{"hands_on_practices": [{"introduction": "A cornerstone of the Fast Multipole Method (FMM) is the translation of multipole expansions to local expansions (M2L), which approximates the influence of a distant source cluster on a target cluster. This approximation's accuracy is controlled by the expansion order $p$. This exercise [@problem_id:3357134] provides direct, hands-on experience in deriving a rigorous upper bound for this M2L translation error from first principles, connecting the abstract mathematics of special functions to a critical, practical decision in FMM design: choosing the minimal expansion order $p$ to guarantee a desired accuracy.", "problem": "Consider the three-dimensional time-harmonic scalar Helmholtz equation in free space with wavenumber $k$, and its associated Green’s function. In a Fast Multipole Method (FMM) setting for computational electromagnetics, sources confined to a spherical box of radius $a$ are aggregated into a truncated multipole expansion of order $p$, translated to a target box at separation at least $Ra$, and then disaggregated into a local expansion. The translation (multipole-to-local) truncation error arises from neglecting terms of degree higher than $p$ in the spherical-wave addition representation of the Green’s function.\n\nStarting from the spherical-wave addition theorem for the Helmholtz Green’s function and using only standard inequalities for spherical Bessel and spherical Hankel functions, derive an explicit upper bound for the translation truncation error between a source cluster contained in $|{\\bf r}'|\\le a$ and a target region $|{\\bf r}|\\ge R$ in terms of $k$, $a$, $R$, and $p$. Then, for a frequency such that $ka=5$ and well-separated boxes such that $R=3a$, choose the smallest integer truncation order $p$ that guarantees the translation error bound does not exceed $\\varepsilon=10^{-6}$.\n\nFinally, evaluate your bound at that $p$ to produce a numerical estimate of the translation error. Provide as your final answer the pair consisting of:\n- the minimal truncation order $p$, and\n- the corresponding numerical value of your error bound,\n\nin that order. Round the error estimate to two significant figures. The error is dimensionless, so report it without units.", "solution": "The user wants to find an upper bound for the translation truncation error in the Fast Multipole Method (FMM) and use it to determine the required truncation order `p` for a given precision.\n\n### Step 1: Problem Validation\n\n*   **Extracted Givens:**\n    *   Equation: Three-dimensional time-harmonic scalar Helmholtz equation.\n    *   Green's function: Free space, wavenumber $k$.\n    *   Methodology: Fast Multipole Method (FMM).\n    *   Source Region: A spherical box of radius $a$, $|{\\bf r}'| \\le a$.\n    *   Target Region: Outside a sphere of radius $R$, $|{\\bf r}| \\ge R$.\n    *   Constraint: $R  a$.\n    *   Error Source: Truncation of the spherical-wave addition theorem for the Green's function, neglecting terms of degree $l  p$.\n    *   Tooling: Standard inequalities for spherical Bessel and spherical Hankel functions.\n    *   Parameters: $ka=5$, $R=3a$.\n    *   Required Precision: Error bound $\\varepsilon \\le 10^{-6}$.\n    *   Task 1: Derive an explicit upper bound for the truncation error in terms of $k$, $a$, $R$, and $p$.\n    *   Task 2: Find the smallest integer $p$ that satisfies the precision requirement for the given parameters.\n    *   Task 3: Evaluate the numerical value of the bound for that $p$.\n\n*   **Validation Analysis:**\n    *   The problem is scientifically grounded in the mathematical physics of wave propagation and standard numerical methods (FMM). The Helmholtz equation, Green's functions, spherical harmonics, and special functions are all core concepts.\n    *   The problem is well-posed. The condition $Ra$ ensures the convergence of the spherical-wave addition theorem, a prerequisite for the method. It asks for the derivation of a bound and a subsequent calculation, which has a unique, verifiable answer.\n    *   The problem is objective, using precise mathematical and physical terminology.\n    *   The setup is consistent and complete, providing all necessary parameters to perform the calculation. The values $ka=5$ and $R=3a$ are typical for FMM applications.\n    *   The problem does not violate any of the invalidity criteria.\n\n*   **Verdict:** The problem is valid.\n\n### Step 2: Derivation of the Error Bound\n\nThe time-harmonic scalar Green's function for the Helmholtz equation in free space is given by $G({\\bf r}, {\\bf r}') = \\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{4\\pi|{\\bf r} - {\\bf r}'|}$. The spherical-wave addition theorem allows this to be expanded for $|{\\bf r}|  |{\\bf r}'|$ as:\n$$\n\\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{|{\\bf r} - {\\bf r}'|} = ik \\sum_{l=0}^{\\infty} (2l+1) \\sum_{m=-l}^{l} j_l(kr') h_l^{(1)}(kr) Y_{lm}(\\hat{r}) Y_{lm}^*(\\hat{r}')\n$$\nHere, $j_l$ is the spherical Bessel function of the first kind, $h_l^{(1)}$ is the spherical Hankel function of the first kind, and $Y_{lm}$ are the spherical harmonics. The expression is often written in terms of Legendre polynomials $P_l$ using the spherical harmonic addition theorem $\\sum_{m=-l}^{l} Y_{lm}(\\hat{r}) Y_{lm}^*(\\hat{r}') = \\frac{2l+1}{4\\pi} P_l(\\hat{r} \\cdot \\hat{r}')$.\n\nThe problem states that the error is dimensionless. This suggests we should consider the error in a dimensionless form of the Green's function expansion. Let us define a dimensionless quantity $g({\\bf r}, {\\bf r}') = \\frac{\\exp(ik|{\\bf r} - {\\bf r}'|)}{ik|{\\bf r} - {\\bf r}'|}$. Its expansion is:\n$$\ng({\\bf r}, {\\bf r}') = \\sum_{l=0}^{\\infty} (2l+1) j_l(kr') h_l^{(1)}(kr) P_l(\\hat{r} \\cdot \\hat{r}')\n$$\nThe truncation error $\\epsilon_p$ is the magnitude of the difference between $g$ and its series truncated at order $p$:\n$$\n\\epsilon_p({\\bf r}, {\\bf r}') = \\left| \\sum_{l=p+1}^{\\infty} (2l+1) j_l(kr') h_l^{(1)}(kr) P_l(\\hat{r} \\cdot \\hat{r}') \\right|\n$$\nTo find an upper bound independent of the specific source and target locations (within the defined regions), we take the maximum over $|{\\bf r}'| \\le a$ and $|{\\bf r}| \\ge R$, and over all angles. Using the triangle inequality and the fact that $|P_l(x)| \\le 1$:\n$$\n\\epsilon_p \\le \\sum_{l=p+1}^{\\infty} (2l+1) \\max_{|{\\bf r}'|\\le a} |j_l(kr')| \\max_{|{\\bf r}|\\ge R} |h_l^{(1)}(kr)|\n$$\nFor $l  ka$, the function $|j_l(x)|$ is increasing for $xl$, so its maximum for $kr' \\le ka$ occurs at $r'=a$. The function $|h_l^{(1)}(x)|$ is decreasing for large $x$, so its maximum for $kr \\ge kR$ occurs at $r=R$. Thus, we have:\n$$\n\\epsilon_p \\le \\sum_{l=p+1}^{\\infty} (2l+1) |j_l(ka)| |h_l^{(1)}(kR)|\n$$\nTo bound this sum, we use standard inequalities for spherical Bessel and Hankel functions valid for large order $l$ compared to their argument:\n$$\n|j_l(x)| \\le \\frac{x^l}{(2l+1)!!} \\quad \\text{and} \\quad |h_l^{(1)}(y)| \\le \\frac{(2l-1)!!}{y^{l+1}}\n$$\nwhere $(2n+1)!! = (2n+1)(2n-1)\\cdots 1$. The product is:\n$$\n|j_l(ka) h_l^{(1)}(kR)| \\le \\frac{(ka)^l}{(2l+1)!!} \\frac{(2l-1)!!}{(kR)^{l+1}} = \\frac{(ka)^l}{(2l+1)(kR)^{l+1}} = \\frac{1}{kR(2l+1)} \\left(\\frac{a}{R}\\right)^l\n$$\nSubstituting this into the sum for the error bound:\n$$\n\\epsilon_p \\le \\sum_{l=p+1}^{\\infty} (2l+1) \\frac{1}{kR(2l+1)} \\left(\\frac{a}{R}\\right)^l = \\frac{1}{kR} \\sum_{l=p+1}^{\\infty} \\left(\\frac{a}{R}\\right)^l\n$$\nThe sum is a geometric series. Let $\\rho = a/R$.\n$$\n\\sum_{l=p+1}^{\\infty} \\rho^l = \\frac{\\rho^{p+1}}{1-\\rho}\n$$\nThus, the explicit upper bound for the translation truncation error is:\n$$\n\\mathcal{B}(p, k, a, R) = \\frac{1}{kR} \\frac{(a/R)^{p+1}}{1 - a/R}\n$$\n\n### Step 3: Calculation of Truncation Order $p$\n\nWe are given the parameters $ka=5$ and $R=3a$. This implies $kR = k(3a) = 3(ka) = 15$, and the ratio $a/R = 1/3$. The required precision is $\\varepsilon = 10^{-6}$. We need to find the smallest integer $p$ such that $\\mathcal{B}(p) \\le 10^{-6}$.\n$$\n\\frac{1}{15} \\frac{(1/3)^{p+1}}{1 - 1/3} \\le 10^{-6}\n$$\n$$\n\\frac{1}{15} \\frac{(1/3)^{p+1}}{2/3} \\le 10^{-6}\n$$\n$$\n\\frac{1}{10} \\left(\\frac{1}{3}\\right)^{p+1} \\le 10^{-6}\n$$\n$$\n\\left(\\frac{1}{3}\\right)^{p+1} \\le 10^{-5}\n$$\n$$\n3^{p+1} \\ge 10^5\n$$\nTaking the base-10 logarithm of both sides:\n$$\n(p+1) \\log_{10}(3) \\ge 5\n$$\n$$\np+1 \\ge \\frac{5}{\\log_{10}(3)} \\approx \\frac{5}{0.47712} \\approx 10.479\n$$\nSince $p+1$ must be an integer, the smallest value it can take is $11$.\n$$\np+1 = 11 \\implies p = 10\n$$\nThe minimal integer truncation order is $p=10$.\n\n### Step 4: Evaluation of the Error Bound\n\nFinally, we evaluate the derived bound $\\mathcal{B}(p)$ for $p=10$ using the given parameters.\n$$\n\\mathcal{B}(10) = \\frac{1}{10} \\left(\\frac{1}{3}\\right)^{10+1} = \\frac{1}{10} \\left(\\frac{1}{3}\\right)^{11} = \\frac{1}{10 \\times 177147} = \\frac{1}{1771470}\n$$\n$$\n\\mathcal{B}(10) \\approx 5.6449... \\times 10^{-7}\n$$\nRounding this numerical estimate to two significant figures, we get $5.6 \\times 10^{-7}$.\n\nThe final answer consists of the pair $(p, \\mathcal{B}(p))$, which is $(10, 5.6 \\times 10^{-7})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n10  5.6 \\times 10^{-7}\n\\end{pmatrix}\n}\n$$", "id": "3357134"}, {"introduction": "Before assembling a full FMM hierarchy, it is crucial to validate the fundamental operators that form its foundation. This practice focuses on a powerful reciprocity-based self-test for the Local-to-Point (L2P) and Point-to-Multipole (P2M) operators. By creating a known field from a local expansion, sampling it on a circle, and then aggregating those samples back into a multipole expansion, you can verify if a power-like quantity is conserved, which is a strong indicator of a correct implementation. This exercise [@problem_id:3357105] not only builds confidence in your code but also provides deep insight into the role of the discrete Fourier transform and the Nyquist sampling criterion in maintaining the integrity of the field representation.", "problem": "Consider a two-dimensional time-harmonic field governed by the scalar Helmholtz equation in a homogeneous medium, expressed as $\\nabla^2 u + k^2 u = 0$, where $u$ is a complex-valued field and $k$ is the wavenumber. In the Fast Multipole Method (FMM), two fundamental operators are used: the Local-to-Point (L2P) operator, which evaluates a local expansion at specified target points, and the Point-to-Multipole (P2M) operator, which aggregates point data into a multipole expansion about a chosen center. You will construct a reciprocity-based self-test on a closed circular surface that assesses whether the composition of L2P followed by P2M approximately conserves a surface-averaged power-like quadratic quantity to within a specified tolerance $\\epsilon$.\n\nAssume a circular surface of radius $R_s$ centered at the origin. Work strictly in polar coordinates $(r,\\theta)$ with $\\theta$ measured in radians. Use separation of variables for the scalar Helmholtz equation and the standard cylindrical basis functions that arise from this separation. Assume a bandlimited local expansion of order $p$ about the origin inside the circle, and an outgoing multipole expansion of order $p$ about the origin outside the circle. Use $N$ equally spaced samples on the circular surface at angles $\\theta_m = \\frac{2\\pi m}{N}$ for integer $m \\in \\{0,1,\\dots,N-1\\}$.\n\nDefine the surface-averaged quadratic quantity as the angular average of the squared magnitude of the field sampled on the circle, namely $P_{\\text{surf}} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(R_s,\\theta)|^2 \\, d\\theta$. Your program must implement the following test protocol:\n\n- Construct a local expansion at the origin with coefficients $b_n$ for integer indices $n$ such that $|n| \\leq p$. The coefficients are given deterministically by $b_n = \\exp(-\\alpha |n|) \\exp(i n \\delta)$ for real parameters $\\alpha  0$ and $\\delta$ in radians.\n- Apply the Local-to-Point (L2P) operator to evaluate the field on the circle of radius $R_s$ at the sampling angles $\\theta_m$, resulting in samples $u_m = u(R_s,\\theta_m)$.\n- From the sampled values $u_m$ on the circle, apply the Point-to-Multipole (P2M) operator to determine the outgoing multipole coefficients $a_n$ about the origin for the same bandlimit $|n| \\leq p$. Use separation-of-variables and orthogonality on the circle to perform this aggregation in a mathematically consistent manner.\n- Compute the discrete approximation to $P_{\\text{surf}}$ using the trapezoidal rule on the uniform angular grid, i.e., replace the angular integral by the uniform average of $|u_m|^2$ over the samples.\n- Using the outgoing multipole coefficients $a_n$, compute a corresponding reconstruction of the surface-averaged quadratic quantity in a way that is consistent with the separation-of-variables representation on the circle and the orthogonality of the angular basis. The exact formula must be derived from first principles; do not assume shortcut identities without justification.\n- Report whether the relative difference between the two computed quadratic quantities does not exceed the specified tolerance $\\epsilon$, i.e., whether $\\frac{|P_{\\text{out}} - P_{\\text{surf}}|}{\\max(P_{\\text{surf}},\\eta)} \\leq \\epsilon$, where $P_{\\text{out}}$ is the quantity computed from the outgoing multipole representation and $\\eta$ is a small positive constant introduced only to prevent division by zero if $P_{\\text{surf}}$ vanishes.\n\nAngles must be treated in radians, and all quantities are dimensionless. Use cylindrical functions appropriate to the scalar Helmholtz setting. The program must implement this test for each parameter set in the provided test suite and produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nTest suite:\n- Case 1 (happy path): $k = 3.0$, $R_s = 1.0$, $p = 6$, $N = 64$, $\\alpha = 0.4$, $\\delta = 0.3$, $\\epsilon = 10^{-10}$.\n- Case 2 (minimal sampling boundary): $k = 5.0$, $R_s = 0.7$, $p = 10$, $N = 21$, $\\alpha = 0.25$, $\\delta = 0.5$, $\\epsilon = 10^{-9}$.\n- Case 3 (under-resolved edge case): $k = 8.0$, $R_s = 1.2$, $p = 12$, $N = 16$, $\\alpha = 0.3$, $\\delta = 0.1$, $\\epsilon = 10^{-6}$.\n- Case 4 (zeroth-order sanity check): $k = 2.0$, $R_s = 0.5$, $p = 0$, $N = 8$, $\\alpha = 0.6$, $\\delta = 0.0$, $\\epsilon = 10^{-12}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is a boolean indicating whether the reciprocity-based power conservation test passed for that case.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of wave propagation and numerical methods, specifically the Fast Multipole Method (FMM). It is well-posed, with all necessary parameters and procedures defined, leading to a unique and verifiable solution. The language is objective and precise.\n\nThe core of the problem is a self-consistency test for the Local-to-Point (L2P) and Point-to-Multipole (P2M) operators within the context of the two-dimensional scalar Helmholtz equation, $(\\nabla^2 + k^2)u = 0$, where $k$ is the wavenumber. The test is performed on a circular boundary.\n\nFirst, we establish the mathematical framework based on separation of variables in polar coordinates $(r, \\theta)$. Solutions to the Helmholtz equation can be expressed as a series of cylindrical basis functions.\n\nA local expansion, representing a field regular at the origin, is constructed using Bessel functions of the first kind, $J_n(z)$. For a bandlimit of order $p$, this expansion is:\n$$u_{\\text{loc}}(r, \\theta) = \\sum_{n=-p}^{p} b_n J_n(kr) e^{in\\theta}$$\nHere, $b_n$ are the local expansion coefficients, given by the deterministic formula $b_n = \\exp(-\\alpha |n|) \\exp(i n \\delta)$.\n\nAn outgoing multipole expansion, representing a field that radiates outwards and satisfies the Sommerfeld radiation condition, is constructed using Hankel functions of the first kind, $H_n^{(1)}(z)$:\n$$u_{\\text{out}}(r, \\theta) = \\sum_{n=-p}^{p} a_n H_n^{(1)}(kr) e^{in\\theta}$$\nwhere $a_n$ are the outgoing multipole expansion coefficients. The identities $J_{-n}(z) = (-1)^n J_n(z)$ and $H_{-n}^{(1)}(z) = (-1)^n H_n^{(1)}(z)$ are used for negative indices $n$.\n\nThe test protocol involves a sequence of operations:\n\n1.  **L2P (Local-to-Point) Operation**: We evaluate the local expansion on a circular surface of radius $R_s$ at $N$ equally spaced points with angles $\\theta_m = \\frac{2\\pi m}{N}$ for $m \\in \\{0, 1, \\dots, N-1\\}$. The resulting field samples $u_m$ are:\n    $$u_m = u_{\\text{loc}}(R_s, \\theta_m) = \\sum_{n=-p}^{p} b_n J_n(kR_s) e^{in\\theta_m}$$\n\n2.  **Surface-Averaged Power, $P_{\\text{surf}}$**: The problem defines a surface-averaged quadratic quantity $P_{\\text{surf}} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(R_s, \\theta)|^2 d\\theta$. We compute its discrete approximation using the trapezoidal rule on our uniform angular grid. With an angular step of $\\Delta\\theta = \\frac{2\\pi}{N}$, this becomes:\n    $$P_{\\text{surf}} \\approx \\frac{1}{N} \\sum_{m=0}^{N-1} |u_m|^2$$\n\n3.  **P2M (Point-to-Multipole) Operation**: We determine the outgoing multipole coefficients $a_n$ from the field samples $u_m$. This involves an inverse operation: finding the coefficients of the Fourier series representation of the field on the circle. Using the orthogonality of the complex exponentials, the continuous relationship is $a_n H_n^{(1)}(kR_s) = \\frac{1}{2\\pi} \\int_0^{2\\pi} u(R_s, \\theta) e^{-in\\theta} d\\theta$. Discretizing this integral (which is equivalent to performing a Discrete Fourier Transform analysis) yields:\n    $$a_n \\approx \\frac{1}{N H_n^{(1)}(kR_s)} \\sum_{m=0}^{N-1} u_m e^{-in\\theta_m}$$\n    This formula allows us to aggregate the point data $\\{u_m\\}$ into a set of multipole coefficients $\\{a_n\\}$.\n\n4.  **Reconstructed Power, $P_{\\text{out}}$**: We compute the analogous surface-averaged power using the derived multipole coefficients $a_n$. By substituting the outgoing expansion into the integral definition of $P_{\\text{surf}}$ and applying Parseval's theorem for Fourier series, we obtain an expression in terms of the coefficients:\n    $$P_{\\text{out}} = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\left| \\sum_{n=-p}^{p} a_n H_n^{(1)}(kR_s) e^{in\\theta} \\right|^2 d\\theta = \\sum_{n=-p}^{p} |a_n H_n^{(1)}(kR_s)|^2 = \\sum_{n=-p}^{p} |a_n|^2 |H_n^{(1)}(kR_s)|^2$$\n\n5.  **Reciprocity Check**: The final step is to compare $P_{\\text{surf}}$ and $P_{\\text{out}}$. The consistency of these two quantities depends critically on the sampling rate $N$. If the sampling is sufficient to resolve all modes in the expansion, i.e., if the Nyquist criterion $N \\ge 2p+1$ is met, then the discrete Fourier transform accurately captures the continuum-level orthogonality. In this well-resolved regime, the relationship between the coefficients is $a_n = b_n \\frac{J_n(kR_s)}{H_n^{(1)}(kR_s)}$. Substituting this into the expression for $P_{\\text{out}}$ demonstrates that, theoretically, $P_{\\text{out}} = \\sum |b_n|^2 |J_n(kR_s)|^2$, which is identical to the exact value of $P_{\\text{surf}}$ derived from the local expansion via Parseval's theorem. Therefore, for $N \\ge 2p+1$, we expect $\\frac{|P_{\\text{out}} - P_{\\text{surf}}|}{\\max(P_{\\text{surf}},\\eta)} \\le \\epsilon$.\n    However, if $N  2p+1$, the discrete Fourier analysis suffers from aliasing. High-frequency components (large $|n|$) are incorrectly mapped to low-frequency components, breaking the simple relationship between $a_n$ and $b_n$. This introduces a significant error, and the test is expected to fail. The parameter $\\eta$ is a small regularization constant to prevent division by zero.", "answer": "```python\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\n# Set a small constant to prevent division by zero in the relative error calculation.\nETA = 1e-30\n\ndef reciprocity_test(k, Rs, p, N, alpha, delta, epsilon):\n    \"\"\"\n    Performs the reciprocity-based self-test for a given set of parameters.\n\n    The test follows these steps:\n    1.  Construct local expansion coefficients 'b_n'.\n    2.  Perform L2P: Evaluate the field 'u_m' on a circle from 'b_n'.\n    3.  Calculate the surface-averaged power 'P_surf' from 'u_m'.\n    4.  Perform P2M: Aggregate 'u_m' to get outgoing multipole coefficients 'a_n'.\n    5.  Calculate the reconstructed power 'P_out' from 'a_n'.\n    6.  Compare 'P_surf' and 'P_out' to check for conservation.\n    \"\"\"\n\n    # --- Step 1: Construct local expansion coefficients 'b_n' ---\n    # The modes/indices 'n' range from -p to p.\n    n_vals = np.arange(-p, p + 1)\n    b_n = np.exp(-alpha * np.abs(n_vals)) * np.exp(1j * n_vals * delta)\n\n    # --- Step 2: L2P (Local-to-Point) Operation ---\n    # Evaluate the local expansion on a circle of radius Rs.\n    # The field u(r, theta) is sum(b_n * J_n(kr) * exp(i*n*theta)).\n    \n    # Angular sample points\n    theta_m = (2 * np.pi / N) * np.arange(N)\n\n    # Calculate Bessel functions J_n(k*Rs). scipy.special.jv handles negative n.\n    jv_vals = jv(n_vals, k * Rs)\n    \n    # Coefficients of the Fourier series for the field on the circle\n    field_coeffs = b_n * jv_vals\n\n    # Evaluate the field samples u_m by synthesizing the Fourier series.\n    # This is an inverse discrete Fourier transform. A matrix-vector product is efficient.\n    # kernel[m, i] = exp(i * n_vals[i] * theta_m[m])\n    kernel_l2p = np.exp(1j * np.outer(theta_m, n_vals))\n    u_m = kernel_l2p @ field_coeffs\n\n    # --- Step 3: Calculate P_surf ---\n    # Approximate the surface-averaged power using the trapezoidal rule on the samples.\n    # P_surf = (1/N) * sum(|u_m|^2)\n    P_surf = np.mean(np.abs(u_m)**2)\n\n    # --- Step 4: P2M (Point-to-Multipole) Operation ---\n    # Aggregate point samples u_m into outgoing multipole coefficients a_n.\n    # a_n = (1 / (N * H_n(kRs))) * sum(u_m * exp(-i*n*theta_m))\n\n    # Calculate Hankel functions H_n^(1)(k*Rs). scipy.special.hankel1 handles negative n.\n    hankel1_vals = hankel1(n_vals, k * Rs)\n    \n    # The sum is a discrete Fourier transform analysis.\n    # kernel[i, m] = exp(-i * n_vals[i] * theta_m[m])\n    kernel_p2m = np.exp(-1j * np.outer(n_vals, theta_m))\n    fourier_sum = kernel_p2m @ u_m\n    \n    # Calculate a_n, handling potential division by zero for Hankel functions\n    # (though H_n^(1)(z) is zero only for z=0, which is not the case here).\n    a_n = fourier_sum / (N * hankel1_vals)\n\n    # --- Step 5: Calculate P_out ---\n    # Reconstruct the surface-averaged power from the multipole coefficients.\n    # P_out = sum(|a_n * H_n(kRs)|^2)\n    P_out = np.sum(np.abs(a_n * hankel1_vals)**2)\n    \n    # --- Step 6: Compare and return result ---\n    # Check if the relative difference is within the tolerance epsilon.\n    relative_diff = np.abs(P_out - P_surf) / max(P_surf, ETA)\n    \n    return relative_diff = epsilon\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (k, Rs, p, N, alpha, delta, epsilon)\n        (3.0, 1.0, 6, 64, 0.4, 0.3, 1e-10),  # Case 1: Well-resolved\n        (5.0, 0.7, 10, 21, 0.25, 0.5, 1e-9),   # Case 2: Nyquist boundary\n        (8.0, 1.2, 12, 16, 0.3, 0.1, 1e-6),   # Case 3: Under-resolved (aliased)\n        (2.0, 0.5, 0, 8, 0.6, 0.0, 1e-12)    # Case 4: Zeroth-order check\n    ]\n\n    results = []\n    for case in test_cases:\n        k, Rs, p, N, alpha, delta, epsilon = case\n        result = reciprocity_test(k, Rs, p, N, alpha, delta, epsilon)\n        results.append(str(result).lower())\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3357105"}, {"introduction": "The efficiency of the FMM hinges on its ability to distinguish between \"near\" interactions, which are computed directly, and \"far\" interactions, where fast translation operators are used. The boundary between near and far is not arbitrary; it must be determined by a strict error criterion to ensure the method's overall accuracy. This practice [@problem_id:3357113] challenges you to design and implement this critical near-far switching logic. By computing a reliable error proxy and using numerical root-finding to determine the precise separation distance that meets a given tolerance, you will be performing a core task in the development of a robust and adaptive FMM code.", "problem": "You are asked to design a robust near–far switching criterion for the Fast Multipole Method (FMM) in the context of the Helmholtz equation used in computational electromagnetics. The switching is between direct interactions and multipole/local expansions based on guaranteed cluster separation. The target is to ensure that multipole-to-local (M2L) translations are used only when the truncation error bound of the spherical Hankel expansion tail is below a user-specified tolerance. You must construct the criterion in a way that is valid for complex wavenumbers and then compute the minimal switching distances that achieve a specified error tolerance.\n\nStart from the fundamental base that the time-harmonic free-space Green’s function of the scalar Helmholtz equation is given by $G(\\mathbf{r},\\mathbf{r}')=\\dfrac{\\exp(i k \\|\\mathbf{r}-\\mathbf{r}'\\|)}{\\|\\mathbf{r}-\\mathbf{r}'\\|}$ where $k \\in \\mathbb{C}$ is the wavenumber with $\\operatorname{Im}(k) \\ge 0$ for passive media. Use the well-tested addition theorem expressing $G$ as a convergent spherical wave expansion involving the spherical Bessel function $j_n$ and the spherical Hankel function of the first kind $h_n^{(1)}$. For two disjoint balls (clusters) containing sources and targets, centered along a line with center-to-center separation $R$, with source ball radius $a_s$ and target ball radius $a_t$, guaranteed separation requires $R  a_s + a_t$. In this separated configuration, the addition theorem expansion converges absolutely and the tail for orders $n  p$ can be bounded using the triangle inequality applied to the spherical Bessel and Hankel terms evaluated at worst-case radii $r_ = a_s$ and $r_ = R - a_t$.\n\nDefine the truncation error proxy for the M2L translation at order $p$ by\n$$\nE_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,r_)\\,h_n^{(1)}(k\\,r_)\\big|,\n$$\nwhich is a dimensionless bound derived from the addition theorem’s tail after summing over azimuthal degrees and applying the triangle inequality. In this problem, you will compute a numerically rigorous approximation of $E_p$ by summation until terms are sufficiently small, leveraging the known behavior of spherical Bessel and Hankel functions for complex arguments via their relationship to ordinary Bessel and Hankel functions.\n\nYour tasks:\n- Given $k \\in \\mathbb{C}$, $a_s \\in \\mathbb{R}_+$, $a_t \\in \\mathbb{R}_+$, an integer expansion order $p \\ge 0$, and an error tolerance $\\varepsilon \\in \\mathbb{R}_+$, design a near–far switching criterion that uses multipole/local expansions if and only if $E_p(R;k,a_s,a_t) \\le \\varepsilon$ with $R  a_s + a_t$, and otherwise uses direct interactions.\n- For each test case, compute the minimal switching distance $R_{\\text{switch}}$ (in meters) defined by the smallest $R$ strictly greater than $a_s + a_t$ such that $E_p(R;k,a_s,a_t) \\le \\varepsilon$. Use a numerically stable search procedure justified by the monotonic decay of the tail bound with increasing $R$ under guaranteed separation.\n- Your program must implement the spherical Hankel $h_n^{(1)}$ and spherical Bessel $j_n$ for complex arguments via their relationship to ordinary Bessel functions:\n$$\nj_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\tfrac{1}{2}}(z), \\quad\nh_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\tfrac{1}{2}}^{(1)}(z),\n$$\nand must numerically approximate the infinite tail sum to a stringent internal tolerance. You must ensure correctness by using worst-case radii $r_ = a_s$ and $r_ = R - a_t$, which correspond to the aggregation (source-to-multipole, S2M) and disaggregation (local-to-target, L2T) operators’ extremal geometric configuration within FMM’s translation chain. The translation operator (multipole-to-local, M2L) is the sole contributor to $E_p$ in this bound.\n\nUnits and output:\n- Use meters for distances and radians per meter for $k$.\n- Express all distances in meters.\n- Angles are not directly required; when present, they must be in radians.\n- For each test case, output the computed $R_{\\text{switch}}$ as a float rounded to five decimal places.\n\nTest suite:\n- Case $1$: $k = \\dfrac{2\\pi}{0.5}\\,\\text{rad/m}$, $a_s = 0.1\\,\\text{m}$, $a_t = 0.1\\,\\text{m}$, $p = 10$, $\\varepsilon = 10^{-6}$.\n- Case $2$ (boundary-sensitive): $k = 20\\,\\text{rad/m}$, $a_s = 0.2\\,\\text{m}$, $a_t = 0.2\\,\\text{m}$, $p = 6$, $\\varepsilon = 10^{-4}$.\n- Case $3$ (attenuative medium): $k = 30 + 5 i\\,\\text{rad/m}$, $a_s = 0.15\\,\\text{m}$, $a_t = 0.1\\,\\text{m}$, $p = 8$, $\\varepsilon = 10^{-8}$.\n- Case $4$ (high frequency, low order): $k = 100\\,\\text{rad/m}$, $a_s = 0.05\\,\\text{m}$, $a_t = 0.05\\,\\text{m}$, $p = 5$, $\\varepsilon = 10^{-5}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where $r_i$ are the computed $R_{\\text{switch}}$ values for the test cases in meters, each rounded to five decimal places.", "solution": "The user problem has been validated and is outlined below.\n\n### Step 1: Extract Givens\n- **Green's function**: $G(\\mathbf{r},\\mathbf{r}')=\\dfrac{\\exp(i k \\|\\mathbf{r}-\\mathbf{r}'\\|)}{\\|\\mathbf{r}-\\mathbf{r}'\\|}$\n- **Wavenumber**: $k \\in \\mathbb{C}$ with $\\operatorname{Im}(k) \\ge 0$.\n- **Cluster Geometry**: Source ball radius $a_s$, target ball radius $a_t$, center-to-center separation $R$.\n- **Separation Condition**: $R  a_s + a_t$.\n- **Truncation Error Proxy**: $E_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,r_)\\,h_n^{(1)}(k\\,r_)\\big|$.\n- **Worst-case Radii**: $r_ = a_s$ and $r_ = R - a_t$.\n- **Switching Criterion**: Use multipole/local expansions if and only if $E_p(R;k,a_s,a_t) \\le \\varepsilon$ for $R  a_s + a_t$.\n- **Objective**: Compute the minimal switching distance $R_{\\text{switch}}$, the smallest $R  a_s + a_t$ such that $E_p(R;k,a_s,a_t) \\le \\varepsilon$.\n- **Special Function Definitions**:\n  - Spherical Bessel function: $j_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\tfrac{1}{2}}(z)$.\n  - Spherical Hankel function of the first kind: $h_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\tfrac{1}{2}}^{(1)}(z)$.\n- **Test Cases**:\n  - Case $1$: $k = \\dfrac{2\\pi}{0.5}\\,\\text{rad/m}$, $a_s = 0.1\\,\\text{m}$, $a_t = 0.1\\,\\text{m}$, $p = 10$, $\\varepsilon = 10^{-6}$.\n  - Case $2$: $k = 20\\,\\text{rad/m}$, $a_s = 0.2\\,\\text{m}$, $a_t = 0.2\\,\\text{m}$, $p = 6$, $\\varepsilon = 10^{-4}$.\n  - Case $3$: $k = 30 + 5 i\\,\\text{rad/m}$, $a_s = 0.15\\,\\text{m}$, $a_t = 0.1\\,\\text{m}$, $p = 8$, $\\varepsilon = 10^{-8}$.\n  - Case $4$: $k = 100\\,\\text{rad/m}$, $a_s = 0.05\\,\\text{m}$, $a_t = 0.05\\,\\text{m}$, $p = 5$, $\\varepsilon = 10^{-5}$.\n- **Output**: A comma-separated list of $R_{\\text{switch}}$ values for each test case, rounded to five decimal places, enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the standard formulation of the Fast Multipole Method (FMM) for the scalar Helmholtz equation. The Green's function, the addition theorem for spherical waves, the definitions of spherical Bessel and Hankel functions, and the concept of a truncation error bound for multipole-to-local (M2L) operators are all fundamental and correct principles in computational electromagnetics and mathematical physics.\n- **Well-Posed**: The problem is well-posed. It requires finding the minimal distance $R_{\\text{switch}}$ that satisfies an error tolerance. The error function $E_p(R)$ is a function of the separation distance $R$. For separated clusters ($R  a_s + a_t$), the magnitude of the terms $|j_n(k a_s) h_n^{(1)}(k(R-a_t))|$ decreases as $R$ increases since $|h_n^{(1)}(z)|$ decays with $|z|$. This ensures that $E_p(R)$ is a monotonically decreasing function of $R$. Therefore, for a given tolerance $\\varepsilon$, there exists a unique solution to the equation $E_p(R) = \\varepsilon$, which can be found using standard numerical root-finding algorithms.\n- **Objective**: The problem is stated in precise mathematical and algorithmic terms. The goal is to compute a specific numerical quantity based on a given set of formulas and parameters, which is an entirely objective task.\n\nThe problem does not exhibit any of the flaws listed in the validation criteria (e.g., scientific unsoundness, ambiguity, missing information). The provided parameters are physically and dimensionally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be developed.\n\n### Solution and Algorithmic Design\n\nThe core task is to determine the near-far switching distance $R_{\\text{switch}}$ for a Fast Multipole Method implementation. This distance is defined as the minimum separation $R$ between two clusters (a source cluster of radius $a_s$ and a target cluster of radius $a_t$) for which the M2L translation error, estimated by the proxy $E_p(R)$, falls below a specified tolerance $\\varepsilon$. The governing equation is $E_p(R_{\\text{switch}}) = \\varepsilon$, subject to the geometric constraint $R_{\\text{switch}}  a_s + a_t$.\n\nThe solution consists of three main components:\n1.  A function to numerically evaluate the truncation error proxy $E_p(R)$.\n2.  Implementation of the required special functions, namely the spherical Bessel and Hankel functions for complex arguments.\n3.  A numerical root-finding procedure to solve for $R_{\\text{switch}}$.\n\n**1. Evaluating the Truncation Error Proxy $E_p(R)$**\n\nThe error proxy is given by the infinite series:\n$$\nE_p(R;k,a_s,a_t) = \\sum_{n=p+1}^{\\infty} (2n+1)\\,\\big|j_n(k\\,a_s)\\,h_n^{(1)}(k(R-a_t))\\big|\n$$\nwhere $r_ = a_s$ and $r_ = R - a_t$ represent the worst-case radii for sources and targets within their respective clusters. To compute this numerically, the infinite sum must be truncated. The convergence of the addition theorem is guaranteed for $R  a_s + a_t$, which implies that the terms of the series must decay to zero for large $n$. The terms decay geometrically at a rate related to the ratio $|a_s / (R-a_t)|  1$. We will approximate the sum by summing a finite number of terms, $n$ from $p+1$ to a sufficiently large upper bound $n_{\\text{max}}$. A conservative choice of $n_{\\text{max}} = p + 50$ ensures that the neglected tail of the series is orders of magnitude smaller than the required precision for all test cases.\n\n**2. Implementing Spherical Functions**\n\nThe spherical Bessel function $j_n(z)$ and Hankel function $h_n^{(1)}(z)$ are computed for complex arguments $z$ using their definitions in terms of ordinary half-integer order Bessel and Hankel functions, which are available in the `scipy.special` library:\n-   $j_n(z) = \\sqrt{\\frac{\\pi}{2z}} J_{n+\\frac{1}{2}}(z)$, implemented using `scipy.special.jv`.\n-   $h_n^{(1)}(z) = \\sqrt{\\frac{\\pi}{2z}} H_{n+\\frac{1}{2}}^{(1)}(z)$, implemented using `scipy.special.hankel1`.\n\nThese functions will be called within the summation loop for the error calculation, with arguments $z_j = k a_s$ and $z_h = k (R-a_t)$.\n\n**3. Root-Finding for $R_{\\text{switch}}$**\n\nThe problem of finding $R_{\\text{switch}}$ translates to finding the root of the function $f(R) = E_p(R) - \\varepsilon = 0$. As established, $E_p(R)$ decreases monotonically for $R  a_s + a_t$. This property makes the problem ideal for a bracketing root-finding algorithm like the Brent-Dekker method, available as `scipy.optimize.brentq`.\n\nThe algorithm for each test case is as follows:\na. Define the objective function `objective_func(R)` which returns $E_p(R) - \\varepsilon$.\nb. Establish the absolute lower limit for the search, $R_{\\text{min}} = a_s + a_t$.\nc. Check the value of `objective_func` at a point $R$ slightly greater than $R_{\\text{min}}$. If it is negative, it means $E_p(R)  \\varepsilon$ for all valid $R$. In this scenario, the multipole expansion is always sufficiently accurate, and the switching distance is effectively the boundary of geometric validity itself, so $R_{\\text{switch}} = a_s + a_t$.\nd. If the function is positive at the lower limit, find a search bracket $[R_a, R_b]$ such that $f(R_a)  0$ and $f(R_b)  0$. We can set $R_a$ to be slightly greater than $R_{\\text{min}}$. Then, we find an upper bound $R_b$ by starting with a guess (e.g., $R_b = 2 R_a$) and iteratively doubling it until the sign of $f(R_b)$ becomes negative.\ne. With a valid bracket, call `scipy.optimize.brentq` to find the root $R_{\\text{switch}}$ with high precision.\nf. The final result is rounded to five decimal places as required.\n\nThis systematic approach guarantees a robust and accurate computation of the switching distance for each of the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the minimal switching distance R_switch for each test case.\n    \"\"\"\n\n    def spherical_jn(n, z):\n        \"\"\"\n        Computes the spherical Bessel function of the first kind j_n(z)\n        for integer order n and complex argument z.\n        \"\"\"\n        # For z=0, j_0(0) = 1 and j_n(0) = 0 for n  0.\n        if z == 0:\n            return 1.0 if n == 0 else 0.0\n        return np.sqrt(np.pi / (2.0 * z)) * jv(n + 0.5, z)\n\n    def spherical_h1n(n, z):\n        \"\"\"\n        Computes the spherical Hankel function of the first kind h_n^(1)(z)\n        for integer order n and complex argument z.\n        \"\"\"\n        # h_n^(1)(z) has a singularity at z=0.\n        if z == 0:\n            return np.complex(np.inf, -np.inf)\n        return np.sqrt(np.pi / (2.0 * z)) * hankel1(n + 0.5, z)\n\n    def calculate_error_proxy(R, k, a_s, a_t, p):\n        \"\"\"\n        Calculates the truncation error proxy E_p for the M2L translation.\n        \"\"\"\n        # The separation must be guaranteed, R  a_s + a_t.\n        # If not, the expansion doesn't converge, error is infinite.\n        if R = a_s + a_t:\n            return np.inf\n\n        r_less = a_s\n        r_great = R - a_t\n\n        z_j = k * r_less\n        z_h = k * r_great\n\n        # Sum a sufficient number of terms in the tail of the series.\n        # p + 50 is a conservative choice that guarantees convergence\n        # to a high precision for the given test cases.\n        n_max = p + 50\n        \n        total_error = 0.0\n        # The sum starts from n = p + 1.\n        for n in range(p + 1, n_max + 1):\n            term = (2 * n + 1) * np.abs(spherical_jn(n, z_j) * spherical_h1n(n, z_h))\n            total_error += term\n            # A dynamic convergence check could be used for optimization,\n            # but a fixed large number of terms is robust.\n        \n        return total_error\n\n    def find_switching_distance(k, a_s, a_t, p, epsilon):\n        \"\"\"\n        Finds the minimal R  a_s + a_t such that E_p(R) = epsilon.\n        \"\"\"\n        R_min = a_s + a_t\n\n        def objective_func(R):\n            \"\"\"The function whose root we want to find: E_p(R) - epsilon = 0.\"\"\"\n            return calculate_error_proxy(R, k, a_s, a_t, p) - epsilon\n\n        # Check if the error is already below the tolerance at minimal separation.\n        # Use a small delta to ensure R  R_min.\n        try:\n            val_at_min_R = objective_func(R_min * (1.0 + 1e-12))\n        except (ValueError, TypeError): # Can happen if functions misbehave at boundary\n             val_at_min_R = np.inf\n\n        if val_at_min_R  0:\n            # If error is already low, the switching distance is the minimum possible.\n            return R_min\n\n        # Establish a search bracket [R_a, R_b] for the root-finder.\n        # R_a is the lower bound, slightly perturbed from R_min.\n        R_a = R_min * (1.0 + 1e-9)\n\n        # Find an upper bound R_b where the objective function is negative.\n        # Start with a reasonable guess and expand the interval if needed.\n        R_b = 2.0 * R_a if R_a > 1e-9 else 1.0 # Handle R_min=0 case\n        safety_counter = 0\n        while objective_func(R_b) > 0:\n            R_b *= 2.0\n            safety_counter += 1\n            if safety_counter > 50: # Avoid infinite loop\n                raise RuntimeError(\n                    f\"Could not find an upper bracket for root search for case \"\n                    f\"(k={k}, a_s={a_s}, a_t={a_t}, p={p}, eps={epsilon}).\"\n                )\n\n        # Use Brent's method to find the root with high tolerance.\n        R_switch = brentq(objective_func, R_a, R_b, xtol=1e-12, rtol=1e-12)\n        return R_switch\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.0 * np.pi / 0.5, 0.1, 0.1, 10, 1e-6),\n        (20.0, 0.2, 0.2, 6, 1e-4),\n        (30.0 + 5.0j, 0.15, 0.1, 8, 1e-8),\n        (100.0, 0.05, 0.05, 5, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_val, a_s_val, a_t_val, p_val, eps_val = case\n        r_switch = find_switching_distance(k_val, a_s_val, a_t_val, p_val, eps_val)\n        # Round the final result to 5 decimal places as specified.\n        results.append(f\"{r_switch:.5f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3357113"}]}