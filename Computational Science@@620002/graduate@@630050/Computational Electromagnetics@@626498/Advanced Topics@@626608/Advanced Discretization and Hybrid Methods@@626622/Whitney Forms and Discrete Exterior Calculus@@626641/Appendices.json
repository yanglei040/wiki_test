{"hands_on_practices": [{"introduction": "The foundation of discrete exterior calculus (DEC) lies in its ability to replicate the core algebraic structure of continuous exterior calculus on a discrete mesh. The most fundamental of these is the property that the boundary of a boundary is zero, denoted $ \\partial^2 = 0 $, which leads to the analogous property $ d^2 = 0 $ for the exterior derivative. This practice [@problem_id:3361221] provides a crucial, hands-on algorithmic exercise in building the discrete boundary operators from a simplicial mesh and ensuring this property holds by correctly normalizing the orientation of edges and faces. Mastering this is the first step toward constructing any valid DEC-based simulation.", "problem": "You are given a finite simplicial mesh composed of oriented triangles. The goal is to construct a discrete exterior calculus (DEC) representation of the coboundary operators for Whitney forms, ensuring that the algebraic condition $ \\delta^2 = 0 $ holds in the resulting complex. Discrete Exterior Calculus (DEC) uses cochains to represent discrete differential forms and the coboundary operator $ \\delta $ as a matrix representation of the discrete exterior derivative. For a simplicial complex with vertices, edges, and triangular faces, the boundary operators $ \\partial_1 $ and $ \\partial_2 $ are represented by incidence matrices $ B_1 \\in \\mathbb{Z}^{n_0 \\times n_1} $ and $ B_2 \\in \\mathbb{Z}^{n_1 \\times n_2} $, where $ n_0 $, $ n_1 $, and $ n_2 $ denote the number of vertices, edges, and faces, respectively. The discrete coboundary operators for cochains are given by $ \\delta_0 = B_1^\\top $ and $ \\delta_1 = B_2^\\top $. The requirement $ \\delta_1 \\delta_0 = 0 $ is equivalent to the chain condition $ B_1 B_2 = 0 $, which relies on proper orientation normalization of edges and faces.\n\nStarting from the following fundamental base:\n- The boundary operator $ \\partial_k $ maps oriented $ k $-chains to oriented $ (k-1) $-chains and satisfies $ \\partial_{k-1} \\circ \\partial_k = 0 $, i.e., $ \\partial^2 = 0 $.\n- The coboundary operator $ \\delta_k $ on $ k $-cochains is the transpose of the boundary operator, i.e., $ \\delta_k = \\partial_{k+1}^\\top $.\n- For an oriented edge $ (i,j) $ with $ i < j $, the boundary is $ \\partial_1(i,j) = v_j - v_i $.\n- For an oriented triangular face $ (i,j,k) $, the boundary is $ \\partial_2(i,j,k) = (i,j) + (j,k) + (k,i) $ with each term signed according to compatibility with global edge orientation.\n\nDesign and implement an algorithm that, given a mesh specified by a number of vertices and a list of faces (each face as an ordered triple of vertex indices indicating its orientation), performs the following:\n1. Normalize all edge orientations by adopting the convention that each edge $ \\{i,j\\} $ is oriented from the lower index to the higher index, i.e., $ (i,j) $ with $ i < j $.\n2. Normalize face orientations across the mesh to be globally consistent on connected components: for any two adjacent faces sharing an edge, the induced orientations along that shared edge must be opposite. If needed, flip the orientation of faces to enforce this.\n3. Construct the boundary incidence matrices $ B_1 $ and $ B_2 $ using the normalized orientations:\n   - For each oriented edge $ (i,j) $ with $ i < j $, set $ B_1[i,e] = -1 $ and $ B_1[j,e] = +1 $, where $ e $ is the index of the edge.\n   - For each oriented face $ (i,j,k) $, its oriented boundary is $ (i,j) + (j,k) + (k,i) $. For each of these three directed edge occurrences, locate the corresponding globally oriented edge $ (u,v) $ with $ u < v $; assign $ +1 $ in $ B_2 $ if the face-induced direction matches $ (u,v) $, and $ -1 $ otherwise.\n4. Verify that $ B_1 B_2 = 0 $, which guarantees $ \\delta_1 \\delta_0 = 0 $ for the corresponding coboundary operators on Whitney cochains.\n\nYour program must implement the above algorithm and apply it to the following test suite. Faces are specified with vertex indices, and the number of vertices is provided explicitly. All meshes are triangular and purely combinatorial; no geometric coordinates are required. The outputs must be booleans indicating whether $ B_1 B_2 $ equals the zero matrix for each test case, evaluated after normalization.\n\nTest Suite:\n- Case 1 (single triangle, reversed initial orientation):\n  - Number of vertices: $ 3 $\n  - Faces: $ [(0,2,1)] $\n- Case 2 (two triangles forming a square with a shared edge and inconsistent initial orientation):\n  - Number of vertices: $ 4 $\n  - Faces: $ [(0,1,2),(3,2,0)] $\n- Case 3 (disconnected mesh with two separate triangles):\n  - Number of vertices: $ 6 $\n  - Faces: $ [(0,1,2),(3,4,5)] $\n- Case 4 (non-manifold edge where three faces share the edge $ \\{1,2\\} $):\n  - Number of vertices: $ 5 $\n  - Faces: $ [(0,1,2),(2,1,3),(1,2,4)] $\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $ [\\text{result1},\\text{result2},\\text{result3},\\text{result4}] $), where each $ \\text{result} $ is a boolean indicating whether $ B_1 B_2 = 0 $ after normalization for the corresponding test case.\n\nThere are no physical units involved. Angles do not appear. Percentages are not applicable. All quantities are purely discrete and algebraic. Ensure that your program is self-contained and requires no input.", "solution": "The problem requires the construction of discrete boundary operators ($B_1$, $B_2$) for a given simplicial complex and the verification of the fundamental topological property $\\partial^2 = 0$, which in its discrete matrix form is $B_1 B_2 = 0$. This property is a cornerstone of homology theory and its application in discrete exterior calculus (DEC), where it guarantees that the coboundary operator $\\delta$, defined as the transpose of the boundary operator $\\partial$, satisfies $\\delta^2 = 0$. The process involves a systematic normalization of the orientations of the mesh's edges and faces to ensure algebraic consistency.\n\nThe solution proceeds in four main steps as outlined in the problem statement.\n\nStep 1: Simplex Identification and Edge Orientation Normalization\nA simplicial complex is defined by its simplices: vertices ($0$-simplices), edges ($1$-simplices), and faces ($2$-simplices). The input provides the number of vertices, $n_0$, and a list of oriented faces.\nFrom the list of faces, we first extract the set of unique edges. For each face, given as an ordered triple of vertex indices $(v_0, v_1, v_2)$, we identify the three edges $\\{v_0, v_1\\}$, $\\{v_1, v_2\\}$, and $\\{v_2, v_0\\}$. A comprehensive set of unique edges for the entire mesh is compiled.\nA global orientation convention is then imposed on all edges. For any edge connecting vertices $i$ and $j$, its canonical orientation is defined as the ordered pair $(i, j)$ such that $i < j$. This establishes a unique, globally consistent orientation for all $1$-simplices. We create a mapping from each canonically oriented edge $(i, j)$ to a unique integer index $e \\in \\{0, 1, \\dots, n_1-1\\}$, where $n_1$ is the total number of unique edges.\n\nStep 2: Global Face Orientation Normalization\nThe initial orientations of the faces, as given by the ordered triples, may not be globally consistent. Consistency requires that for any two faces $f_a$ and $f_b$ sharing a common edge $e$, the orientations they induce on $e$ must be opposite. For example, if $f_a$ induces the oriented edge $(i, j)$ along $e$, then $f_b$ must induce the oriented edge $(j, i)$.\nTo enforce this, we perform a traversal over the face-adjacency graph, where nodes represent faces and graph edges connect faces that share a mesh edge. We can use a Breadth-First Search (BFS) or Depth-First Search (DFS) for this purpose. The algorithm proceeds as follows:\n1.  Maintain an array of orientation multipliers, `face_orientations`, of size $n_2$ (number of faces), initialized to indicate that no face has yet been visited and oriented.\n2.  Iterate through each face $f_i$ from $i=0$ to $n_2-1$. If $f_i$ has not been visited, it signifies the start of a new connected component of the mesh.\n3.  Assign a default orientation multiplier of $+1$ to $f_i$ and begin a traversal (e.g., BFS) from it.\n4.  For each visited face $f_{curr}$ in the traversal, consider its boundary edges. For each such edge $e$, find the adjacent face $f_{adj}$ that shares it.\n5.  If $f_{adj}$ has not yet been visited, we determine its orientation relative to $f_{curr}$. Let the orientation multiplier of $f_{curr}$ be $o_{curr} \\in \\{-1, +1\\}$. Let the local orientation of $e$ induced by the vertex ordering of $f_{curr}$ be $d_{curr} \\in \\{-1, +1\\}$ relative to the canonical edge orientation. Similarly, let $d_{adj}$ be the local orientation of $e$ induced by $f_{adj}$. The consistency condition is $o_{curr} \\cdot d_{curr} + o_{adj} \\cdot d_{adj} = 0$. We solve for the orientation multiplier of the adjacent face: $o_{adj} = -o_{curr} \\cdot d_{curr} \\cdot d_{adj}$.\n6.  We set the orientation for $f_{adj}$ and add it to the traversal queue.\nThis process is repeated until all faces in all connected components are assigned a consistent orientation multiplier. For non-manifold meshes where, for example, more than two faces share an edge, this procedure may not be able to satisfy the consistency condition for all pairs. The resulting set of orientations will be inconsistent, which will be detected in the final verification step.\n\nStep 3: Construction of Boundary Incidence Matrices $B_1$ and $B_2$\nWith normalized orientations for all edges and faces, we construct the boundary matrices.\nThe matrix $B_1 \\in \\mathbb{Z}^{n_0 \\times n_1}$ maps edges to their boundary vertices. For each edge $e$ with index $k_e$, canonically oriented as $(i, j)$ with $i < j$, its boundary is $\\partial_1 e = v_j - v_i$. This corresponds to column $k_e$ of $B_1$ having an entry of $-1$ at row $i$ and $+1$ at row $j$. Formally:\n$$\n(B_1)_{m, k_e} = \\begin{cases} -1 & \\text{if } m=i \\\\ +1 & \\text{if } m=j \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThe matrix $B_2 \\in \\mathbb{Z}^{n_1 \\times n_2}$ maps faces to their boundary edges. For each face $f$ with index $k_f$, its boundary is a sum of its three oriented edges, e.g., $\\partial_2 f = (v_0, v_1) + (v_1, v_2) + (v_2, v_0)$. The final orientation of the face is determined by its initial vertex ordering and the orientation multiplier $o_{k_f}$ computed in Step 2. For each edge on the boundary of face $f$, we find its corresponding canonical edge $e$ with index $k_e$. We determine if the orientation induced by the face on this edge is aligned ($+1$) or anti-aligned ($-1$) with the canonical orientation of $e$. Let this local sign be $s_{local}$. The entry in the matrix $B_2$ is the product of the face's orientation multiplier and this local sign. For an edge with index $k_e$ on the boundary of face with index $k_f$:\n$$\n(B_2)_{k_e, k_f} = o_{k_f} \\cdot s_{local}\n$$\n\nStep 4: Verification of the Property $B_1 B_2 = 0$\nThe final step is to compute the matrix product $C = B_1 B_2$. The fundamental property of a boundary operator is that \"the boundary of a boundary is zero,\" i.e., $\\partial_1 \\circ \\partial_2 = 0$. In matrix representation, this translates to the condition that the product of the corresponding incidence matrices is the zero matrix. We verify if every element of the resulting matrix $C \\in \\mathbb{Z}^{n_0 \\times n_2}$ is zero. If $C$ is the zero matrix, the property holds for the constructed discrete operators. If the mesh (or a part of it) is non-orientable, the face orientation normalization in Step 2 fails to produce a globally consistent set of orientations, which typically leads to $B_1 B_2 \\neq 0$. The check is performed using numerical linear algebra, confirming that all entries of the product matrix are $0$.", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run the DEC boundary operator verification for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (single triangle, reversed initial orientation)\n        {\"n_vertices\": 3, \"faces\": [(0, 2, 1)]},\n        # Case 2 (two triangles forming a square, inconsistent initial orientation)\n        {\"n_vertices\": 4, \"faces\": [(0, 1, 2), (3, 2, 0)]},\n        # Case 3 (disconnected mesh with two separate triangles)\n        {\"n_vertices\": 6, \"faces\": [(0, 1, 2), (3, 4, 5)]},\n        # Case 4 (non-manifold edge where three faces share an edge {1,2})\n        {\"n_vertices\": 5, \"faces\": [(0, 1, 2), (2, 1, 3), (1, 2, 4)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_mesh(case[\"n_vertices\"], case[\"faces\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_mesh(n_vertices, faces):\n    \"\"\"\n    Constructs boundary matrices B1 and B2 for a given mesh and verifies if B1*B2=0.\n\n    Args:\n        n_vertices (int): The number of vertices in the mesh.\n        faces (list of tuples): A list where each tuple represents an oriented triangular face.\n\n    Returns:\n        bool: True if the product B1 * B2 is a zero matrix, False otherwise.\n    \"\"\"\n    if not faces:\n        return True\n\n    n0 = n_vertices\n    n2 = len(faces)\n\n    # --- Step 1: Identify unique edges and fix their orientation ---\n    edge_set = set()\n    for v0, v1, v2 in faces:\n        edge_set.add(tuple(sorted((v0, v1))))\n        edge_set.add(tuple(sorted((v1, v2))))\n        edge_set.add(tuple(sorted((v2, v0))))\n    \n    canonical_edges = sorted(list(edge_set))\n    edge_to_idx = {edge: i for i, edge in enumerate(canonical_edges)}\n    n1 = len(canonical_edges)\n\n    # --- Step 2: Normalize face orientations ---\n    # Build an adjacency map from edges to the faces they belong to\n    edge_to_faces = {edge: [] for edge in canonical_edges}\n    for i, (v0, v1, v2) in enumerate(faces):\n        edge_to_faces[tuple(sorted((v0, v1)))].append(i)\n        edge_to_faces[tuple(sorted((v1, v2)))].append(i)\n        edge_to_faces[tuple(sorted((v2, v0)))].append(i)\n\n    face_orientations = [0] * n2  # 0: unvisited, 1: original, -1: flipped\n\n    # Helper to find the direction of an edge within a face's boundary loop\n    def get_edge_dir_in_face(face_verts, edge_to_find):\n        u, v = edge_to_find\n        boundary = [(face_verts[0], face_verts[1]), \n                    (face_verts[1], face_verts[2]), \n                    (face_verts[2], face_verts[0])]\n        if (u, v) in boundary:\n            return 1\n        if (v, u) in boundary:\n            return -1\n        return 0 # Should not happen for a valid mesh\n\n    # Use BFS to propagate consistent orientations\n    for i in range(n2):\n        if face_orientations[i] == 0:\n            q = deque()\n            face_orientations[i] = 1 # Start component with +1 orientation\n            q.append(i)\n            while q:\n                f_idx1 = q.popleft()\n                f1_verts = faces[f_idx1]\n                f1_orient = face_orientations[f_idx1]\n                \n                # Check neighbors\n                boundary_v_pairs = [(f1_verts[0], f1_verts[1]), \n                                    (f1_verts[1], f1_verts[2]), \n                                    (f1_verts[2], f1_verts[0])]\n                \n                for u, v in boundary_v_pairs:\n                    canonical_e = tuple(sorted((u, v)))\n                    adjacent_faces = edge_to_faces[canonical_e]\n                    \n                    if len(adjacent_faces) == 2: # Only orient across manifold edges\n                        f_idx2 = adjacent_faces[0] if adjacent_faces[1] == f_idx1 else adjacent_faces[1]\n                        \n                        if face_orientations[f_idx2] == 0:\n                            f2_verts = faces[f_idx2]\n                            \n                            # Direction of the edge (u,v) in face 1\n                            edge_dir_in_f1 = 1 \n                            # Direction of the edge (u,v) in face 2\n                            edge_dir_in_f2 = get_edge_dir_in_face(f2_verts, (u, v))\n                            \n                            # Consistency requires: o1 * d1 + o2 * d2 = 0\n                            # where d1, d2 are directions of the shared edge (u,v) in each face's loop\n                            # We get o2 = -o1 * d1 * d2\n                            f2_orient = -f1_orient * edge_dir_in_f1 * edge_dir_in_f2\n                            \n                            face_orientations[f_idx2] = f2_orient\n                            q.append(f_idx2)\n\n    # --- Step 3: Construct boundary matrices B1 and B2 ---\n    # B1: n0 x n1 (vertices x edges)\n    B1 = np.zeros((n0, n1), dtype=np.int8)\n    for e_idx, (i, j) in enumerate(canonical_edges):\n        B1[i, e_idx] = -1\n        B1[j, e_idx] = 1\n\n    # B2: n1 x n2 (edges x faces)\n    B2 = np.zeros((n1, n2), dtype=np.int8)\n    for f_idx, face in enumerate(faces):\n        final_face_orient = face_orientations[f_idx]\n        if final_face_orient == 0: # Handle un-orientable components like non-manifold\n            final_face_orient = 1\n        boundary_edges = [(face[0], face[1]), (face[1], face[2]), (face[2], face[0])]\n        for u, v in boundary_edges:\n            e_idx = edge_to_idx[tuple(sorted((u, v)))]\n            local_sign = 1 if u  v else -1\n            B2[e_idx, f_idx] += final_face_orient * local_sign\n\n    # --- Step 4: Verify B1 * B2 = 0 ---\n    if n1 == 0: # a mesh of only vertices has B2 as empty matrix\n        return True\n    \n    B1_B2 = np.dot(B1, B2)\n    return np.all(B1_B2 == 0)\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3361221"}, {"introduction": "Once the discrete operators are correctly constructed, we need basis functions to represent physical fields on the mesh. This exercise [@problem_id:3361251] focuses on the lowest-order Whitney 1-forms, the natural discrete representation for vector fields like the electric or magnetic fields in electromagnetism. By explicitly constructing the interpolant of a smooth field and analytically calculating the interpolation error, you will gain a concrete understanding of how these forms approximate continuous fields and how the accuracy of this approximation depends on the geometric size of the mesh elements.", "problem": "Consider the single tetrahedron (simplex) $K_{h} \\subset \\mathbb{R}^{3}$ with vertices $v_{0}=(0,0,0)$, $v_{1}=(h,0,0)$, $v_{2}=(0,h,0)$, and $v_{3}=(0,0,h)$, where $h0$ is the characteristic mesh size. Let $\\{\\lambda_{i}\\}_{i=0}^{3}$ denote the barycentric coordinates on $K_{h}$, and define the lowest-order Whitney $1$-forms on $K_{h}$ by $w_{ij}=\\lambda_{i}\\,\\mathrm{d}\\lambda_{j}-\\lambda_{j}\\,\\mathrm{d}\\lambda_{i}$ for each oriented edge $e_{ij}=[v_{i},v_{j}]$ with $ij$. For a smooth differential $1$-form $\\alpha$ on $K_{h}$, the Whitney interpolation operator maps the edge cochain $c_{ij}=\\int_{e_{ij}}\\alpha$ to the Whitney $1$-form $\\mathcal{I}_{W}\\alpha=\\sum_{ij}c_{ij}\\,w_{ij}$.\n\nLet the underlying $1$-form be exact, given by $\\alpha=\\mathrm{d}\\phi$ with scalar potential $\\phi(x,y,z)=x^{2}+y^{2}+z^{2}$. Construct $\\mathcal{I}_{W}\\alpha$ on $K_{h}$ from the definition above, starting from the edge cochain induced by $\\alpha$. Then, using the standard Euclidean metric on $\\mathbb{R}^{3}$ to define the $L^{2}$ inner product on $1$-forms, compute the exact $L^{2}$ norm of the interpolation error $\\|\\alpha-\\mathcal{I}_{W}\\alpha\\|_{L^{2}(K_{h})}$ as a function of $h$.\n\nExpress your final answer as a single closed-form analytic expression in terms of $h$. No rounding is required and no units should be included in the final expression.", "solution": "The user wants to compute the $L^{2}$ norm of the interpolation error of a given $1$-form using lowest-order Whitney forms on a specific tetrahedron.\n\n### Step 1: Extract Givens\n-   **Simplex**: A single tetrahedron $K_{h} \\subset \\mathbb{R}^{3}$.\n-   **Vertices**: $v_{0}=(0,0,0)$, $v_{1}=(h,0,0)$, $v_{2}=(0,h,0)$, and $v_{3}=(0,0,h)$, where $h0$.\n-   **Barycentric Coordinates**: $\\{\\lambda_{i}\\}_{i=0}^{3}$ on $K_{h}$.\n-   **Whitney 1-forms**: $w_{ij}=\\lambda_{i}\\,\\mathrm{d}\\lambda_{j}-\\lambda_{j}\\,\\mathrm{d}\\lambda_{i}$ for edges $e_{ij}=[v_{i},v_{j}]$ with $ij$.\n-   **Whitney Interpolation Operator**: $\\mathcal{I}_{W}\\alpha=\\sum_{ij}c_{ij}\\,w_{ij}$, with edge cochains $c_{ij}=\\int_{e_{ij}}\\alpha$.\n-   **Differential 1-form**: $\\alpha=\\mathrm{d}\\phi$, where the scalar potential is $\\phi(x,y,z)=x^{2}+y^{2}+z^{2}$.\n-   **Metric**: Standard Euclidean metric on $\\mathbb{R}^{3}$.\n-   **Task**: Compute the $L^{2}$ norm of the interpolation error, $\\|\\alpha-\\mathcal{I}_{W}\\alpha\\|_{L^{2}(K_{h})}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It is a standard problem in the field of finite element exterior calculus (or discrete exterior calculus), specifically concerning the analysis of Whitney forms (lowest-order Nédélec edge elements). All terms are defined conventionally, the data is consistent, and the required calculation is well-defined. The problem is valid.\n\n### Step 3: Proceed with Solution\n\nFirst, we explicitly find the differential $1$-form $\\alpha$. Given the scalar potential $\\phi(x,y,z) = x^{2}+y^{2}+z^{2}$, its exterior derivative is:\n$$ \\alpha = \\mathrm{d}\\phi = \\frac{\\partial\\phi}{\\partial x}\\mathrm{d}x + \\frac{\\partial\\phi}{\\partial y}\\mathrm{d}y + \\frac{\\partial\\phi}{\\partial z}\\mathrm{d}z = 2x\\,\\mathrm{d}x + 2y\\,\\mathrm{d}y + 2z\\,\\mathrm{d}z $$\n\nNext, we compute the edge cochains $c_{ij} = \\int_{e_{ij}}\\alpha$. Since $\\alpha = \\mathrm{d}\\phi$ is an exact form, the fundamental theorem of calculus for line integrals applies:\n$$ c_{ij} = \\int_{e_{ij}}\\mathrm{d}\\phi = \\phi(v_{j}) - \\phi(v_{i}) $$\nWe evaluate the potential $\\phi$ at the vertices of the tetrahedron $K_{h}$:\n-   $\\phi(v_{0}) = \\phi(0,0,0) = 0^{2}+0^{2}+0^{2} = 0$\n-   $\\phi(v_{1}) = \\phi(h,0,0) = h^{2}+0^{2}+0^{2} = h^{2}$\n-   $\\phi(v_{2}) = \\phi(0,h,0) = 0^{2}+h^{2}+0^{2} = h^{2}$\n-   $\\phi(v_{3}) = \\phi(0,0,h) = 0^{2}+0^{2}+h^{2} = h^{2}$\n\nThe cochains for the six edges $e_{ij}$ (with $ij$) are:\n-   $c_{01} = \\phi(v_{1}) - \\phi(v_{0}) = h^{2} - 0 = h^{2}$\n-   $c_{02} = \\phi(v_{2}) - \\phi(v_{0}) = h^{2} - 0 = h^{2}$\n-   $c_{03} = \\phi(v_{3}) - \\phi(v_{0}) = h^{2} - 0 = h^{2}$\n-   $c_{12} = \\phi(v_{2}) - \\phi(v_{1}) = h^{2} - h^{2} = 0$\n-   $c_{13} = \\phi(v_{3}) - \\phi(v_{1}) = h^{2} - h^{2} = 0$\n-   $c_{23} = \\phi(v_{3}) - \\phi(v_{2}) = h^{2} - h^{2} = 0$\n\nNow, we construct the Whitney interpolant $\\mathcal{I}_{W}\\alpha$. A key property of the Whitney-Lagrange pair of elements is that the interpolation operator and exterior derivative commute, i.e., $\\mathcal{I}_{W}\\mathrm{d}\\phi = \\mathrm{d}(\\mathcal{I}_{L}\\phi)$, where $\\mathcal{I}_{L}\\phi$ is the standard linear Lagrange interpolant of $\\phi$.\n$$ \\mathcal{I}_{L}\\phi = \\sum_{i=0}^{3} \\phi(v_{i})\\lambda_{i} = \\phi(v_{0})\\lambda_{0} + \\phi(v_{1})\\lambda_{1} + \\phi(v_{2})\\lambda_{2} + \\phi(v_{3})\\lambda_{3} $$\nSubstituting the values of $\\phi(v_{i})$:\n$$ \\mathcal{I}_{L}\\phi = (0)\\lambda_{0} + h^{2}\\lambda_{1} + h^{2}\\lambda_{2} + h^{2}\\lambda_{3} = h^{2}(\\lambda_{1}+\\lambda_{2}+\\lambda_{3}) $$\nUsing the property that barycentric coordinates sum to one, $\\sum_{i=0}^{3}\\lambda_{i} = 1$, we have $\\lambda_{1}+\\lambda_{2}+\\lambda_{3} = 1-\\lambda_{0}$. Thus:\n$$ \\mathcal{I}_{L}\\phi = h^{2}(1-\\lambda_{0}) $$\nNow we can find the Whitney interpolant by taking the exterior derivative:\n$$ \\mathcal{I}_{W}\\alpha = \\mathrm{d}(\\mathcal{I}_{L}\\phi) = \\mathrm{d}(h^{2}(1-\\lambda_{0})) = -h^{2}\\mathrm{d}\\lambda_{0} $$\nTo express this in the standard Cartesian basis $\\{\\mathrm{d}x, \\mathrm{d}y, \\mathrm{d}z\\}$, we relate the barycentric coordinate $\\lambda_{0}$ to the Cartesian coordinates $(x,y,z)$. A point $p=(x,y,z)$ is given by $p = \\sum_{i=0}^{3} \\lambda_{i} v_{i}$.\n$$ (x,y,z) = \\lambda_{0}(0,0,0) + \\lambda_{1}(h,0,0) + \\lambda_{2}(0,h,0) + \\lambda_{3}(0,0,h) = (h\\lambda_{1}, h\\lambda_{2}, h\\lambda_{3}) $$\nThis gives $\\lambda_{1} = x/h$, $\\lambda_{2} = y/h$, $\\lambda_{3} = z/h$. From $\\lambda_{0} = 1 - \\lambda_{1} - \\lambda_{2} - \\lambda_{3}$, we get:\n$$ \\lambda_{0} = 1 - \\frac{x}{h} - \\frac{y}{h} - \\frac{z}{h} $$\nThe exterior derivative of $\\lambda_{0}$ is:\n$$ \\mathrm{d}\\lambda_{0} = -\\frac{1}{h}\\mathrm{d}x - \\frac{1}{h}\\mathrm{d}y - \\frac{1}{h}\\mathrm{d}z = -\\frac{1}{h}(\\mathrm{d}x+\\mathrm{d}y+\\mathrm{d}z) $$\nSubstituting this into the expression for $\\mathcal{I}_{W}\\alpha$:\n$$ \\mathcal{I}_{W}\\alpha = -h^{2}\\left(-\\frac{1}{h}(\\mathrm{d}x+\\mathrm{d}y+\\mathrm{d}z)\\right) = h(\\mathrm{d}x+\\mathrm{d}y+\\mathrm{d}z) $$\n\nThe interpolation error is the $1$-form $\\eta = \\alpha - \\mathcal{I}_{W}\\alpha$:\n$$ \\eta = (2x\\,\\mathrm{d}x + 2y\\,\\mathrm{d}y + 2z\\,\\mathrm{d}z) - (h\\,\\mathrm{d}x+h\\,\\mathrm{d}y+h\\,\\mathrm{d}z) $$\n$$ \\eta = (2x-h)\\mathrm{d}x + (2y-h)\\mathrm{d}y + (2z-h)\\mathrm{d}z $$\nThe squared $L^{2}$ norm of $\\eta$ is given by the integral of the squared magnitude of its vector proxy over the tetrahedron $K_{h}$:\n$$ \\|\\eta\\|_{L^{2}(K_{h})}^{2} = \\int_{K_{h}} \\left( (2x-h)^{2} + (2y-h)^{2} + (2z-h)^{2} \\right) \\mathrm{d}V $$\nThe domain of integration $K_{h}$ is defined by $x \\ge 0$, $y \\ge 0$, $z \\ge 0$, and $x+y+z \\le h$. The integrand and the domain are symmetric with respect to permutations of $x, y, z$. Therefore, the three terms in the integral contribute equally:\n$$ \\|\\eta\\|_{L^{2}(K_{h})}^{2} = 3 \\int_{K_{h}} (2x-h)^{2} \\mathrm{d}V $$\nTo evaluate this integral, we use the standard formula for integrals of polynomials in barycentric coordinates over a simplex. In $n$ dimensions:\n$$ \\int_{T} \\prod_{i=0}^{n} \\lambda_{i}^{p_{i}} \\mathrm{d}V = \\frac{\\prod_{i=0}^{n} p_{i}! \\cdot n!}{(\\sum p_{i} + n)!} \\mathrm{Vol}(T) $$\nFor our tetrahedron $K_{h}$, $n=3$, and the volume is $\\text{Vol}(K_{h}) = \\frac{1}{6}h^{3}$.\nWe express the integrand in barycentric coordinates using $x = h\\lambda_1$:\n$$ \\int_{K_{h}} (2x-h)^{2} \\mathrm{d}V = \\int_{K_{h}} (2h\\lambda_{1}-h)^{2} \\mathrm{d}V = h^{2} \\int_{K_{h}} (2\\lambda_{1}-1)^{2} \\mathrm{d}V $$\n$$ = h^{2} \\int_{K_{h}} (4\\lambda_{1}^{2} - 4\\lambda_{1} + 1) \\mathrm{d}V = h^{2} \\left( 4\\int_{K_{h}}\\lambda_{1}^{2}\\mathrm{d}V - 4\\int_{K_{h}}\\lambda_{1}\\mathrm{d}V + \\int_{K_{h}}1\\mathrm{d}V \\right) $$\nWe compute the individual integrals:\n$$ \\int_{K_{h}} 1 \\mathrm{d}V = \\text{Vol}(K_{h}) = \\frac{h^{3}}{6} $$\n$$ \\int_{K_{h}} \\lambda_{1} \\mathrm{d}V = \\frac{1!0!0!0! \\cdot 3!}{(1+3)!} \\frac{h^{3}}{6} = \\frac{6}{24} \\frac{h^{3}}{6} = \\frac{h^{3}}{24} $$\n$$ \\int_{K_{h}} \\lambda_{1}^{2} \\mathrm{d}V = \\frac{2!0!0!0! \\cdot 3!}{(2+3)!} \\frac{h^{3}}{6} = \\frac{2 \\cdot 6}{120} \\frac{h^{3}}{6} = \\frac{12}{120} \\frac{h^{3}}{6} = \\frac{h^{3}}{60} $$\nSubstituting these results back:\n$$ \\int_{K_{h}} (2x-h)^{2} \\mathrm{d}V = h^{2} \\left( 4\\left(\\frac{h^{3}}{60}\\right) - 4\\left(\\frac{h^{3}}{24}\\right) + \\frac{h^{3}}{6} \\right) = h^{5} \\left( \\frac{4}{60} - \\frac{4}{24} + \\frac{1}{6} \\right) $$\n$$ = h^{5} \\left( \\frac{1}{15} - \\frac{1}{6} + \\frac{1}{6} \\right) = \\frac{h^{5}}{15} $$\nThe squared norm is three times this value:\n$$ \\|\\eta\\|_{L^{2}(K_{h})}^{2} = 3 \\cdot \\frac{h^{5}}{15} = \\frac{h^{5}}{5} $$\nFinally, the $L^{2}$ norm of the interpolation error is the square root of this expression:\n$$ \\|\\alpha-\\mathcal{I}_{W}\\alpha\\|_{L^{2}(K_{h})} = \\sqrt{\\frac{h^{5}}{5}} = \\frac{h^{5/2}}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5}h^{5/2} $$", "answer": "$$\\boxed{\\frac{\\sqrt{5}}{5}h^{5/2}}$$", "id": "3361251"}, {"introduction": "The true power of the DEC framework is revealed when it is applied to solve complex physical problems, where its structure-preserving nature leads to more robust and physically faithful numerical schemes. This culminating practice [@problem_id:3361261] guides you through the implementation of a coupled Discrete Exterior Calculus and Particle-In-Cell (DEC-PIC) model to simulate electrostatic interactions. This exercise demonstrates how the consistent use of Whitney forms for both distributing particle charges onto the mesh and gathering field values from the mesh results in superior numerical behavior, including the discrete satisfaction of Gauss's law and the conservation of momentum.", "problem": "You are asked to construct a minimal, self-contained Discrete Exterior Calculus (DEC) and Particle-In-Cell (PIC) coupling in one spatial dimension to test the consistency of Whitney-form-based field gathering and deposition with the Lorentz force, and to verify momentum conservation. Work in dimensionless units throughout; do not attach physical units to any quantities. All computations must be performed with exact linear algebra on small systems and must be reproducible from the program without any user input.\n\nConsider a periodic domain of length $L$ discretized into $N$ uniform nodes and $N$ edges with spacing $h = L/N$. Let the node indices be $i \\in \\{0,1,\\ldots,N-1\\}$ with periodic wrap-around, and the edge $e$ connects node $e$ to node $(e+1) \\bmod N$. The discrete exterior derivative on $0$-cochains is represented by the incidence matrix $D \\in \\mathbb{R}^{N \\times N}$ with entries\n$$\nD_{e,i} = \\begin{cases}\n-1,  \\text{if } i = e,\\\\\n+1,  \\text{if } i = (e+1)\\bmod N,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nUse the Whitney forms for the one-dimensional mesh:\n- Whitney $0$-forms (hat functions) for charge deposition: for a particle at position $x \\in [0,L)$ on edge $e$, its contributions to the adjacent nodes are $\\lambda_{e}(x)=1-s$ and $\\lambda_{e+1}(x)=s$ with $s = (x - e h)/h \\in [0,1)$. The right-hand-side cochain $b \\in \\mathbb{R}^{N}$ is assembled as $b_i = \\sum_p q_p \\lambda_i(x_p)$.\n- Whitney $1$-forms for the electric field: on edge $e$, the Whitney $1$-form is constant, and the discrete electric $1$-cochain $E_h \\in \\mathbb{R}^{N}$ equals the line integral of the electric field on each edge. The $1$-Hodge star (mass matrix) is diagonal with $(\\star_h)_{e,e} = 1/h$.\n\nFor electrostatics with homogeneous permittivity normalized to $1$, the discrete Poisson equation in DEC Galerkin form is\n$$\nK \\, \\phi = b,\\quad \\text{where } K = D^\\top \\star_h D, \\quad \\phi \\in \\mathbb{R}^{N}.\n$$\nIn the periodic case, $K$ is singular with a one-dimensional null space consisting of constant vectors; impose the gauge condition $\\sum_{i=0}^{N-1} \\phi_i = 0$ by fixing $\\phi_0 = 0$ and solving the reduced system for $\\phi_{1:\\,N-1}$.\n\nAfter solving for $\\phi$, define the edge electric $1$-cochain by\n$$\nE_h = - D \\, \\phi,\n$$\nso that on each edge $e$, the piecewise constant electric field value used in the Lorentz force is $E(x) = \\frac{(E_h)_e}{h}$ for all $x$ on edge $e$.\n\nWe consider the Lorentz force update without magnetic field. For a particle $p$ with charge $q_p$, mass $m_p$, position $x_p$, and velocity $v_p$, update its velocity by\n$$\nv_p^{n+1} = v_p^n + \\frac{q_p}{m_p} E(x_p)\\,\\Delta t.\n$$\nIn this setting, internal electric forces should conserve total momentum exactly (up to solver tolerance) when Whitney forms are used consistently for charge deposition and field gathering, and the system is periodic with net zero charge.\n\nYour tasks:\n1. Implement the above DEC-PIC coupling on a periodic one-dimensional mesh using the given Whitney forms, constructing $D$, $\\star_h$, $K$, and solving $K \\phi = b$ with the gauge $\\phi_0=0$.\n2. For each specified test case (given below), assemble $b$ from the particles via Whitney $0$-form deposition, solve for $\\phi$, compute $E_h$, gather $E(x_p)$ using the Whitney $1$-form interpretation $E(x) = (E_h)_e/h$, and update particle velocities for one time step.\n3. Compute and report the following three verification metrics for each test case:\n   - Momentum conservation error: the absolute value of the total momentum after the update,\n     $$\n     \\left| \\sum_p m_p v_p^{n+1} \\right|.\n     $$\n   - Discrete Gauss law residual norm: the infinity norm of\n     $$\n     r = D^\\top \\star_h E_h + b,\n     $$\n     which should be approximately zero if the solution satisfies the discrete Gauss law $D^\\top \\star_h E_h + b = 0$.\n   - Force consistency error: the maximum, over particles $p$, of\n     $$\n     \\left| q_p \\,\\frac{(E_h)_{e_p}}{h} - \\left(-q_p \\frac{\\phi_{(e_p+1)\\bmod N} - \\phi_{e_p}}{h}\\right) \\right|,\n     $$\n     where $e_p$ is the edge containing $x_p$. This checks that the Whitney $1$-form gather $(E_h)_{e_p}/h$ matches the gradient of the interpolated potential.\n\nUse the following fixed simulation and test parameters:\n- Mesh: $L = 1$, $N = 8$, $h = L/N$.\n- Time step: $\\Delta t = 10^{-2}$.\n- Initial velocities: $v_p^n = 0$ for all particles in every case.\n- Three test cases with two particles each (all quantities are dimensionless):\n  1) Positions $[0.2,\\,0.7]$, charges $[+1,\\,-1]$, masses $[1,\\,1]$.\n  2) Positions $[0.35,\\,0.35]$, charges $[+1,\\,-1]$, masses $[1,\\,2]$.\n  3) Positions $[0.125,\\,0.625]$, charges $[+2,\\,-2]$, masses $[1.5,\\,0.5]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of $9$ floats in the following order:\n$$\n[\\text{mom\\_err}_1,\\ \\text{gauss\\_res}_1,\\ \\text{force\\_err}_1,\\ \\text{mom\\_err}_2,\\ \\text{gauss\\_res}_2,\\ \\text{force\\_err}_2,\\ \\text{mom\\_err}_3,\\ \\text{gauss\\_res}_3,\\ \\text{force\\_err}_3].\n$$\nAll values must be expressed as plain floating point numbers (dimensionless), with no units and no additional text, all on a single line.", "solution": "The user requests the implementation and verification of a one-dimensional Discrete Exterior Calculus (DEC) Particle-In-Cell (PIC) coupling. The problem is to be validated for self-consistency, scientific soundness, and well-posedness before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Domain and Mesh:** A periodic domain of length $L=1$ discretized into $N=8$ nodes and $N=8$ edges. The mesh spacing is $h=L/N$. Node indices are $i \\in \\{0, 1, ..., N-1\\}$ with periodic wrap-around. Edge $e$ connects node $e$ to node $(e+1) \\bmod N$.\n- **Discrete Exterior Derivative ($D$):** An incidence matrix $D \\in \\mathbb{R}^{N \\times N}$ where $D_{e,i} = -1$ if $i = e$, $D_{e,i} = +1$ if $i = (e+1)\\bmod N$, and $0$ otherwise.\n- **Whitney 0-forms (Charge Deposition):** For a particle at position $x$ on edge $e$, the local coordinate is $s = (x - eh)/h$. The deposition weights to adjacent nodes are $\\lambda_{e}(x)=1-s$ and $\\lambda_{e+1}(x)=s$. The charge cochain is $b_i = \\sum_p q_p \\lambda_i(x_p)$.\n- **Whitney 1-forms and Hodge Star:** The discrete electric field $E_h \\in \\mathbb{R}^N$ is a $1$-cochain. The $1$-Hodge star $\\star_h$ is a diagonal matrix with $(\\star_h)_{e,e} = 1/h$.\n- **Discrete Poisson Equation:** $K \\phi = b$, with the stiffness matrix $K = D^\\top \\star_h D$.\n- **Gauge Condition:** The system is solved under the gauge condition $\\phi_0=0$ by reducing the system of equations to nodes $1, \\ldots, N-1$.\n- **Electric Field Calculation:** The electric field $1$-cochain is $E_h = -D\\phi$. The field value on an edge $e$ is taken to be piecewise constant, $E(x) = (E_h)_e/h$.\n- **Particle Velocity Update:** $v_p^{n+1} = v_p^n + \\frac{q_p}{m_p} E(x_p)\\,\\Delta t$.\n- **Constants:** $L=1$, $N=8$, $h=1/8$, $\\Delta t=10^{-2}$. Initial velocities $v_p^n=0$.\n- **Test Cases:**\n  1. Particles at $x=[0.2, 0.7]$ with $q=[+1, -1]$ and $m=[1, 1]$.\n  2. Particles at $x=[0.35, 0.35]$ with $q=[+1, -1]$ and $m=[1, 2]$.\n  3. Particles at $x=[0.125, 0.625]$ with $q=[+2, -2]$ and $m=[1.5, 0.5]$.\n- **Verification Metrics:**\n  1. Momentum conservation error: $|\\sum_p m_p v_p^{n+1}|$.\n  2. Discrete Gauss law residual norm: $||D^\\top \\star_h E_h + b||_\\infty$.\n  3. Force consistency error: $\\max_p | q_p \\frac{(E_h)_{e_p}}{h} - (-q_p \\frac{\\phi_{(e_p+1)\\bmod N} - \\phi_{e_p}}{h}) |$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem describes a standard formulation of a 1D electrostatic PIC simulation using the framework of DEC. The definitions of the discrete operators ($D$, $\\star_h$), the assembly of the stiffness matrix $K$, the Whitney form basis functions, and the relationship between potential and field are all staple components of this methodology. The physical principles, such as the Lorentz force and the expectation of momentum conservation for internal forces, are fundamental.\n- **Well-Posed:** The problem correctly identifies that the discrete Laplacian $K=D^\\top \\star_h D$ on a periodic mesh is singular. The null space consists of constant potential vectors. A condition for the existence of a solution to $K\\phi=b$ is that $b$ must be orthogonal to the null space, i.e., $\\sum_i b_i = 0$. In all test cases, the total charge is $\\sum_p q_p = 0$, which ensures $\\sum_i b_i = \\sum_i \\sum_p q_p \\lambda_i(x_p) = \\sum_p q_p \\sum_i \\lambda_i(x_p) = \\sum_p q_p(1) = 0$. The problem then specifies a valid gauge-fixing procedure (setting $\\phi_0=0$ and solving a reduced system) to obtain a unique solution for $\\phi$. Thus, the problem is well-posed.\n- **Objective:** All aspects of the problem are defined with mathematical precision and specific numerical values, leaving no room for subjective interpretation.\n- **Flaw Checklist:** A review against the checklist confirms no flaws. The problem is scientifically sound, formalizable, complete, and computationally feasible. The verification metrics are well-defined checks on the method's properties. The \"Force consistency error\" is a check of a tautological relationship $E_h = -D\\phi$, which serves as a critical implementation sanity check. The \"Gauss law residual\" verifies the correctness of the Poisson solve. The \"Momentum conservation error\" tests a non-trivial physical property of the numerical scheme.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A complete solution will be provided.\n\n### Solution\n\nThe solution involves implementing the specified DEC-PIC framework. We will first construct the discrete operators, then for each test case, we will execute the charge deposition, solve the discrete Poisson equation, compute the electric field, update particle velocities, and finally calculate the required verification metrics.\n\n**1. Construction of Discrete Operators**\n\nThe simulation parameters are $L=1$ and $N=8$, giving a grid spacing of $h=L/N=0.125$.\n\n- **Incidence Matrix ($D$):** The $N \\times N$ matrix $D$ represents the discrete exterior derivative acting on $0$-cochains (functions on nodes). For an edge $e$ connecting node $i=e$ to node $i'=(e+1)\\bmod N$, the corresponding row $e$ of $D$ has a $-1$ at column $e$ and a $+1$ at column $(e+1)\\bmod N$.\n$$\nD = \\begin{pmatrix}\n-1  1  0  \\dots  0 \\\\\n0  -1  1  \\dots  0 \\\\\n\\vdots   \\ddots   \\vdots \\\\\n0  \\dots  0  -1  1 \\\\\n1  0  \\dots  0  -1\n\\end{pmatrix} \\in \\mathbb{R}^{8 \\times 8}\n$$\nThe last row reflects the periodic boundary condition, connecting node $N-1$ back to node $0$.\n\n- **Hodge Star Matrix ($\\star_h$):** The $1$-Hodge star maps $1$-forms to dual $1$-forms. For this uniform 1D mesh, it is a diagonal $N \\times N$ matrix with constant entries $(\\star_h)_{e,e} = 1/h$.\n\n- **Stiffness Matrix ($K$):** The discrete Poisson operator, or stiffness matrix, is constructed as $K = D^\\top \\star_h D$. Given that $\\star_h = (1/h)I$, this simplifies to $K = (1/h) D^\\top D$. This matrix is the discrete equivalent of the negative Laplacian operator $-\\nabla^2$.\n\n**2. Electrostatic Solver**\n\nFor each test case, we perform the following steps:\n\n- **Charge Deposition:** We initialize a zero vector $b \\in \\mathbb{R}^N$ for the charge $0$-cochain. For each particle $p$ with charge $q_p$ at position $x_p$, we find the edge $e_p = \\lfloor x_p/h \\rfloor$ it resides on. We then compute its local coordinate $s_p = (x_p - e_p h)/h$. The charge $q_p$ is distributed to the nodes $e_p$ and $(e_p+1)\\bmod N$ using the Whitney $0$-form (linear) weights:\n$$\nb_{e_p} \\leftarrow b_{e_p} + q_p (1-s_p)\n$$\n$$\nb_{(e_p+1)\\bmod N} \\leftarrow b_{(e_p+1)\\bmod N} + q_p s_p\n$$\n\n- **Solving for Potential $\\phi$:** We solve the linear system $K\\phi=b$. As $K$ is singular, we enforce the gauge condition $\\phi_0 = 0$. This is done by removing the first row and column of $K$ to form a non-singular reduced matrix $K_{\\text{red}} \\in \\mathbb{R}^{(N-1)\\times(N-1)}$. We similarly form a reduced right-hand-side vector $b_{\\text{red}} \\in \\mathbb{R}^{N-1}$ by taking the last $N-1$ elements of $b$. We solve the reduced system $K_{\\text{red}} \\phi_{\\text{red}} = b_{\\text{red}}$ for $\\phi_{\\text{red}} = [\\phi_1, \\dots, \\phi_{N-1}]^\\top$. The full potential vector is then reconstructed as $\\phi = [0, \\phi_1, \\dots, \\phi_{N-1}]^\\top$.\n\n**3. Field Calculation and Particle Update**\n\n- **Electric Field:** The electric field $1$-cochain $E_h$ is computed from the potential $0$-cochain $\\phi$ using the negative discrete gradient:\n$$\nE_h = -D\\phi\n$$\nEach component $(E_h)_e$ represents the line integral of the electric field along edge $e$.\n- **Field Gathering and Velocity Update:** For each particle $p$, we identify its edge $e_p$. The problem defines the Whitney $1$-form interpretation of the field as a piecewise constant value on each edge, $E(x) = (E_h)_{e_p}/h$ for $x$ on edge $e_p$. The velocity of each particle is initially zero ($v_p^n=0$). We update it for one time step $\\Delta t$:\n$$\nv_p^{n+1} = \\frac{q_p}{m_p} E(x_p) \\Delta t = \\frac{q_p}{m_p} \\frac{(E_h)_{e_p}}{h} \\Delta t\n$$\n\n**4. Verification Metrics**\n\nFor each test case, we compute three metrics:\n\n- **Momentum Conservation Error:** The total initial momentum is zero. After one time step, the total momentum is $\\sum_p m_p v_p^{n+1}$. The error is the absolute value of this sum. This metric tests a fundamental conservation law; any non-zero value reveals that the chosen numerical scheme (linear deposition, piecewise constant field gathering) does not perfectly conserve momentum.\n$$\n\\text{mom\\_err} = \\left| \\sum_p m_p v_p^{n+1} \\right|\n$$\n\n- **Discrete Gauss law residual norm:** This metric verifies that the computed potential and field satisfy the discrete Gauss law, $D^\\top \\star_h E_h + b = 0$. We compute the residual vector $r = D^\\top \\star_h E_h + b$ and find its infinity norm ($L_\\infty$-norm), which is the maximum absolute value of its components. Due to the properties of the discrete operators and the Poisson solver, this residual should be close to machine precision.\n$$\n\\text{gauss\\_res} = ||r||_\\infty = \\max_i |r_i|\n$$\n\n- **Force consistency error:** This metric confirms that the force calculation is self-consistent. It compares the force derived from the gathered field $E_h$ with the force derived directly from the potential difference across the particle's edge.\n$$\nF_{\\text{gathered}} = q_p \\frac{(E_h)_{e_p}}{h} \\quad , \\quad F_{\\text{potential}} = -q_p \\frac{\\phi_{(e_p+1)\\bmod N} - \\phi_{e_p}}{h}\n$$\nSince $E_h = -D\\phi$, we have $(E_h)_{e_p} = -(\\phi_{(e_p+1)\\bmod N} - \\phi_{e_p})$. Therefore, these two expressions for the force are analytically identical. The error, calculated as $\\max_p |F_{\\text{gathered}} - F_{\\text{potential}}|$, should be zero up to floating-point round-off error, serving as a powerful sanity check for the implementation.\n\nThe implementation will proceed by defining the constant matrices, then looping through the specified test cases, performing the calculations, and collecting the three metrics for each case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D DEC-PIC simulation to verify consistency of Whitney forms\n    with the Lorentz force and momentum conservation.\n    \"\"\"\n    # Fixed simulation and test parameters\n    L = 1.0\n    N = 8\n    h = L / N\n    dt = 1.0e-2\n\n    # --- 1. Construct Discrete Operators ---\n    # Incidence matrix D (0-forms - 1-forms)\n    D = np.zeros((N, N))\n    for e in range(N):\n        i = e\n        i_plus_1 = (e + 1) % N\n        D[e, i] = -1.0\n        D[e, i_plus_1] = 1.0\n\n    # 1-Hodge star (diagonal matrix, represented as an array of diagonal elements)\n    star_h_diag = np.full(N, 1.0 / h)\n\n    # Stiffness matrix K (Laplacian for 0-forms)\n    # K = D.T @ np.diag(star_h_diag) @ D\n    K = (1.0 / h) * (D.T @ D)\n\n    # Prepare reduced system for Poisson solve with gauge phi_0 = 0\n    K_red = K[1:, 1:]\n    # Pre-compute the inverse for efficiency in the loop\n    try:\n        K_red_inv = np.linalg.inv(K_red)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse for near-singular cases, though not expected here\n        K_red_inv = np.linalg.pinv(K_red)\n\n    test_cases = [\n        # (positions, charges, masses)\n        (np.array([0.2, 0.7]), np.array([1.0, -1.0]), np.array([1.0, 1.0])),\n        (np.array([0.35, 0.35]), np.array([1.0, -1.0]), np.array([1.0, 2.0])),\n        (np.array([0.125, 0.625]), np.array([2.0, -2.0]), np.array([1.5, 0.5]))\n    ]\n\n    all_results = []\n\n    for positions, charges, masses in test_cases:\n        num_particles = len(positions)\n        v_initial = np.zeros(num_particles)\n\n        # --- 2. Assemble charge cochain b (Charge Deposition) ---\n        b = np.zeros(N)\n        for p in range(num_particles):\n            x_p, q_p = positions[p], charges[p]\n            \n            # Find edge and local coordinate\n            e_p = int(np.floor(x_p / h))\n            # Handle case where particle is exactly at L\n            if e_p >= N: e_p = N - 1\n            \n            s_p = (x_p - e_p * h) / h\n            \n            # Node indices\n            node1_idx = e_p\n            node2_idx = (e_p + 1) % N\n            \n            # Whitney 0-form (linear) deposition\n            b[node1_idx] += q_p * (1.0 - s_p)\n            b[node2_idx] += q_p * s_p\n\n        # --- 3. Solve for potential phi ---\n        b_red = b[1:]\n        phi_red = K_red_inv @ b_red\n        phi = np.concatenate(([0.0], phi_red))\n\n        # --- 4. Compute E-field and update velocity ---\n        E_h = -D @ phi\n        \n        v_new = np.copy(v_initial)\n        for p in range(num_particles):\n            x_p, q_p, m_p = positions[p], charges[p], masses[p]\n            \n            e_p = int(np.floor(x_p / h))\n            if e_p >= N: e_p = N - 1\n\n            # Get field value on the edge (Whitney 1-form interpretation)\n            E_val = E_h[e_p] / h\n            \n            # Update velocity\n            v_new[p] = v_initial[p] + (q_p / m_p) * E_val * dt\n            \n        # --- 5. Compute verification metrics ---\n\n        # 5.1. Momentum conservation error\n        total_momentum_new = np.sum(masses * v_new)\n        mom_err = np.abs(total_momentum_new)\n        \n        # 5.2. Discrete Gauss law residual norm\n        # r = D.T @ (star_h_diag * E_h) + b\n        r = (1.0/h) * (D.T @ E_h) + b\n        gauss_res = np.linalg.norm(r, ord=np.inf)\n\n        # 5.3. Force consistency error\n        max_force_err = 0.0\n        for p in range(num_particles):\n            x_p, q_p = positions[p], charges[p]\n            \n            e_p = int(np.floor(x_p / h))\n            if e_p >= N: e_p = N - 1\n\n            # Force from gathered field\n            force_gathered = q_p * (E_h[e_p] / h)\n            \n            # Force from potential gradient\n            phi_diff = phi[(e_p + 1) % N] - phi[e_p]\n            force_potential = -q_p * (phi_diff / h)\n            \n            # Compare\n            force_err_p = np.abs(force_gathered - force_potential)\n            if force_err_p > max_force_err:\n                max_force_err = force_err_p\n        \n        force_err = max_force_err\n\n        all_results.extend([mom_err, gauss_res, force_err])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{v:.10f}' for v in all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3361261"}]}