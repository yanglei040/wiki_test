{"hands_on_practices": [{"introduction": "At the heart of homogenization lies the \"cell problem,\" which connects the microscopic fields within a single unit cell to an applied macroscopic field. In the long-wavelength limit, we can calculate the bulk effective properties of a metamaterial by solving a static boundary value problem on this representative cell. This foundational exercise provides direct, hands-on experience in numerically solving this cell problem to compute the effective permittivity tensor $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$, a cornerstone skill in computational materials design [@problem_id:3314289].", "problem": "Consider a two-dimensional periodic metamaterial with a square unit cell of side length $a$ populated by a checkerboard arrangement of two scalar, positive permittivities $\\varepsilon_1$ and $\\varepsilon_2$ in alternating quadrants. The macroscopic, effective permittivity tensor $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$ is defined in the long-wavelength limit by the homogenized relation $\\langle \\mathbf{D} \\rangle = \\bar{\\bar{\\varepsilon}}_{\\text{eff}} \\langle \\mathbf{E} \\rangle$, where $\\mathbf{D} = \\varepsilon(\\mathbf{x}) \\mathbf{E}$ and $\\mathbf{E} = -\\nabla u$ with scalar electric potential $u$. In the homogenization setting, the corrector problems for the canonical macroscopic unit vectors $\\mathbf{e}_x = (1,0)$ and $\\mathbf{e}_y = (0,1)$ are posed on the unit cell with periodic boundary conditions and zero-mean correctors.\n\nStarting from Maxwell's equations and their electrostatic limit, the cell problem can be derived from the constitutive relation and charge-free condition as follows. Let $u_j(\\mathbf{x}) = -\\mathbf{e}_j \\cdot \\mathbf{x} + w_j(\\mathbf{x})$ for $j \\in \\{x,y\\}$, where $w_j$ is a periodic function on the unit cell with zero mean. The local electric field is $\\mathbf{E}_j(\\mathbf{x}) = \\mathbf{e}_j - \\nabla w_j(\\mathbf{x})$, and the displacement field is $\\mathbf{D}_j(\\mathbf{x}) = \\varepsilon(\\mathbf{x}) \\mathbf{E}_j(\\mathbf{x})$. The corrector $w_j$ satisfies the cell problem\n$$\n\\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) \\left( \\mathbf{e}_j - \\nabla w_j(\\mathbf{x}) \\right) \\right) = 0\n$$\non the periodic unit cell with zero-mean constraint on $w_j$. The effective permittivity tensor is computed column-wise as\n$$\n\\bar{\\bar{\\varepsilon}}_{\\text{eff}} \\, \\mathbf{e}_j = \\langle \\mathbf{D}_j \\rangle = \\frac{1}{a^2} \\int_{\\text{cell}} \\varepsilon(\\mathbf{x}) \\left( \\mathbf{e}_j - \\nabla w_j(\\mathbf{x}) \\right) \\, d\\mathbf{x}.\n$$\n\nYou must implement a finite-volume or finite-difference scheme on a uniform grid to approximate the solution of the cell problems for $j \\in \\{x,y\\}$ and then compute $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$. Use harmonic averaging of $\\varepsilon$ at cell faces to ensure consistent fluxes across material interfaces. Impose periodic boundary conditions and fix the gauge by enforcing a single node value of $w_j$ to be $0$ to satisfy the zero-mean (up to a constant) constraint.\n\nDefine the unit cell with $a = 1$ and the checkerboard pattern as four quadrants:\n- Lower-left and upper-right quadrants have permittivity $\\varepsilon_1$.\n- Upper-left and lower-right quadrants have permittivity $\\varepsilon_2$.\nThat is, for coordinates $x \\in [0,1)$ and $y \\in [0,1)$, assign $\\varepsilon_1$ or $\\varepsilon_2$ according to the quadrant with equal area fractions.\n\nDiscretize the unit cell with a uniform $N \\times N$ grid, where the number of grid points $N$ is chosen as a function of the scale-separation parameter $\\eta = a/\\lambda$ by $N(\\eta) = \\lceil N_0 / \\eta \\rceil$ for a fixed base resolution $N_0 = 12$. Here $\\lambda$ is a notional free-space wavelength used only to parameterize $\\eta$; the corrector problems are static and do not directly depend on $\\lambda$, but $N(\\eta)$ serves to study numerical convergence as the scale separation increases (smaller $\\eta$). Use grid spacing $h = a/N$.\n\nCompute the discrete correctors $w_x$ and $w_y$ by solving\n$$\n\\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) \\nabla w_j(\\mathbf{x}) \\right) = \\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) \\mathbf{e}_j \\right)\n$$\nwith periodic boundary conditions and gauge fixing. The right-hand side should be discretized as the discrete divergence of the face fluxes corresponding to $\\varepsilon(\\mathbf{x}) \\mathbf{e}_j$ (i.e., $\\partial_x \\varepsilon$ for $j=x$ or $\\partial_y \\varepsilon$ for $j=y$), using the same harmonic face averaging employed for the left-hand side. After solving for $w_j$, compute the local fields and average the displacement to obtain the effective tensor entries.\n\nExpress all permittivities and effective tensor entries in Farads per meter (F/m). The numerical output must be floats.\n\nTest Suite:\nUse the following parameter sets, each specified by $(\\varepsilon_1, \\varepsilon_2, \\eta)$, with $\\varepsilon_1$ and $\\varepsilon_2$ in F/m and $\\eta$ dimensionless:\n1. $(2.0, 8.0, 0.5)$\n2. $(2.0, 8.0, 0.25)$\n3. $(2.0, 8.0, 0.125)$\n4. $(5.0, 5.0, 0.25)$\nAdditionally, for $(2.0, 8.0, 0.25)$, compute two scalar diagnostics:\n- The anisotropy measure defined as $|\\bar{\\bar{\\varepsilon}}_{\\text{eff}}(1,1) - \\bar{\\bar{\\varepsilon}}_{\\text{eff}}(2,2)|$ normalized by the average diagonal $\\frac{1}{2}(\\bar{\\bar{\\varepsilon}}_{\\text{eff}}(1,1) + \\bar{\\bar{\\varepsilon}}_{\\text{eff}}(2,2))$.\n- The off-diagonal magnitude defined as $\\max\\{|\\bar{\\bar{\\varepsilon}}_{\\text{eff}}(1,2)|, |\\bar{\\bar{\\varepsilon}}_{\\text{eff}}(2,1)|\\}$ normalized by the same average diagonal.\n\nFor the first three cases, return the scalar isotropic estimate defined as the average of the diagonal entries $\\frac{1}{2}(\\bar{\\bar{\\varepsilon}}_{\\text{eff}}(1,1) + \\bar{\\bar{\\varepsilon}}_{\\text{eff}}(2,2))$ in F/m. For the fourth case, return the absolute deviation of the isotropic estimate from $\\varepsilon_1$ (which equals $\\varepsilon_2$) in F/m.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n- The isotropic estimates (in F/m) for cases $1$, $2$, and $3$.\n- The convergence ratio defined as $\\frac{|I_1 - I_2|}{|I_2 - I_3|}$, where $I_k$ is the isotropic estimate for case $k$, dimensionless.\n- The absolute deviation (in F/m) for case $4$.\n- The anisotropy measure (dimensionless) for case $(2.0, 8.0, 0.25)$.\n- The normalized off-diagonal magnitude (dimensionless) for case $(2.0, 8.0, 0.25)$.\n\nFor example, the output should look like:\n$[I_1,I_2,I_3,R,\\Delta,I_{\\text{aniso}},I_{\\text{off}}]$\nwith all entries printed as standard Python floats.", "solution": "The problem requires the computation of the effective permittivity tensor $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$ for a two-dimensional periodic metamaterial with a checkerboard structure. This is a classic problem in homogenization theory, which we will solve numerically using a cell-centered finite-volume method (FVM).\n\n### 1. Theoretical Formulation\n\nThe relationship between the averaged electric displacement field $\\langle \\mathbf{D} \\rangle$ and the averaged electric field $\\langle \\mathbf{E} \\rangle$ in the long-wavelength limit is given by $\\langle \\mathbf{D} \\rangle = \\bar{\\bar{\\varepsilon}}_{\\text{eff}} \\langle \\mathbf{E} \\rangle$. The effective permittivity tensor $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$ can be determined by solving a set of so-called \"cell problems\" on the material's unit cell.\n\nFor a macroscopic constant electric field $\\mathbf{E}_0$, the local field is $\\mathbf{E}(\\mathbf{x}) = \\mathbf{E}_0 - \\nabla w(\\mathbf{x})$, where $w(\\mathbf{x})$ is a periodic \"corrector\" potential. The governing equation for the corrector, derived from the charge-free condition $\\nabla \\cdot \\mathbf{D} = 0$, is\n$$\n\\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) (\\mathbf{E}_0 - \\nabla w(\\mathbf{x})) \\right) = 0\n$$\nTo find the components of $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$, we solve this equation for two specific cases: $\\mathbf{E}_0 = \\mathbf{e}_x = (1,0)$ and $\\mathbf{E}_0 = \\mathbf{e}_y = (0,1)$. This gives two corrector potentials, $w_x$ and $w_y$. The corresponding cell problems are:\n$$\n\\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) \\nabla w_j(\\mathbf{x}) \\right) = \\nabla \\cdot \\left( \\varepsilon(\\mathbf{x}) \\mathbf{e}_j \\right) \\quad \\text{for } j \\in \\{x, y\\}\n$$\nThese are Poisson-like equations to be solved on the unit cell with periodic boundary conditions. The corrector $w_j$ is unique up to an additive constant, which is fixed by a gauge condition.\n\nOnce $w_j$ is found, the $j$-th column of the effective permittivity tensor is given by the average of the local displacement field $\\mathbf{D}_j(\\mathbf{x}) = \\varepsilon(\\mathbf{x})(\\mathbf{e}_j - \\nabla w_j(\\mathbf{x}))$:\n$$\n\\bar{\\bar{\\varepsilon}}_{\\text{eff}} \\mathbf{e}_j = \\langle \\mathbf{D}_j \\rangle = \\frac{1}{|\\Omega|} \\int_{\\Omega} \\varepsilon(\\mathbf{x}) (\\mathbf{e}_j - \\nabla w_j(\\mathbf{x})) \\, d\\mathbf{x}\n$$\nwhere $\\Omega$ is the unit cell domain, and $|\\Omega|$ is its area.\n\n### 2. Numerical Discretization using Finite-Volume Method\n\nWe discretize the unit cell (of side length $a=1$) into a uniform $N \\times N$ grid of cells, with grid spacing $h=1/N$. The corrector potential $w$ is defined at the center of each cell $(i,j)$, denoted $w_{i,j}$. The permittivity $\\varepsilon$ is treated as piecewise constant within each cell, with value $\\varepsilon_{i,j}$ determined by the cell's central coordinate.\n\nThe cell problem is integrated over each control volume (cell) $V_{i,j}$ and the divergence theorem is applied, leading to a flux balance equation:\n$$\n\\int_{\\partial V_{i,j}} \\varepsilon(\\mathbf{x}) \\nabla w_j \\cdot \\hat{\\mathbf{n}} \\, dS = \\int_{\\partial V_{i,j}} \\varepsilon(\\mathbf{x}) \\mathbf{e}_j \\cdot \\hat{\\mathbf{n}} \\, dS\n$$\nThe fluxes are evaluated at the four faces of each cell (East, West, North, South). For the left-hand side (LHS), the flux across the face between cell $(i,j)$ and its eastern neighbor $(i+1, j)$ is approximated as:\n$$\nF_{\\text{LHS, E}} = h \\cdot \\varepsilon_{i+1/2, j} \\frac{w_{i+1,j} - w_{i,j}}{h} = \\varepsilon_{i+1/2, j} (w_{i+1,j} - w_{i,j})\n$$\nwhere $\\varepsilon_{i+1/2, j}$ is the permittivity at the face. To ensure flux continuity across material interfaces, we use the harmonic average as specified:\n$$\n\\varepsilon_{i+1/2, j} = \\frac{2 \\varepsilon_{i,j} \\varepsilon_{i+1,j}}{\\varepsilon_{i,j} + \\varepsilon_{i+1,j}}\n$$\nSumming the outgoing fluxes for all four faces gives the discrete equation for cell $(i,j)$:\n$$\n\\varepsilon_{i+1/2,j}(w_{i,j}-w_{i+1,j}) + \\varepsilon_{i-1/2,j}(w_{i,j}-w_{i-1,j}) + \\varepsilon_{i,j+1/2}(w_{i,j}-w_{i,j+1}) + \\varepsilon_{i,j-1/2}(w_{i,j}-w_{i,j-1}) = \\text{RHS}_{i,j}\n$$\nThe right-hand side (RHS) is the net flux of $\\varepsilon \\mathbf{e}_j$. For $j=x$, this involves fluxes only across the East and West faces:\n$$\n\\text{RHS}_{i,j}^{(x)} = (h \\cdot \\varepsilon_{i+1/2,j} \\cdot 1) - (h \\cdot \\varepsilon_{i-1/2,j} \\cdot 1) = h(\\varepsilon_{i+1/2, j} - \\varepsilon_{i-1/2, j})\n$$\nSimilarly, for $j=y$, the RHS involves fluxes across the North and South faces:\n$$\n\\text{RHS}_{i,j}^{(y)} = h(\\varepsilon_{i, j+1/2} - \\varepsilon_{i, j-1/2})\n$$\nPeriodic boundary conditions are imposed by wrapping indices around, e.g., $w_{N,j} = w_{0,j}$, $w_{i,-1} = w_{i,N-1}$.\nThis formulation results in a sparse linear system of equations $A \\mathbf{w} = \\mathbf{b}$ for the $N^2$ unknown corrector values, where $\\mathbf{w}$ is the flattened vector of $w_{i,j}$. Due to the periodic boundary conditions, the matrix $A$ is singular (its null space contains the constant vector). To obtain a unique solution, we fix the gauge by setting the potential at one node to zero, e.g., $w_{0,0}=0$. This is implemented by modifying the first row and right-hand side of the linear system to enforce this constraint, rendering the system non-singular.\n\n### 3. Computation of Effective Permittivity\n\nAfter solving the linear systems for the corrector potentials $w_x$ and $w_y$, we compute\nthe components of $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$. This requires averaging the local displacement field $\\mathbf{D}_j = \\varepsilon(\\mathbf{e}_j-\\nabla w_j)$ over all cells. The gradient $\\nabla w_j$ at the center of cell $(i,j)$ is approximated using central differences with periodic indexing:\n$$\n(\\nabla w_j)_{i,j} \\approx \\left( \\frac{w_j(i+1,j) - w_j(i-1,j)}{2h}, \\frac{w_j(i,j+1) - w_j(i,j-1)}{2h} \\right)\n$$\nThe components of the effective tensor are then computed by averaging over all $N^2$ cells:\n$$\n\\varepsilon_{xx} = \\langle D_{x,x} \\rangle = \\frac{1}{N^2} \\sum_{i,j} \\varepsilon_{i,j} \\left(1 - (\\partial_x w_x)_{i,j}\\right)\n$$\n$$\n\\varepsilon_{yx} = \\langle D_{x,y} \\rangle = \\frac{1}{N^2} \\sum_{i,j} \\varepsilon_{i,j} \\left(- (\\partial_y w_x)_{i,j}\\right)\n$$\n$$\n\\varepsilon_{xy} = \\langle D_{y,x} \\rangle = \\frac{1}{N^2} \\sum_{i,j} \\varepsilon_{i,j} \\left(- (\\partial_x w_y)_{i,j}\\right)\n$$\n$$\n\\varepsilon_{yy} = \\langle D_{y,y} \\rangle = \\frac{1}{N^2} \\sum_{i,j} \\varepsilon_{i,j} \\left(1 - (\\partial_y w_y)_{i,j}\\right)\n$$\n\n### 4. Implementation Steps\n\nThe provided test cases are solved by a single script that:\n1.  For each test case $(\\varepsilon_1, \\varepsilon_2, \\eta)$, calculates the required grid size $N = \\lceil N_0 / \\eta \\rceil$ with $N_0 = 12$.\n2.  Constructs the permittivity grid $\\varepsilon_{i,j}$ corresponding to the checkerboard pattern.\n3.  For each corrector ($w_x, w_y$), assembles the sparse matrix $A$ and right-hand side vector $\\mathbf{b}$.\n4.  Modifies the system to enforce the gauge condition $w_{0,0}=0$ and solves for the corrector potential using a sparse linear solver.\n5.  Calculates the components of $\\bar{\\bar{\\varepsilon}}_{\\text{eff}}$ by numerically differentiating the correctors and averaging the resulting displacement fields.\n6.  Computes the final required output quantities (isotropic estimates, convergence ratio, deviation, and diagnostic measures) from the effective permittivity tensors of the four test cases.\nThis procedure is systematically applied to generate the final output vector. For the homogeneous case ($\\varepsilon_1=\\varepsilon_2$), the corrector should be zero and the effective permittivity tensor should be diagonal with entries equal to the constant permittivity, providing a valuable validation of the numerical method. The numerical result will show a small deviation from this analytical solution, representing the discretization and floating-point error of the simulation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases and print the results.\n    \"\"\"\n    \n    def compute_eff_eps(eps1, eps2, N):\n        \"\"\"\n        Computes the effective permittivity tensor for a checkerboard metamaterial.\n\n        Args:\n            eps1 (float): Permittivity of first material.\n            eps2 (float): Permittivity of second material.\n            N (int): Number of grid points along one dimension.\n\n        Returns:\n            numpy.ndarray: The 2x2 effective permittivity tensor.\n        \"\"\"\n        a = 1.0\n        h = a / N\n\n        # 1. Setup Grid and Permittivity\n        eps_grid = np.zeros((N, N))\n        for i in range(N):\n            for j in range(N):\n                is_ll = (i  N / 2) and (j  N / 2)  # Lower-left\n                is_ur = (i >= N / 2) and (j >= N / 2) # Upper-right\n                if is_ll or is_ur:\n                    eps_grid[i, j] = eps1\n                else:\n                    eps_grid[i, j] = eps2\n\n        # 2. Solve for correctors w_x and w_y\n        correctors = {}\n        for dim_idx, j_dim in enumerate(['x', 'y']):\n            # 3. Build linear system A*w = b\n            A = lil_matrix((N * N, N * N), dtype=np.float64)\n            b = np.zeros(N * N, dtype=np.float64)\n\n            for i in range(N):\n                for j in range(N):\n                    k = i * N + j\n\n                    # Get periodic neighbor indices\n                    ip1, im1 = (i + 1) % N, (i - 1 + N) % N\n                    jp1, jm1 = (j + 1) % N, (j - 1 + N) % N\n\n                    # Harmonic mean for face permittivities\n                    eps_E = 2 * eps_grid[i, j] * eps_grid[ip1, j] / (eps_grid[i, j] + eps_grid[ip1, j])\n                    eps_W = 2 * eps_grid[i, j] * eps_grid[im1, j] / (eps_grid[i, j] + eps_grid[im1, j])\n                    eps_N = 2 * eps_grid[i, j] * eps_grid[i, jp1] / (eps_grid[i, j] + eps_grid[i, jp1])\n                    eps_S = 2 * eps_grid[i, j] * eps_grid[i, jm1] / (eps_grid[i, j] + eps_grid[i, jm1])\n\n                    # Assemble stiffness matrix A (5-point stencil)\n                    # The equation for node k is sum_faces(eps_face * (w_k - w_neighbor)) = RHS\n                    A[k, k] = eps_E + eps_W + eps_N + eps_S\n                    A[k, ip1 * N + j] -= eps_E\n                    A[k, im1 * N + j] -= eps_W\n                    A[k, i * N + jp1] -= eps_N\n                    A[k, i * N + jm1] -= eps_S\n                    \n                    # Assemble RHS vector b = h * div(eps * e_j)\n                    if j_dim == 'x':\n                        b[k] = h * (eps_E - eps_W)\n                    else:  # j_dim == 'y'\n                        b[k] = h * (eps_N - eps_S)\n\n            # 4. Apply gauge condition (fix w[0,0] = 0)\n            k_fix = 0\n            A_csr = A.tocsr() # Convert for efficient row slicing\n            A_csr[k_fix, :] = 0.0\n            A_csr[k_fix, k_fix] = 1.0\n            b[k_fix] = 0.0\n            \n            # 5. Solve for w\n            w_flat = spsolve(A_csr.tocsc(), b) # CSC is good for spsolve\n            correctors[j_dim] = w_flat.reshape((N, N))\n\n        w_x, w_y = correctors['x'], correctors['y']\n\n        # 6. Compute effective permittivity tensor\n        grad_wx_x, grad_wx_y = np.zeros_like(w_x), np.zeros_like(w_x)\n        grad_wy_x, grad_wy_y = np.zeros_like(w_y), np.zeros_like(w_y)\n\n        # Central difference for gradients with periodic BCs\n        for i in range(N):\n            for j in range(N):\n                ip1, im1 = (i + 1) % N, (i - 1 + N) % N\n                jp1, jm1 = (j + 1) % N, (j - 1 + N) % N\n                grad_wx_x[i, j] = (w_x[ip1, j] - w_x[im1, j]) / (2 * h)\n                grad_wx_y[i, j] = (w_x[i, jp1] - w_x[i, jm1]) / (2 * h)\n                grad_wy_x[i, j] = (w_y[ip1, j] - w_y[im1, j]) / (2 * h)\n                grad_wy_y[i, j] = (w_y[i, jp1] - w_y[i, jm1]) / (2 * h)\n\n        # Local E fields\n        Ex_x, Ex_y = 1 - grad_wx_x, -grad_wx_y\n        Ey_x, Ey_y = -grad_wy_x, 1 - grad_wy_y\n\n        # Average D fields\n        eps_xx = np.mean(eps_grid * Ex_x)\n        eps_yx = np.mean(eps_grid * Ex_y)\n        eps_xy = np.mean(eps_grid * Ey_x)\n        eps_yy = np.mean(eps_grid * Ey_y)\n        \n        return np.array([[eps_xx, eps_xy], [eps_yx, eps_yy]])\n\n    N0 = 12.0\n    test_cases_params = [\n        (2.0, 8.0, 0.5),\n        (2.0, 8.0, 0.25),\n        (2.0, 8.0, 0.125),\n        (5.0, 5.0, 0.25)\n    ]\n    \n    # Calculate grid sizes\n    Ns = [int(np.ceil(N0 / eta)) for _, _, eta in test_cases_params]\n\n    # Run simulations\n    eps_eff_1 = compute_eff_eps(test_cases_params[0][0], test_cases_params[0][1], Ns[0])\n    eps_eff_2 = compute_eff_eps(test_cases_params[1][0], test_cases_params[1][1], Ns[1])\n    eps_eff_3 = compute_eff_eps(test_cases_params[2][0], test_cases_params[2][1], Ns[2])\n    eps_eff_4 = compute_eff_eps(test_cases_params[3][0], test_cases_params[3][1], Ns[3])\n\n    # Compute required outputs\n    I1 = 0.5 * (eps_eff_1[0, 0] + eps_eff_1[1, 1])\n    I2 = 0.5 * (eps_eff_2[0, 0] + eps_eff_2[1, 1])\n    I3 = 0.5 * (eps_eff_3[0, 0] + eps_eff_3[1, 1])\n    \n    # Convergence ratio\n    # Add a small epsilon to denominator to avoid division by zero if convergence is perfect\n    R = abs(I1 - I2) / (abs(I2 - I3) + 1e-18)\n    \n    # Absolute deviation for homogeneous case\n    I4_iso = 0.5 * (eps_eff_4[0, 0] + eps_eff_4[1, 1])\n    Delta = abs(I4_iso - test_cases_params[3][0])\n    \n    # Diagnostics for case 2\n    avg_diag_2 = I2\n    Aniso = abs(eps_eff_2[0, 0] - eps_eff_2[1, 1]) / avg_diag_2\n    OffDiag = max(abs(eps_eff_2[0, 1]), abs(eps_eff_2[1, 0])) / avg_diag_2\n    \n    results = [I1, I2, I3, R, Delta, Aniso, OffDiag]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3314289"}, {"introduction": "While calculating effective parameters from a unit cell is fundamental, it is equally important to understand how these parameters are measured or inferred from a finite-sized metamaterial slab. The reflection and transmission coefficients ($S$-parameters) of a slab are directly related to its effective refractive index and impedance, and inverting this relationship is a standard characterization technique. This practice will guide you through retrieving an effective refractive index $n_{\\mathrm{eff}}(\\theta)$ from simulated $S$-parameters, allowing you to discover how phenomena like anisotropy and spatial dispersion reveal themselves as an angular dependence in the retrieved parameters [@problem_id:3314219].", "problem": "You are given a metamaterial slab of thickness $d=5a$ under plane-wave oblique incidence in vacuum, with the lattice constant $a$ and thickness $d$ specified as physical lengths. The objective is to retrieve the scalar effective refractive index $n_{\\mathrm{eff}}(\\theta)$ as a function of incidence angle $\\theta$ from complex scattering parameters (Scattering parameters (S-parameters)) $S_{11}(\\theta)$ and $S_{21}(\\theta)$, and to use the variation of the real part of $n_{\\mathrm{eff}}(\\theta)$ across angles to assess isotropy and spatial dispersion. Your derivation and algorithm must start from the macroscopic Maxwell equations, the definition of plane-wave propagation in homogeneous media, and the continuity of tangential electromagnetic fields at interfaces, and use these principles to establish a retrieval method for the longitudinal wave number inside the slab. No shortcut formulas are to be assumed; the retrieval must follow from first principles and well-tested definitions.\n\nFundamental base:\n- Start from the source-free macroscopic Maxwell equations in the frequency domain with time-harmonic fields $e^{-i\\omega t}$: $\\nabla \\times \\mathbf{E} = i\\omega \\mathbf{B}$ and $\\nabla \\times \\mathbf{H} = - i\\omega \\mathbf{D}$, with constitutive relations $\\mathbf{D} = \\underline{\\underline{\\varepsilon}} \\mathbf{E}$ and $\\mathbf{B} = \\mu \\mathbf{H}$.\n- For vacuum, use $\\varepsilon_0$ and $\\mu_0$ and the speed of light $c$, with $k_0 = \\omega/c$.\n- Define a plane wave in vacuum incident at angle $\\theta$ to the slab normal (taken as $\\hat{z}$): the conserved tangential wave number is $k_x = k_0 \\sin\\theta$, the vacuum longitudinal component is $k_{z0} = k_0 \\cos\\theta$.\n- For a homogeneous slab, define the longitudinal wave number inside the material as $k_z$, and the appropriate polarization-dependent wave impedance $Z$ or admittance based on the ratio of tangential fields. Consider transverse-magnetic (TM) polarization, where the tangential electric and magnetic fields satisfy $Z = E_t/H_t$.\n- Use the transfer (ABCD) matrix of a homogeneous slab of thickness $d$ and wave impedance $Z$ to relate the fields at the input and output interfaces. Combine it with equal port impedances $Z_0$ for vacuum to express $S_{11}$ and $S_{21}$ in terms of the slab parameters. From those relations, retrieve $k_z d$ via a principled inversion and then map to $n_{\\mathrm{eff}}(\\theta)$ by enforcing the isotropic dispersion ansatz $k_z^2 + k_x^2 = n_{\\mathrm{eff}}^2 k_0^2$.\n\nAssessment of anisotropy and spatial dispersion:\n- For an isotropic, local medium with scalar $\\varepsilon$ and $\\mu$, the retrieved $n_{\\mathrm{eff}}(\\theta)$ should be independent of $\\theta$. A variation with $\\theta$ indicates breakdown of a scalar, local description and can arise from anisotropy (tensorial $\\underline{\\underline{\\varepsilon}}$) or nonlocality (spatial dispersion where $\\varepsilon$ depends on wave vector).\n- Quantify this by computing the standard deviation of $\\Re\\{n_{\\mathrm{eff}}(\\theta)\\}$ over several angles; small values indicate angle invariance consistent with an isotropic local medium, while larger values indicate anisotropy or nonlocality.\n\nPhysical and numerical units and conventions:\n- Use $a$ and $d$ in meters. The frequency $f$ must be in Hertz. Angles $\\theta$ must be provided in degrees and interpreted in radians internally. All retrieved $n_{\\mathrm{eff}}(\\theta)$ are dimensionless.\n- The final metric must be computed using the real part of the retrieved $n_{\\mathrm{eff}}(\\theta)$.\n\nTest suite and parameters:\n- Use $a = 1\\times 10^{-3}$ meters, $d = 5 a$ meters, and $f = 1\\times 10^{10}$ Hertz. Use vacuum surrounding the slab.\n- Evaluate at the set of incidence angles $\\{\\theta\\} = \\{0, 30, 60\\}$ in degrees.\n- Consider three metamaterial models under TM polarization:\n  1. Isotropic local model: scalar relative permittivity $\\varepsilon_r = 2.25$ and scalar relative permeability $\\mu_r = 1.0$.\n  2. Uniaxial anisotropic local model with optic axis normal to the slab ($\\hat{z}$): transverse relative permittivity $\\varepsilon_t = 2.25$, normal relative permittivity $\\varepsilon_z = 4.0$, and scalar relative permeability $\\mu_r = 1.0$.\n  3. Isotropic spatially dispersive model: scalar relative permeability $\\mu_r = 1.0$ and scalar relative permittivity $\\varepsilon_r(k_x) = \\varepsilon_{r0} + \\alpha (k_x/k_0)^2$ with $\\varepsilon_{r0} = 2.25$ and $\\alpha = 0.3$.\n\nYour program must:\n- Generate the complex $S_{11}(\\theta)$ and $S_{21}(\\theta)$ for each model and angle using the transfer-matrix formulation based on boundary conditions and mode impedances appropriate to TM polarization.\n- Retrieve $k_z d$ from the generated $S$-parameters by inverting the transfer relations without shortcut assumptions and select the physically continuous branch across angles.\n- Compute $n_{\\mathrm{eff}}(\\theta)$ for each model from $k_z$ using $n_{\\mathrm{eff}}(\\theta) = \\sqrt{(k_z/k_0)^2 + \\sin^2\\theta}$, and take its real part.\n- For each model, compute the standard deviation of $\\Re\\{n_{\\mathrm{eff}}(\\theta)\\}$ over the three angles as a single dimensionless float.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the models listed above, for example $[\\text{iso},\\text{uniaxial},\\text{nonlocal}]$, where each entry is the standard deviation computed as specified. The floats must be dimensionless.\n\nNo user input is required; the program must run as is and use the specified parameters and test suite internally.", "solution": "The user has provided a well-posed problem in computational electromagnetics concerning the retrieval of an effective refractive index for a metamaterial slab from its scattering parameters ($S$-parameters). The problem is scientifically grounded, free of contradictions, and contains all necessary information to proceed with a unique solution. The validation is passed.\n\nThe core of the problem is to first establish a forward model relating the material properties of a slab to its $S$-parameters ($S_{11}, S_{21}$) under transverse-magnetic (TM) plane-wave incidence, and then to derive and implement a robust inversion of this model to retrieve an effective refractive index $n_{\\mathrm{eff}}(\\theta)$ from the $S$-parameters.\n\nThe derivation and solution will proceed in three main steps:\n1.  **Forward Model**: Derivation of $S_{11}(\\theta)$ and $S_{21}(\\theta)$ from the slab's properties using the transfer matrix method, which is based on Maxwell's equations and boundary conditions.\n2.  **Inverse Model**: Derivation of a method to retrieve the longitudinal wavenumber $k_z$ and, subseqently, the effective refractive index $n_{\\mathrm{eff}}$ from the computed $S$-parameters. This must be done from first principles as requested.\n3.  **Numerical Implementation**: Application of the derived forward and inverse models to the three specified metamaterial cases to compute the standard deviation of $\\Re\\{n_{\\mathrm{eff}}(\\theta)\\}$, which serves as a metric for anisotropy and spatial dispersion.\n\nThroughout this derivation, all mathematical entities are rendered in LaTeX as required. The time-harmonic convention is $e^{-i\\omega t}$. The slab is positioned in the region $0 \\le z \\le d$.\n\n**1. Forward Model: From Material Properties to S-Parameters**\n\nFor a TM (p-polarized) plane wave, the magnetic field is oriented along the $y$-axis, $\\mathbf{H} = H_y(x,z) \\hat{y}$, and the electric field lies in the $x-z$ plane. The fields have a spatial dependence of $e^{i k_x x}$, where the tangential wavenumber $k_x = k_0 \\sin\\theta$ is conserved across all interfaces. Here, $k_0 = \\omega/c = 2\\pi f/c$ is the free-space wavenumber and $\\theta$ is the angle of incidence with respect to the normal ($\\hat{z}$-axis).\n\nThe relationship between the tangential electric field $E_x$ and tangential magnetic field $H_y$ for a forward-propagating TM wave defines the characteristic wave impedance, $Z_{\\text{TM}} = E_x / H_y$.\n\n**A. Wave Propagation and Impedance in Each Medium**\n\n*   **Vacuum (Regions $z0$ and $z>d$)**: The dispersion relation is $k_x^2 + k_{z0}^2 = k_0^2$. The longitudinal wavenumber is $k_{z0} = \\sqrt{k_0^2 - k_x^2} = k_0 \\cos\\theta$. The TM wave impedance in vacuum is $Z_{c0}^{\\text{TM}} = \\frac{k_{z0}}{\\omega\\varepsilon_0} = \\frac{k_0 \\cos\\theta}{\\omega\\varepsilon_0} = Z_0 \\cos\\theta$, where $Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}$ is the impedance of free space.\n\n*   **Slab Material (Region $0 \\le z \\le d$)**: The properties depend on the model.\n    1.  **Isotropic Local Model**: With scalar $\\varepsilon = \\varepsilon_r \\varepsilon_0$ and $\\mu = \\mu_r \\mu_0$, the dispersion relation is $k_x^2 + k_z^2 = k_0^2 \\varepsilon_r \\mu_r$. The longitudinal wavenumber is $k_z = \\sqrt{k_0^2 \\varepsilon_r \\mu_r - k_x^2} = k_0\\sqrt{\\varepsilon_r \\mu_r - \\sin^2\\theta}$. The TM impedance is $Z_c^{\\text{TM}} = \\frac{k_z}{\\omega\\varepsilon} = \\frac{k_z}{\\omega\\varepsilon_r\\varepsilon_0}$.\n    2.  **Uniaxial Anisotropic Model**: With $\\underline{\\underline{\\varepsilon}} = \\varepsilon_0 \\mathrm{diag}(\\varepsilon_t, \\varepsilon_t, \\varepsilon_z)$ and scalar $\\mu=\\mu_r\\mu_0$, the dispersion relation for TM modes is $\\frac{k_x^2}{\\varepsilon_z} + \\frac{k_z^2}{\\varepsilon_t} = k_0^2 \\mu_r$. The longitudinal wavenumber is $k_z = k_0\\sqrt{\\varepsilon_t(\\mu_r - \\sin^2\\theta/\\varepsilon_z)}$. The TM impedance is $Z_c^{\\text{TM}} = \\frac{k_z}{\\omega\\varepsilon_t\\varepsilon_0}$.\n    3.  **Isotropic Spatially Dispersive Model**: With $\\varepsilon(k_x) = \\varepsilon_0(\\varepsilon_{r0} + \\alpha(k_x/k_0)^2)$ and $\\mu=\\mu_r\\mu_0$, the dispersion relation is $k_x^2 + k_z^2 = k_0^2 \\mu_r \\varepsilon_r(k_x)$. For $\\mu_r=1$, this gives $k_z = k_0\\sqrt{\\varepsilon_{r0} + (\\alpha-1)\\sin^2\\theta}$. The TM impedance is $Z_c^{\\text{TM}} = \\frac{k_z}{\\omega\\varepsilon(k_x)} = \\frac{k_z}{\\omega\\varepsilon_0\\varepsilon_r(k_x)}$.\n\n**B. Transfer Matrix and S-Parameters**\n\nThe fields at the input ($z=0$) and output ($z=d$) of the slab are related by a transfer (ABCD) matrix. For a uniform slab of thickness $d$, propagation constant $k_z$, and characteristic impedance $Z_c^{\\text{TM}}$, this matrix is:\n$$\n\\begin{pmatrix} A  B \\\\ C  D \\end{pmatrix} = \\begin{pmatrix} \\cos(k_z d)  i Z_c^{\\text{TM}} \\sin(k_z d) \\\\ i (Z_c^{\\text{TM}})^{-1} \\sin(k_z d)  \\cos(k_z d) \\end{pmatrix}\n$$\nThe S-parameters for this two-port network, with identical port impedances $Z_{c0}^{\\text{TM}}$, are derived from the ABCD matrix:\n$$\nS_{11} = \\frac{A + B/Z_{c0}^{\\text{TM}} - C Z_{c0}^{\\text{TM}} - D}{A + B/Z_{c0}^{\\text{TM}} + C Z_{c0}^{\\text{TM}} + D} \\quad , \\quad S_{21} = \\frac{2}{A + B/Z_{c0}^{\\text{TM}} + C Z_{c0}^{\\text{TM}} + D}\n$$\nSubstituting the matrix elements and defining the normalized impedance $z = Z_c^{\\text{TM}} / Z_{c0}^{\\text{TM}}$, we arrive at:\n$$\nS_{11} = \\frac{i(z^2 - 1) \\sin(k_z d)}{2z\\cos(k_z d) + i(z^2+1)\\sin(k_z d)} = \\frac{\\frac{i}{2}(z - 1/z) \\sin(k_z d)}{\\cos(k_z d) + \\frac{i}{2}(z+1/z)\\sin(k_z d)}\n$$\n$$\nS_{21} = \\frac{2z}{2z\\cos(k_z d) + i(z^2+1)\\sin(k_z d)} = \\frac{1}{\\cos(k_z d) + \\frac{i}{2}(z+1/z)\\sin(k_z d)}\n$$\nThese equations form the forward model used to generate synthetic $S$-parameter data for the given material models.\n\n**2. Inverse Model: From S-Parameters to Material Properties**\n\nThe problem requires a principled inversion of the above system to find $k_z$ and $z$ from $S_{11}$ and $S_{21}$. A robust algebraic path is to first determine the reflection coefficient $r$ at the slab interface. From the S-parameter expressions, one can derive a quadratic equation for $r+1/r$:\n$$\nr + 1/r = \\frac{1 + S_{11}^2 - S_{21}^2}{S_{11}}\n$$\nLet $K = \\frac{1 + S_{11}^2 - S_{21}^2}{2S_{11}}$. The equation becomes $r^2 - 2Kr + 1 = 0$, with solutions $r = K \\pm \\sqrt{K^2-1}$. For a passive material, the reflection coefficient must satisfy $|r| \\le 1$. This condition is used to select the correct physical root.\n\nOnce $r$ is determined, the normalized impedance is found via $z = (1+r)/(1-r)$. A passive medium requires $\\Re\\{z\\} \\ge 0$.\n\nNext, we establish a relation for the propagation factor. From the forward equations, it can be shown that:\n$$\ne^{ik_z d} = \\frac{1 - S_{11} r}{S_{21}}\n$$\nFrom this, the complex product $k_z d$ is retrieved using the complex logarithm:\n$$\nk_z d = -i \\log\\left(\\frac{1 - S_{11} r}{S_{21}}\\right)\n$$\nThe complex logarithm is multi-valued: $\\log(w) = \\ln|w| + i(\\arg(w) + 2\\pi m)$, where $m$ is an integer. This leads to an ambiguity in the real part of $k_z d$.\nLet $w = (1-S_{11}r)/S_{21} = e^{ik_z d}$. Then:\n$$\nk_z d = -i \\log(w) = -i (\\ln|w| + i(\\arg(w) + 2\\pi m)) = (\\arg(w) + 2\\pi m) - i \\ln|w|\n$$\nFor a passive medium, waves must decay. For an $e^{-i\\omega t}$ convention and a propagation factor $e^{ik_z z}$, this means $\\Im\\{k_z\\}$ must be non-positive. Thus, $\\Im\\{k_z d\\} = -\\ln|w| \\le 0$, which requires $|w| \\ge 1$. This provides another constraint on the choice of $r$. The ambiguity in the real part is resolved by starting with $m=0$ for the first incidence angle ($\\theta=0^{\\circ}$) and then choosing $m$ for subsequent angles to ensure that $\\Re\\{k_z(\\theta)\\}$ is a continuous function.\n\n**3. Retrieval of Effective Refractive Index**\n\nThe retrieved $k_z$ is related to the effective refractive index $n_{\\mathrm{eff}}$ through the isotropic dispersion relation ansatz, which defines $n_{\\mathrm{eff}}$:\n$$\nk_x^2 + k_z^2 = (n_{\\mathrm{eff}} k_0)^2\n$$\nSubstituting $k_x = k_0 \\sin\\theta$ and solving for $n_{\\mathrm{eff}}$ gives:\n$$\nn_{\\mathrm{eff}}(\\theta) = \\sqrt{\\left(\\frac{k_z}{k_0}\\right)^2 + \\sin^2\\theta}\n$$\nThe principal root ($\\Re\\{n_{\\mathrm{eff}}\\} \\ge 0$) is chosen.\n\nFor a truly isotropic and local medium, the retrieved $n_{\\mathrm{eff}}(\\theta)$ will be a constant, equal to the material's true refractive index. For the anisotropic and spatially dispersive models, $n_{\\mathrm{eff}}(\\theta)$ will vary with the angle of incidence $\\theta$. The standard deviation of $\\Re\\{n_{\\mathrm{eff}}(\\theta)\\}$ over the specified angles serves as a quantitative measure of this angular dependence.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import c as C0, mu_0, epsilon_0\n\ndef solve():\n    \"\"\"\n    Main function to perform the metamaterial analysis.\n    It calculates S-parameters for three different slab models, retrieves\n    the effective refractive index n_eff(theta), and computes the standard\n    deviation of Re(n_eff) across incidence angles as a measure of\n    anisotropy or spatial dispersion.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    a = 1e-3  # meters\n    d = 5 * a  # meters\n    f = 1e10  # Hertz\n    angles_deg = [0, 30, 60]\n\n    # --- Physical Constants and Derived Parameters ---\n    Z0 = np.sqrt(mu_0 / epsilon_0)  # Impedance of free space\n    omega = 2 * np.pi * f\n    k0 = omega / C0\n\n    # --- Test Case Models ---\n    models = [\n        {\n            \"name\": \"Isotropic\",\n            \"type\": \"isotropic\",\n            \"params\": {\"eps_r\": 2.25, \"mu_r\": 1.0}\n        },\n        {\n            \"name\": \"Uniaxial\",\n            \"type\": \"uniaxial\",\n            \"params\": {\"eps_t\": 2.25, \"eps_z\": 4.0, \"mu_r\": 1.0}\n        },\n        {\n            \"name\": \"Spatially Dispersive\",\n            \"type\": \"spatially_dispersive\",\n            \"params\": {\"eps_r0\": 2.25, \"alpha\": 0.3, \"mu_r\": 1.0}\n        }\n    ]\n\n    final_results = []\n\n    for model in models:\n        n_eff_real_parts = []\n        prev_k_z_d_real = None\n\n        for theta_deg in angles_deg:\n            theta_rad = np.deg2rad(theta_deg)\n            kx = k0 * np.sin(theta_rad)\n\n            # --- 1. Forward Model: Calculate S-parameters ---\n            \n            # Impedance of vacuum for TM waves at angle theta\n            k_z0 = k0 * np.cos(theta_rad)\n            Zc0_tm = Z0 * np.cos(theta_rad) if np.cos(theta_rad) > 1e-9 else Z0\n\n            # Calculate slab properties based on model\n            if model[\"type\"] == \"isotropic\":\n                eps_r = model[\"params\"][\"eps_r\"]\n                mu_r = model[\"params\"][\"mu_r\"]\n                n_sq = eps_r * mu_r\n                k_z_sq = k0**2 * n_sq - kx**2\n                k_z = np.sqrt(k_z_sq)\n                Zc_tm = k_z / (omega * eps_r * epsilon_0)\n                \n            elif model[\"type\"] == \"uniaxial\":\n                eps_t = model[\"params\"][\"eps_t\"]\n                eps_z = model[\"params\"][\"eps_z\"]\n                mu_r = model[\"params\"][\"mu_r\"]\n                k_z_sq = eps_t * (k0**2 * mu_r - kx**2 / eps_z)\n                k_z = np.sqrt(k_z_sq)\n                Zc_tm = k_z / (omega * eps_t * epsilon_0)\n\n            elif model[\"type\"] == \"spatially_dispersive\":\n                eps_r0 = model[\"params\"][\"eps_r0\"]\n                alpha = model[\"params\"][\"alpha\"]\n                mu_r = model[\"params\"][\"mu_r\"]\n                eps_r_kx = eps_r0 + alpha * (kx / k0)**2\n                k_z_sq = k0**2 * mu_r * eps_r_kx - kx**2\n                k_z = np.sqrt(k_z_sq)\n                Zc_tm = k_z / (omega * eps_r_kx * epsilon_0)\n\n            # Normalized impedance\n            z_norm = Zc_tm / Zc0_tm\n\n            # Calculate S-parameters from ABCD matrix relations\n            cos_kzd = np.cos(k_z * d)\n            sin_kzd = np.sin(k_z * d)\n            denominator = 2 * cos_kzd + 1j * (z_norm + 1/z_norm) * sin_kzd\n            S11 = 1j * (z_norm - 1/z_norm) * sin_kzd / denominator\n            S21 = 2 / denominator\n            \n            # --- 2. Inverse Model: Retrieve k_z and n_eff ---\n\n            # Suppress division by zero warnings for S11=0 at normal incidence\n            with np.errstate(divide='ignore', invalid='ignore'):\n                 K = (1 + S11**2 - S21**2) / (2 * S11)\n            \n            if np.abs(S11)  1e-9: # Handle normal incidence case where S11 might be 0\n                # When S11=0, r=0, z=1. k_z d from S21\n                # 1/S21 = cos(kzd), so kzd = arccos(1/S21)\n                k_z_d_retrieved = np.arccos(1/S21)\n            else:\n                # Solve r^2 - 2Kr + 1 = 0\n                sqrt_discriminant = np.sqrt(K**2 - 1, dtype=np.complex128)\n                r1 = K + sqrt_discriminant\n                r2 = K - sqrt_discriminant\n                \n                # Select physical root |r| = 1\n                r = r1 if abs(r1) = abs(r2) else r2\n                \n                # Retrieve propagation factor exp(i*k_z*d)\n                exp_ikzd = (1 - S11 * r) / S21\n                \n                # Retrieve k_z * d from complex log, resolving 2*pi ambiguity\n                k_z_d_retrieved = -1j * np.log(exp_ikzd)\n                \n            # Phase unwrapping for continuity across angles\n            if prev_k_z_d_real is not None:\n                diff = k_z_d_retrieved.real - prev_k_z_d_real\n                m = np.round(diff / (2 * np.pi))\n                k_z_d_retrieved -= 2 * np.pi * m\n            prev_k_z_d_real = k_z_d_retrieved.real\n            \n            k_z_retrieved = k_z_d_retrieved / d\n            \n            # --- 3. Calculate Effective Refractive Index ---\n            n_eff_sq = (k_z_retrieved / k0)**2 + np.sin(theta_rad)**2\n            n_eff = np.sqrt(n_eff_sq)\n            \n            # Ensure Re(n_eff) >= 0\n            if n_eff.real  0:\n                n_eff = -n_eff\n            \n            n_eff_real_parts.append(n_eff.real)\n\n        # Compute standard deviation for the model\n        std_dev = np.std(n_eff_real_parts)\n        final_results.append(std_dev)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3314219"}, {"introduction": "The validity of any effective medium model is fundamentally limited to the long-wavelength regime, where the wavelength $\\lambda$ is much larger than the metamaterial's lattice constant $a$. As the wavevector magnitude $|\\mathbf{k}|$ increases, either through higher frequency or oblique incidence, the wave begins to resolve the discrete nature of the lattice, an effect known as spatial dispersion. This exercise offers a quantitative method to explore this breakdown by comparing a simple continuum dispersion relation with one derived from a discrete lattice model, allowing you to determine the precise limits of the homogenization approximation [@problem_id:3314227].", "problem": "Consider a three-dimensional simple cubic metamaterial lattice with period $a$ embedded in free space, where the free-space wavelength is $\\lambda$ and the free-space wavenumber is $k_0 = 2\\pi/\\lambda$. Let the lattice satisfy $a/\\lambda = 0.1$. An effective medium approximation models the structure as a homogeneous isotropic continuum with refractive index $n_{\\mathrm{eff}}$. To isolate the role of spatial dispersion caused by periodicity, assume $n_{\\mathrm{eff}} = 1$ so that the continuum dispersion relation for a plane wave of transverse (in-plane) wavevector magnitude $k_\\parallel$ reads $k_z^{\\mathrm{cont}} = \\sqrt{(n_{\\mathrm{eff}} k_0)^2 - k_\\parallel^2} = \\sqrt{k_0^2 - k_\\parallel^2}$, and the transmitted phase accumulated across a slab is proportional to $k_z^{\\mathrm{cont}}$.\n\nTo assess the breakdown of homogenization with oblique incidence, approximate the lattice-induced nonlocality using the discrete dispersion relation that arises from the second-order central-difference representation of the scalar Helmholtz operator on a simple cubic grid. For a plane-wave solution with components $(k_x, k_y, k_z)$, the discrete Bloch-Floquet relation is\n$$\n\\sin^2\\!\\left(\\frac{k_x a}{2}\\right) + \\sin^2\\!\\left(\\frac{k_y a}{2}\\right) + \\sin^2\\!\\left(\\frac{k_z a}{2}\\right) = \\left(\\frac{k_0 a}{2}\\right)^2.\n$$\nGiven a prescribed transverse magnitude $k_\\parallel$, consider two incidence configurations:\n- Axis-oblique: $k_x = k_\\parallel$, $k_y = 0$.\n- Face-diagonal-oblique: $k_x = k_y = k_\\parallel/\\sqrt{2}$.\n\nFor each configuration, define $k_z^{\\mathrm{disc}}$ as the positive real solution of the discrete relation (if it exists), and measure the relative phase error at fixed $k_\\parallel$ as\n$$\nE(k_\\parallel) = \\frac{\\left|k_z^{\\mathrm{disc}} - k_z^{\\mathrm{cont}}\\right|}{\\left|k_z^{\\mathrm{cont}}\\right|}.\n$$\nThe homogenization is deemed accurate when $E(k_\\parallel) \\le \\delta$, where $\\delta$ is a specified tolerance expressed as a decimal fraction. You must estimate the largest normalized transverse wavevector\n$$\n\\kappa_{\\max} = \\frac{k_\\parallel}{k_0}\n$$\nfor which the above accuracy criterion holds for both the axis-oblique and face-diagonal-oblique configurations. Additionally, for normal incidence $k_\\parallel = 0$, report whether the same accuracy criterion is satisfied.\n\nYour program must compute these quantities for a small test suite of $(a/\\lambda, \\delta)$ pairs. All quantities are dimensionless, so no physical unit conversion is required. The numerical steps should:\n- For a given $a/\\lambda$ and $\\delta$, set $k_0 a = 2\\pi (a/\\lambda)$.\n- For each configuration, search over $\\kappa \\in [0,1]$ (where $k_z^{\\mathrm{cont}}$ remains real) to find the largest $\\kappa_{\\max}$ such that the discrete solution exists and $E(k_\\parallel) \\le \\delta$ with $k_\\parallel = \\kappa k_0$.\n- For normal incidence ($k_\\parallel = 0$), compute $E(0)$ for the axis-oblique discrete relation and report a boolean indicating whether $E(0) \\le \\delta$.\n\nDesign your algorithm to be robust to edge cases, including the boundary $\\delta = 0$ and larger $a/\\lambda$ values approaching the breakdown of the homogenized model. Your implementation must not rely on any external input beyond the specified test suite.\n\nTest suite:\n1. $(a/\\lambda, \\delta) = (0.1, 0.05)$.\n2. $(a/\\lambda, \\delta) = (0.1, 0.0)$.\n3. $(a/\\lambda, \\delta) = (0.2, 0.05)$.\n4. $(a/\\lambda, \\delta) = (0.05, 0.05)$.\n\nOutput specification:\n- For each test case, output a list with three entries $[\\kappa_{\\max}^{\\mathrm{axis}}, \\kappa_{\\max}^{\\mathrm{diag}}, \\mathrm{normal\\_ok}]$, where $\\kappa_{\\max}^{\\mathrm{axis}}$ and $\\kappa_{\\max}^{\\mathrm{diag}}$ are floats rounded to six decimal places, and $\\mathrm{normal\\_ok}$ is a boolean indicating whether $E(0) \\le \\delta$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[[x_1,y_1,\\mathrm{True}],[x_2,y_2,\\mathrm{False}],\\dots]$.\n\nDerivation constraints:\n- Begin from Maxwellâ€™s equations and the scalar Helmholtz equation, then justify the use of the discrete central-difference dispersion to model lattice-induced spatial dispersion in a simple cubic metamaterial.\n- Do not use or cite any shortcut formulas without justification; base arguments on well-tested facts such as plane-wave solutions of the Helmholtz equation and Bloch-Floquet theory.\n- Ensure scientific realism and internal consistency for all parameters and approximations.", "solution": "The problem requires an analysis of the breakdown of the effective medium approximation for a simple cubic metamaterial lattice. This is accomplished by quantifying the phase error that arises due to the lattice-induced spatial dispersion, which is not captured by a simple local homogenization model. The analysis is based on comparing a continuum model with a discrete model derived from a finite-difference approximation of the scalar Helmholtz equation.\n\n**Theoretical Foundation: Continuum vs. Discrete Dispersion**\n\nThe propagation of monochromatic electromagnetic waves with angular frequency $\\omega$ is governed by Maxwell's equations, which can be combined into the vector Helmholtz equation. For certain polarizations or under a scalar approximation, the problem reduces to the scalar Helmholtz equation for a field component $\\psi$:\n$$\n\\nabla^2 \\psi(\\mathbf{r}) + n^2 k_0^2 \\psi(\\mathbf{r}) = 0\n$$\nwhere $k_0 = \\omega/c = 2\\pi/\\lambda$ is the free-space wavenumber and $n$ is the refractive index of the medium.\n\nIn a homogeneous, isotropic continuum, $n$ is a constant. The problem specifies an effective medium with $n_{\\mathrm{eff}} = 1$ to isolate spatial dispersion effects. The Helmholtz equation becomes $(\\nabla^2 + k_0^2)\\psi = 0$. For a plane-wave solution of the form $\\psi(\\mathbf{r}) = e^{i\\mathbf{k}\\cdot\\mathbf{r}}$, where $\\mathbf{k} = (k_x, k_y, k_z)$ is the wavevector, substituting into the equation yields the continuum dispersion relation:\n$$\nk_x^2 + k_y^2 + k_z^2 = k_0^2\n$$\nGiven a transverse wavevector $\\mathbf{k}_\\parallel = (k_x, k_y)$ with magnitude $k_\\parallel = \\sqrt{k_x^2 + k_y^2}$, the longitudinal component $k_z$ for a forward-propagating wave is:\n$$\nk_z^{\\mathrm{cont}} = \\sqrt{k_0^2 - k_\\parallel^2}\n$$\nThis relation is isotropic, meaning it depends only on the magnitude of the wavevector, not its direction.\n\nFor the metamaterial, the structure is a simple cubic lattice with period $a$. The periodicity breaks the continuous translational symmetry. An established method to model the lowest-order effects of this periodicity on wave propagation is to discretize the Helmholtz equation on a cubic grid matching the lattice. Replacing the continuous Laplacian operator $\\nabla^2$ with its second-order central-difference approximation leads to a modified dispersion relation. For a Bloch wave solution $\\psi_j \\propto e^{i\\mathbf{k}\\cdot\\mathbf{r}_j}$ on the grid points $\\mathbf{r}_j$, the finite-difference Helmholtz equation becomes:\n$$\n\\frac{e^{ik_xa} - 2 + e^{-ik_xa}}{a^2} + \\frac{e^{ik_ya} - 2 + e^{-ik_ya}}{a^2} + \\frac{e^{ik_za} - 2 + e^{-ik_za}}{a^2} + k_0^2 = 0\n$$\nUsing the identity $2(1-\\cos\\theta) = 4\\sin^2(\\theta/2)$, this equation can be rewritten as:\n$$\n-\\frac{4}{a^2}\\sin^2\\left(\\frac{k_x a}{2}\\right) - \\frac{4}{a^2}\\sin^2\\left(\\frac{k_y a}{2}\\right) - \\frac{4}{a^2}\\sin^2\\left(\\frac{k_z a}{2}\\right) + k_0^2 = 0\n$$\nRearranging yields the discrete dispersion relation provided in the problem statement, which models the lattice-induced nonlocality (spatial dispersion):\n$$\n\\sin^2\\left(\\frac{k_x a}{2}\\right) + \\sin^2\\left(\\frac{k_y a}{2}\\right) + \\sin^2\\left(\\frac{k_z a}{2}\\right) = \\left(\\frac{k_0 a}{2}\\right)^2\n$$\nThis relation is anisotropic; it depends on the individual components $k_x$, $k_y$, and $k_z$, reflecting the preferred directions of the underlying cubic lattice.\n\n**Error Quantification and Computational Methodology**\n\nTo facilitate the calculation, we work with dimensionless quantities. Let $\\hat{a} = k_0 a = 2\\pi a/\\lambda$ be the normalized lattice constant, and let $\\kappa = k_\\parallel/k_0$ be the normalized transverse wavevector. The wavenumbers are normalized by $k_0$, so $\\hat{k}_i = k_i/k_0$.\n\nThe normalized continuum propagation constant is:\n$$\n\\hat{k}_z^{\\mathrm{cont}}(\\kappa) = \\frac{k_z^{\\mathrm{cont}}}{k_0} = \\sqrt{1 - \\kappa^2}\n$$\nThe normalized discrete propagation constant $\\hat{k}_z^{\\mathrm{disc}} = k_z^{\\mathrm{disc}}/k_0$ is found by solving the discrete dispersion relation for $k_z$. Let $S(\\kappa) = \\sin^2(k_x a/2) + \\sin^2(k_y a/2)$. The relation is $\\sin^2(k_z a/2) = (k_0 a/2)^2 - S(\\kappa)$. Solving for $k_z$ gives $k_z^{\\mathrm{disc}} = \\frac{2}{a} \\arcsin\\left(\\sqrt{(k_0 a/2)^2 - S(\\kappa)}\\right)$. In normalized form:\n$$\n\\hat{k}_z^{\\mathrm{disc}}(\\kappa) = \\frac{k_z^{\\mathrm{disc}}}{k_0} = \\frac{2}{k_0 a} \\arcsin\\left(\\sqrt{\\left(\\frac{k_0 a}{2}\\right)^2 - S(\\kappa)}\\right) = \\frac{2}{\\hat{a}} \\arcsin\\left(\\sqrt{\\left(\\frac{\\hat{a}}{2}\\right)^2 - S(\\kappa)}\\right)\n$$\nThe term $S(\\kappa)$ depends on the incidence configuration:\n1.  **Axis-oblique**: $k_x = k_\\parallel = \\kappa k_0$, $k_y = 0$.\n    $$S_{\\mathrm{axis}}(\\kappa) = \\sin^2\\left(\\frac{\\kappa k_0 a}{2}\\right) = \\sin^2\\left(\\frac{\\kappa \\hat{a}}{2}\\right)$$\n2.  **Face-diagonal-oblique**: $k_x = k_y = k_\\parallel/\\sqrt{2} = \\kappa k_0/\\sqrt{2}$.\n    $$S_{\\mathrm{diag}}(\\kappa) = 2\\sin^2\\left(\\frac{\\kappa k_0 a}{2\\sqrt{2}}\\right) = 2\\sin^2\\left(\\frac{\\kappa \\hat{a}}{2\\sqrt{2}}\\right)$$\n\nThe relative error $E(\\kappa)$ is thus computed as:\n$$\nE(\\kappa) = \\frac{|\\hat{k}_z^{\\mathrm{disc}}(\\kappa) - \\hat{k}_z^{\\mathrm{cont}}(\\kappa)|}{\\hat{k}_z^{\\mathrm{cont}}(\\kappa)}\n$$\nFor each test case $(\\alpha, \\delta)$, where $\\alpha=a/\\lambda$, we first compute $\\hat{a} = 2\\pi\\alpha$. Then we perform the required calculations.\n\n**Normal Incidence ($\\kappa=0$):**\nFor $\\kappa=0$, we have $k_\\parallel=0$, thus $k_x=k_y=0$. Both configurations are identical.\n$\\hat{k}_z^{\\mathrm{cont}}(0) = 1$. The discrete relation gives $\\hat{k}_z^{\\mathrm{disc}}(0) = \\frac{2}{\\hat{a}} \\arcsin(\\hat{a}/2)$. The error is $E(0) = |\\frac{2}{\\hat{a}} \\arcsin(\\hat{a}/2) - 1|$. The condition `normal_ok` is true if $E(0) \\le \\delta$.\n\n**Oblique Incidence ($\\kappa0$):**\nTo find $\\kappa_{\\max}$, we must find the largest $\\kappa \\in [0, 1)$ for which $E(\\kappa) \\le \\delta$. The error function $E(\\kappa)$ is monotonically increasing from $E(0)$ at $\\kappa=0$ and diverges as $\\kappa \\to 1$ (since $\\hat{k}_z^{\\mathrm{cont}}(\\kappa) \\to 0$). This structure makes the problem amenable to a numerical root-finding algorithm.\nThe algorithm proceeds as follows:\n1.  For a given configuration (axis or diagonal), define the target function $f(\\kappa) = E(\\kappa) - \\delta$.\n2.  If $f(0)  0$ (i.e., $E(0)  \\delta$), the condition is not met even at normal incidence, so $\\kappa_{\\max} = 0$.\n3.  Check the error at a value of $\\kappa$ very close to $1$, say $\\kappa_{high} = 1 - 10^{-9}$. If $f(\\kappa_{high}) \\le 0$, the error remains within the tolerance over the entire range, so $\\kappa_{\\max} = 1$.\n4.  If $f(0) \\le 0$ and $f(\\kappa_{high})  0$, a unique root exists in the interval $(0, \\kappa_{high})$. We employ a robust root-finding method, such as Brent's method (`scipy.optimize.brentq`), to solve $f(\\kappa) = 0$. The resulting root is $\\kappa_{\\max}$.\n\nA robust implementation must handle potential numerical domain errors, ensuring that the arguments of `sqrt` are non-negative and the arguments of `arcsin` are within $[-1, 1]$. For the given problem parameters, the discrete wavevector cutoff occurs at $\\kappa \\ge 1$, so the search domain is limited by the continuum model's cutoff at $\\kappa=1$.\nThis procedure is repeated for both the axis-oblique and face-diagonal-oblique configurations to find $\\kappa_{\\max}^{\\mathrm{axis}}$ and $\\kappa_{\\max}^{\\mathrm{diag}}$. The final results are then formatted as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the metamaterial homogenization error problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (0.1, 0.05),\n        (0.1, 0.0),\n        (0.2, 0.05),\n        (0.05, 0.05),\n    ]\n\n    results = []\n    for a_lambda, delta in test_cases:\n        result = compute_metrics(a_lambda, delta)\n        results.append(result)\n\n    # Format output according to the problem specification.\n    # e.g., [[0.123456, 0.234567, True], [0.0, 0.0, False]]\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]:.6f},{res[1]:.6f},{str(res[2]).lower()}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_metrics(a_lambda, delta):\n    \"\"\"\n    Computes kappa_max_axis, kappa_max_diag, and normal_ok for a given (a/lambda, delta) pair.\n    \"\"\"\n    # Dimensionless lattice parameter\n    a_hat = 2.0 * np.pi * a_lambda\n\n    # --- Normal Incidence Check (kappa = 0) ---\n    k_z_cont_norm_0 = 1.0\n    \n    # Check if a_hat/2 is in arcsin domain\n    if a_hat / 2.0 >= 1.0:\n        # This occurs when a/lambda >= 1/pi, outside the problem's typical range.\n        # In this case, the discrete mode is evanescent even at normal incidence.\n        error_0 = np.inf\n    else:\n        k_z_disc_norm_0 = (2.0 / a_hat) * np.arcsin(a_hat / 2.0)\n        error_0 = np.abs(k_z_disc_norm_0 - k_z_cont_norm_0)\n    \n    normal_ok = error_0 = delta\n\n    # --- Find kappa_max for Both Configurations ---\n    k_max_values = []\n    for config in ['axis', 'diag']:\n        def root_function(kappa):\n            \"\"\"\n            This function calculates E(kappa) - delta. The root of this function is kappa_max.\n            It is designed to be used with a root-finding algorithm like brentq.\n            \"\"\"\n            # Handle kappa range. k_z_cont is complex or zero for kappa >= 1.\n            # The denominator of the relative error would be zero.\n            if kappa >= 1.0:\n                return np.inf\n\n            k_z_cont_norm = np.sqrt(1.0 - kappa**2)\n\n            if config == 'axis':\n                s_term = np.sin(kappa * a_hat / 2.0)**2\n            else:  # 'diag'\n                s_term = 2.0 * np.sin(kappa * a_hat / (2.0 * np.sqrt(2.0)))**2\n            \n            # Argument for the square root in the discrete calculation\n            arg_sqrt = (a_hat / 2.0)**2 - s_term\n            \n            # Check for discrete cutoff (evanescent wave)\n            if arg_sqrt  0:\n                return np.inf\n            \n            # Argument for arcsin\n            arg_asin = np.sqrt(arg_sqrt)\n            if arg_asin > 1.0:\n                 return np.inf\n\n            k_z_disc_norm = (2.0 / a_hat) * np.arcsin(arg_asin)\n            \n            # Relative error E(kappa)\n            rel_error = np.abs(k_z_disc_norm - k_z_cont_norm) / k_z_cont_norm\n            \n            return rel_error - delta\n\n        # --- Determine kappa_max using the root function ---\n        if error_0 > delta:\n            # If error at normal incidence already exceeds tolerance, kappa_max is 0.\n            k_max = 0.0\n        else:\n            # Search for kappa_max in [0, 1). Test the upper boundary first.\n            # Use a point very close to 1 to avoid division by zero.\n            kappa_high_test = 1.0 - 1e-12\n            if root_function(kappa_high_test) = 0:\n                # If error is within tolerance for all kappa up to 1, kappa_max is 1.0.\n                k_max = 1.0\n            else:\n                # Use Brent's method to find the root of root_function(kappa) = 0.\n                # This gives the kappa where the error equals the tolerance.\n                try:\n                    k_max = brentq(root_function, 0, kappa_high_test)\n                except ValueError:\n                    # Fallback in case brentq fails (e.g., no sign change).\n                    # Given the function's behavior, this should not occur if\n                    # root_function(0)  0 and root_function(kappa_high_test) > 0.\n                    k_max = 0.0\n        \n        k_max_values.append(k_max)\n\n    return [k_max_values[0], k_max_values[1], normal_ok]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3314227"}]}