{"hands_on_practices": [{"introduction": "Our first practice confronts the fundamental challenge of representing a curved object on a rectilinear grid. We will compare the simple but flawed staircasing method against a more robust contour-weighted subcell approach [@problem_id:3354906]. By quantifying the error in a simple resistance calculation for a rotated loop, you will directly observe the numerical anisotropy inherent in naive discretizations and understand why sophisticated subcell models are essential for achieving accuracy and rotational invariance in simulations.", "problem": "Consider a two-dimensional embedding of a thin conductive loop on a uniform Yee grid intended for Finite-Difference Time-Domain (FDTD) use. You will compare two discretizations of a curved wire (a circular loop) when computing the input impedance at a feed gap in the low-frequency, quasi-static limit, where the input impedance is dominated by conduction. The goal is to quantify the discretization error introduced by staircasing relative to a contour-weighted subcell embedding that uses Morton ordering to accumulate contributions. The derivation must begin from first principles of electromagnetics and circuit theory and must not assume any discretization-specific formulas as given facts.\n\nFundamental base for derivation:\n- Maxwell–Ampère law with conduction for macroscopic media: $\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\dfrac{\\partial \\mathbf{D}}{\\partial t}$ with $\\mathbf{J} = \\sigma \\mathbf{E}$ and $\\mathbf{D} = \\varepsilon \\mathbf{E}$.\n- Ohm’s law for a uniform thin wire carrying current along its tangent direction: $\\mathrm{d}V = \\dfrac{\\rho}{A} \\mathrm{d}\\ell$, where $\\rho$ is resistivity, $A$ is cross-sectional area, and $\\ell$ is the arclength coordinate along the wire.\n- Definition of input impedance at a feed gap driven by current $I$: $Z_{\\text{in}} = V/I$, where $V$ is the voltage across the gap.\n\nProblem setup:\n- Work in the quasi-static limit where the displacement current is negligible relative to conduction along the thin wire. This implies that the input impedance is dominated by the total wire resistance along the loop and is approximately independent of the orientation of the loop in space. Under these conditions, the total voltage drop along the loop approximates $V \\approx \\dfrac{\\rho}{A} \\int_{\\mathcal{C}} \\mathrm{d}\\ell$, where $\\mathcal{C}$ is the closed loop curve excluding the small feed gap, and hence $Z_{\\text{in}} \\approx \\dfrac{\\rho L}{A}$ with $L$ the loop circumference.\n- Use a square domain of side length $L_{\\text{box}}$ discretized into a uniform Yee grid with spacing $\\Delta$. Place a circular thin-wire loop of radius $R$ centered at the domain center. The loop is rotated by an angle $\\theta$ about its center. The feed gap is assumed infinitesimal for the sake of the resistance calculation, so that $L$ is the total circumference $2\\pi R$.\n- Two discrete representations of the loop on the Yee grid are to be compared:\n  1. Staircased wire: The loop is approximated by an axis-aligned 4-connected polyline on the grid that results from rounding sample points on the continuous loop to the nearest grid nodes and connecting successive nodes by Manhattan steps. The approximate length is denoted $L_{\\text{stair}}(\\theta)$.\n  2. Contour-weighted subcell embedding with Morton ordering: The loop is represented by sampling points along the continuous curve and accumulating arclength contributions within each grid cell intersected by the loop. Use the Z-order (Morton) code of each cell to order the accumulation of contributions before summation. The approximate length is denoted $L_{\\text{embed}}(\\theta)$. In the limit of fine sampling, $L_{\\text{embed}}(\\theta)$ approaches the true circumference $L_{\\text{true}}=2\\pi R$, regardless of $\\theta$.\n- The Morton ordering (Z-order curve) is defined by interleaving the bits of the integer grid indices $(i,j)$ into a single key to sort grid cells in a cache-coherent space-filling order. In this problem, you must use Morton ordering to accumulate contour contributions when computing $L_{\\text{embed}}(\\theta)$.\n\nDerivation tasks:\n1. Starting from $\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\dfrac{\\partial \\mathbf{D}}{\\partial t}$ and $\\mathbf{J} = \\sigma \\mathbf{E}$, argue why, in the quasi-static conduction-dominated limit for a thin wire loop, the input impedance is dominated by the wire resistance and reduces to $Z_{\\text{in}} \\approx \\dfrac{\\rho L}{A}$, with $L$ the effective loop length realized by the discretization. State the assumptions needed for this reduction and justify why angle dependence of the true $Z_{\\text{in}}$ disappears in this limit.\n2. Define the staircased discretization that replaces the curved loop with a 4-connected axis-aligned polyline on the grid. Show that this discretization results in an approximate length $L_{\\text{stair}}(\\theta) = N_{\\text{edges}}(\\theta) \\Delta$ and explain why $N_{\\text{edges}}(\\theta)$ depends on $\\theta$.\n3. Define the contour-weighted subcell embedding: sample the curve at a resolution $\\delta s$ along arclength, bin each sample’s contribution $\\delta s$ into the corresponding grid cell $(i,j)$, order the binned contributions by the Morton code of $(i,j)$, and then sum to obtain $L_{\\text{embed}}(\\theta)$. Explain why, for sufficiently small $\\delta s$, $L_{\\text{embed}}(\\theta) \\to L_{\\text{true}}$ independent of $\\theta$.\n4. For each discretization, define $Z_{\\text{stair}}(\\theta) = \\dfrac{\\rho L_{\\text{stair}}(\\theta)}{A}$ and $Z_{\\text{embed}}(\\theta) = \\dfrac{\\rho L_{\\text{embed}}(\\theta)}{A}$. Define the relative error against the true low-frequency input impedance $Z_{\\text{true}} = \\dfrac{\\rho L_{\\text{true}}}{A}$ as $e_{\\text{stair}}(\\theta) = \\left|\\dfrac{Z_{\\text{stair}}(\\theta) - Z_{\\text{true}}}{Z_{\\text{true}}}\\right|$ and $e_{\\text{embed}}(\\theta) = \\left|\\dfrac{Z_{\\text{embed}}(\\theta) - Z_{\\text{true}}}{Z_{\\text{true}}}\\right|$. Show that these errors reduce to $e_{\\text{stair}}(\\theta) = \\left|\\dfrac{L_{\\text{stair}}(\\theta) - L_{\\text{true}}}{L_{\\text{true}}}\\right|$ and $e_{\\text{embed}}(\\theta) = \\left|\\dfrac{L_{\\text{embed}}(\\theta) - L_{\\text{true}}}{L_{\\text{true}}}\\right|$.\n\nNumerical parameters and units:\n- Use $L_{\\text{box}} = 0.128$ m, uniform grid spacing $\\Delta = 1.0 \\times 10^{-3}$ m, so the grid has $128 \\times 128$ cells. The loop center is at the box center.\n- Use loop radius $R = 0.020$ m.\n- Use copper-like resistivity $\\rho = 1.70 \\times 10^{-8}$ $\\Omega \\cdot$m and a round wire with effective radius $a = 2.5 \\times 10^{-4}$ m, so cross-section $A = \\pi a^{2}$ in $\\text{m}^{2}$. Report input impedances in $\\Omega$ when they are needed for intermediate verification. The final required outputs are dimensionless relative errors.\n- For the contour-weighted embedding, sample the loop with a uniform arclength step corresponding to $N_{\\text{samp}} = 40000$ points over the full circle; for the staircased discretization, use $N_{\\text{poly}} = 720$ sample points to construct and connect rounded grid nodes along Manhattan paths.\n- Implement Morton ordering for two-dimensional integer indices $(i,j)$ using standard bit interleaving into a 64-bit integer.\n\nTest suite and output specification:\n- Angles in degrees (use radians internally): $\\theta \\in \\{ 0.0, 22.5, 37.0, 73.0 \\}$.\n- For each $\\theta$ above, compute the pair of relative errors $[e_{\\text{stair}}(\\theta), e_{\\text{embed}}(\\theta)]$ as decimals.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a two-element list in the same order as the angles are given. For example, a valid format is \"[[x11,x12],[x21,x22],[x31,x32],[x41,x42]]\" where $x_{k1}$ is $e_{\\text{stair}}(\\theta_{k})$ and $x_{k2}$ is $e_{\\text{embed}}(\\theta_{k})$.\n- Express the final answers as decimals with no units (dimensionless), corresponding to the relative errors defined above.\n\nScientific realism and restrictions:\n- The derivation must explicitly justify why the low-frequency input impedance reduces to a purely resistive form in $\\Omega$ and why only the length approximation affects the relative error.\n- You must include the use of Morton ordering in the contour-weighted accumulation algorithm and explain its role, even though it does not change the scalar sum.\n- Angles are specified in degrees; use radians for internal computation. Ensure that all distances are in meters and all resistive quantities in $\\Omega$ during any intermediate steps if used for validation. The final output must be the dimensionless relative errors as defined above.", "solution": "The problem is valid as it is scientifically grounded in Maxwell's equations and computational electromagnetics, is well-posed with all necessary parameters provided, and presents a clear, objective task. The derivation and numerical comparison of staircased versus subcell modeling for a thin wire is a standard and meaningful exercise in this field.\n\n### 1. Derivation of Quasi-Static Input Impedance\n\nThe analysis begins with the macroscopic Maxwell-Ampère law in a conductive medium:\n$$\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\frac{\\partial \\mathbf{D}}{\\partial t}\n$$\nHere, $\\mathbf{H}$ is the magnetic field intensity, $\\mathbf{J}$ is the conduction current density, and $\\mathbf{D}$ is the electric displacement field. In a linear, isotropic, and homogeneous medium, the constitutive relations are $\\mathbf{J} = \\sigma \\mathbf{E}$ and $\\mathbf{D} = \\varepsilon \\mathbf{E}$, where $\\sigma$ is the electrical conductivity and $\\varepsilon$ is the permittivity. $\\mathbf{E}$ is the electric field. The resistivity $\\rho$ is the inverse of conductivity, $\\rho = 1/\\sigma$.\n\nThe problem specifies the quasi-static, conduction-dominated limit. This implies several assumptions:\n1.  **Low Frequency**: The fields vary slowly in time. For a sinusoidal time dependence $e^{j\\omega t}$, the time derivative term is $\\frac{\\partial \\mathbf{D}}{\\partial t} = j\\omega \\varepsilon \\mathbf{E}$. The Maxwell-Ampère law becomes $\\nabla \\times \\mathbf{H} = (\\sigma + j\\omega\\varepsilon)\\mathbf{E}$.\n2.  **Conduction Dominance**: For a good conductor like copper, $\\sigma$ is large. At low frequencies (i.e., $\\omega \\to 0$), the conduction current term $\\sigma \\mathbf{E}$ is much larger than the displacement current term $j\\omega\\varepsilon \\mathbf{E}$. That is, $\\sigma \\gg \\omega\\varepsilon$. Under this condition, the displacement current is negligible, and the equation simplifies to:\n    $$\n    \\nabla \\times \\mathbf{H} \\approx \\mathbf{J} = \\sigma \\mathbf{E}\n    $$\n3.  **Thin Wire Approximation**: The wire's radius $a$ is much smaller than its length and any relevant electromagnetic wavelength. We assume the current $I$ is uniform across the wire's cross-section $A$ and flows purely along the wire's tangential direction $\\hat{\\mathbf{\\ell}}$. The current density magnitude is thus $J = I/A$.\n\nThe electric field within the conductor is related to the current density by Ohm's law: $\\mathbf{E} = \\rho \\mathbf{J}$. The voltage drop $\\mathrm{d}V$ across a differential segment of wire of length $\\mathrm{d}\\ell$ is given by the work done by the electric field:\n$$\n\\mathrm{d}V = \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{\\ell} = (\\rho J) \\mathrm{d}\\ell = \\rho \\frac{I}{A} \\mathrm{d}\\ell\n$$\nTo find the total voltage $V$ required to drive the current $I$ around the loop, we integrate this voltage drop along the entire length $L$ of the wire. We assume the feed gap is infinitesimal, so the integration path $\\mathcal{C}$ covers the full circumference of the loop.\n$$\nV = \\int_{\\mathcal{C}} \\mathrm{d}V = \\int_{\\mathcal{C}} \\rho \\frac{I}{A} \\mathrm{d}\\ell\n$$\nAssuming the wire is uniform, its resistivity $\\rho$ and cross-sectional area $A$ are constant. The current $I$ is also constant around the closed loop by conservation of charge in the quasi-static limit. Thus, we can take these terms outside the integral:\n$$\nV = \\frac{\\rho I}{A} \\int_{\\mathcal{C}} \\mathrm{d}\\ell = \\frac{\\rho I L}{A}\n$$\nwhere $L = \\int_{\\mathcal{C}} \\mathrm{d}\\ell$ is the total length of the wire loop.\n\nThe input impedance $Z_{\\text{in}}$ at the feed gap is defined as the ratio of the voltage $V$ across the gap to the current $I$ flowing into it:\n$$\nZ_{\\text{in}} = \\frac{V}{I} = \\frac{\\rho L}{A}\n$$\nThis impedance is purely real, representing the total DC resistance of the wire. Any reactive components (inductance and capacitance) are neglected under the quasi-static, conduction-dominated assumption. The true geometric inductance of the loop and the capacitance of the gap would depend on the loop's size and shape, but in this limit, their impedance contributions ($j\\omega L_{ind}$ and $1/(j\\omega C_{gap})$) are considered negligible compared to the resistance $R_{wire} = \\rho L/A$. Since the true length $L_{\\text{true}} = 2\\pi R$, resistivity $\\rho$, and area $A$ are all independent of the loop's rotation angle $\\theta$, the true low-frequency input impedance $Z_{\\text{true}}$ is also independent of $\\theta$.\n\n### 2. Staircased Wire Discretization\n\nThe staircased approximation represents the continuous circular loop with a path constrained to the edges of the grid. The procedure is as follows:\n1.  Sample a set of $N_{\\text{poly}}$ points on the continuous, rotated circular path. A point on the circle of radius $R$ centered at $(x_c, y_c)$ and rotated by $\\theta$ is given by $(x_c + R\\cos(\\phi - \\theta), y_c + R\\sin(\\phi - \\theta))$, where $\\phi$ is the parametric angle.\n2.  For each sample point $(x_k, y_k)$, find the nearest grid node $(i_k, j_k)$. Assuming grid nodes are located at integer multiples of the grid spacing $\\Delta$, i.e., $(i\\Delta, j\\Delta)$, the nearest node is found by rounding: $(i_k, j_k) = (\\text{round}(x_k/\\Delta), \\text{round}(y_k/\\Delta))$.\n3.  Connect these successive nodes $(i_k, j_k)$ and $(i_{k+1}, j_{k+1})$ (with node $N_{\\text{poly}}$ connected back to node $0$) using Manhattan paths, i.e., paths composed only of horizontal and vertical segments. The length of the path between two nodes is the Manhattan distance: $\\Delta \\cdot (|i_{k+1}-i_k| + |j_{k+1}-j_k|)$.\n4.  The total length $L_{\\text{stair}}(\\theta)$ is the sum of these Manhattan distances over the entire sequence of nodes:\n    $$\n    L_{\\text{stair}}(\\theta) = \\Delta \\left( \\sum_{k=0}^{N_{\\text{poly}}-2} \\left[ |i_{k+1}-i_k| + |j_{k+1}-j_k| \\right] + \\left[ |i_0-i_{N_{\\text{poly}}-1}| + |j_0-j_{N_{\\text{poly}}-1}| \\right] \\right)\n    $$\nThis sum can be expressed as $L_{\\text{stair}}(\\theta) = N_{\\text{edges}}(\\theta) \\Delta$, where $N_{\\text{edges}}(\\theta)$ is the total number of grid edges (of length $\\Delta$) in the resulting closed polyline.\n\nThe dependence of $L_{\\text{stair}}(\\theta)$ on the rotation angle $\\theta$ is a well-known artifact of staircasing. As the continuous curve rotates relative to the fixed grid axes, the set of nearest grid nodes $(i_k, j_k)$ changes. This changes the sequence of horizontal and vertical steps needed to approximate the curve. For instance, a straight line segment at $0^\\circ$ to the x-axis is approximated perfectly, while a segment at $45^\\circ$ is approximated by a \"staircase\" of horizontal and vertical steps, resulting in a length approximation of $(\\cos(45^\\circ) + \\sin(45^\\circ)) L_{\\text{true}} = \\sqrt{2} L_{\\text{true}}$, a significant overestimation. For a circle, the total approximated length $L_{\\text{stair}}(\\theta)$ varies as the distribution of tangential slopes along the curve changes with respect to the grid axes upon rotation. The error is typically largest for $\\theta = n \\cdot 45^\\circ$ and smallest for $\\theta = n \\cdot 90^\\circ$ due to grid symmetries.\n\n### 3. Contour-Weighted Subcell Embedding\n\nThe contour-weighted subcell method provides a more accurate representation of the curve's length.\n1.  Sample the continuous curve at a very high resolution, using $N_{\\text{samp}}$ points, where $N_{\\text{samp}} \\gg N_{\\text{poly}}$. This creates tiny arclength segments, each of length $\\delta s = L_{\\text{true}} / N_{\\text{samp}}$.\n2.  For each sample point $p_k$ located at $(x_k, y_k)$, determine the grid cell $(i_k, j_k) = (\\text{floor}(x_k/\\Delta), \\text{floor}(y_k/\\Delta))$ that contains it.\n3.  Accumulate the arclength contribution $\\delta s$ in a map or array corresponding to the host cell $(i_k, j_k)$.\n4.  The problem mandates ordering the contributions using the Morton (Z-order) code before summing. The Morton code of a 2D integer coordinate pair $(i,j)$ is an integer formed by interleaving the bits of $i$ and $j$. This creates a mapping from 2D space to 1D that preserves spatial locality. To perform the summation, one would first populate a dictionary mapping cell indices `(i,j)` to their total accumulated length. Then, one would create a list of tuples, `(morton_code(i,j), accumulated_length)`, sort this list by the Morton code, and finally sum the length values.\n5.  The total length is $L_{\\text{embed}}(\\theta) = \\sum \\delta s$, where the sum is over all $N_{\\text{samp}}$ sample points.\n\nThe role of Morton ordering in this specific calculation is purely procedural. Summation is a commutative operation, so the order in which contributions are added does not alter the final result. However, in more complex algorithms like FDTD or particle-in-cell simulations, iterating through grid data in a Morton-sorted order significantly improves cache performance by ensuring that memory accesses are spatially local. This leads to substantial speedups in computation. Here, its inclusion serves to demonstrate the algorithmic step, even if it has no impact on the scalar sum.\n\nFor a sufficiently large number of samples $N_{\\text{samp}}$, the arclength step $\\delta s$ becomes infinitesimally small. The sum becomes an integral:\n$$\nL_{\\text{embed}}(\\theta) = \\sum_{k=1}^{N_{\\text{samp}}} \\delta s \\xrightarrow{N_{\\text{samp}} \\to \\infty} \\int_{\\mathcal{C}} \\mathrm{d}\\ell = L_{\\text{true}}\n$$\nThis process simply re-sums the total arclength of the original curve. Since the true arclength of the circle, $L_{\\text{true}} = 2\\pi R$, is independent of its orientation $\\theta$, the computed length $L_{\\text{embed}}(\\theta)$ will also be independent of $\\theta$ and will converge to $L_{\\text{true}}$ as $N_{\\text{samp}}$ increases.\n\n### 4. Relative Error Formulation\n\nThe input impedances for the two discretizations are given by:\n$$\nZ_{\\text{stair}}(\\theta) = \\frac{\\rho \\, L_{\\text{stair}}(\\theta)}{A} \\quad \\text{and} \\quad Z_{\\text{embed}}(\\theta) = \\frac{\\rho \\, L_{\\text{embed}}(\\theta)}{A}\n$$\nThe true impedance is $Z_{\\text{true}} = \\frac{\\rho \\, L_{\\text{true}}}{A}$.\n\nThe relative error for the staircased model is defined as:\n$$\ne_{\\text{stair}}(\\theta) = \\left|\\frac{Z_{\\text{stair}}(\\theta) - Z_{\\text{true}}}{Z_{\\text{true}}}\\right|\n$$\nSubstituting the expressions for impedance:\n$$\ne_{\\text{stair}}(\\theta) = \\left|\\frac{\\frac{\\rho \\, L_{\\text{stair}}(\\theta)}{A} - \\frac{\\rho \\, L_{\\text{true}}}{A}}{\\frac{\\rho \\, L_{\\text{true}}}{A}}\\right| = \\left|\\frac{\\frac{\\rho}{A} \\left( L_{\\text{stair}}(\\theta) - L_{\\text{true}} \\right)}{\\frac{\\rho}{A} L_{\\text{true}}}\\right|\n$$\nThe constant pre-factor $\\rho/A$ cancels out, leaving:\n$$\ne_{\\text{stair}}(\\theta) = \\left|\\frac{L_{\\text{stair}}(\\theta) - L_{\\text{true}}}{L_{\\text{true}}}\\right|\n$$\nSimilarly, for the contour-weighted subcell embedding model, the relative error is:\n$$\ne_{\\text{embed}}(\\theta) = \\left|\\frac{Z_{\\text{embed}}(\\theta) - Z_{\\text{true}}}{Z_{\\text{true}}}\\right| = \\left|\\frac{\\frac{\\rho \\, L_{\\text{embed}}(\\theta)}{A} - \\frac{\\rho \\, L_{\\text{true}}}{A}}{\\frac{\\rho \\, L_{\\text{true}}}{A}}\\right| = \\left|\\frac{L_{\\text{embed}}(\\theta) - L_{\\text{true}}}{L_{\\text{true}}}\\right|\n$$\nThus, in the quasi-static, conduction-dominated limit, the relative error in the input impedance is identical to the relative error in the discretized approximation of the wire's length. The material properties ($\\rho$) and wire thickness ($A$) do not affect the dimensionless relative error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve():\n    \"\"\"\n    Computes and compares the discretization error for a circular wire loop\n    using staircased and contour-weighted subcell models.\n    \"\"\"\n\n    # --- Numerical Parameters ---\n    L_box = 0.128  # m, side length of the square domain\n    delta = 1.0e-3  # m, uniform grid spacing\n    R = 0.020  # m, loop radius\n    # rho = 1.70e-8  # Ohm*m, not needed for relative error\n    # a = 2.5e-4  # m, wire radius, not needed for relative error\n    N_samp = 40000  # Number of samples for contour embedding\n    N_poly = 720  # Number of samples for staircasing\n\n    # --- Test Suite ---\n    thetas_deg = [0.0, 22.5, 37.0, 73.0]\n\n    # --- Derived Constants ---\n    L_true = 2 * np.pi * R\n    center_x = L_box / 2.0\n    center_y = L_box / 2.0\n    thetas_rad = np.deg2rad(thetas_deg)\n\n    # --- Helper Function for Morton Ordering ---\n    def morton_encode(i, j):\n        \"\"\"\n        Computes the 64-bit Morton code for 2D integer indices (i, j)\n        by interleaving their bits. Assumes indices fit in 32 bits.\n        \"\"\"\n        z = 0\n        i = int(i)\n        j = int(j)\n        for k in range(32):\n            z |= (i  (1  k))  k | (j  (1  k))  (k + 1)\n        return z\n\n    results = []\n    # --- Main Loop over Angles ---\n    for theta_rad in thetas_rad:\n\n        # --- 1. Staircased Discretization ---\n        phi_poly = np.linspace(0, 2 * np.pi, N_poly, endpoint=False)\n        x_poly = center_x + R * np.cos(phi_poly - theta_rad)\n        y_poly = center_y + R * np.sin(phi_poly - theta_rad)\n\n        # Round sample points to nearest grid nodes\n        i_nodes = np.round(x_poly / delta).astype(int)\n        j_nodes = np.round(y_poly / delta).astype(int)\n        \n        nodes = np.vstack((i_nodes, j_nodes)).T\n\n        # Calculate total Manhattan distance between successive nodes to close the loop\n        shifted_nodes = np.roll(nodes, -1, axis=0)\n        manhattan_distances = np.sum(np.abs(nodes - shifted_nodes), axis=1)\n        total_manhattan_dist = np.sum(manhattan_distances)\n        \n        L_stair = total_manhattan_dist * delta\n        e_stair = np.abs(L_stair - L_true) / L_true\n\n        # --- 2. Contour-Weighted Subcell Embedding ---\n        ds = L_true / N_samp\n        phi_samp = np.linspace(0, 2 * np.pi, N_samp, endpoint=False)\n        \n        x_samp = center_x + R * np.cos(phi_samp - theta_rad)\n        y_samp = center_y + R * np.sin(phi_samp - theta_rad)\n\n        # Bin contributions into cells\n        i_cells = np.floor(x_samp / delta)\n        j_cells = np.floor(y_samp / delta)\n\n        contributions = {}\n        for i, j in zip(i_cells, j_cells):\n            key = (i, j)\n            contributions[key] = contributions.get(key, 0.0) + ds\n\n        # Order contributions by Morton code (as per problem spec)\n        # Note: Sorting does not change the final sum but is a required step.\n        morton_ordered_contribs = []\n        for (i, j), length_val in contributions.items():\n            key = morton_encode(i, j)\n            morton_ordered_contribs.append((key, length_val))\n        \n        morton_ordered_contribs.sort(key=lambda item: item[0])\n        \n        # Sum the contributions\n        L_embed = sum(item[1] for item in morton_ordered_contribs)\n        e_embed = np.abs(L_embed - L_true) / L_true\n\n        results.append([e_stair, e_embed])\n    \n    # --- Format and Print Final Output ---\n    # The output format must be exactly \"[[x11,x12],[x21,x22],...]\"\n    pair_strs = [f\"[{p[0]},{p[1]}]\" for p in results]\n    final_str = f\"[{','.join(pair_strs)}]\"\n    print(final_str)\n\nsolve()\n```", "id": "3354906"}, {"introduction": "Having established the need for subcell modeling, we now turn to its formulation. This exercise guides you through the foundational derivation of how an arbitrarily oriented or curved wire segment is represented within a single Yee cell [@problem_id:3354986]. By applying volume-averaging principles to the wire's physics, you will derive an effective conductivity tensor that correctly modifies the FDTD update equations, forming the mathematical basis for a versatile and accurate thin-wire model.", "problem": "Consider a three-dimensional Finite-Difference Time-Domain (FDTD) Yee grid with spatial steps $\\Delta x$, $\\Delta y$, and $\\Delta z$. A thin metallic wire of radius $a$ and bulk conductivity $\\sigma_{\\mathrm{w}}$ passes through the local update volume associated with each electric-field edge component. The wire is geometrically subcell-sized ($a \\ll \\min\\{\\Delta x,\\Delta y,\\Delta z\\}$) and is represented by a differentiable space curve $\\mathbf{r}(u)$ with parameter $u$ and arc-length coordinate $s$, with unit tangent $\\hat{\\mathbf{t}}(s)$. The local update volume associated with the $i$-th electric field component ($i \\in \\{x,y,z\\}$) is modeled as having longitudinal dimension $\\Delta i$ and transverse cross-sectional area $A_{\\perp,i}$, where $A_{\\perp,x} = \\Delta y \\Delta z$, $A_{\\perp,y} = \\Delta x \\Delta z$, and $A_{\\perp,z} = \\Delta x \\Delta y$.\n\nStarting strictly from Maxwell–Ampère’s law and the linear conduction constitutive relation within the wire, define the volume-averaged current density component $J_i$ induced by the wire inside the $i$-edge update volume, in terms of the local electric field component $E_i$, the wire’s unit tangent $\\hat{\\mathbf{t}}(s)$, and the wire’s geometric overlap with that update volume. Use the integral form appropriate to averaging over the $i$-edge update volume, and formalize the anisotropic effect of an oblique or curved wire through the projection of $\\hat{\\mathbf{t}}(s)$ onto the coordinate axes.\n\nFrom that base, derive and implement a computable expression for the effective shunt conductivity along the $i$-th electric field edge, denoted $\\sigma_{\\mathrm{eff},i}$, defined as the proportionality constant relating the volume-averaged $J_i$ to $E_i$ for the portion of the wire inside the $i$-edge update volume. Your expression must be obtained by integrating along the portion of the wire curve that lies within the update volume, and it must correctly incorporate the directional projection $\\hat{\\mathbf{t}}(s)$ and the wire’s differential arc length $\\mathrm{d}s$.\n\nYour program must numerically evaluate $\\sigma_{\\mathrm{eff},x}$, $\\sigma_{\\mathrm{eff},y}$, and $\\sigma_{\\mathrm{eff},z}$ for each case below, and return, for each case, the scalar sum $\\sigma_{\\mathrm{eff},x}+\\sigma_{\\mathrm{eff},y}+\\sigma_{\\mathrm{eff},z}$ expressed in $\\mathrm{S/m}$ as a floating-point number. Angle variables must be interpreted in radians. All physical quantities in the input specification are given in SI units, and the final outputs must be in $\\mathrm{S/m}$.\n\nGrid and wire parameters common to all cases:\n- $\\Delta x = \\Delta y = \\Delta z = 1\\times 10^{-3}\\,\\mathrm{m}$,\n- $a = 25\\times 10^{-6}\\,\\mathrm{m}$,\n- $\\sigma_{\\mathrm{w}} = 5.8\\times 10^{7}\\,\\mathrm{S/m}$.\n\nTest Suite (three distinct wire geometries confined to a single $i$-edge update volume; in each case, the wire segment lies entirely within the update volume so that the overlap length equals the wire segment length):\n\n1. Oblique straight segment in the $x$–$y$ plane:\n   - Parameterization by arc length $s$: $\\mathbf{r}(s) = \\mathbf{r}_0 + \\hat{\\mathbf{t}}\\, s$ with $s \\in [0,\\ell]$,\n   - Unit tangent $\\hat{\\mathbf{t}} = \\left(\\dfrac{1}{\\sqrt{5}}, \\dfrac{2}{\\sqrt{5}}, 0\\right)$,\n   - Length $\\ell = 0.8\\times 10^{-3}\\,\\mathrm{m}$.\n\n2. Quarter-circle arc in the $x$–$y$ plane:\n   - Parameterization by angle $\\theta$: $\\mathbf{r}(\\theta) = \\left(R\\cos\\theta, R\\sin\\theta, 0\\right)$ with $\\theta \\in [0,\\pi/2]$,\n   - Radius $R = 0.5\\times 10^{-3}\\,\\mathrm{m}$,\n   - Use $\\dfrac{\\mathrm{d}s}{\\mathrm{d}\\theta} = R$ and $\\hat{\\mathbf{t}}(\\theta) = \\dfrac{\\mathrm{d}\\mathbf{r}/\\mathrm{d}\\theta}{\\|\\mathrm{d}\\mathbf{r}/\\mathrm{d}\\theta\\|}$.\n\n3. Nearly $x$-aligned short straight segment with slight tilt toward $z$:\n   - Parameterization by arc length $s$: $\\mathbf{r}(s) = \\mathbf{r}_0 + \\hat{\\mathbf{t}}\\, s$ with $s \\in [0,\\ell]$,\n   - Raw direction vector $\\mathbf{v} = (1, 0, 0.01)$ and $\\hat{\\mathbf{t}} = \\dfrac{\\mathbf{v}}{\\|\\mathbf{v}\\|}$,\n   - Length $\\ell = 1\\times 10^{-5}\\,\\mathrm{m}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$), where each entry is the sum $\\sigma_{\\mathrm{eff},x}+\\sigma_{\\mathrm{eff},y}+\\sigma_{\\mathrm{eff},z}$ for the corresponding test case. The outputs must be numerical floating-point values in $\\mathrm{S/m}$.", "solution": "The problem is valid as it is scientifically grounded in computational electromagnetics, well-posed, and all necessary parameters for a unique solution are provided.\n\nThe objective is to derive an expression for the effective conductivity $\\sigma_{\\mathrm{eff},i}$ contributed by a subcell thin wire to the $i$-th electric field component in a Finite-Difference Time-Domain (FDTD) grid cell. This is achieved by volume-averaging the wire's current contribution over the FDTD cell volume associated with the electric field component $E_i$.\n\nThe fundamental principles are Ohm's law for a conductor, $\\mathbf{J} = \\sigma \\mathbf{E}$, and the definition of a volume-averaged quantity. The problem defines the effective conductivity $\\sigma_{\\mathrm{eff},i}$ as the proportionality constant linking the volume-averaged current density component $J_i$ to the corresponding local electric field component $E_i$, such that $J_i = \\sigma_{\\mathrm{eff},i} E_i$.\n\nLet the FDTD grid cell associated with the $i$-th electric field component ($i \\in \\{x,y,z\\}$) have volume $V_i = \\Delta x \\Delta y \\Delta z$. The volume-averaged current density component $J_i$ is defined as the integral of the $i$-th component of the wire's current density, $\\mathbf{J}_{\\mathrm{w}}$, over the cell volume, divided by the cell volume itself:\n$$\nJ_i = \\frac{1}{V_i} \\int_{V_i} \\mathbf{J}_{\\mathrm{w}}(\\mathbf{r}) \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V\n$$\nwhere $\\hat{\\mathbf{i}}$ is the unit vector along the $i$-th coordinate axis (e.g., $\\hat{\\mathbf{x}}$ for $i=x$).\n\nThe current density $\\mathbf{J}_{\\mathrm{w}}$ exists only within the volume of the wire. Inside the wire, it is given by the constitutive relation $\\mathbf{J}_{\\mathrm{w}} = \\sigma_{\\mathrm{w}} \\mathbf{E}_{\\mathrm{w}}$, where $\\sigma_{\\mathrm{w}}$ is the wire's bulk conductivity and $\\mathbf{E}_{\\mathrm{w}}$ is the electric field inside the wire. For a thin wire, this field is predominantly parallel to the wire's axis, which is defined by the unit tangent vector $\\hat{\\mathbf{t}}(s)$. The magnitude of the field inside the wire is the projection of the ambient grid electric field, $\\mathbf{E}_{\\mathrm{grid}}$, onto the tangent vector: $\\mathbf{E}_{\\mathrm{w}} \\approx (\\mathbf{E}_{\\mathrm{grid}} \\cdot \\hat{\\mathbf{t}}(s))\\hat{\\mathbf{t}}(s)$.\n\nAs the problem seeks a direct relationship between $J_i$ and $E_i$, we make the standard modeling approximation that the ambient field driving the current within the $i$-th update volume is dominated by the component $E_i$. Therefore, we approximate $\\mathbf{E}_{\\mathrm{grid}} \\approx E_i \\hat{\\mathbf{i}}$. Substituting this into the expression for $\\mathbf{E}_{\\mathrm{w}}$ gives:\n$$\n\\mathbf{E}_{\\mathrm{w}} \\approx ((E_i \\hat{\\mathbf{i}}) \\cdot \\hat{\\mathbf{t}}(s))\\hat{\\mathbf{t}}(s) = E_i (\\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}) \\hat{\\mathbf{t}}(s)\n$$\nLet $t_i(s) = \\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}$ be the component of the unit tangent vector along the $i$-axis. The current density vector inside the wire is then:\n$$\n\\mathbf{J}_{\\mathrm{w}}(s) = \\sigma_{\\mathrm{w}} E_i t_i(s) \\hat{\\mathbf{t}}(s)\n$$\nThe component of this current density along the $i$-axis is:\n$$\n\\mathbf{J}_{\\mathrm{w}}(s) \\cdot \\hat{\\mathbf{i}} = \\sigma_{\\mathrm{w}} E_i t_i(s) (\\hat{\\mathbf{t}}(s) \\cdot \\hat{\\mathbf{i}}) = \\sigma_{\\mathrm{w}} E_i t_i^2(s)\n$$\nNow we can evaluate the volume integral for $J_i$. Since $\\mathbf{J}_{\\mathrm{w}}$ is zero outside the wire, the integral is restricted to the wire's volume within the cell, $V_{\\mathrm{w}, \\text{cell}}$. This volume can be described by integrating the wire's cross-sectional area, $A_{\\mathrm{w}} = \\pi a^2$, along its arc length $s$:\n$$\n\\int_{V_i} \\mathbf{J}_{\\mathrm{w}} \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V = \\int_{V_{\\mathrm{w}, \\text{cell}}} \\sigma_{\\mathrm{w}} E_i t_i^2(s) \\, \\mathrm{d}V = \\int_{\\text{segment}} \\left( \\int_{A_{\\mathrm{w}}} \\sigma_{\\mathrm{w}} E_i t_i^2(s) \\, \\mathrm{d}A \\right) \\mathrm{d}s\n$$\nSince $\\sigma_{\\mathrm{w}}$, $E_i$, and $t_i(s)$ are assumed constant over the wire's subcell cross-section, the inner integral simply yields a factor of the cross-sectional area $A_{\\mathrm{w}} = \\pi a^2$. Assuming $E_i$ is constant throughout its update volume (a cornerstone of the FDTD method), we can factor it out of the outer integral as well:\n$$\n\\int_{V_i} \\mathbf{J}_{\\mathrm{w}} \\cdot \\hat{\\mathbf{i}} \\, \\mathrm{d}V = \\sigma_{\\mathrm{w}} E_i (\\pi a^2) \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s\n$$\nwhere the integral is over the arc length of the wire segment within the cell. Substituting this back into the expression for $J_i$:\n$$\nJ_i = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_i} \\left( \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s \\right) E_i\n$$\nBy comparing this with the definition $J_i = \\sigma_{\\mathrm{eff},i} E_i$, we identify the effective conductivity for the $i$-th component:\n$$\n\\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{\\Delta x \\Delta y \\Delta z} \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s\n$$\nThe problem asks for the sum $\\sigma_{\\mathrm{eff},x} + \\sigma_{\\mathrm{eff},y} + \\sigma_{\\mathrm{eff},z}$. This sum has a notable simplification:\n$$\n\\sum_{i=x,y,z} \\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\sum_{i=x,y,z} \\int_{\\text{segment}} t_i^2(s) \\, \\mathrm{d}s = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\int_{\\text{segment}} (t_x^2 + t_y^2 + t_z^2) \\, \\mathrm{d}s\n$$\nSince $\\hat{\\mathbf{t}}(s)$ is a unit vector, the sum of the squares of its components is $t_x^2(s) + t_y^2(s) + t_z^2(s) = \\|\\hat{\\mathbf{t}}(s)\\|^2 = 1$. The expression simplifies to:\n$$\n\\sum_{i=x,y,z} \\sigma_{\\mathrm{eff},i} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} \\int_{\\text{segment}} 1 \\, \\mathrm{d}s = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} L\n$$\nwhere $L$ is the total arc length of the wire segment within the cell.\n\nThe common parameters are:\n$\\Delta x = \\Delta y = \\Delta z = 1 \\times 10^{-3}\\,\\mathrm{m} \\implies V_{\\mathrm{cell}} = 10^{-9}\\,\\mathrm{m}^3$\n$a = 25 \\times 10^{-6}\\,\\mathrm{m}$\n$\\sigma_{\\mathrm{w}} = 5.8 \\times 10^7\\,\\mathrm{S/m}$\nThe pre-factor is $C_{\\Sigma} = \\frac{\\pi a^2 \\sigma_{\\mathrm{w}}}{V_{\\mathrm{cell}}} = \\frac{\\pi (25 \\times 10^{-6})^2 (5.8 \\times 10^7)}{10^{-9}} \\approx 113882733.9\\,\\mathrm{S/m^2}$.\n\nCase 1: Oblique straight segment\nThe wire is straight, so its length is $L = \\ell = 0.8 \\times 10^{-3}\\,\\mathrm{m}$.\nSum = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (0.8 \\times 10^{-3}) \\approx 91106.187\\,\\mathrm{S/m}$.\n\nCase 2: Quarter-circle arc\nThe arc length is $L = R \\theta$ for $\\theta \\in [0, \\pi/2]$.\n$L = R (\\pi/2 - 0) = (0.5 \\times 10^{-3}) \\cdot (\\pi/2) = \\frac{\\pi}{4} \\times 10^{-3}\\,\\mathrm{m} \\approx 0.7854 \\times 10^{-3}\\,\\mathrm{m}$.\nSum = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (\\frac{\\pi}{4} \\times 10^{-3}) \\approx 89445.542\\,\\mathrm{S/m}$.\n\nCase 3: Nearly $x$-aligned short straight segment\nThe wire is straight, so its length is $L = \\ell = 1 \\times 10^{-5}\\,\\mathrm{m}$.\nThe unit tangent vector is $\\hat{\\mathbf{t}} = \\frac{(1, 0, 0.01)}{\\sqrt{1^2+0.01^2}}$, but $\\|\\hat{\\mathbf{t}}\\|^2=1$ regardless of its direction.\nSum = $C_{\\Sigma} \\cdot L = 113882733.9 \\times (1 \\times 10^{-5}) \\approx 1138.827\\,\\mathrm{S/m}$.\n\nThe following program implements the component-wise calculation of $\\sigma_{\\mathrm{eff},i}$ and sums the results, as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and calculates the effective conductivity of a subcell thin wire\n    in an FDTD grid for three different wire geometries.\n    \"\"\"\n    # Define common grid and wire parameters from the problem statement\n    dx = 1e-3  # Grid spacing in x (m)\n    dy = 1e-3  # Grid spacing in y (m)\n    dz = 1e-3  # Grid spacing in z (m)\n    a = 25e-6  # Wire radius (m)\n    sigma_w = 5.8e7  # Wire bulk conductivity (S/m)\n\n    # Calculate common constants for the effective conductivity formula\n    V_cell = dx * dy * dz\n    A_w = np.pi * a**2  # Wire cross-sectional area\n    \n    # C_factor = (sigma_w * A_w) / V_cell\n    # sigma_eff_i = C_factor * integral(t_i^2 ds)\n    C_factor = (sigma_w * A_w) / V_cell\n\n    test_cases = [\n        # Case 1: Oblique straight segment in the x-y plane\n        {\n            \"type\": \"straight\",\n            \"t_hat\": np.array([1/np.sqrt(5), 2/np.sqrt(5), 0]),\n            \"length\": 0.8e-3\n        },\n        # Case 2: Quarter-circle arc in the x-y plane\n        {\n            \"type\": \"arc\",\n            \"R\": 0.5e-3,\n            \"theta_range\": (0, np.pi/2)\n        },\n        # Case 3: Nearly x-aligned short straight segment\n        {\n            \"type\": \"straight_from_v\",\n            \"v\": np.array([1.0, 0.0, 0.01]),\n            \"length\": 1e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_eff_components = np.zeros(3)  # To store [sigma_eff_x, sigma_eff_y, sigma_eff_z]\n\n        if case[\"type\"] in (\"straight\", \"straight_from_v\"):\n            length = case[\"length\"]\n            if case[\"type\"] == \"straight\":\n                t_hat = case[\"t_hat\"]\n            else: # straight_from_v\n                v = case[\"v\"]\n                t_hat = v / np.linalg.norm(v)\n\n            # For a straight wire, the tangent vector is constant.\n            # The integral of t_i^2 ds becomes t_i^2 * length.\n            integrals = (t_hat**2) * length\n            sigma_eff_components = C_factor * integrals\n\n        elif case[\"type\"] == \"arc\":\n            R = case[\"R\"]\n            theta_min, theta_max = case[\"theta_range\"]\n            \n            # For this specific arc, the tangent vector is t(theta) = [-sin(theta), cos(theta), 0].\n            # The differential arc length ds = R * d(theta).\n            # We need to compute integral_{theta_min}^{theta_max} t_i(theta)^2 * R d(theta).\n            \n            # Integral of t_x^2 ds = R * integral(sin(theta)^2 d(theta))\n            # Antiderivative of sin(theta)^2 is theta/2 - sin(2*theta)/4\n            def int_sin_sq(th): return th / 2.0 - np.sin(2.0 * th) / 4.0\n            integral_tx2_ds = R * (int_sin_sq(theta_max) - int_sin_sq(theta_min))\n            \n            # Integral of t_y^2 ds = R * integral(cos(theta)^2 d(theta))\n            # Antiderivative of cos(theta)^2 is theta/2 + sin(2*theta)/4\n            def int_cos_sq(th): return th / 2.0 + np.sin(2.0 * th) / 4.0\n            integral_ty2_ds = R * (int_cos_sq(theta_max) - int_cos_sq(theta_min))\n\n            # Integral of t_z^2 ds is 0 since t_z = 0.\n            integral_tz2_ds = 0.0\n            \n            sigma_eff_components[0] = C_factor * integral_tx2_ds\n            sigma_eff_components[1] = C_factor * integral_ty2_ds\n            sigma_eff_components[2] = C_factor * integral_tz2_ds\n\n        # The result for the case is the sum of the components\n        total_sigma_eff = np.sum(sigma_eff_components)\n        results.append(total_sigma_eff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354986"}, {"introduction": "A subcell model must be accurate not only in isolation but also in its interaction with the larger simulation environment, particularly absorbing boundary conditions. This advanced practice addresses the critical interface between a thin wire and a Perfectly Matched Layer (PML) [@problem_id:3354927]. By modeling the wire and PML interface as a transmission line discontinuity, you will analyze the resulting impedance mismatch and derive the spurious reflection coefficient, gaining crucial insight into ensuring the stability and accuracy of simulations involving terminated wire structures.", "problem": "Consider a two-dimensional Transverse Magnetic to $z$ (TM$_z$) Finite-Difference Time-Domain (FDTD) configuration in which free space occupies the half-space $x  0$ and a semi-infinite, uniform Perfectly Matched Layer (PML) occupies the half-space $x  0$. The free space region is characterized by vacuum permittivity $\\varepsilon_0$ and vacuum permeability $\\mu_0$. The PML is modeled via complex coordinate stretching with electric stretching parameter $s_e$ and magnetic stretching parameter $s_m$ that are independent of position and frequency within the PML slab. A thin, $z$-directed wire crosses the planar interface at $x = 0$, and its subcell model modifies the local Ampère update in the interface FDTD cell by introducing a lumped shunt admittance $Y_w$ (in siemens) attached across the local $E_z$ degree of freedom.\n\nStarting from Maxwell’s equations in differential form, the vacuum constitutive relations, and the complex-coordinate stretching representation of the PML, derive an expression for the complex plane-wave input impedance $Z_{\\text{pml}}$ of the semi-infinite PML in terms of $\\mu_0$, $\\varepsilon_0$, $s_e$, and $s_m$. Then, model the interaction of the thin-wire subcell admittance $Y_w$ at the interface cell as a shunt admittance in parallel with the PML input admittance seen by an incident TM$_z$ plane wave at normal incidence. Using these principles alone, derive the complex normal-incidence reflection coefficient at $x=0$ for a plane wave originating in free space and impinging on the PML interface modified by the thin-wire subcell, expressed entirely in terms of fundamental constants $\\mu_0$, $\\varepsilon_0$, and the parameters $s_e$, $s_m$, and $Y_w$. You must explicitly state any continuity conditions and equivalences you use to connect the field formulation to the impedance concept.\n\nYour program must implement the derived formula to compute the magnitude of the complex reflection coefficient for each of the following test cases. In each case, compute $s_e$ and $s_m$ from the given real-valued stretching design parameters $\\kappa_e$, $\\sigma_e$ (with units of siemens per meter), $\\kappa_m$, and $\\sigma_m$ (with units of siemens per meter), at a specified frequency $f$ (in hertz), using\n$$\ns_e = \\kappa_e + \\frac{\\sigma_e}{j\\,\\omega\\,\\varepsilon_0},\\qquad\ns_m = \\kappa_m + \\frac{\\sigma_m}{j\\,\\omega\\,\\mu_0},\n$$\nwhere $\\omega = 2\\pi f$. All quantities must be handled in the International System of Units (SI). Report the final reflection coefficient magnitudes as dimensionless decimals. The free-space plane-wave impedance is $Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}$.\n\nTest Suite (each tuple is $(f, \\kappa_e, \\sigma_e, \\kappa_m, \\sigma_m, Y_w)$ with all values in SI units):\n- Case A: ($1.0 \\times 10^9$, 1, 0, 1, 0, 0).\n- Case B: ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, $5.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^{-3}$).\n- Case C: ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, 0, $1.0 \\times 10^{-2}$).\n- Case D: ($2.0 \\times 10^9$, 1, $2.0 \\times 10^4$, 1, $2.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^{-6}$).\n- Case E: ($1.0 \\times 10^9$, 1, $5.0 \\times 10^4$, 1, $5.0 \\times 10^4 \\cdot \\mu_0 / \\varepsilon_0$, $1.0 \\times 10^6$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$), where each entry is the reflection magnitude corresponding to the cases above, in the same order. No other output is permitted. Express the reflection magnitudes as decimals (unitless).", "solution": "The problem requires the derivation of the normal-incidence reflection coefficient at the interface between free space and a semi-infinite Perfectly Matched Layer (PML), where the interface is modified by a thin-wire subcell model. The derivation will begin from Maxwell's equations and employ the complex-coordinate stretching representation of the PML.\n\n**Step 1: PML Wave Impedance Derivation**\n\nWe begin with Maxwell's curl equations in the frequency domain (phasor form, assuming $e^{j\\omega t}$ time dependence):\n$$\n\\nabla \\times \\mathbf{E} = -j\\omega \\mathbf{B}\n$$\n$$\n\\nabla \\times \\mathbf{H} = j\\omega \\mathbf{D}\n$$\nA PML designed to absorb waves propagating in the $x$-direction can be modeled as a uniaxial anisotropic medium. The complex coordinate stretching with electric stretching parameter $s_e$ and magnetic stretching parameter $s_m$ (both uniform and complex-valued for $x  0$) is equivalent to using the following constitutive relations in the PML region:\n$$\n\\mathbf{D} = \\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E} \\quad \\text{with} \\quad \\bar{\\bar{\\varepsilon}} = \\varepsilon_0 \\begin{pmatrix} 1/s_e  0  0 \\\\ 0  s_e  0 \\\\ 0  0  s_e \\end{pmatrix}\n$$\n$$\n\\mathbf{B} = \\bar{\\bar{\\mu}} \\cdot \\mathbf{H} \\quad \\text{with} \\quad \\bar{\\bar{\\mu}} = \\mu_0 \\begin{pmatrix} 1/s_m  0  0 \\\\ 0  s_m  0 \\\\ 0  0  s_m \\end{pmatrix}\n$$\nWe consider a Transverse Magnetic to $z$ (TM$_z$) plane wave propagating at normal incidence along the $x$-axis into the PML. The field components are $\\mathbf{E} = E_z(x)\\hat{z}$ and $\\mathbf{H} = H_y(x)\\hat{y}$.\n\nSubstituting these fields into Maxwell's curl equations:\nFrom $\\nabla \\times \\mathbf{E} = -j\\omega\\mathbf{B}$:\n$$\n\\begin{vmatrix} \\hat{x}  \\hat{y}  \\hat{z} \\\\ \\frac{\\partial}{\\partial x}  \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial z} \\\\ 0  0  E_z(x) \\end{vmatrix} = \\frac{\\partial E_z}{\\partial x} \\hat{y} = -j\\omega (\\bar{\\bar{\\mu}} \\cdot \\mathbf{H})\n$$\nThe $y$-component of $\\bar{\\bar{\\mu}} \\cdot \\mathbf{H}$ is $\\mu_{yy} H_y = \\mu_0 s_m H_y$. Thus,\n$$\n\\frac{dE_z}{dx} = -j\\omega\\mu_0 s_m H_y \\quad (1)\n$$\nFrom $\\nabla \\times \\mathbf{H} = j\\omega\\mathbf{D}$:\n$$\n\\begin{vmatrix} \\hat{x}  \\hat{y}  \\hat{z} \\\\ \\frac{\\partial}{\\partial x}  \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial z} \\\\ 0  H_y(x)  0 \\end{vmatrix} = -\\frac{\\partial H_y}{\\partial x} \\hat{z} = j\\omega (\\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E})\n$$\nThe $z$-component of $\\bar{\\bar{\\varepsilon}} \\cdot \\mathbf{E}$ is $\\varepsilon_{zz} E_z = \\varepsilon_0 s_e E_z$. Thus,\n$$\n-\\frac{dH_y}{dx} = j\\omega\\varepsilon_0 s_e E_z \\quad \\implies \\quad \\frac{dH_y}{dx} = -j\\omega\\varepsilon_0 s_e E_z \\quad (2)\n$$\nTo find the wave impedance, we assume a solution of the form $E_z(x) = E_0 e^{-\\gamma_x x}$ and $H_y(x) = H_0 e^{-\\gamma_x x}$, where $\\gamma_x$ is the propagation constant in the PML. Substituting into equations $(1)$ and $(2)$:\n$$\n-\\gamma_x E_z = -j\\omega\\mu_0 s_m H_y \\quad (3)\n$$\n$$\n-\\gamma_x H_y = -j\\omega\\varepsilon_0 s_e E_z \\quad (4)\n$$\nThe transverse wave impedance of the PML medium, $Z_{\\text{pml}}$, is defined as the ratio of the transverse electric and magnetic fields, $Z_{\\text{pml}} = E_z / H_y$. From equation $(3)$:\n$$\nZ_{\\text{pml}} = \\frac{E_z}{H_y} = \\frac{j\\omega\\mu_0 s_m}{\\gamma_x}\n$$\nTo find $\\gamma_x$, we multiply equation $(3)$ by $(4)$:\n$$\n(-\\gamma_x E_z)(-\\gamma_x H_y) = (-j\\omega\\mu_0 s_m H_y)(-j\\omega\\varepsilon_0 s_e E_z)\n$$\n$$\n\\gamma_x^2 (E_z H_y) = (j\\omega)^2 \\mu_0 \\varepsilon_0 s_e s_m (E_z H_y)\n$$\n$$\n\\gamma_x^2 = -\\omega^2 \\mu_0 \\varepsilon_0 s_e s_m \\quad \\implies \\quad \\gamma_x = j\\omega\\sqrt{\\mu_0 \\varepsilon_0 s_e s_m}\n$$\nWe choose the root for $\\gamma_x$ that has a positive real part to ensure attenuation in the $+x$ direction. Substituting $\\gamma_x$ into the expression for $Z_{\\text{pml}}$:\n$$\nZ_{\\text{pml}} = \\frac{j\\omega\\mu_0 s_m}{j\\omega\\sqrt{\\mu_0 \\varepsilon_0 s_e s_m}} = \\frac{\\mu_0 s_m}{\\sqrt{\\mu_0\\varepsilon_0 s_e s_m}} = \\sqrt{\\frac{\\mu_0^2 s_m^2}{\\mu_0\\varepsilon_0 s_e s_m}} = \\sqrt{\\frac{\\mu_0 s_m}{\\varepsilon_0 s_e}}\n$$\nRecognizing the free-space impedance $Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}$, the PML wave impedance is:\n$$\nZ_{\\text{pml}} = Z_0 \\sqrt{\\frac{s_m}{s_e}}\n$$\nSince the PML is semi-infinite, its input impedance is equal to its characteristic wave impedance.\n\n**Step 2: Reflection Coefficient Calculation**\n\nThe problem of plane wave reflection at the interface can be modeled using an equivalent transmission line circuit. This equivalence is justified by the continuity of tangential fields ($E_z$ and $H_y$) at the interface $x=0$. The free-space region ($x0$) is a transmission line with characteristic impedance $Z_0$. The region $x0$ represents the load.\n\nThe load at $x=0$ consists of two components in parallel:\n1. The input impedance of the semi-infinite PML, $Z_{\\text{pml}}$.\n2. The impedance of the thin-wire subcell, which is given as a shunt admittance $Y_w$.\n\nIt is most convenient to work with admittances for parallel components.\nThe characteristic admittance of free space is $Y_0 = 1/Z_0 = \\sqrt{\\varepsilon_0/\\mu_0}$.\nThe input admittance of the PML is $Y_{\\text{pml}} = 1/Z_{\\text{pml}} = \\frac{1}{Z_0\\sqrt{s_m/s_e}} = Y_0 \\sqrt{\\frac{s_e}{s_m}}$.\nThe total load admittance, $Y_L$, is the sum of the parallel admittances:\n$$\nY_L = Y_{\\text{pml}} + Y_w = Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\n$$\nThe voltage reflection coefficient $\\Gamma$ at the load is given by the standard transmission line formula, expressed in terms of admittances:\n$$\n\\Gamma = \\frac{Y_0 - Y_L}{Y_0 + Y_L}\n$$\nSubstituting the expression for $Y_L$:\n$$\n\\Gamma = \\frac{Y_0 - \\left(Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\\right)}{Y_0 + \\left(Y_0 \\sqrt{\\frac{s_e}{s_m}} + Y_w\\right)}\n$$\nFactoring out $Y_0$ and rearranging yields the final expression for the complex reflection coefficient:\n$$\n\\Gamma = \\frac{Y_0 \\left(1 - \\sqrt{\\frac{s_e}{s_m}}\\right) - Y_w}{Y_0 \\left(1 + \\sqrt{\\frac{s_e}{s_m}}\\right) + Y_w}\n$$\nThis expression depends only on the fundamental constants via $Y_0 = \\sqrt{\\varepsilon_0/\\mu_0}$, and the specified parameters $s_e$, $s_m$, and $Y_w$, as required. For implementation, the complex parameters $s_e$ and $s_m$ are calculated from the provided real-valued design parameters using the given formulas:\n$$\ns_e = \\kappa_e + \\frac{\\sigma_e}{j\\,\\omega\\,\\varepsilon_0}\n$$\n$$\ns_m = \\kappa_m + \\frac{\\sigma_m}{j\\,\\omega\\,\\mu_0}\n$$\nwhere $\\omega = 2\\pi f$. The program will compute $|\\Gamma|$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n# scipy.constants is not used to adhere strictly to the rules.\n\ndef solve():\n    \"\"\"\n    Computes the magnitude of the complex reflection coefficient for a plane wave\n    impinging on a PML-wire interface from free space.\n    \"\"\"\n\n    # Define fundamental physical constants in SI units.\n    # From CODATA 2018. c is exact by definition of the meter. mu_0 is exact by\n    # definition of the Ampere. epsilon_0 is derived.\n    c0 = 299792458.0  # Speed of light in vacuum (m/s)\n    mu_0 = 4.0 * np.pi * 1.0e-7  # Vacuum permeability (H/m)\n    epsilon_0 = 1.0 / (mu_0 * c0**2)  # Vacuum permittivity (F/m)\n\n    # Characteristic admittance of free space\n    Y_0 = np.sqrt(epsilon_0 / mu_0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (f, kappa_e, sigma_e, kappa_m, sigma_m, Y_w)\n    # with all values in SI units.\n    test_cases = [\n        # Case A (matched, no wire)\n        (1.0e9, 1.0, 0.0, 1.0, 0.0, 0.0),\n        # Case B (matched, moderate loss, weak wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 5.0e4 * mu_0 / epsilon_0, 1.0e-3),\n        # Case C (mismatched stretch, stronger wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 0.0, 1.0e-2),\n        # Case D (matched, higher frequency, very weak wire)\n        (2.0e9, 1.0, 2.0e4, 1.0, 2.0e4 * mu_0 / epsilon_0, 1.0e-6),\n        # Case E (matched, extremely strong wire)\n        (1.0e9, 1.0, 5.0e4, 1.0, 5.0e4 * mu_0 / epsilon_0, 1.0e6),\n    ]\n\n    results = []\n    for case in test_cases:\n        f, kappa_e, sigma_e, kappa_m, sigma_m, Y_w = case\n\n        # Angular frequency\n        omega = 2.0 * np.pi * f\n\n        # Complex value j\n        j = 1j\n\n        # Calculate complex stretching parameters s_e and s_m\n        s_e = kappa_e + sigma_e / (j * omega * epsilon_0)\n        s_m = kappa_m + sigma_m / (j * omega * mu_0)\n        \n        # Derived formula for the reflection coefficient Gamma\n        # Gamma = (Y_0 * (1 - sqrt(s_e/s_m)) - Y_w) / (Y_0 * (1 + sqrt(s_e/s_m)) + Y_w)\n        \n        # Handle the case where s_m is zero to avoid division by zero, though\n        # not expected with the given test cases.\n        if s_m == 0:\n            # If s_m is 0, the ratio is infinite, so sqrt(s_e/s_m) is infinite.\n            # Gamma would approach -1.\n            gamma = -1.0\n        else:\n            sqrt_ratio = np.sqrt(s_e / s_m)\n            numerator = Y_0 * (1.0 - sqrt_ratio) - Y_w\n            denominator = Y_0 * (1.0 + sqrt_ratio) + Y_w\n            \n            # Handle the case where the denominator might be zero.\n            if denominator == 0:\n                # This would imply infinite reflection, which is unphysical.\n                # Per problem, we expect a stable solution so this should not occur.\n                # However, for robustness, one might handle it.\n                # For now, we assume it does not happen with valid inputs.\n                gamma = np.inf\n            else:\n                gamma = numerator / denominator\n\n        # The problem asks for the magnitude of the reflection coefficient.\n        reflection_magnitude = np.abs(gamma)\n        results.append(reflection_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354927"}]}