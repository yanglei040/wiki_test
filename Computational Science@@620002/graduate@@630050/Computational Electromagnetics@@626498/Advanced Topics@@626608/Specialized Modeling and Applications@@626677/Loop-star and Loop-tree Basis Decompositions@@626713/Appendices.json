{"hands_on_practices": [{"introduction": "The foundation of many surface integral equation methods rests upon basis functions like the Rao-Wilton-Glisson (RWG) set. This exercise provides a concrete, hands-on calculation of the inner products between two neighboring RWG functions, which form the entries of a Gram matrix. By working through the details, you will not only practice the fundamental definitions but also gain intuition about how a change of basis to a loop-star representation systematically introduces a block-diagonal structure, a key step in improving the numerical stability of integral equation solvers [@problem_id:3325462].", "problem": "Consider a small planar mesh patch $S \\subset \\mathbb{R}^{3}$ lying in the plane $z=0$, formed by three triangles that share edges as follows. Let the vertices be $v_{1}=(0,0,0)$, $v_{2}=(1,0,0)$, $v_{3}=(0,1,0)$, $v_{4}=(1,1,0)$, and $v_{5}=(1,-1,0)$. Define triangles $T_{1}=\\triangle(v_{1},v_{2},v_{3})$, $T_{2}=\\triangle(v_{2},v_{3},v_{4})$, and $T_{3}=\\triangle(v_{1},v_{2},v_{5})$, and let $S=T_{1}\\cup T_{2}\\cup T_{3}$. Consider two Rao–Wilton–Glisson (RWG) basis functions, $\\mathbf{f}_{1}$ and $\\mathbf{f}_{2}$, associated with interior edges $e_{1}=\\overline{v_{2}v_{3}}$ and $e_{2}=\\overline{v_{1}v_{2}}$, respectively. The RWG function $\\mathbf{f}_{e}$ supported on the pair $(T^{+},T^{-})$ is defined piecewise by\n$$\n\\mathbf{f}_{e}(\\mathbf{r})=\n\\begin{cases}\n\\dfrac{l_{e}}{2A^{+}}\\left(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{+}\\right),  \\mathbf{r}\\in T^{+} \\\\[6pt]\n-\\dfrac{l_{e}}{2A^{-}}\\left(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{-}\\right),  \\mathbf{r}\\in T^{-} \\\\[6pt]\n\\mathbf{0},  \\text{otherwise}\n\\end{cases}\n$$\nwhere $l_{e}$ is the length of the interior edge, $A^{\\pm}$ are the areas of $T^{\\pm}$, and $\\mathbf{r}_{\\text{op}}^{\\pm}$ are the vertices opposite the common edge in $T^{\\pm}$. For $\\mathbf{f}_{1}$, take $T^{+}=T_{1}$ with opposite vertex $\\mathbf{r}_{\\text{op}}^{+}=v_{1}$ and $T^{-}=T_{2}$ with opposite vertex $\\mathbf{r}_{\\text{op}}^{-}=v_{4}$. For $\\mathbf{f}_{2}$, take $T^{+}=T_{1}$ with opposite vertex $\\mathbf{r}_{\\text{op}}^{+}=v_{3}$ and $T^{-}=T_{3}$ with opposite vertex $\\mathbf{r}_{\\text{op}}^{-}=v_{5}$.\n\nStarting from the geometric definitions above and the $L^{2}$ inner product on $S$, derive the Gram matrix entries\n$$\nG_{ij}=\\int_{S}\\mathbf{f}_{i}(\\mathbf{r})\\cdot \\mathbf{f}_{j}(\\mathbf{r})\\, dS,\\quad i,j\\in\\{1,2\\},\n$$\nby explicitly evaluating the necessary area integrals over triangles $T_{1}$, $T_{2}$, and $T_{3}$. Then, using first principles of how RWG basis functions are supported and constructed, explain the sparsity pattern and symmetry of the resulting $2\\times 2$ Gram matrix in this RWG basis. Briefly comment on how a loop–star decomposition (expressing RWGs as linear combinations of divergence-free “loop” and irrotational “star” functions) would affect symmetry and sparsity qualitatively for such inner-product matrices, without performing any additional numerical computation.\n\nReport the three quantities $G_{11}$, $G_{22}$, and $G_{12}$ in that order. Express the final values in square meters and give exact forms; no rounding is required.", "solution": "To derive the Gram matrix entries $G_{ij}=\\int_{S}\\mathbf{f}_{i}(\\mathbf{r})\\cdot \\mathbf{f}_{j}(\\mathbf{r})\\, dS$, we must first define the basis functions $\\mathbf{f}_{1}$ and $\\mathbf{f}_{2}$ explicitly based on the provided geometric setup.\n\n**1. Geometric and Basis Function Parameters**\n\nThe vertices are given as $v_{1}=(0,0,0)$, $v_{2}=(1,0,0)$, $v_{3}=(0,1,0)$, $v_{4}=(1,1,0)$, and $v_{5}=(1,-1,0)$. The triangles are $T_{1}=\\triangle(v_{1},v_{2},v_{3})$, $T_{2}=\\triangle(v_{2},v_{3},v_{4})$, and $T_{3}=\\triangle(v_{1},v_{2},v_{5})$. All triangles lie in the $z=0$ plane.\n\nThe areas of the triangles are:\n- $A_{1} = \\text{Area}(T_{1}) = \\frac{1}{2}|\\vec{v_{1}v_{2}} \\times \\vec{v_{1}v_{3}}| = \\frac{1}{2}|(1,0,0) \\times (0,1,0)| = \\frac{1}{2}|(0,0,1)| = \\frac{1}{2}$.\n- $A_{2} = \\text{Area}(T_{2}) = \\frac{1}{2}|\\vec{v_{2}v_{3}} \\times \\vec{v_{2}v_{4}}| = \\frac{1}{2}|(-1,1,0) \\times (0,1,0)| = \\frac{1}{2}|(0,0,-1)| = \\frac{1}{2}$.\n- $A_{3} = \\text{Area}(T_{3}) = \\frac{1}{2}|\\vec{v_{1}v_{2}} \\times \\vec{v_{1}v_{5}}| = \\frac{1}{2}|(1,0,0) \\times (1,-1,0)| = \\frac{1}{2}|(0,0,-1)| = \\frac{1}{2}$.\n\nThe RWG basis functions are defined as follows:\n\n**For $\\mathbf{f}_{1}$ associated with edge $e_{1}=\\overline{v_{2}v_{3}}$:**\n- The edge length is $l_{1} = |v_{3}-v_{2}| = |(-1,1,0)| = \\sqrt{2}$.\n- The supporting triangles are $T^{+}=T_{1}$ and $T^{-}=T_{2}$. Their areas are $A^{+}=A_1=\\frac{1}{2}$ and $A^{-}=A_2=\\frac{1}{2}$.\n- The opposite vertices are $\\mathbf{r}_{\\text{op}}^{+}=v_{1}=(0,0,0)$ and $\\mathbf{r}_{\\text{op}}^{-}=v_{4}=(1,1,0)$.\n- The function is defined as:\n  - For $\\mathbf{r}=(x,y,0) \\in T_{1}$: $\\mathbf{f}_{1}(\\mathbf{r}) = \\frac{l_{1}}{2A^{+}}(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{+}) = \\frac{\\sqrt{2}}{2(1/2)}(\\mathbf{r}-v_{1}) = \\sqrt{2}\\mathbf{r} = \\sqrt{2}(x,y,0)$.\n  - For $\\mathbf{r}=(x,y,0) \\in T_{2}$: $\\mathbf{f}_{1}(\\mathbf{r}) = -\\frac{l_{1}}{2A^{-}}(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{-}) = -\\frac{\\sqrt{2}}{2(1/2)}(\\mathbf{r}-v_{4}) = -\\sqrt{2}(\\mathbf{r}-v_{4}) = -\\sqrt{2}(x-1,y-1,0)$.\n\n**For $\\mathbf{f}_{2}$ associated with edge $e_{2}=\\overline{v_{1}v_{2}}$:**\n- The edge length is $l_{2} = |v_{2}-v_{1}| = |(1,0,0)| = 1$.\n- The supporting triangles are $T^{+}=T_{1}$ and $T^{-}=T_{3}$. Their areas are $A^{+}=A_1=\\frac{1}{2}$ and $A^{-}=A_3=\\frac{1}{2}$.\n- The opposite vertices are $\\mathbf{r}_{\\text{op}}^{+}=v_{3}=(0,1,0)$ and $\\mathbf{r}_{\\text{op}}^{-}=v_{5}=(1,-1,0)$.\n- The function is defined as:\n  - For $\\mathbf{r}=(x,y,0) \\in T_{1}$: $\\mathbf{f}_{2}(\\mathbf{r}) = \\frac{l_{2}}{2A^{+}}(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{+}) = \\frac{1}{2(1/2)}(\\mathbf{r}-v_{3}) = \\mathbf{r}-v_{3} = (x,y-1,0)$.\n  - For $\\mathbf{r}=(x,y,0) \\in T_{3}$: $\\mathbf{f}_{2}(\\mathbf{r}) = -\\frac{l_{2}}{2A^{-}}(\\mathbf{r}-\\mathbf{r}_{\\text{op}}^{-}) = -\\frac{1}{2(1/2)}(\\mathbf{r}-v_{5}) = -(\\mathbf{r}-v_{5}) = -(x-1,y+1,0)$.\n\n**2. Calculation of Gram Matrix Entries**\n\nThe support of $\\mathbf{f}_{1}$ is $T_{1} \\cup T_{2}$ and the support of $\\mathbf{f}_{2}$ is $T_{1} \\cup T_{3}$. Their intersection is $T_{1}$.\n\n**Calculation of $G_{11}$:**\n$G_{11} = \\int_{S}|\\mathbf{f}_{1}(\\mathbf{r})|^{2}\\,dS = \\int_{T_{1}}|\\mathbf{f}_{1}|^{2}\\,dS + \\int_{T_{2}}|\\mathbf{f}_{1}|^{2}\\,dS$.\n- Over $T_{1}$: $\\int_{T_{1}}|\\sqrt{2}\\mathbf{r}|^{2}\\,dS = 2\\int_{T_{1}}(x^{2}+y^{2})\\,dx\\,dy$.\n- Over $T_{2}$: $\\int_{T_{2}}|-\\sqrt{2}(\\mathbf{r}-v_{4})|^{2}\\,dS = 2\\int_{T_{2}}((x-1)^{2}+(y-1)^{2})\\,dx\\,dy$.\n\nWe need to evaluate integrals over the triangles. For $T_{1}$, which is the standard simplex triangle with vertices $(0,0),(1,0),(0,1)$, we have the formula $\\int_{T_{1}} x^{p}y^{q}\\,dx\\,dy = \\frac{p!q!}{(p+q+2)!}$.\n- $\\int_{T_{1}}(x^{2}+y^{2})\\,dx\\,dy = \\frac{2!0!}{4!} + \\frac{0!2!}{4!} = \\frac{2}{24} + \\frac{2}{24} = \\frac{1}{6}$.\nFor the integral over $T_{2}$ (vertices $(1,0),(0,1),(1,1)$), we can use a change of variables $u=x-1, v=y-1$. The new triangle $T'_{2}$ has vertices $(0,-1),(-1,0),(0,0)$. The integral becomes $\\int_{T'_{2}}(u^{2}+v^{2})\\,du\\,dv$. By symmetry with the integral over $T_1$, this evaluates to $\\frac{1}{6}$.\nThus, $G_{11} = 2(\\frac{1}{6}) + 2(\\frac{1}{6}) = \\frac{4}{6} = \\frac{2}{3}$.\n\n**Calculation of $G_{22}$:**\n$G_{22} = \\int_{S}|\\mathbf{f}_{2}(\\mathbf{r})|^{2}\\,dS = \\int_{T_{1}}|\\mathbf{f}_{2}|^{2}\\,dS + \\int_{T_{3}}|\\mathbf{f}_{2}|^{2}\\,dS$.\n- Over $T_{1}$: $\\int_{T_{1}}|\\mathbf{r}-v_{3}|^{2}\\,dS = \\int_{T_{1}}(x^{2}+(y-1)^{2})\\,dx\\,dy = \\int_{T_{1}}(x^{2}+y^{2}-2y+1)\\,dx\\,dy$.\nUsing the integral formula: $\\frac{1}{12} + \\frac{1}{12} - 2(\\frac{1}{6}) + \\frac{1}{2} = \\frac{1}{6} - \\frac{1}{3} + \\frac{1}{2} = \\frac{1-2+3}{6} = \\frac{2}{6} = \\frac{1}{3}$.\n- Over $T_{3}$: $\\int_{T_{3}}|-(\\mathbf{r}-v_{5})|^{2}\\,dS = \\int_{T_{3}}((x-1)^{2}+(y+1)^{2})\\,dx\\,dy$. $T_3$ has vertices $(0,0),(1,0),(1,-1)$. Let $u=x-1, v=y+1$. The new vertices are $(-1,1),(0,1),(0,0)$. This is a right triangle similar to $T_1$. $\\int_{T'_{3}}(u^{2}+v^{2})\\,du\\,dv = \\frac{1}{3}$.\nThus, $G_{22} = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3}$.\n\n**Calculation of $G_{12}$:**\nThe integral is non-zero only over the common support region $T_{1}$.\n$G_{12} = \\int_{T_{1}}\\mathbf{f}_{1}(\\mathbf{r})\\cdot\\mathbf{f}_{2}(\\mathbf{r})\\,dS = \\int_{T_{1}}(\\sqrt{2}\\mathbf{r})\\cdot(\\mathbf{r}-v_{3})\\,dS$.\n$G_{12} = \\sqrt{2}\\int_{T_{1}}(|\\mathbf{r}|^{2} - \\mathbf{r}\\cdot v_{3})\\,dS = \\sqrt{2}\\int_{T_{1}}(x^{2}+y^{2}-y)\\,dx\\,dy$.\nUsing our previous results:\n$G_{12} = \\sqrt{2}\\left(\\int_{T_{1}}(x^{2}+y^{2})\\,dx\\,dy - \\int_{T_{1}}y\\,dx\\,dy\\right) = \\sqrt{2}\\left(\\frac{1}{6} - \\frac{1!0!}{3!}\\right) = \\sqrt{2}\\left(\\frac{1}{6} - \\frac{1}{6}\\right) = 0$.\nThe Gram matrix is $G = \\begin{pmatrix} 2/3  0 \\\\ 0  2/3 \\end{pmatrix}$. The units of the entries are length-squared, which is $m^2$ assuming the vertex coordinates are in meters.\n\n**3. Sparsity, Symmetry, and Loop-Star Decomposition**\n\n**Symmetry and Sparsity of the RWG Gram Matrix:**\nThe Gram matrix $G$ is symmetric ($G_{ij} = G_{ji}$) by definition, as the $L^{2}$ inner product is symmetric: $\\int \\mathbf{f}_{i}\\cdot\\mathbf{f}_{j}\\,dS = \\int \\mathbf{f}_{j}\\cdot\\mathbf{f}_{i}\\,dS$. Our calculation confirms this, as $G_{12}=G_{21}=0$. The sparsity of the matrix is determined by the overlap of the supports of the basis functions. An entry $G_{ij}$ is structurally zero if $\\text{supp}(\\mathbf{f}_i) \\cap \\text{supp}(\\mathbf{f}_j) = \\emptyset$. In our case, $\\text{supp}(\\mathbf{f}_{1}) = T_{1}\\cup T_{2}$ and $\\text{supp}(\\mathbf{f}_{2}) = T_{1}\\cup T_{3}$. Since their supports have a non-empty intersection ($T_1$), the entry $G_{12}$ is not guaranteed to be zero. The fact that $G_{12}=0$ is a consequence of the specific geometric configuration of the vertices and triangles in this problem, leading to an \"accidental\" orthogonality.\n\n**Effect of Loop-Star Decomposition:**\nThe set of all RWG basis functions on a mesh forms a vector space. A loop-star decomposition (a form of Helmholtz-Hodge decomposition) splits this space into two orthogonal subspaces:\n1.  **Loop functions ($\\mathcal{L}$):** These are linear combinations of RWG functions that form closed loops on the mesh dual graph. They are divergence-free ($\\nabla \\cdot \\mathbf{l} = 0$) and represent solenoidal (rotational) current modes.\n2.  **Star functions ($\\mathcal{S}$):** These form a basis for the remaining functions. They are typically constructed from a spanning tree of the mesh graph and are curl-free ($\\nabla \\times \\mathbf{s} = \\mathbf{0}$). They represent irrotational (divergent) current modes.\n\nA fundamental property of this decomposition is that the loop and star subspaces are orthogonal with respect to the $L^{2}$ inner product: $\\int_{S} \\mathbf{l} \\cdot \\mathbf{s} \\,dS = 0$ for any $\\mathbf{l} \\in \\mathcal{L}$ and $\\mathbf{s} \\in \\mathcal{S}$.\n\nIf we were to transform the RWG basis $\\{\\mathbf{f}_i\\}$ to a loop-star basis $\\{\\mathbf{l}_k\\} \\cup \\{\\mathbf{s}_m\\}$, the Gram matrix in this new basis, $G'$, would become block-diagonal:\n$$\nG' = \n\\begin{pmatrix}\nG_{\\mathcal{LL}}  \\mathbf{0} \\\\\n\\mathbf{0}  G_{\\mathcal{SS}}\n\\end{pmatrix}\n$$\nwhere $G_{\\mathcal{LL}}$ contains the inner products between loop functions and $G_{\\mathcal{SS}}$ contains inner products between star functions. The off-diagonal blocks $G_{\\mathcal{LS}}$ and $G_{\\mathcal{SL}}$ are identically zero due to the orthogonality.\n\nQualitatively, the loop-star decomposition introduces a guaranteed, structured sparsity pattern into the Gram matrix that is independent of any accidental geometric symmetries. It partitions the matrix into blocks corresponding to physically distinct types of current modes. This decomposition is highly valuable in numerical methods for separating the contributions of electric and magnetic phenomena, improving the conditioning of matrices, and developing stable time-domain algorithms.\n\nThe final values requested are $G_{11}$, $G_{22}$, and $G_{12}$.\n$G_{11} = \\frac{2}{3}$.\n$G_{22} = \\frac{2}{3}$.\n$G_{12} = 0$.\nThe problem specifies units of square meters, which is correct since the RWG functions are dimensionless and the integration domain is an area.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2}{3}  \\frac{2}{3}  0 \\end{pmatrix}}\n$$", "id": "3325462"}, {"introduction": "Building on the concept of orthogonality, we now turn to the core algorithm for separating a current into its constituent parts. The discrete Helmholtz-Hodge decomposition allows any current on a mesh to be uniquely split into a divergence-free (loop) component and a curl-free (star) component, which correspond to the nullspace and range space of the incidence matrix, respectively. This exercise guides you through the implementation of the essential projection operator that performs this separation, providing a fundamental tool for stabilizing low-frequency integral equation solvers [@problem_id:3325511].", "problem": "Consider a triangulated surface mesh whose Reduced Rao–Wilton–Glisson (RWG) basis coefficients can be indexed by oriented edges. Let the mesh be abstracted by a directed graph with $n_v$ vertices and $n_e$ edges, and let the vertex–edge incidence matrix be $B \\in \\mathbb{R}^{n_v \\times n_e}$, where the $i$-th edge is oriented from its tail vertex $t$ to its head vertex $h$, and the incidence entries are $-1$ at the tail, $+1$ at the head, and $0$ otherwise. The RWG coefficient vector is $j \\in \\mathbb{R}^{n_e}$.\n\nDefine the star subspace as the column space of $B^{\\top}$, i.e., $\\mathrm{Range}(B^{\\top}) = \\{ B^{\\top} \\phi : \\phi \\in \\mathbb{R}^{n_v} \\}$, and define the loop subspace as the nullspace of $B$, i.e., $\\mathrm{Null}(B) = \\{ x \\in \\mathbb{R}^{n_e} : B x = 0 \\}$. The discrete Helmholtz decomposition for graphs implies the orthogonal direct sum $\\mathbb{R}^{n_e} = \\mathrm{Range}(B^{\\top}) \\oplus \\mathrm{Null}(B)$ for any undirected graph with a fixed orientation, and the orthogonality $\\mathrm{Range}(B^{\\top}) \\perp \\mathrm{Null}(B)$ under the Euclidean inner product.\n\nStarting from these definitions and the discrete conservation constraint $B j$ representing the net divergence at vertices, derive and implement an algorithm to project an arbitrary RWG coefficient vector $j$ onto its star component $j_{\\star} \\in \\mathrm{Range}(B^{\\top})$ and its loop component $j_{\\mathrm{loop}} \\in \\mathrm{Null}(B)$ using least-squares with incidence matrices. The projection should be obtained by solving the normal equations for the star component\n$$\n(B B^{\\top}) \\, \\phi = B \\, j,\n$$\nin the least-squares sense, and then setting\n$$\nj_{\\star} = B^{\\top} \\phi, \\quad j_{\\mathrm{loop}} = j - j_{\\star}.\n$$\nWhen $B B^{\\top}$ is singular (e.g., for disconnected graphs), use the Moore–Penrose pseudoinverse to compute the minimum-norm solution for $\\phi$.\n\nYou must test the algorithm against synthetic data generated from known star and loop components. For each test, construct $B$ from the given vertex and edge sets, generate a random potential $\\phi \\in \\mathbb{R}^{n_v}$ to define a star component $j_{\\star} = B^{\\top} \\phi$, and generate a random loop component $j_{\\mathrm{loop}}$ from a basis of $\\mathrm{Null}(B)$. Use a fixed pseudorandom seed to make the tests reproducible. Optionally add a small noise vector $n$ to test numerical robustness, setting $j = j_{\\star} + j_{\\mathrm{loop}} + n$.\n\nFor each test, compute the relative reconstruction errors\n$$\n\\varepsilon_{\\star} = \\frac{\\lVert \\widehat{j}_{\\star} - j_{\\star} \\rVert_2}{\\max(\\lVert j_{\\star} \\rVert_2, \\epsilon)}, \\quad\n\\varepsilon_{\\mathrm{loop}} = \\frac{\\lVert \\widehat{j}_{\\mathrm{loop}} - j_{\\mathrm{loop}} \\rVert_2}{\\max(\\lVert j_{\\mathrm{loop}} \\rVert_2, \\epsilon)},\n$$\nwhere $\\epsilon = 10^{-12}$, $\\widehat{j}_{\\star}$ is the least-squares projection onto $\\mathrm{Range}(B^{\\top})$, and $\\widehat{j}_{\\mathrm{loop}} = j - \\widehat{j}_{\\star}$. All norms are Euclidean $2$-norms.\n\nImplement the program according to the following test suite and data generation protocol (the orientation for each edge is tail $\\rightarrow$ head):\n\n- Test $1$ (connected graph with a single cycle): $n_v = 4$, edges $[(0,1),(1,2),(2,3),(3,0)]$, seed $42$, noise standard deviation $0$.\n- Test $2$ (tree graph, no loops): $n_v = 4$, edges $[(0,1),(1,2),(2,3)]$, seed $43$, noise standard deviation $0$.\n- Test $3$ (two disconnected $3$-cycles): $n_v = 6$, edges $[(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$, seed $44$, noise standard deviation $0$.\n- Test $4$ (connected graph with one cycle and an extra leaf, with noise): $n_v = 5$, edges $[(0,1),(1,2),(2,3),(3,0),(1,4)]$, seed $45$, noise standard deviation $10^{-6}$.\n\nFor each test:\n- Build $B$ from the specified $n_v$ and edge list.\n- Compute a basis for $\\mathrm{Null}(B)$ using singular value decomposition with a tolerance of $10^{-12}$ for zero singular values.\n- Draw $\\phi$ as independent standard normal entries using the provided seed.\n- Compute $j_{\\star} = B^{\\top} \\phi$.\n- Draw coefficients for the loop basis as independent standard normal entries using the same seed, and form $j_{\\mathrm{loop}}$ as a linear combination of the nullspace basis vectors (if the nullspace is trivial, set $j_{\\mathrm{loop}} = 0$).\n- Draw independent standard normal noise entries with the given noise standard deviation and the same seed; set $j = j_{\\star} + j_{\\mathrm{loop}} + n$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\varepsilon_{\\mathrm{loop}}^{(1)}, \\varepsilon_{\\star}^{(1)}, \\varepsilon_{\\mathrm{loop}}^{(2)}, \\varepsilon_{\\star}^{(2)}, \\varepsilon_{\\mathrm{loop}}^{(3)}, \\varepsilon_{\\star}^{(3)}, \\varepsilon_{\\mathrm{loop}}^{(4)}, \\varepsilon_{\\star}^{(4)}],\n$$\nwhere the superscript $(k)$ indexes Test $k$. The outputs are real numbers without units. No other text should be printed.", "solution": "The core task is to decompose a given vector $j \\in \\mathbb{R}^{n_e}$, representing coefficients on the edges of a graph, into two orthogonal components: a star component $j_{\\star}$ and a loop component $j_{\\mathrm{loop}}$. These components lie in the star subspace, $\\mathrm{Range}(B^{\\top})$, and the loop subspace, $\\mathrm{Null}(B)$, respectively, where $B \\in \\mathbb{R}^{n_v \\times n_e}$ is the vertex-edge incidence matrix. The decomposition is given by $j = j_{\\star} + j_{\\mathrm{loop}}$.\n\nThe star component $j_{\\star}$ is the orthogonal projection of $j$ onto the subspace $\\mathrm{Range}(B^{\\top})$. By definition, any vector in this subspace can be expressed as $B^{\\top}\\phi$ for some potential vector $\\phi \\in \\mathbb{R}^{n_v}$. The projection is found by solving a least-squares problem that minimizes the distance between $j$ and its approximation in the star subspace:\n$$\n\\min_{\\phi \\in \\mathbb{R}^{n_v}} \\lVert j - B^{\\top}\\phi \\rVert_2^2\n$$\nTo find the minimum, we differentiate the squared norm with respect to $\\phi$ and set the gradient to zero. The objective function is:\n$$\nf(\\phi) = (j - B^{\\top}\\phi)^{\\top}(j - B^{\\top}\\phi) = j^{\\top}j - 2\\phi^{\\top}B j + \\phi^{\\top}B B^{\\top}\\phi\n$$\nThe gradient with respect to $\\phi$ is $\\nabla_{\\phi} f(\\phi) = -2 B j + 2 B B^{\\top}\\phi$. Setting this to zero yields the normal equations:\n$$\n(B B^{\\top}) \\phi = B j\n$$\nThe matrix $L = B B^{\\top}$ is the graph Laplacian. This matrix is singular if the graph is not a single vertex. Its nullspace, $\\mathrm{Null}(L) = \\mathrm{Null}(B^{\\top})$, has a dimension equal to the number of connected components of the graph. However, the system is always consistent because the right-hand side, $B j$, is always orthogonal to the nullspace of $L$. Let's prove this: for any vector $v \\in \\mathrm{Null}(L) = \\mathrm{Null}(B^{\\top})$, we have $B^{\\top}v=0$. The inner product is $(B j)^{\\top}v = j^{\\top}B^{\\top}v = j^{\\top}0 = 0$. This orthogonality guarantees that a solution for $\\phi$ always exists.\n\nWhile a solution for $\\phi$ exists, it is not unique if $L$ is singular. If $\\phi_s$ is a particular solution, then $\\phi_s + \\phi_0$ is also a solution for any $\\phi_0 \\in \\mathrm{Null}(L)$. However, the resulting star component $j_{\\star} = B^{\\top}\\phi$ is unique. This is because $B^{\\top}(\\phi_s + \\phi_0) = B^{\\top}\\phi_s + B^{\\top}\\phi_0 = B^{\\top}\\phi_s + 0 = B^{\\top}\\phi_s$.\n\nTo obtain a specific, numerically stable solution, we use the Moore-Penrose pseudoinverse, denoted by the superscript '$+$'. The minimum-norm least-squares solution for $\\phi$ is given by:\n$$\n\\phi_{\\text{sol}} = (B B^{\\top})^{+} (B j)\n$$\nWith this $\\phi_{\\text{sol}}$, the estimated star component, which we will denote $\\widehat{j}_{\\star}$, is computed as:\n$$\n\\widehat{j}_{\\star} = B^{\\top} \\phi_{\\text{sol}}\n$$\nOnce the star component is found, the loop component $\\widehat{j}_{\\mathrm{loop}}$ is obtained by subtraction, leveraging the orthogonality of the decomposition:\n$$\n\\widehat{j}_{\\mathrm{loop}} = j - \\widehat{j}_{\\star}\n$$\nThis resulting vector $\\widehat{j}_{\\mathrm{loop}}$ is guaranteed to be in the loop subspace, $\\mathrm{Null}(B)$, because $B\\widehat{j}_{\\mathrm{loop}} = B(j - \\widehat{j}_{\\star}) = B j - B(B^{\\top}\\phi_{\\text{sol}}) = B j - (B B^{\\top})\\phi_{\\text{sol}}$. Since $\\phi_{\\text{sol}}$ is the least-squares solution, $(B B^{\\top})\\phi_{\\text{sol}}$ is the orthogonal projection of $B j$ onto the range of $B B^{\\top}$. As we proved consistency, $B j$ lies in the range of $B B^{\\top}$, so the projection is exact: $(B B^{\\top})\\phi_{\\text{sol}} = B j$. Therefore, $B\\widehat{j}_{\\mathrm{loop}} = 0$, confirming $\\widehat{j}_{\\mathrm{loop}} \\in \\mathrm{Null}(B)$.\n\nThe implementation will follow these steps for each test case:\n1.  Construct the incidence matrix $B$ from the given number of vertices $n_v$ and the list of edges.\n2.  Generate synthetic ground truth data. A random number generator is seeded for reproducibility.\n    a. A basis for the nullspace of $B$, $\\mathrm{Null}(B)$, is found using Singular Value Decomposition (SVD). The basis vectors are the right singular vectors corresponding to singular values below a tolerance of $10^{-12}$.\n    b. The true loop component $j_{\\mathrm{loop}}$ is created as a random linear combination of these nullspace basis vectors. If the nullspace is trivial (e.g., for a tree graph), $j_{\\mathrm{loop}}$ is the zero vector.\n    c. The true star component $j_{\\star}$ is created from a random potential vector $\\phi_{\\text{true}}$ via $j_{\\star} = B^{\\top}\\phi_{\\text{true}}$.\n    d. A noise vector $n$ is generated, and the total vector is constructed as $j = j_{\\star} + j_{\\mathrm{loop}} + n$.\n3.  The projection algorithm is applied to $j$ to compute the estimates $\\widehat{j}_{\\star}$ and $\\widehat{j}_{\\mathrm{loop}}$.\n4.  Finally, the relative reconstruction errors, $\\varepsilon_{\\star}$ and $\\varepsilon_{\\mathrm{loop}}$, are calculated by comparing the estimated components to the ground truth components, normalized by the norm of the ground truth (with a small constant $\\epsilon = 10^{-12}$ to prevent division by zero).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for loop-star decomposition.\n    \"\"\"\n    test_cases = [\n        {'nv': 4, 'edges': [(0, 1), (1, 2), (2, 3), (3, 0)], 'seed': 42, 'noise_std': 0.0},\n        {'nv': 4, 'edges': [(0, 1), (1, 2), (2, 3)], 'seed': 43, 'noise_std': 0.0},\n        {'nv': 6, 'edges': [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)], 'seed': 44, 'noise_std': 0.0},\n        {'nv': 5, 'edges': [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4)], 'seed': 45, 'noise_std': 1e-6},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        nv = case['nv']\n        edges = case['edges']\n        seed = case['seed']\n        noise_std = case['noise_std']\n        \n        ne = len(edges)\n        rng = np.random.default_rng(seed)\n\n        # 1. Build the incidence matrix B\n        B = np.zeros((nv, ne))\n        for i, (tail, head) in enumerate(edges):\n            B[tail, i] = -1.0\n            B[head, i] = 1.0\n\n        # 2. Generate ground truth data (j_star and j_loop)\n        \n        # 2a. Find a basis for Null(B) using SVD\n        # The rows of Vh corresponding to small singular values form a basis for Null(B)\n        try:\n            _, s, Vh = np.linalg.svd(B)\n        except np.linalg.LinAlgError:\n            # SVD may not converge for some matrices, although not expected here\n            all_results.extend([np.nan, np.nan])\n            continue\n            \n        svd_tol = 1e-12\n        null_space_basis_rows = Vh[s  svd_tol]\n\n        # 2b. Generate j_loop\n        if null_space_basis_rows.shape[0]  0:\n            # Transpose to get basis vectors as columns\n            null_space_basis = null_space_basis_rows.T\n            # Generate random coefficients for the basis vectors\n            loop_coeffs = rng.standard_normal(null_space_basis.shape[1])\n            j_loop = null_space_basis @ loop_coeffs\n        else:\n            j_loop = np.zeros(ne)\n\n        # 2c. Generate j_star\n        phi_true = rng.standard_normal(nv)\n        j_star = B.T @ phi_true\n        \n        # 2d. Generate noise and construct the total vector j\n        noise = rng.standard_normal(ne) * noise_std\n        j = j_star + j_loop + noise\n\n        # 3. Apply the projection algorithm\n        # Solve (BB^T) * phi = B*j using the pseudoinverse\n        L = B @ B.T\n        rhs = B @ j\n        \n        # phi_sol is the minimum-norm solution for the potential\n        phi_sol = np.linalg.pinv(L) @ rhs\n        \n        # Compute the estimated star and loop components\n        j_star_hat = B.T @ phi_sol\n        j_loop_hat = j - j_star_hat\n\n        # 4. Calculate relative reconstruction errors\n        epsilon = 1e-12\n        \n        # Error for the star component\n        norm_j_star = np.linalg.norm(j_star)\n        err_star = np.linalg.norm(j_star_hat - j_star) / max(norm_j_star, epsilon)\n        \n        # Error for the loop component\n        norm_j_loop = np.linalg.norm(j_loop)\n        err_loop = np.linalg.norm(j_loop_hat - j_loop) / max(norm_j_loop, epsilon)\n        \n        all_results.extend([err_loop, err_star])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3325511"}, {"introduction": "With the theoretical and algorithmic foundations in place, we can now explore the profound physical meaning of the loop-star decomposition. The irrotational star components of a surface current are directly responsible for the accumulation of surface charge, a dominant effect in the quasi-static regime. In this practice, you will isolate the star subspace to model the charge distribution on a conducting plate under a uniform electric field, demonstrating how this decomposition provides a powerful tool for analyzing distinct physical phenomena [@problem_id:3325476].", "problem": "You are given a thin, perfectly electrically conducting rectangular plate modeled as a planar, triangulated surface domain with boundary. Consider the low-frequency, quasi-static excitation by a uniform incident electric field. In a loop-star decomposition of the induced surface current, the star subspace corresponds to irrotational fields that can be constructed on a triangulation from Rao-Wilton-Glisson (RWG) edge functions via vertex-centered star combinations. The purpose of this problem is to explicitly construct the divergence of star basis functions on a triangulated rectangle and compute a discrete charge-accumulation pattern induced by a uniform incident field through a weak enforcement of the boundary flux implied by Gauss’s theorem, thereby exhibiting edge effects.\n\nStart from the following fundamental base:\n- The surface divergence theorem on a planar domain states that for any sufficiently smooth vector field $\\mathbf{J}$ on a domain $\\Omega$ with boundary $\\partial \\Omega$, one has $\\int_{\\Omega} \\nabla_{s} \\cdot \\mathbf{J}\\, dS = \\int_{\\partial \\Omega} \\mathbf{J} \\cdot \\mathbf{n}_{\\partial \\Omega}\\, ds$, where $\\mathbf{n}_{\\partial \\Omega}$ is the unit outward normal vector along the boundary curve.\n- The RWG (Rao-Wilton-Glisson) basis functions are defined on interior edges shared by two adjacent triangles, with piecewise-linear support on the two triangles and piecewise-constant surface divergence. For the RWG function $f_{e}$ associated with interior edge $e$ of length $l_{e}$ and adjacent triangles of areas $A^{+}$ and $A^{-}$, one has $\\nabla_{s} \\cdot f_{e} = +\\frac{l_{e}}{A^{+}}$ on one adjacent triangle and $\\nabla_{s} \\cdot f_{e} = -\\frac{l_{e}}{A^{-}}$ on the other, with signs determined by consistent orientation.\n- The vertex-star basis function $S_{v}$ at a vertex $v$ is constructed as a signed sum of RWG functions around $v$, namely $S_{v} = \\sum_{e \\ni v} c(v,e)\\, f_{e}$, where $c(v,e) \\in \\{+1,-1\\}$ encodes whether vertex $v$ is the positive or negative endpoint of oriented edge $e$. The divergence of $S_{v}$ is then the corresponding signed sum of the divergences of the contributing RWG functions.\n\nYour task is to build a self-contained numerical model and compute a normalized discrete charge-accumulation pattern induced by a uniform incident electric field on the plate, using only the star subspace. Specifically:\n\n1. Geometry and discretization:\n   - The domain is a rectangle $\\Omega = [0,L_{x}] \\times [0,L_{y}]$ discretized into $N_{x} \\times N_{y}$ rectangular cells, each split into two counterclockwise-oriented triangles by the diagonal from the lower-left to upper-right cell corner.\n   - Let the set of nodes be $\\{(x_{i}, y_{j})\\}$ for $i \\in \\{0,\\dots,N_{x}\\}$ and $j \\in \\{0,\\dots,N_{y}\\}$, with $x_{i} = \\frac{i}{N_{x}} L_{x}$ and $y_{j} = \\frac{j}{N_{y}} L_{y}$.\n   - Construct all triangles with consistent counterclockwise orientation. Construct all interior edges (each shared by exactly two triangles) and boundary edges (each shared by exactly one triangle). For each interior edge, define a global edge orientation from the lower-index node to the higher-index node.\n\n2. Loop-star construction and divergence mapping:\n   - Build the vertex-star basis $\\{S_{v}\\}$ over all vertices $v$ as sums of RWG functions $f_{e}$ on interior edges incident to $v$ with signs $c(v,e) \\in \\{+1,-1\\}$ chosen such that $c(v,e)=+1$ if $v$ is the start node of the globally oriented edge $e$, and $c(v,e)=-1$ if $v$ is the end node.\n   - For each interior edge $e$ shared by triangles $T^{+}$ and $T^{-}$, determine the signs $s(T^{\\pm}, e) \\in \\{+1,-1\\}$ by comparing the edge orientation with the local counterclockwise orientation of the edge in each triangle. For triangle $T$ and edge $e$, the integrated divergence contribution equals $s(T,e)\\, l_{e}$.\n   - Assemble a matrix $D \\in \\mathbb{R}^{N_{T} \\times N_{V}}$ that maps star coefficients $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{N_{V}}$ to per-triangle integrated divergences $\\mathbf{d} \\in \\mathbb{R}^{N_{T}}$ via\n     $$ \\mathbf{d} = D \\, \\boldsymbol{\\alpha}, $$\n     where $N_{T}$ is the number of triangles and $N_{V}$ is the number of vertices. The entry $D_{t,v}$ is the sum over all interior edges $e$ that are both incident to vertex $v$ and belong to triangle $t$ of $c(v,e)\\, s(t,e)\\, l_{e}$.\n\n3. Uniform field excitation and target boundary flux:\n   - Let the uniform incident field be $\\mathbf{E}_{0} = (E_{x}, E_{y})$ tangent to the plate. Consider the surrogate target field $\\mathbf{J}_{\\mathrm{target}} = \\mathbf{E}_{0}$, which is constant over the domain and represents the irrotational field one would obtain from the scalar potential $u(\\mathbf{r}) = -\\mathbf{E}_{0} \\cdot \\mathbf{r}$ through $\\mathbf{J} = -\\nabla_{s} u$.\n   - For each boundary edge of a triangle $t$, with oriented tangent $\\hat{\\mathbf{t}}$ matching the local triangle boundary orientation and outward unit normal $\\hat{\\mathbf{n}}_{\\mathrm{out}}$ obtained by rotating $\\hat{\\mathbf{t}}$ by $-90$ degrees, form the integrated target flux contribution $q_{t,e} = (\\mathbf{E}_{0} \\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})\\, l_{e}$, where $l_{e}$ is the edge length. Define the per-triangle target as\n     $$ q_{t} = \\sum_{\\text{boundary edges } e \\subset \\partial t} q_{t,e}. $$\n     For interior edges, there is no contribution since their flux cancels between adjacent triangles. Collect $\\mathbf{q} \\in \\mathbb{R}^{N_{T}}$.\n\n4. Star-coefficient determination:\n   - Determine the star coefficients $\\boldsymbol{\\alpha}$ by minimizing the Tikhonov-regularized least squares objective\n     $$ \\min_{\\boldsymbol{\\alpha}} \\, \\left\\| D \\boldsymbol{\\alpha} - \\mathbf{q} \\right\\|_{2}^{2} + \\lambda \\left\\| \\boldsymbol{\\alpha} \\right\\|_{2}^{2}, $$\n     where $\\lambda  0$ is a small regularization parameter to ensure a stable solution. Solve the normal equations\n     $$ (D^{\\top} D + \\lambda I)\\, \\boldsymbol{\\alpha} = D^{\\top} \\mathbf{q}. $$\n\n5. Normalization and metrics:\n   - Let the perimeter be $P = 2 (L_{x} + L_{y})$ and the incident field magnitude be $\\|\\mathbf{E}_{0}\\| = \\sqrt{E_{x}^{2} + E_{y}^{2}}$. Normalize the realized per-triangle integrated divergence $\\mathbf{d} = D \\boldsymbol{\\alpha}$ by the scale $S = \\|\\mathbf{E}_{0}\\| \\, P$, i.e., define $\\tilde{\\mathbf{d}} = \\mathbf{d}/S$. All reported values must be dimensionless.\n   - Define the following four metrics from $\\tilde{\\mathbf{d}}$:\n     1) Net normalized charge: $C_{\\mathrm{net}} = \\sum_{t=1}^{N_{T}} \\tilde{d}_{t}$.\n     2) Edge balance error: construct positive and negative side totals with respect to the incident field by distributing each boundary triangle’s $|\\tilde{d}_{t}|$ to its boundary edges proportional to $|q_{t,e}|$, and accumulating into $C_{+}$ for edges with $(\\mathbf{E}_{0}\\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})  0$ and into $C_{-}$ for edges with $(\\mathbf{E}_{0}\\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})  0$. Then define $E_{\\mathrm{bal}} = |\\, |C_{+}| - |C_{-}| \\,|$.\n     3) Maximum interior magnitude: $M_{\\mathrm{int}} = \\max\\{ |\\tilde{d}_{t}| \\,:\\, t \\text{ has no boundary edges} \\}$.\n     4) Edge concentration fraction: $F_{\\mathrm{edge}} = \\left( \\sum_{t \\in \\mathcal{B}} |\\tilde{d}_{t}| \\right) \\big/ \\left( \\sum_{t=1}^{N_{T}} |\\tilde{d}_{t}| \\right)$, where $\\mathcal{B}$ is the set of triangles that have at least one boundary edge.\n\n6. Required output:\n   - For each test case below, compute and output the list $[C_{\\mathrm{net}}, E_{\\mathrm{bal}}, M_{\\mathrm{int}}, F_{\\mathrm{edge}}]$ as floating-point numbers.\n   - Your program should produce a single line of output containing the results for all provided test cases as a comma-separated list enclosed in square brackets, with each test case’s list itself enclosed in square brackets. For example, the required format is $[ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}], \\dots ]$.\n\nTest suite:\n- Case $1$: $L_{x} = 1.0$, $L_{y} = 1.0$, $N_{x} = 8$, $N_{y} = 8$, $\\mathbf{E}_{0} = (1.0, 0.0)$.\n- Case $2$: $L_{x} = 2.0$, $L_{y} = 1.0$, $N_{x} = 12$, $N_{y} = 6$, $\\mathbf{E}_{0} = (0.0, 1.0)$.\n- Case $3$: $L_{x} = 1.0$, $L_{y} = 1.0$, $N_{x} = 10$, $N_{y} = 7$, $\\mathbf{E}_{0} = \\left(\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right)$.\n- Case $4$: $L_{x} = 2.0$, $L_{y} = 0.2$, $N_{x} = 40$, $N_{y} = 4$, $\\mathbf{E}_{0} = (1.0, 0.0)$.\n\nAll outputs must be dimensionless, computed as specified, and presented in the exact final output format described above. No other units are required. Angles, if any, must be understood in radians, but you do not need any trigonometric functions beyond dot products of vectors here.", "solution": "The solution involves the following steps:\n1.  **Geometric Modeling and Discretization**: A rectangular domain $\\Omega = [0,L_{x}] \\times [0,L_{y}]$ is discretized into a grid of $N_{x} \\times N_{y}$ cells. Each cell is subdivided into two counterclockwise-oriented triangles. This process generates a set of vertices (nodes), a list of triangles defined by vertex indices, and sets of interior and boundary edges.\n2.  **Basis Function and Operator Construction**: The core of the model is the construction of the discrete divergence operator, represented by a matrix $D$. The star basis functions, $\\{S_v\\}$, are defined at each vertex $v$ as a signed sum of Rao-Wilton-Glisson (RWG) basis functions $\\{f_e\\}$ over incident interior edges. The matrix $D \\in \\mathbb{R}^{N_{T} \\times N_{V}}$ maps the coefficients $\\boldsymbol{\\alpha}$ of the star basis expansion to the integrated surface divergence on each triangle. An entry $D_{t,v}$ represents the integrated divergence of the star basis function $S_v$ over triangle $t$, and is given by the formula:\n    $$ D_{t,v} = \\sum_{e \\in \\mathcal{E}_t \\cap \\mathcal{E}_v} c(v,e)\\, s(t,e)\\, l_{e} $$\n    where $\\mathcal{E}_t$ and $\\mathcal{E}_v$ are the sets of interior edges belonging to triangle $t$ and incident to vertex $v$, respectively. The sign $c(v,e) \\in \\{+1,-1\\}$ depends on whether $v$ is the start or end node of the globally oriented edge $e$. The sign $s(t,e) \\in \\{+1,-1\\}$ compares the global edge orientation to the local counterclockwise traversal of the edge within triangle $t$. The term $l_e$ is the length of edge $e$. The null space of $D$ corresponds to a constant potential (i.e., $\\boldsymbol{\\alpha}$ is a constant vector), which leads to a rank-deficient system.\n\n3.  **Excitation and Boundary Conditions**: A uniform incident electric field $\\mathbf{E}_0$ is applied. The physical boundary condition, derived from the surface divergence theorem, requires that the total divergence within the domain equals the net flux through the boundary. This is weakly enforced by defining a target flux vector $\\mathbf{q} \\in \\mathbb{R}^{N_{T}}$. For each triangle $t$, the component $q_t$ is the sum of integrated fluxes of $\\mathbf{E}_0$ through its boundary edges:\n    $$ q_{t} = \\sum_{\\text{boundary edges } e \\subset \\partial t} (\\mathbf{E}_{0} \\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})\\, l_{e} $$\n    where $\\hat{\\mathbf{n}}_{\\mathrm{out}}$ is the outward-pointing normal to the edge on the domain boundary.\n\n4.  **Solving the Linear System**: The star coefficients $\\boldsymbol{\\alpha}$ are found by solving a Tikhonov-regularized least-squares problem, which seeks to match the realized divergence $D\\boldsymbol{\\alpha}$ with the target flux $\\mathbf{q}$. This leads to the normal equations:\n    $$ (D^{\\top} D + \\lambda I)\\, \\boldsymbol{\\alpha} = D^{\\top} \\mathbf{q} $$\n    The regularization term $\\lambda I$, with a small parameter $\\lambda > 0$ (chosen here as $\\lambda=10^{-12}$), ensures the matrix is invertible by penalizing non-physical solutions and stabilizing the inversion in the presence of the null space of $D^TD$.\n\n5.  **Post-processing and Metrics Calculation**: Once $\\boldsymbol{\\alpha}$ is found, the realized per-triangle integrated divergence is calculated as $\\mathbf{d} = D\\boldsymbol{\\alpha}$. This vector is normalized by a factor $S = \\|\\mathbf{E}_{0}\\| P$, where $P$ is the plate perimeter, to yield the dimensionless quantity $\\tilde{\\mathbf{d}}$. Finally, the four specified metrics are computed from $\\tilde{\\mathbf{d}}$:\n    -   $C_{\\mathrm{net}}$: The net normalized charge, which should be close to zero due to the properties of the divergence operator.\n    -   $E_{\\mathrm{bal}}$: The balance error between positive and negative charge accumulations on the boundary.\n    -   $M_{\\mathrm{int}}$: The maximum charge magnitude in interior triangles, indicating leakage from the boundary.\n    -   $F_{\\mathrm{edge}}$: The fraction of total charge magnitude concentrated on boundary triangles, quantifying the expected edge effect.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 8, 'Ny': 8, 'E0': (1.0, 0.0)},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 12, 'Ny': 6, 'E0': (0.0, 1.0)},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 10, 'Ny': 7, 'E0': (1/np.sqrt(2), 1/np.sqrt(2))},\n        {'Lx': 2.0, 'Ly': 0.2, 'Nx': 40, 'Ny': 4, 'E0': (1.0, 0.0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Each test case is solved by a dedicated function\n        res = compute_metrics_for_case(**case)\n        results.append(res)\n\n    # Format the output as a list of lists of floats, e.g., [[r1,r2,...],[r1,r2,...]]\n    # The map(str,...) and join combination achieves this format precisely.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_metrics_for_case(Lx, Ly, Nx, Ny, E0):\n    \"\"\"\n    Computes the four required metrics for a single test case following the\n    problem's methodology.\n    \"\"\"\n    # A small regularization parameter for Tikhonov regularization\n    LAMBDA = 1e-12\n    E0_vec = np.array(E0)\n\n    # 1. Geometry and discretization\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_triangles = 2 * Nx * Ny\n\n    # Create nodes with y-index varying fastest to match node_idx function\n    x_coords = np.linspace(0, Lx, num_nodes_x)\n    y_coords = np.linspace(0, Ly, num_nodes_y)\n    node_list = []\n    for i in range(num_nodes_x):\n        for j in range(num_nodes_y):\n            node_list.append([x_coords[i], y_coords[j]])\n    nodes = np.array(node_list)\n\n    def node_idx(i, j):\n        return i * num_nodes_y + j\n\n    # Create triangles with consistent CCW orientation\n    triangles = []\n    for i in range(Nx):\n        for j in range(Ny):\n            v_ll, v_lr, v_ul, v_ur = node_idx(i, j), node_idx(i + 1, j), node_idx(i, j + 1), node_idx(i + 1, j + 1)\n            triangles.append([v_ll, v_lr, v_ur])\n            triangles.append([v_ll, v_ur, v_ul])\n    \n    # Identify interior and boundary edges\n    edge_to_triangles = {}\n    for t_idx, t_verts in enumerate(triangles):\n        for i in range(3):\n            v1, v2 = t_verts[i], t_verts[(i + 1) % 3]\n            edge = tuple(sorted((v1, v2)))\n            edge_to_triangles.setdefault(edge, []).append(t_idx)\n\n    interior_edges = {e for e, t_list in edge_to_triangles.items() if len(t_list) == 2}\n    boundary_edges = {e for e, t_list in edge_to_triangles.items() if len(t_list) == 1}\n\n    # 2. Assemble divergence matrix D\n    D = np.zeros((num_triangles, num_nodes))\n    for t_idx, t_verts in enumerate(triangles):\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        for v_node_idx in t_verts:\n            D_tv_val = 0.0\n            for v_start_local, v_end_local in local_edges_verts:\n                if v_node_idx in (v_start_local, v_end_local):\n                    edge_global = tuple(sorted((v_start_local, v_end_local)))\n                    if edge_global in interior_edges:\n                        edge_len = np.linalg.norm(nodes[v_end_local] - nodes[v_start_local])\n                        c_sign = 1 if v_node_idx == edge_global[0] else -1\n                        s_sign = 1 if (v_start_local, v_end_local) == edge_global else -1\n                        D_tv_val += c_sign * s_sign * edge_len\n            D[t_idx, v_node_idx] = D_tv_val\n\n    # 3. Assemble target vector q\n    q = np.zeros(num_triangles)\n    for t_idx, t_verts in enumerate(triangles):\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        for v_start, v_end in local_edges_verts:\n            if tuple(sorted((v_start, v_end))) in boundary_edges:\n                t_vec = nodes[v_end] - nodes[v_start]\n                n_vec = np.array([t_vec[1], -t_vec[0]])\n                flux = np.dot(E0_vec, n_vec)\n                q[t_idx] += flux\n\n    # 4. Determine star coefficients alpha\n    DtD = D.T @ D\n    A = DtD + LAMBDA * np.identity(num_nodes)\n    b = D.T @ q\n    alpha = np.linalg.solve(A, b)\n    \n    # 5. Calculate metrics\n    d = D @ alpha\n    perimeter = 2 * (Lx + Ly)\n    E0_mag = np.linalg.norm(E0_vec)\n    if E0_mag  1e-15: return [0.0, 0.0, 0.0, 0.0]\n    scale = E0_mag * perimeter\n    if scale  1e-15: return [0.0, 0.0, 0.0, 0.0]\n    d_tilde = d / scale\n    \n    # Metric 1: C_net\n    C_net = np.sum(d_tilde)\n    \n    # Metric 2: E_bal\n    C_plus, C_minus = 0.0, 0.0\n    boundary_triangle_indices = sorted(list({t_idx for e in boundary_edges for t_idx in edge_to_triangles[e]}))\n    for t_idx in boundary_triangle_indices:\n        t_verts = triangles[t_idx]\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        boundary_edges_info = []\n        total_abs_q_t = 0.0\n        for v_start, v_end in local_edges_verts:\n            if tuple(sorted((v_start, v_end))) in boundary_edges:\n                t_vec = nodes[v_end] - nodes[v_start]\n                n_vec = np.array([t_vec[1], -t_vec[0]])\n                q_te = np.dot(E0_vec, n_vec)\n                boundary_edges_info.append(q_te)\n                total_abs_q_t += abs(q_te)\n        if total_abs_q_t  1e-15:\n            d_t_tilde_mag = abs(d_tilde[t_idx])\n            for q_te in boundary_edges_info:\n                fraction = abs(q_te) / total_abs_q_t\n                charge_contribution = d_t_tilde_mag * fraction\n                if q_te  0: C_plus += charge_contribution\n                else: C_minus += charge_contribution\n    E_bal = abs(C_plus - C_minus)\n    \n    # Metric 3: M_int\n    all_triangle_indices = set(range(num_triangles))\n    interior_triangle_indices = list(all_triangle_indices - set(boundary_triangle_indices))\n    M_int = np.max(np.abs(d_tilde[interior_triangle_indices])) if interior_triangle_indices else 0.0\n        \n    # Metric 4: F_edge\n    sum_abs_d_boundary = np.sum(np.abs(d_tilde[list(boundary_triangle_indices)]))\n    sum_abs_d_total = np.sum(np.abs(d_tilde))\n    F_edge = sum_abs_d_boundary / sum_abs_d_total if sum_abs_d_total > 1e-15 else 0.0\n    \n    return [C_net, E_bal, M_int, F_edge]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3325476"}]}