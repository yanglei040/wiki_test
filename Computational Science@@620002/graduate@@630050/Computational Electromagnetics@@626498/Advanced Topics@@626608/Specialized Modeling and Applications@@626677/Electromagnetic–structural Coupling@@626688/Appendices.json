{"hands_on_practices": [{"introduction": "The first step in any coupled simulation is to consistently represent physical interactions within a numerical framework. This practice focuses on the fundamental task of deriving and implementing the element-level coupling matrix for the Lorentz force, $\\mathbf{J} \\times \\mathbf{B}$, which is a cornerstone of magnetostatics-structure interaction. By working through this exercise [@problem_id:3304507], you will bridge the conceptual gap between Maxwell's equations, the principle of virtual work, and a concrete piece of code used in finite element analysis.", "problem": "A two-dimensional magnetoelastic body occupies a polygonal domain in the plane with unit thickness. Under the assumptions of small deformations, quasistatic magnetostatics, linear and isotropic magnetic materials, and negligible magnetostriction, the electromagnetic field and the structure are weakly coupled through the Lorentz body force density. Starting from Maxwell's equations for magnetostatics and the principle of virtual work in continuum mechanics, derive the element-level coupling that maps the electromagnetic degrees of freedom to the mechanical nodal force vector for a single linear triangular element. Then implement the derived expressions to compute either the element-level coupling matrix or the consistent mechanical nodal force vector as specified by the test suite below. All calculations must assume unit thickness and constant current density through the element. When a mechanical force is requested, express the final answer in Newtons, rounded to six decimal places.\n\nFundamental starting point and modeling assumptions:\n- Magnetostatics with the magnetic vector potential, where the magnetic flux density satisfies $\\nabla \\times \\mathbf{A} = \\mathbf{B}$ and the curl equation $\\nabla \\times \\mathbf{H} = \\mathbf{J}$, with $\\mathbf{B} = \\mu \\mathbf{H}$ and constant scalar $\\mu$.\n- Out-of-plane magnetic vector potential representation in two dimensions: $\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$, so that $\\mathbf{B} = \\nabla \\times \\left(A_z \\hat{\\mathbf{k}}\\right)$.\n- Electric current density is out-of-plane and constant per element: $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$, where $J_z$ is an element-wise constant.\n- Mechanical virtual work due to electromagnetic body force density given by $\\delta W = \\int_{\\Omega} \\delta \\mathbf{u} \\cdot \\left(\\mathbf{J} \\times \\mathbf{B}\\right)\\, \\mathrm{d}\\Omega$, neglecting Maxwell surface tractions on the element boundary.\n- Finite Element Method (FEM) with linear shape functions on a single triangle having nodes indexed by $i \\in \\{1,2,3\\}$ and coordinates $(x_i,y_i)$. The magnetic vector potential is approximated as $A_z(x,y) \\approx \\sum_{i=1}^3 N_i(x,y)\\, a_i$, where $a_i$ are nodal values and $N_i$ are scalar shape functions. The mechanical displacement interpolation uses the same shape functions $N_i$ with two displacement components per node.\n\nDerivation objectives:\n- From the above base, derive the explicit expression for the magnetic flux density components $\\left(B_x, B_y\\right)$ in terms of the gradients of the shape functions and the nodal magnetic potential values $\\{a_i\\}_{i=1}^3$ for a linear triangular element.\n- Using the Lorentz force density $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ with $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$, express $\\mathbf{f}$ in terms of the nodal magnetic potential values $\\{a_i\\}_{i=1}^3$.\n- Derive the consistent nodal mechanical force vector $\\mathbf{F}_e \\in \\mathbb{R}^{6}$ for the element by integrating the virtual work with the mechanical shape functions, and obtain the $6 \\times 3$ coupling matrix $C_e$ that maps the magnetic nodal vector $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ to $\\mathbf{F}_e$, i.e., $\\mathbf{F}_e = C_e \\mathbf{a}_e$. Assume unit thickness and that $J_z$ is constant over the element. Do not assume any special orientation for the triangle.\n\nComputational task:\n- Implement the derived expressions for a single linear triangular element with nodes at coordinates $\\left(x_i, y_i\\right)$ for $i \\in \\{1,2,3\\}$ and constant $J_z$ over the element.\n- If a test case requests the coupling matrix, output the matrix entries flattened in row-major order: rows correspond to mechanical degrees of freedom ordered as $\\left[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}\\right]$, and columns correspond to $\\left[a_1, a_2, a_3\\right]$.\n- If a test case requests the mechanical nodal force vector, compute $\\mathbf{F}_e = C_e \\mathbf{a}_e$ and output it as a length-$6$ list ordered as $\\left[F_{1x}, F_{1y}, F_{2x}, F_{2y}, F_{3x}, F_{3y}\\right]$.\n- Units and rounding:\n  - Coordinates $\\left(x_i,y_i\\right)$ are in meters.\n  - Current density $J_z$ is in amperes per square meter $\\left(\\mathrm{A}/\\mathrm{m}^2\\right)$.\n  - Magnetic vector potential nodal values $a_i$ are in weber per meter $\\left(\\mathrm{Wb}/\\mathrm{m}\\right)$.\n  - The element thickness is unity in meters, so the resulting nodal forces are in newtons $\\left(\\mathrm{N}\\right)$.\n  - All numerical outputs must be rounded to $6$ decimal places.\n- Angle units are not used in this problem.\n- The program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each result is itself a bracketed, comma-separated list. For coupling matrices, output the flattened entries in row-major order; for force vectors, output the six entries in order. For example, the output format is like $\\left[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,\\right]$ with no spaces, and all numbers rounded to $6$ decimal places.\n\nTest suite:\n- Test case $1$ (coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=2.0$.\n- Test case $2$ (force vector): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=1.0$, $\\left[a_1,a_2,a_3\\right]=[0.0,1.0,0.0]$.\n- Test case $3$ (zero coupling): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=0.0$.\n- Test case $4$ (scaled geometry, coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(2,1)$, $\\left(x_2,y_2\\right)=(5,1)$, $\\left(x_3,y_3\\right)=(2,4)$, $J_z=3.0$.\n- Test case $5$ (negative current, coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=-1.5$.\n- Test case $6$ (force vector on non-orthogonal triangle): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(2,0)$, $\\left(x_3,y_3\\right)=(1,1.7320508075688772)$, $J_z=0.5$, $\\left[a_1,a_2,a_3\\right]=[0.0,2.0,-0.7320508075688772]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself enclosed in square brackets, and with all floating-point numbers rounded to $6$ decimal places, for example: $\\left[\\,[r_{1,1},\\ldots,r_{1,n_1}],\\,[r_{2,1},\\ldots,r_{2,n_2}],\\ldots\\,\\right]$ where each $r_{k,j}$ is a float rounded to $6$ decimals.", "solution": "The task is to derive and implement the element-level coupling that maps electromagnetic degrees of freedom (nodal magnetic vector potentials) to mechanical nodal forces for a linear triangular element. The coupling arises from the Lorentz body force within a 2D quasistatic magneto-structural model.\n\n### Derivation of the Coupling Matrix\n\nThe derivation proceeds in three steps:\n1.  Express the magnetic flux density, $\\mathbf{B}$, in terms of the nodal magnetic vector potential values, $\\mathbf{a}_e$.\n2.  Derive the Lorentz body force density, $\\mathbf{f}$, using the previously found expression for $\\mathbf{B}$.\n3.  Use the principle of virtual work to find the consistent nodal force vector, $\\mathbf{F}_e$, and extract the coupling matrix, $C_e$.\n\n**1. Magnetic Flux Density $\\mathbf{B}$**\n\nThe problem assumes a 2D model where the magnetic vector potential $\\mathbf{A}$ has only an out-of-plane component, $\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$. The magnetic flux density $\\mathbf{B}$ is given by the curl of $\\mathbf{A}$:\n$$\n\\mathbf{B} = \\nabla \\times \\mathbf{A} = \\nabla \\times (A_z\\,\\hat{\\mathbf{k}}) = \\begin{vmatrix} \\hat{\\mathbf{i}} & \\hat{\\mathbf{j}} & \\hat{\\mathbf{k}} \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ 0 & 0 & A_z \\end{vmatrix} = \\frac{\\partial A_z}{\\partial y} \\hat{\\mathbf{i}} - \\frac{\\partial A_z}{\\partial x} \\hat{\\mathbf{j}}\n$$\nThus, the in-plane components of the magnetic flux density are $B_x = \\frac{\\partial A_z}{\\partial y}$ and $B_y = -\\frac{\\partial A_z}{\\partial x}$.\n\nWithin a linear triangular finite element, the field $A_z(x,y)$ is interpolated from its nodal values $\\{a_1, a_2, a_3\\}$ using linear shape functions $N_i(x,y)$:\n$$\nA_z(x,y) \\approx \\sum_{i=1}^{3} N_i(x,y) a_i\n$$\nThe gradient of $A_z$ is then:\n$$\n\\nabla A_z = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\sum_{i=1}^{3} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} a_i\n$$\nFor a linear triangular element with nodes $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$, the gradients of the shape functions are constant over the element. They are given by:\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2 A_e}, \\quad \\frac{\\partial N_i}{\\partial y} = \\frac{d_i}{2 A_e}\n$$\nwhere $A_e$ is the area of the element, and the coefficients $b_i$ and $d_i$ are functions of the nodal coordinates:\n$$\n\\begin{array}{ll}\nb_1 = y_2 - y_3, & \\quad d_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1, & \\quad d_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2, & \\quad d_3 = x_2 - x_1\n\\end{array}\n$$\nThe gradient $\\nabla A_z$ can be written in matrix form as:\n$$\n\\nabla A_z = \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} = \\mathbf{B}_{mat} \\mathbf{a}_e\n$$\nSince $\\mathbf{B}_{mat}$ and $\\mathbf{a}_e$ are constant with respect to $(x,y)$ within the element, $\\nabla A_z$ is constant. Consequently, the magnetic flux density $\\mathbf{B}$ is also constant over the element:\n$$\n\\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial y} \\\\ -\\frac{\\partial A_z}{\\partial x} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\mathbf{B}_{mat} \\mathbf{a}_e = \\frac{1}{2 A_e} \\begin{bmatrix} d_1 & d_2 & d_3 \\\\ -b_1 & -b_2 & -b_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n\n**2. Lorentz Force Density $\\mathbf{f}$**\n\nThe Lorentz body force density is given by $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$. The current density $\\mathbf{J}$ is assumed to be constant and out-of-plane, $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$.\n$$\n\\mathbf{f} = (J_z \\hat{\\mathbf{k}}) \\times (B_x \\hat{\\mathbf{i}} + B_y \\hat{\\mathbf{j}}) = J_z B_x (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{i}}) + J_z B_y (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{j}}) = J_z B_x \\hat{\\mathbf{j}} - J_z B_y \\hat{\\mathbf{i}}\n$$\nThe components of the force density are $f_x = -J_z B_y$ and $f_y = J_z B_x$. In vector form:\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{pmatrix} -B_y \\\\ B_x \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix}\n$$\nSubstituting the expression for $\\mathbf{B}$ in terms of $\\nabla A_z$:\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\nabla A_z\n$$\nSo, the force density is directly proportional to the gradient of the magnetic vector potential, $\\mathbf{f} = J_z \\mathbf{B}_{mat} \\mathbf{a}_e$. Since $\\nabla A_z$ is constant over the element, so is $\\mathbf{f}$.\n\n**3. Nodal Force Vector $\\mathbf{F}_e$ and Coupling Matrix $C_e$**\n\nThe equivalent nodal forces are derived from the principle of virtual work. The virtual work done by the body force is:\n$$\n\\delta W = \\int_{V_e} \\delta \\mathbf{u} \\cdot \\mathbf{f} \\, dV\n$$\nwhere $\\delta\\mathbf{u}$ is the virtual displacement field. In the FEM framework, the displacement field $\\mathbf{u}$ is interpolated using the same shape functions as $A_z$:\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} \\mathbf{u}_e = \\mathbf{N}(x,y) \\mathbf{u}_e\n$$\nwhere $\\mathbf{u}_e \\in \\mathbb{R}^6$ is the vector of nodal displacements. The virtual work becomes:\n$$\n\\delta W = \\int_{V_e} (\\mathbf{N} \\delta\\mathbf{u}_e)^T \\mathbf{f} \\, dV = \\delta\\mathbf{u}_e^T \\left( \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV \\right)\n$$\nBy definition, $\\delta W = \\delta\\mathbf{u}_e^T \\mathbf{F}_e$, so the consistent nodal force vector is:\n$$\n\\mathbf{F}_e = \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV\n$$\nFor a 2D problem of unit thickness $t=1$, the volume integral becomes an area integral, $dV = t \\, dA = dA$. Since the force density $\\mathbf{f}$ is constant over the element, we can take it out of the integral:\n$$\n\\mathbf{F}_e = \\left( \\int_{A_e} \\mathbf{N}^T \\, dA \\right) \\mathbf{f}\n$$\nThe integral of the shape function matrix $\\mathbf{N}^T$ is:\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\int_{A_e} \\begin{bmatrix} N_1 & 0 \\\\ 0 & N_1 \\\\ N_2 & 0 \\\\ 0 & N_2 \\\\ N_3 & 0 \\\\ 0 & N_3 \\end{bmatrix} dA = \\begin{bmatrix} \\int N_1 dA & 0 \\\\ 0 & \\int N_1 dA \\\\ \\vdots & \\vdots \\\\ \\int N_3 dA & 0 \\\\ 0 & \\int N_3 dA \\end{bmatrix}\n$$\nThe integral of a linear shape function over its triangular element is $\\int_{A_e} N_i \\, dA = A_e/3$. Therefore:\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n$$\nSubstituting this and the expression for $\\mathbf{f}$ into the equation for $\\mathbf{F}_e$:\n$$\n\\mathbf{F}_e = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( J_z \\mathbf{B}_{mat} \\mathbf{a}_e \\right) = \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e\n$$\nThe problem specifies unit thickness $t=1\\,\\text{m}$. The dimensional analysis requires including this thickness. The full expression for force is $\\mathbf{F}_e = t \\frac{A_e}{3} ...$.\n$$\n\\mathbf{F}_e = t \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e = \\frac{t J_z}{6} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\mathbf{a}_e\n$$\nThe term $\\mathbf{F}_e = C_e \\mathbf{a}_e$ allows us to identify the $6 \\times 3$ coupling matrix $C_e$:\n$$\nC_e = \\frac{t J_z}{6} \\begin{bmatrix}\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3\n\\end{bmatrix}\n$$\nWith $t=1$, the final expression for the coupling matrix to be implemented is:\n$$\nC_e = \\frac{J_z}{6} \\begin{bmatrix}\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1\n\\end{bmatrix}\n$$\nThe force vector $\\mathbf{F}_e$ is computed by multiplying this matrix by the nodal vector potential values $\\mathbf{a}_e = [a_1, a_2, a_3]^T$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the magneto-structural coupling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 2.0},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 1.0, \"a\": [0.0, 1.0, 0.0]},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 0.0},\n        {\"mode\": \"matrix\", \"coords\": ((2, 1), (5, 1), (2, 4)), \"Jz\": 3.0},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": -1.5},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (2, 0), (1, 1.7320508075688772)), \"Jz\": 0.5, \"a\": [0.0, 2.0, -0.7320508075688772]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_coupling(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str = []\n    for res_list in results:\n        res_list_str = [f\"{x:.6f}\" for x in res_list]\n        results_str.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_coupling(case_data):\n    \"\"\"\n    Computes the coupling matrix or nodal force vector for a single linear triangular element.\n\n    Args:\n        case_data (dict): A dictionary containing the parameters for the test case.\n                          It must include 'mode', 'coords', and 'Jz'. If 'mode' is 'force',\n                          it must also include 'a'.\n\n    Returns:\n        list: A list of floats representing either the flattened coupling matrix\n              or the nodal force vector, rounded to 6 decimal places.\n    \"\"\"\n    mode = case_data[\"mode\"]\n    (x1, y1), (x2, y2), (x3, y3) = case_data[\"coords\"]\n    Jz = case_data[\"Jz\"]\n    \n    # As per the problem statement, element thickness t is 1 meter.\n    # The derived coupling matrix includes a factor t, so we set t=1.0.\n    t = 1.0\n    \n    # Calculate geometric coefficients b_i and d_i\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    \n    d1 = x3 - x2\n    d2 = x1 - x3\n    d3 = x2 - x1\n    \n    # The core 2x3 matrix relating force density to nodal potentials (scaled by Jz)\n    # This corresponds to [ [b1, b2, b3], [d1, d2, d3] ]\n    core_matrix = np.array([[b1, b2, b3], [d1, d2, d3]])\n    \n    # Construct the 6x3 coupling matrix Ce by tiling the core matrix and scaling\n    # Ce = (t * Jz / 6) * [ core_matrix_tiled_vertically ]\n    C_e = (t * Jz / 6.0) * np.tile(core_matrix, (3, 1))\n\n    if mode == \"matrix\":\n        # Flatten the matrix in row-major order (numpy's default)\n        return C_e.flatten().tolist()\n    elif mode == \"force\":\n        a_e = np.array(case_data[\"a\"]).reshape(3, 1)\n        # Compute the nodal force vector F_e = C_e * a_e\n        F_e = C_e @ a_e\n        return F_e.flatten().tolist()\n\n# Run the solver\nsolve()\n```", "id": "3304507"}, {"introduction": "Once forces are discretized, the coupled system's evolution must be solved over time, where numerical stability is paramount. A common and critical pitfall in multiphysics simulations is the artificial growth of energy, which leads to unphysical and explosive results. This practice [@problem_id:3304517] guides you to contrast a \"power-consistent\" coupling scheme with a simpler but \"inconsistent\" one, allowing you to directly observe and quantify how the choice of numerical algorithm dictates the conservation of energy in a coupled dynamic system.", "problem": "You are to analyze and simulate numerical energy exchange in a lumped electromagnetic–structural system composed of a single-turn coil coupled to a single-degree-of-freedom linear beam. The electric part is treated as a position-dependent inductor with no resistance and no source, updated by a Finite-Difference Time-Domain (FDTD)-consistent invariant, and the structural part is updated by the Newmark family of schemes. Your goal is to implement two time-integration couplings, quantify discrete energy behavior, and identify conditions that avoid artificial energy growth.\n\nThe continuous model is as follows. Let the beam displacement be $x(t)$ in meters and velocity $v(t)$ in meters per second, with mass $m$ in kilograms and stiffness $k$ in newtons per meter. The coil is modeled as an inductor whose inductance depends on the beam displacement, $L(x)$ in henries. Let the coil current be $I(t)$ in amperes and the flux linkage be $\\psi(t)$ in weber-turns. Assume zero electrical resistance and zero voltage source, so that the electric loop equation is the conservation of flux linkage,\n$$\n\\frac{d\\psi}{dt} = 0,\\quad \\text{with}\\quad \\psi(t) = L(x(t))\\,I(t).\n$$\nThe magnetic co-energy is\n$$\nW_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2,\n$$\nand the electromagnetic force acting on the beam is the negative gradient of magnetic co-energy with respect to $x$, which for a scalar state reduces to\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{1}{2} I^2 \\frac{dL}{dx}(x).\n$$\nThe beam equation of motion is\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t)).\n$$\nThe total continuous energy is\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2,\n$$\nwhich is exactly conserved for $d\\psi/dt=0$ and zero damping.\n\nYou will compare two discrete coupling schemes over a fixed time horizon $T$ in seconds:\n- Scheme A (Power-consistent, FDTD–Newmark): enforce the FDTD-consistent invariant by keeping the flux linkage constant, $\\psi^{n+1} = \\psi^{n}$, and use the Newmark trapezoidal rule with parameters $\\beta = 1/4$ and $\\gamma = 1/2$ for the beam. With $\\psi$ held constant, the current is $I(x) = \\psi / L(x)$. Define the acceleration as a function of displacement,\n$$\na(x) = \\frac{1}{m}\\left(\\frac{1}{2}\\,\\frac{\\psi^2}{L(x)^2}\\,\\frac{dL}{dx}(x) - k\\,x\\right).\n$$\nAdvance $x^n \\mapsto x^{n+1}$ by solving the Newmark trapezoidal implicit update\n$$\nx^{n+1} - \\frac{\\Delta t^2}{4}\\,a(x^{n+1}) = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n}),\n$$\nthen set\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right),\\quad I^{n+1} = \\frac{\\psi}{L(x^{n+1})}.\n$$\nUse a Newton iteration to solve for $x^{n+1}$ to numerical convergence at each step. This scheme is designed to be power-conjugate at the discrete level.\n\n- Scheme B (Inconsistent, frozen-current coupling): freeze the current over each step by setting $I^{n+1} = I^{n}$, and evaluate the electromagnetic force using the displacement and current at the beginning of the step,\n$$\nF_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n).\n$$\nAdvance the beam with the same Newmark parameters $\\beta = 1/4$ and $\\gamma = 1/2$, but treating $F_{\\mathrm{em}}^n$ as constant over the step, so that the implicit equation reduces to a linear solve for $x^{n+1}$,\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(\\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right)\\right) + \\frac{\\Delta t^2}{4m} F_{\\mathrm{em}}^{n}}{1 + \\frac{\\Delta t^2}{4}\\frac{k}{m}},\n$$\nfollowed by\n$$\na^{n} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right),\\quad a^{n+1} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n+1}\\right),\\quad v^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right).\n$$\nThis scheme is intentionally not power-conjugate because it freezes the current and evaluates the force at different time than the inductive co-energy.\n\nFor both schemes, compute the discrete total energy at each step $n$,\n$$\nE^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2.\n$$\n\nYour task is to write a program that, for the parameter sets below, simulates the system from $t=0$ to $t=T$ with uniform time step $\\Delta t$ and initial conditions, and returns for each test case the maximum fractional increase of the discrete total energy relative to the initial energy,\n$$\n\\max_{0 \\le n \\le N} \\left(\\frac{E^{n} - E^{0}}{E^{0}}\\right),\n$$\nreported as a dimensionless decimal (no unit), where $N = T/\\Delta t$ is the number of time steps. A value near $0$ indicates no artificial energy growth; a positive value indicates artificial energy growth.\n\nUse the following physically consistent modeling choices:\n- Inductance: $L(x) = L_{0} + \\alpha\\, x$ with $L_{0} > 0$ and $\\alpha \\ge 0$, so that $\\frac{dL}{dx} = \\alpha$.\n- No electrical resistance and no external excitation, so $d\\psi/dt = 0$ for Scheme A.\n- No structural damping.\n\nUse the following numerical and physical parameters, with all quantities in the International System of Units (SI). Mass $m$ in kilograms, stiffness $k$ in newtons per meter, inductance $L$ in henries, current $I$ in amperes, time in seconds, displacement $x$ in meters:\n- Common physical parameters: $m = 0.05$, $k = 200$, $L_{0} = 0.001$, $\\alpha = 0.02$.\n- Initial conditions: $x(0) = 0$, $v(0) = 0$, $I(0) = 20$. For Scheme A, set $\\psi(0) = L(x(0))\\,I(0)$ and enforce $\\psi^{n+1} = \\psi^{n}$.\n- Time horizon: $T = 0.01$.\n\nImplement the four test cases:\n- Case $1$: Scheme A with $\\Delta t = 0.0001$.\n- Case $2$: Scheme A with $\\Delta t = 0.0005$.\n- Case $3$: Scheme B with $\\Delta t = 0.0001$.\n- Case $4$: Scheme B with $\\Delta t = 0.0005$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four cases above. Each result is the maximum fractional energy increase as a floating-point number. For example, a valid output format is \"[0.0,0.00123,0.045,0.12]\". Angles are not used in this task. The outputs are dimensionless decimals without units.\n\nConstraints and expectations:\n- Derive your discrete updates from the provided fundamental conservation law for flux linkage and the Newmark method definitions; do not use any other shortcut formulas.\n- Ensure the Newton iteration for Scheme A converges to a tight tolerance so that energy behavior is representative of the method and not numerical error.\n- The simulation must be self-contained and deterministic for the provided parameters.", "solution": "The problem requires the simulation of a lumped-parameter electromagnetic–structural system under two different time-integration schemes. The primary objective is to quantify the numerical energy conservation properties of each scheme. The analysis begins with the continuous model, which serves as the ground truth, and proceeds to the discrete implementation and comparison.\n\nThe system's state is described by the mechanical displacement $x(t)$ and velocity $v(t)$, and the electrical current $I(t)$. The core physical principles are the conservation of magnetic flux linkage and Newton's second law of motion.\n\nFor the electrical subsystem, with zero resistance and no voltage source, the governing equation is the conservation of flux linkage $\\psi(t)$:\n$$\n\\frac{d\\psi}{dt} = 0 \\implies \\psi(t) = L(x(t))\\,I(t) = \\text{constant}\n$$\nThe magnetic co-energy, which for a linear magnetic circuit equals the stored magnetic energy, is $W_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2$. The electromagnetic force exerted on the mechanical part is derived from this co-energy:\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{\\partial W_{\\mathrm{m}}}{\\partial x} = \\frac{1}{2} I^2 \\frac{dL}{dx}(x)\n$$\nFor the mechanical subsystem, a single-degree-of-freedom linear oscillator, the equation of motion is:\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t))\n$$\nThe total energy of the continuous system is the sum of the mechanical kinetic energy, mechanical potential (elastic) energy, and the magnetic energy:\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2\n$$\nIn the continuous domain, this total energy is exactly conserved. The rate of change of total energy is $\\frac{dE}{dt} = m\\,v\\,\\dot{v} + k\\,x\\,\\dot{x} + \\frac{1}{2}\\frac{dL}{dx}\\dot{x}\\,I^2 + L\\,I\\,\\frac{dI}{dt}$. With $\\dot{x}=v$, $\\ddot{x}=\\dot{v}$, and $\\psi = L\\,I$ being constant, we have $\\frac{dI}{dt} = -\\frac{I}{L}\\frac{dL}{dt} = -\\frac{I}{L}\\frac{dL}{dx}\\dot{x}$. Substituting these into the energy derivative gives $\\frac{dE}{dt} = v(m\\ddot{x} + kx) + \\frac{1}{2}v\\frac{dL}{dx}I^2 + L\\,I(-\\frac{I}{L}\\frac{dL}{dx}v) = v(F_{em}) + vF_{em} - vF_{em} = vF_{em}$, which is not zero. Let's re-evaluate. $F_{em} = \\frac{1}{2}I^2 \\frac{dL}{dx}$. So $\\frac{dE}{dt} = v(m\\ddot{x} + kx) + \\frac{1}{2}v\\frac{dL}{dx}I^2 + L\\,I(-\\frac{I}{L}\\frac{dL}{dx}v) = v(F_{em}) + \\frac{1}{2}v\\frac{dL}{dx}I^2 - vI^2\\frac{dL}{dx} = v F_{em} - \\frac{1}{2}v I^2 \\frac{dL}{dx} = v F_{em} - v F_{em} = 0$. The conservation is confirmed.\n\nThe task is to discretize this system using two schemes and compare their energy behavior. Both schemes use the Newmark family of integrators for the mechanical part with parameters $\\beta = 1/4$ and $\\gamma = 1/2$, which corresponds to the trapezoidal rule, known for its favorable energy conservation properties in linear systems. The distinction lies in how the electromagnetic and mechanical parts are coupled.\n\n**Scheme A: Power-Consistent FDTD–Newmark Coupling**\nThis scheme is designed to respect the power conjugacy between the two physical domains at the discrete level, which is a prerequisite for discrete energy conservation. The flux linkage is held constant, $\\psi^{n+1} = \\psi^n = \\psi$, mirroring the continuous invariant. This implies $I(x) = \\psi / L(x)$. The acceleration becomes a nonlinear function of displacement alone:\n$$\na(x) = \\frac{1}{m}\\left( F_{\\mathrm{em}}(x, I(x)) - k\\,x \\right) = \\frac{1}{m}\\left(\\frac{1}{2} \\left(\\frac{\\psi}{L(x)}\\right)^2 \\frac{dL}{dx}(x) - k\\,x\\right)\n$$\nWith the specified inductance $L(x) = L_0 + \\alpha x$ and its derivative $\\frac{dL}{dx} = \\alpha$, this is:\n$$\na(x) = \\frac{1}{m}\\left(\\frac{\\alpha \\psi^2}{2(L_0 + \\alpha x)^2} - k\\,x\\right)\n$$\nThe Newmark trapezoidal rule update for displacement $x^{n+1}$ is implicit and nonlinear:\n$$\nx^{n+1} = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\nThis can be written as a root-finding problem $g(x^{n+1}) = 0$, where:\n$$\ng(z) = z - \\frac{\\Delta t^2}{4}\\,a(z) - \\left(x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n})\\right) = 0\n$$\nThis nonlinear algebraic equation is solved at each time step using Newton's method. The iterative update for the root $z$ is $z_{k+1} = z_k - g(z_k)/g'(z_k)$, where $g'(z) = 1 - \\frac{\\Delta t^2}{4}a'(z)$ and $a'(z) = \\frac{1}{m}(-\\frac{\\alpha^2\\psi^2}{(L_0+\\alpha z)^3} - k)$. A tight convergence tolerance is used to ensure the numerical solution accurately reflects the properties of the scheme itself.\nOnce $x^{n+1}$ is found, the velocity and current are updated:\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n$$\nI^{n+1} = \\frac{\\psi}{L(x^{n+1})}\n$$\nThis monolithic approach, where the full coupled system is solved implicitly, is expected to yield excellent energy conservation.\n\n**Scheme B: Inconsistent, Frozen-Current Coupling**\nThis scheme represents a common but flawed simplification. Instead of enforcing the flux invariant, the current is \"frozen\" over the time step, $I^{n+1} = I^n$. The electromagnetic force is calculated at the beginning of the step, $F_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n)$, and treated as a constant external force throughout the interval $[t^n, t^{n+1}]$.\nThe equation of motion becomes linear within the step: $m a^{n+1} + k x^{n+1} = F_{\\mathrm{em}}^n$. The Newmark update for displacement is:\n$$\nx^{n+1} = x^{n} + \\Delta t v^{n} + \\frac{\\Delta t^2}{4}(a^n + a^{n+1})\n$$\nSubstituting $a^n = (F_{\\mathrm{em}}^n - kx^n)/m$ and $a^{n+1} = (F_{\\mathrm{em}}^n - kx^{n+1})/m$ and solving for $x^{n+1}$ yields the explicit update rule provided in the problem, which simplifies to:\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4m}(2F_{\\mathrm{em}}^{n} - k\\, x^{n})}{1 + \\frac{k \\Delta t^2}{4m}}\n$$\nThe velocity is then updated using the trapezoidal rule:\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right)\n$$\nThis staggered or explicit coupling breaks the discrete power balance. The work done by the force $F_{\\mathrm{em}}^n$ on the mechanical system is not correctly sourced from the change in stored magnetic energy, leading to an artificial gain or loss of total system energy, which typically manifests as numerical instability or unphysical energy growth.\n\nThe implementation calculates the total discrete energy $E^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2$ at each step for both schemes. The metric for comparison is the maximum fractional energy increase over the simulation horizon, $\\max_{n} ((E^n - E^0)/E^0)$, where $E^0$ is the initial energy. This metric quantifies the degree of artificial energy growth introduced by the numerical scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetic-structural coupling problem for four test cases\n    and prints the maximum fractional energy increase for each.\n    \"\"\"\n    # Common physical parameters (SI units)\n    M = 0.05  # mass (kg)\n    K = 200.0  # stiffness (N/m)\n    L0 = 0.001  # base inductance (H)\n    ALPHA = 0.02  # inductance gradient (H/m)\n    \n    # Initial conditions\n    X0 = 0.0  # initial displacement (m)\n    V0 = 0.0  # initial velocity (m/s)\n    I0 = 20.0  # initial current (A)\n    \n    # Time horizon\n    T_HORIZON = 0.01  # s\n\n    # Define inductance and its derivative\n    def L_func(x):\n        return L0 + ALPHA * x\n    \n    def dLdx_func(x):\n        return ALPHA\n\n    def calculate_energy(x, v, i):\n        return 0.5 * M * v**2 + 0.5 * K * x**2 + 0.5 * L_func(x) * i**2\n\n    def run_simulation(scheme, dt):\n        \"\"\"\n        Runs the time-domain simulation for a given scheme and time step.\n\n        Args:\n            scheme (str): 'A' or 'B' specifying the coupling scheme.\n            dt (float): The time step size.\n\n        Returns:\n            float: The maximum fractional energy increase.\n        \"\"\"\n        x_n, v_n, i_n = X0, V0, I0\n        \n        e0 = calculate_energy(x_n, v_n, i_n)\n        if e0 == 0:  # Avoid division by zero, though not expected here\n            return 0.0\n            \n        max_energy_frac_inc = 0.0\n        n_steps = int(round(T_HORIZON / dt))\n\n        if scheme == 'A':\n            psi = L_func(x_n) * i_n\n            newton_tol = 1e-14\n            max_newton_iter = 20\n            \n            def accel(x):\n                L_val = L_func(x)\n                if L_val <= 0: return np.inf # To prevent division by zero in extreme cases\n                fem = 0.5 * (psi**2 / L_val**2) * dLdx_func(x)\n                return (fem - K * x) / M\n\n            def accel_deriv(x):\n                L_val = L_func(x)\n                if L_val <= 0: return np.inf\n                fem_deriv = -1.0 * (psi**2 * ALPHA**2) / (L_val**3)\n                return (fem_deriv - K) / M\n\n            for _ in range(n_steps):\n                a_n = accel(x_n)\n                \n                # Newton-Raphson solver for x_{n+1}\n                c_const = x_n + dt * v_n + (dt**2 / 4.0) * a_n\n                x_np1_guess = x_n\n                \n                for _ in range(max_newton_iter):\n                    g = x_np1_guess - (dt**2 / 4.0) * accel(x_np1_guess) - c_const\n                    g_prime = 1.0 - (dt**2 / 4.0) * accel_deriv(x_np1_guess)\n                    if abs(g_prime) < 1e-15: # Avoid division by zero\n                        break\n                    delta_x = -g / g_prime\n                    x_np1_guess += delta_x\n                    if abs(delta_x) < newton_tol:\n                        break\n                \n                x_np1 = x_np1_guess\n                a_np1 = accel(x_np1)\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = psi / L_func(x_np1)\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n                \n                x_n, v_n = x_np1, v_np1\n        \n        elif scheme == 'B':\n            for _ in range(n_steps):\n                fem_n = 0.5 * i_n**2 * dLdx_func(x_n)\n                \n                # Explicit update for x_{n+1}\n                numerator = x_n + dt * v_n + (dt**2 / (4.0 * M)) * (2 * fem_n - K * x_n)\n                denominator = 1.0 + (K * dt**2) / (4.0 * M)\n                x_np1 = numerator / denominator\n                \n                a_n = (fem_n - K * x_n) / M\n                a_np1 = (fem_n - K * x_np1) / M\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = i_n\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n\n                x_n, v_n, i_n = x_np1, v_np1, i_np1\n                \n        return max_energy_frac_inc\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('A', 0.0001),  # Case 1\n        ('A', 0.0005),  # Case 2\n        ('B', 0.0001),  # Case 3\n        ('B', 0.0005),  # Case 4\n    ]\n\n    results = []\n    for scheme, dt in test_cases:\n        result = run_simulation(scheme, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3304517"}, {"introduction": "Beyond stability, the accuracy of a simulation is crucial, especially when using computationally convenient partitioned (or staggered) schemes where each physics is solved sequentially. This approach introduces an inherent time lag, or latency, which can compromise simulation fidelity. This exercise [@problem_id:3304465] employs a simplified yet insightful model of a membrane antenna to analytically and numerically quantify the phase error introduced by such a time lag, highlighting the critical trade-offs between algorithmic complexity and accuracy in modern multiphysics problems.", "problem": "Consider a one-degree-of-freedom model of a thin membrane antenna undergoing electromagnetic–structural coupling. An incident time-harmonic electromagnetic plane wave in vacuum with wavelength $\\lambda$ impinges normally on the membrane, which reflects the wave. The membrane displacement $u(t)$ along the wave propagation direction modulates the reflected electromagnetic phase via the path length change. Assume small displacement such that geometric nonlinearities can be neglected, and approximate the reflected electric field at a fixed probe point by\n$$\nE(t) = E_0 \\cos\\!\\big(\\omega_e t - \\phi(t)\\big), \\quad \\phi(t) = 2 k_0 u(t), \\quad k_0 = \\frac{2\\pi}{\\lambda},\n$$\nwhere $E_0$ is the incident field amplitude and $\\omega_e$ is the electromagnetic angular frequency. The factor $2$ in $\\phi(t)$ accounts for the round-trip path change in reflection. The structural dynamics of the membrane’s dominant mode are modeled by the linear mass–spring–damper equation\n$$\nm \\ddot{u}(t) + c \\dot{u}(t) + k u(t) = F(t),\n$$\nwhere $m$ is the modal mass, $c$ is the modal damping coefficient, $k$ is the modal stiffness, and $F(t)$ is the generalized forcing due to radiation pressure. To isolate the effect of coupling latency and achieve analytical tractability, use a radiation pressure forcing of the form\n$$\nF(t) = A_{\\mathrm{eff}}\\, p_m \\cos(\\omega_m t),\n$$\nwhere $A_{\\mathrm{eff}}$ is an effective area that projects the distributed pressure to the mode, $p_m$ is the amplitude of the radiation pressure, and $\\omega_m$ is the mechanical forcing angular frequency. For a thin reflective membrane under a time-harmonic electromagnetic illumination, this $p_m$ can be interpreted as the amplitude of a modulated Maxwell stress; the modulation at frequency $\\omega_m$ is assumed to be externally set by the feed and is consistent with scientific realism for radio-frequency antennas.\n\nDefine two coupling strategies:\n- Monolithic coupling: the electromagnetic phase uses the instantaneous membrane displacement, $\\phi_{\\mathrm{mono}}(t) = 2 k_0 u(t)$.\n- Partitioned explicit coupling with time lag $\\Delta t$: the electromagnetic phase uses the time-lagged displacement, $\\phi_{\\mathrm{part}}(t) = 2 k_0 u(t-\\Delta t)$.\n\nThe phase error attributed to partitioned coupling is the difference in instantaneous electromagnetic phase used by the electromagnetic solver versus the monolithic solver,\n$$\n\\Delta \\phi(t) = \\phi_{\\mathrm{mono}}(t) - \\phi_{\\mathrm{part}}(t) = 2 k_0 \\big(u(t) - u(t-\\Delta t)\\big).\n$$\n\nAssume steady-state response under harmonic forcing. The structural steady-state displacement is\n$$\nu(t) = U \\cos(\\omega_m t - \\theta_u),\n$$\nwith amplitude\n$$\nU = \\frac{A_{\\mathrm{eff}}\\, p_m}{\\sqrt{\\big(k - m \\omega_m^2\\big)^2 + \\big(c\\, \\omega_m\\big)^2}},\n$$\nand phase $\\theta_u$ given by\n$$\n\\theta_u = \\arctan\\!\\left(\\frac{c\\, \\omega_m}{k - m \\omega_m^2}\\right).\n$$\nQuantify the phase error using the Root Mean Square (RMS) measure over one mechanical period,\n$$\n\\Delta \\phi_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{T_m} \\int_0^{T_m} \\big(\\Delta \\phi(t)\\big)^2 \\, dt}, \\quad T_m = \\frac{2\\pi}{\\omega_m}.\n$$\n\nTasks:\n1. Starting from Maxwell’s equations and the definition of the Maxwell stress tensor, justify the radiation pressure forcing model and the phase modulation relation $\\,\\phi(t)=2 k_0 u(t)\\,$ for normal incidence and small $u(t)$.\n2. Starting from the mass–spring–damper equation, derive the steady-state displacement amplitude $U$ under harmonic forcing $F(t)=A_{\\mathrm{eff}}\\, p_m \\cos(\\omega_m t)$.\n3. Using the above, derive an explicit formula for $\\Delta \\phi_{\\mathrm{RMS}}$ in terms of the parameters $m$, $c$, $k$, $A_{\\mathrm{eff}}$, $p_m$, $\\omega_m$, $\\lambda$, and $\\Delta t$.\n4. Implement a program that computes $\\Delta \\phi_{\\mathrm{RMS}}$ for each test case below.\n\nAll quantities are in SI units unless stated. The final answers must be expressed in radians. Angles are in radians.\n\nTest suite:\n- Case 1 (happy path, off-resonance, small lag): $m=0.01$, $c=0.2$, $f_n=500$ Hz (use $k = m (2\\pi f_n)^2$), $A_{\\mathrm{eff}}=0.01$, $p_m=1$ Pa, $f_m=400$ Hz (use $\\omega_m = 2\\pi f_m$), $\\lambda = 3\\times 10^{-3}$ m, $\\Delta t = 5\\times 10^{-4}$ s.\n- Case 2 (boundary, zero lag): same as Case 1 but $\\Delta t = 0$ s.\n- Case 3 (near resonance, strong radiation pressure, quarter-period lag): $m=0.01$, $c=0.05$, $f_n=500$ Hz, $A_{\\mathrm{eff}}=0.01$, $p_m=5$ Pa, $f_m=500$ Hz, $\\lambda = 3\\times 10^{-3}$ m, $\\Delta t = T_m/4$, where $T_m = 1/f_m$.\n- Case 4 (near resonance, stronger radiation pressure, half-period lag): $m=0.01$, $c=0.1$, $f_n=500$ Hz, $A_{\\mathrm{eff}}=0.01$, $p_m=10$ Pa, $f_m=500$ Hz, $\\lambda = 3\\times 10^{-3}$ m, $\\Delta t = T_m/2$, where $T_m = 1/f_m$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the computed $\\Delta \\phi_{\\mathrm{RMS}}$ for the corresponding test case, rounded to six decimal places.", "solution": "This solution addresses the derivation tasks outlined in the problem. First, we justify the physical model assumptions. Then, we derive the steady-state displacement amplitude $U$. Finally, we derive the explicit formula for the root-mean-square (RMS) phase error, $\\Delta \\phi_{\\mathrm{RMS}}$.\n\n### Justification of Physical Models\n\n*   **Phase Modulation $\\phi(t) = 2 k_0 u(t)$**: For a plane wave at normal incidence on a reflective membrane located at position $z=u(t)$, the round-trip path length changes by $2u(t)$ compared to a fixed mirror at $z=0$. The corresponding phase shift is the path length difference multiplied by the wave number $k_0 = 2\\pi/\\lambda$. Therefore, the phase modulation is correctly modeled as $\\phi(t) = k_0 \\cdot (2u(t)) = 2 k_0 u(t)$.\n\n*   **Radiation Pressure Forcing $F(t) = A_{\\mathrm{eff}}\\, p_m \\cos(\\omega_m t)$**: The force from an electromagnetic field is given by the Maxwell stress tensor. For a perfectly reflecting surface at normal incidence, the time-averaged pressure is $P = 2 \\langle u_{em} \\rangle = \\epsilon_0 E_{inc}^2$, where $\\langle u_{em} \\rangle$ is the average energy density and $E_{inc}$ is the incident electric field amplitude. If the incident field's amplitude is modulated at a mechanical frequency $\\omega_m$, for example as $E_{0,mod}(t) = E_0(1 + M \\cos(\\omega_m t))$, the resulting pressure (proportional to $E_{0,mod}^2(t)$) will contain a harmonic component at $\\omega_m$. The forcing term $F(t) = A_{\\mathrm{eff}}\\, p_m \\cos(\\omega_m t)$ represents the generalized force corresponding to this fundamental harmonic of the modulated radiation pressure, a standard and valid simplification for analyzing the driven response.\n\n### Derivation of Steady-State Displacement Amplitude $U$\n\nThe equation of motion is a standard forced, damped harmonic oscillator:\n$$m \\ddot{u}(t) + c \\dot{u}(t) + k u(t) = F_0 \\cos(\\omega_m t)$$\nwhere $F_0 = A_{\\mathrm{eff}} p_m$. Using complex phasors, we let the forcing be $\\tilde{F}(t) = F_0 e^{i\\omega_m t}$ and seek a solution $\\tilde{u}(t) = \\tilde{U} e^{i\\omega_m t}$. Substituting into the differential equation gives:\n$$(-m\\omega_m^2 + i c\\omega_m + k) \\tilde{U} = F_0$$\nThe complex amplitude is:\n$$\\tilde{U} = \\frac{F_0}{(k - m\\omega_m^2) + i(c\\omega_m)}$$\nThe real amplitude $U$ is the magnitude of $\\tilde{U}$:\n$$U = |\\tilde{U}| = \\frac{F_0}{\\sqrt{(k - m\\omega_m^2)^2 + (c\\omega_m)^2}}$$\nThis matches the formula given in the problem statement.\n\n### Derivation of RMS Phase Error $\\Delta \\phi_{\\mathrm{RMS}}$\n\nThe instantaneous phase error is $\\Delta \\phi(t) = 2 k_0 (u(t) - u(t-\\Delta t))$. With $u(t) = U \\cos(\\omega_m t - \\theta_u)$, the error becomes:\n$$\\Delta \\phi(t) = 2 k_0 U \\left[ \\cos(\\omega_m t - \\theta_u) - \\cos(\\omega_m t - \\theta_u - \\omega_m \\Delta t) \\right]$$\nUsing the identity $\\cos(A) - \\cos(B) = -2 \\sin(\\frac{A+B}{2}) \\sin(\\frac{A-B}{2})$, we get:\n$$\\Delta \\phi(t) = -4 k_0 U \\sin\\left(\\frac{\\omega_m \\Delta t}{2}\\right) \\sin\\left(\\omega_m t - \\theta_u - \\frac{\\omega_m \\Delta t}{2}\\right)$$\nThis shows that the phase error is a sinusoidal function of time. The RMS value of a sine wave $A \\sin(\\omega t + \\phi_{shift})$ is $A/\\sqrt{2}$. Here, the amplitude is $A = \\left| -4 k_0 U \\sin\\left(\\frac{\\omega_m \\Delta t}{2}\\right) \\right|$.\nThus, the RMS phase error is:\n$$\\Delta \\phi_{\\mathrm{RMS}} = \\frac{1}{\\sqrt{2}} \\left| -4 k_0 U \\sin\\left(\\frac{\\omega_m \\Delta t}{2}\\right) \\right| = 2\\sqrt{2} k_0 U \\left|\\sin\\left(\\frac{\\omega_m \\Delta t}{2}\\right)\\right|$$\nSubstituting the expressions for $k_0 = 2\\pi/\\lambda$ and the amplitude $U$:\n$$\\Delta \\phi_{\\mathrm{RMS}} = \\frac{4\\sqrt{2} \\pi A_{\\mathrm{eff}}\\, p_m}{\\lambda \\sqrt{(k - m\\omega_m^2)^2 + (c\\omega_m)^2}} \\left|\\sin\\left(\\frac{\\omega_m \\Delta t}{2}\\right)\\right|$$\nThis final explicit formula can be directly implemented to compute the phase error for the given test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetic-structural coupling problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"m\": 0.01, \"c\": 0.2, \"f_n\": 500, \"A_eff\": 0.01,\n            \"p_m\": 1.0, \"f_m\": 400, \"lambda\": 3e-3, \"delta_t_def\": (5e-4, \"s\")\n        },\n        {\n            \"name\": \"Case 2\",\n            \"m\": 0.01, \"c\": 0.2, \"f_n\": 500, \"A_eff\": 0.01,\n            \"p_m\": 1.0, \"f_m\": 400, \"lambda\": 3e-3, \"delta_t_def\": (0.0, \"s\")\n        },\n        {\n            \"name\": \"Case 3\",\n            \"m\": 0.01, \"c\": 0.05, \"f_n\": 500, \"A_eff\": 0.01,\n            \"p_m\": 5.0, \"f_m\": 500, \"lambda\": 3e-3, \"delta_t_def\": (1.0/4.0, \"Tm\")\n        },\n        {\n            \"name\": \"Case 4\",\n            \"m\": 0.01, \"c\": 0.1, \"f_n\": 500, \"A_eff\": 0.01,\n            \"p_m\": 10.0, \"f_m\": 500, \"lambda\": 3e-3, \"delta_t_def\": (1.0/2.0, \"Tm\")\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters from the case dictionary\n        m = case[\"m\"]\n        c = case[\"c\"]\n        f_n = case[\"f_n\"]\n        A_eff = case[\"A_eff\"]\n        p_m = case[\"p_m\"]\n        f_m = case[\"f_m\"]\n        lam = case[\"lambda\"]\n        delta_t_val, delta_t_type = case[\"delta_t_def\"]\n\n        # Calculate intermediate quantities\n        omega_n = 2 * np.pi * f_n\n        omega_m = 2 * np.pi * f_m\n        k = m * omega_n**2\n\n        # Calculate delta_t based on its definition\n        if delta_t_type == \"s\":\n            delta_t = delta_t_val\n        elif delta_t_type == \"Tm\":\n            T_m = 1.0 / f_m\n            delta_t = delta_t_val * T_m\n\n        # Calculate delta_phi_rms using the derived formula\n        # delta_phi_rms = (4 * sqrt(2) * pi * A_eff * p_m) / \n        #                 (lambda * sqrt((k - m*omega_m^2)^2 + (c*omega_m)^2)) * \n        #                 |sin(omega_m * delta_t / 2)|\n        \n        # Denominator of the mechanical response part\n        denom_mech = np.sqrt((k - m * omega_m**2)**2 + (c * omega_m)**2)\n        \n        # Sine term related to the time lag\n        sin_term = np.abs(np.sin(omega_m * delta_t / 2.0))\n        \n        # Numerator of the main formula\n        numerator = 4 * np.sqrt(2) * np.pi * A_eff * p_m\n        \n        # Combine parts to get the final result\n        if denom_mech == 0:\n            # Handle potential division by zero, although not expected with damping\n            delta_phi_rms = np.inf\n        else:\n            delta_phi_rms = (numerator / (lam * denom_mech)) * sin_term\n\n        # Round the result to six decimal places as required\n        results.append(round(delta_phi_rms, 6))\n\n    # Print the results in the specified single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3304465"}]}