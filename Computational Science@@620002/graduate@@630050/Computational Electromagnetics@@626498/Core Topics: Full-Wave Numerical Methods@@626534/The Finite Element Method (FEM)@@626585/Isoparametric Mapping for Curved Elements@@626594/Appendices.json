{"hands_on_practices": [{"introduction": "To build a solid understanding of isoparametric elements, we begin with the most fundamental operation: transforming a single point from the reference domain to the physical domain. This exercise will guide you through the direct application of the mapping formula using quadratic shape functions for a tetrahedron. By performing this calculation and comparing the result to that of a simpler linear element, you will gain a concrete appreciation for how mid-side nodes enable the accurate representation of curved geometries [@problem_id:3320941].", "problem": "Consider a curved quadratic isoparametric tetrahedral element used in the Finite Element Method (FEM) for solving Maxwell's equations in computational electromagnetics near a smooth, conducting boundary. The isoparametric mapping from the reference tetrahedron with local coordinates $(\\xi,\\eta,\\zeta)$ to physical space is defined by the Lagrange interpolation using nodal shape functions. Let the barycentric coordinates be $L_1 = \\xi$, $L_2 = \\eta$, $L_3 = \\zeta$, and $L_4 = 1 - \\xi - \\eta - \\zeta$, and let the quadratic tetrahedral shape functions be the standard $10$-node Lagrange polynomials:\n$$\nN_1 = L_1(2L_1 - 1),\\quad\nN_2 = L_2(2L_2 - 1),\\quad\nN_3 = L_3(2L_3 - 1),\\quad\nN_4 = L_4(2L_4 - 1),\n$$\n$$\nN_5 = 4L_1L_2,\\quad\nN_6 = 4L_2L_3,\\quad\nN_7 = 4L_3L_1,\\quad\nN_8 = 4L_1L_4,\\quad\nN_9 = 4L_2L_4,\\quad\nN_{10} = 4L_3L_4.\n$$\nThe physical coordinate mapping is\n$$\n\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i,\n$$\nwhere $\\{\\mathbf{x}_i\\}_{i=1}^{10}$ are the physical nodal coordinates of the curved element. The vertices are\n$$\n\\mathbf{x}_1 = (0,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_2 = (1,0,0)\\,\\text{m},\\quad\n\\mathbf{x}_3 = (0,1,0)\\,\\text{m},\\quad\n\\mathbf{x}_4 = (0,0,1)\\,\\text{m},\n$$\nand the midside nodes are\n$$\n\\mathbf{x}_5 = \\left(\\frac{1}{2},0,\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_6 = \\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_7 = \\left(0,\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{m},\n$$\n$$\n\\mathbf{x}_8 = \\left(0,0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_9 = \\left(\\frac{1}{2},0,\\frac{1}{2}\\right)\\,\\text{m},\\quad\n\\mathbf{x}_{10} = \\left(0,\\frac{1}{2},\\frac{1}{2}\\right)\\,\\text{m}.\n$$\nThese midside node placements on the face $1$-$2$-$3$ represent a smooth inward bulge (curved boundary), while the edges connected to node $4$ remain straight.\n\nCompute the physical coordinate vector $\\mathbf{x}$ at the parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$. Express the three components of $\\mathbf{x}$ in meters. Use exact values; no rounding is necessary. Then, interpret the result in terms of boundary curvature fidelity, comparing qualitatively to what would be obtained with a linear ($4$-node) tetrahedral mapping at the same parameter point.", "solution": "The problem requires the computation of the physical coordinates $\\mathbf{x} = (x,y,z)$ within a quadratic isoparametric tetrahedral element at a specific local parameter point $(\\xi,\\eta,\\zeta)$, and a subsequent qualitative analysis comparing the result to a linear element approximation.\n\n### Step 1: Problem Validation\nThe problem statement provides a complete and consistent set of givens for an isoparametric mapping calculation.\n- **Givens**:\n    - Local coordinates: $(\\xi, \\eta, \\zeta)$.\n    - Barycentric coordinates: $L_1 = \\xi$, $L_2 = \\eta$, $L_3 = \\zeta$, $L_4 = 1 - \\xi - \\eta - \\zeta$.\n    - Quadratic shape functions $N_i$ for $i=1, \\dots, 10$.\n    - Isoparametric mapping formula: $\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i$.\n    - Nodal coordinates $\\{\\mathbf{x}_i\\}_{i=1}^{10}$.\n    - Parameter point for evaluation: $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$.\n- **Validation**:\n    - The problem is **scientifically grounded** in the Finite Element Method (FEM), a standard and well-established numerical technique in computational science and engineering.\n    - The provided shape functions are the standard 10-node Lagrange polynomials for a quadratic tetrahedron.\n    - The nodal coordinates are well-defined, creating a specific curved geometry. The description of \"inward bulge\" for the face $1-2-3$ (which lies in the plane $z=0$ for a linear element) with midside nodes at a positive $z$-coordinate is accurate, as it describes a bulge into the tetrahedron's volume (assuming the interior is where $L_4 > 0$).\n    - The problem is **well-posed**: all necessary information is provided, and the task leads to a unique, meaningful solution.\n    - The language is **objective** and precise.\n\n- **Verdict**: The problem is valid.\n\n### Step 2: Computation of Physical Coordinates\n\nThe first step is to evaluate the barycentric coordinates $L_i$ at the given parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$.\n$$\nL_1 = \\xi = \\frac{1}{4}\n$$\n$$\nL_2 = \\eta = \\frac{1}{4}\n$$\n$$\nL_3 = \\zeta = \\frac{1}{4}\n$$\n$$\nL_4 = 1 - \\xi - \\eta - \\zeta = 1 - \\frac{1}{4} - \\frac{1}{4} - \\frac{1}{4} = \\frac{1}{4}\n$$\nThe evaluation point is the barycenter of the reference tetrahedron.\n\nNext, we evaluate the 10 quadratic shape functions $N_i$ at this point.\nFor the vertex nodes ($i=1,2,3,4$):\n$$\nN_i = L_i(2L_i - 1) = \\frac{1}{4}\\left(2\\left(\\frac{1}{4}\\right) - 1\\right) = \\frac{1}{4}\\left(\\frac{1}{2} - 1\\right) = \\frac{1}{4}\\left(-\\frac{1}{2}\\right) = -\\frac{1}{8}\n$$\nSo, $N_1 = N_2 = N_3 = N_4 = -\\frac{1}{8}$.\n\nFor the midside nodes ($i=5, \\dots, 10$):\nThe general form is $N_{ij} = 4L_iL_j$.\n$$\nN_5 = 4L_1L_2 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_6 = 4L_2L_3 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_7 = 4L_3L_1 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_8 = 4L_1L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_9 = 4L_2L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_{10} = 4L_3L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\nAs a consistency check, the sum of the shape functions must be unity: $\\sum_{i=1}^{10} N_i = 4\\left(-\\frac{1}{8}\\right) + 6\\left(\\frac{1}{4}\\right) = -\\frac{1}{2} + \\frac{3}{2} = 1$. The values are correct.\n\nFinally, we compute the physical coordinate vector $\\mathbf{x} = \\sum_{i=1}^{10} N_i \\mathbf{x}_i$. Let $\\mathbf{x} = (x,y,z)$. We compute each component separately.\nThe nodal coordinates are:\n$\\mathbf{x}_1 = (0,0,0)$, $\\mathbf{x}_2 = (1,0,0)$, $\\mathbf{x}_3 = (0,1,0)$, $\\mathbf{x}_4 = (0,0,1)$.\n$\\mathbf{x}_5 = (\\frac{1}{2},0,\\frac{1}{8})$, $\\mathbf{x}_6 = (\\frac{1}{2},\\frac{1}{2},\\frac{1}{8})$, $\\mathbf{x}_7 = (0,\\frac{1}{2},\\frac{1}{8})$.\n$\\mathbf{x}_8 = (0,0,\\frac{1}{2})$, $\\mathbf{x}_9 = (\\frac{1}{2},0,\\frac{1}{2})$, $\\mathbf{x}_{10} = (0,\\frac{1}{2},\\frac{1}{2})$.\n\nFor the $x$-component:\n$$\nx = \\sum_{i=1}^{10} N_i x_i = N_2 x_2 + N_5 x_5 + N_6 x_6 + N_9 x_9\n$$\n$$\nx = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nx = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\nFor the $y$-component:\n$$\ny = \\sum_{i=1}^{10} N_i y_i = N_3 y_3 + N_6 y_6 + N_7 y_7 + N_{10} y_{10}\n$$\n$$\ny = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\ny = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\nFor the $z$-component:\n$$\nz = \\sum_{i=1}^{10} N_i z_i = N_4 z_4 + N_5 z_5 + N_6 z_6 + N_7 z_7 + N_8 z_8 + N_9 z_9 + N_{10} z_{10}\n$$\n$$\nz = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nz = -\\frac{1}{8} + 3\\left(\\frac{1}{32}\\right) + 3\\left(\\frac{1}{8}\\right) = -\\frac{1}{8} + \\frac{3}{32} + \\frac{3}{8}\n$$\n$$\nz = \\frac{-4 + 3 + 12}{32} = \\frac{11}{32}\n$$\nThe physical coordinate vector is $\\mathbf{x} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$ meters.\n\n### Step 3: Qualitative Interpretation\n\nTo interpret this result, we compare it with the coordinate obtained from a linear ($4$-node) tetrahedral mapping. For a linear element, the mapping is defined solely by the vertices:\n$$\n\\mathbf{x}_{\\text{lin}}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{4} L_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i\n$$\nAt the same parameter point $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$, where $L_1 = L_2 = L_3 = L_4 = \\frac{1}{4}$:\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\mathbf{x}_1 + \\frac{1}{4}\\mathbf{x}_2 + \\frac{1}{4}\\mathbf{x}_3 + \\frac{1}{4}\\mathbf{x}_4\n$$\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\left[(0,0,0) + (1,0,0) + (0,1,0) + (0,0,1)\\right] = \\frac{1}{4}(1,1,1) = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{1}{4}\\right)\n$$\nThe linear mapping simply yields the physical centroid of the four vertices.\n\n**Comparison and Fidelity**:\n-   **Linear Element**: The linear element produces a physical element with straight edges and flat faces. It maps the reference tetrahedron's barycenter to the physical barycenter of the vertices, $\\mathbf{x}_{\\text{lin}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{8}{32}\\right)$. This constitutes a first-order, or piecewise linear, approximation of the geometry. If the actual boundary is curved, the linear element can only represent it as a collection of flat facets, leading to a \"staircase\" approximation that introduces geometrical error.\n\n-   **Quadratic Element**: The quadratic element uses midside nodes to define a higher-order, curved geometry. The resulting coordinate is $\\mathbf{x}_{\\text{quad}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$. The $x$ and $y$ components are identical to the linear case, but the $z$ component is different: $z_{\\text{quad}} = \\frac{11}{32}$ versus $z_{\\text{lin}} = \\frac{8}{32}$. The displacement $\\Delta z = \\frac{3}{32}$ is a direct consequence of the midside nodes being shifted from their straight-edge positions. Specifically, the midside nodes $\\mathbf{x}_5, \\mathbf{x}_6, \\mathbf{x}_7$ on the face that would otherwise be at $z=0$ were given a positive $z$-component of $\\frac{1}{8}$, creating a curved surface that bulges into the element's volume.\n\n-   **Conclusion**: The quadratic isoparametric element provides superior boundary curvature fidelity. It allows the finite element mesh to conform smoothly and accurately to curved boundaries, which is crucial for problems in computational electromagnetics where boundary conditions on conducting surfaces must be enforced precisely. A linear element's geometric inaccuracy can lead to significant errors in the computed fields, surface currents, and scattering parameters, whereas the quadratic element's ability to model curvature drastically improves the solution's accuracy.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  \\frac{11}{32}\n\\end{pmatrix}\n}\n$$", "id": "3320941"}, {"introduction": "While an isoparametric mapping allows us to model complex shapes, not all mappings are created equal. Distorted elements can significantly degrade the accuracy of a finite element simulation. This practice moves beyond a single point to analyze the quality of the entire element, introducing key metrics like skewness, aspect ratio, and the Jacobian determinant. By computationally linking these geometric measures to errors in field interpolation and numerical integration, you will develop a practical intuition for why maintaining high element quality is critical for obtaining reliable results in computational science [@problem_id:3320978].", "problem": "Consider a two-dimensional isoparametric quadratic quadrilateral element with nine nodes defined on the reference square with coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$. The isoparametric mapping from the reference square to the physical element is constructed using the tensor-product quadratic Lagrange basis on the three-node set $\\{\\xi=-1,0,1\\}\\times\\{\\eta=-1,0,1\\}$, and the physical node coordinates $\\{\\mathbf{x}_i\\}_{i=1}^{9}$ are given for each test case. The Jacobian matrix $\\mathbf{J}(\\xi,\\eta)$ of the mapping is defined by the partial derivatives of the physical coordinates with respect to $(\\xi,\\eta)$ and its determinant is $\\det \\mathbf{J}(\\xi,\\eta)$. Let the analytic scalar field be $f(x,y)=\\sin(\\pi x)\\cos(\\pi y)$, treated as dimensionless.\n\nStarting from the fundamental definitions of isoparametric mapping, metric tensors, and Gaussian quadrature rules, implement a program that, for each test case, computes the following distortion metrics and accuracy measures:\n\n1. Mean skewness $\\overline{s}$: For each sample point $(\\xi,\\eta)$, let $\\mathbf{a}=\\partial\\mathbf{x}/\\partial\\xi$ and $\\mathbf{b}=\\partial\\mathbf{x}/\\partial\\eta$ be the columns of $\\mathbf{J}$. Define the local skewness as $s=\\left|\\frac{\\mathbf{a}\\cdot\\mathbf{b}}{\\|\\mathbf{a}\\|\\|\\mathbf{b}\\|}\\right|$. Compute $\\overline{s}$ as the arithmetic mean of $s$ over an interior sampling grid of $n_s\\times n_s$ points, where $n_s$ is set to $7$. The angle is implicitly measured in radians via the cosine function.\n\n2. Mean aspect ratio $\\overline{r}$: At each sample point, compute the singular values $\\sigma_{\\max}$ and $\\sigma_{\\min}$ of $\\mathbf{J}$ and define $r=\\sigma_{\\max}/\\sigma_{\\min}$. Compute $\\overline{r}$ as the arithmetic mean of $r$ over the same sampling grid.\n\n3. Minimum Jacobian determinant $\\min_{\\text{samples}} \\det \\mathbf{J}$: Evaluate $\\det \\mathbf{J}$ on the sampling grid and report its minimum value over the sampled points (do not take the absolute value).\n\n4. Field interpolation $L^2$-error: Using the same quadratic Lagrange basis used for the geometric mapping, form the isoparametric interpolation $f_h(\\xi,\\eta)=\\sum_{i=1}^{9}N_i(\\xi,\\eta) f(\\mathbf{x}_i)$, where $N_i$ are the shape functions and $\\mathbf{x}_i$ are the physical node coordinates. Compute the $L^2$-norm of the interpolation error over the physical element,\n$$\n\\|f-f_h\\|_{L^2(\\Omega_e)}=\\left(\\int_{\\Omega_e} (f-f_h)^2 \\, d\\Omega\\right)^{1/2},\n$$\nby transforming to the reference domain and approximating the integral with tensor-product Gaussian quadrature of order $q_h=7$ using the absolute value $\\left|\\det \\mathbf{J}\\right|$ as the measure factor under the mapping.\n\n5. Integration accuracy: Compute the integral $I=\\int_{\\Omega_e} f \\, d\\Omega$ with tensor-product Gaussian quadrature of order $q_\\ell=3$, and a reference value $I_{\\text{ref}}$ with order $q_h=7$, both using the absolute value $\\left|\\det \\mathbf{J}\\right|$. Report the absolute integration error $|I-I_{\\text{ref}}|$.\n\nUse sampling points that exclude the boundary by placing the $n_s$ points uniformly within $(-1,1)$ on each axis at positions $\\xi_i=-1+\\frac{2i}{n_s+1}$ and $\\eta_j=-1+\\frac{2j}{n_s+1}$ for $i,j\\in\\{1,\\dots,n_s\\}$.\n\nRelate the distortion metrics to the accuracy measures by computing all quantities and returning numerical values for each test case. Larger skewness and aspect ratio typically indicate higher distortion and are expected to correlate with larger interpolation and integration errors.\n\nTest Suite (each test case provides the nine physical nodes in row-major order corresponding to $(\\xi,\\eta)\\in\\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$):\n\n- Test Case $1$ (mildly curved, nearly rectangular):\n$\\left[\n(0.0,0.0),\\,\n(1.0,-0.03),\\,\n(2.0,0.05),\\,\n(-0.02,0.5),\\,\n(1.02,0.52),\\,\n(2.03,0.5),\\,\n(0.0,1.0),\\,\n(1.0,1.03),\\,\n(2.0,1.05)\n\\right]$.\n\n- Test Case $2$ (skewed and moderately curved):\n$\\left[\n(0.0,0.0),\\,\n(1.0,0.10),\\,\n(2.0,0.3),\\,\n(0.03,0.42),\\,\n(1.07,0.57),\\,\n(2.08,0.68),\\,\n(0.1,0.8),\\,\n(1.12,0.97),\\,\n(2.1,1.1)\n\\right]$.\n\n- Test Case $3$ (thin and significantly curved):\n$\\left[\n(0.0,0.0),\\,\n(1.5,0.06),\\,\n(3.0,0.2),\\,\n(0.2,0.22),\\,\n(1.62,0.27),\\,\n(3.15,0.33),\\,\n(0.5,0.4),\\,\n(1.9,0.47),\\,\n(3.2,0.5)\n\\right]$.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list of five floating-point numbers in the order $\\left[\\overline{s},\\overline{r},\\min \\det \\mathbf{J},\\|f-f_h\\|_{L^2(\\Omega_e)},|I-I_{\\text{ref}}|\\right]$. For example, the output format is $\\left[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5] \\right]$, with all entries expressed as decimal numbers.", "solution": "The problem requires the computation of several distortion metrics and accuracy measures for a two-dimensional, nine-node isoparametric quadratic quadrilateral element. The analysis involves concepts from finite element methods, including isoparametric mapping, numerical integration using Gaussian quadrature, and error estimation. The full procedure is detailed below, beginning with fundamental definitions.\n\n### 1. Isoparametric Formulation\n\nThe core of the method is the isoparametric mapping, which uses the same set of basis functions (shape functions) to define the element's geometry and to interpolate a field over the element.\n\n#### 1.1. Reference Element and Shape Functions\nThe reference element is a square in the computational domain, defined by $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. For a nine-node quadratic element, the nodes are located at the tensor product of the points $\\{-1, 0, 1\\}$ on each axis.\n\nFirst, we define the one-dimensional quadratic Lagrange basis functions, $L_k(\\zeta)$, for a variable $\\zeta \\in [-1, 1]$ with nodes at $\\zeta \\in \\{-1, 0, 1\\}$.\nLet the nodal positions be $\\zeta_1 = -1$, $\\zeta_2 = 0$, and $\\zeta_3 = 1$. The basis functions are:\n- $L_1(\\zeta) = \\frac{(\\zeta - \\zeta_2)(\\zeta - \\zeta_3)}{(\\zeta_1 - \\zeta_2)(\\zeta_1 - \\zeta_3)} = \\frac{\\zeta(\\zeta - 1)}{(-1)(-2)} = \\frac{1}{2}\\zeta(\\zeta - 1)$\n- $L_2(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_3)}{(\\zeta_2 - \\zeta_1)(\\zeta_2 - \\zeta_3)} = \\frac{(\\zeta + 1)(\\zeta - 1)}{(1)(-1)} = 1 - \\zeta^2$\n- $L_3(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_2)}{(\\zeta_3 - \\zeta_1)(\\zeta_3 - \\zeta_2)} = \\frac{(\\zeta + 1)\\zeta}{(2)(1)} = \\frac{1}{2}\\zeta(\\zeta + 1)$\n\nThe two-dimensional shape functions $N_i(\\xi, \\eta)$ for the nine nodes are formed by the tensor product of these 1D functions. Given the specified row-major node ordering, if we have node indices $j,k \\in \\{1,2,3\\}$ for the $\\xi$ and $\\eta$ directions respectively, the global node index $i$ (from 1 to 9) and the corresponding shape function are given by $N_i(\\xi, \\eta) = L_j(\\xi) L_k(\\eta)$. For example, for node $i=5$ at $(\\xi, \\eta)=(0,0)$, the shape function is $N_5(\\xi, \\eta) = L_2(\\xi)L_2(\\eta) = (1-\\xi^2)(1-\\eta^2)$.\n\n#### 1.2. Geometric Mapping and Field Interpolation\nThe isoparametric mapping from the reference coordinates $(\\xi, \\eta)$ to the physical coordinates $\\mathbf{x} = (x, y)$ is given by:\n$$ \\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) \\mathbf{x}_i $$\nwhere $\\mathbf{x}_i = (x_i, y_i)$ are the coordinates of the $i$-th physical node.\n\nSimilarly, the scalar field $f(x, y)$ is interpolated over the element using the same shape functions:\n$$ f_h(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) f(\\mathbf{x}_i) $$\nwhere $f_h$ is the approximation of $f$ and $f(\\mathbf{x}_i)$ is the value of the true field at the physical node $i$.\n\n### 2. Jacobian Matrix and Distortion Metrics\n\nThe local distortion of the mapping is characterized by the Jacobian matrix $\\mathbf{J}$, which relates infinitesimal changes in reference coordinates to infinitesimal changes in physical coordinates.\n\n#### 2.1. Jacobian Matrix\nThe Jacobian matrix is defined as:\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} $$\nThe partial derivatives are found by differentiating the mapping equation:\n$$ \\frac{\\partial \\mathbf{x}}{\\partial \\xi} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\xi} \\mathbf{x}_i \\quad \\text{and} \\quad \\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\eta} \\mathbf{x}_i $$\nThe derivatives of the shape functions are required, e.g., $\\frac{\\partial N_i}{\\partial \\xi} = \\frac{d L_j(\\xi)}{d \\xi} L_k(\\eta)$.\n\n#### 2.2. Distortion Metrics\nThe problem asks for three metrics to be evaluated over an interior $n_s \\times n_s$ sampling grid, where $n_s=7$.\n1.  **Mean Skewness $\\overline{s}$**: The columns of $\\mathbf{J}$, $\\mathbf{a} = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}$ and $\\mathbf{b} = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}$, represent the mapped basis vectors. Skewness measures the deviation from orthogonality. The local skewness $s$ is the absolute value of the cosine of the angle between them:\n    $$ s(\\xi, \\eta) = \\left| \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|} \\right| $$\n    The mean skewness $\\overline{s}$ is the arithmetic average of $s$ over the sampling grid. A value of $0$ is ideal (orthogonal), while a value near $1$ indicates severe distortion.\n\n2.  **Mean Aspect Ratio $\\overline{r}$**: This metric measures the stretching of the element. It is defined as the ratio of the largest to the smallest singular values of the Jacobian matrix, $\\sigma_{\\max}$ and $\\sigma_{\\min}$:\n    $$ r(\\xi, \\eta) = \\frac{\\sigma_{\\max}(\\mathbf{J})}{\\sigma_{\\min}(\\mathbf{J})} $$\n    The mean aspect ratio $\\overline{r}$ is the arithmetic average of $r$ over the sampling grid. An ideal element has an aspect ratio of $1$.\n\n3.  **Minimum Jacobian Determinant $\\min \\det \\mathbf{J}$**: The determinant of the Jacobian, $\\det \\mathbf{J}$, is the local ratio of area in the physical domain to area in the reference domain. A non-positive determinant indicates a locally invalid (folded) mapping. We find the minimum value of $\\det \\mathbf{J}$ over the sampling grid.\n\n### 3. Accuracy Measures\n\nDistortion affects the accuracy of both field interpolation and numerical integration.\n\n#### 3.1. $L^2$-Error of Field Interpolation\nThe error in approximating the field $f$ by $f_h$ is measured by the $L^2$-norm of their difference over the physical element $\\Omega_e$:\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{\\Omega_e} (f(\\mathbf{x}) - f_h(\\mathbf{x}))^2 \\, d\\Omega \\right)^{1/2} $$\nTo compute this, we transform the integral to the reference element:\n$$ \\int_{\\Omega_e} g(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} g(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\nApplying this with $g = (f-f_h)^2$, the error norm becomes:\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{-1}^{1} \\int_{-1}^{1} (f(\\mathbf{x}(\\xi, \\eta)) - f_h(\\xi, \\eta))^2 |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta \\right)^{1/2} $$\nThis integral is approximated using a $q_h \\times q_h$ tensor-product Gaussian quadrature rule, where $q_h=7$. The formula for 2D Gaussian quadrature is:\n$$ \\int_{-1}^{1}\\int_{-1}^{1} G(\\xi, \\eta) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{q} \\sum_{k=1}^{q} w_j w_k G(\\xi_j, \\eta_k) $$\nwhere $(\\xi_j, \\eta_k)$ are the quadrature points and $(w_j, w_k)$ are the corresponding weights.\n\n#### 3.2. Integration Accuracy\nWe assess how element distortion affects the accuracy of numerical integration by comparing the integral of the field $f$ computed with two different quadrature orders. The integral is:\n$$ I = \\int_{\\Omega_e} f(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n- A low-accuracy integral, $I$, is computed using a low-order quadrature rule ($q_\\ell=3$).\n- A high-accuracy reference integral, $I_{\\text{ref}}$, is computed using a high-order rule ($q_h=7$).\nThe absolute integration error is then $|I - I_{\\text{ref}}|$.\n\n### 4. Computational Algorithm\nFor each test case (a set of 9 physical node coordinates $\\mathbf{x}_i$):\n1.  Define the $n_s \\times n_s = 7 \\times 7$ interior sampling grid.\n2.  Initialize accumulators for mean skewness, mean aspect ratio, and a variable for minimum Jacobian determinant.\n3.  Iterate over each point $(\\xi, \\eta)$ in the sampling grid:\n    a. Calculate the Jacobian matrix $\\mathbf{J}(\\xi, \\eta)$.\n    b. Compute local skewness $s$, aspect ratio $r$, and $\\det \\mathbf{J}$.\n    c. Update the accumulators and the minimum determinant.\n4.  Calculate the final mean values $\\overline{s}$ and $\\overline{r}$.\n5.  Set up the $q_h=7$ point Gaussian quadrature rule.\n6.  Evaluate the analytic field $f(\\mathbf{x}_i)$ at each of the 9 physical nodes.\n7.  Calculate the $L^2$ interpolation error integral by summing contributions at each quadrature point. Take the square root of the result.\n8.  Calculate the reference integral $I_{\\text{ref}}$ using the $q_h=7$ quadrature rule.\n9.  Set up the $q_\\ell=3$ point Gaussian quadrature rule.\n10. Calculate the low-order integral $I$ using the $q_\\ell=3$ rule.\n11. Compute the absolute integration error $|I - I_{\\text{ref}}|$.\n12. Collect the five computed values: $\\overline{s}$, $\\overline{r}$, $\\min \\det \\mathbf{J}$, $\\|f-f_h\\|_{L^2(\\Omega_e)}$, and $|I-I_{\\text{ref}}|$.\n\nThis procedure is repeated for each test case, yielding the requested numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_d_basis(z: float) - np.ndarray:\n    \"\"\"Computes the 1D quadratic Lagrange basis functions at a point z.\"\"\"\n    l1 = 0.5 * z * (z - 1.0)\n    l2 = 1.0 - z**2\n    l3 = 0.5 * z * (z + 1.0)\n    return np.array([l1, l2, l3])\n\ndef one_d_basis_deriv(z: float) - np.ndarray:\n    \"\"\"Computes the derivatives of the 1D quadratic Lagrange basis functions.\"\"\"\n    dl1 = z - 0.5\n    dl2 = -2.0 * z\n    dl3 = z + 0.5\n    return np.array([dl1, dl2, dl3])\n\ndef shape_functions(xi: float, eta: float) - np.ndarray:\n    \"\"\"Computes the 9-node quadratic shape functions at (xi, eta).\"\"\"\n    l_xi = one_d_basis(xi)\n    l_eta = one_d_basis(eta)\n    n_vec = np.zeros(9)\n    for i in range(3):  # eta node index\n        for j in range(3):  # xi node index\n            n_vec[i * 3 + j] = l_xi[j] * l_eta[i]\n    return n_vec\n\ndef shape_derivatives(xi: float, eta: float) - tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes derivatives of shape functions w.r.t. xi and eta.\"\"\"\n    l_xi = one_d_basis(xi)\n    dl_xi = one_d_basis_deriv(xi)\n    l_eta = one_d_basis(eta)\n    dl_eta = one_d_basis_deriv(eta)\n    \n    dn_dxi = np.zeros(9)\n    dn_deta = np.zeros(9)\n    \n    for i in range(3):\n        for j in range(3):\n            k = i * 3 + j\n            dn_dxi[k] = dl_xi[j] * l_eta[i]\n            dn_deta[k] = l_xi[j] * dl_eta[i]\n            \n    return dn_dxi, dn_deta\n\ndef jacobian(xi: float, eta: float, physical_nodes: np.ndarray) - np.ndarray:\n    \"\"\"Computes the Jacobian matrix of the mapping at (xi, eta).\"\"\"\n    dn_dxi, dn_deta = shape_derivatives(xi, eta)\n    \n    # J is a 2x2 matrix\n    # J[0,0] = dN_dxi . x_coords, J[1,0] = dN_dxi . y_coords\n    # J[0,1] = dN_deta . x_coords, J[1,1] = dN_deta . y_coords\n    \n    j_matrix = np.zeros((2, 2))\n    j_matrix[:, 0] = np.dot(dn_dxi, physical_nodes)   # d(x,y)/dxi\n    j_matrix[:, 1] = np.dot(dn_deta, physical_nodes) # d(x,y)/deta\n    \n    return j_matrix\n\ndef f_analytic(x: float, y: float) - float:\n    \"\"\"The analytic scalar field.\"\"\"\n    return np.sin(np.pi * x) * np.cos(np.pi * y)\n\ndef calculate_all_metrics(physical_nodes: np.ndarray) - list[float]:\n    \"\"\"\n    Computes all requiredd distortion and accuracy metrics for a given element.\n    \"\"\"\n    n_s = 7\n    q_h = 7\n    q_l = 3\n\n    # 1. Compute distortion metrics\n    s_vals, r_vals, det_j_vals = [], [], []\n    sample_points_1d = -1.0 + 2.0 * (np.arange(n_s) + 1.0) / (n_s + 1.0)\n\n    for eta_s in sample_points_1d:\n        for xi_s in sample_points_1d:\n            j_mat = jacobian(xi_s, eta_s, physical_nodes)\n            a, b = j_mat[:, 0], j_mat[:, 1]\n\n            # Skewness\n            norm_a = np.linalg.norm(a)\n            norm_b = np.linalg.norm(b)\n            if norm_a  1e-12 and norm_b  1e-12:\n                cos_theta = np.dot(a, b) / (norm_a * norm_b)\n                s_vals.append(np.abs(cos_theta))\n            else: # Should not happen for valid elements\n                s_vals.append(0.0)\n\n            # Aspect ratio from singular values\n            _, s_svd, _ = np.linalg.svd(j_mat)\n            if s_svd.min()  1e-12:\n                r_vals.append(s_svd.max() / s_svd.min())\n            else: # Folded element\n                r_vals.append(np.inf)\n\n            # Jacobian determinant\n            det_j_vals.append(np.linalg.det(j_mat))\n\n    s_mean = np.mean(s_vals)\n    r_mean = np.mean(r_vals)\n    min_det_j = np.min(det_j_vals)\n    \n    # 2. Compute L^2 interpolation error\n    xi_h, w_h = np.polynomial.legendre.leggauss(q_h)\n    f_at_nodes = f_analytic(physical_nodes[:, 0], physical_nodes[:, 1])\n\n    error_integral_sum = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            f_h = np.dot(n_vec, f_at_nodes)\n            \n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            \n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            \n            error_integral_sum += (f_true - f_h)**2 * np.abs(det_j) * w_xi * w_eta\n    \n    l2_error = np.sqrt(error_integral_sum)\n    \n    # 3. Compute integration accuracy\n    # I_ref (high order, q_h=7)\n    i_ref = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_ref += f_true * np.abs(det_j) * w_xi * w_eta\n\n    # I (low order, q_l=3)\n    xi_l, w_l = np.polynomial.legendre.leggauss(q_l)\n    i_low = 0.0\n    for w_eta, eta_q in zip(w_l, xi_l):\n        for w_xi, xi_q in zip(w_l, xi_l):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_low += f_true * np.abs(det_j) * w_xi * w_eta\n            \n    int_error = np.abs(i_low - i_ref)\n    \n    return [s_mean, r_mean, min_det_j, l2_error, int_error]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        [(0.0, 0.0), (1.0, -0.03), (2.0, 0.05),\n         (-0.02, 0.5), (1.02, 0.52), (2.03, 0.5),\n         (0.0, 1.0), (1.0, 1.03), (2.0, 1.05)],\n        # Test Case 2\n        [(0.0, 0.0), (1.0, 0.10), (2.0, 0.3),\n         (0.03, 0.42), (1.07, 0.57), (2.08, 0.68),\n         (0.1, 0.8), (1.12, 0.97), (2.1, 1.1)],\n        # Test Case 3\n        [(0.0, 0.0), (1.5, 0.06), (3.0, 0.2),\n         (0.2, 0.22), (1.62, 0.27), (3.15, 0.33),\n         (0.5, 0.4), (1.9, 0.47), (3.2, 0.5)]\n    ]\n\n    all_results = []\n    for case_nodes in test_cases:\n        physical_nodes_arr = np.array(case_nodes)\n        metrics = calculate_all_metrics(physical_nodes_arr)\n        all_results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3320978"}, {"introduction": "This final practice connects the geometric mapping directly to its principal application in computational electromagnetics: the representation of vector fields. The accurate modeling of electric and magnetic fields requires special vector basis functions, like those developed by Nédélec, which must maintain tangential continuity across element boundaries. You will implement the covariant Piola transform, which uses the Jacobian of the geometric map to correctly transform these vector basis functions from the reference element to the curved physical element, a cornerstone of modern $\\mathbf{H}(\\mathrm{curl})$-conforming finite element methods [@problem_id:3320946].", "problem": "You are given the task of constructing mapped Nédélec first-kind edge basis functions on a curved tetrahedral element in computational electromagnetics and verifying their tangential continuity across a shared curved face between two quadratic isoparametric tetrahedra. The analysis must begin from the foundational law of electromagnetics that constrains the function space: Maxwell–Faraday law of electromagnetic induction, which in its integral form states that for any sufficiently smooth surface with boundary curve,\n$$\n\\oint_{\\partial S} \\mathbf{E} \\cdot \\mathbf{t}\\, ds \\;=\\; -\\frac{d}{dt}\\iint_S \\mathbf{B} \\cdot \\mathbf{n}\\, dS,\n$$\nwhere $\\mathbf{E}$ is the electric field, $\\mathbf{B}$ is the magnetic flux density, $\\mathbf{t}$ is the unit tangent along the curve, and $\\mathbf{n}$ is the unit normal to the surface. In finite elements for electromagnetic fields, preserving tangential line integrals of the electric field along edges leads to the use of function spaces conforming to the Sobolev space of square-integrable vector fields with square-integrable curl, denoted $\\mathbf{H}(\\mathrm{curl})$. The construction of curved elements is based on isoparametric mappings that transform a reference element into a physical curved element using higher-order geometry representation.\n\nYour task is to implement the following in a complete, runnable program:\n\n1. Define the Nédélec first-kind lowest-order edge basis functions on the reference tetrahedron using barycentric coordinates. Let the reference tetrahedron have vertices at $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, with barycentric coordinates $\\lambda_1 = 1 - r - s - t$, $\\lambda_2 = r$, $\\lambda_3 = s$, $\\lambda_4 = t$, and constant gradients $\\nabla \\lambda_1 = (-1,-1,-1)$, $\\nabla \\lambda_2 = (1,0,0)$, $\\nabla \\lambda_3 = (0,1,0)$, $\\nabla \\lambda_4 = (0,0,1)$. The six edge basis functions on the reference element are associated with the edges $(1,2)$, $(1,3)$, $(1,4)$, $(2,3)$, $(2,4)$, $(3,4)$, and must be expressed in terms of the barycentric coordinates and their gradients, consistent with the edge-integral degrees of freedom along the reference edges.\n\n2. Use a quadratic isoparametric mapping for the tetrahedra. The mapping from the reference tetrahedron with coordinates $(r,s,t)$ to the physical tetrahedron is defined by the quadratic tetrahedral Lagrange shape functions with $10$ nodes: $4$ vertex nodes and $6$ mid-edge nodes. Let the quadratic shape functions be defined by the barycentric coordinates as follows:\n   - Vertex shape functions:\n     $$\n     N_1 = \\lambda_1(2\\lambda_1 - 1),\\quad N_2 = \\lambda_2(2\\lambda_2 - 1),\\quad N_3 = \\lambda_3(2\\lambda_3 - 1),\\quad N_4 = \\lambda_4(2\\lambda_4 - 1).\n     $$\n   - Edge shape functions (for edge $(i,j)$):\n     $$\n     N_{ij} = 4\\lambda_i \\lambda_j.\n     $$\n   The mapping $\\mathbf{F}$ is given by\n   $$\n   \\mathbf{x}(r,s,t) \\;=\\; \\sum_{a=1}^{10} N_a(r,s,t)\\, \\mathbf{X}_a,\n   $$\n   where $\\mathbf{X}_a \\in \\mathbb{R}^3$ are the physical coordinates of the $10$ geometry nodes, ordered as $[1,2,3,4,12,13,14,23,24,34]$. The Jacobian matrix $\\mathbf{J} = D\\mathbf{F}$ must be computed using\n   $$\n   \\mathbf{J}(r,s,t) \\;=\\; \\sum_{a=1}^{10} \\mathbf{X}_a \\otimes \\nabla N_a(r,s,t),\n   $$\n   so that its columns are the partial derivatives $\\partial \\mathbf{x}/\\partial r$, $\\partial \\mathbf{x}/\\partial s$, and $\\partial \\mathbf{x}/\\partial t$.\n\n3. Construct the mapped Nédélec first-kind basis functions on each physical tetrahedron using the covariant Piola transform appropriate for $\\mathbf{H}(\\mathrm{curl})$-conforming elements, and compute their tangential components along the shared curved face using tangent vectors obtained from the isoparametric mapping. The shared face is the face opposite vertex $4$ (i.e., the face formed by vertices $1$, $2$, and $3$), and all comparisons must be made at points with $t = 0$ in reference coordinates.\n\n4. Verify tangential continuity across the shared curved face between the two tetrahedra by sampling multiple points on the face. The continuity verification must be performed by computing the differences in the tangential components of corresponding mapped basis functions from the two tetrahedra and aggregating the maximum absolute difference across the sample points.\n\n5. Use the following geometry definition for two tetrahedra, which share the curved face formed by nodes $1$, $2$, $3$, and mid-edge nodes $12$, $13$, $23$. All coordinates are in meters:\n   - Shared face (used by both tetrahedra):\n     $$\n     \\mathbf{X}_1 = (0,0,0),\\quad \\mathbf{X}_2 = (1,0,0),\\quad \\mathbf{X}_3 = (0,1,0),\n     $$\n     $$\n     \\mathbf{X}_{12} = (0.5,\\, 0.0,\\, 0.05),\\quad \\mathbf{X}_{13} = (0.0,\\, 0.5,\\, -0.04),\\quad \\mathbf{X}_{23} = (0.5,\\, 0.5,\\, 0.03).\n     $$\n   - Tetrahedron A interior nodes:\n     $$\n     \\mathbf{X}_4^{(A)} = (0.2,\\, 0.2,\\, 0.4),\n     $$\n     $$\n     \\mathbf{X}_{14}^{(A)} = (0.12,\\, 0.09,\\, 0.2),\\quad \\mathbf{X}_{24}^{(A)} = (0.6,\\, 0.12,\\, 0.21),\\quad \\mathbf{X}_{34}^{(A)} = (0.09,\\, 0.6,\\, 0.18).\n     $$\n   - Tetrahedron B interior nodes:\n     $$\n     \\mathbf{X}_4^{(B)} = (0.3,\\, 0.2,\\, -0.35),\n     $$\n     $$\n     \\mathbf{X}_{14}^{(B)} = (0.13,\\, 0.10,\\, -0.165),\\quad \\mathbf{X}_{24}^{(B)} = (0.66,\\, 0.09,\\, -0.175),\\quad \\mathbf{X}_{34}^{(B)} = (0.15,\\, 0.62,\\, -0.18).\n     $$\n\n6. Use the following set of reference-face sampling points (all with $t = 0$):\n   $$\n   (r,s,t) \\in \\{(0.2,\\, 0.3,\\, 0),\\; (0.5,\\, 0.0,\\, 0),\\; (0.0,\\, 0.5,\\, 0),\\; (0.5,\\, 0.5,\\, 0),\\; (0.0,\\, 0.0,\\, 0),\\; (1.0,\\, 0.0,\\, 0),\\; (0.0,\\, 1.0,\\, 0)\\}.\n   $$\n\n7. Define four test cases to verify different aspects:\n   - Test Case $1$ (general interior continuity): Compare the tangential components of the mapped basis function associated with edge $(1,2)$ along the tangent vector corresponding to $\\partial\\mathbf{x}/\\partial r$ at the sampling points, and report the maximum absolute difference across all points.\n   - Test Case $2$ (alternative direction continuity): Compare the tangential components of the mapped basis function associated with edge $(1,3)$ along the tangent vector corresponding to $\\partial\\mathbf{x}/\\partial s$ at the sampling points, and report the maximum absolute difference.\n   - Test Case $3$ (orientation mismatch boundary case): Repeat Test Case $1$ but intentionally reverse the tangent direction for the second tetrahedron by using the negative of the tangent vector; report the maximum absolute difference to illustrate the effect of inconsistent orientation handling.\n   - Test Case $4$ (arbitrary tangential direction): Compare the tangential components of the mapped basis function associated with edge $(2,3)$ along the unit tangent direction formed by normalizing $\\partial\\mathbf{x}/\\partial r + 0.3\\, \\partial\\mathbf{x}/\\partial s$; report the maximum absolute difference.\n\n8. Final output format: Your program should produce a single line of output containing the results of the four test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$, where each result is a floating-point number in meters (since the tangential components are dot-products with position derivatives, which have units of meters), printed in plain decimal or scientific notation.\n\nYour program must be self-contained, must construct the isoparametric mappings, the reference Nédélec basis functions, apply the covariant Piola transform for $\\mathbf{H}(\\mathrm{curl})$, and compute the specified tangential continuity checks using only the specified numerical libraries. The implementation must not require any external input and must adhere to the output format requirement exactly.", "solution": "The problem requires the implementation and verification of tangential continuity for Nédélec first-kind lowest-order edge basis functions on curved quadratic isoparametric tetrahedra. This is a foundational procedure in the finite element method (FEM) for computational electromagnetics. Before proceeding to the numerical implementation, the underlying principles must be elucidated.\n\n**1. Theoretical Foundation for H(curl)-Conforming Elements**\n\nThe time-harmonic Maxwell's equations govern electromagnetic phenomena. The Maxwell-Faraday law, $\\nabla \\times \\mathbf{E} = -j\\omega\\mathbf{B}$, relates the curl of the electric field $\\mathbf{E}$ to the magnetic flux density $\\mathbf{B}$. When formulating a FEM solution, the electric field is approximated as a weighted sum of vector basis functions, $\\mathbf{E}(\\mathbf{x}) \\approx \\sum_{i} e_i \\mathbf{W}_i(\\mathbf{x})$. For the curl operator to be well-defined in a weak sense, these basis functions must belong to the Sobolev space $\\mathbf{H}(\\mathrm{curl})$, which consists of square-integrable vector fields whose curl is also square-integrable. A critical property of fields in $\\mathbf{H}(\\mathrm{curl})$ is the continuity of their tangential components across inter-element boundaries. This ensures that spurious, non-physical solutions do not arise and that the line integral of the field is well-defined. Nédélec basis functions are specifically designed to enforce this tangential continuity.\n\n**2. Basis Functions on the Reference Element**\n\nThe construction begins on a simple reference element, a tetrahedron $\\hat{K}$ with vertices at $\\hat{\\mathbf{v}}_1=(0,0,0)$, $\\hat{\\mathbf{v}}_2=(1,0,0)$, $\\hat{\\mathbf{v}}_3=(0,1,0)$, and $\\hat{\\mathbf{v}}_4=(0,0,1)$. Any point $\\hat{\\mathbf{x}}=(r,s,t)$ inside $\\hat{K}$ can be expressed using barycentric coordinates:\n$$\n\\lambda_1 = 1 - r - s - t, \\quad \\lambda_2 = r, \\quad \\lambda_3 = s, \\quad \\lambda_4 = t.\n$$\nThe gradients of these coordinates with respect to the reference coordinate system $(r,s,t)$ are constant vectors:\n$$\n\\nabla \\lambda_1 = \\begin{pmatrix}-1\\\\-1\\\\-1\\end{pmatrix}, \\quad \\nabla \\lambda_2 = \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}, \\quad \\nabla \\lambda_3 = \\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix}, \\quad \\nabla \\lambda_4 = \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\nThe Nédélec first-kind, lowest-order edge basis function $\\hat{\\mathbf{W}}_{ij}$ associated with the edge connecting vertex $i$ and vertex $j$ is defined as:\n$$\n\\hat{\\mathbf{W}}_{ij}(\\hat{\\mathbf{x}}) = \\lambda_i(\\hat{\\mathbf{x}}) \\nabla \\lambda_j - \\lambda_j(\\hat{\\mathbf{x}}) \\nabla \\lambda_i.\n$$\nThis definition ensures that the line integral of $\\hat{\\mathbf{W}}_{ij}$ along any edge $\\hat{e}_{kl}$ is $\\int_{\\hat{e}_{kl}} \\hat{\\mathbf{W}}_{ij} \\cdot d\\mathbf{l} = \\delta_{ij,kl}$, where $\\delta$ is the Kronecker delta. This property defines the degrees of freedom for these elements. There are six such basis functions corresponding to the six edges of the tetrahedron.\n\n**3. Quadratic Isoparametric Mapping**\n\nTo model curved geometries, we employ an isoparametric mapping $\\mathbf{F}$ that transforms the reference element $\\hat{K}$ into a physical, curved element $K$. The position vector $\\mathbf{x}$ in the physical domain is expressed as a function of the reference coordinates $\\hat{\\mathbf{x}}=(r,s,t)$:\n$$\n\\mathbf{x}(\\hat{\\mathbf{x}}) = \\mathbf{F}(\\hat{\\mathbf{x}}) = \\sum_{a=1}^{10} N_a(\\hat{\\mathbf{x}}) \\mathbf{X}_a.\n$$\nHere, $\\mathbf{X}_a$ are the coordinates of the $10$ physical nodes of the quadratic tetrahedron, and $N_a$ are the corresponding quadratic Lagrange shape functions. The shape functions are defined in terms of barycentric coordinates:\n- Vertex nodes $(i=1,2,3,4)$: $N_i = \\lambda_i(2\\lambda_i - 1)$\n- Mid-edge nodes (on edge $(i,j)$): $N_{ij} = 4\\lambda_i \\lambda_j$\n\nThe transformation's local behavior is described by the Jacobian matrix $\\mathbf{J}$, whose entries are the partial derivatives of the physical coordinates with respect to the reference coordinates, $J_{mn} = \\partial x_m / \\partial \\hat{x}_n$. It is computed as:\n$$\n\\mathbf{J}(\\hat{\\mathbf{x}}) = D\\mathbf{F} = \\sum_{a=1}^{10} \\mathbf{X}_a \\otimes \\nabla N_a(\\hat{\\mathbf{x}}),\n$$\nwhere $\\otimes$ denotes the outer product, and $\\nabla N_a$ is the gradient of the shape function with respect to $(r,s,t)$.\n\n**4. Covariant Piola Transform**\n\nVector basis functions from the reference element cannot be simply transferred to the physical element; they must be transformed to preserve their specific properties, such as tangential continuity. For $\\mathbf{H}(\\mathrm{curl})$-conforming elements, this is achieved via the covariant Piola transform. A reference basis function $\\hat{\\mathbf{W}}(\\hat{\\mathbf{x}})$ is mapped to the physical basis function $\\mathbf{W}(\\mathbf{x})$ according to:\n$$\n\\mathbf{W}(\\mathbf{x}(\\hat{\\mathbf{x}})) = \\left[\\mathbf{J}(\\hat{\\mathbf{x}})^{-1}\\right]^T \\hat{\\mathbf{W}}(\\hat{\\mathbf{x}}).\n$$\nThis transformation ensures that the tangential components of the vector field are preserved across the mapping, which is the fundamental requirement for $\\mathbf{H}(\\mathrm{curl})$ conformity.\n\n**5. Verification of Tangential Continuity**\n\nThe core of the task is to verify that this construction indeed results in tangentially continuous basis functions. We consider two adjacent tetrahedra, $K_A$ and $K_B$, sharing a common curved face $f$. The face $f$ is defined by a common set of nodes. A basis function $\\mathbf{W}_e$ associated with an edge $e$ lying on this shared face should have the same tangential component when evaluated from either tetrahedron.\nThis means that for any vector $\\mathbf{t}$ tangent to the face $f$ at a point $\\mathbf{x} \\in f$, the following equality must hold:\n$$\n\\mathbf{W}_{e, A}(\\mathbf{x}) \\cdot \\mathbf{t}(\\mathbf{x}) = \\mathbf{W}_{e, B}(\\mathbf{x}) \\cdot \\mathbf{t}(\\mathbf{x}).\n$$\nIn the implementation, we will sample several points on the shared face. At each point, we compute the mapped basis functions $\\mathbf{W}_{A}$ and $\\mathbf{W}_{B}$ using their respective Jacobians, $\\mathbf{J}_A$ and $\\mathbf{J}_B$. We also compute a tangent vector $\\mathbf{t}$. Since the mapping on the face is defined solely by the shared nodes, the tangent plane and any tangent vectors derived from the mapping (e.g., $\\partial\\mathbf{x}/\\partial r$, $\\partial\\mathbf{x}/\\partial s$) will be identical for both tetrahedra. We then compute the dot products and their difference. For basis functions associated with edges on the shared face, this difference should be zero up to numerical precision. The test cases are designed to confirm this property under different conditions and to illustrate the consequence of inconsistent tangent vector orientation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies tangential continuity of Nédélec basis functions on curved tetrahedra.\n    \"\"\"\n\n    class QuadraticTet:\n        \"\"\"Represents a quadratic isoparametric tetrahedron.\"\"\"\n        \n        def __init__(self, node_coords_dict):\n            \"\"\"\n            Initializes the tetrahedron with coordinates for its 10 nodes.\n            Args:\n                node_coords_dict: A dictionary mapping node keys (e.g., 1, 2, 12, 34) \n                                  to their 3D coordinates.\n            \"\"\"\n            # Order: 1, 2, 3, 4, 12, 13, 14, 23, 24, 34\n            self.nodes_X = np.array([\n                node_coords_dict[1], node_coords_dict[2], node_coords_dict[3], node_coords_dict[4],\n                node_coords_dict[12], node_coords_dict[13], node_coords_dict[14],\n                node_coords_dict[23], node_coords_dict[24], node_coords_dict[34]\n            ])\n            # Constant gradients of barycentric coordinates\n            self.grad_lambda = np.array([\n                [-1, -1, -1],  # grad(lambda_1)\n                [ 1,  0,  0],  # grad(lambda_2)\n                [ 0,  1,  0],  # grad(lambda_3)\n                [ 0,  0,  1]   # grad(lambda_4)\n            ])\n\n        def get_barycentric_coords(self, r, s, t):\n            \"\"\"Computes barycentric coordinates for a point (r,s,t).\"\"\"\n            return np.array([1 - r - s - t, r, s, t])\n\n        def get_shape_function_grads(self, r, s, t):\n            \"\"\"Computes gradients of the 10 quadratic Lagrange shape functions.\"\"\"\n            l = self.get_barycentric_coords(r, s, t)\n            grads = np.zeros((10, 3))\n            \n            # Vertex shape function gradients: grad(Ni) = (4*li - 1)*grad(li)\n            for i in range(4):\n                grads[i, :] = (4 * l[i] - 1) * self.grad_lambda[i]\n\n            # Edge shape function gradients: grad(Nij) = 4 * (lj*grad(li) + li*grad(lj))\n            edge_pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n            for idx, (i, j) in enumerate(edge_pairs):\n                grads[4 + idx, :] = 4 * (l[j] * self.grad_lambda[i] + l[i] * self.grad_lambda[j])\n            \n            return grads\n\n        def get_jacobian(self, r, s, t):\n            \"\"\"Computes the Jacobian matrix of the isoparametric mapping.\"\"\"\n            shape_grads = self.get_shape_function_grads(r, s, t)\n            # J = sum(X_a outer grad(N_a))\n            J = np.zeros((3, 3))\n            for i in range(10):\n                J += np.outer(self.nodes_X[i], shape_grads[i])\n            return J\n\n    def get_ref_nedelec_basis(edge_pair, r, s, t):\n        \"\"\"\n        Computes the lowest-order Nédélec basis function on the reference element.\n        Args:\n            edge_pair: A tuple (i, j) of 0-indexed vertex numbers.\n            r, s, t: Coordinates on the reference element.\n        Returns:\n            The 3D vector value of the basis function.\n        \"\"\"\n        i, j = edge_pair\n        l = np.array([1 - r - s - t, r, s, t])\n        grad_lambda = np.array([\n            [-1, -1, -1], [1, 0, 0], [0, 1, 0], [0, 0, 1]\n        ])\n        \n        # W_ij = li * grad(lj) - lj * grad(li)\n        return l[i] * grad_lambda[j] - l[j] * grad_lambda[i]\n\n    # --- Problem Setup ---\n    # Shared nodes for both tetrahedra\n    shared_nodes = {\n        1: np.array([0.0, 0.0, 0.0]), 2: np.array([1.0, 0.0, 0.0]), 3: np.array([0.0, 1.0, 0.0]),\n        12: np.array([0.5, 0.0, 0.05]), 13: np.array([0.0, 0.5, -0.04]), 23: np.array([0.5, 0.5, 0.03])\n    }\n\n    # Nodes for Tetrahedron A\n    nodes_A = shared_nodes.copy()\n    nodes_A.update({\n        4: np.array([0.2, 0.2, 0.4]), 14: np.array([0.12, 0.09, 0.2]),\n        24: np.array([0.6, 0.12, 0.21]), 34: np.array([0.09, 0.6, 0.18])\n    })\n\n    # Nodes for Tetrahedron B\n    nodes_B = shared_nodes.copy()\n    nodes_B.update({\n        4: np.array([0.3, 0.2, -0.35]), 14: np.array([0.13, 0.10, -0.165]),\n        24: np.array([0.66, 0.09, -0.175]), 34: np.array([0.15, 0.62, -0.18])\n    })\n\n    tet_A = QuadraticTet(nodes_A)\n    tet_B = QuadraticTet(nodes_B)\n\n    # Sample points on the reference face (t=0)\n    sample_points = [\n        (0.2, 0.3, 0.0), (0.5, 0.0, 0.0), (0.0, 0.5, 0.0), (0.5, 0.5, 0.0),\n        (0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0)\n    ]\n    \n    # 0-indexed reference edges for Nédélec functions\n    edge_map = {\n        (1, 2): (0, 1), (1, 3): (0, 2), (1, 4): (0, 3),\n        (2, 3): (1, 2), (2, 4): (1, 3), (3, 4): (2, 3)\n    }\n\n    test_cases_params = [\n        {'edge': (1, 2), 'case': 1},\n        {'edge': (1, 3), 'case': 2},\n        {'edge': (1, 2), 'case': 3},\n        {'edge': (2, 3), 'case': 4},\n    ]\n\n    final_results = []\n\n    for params in test_cases_params:\n        edge_key = params['edge']\n        case_num = params['case']\n        ref_edge_indices = edge_map[edge_key]\n        \n        max_abs_diff = 0.0\n\n        for r_p, s_p, t_p in sample_points:\n            # 1. Get reference Nédélec basis function\n            W_ref = get_ref_nedelec_basis(ref_edge_indices, r_p, s_p, t_p)\n\n            # 2. Compute Jacobians for both tetrahedra\n            J_A = tet_A.get_jacobian(r_p, s_p, t_p)\n            J_B = tet_B.get_jacobian(r_p, s_p, t_p)\n\n            # 3. Apply Covariant Piola Transform: W_phys = (J^-T) @ W_ref\n            J_A_inv_T = np.linalg.inv(J_A).T\n            J_B_inv_T = np.linalg.inv(J_B).T\n            \n            W_A = J_A_inv_T @ W_ref\n            W_B = J_B_inv_T @ W_ref\n\n            # 4. Define tangent vector for the test case\n            # Tangent vectors on the face are identical for both tets as nodes are shared\n            tangent_r = J_A[:, 0]  # d(x)/dr\n            tangent_s = J_A[:, 1]  # d(x)/ds\n\n            if case_num == 1 or case_num == 3:\n                t_A = tangent_r\n                t_B = -tangent_r if case_num == 3 else tangent_r\n            elif case_num == 2:\n                t_A = tangent_s\n                t_B = tangent_s\n            elif case_num == 4:\n                t_vec = tangent_r + 0.3 * tangent_s\n                t_norm = np.linalg.norm(t_vec)\n                t_A = t_vec / t_norm if t_norm  1e-15 else np.zeros(3)\n                t_B = t_A\n            \n            # 5. Compute tangential components and their difference\n            tangential_comp_A = np.dot(W_A, t_A)\n            tangential_comp_B = np.dot(W_B, t_B)\n            \n            diff = np.abs(tangential_comp_A - tangential_comp_B)\n            if diff  max_abs_diff:\n                max_abs_diff = diff\n\n        final_results.append(max_abs_diff)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n\nsolve()\n\n```", "id": "3320946"}]}