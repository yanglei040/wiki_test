{"hands_on_practices": [{"introduction": "The foundational property of the Sobolev space $H(\\mathrm{curl})$ is the guaranteed continuity of a vector field's tangential component across internal boundaries. This exercise provides a direct, hands-on calculation to build intuition for this abstract concept. By computing the edge degrees of freedom for a field with a specified normal discontinuity [@problem_id:3297079], you will verify how Nédélec finite elements naturally enforce tangential continuity, a property crucial for the well-posedness of Maxwell's equations.", "problem": "Consider the Sobolev space of square-integrable vector fields with square-integrable curl, denoted by $H(\\mathrm{curl}; \\Omega)$, and its curl-conforming finite element discretization using first-kind Nédélec (edge) elements. The tangential trace on an interface is defined by the line integral of the field’s tangential component along each edge. In computational electromagnetics, these edge degrees of freedom encode tangential continuity, which is required by the weak form of Maxwell’s equations and the definition of $H(\\mathrm{curl}; \\Omega)$.\n\nLet $\\Omega \\subset \\mathbb{R}^{3}$ be the union of two tetrahedra $T^{-}$ and $T^{+}$ sharing the triangular face $S$ with vertices $P_{1} = (1,0,0)$, $P_{2} = (0,1,0)$, and $P_{3} = (0,0,1)$. The tetrahedron $T^{-}$ has vertices $A_{0} = (0,0,0)$, $A_{1} = P_{1}$, $A_{2} = P_{2}$, $A_{3} = P_{3}$, and the tetrahedron $T^{+}$ has vertices $B_{0} = P_{1}$, $B_{1} = P_{2}$, $B_{2} = P_{3}$, $B_{3} = (1,1,1)$. The shared face $S$ lies in the plane $x + y + z = 1$ and has unit normal $\\boldsymbol{n}_{S}$ chosen to be outward from $T^{-}$.\n\nDefine a piecewise electric field $\\boldsymbol{E} : \\Omega \\to \\mathbb{R}^{3}$ by\n$$\n\\boldsymbol{E}(\\boldsymbol{x}) = \n\\begin{cases}\n\\boldsymbol{E}^{-}(\\boldsymbol{x}) = \\begin{pmatrix} x + y \\\\ y + z \\\\ z + x \\end{pmatrix} \\ \\text{V/m}, & \\boldsymbol{x} \\in T^{-}, \\\\\n\\boldsymbol{E}^{+}(\\boldsymbol{x}) = \\boldsymbol{E}^{-}(\\boldsymbol{x}) + \\gamma \\, \\boldsymbol{n}_{S} \\ \\text{V/m}, & \\boldsymbol{x} \\in T^{+},\n\\end{cases}\n$$\nwhere $\\gamma \\in \\mathbb{R}$ is a constant and $\\boldsymbol{n}_{S}$ is the unit normal to $S$.\n\nUse the globally oriented shared edges of $S$,\n$$\ne_{1} : P_{1} \\to P_{2}, \\quad e_{2} : P_{2} \\to P_{3}, \\quad e_{3} : P_{3} \\to P_{1},\n$$\nwith the degree of freedom on an edge $e$ defined as the line integral\n$$\nI(\\boldsymbol{E}; e) = \\int_{e} \\boldsymbol{E} \\cdot \\boldsymbol{t}_{e} \\, \\mathrm{d}s = \\int_{e} \\boldsymbol{E} \\cdot \\mathrm{d}\\boldsymbol{l},\n$$\nwhere $\\boldsymbol{t}_{e}$ is the unit tangent to $e$ consistent with its orientation and $\\mathrm{d}\\boldsymbol{l} = \\boldsymbol{t}_{e} \\, \\mathrm{d}s$.\n\nCompute the three shared-edge degrees of freedom for $\\boldsymbol{E}^{-}$ and $\\boldsymbol{E}^{+}$, and verify tangential continuity across $S$ by evaluating the sum of squared differences\n$$\nJ = \\sum_{i=1}^{3} \\left( I\\!\\left(\\boldsymbol{E}^{+}; e_{i}\\right) - I\\!\\left(\\boldsymbol{E}^{-}; e_{i}\\right) \\right)^{2}.\n$$\nExpress the final quantity $J$ in $\\mathrm{V}^{2}$. The final answer must be a single real number or a single closed-form analytic expression.", "solution": "The objective is to compute the quantity $J = \\sum_{i=1}^{3} \\left( I\\!\\left(\\boldsymbol{E}^{+}; e_{i}\\right) - I\\!\\left(\\boldsymbol{E}^{-}; e_{i}\\right) \\right)^{2}$. This quantity represents the sum of squared differences of the edge degrees of freedom for the piecewise-defined electric field $\\boldsymbol{E}$ across the shared interface $S$.\n\nThe degree of freedom associated with a vector field $\\boldsymbol{F}$ and an edge $e$ is given by the line integral $I(\\boldsymbol{F}; e) = \\int_{e} \\boldsymbol{F} \\cdot \\mathrm{d}\\boldsymbol{l}$. We first analyze the difference term for a single edge $e_i$:\n$$\n\\Delta I_i = I(\\boldsymbol{E}^{+}; e_{i}) - I(\\boldsymbol{E}^{-}; e_{i}) = \\int_{e_i} \\boldsymbol{E}^{+}(\\boldsymbol{x}) \\cdot \\mathrm{d}\\boldsymbol{l} - \\int_{e_i} \\boldsymbol{E}^{-}(\\boldsymbol{x}) \\cdot \\mathrm{d}\\boldsymbol{l}\n$$\nBy the linearity of the integral, this can be combined into a single integral over the difference of the vector fields:\n$$\n\\Delta I_i = \\int_{e_i} \\left( \\boldsymbol{E}^{+}(\\boldsymbol{x}) - \\boldsymbol{E}^{-}(\\boldsymbol{x}) \\right) \\cdot \\mathrm{d}\\boldsymbol{l}\n$$\nAccording to the problem statement, the electric field is defined as $\\boldsymbol{E}^{+}(\\boldsymbol{x}) = \\boldsymbol{E}^{-}(\\boldsymbol{x}) + \\gamma \\, \\boldsymbol{n}_{S}$ for $\\boldsymbol{x} \\in T^{+}$. This relation holds for points on the interface $S$, which includes the edges $e_i$. Therefore, the difference between the fields along these edges is constant:\n$$\n\\boldsymbol{E}^{+}(\\boldsymbol{x}) - \\boldsymbol{E}^{-}(\\boldsymbol{x}) = \\gamma \\, \\boldsymbol{n}_{S}\n$$\nSubstituting this into the expression for $\\Delta I_i$:\n$$\n\\Delta I_i = \\int_{e_i} (\\gamma \\, \\boldsymbol{n}_{S}) \\cdot \\mathrm{d}\\boldsymbol{l}\n$$\nThe term $\\gamma \\, \\boldsymbol{n}_{S}$ is a constant vector. As such, it can be factored out of the integral:\n$$\n\\Delta I_i = \\gamma \\, \\boldsymbol{n}_{S} \\cdot \\int_{e_i} \\mathrm{d}\\boldsymbol{l}\n$$\nThe remaining integral, $\\int_{e_i} \\mathrm{d}\\boldsymbol{l}$, represents the vector displacement from the start-point to the end-point of the edge $e_i$.\n\nThe fundamental insight is that each edge $e_i$ lies entirely within the face $S$. The vector $\\boldsymbol{n}_{S}$ is, by definition, normal (perpendicular) to the plane containing the face $S$. Any vector that lies within this plane must be orthogonal to $\\boldsymbol{n}_{S}$. The displacement vector $\\int_{e_i} \\mathrm{d}\\boldsymbol{l}$ is such a vector. Consequently, their dot product must be zero:\n$$\n\\boldsymbol{n}_{S} \\cdot \\int_{e_i} \\mathrm{d}\\boldsymbol{l} = 0\n$$\nThis implies that $\\Delta I_i = \\gamma \\cdot 0 = 0$ for each edge $i=1, 2, 3$.\n\nTo verify this, we can perform the calculation explicitly. The vertices of the face $S$ are $P_{1} = (1,0,0)$, $P_{2} = (0,1,0)$, and $P_{3} = (0,0,1)$. These points satisfy the plane equation $x+y+z=1$. A normal vector to this plane is $\\boldsymbol{n} = (1,1,1)^\\top$. The corresponding unit normal vector is:\n$$\n\\boldsymbol{n}_{S} = \\frac{1}{\\sqrt{1^2+1^2+1^2}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\nThe displacement vectors for the oriented edges are:\n- $e_1: P_1 \\to P_2$, so $\\boldsymbol{v}_1 = P_2 - P_1 = \\begin{pmatrix} -1 \\\\ 1 \\\\ 0 \\end{pmatrix}$.\n- $e_2: P_2 \\to P_3$, so $\\boldsymbol{v}_2 = P_3 - P_2 = \\begin{pmatrix} 0 \\\\ -1 \\\\ 1 \\end{pmatrix}$.\n- $e_3: P_3 \\to P_1$, so $\\boldsymbol{v}_3 = P_1 - P_3 = \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$.\n\nNow we compute the dot products:\n- For $e_1$: $\\Delta I_1 = \\gamma \\boldsymbol{n}_{S} \\cdot \\boldsymbol{v}_1 = \\gamma \\frac{1}{\\sqrt{3}}(1,1,1) \\cdot (-1,1,0) = \\frac{\\gamma}{\\sqrt{3}}(-1+1+0) = 0$.\n- For $e_2$: $\\Delta I_2 = \\gamma \\boldsymbol{n}_{S} \\cdot \\boldsymbol{v}_2 = \\gamma \\frac{1}{\\sqrt{3}}(1,1,1) \\cdot (0,-1,1) = \\frac{\\gamma}{\\sqrt{3}}(0-1+1) = 0$.\n- For $e_3$: $\\Delta I_3 = \\gamma \\boldsymbol{n}_{S} \\cdot \\boldsymbol{v}_3 = \\gamma \\frac{1}{\\sqrt{3}}(1,1,1) \\cdot (1,0,-1) = \\frac{\\gamma}{\\sqrt{3}}(1+0-1) = 0$.\n\nSince the difference in degrees of freedom $\\Delta I_i$ is $0$ for all three shared edges, the quantity $J$ is:\n$$\nJ = \\sum_{i=1}^{3} (\\Delta I_i)^2 = 0^2 + 0^2 + 0^2 = 0\n$$\nThe result $J=0$ in units of $\\mathrm{V}^2$ confirms that the tangential component of the electric field $\\boldsymbol{E}$ is continuous across the interface $S$, irrespective of the specific form of $\\boldsymbol{E}^{-}$ or the value of the normal jump parameter $\\gamma$. This is a fundamental property of fields in $H(\\mathrm{curl}, \\Omega)$ and the basis of Nédélec finite element formulations.", "answer": "$$\\boxed{0}$$", "id": "3297079"}, {"introduction": "After understanding the continuity properties of the space, we must ensure that our discrete differential operators faithfully represent their continuous counterparts. This practice implements a numerical patch test to verify the crucial \"commuting diagram\" property for the curl operator [@problem_id:3297150]. By confirming that the curl of a transformed basis function can be calculated consistently in multiple ways, you will validate the core machinery that makes curl-conforming methods stable and accurate.", "problem": "Implement a small patch test for curl-conforming Sobolev spaces by computing the curl of lowest-order Nédélec (first kind) basis functions on a reference triangle and verifying numerically that a discrete curl operator matches analytical expressions under affine mappings to physical triangles. The verification must be carried out purely in mathematical terms using standard constructions, without external files or user input.\n\nStart from the following fundamental base:\n- The curl-conforming Sobolev space is $H(\\mathrm{curl};\\Omega) = \\{\\boldsymbol{v} \\in [L^2(\\Omega)]^2 \\mid \\mathrm{curl}\\,\\boldsymbol{v} \\in L^2(\\Omega)\\}$ in two dimensions, where for $\\boldsymbol{v} = (v_x,v_y)$, $\\mathrm{curl}\\,\\boldsymbol{v} = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$.\n- On the reference triangle $\\hat{T}$ with vertices $\\hat{\\boldsymbol{x}}_1=(0,0)$, $\\hat{\\boldsymbol{x}}_2=(1,0)$, $\\hat{\\boldsymbol{x}}_3=(0,1)$, the barycentric coordinates are $\\hat{\\lambda}_1 = 1 - \\hat{x} - \\hat{y}$, $\\hat{\\lambda}_2 = \\hat{x}$, $\\hat{\\lambda}_3 = \\hat{y}$, with constant gradients $\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_1 = (-1,-1)^\\top$, $\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_2 = (1,0)^\\top$, $\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_3 = (0,1)^\\top$.\n- The lowest-order Nédélec (first kind) edge basis on $\\hat{T}$ associated to an oriented edge $(i \\to j)$ is\n$$\n\\hat{\\boldsymbol{N}}_{ij} = \\hat{\\lambda}_i \\,\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_j \\;-\\; \\hat{\\lambda}_j \\,\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_i.\n$$\nThese basis functions have unit tangential line integral along their associated oriented edge and zero along the other edges.\n- The covariant Piola mapping for curl-conforming fields on an affine map $F:\\hat{T}\\to T$ defined by $\\boldsymbol{x} = \\boldsymbol{x}_1 + J \\hat{\\boldsymbol{x}}$ with constant Jacobian $J \\in \\mathbb{R}^{2\\times 2}$ is\n$$\n\\boldsymbol{v}(\\boldsymbol{x}) = J^{-\\top}\\,\\hat{\\boldsymbol{v}}(\\hat{\\boldsymbol{x}}),\n\\quad \\text{with} \\quad \\hat{\\boldsymbol{x}} = J^{-1}(\\boldsymbol{x}-\\boldsymbol{x}_1).\n$$\n- The discrete curl operator on the lowest-order de Rham complex maps edge degrees of freedom to a cell degree of freedom by oriented boundary incidence, and the $L^2$ projection to the constant scalar space $P_0(T)$ uses the element mass (area) $|T|$. For a single triangle with local edges oriented $(1\\to 2)$, $(2\\to 3)$, $(3\\to 1)$ in that order, the oriented integral of $\\mathrm{curl}\\,\\boldsymbol{v}$ over $T$ equals the oriented sum of edge tangential integrals.\n\nTasks to implement and verify:\n1. Implement the three local Nédélec basis functions on $\\hat{T}$ corresponding to oriented edges $(1\\to 2)$, $(2\\to 3)$, $(3\\to 1)$. For each basis, compute its analytical scalar curl on $\\hat{T}$ using the definition $\\mathrm{curl}\\,\\boldsymbol{v} = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$.\n2. For an affine image triangle $T$ with vertices $\\boldsymbol{x}_1$, $\\boldsymbol{x}_2$, $\\boldsymbol{x}_3$, compute numerically the scalar curl of the mapped field $\\boldsymbol{v} = J^{-\\top}\\hat{\\boldsymbol{v}} \\circ F^{-1}$ using the chain rule. Concretely, if $\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}}$ is the $2\\times 2$ Jacobian of $\\hat{\\boldsymbol{v}}$ with respect to $\\hat{\\boldsymbol{x}}$, then compute\n$$\n\\nabla_{\\boldsymbol{x}}\\boldsymbol{v} = J^{-\\top}\\,(\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}})\\,J^{-1},\n$$\nand extract $\\mathrm{curl}\\,\\boldsymbol{v}$ as $\\left(\\nabla_{\\boldsymbol{x}}\\boldsymbol{v}\\right)_{21} - \\left(\\nabla_{\\boldsymbol{x}}\\boldsymbol{v}\\right)_{12}$.\n3. Implement the discrete curl operator on a single triangle as follows. The oriented integral of the curl equals the oriented sum of edge tangential degrees of freedom by Stokes’ theorem. For a single edge basis function, this integral equals $\\pm 1$ depending on whether the triangle orientation induced by the vertex order is counterclockwise or clockwise. The $L^2$ projection to $P_0(T)$ is the integral divided by the triangle area $|T|$. This produces a constant coefficient on $T$; treat $|T|$ as the positive area in $\\mathbb{R}^2$ and encode the orientation sign via $\\operatorname{sign}(\\det J)$.\n4. Verify the commuting-diagram property numerically by checking that the $L^2$-projected discrete curl computed in item $3$ matches the analytical curl computed in item $2$ for each basis and each triangle.\n5. Test suite. Use the following five triangles $T_k$ specified by their vertices $\\boldsymbol{x}_1$, $\\boldsymbol{x}_2$, $\\boldsymbol{x}_3$ in $\\mathbb{R}^2$:\n   - $T_1$: $(0,0)$, $(1,0)$, $(0,1)$.\n   - $T_2$: $(0,0)$, $(2,0)$, $(0,3)$.\n   - $T_3$: $(1,2)$, $(4,2.5)$, $(1.2,3.8)$.\n   - $T_4$: $(0,0)$, $(0,1)$, $(1,0)$.\n   - $T_5$: $(0,0)$, $(0.1,0)$, $(0,0.1)$.\n   For each triangle, test all three local edge bases $(1\\to 2)$, $(2\\to 3)$, $(3\\to 1)$.\n6. Quantifiable answers. For each case (triangle and edge), compute three scalars:\n   - the analytical curl on $T$ from item $2$,\n   - the discrete $P_0$ coefficient from item $3$,\n   - and, for reference, the analytical curl on $\\hat{T}$ from item $1$ mapped to $T$ using only the affine data.\n   Report for each case the maximum absolute difference among these three scalars as a float. A verification is considered successful for a case if this error is less than $10^{-12}$.\n7. Final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,\\dots,e_{15}]$), where each $e_m$ is the maximum absolute error for one case in the order of triangles $T_1,\\dots,T_5$ and edges $(1\\to 2)$, $(2\\to 3)$, $(3\\to 1)$ within each triangle.\n\nNo physical units are involved in this problem. All angles, if any appear implicitly through geometry, are in radians by default, but no explicit angle computations are required. All computations must be carried out in double precision floating point. The final answers are floats as specified above.", "solution": "The problem asks for a numerical verification of the commuting diagram property for the lowest-order Nédélec (first kind) curl-conforming finite element. This is a form of a patch test, a fundamental sanity check in finite element analysis. The verification involves comparing three different but analytically equivalent methods for computing the curl of a basis function on a physical triangular element $T$, which is an affine image of a reference triangle $\\hat{T}$. The problem is well-posed, scientifically grounded in the theory of computational electromagnetics, and provides all necessary definitions and data for a unique solution.\n\nFirst, we establish the analytical expressions for the basis functions and their curls on the reference element $\\hat{T}$. The reference triangle $\\hat{T}$ has vertices $\\hat{\\boldsymbol{x}}_1=(0,0)$, $\\hat{\\boldsymbol{x}}_2=(1,0)$, and $\\hat{\\boldsymbol{x}}_3=(0,1)$. The barycentric coordinates are $\\hat{\\lambda}_1 = 1 - \\hat{x} - \\hat{y}$, $\\hat{\\lambda}_2 = \\hat{x}$, and $\\hat{\\lambda}_3 = \\hat{y}$. Their gradients with respect to the reference coordinates $\\hat{\\boldsymbol{x}}=(\\hat{x}, \\hat{y})^\\top$ are constant vectors:\n$$\n\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}, \\quad\n\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_2 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad\n\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_3 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}.\n$$\nThe lowest-order Nédélec basis function associated with the oriented edge $(i \\to j)$ is given by $\\hat{\\boldsymbol{N}}_{ij} = \\hat{\\lambda}_i \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_j - \\hat{\\lambda}_j \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_i$. We compute the three basis functions for the local edges oriented counter-clockwise: $(1 \\to 2)$, $(2 \\to 3)$, and $(3 \\to 1)$.\n\n- For edge $(1 \\to 2)$:\n$$\n\\hat{\\boldsymbol{N}}_{12}(\\hat{\\boldsymbol{x}}) = \\hat{\\lambda}_1 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_2 - \\hat{\\lambda}_2 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_1 = (1-\\hat{x}-\\hat{y})\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - \\hat{x}\\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1-\\hat{y} \\\\ \\hat{x} \\end{pmatrix}.\n$$\n- For edge $(2 \\to 3)$:\n$$\n\\hat{\\boldsymbol{N}}_{23}(\\hat{\\boldsymbol{x}}) = \\hat{\\lambda}_2 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_3 - \\hat{\\lambda}_3 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_2 = \\hat{x}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} - \\hat{y}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\hat{y} \\\\ \\hat{x} \\end{pmatrix}.\n$$\n- For edge $(3 \\to 1)$:\n$$\n\\hat{\\boldsymbol{N}}_{31}(\\hat{\\boldsymbol{x}}) = \\hat{\\lambda}_3 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_1 - \\hat{\\lambda}_1 \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\lambda}_3 = \\hat{y}\\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} - (1-\\hat{x}-\\hat{y})\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\hat{y} \\\\ \\hat{x}-1 \\end{pmatrix}.\n$$\nThe scalar curl in two dimensions for a vector field $\\boldsymbol{v}=(v_x, v_y)^\\top$ is $\\mathrm{curl}\\,\\boldsymbol{v} = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$. The curls of the reference basis functions are:\n$$\n\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\,\\hat{\\boldsymbol{N}}_{12} = \\frac{\\partial}{\\partial \\hat{x}}(\\hat{x}) - \\frac{\\partial}{\\partial \\hat{y}}(1-\\hat{y}) = 1 - (-1) = 2.\n$$\n$$\n\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\,\\hat{\\boldsymbol{N}}_{23} = \\frac{\\partial}{\\partial \\hat{x}}(\\hat{x}) - \\frac{\\partial}{\\partial \\hat{y}}(-\\hat{y}) = 1 - (-1) = 2.\n$$\n$$\n\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\,\\hat{\\boldsymbol{N}}_{31} = \\frac{\\partial}{\\partial \\hat{x}}(\\hat{x}-1) - \\frac{\\partial}{\\partial \\hat{y}}(-\\hat{y}) = 1 - (-1) = 2.\n$$\nAll three basis functions have a constant curl of $2$ on the reference element $\\hat{T}$.\n\nNext, we consider the affine mapping $F: \\hat{T} \\to T$, where $\\boldsymbol{x} = F(\\hat{\\boldsymbol{x}}) = \\boldsymbol{x}_1 + J\\hat{\\boldsymbol{x}}$. The Jacobian matrix of this transformation, $J$, is constant and given by $J = [\\boldsymbol{x}_2 - \\boldsymbol{x}_1, \\boldsymbol{x}_3 - \\boldsymbol{x}_1]$. A curl-conforming vector field $\\hat{\\boldsymbol{v}}$ on $\\hat{T}$ transforms to a field $\\boldsymbol{v}$ on $T$ via the covariant Piola transformation: $\\boldsymbol{v}(\\boldsymbol{x}) = (J^{-1})^\\top \\hat{\\boldsymbol{v}}(F^{-1}(\\boldsymbol{x}))$.\n\nThe problem requires computing the curl of the mapped basis functions on $T$ in three ways. Let's denote the curl of $\\boldsymbol{v}$ on $T$ as $C$.\n\n1.  **Analytical curl via chain rule:** The Jacobian of the mapped field $\\boldsymbol{v}$ with respect to coordinates $\\boldsymbol{x}$ is $\\nabla_{\\boldsymbol{x}}\\boldsymbol{v} = (J^{-1})^\\top (\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}}) J^{-1}$. The Jacobians of the reference basis functions, $\\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{N}}_{ij}$, are all identical:\n    $$\n    \\hat{K} = \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{N}}_{12} = \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{N}}_{23} = \\nabla_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{N}}_{31} = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}.\n    $$\n    Let $V = \\nabla_{\\boldsymbol{x}}\\boldsymbol{v}$. The curl is $C_1 = V_{21} - V_{12}$. Analytically, with $A = J^{-1}$, this is $(A^\\top \\hat{K} A)_{21} - (A^\\top \\hat{K} A)_{12} = \\det(A) - (-\\det(A)) = 2\\det(A) = 2/\\det(J)$.\n\n2.  **Discrete $P_0$ curl:** The $L^2$-projection of $\\mathrm{curl}\\,\\boldsymbol{v}$ onto the space of constant functions on $T$, $P_0(T)$, is given by $(\\int_T \\mathrm{curl}\\,\\boldsymbol{v}\\,dA) / |T|$, where $|T|$ is the area of triangle $T$. Using a change of variables and the curl transformation rule $\\mathrm{curl}_{\\boldsymbol{x}}\\boldsymbol{v} = (\\det J)^{-1} \\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}}$, we have:\n    $$\n    \\int_T \\mathrm{curl}\\,\\boldsymbol{v}\\,dA = \\int_{\\hat{T}} \\frac{\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}}}{\\det J} |\\det J| \\,d\\hat{A} = \\operatorname{sign}(\\det J) \\int_{\\hat{T}} \\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}} \\,d\\hat{A}.\n    $$\n    Since $\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}} = 2$ and the area of $\\hat{T}$ is $1/2$, the integral becomes $\\operatorname{sign}(\\det J) \\times 2 \\times (1/2) = \\operatorname{sign}(\\det J)$. The discrete curl coefficient is therefore $C_2 = \\operatorname{sign}(\\det J) / |T|$. As the area $|T| = (1/2)|\\det J|$, this simplifies to $C_2 = \\operatorname{sign}(\\det J) / ( (1/2) |\\det J| ) = 2/\\det J$.\n\n3.  **Mapped analytical curl from $\\hat{T}$:** This third value is computed using the direct transformation rule for the scalar curl field: $C_3 = (\\det J)^{-1} \\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}}$. Since $\\mathrm{curl}_{\\hat{\\boldsymbol{x}}}\\hat{\\boldsymbol{v}} = 2$, we get $C_3 = 2/\\det J$.\n\nAll three methods yield the identical analytical result $C = 2/\\det J$. The numerical test verifies that their floating-point implementations produce results that are equal to within a small tolerance, thus confirming the correctness of the implementation of these fundamental FEM concepts. The code will compute these three values for each test case (a specific triangle and a basis function) and report the maximum absolute difference among them. Since the analytical results are independent of the choice of edge basis function, the computation for edges $(1 \\to 2)$, $(2 \\to 3)$, and $(3 \\to 1)$ on a given triangle will be identical, but we perform the loop as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a patch test for lowest-order Nédélec curl-conforming elements.\n    \n    This function verifies the commuting diagram property by computing the curl\n    of Nédélec basis functions on several affine triangular elements using three\n    different but analytically equivalent methods. It then calculates the maximum\n    absolute difference between the results of these methods for each test case.\n    \"\"\"\n\n    # Define the 5 test triangles by their vertices (x1, x2, x3)\n    test_cases = [\n        # T1: Reference triangle\n        ((0.0, 0.0), (1.0, 0.0), (0.0, 1.0)),\n        # T2: Scaled triangle\n        ((0.0, 0.0), (2.0, 0.0), (0.0, 3.0)),\n        # T3: Generic affine triangle\n        ((1.0, 2.0), (4.0, 2.5), (1.2, 3.8)),\n        # T4: Flipped orientation\n        ((0.0, 0.0), (0.0, 1.0), (1.0, 0.0)),\n        # T5: Small-scale triangle\n        ((0.0, 0.0), (0.1, 0.0), (0.0, 0.1)),\n    ]\n\n    # The local edges are (1->2), (2->3), (3->1). The calculations are\n    # identical for all three on a given triangle, but the loop is\n    # performed to match the problem's case structure.\n    edge_indices = [(1, 2), (2, 3), (3, 1)]\n\n    # The Jacobian of the reference basis functions is constant\n    # K_hat = [[d(vx)/dx, d(vx)/dy], [d(vy)/dx, d(vy)/dy]]\n    K_hat = np.array([[0.0, -1.0], [1.0, 0.0]])\n    \n    # The curl of the reference basis functions is constant\n    curl_hat = 2.0\n    \n    results = []\n\n    for vertices in test_cases:\n        x1 = np.array(vertices[0], dtype=np.float64)\n        x2 = np.array(vertices[1], dtype=np.float64)\n        x3 = np.array(vertices[2], dtype=np.float64)\n\n        # The Jacobian of the affine map x = x1 + J * x_hat\n        # J = [x2 - x1, x3 - x1]\n        J = np.array([x2 - x1, x3 - x1]).T\n\n        det_J = np.linalg.det(J)\n        \n        # Guard against degenerate triangles\n        if np.abs(det_J) < 1e-15:\n            # For the given test cases, this path is not taken.\n            # Assigning an arbitrary large error for a degenerate case.\n            error = 1.0\n            for _ in edge_indices:\n                results.append(error)\n            continue\n\n        J_inv = np.linalg.inv(J)\n        \n        # The positive area of the triangle T\n        area_T = 0.5 * np.abs(det_J)\n\n        for _ in edge_indices:\n            # The calculation is the same for all 3 basis functions of the element.\n            \n            # Method 1: Analytical curl from the Jacobian of the mapped field\n            # curl(v) = (grad(v)_21 - grad(v)_12)\n            # grad(v) = (J^-T) * K_hat * (J^-1)\n            grad_v = J_inv.T @ K_hat @ J_inv\n            curl_method1 = grad_v[1, 0] - grad_v[0, 1]\n            \n            # Method 2: Discrete P0 curl from Stokes' theorem\n            # curl_P0 = ( oriented_integral_of_curl / area )\n            # oriented_integral_of_curl = sign(det(J))\n            curl_method2 = np.sign(det_J) / area_T\n            \n            # Method 3: Mapped analytical curl from the reference element\n            # curl(v) = curl(v_hat) / det(J)\n            curl_method3 = curl_hat / det_J\n            \n            # Calculate the maximum absolute difference between the three methods\n            max_abs_diff = max(\n                np.abs(curl_method1 - curl_method2),\n                np.abs(curl_method1 - curl_method3),\n                np.abs(curl_method2 - curl_method3)\n            )\n            results.append(max_abs_diff)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3297150"}, {"introduction": "With a robust discrete framework in place, we can solve practical problems in vector calculus. This exercise applies the concepts of discrete operators to implement a discrete Helmholtz-Hodge decomposition, which separates any vector field into a curl-free (gradient) component and a divergence-free component. This practice [@problem_id:3297121] translates the continuous variational problem into a concrete linear system involving the graph Laplacian, demonstrating how to use the $H(\\mathrm{curl})$-conforming framework to perform fundamental field analysis on unstructured meshes.", "problem": "You are asked to design and implement a discrete algorithm for the Helmholtz decomposition in the curl-conforming Sobolev space $H(\\mathrm{curl})$ on an unstructured mesh. Starting from fundamental definitions, derive a variational characterization of the decomposition and translate it into a graph-based linear algebra formulation that acts on edge-integrated degrees of freedom. The goal is to numerically separate a discrete vector field $\\mathbf{E}$ into a gradient component and an orthogonal curl-conforming complement.\n\nFundamental base and definitions to use:\n- The curl-conforming Sobolev space $H(\\mathrm{curl})$ on a domain $\\Omega \\subset \\mathbb{R}^3$ is defined as $H(\\mathrm{curl};\\Omega) = \\{\\mathbf{v} \\in (L^2(\\Omega))^3 : \\nabla \\times \\mathbf{v} \\in (L^2(\\Omega))^3\\}$, with analogous two-dimensional specialization when needed.\n- The Helmholtz decomposition in $H(\\mathrm{curl})$ expresses $\\mathbf{E} = \\nabla \\phi + \\mathbf{E}_\\perp$, where $\\phi \\in H^1(\\Omega)$ and $\\mathbf{E}_\\perp$ is orthogonal to gradients under a suitable inner product, i.e., $(\\mathbf{E}_\\perp, \\nabla \\psi) = 0$ for all $\\psi \\in H^1(\\Omega)$, where $(\\cdot,\\cdot)$ denotes the $L^2$ inner product.\n- On an unstructured mesh, represent discrete fields by edge-integrated degrees of freedom $\\int_e \\mathbf{E} \\cdot \\mathbf{t}\\, \\mathrm{d}s$ for each oriented edge $e$ with unit tangent $\\mathbf{t}$. For nodal scalar potentials $\\phi$, the discrete gradient along an oriented edge $(i \\to j)$ is the potential difference $\\phi_j - \\phi_i$.\n- The discrete incidence operator $B$ maps nodal potentials to edge differences: if an edge $e$ is oriented from node $i$ to node $j$, then $B_{e,i}=-1$ and $B_{e,j}=+1$. The discrete gradient subspace is $\\mathrm{range}(B)$, and discrete orthogonality to gradients is enforced by requiring $B^\\top W \\mathbf{E}_\\perp = \\mathbf{0}$ for a symmetric positive-definite edge-weight matrix $W$ that encodes the inner product on edges. In this problem, use $W = I$, the identity matrix, to define the discrete inner product on edge degrees of freedom as $(\\mathbf{u},\\mathbf{v}) = \\sum_e u_e v_e$.\n\nDerivation target:\n- Starting from the orthogonality condition $(\\mathbf{E}-B\\phi, B\\psi) = 0$ for all discrete test potentials $\\psi$, derive the normal equations $B^\\top B \\phi = B^\\top \\mathbf{E}$ for the nodal potential $\\phi$ (up to an additive constant). From $\\phi$, recover the gradient component $B\\phi$ and the curl-conforming complement $\\mathbf{E}_\\perp = \\mathbf{E} - B\\phi$. Discuss and justify the need to fix a gauge (e.g., pin one node to zero potential) to make the linear system nonsingular.\n\nAlgorithmic requirements:\n- Implement the discrete Helmholtz decomposition on an unstructured mesh with the above representation. Pin a single node (choose any node) to fix the gauge and solve the reduced linear system for $\\phi$.\n- Produce the gradient component and orthogonal complement and verify the orthogonality $B^\\top \\mathbf{E}_\\perp \\approx \\mathbf{0}$ numerically.\n\nMesh and test suite:\n- Use the following unstructured mesh in two dimensions with $N$ nodes and a set of oriented edges. Nodes have coordinates (dimensionless units):\n  - Node $0$: $(0.0,\\, 0.0)$\n  - Node $1$: $(1.0,\\, 0.0)$\n  - Node $2$: $(0.2,\\, 0.8)$\n  - Node $3$: $(1.1,\\, 0.9)$\n  - Node $4$: $(-0.2,\\, 0.9)$\n  - Node $5$: $(0.5,\\, -0.1)$\n  - Node $6$: $(0.8,\\, 0.5)$\n- Oriented edges (each oriented from the smaller node index to the larger): $(0,1)$, $(0,2)$, $(0,5)$, $(1,2)$, $(1,3)$, $(1,5)$, $(1,6)$, $(2,3)$, $(2,4)$, $(2,6)$, $(3,6)$, $(5,6)$.\n- Define the following discrete fields for three test cases, all expressed as edge-integrated degrees of freedom:\n  1. Mixed field: Let the nodal potential be $\\phi_i = \\sin(\\pi x_i) + 0.3\\, y_i$ at node $i$ with coordinates $(x_i, y_i)$. Define the gradient component along each oriented edge $(i,j)$ as $\\phi_j - \\phi_i$. Superimpose a solenoidal circulation along the closed loop of nodes $[0,1,6,3,2,0]$ with constant edge value amplitude $0.7$ along the loop direction; for an oriented edge used in the loop opposite to its stored orientation, assign the negative of the amplitude. The total field $\\mathbf{E}$ is the sum of the gradient and solenoidal components.\n  2. Pure gradient field: Use the same $\\phi_i$ as above and set $\\mathbf{E}$ equal to the discrete gradient component $B\\phi$ (no solenoidal circulation added).\n  3. Pure solenoidal field: Use only the circulation along the loop $[0,1,6,3,2,0]$ with amplitude $0.7$ (no gradient component).\n\nOutput specification:\n- For each test case, compute the discrete Helmholtz decomposition using $W=I$, pin node $0$ to $\\phi_0 = 0$, solve for $\\phi$, form $B\\phi$, and compute $\\mathbf{E}_\\perp = \\mathbf{E} - B\\phi$.\n- Report the following aggregated metrics across the test suite:\n  - For the mixed field (test case $1$): the orthogonality residual ratio $r_{\\mathrm{orth}} = \\|B^\\top \\mathbf{E}_\\perp\\|_2 / (\\|B^\\top \\mathbf{E}\\|_2 + \\varepsilon)$, and the reconstruction residual ratio $r_{\\mathrm{rec}} = \\|\\mathbf{E} - (B\\phi + \\mathbf{E}_\\perp)\\|_2 / \\|\\mathbf{E}\\|_2$, where $\\varepsilon$ is a small positive constant to avoid division by zero in edge cases; take $\\varepsilon = 10^{-12}$.\n  - For the pure gradient field (test case $2$): a boolean indicating whether the relative norm of the complement $\\|\\mathbf{E}_\\perp\\|_2 / \\|\\mathbf{E}\\|_2$ is less than $10^{-10}$.\n  - For the pure solenoidal field (test case $3$): a boolean indicating whether the relative norm of the gradient component $\\|B\\phi\\|_2 / \\|\\mathbf{E}\\|_2$ is less than $10^{-10}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r_{\\mathrm{orth}}, r_{\\mathrm{rec}}, \\text{bool\\_case2}, \\text{bool\\_case3}]$.\n\nAll quantities are dimensionless; do not introduce any physical units. Angles appear only inside the definition of $\\phi_i$ via the sine function and are evaluated in radians.", "solution": "The problem asks for the design and implementation of a discrete Helmholtz decomposition algorithm for a vector field defined on an unstructured mesh. The field is represented by its edge-integrated degrees of freedom. The decomposition separates the field $\\mathbf{E}$ into a pure gradient (curl-free) component $\\mathbf{E}_{\\nabla}$ and an orthogonal complement $\\mathbf{E}_{\\perp}$ that is curl-conforming (in this discrete context, divergence-free). The foundation of the method lies in a variational principle that is translated into a system of linear equations.\n\nLet the set of nodes be $\\mathcal{N}$ and the set of oriented edges be $\\mathcal{E}$, with cardinalities $N_n=|\\mathcal{N}|$ and $N_e=|\\mathcal{E}|$, respectively. A discrete scalar potential is a vector $\\phi \\in \\mathbb{R}^{N_n}$, assigning a value to each node. A discrete vector field is a vector $\\mathbf{E} \\in \\mathbb{R}^{N_e}$, assigning a value to each edge.\n\nThe discrete gradient operator is represented by the incidence matrix $B \\in \\mathbb{R}^{N_e \\times N_n}$. For an edge $e \\in \\mathcal{E}$ oriented from node $i$ to node $j$, the corresponding row of $B$ has entries $B_{e,i} = -1$ and $B_{e,j} = +1$, and $0$ otherwise. The gradient of a nodal potential $\\phi$ is an edge field given by $\\mathbf{E}_{\\nabla} = B\\phi$. This is the discrete analogue of taking the gradient of a scalar function.\n\nThe discrete Helmholtz decomposition is written as:\n$$ \\mathbf{E} = B\\phi + \\mathbf{E}_{\\perp} $$\nwhere $\\mathbf{E}_{\\nabla} = B\\phi$ is the gradient component and $\\mathbf{E}_{\\perp}$ is its orthogonal complement. The problem defines the inner product on the space of edge fields $\\mathbb{R}^{N_e}$ as $(\\mathbf{u}, \\mathbf{v}) = \\mathbf{u}^\\top \\mathbf{v}$, corresponding to the weight matrix $W=I$.\n\nThe defining property of the decomposition is that $\\mathbf{E}_{\\perp}$ must be orthogonal to the entire subspace of gradient fields, which is the range of the operator $B$. This means $(\\mathbf{E}_{\\perp}, B\\psi) = 0$ for all possible nodal potential vectors $\\psi \\in \\mathbb{R}^{N_n}$. Substituting $\\mathbf{E}_{\\perp} = \\mathbf{E} - B\\phi$, we formulate the variational problem: find $\\phi \\in \\mathbb{R}^{N_n}$ such that\n$$ (\\mathbf{E} - B\\phi, B\\psi) = 0 \\quad \\forall \\psi \\in \\mathbb{R}^{N_n} $$\nUsing the inner product definition and properties of the matrix transpose, this becomes:\n$$ (B\\psi)^\\top (\\mathbf{E} - B\\phi) = 0 $$\n$$ \\psi^\\top B^\\top (\\mathbf{E} - B\\phi) = 0 $$\nSince this must hold for any vector $\\psi$, the term in the parenthesis must be the zero vector. This yields the normal equations for the potential $\\phi$:\n$$ B^\\top (\\mathbf{E} - B\\phi) = \\mathbf{0} \\implies B^\\top B \\phi = B^\\top \\mathbf{E} $$\nThe matrix $L = B^\\top B$ is the graph Laplacian. It is a symmetric, positive semi-definite matrix. For any connected graph, $L$ has a one-dimensional nullspace spanned by the constant vector $\\mathbf{1} = [1, 1, \\dots, 1]^\\top$. This is because the gradient of a constant potential is zero: $B(c\\mathbf{1}) = \\mathbf{0}$ for any scalar $c$. Therefore, $L(c\\mathbf{1}) = B^\\top B (c\\mathbf{1}) = \\mathbf{0}$. The singularity of $L$ implies that the system $L\\phi = B^\\top\\mathbf{E}$ does not have a unique solution; if $\\phi^*$ is a solution, so is $\\phi^* + c\\mathbf{1}$.\n\nTo obtain a unique solution for $\\phi$, we must \"fix the gauge\" by imposing an additional constraint. A standard choice is to pin the potential of one node to a constant value, for instance, $\\phi_0 = 0$. This removes the ambiguity. To implement this, we remove the row and column corresponding to node $0$ from the matrix $L$, and the corresponding entry from the vectors $\\phi$ and $B^\\top\\mathbf{E}$. Let $L_R$ be the resulting reduced $(N_n-1) \\times (N_n-1)$ matrix, and let $\\phi_R$ and $(B^\\top\\mathbf{E})_R$ be the reduced vectors. The modified system is:\n$$ L_R \\phi_R = (B^\\top\\mathbf{E})_R $$\nThe reduced matrix $L_R$ is invertible for a connected graph, yielding a unique solution for $\\phi_R$. The full potential vector $\\phi$ is then reconstructed by re-inserting $\\phi_0=0$.\n\nThe overall computational procedure is:\n1.  Construct the incidence matrix $B$ from the mesh topology.\n2.  Define the input edge field $\\mathbf{E}$ for each test case.\n3.  Compute the graph Laplacian $L = B^\\top B$ and the right-hand side vector $\\mathbf{f} = B^\\top \\mathbf{E}$.\n4.  Apply the gauge-fixing condition ($\\phi_0=0$) by forming the reduced system $L_R \\phi_R = \\mathbf{f}_R$.\n5.  Solve the reduced linear system for $\\phi_R$.\n6.  Reconstruct the full potential vector $\\phi$.\n7.  Compute the gradient component $\\mathbf{E}_{\\nabla} = B\\phi$.\n8.  Compute the orthogonal complement $\\mathbf{E}_{\\perp} = \\mathbf{E} - \\mathbf{E}_{\\nabla}$.\n9.  Finally, evaluate the specified quality metrics for each test case to verify the correctness of the decomposition. The orthogonality residual ratio $r_{\\mathrm{orth}} = \\|B^\\top \\mathbf{E}_\\perp\\|_2 / (\\|B^\\top \\mathbf{E}\\|_2 + \\varepsilon)$ should be small, confirming that $\\mathbf{E}_\\perp$ is discretely divergence-free. The reconstruction residual $r_{\\mathrm{rec}} = \\|\\mathbf{E} - (\\mathbf{E}_{\\nabla} + \\mathbf{E}_\\perp)\\|_2 / \\|\\mathbf{E}\\|_2$ should be on the order of machine precision.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the discrete Helmholtz decomposition on a given\n    unstructured mesh.\n    \"\"\"\n    # Define mesh and constants\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0\n        [1.0, 0.0],  # Node 1\n        [0.2, 0.8],  # Node 2\n        [1.1, 0.9],  # Node 3\n        [-0.2, 0.9], # Node 4\n        [0.5, -0.1], # Node 5\n        [0.8, 0.5],  # Node 6\n    ])\n    num_nodes = nodes.shape[0]\n\n    # Edges are oriented from smaller to larger node index\n    edges = [\n        (0, 1), (0, 2), (0, 5), (1, 2), (1, 3), (1, 5), \n        (1, 6), (2, 3), (2, 4), (2, 6), (3, 6), (5, 6)\n    ]\n    num_edges = len(edges)\n    edge_map = {edge: i for i, edge in enumerate(edges)}\n\n    epsilon = 1e-12\n\n    # 1. Construct the incidence matrix B\n    B = np.zeros((num_edges, num_nodes))\n    for i, (u, v) in enumerate(edges):\n        B[i, u] = -1\n        B[i, v] = 1\n\n    # --- Test Case Field Generation ---\n\n    # Base potential for gradient fields\n    phi_true = np.sin(np.pi * nodes[:, 0]) + 0.3 * nodes[:, 1]\n    \n    # Gradient component (used in cases 1 and 2)\n    E_grad_true = B @ phi_true\n\n    # Solenoidal component (used in cases 1 and 3)\n    # Circulation along loop [0, 1, 6, 3, 2, 0] with amplitude 0.7\n    E_sol = np.zeros(num_edges)\n    amplitude = 0.7\n    loop_edges_oriented = [(0, 1), (1, 6), (6, 3), (3, 2), (2, 0)]\n    \n    for u, v in loop_edges_oriented:\n        if (u, v) in edge_map:\n            E_sol[edge_map[(u, v)]] += amplitude\n        elif (v, u) in edge_map:\n            E_sol[edge_map[(v, u)]] -= amplitude\n        # else: This case is not expected for the given mesh and loop\n    \n    test_fields = {\n        1: E_grad_true + E_sol, # Mixed field\n        2: E_grad_true,           # Pure gradient field\n        3: E_sol                  # Pure solenoidal field\n    }\n\n    # --- Decomposition and Metric Calculation ---\n    results = []\n\n    def perform_decomposition(E):\n        \"\"\"Solves for the potential and returns the decomposed fields.\"\"\"\n        # 3. Compute L and f\n        L = B.T @ B\n        f = B.T @ E\n\n        # 4. Apply gauge fixing (pin node 0 to 0)\n        # We solve for nodes 1 to N-1\n        pinned_node = 0\n        active_nodes = list(range(num_nodes))\n        active_nodes.remove(pinned_node)\n        \n        L_reduced = L[np.ix_(active_nodes, active_nodes)]\n        f_reduced = f[active_nodes]\n\n        # 5. Solve the reduced system\n        phi_reduced = np.linalg.solve(L_reduced, f_reduced)\n\n        # 6. Reconstruct full potential vector\n        phi = np.zeros(num_nodes)\n        phi[active_nodes] = phi_reduced\n        \n        # 7. & 8. Compute gradient and orthogonal components\n        E_grad = B @ phi\n        E_perp = E - E_grad\n        \n        return E_grad, E_perp\n\n    # Case 1: Mixed field\n    E1 = test_fields[1]\n    E1_grad, E1_perp = perform_decomposition(E1)\n    \n    # Orthogonality residual ratio\n    orth_num = np.linalg.norm(B.T @ E1_perp)\n    orth_den = np.linalg.norm(B.T @ E1) + epsilon\n    r_orth = orth_num / orth_den\n    results.append(r_orth)\n    \n    # Reconstruction residual ratio\n    rec_num = np.linalg.norm(E1 - (E1_grad + E1_perp))\n    rec_den = np.linalg.norm(E1)\n    r_rec = rec_num / rec_den if rec_den > 0 else 0.0\n    results.append(r_rec)\n    \n    # Case 2: Pure gradient field\n    E2 = test_fields[2]\n    _, E2_perp = perform_decomposition(E2)\n    \n    norm_E2 = np.linalg.norm(E2)\n    relative_norm_perp = np.linalg.norm(E2_perp) / norm_E2 if norm_E2 > 0 else 0.0\n    bool_case2 = relative_norm_perp < 1e-10\n    results.append(bool_case2)\n    \n    # Case 3: Pure solenoidal field\n    E3 = test_fields[3]\n    E3_grad, _ = perform_decomposition(E3)\n    \n    norm_E3 = np.linalg.norm(E3)\n    relative_norm_grad = np.linalg.norm(E3_grad) / norm_E3 if norm_E3 > 0 else 0.0\n    bool_case3 = relative_norm_grad < 1e-10\n    results.append(bool_case3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3297121"}]}