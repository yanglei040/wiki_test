{"hands_on_practices": [{"introduction": "A correct numerical implementation begins with a solid theoretical foundation. This practice guides you through the essential process of deriving the weak formulation for the Helmholtz equation and understanding its inherent symmetry, a property known as reciprocity. You will then translate this theoretical principle into a powerful numerical test to verify your Finite Element Method (FEM) code and detect common implementation errors [@problem_id:3360923].", "problem": "Consider the scalar Helmholtz boundary value problem that arises as a model reduction of time-harmonic electromagnetic wave propagation in a lossless, inhomogeneous, one-dimensional medium. Let $\\Omega = (0,1)$ and let $a(x)$ and $b(x)$ be real-valued, bounded, strictly positive coefficient functions representing effective material parameters. For a given real wavenumber $k \\in \\mathbb{R}$ and a given source function $f \\in L^2(\\Omega)$, the strong form is: find $u:\\Omega \\to \\mathbb{R}$ such that\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\quad u(1)=0,\n$$\nwhere all quantities are dimensionless. \n\n1) Starting from the divergence theorem and the definition of the Sobolev space $H_0^1(\\Omega)$, derive the weak form: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\nMake precise which properties of $a(x)$, $b(x)$, and the boundary conditions ensure that the bilinear form\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\nis symmetric. Explain, from first principles, why this symmetry implies a reciprocity identity between any two weak solutions $u_1,u_2 \\in H_0^1(\\Omega)$ corresponding to sources $f_1,f_2 \\in L^2(\\Omega)$:\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx.\n$$\n\n2) Consider the conforming Galerkin Finite Element Method (FEM) using globally continuous, piecewise linear basis functions on a uniform mesh with $N$ elements. Let $\\{\\phi_i(x)\\}_{i=0}^N$ denote the standard nodal basis on the partition of $[0,1]$ with nodes $0=x_0 < x_1 < \\cdots < x_N = 1$. Using midpoint quadrature for elementwise assembly, define the element matrices and vectors to assemble the global matrix\n$$\nA \\equiv K - k^2 M,\n$$\nwith stiffness matrix entries $K_{ij} \\approx \\int_0^1 a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx$ and mass matrix entries $M_{ij} \\approx \\int_0^1 b(x)\\, \\phi_i(x)\\, \\phi_j(x)\\, dx$, and the load vector entries $b_i \\approx \\int_0^1 f(x)\\, \\phi_i(x)\\, dx$. Enforce homogeneous Dirichlet boundary conditions strongly at the endpoints. Show from the algebra of the assembled system that, when $A$ is symmetric and both discrete solutions $U^{(1)}$ and $U^{(2)}$ satisfy $A U^{(m)} = b^{(m)}$ with the same $A$, the following discrete reciprocity identity holds exactly in finite precision arithmetic up to linear solver roundoff:\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}.\n$$\n\n3) Construct a numerical test that detects implementation errors violating reciprocity in the discrete setting by computing the discrepancy\n$$\nr \\equiv \\left| \\left(U^{(2)}\\right)^\\top b^{(1)} - \\left(U^{(1)}\\right)^\\top b^{(2)} \\right|.\n$$\nImplement a self-contained program that:\n- Assembles the one-dimensional piecewise linear FEM system with midpoint quadrature.\n- Solves two discrete problems with sources $f_1$ and $f_2$.\n- Reports the reciprocity discrepancy $r$.\n\nYour program must evaluate the following test suite and output the four discrepancies as floating-point numbers. All quantities are dimensionless.\n\n- Test 1 (happy path, smooth coefficients and sources):\n  - $N = 64$, $k = 7.3$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = \\sin(3\\pi x)$, $f_2(x) = \\cos(5\\pi x)$,\n  - both solves use the same assembled matrix $A$.\n\n- Test 2 (heterogeneous coefficient, smooth localized sources):\n  - $N = 64$, $k = 4.2$,\n  - $a(x) = 1$ for $x < 0.5$ and $a(x) = 3$ for $x \\ge 0.5$, $b(x) = 1$,\n  - $f_1(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right)$, $f_2(x) = \\exp\\!\\left(-120\\,(x-0.7)^2\\right)$,\n  - both solves use the same assembled matrix $A$.\n\n- Test 3 (boundary-size mesh, coarse discretization edge case):\n  - $N = 2$, $k = 2.0$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = x\\,(1-x)$, $f_2(x) = 1 - 2x$,\n  - both solves use the same assembled matrix $A$.\n\n- Test 4 (intentional reciprocity violation via a skew perturbation modeling an assembly bug):\n  - Start from the same configuration as Test 1.\n  - After assembling the symmetric matrix $A$, create a perturbed matrix $\\tilde{A}$ by adding a skew perturbation $\\varepsilon = 10^{-2}$ to a single off-diagonal interior entry: $\\tilde{A}_{p,p+1} \\leftarrow \\tilde{A}_{p,p+1} + \\varepsilon$ for $p = \\lfloor N/2 \\rfloor$, without applying the corresponding change to $\\tilde{A}_{p+1,p}$.\n  - Solve $A U^{(1)} = b^{(1)}$ and $\\tilde{A} U^{(2)} = b^{(2)}$.\n  - Compute $r$ with $U^{(1)},U^{(2)},b^{(1)},b^{(2)}$. This configuration should yield a discrepancy several orders of magnitude larger than in Tests 1–3.\n\nFinal output format: Your program should produce a single line of output containing the four reciprocity discrepancies as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). Each $r_m$ must be a floating-point number. No additional text should be printed. The problem is fully dimensionless; no physical units are required, and no angles are involved.", "solution": "The problem asks for a theoretical derivation and numerical verification of the reciprocity principle for the one-dimensional scalar Helmholtz equation. We will first validate the problem statement and then proceed with a detailed solution.\n\n### Part 1: Derivation of the Weak Form and Reciprocity Identity\n\nThe strong form of the boundary value problem is to find a function $u:\\Omega \\to \\mathbb{R}$ on the domain $\\Omega = (0,1)$ that satisfies:\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\nsubject to homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$. The coefficients $a(x)$ and $b(x)$ are real-valued, bounded, and strictly positive, $k \\in \\mathbb{R}$ is the wavenumber, and $f \\in L^2(\\Omega)$ is the source term.\n\nTo derive the weak form, we employ the standard procedure of multiplying the differential equation by a test function $v$ and integrating over the domain $\\Omega$. The appropriate space for both the solution $u$ and the test function $v$ is the Sobolev space $H_0^1(\\Omega)$. This space consists of functions in $L^2(\\Omega)$ whose weak derivatives are also in $L^2(\\Omega)$ and which satisfy the homogeneous boundary conditions, i.e., $u(0)=v(0)=0$ and $u(1)=v(1)=0$.\n\nMultiplying the strong form by $v \\in H_0^1(\\Omega)$ and integrating gives:\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\nWe focus on the first term and apply integration by parts, which is the one-dimensional version of the divergence theorem: $\\int_\\Omega (\\nabla \\cdot \\mathbf{F}) \\phi \\, dV = -\\int_\\Omega \\mathbf{F} \\cdot (\\nabla \\phi) \\, dV + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$. In one dimension, this becomes $\\int_0^1 \\frac{dF}{dx} v \\, dx = [Fv]_0^1 - \\int_0^1 F\\frac{dv}{dx} \\, dx$.\nLetting $F(x) = -a(x)\\frac{du}{dx}$, we have:\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx = - \\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 + \\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\nThe boundary term $\\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 = a(1)\\frac{du}{dx}(1)v(1) - a(0)\\frac{du}{dx}(0)v(0)$ vanishes because the test function $v$ is in $H_0^1(\\Omega)$, which implies $v(0)=0$ and $v(1)=0$.\n\nSubstituting this back into the integrated equation, we obtain the weak form: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\nThis can be written in the abstract form $B(u,v) = L(v)$, where $B(u,v)$ is the bilinear form and $L(v)$ is the linear functional on the right-hand side.\n\nThe bilinear form $B(u,v)$ is defined as:\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\nFor $B(u,v)$ to be symmetric, we require $B(u,v) = B(v,u)$ for all $u,v \\in H_0^1(\\Omega)$. Let's examine $B(v,u)$:\n$$\nB(v,u) = \\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx - k^2 \\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx\n$$\nSince $u(x)$, $v(x)$, and their derivatives are scalar real-valued functions, and the coefficients $a(x)$ and $b(x)$ are also real-valued, the multiplication of these functions is commutative. That is, $u'(x)v'(x) = v'(x)u'(x)$ and $u(x)v(x) = v(x)u(x)$. Therefore:\n$$\n\\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx\n$$\n$$\n\\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx = \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\nThis demonstrates that $B(u,v) = B(v,u)$. The symmetry of the bilinear form is guaranteed because the problem deals with real-valued functions and coefficients.\n\nNow, we derive the reciprocity identity. Let $u_1, u_2 \\in H_0^1(\\Omega)$ be two weak solutions corresponding to two different source functions $f_1, f_2 \\in L^2(\\Omega)$, respectively. From the definition of a weak solution, they satisfy:\n1. $B(u_1, v) = \\int_0^1 f_1(x) v(x) dx$ for all $v \\in H_0^1(\\Omega)$.\n2. $B(u_2, v) = \\int_0^1 f_2(x) v(x) dx$ for all $v \\in H_0^1(\\Omega)$.\n\nSince $u_1, u_2 \\in H_0^1(\\Omega)$, they are valid test functions themselves. We can choose $v=u_2$ in the first equation and $v=u_1$ in the second equation:\n1. $B(u_1, u_2) = \\int_0^1 f_1(x) u_2(x) dx$\n2. $B(u_2, u_1) = \\int_0^1 f_2(x) u_1(x) dx$\n\nAs we have just shown, the bilinear form $B(\\cdot, \\cdot)$ is symmetric, leading to $B(u_1, u_2) = B(u_2, u_1)$. Equating the right-hand sides of the two expressions above yields the reciprocity identity:\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx\n$$\nThis identity states that the work done by the first source on the second solution equals the work done by the second source on the first solution.\n\n### Part 2: Discrete Formulation and Reciprocity\n\nWe discretize the problem using the conforming Galerkin Finite Element Method (FEM) with piecewise linear basis functions $\\phi_i(x)$ on a uniform mesh of $[0,1]$ with $N$ elements and step size $h=1/N$. The nodes are $x_i = i h$ for $i=0, \\dots, N$. The hat function $\\phi_i(x)$ is $1$ at node $x_i$ and $0$ at all other nodes.\n\nThe FEM solution $u_h(x)$ is sought in the finite-dimensional subspace $V_h \\subset H_0^1(\\Omega)$ spanned by the interior basis functions $\\{\\phi_i\\}_{i=1}^{N-1}$. The solution is expressed as a linear combination of these basis functions:\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\n$$\nwhere $U_j$ are the unknown coefficients, representing the value of the solution at the interior nodes $x_j$. Note that $U_0=0$ and $U_N=0$ are enforced strongly.\n\nThe Galerkin method requires the weak form to hold for all test functions $v_h \\in V_h$. We choose the basis functions themselves as test functions, $v = \\phi_i(x)$ for $i=1, \\dots, N-1$:\n$$\nB\\left(\\sum_{j=1}^{N-1} U_j \\phi_j, \\phi_i\\right) = L(\\phi_i) \\quad \\text{for } i=1, \\dots, N-1\n$$\nBy the linearity of the bilinear form, this becomes a system of linear equations:\n$$\n\\sum_{j=1}^{N-1} U_j B(\\phi_j, \\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx\n$$\nThis is the algebraic system $A U = b$, where $U = [U_1, \\dots, U_{N-1}]^\\top$ is the vector of unknown nodal values, and the matrix $A$ and vector $b$ (of size $(N-1) \\times (N-1)$ and $(N-1) \\times 1$ respectively) have entries:\n$$\nA_{ij} = B(\\phi_j, \\phi_i) = \\int_0^1 a(x) \\phi_j'(x) \\phi_i'(x) dx - k^2 \\int_0^1 b(x) \\phi_j(x) \\phi_i(x) dx\n$$\n$$\nb_i = \\int_0^1 f(x) \\phi_i(x) dx\n$$\nThe problem specifies midpoint quadrature for assembling the system. For an element $e_m = [x_{m-1}, x_m]$ with midpoint $x_{m-1/2} = (x_{m-1}+x_m)/2$:\n- The element stiffness matrix $K^{(m)}$ has local entries $K_{ij}^{(m)} \\approx h \\cdot a(x_{m-1/2}) \\phi_j'(x_{m-1/2}) \\phi_i'(x_{m-1/2})$. The derivatives of local linear basis functions are constant, $\\pm 1/h$. This leads to the symmetric element matrix: $K^{(m)} \\approx \\frac{a(x_{m-1/2})}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$.\n- The element mass matrix $M^{(m)}$ has local entries $M_{ij}^{(m)} \\approx h \\cdot b(x_{m-1/2}) \\phi_j(x_{m-1/2}) \\phi_i(x_{m-1/2})$. At the element midpoint, the local basis functions both have value $1/2$. This leads to the symmetric element matrix: $M^{(m)} \\approx \\frac{h \\cdot b(x_{m-1/2})}{4} \\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix}$.\n- The element load vector $b^{(m)}$ has entries $b_i^{(m)} \\approx h \\cdot f(x_{m-1/2}) \\phi_i(x_{m-1/2})$. This gives $b^{(m)} \\approx \\frac{h \\cdot f(x_{m-1/2})}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$.\n\nThe global matrices $K$ and $M$ are formed by summing up these symmetric element contributions. The sum of symmetric matrices is symmetric, so $K$ and $M$ are symmetric. Consequently, the system matrix $A = K - k^2 M$ is also symmetric, i.e., $A = A^\\top$.\n\nNow, let's derive the discrete reciprocity identity. Consider two discrete problems with the same matrix $A$ but different sources $b^{(1)}$ and $b^{(2)}$:\n1. $A U^{(1)} = b^{(1)}$\n2. $A U^{(2)} = b^{(2)}$\nWe want to show that $(U^{(2)})^\\top b^{(1)} = (U^{(1)})^\\top b^{(2)}$.\nStarting with the left-hand side, substitute $b^{(1)}$ from the first equation:\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(2)}\\right)^\\top \\left(A U^{(1)}\\right)\n$$\nUsing the transpose property $(XY)^\\top = Y^\\top X^\\top$, we can write this as:\n$$\n\\left(U^{(2)}\\right)^\\top A U^{(1)} = \\left(U^{(2)}\\right)^\\top A^\\top U^{(1)} = \\left(A U^{(2)}\\right)^\\top U^{(1)}\n$$\nThis step relies on the symmetry of $A$, i.e., $A = A^\\top$. Now, substitute $A U^{(2)} = b^{(2)}$ from the second equation:\n$$\n\\left(A U^{(2)}\\right)^\\top U^{(1)} = \\left(b^{(2)}\\right)^\\top U^{(1)}\n$$\nFinally, since the product of a row vector and a column vector is a scalar, it is equal to its own transpose. The transpose of $(b^{(2)})^\\top U^{(1)}$ is $(U^{(1)})^\\top b^{(2)}$. Thus,\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}\n$$\nThis identity holds exactly at the algebraic level. Any numerical deviation must arise from sources like non-symmetric matrix assembly (bugs), different matrices used for the two solves, or floating-point roundoff error in the linear solver. The proposed numerical test is designed to measure this deviation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly needed, numpy is sufficient\n\ndef run_reciprocity_test(N, k, a_func, b_func, f1_func, f2_func, A_perturbation=None):\n    \"\"\"\n    Assembles and solves two 1D Helmholtz problems using FEM and calculates the reciprocity discrepancy.\n    \n    Args:\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        a_func (callable): Coefficient function a(x).\n        b_func (callable): Coefficient function b(x).\n        f1_func (callable): Source function f1(x).\n        f2_func (callable): Source function f2(x).\n        A_perturbation (tuple, optional): A tuple (row, col, value) to perturb the matrix A for the \n                                          second solve. Defaults to None.\n    \n    Returns:\n        float: The reciprocity discrepancy |(U2)^T b1 - (U1)^T b2|.\n    \"\"\"\n    \n    # Mesh properties\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    # Initialize global stiffness and mass matrices, and load vectors\n    # Full size (N+1)x(N+1) to simplify assembly indexing\n    K = np.zeros((N + 1, N + 1))\n    M = np.zeros((N + 1, N + 1))\n    b1 = np.zeros(N + 1)\n    b2 = np.zeros(N + 1)\n    \n    # Element properties (constant for all elements with linear basis functions)\n    # Element stiffness matrix for a(x)=1, h=1\n    k_elem_base = np.array([[1, -1], [-1, 1]])\n    # Element mass matrix for b(x)=1, h=1\n    m_elem_base = np.array([[1/4, 1/4], [1/4, 1/4]])\n    \n    # Loop over elements to assemble the system\n    for i in range(N):\n        # Global indices for the current element's nodes\n        idx0, idx1 = i, i + 1\n        \n        # Midpoint of the element\n        midpoint = nodes[idx0] + h / 2.0\n        \n        # Evaluate coefficients and sources at the midpoint\n        a_mid = a_func(midpoint)\n        b_mid = b_func(midpoint)\n        f1_mid = f1_func(midpoint)\n        f2_mid = f2_func(midpoint)\n        \n        # Scale element matrices by coefficients and mesh size\n        k_elem = (a_mid / h) * k_elem_base\n        m_elem = (b_mid * h) * m_elem_base\n        \n        # Assemble element matrices into global matrices\n        K[idx0:idx1+1, idx0:idx1+1] += k_elem\n        M[idx0:idx1+1, idx0:idx1+1] += m_elem\n        \n        # Assemble element load vectors\n        b1[idx0] += h * f1_mid * 0.5\n        b1[idx1] += h * f1_mid * 0.5\n        b2[idx0] += h * f2_mid * 0.5\n        b2[idx1] += h * f2_mid * 0.5\n\n    # Form the system matrix A\n    A = K - k**2 * M\n    \n    # Enforce homogeneous Dirichlet boundary conditions by using only interior nodes\n    # The interior system involves nodes 1 to N-1\n    A_int = A[1:N, 1:N]\n    b1_int = b1[1:N]\n    b2_int = b2[1:N]\n    \n    # --- Solve for U1 ---\n    # The matrix for the first solve is always the unperturbed one\n    U1 = np.linalg.solve(A_int, b1_int)\n    \n    # --- Solve for U2 ---\n    # The matrix for the second solve might be perturbed\n    A2_int = A_int.copy()\n    if A_perturbation:\n        row, col, value = A_perturbation\n        A2_int[row, col] += value\n    \n    U2 = np.linalg.solve(A2_int, b2_int)\n    \n    # --- Calculate reciprocity discrepancy ---\n    # r = | (U2)^T @ b1 - (U1)^T @ b2 |\n    discrepancy = np.abs(U2.T @ b1_int - U1.T @ b2_int)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the reciprocity check.\n    \"\"\"\n    \n    # Test 1: Happy path, smooth coefficients and sources\n    N1 = 64\n    k1 = 7.3\n    a1 = lambda x: 1.0\n    b1 = lambda x: 1.0\n    f1_1 = lambda x: np.sin(3 * np.pi * x)\n    f2_1 = lambda x: np.cos(5 * np.pi * x)\n    \n    # Test 2: Heterogeneous coefficient, smooth localized sources\n    N2 = 64\n    k2 = 4.2\n    a2 = lambda x: 3.0 if x >= 0.5 else 1.0\n    b2 = lambda x: 1.0\n    f1_2 = lambda x: np.exp(-100 * (x - 0.3)**2)\n    f2_2 = lambda x: np.exp(-120 * (x - 0.7)**2)\n    \n    # Test 3: Boundary-size mesh, coarse discretization edge case\n    N3 = 2\n    k3 = 2.0\n    a3 = lambda x: 1.0\n    b3 = lambda x: 1.0\n    f1_3 = lambda x: x * (1 - x)\n    f2_3 = lambda x: 1 - 2 * x\n\n    # Test 4: Intentional reciprocity violation via a skew perturbation\n    N4 = 64 # Same as Test 1\n    k4 = 7.3\n    a4 = lambda x: 1.0\n    b4 = lambda x: 1.0\n    f1_4 = lambda x: np.sin(3 * np.pi * x)\n    f2_4 = lambda x: np.cos(5 * np.pi * x)\n    # The interior matrix indices are 0...N-2.\n    # Node p = floor(N/2) = 32 has matrix index 32-1=31.\n    # Node p+1 = 33 has matrix index 33-1=32.\n    perturbation = (31, 32, 1e-2)\n\n    test_cases = [\n        (N1, k1, a1, b1, f1_1, f2_1, None),\n        (N2, k2, a2, b2, f1_2, f2_2, None),\n        (N3, k3, a3, b3, f1_3, f2_3, None),\n        (N4, k4, a4, b4, f1_4, f2_4, perturbation),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_reciprocity_test(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3360923"}, {"introduction": "Solving the Helmholtz equation accurately for high wavenumbers presents a notorious challenge known as pollution or phase error, where standard refinement methods can fail. This exercise moves beyond basic implementation to the realm of adaptive FEM, challenging you to analyze and select an effective error-indication strategy for heterogeneous media. By engaging with this problem, you will develop the critical thinking needed to design robust adaptive algorithms that can conquer the complexities of wave propagation simulations [@problem_id:2539330].", "problem": "Consider the heterogeneous Helmholtz problem: find $u:\\Omega \\to \\mathbb{R}$, with $\\Omega \\subset \\mathbb{R}^d$ a bounded Lipschitz domain and $d \\in \\{1,2,3\\}$, such that\n$$\n-\\Delta u - k(\\boldsymbol{x})^2 u = f \\quad \\text{in } \\Omega, \n\\qquad \nu = 0 \\quad \\text{on } \\partial \\Omega,\n$$\nwhere the wave number $k:\\Omega \\to \\mathbb{R}_+$ is piecewise smooth and strictly positive, and $f \\in L^2(\\Omega)$. The weak formulation reads: find $u \\in H_0^1(\\Omega)$ such that\n$$\na(u,v) = \\ell(v) \\quad \\forall v \\in H_0^1(\\Omega),\n$$\nwith\n$$\na(u,v) := \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} - \\int_{\\Omega} k(\\boldsymbol{x})^2 \\, u \\, v \\, \\mathrm{d}\\boldsymbol{x},\n\\qquad\n\\ell(v) := \\int_{\\Omega} f \\, v \\, \\mathrm{d}\\boldsymbol{x}.\n$$\nLet $V_h \\subset H_0^1(\\Omega)$ be a conforming finite element method (FEM) space of polynomial degree $p \\in \\mathbb{N}$ on a shape-regular triangulation $\\mathcal{T}_h$, and let $u_h \\in V_h$ solve\n$$\na(u_h,v_h) = \\ell(v_h) \\quad \\forall v_h \\in V_h.\n$$\nDefine the element residual and interior-edge jump residual by\n$$\nR_T := f + \\Delta u_h + k(\\boldsymbol{x})^2 u_h \\quad \\text{in } T \\in \\mathcal{T}_h,\n\\qquad\nJ_e := \\llbracket \\nabla u_h \\cdot \\boldsymbol{n}_e \\rrbracket \\quad \\text{on interior edge/face } e,\n$$\nand the standard residual-based local indicator\n$$\n\\eta_T^2 := h_T^2 \\, \\| R_T \\|_{0,T}^2 + \\sum_{e \\subset \\partial T \\cap \\mathcal{E}_h^{\\mathrm{int}}} h_e \\, \\| J_e \\|_{0,e}^2,\n$$\nwith the usual notation for element diameter $h_T$, edge/face diameter $h_e$, and broken $L^2$-norms. In indefinite Helmholtz problems, preasymptotic pollution (phase) errors can dominate the total error even when $\\eta_T$ is not large. Consider the local resolution parameter\n$$\n\\kappa_T := \\frac{k_T \\, h_T}{p+1},\n\\qquad \nk_T := \\left(\\frac{1}{|T|} \\int_T k(\\boldsymbol{x})^2 \\, \\mathrm{d}\\boldsymbol{x} \\right)^{1/2},\n$$\nand note that rapid spatial variation of $k(\\boldsymbol{x})$ may induce additional local phase mismatch. A standard bulk (Dörfler) marking selects a minimal set $\\mathcal{M} \\subset \\mathcal{T}_h$ such that\n$$\n\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2,\n$$\nfor a given fraction $\\theta \\in (0,1)$.\n\nWhich of the following strategies most appropriately accounts for local wave number variation in the marking step to refine preferentially where phase errors dominate, while remaining within an $h$-refinement framework?\n\nA. Use standard bulk marking with $\\eta_T$ as defined, independent of $k(\\boldsymbol{x})$, because the jump terms $J_e$ already capture phase errors.\n\nB. Augment the indicator to amplify poor local resolution and coefficient variation, for example,\n$$\n\\widetilde{\\eta}_T^2 := \\bigl(1 + \\alpha \\, \\kappa_T^q \\bigr) \\, \\eta_T^2 \\;+\\; \\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2,\n$$\nwith user-chosen constants $\\alpha>0$, $q \\ge 1$, and $\\beta>0$, then apply bulk marking using $\\widetilde{\\eta}_T$. This targets regions with large $k_T$ or large $\\|\\nabla k\\|_{0,T}$, where phase error is expected to be significant.\n\nC. Preferentially coarsen elements with large $\\kappa_T$ to reduce pollution accumulation, since fewer degrees of freedom limit phase lag.\n\nD. Mark elements where the data oscillation term is smallest, because minimizing data oscillation suppresses dispersion independently of $k(\\boldsymbol{x})$.\n\nE. Ignore residuals and mark exclusively by face jumps, i.e., select elements adjacent to edges with the largest $\\|J_e\\|_{0,e}$, because dispersion error is an interelement phenomenon.\n\nSelect the best answer. Justify your choice from the variational formulation and the structure of the residual, explaining how local wave number variations enter an a posteriori indicator and the marking decision, and how the proposed strategy aligns with refining where phase errors dominate. The constants $\\alpha$, $q$, and $\\beta$ are allowed to be generic positive parameters independent of $h_T$ and $k_T$.", "solution": "We begin from the weak formulation and the definition of a posteriori residual indicators. The finite element error $e := u - u_h$ satisfies the Galerkin orthogonality\n$$\na(e,v_h) = 0 \\quad \\forall v_h \\in V_h,\n$$\nand the residual representation, in distributional form,\n$$\na(e,v) = \\sum_{T \\in \\mathcal{T}_h} \\int_T R_T \\, v \\, \\mathrm{d}\\boldsymbol{x} - \\sum_{e \\in \\mathcal{E}_h^{\\mathrm{int}}} \\int_e J_e \\, v \\, \\mathrm{d}s \\quad \\forall v \\in H_0^1(\\Omega).\n$$\nClassical residual-based a posteriori theory for second-order elliptic problems relates the energy error to the element-wise quantities $h_T \\|R_T\\|_{0,T}$ and $h_e^{1/2} \\|J_e\\|_{0,e}$, typically yielding, for some mesh-independent constants $C_{\\mathrm{rel}}, C_{\\mathrm{eff}} > 0$,\n$$\n\\| e \\|_{1,\\Omega} \\le C_{\\mathrm{rel}} \\left( \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2 \\right)^{1/2},\n\\qquad\n\\left( \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2 \\right)^{1/2} \\le C_{\\mathrm{eff}} \\left( \\| e \\|_{1,\\Omega} + \\operatorname{osc}(f,k; \\mathcal{T}_h) \\right),\n$$\nwhere $\\| \\cdot \\|_{1,\\Omega}$ denotes the $H^1$-seminorm and $\\operatorname{osc}$ denotes data oscillation. However, for the indefinite Helmholtz operator with large wave number $k(\\boldsymbol{x})$, preasymptotic pollution (dispersion or phase) error can dominate the energy error. This pollution is not purely a local residual phenomenon; rather, it reflects a mismatch between the continuous and discrete dispersion relations, and it depends on the local resolution parameter\n$$\n\\kappa_T := \\frac{k_T \\, h_T}{p+1},\n\\qquad \nk_T := \\left(\\frac{1}{|T|} \\int_T k(\\boldsymbol{x})^2 \\, \\mathrm{d}\\boldsymbol{x} \\right)^{1/2}.\n$$\nHeuristically, when $\\kappa_T$ is large, the discrete solution $u_h$ under-resolves the local wavelength and accumulates phase error even if $\\eta_T$ is not large. Moreover, when $k(\\boldsymbol{x})$ varies rapidly, the local plane-wave direction and phase change across elements, introducing additional phase mismatch that may not be adequately captured by residual magnitudes alone. The gradient $\\nabla k$ provides a natural local measure of variation of the medium.\n\nTherefore, it is principled to incorporate two effects into the marking criterion:\n\n$1.$ Poor local resolution due to large $k_T$ and large $h_T$ relative to $p$, quantified by $\\kappa_T$.\n\n$2.$ Rapid spatial variation of $k(\\boldsymbol{x})$, quantified by norms of $\\nabla k$ on $T$.\n\nA simple way to encode $1$ and $2$ while remaining within an $h$-refinement strategy is to augment the residual indicator by a factor increasing in $\\kappa_T$ and by a term scaling with $\\|\\nabla k\\|_{0,T}$. For instance, define\n$$\n\\widetilde{\\eta}_T^2 := \\bigl(1 + \\alpha \\, \\kappa_T^q \\bigr) \\, \\eta_T^2 \\;+\\; \\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2,\n$$\nwith user-chosen constants $\\alpha>0$, $q \\ge 1$, and $\\beta>0$. The choice of a multiplicative factor $(1 + \\alpha \\kappa_T^q)$ enhances the priority of elements with large $\\kappa_T$, which are susceptible to phase error. The additive term $\\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2$ targets regions where the coefficient varies significantly across $T$, a proxy for locally varying phase velocity that can exacerbate dispersion. The scalings with $h_T$ and $L^2$-norms are consistent with dimensional considerations in residual estimators: $h_T$ times a volumetric quantity yields a contribution commensurate with an energy-norm bound.\n\nApplying bulk (Dörfler) marking with $\\widetilde{\\eta}_T$ then selects a minimal set $\\mathcal{M}$ such that\n$$\n\\sum_{T \\in \\mathcal{M}} \\widetilde{\\eta}_T^2 \\ge \\theta \\sum_{T \\in \\mathcal{T}_h} \\widetilde{\\eta}_T^2,\n$$\nwhich prioritizes refinement where either the traditional residual is large or the local resolution and coefficient variation suggest phase-dominated error. This aligns with the physical and numerical origin of phase errors and remains within an $h$-refinement paradigm.\n\nWe now analyze each option.\n\nOption A. Using the standard residual-only $\\eta_T$ ignores the explicit dependence on $k(\\boldsymbol{x})$ beyond its presence in $R_T = f + \\Delta u_h + k^2 u_h$. While $R_T$ does contain $k^2 u_h$, it does not distinguish whether a moderate residual arises in a well-resolved low-$k$ region or in a poorly resolved high-$k$ region; moreover, pollution error can remain significant even when $\\eta_T$ is modest, due to dispersion mismatch not captured by local residual magnitudes. Jump terms $J_e$ primarily measure interelement flux equilibrium but do not, by themselves, diagnose under-resolution relative to the local wavelength. Hence, this strategy does not specifically target phase errors. Verdict: Incorrect.\n\nOption B. The proposed $\\widetilde{\\eta}_T$ incorporates the local resolution parameter $\\kappa_T$ and the coefficient variation through $\\|\\nabla k\\|_{0,T}$, amplifying indicators precisely where phase errors are expected to dominate: large $k_T$ relative to $h_T$ and $p$, or rapid changes in $k(\\boldsymbol{x})$. The multiplicative factor $(1+\\alpha \\kappa_T^q)$ is monotone in $\\kappa_T$, and the additive term scaled by $h_T \\|\\nabla k\\|_{0,T}$ is consistent with how coefficient variation enters residual-based bounds via data oscillation. Applying bulk marking to $\\widetilde{\\eta}_T$ yields an $h$-refinement strategy that respects the variational structure and the origin of phase errors. Verdict: Correct.\n\nOption C. Coarsening where $\\kappa_T$ is large increases $h_T$ and thus increases $\\kappa_T$, which exacerbates under-resolution and phase error. This contradicts the requirement to maintain adequate points per wavelength. Coarsening cannot reduce dispersion error in the Helmholtz setting. Verdict: Incorrect.\n\nOption D. Minimizing or prioritizing elements with small data oscillation does not address the root cause of phase (dispersion) errors, which are tied to under-resolution relative to the wavelength and to coefficient variation, not to the magnitude of oscillation terms alone. Marking where oscillation is smallest misdirects refinement. Verdict: Incorrect.\n\nOption E. Face jumps $J_e$ quantify interelement flux disequilibrium and are part of consistent residual estimators. However, dispersion error is not confined to interfaces; it is a bulk phase mismatch that depends on local wavelength resolution ($\\kappa_T$) and the medium variation. Ignoring volumetric residuals $R_T$ and the dependence on $k(\\boldsymbol{x})$ fails to target phase-dominated regions reliably. Verdict: Incorrect.\n\nTherefore, among the given options, the strategy in Option B best captures the influence of local wave number variations on marking and refines preferentially where phase errors dominate, all within an $h$-refinement framework.", "answer": "$$\\boxed{B}$$", "id": "2539330"}]}