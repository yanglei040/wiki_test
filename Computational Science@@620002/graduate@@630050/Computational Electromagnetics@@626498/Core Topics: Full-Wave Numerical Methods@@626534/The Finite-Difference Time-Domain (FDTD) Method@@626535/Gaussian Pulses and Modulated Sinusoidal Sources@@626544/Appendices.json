{"hands_on_practices": [{"introduction": "The Gabor pulse, or Gaussian-modulated sinusoid, is a cornerstone of broadband excitation in time-domain simulations due to its excellent localization in both time and frequency. To appreciate its numerical advantages, this exercise guides you through the analytical derivation of its crest factor, a key metric relating the pulse's peak amplitude to its root-mean-square (RMS) value. By understanding how the crest factor depends on the pulse parameters, you will gain insight into managing dynamic range and ensuring both stability and high signal-to-noise ratio in your simulations [@problem_id:3310757].", "problem": "A Gaussian-modulated sinusoidal source (Gabor pulse) used as a broadband excitation in computational electromagnetics is defined by the real-valued waveform\n$$\ns(t) = \\exp\\!\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\!\\left(2\\pi f_{0} t\\right),\n$$\nwhere $f_{0}$ is the carrier frequency and $\\sigma$ is the temporal standard deviation of the Gaussian envelope. Consider the crest factor (peak-to-root-mean-square ratio) defined as the ratio of the peak amplitude to a root-mean-square value computed via a Gaussian-windowed time average appropriate for finite-energy pulses:\n$$\nC = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}, \\quad s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}.\n$$\nStarting only from the given definitions and standard integral identities for Gaussian functions, derive an exact closed-form expression for the crest factor $C$ as a function of the dimensionless parameter $f_{0}\\sigma$. Your derivation must be self-contained and must not assume any unproven intermediate formulas. Then, using your result, explain how the dependence of $C$ on $f_{0}\\sigma$ impacts the required dynamic range when exciting and recording fields in time-domain solvers such as Finite-Difference Time-Domain (FDTD), including any implications for numerical precision and stability.\n\nExpress your final answer as a single analytic expression in terms of $f_{0}\\sigma$ only. Do not include units in your final answer. No numerical approximation is required.", "solution": "The problem is valid as it is scientifically grounded in the principles of signal processing and computational electromagnetics, is well-posed with all necessary definitions provided, and is stated in objective, formal language. We may proceed with the solution.\n\nThe problem requires the derivation of the crest factor $C$ for a Gabor pulse and a discussion of its implications. The Gabor pulse is given by\n$$s(t) = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right)$$\nand the crest factor is defined as\n$$C = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}$$\nwhere the root-mean-square value $s_{\\mathrm{rms}}$ is defined by a Gaussian-windowed average:\n$$s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\fract^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}$$\nOur derivation will proceed in two main steps: calculating the peak amplitude $\\max|s(t)|$ and calculating the RMS value $s_{\\mathrm{rms}}$.\n\n**Step 1: Calculation of the Peak Amplitude**\n\nThe peak amplitude is the maximum value of $|s(t)|$ over all $t \\in \\mathbb{R}$.\n$$|s(t)| = \\left| \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right| = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right) \\left|\\cos\\left(2\\pi f_{0} t\\right)\\right|$$\nThe term $\\exp(-t^{2}/(2\\sigma^{2}))$ is a Gaussian function, which has its unique maximum value of $1$ at $t=0$. For any $t \\neq 0$, its value is strictly less than $1$. The term $|\\cos(2\\pi f_{0} t)|$ is a periodic function with a maximum value of $1$. One of these maxima occurs at $t=0$.\nSince both terms achieve their maximum value of $1$ at the same point $t=0$, their product also achieves its global maximum at this point.\nTherefore, the peak amplitude is:\n$$\\max_{t\\in\\mathbb{R}} |s(t)| = |s(0)| = \\exp(0) \\cdot |\\cos(0)| = 1 \\cdot 1 = 1$$\n\n**Step 2: Calculation of the RMS Value**\n\nThe calculation of $s_{\\mathrm{rms}}$ requires the evaluation of two integrals. Let's denote the integral in the numerator as $I_{N}$ and the integral in the denominator as $I_{D}$.\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{I_{N}}{I_{D}}}$$\n\nFirst, we evaluate the denominator integral, $I_{D}$:\n$$I_{D} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t$$\nThis is a standard Gaussian integral of the form $\\int_{-\\infty}^{\\infty} \\exp(-at^{2}) \\mathrm{d}t = \\sqrt{\\pi/a}$. Here, $a=1/\\sigma^2$.\n$$I_{D} = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} = \\sqrt{\\pi\\sigma^{2}} = \\sigma\\sqrt{\\pi}$$\n\nNext, we evaluate the numerator integral, $I_{N}$:\n$$I_{N} = \\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t = \\int_{-\\infty}^{\\infty} \\left[ \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right]^{2} \\mathrm{d}t$$\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos^{2}\\left(2\\pi f_{0} t\\right)\\mathrm{d}t$$\nWe use the trigonometric identity $\\cos^{2}(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$. Let $\\theta = 2\\pi f_{0} t$.\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right) \\frac{1}{2}\\left[1 + \\cos\\left(4\\pi f_{0} t\\right)\\right]\\mathrm{d}t$$\nWe can split this into two integrals:\n$$I_{N} = \\frac{1}{2} \\left[ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t + \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t \\right]$$\nThe first integral is simply $I_{D} = \\sigma\\sqrt{\\pi}$. The second integral is a Fourier cosine transform of a Gaussian. We use the standard identity $\\int_{-\\infty}^{\\infty} \\exp(-at^{2})\\cos(bt)\\mathrm{d}t = \\sqrt{\\pi/a} \\exp(-b^{2}/(4a))$.\nFor this integral, we have $a=1/\\sigma^2$ and $b=4\\pi f_{0}$.\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} \\exp\\left(-\\frac{(4\\pi f_{0})^{2}}{4(1/\\sigma^{2})}\\right) = \\sigma\\sqrt{\\pi} \\exp\\left(-\\frac{16\\pi^{2}f_{0}^{2}\\sigma^{2}}{4}\\right)$$\n$$= \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right)$$\nSubstituting this back into the expression for $I_{N}$:\n$$I_{N} = \\frac{1}{2} \\left[ \\sigma\\sqrt{\\pi} + \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right) \\right] = \\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n\nNow we can compute $s_{\\mathrm{rms}}^{2}$:\n$$s_{\\mathrm{rms}}^{2} = \\frac{I_{N}}{I_{D}} = \\frac{\\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]}{\\sigma\\sqrt{\\pi}} = \\frac{1}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\nTaking the square root gives $s_{\\mathrm{rms}}$:\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}$$\n\n**Step 3: Derivation of the Crest Factor C**\n\nFinally, we find the crest factor $C$ by substituting the peak amplitude and the RMS value into its definition:\n$$C = \\frac{\\max|s(t)|}{s_{\\mathrm{rms}}} = \\frac{1}{\\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}} = \\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}$$\nThis is the required closed-form expression for the crest factor $C$ as a function of the dimensionless parameter $f_{0}\\sigma$.\n\n**Discussion of Implications for Time-Domain Solvers (e.g., FDTD)**\n\nThe derived expression for the crest factor, $C(f_{0}\\sigma)$, reveals how the waveform's shape influences its numerical properties as a source in computational solvers. Let's analyze the behavior of $C$ in two limiting cases of the parameter $f_{0}\\sigma$, which represents the number of carrier cycles within the effective duration of the Gaussian envelope.\n\n1.  **Low-frequency or impulsive limit ($f_{0}\\sigma \\to 0$):**\n    As $f_{0}\\sigma \\to 0$, the exponential term $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to \\exp(0) = 1$.\n    $$C \\to \\sqrt{\\frac{2}{1+1}} = \\sqrt{1} = 1$$\n    This corresponds to a baseband Gaussian pulse (where $f_{0}=0$). A crest factor of $1$ implies the peak value is equal to the RMS value, which is characteristic of a constant (DC) signal. For the given pulse definition, $f_0=0$ yields $s(t) = \\exp(-t^2/(2\\sigma^2))$ and $s_{\\mathrm{rms}}=1$, leading to $C=1$.\n\n2.  **High-frequency or narrowband limit ($f_{0}\\sigma \\gg 1$):**\n    As $f_{0}\\sigma \\to \\infty$, the exponential term $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to 0$.\n    $$C \\to \\sqrt{\\frac{2}{1+0}} = \\sqrt{2}$$\n    This corresponds to a sinusoidal carrier modulated by a slowly varying Gaussian envelope, containing many cycles. The crest factor approaches $\\sqrt{2}$, which is precisely the crest factor of an ideal, un-windowed sinusoidal waveform ($\\cos(\\omega t)$).\n\nThe key insight is that the crest factor of a Gabor pulse is bounded: $1 \\le C \\le \\sqrt{2}$. This has important consequences for numerical methods like FDTD.\n\nIn a numerical simulation, the **dynamic range** refers to the ratio between the largest representable (non-overflow) value and the smallest discernible value above the numerical noise floor (due to round-off errors). The source waveform must be chosen to fit within this range.\n- The **peak amplitude** ($\\max|s(t)|$) determines the maximum field values generated in the simulation. This peak must be low enough to prevent floating-point overflow, which would cause catastrophic instability.\n- The **RMS value** ($s_{\\mathrm{rms}}$) is a measure of the effective amplitude and is related to the total energy of the pulse. This value must be large enough relative to the machine precision to ensure a good signal-to-noise ratio (SNR) in the recorded field data, which are later used for post-processing (e.g., Fourier transforms to find S-parameters).\n\nThe fact that $C \\le \\sqrt{2}$ is highly desirable. It means the peak amplitude is never more than about $1.414$ times the effective RMS amplitude. This is in contrast to other possible signals with very high crest factors (e.g., a train of sharp impulses), which would have very large peaks compared to their total energy content.\n\nFor a Gabor pulse, one can set the peak amplitude to a safe, high value (e.g., normalized to $1$) to maximize the injected energy. The resulting RMS value will be at worst $1/\\sqrt{2} \\approx 0.707$, which is still a substantial fraction of the peak value. This simultaneously ensures a high SNR and a low risk of overflow. The benign and bounded nature of its crest factor makes the Gabor pulse a numerically robust and \"friendly\" source for broadband excitation in FDTD and other time-domain methods, contributing to both the accuracy and stability of the simulation.", "answer": "$$\n\\boxed{\\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}}\n$$", "id": "3310757"}, {"introduction": "An ideal mathematical source function must ultimately be translated into a sequence of discrete, finite-precision numbers for use in a computer simulation. This practice delves into the practical challenges of this process by modeling a Direct Digital Synthesizer (DDS) with fixed-point arithmetic. You will quantify the effects of phase and amplitude quantization on signal quality, analyzing the resulting error spectrum to compute critical performance metrics like Carrier-to-Noise Ratio (CNR) and Spurious-Free Dynamic Range (SFDR) [@problem_id:3310693].", "problem": "Consider a one-dimensional source driving the electric field amplitude $E(t)$ in a computational electromagnetics simulation. The excitation is a Gaussian-envelope sinusoid, modeled in continuous time by the function\n$$\nE_{\\mathrm{ideal}}(t) = E_0 \\exp\\!\\left(-\\frac{(t - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t\\right),\n$$\nwhere $E_0$ is the peak electric field amplitude (expressed in $\\mathrm{V/m}$), $t_0$ is the pulse center time (expressed in $\\mathrm{s}$), $\\sigma$ is the Gaussian standard deviation (expressed in $\\mathrm{s}$), and $f_0$ is the carrier frequency (expressed in $\\mathrm{Hz}$). The angle unit is radians.\n\nIn practice, $E(t)$ is generated by a sampled system with uniform time quantization step $\\Delta t$ (sampling frequency $f_s = 1/\\Delta t$), and a fixed-point Direct Digital Synthesis (DDS) phase generator. The DDS has an $M$-bit phase accumulator and uses a cosine lookup with $B_{\\cos}$ bits of uniform amplitude quantization over the range $[-1,1]$. The Gaussian envelope is implemented with $B_{\\mathrm{env}}$ bits of uniform amplitude quantization over the range $[0,E_0]$. Define the sampled times $t_n = n \\Delta t$ for integer $n \\in \\{0,1,\\dots,N-1\\}$ and set $t_0 = \\frac{(N-1)\\Delta t}{2}$ to center the pulse in the record.\n\nThe DDS phase accumulator uses an integer frequency control word $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$, producing the discrete phase sequence\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}.\n$$\nLet $\\mathrm{Q}_{B_{\\cos}}(\\cdot)$ denote uniform quantization with $B_{\\cos}$ bits over $[-1,1]$, and let $\\mathrm{Q}_{B_{\\mathrm{env}}}(\\cdot)$ denote uniform quantization with $B_{\\mathrm{env}}$ bits over $[0,E_0]$. The realized discrete-time source is\n$$\nE_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\\cdot \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right).\n$$\n\nYour task is to assess the effect of time quantization and finite precision on the modulated sinusoidal source, and analyze the phase noise introduced by fixed-point arithmetic along with its impact on the spectrum of $E(t)$. Use only definitions and first principles to construct your algorithm. Specifically:\n\n1. Construct the ideal discrete-time reference by sampling the continuous-time expression:\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right),\n$$\ncomputed in floating-point arithmetic without any quantization aside from the inherent sampling at $t_n$.\n\n2. Form the error sequence\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n].\n$$\n\n3. Compute the one-sided discrete Fourier transforms of $E_{\\mathrm{float}}[n]$ and $e[n]$ using the standard complex exponential definition. Identify the carrier bin index $k_0$ as the index whose corresponding frequency is closest to $f_0$ among the nonnegative-frequency bins. Define a carrier band as the indices $k \\in \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$ clipped to valid indices.\n\n4. Define the following metrics:\n   - Carrier-to-Noise Ratio (CNR) in decibels:\n     $$\n     \\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right),\n     $$\n     where $X_{\\mathrm{float}}[k]$ is the one-sided discrete Fourier transform of $E_{\\mathrm{float}}[n]$, $X_{e}[k]$ is that of $e[n]$, and $\\mathcal{B}$ is the carrier band. Exclude the direct current (DC) bin ($k=0$) from the denominator.\n   - Spurious-Free Dynamic Range (SFDR) in decibels, computed as\n     $$\n     \\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right).\n     $$\n   - Root-Mean-Square (RMS) phase error in radians, computed over indices where the ideal envelope is sufficiently large (use a threshold criterion $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\ge 0.2 E_0$):\n     Obtain the analytic signal $z_{\\mathrm{quant}}[n]$ of $E_{\\mathrm{quant}}[n]$ using the Hilbert transform and define the instantaneous phase $\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$. Compute\n     $$\n     \\epsilon_\\phi[n] = \\hat{\\phi}[n] - \\left(2\\pi f_0 t_n + b\\right),\n     $$\n     where $b$ is the constant that minimizes the mean-square error over the thresholded indices, and then report\n     $$\n     \\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_\\mathrm{thr}} \\sum_{n \\in \\mathcal{I}_\\mathrm{thr}} \\epsilon_\\phi[n]^2},\n     $$\n     with $\\mathcal{I}_\\mathrm{thr}$ the set of indices meeting the threshold and $N_\\mathrm{thr}$ its cardinality.\n\nAll angles must be in radians. All times must be in seconds. All frequencies must be in hertz. The electric field amplitude must be in volts per meter.\n\nImplement a complete, runnable program that, for each test case in the test suite below, computes and returns the metrics described above as floats in the order $\\left[\\mathrm{CNR}, \\mathrm{SFDR}, \\phi_{\\mathrm{rms}}\\right]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the list concatenates the triplets for all test cases in the order given.\n\nTest suite parameter sets $(f_s, f_0, N, \\sigma, E_0, M, B_{\\cos}, B_{\\mathrm{env}})$:\n- Case A (happy path): $(10^9, 1.25\\times 10^8, 16384, 1.0\\times 10^{-7}, 1.0, 28, 14, 14)$.\n- Case B (coarse quantization near higher fractional bandwidth): $(2.0\\times 10^8, 8.0\\times 10^7, 8192, 2.5\\times 10^{-7}, 1.0, 16, 10, 10)$.\n- Case C (frequency not exactly representable by DDS): $(5.0\\times 10^8, 1.93333333333\\times 10^8, 8192, 1.2\\times 10^{-7}, 1.0, 12, 8, 8)$.\n- Case D (very broad Gaussian envelope approximating steady amplitude): $(10^9, 3.0\\times 10^8, 16384, 3.0\\times 10^{-6}, 1.0, 20, 12, 12)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{CNR}_A,\\mathrm{SFDR}_A,\\phi_{\\mathrm{rms},A},\\mathrm{CNR}_B,\\mathrm{SFDR}_B,\\phi_{\\mathrm{rms},B},\\mathrm{CNR}_C,\\mathrm{SFDR}_C,\\phi_{\\mathrm{rms},C},\\mathrm{CNR}_D,\\mathrm{SFDR}_D,\\phi_{\\mathrm{rms},D}]$). The values must be floats. Express $\\mathrm{CNR}$ and $\\mathrm{SFDR}$ in decibels, and express $\\phi_{\\mathrm{rms}}$ in radians.", "solution": "The user has provided a problem that requires the quantitative analysis of errors introduced by finite-precision digital synthesis of a modulated sinusoidal source. The problem is scientifically grounded, well-posed, and contains all necessary information for a unique solution. We will proceed to solve it by implementing an algorithm that directly follows the specified steps.\n\nThe core of the problem is to compare an ideal, floating-point representation of a Gaussian-enveloped sinusoid with a practical, fixed-point realization and to quantify the differences using established signal processing metrics. The algorithm is designed in four main stages: signal generation, error computation, spectral analysis, and metric evaluation.\n\n**1. Signal Generation**\n\nFirst, we establish a baseline by constructing the ideal discrete-time reference signal, $E_{\\mathrm{float}}[n]$. This signal is obtained by sampling the continuous-time ideal function at discrete time instances $t_n = n \\Delta t$, where $\\Delta t = 1/f_s$ is the sampling period.\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right)\n$$\nThe pulse is centered in the time window of $N$ samples by setting $t_0 = \\frac{(N-1)\\Delta t}{2}$. All computations for this reference signal are performed using standard double-precision floating-point arithmetic.\n\nNext, we model the realistic, quantized signal, $E_{\\mathrm{quant}}[n]$. This model incorporates two primary sources of error inherent in digital hardware: phase truncation and amplitude quantization.\n\nThe phase is generated by a Direct Digital Synthesizer (DDS) model. The DDS uses an $M$-bit phase accumulator and a frequency control word $K$. $K$ is the closest integer representation of the desired normalized frequency, given by $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$. At each time step $n$, the phase accumulator value is incremented by $K$, and the result is taken modulo $2^M$. The resulting discrete phase sequence is:\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}\n$$\nThe \"modulo\" operation here is the source of phase truncation error, which manifests as phase noise. The cosine of this phase, $\\cos(\\phi[n])$, is then quantized to $B_{\\cos}$ bits over the range $[-1, 1]$.\n\nThe Gaussian envelope, $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)$, is separately quantized to $B_{\\mathrm{env}}$ bits over the range $[0, E_0]$.\n\nWe define a general uniform quantization function, $\\mathrm{Q}_B(x; x_{\\min}, x_{\\max})$, which maps a value $x$ to one of $2^B$ discrete levels distributed evenly over the range $[x_{\\min}, x_{\\max}]$. The step size is $\\Delta = (x_{\\max} - x_{\\min}) / (2^B - 1)$. The function is implemented as:\n$$\n\\mathrm{Q}_B(x) = x_{\\min} + \\mathrm{round}\\left(\\frac{x - x_{\\min}}{\\Delta}\\right) \\Delta\n$$\nUsing this, the quantized components are:\n$$\n\\text{envelope}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\n$$\n$$\n\\text{carrier}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right)\n$$\nThe final quantized signal is the product of these two components:\n$$\nE_{\\mathrm{quant}}[n] = \\text{envelope}_{\\mathrm{quant}}[n] \\cdot \\text{carrier}_{\\mathrm{quant}}[n]\n$$\n\n**2. Error Signal and Spectral Analysis**\n\nThe total error introduced by the digital synthesis process is captured by the error sequence $e[n]$, defined as the sample-wise difference between the quantized and ideal signals:\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n]\n$$\nTo analyze the characteristics of the signal and the error, we compute their discrete Fourier transforms (DFTs), denoted $X_{\\mathrm{float}}[k]$ and $X_{e}[k]$ respectively. We use the standard unscaled DFT definition: $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp(-j 2\\pi nk/N)$. The analysis is performed on the one-sided spectrum, considering only the non-negative frequency bins, which correspond to indices $k \\in \\{0, 1, \\dots, N/2\\}$.\n\nA carrier band $\\mathcal{B}$ is defined to isolate the intended signal power. It comprises the frequency bin $k_0$ closest to the carrier frequency $f_0$, along with its four nearest neighbors: $\\mathcal{B} = \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$, clipped to the valid range of non-negative frequency indices. Here, $k_0 = \\mathrm{round}(f_0 N / f_s)$.\n\n**3. Performance Metrics**\n\nWith the spectra computed, we evaluate the three specified performance metrics.\n\n**Carrier-to-Noise Ratio (CNR):** This metric measures the ratio of the total power in the desired signal band to the total power of the error signal outside this band. It provides a global measure of signal quality. We exclude the DC component ($k=0$) from the noise calculation.\n$$\n\\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right)\n$$\n\n**Spurious-Free Dynamic Range (SFDR):** This metric gives the ratio of the power of the strongest component in the carrier band to the power of the strongest undesired component (spur) in the error spectrum. It is a critical measure for systems where interference from spurious tones is a concern.\n$$\n\\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right)\n$$\nFor both CNR and SFDR, a small epsilon is added to the denominator to prevent division by zero in high-precision cases where numerical error may be negligible.\n\n**Root-Mean-Square (RMS) Phase Error:** This metric specifically quantifies the phase noise. It is calculated only over the portion of the pulse where the signal is strong, defined by the condition that the ideal envelope amplitude exceeds $20\\%$ of its peak, i.e., $E_0 \\exp(-\\frac{(t_n-t_0)^2}{2\\sigma^2}) \\ge 0.2 E_0$. Let the set of indices satisfying this be $\\mathcal{I}_{\\mathrm{thr}}$.\n\nFirst, we compute the analytic signal of $E_{\\mathrm{quant}}[n]$ using the Hilbert transform, $z_{\\mathrm{quant}}[n] = E_{\\mathrm{quant}}[n] + j\\mathcal{H}\\{E_{\\mathrm{quant}}[n]\\}$. The instantaneous phase is then extracted and unwrapped to be continuous: $\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$.\n\nThe phase error $\\epsilon_\\phi[n]$ is the difference between this measured phase and the ideal linear phase ramp $2\\pi f_0 t_n$, after removing any constant phase offset $b$. The offset $b$ is chosen to minimize the mean squared error over the thresholded indices, which corresponds to the mean of the phase difference in that region: $b = \\frac{1}{N_{\\mathrm{thr}}}\\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} (\\hat{\\phi}[n] - 2\\pi f_0 t_n)$. The phase error is then $\\epsilon_\\phi[n] = (\\hat{\\phi}[n] - 2\\pi f_0 t_n) - b$.\n\nFinally, the RMS phase error is the square root of the mean of the squared phase error over the thresholded region:\n$$\n\\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_{\\mathrm{thr}}} \\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} \\epsilon_\\phi[n]^2}\n$$\nwhere $N_{\\mathrm{thr}}$ is the number of indices in $\\mathcal{I}_{\\mathrm{thr}}$. This procedure robustly quantifies the phase jitter introduced by the DDS and quantization, independent of any fixed phase offset.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem solution.\n    It iterates through test cases, computes metrics, and prints the final result.\n    \"\"\"\n\n    def quantize(x, min_val, max_val, num_bits):\n        \"\"\"\n        Performs uniform amplitude quantization.\n        \n        Args:\n            x (np.ndarray): The input signal to be quantized.\n            min_val (float): The minimum value of the quantization range.\n            max_val (float): The maximum value of the quantization range.\n            num_bits (int): The number of bits for quantization.\n\n        Returns:\n            np.ndarray: The quantized signal.\n        \"\"\"\n        num_levels = 2**num_bits\n        if num_levels = 1:\n            return np.full_like(x, (min_val + max_val) / 2.0)\n        \n        delta = (max_val - min_val) / (num_levels - 1)\n        if delta == 0:\n            return np.full_like(x, min_val)\n            \n        quantized_indices = np.round((x - min_val) / delta)\n        quantized_values = min_val + quantized_indices * delta\n        \n        return np.clip(quantized_values, min_val, max_val)\n\n    def compute_metrics(fs, f0, N, sigma, E0, M, B_cos, B_env):\n        \"\"\"\n        Computes CNR, SFDR, and RMS phase error for a given parameter set.\n        \"\"\"\n        # 1. Setup time vector and pulse center\n        dt = 1.0 / fs\n        t = np.arange(N, dtype=np.float64) * dt\n        t0 = (N - 1) * dt / 2.0\n\n        # 2. Generate E_float (ideal discrete-time reference)\n        time_exp_term = (t - t0)**2\n        gaussian_envelope_ideal = E0 * np.exp(-time_exp_term / (2.0 * sigma**2))\n        carrier_ideal = np.cos(2.0 * np.pi * f0 * t)\n        E_float = gaussian_envelope_ideal * carrier_ideal\n\n        # 3. Generate E_quant (realized discrete-time source)\n        # DDS phase generation\n        K = np.round((f0 / fs) * (2**M))\n        n_indices = np.arange(N, dtype=np.int64)\n        phase_accumulator = (n_indices * K) % (2**M)\n        phi_dds = phase_accumulator * (2.0 * np.pi / (2**M))\n        \n        # Quantized carrier from cosine lookup\n        carrier_unquantized = np.cos(phi_dds)\n        carrier_quantized = quantize(carrier_unquantized, -1.0, 1.0, B_cos)\n\n        # Quantized envelope\n        envelope_quantized = quantize(gaussian_envelope_ideal, 0.0, E0, B_env)\n        \n        E_quant = envelope_quantized * carrier_quantized\n\n        # 4. Form error sequence\n        e = E_quant - E_float\n\n        # 5. Perform spectral analysis\n        X_float = np.fft.fft(E_float)\n        X_e = np.fft.fft(e)\n        \n        # Use one-sided spectrum for analysis (non-negative frequencies)\n        num_freq_bins = N // 2 + 1\n        X_float_one_sided = X_float[:num_freq_bins]\n        X_e_one_sided = X_e[:num_freq_bins]\n\n        # Define carrier band\n        freq_res = fs / N\n        k0 = int(np.round(f0 / freq_res))\n        carrier_band_indices = np.arange(max(0, k0 - 2), min(num_freq_bins, k0 + 3))\n\n        # 6. Calculate performance metrics\n        epsilon = 1e-30  # Small value to prevent log(0) or division by zero\n\n        # CNR calculation\n        signal_power = np.sum(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        all_positive_indices = np.arange(1, num_freq_bins)\n        noise_indices = np.setdiff1d(all_positive_indices, carrier_band_indices, assume_unique=True)\n        noise_power = np.sum(np.abs(X_e_one_sided[noise_indices])**2)\n        cnr = 10.0 * np.log10(signal_power / (noise_power + epsilon))\n\n        # SFDR calculation\n        peak_signal_power = np.max(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        if noise_indices.size == 0:\n            peak_spur_power = 0.0\n        else:\n            peak_spur_power = np.max(np.abs(X_e_one_sided[noise_indices])**2)\n        sfdr = 10.0 * np.log10(peak_signal_power / (peak_spur_power + epsilon))\n\n        # RMS phase error calculation\n        threshold = 0.2 * E0\n        thr_indices = np.where(gaussian_envelope_ideal >= threshold)[0]\n        \n        phi_rms = 0.0\n        if thr_indices.size > 0:\n            z_quant = signal.hilbert(E_quant)\n            inst_phase_quant = np.unwrap(np.angle(z_quant))\n            ideal_phase_ramp = 2.0 * np.pi * f0 * t\n            phase_diff = inst_phase_quant - ideal_phase_ramp\n            \n            # Remove constant phase offset by subtracting the mean\n            b = np.mean(phase_diff[thr_indices])\n            phase_error = phase_diff - b\n\n            phi_rms = np.sqrt(np.mean(phase_error[thr_indices]**2))\n\n        return cnr, sfdr, phi_rms\n\n    test_cases = [\n        # (fs, f0, N, sigma, E0, M, B_cos, B_env)\n        (1e9, 1.25e8, 16384, 1.0e-7, 1.0, 28, 14, 14),\n        (2.0e8, 8.0e7, 8192, 2.5e-7, 1.0, 16, 10, 10),\n        (5.0e8, 1.93333333333e8, 8192, 1.2e-7, 1.0, 12, 8, 8),\n        (1.0e9, 3.0e8, 16384, 3.0e-6, 1.0, 20, 12, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters: all are floats except N, M, B_cos, B_env\n        fs, f0, N_int, sigma, E0, M_int, B_cos_int, B_env_int = case\n        cnr, sfdr, phi_rms = compute_metrics(\n            fs, f0, int(N_int), sigma, E0, int(M_int), int(B_cos_int), int(B_env_int)\n        )\n        results.extend([cnr, sfdr, phi_rms])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310693"}, {"introduction": "The choice of a source pulse has profound consequences that extend beyond the local injection point, dictating the entire computational cost of a simulation. This exercise explores the fundamental relationship between a source's bandwidth and the total workload required for two common time-domain methods: PSTD and FDTD. By deriving the scaling laws from first principles, you will gain a high-level understanding of how source parameters determine the necessary grid resolution and simulation duration, providing crucial insights for designing efficient and feasible numerical experiments [@problem_id:3310734].", "problem": "A one-dimensional time-domain electromagnetic simulation of a Gaussian-modulated sinusoidal source must be designed to generate broadband excitations and to benchmark algorithmic workloads for two classes of solvers: Pseudo-Spectral Time-Domain (PSTD) using the Fast Fourier Transform (FFT) and Finite-Difference Time-Domain (FDTD) with an Auxiliary Differential Equation (ADE) for a single-pole Debye dispersion. The goal is to quantify how the total computational workload scales with the source bandwidth when the discretization is chosen to resolve the highest significant frequency content of the pulse. The problem must be solved from first principles of wave propagation and sampling constraints, and the algorithmic workload must be defined in terms of elementary operation counts without relying on empirical timings.\n\nAssume a one-dimensional vacuum domain of length $L$ with speed of light $c$, and a time-domain source of the form $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$ for center frequency $f_{0}$ and temporal standard deviation $\\sigma_{t}$. From Fourier analysis, the positive-frequency spectrum of the Gaussian-modulated sinusoid is Gaussian with standard deviation $\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}$ centered at $f_{0}$. To ensure negligible spectral truncation, define the maximum design frequency as $f_{\\max} = f_{0} + m\\,\\sigma_{f}$ for a fixed $m$. The discretization must satisfy two constraints that are standard in time-domain electromagnetics: a minimum number of spatial points per minimum wavelength and a Courant stability bound on the time step. Specifically, let the minimum resolvable wavelength be $\\lambda_{\\min} = \\frac{c}{f_{\\max}}$, enforce $p$ points per $\\lambda_{\\min}$ so that $\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}$, and choose a time step $\\Delta t = S \\frac{\\Delta x}{c}$ with Courant number $S \\in (0,1)$. Consider a total simulated time window $T_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}$, where $q$ is a fixed multiple of the temporal standard deviation chosen to capture essentially all pulse energy and the traversal time across the domain. Let the number of spatial samples be $N = \\lceil \\frac{L}{\\Delta x} \\rceil$, the number of time steps be $N_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil$, and the FFT grid size be $N_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}$ (the smallest power of two not less than $N$) to stress FFT workloads.\n\nDefine an operation-count model in which one operation unit is one floating-point addition or multiplication. For the PSTD solver, model each time step as completing a fixed number of complex FFTs of length $N_{\\text{fft}}$; assume there are $n_{\\text{fft}}$ such transforms per time step, and that one length-$N_{\\text{fft}}$ complex FFT costs $k_{\\text{fft}}\\,N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$ operation units. Thus, the total PSTD workload is the product of the per-step FFT cost and the number of steps. For the ADE-FDTD solver with a single-pole Debye polarization, model the per-cell, per-time-step workload as a constant $k_{\\text{cell}}$ operation units accounting for one magnetic field update, one polarization update, and one electric field update. Thus, the total ADE-FDTD workload is the per-cell cost times $N$ times $N_{t}$.\n\nAll physical constants and modeling parameters are to be treated as given constants:\n- Speed of light: $c = 299792458$ in $\\text{m/s}$.\n- Domain length: $L = 1.0$ in $\\text{m}$.\n- Points per minimum wavelength: $p = 12$.\n- Spectral truncation multiple: $m = 4$.\n- Courant number: $S = 0.99$.\n- Time-window multiple: $q = 6$.\n- FFT cost coefficient: $k_{\\text{fft}} = 5$.\n- Number of complex FFTs per time step in PSTD: $n_{\\text{fft}} = 4$.\n- ADE-FDTD per-cell cost: $k_{\\text{cell}} = 12$.\n\nUsing these constants and the definitions above, compute the following for each test case in the test suite:\n- The total PSTD workload $W_{\\text{PSTD}}$ in operation units.\n- The total ADE-FDTD workload $W_{\\text{ADE}}$ in operation units.\n\nAdditionally, across the entire test suite, compute two scaling exponents by least-squares fit on a log-log scale:\n- The slope $s_{\\text{PSTD}}$ of $\\log W_{\\text{PSTD}}$ versus $\\log f_{\\max}$.\n- The slope $s_{\\text{ADE}}$ of $\\log W_{\\text{ADE}}$ versus $\\log f_{\\max}$.\n\nThe test suite consists of four cases, all with the units specified explicitly:\n1. Case A (moderately broadband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.0000000005$ in $\\text{s}$.\n2. Case B (strongly broadband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.00000000005$ in $\\text{s}$.\n3. Case C (ultra-broadband, baseband Gaussian): $f_{0} = 0$ in $\\text{Hz}$, $\\sigma_{t} = 0.00000000002$ in $\\text{s}$.\n4. Case D (narrowband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.000000005$ in $\\text{s}$.\n\nYour program must compute, for each case in the order A, B, C, D, the pair of workloads $\\left(W_{\\text{PSTD}}, W_{\\text{ADE}}\\right)$ using the definitions and constants above. Then compute the two slopes $s_{\\text{PSTD}}$ and $s_{\\text{ADE}}$ using all four cases. Report the workloads as integers (operation units) and the slopes as decimal numbers rounded to three decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$\\left[W_{\\text{PSTD}}^{(A)}, W_{\\text{ADE}}^{(A)}, W_{\\text{PSTD}}^{(B)}, W_{\\text{ADE}}^{(B)}, W_{\\text{PSTD}}^{(C)}, W_{\\text{ADE}}^{(C)}, W_{\\text{PSTD}}^{(D)}, W_{\\text{ADE}}^{(D)}, s_{\\text{PSTD}}, s_{\\text{ADE}}\\right]$.\nAll workloads are unitless operation counts; no physical unit is required on the output, and angles do not appear. The slopes must be expressed as decimals (not percentages).", "solution": "The problem requires the calculation of computational workloads for two numerical methods in electromagnetics, Pseudo-Spectral Time-Domain (PSTD) and Finite-Difference Time-Domain with an Auxiliary Differential Equation (ADE-FDTD), under various source conditions. Furthermore, it requires an analysis of how these workloads scale with the maximum frequency content of the source. The solution is derived from first principles of wave theory, numerical discretization, and algorithmic complexity analysis as specified.\n\nThe process begins by calculating the necessary simulation parameters from the given physical source parameters for each test case.\nThe source is a Gaussian-modulated sinusoid, $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$, with a center frequency $f_{0}$ and temporal standard deviation $\\sigma_{t}$. Its spectral properties determine the simulation requirements. The standard deviation of the pulse's spectrum in the frequency domain, $\\sigma_{f}$, is inversely related to its temporal standard deviation:\n$$\n\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}\n$$\nTo accurately capture the pulse's energy, the simulation must resolve frequencies up to a maximum design frequency, $f_{\\max}$. This is defined by extending from the center frequency by a multiple $m$ of the spectral standard deviation:\n$$\nf_{\\max} = f_{0} + m\\,\\sigma_{f}\n$$\nWith $f_{\\max}$ established, we can determine the required spatial and temporal discretization. For a numerical method to be stable and accurate, its grid must resolve the smallest wavelength present, $\\lambda_{\\min} = c/f_{\\max}$. The spatial step size, $\\Delta x$, is set to be a fraction of this minimum wavelength, controlled by the parameter $p$ (points per wavelength):\n$$\n\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}\n$$\nThe total number of spatial grid points, $N$, is then found by dividing the domain length $L$ by $\\Delta x$ and taking the ceiling to ensure the entire domain is covered:\n$$\nN = \\left\\lceil \\frac{L}{\\Delta x} \\right\\rceil = \\left\\lceil \\frac{L\\,p\\,f_{\\max}}{c} \\right\\rceil\n$$\nThe time step, $\\Delta t$, is constrained by the Courant-Friedrichs-Lewy (CFL) stability condition. It is related to $\\Delta x$ via the Courant number $S$:\n$$\n\\Delta t = S \\frac{\\Delta x}{c} = S \\frac{1}{p\\,f_{\\max}}\n$$\nThe total simulation duration, $T_{\\text{tot}}$, must be long enough for the wave to propagate across the domain (time $L/c$) and for the significant portion of the pulse's temporal envelope to pass, which is estimated as a multiple $q$ of $\\sigma_{t}$:\n$$\nT_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}\n$$\nThe total number of time steps, $N_{t}$, is then the total duration divided by the time step size, again taking the ceiling:\n$$\nN_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil = \\left\\lceil \\left(\\frac{L}{c} + q\\,\\sigma_{t}\\right) \\frac{p\\,f_{\\max}}{S} \\right\\rceil\n$$\nFor the PSTD method, which relies on the Fast Fourier Transform (FFT), performance is optimal when the grid size is a power of two. Therefore, the computational grid size for the FFT, $N_{\\text{fft}}$, is defined as the smallest power of two that is not less than $N$:\n$$\nN_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}\n$$\nWith these numerical parameters ($N, N_{t}, N_{\\text{fft}}$) derived, we can apply the given operation-count models to find the workloads.\nThe PSTD workload, $W_{\\text{PSTD}}$, is modeled as the total number of time steps, $N_t$, multiplied by the cost per time step. The cost per step is determined by the number of FFTs, $n_{\\text{fft}}$, the cost coefficient, $k_{\\text{fft}}$, and the complexity of a single FFT of size $N_{\\text{fft}}$, which is $N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$:\n$$\nW_{\\text{PSTD}} = N_{t} \\cdot n_{\\text{fft}} \\cdot k_{\\text{fft}} \\cdot N_{\\text{fft}} \\log_{2} N_{\\text{fft}}\n$$\nThe ADE-FDTD workload, $W_{\\text{ADE}}$, is a simpler volume-of-computation model. It is the product of the per-cell update cost, $k_{\\text{cell}}$, the number of spatial cells, $N$, and the number of time steps, $N_t$:\n$$\nW_{\\text{ADE}} = k_{\\text{cell}} \\cdot N \\cdot N_{t}\n$$\nFinally, to analyze the scaling of these workloads with respect to the maximum frequency, we assume a power-law relationship $W \\propto (f_{\\max})^s$. Taking the logarithm of both sides yields $\\log W = s \\log f_{\\max} + \\log(\\text{constant})$, which is a linear equation. The scaling exponent, $s$, is the slope of the best-fit line to the data points $(\\log f_{\\max}^{(i)}, \\log W^{(i)})$ for each test case $i$. This slope is calculated using a standard linear least-squares regression. The formula for the slope $s$ given a set of points $(x_i, y_i)$ is:\n$$\ns = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum (x_i - \\bar{x})^2}\n$$\nwhere $x_i = \\log f_{\\max}^{(i)}$ and $y_i = \\log W^{(i)}$. This procedure is applied separately to the datasets for $W_{\\text{PSTD}}$ and $W_{\\text{ADE}}$ to find the exponents $s_{\\text{PSTD}}$ and $s_{\\text{ADE}}$.\n\nThe provided constants are: $c = 299792458$, $L=1.0$, $p=12$, $m=4$, $S=0.99$, $q=6$, $k_{\\text{fft}}=5$, $n_{\\text{fft}}=4$, and $k_{\\text{cell}}=12$. These values, along with the parameters for each test case, are substituted into the above formulas to compute the final results. All workload results are converted to integers, and the slopes are rounded to three decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics workload problem.\n\n    This function calculates the computational workloads for PSTD and ADE-FDTD methods\n    for a set of test cases involving Gaussian-modulated sinusoidal sources. It then\n    computes the scaling exponents of these workloads with respect to the maximum\n    simulation frequency using a log-log linear least-squares fit.\n    \"\"\"\n\n    # Define physical constants and modeling parameters.\n    c = 299792458       # Speed of light in m/s\n    L = 1.0             # Domain length in m\n    p = 12              # Points per minimum wavelength\n    m = 4               # Spectral truncation multiple\n    S = 0.99            # Courant number\n    q = 6               # Time-window multiple\n    k_fft = 5           # FFT cost coefficient\n    n_fft = 4           # Number of complex FFTs per time step in PSTD\n    k_cell = 12         # ADE-FDTD per-cell cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f0 in Hz, sigma_t in s)\n        (3.0e9, 5.0e-10),  # Case A\n        (3.0e9, 5.0e-11),  # Case B\n        (0.0,   2.0e-11),  # Case C\n        (3.0e9, 5.0e-9),   # Case D\n    ]\n\n    results = []\n    log_fmax_list = []\n    log_w_pstd_list = []\n    log_w_ade_list = []\n\n    for f0, sigma_t in test_cases:\n        # Step 1: Calculate maximum frequency\n        sigma_f = 1 / (2 * np.pi * sigma_t)\n        f_max = f0 + m * sigma_f\n\n        # Step 2: Calculate discretization parameters\n        delta_x = c / (p * f_max)\n        delta_t = S / (p * f_max) # This is equivalent to S * delta_x / c\n\n        # Step 3: Calculate grid and time dimensions\n        N = int(np.ceil(L / delta_x))\n        T_tot = L / c + q * sigma_t\n        N_t = int(np.ceil(T_tot / delta_t))\n\n        # Step 4: Calculate FFT grid size\n        if N = 1:\n            log2_N_ceil = 0 if N == 0 else 1\n        else:\n            log2_N_ceil = int(np.ceil(np.log2(N)))\n        N_fft = 1  log2_N_ceil # Efficient way to compute 2^log2_N_ceil\n\n        # Step 5: Calculate workloads\n        W_pstd = N_t * n_fft * k_fft * N_fft * log2_N_ceil\n        W_ade = k_cell * N * N_t\n        \n        results.extend([int(W_pstd), int(W_ade)])\n\n        # Step 6: Store log values for regression\n        log_fmax_list.append(np.log(f_max))\n        # Add a small epsilon to workloads that could be zero to avoid log(0)\n        # In this problem, workloads are guaranteed to be positive.\n        log_w_pstd_list.append(np.log(W_pstd))\n        log_w_ade_list.append(np.log(W_ade))\n\n    # Step 7: Compute scaling exponents using least-squares fit on log-log data\n    # np.polyfit(x, y, 1) returns [slope, intercept] for the best-fit line.\n    slope_pstd, _ = np.polyfit(log_fmax_list, log_w_pstd_list, 1)\n    slope_ade, _ = np.polyfit(log_fmax_list, log_w_ade_list, 1)\n\n    results.extend([round(slope_pstd, 3), round(slope_ade, 3)])\n    \n    # Final print statement in the exact required format.\n    # Convert all numbers to string before joining\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310734"}]}