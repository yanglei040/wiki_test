{"hands_on_practices": [{"introduction": "This exercise serves as a foundational entry point into the practical implementation of point-matching methods. By solving a one-dimensional Fredholm integral equation of the form $u(x) - \\lambda \\mathcal{K}u(x) = f(x)$, you will build a complete collocation solver and verify its correctness using the Method of Manufactured Solutions (MMS) [@problem_id:3341400]. This practice emphasizes the critical skill of performing convergence analysis to empirically confirm that your numerical implementation achieves the theoretically predicted accuracy, which for piecewise linear basis functions should be of order $O(h^2)$.", "problem": "Consider the one-dimensional Fredholm integral equation of the second kind on the interval $[0,1]$ given by\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1].\n$$\nUsing the method of manufactured solutions, let the exact solution be the analytic function $u(x) = e^{x}$. Your first task is to construct the corresponding right-hand side $f(x)$ by substituting $u(x)$ into the integral equation and evaluating the integral exactly in terms of $x$ and $\\lambda$. Your second task is to implement a point-matching (collocation) scheme with piecewise linear basis functions on a uniform mesh to approximate $u(x)$ and to empirically quantify the observed convergence rate under uniform mesh refinement.\n\nStart from the following fundamental base:\n- The definition of a Fredholm integral equation of the second kind, namely $u - \\lambda \\mathcal{K}u = f$, where $(\\mathcal{K}u)(x) = \\int_{0}^{1} K(x,x') u(x')\\,dx'$.\n- The point-matching (collocation) procedure: approximate $u(x)$ by a finite-dimensional function $u_h(x)$ expressed in a basis $\\{\\phi_j(x)\\}$, and enforce the equation at selected points to form a square linear system.\n\nUse the following setup:\n- Let the kernel be $K(x,x') = e^{-|x-x'|}$.\n- Use a uniform partition of $[0,1]$ with $N$ subintervals and nodes $x_j = j h$, where $h = 1/N$ and $j \\in \\{0,1,\\dots,N\\}$.\n- Use continuous, piecewise linear hat functions $\\{\\phi_j(x)\\}_{j=0}^{N}$ associated to the uniform nodes.\n- Let the collocation points be the mesh nodes $x_i$ for all $i \\in \\{0,1,\\dots,N\\}$.\n- Approximate the integral terms arising in the discrete system by accurate numerical quadrature on each element; ensure the quadrature error is negligible compared to the discretization error so that the observed rate reflects the method, not the quadrature.\n\nDiscrete formulation requirement:\n- Express $u_h(x)$ as $u_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)$.\n- Enforce the equation at each node $x_i$ to obtain a linear system for the coefficients $\\{a_j\\}$:\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx' = f(x_i).\n$$\n- Note that $\\phi_j(x_i) = \\delta_{ij}$, so the system reduces to\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j \\left(\\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx'\\right) = f(x_i), \\quad i \\in \\{0,\\dots,N\\}.\n$$\n- Assemble and solve this system for $\\{a_j\\}$.\n\nError and convergence rate:\n- Define the $L^2$ error as\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_{0}^{1} \\left(u(x) - u_h(x)\\right)^2 dx \\right)^{1/2}.\n$$\n- Estimate the integral for the $L^2$ error using sufficiently high-order quadrature per element to avoid pollution by quadrature error.\n- For each refinement level $N \\in \\{8,16,32,64\\}$, compute the $L^2$ error, denoted $e_N$.\n- Compute the observed convergence rates between successive refinements as\n$$\n\\rho_{N \\to 2N} = \\frac{\\log\\left(e_{N} / e_{2N}\\right)}{\\log(2)}.\n$$\n\nTest suite:\n- Use three values of the parameter $\\lambda$: $\\lambda \\in \\{0.0, 0.5, 0.9\\}$.\n- For each $\\lambda$ in the test suite, compute the observed rates for $N \\in \\{8,16,32,64\\}$, generating the list $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one value of $\\lambda$ in the order $\\lambda = 0.0$, then $\\lambda = 0.5$, then $\\lambda = 0.9$.\n- Each entry should itself be a list of three floating-point numbers $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$, rounded to $6$ decimal places.\n- For example, the output format must look like $[[r_{1,1},r_{1,2},r_{1,3}],[r_{2,1},r_{2,2},r_{2,3}],[r_{3,1},r_{3,2},r_{3,3}]]$, with no spaces.\n\nAngle units are not applicable. There are no physical units; all quantities are dimensionless.", "solution": "The user-provided problem has been analyzed and validated.\n- **Scientific Basis**: The problem is grounded in the theory of Fredholm integral equations and numerical analysis, specifically the method of manufactured solutions and the point-matching finite element method. These are standard and well-established mathematical and computational topics.\n- **Problem Posing**: The problem is well-posed. The integral operator corresponding to the kernel $K(x,x') = e^{-|x-x'|}$ is a compact self-adjoint operator on $L^2([0,1])$. Unique solutions to the equation $u - \\lambda \\mathcal{K}u = f$ are guaranteed for any $\\lambda$ such that $\\lambda^{-1}$ is not an eigenvalue of $\\mathcal{K}$. The largest eigenvalue (spectral radius) $\\rho(\\mathcal{K})$ is approximately $0.787$. For all test values of $\\lambda \\in \\{0.0, 0.5, 0.9\\}$, the condition $|\\lambda|\\rho(\\mathcal{K}) < 1$ is satisfied, ensuring the equation is well-posed.\n- **Objectivity and Completeness**: The problem statement is objective, precise, and provides all necessary information, including the equation, manufactured solution, numerical method specifications, error metrics, and test parameters.\n\nThe problem is deemed valid and a full solution follows.\n\n### Part 1: Construction of the Right-Hand Side $f(x)$\n\nThe method of manufactured solutions requires substituting the chosen exact solution $u(x)$ into the integral equation to determine the corresponding right-hand side, or source term, $f(x)$. The given integral equation is:\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1]\n$$\nWith the manufactured solution $u(x) = e^x$, we first evaluate the integral term, which we denote as $I(x)$:\n$$\nI(x) = \\int_{0}^{1} e^{-|x - x'|} e^{x'} \\,dx'\n$$\nTo evaluate this integral, we must split the domain of integration at $x' = x$ to handle the absolute value term $|x - x'|$:\n$$\nI(x) = \\int_{0}^{x} e^{-(x - x')} e^{x'} \\,dx' + \\int_{x}^{1} e^{-(x' - x)} e^{x'} \\,dx'\n$$\nWe evaluate each part separately. For the first integral:\n$$\n\\int_{0}^{x} e^{-(x - x')} e^{x'} \\,dx' = e^{-x} \\int_{0}^{x} e^{2x'} \\,dx' = e^{-x} \\left[ \\frac{1}{2} e^{2x'} \\right]_{0}^{x} = e^{-x} \\left( \\frac{1}{2}e^{2x} - \\frac{1}{2} \\right) = \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} = \\sinh(x)\n$$\nFor the second integral:\n$$\n\\int_{x}^{1} e^{-(x' - x)} e^{x'} \\,dx' = e^{x} \\int_{x}^{1} 1 \\,dx' = e^{x} [x']_{x}^{1} = e^x(1 - x)\n$$\nCombining the two parts gives the full expression for $I(x)$:\n$$\nI(x) = \\left( \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} \\right) + (e^x - x e^x) = \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x}\n$$\nFinally, we find $f(x)$ by substituting this result back into the original equation:\n$$\nf(x) = u(x) - \\lambda I(x) = e^x - \\lambda \\left[ \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x} \\right]\n$$\n$$\nf(x) = \\left(1 - \\lambda\\left(\\frac{3}{2} - x\\right)\\right)e^x + \\frac{\\lambda}{2}e^{-x} = \\left(1 - \\frac{3\\lambda}{2} + \\lambda x\\right)e^x + \\frac{\\lambda}{2}e^{-x}\n$$\nThis is the analytical expression for the right-hand side function $f(x)$ used to test the numerical scheme.\n\n### Part 2: Discretization with the Point-Matching Method\n\nWe approximate the solution $u(x)$ using a linear combination of basis functions. The domain $[0,1]$ is divided into $N$ uniform subintervals of width $h=1/N$, with nodes at $x_j = j h$ for $j \\in \\{0, 1, \\dots, N\\}$. The basis functions $\\{\\phi_j(x)\\}_{j=0}^N$ are continuous, piecewise linear \"hat\" functions, where $\\phi_j(x)$ has a value of $1$ at node $x_j$ and $0$ at all other nodes $x_k$ for $k \\ne j$.\nThe approximate solution $u_h(x)$ is written as:\n$$\nu_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)\n$$\nwhere $\\{a_j\\}$ are the unknown coefficients to be determined. In this basis, the coefficient $a_j$ represents the value of the approximate solution at node $x_j$, i.e., $a_j = u_h(x_j)$.\n\nThe point-matching (or collocation) method enforces the integral equation at a set of discrete points. We use the mesh nodes $\\{x_i\\}_{i=0}^N$ as the collocation points. Substituting $u_h(x)$ into the integral equation and evaluating at each $x_i$ yields the system:\n$$\nu_h(x_i) - \\lambda \\int_{0}^{1} e^{-|x_i - x'|} u_h(x') \\,dx' = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\nSubstituting the expansion for $u_h(x)$ gives:\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx' = f(x_i)\n$$\nDue to the property $\\phi_j(x_i) = \\delta_{ij}$ (the Kronecker delta), the first term simplifies to $a_i$. This leads to the $(N+1) \\times (N+1)$ linear system of equations for the coefficients $\\mathbf{a} = [a_0, \\dots, a_N]^T$:\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j M_{ij} = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\nIn matrix form, this is $(I - \\lambda M)\\mathbf{a} = \\mathbf{f}$, where $I$ is the identity matrix, $\\mathbf{f}$ is the vector with entries $f_i = f(x_i)$, and $M$ is the matrix with entries:\n$$\nM_{ij} = \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx'\n$$\nThe support of the basis function $\\phi_j(x')$ is limited to the interval $[x_{j-1}, x_{j+1}]$ (with endpoint modifications for $j=0$ and $j=N$). The integral for $M_{ij}$ involves the product of an exponential function and a piecewise linear function. While an analytical solution exists, it is tedious. To ensure high accuracy as specified, we compute these integrals using high-order Gaussian quadrature over each linear segment of $\\phi_j(x')$, thereby making the quadrature error negligible compared to the method's intrinsic discretization error.\n\n### Part 3: Error Analysis and Convergence Rate\n\nAfter solving the linear system for the coefficients $\\mathbf{a}$, we have the approximate solution $u_h(x)$. The error of the approximation is quantified in the $L^2$ norm:\n$$\n\\|u - u_h\\|_{L^2} = \\left( \\int_{0}^{1} (u(x) - u_h(x))^2 \\,dx \\right)^{1/2}\n$$\nThe integral is computed numerically by summing contributions from each element $[x_k, x_{k+1}]$:\n$$\n\\|u - u_h\\|_{L^2}^2 = \\sum_{k=0}^{N-1} \\int_{x_k}^{x_{k+1}} \\left(e^x - \\left(a_k \\frac{x_{k+1}-x}{h} + a_{k+1} \\frac{x-x_k}{h}\\right)\\right)^2 \\,dx\n$$\nSimilar to the matrix assembly, high-order Gaussian quadrature is employed on each element to compute the error integral accurately.\n\nThe theoretical convergence rate for this method with a smooth solution is $O(h^2)$, meaning the error $e_N = \\|u - u_h\\|_{L^2}$ should be proportional to $(1/N)^2$. We verify this empirically by computing the observed convergence rate $\\rho$ between two successive mesh refinements, from $N$ to $2N$ intervals:\n$$\n\\rho_{N \\to 2N} = \\frac{\\log(e_N / e_{2N})}{\\log(2)}\n$$\nA rate of $\\rho \\approx 2$ would confirm the expected second-order accuracy of the method. For $\\lambda=0$, the problem reduces to piecewise linear interpolation of $u(x)=e^x$, for which the $L^2$ error is known to be $O(h^2)$, providing a strong baseline test for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Fredholm integral equation using point-matching and computes\n    convergence rates for different values of lambda.\n    \"\"\"\n    LAMBDAS = [0.0, 0.5, 0.9]\n    N_VALS = [8, 16, 32, 64]\n    QUAD_ORDER = 16  # High order for negligible quadrature error\n\n    all_lambda_rates = []\n\n    # Get Gauss-Legendre quadrature points and weights on [-1, 1]\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(QUAD_ORDER)\n\n    for lambda_val in LAMBDAS:\n        errors = []\n        for N in N_VALS:\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n\n            # Define exact solution and manufactured right-hand side\n            u_exact = lambda x: np.exp(x)\n            f_rhs = lambda x: (1.0 - 1.5 * lambda_val + lambda_val * x) * np.exp(x) + (lambda_val / 2.0) * np.exp(-x)\n\n            # The coefficients a_j are the approximations to u(x_j)\n            if lambda_val == 0.0:\n                # For lambda=0, u(x) = f(x). The collocation system is a_i = f(x_i).\n                # The manufactured f(x) for lambda=0 is e^x.\n                # So a_i = exp(x_i). This is equivalent to interpolating the exact solution.\n                a_coeffs = u_exact(x_nodes)\n            else:\n                # Assemble the system matrix M\n                M = np.zeros((N + 1, N + 1))\n                for i in range(N + 1):\n                    xi = x_nodes[i]\n                    for j in range(N + 1):\n                        # M_ij = integral of exp(-|xi - x'|) * phi_j(x') dx' from 0 to 1.\n                        # phi_j(x') is non-zero only on [x_{j-1}, x_{j+1}].\n                        \n                        integral_val = 0.0\n                        \n                        # Left part of hat function, on [x_{j-1}, x_j] for j > 0\n                        if j > 0:\n                            x_start, x_end = x_nodes[j-1], x_nodes[j]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (xp - x_start) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        # Right part of hat function, on [x_j, x_{j+1}] for j  N\n                        if j  N:\n                            x_start, x_end = x_nodes[j], x_nodes[j+1]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (x_end - xp) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        M[i, j] = integral_val\n                \n                # Form and solve the linear system (I - lambda * M) a = f\n                A_matrix = np.eye(N + 1) - lambda_val * M\n                f_vector = f_rhs(x_nodes)\n                a_coeffs = np.linalg.solve(A_matrix, f_vector)\n            \n            # Compute the L2 error ||u - u_h||\n            l2_error_sq = 0.0\n            for k in range(N):\n                # Integrate over element [x_k, x_{k+1}]\n                x_start, x_end = x_nodes[k], x_nodes[k+1]\n                \n                # Map quadrature points to the current element\n                xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                \n                # Evaluate numerical solution u_h(x) at quadrature points\n                # On [x_k, x_k+1], u_h is a linear combination of phi_k and phi_{k+1}\n                phi_k_vals = (x_end - xp) / h\n                phi_k1_vals = (xp - x_start) / h\n                u_h_vals = a_coeffs[k] * phi_k_vals + a_coeffs[k+1] * phi_k1_vals\n                \n                # Evaluate exact solution u(x) at quadrature points\n                u_exact_vals = u_exact(xp)\n                \n                # Add element's contribution to the squared L2 error integral\n                integrand_vals = (u_exact_vals - u_h_vals)**2\n                l2_error_sq += 0.5 * (x_end - x_start) * np.sum(quad_weights * integrand_vals)\n            \n            errors.append(np.sqrt(l2_error_sq))\n\n        # Compute observed convergence rates for the current lambda\n        rates = []\n        for i in range(len(N_VALS) - 1):\n            # rate = log2(error_N / error_2N)\n            rate = np.log(errors[i] / errors[i+1]) / np.log(2.0)\n            rates.append(rate)\n        \n        all_lambda_rates.append(rates)\n\n    # Format the final output string as specified: [[r1,r2,r3],[r4,r5,r6],[r7,r8,r9]]\n    formatted_rates_str = []\n    for rates_list in all_lambda_rates:\n        formatted_list = [f\"{rate:.6f}\" for rate in rates_list]\n        formatted_rates_str.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_rates_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3341400"}, {"introduction": "Building on the foundational concepts, this practice applies the point-matching technique to a canonical problem in wave physics: electromagnetic scattering governed by the Helmholtz equation, $\\nabla^2 u + k^2 u = 0$. You will model scattering from a two-dimensional cylinder using cylindrical harmonics as basis functions and compute important physical quantities like the far-field pattern [@problem_id:3341417]. This exercise provides invaluable experience in validating a numerical code against a known analytical solution, offering a direct and powerful way to quantify the accuracy of your implementation.", "problem": "Consider two-dimensional time-harmonic electromagnetic scattering by a perfectly electrically conducting circular cylinder of radius $a$ under transverse magnetic polarization ($\\mathrm{TM}_z$), so that the only nonzero electric field component is $E_z(x,y)$ with time dependence $e^{i \\omega t}$. From Maxwell's equations in the frequency domain and separation of variables in cylindrical coordinates, the scalar total field $u(x,y) = E_z(x,y)$ satisfies the homogeneous Helmholtz equation in $\\mathbb{R}^2 \\setminus \\{r \\le a\\}$,\n$$\n\\nabla^2 u + k^2 u = 0,\n$$\nand the Dirichlet boundary condition on the conductor surface,\n$$\nu(a,\\theta) = 0.\n$$\nLet the incident field be a plane wave of the form\n$$\nu^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})},\n$$\nwith $k = \\omega \\sqrt{\\mu \\epsilon}$ the free-space wavenumber, $r$ the radial coordinate, $\\theta$ the angular coordinate, and $\\theta_{\\mathrm{inc}}$ an incidence angle measured from the $x$-axis. The scattered field $u^{\\mathrm{scat}}$ satisfies the Sommerfeld radiation condition. The far-field pattern of the scattered field is defined via the large-$r$ asymptotics in radians:\n$$\nu^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i \\left( k r - \\frac{\\pi}{4} \\right)} F(\\phi), \\quad r \\to \\infty,\n$$\nwith $\\phi$ the observation angle in radians and $F(\\phi)$ the dimensionless far-field amplitude.\n\nTask A (derivation). Starting from the stated Helmholtz model and boundary condition, and using the outgoing cylindrical harmonics as a basis for the scattered field,\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta},\n$$\nderive a point-matching (boundary collocation) discretization on the circular boundary $r = a$. Choose $M$ equispaced boundary angles $\\theta_m = 2\\pi m / M$ for $m=0,1,\\ldots,M-1$, with $M \\ge 2N+1$ (integer), and enforce the Dirichlet boundary condition at these angles. Clearly state the resulting discrete linear system that determines the truncated coefficient vector $\\{c_n\\}_{n=-N}^{N}$, and explain why a least-squares solution is appropriate when $M  2N+1$.\n\nTask B (far-field). Express the discrete far-field amplitude $F_N(\\phi)$ computed from the truncated coefficient vector $\\{c_n\\}_{n=-N}^{N}$, using only the basis orthogonality and the large-argument asymptotics of outgoing cylindrical waves, in units that are dimensionless with respect to $F(\\phi)$. Use radians for all angles and provide $F_N(\\phi)$ as a complex-valued function of $\\phi$.\n\nTask C (analytic reference). Without appealing to any numerical method, use separation of variables and boundary conditions on the circle to obtain the exact modal coefficient formula for a perfectly electrically conducting circular cylinder under $\\mathrm{TM}_z$ illumination, in terms of Bessel and Hankel functions. From these exact coefficients, define a reference far-field amplitude $F_{\\mathrm{ref}}(\\phi)$ as a rapidly convergent truncated series and explain how to select a truncation index to control the truncation error.\n\nTask D (error quantification). For a uniform grid of observation angles $\\phi_j = 2\\pi j / Q$, $j = 0, 1, \\ldots, Q-1$, define the following relative error metrics between the numerical and reference far-field amplitudes:\n- Relative discrete $L^2$ error,\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }},\n$$\n- Relative discrete $L^\\infty$ error,\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}.\n$$\n\nProgramming requirements and test suite. Implement a complete program that:\n- Uses $a = 1\\,\\mathrm{m}$ and $\\theta_{\\mathrm{inc}} = 0$ (radians), hence $k a$ is dimensionless and equal to the parameter $k a$ listed in the test suite.\n- Applies the point-matching discretization from Task A with $M = s \\cdot (2N+1)$, where $s$ is an oversampling factor (integer) supplied by the test suite.\n- Computes $F_N(\\phi)$ from Task B on a uniform observation grid of size $Q = 720$ (angles in radians).\n- Builds $F_{\\mathrm{ref}}(\\phi)$ from Task C using a truncation index $N_{\\mathrm{ref}}$ sufficiently large to ensure that the truncation error is negligible relative to the discretization error; you must justify your choice in the solution and implement it in the code.\n- Computes $\\mathcal{E}_2$ and $\\mathcal{E}_\\infty$ from Task D.\n\nTest suite. Run your program for the following three parameter sets, each producing two floating-point numbers $\\mathcal{E}_2$ and $\\mathcal{E}_\\infty$:\n- Case $1$: $k a = 3.0$, $N = 3$, $s = 1$.\n- Case $2$: $k a = 3.0$, $N = 10$, $s = 2$.\n- Case $3$: $k a = 10.0$, $N = 20$, $s = 2$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\mathcal{E}_2, \\mathcal{E}_\\infty]$ for one test case, in the order of the test suite. Angles must be in radians, and all quantities are dimensionless. For example, the output format must look like\n[[e2_case1,einf_case1],[e2_case2,einf_case2],[e2_case3,einf_case3]].", "solution": "The problem is scientifically and mathematically sound, well-posed, and contains all necessary information for a unique solution. We proceed with the derivation and implementation. The problem concerns the determination of the scattered electromagnetic field from a perfectly electrically conducting (PEC) circular cylinder under transverse magnetic ($\\mathrm{TM}_z$) illumination.\n\nTask A: Point-Matching Discretization\n\nThe total field $u(r,\\theta)$ is the sum of the incident field $u^{\\mathrm{inc}}(r,\\theta)$ and the scattered field $u^{\\mathrm{scat}}(r,\\theta)$, so $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$. The Dirichlet boundary condition on the surface of the PEC cylinder of radius $a$ requires the total tangential electric field to be zero. For this $\\mathrm{TM}_z$ case, this means $u(a,\\theta) = E_z(a,\\theta) = 0$. This condition implies that the scattered field must cancel the incident field on the boundary:\n$$\nu^{\\mathrm{scat}}(a,\\theta) = -u^{\\mathrm{inc}}(a,\\theta)\n$$\nThe incident field is a plane wave given by $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})}$. For the specified case where the incidence angle $\\theta_{\\mathrm{inc}}=0$, this simplifies to $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos\\theta}$.\n\nThe scattered field is approximated by a truncated series of outgoing cylindrical waves (cylindrical harmonics), which inherently satisfy the Sommerfeld radiation condition:\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx u_N^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta}\n$$\nHere, $c_n$ are the unknown complex coefficients, $H_n^{(1)}$ is the Hankel function of the first kind of order $n$, and the series is truncated to $2N+1$ modes.\n\nThe point-matching method, or boundary collocation, enforces the boundary condition at a discrete set of points. We select $M$ equispaced points on the cylinder boundary, with angular positions $\\theta_m = 2\\pi m / M$ for $m=0, 1, \\ldots, M-1$. At each of these points, we enforce the boundary condition:\n$$\nu_N^{\\mathrm{scat}}(a,\\theta_m) = -u^{\\mathrm{inc}}(a,\\theta_m)\n$$\nSubstituting the expressions for the fields, we obtain a system of $M$ linear equations for the $2N+1$ unknown coefficients $\\{c_n\\}_{n=-N}^{N}$:\n$$\n\\sum_{n=-N}^{N} c_n H_n^{(1)}(ka) e^{i n \\theta_m} = -e^{i k a \\cos \\theta_m}, \\quad m=0, 1, \\ldots, M-1\n$$\nThis system can be written in matrix form as $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$, where:\n-   $\\mathbf{c}$ is the $(2N+1) \\times 1$ column vector of unknown coefficients, $[c_{-N}, c_{-N+1}, \\ldots, c_N]^T$.\n-   $\\mathbf{b}$ is the $M \\times 1$ column vector representing the negative of the incident field sampled at the collocation points, with entries $b_m = -e^{i k a \\cos \\theta_m}$.\n-   $\\mathbf{A}$ is the $M \\times (2N+1)$ system matrix, whose elements are given by the values of the basis functions at the collocation points. The element in row $m$ and the column corresponding to index $n$ is $A_{m,n} = H_n^{(1)}(ka) e^{i n \\theta_m}$.\n\nThe problem states that $M \\ge 2N+1$.\n-   If $M = 2N+1$, the matrix $\\mathbf{A}$ is square. For a circular boundary, this matrix is invertible, and a unique solution for $\\mathbf{c}$ can be found by direct inversion, $\\mathbf{c} = \\mathbf{A}^{-1}\\mathbf{b}$.\n-   If $M  2N+1$, the system is overdetermined, meaning there are more equations than unknowns. An exact solution that satisfies all $M$ equations simultaneously may not exist due to the truncation of the series (a modeling error). In this case, a least-squares solution is appropriate. We seek the vector $\\mathbf{c}$ that minimizes the Euclidean norm of the residual, $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2$. The solution to this minimization problem is given by the normal equations:\n    $$\n    (\\mathbf{A}^H \\mathbf{A})\\mathbf{c} = \\mathbf{A}^H \\mathbf{b}\n    $$\n    where $\\mathbf{A}^H$ is the conjugate transpose (Hermitian) of $\\mathbf{A}$. If $\\mathbf{A}$ has full column rank, the matrix $\\mathbf{A}^H \\mathbf{A}$ is invertible, and the least-squares solution is unique: $\\mathbf{c} = (\\mathbf{A}^H \\mathbf{A})^{-1}\\mathbf{A}^H\\mathbf{b}$. Numerically, this is typically solved using more stable methods like QR or SVD decomposition.\n\nTask B: Discrete Far-Field Amplitude\n\nThe far-field pattern $F(\\phi)$ is defined by the asymptotic behavior of the scattered field for large $r$. The asymptotic form of the Hankel function of the first kind for large argument $z$ is:\n$$\nH_n^{(1)}(z) \\sim \\sqrt{\\frac{2}{\\pi z}} e^{i(z - n\\pi/2 - \\pi/4)} \\quad \\text{as } z \\to \\infty\n$$\nSubstituting this into the truncated series for the scattered field $u_N^{\\mathrm{scat}}$, we set $z=kr$ and identify the observation angle $\\phi$ with the coordinate $\\theta$:\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sum_{n=-N}^{N} c_n \\left( \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - n\\pi/2 - \\pi/4)} \\right) e^{i n \\phi}\n$$\nFactoring out terms that do not depend on the summation index $n$:\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi}\n$$\nComparing this with the definition $u^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} F(\\phi)$, we identify the discrete far-field amplitude $F_N(\\phi)$ as:\n$$\nF_N(\\phi) = \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi} = \\sum_{n=-N}^{N} c_n (-i)^n e^{i n \\phi}\n$$\nThis expression provides the far-field pattern as a complex-valued function of the observation angle $\\phi$, computed from the discrete coefficients $c_n$.\n\nTask C: Analytic Reference Solution\n\nTo obtain an analytic solution, we do not truncate the series expansions. The incident plane wave is expanded in cylindrical harmonics using the Jacobi-Anger identity (with $\\theta_{\\mathrm{inc}}=0$):\n$$\nu^{\\mathrm{inc}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(kr) e^{i n \\theta}\n$$\nwhere $J_n$ is the Bessel function of the first kind. The scattered field is expanded in outgoing waves, as they must satisfy the Sommerfeld radiation condition:\n$$\nu^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(kr) e^{i n \\theta}\n$$\nThe total field $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$ must satisfy the boundary condition $u(a,\\theta)=0$ for all $\\theta \\in [0, 2\\pi)$.\n$$\n\\sum_{n=-\\infty}^{\\infty} i^n J_n(ka) e^{i n \\theta} + \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(ka) e^{i n \\theta} = 0\n$$\n$$\n\\sum_{n=-\\infty}^{\\infty} \\left[ i^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) \\right] e^{i n \\theta} = 0\n$$\nDue to the orthogonality of the complex exponentials $\\{e^{i n \\theta}\\}$ on the interval $[0, 2\\pi)$, each term in the sum must be zero for the equation to hold for all $\\theta$.\n$$\ni^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) = 0\n$$\nSolving for the exact modal coefficients $c_n^{\\mathrm{exact}}$ gives:\n$$\nc_n^{\\mathrm{exact}} = -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)}\n$$\nThe exact far-field amplitude $F(\\phi)$ is obtained by using these coefficients in the far-field summation formula:\n$$\nF(\\phi) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} (-i)^n e^{i n \\phi} = \\sum_{n=-\\infty}^{\\infty} \\left( -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)} \\right) (-i)^n e^{i n \\phi} = -\\sum_{n=-\\infty}^{\\infty} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\nFor a numerical reference, this infinite series must be truncated. We define the reference far-field amplitude $F_{\\mathrm{ref}}(\\phi)$ by truncating at an index $N_{\\mathrm{ref}}$:\n$$\nF_{\\mathrm{ref}}(\\phi) = -\\sum_{n=-N_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\nThe truncation index $N_{\\mathrm{ref}}$ must be chosen large enough so that the truncation error of this reference series is negligible compared to the discretization error of the point-matching solution being tested. The magnitude of the terms $|J_n(ka)/H_n^{(1)}(ka)|$ decays extremely rapidly for $|n|  ka$. A robust rule is to choose $N_{\\mathrm{ref}}$ to be significantly larger than both the numerical truncation index $N$ and the electrical size $ka$. We will use $N_{\\mathrm{ref}} = \\max(2N, \\lfloor ka \\rfloor + 20)$, which ensures high accuracy for the reference solution across the specified test cases.\n\nTask D: Error Quantification\n\nThe relative error between the numerical far-field amplitude $F_N(\\phi)$ and the reference far-field amplitude $F_{\\mathrm{ref}}(\\phi)$ is quantified using two discrete norms. Both are evaluated over a uniform grid of $Q$ observation angles $\\phi_j = 2\\pi j / Q$ for $j=0, 1, \\ldots, Q-1$.\n\nThe relative discrete $L^2$ error, $\\mathcal{E}_2$, measures the root-mean-square difference:\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}\n$$\nThe relative discrete $L^\\infty$ error, $\\mathcal{E}_\\infty$, measures the maximum relative difference:\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}\n$$\nThese metrics provide a normalized measure of the accuracy of the numerical point-matching solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\ndef solve():\n    \"\"\"\n    Solves for the scattering from a PEC circular cylinder using point matching and\n    computes the error against an analytic reference solution for given test cases.\n    \"\"\"\n    # Test suite parameters: (ka, N, s)\n    # ka: dimensionless electrical size\n    # N: truncation index for the scattered field series\n    # s: oversampling factor for point-matching\n    test_cases = [\n        (3.0, 3, 1),\n        (3.0, 10, 2),\n        (10.0, 20, 2),\n    ]\n\n    # Number of observation points for far-field evaluation\n    Q = 720\n    # Observation angles from 0 to 2*pi (exclusive)\n    phi_obs = np.linspace(0, 2 * np.pi, Q, endpoint=False)\n    \n    results = []\n    for ka, N, s in test_cases:\n        # Determine the number of collocation points\n        M = s * (2 * N + 1)\n        # Collocation angles on the cylinder boundary\n        thetas_col = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        \n        # --- Task A: Point-Matching Discretization and Solution ---\n        # Mode indices for the truncated series from -N to N\n        n_modes = np.arange(-N, N + 1)\n        \n        # Build the system matrix A, where A_mn = H_n^(1)(ka) * exp(i*n*theta_m)\n        # We use broadcasting for an efficient construction.\n        # h1_vals has shape (2N+1,)\n        h1_vals = hankel1(n_modes, ka)\n        # exp_vals has shape (M, 2N+1)\n        exp_vals = np.exp(1j * np.outer(thetas_col, n_modes))\n        # Broadcast h1_vals to (1, 2N+1) and element-wise multiply with exp_vals\n        A = h1_vals[np.newaxis, :] * exp_vals\n        \n        # Build the right-hand side vector b, where b_m = -exp(i*ka*cos(theta_m))\n        b = -np.exp(1j * ka * np.cos(thetas_col))\n        \n        # Solve the linear system Ac = b for the coefficients c.\n        # np.linalg.lstsq is used as it handles both square (M=2N+1) and\n        # overdetermined (M > 2N+1) systems robustly.\n        c_numerical, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        # --- Task B: Compute Numerical Far-Field Amplitude F_N ---\n        # F_N(phi) = sum_{n=-N to N} c_n * (-i)^n * exp(i*n*phi)\n        far_field_phase = (-1j)**n_modes\n        exp_obs = np.exp(1j * np.outer(phi_obs, n_modes))\n        # The '@' operator performs matrix-vector multiplication\n        F_N = exp_obs @ (c_numerical * far_field_phase)\n\n        # --- Task C: Compute Analytic Reference Far-Field F_ref ---\n        # Choose a sufficiently large truncation index for the reference series\n        # to ensure its truncation error is negligible.\n        N_ref = int(max(2 * N, np.floor(ka) + 20))\n        n_ref_modes = np.arange(-N_ref, N_ref + 1)\n\n        # Compute coefficients for the reference far-field series: d_n = -J_n(ka)/H_n^(1)(ka)\n        d_n_ref = -jv(n_ref_modes, ka) / hankel1(n_ref_modes, ka)\n        \n        # F_ref(phi) = sum_{n=-N_ref to N_ref} d_n * exp(i*n*phi)\n        exp_ref = np.exp(1j * np.outer(phi_obs, n_ref_modes))\n        F_ref = exp_ref @ d_n_ref\n        \n        # --- Task D: Error Quantification ---\n        diff = F_N - F_ref\n        \n        # Relative L2 error\n        E2_num = np.sqrt(np.mean(np.abs(diff)**2))\n        E2_den = np.sqrt(np.mean(np.abs(F_ref)**2))\n        E2 = E2_num / E2_den\n        \n        # Relative L-infinity error\n        Einf_num = np.max(np.abs(diff))\n        Einf_den = np.max(np.abs(F_ref))\n        Einf = Einf_num / Einf_den\n        \n        results.append([E2, Einf])\n        \n    # The final print statement must match the specified format.\n    # The `str` of a list includes the brackets, so we join these strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3341417"}, {"introduction": "This final practice challenges you to implement a sophisticated verification procedure for a full three-dimensional vector integral equation, the Electric Field Integral Equation (EFIE), which enforces the boundary condition $\\hat{\\mathbf{n}} \\times \\mathbf{E}^{\\text{total}} = \\mathbf{0}$. You will employ an advanced form of the Method of Manufactured Solutions by first defining a complex, vector-valued surface current $\\mathbf{J}$ and then numerically deriving the exact incident field $\\mathbf{E}^{\\text{inc}}$ required to produce it [@problem_id:3341444]. This approach demonstrates a powerful and practical methodology for verifying complex computational electromagnetics codes, particularly when exact analytical solutions are not available.", "problem": "You are asked to design a manufactured surface current density $\\mathbf{J}$ on a sphere in free space and to compute the corresponding incident field needed to verify an Electric Field Integral Equation (EFIE) collocation implementation. Your manufactured solution must employ point-matching testing procedures: the incident field is constructed so that the EFIE boundary condition holds at a chosen set of matched (collocation) points, while the verification error metric is evaluated at a distinct set of non-matched points on a sphere just outside the surface. The goal is to derive a principled and testable computation of the EFIE operator and produce a numerical error metric reflecting the quality of the point-matching procedure when the integral operator is discretized with a coarse quadrature.\n\nBegin from the time-harmonic Maxwell equations in homogeneous free space, with the convention $\\mathrm{e}^{\\mathrm{i}\\omega t}$. The total electric field $\\mathbf{E}$ satisfies the Electric Field Integral Equation on a perfectly electrically conducting (PEC) surface,\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0},\n$$\nwhere $\\hat{\\mathbf{n}}$ is the outward unit normal at the surface point $\\mathbf{r}_s$, $\\mathbf{E}^{\\text{inc}}$ is the incident field, and $\\mathbf{E}^{\\text{scat}}$ is the field scattered by the induced surface current density $\\mathbf{J}(\\mathbf{r}_s)$. The scattered field for a general surface current $\\mathbf{J}$ is given by the classical EFIE operator,\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S',\n$$\nwhere $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ is the free-space Green function, $k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ is the free-space wavenumber, and $\\nabla'_s\\cdot$ is the surface divergence at $\\mathbf{r}'$. If the manufactured $\\mathbf{J}$ is chosen to be surface divergence-free, then the scalar-potential term vanishes and only the vector-potential term contributes.\n\nYou will manufacture a smooth, divergence-free, tangential surface current density on a sphere of radius $a$ using the toroidal vector spherical harmonic $\\mathbf{X}_{\\ell m}$:\n$$\n\\mathbf{J}(\\theta,\\phi) = J_0\\,\\mathbf{X}_{\\ell m}(\\theta,\\phi),\n$$\nwhere $(\\theta,\\phi)$ are the polar and azimuthal angles on the sphere, $\\ell\\ge 1$ and $|m|\\le \\ell$, $J_0$ has units $\\mathrm{A}/\\mathrm{m}$, and\n$$\n\\mathbf{X}_{\\ell m}(\\theta,\\phi) = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta} - \\hat{\\boldsymbol{\\theta}}\\;\\frac{1}{\\sin\\theta}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi}\\right),\n$$\nwith $Y_{\\ell m}$ the complex spherical harmonic and $\\hat{\\boldsymbol{\\theta}}$, $\\hat{\\boldsymbol{\\phi}}$ the standard orthonormal tangential basis. This current is strictly tangential and satisfies $\\nabla_s\\cdot\\mathbf{J}=0$ on the sphere.\n\nTo avoid handling singular integrals exactly on the surface, evaluate fields on the sphere of radius $a+\\delta$, with $\\delta0$ small compared to the wavelength $\\lambda=2\\pi/k$. At any observation point $(\\theta_0,\\phi_0)$ on this offset sphere, the required incident field that enforces the PEC EFIE boundary condition is constructed as\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) = -\\,\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\theta_0,\\phi_0),\n$$\nwhere the symbol $\\parallel$ denotes the tangential projection onto the local tangent plane orthogonal to the radial unit vector. The scattered field appearing on the right-hand side must be computed via a numerically accurate quadrature (a fine spherical product grid using the midpoint rule) to act as the manufactured reference incident field. To mimic a collocation code using a coarse discretization of the EFIE operator, compute $\\mathbf{E}^{\\text{scat}}_{\\parallel}$ again with a coarser spherical product grid using the midpoint rule, and define a pointwise residual at non-matched points\n$$\n\\mathcal{R}(\\theta_0,\\phi_0) = \\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) + \\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}(\\theta_0,\\phi_0)\\right\\|_2.\n$$\nReport the relative root-mean-square (RMS) error across a specified set of non-matched points $\\{(\\theta_i,\\phi_i)\\}_{i=1}^M$,\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left(\\frac{\\mathcal{R}(\\theta_i,\\phi_i)}{\\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_i,\\phi_i)\\right\\|_2}\\right)^2 }.\n$$\n\nImplementation details for the program:\n- Use the free-space constants $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\mathrm{H/m}$ and $\\varepsilon_0 \\approx 8.8541878176\\times 10^{-12}\\,\\mathrm{F/m}$, with $\\omega = 2\\pi f$ and $k = \\omega\\sqrt{\\mu_0\\varepsilon_0}$.\n- Express the current density $\\mathbf{J}$ in $\\mathrm{A}/\\mathrm{m}$ and the electric field $\\mathbf{E}$ in $\\mathrm{V}/\\mathrm{m}$. Angles $\\theta$ and $\\phi$ must be in radians.\n- Use the midpoint rule on a spherical product grid with $(N_\\theta,N_\\phi)$ points: centers at $(\\theta_i,\\phi_j)$ with $\\theta_i = (i+\\tfrac{1}{2})\\Delta\\theta$, $\\phi_j = (j+\\tfrac{1}{2})\\Delta\\phi$, $\\Delta\\theta = \\pi/N_\\theta$, $\\Delta\\phi = 2\\pi/N_\\phi$, and area element $a^2 \\sin\\theta\\,\\Delta\\theta\\,\\Delta\\phi$.\n- The scattered field contribution reduces to the vector-potential term,\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|} \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S',\n$$\nand the tangential component is obtained by subtracting the radial projection: $\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$.\n- For numerical stability, select non-matched test points whose $\\theta$ values avoid the poles.\n\nTest suite:\nFor all test cases, use the same set of non-matched points $\\{(\\theta_i,\\phi_i)\\}_{i=1}^9$ with\n$$\n\\begin{aligned}\n(\\theta_1,\\phi_1) = (0.3\\pi,\\,0.1\\pi),\\quad (\\theta_2,\\phi_2) = (0.45\\pi,\\,0.35\\pi),\\quad (\\theta_3,\\phi_3) = (0.6\\pi,\\,1.2\\pi),\\\\\n(\\theta_4,\\phi_4) = (0.2\\pi,\\,2.0\\pi),\\quad (\\theta_5,\\phi_5) = (0.75\\pi,\\,2.4\\pi),\\quad (\\theta_6,\\phi_6) = (0.5\\pi,\\,3.1\\pi),\\\\\n(\\theta_7,\\phi_7) = (0.65\\pi,\\,1.7\\pi),\\quad (\\theta_8,\\phi_8) = (0.4\\pi,\\,2.8\\pi),\\quad (\\theta_9,\\phi_9) = (0.85\\pi,\\,0.9\\pi).\n\\end{aligned}\n$$\nDefine the four test cases as tuples of parameters $(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}})$, where $\\delta = \\alpha \\lambda$ with $\\lambda = 2\\pi/k$:\n- Case 1 (happy path): $(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}) = (0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$.\n- Case 2 (coarse quadrature edge): $(0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 8, 16, 40, 80)$.\n- Case 3 (high frequency): $(0.50\\,\\mathrm{m}, 1200\\,\\mathrm{MHz}, 4, 2, 1.0\\,\\mathrm{A/m}, 0.02, 20, 40, 40, 80)$.\n- Case 4 (low frequency): $(0.50\\,\\mathrm{m}, 50\\,\\mathrm{MHz}, 2, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$.\n\nYour program must:\n- Construct $\\mathbf{J}$ from $\\mathbf{X}_{\\ell m}$ as above.\n- Compute $\\mathbf{E}^{\\text{inc}}_{\\parallel}$ using the fine grid and set it equal to $-\\mathbf{E}^{\\text{scat}}_{\\parallel}$ evaluated at radius $a+\\delta$.\n- Compute the coarse-grid scattered tangential field $\\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}$ at the same non-matched points.\n- Aggregate the relative RMS error $\\epsilon_{\\text{RMS}}$ over the nine non-matched points for each test case.\n\nFinal output:\nYour program should produce a single line of output containing the four $\\epsilon_{\\text{RMS}}$ values, in the order of the test cases above, as a comma-separated list enclosed in square brackets (for example, $[\\epsilon_1,\\epsilon_2,\\epsilon_3,\\epsilon_4]$). No additional text should be printed. All angles must be interpreted in radians, all lengths in meters, current density in $\\mathrm{A}/\\mathrm{m}$, and electric field in $\\mathrm{V}/\\mathrm{m}$. The numerical values printed are dimensionless relative errors and must be standard floating-point numbers.", "solution": "The problem requires the design and implementation of a verification test for a computational electromagnetics code based on the Electric Field Integral Equation (EFIE). This is accomplished using the Method of Manufactured Solutions (MMS), where a known, non-trivial solution is posited for the surface current density, and the corresponding incident field required to sustain it is derived. The accuracy of a numerical EFIE operator can then be assessed by comparing its output to the known solution.\n\nLet us begin by formalizing the components of the problem. The geometry is a sphere of radius $a$ in free space. The time-harmonic convention is $\\mathrm{e}^{\\mathrm{i}\\omega t}$.\n\nThe foundational equation is the EFIE for a perfect electric conductor (PEC), which states that the tangential component of the total electric field must vanish on the surface $S$:\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0} \\quad \\text{for } \\mathbf{r}_s \\in S\n$$\nThis is equivalent to stating that the tangential component of the scattered field must be the negative of the tangential component of the incident field: $\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\mathbf{r}_s) = -\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_s)$.\n\nThe scattered field $\\mathbf{E}^{\\text{scat}}$ at an observation point $\\mathbf{r}$ is generated by the surface current density $\\mathbf{J}$ via the integral operator:\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S'\n$$\nwhere $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ is the scalar free-space Green's function, $k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ is the wavenumber, and $\\mu_0, \\varepsilon_0$ are the free-space permeability and permittivity.\n\nThe manufactured solution for the current density is chosen to be a single toroidal vector spherical harmonic, which ensures it is tangential to the sphere and surface divergence-free ($\\nabla_s\\cdot\\mathbf{J}=0$):\n$$\n\\mathbf{J}(\\theta',\\phi') = J_0\\,\\mathbf{X}_{\\ell m}(\\theta',\\phi')\n$$\nHere, $(\\theta', \\phi')$ are the spherical coordinate angles on the source sphere, $J_0$ is a constant amplitude, and\n$$\n\\mathbf{X}_{\\ell m}(\\theta',\\phi') = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}'\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} - \\hat{\\boldsymbol{\\theta}}'\\;\\frac{1}{\\sin\\theta'}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'}\\right)\n$$\nwhere $Y_{\\ell m}$ are the standard complex spherical harmonics. The property $\\nabla_s\\cdot\\mathbf{J}=0$ simplifies the scattered field expression by eliminating the scalar potential term (the second integral), leaving only the vector potential term:\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S'\n$$\n\nFor numerical computation, we discretize this integral. The observation points $\\mathbf{r}$ are located on a sphere of radius $a+\\delta$ (with $\\delta  0$), and the source points $\\mathbf{r}'$ are on the sphere of radius $a$. This offset $\\delta$ circumvents the singularity in the Green's function when $\\mathbf{r}=\\mathbf{r}'$. We use a midpoint rule on a regular grid in $(\\theta', \\phi')$. The integral becomes a sum:\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) \\approx \\mathrm{i}\\omega\\mu_0 \\sum_{j=0}^{N_\\theta-1} \\sum_{k=0}^{N_\\phi-1} G(\\mathbf{r},\\mathbf{r}'_{jk}) \\mathbf{J}(\\mathbf{r}'_{jk}) a^2 \\sin(\\theta'_j) \\Delta\\theta \\Delta\\phi\n$$\nwhere $\\Delta\\theta = \\pi/N_\\theta$, $\\Delta\\phi = 2\\pi/N_\\phi$, and the grid centers are $\\theta'_j = (j+0.5)\\Delta\\theta$, $\\phi'_k = (k+0.5)\\Delta\\phi$.\n\nThe current density vector $\\mathbf{J}$ and the field $\\mathbf{E}^{\\text{scat}}$ must be expressed in a common global coordinate system, a Cartesian system $(\\hat{\\mathbf{x}},\\hat{\\mathbf{y}},\\hat{\\mathbf{z}})$, to perform vector addition. The spherical basis vectors $(\\hat{\\mathbf{r}}', \\hat{\\boldsymbol{\\theta}}', \\hat{\\boldsymbol{\\phi}}')$ at each source point $(\\theta', \\phi')$ are converted to Cartesian coordinates:\n\\begin{align*} \\hat{\\mathbf{r}}' = \\sin\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\sin\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} + \\cos\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\theta}}' = \\cos\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} - \\sin\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\phi}}' = -\\sin\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\phi'\\,\\hat{\\mathbf{y}} \\end{align*}\nThe components of $\\mathbf{J}(\\theta', \\phi') = J_{\\theta'}\\hat{\\boldsymbol{\\theta}}' + J_{\\phi'}\\hat{\\boldsymbol{\\phi}}'$ are calculated. The derivative with respect to $\\phi'$ is straightforward: $\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'} = \\mathrm{i}m Y_{\\ell m}$. The derivative with respect to $\\theta'$ can be computed stably using a recurrence relation involving other spherical harmonics:\n$$\n\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} = \\frac{1}{2} \\left[ \\sqrt{(\\ell-m)(\\ell+m+1)} e^{-\\mathrm{i}\\phi'} Y_{\\ell,m+1} - \\sqrt{(\\ell+m)(\\ell-m+1)} e^{\\mathrm{i}\\phi'} Y_{\\ell,m-1} \\right]\n$$\nThis relation is valid for the Condon-Shortley phase convention used by `scipy.special.sph_harm`.\n\nThe manufactured incident field $\\mathbf{E}^{\\text{inc}}_{\\parallel}$ is defined as the field that perfectly cancels the tangential scattered field at the observation points. The reference scattered field is computed using a fine quadrature grid ($N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}$):\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}) = - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r})\n$$\nThe tangential projection is performed by subtracting the radial component: $\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot\\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$, where $\\hat{\\mathbf{r}} = \\mathbf{r}/\\|\\mathbf{r}\\|$.\n\nTo test a less accurate operator, we compute the scattered field again, this time using a coarse quadrature grid ($N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}$), to obtain $\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}$. The pointwise residual at an observation point $\\mathbf{r}_i$ is the deviation from the expected boundary condition:\n$$\n\\mathcal{R}(\\mathbf{r}_i) = \\left\\| \\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i) + \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) \\right\\|_2 = \\left\\| \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i) \\right\\|_2\n$$\nThe final error metric is the relative root-mean-square (RMS) error, averaged over the $M=9$ non-matched observation points:\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\mathcal{R}(\\mathbf{r}_i)}{\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i)\\|_2} \\right)^2} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2}{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2} \\right)^2}\n$$\nThis metric quantifies the error introduced by the coarser discretization of the EFIE operator, relative to the magnitude of the true solution field. The procedure is repeated for each of the four test cases specified.", "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom scipy.constants import mu_0, epsilon_0, c\n\ndef solve():\n    \"\"\"\n    Main orchestrator for solving the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine)\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 24, 48, 40, 80),\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 8, 16, 40, 80),\n        (0.50, 1200e6, 4, 2, 1.0, 0.02, 20, 40, 40, 80),\n        (0.50, 50e6, 2, 1, 1.0, 0.05, 24, 48, 40, 80),\n    ]\n\n    # Non-matched test points (theta, phi) in radians\n    non_matched_points_sph = np.array([\n        (0.3 * np.pi, 0.1 * np.pi), (0.45 * np.pi, 0.35 * np.pi),\n        (0.6 * np.pi, 1.2 * np.pi), (0.2 * np.pi, 2.0 * np.pi),\n        (0.75 * np.pi, 2.4 * np.pi), (0.5 * np.pi, 3.1 * np.pi),\n        (0.65 * np.pi, 1.7 * np.pi), (0.4 * np.pi, 2.8 * np.pi),\n        (0.85 * np.pi, 0.9 * np.pi)\n    ])\n\n    results = []\n    for case in test_cases:\n        a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine = case\n\n        omega = 2 * np.pi * f\n        k = omega / c # k = omega * sqrt(mu_0 * epsilon_0)\n        wavelength = 2 * np.pi / k\n        delta = alpha * wavelength\n        \n        r_obs_mag = a + delta\n        obs_points_cart = np.array([\n            r_obs_mag * np.array([\n                np.sin(th) * np.cos(ph),\n                np.sin(th) * np.sin(ph),\n                np.cos(th)\n            ]) for th, ph in non_matched_points_sph\n        ])\n\n        E_scat_fine_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_fine, N_phi_fine\n        )\n        \n        E_scat_coarse_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_coarse, N_phi_coarse\n        )\n\n        E_inc_tangential = -E_scat_fine_tangential\n\n        # E_inc is a numpy array of shape (M, 3)\n        # E_scat_coarse is also a numpy array of shape (M, 3)\n        residual_vectors = E_inc_tangential + E_scat_coarse_tangential\n        \n        # Norms are computed along the last axis (axis=1)\n        residual_norms = np.linalg.norm(residual_vectors, axis=1)\n        inc_field_norms = np.linalg.norm(E_inc_tangential, axis=1)\n\n        # To avoid division by zero, though unlikely for these test points\n        inc_field_norms[inc_field_norms == 0] = 1e-16\n\n        relative_errors = residual_norms / inc_field_norms\n        rms_error = np.sqrt(np.mean(relative_errors**2))\n        results.append(rms_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_dYlm_dtheta(m, l, theta, phi):\n    \"\"\"\n    Computes the derivative of the spherical harmonic Y_lm with respect to theta.\n    Uses the stable recurrence relation involving Y_l,m-1 and Y_l,m+1.\n    \"\"\"\n    if l == 0:\n        return np.zeros_like(theta, dtype=complex)\n\n    # Term 1: involving Y_l,m+1\n    # This term is zero if m = l\n    if m == l:\n        c1 = 0\n    else:\n        c1 = np.sqrt((l - m) * (l + m + 1))\n    \n    Y_lm_plus_1 = sph_harm(m + 1, l, phi, theta)\n    term1 = 0.5 * c1 * np.exp(-1j * phi) * Y_lm_plus_1\n\n    # Term 2: involving Y_l,m-1\n    # This term is zero if m = -l\n    if m == -l:\n        c2 = 0\n    else:\n        c2 = np.sqrt((l + m) * (l - m + 1))\n        \n    Y_lm_minus_1 = sph_harm(m - 1, l, phi, theta)\n    term2 = -0.5 * c2 * np.exp(1j * phi) * Y_lm_minus_1\n\n    return term1 + term2\n\ndef compute_scattered_field(obs_points_cart, a, k, omega, J0, l, m, N_theta, N_phi):\n    \"\"\"\n    Computes the scattered electric field by numerically integrating over the sphere.\n    \"\"\"\n    # Create the source grid for integration\n    d_theta = np.pi / N_theta\n    d_phi = 2 * np.pi / N_phi\n    \n    theta_s = (np.arange(N_theta) + 0.5) * d_theta\n    phi_s = (np.arange(N_phi) + 0.5) * d_phi\n    \n    theta_s_grid, phi_s_grid = np.meshgrid(theta_s, phi_s, indexing='ij')\n\n    # Compute current density J at all source points\n    # 1. Spherical harmonics and their derivatives\n    Y_lm = sph_harm(m, l, phi_s_grid, theta_s_grid)\n    dYlm_dphi = 1j * m * Y_lm\n    dYlm_dtheta_vals = compute_dYlm_dtheta(m, l, theta_s_grid, phi_s_grid)\n    \n    # Avoid division by zero at poles (though midpoint rule already does)\n    sin_theta_s = np.sin(theta_s_grid)\n    sin_theta_s[sin_theta_s == 0] = 1e-16\n    \n    # 2. Components of X_lm in spherical coordinates\n    X_theta = - (1 / np.sqrt(l * (l + 1))) * (1 / sin_theta_s) * dYlm_dphi\n    X_phi = (1 / np.sqrt(l * (l + 1))) * dYlm_dtheta_vals\n\n    # 3. Current density vector J in local spherical coordinates\n    J_theta = J0 * X_theta\n    J_phi = J0 * X_phi\n    \n    # 4. Convert J to Cartesian coordinates for integration\n    # Cartesian components of spherical basis vectors\n    e_theta_x = np.cos(theta_s_grid) * np.cos(phi_s_grid)\n    e_theta_y = np.cos(theta_s_grid) * np.sin(phi_s_grid)\n    e_theta_z = -np.sin(theta_s_grid)\n    e_phi_x = -np.sin(phi_s_grid)\n    e_phi_y = np.cos(phi_s_grid)\n    # e_phi_z is always 0\n    \n    J_x = J_theta * e_theta_x + J_phi * e_phi_x\n    J_y = J_theta * e_theta_y + J_phi * e_phi_y\n    J_z = J_theta * e_theta_z # J_phi has no z-component\n    \n    J_cartesian = np.stack((J_x, J_y, J_z), axis=-1) # Shape: (N_theta, N_phi, 3)\n\n    # Source point positions in Cartesian coordinates\n    r_prime_x = a * np.sin(theta_s_grid) * np.cos(phi_s_grid)\n    r_prime_y = a * np.sin(theta_s_grid) * np.sin(phi_s_grid)\n    r_prime_z = a * np.cos(theta_s_grid)\n    r_prime = np.stack((r_prime_x, r_prime_y, r_prime_z), axis=-1)\n\n    # Integration area element\n    dS = a**2 * np.sin(theta_s_grid) * d_theta * d_phi\n\n    E_scat_tangential = []\n    \n    # Loop over each observation point\n    for r_obs in obs_points_cart:\n        # Vector from source to observation point\n        dr = r_obs - r_prime  # Shape: (N_theta, N_phi, 3)\n        dist = np.linalg.norm(dr, axis=-1) # Shape: (N_theta, N_phi)\n\n        # Green's function\n        G = np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n        # Integrand (vector)\n        integrand = G[..., np.newaxis] * J_cartesian * dS[..., np.newaxis]\n        \n        # Sum over grid points to get E_scat (vector)\n        E_scat_vec = np.sum(integrand, axis=(0, 1)) * 1j * omega * mu_0\n\n        # Project to tangential component at observation point\n        r_obs_hat = r_obs / np.linalg.norm(r_obs)\n        E_scat_radial_comp = np.dot(E_scat_vec, r_obs_hat) * r_obs_hat\n        E_scat_tangential_vec = E_scat_vec - E_scat_radial_comp\n        \n        E_scat_tangential.append(E_scat_tangential_vec)\n\n    return np.array(E_scat_tangential)\n\nsolve()\n```", "id": "3341444"}]}