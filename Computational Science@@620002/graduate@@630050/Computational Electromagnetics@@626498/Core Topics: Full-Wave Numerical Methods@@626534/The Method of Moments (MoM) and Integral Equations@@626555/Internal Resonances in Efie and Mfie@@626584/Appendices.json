{"hands_on_practices": [{"introduction": "This practice provides a foundational link between the abstract theory of internal resonances and a concrete, analyzable case: a perfectly conducting sphere. You will numerically compute the resonant frequencies for the interior of a sphere, which correspond to the zeros of spherical Bessel functions. This exercise will help you build intuition by directly diagnosing the proximity of a given problem setup to a resonance for both the EFIE and MFIE formulations [@problem_id:3319829].", "problem": "You are asked to write a complete and runnable program that diagnoses internal resonances of the Electric Field Integral Equation (EFIE) and Magnetic Field Integral Equation (MFIE) for perfectly electrically conducting spheres by using analytic interior eigenvalue information derived from separation of variables. For a sphere of radius $a$ and wavenumber $k$ (in units of $\\mathrm{m}^{-1}$), the internal resonances that cause EFIE ill-conditioning occur at the interior Dirichlet eigenvalues of the scalar Helmholtz equation, while those that cause MFIE ill-conditioning occur at the interior Neumann eigenvalues. For spherical geometry, separation of variables leads to spherical Bessel functions $j_{\\ell}(x)$ of order $\\ell$, and the eigenvalues are characterized by the dimensionless quantity $x = ka$ through:\n- Dirichlet (interior) eigenvalues: $j_{\\ell}(ka) = 0$,\n- Neumann (interior) eigenvalues: $j_{\\ell}'(ka) = 0$,\nwhere the prime denotes differentiation with respect to the argument.\n\nStarting from the vector Maxwell equations in the frequency domain, the scattered-field boundary integral equations for a perfectly electrically conducting sphere reduce, when expanded in vector spherical harmonics, to independent scalar radial conditions whose roots coincide with the zeros of $j_{\\ell}(x)$ for transverse magnetic type (which pollute EFIE) and the zeros of $j_{\\ell}'(x)$ for transverse electric type (which pollute MFIE). Therefore, when $ka$ approaches one of these zeros, the corresponding integral operator develops a near-null space and its condition number grows large. In this problem, you will:\n- Compute sets of the first $N$ zeros $\\{x_{\\ell,n}^{(D)}\\}_{n=1}^{N}$ of $j_{\\ell}(x)$ for orders $\\ell \\in \\{0,1,\\dots,L\\}$ (Dirichlet set), and the first $N$ zeros $\\{x_{\\ell,n}^{(N)}\\}_{n=1}^{N}$ of $j_{\\ell}'(x)$ for the same range of $\\ell$ (Neumann set),\n- For test wavenumbers $k$ and radii $a$, evaluate the minimal distances in the $x$-domain, $\\delta_E = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(D)} \\rvert$ and $\\delta_M = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(N)} \\rvert$,\n- Define proxy conditioning metrics for EFIE and MFIE as $C_E = 1/\\max(\\delta_E,\\varepsilon)$ and $C_M = 1/\\max(\\delta_M,\\varepsilon)$, with a small floor $\\varepsilon$ to avoid division by zero. These dimensionless proxies increase as $k a$ approaches a resonance, reflecting the integral equations’ ill-conditioning.\n\nYour program must implement the following, using only fundamental mathematical and physical principles:\n- Use the time-harmonic Maxwell equations and boundary conditions on a perfectly electrically conducting sphere to justify that EFIE internal resonances coincide with interior Dirichlet eigenvalues and MFIE internal resonances with interior Neumann eigenvalues, and that these are captured by the spherical Bessel function zero conditions above.\n- Numerically compute the first $N$ positive zeros of $j_{\\ell}(x)$ and $j_{\\ell}'(x)$ for each $\\ell \\in \\{0,\\dots,L\\}$ by robust one-dimensional root bracketing and bisection-like methods on $x \\in (0,\\infty)$, relying only on well-defined sign changes of the target functions. You may assume $j_{\\ell}(x)$ is continuous for $x \\ge 0$, strictly oscillatory after a finite onset, and that zeros are simple and interlaced with those of its derivative.\n- Aggregate all zeros for the specified range of $\\ell$ and index $n$, and compute the minimal separations $\\delta_E$ and $\\delta_M$ for each test case.\n\nPhysical units and output specification:\n- The sphere radius must be specified in meters ($\\mathrm{m}$).\n- The wavenumber must be specified in inverse meters ($\\mathrm{m}^{-1}$).\n- The dimensionless parameter is $x = ka$.\n- Your proxy conditioning metrics $C_E$ and $C_M$ are dimensionless and must be produced as floating-point numbers.\n\nTest suite and answer specification:\n- Use the following test suite, where each test case is a tuple $(a, L, N, k)$:\n    1. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;6.2\\;\\mathrm{m}^{-1})$,\n    2. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;8.99\\;\\mathrm{m}^{-1})$,\n    3. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;2.0\\;\\mathrm{m}^{-1})$,\n    4. $(a=\\;1.0\\;\\mathrm{m},\\;L=\\;8,\\;N=\\;3,\\;k=\\;4.50\\;\\mathrm{m}^{-1})$,\n    5. $(a=\\;0.2\\;\\mathrm{m},\\;L=\\;4,\\;N=\\;5,\\;k=\\;20.0\\;\\mathrm{m}^{-1})$.\n- Use a distance floor $\\varepsilon = 10^{-6}$ in the definition of $C_E$ and $C_M$.\n- For each test case, compute and return the pair $[C_E, C_M]$ as a list of two floating-point numbers, rounded to at least $6$ significant digits in the printed output.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets, where each element is itself a two-element list for $[C_E, C_M]$. For example, the final printed line must have the form:\n- $[\\,[C_{E,1},C_{M,1}],\\,[C_{E,2},C_{M,2}],\\,\\dots\\,]$.", "solution": "The subject of this problem is the diagnosis of internal resonances in frequency-domain boundary integral equations for electromagnetic scattering from a perfectly electrically conducting (PEC) sphere. The Electric Field Integral Equation (EFIE) and Magnetic Field Integral Equation (MFIE) are standard formulations for such problems. However, they suffer from a critical flaw: their discrete representations become ill-conditioned at frequencies corresponding to the resonant modes of the cavity formed by the scatterer's interior. This analysis substantiates the provided problem statement and lays the groundwork for the numerical solution.\n\nFirst, we establish the theoretical connection between the integral equations and interior eigenvalues. The analysis begins with the time-harmonic Maxwell's equations, assuming an $e^{i\\omega t}$ time dependence, where $\\omega=kc$ is the angular frequency, $k$ is the wavenumber, and $c$ is the speed of light in the medium.\n$$\n\\nabla \\times \\vec{E} = -i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = i \\omega \\epsilon \\vec{E} + \\vec{J}\n$$\nFor a scattering problem involving a PEC body occupying a volume $V$ bounded by a surface $S$, we must find the surface electric current $\\vec{J}_s$ induced by an incident field $(\\vec{E}^{inc}, \\vec{H}^{inc})$. The total field is the sum of the incident and scattered fields, e.g., $\\vec{E} = \\vec{E}^{inc} + \\vec{E}^{scat}$.\n\nThe EFIE is derived from the PEC boundary condition that the tangential component of the total electric field must vanish on the surface $S$:\n$$\n\\hat{n} \\times \\vec{E}|_S = \\hat{n} \\times (\\vec{E}^{inc} + \\vec{E}^{scat})|_S = 0\n$$\nThe scattered electric field $\\vec{E}^{scat}$ is generated by the surface current $\\vec{J}_s$ and can be expressed via an integral operator $\\mathcal{E}$ acting on $\\vec{J}_s$, i.e., $\\vec{E}^{scat} = \\mathcal{E}(\\vec{J}_s)$. This leads to the operator equation $\\mathcal{L}_{EFIE}(\\vec{J}_s) \\equiv (\\hat{n} \\times \\mathcal{E}(\\vec{J}_s))|_S = -(\\hat{n} \\times \\vec{E}^{inc})|_S$. The operator $\\mathcal{L}_{EFIE}$ is non-invertible if there exists a non-trivial current $\\vec{J}_s$ for which $\\mathcal{L}_{EFIE}(\\vec{J}_s)=0$. This occurs precisely at wavenumbers $k$ for which the homogeneous interior problem, i.e., finding a non-trivial field $\\vec{E}_{int}$ inside $V$ satisfying $\\nabla \\times \\nabla \\times \\vec{E}_{int} - k^2\\vec{E}_{int} = 0$ with the boundary condition $\\hat{n} \\times \\vec{E}_{int}|_S = 0$, has a solution. These wavenumbers are the resonant frequencies of the PEC cavity, corresponding to the interior Dirichlet eigenvalues of the vector Helmholtz operator.\n\nThe MFIE is derived from the continuity condition on the tangential magnetic field across $S$. The total tangential magnetic field just outside $S$ is related to the surface current by $\\hat{n} \\times \\vec{H}|_S = \\vec{J}_s$. This leads to the operator equation $\\mathcal{L}_{MFIE}(\\vec{J}_s) \\equiv \\vec{J}_s - \\hat{n} \\times \\mathcal{H}(\\vec{J}_s)|_S = \\hat{n} \\times \\vec{H}^{inc}|_S$, where $\\mathcal{H}$ is the operator yielding the scattered magnetic field. The operator $\\mathcal{L}_{MFIE}$ fails at wavenumbers $k$ corresponding to the resonances of the dual interior problem, which is associated with homogeneous Neumann boundary conditions on the fields. These are the interior Neumann eigenvalues.\n\nFor a sphere of radius $a$, these vector boundary value problems can be simplified using separation of variables and expansion in vector spherical harmonics. The solutions inside the sphere must be regular at the origin. The radial dependence of these solutions is given by spherical Bessel functions of the first kind, $j_{\\ell}(kr)$.\nThe analysis of vector spherical harmonics shows that the field solutions separate into two types: Transverse Magnetic (TM) and Transverse Electric (TE) with respect to the radial direction $\\hat{r}$.\n\\begin{itemize}\n    \\item The interior Dirichlet problem, which contaminates the EFIE, has solutions whose eigenvalues $k$ satisfy $j_{\\ell}(ka) = 0$ for some integer order $\\ell \\ge 0$. These are designated as the Dirichlet eigenvalues.\n    \\item The interior Neumann problem, which contaminates the MFIE, has solutions whose eigenvalues $k$ satisfy $j_{\\ell}'(ka) = 0$ for some integer order $\\ell \\ge 0$, where the prime denotes differentiation with respect to the argument. These are the Neumann eigenvalues.\n\\end{itemize}\nThus, the problem correctly identifies that the ill-conditioning of the EFIE and MFIE for a sphere is tied to the proximity of the dimensionless parameter $x = ka$ to the zeros of $j_{\\ell}(x)$ and $j_{\\ell}'(x)$, respectively.\n\nThe numerical task is to find these zeros and then compute the conditioning proxies $C_E$ and $C_M$. The algorithm proceeds as follows:\n1.  Define the target functions for root-finding: $f_D(x;\\ell) = j_{\\ell}(x)$ for Dirichlet roots (EFIE) and $f_N(x;\\ell) = j_{\\ell}'(x)$ for Neumann roots (MFIE). These are implemented using functions from the `scipy.special` library.\n2.  Implement a robust root-finding procedure to locate the first $N$ positive zeros for each function for orders $\\ell=0, 1, \\dots, L$. This is achieved by first bracketing the roots and then refining them. Bracketing is done by stepping along the positive $x$-axis and detecting sign changes in the function value. The interval where a sign change occurs is then passed to a bisection-based solver, `scipy.optimize.brentq`, which efficiently finds the root to high precision.\n3.  For each test case $(a, L, N, k)$, first pre-calculate the required sets of zeros $\\{x_{\\ell,n}^{(D)}\\}$ and $\\{x_{\\ell,n}^{(N)}\\}$ for $\\ell \\in \\{0, \\dots, L\\}$ and $n \\in \\{1, \\dots, N\\}$.\n4.  Calculate the test parameter $x_{test} = ka$.\n5.  Compute the minimum distance from $x_{test}$ to any of the computed Dirichlet zeros: $\\delta_E = \\min_{\\ell,n} |x_{test} - x_{\\ell,n}^{(D)}|$.\n6.  Compute the minimum distance from $x_{test}$ to any of the computed Neumann zeros: $\\delta_M = \\min_{\\ell,n} |x_{test} - x_{\\ell,n}^{(N)}|$.\n7.  Calculate the proxy conditioning metrics $C_E = 1/\\max(\\delta_E, \\varepsilon)$ and $C_M = 1/\\max(\\delta_M, \\varepsilon)$, using the specified floor value $\\varepsilon = 10^{-6}$.\n8.  The final results for all test cases are collected and formatted into a single string as specified. This systematic procedure provides a quantitative measure of how close each test configuration is to an internal resonance, thereby diagnosing the potential for numerical instability in EFIE and MFIE solvers.", "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.optimize import brentq\nimport json\n\ndef solve():\n    \"\"\"\n    Computes EFIE and MFIE conditioning proxies for PEC spheres by analyzing distances\n    to interior resonance wavenumbers.\n    \"\"\"\n    test_cases = [\n        # (a, L, N, k)\n        (0.5, 6, 4, 6.2),\n        (0.5, 6, 4, 8.99),\n        (0.5, 6, 4, 2.0),\n        (1.0, 8, 3, 4.50),\n        (0.2, 4, 5, 20.0),\n    ]\n\n    epsilon = 1e-6\n\n    def find_zeros(l, N, derivative):\n        \"\"\"\n        Finds the first N positive zeros of j_l(x) or j_l'(x) for a given order l.\n        Uses scanning to find brackets, then brentq to find roots.\n        \"\"\"\n        zeros = []\n        f = lambda x: spherical_jn(l, x, derivative=derivative)\n        \n        # Start scanning for roots from a small positive number to avoid x=0.\n        x_current = 0.1\n        scan_step = 0.1\n\n        # For l>0, j_l(0)=0 and j'_l(0)=0 (for l>1).\n        # We seek positive roots, so starting at x_current > 0 is correct.\n        \n        y_current = f(x_current)\n        \n        while len(zeros)  N:\n            # Move along the x-axis to find a sign change.\n            x_next = x_current + scan_step\n            y_next = f(x_next)\n            \n            # If a sign change is detected, there is a root in [x_current, x_next].\n            if np.sign(y_current) != np.sign(y_next):\n                try:\n                    root = brentq(f, x_current, x_next)\n                    # Add if it's a new root (to guard against re-finding)\n                    if not any(np.isclose(root, z) for z in zeros):\n                        zeros.append(root)\n                    # Advance the anchor to continue searching past the found root.\n                    x_current = root + scan_step\n                    y_current = f(x_current)\n\n                except ValueError: # Should not happen with a sign change\n                    x_current = x_next\n                    y_current = y_next\n            else:\n                x_current = x_next\n                y_current = y_next\n        \n        return zeros\n\n    # Determine maximum L and N from test cases to pre-compute all needed zeros.\n    L_max = max(tc[1] for tc in test_cases)\n    N_max = max(tc[2] for tc in test_cases)\n\n    # Pre-compute zeros to avoid redundant calculations.\n    # precomputed_dirichlet_zeros[l] will be a list of the first N_max zeros of j_l(x)\n    precomputed_dirichlet_zeros = [find_zeros(l, N_max, derivative=False) for l in range(L_max + 1)]\n    # precomputed_neumann_zeros[l] will be a list of the first N_max zeros of j_l'(x)\n    precomputed_neumann_zeros = [find_zeros(l, N_max, derivative=True) for l in range(L_max + 1)]\n\n    final_results = []\n    \n    for a, L, N, k in test_cases:\n        # Assemble the sets of active roots for the current test case.\n        active_dirichlet_roots = []\n        for l in range(L + 1):\n            active_dirichlet_roots.extend(precomputed_dirichlet_zeros[l][:N])\n\n        active_neumann_roots = []\n        for l in range(L + 1):\n            active_neumann_roots.extend(precomputed_neumann_zeros[l][:N])\n            \n        x_test = k * a\n\n        # Compute minimum distances to the resonance sets.\n        delta_E = np.min(np.abs(np.array(active_dirichlet_roots) - x_test))\n        delta_M = np.min(np.abs(np.array(active_neumann_roots) - x_test))\n\n        # Compute conditioning proxies.\n        C_E = 1.0 / max(delta_E, epsilon)\n        C_M = 1.0 / max(delta_M, epsilon)\n\n        final_results.append([C_E, C_M])\n\n    # Format the output string exactly as required.\n    # Using json.dumps provides a compact, space-free representation of a list of lists.\n    # The default float precision is sufficient.\n    class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, np.floating):\n                return float(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    print(json.dumps(final_results, separators=(',', ':'), cls=CustomEncoder))\n\nsolve()\n```", "id": "3319829"}, {"introduction": "Having learned how to diagnose when resonances occur, this exercise focuses on quantifying their severe numerical consequences. You will investigate the Electric Field Integral Equation (EFIE) for a 2D circular scatterer, a problem that can be elegantly diagonalized using a Fourier basis. By computing the condition number of the discretized operator, you will directly observe how it deteriorates catastrophically as the wavenumber approaches an interior resonant frequency [@problem_id:3319757].", "problem": "Consider the time-harmonic electromagnetic scattering in two dimensions under transverse electric polarization, where the only nonzero component of the electric field is the out-of-plane scalar field $E_z(\\mathbf{r})$ satisfying the scalar Helmholtz equation $\\nabla^2 E_z + k^2 E_z = 0$ in the exterior of a perfectly electrically conducting obstacle with smooth boundary $\\Gamma$. The Electric Field Integral Equation (EFIE) for the Dirichlet boundary condition $E_z|_{\\Gamma} = 0$ can be written in terms of the single-layer integral operator\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}'),\n$$\nwhere $G_k(\\mathbf{r}, \\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$ is the two-dimensional free-space Green's function for the Helmholtz equation, $H_0^{(1)}$ is the Hankel function of the first kind of order zero, and $k$ is the wavenumber (dimensionless for this mathematical formulation). Internal resonances for the EFIE manifest when the operator $S_k$ becomes non-invertible due to the existence of nontrivial solutions of the interior Dirichlet problem, which correspond to values of $k$ for which there exists a nonzero solution of $\\nabla^2 u + k^2 u = 0$ in the interior with $u|_{\\Gamma} = 0$.\n\nOn a circle of radius $a$, parameterized by $\\mathbf{r}(\\theta) = a(\\cos\\theta, \\sin\\theta)$ with $0 \\le \\theta  2\\pi$, the operator $S_k$ acts as a convolution in the angular variable and diagonalizes in the Fourier basis $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$. Using Graf’s addition theorem for Bessel and Hankel functions, the action of $S_k$ on the Fourier mode $e^{i m \\theta}$ yields a scalar multiplication by\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a),\n$$\nwhere $J_m$ is the Bessel function of the first kind of order $m$, and $H_m^{(1)}$ is the Hankel function of the first kind of order $m$. The interior Dirichlet eigenvalues (resonances) for the circle occur at those $k$ such that $J_m(k a) = 0$ for some integer $m$, causing $s_m(k)$ to vanish and the EFIE to become singular.\n\nDiscretize the EFIE on the circle of radius $a$ by truncating the Fourier basis to modes $m = -M, \\ldots, M$, yielding a square $(2M+1) \\times (2M+1)$ diagonal matrix whose diagonal entries are $\\{s_m(k)\\}_{m=-M}^{M}$. For a given $k$, define the condition number of this discretized EFIE matrix as\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}.\n$$\nNear an interior resonance associated with mode $m$, the value $\\lvert s_m(k) \\rvert$ becomes small because $J_m(k a) \\to 0$, and the condition number grows accordingly.\n\nTask: Write a complete, runnable program that:\n- Computes the condition number $\\kappa(k; a, M)$ for specified values of $k$ using the above Fourier-Galerkin discretization on the circle.\n- Uses $a = 1$ and $M = 20$.\n- Determines the first interior Dirichlet resonance $k_0$ for mode $m = 0$ as the smallest positive root of $J_0(k a)$ (with $a=1$).\n- Evaluates the condition number for the following test suite of wavenumbers:\n  1. $k = 1.0$ (far from resonance),\n  2. $k = k_0 - 0.2$ (moderately below resonance),\n  3. $k = k_0 - 0.05$ (near below resonance),\n  4. $k = k_0 - 0.005$ (very close below resonance),\n  5. $k = k_0 + 0.05$ (near above resonance),\n  6. $k = 3.0$ (above the first resonance, below the next).\n- Produces the final output as a single line containing the six condition numbers for the above test suite, formatted as a comma-separated Python list enclosed in square brackets, for example, $[c_1,c_2,c_3,c_4,c_5,c_6]$ where each $c_j$ is a floating-point number.\n\nNotes:\n- All quantities in this problem are dimensionless; no physical units are required.\n- Your implementation must use the stated Fourier symbol $s_m(k)$, and the condition number must be computed as the ratio of the maximum to the minimum singular values, which, for a diagonal matrix, are the absolute values of its diagonal entries.\n- Ensure numerical stability by using reliable special function evaluations for $J_m$ and $H_m^{(1)}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\").", "solution": "The problem is evaluated as valid. It is scientifically grounded in the principles of computational electromagnetics, specifically the integral equation methods for scattering problems. The formulation is well-posed, with all necessary parameters, equations, and definitions provided to compute a unique, meaningful numerical result. The language is objective and mathematically precise.\n\nThe problem requires the computation of the condition number of a discretized Electric Field Integral Equation (EFIE) operator for a circular scatterer. This serves to demonstrate the phenomenon of internal resonance, where the operator becomes ill-conditioned or singular.\n\nThe physical context is the time-harmonic electromagnetic scattering in two dimensions from a perfectly electrically conducting (PEC) cylinder. For transverse electric (TE) polarization, the problem reduces to solving the scalar Helmholtz equation for the out-of-plane component of the electric field, $E_z(\\mathbf{r})$:\n$$\n(\\nabla^2 + k^2) E_z(\\mathbf{r}) = 0\n$$\nin the domain exterior to the scatterer. Here, $k$ is the wavenumber. For a PEC scatterer, the total tangential electric field must be zero on the boundary $\\Gamma$, which for the scalar field $E_z$ implies the Dirichlet boundary condition $E_z|_{\\Gamma} = 0$.\n\nThe EFIE arises from representing the scattered field as a single-layer potential. This leads to an integral equation for an unknown surface current density $\\varphi(\\mathbf{r}')$. The operator involved is the single-layer operator, $S_k$:\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}')\n$$\nwhere $G_k(\\mathbf{r}, \\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$ is the free-space Green's function in two dimensions, with $H_0^{(1)}$ being the Hankel function of the first kind and order zero.\n\nA critical issue with the EFIE is the existence of internal resonances. These occur at wavenumbers $k$ for which the corresponding interior Dirichlet problem (i.e., the Helmholtz equation inside the scatterer with zero boundary conditions) has a non-trivial solution. At these resonant wavenumbers, the exterior EFIE operator $S_k$ becomes non-invertible, and numerical solutions become unstable.\n\nFor a circular scatterer of radius $a$, the problem simplifies considerably due to symmetry. The operator $S_k$ a'cts as a convolution in the angular variable and is diagonalized by the Fourier basis functions $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$. The action of $S_k$ on $e^{i m \\theta}$ is simply multiplication by a scalar, the symbol $s_m(k)$:\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a)\n$$\nHere, $J_m$ and $H_m^{(1)}$ are the Bessel and Hankel functions of order $m$, respectively.\nThe internal resonances for the circle correspond to wavenumbers $k$ such that $k a$ is a zero of a Bessel function $J_m$. At such a $k$, the symbol $s_m(k)$ becomes zero, indicating the non-invertibility of $S_k$.\n\nThe problem asks us to discretize the operator by truncating the Fourier series to a finite number of modes, $m \\in \\{-M, \\ldots, M\\}$. In this basis, the operator is represented by a $(2M+1) \\times (2M+1)$ diagonal matrix, $S_{k,M}$, with the symbols $\\{s_m(k)\\}_{m=-M}^{M}$ on its diagonal.\n\nThe condition number of this matrix, $\\kappa(S_{k,M})$, measures its sensitivity to perturbations and its proximity to being singular. For a diagonal matrix, the singular values are the absolute values of the diagonal entries. Therefore, the condition number is given by the ratio of the largest singular value to the smallest singular value:\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}\n$$\nNear a resonance, say for mode $m_0$, where $k a$ is close to a zero of $J_{m_0}$, the value of $\\lvert s_{m_0}(k) \\rvert$ becomes very small. This small value appears in the denominator of the condition number, causing $\\kappa$ to become very large, signaling the ill-conditioning of the numerical problem.\n\nThe computational procedure is as follows:\n1.  Set the fixed parameters: radius $a=1$ and Fourier truncation limit $M=20$. The modes considered will be $m \\in \\{-20, -19, \\ldots, 19, 20\\}$.\n2.  Determine the first interior Dirichlet resonance $k_0$ for the mode $m=0$. This is the smallest positive $k$ such that $J_0(k a) = J_0(k) = 0$. This value is a well-known mathematical constant, the first zero of $J_0(x)$, which is approximately $2.4048$. We find this value numerically for high precision.\n3.  Construct the test suite of wavenumbers $k$ based on the computed value of $k_0$.\n4.  For each test wavenumber $k$ in the suite:\n    a. Generate the array of mode numbers, $m$, from $-M$ to $M$.\n    b. Compute the set of symbols $\\{s_m(k)\\}_{m=-M}^{M}$ using the formula $s_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(ka) J_m(ka)$. Note that since $J_{-m}(z) = (-1)^m J_m(z)$ and $H_{-m}^{(1)}(z) = (-1)^m H_m^{(1)}(z)$, it follows that $s_{-m}(k) = s_m(k)$. Our computation will process all $m$ from $-M$ to $M$ directly.\n    c. Calculate the absolute values of all symbols, $\\{\\lvert s_m(k) \\rvert\\}_{m=-M}^{M}$.\n    d. Find the maximum and minimum of these absolute values.\n    e. Compute the condition number $\\kappa$ as the ratio of the maximum to the minimum.\n5.  Collect the six computed condition numbers and present them in the specified format. The necessary special functions ($J_m, H_m^{(1)}$) and the zero-finding routine for $J_0$ are available in the `scipy.special` library.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1, jn_zeros\n\ndef solve():\n    \"\"\"\n    Computes the condition number of a discretized EFIE operator on a circle\n    to demonstrate the effect of internal resonances.\n    \"\"\"\n    \n    # Define the problem parameters as specified.\n    a = 1.0\n    M = 20\n\n    # Step 1: Find the first interior Dirichlet resonance k_0 for m=0.\n    # This is the smallest positive root of J_0(k*a) = 0, which is the first\n    # zero of the Bessel function J_0(x) divided by a.\n    # jn_zeros(0, 1) returns an array containing the first positive zero of J_0.\n    # Since a=1, k_0 is simply the first zero.\n    k0 = jn_zeros(0, 1)[0]\n\n    # Step 2: Define the test suite of wavenumbers.\n    test_k_values = [\n        1.0,           # k = 1.0 (far from resonance)\n        k0 - 0.2,      # k moderately below resonance\n        k0 - 0.05,     # k near below resonance\n        k0 - 0.005,    # k very close below resonance\n        k0 + 0.05,     # k near above resonance\n        3.0,           # k above the first resonance, below the next\n    ]\n\n    results = []\n    \n    # Step 3: Loop through each test wavenumber and compute the condition number.\n    for k in test_k_values:\n        # Define the range of Fourier modes m = -M, ..., M.\n        modes = np.arange(-M, M + 1)\n        \n        # Argument for the Bessel and Hankel functions.\n        x = k * a\n        \n        # Calculate the symbols s_m(k) for all modes.\n        # The formula is s_m(k) = a * (i*pi/2) * H_m^(1)(k*a) * J_m(k*a)\n        # SciPy's jv and hankel1 functions are vectorized, so we can compute\n        # for all modes at once.\n        Jm_values = jv(modes, x)\n        H1m_values = hankel1(modes, x)\n        \n        sm_values = a * (1j * np.pi / 2.0) * H1m_values * Jm_values\n        \n        # The singular values of the diagonal matrix are the absolute values\n        # of its diagonal entries.\n        singular_values = np.abs(sm_values)\n        \n        # The condition number is the ratio of the largest to smallest singular value.\n        max_sv = np.max(singular_values)\n        min_sv = np.min(singular_values)\n        \n        # A check for singularity. For the chosen k, min_sv should not be zero.\n        if min_sv == 0:\n            condition_number = np.inf\n        else:\n            condition_number = max_sv / min_sv\n            \n        results.append(condition_number)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3319757"}, {"introduction": "The previous exercises demonstrated the existence and catastrophic effects of internal resonances. This final practice moves from diagnosis to mitigation by exploring the Combined Field Integral Equation (CFIE), the standard industrial and academic cure. To focus on the core principles of spectral mixing, this problem utilizes a synthetic spectral model that mimics the behavior of EFIE and MFIE operators for a complex object without the overhead of geometric meshing [@problem_id:3319825]. You will design and test an adaptive strategy for choosing the CFIE mixing parameter $\\alpha$ to maintain good conditioning, even at resonant frequencies.", "problem": "You are to construct, analyze, and algorithmically optimize a Combined Field Integral Equation (CFIE) to mitigate internal resonances that arise in the Electric Field Integral Equation (EFIE) and the Magnetic Field Integral Equation (MFIE) when solving time-harmonic Maxwell boundary integral equations on a closed Perfect Electric Conductor (PEC). Your task is to implement a self-contained numerical experiment that models a genus-2 PEC body via a synthetic but physically plausible spectral surrogate and to propose and validate an adaptive CFIE mixing parameter that reduces spectral deterioration near resonant wavenumbers.\n\nStart from the following principles and modeling assumptions.\n\n1. Fundamental base. Begin from the time-harmonic Maxwell equations and the well-known boundary integral formulations on a closed PEC, namely the Electric Field Integral Equation (EFIE) and the Magnetic Field Integral Equation (MFIE). A CFIE is a convex combination of the two operators and is used to avoid internal resonances that can cause ill-conditioning and iteration stagnation. Denote the EFIE operator by $\\mathcal{E}(k)$ and the MFIE operator by $\\mathcal{M}(k)$ for real wavenumber $k$ (in $1/\\mathrm{m}$). The CFIE operator is\n$$\n\\mathcal{C}_{\\alpha}(k) \\,=\\, \\alpha\\, \\mathcal{E}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\mathcal{M}(k),\n$$\nwith $\\alpha \\in [0,1]$. We will analyze the spectrum of a discrete surrogate of $\\mathcal{C}_{\\alpha}(k)$ to quantify robustness.\n\n2. Discrete spectral surrogate. Model the genus-2 PEC body by two independent families of surface current modes leading to a total of $N = 12$ discrete modes. For each mode index $i \\in \\{1,2,\\dots,12\\}$ and for a given wavenumber $k$, define the EFIE and MFIE eigenvalues, $\\lambda_{E,i}(k)$ and $\\lambda_{M,i}(k)$, by smooth Lorentzian perturbations around strictly positive baselines. The EFIE exhibits pronounced dips (mimicking interior Dirichlet resonances), while the MFIE remains bounded away from zero with mild variation (mimicking the relative robustness of MFIE on closed PEC geometries). Specifically:\n- EFIE eigenvalues:\n$$\n\\lambda_{E,i}(k) \\,=\\, b_i \\;-\\; \\sum_{j=1}^{4} a_{E,i,j}\\,\\frac{\\gamma_{E,j}^{2}}{(k - k_{E,j})^{2} + \\gamma_{E,j}^{2}},\n$$\nwith resonance centers and widths\n$$\nk_{E,1} = 5.0,\\;\\; \\gamma_{E,1} = 0.08;\\quad\nk_{E,2} = 8.0,\\;\\; \\gamma_{E,2} = 0.06;\\quad\nk_{E,3} = 3.2,\\;\\; \\gamma_{E,3} = 0.05;\\quad\nk_{E,4} = 9.2,\\;\\; \\gamma_{E,4} = 0.07,\n$$\nand mode-dependent amplitudes\n$$\nb_i \\in [0.95, 1.25],\\quad\na_{E,i,1} = 0.35\\,w_i,\\;\\;\na_{E,i,2} = 0.30\\,w_i,\\;\\;\na_{E,i,3} = 0.12\\,w_i,\\;\\;\na_{E,i,4} = 0.10\\,w_i,\n$$\nwhere $w_i \\in [0.85,1.15]$ encodes the genus-$2$ multiplicity pattern (two families of $6$ modes each) via a deterministic scaling vector. These choices ensure $\\lambda_{E,i}(k)  0$ yet permit near-vanishing dips near $k \\approx 5.0$ and $k \\approx 8.0$.\n\n- MFIE eigenvalues:\n$$\n\\lambda_{M,i}(k) \\,=\\, m_i \\;+\\; \\sum_{j=1}^{2} q_{M,i,j}\\,\\frac{\\gamma_{M,j}^{2}}{(k - k_{M,j})^{2} + \\gamma_{M,j}^{2}},\n$$\nwith\n$$\nk_{M,1} = 6.3,\\;\\; \\gamma_{M,1} = 0.08;\\quad\nk_{M,2} = 9.5,\\;\\; \\gamma_{M,2} = 0.07,\n$$\nand mode-dependent baselines and amplitudes\n$$\nm_i \\in [0.50, 0.72],\\qquad\nq_{M,i,1} = 0.08\\,v_i,\\;\\;\nq_{M,i,2} = 0.07\\,v_i,\n$$\nwhere $v_i \\in [0.90,1.10]$. These ensure $\\lambda_{M,i}(k)  0.30$ for all $k$ of interest.\n\n3. CFIE spectrum. The $i$th CFIE eigenvalue is the convex combination\n$$\n\\lambda_{C,i}(k,\\alpha) \\,=\\, \\alpha\\, \\lambda_{E,i}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\lambda_{M,i}(k),\\qquad \\alpha \\in [0,1].\n$$\n\n4. Performance metric. Consider stationary Richardson iteration applied to a linearly scaled CFIE matrix. For a matrix with real positive eigenvalues, the optimal scalar step size for Richardson iteration minimizes the spectral radius of the iteration matrix and yields a minimized spectral radius that depends only on the condition number. Let\n$$\n\\kappa(\\alpha,k) \\,=\\, \\frac{\\max_{i}\\lambda_{C,i}(k,\\alpha)}{\\min_{i}\\lambda_{C,i}(k,\\alpha)}.\n$$\nThe spectral radius of optimally scaled Richardson iteration satisfies\n$$\n\\rho^{\\star}(\\alpha,k) \\,=\\, \\frac{\\kappa(\\alpha,k) - 1}{\\kappa(\\alpha,k) + 1}.\n$$\nMinimizing $\\rho^{\\star}(\\alpha,k)$ over $\\alpha \\in [0,1]$ is therefore equivalent to minimizing $\\kappa(\\alpha,k)$ when all eigenvalues are positive reals.\n\n5. Adaptive CFIE parameter. Design an adaptive strategy $\\alpha(k)$ based solely on coarse spectral indicators for EFIE and MFIE:\n$$\n\\kappa_{E}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{E,i}(k)}{\\min_{i}\\lambda_{E,i}(k)},\\quad\n\\kappa_{M}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{M,i}(k)}{\\min_{i}\\lambda_{M,i}(k)}.\n$$\nDefine stability scores\n$$\ns_{E}(k) \\,=\\, \\kappa_{E}(k)^{-1},\\qquad\ns_{M}(k) \\,=\\, \\kappa_{M}(k)^{-1},\n$$\nand an adaptive mixing law with sharpness parameter $p \\ge 1$,\n$$\n\\alpha_{\\mathrm{ad}}(k) \\,=\\, \\frac{\\left[s_{E}(k)\\right]^{p}}{\\left[s_{E}(k)\\right]^{p} + \\left[s_{M}(k)\\right]^{p}}.\n$$\nUse $p = 2$.\n\n6. Tasks.\n- Implement the spectral surrogate exactly as stated above, using deterministic arrays for $b_i$, $m_i$, $w_i$, and $v_i$ spanning the ranges specified, and $N=12$ modes.\n- For each given test wavenumber $k$ (in $1/\\mathrm{m}$), compute:\n  1. The adaptive parameter $\\alpha_{\\mathrm{ad}}(k)$.\n  2. The minimized spectral radius $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k)$ achieved by the adaptive choice.\n  3. The globally minimized spectral radius $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$.\n  4. A boolean indicating whether the adaptive choice is within a relative tolerance of $5$ percent of the optimal spectral radius, i.e., whether\n  $$\n  \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k) \\,\\le\\, 1.05 \\times \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k).\n  $$\n- Numerically minimize over $\\alpha \\in [0,1]$ using a robust one-dimensional bounded search.\n\n7. Test suite. Use the following wavenumbers (in $1/\\mathrm{m}$), chosen to probe happy-path, near-resonant, and edge scenarios:\n$$\nk \\in \\left\\{\\, 4.0,\\; 5.0,\\; 6.3,\\; 8.0,\\; 9.2,\\; 9.5,\\; 3.2,\\; 10.0 \\,\\right\\}.\n$$\n\n8. Output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order specified above, output a list with four entries:\n$$\n\\left[\\, \\alpha_{\\mathrm{ad}}(k),\\; \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k),\\; \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k),\\; \\text{boolean} \\,\\right].\n$$\nAll floating-point numbers must be rounded to $6$ decimal places, and the boolean must be either $\\mathrm{True}$ or $\\mathrm{False}$. Thus the entire output is a single list of eight such per-test-case lists, for example:\n$$\n\\left[\\,[0.123456,0.234567,0.210000,\\mathrm{True}],\\; \\dots \\,\\right].\n$$\nNo other text should be printed. All quantities are dimensionless except for the wavenumber inputs $k$ which are in $1/\\mathrm{m}$; you do not need to report units in the output.", "solution": "The problem is valid. It presents a well-posed, scientifically grounded numerical experiment in computational electromagnetics. The task is to analyze a spectral surrogate model for the Combined Field Integral Equation (CFIE) to evaluate an adaptive strategy for choosing the mixing parameter $\\alpha$. The model simulates the behavior of the Electric Field Integral Equation (EFIE) and Magnetic Field Integral Equation (MFIE) near internal resonances. The subsequent solution is developed by adhering strictly to the provided definitions and parameters.\n\nThe methodology is implemented in the following sequence:\n\n1.  **Discretization of Model Parameters:** The analysis is performed on a system with $N=12$ discrete modes. The mode-dependent parameters $b_i$, $m_i$, $w_i$, and $v_i$ for $i \\in \\{1, 2, \\dots, 12\\}$ are required to be deterministic arrays spanning their specified ranges.\n    -   The baseline parameters $b_i$ and $m_i$ are generated using linearly spaced values across their respective intervals: $b_i$ is a vector spanning $[0.95, 1.25]$ and $m_i$ spans $[0.50, 0.72]$.\n    -   The scaling vectors $w_i$ and $v_i$ are specified to encode a \"genus-2 multiplicity pattern (two families of 6 modes each)\". This is interpreted as a repeating pattern. We construct $w_i$ by generating $6$ linearly spaced points in $[0.85, 1.15]$ and tiling this sequence twice. A similar procedure is applied to $v_i$ over the interval $[0.90, 1.10]$.\n\n2.  **Spectral Surrogate Functions:** We define functions to compute the eigenvalues of the EFIE and MFIE operators as functions of the wavenumber $k$.\n    -   The EFIE eigenvalues $\\lambda_{E,i}(k)$ are given by:\n    $$\n    \\lambda_{E,i}(k) \\,=\\, b_i \\;-\\; \\sum_{j=1}^{4} a_{E,i,j}\\,\\frac{\\gamma_{E,j}^{2}}{(k - k_{E,j})^{2} + \\gamma_{E,j}^{2}}\n    $$\n    where the amplitudes $a_{E,i,j}$ are products of the given constants ($0.35, 0.30, 0.12, 0.10$) and the mode-dependent scaling factor $w_i$. The summation models the resonant dips characteristic of the EFIE.\n    -   The MFIE eigenvalues $\\lambda_{M,i}(k)$ are given by:\n    $$\n    \\lambda_{M,i}(k) \\,=\\, m_i \\;+\\; \\sum_{j=1}^{2} q_{M,i,j}\\,\\frac{\\gamma_{M,j}^{2}}{(k - k_{M,j})^{2} + \\gamma_{M,j}^{2}}\n    $$\n    where the amplitudes $q_{M,i,j}$ are products of the constants ($0.08, 0.07$) and the scaling factor $v_i$. This models the typically more stable spectrum of the MFIE.\n\n3.  **CFIE Spectrum and Performance Metric:** The core of the analysis involves the CFIE, which combines the EFIE and MFIE operators.\n    -   The CFIE eigenvalues are a convex combination:\n    $$\n    \\lambda_{C,i}(k,\\alpha) \\,=\\, \\alpha\\, \\lambda_{E,i}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\lambda_{M,i}(k)\n    $$\n    for a mixing parameter $\\alpha \\in [0,1]$.\n    -   The performance of an iterative solver is related to the condition number of the system matrix. The problem defines the condition number as:\n    $$\n    \\kappa(\\alpha,k) \\,=\\, \\frac{\\max_{i}\\lambda_{C,i}(k,\\alpha)}{\\min_{i}\\lambda_{C,i}(k,\\alpha)}\n    $$\n    -   For an optimally scaled Richardson iteration, the spectral radius of the iteration matrix, which determines the asymptotic convergence rate, is:\n    $$\n    \\rho^{\\star}(\\alpha,k) \\,=\\, \\frac{\\kappa(\\alpha,k) - 1}{\\kappa(\\alpha,k) + 1}\n    $$\n    Minimizing this spectral radius $\\rho^{\\star}$ is equivalent to minimizing the condition number $\\kappa$, as $\\rho^{\\star}$ is a monotonically increasing function of $\\kappa \\ge 1$.\n\n4.  **Adaptive Mixing Strategy and its Evaluation:** The problem proposes a heuristic for choosing $\\alpha$ adaptively based on the condition numbers of the constituent operators.\n    -   We first compute the condition numbers for the EFIE and MFIE eigenvalue sets:\n    $$\n    \\kappa_{E}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{E,i}(k)}{\\min_{i}\\lambda_{E,i}(k)},\\quad\n    \\kappa_{M}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{M,i}(k)}{\\min_{i}\\lambda_{M,i}(k)}\n    $$\n    -   The adaptive parameter $\\alpha_{\\mathrm{ad}}(k)$ is formulated to give more weight to the operator with the lower condition number (higher stability score $s = 1/\\kappa$). With sharpness $p=2$:\n    $$\n    \\alpha_{\\mathrm{ad}}(k) \\,=\\, \\frac{\\left[s_{E}(k)\\right]^{p}}{\\left[s_{E}(k)\\right]^{p} + \\left[s_{M}(k)\\right]^{p}} = \\frac{\\kappa_{M}(k)^p}{\\kappa_{M}(k)^p + \\kappa_{E}(k)^p}\n    $$\n    -   The performance of this adaptive choice, $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k)$, is then compared against the globally optimal value, $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$.\n\n5.  **Numerical Optimization:** To find the globally optimal spectral radius, a numerical minimization is required for each test wavenumber $k$. The target function is $f(\\alpha) = \\rho^{\\star}(\\alpha,k)$. Since $\\alpha$ is constrained to the interval $[0,1]$, a bounded one-dimensional optimization algorithm is employed. The `scipy.optimize.minimize_scalar` function with the 'bounded' method is suitable for this purpose.\n\n6.  **Computational Procedure:** For each wavenumber $k$ in the provided test suite, the following steps are executed:\n    a. Compute the $N=12$ eigenvalues for EFIE, $\\lambda_{E,i}(k)$, and MFIE, $\\lambda_{M,i}(k)$.\n    b. Calculate the adaptive mixing parameter $\\alpha_{\\mathrm{ad}}(k)$.\n    c. Compute the spectral radius $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k),k)$ using the adaptive parameter.\n    d. Numerically find the minimum spectral radius $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$ by optimizing over $\\alpha$.\n    e. A boolean flag is determined by checking if the adaptive spectral radius is within a $5\\%$ relative tolerance of the optimal one:\n    $$\n    \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k) \\,\\le\\, 1.05 \\times \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)\n    $$\n    Finally, the collected results are formatted into a single list of lists as specified, with floating-point numbers rounded to $6$ decimal places.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and algorithmically optimizes a Combined Field Integral Equation (CFIE)\n    to mitigate internal resonances using a spectral surrogate model.\n    \"\"\"\n    # 1. Define Constants and Parameters\n    N = 12\n    P_SHARPNESS = 2.0\n\n    # EFIE resonance parameters\n    KE_RESONANCES = np.array([5.0, 8.0, 3.2, 9.2])\n    GAMMA_E = np.array([0.08, 0.06, 0.05, 0.07])\n\n    # MFIE resonance parameters\n    KM_RESONANCES = np.array([6.3, 9.5])\n    GAMMA_M = np.array([0.08, 0.07])\n\n    # 2. Generate Deterministic Mode-Dependent Arrays\n    b_i = np.linspace(0.95, 1.25, N)\n    m_i = np.linspace(0.50, 0.72, N)\n    \n    # Per problem statement: \"genus-2 multiplicity pattern (two families of 6 modes each)\"\n    w_i = np.tile(np.linspace(0.85, 1.15, 6), 2)\n    v_i = np.tile(np.linspace(0.90, 1.10, 6), 2)\n\n    # Pre-calculate mode-dependent amplitudes\n    a_E_factors = np.array([0.35, 0.30, 0.12, 0.10])\n    a_E_ij = np.outer(w_i, a_E_factors)  # Shape (12, 4)\n\n    q_M_factors = np.array([0.08, 0.07])\n    q_M_ij = np.outer(v_i, q_M_factors)  # Shape (12, 2)\n\n    def lorentzian(k, k_res_vec, gamma_vec):\n        \"\"\"Calculates an array of Lorentzian terms.\"\"\"\n        return (gamma_vec**2) / ((k - k_res_vec)**2 + gamma_vec**2)\n\n    # 3. Implement Eigenvalue Functions\n    def get_lambda_E(k):\n        \"\"\"Computes the 12 EFIE eigenvalues for a given wavenumber k.\"\"\"\n        lorentzian_terms = lorentzian(k, KE_RESONANCES, GAMMA_E)\n        sum_term = np.dot(a_E_ij, lorentzian_terms)\n        return b_i - sum_term\n\n    def get_lambda_M(k):\n        \"\"\"Computes the 12 MFIE eigenvalues for a given wavenumber k.\"\"\"\n        lorentzian_terms = lorentzian(k, KM_RESONANCES, GAMMA_M)\n        sum_term = np.dot(q_M_ij, lorentzian_terms)\n        return m_i + sum_term\n\n    def get_lambda_C(lambda_E, lambda_M, alpha):\n        \"\"\"Computes the CFIE eigenvalues.\"\"\"\n        return alpha * lambda_E + (1.0 - alpha) * lambda_M\n\n    # 4. Implement Performance Metric and Adaptive Parameter Functions\n    def get_rho_star_from_lambdas(lambdas_C):\n        \"\"\"Calculates the optimal Richardson spectral radius from eigenvalues.\"\"\"\n        min_lambda = np.min(lambdas_C)\n        if min_lambda = 0:\n            return np.inf  # Problem guarantees positivity, but good practice\n        kappa = np.max(lambdas_C) / min_lambda\n        return (kappa - 1.0) / (kappa + 1.0)\n\n    def get_alpha_ad(lambda_E, lambda_M):\n        \"\"\"Calculates the adaptive mixing parameter.\"\"\"\n        kappa_E = np.max(lambda_E) / np.min(lambda_E)\n        kappa_M = np.max(lambda_M) / np.min(lambda_M)\n        \n        # Using the formulation alpha = kappa_M^p / (kappa_M^p + kappa_E^p)\n        # which is equivalent to the one based on stability scores s=1/kappa\n        # and is numerically more stable if a kappa is very large.\n        term_M_p = kappa_M ** P_SHARPNESS\n        term_E_p = kappa_E ** P_SHARPNESS\n        \n        if term_M_p + term_E_p == 0:\n            return 0.5 # Fallback for a potential 0/0 case, though unlikely\n        \n        return term_M_p / (term_M_p + term_E_p)\n\n    # 5. Define Test Suite and Main Loop\n    test_k_values = [4.0, 5.0, 6.3, 8.0, 9.2, 9.5, 3.2, 10.0]\n    all_results = []\n\n    for k in test_k_values:\n        lambda_E = get_lambda_E(k)\n        lambda_M = get_lambda_M(k)\n\n        # Task 1: Compute adaptive parameter\n        alpha_ad = get_alpha_ad(lambda_E, lambda_M)\n\n        # Task 2: Compute spectral radius for the adaptive choice\n        lambda_C_ad = get_lambda_C(lambda_E, lambda_M, alpha_ad)\n        rho_star_ad = get_rho_star_from_lambdas(lambda_C_ad)\n\n        # Task 3: Numerically find the globally minimized spectral radius\n        def objective_func(alpha):\n            lambdas_C = get_lambda_C(lambda_E, lambda_M, alpha)\n            return get_rho_star_from_lambdas(lambdas_C)\n        \n        opt_result = minimize_scalar(objective_func, bounds=(0, 1), method='bounded')\n        rho_star_opt = opt_result.fun\n\n        # Task 4: Compare adaptive vs optimal\n        is_near_optimal = rho_star_ad = 1.05 * rho_star_opt\n\n        all_results.append([\n            alpha_ad,\n            rho_star_ad,\n            rho_star_opt,\n            is_near_optimal\n        ])\n\n    # 6. Format and Print Output\n    formatted_results = []\n    for res in all_results:\n        # Format: [float, float, float, bool]\n        # Floats are rounded to 6 decimal places implicitly by formatter\n        # Python's str(bool) results in 'True'/'False' as required\n        formatted_r = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]}]\"\n        formatted_results.append(formatted_r)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3319825"}]}