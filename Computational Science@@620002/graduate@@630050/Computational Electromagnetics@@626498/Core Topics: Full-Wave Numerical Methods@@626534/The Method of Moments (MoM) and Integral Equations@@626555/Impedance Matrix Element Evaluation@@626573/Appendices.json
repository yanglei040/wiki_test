{"hands_on_practices": [{"introduction": "Evaluating impedance matrix elements begins with a solid understanding of the underlying integral operators. The Combined Field Integral Equation (CFIE) is a widely used and robust formulation, and this exercise focuses on analytically deriving a key component of its impedance matrix. By isolating the local contribution from the Magnetic Field Integral Equation (MFIE) operator, you will engage directly with the operator theory and the properties of Rao-Wilton-Glisson (RWG) basis functions, building a foundational understanding of how these elements are constructed.", "problem": "Consider a perfectly electrically conducting (PEC) smooth closed surface discretized by two identical equilateral planar triangles of side length $s$ that share a common edge. Use a single Rao–Wilton–Glisson (RWG) basis function $\\mathbf{f}$ supported on these two triangles and employ a Galerkin testing scheme with the same RWG function. Assume free-space with permittivity $\\varepsilon$, permeability $\\mu$, wavenumber $k$, and wave impedance $\\eta = \\sqrt{\\mu/\\varepsilon}$. The Combined Field Integral Equation (CFIE) is formed as a convex combination of the Electric Field Integral Equation (EFIE) and the Magnetic Field Integral Equation (MFIE) with parameter $\\alpha \\in (0,1)$, so that the CFIE operator is $\\,\\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}\\,$ acting on the surface current density $\\mathbf{J}$. \n\nStarting from the time-harmonic Maxwell equations $\\,\\nabla \\times \\mathbf{E} = i \\omega \\mu \\mathbf{H}\\,$ and $\\,\\nabla \\times \\mathbf{H} = -i \\omega \\varepsilon \\mathbf{E}\\,$, the free-space Green's function $\\,G(\\mathbf{r},\\mathbf{r}')=\\exp(i k |\\mathbf{r}-\\mathbf{r}'|)/(4\\pi |\\mathbf{r}-\\mathbf{r}'|)\\,$, and the boundary integral representation of the scattered magnetic field due to a surface current sheet, use the canonical jump relations of singular boundary integral operators on smooth closed surfaces to identify the principal value contribution of the MFIE. Then, under the assumption that local curvature over the two-triangle support is negligible so the planar RWG geometry is valid, evaluate the singular MFIE contribution to the CFIE diagonal impedance matrix element $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ associated with $\\mathbf{f}$, expressed via the Galerkin bilinear form $\\,\\langle \\mathbf{f}, \\cdot \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot (\\cdot)\\, \\mathrm{d}S\\,$. \n\nTo carry out the calculation, use the standard RWG definition on an equilateral pair: on the “positive” triangle $T^{+}$ with free vertex at $\\mathbf{r}^{+}$, set $\\,\\mathbf{f}(\\mathbf{r}) = \\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{+}(\\mathbf{r})\\,$, and on the “negative” triangle $T^{-}$ with free vertex at $\\mathbf{r}^{-}$, set $\\,\\mathbf{f}(\\mathbf{r}) = -\\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{-}(\\mathbf{r})\\,$, where $\\,\\ell=s\\,$ is the common edge length, $\\,A=\\dfrac{\\sqrt{3}}{4}s^{2}\\,$ is the triangle area, and $\\,\\boldsymbol{\\rho}^{\\pm}(\\mathbf{r})$ is the in-triangle vector from the free vertex to the point $\\mathbf{r}$. Parameterize each equilateral triangle by $\\,\\mathbf{r}(u,v)=u\\,\\mathbf{a}+v\\,\\mathbf{b}\\,$ with $\\,u\\ge 0\\,$, $\\,v\\ge 0\\,$, $\\,u+v\\le 1\\,$, where $\\,\\mathbf{a}\\,$ and $\\,\\mathbf{b}\\,$ are edge vectors of lengths $\\,|\\mathbf{a}|=|\\mathbf{b}|=s\\,$ and mutual angle $\\,60^{\\circ}\\,$. The area element satisfies $\\,\\mathrm{d}S = |\\mathbf{a}\\times \\mathbf{b}|\\, \\mathrm{d}u\\,\\mathrm{d}v\\,$, with $\\,|\\mathbf{a}\\times \\mathbf{b}| = \\dfrac{\\sqrt{3}}{2}s^{2}\\,$.\n\nExpress your final answer as a closed-form analytic expression for $\\,Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}\\,$ in terms of $\\,\\alpha\\,$, $\\,\\eta\\,$, and $\\,s\\,$. No numerical rounding is required and no physical units should be included in the final expression.", "solution": "The problem requires the evaluation of the singular contribution of the Magnetic Field Integral Equation (MFIE) to the diagonal impedance matrix element of the Combined Field Integral Equation (CFIE), using a Galerkin scheme with a Rao-Wilton-Glisson (RWG) basis function.\n\nThe problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. All provided definitions and parameters are consistent with standard literature in computational electromagnetics.\n\nThe CFIE operator, acting on a surface current density $\\mathbf{J}$, is given as $\\mathcal{L}_{\\mathrm{CFIE}} = \\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}$, where $\\mathcal{T}_{\\mathrm{E}}$ and $\\mathcal{T}_{\\mathrm{M}}$ are the Electric and Magnetic Field Integral Equation operators, respectively, $\\alpha \\in (0,1)$ is a combination parameter, and $\\eta$ is the wave impedance of the medium.\n\nIn a Galerkin-based Method of Moments (MoM) formulation, a diagonal impedance element $Z$ associated with a basis function $\\mathbf{f}$ is given by the inner product:\n$$Z = \\langle \\mathbf{f}, \\mathcal{L}_{\\mathrm{CFIE}}(\\mathbf{f}) \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\left[ \\alpha\\,\\mathcal{T}_{\\mathrm{E}}(\\mathbf{f})(\\mathbf{r}) + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}(\\mathbf{f})(\\mathbf{r}) \\right] \\mathrm{d}S$$\nThe problem directs us to find the singular contribution arising from the MFIE part of this expression. The MFIE operator relates the surface current density $\\mathbf{J}$ to the incident magnetic field. Its formulation involves an integral operator whose kernel is singular. The behavior of this operator at the surface is described by jump conditions. The scattered magnetic field $\\mathbf{H}^s$ at a point $\\mathbf{r}$ is given by $\\mathbf{H}^s(\\mathbf{r}) = \\nabla \\times \\int_S \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') \\mathrm{d}S'$, where $G$ is the free-space Green's function. The jump condition for the tangential component of this field across the surface $S$ gives rise to a local term and a principal value (P.V.) integral. The MFIE operator acting on the current $\\mathbf{J}$ can be expressed as:\n$$\\mathcal{T}_{\\mathrm{M}}(\\mathbf{J})(\\mathbf{r}) = \\frac{1}{2}\\mathbf{J}(\\mathbf{r}) + \\mathbf{\\hat{n}}(\\mathbf{r}) \\times \\mathrm{P.V.} \\int_S \\nabla G(\\mathbf{r}, \\mathbf{r}') \\times \\mathbf{J}(\\mathbf{r}') \\mathrm{d}S'$$\nThe term $\\frac{1}{2}\\mathbf{J}(\\mathbf{r})$ is the local, non-integral contribution that arises from the singularity of the Green's function kernel. This is the \"principal value contribution\" isolated by the jump relation, which the problem asks us to evaluate. The other term, the Cauchy Principal Value integral, is computationally intensive but is weakly singular and will not be considered part of the \"singular contribution\" in this context. The EFIE operator $\\mathcal{T}_{\\mathrm{E}}$ involves a stronger (hyper-singular) singularity, which is handled differently and is not the focus here.\n\nThe singular contribution to the CFIE operator is therefore $\\mathcal{L}_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = (1-\\alpha)\\eta\\,\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}$, where $\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}(\\mathbf{f}) = \\frac{1}{2}\\mathbf{f}$.\nThe corresponding singular contribution to the diagonal impedance element $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ is:\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\left\\langle \\mathbf{f}, (1-\\alpha)\\eta \\left(\\frac{1}{2}\\mathbf{f}\\right) \\right\\rangle = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\mathbf{f}(\\mathbf{r}) \\, \\mathrm{d}S = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe integral is over the support of $\\mathbf{f}$, which consists of two adjacent equilateral triangles, $T^{+}$ and $T^{-}$. Due to the symmetry of the basis function definition on the two identical triangles, the integral over the full support is twice the integral over one triangle:\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S + \\int_{T^{-}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe RWG basis function on the \"positive\" triangle $T^{+}$ is defined as $\\mathbf{f}(\\mathbf{r}) = \\frac{\\ell}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r})$, where $\\ell=s$ is the side length, $A=\\frac{\\sqrt{3}}{4}s^2$ is the area of a single triangle, and $\\boldsymbol{\\rho}^{+}(\\mathbf{r}) = \\mathbf{r} - \\mathbf{r}^{+}$ is the position vector from the free vertex $\\mathbf{r}^{+}$ to a point $\\mathbf{r} \\in T^{+}$.\nThe integral over $T^{+}$ becomes:\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} \\left| \\frac{s}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r}) \\right|^2 \\, \\mathrm{d}S = \\left(\\frac{s}{2A}\\right)^2 \\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\nThe integral $\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$ is the polar moment of inertia of the triangular area $T^{+}$ about its free vertex, assuming a uniform mass density of $1$. We can evaluate this by parameterizing the triangle. Let the free vertex $\\mathbf{r}^{+}$ be at the origin. The other vertices are defined by vectors $\\mathbf{a}$ and $\\mathbf{b}$ of length $s$ with an angle of $60^{\\circ}$ between them. A point $\\mathbf{r}$ in the triangle is $\\mathbf{r}(u,v) = u\\mathbf{a} + v\\mathbf{b}$ for $u \\ge 0, v \\ge 0, u+v \\le 1$.\nThen $|\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 = |\\mathbf{r}|^2 = |u\\mathbf{a} + v\\mathbf{b}|^2 = u^2|\\mathbf{a}|^2 + v^2|\\mathbf{b}|^2 + 2uv(\\mathbf{a}\\cdot\\mathbf{b}) = s^2(u^2+v^2+uv)$.\nThe area element is $\\mathrm{d}S = |\\mathbf{a} \\times \\mathbf{b}| \\mathrm{d}u\\mathrm{d}v = s^2\\sin(60^{\\circ})\\mathrm{d}u\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\mathrm{d}u\\mathrm{d}v$.\nThe integral is:\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{u=0}^{1} \\int_{v=0}^{1-u} s^2(u^2+v^2+uv) \\left(\\frac{\\sqrt{3}}{2}s^2\\right) \\mathrm{d}v\\mathrm{d}u$$\n$$ = \\frac{\\sqrt{3}}{2}s^4 \\int_{u=0}^{1}\\int_{v=0}^{1-u} (u^2+v^2+uv) \\mathrm{d}v\\mathrm{d}u$$\nUsing the standard integral formula over a unit simplex, $\\int_{0}^{1}\\int_{0}^{1-u} u^a v^b \\mathrm{d}v\\mathrm{d}u = \\frac{a!b!}{(a+b+2)!}$:\n$$\\int_{0}^{1}\\int_{0}^{1-u} u^2 \\mathrm{d}v\\mathrm{d}u = \\frac{2!0!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} v^2 \\mathrm{d}v\\mathrm{d}u = \\frac{0!2!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} uv \\mathrm{d}v\\mathrm{d}u = \\frac{1!1!}{4!} = \\frac{1}{24}$$\nThe sum of these integrals is $\\frac{1}{12} + \\frac{1}{12} + \\frac{1}{24} = \\frac{2+2+1}{24} = \\frac{5}{24}$.\nSo, the polar moment of inertia is:\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\frac{\\sqrt{3}}{2}s^4 \\left(\\frac{5}{24}\\right) = \\frac{5\\sqrt{3}}{48}s^4$$\nNow we substitute this back. The pre-factor is:\n$$\\left(\\frac{s}{2A}\\right)^2 = \\left(\\frac{s}{2 \\cdot \\frac{\\sqrt{3}}{4}s^2}\\right)^2 = \\left(\\frac{s}{\\frac{\\sqrt{3}}{2}s^2}\\right)^2 = \\left(\\frac{2}{\\sqrt{3}s}\\right)^2 = \\frac{4}{3s^2}$$\nThe integral over one triangle is:\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\left(\\frac{4}{3s^2}\\right) \\left(\\frac{5\\sqrt{3}}{48}s^4\\right) = \\frac{20\\sqrt{3}}{144}s^2 = \\frac{5\\sqrt{3}}{36}s^2$$\nThe total integral over the support $S = T^{+} \\cup T^{-}$ is:\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\times \\frac{5\\sqrt{3}}{36}s^2 = \\frac{5\\sqrt{3}}{18}s^2$$\nFinally, we can compute the value of $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$:\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\frac{1}{2}(1-\\alpha)\\eta \\left( \\frac{5\\sqrt{3}}{18}s^2 \\right) = \\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^2$$\nThis expression represents the singular contribution of the MFIE operator to the diagonal impedance element as requested.", "answer": "$$\n\\boxed{\\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^{2}}\n$$", "id": "3317565"}, {"introduction": "Once the analytical form of the impedance elements is known, the next challenge is their accurate numerical computation. This task is complicated by the singular nature of the Green's function, which requires special treatment when geometric elements are close. This practice introduces an advanced quadrature technique to handle these weakly singular integrals by using a nonlinear coordinate transformation. Implementing and analyzing this \"stretched\" quadrature rule provides direct insight into the numerical methods that ensure accuracy and stability in modern Method of Moments codes.", "problem": "Consider two co-axial, parallel, square panels of side length $2a$ in three-dimensional free space. The source panel lies in the plane $z=0$ and the testing panel lies in the parallel plane $z=\\delta$, where $\\delta>0$ is the minimum clearance distance. Let $\\mathbf{r}=(x,y,0)$ and $\\mathbf{r}'=(x',y',\\delta)$ with $(x,y)$ and $(x',y')$ each ranging over the square $[-a,a]\\times[-a,a]$. For the three-dimensional Helmholtz equation with wavenumber $k$ (in radians per meter), the free-space scalar Green's function is $G_k(r)=\\exp(i k r)/(4\\pi r)$, where $r=\\|\\mathbf{r}-\\mathbf{r}'\\|$. In a pulse-basis, pulse-test Method of Moments impedance matrix element, the representative entry is the double surface integral\n$$\nZ(a,\\delta,k) \\;=\\; \\iint_{S_t} \\iint_{S_s} G_k\\big(\\|\\mathbf{r}-\\mathbf{r}'\\|\\big)\\, dS_{\\mathbf{r}}\\, dS_{\\mathbf{r}'},\n$$\nwhere $S_t=S_s=[-a,a]\\times[-a,a]$. By introducing the difference variables $\\Delta x=x-x'$ and $\\Delta y=y-y'$, this integral can be written as a weighted convolution integral\n$$\nZ(a,\\delta,k) \\;=\\; \\int_{-2a}^{2a} \\int_{-2a}^{2a} \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big)\\, \\frac{e^{i k \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}}}{4\\pi \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}} \\, d\\Delta x\\, d\\Delta y.\n$$\nThe kernel is weakly singular as $\\delta\\to 0^+$, in the sense that it behaves like $1/\\sqrt{\\rho^2+\\delta^2}$ with $\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}$ near $\\rho=0$. A standard tensor-product Gauss–Legendre quadrature on $[-2a,2a]\\times[-2a,2a]$ without coordinate stretching can incur large errors for small $\\delta$ due to insufficient resolution near $\\rho=0$. To address this, develop a quadrature rule by mapping to a stretched coordinate aligned with the minimum clearance direction, using the transformation\n$$\n\\Delta x \\;=\\; s(\\xi) \\;=\\; \\frac{2a\\,\\sinh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\quad \\Delta y \\;=\\; s(\\eta) \\;=\\; \\frac{2a\\,\\sinh(\\gamma \\eta)}{\\sinh(\\gamma)}, \\quad \\xi,\\eta \\in [-1,1],\n$$\nwith Jacobians\n$$\n\\frac{d\\Delta x}{d\\xi} \\;=\\; \\frac{2a\\,\\gamma \\cosh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\qquad \\frac{d\\Delta y}{d\\eta} \\;=\\; \\frac{2a\\,\\gamma \\cosh(\\gamma \\eta)}{\\sinh(\\gamma)}.\n$$\nChoose the stretch parameter as\n$$\n\\gamma \\;=\\; \\operatorname{asinh}\\!\\left(\\frac{2a}{\\delta}\\right),\n$$\nso that the smallest geometric scale near $\\rho=0$ is resolved uniformly in the stretched coordinates as $\\delta\\to 0^+$. Apply tensor-product Gauss–Legendre quadrature of order $N$ in $(\\xi,\\eta)$ to approximate $Z(a,\\delta,k)$ via this mapping. The standard (unstretched) rule corresponds to the affine map $\\Delta x=2a\\,\\xi$, $\\Delta y=2a\\,\\eta$ with constant Jacobian $4a^2$.\n\nTasks:\n- Starting from the definition of $Z(a,\\delta,k)$ above and the weighted difference-variable formulation, derive the mapped quadrature formula in $(\\xi,\\eta)$ for the stretched transformation specified. Your derivation must be grounded in the fundamental expressions for the Green's function and the change-of-variables theorem for multiple integrals.\n- Provide a principle-based derivation of the asymptotic error scaling of the stretched-rule quadrature with respect to $\\delta$ and $k$, assuming fixed quadrature order $N$ and fixed panel half-size $a$. Your derivation should explain why aligning the coordinate transform with the minimum clearance distance $\\delta$ mitigates the weak singularity and how $k$ influences the resolution requirements through oscillations of $e^{i k r}$.\n- Implement both the standard affine quadrature and the stretched quadrature described above, and estimate the absolute quadrature error by comparison to a high-accuracy reference approximation of $Z(a,\\delta,k)$ computed with the stretched mapping at a substantially higher quadrature order $N_{\\mathrm{ref}}$. The integral is to be evaluated numerically; there is no closed-form target to use.\n\nUse the following numerical parameters as a test suite:\n- Panel half-size: $a=0.5$ meters.\n- Quadrature orders: $N=16$ for both the standard affine and stretched rules; $N_{\\mathrm{ref}}=80$ for the high-accuracy reference approximation.\n- For examining $\\delta$-scaling at fixed $k$, use $\\delta \\in \\{10^{-1},\\,5\\times 10^{-2},\\,2.5\\times 10^{-2},\\,1.25\\times 10^{-2}\\}$ meters and $k=10$ radians per meter.\n- For examining $k$-scaling at fixed $\\delta$, use $k \\in \\{1,\\,2,\\,5,\\,10\\}$ radians per meter and $\\delta=1.25\\times 10^{-2}$ meters.\n\nFor each set, compute:\n- The slope $s_{\\mathrm{std},\\delta}$ of $\\log_{10}$ absolute error of the standard rule versus $\\log_{10}\\delta$ (linear regression over the above $\\delta$ values at fixed $k$).\n- The slope $s_{\\mathrm{str},\\delta}$ of $\\log_{10}$ absolute error of the stretched rule versus $\\log_{10}\\delta$ (linear regression over the above $\\delta$ values at fixed $k$).\n- The slope $s_{\\mathrm{str},k}$ of $\\log_{10}$ absolute error of the stretched rule versus $\\log_{10}k$ (linear regression over the above $k$ values at fixed $\\delta$).\n- The improvement ratio $R=\\mathcal{E}_{\\mathrm{std}}/\\mathcal{E}_{\\mathrm{str}}$ at $\\delta=1.25\\times 10^{-2}$ meters and $k=10$ radians per meter, where $\\mathcal{E}_{\\mathrm{std}}$ and $\\mathcal{E}_{\\mathrm{str}}$ are the absolute errors of the standard and stretched rules, respectively.\n\nAll physical lengths must be treated in meters and wavenumbers in radians per meter. The absolute errors and slopes are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[s_{\\mathrm{std},\\delta}, s_{\\mathrm{str},\\delta}, s_{\\mathrm{str},k}, R]$.", "solution": "The objective is to numerically evaluate the impedance matrix element $Z(a,\\delta,k)$ for the interaction between two parallel, coaxial square panels using two different quadrature schemes, and to analyze their error characteristics. The integral is given by\n$$\nZ(a,\\delta,k) = \\int_{-2a}^{2a} \\int_{-2a}^{2a} \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big)\\, \\frac{e^{i k \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}}}{4\\pi \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}} \\, d\\Delta x\\, d\\Delta y.\n$$\nThis integral presents a numerical challenge for small clearance distances $\\delta$, as the kernel exhibits a weak singularity at the origin $(\\Delta x, \\Delta y) = (0,0)$. We will derive and compare a standard affine tensor-product Gauss-Legendre quadrature with a specialized quadrature based on a coordinate stretching transformation designed to mitigate this singularity.\n\n**Derivation of the Mapped Quadrature Formula**\n\nThe core of the task is to transform the integral from the physical difference-variable domain $(\\Delta x, \\Delta y) \\in [-2a, 2a] \\times [-2a, 2a]$ to a computational domain $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$, over which a standard tensor-product Gauss-Legendre quadrature can be applied. The general form of a tensor-product quadrature approximation of order $N$ for an integral over this computational domain is\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} F(\\xi, \\eta) \\,d\\xi\\,d\\eta \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j F(\\xi_i, \\xi_j)\n$$\nwhere $(\\xi_i, w_i)$ are the $N$ Gauss-Legendre nodes and weights on $[-1, 1]$.\n\nLet the integrand be denoted by\n$$\nI(\\Delta x, \\Delta y) = \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big) G_k\\big(\\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}\\big),\n$$\nwhere $G_k(r) = e^{ikr}/(4\\pi r)$ is the free-space Green's function.\n\n**1. Standard Affine Quadrature Rule**\nThe standard rule uses a simple affine mapping from the computational domain to the physical domain:\n$$\n\\Delta x = 2a\\,\\xi, \\qquad \\Delta y = 2a\\,\\eta.\n$$\nThe differential area element transforms according to the Jacobian of the mapping:\n$$\nd\\Delta x\\,d\\Delta y = \\left|\\frac{\\partial(\\Delta x, \\Delta y)}{\\partial(\\xi, \\eta)}\\right| d\\xi\\,d\\eta = \\left(\\frac{d\\Delta x}{d\\xi}\\right) \\left(\\frac{d\\Delta y}{d\\eta}\\right) d\\xi\\,d\\eta = (2a)(2a)\\,d\\xi\\,d\\eta = 4a^2\\,d\\xi\\,d\\eta.\n$$\nSubstituting this into the integral for $Z(a,\\delta,k)$ yields:\n$$\nZ_{\\mathrm{std}}(a,\\delta,k) = \\int_{-1}^{1}\\int_{-1}^{1} I(2a\\xi, 2a\\eta) \\cdot 4a^2 \\,d\\xi\\,d\\eta.\n$$\nApplying the $N$-th order Gauss-Legendre quadrature rule gives the numerical approximation:\n$$\nZ_{\\mathrm{std}}(a,\\delta,k) \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\left[ \\big(2a-2a|\\xi_i|\\big)\\big(2a-2a|\\xi_j|\\big) \\frac{e^{i k r_{ij}}}{4\\pi r_{ij}} \\cdot 4a^2 \\right],\n$$\nwhere $r_{ij} = \\sqrt{(2a\\xi_i)^2+(2a\\xi_j)^2+\\delta^2}$.\n\n**2. Stretched Quadrature Rule**\nThe stretched rule employs the nonlinear transformation:\n$$\n\\Delta x = s(\\xi) = \\frac{2a\\,\\sinh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\qquad \\Delta y = s(\\eta) = \\frac{2a\\,\\sinh(\\gamma \\eta)}{\\sinh(\\gamma)}.\n$$\nThe stretch parameter is chosen as $\\gamma = \\operatorname{asinh}(2a/\\delta)$. The Jacobian of this transformation is given by the product of the derivatives:\n$$\nJ(\\xi, \\eta) = \\frac{d\\Delta x}{d\\xi} \\frac{d\\Delta y}{d\\eta} = \\left(\\frac{2a\\,\\gamma \\cosh(\\gamma \\xi)}{\\sinh(\\gamma)}\\right) \\left(\\frac{2a\\,\\gamma \\cosh(\\gamma \\eta)}{\\sinh(\\gamma)}\\right) = \\left(\\frac{2a\\gamma}{\\sinh(\\gamma)}\\right)^2 \\cosh(\\gamma \\xi) \\cosh(\\gamma \\eta).\n$$\nThe integral for $Z(a,\\delta,k)$ transforms to:\n$$\nZ_{\\mathrm{str}}(a,\\delta,k) = \\int_{-1}^{1}\\int_{-1}^{1} I(s(\\xi), s(\\eta)) J(\\xi, \\eta) \\,d\\xi\\,d\\eta.\n$$\nThe quadrature approximation is then:\n$$\nZ_{\\mathrm{str}}(a,\\delta,k) \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\left[ \\big(2a-|s(\\xi_i)|\\big)\\big(2a-|s(\\eta_j)|\\big) \\frac{e^{i k r_{ij}}}{4\\pi r_{ij}} J(\\xi_i, \\xi_j) \\right],\n$$\nwhere $r_{ij} = \\sqrt{s(\\xi_i)^2+s(\\eta_j)^2+\\delta^2}$. Note that since $\\sinh(t)$ is an odd function, $|s(t)| = s(|t|)$.\n\n**Asymptotic Error Scaling Analysis**\n\nThe error in Gauss-Legendre quadrature is related to the magnitude of high-order derivatives of the integrand. The challenge in the present problem stems from the behavior of the integrand as $\\delta \\to 0^+$.\n\n**Error Scaling with Respect to $\\delta$**\nThe source of numerical difficulty is the term $1/r = 1/\\sqrt{\\rho^2 + \\delta^2}$, where $\\rho^2 = (\\Delta x)^2 + (\\Delta y)^2$. As $\\delta \\to 0$, this function develops a sharp peak at $\\rho=0$, with a characteristic width proportional to $\\delta$.\n\n- **Standard Rule Error ($s_{\\mathrm{std},\\delta}$)**: The affine mapping distributes quadrature points uniformly in the $(\\Delta x, \\Delta y)$ plane (after accounting for the natural clustering of Gauss nodes near the boundaries). As $\\delta$ shrinks, the sharp peak of the integrand becomes narrower than the spacing between the fixed quadrature points near the origin. The fixed-order polynomial basis of the quadrature rule cannot accurately represent this increasingly sharp feature. Consequently, the quadrature error grows as $\\delta$ decreases. We expect the error $\\mathcal{E}_{\\mathrm{std}}$ to scale like $\\delta^{\\alpha}$ with $\\alpha  0$, leading to a negative slope $s_{\\mathrm{std},\\delta} = d(\\log_{10}\\mathcal{E}_{\\mathrm{std}})/d(\\log_{10}\\delta)  0$.\n\n- **Stretched Rule Error ($s_{\\mathrm{str},\\delta}$)**: The stretching transformation is specifically designed to counteract this problem. Consider the behavior near the origin $(\\xi, \\eta) \\to (0,0)$. For small arguments, $\\sinh(\\gamma t) \\approx \\gamma t$. With $\\gamma = \\operatorname{asinh}(2a/\\delta)$, we have $\\sinh(\\gamma) = 2a/\\delta$. The transformation becomes:\n$$\n\\Delta x = s(\\xi) \\approx \\frac{2a(\\gamma \\xi)}{2a/\\delta} = \\delta\\gamma\\xi.\n$$\nSimilarly, $\\Delta y \\approx \\delta\\gamma\\eta$. The distance $r$ near the origin is then\n$$\nr = \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2} \\approx \\sqrt{(\\delta\\gamma\\xi)^2+(\\delta\\gamma\\eta)^2+\\delta^2} = \\delta\\sqrt{\\gamma^2(\\xi^2+\\eta^2)+1}.\n$$\nThe crucial outcome is that the separation parameter $\\delta$ is factored out of the square root. The remaining term $\\sqrt{\\gamma^2(\\xi^2+\\eta^2)+1}$ is a smooth function of $(\\xi, \\eta)$ whose shape depends on $\\gamma$ but is not singular as $\\delta\\to 0$. The mapping effectively \"zooms in\" on the origin in physical space, allocating more quadrature points to the region of rapid variation. This regularizes the integrand in the computational $(\\xi, \\eta)$ domain. As a result, the quadrature error becomes largely insensitive to the value of $\\delta$. We therefore anticipate the error slope $s_{\\mathrm{str},\\delta}$ to be close to zero.\n\n**Error Scaling with Respect to $k$ ($s_{\\mathrm{str},k}$)**\nThe wavenumber $k$ governs the oscillations of the complex exponential term $e^{ikr}$. The spatial frequency of these oscillations is proportional to $k$. A quadrature rule of fixed order $N$ has a fixed number of sampling points. As $k$ increases, the integrand oscillates more rapidly. When the local wavelength becomes comparable to or smaller than the spacing between quadrature points, the quadrature rule can no longer accurately capture the function's behavior, leading to a rapid increase in error. The error of polynomial-based quadrature for oscillatory functions typically grows polynomially with the frequency. Thus, we expect the error $\\mathcal{E}_{\\mathrm{str}}$ to increase with $k$, yielding a positive slope $s_{\\mathrm{str},k} = d(\\log_{10}\\mathcal{E}_{\\mathrm{str}})/d(\\log_{10}k) > 0$. The stretching transformation does not address these oscillations; it is designed for the singularity at $\\rho=0$.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the error of standard and stretched quadrature rules\n    for a Method of Moments impedance matrix element.\n    \"\"\"\n    \n    # ------------------ Parameters ------------------\n    a = 0.5  # Panel half-size in meters\n    N = 16   # Quadrature order for test rules\n    N_ref = 80 # Quadrature order for reference solution\n\n    # Parameter sweeps from the problem statement\n    # Delta-scaling test parameters\n    k_fixed_for_delta_sweep = 10.0\n    delta_vals = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2])\n    \n    # K-scaling test parameters\n    delta_fixed_for_k_sweep = 1.25e-2\n    k_vals = np.array([1.0, 2.0, 5.0, 10.0])\n\n    # Cache for Gauss-Legendre nodes and weights\n    _quad_cache = {}\n    def get_quad_points(order):\n        if order not in _quad_cache:\n            nodes, weights = roots_legendre(order)\n            _quad_cache[order] = (nodes, weights)\n        return _quad_cache[order]\n\n    # ------------------ Quadrature Implementation ------------------\n    def compute_Z(a_val, delta, k, order, use_stretching):\n        \"\"\"\n        Computes the impedance integral Z using tensor-product Gauss-Legendre quadrature.\n        \"\"\"\n        nodes, weights = get_quad_points(order)\n        z_integral = 0.0 + 0.0j\n\n        if use_stretching:\n            # Stretched coordinate transformation\n            if delta == 0:\n                gamma = np.inf\n                sinh_gamma = np.inf\n            else:\n                gamma = np.arcsinh(2.0 * a_val / delta)\n                sinh_gamma = np.sinh(gamma)\n            \n            for i in range(order):\n                xi = nodes[i]\n                wi = weights[i]\n                \n                sinh_gamma_xi = np.sinh(gamma * xi)\n                cosh_gamma_xi = np.cosh(gamma * xi)\n                \n                delta_x = 2.0 * a_val * sinh_gamma_xi / sinh_gamma\n                jacobian_x = 2.0 * a_val * gamma * cosh_gamma_xi / sinh_gamma\n                \n                for j in range(order):\n                    eta = nodes[j]\n                    wj = weights[j]\n                    \n                    sinh_gamma_eta = np.sinh(gamma * eta)\n                    cosh_gamma_eta = np.cosh(gamma * eta)\n\n                    delta_y = 2.0 * a_val * sinh_gamma_eta / sinh_gamma\n                    jacobian_y = 2.0 * a_val * gamma * cosh_gamma_eta / sinh_gamma\n                    \n                    r = np.sqrt(delta_x**2 + delta_y**2 + delta**2)\n                    \n                    if r == 0:\n                        continue # Integrand is singular, but this point has zero measure\n                    \n                    # Full integrand including transformation Jacobian\n                    weight_func = (2.0 * a_val - np.abs(delta_x)) * (2.0 * a_val - np.abs(delta_y))\n                    green_func = np.exp(1j * k * r) / (4.0 * np.pi * r)\n                    jacobian = jacobian_x * jacobian_y\n                    \n                    integrand_val = weight_func * green_func * jacobian\n                    z_integral += wi * wj * integrand_val\n        else:\n            # Standard affine transformation\n            jacobian = (2.0 * a_val)**2\n            for i in range(order):\n                xi = nodes[i]\n                wi = weights[i]\n                delta_x = 2.0 * a_val * xi\n                \n                for j in range(order):\n                    eta = nodes[j]\n                    wj = weights[j]\n                    delta_y = 2.0 * a_val * eta\n                    \n                    r = np.sqrt(delta_x**2 + delta_y**2 + delta**2)\n\n                    if r == 0:\n                        continue\n\n                    weight_func = (2.0 * a_val - np.abs(delta_x)) * (2.0 * a_val - np.abs(delta_y))\n                    green_func = np.exp(1j * k * r) / (4.0 * np.pi * r)\n                    \n                    integrand_val = weight_func * green_func * jacobian\n                    z_integral += wi * wj * integrand_val\n                    \n        return z_integral\n\n    # ------------------ Numerical Experiments ------------------\n\n    # 1. Delta-scaling analysis\n    log_delta = np.log10(delta_vals)\n    errors_std_delta_sweep = []\n    errors_str_delta_sweep = []\n\n    for delta in delta_vals:\n        z_ref = compute_Z(a, delta, k_fixed_for_delta_sweep, N_ref, use_stretching=True)\n        z_std = compute_Z(a, delta, k_fixed_for_delta_sweep, N, use_stretching=False)\n        z_str = compute_Z(a, delta, k_fixed_for_delta_sweep, N, use_stretching=True)\n        \n        errors_std_delta_sweep.append(np.abs(z_std - z_ref))\n        errors_str_delta_sweep.append(np.abs(z_str - z_ref))\n\n    log_errors_std = np.log10(errors_std_delta_sweep)\n    log_errors_str = np.log10(errors_str_delta_sweep)\n    \n    s_std_delta = np.polyfit(log_delta, log_errors_std, 1)[0]\n    s_str_delta = np.polyfit(log_delta, log_errors_str, 1)[0]\n    \n    # 2. K-scaling analysis\n    log_k = np.log10(k_vals)\n    errors_str_k_sweep = []\n\n    for k in k_vals:\n        z_ref = compute_Z(a, delta_fixed_for_k_sweep, k, N_ref, use_stretching=True)\n        z_str = compute_Z(a, delta_fixed_for_k_sweep, k, N, use_stretching=True)\n        \n        errors_str_k_sweep.append(np.abs(z_str - z_ref))\n        \n    log_errors_str_k = np.log10(errors_str_k_sweep)\n    s_str_k = np.polyfit(log_k, log_errors_str_k, 1)[0]\n    \n    # 3. Improvement ratio R\n    # These are the errors at delta=1.25e-2 and k=10, which is the last point in the delta sweep\n    error_std_at_endpoint = errors_std_delta_sweep[-1]\n    error_str_at_endpoint = errors_str_delta_sweep[-1]\n    \n    R = error_std_at_endpoint / error_str_at_endpoint\n    \n    # ------------------ Final Output ------------------\n    # The output must be a single line with the specified format.\n    print(f\"[{s_std_delta},{s_str_delta},{s_str_k},{R}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3317563"}, {"introduction": "For large-scale simulations, assembling the full dense impedance matrix is computationally infeasible. The final frontier in practical impedance matrix evaluation is computational efficiency. This hands-on practice introduces the powerful concept of hierarchical matrices ($\\mathcal{H}$-matrices), which exploit the physical properties of far-field interactions to create a data-sparse approximation of the matrix. By building a simplified $\\mathcal{H}$-matrix structure and analyzing the numerical rank of admissible blocks, you will understand the principles behind fast solvers and quantify their dramatic impact on computational complexity.", "problem": "You are to derive and implement a program that constructs and analyzes a hierarchical matrix representation for the impedance matrix associated with a one-dimensional discretization of a thin straight conductor under time-harmonic excitation. The impedance matrix entries arise from the double-integral of the free-space scalar Green's function of the Helmholtz equation. Begin from fundamental electromagnetic laws and definitions, and express all mathematical quantities in LaTeX. Then, implement a hierarchical matrix that uses low-rank approximations for admissible far-field blocks. Finally, predict and measure numerical ranks for these blocks and estimate the impact on assembly time.\n\nStart from the macroscopic Maxwell's equations in the frequency domain for a source-free homogeneous medium with angular frequency $\\omega$, permittivity $\\epsilon$, and permeability $\\mu$. For time-harmonic fields with $e^{i \\omega t}$ convention, the electric field $\\mathbf{E}$ satisfies the vector Helmholtz equation. The scalar free-space Green's function $G(\\mathbf{r},\\mathbf{r}')$ of the Helmholtz equation solves\n$$\n\\left(\\nabla^2 + k^2\\right) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}'),\n$$\nwhere $k = \\omega \\sqrt{\\mu \\epsilon}$ is the wavenumber. In three dimensions,\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{e^{i k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\n\nConsider a thin straight conductor aligned with the $x$-axis, occupying the interval $[0,L]$ where $L$ is the total length. Discretize $[0,L]$ into $M$ uniform segments (panels) of length $h = L/M$, with indices $i = 0,1,\\dots,M-1$. Use piecewise-constant basis functions $\\phi_i(x)$ supported on the $i$-th panel:\n$$\n\\phi_i(x) = \\begin{cases}\n1  \\text{for } x \\in [i h, (i+1) h],\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nDefine the impedance matrix $Z \\in \\mathbb{C}^{M \\times M}$ with entries\n$$\nZ_{ij} = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{e^{i k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x,\n$$\nwhere the distance is approximated by $|x-x'|$ along the line. When $i=j$, the integrand has a weak singularity at $x=x'$, which must be handled numerically in a stable manner.\n\nPartition the index set $\\{0,1,\\dots,M-1\\}$ into contiguous clusters and build a block cluster tree. For any block defined by a pair of clusters $A$ and $B$ with index sets $I_A$ and $I_B$, define the cluster diameters\n$$\n\\operatorname{diam}(A) = \\max_{i \\in I_A} (i+1)h - \\min_{i \\in I_A} i h = |I_A| h,\n$$\nand similarly for $B$. Let the separation distance be the minimum gap between the support intervals of $A$ and $B$,\n$$\n\\operatorname{sep}(A,B) = \\max\\bigl(0, \\max(\\min_{j \\in I_B} j h - \\max_{i \\in I_A} (i+1) h,\\; \\min_{i \\in I_A} i h - \\max_{j \\in I_B} (j+1) h)\\bigr),\n$$\nwhich is zero if the intervals overlap or touch. Adopt the admissibility condition with parameter $\\eta > 0$:\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max\\left(\\operatorname{diam}(A), \\operatorname{diam}(B)\\right).\n$$\nFor admissible blocks, use a low-rank approximation by truncating the singular value decomposition (SVD) of the block submatrix to a rank that meets a prescribed relative error tolerance $\\varepsilon$ in Frobenius norm. For non-admissible blocks, use the full dense representation.\n\nFor blocks that are admissible, the Green's function kernel is smooth over $A \\times B$, allowing approximation by a separated low-rank expansion. Provide a theoretically motivated estimate of the rank $r_{\\mathrm{pred}}$ in terms of the wavenumber $k$, the cluster diameters, and the separation distance. Use a simple predictor of the form\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\nwhere $a = \\max\\bigl(\\operatorname{diam}(A),\\operatorname{diam}(B)\\bigr)$ is the characteristic size, $\\xi = \\operatorname{sep}(A,B)/a$ is the normalized separation, and $\\alpha$ and $\\beta$ are positive constants of order unity summarizing analytic approximation properties. Saturate $r_{\\mathrm{pred}}$ to be at least $1$ and at most $\\min(|I_A|,|I_B|)$, and for non-admissible blocks set $r_{\\mathrm{pred}} = \\min(|I_A|,|I_B|)$.\n\nNumerically, approximate the double-integral for $Z_{ij}$ with Gauss–Legendre quadrature using $Q$ nodes per panel along both integrals. Use quadrature nodes and weights on each panel to construct the block matrix entries. To handle the weak singularity when $i=j$, employ a regularization such as replacing $|x-x'|$ by $\\max(|x-x'|, \\delta)$ with a small $\\delta$ proportional to the mesh size $h$.\n\nDefine an assembly time proxy (operation count) for a block:\n- For a dense block of size $|I_A| \\times |I_B|$, using $Q$ quadrature points in each integral, set\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = |I_A| \\, |I_B| \\, Q^2.\n$$\n- For an admissible block represented with numerical rank $r_{\\mathrm{num}}$, approximate the hierarchical assembly cost by\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} \\, (|I_A| + |I_B|) \\, Q + r_{\\mathrm{num}}^2,\n$$\nand for non-admissible blocks use $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$.\n\nCompute the speedup proxy\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\nImplement a program that, for each test case described below, constructs the block submatrix for $(A,B)$, computes the truncated SVD to determine $r_{\\mathrm{num}}$ meeting tolerance $\\varepsilon$, evaluates the actual relative Frobenius error achieved by the truncation, computes $r_{\\mathrm{pred}}$, and computes $\\mathrm{ops}_{\\mathrm{dense}}$, $\\mathrm{ops}_{\\mathcal{H}}$, and $S$.\n\nAll distances must be expressed in meters, the wavenumber $k$ must be expressed in radians per meter, and all reported floating-point quantities must be in decimal form. Angles do not appear in this formulation. The final outputs are unitless except for the input parameters as specified.\n\nUse the following test suite to ensure coverage:\n- Use $L = 1\\,\\mathrm{m}$, $M = 64$, $Q = 8$, $\\eta = 1$, and regularization $\\delta = 10^{-6} h$ for all cases, where $h = L/M$.\n- Cluster indices are contiguous ranges $\\{s, s+1, \\dots, s+n-1\\}$ specified by a start index $s$ and size $n$.\n\nTest cases:\n1. Case $1$: $k = 20\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 0$, $n_A = 8$, cluster $B$: $s_B = 24$, $n_B = 8$.\n2. Case $2$: $k = 5\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-6}$, cluster $A$: $s_A = 0$, $n_A = 8$, cluster $B$: $s_B = 56$, $n_B = 8$.\n3. Case $3$: $k = 40\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 16$, $n_A = 8$, cluster $B$: $s_B = 24$, $n_B = 8$.\n4. Case $4$: $k = 20\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-5}$, cluster $A$: $s_A = 8$, $n_A = 8$, cluster $B$: $s_B = 8$, $n_B = 8$.\n5. Case $5$: $k = 80\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$, cluster $A$: $s_A = 0$, $n_A = 16$, cluster $B$: $s_B = 32$, $n_B = 16$.\n\nFor each test case, output a list containing\n$$\n\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr],\n$$\nwhere $E_{\\mathrm{rel}}$ is the achieved relative Frobenius error of the truncated SVD.\n\nYour program should produce a single line of output containing the results as a comma-separated list of these lists enclosed in square brackets with no spaces, for example, \n$$\n[\\,[1,2,0.001,64,32,2.0],[\\dots]\\,].\n$$", "solution": "The problem requires the derivation and implementation of a method to analyze the hierarchical matrix structure of an impedance matrix $Z$ arising from the discretization of an integral equation for a one-dimensional thin wire antenna. This analysis involves constructing specific blocks of the matrix, determining their admissibility for low-rank approximation, computing their numerical rank, and comparing it to a theoretical prediction. Finally, the computational savings from using a hierarchical representation are estimated.\n\n### Theoretical Formulation\n\nThe physical problem concerns time-harmonic electromagnetic scattering from a thin straight conductor. For a time-harmonic dependence $e^{i \\omega t}$, the electric field $\\mathbf{E}$ in a source-free, homogeneous medium characterized by permittivity $\\epsilon$ and permeability $\\mu$ satisfies the vector Helmholtz equation:\n$$\n\\nabla \\times \\nabla \\times \\mathbf{E} - k^2 \\mathbf{E} = \\mathbf{0},\n$$\nwhere $k = \\omega \\sqrt{\\mu \\epsilon}$ is the wavenumber. This can be solved using an integral equation formulation. The electric field is related to the scalar potential $\\Phi$ and vector potential $\\mathbf{A}$ as $\\mathbf{E} = -i\\omega\\mathbf{A} - \\nabla\\Phi$. Both potentials can be expressed as convolutions of the sources (currents $\\mathbf{J}$ and charges $\\rho$) with the free-space Green's function, $G(\\mathbf{r},\\mathbf{r}')$, which is the solution to:\n$$\n(\\nabla^2 + k^2) G(\\mathbf{r},\\mathbf{r}') = -\\delta(\\mathbf{r}-\\mathbf{r}').\n$$\nIn three dimensions, this Green's function is given by:\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{e^{i k \\|\\mathbf{r}-\\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}.\n$$\nThe problem considers a simplified one-dimensional conductor along the $x$-axis from $x=0$ to $x=L$. The distance between two points $\\mathbf{r}=(x,0,0)$ and $\\mathbf{r}'=(x',0,0)$ is approximated by $\\|\\mathbf{r}-\\mathbf{r}'\\| \\approx |x-x'|$. The problem uses the Method of Moments (MoM) to discretize the governing integral equation. The conductor is divided into $M$ segments of length $h = L/M$. The unknown current distribution is expanded in a basis of piecewise-constant functions $\\phi_i(x)$:\n$$\n\\phi_i(x) = \\begin{cases}\n1  \\text{for } x \\in [i h, (i+1) h] \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nApplying Galerkin's method, where the testing functions are the same as the basis functions, yields a dense linear system $Z I = V$, where $I$ is the vector of unknown current coefficients and $Z$ is the impedance matrix. The entry $Z_{ij}$ represents the mutual impedance between segment $i$ and segment $j$. It is calculated by a double integral over the supports of the respective basis functions:\n$$\nZ_{ij} = \\int_{\\mathbb{R}} \\int_{\\mathbb{R}} \\phi_i(x) G(x,x') \\phi_j(x') \\,\\mathrm{d}x' \\,\\mathrm{d}x = \\int_{i h}^{(i+1) h} \\int_{j h}^{(j+1) h} \\frac{e^{i k |x - x'|}}{4 \\pi |x - x'|} \\,\\mathrm{d}x' \\,\\mathrm{d}x.\n$$\n\n### Numerical Discretization and Singularity Treatment\n\nThe double integral for $Z_{ij}$ is evaluated numerically using Gauss-Legendre quadrature. For each panel, $Q$ quadrature nodes are used. Let $\\{\\xi_p, w_p\\}_{p=1}^Q$ be the standard Gauss-Legendre nodes and weights on the interval $[-1, 1]$. The integrals over panels $i$ and $j$ are transformed:\n- For $x \\in [ih, (i+1)h]$, we use the mapping $x(\\xi) = (i+0.5)h + \\xi \\frac{h}{2}$, so $\\mathrm{d}x = \\frac{h}{2} \\mathrm{d}\\xi$.\n- For $x' \\in [jh, (j+1)h]$, we use $x'(\\xi') = (j+0.5)h + \\xi' \\frac{h}{2}$, so $\\mathrm{d}x' = \\frac{h}{2} \\mathrm{d}\\xi'$.\n\nThe integral becomes:\n$$\nZ_{ij} \\approx \\frac{1}{4\\pi} \\left(\\frac{h}{2}\\right)^2 \\sum_{p=1}^Q \\sum_{q=1}^Q w_p w_q \\frac{e^{i k |x(\\xi_p) - x'(\\xi'_q)|}}{|x(\\xi_p) - x'(\\xi'_q)|}.\n$$\nWhen $i=j$, the kernel $1/|x-x'|$ has an integrable (weak) singularity at $x=x'$. Standard quadrature rules may fail or be inaccurate. The problem specifies a regularization technique: replacing the distance $|x-x'|$ with $\\max(|x-x'|, \\delta)$, where $\\delta$ is a small parameter. This removes the singularity, allowing for stable numerical integration.\n\n### Hierarchical Matrix Framework and Admissibility\n\nThe core of the hierarchical matrix method is to partition the dense matrix $Z$ into blocks and approximate certain blocks with a low-rank representation. A block submatrix $Z_{AB}$ is defined by two clusters of indices, $A$ and $B$, with index sets $I_A$ and $I_B$. The low-rank approximability of a block depends on the geometric separation of the corresponding clusters. This is formalized by the admissibility condition.\n\nFirst, we define geometric properties for the clusters:\n- **Cluster Diameter**: $\\operatorname{diam}(A) = (\\max_{i \\in I_A} (i+1) - \\min_{i \\in I_A} i)h = |I_A|h$ for a contiguous cluster of size $|I_A|$.\n- **Separation Distance**: $\\operatorname{sep}(A,B)$ is the minimum distance between the spatial domains corresponding to clusters $A$ and $B$. For contiguous clusters starting at $s_A$ and $s_B$ with sizes $n_A$ and $n_B$ respectively, the domains are $[s_A h, (s_A+n_A)h]$ and $[s_B h, (s_B+n_B)h]$. The separation is:\n$$\n\\operatorname{sep}(A,B) = h \\cdot \\max(0, s_B - (s_A+n_A), s_A - (s_B+n_B)).\n$$\n- **Admissibility Condition**: A block $(A,B)$ is deemed admissible (or \"far-field\") if its clusters are well-separated relative to their size. With a parameter $\\eta > 0$:\n$$\n\\operatorname{sep}(A,B) \\ge \\eta \\max(\\operatorname{diam}(A), \\operatorname{diam}(B)).\n$$\nIf this condition holds, the kernel function $G(x,x')$ is smooth for $x$ in cluster $A$'s domain and $x'$ in cluster $B$'s domain, which allows for an efficient low-rank approximation of the matrix block $Z_{AB}$.\n\n### Low-Rank Approximation and Rank Prediction\n\nFor an admissible block $Z_{AB}$ of size $n_A \\times n_B$, we can find a low-rank approximation. The Singular Value Decomposition (SVD), $Z_{AB} = U \\Sigma V^H$, provides the optimal rank-$r$ approximation by keeping the first $r$ singular values and vectors. The numerical rank, $r_{\\mathrm{num}}$, is the smallest rank $r$ that satisfies a given relative error tolerance $\\varepsilon$ in the Frobenius norm:\n$$\n\\frac{\\|Z_{AB} - Z_{AB}^{(r)}\\|_F}{\\|Z_{AB}\\|_F} = \\frac{\\sqrt{\\sum_{k=r+1}^{\\min(n_A,n_B)} \\sigma_k^2}}{\\sqrt{\\sum_{k=1}^{\\min(n_A,n_B)} \\sigma_k^2}} \\le \\varepsilon,\n$$\nwhere $Z_{AB}^{(r)}$ is the rank-$r$ truncated SVD approximation and $\\sigma_k$ are the singular values.\n\nThe problem provides a theoretical predictor for the rank:\n$$\nr_{\\mathrm{pred}} = \\left\\lceil \\alpha \\frac{k \\, a}{\\xi} + \\beta \\log \\frac{1}{\\varepsilon} \\right\\rceil,\n$$\nwhere $a = \\max(\\operatorname{diam}(A), \\operatorname{diam}(B))$ and $\\xi = \\operatorname{sep}(A,B)/a$. The constants $\\alpha$ and $\\beta$ are stated to be of order unity. Based on this, we choose $\\alpha=1$ and $\\beta=1$, a common simplification. The predicted rank is saturated to be at least $1$ and at most the dimension of the block, $\\min(n_A, n_B)$. For non-admissible blocks, the full rank is predicted: $r_{\\mathrm{pred}} = \\min(n_A, n_B)$.\n\n### Complexity and Speedup Estimation\n\nThe computational benefit of the hierarchical matrix approach is estimated by comparing operation counts.\n- **Dense Assembly**: Constructing a dense $n_A \\times n_B$ block with $Q$-point quadrature per dimension requires nested loops, leading to a computational cost proxy of:\n$$\n\\mathrm{ops}_{\\mathrm{dense}} = n_A \\cdot n_B \\cdot Q^2.\n$$\n- **Hierarchical Assembly**: For an admissible block, a low-rank representation is constructed. The cost is dominated by forming the low-rank factors and is given by the proxy:\n$$\n\\mathrm{ops}_{\\mathcal{H}} = r_{\\mathrm{num}} (n_A + n_B) Q + r_{\\mathrm{num}}^2.\n$$\nFor non-admissible blocks, no approximation is made, so $\\mathrm{ops}_{\\mathcal{H}} = \\mathrm{ops}_{\\mathrm{dense}}$.\n- **Speedup Proxy**: The estimated speedup is the ratio:\n$$\nS = \\frac{\\mathrm{ops}_{\\mathrm{dense}}}{\\mathrm{ops}_{\\mathcal{H}}}.\n$$\n\n### Algorithm Summary\nFor each test case, the following steps are executed:\n1.  Parse the case parameters: $k, \\varepsilon$, and cluster definitions ($s_A, n_A, s_B, n_B$).\n2.  Calculate derived geometric parameters: $\\operatorname{diam}(A)$, $\\operatorname{diam}(B)$, $\\operatorname{sep}(A,B)$, and $a$.\n3.  Determine if the block $(A,B)$ is admissible using the given condition with $\\eta=1$.\n4.  Calculate the predicted rank $r_{\\mathrm{pred}}$ using the specified formula, our choice of $\\alpha=1, \\beta=1$, and the appropriate rule for admissible/non-admissible blocks.\n5.  Assemble the dense block matrix $Z_{AB} \\in \\mathbb{C}^{n_A \\times n_B}$ using $Q$-point Gauss-Legendre quadrature, applying the singularity regularization for diagonal entries of the global matrix $Z$.\n6.  Compute the singular values of $Z_{AB}$.\n7.  Determine the numerical rank $r_{\\mathrm{num}}$ by finding the smallest rank satisfying the relative Frobenius error tolerance $\\varepsilon$.\n8.  Calculate the actual relative error $E_{\\mathrm{rel}}$ achieved with rank $r_{\\mathrm{num}}$.\n9.  Compute the operation count proxies $\\mathrm{ops}_{\\mathrm{dense}}$ and $\\mathrm{ops}_{\\mathcal{H}}$, and the speedup $S$.\n10. Format and collect the results $\\bigl[r_{\\mathrm{pred}},\\; r_{\\mathrm{num}},\\; E_{\\mathrm{rel}},\\; \\mathrm{ops}_{\\mathrm{dense}},\\; \\mathrm{ops}_{\\mathcal{H}},\\; S\\bigr]$.\n\nThis procedure is applied to all test cases to generate the final output.", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.linalg import svdvals\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to execute the analysis for all test cases.\n    \"\"\"\n    \n    # Global parameters\n    L = 1.0  # m\n    M = 64\n    Q = 8\n    eta = 1.0\n    h = L / M\n    delta_reg = 1e-6 * h\n\n    # Quadrature nodes and weights on [-1, 1]\n    quad_nodes, quad_weights = leggauss(Q)\n\n    # Test cases\n    test_cases = [\n        # k, eps, (s_A, n_A), (s_B, n_B)\n        (20.0, 1e-4, (0, 8), (24, 8)),\n        (5.0, 1e-6, (0, 8), (56, 8)),\n        (40.0, 1e-4, (16, 8), (24, 8)),\n        (20.0, 1e-5, (8, 8), (8, 8)),\n        (80.0, 1e-4, (0, 16), (32, 16)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        k, eps, cluster_A_def, cluster_B_def = case\n        s_A, n_A = cluster_A_def\n        s_B, n_B = cluster_B_def\n        \n        # 1. Calculate cluster properties\n        diam_A = n_A * h\n        diam_B = n_B * h\n        \n        # Separation distance\n        # Interval for A: [s_A*h, (s_A+n_A)*h]\n        # Interval for B: [s_B*h, (s_B+n_B)*h]\n        gap = max(0, s_B - (s_A + n_A), s_A - (s_B + n_B))\n        sep_AB = gap * h\n        \n        # Admissibility check\n        a = max(diam_A, diam_B)\n        is_admissible = sep_AB = eta * a\n        \n        # 2. Calculate predicted rank\n        if is_admissible:\n            if sep_AB  0:\n                xi = sep_AB / a\n                alpha = 1.0  # Assumed constant of order unity\n                beta = 1.0   # Assumed constant of order unity\n                r_pred_raw = alpha * (k * a / xi) + beta * math.log(1.0 / eps)\n                r_pred = math.ceil(r_pred_raw)\n                r_pred = max(1, min(r_pred, n_A, n_B))\n            else: # sep_AB is 0, so should not be admissible, but as a fallback\n                r_pred = min(n_A, n_B)\n        else:\n            r_pred = min(n_A, n_B)\n\n        # 3. Assemble the block matrix Z_AB\n        Z_AB = np.zeros((n_A, n_B), dtype=np.complex128)\n        \n        for i_idx in range(n_A):\n            for j_idx in range(n_B):\n                i_global = s_A + i_idx\n                j_global = s_B + j_idx\n                \n                # Map quadrature points to panels i_global and j_global\n                x_nodes = (i_global + 0.5) * h + quad_nodes * h / 2.0\n                xp_nodes = (j_global + 0.5) * h + quad_nodes * h / 2.0\n                \n                integral_val = 0.0j\n                for p in range(Q):\n                    for q in range(Q):\n                        x = x_nodes[p]\n                        xp = xp_nodes[q]\n                        dist = abs(x - xp)\n                        \n                        # Apply regularization for singular term\n                        if i_global == j_global:\n                            dist = max(dist, delta_reg)\n                        \n                        if dist  0:\n                            kernel_val = np.exp(1j * k * dist) / (4 * np.pi * dist)\n                            integral_val += quad_weights[p] * quad_weights[q] * kernel_val\n                \n                Z_AB[i_idx, j_idx] = integral_val * (h / 2.0)**2\n\n        # 4. Compute SVD and numerical rank\n        s = svdvals(Z_AB)\n        s_sq_sorted = s**2\n        total_norm_sq = np.sum(s_sq_sorted)\n\n        r_num = min(n_A, n_B)\n        if total_norm_sq  0:\n            trunc_err_sq = 0.0\n            found = False\n            for r in range(len(s) - 1, -1, -1):\n                trunc_err_sq += s_sq_sorted[r]\n                if np.sqrt(trunc_err_sq / total_norm_sq)  eps:\n                    r_num = r + 1\n                    found = True\n                    break\n            if not found: # All singular values can be truncated\n                r_num = 0\n\n        # 5. Calculate actual relative error for r_num\n        E_rel = 0.0\n        if total_norm_sq  0:\n            err_sq_for_r_num = np.sum(s_sq_sorted[r_num:])\n            E_rel = np.sqrt(err_sq_for_r_num / total_norm_sq)\n        \n        # 6. Compute operation counts and speedup\n        ops_dense = n_A * n_B * (Q**2)\n        \n        if is_admissible:\n            ops_H = r_num * (n_A + n_B) * Q + r_num**2\n        else:\n            ops_H = ops_dense\n\n        # Prevent division by zero if ops_H is 0 (e.g., zero matrix, r_num=0)\n        speedup = ops_dense / ops_H if ops_H > 0 else float('inf')\n\n        # Convert to int where appropriate\n        r_pred = int(r_pred)\n        ops_dense = int(ops_dense)\n        ops_H = int(ops_H)\n        \n        results.append(f\"[{r_pred},{r_num},{E_rel:.6f},{ops_dense},{ops_H},{speedup:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3317604"}]}