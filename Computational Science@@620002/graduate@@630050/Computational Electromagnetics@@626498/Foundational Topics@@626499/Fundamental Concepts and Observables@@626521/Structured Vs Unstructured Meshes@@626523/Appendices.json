{"hands_on_practices": [{"introduction": "The choice between a structured and an unstructured mesh has immediate and fundamental consequences for the size of the resulting computational problem. Before considering aspects like accuracy or geometric flexibility, a crucial first step is to understand how many unknowns a given mesh will generate. This exercise provides a concrete, quantitative analysis by guiding you through the process of counting the degrees of freedom (DoFs) for a standard edge-based finite element discretization on both mesh types, revealing how the problem size scales with mesh refinement [@problem_id:3351211].", "problem": "Consider the time-harmonic Maxwell curl-curl formulation in a cubic cavity domain $\\Omega = [0,L]^{3}$ with side length $L$. Suppose the electric field is discretized using first-order curl-conforming Nédélec edge elements (first kind), so that each unique mesh edge carries exactly one scalar degree of freedom. Ignore boundary condition constraints; that is, count every mesh edge as an independent unknown.\n\nTwo meshes of $\\Omega$ are considered, both parameterized by a positive integer $n$ via the relation $h = L/n$:\n\n- A structured hexahedral mesh: the cube is partitioned into $n$ uniform intervals per axis, yielding $n^{3}$ congruent hexahedral cells of side length $h$.\n\n- A tetrahedral mesh whose average edge length is $\\Theta(h)$, obtained by subdividing each hexahedral cell of the structured grid into $6$ tetrahedra using a consistent Freudenthal-type diagonalization: in each hexahedron, insert the long space diagonal and select one diagonal per quadrilateral face, with the diagonal choices consistent across neighboring cells so that shared faces have the same diagonal.\n\nUsing only the following foundational facts: (i) first-order Nédélec edge elements associate one degree of freedom per unique mesh edge, and (ii) the numbers of hexahedral grid nodes, edges, faces, and cells can be counted combinatorially as functions of $n$, do the following:\n\n- Derive the exact total number of edge unknowns $N_{\\mathrm{hex}}(n)$ on the structured hexahedral mesh in terms of $n$.\n\n- Derive the exact total number of edge unknowns $N_{\\mathrm{tet}}(n)$ on the tetrahedral mesh constructed as above, in terms of $n$.\n\n- From these expressions, determine the leading-order scaling with $h$ for each mesh and then compute the asymptotic ratio\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} \\, ,\n$$\nexpressed purely as a function of constants (i.e., independent of $h$ and $L$). Here $N_{\\mathrm{hex}}(h)$ and $N_{\\mathrm{tet}}(h)$ denote the counts expressed in terms of $h$ via $n=L/h$.\n\nReport the final asymptotic ratio as a single simplified rational number. No rounding is required. The answer is dimensionless; do not include units.", "solution": "The problem requires the derivation of the number of degrees of freedom (DoFs) for two different mesh discretizations of a cubic domain $\\Omega = [0,L]^3$. The DoFs correspond to the number of unique mesh edges, as first-order Nédélec elements are used. The analysis must be performed for a structured hexahedral mesh and a derived tetrahedral mesh. Finally, the asymptotic ratio of the number of edges for the two meshes must be computed as the mesh size $h$ approaches zero.\n\nFirst, we derive the exact number of edge unknowns $N_{\\mathrm{hex}}(n)$ for the structured hexahedral mesh. This mesh is formed by partitioning the cube into $n$ intervals along each of the three axes. This creates a grid of $(n+1) \\times (n+1) \\times (n+1)$ vertices, which can be indexed by $(i,j,k)$ where $i, j, k \\in \\{0, 1, \\dots, n\\}$. The edges of this grid are the lines connecting adjacent vertices. We can count the edges by classifying them according to their orientation.\n\n1.  Edges parallel to the $x$-axis: These edges connect vertices of the form $(i, j, k)$ and $(i+1, j, k)$. The index $i$ can range from $0$ to $n-1$ (a total of $n$ choices), while indices $j$ and $k$ can each range from $0$ to $n$ (a total of $n+1$ choices each). Thus, the number of edges parallel to the $x$-axis is $n \\times (n+1) \\times (n+1)$.\n\n2.  Edges parallel to the $y$-axis: Similarly, these edges connect vertices $(i, j, k)$ and $(i, j+1, k)$. The index $j$ runs from $0$ to $n-1$, while $i$ and $k$ run from $0$ to $n$. The number of such edges is $(n+1) \\times n \\times (n+1)$.\n\n3.  Edges parallel to the $z$-axis: These connect vertices $(i, j, k)$ and $(i, j, k+1)$. The index $k$ runs from $0$ to $n-1$, while $i$ and $j$ run from $0$ to $n$. The number is $(n+1) \\times (n+1) \\times n$.\n\nThe total number of edges, $N_{\\mathrm{hex}}(n)$, is the sum of these three counts. By symmetry, the counts are identical.\n$$\nN_{\\mathrm{hex}}(n) = 3 \\times n \\times (n+1)^2\n$$\nExpanding this expression gives the polynomial form:\n$$\nN_{\\mathrm{hex}}(n) = 3n(n^2 + 2n + 1) = 3n^3 + 6n^2 + 3n\n$$\nNext, we derive the exact number of edge unknowns $N_{\\mathrm{tet}}(n)$ for the tetrahedral mesh. This mesh is constructed by subdividing each of the $n^3$ hexahedral cells of the original grid. The problem specifies that the subdivision adds new edges to the mesh: one long space diagonal is inserted within each hexahedron, and one diagonal is selected for each quadrilateral face. The choices of face diagonals are consistent across shared faces.\n\nThe total set of edges in the tetrahedral mesh is therefore the union of three disjoint sets of edges:\n1.  The original edges of the hexahedral grid. The number of these edges is $N_{\\mathrm{hex}}(n) = 3n(n+1)^2$.\n2.  Newly created space diagonals. Each of the $n^3$ hexahedral cells has one space diagonal added to its interior. Since these diagonals are internal to the cells, they are not shared. Thus, this adds exactly $n^3$ new edges.\n3.  Newly created face diagonals. The problem states that a single diagonal is introduced for each face of the hexahedral grid. This means the number of new face diagonals is equal to the total number of faces in the hexahedral grid. We can count these faces by orientation:\n    -   Faces parallel to the $xy$-plane: There are $n \\times n$ such faces in each of the $n+1$ horizontal layers of vertices. Total: $n^2(n+1)$.\n    -   Faces parallel to the $yz$-plane: There are $n \\times n$ such faces in each of the $n+1$ sagittal planes. Total: $n^2(n+1)$.\n    -   Faces parallel to the $xz$-plane: There are $n \\times n$ such faces in each of the $n+1$ coronal planes. Total: $n^2(n+1)$.\n    The total number of faces is the sum, which is $3n^2(n+1)$. Therefore, $3n^2(n+1)$ new edges are created from face diagonals.\n\nThe total number of edges in the tetrahedral mesh, $N_{\\mathrm{tet}}(n)$, is the sum of the counts from these three sources:\n$$\nN_{\\mathrm{tet}}(n) = N_{\\mathrm{hex}}(n) + (\\text{number of new space diagonals}) + (\\text{number of new face diagonals})\n$$\n$$\nN_{\\mathrm{tet}}(n) = [3n(n+1)^2] + [n^3] + [3n^2(n+1)]\n$$\nWe expand each term and sum them:\n$$\nN_{\\mathrm{tet}}(n) = (3n^3 + 6n^2 + 3n) + n^3 + (3n^3 + 3n^2)\n$$\n$$\nN_{\\mathrm{tet}}(n) = (3+1+3)n^3 + (6+3)n^2 + 3n\n$$\n$$\nN_{\\mathrm{tet}}(n) = 7n^3 + 9n^2 + 3n\n$$\nFinally, we compute the asymptotic ratio $\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)}$. The relationship between the mesh parameter $n$ and the mesh size $h$ is given by $h = L/n$. As $h \\to 0^+$, for a fixed domain size $L$, the integer $n$ must approach infinity ($n \\to \\infty$). Therefore, the limit can be computed with respect to $n$:\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} = \\lim_{n \\to \\infty} \\frac{N_{\\mathrm{tet}}(n)}{N_{\\mathrm{hex}}(n)}\n$$\nWe substitute the derived polynomial expressions for $N_{\\mathrm{tet}}(n)$ and $N_{\\mathrm{hex}}(n)$:\n$$\n\\lim_{n \\to \\infty} \\frac{7n^3 + 9n^2 + 3n}{3n^3 + 6n^2 + 3n}\n$$\nFor a limit of a rational function of polynomials as the variable approaches infinity, the limit is the ratio of the coefficients of the highest power term in the numerator and the denominator. The highest power is $n^3$.\n$$\n\\lim_{n \\to \\infty} \\frac{n^3(7 + \\frac{9}{n} + \\frac{3}{n^2})}{n^3(3 + \\frac{6}{n} + \\frac{3}{n^2})} = \\lim_{n \\to \\infty} \\frac{7 + \\frac{9}{n} + \\frac{3}{n^2}}{3 + \\frac{6}{n} + \\frac{3}{n^2}}\n$$\nAs $n \\to \\infty$, terms such as $\\frac{9}{n}$, $\\frac{3}{n^2}$, and $\\frac{6}{n}$ approach $0$.\n$$\n\\frac{7 + 0 + 0}{3 + 0 + 0} = \\frac{7}{3}\n$$\nThe leading-order scaling for both $N_{\\mathrm{hex}}$ and $N_{\\mathrm{tet}}$ is $O(n^3)$, which corresponds to $O(h^{-3})$. The asymptotic ratio is the ratio of the leading-order coefficients, $7/3$.", "answer": "$$\n\\boxed{\\frac{7}{3}}\n$$", "id": "3351211"}, {"introduction": "While the number of degrees of freedom determines the size of the linear system, its numerical properties dictate how easily it can be solved. A key advantage of structured meshes is their inherent high element quality, which leads to well-conditioned matrices. This practice explores the consequences of poor element quality, a common risk in unstructured meshing, by connecting the geometric shape of \"sliver\" tetrahedra to the condition number of the system matrix and demonstrating how targeted mesh refinement can mitigate these numerical issues [@problem_id:3351151].", "problem": "Consider the time-harmonic Maxwell equations in a simply connected, bounded three-dimensional domain with perfectly conducting boundary. In the absence of sources, the electric field satisfies the weak form that involves the curl-curl operator. Let the discrete approximation use first-order edge elements of Jean-Claude Nédélec on a tetrahedral mesh. The discrete stiffness matrix is assembled from element contributions defined by the bilinear form of the curl-curl operator. Two meshes of the same domain are provided: a baseline mesh and a perturbed mesh that contains a set of sliver tetrahedra. You are asked to estimate the expected increase in the condition number of the global curl-curl stiffness matrix due to the presence of sliver elements, using a shape-quality-based spectral equivalence argument derived from the element mapping, and then propose and model the effect of a remedial refinement strategy that targets the sliver elements.\n\nFundamental base and definitions to be used in the derivation and computation:\n- The time-harmonic Maxwell equations in a source-free medium with constant material properties reduce to the eigenproblem of the curl-curl operator. The weak form on a domain $\\Omega$ for the electric field $\\mathbf{E}$ and test functions $\\mathbf{v}$ in the $\\mathbf{H}(\\mathrm{curl},\\Omega)$ space is given by\n$$\na(\\mathbf{E},\\mathbf{v}) = \\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}x,\n$$\nwhere $\\mu$ is the magnetic permeability, and the stiffness matrix entries are $A_{ij} = a(\\mathbf{N}_i,\\mathbf{N}_j)$ with $\\mathbf{N}_i$ being the Nédélec basis functions.\n- Each physical tetrahedral element $K$ is obtained from an affine mapping of a reference tetrahedron via $F_K(\\boldsymbol{\\xi}) = \\mathbf{x}_0 + \\mathbf{J}_K \\boldsymbol{\\xi}$, where $\\mathbf{J}_K$ is the Jacobian matrix on $K$. The curl transformation under the mapping yields a metric tensor $\\mathbf{G}_K = \\mathbf{J}_K^{-T} \\mathbf{J}_K^{-1}$ entering the element bilinear form after pullback. The element-wise contribution to the stiffness is spectrally equivalent to the reference element contribution scaled by the eigenvalues of $\\mathbf{G}_K$.\n- Let the singular values of $\\mathbf{J}_K$ be $\\sigma_1(K) \\ge \\sigma_2(K) \\ge \\sigma_3(K) > 0$. Define the element shape regularity factor $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$. Sliver tetrahedra have large $\\kappa(K)$ due to a very small $\\sigma_3(K)$ compared to $\\sigma_1(K)$.\n- For a mesh $\\mathcal{T}$, define $h_{\\min}(\\mathcal{T})$ as the minimum characteristic size among elements and $\\kappa_{\\max}(\\mathcal{T}) = \\max_{K\\in \\mathcal{T}} \\kappa(K)$. Denote the domain diameter by $H$. In the absence of material contrast and for quasi-uniform meshes, a widely used estimate for the discrete condition number of the global stiffness matrix for the curl-curl operator is\n$$\n\\operatorname{cond}(A(\\mathcal{T})) \\lesssim C \\, \\left(\\frac{H}{h_{\\min}(\\mathcal{T})}\\right)^2 \\, \\kappa_{\\max}(\\mathcal{T})^2,\n$$\nwith a mesh-independent constant $C$, reflecting that poor element shapes and large size ratios degrade conditioning. When comparing two meshes of the same domain, the ratio of their condition numbers satisfies\n$$\nR(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\nso the constant and $H$ cancel in the ratio. This ratio is dimensionless, and all answers must therefore be dimensionless real numbers.\n\nRemedial refinement model:\n- Identify sliver elements by a threshold $\\tau$: an element $K$ is classified as a sliver if $\\kappa(K) \\ge \\tau$.\n- Apply a local refinement and smoothing strategy conceptually similar to longest-edge bisection followed by vertex smoothing in the sliver region. In the spectral model, this increases the smallest singular value of the Jacobian by a factor $\\eta > 1$ while leaving the largest singular value unchanged, i.e., $\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}$ for sliver elements and $\\sigma_3'(K) = \\sigma_3(K)$ otherwise. Assume $h_{\\min}$ does not deteriorate under this remediation in these test cases, since the strategy targets shape without reducing sizes.\n- The refined mesh condition number ratio is then\n$$\nR'(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\nwhere $\\kappa_{\\max}'(\\mathcal{T}_B)$ is computed from $\\sigma_1(K)$ and $\\sigma_3'(K)$.\n\nYour task:\n- For each test case, compute the estimated condition number increase $R(\\mathcal{T}_B \\Vert \\mathcal{T}_A)$ using the formula above, and the refined ratio $R'(\\mathcal{T}_B \\Vert \\mathcal{T}_A)$ after applying the remedial refinement model.\n- Report the results as floats.\n\nTest suite and data:\n- Each mesh is specified by a list of tetrahedral elements, each element by a tuple of its Jacobian singular values $(\\sigma_1,\\sigma_2,\\sigma_3)$ and a characteristic size $h_K$. For each mesh, use $h_{\\min}$ equal to the minimum over its $h_K$ values. For each test case, also specify the sliver threshold $\\tau$ and the improvement factor $\\eta$ for the remedial refinement. All numbers are given below.\n\n- Test case $1$ (happy path, structured baseline versus unstructured with slivers):\n  Baseline mesh $\\mathcal{T}_A$ elements:\n  $[(1.00,0.95,0.90,0.25),(1.00,0.96,0.88,0.25),(1.00,0.94,0.89,0.25),(1.00,0.97,0.91,0.25),(1.00,0.95,0.92,0.25),(1.00,0.96,0.93,0.25),(1.00,0.94,0.92,0.25),(1.00,0.97,0.93,0.25)]$.\n  Perturbed mesh $\\mathcal{T}_B$ elements:\n  $[(1.00,0.99,0.02,0.25),(1.00,0.98,0.03,0.25),(1.00,0.97,0.04,0.25),(1.00,0.95,0.92,0.25),(1.00,0.96,0.93,0.25),(1.00,0.94,0.90,0.25),(1.00,0.95,0.91,0.25),(1.00,0.96,0.92,0.25)]$.\n  Parameters: $\\tau = 10$, $\\eta = 5$.\n\n- Test case $2$ (boundary case, both meshes near-structured, minimal sliver presence):\n  Baseline mesh $\\mathcal{T}_A$ elements:\n  $[(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10),(0.50,0.50,0.50,0.10)]$.\n  Perturbed mesh $\\mathcal{T}_B$ elements:\n  $[(0.55,0.50,0.45,0.10),(0.60,0.50,0.40,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10),(0.52,0.50,0.48,0.10)]$.\n  Parameters: $\\tau = 10$, $\\eta = 5$.\n\n- Test case $3$ (edge case, extreme slivers in unstructured mesh):\n  Baseline mesh $\\mathcal{T}_A$ elements:\n  $[(1.00,0.80,0.40,0.30),(1.00,0.85,0.45,0.30),(1.00,0.82,0.42,0.30),(1.00,0.83,0.43,0.30),(1.00,0.84,0.44,0.30)]$.\n  Perturbed mesh $\\mathcal{T}_B$ elements:\n  $[(1.00,0.999,0.001,0.30),(1.00,0.995,0.002,0.30),(1.00,0.90,0.60,0.30),(1.00,0.85,0.50,0.30),(1.00,0.88,0.55,0.30)]$.\n  Parameters: $\\tau = 10$, $\\eta = 20$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the two-element list $[R,R']$ where $R$ is the estimated condition number ratio and $R'$ is the refined ratio. Aggregate the three test cases into one list, for example, $[[R_1,R_1'],[R_2,R_2'],[R_3,R_3']]$. No physical units are required because the ratios are dimensionless.", "solution": "The starting point is the time-harmonic Maxwell equations in a source-free, homogeneous medium on a domain with perfectly conducting boundary. The weak form employs the curl-curl operator and, when discretized by first-order Nédélec edge elements, yields a global stiffness matrix that assembles element-wise contributions of the bilinear form \n$$\na(\\mathbf{E},\\mathbf{v}) = \\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}x.\n$$\nThe assembly process maps each physical tetrahedron $K$ from the reference element via an affine mapping $F_K(\\boldsymbol{\\xi}) = \\mathbf{x}_0 + \\mathbf{J}_K \\boldsymbol{\\xi}$ with Jacobian $\\mathbf{J}_K$. The curl transforms as $\\nabla_{\\mathbf{x}} \\times \\mathbf{E}(\\mathbf{x}) = (\\det \\mathbf{J}_K)^{-1} \\mathbf{J}_K \\, (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{E}}(\\boldsymbol{\\xi}))$, where hats denote quantities on the reference element. Consequently, the element bilinear form after pullback acquires the metric tensor \n$$\n\\mathbf{G}_K = \\mathbf{J}_K^{-T} \\mathbf{J}_K^{-1},\n$$ \nin the sense that the reference-element contribution is scaled by $\\mathbf{G}_K$ through the factor $\\int_{\\hat{K}} (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{N}}_i) \\cdot \\mathbf{G}_K \\, (\\nabla_{\\boldsymbol{\\xi}} \\times \\hat{\\mathbf{N}}_j) \\, \\mathrm{d}\\boldsymbol{\\xi}$. The eigenvalues of $\\mathbf{G}_K$ are $\\lambda_i(\\mathbf{G}_K) = \\sigma_i(\\mathbf{J}_K)^{-2}$, where $\\sigma_i(\\mathbf{J}_K)$ are the singular values of $\\mathbf{J}_K$. The spectral conditioning of $\\mathbf{G}_K$ is thus governed by the ratio \n$$\n\\frac{\\lambda_{\\max}(\\mathbf{G}_K)}{\\lambda_{\\min}(\\mathbf{G}_K)} = \\left(\\frac{\\sigma_1(K)}{\\sigma_3(K)}\\right)^2 = \\kappa(K)^2,\n$$\nwith $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$ serving as a shape regularity factor. Sliver tetrahedra have $\\sigma_3(K)$ much smaller than $\\sigma_1(K)$, yielding large $\\kappa(K)$ and consequently large local stiffness contributions that vary widely, which causes poor global conditioning when assembled.\n\nFor a mesh $\\mathcal{T}$, the global stiffness matrix condition number scales with both the mesh size ratio and element shape quality. A standard estimate for conforming finite elements under reasonable quasi-uniformity assumptions is \n$$\n\\operatorname{cond}(A(\\mathcal{T})) \\lesssim C \\, \\left(\\frac{H}{h_{\\min}(\\mathcal{T})}\\right)^2 \\, \\kappa_{\\max}(\\mathcal{T})^2,\n$$\nwhere $H$ is the domain diameter, $h_{\\min}(\\mathcal{T})$ is the minimum element size, $\\kappa_{\\max}(\\mathcal{T}) = \\max_{K\\in \\mathcal{T}} \\kappa(K)$ is the worst shape factor, and $C$ is a mesh-independent constant that depends on polynomial order but cancels in ratios. For two meshes $\\mathcal{T}_A$ and $\\mathcal{T}_B$ of the same domain, the ratio of their condition numbers satisfies \n$$\nR(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2,\n$$\nbecause $H$ is identical and $C$ cancels out. This provides a physics- and geometry-based estimate grounded in the mapping and the $\\mathbf{H}(\\mathrm{curl})$ element theory.\n\nTo model a remedial refinement strategy focusing on slivers, consider a threshold $\\tau$ and an improvement factor $\\eta$. Identify slivers by $\\kappa(K) \\ge \\tau$. A local refinement such as longest-edge bisection combined with vertex smoothing increases the smallest singular value while largely preserving the largest singular value for slivers, thereby improving shape quality. In spectral terms,\n$$\n\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}, \\quad \\sigma_1'(K) = \\sigma_1(K),\n$$\nand for non-sliver elements, $\\sigma_3'(K)=\\sigma_3(K)$. The refined shape factor becomes \n$$\n\\kappa'(K) = \\frac{\\sigma_1'(K)}{\\sigma_3'(K)} = \\frac{\\sigma_1(K)}{\\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}},\n$$\nwhich is approximately $\\kappa(K)/\\eta$ for $\\eta \\, \\sigma_3(K) \\le \\sigma_1(K)$. The refined worst-case factor is $\\kappa_{\\max}'(\\mathcal{T}_B) = \\max_{K\\in \\mathcal{T}_B} \\kappa'(K)$. Assuming the refinement targets shape quality without reducing the smallest element size in the test scenarios, $h_{\\min}(\\mathcal{T}_B)$ is unchanged, and the refined ratio is \n$$\nR'(\\mathcal{T}_B \\Vert \\mathcal{T}_A) \\approx \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n\nAlgorithmic steps implemented by the program for each test case:\n- Compute $\\kappa(K) = \\sigma_1(K)/\\sigma_3(K)$ for every element in $\\mathcal{T}_A$ and $\\mathcal{T}_B$.\n- Determine $\\kappa_{\\max}(\\mathcal{T}_A)$ and $\\kappa_{\\max}(\\mathcal{T}_B)$.\n- Compute $h_{\\min}(\\mathcal{T}_A)$ and $h_{\\min}(\\mathcal{T}_B)$ from the element sizes.\n- Evaluate \n$$\nR = \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n- Apply the remedial refinement model to all sliver elements in $\\mathcal{T}_B$: for each $K$ with $\\kappa(K) \\ge \\tau$, set $\\sigma_3'(K) = \\min\\{\\eta \\, \\sigma_3(K), \\sigma_1(K)\\}$ and recompute $\\kappa'(K)$; otherwise, keep $\\sigma_3'(K)=\\sigma_3(K)$. Then find $\\kappa_{\\max}'(\\mathcal{T}_B)$ and compute \n$$\nR' = \\left(\\frac{h_{\\min}(\\mathcal{T}_A)}{h_{\\min}(\\mathcal{T}_B)}\\right)^2 \\left(\\frac{\\kappa_{\\max}'(\\mathcal{T}_B)}{\\kappa_{\\max}(\\mathcal{T}_A)}\\right)^2.\n$$\n\nInterpretation relative to structured versus unstructured meshes in computational electromagnetics: Structured meshes typically maintain bounded $\\kappa(K)$ and uniform $h_K$, resulting in smaller condition numbers. Unstructured meshes may contain slivers with large $\\kappa(K)$, severely degrading conditioning. The proposed targeted refinement reduces $\\kappa_{\\max}$ by improving sliver shape while not unduly changing $h_{\\min}$, thereby restoring conditioning closer to the baseline structured mesh.\n\nThe program implements these computations precisely for the provided test suite and outputs a single line containing $[[R_1,R_1'],[R_2,R_2'],[R_3,R_3']]$, with each $R_i$ and $R_i'$ represented as floating-point numbers. The ratios are dimensionless, so no physical units are required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kappa_max(elements):\n    # elements: list of tuples (s1, s2, s3, h)\n    kappas = []\n    for (s1, s2, s3, h) in elements:\n        # Avoid division by zero; s3 > 0 by construction in test suite\n        kappas.append(s1 / s3)\n    return max(kappas)\n\ndef h_min(elements):\n    return min(h for (_, _, _, h) in elements)\n\ndef refine_elements(elements, tau, eta):\n    # Return new list of elements with refined s3 for slivers\n    refined = []\n    for (s1, s2, s3, h) in elements:\n        kappa = s1 / s3\n        if kappa >= tau:\n            s3_new = min(eta * s3, s1)  # increase smallest singular value, cap at s1\n            refined.append((s1, s2, s3_new, h))\n        else:\n            refined.append((s1, s2, s3, h))\n    return refined\n\ndef cond_ratio(meshA, meshB):\n    kA = kappa_max(meshA)\n    kB = kappa_max(meshB)\n    hA = h_min(meshA)\n    hB = h_min(meshB)\n    return (hA / hB) ** 2 * (kB / kA) ** 2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"meshA\": [\n                (1.00, 0.95, 0.90, 0.25),\n                (1.00, 0.96, 0.88, 0.25),\n                (1.00, 0.94, 0.89, 0.25),\n                (1.00, 0.97, 0.91, 0.25),\n                (1.00, 0.95, 0.92, 0.25),\n                (1.00, 0.96, 0.93, 0.25),\n                (1.00, 0.94, 0.92, 0.25),\n                (1.00, 0.97, 0.93, 0.25),\n            ],\n            \"meshB\": [\n                (1.00, 0.99, 0.02, 0.25),\n                (1.00, 0.98, 0.03, 0.25),\n                (1.00, 0.97, 0.04, 0.25),\n                (1.00, 0.95, 0.92, 0.25),\n                (1.00, 0.96, 0.93, 0.25),\n                (1.00, 0.94, 0.90, 0.25),\n                (1.00, 0.95, 0.91, 0.25),\n                (1.00, 0.96, 0.92, 0.25),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 5.0,\n        },\n        # Test case 2\n        {\n            \"meshA\": [\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n                (0.50, 0.50, 0.50, 0.10),\n            ],\n            \"meshB\": [\n                (0.55, 0.50, 0.45, 0.10),\n                (0.60, 0.50, 0.40, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n                (0.52, 0.50, 0.48, 0.10),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 5.0,\n        },\n        # Test case 3\n        {\n            \"meshA\": [\n                (1.00, 0.80, 0.40, 0.30),\n                (1.00, 0.85, 0.45, 0.30),\n                (1.00, 0.82, 0.42, 0.30),\n                (1.00, 0.83, 0.43, 0.30),\n                (1.00, 0.84, 0.44, 0.30),\n            ],\n            \"meshB\": [\n                (1.00, 0.999, 0.001, 0.30),\n                (1.00, 0.995, 0.002, 0.30),\n                (1.00, 0.90, 0.60, 0.30),\n                (1.00, 0.85, 0.50, 0.30),\n                (1.00, 0.88, 0.55, 0.30),\n            ],\n            \"tau\": 10.0,\n            \"eta\": 20.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        meshA = case[\"meshA\"]\n        meshB = case[\"meshB\"]\n        tau = case[\"tau\"]\n        eta = case[\"eta\"]\n\n        R = cond_ratio(meshA, meshB)\n        meshB_refined = refine_elements(meshB, tau, eta)\n        R_refined = cond_ratio(meshA, meshB_refined)\n\n        # Round moderately for cleaner output\n        results.append([float(f\"{R:.6f}\"), float(f\"{R_refined:.6f}\")])\n\n    # Final print statement in the exact required format.\n    # Single line, comma-separated list enclosed in square brackets.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3351151"}, {"introduction": "Ultimately, the value of a mesh is judged by the accuracy of the solution it produces. For wave propagation problems, a primary source of error is numerical dispersion, which is heavily influenced by how well the mesh conforms to the physical geometry. This final practice directly compares the impact of different geometry-fitting strategies—a body-fitted structured mesh versus linear and quadratic unstructured elements—on the phase accuracy of a simulated wave, providing a clear illustration of the trade-off between geometric fidelity and solution quality [@problem_id:3351225].", "problem": "Consider electromagnetic wave propagation in free space, governed by Maxwell’s equations, discretized using a staggered finite-difference time-domain scheme that places electric and magnetic field components on interleaved spatial locations and advances them in time with explicit updates. The goal is to investigate the impact of geometry-fitting strategies on numerical dispersion and phase accuracy when representing a smoothly curved path. You will compare two geometry-fitting strategies: a curvilinear mapping on a logically structured mesh and curving unstructured elements, and you will explicitly quantify how approximations of the Jacobian determinant and metric scale factors influence the discrete dispersion relation.\n\nStart from the fundamental base: Maxwell’s equations in free space,\n$$\n\\nabla \\times \\mathbf{E} = -\\mu_0 \\frac{\\partial \\mathbf{H}}{\\partial t}, \\quad \\nabla \\times \\mathbf{H} = \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t},\n$$\nwith wave speed $c = \\frac{1}{\\sqrt{\\mu_0 \\varepsilon_0}}$. Consider a two-dimensional transverse-electric configuration with out-of-plane electric field and in-plane magnetic field where the propagation is tangential to a circular arc of radius $R$ (centerline), parameterized by an angle coordinate. In the structured case, adopt an orthogonal curvilinear mapping aligned to the circle such that the tangential coordinate has metric scale factor $h_\\xi$ and the normal coordinate has $h_\\eta$, and the Jacobian determinant of the mapping satisfies $J = h_\\xi h_\\eta$. In the unstructured case, consider isoparametric edges on curved elements: a linear edge between endpoints (a straight chord) and a quadratic edge defined by quadratic Lagrange shape functions interpolating three nodal points placed on the circular boundary; the induced Jacobian and metric terms are approximated by the element mapping. You are to analyze numerical dispersion by deriving the discrete dispersion relation for propagation along the tangential direction, taking into account the metric scaling of spatial steps and the explicit time step, and to compute the resulting phase velocity error.\n\nYour program must implement the following steps:\n\n1. Model the geometry of a circular arc with centerline radius $R$ and angular extent per cell $\\Delta \\theta$ (in radians). Define three effective spatial steps along the tangential direction:\n   - Structured curvilinear mapping: use the exact arc length $s_{\\text{arc}} = R \\Delta \\theta$ aligned to the mapping with exact metric scale factor $h_\\xi$ on the centerline.\n   - Unstructured, linear edge: use the chord length $s_{\\text{chord}} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)$ as the effective cell size along the tangential direction, reflecting Jacobian and metric approximation by straight edges.\n   - Unstructured, quadratic curved edge: construct a quadratic isoparametric edge by quadratic Lagrange interpolation of the endpoints at angles $0$ and $\\Delta \\theta$ and a mid-side node at angle $\\frac{\\Delta \\theta}{2}$; compute the effective edge length\n     $$\n     s_{\\text{quad}} = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2}\\, dt,\n     $$\n     where $(x(t),y(t))$ are obtained by quadratic interpolation of the nodal coordinates in parameter $t \\in [-1,1]$ using the standard quadratic Lagrange shape functions. This integral represents the metric-induced length when the Jacobian is approximated by the quadratic isoparametric mapping.\n\n2. From the free-space plane-wave relation $k = \\frac{2\\pi}{\\lambda}$ with wavelength $\\lambda$ (in meters) and angular frequency $\\omega = c k$, obtain the discrete numerical angular frequency $\\omega_{\\text{num}}$ for each effective step using the one-dimensional staggered finite-difference time-domain dispersion relation along the tangential direction with spatial step $\\Delta s$ and time step $\\Delta t$. The relation must be derived from Maxwell’s equations in orthogonal curvilinear coordinates; it should account for the metric scale factor implicitly through the effective step size and produce $\\omega_{\\text{num}}$ as a function of $k$, $\\Delta s$, and $\\Delta t$, without invoking shortcut formulas.\n\n3. For each case, compute the numerical phase velocity $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$ and the relative phase velocity error\n   $$\n   e = \\frac{v_{\\text{num}} - c}{c},\n   $$\n   which is dimensionless and must be reported as a decimal number (no percentage sign).\n\n4. Use the explicit time step determined by a Courant factor $\\sigma \\in (0,1)$ defined by\n   $$\n   \\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c},\n   $$\n   which ensures stability across the three strategies for a given case.\n\nAngle units must be radians. All lengths must be in meters. The speed of light must be $c = 299792458\\,\\mathrm{m/s}$. The final outputs must be dimensionless decimal numbers representing relative phase velocity errors.\n\nTest Suite:\nImplement your program to evaluate the following four test cases, each providing $(R, \\Delta \\theta, \\lambda, \\sigma)$:\n\n- Case 1 (happy path): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.2$ (radians), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$.\n- Case 2 (fine angular resolution): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.01$ (radians), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$.\n- Case 3 (strong curvature): $R = 0.3\\,\\mathrm{m}$, $\\Delta \\theta = 0.5$ (radians), $\\lambda = 0.25\\,\\mathrm{m}$, $\\sigma = 0.90$.\n- Case 4 (near stability limit): $R = 0.2\\,\\mathrm{m}$, $\\Delta \\theta = 0.3$ (radians), $\\lambda = 0.10\\,\\mathrm{m}$, $\\sigma = 0.99$.\n\nFor each test case, your program must compute and return three numbers in the order corresponding to the structured curvilinear arc, the unstructured linear chord, and the unstructured quadratic curved edge. Thus, across four cases, your program must produce a single line of output containing twelve comma-separated decimal numbers enclosed in square brackets, in the order:\n$$\n[e_{1,\\text{arc}}, e_{1,\\text{chord}}, e_{1,\\text{quad}}, e_{2,\\text{arc}}, e_{2,\\text{chord}}, e_{2,\\text{quad}}, e_{3,\\text{arc}}, e_{3,\\text{chord}}, e_{3,\\text{quad}}, e_{4,\\text{arc}}, e_{4,\\text{chord}}, e_{4,\\text{quad}}].\n$$\nNo additional text may be printed.", "solution": "The problem is deemed valid as it is scientifically grounded in Maxwell's theory and computational electromagnetics, is well-posed with a clear objective and sufficient data, and is free of contradictions or ambiguities.\n\nThe solution proceeds by first determining the effective tangential spatial step sizes for three different geometric modeling strategies. Second, the one-dimensional finite-difference time-domain (FDTD) numerical dispersion relation is derived from Maxwell's equations. Third, this relation is used to compute the numerical phase velocity and its relative error for each strategy. Finally, the time step is determined based on a Courant condition that ensures stability across all three cases.\n\n### Step 1: Geometric Approximation and Effective Step Sizes\n\nWe consider a circular arc of radius $R$ and compute the length of a single discrete segment corresponding to an angular span of $\\Delta \\theta$.\n\n1.  **Structured Curvilinear Mapping ($s_{\\text{arc}}$)**: In a structured curvilinear mesh perfectly aligned with the circular geometry, the cell side along the tangential direction follows the arc itself. The exact length of this arc segment is:\n    $$\n    s_{\\text{arc}} = R \\Delta \\theta\n    $$\n\n2.  **Unstructured, Linear Edge ($s_{\\text{chord}}$)**: When an unstructured mesh approximates the curve using straight-sided elements (e.g., linear triangles), the segment is a straight line connecting the two endpoints on the arc. This is the chord length. The endpoints, for an arc segment starting at angle $0$ and ending at $\\Delta \\theta$, can be placed at $(R, 0)$ and $(R \\cos \\Delta \\theta, R \\sin \\Delta \\theta)$. The chord length is the distance between them, which simplifies to:\n    $$\n    s_{\\text{chord}} = \\sqrt{(R \\cos \\Delta \\theta - R)^2 + (R \\sin \\Delta \\theta - 0)^2} = R \\sqrt{\\cos^2 \\Delta \\theta - 2 \\cos \\Delta \\theta + 1 + \\sin^2 \\Delta \\theta} = R \\sqrt{2 - 2 \\cos \\Delta \\theta}\n    $$\n    Using the half-angle identity $1 - \\cos \\Delta \\theta = 2 \\sin^2(\\frac{\\Delta \\theta}{2})$, this becomes:\n    $$\n    s_{\\text{chord}} = R \\sqrt{4 \\sin^2\\left(\\frac{\\Delta \\theta}{2}\\right)} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)\n    $$\n\n3.  **Unstructured, Quadratic Curved Edge ($s_{\\text{quad}}$)**: A higher-order approximation uses curved elements. We model the segment using a quadratic isoparametric mapping. Three nodes are placed on the arc: at angles $0$, $\\frac{\\Delta\\theta}{2}$, and $\\Delta\\theta$. In a local coordinate system $t \\in [-1, 1]$, the positions of these nodes are interpolated using quadratic Lagrange shape functions:\n    $$\n    N_{-1}(t) = \\frac{t(t-1)}{2}, \\quad N_{0}(t) = 1-t^2, \\quad N_{1}(t) = \\frac{t(t+1)}{2}\n    $$\n    The node at $t=-1$ corresponds to angle $0$, $t=0$ to angle $\\frac{\\Delta\\theta}{2}$, and $t=1$ to angle $\\Delta\\theta$. The physical coordinates $(x(t), y(t))$ are given by:\n    $$\n    \\mathbf{r}(t) = \\mathbf{r}_{-1} N_{-1}(t) + \\mathbf{r}_{0} N_{0}(t) + \\mathbf{r}_{1} N_{1}(t)\n    $$\n    where $\\mathbf{r}_{-1}=(R,0)$, $\\mathbf{r}_{0}=(R\\cos(\\frac{\\Delta\\theta}{2}), R\\sin(\\frac{\\Delta\\theta}{2}))$, and $\\mathbf{r}_{1}=(R\\cos(\\Delta\\theta), R\\sin(\\Delta\\theta))$. The effective length of this curved edge is the integral of its differential arc length:\n    $$\n    s_{\\text{quad}} = \\int_{-1}^{1} \\left\\| \\frac{d\\mathbf{r}}{dt} \\right\\| dt = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2} dt\n    $$\n    The derivatives are linear functions of $t$: $\\frac{dx}{dt} = A_x t + B_x$ and $\\frac{dy}{dt} = A_y t + B_y$, where the coefficients are:\n    $$\n    A_x = R\\left(1 + \\cos(\\Delta\\theta) - 2\\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_x = \\frac{R}{2}(\\cos(\\Delta\\theta)-1)\n    $$\n    $$\n    A_y = R\\left(\\sin(\\Delta\\theta) - 2\\sin\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_y = \\frac{R}{2}\\sin(\\Delta\\theta)\n    $$\n    This integral is computed using numerical quadrature.\n\n### Step 2: FDTD Dispersion Relation\n\nFor a $2$D transverse-electric wave ($E_z, H_x, H_y$) propagating purely tangentially along a path defined by an orthogonal curvilinear coordinate $\\xi$, Maxwell's equations reduce to a one-dimensional system. Assuming uniformity in the normal direction ($\\frac{\\partial}{\\partial \\eta}=0$), the relevant equations are:\n$$\n\\frac{1}{h_\\xi} \\frac{\\partial E_z}{\\partial \\xi} = \\mu_0 \\frac{\\partial H_\\eta}{\\partial t}, \\quad \\frac{1}{h_\\xi} \\frac{\\partial H_\\eta}{\\partial \\xi} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\nwhere $h_\\xi$ is the metric scale factor. By defining a physical path length variable $s$ such that $ds = h_\\xi d\\xi$, and an effective spatial step $\\Delta s$, these equations take the form of the standard $1$D Cartesian Maxwell's equations:\n$$\n\\frac{\\partial E_z}{\\partial s} = \\mu_0 \\frac{\\partial H_y}{\\partial t}, \\quad \\frac{\\partial H_y}{\\partial s} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\nDiscretizing these using a staggered leapfrog FDTD scheme gives:\n$$\n\\frac{E_z|_i^{n+1/2} - E_z|_i^{n-1/2}}{\\Delta t} = \\frac{1}{\\varepsilon_0} \\frac{H_y|_{i+1/2}^n - H_y|_{i-1/2}^n}{\\Delta s}\n$$\n$$\n\\frac{H_y|_{i+1/2}^{n+1} - H_y|_{i+1/2}^n}{\\Delta t} = \\frac{1}{\\mu_0} \\frac{E_z|_{i+1}^{n+1/2} - E_z|_i^{n+1/2}}{\\Delta s}\n$$\nAssuming a harmonic plane-wave solution of the form $e^{j(k s - \\omega_{\\text{num}} t)}$, where $k$ is the analytical wavenumber and $\\omega_{\\text{num}}$ is the numerical angular frequency, and substituting into the finite-difference equations yields the numerical dispersion relation:\n$$\n\\sin\\left(\\frac{\\omega_{\\text{num}} \\Delta t}{2}\\right) = \\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\n$$\nwhere $c = 1/\\sqrt{\\mu_0 \\varepsilon_0}$ is the speed of light in vacuum. From this, we solve for $\\omega_{\\text{num}}$:\n$$\n\\omega_{\\text{num}} = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right)\n$$\nThe analytical wavenumber is $k = \\frac{2\\pi}{\\lambda}$ for a given wavelength $\\lambda$. This relation holds for each of the three effective step sizes $\\Delta s \\in \\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}$.\n\n### Step 3: Phase Velocity Error\n\nThe numerical phase velocity is defined as $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$. The ideal phase velocity is $c$. The relative error $e$ is therefore:\n$$\ne = \\frac{v_{\\text{num}} - c}{c} = \\frac{v_{\\text{num}}}{c} - 1\n$$\nSubstituting the expression for $\\omega_{\\text{num}}$ gives the final formula for the error:\n$$\ne = \\frac{2}{c k \\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right) - 1\n$$\n\n### Step 4: Time Step Calculation\n\nTo ensure numerical stability for the explicit time-marching scheme across all three geometric approximations with a single time step, $\\Delta t$ is chosen based on the most restrictive (smallest) spatial step for a given Courant factor $\\sigma$:\n$$\n\\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c}\n$$\nThe Courant factor $\\sigma$ must be less than $1$ for stability in one dimension. This choice of $\\Delta t$ guarantees that the argument of the $\\arcsin$ function in the dispersion relation is less than $1$, preventing instability.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for three different FDTD\n    geometry-fitting strategies on a circular arc.\n    \"\"\"\n\n    # Speed of light in vacuum (m/s)\n    c_light = 299792458.0\n\n    # Test cases: (R, delta_theta, lambda, sigma)\n    test_cases = [\n        (1.0, 0.2, 0.5, 0.95),   # Case 1: happy path\n        (1.0, 0.01, 0.5, 0.95),  # Case 2: fine angular resolution\n        (0.3, 0.5, 0.25, 0.90),  # Case 3: strong curvature\n        (0.2, 0.3, 0.10, 0.99),  # Case 4: near stability limit\n    ]\n\n    results = []\n\n    def calculate_s_quad(R, dtheta):\n        \"\"\"\n        Calculates the length of a quadratic isoparametric edge.\n        \"\"\"\n        if dtheta == 0.0:\n            return 0.0\n\n        # Define node positions corresponding to angles 0, dtheta/2, dtheta\n        # Mapped to local coordinates t = -1, 0, 1\n        r_m1 = np.array([R, 0.0])\n        r_0 = np.array([R * np.cos(dtheta / 2.0), R * np.sin(dtheta / 2.0)])\n        r_1 = np.array([R * np.cos(dtheta), R * np.sin(dtheta)])\n        \n        # Coefficients for dr/dt = A*t + B\n        # from r(t) = r_m1*N_m1(t) + r_0*N_0(t) + r_1*N_1(t)\n        # where N_m1, N_0, N_1 are standard quadratic Lagrange shape functions.\n        # This gives dr/dt = ((r_1-r_m1)/2) + (r_m1+r_1-2*r_0)*t\n        A = r_m1 + r_1 - 2 * r_0\n        B = (r_1 - r_m1) / 2.0\n        \n        Ax, Ay = A\n        Bx, By = B\n\n        # Integrand for arc length: sqrt((dx/dt)^2 + (dy/dt)^2)\n        def integrand(t):\n            dxdt = Ax * t + Bx\n            dydt = Ay * t + By\n            return np.sqrt(dxdt**2 + dydt**2)\n\n        # Numerical integration over t in [-1, 1]\n        s_quad_val, _ = quad(integrand, -1.0, 1.0)\n        return s_quad_val\n\n    def calculate_error(ds, dt, k, c):\n        \"\"\"\n        Calculates the relative phase velocity error.\n        \"\"\"\n        if ds == 0.0:\n            return 0.0 # Avoid division by zero, error is zero for zero step size\n\n        # Argument for the arcsin in the dispersion relation\n        courant_local = c * dt / ds\n        arg = courant_local * np.sin(k * ds / 2.0)\n        \n        # The choice of dt ensures abs(arg) = sigma  1\n        # so no complex numbers should arise.\n        if abs(arg) > 1.0:\n            # This case should not be reached with the problem's setup\n            arg = np.sign(arg)\n\n        omega_num = (2.0 / dt) * np.arcsin(arg)\n        v_num = omega_num / k\n        error = v_num / c - 1.0\n        return error\n\n    for R, dtheta, lambda_w, sigma in test_cases:\n        # Analytical wavenumber\n        k = 2.0 * np.pi / lambda_w\n\n        # Step 1: Calculate effective step sizes\n        s_arc = R * dtheta\n        s_chord = 2.0 * R * np.sin(dtheta / 2.0)\n        s_quad = calculate_s_quad(R, dtheta)\n\n        # Step 2: Calculate time step based on Courant condition\n        s_min = min(s_arc, s_chord, s_quad)\n        dt = sigma * s_min / c_light\n\n        # Step 3: Calculate errors for each geometry\n        error_arc = calculate_error(s_arc, dt, k, c_light)\n        error_chord = calculate_error(s_chord, dt, k, c_light)\n        error_quad = calculate_error(s_quad, dt, k, c_light)\n        \n        results.extend([error_arc, error_chord, error_quad])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3351225"}]}