{"hands_on_practices": [{"introduction": "A cornerstone of validating any simulation or measurement is ensuring the results adhere to fundamental physical laws. For passive networks, the law of energy conservation dictates that the device cannot create energy. This practice [@problem_id:3346657] provides a direct, hands-on method to implement a passivity check, verifying that the total power leaving a device, as described by its scattering parameters, does not exceed the total power entering it. Mastering this test is crucial for identifying non-physical artifacts in numerical data and building confidence in your simulation results.", "problem": "Consider a linear time-invariant multiport microwave network modeled by scattering parameters (S-parameters). Let the incident wave amplitude vector be denoted by $\\mathbf{a} \\in \\mathbb{C}^N$ and the scattered (outgoing) wave amplitude vector by $\\mathbf{b} \\in \\mathbb{C}^N$. The scattering relation is $\\mathbf{b} = \\mathbf{S} \\mathbf{a}$, where $\\mathbf{S} \\in \\mathbb{C}^{N \\times N}$ is the scattering matrix extracted numerically from a computational electromagnetics solver. Assume standard power-wave normalization at each port with real, positive reference impedances so that the time-averaged net Poynting flux associated with the port waves satisfies $\\sum_{j=1}^N |b_j|^2 - \\sum_{i=1}^N |a_i|^2 = P_{\\text{out}} - P_{\\text{in}}$, where $P_{\\text{in}}$ and $P_{\\text{out}}$ are the total incoming and outgoing powers across all ports, respectively.\n\nStarting from Maxwell's equations and the Poynting theorem for time-harmonic fields, the net time-averaged outward Poynting flux through a surface enclosing the device equals the input power minus any dissipated power. For a lossless passive network, the dissipated power is zero, and energy conservation implies $P_{\\text{out}} - P_{\\text{in}} = 0$ for any excitation $\\mathbf{a}$. In a discrete computational setting, define a Poynting flux-based test that, for a finite set of excitations $\\{\\mathbf{a}^{(k)}\\}$, computes the quantity\n$$\n\\Delta^{(k)} = \\sum_{j=1}^N \\left| b^{(k)}_j \\right|^2 - \\sum_{i=1}^N \\left| a^{(k)}_i \\right|^2,\n$$\nwhere $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$, and then tests for significant apparent energy loss in what is assumed to be a lossless setup. A violation is flagged whenever the net power change is negative beyond a numerical tolerance (i.e., declare a violation if $\\Delta^{(k)} < -\\tau$). The tolerance accounts for finite-precision roundoff.\n\nYour task is to implement a complete program that performs this discrete test for the following specified test suite. For each test case, compute whether any of the provided excitations yields a negative Poynting flux difference below the tolerance and return a boolean indicating detection of such a violation.\n\nUse the following test suite:\n\n- Case 1 (two-port, ideal lossless swap): $N=2$, \n$$\n\\mathbf{S}_1 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(1)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(1)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(1)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 2 (two-port, numerically lossy swap): $N=2$, \n$$\n\\mathbf{S}_2 = \\begin{bmatrix} 0 & 0.99 \\\\ 0.99 & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(2)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(2)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(2)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 3 (two-port, active diagonal gain): $N=2$, \n$$\n\\mathbf{S}_3 = \\begin{bmatrix} 1.01 & 0 \\\\ 0 & 1.01 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(3)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(3)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(3)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ -\\mathrm{j} \\end{bmatrix}.\n$$\n\n- Case 4 (three-port, unitary discrete Fourier transform): $N=3$, \n$$\n\\mathbf{S}_4 = \\frac{1}{\\sqrt{3}} \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & e^{\\mathrm{j}\\frac{2\\pi}{3}} & e^{\\mathrm{j}\\frac{4\\pi}{3}} \\\\\n1 & e^{\\mathrm{j}\\frac{4\\pi}{3}} & e^{\\mathrm{j}\\frac{8\\pi}{3}}\n\\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(4)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(4)}_4 = \\begin{bmatrix} 1 \\\\ e^{\\mathrm{j}\\frac{\\pi}{4}} \\\\ e^{-\\mathrm{j}\\frac{\\pi}{3}} \\end{bmatrix}.\n$$\n\n- Case 5 (two-port, near-lossless within tolerance): $N=2$, \n$$\n\\mathbf{S}_5 = \\begin{bmatrix} 0 & 1 - 10^{-7} \\\\ 1 - 10^{-7} & 0 \\end{bmatrix},\n$$\nexcitations \n$$\n\\mathbf{a}^{(5)}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\\quad\n\\mathbf{a}^{(5)}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\n\\mathbf{a}^{(5)}_3 = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ \\mathrm{j} \\end{bmatrix}.\n$$\n\nUse a common tolerance $\\tau = 10^{-6}$ for all cases.\n\nImplement an algorithm that, for each case, evaluates $\\Delta^{(k)}$ across all specified excitations and returns the boolean value $\\mathrm{True}$ if any $\\Delta^{(k)} < -\\tau$ and $\\mathrm{False}$ otherwise.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_m$ is the boolean result for case $m$. No physical units and no angle unit conversions are required; complex exponentials are to be handled in radians.", "solution": "We begin from Maxwell's equations in differential form for time-harmonic fields with the convention $e^{\\mathrm{j}\\omega t}$:\n$$\n\\nabla \\times \\mathbf{E} = -\\mathrm{j}\\omega \\mu \\mathbf{H}, \\quad\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + \\mathrm{j}\\omega \\epsilon \\mathbf{E}.\n$$\nThe complex Poynting vector is $\\mathbf{S} = \\frac{1}{2} \\mathbf{E} \\times \\mathbf{H}^*$, and the time-averaged Poynting theorem integrates over a closed surface $\\partial V$ enclosing the device to yield\n$$\n\\int_{\\partial V} \\mathrm{Re}\\{\\mathbf{S}\\} \\cdot \\mathbf{\\hat{n}} \\, \\mathrm{d}A = P_{\\text{out}} = P_{\\text{in}} - P_{\\text{diss}},\n$$\nwhere $P_{\\text{in}}$ is the time-averaged power delivered by sources through the ports and $P_{\\text{diss}}$ is the time-averaged dissipated power inside the volume $V$. For a lossless passive device, $P_{\\text{diss}} = 0$, and energy conservation implies $P_{\\text{out}} = P_{\\text{in}}$.\n\nIn multiport microwave network theory with standard power-wave normalization and real, positive reference impedances, the incident and outgoing port waves are represented by $\\mathbf{a} \\in \\mathbb{C}^N$ and $\\mathbf{b} \\in \\mathbb{C}^N$, respectively. The scattering relation is linear:\n$$\n\\mathbf{b} = \\mathbf{S} \\mathbf{a},\n$$\nwhere $\\mathbf{S} \\in \\mathbb{C}^{N \\times N}$ is the scattering matrix (S-parameters). Under power-wave normalization, the total time-averaged power entering and leaving through the ports are\n$$\nP_{\\text{in}} = \\sum_{i=1}^N |a_i|^2, \\qquad P_{\\text{out}} = \\sum_{j=1}^N |b_j|^2.\n$$\nFor a lossless passive network, the Poynting theorem implies $P_{\\text{out}} - P_{\\text{in}} = 0$ for any excitation $\\mathbf{a}$. This condition can be expressed equivalently by the unitarity of the scattering matrix, $\\mathbf{S}^\\dagger \\mathbf{S} = \\mathbf{I}$, but in a discrete numerical setting we assess conservation directly from the port-wave powers to avoid relying on global matrix properties that may be obscured by numerical error.\n\nDefine the discrete Poynting flux difference for a specific excitation $\\mathbf{a}^{(k)}$ as\n$$\n\\Delta^{(k)} = \\sum_{j=1}^N \\left| b^{(k)}_j \\right|^2 - \\sum_{i=1}^N \\left| a^{(k)}_i \\right|^2,\n$$\nwhere $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$. In exact arithmetic for a lossless device, $\\Delta^{(k)} = 0$ for all $k$. In finite-precision computations, we introduce a tolerance $\\tau > 0$ and declare a violation of the lossless setup if $\\Delta^{(k)} < -\\tau$ for any $k$. The negative sign specifically identifies apparent net absorption beyond the tolerance, which is incompatible with the assumed losslessness. Positive values indicate apparent net generation (active behavior), which also violates losslessness; however, the requested test flags the negative side to detect apparent dissipation inconsistencies in the extracted $\\mathbf{S}$.\n\nAlgorithmically, for each test case:\n1. Initialize the tolerance $\\tau = 10^{-6}$.\n2. For each specified excitation vector $\\mathbf{a}^{(k)}$, compute $\\mathbf{b}^{(k)} = \\mathbf{S} \\mathbf{a}^{(k)}$.\n3. Compute $\\Delta^{(k)} = \\sum_{j=1}^N |b^{(k)}_j|^2 - \\sum_{i=1}^N |a^{(k)}_i|^2$.\n4. If any $\\Delta^{(k)} < -\\tau$, flag the case as a violation (return $\\mathrm{True}$); otherwise, return $\\mathrm{False}$.\n\nWe now reason through expectations for the provided test suite:\n\n- Case 1: $\\mathbf{S}_1$ swaps the ports with unit magnitude, and the excitations have unit total power. For each excitation, $P_{\\text{out}} = P_{\\text{in}}$, so $\\Delta^{(k)} = 0$ and no violation is flagged. The result is $\\mathrm{False}$.\n\n- Case 2: $\\mathbf{S}_2$ swaps ports with magnitude $0.99$, so $P_{\\text{out}} = 0.99^2 P_{\\text{in}} = 0.9801 P_{\\text{in}}$. For unit-power excitations, $\\Delta^{(k)} = 0.9801 - 1 = -0.0199 < -\\tau$, which flags a violation. The result is $\\mathrm{True}$.\n\n- Case 3: $\\mathbf{S}_3$ applies a gain of $1.01$ on each port, so $P_{\\text{out}} = 1.01^2 P_{\\text{in}} = 1.0201 P_{\\text{in}}$, giving $\\Delta^{(k)} = 0.0201 > 0$. This does not meet the condition $\\Delta^{(k)} < -\\tau$, so the test does not flag a negative violation. The result is $\\mathrm{False}$.\n\n- Case 4: $\\mathbf{S}_4$ is the $3 \\times 3$ discrete Fourier transform matrix normalized by $1/\\sqrt{3}$, which is unitary. Hence, $P_{\\text{out}} = P_{\\text{in}}$ for any excitation, yielding $\\Delta^{(k)} = 0$ within numerical precision and no negative violation. The result is $\\mathrm{False}$.\n\n- Case 5: $\\mathbf{S}_5$ is nearly lossless with magnitude $1 - 10^{-7}$; thus $P_{\\text{out}} = (1 - 10^{-7})^2 P_{\\text{in}} = (1 - 2 \\cdot 10^{-7} + 10^{-14}) P_{\\text{in}}$. For unit-power excitations, $\\Delta^{(k)} \\approx -2 \\cdot 10^{-7}$, which is greater than $-\\tau = -10^{-6}$, so no violation is flagged under the specified tolerance. The result is $\\mathrm{False}$.\n\nThe program implements these computations exactly and outputs a single line with the list of booleans $[r_1,r_2,r_3,r_4,r_5]$ corresponding to the five cases.", "answer": "```python\nimport numpy as np\n\ndef poynting_flux_difference(S: np.ndarray, a: np.ndarray) -> float:\n    \"\"\"\n    Compute Delta = sum |b_j|^2 - sum |a_i|^2 for b = S a.\n    \"\"\"\n    b = S @ a\n    return float(np.sum(np.abs(b) ** 2) - np.sum(np.abs(a) ** 2))\n\ndef check_negative_violation(S: np.ndarray, excitations: list, tol: float) -> bool:\n    \"\"\"\n    Return True if any excitation produces Delta < -tol.\n    \"\"\"\n    for a in excitations:\n        delta = poynting_flux_difference(S, a)\n        if delta < -tol:\n            return True\n    return False\n\ndef solve():\n    tau = 1e-6  # tolerance\n\n    # Case 1: two-port, ideal lossless swap\n    S1 = np.array([[0.0, 1.0],\n                   [1.0, 0.0]], dtype=complex)\n    a1_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a1_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a1_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations1 = [a1_1, a1_2, a1_3]\n\n    # Case 2: two-port, numerically lossy swap\n    S2 = np.array([[0.0, 0.99],\n                   [0.99, 0.0]], dtype=complex)\n    a2_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a2_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a2_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations2 = [a2_1, a2_2, a2_3]\n\n    # Case 3: two-port, active diagonal gain\n    S3 = np.array([[1.01, 0.0],\n                   [0.0, 1.01]], dtype=complex)\n    a3_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a3_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a3_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, -1.0j])\n    excitations3 = [a3_1, a3_2, a3_3]\n\n    # Case 4: three-port, unitary DFT\n    # Construct the 3x3 DFT matrix normalized by 1/sqrt(3)\n    N = 3\n    F = np.zeros((N, N), dtype=complex)\n    for m in range(N):\n        for n in range(N):\n            F[m, n] = np.exp(1j * 2 * np.pi * m * n / N)\n    S4 = (1/np.sqrt(3)) * F\n    a4_1 = np.array([1.0+0.0j, 0.0+0.0j, 0.0+0.0j])\n    a4_2 = np.array([0.0+0.0j, 1.0+0.0j, 0.0+0.0j])\n    a4_3 = np.array([0.0+0.0j, 0.0+0.0j, 1.0+0.0j])\n    a4_4 = np.array([1.0+0.0j, np.exp(1j*np.pi/4), np.exp(-1j*np.pi/3)])\n    excitations4 = [a4_1, a4_2, a4_3, a4_4]\n\n    # Case 5: two-port, near-lossless within tolerance\n    S5 = np.array([[0.0, 1.0 - 1e-7],\n                   [1.0 - 1e-7, 0.0]], dtype=complex)\n    a5_1 = np.array([1.0+0.0j, 0.0+0.0j])\n    a5_2 = np.array([0.0+0.0j, 1.0+0.0j])\n    a5_3 = (1/np.sqrt(2)) * np.array([1.0+0.0j, 1.0j])\n    excitations5 = [a5_1, a5_2, a5_3]\n\n    test_cases = [\n        (S1, excitations1),\n        (S2, excitations2),\n        (S3, excitations3),\n        (S4, excitations4),\n        (S5, excitations5),\n    ]\n\n    results = []\n    for S, excitations in test_cases:\n        violation = check_negative_violation(S, excitations, tau)\n        results.append(violation)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346657"}, {"introduction": "In practical microwave engineering, the component we wish to characterize—the device-under-test (DUT)—is often measured or simulated as part of a larger assembly that includes feed lines, connectors, or test fixtures. To isolate the DUT's performance, these surrounding structures must be mathematically removed in a process known as de-embedding. This exercise [@problem_id:3346692] guides you through a powerful and standard technique: converting scattering parameters ($S$-parameters) to transmission matrices ($T$-matrices), which can be easily cascaded and inverted to surgically extract the true parameters of the DUT.", "problem": "A two-port measurement structure in a full-wave numerical solver is composed of an identical feed launcher on each side and a reciprocal device-under-test (DUT) at a single frequency. All ports are referenced to a real characteristic impedance $Z_{0} = 50\\,\\Omega$. The solver returns the scattering matrix $S$ of the entire three-block cascade (left feed, DUT, right feed). You are tasked with de-embedding the feeds to recover the DUT scattering matrix by constructing transmission (chain) matrices and algebraically removing the feed contributions.\n\nBase the derivation on first principles: define the complex power-wave variables $a_{n}$ and $b_{n}$ at port $n$, state the scattering matrix relation $b = S\\,a$, and define the transmission (chain) matrix in terms of port voltages and currents (the $A$–$B$–$C$–$D$ matrix). Derive the $A$–$B$–$C$–$D$ matrix from $S$ using only these definitions and linear algebra. Use the fact that identical feeds are present on both sides to perform the de-embedding by appropriate matrix inversion and cascading.\n\nAt the operating frequency, the individual feed launcher has scattering parameters\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = \\frac{19}{20},\\quad S_{12}^{(\\mathrm{feed})} = \\frac{19}{20},\n$$\nand the simulated three-block cascade (feed–DUT–feed) has scattering parameters\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\quad S_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\n\nConstruct the transmission matrices $T^{(\\mathrm{feed})}$ and $T^{(\\mathrm{tot})}$ in the voltage–current chain form $(A,B;C,D)$ using $Z_{0}$, then recover the DUT transmission matrix by algebraically removing the feeds on both sides. Convert the resulting DUT transmission matrix back to $S^{(\\mathrm{DUT})}$ using your derived relations.\n\nWhat is the value of the DUT forward transmission coefficient $S_{21}^{(\\mathrm{DUT})}$ at this frequency? Express your final answer as a real number and round to four significant figures.", "solution": "We begin with the power-wave definitions at a port of real reference impedance $Z_{0}$: for port $n$, the incident and reflected waves $a_{n}$ and $b_{n}$ are related to port voltage $V_{n}$ and current $I_{n}$ by\n$$\na_{n} = \\frac{V_{n} + Z_{0} I_{n}}{2\\sqrt{Z_{0}}},\\qquad b_{n} = \\frac{V_{n} - Z_{0} I_{n}}{2\\sqrt{Z_{0}}}.\n$$\nThe two-port scattering relation is\n$$\n\\begin{pmatrix} b_{1} \\\\ b_{2} \\end{pmatrix}\n=\n\\begin{pmatrix}\nS_{11} & S_{12} \\\\\nS_{21} & S_{22}\n\\end{pmatrix}\n\\begin{pmatrix} a_{1} \\\\ a_{2} \\end{pmatrix}.\n$$\nFor cascading, the convenient representation is the voltage–current transmission (chain) matrix, commonly denoted $(A,B;C,D)$ (the $A$–$B$–$C$–$D$ matrix), defined by\n$$\n\\begin{pmatrix} V_{1} \\\\ I_{1} \\end{pmatrix}\n=\n\\begin{pmatrix}\nA & B \\\\\nC & D\n\\end{pmatrix}\n\\begin{pmatrix} V_{2} \\\\ I_{2} \\end{pmatrix}.\n$$\nOur fundamental base is linear network theory under the $Z_{0}$-normalized power-wave framework, which ensures that both $S$ and $(A,B;C,D)$ are linearly related via the underlying $(V,I)$ variables.\n\nTo derive $(A,B;C,D)$ from $S$, we express $(V,I)$ in terms of $(a,b)$ using the definitions:\n$$\nV_{n} = \\sqrt{Z_{0}}(a_{n} + b_{n}),\\qquad I_{n} = \\frac{1}{\\sqrt{Z_{0}}}(a_{n} - b_{n}),\n$$\nand combine with $b = S\\,a$. Eliminating $a_{2}$ and $b_{2}$ in favor of $(V_{2}, I_{2})$ and similarly writing $(V_{1}, I_{1})$ in terms of $(a_{1}, b_{1})$ yields, after algebraic manipulation,\n$$\nA = \\frac{(1+S_{11})(1-S_{22}) + S_{12} S_{21}}{2 S_{21}},\\quad\nB = Z_{0}\\,\\frac{(1+S_{11})(1+S_{22}) - S_{12} S_{21}}{2 S_{21}},\n$$\n$$\nC = \\frac{1}{Z_{0}}\\,\\frac{(1-S_{11})(1-S_{22}) - S_{12} S_{21}}{2 S_{21}},\\quad\nD = \\frac{(1-S_{11})(1+S_{22}) + S_{12} S_{21}}{2 S_{21}}.\n$$\nThese relations follow directly from the linear transformations between $(a,b)$ and $(V,I)$ and the definition of the chain matrix.\n\nConversely, converting from $(A,B;C,D)$ back to $S$ under real $Z_{0}$ is obtained by solving the port-matching problem with $(V,I)$ waves:\n$$\n\\Delta \\equiv A + \\frac{B}{Z_{0}} + C Z_{0} + D,\n$$\n$$\nS_{21} = \\frac{2}{\\Delta},\\quad\nS_{11} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta},\\quad\nS_{22} = \\frac{-A + \\frac{B}{Z_{0}} - C Z_{0} + D}{\\Delta},\\quad\nS_{12} = \\frac{2(AD - BC)}{\\Delta}.\n$$\n\nWe now compute the feed launcher $(A,B;C,D)^{(\\mathrm{feed})}$ from its given $S^{(\\mathrm{feed})}$ at $Z_{0} = 50$:\n$$\nS_{11}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{22}^{(\\mathrm{feed})} = \\frac{1}{10},\\quad S_{21}^{(\\mathrm{feed})} = S_{12}^{(\\mathrm{feed})} = \\frac{19}{20}.\n$$\nCompute the products needed:\n$$\n(1+S_{11})(1-S_{22}) = \\left(1 + \\frac{1}{10}\\right)\\left(1 - \\frac{1}{10}\\right) = \\frac{11}{10}\\cdot\\frac{9}{10} = \\frac{99}{100},\n$$\n$$\nS_{12} S_{21} = \\left(\\frac{19}{20}\\right)^{2} = \\frac{361}{400}.\n$$\nThus\n$$\nA^{(\\mathrm{feed})} = \\frac{\\frac{99}{100} + \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{\\frac{396}{400} + \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{\\frac{757}{400}}{\\frac{38}{20}}\n= \\frac{757}{400}\\cdot\\frac{20}{38}\n= \\frac{757}{760},\n$$\n$$\n(1+S_{11})(1+S_{22}) = \\frac{11}{10}\\cdot\\frac{11}{10} = \\frac{121}{100},\\quad\n(1-S_{11})(1-S_{22}) = \\frac{9}{10}\\cdot\\frac{9}{10} = \\frac{81}{100}.\n$$\nSince the network is reciprocal and $S_{11}=S_{22}$, we have $D=A$, so $D^{(\\mathrm{feed})} = 757/760$. Then\n$$\nB^{(\\mathrm{feed})} = 50\\cdot\\frac{\\frac{121}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= 50\\cdot\\frac{\\frac{484}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{\\frac{123}{400}}{\\frac{38}{20}}\n= 50\\cdot\\frac{123}{400}\\cdot\\frac{20}{38}\n= \\frac{615}{76},\n$$\n$$\nC^{(\\mathrm{feed})} = \\frac{1}{50}\\cdot\\frac{\\frac{81}{100} - \\frac{361}{400}}{2\\cdot \\frac{19}{20}}\n= \\frac{1}{50}\\cdot\\frac{\\frac{324}{400} - \\frac{361}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\frac{-\\frac{37}{400}}{\\frac{38}{20}}\n= \\frac{1}{50}\\cdot\\left(-\\frac{37}{400}\\cdot\\frac{20}{38}\\right)\n= -\\frac{37}{38000}.\n$$\nThe feed matrix is\n$$\nT^{(\\mathrm{feed})}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & \\frac{615}{76} \\\\\n-\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\n\nNext, compute the chain matrix of the total cascade $T^{(\\mathrm{tot})}$ from $S^{(\\mathrm{tot})}$ using the same formulas. The given values are\n$$\nS_{11}^{(\\mathrm{tot})} = S_{22}^{(\\mathrm{tot})} = \\frac{491}{3105},\\qquad\nS_{21}^{(\\mathrm{tot})} = S_{12}^{(\\mathrm{tot})} = \\frac{1805}{2484}.\n$$\nCarrying out the arithmetic (keeping exact rational forms to avoid numerical error) yields\n$$\nT^{(\\mathrm{tot})}\n=\n\\begin{pmatrix}\n\\frac{7466980}{7220000} & \\frac{4040220}{144400} \\\\\n\\frac{897820}{361000000} & \\frac{7466980}{7220000}\n\\end{pmatrix}.\n$$\nWe now de-embed the identical feeds from the total transmission matrix. For a left–DUT–right cascade with identical feeds, the chain matrices satisfy\n$$\nT^{(\\mathrm{tot})} = T^{(\\mathrm{feed})}\\,T^{(\\mathrm{DUT})}\\,T^{(\\mathrm{feed})}.\n$$\nSolving for the DUT matrix,\n$$\nT^{(\\mathrm{DUT})} = \\left(T^{(\\mathrm{feed})}\\right)^{-1}\\,T^{(\\mathrm{tot})}\\,\\left(T^{(\\mathrm{feed})}\\right)^{-1}.\n$$\nFor a reciprocal passive two-port, the determinant of the chain matrix is $AD - BC = S_{12}/S_{21}$. Since the feed is reciprocal ($S_{12}=S_{21}$), its determinant is 1. Therefore,\n$$\n\\left(T^{(\\mathrm{feed})}\\right)^{-1}\n=\n\\begin{pmatrix}\nD^{(\\mathrm{feed})} & -B^{(\\mathrm{feed})} \\\\\n- C^{(\\mathrm{feed})} & A^{(\\mathrm{feed})}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}.\n$$\nPerforming the matrix products\n$$\nT^{(\\mathrm{DUT})} = \\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{7466980}{7220000} & \\frac{4040220}{144400} \\\\\n\\frac{897820}{361000000} & \\frac{7466980}{7220000}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{757}{760} & -\\frac{615}{76} \\\\\n\\frac{37}{38000} & \\frac{757}{760}\n\\end{pmatrix}\n$$\nyields, after exact rational simplification,\n$$\nT^{(\\mathrm{DUT})} =\n\\begin{pmatrix}\n\\frac{41}{40} & \\frac{45}{4} \\\\\n\\frac{9}{2000} & \\frac{41}{40}\n\\end{pmatrix}.\n$$\nThis chain matrix corresponds to a matched reciprocal attenuator. Converting $T^{(\\mathrm{DUT})}$ back to $S^{(\\mathrm{DUT})}$,\n$$\n\\Delta_{\\mathrm{DUT}} = A^{(\\mathrm{DUT})} + \\frac{B^{(\\mathrm{DUT})}}{Z_{0}} + C^{(\\mathrm{DUT})} Z_{0} + D^{(\\mathrm{DUT})}\n= \\frac{41}{40} + \\frac{45/4}{50} + \\left(\\frac{9}{2000}\\right) \\cdot 50 + \\frac{41}{40}\n= \\frac{41}{40} + \\frac{9}{40} + \\frac{9}{40} + \\frac{41}{40}\n= \\frac{100}{40}\n= \\frac{5}{2}.\n$$\nTherefore,\n$$\nS_{21}^{(\\mathrm{DUT})} = \\frac{2}{\\Delta_{\\mathrm{DUT}}} = \\frac{2}{5/2} = \\frac{4}{5} = 0.8.\n$$\nFor consistency, we can check the other DUT parameters:\n$$\nS_{11}^{(\\mathrm{DUT})} = \\frac{A + \\frac{B}{Z_{0}} - C Z_{0} - D}{\\Delta} = 0,\\qquad\nS_{22}^{(\\mathrm{DUT})} = 0.\n$$\nSince the DUT is specified as reciprocal, $AD-BC = S_{12}/S_{21}=1$, so $S_{12}=S_{21}$. This confirms we have a reciprocal matched attenuator.\n\nThus, the de-embedded device-under-test forward transmission is\n$$\nS_{21}^{(\\mathrm{DUT})} = 0.8.\n$$\nRounded to four significant figures, the requested value is $0.8000$.", "answer": "$$\\boxed{0.8000}$$", "id": "3346692"}, {"introduction": "The scattering parameters we work with are often generated by computational solvers that approximate the continuous laws of electromagnetism on a discrete mesh. This discretization process can introduce subtle errors that might violate physical principles, such as reciprocity, even when the underlying physical system is perfectly reciprocal. This final practice [@problem_id:3346695] illuminates this important computational nuance, tasking you with demonstrating how a simple numerical scheme can break reciprocity and, critically, how to perform a convergence study to quantify this error and verify that it vanishes as the simulation fidelity increases.", "problem": "Consider a one-dimensional transverse electromagnetic transmission problem in the frequency domain, modeled by the Telegrapher’s equations derived from Maxwell’s equations for a uniform, reciprocal, lossless medium with per-unit-length inductance $L'$ and capacitance $C'$: \n$$\\frac{dV}{dx} = -Z' I,\\quad \\frac{dI}{dx} = -Y' V,$$\nwhere $Z' = i \\omega L'$ and $Y' = i \\omega C'$ for angular frequency $\\omega = 2\\pi f$. For any reciprocal medium with symmetric constitutive relations and equal port reference impedances, the two-port scattering matrix $\\mathbf{S}$ is symmetric, that is $S_{12} = S_{21}$. \n\nIn computational electromagnetics, discretization of the spatial derivatives can introduce asymmetries that break reciprocity at finite mesh sizes, which should vanish under mesh refinement. In this problem, you will demonstrate and quantify how a first-order, one-sided spatial discretization (a forward Euler march in space) applied to the Telegrapher’s equations breaks the symmetry of the scattering matrix and how this asymmetry converges to zero as the spatial step size $h \\to 0$.\n\nUse the following construction. Over a segment of length $L$ discretized into $N$ uniform cells of size $h = L/N$, apply the forward Euler update\n$$\\begin{bmatrix}V_{n+1} \\\\ I_{n+1}\\end{bmatrix} = \\mathbf{T}_h \\begin{bmatrix}V_{n} \\\\ I_{n}\\end{bmatrix},\\quad \\mathbf{T}_h = \\begin{bmatrix}1 & -h Z' \\\\ -h Y' & 1\\end{bmatrix}.$$\nThe total chain (ABCD) matrix for the segment is \n$$\\mathbf{M}(h) = \\left(\\mathbf{T}_h\\right)^N = \\begin{bmatrix}A & B \\\\ C & D\\end{bmatrix}.$$\nFor equal reference impedances $Z_0$ at both ports, define the scattering parameters from the chain matrix by\n$$\\Delta = A + \\frac{B}{Z_0} + C Z_0 + D,$$\n$$S_{11} = \\frac{A + \\frac{B}{Z_0} - C Z_0 - D}{\\Delta},\\quad S_{21} = \\frac{2}{\\Delta},\\quad S_{12} = \\frac{2\\det(\\mathbf{M})}{\\Delta},\\quad S_{22} = \\frac{-A + \\frac{B}{Z_0} - C Z_0 + D}{\\Delta},$$\nwhere $\\det(\\mathbf{M}) = AD - BC$. For a truly reciprocal system $\\det(\\mathbf{M}) = 1$, which implies $S_{12} = S_{21}$; for the stated discretization, $\\det(\\mathbf{M}) \\neq 1$ at finite $h$, and $|S_{12} - S_{21}|$ quantifies the reciprocity-breaking error. \n\nYour task is to:\n- Implement the above discretized two-port model.\n- For a fixed physical configuration and a mesh refinement path $h_k = L/N_k$ with $N_k$ increasing by powers of two, compute the sequence $E(h_k) = |S_{12}(h_k) - S_{21}(h_k)|$.\n- Estimate the convergence rate $p$ defined by the model $E(h) \\approx C h^p$ as $h \\to 0$, by a least-squares fit on the log-log data $\\{\\log h_k, \\log E(h_k)\\}$.\n\nUse the following test suite, each specified by $(L, f, L', C', Z_0)$ in SI units, and a refinement path $N_k \\in \\{N_0, 2N_0, 4N_0, 8N_0\\}$ as specified per test. All physical quantities must be interpreted in their standard SI units. Angles for any internal trigonometric computations are in radians. The estimated convergence rates are dimensionless and should be output as real numbers.\n\n- Test 1 (happy path, matched line): $(L, f, L', C', Z_0) = (\\,0.5\\,\\mathrm{m},\\, 1.0\\times 10^9\\,\\mathrm{Hz},\\, 250\\times 10^{-9}\\,\\mathrm{H/m},\\, 100\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$ with $N_k \\in \\{\\,128,\\,256,\\,512,\\,1024\\,\\}$.\n- Test 2 (mismatch, moderate electrical length): $(L, f, L', C', Z_0) = (\\,0.3\\,\\mathrm{m},\\, 0.5\\times 10^9\\,\\mathrm{Hz},\\, 400\\times 10^{-9}\\,\\mathrm{H/m},\\, 100\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$ with $N_k \\in \\{\\,64,\\,128,\\,256,\\,512\\,\\}$.\n- Test 3 (edge case, small reciprocity error): $(L, f, L', C', Z_0) = (\\,0.2\\,\\mathrm{m},\\, 2.0\\times 10^9\\,\\mathrm{Hz},\\, 250\\times 10^{-9}\\,\\mathrm{H/m},\\, 50\\times 10^{-12}\\,\\mathrm{F/m},\\, 50\\,\\Omega\\,)$ with $N_k \\in \\{\\,64,\\,128,\\,256,\\,512\\,\\}$.\n\nYour program should compute the estimated convergence rate $p$ for each of the above three tests and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[p_1,p_2,p_3]$). The three values must be in the same order as the three tests listed above. The program must be self-contained and require no input.", "solution": "The problem is deemed valid as it is scientifically grounded in the principles of electromagnetic wave propagation and numerical analysis, self-contained, and well-posed. The parameters provided are physically realistic, and the task is a standard exercise in computational science, specifically quantifying the convergence rate of a numerical error.\n\nThe objective is to determine the convergence rate of the reciprocity-breaking error introduced by a first-order forward Euler spatial discretization of the one-dimensional Telegrapher’s equations. The reciprocity of a two-port network, described by its scattering matrix $\\mathbf{S}$, is guaranteed if $S_{12} = S_{21}$. The continuous physical system is reciprocal, but the numerical discretization violates this property at finite spatial step sizes. We are tasked with estimating the order of convergence $p$ in the error model $E(h) \\approx C h^p$, where $E(h) = |S_{12}(h) - S_{21}(h)|$ and $h$ is the spatial step size.\n\nThe analysis proceeds as follows for each test case.\n\nFirst, we define the physical and electrical parameters from the given inputs $(L, f, L', C', Z_0)$. The angular frequency is $\\omega = 2\\pi f$. The per-unit-length series impedance $Z'$ and shunt admittance $Y'$ for a lossless transmission line are purely imaginary:\n$$Z' = i \\omega L'$$\n$$Y' = i \\omega C'$$\nwhere $i$ is the imaginary unit. These are complex-valued constants for a fixed frequency $f$.\n\nNext, we implement the specified numerical scheme. The transmission line of total length $L$ is discretized into $N$ uniform cells, each of length $h = L/N$. The voltage $V$ and current $I$ at adjacent nodes, indexed by $n$, are related by a first-order forward Euler update rule:\n$$\n\\begin{bmatrix}\nV_{n+1} \\\\\nI_{n+1}\n\\end{bmatrix}\n=\n\\mathbf{T}_h\n\\begin{bmatrix}\nV_{n} \\\\\nI_{n}\n\\end{bmatrix}\n$$\nwhere $\\mathbf{T}_h$ is the local transfer matrix for a single cell of length $h$:\n$$\n\\mathbf{T}_h =\n\\begin{bmatrix}\n1 & -h Z' \\\\\n-h Y' & 1\n\\end{bmatrix}\n$$\nThe total chain matrix, also known as the ABCD matrix $\\mathbf{M}(h)$, relates the quantities at the input (port $1$, $x=0$) to the output (port $2$, $x=L$). It is obtained by composing the local transfer matrices for all $N$ cells:\n$$\n\\mathbf{M}(h) = (\\mathbf{T}_h)^N =\n\\begin{bmatrix}\nA & B \\\\\nC & D\n\\end{bmatrix}\n$$\nThis matrix power is computed numerically for each discretization level $N_k$ in the test sequence.\n\nThe source of the reciprocity error in this numerical model lies in the determinant of the transfer matrix. For a truly reciprocal two-port network, its ABCD matrix must have a determinant of $1$. For our numerical scheme, the determinant of the local matrix is:\n$$ \\det(\\mathbf{T}_h) = (1)(1) - (-h Z')(-h Y') = 1 - h^2 Z' Y' = 1 + h^2 \\omega^2 L' C' $$\nSince $\\det(\\mathbf{T}_h) \\neq 1$ for any $h > 0$, the total matrix $\\mathbf{M}(h)$ also has a non-unit determinant:\n$$ \\det(\\mathbf{M}(h)) = (\\det(\\mathbf{T}_h))^N = (1 + h^2 \\omega^2 L' C')^N $$\nThis deviation from unity directly causes the asymmetry in the S-matrix.\n\nThe scattering parameters are calculated from the elements of $\\mathbf{M}(h)$ and the reference impedance $Z_0$, using the provided formulas:\n$$ \\Delta = A + \\frac{B}{Z_0} + C Z_0 + D $$\n$$ S_{12} = \\frac{2\\det(\\mathbf{M})}{\\Delta} \\quad \\text{and} \\quad S_{21} = \\frac{2}{\\Delta} $$\nThe reciprocity-breaking error is defined as $E(h) = |S_{12}(h) - S_{21}(h)|$. Substituting the expressions for $S_{12}$ and $S_{21}$:\n$$ E(h) = \\left| \\frac{2\\det(\\mathbf{M})}{\\Delta} - \\frac{2}{\\Delta} \\right| = \\frac{2}{|\\Delta|} |\\det(\\mathbf{M}) - 1| $$\nTo understand the convergence behavior as $h \\to 0$, we analyze the term $|\\det(\\mathbf{M}) - 1|$. Since $N = L/h$, we have $\\det(\\mathbf{M}) = (1 + h^2 \\omega^2 L' C')^{L/h}$. Using the binomial approximation $(1 + x)^n \\approx 1 + nx$ for small $x$, where $x = h^2 \\omega^2 L' C'$ is small for small $h$:\n$$ \\det(\\mathbf{M}) \\approx 1 + N(h^2 \\omega^2 L' C') = 1 + \\frac{L}{h}(h^2 \\omega^2 L' C') = 1 + (L \\omega^2 L' C')h $$\nThus, $|\\det(\\mathbf{M})-1|$ is of order $O(h)$. As $h \\to 0$, the term $\\Delta$ converges to a finite, non-zero constant corresponding to the continuous system. Therefore, the error $E(h)$ is expected to be of order $O(h)$, implying a theoretical convergence rate of $p=1$.\n\nTo numerically estimate $p$, we use the model $E(h) \\approx C h^p$. Taking the natural logarithm of both sides linearizes the relationship:\n$$ \\ln(E(h)) \\approx \\ln(C) + p \\ln(h) $$\nThis equation is of the form $y = c + mx$, where $y = \\ln(E)$, $x = \\ln(h)$, and the slope is the convergence rate, $m=p$. For each test case, we compute the error $E(h_k)$ for each step size $h_k = L/N_k$ in the given refinement path. We then perform a linear least-squares regression on the set of data points $\\{\\ln(h_k), \\ln(E_k)\\}$. The slope of the best-fit line provides the numerical estimate for the convergence rate $p$. This procedure is repeated for all three test cases.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    \n    # Test cases defined as tuples:\n    # (L, f, L', C', Z0, N_values)\n    # L: length in meters\n    # f: frequency in Hertz\n    # L': per-unit-length inductance in Henrys/meter\n    # C': per-unit-length capacitance in Farads/meter\n    # Z0: reference impedance in Ohms\n    # N_values: list of discretization counts\n    test_cases = [\n        (0.5, 1.0e9, 250e-9, 100e-12, 50.0, [128, 256, 512, 1024]),\n        (0.3, 0.5e9, 400e-9, 100e-12, 50.0, [64, 128, 256, 512]),\n        (0.2, 2.0e9, 250e-9, 50e-12, 50.0, [64, 128, 256, 512]),\n    ]\n\n    results = []\n    for params in test_cases:\n        p = calculate_convergence_rate(*params)\n        results.append(p)\n\n    # Format the output as a comma-separated list in square brackets.\n    # The problem example shows integers, but results are floats.\n    # Default string conversion is used as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_convergence_rate(L, f, L_prime, C_prime, Z0, N_values):\n    \"\"\"\n    Calculates the convergence rate p for a single test case.\n\n    Args:\n        L (float): Length of the transmission line in meters.\n        f (float): Frequency in Hertz.\n        L_prime (float): Per-unit-length inductance in H/m.\n        C_prime (float): Per-unit-length capacitance in F/m.\n        Z0 (float): Reference impedance in Ohms.\n        N_values (list): A list of integers for the number of cells N.\n\n    Returns:\n        float: The estimated convergence rate p.\n    \"\"\"\n    \n    omega = 2 * math.pi * f\n    Z_prime = 1j * omega * L_prime\n    Y_prime = 1j * omega * C_prime\n\n    h_values = []\n    E_values = []\n\n    for N in N_values:\n        h = L / N\n        \n        # Construct the local transfer matrix T_h\n        T_h = np.array([[1, -h * Z_prime],\n                        [-h * Y_prime, 1]], dtype=np.complex128)\n        \n        # Calculate the total ABCD matrix M = (T_h)^N\n        M = np.linalg.matrix_power(T_h, N)\n        A, B = M[0, 0], M[0, 1]\n        C, D = M[1, 0], M[1, 1]\n        \n        # Calculate the S-parameters from the ABCD matrix\n        # Note: np.linalg.det() can be less accurate than manual calculation\n        # for a 2x2 matrix. A*D - B*C is more stable.\n        det_M = A * D - B * C\n        delta = A + B/Z0 + C*Z0 + D\n        \n        S12 = (2 * det_M) / delta\n        S21 = 2 / delta\n        \n        # Calculate the reciprocity error E(h)\n        E = abs(S12 - S21)\n        \n        h_values.append(h)\n        E_values.append(E)\n\n    # Convert lists to numpy arrays for vectorized operations\n    h_values = np.array(h_values)\n    E_values = np.array(E_values)\n\n    # Take the natural logarithm for log-log regression\n    log_h = np.log(h_values)\n    log_E = np.log(E_values)\n    \n    # Perform a linear least-squares fit on the log-log data.\n    # np.polyfit with degree 1 returns [slope, intercept].\n    # The slope is the convergence rate p.\n    p, _ = np.polyfit(log_h, log_E, 1)\n    \n    return p\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3346695"}]}