{"hands_on_practices": [{"introduction": "Before diving into complex numerical methods, it is essential to build a solid analytical foundation. This first practice explores the direct consequences of the wave equations for scalar and vector potentials, $V$ and $\\mathbf{A}$, in the Lorenz gauge. By working through this problem [@problem_id:73675], you will see how the fundamental principle of charge conservation, expressed through the continuity equation $\\nabla \\cdot \\mathbf{J} + \\frac{\\partial \\rho}{\\partial t} = 0$, directly links a time-varying current to a necessary charge distribution that acts as the source for the retarded scalar potential. Solving this problem provides a concrete understanding of how propagating sources generate potentials, reinforcing the physical intuition behind the mathematical formalism.", "problem": "An infinitely long, thin, straight wire is aligned with the $z$-axis. It carries a traveling-wave current given by $I(z, t) = I_0 \\cos(kz - \\omega t)$, where $I_0$, $k$, and $\\omega$ are positive constants. The current constitutes a sinusoidal pattern of charge moving along the wire.\n\nThe phase velocity of this wave is $v_p = \\omega/k$. We consider the case where the wave propagates slower than the speed of light in vacuum, $c$. This condition is expressed by setting $k = \\alpha (\\omega/c)$ for a given dimensionless constant $\\alpha > 1$.\n\nIn the Lorenz gauge, the scalar potential $V$ and vector potential $\\mathbf{A}$ are given by the retarded potential formulae. The time-varying current induces a time-varying charge density on the wire to ensure charge conservation, as described by the continuity equation $\\nabla \\cdot \\mathbf{J} + \\partial \\rho / \\partial t = 0$.\n\nThe resulting scalar potential in cylindrical coordinates $(\\rho, \\phi, z)$ takes the form $V(\\rho, z, t) = V_{\\text{amp}}(\\rho) \\cos(kz - \\omega t)$. Determine the expression for the amplitude of the scalar potential, $V_{\\text{amp}}(\\rho)$. Your answer should be expressed in terms of $I_0$, $\\omega$, $\\rho$, $\\alpha$, $c$, and the permeability of free space $\\mu_0$.", "solution": "1. From the continuity equation $\\frac{\\partial \\lambda}{\\partial t} + \\frac{\\partial I}{\\partial z} = 0$ and $I(z,t)=I_0\\cos(kz−\\omega t)$, we find $\\frac{\\partial \\lambda}{\\partial t} = -\\frac{\\partial I}{\\partial z} = kI_0 \\sin(kz−\\omega t)$. Integrating with respect to $t$ yields $\\lambda(z,t) = \\frac{kI_0}{\\omega}\\cos(kz−\\omega t)$. Thus, the charge amplitude is $\\lambda_{\\text{amp}}=\\frac{kI_0}{\\omega}$.\n2. In the Lorenz gauge, the wave equation for $V=V_{\\text{amp}}(\\rho)\\cos(kz−\\omega t)$ simplifies to the 2D modified Helmholtz equation: $(\\nabla_\\perp^2 - \\gamma^2)V_{\\text{amp}}(\\rho) = -\\frac{\\lambda_{\\text{amp}}}{\\epsilon_0}\\delta(x)\\delta(y)$, where $\\gamma^2 = k^2 - \\omega^2/c^2$.\n3. The solution to $(\\nabla_\\perp^2 - \\gamma^2)G(\\rho) = -\\delta(x)\\delta(y)$ is $G(\\rho) = \\frac{1}{2\\pi}K_0(\\gamma\\rho)$. The potential amplitude is therefore $V_{\\text{amp}}(\\rho) = \\frac{\\lambda_{\\text{amp}}}{\\epsilon_0}G(\\rho) = \\frac{\\lambda_{\\text{amp}}}{2\\pi\\epsilon_0}K_0(\\gamma\\rho)$.\n4. Substituting $\\lambda_{\\text{amp}}$, $\\epsilon_0=1/(\\mu_0c^2)$, $k=\\alpha\\omega/c$, and $\\gamma=(\\omega/c)\\sqrt{\\alpha^2-1}$:\n   $$V_{\\text{amp}}(\\rho) = \\frac{kI_0}{\\omega} \\frac{\\mu_0c^2}{2\\pi} K_0(\\gamma\\rho) = \\frac{(\\alpha\\omega/c)I_0\\mu_0c^2}{2\\pi\\omega} K_0(\\gamma\\rho) = \\frac{\\mu_0\\alpha cI_0}{2\\pi} K_0\\left(\\frac{\\omega\\rho}{c}\\sqrt{\\alpha^2-1}\\right)$$", "answer": "$$\\boxed{\\frac{\\mu_{0}\\,\\alpha\\,c\\,I_{0}}{2\\pi}\\;K_{0}\\!\\Bigl(\\frac{\\omega\\,\\rho}{c}\\sqrt{\\alpha^{2}-1}\\Bigr)}$$", "id": "73675"}, {"introduction": "Moving from continuous theory to computational practice requires us to represent physical quantities on a discrete mesh. A critical challenge in this transition is ensuring that fundamental conservation laws are not violated by the discretization scheme. This exercise [@problem_id:3346293] introduces the celebrated Rao-Wilton-Glisson (RWG) basis functions, which are specifically designed to be \"divergence-conforming.\" This practice will guide you through the implementation of these functions, demonstrating how they provide a mathematically consistent link between the discrete representation of surface current density $\\mathbf{J}$ and surface charge density $\\rho$, thereby numerically enforcing the continuity equation and guaranteeing charge conservation in the simulation.", "problem": "Consider time-harmonic electromagnetic fields with angular frequency $\\omega$ in free space. Start from Maxwell's equations in differential form for time-harmonic fields with complex phasors $e^{j \\omega t}$: $$\\nabla \\times \\mathbf{H} = \\mathbf{J} + j \\omega \\mathbf{D}, \\quad \\nabla \\times \\mathbf{E} = - j \\omega \\mathbf{B}, \\quad \\nabla \\cdot \\mathbf{D} = \\rho, \\quad \\nabla \\cdot \\mathbf{B} = 0,$$ with constitutive relations $\\mathbf{D} = \\varepsilon \\mathbf{E}$ and $\\mathbf{B} = \\mu \\mathbf{H}$, where $\\varepsilon$ is the permittivity, $\\mu$ is the permeability, $\\mathbf{J}$ is the current density, and $\\rho$ is the charge density. The fundamental conservation law is the continuity equation $$\\nabla \\cdot \\mathbf{J} + j \\omega \\rho = 0.$$\n\nDefine the magnetic vector potential $\\mathbf{A}$ and the electric scalar potential $\\phi$ through the retarded potentials for sources in free space: $$\\mathbf{A}(\\mathbf{x}) = \\mu \\int_S \\mathbf{J}(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}, \\quad \\phi(\\mathbf{x}) = \\frac{1}{\\varepsilon} \\int_S \\rho(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}},$$ where $k = \\omega \\sqrt{\\mu \\varepsilon}$ is the free-space wavenumber, and the integrals are taken over the source surface $S$. In computational electromagnetics, one must discretize $\\mathbf{J}$ and $\\rho$ in a manner that enforces a discrete analogue of the continuity equation. A standard choice on triangulated surfaces is the Rao-Wilton-Glisson (RWG) basis, which is divergence-conforming and ensures that the discrete divergence maps consistently onto piecewise-constant charge densities.\n\nOn a triangulated planar surface, the lowest-order RWG basis function associated with an interior edge of length $\\ell_e$ shared by two triangles $T^+$ and $T^-$ with areas $A^+$ and $A^-$ and opposite vertices $\\mathbf{r}_\\text{op}^+$ and $\\mathbf{r}_\\text{op}^-$ is defined by $$\\mathbf{f}_e(\\mathbf{r}) = \\begin{cases} \\dfrac{\\ell_e}{2 A^+} \\left(\\mathbf{r} - \\mathbf{r}_\\text{op}^+\\right), & \\mathbf{r} \\in T^+, \\\\ \\dfrac{\\ell_e}{2 A^-} \\left(\\mathbf{r}_\\text{op}^- - \\mathbf{r}\\right), & \\mathbf{r} \\in T^-, \\\\ 0, & \\text{otherwise}, \\end{cases}$$ whose surface divergence is piecewise constant: $$\\nabla_s \\cdot \\mathbf{f}_e = \\begin{cases} + \\dfrac{\\ell_e}{A^+}, & \\mathbf{r} \\in T^+, \\\\ - \\dfrac{\\ell_e}{A^-}, & \\mathbf{r} \\in T^-. \\end{cases}$$ If the current density is discretized as $\\mathbf{J}_h = i_e \\mathbf{f}_e$ for some complex amplitude $i_e$ (in amperes), then a consistent discrete divergence operator $D$ mapping the edge coefficient $i_e$ to piecewise-constant charges on $T^+$ and $T^-$ is $$D \\, i_e = \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix} i_e.$$ The discrete continuity equation then reads $$D \\, i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0},$$ where $\\boldsymbol{\\rho}_h \\in \\mathbb{C}^2$ are the piecewise-constant surface charge densities on $T^+$ and $T^-$. Solving for $\\boldsymbol{\\rho}_h$ yields $$\\boldsymbol{\\rho}_h = - \\dfrac{1}{j \\omega} D \\, i_e.$$\n\nTask: Construct the divergence-conforming RWG basis on simple triangle pairs, assemble the discrete divergence operator $D$, compute the charge densities $\\boldsymbol{\\rho}_h$ via the discrete continuity equation, and verify numerically that the residual $\\|D \\, i_e + j \\omega \\boldsymbol{\\rho}_h\\|_2$ is below a prescribed tolerance. Additionally, compute the retarded magnetic vector potential $\\mathbf{A}(\\mathbf{x})$ and scalar potential $\\phi(\\mathbf{x})$ at given observation points using centroid-based quadrature to demonstrate a complete potential-based discretization, though the verification criterion is solely the discrete continuity residual.\n\nUse free-space parameters $\\mu = \\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{H/m}$ and $\\varepsilon = \\varepsilon_0 = 8.854187817 \\times 10^{-12} \\ \\mathrm{F/m}$. All geometric lengths are in meters, currents in amperes, charges in coulombs per square meter, and potentials in weber per meter for $\\mathbf{A}$ and volts for $\\phi$. Angles, if any, are in radians. Implement the following test suite:\n\n- Test case $1$ (happy path): Triangulated unit square split by the interior edge between $(1,0)$ and $(0,1)$ forming triangles $T^+ = \\{(0,0),(1,0),(0,1)\\}$ and $T^- = \\{(1,1),(0,1),(1,0)\\}$, with $i_e = 1.0 \\ \\mathrm{A}$ and $\\omega = 2 \\pi \\cdot 100 \\times 10^{6} \\ \\mathrm{rad/s}$. Use observation points $\\mathbf{x}_1 = (0.50, 0.50, 0.25)$, $\\mathbf{x}_2 = (0.25, 0.25, 0.25)$, and $\\mathbf{x}_3 = (0.75, 0.25, 0.25)$ in meters for computing $\\mathbf{A}$ and $\\phi$ via centroid quadrature.\n- Test case $2$ (low-frequency edge case): Same geometry and observation points, with $i_e = 0.5 \\ \\mathrm{A}$ and $\\omega = 2 \\pi \\cdot 1 \\times 10^{3} \\ \\mathrm{rad/s}$.\n- Test case $3$ (geometric variation): Rectangle $\\{(0,0),(2,0),(0,1),(2,1)\\}$ split by the interior edge between $(2,0)$ and $(0,1)$ forming triangles $T^+ = \\{(0,0),(2,0),(0,1)\\}$ and $T^- = \\{(2,1),(0,1),(2,0)\\}$, with $i_e = 2.0 \\ \\mathrm{A}$ and $\\omega = 2 \\pi \\cdot 1 \\times 10^{6} \\ \\mathrm{rad/s}$. Use observation points $\\mathbf{x}_1 = (1.00, 0.50, 0.25)$, $\\mathbf{x}_2 = (0.50, 0.25, 0.25)$, and $\\mathbf{x}_3 = (1.50, 0.25, 0.25)$ in meters.\n\nFor each test case, compute the discrete residual $$r = \\left\\| D \\, i_e + j \\omega \\boldsymbol{\\rho}_h \\right\\|_2,$$ and report a boolean indicating whether $r < 10^{-12}$ (unitless threshold applied to the $2$-norm of the complex residual vector). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\texttt{[result1,result2,result3]}$).", "solution": "The user has provided a problem in computational electromagnetics that requires validating the discrete continuity equation for Rao-Wilton-Glisson (RWG) basis functions and subsequently computing the retarded electromagnetic potentials. The problem is to be solved for three distinct test cases.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n- **Governing Equations**: Time-harmonic Maxwell's equations and the continuity equation.\n$$\n\\begin{align*}\n\\nabla \\times \\mathbf{H} &= \\mathbf{J} + j \\omega \\mathbf{D} \\\\\n\\nabla \\times \\mathbf{E} &= - j \\omega \\mathbf{B} \\\\\n\\nabla \\cdot \\mathbf{D} &= \\rho \\\\\n\\nabla \\cdot \\mathbf{B} &= 0 \\\\\n\\nabla \\cdot \\mathbf{J} + j \\omega \\rho &= 0\n\\end{align*}\n$$\n- **Constitutive Relations**: $\\mathbf{D} = \\varepsilon \\mathbf{E}$, $\\mathbf{B} = \\mu \\mathbf{H}$.\n- **Constants**: Permeability of free space $\\mu = \\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{H/m}$, Permittivity of free space $\\varepsilon = \\varepsilon_0 = 8.854187817 \\times 10^{-12} \\ \\mathrm{F/m}$.\n- **Retarded Potentials**:\n$$\n\\mathbf{A}(\\mathbf{x}) = \\mu \\int_S \\mathbf{J}(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}\n$$\n$$\n\\phi(\\mathbf{x}) = \\frac{1}{\\varepsilon} \\int_S \\rho(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}\n$$\nwhere $k = \\omega \\sqrt{\\mu \\varepsilon}$.\n- **RWG Basis Function**: For an interior edge of length $\\ell_e$ between triangles $T^+$ and $T^-$, with areas $A^+$, $A^-$ and opposite vertices $\\mathbf{r}_\\text{op}^+$, $\\mathbf{r}_\\text{op}^-$.\n$$\n\\mathbf{f}_e(\\mathbf{r}) = \\begin{cases} \\dfrac{\\ell_e}{2 A^+} \\left(\\mathbf{r} - \\mathbf{r}_\\text{op}^+\\right), & \\mathbf{r} \\in T^+, \\\\ \\dfrac{\\ell_e}{2 A^-} \\left(\\mathbf{r}_\\text{op}^- - \\mathbf{r}\\right), & \\mathbf{r} \\in T^-, \\\\ 0, & \\text{otherwise}. \\end{cases}\n$$\n- **RWG Surface Divergence**:\n$$\n\\nabla_s \\cdot \\mathbf{f}_e = \\begin{cases} + \\dfrac{\\ell_e}{A^+}, & \\mathbf{r} \\in T^+, \\\\ - \\dfrac{\\ell_e}{A^-}, & \\mathbf{r} \\in T^-. \\end{cases}\n$$\n- **Discrete Divergence Operator**: $D \\, i_e = \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix} i_e$.\n- **Discrete Continuity Equation**: $D \\, i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0}$, where $\\boldsymbol{\\rho}_h$ is the vector of piecewise-constant surface charge densities on $T^+$ and $T^-$.\n- **Solution for Charge Density**: $\\boldsymbol{\\rho}_h = - \\dfrac{1}{j \\omega} D \\, i_e$.\n- **Verification Task**: Compute the residual $r = \\| D \\, i_e + j \\omega \\boldsymbol{\\rho}_h \\|_2$ and check if $r < 10^{-12}$.\n- **Potential Calculation Task**: Compute $\\mathbf{A}(\\mathbf{x})$ and $\\phi(\\mathbf{x})$ using centroid-based quadrature.\n- **Test Case 1**:\n    -   Geometry: $T^+ = \\{(0,0),(1,0),(0,1)\\}$, $T^- = \\{(1,1),(0,1),(1,0)\\}$.\n    -   Current amplitude: $i_e = 1.0 \\ \\mathrm{A}$.\n    -   Angular frequency: $\\omega = 2 \\pi \\cdot 100 \\times 10^{6} \\ \\mathrm{rad/s}$.\n    -   Observation points: $\\mathbf{x}_1 = (0.50, 0.50, 0.25)$, $\\mathbf{x}_2 = (0.25, 0.25, 0.25)$, $\\mathbf{x}_3 = (0.75, 0.25, 0.25)$.\n- **Test Case 2**:\n    -   Geometry: Same as case 1.\n    -   Current amplitude: $i_e = 0.5 \\ \\mathrm{A}$.\n    -   Angular frequency: $\\omega = 2 \\pi \\cdot 1 \\times 10^{3} \\ \\mathrm{rad/s}$.\n    -   Observation points: Same as case 1.\n- **Test Case 3**:\n    -   Geometry: $T^+ = \\{(0,0),(2,0),(0,1)\\}$, $T^- = \\{(2,1),(0,1),(2,0)\\}$.\n    -   Current amplitude: $i_e = 2.0 \\ \\mathrm{A}$.\n    -   Angular frequency: $\\omega = 2 \\pi \\cdot 1 \\times 10^{6} \\ \\mathrm{rad/s}$.\n    -   Observation points: $\\mathbf{x}_1 = (1.00, 0.50, 0.25)$, $\\mathbf{x}_2 = (0.50, 0.25, 0.25)$, $\\mathbf{x}_3 = (1.50, 0.25, 0.25)$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is reviewed against the validation criteria:\n1.  **Scientific or Factual Unsoundness**: The problem is based on the standard Maxwell's equations and their application in computational electromagnetics using the Method of Moments with RWG basis functions. The equations for the basis function, its divergence, the discrete continuity equation, and retarded potentials are all standard and correct. There are no scientific flaws.\n2.  **Non-Formalizable or Irrelevant**: The problem is a well-defined computational task directly relevant to the topic of scalar and vector potentials in electromagnetics.\n3.  **Incomplete or Contradictory Setup**: All necessary parameters, including geometries, physical constants, current amplitudes, and frequencies, are explicitly provided for each test case. The procedure for numerical integration (centroid quadrature) is also specified. There are no contradictions.\n4.  **Unrealistic or Infeasible**: The geometric dimensions and physical parameters are realistic for engineering applications (e.g., radio-frequency devices).\n5.  **Ill-Posed or Poorly Structured**: The primary task is to verify an algebraic identity. By defining $\\boldsymbol{\\rho}_h = - \\frac{1}{j \\omega} D i_e$, the residual $D i_e + j \\omega \\boldsymbol{\\rho}_h$ becomes $D i_e + j \\omega (-\\frac{1}{j \\omega} D i_e) = D i_e - D i_e = \\mathbf{0}$. Analytically, the solution is exact. The numerical task is to implement this and show that the residual is zero up to machine precision, which is a well-posed verification task. The potential calculations are also based on well-defined integrals.\n6.  **Pseudo-Profound, Trivial, or Tautological**: While the verification of the continuity equation is algebraically trivial, its numerical implementation requires correct geometric calculations (areas, lengths), assembly of the discrete operator, and correct handling of complex arithmetic. This serves as a valid, non-trivial programming exercise to confirm understanding of the underlying discretization principles.\n7.  **Outside Scientific Verifiability**: The problem is a computational task whose results are entirely verifiable by calculation.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-posed, scientifically sound exercise in computational electromagnetics. I will proceed with a full solution.\n\n### Algorithmic Solution\n\nThe solution procedure for each test case involves the following steps:\n1.  **Geometric Analysis**: From the vertices defining the two triangles, $T^+$ and $T^-$, we identify the shared edge and the two opposite vertices, $\\mathbf{r}_{\\text{op}}^+$ and $\\mathbf{r}_{\\text{op}}^-$. We then compute the length of the shared edge, $\\ell_e$, and the areas of the two triangles, $A^+$ and $A^-$. The area of a triangle defined by vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ is given by $A = \\frac{1}{2} \\| (\\mathbf{v}_2 - \\mathbf{v}_1) \\times (\\mathbf{v}_3 - \\mathbf{v}_1) \\|$.\n\n2.  **Discrete Operator Assembly**: The discrete divergence operator $D$, which maps the current coefficient $i_e$ on the shared edge to the resulting charges on the triangles, is formed as a $2 \\times 1$ matrix (or a 2-element column vector):\n    $$\n    D = \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix}\n    $$\n\n3.  **Charge Density Calculation**: Given the current coefficient $i_e$ and angular frequency $\\omega$, the vector of piecewise-constant charge densities $\\boldsymbol{\\rho}_h = [\\rho^+, \\rho^-]^T$ is computed from the discrete continuity equation, $D i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0}$. This yields:\n    $$\n    \\boldsymbol{\\rho}_h = -\\frac{1}{j\\omega} D i_e = \\frac{j}{\\omega} D i_e = \\frac{j i_e}{\\omega} \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix}\n    $$\n    Here, $j = \\sqrt{-1}$ is the imaginary unit.\n\n4.  **Residual Verification**: We compute the residual vector $\\mathbf{res} = D i_e + j \\omega \\boldsymbol{\\rho}_h$. Substituting the expression for $\\boldsymbol{\\rho}_h$ from the previous step, we expect this vector to be numerically close to the zero vector. We calculate its Euclidean norm (2-norm), $r = \\| \\mathbf{res} \\|_2$, and verify if it is below the specified tolerance of $10^{-12}$.\n\n5.  **Potential Calculation**: To complete the demonstration, we compute the magnetic vector potential $\\mathbf{A}(\\mathbf{x})$ and electric scalar potential $\\phi(\\mathbf{x})$ at specified observation points $\\mathbf{x}$. The problem prescribes centroid-based quadrature.\n    -   First, we determine the centroids of the triangles: $\\mathbf{r}_c^+ = \\frac{1}{3}\\sum_{i=1}^3 \\mathbf{v}_i^+$ and $\\mathbf{r}_c^- = \\frac{1}{3}\\sum_{i=1}^3 \\mathbf{v}_i^-$.\n    -   The magnetic vector potential $\\mathbf{A}(\\mathbf{x})$ is approximated by:\n        $$\n        \\mathbf{A}(\\mathbf{x}) \\approx \\mu_0 i_e \\left[ \\mathbf{f}_e(\\mathbf{r}_c^+) A^+ \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^+\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^+\\|} + \\mathbf{f}_e(\\mathbf{r}_c^-) A^- \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^-\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^-\\|} \\right]\n        $$\n        where $\\mathbf{f}_e$ is evaluated at the respective centroids. This simplifies to:\n        $$\n        \\mathbf{A}(\\mathbf{x}) \\approx \\frac{\\mu_0 i_e \\ell_e}{8 \\pi} \\left[ (\\mathbf{r}_c^+ - \\mathbf{r}_\\text{op}^+) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^+\\|}}{\\|\\mathbf{x}-\\mathbf{r}_c^+\\|} + (\\mathbf{r}_\\text{op}^- - \\mathbf{r}_c^-) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^-\\|}}{\\|\\mathbf{x}-\\mathbf{r}_c^-\\|} \\right]\n        $$\n        The wavenumber is $k = \\omega \\sqrt{\\mu_0 \\varepsilon_0}$.\n    -   The electric scalar potential $\\phi(\\mathbf{x})$ is approximated by:\n        $$\n        \\phi(\\mathbf{x}) \\approx \\frac{1}{\\varepsilon_0} \\left[ \\rho^+ A^+ \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^+\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^+\\|} + \\rho^- A^- \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^-\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^-\\|} \\right]\n        $$\n        using the components $\\rho^+$ and $\\rho^-$ of the vector $\\boldsymbol{\\rho}_h$ computed in step 3.\n\nThis procedure will be applied to each of the three test cases provided. The final output is a boolean list indicating whether the residual check passed for each case. Given the analytical nature of the check, the result is expected to be `True` for all cases, provided the implementation is numerically sound.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational electromagnetics problem.\n    It processes three test cases, calculates geometric properties of triangle pairs,\n    verifies the discrete continuity equation for RWG basis functions, and\n    computes the retarded potentials as a demonstration.\n    \"\"\"\n    \n    # Constants\n    MU_0 = 4 * np.pi * 1e-7 # H/m\n    EPSILON_0 = 8.854187817e-12 # F/m\n    \n    test_cases = [\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"i_e\": 1.0 + 0.0j,\n            \"omega\": 2 * np.pi * 100e6,\n            \"obs_points\": np.array([[0.50, 0.50, 0.25], [0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        },\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"i_e\": 0.5 + 0.0j,\n            \"omega\": 2 * np.pi * 1e3,\n            \"obs_points\": np.array([[0.50, 0.50, 0.25], [0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        },\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[2.0, 1.0, 0.0], [0.0, 1.0, 0.0], [2.0, 0.0, 0.0]]),\n            \"i_e\": 2.0 + 0.0j,\n            \"omega\": 2 * np.pi * 1e6,\n            \"obs_points\": np.array([[1.00, 0.50, 0.25], [0.50, 0.25, 0.25], [1.50, 0.25, 0.25]])\n        }\n    ]\n    \n    results = []\n\n    def get_triangle_properties(verts_plus, verts_minus):\n        \"\"\"Identifies shared edge, opposite vertices, and calculates areas.\"\"\"\n        set_plus = {tuple(v) for v in verts_plus}\n        set_minus = {tuple(v) for v in verts_minus}\n        \n        shared_verts_tuples = set_plus.intersection(set_minus)\n        shared_verts = [np.array(v) for v in shared_verts_tuples]\n        \n        v_op_plus_tuple = set_plus.difference(set_minus).pop()\n        v_op_plus = np.array(v_op_plus_tuple)\n        \n        v_op_minus_tuple = set_minus.difference(set_plus).pop()\n        v_op_minus = np.array(v_op_minus_tuple)\n\n        edge_vec = shared_verts[0] - shared_verts[1]\n        ell_e = np.linalg.norm(edge_vec)\n\n        area_plus = 0.5 * np.linalg.norm(np.cross(shared_verts[0] - v_op_plus, shared_verts[1] - v_op_plus))\n        area_minus = 0.5 * np.linalg.norm(np.cross(shared_verts[0] - v_op_minus, shared_verts[1] - v_op_minus))\n        \n        return v_op_plus, v_op_minus, ell_e, area_plus, area_minus\n\n    for case in test_cases:\n        # Step 1: Geometric Analysis\n        v_op_plus, v_op_minus, ell_e, A_plus, A_minus = get_triangle_properties(\n            case[\"tri_plus_verts\"], case[\"tri_minus_verts\"]\n        )\n\n        # Step 2: Discrete Operator Assembly\n        D_op = np.array([ell_e / A_plus, -ell_e / A_minus])\n\n        # Step 3: Charge Density Calculation\n        i_e = case[\"i_e\"]\n        omega = case[\"omega\"]\n        j = 1j\n        \n        rho_h = -(1 / (j * omega)) * D_op * i_e\n\n        # Step 4: Residual Verification\n        residual_vec = D_op * i_e + j * omega * rho_h\n        residual_norm = np.linalg.norm(residual_vec)\n        results.append(residual_norm < 1e-12)\n\n        # Step 5: Potential Calculation (for demonstration)\n        # This part is computed as requested but not part of the final output.\n        k = omega * np.sqrt(MU_0 * EPSILON_0)\n        \n        r_c_plus = np.mean(case[\"tri_plus_verts\"], axis=0)\n        r_c_minus = np.mean(case[\"tri_minus_verts\"], axis=0)\n        \n        rho_plus, rho_minus = rho_h\n        \n        A_values = []\n        phi_values = []\n        \n        for x in case[\"obs_points\"]:\n            # Distances from observation point to centroids\n            dist_plus = np.linalg.norm(x - r_c_plus)\n            dist_minus = np.linalg.norm(x - r_c_minus)\n\n            # Green's function, handling division by zero if x is on a centroid\n            G_plus = np.exp(-j * k * dist_plus) / (4 * np.pi * dist_plus) if dist_plus > 1e-9 else 0\n            G_minus = np.exp(-j * k * dist_minus) / (4 * np.pi * dist_minus) if dist_minus > 1e-9 else 0\n            \n            # Scalar potential\n            phi = (1 / EPSILON_0) * (rho_plus * A_plus * G_plus + rho_minus * A_minus * G_minus)\n            phi_values.append(phi)\n            \n            # Vector potential\n            A = (MU_0 * i_e * ell_e / (8 * np.pi)) * (\n                (r_c_plus - v_op_plus) * np.exp(-j * k * dist_plus) / dist_plus +\n                (v_op_minus - r_c_minus) * np.exp(-j * k * dist_minus) / dist_minus\n            )\n            A_values.append(A)\n\n    # Final print statement must be in this exact format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346293"}, {"introduction": "A major hurdle in implementing integral equation methods for potential theory is the numerical evaluation of the potential integrals, which often feature singular kernels. This problem arises when the observation point lies on the source patch itself, causing the distance term $R$ in the kernel, such as $1/R$, to go to zero. This advanced practice [@problem_id:3346287] focuses on developing a robust technique to handle these \"weakly singular\" integrals. You will derive and implement a coordinate transformation method that regularizes the integrand, effectively canceling the singularity and enabling accurate computation with standard quadrature rules, a crucial skill for building stable and reliable computational electromagnetics solvers.", "problem": "You are tasked with designing, justifying, and implementing a quadrature scheme to accurately evaluate weakly singular integrals with kernel of the form $1/R$ that arise in the computation of the vector potential in computational electromagnetics. Consider the magnetostatic vector potential $\\mathbf{A}(\\mathbf{r})$ generated by a surface current density $\\mathbf{J}(\\mathbf{r}')$ over a curved parametric surface patch. The problem reduces to reliably evaluating surface integrals of the form\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{S_e} \\frac{1}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|} \\, \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi}(\\xi,\\eta) \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta}(\\xi,\\eta) \\right\\| \\, d\\xi \\, d\\eta,\n$$\nwhere $S_e$ is a single curved isoparametric triangular element with local coordinates $(\\xi,\\eta)$ in the reference triangle $T = \\{(\\xi,\\eta)\\,|\\,\\xi \\ge 0, \\eta \\ge 0, \\xi+\\eta \\le 1\\}$, $\\mathbf{r}(\\xi,\\eta)$ is the isoparametric mapping to $\\mathbb{R}^3$, and $\\mathbf{r}_\\mathrm{p}=\\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ is a source or field point lying on the same element. The kernel is weakly singular because as $(\\xi,\\eta)\\to(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$, the Euclidean distance $R=\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|$ vanishes and the integrand behaves like $1/R$ multiplied by the surface metric factor.\n\nStarting point and constraints:\n- Begin from the definition of the magnetostatic vector potential $\\mathbf{A}(\\mathbf{r})$ in terms of a surface current density over a surface, and from the geometric definition of an isoparametric quadratic triangular element. Do not assume any specialized singular quadrature formula a priori; the quadrature scheme must be derived from first principles using coordinate transformations and Jacobians.\n- The isoparametric quadratic triangular element is defined by six nodes with quadratic Lagrange shape functions, using barycentric coordinates $L_1=1-\\xi-\\eta$, $L_2=\\xi$, and $L_3=\\eta$. The $6$ shape functions are $N_1=L_1(2L_1-1)$, $N_2=L_2(2L_2-1)$, $N_3=L_3(2L_3-1)$, $N_4=4L_1L_2$, $N_5=4L_2L_3$, and $N_6=4L_3L_1$. The mapping is $\\mathbf{r}(\\xi,\\eta) = \\sum_{i=1}^6 N_i(\\xi,\\eta)\\,\\mathbf{x}_i$, where $\\mathbf{x}_i \\in \\mathbb{R}^3$ are the nodal coordinates.\n- The element geometry is constructed by sampling a curved surface given implicitly by $z = \\epsilon (x^2 + y^2)$ at the six node locations of the triangle with planar $(x,y)$-coordinates at $(0,0)$, $(1,0)$, $(0,1)$ for the three vertices and $(\\tfrac{1}{2},0)$, $(\\tfrac{1}{2},\\tfrac{1}{2})$, $(0,\\tfrac{1}{2})$ for the mid-edge nodes. The $z$-coordinates follow from the given surface formula.\n\nYour tasks:\n1) Derive a principled quadrature scheme that evaluates $I(\\mathbf{r}_\\mathrm{p})$ accurately when $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ is strictly inside the reference triangle $T$. Your derivation must start from the integral definition above and fundamental geometric transformations. Explain why the singularity is integrable and how your chosen change of variables regularizes the integrand.\n2) Implement the scheme as a program that constructs the curved element from the specified nodes and computes $I(\\mathbf{r}_\\mathrm{p})$ for given $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$. Your algorithm must be applicable to general on-element points $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$.\n3) For verification, implement a high-accuracy reference by the same approach but with significantly higher polynomial quadrature order, and report the absolute error of your proposed practical-order quadrature relative to the high-accuracy reference.\n\nAssume arbitrary consistent units for geometry; all outputs are pure numbers without units.\n\nTest suite:\nYou must evaluate the integral for the following four cases, each defined by curvature parameter $\\epsilon$ and on-element parametric point $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$:\n- Case $1$: $\\epsilon = 0.2$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.3, 0.4)$.\n- Case $2$: $\\epsilon = 0.2$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (10^{-6}, 10^{-6})$.\n- Case $3$: $\\epsilon = 10^{-3}$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.3, 0.4)$.\n- Case $4$: $\\epsilon = 0.5$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.2, 0.2)$.\n\nNumerical specification:\n- Use Gaussian quadrature of order $q$ in each of two scalar variables introduced by your transformation for the practical scheme, and $q_\\mathrm{ref}$ for the high-accuracy reference. For the purposes of this problem, use $q=12$ and $q_\\mathrm{ref}=50$.\n- For each case, compute the absolute error $|I_q - I_{q_\\mathrm{ref}}|$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of the four absolute errors, enclosed in square brackets, in the order of Cases $1$ through $4$ (for example, \"[e1,e2,e3,e4]\").", "solution": "The problem requires the design, justification, and implementation of a numerical quadrature scheme to evaluate a weakly singular integral arising in computational electromagnetics. The integral represents a simplified scalar version of the magnetostatic vector potential generated by a current density on a curved surface element.\n\nThe integral to be evaluated is:\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{T} \\frac{1}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|} \\, \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi}(\\xi,\\eta) \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta}(\\xi,\\eta) \\right\\| \\, d\\xi \\, d\\eta\n$$\nwhere $T = \\{(\\xi,\\eta)\\,|\\,\\xi \\ge 0, \\eta \\ge 0, \\xi+\\eta \\le 1\\}$ is the standard reference triangle. The mapping $\\mathbf{r}(\\xi,\\eta)$ describes a curved quadratic isoparametric triangular element, and $\\mathbf{r}_\\mathrm{p}=\\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ is a point on this element, making it the source of the singularity. The term $R = \\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|$ is the Euclidean distance between the field point $\\mathbf{r}(\\xi,\\eta)$ and the source point $\\mathbf{r}_\\mathrm{p}$. As $(\\xi,\\eta) \\to (\\xi_\\mathrm{p},\\eta_\\mathrm{p})$, $R \\to 0$, and the integrand becomes singular.\n\nLet us define the surface element Jacobian as $J_S(\\xi,\\eta) = \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta} \\right\\|$. The integral is thus:\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{T} \\frac{J_S(\\xi,\\eta)}{R(\\xi,\\eta)} \\, d\\xi \\, d\\eta\n$$\n\nThe singularity is termed \"weak\" because, in the vicinity of the singular point $(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$, the distance $R$ behaves linearly with the distance in the parameter plane. Let $\\tilde{\\xi} = \\xi - \\xi_\\mathrm{p}$ and $\\tilde{\\eta} = \\eta - \\eta_\\mathrm{p}$. A first-order Taylor expansion of $\\mathbf{r}(\\xi,\\eta)$ around $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ gives:\n$$\n\\mathbf{r}(\\xi,\\eta) \\approx \\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) + \\frac{\\partial \\mathbf{r}}{\\partial \\xi}\\bigg|_{p} \\tilde{\\xi} + \\frac{\\partial \\mathbf{r}}{\\partial \\eta}\\bigg|_{p} \\tilde{\\eta}\n$$\nTherefore, $R = \\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{r}_\\mathrm{p}\\| \\approx \\|\\mathbf{r}_\\xi \\tilde{\\xi} + \\mathbf{r}_\\eta \\tilde{\\eta}\\|$. Since $\\mathbf{r}_\\xi$ and $\\mathbf{r}_\\eta$ are linearly independent vectors for a non-degenerate surface patch, $R$ is proportional to the radial distance $\\rho = \\sqrt{\\tilde{\\xi}^2+\\tilde{\\eta}^2}$ in the parametric plane. The integral locally behaves like $\\int \\frac{1}{\\rho} \\rho \\, d\\rho \\, d\\theta$ in polar coordinates, which is regular. This confirms the singularity is integrable. Standard quadrature methods, however, would fail to provide accurate results due to the large, sharp variation of the integrand.\n\nThe problem states that a specialized quadrature formula cannot be assumed, but must be derived from first principles using coordinate transformations. The appropriate technique is to apply a transformation that regularizes the integrand. This is achieved by introducing a new coordinate system centered at the singular point $(\\xi_\\mathrmp, \\eta_\\mathrmp)$, which effectively transforms the singularity into a form that is cancelled by the Jacobian of the transformation.\n\nThe procedure is as follows:\n1.  **Decomposition of the Domain**: The reference triangle $T$, with vertices $V_1=(0,0)$, $V_2=(1,0)$, and $V_3=(0,1)$, is subdivided into three smaller triangles, using the singular point $P=(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ as a common vertex. The three sub-triangles are $T_1 = \\triangle V_1V_2P$, $T_2 = \\triangle V_2V_3P$, and $T_3 = \\triangle V_3V_1P$. The total integral is the sum of the integrals over these three sub-triangles: $I = I_1 + I_2 + I_3$.\n\n2.  **Coordinate Transformation**: For each sub-triangle, say $T_k$ with vertices $A$, $B$, and $P$, we introduce a transformation from the unit square $(u,v) \\in [0,1]\\times[0,1]$ to the triangle $T_k$. Any point $(\\xi,\\eta)$ in $T_k$ can be parameterized as:\n    $$\n    (\\xi(u,v), \\eta(u,v)) = P + u \\cdot ((1-v)A + vB - P)\n    $$\n    Here, $u$ acts as a radial scaling factor from the singular vertex $P$ ($u=0$ corresponds to $P$), and $v$ parameterizes the base of the triangle formed by $A$, $B$, and $P$.\n\n3.  **Jacobian of the Transformation**: The differential area element transforms as $d\\xi d\\eta = |J_{uv}| du dv$. The Jacobian of this mapping is:\n    $$\n    J_{uv} = \\det\\left(\\frac{\\partial(\\xi,\\eta)}{\\partial(u,v)}\\right) = \\det \\begin{pmatrix} \\partial\\xi/\\partial u & \\partial\\xi/\\partial v \\\\ \\partial\\eta/\\partial u & \\partial\\eta/\\partial v \\end{pmatrix}\n    $$\n    Computing the partial derivatives:\n    $$\n    \\frac{\\partial}{\\partial u}(\\xi, \\eta) = (1-v)A + vB - P\n    $$\n    $$\n    \\frac{\\partial}{\\partial v}(\\xi, \\eta) = u(B-A)\n    $$\n    The determinant is then:\n    $$\n    J_{uv} = \\det\\begin{pmatrix} (1-v)A_x+vB_x-P_x & u(B_x-A_x) \\\\ (1-v)A_y+vB_y-P_y & u(B_y-A_y) \\end{pmatrix} = u \\cdot \\det(A-P, B-P)\n    $$\n    The term $\\det(A-P, B-P)$ is twice the signed area of the triangle $\\triangle ABP$. Thus, $|J_{uv}| = u \\cdot 2 \\cdot \\text{Area}(\\triangle ABP)$. The critical feature of this Jacobian is the linear factor of $u$.\n\n4.  **Regularization**: Substituting this into the integral over sub-triangle $T_k$:\n    $$\n    I_k = \\iint_{T_k} \\frac{J_S(\\xi,\\eta)}{R(\\xi,\\eta)} \\, d\\xi d\\eta = \\int_0^1 \\int_0^1 \\frac{J_S(\\xi(u,v), \\eta(u,v))}{R(\\xi(u,v), \\eta(u,v))} |J_{uv}| \\, du dv\n    $$\n    As $u \\to 0$, we have $(\\xi,\\eta) \\to P$, and $R \\approx c(v) \\cdot u$ for some function $c(v) > 0$. The integrand becomes:\n    $$\n    \\frac{J_S(\\dots)}{c(v) \\cdot u} \\cdot (u \\cdot 2\\cdot \\text{Area}(\\triangle ABP)) = \\frac{J_S(\\dots) \\cdot 2\\cdot \\text{Area}(\\triangle ABP)}{c(v)}\n    $$\n    The factor of $u$ from the transformation Jacobian exactly cancels the $1/R \\sim 1/u$ singularity. The resulting integrand is regular over the unit square $[0,1]^2$.\n\n5.  **Numerical Quadrature**: The regularized integral over the unit square can now be accurately evaluated using a standard tensor-product Gaussian quadrature rule. For an order-$q$ rule in each dimension, the integral is approximated as:\n    $$\n    I_k \\approx \\sum_{i=1}^q \\sum_{j=1}^q w_i w_j F_k(u_i, v_j)\n    $$\n    where $(u_i, w_i)$ and $(v_j, w_j)$ are the 1D Gauss-Legendre quadrature points and weights scaled to the interval $[0,1]$, and $F_k(u,v)$ is the transformed regular integrand.\n\nThe total integral $I$ is the sum of the results from the three sub-triangles. This derived scheme is robust for any singular point $(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ strictly inside the reference triangle. The implementation will construct the element geometry, perform the described transformation for each sub-triangle, and compute the integral using high-order Gaussian quadrature. Verification is done by comparing a practical-order quadrature ($q=12$) with a high-accuracy reference ($q_{\\mathrm{ref}}=50$).", "answer": "```python\nimport numpy as np\n\n# This program implements a singular quadrature scheme based on coordinate\n# transformation to evaluate weakly singular 1/R integrals over a curved\n# quadratic triangular element. The scheme is validated by comparing its\n# results against a high-accuracy reference computation.\n\ndef create_nodes(epsilon):\n    \"\"\"\n    Creates the 6 nodal coordinates of the curved quadratic triangle.\n    The geometry is defined by projecting points from a planar triangle\n    onto the surface z = epsilon * (x^2 + y^2).\n    \"\"\"\n    xy_coords = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.0, 1.0],  # Vertices (Nodes 1, 2, 3)\n        [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]   # Midside nodes (Nodes 4, 5, 6)\n    ], dtype=np.float64)\n    z_coords = epsilon * (xy_coords[:, 0]**2 + xy_coords[:, 1]**2)\n    nodes = np.hstack([xy_coords, z_coords[:, np.newaxis]])\n    return nodes\n\nclass IsoparametricQuadraticTriangle:\n    \"\"\"\n    Handles geometric mappings and derivatives for a 6-node quadratic triangle.\n    \"\"\"\n    def __init__(self, nodes):\n        self.nodes = nodes\n\n    def shape_functions(self, xi, eta):\n        L = np.empty((3,) + xi.shape, dtype=np.float64)\n        L[0] = 1.0 - xi - eta\n        L[1] = xi\n        L[2] = eta\n        \n        N = np.empty((6,) + xi.shape, dtype=np.float64)\n        N[0] = L[0] * (2 * L[0] - 1)\n        N[1] = L[1] * (2 * L[1] - 1)\n        N[2] = L[2] * (2 * L[2] - 1)\n        N[3] = 4 * L[0] * L[1]\n        N[4] = 4 * L[1] * L[2]\n        N[5] = 4 * L[2] * L[0]\n        return N\n\n    def shape_function_derivatives(self, xi, eta):\n        L = np.empty((3,) + xi.shape, dtype=np.float64)\n        L[0] = 1.0 - xi - eta\n        L[1] = xi\n        L[2] = eta\n\n        dN_dxi = np.empty((6,) + xi.shape, dtype=np.float64)\n        dN_deta = np.empty((6,) + xi.shape, dtype=np.float64)\n        \n        dN_dxi[0] = -1.0 * (4 * L[0] - 1)\n        dN_dxi[1] = (4 * L[1] - 1)\n        dN_dxi[2] = 0.0\n        dN_dxi[3] = 4 * (L[0] - L[1])\n        dN_dxi[4] = 4 * L[2]\n        dN_dxi[5] = -4 * L[2]\n\n        dN_deta[0] = -1.0 * (4 * L[0] - 1)\n        dN_deta[1] = 0.0\n        dN_deta[2] = (4 * L[2] - 1)\n        dN_deta[3] = -4 * L[1]\n        dN_deta[4] = 4 * L[1]\n        dN_deta[5] = 4 * (L[0] - L[2])\n        \n        # Stack into a (2, 6, ...) array for dN/dxi, dN/deta\n        return np.stack([dN_dxi, dN_deta], axis=0)\n\n    def map_to_surface(self, xi, eta):\n        N = self.shape_functions(xi, eta)\n        return np.tensordot(N, self.nodes, axes=([0], [0]))\n\n    def surface_derivatives(self, xi, eta):\n        dN_d_param = self.shape_function_derivatives(xi, eta)\n        r_derivs = np.tensordot(dN_d_param, self.nodes, axes=([1], [0]))\n        r_xi = r_derivs[0]\n        r_eta = r_derivs[1]\n        return r_xi, r_eta\n\ndef compute_singular_integral(element, xi_p, eta_p, q_order):\n    \"\"\"\n    Computes the singular integral using the derived transformation method.\n    \"\"\"\n    gp, gw = np.polynomial.legendre.leggauss(q_order)\n    # Scale points and weights to [0, 1]\n    u_pts = 0.5 * (gp + 1)\n    v_pts = 0.5 * (gp + 1)\n    u_wts = 0.5 * gw\n    v_wts = 0.5 * gw\n\n    U, V = np.meshgrid(u_pts, v_pts)\n    W_U, W_V = np.meshgrid(u_wts, v_wts)\n    Weights = W_U * W_V\n\n    r_p = element.map_to_surface(np.array(xi_p), np.array(eta_p))\n\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.0])\n    V3 = np.array([0.0, 1.0])\n    P = np.array([xi_p, eta_p])\n\n    sub_triangles = [(V1, V2, P), (V2, V3, P), (V3, V1, P)]\n    total_integral = 0.0\n\n    r_p_xi, r_p_eta = element.surface_derivatives(np.array(xi_p), np.array(eta_p))\n    \n    for A, B, P_vert in sub_triangles:\n        # Jacobian of the (u,v) -> (xi,eta) transformation\n        J_uv_factor = np.linalg.det(np.array([A - P_vert, B - P_vert]))\n\n        # Parametric mapping from (U,V) to (xi, eta)\n        d_vec = (B - A)[:, np.newaxis, np.newaxis] \\\n                * V[np.newaxis, :, :] + (A - P_vert)[:, np.newaxis, np.newaxis]\n        \n        xi = P_vert[0] + U * d_vec[0]\n        eta = P_vert[1] + U * d_vec[1]\n        \n        r = element.map_to_surface(xi, eta)\n        r_xi, r_eta = element.surface_derivatives(xi, eta)\n\n        dist_R = np.linalg.norm(r - r_p, axis=-1)\n        surface_jacobian = np.linalg.norm(np.cross(r_xi, r_eta, axis=-1), axis=-1)\n\n        # Regularize the u/R term, especially for u -> 0\n        u_over_R = np.zeros_like(U)\n        \n        # Analytical limit for u -> 0\n        d_vec_v = (B - A)[:, np.newaxis] * v_pts[np.newaxis, :] + (A-P_vert)[:, np.newaxis]\n        limit_denom = np.linalg.norm(r_p_xi[np.newaxis,:] * d_vec_v[0,:,np.newaxis] + \\\n                                     r_p_eta[np.newaxis,:] * d_vec_v[1,:,np.newaxis], axis=-1)\n        limit_val = 1.0 / limit_denom\n        limit_val = np.tile(limit_val, (q_order, 1)) # Match shape of U\n\n        # Use analytical limit where u is very small, otherwise direct computation.\n        # leguass points are > 0 but can be close.\n        mask = U < 1e-12\n        u_over_R[mask] = limit_val[mask]\n        u_over_R[~mask] = U[~mask] / dist_R[~mask]\n\n        transformed_integrand = surface_jacobian * u_over_R * abs(J_uv_factor)\n        \n        sub_integral = np.sum(transformed_integrand * Weights)\n        total_integral += sub_integral\n\n    return total_integral\n\n\ndef solve():\n    test_cases = [\n        {'epsilon': 0.2, 'xi_p': 0.3, 'eta_p': 0.4},\n        {'epsilon': 0.2, 'xi_p': 1e-6, 'eta_p': 1e-6},\n        {'epsilon': 1e-3, 'xi_p': 0.3, 'eta_p': 0.4},\n        {'epsilon': 0.5, 'xi_p': 0.2, 'eta_p': 0.2},\n    ]\n\n    q_practical = 12\n    q_ref = 50\n    abs_errors = []\n\n    for case in test_cases:\n        epsilon = case['epsilon']\n        xi_p = case['xi_p']\n        eta_p = case['eta_p']\n        \n        nodes = create_nodes(epsilon)\n        element = IsoparametricQuadraticTriangle(nodes)\n\n        I_practical = compute_singular_integral(element, xi_p, eta_p, q_practical)\n        I_ref = compute_singular_integral(element, xi_p, eta_p, q_ref)\n        \n        abs_errors.append(abs(I_practical - I_ref))\n    \n    # Format output as specified\n    print(f\"[{','.join(f'{err:.10e}' for err in abs_errors)}]\")\n\nsolve()\n```", "id": "3346287"}]}