{"hands_on_practices": [{"introduction": "Before we can analyze the quality of a grid, we must first understand its fundamental geometric properties. In structured-grid methods, complex physical domains are mapped from simple computational spaces, such as a unit cube. This practice [@problem_id:3326712] challenges you to derive the essential geometric quantities of a grid cell, such as face area vectors and cell volume, directly from the mathematical mapping function. By working from first principles of differential geometry, you will build a solid understanding of concepts like covariant and contravariant base vectors and the crucial role of the Jacobian determinant, which forms the bedrock of finite volume discretizations on curvilinear grids.", "problem": "A curvilinear hexahedral control volume in Computational Fluid Dynamics (CFD) is defined by a smooth, one-to-one mapping $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ from the unit computational cube $\\{(\\xi,\\eta,\\zeta)\\,|\\,0 \\le \\xi \\le 1,\\,0 \\le \\eta \\le 1,\\,0 \\le \\zeta \\le 1\\}$ to physical space. Starting from the fundamental definition of a differentiable mapping $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ and the differential geometric identities for line, area, and volume elements, derive the covariant base vectors $\\boldsymbol{g}_{\\xi}$, $\\boldsymbol{g}_{\\eta}$, $\\boldsymbol{g}_{\\zeta}$ and the contravariant base vectors $\\boldsymbol{g}^{\\xi}$, $\\boldsymbol{g}^{\\eta}$, $\\boldsymbol{g}^{\\zeta}$, and express the oriented face area vectors (for faces at constant $\\xi$, $\\eta$, and $\\zeta$) and the cell volume in terms of the Jacobian $J$ and metric coefficients. Your derivation must proceed from the definitions of the differential mapping and dual bases, not from pre-stated formulas.\n\nThen, for the specific mapping\n$$\n\\begin{aligned}\nx(\\xi,\\eta,\\zeta) &= \\big(L_{x} + \\alpha\\,\\eta\\big)\\,\\xi,\\\\\ny(\\xi,\\eta,\\zeta) &= \\big(L_{y} + \\beta\\,\\xi\\big)\\,\\eta + \\gamma\\,\\xi\\,\\zeta,\\\\\nz(\\xi,\\eta,\\zeta) &= L_{z}\\,\\zeta + \\delta\\,\\eta\\,\\zeta,\n\\end{aligned}\n$$\nwith constants $L_{x} = 2$, $L_{y} = 1.5$, $L_{z} = 1.2$, $\\alpha = 0.4$, $\\beta = 0.2$, $\\gamma = 0.3$, and $\\delta = 0.1$ (all lengths in meters), compute the total physical volume of the control volume,\n$$\nV \\;=\\; \\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} J(\\xi,\\eta,\\zeta)\\,d\\xi\\,d\\eta\\,d\\zeta,\n$$\nwhere $J(\\xi,\\eta,\\zeta)$ is the Jacobian determinant of the mapping. Round your final numerical answer for $V$ to four significant figures. Express the final volume in $\\mathrm{m}^{3}$.", "solution": "The fundamental base for curvilinear grids is the differentiable mapping $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ and the associated differential geometry of coordinate transformations. The differential displacement in physical space is\n$$\nd\\boldsymbol{x} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\,d\\xi \\;+\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\,d\\eta \\;+\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\,d\\zeta.\n$$\nBy definition, the covariant base vectors are\n$$\n\\boldsymbol{g}_{\\xi} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi},\\qquad\n\\boldsymbol{g}_{\\eta} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\eta},\\qquad\n\\boldsymbol{g}_{\\zeta} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}.\n$$\nThe covariant metric tensor has coefficients $g_{ij} = \\boldsymbol{g}_{i}\\cdot\\boldsymbol{g}_{j}$ for $i,j \\in \\{\\xi,\\eta,\\zeta\\}$, and the Jacobian determinant is the scalar triple product\n$$\nJ \\;=\\; \\boldsymbol{g}_{\\xi}\\cdot\\left(\\boldsymbol{g}_{\\eta}\\times\\boldsymbol{g}_{\\zeta}\\right).\n$$\nThe contravariant base vectors are defined as the dual basis satisfying $\\boldsymbol{g}^{i}\\cdot\\boldsymbol{g}_{j} = \\delta^{i}_{j}$, where $\\delta^{i}_{j}$ is the Kronecker delta. From the properties of the scalar triple product and dual bases, one obtains\n$$\n\\boldsymbol{g}^{\\xi} \\;=\\; \\frac{\\boldsymbol{g}_{\\eta}\\times\\boldsymbol{g}_{\\zeta}}{J},\\qquad\n\\boldsymbol{g}^{\\eta} \\;=\\; \\frac{\\boldsymbol{g}_{\\zeta}\\times\\boldsymbol{g}_{\\xi}}{J},\\qquad\n\\boldsymbol{g}^{\\zeta} \\;=\\; \\frac{\\boldsymbol{g}_{\\xi}\\times\\boldsymbol{g}_{\\eta}}{J}.\n$$\nThe oriented area vector of a surface element is given by the cross product of the tangent covariant base vectors spanning the surface. Therefore, for faces at constant computational coordinate, the oriented area vectors are\n$$\nd\\boldsymbol{S}_{\\xi} \\;=\\; \\boldsymbol{g}_{\\eta}\\times\\boldsymbol{g}_{\\zeta}\\;d\\eta\\,d\\zeta \\;=\\; J\\,\\boldsymbol{g}^{\\xi}\\;d\\eta\\,d\\zeta,\n$$\n$$\nd\\boldsymbol{S}_{\\eta} \\;=\\; \\boldsymbol{g}_{\\zeta}\\times\\boldsymbol{g}_{\\xi}\\;d\\zeta\\,d\\xi \\;=\\; J\\,\\boldsymbol{g}^{\\eta}\\;d\\zeta\\,d\\xi,\n$$\n$$\nd\\boldsymbol{S}_{\\zeta} \\;=\\; \\boldsymbol{g}_{\\xi}\\times\\boldsymbol{g}_{\\eta}\\;d\\xi\\,d\\eta \\;=\\; J\\,\\boldsymbol{g}^{\\zeta}\\;d\\xi\\,d\\eta.\n$$\nThe differential volume element follows from the scalar triple product:\n$$\ndV \\;=\\; \\left(\\boldsymbol{g}_{\\xi}\\cdot\\left(\\boldsymbol{g}_{\\eta}\\times\\boldsymbol{g}_{\\zeta}\\right)\\right)\\,d\\xi\\,d\\eta\\,d\\zeta \\;=\\; J\\,d\\xi\\,d\\eta\\,d\\zeta,\n$$\nand the total cell volume is $V = \\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} J(\\xi,\\eta,\\zeta)\\,d\\xi\\,d\\eta\\,d\\zeta$.\n\nWe now apply these definitions to the given mapping. Write\n$$\nx(\\xi,\\eta,\\zeta) \\;=\\; \\big(L_{x} + \\alpha\\,\\eta\\big)\\,\\xi, \\quad\ny(\\xi,\\eta,\\zeta) \\;=\\; \\big(L_{y} + \\beta\\,\\xi\\big)\\,\\eta \\;+\\; \\gamma\\,\\xi\\,\\zeta, \\quad\nz(\\xi,\\eta,\\zeta) \\;=\\; L_{z}\\,\\zeta \\;+\\; \\delta\\,\\eta\\,\\zeta.\n$$\nThe covariant base vectors are\n$$\n\\boldsymbol{g}_{\\xi} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\n\\;=\\; \\left(\\frac{\\partial x}{\\partial \\xi},\\,\\frac{\\partial y}{\\partial \\xi},\\,\\frac{\\partial z}{\\partial \\xi}\\right)\n\\;=\\; \\left(L_{x} + \\alpha\\,\\eta,\\,\\beta\\,\\eta + \\gamma\\,\\zeta,\\,0\\right),\n$$\n$$\n\\boldsymbol{g}_{\\eta} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\n\\;=\\; \\left(\\alpha\\,\\xi,\\,L_{y} + \\beta\\,\\xi,\\,\\delta\\,\\zeta\\right),\n$$\n$$\n\\boldsymbol{g}_{\\zeta} \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\n\\;=\\; \\left(0,\\,\\gamma\\,\\xi,\\,L_{z} + \\delta\\,\\eta\\right).\n$$\nThe Jacobian is the scalar triple product\n$$\nJ(\\xi,\\eta,\\zeta)\n\\;=\\; \\boldsymbol{g}_{\\xi}\\cdot\\left(\\boldsymbol{g}_{\\eta}\\times\\boldsymbol{g}_{\\zeta}\\right)\n\\;=\\; \\det\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial x}{\\partial \\zeta}\\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\zeta}\\\\[4pt]\n\\frac{\\partial z}{\\partial \\xi} & \\frac{\\partial z}{\\partial \\eta} & \\frac{\\partial z}{\\partial \\zeta}\n\\end{pmatrix}.\n$$\nComputing the determinant explicitly using the previously obtained partial derivatives gives\n$$\nJ(\\xi,\\eta,\\zeta)\n\\;=\\; \\big(L_{x} + \\alpha\\,\\eta\\big)\\Big(\\big(L_{y} + \\beta\\,\\xi\\big)\\big(L_{z} + \\delta\\,\\eta\\big) - \\gamma\\,\\xi\\,\\delta\\,\\zeta\\Big)\n\\;-\\; \\alpha\\,\\xi\\Big(\\big(\\beta\\,\\eta + \\gamma\\,\\zeta\\big)\\big(L_{z} + \\delta\\,\\eta\\big)\\Big).\n$$\nSubstituting the given constants $L_{x} = 2$, $L_{y} = 1.5$, $L_{z} = 1.2$, $\\alpha = 0.4$, $\\beta = 0.2$, $\\gamma = 0.3$, $\\delta = 0.1$, we obtain\n$$\nJ(\\xi,\\eta,\\zeta)\n\\;=\\; \\big(2 + 0.4\\,\\eta\\big)\\Big(\\big(1.5 + 0.2\\,\\xi\\big)\\big(1.2 + 0.1\\,\\eta\\big) - 0.03\\,\\xi\\,\\zeta\\Big)\n\\;-\\; 0.4\\,\\xi\\Big(\\big(0.2\\,\\eta + 0.3\\,\\zeta\\big)\\big(1.2 + 0.1\\,\\eta\\big)\\Big).\n$$\nExpanding and simplifying yields the polynomial\n$$\nJ(\\xi,\\eta,\\zeta)\n\\;=\\; 3.6 \\;+\\; 1.02\\,\\eta \\;+\\; 0.06\\,\\eta^{2} \\;+\\; 0.48\\,\\xi \\;+\\; 0.040\\,\\xi\\,\\eta \\;-\\; 0.204\\,\\xi\\,\\zeta \\;-\\; 0.024\\,\\xi\\,\\eta\\,\\zeta.\n$$\nThe total volume is\n$$\nV \\;=\\; \\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} J(\\xi,\\eta,\\zeta)\\,d\\zeta\\,d\\eta\\,d\\xi.\n$$\nIntegrate first with respect to $\\zeta$:\n$$\n\\int_{0}^{1} J(\\xi,\\eta,\\zeta)\\,d\\zeta\n\\;=\\; 3.6 \\;+\\; 1.02\\,\\eta \\;+\\; 0.06\\,\\eta^{2} \\;+\\; 0.48\\,\\xi \\;+\\; 0.040\\,\\xi\\,\\eta \\;-\\; 0.102\\,\\xi \\;-\\; 0.012\\,\\xi\\,\\eta,\n$$\nwhich simplifies to\n$$\n3.6 \\;+\\; 1.02\\,\\eta \\;+\\; 0.06\\,\\eta^{2} \\;+\\; 0.378\\,\\xi \\;+\\; 0.028\\,\\xi\\,\\eta.\n$$\nIntegrate next with respect to $\\eta$ on $[0,1]$:\n$$\n\\int_{0}^{1}\\Big(3.6 \\;+\\; 1.02\\,\\eta \\;+\\; 0.06\\,\\eta^{2} \\;+\\; 0.378\\,\\xi \\;+\\; 0.028\\,\\xi\\,\\eta\\Big)\\,d\\eta\n\\;=\\; 3.6 \\;+\\; 0.51 \\;+\\; 0.02 \\;+\\; 0.378\\,\\xi \\;+\\; 0.014\\,\\xi,\n$$\nwhich simplifies to\n$$\n4.13 \\;+\\; 0.392\\,\\xi.\n$$\nFinally, integrate with respect to $\\xi$ on $[0,1]$:\n$$\nV \\;=\\; \\int_{0}^{1} \\big(4.13 + 0.392\\,\\xi\\big)\\,d\\xi \\;=\\; 4.13 \\;+\\; \\frac{0.392}{2} \\;=\\; 4.13 \\;+\\; 0.196 \\;=\\; 4.326.\n$$\nTherefore, the physical volume of the control volume is $4.326$ in $\\mathrm{m}^{3}$. Rounded to four significant figures, this remains $4.326$.", "answer": "$$\\boxed{4.326}$$", "id": "3326712"}, {"introduction": "While the geometry of a single cell is fundamental, a CFD simulation involves thousands or millions of interconnected cells forming a mesh. This hands-on coding practice [@problem_id:3326657] shifts the focus from a single analytical mapping to the algorithmic processing of a complete 2D unstructured mesh. You will develop an algorithm to compute essential grid quality metrics like orthogonality, aspect ratio, and skewness from raw connectivity data, and more importantly, to verify the geometric consistency of the entire mesh using a discrete form of the divergence theorem. This exercise provides a crucial bridge between theoretical geometry and the practical realities of CFD code development.", "problem": "You are given planar cell connectivities of a two-dimensional mesh in compressed sparse row form and Cartesian coordinates of points in meters. Each cell is a simple polygon whose vertices are listed in either counterclockwise or clockwise order. A face in two dimensions is an edge of a polygon. From first principles of Euclidean geometry and the divergence theorem, design and implement an algorithm that, for each cell, constructs outward unit normals for each face in a manner that is consistent across cells sharing faces, and verifies orientation consistency via a closed-loop test. Additionally, compute grid quality metrics tied to these normals: a per-cell orthogonality quality and aspect ratio, and a per-face skewness aggregated per cell.\n\nThe algorithm must be derived from the following base principles and definitions:\n\n- The mesh lies in the Cartesian plane $\\mathbb{R}^2$ and all coordinates are specified in meters.\n- A cell $c$ with vertices $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_{m-1}\\}$ defines faces as line segments between successive vertices with wrap-around, i.e., $(\\mathbf{x}_i, \\mathbf{x}_{i+1 \\bmod m})$.\n- The signed area $A_c$ of a polygon is given by the shoelace formula, which determines orientation: $$A_c = \\frac{1}{2}\\sum_{i=0}^{m-1} \\left(x_i y_{i+1 \\bmod m} - x_{i+1 \\bmod m} y_i\\right).$$ A strictly positive $A_c$ implies counterclockwise ordering, and a strictly negative $A_c$ implies clockwise ordering.\n- For an edge vector $\\mathbf{e}_i = \\mathbf{x}_{i+1 \\bmod m} - \\mathbf{x}_i$ with Euclidean length $L_i = \\|\\mathbf{e}_i\\|$, the outward unit normal $\\mathbf{n}_i$ is obtained by a $\\pm 90^\\circ$ rotation of $\\mathbf{e}_i$ followed by normalization. For a counterclockwise-ordered cell, the outward normal is the $-90^\\circ$ rotation, and for a clockwise-ordered cell, the outward normal is the $+90^\\circ$ rotation.\n- The divergence theorem in two dimensions (Greenâ€“Gauss theorem) implies for a closed polygon $\\Omega$ with boundary $\\partial \\Omega$ that $$\\oint_{\\partial \\Omega} \\mathbf{n}\\, ds = \\mathbf{0},$$ where $\\mathbf{n}$ is the outward unit normal and $ds$ is the differential arc length. In the discrete setting for a polygon, this becomes $$\\sum_{i=0}^{m-1} \\mathbf{n}_i\\, L_i = \\mathbf{0}.$$\n- The cell centroid is defined as the arithmetic mean of its vertex coordinates, $$\\mathbf{x}_c = \\frac{1}{m}\\sum_{i=0}^{m-1}\\mathbf{x}_i.$$\n- The face centroid for edge $i$ is the midpoint $$\\mathbf{x}_{f,i} = \\frac{1}{2}\\left(\\mathbf{x}_i + \\mathbf{x}_{i+1 \\bmod m}\\right).$$\n- The orthogonality quality for edge $i$ of cell $c$ is $$q_i = \\frac{\\left|\\left(\\mathbf{x}_{f,i} - \\mathbf{x}_c\\right)\\cdot \\mathbf{n}_i\\right|}{\\left\\|\\mathbf{x}_{f,i} - \\mathbf{x}_c\\right\\|},$$ which lies in $[0,1]$ and quantifies alignment between the centroid-to-face vector and the face normal. A per-cell orthogonality quality is the minimum $q_i$ over all faces, i.e., $$q_c = \\min_i q_i.$$\n- The face skewness for edge $i$ of cell $c$ is defined by the magnitude of the tangential component of the centroid-to-face vector normalized by the local face length, $$s_i = \\frac{\\left\\|\\left(\\mathbf{x}_{f,i} - \\mathbf{x}_c\\right) - \\left(\\left(\\mathbf{x}_{f,i} - \\mathbf{x}_c\\right)\\cdot \\mathbf{n}_i\\right)\\mathbf{n}_i\\right\\|}{L_i}.$$ A per-cell skewness is the maximum $s_i$ over all faces, $$s_c = \\max_i s_i.$$\n- The per-cell aspect ratio is $$\\text{AR}_c = \\frac{\\max_i L_i}{\\min_i L_i}.$$\n\nYou must use the following data representation:\n\n- The points array $P$ is an array of Cartesian coordinates in meters of shape $(N,2)$.\n- The compressed sparse row representation of cell connectivity consists of two integer arrays: $cell\\_ptr$ of length $n\\_cells + 1$ and $cell\\_indices$ of length equal to the total number of vertex references across all cells. For cell $k \\in \\{0,1,\\dots,n\\_cells-1\\}$, the vertex indices of the cell in $P$ are given by the slice $cell\\_indices[cell\\_ptr[k]:cell\\_ptr[k+1]]$.\n\nYour algorithm must perform the following tasks for each test case:\n\n- For each cell, compute outward unit normals $\\mathbf{n}_i$ for all faces using the sign of $A_c$ to select the correct rotation direction.\n- For each cell, perform the closed-loop test by checking that $$\\frac{\\left\\|\\sum_i \\mathbf{n}_i L_i\\right\\|}{\\sum_i L_i} < \\varepsilon,$$ with $\\varepsilon = 10^{-12}$, yielding a boolean per cell. All cells must pass for the test case to report closed-loop consistency as true.\n- For each undirected interior face shared by exactly two cells, verify that the two outward unit normals are opposite, i.e., that $$\\left|\\mathbf{n}^{(a)}\\cdot \\mathbf{n}^{(b)} + 1\\right| < \\delta,$$ with $\\delta = 10^{-12}$, yielding a boolean per shared face. All shared faces must pass for the test case to report orientation consistency as true.\n- Compute the per-cell orthogonality quality $q_c$, aspect ratio $\\text{AR}_c$, and skewness $s_c$, and aggregate per test case as follows: the minimum orthogonality quality across cells, the maximum aspect ratio across cells, and the maximum skewness across cells.\n\nYour program must produce a single line of output containing one entry per test case, where each entry is a list of five values in the order: closed-loop consistency boolean, orientation consistency boolean, minimum orthogonality quality across cells (float), maximum aspect ratio across cells (float), and maximum skewness across cells (float). The output must be a comma-separated list enclosed in square brackets. For example, the output format must look like $[\\,[b_1, b_2, r_1, r_2, r_3],\\,[\\dots],\\,[\\dots]\\,]$ with booleans and floats.\n\nUse the following test suite of meshes defined by point coordinates in meters and CSR arrays:\n\n- Test case $1$ (two adjacent unit squares):\n  - Points $P^{(1)} = \\{(0,0),(1,0),(2,0),(0,1),(1,1),(2,1)\\}$ in meters.\n  - $cell\\_ptr^{(1)} = [0,4,8]$.\n  - $cell\\_indices^{(1)} = [0,1,4,3,1,2,5,4]$.\n\n- Test case $2$ (a slender rectangle adjacent to a triangle, with the rectangle vertices given in clockwise order):\n  - Points $P^{(2)} = \\{(0,0),(2,0),(2,0.2),(0,0.2),(3,0.1)\\}$ in meters.\n  - $cell\\_ptr^{(2)} = [0,4,7]$.\n  - $cell\\_indices^{(2)} = [0,3,2,1,1,4,2]$.\n\n- Test case $3$ (a single concave pentagon):\n  - Points $P^{(3)} = \\{(0,0),(1,0),(0.6,0.3),(1,1),(0,1)\\}$ in meters.\n  - $cell\\_ptr^{(3)} = [0,5]$.\n  - $cell\\_indices^{(3)} = [0,1,2,3,4]$.\n\nAll arrays are $0$-indexed. Angles are not reported, so no angle unit is required in the output. All geometric quantities computed internally must be consistent with the input unit (meters), but the reported orthogonality, aspect ratio, skewness, and relative closed-loop error are dimensionless. Your program must produce the exact single-line output format specified above and must not read external input.", "solution": "The problem requires the design and implementation of an algorithm to compute various geometric properties and quality metrics for a two-dimensional mesh defined by point coordinates and cell connectivity. The algorithm must be derived from first principles of Euclidean geometry and vector calculus, specifically the divergence theorem in two dimensions. The solution proceeds by first validating the problem statement, which is found to be scientifically sound, well-posed, and complete.\n\nThe core of the algorithm involves iterating through each cell of the mesh, and for each cell, iterating through its faces (edges). For each cell, we first determine its orientation (clockwise or counterclockwise) to correctly compute the outward unit normal vectors for each of its faces. These normals are then used for two consistency checks and for the calculation of grid quality metrics.\n\n**1. Cell Processing and Face Information Extraction**\n\nThe mesh is provided in a compressed sparse row (CSR) format, which is efficient for representing sparse connectivities. For each cell $c$, its vertex indices are extracted from the `cell_indices` array using the offsets provided in the `cell_ptr` array. The Cartesian coordinates of these vertices, $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_{m-1}\\}$, are then retrieved from the points array $P$.\n\n**2. Orientation and Outward Normal Calculation**\n\nThe orientation of a cell's vertices is crucial for distinguishing between inward and outward directions. We compute the signed area $A_c$ of the cell polygon using the shoelace formula:\n$$A_c = \\frac{1}{2}\\sum_{i=0}^{m-1} (x_i y_{i+1 \\bmod m} - x_{i+1 \\bmod m} y_i)$$\nA strictly positive area ($A_c > 0$) indicates a counterclockwise (CCW) ordering of vertices, while a strictly negative area ($A_c < 0$) indicates a clockwise (CW) ordering.\n\nFor each face $i$ of the cell, defined by vertices $\\mathbf{x}_i$ and $\\mathbf{x}_{i+1 \\bmod m}$, we define the edge vector $\\mathbf{e}_i = \\mathbf{x}_{i+1 \\bmod m} - \\mathbf{x}_i = (e_{ix}, e_{iy})$. The outward unit normal $\\mathbf{n}_i$ is obtained by rotating $\\mathbf{e}_i$ by $\\pm 90^\\circ$ and normalizing. The direction of rotation depends on the cell's orientation, as specified:\n- For a CCW cell, the outward normal corresponds to a $-90^\\circ$ rotation of the edge vector: the rotated vector is $(e_{iy}, -e_{ix})$.\n- For a CW cell, the outward normal corresponds to a $+90^\\circ$ rotation: the rotated vector is $(-e_{iy}, e_{ix})$.\n\nThe resulting vector is then normalized to unit length: $\\mathbf{n}_i = \\frac{\\mathbf{e}_i^{\\perp}}{\\|\\mathbf{e}_i\\|}$, where $\\mathbf{e}_i^{\\perp}$ is the appropriately rotated vector and $L_i = \\|\\mathbf{e}_i\\|$ is the face length.\n\n**3. Consistency Verification**\n\nTwo types of consistency checks are performed:\n\n- **Closed-Loop Test (per cell)**: The two-dimensional divergence theorem, applied to a constant vector field, implies that for any closed polygon, the sum of outward face normal vectors scaled by face lengths must be the zero vector. Discretely, this is $\\sum_{i=0}^{m-1} \\mathbf{n}_i L_i = \\mathbf{0}$. We verify this for each cell by checking if the relative error is below a small tolerance $\\varepsilon = 10^{-12}$:\n$$ \\frac{\\left\\|\\sum_{i=0}^{m-1} \\mathbf{n}_i L_i\\right\\|}{\\sum_{i=0}^{m-1} L_i} < \\varepsilon $$\nA boolean flag for the entire mesh is set to true only if all cells pass this test.\n\n- **Orientation Consistency Test (for shared faces)**: For the mesh to be valid for computations like those in finite volume methods, the outward normal of a face from one cell must be equal and opposite to the outward normal of the same face from the adjacent cell. To check this, we first identify all unique interior faces. A face can be uniquely identified by a sorted tuple of its vertex indices. We build a map from each unique face to the cells that contain it, along with the corresponding computed outward normals. For each face shared by exactly two cells, say cell $(a)$ and cell $(b)$, we verify that their normals $\\mathbf{n}^{(a)}$ and $\\mathbf{n}^{(b)}$ are anti-parallel. This is checked by ensuring their dot product is close to $-1$:\n$$ \\left|\\mathbf{n}^{(a)} \\cdot \\mathbf{n}^{(b)} + 1\\right| < \\delta $$\nwith a tolerance $\\delta = 10^{-12}$. A global boolean flag is true if all shared faces pass this test. If there are no shared faces, this condition is vacuously true.\n\n**4. Grid Quality Metrics Calculation**\n\nFor each cell $c$, a set of quality metrics is computed based on geometric relationships between the cell centroid, face centroids, and face normals.\n\n- **Cell Centroid and Face Centroids**: The cell centroid $\\mathbf{x}_c$ is the arithmetic mean of its vertex coordinates. The centroid of face $i$, $\\mathbf{x}_{f,i}$, is the midpoint of its vertices.\n\n- **Aspect Ratio ($AR_c$)**: This metric measures the elongation of a cell and is defined as the ratio of the maximum face length to the minimum face length within the cell:\n$$ \\text{AR}_c = \\frac{\\max_i L_i}{\\min_i L_i} $$\n\n- **Orthogonality Quality ($q_c$)**: This metric quantifies how well the vector connecting the cell centroid to a face centroid aligns with the face normal. For each face $i$, the quality $q_i$ is the absolute value of the cosine of the angle between the vector $\\mathbf{v}_i = \\mathbf{x}_{f,i} - \\mathbf{x}_c$ and the normal $\\mathbf{n}_i$:\n$$ q_i = \\frac{\\left|\\mathbf{v}_i \\cdot \\mathbf{n}_i\\right|}{\\left\\|\\mathbf{v}_i\\right\\|} $$\nThe cell's orthogonality quality $q_c$ is the minimum of these values over all its faces, $q_c = \\min_i q_i$. A value of $1$ is ideal.\n\n- **Skewness ($s_c$)**: This metric quantifies the deviation from orthogonality. For each face $i$, skewness $s_i$ is the magnitude of the tangential component of the vector $\\mathbf{v}_i$, normalized by the face length $L_i$. The tangential component is what remains after subtracting the normal component: $\\mathbf{v}_{i, \\text{tan}} = \\mathbf{v}_i - (\\mathbf{v}_i \\cdot \\mathbf{n}_i) \\mathbf{n}_i$.\n$$ s_i = \\frac{\\|\\mathbf{v}_{i, \\text{tan}}\\|}{L_i} $$\nThe cell's skewness $s_c$ is the maximum of these values over all its faces, $s_c = \\max_i s_i$. A value of $0$ is ideal.\n\n**5. Aggregation and Output**\n\nFinally, after processing all cells in a mesh, the results are aggregated for the entire test case: the overall closed-loop consistency boolean, the overall orientation consistency boolean, the minimum orthogonality quality across all cells, the maximum aspect ratio across all cells, and the maximum skewness across all cells. These five values form a list, and the final output is a list of these lists for all test cases, formatted as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to process all test cases and print the final results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"P\": np.array([[0.0, 0.0], [1.0, 0.0], [2.0, 0.0], [0.0, 1.0], [1.0, 1.0], [2.0, 1.0]]),\n            \"cell_ptr\": np.array([0, 4, 8]),\n            \"cell_indices\": np.array([0, 1, 4, 3, 1, 2, 5, 4]),\n        },\n        {\n            \"P\": np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 0.2], [0.0, 0.2], [3.0, 0.1]]),\n            \"cell_ptr\": np.array([0, 4, 7]),\n            \"cell_indices\": np.array([0, 3, 2, 1, 1, 4, 2]),\n        },\n        {\n            \"P\": np.array([[0.0, 0.0], [1.0, 0.0], [0.6, 0.3], [1.0, 1.0], [0.0, 1.0]]),\n            \"cell_ptr\": np.array([0, 5]),\n            \"cell_indices\": np.array([0, 1, 2, 3, 4]),\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_mesh(case[\"P\"], case[\"cell_ptr\"], case[\"cell_indices\"])\n        all_results.append(result)\n\n    # Format the final output string\n    # Using str(list) will produce the required output format, including 'True'/'False' for booleans.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef process_mesh(P, cell_ptr, cell_indices):\n    \"\"\"\n    Processes a single mesh to compute consistency and quality metrics.\n    \"\"\"\n    n_cells = len(cell_ptr) - 1\n    \n    all_cell_closed_loop_ok = []\n    all_cell_orthogonality = []\n    all_cell_aspect_ratio = []\n    all_cell_skewness = []\n    \n    face_map = {}  # Maps face_key -> list of {cell_id, normal}\n\n    eps = 1e-12\n    delta = 1e-12\n\n    for i_cell in range(n_cells):\n        vert_indices = cell_indices[cell_ptr[i_cell]:cell_ptr[i_cell + 1]]\n        verts = P[vert_indices]\n        m = len(verts)\n\n        # 1. Compute signed area to determine orientation\n        x = verts[:, 0]\n        y = verts[:, 1]\n        area = 0.5 * np.sum(x * np.roll(y, -1) - np.roll(x, -1) * y)\n        \n        # Determine rotation for outward normal based on orientation\n        # +1 for CCW (-90 deg rot), -1 for CW (+90 deg rot)\n        orientation_sign = np.sign(area)\n        \n        cell_centroid = np.mean(verts, axis=0)\n        \n        sum_normal_len = np.zeros(2)\n        sum_len = 0.0\n        face_lengths = []\n        face_orthogonalities = []\n        face_skewnesses = []\n\n        for i_face in range(m):\n            p1_idx, p2_idx = vert_indices[i_face], vert_indices[(i_face + 1) % m]\n            p1, p2 = verts[i_face], verts[(i_face + 1) % m]\n            \n            edge_vec = p2 - p1\n            edge_len = np.linalg.norm(edge_vec)\n            face_lengths.append(edge_len)\n\n            if edge_len < eps:\n                # Degenerate face, assign default bad/neutral values\n                face_orthogonalities.append(0.0)\n                face_skewnesses.append(np.inf)\n                continue\n\n            # 2. Compute outward unit normal\n            if orientation_sign > 0:  # CCW\n                normal_vec = np.array([edge_vec[1], -edge_vec[0]])\n            else:  # CW\n                normal_vec = np.array([-edge_vec[1], edge_vec[0]])\n            \n            unit_normal = normal_vec / edge_len\n            \n            # For closed-loop test\n            sum_normal_len += unit_normal * edge_len\n            sum_len += edge_len\n            \n            # Store face info for consistency check\n            face_key = tuple(sorted((p1_idx, p2_idx)))\n            if face_key not in face_map:\n                face_map[face_key] = []\n            face_map[face_key].append({\"cell_id\": i_cell, \"normal\": unit_normal})\n            \n            # 3. Compute quality metrics for the face\n            face_centroid = 0.5 * (p1 + p2)\n            centroid_to_face_vec = face_centroid - cell_centroid\n            ctf_vec_norm = np.linalg.norm(centroid_to_face_vec)\n            \n            if ctf_vec_norm < eps:\n                # Cell centroid coincides with face centroid, perfect orthogonality\n                face_orthogonalities.append(1.0)\n                face_skewnesses.append(0.0)\n                continue\n\n            # Orthogonality\n            ortho = abs(np.dot(centroid_to_face_vec, unit_normal)) / ctf_vec_norm\n            face_orthogonalities.append(ortho)\n\n            # Skewness\n            tangential_vec = centroid_to_face_vec - (np.dot(centroid_to_face_vec, unit_normal) * unit_normal)\n            skew = np.linalg.norm(tangential_vec) / edge_len\n            face_skewnesses.append(skew)\n\n        # 4. Per-cell aggregation\n        if sum_len < eps:\n            all_cell_closed_loop_ok.append(True) # Degenerate cell is trivially closed\n        else:\n            closed_loop_error = np.linalg.norm(sum_normal_len) / sum_len\n            all_cell_closed_loop_ok.append(closed_loop_error < eps)\n\n        min_face_len = np.min(face_lengths) if face_lengths else 0.0\n        max_face_len = np.max(face_lengths) if face_lengths else 0.0\n        \n        aspect_ratio = max_face_len / min_face_len if min_face_len > eps else np.inf\n        all_cell_aspect_ratio.append(aspect_ratio)\n        \n        all_cell_orthogonality.append(np.min(face_orthogonalities) if face_orthogonalities else 0.0)\n        all_cell_skewness.append(np.max(face_skewnesses) if face_skewnesses else np.inf)\n\n    # 5. Final aggregation for the whole mesh\n    \n    # Closed-loop consistency\n    mesh_closed_loop_ok = all(all_cell_closed_loop_ok)\n    \n    # Orientation consistency\n    mesh_orientation_ok = True\n    num_shared_faces = 0\n    for face_key, owners in face_map.items():\n        if len(owners) == 2:\n            num_shared_faces += 1\n            n1 = owners[0][\"normal\"]\n            n2 = owners[1][\"normal\"]\n            if abs(np.dot(n1, n2) + 1.0) >= delta:\n                mesh_orientation_ok = False\n                break\n    if num_shared_faces == 0:\n        mesh_orientation_ok = True # Vacuously true\n\n    min_ortho = np.min(all_cell_orthogonality) if all_cell_orthogonality else 1.0\n    max_ar = np.max(all_cell_aspect_ratio) if all_cell_aspect_ratio else 1.0\n    max_skew = np.max(all_cell_skewness) if all_cell_skewness else 0.0\n    \n    return [mesh_closed_loop_ok, mesh_orientation_ok, min_ortho, max_ar, max_skew]\n\nsolve()\n```", "id": "3326657"}, {"introduction": "Ultimately, the goal of assessing grid quality is to ensure the accuracy and stability of the numerical simulation. This advanced practice [@problem_id:3326707] takes a goal-oriented approach, focusing on designing grids suitable for a specific, demanding application: Large-Eddy Simulation (LES). You will first derive an optimal cell aspect ratio based on the physical properties of the flow, captured by a local anisotropy tensor. Then, by combining this with other standard quality metrics, you will formulate and apply a decision rule to determine if a cell is 'LES-accurate', demonstrating the critical link between grid design, flow physics, and simulation fidelity.", "problem": "You are given a two-dimensional computational mesh comprised of grid entities: points, faces, and cells. Consider a local control volume defined by a convex quadrilateral cell specified by four ordered points in the plane. Let the local flow be characterized by the anisotropy tensor $ \\boldsymbol{E} = \\langle \\nabla \\boldsymbol{u}\\, \\nabla \\boldsymbol{u}^\\top \\rangle $, where $ \\boldsymbol{u} $ is the velocity vector field and $ \\langle \\cdot \\rangle $ denotes an appropriate average over subgrid scales. Assume $ \\boldsymbol{E} $ is symmetric and positive definite. Your task is to derive, implement, and test mesh quality metrics for Large-Eddy Simulation (LES) accuracy.\n\nStarting from first principles of directional truncation error control and the definition of $ \\boldsymbol{E} $, derive an expression for the recommended local aspect ratio $ AR^\\star $ that equalizes relative resolution of directional gradients along the principal axes of $ \\boldsymbol{E} $. Express $ AR^\\star $ in terms of the eigenvalues of $ \\boldsymbol{E} $ and justify the derivation from the base definitions. Do not use any pre-given shortcut formulas.\n\nDefine and implement the following quality metrics for a single convex quadrilateral cell:\n- The actual aspect ratio $ AR $ as the ratio of the longest edge length to the shortest edge length, computed from the ordered vertices $ (x_i, y_i) $ for $ i = 0,1,2,3 $. All coordinates are given in meters, and all distances must be computed in meters.\n- The face orthogonality metric $ O $ computed as follows. For each face $ i $, let the edge vector be $ \\boldsymbol{v}_i $ and the outward unit normal be $ \\boldsymbol{n}_i $ (determined consistently with the polygon orientation). Let the cell centroid be $ \\boldsymbol{c} $ and the face centroid be $ \\boldsymbol{f}_i $. Define the per-face orthogonality as $ \\left| \\boldsymbol{n}_i \\cdot \\dfrac{\\boldsymbol{f}_i - \\boldsymbol{c}}{\\| \\boldsymbol{f}_i - \\boldsymbol{c} \\|} \\right| $. Then take $ O $ as the minimum over all faces. This metric is dimensionless.\n- The skewness metric $ S_{\\mathrm{deg}} $ defined as the maximum deviation, in degrees, of the internal corner angles from $ 90 $ degrees. For a corner at vertex $ i $, the internal angle is the angle between $ -\\boldsymbol{e}_{i-1} $ and $ \\boldsymbol{e}_i $, where $ \\boldsymbol{e}_i $ is the edge vector from vertex $ i $ to $ i+1 $ (indices modulo $ 4 $). Angles must be computed and reported in degrees.\n\nDefine a mathematically precise LES-accuracy decision rule that uses $ AR^\\star $, $ AR $, $ O $, and $ S_{\\mathrm{deg}} $. Specifically, declare a cell LES-accurate if and only if all of the following hold:\n- The relative aspect ratio mismatch $ \\left| AR - AR^\\star \\right| / AR^\\star \\le \\varepsilon_{AR} $, with $ \\varepsilon_{AR} = 0.10 $.\n- The orthogonality metric $ O \\ge O_{\\min} $, with $ O_{\\min} = 0.95 $.\n- The skewness metric $ S_{\\mathrm{deg}} \\le S_{\\max} $, with $ S_{\\max} = 10 $ degrees.\n\nAll computations must be performed in two dimensions. Angles must be handled in degrees. Distances must be handled in meters. Eigenvalues must be computed from $ \\boldsymbol{E} $ using a symmetric-eigen decomposition, and the definition of $ AR^\\star $ must use only quantities derived from $ \\boldsymbol{E} $.\n\nTest Suite:\nProvide a program that evaluates the LES-accuracy decision for the following five test cases. Each test case specifies $ \\boldsymbol{E} $ and the ordered vertices of the quadrilateral cell $ \\{ (x_i, y_i) \\}_{i=0}^3 $ in meters:\n\n- Case $ 1 $ (happy path): $ \\boldsymbol{E} = \\begin{bmatrix} 9 & 0 \\\\ 0 & 1 \\end{bmatrix} $, vertices $ (0,0),(3,0),(3,1),(0,1) $.\n- Case $ 2 $ (isotropic boundary): $ \\boldsymbol{E} = \\begin{bmatrix} 4 & 0 \\\\ 0 & 4 \\end{bmatrix} $, vertices $ (0,0),(1,0),(1,1),(0,1) $.\n- Case $ 3 $ (high anisotropy, insufficient $ AR $): $ \\boldsymbol{E} = \\begin{bmatrix} 25 & 0 \\\\ 0 & 1 \\end{bmatrix} $, vertices $ (0,0),(2,0),(2,1),(0,1) $.\n- Case $ 4 $ (correct $ AR $ but poor orthogonality/skewness): $ \\boldsymbol{E} = \\begin{bmatrix} 9 & 0 \\\\ 0 & 1 \\end{bmatrix} $, vertices $ (0,0),(3,0),(3+\\cos 30^\\circ, \\sin 30^\\circ),(\\cos 30^\\circ, \\sin 30^\\circ) $, where $ 30^\\circ $ is an angle in degrees and the numeric values $ \\cos 30^\\circ = 0.8660254037844386 $ and $ \\sin 30^\\circ = 0.5 $ are to be used.\n- Case $ 5 $ (very high anisotropy, matched $ AR $): $ \\boldsymbol{E} = \\begin{bmatrix} 100 & 0 \\\\ 0 & 1 \\end{bmatrix} $, vertices $ (0,0),(10,0),(10,1),(0,1) $.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the LES-accuracy decisions for the five test cases as a comma-separated list enclosed in square brackets, for example $ [\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5] $, where each $ \\mathrm{result}_i $ is a boolean. The output must contain only this single line.", "solution": "The problem is assessed to be **valid**. It is scientifically grounded in the principles of computational fluid dynamics (CFD), specifically in the area of mesh quality for Large-Eddy Simulation (LES). The problem is well-posed, providing all necessary definitions, data, and constraints to derive and compute a unique solution for each test case. The language is objective and the requirements are mathematically precise.\n\nThe solution proceeds in three stages:\n1.  Derivation of the recommended aspect ratio, $AR^\\star$.\n2.  Definition and formulation of the three required quality metrics: actual aspect ratio ($AR$), orthogonality ($O$), and skewness ($S_{\\mathrm{deg}}$).\n3.  Application of a decision rule based on these metrics to the provided test cases.\n\n### Derivation of Recommended Aspect Ratio ($AR^\\star$)\nThe goal is to derive the recommended local aspect ratio, $AR^\\star$, that equalizes the relative resolution of directional gradients along the principal axes of the anisotropy tensor $\\boldsymbol{E}$.\n\nThe anisotropy tensor $\\boldsymbol{E} = \\langle \\nabla \\boldsymbol{u}\\, \\nabla \\boldsymbol{u}^\\top \\rangle$ is symmetric and positive definite. Its eigenvalues, $\\lambda_i$, represent the mean-squared directional gradients along its principal directions (eigenvectors). Let the principal axes be aligned with a coordinate system $(x_1, x_2)$, and let the corresponding eigenvalues be $\\lambda_1$ and $\\lambda_2$. The magnitude of the gradient fluctuations along these axes can be taken to be proportional to $\\sqrt{\\lambda_1}$ and $\\sqrt{\\lambda_2}$, respectively.\n\nIn numerical methods, the truncation error is a function of the grid spacing and derivatives of the resolved field. For a scheme to be \"equally accurate\" in all directions, the grid resolution should be adapted to the local behavior of the solution. Specifically, the grid should be finer in directions where solution gradients are larger. This principle of \"equidistribution of error\" suggests that the product of the grid spacing, $\\Delta x_i$, and a measure of the solution variation in that direction should be constant.\n\nWe seek to equalize the resolution of gradients. The characteristic length scale of variation along principal direction $i$ is inversely proportional to the gradient magnitude, i.e., $L_i \\propto 1/\\sqrt{\\lambda_i}$. To resolve these structures with comparable accuracy, the number of grid points per characteristic length should be the same in all principal directions. This implies that the grid spacing $\\Delta x_i$ should be proportional to the characteristic length $L_i$.\n$$ \\Delta x_i \\propto \\frac{1}{\\sqrt{\\lambda_i}} $$\nThis leads to the condition that the \"metric-scaled\" cell dimensions are equal:\n$$ \\Delta x_1 \\sqrt{\\lambda_1} = \\Delta x_2 \\sqrt{\\lambda_2} = \\text{constant} $$\nLet's order the eigenvalues such that $\\lambda_{\\max}$ is the largest eigenvalue and $\\lambda_{\\min}$ is the smallest. The direction corresponding to $\\lambda_{\\max}$ has the largest gradients and thus requires the finest resolution, which we denote by a cell dimension $\\Delta x_{\\min}$. The direction corresponding to $\\lambda_{\\min}$ can be resolved with the coarsest resolution, a cell dimension $\\Delta x_{\\max}$.\nFollowing our condition:\n$$ \\Delta x_{\\min} \\sqrt{\\lambda_{\\max}} = \\Delta x_{\\max} \\sqrt{\\lambda_{\\min}} $$\nThe aspect ratio is defined as the ratio of the longest to the shortest dimension. For an optimally aligned cell, this would be $\\frac{\\Delta x_{\\max}}{\\Delta x_{\\min}}$. Rearranging the equation above gives the expression for the recommended aspect ratio, $AR^\\star$:\n$$ AR^\\star = \\frac{\\Delta x_{\\max}}{\\Delta x_{\\min}} = \\frac{\\sqrt{\\lambda_{\\max}}}{\\sqrt{\\lambda_{\\min}}} = \\sqrt{\\frac{\\lambda_{\\max}}{\\lambda_{\\min}}} $$\nThis expression provides the optimal aspect ratio for a cell whose principal axes are aligned with the principal axes of the anisotropy tensor $\\boldsymbol{E}$.\n\n### Mesh Quality Metrics\nThe problem defines three quality metrics for a convex quadrilateral cell given by ordered vertices $\\{\\boldsymbol{p}_0, \\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3\\}$, where $\\boldsymbol{p}_i = (x_i, y_i)$.\n\n1.  **Actual Aspect Ratio ($AR$)**: This is the ratio of the longest edge length to the shortest edge length. The length of edge $i$ (connecting $\\boldsymbol{p}_i$ and $\\boldsymbol{p}_{i+1}$, with indices modulo $4$) is $L_i = \\|\\boldsymbol{p}_{i+1} - \\boldsymbol{p}_i\\|$.\n    $$ AR = \\frac{\\max(L_0, L_1, L_2, L_3)}{\\min(L_0, L_1, L_2, L_3)} $$\n\n2.  **Face Orthogonality Metric ($O$)**: This metric measures how well the vector connecting the cell centroid to a face centroid aligns with the face normal.\n    -   Cell centroid: $\\boldsymbol{c} = \\frac{1}{4} \\sum_{i=0}^{3} \\boldsymbol{p}_i$.\n    -   Face $i$ centroid (midpoint of the edge): $\\boldsymbol{f}_i = \\frac{1}{2}(\\boldsymbol{p}_i + \\boldsymbol{p}_{i+1})$.\n    -   Edge vector for face $i$: $\\boldsymbol{e}_i = \\boldsymbol{p}_{i+1} - \\boldsymbol{p}_i = (e_{ix}, e_{iy})$.\n    -   Outward unit normal $\\boldsymbol{n}_i$: For a counter-clockwise (CCW) ordering of vertices, the outward normal to $\\boldsymbol{e}_i$ is obtained by a $90^\\circ$ clockwise rotation. The normalized vector is $\\boldsymbol{n}_i = \\frac{(e_{iy}, -e_{ix})}{\\|\\boldsymbol{e}_i\\|}$.\n    -   Vector from cell centroid to face centroid: $\\boldsymbol{d}_i = \\boldsymbol{f}_i - \\boldsymbol{c}$.\n    -   Per-face orthogonality: $O_i = \\left| \\boldsymbol{n}_i \\cdot \\frac{\\boldsymbol{d}_i}{\\| \\boldsymbol{d}_i \\|} \\right|$.\n    -   The overall metric is the minimum over all faces: $O = \\min(O_0, O_1, O_2, O_3)$. A value of $1$ indicates perfect orthogonality for all faces.\n\n3.  **Skewness Metric ($S_{\\mathrm{deg}}$)**: This is the maximum deviation of the internal corner angles from $90^\\circ$.\n    -   At each vertex $\\boldsymbol{p}_i$, the internal angle $\\theta_i$ is formed by the vectors pointing to the adjacent vertices, $\\boldsymbol{v}_{i, \\text{prev}} = \\boldsymbol{p}_{i-1} - \\boldsymbol{p}_i$ and $\\boldsymbol{v}_{i, \\text{next}} = \\boldsymbol{p}_{i+1} - \\boldsymbol{p}_i$.\n    -   The angle in radians is given by $\\theta_i = \\arccos\\left(\\frac{\\boldsymbol{v}_{i, \\text{prev}} \\cdot \\boldsymbol{v}_{i, \\text{next}}}{\\|\\boldsymbol{v}_{i, \\text{prev}}\\| \\|\\boldsymbol{v}_{i, \\text{next}}\\|}\\right)$.\n    -   This is converted to degrees: $\\theta_i^{\\mathrm{deg}} = \\theta_i \\times \\frac{180}{\\pi}$.\n    -   The skewness metric is the maximum absolute deviation from $90^\\circ$:\n        $$ S_{\\mathrm{deg}} = \\max_{i \\in \\{0,1,2,3\\}} \\left| \\theta_i^{\\mathrm{deg}} - 90 \\right| $$\n\n### LES-Accuracy Decision Rule\nA cell is declared \"LES-accurate\" if and only if all three of the following conditions are met:\n1.  Relative aspect ratio mismatch: $\\frac{\\left| AR - AR^\\star \\right|}{AR^\\star} \\le \\varepsilon_{AR}$, with $\\varepsilon_{AR} = 0.10$.\n2.  Orthogonality: $O \\ge O_{\\min}$, with $O_{\\min} = 0.95$.\n3.  Skewness: $S_{\\mathrm{deg}} \\le S_{\\max}$, with $S_{\\max} = 10$ degrees.\n\nThe evaluation of the test cases will be performed by computing $AR^\\star$, $AR$, $O$, and $S_{\\mathrm{deg}}$ for each case and applying this decision rule.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_recommended_ar(E):\n    \"\"\"\n    Calculates the recommended aspect ratio AR* from the anisotropy tensor E.\n    AR* = sqrt(lambda_max / lambda_min)\n    \"\"\"\n    # For a symmetric matrix, eigvalsh is efficient and numerically stable\n    eigenvalues = np.linalg.eigvalsh(E)\n    lambda_max = np.max(eigenvalues)\n    lambda_min = np.min(eigenvalues)\n    if lambda_min <= 0:\n        # Avoid division by zero or negative sqrt for non-positive-definite E\n        return np.inf\n    return np.sqrt(lambda_max / lambda_min)\n\ndef calculate_actual_ar(vertices):\n    \"\"\"\n    Calculates the actual aspect ratio AR of a quadrilateral cell.\n    AR = longest_edge / shortest_edge\n    \"\"\"\n    edge_lengths = []\n    num_vertices = len(vertices)\n    for i in range(num_vertices):\n        p1 = vertices[i]\n        p2 = vertices[(i + 1) % num_vertices]\n        length = np.linalg.norm(p2 - p1)\n        edge_lengths.append(length)\n    \n    if not edge_lengths or min(edge_lengths) == 0:\n        return np.inf\n        \n    return max(edge_lengths) / min(edge_lengths)\n\ndef calculate_orthogonality(vertices):\n    \"\"\"\n    Calculates the face orthogonality metric O for a quadrilateral cell.\n    Assumes CCW ordering of vertices.\n    \"\"\"\n    num_vertices = len(vertices)\n    cell_centroid = np.mean(vertices, axis=0)\n    \n    ortho_per_face = []\n    for i in range(num_vertices):\n        p1 = vertices[i]\n        p2 = vertices[(i + 1) % num_vertices]\n        \n        face_centroid = (p1 + p2) / 2.0\n        edge_vector = p2 - p1\n        \n        # Outward normal for CCW vertex ordering\n        normal_vector = np.array([edge_vector[1], -edge_vector[0]])\n        unit_normal = normal_vector / np.linalg.norm(normal_vector)\n        \n        # Vector from cell centroid to face centroid\n        d_vector = face_centroid - cell_centroid\n        if np.linalg.norm(d_vector) == 0:\n            # This can happen if cell centroid lies on a face centroid (e.g., a triangle)\n            # For a convex quad, it's generally non-zero unless highly degenerate.\n            ortho_per_face.append(0.0)\n            continue\n        unit_d_vector = d_vector / np.linalg.norm(d_vector)\n        \n        ortho_per_face.append(np.abs(np.dot(unit_normal, unit_d_vector)))\n        \n    return min(ortho_per_face)\n\ndef calculate_skewness(vertices):\n    \"\"\"\n    Calculates the skewness metric S_deg in degrees for a quadrilateral cell.\n    \"\"\"\n    num_vertices = len(vertices)\n    deviations = []\n    for i in range(num_vertices):\n        p_prev = vertices[(i - 1 + num_vertices) % num_vertices]\n        p_curr = vertices[i]\n        p_next = vertices[(i + 1) % num_vertices]\n        \n        v_prev = p_prev - p_curr\n        v_next = p_next - p_curr\n        \n        cosine_angle = np.dot(v_prev, v_next) / (np.linalg.norm(v_prev) * np.linalg.norm(v_next))\n        # Clip for numerical stability\n        cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n        \n        angle_rad = np.arccos(cosine_angle)\n        angle_deg = np.rad2deg(angle_rad)\n        \n        deviations.append(np.abs(angle_deg - 90.0))\n        \n    return max(deviations)\n\ndef solve():\n    \"\"\"\n    Main function to evaluate the LES-accuracy for the given test cases.\n    \"\"\"\n    # Constants from the problem statement\n    EPSILON_AR = 0.10\n    O_MIN = 0.95\n    S_MAX = 10.0 # degrees\n\n    # Given numeric values for Case 4\n    COS_30 = 0.8660254037844386\n    SIN_30 = 0.5\n\n    test_cases = [\n        {\n            \"E\": np.array([[9, 0], [0, 1]]),\n            \"vertices\": np.array([[0, 0], [3, 0], [3, 1], [0, 1]], dtype=float)\n        },\n        {\n            \"E\": np.array([[4, 0], [0, 4]]),\n            \"vertices\": np.array([[0, 0], [1, 0], [1, 1], [0, 1]], dtype=float)\n        },\n        {\n            \"E\": np.array([[25, 0], [0, 1]]),\n            \"vertices\": np.array([[0, 0], [2, 0], [2, 1], [0, 1]], dtype=float)\n        },\n        {\n            \"E\": np.array([[9, 0], [0, 1]]),\n            \"vertices\": np.array([\n                [0, 0],\n                [3, 0],\n                [3 + COS_30, SIN_30],\n                [COS_30, SIN_30]\n            ], dtype=float)\n        },\n        {\n            \"E\": np.array([[100, 0], [0, 1]]),\n            \"vertices\": np.array([[0, 0], [10, 0], [10, 1], [0, 1]], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E = case[\"E\"]\n        vertices = case[\"vertices\"]\n\n        # Calculate all metrics\n        ar_star = calculate_recommended_ar(E)\n        ar_actual = calculate_actual_ar(vertices)\n        orthogonality = calculate_orthogonality(vertices)\n        skewness = calculate_skewness(vertices)\n\n        # Apply the decision rule\n        # Condition 1: Aspect Ratio\n        if ar_star == 0: # Avoid division by zero if E is degenerate\n            cond1 = (ar_actual == 0)\n        else:\n            rel_ar_mismatch = np.abs(ar_actual - ar_star) / ar_star\n            cond1 = rel_ar_mismatch <= EPSILON_AR\n        \n        # Condition 2: Orthogonality\n        cond2 = orthogonality >= O_MIN\n\n        # Condition 3: Skewness\n        cond3 = skewness <= S_MAX\n\n        is_les_accurate = cond1 and cond2 and cond3\n        results.append(is_les_accurate)\n\n    # Format output exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3326707"}]}