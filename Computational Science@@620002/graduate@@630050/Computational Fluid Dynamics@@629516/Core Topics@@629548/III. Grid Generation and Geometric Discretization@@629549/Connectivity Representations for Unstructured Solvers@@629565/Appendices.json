{"hands_on_practices": [{"introduction": "Many common mesh file formats, for the sake of compactness, store only cell-to-node connectivity. This exercise [@problem_id:3303794] guides you through the fundamental and highly practical task of reconstructing the full face-based connectivity from this minimal information. You will implement an algorithm to identify unique faces and distinguish boundary from interior ones by creating a canonical key for each face, a cornerstone for building data structures in finite volume or finite element solvers.", "problem": "An unstructured mesh used in Computational Fluid Dynamics (CFD) and stored in the Visualization Toolkit (VTK) format is often represented with only cell-to-node connectivity. From first principles, consider that a cell is a topological three-dimensional entity composed of faces, where a face is a two-dimensional boundary entity defined by a minimal subset of nodes forming a planar polygon. A unique face in a mesh is defined as an equivalence class of faces across all cells, where two faces are equivalent if they are composed of the same set of node indices, independent of ordering. Therefore, a face can be canonically represented by a sorted tuple of its node indices. The goal is to reconstruct the set of unique faces and identify boundary faces, which are faces incident to exactly one cell.\n\nStarting from the core definitions:\n- A mesh is a pair $(\\mathcal{N}, \\mathcal{C})$ where $\\mathcal{N}$ is the set of node indices and $\\mathcal{C}$ is a list of cells. Each cell $c \\in \\mathcal{C}$ is given by a type identifier and an ordered list of node indices.\n- For common VTK three-dimensional cell types, the face templates are defined by discrete topology: a tetrahedron has $4$ triangular faces, a hexahedron has $6$ quadrilateral faces, a wedge (triangular prism) has $5$ faces composed of $2$ triangles and $3$ quadrilaterals, and a pyramid has $5$ faces composed of $1$ quadrilateral and $4$ triangles.\n- A unique face key is the sorted tuple $\\mathrm{sort}([n_0,\\dots,n_{k-1}])$, canonically representing the node set of the face.\n\nYour task is to design and implement a complete program that:\n1. Reconstructs the set of unique faces from only cell-to-node connectivity for the following VTK cell types: `VTK_TETRA` (10), `VTK_HEXAHEDRON` (12), `VTK_WEDGE` (13), and `VTK_PYRAMID` (14).\n2. Counts the number of boundary faces, defined as those unique faces that are incident to exactly one cell.\n3. Validates the reconstruction against expected boundary-face counts for several test meshes.\n\nUse the following test suite, where each test case is a list of cells. Each cell is a pair $(t, \\mathbf{n})$ where $t$ is the VTK cell type integer and $\\mathbf{n}$ is the ordered list of node indices for that cell. The expected boundary-face counts are provided for each test case:\n\n- Test case $1$ (two tetrahedra sharing one triangular face with reversed orientation in one cell):\n  Cells: $[(10, [0,1,2,3]), (10, [2,1,0,4])]$.\n  Expected boundary-face count: $6$.\n\n- Test case $2$ (one hexahedron):\n  Cells: $[(12, [0,1,2,3,4,5,6,7])]$.\n  Expected boundary-face count: $6$.\n\n- Test case $3$ (two wedges sharing one quadrilateral face across different cell instances):\n  Cells: $[(13, [0,1,2,3,4,5]), (13, [0,1,9,3,4,10])]$.\n  Expected boundary-face count: $8$.\n\n- Test case $4$ (one pyramid and one tetrahedron sharing one triangular face):\n  Cells: $[(14, [0,1,2,3,4]), (10, [1,2,4,5])]$.\n  Expected boundary-face count: $7$.\n\n- Test case $5$ (two tetrahedra sharing only an edge, not a face):\n  Cells: $[(10, [0,1,2,3]), (10, [2,3,4,5])]$.\n  Expected boundary-face count: $8$.\n\nYour program must:\n- Implement face reconstruction using only the provided cell-to-node lists and the topological face templates for the given VTK cell types.\n- Canonicalize each face by sorting its node indices to ensure unique identification independent of orientation.\n- Count boundary faces by identifying unique faces that are incident to exactly one cell.\n- Compare the computed boundary-face count to the expected count for each test case and produce a boolean result for each test case: $true$ if the counts match, and $false$ otherwise.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is a boolean.\n\nNo physical units are involved in this problem. Angles are not applicable. Percentages are not applicable. Ensure that the algorithm is derived from the provided core definitions and cell-face topology, not from any external shortcuts or precomputed adjacency structures.", "solution": "The problem of reconstructing face connectivity and identifying boundary faces from cell-to-node connectivity is a fundamental task in computational geometry, particularly in the preprocessing stage for numerical solvers in fields like Computational Fluid Dynamics (CFD). The provided problem is well-posed, scientifically sound, and internally consistent, thus admitting a formal solution.\n\nThe core principle underpinning the solution is the establishment of a canonical representation for each face. A face is a geometric entity defined by a set of nodes. While the ordering of these nodes may differ depending on the orientation of the face relative to its parent cell, the set of nodes itself is invariant. The problem statement correctly defines a unique face as an equivalence class based on this set of nodes. A robust canonical representation, or key, is therefore a sorted tuple of the global indices of the nodes that constitute the face. This key is unique regardless of the original node ordering.\n\nThe algorithm proceeds as follows:\n\nLet the computational mesh be represented by a pair $\\mathcal{M} = (\\mathcal{N}, \\mathcal{C})$, where $\\mathcal{N}$ is the set of node indices (e.g., $\\{0, 1, 2, \\dots\\}$) and $\\mathcal{C}$ is a list of cells. Each cell $c_i \\in \\mathcal{C}$ is defined by a pair $(t_i, \\mathbf{n}_i)$, where $t_i$ is an integer identifying the cell's topological type and $\\mathbf{n}_i$ is an ordered list of global node indices for that cell.\n\n$1$. **Topological Face Templates**: For each supported VTK cell type $t$, we must define a fixed set of face templates. Each template is a list of local indices that identify the nodes forming a single face of the cell, based on VTK's standard node ordering for that cell type. Let $F_t$ be the set of face templates for a cell of type $t$.\n- For `VTK_TETRA` (type $t=10$), there are $4$ triangular faces: $F_{10} = \\{ (0,1,2), (0,3,1), (1,3,2), (2,3,0) \\}$.\n- For `VTK_HEXAHEDRON` (type $t=12$), there are $6$ quadrilateral faces: $F_{12} = \\{ (0,1,2,3), (4,5,6,7), (0,1,5,4), (1,2,6,5), (2,3,7,6), (3,0,4,7) \\}$.\n- For `VTK_WEDGE` (type $t=13$), there are $2$ triangular and $3$ quadrilateral faces: $F_{13} = \\{ (0,1,2), (3,4,5), (0,1,4,3), (1,2,5,4), (2,0,3,5) \\}$.\n- For `VTK_PYRAMID` (type $t=14$), there is $1$ quadrilateral and $4$ triangular faces: $F_{14} = \\{ (0,1,2,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4) \\}$.\n\n$2$. **Face Instance Generation and Counting**: We require a mapping data structure, which we will denote as $\\mathcal{A}$, to store the incidence count of each unique face. A hash map (or dictionary) is suitable, where keys are the canonical face representations and values are their corresponding counts. The algorithm iterates through every cell $c_i = (t_i, \\mathbf{n}_i)$ in the list $\\mathcal{C}$.\nFor each cell $c_i$:\n- Retrieve the set of face templates $F_{t_i}$ corresponding to its type $t_i$.\n- For each local face template $f_j = (l_0, l_1, \\dots, l_k) \\in F_{t_i}$:\n    - A specific face instance is formed by mapping these local indices to the global node indices provided in $\\mathbf{n}_i$. The global nodes for this face instance are $\\{ \\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k] \\}$.\n    - The canonical key, $K_f$, for this face instance is generated by sorting these global node indices: $K_f = \\mathrm{tuple}(\\mathrm{sorted}([\\mathbf{n}_i[l_0], \\mathbf{n}_i[l_1], \\dots, \\mathbf{n}_i[l_k]]))$.\n    - The incidence count in the map $\\mathcal{A}$ for this key $K_f$ is incremented. If the key does not exist in $\\mathcal{A}$, it is initialized with a count of $1$.\n\n$3$. **Boundary Face Identification**: After processing all cells, the map $\\mathcal{A}$ contains every unique face key present in the mesh, along with the number of cells it is incident to. According to the definition, a boundary face is one that is incident to exactly one cell. Therefore, the number of boundary faces, $N_{bf}$, is the number of entries in $\\mathcal{A}$ whose value is exactly $1$.\n$$N_{bf} = |\\{K_f \\mid \\mathcal{A}[K_f] = 1\\}|$$\n\nThis algorithm is deterministic and provides an exact reconstruction of face-based connectivity from cell-based connectivity. It correctly identifies boundary faces by leveraging the principle that internal faces are shared by two or more cells, resulting in an incidence count greater than $1$. The implementation of this algorithm will be used to validate the provided test cases.", "answer": "```python\ndef solve():\n    \"\"\"\n    Solves the mesh face reconstruction problem for a suite of test cases.\n    \"\"\"\n\n    # Face templates are defined using local node indices for each VTK cell type.\n    # These orderings are based on the standard VTK library definitions.\n    FACE_TEMPLATES = {\n        10: [  # VTK_TETRA (4 nodes)\n            (0, 1, 2), (0, 3, 1), (1, 3, 2), (2, 3, 0)\n        ],\n        12: [  # VTK_HEXAHEDRON (8 nodes)\n            (0, 1, 2, 3), (4, 5, 6, 7), (0, 1, 5, 4), (1, 2, 6, 5),\n            (2, 3, 7, 6), (3, 0, 4, 7)\n        ],\n        13: [  # VTK_WEDGE (6 nodes)\n            (0, 1, 2), (3, 4, 5), (0, 1, 4, 3), (1, 2, 5, 4), (2, 0, 3, 5)\n        ],\n        14: [  # VTK_PYRAMID (5 nodes)\n            (0, 1, 2, 3), (0, 1, 4), (1, 2, 4), (2, 3, 4), (3, 0, 4)\n        ]\n    }\n\n    def count_boundary_faces(cells):\n        \"\"\"\n        Reconstructs unique faces and counts boundary faces from cell-to-node connectivity.\n\n        Args:\n            cells (list): A list of cells, where each cell is a tuple\n                          (cell_type_id, node_indices_list).\n\n        Returns:\n            int: The number of boundary faces.\n        \"\"\"\n        face_counts = {}\n\n        for cell_type, node_indices in cells:\n            if cell_type not in FACE_TEMPLATES:\n                raise ValueError(f\"Unknown cell type: {cell_type}\")\n\n            templates = FACE_TEMPLATES[cell_type]\n            for template in templates:\n                # Map local face template indices to global node indices\n                global_face_nodes = [node_indices[i] for i in template]\n                \n                # Create a canonical key by sorting the node indices.\n                # A tuple is used because it is hashable.\n                canonical_key = tuple(sorted(global_face_nodes))\n\n                # Increment the count for this unique face\n                face_counts[canonical_key] = face_counts.get(canonical_key, 0) + 1\n        \n        # A boundary face is a unique face that appears exactly once.\n        boundary_face_count = 0\n        for count in face_counts.values():\n            if count == 1:\n                boundary_face_count += 1\n        \n        return boundary_face_count\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 1, 0, 4])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 2,\n            \"cells\": [(12, [0, 1, 2, 3, 4, 5, 6, 7])],\n            \"expected\": 6\n        },\n        {\n            \"id\": 3,\n            \"cells\": [(13, [0, 1, 2, 3, 4, 5]), (13, [0, 1, 9, 3, 4, 10])],\n            \"expected\": 8\n        },\n        {\n            \"id\": 4,\n            \"cells\": [(14, [0, 1, 2, 3, 4]), (10, [1, 2, 4, 5])],\n            \"expected\": 7\n        },\n        {\n            \"id\": 5,\n            \"cells\": [(10, [0, 1, 2, 3]), (10, [2, 3, 4, 5])],\n            \"expected\": 8\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        computed_count = count_boundary_faces(case[\"cells\"])\n        # The result for the case is true if the computed count matches the expected one.\n        is_correct = (computed_count == case[\"expected\"])\n        results.append(str(is_correct).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3303794"}, {"introduction": "Building on the previous practice, this exercise [@problem_id:3303832] addresses a more subtle but critical requirement: establishing a canonical representation for each face that is invariant to its local orientation within a cell. This is essential for algorithms where face orientation, which determines the normal vector direction, must be consistent across the mesh for tasks like flux computation. You will develop a robust canonicalization scheme based on the lexicographically minimal representation among all cyclic rotations and reversals of a face's node sequence.", "problem": "An unstructured mesh in Computational Fluid Dynamics (CFD) is represented by a set of cells, each cell referencing a sequence of global node identifiers. A face is the lower-dimensional boundary entity of a cell: in two dimensions an edge with $2$ nodes, and in three dimensions a polygonal face with $m \\ge 3$ nodes. In an unstructured solver, different adjacent cells reference the same geometric face with different local orientations, so a robust connectivity representation must assign a unique canonical node ordering to each geometrically identical face so that faces can be deduplicated and cell adjacencies derived unambiguously.\n\nFundamental definitions and facts:\n- A cell of type triangle has $3$ local nodes. Its faces are the oriented edges induced by consecutive local nodes, and the orientation is consistent with the cell's local node ordering convention.\n- A cell of type quadrilateral has $4$ local nodes. Its faces are the oriented edges induced by consecutive local nodes.\n- A cell of type tetrahedron has $4$ local nodes. Its faces are the oriented triangles obtained from the cell’s local node ordering according to a fixed consistent convention. For a tetrahedron with local nodes `[n0,n1,n2,n3]`, a widely used orientation-consistent set of face local index patterns is:\n$$\n\\left[n_0,n_2,n_1\\right],\\ \\left[n_0,n_1,n_3\\right],\\ \\left[n_1,n_2,n_3\\right],\\ \\left[n_0,n_3,n_2\\right].\n$$\n- A hexahedron with local nodes `[n0,n1,n2,n3,n4,n5,n6,n7]` has $6$ quadrilateral faces. A consistent template for its face local index patterns is:\n$$\n\\left[n_0,n_1,n_2,n_3\\right],\\ \\left[n_4,n_5,n_6,n_7\\right],\\ \\left[n_0,n_4,n_5,n_1\\right],\\ \\left[n_1,n_5,n_6,n_2\\right],\\ \\left[n_2,n_6,n_7,n_3\\right],\\ \\left[n_3,n_7,n_4,n_0\\right].\n$$\n\nCanonicalization goal:\n- Two node sequences represent the same geometric face if one can be transformed to the other by a cyclic rotation or by reversal followed by a cyclic rotation. The canonical representative of the face should be the lexicographically minimal sequence among all cyclic rotations of the original sequence and of its reversal. This ensures that shared faces between cells, even when referenced with opposite orientations, map to the same canonical representative, enabling unique face detection.\n\nTask:\n- Starting from these foundational definitions, derive the algorithmic steps necessary to:\n  1. Enumerate all faces for each cell using only the cell-to-node connectivity and the above local orientation conventions.\n  2. For each enumerated face node sequence $S$ of length $m$, form the set of candidates comprising all $m$ cyclic rotations of $S$ and all $m$ cyclic rotations of the reversed sequence $S^{\\mathrm{rev}}$, then select the lexicographically minimal candidate to define the canonical representative $C(S)$.\n  3. Deduplicate faces by their canonical representative, and count the number of incident cells per unique face (the face's adjacency count). This yields interior faces with adjacency counts greater than $1$, boundary faces with adjacency count equal to $1$, and non-manifold faces with adjacency counts greater than $2$.\n\nYour program must implement this algorithm and apply it to the following test suite of cell-to-node datasets, assuming the above orientation conventions. All node identifiers are global and are nonnegative integers. Each test case is a list of cells, where each cell is a tuple of a type string and a list of its node identifiers in local order.\n\nTest suite:\n- Test case $1$ (two triangles in a $2$-dimensional mesh sharing an edge with opposite orientation):\n  - Cells: `[('tri', [0, 1, 2]), ('tri', [3, 2, 1])]`.\n- Test case $2$ (two tetrahedra in a $3$-dimensional mesh sharing a triangular face with opposite orientation):\n  - Cells: `[('tet', [0, 1, 2, 3]), ('tet', [1, 0, 3, 4])]`.\n- Test case $3$ (three tetrahedra in a non-manifold configuration sharing one triangular face):\n  - Cells: `[('tet', [1, 2, 3, 0]), ('tet', [2, 1, 3, 4]), ('tet', [3, 1, 2, 5])]`.\n\nOutput specification:\n- For each test case, produce a pair `[F, A]` where $F$ is the lexicographically sorted list of unique canonical faces (each face represented as a list of node identifiers), and $A$ is the list of adjacency counts aligned with $F$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order of the test cases. For example, the format should follow `[result_1,result_2,result_3]`, where each `result_i` is the pair `[F_i,A_i]` for test case $i$.\n- All outputs are pure integers or lists of integers; no physical units or angles apply.\n\nThe problem requires you to derive the algorithmic steps from the above definitions of faces, oriented local conventions, equivalence under rotation and reversal, and lexicographic ordering. Then implement the algorithm as a complete, runnable program that applies it to the test suite and prints the aggregate results in the specified single-line format.", "solution": "The problem is valid. It is scientifically grounded in the established principles of computational geometry and mesh data structures used in computational fluid dynamics (CFD). The definitions are precise, self-contained, and consistent. The task is well-posed, leading to a unique and verifiable solution for the provided test cases.\n\nThe objective is to devise and implement an algorithm that processes a mesh defined by cell-to-node connectivity to identify all unique geometric faces and determine their adjacency counts. This is a foundational task for unstructured mesh solvers, enabling the construction of face-based data structures for computing fluxes between cells. The core of the problem lies in creating a unique identifier for each face, regardless of how it is referenced by adjacent cells, which may use different local node orderings and orientations.\n\nThe solution is constructed upon the principle of a **canonical representation**. A canonical form is a standardized representation chosen from a set of equivalent forms. Here, two face-node sequences are considered equivalent if they represent the same geometric face, which occurs if one can be transformed into the other via cyclic permutation or reversal followed by cyclic permutation. The problem specifies the canonical representative as the lexicographically minimal sequence among all these possible equivalent forms.\n\nThe algorithm proceeds in three main stages: face enumeration, canonicalization, and aggregation.\n\n**1. Face Enumeration**\n\nThe first step is to generate a list of all raw, oriented faces from the input cell data. The input consists of a list of cells, where each cell is defined by its type (e.g., 'tri', 'tet') and an ordered list of its global node identifiers. The problem provides specific conventions for how the faces of a cell are defined based on its local node ordering.\n\n- For a $2$-dimensional cell like a triangle with local nodes $[n_0, n_1, n_2]$, the faces are the edges formed by consecutive nodes, closing the loop: $[n_0, n_1]$, $[n_1, n_2]$, and $[n_2, n_0]$.\n- For a $3$-dimensional cell like a tetrahedron, the faces are triangles. For a tetrahedron with local nodes $[n_0, n_1, n_2, n_3]$, the problem specifies the face patterns as $[n_0, n_2, n_1]$, $[n_0, n_1, n_3]$, $[n_1, n_2, n_3]$, and $[n_0, n_3, n_2]$.\n\nFor each cell in the mesh, we apply these patterns. Given a cell's list of global node identifiers, $[g_0, g_1, \\dots, g_{k-1}]$, a local index pattern like $[l_0, l_1, \\dots, l_{m-1}]$ is mapped to a global face-node list $[g_{l_0}, g_{l_1}, \\dots, g_{l_{m-1}}]$. This process is repeated for every face pattern of every cell, yielding a complete, albeit redundant, list of all face instances in the mesh.\n\n**2. Face Canonicalization**\n\nThe second step is to compute the canonical representative $C(S)$ for each raw face-node sequence $S$ generated in the previous step. For a face $S$ with $m$ nodes, its equivalence class contains $2m$ sequences: the $m$ cyclic rotations of $S$ and the $m$ cyclic rotations of its reversed sequence, $S^{\\mathrm{rev}}$.\n\nThe algorithm to find the canonical representative $C(S)$ is as follows:\n1. Let the input face be the sequence of node identifiers $S = [s_0, s_1, \\dots, s_{m-1}]$.\n2. Create an empty set of candidate sequences.\n3. Generate all $m$ cyclic rotations of $S$. A simple way to do this is to start with $S$ and repeatedly move the first element to the end, $m-1$ times. Add each rotation to the candidate set.\n4. Reverse the original sequence to get $S^{\\mathrm{rev}} = [s_{m-1}, \\dots, s_1, s_0]$.\n5. Generate all $m$ cyclic rotations of $S^{\\mathrm{rev}}$ and add them to the candidate set.\n6. The canonical representative $C(S)$ is the single sequence in the candidate set that is lexicographically minimal. Lexicographical comparison proceeds element by element from left to right.\n\nFor instance, if two adjacent triangular cells reference a shared face with node lists $[3, 2, 1]$ and $[1, 2, 3]$, this canonicalization procedure will map both to the same representative, $[1, 2, 3]$, as it is the lexicographically smallest among all rotations of both sequences.\n\n**3. Deduplication and Adjacency Counting**\n\nThe final step is to use the canonical representations to count the unique faces and their adjacencies. A hash map (or a dictionary in Python) is the ideal data structure for this task, as it provides efficient key-based lookups and updates.\n\n1. Initialize an empty hash map, `face_counts`. The keys will store the canonical face representations (as immutable tuples to be hashable), and the values will store their corresponding adjacency counts.\n2. Iterate through the complete list of raw faces generated in Step 1.\n3. For each raw face $S$, compute its canonical representative $C(S)$ using the method from Step 2.\n4. Use this canonical tuple $C(S)$ as a key into the `face_counts` map. If the key is not present, add it with a value of $1$. If the key already exists, increment its associated value by $1$.\n5. After iterating through all raw faces, the `face_counts` map will contain exactly one entry for each unique geometric face, with the value being the number of cells that share it. An adjacency count of $1$ indicates a boundary face, a count of $2$ indicates a standard interior face, and a count greater than $2$ indicates a non-manifold configuration.\n\nTo produce the final output as specified, the keys of the `face_counts` map are extracted and sorted lexicographically. This sorted list of faces constitutes the list $F$. The list of corresponding adjacency counts, $A$, is created by retrieving the values from the map in the same order. The final result for one test case is the pair $[F, A]$.", "answer": "```python\ndef solve():\n    \"\"\"\n    Main function to solve the mesh connectivity problem for all test cases.\n    It encapsulates all logic, including helpers and constants, for self-contained execution.\n    \"\"\"\n\n    # --- Helper Functions and Constants ---\n\n    def get_canonical_face(nodes):\n        \"\"\"\n        Computes the canonical representative of a face.\n        The canonical form is the lexicographically smallest of all cyclic\n        permutations of the node list and its reverse.\n        \"\"\"\n        m = len(nodes)\n        if m == 0:\n            return tuple()\n\n        # Find the lexicographically smallest rotation of the original sequence\n        min_rotation = tuple(nodes)\n        current_rotation = list(nodes)\n        for _ in range(m - 1):\n            current_rotation.append(current_rotation.pop(0))\n            if tuple(current_rotation)  min_rotation:\n                min_rotation = tuple(current_rotation)\n\n        # Find the lexicographically smallest rotation of the reversed sequence\n        nodes_rev = list(nodes)[::-1]\n        min_rev_rotation = tuple(nodes_rev)\n        current_rev_rotation = list(nodes_rev)\n        for _ in range(m - 1):\n            current_rev_rotation.append(current_rev_rotation.pop(0))\n            if tuple(current_rev_rotation)  min_rev_rotation:\n                min_rev_rotation = tuple(current_rev_rotation)\n\n        # The canonical form is the smaller of the two minimal rotations\n        return min(min_rotation, min_rev_rotation)\n\n    # Define face structures based on local node indices.\n    FACE_PATTERNS = {\n        'tri': [[0, 1], [1, 2], [2, 0]],\n        'tet': [[0, 2, 1], [0, 1, 3], [1, 2, 3], [0, 3, 2]],\n    }\n\n    def process_mesh(cells):\n        \"\"\"\n        Processes a single mesh (test case) to find unique faces and adjacencies.\n        \"\"\"\n        face_counts = {}\n\n        for cell_type, cell_nodes in cells:\n            if cell_type not in FACE_PATTERNS:\n                continue\n            \n            patterns = FACE_PATTERNS[cell_type]\n            for pattern in patterns:\n                # Map local face indices to global node identifiers\n                face_nodes = [cell_nodes[i] for i in pattern]\n                \n                # Compute the canonical representation for the face\n                canonical_face = get_canonical_face(face_nodes)\n                \n                # Increment the adjacency count for this canonical face\n                face_counts[canonical_face] = face_counts.get(canonical_face, 0) + 1\n\n        # Sort the unique canonical faces lexicographically\n        sorted_faces = sorted(face_counts.keys())\n\n        # Prepare the final output lists F (faces) and A (adjacencies)\n        F = [list(face) for face in sorted_faces]\n        A = [face_counts[face] for face in sorted_faces]\n\n        return [F, A]\n\n    # --- Test Suite ---\n\n    test_cases = [\n        # Test case 1: Two triangles sharing an edge\n        [('tri', [0, 1, 2]), ('tri', [3, 2, 1])],\n        \n        # Test case 2: Two tetrahedra sharing a face\n        [('tet', [0, 1, 2, 3]), ('tet', [1, 0, 3, 4])],\n        \n        # Test case 3: Three tetrahedra in a non-manifold configuration\n        [('tet', [1, 2, 3, 0]), ('tet', [2, 1, 3, 4]), ('tet', [3, 1, 2, 5])],\n    ]\n\n    # --- Main Execution Logic ---\n\n    results = []\n    for case in test_cases:\n        result = process_mesh(case)\n        results.append(result)\n\n    # Format the output exactly as specified in the problem statement.\n    # The use of str() on lists will include spaces, which is consistent\n    # with a literal interpretation of the provided `print` statement template.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3303832"}, {"introduction": "After mastering the algorithmic construction of connectivity, we can apply these data structures to perform high-level topological validation. This practice [@problem_id:3303802] moves from implementation to a conceptual derivation, using the Euler-Poincaré formula to verify the global topological properties of a 2D mesh, such as determining the number of holes. This exercise demonstrates how low-level connectivity counts of vertices ($V$), edges ($E$), and faces ($F$) can reveal profound topological invariants of the discretized domain, linking computational geometry directly to topology.", "problem": "An unstructured two-dimensional triangular mesh is used by a Computational Fluid Dynamics (CFD) solver to discretize a bounded planar domain. The solver stores connectivity using per-cell lists of vertex indices and a separate list of boundary edges. Consider a mesh of a planar domain that may contain interior holes. The mesh has exactly $F = 100$ triangular cells (counting only the bounded triangles that tile the domain, not the unbounded exterior), $V = 68$ distinct vertices, and the boundary edge list contains $B = 40$ distinct edges. There are no hanging nodes, and each boundary edge belongs to exactly one triangle.\n\nStarting only from the foundational definitions of a two-dimensional cell complex, the Euler characteristic as an alternating count of $0$-cells, $1$-cells, and $2$-cells, the topological invariance of the Euler characteristic under homeomorphisms, and the double-counting principle for edge-to-face incidences in a triangulation, derive the topological invariant that links the alternated count of mesh entities to the number of boundary components. Use this invariant to compute the number of interior holes $h$ of the meshed domain under the convention that each hole contributes an additional boundary component beyond the outer boundary.\n\nProvide as your final answer the value of $h$ as a single number. No rounding is required, and no units are involved. Assume standard planar topology and that all mesh entities are correctly counted as described.", "solution": "The problem requires the derivation of a topological invariant relating the counts of mesh entities (vertices, edges, faces) to the number of holes in a planar domain and then using this invariant to compute the number of holes from given mesh data.\n\nThe derivation begins with the concept of the Euler characteristic, $\\chi$, a fundamental topological invariant. For any polyhedral decomposition (such as a triangulation) of a closed, orientable 2-manifold (a surface without boundary) into $V$ vertices, $E$ edges, and $F$ faces, the Euler characteristic is given by the alternating sum:\n$$ \\chi = V - E + F $$\nThe simplest such surface is the sphere, $S^2$, for which the Euler characteristic is $\\chi(S^2) = 2$. This can be confirmed with a simple polyhedron like a tetrahedron, where $V=4$, $E=6$, and $F=4$, giving $V-E+F=4-6+4=2$.\n\nThe meshed domain described in the problem is a bounded planar region, which may contain interior holes. Topologically, such a domain is homeomorphic to a sphere from which a number of disjoint open disks have been removed. Each removed disk creates a boundary component. Let the total number of boundary components be $k$. According to the problem's convention, there is one outer boundary and $h$ interior holes, so the total number of boundary components is $k = h+1$.\n\nTo find the Euler characteristic of this domain with boundaries, we can consider how $\\chi$ changes when we \"puncture\" a closed surface. Let us start with a triangulation of a sphere, for which $V_s - E_s + F_s = 2$. To create a surface homeomorphic to our domain, we remove $k$ disjoint faces from this triangulation. The vertices and edges that form the boundaries of these $k$ faces remain part of the complex, but the faces themselves are removed. The new number of faces in the complex is $F = F_s - k$. The number of vertices and edges remains unchanged, i.e., $V=V_s$ and $E=E_s$. The Euler characteristic of the resulting surface with boundary, $\\chi_{domain}$, is:\n$$ \\chi_{domain} = V - E + F = V_s - E_s + (F_s - k) = (V_s - E_s + F_s) - k $$\nSubstituting $\\chi(S^2) = 2$, we get:\n$$ \\chi_{domain} = 2 - k $$\nThe quantities $V$, $E$, and $F$ given in the problem statement correspond to the vertices, edges, and faces of the triangulation that discretizes the domain. Therefore, the value of the alternating sum for the mesh, $V-E+F$, must be equal to the Euler characteristic of the domain it represents. This provides the general invariant:\n$$ V - E + F = 2 - k $$\nNow, we relate this to the number of interior holes, $h$. With $k = h+1$ boundary components, the invariant becomes:\n$$ V - E + F = 2 - (h+1) = 1 - h $$\nThis is the specific topological invariant that connects the alternated count of mesh entities to the number of interior holes.\n\nNext, we must calculate the values of $V$, $E$, and $F$ for the given mesh. The problem provides:\n- Number of vertices (0-cells): $V = 68$.\n- Number of triangular faces (2-cells): $F = 100$.\n- Number of boundary edges: $B = 40$.\n\nThe total number of edges, $E$, is not explicitly provided. To find it, we employ the double-counting principle (a handshaking lemma for face-edge adjacencies). The sum of the number of edges for each face is computed. Since all cells are triangles, each has $3$ edges. Thus, summing the edges over all $F$ faces gives a total count of $3F$.\nIn this summation, every interior edge is shared by exactly two faces and is therefore counted twice. Every boundary edge, by definition and as stated in the problem (\"each boundary edge belongs to exactly one triangle\"), is part of only one face in the mesh and is counted once.\nLet $E_I$ be the number of interior edges and $E_B$ be the number of boundary edges. The total number of edges is $E = E_I + E_B$. The double-counting relationship is expressed as:\n$$ 3F = 2E_I + E_B $$\nWe are given $F=100$ and $E_B = B = 40$. Substituting these values into the equation:\n$$ 3(100) = 2E_I + 40 $$\n$$ 300 = 2E_I + 40 $$\n$$ 2E_I = 300 - 40 = 260 $$\nThis gives the number of interior edges as $E_I = 130$.\nThe total number of edges in the mesh is:\n$$ E = E_I + E_B = 130 + 40 = 170 $$\nNow we have all the necessary quantities for our derived invariant:\n- $V = 68$\n- $E = 170$\n- $F = 100$\n\nWe substitute these values into the formula $V - E + F = 1 - h$:\n$$ 68 - 170 + 100 = 1 - h $$\nCalculating the left-hand side:\n$$ 168 - 170 = -2 $$\nThe equation simplifies to:\n$$ -2 = 1 - h $$\nFinally, we solve for $h$, the number of interior holes:\n$$ h = 1 - (-2) = 1 + 2 = 3 $$\nThus, the meshed domain has $3$ interior holes.", "answer": "$$\n\\boxed{3}\n$$", "id": "3303802"}]}