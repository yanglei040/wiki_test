{"hands_on_practices": [{"introduction": "To accurately model physical phenomena on complex geometries, we must express fundamental operators like the gradient in body-fitted, curvilinear coordinates. This foundational exercise guides you through the derivation of the gradient from first principles, starting with its invariant definition and applying the chain rule. By performing this derivation for a general coordinate system and then simplifying it for the common case of orthogonal coordinates [@problem_id:3298892], you will build a bedrock understanding of how metric tensors and scale factors naturally arise from the geometry of the transformation.", "problem": "In Computational Fluid Dynamics (CFD), curvilinear coordinate mappings are used to express spatial derivatives on body-fitted grids. Let $\\boldsymbol{x}(\\xi^1,\\xi^2,\\xi^3)$ be a smooth bijective mapping from computational coordinates $(\\xi^1,\\xi^2,\\xi^3)\\in\\mathbb{R}^3$ to physical space $\\boldsymbol{x}\\in\\mathbb{R}^3$. Define the covariant basis vectors by $\\boldsymbol{a}_i=\\partial \\boldsymbol{x}/\\partial \\xi^i$ for $i\\in\\{1,2,3\\}$, and the metric tensor by $g_{ij}=\\boldsymbol{a}_i\\cdot \\boldsymbol{a}_j$. Let $d\\boldsymbol{x}=\\boldsymbol{a}_i\\,d\\xi^i$ denote the differential mapping, and let $\\phi(\\boldsymbol{x})$ be a smooth scalar field.\n\nStarting only from the chain rule and the defining property of the gradient that $d\\phi=\\nabla \\phi \\cdot d\\boldsymbol{x}$, first express $\\nabla \\phi$ in terms of derivatives of $\\phi$ with respect to $\\xi^i$ and the reciprocal basis. Then assume an orthogonal mapping, i.e., $g_{ij}=0$ for $i\\neq j$, and introduce the scale factors $h_i=\\sqrt{g_{ii}}$ and associated orthonormal directions $\\boldsymbol{e}_i=\\boldsymbol{a}_i/h_i$. Using these definitions, reduce your general expression to its simplified orthogonal-coordinate form.\n\nProvide as your final answer a single closed-form analytic vector expression for the reduced gradient in terms of $\\boldsymbol{e}_i$, $h_i$, and $\\partial \\phi/\\partial \\xi^i$. No numerical evaluation is required.", "solution": "The problem statement is first validated against the required criteria.\n\n**Step 1: Extract Givens**\n-   Coordinate mapping: $\\boldsymbol{x}(\\xi^1,\\xi^2,\\xi^3)$ is a smooth bijective mapping from computational coordinates $(\\xi^1,\\xi^2,\\xi^3)\\in\\mathbb{R}^3$ to physical space $\\boldsymbol{x}\\in\\mathbb{R}^3$.\n-   Covariant basis vectors: $\\boldsymbol{a}_i=\\partial \\boldsymbol{x}/\\partial \\xi^i$ for $i\\in\\{1,2,3\\}$.\n-   Metric tensor: $g_{ij}=\\boldsymbol{a}_i\\cdot \\boldsymbol{a}_j$.\n-   Differential mapping: $d\\boldsymbol{x}=\\boldsymbol{a}_i\\,d\\xi^i$ (Einstein summation convention is implied).\n-   Scalar field: $\\phi(\\boldsymbol{x})$ is a smooth scalar field.\n-   Gradient definition: $d\\phi=\\nabla \\phi \\cdot d\\boldsymbol{x}$.\n-   Orthogonality condition: $g_{ij}=0$ for $i\\neq j$.\n-   Scale factors: $h_i=\\sqrt{g_{ii}}$.\n-   Orthonormal basis vectors: $\\boldsymbol{e}_i=\\boldsymbol{a}_i/h_i$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is firmly rooted in the principles of tensor calculus and differential geometry, which are standard mathematical tools for describing physics and engineering systems in curvilinear coordinates. The definitions and relationships are fundamental to fields like General Relativity and Computational Fluid Dynamics.\n-   **Well-Posed**: The problem is clearly stated, providing all necessary definitions and a clear objective: to derive a specific physical quantity (the gradient) under a specified coordinate transformation. The path to the solution is logically directed, and a unique, meaningful analytical expression is expected.\n-   **Objective**: The language is precise, mathematical, and devoid of any subjective or ambiguous terminology.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically sound, well-posed, and objective. It contains no contradictions, missing information, or pseudoscientific claims. Therefore, the problem is deemed **valid** and a solution will be provided.\n\n**Derivation of the Gradient Expression**\n\nWe begin by finding a general expression for the gradient, $\\nabla \\phi$, in the non-orthogonal curvilinear coordinate system $(\\xi^1, \\xi^2, \\xi^3)$. The total differential of the scalar field $\\phi$, which is a function of the physical coordinates $\\boldsymbol{x}$ that in turn are functions of the computational coordinates $\\xi^i$, can be found using the chain rule:\n$$d\\phi = \\frac{\\partial\\phi}{\\partial\\xi^1}d\\xi^1 + \\frac{\\partial\\phi}{\\partial\\xi^2}d\\xi^2 + \\frac{\\partial\\phi}{\\partial\\xi^3}d\\xi^3$$\nUsing Einstein summation convention, this is written compactly as:\n$$d\\phi = \\frac{\\partial\\phi}{\\partial\\xi^i}d\\xi^i$$\nThe problem provides the defining property of the gradient vector, $\\nabla \\phi$:\n$$d\\phi = \\nabla \\phi \\cdot d\\boldsymbol{x}$$\nWe are also given the relationship between the physical differential displacement $d\\boldsymbol{x}$ and the computational coordinate differentials $d\\xi^i$:\n$$d\\boldsymbol{x} = \\frac{\\partial\\boldsymbol{x}}{\\partial\\xi^j}d\\xi^j = \\boldsymbol{a}_j d\\xi^j$$\nSubstituting this into the gradient definition gives:\n$$d\\phi = \\nabla \\phi \\cdot (\\boldsymbol{a}_j d\\xi^j) = (\\nabla \\phi \\cdot \\boldsymbol{a}_j) d\\xi^j$$\nBy equating the two expressions for $d\\phi$, we get:\n$$\\frac{\\partial\\phi}{\\partial\\xi^i}d\\xi^i = (\\nabla \\phi \\cdot \\boldsymbol{a}_j) d\\xi^j$$\nSince the differentials $d\\xi^i$ form a basis for $1$-forms in the computational space, they are independent. Therefore, we can equate the coefficients of corresponding differentials. To avoid index collision, we write:\n$$\\frac{\\partial\\phi}{\\partial\\xi^i} = \\nabla \\phi \\cdot \\boldsymbol{a}_i$$\nThis equation gives the projection of the gradient vector onto the covariant basis vectors $\\boldsymbol{a}_i$. To express the vector $\\nabla \\phi$ itself, we introduce the reciprocal (or contravariant) basis, denoted by $\\boldsymbol{a}^j$, which is defined by the property:\n$$\\boldsymbol{a}^j \\cdot \\boldsymbol{a}_i = \\delta^j_i$$\nwhere $\\delta^j_i$ is the Kronecker delta. Any vector in the physical space can be expanded in terms of this reciprocal basis. We write the gradient vector as:\n$$\\nabla \\phi = C_j \\boldsymbol{a}^j$$\nwhere $C_j$ are the contravariant components of the gradient. To find these components, we take the dot product of the above expression with $\\boldsymbol{a}_i$:\n$$\\nabla \\phi \\cdot \\boldsymbol{a}_i = (C_j \\boldsymbol{a}^j) \\cdot \\boldsymbol{a}_i = C_j (\\boldsymbol{a}^j \\cdot \\boldsymbol{a}_i) = C_j \\delta^j_i = C_i$$\nComparing this with our earlier result, we find that the components are precisely the partial derivatives of $\\phi$:\n$$C_i = \\frac{\\partial\\phi}{\\partial\\xi^i}$$\nSubstituting this back into the expansion for $\\nabla \\phi$, we obtain the general expression for the gradient in arbitrary curvilinear coordinates:\n$$\\nabla \\phi = \\frac{\\partial\\phi}{\\partial\\xi^i} \\boldsymbol{a}^i$$\nNext, we simplify this expression for an orthogonal coordinate system. The orthogonality condition is $g_{ij} = \\boldsymbol{a}_i \\cdot \\boldsymbol{a}_j = 0$ for $i \\neq j$. The diagonal elements of the metric tensor are $g_{ii} = \\boldsymbol{a}_i \\cdot \\boldsymbol{a}_i$ (no summation on $i$).\n\nThe relationship between the reciprocal basis $\\boldsymbol{a}^j$ and the covariant basis $\\boldsymbol{a}_k$ is given by $\\boldsymbol{a}^j = g^{jk}\\boldsymbol{a}_k$, where $g^{jk}$ is the inverse of the metric tensor, $g_{ik}g^{kj} = \\delta^j_i$. For a diagonal metric tensor, the inverse is also diagonal, with components $g^{jj} = 1/g_{jj}$ (no summation) and $g^{jk}=0$ for $j \\neq k$.\nTherefore, for an orthogonal system, the sum for $\\boldsymbol{a}^j$ simplifies:\n$$\\boldsymbol{a}^j = g^{j1}\\boldsymbol{a}_1 + g^{j2}\\boldsymbol{a}_2 + g^{j3}\\boldsymbol{a}_3 = g^{jj}\\boldsymbol{a}_j = \\frac{1}{g_{jj}}\\boldsymbol{a}_j$$\n(no summation on $j$).\nSubstituting this simplified form of the reciprocal basis into our general gradient expression:\n$$\\nabla \\phi = \\sum_{i=1}^{3} \\frac{\\partial\\phi}{\\partial\\xi^i} \\boldsymbol{a}^i = \\sum_{i=1}^{3} \\frac{\\partial\\phi}{\\partial\\xi^i} \\left(\\frac{1}{g_{ii}}\\boldsymbol{a}_i\\right)$$\nFinally, we introduce the scale factors $h_i = \\sqrt{g_{ii}}$ and the orthonormal basis vectors $\\boldsymbol{e}_i = \\boldsymbol{a}_i/h_i$. From these definitions, we have $g_{ii} = h_i^2$ and $\\boldsymbol{a}_i = h_i \\boldsymbol{e}_i$. Substituting these into the expression for the gradient:\n$$\\nabla \\phi = \\sum_{i=1}^{3} \\frac{\\partial\\phi}{\\partial\\xi^i} \\left(\\frac{1}{h_i^2}}(h_i \\boldsymbol{e}_i)\\right) = \\sum_{i=1}^{3} \\frac{\\partial\\phi}{\\partial\\xi^i} \\left(\\frac{1}{h_i}\\boldsymbol{e}_i\\right)$$\nThis yields the final simplified expression for the gradient in orthogonal curvilinear coordinates:\n$$\\nabla \\phi = \\frac{1}{h_1}\\frac{\\partial\\phi}{\\partial\\xi^1}\\boldsymbol{e}_1 + \\frac{1}{h_2}\\frac{\\partial\\phi}{\\partial\\xi^2}\\boldsymbol{e}_2 + \\frac{1}{h_3}\\frac{\\partial\\phi}{\\partial\\xi^3}\\boldsymbol{e}_3$$", "answer": "$$\n\\boxed{\\sum_{i=1}^{3} \\frac{1}{h_i} \\frac{\\partial \\phi}{\\partial \\xi^i} \\boldsymbol{e}_i}\n$$", "id": "3298892"}, {"introduction": "A critical test for any numerical scheme is its ability to maintain a uniform flow without generating spurious forces, a property known as free-stream preservation. This practice explores what happens when the chain-rule treatment of transformed derivatives is applied incorrectly. By analyzing a deliberately flawed transformation of the advection operator in a uniform flow field [@problem_id:3298873], you will uncover how neglecting the spatial variation of the coordinate basis vectors generates non-physical \"metric source terms,\" providing a clear and concrete illustration of why a rigorous application of vector calculus is essential.", "problem": "A central requirement in computational fluid dynamics (CFD) is that a constant free-stream solution remain a solution after transforming the governing equations to curvilinear coordinates. Consider the two-dimensional, steady, inviscid momentum balance in primitive variables for a fluid with constant density and pressure, so that the physical-space material acceleration of the velocity field must vanish for a uniform free-stream. Let the physical space be mapped to a curvilinear coordinate system by the smooth bijection defined by the polar transformation\n$$\nx = r \\cos\\theta,\\qquad y = r \\sin\\theta,\n$$\nwith computational coordinates $(r,\\theta)$ covering a simply connected annular region where $r>0$.\n\nImpose a uniform free-stream in Cartesian coordinates, given by\n$$\nu(x,y) = U_0,\\qquad v(x,y) = 0,\n$$\nwith $U_0$ a positive constant, and with constant density and pressure fields. The exact physical-space material acceleration of this field is identically zero.\n\nNow, suppose one attempts to write a non-conservative transformed advective form in $(r,\\theta)$ by applying the chain rule only to the scalar component fields, while incorrectly holding the curvilinear basis vectors fixed (that is, ignoring their $\\theta$-dependence). In that naive procedure, the radial component of the material acceleration is approximated by the directional derivative of the radial component along the velocity vector expressed in $(r,\\theta)$, formed only from partial derivatives of the scalar component fields $u_r(r,\\theta)$ and $u_\\theta(r,\\theta)$.\n\nUsing only fundamental definitions and the chain rule, do the following:\n\n- Express the uniform Cartesian free-stream $(u,v)$ in terms of its curvilinear components $(u_r,u_\\theta)$ associated with the polar basis at $(r,\\theta)$.\n- Construct the naive non-conservative transformed radial advective residual $S_r(r,\\theta)$ obtained by differentiating only the scalar components while treating the polar basis as fixed. Evaluate $S_r(r,\\theta)$ explicitly for the given free-stream.\n- Briefly identify, at the level of first principles, which derivatives were omitted by this naive procedure and why they cannot be neglected in a correct transformed formulation.\n\nYour final answer must be the single explicit closed-form expression for $S_r(r,\\theta)$ in terms of $r$, $\\theta$, and $U_0$. Do not include units in your final answer, and do not round or approximate.", "solution": "The problem statement is critically validated and found to be valid. It is a well-posed, scientifically grounded problem in vector calculus and computational fluid dynamics that asks for the calculation of a specific term resulting from an intentionally flawed procedure to highlight a common error in coordinate transformations.\n\nThe solution proceeds in three parts as requested.\n\nFirst, we express the uniform Cartesian free-stream velocity vector in terms of its curvilinear components in the polar coordinate system $(r, \\theta)$. The Cartesian velocity field is given by $\\vec{V} = u\\hat{i} + v\\hat{j}$, where $u(x,y) = U_0$ and $v(x,y) = 0$. Thus, the velocity vector is constant in physical space: $\\vec{V} = U_0\\hat{i}$.\n\nThe polar coordinate basis vectors, $\\hat{e}_r$ and $\\hat{e}_\\theta$, can be expressed in terms of the Cartesian basis vectors, $\\hat{i}$ and $\\hat{j}$, as:\n$$\n\\hat{e}_r = \\cos\\theta \\hat{i} + \\sin\\theta \\hat{j}\n$$\n$$\n\\hat{e}_\\theta = -\\sin\\theta \\hat{i} + \\cos\\theta \\hat{j}\n$$\nThe velocity vector $\\vec{V}$ can be expressed in the polar basis as $\\vec{V} = u_r \\hat{e}_r + u_\\theta \\hat{e}_\\theta$. The scalar components, $u_r$ and $u_\\theta$, are found by projecting $\\vec{V}$ onto the polar basis vectors:\n$$\nu_r(r,\\theta) = \\vec{V} \\cdot \\hat{e}_r = (U_0\\hat{i}) \\cdot (\\cos\\theta \\hat{i} + \\sin\\theta \\hat{j}) = U_0 \\cos\\theta\n$$\n$$\nu_\\theta(r,\\theta) = \\vec{V} \\cdot \\hat{e}_\\theta = (U_0\\hat{i}) \\cdot (-\\sin\\theta \\hat{i} + \\cos\\theta \\hat{j}) = -U_0 \\sin\\theta\n$$\nThese are the curvilinear components of the uniform free-stream velocity field. Note that they are functions of the coordinate $\\theta$.\n\nSecond, we construct and evaluate the naive non-conservative transformed radial advective residual, $S_r(r,\\theta)$. The problem states this is formed by applying the directional derivative along the velocity vector to the scalar radial velocity component, $u_r$, while incorrectly treating the basis vectors as constant. This corresponds to calculating $(\\vec{V} \\cdot \\nabla) u_r$.\n\nThe gradient operator $\\nabla$ in polar coordinates is given by:\n$$\n\\nabla = \\hat{e}_r \\frac{\\partial}{\\partial r} + \\hat{e}_\\theta \\frac{1}{r} \\frac{\\partial}{\\partial \\theta}\n$$\nThe velocity vector is $\\vec{V} = u_r \\hat{e}_r + u_\\theta \\hat{e}_\\theta$. The advective operator, or directional derivative along $\\vec{V}$, is therefore:\n$$\n\\vec{V} \\cdot \\nabla = (u_r \\hat{e}_r + u_\\theta \\hat{e}_\\theta) \\cdot \\left( \\hat{e}_r \\frac{\\partial}{\\partial r} + \\hat{e}_\\theta \\frac{1}{r} \\frac{\\partial}{\\partial \\theta} \\right) = u_r \\frac{\\partial}{\\partial r} + \\frac{u_\\theta}{r} \\frac{\\partial}{\\partial \\theta}\n$$\nThe naive radial residual $S_r$ is this operator applied to the scalar field $u_r(r,\\theta)$:\n$$\nS_r(r,\\theta) = (\\vec{V} \\cdot \\nabla) u_r = u_r \\frac{\\partial u_r}{\\partial r} + \\frac{u_\\theta}{r} \\frac{\\partial u_r}{\\partial \\theta}\n$$\nTo evaluate this expression, we need the partial derivatives of $u_r = U_0 \\cos\\theta$:\n$$\n\\frac{\\partial u_r}{\\partial r} = \\frac{\\partial}{\\partial r} (U_0 \\cos\\theta) = 0\n$$\n$$\n\\frac{\\partial u_r}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (U_0 \\cos\\theta) = -U_0 \\sin\\theta\n$$\nSubstituting the components $u_r$, $u_\\theta$, and the partial derivatives into the expression for $S_r$:\n$$\nS_r(r,\\theta) = (U_0 \\cos\\theta)(0) + \\frac{-U_0 \\sin\\theta}{r} (-U_0 \\sin\\theta)\n$$\n$$\nS_r(r,\\theta) = \\frac{U_0^2 \\sin^2\\theta}{r}\n$$\nThis non-zero residual is an artifact of the incorrect transformation procedure. For a uniform flow, all components of the material acceleration must be identically zero.\n\nThird, we identify the derivatives omitted by the naive procedure. The correct radial component of the material acceleration, $a_r$, is the radial component of the full vector derivative $(\\vec{V} \\cdot \\nabla)\\vec{V}$. The naive procedure errs by not applying the product rule of differentiation to the full vector expression $\\vec{V} = u_r \\hat{e}_r + u_\\theta \\hat{e}_\\theta$. The full derivative is:\n$$\n(\\vec{V} \\cdot \\nabla)\\vec{V} = (\\vec{V} \\cdot \\nabla) (u_r \\hat{e}_r + u_\\theta \\hat{e}_\\theta) = [(\\vec{V} \\cdot \\nabla)u_r] \\hat{e}_r + [(\\vec{V} \\cdot \\nabla)u_\\theta] \\hat{e}_\\theta + u_r [(\\vec{V} \\cdot \\nabla)\\hat{e}_r] + u_\\theta [(\\vec{V} \\cdot \\nabla)\\hat{e}_\\theta]\n$$\nThe naive procedure only considers the term $[(\\vec{V} \\cdot \\nabla)u_r] \\hat{e}_r$, whose scalar part is $S_r$. The omitted terms arise because the basis vectors $\\hat{e}_r$ and $\\hat{e}_\\theta$ are themselves functions of position (specifically, $\\theta$), and thus have non-zero spatial derivatives. The omitted derivatives are precisely the derivatives of the basis vectors, $(\\vec{V} \\cdot \\nabla)\\hat{e}_r$ and $(\\vec{V} \\cdot \\nabla)\\hat{e}_\\theta$.\nExplicitly, the key derivative of a basis vector is:\n$$\n\\frac{\\partial \\hat{e}_r}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (\\cos\\theta \\hat{i} + \\sin\\theta \\hat{j}) = -\\sin\\theta \\hat{i} + \\cos\\theta \\hat{j} = \\hat{e}_\\theta\n$$\nAnd similarly, $\\frac{\\partial \\hat{e}_\\theta}{\\partial \\theta} = -\\hat{e}_r$. The naive procedure incorrectly assumes these derivatives are zero. These terms, often called \"metric terms\" or related to Christoffel symbols, account for the curvature of the coordinate lines. The radial component of acceleration, $a_r$, is correctly given by:\n$$\na_r = u_r \\frac{\\partial u_r}{\\partial r} + \\frac{u_\\theta}{r} \\frac{\\partial u_r}{\\partial \\theta} - \\frac{u_\\theta^2}{r}\n$$\nThe term $-\\frac{u_\\theta^2}{r}$ arises directly from the derivatives of the basis vectors. We can verify that for the uniform free-stream, the true acceleration is zero:\n$$\na_r = S_r - \\frac{u_\\theta^2}{r} = \\frac{U_0^2 \\sin^2\\theta}{r} - \\frac{(-U_0 \\sin\\theta)^2}{r} = \\frac{U_0^2 \\sin^2\\theta}{r} - \\frac{U_0^2 \\sin^2\\theta}{r} = 0\n$$\nThus, the naive procedure fails because it neglects the spatial derivatives of the curvilinear basis vectors, violating the product rule of differentiation for vectors and leading to a spurious, non-zero acceleration.", "answer": "$$\n\\boxed{\\frac{U_0^2 \\sin^2\\theta}{r}}\n$$", "id": "3298873"}, {"introduction": "The ultimate goal of transforming derivatives is to formulate conservation laws in a way that remains valid for numerical discretization on arbitrary grids. This hands-on coding exercise bridges the gap between analytical theory and computational practice by exploring the concept of the Geometric Conservation Law (GCL). You will implement and compare two different numerical treatments of the continuity equation [@problem_id:3298902]: a \"conservative\" form that respects the integral nature of the conservation law, and a naive \"non-conservative\" form. The results will vividly demonstrate why only the conservative formulation guarantees mass conservation on non-orthogonal grids, a cornerstone principle of modern finite volume methods.", "problem": "In Computational Fluid Dynamics (CFD), conservation properties hinge on how transformed derivatives are handled under curvilinear mappings. Consider a two-dimensional (2D) periodic computational domain $\\{(\\xi,\\eta)\\mid \\xi\\in[0,2\\pi),\\ \\eta\\in[0,2\\pi)\\}$ with angles measured in radians. A smooth curvilinear mapping from computational coordinates $(\\xi,\\eta)$ to physical coordinates $(x,y)$ is defined by the smooth functions $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$, and the Jacobian determinant $J(\\xi,\\eta)$ of this mapping satisfies $J(\\xi,\\eta)\\neq 0$ everywhere. Let the scalar field be $\\phi(x,y)$ and the physical velocity field be $\\boldsymbol{u}(x,y)=(u_x(x,y),u_y(x,y))$. The continuity equation expresses mass conservation through the divergence of the mass flux $\\nabla\\cdot(\\phi\\boldsymbol{u})$. A correct transformation to computational coordinates must respect the Geometric Conservation Law (GCL) to preserve mass under arbitrary smooth mesh mappings.\n\nStarting only from first principles appropriate to this context, namely: (i) the definition of divergence, (ii) the chain rule for products and for coordinate transformations, (iii) the definition of the Jacobian determinant and metric relations under a smooth mapping, and (iv) the divergence theorem for periodic domains, you must:\n\n- Derive transformation relations needed to express $\\nabla\\cdot(\\phi\\boldsymbol{u})$ in terms of computational derivatives with respect to $\\xi$ and $\\eta$ and appropriate metric quantities. Explain, from first principles, why a formulation that treats the divergence in conservative form at the discrete level corresponds to telescoping flux differences and therefore preserves the integral of mass over a periodic domain, whereas a naively split nonconservative chain-rule treatment can violate this property under nonorthogonal mappings.\n\n- Implement a program that, on a uniform periodic grid in $(\\xi,\\eta)$, evaluates the integral mass defect\n$$\n\\mathcal{M}=\\iint_{[0,2\\pi)\\times[0,2\\pi)} J(\\xi,\\eta)\\,\\nabla\\cdot(\\phi\\boldsymbol{u})\\ d\\xi\\,d\\eta\n$$\nnumerically using second-order central differences in $(\\xi,\\eta)$ for two formulations:\n    1. A conservative transformed divergence that applies the derivative to the combined flux in computational space and respects flux telescoping under periodic boundary conditions.\n    2. A deliberately naive nonconservative split of the divergence operator itself, specifically treating $\\partial/\\partial x$ as $(1/x_\\xi)\\,\\partial/\\partial \\xi$ and $\\partial/\\partial y$ as $(1/y_\\eta)\\,\\partial/\\partial \\eta$, and applying these to the flux components while ignoring cross-derivative couplings due to $x_\\eta$ and $y_\\xi$. This naive split is known to be incorrect under nonorthogonal mappings but serves to construct a counterexample.\n\nYour program must use the following scientifically realistic and self-consistent test suite with smooth fields:\n\n- Mapping family parameterized by curvature amplitude $\\kappa$:\n$$\nx(\\xi,\\eta)=\\xi+\\kappa\\sin(\\xi)\\sin(\\eta),\\qquad y(\\xi,\\eta)=\\eta+\\kappa\\cos(\\xi)\\sin(\\eta),\n$$\nwith corresponding smooth derivatives $x_\\xi(\\xi,\\eta)$, $x_\\eta(\\xi,\\eta)$, $y_\\xi(\\xi,\\eta)$, $y_\\eta(\\xi,\\eta)$ and Jacobian $J(\\xi,\\eta)=x_\\xi y_\\eta - x_\\eta y_\\xi$.\n\n- Velocity defined by a streamfunction $\\psi(x,y)=\\sin(x)\\sin(y)$, so that\n$$\nu_x(x,y)=\\frac{\\partial\\psi}{\\partial y}(x,y)=\\cos(y)\\sin(x),\\qquad\nu_y(x,y)=-\\frac{\\partial\\psi}{\\partial x}(x,y)=-\\cos(x)\\sin(y).\n$$\nThis yields a physically divergence-free velocity in $(x,y)$.\n\n- Scalar field\n$$\n\\phi(x,y)=1+\\alpha\\cos(2x)\\sin(y),\n$$\nwith amplitude $\\alpha$ specified per test case.\n\nUse second-order central differences on the uniform computational grid to approximate derivatives with respect to $\\xi$ and $\\eta$, and enforce periodic boundary conditions.\n\nFor each test case, compute and report two floats: the absolute value of the integral mass defect $\\mathcal{M}$ for the conservative formulation and for the naive nonconservative split, respectively. Compute the integral numerically as the discrete sum\n$$\n\\mathcal{M}\\approx \\sum_{i=0}^{N_\\xi-1}\\sum_{j=0}^{N_\\eta-1} J_{ij}\\,\\left[\\nabla\\cdot(\\phi\\boldsymbol{u})\\right]_{ij}\\ \\Delta\\xi\\ \\Delta\\eta,\n$$\nwhere $N_\\xi$ and $N_\\eta$ are the number of grid points in $\\xi$ and $\\eta$, and $\\Delta\\xi=2\\pi/N_\\xi$, $\\Delta\\eta=2\\pi/N_\\eta$. Angles are in radians.\n\nTest suite parameter values:\n\n- Case $1$ (baseline orthogonal mapping): $N_\\xi=N_\\eta=64$, $\\kappa=0$, $\\alpha=0.2$.\n- Case $2$ (moderate curvature mapping): $N_\\xi=N_\\eta=64$, $\\kappa=0.3$, $\\alpha=0.2$.\n- Case $3$ (strong curvature with coarse grid): $N_\\xi=N_\\eta=16$, $\\kappa=0.7$, $\\alpha=0.5$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list holding the two floats for the conservative and naive nonconservative mass defects, rounded to ten decimal places, for the three cases in order. For example, the printed line must be of the form\n$$\n[[m_{c,1},m_{n,1}],[m_{c,2},m_{n,2}],[m_{c,3},m_{n,3}]],\n$$\nwhere each $m_{(\\cdot,\\cdot)}$ is a float rounded to ten decimal places.", "solution": "The problem requires the derivation of the conservative form of the divergence operator under a coordinate transformation and a numerical demonstration of its importance for mass conservation compared to a naive, nonconservative approximation. The validation process confirms the problem statement is scientifically sound, well-posed, and objective. We proceed with the solution.\n\nThe core task is to transform the physical-space continuity equation, represented by the divergence of the mass flux $\\nabla\\cdot(\\phi\\boldsymbol{u})$, into the computational space $(\\xi, \\eta)$.\n\nIn Cartesian coordinates $(x,y)$, the divergence of the mass flux vector $\\phi\\boldsymbol{u} = (\\phi u_x, \\phi u_y)$ is defined as:\n$$\n\\nabla\\cdot(\\phi\\boldsymbol{u}) = \\frac{\\partial(\\phi u_x)}{\\partial x} + \\frac{\\partial(\\phi u_y)}{\\partial y}\n$$\n\nA smooth, invertible mapping from computational coordinates $(\\xi, \\eta)$ to physical coordinates $(x,y)$ is given by the functions $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$. The chain rule provides the relationship between the partial derivative operators in the two coordinate systems:\n$$\n\\begin{pmatrix} \\partial/\\partial\\xi \\\\ \\partial/\\partial\\eta \\end{pmatrix}\n=\n\\begin{pmatrix} x_\\xi  y_\\xi \\\\ x_\\eta  y_\\eta \\end{pmatrix}\n\\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix}\n$$\nwhere $x_\\xi = \\partial x/\\partial\\xi$, $y_\\xi = \\partial y/\\partial\\xi$, and so on. To express the physical-space derivatives in terms of computational-space derivatives, we must invert this matrix relationship. The determinant of the transformation matrix is the Jacobian determinant $J = x_\\xi y_\\eta - x_\\eta y_\\xi$, which is given to be non-zero. The inverse transformation is:\n$$\n\\begin{pmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{pmatrix}\n=\n\\frac{1}{J}\n\\begin{pmatrix} y_\\eta  -y_\\xi \\\\ -x_\\eta  x_\\xi \\end{pmatrix}\n\\begin{pmatrix} \\partial/\\partial\\xi \\\\ \\partial/\\partial\\eta \\end{pmatrix}\n$$\nThis provides the metric relations for the derivative operators:\n$$\n\\frac{\\partial}{\\partial x} = \\frac{1}{J} \\left( y_\\eta \\frac{\\partial}{\\partial \\xi} - y_\\xi \\frac{\\partial}{\\partial \\eta} \\right)\n\\qquad \\text{and} \\qquad\n\\frac{\\partial}{\\partial y} = \\frac{1}{J} \\left( -x_\\eta \\frac{\\partial}{\\partial \\xi} + x_\\xi \\frac{\\partial}{\\partial \\eta} \\right)\n$$\n\nSubstituting these relations into the divergence expression yields:\n$$\n\\nabla\\cdot(\\phi\\boldsymbol{u}) = \\frac{1}{J} \\left( y_\\eta \\frac{\\partial(\\phi u_x)}{\\partial \\xi} - y_\\xi \\frac{\\partial(\\phi u_x)}{\\partial \\eta} \\right) + \\frac{1}{J} \\left( -x_\\eta \\frac{\\partial(\\phi u_y)}{\\partial \\xi} + x_\\xi \\frac{\\partial(\\phi u_y)}{\\partial \\eta} \\right)\n$$\nMultiplying by the Jacobian $J$ and rearranging terms based on the derivative operators:\n$$\nJ\\,\\nabla\\cdot(\\phi\\boldsymbol{u}) = \\left( y_\\eta \\frac{\\partial(\\phi u_x)}{\\partial \\xi} - x_\\eta \\frac{\\partial(\\phi u_y)}{\\partial \\xi} \\right) + \\left( x_\\xi \\frac{\\partial(\\phi u_y)}{\\partial \\eta} - y_\\xi \\frac{\\partial(\\phi u_x)}{\\partial \\eta} \\right)\n$$\nUsing the product rule, for example $y_\\eta \\frac{\\partial(\\phi u_x)}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(y_\\eta \\phi u_x) - (\\phi u_x) \\frac{\\partial y_\\eta}{\\partial \\xi}$, we can rewrite the expression to group terms inside the derivatives:\n$$\nJ\\,\\nabla\\cdot(\\phi\\boldsymbol{u}) = \\frac{\\partial}{\\partial \\xi}\\left( \\phi (u_x y_\\eta - u_y x_\\eta) \\right) + \\frac{\\partial}{\\partial \\eta}\\left( \\phi (u_y x_\\xi - u_x y_\\xi) \\right) + \\mathcal{R}\n$$\nwhere the remainder term $\\mathcal{R}$ contains the derivatives of the metric terms:\n$$\n\\mathcal{R} = -\\phi u_x \\frac{\\partial y_\\eta}{\\partial \\xi} + \\phi u_y \\frac{\\partial x_\\eta}{\\partial \\xi} - \\phi u_y \\frac{\\partial x_\\xi}{\\partial \\eta} + \\phi u_x \\frac{\\partial y_\\xi}{\\partial \\eta} = \\phi u_x \\left( \\frac{\\partial y_\\xi}{\\partial \\eta} - \\frac{\\partial y_\\eta}{\\partial \\xi} \\right) + \\phi u_y \\left( \\frac{\\partial x_\\eta}{\\partial \\xi} - \\frac{\\partial x_\\xi}{\\partial \\eta} \\right)\n$$\nFor a smooth mapping, the order of differentiation does not matter (Clairaut's theorem on equality of mixed partials), so $\\partial y_\\xi/\\partial \\eta = \\partial^2 y/\\partial\\eta\\partial\\xi = \\partial^2 y/\\partial\\xi\\partial\\eta = \\partial y_\\eta/\\partial\\xi$, and similarly for $x$. Thus, the terms in parentheses are identically zero, so $\\mathcal{R}=0$. This crucial result is known as the Geometric Conservation Law (GCL) identity.\n\nThe final expression is the divergence in strong conservative form:\n$$\nJ\\,\\nabla\\cdot(\\phi\\boldsymbol{u}) = \\frac{\\partial}{\\partial \\xi}\\left( F_\\xi \\right) + \\frac{\\partial}{\\partial \\eta}\\left( F_\\eta \\right)\n$$\nwhere $F_\\xi = \\phi(u_x y_\\eta - u_y x_\\eta)$ and $F_\\eta = \\phi(u_y x_\\xi - u_x y_\\xi)$ are the conservative mass fluxes in the computational $(\\xi, \\eta)$ directions.\n\nThe integral mass defect is $\\mathcal{M}=\\iint J(\\xi,\\eta)\\,\\nabla\\cdot(\\phi\\boldsymbol{u})\\ d\\xi\\,d\\eta$ over the periodic domain $[0,2\\pi)\\times[0,2\\pi)$. Using the conservative form:\n$$\n\\mathcal{M} = \\int_0^{2\\pi} \\int_0^{2\\pi} \\left(\\frac{\\partial F_\\xi}{\\partial \\xi} + \\frac{\\partial F_\\eta}{\\partial \\eta}\\right) d\\xi\\,d\\eta\n$$\nBy the fundamental theorem of calculus and the periodicity of all fields (e.g., $F_\\xi(\\xi=0, \\eta) = F_\\xi(\\xi=2\\pi, \\eta)$), the integral of a perfect derivative over a periodic interval is zero. Thus, $\\mathcal{M}=0$ analytically.\n\nDiscretely, approximating the derivatives with a scheme like central differencing, $\\left(\\frac{\\partial F}{\\partial\\xi}\\right)_i \\approx \\frac{F_{i+1} - F_{i-1}}{2\\Delta\\xi}$, the sum of all such derivatives over the periodic grid becomes a telescoping sum. For any grid row $j$:\n$$\n\\sum_{i=0}^{N_\\xi-1} \\left(\\frac{\\partial F_\\xi}{\\partial \\xi}\\right)_{ij} \\approx \\frac{1}{2\\Delta\\xi} \\sum_{i=0}^{N_\\xi-1} ( (F_\\xi)_{i+1,j} - (F_\\xi)_{i-1,j} ) = 0\n$$\ndue to cancellation from periodic boundary conditions (e.g., $F_{-1,j} = F_{N_\\xi-1, j}$ and $F_{N_\\xi,j} = F_{0,j}$). This \"flux telescoping\" property ensures that the discrete sum over the entire domain is zero up to machine precision, thereby preserving mass discretely. This is the hallmark of a conservative numerical scheme.\n\nConversely, the prescribed naive nonconservative split approximates the divergence as:\n$$\n[\\nabla\\cdot(\\phi\\boldsymbol{u})]_{\\text{naive}} = \\frac{1}{x_\\xi} \\frac{\\partial(\\phi u_x)}{\\partial \\xi} + \\frac{1}{y_\\eta} \\frac{\\partial(\\phi u_y)}{\\partial \\eta}\n$$\nThis formulation incorrectly assumes that the grid is orthogonal, ignoring the metric terms $x_\\eta$ and $y_\\xi$. The integral becomes:\n$$\n\\mathcal{M}_{\\text{naive}} = \\iint J \\left( \\frac{1}{x_\\xi} \\frac{\\partial(\\phi u_x)}{\\partial \\xi} + \\frac{1}{y_\\eta} \\frac{\\partial(\\phi u_y)}{\\partial \\eta} \\right) d\\xi\\,d\\eta\n$$\nThis expression cannot be written in a conservative (or divergence) form. The terms inside the integral are, for instance, $\\frac{J}{x_\\xi}\\frac{\\partial(\\phi u_x)}{\\partial \\xi}$. Integrating by parts would yield a boundary term that vanishes due to periodicity, but also a source term $-\\iint (\\phi u_x) \\frac{\\partial}{\\partial\\xi}\\left(\\frac{J}{x_\\xi}\\right) d\\xi d\\eta$, which is not guaranteed to be zero. When the grid is non-orthogonal (i.e., $\\kappa \\neq 0$), the metric coefficients $J$, $x_\\xi$, etc., are not constant, and this integral will be non-zero, leading to a spurious numerical creation or destruction of mass. The only case where this form is correct is when the mapping is orthogonal, $x=x(\\xi), y=y(\\eta)$, which for the provided family means $\\kappa=0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef central_diff(field: np.ndarray, axis: int, delta: float) -> np.ndarray:\n    \"\"\"\n    Computes the second-order central difference of a 2D array along a given axis,\n    assuming periodic boundary conditions.\n\n    Args:\n        field: The 2D numpy array.\n        axis: The axis along which to differentiate (0 for xi, 1 for eta).\n        delta: The grid spacing in that direction.\n\n    Returns:\n        A 2D numpy array of the computed derivatives.\n    \"\"\"\n    return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * delta)\n\ndef compute_mass_defect(N: int, kappa: float, alpha: float) -> list[float]:\n    \"\"\"\n    Computes the integral mass defect for both conservative and naive formulations.\n\n    Args:\n        N: The number of grid points in each direction (N_xi = N_eta = N).\n        kappa: The curvature amplitude of the grid mapping.\n        alpha: The amplitude of the scalar field.\n\n    Returns:\n        A list containing two floats: the absolute mass defect for the\n        conservative and naive formulations, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Grid Setup\n    N_xi, N_eta = N, N\n    d_xi = 2.0 * np.pi / N_xi\n    d_eta = 2.0 * np.pi / N_eta\n\n    xi_1d = np.linspace(0.0, 2.0 * np.pi, N_xi, endpoint=False)\n    eta_1d = np.linspace(0.0, 2.0 * np.pi, N_eta, endpoint=False)\n    # 'ij' indexing ensures that xi corresponds to axis 0 and eta to axis 1.\n    xi, eta = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n    # 2. Compute Mapping, Metrics, and Physical Fields\n    # Mapping to physical coordinates\n    x = xi + kappa * np.sin(xi) * np.sin(eta)\n    y = eta + kappa * np.cos(xi) * np.sin(eta)\n\n    # Analytical metric terms\n    x_xi = 1.0 + kappa * np.cos(xi) * np.sin(eta)\n    x_eta = kappa * np.sin(xi) * np.cos(eta)\n    y_xi = -kappa * np.sin(xi) * np.sin(eta)\n    y_eta = 1.0 + kappa * np.cos(xi) * np.cos(eta)\n    \n    # Jacobian determinant\n    J = x_xi * y_eta - x_eta * y_xi\n\n    # Physical fields evaluated on the grid\n    phi = 1.0 + alpha * np.cos(2.0 * x) * np.sin(y)\n    u_x = np.sin(x) * np.cos(y)\n    u_y = -np.cos(x) * np.sin(y)\n\n    # 3. Conservative Formulation\n    # Transformed conservative mass fluxes\n    F_xi = phi * (u_x * y_eta - u_y * x_eta)\n    F_eta = phi * (u_y * x_xi - u_x * y_xi)\n\n    # Compute derivatives of fluxes\n    dFxi_dxi = central_diff(F_xi, axis=0, delta=d_xi)\n    dFeta_deta = central_diff(F_eta, axis=1, delta=d_eta)\n    \n    # The term J * div(phi*u) is exactly dFxi/dxi + dFeta/deta\n    integrand_c = dFxi_dxi + dFeta_deta\n    \n    # Integrate by summing over the domain and multiplying by cell area\n    M_c = np.sum(integrand_c) * d_xi * d_eta\n\n    # 4. Naive Nonconservative Formulation\n    # Physical mass fluxes\n    f_x = phi * u_x\n    f_y = phi * u_y\n\n    # Differentiate physical fluxes w.r.t. computational coordinates\n    dfx_dxi = central_diff(f_x, axis=0, delta=d_xi)\n    dfy_deta = central_diff(f_y, axis=1, delta=d_eta)\n    \n    # Construct the naive divergence approximation\n    naive_div = (1.0 / x_xi) * dfx_dxi + (1.0 / y_eta) * dfy_deta\n    \n    # The integrand is J * (naive divergence)\n    integrand_n = J * naive_div\n    \n    # Integrate by summing\n    M_n = np.sum(integrand_n) * d_xi * d_eta\n    \n    return [round(abs(M_c), 10), round(abs(M_n), 10)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, kappa, alpha)\n        (64, 0.0, 0.2), # Case 1: Baseline orthogonal mapping\n        (64, 0.3, 0.2), # Case 2: Moderate curvature mapping\n        (16, 0.7, 0.5), # Case 3: Strong curvature, coarse grid\n    ]\n\n    results = []\n    for N, kappa, alpha in test_cases:\n        result = compute_mass_defect(N, kappa, alpha)\n        results.append(result)\n\n    # Format the output string exactly as specified.\n    outer_list_str = []\n    for res_pair in results:\n        # Format each float to 10 decimal places.\n        inner_list_str = f\"[{res_pair[0]:.10f},{res_pair[1]:.10f}]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3298902"}]}