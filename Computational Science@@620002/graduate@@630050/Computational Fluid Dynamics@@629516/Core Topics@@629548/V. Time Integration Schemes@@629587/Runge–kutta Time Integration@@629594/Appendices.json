{"hands_on_practices": [{"introduction": "A cornerstone of computational fluid dynamics is ensuring that a numerical simulation does not diverge due to instabilities. This foundational practice connects the choice of time integrator with the properties of the spatial discretization for a model advection-diffusion equation. By performing an eigenvalue analysis, you will determine the maximum stable time step for the classical fourth-order Runge-Kutta method, a critical skill for developing robust and reliable CFD solvers. [@problem_id:3359928]", "problem": "Consider the one-dimensional linear advection–diffusion Partial Differential Equation (PDE) in Computational Fluid Dynamics (CFD)\n$$\nu_{t}(x,t) + a\\,u_{x}(x,t) = \\nu\\,u_{xx}(x,t),\n$$\nwith constant advection speed $a>0$ and kinematic viscosity $\\nu>0$, on the periodic domain $x \\in [0,L]$. Discretize space on a uniform grid $x_{j} = j h$ for $j=0,1,\\ldots,N-1$ with spacing $h = L/N$, and denote by $y_{j}(t) \\equiv u(x_{j},t)$ the nodal solution. Use second-order centered finite differences for $u_{x}$ and $u_{xx}$, and impose periodic boundary conditions. \n\n1. Derive the semi-discrete Ordinary Differential Equation (ODE) system in matrix form $y'(t) = A\\,y(t)$, identifying explicitly the discrete operators that contribute to advection and diffusion. \n\n2. Show that, due to periodicity and uniform spacing, the discrete Fourier modes \n$$\n\\phi_{j}(\\theta) = \\exp(i j \\theta), \\quad \\theta \\in [-\\pi,\\pi],\n$$\nare eigenvectors of the matrix $A$, and derive the corresponding eigenvalues $\\lambda(\\theta)$ as functions of $\\theta$, highlighting the separate advection and diffusion contributions to the real and imaginary parts of $\\lambda(\\theta)$.\n\n3. Consider time integration by the classical explicit fourth-order Runge–Kutta (RK) method. Let the one-step amplification factor be $R(z)$ when applied to the scalar test equation $y'=\\lambda y$. Determine the largest stable timestep $\\Delta t_{\\max}$ such that \n$$\n\\max_{\\theta \\in [-\\pi,\\pi]} \\left| R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right) \\right| \\leq 1.\n$$\nUse the following physical and numerical parameters: $L = 1$ (meters), $N = 128$, $a = 0.2$ (meters per second), and $\\nu = 10^{-3}$ (square meters per second). \n\nRound your final answer for $\\Delta t_{\\max}$ to four significant figures and express it in seconds.", "solution": "The user-provided problem is evaluated as valid based on the specified criteria. It is scientifically grounded in computational fluid dynamics, well-posed, objective, and contains all necessary information for a complete solution.\n\n### Part 1: Derivation of the Semi-Discrete ODE System\n\nThe given one-dimensional linear advection–diffusion equation is:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\nWe discretize the spatial domain $x \\in [0,L]$ using a uniform grid with $N$ points $x_j = j h$ for $j=0, 1, \\ldots, N-1$, where the grid spacing is $h=L/N$. The solution at these grid points is denoted by $y_j(t) = u(x_j, t)$. The semi-discrete form of the PDE is obtained by replacing the spatial derivatives with finite difference approximations.\n\nFor the first spatial derivative, the second-order centered difference is:\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_{x_j} \\approx \\frac{u(x_{j+1}, t) - u(x_{j-1}, t)}{2h} = \\frac{y_{j+1}(t) - y_{j-1}(t)}{2h}\n$$\nFor the second spatial derivative, the second-order centered difference is:\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_j} \\approx \\frac{u(x_{j+1}, t) - 2u(x_j, t) + u(x_{j-1}, t)}{h^2} = \\frac{y_{j+1}(t) - 2y_j(t) + y_{j-1}(t)}{h^2}\n$$\nDue to the periodic domain, the indices are taken modulo $N$, meaning $y_{j+N} = y_j$. For example, $y_{-1} = y_{N-1}$ and $y_N = y_0$.\n\nSubstituting these approximations into the PDE gives a system of ordinary differential equations (ODEs), one for each grid point $j$:\n$$\n\\frac{d y_j}{d t} = -a \\left( \\frac{y_{j+1} - y_{j-1}}{2h} \\right) + \\nu \\left( \\frac{y_{j+1} - 2y_j + y_{j-1}}{h^2} \\right)\n$$\nLet $y(t) = [y_0(t), y_1(t), \\ldots, y_{N-1}(t)]^T$ be the vector of solutions. The system can be written in matrix form as $y'(t) = A y(t)$. We can identify the contributions from advection and diffusion. Let $A = A_{adv} + A_{diff}$.\n\nThe advection operator $A_{adv}$ corresponds to the term $-a u_x$:\n$$\n(A_{adv} y)_j = -\\frac{a}{2h} (y_{j+1} - y_{j-1})\n$$\nThe diffusion operator $A_{diff}$ corresponds to the term $\\nu u_{xx}$:\n$$\n(A_{diff} y)_j = \\frac{\\nu}{h^2} (y_{j+1} - 2y_j + y_{j-1})\n$$\nThe combined operator $A = A_{adv} + A_{diff}$ acts on $y_j$ as:\n$$\n(A y)_j = \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) y_{j+1} - \\frac{2\\nu}{h^2} y_j + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) y_{j-1}\n$$\nThe matrix $A$ is an $N \\times N$ circulant matrix due to the periodic boundary conditions.\n\n### Part 2: Eigenvalue Analysis\n\nWe test if the discrete Fourier modes $\\phi_j(\\theta) = \\exp(ij\\theta)$ are eigenvectors of the matrix $A$. Let the vector $\\phi(\\theta)$ have components $[\\phi_j(\\theta)]_j = \\exp(ij\\theta)$. We apply the operator $A$ to this vector. The $j$-th component of the result is:\n$$\n(A \\phi(\\theta))_j = \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) \\exp(i(j+1)\\theta) - \\frac{2\\nu}{h^2} \\exp(ij\\theta) + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) \\exp(i(j-1)\\theta)\n$$\nFactor out the term $\\exp(ij\\theta)$:\n$$\n(A \\phi(\\theta))_j = \\exp(ij\\theta) \\left[ \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) \\exp(i\\theta) - \\frac{2\\nu}{h^2} + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) \\exp(-i\\theta) \\right]\n$$\nThis shows that $(A \\phi(\\theta))_j = \\lambda(\\theta) \\phi_j(\\theta)$, which confirms that $\\phi(\\theta)$ is an eigenvector of $A$. The corresponding eigenvalue $\\lambda(\\theta)$ is the expression in the brackets:\n$$\n\\lambda(\\theta) = \\frac{\\nu}{h^2} (\\exp(i\\theta) - 2 + \\exp(-i\\theta)) - \\frac{a}{2h} (\\exp(i\\theta) - \\exp(-i\\theta))\n$$\nUsing Euler's identities, $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$ and $\\exp(i\\theta) - \\exp(-i\\theta) = 2i\\sin(\\theta)$, we can simplify $\\lambda(\\theta)$:\n$$\n\\lambda(\\theta) = \\frac{\\nu}{h^2} (2\\cos(\\theta) - 2) - \\frac{a}{2h} (2i\\sin(\\theta))\n$$\n$$\n\\lambda(\\theta) = \\frac{2\\nu}{h^2}(\\cos(\\theta) - 1) - i\\frac{a}{h}\\sin(\\theta)\n$$\nThis expression separates the eigenvalue into its real and imaginary parts.\nThe real part of the eigenvalue arises from the diffusion term:\n$$\n\\text{Re}(\\lambda(\\theta)) = \\frac{2\\nu}{h^2}(\\cos(\\theta) - 1)\n$$\nSince $\\nu > 0$ and $\\cos(\\theta) - 1 \\le 0$, the real part is always non-positive, reflecting the dissipative nature of the diffusion operator.\n\nThe imaginary part of the eigenvalue arises from the advection term:\n$$\n\\text{Im}(\\lambda(\\theta)) = -\\frac{a}{h}\\sin(\\theta)\n$$\nThis is characteristic of the dispersive nature of the centered difference approximation to the advection operator.\n\n### Part 3: Maximum Stable Timestep\n\nThe classical fourth-order Runge-Kutta (RK4) method, when applied to the scalar test equation $y'=\\lambda y$, has an amplification factor given by the Taylor series expansion of the exponential function truncated to the fourth order:\n$$\nR(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\nwhere $z = \\Delta t \\lambda$. For numerical stability, the magnitude of the amplification factor must be no greater than $1$ for all eigenvalues of the system. This gives the condition:\n$$\n\\max_{\\theta \\in [-\\pi,\\pi]} |R(\\Delta t \\lambda(\\theta))| \\le 1\n$$\nThis means that for all $\\theta$, the complex number $z(\\theta) = \\Delta t \\lambda(\\theta)$ must lie within the stability region of the RK4 method. The stability region is the set $S = \\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$.\n\nThe locus of eigenvalues $\\lambda(\\theta)$ for $\\theta \\in [-\\pi, \\pi]$ forms an ellipse in the complex plane, centered at $(-\\frac{2\\nu}{h^2}, 0)$, with semi-axes $\\frac{2\\nu}{h^2}$ (real) and $\\frac{a}{h}$ (imaginary). The locus of $z(\\theta)$ is a scaled version of this ellipse.\n\nThe stability region of the RK4 method intersects the negative real axis at approximately $[-2.785, 0]$ and the imaginary axis at approximately $[-2.828i, 2.828i]$ (more precisely, $[-2\\sqrt{2}i, 2\\sqrt{2}i]$). The stability region is \"pinched\" near the origin along the negative real axis. The eigenvalue ellipse $\\lambda(\\theta)$ is always tangent to the origin at $\\theta=0$. As $\\Delta t$ increases, the scaled ellipse $z(\\theta)$ expands. The first point of this ellipse to exit the stability region will be its leftmost point, which lies on the negative real axis. This point corresponds to the Fourier mode $\\theta = \\pi$.\n\nAt $\\theta = \\pi$, the eigenvalue is purely real:\n$$\n\\lambda(\\pi) = \\frac{2\\nu}{h^2}(\\cos(\\pi) - 1) - i\\frac{a}{h}\\sin(\\pi) = \\frac{2\\nu}{h^2}(-1 - 1) - 0 = -\\frac{4\\nu}{h^2}\n$$\nThis is the eigenvalue with the largest magnitude. The stability condition for this mode is:\n$$\n|\\Delta t \\lambda(\\pi)| \\le S_R\n$$\nwhere $S_R \\approx 2.78529$ is the length of the stability interval of RK4 on the negative real axis. This value is the positive root of $|R(-x)|=1$, specifically $R(-x) = -1$.\n$$\n\\Delta t \\frac{4\\nu}{h^2} \\le S_R\n$$\nThe maximum stable timestep is therefore:\n$$\n\\Delta t_{\\max} = \\frac{S_R h^2}{4\\nu}\n$$\nNow, we substitute the given numerical parameters:\n$L = 1$, $N = 128$, so the grid spacing is $h = L/N = 1/128$.\n$\\nu = 10^{-3}$.\n$S_R \\approx 2.78529$.\n$$\n\\Delta t_{\\max} = \\frac{2.78529 \\times (1/128)^2}{4 \\times 10^{-3}} = \\frac{2.78529}{16384 \\times 4 \\times 10^{-3}} = \\frac{2.78529}{65.536}\n$$\n$$\n\\Delta t_{\\max} \\approx 0.04250333...\n$$\nRounding to four significant figures, we get $\\Delta t_{\\max} = 0.04250$.", "answer": "$$\n\\boxed{0.04250}\n$$", "id": "3359928"}, {"introduction": "While high-order accuracy is desirable, it is not sufficient for many CFD applications, especially those involving shocks or sharp interfaces where physical bounds must be respected. This exercise provides a hands-on coding demonstration of the importance of qualitative properties, such as monotonicity, and the concept of Strong Stability Preserving (SSP) time integrators. By constructing a counterexample, you will see firsthand how a standard high-order scheme can introduce unphysical oscillations, while an SSP method correctly maintains the solution's bounds. [@problem_id:3359952]", "problem": "Consider the scalar linear parabolic conservation law often used in computational fluid dynamics to model diffusion, given by the partial differential equation $u_t = \\kappa u_{xx}$, where $u(t,x)$ is a scalar field, $t$ is time in seconds, $x$ is space in meters, and $\\kappa$ is the diffusivity in $\\mathrm{m}^2/\\mathrm{s}$. A standard semi-discretization in space on a uniform grid with spacing $\\Delta x$ and Dirichlet boundary conditions uses the second-order central difference approximation of the Laplacian. Let $u_i(t)$ denote the approximation of $u(t,x)$ at grid point $x_i$, and define the semi-discrete operator $L(u)$ component-wise by\n$$\nL(u)_i = \\frac{\\kappa}{\\Delta x^2}\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n$$\nfor all interior indices $i$, with boundary indices held fixed to $u_0(t)=0$ and $u_{N-1}(t)=0$ for all time (Dirichlet boundary conditions at the domain endpoints). The explicit Forward Euler method $u^{n+1} = u^n + \\Delta t\\, L(u^n)$ is known to be monotone in the sense of preserving the minimum and maximum bounds of $u$ for sufficiently small time step $\\Delta t$, specifically when the nondimensional parameter $\\mu = \\kappa \\Delta t / \\Delta x^2$ satisfies $\\mu \\leq 1/2$. In contrast, high-order Runge–Kutta methods that are not Strong Stability Preserving (SSP), such as the classical fourth-order Runge–Kutta method, can fail to preserve such bounds even when the spatial discretization is monotone and $\\Delta t$ lies within the Forward Euler monotonicity limit.\n\nYour task is to construct an explicit counterexample that demonstrates the failure of bound preservation when using a non-SSP Runge–Kutta time integrator on a monotone spatial discretization. Use the semi-discrete diffusion operator $L(u)$ above, and implement three time integrators for a single time step of size $\\Delta t$: Forward Euler, classical fourth-order Runge–Kutta, and the third-order SSP Runge–Kutta (Shu–Osher form). Start from an initial condition that is nonnegative and bounded by $1$, given by a unit spike at the center of the grid:\n$$\nu_i^0 = \\begin{cases}\n1  \\text{if } i = \\lfloor (N-1)/2 \\rfloor, \\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\nThe domain endpoints satisfy Dirichlet boundary conditions $u_0^n = 0$ and $u_{N-1}^n = 0$ for all $n$.\n\nYou must produce a program that, for each specified test case, performs exactly one time step using the indicated integrator and then checks whether any component of the updated solution $u^{1}$ lies outside the convex hull of the initial data $[\\min_i u^0_i, \\max_i u^0_i] = [0,1]$. That is, detect whether there exists any index $i$ such that $u^{1}_i  0$ or $u^{1}_i > 1$. If such a violation occurs, this indicates that a “new extremum” has been generated by the time integrator coupled with the spatial discretization, and the boolean answer for that test case should be `true`. Otherwise, the boolean answer should be `false`.\n\nUse the following test suite, which varies method and time step to illustrate the phenomenon:\n\n- Test case $1$: Forward Euler, $N = 51$, $\\Delta x = 1\\,\\mathrm{m}$, $\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$ (so $\\mu = 0.5$). Report whether a new extremum is generated.\n- Test case $2$: Classical fourth-order Runge–Kutta (non-SSP), $N = 51$, $\\Delta x = 1\\,\\mathrm{m}$, $\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$ (so $\\mu = 0.5$). Report whether a new extremum is generated.\n- Test case $3$: Third-order Strong Stability Preserving Runge–Kutta (Shu–Osher form), $N = 51$, $\\Delta x = 1\\,\\mathrm{m}$, $\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$ (so $\\mu = 0.5$). Report whether a new extremum is generated.\n- Test case $4$: Classical fourth-order Runge–Kutta (non-SSP), $N = 51$, $\\Delta x = 1\\,\\mathrm{m}$, $\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$, $\\Delta t = 0.05\\,\\mathrm{s}$ (so $\\mu = 0.05$). Report whether a new extremum is generated.\n\nAll angles, if any appear, must be expressed in radians. All physical quantities must be treated with the specified units. Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets, for example, `[true,false,true,false]`.\n\nThe underlying foundational basis to be used in reasoning is as follows:\n\n- The semi-discrete central difference Laplacian is an $M$-matrix spatial discretization that is monotone under Forward Euler when $\\mu \\leq 1/2$.\n- The classical fourth-order Runge–Kutta method is not Strong Stability Preserving, meaning it does not admit a nonzero coefficient $C$ such that it can be represented as a convex combination of Forward Euler steps, and therefore bound-preserving properties of Forward Euler need not be inherited by this method.\n- The third-order Strong Stability Preserving Runge–Kutta method is designed to preserve monotonicity properties under the same Forward Euler time step restriction.\n\nYour implementation must follow these principles to construct the counterexample and return the booleans for the test suite in the exact output format described.", "solution": "The problem requires the construction of a numerical counterexample to demonstrate that a non-Strong Stability Preserving (SSP) time integration method, specifically the classical fourth-order Runge–Kutta (RK4) method, can fail to preserve the bounds of a solution (i.e., generate new extrema) even when coupled with a monotone spatial discretization and using a time step that is within the monotonicity limit of the simpler Forward Euler method. We will compare this behavior to the Forward Euler method itself and to a third-order SSP Runge–Kutta method, which are expected to preserve the solution bounds under the given conditions.\n\nThe governing partial differential equation is the scalar linear diffusion equation:\n$$\nu_t = \\kappa u_{xx}\n$$\nwhere $u(t,x)$ is the scalar field, $t$ is time, $x$ is the spatial coordinate, and $\\kappa$ is the diffusivity.\n\nThe spatial domain is discretized on a uniform grid with $N$ points and grid spacing $\\Delta x$. The semi-discrete form of the equation is $\\frac{du}{dt} = L(u)$, where $u(t)$ is a vector representing the solution at the grid points $u_i(t)$, and $L$ is the spatial operator. The problem specifies a second-order central difference approximation for the Laplacian, which defines the operator $L(u)$ for interior grid points $i=1, \\dots, N-2$:\n$$\nL(u)_i = \\frac{\\kappa}{\\Delta x^2}\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n$$\nThe boundary conditions are of Dirichlet type, with $u_0(t) = 0$ and $u_{N-1}(t) = 0$ for all time.\n\nThe initial condition is a unit spike at the center of the grid, which for a grid with $N$ points is at index $i_c = \\lfloor (N-1)/2 \\rfloor$:\n$$\nu_i^0 = \\begin{cases}\n1  \\text{if } i = i_c, \\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\nThis initial condition is non-negative and its values are bounded within the convex hull $[0, 1]$. A method is said to be bound-preserving if the solution after one time step, $u^1$, remains within this convex hull, i.e., $0 \\leq u_i^1 \\leq 1$ for all $i$.\n\nWe will implement and test three explicit time integration schemes for taking a single time step of size $\\Delta t$:\n\n1.  **Forward Euler (FE)**: This is the simplest explicit method, given by:\n    $$\n    u^{n+1} = u^n + \\Delta t L(u^n)\n    $$\n    For the given spatial discretization, this method is known to be monotone, and therefore bound-preserving, if the time step $\\Delta t$ satisfies the condition $\\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2} \\leq \\frac{1}{2}$.\n\n2.  **Classical Fourth-Order Runge–Kutta (RK4)**: This is a high-order method defined by the following stages:\n    $$\n    \\begin{aligned}\n    k_1 = L(u^n) \\\\\n    k_2 = L(u^n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 = L(u^n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 = L(u^n + \\Delta t k_3) \\\\\n    u^{n+1} = u^n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{aligned}\n    $$\n    This method is not Strong Stability Preserving. It cannot be written as a convex combination of Forward Euler steps. As a result, even if the Forward Euler step is bound-preserving (i.e., $\\mu \\leq 1/2$), the RK4 method is not guaranteed to be, and can produce new extrema (undershoots or overshoots).\n\n3.  **Third-Order Strong Stability Preserving Runge–Kutta (SSP-RK3)**: This method is specifically designed to preserve monotonicity properties. The Shu–Osher form is given by:\n    $$\n    \\begin{aligned}\n    u^{(1)} = u^n + \\Delta t L(u^n) \\\\\n    u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} \\left(u^{(1)} + \\Delta t L(u^{(1)})\\right) \\\\\n    u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} \\left(u^{(2)} + \\Delta t L(u^{(2)})\\right)\n    \\end{aligned}\n    $$\n    Each stage of this method is a convex combination of previous stages and a Forward Euler step. This structure ensures that if the Forward Euler step is bound-preserving under a given time step restriction, the entire SSP-RK3 method is also bound-preserving under the same restriction.\n\nThe implementation will proceed by defining the spatial operator $L$ as a function that operates on a NumPy array representing the solution vector $u$. For each test case, we will initialize the solution vector $u^0$, apply one step of the specified integrator to obtain $u^1$, and then check if any component of $u^1$ lies outside the initial range $[0, 1]$.\n\n**Analysis of Test Cases**:\n- **Test case 1**: Forward Euler with $\\mu = 0.5$. This is at the limit of the monotonicity condition. The method should be bound-preserving. We expect the result to be `false`.\n- **Test case 2**: Classical RK4 with $\\mu = 0.5$. Although $\\Delta t$ satisfies the FE monotonicity condition, the RK4 method is not SSP. We expect it to fail to preserve bounds, generating a negative undershoot near the initial spike. The result should be `true`. This is the central demonstration.\n- **Test case 3**: SSP-RK3 with $\\mu = 0.5$. Since the method is SSP and $\\Delta t$ satisfies the FE condition, it will inherit the bound-preserving property. We expect the result to be `false`.\n- **Test case 4**: Classical RK4 with a much smaller time step, $\\mu = 0.05$. For sufficiently small time steps, the non-SSP effects of RK4 become negligible, as the method better approximates the true solution. At this small $\\mu$, it is not expected to generate new extrema. The result should be `false`.\n\nThe program will execute these four tests and report a boolean value for each, indicating whether a new extremum was generated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a counterexample for non-SSP Runge-Kutta methods.\n    \"\"\"\n\n    def L_operator(u, kappa_div_dx2):\n        \"\"\"\n        Applies the semi-discrete spatial operator L(u) for the diffusion equation.\n        L(u)_i = (kappa/dx^2) * (u_{i-1} - 2u_i + u_{i+1})\n        Dirichlet boundary conditions u_0=0, u_{N-1}=0 are handled by keeping\n        the first and last elements of the output vector as 0.\n        \"\"\"\n        N = u.shape[0]\n        Lu = np.zeros(N)\n        \n        # Vectorized calculation for interior points\n        u_left = u[:-2]   # u[0]...u[N-3]\n        u_mid = u[1:-1]  # u[1]...u[N-2]\n        u_right = u[2:]    # u[2]...u[N-1]\n        \n        Lu[1:-1] = kappa_div_dx2 * (u_left - 2 * u_mid + u_right)\n        \n        return Lu\n\n    def run_simulation(method, N, dx, kappa, dt):\n        \"\"\"\n        Runs a single time step for a given method and parameters.\n        Returns True if a new extremum is generated, False otherwise.\n        \"\"\"\n        # Initial condition: unit spike at the center\n        u0 = np.zeros(N)\n        center_idx = (N - 1) // 2\n        u0[center_idx] = 1.0\n\n        kappa_div_dx2 = kappa / (dx**2)\n\n        # Apply one time step of the selected integrator\n        if method == 'FE':\n            # Forward Euler\n            u1 = u0 + dt * L_operator(u0, kappa_div_dx2)\n        \n        elif method == 'RK4':\n            # Classical Fourth-Order Runge-Kutta\n            k1 = L_operator(u0, kappa_div_dx2)\n            k2 = L_operator(u0 + 0.5 * dt * k1, kappa_div_dx2)\n            k3 = L_operator(u0 + 0.5 * dt * k2, kappa_div_dx2)\n            k4 = L_operator(u0 + dt * k3, kappa_div_dx2)\n            u1 = u0 + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n        elif method == 'SSP3':\n            # Third-Order SSP Runge-Kutta (Shu-Osher)\n            u_stage1 = u0 + dt * L_operator(u0, kappa_div_dx2)\n            u_stage2 = 0.75 * u0 + 0.25 * (u_stage1 + dt * L_operator(u_stage1, kappa_div_dx2))\n            u1 = (1.0 / 3.0) * u0 + (2.0 / 3.0) * (u_stage2 + dt * L_operator(u_stage2, kappa_div_dx2))\n        \n        else:\n            raise ValueError(\"Unknown method specified\")\n\n        # Check if the solution is outside the initial bounds [0, 1]\n        # The convex hull of the initial data is [min(u0), max(u0)] = [0, 1]\n        min_u1 = np.min(u1)\n        max_u1 = np.max(u1)\n        \n        # Per problem, check for strict violation. Floating point tolerance is not\n        # necessary here as the expected violation for RK4 is significant.\n        is_violated = (min_u1  0.0) or (max_u1 > 1.0)\n        \n        return is_violated\n\n    # Define the test cases from the problem statement.\n    # (method, N, dx, kappa, dt)\n    test_cases = [\n        ('FE', 51, 1.0, 1.0, 0.5),    # Case 1: FE, mu=0.5\n        ('RK4', 51, 1.0, 1.0, 0.5),   # Case 2: RK4, mu=0.5\n        ('SSP3', 51, 1.0, 1.0, 0.5),  # Case 3: SSP3, mu=0.5\n        ('RK4', 51, 1.0, 1.0, 0.05),  # Case 4: RK4, mu=0.05\n    ]\n\n    results = []\n    for case in test_cases:\n        method, N, dx, kappa, dt = case\n        result = run_simulation(method, N, dx, kappa, dt)\n        results.append(str(result).lower()) # Convert boolean to lowercase string\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3359952"}, {"introduction": "Many real-world fluid dynamics problems, such as reactive flows or multiphysics simulations, are \"stiff,\" meaning they involve physical processes occurring on vastly different time scales. This presents a significant challenge for time integration, as a simple explicit method would be constrained by the fastest, and often uninteresting, scale. This advanced numerical experiment guides you through comparing a modern, unsplit Implicit-Explicit (IMEX) Runge-Kutta method against a traditional operator splitting technique, providing insight into the accuracy, cost, and stability trade-offs when tackling stiff systems. [@problem_id:3359953]", "problem": "You will design and implement a numerical experiment, in code, to demonstrate that an unsplit Implicit–Explicit Runge–Kutta (IMEX RK) time integrator outperforms Strang splitting in both accuracy and cost for a stiff reactive flow in one spatial dimension. The governing equation is the linear advection–relaxation model\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\frac{s(x) - u}{\\varepsilon}, \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\nwith periodic boundary conditions, where $a > 0$ is the advection speed, $\\varepsilon > 0$ is the stiffness parameter, and $s(x)$ is a spatially varying equilibrium state. Consider the following specifications for the numerical experiment:\n\n- Discretize space using a uniform grid with $N$ cells and cell-centered unknowns. Use a first-order upwind finite-volume semi-discretization for the advection operator. That is, if $a > 0$, approximate the spatial operator by\n$$\n\\left(F_E(u)\\right)_i = -\\frac{a}{\\Delta x} \\left(u_i - u_{i-1}\\right),\n$$\nwith periodic indexing, where $\\Delta x = 1/N$.\n- Take the source as $s(x) = \\sin(4\\pi x)$ and the initial condition as $u(x,0) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$.\n- Implement two time integrators over the time interval $[0,T]$:\n  1. An unsplit Implicit–Explicit Runge–Kutta (IMEX RK) scheme of order $2$ with two stages, diagonally implicit in the implicit part and $L$-stable, specifically the Ascher–Ruuth–Spiteri two-stage method with parameter $\\gamma = 1 - 1/\\sqrt{2}$. Denote the explicit (advection) right-hand side by $F_E(u)$ and the implicit (reaction) right-hand side by $F_I(u) = \\left(s - u\\right)/\\varepsilon$. Use the additive Runge–Kutta form with the explicit tableau\n  $$\n  A^{E} = \\begin{bmatrix} 0  0 \\\\ \\gamma  0 \\end{bmatrix}, \\quad b^{E} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{2} \\end{bmatrix},\n  $$\n  and the implicit tableau\n  $$\n  A^{I} = \\begin{bmatrix} \\gamma  0 \\\\ 1-\\gamma  \\gamma \\end{bmatrix}, \\quad b^{I} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{2} \\end{bmatrix}.\n  $$\n  2. A Strang splitting scheme of order $2$ that alternates reaction and advection over each time step $\\Delta t$: a reaction half-step, a full advection step advanced by an explicit two-stage second-order Runge–Kutta scheme, and a final reaction half-step. For the reaction substeps, integrate the linear relaxation exactly:\n  $$\n  u^{\\text{new}} = s + \\left(u^{\\text{old}} - s\\right) \\exp\\left(-\\frac{\\Delta t}{\\varepsilon}\\right),\n  $$\n  applied with $\\Delta t/2$ for the half-steps.\n- For each method, choose the time step from a Courant–Friedrichs–Lewy number (CFL) according to\n$$\n\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{a}.\n$$\n- Define the reference (exact) solution at any time $t$ by the method of characteristics. Along characteristics $x(t) = x_0 + a t$, the solution satisfies a linear relaxation ordinary differential equation. For $s(x) = \\sin(4\\pi x)$ and the given $u(x,0)$, the exact solution can be expressed in closed form using\n$$\nu(x,t) = e^{-\\lambda t} u_0(x - a t) + \\lambda \\int_{0}^{t} e^{-\\lambda \\sigma} s\\!\\left(x - a\\sigma\\right)\\, d\\sigma,\n$$\nwhere $\\lambda = 1/\\varepsilon$, $u_0(x) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$, and the integral is computable analytically using the identities for $\\int e^{-\\lambda \\sigma}\\cos(b \\sigma)\\, d\\sigma$ and $\\int e^{-\\lambda \\sigma}\\sin(b \\sigma)\\, d\\sigma$ with $b = 4\\pi a$.\n- Measure the error of a numerical solution $u_h$ against the exact solution $u_{\\text{exact}}$ at final time $T$ using the discrete $L^2$-norm\n$$\n\\left\\| u_h - u_{\\text{exact}} \\right\\|_2 = \\sqrt{ \\Delta x \\sum_{i=0}^{N-1} \\left(u_{h,i} - u_{\\text{exact}}(x_i,T)\\right)^2 }.\n$$\n- Measure the cost in units proportional to the number of right-hand side evaluations and implicit solves. Define the cost per time step as $C_{\\text{step}} = 2 + 2$ for both methods, counting $2$ explicit advection residual evaluations and $2$ reaction solves per full step, so the total cost is $C_{\\text{total}} = C_{\\text{step}} \\times$ (number of steps).\n- For each test case below, compute:\n  1. A boolean indicating whether the IMEX RK method has strictly smaller error than Strang splitting at the same $\\Delta t$.\n  2. A boolean indicating whether the IMEX RK method is cheaper than Strang splitting to achieve the same or better accuracy. To assess this, keep the IMEX time step fixed, then refine the Strang splitting time step by integer factors $m \\in \\{1,2,4,8,16,32\\}$, using $\\Delta t_{\\text{split}} = \\Delta t / m$, and find the smallest $m$ such that the Strang splitting error is less than or equal to the IMEX error. Compare costs at that $m$. If no such $m$ exists in the set, regard the IMEX method as cheaper.\n- Use $a = 1$, and $T$ as specified per test.\n\nYour program must implement the above numerics and produce results for the following test suite:\n- Test $1$: $N = 256$, $\\varepsilon = 10^{-3}$, $\\text{CFL} = 0.9$, $T = 0.2$.\n- Test $2$: $N = 256$, $\\varepsilon = 10^{-5}$, $\\text{CFL} = 0.9$, $T = 0.2$.\n- Test $3$: $N = 128$, $\\varepsilon = 10^{-4}$, $\\text{CFL} = 0.99$, $T = 0.3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test and is itself a two-element list of booleans in the order described above. For example, the output format must be\n`[[\\text{acc\\_better}_1,\\text{cost\\_better}_1],[\\text{acc\\_better}_2,\\text{cost\\_better}_2],[\\text{acc\\_better}_3,\\text{cost\\_better}_3]]`.\nNo physical units or angles are involved. All angles in trigonometric functions are in radians by definition. The output entries must be boolean values.", "solution": "The problem presents a well-posed and scientifically grounded numerical experiment for comparing two time integration schemes, an Implicit-Explicit (IMEX) Runge-Kutta method and a Strang splitting method, on a stiff advection-reaction problem. A detailed validation confirms that the problem is self-contained, objective, and free of scientific or logical flaws. We therefore proceed to construct the solution.\n\nThe core of the problem is to solve the one-dimensional linear advection-reaction equation with periodic boundary conditions:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\frac{s(x) - u}{\\varepsilon}, \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\nHere, $a > 0$ is the constant advection speed, $\\varepsilon > 0$ is the relaxation time which dictates the stiffness of the reaction term, and $s(x)$ is the equilibrium state. The stiffness arises when $\\varepsilon$ is small, causing the reaction term to operate on a much faster time scale than the advection term.\n\nThe spatial domain is discretized on a uniform grid with $N$ cells of width $\\Delta x = 1/N$. The cell-centered unknowns are denoted by $u_i(t) \\approx u(x_i, t)$, where $x_i = (i+0.5)\\Delta x$ for $i = 0, \\dots, N-1$. This yields a system of ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{u}}{dt} = F_E(\\mathbf{u}) + F_I(\\mathbf{u})\n$$\nwhere $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$. The advection operator $F_E$ is the non-stiff (explicit) part, and the reaction operator $F_I$ is the stiff (implicit) part.\nThe advection term is discretized using a first-order upwind finite volume method. For $a>0$, the flux at the interface $x_{i-1/2}$ is approximated as $a u_{i-1}$, leading to the semi-discretization:\n$$\n(F_E(\\mathbf{u}))_i = -\\frac{a}{\\Delta x} (u_i - u_{i-1})\n$$\nPeriodicity is handled by index arithmetic modulo $N$. The reaction term is purely local:\n$$\n(F_I(\\mathbf{u}))_i = \\frac{s(x_i) - u_i}{\\varepsilon}\n$$\nThe specific initial condition is $u(x,0) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$ and the source is $s(x) = \\sin(4\\pi x)$.\n\nA reference solution is required for error analysis. The provided method of characteristics gives the exact solution. The governing PDE along a characteristic curve $x(t) = x_0 + at$ reduces to the ODE $\\frac{du}{dt} = \\frac{s(x_0+at) - u}{\\varepsilon}$. The general solution to this linear ODE is the sum of the homogeneous solution and a particular solution. A stable and insightful representation is:\n$$\nu(x,t) = u_{\\text{eq}}(x) + e^{-t/\\varepsilon} \\left( u(x-at, 0) - u_{\\text{eq}}(x-at) \\right)\n$$\nwhere $u(x-at,0) = u_0(x-at)$ is the initial condition advected along the characteristic, and $u_{\\text{eq}}(x)$ is the equilibrium solution to the steady-state equation $a \\frac{du}{dx} = \\frac{s(x) - u}{\\varepsilon}$. By substituting $s(x) = \\sin(4\\pi x)$ and assuming a solution of the form $u_{\\text{eq}}(x) = A\\sin(4\\pi x) + B\\cos(4\\pi x)$, we find:\n$$\nu_{\\text{eq}}(x) = \\frac{\\sin(4\\pi x) - 4\\pi a \\varepsilon \\cos(4\\pi x)}{1 + (4\\pi a \\varepsilon)^2}\n$$\nThis form of the exact solution is robust for small $\\varepsilon$, as the term $e^{-t/\\varepsilon}$ rapidly decays to zero.\n\nThe numerical experiment compares two second-order time integrators.\n\n1.  **Unsplit IMEX Runge-Kutta Method:** The Ascher–Ruuth–Spiteri ARS(2,2,2) scheme is an $L$-stable, two-stage, second-order diagonally implicit Runge-Kutta (DIRK) method for the implicit part and explicit for the explicit part. For an ODE system $\\mathbf{u}' = F_E(\\mathbf{u}) + F_I(\\mathbf{u})$, the stages $\\mathbf{Y}_1, \\mathbf{Y}_2$ and the final solution $\\mathbf{u}^{n+1}$ are computed from $\\mathbf{u}^n$ over a time step $\\Delta t$ as follows:\n    -   Stage 1: Solve for $\\mathbf{Y}_1$:\n        $$\n        \\mathbf{Y}_1 = \\mathbf{u}^n + \\Delta t \\gamma F_I(\\mathbf{Y}_1)\n        $$\n        Since $F_I$ is linear, this is an algebraic solve for each component: $(\\mathbf{Y}_1)_i = \\frac{(\\mathbf{u}^n)_i + \\Delta t \\gamma s_i / \\varepsilon}{1 + \\Delta t \\gamma / \\varepsilon}$, where $\\gamma = 1 - 1/\\sqrt{2}$.\n    -   Stage 2: Solve for $\\mathbf{Y}_2$:\n        $$\n        \\mathbf{Y}_2 = \\mathbf{u}^n + \\Delta t \\gamma F_E(\\mathbf{Y}_1) + \\Delta t (1-\\gamma) F_I(\\mathbf{Y}_1) + \\Delta t \\gamma F_I(\\mathbf{Y}_2)\n        $$\n        Again, this is a component-wise algebraic solve for $\\mathbf{Y}_2$.\n    -   Final solution:\n        $$\n        \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} \\left[ F_E(\\mathbf{Y}_1) + F_E(\\mathbf{Y}_2) + F_I(\\mathbf{Y}_1) + F_I(\\mathbf{Y}_2) \\right]\n        $$\n\n2.  **Strang Splitting Method:** This method splits the full operator into advection and reaction parts and applies them sequentially, symmetrized to achieve second-order accuracy. A step from $\\mathbf{u}^n$ to $\\mathbf{u}^{n+1}$ consists of three substeps:\n    -   1. Half-step reaction: $\\mathbf{u}^* = \\mathcal{S}_{\\Delta t/2}(\\mathbf{u}^n)$. Integrate $\\frac{d\\mathbf{u}}{dt} = F_I(\\mathbf{u})$ over $\\Delta t/2$. The exact solution is used:\n        $$\n        u_i^* = s_i + (u_i^n - s_i) \\exp\\left(-\\frac{\\Delta t}{2\\varepsilon}\\right)\n        $$\n    -   2. Full-step advection: $\\mathbf{u}^{**} = \\mathcal{A}_{\\Delta t}(\\mathbf{u}^*)$. Integrate $\\frac{d\\mathbf{u}}{dt} = F_E(\\mathbf{u})$ over a full step $\\Delta t$ using a second-order explicit Runge-Kutta scheme (e.g., Heun's method):\n        $$\n        \\mathbf{k}_1 = F_E(\\mathbf{u}^*)\n        $$\n        $$\n        \\mathbf{k}_2 = F_E(\\mathbf{u}^* + \\Delta t \\mathbf{k}_1)\n        $$\n        $$\n        \\mathbf{u}^{**} = \\mathbf{u}^* + \\frac{\\Delta t}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n        $$\n    -   3. Half-step reaction: $\\mathbf{u}^{n+1} = \\mathcal{S}_{\\Delta t/2}(\\mathbf{u}^{**})$. This is another exact reaction step over $\\Delta t/2$:\n        $$\n        u_i^{n+1} = s_i + (u_i^{**} - s_i) \\exp\\left(-\\frac{\\Delta t}{2\\varepsilon}\\right)\n        $$\n    Splitting methods can suffer from order reduction for stiff problems, where the splitting error contains terms like $\\Delta t^2 / \\varepsilon$ that become large as $\\varepsilon \\to 0$.\n\nThe comparison is based on accuracy and cost. The error is measured using the discrete $L^2$-norm against the exact solution at the final time $T$. The computational cost is defined as $C_{\\text{total}} = 4 \\times (\\text{number of time steps})$, accounting for two explicit evaluations and two implicit solves (or their equivalents) per step for both methods. The experiment evaluates (1) whether IMEX is more accurate for the same time step $\\Delta t$, and (2) whether IMEX is cheaper to achieve a target accuracy set by its own error. For the second point, the Strang splitting method's time step is refined by factors $m \\in \\{1,2,4,8,16,32\\}$ until its error is less than or equal to the IMEX error, and the costs are then compared. If the required accuracy is not met even for $m=32$, IMEX is deemed cheaper by definition. The implementation will execute this procedure for each test case specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print results.\n    \"\"\"\n\n    test_cases = [\n        # (N, epsilon, CFL, T)\n        (256, 1e-3, 0.9, 0.2),\n        (256, 1e-5, 0.9, 0.2),\n        (128, 1e-4, 0.99, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = run_comparison(*case)\n        results.append(case_result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[True,False],[True,True],[True,True]]\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\n\ndef run_comparison(N, epsilon, CFL, T):\n    \"\"\"\n    Runs the full comparison for a single test case.\n    \"\"\"\n    # --- 1. Setup ---\n    a = 1.0\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    dt = CFL * dx / a\n\n    u0 = np.cos(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x)\n    s = np.sin(4 * np.pi * x)\n\n    # --- 2. Run IMEX Method ---\n    u_imex = run_integrator(\n        imex_step, u0, s, dt, T, N, a, epsilon, gamma\n    )\n    num_steps_imex = int(np.ceil(T / dt))\n    cost_imex = 4 * num_steps_imex\n\n    # --- 3. Run Strang Splitting Method (baseline) ---\n    u_strang_base = run_integrator(\n        strang_step, u0, s, dt, T, N, a, epsilon, gamma\n    )\n\n    # --- 4. Compute Errors and Compare Accuracy ---\n    u_exact_final = get_exact_solution(x, T, a, epsilon)\n    error_imex = compute_l2_error(u_imex, u_exact_final, dx)\n    error_strang_base = compute_l2_error(u_strang_base, u_exact_final, dx)\n\n    acc_better = error_imex  error_strang_base\n\n    # --- 5. Compare Cost for a Given Accuracy ---\n    cost_better = False\n    found_m = False\n    refinement_factors = [1, 2, 4, 8, 16, 32]\n\n    for m in refinement_factors:\n        dt_split = dt / m\n        u_strang_refined = run_integrator(\n            strang_step, u0, s, dt_split, T, N, a, epsilon, gamma\n        )\n        error_strang_refined = compute_l2_error(u_strang_refined, u_exact_final, dx)\n\n        if error_strang_refined = error_imex:\n            num_steps_strang = int(np.ceil(T / dt_split))\n            cost_strang_refined = 4 * num_steps_strang\n            cost_better = cost_imex  cost_strang_refined\n            found_m = True\n            break\n            \n    if not found_m:\n        # If Strang can't match accuracy even with 32x refinement, IMEX is cheaper.\n        cost_better = True\n\n    return [acc_better, cost_better]\n\n\n# --- Helper Functions ---\n\ndef advection_rhs(u, a, dx):\n    \"\"\"Computes the first-order upwind discretization of the advection term.\"\"\"\n    return -a / dx * (u - np.roll(u, 1))\n\n\ndef get_exact_solution(x, t, a, epsilon):\n    \"\"\"Computes the exact solution at a given time t.\"\"\"\n    \n    def u0_func(x_arg):\n        return np.cos(2 * np.pi * x_arg) + 0.5 * np.sin(6 * np.pi * x_arg)\n\n    def u_eq(x_arg):\n        b = 4.0 * np.pi * a\n        return (np.sin(4 * np.pi * x_arg) - b * epsilon * np.cos(4 * np.pi * x_arg)) / (1.0 + (b * epsilon)**2)\n\n    lambd = 1.0 / epsilon\n    x_char = (x - a * t) % 1.0\n    \n    # This form is numerically stable for small epsilon (large lambda)\n    transient_term = np.exp(-lambd * t) * (u0_func(x_char) - u_eq(x_char))\n    \n    return u_eq(x) + transient_term\n\n\ndef imex_step(u, s, dt, N, a, epsilon, gamma):\n    \"\"\"Performs one step of the IMEX Runge-Kutta scheme.\"\"\"\n    dx = 1.0 / N\n    \n    # Common denominator for implicit solves\n    denom = 1.0 + dt * gamma / epsilon\n\n    # Stage 1\n    Y1 = (u + dt * gamma * s / epsilon) / denom\n    \n    # Stage 2\n    F_E_Y1 = advection_rhs(Y1, a, dx)\n    F_I_Y1 = (s - Y1) / epsilon\n    RHS2 = u + dt * gamma * F_E_Y1 + dt * (1.0 - gamma) * F_I_Y1\n    Y2 = (RHS2 + dt * gamma * s / epsilon) / denom\n\n    # Final update\n    F_E_Y2 = advection_rhs(Y2, a, dx)\n    F_I_Y2 = (s - Y2) / epsilon\n    u_new = u + 0.5 * dt * (F_E_Y1 + F_E_Y2 + F_I_Y1 + F_I_Y2)\n    return u_new\n\n\ndef strang_step(u, s, dt, N, a, epsilon, gamma):\n    \"\"\"Performs one step of the Strang splitting scheme.\"\"\"\n    dx = 1.0 / N\n    \n    # 1. Reaction half-step\n    exp_term = np.exp(-0.5 * dt / epsilon)\n    u_star = s + (u - s) * exp_term\n    \n    # 2. Advection full-step (Heun's method)\n    k1 = advection_rhs(u_star, a, dx)\n    u_tmp = u_star + dt * k1\n    k2 = advection_rhs(u_tmp, a, dx)\n    u_ss = u_star + 0.5 * dt * (k1 + k2)\n    \n    # 3. Reaction half-step\n    u_new = s + (u_ss - s) * exp_term\n    return u_new\n\n\ndef run_integrator(step_func, u0, s, dt, T, N, a, epsilon, gamma):\n    \"\"\"\n    Evolves the solution u from t=0 to t=T using the provided step function.\n    Handles the final partial time step.\n    \"\"\"\n    u = u0.copy()\n    num_steps = int(T / dt)\n    dt_final = T - num_steps * dt\n    \n    for _ in range(num_steps):\n        u = step_func(u, s, dt, N, a, epsilon, gamma)\n        \n    if dt_final > 1e-12:  # Avoid tiny final steps due to float precision\n        u = step_func(u, s, dt_final, N, a, epsilon, gamma)\n        \n    return u\n\n\ndef compute_l2_error(u_num, u_exact, dx):\n    \"\"\"Computes the discrete L2 error norm.\"\"\"\n    return np.sqrt(dx * np.sum((u_num - u_exact)**2))\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3359953"}]}