{"hands_on_practices": [{"introduction": "The most fundamental task in designing non-reflecting boundary conditions (NRBCs) is understanding how a numerical boundary interacts with discrete waves. This practice guides you through the process of analyzing wave reflection at the discrete level by deriving the reflection coefficient for both a simple Dirichlet boundary and a first-order absorbing boundary condition. This exercise is crucial for building intuition on how numerical schemes can create spurious, non-physical reflections, which is the primary problem NRBCs are designed to solve [@problem_id:3349612].", "problem": "Consider the one-dimensional wave equation $u_{tt} = c^2 u_{xx}$ on a semi-infinite domain $x \\ge 0$. The field $u$ is discretized on a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$, indexed as $u_j^n \\approx u(x_j,t_n)$ where $x_j = j \\Delta x$ and $t_n = n \\Delta t$. The interior update is the second-order accurate central-difference scheme in both space and time, which advances $u_j^n$ according to a standard explicit stencil. The Courant–Friedrichs–Lewy (CFL) number is defined as $\\lambda = \\dfrac{c \\Delta t}{\\Delta x}$.\n\nYou will analyze the discrete reflection of a time-harmonic plane wave incident on the boundary at $j = 0$ for two boundary closures:\n\n- A simple Dirichlet boundary, enforcing $u_0^n = 0$ for all integer $n$.\n- A first-order impedance-matched (Sommerfeld-type) boundary closure at $j = 0$ that uses a centered time difference and a one-sided spatial difference, enforcing\n$$\n\\frac{u_0^{n+1} - u_0^{n-1}}{2 \\Delta t} - c \\, \\frac{u_1^n - u_0^n}{\\Delta x} = 0.\n$$\n\nAngles must be expressed in radians.\n\nStarting from the discrete interior update and a superposition of incident and reflected discrete plane waves, you must:\n\n1. Derive the discrete dispersion relation linking the discrete temporal frequency to the discrete wavenumber and the CFL number, using the plane-wave ansatz and the interior stencil.\n2. Construct the discrete reflection coefficient at $j=0$ for the Dirichlet boundary and for the impedance-matched boundary, by enforcing each boundary closure on the superposed incident and reflected waves. The reflection coefficient $R$ is defined as the complex amplitude ratio of the reflected wave to the incident wave.\n3. Use the derived expressions to compute the magnitudes $|R|$ for both boundary closures, for a set of test cases specified below. Every test case is parameterized by $(\\lambda,\\theta)$, where $\\theta = k \\Delta x$ is the dimensionless discrete wavenumber and $k$ is the continuous wavenumber. The discrete temporal frequency is consistent with the dispersion relation you derive. For numerical evaluation, choose the principal branch of the discrete frequency consistent with the interior dispersion.\n\nThe test suite to be evaluated is:\n- Case $1$: $\\lambda = 0.8$, $\\theta = 0.4$.\n- Case $2$: $\\lambda = 0.8$, $\\theta = 2.6$.\n- Case $3$: $\\lambda = 1.0$, $\\theta = \\pi$.\n- Case $4$: $\\lambda = 0.2$, $\\theta = 1.0$.\n- Case $5$: $\\lambda = 0.95$, $\\theta = 0.05$.\n\nYour program must compute, for each test case, the pair of floats $[|R_{\\mathrm{D}}|, |R_{\\mathrm{ABC}}|]$, where $|R_{\\mathrm{D}}|$ is the magnitude of the reflection coefficient for the Dirichlet boundary and $|R_{\\mathrm{ABC}}|$ is the magnitude for the impedance-matched boundary. The final output must be a single line containing a comma-separated list of these pairs, enclosed in square brackets, for example:\n$$\n[[|R_{\\mathrm{D}}|,|R_{\\mathrm{ABC}}|],\\,[|R_{\\mathrm{D}}|,|R_{\\mathrm{ABC}}|],\\,\\dots]\n$$\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with each entry formatted exactly as a two-element list $[|R_{\\mathrm{D}}|,|R_{\\mathrm{ABC}}|]$ in the order of the test suite.", "solution": "The problem is found to be valid as it is scientifically grounded, well-posed, and objective. It consists of a standard analysis of numerical wave propagation and reflection, free of any invalidating flaws. We proceed with the solution.\n\nThe analysis is structured into three parts:\n1.  Derivation of the discrete dispersion relation for the interior finite-difference scheme.\n2.  Derivation of the discrete reflection coefficients for the Dirichlet and first-order impedance-matched boundary conditions.\n3.  Specification of the numerical evaluation procedure for the given test cases.\n\n**1. Discrete Dispersion Relation**\n\nThe one-dimensional wave equation is given by $u_{tt} = c^2 u_{xx}$. The interior of the domain is discretized using a second-order accurate central-difference scheme in both time and space:\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = c^2 \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\nIntroducing the Courant-Friedrichs-Lewy (CFL) number, $\\lambda = \\frac{c \\Delta t}{\\Delta x}$, the scheme can be rearranged to its explicit form:\n$$\nu_j^{n+1} = 2(1 - \\lambda^2)u_j^n - u_j^{n-1} + \\lambda^2 (u_{j+1}^n + u_{j-1}^n)\n$$\nTo find the dispersion relation, we substitute the plane-wave ansatz, $u_j^n = \\hat{u} e^{i(\\omega t_n - k x_j)}$, into the scheme. Let $\\tilde{\\omega} = \\omega \\Delta t$ be the dimensionless discrete temporal frequency and $\\theta = k \\Delta x$ be the dimensionless discrete wavenumber. The ansatz becomes $u_j^n = \\hat{u} e^{i(n\\tilde{\\omega} - j\\theta)}$. Substituting this into the numerical scheme and dividing by the common factor $\\hat{u} e^{i(n\\tilde{\\omega} - j\\theta)}$ yields:\n$$\ne^{i\\tilde{\\omega}} = 2(1 - \\lambda^2) - e^{-i\\tilde{\\omega}} + \\lambda^2 (e^{-i\\theta} + e^{i\\theta})\n$$\nRearranging terms to solve for $\\tilde{\\omega}$:\n$$\ne^{i\\tilde{\\omega}} + e^{-i\\tilde{\\omega}} = 2(1 - \\lambda^2) + 2\\lambda^2 \\cos\\theta\n$$\nUsing the identity $e^{iz} + e^{-iz} = 2\\cos z$, we get:\n$$\n2\\cos\\tilde{\\omega} = 2 - 2\\lambda^2(1 - \\cos\\theta)\n$$\nApplying the half-angle identities $\\cos z = 1 - 2\\sin^2(z/2)$ and $1 - \\cos z = 2\\sin^2(z/2)$:\n$$\n2(1 - 2\\sin^2(\\tilde{\\omega}/2)) = 2 - 2\\lambda^2(2\\sin^2(\\theta/2))\n$$\n$$\n-4\\sin^2(\\tilde{\\omega}/2) = -4\\lambda^2\\sin^2(\\theta/2)\n$$\nThis simplifies to the discrete dispersion relation for the scheme:\n$$\n\\sin^2(\\tilde{\\omega}/2) = \\lambda^2\\sin^2(\\theta/2)\n$$\nTaking the square root and selecting the principal branch that corresponds to physical wave propagation, we obtain:\n$$\n\\sin(\\tilde{\\omega}/2) = \\lambda \\sin(\\theta/2)\n$$\nFrom this, the discrete temporal frequency $\\tilde{\\omega}$ can be expressed as a function of the discrete wavenumber $\\theta$ and CFL number $\\lambda$:\n$$\n\\tilde{\\omega} = 2 \\arcsin(\\lambda \\sin(\\theta/2))\n$$\nThis relation is valid for stable schemes, where $\\lambda \\le 1$.\n\n**2. Reflection Coefficients**\n\nThe solution on the semi-infinite domain $x \\ge 0$ is a superposition of an incident wave propagating towards the boundary at $x=0$ (left-propagating) and a reflected wave propagating away from it (right-propagating). The discrete form of the solution is:\n$$\nu_j^n = u_{I,j}^n + u_{R,j}^n = A_I e^{i(n\\tilde{\\omega} + j\\theta)} + A_R e^{i(n\\tilde{\\omega} - j\\theta)}\n$$\nwhere $A_I$ and $A_R$ are the complex amplitudes of the incident and reflected waves, respectively. The reflection coefficient $R$ is defined as the ratio $R = A_R / A_I$. The total solution can be written as:\n$$\nu_j^n = A_I e^{in\\tilde{\\omega}}(e^{ij\\theta} + R e^{-ij\\theta})\n$$\n\n**Dirichlet Boundary Condition ($R_D$)**\nThe boundary condition is $u_0^n = 0$ for all $n$. Applying this to the total solution at $j=0$:\n$$\nu_0^n = A_I e^{in\\tilde{\\omega}}(e^{i(0)\\theta} + R_D e^{-i(0)\\theta}) = 0\n$$\n$$\nA_I e^{in\\tilde{\\omega}}(1 + R_D) = 0\n$$\nFor a non-trivial incident wave ($A_I \\ne 0$), this requires $1 + R_D = 0$, which yields:\n$$\nR_D = -1\n$$\nThe magnitude of the reflection coefficient is $|R_D| = 1$, indicating perfect reflection with a phase inversion, regardless of $\\lambda$ or $\\theta$.\n\n**Impedance-Matched Boundary Condition ($R_{ABC}$)**\nThe boundary condition is given by:\n$$\n\\frac{u_0^{n+1} - u_0^{n-1}}{2 \\Delta t} - c \\, \\frac{u_1^n - u_0^n}{\\Delta x} = 0\n$$\nWe substitute the total solution $u_j^n = A_I e^{in\\tilde{\\omega}}(e^{ij\\theta} + R_{ABC} e^{-ij\\theta})$ into this equation. First, we evaluate the necessary terms:\n- $u_0^n = A_I e^{in\\tilde{\\omega}}(1 + R_{ABC})$\n- $u_0^{n \\pm 1} = u_0^n e^{\\pm i\\tilde{\\omega}}$\n- $u_1^n = A_I e^{in\\tilde{\\omega}}(e^{i\\theta} + R_{ABC} e^{-i\\theta})$\n\nSubstituting these into the boundary condition:\n$$\n\\frac{A_I e^{in\\tilde{\\omega}}(1+R_{ABC})(e^{i\\tilde{\\omega}} - e^{-i\\tilde{\\omega}})}{2\\Delta t} - \\frac{c}{\\Delta x} \\left( A_I e^{in\\tilde{\\omega}}(e^{i\\theta} + R_{ABC}e^{-i\\theta}) - A_I e^{in\\tilde{\\omega}}(1 + R_{ABC}) \\right) = 0\n$$\nDividing by $A_I e^{in\\tilde{\\omega}}$ and using $e^{iz} - e^{-iz} = 2i\\sin z$:\n$$\n\\frac{(1+R_{ABC})(i\\sin\\tilde{\\omega})}{\\Delta t} - \\frac{c}{\\Delta x} \\left( (e^{i\\theta}-1) + R_{ABC}(e^{-i\\theta}-1) \\right) = 0\n$$\nMultiplying by $\\Delta x/c = \\Delta t/\\lambda$:\n$$\n\\frac{1}{\\lambda} (1+R_{ABC})(i\\sin\\tilde{\\omega}) - \\left( (e^{i\\theta}-1) + R_{ABC}(e^{-i\\theta}-1) \\right) = 0\n$$\nWe now solve for $R_{ABC}$:\n$$\nR_{ABC} \\left( \\frac{i\\sin\\tilde{\\omega}}{\\lambda} - (e^{-i\\theta}-1) \\right) = (e^{i\\theta}-1) - \\frac{i\\sin\\tilde{\\omega}}{\\lambda}\n$$\n$$\nR_{ABC} = \\frac{(e^{i\\theta}-1) - i\\sin\\tilde{\\omega}/\\lambda}{i\\sin\\tilde{\\omega}/\\lambda - (e^{-i\\theta}-1)}\n$$\nTo avoid division by $\\lambda$ in the implementation, we can multiply the numerator and denominator by $\\lambda$:\n$$\nR_{ABC} = \\frac{\\lambda(e^{i\\theta}-1) - i\\sin\\tilde{\\omega}}{i\\sin\\tilde{\\omega} + \\lambda(1-e^{-i\\theta})}\n$$\nThe magnitude $|R_{ABC}|$ must be computed for each test case.\n\n**3. Numerical Evaluation**\n\nFor each test case $(\\lambda, \\theta)$:\n1.  The magnitude of the reflection coefficient for the Dirichlet boundary is $|R_D| = 1.0$.\n2.  The discrete temporal frequency $\\tilde{\\omega}$ is computed from the dispersion relation: $\\tilde{\\omega} = 2 \\arcsin(\\lambda \\sin(\\theta/2))$.\n3.  The complex reflection coefficient $R_{ABC}$ is computed using the derived formula.\n4.  The magnitude $|R_{ABC}|$ is then calculated as the absolute value of the complex number $R_{ABC}$.\n5.  The results are reported as a pair $[|R_D|, |R_{ABC}|]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the magnitude of the reflection coefficient for Dirichlet and\n    first-order impedance-matched boundary conditions for a 1D wave equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (lambda, theta).\n    test_cases = [\n        (0.8, 0.4),\n        (0.8, 2.6),\n        (1.0, np.pi),\n        (0.2, 1.0),\n        (0.95, 0.05)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lmbda, theta = case\n        \n        # 1. Reflection coefficient for the Dirichlet boundary\n        # As derived, R_D = -1, so its magnitude is always 1.\n        mag_R_d = 1.0\n        \n        # 2. Reflection coefficient for the impedance-matched boundary (ABC)\n        \n        # Check for stability condition, although all test cases satisfy it.\n        if lmbda > 1.0:\n            raise ValueError(f\"CFL condition not met: lambda = {lmbda} > 1\")\n\n        # Calculate discrete temporal frequency from the dispersion relation\n        # sin(omega_tilde/2) = lambda * sin(theta/2)\n        omega_tilde = 2 * np.arcsin(lmbda * np.sin(theta / 2.0))\n        \n        # Calculate the complex reflection coefficient R_ABC using the derived formula:\n        # R_ABC = (lmbda*(exp(i*theta) - 1) - i*sin(omega_tilde)) / \n        #         (i*sin(omega_tilde) + lmbda*(1 - exp(-i*theta)))\n        \n        # Numerator of R_ABC\n        num = lmbda * (np.exp(1j * theta) - 1.0) - 1j * np.sin(omega_tilde)\n        \n        # Denominator of R_ABC\n        den = 1j * np.sin(omega_tilde) + lmbda * (1.0 - np.exp(-1j * theta))\n        \n        # In the limit theta -> 0, den -> 0. Handle this case if necessary.\n        # For the given test cases, theta is never zero.\n        if np.isclose(den, 0):\n             # This case corresponds to perfect absorption in the continuous limit.\n             # Numerically, R_abc should be 0.\n             R_abc = 0.0\n        else:\n             R_abc = num / den\n\n        # Calculate the magnitude of the reflection coefficient\n        mag_R_abc = np.abs(R_abc)\n        \n        results.append([mag_R_d, mag_R_abc])\n\n    # Final print statement in the exact required format.\n    # str(list) automatically creates the \"[a, b]\" format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3349612"}, {"introduction": "An effective NRBC often requires an accurate estimate of the properties of outgoing waves, such as the local speed of sound $c$. This exercise explores the practical robustness of an invariant-based NRBC by quantifying its reflection coefficient when there is a mismatch between the true wave speed $c$ and the estimated speed $\\hat{c}$ used in the boundary formulation. By performing a sensitivity analysis, you will gain a deeper appreciation for the performance limitations of NRBCs and the importance of accurately characterizing the flow state at the computational boundary [@problem_id:3349564].", "problem": "Consider one-dimensional small-amplitude plane-wave disturbances of a uniform perfect-gas flow governed by the linearized Euler equations. Let the uniform base state be characterized by constant density $\\rho_0$, pressure $p_0$, temperature $T_0$, ratio of specific heats $\\gamma$, gas constant $R$ (so that $c^2 = \\gamma R T$ for the local speed of sound $c$), and negligible mean velocity so that convective effects may be ignored to leading order. For small perturbations $(\\rho', u', p')$, the linearized equations admit right- and left-traveling acoustic modes with dispersion relation $\\omega = \\pm c k$ and constitutive relations $u' = \\pm p'/(\\rho_0 c)$ for the acoustic part, and $p' = c^2 \\rho'$ as well as an entropy mode with $p'_s = 0$, $u'_s = 0$, and $s' \\neq 0$ that convects the local thermodynamic state.\n\nNon-Reflecting Boundary Conditions (NRBC) based on invariants commonly enforce at an outflow boundary that the incoming acoustic characteristic vanishes. A practical implementation enforces the algebraic constraint $u' = p'/(\\rho_0 \\hat{c})$ at the boundary using an estimated speed of sound $\\hat{c}$ derived from an estimated ratio of specific heats $\\hat{\\gamma}$ and base thermodynamic state. In slightly non-isentropic flows, local temperature is perturbed by a small dimensionless entropy amplitude $\\sigma$, defined by $\\sigma \\equiv s'/c_v$ where $c_v$ is the specific heat at constant volume, so that for small $\\sigma$ the local sound speed satisfies $c \\approx \\sqrt{\\gamma R T_0}\\,(1 + \\tfrac{1}{2}\\sigma)$, while the boundary algorithm uses $\\hat{c} \\approx \\sqrt{\\hat{\\gamma} R T_0}$ that neglects $\\sigma$ and uses possibly erroneous $\\hat{\\gamma}$.\n\nStarting from the linearized Euler equations and the acoustic mode relations, derive from first principles the reflection coefficient magnitude $|R|$ for a right-traveling incident acoustic wave encountering the outflow boundary that enforces $u' = p'/(\\rho_0 \\hat{c})$. Express $|R|$ purely in terms of the true local sound speed $c$ and its estimate $\\hat{c}$. Then, using $c \\approx \\sqrt{\\gamma R T_0}\\,(1 + \\tfrac{1}{2}\\sigma)$ and $\\hat{c} \\approx \\sqrt{\\hat{\\gamma} R T_0}$, derive analytical expressions for the sensitivity of $|R|$ with respect to $\\hat{c}$, denoted by $\\partial |R| / \\partial \\hat{c}$, and the sensitivity of $|R|$ with respect to $\\hat{\\gamma}$, denoted by $\\partial |R| / \\partial \\hat{\\gamma}$, evaluated at given parameter values. You must express $\\partial |R| / \\partial \\hat{\\gamma}$ using the chain rule through $\\hat{c}(\\hat{\\gamma})$.\n\nYour program must implement these formulas and compute, for each test case, the triple consisting of:\n- the reflection coefficient magnitude $|R|$,\n- the absolute sensitivity $\\left|\\partial |R| / \\partial \\hat{c}\\right|$,\n- the absolute sensitivity $\\left|\\partial |R| / \\partial \\hat{\\gamma}\\right|$.\n\nAll speeds must be treated in meters per second (m/s), $R$ in joules per kilogram-kelvin (J/(kg·K)), $T_0$ in kelvin (K), and the outputs are dimensionless floats. For test cases in which the estimate $\\hat{c}$ is provided directly without any $\\hat{\\gamma}$, define $\\partial |R| / \\partial \\hat{\\gamma}$ to be the numeric value $0.0$.\n\nUse the following test suite, covering a general case, an exact-match boundary condition case, and edge cases including larger parameter errors:\n1. Direct speed-of-sound specification (happy path): $c = 340.0$ m/s, $\\hat{c} = 333.0$ m/s. Ignore $\\sigma$ and any $\\hat{\\gamma}$; report the triple $(|R|, |\\partial |R| / \\partial \\hat{c}|, 0.0)$.\n2. Gamma-based estimation with slight non-isentropic effect (general case): $\\gamma = 1.4$, $\\hat{\\gamma} = 1.39$, $R = 287.0$ J/(kg·K), $T_0 = 300.0$ K, $\\sigma = 0.02$.\n3. Gamma-based estimation with perfect match (boundary condition exactness): $\\gamma = 1.4$, $\\hat{\\gamma} = 1.4$, $R = 287.0$ J/(kg·K), $T_0 = 300.0$ K, $\\sigma = 0.0$.\n4. Gamma-based estimation with larger mismatch and larger non-isentropic effect (edge case): $\\gamma = 1.4$, $\\hat{\\gamma} = 1.2$, $R = 287.0$ J/(kg·K), $T_0 = 800.0$ K, $\\sigma = 0.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s triple is itself a comma-separated list enclosed in square brackets. For example: \"[[result_case1_a,result_case1_b,result_case1_c],[result_case2_a,result_case2_b,result_case2_c],...]\". All outputs must be floats. No additional text may be printed.", "solution": "The user-provided problem has been validated and is determined to be self-contained, scientifically grounded, and well-posed. The solution proceeds as follows.\n\nThe core of the problem is to determine the reflection of a one-dimensional acoustic wave at a numerical outflow boundary and analyze the sensitivity of this reflection to parameters used in the boundary condition. The flow field perturbations are decomposed into incident (right-traveling, subscript $i$) and reflected (left-traveling, subscript $r$) components. The total velocity perturbation $u'$ and pressure perturbation $p'$ are given by the superposition $u' = u'_i + u'_r$ and $p' = p'_i + p'_r$.\n\nFrom the linearized Euler equations for a flow with negligible mean velocity, the constitutive relations for right- and left-traveling plane acoustic waves are:\n$$u'_i = \\frac{p'_i}{\\rho_0 c} \\quad \\text{(incident, right-traveling)}$$\n$$u'_r = -\\frac{p'_r}{\\rho_0 c} \\quad \\text{(reflected, left-traveling)}$$\nwhere $\\rho_0$ is the constant mean density and $c$ is the true local speed of sound in the medium.\n\nThe non-reflecting boundary condition (NRBC) is enforced at the outflow boundary. As specified, this condition is an algebraic constraint intended to make the incoming characteristic (here, the left-traveling wave) vanish. However, it uses an estimated speed of sound, $\\hat{c}$. The condition is:\n$$u' = \\frac{p'}{\\rho_0 \\hat{c}}$$\n\nTo find the reflection coefficient, we substitute the superposed fields into the boundary condition:\n$$u'_i + u'_r = \\frac{p'_i + p'_r}{\\rho_0 \\hat{c}}$$\nNext, we replace the velocity perturbations $u'_i$ and $u'_r$ with their pressure-based constitutive relations:\n$$\\frac{p'_i}{\\rho_0 c} - \\frac{p'_r}{\\rho_0 c} = \\frac{p'_i}{\\hat{c}} + \\frac{p'_r}{\\hat{c}}$$\nThe term $\\rho_0$ cancels, yielding an equation relating the pressure perturbations:\n$$\\frac{p'_i}{c} - \\frac{p'_r}{c} = \\frac{p'_i}{\\hat{c}} + \\frac{p'_r}{\\hat{c}}$$\nThe reflection coefficient, $R$, is defined as the ratio of the reflected wave amplitude to the incident wave amplitude, $R = p'_r / p'_i$. Rearranging the equation to solve for this ratio gives:\n$$p'_i \\left( \\frac{1}{c} - \\frac{1}{\\hat{c}} \\right) = p'_r \\left( \\frac{1}{c} + \\frac{1}{\\hat{c}} \\right)$$\n$$R = \\frac{p'_r}{p'_i} = \\frac{\\frac{1}{c} - \\frac{1}{\\hat{c}}}{\\frac{1}{c} + \\frac{1}{\\hat{c}}}$$\nMultiplying the numerator and denominator by $c\\hat{c}$ simplifies the expression:\n$$R = \\frac{\\hat{c} - c}{\\hat{c} + c}$$\nThe problem asks for the magnitude of the reflection coefficient, $|R|$. Since $c$ and $\\hat{c}$ are speeds and thus positive, the denominator $\\hat{c}+c$ is always positive. The magnitude is:\n$$|R| = \\left| \\frac{\\hat{c} - c}{\\hat{c} + c} \\right| = \\frac{|\\hat{c} - c|}{\\hat{c} + c}$$\n\nThe second task is to find the absolute sensitivity of $|R|$ with respect to the estimated sound speed $\\hat{c}$, which is $|\\partial |R| / \\partial \\hat{c}|$. We must differentiate $|R|$ with respect to $\\hat{c}$. Let's consider the cases $\\hat{c} \\neq c$.\nIf $\\hat{c} > c$, then $|R| = (\\hat{c}-c)/(\\hat{c}+c)$. Using the quotient rule for differentiation:\n$$\\frac{\\partial |R|}{\\partial \\hat{c}} = \\frac{1(\\hat{c}+c) - (\\hat{c}-c)1}{(\\hat{c}+c)^2} = \\frac{2c}{(\\hat{c}+c)^2}$$\nIf $\\hat{c} < c$, then $|R| = (c-\\hat{c})/(c+\\hat{c})$. Differentiating gives:\n$$\\frac{\\partial |R|}{\\partial \\hat{c}} = \\frac{-1(c+\\hat{c}) - (c-\\hat{c})1}{(c+\\hat{c})^2} = \\frac{-2c}{(c+\\hat{c})^2}$$\nThe two cases can be combined as $\\frac{\\partial |R|}{\\partial \\hat{c}} = \\text{sgn}(\\hat{c}-c) \\frac{2c}{(\\hat{c}+c)^2}$. The absolute sensitivity is therefore:\n$$\\left|\\frac{\\partial |R|}{\\partial \\hat{c}}\\right| = \\frac{2c}{(\\hat{c}+c)^2}$$\nThis expression is continuous and well-defined for all positive $c$ and $\\hat{c}$. At the point $\\hat{c}=c$, $|R|=0$ and its derivative is formally undefined. However, the limit of the absolute derivative as $\\hat{c} \\to c$ is $\\frac{2c}{(c+c)^2} = \\frac{1}{2c}$, which represents the magnitude of the rate of change of reflection near the perfect-match condition. Thus, we use this formula for all cases.\n\nThe third task is to find the absolute sensitivity of $|R|$ with respect to the estimated ratio of specific heats $\\hat{\\gamma}$, which is $|\\partial |R| / \\partial \\hat{\\gamma}|$. We apply the chain rule:\n$$\\frac{\\partial |R|}{\\partial \\hat{\\gamma}} = \\frac{\\partial |R|}{\\partial \\hat{c}} \\frac{\\partial \\hat{c}}{\\partial \\hat{\\gamma}}$$\nThe estimated sound speed $\\hat{c}$ is given by $\\hat{c} = \\sqrt{\\hat{\\gamma} R T_0}$. Its derivative with respect to $\\hat{\\gamma}$ is:\n$$\\frac{\\partial \\hat{c}}{\\partial \\hat{\\gamma}} = \\frac{\\partial}{\\partial \\hat{\\gamma}} \\left( (\\hat{\\gamma} R T_0)^{1/2} \\right) = \\frac{1}{2} (\\hat{\\gamma} R T_0)^{-1/2} (R T_0) = \\frac{\\sqrt{\\hat{\\gamma} R T_0}}{2\\hat{\\gamma}} = \\frac{\\hat{c}}{2\\hat{\\gamma}}$$\nSubstituting this and the expression for $\\partial|R|/\\partial\\hat{c}$ into the chain rule gives:\n$$\\frac{\\partial |R|}{\\partial \\hat{\\gamma}} = \\left( \\text{sgn}(\\hat{c}-c) \\frac{2c}{(\\hat{c}+c)^2} \\right) \\left( \\frac{\\hat{c}}{2\\hat{\\gamma}} \\right) = \\text{sgn}(\\hat{c}-c) \\frac{c \\hat{c}}{\\hat{\\gamma} (\\hat{c}+c)^2}$$\nThe absolute sensitivity is therefore:\n$$\\left|\\frac{\\partial |R|}{\\partial \\hat{\\gamma}}\\right| = \\frac{c \\hat{c}}{\\hat{\\gamma} (\\hat{c}+c)^2}$$\n\nThe local sound speed $c$ is affected by non-isentropic perturbations, given by $c \\approx \\sqrt{\\gamma R T_0}\\,(1 + \\tfrac{1}{2}\\sigma)$. For test cases where $\\hat{\\gamma}$ is not specified, $\\hat{c}$ is given directly, meaning $\\partial\\hat{c}/\\partial\\hat{\\gamma}$ is $0$, and thus $|\\partial|R|/\\partial\\hat{\\gamma}|=0.0$.\n\nThese derived formulas will be implemented to compute the required triples for the given test cases.\nFor cases involving $\\gamma$ and $\\sigma$, the true local sound speed $c$ is computed as $c = \\sqrt{\\gamma R T_0} (1 + 0.5 \\sigma)$, and the estimated sound speed $\\hat{c}$ is computed as $\\hat{c} = \\sqrt{\\hat{\\gamma} R T_0}$.\nThe calculations for each test case are performed using these formulas.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the non-reflecting boundary condition problem for four test cases.\n    Derives the reflection coefficient and its sensitivities, then computes the numerical values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'direct', 'c': 340.0, 'c_hat': 333.0},\n        {'type': 'gamma', 'gamma': 1.4, 'gamma_hat': 1.39, 'R': 287.0, 'T0': 300.0, 'sigma': 0.02},\n        {'type': 'gamma', 'gamma': 1.4, 'gamma_hat': 1.4, 'R': 287.0, 'T0': 300.0, 'sigma': 0.0},\n        {'type': 'gamma', 'gamma': 1.4, 'gamma_hat': 1.2, 'R': 287.0, 'T0': 800.0, 'sigma': 0.1},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        if case['type'] == 'direct':\n            c = case['c']\n            c_hat = case['c_hat']\n            gamma_hat = None  # Indicates gamma_hat is not used for c_hat calculation\n        elif case['type'] == 'gamma':\n            gamma = case['gamma']\n            gamma_hat = case['gamma_hat']\n            R_const = case['R']\n            T0 = case['T0']\n            sigma = case['sigma']\n            \n            # Calculate the true local sound speed, c, including non-isentropic effects\n            c0 = np.sqrt(gamma * R_const * T0)\n            c = c0 * (1.0 + 0.5 * sigma)\n            \n            # Calculate the estimated sound speed, c_hat, used in the boundary condition\n            c_hat = np.sqrt(gamma_hat * R_const * T0)\n        else:\n            continue\n\n        # Formula 1: Reflection Coefficient Magnitude |R|\n        # |R| = |c_hat - c| / (c_hat + c)\n        if c_hat + c == 0:\n             # Avoid division by zero, though physically c, c_hat > 0\n            R_mag = np.inf if c_hat - c != 0 else 0.0\n        else:\n            R_mag = np.abs(c_hat - c) / (c_hat + c)\n\n        # Formula 2: Absolute Sensitivity of |R| with respect to c_hat\n        # |d|R|/d(c_hat)| = 2*c / (c_hat + c)^2\n        if (c_hat + c) == 0:\n            sens_c_hat_abs = np.inf\n        else:\n            sens_c_hat_abs = (2.0 * c) / (c_hat + c)**2\n\n        # Formula 3: Absolute Sensitivity of |R| with respect to gamma_hat\n        # |d|R|/d(gamma_hat)| = (c * c_hat) / (gamma_hat * (c_hat + c)^2)\n        if gamma_hat is not None:\n            if gamma_hat == 0 or (c_hat + c) == 0:\n                sens_gamma_hat_abs = np.inf\n            else:\n                sens_gamma_hat_abs = (c * c_hat) / (gamma_hat * (c_hat + c)**2)\n        else:\n            # Case where c_hat is given directly, so sensitivity to gamma_hat is 0.\n            sens_gamma_hat_abs = 0.0\n            \n        all_results.append([R_mag, sens_c_hat_abs, sens_gamma_hat_abs])\n\n    # Format the final output string as specified in the problem.\n    # e.g., \"[[r1,s1a,s1b],[r2,s2a,s2b],...]\"\n    formatted_results = []\n    for res_triple in all_results:\n        formatted_triple = ','.join(map(str, res_triple))\n        formatted_results.append(f\"[{formatted_triple}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3349564"}, {"introduction": "In modern high-order computational fluid dynamics, provable stability is paramount, and NRBCs can be formulated elegantly within an energy-stable framework like the Summation-By-Parts with Simultaneous Approximation Terms (SBP-SAT) method. This advanced practice involves implementing a scheme where the NRBC is enforced using a penalty term, and then verifying that the discrete energy dissipation at the boundary correctly matches the physical energy flux of the outgoing wave. This exercise reveals the profound connection between non-reflecting properties and the conservation of a discrete energy-like quantity, a cornerstone of modern numerical methods [@problem_id:3349573].", "problem": "You are asked to construct and verify a split-form Summation-By-Parts with Simultaneous Approximation Terms (SBP-SAT) semidiscrete scheme that implements a Non-Reflecting Boundary Condition (NRBC) via an entropy-stable boundary penalty, and to quantify that the discrete energy dissipation equals the outgoing wave energy flux at the outflow boundary. Consider the one-dimensional constant-coefficient linear advection equation on a uniform grid,\n$$\n\\partial_t u(x,t) + a \\, \\partial_x u(x,t) = 0,\\quad x \\in [0,L],\\ t \\ge 0,\n$$\nwith constant advection speed $a \\in \\mathbb{R}$, periodicity is not used, and the boundary at the inflow is prescribed by a time-dependent Dirichlet data $g(t)$ via a characteristic SAT penalty. The outflow boundary must be non-reflecting, meaning no incoming characteristic is imposed there.\n\nDiscretize the spatial interval using $N$ grid points $x_i = i h$ for $i=0,\\dots,N-1$ with $h = L/(N-1)$. Use the diagonal-norm SBP operator of second order for the first derivative, specified by a diagonal norm matrix $H = h\\ \\mathrm{diag}(w_0,\\dots,w_{N-1})$ with $w_0 = w_{N-1} = \\tfrac{1}{2}$ and $w_i = 1$ for $1 \\le i \\le N-2$, and a corresponding matrix $Q \\in \\mathbb{R}^{N \\times N}$ with entries\n$$\nQ_{i,i+1} = \\tfrac{1}{2},\\quad Q_{i+1,i} = -\\tfrac{1}{2}\\ \\text{for } i=0,\\dots,N-2,\\quad Q_{0,0}=-\\tfrac{1}{2},\\ Q_{N-1,N-1}=\\tfrac{1}{2},\n$$\nand zero elsewhere. This choice ensures the Summation-By-Parts (SBP) property $Q + Q^\\top = B$, where\n$$\nB = \\mathrm{diag}\\left(-1, 0,\\dots,0, 1\\right).\n$$\nThe split-form semidiscrete scheme reads\n$$\n\\frac{\\mathrm{d} \\mathbf{u}}{\\mathrm{d} t} = - a \\, H^{-1} Q \\mathbf{u} + H^{-1}\\left(\\sigma_L \\, \\mathbf{e}_0 \\left(g_L(t) - u_0\\right) + \\sigma_R \\, \\mathbf{e}_{N-1} \\left(g_R(t) - u_{N-1}\\right)\\right),\n$$\nwhere $\\mathbf{u} = [u_0,\\dots,u_{N-1}]^\\top$ is the vector of nodal values, $\\mathbf{e}_0$ and $\\mathbf{e}_{N-1}$ are the standard basis vectors selecting the first and last grid point, and the penalty coefficients are chosen to enforce an entropy-stable SAT inflow and a non-reflecting outflow:\n- If $a > 0$, then $x=0$ is the inflow: set $\\sigma_L = |a|$ with prescribed $g_L(t)$, and set $\\sigma_R = 0$ with $g_R$ unused.\n- If $a < 0$, then $x=L$ is the inflow: set $\\sigma_R = |a|$ with prescribed $g_R(t)$, and set $\\sigma_L = 0$ with $g_L$ unused.\n\nThe discrete energy is defined by\n$$\nE(t) = \\frac{1}{2} \\mathbf{u}(t)^\\top H \\mathbf{u}(t).\n$$\nUsing the SBP property, the semidiscrete energy rate satisfies\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\frac{a}{2} u_0^2 - \\frac{a}{2} u_{N-1}^2 + \\sigma_L u_0\\left(g_L(t) - u_0\\right) + \\sigma_R u_{N-1}\\left(g_R(t) - u_{N-1}\\right),\n$$\nwhich shows that the outflow boundary contribution to the energy is exactly the physically outgoing energy flux. Define the outgoing energy flux at the outflow boundary by\n$$\n\\Phi_{\\text{out}}(t) = \\frac{|a|}{2}\\, u_{\\text{out}}(t)^2,\\quad \\text{where } u_{\\text{out}}(t) = \\begin{cases} u_{N-1}(t), & a>0,\\\\ u_{0}(t), & a<0.\\end{cases}\n$$\nDefine the inflow energy supply term by\n$$\nR_{\\text{in}}(t) = \\begin{cases}\n\\frac{a}{2} u_0^2 + \\sigma_L u_0\\left(g_L(t) - u_0\\right), & a>0,\\\\\n\\frac{-a}{2} u_{N-1}^2 + \\sigma_R u_{N-1}\\left(g_R(t) - u_{N-1}\\right), & a<0.\n\\end{cases}\n$$\nThen the exact semidiscrete balance reads\n$$\nE(T) - E(0) = \\int_0^T R_{\\text{in}}(t)\\,\\mathrm{d}t - \\int_0^T \\Phi_{\\text{out}}(t)\\,\\mathrm{d}t.\n$$\nYour program must:\n- Implement the semidiscrete SBP-SAT scheme above.\n- Integrate in time using the third-order Strong Stability Preserving Runge-Kutta scheme (SSP-RK3) with adaptive boundary data evaluation at the scheme’s internal stages. Use a Courant-Friedrichs-Lewy number $\\mathrm{CFL} = 0.4$ so that the time step is $\\Delta t = \\mathrm{CFL}\\, h / |a|$.\n- For each test case defined below, compute the scalar error\n$$\n\\varepsilon = \\left|\\ \\int_0^T \\Phi_{\\text{out}}(t)\\,\\mathrm{d}t\\ -\\ \\left( \\int_0^T R_{\\text{in}}(t)\\,\\mathrm{d}t\\ - \\left(E(T)-E(0)\\right) \\right)\\ \\right|,\n$$\nusing the trapezoidal rule in time to approximate the integrals. This error quantifies whether the numerically dissipated energy matches the physically outgoing wave energy flux at the outflow boundary.\n\nInitial condition and boundary data:\n- Use nodal initialization $\\mathbf{u}(0)$ derived from a prescribed function $u(x,0)$.\n- For $a>0$, define $g_L(t)$ and set $g_R$ unused; for $a<0$, define $g_R(t)$ and set $g_L$ unused.\n\nAngle units are not used. No physical units are required. All reported numerical values must be dimensionless real numbers.\n\nTest Suite:\nProvide results for the following four test cases. For each case, specify $a$, $L$, $N$, $T$, $u(x,0)$, and the relevant boundary data $g(t)$.\n\n- Case 1 (Gaussian pulse, right-going, homogeneous inflow):\n  - $a = 1.0$, $L = 1.0$, $N = 201$, $T = 0.8$.\n  - $u(x,0) = \\exp\\left(-\\left(\\frac{x - 0.30}{0.05}\\right)^2\\right)$.\n  - $g_L(t) = 0$.\n\n- Case 2 (Pure inflow-driven right-going sine wave):\n  - $a = 1.0$, $L = 1.0$, $N = 201$, $T = 0.5$.\n  - $u(x,0) = 0$.\n  - $g_L(t) = \\sin\\left(2\\pi \\cdot 1.0 \\cdot t\\right)$.\n\n- Case 3 (Pure inflow-driven left-going cosine wave):\n  - $a = -1.0$, $L = 1.0$, $N = 201$, $T = 0.5$.\n  - $u(x,0) = 0$.\n  - $g_R(t) = \\cos\\left(2\\pi \\cdot 0.5 \\cdot t\\right)$.\n\n- Case 4 (Coarse grid edge case, right-going step-like pulse, homogeneous inflow):\n  - $a = 1.0$, $L = 1.0$, $N = 4$, $T = 0.1$.\n  - $$u(x,0) = \\begin{cases} 1, & x < 0.5,\\\\ 0, & x \\ge 0.5.\\end{cases}$$\n  - $g_L(t) = 0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test cases above, i.e., $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$. Each $\\varepsilon_i$ must be a floating-point number computed by your program. No additional text must be printed.", "solution": "The user has provided a valid, well-posed problem statement. The task is to implement a numerical scheme for the one-dimensional linear advection equation and to verify its discrete energy conservation properties. The problem is grounded in the established theory of Summation-By-Parts (SBP) operators and Simultaneous Approximation Term (SAT) penalty methods for imposing boundary conditions.\n\nThe solution proceeds as follows:\nFirst, we formulate the semidiscrete approximation of the governing partial differential equation, $\\partial_t u + a \\partial_x u = 0$. The spatial domain $x \\in [0, L]$ is discretized using $N$ grid points, $x_i = i h$ for $i=0, \\dots, N-1$, with a uniform grid spacing of $h = L/(N-1)$. The solution on this grid is represented by a vector $\\mathbf{u}(t) = [u_0(t), \\dots, u_{N-1}(t)]^\\top$, where $u_i(t) \\approx u(x_i, t)$.\n\nThe spatial derivative $\\partial_x u$ is approximated using a second-order accurate, diagonal-norm SBP operator. This approximation can be written in matrix form as $D\\mathbf{u} = H^{-1}Q\\mathbf{u}$. The matrix $H$ is a diagonal, positive-definite matrix that defines a discrete norm, equivalent to a quadrature rule for integrating functions on the grid. As specified, $H = h\\,\\mathrm{diag}(\\frac{1}{2}, 1, \\dots, 1, \\frac{1}{2})$. The matrix $Q$ is a finite difference operator designed to satisfy the SBP property, $Q+Q^\\top = B = \\mathrm{diag}(-1, 0, \\dots, 0, 1)$. This property is a discrete analogue of integration by parts, which is crucial for deriving stable numerical schemes.\n\nThe semidiscrete system, which is a system of ordinary differential equations (ODEs) in time, is given by\n$$\n\\frac{\\mathrm{d}\\mathbf{u}}{\\mathrm{d}t} = -a D \\mathbf{u} + \\text{BC terms} = -a H^{-1}Q\\mathbf{u} + H^{-1}\\left(\\sigma_L \\mathbf{e}_0 \\left(g_L(t) - u_0\\right) + \\sigma_R \\mathbf{e}_{N-1} \\left(g_R(t) - u_{N-1}\\right)\\right).\n$$\nThe boundary condition terms are imposed weakly using the SAT method. The penalty parameters $\\sigma_L$ and $\\sigma_R$ are chosen based on the direction of the advection velocity $a$ to enforce characteristic boundary conditions in an energy-stable manner.\n- If $a > 0$, the wave travels to the right. The left boundary at $x=0$ is an inflow, where we impose the Dirichlet condition $u(0,t) = g_L(t)$. The right boundary at $x=L$ is an outflow, where a non-reflecting boundary condition is desired. This is achieved by setting $\\sigma_L = |a| = a$ and $\\sigma_R = 0$.\n- If $a < 0$, the wave travels to the left. The right boundary at $x=L$ is an inflow, where $u(L,t) = g_R(t)$ is imposed. The left boundary at $x=0$ is an outflow. This corresponds to setting $\\sigma_R = |a| = -a$ and $\\sigma_L = 0$.\n\nA key feature of this SBP-SAT construction is its adherence to a discrete energy balance. The discrete energy of the system is defined as $E(t) = \\frac{1}{2} \\mathbf{u}^\\top H \\mathbf{u}$. The time evolution of this energy is found by taking the time derivative:\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\mathbf{u}^\\top H \\frac{\\mathrm{d}\\mathbf{u}}{\\mathrm{d}t} = \\mathbf{u}^\\top H \\left(-a H^{-1}Q\\mathbf{u} + \\text{SATs}\\right) = -a \\mathbf{u}^\\top Q \\mathbf{u} + \\mathbf{u}^\\top(\\text{SATs}).\n$$\nUsing the SBP property, the first term becomes $-a \\mathbf{u}^\\top (\\frac{1}{2}(Q+Q^\\top))\\mathbf{u} = -\\frac{a}{2}\\mathbf{u}^\\top B \\mathbf{u} = \\frac{a}{2}u_0^2 - \\frac{a}{2}u_{N-1}^2$. This precisely represents the energy flux at the boundaries. Combining this with the SAT terms leads to the specified energy rate equation:\n$$\n\\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\frac{a}{2} u_0^2 - \\frac{a}{2} u_{N-1}^2 + \\sigma_L u_0\\left(g_L(t) - u_0\\right) + \\sigma_R u_{N-1}\\left(g_R(t) - u_{N-1}\\right).\n$$\nThis equation can be rearranged as $\\frac{\\mathrm{d}E}{\\mathrm{d}t} = R_{\\text{in}}(t) - \\Phi_{\\text{out}}(t)$, where $R_{\\text{in}}(t)$ is the rate of energy supplied at the inflow boundary and $\\Phi_{\\text{out}}(t)$ is the rate of energy leaving at the outflow boundary. The non-reflecting boundary condition is implemented by choosing the SAT parameter at the outflow to be zero, which results in the boundary term in the energy balance becoming exactly the physical outgoing energy flux, e.g., $-\\frac{a}{2}u_{N-1}^2$ for $a>0$, which is $-\\Phi_{\\text{out}}(t)$.\n\nTo solve the semidiscrete system numerically, we employ the third-order Strong Stability Preserving Runge-Kutta (SSP-RK3) method for time integration. The time step $\\Delta t$ is chosen based on the Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t = \\mathrm{CFL} \\cdot h/|a|$, with $\\mathrm{CFL}=0.4$. To ensure the simulation ends precisely at time $T$, we adjust $\\Delta t$ slightly by calculating the number of steps as $N_{steps} = \\lceil T/\\Delta t_{\\mathrm{CFL}} \\rceil$ and then setting $\\Delta t = T/N_{steps}$. During the SSP-RK3 stages, the time-dependent boundary data, $g_L(t)$ or $g_R(t)$, is evaluated at the corresponding intermediate times.\n\nThe final task is to verify the energy balance numerically. Integrating the semidiscrete energy balance equation from $t=0$ to $t=T$ gives:\n$$\nE(T) - E(0) = \\int_0^T R_{\\text{in}}(t)\\,\\mathrm{d}t - \\int_0^T \\Phi_{\\text{out}}(t)\\,\\mathrm{d}t.\n$$\nThis identity holds exactly for the semidiscrete equations. However, numerical time integration introduces discretization errors. We quantify this discrepancy by calculating the error $\\varepsilon$:\n$$\n\\varepsilon = \\left| \\int_0^T \\Phi_{\\text{out}}(t)\\,\\mathrm{d}t - \\left( \\int_0^T R_{\\text{in}}(t)\\,\\mathrm{d}t - (E(T) - E(0)) \\right) \\right|.\n$$\nThe integrals are computed numerically from the time-series data using the trapezoidal rule. The value of $\\varepsilon$ represents the extent to which the numerical solution from the time-stepping scheme deviates from the exact energy balance of the semidiscrete system, and it is expected to be small, approaching zero as $\\Delta t \\to 0$.\n\nThe implementation will loop through the four specified test cases, perform the time integration for each, calculate the necessary time histories of boundary values and energy, compute the integrals, and finally determine the error $\\varepsilon$.", "answer": "```python\nimport numpy as np\n\ndef run_case(a, L, N, T, u_initial_func, g_inflow_func):\n    \"\"\"\n    Runs a single test case for the SBP-SAT scheme.\n\n    Args:\n        a (float): Advection speed.\n        L (float): Domain length.\n        N (int): Number of grid points.\n        T (float): Final time.\n        u_initial_func (callable): Function u(x) for initial condition.\n        g_inflow_func (callable): Function g(t) for inflow boundary data.\n\n    Returns:\n        float: The computed error epsilon.\n    \"\"\"\n    # 1. Grid and Parameters\n    h = L / (N - 1)\n    x = np.linspace(0, L, N)\n    CFL = 0.4\n    dt_cfl = CFL * h / np.abs(a)\n    num_steps = int(np.ceil(T / dt_cfl))\n    dt = T / num_steps\n\n    # 2. SBP Operators\n    # Q matrix\n    Q = np.diag(0.5 * np.ones(N - 1), k=1) + np.diag(-0.5 * np.ones(N - 1), k=-1)\n    Q[0, 0] = -0.5\n    Q[N - 1, N - 1] = 0.5\n    \n    # H matrix (diagonal)\n    w = np.ones(N)\n    w[0] = 0.5\n    w[N-1] = 0.5\n    h_diag = h * w\n    h_inv_diag = 1.0 / h_diag\n\n    # 3. Semidiscrete RHS function\n    def dUdt(t, u_vec):\n        du_dt = -a * (Q @ u_vec)\n        du_dt = h_inv_diag * du_dt\n        \n        # SAT Penalty terms\n        if a > 0: # Inflow at x=0\n            sigma_L = a\n            g_L = g_inflow_func(t)\n            sat_term_L = sigma_L * (g_L - u_vec[0])\n            du_dt[0] += h_inv_diag[0] * sat_term_L\n        elif a < 0: # Inflow at x=L\n            sigma_R = -a\n            g_R = g_inflow_func(t)\n            sat_term_R = sigma_R * (g_R - u_vec[-1])\n            du_dt[-1] += h_inv_diag[-1] * sat_term_R\n        return du_dt\n\n    # 4. Time Integration (SSP-RK3)\n    u = u_initial_func(x)\n    t = 0.0\n\n    t_hist = [t]\n    u0_hist = [u[0]]\n    uN1_hist = [u[-1]]\n\n    def get_energy(u_vec):\n        return 0.5 * np.sum(h_diag * u_vec**2)\n\n    E_hist = [get_energy(u)]\n    \n    for _ in range(num_steps):\n        # SSP-RK3 stages\n        u_stage1 = u + dt * dUdt(t, u)\n        u_stage2 = 0.75 * u + 0.25 * (u_stage1 + dt * dUdt(t + dt, u_stage1))\n        u = (1/3) * u + (2/3) * (u_stage2 + dt * dUdt(t + 0.5*dt, u_stage2))\n        \n        t += dt\n\n        t_hist.append(t)\n        u0_hist.append(u[0])\n        uN1_hist.append(u[-1])\n        E_hist.append(get_energy(u))\n\n    # 5. Post-processing and Error Calculation\n    t_hist = np.array(t_hist)\n    u0_hist = np.array(u0_hist)\n    uN1_hist = np.array(uN1_hist)\n    E_hist = np.array(E_hist)\n\n    # Calculate R_in and Phi_out time series\n    if a > 0:\n        sigma_L = a\n        g_L_hist = np.array([g_inflow_func(ti) for ti in t_hist])\n        R_in_hist = (a/2) * u0_hist**2 + sigma_L * u0_hist * (g_L_hist - u0_hist)\n        Phi_out_hist = (a/2) * uN1_hist**2\n    else: # a < 0\n        sigma_R = -a\n        g_R_hist = np.array([g_inflow_func(ti) for ti in t_hist])\n        R_in_hist = (-a/2) * uN1_hist**2 + sigma_R * uN1_hist * (g_R_hist - uN1_hist)\n        Phi_out_hist = (-a/2) * u0_hist**2\n\n    # Integrate using trapezoidal rule\n    integral_R_in = np.trapz(R_in_hist, x=t_hist)\n    integral_Phi_out = np.trapz(Phi_out_hist, x=t_hist)\n    \n    # Energy change\n    delta_E = E_hist[-1] - E_hist[0]\n\n    # Calculate error epsilon\n    epsilon = np.abs(integral_Phi_out - (integral_R_in - delta_E))\n    \n    return epsilon\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"a\": 1.0, \"L\": 1.0, \"N\": 201, \"T\": 0.8,\n            \"u_initial_func\": lambda x: np.exp(-((x - 0.3) / 0.05)**2),\n            \"g_inflow_func\": lambda t: 0.0,\n        },\n        # Case 2\n        {\n            \"a\": 1.0, \"L\": 1.0, \"N\": 201, \"T\": 0.5,\n            \"u_initial_func\": lambda x: np.zeros_like(x),\n            \"g_inflow_func\": lambda t: np.sin(2 * np.pi * 1.0 * t),\n        },\n        # Case 3\n        {\n            \"a\": -1.0, \"L\": 1.0, \"N\": 201, \"T\": 0.5,\n            \"u_initial_func\": lambda x: np.zeros_like(x),\n            \"g_inflow_func\": lambda t: np.cos(np.pi * t),\n        },\n        # Case 4\n        {\n            \"a\": 1.0, \"L\": 1.0, \"N\": 4, \"T\": 0.1,\n            \"u_initial_func\": lambda x: np.where(x < 0.5, 1.0, 0.0),\n            \"g_inflow_func\": lambda t: 0.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon = run_case(\n            case[\"a\"], case[\"L\"], case[\"N\"], case[\"T\"],\n            case[\"u_initial_func\"], case[\"g_inflow_func\"]\n        )\n        results.append(epsilon)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3349573"}]}