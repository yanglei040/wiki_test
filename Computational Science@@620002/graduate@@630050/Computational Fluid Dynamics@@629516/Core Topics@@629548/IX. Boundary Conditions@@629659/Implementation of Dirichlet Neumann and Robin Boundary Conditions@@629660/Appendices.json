{"hands_on_practices": [{"introduction": "A fundamental practice in computational science for verifying the correctness of a numerical solver is the Method of Manufactured Solutions (MMS). This exercise reverses the typical problem-solving workflow; instead of finding a solution $u(x,t)$ for a given problem, you will start with a chosen analytical solution and derive the corresponding source terms and boundary data that make it exact [@problem_id:3333209]. This hands-on calculation reinforces a deep understanding of the governing partial differential equation and the precise mathematical meaning of Dirichlet, Neumann, and Robin boundary conditions.", "problem": "Consider the one-dimensional heat conduction problem on a finite interval with position coordinate $x \\in [0,L]$ and time $t \\ge 0$, governed by the conservation of energy and Fourier’s law of heat conduction. Let the thermal diffusivity be the positive constant $\\kappa > 0$. The governing equation with a (to-be-determined) volumetric source term is\n$$\n\\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}} = s(x,t),\n$$\nwith a mixed (Robin) boundary condition at $x=0$ and a Neumann boundary condition at $x=L$,\n$$\n\\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t) = r(t), \\qquad \\kappa \\frac{\\partial u}{\\partial x}(L,t) = q_{N}(t),\n$$\nwhere $\\beta>0$ is a given constant. To exercise both terms of the Robin boundary implementation and to ensure a nontrivial Neumann flux, use the method of manufactured solutions with the choice\n$$\nu(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t),\n$$\nwhere $a>0$, $\\sigma \\in \\mathbb{R}$, and $\\gamma \\in \\mathbb{R}$ are constants such that $\\sigma \\ne \\gamma$. Starting from the definitions of the heat equation and the boundary conditions, compute the source term $s(x,t)$, the Robin boundary data $r(t)$, the Neumann boundary data $q_{N}(t)$, and the initial condition $u(x,0)$ in closed form so that the manufactured solution satisfies the problem for all $x \\in [0,L]$ and all $t \\ge 0$. Express your final answer as a single row matrix containing $s(x,t)$, $r(t)$, $q_{N}(t)$, and $u(x,0)$, in that order. Do not perform any numerical rounding; leave your answer in exact analytic form. All symbols represent physical quantities with their usual dimensions implied by the heat equation; no specific units are required for this problem.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $\\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}} = s(x,t)$ for $x \\in [0,L]$ and $t \\ge 0$.\n- **Thermal Diffusivity**: $\\kappa$ is a positive constant, $\\kappa > 0$.\n- **Robin Boundary Condition at $x=0$**: $\\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t) = r(t)$, where $\\beta$ is a positive constant, $\\beta > 0$.\n- **Neumann Boundary Condition at $x=L$**: $\\kappa \\frac{\\partial u}{\\partial x}(L,t) = q_{N}(t)$.\n- **Manufactured Solution**: $u(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t)$.\n- **Constants**: $a>0$, $\\sigma \\in \\mathbb{R}$, $\\gamma \\in \\mathbb{R}$, and $\\sigma \\ne \\gamma$.\n- **Objective**: Compute the source term $s(x,t)$, the Robin boundary data $r(t)$, the Neumann boundary data $q_{N}(t)$, and the initial condition $u(x,0)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem is based on the one-dimensional heat equation, a cornerstone of transport phenomena. The method of manufactured solutions is a standard, mathematically sound technique used in the verification of numerical algorithms for partial differential equations. The setup is scientifically and mathematically valid.\n- **Well-Posed**: The problem asks for the determination of source and boundary terms that are consistent with a prescribed solution. This is a direct calculation, not the solution of an inverse problem. The task is well-defined and yields a unique set of functions ($s(x,t)$, $r(t)$, $q_N(t)$, $u(x,0)$) for the given manufactured solution $u(x,t)$.\n- **Objective**: The problem is stated using precise mathematical language, free of ambiguity or subjective claims.\n- **Completeness and Consistency**: All necessary components—the governing PDE, the form of the boundary conditions, and the manufactured solution—are provided. There are no internal contradictions. For instance, the condition $\\sigma \\ne \\gamma$ is stated, which ensures the two temporal components of the solution are distinct, though this condition is not strictly required for the forthcoming calculations. All parameters are clearly defined.\n\n### Step 3: Verdict and Action\nThe problem is **valid** as it is scientifically grounded, well-posed, objective, and self-contained. A solution will be provided.\n\nThe method of manufactured solutions involves substituting the chosen analytical function for $u(x,t)$ into the governing partial differential equation and its boundary conditions to derive the necessary source term and boundary data.\n\nThe given manufactured solution is:\n$$\nu(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t)\n$$\nTo proceed, we must compute the relevant partial derivatives of $u(x,t)$.\n\nFirst, the partial derivative with respect to time $t$:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t) \\right) = \\sigma \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t)\n$$\n\nNext, the first partial derivative with respect to position $x$:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t) \\right) = -a \\exp(\\sigma t)\\,\\sin(a x) + \\exp(\\gamma t)\n$$\n\nFinally, the second partial derivative with respect to position $x$:\n$$\n\\frac{\\partial^{2} u}{\\partial x^{2}} = \\frac{\\partial}{\\partial x} \\left( -a \\exp(\\sigma t)\\,\\sin(a x) + \\exp(\\gamma t) \\right) = -a^2 \\exp(\\sigma t)\\,\\cos(a x)\n$$\n\nWith these derivatives, we can determine each required term.\n\n**1. Source Term $s(x,t)$**\nThe source term $s(x,t)$ is found by substituting the derivatives into the governing equation:\n$$\ns(x,t) = \\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}}\n$$\n$$\ns(x,t) = \\left( \\sigma \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t) \\right) - \\kappa \\left( -a^2 \\exp(\\sigma t)\\,\\cos(a x) \\right)\n$$\nCombining terms, we get:\n$$\ns(x,t) = (\\sigma + \\kappa a^2) \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t)\n$$\n\n**2. Robin Boundary Data $r(t)$**\nThe Robin boundary data $r(t)$ at $x=0$ is given by the formula:\n$$\nr(t) = \\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t)\n$$\nWe need to evaluate $u(x,t)$ and $\\frac{\\partial u}{\\partial x}(x,t)$ at $x=0$:\n$$\nu(0,t) = \\exp(\\sigma t)\\,\\cos(a \\cdot 0) + 0 \\cdot \\exp(\\gamma t) = \\exp(\\sigma t)\\,\\cos(0) = \\exp(\\sigma t)\n$$\n$$\n\\frac{\\partial u}{\\partial x}(0,t) = -a \\exp(\\sigma t)\\,\\sin(a \\cdot 0) + \\exp(\\gamma t) = -a \\exp(\\sigma t)\\,\\sin(0) + \\exp(\\gamma t) = \\exp(\\gamma t)\n$$\nSubstituting these into the expression for $r(t)$:\n$$\nr(t) = \\kappa (\\exp(\\gamma t)) + \\beta (\\exp(\\sigma t)) = \\beta \\exp(\\sigma t) + \\kappa \\exp(\\gamma t)\n$$\n\n**3. Neumann Boundary Data $q_{N}(t)$**\nThe Neumann boundary data $q_{N}(t)$ at $x=L$ is defined as:\n$$\nq_{N}(t) = \\kappa \\frac{\\partial u}{\\partial x}(L,t)\n$$\nWe evaluate $\\frac{\\partial u}{\\partial x}(x,t)$ at $x=L$:\n$$\n\\frac{\\partial u}{\\partial x}(L,t) = -a \\exp(\\sigma t)\\,\\sin(a L) + \\exp(\\gamma t)\n$$\nTherefore, $q_N(t)$ is:\n$$\nq_{N}(t) = \\kappa \\left( \\exp(\\gamma t) - a \\sin(a L) \\exp(\\sigma t) \\right)\n$$\n\n**4. Initial Condition $u(x,0)$**\nThe initial condition is the value of the solution at time $t=0$:\n$$\nu(x,0) = u(x,t)\\big|_{t=0} = \\exp(\\sigma \\cdot 0)\\,\\cos(a x) + x\\,\\exp(\\gamma \\cdot 0)\n$$\n$$\nu(x,0) = \\exp(0)\\,\\cos(a x) + x\\,\\exp(0) = 1 \\cdot \\cos(a x) + x \\cdot 1\n$$\n$$\nu(x,0) = \\cos(a x) + x\n$$\n\nThe four required quantities have been determined in closed form. They are collected to form the final answer.", "answer": "$$\n\\boxed{\\begin{pmatrix} (\\sigma + \\kappa a^2) \\exp(\\sigma t)\\cos(a x) + \\gamma x\\exp(\\gamma t) & \\beta \\exp(\\sigma t) + \\kappa \\exp(\\gamma t) & \\kappa (\\exp(\\gamma t) - a \\sin(a L) \\exp(\\sigma t)) & \\cos(a x) + x \\end{pmatrix}}\n$$", "id": "3333209"}, {"introduction": "Moving from continuous mathematics to a discrete numerical framework, this practice focuses on a core task in developing a Finite Volume Method (FVM) solver. You will derive the discrete representation of a diffusive flux across a boundary face where a Robin condition is applied [@problem_id:3333247]. The process involves skillfully combining the physical definition of the boundary condition with the geometric approximation of the scalar gradient to eliminate the unknown face value and formulate an algebraic coefficient. Mastering this derivation is crucial for correctly implementing generalized boundary conditions, as these coefficients directly form the matrix of the linear system your code will solve.", "problem": "Consider a scalar transport governed by purely diffusive physics in a bounded domain, discretized by the Finite Volume Method (FVM). Let $\\Omega_P$ denote a control volume with centroid at $\\mathbf{x}_P$, and let $\\Gamma_f$ be a planar boundary face of area $A_f$, outward unit normal $\\hat{\\mathbf{n}}_f$, and centroid at $\\mathbf{x}_f$. Assume isotropic, constant diffusivity $\\kappa>0$ and a Robin boundary condition on $\\Gamma_f$ given by $\\kappa\\,\\partial u/\\partial n + \\beta\\,u = \\beta\\,g$, where $\\beta \\ge 0$ and $g$ is a prescribed face datum. The outward normal derivative is defined by $\\partial u/\\partial n = \\nabla u \\cdot \\hat{\\mathbf{n}}_f$ evaluated at $\\mathbf{x}_f$.\n\nIn the FVM implementation, approximate the normal derivative at $\\mathbf{x}_f$ using a linear extrapolation between the cell centroid and the face centroid along the normal direction, i.e., $\\partial u/\\partial n \\approx (u_f - u_P)/\\delta_{Pf}$, where $u_P$ is the cell-center value at $\\mathbf{x}_P$, $u_f$ is the face-center value at $\\mathbf{x}_f$, and $\\delta_{Pf} = (\\mathbf{x}_f - \\mathbf{x}_P)\\cdot \\hat{\\mathbf{n}}_f$ is the signed normal distance from $\\mathbf{x}_P$ to $\\mathbf{x}_f$.\n\nStarting from the definition of diffusive flux as the surface integral of the constitutive law, derive the discrete diffusive flux across $\\Gamma_f$ expressed solely in terms of $u_P$, $g$, $\\kappa$, $\\beta$, $\\delta_{Pf}$, and $A_f$, and then define the effective face coefficient $C_f$ by $\\Phi_f = C_f\\,(u_P - g)$, where $\\Phi_f$ is the outward diffusive flux across $\\Gamma_f$ associated with $\\Omega_P$. Compute the closed-form expression for $C_f$.\n\nYour final answer must be the single closed-form analytic expression for $C_f$. No numerical evaluation is required.", "solution": "The problem requires the derivation of the effective face coefficient $C_f$ for a diffusive flux across a boundary face governed by a Robin boundary condition, within the context of the Finite Volume Method (FVM).\n\nThe outward diffusive flux, $\\Phi_f$, across the boundary face $\\Gamma_f$ of the control volume $\\Omega_P$ is defined by the surface integral of the flux vector. The constitutive law for isotropic diffusion (Fick's or Fourier's law) states that the flux vector is $\\mathbf{q} = -\\kappa \\nabla u$, where $\\kappa$ is the diffusivity and $u$ is the scalar field. The total outward flux is therefore:\n$$\n\\Phi_f = \\int_{\\Gamma_f} (-\\kappa \\nabla u) \\cdot \\hat{\\mathbf{n}}_f \\, dS\n$$\nwhere $\\hat{\\mathbf{n}}_f$ is the outward unit normal vector to the face $\\Gamma_f$ and $dS$ is the differential surface element.\n\nIn the Finite Volume Method, we approximate this integral. Given that the face $\\Gamma_f$ is planar with area $A_f$, and the diffusivity $\\kappa$ is constant, we can approximate the integral by assuming the integrand is constant over the face and equal to its value at the face centroid $\\mathbf{x}_f$. This yields:\n$$\n\\Phi_f \\approx A_f (-\\kappa \\nabla u \\cdot \\hat{\\mathbf{n}}_f)\\big|_{\\mathbf{x}_f}\n$$\nThe term $\\nabla u \\cdot \\hat{\\mathbf{n}}_f$ is the definition of the normal derivative, $\\partial u / \\partial n$. Thus, the discrete flux is:\n$$\n\\Phi_f \\approx -A_f \\kappa \\left(\\frac{\\partial u}{\\partial n}\\right)\\bigg|_{\\mathbf{x}_f}\n$$\nThis expression depends on the normal derivative at the face, which must be determined using the boundary condition and the FVM discretization scheme.\n\nWe are given two key pieces of information involving the normal derivative at the face:\n1.  The Robin boundary condition, evaluated at the face centroid $\\mathbf{x}_f$:\n    $$\n    \\kappa \\left(\\frac{\\partial u}{\\partial n}\\right)\\bigg|_{\\mathbf{x}_f} + \\beta u_f = \\beta g\n    $$\n    where $u_f$ is the value of the scalar field $u$ at the face centroid. From this, we can express the term $\\kappa (\\partial u/\\partial n)$ as:\n    $$\n    \\kappa \\left(\\frac{\\partial u}{\\partial n}\\right)\\bigg|_{\\mathbf{x}_f} = \\beta (g - u_f)\n    $$\n2.  The FVM approximation for the normal derivative, based on a linear extrapolation between the cell-center value $u_P$ and the face-center value $u_f$:\n    $$\n    \\left(\\frac{\\partial u}{\\partial n}\\right)\\bigg|_{\\mathbf{x}_f} \\approx \\frac{u_f - u_P}{\\delta_{Pf}}\n    $$\n    where $\\delta_{Pf} = (\\mathbf{x}_f - \\mathbf{x}_P)\\cdot \\hat{\\mathbf{n}}_f$ is the signed normal distance from the cell centroid to the face centroid. Multiplying by $\\kappa$ gives:\n    $$\n    \\kappa \\left(\\frac{\\partial u}{\\partial n}\\right)\\bigg|_{\\mathbf{x}_f} \\approx \\frac{\\kappa}{\\delta_{Pf}} (u_f - u_P)\n    $$\nOur goal is to find an expression for the flux $\\Phi_f$ that depends only on the cell-center value $u_P$, the boundary datum $g$, and known geometric and physical parameters. The face value $u_f$ is an unknown that must be eliminated. We can achieve this by equating the two expressions for $\\kappa (\\partial u / \\partial n)|_{\\mathbf{x}_f}$:\n$$\n\\beta (g - u_f) = \\frac{\\kappa}{\\delta_{Pf}} (u_f - u_P)\n$$\nNow, we solve this equation for $u_f$:\n$$\n\\beta g - \\beta u_f = \\frac{\\kappa}{\\delta_{Pf}} u_f - \\frac{\\kappa}{\\delta_{Pf}} u_P\n$$\n$$\n\\beta g + \\frac{\\kappa}{\\delta_{Pf}} u_P = u_f \\left( \\beta + \\frac{\\kappa}{\\delta_{Pf}} \\right)\n$$\n$$\nu_f = \\frac{\\beta g + \\frac{\\kappa}{\\delta_{Pf}} u_P}{\\beta + \\frac{\\kappa}{\\delta_{Pf}}}\n$$\nTo simplify, we multiply the numerator and denominator by $\\delta_{Pf}$:\n$$\nu_f = \\frac{\\beta \\delta_{Pf} g + \\kappa u_P}{\\beta \\delta_{Pf} + \\kappa}\n$$\nNow we can express the flux $\\Phi_f$ in terms of known quantities. Let's substitute the expression for $u_f$ into the FVM-approximated flux equation, $\\Phi_f \\approx -A_f \\frac{\\kappa}{\\delta_{Pf}} (u_f - u_P)$:\n$$\n\\Phi_f = -A_f \\frac{\\kappa}{\\delta_{Pf}} \\left( \\frac{\\beta \\delta_{Pf} g + \\kappa u_P}{\\beta \\delta_{Pf} + \\kappa} - u_P \\right)\n$$\nTo simplify the term in the parentheses, we find a common denominator:\n$$\n\\frac{\\beta \\delta_{Pf} g + \\kappa u_P}{\\beta \\delta_{Pf} + \\kappa} - u_P = \\frac{(\\beta \\delta_{Pf} g + \\kappa u_P) - u_P(\\beta \\delta_{Pf} + \\kappa)}{\\beta \\delta_{Pf} + \\kappa}\n$$\n$$\n= \\frac{\\beta \\delta_{Pf} g + \\kappa u_P - \\beta \\delta_{Pf} u_P - \\kappa u_P}{\\beta \\delta_{Pf} + \\kappa}\n$$\n$$\n= \\frac{\\beta \\delta_{Pf} g - \\beta \\delta_{Pf} u_P}{\\beta \\delta_{Pf} + \\kappa} = \\frac{\\beta \\delta_{Pf} (g - u_P)}{\\kappa + \\beta \\delta_{Pf}}\n$$\nSubstituting this simplified expression back into the equation for $\\Phi_f$:\n$$\n\\Phi_f = -A_f \\frac{\\kappa}{\\delta_{Pf}} \\left( \\frac{\\beta \\delta_{Pf} (g - u_P)}{\\kappa + \\beta \\delta_{Pf}} \\right)\n$$\nThe $\\delta_{Pf}$ terms in the numerator and denominator cancel out:\n$$\n\\Phi_f = -A_f \\kappa \\left( \\frac{\\beta (g - u_P)}{\\kappa + \\beta \\delta_{Pf}} \\right)\n$$\nTo match the a priori form $\\Phi_f = C_f(u_P - g)$, we absorb the negative sign into the parenthesis term:\n$$\n\\Phi_f = A_f \\kappa \\left( \\frac{\\beta (u_P - g)}{\\kappa + \\beta \\delta_{Pf}} \\right)\n$$\nRe-arranging to isolate the coefficient of $(u_P - g)$:\n$$\n\\Phi_f = \\left( \\frac{A_f \\kappa \\beta}{\\kappa + \\beta \\delta_{Pf}} \\right) (u_P - g)\n$$\nBy direct comparison with the required form $\\Phi_f = C_f(u_P - g)$, we can identify the effective face coefficient $C_f$:\n$$\nC_f = \\frac{A_f \\kappa \\beta}{\\kappa + \\beta \\delta_{Pf}}\n$$\nThis expression depends only on the given physical and geometrical parameters, as required.", "answer": "$$\n\\boxed{\\frac{A_f \\kappa \\beta}{\\kappa + \\beta \\delta_{Pf}}}\n$$", "id": "3333247"}, {"introduction": "This final practice synthesizes theory and implementation into a complete verification benchmark for a two-dimensional advection-diffusion problem. You are tasked with developing a finite difference solver from the ground up, implementing second-order accurate schemes for both the interior domain and the boundaries [@problem_id:3333213]. The challenge includes handling a mix of Dirichlet, Neumann, and Robin conditions, with special attention to the logic at corners where different boundary types meet. By building and running this solver against a manufactured solution, you will gain invaluable hands-on experience in the complete workflow of code verification: from analytical derivation and discretization to implementation and error analysis.", "problem": "Design and implement a manufactured-solution benchmark for the steady, two-dimensional advection–diffusion equation with mixed boundary segments and ghost-cell stencils that preserve a target second-order accuracy, including near corners where Dirichlet, Neumann, and Robin boundaries meet.\n\nThe mathematical model is the steady advection–diffusion equation for a passive scalar field $u(x,y)$ in a square domain $\\Omega = [0,1]\\times[0,1]$:\n$$\n- \\nabla \\cdot \\left( \\nu \\nabla u \\right) + \\mathbf{a} \\cdot \\nabla u \\;=\\; s(x,y) \\quad \\text{in } \\Omega,\n$$\nwhere $\\nu > 0$ is the (constant) diffusivity and $\\mathbf{a} = (a_x,a_y)$ is a (constant) advection velocity. The boundary $\\partial \\Omega$ is partitioned into three disjoint segments,\n$$\n\\partial \\Omega = \\Gamma_D \\cup \\Gamma_N \\cup \\Gamma_R, \\quad \\Gamma_D \\cap \\Gamma_N = \\Gamma_D \\cap \\Gamma_R = \\Gamma_N \\cap \\Gamma_R = \\emptyset,\n$$\non which the following boundary conditions are prescribed:\n- Dirichlet: $u|_{\\Gamma_D} = g$,\n- Neumann: $\\nabla u \\cdot \\mathbf{n}|_{\\Gamma_N} = h$,\n- Robin: $\\alpha u + \\beta \\nabla u \\cdot \\mathbf{n}|_{\\Gamma_R} = r$,\nwhere $\\mathbf{n}$ is the outward unit normal, and $\\alpha \\ge 0$, $\\beta \\ge 0$ are constants with at least one of $\\alpha$, $\\beta$ strictly positive. On corner points where boundary types meet, enforce a single condition following the priority $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$ to avoid over-determination.\n\nStart from conservation of a scalar quantity and Fick’s law as the fundamental base: the steady conservation law reads $\\nabla \\cdot \\mathbf{J} + q = 0$ with flux $\\mathbf{J} = -\\nu \\nabla u + \\mathbf{a} u$ and $q = -s$, yielding the partial differential equation above.\n\nTo enable a quantitative test, adopt a manufactured analytic solution\n$$\nu(x,y) \\;=\\; \\sin(2\\pi x)\\,\\cos(\\pi y) \\;+\\; x\\,y,\n$$\nand define the right-hand side $s(x,y)$ by substituting this $u(x,y)$ into the governing equation with the specified $\\nu$ and $\\mathbf{a}$. For boundary data, define\n- $g(x,y) = u(x,y)$ on $\\Gamma_D$,\n- $h(x,y) = \\nabla u \\cdot \\mathbf{n}$ on $\\Gamma_N$,\n- $r(x,y) = \\alpha u + \\beta \\nabla u \\cdot \\mathbf{n}$ on $\\Gamma_R$,\nso the manufactured solution exactly satisfies the model.\n\nDiscretization requirements:\n- Use a node-centered, uniform Cartesian grid with $N_x+1$ points in the $x$-direction and $N_y+1$ points in the $y$-direction, with $x_i = i \\Delta x$, $\\Delta x = 1/N_x$, $i=0,\\dots,N_x$, and $y_j = j \\Delta y$, $\\Delta y = 1/N_y$, $j=0,\\dots,N_y$.\n- Discretize the differential operator at interior nodes using second-order central finite differences for both diffusion and advection, i.e., for an interior node $(i,j)$,\n$$\n- \\nu \\left( \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2} \\right)\n+ a_x \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x}\n+ a_y \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta y}\n= s(x_i,y_j).\n$$\n- Implement boundary conditions using ghost-cell stencils that, when algebraically eliminated, yield one-sided, second-order accurate boundary equations at boundary nodes. Explicitly derive the following canonical stencils on a node-centered grid:\n  1. Dirichlet at a boundary node $(i,j)$: $u_{i,j} = g(x_i,y_j)$.\n  2. Neumann at the bottom boundary $y=0$ with outward normal $\\mathbf{n}=(0,-1)$ so that $\\nabla u \\cdot \\mathbf{n} = -u_y$:\n     starting from the central normal derivative with a ghost value $u_{i,-1}$,\n     $$\n     -\\frac{u_{i,1} - u_{i,-1}}{2\\Delta y} = h(x_i,0),\n     $$\n     eliminate $u_{i,-1}$ by fitting a quadratic through $u_{i,0}$, $u_{i,1}$, $u_{i,2}$ to obtain the second-order one-sided stencil\n     $$\n     -\\frac{-3u_{i,0} + 4u_{i,1} - u_{i,2}}{2\\Delta y} = h(x_i,0).\n     $$\n  3. Robin at the right boundary $x=1$ with outward normal $\\mathbf{n}=(1,0)$ so that $\\nabla u \\cdot \\mathbf{n} = u_x$:\n     starting from $\\alpha u + \\beta u_x = r$ with ghost value $u_{N_x+1,j}$, eliminate the ghost by a quadratic fit through $u_{N_x,j}$, $u_{N_x-1,j}$, $u_{N_x-2,j}$ to obtain\n     $$\n     \\alpha u_{N_x,j} + \\beta \\frac{3u_{N_x,j} - 4u_{N_x-1,j} + u_{N_x-2,j}}{2\\Delta x} = r(1,y_j).\n     $$\n- Near corners, enforce only one boundary condition according to the priority $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$ and use the above one-sided stencils along each edge away from the corner nodes. Ensure the resulting global linear system is square and well-posed.\n\nBoundary segmentation for this benchmark must be as follows:\n- $\\Gamma_D$: the left edge $x=0$ and the top edge $y=1$,\n- $\\Gamma_N$: the bottom edge $y=0$,\n- $\\Gamma_R$: the right edge $x=1$,\nwith the corner selection rule as specified.\n\nNumerical outputs: Implement the scheme described above to assemble and solve the linear system for $u_{i,j}$ using a sparse linear solver. Compute error norms against the manufactured solution on interior nodes:\n- The discrete $L^2$-norm\n$$\n\\|e\\|_{L^2_h} = \\left( \\sum_{i=1}^{N_x-1} \\sum_{j=1}^{N_y-1} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|^2 \\,\\Delta x \\Delta y \\right)^{1/2},\n$$\n- The discrete $L^\\infty$-norm\n$$\n\\|e\\|_{L^\\infty_h} = \\max_{1 \\le i \\le N_x-1,\\;1 \\le j \\le N_y-1} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|.\n$$\n\nTest suite: Your program must run the following three test cases and aggregate the results into a single output line as specified below.\n\n- Test 1 (happy path): $N_x=N_y=32$, $\\nu=0.07$, $a_x=1.2$, $a_y=-0.8$, $\\alpha=2.0$, $\\beta=1.0$. Output the discrete $L^2$-norm as a floating-point number.\n- Test 2 (order of accuracy near a Dirichlet–Neumann and Dirichlet–Robin corner): compute the discrete $L^2$-norms for $N_x=N_y=16$ and $N_x=N_y=32$ with $\\nu=0.07$, $a_x=1.2$, $a_y=-0.8$, $\\alpha=2.0$, $\\beta=1.0$, and then report the observed order\n$$\np = \\log_2\\left( \\frac{\\|e\\|_{L^2_h}(N_x=16)}{\\|e\\|_{L^2_h}(N_x=32)} \\right).\n$$\n- Test 3 (altered Robin strength and advection): $N_x=N_y=36$, $\\nu=0.10$, $a_x=1.6$, $a_y=0.4$, $\\alpha=0.5$, $\\beta=2.0$. Output the discrete $L^\\infty$-norm as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order of Test 1, Test 2, Test 3; for example, \"[result1,result2,result3]\". No units are used; all quantities are nondimensional.", "solution": "The problem requires the design and implementation of a numerical benchmark for the two-dimensional, steady-state advection-diffusion equation using the method of manufactured solutions. This involves deriving the necessary analytical terms, discretizing the governing partial differential equation (PDE) on a uniform grid, implementing various boundary conditions including at corners where different boundary types meet, and finally verifying the implementation by comparing the numerical solution to the known analytical solution.\n\n### Analytical Formulation\n\nThe governing equation is the steady advection-diffusion equation for a scalar field $u(x,y)$ on the domain $\\Omega = [0,1]\\times[0,1]$:\n$$\n- \\nabla \\cdot \\left( \\nu \\nabla u \\right) + \\mathbf{a} \\cdot \\nabla u = s(x,y)\n$$\nwhere $\\nu > 0$ is the constant diffusivity, $\\mathbf{a}=(a_x, a_y)$ is the constant advection velocity, and $s(x,y)$ is a source term.\n\nA manufactured solution is prescribed for verification purposes:\n$$\nu(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + xy\n$$\nTo determine the source term $s(x,y)$ that makes this $u(x,y)$ an exact solution, we compute the necessary partial derivatives:\n$$\nu_x = \\frac{\\partial u}{\\partial x} = 2\\pi \\cos(2\\pi x)\\cos(\\pi y) + y\n$$\n$$\nu_y = \\frac{\\partial u}{\\partial y} = -\\pi \\sin(2\\pi x)\\sin(\\pi y) + x\n$$\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = -4\\pi^2 \\sin(2\\pi x)\\cos(\\pi y) - \\pi^2 \\sin(2\\pi x)\\cos(\\pi y) = -5\\pi^2 \\sin(2\\pi x)\\cos(\\pi y)\n$$\nSubstituting these into the PDE gives the source term:\n$$\ns(x,y) = -\\nu(\\nabla^2 u) + a_x u_x + a_y u_y\n$$\n$$\ns(x,y) = 5\\pi^2 \\nu \\sin(2\\pi x)\\cos(\\pi y) + a_x (2\\pi \\cos(2\\pi x)\\cos(\\pi y) + y) + a_y (-\\pi \\sin(2\\pi x)\\sin(\\pi y) + x)\n$$\nThe boundary conditions are defined on the partition $\\partial \\Omega = \\Gamma_D \\cup \\Gamma_N \\cup \\Gamma_R$. The data for these conditions are derived from the manufactured solution.\n1.  **Dirichlet Boundary ($\\Gamma_D$: left edge $x=0$, top edge $y=1$)**: The condition is $u=g$.\n    $$\n    g(x,y) = u(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + xy\n    $$\n2.  **Neumann Boundary ($\\Gamma_N$: bottom edge $y=0$)**: The condition is $\\nabla u \\cdot \\mathbf{n} = h$. The outward normal is $\\mathbf{n}=(0,-1)$, so $\\nabla u \\cdot \\mathbf{n} = -u_y$.\n    $$\n    h(x,0) = -u_y(x,0) = -(-\\pi \\sin(2\\pi x)\\sin(0) + x) = -x\n    $$\n3.  **Robin Boundary ($\\Gamma_R$: right edge $x=1$)**: The condition is $\\alpha u + \\beta \\nabla u \\cdot \\mathbf{n} = r$. The outward normal is $\\mathbf{n}=(1,0)$, so $\\nabla u \\cdot \\mathbf{n} = u_x$.\n    $$\n    r(1,y) = \\alpha u(1,y) + \\beta u_x(1,y)\n    $$\n    With $u(1,y) = \\sin(2\\pi)\\cos(\\pi y) + y = y$ and $u_x(1,y) = 2\\pi \\cos(2\\pi)\\cos(\\pi y) + y = 2\\pi\\cos(\\pi y) + y$, we get:\n    $$\n    r(1,y) = \\alpha y + \\beta(2\\pi\\cos(\\pi y) + y) = (\\alpha + \\beta)y + 2\\pi\\beta\\cos(\\pi y)\n    $$\n\n### Discretization and Linear System Assembly\n\nWe use a node-centered grid with $N_x+1$ points in the $x$-direction and $N_y+1$ points in the $y$-direction. The grid points are $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ for $i=0,\\dots,N_x$ and $j=0,\\dots,N_y$, where $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The numerical solution at these points is denoted $u_{i,j}$.\n\nThis set of unknowns is arranged into a single column vector $\\mathbf{U}$ of size $(N_x+1)(N_y+1)$, using a row-major mapping from the 2D indices $(i,j)$ to a 1D index $k$: $k = j(N_x+1) + i$. The discretization leads to a sparse linear system of equations $A\\mathbf{U} = \\mathbf{b}$, where $A$ is a square matrix of size $((N_x+1)(N_y+1)) \\times ((N_x+1)(N_y+1))$. We assemble this system by defining an equation for each grid point $(i,j)$.\n\n**Interior Nodes ($1 \\le i \\le N_x-1, 1 \\le j \\le N_y-1$)**:\nThe PDE is discretized using second-order central differences:\n$$\n- \\nu \\left( \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2} \\right) + a_x \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x} + a_y \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta y} = s(x_i,y_j)\n$$\nRearranging terms gives a 5-point stencil equation defining a row in matrix $A$:\n$$\n\\left(\\frac{2\\nu}{\\Delta x^2} + \\frac{2\\nu}{\\Delta y^2}\\right) u_{i,j} + \\left(-\\frac{\\nu}{\\Delta x^2} - \\frac{a_x}{2\\Delta x}\\right)u_{i-1,j} + \\left(-\\frac{\\nu}{\\Delta x^2} + \\frac{a_x}{2\\Delta x}\\right)u_{i+1,j} + \\left(-\\frac{\\nu}{\\Delta y^2} - \\frac{a_y}{2\\Delta y}\\right)u_{i,j-1} + \\left(-\\frac{\\nu}{\\Delta y^2} + \\frac{a_y}{2\\Delta y}\\right)u_{i,j+1} = s(x_i,y_j)\n$$\n\n**Boundary and Corner Nodes**:\nThe equations for boundary and corner nodes are determined by the specified boundary conditions and the corner priority rule $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$.\n\n- **Left Edge ($i=0, \\Gamma_D$) and Top Edge ($j=N_y, \\Gamma_D$)**: Dirichlet condition $u=g$.\n  For $i=0, 0 \\le j \\le N_y$: $u_{0,j} = g(0,y_j)$.\n  For $j=N_y, 1 \\le i \\le N_x$: $u_{i,N_y} = g(x_i,1)$.\n  These are simple identity equations, e.g., $1 \\cdot u_{0,j} = g(0,y_j)$, forming a row with a single $1$ on the diagonal.\n\n- **Bottom Edge ($j=0, 1 \\le i \\le N_x-1, \\Gamma_N$)**: Neumann condition. The second-order one-sided stencil is $\\nabla u \\cdot \\mathbf{n} = -u_y=h$, which discretizes to:\n  $$\n  -\\frac{-3u_{i,0} + 4u_{i,1} - u_{i,2}}{2\\Delta y} = h(x_i,0) \\implies 3u_{i,0} - 4u_{i,1} + u_{i,2} = 2\\Delta y \\cdot h(x_i,0)\n  $$\n\n- **Right Edge ($i=N_x, 1 \\le j \\le N_y-1, \\Gamma_R$)**: Robin condition. The second-order one-sided stencil for $\\alpha u + \\beta u_x = r$ is:\n  $$\n  \\alpha u_{N_x,j} + \\beta \\frac{3u_{N_x,j} - 4u_{N_x-1,j} + u_{N_x-2,j}}{2\\Delta x} = r(1,y_j)\n  $$\n  This can be rearranged into a linear equation involving $u_{N_x,j}, u_{N_x-1,j}, u_{N_x-2,j}$.\n\n- **Corner Nodes**:\n  - **$(0,0)$ (Left-Bottom)**: $\\Gamma_D$ meets $\\Gamma_N$. Priority $\\Gamma_D$. The equation is the Dirichlet condition: $u_{0,0} = g(0,0)$.\n  - **$(N_x,0)$ (Right-Bottom)**: $\\Gamma_R$ meets $\\Gamma_N$. Priority $\\Gamma_R$. The equation is the Robin stencil evaluated at $(i=N_x, j=0)$:\n    $$\n    \\alpha u_{N_x,0} + \\beta \\frac{3u_{N_x,0} - 4u_{N_x-1,0} + u_{N_x-2,0}}{2\\Delta x} = r(1,0)\n    $$\n  - **$(N_x,N_y)$ (Right-Top)**: $\\Gamma_R$ meets $\\Gamma_D$. Priority $\\Gamma_D$. The equation is the Dirichlet condition: $u_{N_x,N_y} = g(1,1)$.\n  - **$(0,N_y)$ (Left-Top)**: $\\Gamma_D$ meets $\\Gamma_D$. The equation is the Dirichlet condition: $u_{0,N_y} = g(0,1)$.\n\nBy systematically applying these rules for every grid point, a complete, square linear system $A\\mathbf{U} = \\mathbf{b}$ is formed. This system is solved using a sparse linear solver.\n\n### Error Analysis\n\nThe accuracy of the numerical solution $u_{i,j}^{\\text{num}}$ is assessed by comparing it to the exact manufactured solution $u(x_i,y_j)$ on the interior grid nodes ($1 \\le i \\le N_x-1, 1 \\le j \\le N_y-1$). The error $e_{i,j} = u_{i,j}^{\\text{num}} - u(x_i,y_j)$ is quantified using two discrete norms:\n\n- **$L^2$-norm**:\n  $$\n  \\|e\\|_{L^2_h} = \\left( \\sum_{i=1}^{N_x-1} \\sum_{j=1}^{N_y-1} |e_{i,j}|^2 \\,\\Delta x \\Delta y \\right)^{1/2}\n  $$\n- **$L^\\infty$-norm**:\n  $$\n  \\|e\\|_{L^\\infty_h} = \\max_{1 \\le i \\le N_x-1,\\;1 \\le j \\le N_y-1} |e_{i,j}|\n  $$\n\nThe rate of convergence, $p$, is computed via grid refinement studies. For a method with error $E \\propto (\\Delta x)^p$, comparing errors from two grids, one with spacing $h$ and one with $h/2$, gives $p=\\log_2(E_h / E_{h/2})$.\n\nThe provided Python code implements this entire procedure to solve the specified test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef u_exact(x, y):\n    \"\"\"Manufactured solution u(x,y).\"\"\"\n    return np.sin(2 * np.pi * x) * np.cos(np.pi * y) + x * y\n\ndef s_func(x, y, nu, ax, ay):\n    \"\"\"Source term s(x,y) derived from the manufactured solution.\"\"\"\n    term1 = 5 * np.pi**2 * nu * np.sin(2 * np.pi * x) * np.cos(np.pi * y)\n    term2 = ax * (2 * np.pi * np.cos(2 * np.pi * x) * np.cos(np.pi * y) + y)\n    term3 = ay * (-np.pi * np.sin(2 * np.pi * x) * np.sin(np.pi * y) + x)\n    return term1 + term2 + term3\n\ndef h_func_bottom(x):\n    \"\"\"Neumann boundary data h(x,0) on the bottom edge.\"\"\"\n    return -x\n\ndef r_func_right(y, alpha, beta):\n    \"\"\"Robin boundary data r(1,y) on the right edge.\"\"\"\n    return (alpha + beta) * y + 2 * np.pi * beta * np.cos(np.pi * y)\n\ndef run_simulation(Nx, Ny, nu, ax, ay, alpha, beta):\n    \"\"\"\n    Assembles and solves the linear system for the 2D advection-diffusion\n    equation with mixed boundary conditions.\n    \"\"\"\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n    num_points = (Nx + 1) * (Ny + 1)\n\n    x = np.linspace(0, 1, Nx + 1)\n    y = np.linspace(0, 1, Ny + 1)\n\n    A = lil_matrix((num_points, num_points), dtype=np.float64)\n    b = np.zeros(num_points, dtype=np.float64)\n\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            k = j * (Nx + 1) + i\n\n            # Boundary conditions have priority. Corner logic is embedded.\n            # Priority: Dirichlet > Robin > Neumann\n\n            # Left boundary (Dirichlet, i=0)\n            if i == 0:\n                A[k, k] = 1.0\n                b[k] = u_exact(x[i], y[j])\n                continue\n\n            # Top boundary (Dirichlet, j=Ny)\n            if j == Ny:\n                A[k, k] = 1.0\n                b[k] = u_exact(x[i], y[j])\n                continue\n\n            # Corner (Nx, 0) needs Robin, handled before general Neumann for j=0\n            if i == Nx and j == 0:\n                k_m1 = k - 1\n                k_m2 = k - 2\n                A[k, k]   = alpha + beta * 3.0 / (2.0 * dx)\n                A[k, k_m1] = -beta * 4.0 / (2.0 * dx)\n                A[k, k_m2] = beta * 1.0 / (2.0 * dx)\n                b[k] = r_func_right(y[j], alpha, beta)\n                continue\n\n            # Right boundary (Robin, i=Nx)\n            if i == Nx:\n                k_m1 = k - 1\n                k_m2 = k - 2\n                A[k, k] = alpha + beta * 3.0 / (2.0 * dx)\n                A[k, k_m1] = -beta * 4.0 / (2.0 * dx)\n                A[k, k_m2] = beta * 1.0 / (2.0 * dx)\n                b[k] = r_func_right(y[j], alpha, beta)\n                continue\n            \n            # Bottom boundary (Neumann, j=0)\n            if j == 0:\n                k_p1_y = (j + 1) * (Nx + 1) + i\n                k_p2_y = (j + 2) * (Nx + 1) + i\n                A[k, k] = 3.0 / (2.0 * dy)\n                A[k, k_p1_y] = -4.0 / (2.0 * dy)\n                A[k, k_p2_y] = 1.0 / (2.0 * dy)\n                # The provided stencil in the problem for Neumann is -u_y.\n                # So the equation is -(-3u0+4u1-u2)/(2dy)=h\n                # Which is (3u0-4u1+u2)/(2dy)=h\n                b[k] = h_func_bottom(x[i])\n                continue\n\n            # Interior nodes\n            k_p1_x = k + 1\n            k_m1_x = k - 1\n            k_p1_y = (j + 1) * (Nx + 1) + i\n            k_m1_y = (j - 1) * (Nx + 1) + i\n            \n            A[k, k]      = 2.0 * nu / dx**2 + 2.0 * nu / dy**2\n            A[k, k_p1_x] = -nu / dx**2 + ax / (2.0 * dx)\n            A[k, k_m1_x] = -nu / dx**2 - ax / (2.0 * dx)\n            A[k, k_p1_y] = -nu / dy**2 + ay / (2.0 * dy)\n            A[k, k_m1_y] = -nu / dy**2 - ay / (2.0 * dy)\n            b[k] = s_func(x[i], y[j], nu, ax, ay)\n\n    A_csr = A.tocsr()\n    u_vec = spsolve(A_csr, b)\n    u_num = u_vec.reshape((Ny + 1, Nx + 1))\n    \n    # Calculate error norms on interior nodes\n    u_exact_grid = np.zeros_like(u_num)\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            u_exact_grid[j, i] = u_exact(x[i], y[j])\n            \n    error_grid = u_num - u_exact_grid\n    \n    # Interior points: 1 <= i <= Nx-1, 1 <= j <= Ny-1\n    interior_errors = error_grid[1:Ny, 1:Nx]\n    \n    l2_norm = np.sqrt(np.sum(interior_errors**2) * dx * dy)\n    linf_norm = np.max(np.abs(interior_errors))\n    \n    return l2_norm, linf_norm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    results = []\n\n    # Test 1\n    nu_1, ax_1, ay_1 = 0.07, 1.2, -0.8\n    alpha_1, beta_1 = 2.0, 1.0\n    Nx1, Ny1 = 32, 32\n    l2_norm_1, _ = run_simulation(Nx1, Ny1, nu_1, ax_1, ay_1, alpha_1, beta_1)\n    results.append(l2_norm_1)\n\n    # Test 2\n    nu_2, ax_2, ay_2 = 0.07, 1.2, -0.8\n    alpha_2, beta_2 = 2.0, 1.0\n    \n    # N=16\n    l2_norm_16, _ = run_simulation(16, 16, nu_2, ax_2, ay_2, alpha_2, beta_2)\n    # N=32\n    l2_norm_32, _ = run_simulation(32, 32, nu_2, ax_2, ay_2, alpha_2, beta_2)\n    \n    # Check for non-positive norms to avoid log errors\n    if l2_norm_16 > 0 and l2_norm_32 > 0:\n        order_p = np.log2(l2_norm_16 / l2_norm_32)\n    else:\n        order_p = 0.0 # Or some indicator of an issue\n    results.append(order_p)\n\n    # Test 3\n    nu_3, ax_3, ay_3 = 0.10, 1.6, 0.4\n    alpha_3, beta_3 = 0.5, 2.0\n    Nx3, Ny3 = 36, 36\n    _, linf_norm_3 = run_simulation(Nx3, Ny3, nu_3, ax_3, ay_3, alpha_3, beta_3)\n    results.append(linf_norm_3)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3333213"}]}