{"hands_on_practices": [{"introduction": "A cornerstone of code verification is confirming that a numerical scheme achieves its theoretical order of accuracy. This practice provides a clear and direct application of the Method of Manufactured Solutions (MMS) to this task, focusing specifically on the temporal component of the discretization. By manufacturing a solution with known time evolution, you will learn to isolate and quantify the local truncation error of several common Runge-Kutta methods, thereby verifying their temporal accuracy in a controlled environment [@problem_id:3376840].", "problem": "Consider the one-dimensional linear advection-diffusion equation on the periodic domain $x \\in [0, 2\\pi]$,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t),\n$$\nwhere $a$ and $\\nu$ are constant coefficients and $s(x,t)$ is a source term to be determined. Use the Method of Manufactured Solutions (MMS) to derive a consistent source term by prescribing the exact solution\n$$\nu(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x),\n$$\nwhere $\\alpha$ and $\\beta$ are real constants and $k$ is a positive integer. All angles in trigonometric functions must be interpreted in radians. You may assume smoothness sufficient for all operations performed.\n\nTask 1. Starting from the fundamental definitions of partial derivatives and the given exact solution, derive the source term $s(x,t)$ such that $u(x,t)$ is an exact solution of the advection-diffusion equation. The derivation must begin by computing the time derivative $\\partial u/\\partial t$, the first spatial derivative $\\partial u/\\partial x$, and the second spatial derivative $\\partial^2 u/\\partial x^2$, and then substituting these into the governing equation to isolate $s(x,t)$.\n\nTask 2. Define the one-step discrete-time residual (also called the local defect) of a Runge–Kutta time integrator by inserting the exact manufactured solution along its internal stage abscissae. For a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$, the Runge–Kutta update applied along the exact trajectory is\n$$\nu^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right),\n$$\nwhere $m$ is the number of stages, $b_i$ and $c_i$ are the method weights and abscissae, and $F(x,t)$ denotes the right-hand side of the partial differential equation evaluated at the exact manufactured solution. Because the source term is chosen by MMS to enforce the solution, it holds for the manufactured solution that $F(x,t) = \\partial u/\\partial t(x,t)$. Define the one-step residual norm\n$$\n\\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])},\n$$\nwhere the $L^2$ norm is computed as the square root of the spatial average of the squared pointwise difference over the periodic domain.\n\nTask 3. Using the above residual definition, implement the following explicit Runge–Kutta methods by their weights $b_i$ and abscissae $c_i$, and evaluate the residual for a single time step starting at $t_n = 0$:\n- Forward Euler (one-stage): $m=1$, $b_1 = 1$, $c_1 = 0$.\n- Explicit midpoint (second order): $m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$, interpreted as the one-point midpoint quadrature of $\\partial u/\\partial t$ over the time step.\n- Classical Runge–Kutta of order four (four-stage): $m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$ and $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$.\n\nTask 4. For each method and a sequence of time steps $\\Delta t_1 > \\Delta t_2 > \\Delta t_3$, compute the empirical order of accuracy from the residuals as\n$$\np_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}.\n$$\nRepeat for the pair $\\left(\\Delta t_2, \\Delta t_3\\right)$.\n\nTask 5. Investigate superconvergence-like cancellation for oscillatory manufactured dynamics by setting $\\alpha = 0$ and selecting $\\beta$ and $\\Delta t$ such that $\\beta \\Delta t = \\pi$. In this case, the exact change of $u$ over one step is zero for the temporal factor, and certain quadratures may display enhanced cancellation. For the classical fourth-order Runge–Kutta method, compute the empirical orders $p_{\\text{est}}$ for the step pairs $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$ with $\\Delta t_2$ satisfying $\\beta \\Delta t_2 = \\pi$, and return a boolean flag indicating whether each empirical order exceeds the method’s nominal order plus $0.5$.\n\nImplementation details and units:\n- Use a periodic spatial grid with $N$ points uniformly distributed on $[0,2\\pi]$ to numerically approximate the $L^2$ norm as the square root of the mean squared difference over grid points.\n- All trigonometric angles must be interpreted in radians.\n- No physical dimensional units are required beyond the specification of the angular unit for trigonometric evaluation.\n\nTest Suite. Your program must implement the computations for the following three parameter sets, each producing two empirical orders or boolean flags as described:\n\n1. General dynamics, fourth-order method (happy path):\n   - Parameters: $a = 1.0$, $\\nu = 0.05$, $\\alpha = 0.1$, $\\beta = 2.0$, $k = 2$, $N = 256$.\n   - Method: classical fourth-order Runge–Kutta.\n   - Time steps: $\\Delta t_1 = 0.2$, $\\Delta t_2 = 0.1$, $\\Delta t_3 = 0.05$.\n   - Output: two floats, the empirical orders computed for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$.\n\n2. Time-dominated manufactured dynamics, second-order method (edge case emphasizing time-only variation):\n   - Parameters: $a = 0.0$, $\\nu = 0.0$, $\\alpha = 0.2$, $\\beta = 1.5$, $k = 3$, $N = 256$.\n   - Method: explicit midpoint.\n   - Time steps: $\\Delta t_1 = 0.3$, $\\Delta t_2 = 0.15$, $\\Delta t_3 = 0.075$.\n   - Output: two floats, the empirical orders computed for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$.\n\n3. Oscillatory superconvergence-like cancellation, fourth-order method:\n   - Parameters: $a = 0.5$, $\\nu = 0.01$, $\\alpha = 0.0$, $\\beta = 4\\pi$, $k = 4$, $N = 256$.\n   - Method: classical fourth-order Runge–Kutta.\n   - Time steps: $\\Delta t_1 = 0.5$, $\\Delta t_2 = 0.25$, $\\Delta t_3 = 0.125$ so that $\\beta \\Delta t_2 = \\pi$.\n   - Output: two booleans indicating whether the empirical orders for $\\left(\\Delta t_1,\\Delta t_2\\right)$ and $\\left(\\Delta t_2,\\Delta t_3\\right)$ exceed $4.5$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[ p^{(1)}_{12},\\, p^{(1)}_{23},\\, p^{(2)}_{12},\\, p^{(2)}_{23},\\, \\text{flag}^{(3)}_{12},\\, \\text{flag}^{(3)}_{23} \\right],\n$$\nwhere superscripts indicate the test case number and subscripts indicate the time step pair used. Each $p$ must be a floating-point number, and each flag must be a boolean.", "solution": "The problem is subjected to validation against the specified criteria.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The one-dimensional linear advection-diffusion equation on a periodic domain $x \\in [0, 2\\pi]$ is given by\n$$ \\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) $$\nwhere $a$ and $\\nu$ are constant coefficients and $s(x,t)$ is a source term.\n- **Manufactured Solution**: The prescribed exact solution is\n$$ u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) $$\nwhere $\\alpha$, $\\beta$ are real constants and $k$ is a positive integer.\n- **Task 1**: Derive the source term $s(x,t)$ by substituting the manufactured solution into the governing equation.\n- **Task 2**: Define the one-step discrete-time residual of a Runge–Kutta (RK) integrator. The RK update is:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right) $$\nwhere $F(x,t) = \\partial u/\\partial t(x,t)$ along the exact solution trajectory. The residual norm is defined as:\n$$ \\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])} $$\nThe $L^2$ norm is to be approximated as the square root of the spatial average of the squared pointwise difference.\n- **Task 3**: Implement and evaluate the residual for three explicit RK methods starting at $t_n = 0$:\n    - Forward Euler: $m=1$, $b_1 = 1$, $c_1 = 0$.\n    - Explicit midpoint: $m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$ (interpreted as one-point quadrature).\n    - Classical Runge–Kutta (RK4): $m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$, $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$.\n- **Task 4**: Compute the empirical order of accuracy:\n$$ p_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)} $$\n- **Task 5**: Investigate superconvergence for the RK4 method when $\\alpha = 0$ and $\\beta \\Delta t = \\pi$.\n- **Implementation Details**: Use a periodic spatial grid of $N$ points on $[0, 2\\pi]$. Angles are in radians.\n- **Test Suite**: Three specific test cases are provided with all necessary parameters ($\\alpha, \\beta, k, a, \\nu, N$), time steps ($\\Delta t_1, \\Delta t_2, \\Delta t_3$), and target outputs (empirical orders or boolean flags).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically examined:\n- **Scientifically Grounded**: The problem is grounded in the fields of computational fluid dynamics and numerical analysis. The governing equation is a fundamental PDE, and the Method of Manufactured Solutions (MMS) is a standard technique for code verification. The Runge-Kutta methods and the concept of order of accuracy are pillars of numerical analysis for ODEs/PDEs. The investigation of superconvergence is a valid and specific topic within numerical analysis. All components are scientifically sound.\n- **Well-Posed**: The problem is well-posed. The tasks are clearly defined, and all necessary data, parameters, and formulas are provided. The definition of the explicit midpoint method, though compactly stated, is clarified by its interpretation as a one-point quadrature rule, which removes ambiguity. The problem structure leads to a unique and meaningful numerical result for each test case.\n- **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or opinion-based claims.\n- **Completeness and Consistency**: The problem is self-contained. All constants, equations, and conditions needed for the solution are provided. There are no internal contradictions. For instance, the crucial simplification $F(x,t) = \\partial u/\\partial t(x,t)$ is explicitly stated and justified within the context of MMS, ensuring a consistent framework for calculating the time integration error.\n- **No Other Flaws**: The problem is not trivial, unrealistic, or un-formalizable. It represents a standard, rigorous exercise in verifying the temporal accuracy of numerical schemes.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Solution Derivation\n\nThe solution requires implementing the logic described in the problem statement. The core of the task is to compute the temporal error of Runge-Kutta methods when applied to a known solution trajectory.\n\n**Task 1: Derivation of the Source Term**\n\nThe source term $s(x,t)$ is derived by enforcing that $u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x)$ is a solution to the governing advection-diffusion equation. This requires rearranging the equation to solve for $s(x,t)$:\n$$ s(x,t) = \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} - \\nu \\frac{\\partial^2 u}{\\partial x^2} $$\nWe compute the necessary partial derivatives of $u(x,t)$.\n\nFirst, the time derivative $\\partial u / \\partial t$, using the product rule on the temporal part $T(t) = \\exp(\\alpha t)\\sin(\\beta t)$:\n$$ \\frac{d T}{d t} = \\frac{d}{dt} \\left( \\exp(\\alpha t)\\sin(\\beta t) \\right) = \\alpha \\exp(\\alpha t)\\sin(\\beta t) + \\beta \\exp(\\alpha t)\\cos(\\beta t) = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) $$\nTherefore,\n$$ \\frac{\\partial u}{\\partial t} = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) $$\nNext, the spatial derivatives:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) \\right) = \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( k \\cos(k x) \\right) $$\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( k \\exp(\\alpha t)\\,\\sin(\\beta t) \\cos(k x) \\right) = k \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( -k \\sin(k x) \\right) = -k^2 u(x,t) $$\nSubstituting these expressions back into the equation for $s(x,t)$:\n$$ s(x,t) = \\left[ \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) \\right] + a \\left[ k \\exp(\\alpha t)\\sin(\\beta t) \\cos(k x) \\right] - \\nu \\left[ -k^2 \\exp(\\alpha t)\\sin(\\beta t)\\sin(k x) \\right] $$\nFactoring out common terms, we obtain the final expression for the source term:\n$$ s(x,t) = \\exp(\\alpha t) \\left[ \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) + a k \\sin(\\beta t) \\cos(k x) + \\nu k^2 \\sin(\\beta t) \\sin(k x) \\right] $$\nThis source term, by construction, ensures that the given $u(x,t)$ is an exact solution to the PDE. Note that for the remainder of the problem, this expression for $s(x,t)$ is not directly used. Instead, we use the property that the full right-hand side, when evaluated on the exact solution, simplifies to its time derivative.\n\n**Task 2 & 3: Residual Calculation for Runge-Kutta Methods**\n\nThe core of the problem is to compute the one-step residual, which measures the local truncation error of the time integrator. The general form of the update along the exact solution is:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F(x,t_n + c_i \\Delta t) $$\nAs established by the problem statement for MMS verification of a time-integrator, the right-hand side function $F(x,t)$ is evaluated on the exact solution path, which simplifies to the exact time derivative:\n$$ F(x, t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) = \\frac{\\partial u}{\\partial t}(x,t) $$\nThus, the RK update is computed as an integration of the known function $\\partial u / \\partial t$ over the time step $[t_n, t_{n+1}]$:\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i \\frac{\\partial u}{\\partial t}(x,t_n + c_i \\Delta t) $$\nThe residual norm is the discrete $L^2$ norm of the difference between this numerical approximation and the exact solution at the end of the step, $u(x, t_{n+1})$:\n$$ \\mathcal{R}(\\Delta t) = \\sqrt{ \\frac{1}{N} \\sum_{j=1}^{N} \\left( u^{\\text{RK}}(x_j) - u(x_j, t_n + \\Delta t) \\right)^2 } $$\nwhere the spatial grid is $x_j = (j-1) \\frac{2\\pi}{N}$ for $j=1, \\dots, N$. The calculation starts at $t_n = 0$.\n\nThe specific updates for the required methods with $t_n=0$ are:\n- **Forward Euler**: $m=1, b_1=1, c_1=0$.\n$$ u^{\\text{FE}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x,0) $$\n- **Explicit Midpoint**: $m=1, b_1=1, c_1=1/2$.\n$$ u^{\\text{Midpoint}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x, \\Delta t/2) $$\nThis corresponds to using the one-point midpoint quadrature rule to approximate $\\int_{0}^{\\Delta t} (\\partial u / \\partial t) dt$.\n- **Classical RK4**: $m=4, b=(\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{3}, \\frac{1}{6}), c=(0, \\frac{1}{2}, \\frac{1}{2}, 1)$.\n$$ u^{\\text{RK4}}(x) = u(x,0) + \\Delta t \\left[ \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,0) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,\\Delta t) \\right] $$\nThis corresponds to using Simpson's rule for the integral.\n\n**Task 4 & 5: Empirical Order and Superconvergence**\n\nThe empirical order of accuracy $p_{\\text{est}}$ is computed using the residuals from two different time steps, $\\Delta t_1$ and $\\Delta t_2$:\n$$ p_{\\text{est}} = \\frac{\\log(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2))}{\\log(\\Delta t_1 / \\Delta t_2)} $$\nFor the final test case, a special condition is investigated. With $\\alpha=0$, the solution becomes purely oscillatory in time: $u(x,t) = \\sin(\\beta t)\\sin(k x)$. If we choose $\\Delta t$ such that $\\beta \\Delta t = \\pi$, an interesting cancellation occurs. For $t_n=0$ and $\\Delta t_{special} = \\pi/\\beta$:\n- The exact solution at $t_n=0$ is $u(x,0) = \\sin(0)\\sin(kx) = 0$.\n- The exact solution at $t_n+\\Delta t_{special}$ is $u(x,\\pi/\\beta) = \\sin(\\beta \\cdot \\pi/\\beta)\\sin(kx) = \\sin(\\pi)\\sin(kx) = 0$.\nThe time derivative is $\\partial u/\\partial t = \\beta\\cos(\\beta t)\\sin(kx)$. The RK4 update involves samples at $t=0, \\Delta t/2, \\Delta t$.\n- At $t=0$, $\\partial u/\\partial t = \\beta\\cos(0)\\sin(kx)=\\beta\\sin(kx)$.\n- At $t=\\Delta t_{special}/2=\\pi/(2\\beta)$, $\\partial u/\\partial t = \\beta\\cos(\\pi/2)\\sin(kx)=0$.\n- At $t=\\Delta t_{special}=\\pi/\\beta$, $\\partial u/\\partial t = \\beta\\cos(\\pi)\\sin(kx)=-\\beta\\sin(kx)$.\nThe RK4 increment becomes proportional to $\\frac{1}{6}(\\beta\\sin(kx)) + \\frac{2}{3}(0) + \\frac{1}{6}(-\\beta\\sin(kx)) = 0$.\nThus, for this specific time step, both the exact solution and the RK4 approximation are zero at the end of the step, starting from zero. The residual $\\mathcal{R}(\\Delta t_{special})$ is exactly zero (up to machine precision). This leads to an \"infinite\" calculated order for the step pair including $\\Delta t_{special}$, indicating superconvergence. The implementation must handle the case of a zero residual to avoid numerical errors like $\\log(0)$.\n\nThe following program implements these calculations for the three specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Dictionary defining the Butcher tableau coefficients for the RK methods.\n    # The structure is method_name: {'b': weights, 'c': abscissae}.\n    RK_METHODS = {\n        \"fe\": {\"b\": np.array([1.0]), \"c\": np.array([0.0])},\n        \"midpoint\": {\"b\": np.array([1.0]), \"c\": np.array([0.5])},\n        \"rk4\": {\n            \"b\": np.array([1/6, 1/3, 1/3, 1/6]),\n            \"c\": np.array([0.0, 0.5, 0.5, 1.0]),\n        },\n    }\n\n    # Test suite parameters. Each tuple contains:\n    # (a, nu, alpha, beta, k, N, method_key, [dt1, dt2, dt3], task_type)\n    test_cases = [\n        (1.0, 0.05, 0.1, 2.0, 2, 256, \"rk4\", [0.2, 0.1, 0.05], \"order\"),\n        (0.0, 0.0, 0.2, 1.5, 3, 256, \"midpoint\", [0.3, 0.15, 0.075], \"order\"),\n        (0.5, 0.01, 0.0, 4 * np.pi, 4, 256, \"rk4\", [0.5, 0.25, 0.125], \"super\"),\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        a_p, nu_p, alpha, beta, k, N, method_key, dts, task_type = params\n        \n        # Spatial grid (uniform on periodic domain [0, 2*pi])\n        x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n        # Define the manufactured solution u(x,t) and its time derivative du/dt\n        # Note: These are vectorized to operate on the grid 'x'.\n        u_func = lambda t_val: np.exp(alpha * t_val) * np.sin(beta * t_val) * np.sin(k * x)\n        dudt_func = lambda t_val: np.exp(alpha * t_val) * (\n            alpha * np.sin(beta * t_val) + beta * np.cos(beta * t_val)\n        ) * np.sin(k * x)\n\n        residuals = []\n        for dt in dts:\n            # Get RK method coefficients\n            b = RK_METHODS[method_key][\"b\"]\n            c = RK_METHODS[method_key][\"c\"]\n\n            # Exact solution at t_n=0 and t_{n+1}=dt\n            u_exact_tn = u_func(0)\n            u_exact_tn1 = u_func(dt)\n            \n            # Calculate the Runge-Kutta update\n            # u^RK = u(t_n) + dt * sum(b_i * F(t_n + c_i*dt))\n            # where F = du/dt on the exact trajectory\n            rk_sum_term = np.zeros_like(x)\n            for i in range(len(b)):\n                t_stage = 0 + c[i] * dt  # t_n = 0\n                rk_sum_term += b[i] * dudt_func(t_stage)\n            \n            u_rk = u_exact_tn + dt * rk_sum_term\n            \n            # Calculate the L2 norm of the residual\n            # R = ||u^RK - u(t_{n+1})||_L2\n            error_sq = (u_rk - u_exact_tn1)**2\n            l2_norm = np.sqrt(np.mean(error_sq))\n            residuals.append(l2_norm)\n\n        # Unpack time steps and residuals\n        dt1, dt2, dt3 = dts\n        res1, res2, res3 = residuals\n\n        # Calculate empirical order p_est = log(R1/R2) / log(dt1/dt2)\n        # Handle cases where residual is zero (perfect cancellation)\n        if res2 == 0:\n            p_12 = np.inf\n        else:\n            p_12 = np.log(res1 / res2) / np.log(dt1 / dt2)\n\n        if res3 == 0:\n            p_23 = np.inf  # This case is not expected here\n        elif res2 == 0:\n            p_23 = -np.inf\n        else:\n            p_23 = np.log(res2 / res3) / np.log(dt2 / dt3)\n\n        if task_type == \"order\":\n            final_results.extend([p_12, p_23])\n        elif task_type == \"super\":\n            # Nominal order for RK4 is 4. Superconvergence threshold is 4.5\n            nominal_order = 4.0\n            super_threshold = 0.5\n            is_super_12 = p_12 > (nominal_order + super_threshold)\n            is_super_23 = p_23 > (nominal_order + super_threshold)\n            final_results.extend([is_super_12, is_super_23])\n            \n    # Format and print the final output string exactly as required\n    # Booleans are converted to lowercase strings 'true'/'false'\n    formatted_results = []\n    for item in final_results:\n        if isinstance(item, bool) or isinstance(item, np.bool_):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3376840"}, {"introduction": "Beyond simple model equations, real-world fluid dynamics simulations often involve multiple physical phenomena that are tightly coupled, such as momentum and heat transfer with temperature-dependent material properties. This practice demonstrates the power of MMS to verify complex, multi-physics implementations [@problem_id:3376812]. You will construct source terms for a coupled system where fluid viscosity and thermal conductivity vary with the temperature field, providing a rigorous test for the correct implementation of these nonlinear dependencies and complex differential operators.", "problem": "Design a self-contained verification using the Method of Manufactured Solutions (MMS) for a steady, dimensionless, incompressible, two-dimensional flow with temperature-dependent dynamic viscosity and thermal conductivity. The manufactured fields are smooth and periodic in space over the square domain $\\Omega = [0,1]\\times[0,1]$. Angles in trigonometric functions must be interpreted in radians.\n\nThe governing equations are the steady incompressible momentum and energy equations in their standard divergence forms for a Newtonian fluid with temperature-dependent properties, namely:\n- Continuity: $\\nabla \\cdot \\boldsymbol{u} = 0$.\n- Momentum: $\\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) + \\boldsymbol{f}$.\n- Energy (with viscous dissipation): $\\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T = \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) + \\Phi + Q$.\n\nHere $\\boldsymbol{u}=(u_x,u_y)$ is the velocity, $p$ is the pressure, $T$ is the temperature, $\\rho$ is the density, $c_p$ is the specific heat at constant pressure, $\\mu(T)$ is the dynamic viscosity, $k(T)$ is the thermal conductivity, $\\boldsymbol{S}(\\boldsymbol{u}) = \\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)$ is the rate-of-strain tensor, and $\\Phi = 2\\,\\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$ is the viscous dissipation. All quantities are non-dimensionalized.\n\nManufacture the following smooth fields:\n- Streamfunction $\\psi(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$, which defines a divergence-free velocity via $\\boldsymbol{u}(x,y) = \\left(\\tfrac{\\partial \\psi}{\\partial y},\\,-\\tfrac{\\partial \\psi}{\\partial x}\\right)$.\n- Pressure $p(x,y) = \\sin(\\pi x)\\,\\sin(2\\pi y)$.\n- Temperature $T(x,y) = \\tfrac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\tfrac{1}{4}\\,x\\,y$.\n\nDefine temperature-dependent material properties that are strictly positive and strongly varying:\n- $\\mu(T) = \\mu_0 \\exp\\left(\\beta\\,T\\right)$.\n- $k(T) = k_0 \\exp\\left(\\alpha\\,T\\right)$.\n\nYour task:\n1) Starting from the fundamental laws above, construct source terms $\\boldsymbol{f}(x,y)$ in the momentum equation and $Q(x,y)$ in the energy equation so that the manufactured fields $\\boldsymbol{u},p,T$ satisfy the equations exactly for any parameter set $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$.\n2) Implement a program that, for each parameter set in the test suite below, evaluates the residuals of the momentum and energy equations when using your constructed $\\boldsymbol{f}$ and $Q$ at a common set of points in the domain and reports the maximum absolute residual as a single floating-point number for the case.\n\nResidual definitions to be evaluated at a point $(x,y)$:\n- Momentum residual vector: $\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right) - \\boldsymbol{f}$.\n- Energy residual scalar: $R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi - Q$.\n\nFor each case, compute:\n- The maximum over the specified points of the componentwise absolute values of $\\boldsymbol{R}_m$ and the absolute value of $R_e$.\n- Report, for that case, the single scalar equal to the maximum of these values.\n\nTest points (shared by all cases; angles in radians):\n- $(x,y) \\in \\{(0.25,0.40),\\,(0.73,0.90),\\,(0.01,0.99),\\,(0.50,0.50)\\}$.\n\nTest suite (each case specifies $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$):\n- Case A (moderate variability): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.0,\\,1.0,\\,0.3,\\,1.5,\\,0.7,\\,1.2)$.\n- Case B (strong variability with opposing trends): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (2.0,\\,0.5,\\,0.05,\\,3.0,\\,1.1,\\,-2.5)$.\n- Case C (constant properties): $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha) = (1.3,\\,2.2,\\,0.2,\\,0.0,\\,0.9,\\,0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,r_C]$), where each $r_\\cdot$ is a floating-point number giving the maximum absolute residual for the corresponding case. The residuals are dimensionless numbers.\n\nAll computations must be performed in double precision. No user input is allowed, and no external files may be read or written. The implementation language and libraries are constrained as specified separately.", "solution": "We begin from the steady, incompressible, two-dimensional equations. The continuity equation $\\nabla\\cdot\\boldsymbol{u} = 0$ is identically satisfied by constructing the velocity from a streamfunction. We select the streamfunction $\\psi(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ and define\n$$\n\\boldsymbol{u}(x,y)=\\left(\\frac{\\partial \\psi}{\\partial y},\\, -\\frac{\\partial \\psi}{\\partial x}\\right)\n= \\left(\\pi \\cos(\\pi y)\\sin(\\pi x),\\, -\\pi \\cos(\\pi x)\\sin(\\pi y)\\right).\n$$\nThis ensures $\\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} = 0$ by construction.\n\nWe specify the pressure $p(x,y)=\\sin(\\pi x)\\sin(2\\pi y)$ so that the pressure gradient is nontrivial:\n$$\n\\nabla p = \\left(\\pi \\cos(\\pi x)\\sin(2\\pi y),\\, 2\\pi \\sin(\\pi x)\\cos(2\\pi y)\\right).\n$$\nWe manufacture the temperature\n$$\nT(x,y) = \\frac{1}{2}\\,\\sin(2\\pi x)\\,\\cos(\\pi y) + \\frac{1}{4}\\,x\\,y,\n$$\nso that it is smooth and yields nontrivial gradients and curvatures. The material properties are strictly positive and strongly varying with temperature:\n$$\n\\mu(T) = \\mu_0 \\exp(\\beta T), \\qquad k(T) = k_0 \\exp(\\alpha T),\n$$\nwith $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ given per case.\n\nTo enforce that the manufactured fields satisfy the momentum equation identically, we rearrange the steady momentum equation for the body force $\\boldsymbol{f}$:\n$$\n\\boldsymbol{f} = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot\\left(2\\,\\mu(T)\\,\\boldsymbol{S}(\\boldsymbol{u})\\right).\n$$\nSimilarly, to enforce that the manufactured fields satisfy the energy equation identically, we rearrange for $Q$:\n$$\nQ = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot\\left(k(T)\\,\\nabla T\\right) - \\Phi,\n$$\nwhere the viscous dissipation for a Newtonian incompressible fluid is $\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S}$.\n\nWe now compute all necessary derivatives analytically. First, the velocity gradient:\n$$\n\\nabla\\boldsymbol{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi y)\\cos(\\pi x) & -\\pi^2 \\sin(\\pi y)\\sin(\\pi x) \\\\\n\\pi^2 \\sin(\\pi x)\\sin(\\pi y) & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\nHence the symmetric rate-of-strain tensor is\n$$\n\\boldsymbol{S} = \\frac{1}{2}\\left(\\nabla\\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\top\\right)\n=\n\\begin{bmatrix}\n\\pi^2 \\cos(\\pi x)\\cos(\\pi y) & 0 \\\\\n0 & -\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\n\\end{bmatrix}.\n$$\nThe off-diagonal components cancel because $\\tfrac{1}{2}\\left(\\tfrac{\\partial u_x}{\\partial y}+\\tfrac{\\partial u_y}{\\partial x}\\right) = \\tfrac{1}{2}\\left(-\\pi^2 \\sin(\\pi y)\\sin(\\pi x)+\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\right)=0$.\nTherefore\n$$\n\\boldsymbol{S}:\\boldsymbol{S} = \\left(\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 + \\left(-\\pi^2 \\cos(\\pi x)\\cos(\\pi y)\\right)^2 = 2\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y),\n$$\nand the viscous dissipation becomes\n$$\n\\Phi = 2 \\mu(T)\\,\\boldsymbol{S}:\\boldsymbol{S} = 4\\,\\mu(T)\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\nFor the convection of velocity we compute $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$ componentwise:\n$$\n(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} =\n\\begin{bmatrix}\nu_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y} \\\\\nu_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}.\n$$\n\nThe viscous term requires the divergence of $2\\mu(T)\\boldsymbol{S}$. With $\\boldsymbol{S}$ diagonal, only $S_{11}$ and $S_{22}$ contribute. Define $g(x,y) = 2\\pi^2 \\cos(\\pi x)\\cos(\\pi y)$. Then\n$$\n2\\,\\mu(T)\\,S_{11} = \\mu(T)\\,g(x,y), \\qquad 2\\,\\mu(T)\\,S_{22} = -\\mu(T)\\,g(x,y),\n$$\nand hence\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_x = \\frac{\\partial}{\\partial x}\\left(\\mu\\,g\\right) + \\frac{\\partial}{\\partial y}\\left(0\\right) = \\mu_x g + \\mu\\,g_x,\n$$\n$$\n\\left[\\nabla\\cdot(2\\,\\mu \\boldsymbol{S})\\right]_y = \\frac{\\partial}{\\partial x}\\left(0\\right) + \\frac{\\partial}{\\partial y}\\left(-\\mu\\,g\\right) = -\\mu_y g - \\mu\\,g_y.\n$$\nUsing the chain rule for $\\mu(T)=\\mu_0 e^{\\beta T}$, we have $\\mu_x = \\mu\\,\\beta\\,T_x$ and $\\mu_y = \\mu\\,\\beta\\,T_y$. The derivatives of $g$ are\n$$\ng_x = -2\\pi^3 \\sin(\\pi x)\\cos(\\pi y), \\qquad g_y = -2\\pi^3 \\cos(\\pi x)\\sin(\\pi y).\n$$\n\nFor the temperature, its derivatives are\n$$\nT_x = \\pi \\cos(2\\pi x)\\cos(\\pi y) + \\frac{1}{4} y, \\qquad\nT_y = -\\frac{1}{2}\\pi \\sin(2\\pi x)\\sin(\\pi y) + \\frac{1}{4} x,\n$$\n$$\nT_{xx} = - (2\\pi)^2 \\frac{1}{2}\\,\\sin(2\\pi x)\\cos(\\pi y) = -2\\pi^2 \\sin(2\\pi x)\\cos(\\pi y),\n$$\n$$\nT_{yy} = - \\frac{1}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\nThus\n$$\nT_{xx} + T_{yy} = -\\frac{5}{2}\\pi^2 \\sin(2\\pi x)\\cos(\\pi y).\n$$\nThe temperature convection is $\\boldsymbol{u}\\cdot\\nabla T = u_x T_x + u_y T_y$.\n\nFor the variable conductivity diffusion, we use\n$$\n\\nabla\\cdot(k(T)\\nabla T) = \\frac{\\partial}{\\partial x}\\left(k T_x\\right) + \\frac{\\partial}{\\partial y}\\left(k T_y\\right)\n= k \\left(T_{xx} + T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right),\n$$\nsince $k_x = k\\,\\alpha\\,T_x$ and $k_y = k\\,\\alpha\\,T_y$ for $k(T)=k_0 e^{\\alpha T}$.\n\nTherefore, the manufactured source terms that make the chosen $(\\boldsymbol{u},p,T)$ an exact solution are:\n$$\n\\boldsymbol{f}(x,y) = \\rho (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\begin{bmatrix}\\mu_x g + \\mu g_x \\\\ -\\mu_y g - \\mu g_y\\end{bmatrix},\n$$\n$$\nQ(x,y) = \\rho c_p \\,\\boldsymbol{u}\\cdot\\nabla T - k\\left(T_{xx}+T_{yy} + \\alpha\\left(T_x^2 + T_y^2\\right)\\right) - 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y).\n$$\n\nAlgorithmic design for the program:\n- For each parameter set $(\\rho,c_p,\\mu_0,\\beta,k_0,\\alpha)$ and each test point $(x,y)$, evaluate:\n  - $\\boldsymbol{u}$ and its gradient, then $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$.\n  - $p$ gradient $\\nabla p$.\n  - $T$, $T_x$, $T_y$, $T_{xx}$, $T_{yy}$.\n  - $\\mu(T)$, $k(T)$ and their implicit derivatives via $\\mu_x = \\mu \\beta T_x$, $\\mu_y = \\mu \\beta T_y$; compute $g$, $g_x$, $g_y$; assemble $\\nabla\\cdot(2\\mu \\boldsymbol{S})$ using the simplified form above.\n  - $\\Phi = 4\\,\\mu\\,\\pi^4 \\cos^2(\\pi x)\\cos^2(\\pi y)$.\n- Construct $\\boldsymbol{f}$ and $Q$ from the formulas above.\n- Form residuals:\n  - Momentum residual $\\boldsymbol{R}_m = \\rho(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nabla\\cdot(2\\mu \\boldsymbol{S}) - \\boldsymbol{f}$.\n  - Energy residual $R_e = \\rho c_p\\,\\boldsymbol{u}\\cdot\\nabla T - \\nabla\\cdot(k \\nabla T) - \\Phi - Q$.\n- For each case, compute the maximum absolute residual across all components and points:\n  - $\\max\\left(\\max_{(x,y)} |R_{m,x}|,\\, \\max_{(x,y)} |R_{m,y}|,\\, \\max_{(x,y)} |R_e|\\right)$.\n- Output across the three cases as a single line $[r_A,r_B,r_C]$.\n\nBecause the source terms are constructed exactly from the governing equations and manufactured fields, the residuals should be at the level of floating-point roundoff, demonstrating consistency of the variable-coefficient differential operators with the MMS construction.", "answer": "```python\nimport numpy as np\n\ndef manufactured_fields(x, y):\n    pi = np.pi\n    # Streamfunction and derived velocity\n    ux = pi * np.cos(pi * y) * np.sin(pi * x)\n    uy = -pi * np.cos(pi * x) * np.sin(pi * y)\n    # Velocity gradients\n    dux_dx = pi**2 * np.cos(pi * y) * np.cos(pi * x)\n    dux_dy = -pi**2 * np.sin(pi * y) * np.sin(pi * x)\n    duy_dx = pi**2 * np.sin(pi * x) * np.sin(pi * y)\n    duy_dy = -pi**2 * np.cos(pi * x) * np.cos(pi * y)\n    # Symmetric strain S and invariants\n    S11 = dux_dx\n    S22 = duy_dy\n    S12 = 0.5 * (dux_dy + duy_dx)  # will be zero analytically\n    # For viscous dissipation, S:S\n    S_contract = S11**2 + 2.0 * S12**2 + S22**2\n\n    # Pressure and gradient\n    dp_dx = pi * np.cos(pi * x) * np.sin(2.0 * pi * y)\n    dp_dy = 2.0 * pi * np.sin(pi * x) * np.cos(2.0 * pi * y)\n\n    # Temperature and derivatives\n    T = 0.5 * np.sin(2.0 * pi * x) * np.cos(pi * y) + 0.25 * x * y\n    Tx = (2.0 * pi) * 0.5 * np.cos(2.0 * pi * x) * np.cos(pi * y) + 0.25 * y  # = pi * cos(2pi x) cos(pi y) + 0.25 y\n    Ty = 0.5 * np.sin(2.0 * pi * x) * (-pi) * np.sin(pi * y) + 0.25 * x       # = -0.5*pi*sin(2pi x) sin(pi y) + 0.25 x\n    Txx = -(2.0 * pi)**2 * 0.5 * np.sin(2.0 * pi * x) * np.cos(pi * y)        # = -2*pi^2 * sin(2pi x) cos(pi y)\n    Tyy = -0.5 * (pi**2) * np.sin(2.0 * pi * x) * np.cos(pi * y)\n\n    # Convection of velocity (u · ∇)u\n    conv_u_x = ux * dux_dx + uy * dux_dy\n    conv_u_y = ux * duy_dx + uy * duy_dy\n\n    # g for viscous divergence and its derivatives\n    g = 2.0 * (pi**2) * np.cos(pi * x) * np.cos(pi * y)\n    gx = -2.0 * (pi**3) * np.sin(pi * x) * np.cos(pi * y)\n    gy = -2.0 * (pi**3) * np.cos(pi * x) * np.sin(pi * y)\n\n    # For dissipation quick evaluation using S:S (consistency check)\n    # S:S analytically equals 2*pi^4 cos^2(pi x) cos^2(pi y); but we use computed S_contract for generality\n    return {\n        \"ux\": ux, \"uy\": uy,\n        \"dux_dx\": dux_dx, \"dux_dy\": dux_dy, \"duy_dx\": duy_dx, \"duy_dy\": duy_dy,\n        \"S11\": S11, \"S22\": S22, \"S12\": S12, \"S_contract\": S_contract,\n        \"dp_dx\": dp_dx, \"dp_dy\": dp_dy,\n        \"T\": T, \"Tx\": Tx, \"Ty\": Ty, \"Txx\": Txx, \"Tyy\": Tyy,\n        \"conv_u_x\": conv_u_x, \"conv_u_y\": conv_u_y,\n        \"g\": g, \"gx\": gx, \"gy\": gy\n    }\n\ndef properties_and_sources(x, y, rho, cp, mu0, beta, k0, alpha):\n    fld = manufactured_fields(x, y)\n    pi = np.pi\n\n    # Temperature-dependent properties\n    T = fld[\"T\"]\n    mu = mu0 * np.exp(beta * T)\n    k = k0 * np.exp(alpha * T)\n\n    # Implicit derivatives via chain rule\n    mu_x = mu * beta * fld[\"Tx\"]\n    mu_y = mu * beta * fld[\"Ty\"]\n\n    # Divergence of 2 mu S using simplified diagonal form\n    g = fld[\"g\"]; gx = fld[\"gx\"]; gy = fld[\"gy\"]\n    div2muS_x = mu_x * g + mu * gx\n    div2muS_y = - (mu_y * g + mu * gy)\n\n    # Momentum source term\n    conv_u_x = fld[\"conv_u_x\"]; conv_u_y = fld[\"conv_u_y\"]\n    dp_dx = fld[\"dp_dx\"]; dp_dy = fld[\"dp_dy\"]\n    fx = rho * conv_u_x + dp_dx - div2muS_x\n    fy = rho * conv_u_y + dp_dy - div2muS_y\n\n    # Energy terms\n    ux = fld[\"ux\"]; uy = fld[\"uy\"]\n    Tx = fld[\"Tx\"]; Ty = fld[\"Ty\"]; Txx = fld[\"Txx\"]; Tyy = fld[\"Tyy\"]\n    u_dot_gradT = ux * Tx + uy * Ty\n\n    # Variable-k diffusion operator\n    diff_T = k * (Txx + Tyy + alpha * (Tx**2 + Ty**2))\n\n    # Viscous dissipation Phi = 2 mu S:S\n    # Use analytical compact form for robustness (equal to computed S_contract form)\n    Phi = 4.0 * mu * (pi**4) * (np.cos(pi * x)**2) * (np.cos(pi * y)**2)\n\n    # Energy source term\n    Q = rho * cp * u_dot_gradT - diff_T - Phi\n\n    return fx, fy, Q, mu, k, div2muS_x, div2muS_y, diff_T, Phi, u_dot_gradT\n\ndef residuals_at_point(x, y, params):\n    rho, cp, mu0, beta, k0, alpha = params\n    # Compute sources using MMS formulas\n    fx, fy, Q, mu, k, div2muS_x, div2muS_y, diff_T, Phi, u_dot_gradT = properties_and_sources(\n        x, y, rho, cp, mu0, beta, k0, alpha\n    )\n    fld = manufactured_fields(x, y)\n\n    # Rebuild PDE terms to form residuals\n    # Momentum residual: rho (u·∇)u + ∇p - div(2 mu S) - f\n    Rm_x = rho * fld[\"conv_u_x\"] + fld[\"dp_dx\"] - div2muS_x - fx\n    Rm_y = rho * fld[\"conv_u_y\"] + fld[\"dp_dy\"] - div2muS_y - fy\n\n    # Energy residual: rho cp u·∇T - div(k grad T) - Phi - Q\n    # div(k grad T) equals diff_T\n    Re = rho * cp * (fld[\"ux\"] * fld[\"Tx\"] + fld[\"uy\"] * fld[\"Ty\"]) - diff_T - Phi - Q\n\n    return Rm_x, Rm_y, Re\n\ndef solve():\n    # Define test cases (rho, cp, mu0, beta, k0, alpha)\n    test_cases = [\n        (1.0, 1.0, 0.3, 1.5, 0.7, 1.2),     # Case A\n        (2.0, 0.5, 0.05, 3.0, 1.1, -2.5),   # Case B\n        (1.3, 2.2, 0.2, 0.0, 0.9, 0.0),     # Case C\n    ]\n    # Test points\n    points = [\n        (0.25, 0.40),\n        (0.73, 0.90),\n        (0.01, 0.99),\n        (0.50, 0.50),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_abs = 0.0\n        for (x, y) in points:\n            Rm_x, Rm_y, Re = residuals_at_point(x, y, params)\n            max_abs = max(max_abs, abs(Rm_x), abs(Rm_y), abs(Re))\n        results.append(max_abs)\n\n    # Final print statement in the exact required format: comma-separated values, no spaces\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3376812"}, {"introduction": "While order-of-accuracy tests are essential, MMS can also be used to diagnose more subtle properties of a numerical scheme, particularly those related to its interaction with the computational grid. This advanced practice explores the critical concept of free-stream preservation on non-Cartesian grids, a fundamental test of a scheme's geometric fidelity [@problem_id:3376848]. You will investigate how errors can arise from the discrete approximation of geometric metric terms and quantify this \"geometric conservation law\" error, ensuring that a uniform flow remains uniform on a warped grid.", "problem": "Consider the two-dimensional compressible Euler equations written in the conservative form in the physical coordinates $(x,y)$, with the conserved variable vector $Q = [\\rho,\\rho u,\\rho v,\\rho E]^\\top$ and Cartesian fluxes $F(Q)$ and $G(Q)$ in the $x$- and $y$-directions, respectively. The fundamental basis for this problem is the conservation of mass, momentum, and energy embodied by $\\partial_t Q + \\partial_x F + \\partial_y G = 0$ and the definition of a smooth mapping $\\mathbf{x}(\\xi,\\eta) = (x(\\xi,\\eta),y(\\xi,\\eta))$ from a uniform computational domain $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ to the physical domain. You will manufacture a uniform free-stream state $(\\rho,u,v,p)$ that is constant in space and time with zero source, and evaluate the discrete free-stream preservation on warped grids via the divergence of contravariant mass fluxes computed on the computational grid.\n\nStarting from the fundamental conservation laws in physical coordinates and the definition of a smooth change of variables via $\\mathbf{x}(\\xi,\\eta)$, derive the strong conservation-law form in computational coordinates and the associated contravariant mass fluxes. In continuous form, free-stream preservation for constant $(\\rho,u,v,p)$ critically depends on metric identities satisfied by derivatives of the mapping and the Jacobian determinant. In discrete form, violations of these identities by the chosen finite-difference approximations produce non-zero residuals even for uniform states.\n\nImplement the following in a single, self-contained program:\n- Use a uniform computational grid with $N_\\xi$ points in the $\\xi$-direction and $N_\\eta$ points in the $\\eta$-direction, with periodic boundary conditions. Let the grid spacings be $\\Delta \\xi = 1/N_\\xi$ and $\\Delta \\eta = 1/N_\\eta$.\n- Define a warped mapping $\\mathbf{x}(\\xi,\\eta)$ by\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta), \\qquad\ny(\\xi,\\eta) = \\eta + \\beta \\cos(2\\pi \\xi)\\sin(2\\pi \\eta),\n$$\nwhere $\\alpha$ and $\\beta$ are real-valued warp amplitudes. All quantities are dimensionless.\n- Compute the discrete metric derivatives $x_\\xi, x_\\eta, y_\\xi, y_\\eta$ and the discrete Jacobian $J = x_\\xi y_\\eta - x_\\eta y_\\xi$ using second-order centered differences on the computational grid with periodic boundary conditions. Use the same discrete operator for all partial derivatives.\n- Manufacture a uniform free-stream state with constants $(\\rho,u,v,p)$ that do not vary with $(\\xi,\\eta)$ and set the source to zero. Specifically use the constant values $\\rho = 1$, $u = 0.7$, $v = -0.2$, and $p = 1$.\n- For the mass conservation equation, form the discrete contravariant mass fluxes\n$$\n\\widehat{F}_\\rho = y_\\eta \\,\\rho u - x_\\eta \\,\\rho v, \\qquad\n\\widehat{G}_\\rho = -y_\\xi \\,\\rho u + x_\\xi \\,\\rho v,\n$$\nand then compute the discrete divergence\n$$\nR_\\rho = \\partial_\\xi\\!\\left(\\frac{\\widehat{F}_\\rho}{J}\\right) + \\partial_\\eta\\!\\left(\\frac{\\widehat{G}_\\rho}{J}\\right),\n$$\nusing the same second-order centered differences and periodic boundary conditions. This $R_\\rho$ is the manufactured residual for the free-stream mass equation; exact free-stream preservation corresponds to $R_\\rho \\equiv 0$.\n- Quantify the free-stream preservation error as the discrete $\\ell_2$ norm of $R_\\rho$ over the grid,\n$$\n\\|R_\\rho\\|_2 = \\sqrt{\\frac{1}{N_\\xi N_\\eta}\\sum_{i=0}^{N_\\xi-1}\\sum_{j=0}^{N_\\eta-1} \\left(R_{\\rho,ij}\\right)^2 }.\n$$\nReport this error as a floating-point number for each test case.\n\nUse the following test suite to explore the influence of mapping strength and resolution:\n- Test $1$: $N_\\xi = 32$, $N_\\eta = 32$, $\\alpha = 0$, $\\beta = 0$ (identity mapping on a uniform grid; a boundary case where exact discrete preservation is expected).\n- Test $2$: $N_\\xi = 32$, $N_\\eta = 32$, $\\alpha = 0.10$, $\\beta = 0.10$ (mildly warped grid).\n- Test $3$: $N_\\xi = 64$, $N_\\eta = 64$, $\\alpha = 0.30$, $\\beta = 0.25$ (strongly warped grid with higher resolution).\n- Test $4$: $N_\\xi = 16$, $N_\\eta = 16$, $\\alpha = 0.30$, $\\beta = 0.25$ (strongly warped grid with coarse resolution; an edge case for discretization errors).\n- Test $5$: $N_\\xi = 64$, $N_\\eta = 16$, $\\alpha = 0.30$, $\\beta = 0.05$ (anisotropic resolution with moderate warp).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where $r_k$ is the computed $\\ell_2$ error for Test $k$. All values are dimensionless and should be reported as standard floating-point numbers. No user input is required.", "solution": "The problem requires the quantification of free-stream preservation error for the two-dimensional compressible Euler equations on a warped grid. This is a standard verification procedure in computational fluid dynamics (CFD) to assess the quality of a numerical scheme on non-Cartesian grids. The core of the problem lies in the fact that while a uniform flow field should be an exact solution to the continuous governing equations, its discrete approximation often produces non-zero residuals due to the failure of discrete geometric operators to perfectly replicate the identities of continuous calculus.\n\nThe analysis begins with the integral form of a generic conservation law in a physical domain $\\Omega$ with boundary $\\partial\\Omega$:\n$$\n\\frac{d}{dt} \\int_{\\Omega} Q \\, dV + \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega} S \\, dV\n$$\nwhere $Q$ is the vector of conserved variables, $\\mathbf{F}$ is the flux tensor, $\\mathbf{n}$ is the outward-pointing normal vector, and $S$ is a source term. For the two-dimensional Euler equations, $Q = [\\rho, \\rho u, \\rho v, \\rho E]^\\top$, and the problem states the source is zero, $S=0$.\n\nA coordinate transformation is introduced from the physical coordinates $(x,y)$ to computational coordinates $(\\xi,\\eta)$, defined by the mapping $\\mathbf{x}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$. The differential form of the conservation law in physical coordinates is $\\partial_t Q + \\partial_x F + \\partial_y G = 0$. Applying the chain rule transforms this equation into the computational domain. The result is the strong conservation-law form:\n$$\n\\partial_t (J Q) + \\partial_\\xi \\widehat{F} + \\partial_\\eta \\widehat{G} = 0\n$$\nHere, $J = x_\\xi y_\\eta - x_\\eta y_\\xi$ is the Jacobian determinant of the transformation, representing the ratio of differential areas $dx\\,dy = J\\,d\\xi\\,d\\eta$. The quantities $\\widehat{F}$ and $\\widehat{G}$ are the contravariant flux vectors, defined as:\n$$\n\\widehat{F} = J(\\xi_x F + \\xi_y G)\n\\qquad\n\\widehat{G} = J(\\eta_x F + \\eta_y G)\n$$\nThe terms $\\xi_x, \\xi_y, \\eta_x, \\eta_y$ are the metric terms of the transformation. They can be expressed in terms of the derivatives of the mapping $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ using the following metric identities:\n$$\n\\xi_x = \\frac{y_\\eta}{J}, \\quad \\xi_y = -\\frac{x_\\eta}{J}, \\quad \\eta_x = -\\frac{y_\\xi}{J}, \\quad \\eta_y = \\frac{x_\\xi}{J}\n$$\nThe problem focuses on the mass conservation equation, which is the first component of the system. For mass conservation, the conserved variable is density $\\rho$ and the Cartesian fluxes are $F_\\rho = \\rho u$ and $G_\\rho = \\rho v$. Substituting the metric identities into the definitions of the contravariant fluxes for the mass equation yields:\n$$\n\\widehat{F}_\\rho = J(\\xi_x (\\rho u) + \\xi_y (\\rho v)) = J\\left(\\frac{y_\\eta}{J} \\rho u - \\frac{x_\\eta}{J} \\rho v\\right) = y_\\eta \\rho u - x_\\eta \\rho v\n$$\n$$\n\\widehat{G}_\\rho = J(\\eta_x (\\rho u) + \\eta_y (\\rho v)) = J\\left(-\\frac{y_\\xi}{J} \\rho u + \\frac{x_\\xi}{J} \\rho v\\right) = -y_\\xi \\rho u + x_xi \\rho v\n$$\nThese expressions match the definitions provided in the problem statement.\n\nFor a steady ($\\partial_t = 0$), uniform free-stream flow, the state variables $(\\rho, u, v, p)$ are constant throughout the domain. The transformed mass conservation equation for a steady state is $\\partial_\\xi \\widehat{F}_\\rho + \\partial_\\eta \\widehat{G}_\\rho = 0$. Substituting the expressions for the fluxes and noting that $\\rho, u, v$ are constants, we obtain:\n$$\n\\partial_\\xi(y_\\eta \\rho u - x_\\eta \\rho v) + \\partial_\\eta(-y_\\xi \\rho u + x_\\xi \\rho v) = 0\n$$\n$$\n\\rho u (\\partial_\\xi y_\\eta - \\partial_\\eta y_\\xi) + \\rho v (-\\partial_\\xi x_\\eta + \\partial_\\eta x_\\xi) = 0\n$$\nIn continuous calculus, for a smooth mapping, the order of differentiation is interchangeable (Clairaut's theorem), which implies $\\partial_\\xi y_\\eta = \\partial_{\\xi\\eta} y = \\partial_{\\eta\\xi} y = \\partial_\\eta y_\\xi$. Therefore, the terms in the parentheses, known as the Geometric Conservation Law (GCL) identities, are identically zero:\n$$\n\\partial_\\xi y_\\eta - \\partial_\\eta y_\\xi = 0 \\quad \\text{and} \\quad \\partial_\\eta x_\\xi - \\partial_\\xi x_\\eta = 0\n$$\nThis confirms that a uniform free-stream flow is an exact solution of the continuous transformed equations.\n\nHowever, when discretized, these identities may not hold. The problem specifies using a second-order centered difference operator, denoted here by $\\delta_\\xi$ and $\\delta_\\eta$, to approximate the partial derivatives. For a generic function $f_{ij}$ on the grid, these are:\n$$\n(\\delta_\\xi f)_{ij} = \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta\\xi}, \\qquad (\\delta_\\eta f)_{ij} = \\frac{f_{i,j+1} - f_{i,j-1}}{2 \\Delta\\eta}\n$$\nIn general, the discrete operators do not commute, i.e., $\\delta_\\xi(\\delta_\\eta f) \\neq \\delta_\\eta(\\delta_\\xi f)$. This failure to satisfy the GCL at the discrete level introduces a source-like error term, causing the numerical scheme to generate a non-zero residual for a uniform flow.\n\nThe problem defines the residual for the mass equation as:\n$$\nR_\\rho = \\partial_\\xi\\left(\\frac{\\widehat{F}_\\rho}{J}\\right) + \\partial_\\eta\\left(\\frac{\\widehat{G}_\\rho}{J}\\right)\n$$\nThis form arises from rearranging the transformed equation as $\\partial_t Q + \\frac{1}{J}(\\partial_\\xi \\widehat{F} + \\partial_\\eta \\widehat{G})=0$ before discretization. For a steady state, the residual $R_\\rho$ should be zero.\n\nThe algorithm to compute the free-stream preservation error is as follows:\n1.  Define the computational grid $(\\xi_{ij}, \\eta_{ij})$ with $N_\\xi \\times N_\\eta$ points and grid spacings $\\Delta\\xi = 1/N_\\xi$, $\\Delta\\eta = 1/N_\\eta$. The grid points are $\\xi_i = i\\Delta\\xi$ for $i \\in \\{0, \\dots, N_\\xi-1\\}$ and $\\eta_j = j\\Delta\\eta$ for $j \\in \\{0, \\dots, N_\\eta-1\\}$.\n2.  Compute the physical coordinates $(x_{ij}, y_{ij})$ at each grid point using the provided mapping functions:\n    $$\n    x(\\xi,\\eta) = \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta), \\qquad y(\\xi,\\eta) = \\eta + \\beta \\cos(2\\pi \\xi)\\sin(2\\pi \\eta)\n    $$\n3.  Calculate the discrete metric derivatives $(x_\\xi)_{ij}, (x_\\eta)_{ij}, (y_\\xi)_{ij}, (y_\\eta)_{ij}$ using the second-order centered difference operator with periodic boundary conditions.\n4.  Compute the discrete Jacobian at each grid point: $J_{ij} = (x_\\xi)_{ij} (y_\\eta)_{ij} - (x_\\eta)_{ij} (y_\\xi)_{ij}$.\n5.  Set the free-stream state constants: $\\rho = 1$, $u = 0.7$, $v = -0.2$.\n6.  Form the discrete contravariant mass fluxes at each point:\n    $$\n    (\\widehat{F}_\\rho)_{ij} = (y_\\eta)_{ij} \\,\\rho u - (x_\\eta)_{ij} \\,\\rho v, \\qquad (\\widehat{G}_\\rho)_{ij} = -(y_\\xi)_{ij} \\,\\rho u + (x_\\xi)_{ij} \\,\\rho v\n    $$\n7.  Compute the flux densities $\\Phi_{ij} = (\\widehat{F}_\\rho)_{ij} / J_{ij}$ and $\\Psi_{ij} = (\\widehat{G}_\\rho)_{ij} / J_{ij}$.\n8.  Compute the discrete residual field $R_{\\rho,ij}$ by applying the centered difference operators to the flux densities:\n    $$\n    R_{\\rho,ij} = (\\delta_\\xi \\Phi)_{ij} + (\\delta_\\eta \\Psi)_{ij}\n    $$\n9.  Quantify the total error by computing the discrete $\\ell_2$ norm of the residual field:\n    $$\n    \\|R_\\rho\\|_2 = \\sqrt{\\frac{1}{N_\\xi N_\\eta}\\sum_{i=0}^{N_\\xi-1}\\sum_{j=0}^{N_\\eta-1} \\left(R_{\\rho,ij}\\right)^2 }\n    $$\nFor the identity mapping ($\\alpha=0, \\beta=0$), the grid is Cartesian ($x=\\xi, y=\\eta$), the metric derivatives are constant ($x_\\xi=1, y_\\eta=1, x_\\eta=0, y_\\xi=0$), the Jacobian is $J=1$, and the contravariant fluxes $\\widehat{F}_\\rho, \\widehat{G}_\\rho$ are constant. The discrete derivative of a constant field is exactly zero, so the residual $R_\\rho$ and its norm must be zero (up to machine precision), providing a key validation check. For non-zero $\\alpha$ and $\\beta$, a non-zero error is expected.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(N_xi, N_eta, alpha, beta):\n    \"\"\"\n    Computes the l2-norm of the free-stream preservation residual for the mass equation.\n\n    Args:\n        N_xi (int): Number of grid points in the xi-direction.\n        N_eta (int): Number of grid points in the eta-direction.\n        alpha (float): Warp amplitude for the x-coordinate.\n        beta (float): Warp amplitude for the y-coordinate.\n\n    Returns:\n        float: The discrete l2-norm of the residual field.\n    \"\"\"\n    # Define free-stream state constants\n    rho = 1.0\n    u = 0.7\n    v = -0.2\n    # p = 1.0 (not needed for mass conservation)\n\n    # 1. Define the computational grid\n    delta_xi = 1.0 / N_xi\n    delta_eta = 1.0 / N_eta\n\n    xi_1d = np.linspace(0, 1.0, N_xi, endpoint=False)\n    eta_1d = np.linspace(0, 1.0, N_eta, endpoint=False)\n    xi, eta = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n    # 2. Compute physical coordinates from the mapping\n    x = xi + alpha * np.sin(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n    y = eta + beta * np.cos(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n\n    # Helper function for centered differences with periodic boundary conditions\n    def centered_diff(field, delta, axis):\n        \"\"\"Computes 2nd order centered differences on a periodic grid.\"\"\"\n        # axis=0 corresponds to eta-derivative (column-wise)\n        # axis=1 corresponds to xi-derivative (row-wise)\n        # Note: numpy meshgrid with 'ij' indexing makes xi the first index (axis=0)\n        # and eta the second index (axis=1).\n        \n        # Adjust axis for numpy array indexing\n        np_axis = axis \n        \n        f_plus_1 = np.roll(field, -1, axis=np_axis)\n        f_minus_1 = np.roll(field, 1, axis=np_axis)\n        return (f_plus_1 - f_minus_1) / (2.0 * delta)\n\n    # 3. Calculate discrete metric derivatives\n    x_xi = centered_diff(x, delta_xi, axis=0)\n    x_eta = centered_diff(x, delta_eta, axis=1)\n    y_xi = centered_diff(y, delta_xi, axis=0)\n    y_eta = centered_diff(y, delta_eta, axis=1)\n\n    # 4. Compute the discrete Jacobian\n    J = x_xi * y_eta - x_eta * y_xi\n\n    # Check for non-positive Jacobian, which indicates grid folding\n    if np.any(J <= 0):\n        # This should not happen for the given parameters but is good practice\n        # to check. For this specific problem, we proceed as specified.\n        pass\n\n    # 5. Form the discrete contravariant mass fluxes\n    F_hat_rho = y_eta * rho * u - x_eta * rho * v\n    G_hat_rho = -y_xi * rho * u + x_xi * rho * v\n    \n    # 6. Compute flux densities\n    Phi = F_hat_rho / J\n    Psi = G_hat_rho / J\n\n    # 7. Compute the discrete residual field\n    R_rho = centered_diff(Phi, delta_xi, axis=0) + centered_diff(Psi, delta_eta, axis=1)\n\n    # 8. Quantify the error using the l2-norm\n    # Note: np.mean(R_rho**2) is equivalent to (1/(N_xi*N_eta)) * sum(R_rho**2)\n    l2_error = np.sqrt(np.mean(R_rho**2))\n    \n    return l2_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N_xi, N_eta, alpha, beta)\n        (32, 32, 0.0, 0.0),      # Test 1\n        (32, 32, 0.10, 0.10),    # Test 2\n        (64, 64, 0.30, 0.25),    # Test 3\n        (16, 16, 0.30, 0.25),    # Test 4\n        (64, 16, 0.30, 0.05),    # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N_xi, N_eta, alpha, beta = case\n        error = compute_error(N_xi, N_eta, alpha, beta)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3376848"}]}