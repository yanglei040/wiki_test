{"hands_on_practices": [{"introduction": "Moving from the theoretical definition of central interpolation to its practical application requires a deep understanding of its limitations. For transport phenomena involving both convection and diffusion, the balance between these two mechanisms is critical. This exercise provides a foundational analysis of the stability of the Central Differencing Scheme (CDS) by deriving the famous cell Peclet number constraint, which dictates when this scheme can be used without producing unphysical oscillations. [@problem_id:3298459]", "problem": "Consider a one-dimensional, steady convectionâ€“diffusion transport of a passive scalar $\\phi(x)$ on a uniform grid of control volumes with spacing $\\Delta x$ and unit cross-sectional area. The governing differential statement of conservation is\n$$\\frac{d}{dx}\\left(\\Gamma \\frac{d \\phi}{dx}\\right) - \\rho u \\frac{d \\phi}{dx} = 0,$$\nwhere $\\rho$ is the fluid density, $u$ is the constant velocity, and $\\Gamma$ is the diffusion coefficient for $\\phi$. Using the Finite Volume Method (FVM), integrate over a generic interior control volume $P$ bounded by faces $w$ (west) and $e$ (east), and discretize the diffusive fluxes with central gradients. For the convective fluxes, employ central interpolation for face values (the Central Differencing Scheme, CDS), meaning the face values are the arithmetic mean of adjacent cell-center values on a uniform grid. Define the face mass flux magnitude by $F \\equiv \\rho u$ (with unit area) and the diffusive conductance by $D \\equiv \\Gamma/\\Delta x$.\n\nA discrete scheme is said to be bounded if the coefficients multiplying neighboring unknowns in the linearized algebraic equation are nonnegative and the central coefficient satisfies the necessary dominance condition that precludes overshoots and undershoots in the discrete solution. Derive the coefficient constraints implied by CDS and express the boundedness requirement in terms of the dimensionless cell Peclet number\n$$Pe \\equiv \\frac{\\rho u \\,\\Delta x}{\\Gamma} = \\frac{F}{D}.$$\n\nThen, for the specific parameter values\n$$\\rho = 1.2 \\ \\text{kg}\\,\\text{m}^{-3}, \\quad u = 2 \\ \\text{m}\\,\\text{s}^{-1}, \\quad \\Gamma = 1.8 \\times 10^{-5} \\ \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-1}, \\quad \\Delta x = 1.0 \\times 10^{-2} \\ \\text{m},$$\ncompute the numerical value of $Pe$ and decide whether central interpolation is bounded for these conditions. Report your final answer as a row matrix $\\begin{pmatrix} Pe & b \\end{pmatrix}$, where $b=1$ if central interpolation is bounded and $b=0$ otherwise. Express $Pe$ as a pure number with no units and $b$ as a dimensionless indicator. No rounding is necessary; provide exact values whenever possible.", "solution": "The task is to derive the boundedness criterion for the Central Differencing Scheme (CDS) applied to the one-dimensional steady convection-diffusion equation and then to evaluate this criterion for a specific set of physical parameters.\n\nThe governing differential equation is given as:\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0\n$$\nwhere $\\phi$ is the passive scalar, $\\Gamma$ is the diffusion coefficient, $\\rho$ is the density, and $u$ is the velocity.\n\nTo apply the Finite Volume Method (FVM), we integrate this equation over a generic control volume (CV) centered at a node $P$, bounded by a west face $w$ and an east face $e$. The volume of the CV is $\\Delta V = A \\Delta x$, where the cross-sectional area is given as unity ($A=1$) and the grid spacing is $\\Delta x$.\n$$\n\\int_{w}^{e} \\left[ \\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} \\right] A \\, dx = 0\n$$\nSince $A=1$, we can write:\n$$\n\\int_{w}^{e} \\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) dx - \\int_{w}^{e} \\rho u \\frac{d\\phi}{dx} dx = 0\n$$\nApplying the fundamental theorem of calculus to the first term (the divergence of the diffusive flux) and assuming constant $\\rho$ and $u$ for the second term, we obtain the balance over the CV:\n$$\n\\left(A \\Gamma \\frac{d\\phi}{dx}\\right)_e - \\left(A \\Gamma \\frac{d\\phi}{dx}\\right)_w - \\rho u A (\\phi_e - \\phi_w) = 0\n$$\nAgain, with $A=1$:\n$$\n\\left(\\Gamma \\frac{d\\phi}{dx}\\right)_e - \\left(\\Gamma \\frac{d\\phi}{dx}\\right)_w - \\rho u (\\phi_e - \\phi_w) = 0\n$$\nThis equation represents the balance of diffusive and convective fluxes across the CV faces. The standard FVM approach treats the total flux at the faces. An equivalent, and more standard, starting point is the conservation law in divergence form, $\\frac{d}{dx}(\\rho u \\phi - \\Gamma \\frac{d\\phi}{dx}) = 0$. Integration gives $(\\rho u \\phi)_e - (\\Gamma \\frac{d\\phi}{dx})_e - [(\\rho u \\phi)_w - (\\Gamma \\frac{d\\phi}{dx})_w] = 0$. The discretization scheme specified in the problem leads to the same algebraic form as we will derive, confirming the consistency of the problem statement.\n\nWe now discretize the terms for a uniform grid where nodes are denoted by $W$ (west), $P$ (central), and $E$ (east), separated by $\\Delta x$.\nThe diffusive fluxes at the faces are approximated using central differences for the gradients:\n$$\n\\left(\\Gamma \\frac{d\\phi}{dx}\\right)_e \\approx \\Gamma_e \\frac{\\phi_E - \\phi_P}{\\Delta x} \\quad \\text{and} \\quad \\left(\\Gamma \\frac{d\\phi}{dx}\\right)_w \\approx \\Gamma_w \\frac{\\phi_P - \\phi_W}{\\Delta x}\n$$\nAssuming a constant diffusion coefficient, $\\Gamma_e = \\Gamma_w = \\Gamma$.\nFor the convective term, the problem specifies the use of CDS, where the value of the scalar $\\phi$ at a face is the arithmetic mean of the adjacent cell-center values:\n$$\n\\phi_e \\approx \\frac{\\phi_P + \\phi_E}{2} \\quad \\text{and} \\quad \\phi_w \\approx \\frac{\\phi_W + \\phi_P}{2}\n$$\nSubstituting these discretizations into the integrated equation yields:\n$$\n\\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x} - \\Gamma \\frac{\\phi_P - \\phi_W}{\\Delta x} - \\rho u \\left( \\frac{\\phi_P + \\phi_E}{2} - \\frac{\\phi_W + \\phi_P}{2} \\right) = 0\n$$\nSimplifying the terms:\n$$\n\\frac{\\Gamma}{\\Delta x}(\\phi_E - 2\\phi_P + \\phi_W) - \\frac{\\rho u}{2}(\\phi_E - \\phi_W) = 0\n$$\nWe introduce the definitions for diffusive conductance, $D \\equiv \\Gamma/\\Delta x$, and face mass flux, $F \\equiv \\rho u$:\n$$\nD(\\phi_E - 2\\phi_P + \\phi_W) - \\frac{F}{2}(\\phi_E - \\phi_W) = 0\n$$\nTo analyze the properties of the scheme, we rearrange this into the standard linear algebraic form, $a_P \\phi_P = a_W \\phi_W + a_E \\phi_E$:\n$$\n(D\\phi_E - \\frac{F}{2}\\phi_E) + (D\\phi_W + \\frac{F}{2}\\phi_W) - 2D\\phi_P = 0\n$$\n$$\n(2D)\\phi_P = \\left(D + \\frac{F}{2}\\right)\\phi_W + \\left(D - \\frac{F}{2}\\right)\\phi_E\n$$\nFrom this, we identify the coefficients:\n$$\na_W = D + \\frac{F}{2}\n$$\n$$\na_E = D - \\frac{F}{2}\n$$\n$$\na_P = 2D\n$$\nA numerical scheme is bounded if it does not produce unphysical overshoots or undershoots. A sufficient condition for boundedness is that all coefficients of the neighboring nodes ($a_W, a_E$) are non-negative. This ensures that $\\phi_P$ is a weighted average of $\\phi_W$ and $\\phi_E$.\n$$\na_W \\ge 0 \\implies D + \\frac{F}{2} \\ge 0\n$$\n$$\na_E \\ge 0 \\implies D - \\frac{F}{2} \\ge 0\n$$\nSince $D = \\Gamma/\\Delta x$ is inherently positive, these two inequalities combine to give $|F/2| \\le D$, or $|F| \\le 2D$.\n\nThis condition can be expressed using the dimensionless cell Peclet number, defined as $Pe \\equiv \\frac{\\rho u \\Delta x}{\\Gamma}$. We can rewrite $Pe$ using our definitions of $F$ and $D$:\n$$\nPe = \\frac{(\\rho u) \\Delta x}{\\Gamma} = \\frac{F}{(\\Gamma/\\Delta x)} = \\frac{F}{D}\n$$\nThe boundedness criterion $|F| \\le 2D$ can then be rewritten by dividing by $D$:\n$$\n\\frac{|F|}{D} \\le 2 \\implies |Pe| \\le 2\n$$\nThis is the celebrated constraint for the CDS: the scheme is bounded and guaranteed to be physically realistic only when the magnitude of the cell Peclet number is less than or equal to $2$.\n\nNext, we calculate the value of $Pe$ using the provided data:\n$\\rho = 1.2 \\ \\text{kg}\\,\\text{m}^{-3}$, $u = 2 \\ \\text{m}\\,\\text{s}^{-1}$, $\\Gamma = 1.8 \\times 10^{-5} \\ \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-1}$, and $\\Delta x = 1.0 \\times 10^{-2} \\ \\text{m}$.\n$$\nPe = \\frac{\\rho u \\Delta x}{\\Gamma} = \\frac{(1.2)(2)(1.0 \\times 10^{-2})}{1.8 \\times 10^{-5}} = \\frac{2.4 \\times 10^{-2}}{1.8 \\times 10^{-5}}\n$$\n$$\nPe = \\frac{2.4}{1.8} \\times 10^{-2 - (-5)} = \\frac{4}{3} \\times 10^3 = \\frac{4000}{3}\n$$\nThe calculated Peclet number is $Pe = \\frac{4000}{3} \\approx 1333.33$.\n\nFinally, we check this value against the boundedness criterion $|Pe| \\le 2$.\n$$\n\\left|\\frac{4000}{3}\\right| = \\frac{4000}{3} \\approx 1333.33\n$$\nClearly, $\\frac{4000}{3} > 2$. The condition is not met. Therefore, for this set of parameters, the central interpolation scheme is not bounded. This implies that the numerical solution is prone to spurious oscillations and may be physically meaningless. We set the boundedness indicator $b=0$.\n\nThe final answer is the row matrix $\\begin{pmatrix} Pe & b \\end{pmatrix}$.\nSubstituting our results, we get $\\begin{pmatrix} \\frac{4000}{3} & 0 \\end{pmatrix}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{4000}{3} & 0\n\\end{pmatrix}\n}\n$$", "id": "3298459"}, {"introduction": "A cornerstone of reliable scientific computing is the ability to verify that a code implementation correctly matches its underlying mathematical theory. This practice introduces the Method of Manufactured Solutions (MMS), a powerful and rigorous technique for code verification. You will implement central interpolation and use a known analytical solution to numerically measure the scheme's error, confirming its theoretical second-order accuracy and developing a core skill in computational fluid dynamics. [@problem_id:3298479]", "problem": "Consider a one-dimensional, periodic domain $x \\in [0,1]$ with a smooth manufactured solution $\\phi(x) = \\sin(k x)$, where all angles are measured in radians. Let a family of uniform meshes be defined by the number of cells $N \\in \\{10, 20, 40, 80\\}$, and denote the mesh spacing by $\\Delta x = 1/N$. For each mesh, define cell-center positions $x_i = (i + 1/2)\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$ and face positions $x_{f}^{(j)} = j \\Delta x$ for $j \\in \\{0, 1, \\dots, N-1\\}$, with periodic indexing such that face $j$ lies between the left cell $(j-1) \\bmod N$ and the right cell $j$.\n\nUsing only principles based on smoothness and symmetry about each face, construct a second-order accurate approximation $\\phi_f$ to the face value $\\phi(x_f^{(j)})$ by central interpolation from neighboring cell-center values. For each mesh, compute the discrete $L_2$ norm of the face interpolation error\n$$\n\\|e\\|_{L_2} = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[\\phi_f^{(j)} - \\phi\\!\\left(x_f^{(j)}\\right)\\right]^2 \\right)^{1/2},\n$$\nand then estimate the observed order of accuracy $p$ by fitting a straight line to the data $\\left(\\ln \\Delta x, \\ln \\|e\\|_{L_2}\\right)$ across the mesh family via least squares, taking $p$ as the slope.\n\nUse the following test suite of wavenumbers $k$:\n- $k = 2\\pi$ (one wavelength across the domain) as a general case,\n- $k = 8\\pi$ (four wavelengths) to probe higher frequency content,\n- $k = 32\\pi$ (sixteen wavelengths) to challenge resolution.\n\nAll angles must be in radians. If all computed errors for a test case are numerically zero for the entire mesh family, define the observed order $p$ to be $+\\infty$ for that case.\n\nYour program should produce a single line of output containing the three observed orders, in the same order as the test suite, as a comma-separated list enclosed in square brackets (e.g., $[p_1,p_2,p_3]$). The outputs must be real numbers (floating-point values); if a case yields an infinite observed order as per the rule above, print it as $+\\infty$ represented by the standard floating-point infinity.", "solution": "The problem is well-posed, scientifically sound, and internally consistent. It presents a standard numerical analysis task from the field of computational fluid dynamics, specifically, the verification of a numerical scheme using the Method of Manufactured Solutions. All necessary data, definitions, and procedures are explicitly provided, allowing for a unique and verifiable solution.\n\nThe core of the problem is to construct a second-order accurate central interpolation scheme for a variable $\\phi$ from cell-centered values to face locations, and then to numerically verify its order of accuracy.\n\nFirst, we design the interpolation scheme based on the specified principles of smoothness and symmetry. Consider a uniform one-dimensional mesh with spacing $\\Delta x = 1/N$. The cell centers are located at $x_i = (i + 1/2)\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$, and the faces are at $x_{f}^{(j)} = j \\Delta x$ for $j \\in \\{0, 1, \\dots, N-1\\}$. According to the problem statement, face $j$ is located between cell $(j-1) \\pmod N$ and cell $j$. The positions of the centers of these two cells are $x_{j-1} = ((j-1) + 1/2)\\Delta x$ and $x_j = (j + 1/2)\\Delta x$. The face position $x_f^{(j)}$ is the midpoint of these two cell centers:\n$$\n\\frac{x_{j-1} + x_j}{2} = \\frac{((j - 1/2) + (j + 1/2))\\Delta x}{2} = \\frac{2j\\Delta x}{2} = j\\Delta x = x_f^{(j)}\n$$\nGiven that the underlying function $\\phi(x)$ is smooth and the interpolation stencil is symmetric about the target point $x_f^{(j)}$, the simplest and most natural central interpolation scheme is a linear interpolation between the two neighboring cell-centered values, $\\phi_{j-1} = \\phi(x_{j-1})$ and $\\phi_j = \\phi(x_j)$. Since $x_f^{(j)}$ is the midpoint, this corresponds to the arithmetic mean:\n$$\n\\phi_f^{(j)} = \\frac{\\phi_{j-1} + \\phi_j}{2}\n$$\nThe periodic indexing $(j-1) \\pmod N$ is used to find the \"left\" cell, $\\phi_{j-1}$, when $j=0$.\n\nNext, we must verify that this scheme is second-order accurate as requested. We perform a Taylor series expansion of $\\phi(x)$ around the face position $x_f^{(j)}$. The neighboring cell centers are at a distance of $\\pm \\Delta x/2$ from the face.\n$$\n\\phi_j = \\phi(x_j) = \\phi\\left(x_f^{(j)} + \\frac{\\Delta x}{2}\\right) = \\phi(x_f^{(j)}) + \\phi'(x_f^{(j)})\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^2 + \\frac{1}{6}\\phi'''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^3 + \\mathcal{O}(\\Delta x^4)\n$$\n$$\n\\phi_{j-1} = \\phi(x_{j-1}) = \\phi\\left(x_f^{(j)} - \\frac{\\Delta x}{2}\\right) = \\phi(x_f^{(j)}) - \\phi'(x_f^{(j)})\\frac{\\Delta x}{2} + \\frac{1}{2}\\phi''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^2 - \\frac{1}{6}\\phi'''(x_f^{(j)})\\left(\\frac{\\Delta x}{2}\\right)^3 + \\mathcal{O}(\\Delta x^4)\n$$\nSubstituting these expansions into the interpolation formula:\n$$\n\\phi_f^{(j)} = \\frac{1}{2}(\\phi_{j-1} + \\phi_j) = \\frac{1}{2}\\left[2\\phi(x_f^{(j)}) + \\phi''(x_f^{(j)})\\frac{\\Delta x^2}{4} + \\mathcal{O}(\\Delta x^4)\\right] = \\phi(x_f^{(j)}) + \\frac{1}{8}\\phi''(x_f^{(j)})\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\nThe interpolation error at face $j$, denoted by $e_j$, is the difference between the interpolated value and the exact value:\n$$\ne_j = \\phi_f^{(j)} - \\phi(x_f^{(j)}) = \\frac{1}{8}\\phi''(x_f^{(j)})\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\nSince the leading term of the error is proportional to $\\Delta x^2$, the scheme is second-order accurate, satisfying the problem's requirement.\n\nTo determine the observed order of accuracy $p$, we compute the $L_2$ norm of the error, $\\|e\\|_{L_2}$, for a sequence of progressively refined meshes. The theoretical relationship between the error norm and the mesh spacing is $\\|e\\|_{L_2} \\approx C(\\Delta x)^p$, where $C$ is a constant. Taking the natural logarithm of both sides yields:\n$$\n\\ln(\\|e\\|_{L_2}) \\approx \\ln(C) + p \\ln(\\Delta x)\n$$\nThis equation has the form of a straight line, $y = m x + b$, where $y = \\ln(\\|e\\|_{L_2})$, $x = \\ln(\\Delta x)$, the slope is the order of accuracy $m=p$, and the y-intercept is $b = \\ln(C)$.\n\nThe computational procedure is as follows:\n1. For each wavenumber $k$ in the test suite $\\{2\\pi, 8\\pi, 32\\pi\\}$:\n2. For each mesh size $N$ in the family $\\{10, 20, 40, 80\\}$:\n    a. Calculate the mesh spacing $\\Delta x = 1/N$.\n    b. Define the arrays of cell-center positions $x_i$ and face positions $x_f^{(j)}$.\n    c. Evaluate the manufactured solution $\\phi(x) = \\sin(kx)$ at cell centers to obtain $\\{\\phi_i\\}$.\n    d. Evaluate the exact solution at face centers to obtain $\\{\\phi(x_f^{(j)})\\}$.\n    e. Compute the interpolated face values $\\{\\phi_f^{(j)}\\}$ using $\\phi_f^{(j)} = (\\phi_{(j-1)\\pmod N} + \\phi_j)/2$.\n    f. Compute the discrete $L_2$ norm of the face interpolation error: $\\|e\\|_{L_2} = \\left( \\Delta x \\sum_{j=0}^{N-1} [\\phi_f^{(j)} - \\phi(x_f^{(j)})]^2 \\right)^{1/2}$.\n    g. Store the pair $(\\ln \\Delta x, \\ln \\|e\\|_{L_2})$.\n3. Check if all computed errors for a given $k$ are numerically zero. If so, set $p = +\\infty$.\n4. Otherwise, perform a linear least-squares regression on the set of points $(\\ln \\Delta x, \\ln \\|e\\|_{L_2})$ to find the slope, which is the observed order of accuracy $p$.\n\nThis procedure is implemented for each of the three given wavenumbers to produce the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for a central interpolation scheme.\n\n    The problem involves a 1D periodic domain with a manufactured solution\n    phi(x) = sin(k*x). The value at a cell face is interpolated from the two\n    neighboring cell centers using a second-order accurate central scheme, which\n    is the arithmetic mean of the neighboring values.\n\n    The L2 error of this interpolation is computed for a family of meshes. The\n    observed order of accuracy is then determined by a least-squares fit on\n    the log-log plot of the error vs. mesh size.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    k_values = [2 * np.pi, 8 * np.pi, 32 * np.pi]\n    N_values = [10, 20, 40, 80]\n    \n    # Store the observed order of accuracy for each k.\n    observed_orders = []\n\n    for k in k_values:\n        log_dx_list = []\n        log_error_list = []\n        errors_for_case = []\n        \n        for N in N_values:\n            # 1. Define mesh parameters and grid locations.\n            dx = 1.0 / N\n            # Cell centers: x_i = (i + 1/2) * dx\n            x_cell = (np.arange(N) + 0.5) * dx\n            # Face centers: x_f = j * dx\n            x_face = np.arange(N) * dx\n\n            # 2. Evaluate the manufactured solution.\n            # Cell-centered values of the solution.\n            phi_cell = np.sin(k * x_cell)\n            # Exact solution at face locations.\n            phi_face_exact = np.sin(k * x_face)\n\n            # 3. Perform central interpolation for face values.\n            # The scheme is phi_f[j] = 0.5 * (phi_cell[j-1] + phi_cell[j]).\n            # np.roll(phi_cell, 1) provides periodic shifting, so that\n            # phi_left[j] = phi_cell[j-1] (and phi_left[0] = phi_cell[N-1]).\n            phi_left_neighbor = np.roll(phi_cell, 1)\n            phi_right_neighbor = phi_cell\n            phi_face_interp = 0.5 * (phi_left_neighbor + phi_right_neighbor)\n\n            # 4. Compute the discrete L2 norm of the interpolation error.\n            error_vector = phi_face_interp - phi_face_exact\n            l2_error = np.sqrt(dx * np.sum(error_vector**2))\n            \n            errors_for_case.append(l2_error)\n            \n            # Store log-values for regression, avoiding log(0).\n            # A small tolerance is used to check for numerical zero.\n            if l2_error > 1e-16:\n                log_dx_list.append(np.log(dx))\n                log_error_list.append(np.log(l2_error))\n\n        # 5. Estimate the order of accuracy.\n        # Check for the special case of all errors being numerically zero.\n        if np.all(np.array(errors_for_case) < 1e-16):\n            order = np.inf\n        # Ensure at least two points for a meaningful line fit.\n        elif len(log_dx_list) >= 2:\n            # Perform a linear least-squares fit to find the slope.\n            # The model is log(error) = p * log(dx) + C.\n            # np.polyfit returns [slope, intercept].\n            p, _ = np.polyfit(log_dx_list, log_error_list, 1)\n            order = p\n        else:\n            # This case (fewer than 2 non-zero points) is unlikely but\n            # would mean the order cannot be determined from the fit.\n            # We'll assign NaN as a signal of this undefined state.\n            order = np.nan\n            \n        observed_orders.append(order)\n\n    # Final print statement in the exact required format.\n    # The default string representation of np.inf is 'inf', which is the\n    # standard representation for floating-point infinity.\n    print(f\"[{','.join(map(str, observed_orders))}]\")\n\nsolve()\n```", "id": "3298479"}, {"introduction": "As established, linear high-order schemes like central differencing can fail spectacularly in advection-dominated flows, producing non-physical results such as negative concentrations. This advanced exercise confronts this issue directly by demonstrating the failure and then guiding you through the implementation of a solution: a Flux-Corrected Transport (FCT) scheme. This practice bridges the gap between simple linear methods and the more robust, non-linear schemes required for modern CFD, showing how to retain accuracy while enforcing physical realism. [@problem_id:3298519]", "problem": "Consider the one-dimensional conservative transport of a nonnegative scalar concentration $\\,\\phi(x,t)\\,$ with a localized source term $\\,S(x)\\,$, governed by the conservation law\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u\\,\\phi\\right) = S(x),\n$$\nwhere $\\,u\\,$ is a constant velocity. Use a finite volume discretization on a uniform mesh of $\\,N\\,$ control volumes covering a periodic domain of length $\\,L\\,$. Let the cell-average at time $\\,t^n\\,$ be denoted $\\,\\phi_i^n\\,$ for cell index $\\,i \\in \\{0,1,\\dots,N-1\\}\\,$, with uniform spacing $\\,\\Delta x = L/N\\,$ and time step $\\,\\Delta t\\,$. Define the right face between cells $\\,i\\,$ and $\\,i+1\\,$ by the index $\\,i+\\tfrac{1}{2}\\,$, with periodic indexing for $\\,i=\\{-1,N\\}\\,$. Assume a first-order operator splitting where the source is applied explicitly followed by transport:\n$$\n\\tilde{\\phi}_i = \\phi_i^n + \\Delta t\\,S_i,\\quad \\text{then}\\quad \\phi_i^{n+1} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right).\n$$\nHere $\\,F_{i+\\tfrac{1}{2}}\\,$ is the numerical advective flux at face $\\,i+\\tfrac{1}{2}\\,$ computed from $\\,\\tilde{\\phi}\\,$. Consider the central face interpolation defined by\n$$\n\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}} = \\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2},\\quad F_{i+\\tfrac{1}{2}}^{H} = u\\,\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}}.\n$$\nFor comparison, define the positivity-preserving low-order upwind flux\n$$\nF_{i+\\tfrac{1}{2}}^{L} =\n\\begin{cases}\nu\\,\\tilde{\\phi}_i,& u>0,\\\\\nu\\,\\tilde{\\phi}_{i+1},& u<0.\n\\end{cases}\n$$\nLet the high-order central-only update be\n$$\n\\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{H} - F_{i-\\tfrac{1}{2}}^{H}\\right),\n$$\nand the low-order upwind update be\n$$\n\\phi_i^{L} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{L} - F_{i-\\tfrac{1}{2}}^{L}\\right).\n$$\nYour task is twofold:\n- Starting from the finite volume conservation form and the definitions above, analyze how central face interpolation may produce negative concentrations after one transport step when $\\,\\tilde{\\phi}\\,$ is strongly localized due to $\\,S(x)\\,$.\n- Design and implement a flux-corrected transport step that minimally perturbs the central fluxes to enforce nonnegativity in $\\,\\phi^{n+1}\\,$. Specifically, construct antidiffusive fluxes $\\,A_{i+\\tfrac{1}{2}} = F_{i+\\tfrac{1}{2}}^{H} - F_{i+\\tfrac{1}{2}}^{L}\\,$, define per-cell lower bound allowances $\\,P_i^{-} = \\phi_i^{L}\\,$, and choose face limiters $\\,\\alpha_{i+\\tfrac{1}{2}} \\in [0,1]\\,$ such that the limited antidiffusion preserves nonnegativity while maximizing $\\,\\alpha_{i+\\tfrac{1}{2}}\\,$ subject to the constraint. The limited update must be\n$$\n\\phi_i^{\\text{FCT}} = \\phi_i^{L} - \\frac{\\Delta t}{\\Delta x}\\left(\\alpha_{i+\\tfrac{1}{2}}\\,A_{i+\\tfrac{1}{2}} - \\alpha_{i-\\tfrac{1}{2}}\\,A_{i-\\tfrac{1}{2}}\\right).\n$$\nUse periodic boundary conditions. All concentrations are dimensionless, and no physical unit conversion is required.\n\nThe limiter design requirement is as follows. For each cell, consider the antidiffusive contributions from faces:\n$$\nc_{i,\\,+} = -\\frac{\\Delta t}{\\Delta x}A_{i+\\tfrac{1}{2}},\\quad c_{i,\\,-} = \\frac{\\Delta t}{\\Delta x}A_{i-\\tfrac{1}{2}}\\,.\n$$\nCompute the sum of their negative parts\n$$\n\\Sigma_i^{-} = \\sum_{\\sigma \\in \\{+,-\\}} \\min\\left(0, c_{i,\\sigma}\\right).\n$$\nDefine the per-cell reduction factor\n$$\nr_i^{-} =\n\\begin{cases}\n1,& \\Sigma_i^{-} = 0,\\\\\n\\min\\left(1,\\dfrac{P_i^{-}}{-\\Sigma_i^{-}}\\right),& \\Sigma_i^{-} < 0,\n\\end{cases}\n$$\nand set the face limiter by\n$$\n\\alpha_{i+\\tfrac{1}{2}} =\n\\begin{cases}\nr_i^{-},& A_{i+\\tfrac{1}{2}} \\ge 0,\\\\\nr_{i+1}^{-},& A_{i+\\tfrac{1}{2}} < 0.\n\\end{cases}\n$$\nThis choice must ensure nonnegativity of $\\,\\phi^{\\text{FCT}}\\,$ while perturbing the central fluxes only as much as necessary.\n\nImplement the scheme for the following test suite. For each case, initialize $\\,\\phi_i^0 = 0\\,$ for all $\\,i\\,$, place a localized source at a single cell index $\\,i_0\\,$ with strength $\\,Q > 0\\,$ applied for one source-transport split step such that $\\,\\Delta t\\,S_{i_0} = Q\\,$ and $\\,S_i = 0\\,$ for $\\,i \\ne i_0\\,$. Choose $\\,\\Delta t\\,$ to satisfy a target Courant number $\\,\\mathsf{C} = |u|\\,\\Delta t/\\Delta x\\,$. The four test cases are:\n1. $\\,N=50\\,$, $\\,L=1.0\\,$, $\\,u=1.0\\,$, $\\,\\mathsf{C}=0.8\\,$, $\\,Q=1.0\\,$, $\\,i_0=12\\,$.\n2. $\\,N=50\\,$, $\\,L=1.0\\,$, $\\,u=-1.0\\,$, $\\,\\mathsf{C}=0.8\\,$, $\\,Q=1.0\\,$, $\\,i_0=12\\,$.\n3. $\\,N=50\\,$, $\\,L=1.0\\,$, $\\,u=1.0\\,$, $\\,\\mathsf{C}=0.8\\,$, $\\,Q=4.0\\,$, $\\,i_0=0\\,$.\n4. $\\,N=50\\,$, $\\,L=1.0\\,$, $\\,u=1.0\\,$, $\\,\\mathsf{C}=0.95\\,$, $\\,Q=1.0\\,$, $\\,i_0=25\\,$.\n\nFor each case, perform one source step and one transport step, and compute the minimum values $\\,\\min_i \\phi_i^{H}\\,$ and $\\,\\min_i \\phi_i^{\\text{FCT}}\\,$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\min_i \\phi_i^{H},\\,\\min_i \\phi_i^{\\text{FCT}}]$ for the corresponding test case, for example $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$ with decimal numbers $\\,a_k\\,$ and $\\,b_k\\,$.", "solution": "The user has provided a valid problem statement from the field of computational fluid dynamics, specifically concerning the implementation and analysis of a flux-corrected transport (FCT) scheme for a one-dimensional advection equation. The problem is scientifically grounded, well-posed, and all necessary parameters and definitions are provided for a unique solution.\n\nThe task is twofold: first, to provide a theoretical analysis of why a simple central differencing scheme for the advective flux can lead to non-physical negative values, and second, to design and implement a specific FCT scheme that corrects this issue.\n\n### Analysis of Central Face Interpolation\nThe finite volume update for the transport step is given by:\n$$ \\phi_i^{n+1} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right) $$\nwhere $\\tilde{\\phi}_i$ is the concentration in cell $i$ after the source step. The high-order update, $\\phi_i^H$, uses the central flux $F^H$:\n$$ F_{i+\\tfrac{1}{2}}^{H} = u\\,\\phi_{i+\\tfrac{1}{2}}^{\\text{cen}} = u\\,\\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2} $$\nSubstituting this flux into the update equation gives the explicit form for the high-order update:\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left( u\\,\\frac{\\tilde{\\phi}_i + \\tilde{\\phi}_{i+1}}{2} - u\\,\\frac{\\tilde{\\phi}_{i-1} + \\tilde{\\phi}_{i}}{2} \\right) $$\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{u\\,\\Delta t}{2\\Delta x}\\left( \\tilde{\\phi}_{i+1} - \\tilde{\\phi}_{i-1} \\right) $$\nLet the signed Courant number be $\\mathsf{C}_u = u\\,\\Delta t/\\Delta x$. The update becomes:\n$$ \\phi_i^{H} = \\tilde{\\phi}_i - \\frac{\\mathsf{C}_u}{2}\\left( \\tilde{\\phi}_{i+1} - \\tilde{\\phi}_{i-1} \\right) $$\nNow, consider the problem's initial condition for a single step: $\\phi_i^0=0$ for all $i$, with a localized source $\\Delta t S_{i_0} = Q$ at a single cell $i_0$. After the source step, the state is $\\tilde{\\phi}_{i_0} = Q$ and $\\tilde{\\phi}_{i \\ne i_0} = 0$. We analyze the update for cells in the vicinity of the pulse at $i_0$.\n\nLet's assume a positive velocity $u > 0$, so $\\mathsf{C}_u = \\mathsf{C} = |u|\\Delta t / \\Delta x > 0$.\n- For cell $i_0+1$ (downstream):\n  $$ \\phi_{i_0+1}^H = \\tilde{\\phi}_{i_0+1} - \\frac{\\mathsf{C}}{2}\\left( \\tilde{\\phi}_{i_0+2} - \\tilde{\\phi}_{i_0} \\right) = 0 - \\frac{\\mathsf{C}}{2}(0 - Q) = \\frac{\\mathsf{C}}{2}Q $$\n  This is a positive value, representing the advection of the pulse.\n- For cell $i_0-1$ (upstream):\n  $$ \\phi_{i_0-1}^H = \\tilde{\\phi}_{i_0-1} - \\frac{\\mathsf{C}}{2}\\left( \\tilde{\\phi}_{i_0} - \\tilde{\\phi}_{i_0-2} \\right) = 0 - \\frac{\\mathsf{C}}{2}(Q - 0) = -\\frac{\\mathsf{C}}{2}Q $$\nThis result is explicitly negative. The central scheme, in approximating the spatial derivative at cell $i-1$ using values from cells $i-2$ and $i$, creates a non-physical undershoot upstream of the propagating pulse. This is a characteristic failure of linear, second-order schemes, which are not monotonicity-preserving and can generate new minima and maxima (Gibbs phenomenon). The magnitude of this negative concentration is proportional to both the Courant number and the pulse strength. A similar analysis for $u < 0$ shows a negative undershoot at cell $i_0+1$.\n\n### Flux-Corrected Transport (FCT) Scheme\n\nThe FCT methodology addresses this issue by blending a low-order, positivity-preserving scheme with a high-order, more accurate scheme. The process ensures that the correction (antidiffusion) from the high-order scheme does not violate the positivity constraint.\n\n**1. Low-Order Positivity-Preserving Solution**\nThe foundation is the first-order upwind scheme, which is known to be diffusive but guarantees positivity for Courant numbers $\\mathsf{C} \\le 1$. Its update is:\n$$ \\phi_i^{L} = \\tilde{\\phi}_i - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^{L} - F_{i-\\tfrac{1}{2}}^{L}\\right) $$\nFor $u>0$ and the given pulse initial condition, it can be shown that $\\phi_i^L = \\tilde{\\phi}_i - \\mathsf{C}(\\tilde{\\phi}_i - \\tilde{\\phi}_{i-1})$. For the pulse at $i_0$, this yields $\\phi_{i_0}^L = (1-\\mathsf{C})Q$ and $\\phi_{i_0+1}^L = \\mathsf{C}Q$, with all other values being zero. Since $\\mathsf{C} \\le 1$, all $\\phi_i^L \\ge 0$. This non-negative field, $\\phi_i^L$, serves as the baseline and also defines the available \"room\" for antidiffusive corrections, $P_i^- = \\phi_i^L$.\n\n**2. Antidiffusive Flux and Limiter Design**\nThe difference between the high-order and low-order fluxes is the antidiffusive flux, $A_{i+\\tfrac{1}{2}} = F_{i+\\tfrac{1}{2}}^{H} - F_{i+\\tfrac{1}{2}}^{L}$, which represents the correction needed to restore second-order accuracy. The FCT update is formulated as the low-order solution plus a limited antidiffusive correction:\n$$ \\phi_i^{\\text{FCT}} = \\phi_i^{L} - \\frac{\\Delta t}{\\Delta x}\\left(\\alpha_{i+\\tfrac{1}{2}}\\,A_{i+\\tfrac{1}{2}} - \\alpha_{i-\\tfrac{1}{2}}\\,A_{i-\\tfrac{1}{2}}\\right) $$\nThe core of the method lies in choosing the face limiters $\\alpha_{i+\\tfrac{1}{2}} \\in [0,1]$. The specific algorithm is as follows:\n\n- **Step 1: Compute Per-Cell Antidiffusive Contributions**: For each cell $i$, the potential changes due to antidiffusion from the right face ($i+\\frac{1}{2}$) and left face ($i-\\frac{1}{2}$) are calculated:\n  $$ c_{i,\\,+} = -\\frac{\\Delta t}{\\Delta x}A_{i+\\tfrac{1}{2}}, \\quad c_{i,\\,-} = \\frac{\\Delta t}{\\Delta x}A_{i-\\tfrac{1}{2}} $$\n- **Step 2: Sum Negative Contributions**: For each cell $i$, sum all incoming antidiffusive contributions that would decrease $\\phi_i^L$:\n  $$ \\Sigma_i^{-} = \\min\\left(0, c_{i,\\,+}\\right) + \\min\\left(0, c_{i,\\,-}\\right) $$\n- **Step 3: Compute Per-Cell Reduction Factor**: This factor, $r_i^-$, determines how much the negative-going fluxes must be scaled down to prevent $\\phi_i$ from becoming negative. The budget for this is $P_i^{-} = \\phi_i^L$.\n  $$ r_i^{-} = \\begin{cases} 1, & \\text{if } \\Sigma_i^{-} = 0 \\\\ \\min\\left(1, \\frac{P_i^{-}}{-\\Sigma_i^{-}}\\right), & \\text{if } \\Sigma_i^{-} < 0 \\end{cases} $$\n  This ensures that the total limited negative contribution, $r_i^- \\Sigma_i^-$, does not have a magnitude greater than $\\phi_i^L$.\n\n- **Step 4: Compute Face Limiters**: The per-cell factor $r^-$ is used to determine the limiter $\\alpha$ for each face. The choice depends on which cell is the \"donor\" of the antidiffusive flux. This is determined by the sign of $A_{i+\\tfrac{1}{2}}$:\n  $$ \\alpha_{i+\\tfrac{1}{2}} = \\begin{cases} r_i^{-}, & \\text{if } A_{i+\\tfrac{1}{2}} \\ge 0 \\\\ r_{i+1}^{-}, & \\text{if } A_{i+\\tfrac{1}{2}} < 0 \\end{cases} $$\n  If $A_{i+\\tfrac{1}{2}} \\ge 0$ (for $u>0$), it corresponds to a flux of antidiffusion from cell $i$ to $i+1$. The limiting is thus governed by the available amount in cell $i$, via $r_i^-$. Conversely, if $A_{i+\\tfrac{1}{2}} < 0$, antidiffusion flows from $i+1$ to $i$, and the limiter $r_{i+1}^-$ is used. This construction guarantees that for any cell $i$, the sum of all limited negative-going antidiffusive fluxes does not exceed $\\phi_i^L$, thus ensuring $\\phi_i^{\\text{FCT}} \\ge 0$.\n\n- **Step 5: Compute Final Solution**: With the limiters $\\alpha_{i+\\tfrac{1}{2}}$ determined, the final non-negative solution $\\phi_i^{\\text{FCT}}$ is calculated using the FCT update formula. By design, this scheme minimally perturbs the more accurate central fluxes, only applying corrections where necessary to preserve positivity.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using high-order central and \n    flux-corrected transport (FCT) schemes for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (N, L, u, C, Q, i0)\n        (50, 1.0, 1.0, 0.8, 1.0, 12),\n        (50, 1.0, -1.0, 0.8, 1.0, 12),\n        (50, 1.0, 1.0, 0.8, 4.0, 0),\n        (50, 1.0, 1.0, 0.95, 1.0, 25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, u, C, Q, i0 = case\n        \n        # Grid and time step setup\n        dx = L / N\n        dt = C * dx / abs(u)\n        \n        # Initial condition and source step\n        phi_n = np.zeros(N)\n        tilde_phi = np.copy(phi_n)\n        tilde_phi[i0] += Q # Problem statement: delta_t * S_i0 = Q\n        \n        # Prepare shifted arrays for periodic boundaries\n        tilde_phi_ip1 = np.roll(tilde_phi, -1) # phi_{i+1} at index i\n        \n        # --- Flux calculations ---\n        # High-order central flux (F_H)\n        F_H = u * (tilde_phi + tilde_phi_ip1) / 2.0\n        \n        # Low-order upwind flux (F_L)\n        if u > 0:\n            F_L = u * tilde_phi\n        else:\n            F_L = u * tilde_phi_ip1\n            \n        # Antidiffusive flux (A)\n        A = F_H - F_L\n\n        # --- Compute H and L solutions ---\n        # Get fluxes at i-1/2 face for divergence calculation\n        F_H_im1 = np.roll(F_H, 1)\n        F_L_im1 = np.roll(F_L, 1)\n        \n        # High-order update (phi_H)\n        phi_H = tilde_phi - (dt / dx) * (F_H - F_H_im1)\n        \n        # Low-order update (phi_L), which is also P_minus\n        phi_L = tilde_phi - (dt / dx) * (F_L - F_L_im1)\n        P_minus = phi_L\n\n        # --- FCT Limiter Calculation ---\n        # Antidiffusive contributions per cell\n        c_plus = -(dt / dx) * A\n        c_minus = (dt / dx) * np.roll(A, 1)\n        \n        # Sum of negative parts\n        Sigma_minus = np.minimum(0.0, c_plus) + np.minimum(0.0, c_minus)\n        \n        # Per-cell reduction factor (r_minus)\n        r_minus = np.ones(N)\n        # Use a mask to avoid division by zero and handle the case Sigma_minus = 0\n        neg_sigma_mask = Sigma_minus < 0\n        \n        # The denominator -Sigma_minus is positive where the mask is true\n        r_minus[neg_sigma_mask] = np.minimum(1.0, P_minus[neg_sigma_mask] / (-Sigma_minus[neg_sigma_mask]))\n        \n        # Face limiter (alpha) based on donor cell logic from the problem statement\n        r_minus_ip1 = np.roll(r_minus, -1)\n        alpha = np.where(A >= 0, r_minus, r_minus_ip1)\n        \n        # --- Final FCT Update ---\n        A_limited = alpha * A\n        div_A_limited = A_limited - np.roll(A_limited, 1)\n        phi_FCT = phi_L - (dt / dx) * div_A_limited\n        \n        # Record the minimum values\n        min_H = np.min(phi_H)\n        min_FCT = np.min(phi_FCT)\n        results.append([min_H, min_FCT])\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{h:.6f},{fct:.6f}]\" for h, fct in results]\n    final_string = f\"[{','.join(inner_strings)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "3298519"}]}