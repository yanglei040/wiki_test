{"hands_on_practices": [{"introduction": "We begin with an essential tool for analyzing numerical schemes: Fourier analysis. This exercise explores how the most common interpolation method, the central arithmetic average, performs on a simple uniform grid when resolving a pure sinusoidal wave. By deriving the exact error as a function of the grid resolution, you will gain a quantitative understanding of 'dispersive error,' a fundamental concept that explains how numerical schemes can damp the amplitude of waves they are meant to represent [@problem_id:3337085].", "problem": "In one spatial dimension, consider a uniform finite-volume mesh used in Computational Fluid Dynamics (CFD), with cell centers located at positions $x_{c}^{-} = x_{f} - \\frac{\\Delta x}{2}$ and $x_{c}^{+} = x_{f} + \\frac{\\Delta x}{2}$ bracketing a face located at $x_{f}$. A scalar field is given by $u(x) = \\sin(k x)$, where $k$ is a real wavenumber and $\\Delta x$ is the uniform cell size. The midpoint interpolation constructs an approximation to the face value using adjacent cell-center samples,\n$$\n\\tilde{u}_{f} \\equiv \\frac{1}{2}\\big(u(x_{c}^{-}) + u(x_{c}^{+})\\big).\n$$\nDefine the error transfer function as the relative error at the face,\n$$\nE(\\theta) \\equiv \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1,\n$$\nwhere $\\theta \\equiv k \\Delta x$. Starting from the definitions above and standard trigonometric identities, derive a closed-form expression for $E(\\theta)$ that depends only on $\\theta$. Your final answer must be a single analytic expression in terms of $\\theta$ only. No rounding is required, and no units are needed.", "solution": "The problem statement is critically validated and deemed to be self-contained, scientifically grounded, and well-posed. All definitions are standard within the field of numerical methods for partial differential equations, specifically the analysis of finite-volume and finite-difference schemes. The problem asks for the derivation of a closed-form expression for the error transfer function of a midpoint interpolation scheme applied to a sinusoidal field. We shall proceed with a formal derivation.\n\nThe objective is to find an expression for the error transfer function $E(\\theta)$ defined as\n$$\nE(\\theta) \\equiv \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1,\n$$\nwhere $\\tilde{u}_{f}$ is the interpolated value at a cell face located at $x_{f}$, and $u(x_{f})$ is the exact value.\n\nFirst, we write down the definition of the midpoint interpolation for the value at the face, $\\tilde{u}_{f}$. It is the arithmetic mean of the values at the centers of the two adjacent cells, $x_{c}^{-}$ and $x_{c}^{+}$:\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( u(x_{c}^{-}) + u(x_{c}^{+}) \\right).\n$$\n\nThe locations of the cell centers are given relative to the face location $x_{f}$ and the uniform cell size $\\Delta x$ as:\n$$\nx_{c}^{-} = x_{f} - \\frac{\\Delta x}{2},\n$$\n$$\nx_{c}^{+} = x_{f} + \\frac{\\Delta x}{2}.\n$$\n\nThe scalar field $u(x)$ is given by a single Fourier mode:\n$$\nu(x) = \\sin(k x),\n$$\nwhere $k$ is the wavenumber.\n\nWe substitute the expressions for the cell center locations and the scalar field into the definition of $\\tilde{u}_{f}$:\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k x_{c}^{-}\\right) + \\sin\\left(k x_{c}^{+}\\right) \\right)\n$$\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k \\left(x_{f} - \\frac{\\Delta x}{2}\\right)\\right) + \\sin\\left(k \\left(x_{f} + \\frac{\\Delta x}{2}\\right)\\right) \\right).\n$$\n\nExpanding the arguments of the sine functions, we get:\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\sin\\left(k x_{f} + \\frac{k \\Delta x}{2}\\right) \\right).\n$$\n\nTo simplify this expression, we employ the standard trigonometric sum-to-product identity:\n$$\n\\sin(A) + \\sin(B) = 2 \\sin\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right).\n$$\n\nLet us identify $A$ and $B$ from our expression for $\\tilde{u}_{f}$:\n$$\nA = k x_{f} - \\frac{k \\Delta x}{2},\n$$\n$$\nB = k x_{f} + \\frac{k \\Delta x}{2}.\n$$\n\nNow, we compute the terms needed for the identity:\n$$\n\\frac{A+B}{2} = \\frac{\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\left(k x_{f} + \\frac{k \\Delta x}{2}\\right)}{2} = \\frac{2 k x_{f}}{2} = k x_{f}.\n$$\n$$\n\\frac{A-B}{2} = \\frac{\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) - \\left(k x_{f} + \\frac{k \\Delta x}{2}\\right)}{2} = \\frac{-k \\Delta x}{2} = -\\frac{k \\Delta x}{2}.\n$$\n\nSubstituting these back into the sum-to-product identity, the sum of sine terms becomes:\n$$\n\\sin\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\sin\\left(k x_{f} + \\frac{k \\Delta x}{2}\\right) = 2 \\sin(k x_{f}) \\cos\\left(-\\frac{k \\Delta x}{2}\\right).\n$$\n\nUsing the property that the cosine function is an even function, i.e., $\\cos(-z) = \\cos(z)$, we have:\n$$\n2 \\sin(k x_{f}) \\cos\\left(-\\frac{k \\Delta x}{2}\\right) = 2 \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\nNow, we substitute this simplified result back into the expression for $\\tilde{u}_{f}$:\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left[ 2 \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right) \\right] = \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\nNext, we evaluate the ratio $\\frac{\\tilde{u}_{f}}{u(x_{f})}$. The exact value at the face is $u(x_{f}) = \\sin(k x_{f})$. Therefore,\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\frac{\\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right)}{\\sin(k x_{f})}.\n$$\nThis ratio is valid for all $x_f$ such that $\\sin(k x_f) \\neq 0$. The expression simplifies by cancelling the term $\\sin(k x_f)$, resolving the apparent dependence on the face position $x_f$ and the singularity at the nodes of the wave. The result is:\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\nThe problem defines the dimensionless wavenumber as $\\theta \\equiv k \\Delta x$. Substituting this into our expression gives:\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\cos\\left(\\frac{\\theta}{2}\\right).\n$$\n\nFinally, we use the definition of the error transfer function $E(\\theta)$:\n$$\nE(\\theta) = \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1.\n$$\nSubstituting the expression we just derived for the ratio gives the final closed-form expression for $E(\\theta)$ solely in terms of $\\theta$:\n$$\nE(\\theta) = \\cos\\left(\\frac{\\theta}{2}\\right) - 1.\n$$\nThis function quantifies the amplitude error introduced by the midpoint interpolation. For waves that are well-resolved by the mesh (i.e., $\\theta \\ll 1$), the error is small, as $\\cos(\\theta/2) \\approx 1$. For waves at the Nyquist limit of the grid, where $\\Delta x = \\lambda/2$ and $\\theta = k \\Delta x = (2\\pi/\\lambda)(\\lambda/2) = \\pi$, the error is $E(\\pi) = \\cos(\\pi/2) - 1 = -1$, indicating complete damping of the interpolated amplitude for this specific mode.", "answer": "$$\n\\boxed{\\cos\\left(\\frac{\\theta}{2}\\right) - 1}\n$$", "id": "3337085"}, {"introduction": "While uniform grids are ideal, real-world geometries in CFD often demand non-orthogonal or 'skewed' meshes. This practice reveals a critical pitfall of simple interpolation schemes when applied to such grids, a phenomenon that gives rise to 'skewness error.' By analyzing a deliberately constructed counterexample, you will prove that a naive arithmetic average fails to preserve linearity and will quantify the resulting error, directly linking it to the mesh geometry and the gradient of the scalar field [@problem_id:3337138].", "problem": "Consider the two-dimensional Computational Fluid Dynamics (CFD) setting under the Finite Volume Method (FVM), where face-centered fluxes require interpolation of cell-centered values. A face interpolation is said to be linearity-preserving if, for any linear scalar field, the interpolation reproduces the exact value at the face centroid. Starting only from the definitions of a linear scalar field and Euclidean geometry, analyze the following deliberately skewed mesh and naive interpolation rule.\n\nThe mesh consists of two adjacent convex control volumes with cell centroids at $\\boldsymbol{C}_{L}=(0,0)$ and $\\boldsymbol{C}_{R}=(1,0)$, sharing a common straight face whose centroid is at $\\boldsymbol{F}=(0.6,0.2)$. Consider the scalar field $u(x,y)=a\\,x+b\\,y$, where $a$ and $b$ are real constants. The face value is approximated by the simple arithmetic mean of the adjacent cell-centered values,\n$$u_{f}^{\\mathrm{interp}}=\\frac{1}{2}\\big(u(\\boldsymbol{C}_{L})+u(\\boldsymbol{C}_{R})\\big).$$\n\nUsing only the stated geometry and the fundamental properties of linear functions, compute the interpolation error\n$$\\varepsilon=u_{f}^{\\mathrm{interp}}-u(\\boldsymbol{F}).$$\nExpress your final answer as a single simplified analytic expression in terms of $a$ and $b$ with no units.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The setup represents a standard pedagogical case in computational fluid dynamics for analyzing the error of an interpolation scheme on a skewed mesh. Therefore, the problem is valid, and we proceed with the solution.\n\nThe problem requires the computation of the interpolation error, $\\varepsilon$, for a given linear scalar field on a specified two-dimensional mesh. The error is defined as the difference between the interpolated value at a face, $u_{f}^{\\mathrm{interp}}$, and the exact value at the face centroid, $u(\\boldsymbol{F})$.\n\nThe provided information is:\n- The cell centroid of the left control volume: $\\boldsymbol{C}_{L} = (0, 0)$.\n- The cell centroid of the right control volume: $\\boldsymbol{C}_{R} = (1, 0)$.\n- The centroid of the shared face: $\\boldsymbol{F} = (0.6, 0.2)$. For precision, we will use the equivalent fractional form $\\boldsymbol{F} = (\\frac{3}{5}, \\frac{1}{5})$.\n- The linear scalar field: $u(x,y) = a\\,x + b\\,y$.\n- The interpolation rule: $u_{f}^{\\mathrm{interp}} = \\frac{1}{2}\\big(u(\\boldsymbol{C}_{L}) + u(\\boldsymbol{C}_{R})\\big)$.\n- The quantity to be computed: $\\varepsilon = u_{f}^{\\mathrm{interp}} - u(\\boldsymbol{F})$.\n\nOur derivation proceeds in three steps: First, we compute the interpolated value $u_{f}^{\\mathrm{interp}}$. Second, we compute the exact value $u(\\boldsymbol{F})$. Finally, we compute their difference to find the error $\\varepsilon$.\n\nStep 1: Compute the interpolated value $u_{f}^{\\mathrm{interp}}$.\nWe evaluate the scalar field $u(x,y)$ at the two cell centroids, $\\boldsymbol{C}_{L}$ and $\\boldsymbol{C}_{R}$.\nAt the left centroid $\\boldsymbol{C}_{L} = (0, 0)$:\n$$u(\\boldsymbol{C}_{L}) = u(0, 0) = a(0) + b(0) = 0$$\nAt the right centroid $\\boldsymbol{C}_{R} = (1, 0)$:\n$$u(\\boldsymbol{C}_{R}) = u(1, 0) = a(1) + b(0) = a$$\nNow, we apply the specified interpolation rule, which is the simple arithmetic mean of the two cell-centered values:\n$$u_{f}^{\\mathrm{interp}} = \\frac{1}{2}\\big(u(\\boldsymbol{C}_{L}) + u(\\boldsymbol{C}_{R})\\big) = \\frac{1}{2}(0 + a) = \\frac{a}{2}$$\n\nIt is instructive to note the geometric meaning of this interpolation. A fundamental property of linear functions is that the value of the function at the midpoint of a line segment is the arithmetic mean of the values at the endpoints. The interpolation point, let's call it $\\boldsymbol{M}$, is the midpoint of the segment connecting $\\boldsymbol{C}_{L}$ and $\\boldsymbol{C}_{R}$:\n$$\\boldsymbol{M} = \\frac{1}{2}(\\boldsymbol{C}_{L} + \\boldsymbol{C}_{R}) = \\frac{1}{2}\\big((0,0) + (1,0)\\big) = (\\frac{1}{2}, 0)$$\nThe interpolated value $u_{f}^{\\mathrm{interp}}$ is precisely the value of the linear field $u$ at this point $\\boldsymbol{M}$:\n$$u(\\boldsymbol{M}) = u(\\frac{1}{2}, 0) = a(\\frac{1}{2}) + b(0) = \\frac{a}{2}$$\nThis confirms our calculation. The simple averaging scheme implicitly assumes the face centroid lies at the midpoint of the line connecting the cell centroids. For a skewed mesh, this is not the case, which is the source of the error.\n\nStep 2: Compute the exact value at the face centroid, $u(\\boldsymbol{F})$.\nThe exact value is obtained by evaluating the function $u(x,y)$ at the coordinates of the face centroid, $\\boldsymbol{F} = (\\frac{3}{5}, \\frac{1}{5})$.\n$$u(\\boldsymbol{F}) = u(\\frac{3}{5}, \\frac{1}{5}) = a(\\frac{3}{5}) + b(\\frac{1}{5}) = \\frac{3a}{5} + \\frac{b}{5}$$\n\nStep 3: Compute the interpolation error $\\varepsilon$.\nThe error is the difference between the interpolated value and the exact value.\n$$\\varepsilon = u_{f}^{\\mathrm{interp}} - u(\\boldsymbol{F})$$\nSubstituting the expressions derived in the previous steps:\n$$\\varepsilon = \\frac{a}{2} - \\left(\\frac{3a}{5} + \\frac{b}{5}\\right)$$\nWe group the terms containing $a$ and $b$:\n$$\\varepsilon = \\left(\\frac{1}{2} - \\frac{3}{5}\\right)a - \\frac{1}{5}b$$\nTo combine the coefficients of $a$, we find a common denominator, which is $10$:\n$$\\varepsilon = \\left(\\frac{5}{10} - \\frac{6}{10}\\right)a - \\frac{2}{10}b$$\n$$\\varepsilon = -\\frac{1}{10}a - \\frac{2}{10}b$$\nThis expression can be simplified into a single fraction:\n$$\\varepsilon = -\\frac{a + 2b}{10}$$\nThe error is non-zero for arbitrary constants $a$ and $b$, which demonstrates that this simple interpolation scheme is not linearity-preserving on the given skewed mesh. The error depends on the gradient of the scalar field, $\\nabla u = (a, b)$, and the geometric skewness of the mesh, represented by the vector difference between the interpolation point $\\boldsymbol{M}$ and the true face centroid $\\boldsymbol{F}$.\n$\\boldsymbol{M} - \\boldsymbol{F} = (\\frac{1}{2} - \\frac{3}{5}, 0 - \\frac{1}{5}) = (\\frac{5-6}{10}, -\\frac{1}{5}) = (-\\frac{1}{10}, -\\frac{1}{5})$.\nThe error is $\\varepsilon = u(\\boldsymbol{M}) - u(\\boldsymbol{F}) = \\nabla u \\cdot (\\boldsymbol{M} - \\boldsymbol{F}) = (a,b)\\cdot(-\\frac{1}{10}, -\\frac{2}{10}) = -\\frac{a}{10}-\\frac{2b}{10} = -\\frac{a+2b}{10}$, which rigorously confirms our result.", "answer": "$$\n\\boxed{-\\frac{a + 2b}{10}}\n$$", "id": "3337138"}, {"introduction": "This final practice bridges the gap between analytical theory and computational practice by introducing the Method of Manufactured Solutions (MMS), a cornerstone of modern code verification. You will implement several common interpolation schemes and use a known analytical solution to rigorously test their performance on sequences of refining grids. By computationally measuring the convergence of the interpolation error, you will verify the theoretical 'order of accuracy' for each scheme, a critical skill for developing and validating reliable CFD software [@problem_id:3337129].", "problem": "Consider finite volume interpolation from cell centers to faces for a scalar field on a two-dimensional Cartesian domain $[0,1]\\times[0,1]$. The Method of Manufactured Solutions (MMS) will be used with the exact solution $u(x,y)=\\exp(x+y)$, which is infinitely differentiable and strictly positive on the domain.\n\nFundamental base and definitions:\n- The finite volume method stores the field $u$ at cell centers and requires an approximation of $u$ at face centers to compute consistent fluxes. A face interpolation operator is a mapping from values at cell centers to an estimate of $u$ at face centers.\n- For a uniform grid with $N_x$ cells in the $x$ direction and $N_y$ cells in the $y$ direction, let $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The nodal coordinates are $x_k = k\\Delta x$ for $k=0,\\dots,N_x$ and $y_\\ell = \\ell\\Delta y$ for $\\ell=0,\\dots,N_y$. The cell center coordinates are $x_i^c = (x_i + x_{i+1})/2$ and $y_j^c = (y_j + y_{j+1})/2$.\n- For a nonuniform grid with nodes $\\{x_k\\}_{k=0}^{N_x}$ and $\\{y_\\ell\\}_{\\ell=0}^{N_y}$ in $[0,1]$, the cell center coordinates are $x_i^c = (x_i + x_{i+1})/2$ and $y_j^c = (y_j + y_{j+1})/2$, and face centers are located at $x_{i+1}$ for vertical faces and $y_{j+1}$ for horizontal faces.\n- The discrete $L^2$ error for face interpolation is defined as\n$$\nE = \\left(\\frac{1}{N_f}\\sum_{f\\in\\mathcal{F}}\\left(\\hat{u}_f - u(x_f,y_f)\\right)^2\\right)^{1/2},\n$$\nwhere $\\mathcal{F}$ is the set of all face centers considered (both vertical and horizontal interior faces), $N_f$ is the total number of faces, and $\\hat{u}_f$ is the interpolated value at face $f$.\n\nInterpolation schemes to be implemented:\n- Upwind (piecewise constant) with positive advection components: on a vertical face between cells $(i,j)$ and $(i+1,j)$, use the left cell center value, and on a horizontal face between cells $(i,j)$ and $(i,j+1)$, use the bottom cell center value. This corresponds to selecting the upstream cell value for a constant advection vector with positive components.\n- Central arithmetic average: on a vertical face between cells $(i,j)$ and $(i+1,j)$, use $(u_{i,j}+u_{i+1,j})/2$, and on a horizontal face between cells $(i,j)$ and $(i,j+1)$, use $(u_{i,j}+u_{i,j+1})/2$.\n- Distance-weighted linear interpolation on nonuniform grids: on a vertical face at $x_f=x_{i+1}$ between cell centers $x_L=x_i^c$ and $x_R=x_{i+1}^c$, define\n$$\n\\hat{u}_f = \\frac{x_R - x_f}{x_R - x_L}u_L + \\frac{x_f - x_L}{x_R - x_L}u_R,\n$$\nand analogously for horizontal faces at $y_f=y_{j+1}$ with $y_L=y_j^c$ and $y_R=y_{j+1}^c$.\n\nObserved order of accuracy:\n- For a sequence of grids characterized by a mesh parameter $h$, define $h=\\max\\{\\max_i(x_{i+1}-x_i), \\max_j(y_{j+1}-y_j)\\}$. The observed order $p$ is obtained by fitting $\\log E \\approx \\log C + p \\log h$ via linear least squares over the grid sequence, and reporting the slope $p$.\n\nRequired computations:\n- Design the following grids and compute face interpolations to verify the observed order of accuracy for the three schemes above using $u(x,y)=\\exp(x+y)$:\n    1. Uniform grids with $N_x=N_y\\in\\{16,32,64,128\\}$ for the upwind scheme.\n    2. Uniform grids with $N_x=N_y\\in\\{16,32,64,128\\}$ for the central arithmetic average scheme.\n    3. Stretched nonuniform grids with nodes $x_k=(k/N_x)^2$, $y_\\ell=(\\ell/N_y)^2$ for $N_x=N_y\\in\\{20,40,80,160\\}$ using distance-weighted linear interpolation.\n- For each grid in a sequence, compute the discrete $L^2$ error $E$ over all interior vertical and horizontal faces using the exact value $u(x_f,y_f)=\\exp(x_f+y_f)$ at the face centers.\n- For each of the three cases above, compute the observed order $p$ of the interpolation scheme by performing a linear fit of $\\log E$ against $\\log h$ over the given grid sizes.\n\nTest suite and final output specification:\n- The test suite consists of three parameter sets:\n    - Case A: scheme upwind, grid type uniform, sizes $(16,16)$, $(32,32)$, $(64,64)$, $(128,128)$.\n    - Case B: scheme central average, grid type uniform, sizes $(16,16)$, $(32,32)$, $(64,64)$, $(128,128)$.\n    - Case C: scheme distance-weighted linear, grid type stretched, sizes $(20,20)$, $(40,40)$, $(80,80)$, $(160,160)$.\n- The expected outputs are three floating-point numbers, each the observed order $p$ for the corresponding case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[pA,pB,pC]\"). Each $p$ must be rounded to three decimal places. No physical units are involved, and no angles or percentages are required.", "solution": "The objective is to determine the observed order of accuracy for three distinct finite volume interpolation schemes on a two-dimensional Cartesian domain, $[0,1]\\times[0,1]$. This is achieved using the Method of Manufactured Solutions (MMS), where a known, smooth analytical solution is used as a benchmark to quantify the discretization error of a numerical method.\n\nThe exact solution is given as $u(x,y) = \\exp(x+y)$. The cell-centered values, denoted $u_{i,j}$, are obtained by evaluating this exact solution at the center of each cell $(i,j)$, i.e., $u_{i,j} = u(x_i^c, y_j^c)$. An interpolation scheme provides an approximation $\\hat{u}_f$ of the field value at the center of each face $f$. The error of the interpolation is measured against the exact solution evaluated at the same face center, $u(x_f, y_f)$.\n\nThe error is quantified using a discrete $L^2$ norm, defined as:\n$$\nE = \\left(\\frac{1}{N_f}\\sum_{f\\in\\mathcal{F}}\\left(\\hat{u}_f - u(x_f,y_f)\\right)^2\\right)^{1/2}\n$$\nwhere $\\mathcal{F}$ is the set of all interior faces (both vertical and horizontal), $N_f$ is the total number of such faces, $\\hat{u}_f$ is the interpolated value at face $f$, and $u(x_f, y_f)$ is the exact value. For an $N_x \\times N_y$ grid of cells, there are $N_y(N_x-1)$ interior vertical faces and $N_x(N_y-1)$ interior horizontal faces, so $N_f = N_y(N_x-1) + N_x(N_y-1)$.\n\nThe order of accuracy, $p$, describes how the error $E$ decreases as the mesh is refined. It is determined by the relationship $E \\approx C h^p$, where $C$ is a constant and $h$ is a characteristic mesh size. Taking the logarithm of this relation gives $\\log E \\approx \\log C + p \\log h$. We can therefore compute $p$ as the slope of a line fitted to a set of $(\\log h, \\log E)$ data points obtained from a sequence of grids with decreasing mesh sizes. The mesh parameter $h$ is defined as the maximum cell edge length in the grid, $h=\\max\\{\\max_i(x_{i+1}-x_i), \\max_j(y_{j+1}-y_j)\\}$.\n\nThe analysis proceeds by implementing each of the three specified schemes, computing the error $E$ for each grid in the given sequences, and then performing a linear least-squares regression on the log-transformed data to find the order $p$.\n\n**Case A: Upwind Scheme on Uniform Grids**\nThe upwind scheme, for an advection field with positive velocity components, approximates the face value by the value in the upstream cell.\n- For a vertical face at $x_{i+1}$ between cells $(i,j)$ and $(i+1,j)$, the upstream cell is $(i,j)$, so $\\hat{u}_f = u_{i,j}$.\n- For a horizontal face at $y_{j+1}$ between cells $(i,j)$ and $(i,j+1)$, the upstream cell is $(i,j)$, so $\\hat{u}_f = u_{i,j}$.\nThis scheme uses a piecewise constant reconstruction of the field. For the sequence of uniform grids with $N_x=N_y=N \\in \\{16, 32, 64, 128\\}$, the mesh size is $h = \\Delta x = \\Delta y = 1/N$. The cell-centered value is $u_{i,j} = \\exp(x_i^c + y_j^c)$. The error is computed at each interior face, and the order $p$ is determined from the slope of $\\log E$ vs. $\\log h$. This scheme is theoretically first-order accurate, so we expect $p \\approx 1$.\n\n**Case B: Central Arithmetic Average on Uniform Grids**\nThe central scheme approximates the face value as the arithmetic average of the values in the two adjacent cells.\n- For a vertical face: $\\hat{u}_f = (u_{i,j} + u_{i+1,j})/2$.\n- For a horizontal face: $\\hat{u}_f = (u_{i,j} + u_{i,j+1})/2$.\nThis is equivalent to linear interpolation on a uniform grid, as the face center is exactly halfway between the two adjacent cell centers. The same sequence of uniform grids as in Case A is used. This scheme is theoretically second-order accurate, so we expect $p \\approx 2$.\n\n**Case C: Distance-Weighted Linear Interpolation on Stretched Grids**\nThis scheme is a generalized linear interpolation applicable to nonuniform grids. For a face $f$ located between two cell centers $L$ (left/lower) and $R$ (right/upper), the interpolated value is a weighted average of the cell-centered values $u_L$ and $u_R$.\n- For a vertical face at $x_f=x_{i+1}$, with cell centers $x_L=x_i^c$ and $x_R=x_{i+1}^c$:\n$$\n\\hat{u}_f = \\frac{x_R - x_f}{x_R - x_L}u_L + \\frac{x_f - x_L}{x_R - x_L}u_R\n$$\nwhere $u_L=u_{i,j}$ and $u_R=u_{i+1,j}$.\n- An analogous formula applies to horizontal faces.\nThe grids are nonuniform, with nodes defined by $x_k = (k/N_x)^2$ and $y_\\ell = (\\ell/N_y)^2$. The sequence of grids is $N_x=N_y=N \\in \\{20, 40, 80, 160\\}$. The cell spacing $\\Delta x_k = x_{k+1}-x_k = (2k+1)/N^2$ is not constant. The maximum spacing, $h$, occurs for the largest index, $k=N-1$, giving $h = (2(N-1)+1)/N^2 = (2N-1)/N^2$. Since the grid transformation is smooth, this linear interpolation scheme is expected to be second-order accurate, yielding $p \\approx 2$.\n\nThe computational procedure involves, for each case:\n1. Looping through the specified grid sizes $N$.\n2. For each $N$, constructing the grid (nodes and cell centers) and computing the mesh parameter $h$.\n3. Evaluating the manufactured solution at all cell centers to get the discrete field $u_{i,j}$.\n4. Iterating over all interior vertical and horizontal faces to compute the sum of squared errors by comparing the interpolated value $\\hat{u}_f$ with the exact value $u(x_f, y_f)$.\n5. Calculating the total error $E$ and storing the pair $(\\log h, \\log E)$.\n6. After processing all grid sizes, performing a linear regression on the stored log-log data to find the slope, which is the observed order of accuracy $p$.", "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef compute_order_of_accuracy(scheme, grid_type, sizes):\n    \"\"\"\n    Computes the observed order of accuracy for a given interpolation scheme.\n\n    Args:\n        scheme (str): The interpolation scheme ('upwind', 'central', 'distance-weighted').\n        grid_type (str): The type of grid ('uniform', 'stretched').\n        sizes (list of int): A list of grid sizes (N x N) for the refinement study.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    exact_sol = lambda x, y: np.exp(x + y)\n    log_h_values = []\n    log_E_values = []\n\n    for N in sizes:\n        Nx = Ny = N\n\n        # 1. Generate Grid and Mesh Parameter h\n        if grid_type == 'uniform':\n            x_nodes = np.linspace(0.0, 1.0, Nx + 1)\n            y_nodes = np.linspace(0.0, 1.0, Ny + 1)\n            h = 1.0 / N\n        elif grid_type == 'stretched':\n            k = np.arange(N + 1)\n            x_nodes = (k / N)**2\n            y_nodes = (k / N)**2\n            h = (2 * N - 1) / N**2\n        else:\n            raise ValueError(\"Unknown grid_type\")\n\n        log_h_values.append(np.log(h))\n\n        x_centers = (x_nodes[:-1] + x_nodes[1:]) / 2.0\n        y_centers = (y_nodes[:-1] + y_nodes[1:]) / 2.0\n\n        # 2. Compute Cell-Centered Values\n        u_cell_centered = exact_sol(x_centers[:, np.newaxis], y_centers[np.newaxis, :])\n\n        # 3. Iterate Over Interior Faces and Calculate Error\n        sum_sq_err = 0.0\n        num_faces = 0\n\n        # Vertical faces\n        for i in range(Nx - 1):\n            for j in range(Ny):\n                x_face = x_nodes[i + 1]\n                y_face = y_centers[j]\n                u_exact = exact_sol(x_face, y_face)\n\n                if scheme == 'upwind':\n                    u_interp = u_cell_centered[i, j]\n                elif scheme == 'central':\n                    u_interp = (u_cell_centered[i, j] + u_cell_centered[i + 1, j]) / 2.0\n                elif scheme == 'distance-weighted':\n                    x_L, x_R = x_centers[i], x_centers[i+1]\n                    u_L, u_R = u_cell_centered[i, j], u_cell_centered[i+1, j]\n                    # Note: x_face == x_nodes[i+1]\n                    # The formula simplifies, but we use the general form for clarity.\n                    weight_R = (x_face - x_L) / (x_R - x_L)\n                    u_interp = (1.0 - weight_R) * u_L + weight_R * u_R\n                else: \n                    raise ValueError(\"Unknown scheme\")\n\n                sum_sq_err += (u_interp - u_exact)**2\n                num_faces += 1\n\n        # Horizontal faces\n        for i in range(Nx):\n            for j in range(Ny - 1):\n                x_face = x_centers[i]\n                y_face = y_nodes[j + 1]\n                u_exact = exact_sol(x_face, y_face)\n\n                if scheme == 'upwind':\n                    u_interp = u_cell_centered[i, j]\n                elif scheme == 'central':\n                    u_interp = (u_cell_centered[i, j] + u_cell_centered[i, j + 1]) / 2.0\n                elif scheme == 'distance-weighted':\n                    y_L, y_R = y_centers[j], y_centers[j+1]\n                    u_L, u_R = u_cell_centered[i, j], u_cell_centered[i, j+1]\n                    weight_R = (y_face - y_L) / (y_R - y_L)\n                    u_interp = (1.0 - weight_R) * u_L + weight_R * u_R\n                else:\n                    raise ValueError(\"Unknown scheme\")\n\n                sum_sq_err += (u_interp - u_exact)**2\n                num_faces += 1\n        \n        # 4. Calculate L2 error E\n        E = np.sqrt(sum_sq_err / num_faces)\n        log_E_values.append(np.log(E))\n\n    # 5. Perform Linear Regression to find order p\n    slope, _, _, _, _ = stats.linregress(log_h_values, log_E_values)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = {\n        'A': {\n            'scheme': 'upwind', \n            'grid_type': 'uniform', \n            'sizes': [16, 32, 64, 128]\n        },\n        'B': {\n            'scheme': 'central', \n            'grid_type': 'uniform', \n            'sizes': [16, 32, 64, 128]\n        },\n        'C': {\n            'scheme': 'distance-weighted', \n            'grid_type': 'stretched', \n            'sizes': [20, 40, 80, 160]\n        }\n    }\n\n    results = []\n    # Sort keys to ensure consistent order [A, B, C]\n    for key in sorted(test_cases.keys()):\n        params = test_cases[key]\n        p = compute_order_of_accuracy(**params)\n        results.append(round(p, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3337129"}]}