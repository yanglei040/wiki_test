{"hands_on_practices": [{"introduction": "The various algorithms in the SIMPLE family are distinguished by the approximations they make to link velocity and pressure corrections. This exercise guides you through a direct analytical derivation to expose the fundamental difference between the standard SIMPLE algorithm and its more consistent variant, SIMPLEC. By comparing their respective velocity correction formulas, you gain insight into why SIMPLEC often exhibits improved convergence behavior.", "problem": "Consider steady, one-dimensional, incompressible flow along the $x$-direction, discretized by the finite volume method on a uniform grid with internal control volume $P$ and its west and east neighbors denoted $W$ and $E$. Let the discretized linearized convection-diffusion form of the $x$-momentum equation at node $P$ be written as \n$$a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$$\nwhere $u_{P}$ is the nodal velocity, $p_{P}$ is the nodal pressure, $a_{P}$, $a_{W}$, and $a_{E}$ are the diagonal and neighbor coefficients arising from the convection-diffusion fluxes, $b$ is a known source contribution, and $S$ is the cross-sectional area of the control volume faces. Suppose a provisional velocity $u^{*}$ and pressure $p^{*}$ have been obtained by solving the momentum equation using a guessed pressure field. Define corrections $u^{\\prime}$ and $p^{\\prime}$ by $u = u^{*} + u^{\\prime}$ and $p = p^{*} + p^{\\prime}$. In the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) and the SIMPLE-Consistent (SIMPLEC) algorithms, the velocity correction $u_{P}^{\\prime}$ is obtained from the momentum correction equation under different consistency assumptions regarding neighbor velocity corrections. Starting from the integral conservation of momentum for a control volume and its standard finite-volume discretization, derive the velocity correction expressions used by SIMPLE and SIMPLEC at node $P$, and then compute the difference between the SIMPLEC-predicted and SIMPLE-predicted velocity corrections at $P$. Assume a slowly varying correction field in one dimension so that $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ and $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$ to leading order. Express your final answer as a single simplified analytic expression in terms of $a_{P}$, $a_{W}$, $a_{E}$, $S$, and $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$. Do not introduce any additional parameters. Your final answer must be a single closed-form expression with no units inside the expression.", "solution": "The problem requires the derivation of velocity correction expressions for the SIMPLE and SIMPLEC algorithms in computational fluid dynamics and the calculation of the difference between these corrections. We begin from the provided discretized momentum equation and the definitions of the correction fields.\n\nThe discretized momentum equation for the true velocity field $u$ and pressure field $p$ at a node $P$ with neighbors $W$ and $E$ is given as:\n$$a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$$\nThis can be written more compactly by summing over the neighbors ($nb$):\n$$a_{P} u_{P} = \\sum_{nb} a_{nb} u_{nb} + b + S \\left( p_{W} - p_{E} \\right)$$\nIn the SIMPLE family of algorithms, a provisional velocity field $u^{*}$ is calculated by solving the momentum equation using a guessed or previous-iteration pressure field $p^{*}$:\n$$a_{P} u_{P}^{*} = \\sum_{nb} a_{nb} u_{nb}^{*} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right)$$\nThe true fields are related to the provisional fields via correction quantities, denoted by a prime ($^{\\prime}$):\n$$u = u^{*} + u^{\\prime}$$\n$$p = p^{*} + p^{\\prime}$$\nSubstituting these definitions into the first equation, we get for node $P$:\n$$a_{P} (u_{P}^{*} + u_{P}^{\\prime}) = \\sum_{nb} a_{nb} (u_{nb}^{*} + u_{nb}^{\\prime}) + b + S \\left( (p_{W}^{*} + p_{W}^{\\prime}) - (p_{E}^{*} + p_{E}^{\\prime}) \\right)$$\nExpanding the terms yields:\n$$a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right) + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\nTo obtain an equation for the corrections, we subtract the equation for the provisional field from this expanded equation. The terms involving $u^{*}$ and $p^{*}$ cancel out:\n$$(a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime}) - (a_{P} u_{P}^{*}) = \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S(p_{W}^{*} - p_{E}^{*}) + S(p_{W}^{\\prime} - p_{E}^{\\prime})\\right) - \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + b + S(p_{W}^{*} - p_{E}^{*})\\right)$$\nThis simplifies to the momentum correction equation:\n$$a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\nIn our one-dimensional case, this is:\n$$a_{P} u_{P}^{\\prime} = a_{W} u_{W}^{\\prime} + a_{E} u_{E}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\nNow, we derive the expressions for the velocity correction $u_{P}^{\\prime}$ based on the specific approximations made by the SIMPLE and SIMPLEC algorithms.\n\n**SIMPLE Algorithm Velocity Correction**\nThe standard SIMPLE algorithm simplifies the momentum correction equation by neglecting the neighbor velocity correction term $\\sum_{nb} a_{nb} u_{nb}^{\\prime}$. This is a significant approximation, based on the assumption that the pressure correction is the primary driver of velocity changes. Applying this to our one-dimensional equation:\n$$a_{P} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\nSolving for the velocity correction at node $P$ gives the SIMPLE prediction:\n$$u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S}{a_{P}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**SIMPLEC Algorithm Velocity Correction**\nThe SIMPLEC (SIMPLE-Consistent) algorithm aims for a more consistent approximation. Instead of completely dropping the neighbor correction term, it approximates it. The problem states to use the assumption of a slowly varying velocity correction field, such that $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ and $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$. We substitute this approximation into the full momentum correction equation:\n$$a_{P} u_{P}^{\\prime} \\approx a_{W} u_{P}^{\\prime} + a_{E} u_{P}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\nNow, we group the terms involving $u_{P}^{\\prime}$ on the left-hand side and solve for $u_{P}^{\\prime}$:\n$$a_{P} u_{P}^{\\prime} - a_{W} u_{P}^{\\prime} - a_{E} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n$$\\left( a_{P} - a_{W} - a_{E} \\right) u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\nThis yields the velocity correction at node $P$ as predicted by SIMPLEC:\n$$u_{P, \\text{SIMPLEC}}^{\\prime} = \\frac{S}{a_{P} - a_{W} - a_{E}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**Difference between SIMPLEC and SIMPLE Corrections**\nFinally, we compute the difference between the SIMPLEC-predicted and SIMPLE-predicted velocity corrections. We use the given definition $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$.\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S \\Delta p^{\\prime}}{a_{P} - a_{W} - a_{E}} - \\frac{S \\Delta p^{\\prime}}{a_{P}}$$\nFactoring out the common term $S \\Delta p^{\\prime}$:\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{1}{a_{P} - a_{W} - a_{E}} - \\frac{1}{a_{P}} \\right)$$\nTo simplify, we combine the fractions inside the parentheses by finding a common denominator, which is $a_{P} (a_{P} - a_{W} - a_{E})$:\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - \\left( a_{P} - a_{W} - a_{E} \\right)}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\nSimplifying the numerator:\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - a_{P} + a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\nThis gives the final simplified analytic expression for the difference in velocity corrections as requested.", "answer": "$$\\boxed{\\frac{S \\Delta p^{\\prime} (a_{W} + a_{E})}{a_{P} (a_{P} - a_{W} - a_{E})}}$$", "id": "3362268"}, {"introduction": "A robust CFD code relies on the correctness of its individual components, and the pressure-correction solver is arguably the most critical. This practice introduces the Method of Manufactured Solutions (MMS), a powerful technique for verifying the accuracy and convergence order of your numerical implementation. You will implement a solver for the pressure-correction equation and use a known analytical solution to confirm that your discretization achieves its theoretical second-order accuracy.", "problem": "Consider steady, two-dimensional, incompressible flow of a Newtonian fluid with constant density $\\rho$ and kinematic viscosity $\\nu$ on the unit square $\\Omega = (0,1)\\times(0,1)$. The governing equations are the steady incompressible Navier–Stokes equations,\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\quad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\nwith no-slip velocity boundary conditions and Dirichlet boundary conditions for the pressure correction on $\\partial\\Omega$ as specified below. Here $\\mathbf{u} = (u,v)$ is the velocity field and $p$ is the pressure.\n\nYou will employ the Method of Manufactured Solutions to construct an exact analytical solution and use it to verify the spatial convergence order of the pressure correction $p'$ computed by three Pressure–Velocity Coupling algorithms: Semi-Implicit Method for Pressure-Linked Equations (SIMPLE), Semi-Implicit Method for Pressure-Linked Equations Revised (SIMPLER), and Semi-Implicit Method for Pressure-Linked Equations Consistent (SIMPLEC).\n\nManufactured analytical solution:\n- Choose the velocity field\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\qquad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\n$$\nwhich satisfies $\\nabla\\cdot\\mathbf{u}=0$ for all $(x,y)\\in\\Omega$. Choose the pressure field\n$$\np(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nwhich satisfies $p(x,y)=0$ on $\\partial\\Omega$. Using these, a body force $\\mathbf{f}(x,y)$ can be constructed that makes $(\\mathbf{u},p)$ an exact solution of the steady equations.\n\nPressure correction equation in the SIMPLE family:\n- In the pressure–velocity coupling framework, the pressure correction $p'$ satisfies a pressure-correction Poisson-type equation that arises from enforcing mass conservation on the predicted mass fluxes. On a uniform grid with central differencing and constant momentum equation diagonals, the pressure correction equation reduces to\n$$\n\\nabla^2 p'(x,y) = s(x,y),\n$$\nwith homogeneous Dirichlet boundary condition $p'(x,y)=0$ on $\\partial\\Omega$. For verification purposes, take the manufactured pressure correction to be $p'(x,y) = p(x,y)$ with a guessed pressure equal to zero, and define the source term consistently by\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nso that the exact solution of the pressure-correction equation is $p'(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$.\n\nYour tasks:\n- Starting from the steady incompressible Navier–Stokes equations and the definition of the pressure correction equation in the SIMPLE family, justify that, under the stated manufactured assumptions (uniform grid, constant coefficients, central differencing, Dirichlet boundary data), the discretized pressure correction equations for SIMPLE, SIMPLER, and SIMPLEC collapse to the same second-order central difference approximation of the scalar Poisson problem for $p'(x,y)$.\n\n- Implement a solver that approximates $p'(x,y)$ on a sequence of uniform Cartesian grids covering $\\Omega$ using second-order central differences. The grids are specified by the number of equal subdivisions per coordinate direction $N\\in\\{8,16,32,64\\}$, so the mesh spacing is $h=1/N$, and the unknowns are located at the $N-1$ interior points in each direction with $p'=0$ on the boundary. Assemble the standard five-point discrete Laplacian and solve the resulting linear system for each $N$.\n\n- For each $N$, compute the discrete $\\ell^2$ error of the numerical solution $p'_h$ with respect to the exact manufactured solution $p'(x,y)$. The discrete $\\ell^2$ error must be defined as\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\nwhere $x_i=i\\,h$ and $y_j=j\\,h$ for $i=1,\\dots,N-1$ and $j=1,\\dots,N-1$.\n\n- For each algorithm variant (SIMPLE, SIMPLER, SIMPLEC), compute the observed convergence order $r$ of $p'$ using the two finest grids by\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)},\n$$\nwith $h=1/32$ and $h/2=1/64$. In this manufactured setting, all three algorithms use the same spatial discretization of the pressure correction equation, hence the observed $r$ values should be equal and close to $2$.\n\nTest suite and output specification:\n- Use the grid sizes $N\\in\\{8,16,32,64\\}$ as the test suite to cover a coarse-grid edge case and progressively refined grids.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$, for example $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$.", "solution": "The governing equations are the steady incompressible Navier–Stokes equations,\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\qquad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f}.\n$$\nWe select the manufactured fields\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\quad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\\quad p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nwhich satisfy incompressibility because\n$$\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n= \\pi\\cos(\\pi x)\\,\\cos(\\pi y) - \\pi\\cos(\\pi x)\\,\\cos(\\pi y) = 0.\n$$\nGiven $\\rho$ and $\\nu$, one can substitute $(\\mathbf{u},p)$ into the momentum equations and compute the body force $\\mathbf{f}(x,y)$ that makes $(\\mathbf{u},p)$ an exact solution; this uses the fundamental base of the governing laws.\n\nPressure–velocity coupling in the Semi-Implicit Method for Pressure-Linked Equations family introduces an intermediate velocity $\\mathbf{u}^*$ computed from a guessed pressure, followed by a pressure correction $p'$ used to correct mass fluxes to satisfy continuity. The correction step satisfies a pressure correction equation derived from the discrete continuity equation and the discrete momentum equations. In general finite-volume form, the discrete pressure correction equation can be written as\n$$\n\\sum_{f\\in \\text{faces}} \\rho\\,d_f\\,\\left(p'_N - p'_P\\right) = \\sum_{f\\in \\text{faces}} \\dot{m}^*_f,\n$$\nwhere $d_f$ are coefficients representative of inverse momentum diagonals and geometric factors, $P$ denotes the cell under consideration, $N$ denotes a neighbor, and $\\dot{m}^*_f$ are the predicted mass fluxes violating continuity. On a uniform grid with constant properties and central differencing, the momentum equation diagonal $a_P$ is constant across cells, the face coefficients $d_f$ become constant, and the discrete divergence of the predicted mass flux reduces to a uniform scaling of the discrete Laplacian of $p'$. Thus, the correction equation simplifies to the scalar Poisson problem\n$$\n\\nabla^2 p'(x,y) = s(x,y)\n$$\nwith homogeneous Dirichlet boundary conditions for $p'$ on $\\partial\\Omega$ when the guessed pressure is zero and the exact pressure vanishes at the boundary. This simplification uses only the core definitions and structure of the algorithms without invoking shortcut formulas. The differences between Semi-Implicit Method for Pressure-Linked Equations (SIMPLE), Semi-Implicit Method for Pressure-Linked Equations Revised (SIMPLER), and Semi-Implicit Method for Pressure-Linked Equations Consistent (SIMPLEC) occur in how the intermediate velocity $\\mathbf{u}^*$ and the coupling coefficients are formed, but in the manufactured uniform-coefficient setting, the spatial discretization of the pressure correction equation is identical among them.\n\nTo manufacture the source term, we take $p'(x,y) = p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$ (consistent with a guessed pressure equal to zero), so that\n$$\n\\nabla^2 p'(x,y) = \\frac{\\partial^2}{\\partial x^2}\\sin(\\pi x)\\,\\sin(\\pi y) + \\frac{\\partial^2}{\\partial y^2}\\sin(\\pi x)\\,\\sin(\\pi y)\n= -\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nand therefore\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n\nWe discretize the Poisson equation on a uniform grid with spacing $h=1/N$ and interior points $(x_i,y_j) = (i h, j h)$ for $i=1,\\dots,N-1$ and $j=1,\\dots,N-1$. The standard second-order central difference approximation to $\\nabla^2 p'$ on a Cartesian grid yields the five-point stencil,\n$$\n\\left(\\nabla^2 p'\\right)_{i,j} \\approx \\frac{p'_{i+1,j} - 2 p'_{i,j} + p'_{i-1,j}}{h^2} + \\frac{p'_{i,j+1} - 2 p'_{i,j} + p'_{i,j-1}}{h^2},\n$$\nwhich provides a second-order approximation in $h$. Applying homogeneous Dirichlet boundary conditions $p'=0$ on $\\partial\\Omega$, the discrete system takes the matrix form\n$$\n\\mathbf{L}\\,\\mathbf{p} = h^2\\,\\mathbf{s},\n$$\nwhere $\\mathbf{L}$ is the discrete two-dimensional Laplacian with the five-point stencil and $\\mathbf{p}$ and $\\mathbf{s}$ are the vectors of unknowns and source values at interior nodes.\n\nThe discrete $\\ell^2$ error is defined by\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\nwhich is a consistent quadrature for the continuum $L^2$ norm. For second-order central differences, the truncation error is $\\mathcal{O}(h^2)$, and for smooth solutions on uniform grids, the discrete solution converges with order $2$ in $h$ under Dirichlet boundary conditions, so we expect\n$$\nE(h) \\approx C\\,h^2\n$$\nfor some constant $C$, leading to the observed convergence order\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)} \\approx 2.\n$$\n\nIn the manufactured setting described, Semi-Implicit Method for Pressure-Linked Equations (SIMPLE), Semi-Implicit Method for Pressure-Linked Equations Revised (SIMPLER), and Semi-Implicit Method for Pressure-Linked Equations Consistent (SIMPLEC) share the same spatial discretization for the pressure correction equation and hence produce identical $p'$ solutions when the linear system is solved to convergence. Therefore, computing $E(h)$ for $h=1/32$ and $h/2=1/64$ and forming $r$ as above should yield three equal values close to $2$. The implementation uses the Kronecker-sum construction of the two-dimensional discrete Laplacian and a direct sparse linear solver to eliminate iterative effects and isolate the spatial discretization error, aligning with the principle-based derivation and verification task.\n\nThe program evaluates the errors for $N\\in\\{8,16,32,64\\}$ and reports the three observed orders $[r_{\\text{SIMPLE}}, r_{\\text{SIMPLER}}, r_{\\text{SIMPLEC}}]$ computed from the two finest grids, thereby verifying second-order convergence of $p'$ under grid refinement for all three algorithms in this manufactured, uniform-coefficient limit.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef build_poisson_matrix(m):\n    \"\"\"\n    Build the 2D Poisson matrix with Dirichlet boundary conditions\n    on an m x m interior grid using the 5-point Laplacian.\n    \"\"\"\n    # 1D Laplacian (Dirichlet interior nodes): tridiagonal [-1, 2, -1]\n    main = -2.0 * np.ones(m)\n    off = 1.0 * np.ones(m - 1)\n    L1 = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(m, format='csr')\n    # 2D Laplacian via Kronecker sum\n    L2 = kron(I, L1) + kron(L1, I)\n    return L2\n\ndef manufactured_source_and_exact(N):\n    \"\"\"\n    Compute source term s(x,y) = 2*pi^2*sin(pi*x)*sin(pi*y)\n    and exact p'(x,y) at interior points for grid size N (spacing h=1/N).\n    Returns (s_flat, p_exact_flat).\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    x = np.linspace(h, 1.0 - h, m)\n    y = np.linspace(h, 1.0 - h, m)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    p_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    s = 2.0 * (np.pi ** 2) * p_exact\n    return s.ravel(), p_exact.ravel()\n\ndef solve_poisson(N):\n    \"\"\"\n    Solve L p = h^2 * s for p on interior grid for given N,\n    with exact source manufactured from p'(x,y) = sin(pi*x)*sin(pi*y).\n    Returns L2 error E(h) with discrete quadrature.\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    L = build_poisson_matrix(m)\n    s_flat, p_exact_flat = manufactured_source_and_exact(N)\n    rhs = (h ** 2) * s_flat\n    p_num = spsolve(L, rhs)\n    # Discrete L2 error: sqrt(sum((error)^2)) * h\n    err = p_num - p_exact_flat\n    E = np.sqrt(np.sum(err ** 2)) * h\n    return E\n\ndef observed_order(e_h, e_h2):\n    \"\"\"\n    Compute observed order r = log(e_h/e_h2)/log(2),\n    where h2 = h/2 (i.e., N doubled).\n    \"\"\"\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    grid_sizes = [8, 16, 32, 64]\n\n    # Compute errors for each grid size.\n    errors = {}\n    for N in grid_sizes:\n        errors[N] = solve_poisson(N)\n\n    # Compute observed order using the two finest grids N=32 and N=64.\n    e32 = errors[32]\n    e64 = errors[64]\n    r = observed_order(e32, e64)\n\n    # In this manufactured uniform-coefficient setting, SIMPLE, SIMPLER, and SIMPLEC\n    # produce identical spatial discretizations for the pressure correction equation,\n    # hence identical observed orders.\n    results = [r, r, r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362285"}, {"introduction": "In incompressible flow, the absolute pressure is arbitrary; only its gradient matters. This physical reality creates a numerical challenge: the pressure-correction equation often has a nullspace, leading to a \"floating\" pressure that can cause solver instability. This exercise simulates this common problem and tasks you with implementing and evaluating standard techniques, such as pressure anchoring and mean-value constraints, to stabilize the solution.", "problem": "Consider a two-dimensional, steady, incompressible flow on a unit square domain $\\Omega = [0,1] \\times [0,1]$. The governing constraint is the continuity equation $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mathbf{u} = (u_x, u_y)$ is the velocity field. In the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE) family of algorithms (which includes SIMPLE-Revised (SIMPLER) and SIMPLE-Consistent (SIMPLEC)), a tentative velocity $\\mathbf{u}^*$ is corrected via a pressure correction $p'$ such that the corrected velocity is $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* + \\mathbf{u}'$, and continuity is approximately enforced by a relation of the form $\\mathbf{u}' \\approx -\\kappa \\nabla p'$, where $\\kappa  0$ is a constant linking pressure gradients to velocity corrections obtained from the linearized momentum equations. The pressure correction $p'$ is obtained by solving a Poisson-type equation that arises from inserting $\\mathbf{u}^{\\text{new}}$ into the continuity condition. For purely Neumann boundary conditions on $p'$ (zero normal gradient), the discrete operator for $p'$ possesses a nullspace containing constants. Without a pressure reference, $p'$ can float by an arbitrary additive constant, and if the domain-integral of the source term is non-zero due to modeling or discretization defects, a drift can occur during iterative solution.\n\nYour task is to implement the following scenario in a program using a uniform Cartesian grid of $N \\times N$ nodes on $\\Omega$:\n\n- Use a uniform spacing $h = 1/(N-1)$ and node coordinates $(x_i,y_j)$ with $x_i = i h$ and $y_j = j h$ for all integers $i,j$ satisfying $0 \\leq i,j \\leq N-1$.\n- Construct a tentative velocity $\\mathbf{u}^*$ as a superposition of a divergence-free component obtained from a streamfunction $\\psi(x,y)$ and a compressible defect:\n  - Let $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$, and define the divergence-free base velocity $\\mathbf{u}^{\\text{df}} = (\\partial \\psi / \\partial y, -\\partial \\psi / \\partial x)$.\n  - Define a compressible defect $\\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0)$ where $\\varepsilon  0$ is a small amplitude.\n  - Set $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$.\n- Compute the discrete divergence on the grid to form the source term $f = \\nabla \\cdot \\mathbf{u}^*$ using second-order central differences in the interior and mirrored (Neumann) boundary treatment for differences at the boundary.\n- Form the discrete Poisson equation for $p'$ using the standard five-point Laplacian stencil with mirrored (Neumann) boundary conditions. Use a Jacobi iteration to update $p'$:\n  - For interior points, the update is based on the average of neighbors minus $h^2 f / 4$.\n  - At boundaries, implement a mirrored neighbor treatment consistent with $\\partial p'/\\partial n = 0$.\n- Implement three algorithmic variants of the pressure correction solve:\n  $1$) Floating $p'$ with no pressure reference or constraint.\n  $2$) Constrained $p'$ with a zero-mean condition imposed discretely at every iteration, i.e., enforce $\\sum_{i,j} p'_{i,j} h^2 = 0$, which is the discrete form of $\\int_{\\Omega} p' \\, dV = 0$.\n  $3$) Single-cell anchoring where a specific cell (e.g., $(i,j) = (0,0)$) is constrained by setting $p'_{0,0} = 0$ at every iteration.\n\nTo analyze drift and convergence behavior under an incorrect pressure reference, perturb the source term $f$ by a constant offset $m$ so that $f \\leftarrow f + m$, with $m$ possibly non-zero. This models an inconsistency where the domain-integral of the source is not zero, which interacts with the nullspace of the Neumann Laplacian.\n\nFor each variant, compute:\n- The final mean of $p'$ (discrete integral divided by area), which quantifies the pressure drift (dimensionless).\n- The final residual norm $\\|\\Delta_h p' - f\\|_2$ of the discrete Poisson equation, where $\\Delta_h$ is the discrete Laplacian (dimensionless).\n- The impact on the velocity by computing the corrected velocity $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$ using central differences for $\\nabla_h$, then measure the discrete $L^2$ norm of $\\nabla \\cdot \\mathbf{u}^{\\text{new}}$ (dimensionless).\n- The number of iterations taken to reach a target residual tolerance or, if not reached, the maximum iterations performed (integer count).\n\nUse the following constants and numerical choices:\n- Take $\\kappa = 1$.\n- Initialize $p'$ to zero everywhere.\n- Use Jacobi iteration with no over-relaxation.\n- Define the residual tolerance as $\\text{tol} = 10^{-8}$ and the maximum number of iterations as $2000$.\n\nDesign a test suite to exercise distinct behaviors:\n- Case A (happy path with observable drift): $N = 32$, $\\varepsilon = 0.2$, $m = 10^{-3}$, floating $p'$ (no constraint).\n- Case B (constraint removes drift): $N = 32$, $\\varepsilon = 0.2$, $m = 10^{-3}$, constrained zero-mean $p'$.\n- Case C (anchored reference cell): $N = 32$, $\\varepsilon = 0.2$, $m = 10^{-3}$, single-cell anchoring at $(0,0)$.\n- Case D (compatible source, tests nullspace without forcing): $N = 32$, $\\varepsilon = 0.2$, $m = 0$, floating $p'$.\n\nAll quantities are non-dimensional; report all outputs as floats except the iteration count, which is an integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of four values ordered as $[\\text{mean}(p'), \\|\\Delta_h p' - f\\|_2, \\|\\nabla \\cdot \\mathbf{u}^{\\text{new}}\\|_2, \\text{iterations}]$. For example, the format is $[[r_{A1}, r_{A2}, r_{A3}, r_{A4}], [r_{B1}, r_{B2}, r_{B3}, r_{B4}], [r_{C1}, r_{C2}, r_{C3}, r_{C4}], [r_{D1}, r_{D2}, r_{D3}, r_{D4}]]$.", "solution": "The problem requires an analysis of pressure-correction methods for incompressible flows, specifically focusing on the numerical stability of solving the pressure-correction Poisson equation under pure Neumann boundary conditions. The core of the task is to implement a numerical simulation that demonstrates how different stabilization techniques handle the nullspace (constant-valued functions) of the discrete Neumann-Laplace operator, particularly when the source term is inconsistent (i.e., its domain integral is non-zero).\n\nThe solution is developed through the following steps:\n\n1.  **Discretization and Field Definition**:\n    The continuous domain $\\Omega = [0,1] \\times [0,1]$ is discretized into a uniform Cartesian grid of $N \\times N$ nodes. The grid spacing is $h = 1/(N-1)$. Node coordinates are $(x_i, y_j)$ where $x_i = i h$ and $y_j = j h$ for integers $i,j$ from $0$ to $N-1$.\n    A tentative velocity field $\\mathbf{u}^* = (u_x^*, u_y^*)$ is constructed on this grid. It comprises a divergence-free part $\\mathbf{u}^{\\text{df}}$ derived from a streamfunction $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$, and a compressible defect $\\mathbf{u}^{\\text{c}}$:\n    $$ \\mathbf{u}^{\\text{df}} = \\left( \\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x} \\right) = (2\\pi \\sin(2\\pi x)\\cos(2\\pi y), -2\\pi \\cos(2\\pi x)\\sin(2\\pi y)) $$\n    $$ \\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0) $$\n    The resulting tentative velocity is $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$.\n\n2.  **Source Term Formulation**:\n    The pressure correction $p'$ must satisfy a Poisson equation $\\Delta p' = f$, where the source term $f$ is the divergence of the tentative velocity, $f = \\nabla \\cdot \\mathbf{u}^*$. Analytically, $\\nabla \\cdot \\mathbf{u}^{\\text{df}} = 0$, so the divergence is solely due to the defect: $f = \\nabla \\cdot \\mathbf{u}^{\\text{c}} = \\varepsilon \\pi \\cos(\\pi x) \\sin(\\pi y)$.\n    The problem specifies computing $f$ discretely using a second-order central difference operator, denoted $\\nabla_h \\cdot$. For a vector field $\\mathbf{q}=(q_x, q_y)$, its divergence at node $(i,j)$ is:\n    $$ (\\nabla_h \\cdot \\mathbf{q})_{i,j} = \\frac{q_{x,i+1,j} - q_{x,i-1,j}}{2h} + \\frac{q_{y,i,j+1} - q_{y,i,j-1}}{2h} $$\n    At the boundaries, a mirrored (zero-Neumann) boundary treatment is used. This is implemented using ghost points, where the value of a field at a ghost point is a symmetric reflection of its corresponding interior point (e.g., $q_{x,-1,j} = q_{x,1,j}$). This method is consistently applied to all discrete differential operators.\n\n3.  **Pressure-Correction Poisson Equation**:\n    We solve the discrete Poisson equation $\\Delta_h p' = f$, where $\\Delta_h$ is the standard five-point stencil for the Laplacian operator, consistent with the zero-Neumann boundary condition $\\partial p'/\\partial n = 0$. The update rule for a Jacobi iteration at step $k+1$ is:\n    $$ p'^{(k+1)}_{i,j} = \\frac{1}{4} \\left( p'^{(k)}_{i+1,j} + p'^{(k)}_{i-1,j} + p'^{(k)}_{i,j+1} + p'^{(k)}_{i,j-1} - h^2 f_{i,j} \\right) $$\n    The mirrored boundary condition is handled with ghost points, for instance at the boundary $i=0$:\n    $$ p'^{(k+1)}_{0,j} = \\frac{1}{4} \\left( 2p'^{(k)}_{1,j} + p'^{(k)}_{0,j+1} + p'^{(k)}_{0,j-1} - h^2 f_{0,j} \\right) $$\n    The source term $f$ is perturbed by a constant offset $m$, so the equation becomes $\\Delta_h p' = f + m$. This models a common numerical situation where the discrete source term does not sum to zero, i.e., $\\sum_{i,j} (f_{i,j}+m)h^2 \\neq 0$. This violates the solvability condition for the Neumann-Poisson problem, as the integral of the Laplacian's output is always zero by the divergence theorem.\n\n4.  **Handling the Nullspace**:\n    The discrete operator $\\Delta_h$ with Neumann boundary conditions has a nullspace consisting of constant fields. This means if $p'$ is a solution, so is $p' + C$ for any constant $C$. If the source is incompatible (non-zero integral), the iterative solution will typically diverge or drift. Three variants are implemented to manage this:\n    - **Floating $p'$**: No constraints are applied. With an incompatible source ($m \\neq 0$), the mean of $p'$ is expected to drift indefinitely.\n    - **Constrained $p'$**: A zero-mean condition, $\\sum_{i,j} p'_{i,j} h^2 = 0$, is enforced at every iteration. This is achieved by calculating the arithmetic mean of the updated pressure field and subtracting it from every point: $p' \\leftarrow p' - \\text{mean}(p')$. This stabilizes the mean value but does not resolve the underlying incompatibility, preventing convergence to the specified tolerance.\n    - **Single-cell Anchoring**: The pressure at a single cell, $p'_{0,0}$, is fixed to $0$ at every iteration. This removes the constant-offset degree of freedom, making the linear system non-singular and ensuring convergence to a unique solution, even with an incompatible source.\n\n5.  **Metrics Calculation**:\n    After the iterative solver either converges to a tolerance of $\\text{tol} = 10^{-8}$ or reaches the maximum of $2000$ iterations, four metrics are computed:\n    - **Mean of $p'$**: The arithmetic mean of the final pressure field, $\\frac{1}{N^2}\\sum_{i,j}p'_{i,j}$.\n    - **Residual Norm**: The discrete $L^2$ norm of the final residual, $\\|\\Delta_h p' - (f+m)\\|_2 = \\sqrt{\\sum_{i,j} (\\Delta_h p'_{i,j} - (f_{i,j}+m))^2}$.\n    - **Corrected Velocity Divergence Norm**: The new velocity field $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$ is computed, where $\\kappa=1$ and $\\nabla_h$ is the discrete gradient operator (using central differences and mirrored boundaries). The $L^2$ norm of its divergence, $\\|\\nabla_h \\cdot \\mathbf{u}^{\\text{new}}\\|_2$, is then calculated.\n    - **Iterations**: The number of Jacobi iterations performed.\n\nThe implementation encapsulates this logic, systematically applying it to the four specified test cases, each designed to highlight a different aspect of the numerical behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa):\n    \"\"\"\n    Runs a single simulation case for the pressure-correction Poisson problem.\n\n    Args:\n        N (int): Number of grid points in each dimension.\n        epsilon (float): Amplitude of the compressible defect.\n        m (float): Constant offset for the source term.\n        constraint_type (str): Type of constraint ('floating', 'mean_zero', 'anchor').\n        tol (float): Convergence tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n        kappa (float): Proportionality constant for pressure correction.\n\n    Returns:\n        list: A list containing [final_p_mean, residual_norm, div_u_new_norm, iterations].\n    \"\"\"\n    # 1. Grid and Coordinates\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # 'ij' indexing ensures xx[i, j] = x[i] and yy[i, j] = y[j]\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Velocity Field Construction\n    # Divergence-free component from streamfunction\n    ux_df = 2 * np.pi * np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy)\n    uy_df = -2 * np.pi * np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n\n    # Compressible defect\n    ux_c = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    uy_c = np.zeros_like(yy)\n\n    # Tentative velocity u*\n    ux_star = ux_df + ux_c\n    uy_star = uy_df + uy_c\n\n    # Helper functions for discrete operators with mirrored Neumann boundaries\n    def discr_divergence(u, v, h_val):\n        u_padded = np.pad(u, 1, mode='symmetric')\n        v_padded = np.pad(v, 1, mode='symmetric')\n        du_dx = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2 * h_val)\n        dv_dy = (v_padded[1:-1, 2:] - v_padded[1:-1, :-2]) / (2 * h_val)\n        return du_dx + dv_dy\n\n    def discr_gradient(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        dp_dx = (p_padded[2:, 1:-1] - p_padded[:-2, 1:-1]) / (2 * h_val)\n        dp_dy = (p_padded[1:-1, 2:] - p_padded[1:-1, :-2]) / (2 * h_val)\n        return dp_dx, dp_dy\n\n    def discr_laplacian(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        lap_p = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p) / h_val**2\n        return lap_p\n\n    # 3. Source Term Calculation\n    f = discr_divergence(ux_star, uy_star, h)\n    f += m  # Add perturbation\n\n    # 4. Jacobi Iteration for the Poisson equation\n    p_prime = np.zeros((N, N))\n    iterations = 0\n    residual_norm = np.inf\n\n    for k in range(max_iter):\n        iterations = k + 1\n        \n        # Jacobi update step\n        p_padded = np.pad(p_prime, 1, mode='symmetric')\n        p_new = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - h**2 * f) / 4.0\n        \n        # 5. Apply constraints based on the variant\n        if constraint_type == 'mean_zero':\n            p_new -= np.mean(p_new)\n        elif constraint_type == 'anchor':\n            p_new[0, 0] = 0.0\n        # For 'floating', no action is taken.\n        \n        p_prime = p_new\n\n        # Check for convergence based on the L2 norm of the residual\n        residual = discr_laplacian(p_prime, h) - f\n        residual_norm = np.linalg.norm(residual)\n        if residual_norm  tol:\n            break\n            \n    # 6. Post-Processing and Metrics Calculation\n    final_p_mean = np.mean(p_prime)\n    \n    # Corrected velocity divergence calculation\n    dp_dx, dp_dy = discr_gradient(p_prime, h)\n    ux_new = ux_star - kappa * dp_dx\n    uy_new = uy_star - kappa * dp_dy\n    \n    div_u_new = discr_divergence(ux_new, uy_new, h)\n    div_u_new_norm = np.linalg.norm(div_u_new)\n\n    return [final_p_mean, residual_norm, div_u_new_norm, int(iterations)]\n\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, m, constraint_type)\n        (32, 0.2, 1e-3, 'floating'),     # Case A\n        (32, 0.2, 1e-3, 'mean_zero'),   # Case B\n        (32, 0.2, 1e-3, 'anchor'),       # Case C\n        (32, 0.2, 0.0, 'floating'),      # Case D\n    ]\n\n    # Global constants for the simulation\n    tol = 1e-8\n    max_iter = 2000\n    kappa = 1.0\n    \n    results = []\n    for N, epsilon, m, constraint_type in test_cases:\n        result = run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362264"}]}