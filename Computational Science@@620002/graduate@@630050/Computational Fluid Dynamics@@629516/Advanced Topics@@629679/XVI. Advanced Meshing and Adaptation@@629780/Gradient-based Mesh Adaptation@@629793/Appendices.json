{"hands_on_practices": [{"introduction": "The first step in any mesh adaptation process is to identify where the numerical solution is least accurate. This exercise provides a concrete, first-principles calculation of a gradient-based error indicator for a single finite element [@problem_id:3325351]. By comparing the gradient of the exact analytical solution to that of its simple linear interpolation, you will quantify the local approximation error and use it to predict where mesh refinement is most needed, forming the foundational skill for error estimation.", "problem": "Consider a single triangular finite element with vertices ordered counterclockwise at $\\mathbf{x}_1=(0,0)$, $\\mathbf{x}_2=(1,0)$, and $\\mathbf{x}_3=(0,1)$ in the plane. Let the scalar field be $u(x,y)=\\exp(x)\\sin(y)$, and let $u_h$ be the nodal interpolant in the space of affine linear polynomials (also called $\\mathbb{P}_1$ finite elements) constructed from the pointwise samples $u(\\mathbf{x}_i)$ at the three vertices.\n\nUsing only foundational definitions from interpolation theory and vector calculus, perform the following tasks:\n\n1. Define the elementwise gradient-based error indicator $\\eta_K$ by approximating the $L^2$ norm of the gradient error over the element $K$ via first-order centroid quadrature. That is, treat the integral of the squared gradient error over $K$ as the element area times the squared pointwise error of the gradient at the centroid. Then derive and compute the numerical value of $\\eta_K$ for this element.\n\n2. For anisotropic refinement driven by the magnitude of the directional derivative across each edge, predict which edge should be refined most intensely. For an edge $e$ with outward unit normal $\\mathbf{n}_e$, the across-edge directional derivative at the element centroid $\\mathbf{x}_c$ is the scalar $|\\nabla u(\\mathbf{x}_c)\\cdot \\mathbf{n}_e|$. Use the absolute value to remove any dependence on the choice of normal orientation. Enumerate edges as $e_1=\\overline{\\mathbf{x}_1\\mathbf{x}_2}$, $e_2=\\overline{\\mathbf{x}_2\\mathbf{x}_3}$, and $e_3=\\overline{\\mathbf{x}_3\\mathbf{x}_1}$, and select the index $k\\in\\{1,2,3\\}$ attaining the maximum.\n\nReport your final answer as a $1\\times 2$ row matrix containing:\n- the value of $\\eta_K$ (dimensionless), rounded to $4$ significant figures, followed by\n- the edge index $k$ as an integer.\n\nNo units should be included in the final boxed answer.", "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\nThe givens are:\n- A triangular finite element $K$ with vertices $\\mathbf{x}_1=(0,0)$, $\\mathbf{x}_2=(1,0)$, and $\\mathbf{x}_3=(0,1)$.\n- A scalar field $u(x,y)=\\exp(x)\\sin(y)$.\n- The nodal interpolant $u_h$ is a $\\mathbb{P}_1$ polynomial.\n- The isotropic error indicator is defined as $\\eta_K = \\left( |K| \\cdot |\\nabla u(\\mathbf{x}_c) - \\nabla u_h(\\mathbf{x}_c)|^2 \\right)^{1/2}$, where $|K|$ is the area of the triangle and $\\mathbf{x}_c$ is its centroid.\n- The anisotropic refinement criterion for an edge $e$ is $|\\nabla u(\\mathbf{x}_c)\\cdot \\mathbf{n}_e|$, where $\\mathbf{n}_e$ is the outward unit normal.\n- The edges are enumerated as $e_1=\\overline{\\mathbf{x}_1\\mathbf{x}_2}$, $e_2=\\overline{\\mathbf{x}_2\\mathbf{x}_3}$, and $e_3=\\overline{\\mathbf{x}_3\\mathbf{x}_1}$.\n\nThe problem is a standard exercise in the field of a posteriori error estimation for the finite element method. All terms are well-defined, the functions are smooth, and the geometry is simple. The problem is based on established principles of numerical analysis and vector calculus. Hence, the problem is valid.\n\nWe will solve the two parts of the problem sequentially.\n\n**Part 1: Calculation of the error indicator $\\eta_K$**\n\nFirst, we determine the geometric properties of the triangular element $K$. The vertices are $\\mathbf{x}_1=(0,0)$, $\\mathbf{x}_2=(1,0)$, and $\\mathbf{x}_3=(0,1)$. This is a right-angled triangle.\nThe area of the element, $|K|$, is given by $|K| = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$.\nThe centroid of the triangle, $\\mathbf{x}_c$, is the average of its vertices' coordinates:\n$$\n\\mathbf{x}_c = \\frac{1}{3}(\\mathbf{x}_1 + \\mathbf{x}_2 + \\mathbf{x}_3) = \\frac{1}{3}((0,0) + (1,0) + (0,1)) = \\left(\\frac{1}{3}, \\frac{1}{3}\\right)\n$$\n\nNext, we compute the gradient of the true scalar field $u(x,y) = \\exp(x)\\sin(y)$.\n$$\n\\nabla u(x,y) = \\left(\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}\\right) = (\\exp(x)\\sin(y), \\exp(x)\\cos(y))\n$$\nWe evaluate this gradient at the element centroid $\\mathbf{x}_c = (1/3, 1/3)$:\n$$\n\\nabla u(\\mathbf{x}_c) = \\left(\\exp\\left(\\frac{1}{3}\\right)\\sin\\left(\\frac{1}{3}\\right), \\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right)\\right)\n$$\n\nNow, we must find the $\\mathbb{P}_1$ nodal interpolant $u_h(x,y)$. A $\\mathbb{P}_1$ function is an affine linear polynomial of the form $u_h(x,y) = a + bx + cy$. Its coefficients are determined by enforcing that $u_h$ matches $u$ at the vertices.\nThe nodal values of $u$ are:\n$u_1 = u(\\mathbf{x}_1) = u(0,0) = \\exp(0)\\sin(0) = 0$.\n$u_2 = u(\\mathbf{x}_2) = u(1,0) = \\exp(1)\\sin(0) = 0$.\n$u_3 = u(\\mathbf{x}_3) = u(0,1) = \\exp(0)\\sin(1) = \\sin(1)$.\n\nThe interpolant $u_h$ can be written using the linear basis functions $\\phi_i$ of the triangle:\n$u_h(x,y) = u_1 \\phi_1(x,y) + u_2 \\phi_2(x,y) + u_3 \\phi_3(x,y)$.\nFor this reference triangle, the basis functions are $\\phi_1(x,y) = 1-x-y$, $\\phi_2(x,y) = x$, and $\\phi_3(x,y) = y$.\nSubstituting the nodal values:\n$$\nu_h(x,y) = 0 \\cdot (1-x-y) + 0 \\cdot x + \\sin(1) \\cdot y = y\\sin(1)\n$$\nThe gradient of the interpolant $\\nabla u_h$ is constant over the element:\n$$\n\\nabla u_h(x,y) = \\left(\\frac{\\partial}{\\partial x}(y\\sin(1)), \\frac{\\partial}{\\partial y}(y\\sin(1))\\right) = (0, \\sin(1))\n$$\nSince $\\nabla u_h$ is constant, its value at the centroid $\\mathbf{x}_c$ is $\\nabla u_h(\\mathbf{x}_c) = (0, \\sin(1))$.\n\nNow we compute the gradient error vector at the centroid:\n$$\n\\nabla u(\\mathbf{x}_c) - \\nabla u_h(\\mathbf{x}_c) = \\left(\\exp\\left(\\frac{1}{3}\\right)\\sin\\left(\\frac{1}{3}\\right), \\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right) - \\sin(1)\\right)\n$$\nThe squared magnitude of this vector is:\n$$\n|\\nabla u(\\mathbf{x}_c) - \\nabla u_h(\\mathbf{x}_c)|^2 = \\left(\\exp\\left(\\frac{1}{3}\\right)\\sin\\left(\\frac{1}{3}\\right)\\right)^2 + \\left(\\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right) - \\sin(1)\\right)^2\n$$\n$$\n= \\exp\\left(\\frac{2}{3}\\right)\\sin^2\\left(\\frac{1}{3}\\right) + \\exp\\left(\\frac{2}{3}\\right)\\cos^2\\left(\\frac{1}{3}\\right) - 2\\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right)\\sin(1) + \\sin^2(1)\n$$\n$$\n= \\exp\\left(\\frac{2}{3}\\right)\\left(\\sin^2\\left(\\frac{1}{3}\\right) + \\cos^2\\left(\\frac{1}{3}\\right)\\right) - 2\\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right)\\sin(1) + \\sin^2(1)\n$$\n$$\n= \\exp\\left(\\frac{2}{3}\\right) - 2\\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right)\\sin(1) + \\sin^2(1)\n$$\nThe error indicator $\\eta_K$ is defined as:\n$$\n\\eta_K = \\sqrt{|K|} \\cdot |\\nabla u(\\mathbf{x}_c) - \\nabla u_h(\\mathbf{x}_c)| = \\sqrt{\\frac{1}{2}} \\sqrt{\\exp\\left(\\frac{2}{3}\\right) - 2\\exp\\left(\\frac{1}{3}\\right)\\cos\\left(\\frac{1}{3}\\right)\\sin(1) + \\sin^2(1)}\n$$\nWe now compute the numerical value (using radians for trigonometric functions):\n$\\exp(2/3) \\approx 1.947734$\n$2\\exp(1/3)\\cos(1/3)\\sin(1) \\approx 2 \\cdot (1.395612) \\cdot (0.944957) \\cdot (0.841471) \\approx 2.219516$\n$\\sin^2(1) \\approx (0.841471)^2 \\approx 0.708073$\nSo, the term inside the square root is approximately $1.947734 - 2.219516 + 0.708073 \\approx 0.436291$.\n$$\n\\eta_K \\approx \\sqrt{\\frac{1}{2} \\cdot 0.436291} = \\sqrt{0.2181455} \\approx 0.4670609\n$$\nRounded to $4$ significant figures, $\\eta_K \\approx 0.4671$.\n\n**Part 2: Identification of the edge for refinement**\n\nWe need to compute the indicator $|\\nabla u(\\mathbf{x}_c)\\cdot \\mathbf{n}_e|$ for each edge $e \\in \\{e_1, e_2, e_3\\}$. The vertices are ordered counter-clockwise.\nThe edge vectors are:\n$e_1 = \\overline{\\mathbf{x}_1\\mathbf{x}_2}$: vector $\\mathbf{v}_1 = \\mathbf{x}_2 - \\mathbf{x}_1 = (1,0)$.\n$e_2 = \\overline{\\mathbf{x}_2\\mathbf{x}_3}$: vector $\\mathbf{v}_2 = \\mathbf{x}_3 - \\mathbf{x}_2 = (-1,1)$.\n$e_3 = \\overline{\\mathbf{x}_3\\mathbf{x}_1}$: vector $\\mathbf{v}_3 = \\mathbf{x}_1 - \\mathbf{x}_3 = (0,-1)$.\n\nThe corresponding outward unit normal vectors $\\mathbf{n}_e$ are found by rotating the edge vectors by $-90^\\circ$ (which maps a vector $(a,b)$ to $(b,-a)$) and normalizing.\nFor $e_1$: The normal direction is $(0,-1)$. This is already a unit vector. So, $\\mathbf{n}_{e_1} = (0,-1)$.\nFor $e_2$: The normal direction is $(1,1)$. The length is $\\sqrt{1^2+1^2}=\\sqrt{2}$. So, $\\mathbf{n}_{e_2} = (1/\\sqrt{2}, 1/\\sqrt{2})$.\nFor $e_3$: The normal direction is $(-1,0)$. This is already a unit vector. So, $\\mathbf{n}_{e_3} = (-1,0)$.\n\nNow we compute the dot product of the gradient $\\nabla u(\\mathbf{x}_c) = (\\exp(1/3)\\sin(1/3), \\exp(1/3)\\cos(1/3))$ with each normal vector.\nLet $g_x = \\exp(1/3)\\sin(1/3)$ and $g_y = \\exp(1/3)\\cos(1/3)$.\n$\\nabla u(\\mathbf{x}_c) = (g_x, g_y)$.\n\nFor edge $e_1$:\n$\\text{Indicator}_1 = |\\nabla u(\\mathbf{x}_c) \\cdot \\mathbf{n}_{e_1}| = |(g_x, g_y) \\cdot (0, -1)| = |-g_y| = g_y = \\exp(1/3)\\cos(1/3)$.\n$\\text{Indicator}_1 \\approx 1.395612 \\cdot 0.944957 \\approx 1.31876$.\n\nFor edge $e_2$:\n$\\text{Indicator}_2 = |\\nabla u(\\mathbf{x}_c) \\cdot \\mathbf{n}_{e_2}| = |(g_x, g_y) \\cdot (1/\\sqrt{2}, 1/\\sqrt{2})| = \\frac{1}{\\sqrt{2}}|g_x+g_y|$. Since $g_x, g_y > 0$, this is $\\frac{1}{\\sqrt{2}}(g_x+g_y)$.\n$\\text{Indicator}_2 = \\frac{\\exp(1/3)}{\\sqrt{2}}(\\sin(1/3) + \\cos(1/3))$.\n$\\text{Indicator}_2 \\approx \\frac{1.395612}{\\sqrt{2}}(0.327195 + 0.944957) \\approx 0.986845 \\cdot 1.272152 \\approx 1.25544$.\n\nFor edge $e_3$:\n$\\text{Indicator}_3 = |\\nabla u(\\mathbf{x}_c) \\cdot \\mathbf{n}_{e_3}| = |(g_x, g_y) \\cdot (-1, 0)| = |-g_x| = g_x = \\exp(1/3)\\sin(1/3)$.\n$\\text{Indicator}_3 \\approx 1.395612 \\cdot 0.327195 \\approx 0.45659$.\n\nComparing the three values:\n$\\text{Indicator}_1 \\approx 1.31876$\n$\\text{Indicator}_2 \\approx 1.25544$\n$\\text{Indicator}_3 \\approx 0.45659$\nThe maximum value is $\\text{Indicator}_1$, which corresponds to edge $e_1$. Therefore, the index of the edge that should be refined most intensely is $k=1$.\n\nThe final answer consists of the numerical value of $\\eta_K$ rounded to $4$ significant figures and the edge index $k$.\n$\\eta_K \\approx 0.4671$\n$k = 1$\nThese are to be reported as a $1 \\times 2$ row matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4671 & 1\n\\end{pmatrix}\n}\n$$", "id": "3325351"}, {"introduction": "Once an error distribution is known, it is encoded into a Riemannian metric tensor field, which specifies the ideal size, shape, and orientation of elements throughout the domain. This practice [@problem_id:3325366] bridges the gap between the abstract concept of a metric and its practical application by having you evaluate how well a given tetrahedral element conforms to a prescribed metric. You will compute the \"metric length\" of each edge to see how far it deviates from the ideal of unity, a core analysis task in any modern adaptation software.", "problem": "In Computational Fluid Dynamics (CFD), gradient-based mesh adaptation uses a Riemannian metric tensor to control anisotropic resolution. Consider a tetrahedral element with vertices labeled $1$, $2$, $3$, and $4$, having physical coordinates\n$$\n\\mathbf{x}_1 = (0, 0, 0), \\quad \\mathbf{x}_2 = (1, 0, 0), \\quad \\mathbf{x}_3 = (0.2, 1.1, 0), \\quad \\mathbf{x}_4 = (0, 0.3, 0.9).\n$$\nAt each vertex $i$, a symmetric positive-definite Riemannian metric tensor $M_i$ is prescribed, representing the local desired resolution, given by\n$$\nM_1 = \\begin{pmatrix}4 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1\\end{pmatrix}, \\quad\nM_2 = \\begin{pmatrix}2.5 & 0 & 0 \\\\ 0 & 1.5 & 0 \\\\ 0 & 0 & 1\\end{pmatrix}, \\quad\nM_3 = \\begin{pmatrix}3 & 0 & 0 \\\\ 0 & 0.8 & 0 \\\\ 0 & 0 & 1.2\\end{pmatrix}, \\quad\nM_4 = \\begin{pmatrix}2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 2.2\\end{pmatrix}.\n$$\nThe fundamental definition for metric-based length is that, for an edge with vector $\\mathbf{v}$ at point $\\mathbf{x}$, its metric length is $\\ell(\\mathbf{x}) = \\sqrt{\\mathbf{v}^{\\mathsf{T}} M(\\mathbf{x}) \\mathbf{v}}$. For an edge connecting nodes $i$ and $j$, approximate the metric along the edge by the arithmetic mean\n$$\nM_{ij} = \\frac{1}{2}\\left(M_i + M_j\\right).\n$$\nDefine the edge quality function $q(\\ell) = \\exp\\!\\big(-|\\ln \\ell|\\big)$, which is dimensionless, attains its maximum value of $1$ when $\\ell = 1$, and symmetrically penalizes deviations above and below $1$. For the tetrahedron, define the average metric-based shape quality as\n$$\nQ_{\\mathrm{avg}} = \\frac{1}{6} \\sum_{(i,j) \\in \\mathcal{E}} q\\!\\left(\\ell_{ij}\\right),\n$$\nwhere $\\mathcal{E}$ is the set of the six edges, and $\\ell_{ij} = \\sqrt{\\mathbf{v}_{ij}^{\\mathsf{T}} M_{ij} \\mathbf{v}_{ij}}$ with $\\mathbf{v}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$.\n\nEnumerate the edges by indices as follows:\n$$\n\\text{edge }1: (1,2), \\quad \\text{edge }2: (1,3), \\quad \\text{edge }3: (1,4), \\quad \\text{edge }4: (2,3), \\quad \\text{edge }5: (2,4), \\quad \\text{edge }6: (3,4).\n$$\n\nStarting from the above fundamental definitions, compute $Q_{\\mathrm{avg}}$ and identify the worst edge as the one with the smallest $q(\\ell_{ij})$ among the six edges. Express the average quality as a dimensionless number and round it to four significant figures. Express the final answer as a row matrix with two entries, the first being $Q_{\\mathrm{avg}}$ (dimensionless, rounded to four significant figures) and the second being the integer index of the worst edge according to the above enumeration. No physical units are required in the final answer.", "solution": "The problem is validated as scientifically grounded, well-posed, objective, and complete. All data and definitions required for a unique solution are provided. The context, gradient-based mesh adaptation in CFD, is a legitimate field of study, and the use of Riemannian metrics is a standard technique. The provided metric tensors are symmetric and positive-definite, as required. The problem is a direct application of the provided definitions and requires a systematic calculation.\n\nThe task is to compute the average metric-based shape quality, $Q_{\\mathrm{avg}}$, for a given tetrahedron and to identify the edge with the lowest quality. The calculation will proceed by evaluating the quality for each of the six edges of the tetrahedron and then averaging these values.\n\nThe tetrahedral vertices are given by:\n$$\n\\mathbf{x}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{x}_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{x}_3 = \\begin{pmatrix} 0.2 \\\\ 1.1 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{x}_4 = \\begin{pmatrix} 0 \\\\ 0.3 \\\\ 0.9 \\end{pmatrix}.\n$$\nThe Riemannian metric tensors at each vertex $i$ are $M_i$. For an edge connecting vertices $i$ and $j$, the edge vector is $\\mathbf{v}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$, and the metric tensor is approximated by the arithmetic mean $M_{ij} = \\frac{1}{2}(M_i + M_j)$. The metric length of the edge is $\\ell_{ij} = \\sqrt{\\mathbf{v}_{ij}^{\\mathsf{T}} M_{ij} \\mathbf{v}_{ij}}$. Since all provided metric tensors $M_i$ are diagonal, the averaged metrics $M_{ij}$ are also diagonal. For a diagonal metric $M = \\mathrm{diag}(m_{11}, m_{22}, m_{33})$ and a vector $\\mathbf{v} = (v_1, v_2, v_3)^{\\mathsf{T}}$, the quadratic form simplifies to $\\mathbf{v}^{\\mathsf{T}} M \\mathbf{v} = m_{11}v_1^2 + m_{22}v_2^2 + m_{33}v_3^2$.\n\nThe quality of an edge is given by $q(\\ell) = \\exp(-|\\ln \\ell|)$. This can also be written as $q(\\ell) = \\min(\\ell, 1/\\ell)$. If $\\ell \\ge 1$, then $q(\\ell) = 1/\\ell$. If $0  \\ell  1$, then $q(\\ell) = \\ell$. The worst edge is the one with the minimum quality $q(\\ell_{ij})$, which corresponds to the metric length $\\ell_{ij}$ that deviates most from the ideal value of $1$.\n\nWe now compute the quality for each of the six edges.\n\n**Edge 1: (1, 2)**\n$\\mathbf{v}_{12} = \\mathbf{x}_2 - \\mathbf{x}_1 = (1, 0, 0)^{\\mathsf{T}}$.\n$M_{12} = \\frac{1}{2}(M_1 + M_2) = \\frac{1}{2}\\left(\\begin{pmatrix}4  0  0 \\\\ 0  1  0 \\\\ 0  0  1\\end{pmatrix} + \\begin{pmatrix}2.5  0  0 \\\\ 0  1.5  0 \\\\ 0  0  1\\end{pmatrix}\\right) = \\begin{pmatrix}3.25  0  0 \\\\ 0  1.25  0 \\\\ 0  0  1\\end{pmatrix}$.\n$\\ell_{12}^2 = \\mathbf{v}_{12}^{\\mathsf{T}} M_{12} \\mathbf{v}_{12} = 3.25 \\cdot 1^2 + 1.25 \\cdot 0^2 + 1 \\cdot 0^2 = 3.25$.\n$\\ell_{12} = \\sqrt{3.25} \\approx 1.80278$. Since $\\ell_{12} > 1$, $q_{12} = 1/\\ell_{12} = 1/\\sqrt{3.25} \\approx 0.554708$.\n\n**Edge 2: (1, 3)**\n$\\mathbf{v}_{13} = \\mathbf{x}_3 - \\mathbf{x}_1 = (0.2, 1.1, 0)^{\\mathsf{T}}$.\n$M_{13} = \\frac{1}{2}(M_1 + M_3) = \\frac{1}{2}\\left(\\begin{pmatrix}4  0  0 \\\\ 0  1  0 \\\\ 0  0  1\\end{pmatrix} + \\begin{pmatrix}3  0  0 \\\\ 0  0.8  0 \\\\ 0  0  1.2\\end{pmatrix}\\right) = \\begin{pmatrix}3.5  0  0 \\\\ 0  0.9  0 \\\\ 0  0  1.1\\end{pmatrix}$.\n$\\ell_{13}^2 = 3.5 \\cdot (0.2)^2 + 0.9 \\cdot (1.1)^2 = 3.5 \\cdot 0.04 + 0.9 \\cdot 1.21 = 0.14 + 1.089 = 1.229$.\n$\\ell_{13} = \\sqrt{1.229} \\approx 1.10860$. Since $\\ell_{13} > 1$, $q_{13} = 1/\\ell_{13} = 1/\\sqrt{1.229} \\approx 0.902054$.\n\n**Edge 3: (1, 4)**\n$\\mathbf{v}_{14} = \\mathbf{x}_4 - \\mathbf{x}_1 = (0, 0.3, 0.9)^{\\mathsf{T}}$.\n$M_{14} = \\frac{1}{2}(M_1 + M_4) = \\frac{1}{2}\\left(\\begin{pmatrix}4  0  0 \\\\ 0  1  0 \\\\ 0  0  1\\end{pmatrix} + \\begin{pmatrix}2  0  0 \\\\ 0  1  0 \\\\ 0  0  2.2\\end{pmatrix}\\right) = \\begin{pmatrix}3  0  0 \\\\ 0  1  0 \\\\ 0  0  1.6\\end{pmatrix}$.\n$\\ell_{14}^2 = 1 \\cdot (0.3)^2 + 1.6 \\cdot (0.9)^2 = 1 \\cdot 0.09 + 1.6 \\cdot 0.81 = 0.09 + 1.296 = 1.386$.\n$\\ell_{14} = \\sqrt{1.386} \\approx 1.17728$. Since $\\ell_{14} > 1$, $q_{14} = 1/\\ell_{14} = 1/\\sqrt{1.386} \\approx 0.849416$.\n\n**Edge 4: (2, 3)**\n$\\mathbf{v}_{23} = \\mathbf{x}_3 - \\mathbf{x}_2 = (-0.8, 1.1, 0)^{\\mathsf{T}}$.\n$M_{23} = \\frac{1}{2}(M_2 + M_3) = \\frac{1}{2}\\left(\\begin{pmatrix}2.5  0  0 \\\\ 0  1.5  0 \\\\ 0  0  1\\end{pmatrix} + \\begin{pmatrix}3  0  0 \\\\ 0  0.8  0 \\\\ 0  0  1.2\\end{pmatrix}\\right) = \\begin{pmatrix}2.75  0  0 \\\\ 0  1.15  0 \\\\ 0  0  1.1\\end{pmatrix}$.\n$\\ell_{23}^2 = 2.75 \\cdot (-0.8)^2 + 1.15 \\cdot (1.1)^2 = 2.75 \\cdot 0.64 + 1.15 \\cdot 1.21 = 1.76 + 1.3915 = 3.1515$.\n$\\ell_{23} = \\sqrt{3.1515} \\approx 1.77525$. Since $\\ell_{23} > 1$, $q_{23} = 1/\\ell_{23} = 1/\\sqrt{3.1515} \\approx 0.563302$.\n\n**Edge 5: (2, 4)**\n$\\mathbf{v}_{24} = \\mathbf{x}_4 - \\mathbf{x}_2 = (-1, 0.3, 0.9)^{\\mathsf{T}}$.\n$M_{24} = \\frac{1}{2}(M_2 + M_4) = \\frac{1}{2}\\left(\\begin{pmatrix}2.5  0  0 \\\\ 0  1.5  0 \\\\ 0  0  1\\end{pmatrix} + \\begin{pmatrix}2  0  0 \\\\ 0  1  0 \\\\ 0  0  2.2\\end{pmatrix}\\right) = \\begin{pmatrix}2.25  0  0 \\\\ 0  1.25  0 \\\\ 0  0  1.6\\end{pmatrix}$.\n$\\ell_{24}^2 = 2.25 \\cdot (-1)^2 + 1.25 \\cdot (0.3)^2 + 1.6 \\cdot (0.9)^2 = 2.25 + 1.25 \\cdot 0.09 + 1.6 \\cdot 0.81 = 2.25 + 0.1125 + 1.296 = 3.6585$.\n$\\ell_{24} = \\sqrt{3.6585} \\approx 1.91272$. Since $\\ell_{24} > 1$, $q_{24} = 1/\\ell_{24} = 1/\\sqrt{3.6585} \\approx 0.522818$.\n\n**Edge 6: (3, 4)**\n$\\mathbf{v}_{34} = \\mathbf{x}_4 - \\mathbf{x}_3 = (-0.2, -0.8, 0.9)^{\\mathsf{T}}$.\n$M_{34} = \\frac{1}{2}(M_3 + M_4) = \\frac{1}{2}\\left(\\begin{pmatrix}3  0  0 \\\\ 0  0.8  0 \\\\ 0  0  1.2\\end{pmatrix} + \\begin{pmatrix}2  0  0 \\\\ 0  1  0 \\\\ 0  0  2.2\\end{pmatrix}\\right) = \\begin{pmatrix}2.5  0  0 \\\\ 0  0.9  0 \\\\ 0  0  1.7\\end{pmatrix}$.\n$\\ell_{34}^2 = 2.5 \\cdot (-0.2)^2 + 0.9 \\cdot (-0.8)^2 + 1.7 \\cdot (0.9)^2 = 2.5 \\cdot 0.04 + 0.9 \\cdot 0.64 + 1.7 \\cdot 0.81 = 0.1 + 0.576 + 1.377 = 2.053$.\n$\\ell_{34} = \\sqrt{2.053} \\approx 1.43283$. Since $\\ell_{34} > 1$, $q_{34} = 1/\\ell_{34} = 1/\\sqrt{2.053} \\approx 0.697914$.\n\nNow, we sum the qualities:\n$\\sum_{(i,j) \\in \\mathcal{E}} q(\\ell_{ij}) = q_{12} + q_{13} + q_{14} + q_{23} + q_{24} + q_{34}$\n$\\sum q_{ij} \\approx 0.554708 + 0.902054 + 0.849416 + 0.563302 + 0.522818 + 0.697914 = 4.090212$.\n\nThe average quality is:\n$Q_{\\mathrm{avg}} = \\frac{1}{6} \\sum q_{ij} = \\frac{4.090212}{6} \\approx 0.681702$.\nRounding to four significant figures, $Q_{\\mathrm{avg}} \\approx 0.6817$.\n\nTo find the worst edge, we identify the minimum quality value:\n$q_1 \\approx 0.5547$\n$q_2 \\approx 0.9021$\n$q_3 \\approx 0.8494$\n$q_4 \\approx 0.5633$\n$q_5 \\approx 0.5228$\n$q_6 \\approx 0.6979$\nThe minimum quality is $q_5 \\approx 0.522818$, which corresponds to edge 5. Thus, the index of the worst edge is $5$.\n\nThe final answer is composed of the rounded average quality and the index of the worst edge.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.6817  5 \\end{pmatrix}}\n$$", "id": "3325366"}, {"introduction": "After analyzing the quality of the entire mesh against the target metric, the final stage is to create a sequence of local modifications to improve it. This coding exercise [@problem_id:3325355] moves from analysis to synthesis, challenging you to design the core logic of an adaptation algorithm. You will generate a prioritized list of edge splits and collapses, transforming the quality assessment into a concrete action plan for refining the mesh, which is exactly how automated adaptive meshing engines operate.", "problem": "You are given a three-dimensional tetrahedral mesh and a symmetric positive definite nodal metric field that encodes a Riemannian metric, which prescribes desired anisotropic resolution for gradient-based mesh adaptation in Computational Fluid Dynamics (CFD). The goal is to compute the target Euclidean edge-length distribution implied by the nodal metric and then propose a sequence of local, edge-based operations to enforce metric uniformity.\n\nStart from the fundamental geometric definition that a Riemannian metric field associates to each point a symmetric positive definite tensor $M(\\mathbf{x})$ such that the squared differential line element is $ds^2 = d\\mathbf{x}^\\top M(\\mathbf{x}) d\\mathbf{x}$. For an edge connecting nodes $i$ and $j$ with positions $\\mathbf{x}_i$ and $\\mathbf{x}_j$, denote the edge vector by $\\mathbf{d}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$ and its Euclidean length by $h_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2$. Assume the metric is interpolated along the edge by the arithmetic average $M_{ij} = \\tfrac{1}{2}(M_i + M_j)$, where $M_i$ and $M_j$ are the nodal metrics. In the Riemannian metric, the edge length is approximated by $L_{ij} = \\sqrt{\\mathbf{d}_{ij}^\\top M_{ij}\\,\\mathbf{d}_{ij}}$. The unit-metric target is $L_{ij} \\approx 1$, which implies a target Euclidean length $h_{ij}^{\\star} = \\dfrac{1}{\\sqrt{\\hat{\\mathbf{u}}_{ij}^\\top M_{ij} \\hat{\\mathbf{u}}_{ij}}}$ where $\\hat{\\mathbf{u}}_{ij} = \\mathbf{d}_{ij}/\\lVert \\mathbf{d}_{ij} \\rVert_2$. Equivalently, the ratio $r_{ij}$ measuring deviation from the unit-metric target can be computed as $r_{ij} = \\dfrac{h_{ij}}{h_{ij}^{\\star}} = \\sqrt{\\mathbf{d}_{ij}^\\top M_{ij}\\,\\mathbf{d}_{ij}}$.\n\nDesign an algorithm that:\n- Computes $r_{ij}$ for every unique undirected mesh edge.\n- Classifies each edge by thresholds $t_{\\text{split}} = 1.3$ and $t_{\\text{collapse}} = 0.7$ as follows:\n    - If $r_{ij} > t_{\\text{split}}$, propose an edge split.\n    - If $r_{ij}  t_{\\text{collapse}}$, propose an edge collapse.\n    - Otherwise, no operation is proposed for that edge.\n- Produces a proposed sequence of local operations by ordering:\n    - All split edges in descending order of $r_{ij}$ (larger $r_{ij}$ first), with ties broken by increasing edge index.\n    - All collapse edges in ascending order of $r_{ij}$ (smaller $r_{ij}$ first), with ties broken by increasing edge index.\n\nEdge indexing rule: enumerate the set of unique undirected edges by lexicographic order of their node-index pairs $(\\min(i,j),\\max(i,j))$, starting from index $0$.\n\nYou must implement a complete, runnable program that computes, for each test case below, the ordered lists of edge indices to split and to collapse. The final output must aggregate all test cases into a single line: a list of per-test-case results, where each per-test-case result is a list with two lists, the first being the split edge indices in order and the second being the collapse edge indices in order. If a list is empty, represent it as an empty list. No additional text is permitted.\n\nUse the following test suite. Node indices start at $0$. Each nodal metric $M_i$ is given as a diagonal $3 \\times 3$ matrix $\\mathrm{diag}(m_{x}, m_{y}, m_{z})$ with strictly positive entries.\n\n- Test case $1$ (isotropic refinement demand):\n    - Nodes (Cartesian coordinates): $\\mathbf{x}_0=(0,0,0)$, $\\mathbf{x}_1=(1,0,0)$, $\\mathbf{x}_2=(0,1,0)$, $\\mathbf{x}_3=(0,0,1)$.\n    - Tetrahedra: $[0,1,2,3]$.\n    - Nodal metrics: for all nodes $i \\in \\{0,1,2,3\\}$, $M_i = 4\\,I$.\n- Test case $2$ (isotropic coarsening demand):\n    - Nodes and tetrahedra identical to test case $1$.\n    - Nodal metrics: for all nodes $i \\in \\{0,1,2,3\\}$, $M_i = 0.25\\,I$.\n- Test case $3$ (anisotropic, spatially varying):\n    - Nodes: $\\mathbf{x}_0=(0,0,0)$, $\\mathbf{x}_1=(1,0,0)$, $\\mathbf{x}_2=(0,1,0)$, $\\mathbf{x}_3=(0,0,1)$, $\\mathbf{x}_4=(1,1,0)$.\n    - Tetrahedra: $[0,1,2,3]$ and $[1,2,3,4]$.\n    - Nodal metrics:\n        - $M_0 = \\mathrm{diag}(9,1,1)$, $M_1 = \\mathrm{diag}(9,1,1)$,\n        - $M_2 = \\mathrm{diag}(1,9,1)$, $M_3 = \\mathrm{diag}(1,9,1)$,\n        - $M_4 = \\mathrm{diag}(1,1,4)$.\n\nAngle units are not applicable. No physical units are required for the output; all returned values are edge indices (dimensionless). For threshold comparisons, treat strict inequalities (for example, $r_{ij}  t_{\\text{collapse}}$ triggers a collapse, while $r_{ij} = t_{\\text{collapse}}$ does not).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the per-test-case result in the form $[\\text{split\\_indices}, \\text{collapse\\_indices}]$. For example, a valid structure is $[[[a_1,a_2], [b_1]], [[], [c_1,c_2]]]$, with integers $a_k$, $b_k$, and $c_k$ representing edge indices.", "solution": "The problem requires the design and implementation of an algorithm to propose mesh adaptation operations (edge splits and collapses) based on a nodal Riemannian metric field. The objective is to identify edges that are too long or too short in the metric-defined space and to schedule modification operations in a prioritized order. The process adheres to standard practices in gradient-based mesh adaptation for computational fluid dynamics (CFD).\n\nThe core principle of metric-based mesh adaptation is to generate a mesh where all edges have a length of approximately unity in the space defined by a given Riemannian metric. A metric tensor field, $M(\\mathbf{x})$, is a symmetric positive definite tensor at each point $\\mathbf{x}$ in the domain, which defines a local measure of distance. The squared differential line element is given by $ds^2 = d\\mathbf{x}^\\top M(\\mathbf{x}) d\\mathbf{x}$. A uniform mesh in this metric space corresponds to a non-uniform, adapted mesh in the original Euclidean space, with high mesh resolution (small elements) where the metric prescribes it and low resolution (large elements) elsewhere.\n\nThe algorithm proceeds in four main steps: unique edge identification, metric-based length calculation, classification of operations, and sequencing of operations.\n\n**1. Unique Edge Identification and Indexing**\nThe input mesh is defined by a set of nodes and their connectivity (tetrahedra). A single tetrahedron with vertices $\\{n_1, n_2, n_3, n_4\\}$ contributes six edges: $(n_1, n_2)$, $(n_1, n_3)$, $(n_1, n_4)$, $(n_2, n_3)$, $(n_2, n_4)$, and $(n_3, n_4)$. To process the entire mesh, we first extract all such edges from every tetrahedron. To handle each unique edge only once, we represent each undirected edge by a canonical ordered pair of its node indices, $(\\min(i,j), \\max(i,j))$. A set data structure is used to collect these canonical pairs, automatically discarding duplicates.\n\nFollowing the problem specification, we establish a deterministic ordering for these unique edges. The set of canonical pairs is converted to a list and sorted lexicographically. The index of an edge in this sorted list becomes its unique edge index, starting from $0$.\n\n**2. Metric-Based Edge Length Calculation**\nFor each unique edge connecting nodes $i$ and $j$, with corresponding position vectors $\\mathbf{x}_i$ and $\\mathbf{x}_j$, the algorithm computes a deviation ratio $r_{ij}$. This ratio represents the length of the edge in the specified Riemannian metric. The target for an ideal mesh is $r_{ij} \\approx 1$ for all edges.\n\nThe calculation proceeds as follows:\n- The edge vector in Euclidean space is computed: $\\mathbf{d}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$.\n- The metric tensor is defined at the nodes. To obtain a metric representative of the entire edge, we interpolate the nodal metrics. The problem specifies an arithmetic average: $M_{ij} = \\frac{1}{2}(M_i + M_j)$, where $M_i$ and $M_j$ are the symmetric positive definite metric tensors at nodes $i$ and $j$.\n- The length of the edge in the Riemannian metric, denoted $L_{ij}$, is approximated by discretizing the line integral along the edge vector:\n$$L_{ij} \\approx \\sqrt{\\mathbf{d}_{ij}^\\top M_{ij} \\mathbf{d}_{ij}}$$\nThis value is precisely the deviation ratio, $r_{ij}$, required by the problem statement. A value $r_{ij} > 1$ indicates the edge is longer than the ideal unit length, suggesting the need for refinement (splitting). A value $r_{ij}  1$ indicates the edge is too short, suggesting coarsening (collapsing). Since the provided nodal metrics $M_i$ are diagonal, e.g., $M_i = \\mathrm{diag}(m_{ix}, m_{iy}, m_{iz})$, and the edge vector is $\\mathbf{d}_{ij} = (d_x, d_y, d_z)$, the quadratic form simplifies to:\n$$\\mathbf{d}_{ij}^\\top M_{ij} \\mathbf{d}_{ij} = m_{ij,x} d_x^2 + m_{ij,y} d_y^2 + m_{ij,z} d_z^2$$\nwhere $m_{ij,k} = \\frac{1}{2}(m_{ik} + m_{jk})$ for $k \\in \\{x,y,z\\}$.\n\n**3. Edge Operation Classification**\nOnce the ratio $r_{ij}$ is computed for every edge, each edge is classified based on two predefined thresholds, $t_{\\text{split}} = 1.3$ and $t_{\\text{collapse}} = 0.7$.\n- If $r_{ij} > t_{\\text{split}}$, the edge is too long. An **edge split** operation is proposed. This operation typically involves inserting a new node at the edge midpoint and reconnecting the local topology.\n- If $r_{ij}  t_{\\text{collapse}}$, the edge is too short. An **edge collapse** operation is proposed. This involves merging the two endpoint nodes into a single node, removing the edge and affected elements.\n- If $t_{\\text{collapse}} \\le r_{ij} \\le t_{\\text{split}}$, the edge length is considered acceptable, and no operation is proposed. The range $[t_{\\text{collapse}}, t_{\\text{split}}]$ forms a \"dead zone\" to prevent excessive or unstable oscillations in the adaptation process.\n\n**4. Operation Sequencing**\nA mesh adaptation cycle typically consists of applying many local operations. The order of these operations can affect the quality of the final mesh. The problem specifies a prioritized ordering scheme:\n- **Splits**: All edges marked for splitting are sorted in descending order of their deviation ratio $r_{ij}$. This prioritizes splitting the longest edges first, which is a common heuristic to rapidly improve the quality of the worst parts of the mesh.\n- **Collapses**: All edges marked for collapsing are sorted in ascending order of their deviation ratio $r_{ij}$. This prioritizes collapsing the shortest edges first, which is crucial for removing degenerate or near-degenerate elements and improving numerical stability.\n- **Tie-Breaking**: In both cases, if multiple edges have the same $r_{ij}$ value, ties are broken by sorting based on their unique edge index in ascending order. This ensures a fully deterministic sequence.\n\nThe final output consists of two ordered lists for each test case: a list of edge indices to be split and a list of edge indices to be collapsed. This sequence of proposed operations can then be passed to a mesh modification kernel to perform the adaptation.", "answer": "[[[3,4,5,0,1,2],[]],[[0,1,2],[]],[[3,6,0,8,4,1],[]]]", "id": "3325355"}]}