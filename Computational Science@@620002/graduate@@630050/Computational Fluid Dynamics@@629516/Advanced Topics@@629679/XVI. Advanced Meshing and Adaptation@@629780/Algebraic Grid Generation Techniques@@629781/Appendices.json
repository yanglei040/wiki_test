{"hands_on_practices": [{"introduction": "At the heart of algebraic grid generation is the ability to create a smooth interior grid that conforms to specified boundary curves. This exercise guides you through constructing a transfinite interpolation (TFI) mapping from first principles, using linear blending and the inclusion-exclusion principle to ensure the mapping perfectly matches the given boundaries. Mastering this fundamental technique is essential for understanding how more complex algebraic methods are built and for developing custom grid generators.", "problem": "In algebraic grid generation for computational fluid dynamics, an interior mapping is constructed over the unit square parameter domain $[0,1] \\times [0,1]$ from four analytic edge curves, two given as functions of the horizontal parameter $\\xi$ and two as functions of the vertical parameter $\\eta$. Consider the following four boundary curves in the physical plane $\\mathbb{R}^{2}$:\n- Bottom edge (parametrized by $\\xi$): $\\mathbf{c}_{1}(\\xi) = \\big(\\,\\xi + \\xi^{2}, \\tfrac{1}{2}\\,\\xi\\,\\big)$.\n- Top edge (parametrized by $\\xi$): $\\mathbf{c}_{2}(\\xi) = \\big(\\,1 + \\tfrac{1}{2}\\cos(\\pi \\xi),\\, 1 + \\tfrac{1}{2}\\sin(\\pi \\xi)\\,\\big)$.\n- Left edge (parametrized by $\\eta$): $\\mathbf{d}_{1}(\\eta) = \\big(\\,\\tfrac{3}{2}\\,\\eta^{2},\\, \\eta\\,\\big)$.\n- Right edge (parametrized by $\\eta$): $\\mathbf{d}_{2}(\\eta) = \\big(\\,2 - \\tfrac{3}{2}\\,\\eta,\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\,\\eta\\,\\big)$.\n\nThese curves are consistent at the four corners in the sense that $\\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0)$, $\\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0)$, $\\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1)$, and $\\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1)$.\n\nUsing only the following fundamental base: (i) one-dimensional linear interpolation along a parameter line, and (ii) inclusion–exclusion to correct for double-counted corner contributions, construct from first principles a two-dimensional algebraic mapping $\\mathbf{x}(\\xi,\\eta)$ over $[0,1] \\times [0,1]$ that blends these edges and reproduces them exactly on the boundary. Prove that your construction satisfies the boundary reproduction properties $\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi)$, $\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi)$, $\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta)$, and $\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta)$.\n\nFinally, evaluate the resulting transfinite interpolation (TFI) mapping at the interior point $(\\xi_{0},\\eta_{0}) = \\big(\\tfrac{1}{3}, \\tfrac{2}{5}\\big)$, and give $\\mathbf{x}(\\tfrac{1}{3}, \\tfrac{2}{5})$ as an exact analytic expression. Express your final answer as a two-component row vector. No rounding is required.", "solution": "The goal is to derive a two-dimensional algebraic mapping that interpolates the four boundary curves and reproduces them on the boundary. The derivation proceeds from the following foundational ideas:\n\n1. One-dimensional linear interpolation along a coordinate line in the parameter domain. Given two vector-valued functions $\\mathbf{a}(\\xi)$ and $\\mathbf{b}(\\xi)$ associated with $\\eta=0$ and $\\eta=1$, a linear blend along $\\eta$ is\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{a}(\\xi) + \\eta\\,\\mathbf{b}(\\xi).\n$$\nSimilarly, along $\\xi$ with two vector-valued functions $\\mathbf{p}(\\eta)$ and $\\mathbf{q}(\\eta)$ associated with $\\xi=0$ and $\\xi=1$, a linear blend is\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{p}(\\eta) + \\xi\\,\\mathbf{q}(\\eta).\n$$\n\n2. Inclusion–exclusion (or boolean sum) to correct for double counting. If we simply add the two one-dimensional blends $\\mathbf{L}_{\\eta}$ and $\\mathbf{L}_{\\xi}$, the corner points become counted twice. To remove the overcount, we subtract a bilinear interpolation of the four corner points with the standard bilinear shape functions $N_{00}=(1-\\xi)(1-\\eta)$, $N_{10}=\\xi(1-\\eta)$, $N_{01}=(1-\\xi)\\eta$, $N_{11}=\\xi\\eta$.\n\nWe first identify the corner points, which must be mutually consistent:\n$$\n\\mathbf{x}_{00} = \\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0),\\quad\n\\mathbf{x}_{10} = \\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0),\\quad\n\\mathbf{x}_{01} = \\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1),\\quad\n\\mathbf{x}_{11} = \\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1).\n$$\nFrom the data,\n$$\n\\mathbf{x}_{00} = (0,0),\\quad\n\\mathbf{x}_{10} = (2,\\tfrac{1}{2}),\\quad\n\\mathbf{x}_{01} = (\\tfrac{3}{2},1),\\quad\n\\mathbf{x}_{11} = (\\tfrac{1}{2},1).\n$$\n\nConstruct the one-dimensional blends using the given edges:\n- Along $\\eta$ between $\\mathbf{c}_{1}(\\xi)$ and $\\mathbf{c}_{2}(\\xi)$:\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi).\n$$\n- Along $\\xi$ between $\\mathbf{d}_{1}(\\eta)$ and $\\mathbf{d}_{2}(\\eta)$:\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta).\n$$\n\nTo correct double counting of corners, subtract the bilinear corner interpolation\n$$\n\\mathbf{B}(\\xi,\\eta) = (1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}.\n$$\n\nThus, the transfinite interpolation (TFI) mapping constructed from first principles is\n$$\n\\mathbf{x}(\\xi,\\eta) \\;=\\; \\mathbf{L}_{\\eta}(\\xi,\\eta) \\;+\\; \\mathbf{L}_{\\xi}(\\xi,\\eta) \\;-\\; \\mathbf{B}(\\xi,\\eta).\n$$\n\nWe now verify boundary reproduction:\n\n1. Bottom edge $\\eta=0$:\nSubstitute $\\eta=0$:\n$$\n\\mathbf{x}(\\xi,0) = (1-0)\\mathbf{c}_{1}(\\xi) + 0\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(0) + \\xi \\mathbf{d}_{2}(0) - \\big[(1-\\xi)(1-0)\\mathbf{x}_{00} + \\xi(1-0)\\mathbf{x}_{10} + (1-\\xi)0\\,\\mathbf{x}_{01} + \\xi 0\\,\\mathbf{x}_{11}\\big].\n$$\nSince $\\mathbf{d}_{1}(0)=\\mathbf{x}_{00}$ and $\\mathbf{d}_{2}(0)=\\mathbf{x}_{10}$, the latter two terms cancel exactly with the bilinear corner terms, leaving\n$$\n\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi).\n$$\n\n2. Top edge $\\eta=1$:\nSimilarly,\n$$\n\\mathbf{x}(\\xi,1) = (1-1)\\mathbf{c}_{1}(\\xi) + 1\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(1) + \\xi \\mathbf{d}_{2}(1) - \\big[(1-\\xi)0\\,\\mathbf{x}_{00} + \\xi 0\\,\\mathbf{x}_{10} + (1-\\xi)1\\,\\mathbf{x}_{01} + \\xi 1\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{d}_{1}(1)=\\mathbf{x}_{01}$ and $\\mathbf{d}_{2}(1)=\\mathbf{x}_{11}$, the last two terms cancel with the subtracted corner terms, giving\n$$\n\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi).\n$$\n\n3. Left edge $\\xi=0$:\n$$\n\\mathbf{x}(0,\\eta) = (1-\\eta)\\mathbf{c}_{1}(0) + \\eta \\mathbf{c}_{2}(0) + (1-0)\\mathbf{d}_{1}(\\eta) + 0\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-0)(1-\\eta)\\mathbf{x}_{00} + 0(1-\\eta)\\mathbf{x}_{10} + (1-0)\\eta\\,\\mathbf{x}_{01} + 0\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{c}_{1}(0)=\\mathbf{x}_{00}$ and $\\mathbf{c}_{2}(0)=\\mathbf{x}_{01}$, the added terms cancel with the subtracted bilinear corner terms, yielding\n$$\n\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta).\n$$\n\n4. Right edge $\\xi=1$:\n$$\n\\mathbf{x}(1,\\eta) = (1-\\eta)\\mathbf{c}_{1}(1) + \\eta \\mathbf{c}_{2}(1) + (1-1)\\mathbf{d}_{1}(\\eta) + 1\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-1)(1-\\eta)\\mathbf{x}_{00} + 1(1-\\eta)\\mathbf{x}_{10} + (1-1)\\eta\\,\\mathbf{x}_{01} + 1\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{c}_{1}(1)=\\mathbf{x}_{10}$ and $\\mathbf{c}_{2}(1)=\\mathbf{x}_{11}$, again the terms cancel, giving\n$$\n\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta).\n$$\nTherefore, the mapping reproduces all four boundaries exactly.\n\nWe now evaluate $\\mathbf{x}(\\xi,\\eta)$ at $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$ using the explicit data.\n\nCompute the edge values at the specified parameters:\n$$\n\\mathbf{c}_{1}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(\\tfrac{1}{3} + \\tfrac{1}{9},\\, \\tfrac{1}{2}\\cdot \\tfrac{1}{3}\\Big) = \\Big(\\tfrac{4}{9},\\, \\tfrac{1}{6}\\Big),\n$$\n$$\n\\mathbf{c}_{2}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(1 + \\tfrac{1}{2}\\cos\\tfrac{\\pi}{3},\\, 1 + \\tfrac{1}{2}\\sin\\tfrac{\\pi}{3}\\Big) = \\Big(1 + \\tfrac{1}{2}\\cdot \\tfrac{1}{2},\\, 1 + \\tfrac{1}{2}\\cdot \\tfrac{\\sqrt{3}}{2}\\Big) = \\Big(\\tfrac{5}{4},\\, 1 + \\tfrac{\\sqrt{3}}{4}\\Big),\n$$\n$$\n\\mathbf{d}_{1}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(\\tfrac{3}{2}\\cdot \\big(\\tfrac{2}{5}\\big)^{2},\\, \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{6}{25},\\, \\tfrac{2}{5}\\Big),\n$$\n$$\n\\mathbf{d}_{2}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(2 - \\tfrac{3}{2}\\cdot \\tfrac{2}{5},\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\cdot \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{7}{5},\\, \\tfrac{7}{10}\\Big).\n$$\nThe corner points are\n$$\n\\mathbf{x}_{00}=(0,0),\\quad \\mathbf{x}_{10}=(2,\\tfrac{1}{2}),\\quad \\mathbf{x}_{01}=(\\tfrac{3}{2},1),\\quad \\mathbf{x}_{11}=(\\tfrac{1}{2},1).\n$$\n\nWith $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$, the mapping evaluates to\n$$\n\\mathbf{x} = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi) + (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta) \\;-\\; \\Big[(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}\\Big].\n$$\nCompute the scalar weights:\n$$\n1-\\eta = \\tfrac{3}{5},\\quad 1-\\xi = \\tfrac{2}{3},\\quad \\xi = \\tfrac{1}{3},\\quad \\eta = \\tfrac{2}{5}.\n$$\nFirst, the four blended terms:\n$$\n(1-\\eta)\\,\\mathbf{c}_{1}(\\xi) = \\tfrac{3}{5}\\,\\Big(\\tfrac{4}{9},\\,\\tfrac{1}{6}\\Big) = \\Big(\\tfrac{4}{15},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n\\eta\\,\\mathbf{c}_{2}(\\xi) = \\tfrac{2}{5}\\,\\Big(\\tfrac{5}{4},\\,1 + \\tfrac{\\sqrt{3}}{4}\\Big) = \\Big(\\tfrac{1}{2},\\, \\tfrac{2}{5} + \\tfrac{\\sqrt{3}}{10}\\Big),\n$$\n$$\n(1-\\xi)\\,\\mathbf{d}_{1}(\\eta) = \\tfrac{2}{3}\\,\\Big(\\tfrac{6}{25},\\,\\tfrac{2}{5}\\Big) = \\Big(\\tfrac{4}{25},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\,\\mathbf{d}_{2}(\\eta) = \\tfrac{1}{3}\\,\\Big(\\tfrac{7}{5},\\,\\tfrac{7}{10}\\Big) = \\Big(\\tfrac{7}{15},\\,\\tfrac{7}{30}\\Big).\n$$\nSumming these four terms gives\n$$\n\\mathbf{S}_{1} = \\Big(\\tfrac{209}{150},\\, 1 + \\tfrac{\\sqrt{3}}{10}\\Big).\n$$\n\nNext, the bilinear corner subtraction:\n$$\n(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} = \\tfrac{2}{5}\\,(0,0) = (0,0),\n$$\n$$\n\\xi(1-\\eta)\\,\\mathbf{x}_{10} = \\tfrac{1}{5}\\,(2,\\tfrac{1}{2}) = \\Big(\\tfrac{2}{5},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n(1-\\xi)\\eta\\,\\mathbf{x}_{01} = \\tfrac{4}{15}\\,(\\tfrac{3}{2},1) = \\Big(\\tfrac{2}{5},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\eta\\,\\mathbf{x}_{11} = \\tfrac{2}{15}\\,(\\tfrac{1}{2},1) = \\Big(\\tfrac{1}{15},\\,\\tfrac{2}{15}\\Big).\n$$\nSumming these four terms yields\n$$\n\\mathbf{S}_{2} = \\Big(\\tfrac{13}{15},\\, \\tfrac{1}{2}\\Big).\n$$\n\nTherefore,\n$$\n\\mathbf{x}\\!\\Big(\\tfrac{1}{3},\\tfrac{2}{5}\\Big) \\;=\\; \\mathbf{S}_{1} - \\mathbf{S}_{2} \\;=\\; \\Big(\\tfrac{209}{150} - \\tfrac{13}{15},\\, 1 + \\tfrac{\\sqrt{3}}{10} - \\tfrac{1}{2}\\Big) \\;=\\; \\Big(\\tfrac{79}{150},\\, \\tfrac{5+\\sqrt{3}}{10}\\Big).\n$$\nThis is an exact analytic expression for the interior point produced by the constructed transfinite interpolation mapping, and the boundary reproduction properties have been established from first principles via one-dimensional blending and inclusion–exclusion.", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{79}{150} & \\frac{5+\\sqrt{3}}{10}\\end{pmatrix}}$$", "id": "3290639"}, {"introduction": "Once a grid is generated via a coordinate mapping, its quality must be assessed to ensure it is suitable for numerical simulation, and the Jacobian determinant is the most fundamental metric for this purpose. This practice focuses on deriving the Jacobian determinant, $J$, for a given algebraic mapping and interpreting its physical meaning in the context of grid generation. Understanding the Jacobian allows you to identify regions of high cell compression, distortion, or even grid inversion ($J \\le 0$), which are critical for simulation accuracy and stability.", "problem": "In algebraic grid generation for Computational Fluid Dynamics (CFD), mappings from a computational domain to a physical domain are constructed to control grid spacing and orientation. Consider the analytic mapping from the unit computational square $\\{(\\xi,\\eta)\\,|\\,0 \\le \\xi \\le 1,\\,0 \\le \\eta \\le 1\\}$ to the physical plane given by\n$$\nx(\\xi,\\eta) \\;=\\; \\xi \\;+\\; \\alpha\\,\\xi\\,(1-\\xi)\\,\\bigl(2\\eta - 1\\bigr),\\qquad\ny(\\xi,\\eta) \\;=\\; \\eta \\;+\\; \\beta\\,\\eta\\,(1-\\eta)\\,\\bigl(2\\xi - 1\\bigr),\n$$\nwhere $\\alpha$ and $\\beta$ are real parameters controlling interior algebraic blending.\n\nStarting from the definition of the Jacobian determinant for a planar mapping and fundamental change-of-variables principles in area transformation, derive the exact analytic expression for the Jacobian determinant $J(\\xi,\\eta)$ of this mapping. Then, using first-principles reasoning, interpret regions of small $|J(\\xi,\\eta)|$ in terms of local cell area compression, skewness, and potential near-inversion in the generated grid, explaining how the sign and magnitude of $J$ relate to cell orientation and distortion.\n\nProvide your final result for $J(\\xi,\\eta)$ as a single, closed-form analytic expression in terms of $\\xi$, $\\eta$, $\\alpha$, and $\\beta$. No numerical evaluation is required, and no rounding is needed. Do not include any units in your final expression.", "solution": "The transformation from the computational coordinates $(\\xi, \\eta)$ to the physical coordinates $(x, y)$ is given by the mapping:\n$$\nx(\\xi,\\eta) = \\xi + \\alpha\\,\\xi\\,(1-\\xi)\\,(2\\eta - 1)\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\beta\\,\\eta\\,(1-\\eta)\\,(2\\xi - 1)\n$$\nThe Jacobian determinant, $J(\\xi, \\eta)$, of this transformation is defined as:\n$$\nJ(\\xi, \\eta) = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\det \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\frac{\\partial x}{\\partial \\xi} \\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta} \\frac{\\partial y}{\\partial \\xi}\n$$\nTo compute $J(\\xi, \\eta)$, we first find the four required partial derivatives.\n\n1.  Differentiating $x(\\xi, \\eta)$ with respect to $\\xi$:\n    $$\n    \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\xi + \\alpha(\\xi - \\xi^2)(2\\eta - 1) \\right] = 1 + \\alpha(1-2\\xi)(2\\eta - 1)\n    $$\n\n2.  Differentiating $x(\\xi, \\eta)$ with respect to $\\eta$:\n    $$\n    \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\xi + \\alpha\\xi(1-\\xi)(2\\eta - 1) \\right] = \\alpha\\xi(1-\\xi)(2) = 2\\alpha\\xi(1-\\xi)\n    $$\n\n3.  Differentiating $y(\\xi, \\eta)$ with respect to $\\xi$:\n    $$\n    \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\eta + \\beta\\eta(1-\\eta)(2\\xi - 1) \\right] = \\beta\\eta(1-\\eta)(2) = 2\\beta\\eta(1-\\eta)\n    $$\n\n4.  Differentiating $y(\\xi, \\eta)$ with respect to $\\eta$:\n    $$\n    \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\eta + \\beta(\\eta - \\eta^2)(2\\xi - 1) \\right] = 1 + \\beta(1-2\\eta)(2\\xi - 1)\n    $$\n\nNext, we substitute these partial derivatives into the determinant formula.\n$$\nJ(\\xi, \\eta) = \\left[ 1 + \\alpha(1-2\\xi)(2\\eta - 1) \\right] \\left[ 1 + \\beta(1-2\\eta)(2\\xi - 1) \\right] - \\left[ 2\\alpha\\xi(1-\\xi) \\right] \\left[ 2\\beta\\eta(1-\\eta) \\right]\n$$\nTo simplify this expression, we observe that $(2\\eta-1) = -(1-2\\eta)$ and $(2\\xi-1) = -(1-2\\xi)$.\nWe can rewrite the first two terms of the product:\n$$\n\\alpha(1-2\\xi)(2\\eta-1) = -\\alpha(1-2\\xi)(1-2\\eta)\n$$\n$$\n\\beta(1-2\\eta)(2\\xi-1) = -\\beta(1-2\\eta)(1-2\\xi)\n$$\nThe product term becomes:\n$$\n\\left[ 1 - \\alpha(1-2\\xi)(1-2\\eta) \\right] \\left[ 1 - \\beta(1-2\\xi)(1-2\\eta) \\right]\n$$\nExpanding this product gives:\n$$\n1 - \\beta(1-2\\xi)(1-2\\eta) - \\alpha(1-2\\xi)(1-2\\eta) + \\alpha\\beta(1-2\\xi)^2(1-2\\eta)^2\n$$\n$$\n= 1 - (\\alpha+\\beta)(1-2\\xi)(1-2\\eta) + \\alpha\\beta(1-2\\xi)^2(1-2\\eta)^2\n$$\nThe second part of the Jacobian expression is:\n$$\n\\left[ 2\\alpha\\xi(1-\\xi) \\right] \\left[ 2\\beta\\eta(1-\\eta) \\right] = 4\\alpha\\beta\\xi(1-\\xi)\\eta(1-\\eta)\n$$\nCombining all parts, the full expression for the Jacobian determinant is:\n$$\nJ(\\xi, \\eta) = 1 - (\\alpha+\\beta)(1-2\\xi)(1-2\\eta) + \\alpha\\beta(1-2\\xi)^2(1-2\\eta)^2 - 4\\alpha\\beta\\xi(1-\\xi)\\eta(1-\\eta)\n$$\nThis is the final, exact analytic expression for the Jacobian determinant.\n\nThe second part of the problem requires an interpretation of this result.\nFrom the principles of multivariable calculus, the Jacobian determinant $J(\\xi, \\eta)$ relates an infinitesimal area element $d\\xi d\\eta$ in the computational domain to the corresponding infinitesimal area element $dA$ in the physical domain. The relationship is $dA = |J(\\xi, \\eta)| d\\xi d\\eta$.\n\n1.  **Magnitude and Cell Area:** The magnitude, $|J(\\xi, \\eta)|$, represents the local ratio of the physical cell area to the computational cell area.\n    - Regions where $|J(\\xi, \\eta)|$ is small correspond to regions of high grid-point density, where the physical cells are highly compressed. For a uniform grid in the computational domain, a small $|J|$ means small physical cells. This is often done intentionally to resolve regions with high physical gradients, such as boundary layers.\n    - Conversely, large values of $|J(\\xi, \\eta)|$ indicate regions where the physical cells are larger than the computational cells, corresponding to areas of low grid resolution.\n\n2.  **Sign and Cell Orientation:** The sign of $J(\\xi, \\eta)$ is critically important for the validity of the grid.\n    - A positive Jacobian, $J(\\xi, \\eta) > 0$, signifies that the mapping preserves the local orientation. A right-handed coordinate system $(\\xi, \\eta)$ is mapped to a right-handed system $(x, y)$. This corresponds to a physically valid, non-overlapping grid cell. For a valid numerical simulation, the Jacobian must be positive everywhere in the domain.\n    - A negative Jacobian, $J(\\xi, \\eta) < 0$, indicates that the local orientation is reversed. The grid cell has \"flipped\" or \"folded over\" on itself. This is a fatal flaw in a grid, as it leads to overlapping cells and is unacceptable for any standard CFD solver.\n    - A zero Jacobian, $J(\\xi, \\eta) = 0$, represents a singularity in the mapping. At this point, the grid lines are perfectly collinear, and the cell area has collapsed to zero. This is the boundary between a valid (positive $J$) and an invalid (negative $J$) grid. The parameters $\\alpha$ and $\\beta$ must be chosen to ensure $J(\\xi, \\eta) > 0$ for all $(\\xi, \\eta)$ in the domain.\n\n3.  **Distortion and Skewness:** While the Jacobian determinant is fundamentally a measure of area (or volume in 3D), its behavior is closely linked to cell quality metrics like skewness and aspect ratio. As grid lines become highly non-orthogonal (high skewness) or a cell is stretched excessively (high aspect ratio), the cell area tends to decrease. Therefore, regions of small $|J(\\xi, \\eta)|$ are often, but not always, regions of high cell distortion. The condition $J \\to 0$ definitively signals that the grid is becoming degenerate, which may manifest as extreme skewness, aspect ratio, or both, culminating in grid line crossing and inversion at $J<0$.", "answer": "$$\n\\boxed{1 - (\\alpha+\\beta)(1-2\\xi)(1-2\\eta) + \\alpha\\beta(1-2\\xi)^2(1-2\\eta)^2 - 4\\alpha\\beta\\xi(1-\\xi)\\eta(1-\\eta)}\n$$", "id": "3290596"}, {"introduction": "The choice of blending functions in transfinite interpolation significantly impacts grid quality, particularly near boundaries. This advanced practice explores the practical difference between simple linear blending and a more sophisticated cubic approach designed to improve grid line behavior. You will implement both a standard bilinear TFI and a Coons patch with cubic blending, then quantify and compare their effects on grid line orthogonality and smoothness. By calculating metrics like skewness and smoothness, you will gain direct insight into how to select appropriate blending strategies to achieve desired grid characteristics, such as boundary orthogonality.", "problem": "You are tasked with constructing and comparing two algebraic structured grids in the plane generated from the same four boundary curves using two different transfinite interpolation strategies. Your program must implement both strategies from first principles, compute two quantitative grid quality metrics for each grid, and then aggregate results across a specified test suite.\n\nThe setting is as follows. Let there be a mapping from a computational rectangle to a physical domain given by a vector-valued function $\\mathbf{X}(\\xi,\\eta) \\in \\mathbb{R}^2$ with $(\\xi,\\eta) \\in [0,1]\\times[0,1]$. The mapping must interpolate the four boundary curves $\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$, $\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$, $\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$, and $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$, and be consistent at corners, meaning $\\mathbf{B}_0(0) = \\mathbf{C}_0(0)$, $\\mathbf{B}_0(1) = \\mathbf{C}_1(0)$, $\\mathbf{B}_1(0) = \\mathbf{C}_0(1)$, and $\\mathbf{B}_1(1) = \\mathbf{C}_1(1)$.\n\nYour grid generator must be built by transfinite interpolation from the four boundary curves using blending functions that satisfy the partition-of-unity and endpoint conditions. Specifically, let $g_0(\\xi)$ and $g_1(\\xi)$ be blending functions in the $\\xi$-direction and $h_0(\\eta)$ and $h_1(\\eta)$ be blending functions in the $\\eta$-direction such that $g_0(\\xi) + g_1(\\xi) = 1$, $h_0(\\eta) + h_1(\\eta) = 1$, $g_0(0) = 1$, $g_0(1) = 0$, $g_1(0) = 0$, $g_1(1) = 1$, and similarly $h_0(0) = 1$, $h_0(1) = 0$, $h_1(0) = 0$, $h_1(1) = 1$. Starting from these definitions and the requirement that the mapping interpolates the boundary curves, derive the transfinite interpolation formula for $\\mathbf{X}(\\xi,\\eta)$ consistent with inclusion-exclusion to avoid double counting of corner data.\n\nYou must construct and compare two grids on the same boundary curves:\n- Grid A (bilinear transfinite interpolation): choose linear blending functions $g_1(\\xi) = \\xi$, $g_0(\\xi) = 1 - \\xi$, $h_1(\\eta) = \\eta$, $h_0(\\eta) = 1 - \\eta$.\n- Grid B (Coons patch with cubic parametric stretching): choose the monotone cubic ramp $\\sigma(\\xi) = 3\\xi^2 - 2\\xi^3$ and $\\rho(\\eta) = 3\\eta^2 - 2\\eta^3$, and set $g_1(\\xi) = \\sigma(\\xi)$, $g_0(\\xi) = 1 - \\sigma(\\xi)$, $h_1(\\eta) = \\rho(\\eta)$, $h_0(\\eta) = 1 - \\rho(\\eta)$.\n\nUse the following family of corner-consistent boundary curves parameterized by real scalars $a$, $b$, $c$, and $d$:\n- Bottom edge $\\mathbf{B}_0(\\xi) = \\big(\\xi + a \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 0\\big)$,\n- Top edge $\\mathbf{B}_1(\\xi) = \\big(\\xi + b \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 1\\big)$,\n- Left edge $\\mathbf{C}_0(\\eta) = \\big(0,\\; \\eta + c \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$,\n- Right edge $\\mathbf{C}_1(\\eta) = \\big(1,\\; \\eta + d \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$.\n\nFor each grid, you must quantify:\n1. A skewness metric based on orthogonality deviation of the grid lines. Let the covariant base vectors at a grid node be approximated by centered finite differences as $\\mathbf{g}_\\xi \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ and $\\mathbf{g}_\\eta \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$. Define the local orthogonality deviation $\\delta(\\xi,\\eta) = \\left| \\frac{\\pi}{2} - \\arccos\\left( \\frac{\\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta}{\\|\\mathbf{g}_\\xi\\| \\,\\|\\mathbf{g}_\\eta\\|} \\right) \\right|$. The skewness metric is the mean of $\\delta(\\xi,\\eta)$ over all interior nodes. All angles must be expressed in radians.\n\n2. A smoothness metric based on second differences. Using centered second differences, define $\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ and $\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$. At each interior node, compute $s(\\xi,\\eta) = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$. The smoothness metric is the mean of $s(\\xi,\\eta)$ over all interior nodes.\n\nYour program must:\n- Implement both grid A and grid B using the derived transfinite interpolation construction.\n- Compute the two metrics for each grid.\n- For each test case, return a list of six floating-point numbers: $[\\text{skew}_A,\\text{skew}_B,\\text{smooth}_A,\\text{smooth}_B,\\text{skew}_A-\\text{skew}_B,\\text{smooth}_A-\\text{smooth}_B]$.\n\nTest suite:\n- Case 1 (balanced mild curvature): $N_\\xi = 21$, $N_\\eta = 21$, $(a,b,c,d) = (0.2, 0.2, 0.2, 0.2)$.\n- Case 2 (asymmetric stronger curvature, higher resolution): $N_\\xi = 41$, $N_\\eta = 31$, $(a,b,c,d) = (0.3, -0.1, 0.25, 0.0)$.\n- Case 3 (rectangular domain): $N_\\xi = 17$, $N_\\eta = 19$, $(a,b,c,d) = (0.0, 0.0, 0.0, 0.0)$.\n\nAngle unit: all angles must be in radians. There are no other physical units.\n\nFinal output format:\nYour program should produce a single line of output containing a Python-style list of three elements (one per test case), where each element is itself a list of six floating-point results in the order specified above, for example, [[...case1...],[...case2...],[...case3...]].", "solution": "### 1. Derivation of the Transfinite Interpolation Formula\n\nThe objective is to find a mapping $\\mathbf{X}(\\xi, \\eta) : [0,1]^2 \\to \\mathbb{R}^2$ that matches four given boundary curves: $\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$, $\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$, $\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$, and $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$. The construction uses transfinite interpolation (TFI), which extends standard polynomial interpolation to functions, i.e., it interpolates over a continuum of points.\n\nWe define two projection operators, $P_\\xi$ and $P_\\eta$, which interpolate data from the boundaries.\nThe projector $P_\\xi$ constructs a ruled surface between the boundaries $\\mathbf{C}_0(\\eta)$ and $\\mathbf{C}_1(\\eta)$ using blending functions $g_0(\\xi)$ and $g_1(\\xi)$:\n$$P_\\xi[\\mathbf{F}](\\xi,\\eta) = g_0(\\xi) \\mathbf{F}(0,\\eta) + g_1(\\xi) \\mathbf{F}(1,\\eta)$$\nThe projector $P_\\eta$ constructs a ruled surface between the boundaries $\\mathbf{B}_0(\\xi)$ and $\\mathbf{B}_1(\\xi)$ using blending functions $h_0(\\eta)$ and $h_1(\\eta)$:\n$$P_\\eta[\\mathbf{F}](\\xi,\\eta) = h_0(\\eta) \\mathbf{F}(\\xi,0) + h_1(\\eta) \\mathbf{F}(\\xi,1)$$\nThe blending functions must satisfy endpoint and partition-of-unity properties: $g_0(0)=1, g_0(1)=0, g_1(0)=0, g_1(1)=1$, and $g_0(\\xi)+g_1(\\xi)=1$. The same applies to $h_0, h_1$.\n\nA simple sum of these two projectors, $(P_\\xi + P_\\eta)[\\mathbf{X}]$, would double-count the information at the corners. The principle of inclusion-exclusion dictates that we must subtract the common part, which is the information interpolated by both operators. This leads to the Boolean sum of the projectors: $P_{TFI} = P_\\xi \\oplus P_\\eta = P_\\xi + P_\\eta - P_\\xi P_\\eta$.\n\nApplying this to our mapping function $\\mathbf{X}$ gives the interpolation formula:\n$$\\mathbf{X}(\\xi,\\eta) = (P_\\xi + P_\\eta - P_\\xi P_\\eta)[\\mathbf{X}]$$\nLet's expand the terms:\n1. $P_\\xi[\\mathbf{X}](\\xi,\\eta) = g_0(\\xi) \\mathbf{X}(0,\\eta) + g_1(\\xi) \\mathbf{X}(1,\\eta) = g_0(\\xi) \\mathbf{C}_0(\\eta) + g_1(\\xi) \\mathbf{C}_1(\\eta)$.\n2. $P_\\eta[\\mathbf{X}](\\xi,\\eta) = h_0(\\eta) \\mathbf{X}(\\xi,0) + h_1(\\eta) \\mathbf{X}(\\xi,1) = h_0(\\eta) \\mathbf{B}_0(\\xi) + h_1(\\eta) \\mathbf{B}_1(\\xi)$.\n3. The product term $P_\\xi P_\\eta[\\mathbf{X}]$ is $P_\\xi (P_\\eta[\\mathbf{X}])$. We apply $P_\\xi$ to the result of $P_\\eta$:\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=0} + g_1(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=1}$$\n$$= g_0(\\xi) [h_0(\\eta) \\mathbf{B}_0(0) + h_1(\\eta) \\mathbf{B}_1(0)] + g_1(\\xi) [h_0(\\eta) \\mathbf{B}_0(1) + h_1(\\eta) \\mathbf{B}_1(1)]$$\nUsing the corner consistency conditions, e.g., $\\mathbf{B}_0(0) = \\mathbf{X}(0,0)$, $\\mathbf{B}_1(0) = \\mathbf{X}(0,1)$, etc., this simplifies to:\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi)h_0(\\eta)\\mathbf{X}(0,0) + g_0(\\xi)h_1(\\eta)\\mathbf{X}(0,1) + g_1(\\xi)h_0(\\eta)\\mathbf{X}(1,0) + g_1(\\xi)h_1(\\eta)\\mathbf{X}(1,1)$$\nThis is a tensor product interpolation of the four corner points.\n\nCombining these terms yields the final TFI formula, often called a Coons patch:\n$$\\mathbf{X}(\\xi,\\eta) = \\sum_{i=0}^{1} g_i(\\xi) \\mathbf{C}_i(\\eta) + \\sum_{j=0}^{1} h_j(\\eta) \\mathbf{B}_j(\\xi) - \\sum_{i=0}^{1}\\sum_{j=0}^{1} g_i(\\xi) h_j(\\eta) \\mathbf{X}(i,j)$$\nwhere $\\mathbf{C}_i(\\eta)$, $\\mathbf{B}_j(\\xi)$, and $\\mathbf{X}(i,j)$ represent boundary and corner data.\n\n### 2. Grid Generation and Blending Functions\n\nThe continuous mapping $\\mathbf{X}(\\xi,\\eta)$ is discretized on a uniform computational grid of size $N_\\xi \\times N_\\eta$. The computational coordinates are $\\xi_i = i/(N_\\xi-1)$ for $i \\in \\{0, \\dots, N_\\xi-1\\}$ and $\\eta_j = j/(N_\\eta-1)$ for $j \\in \\{0, \\dots, N_\\eta-1\\}$. The physical grid nodes are then computed as $\\mathbf{X}_{i,j} = \\mathbf{X}(\\xi_i, \\eta_j)$.\n\nTwo types of grids are generated based on different choices of blending functions:\n- **Grid A (Bilinear TFI):** Uses linear blending functions.\n  $$g_1(\\xi) = \\xi, \\quad g_0(\\xi) = 1-\\xi$$\n  $$h_1(\\eta) = \\eta, \\quad h_0(\\eta) = 1-\\eta$$\n- **Grid B (Cubic TFI):** Uses cubic Hermite blending functions for parametric stretching, which provide zero derivative at the endpoints, leading to boundary-orthogonal grid lines if the boundary curves are aligned with Cartesian axes.\n  $$\\sigma(t) = 3t^2 - 2t^3$$\n  $$g_1(\\xi) = \\sigma(\\xi), \\quad g_0(\\xi) = 1 - \\sigma(\\xi)$$\n  $$h_1(\\eta) = \\sigma(\\eta), \\quad h_0(\\eta) = 1 - \\sigma(\\eta)$$\n\n### 3. Grid Quality Metrics\n\nThe quality of the generated grids is assessed using two metrics evaluated on the interior nodes of the grid (i.e., for $i \\in \\{1, \\dots, N_\\xi-2\\}$ and $j \\in \\{1, \\dots, N_\\eta-2\\}$).\n\n**Skewness Metric:** This metric quantifies the deviation from orthogonality. The tangent (covariant base) vectors $\\mathbf{g}_\\xi = \\partial\\mathbf{X}/\\partial\\xi$ and $\\mathbf{g}_\\eta = \\partial\\mathbf{X}/\\partial\\eta$ are approximated using second-order centered finite differences:\n$$\\mathbf{g}_\\xi(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}}{2\\Delta\\xi}, \\quad \\mathbf{g}_\\eta(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}}{2\\Delta\\eta}$$\nSince the scaling factor $2\\Delta\\xi$ does not affect the angle, the problem defines the vectors for angle calculation as $\\mathbf{g}_\\xi \\approx \\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}$ and $\\mathbf{g}_\\eta \\approx \\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}$. The angle $\\theta$ between them is found via the dot product. The local orthogonality deviation is $\\delta_{i,j} = |\\frac{\\pi}{2} - \\theta_{i,j}|$. The skewness metric is the average of $\\delta_{i,j}$ over all interior nodes.\n\n**Smoothness Metric:** This metric quantifies the variation in grid spacing. It is based on the magnitude of the second derivatives of the mapping function, approximated by centered second differences:\n$$\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}_{i+1,j} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i-1,j}$$\n$$\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}_{i,j+1} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i,j-1}$$\nThe local smoothness value is $s_{i,j} = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$. The smoothness metric is the average of $s_{i,j}$ over all interior nodes.\n\n### 4. Algorithmic Implementation\n\nFor each test case specified by $(N_\\xi, N_\\eta, a, b, c, d)$:\n1.  Define the blending functions $\\{g_0, g_1, h_0, h_1\\}$ for Grid A (linear) and Grid B (cubic).\n2.  Create uniform computational coordinate arrays `xi_v` and `eta_v` of sizes $N_\\xi$ and $N_\\eta$.\n3.  For each grid type (A and B):\n    a.  Evaluate the four boundary curves $\\mathbf{B}_0(\\xi), \\mathbf{B}_1(\\xi), \\mathbf{C}_0(\\eta), \\mathbf{C}_1(\\eta)$ at the discrete points in `xi_v` and `eta_v`.\n    b.  Apply the derived TFI formula to compute the physical grid coordinates $\\mathbf{X}_{i,j}$ for all $(i,j)$. This involves careful use of array broadcasting for an efficient implementation.\n    c.  Compute the skewness and smoothness metrics by applying the finite difference formulas to the interior of the grid $\\mathbf{X}$.\n4.  Consolidate the four computed metrics ($\\text{skew}_A, \\text{skew}_B, \\text{smooth}_A, \\text{smooth}_B$) and their differences into a single list of six values.\n5.  Collect the results for all test cases and format the final output as specified.\n\nThe case where $a=b=c=d=0$ serves as a validation check. Here, the boundaries form a unit square. The TFI formula should reproduce the identity mapping $\\mathbf{X}(\\xi,\\eta) = (\\xi,\\eta)$, resulting in a perfect Cartesian grid for which both skewness and smoothness metrics are identically zero.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and compares two algebraic structured grids using different\n    transfinite interpolation (TFI) strategies and computes grid quality metrics.\n    \"\"\"\n\n    # --- Blending Functions ---\n    # Grid A: Linear blending functions\n    def g1_A(xi): return xi\n    def g0_A(xi): return 1.0 - xi\n    def h1_A(eta): return eta\n    def h0_A(eta): return 1.0 - eta\n\n    # Grid B: Cubic (Hermite) blending functions\n    def sigma(t): return 3.0 * t**2 - 2.0 * t**3\n    def g1_B(xi): return sigma(xi)\n    def g0_B(xi): return 1.0 - sigma(xi)\n    def h1_B(eta): return sigma(eta)\n    def h0_B(eta): return 1.0 - sigma(eta)\n\n    # --- Boundary Curve Definitions ---\n    def B0(xi, a, b, c, d):\n        x = xi + a * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.zeros_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def B1(xi, a, b, c, d):\n        x = xi + b * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.ones_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def C0(eta, a, b, c, d):\n        x = np.zeros_like(eta)\n        y = eta + c * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def C1(eta, a, b, c, d):\n        x = np.ones_like(eta)\n        y = eta + d * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def generate_grid(N_xi, N_eta, params, g_funcs, h_funcs):\n        \"\"\"\n        Generates a 2D structured grid using transfinite interpolation.\n        \"\"\"\n        a, b, c, d = params\n        g0, g1 = g_funcs\n        h0, h1 = h_funcs\n        \n        xi_v = np.linspace(0.0, 1.0, N_xi)\n        eta_v = np.linspace(0.0, 1.0, N_eta)\n        \n        # 'ij' indexing ensures shape is (N_xi, N_eta)\n        XI, ETA = np.meshgrid(xi_v, eta_v, indexing='ij')\n\n        # Evaluate boundary curves on the discrete points\n        B0_vals = B0(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        B1_vals = B1(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        C0_vals = C0(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n        C1_vals = C1(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n\n        # Evaluate blending functions on the computational grid\n        G0 = g0(XI)\n        G1 = g1(XI)\n        H0 = h0(ETA)\n        H1 = h1(ETA)\n\n        # Apply TFI formula using numpy broadcasting\n        # Term 1: Interpolation from xi-boundaries\n        term1 = G0[..., None] * C0_vals[None, :, :] + G1[..., None] * C1_vals[None, :, :]\n        # Term 2: Interpolation from eta-boundaries\n        term2 = H0[..., None] * B0_vals[:, None, :] + H1[..., None] * B1_vals[:, None, :]\n        \n        # Term 3: Corner correction term\n        X00, X10 = B0_vals[0], B0_vals[-1]\n        X01, X11 = B1_vals[0], B1_vals[-1]\n        \n        term3 = (G0[..., None] * H0[..., None] * X00[None, None, :] +\n                 G1[..., None] * H0[..., None] * X10[None, None, :] +\n                 G0[..., None] * H1[..., None] * X01[None, None, :] +\n                 G1[..., None] * H1[..., None] * X11[None, None, :])\n\n        X = term1 + term2 - term3\n        return X\n\n    def calculate_metrics(X):\n        \"\"\"\n        Computes skewness and smoothness metrics for a given grid.\n        \"\"\"\n        N_xi, N_eta, _ = X.shape\n        if N_xi  3 or N_eta  3:\n            return 0.0, 0.0\n\n        # --- Skewness Metric ---\n        # Approximate tangent vectors using centered differences on interior nodes\n        g_xi = X[2:, 1:-1, :] - X[:-2, 1:-1, :]\n        g_eta = X[1:-1, 2:, :] - X[1:-1, :-2, :]\n\n        # Calculate angle between tangent vectors\n        dot_product = np.sum(g_xi * g_eta, axis=2)\n        norm_g_xi = np.linalg.norm(g_xi, axis=2)\n        norm_g_eta = np.linalg.norm(g_eta, axis=2)\n        \n        denominator = norm_g_xi * norm_g_eta\n        # Avoid division by zero for robustness\n        cos_theta = np.divide(dot_product, denominator, \n                              out=np.zeros_like(dot_product), \n                              where=denominator != 0)\n        \n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        # Orthogonality deviation in radians\n        ortho_dev = np.abs(np.pi / 2.0 - theta)\n        skewness = np.mean(ortho_dev)\n        \n        # --- Smoothness Metric ---\n        # Approximate second derivatives using centered differences\n        d2X_dxi2 = X[2:, 1:-1, :] - 2 * X[1:-1, 1:-1, :] + X[:-2, 1:-1, :]\n        d2X_deta2 = X[1:-1, 2:, :] - 2 * X[1:-1, 1:-1, :] + X[1:-1, :-2, :]\n\n        # Compute magnitude of second derivatives\n        norm_sq_d2xi = np.sum(d2X_dxi2**2, axis=2)\n        norm_sq_d2eta = np.sum(d2X_deta2**2, axis=2)\n        \n        s = np.sqrt(norm_sq_d2xi + norm_sq_d2eta)\n        smoothness = np.mean(s)\n        \n        return skewness, smoothness\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"N_xi\": 21, \"N_eta\": 21, \"params\": (0.2, 0.2, 0.2, 0.2)},\n        {\"N_xi\": 41, \"N_eta\": 31, \"params\": (0.3, -0.1, 0.25, 0.0)},\n        {\"N_xi\": 17, \"N_eta\": 19, \"params\": (0.0, 0.0, 0.0, 0.0)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N_xi, N_eta, params = case[\"N_xi\"], case[\"N_eta\"], case[\"params\"]\n\n        # Generate Grid A and calculate metrics\n        grid_A = generate_grid(N_xi, N_eta, params, (g0_A, g1_A), (h0_A, h1_A))\n        skew_A, smooth_A = calculate_metrics(grid_A)\n\n        # Generate Grid B and calculate metrics\n        grid_B = generate_grid(N_xi, N_eta, params, (g0_B, g1_B), (h0_B, h1_B))\n        skew_B, smooth_B = calculate_metrics(grid_B)\n        \n        skew_diff = skew_A - skew_B\n        smooth_diff = smooth_A - smooth_B\n\n        case_results = [skew_A, skew_B, smooth_A, smooth_B, skew_diff, smooth_diff]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in all_results)}]\")\n\nsolve()\n```", "id": "3290621"}]}