{"hands_on_practices": [{"introduction": "Transfinite interpolation (TFI) provides a powerful algebraic method for generating structured grids. The fundamental principle involves blending information from the boundary curves to define the interior mapping. This first practice guides you through the core implementation of a TFI surface, starting from four boundary curves defined by cubic splines. By constructing the blending functions and the crucial corner correction term, you will gain a concrete understanding of how TFI systematically combines one-dimensional interpolations to form a two-dimensional grid that precisely matches its boundaries. [@problem_id:3384022]", "problem": "Consider the construction of a two-dimensional parametric surface patch for grid generation using Transfinite Interpolation (TFI). Four boundary polylines are prescribed as parametric cubic splines: the two boundaries along the $t$-direction, denoted $C_{t0}(s)$ and $C_{t1}(s)$, and the two boundaries along the $s$-direction, denoted $C_{s0}(t)$ and $C_{s1}(t)$. The corner points are defined by $P_{00}$ at $(s,t)=(0,0)$, $P_{10}$ at $(s,t)=(1,0)$, $P_{01}$ at $(s,t)=(0,1)$, and $P_{11}$ at $(s,t)=(1,1)$. The goal is to compute the interior mapping $P(s,t)$ that blends the boundary curves according to the transfinite interpolation principle and to verify the inclusion-exclusion correction.\n\nFundamental base assumptions:\n- Parametric cubic spline interpolation produces $C^2$ continuous curves that exactly interpolate the given data points for each boundary curve.\n- Transfinite interpolation constructs a surface from its boundary curves by blending one-dimensional interpolants along $s$ and $t$ in a way that enforces boundary consistency and removes double-counting of corner contributions through inclusion-exclusion.\n\nDefine the four corner points as:\n- $P_{00} = (0.5, 0.1)$,\n- $P_{10} = (2.1, 0.3)$,\n- $P_{01} = (0.0, 1.7)$,\n- $P_{11} = (2.2, 1.9)$.\n\nDefine the four boundary polylines by their parametric cubic spline control points. For the boundary at $t=0$, $C_{t0}(s)$, use the parameter values $s \\in \\{0, 0.25, 0.5, 0.75, 1\\}$ with corresponding points:\n- $s=0$: $(0.5, 0.1)$,\n- $s=0.25$: $(0.9, -0.05)$,\n- $s=0.5$: $(1.4, 0.20)$,\n- $s=0.75$: $(1.8, 0.35)$,\n- $s=1$: $(2.1, 0.3)$.\n\nFor the boundary at $t=1$, $C_{t1}(s)$, use the parameter values $s \\in \\{0, 0.35, 0.7, 1\\}$ with corresponding points:\n- $s=0$: $(0.0, 1.7)$,\n- $s=0.35$: $(0.8, 2.0)$,\n- $s=0.7$: $(1.5, 1.4)$,\n- $s=1$: $(2.2, 1.9)$.\n\nFor the boundary at $s=0$, $C_{s0}(t)$, use the parameter values $t \\in \\{0, 0.4, 0.8, 1\\}$ with corresponding points:\n- $t=0$: $(0.5, 0.1)$,\n- $t=0.4$: $(0.2, 0.8)$,\n- $t=0.8$: $(-0.1, 1.3)$,\n- $t=1$: $(0.0, 1.7)$.\n\nFor the boundary at $s=1$, $C_{s1}(t)$, use the parameter values $t \\in \\{0, 0.2, 0.6, 1\\}$ with corresponding points:\n- $t=0$: $(2.1, 0.3)$,\n- $t=0.2$: $(2.6, 0.5)$,\n- $t=0.6$: $(2.4, 1.2)$,\n- $t=1$: $(2.2, 1.9)$.\n\nLet the inclusion-exclusion corner correction be the bilinear blend\n$$\nB(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)t\\,P_{01} + st\\,P_{11}.\n$$\nStarting from the transfinite interpolation principle, derive $P(s,t)$ as a combination of the boundary interpolants along $s$ and $t$, together with $B(s,t)$, to avoid double-counting of corners. Implement $P(s,t)$ explicitly for the prescribed boundary cubic splines.\n\nTest suite:\nEvaluate at the following set of parameter pairs $(s,t)$:\n- Corners: $(0,0)$, $(1,0)$, $(0,1)$, $(1,1)$.\n- Edge midpoints: $(0.5,0)$, $(0.5,1)$, $(0,0.5)$, $(1,0.5)$.\n- Interior points: $(0.3,0.4)$, $(0.75,0.25)$.\n\nFor each $(s,t)$, compute:\n1. The inclusion-exclusion residual defined by the maximum absolute component of $R(s,t) = \\left[H(s,t)+V(s,t)\\right] - P(s,t) - B(s,t)$, where $H(s,t)$ is the $t$-direction blend and $V(s,t)$ is the $s$-direction blend used in transfinite interpolation.\n2. The boundary consistency error defined by the maximum absolute component of the difference between $P(s,t)$ and the applicable boundary curve(s) when $(s,t)$ lies on an edge: if $t=0$, compare to $C_{t0}(s)$; if $t=1$, compare to $C_{t1}(s)$; if $s=0$, compare to $C_{s0}(t)$; if $s=1$, compare to $C_{s1}(t)$. For corners, compare against both applicable boundaries and report the maximum of the two; for interior points, report $0$.\n3. The corner double-counting error before correction at corners, defined by the maximum absolute component of $\\left[H(s,t)+V(s,t)\\right] - P_{\\mathrm{corner}}$ where $P_{\\mathrm{corner}}$ is the corresponding corner point $P_{00}$, $P_{10}$, $P_{01}$, or $P_{11}$. For non-corner points, report $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one $(s,t)$ pair from the test suite and is itself a list of three floating-point numbers in the order described above (for example, $[[e_{11},e_{12},e_{13}],[e_{21},e_{22},e_{23}],\\ldots]$). All quantities are unitless real numbers. Round nothing; report raw floating-point results produced by the computation.", "solution": "The user has provided a well-defined problem in the domain of computational grid generation, specifically concerning the application of Transfinite Interpolation (TFI).\n\n### Step 1: Extract Givens\n- **Corner Points**:\n  - $P_{00} = (0.5, 0.1)$\n  - $P_{10} = (2.1, 0.3)$\n  - $P_{01} = (0.0, 1.7)$\n  - $P_{11} = (2.2, 1.9)$\n- **Boundary $C_{t0}(s)$ (at $t=0$)**: Parametric cubic spline through points:\n  - $(s, P) \\in \\{(0, (0.5, 0.1)), (0.25, (0.9, -0.05)), (0.5, (1.4, 0.20)), (0.75, (1.8, 0.35)), (1, (2.1, 0.3))\\}$\n- **Boundary $C_{t1}(s)$ (at $t=1$)**: Parametric cubic spline through points:\n  - $(s, P) \\in \\{(0, (0.0, 1.7)), (0.35, (0.8, 2.0)), (0.7, (1.5, 1.4)), (1, (2.2, 1.9))\\}$\n- **Boundary $C_{s0}(t)$ (at $s=0$)**: Parametric cubic spline through points:\n  - $(t, P) \\in \\{(0, (0.5, 0.1)), (0.4, (0.2, 0.8)), (0.8, (-0.1, 1.3)), (1, (0.0, 1.7))\\}$\n- **Boundary $C_{s1}(t)$ (at $s=1$)**: Parametric cubic spline through points:\n  - $(t, P) \\in \\{(0, (2.1, 0.3)), (0.2, (2.6, 0.5)), (0.6, (2.4, 1.2)), (1, (2.2, 1.9))\\}$\n- **Bilinear Blend Definition**:\n  $B(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)t\\,P_{01} + st\\,P_{11}$\n- **Test Suite**:\n  - $(s,t) \\in \\{(0,0), (1,0), (0,1), (1,1), (0.5,0), (0.5,1), (0,0.5), (1,0.5), (0.3,0.4), (0.75,0.25)\\}$\n- **Error Metrics**: For each test point, compute a list of three values:\n  1. Inclusion-Exclusion Residual: $\\max|\\left[H(s,t)+V(s,t)\\right] - P(s,t) - B(s,t)|$\n  2. Boundary Consistency Error: $\\max|P(s,t) - C_{\\text{boundary}}|$ if on boundary, else $0$.\n  3. Corner Double-Counting Error: $\\max|\\left[H(s,t)+V(s,t)\\right] - P_{\\mathrm{corner}}|$ if at a corner, else $0$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the established theory of transfinite interpolation, a standard technique in computer-aided geometric design (CAGD) and computational fluid dynamics (CFD) for generating structured grids. All concepts and formulae are standard.\n- **Well-Posed**: The problem provides all necessary information: four boundary curves and four corner points. A check confirms that the endpoints of the boundary curves correctly coincide with the specified corner points (e.g., $C_{t0}(0) = P_{00}$, $C_{t0}(1) = P_{10}$, $C_{s0}(0) = P_{00}$, $C_{s0}(1)=P_{01}$, etc.), ensuring a closed, valid boundary loop. The method for interpolation (TFI) is explicitly defined.\n- **Objective**: The problem is stated using precise mathematical language, and the quantities to be computed are defined by unambiguous formulae.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, self-contained, and objective. It is **valid**. We proceed to the solution.\n\n### Principle-Based Solution\n\nThe objective is to construct a parametric surface $P(s,t)$ that interpolates four given boundary curves $C_{t0}(s)$, $C_{t1}(s)$, $C_{s0}(t)$, and $C_{s1}(t)$, which form the edges of a unit square in the parametric domain $(s,t) \\in [0,1] \\times [0,1]$. This is achieved using Transfinite Interpolation (TFI).\n\nThe core idea of TFI is to blend one-dimensional interpolations. We first define two surfaces, each interpolating an opposing pair of boundary curves.\n\n$1$. The first surface, which we denote as $H(s,t)$, interpolates the boundaries at $t=0$ and $t=1$ (the \"horizontal\" boundaries in the parameter plane) using linear blending functions in the $t$-direction:\n$$H(s,t) = (1-t)C_{t0}(s) + t C_{t1}(s)$$\nThis construction ensures that $H(s,0) = C_{t0}(s)$ and $H(s,1) = C_{t1}(s)$.\n\n$2$. The second surface, $V(s,t)$, interpolates the boundaries at $s=0$ and $s=1$ (the \"vertical\" boundaries) using linear blending functions in the $s$-direction:\n$$V(s,t) = (1-s)C_{s0}(t) + s C_{s1}(t)$$\nThis construction ensures that $V(0,t) = C_{s0}(t)$ and $V(1,t) = C_{s1}(t)$.\n\nA naive approach would be to sum these two surfaces, $H(s,t) + V(s,t)$. However, this leads to an incorrect result because the contributions from the corners are counted twice. For instance, at the corner $(s,t)=(0,0)$:\n- $H(0,0) = (1-0)C_{t0}(0) + 0 \\cdot C_{t1}(0) = C_{t0}(0) = P_{00}$\n- $V(0,0) = (1-0)C_{s0}(0) + 0 \\cdot C_{s1}(0) = C_{s0}(0) = P_{00}$\nThe sum is $H(0,0) + V(0,0) = P_{00} + P_{00} = 2P_{00}$. This over-counting occurs at all four corners.\n\nThe principle of inclusion-exclusion resolves this. We must subtract the portion of the interpolation that is common to both $H(s,t)$ and $V(s,t)$. This common portion is the surface that interpolates only the four corner points $P_{00}$, $P_{10}$, $P_{01}$, and $P_{11}$. A bilinear interpolation of the corners achieves this:\n$$B(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}$$\nThis is the bilinear blend specified in the problem. Notice that $B(s,t)$ is what one obtains by applying the $s$-direction interpolation scheme to the boundaries of the $t$-direction interpolation scheme (or vice-versa).\n\nThe final transfinite interpolation surface $P(s,t)$ is constructed by summing the two directional interpolants and subtracting the doubly-counted bilinear corner blend:\n$$P(s,t) = H(s,t) + V(s,t) - B(s,t)$$\n\nThis formulation correctly satisfies all boundary conditions. For instance, let's verify the boundary at $t=0$:\n$P(s,0) = H(s,0) + V(s,0) - B(s,0)$\n- $H(s,0) = (1-0)C_{t0}(s) + 0 \\cdot C_{t1}(s) = C_{t0}(s)$\n- $V(s,0) = (1-s)C_{s0}(0) + sC_{s1}(0) = (1-s)P_{00} + sP_{10}$\n- $B(s,0) = (1-s)(1-0)P_{00} + s(1-0)P_{10} + (1-s)\\cdot 0 \\cdot P_{01} + s \\cdot 0 \\cdot P_{11} = (1-s)P_{00} + sP_{10}$\nSubstituting these into the equation for $P(s,0)$:\n$P(s,0) = C_{t0}(s) + \\left[(1-s)P_{00} + sP_{10}\\right] - \\left[(1-s)P_{00} + sP_{10}\\right] = C_{t0}(s)$\nThe surface correctly reproduces the boundary curve $C_{t0}(s)$. A similar derivation shows that $P(s,t)$ correctly reproduces the other three boundary curves.\n\nThe implementation will proceed by:\n1.  Defining the four parametric cubic splines $C_{t0}(s)$, $C_{t1}(s)$, $C_{s0}(t)$, and $C_{s1}(t)$ from the given control points using `scipy.interpolate.CubicSpline`. A `natural` boundary condition will be assumed for the splines.\n2.  Implementing functions for $H(s,t)$, $V(s,t)$, $B(s,t)$, and the final surface $P(s,t)$ based on the derived formulae.\n3.  Iterating through the test suite of $(s,t)$ pairs and calculating the three specified error metrics.\n\n- **Inclusion-Exclusion Residual**: $R(s,t) = [H(s,t)+V(s,t)] - P(s,t) - B(s,t)$. From the definition of $P(s,t)$, we have $P(s,t) + B(s,t) = H(s,t) + V(s,t)$. Therefore, $R(s,t)$ must be identically the zero vector, and its maximum absolute component will be $0$ (within floating-point precision). This calculation serves as a sanity check on the implementation.\n- **Boundary Consistency Error**: As derived above, the TFI surface $P(s,t)$ is guaranteed to match the boundary curves exactly. This error will therefore be $0$ for all boundary points (within floating-point precision). For interior points, it is defined to be $0$.\n- **Corner Double-Counting Error**: This quantity measures the error at a corner if one were to naively sum $H(s,t)$ and $V(s,t)$. At a corner, say $(s,t)=(0,0)$, the error is $\\max|H(0,0)+V(0,0)-P_{00}| = \\max|P_{00}+P_{00}-P_{00}| = \\max|P_{00}|$. This will be non-zero and represents the magnitude of the corner over-counting which is corrected by subtracting $B(s,t)$. For all non-corner points, this error is defined to be $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes TFI surface points and associated error metrics for a given test suite.\n    \"\"\"\n    # 1. DEFINE GIVEN DATA\n    # Corner points\n    P00 = np.array([0.5, 0.1])\n    P10 = np.array([2.1, 0.3])\n    P01 = np.array([0.0, 1.7])\n    P11 = np.array([2.2, 1.9])\n\n    # Boundary curve spline parameters and points\n    # C_t0(s) at t=0\n    s_t0 = [0, 0.25, 0.5, 0.75, 1]\n    pts_t0 = np.array([[0.5, 0.1], [0.9, -0.05], [1.4, 0.20], [1.8, 0.35], [2.1, 0.3]])\n\n    # C_t1(s) at t=1\n    s_t1 = [0, 0.35, 0.7, 1]\n    pts_t1 = np.array([[0.0, 1.7], [0.8, 2.0], [1.5, 1.4], [2.2, 1.9]])\n\n    # C_s0(t) at s=0\n    t_s0 = [0, 0.4, 0.8, 1]\n    pts_s0 = np.array([[0.5, 0.1], [0.2, 0.8], [-0.1, 1.3], [0.0, 1.7]])\n    \n    # C_s1(t) at s=1\n    t_s1 = [0, 0.2, 0.6, 1]\n    pts_s1 = np.array([[2.1, 0.3], [2.6, 0.5], [2.4, 1.2], [2.2, 1.9]])\n\n    # 2. CREATE PARAMETRIC CUBIC SPLINES FOR BOUNDARIES\n    # Use 'natural' boundary conditions as a standard choice.\n    spline_t0 = CubicSpline(s_t0, pts_t0, bc_type='natural', axis=0)\n    spline_t1 = CubicSpline(s_t1, pts_t1, bc_type='natural', axis=0)\n    spline_s0 = CubicSpline(t_s0, pts_s0, bc_type='natural', axis=0)\n    spline_s1 = CubicSpline(t_s1, pts_s1, bc_type='natural', axis=0)\n\n    # Wrapper functions for clarity\n    def C_t0(s): return spline_t0(s)\n    def C_t1(s): return spline_t1(s)\n    def C_s0(t): return spline_s0(t)\n    def C_s1(t): return spline_s1(t)\n\n    # 3. DEFINE TFI COMPONENT FUNCTIONS\n    def H(s, t):\n        return (1 - t) * C_t0(s) + t * C_t1(s)\n    \n    def V(s, t):\n        return (1 - s) * C_s0(t) + s * C_s1(t)\n    \n    def B(s, t):\n        return (1 - s) * (1 - t) * P00 + s * (1 - t) * P10 + \\\n               (1 - s) * t * P01 + s * t * P11\n    \n    def P(s, t):\n        return H(s, t) + V(s, t) - B(s, t)\n\n    # 4. DEFINE TEST SUITE\n    test_cases = [\n        # Corners\n        (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0),\n        # Edge midpoints\n        (0.5, 0.0), (0.5, 1.0), (0.0, 0.5), (1.0, 0.5),\n        # Interior points\n        (0.3, 0.4), (0.75, 0.25)\n    ]\n    \n    results = []\n    \n    # 5. PROCESS TEST CASES AND CALCULATE ERRORS\n    for s, t in test_cases:\n        # Error 1: Inclusion-Exclusion Residual\n        residual_vec = (H(s, t) + V(s, t)) - P(s, t) - B(s, t)\n        e1 = np.max(np.abs(residual_vec))\n\n        # Error 2: Boundary Consistency Error\n        e2 = 0.0\n        # A small tolerance is good practice, but for these exact inputs, direct comparison is fine.\n        is_on_boundary_t0 = (t == 0.0)\n        is_on_boundary_t1 = (t == 1.0)\n        is_on_boundary_s0 = (s == 0.0)\n        is_on_boundary_s1 = (s == 1.0)\n        \n        is_on_boundary = is_on_boundary_t0 or is_on_boundary_t1 or is_on_boundary_s0 or is_on_boundary_s1\n        \n        if is_on_boundary:\n            err_t0 = np.max(np.abs(P(s, t) - C_t0(s))) if is_on_boundary_t0 else -1.0\n            err_t1 = np.max(np.abs(P(s, t) - C_t1(s))) if is_on_boundary_t1 else -1.0\n            err_s0 = np.max(np.abs(P(s, t) - C_s0(t))) if is_on_boundary_s0 else -1.0\n            err_s1 = np.max(np.abs(P(s, t) - C_s1(t))) if is_on_boundary_s1 else -1.0\n            e2 = max(err for err in [err_t0, err_t1, err_s0, err_s1] if err >= 0.0)\n\n        # Error 3: Corner Double-Counting Error\n        e3 = 0.0\n        if (s, t) == (0.0, 0.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P00))\n        elif (s, t) == (1.0, 0.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P10))\n        elif (s, t) == (0.0, 1.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P01))\n        elif (s, t) == (1.0, 1.0):\n            e3 = np.max(np.abs(H(s, t) + V(s, t) - P11))\n        \n        results.append([e1, e2, e3])\n\n    # 6. FORMAT AND PRINT OUTPUT\n    # The default string representation of a list is '[item1, item2, ...]'\n    # which matches the required inner format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3384022"}, {"introduction": "Once a grid has been generated, its quality must be assessed to ensure it is suitable for numerical simulation. This practice moves from grid construction to grid analysis, connecting transfinite interpolation to the principles of differential geometry. You will derive the metric tensor components for a Coons patch, which quantify how the mapping from computational to physical space distorts lengths and angles. This exercise will allow you to calculate a non-orthogonality metric, providing a direct measure of grid skewness—a key factor influencing the accuracy of numerical schemes. [@problem_id:3384066]", "problem": "Consider a two-dimensional transfinite interpolation (Coons patch) used for structured grid generation in computational fluid dynamics. The patch is defined over the unit square in computational coordinates $(s,t) \\in [0,1] \\times [0,1]$ by four boundary curves in physical space $\\mathbb{R}^2$:\n- Bottom boundary at $t=0$: $C_0(s) = \\big(2s,\\,0\\big)$,\n- Top boundary at $t=1$: $C_1(s) = \\big(2s,\\,1 + \\epsilon \\sin(\\pi s)\\big)$,\n- Left boundary at $s=0$: $D_0(t) = \\big(\\delta \\sin(\\pi t),\\,t\\big)$,\n- Right boundary at $s=1$: $D_1(t) = \\big(2 + \\delta \\sin(\\pi t),\\,t\\big)$,\n\nwith corner consistency ensured at $(s,t) \\in \\{0,1\\}^2$. The Coons patch is constructed by bilinear blending of these boundary curves,\n$$\nP(s,t) = (1-t)\\,C_0(s) + t\\,C_1(s) + (1-s)\\,D_0(t) + s\\,D_1(t) - \\big[(1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}\\big],\n$$\nwhere $P_{00},P_{10},P_{01},P_{11}$ are the four corners implied by the boundary curves.\n\nStarting from this definition, and using only fundamental definitions from differential geometry of curvilinear coordinates (metric tensor and inner product), perform the following:\n1. Derive $P(s,t)$ explicitly in component form.\n2. Compute the partial derivatives $P_s = \\partial P/\\partial s$ and $P_t = \\partial P/\\partial t$.\n3. Derive the metric coefficients $g_{ss} = \\|P_s\\|^2$, $g_{tt} = \\|P_t\\|^2$, and $g_{st} = P_s \\cdot P_t$ for the patch.\n4. Define the non-orthogonality (skewness) measure as\n$$\nM(s,t) \\equiv \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)\\,g_{tt}(s,t)}},\n$$\nand explain why $M=0$ corresponds to orthogonality of grid lines while larger $M$ indicates greater skewness.\n5. Evaluate $M(s,t)$ at $s=\\frac{1}{3}$ and $t=\\frac{1}{3}$ for $\\epsilon = 0.2$ and $\\delta = 0.3$.\n\nRound your final numerical answer for $M\\!\\left(\\frac{1}{3},\\frac{1}{3}\\right)$ to $4$ significant figures. State your final answer as a pure number (dimensionless). Do not include units. Angles, if any are discussed, should be considered in radians, but you are not required to report any angle; only report the numerical value of $M$.", "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Computational domain: $(s,t) \\in [0,1] \\times [0,1]$.\n- Boundary curves:\n  - $C_0(s) = \\big(2s,\\,0\\big)$ for $t=0$.\n  - $C_1(s) = \\big(2s,\\,1 + \\epsilon \\sin(\\pi s)\\big)$ for $t=1$.\n  - $D_0(t) = \\big(\\delta \\sin(\\pi t),\\,t\\big)$ for $s=0$.\n  - $D_1(t) = \\big(2 + \\delta \\sin(\\pi t),\\,t\\big)$ for $s=1$.\n- Coons patch formula: $P(s,t) = (1-t)C_0(s) + tC_1(s) + (1-s)D_0(t) + sD_1(t) - \\big[(1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}\\big]$.\n- Non-orthogonality measure: $M(s,t) = \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)\\,g_{tt}(s,t)}}$.\n- Evaluation point: $(s,t) = (\\frac{1}{3}, \\frac{1}{3})$.\n- Parameters: $\\epsilon = 0.2$, $\\delta = 0.3$.\n- Final instruction: Round the numerical value for $M(\\frac{1}{3},\\frac{1}{3})$ to $4$ significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, belonging to the field of computational fluid dynamics and differential geometry. The method of transfinite interpolation (Coons patch) and the definition of metric tensor components are standard and correct. The boundary curves are checked for consistency at the corners:\n- $P_{00}: C_0(0) = (0,0)$ and $D_0(0) = (0,0)$. Consistent. $P_{00}=(0,0)$.\n- $P_{10}: C_0(1) = (2,0)$ and $D_1(0) = (2,0)$. Consistent. $P_{10}=(2,0)$.\n- $P_{01}: C_1(0) = (0,1)$ and $D_0(1) = (\\delta\\sin(\\pi),1)=(0,1)$. Consistent. $P_{01}=(0,1)$.\n- $P_{11}: C_1(1) = (2,1+\\epsilon\\sin(\\pi))=(2,1)$ and $D_1(1) = (2+\\delta\\sin(\\pi),1)=(2,1)$. Consistent. $P_{11}=(2,1)$.\nThe problem is well-posed, self-contained, and provides all necessary information for a unique solution. The language is objective and unambiguous. No flaws are detected.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution is provided below.\n\n### Task 1: Derive $P(s,t)$ explicitly\nThe Coons patch is defined by $P(s,t) = L_s P(s,t) + L_t P(s,t) - L_s L_t P(s,t)$, where $L_s$ and $L_t$ are linear interpolation operators. The given formula is an expansion of this. Let's compute the terms.\nThe linear interpolation of the bottom and top curves is:\n$$L_t P(s,t) = (1-t)C_0(s) + tC_1(s) = (1-t)(2s,0) + t(2s, 1+\\epsilon\\sin(\\pi s)) = (2s, t(1+\\epsilon\\sin(\\pi s)))$$\nThe linear interpolation of the left and right curves is:\n$$L_s P(s,t) = (1-s)D_0(t) + sD_1(t) = (1-s)(\\delta\\sin(\\pi t), t) + s(2+\\delta\\sin(\\pi t), t) = (2s+\\delta\\sin(\\pi t), t)$$\nThe bilinear interpolation of the corners is:\n$$L_s L_t P(s,t) = (1-s)(1-t)P_{00} + s(1-t)P_{10} + (1-s)tP_{01} + stP_{11}$$\n$$L_s L_t P(s,t) = (1-s)(1-t)(0,0) + s(1-t)(2,0) + (1-s)t(0,1) + st(2,1) = (2s, t)$$\nCombining these terms gives the mapping $P(s,t) = (x(s,t), y(s,t))$:\n$$P(s,t) = (2s+\\delta\\sin(\\pi t), t) + (2s, t(1+\\epsilon\\sin(\\pi s))) - (2s, t)$$\nThe $x$-component is $x(s,t) = (2s+\\delta\\sin(\\pi t)) + 2s - 2s = 2s+\\delta\\sin(\\pi t)$.\nThe $y$-component is $y(s,t) = t + t(1+\\epsilon\\sin(\\pi s)) - t = t(1+\\epsilon\\sin(\\pi s))$.\nSo, the explicit component form of the mapping is:\n$$P(s,t) = \\big(2s + \\delta \\sin(\\pi t),\\, t(1 + \\epsilon \\sin(\\pi s))\\big)$$\n\n### Task 2: Compute the partial derivatives $P_s$ and $P_t$\nThe partial derivatives are the tangent vectors to the coordinate lines.\n$P_s(s,t) = \\frac{\\partial P}{\\partial s} = \\left(\\frac{\\partial x}{\\partial s}, \\frac{\\partial y}{\\partial s}\\right)$.\n$$\\frac{\\partial x}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(2s + \\delta \\sin(\\pi t)\\right) = 2$$\n$$\\frac{\\partial y}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(t(1 + \\epsilon \\sin(\\pi s))\\right) = t\\epsilon\\pi\\cos(\\pi s)$$\nThus, $P_s(s,t) = \\big(2, t\\epsilon\\pi\\cos(\\pi s)\\big)$.\n\n$P_t(s,t) = \\frac{\\partial P}{\\partial t} = \\left(\\frac{\\partial x}{\\partial t}, \\frac{\\partial y}{\\partial t}\\right)$.\n$$\\frac{\\partial x}{\\partial t} = \\frac{\\partial}{\\partial t}\\left(2s + \\delta \\sin(\\pi t)\\right) = \\delta\\pi\\cos(\\pi t)$$\n$$\\frac{\\partial y}{\\partial t} = \\frac{\\partial}{\\partial t}\\left(t(1 + \\epsilon \\sin(\\pi s))\\right) = 1 + \\epsilon \\sin(\\pi s)$$\nThus, $P_t(s,t) = \\big(\\delta\\pi\\cos(\\pi t), 1 + \\epsilon \\sin(\\pi s)\\big)$.\n\n### Task 3: Derive the metric coefficients\nThe metric coefficients $g_{ij}$ are the inner products of the tangent vectors.\n$g_{ss}(s,t) = P_s \\cdot P_s = \\|P_s\\|^2 = (2)^2 + (t\\epsilon\\pi\\cos(\\pi s))^2$.\n$$g_{ss}(s,t) = 4 + t^2\\epsilon^2\\pi^2\\cos^2(\\pi s)$$\n$g_{tt}(s,t) = P_t \\cdot P_t = \\|P_t\\|^2 = (\\delta\\pi\\cos(\\pi t))^2 + (1 + \\epsilon \\sin(\\pi s))^2$.\n$$g_{tt}(s,t) = \\delta^2\\pi^2\\cos^2(\\pi t) + (1 + \\epsilon \\sin(\\pi s))^2$$\n$g_{st}(s,t) = P_s \\cdot P_t = (2)(\\delta\\pi\\cos(\\pi t)) + (t\\epsilon\\pi\\cos(\\pi s))(1 + \\epsilon \\sin(\\pi s))$.\n$$g_{st}(s,t) = 2\\delta\\pi\\cos(\\pi t) + t\\epsilon\\pi\\cos(\\pi s)(1 + \\epsilon \\sin(\\pi s))$$\n\n### Task 4: Explain the non-orthogonality measure $M(s,t)$\nThe vectors $P_s$ and $P_t$ are tangent to the grid lines of constant $t$ and constant $s$, respectively. The angle $\\theta(s,t)$ between these grid lines at a point $P(s,t)$ is the angle between these two tangent vectors. The inner product (dot product) of $P_s$ and $P_t$ is defined as $P_s \\cdot P_t = \\|P_s\\| \\|P_t\\| \\cos(\\theta)$.\nIn terms of the metric coefficients, this is written as $g_{st} = \\sqrt{g_{ss}} \\sqrt{g_{tt}} \\cos(\\theta)$.\nRearranging this equation gives an expression for $\\cos(\\theta)$:\n$$\\cos(\\theta) = \\frac{g_{st}}{\\sqrt{g_{ss}g_{tt}}}$$\nThe non-orthogonality measure is defined as $M(s,t) = \\frac{|g_{st}(s,t)|}{\\sqrt{g_{ss}(s,t)g_{tt}(s,t)}}$. By comparison, we see that $M(s,t) = |\\cos(\\theta)|$.\n- If the grid lines are orthogonal, $\\theta = \\pi/2$, which makes $\\cos(\\theta) = 0$. Thus, $M=0$ indicates perfect orthogonality.\n- If the grid lines are highly skewed, they are nearly parallel, so the angle $\\theta$ approaches $0$ or $\\pi$. In this case, $|\\cos(\\theta)|$ approaches $1$. A value of $M=1$ corresponds to a degenerate cell where grid lines are collinear.\nTherefore, $M$ is a measure of the local deviation from orthogonality, with larger values indicating greater skewness, which is generally undesirable in numerical simulations as it can degrade accuracy.\n\n### Task 5: Evaluate $M(1/3, 1/3)$\nWe are given $s=1/3$, $t=1/3$, $\\epsilon = 0.2$, and $\\delta = 0.3$.\nFirst, evaluate the trigonometric functions:\n$$\\pi s = \\frac{\\pi}{3} \\implies \\sin(\\pi s) = \\frac{\\sqrt{3}}{2}, \\quad \\cos(\\pi s) = \\frac{1}{2}$$\n$$\\pi t = \\frac{\\pi}{3} \\implies \\cos(\\pi t) = \\frac{1}{2}$$\nNow, we calculate the metric coefficients at this point.\n$$g_{ss}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 4 + \\left(\\frac{1}{3}\\right)^2(0.2)^2\\pi^2\\cos^2\\left(\\frac{\\pi}{3}\\right) = 4 + \\frac{1}{9}(0.04)\\pi^2\\left(\\frac{1}{2}\\right)^2 = 4 + \\frac{0.04\\pi^2}{36} = 4 + \\frac{\\pi^2}{900}$$\nNumerically, $g_{ss} \\approx 4 + \\frac{(3.14159...)^2}{900} \\approx 4 + 0.0109662 \\approx 4.0109662$.\n\n$$g_{tt}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = (0.3)^2\\pi^2\\cos^2\\left(\\frac{\\pi}{3}\\right) + \\left(1 + 0.2\\sin\\left(\\frac{\\pi}{3}\\right)\\right)^2 = 0.09\\pi^2\\left(\\frac{1}{2}\\right)^2 + \\left(1 + 0.2\\frac{\\sqrt{3}}{2}\\right)^2$$\n$$g_{tt}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 0.0225\\pi^2 + (1+0.1\\sqrt{3})^2$$\nNumerically, $g_{tt} \\approx 0.0225(9.86960) + (1+0.1(1.73205))^2 \\approx 0.222066 + (1.173205)^2 \\approx 0.222066 + 1.376410 \\approx 1.598476$.\n\n$$g_{st}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 2(0.3)\\pi\\cos\\left(\\frac{\\pi}{3}\\right) + \\frac{1}{3}(0.2)\\pi\\cos\\left(\\frac{\\pi}{3}\\right)\\left(1 + 0.2\\sin\\left(\\frac{\\pi}{3}\\right)\\right)$$\n$$g_{st}\\left(\\frac{1}{3},\\frac{1}{3}\\right) = 0.6\\pi\\left(\\frac{1}{2}\\right) + \\frac{0.2\\pi}{3}\\left(\\frac{1}{2}\\right)\\left(1 + 0.1\\sqrt{3}\\right) = 0.3\\pi + \\frac{0.1\\pi}{3}(1+0.1\\sqrt{3})$$\nSince all terms are positive, $|g_{st}| = g_{st}$.\nNumerically, $g_{st} \\approx 0.3(3.14159) + \\frac{0.1(3.14159)}{3}(1.173205) \\approx 0.942478 + 0.104720(1.173205) \\approx 0.942478 + 0.122856 \\approx 1.065334$.\n\nFinally, we compute $M(1/3, 1/3)$:\n$$M\\left(\\frac{1}{3},\\frac{1}{3}\\right) = \\frac{|g_{st}|}{\\sqrt{g_{ss}g_{tt}}} \\approx \\frac{1.065334}{\\sqrt{(4.0109662)(1.598476)}} = \\frac{1.065334}{\\sqrt{6.411420}} \\approx \\frac{1.065334}{2.532078}$$\n$$M\\left(\\frac{1}{3},\\frac{1}{3}\\right) \\approx 0.4207298$$\nRounding to $4$ significant figures, the result is $0.4207$.", "answer": "$$\\boxed{0.4207}$$", "id": "3384066"}, {"introduction": "While TFI is elegant, it is not guaranteed to produce a valid grid for any arbitrary set of boundary curves, especially those with high curvature or incompatible definitions. This practice demonstrates this limitation by tasking you with constructing examples that lead to cell inversion. By calculating the Jacobian determinant of the mapping and measuring the region of inversion, you will develop a critical awareness of potential failure modes—such as grid folding—and the importance of boundary shape control in algebraic grid generation. [@problem_id:3384030]", "problem": "Consider the construction of a two-dimensional structured grid by transfinite interpolation over a unit square parameter domain. Let the parameter domain be the Cartesian product of the intervals $[0,1]$ in $u$ and $[0,1]$ in $v$. Four boundary curves are prescribed in the physical plane, denoted by $\\mathbf{B}(u)$ for the bottom edge ($v=0$), $\\mathbf{T}(u)$ for the top edge ($v=1$), $\\mathbf{L}(v)$ for the left edge ($u=0$), and $\\mathbf{R}(v)$ for the right edge ($u=1$). A Coons patch mapping $\\mathbf{P}(u,v)$ is defined by blending these edges using transfinite interpolation. The Jacobian determinant of the mapping, denoted $J(u,v)=\\det\\left(\\frac{\\partial \\mathbf{P}}{\\partial (u,v)}\\right)$, encodes local orientation and area scaling; negative values of $J(u,v)$ indicate cell inversion (orientation reversal).\n\nStart from the fundamental base that a parametric mapping $\\mathbf{P}(u,v)$ induces a Jacobian tensor $\\frac{\\partial \\mathbf{P}}{\\partial (u,v)}$ whose determinant $J(u,v)$ provides the local change of area and orientation. Derive the expression for the Coons patch $\\mathbf{P}(u,v)$ from the definition of transfinite interpolation over the four prescribed boundary curves, and then derive the expressions for $\\frac{\\partial \\mathbf{P}}{\\partial u}$ and $\\frac{\\partial \\mathbf{P}}{\\partial v}$ in terms of the boundary data and their derivatives. Use these to compute $J(u,v)$ over the unit square.\n\nDesign a counterexample that exhibits cell inversion due to either incompatible edge data or extreme concavity. To make the construction concrete and testable, use the following family of boundary curves parameterized by real scalars $\\alpha$ and $\\beta$ and orientation flags $\\sigma_T \\in \\{+1,-1\\}$ and $\\sigma_R \\in \\{+1,-1\\}$, which control the orientation of the top and right edges, respectively:\n\n- Bottom edge: $\\mathbf{B}(u)=\\begin{bmatrix}u \\\\ 0\\end{bmatrix}$ for $u\\in[0,1]$.\n- Left edge: $\\mathbf{L}(v)=\\begin{bmatrix}0 \\\\ v\\end{bmatrix}$ for $v\\in[0,1]$.\n- Top edge: $\\mathbf{T}(u)=\\begin{bmatrix}x_T(u) \\\\ 1-\\alpha \\sin(\\pi u)\\end{bmatrix}$ for $u\\in[0,1]$, where $x_T(u)=u$ if $\\sigma_T=+1$ and $x_T(u)=1-u$ if $\\sigma_T=-1$.\n- Right edge: $\\mathbf{R}(v)=\\begin{bmatrix}1+\\beta \\sin(\\pi v) \\\\ y_R(v)\\end{bmatrix}$ for $v\\in[0,1]$, where $y_R(v)=v$ if $\\sigma_R=+1$ and $y_R(v)=1-v$ if $\\sigma_R=-1$.\n\nAssume corner point data for the Coons patch are taken from the left and bottom edges when needed to resolve incompatibilities, specifically $P_{00}=\\mathbf{L}(0)$, $P_{01}=\\mathbf{L}(1)$, $P_{10}=\\mathbf{B}(1)$, and $P_{11}=\\mathbf{T}(1)$. Using these boundary curves and corner points, construct $\\mathbf{P}(u,v)$ via transfinite interpolation. Then, compute the Jacobian determinant $J(u,v)$ over the parameter domain $[0,1]^2$.\n\nQuantify the inversion by measuring the Lebesgue area (in the $u$-$v$ parameter space, which is dimensionless) of the region where $J(u,v)<0$, denoted $A_{-}=\\int_{[0,1]^2} \\mathbf{1}_{\\{J(u,v)<0\\}} \\, \\mathrm{d}u\\,\\mathrm{d}v$, where $\\mathbf{1}$ is the indicator function. Express each computed area as a decimal number (no percentage sign), rounded to $6$ decimal places.\n\nUse the following test suite to exercise different behaviors:\n\n- Test case $1$ (well-behaved rectangle): $\\alpha=0$, $\\beta=0$, $\\sigma_T=+1$, $\\sigma_R=+1$.\n- Test case $2$ (extreme concavity on the top edge): $\\alpha=2.0$, $\\beta=0$, $\\sigma_T=+1$, $\\sigma_R=+1$.\n- Test case $3$ (incompatible edge data via reversed top orientation): $\\alpha=0$, $\\beta=0$, $\\sigma_T=-1$, $\\sigma_R=+1$.\n- Test case $4$ (incompatible edge data via reversed right orientation with concavity): $\\alpha=0$, $\\beta=0.8$, $\\sigma_T=+1$, $\\sigma_R=-1$.\n\nYour program should approximate $A_{-}$ for each test case by uniform sampling on a grid of resolution $N$ in each parameter direction, using the fraction of sample points where $J(u,v)<0$ as the estimator (i.e., Riemann-sum approximation). Use $N=800$ to ensure adequate coverage, and round each result to $6$ decimal places.\n\nFinal output format: Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (e.g., $[a_1,a_2,a_3,a_4]$), where each $a_i$ is the rounded area $A_{-}$ for test case $i$ in the order listed above. No other text should be printed.", "solution": "The problem requires the analysis of cell inversion in a two-dimensional structured grid generated by transfinite interpolation. The grid is a mapping from a unit square parameter domain $(u,v) \\in [0,1]^2$ to a physical domain $(x,y)$. Cell inversion occurs where the Jacobian determinant of the mapping becomes negative. We must first derive the general expression for the Jacobian determinant, $J(u,v)$, of a bilinearly blended Coons patch, and then apply it to a specific family of boundary curves to compute the area of the inverted region for several test cases.\n\nLet the four boundary curves be denoted by $\\mathbf{B}(u) = \\mathbf{P}(u,0)$, $\\mathbf{T}(u) = \\mathbf{P}(u,1)$, $\\mathbf{L}(v) = \\mathbf{P}(0,v)$, and $\\mathbf{R}(v) = \\mathbf{P}(1,v)$. The Coons patch is constructed by the Boolean sum of two linearly ruled surfaces, corrected by a bilinear interpolant of the corners. The formula for the mapping $\\mathbf{P}(u,v) = [x(u,v), y(u,v)]^T$ is:\n$$\n\\mathbf{P}(u,v) = (1-v)\\mathbf{B}(u) + v\\mathbf{T}(u) + (1-u)\\mathbf{L}(v) + u\\mathbf{R}(v) - \\mathbf{P}_{corners}(u,v)\n$$\nwhere the corner correction term $\\mathbf{P}_{corners}(u,v)$ is given by:\n$$\n\\mathbf{P}_{corners}(u,v) = (1-u)(1-v)P_{00} + u(1-v)P_{10} + (1-u)vP_{01} + uvP_{11}\n$$\nThe problem specifies the corner points as $P_{00}=\\mathbf{L}(0)$, $P_{01}=\\mathbf{L}(1)$, $P_{10}=\\mathbf{B}(1)$, and $P_{11}=\\mathbf{T}(1)$.\n\nThe Jacobian matrix of the mapping is formed by the partial derivatives of $\\mathbf{P}(u,v)$ with respect to $u$ and $v$:\n$$\n\\mathbf{J}_{\\mathbf{P}}(u,v) = \\frac{\\partial \\mathbf{P}}{\\partial(u,v)} = \\left[ \\frac{\\partial \\mathbf{P}}{\\partial u} \\quad \\frac{\\partial \\mathbf{P}}{\\partial v} \\right]\n$$\nThe Jacobian determinant is $J(u,v) = \\det(\\mathbf{J}_{\\mathbf{P}}) = \\frac{\\partial x}{\\partial u}\\frac{\\partial y}{\\partial v} - \\frac{\\partial x}{\\partial v}\\frac{\\partial y}{\\partial u}$.\n\nTo find the partial derivatives, we differentiate the expression for $\\mathbf{P}(u,v)$. Let primes denote differentiation with respect to the curve's parameter.\n$$\n\\frac{\\partial \\mathbf{P}}{\\partial u} = (1-v)\\mathbf{B}'(u) + v\\mathbf{T}'(u) - \\mathbf{L}(v) + \\mathbf{R}(v) - \\frac{\\partial}{\\partial u}\\mathbf{P}_{corners}(u,v)\n$$\n$$\n\\frac{\\partial \\mathbf{P}}{\\partial v} = -\\mathbf{B}(u) + \\mathbf{T}(u) + (1-u)\\mathbf{L}'(v) + u\\mathbf{R}'(v) - \\frac{\\partial}{\\partial v}\\mathbf{P}_{corners}(u,v)\n$$\nThe derivatives of the corner term are:\n$$\n\\frac{\\partial}{\\partial u}\\mathbf{P}_{corners}(u,v) = -(1-v)P_{00} + (1-v)P_{10} - vP_{01} + vP_{11}\n$$\n$$\n\\frac{\\partial}{\\partial v}\\mathbf{P}_{corners}(u,v) = -(1-u)P_{00} - uP_{10} + (1-u)P_{01} + uP_{11}\n$$\nSubstituting these into the expressions for the partial derivatives of $\\mathbf{P}$ yields the general formulas for the columns of the Jacobian matrix.\n\nThe problem provides the following family of curves:\n- $\\mathbf{B}(u)=\\begin{bmatrix}u \\\\ 0\\end{bmatrix} \\implies \\mathbf{B}'(u)=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$\n- $\\mathbf{L}(v)=\\begin{bmatrix}0 \\\\ v\\end{bmatrix} \\implies \\mathbf{L}'(v)=\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$\n- $\\mathbf{T}(u)=\\begin{bmatrix}x_T(u) \\\\ 1-\\alpha \\sin(\\pi u)\\end{bmatrix}$ where $x_T(u) = u$ if $\\sigma_T=1$ and $1-u$ if $\\sigma_T=-1$. Thus, $x_T'(u) = \\sigma_T$. So, $\\mathbf{T}'(u)=\\begin{bmatrix}\\sigma_T \\\\ -\\alpha \\pi \\cos(\\pi u)\\end{bmatrix}$.\n- $\\mathbf{R}(v)=\\begin{bmatrix}1+\\beta \\sin(\\pi v) \\\\ y_R(v)\\end{bmatrix}$ where $y_R(v) = v$ if $\\sigma_R=1$ and $1-v$ if $\\sigma_R=-1$. Thus, $y_R'(v) = \\sigma_R$. So, $\\mathbf{R}'(v)=\\begin{bmatrix}\\beta \\pi \\cos(\\pi v) \\\\ \\sigma_R\\end{bmatrix}$.\n\nUsing these specific curves and the specified corner points, we can derive the components of the Jacobian vectors, $\\mathbf{P}_u = [x_u, y_u]^T$ and $\\mathbf{P}_v = [x_v, y_v]^T$. The derivation is tedious but systematic, yielding expressions that depend on the flags $\\sigma_T$ and $\\sigma_R$:\n\nFor $\\frac{\\partial \\mathbf{P}}{\\partial u} = [x_u, y_u]^T$:\n- If $\\sigma_T=1$: $x_u = 1 + \\beta\\sin(\\pi v)$\n- If $\\sigma_T=-1$: $x_u = 1-v + \\beta\\sin(\\pi v)$\n- If $\\sigma_R=1$: $y_u = -\\alpha v \\pi \\cos(\\pi u)$\n- If $\\sigma_R=-1$: $y_u = 1 - 2v - \\alpha v \\pi \\cos(\\pi u)$\n\nFor $\\frac{\\partial \\mathbf{P}}{\\partial v} = [x_v, y_v]^T$:\n- If $\\sigma_T=1$: $x_v = u \\beta \\pi \\cos(\\pi v)$\n- If $\\sigma_T=-1$: $x_v = 1-u + u \\beta \\pi \\cos(\\pi v)$\n- If $\\sigma_R=1$: $y_v = 1 - \\alpha \\sin(\\pi u)$\n- If $\\sigma_R=-1$: $y_v = 1-2u - \\alpha \\sin(\\pi u)$\n\nThe Jacobian determinant is $J(u,v) = x_u y_v - x_v y_u$.\nThe area of inversion, $A_{-}$, is the area of the region in the parameter domain where $J(u,v) < 0$. We approximate this area numerically. We create a uniform grid of $N \\times N$ points in the $[0,1]^2$ domain, with $N=800$. The grid points are $(u_i, v_j)$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. The area $A_{-}$ is estimated as the fraction of these grid points for which the computed Jacobian determinant $J(u_i,v_j)$ is negative.\n$A_{-} \\approx \\frac{\\text{count}\\{ (i,j) | J(u_i,v_j) < 0 \\}}{N^2}$.\n\nWe evaluate this for each of the four test cases:\n1.  **Case 1: $\\alpha=0, \\beta=0, \\sigma_T=1, \\sigma_R=1$** (Unit square)\n    $x_u=1$, $y_u=0$, $x_v=0$, $y_v=1$.\n    $J(u,v) = (1)(1) - (0)(0) = 1$.\n    $J(u,v)>0$ everywhere. $A_{-}=0$.\n\n2.  **Case 2: $\\alpha=2.0, \\beta=0, \\sigma_T=1, \\sigma_R=1$** (Concave top edge)\n    $x_u=1$, $y_u=-2\\pi v \\cos(\\pi u)$, $x_v=0$, $y_v=1-2\\sin(\\pi u)$.\n    $J(u,v) = 1 - 2\\sin(\\pi u)$.\n    $J(u,v)<0$ when $\\sin(\\pi u) > 1/2$, which occurs for $u \\in (1/6, 5/6)$. The analytical area is $5/6 - 1/6 = 4/6 \\approx 0.666667$. The numerical approximation will be calculated.\n\n3.  **Case 3: $\\alpha=0, \\beta=0, \\sigma_T=-1, \\sigma_R=1$** (Reversed top edge)\n    $x_u=1-v$, $y_u=0$, $x_v=1-u$, $y_v=1$.\n    $J(u,v) = (1-v)(1) - (1-u)(0) = 1-v$.\n    For $(u,v) \\in [0,1]^2$, $J(u,v) \\ge 0$. Thus, $A_{-}=0$.\n\n4.  **Case 4: $\\alpha=0, \\beta=0.8, \\sigma_T=1, \\sigma_R=-1$** (Reversed right edge, convex)\n    $x_u=1+0.8\\sin(\\pi v)$, $y_u=1-2v$, $x_v=0.8u\\pi\\cos(\\pi v)$, $y_v=1-2u$.\n    $J(u,v) = (1+0.8\\sin(\\pi v))(1-2u) - (0.8u\\pi\\cos(\\pi v))(1-2v)$.\n    The area $A_{-}$ for this case is computed numerically.\n\nThe implementation will compute the Jacobian at each point of an $800 \\times 800$ grid and determine the fraction of points with a negative Jacobian for each test case.", "answer": "```python\nimport numpy as np\n\ndef calculate_jacobian_components(u, v, alpha, beta, sigma_T, sigma_R):\n    \"\"\"\n    Calculates the components of the Jacobian matrix for the Coons patch.\n    u and v can be scalars or numpy arrays of the same shape.\n    \n    Args:\n        u (float or np.ndarray): Parameter u.\n        v (float or np.ndarray): Parameter v.\n        alpha (float): Parameter for top edge concavity.\n        beta (float): Parameter for right edge concavity.\n        sigma_T (int): Orientation flag for the top edge (+1 or -1).\n        sigma_R (int): Orientation flag for the right edge (+1 or -1).\n        \n    Returns:\n        tuple[np.ndarray, ...]: Components xu, yu, xv, yv of the Jacobian matrix.\n    \"\"\"\n    pi = np.pi\n    sin_pi_u = np.sin(pi * u)\n    cos_pi_u = np.cos(pi * u)\n    sin_pi_v = np.sin(pi * v)\n    cos_pi_v = np.cos(pi * v)\n\n    # Component x_u\n    if sigma_T == 1:\n        xu = 1 + beta * sin_pi_v\n    else:  # sigma_T == -1\n        xu = 1 - v + beta * sin_pi_v\n\n    # Component y_u\n    if sigma_R == 1:\n        yu = -alpha * v * pi * cos_pi_u\n    else:  # sigma_R == -1\n        yu = 1 - 2 * v - alpha * v * pi * cos_pi_u\n\n    # Component x_v\n    if sigma_T == 1:\n        xv = u * beta * pi * cos_pi_v\n    else:  # sigma_T == -1\n        xv = 1 - u + u * beta * pi * cos_pi_v\n\n    # Component y_v\n    if sigma_R == 1:\n        yv = 1 - alpha * sin_pi_u\n    else:  # sigma_R == -1\n        yv = 1 - 2 * u - alpha * sin_pi_u\n\n    return xu, yu, xv, yv\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the inverted area for four test cases.\n    \"\"\"\n    test_cases = [\n        # (alpha, beta, sigma_T, sigma_R)\n        (0.0, 0.0, 1, 1),\n        (2.0, 0.0, 1, 1),\n        (0.0, 0.0, -1, 1),\n        (0.0, 0.8, 1, -1),\n    ]\n\n    results = []\n    N = 800\n\n    u_vals = np.linspace(0, 1, N)\n    v_vals = np.linspace(0, 1, N)\n    u, v = np.meshgrid(u_vals, v_vals)\n    \n    total_points = N * N\n\n    for case in test_cases:\n        alpha, beta, sigma_T, sigma_R = case\n        \n        xu, yu, xv, yv = calculate_jacobian_components(u, v, alpha, beta, sigma_T, sigma_R)\n        \n        jacobian = xu * yv - xv * yu\n        \n        # Count points where the Jacobian is strictly negative\n        inverted_points_count = np.sum(jacobian < 0)\n        \n        # The area is the fraction of inverted points over the total number of points\n        area = inverted_points_count / total_points\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{area:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3384030"}]}