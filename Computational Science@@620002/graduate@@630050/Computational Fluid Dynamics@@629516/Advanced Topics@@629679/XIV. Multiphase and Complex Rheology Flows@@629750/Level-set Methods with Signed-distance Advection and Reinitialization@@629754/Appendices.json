{"hands_on_practices": [{"introduction": "Accurately advecting the level-set function is critical for tracking an interface without introducing numerical oscillations or excessive smearing. High-order Weighted Essentially Non-Oscillatory (WENO) schemes are a cornerstone of modern level-set methods, providing sharp interface resolution by non-linearly combining several lower-order approximations. This practice [@problem_id:3339785] will guide you through the core mechanics of a fifth-order WENO reconstruction, building your intuition for how these schemes adapt to maintain smoothness and accuracy.", "problem": "Consider one-dimensional advection of a Level-Set signed-distance function $\\phi(x,t)$ governed by the linear Hamilton–Jacobi equation $\\phi_{t} + u\\,\\phi_{x} = 0$ on a uniform grid with spacing $\\Delta x$, where $u>0$ is a constant advection velocity. In the finite-difference Weighted Essentially Non-Oscillatory (WENO) of fifth order (WENO5), one reconstructs one-sided spatial derivatives at cell faces using three quadratic candidate polynomials defined on three-point substencils and combines them via nonlinear weights determined by smoothness indicators. These reconstructions are used in both signed-distance advection and signed-distance reinitialization computations to maintain non-oscillatory, high-order approximations near interfaces.\n\nYou are given a local stencil of cell-centered values of $\\phi$ near a face $x_{i+1/2}$:\n$$\n\\phi_{i-2} = -\\frac{22}{10},\\quad \\phi_{i-1} = -\\frac{12}{10},\\quad \\phi_{i} = -\\frac{2}{10},\\quad \\phi_{i+1} = \\frac{8}{10},\\quad \\phi_{i+2} = \\frac{17}{10},\n$$\nand a uniform grid spacing $\\Delta x = 1$. Assume positive velocity $u>0$ so that a left-biased reconstruction of $\\partial_x \\phi$ at $x_{i+1/2}$ is required. Use the Jiang–Shu WENO5 finite-difference formulation with the standard three-point substencils $S_0=\\{i-2,i-1,i\\}$, $S_1=\\{i-1,i,i+1\\}$, and $S_2=\\{i,i+1,i+2\\}$; use the classical linear weights $d_0$, $d_1$, $d_2$ associated with the left-biased reconstruction at $x_{i+1/2}$, and the standard smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$ for WENO5. Take the nonlinear weight regularization to be $\\epsilon = 10^{-6}$ and the power parameter to be $p=2$ in the weight definition.\n\nStarting from the governing equation and the finite-difference reconstruction principles, derive the three quadratic candidate polynomials on each substencil, differentiate them to obtain the three candidate one-sided approximations to $\\partial_x \\phi$ at $x_{i+1/2}$, derive the Jiang–Shu smoothness indicators on each substencil, and state the classical linear weights for this left-biased face. Then compute:\n1. The WENO5 left-biased reconstruction of $\\partial_x \\phi$ at $x_{i+1/2}$.\n2. The numerical values of the linear weights $d_0$, $d_1$, $d_2$ used.\n3. The numerical values of the smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$.\n\nProvide the final answer as a single row vector containing, in order, the reconstructed derivative $\\partial_x \\phi|_{x_{i+1/2}}$, the three linear weights $d_0$, $d_1$, $d_2$, and the three smoothness indicators $\\beta_0$, $\\beta_1$, $\\beta_2$. No units are required. No rounding is required; express any rational quantities in exact form if convenient.", "solution": "The user wants to solve a problem related to the Weighted Essentially Non-Oscillatory (WENO) scheme of fifth order (WENO5).\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Governing Equation**: 1D linear Hamilton-Jacobi equation, $\\phi_{t} + u\\,\\phi_{x} = 0$, with constant velocity $u > 0$.\n-   **Grid**: Uniform grid with spacing $\\Delta x = 1$.\n-   **Task**: Compute the left-biased WENO5 reconstruction of the spatial derivative $\\partial_x \\phi$ at the cell face $x_{i+1/2}$.\n-   **Stencil Data**: A 5-point stencil of cell-centered values is provided:\n    $\\phi_{i-2} = -\\frac{22}{10}$, $\\phi_{i-1} = -\\frac{12}{10}$, $\\phi_{i} = -\\frac{2}{10}$, $\\phi_{i+1} = \\frac{8}{10}$, $\\phi_{i+2} = \\frac{17}{10}$.\n-   **Substencils**: The three 3-point candidate substencils are $S_0=\\{i-2,i-1,i\\}$, $S_1=\\{i-1,i,i+1\\}$, and $S_2=\\{i,i+1,i+2\\}$.\n-   **WENO Parameters**:\n    -   Classical linear weights for left-biased reconstruction at $x_{i+1/2}$ are denoted $d_0, d_1, d_2$.\n    -   Regularization parameter $\\epsilon = 10^{-6}$.\n    -   Power parameter $p=2$.\n-   **Required Outputs**:\n    1.  The numerical value of the reconstructed derivative $\\partial_x \\phi|_{x_{i+1/2}}$.\n    2.  The numerical values of the linear weights $d_0, d_1, d_2$.\n    3.  The numerical values of the Jiang–Shu smoothness indicators $\\beta_0, \\beta_1, \\beta_2$.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is based on the well-established Jiang-Shu WENO5 scheme, a standard high-order numerical method in computational physics and engineering. The equations, stencils, and definitions are canonical to this method.\n-   **Well-Posed**: The problem provides all necessary data and definitions to perform the calculations. The procedure is deterministic and leads to a unique set of results.\n-   **Objective**: The problem statement is quantitative and free of subjective or ambiguous language.\n-   **Completeness and Consistency**: The provided data is complete and self-consistent. The values of $\\phi$ describe a function crossing zero near the face $x_{i+1/2}$, which is a typical scenario in level-set methods.\n-   **Verdict**: The problem is scientifically sound, well-posed, and objective. It is a standard application of the WENO5 finite-difference methodology.\n\nThe problem is **valid**.\n\n### Solution\n\nThe objective is to compute the fifth-order WENO reconstruction of the spatial derivative, $\\partial_x \\phi$, at the cell face $x_{i+1/2}$. This involves several steps: finding the candidate derivative approximations, computing the smoothness indicators, and then calculating the final weighted average. Although the final WENO derivative is a non-linear combination, we are asked to first derive the candidate derivatives and intermediate quantities.\n\n**1. Candidate Derivative Approximations**\n\nThe candidate approximations for the derivative, denoted $(\\partial_x \\phi)_k$, are found by first constructing a quadratic polynomial $p_k(x)$ that interpolates the data on each substencil $S_k$, and then evaluating the derivative of this polynomial, $p_k'(x)$, at the face $x_{i+1/2}$. We assume $\\Delta x=1$.\n\nLet a local coordinate system be centered at $x_i$, such that $x_j = (j-i)\\Delta x = j-i$. The face is located at $x_{i+1/2} = (i+1/2-i)\\Delta x = 1/2$.\n\n**Stencil $S_0 = \\{i-2, i-1, i\\}$**:\nThe quadratic polynomial $p_0(x)$ interpolates $(\\phi_{i-2}, \\phi_{i-1}, \\phi_i)$ at points $(x_{i-2}, x_{i-1}, x_i)$. The derivative at $x_{i+1/2}$ is given by the formula:\n$$(\\partial_x \\phi)_0 = \\frac{1}{\\Delta x} (2\\phi_i - 3\\phi_{i-1} + \\phi_{i-2})$$\nWith $\\Delta x=1$ and the given values:\n$$(\\partial_x \\phi)_0 = 2(-\\frac{2}{10}) - 3(-\\frac{12}{10}) + (-\\frac{22}{10}) = \\frac{-4 + 36 - 22}{10} = \\frac{10}{10} = 1$$\n\n**Stencil $S_1 = \\{i-1, i, i+1\\}$**:\nThe polynomial $p_1(x)$ interpolates $(\\phi_{i-1}, \\phi_{i}, \\phi_{i+1})$ at points $(x_{i-1}, x_i, x_{i+1})$. The derivative at $x_{i+1/2}$ is the central difference over the interval $[x_i, x_{i+1}]$:\n$$(\\partial_x \\phi)_1 = \\frac{1}{\\Delta x} (\\phi_{i+1} - \\phi_i)$$\nWith $\\Delta x=1$:\n$$(\\partial_x \\phi)_1 = \\frac{8}{10} - (-\\frac{2}{10}) = \\frac{10}{10} = 1$$\n\n**Stencil $S_2 = \\{i, i+1, i+2\\}$**:\nThe polynomial $p_2(x)$ interpolates $(\\phi_i, \\phi_{i+1}, \\phi_{i+2})$ at points $(x_i, x_{i+1}, x_{i+2})$. A notable property is that the derivative of this specific interpolating polynomial, when evaluated at the midpoint of its first two points, $x_{i+1/2} = (x_i+x_{i+1})/2$, depends only on the values at those two points. The formula is identical to that for $S_1$:\n$$(\\partial_x \\phi)_2 = \\frac{1}{\\Delta x} (\\phi_{i+1} - \\phi_i)$$\nWith $\\Delta x=1$:\n$$(\\partial_x \\phi)_2 = \\frac{8}{10} - (-\\frac{2}{10}) = \\frac{10}{10} = 1$$\n\nAll three candidate derivatives are equal to $1$.\n\n**2. WENO5 Reconstructed Derivative**\n\nThe final WENO5 reconstructed derivative is a non-linear convex combination of the candidate derivatives:\n$$(\\partial_x \\phi)_{WENO5} = \\omega_0 (\\partial_x \\phi)_0 + \\omega_1 (\\partial_x \\phi)_1 + \\omega_2 (\\partial_x \\phi)_2$$\nwhere the weights $\\omega_k$ sum to $1$.\nSince $(\\partial_x \\phi)_0 = (\\partial_x \\phi)_1 = (\\partial_x \\phi)_2 = 1$, the final value is:\n$$(\\partial_x \\phi)_{WENO5} = \\omega_0 (1) + \\omega_1 (1) + \\omega_2 (1) = (\\omega_0 + \\omega_1 + \\omega_2) \\times 1 = 1 \\times 1 = 1$$\nThe reconstructed derivative is exactly $1$. Although we do not need the non-linear weights to find this answer, we compute the required quantities below.\n\n**3. Linear Weights**\n\nThe problem asks for the classical linear weights $d_k$ for the left-biased fifth-order reconstruction at face $x_{i+1/2}$. These are standard values for WENO5:\n$$d_0 = \\frac{1}{10}$$\n$$d_1 = \\frac{6}{10} = \\frac{3}{5}$$\n$$d_2 = \\frac{3}{10}$$\n\n**4. Smoothness Indicators**\n\nThe Jiang-Shu smoothness indicators $\\beta_k$ measure the oscillatory nature of the data on each substencil. For point values, the formulas are:\n\n**For $S_0 = \\{i-2, i-1, i\\}$**:\n$$\\beta_0 = \\frac{13}{12}(\\phi_{i-2} - 2\\phi_{i-1} + \\phi_i)^2 + \\frac{1}{4}(\\phi_{i-2} - 4\\phi_{i-1} + 3\\phi_i)^2$$\nFirst term: $\\phi_{i-2} - 2\\phi_{i-1} + \\phi_i = -\\frac{22}{10} - 2(-\\frac{12}{10}) - \\frac{2}{10} = \\frac{-22+24-2}{10} = 0$.\nSecond term: $\\phi_{i-2} - 4\\phi_{i-1} + 3\\phi_i = -\\frac{22}{10} - 4(-\\frac{12}{10}) + 3(-\\frac{2}{10}) = \\frac{-22+48-6}{10} = \\frac{20}{10} = 2$.\n$$\\beta_0 = \\frac{13}{12}(0)^2 + \\frac{1}{4}(2)^2 = \\frac{4}{4} = 1$$\n\n**For $S_1 = \\{i-1, i, i+1\\}$**:\n$$\\beta_1 = \\frac{13}{12}(\\phi_{i-1} - 2\\phi_i + \\phi_{i+1})^2 + \\frac{1}{4}(\\phi_{i-1} - \\phi_{i+1})^2$$\nFirst term: $\\phi_{i-1} - 2\\phi_i + \\phi_{i+1} = -\\frac{12}{10} - 2(-\\frac{2}{10}) + \\frac{8}{10} = \\frac{-12+4+8}{10} = 0$.\nSecond term: $\\phi_{i-1} - \\phi_{i+1} = -\\frac{12}{10} - \\frac{8}{10} = -\\frac{20}{10} = -2$.\n$$\\beta_1 = \\frac{13}{12}(0)^2 + \\frac{1}{4}(-2)^2 = \\frac{4}{4} = 1$$\n\n**For $S_2 = \\{i, i+1, i+2\\}$**:\n$$\\beta_2 = \\frac{13}{12}(\\phi_i - 2\\phi_{i+1} + \\phi_{i+2})^2 + \\frac{1}{4}(3\\phi_i - 4\\phi_{i+1} + \\phi_{i+2})^2$$\nFirst term: $\\phi_i - 2\\phi_{i+1} + \\phi_{i+2} = -\\frac{2}{10} - 2(\\frac{8}{10}) + \\frac{17}{10} = \\frac{-2-16+17}{10} = -\\frac{1}{10}$.\nSecond term: $3\\phi_i - 4\\phi_{i+1} + \\phi_{i+2} = 3(-\\frac{2}{10}) - 4(\\frac{8}{10}) + \\frac{17}{10} = \\frac{-6-32+17}{10} = -\\frac{21}{10}$.\n$$\\beta_2 = \\frac{13}{12}(-\\frac{1}{10})^2 + \\frac{1}{4}(-\\frac{21}{10})^2 = \\frac{13}{12 \\cdot 100} + \\frac{441}{4 \\cdot 100} = \\frac{13}{1200} + \\frac{441}{400}$$\nTo sum the fractions, we use a common denominator of $1200$:\n$$\\beta_2 = \\frac{13}{1200} + \\frac{441 \\times 3}{1200} = \\frac{13 + 1323}{1200} = \\frac{1336}{1200} = \\frac{334}{300} = \\frac{167}{150}$$\nThe smoothness indicators are $\\beta_0=1$, $\\beta_1=1$, and $\\beta_2=167/150$. The given data is perfectly smooth on stencils $S_0$ and $S_1$ (corresponding to zero second derivatives), but shows some loss of smoothness on $S_2$ due to the value of $\\phi_{i+2}$.\n\n**Summary of Results**\nThe required values are:\n-   Reconstructed derivative $\\partial_x \\phi|_{x_{i+1/2}} = 1$.\n-   Linear weights: $d_0 = 1/10$, $d_1 = 3/5$, $d_2 = 3/10$.\n-   Smoothness indicators: $\\beta_0 = 1$, $\\beta_1 = 1$, $\\beta_2 = 167/150$.\nThese are presented as a single row vector in the final answer.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & \\frac{1}{10} & \\frac{3}{5} & \\frac{3}{10} & 1 & 1 & \\frac{167}{150}\n\\end{pmatrix}\n}\n$$", "id": "3339785"}, {"introduction": "While advection moves the interface, the level-set field itself can become distorted, losing the crucial signed-distance property. Reinitialization restores this property by solving a specific Hamilton-Jacobi equation, but this requires a numerical scheme that correctly handles the non-linear term $|\\nabla \\phi|$. This exercise [@problem_id:3339817] focuses on the Godunov-type upwind discretization, a fundamental technique for ensuring a stable and physically consistent solution to the reinitialization equation.", "problem": "Consider a one-dimensional uniform grid with spacing $\\Delta x = 0.2$, nodal locations $x_{i-1}$, $x_i$, and $x_{i+1}$, and a level-set function $\\phi$ that is intended to represent a signed-distance function. The reinitialization step is modeled by the Hamilton–Jacobi type partial differential equation (PDE)\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0,\n$$\nwhere $S(\\phi_0)$ is the smoothed sign of the initial level-set $\\phi_0$, and $\\tau$ is the pseudo-time variable used only for reinitialization. The one-sided finite differences at node $x_i$ are\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}, \\qquad D_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}.\n$$\nStarting from the monotonicity requirement for numerical Hamiltonians in Hamilton–Jacobi equations and the upwind principle derived from characteristic speeds, derive a Godunov-type consistent discretization of $|\\partial_x \\phi|$ at $x_i$ that uses the one-sided differences $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ and depends on the sign of $S(\\phi_0)$ at $x_i$. Then, for the specific data\n$$\n\\phi_{i-1} = 0.3, \\qquad \\phi_i = -0.1, \\qquad \\phi_{i+1} = -0.6, \\qquad \\Delta x = 0.2, \\qquad \\phi_{0,i} = 0.15,\n$$\ncompute the Godunov discretization of $|\\partial_x \\phi|$ at $x_i$ and determine the direction of the pseudo-time update at $x_i$ implied by the reinitialization PDE. In the direction indicator, use $+1$ for an increase in $\\phi_i$ with respect to $\\tau$, $-1$ for a decrease, and $0$ for a stationary update.\n\nProvide your final answer as a single row matrix whose first entry is the computed Godunov value for $|\\partial_x \\phi|$ at $x_i$ and whose second entry is the update direction indicator. No rounding is required.", "solution": "The reinitialization PDE\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0\n$$\nis a Hamilton–Jacobi type equation with Hamiltonian\n$$\nH(p) = S(\\phi_0)\\left(|p| - 1\\right), \\qquad p = \\partial_x \\phi.\n$$\nFor viscosity solutions, a consistent and monotone numerical Hamiltonian must respect the upwind direction determined by the characteristic speed. The characteristic speed is given by the derivative of the Hamiltonian with respect to $p$:\n$$\na(p) = \\frac{\\partial H}{\\partial p} = S(\\phi_0)\\frac{\\partial}{\\partial p}|p| = S(\\phi_0)\\,\\operatorname{sign}(p), \\quad \\text{for } p \\neq 0,\n$$\nwhere $\\operatorname{sign}(p)$ denotes the sign function. Because $a(p)$ depends on the (unknown) local gradient $p$, the Godunov numerical Hamiltonian selects among admissible one-sided approximations $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ according to the monotonicity principle: the discretization must be non-decreasing in each of its arguments when $H$ is non-decreasing in $|p|$ and must choose upwind differences based on the direction of characteristics.\n\nIn one dimension, the Godunov choice for $|\\partial_x \\phi|$ can be derived by considering the admissible interval for $p$ spanned by the one-sided slopes. The numerical Hamiltonian seeks the extremal value of $|p|$ within this interval consistent with monotonicity and upwinding. The resulting Godunov discretization for the magnitude $|\\partial_x \\phi|$ at $x_i$ is\n$$\n|\\partial_x \\phi|_{\\text{G}} =\n\\begin{cases}\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^- \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^+ \\phi_i,0)\\bigr)^2\\right)}, & \\text{if } S(\\phi_{0,i}) > 0, \\\\\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^+ \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^- \\phi_i,0)\\bigr)^2\\right)}, & \\text{if } S(\\phi_{0,i}) < 0, \\\\\n0, & \\text{if } S(\\phi_{0,i}) = 0,\n\\end{cases}\n$$\nwhich, in one dimension, reduces to selecting the upwind one-sided magnitude according to the signs of $D_x^- \\phi_i$ and $D_x^+ \\phi_i$. Specifically, for $S(\\phi_{0,i})>0$,\n- if $D_x^- \\phi_i \\ge 0$ and $D_x^+ \\phi_i \\le 0$, then $|\\partial_x \\phi|_{\\text{G}} = \\max\\!\\left(|D_x^- \\phi_i|, |D_x^+ \\phi_i|\\right)$,\n- if $D_x^- \\phi_i \\ge 0$ and $D_x^+ \\phi_i \\ge 0$, then $|\\partial_x \\phi|_{\\text{G}} = |D_x^- \\phi_i|$,\n- if $D_x^- \\phi_i \\le 0$ and $D_x^+ \\phi_i \\le 0$, then $|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i|$,\nand for $S(\\phi_{0,i})<0$ the roles of $D_x^- \\phi_i$ and $D_x^+ \\phi_i$ are reversed.\n\nNow compute the one-sided differences for the given data:\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} = \\frac{-0.1 - 0.3}{0.2} = \\frac{-0.4}{0.2} = -2.0,\n$$\n$$\nD_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} = \\frac{-0.6 - (-0.1)}{0.2} = \\frac{-0.5}{0.2} = -2.5.\n$$\nThe smoothed sign $S(\\phi_{0,i})$ is positive because $\\phi_{0,i} = 0.15 > 0$; any standard smooth sign approximation (for example, $S(\\phi_{0,i}) = \\phi_{0,i}/\\sqrt{\\phi_{0,i}^2 + \\varepsilon^2}$ with small $\\varepsilon>0$) yields $S(\\phi_{0,i}) > 0$.\n\nWith $S(\\phi_{0,i}) > 0$ and both one-sided differences negative, the Godunov selection reduces to\n$$\n|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i| = 2.5.\n$$\nNext, determine the pseudo-time update direction from the PDE:\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,S(\\phi_{0,i})\\left(|\\partial_x \\phi|_{\\text{G}} - 1\\right).\n$$\nSubstituting $S(\\phi_{0,i})>0$ and $|\\partial_x \\phi|_{\\text{G}} = 2.5$ gives\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,(2.5 - 1) = -1.5,\n$$\nwhich is negative. Hence the update direction indicator is $-1$ (decrease).\n\nTherefore, the required outputs are the Godunov magnitude $2.5$ and the direction indicator $-1$.", "answer": "$$\\boxed{\\begin{pmatrix} 2.5 & -1 \\end{pmatrix}}$$", "id": "3339817"}, {"introduction": "Applying numerical methods in practice often reveals challenges not apparent in theory, and the reinitialization of closely-spaced interfaces is a classic example. Standard reinitialization can cause thin films to artificially merge or erode, a significant issue in simulating phenomena like bubble dynamics or ligament breakup. This hands-on coding problem [@problem_id:3339798] allows you to simulate this numerical artifact and implement a practical clipping strategy to mitigate it, highlighting the importance of tailoring algorithms to specific physical and geometric constraints.", "problem": "Consider a one-dimensional Level Set Method (LSM) for representing interfaces by the zero level of a scalar field $\\phi(x,t)$. A signed distance function is defined by the property $\\lvert \\nabla \\phi \\rvert = 1$ almost everywhere, with $\\phi < 0$ inside a region and $\\phi > 0$ outside. Reinitialization is the process of evolving an arbitrary $\\phi(x,0)$ toward a steady state that satisfies the Eikonal equation $\\lvert \\nabla \\phi \\rvert = 1$ while preserving the original zero level set topology. A standard reinitialization approach uses the Hamilton–Jacobi evolution equation\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S_{\\epsilon}(\\phi_0)\\, \\left(\\lvert \\nabla \\phi \\rvert - 1\\right) = 0,\n$$\nwhere $\\tau$ is a fictitious time, $\\phi_0$ is the initial field, and $S_{\\epsilon}$ is a smooth sign function constructed from $\\phi_0$ (for example $S_{\\epsilon}(u) = \\frac{u}{\\sqrt{u^2+\\epsilon^2}}$). In a one-dimensional spatial grid with spacing $h$, the Godunov upwind discretization for $\\lvert \\nabla \\phi \\rvert$ may be used together with explicit time stepping subject to a Courant–Friedrichs–Lewy (CFL) condition.\n\nWhen two interfaces are closely spaced with gap $g$ on the order of the grid spacing $h$, reinitialization can spuriously merge the interfaces or erode the thin film between them because $S_{\\epsilon}(\\phi_0)$ is regularized across a width comparable to $h$, causing overlapping smoothing neighborhoods and numerical diffusion. Two mitigation ideas are: local clipping of reinitialization speed near ambiguous regions where a grid point is comparably close to two distinct interfaces, or multi-valued signed distance that keeps separate distances to each interface.\n\nYour task is to write a complete program that:\n- Constructs a one-dimensional domain $x \\in [-L,L]$ with a uniform grid of $N$ points and spacing $h$.\n- Builds an initial signed distance field $\\phi_0(x)$ that represents a thin film bounded by two interfaces symmetrically placed at $x=-g/2$ and $x=+g/2$, with $\\phi_0(x) < 0$ inside the film and $\\phi_0(x) > 0$ outside, and with $\\phi_0$ equal to the signed distance to the nearest interface.\n- Evolves $\\phi$ by explicit Euler time stepping in fictitious time $\\tau$, using the above reinitialization equation with Godunov upwinding in one spatial dimension:\n  - For each grid index $i$, define one-sided differences $D^+ \\phi_i = \\frac{\\phi_{i+1}-\\phi_i}{h}$ and $D^- \\phi_i = \\frac{\\phi_i-\\phi_{i-1}}{h}$. For boundaries, enforce homogeneous Neumann conditions by copying boundary values when needed.\n  - For each $i$, compute \n    $$\n    G_i = \n    \\begin{cases}\n    \\sqrt{\\max\\left(\\max(D^- \\phi_i, 0)^2, \\min(D^+ \\phi_i, 0)^2\\right)} & \\text{if } S_{\\epsilon}(\\phi_{0,i}) > 0,\\\\\n    \\sqrt{\\max\\left(\\max(D^+ \\phi_i, 0)^2, \\min(D^- \\phi_i, 0)^2\\right)} & \\text{if } S_{\\epsilon}(\\phi_{0,i}) < 0,\\\\\n    0 & \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0,\n    \\end{cases}\n    $$\n    and update \n    $$\n    \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right).\n    $$\n- Implements a local clipping strategy that suppresses reinitialization where a grid point is nearly equidistant from two interfaces: Let $x_L$ and $x_R$ denote the two interface positions initialized from $\\phi_0$ (found by subcell zero-crossing detection). Define for each grid point $x_i$ the distances $d_L = \\lvert x_i - x_L \\rvert$ and $d_R = \\lvert x_i - x_R \\rvert$, and the closeness measure $c_i = \\lvert d_L - d_R \\rvert$. Introduce a weight $w_i \\in \\{0,1\\}$ defined by\n  $$\n  w_i = \\begin{cases}\n  0 & \\text{if } c_i < \\beta\\, h,\\\\\n  1 & \\text{otherwise},\n  \\end{cases}\n  $$\n  and replace $S_{\\epsilon}(\\phi_{0,i})$ by $w_i\\, S_{\\epsilon}(\\phi_{0,i})$ in the update. This locally freezes reinitialization where two interfaces are too close to distinguish at grid scale. Take $\\beta$ as a fixed constant.\n- After reinitialization for a specified number of steps, measures two diagnostics:\n  - The number of zero crossings detected by sign change between adjacent grid points, computed by linear interpolation to subcell positions. This quantifies whether two interfaces persist.\n  - The film thickness, defined as the distance between the two zero-crossing positions that bracket $x=0$. If fewer than two crossings are found, report a film thickness of $0$.\n\nUse the following fixed numerical parameters for all tests:\n- Domain half-length $L = 1$ (dimensionless).\n- Number of grid points $N = 801$ (so that the domain includes $x=0$).\n- Grid spacing $h = \\frac{2L}{N-1}$ (dimensionless).\n- Reinitialization smoothing parameter $\\epsilon = \\alpha h$ with $\\alpha = 1.5$ (dimensionless).\n- Time step $\\Delta \\tau = 0.3 h$ (dimensionless) to respect the Courant–Friedrichs–Lewy number.\n- Number of reinitialization steps $N_{\\tau} = 300$.\n- Clipping threshold factor $\\beta = 1$.\n\nTest suite:\n- Case A (happy path): $g/h = 3.0$.\n- Case B (boundary): $g/h = 1.0$.\n- Case C (edge): $g/h = 0.5$.\n\nFor each case, run two reinitializations starting from the same $\\phi_0$: one with the baseline scheme, and one with the clipping strategy enabled. For each run, report:\n- $g/h$ as a float,\n- the baseline zero-crossing count as an integer,\n- the baseline film thickness divided by $h$ as a float,\n- the clipped zero-crossing count as an integer,\n- the clipped film thickness divided by $h$ as a float.\n\nFinal output format:\n- Your program should produce a single line of output containing a list with three elements, one for each case. Each element must be a list of the five values in the order specified above, for example\n  $$\n  \\left[ [g/h, z_{\\text{base}}, t_{\\text{base}}/h, z_{\\text{clip}}, t_{\\text{clip}}/h], \\ \\ldots \\right].\n  $$\n- All quantities are dimensionless as defined, so no physical units are required.", "solution": "The user has provided a valid problem statement.\n\n### Introduction to Level Set Reinitialization\n\nThe Level Set Method (LSM) is a powerful numerical technique for tracking evolving interfaces and shapes, widely used in fields like computational fluid dynamics, computer graphics, and materials science. The core idea is to represent an interface $\\Gamma$ as the zero level set of a higher-dimensional scalar function $\\phi(\\mathbf{x}, t)$, i.e., $\\Gamma(t) = \\{ \\mathbf{x} \\mid \\phi(\\mathbf{x}, t) = 0 \\}$. By convention, $\\phi < 0$ inside the region enclosed by the interface and $\\phi > 0$ outside.\n\nFor numerical stability and accuracy, it is highly desirable for $\\phi$ to be a signed distance function (SDF), which satisfies the Eikonal equation $|\\nabla \\phi| = 1$. However, during the evolution of the interface, the $\\phi$ field can become distorted, losing the SDF property. Reinitialization is a crucial procedure that reshapes $\\phi$ back into an SDF while keeping the zero level set ($\\phi=0$) unchanged. This is typically achieved by solving a Hamilton-Jacobi equation until a steady state is reached:\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0) \\left( |\\nabla \\phi| - 1 \\right) = 0\n$$\nHere, $\\tau$ is a fictitious time variable for the reinitialization process. $S(\\phi_0)$ is a sign function derived from the initial, distorted field $\\phi_0$ before reinitialization. It ensures that the evolution proceeds in the correct direction (i.e., making $|\\nabla \\phi|$ closer to $1$) without moving the zero level set. To avoid singularities, a smoothed sign function is used, such as $S_{\\epsilon}(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + \\epsilon^2}}$, where $\\epsilon$ is a small parameter typically on the order of the grid spacing $h$.\n\n### Numerical Discretization\n\nThe reinitialization equation is solved on a discrete grid. We consider a one-dimensional domain $x \\in [-L, L]$ with $N$ uniformly spaced grid points $x_i$ and spacing $h = \\frac{2L}{N-1}$.\n\n- **Time Discretization**: An explicit forward Euler method is used to advance in fictitious time $\\tau$:\n  $$\n  \\frac{\\phi_i^{n+1} - \\phi_i^n}{\\Delta \\tau} = -S_{\\epsilon}(\\phi_{0,i}) \\left( |\\nabla \\phi|_i - 1 \\right)\n  $$\n  where $\\Delta \\tau$ is the time step, chosen small enough to satisfy the Courant–Friedrichs–Lewy (CFL) stability condition.\n\n- **Spatial Discretization**: The non-linear term $|\\nabla \\phi|$ requires a careful upwind discretization scheme appropriate for Hamilton-Jacobi equations. The Godunov scheme is a standard choice. In one dimension, it is given by:\n  $$\n  |\\nabla \\phi|_i \\approx G_i =\n  \\begin{cases}\n  \\sqrt{\\max\\left(\\left(\\max(D^- \\phi_i, 0)\\right)^2, \\left(\\min(D^+ \\phi_i, 0)\\right)^2\\right)} & \\text{if } S_{\\epsilon}(\\phi_{0,i}) > 0 \\\\\n  \\sqrt{\\max\\left(\\left(\\max(D^+ \\phi_i, 0)\\right)^2, \\left(\\min(D^- \\phi_i, 0)\\right)^2\\right)} & \\text{if } S_{\\epsilon}(\\phi_{0,i}) < 0 \\\\\n  0 & \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0\n  \\end{cases}\n  $$\n  where $D^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{h}$ and $D^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{h}$ are the forward and backward finite differences, respectively. Homogeneous Neumann boundary conditions ($\\frac{\\partial\\phi}{\\partial x}=0$) are enforced at the domain boundaries.\n\nThe full update for a grid point $\\phi_i$ from time step $n$ to $n+1$ is thus:\n$$\n\\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right)\n$$\n\n### The Thin Film Problem and Numerical Erosion\n\nA known challenge in LSM is the representation of thin structures whose thickness is comparable to the grid spacing. In this problem, we model a thin film of thickness $g$ symmetrically placed around $x=0$. The initial field $\\phi_0(x)$ is constructed as a true signed distance function to the interfaces at $x = -g/2$ and $x = +g/2$.\n\nWhen $g$ is on the order of $h$, standard reinitialization can lead to numerical errors. The smoothed sign function $S_{\\epsilon}(\\phi_0)$ has a transition region of width proportional to $\\epsilon = \\alpha h$. If the film is too thin, the smoothing from the left interface can overlap with the smoothing from the right interface. This can create ambiguity in the sign term $S_{\\epsilon}(\\phi_0)$ near the center of the film, leading to incorrect evolution and causing the two interfaces to merge or the film to \"erode\", effectively destroying the feature.\n\n### The Clipping Mitigation Strategy\n\nTo counteract this erosion, a local clipping strategy is introduced. The core idea is to suppress reinitialization in regions where the grid is too coarse to unambiguously determine the nearest interface.\n\n$1$. The initial interface locations, $x_L$ and $x_R$, are found by detecting the zero-crossings of the initial field $\\phi_0$.\n$2$. For each grid point $x_i$, we compute its distance to the left and right interfaces, $d_L = |x_i - x_L|$ and $d_R = |x_i - x_R|$.\n$3$. A \"closeness measure\" $c_i = |d_L - d_R|$ is defined. A small value of $c_i$ indicates that $x_i$ is nearly equidistant from both interfaces. This is the region of ambiguity.\n$4$. A binary weight $w_i$ is defined based on a threshold $\\beta h$:\n   $$\n   w_i = \\begin{cases}\n   0 & \\text{if } c_i < \\beta h \\\\\n   1 & \\text{otherwise}\n   \\end{cases}\n   $$\n$5$. This weight is used to modify the update rule by multiplying the sign term, effectively \"clipping\" or freezing the reinitialization speed where $w_i=0$:\n   $$\n   \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, \\left(w_i S_{\\epsilon}(\\phi_{0,i})\\right)\\, \\left(G_i - 1\\right)\n   $$\nThis strategy selectively applies reinitialization, preserving the film's integrity in under-resolved regions.\n\n### Simulation and Evaluation\n\nThe program implements both the baseline and the clipped reinitialization schemes. It initializes a thin film for three different ratios of film thickness to grid spacing, $g/h$. After a fixed number of reinitialization steps ($N_{\\tau}=300$), two diagnostics are computed:\n- The number of zero-crossings, which indicates if the two interfaces have merged into one or disappeared.\n- The film thickness, measured as the distance between the two zero-crossings that bracket the origin, which quantifies the extent of film erosion.\n\nBy comparing the results of the baseline and clipped schemes, the effectiveness of the mitigation strategy is evaluated across different levels of film resolution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D level set reinitialization problem for a thin film,\n    comparing a baseline scheme with a local clipping mitigation strategy.\n    \"\"\"\n\n    # Define the fixed numerical parameters from the problem statement.\n    L = 1.0\n    N = 801\n    h = 2 * L / (N - 1)\n    alpha = 1.5\n    epsilon = alpha * h\n    dt = 0.3 * h\n    N_tau = 300\n    beta = 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        3.0,  # Case A: g/h = 3.0\n        1.0,  # Case B: g/h = 1.0\n        0.5,  # Case C: g/h = 0.5\n    ]\n    \n    # Grid setup\n    x = np.linspace(-L, L, N, dtype=np.float64)\n    \n    results = []\n\n    def find_zero_crossings(x_grid, phi_field):\n        \"\"\"Finds subcell zero-crossing locations using linear interpolation.\"\"\"\n        crossings = []\n        # Find indices where sign changes\n        indices = np.where(phi_field[:-1] * phi_field[1:] < 0)[0]\n        for i in indices:\n            phi_i, phi_i1 = phi_field[i], phi_field[i+1]\n            x_i, x_i1 = x_grid[i], x_grid[i+1]\n            # Linear interpolation formula for zero crossing\n            x_cross = x_i - phi_i * (x_i1 - x_i) / (phi_i1 - phi_i)\n            crossings.append(x_cross)\n        return sorted(crossings)\n\n    def calculate_diagnostics(crossings, h_spacing):\n        \"\"\"Calculates number of crossings and film thickness.\"\"\"\n        num_crossings = len(crossings)\n        \n        neg_crossings = [c for c in crossings if c <= 0]\n        pos_crossings = [c for c in crossings if c > 0]\n        \n        thickness = 0.0\n        if neg_crossings and pos_crossings:\n            thickness = min(pos_crossings) - max(neg_crossings)\n            \n        return num_crossings, thickness / h_spacing\n\n    for gh_ratio in test_cases:\n        g = gh_ratio * h\n\n        # Build initial signed distance field phi_0\n        dist = np.minimum(np.abs(x + g / 2.0), np.abs(x - g / 2.0))\n        sign_field = np.ones_like(x)\n        sign_field[(x > -g / 2.0) & (x < g / 2.0)] = -1.0\n        phi0 = dist * sign_field\n\n        # Pre-compute the smoothed sign of the initial field\n        s_phi0 = phi0 / np.sqrt(phi0**2 + epsilon**2)\n\n        case_results = [gh_ratio]\n\n        # --- Run simulation for both baseline and clipped schemes ---\n        for use_clipping in [False, True]:\n            phi = phi0.copy()\n            \n            w = np.ones(N) # Default weights (no clipping)\n            if use_clipping:\n                # Calculate clipping weights\n                initial_crossings = find_zero_crossings(x, phi0)\n                if len(initial_crossings) >= 2:\n                    x_L, x_R = initial_crossings[0], initial_crossings[-1]\n                else: # Fallback for unexpected cases\n                    x_L, x_R = -g/2.0, g/2.0\n                \n                d_L = np.abs(x - x_L)\n                d_R = np.abs(x - x_R)\n                c = np.abs(d_L - d_R)\n                w[c < beta * h] = 0.0\n\n            # Evolve in fictitious time\n            for _ in range(N_tau):\n                # Enforce homogeneous Neumann boundary conditions via padding\n                padded_phi = np.pad(phi, 1, 'edge')\n                \n                # Compute one-sided differences\n                diffs = np.diff(padded_phi) / h\n                dm = diffs[:-1]\n                dp = diffs[1:]\n                \n                # Compute Godunov upwind scheme for |nabla phi|\n                grad_phi_sq = np.zeros(N)\n                \n                idx_pos = s_phi0 > 0\n                idx_neg = s_phi0 < 0\n                \n                grad_phi_sq[idx_pos] = np.maximum(np.maximum(dm[idx_pos], 0)**2, np.minimum(dp[idx_pos], 0)**2)\n                grad_phi_sq[idx_neg] = np.maximum(np.maximum(dp[idx_neg], 0)**2, np.minimum(dm[idx_neg], 0)**2)\n                \n                G = np.sqrt(grad_phi_sq)\n                \n                # Update phi\n                update_term = s_phi0\n                if use_clipping:\n                    update_term *= w\n                \n                phi -= dt * update_term * (G - 1)\n\n            # Calculate and store diagnostics for this run\n            final_crossings = find_zero_crossings(x, phi)\n            z_count, t_h_ratio = calculate_diagnostics(final_crossings, h)\n            case_results.extend([z_count, t_h_ratio])\n            \n        results.append(case_results)\n\n    # Format the final output string to be exactly as specified, without spaces\n    formatted_sublists = []\n    for sublist in results:\n        # Format: g/h (float), z_base (int), t_base/h (float), z_clip (int), t_clip/h (float)\n        # Ensure correct types for formatting\n        formatted_items = [\n            f\"{sublist[0]:.1f}\",\n            str(int(sublist[1])),\n            f\"{sublist[2]:.6f}\",\n            str(int(sublist[3])),\n            f\"{sublist[4]:.6f}\"\n        ]\n        formatted_sublists.append(f\"[{','.join(formatted_items)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3339798"}]}