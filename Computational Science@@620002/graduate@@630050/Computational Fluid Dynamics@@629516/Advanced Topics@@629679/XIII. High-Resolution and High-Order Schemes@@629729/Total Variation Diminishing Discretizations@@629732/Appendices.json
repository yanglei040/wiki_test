{"hands_on_practices": [{"introduction": "A powerful technique to probe the behavior of a finite difference scheme is modified equation analysis, which reveals the partial differential equation that the scheme *actually* solves, including its leading-order error terms. This practice guides you through the analytical derivation of the numerical viscosity coefficient $\\nu_{\\mathrm{num}}$ and dispersion coefficient $\\mu_{\\mathrm{num}}$ for the MUSCL scheme [@problem_id:3383815]. By completing this 'paper-and-pencil' exercise, you will gain a fundamental understanding of how flux limiters contribute to the scheme's third-order dispersion error, which governs its accuracy in smooth regions.", "problem": "Consider the linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a>0$ on a uniform grid with spacing $\\Delta x$ and time step $\\Delta t$. Define the Courant number $C = a\\,\\Delta t/\\Delta x$. Consider a finite-volume Total Variation Diminishing (TVD) Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) discretization written in the canonical flux-limiter form for linear flux $f(u)=a\\,u$:\n$$\nu_{i}^{n+1} \\;=\\; u_{i}^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\,\\Big(f_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}}\\Big), \n\\qquad\nf_{i+\\frac{1}{2}} \\;=\\; a\\,u_{i} \\;+\\; \\frac{a}{2}\\,(1-C)\\,\\phi(r_{i})\\,\\big(u_{i+1}-u_{i}\\big),\n$$\nwith the standard smoothness indicator \n$$\nr_{i} \\;=\\; \\frac{u_{i}-u_{i-1}}{u_{i+1}-u_{i}},\n$$\nand with limiter functions $\\phi(r)$ chosen from the following Total Variation Diminishing (TVD) set:\n- minmod: $\\phi_{\\mathrm{mm}}(r) = \\max(0, \\min(1,r))$,\n- monotonized central (MC): $\\phi_{\\mathrm{MC}}(r) = \\max(0, \\min(2r, (1+r)/2, 2))$,\n- van Leer: $\\phi_{\\mathrm{vL}}(r) = \\frac{r+|r|}{1+|r|}$.\n\nAssume a smooth, monotone, convex local profile, specifically $u_{x}>0$ and $u_{xx}>0$ at the evaluation point, so that $r_{i}$ lies in a neighborhood just below $1$. Perform a modified equation analysis up to and including $O(\\Delta x^{2})$ terms, linearizing the limiter about $r=1$ and keeping only terms linear in $u_{x}$, $u_{xx}$, and $u_{xxx}$ (i.e., neglecting products such as $u_{xx}^{2}/u_{x}$). In other words, seek the continuous equation of the form\n$$\nu_{t} + a\\,u_{x} \\;=\\; \\nu_{\\mathrm{num}}(C)\\,\\Delta x\\,u_{xx} \\;+\\; \\mu_{\\mathrm{num}}(C)\\,\\Delta x^{2}\\,u_{xxx} \\;+\\; O(\\Delta x^{3}),\n$$\nand compute the leading-order numerical viscosity coefficient $\\nu_{\\mathrm{num}}(C)$ and dispersion coefficient $\\mu_{\\mathrm{num}}(C)$ for each limiter listed above, expressing your results in closed form as analytic functions of $C$ and $a$. Provide your final answer as a single row matrix containing, in order, the pair for minmod, the pair for MC, and the pair for van Leer:\n$$\n\\big(\\nu_{\\mathrm{mm}}(C),\\,\\mu_{\\mathrm{mm}}(C),\\,\\nu_{\\mathrm{MC}}(C),\\,\\mu_{\\mathrm{MC}}(C),\\,\\nu_{\\mathrm{vL}}(C),\\,\\mu_{\\mathrm{vL}}(C)\\big).\n$$\nNo numerical evaluation is required; give exact analytic expressions. The final answer must be an analytical expression without units.", "solution": "The user wants to perform a modified equation analysis on a specific Total Variation Diminishing (TVD) Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) discretization of the linear advection equation.\n\n### Step 1: Problem Validation\n\n**Extracted Givens:**\n- Governing Equation: $u_t + a u_x = 0$ with constant advection speed $a > 0$.\n- Grid: Uniform with cell size $\\Delta x$ and time step $\\Delta t$.\n- Courant Number: $C = a \\frac{\\Delta t}{\\Delta x}$.\n- Discretization Scheme:\n  $$ u_{i}^{n+1} = u_{i}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(f_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}}\\right) $$\n- Numerical Flux:\n  $$ f_{i+\\frac{1}{2}} = a u_i + \\frac{a}{2}(1-C)\\phi(r_i)(u_{i+1}-u_i) $$\n- Smoothness Indicator:\n  $$ r_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i} $$\n- Flux Limiters:\n  - minmod: $\\phi_{\\mathrm{mm}}(r) = \\max(0, \\min(1,r))$\n  - MC: $\\phi_{\\mathrm{MC}}(r) = \\max(0, \\min(2r, \\frac{1+r}{2}, 2))$\n  - van Leer: $\\phi_{\\mathrm{vL}}(r) = \\frac{r+|r|}{1+|r|}$\n- Assumption: The solution is smooth, monotone, and convex ($u_x > 0, u_{xx} > 0$), which implies $r_i$ is near $1$ from below.\n- Objective: Find the coefficients $\\nu_{\\mathrm{num}}(C)$ and $\\mu_{\\mathrm{num}}(C)$ in the modified equation:\n  $$ u_t + a u_x = \\nu_{\\mathrm{num}}(C) \\Delta x u_{xx} + \\mu_{\\mathrm{num}}(C) \\Delta x^2 u_{xxx} + O(\\Delta x^3) $$\n- Additional Instruction: The analysis involves linearizing $\\phi(r)$ about $r=1$ and neglecting non-linear terms in derivatives (e.g., $u_{xx}^2/u_x$).\n\n**Validation Verdict:**\nThe problem is **valid**. It is a standard, well-posed problem in the field of computational fluid dynamics concerning the accuracy analysis of numerical schemes. All provided information is scientifically sound, self-contained, and formalizable. The task is to perform a rigorous mathematical derivation, which is a standard procedure in this field.\n\n### Step 2: Solution Derivation\n\nThe analysis proceeds by applying Taylor series expansions to the terms of the discrete equation to derive its continuous, or modified, counterpart.\n\nThe discrete scheme is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = -\\frac{1}{\\Delta x}\\left(f_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}}\\right)\n$$\n\n**Left-Hand Side (LHS) Expansion:**\nWe expand $u_i^{n+1} = u(x_i, t_n + \\Delta t)$ in a Taylor series around $(x_i, t_n)$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = u_t + \\frac{\\Delta t}{2}u_{tt} + \\frac{\\Delta t^2}{6}u_{ttt} + O(\\Delta t^3)\n$$\nTo express time derivatives in terms of spatial derivatives, we use the modified equation itself, $u_t = -a u_x + O(\\Delta x)$.\n$u_{tt} = \\frac{\\partial}{\\partial t}(-a u_x + \\dots) = -a u_{xt} = -a \\frac{\\partial}{\\partial x}(u_t) \\approx -a \\frac{\\partial}{\\partial x}(-a u_x) = a^2 u_{xx}$.\n$u_{ttt} \\approx \\frac{\\partial}{\\partial t}(a^2 u_{xx}) = -a^3 u_{xxx}$.\nSubstituting these and using $C = a \\Delta t / \\Delta x$:\n$$\nLHS = u_t + \\frac{a^2 \\Delta t}{2}u_{xx} - \\frac{a^3 \\Delta t^2}{6}u_{xxx} + \\dots = u_t + \\frac{a C \\Delta x}{2}u_{xx} - \\frac{a C^2 \\Delta x^2}{6}u_{xxx} + \\dots\n$$\n\n**Right-Hand Side (RHS) Expansion:**\nThe RHS involves the divergence of the numerical flux. The flux difference is:\n$$\nf_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}} = \\left[a u_i + \\frac{a(1-C)}{2}\\phi(r_i)(u_{i+1}-u_i)\\right] - \\left[a u_{i-1} + \\frac{a(1-C)}{2}\\phi(r_{i-1})(u_i-u_{i-1})\\right]\n$$\n$$\n= a(u_i - u_{i-1}) + \\frac{a(1-C)}{2}\\left[\\phi(r_i)(u_{i+1}-u_i) - \\phi(r_{i-1})(u_i-u_{i-1})\\right]\n$$\nWe expand all terms around $x_i$, denoting derivatives of $u$ at $x_i$ by $u_x, u_{xx}$, etc.\n$$\nu_{i \\pm k} = u \\pm k\\Delta x u_x + \\frac{(k\\Delta x)^2}{2}u_{xx} \\pm \\frac{(k\\Delta x)^3}{6}u_{xxx} + \\dots\n$$\nThe difference terms are:\n$$\nu_i - u_{i-1} = \\Delta x u_x - \\frac{\\Delta x^2}{2} u_{xx} + \\frac{\\Delta x^3}{6} u_{xxx} + O(\\Delta x^4)\n$$\n$$\nu_{i+1} - u_i = \\Delta x u_x + \\frac{\\Delta x^2}{2} u_{xx} + \\frac{\\Delta x^3}{6} u_{xxx} + O(\\Delta x^4)\n$$\nThe smoothness indicator $r_i$ is expanded as:\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i} = \\frac{1 - \\frac{\\Delta x}{2}\\frac{u_{xx}}{u_x} + \\frac{\\Delta x^2}{6}\\frac{u_{xxx}}{u_x} - \\dots}{1 + \\frac{\\Delta x}{2}\\frac{u_{xx}}{u_x} + \\frac{\\Delta x^2}{6}\\frac{u_{xxx}}{u_x} + \\dots} \\approx 1 - \\Delta x \\frac{u_{xx}}{u_x} + O(\\Delta x^2)\n$$\nwhere we neglect products of derivatives as per the instructions. This implies $r_i - 1 \\approx -\\Delta x \\frac{u_{xx}}{u_x}$.\nThe limiter function is linearized around $r=1$: $\\phi(r_i) \\approx \\phi(1) + \\phi'(1)(r_i-1)$. For all specified limiters, in the region $r \\to 1^-$, $\\phi(1)=1$.\n$$\n\\phi(r_i) \\approx 1 - \\phi'(1)\\Delta x \\frac{u_{xx}}{u_x}\n$$\nSimilarly, $r_{i-1} = r(x_i - \\Delta x) \\approx r(x_i) - \\Delta x \\frac{dr}{dx}|_{x_i}$.\n$$\n\\frac{dr}{dx} \\approx \\frac{d}{dx}\\left(-\\Delta x \\frac{u_{xx}}{u_x}\\right) \\approx -\\Delta x \\frac{u_{xxx}}{u_x}\n$$\nSo, $r_{i-1} \\approx \\left(1 - \\Delta x \\frac{u_{xx}}{u_x}\\right) - \\Delta x \\left(-\\Delta x \\frac{u_{xxx}}{u_x}\\right) = 1 - \\Delta x \\frac{u_{xx}}{u_x} + \\Delta x^2 \\frac{u_{xxx}}{u_x}$.\n$$\n\\phi(r_{i-1}) \\approx 1 + \\phi'(1)(r_{i-1}-1) = 1 + \\phi'(1)\\left(-\\Delta x \\frac{u_{xx}}{u_x} + \\Delta x^2 \\frac{u_{xxx}}{u_x}\\right)\n$$\nNow we expand the bracketed term in the flux difference, let's call it $T$:\n$$\nT = \\phi(r_i)(u_{i+1}-u_i) - \\phi(r_{i-1})(u_i-u_{i-1})\n$$\n$$\n\\phi(r_i)(u_{i+1}-u_i) \\approx \\left(1-\\phi'(1)\\Delta x \\frac{u_{xx}}{u_x}\\right)\\left(\\Delta x u_x + \\frac{\\Delta x^2}{2}u_{xx} + \\dots\\right) \\approx \\Delta x u_x + \\left(\\frac{1}{2}-\\phi'(1)\\right)\\Delta x^2 u_{xx} + \\dots\n$$\n$$\n\\phi(r_{i-1})(u_i-u_{i-1}) \\approx \\left(1-\\phi'(1)\\Delta x \\frac{u_{xx}}{u_x} + \\phi'(1)\\Delta x^2\\frac{u_{xxx}}{u_x}\\right)\\left(\\Delta x u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx}\\right)\n$$\n$$\n\\approx \\Delta x u_x - \\left(\\frac{1}{2}+\\phi'(1)\\right)\\Delta x^2 u_{xx} + \\left(\\frac{1}{6}+\\phi'(1)\\right)\\Delta x^3 u_{xxx} + \\dots\n$$\nSubtracting these two expressions gives:\n$$\nT \\approx \\Delta x^2 u_{xx} - \\phi'(1)\\Delta x^3 u_{xxx}\n$$\nSubstituting this into the flux difference expression:\n$$\nf_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}} = a\\left(\\Delta x u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx}\\right) + \\frac{a(1-C)}{2}\\left(\\Delta x^2 u_{xx} - \\phi'(1)\\Delta x^3 u_{xxx}\\right)\n$$\n$$\n= a\\Delta x u_x + \\left(-\\frac{a}{2} + \\frac{a(1-C)}{2}\\right)\\Delta x^2 u_{xx} + \\left(\\frac{a}{6} - \\frac{a(1-C)\\phi'(1)}{2}\\right)\\Delta x^3 u_{xxx}\n$$\n$$\n= a\\Delta x u_x - \\frac{aC}{2}\\Delta x^2 u_{xx} + a\\left(\\frac{1}{6} - \\frac{(1-C)\\phi'(1)}{2}\\right)\\Delta x^3 u_{xxx}\n$$\nThe RHS of the discrete equation is:\n$$\nRHS = -\\frac{1}{\\Delta x}(f_{i+\\frac{1}{2}} - f_{i-\\frac{1}{2}}) = -a u_x + \\frac{aC}{2}\\Delta x u_{xx} - a\\left(\\frac{1}{6} - \\frac{(1-C)\\phi'(1)}{2}\\right)\\Delta x^2 u_{xxx}\n$$\nEquating the expanded LHS and RHS:\n$$\nu_t + \\frac{a C \\Delta x}{2}u_{xx} - \\frac{a C^2 \\Delta x^2}{6}u_{xxx} = -a u_x + \\frac{aC}{2}\\Delta x u_{xx} - a\\left(\\frac{1}{6} - \\frac{(1-C)\\phi'(1)}{2}\\right)\\Delta x^2 u_{xxx}\n$$\nRearranging to the desired form $u_t + a u_x = \\dots$:\n$$\nu_t + a u_x = \\left(\\frac{aC}{2}\\Delta x - \\frac{aC\\Delta x}{2}\\right)u_{xx} + \\left[\\frac{a C^2 \\Delta x^2}{6} - a\\left(\\frac{1}{6} - \\frac{(1-C)\\phi'(1)}{2}\\right)\\Delta x^2\\right]u_{xxx}\n$$\nThe coefficient of the $u_{xx}$ term (numerical viscosity) is zero:\n$$\n\\nu_{\\mathrm{num}}(C)\\Delta x = 0 \\implies \\nu_{\\mathrm{num}}(C) = 0\n$$\nThis is expected, as the scheme is designed to be second-order accurate in space in smooth regions.\n\nThe coefficient of the $u_{xxx}$ term (numerical dispersion) is:\n$$\n\\mu_{\\mathrm{num}}(C)\\Delta x^2 = \\left[\\frac{aC^2}{6} - \\frac{a}{6} + \\frac{a(1-C)\\phi'(1)}{2}\\right]\\Delta x^2\n$$\n$$\n\\mu_{\\mathrm{num}}(C) = \\frac{a}{6}[C^2 - 1 + 3(1-C)\\phi'(1)]\n$$\n\n**Evaluating for Each Limiter:**\nWe need to find $\\phi'(1)$ for each limiter as $r\\to 1^-$.\n1.  **minmod:** For $0 < r < 1$, $\\phi_{\\mathrm{mm}}(r) = r$. Thus, $\\phi'_{\\mathrm{mm}}(1) = 1$.\n2.  **MC:** For $r$ near $1$, $\\frac{1+r}{2}$ is the smallest argument in the `min` function. $\\phi_{\\mathrm{MC}}(r) = \\frac{1+r}{2}$. Thus, $\\phi'_{\\mathrm{MC}}(1) = \\frac{1}{2}$.\n3.  **van Leer:** For $r > 0$, $\\phi_{\\mathrm{vL}}(r) = \\frac{2r}{1+r}$. The derivative is $\\phi'_{\\mathrm{vL}}(r) = \\frac{2}{(1+r)^2}$. Thus, $\\phi'_{\\mathrm{vL}}(1) = \\frac{2}{(1+1)^2} = \\frac{1}{2}$.\n\nSubstituting these values into the expression for $\\mu_{\\mathrm{num}}(C)$:\n- **minmod ($\\phi'(1)=1$):**\n  $$\n  \\mu_{\\mathrm{mm}}(C) = \\frac{a}{6}[C^2 - 1 + 3(1-C)] = \\frac{a}{6}[C^2 - 3C + 2] = \\frac{a}{6}(C-1)(C-2)\n  $$\n- **MC ($\\phi'(1)=\\frac{1}{2}$):**\n  $$\n  \\mu_{\\mathrm{MC}}(C) = \\frac{a}{6}\\left[C^2 - 1 + 3(1-C)\\frac{1}{2}\\right] = \\frac{a}{6}\\left[C^2 - 1 + \\frac{3}{2} - \\frac{3}{2}C\\right] = \\frac{a}{6}\\left[C^2 - \\frac{3}{2}C + \\frac{1}{2}\\right] = \\frac{a}{12}(2C^2 - 3C + 1) = \\frac{a}{12}(2C-1)(C-1)\n  $$\n- **van Leer ($\\phi'(1)=\\frac{1}{2}$):**\n  The result is the same as for the MC limiter.\n  $$\n  \\mu_{\\mathrm{vL}}(C) = \\frac{a}{12}(2C-1)(C-1)\n  $$\n\nThe six requested coefficients are:\n- $\\nu_{\\mathrm{mm}}(C) = 0$\n- $\\mu_{\\mathrm{mm}}(C) = \\frac{a}{6}(C-1)(C-2)$\n- $\\nu_{\\mathrm{MC}}(C) = 0$\n- $\\mu_{\\mathrm{MC}}(C) = \\frac{a}{12}(2C-1)(C-1)$\n- $\\nu_{\\mathrm{vL}}(C) = 0$\n- $\\mu_{\\mathrm{vL}}(C) = \\frac{a}{12}(2C-1)(C-1)$\nThese are assembled into a single row matrix for the final answer.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{a}{6}(C-1)(C-2) & 0 & \\frac{a}{12}(2C-1)(C-1) & 0 & \\frac{a}{12}(2C-1)(C-1) \\end{pmatrix}}\n$$", "id": "3383815"}, {"introduction": "Flux limiters are the core component that gives TVD schemes their non-oscillatory character, adaptively blending high- and low-resolution fluxes. This hands-on coding exercise challenges you to compare the behavior of several classic limiters by observing their effect on the total variation, $TV(u)$, of a solution with a sharp jump [@problem_id:3383804]. By implementing the scheme and tracking how $TV(u)$ evolves, you will develop an intuitive feel for the trade-off between compressive, sharp-interface capturing and smooth, oscillation-free results.", "problem": "Consider the linear advection equation in conservative form for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\nposed on a periodic domain of length $L$. Let the initial condition be a unit step with left state $u_L$ and right state $u_R$, positioned at a point $x_s \\in [0,L)$, and let the spatial grid be uniform with $N_x$ control volumes. The goal is to numerically study how the total variation evolves under high-resolution second-order Total Variation Diminishing (TVD) Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) using three different flux limiters: minmod, Monotonized Central (MC), and superbee.\n\nBase your derivation and implementation on the following foundational principles and facts:\n- Conservation-law finite volume update for cell averages $u_i^n$ with a consistent numerical flux $F_{i+1/2}^n$,\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right).\n$$\n- The Courant number $C$ is given by $C = a\\,\\Delta t / \\Delta x$.\n- The total variation of a grid function $u^n = \\{u_i^n\\}$ on a periodic grid is\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|,\n$$\nwith periodic indexing so that $u_{N_x}^n \\equiv u_0^n$.\n- For constant $a>0$, a high-resolution TVD flux-limiter method consistent with the Sweby framework combines an upwind monotone flux with a limited high-order correction depending on the local smoothness ratio $r_i$ and a limiter function $\\phi(r)$, such that the scheme is second-order accurate in smooth regions and reduces to a monotone upwind method near discontinuities. Assume standard MUSCL-type reconstruction with $r_i$ defined by one-sided discrete gradients and a limiter $\\phi(r)$ belonging to the classical TVD admissible set.\n\nUse the following limiter functions defined on the smoothness ratio $r$ (with the convention that if the denominator in $r$ is zero, then $r=0$ is to be used):\n- Minmod limiter: $\\phi_{\\text{MM}}(r) = \\max(0, \\min(1, r))$.\n- Monotonized Central limiter: $\\phi_{\\text{MC}}(r) = \\max(0, \\min((1+r)/2, 2, 2r))$.\n- Superbee limiter: $\\phi_{\\text{SB}}(r) = \\max(0, \\min(2r,1), \\min(r,2))$.\n\nYour task is to:\n- Derive a conservative second-order MUSCL-type TVD discretization for the linear advection equation with the above limiters, ensuring it respects the Total Variation Diminishing property for Courant numbers $C$ in the admissible range.\n- Implement the derived method and compute the total variation $TV(u^n)$ at selected time steps for a periodic step initial condition, under the same Courant number across all three limiters, to compare limiter aggressiveness via the evolution of total variation.\n\nImplementation details to use for this study:\n- Domain: periodic interval $[0,L)$ with $L = 1$.\n- Advection speed: $a = 1$.\n- Number of grid cells: $N_x = 400$.\n- Initial condition: $u(x,0) = u_L$ for $x < x_s$ and $u(x,0) = u_R$ for $x \\ge x_s$, with $u_L = 1$, $u_R = 0$, and $x_s = 0.3$.\n- Time integration: explicit single-step update as per the conservative finite-volume method with a MUSCL-type TVD numerical flux consistent with the above principles. Periodic boundary conditions must be enforced.\n- Courant numbers and sampling schedule (test suite):\n    - Test A (happy path): $C = 0.8$, evolve for $N_{\\text{steps}} = 80$ time steps and record total variation at time steps $n \\in \\{0,10,20,40,80\\}$.\n    - Test B (diffusive edge): $C = 0.2$, evolve for $N_{\\text{steps}} = 80$ and record $TV(u^n)$ at the same set of steps $n \\in \\{0,10,20,40,80\\}$.\n    - Test C (CFL boundary): $C = 1.0$, evolve for $N_{\\text{steps}} = 80$ and record $TV(u^n)$ at the same set of steps $n \\in \\{0,10,20,40,80\\}$.\n- For each test, compute and report the sequence of total variations for each limiter in the order: minmod, MC, superbee.\n\nYour program must produce a single line of output containing all results aggregated into one flat list of floating-point values, ordered as follows: for each test in the order A, B, C, and within each test for each limiter in the order minmod, MC, superbee, append the total variation values at the steps $n \\in \\{0,10,20,40,80\\}$ in increasing order of $n$. The final output format must be a single Python-style list on one line, for example,\n\"[v_1,v_2, ... , v_M]\",\nwhere each $v_k$ is a floating-point number representing one measured total variation. No physical units are required for the output since $TV(u^n)$ is dimensionless.", "solution": "We start from the linear advection equation for a scalar $u(x,t)$ with constant advection speed $a$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(a\\,u\\right) = 0,\n$$\non a periodic domain. The conservative finite volume method updates cell averages $u_i^n$ via\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right),\n$$\nwhere $F_{i+1/2}^n$ is a consistent numerical flux approximating $a\\,u$ at the interface between cells $i$ and $i+1$. For a constant $a>0$, a monotone upwind flux is $F_{i+1/2}^{\\text{up}} = a\\,u_i^n$. This yields a first-order method that is Total Variation Diminishing (TVD) but diffusive. To restore second-order accuracy in smooth regions while retaining TVD properties near discontinuities, we adopt a high-resolution MUSCL (Monotonic Upstream-centered Schemes for Conservation Laws) flux-limiter approach consistent with the Sweby framework.\n\nThe Courant number is $C = a\\,\\Delta t/\\Delta x$, and for $0 \\le C \\le 1$ the TVD property can be ensured with suitable limiters. The key idea is to correct the upwind flux by a limited high-order term based on local smoothness. Define forward and backward differences $\\Delta^+ u_i = u_{i+1}^n - u_i^n$ and $\\Delta^- u_i = u_i^n - u_{i-1}^n$, and define the smoothness ratio\n$$\nr_i = \\frac{\\Delta^- u_i}{\\Delta^+ u_i},\n$$\nwith the convention $r_i = 0$ whenever $\\Delta^+ u_i = 0$ to avoid division by zero and to remain within the TVD monotone upwind baseline in flat regions. A general second-order TVD flux for $a>0$ consistent with the Sweby diagram takes the form\n$$\nF_{i+1/2}^n = a\\,u_i^n + \\frac{1}{2}\\,a\\,\\left(1 - C\\right)\\,\\phi(r_i)\\,\\left(u_{i+1}^n - u_i^n\\right),\n$$\nwhere $\\phi(r)$ is a limiter function constrained to the TVD admissible region so that the resulting scheme is TVD for $0 \\le C \\le 1$. The Total Variation Diminishing property is understood as\n$$\nTV(u^{n+1}) \\le TV(u^n),\n$$\nwhere for periodic data\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left|u_{i+1}^n - u_i^n\\right|, \\quad u_{N_x}^n \\equiv u_0^n.\n$$\n\nWe employ three classical limiter functions:\n- Minmod: $\\phi_{\\text{MM}}(r) = \\max(0,\\min(1,r))$, aggressively limiting to avoid spurious oscillations and thus introducing more numerical diffusion relative to other TVD limiters.\n- Monotonized Central (MC): $\\phi_{\\text{MC}}(r) = \\max(0, \\min((1+r)/2, 2, 2r))$, a balanced limiter with moderate compressiveness and good accuracy in smooth regions.\n- Superbee: $\\phi_{\\text{SB}}(r) = \\max(0,\\min(2r,1),\\min(r,2))$, a highly compressive limiter that best preserves sharp discontinuities while remaining TVD for $0 \\le C \\le 1$.\n\nPrinciple-based justification:\n- The discretization is conservative by construction since it updates through flux differences, ensuring that the domain-integrated quantity $\\sum_i u_i^n$ is preserved under periodic boundaries.\n- The TVD property follows from Harten’s theorem for monotone fluxes with limited antidiffusive corrections bounded by the Sweby constraints. The choice $F_{i+1/2}^n = F_{i+1/2}^{\\text{up}} +$ limited correction keeps the modified scheme within the TVD class when $0 \\le C \\le 1$ and $\\phi(r)$ lies in the admissible set.\n- For $C = 1$, the high-order correction term vanishes and the scheme reduces exactly to the upwind method with $u_i^{n+1} = u_{i-1}^n$, i.e., a pure shift by one cell, which preserves total variation exactly. For $0 < C < 1$, the correction provides second-order accuracy in smooth regions, while limiting enforces non-oscillatory behavior near discontinuities.\n\nAlgorithmic design:\n- Initialize a uniform grid with $N_x = 400$ on $[0,1)$ with cell centers $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$, where $\\Delta x = L/N_x$ and $L=1$.\n- Initialize $u_i^0 = u_L$ if $x_i < x_s$ and $u_R$ otherwise, with $u_L = 1$, $u_R = 0$, and $x_s = 0.3$. Under periodicity, this creates two jumps and hence $TV(u^0) \\approx 2$.\n- For each test Courant number $C \\in \\{0.8,0.2,1.0\\}$, set $\\Delta t = C\\,\\Delta x/a$ with $a=1$. Evolve for $N_{\\text{steps}} = 80$ by repeating:\n    - Compute periodic forward differences $\\Delta^+ u_i$ and backward differences $\\Delta^- u_i$.\n    - Form $r_i = \\Delta^- u_i/\\Delta^+ u_i$ where $\\Delta^+ u_i \\ne 0$, otherwise set $r_i=0$.\n    - Evaluate $\\phi(r_i)$ for the chosen limiter.\n    - Assemble fluxes $F_{i+1/2}^n = a\\,u_i^n + \\frac{1}{2}a(1-C)\\phi(r_i)\\,\\Delta^+ u_i$ for all interfaces with periodic indexing.\n    - Update $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$ using periodic shifts to obtain $F_{i-1/2}^n$.\n    - At specified time steps $n \\in \\{0,10,20,40,80\\}$, compute $TV(u^n)$ by summing $|\\Delta^+ u_i|$ over all $i$ with periodic indexing.\n- Repeat the above for each limiter choice: minmod, MC, superbee.\n\nExpected qualitative behavior:\n- For $C = 0.8$ (happy path), minmod will damp total variation more aggressively, MC will retain more variation, and superbee will preserve the most variation and the sharpest front while remaining TVD.\n- For $C = 0.2$ (more diffusive due to smaller Courant number), all limiters will show a more pronounced decay in total variation, with the ordering of aggressiveness unchanged: minmod most diffusive, superbee least.\n- For $C = 1.0$ (Courant–Friedrichs–Lewy boundary), the correction vanishes and the method reduces to pure upwind translation by one cell per time step, preserving $TV$ exactly for this linear problem.\n\nTest suite and output:\n- Test A: $C=0.8$, record $TV$ at $n \\in \\{0,10,20,40,80\\}$ for the three limiters in the order minmod, MC, superbee.\n- Test B: $C=0.2$, same sampling.\n- Test C: $C=1.0$, same sampling.\n- The program must output a single line with a flat Python-style list of floating-point values ordered as follows: Test A minmod sequence, Test A MC sequence, Test A superbee sequence, then Test B in the same order, then Test C in the same order.\n\nSince $TV(u^n)$ is dimensionless, no units are required in the final answer. The numerical scheme and sampling as described are sufficient to compute all requested values, and Total Variation Diminishing behavior should manifest as a non-increasing sequence within each limiter’s sampled times, with the superbee limiter showing the least decay in total variation across the same time horizon compared to MC and minmod.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi_minmod(r):\n    # phi_MM(r) = max(0, min(1, r))\n    return np.maximum(0.0, np.minimum(1.0, r))\n\ndef phi_mc(r):\n    # phi_MC(r) = max(0, min((1+r)/2, 2, 2r))\n    a = (1.0 + r) / 2.0\n    b = 2.0 * np.ones_like(r)\n    c = 2.0 * r\n    return np.maximum(0.0, np.minimum(np.minimum(a, b), c))\n\ndef phi_superbee(r):\n    # phi_SB(r) = max(0, min(2r, 1), min(r, 2))\n    return np.maximum(0.0, np.maximum(np.minimum(2.0 * r, 1.0), np.minimum(r, 2.0)))\n\ndef compute_tv(u):\n    \"\"\"Total variation on periodic grid.\"\"\"\n    return np.sum(np.abs(np.roll(u, -1) - u))\n\ndef muscl_tvd_advection_tv_sequence(C, limiter_name, Nx=400, L=1.0, a=1.0, nsteps=80, checkpoints=(0,10,20,40,80)):\n    \"\"\"\n    Compute TV sequence for linear advection using a MUSCL-type TVD flux-limiter scheme.\n    Periodic boundaries. Step initial condition: u_L=1 for x<x_s and u_R=0 else.\n    \"\"\"\n    dx = L / Nx\n    dt = C * dx / a\n\n    # Grid cell centers\n    x = (np.arange(Nx) + 0.5) * dx\n    # Step initial condition\n    x_s = 0.3\n    uL, uR = 1.0, 0.0\n    u = np.where(x < x_s, uL, uR).astype(float)\n\n    # Choose limiter function\n    if limiter_name == 'minmod':\n        phi = phi_minmod\n    elif limiter_name == 'mc':\n        phi = phi_mc\n    elif limiter_name == 'superbee':\n        phi = phi_superbee\n    else:\n        raise ValueError(\"Unknown limiter\")\n\n    eps = 1e-14\n    tvs = []\n    checkpoint_set = set(checkpoints)\n    max_step = nsteps\n\n    # Record initial TV if requested\n    if 0 in checkpoint_set:\n        tvs.append(compute_tv(u))\n\n    for n in range(1, max_step + 1):\n        # Periodic differences\n        du_plus = np.roll(u, -1) - u\n        du_minus = u - np.roll(u, 1)\n\n        # Smoothness ratio r = du_minus / du_plus with safe handling of zero denominator\n        denom = du_plus\n        r = np.zeros_like(u)\n        mask = np.abs(denom) > eps\n        r[mask] = du_minus[mask] / denom[mask]\n\n        # Limiter values\n        phi_r = phi(r)\n\n        # Numerical flux at i+1/2 for a > 0:\n        # F_{i+1/2} = a*u_i + 0.5*a*(1 - C)*phi(r_i)*(u_{i+1} - u_i)\n        F_iphalf = a * (u + 0.5 * (1.0 - C) * phi_r * du_plus)\n\n        # Update: u^{n+1} = u^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        u = u - (dt / dx) * (F_iphalf - np.roll(F_iphalf, 1))\n\n        if n in checkpoint_set:\n            tvs.append(compute_tv(u))\n\n    # Ensure ordering of outputs matches the checkpoints tuple order\n    # The tvs currently appended in time order for requested checkpoints.\n    # If 0 was included, it's first; otherwise, tvs starts at first positive checkpoint.\n    # To be safe, rebuild according to exact checkpoints order.\n    # Re-simulating to reorder would be expensive; instead, we regenerate with storage by step.\n    # However, since we appended exactly when encountered and checkpoints are increasing, tvs\n    # is in the same order as checkpoints. We'll assert this assumption:\n    if len(tvs) != len(checkpoints):\n        # In case 0 not in checkpoints, we need to recompute mapping:\n        # But per our use, checkpoints always include 0.\n        pass\n    return tvs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Courant number C, total steps, checkpoints)\n    test_cases = [\n        (0.8, 80, (0, 10, 20, 40, 80)),  # Test A: happy path\n        (0.2, 80, (0, 10, 20, 40, 80)),  # Test B: diffusive edge\n        (1.0, 80, (0, 10, 20, 40, 80)),  # Test C: CFL boundary\n    ]\n\n    limiters = ['minmod', 'mc', 'superbee']  # Order: minmod, MC, superbee\n\n    results = []\n    for C, nsteps, checkpoints in test_cases:\n        for lim in limiters:\n            tv_seq = muscl_tvd_advection_tv_sequence(C, lim, Nx=400, L=1.0, a=1.0, nsteps=nsteps, checkpoints=checkpoints)\n            # Append sequence to results\n            results.extend(tv_seq)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3383804"}, {"introduction": "Moving beyond the linear scalar advection equation is a crucial step toward solving real-world problems. This culminating practice challenges you to apply your knowledge to the non-linear shallow water equations, a fundamental model in geophysical fluid dynamics [@problem_id:3383825]. You will construct a complete, robust finite volume scheme that not only is Total Variation Diminishing in the water height $h$, but also handles critical physical constraints such as positivity ($h \\ge 0$) and well-balancing for stationary states.", "problem": "Consider the one-dimensional shallow water system (no bathymetry) consisting of the mass and momentum conservation laws\n$$\nh_t + (hu)_x = 0,\\qquad (hu)_t + \\left(hu^2 + \\tfrac{1}{2} g h^2\\right)_x = 0,\n$$\nwhere $h$ is the water height, $u$ is the velocity, $hu$ is the discharge, and $g$ is the gravitational acceleration. The computational task is to design a finite volume discretization that is Total Variation Diminishing (TVD) in $h$, preserves non-negativity of $h$ in the presence of dry beds ($h=0$), and is well-balanced for the lake-at-rest state (constant $h$ and zero velocity $u=0$). You must construct a second-order accurate in space reconstruction for cell interface states using a slope limiter and a single-step method whose stability property implies TVD under a Courant–Friedrichs–Lewy (CFL) constraint. You must select a monotone numerical flux that is consistent with the hyperbolic structure of the system and supports positivity preservation for $h$ under an appropriate time step restriction.\n\nYour derivation must start from the finite volume form of a generic conservation law on a uniform grid of cell centers $x_i$ with spacing $\\Delta x$, cell averages $Q_i^n$ at time $t^n$, and interface fluxes at $x_{i\\pm \\frac{1}{2}}$, together with the definition of total variation\n$$\nTV(h^n) = \\sum_{i} \\left|h_{i+1}^n - h_i^n\\right|.\n$$\nFrom these bases, derive the requirements on the reconstruction, flux, and time discretization that ensure\n$$\nh_i^{n+1} \\ge 0\\quad\\text{for all }i,\\qquad TV(h^{n+1}) \\le TV(h^n),\n$$\nand that the lake-at-rest state $h\\equiv \\text{constant}$, $u\\equiv 0$ is exactly preserved by your scheme. Restrict attention to a one-dimensional periodic domain or transmissive (zero-gradient) boundaries on a finite interval, and assume the gravitational acceleration parameter is $g=9.81$ expressed in $\\mathrm{m/s^2}$; the final answers in this problem are booleans and therefore do not require physical units.\n\nImplement your derived algorithm as a program that performs one Strong Stability Preserving step of the time integration on each test case below (with a single time step chosen from a computed CFL condition). The spatial grid is uniform with $N$ cells, domain length $L$, and spacing $\\Delta x = L/N$. The CFL-based time step must be computed as\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i\\left(|u_i| + \\sqrt{g\\,h_i}\\right)},\n$$\nwith a fixed $\\text{CFL}$ chosen by you to meet the TVD and positivity conditions. Use transmissive boundary conditions.\n\nTest suite:\n- Case A (lake at rest, well-balanced and TVD check): $L=1.0$, $N=100$, $g=9.81$, $h(x,0)=1.0$ for all $x$, $u(x,0)=0$ for all $x$.\n- Case B (dam-break with dry bed on the right, positivity and TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=1.0$ for $x<0.5$ and $h(x,0)=0.0$ for $x\\ge 0.5$, $u(x,0)=0$.\n- Case C (smooth small-amplitude perturbation, TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=1.0+0.2\\sin(2\\pi x)$, $u(x,0)=0$.\n- Case D (near-vacuum with dry bed, positivity and TVD check): $L=1.0$, $N=200$, $g=9.81$, $h(x,0)=10^{-3}$ for $x<0.5$ and $h(x,0)=0.0$ for $x\\ge 0.5$, $u(x,0)=0$.\n\nFor each case, perform exactly one second-order Strong Stability Preserving step of your scheme and evaluate the following criteria:\n- Non-negativity: $\\min_i h_i^{n+1} \\ge 0$.\n- TVD: $TV(h^{n+1}) \\le TV(h^n)$.\n- For Case A only, well-balanced: $\\max_i |h_i^{n+1}-h_i^n| + \\max_i |(hu)_i^{n+1}-(hu)_i^n|$ is less than a small tolerance.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,true,true,true]\"). Each entry is a boolean corresponding to Cases A–D, where \"true\" indicates that all required criteria for that case are satisfied and \"false\" otherwise. No other output is permitted.", "solution": "We begin from the finite volume form of a conservation law for a vector of conserved variables $Q=(q_1,q_2)$, here chosen as $Q=(h,hu)$, on a uniform grid with cell centers $x_i$ and spacing $\\Delta x$. The semi-discrete finite volume method for a hyperbolic system $Q_t + F(Q)_x=0$ is\n$$\n\\frac{d Q_i}{d t} = - \\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nwhere $F_{i\\pm\\frac{1}{2}}$ are consistent numerical fluxes approximating $F(Q)$ at interfaces. A forward Euler update with time step $\\Delta t$ reads\n$$\nQ_i^{n+1} = Q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right).\n$$\nTo achieve second-order spatial accuracy while controlling spurious oscillations near discontinuities, we use a piecewise linear reconstruction with a slope limiter. For a scalar variable $w_i$ (either $h$ or $u$), define limited slopes $\\sigma_i$ by a Total Variation Diminishing limiter, for example the minmod limiter:\n$$\n\\operatorname{minmod}(a,b) = \\begin{cases}\n\\mathrm{sign}(a)\\min(|a|,|b|), & \\text{if } ab>0,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nand set\n$$\n\\sigma_i = \\operatorname{minmod}(w_i - w_{i-1},\\, w_{i+1} - w_i).\n$$\nThe left and right reconstructed states at interface $x_{i+\\frac{1}{2}}$ are then\n$$\nw_{i+\\frac{1}{2}}^L = w_i + \\tfrac{1}{2}\\sigma_i,\\qquad\nw_{i+\\frac{1}{2}}^R = w_{i+1} - \\tfrac{1}{2}\\sigma_{i+1}.\n$$\nWe perform this reconstruction on the primitive pair $(h,u)$, followed by conversion to conserved variables at interfaces via $(h,hu)=(h,h\\,u)$. To guarantee $h\\ge 0$ in reconstructed states in the presence of dry beds, we clip interface heights by\n$$\nh_{i+\\frac{1}{2}}^{L} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{L},\\,0\\},\\quad\nh_{i+\\frac{1}{2}}^{R} \\leftarrow \\max\\{h_{i+\\frac{1}{2}}^{R},\\,0\\},\n$$\nand set the corresponding discharge to $0$ whenever $h=0$, i.e., if $h_{i+\\frac{1}{2}}^{L}=0$ then $(hu)_{i+\\frac{1}{2}}^{L}=0$, and similarly on the right. This reconstruction is TVD for $h$ because the minmod limiter ensures that the discrete total variation cannot increase under a forward Euler step with a monotone flux and a suitable time step restriction, and Strong Stability Preserving time integrators inherit this TVD property under the same restriction scaled by their stability coefficient.\n\nFor the numerical flux, we select a monotone approximate Riemann solver with positivity-preserving properties. A widely used choice with these properties is the two-wave Harten–Lax–van Leer–Einfeldt (HLLE) flux. Given left and right states $Q^L=(h^L,(hu)^L)$ and $Q^R=(h^R,(hu)^R)$ at an interface, define primitive velocities and wave speeds by\n$$\nu^L = \\begin{cases}\\frac{(hu)^L}{h^L}, & h^L>0,\\\\ 0, & h^L=0,\\end{cases}\\quad\nu^R = \\begin{cases}\\frac{(hu)^R}{h^R}, & h^R>0,\\\\ 0, & h^R=0,\\end{cases}\n$$\n$$\nc^L = \\sqrt{g h^L},\\qquad c^R = \\sqrt{g h^R},\n$$\nand signal speeds\n$$\ns_L = \\min\\{u^L - c^L,\\, u^R - c^R\\},\\qquad s_R = \\max\\{u^L + c^L,\\, u^R + c^R\\}.\n$$\nLet the physical flux be $F(Q)=(hu,\\, (hu)^2/h + \\tfrac{1}{2} g h^2)$ for $h>0$ and $F(Q)=(0,0)$ if $h=0$. The HLLE flux is\n$$\nF_{\\mathrm{HLLE}} =\n\\begin{cases}\nF(Q^L), & s_L \\ge 0,\\\\\nF(Q^R), & s_R \\le 0,\\\\\n\\frac{s_R F(Q^L) - s_L F(Q^R) + s_L s_R (Q^R - Q^L)}{s_R - s_L}, & s_L < 0 < s_R.\n\\end{cases}\n$$\nUnder the Courant–Friedrichs–Lewy condition\n$$\n\\Delta t \\le \\frac{\\Delta x}{\\max_i(|u_i| + \\sqrt{g h_i})},\n$$\nthe HLLE flux combined with forward Euler is monotone and positivity-preserving for $h$. Using a minmod limiter for $h$ makes the forward Euler update TVD in $h$. To achieve second-order temporal accuracy while preserving TVD, we employ a second-order Strong Stability Preserving Runge–Kutta method (also called Shu–Osher scheme):\n$$\nQ^{(1)} = Q^n + \\Delta t\\, L(Q^n),\\qquad\nQ^{n+1} = \\tfrac{1}{2} Q^n + \\tfrac{1}{2}\\left(Q^{(1)} + \\Delta t\\, L(Q^{(1)})\\right),\n$$\nwhere $L(Q)$ denotes the semi-discrete operator $L(Q)_i = -\\tfrac{1}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$ with the above reconstruction and flux. The Strong Stability Preserving theory ensures that if forward Euler with time step $\\Delta t$ is TVD in $h$, then this Runge–Kutta method is also TVD provided the same time step restriction is respected.\n\nWell-balancedness for the lake-at-rest state $h\\equiv H$, $u\\equiv 0$ follows because the reconstruction produces constant left and right states $h^L=h^R=H$, $u^L=u^R=0$ at every interface, leading to identical fluxes at adjacent interfaces. Consequently, $F_{i+\\frac{1}{2}}=F_{i-\\frac{1}{2}}$ and $L(Q)=0$, so both stages of the Strong Stability Preserving method leave the state unchanged exactly up to round-off errors.\n\nAlgorithmic steps:\n1. Initialize $h_i$ and $u_i$ from the test case. Form $Q_i=(h_i, h_i u_i)$.\n2. Compute $\\Delta x=L/N$ and a time step $\\Delta t=\\text{CFL}\\,\\Delta x / \\max_i(|u_i|+\\sqrt{g h_i})$ with $\\text{CFL}$ in $(0,1)$ chosen to satisfy the TVD and positivity conditions (we take a conservative choice).\n3. Apply transmissive boundary conditions by copying end cell values into ghost cells.\n4. Reconstruct interface states for $(h,u)$ by minmod-limited piecewise linear reconstruction and clip $h\\ge 0$ at interfaces; set $hu=0$ wherever $h=0$.\n5. Compute HLLE fluxes at interfaces, then the semi-discrete operator $L(Q)$.\n6. Perform one Strong Stability Preserving second-order step to obtain $Q^{n+1}$.\n7. Evaluate the criteria: non-negativity of $h$, TVD for $h$ by comparing $TV(h^{n+1})$ and $TV(h^n)$, and for the lake-at-rest case check that both $h$ and $hu$ remain unchanged within a small tolerance.\n8. Output booleans per case indicating whether all case-specific criteria are satisfied.\n\nThis construction integrates core hyperbolic conservation law discretization principles, slope-limited reconstruction for TVD, monotone flux for positivity, and Strong Stability Preserving time stepping. The HLLE flux is consistent and monotone, and the minmod limiter suppresses new extrema in $h$, satisfying the TVD requirement under the CFL restriction. The lake-at-rest well-balanced property holds because the reconstruction and flux computation do not perturb constant states.", "answer": "```python\nimport numpy as np\n\n# Shallow water TVD solver with HLLE flux, minmod-limited MUSCL reconstruction, and SSP RK2.\n# Domain: 1D, transmissive boundaries.\n\ndef minmod(a, b):\n    \"\"\"Minmod limiter for two arrays a, b.\"\"\"\n    sign = np.sign(a)\n    cond = (a * b) > 0.0\n    return np.where(cond, sign * np.minimum(np.abs(a), np.abs(b)), 0.0)\n\ndef apply_transmissive_bc(h, m):\n    \"\"\"Apply transmissive (zero-gradient) boundary conditions to ghost cells.\"\"\"\n    # h and m include ghost cells indices [0..N+1], real cells [1..N]\n    h[0] = h[1]\n    h[-1] = h[-2]\n    m[0] = m[1]\n    m[-1] = m[-2]\n\ndef reconstruct_interfaces(h, m, g, eps=1e-14):\n    \"\"\"\n    Reconstruct left/right states (h,u) at interfaces using minmod limiter on (h,u),\n    then convert to conserved (h,hu). Clip h >= 0, set hu = 0 where h == 0.\n    Input arrays h, m include ghost cells.\n    Returns arrays hL, mL, hR, mR for interfaces i=0..N (N+1 interfaces).\n    \"\"\"\n    Np2 = h.shape[0]  # includes ghost cells\n    N = Np2 - 2       # number of real cells\n    # Compute primitive velocity u in cells, with safe handling near dryness.\n    u = np.zeros_like(h)\n    mask = h > eps\n    u[mask] = m[mask] / h[mask]\n    u[~mask] = 0.0\n\n    # Limited slopes for h and u in real cells [1..N]\n    dh_left = h[1:N+1] - h[0:N]      # h_i - h_{i-1}\n    dh_right = h[2:N+2] - h[1:N+1]   # h_{i+1} - h_i\n    du_left = u[1:N+1] - u[0:N]\n    du_right = u[2:N+2] - u[1:N+1]\n    sigma_h = minmod(dh_left, dh_right)\n    sigma_u = minmod(du_left, du_right)\n\n    # Prepare arrays for interface states\n    hL = np.zeros(N+1)\n    hR = np.zeros(N+1)\n    uL = np.zeros(N+1)\n    uR = np.zeros(N+1)\n\n    # For interfaces i=0..N, left cell index is i, right cell index is i+1 in full arrays\n    # Left state from cell i:\n    # For i in [1..N-1], use limited slope; for i=0 or i=N, slope = 0 (ghost or boundary)\n    # Build extended slope arrays with boundaries:\n    sigma_h_ext = np.zeros(N+2)\n    sigma_u_ext = np.zeros(N+2)\n    sigma_h_ext[1:N+1] = sigma_h\n    sigma_u_ext[1:N+1] = sigma_u\n\n    # Left states\n    hL[:] = h[0:N+1] + 0.5 * sigma_h_ext[0:N+1]\n    uL[:] = u[0:N+1] + 0.5 * sigma_u_ext[0:N+1]\n    # Right states\n    hR[:] = h[1:N+2] - 0.5 * sigma_h_ext[1:N+2]\n    uR[:] = u[1:N+2] - 0.5 * sigma_u_ext[1:N+2]\n\n    # Positivity clip for reconstructed heights, and set velocity zero where h==0\n    hL = np.maximum(hL, 0.0)\n    hR = np.maximum(hR, 0.0)\n    uL = np.where(hL > eps, uL, 0.0)\n    uR = np.where(hR > eps, uR, 0.0)\n\n    # Convert to conserved discharge\n    mL = hL * uL\n    mR = hR * uR\n\n    return hL, mL, hR, mR\n\ndef hlle_flux(hL, mL, hR, mR, g, eps=1e-14):\n    \"\"\"\n    Compute HLLE flux for shallow water at interfaces.\n    Inputs are arrays at interfaces.\n    Returns flux arrays Fh, Fm at interfaces.\n    \"\"\"\n    # Primitive velocities and wave speeds\n    uL = np.zeros_like(hL)\n    uR = np.zeros_like(hR)\n    maskL = hL > eps\n    maskR = hR > eps\n    uL[maskL] = mL[maskL] / hL[maskL]\n    uR[maskR] = mR[maskR] / hR[maskR]\n\n    cL = np.sqrt(g * hL)\n    cR = np.sqrt(g * hR)\n\n    sL = np.minimum(uL - cL, uR - cR)\n    sR = np.maximum(uL + cL, uR + cR)\n\n    # Physical fluxes\n    FhL = mL\n    FhR = mR\n\n    FmL = np.where(maskL, mL * uL + 0.5 * g * hL * hL, 0.0)\n    FmR = np.where(maskR, mR * uR + 0.5 * g * hR * hR, 0.0)\n\n    Fh = np.zeros_like(hL)\n    Fm = np.zeros_like(hL)\n\n    # Regions: sL >= 0, sR <= 0, else\n    left_dom = sL >= 0.0\n    right_dom = sR <= 0.0\n    mid_dom = ~(left_dom | right_dom)\n\n    Fh[left_dom] = FhL[left_dom]\n    Fm[left_dom] = FmL[left_dom]\n\n    Fh[right_dom] = FhR[right_dom]\n    Fm[right_dom] = FmR[right_dom]\n\n    denom = sR[mid_dom] - sL[mid_dom]\n    # Avoid division by zero; where denom is tiny, pick average of left/right flux\n    safe = np.where(np.abs(denom) > 1e-14, denom, 1e-14)\n\n    Fh[mid_dom] = (sR[mid_dom] * FhL[mid_dom] - sL[mid_dom] * FhR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (hR[mid_dom] - hL[mid_dom])) / safe\n    Fm[mid_dom] = (sR[mid_dom] * FmL[mid_dom] - sL[mid_dom] * FmR[mid_dom] +\n                   sL[mid_dom] * sR[mid_dom] * (mR[mid_dom] - mL[mid_dom])) / safe\n\n    return Fh, Fm\n\ndef semi_discrete_L(h, m, g, dx):\n    \"\"\"\n    Compute L(Q) = -(F_{i+1/2} - F_{i-1/2})/dx for arrays with ghost cells.\n    Returns arrays Lh, Lm for real cells [1..N].\n    \"\"\"\n    # Apply BCs\n    apply_transmissive_bc(h, m)\n    # Reconstruct interface states\n    hL, mL, hR, mR = reconstruct_interfaces(h, m, g)\n    # Compute fluxes at interfaces\n    Fh, Fm = hlle_flux(hL, mL, hR, mR, g)\n    # Compute L for real cells: i=1..N using interfaces 0..N\n    Lh = -(Fh[1:] - Fh[:-1]) / dx\n    Lm = -(Fm[1:] - Fm[:-1]) / dx\n    return Lh, Lm\n\ndef ssp_rk2_step(h, m, g, dx, dt):\n    \"\"\"\n    One SSP RK2 step for arrays h, m including ghost cells.\n    Returns new arrays h_new, m_new including ghost cells.\n    \"\"\"\n    # Stage 1\n    Lh1, Lm1 = semi_discrete_L(h.copy(), m.copy(), g, dx)\n    h1 = h.copy()\n    m1 = m.copy()\n    h1[1:-1] = h[1:-1] + dt * Lh1\n    m1[1:-1] = m[1:-1] + dt * Lm1\n\n    # Stage 2\n    Lh2, Lm2 = semi_discrete_L(h1.copy(), m1.copy(), g, dx)\n    h2 = h1.copy()\n    m2 = m1.copy()\n    h2[1:-1] = h1[1:-1] + dt * Lh2\n    m2[1:-1] = m1[1:-1] + dt * Lm2\n\n    # Combine\n    h_new = h.copy()\n    m_new = m.copy()\n    h_new[1:-1] = 0.5 * (h[1:-1] + h2[1:-1])\n    m_new[1:-1] = 0.5 * (m[1:-1] + m2[1:-1])\n\n    # Apply BCs to the result\n    apply_transmissive_bc(h_new, m_new)\n    return h_new, m_new\n\ndef compute_tv(h_real):\n    \"\"\"Compute total variation of h over real cells.\"\"\"\n    return np.sum(np.abs(h_real[1:] - h_real[:-1]))\n\ndef initial_conditions(case, L, N):\n    \"\"\"Generate initial h and u arrays for a given case.\"\"\"\n    x = (np.arange(N) + 0.5) * (L / N)\n    if case == \"lake\":\n        h = np.ones_like(x) * 1.0\n        u = np.zeros_like(x)\n    elif case == \"dam_dry\":\n        h = np.where(x < 0.5, 1.0, 0.0)\n        u = np.zeros_like(x)\n    elif case == \"smooth\":\n        h = 1.0 + 0.2 * np.sin(2.0 * np.pi * x)\n        u = np.zeros_like(x)\n    elif case == \"near_vacuum\":\n        h = np.where(x < 0.5, 1e-3, 0.0)\n        u = np.zeros_like(x)\n    else:\n        raise ValueError(\"Unknown case\")\n    return h, u\n\ndef cfl_dt(h_real, m_real, g, dx, CFL, eps=1e-14):\n    \"\"\"Compute time step from CFL.\"\"\"\n    u_real = np.zeros_like(h_real)\n    mask = h_real > eps\n    u_real[mask] = m_real[mask] / h_real[mask]\n    speeds = np.abs(u_real) + np.sqrt(g * h_real)\n    amax = np.max(speeds)\n    if amax < eps:\n        # If no wave speed (dry or zero), pick small dt\n        return CFL * dx / (eps + 1.0)\n    return CFL * dx / amax\n\ndef run_case(case_name, L, N, g, CFL, tol=1e-12):\n    \"\"\"Run one SSP RK2 step for the given case and return boolean result.\"\"\"\n    dx = L / N\n    # Allocate with ghost cells\n    h_real, u_real = initial_conditions(case_name, L, N)\n    m_real = h_real * u_real\n\n    # Add ghost cells\n    h = np.zeros(N + 2)\n    m = np.zeros(N + 2)\n    h[1:-1] = h_real\n    m[1:-1] = m_real\n    apply_transmissive_bc(h, m)\n\n    # Compute initial TV\n    tv0 = compute_tv(h[1:-1])\n\n    # Time step from CFL\n    dt = cfl_dt(h[1:-1], m[1:-1], g, dx, CFL)\n\n    # SSP RK2 step\n    h_new, m_new = ssp_rk2_step(h, m, g, dx, dt)\n\n    # Extract real cells\n    h1 = h_new[1:-1]\n    m1 = m_new[1:-1]\n\n    # Checks\n    positive = (np.min(h1) >= -tol)\n    tv1 = compute_tv(h1)\n    tvd = (tv1 <= tv0 + tol)\n\n    if case_name == \"lake\":\n        # Well-balanced: state unchanged within tolerance\n        wb = (np.max(np.abs(h1 - h[1:-1])) + np.max(np.abs(m1 - m[1:-1])) <= tol)\n        return bool(positive and tvd and wb)\n    else:\n        return bool(positive and tvd)\n\ndef solve():\n    g = 9.81  # gravitational acceleration\n    # Choose conservative CFL for TVD and positivity\n    CFL = 0.45\n\n    test_cases = [\n        (\"lake\", 1.0, 100, g, CFL),\n        (\"dam_dry\", 1.0, 200, g, CFL),\n        (\"smooth\", 1.0, 200, g, CFL),\n        (\"near_vacuum\", 1.0, 200, g, CFL),\n    ]\n\n    results = []\n    for name, L, N, gval, cfl in test_cases:\n        res = run_case(name, L, N, gval, cfl)\n        results.append(res)\n\n    # Print in the exact required format: comma-separated booleans in brackets\n    # Use lowercase 'true'/'false' to match example format strictly.\n    def to_str(b):\n        return \"true\" if b else \"false\"\n\n    print(f\"[{','.join(map(to_str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3383825"}]}