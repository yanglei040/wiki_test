{"hands_on_practices": [{"introduction": "An essential claim of multigrid methods is their optimal computational efficiency, meaning the solution cost scales linearly with the number of unknowns. This exercise provides a concrete method for verifying this claim by performing a detailed work-unit analysis for a typical V-cycle. By accounting for the costs of smoothing, restriction, and prolongation across a grid hierarchy, you will gain quantitative insight into why the total computational cost of a multigrid cycle is only a small constant multiple of the work done on the finest grid alone [@problem_id:3322361].", "problem": "Consider a Full Multigrid (FMG) solution strategy for a three-dimensional elliptic problem discretized on nested grids with levels $\\ell = 0, 1, 2, 3, 4$, where $\\ell = 0$ is the finest level and $\\ell = 4$ is the coarsest level. Between successive levels, the grid is coarsened by a factor of $2$ in each spatial dimension, so the number of unknowns scales as $n_{\\ell} = n_{0} \\times 8^{-\\ell}$. Assume that the computational work of one level-$\\ell$ sparse matrix-vector product (SpMV) scales linearly with the number of unknowns; consequently, the cost of one level-$\\ell$ SpMV, expressed in units of a finest-level SpMV, is $r_{\\ell} = 8^{-\\ell}$.\n\nConsider a single V-cycle starting on level $\\ell = 0$, descending to level $\\ell = 4$, solving on the coarsest level, and returning to level $\\ell = 0$. At each level $\\ell = 0, 1, 2, 3$, the V-cycle performs $\\nu_{1} = 2$ pre-smoothing sweeps and $\\nu_{2} = 1$ post-smoothing sweep. At the coarsest level $\\ell = 4$, the algorithm performs a coarse-grid solve with no smoothing. The per-operation costs on level $\\ell$, measured in units of a level-$\\ell$ SpMV, are:\n- one smoothing sweep costs $c_{s} = 1$,\n- one restriction from level $\\ell$ to level $\\ell+1$ costs $c_{r} = \\frac{1}{4}$,\n- one prolongation from level $\\ell+1$ to level $\\ell$ costs $c_{p} = \\frac{1}{2}$,\n- the coarse-grid solve on level $\\ell = 4$ costs $c_{0} = 16$.\n\nCompute the total work $W$ of this V-cycle, expressed in units of a finest-level SpMV (that is, normalized by the cost of a single finest-level SpMV). Then determine which single component contributes the largest share of $W$ among the four categories: smoothing, restriction, prolongation, and coarse-grid solve. Report the dominant component using the index $\\kappa$ defined as follows: $\\kappa = 1$ for smoothing, $\\kappa = 2$ for restriction, $\\kappa = 3$ for prolongation, and $\\kappa = 4$ for coarse-grid solve.\n\nExpress the total work $W$ exactly (no rounding), and provide the final answer as a two-entry row vector $\\left(W, \\kappa\\right)$ using the LaTeX $\\texttt{pmatrix}$ environment, in units of a finest-level SpMV.", "solution": "The user wants me to solve the following problem:\n\"Consider a Full Multigrid (FMG) solution strategy for a three-dimensional elliptic problem discretized on nested grids with levels $\\ell = 0, 1, 2, 3, 4$, where $\\ell = 0$ is the finest level and $\\ell = 4$ is the coarsest level. Between successive levels, the grid is coarsened by a factor of $2$ in each spatial dimension, so the number of unknowns scales as $n_{\\ell} = n_{0} \\times 8^{-\\ell}$. Assume that the computational work of one level-$\\ell$ sparse matrix-vector product (SpMV) scales linearly with the number of unknowns; consequently, the cost of one level-$\\ell$ SpMV, expressed in units of a finest-level SpMV, is $r_{\\ell} = 8^{-\\ell}$.\n\nConsider a single V-cycle starting on level $\\ell = 0$, descending to level $\\ell = 4$, solving on the coarsest level, and returning to level $\\ell = 0$. At each level $\\ell = 0, 1, 2, 3$, the V-cycle performs $\\nu_{1} = 2$ pre-smoothing sweeps and $\\nu_{2} = 1$ post-smoothing sweep. At the coarsest level $\\ell = 4$, the algorithm performs a coarse-grid solve with no smoothing. The per-operation costs on level $\\ell$, measured in units of a level-$\\ell$ SpMV, are:\n- one smoothing sweep costs $c_{s} = 1$,\n- one restriction from level $\\ell$ to level $\\ell+1$ costs $c_{r} = \\frac{1}{4}$,\n- one prolongation from level $\\ell+1$ to level $\\ell$ costs $c_{p} = \\frac{1}{2}$,\n- the coarse-grid solve on level $\\ell = 4$ costs $c_{0} = 16$.\n\nCompute the total work $W$ of this V-cycle, expressed in units of a finest-level SpMV (that is, normalized by the cost of a single finest-level SpMV). Then determine which single component contributes the largest share of $W$ among the four categories: smoothing, restriction, prolongation, and coarse-grid solve. Report the dominant component using the index $\\kappa$ defined as follows: $\\kappa = 1$ for smoothing, $\\kappa = 2$ for restriction, $\\kappa = 3$ for prolongation, and $\\kappa = 4$ for coarse-grid solve.\n\nExpress the total work $W$ exactly (no rounding), and provide the final answer as a two-entry row vector $\\left(W, \\kappa\\right)$ using the LaTeX $\\texttt{pmatrix}$ environment, in units of a finest-level SpMV.\"\n\n### Step 1: Extract Givens\n- Grid levels: $\\ell = 0, 1, 2, 3, 4$, with $\\ell=0$ being the finest and $\\ell=4$ being the coarsest.\n- Scaling of unknowns: $n_{\\ell} = n_{0} \\times 8^{-\\ell}$.\n- Relative cost of a level-$\\ell$ SpMV: $r_{\\ell} = 8^{-\\ell}$ (in units of a finest-level, $\\ell=0$, SpMV).\n- V-cycle structure: Starts on level $\\ell=0$, descends to $\\ell=4$, returns to $\\ell=0$.\n- Pre-smoothing sweeps on levels $\\ell=0, 1, 2, 3$: $\\nu_{1} = 2$.\n- Post-smoothing sweeps on levels $\\ell=0, 1, 2, 3$: $\\nu_{2} = 1$.\n- No smoothing on coarsest level $\\ell=4$.\n- Per-operation costs in units of a level-$\\ell$ SpMV:\n  - Smoothing sweep: $c_{s} = 1$.\n  - Restriction ($\\ell \\to \\ell+1$): $c_{r} = \\frac{1}{4}$.\n  - Prolongation ($\\ell+1 \\to \\ell$): $c_{p} = \\frac{1}{2}$.\n- Coarse-grid solve cost on level $\\ell=4$: $c_{0} = 16$ (in units of a level-$4$ SpMV).\n- Output definition: Total work $W$ and dominant component index $\\kappa$, where $\\kappa=1$ for smoothing, $\\kappa=2$ for restriction, $\\kappa=3$ for prolongation, $\\kappa=4$ for coarse-grid solve.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement describes a standard computational cost analysis of a multigrid V-cycle, a staple topic in numerical analysis and computational science.\n- **Scientifically Grounded**: The problem is based on established principles of multigrid algorithms. The scaling assumptions are standard for geometric multigrid on structured grids.\n- **Well-Posed**: The problem provides a complete set of parameters and a clear objective, leading to a unique, computable solution.\n- **Objective**: The problem is stated in precise, quantitative terms, free from ambiguity or subjectivity.\n- **Incomplete or Contradictory Setup**: The problem is self-contained. All necessary data (number of levels, sweeps, and relative costs) are provided and are not contradictory. The phrasing \"Full Multigrid (FMG) solution strategy\" provides context, but the task is narrowly and clearly defined as the analysis of a single V-cycle, making it a well-posed sub-problem.\n- **Other flaws**: The problem does not exhibit any other flaws from the checklist. It is a formal, quantitative problem requiring substantive calculation.\n\n### Step 3: Verdict and Action\nThe problem is valid. A rigorous solution can be constructed.\n\n### Solution\nThe objective is to compute the total computational work $W$ of a single V-cycle, expressed in units of a finest-level ($\\ell=0$) sparse matrix-vector product (SpMV), and to identify the dominant work component. The total work $W$ is the sum of the work contributions from smoothing ($W_s$), restriction ($W_r$), prolongation ($W_p$), and the coarse-grid solve ($W_c$).\n\nThe cost of any operation performed on grid level $\\ell$ must be normalized by the cost of a finest-level SpMV. This is achieved by multiplying the operation's cost (given in units of a level-$\\ell$ SpMV) by the factor $r_{\\ell} = 8^{-\\ell}$.\n\n1.  **Work of Smoothing ($W_s$)**\n    Smoothing is performed on levels $\\ell = 0, 1, 2, 3$. On each of these levels, there are $\\nu_{1} = 2$ pre-smoothing sweeps and $\\nu_{2} = 1$ post-smoothing sweep. The cost of a single smoothing sweep on level $\\ell$ is $c_s = 1$ level-$\\ell$ SpMV.\n    The total smoothing work is the sum of costs over the relevant levels:\n    $$W_s = \\sum_{\\ell=0}^{3} (\\nu_{1} + \\nu_{2}) c_s r_{\\ell} = \\sum_{\\ell=0}^{3} (2+1)(1) (8^{-\\ell}) = 3 \\sum_{\\ell=0}^{3} 8^{-\\ell}$$\n\n2.  **Work of Restriction ($W_r$)**\n    Restriction from level $\\ell$ to $\\ell+1$ occurs for $\\ell = 0, 1, 2, 3$. The cost $c_r = \\frac{1}{4}$ is measured in units of a level-$\\ell$ SpMV.\n    The total restriction work is:\n    $$W_r = \\sum_{\\ell=0}^{3} c_r r_{\\ell} = \\sum_{\\ell=0}^{3} \\frac{1}{4} (8^{-\\ell}) = \\frac{1}{4} \\sum_{\\ell=0}^{3} 8^{-\\ell}$$\n\n3.  **Work of Prolongation ($W_p$)**\n    Prolongation from level $\\ell+1$ to $\\ell$ occurs for $\\ell = 0, 1, 2, 3$. The cost $c_p = \\frac{1}{2}$ is measured in units of a level-$\\ell$ SpMV, as the operation targets the finer grid.\n    The total prolongation work is:\n    $$W_p = \\sum_{\\ell=0}^{3} c_p r_{\\ell} = \\sum_{\\ell=0}^{3} \\frac{1}{2} (8^{-\\ell}) = \\frac{1}{2} \\sum_{\\ell=0}^{3} 8^{-\\ell}$$\n\n4.  **Work of Coarse-Grid Solve ($W_c$)**\n    The coarse-grid solve is performed once on the coarsest level, $\\ell = 4$. Its cost is $c_0 = 16$ level-$4$ SpMVs.\n    The work contribution is:\n    $$W_c = c_0 r_{4} = 16 \\times 8^{-4} = \\frac{16}{8^4} = \\frac{16}{4096} = \\frac{1}{256}$$\n\nTo compute the total work, we first evaluate the geometric series sum, which appears in the expressions for $W_s$, $W_r$, and $W_p$:\n$$S = \\sum_{\\ell=0}^{3} 8^{-\\ell} = 8^{-0} + 8^{-1} + 8^{-2} + 8^{-3} = 1 + \\frac{1}{8} + \\frac{1}{64} + \\frac{1}{512}$$\n$$S = \\frac{512}{512} + \\frac{64}{512} + \\frac{8}{512} + \\frac{1}{512} = \\frac{512+64+8+1}{512} = \\frac{585}{512}$$\n\nNow we can calculate the work for each component:\n$W_s = 3 \\times S = 3 \\times \\frac{585}{512} = \\frac{1755}{512}$\n$W_r = \\frac{1}{4} \\times S = \\frac{1}{4} \\times \\frac{585}{512} = \\frac{585}{2048}$\n$W_p = \\frac{1}{2} \\times S = \\frac{1}{2} \\times \\frac{585}{512} = \\frac{585}{1024}$\n$W_c = \\frac{1}{256}$\n\nThe total work $W$ is the sum of these components:\n$$W = W_s + W_r + W_p + W_c = \\frac{1755}{512} + \\frac{585}{2048} + \\frac{585}{1024} + \\frac{1}{256}$$\nTo sum these fractions, we find a common denominator, which is $2048$:\n$$W = \\frac{1755 \\times 4}{2048} + \\frac{585}{2048} + \\frac{585 \\times 2}{2048} + \\frac{1 \\times 8}{2048}$$\n$$W = \\frac{7020}{2048} + \\frac{585}{2048} + \\frac{1170}{2048} + \\frac{8}{2048} = \\frac{7020 + 585 + 1170 + 8}{2048} = \\frac{8783}{2048}$$\n\nFinally, to determine the dominant component, we compare the values of $W_s$, $W_r$, $W_p$, and $W_c$ using the common denominator $2048$:\n- Smoothing ($\\kappa=1$): $W_s = \\frac{7020}{2048}$\n- Restriction ($\\kappa=2$): $W_r = \\frac{585}{2048}$\n- Prolongation ($\\kappa=3$): $W_p = \\frac{1170}{2048}$\n- Coarse-grid solve ($\\kappa=4$): $W_c = \\frac{8}{2048}$\n\nComparing the numerators, $7020 > 1170 > 585 > 8$. The largest contribution comes from smoothing. Therefore, the dominant component index is $\\kappa=1$.\n\nThe final answer consists of the total work $W$ and the dominant component index $\\kappa$.\n$W = \\frac{8783}{2048}$\n$\\kappa = 1$", "answer": "$$\n\\boxed{\n\\begin{pmatrix} \\frac{8783}{2048} & 1 \\end{pmatrix}\n}\n$$", "id": "3322361"}, {"introduction": "Most real-world fluid dynamics problems are inherently nonlinear, which requires an extension of the standard linear multigrid correction scheme. This practice delves into the Full Approximation Scheme (FAS), the most common and robust multigrid approach for nonlinear systems. By explicitly calculating the crucial $\\tau$-correction term for a nonlinear diffusion problem, you will understand how FAS enables the coarse grid to accurately model the full nonlinear problem, ensuring consistency across the grid hierarchy and maintaining rapid convergence [@problem_id:3322340].", "problem": "Consider the one-dimensional nonlinear diffusion boundary-value problem on the interval $\\Omega=[0,1]$ with homogeneous Dirichlet boundary conditions,\n$$\n- \\partial_{x}\\!\\left(\\kappa(u)\\,\\partial_{x} u\\right) \\;=\\; f(x), \n\\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere $\\kappa(u)=1+u^{2}$ and $f(x)=1$. Let the equation be discretized in conservative form using a cell-centered finite-difference/finite-volume viewpoint on two nested, uniform grids: a fine grid with spacing $h=1/4$ and a coarse grid with spacing $H=1/2$. The fine-grid nodes are located at $x_{i}=i h$ for $i=0,1,2,3,4$ and the coarse-grid nodes at $X_{J}=J H$ for $J=0,1,2$.\n\nOn either grid, define the discrete diffusion operator $L_{\\Delta}(\\cdot)$ (with $\\Delta\\in\\{h,H\\}$) at an interior node by\n$$\n\\left[L_{\\Delta}(u)\\right]_{i} \\;=\\; -\\frac{1}{\\Delta^{2}}\\Big( K_{i+\\tfrac{1}{2}}\\,(u_{i+1}-u_{i}) \\;-\\; K_{i-\\tfrac{1}{2}}\\,(u_{i}-u_{i-1}) \\Big),\n$$\nwhere the face coefficients are given by the arithmetic average $K_{i+\\tfrac{1}{2}}=\\tfrac{1}{2}\\big(\\kappa(u_{i+1})+\\kappa(u_{i})\\big)$ evaluated at neighboring nodal states. On the fine grid, the given current approximation is\n$$\nu_{h}(0)=0,\\quad u_{h}(0.25)=0.2,\\quad u_{h}(0.5)=0.3,\\quad u_{h}(0.75)=0.1,\\quad u_{h}(1)=0.\n$$\n\nDefine the restriction of fine-grid states to the coarse grid by point injection at coincident nodes, i.e., $\\hat{u}_{H}(0)=0$, $\\hat{u}_{H}(0.5)=u_{h}(0.5)$, $\\hat{u}_{H}(1)=0$, and define restriction of discrete operator values (or residuals) from fine to coarse by full weighting in one dimension, i.e., for the unique interior coarse node $X_{1}=0.5$ associated with fine node $x_{2}=0.5$,\n$$\n\\left[I_{h}^{H} w_{h}\\right]_{1} \\;=\\; \\tfrac{1}{4}\\,w_{1} \\;+\\; \\tfrac{1}{2}\\,w_{2} \\;+\\; \\tfrac{1}{4}\\,w_{3}.\n$$\n\nLet the coarse-grid right-hand side be defined by restriction of the fine-grid right-hand side, $f_{H}=I_{h}^{H} f_{h}$, where $f_{h,i}=1$ at each fine interior node.\n\nStarting from conservation and the Full Approximation Scheme (FAS) for nonlinear multigrid, derive the explicit formula for the coarse-grid $\\tau$-correction at the unique interior coarse node $X_{1}$ and compute its value for the data above. Then write down the resulting coarse-grid equation with and without the $\\tau$-correction, and explain, based on these constructions, why including $\\tau_{H}$ improves two-grid convergence for this nonlinear problem.\n\nReport the computed value of the coarse-grid $\\tau$-correction at $X_{1}$ as a single dimensionless number, rounded to six significant figures.", "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to proceed with a solution.\n\nThe core of the problem lies in the Full Approximation Scheme (FAS) for nonlinear multigrid methods. The fine-grid discrete equation is $L_h(u_h) = f_h$. Given a current approximation to the solution on the fine grid, which we will also denote $u_h$ as per the problem's notation, the goal is to compute a correction on a coarser grid. The FAS coarse-grid equation is designed to solve for a coarse-grid variable $u_H$ that is an approximation to the full solution, not just a correction. It is given by:\n$$\nL_H(u_H) = L_H(\\hat{u}_H) + I_h^H \\left( f_h - L_h(u_h) \\right)\n$$\nwhere $u_h$ is the current fine-grid approximation, $\\hat{u}_H = I_h^H u_h$ is its restriction to the coarse grid, $L_h$ and $L_H$ are the discrete operators on the fine and coarse grids, respectively, and $I_h^H$ is the restriction operator.\n\nThe problem asks for the coarse-grid equation to be written in the form $L_H(u_H) = f_H + \\tau_H$, where $f_H = I_h^H f_h$. By comparing this with the standard FAS formulation, we can identify the coarse-grid $\\tau$-correction term:\n$$\nf_H + \\tau_H = L_H(\\hat{u}_H) + I_h^H f_h - I_h^H L_h(u_h)\n$$\nSince $f_H = I_h^H f_h$, we can cancel this term from both sides, yielding the expression for the $\\tau$-correction:\n$$\n\\tau_H = L_H(\\hat{u}_H) - I_h^H L_h(u_h)\n$$\nThis term, also known as the relative truncation error, measures the difference between the coarse-grid operator applied to the restricted solution and the restricted fine-grid operator applied to the fine-grid solution. We now compute this value for the unique interior coarse node $X_1 = 0.5$.\n\nThe calculation proceeds in three main steps:\n1.  Compute the fine-grid operator term, $L_h(u_h_)$, at the required interior fine nodes.\n2.  Compute the coarse-grid operator term, $L_H(\\hat{u}_H)$, at the interior coarse node.\n3.  Combine these results using the restriction and subtraction as defined above.\n\nThe given fine-grid approximation is the vector of values at nodes $x_i = i h$ for $i=0, \\dots, 4$ with $h=1/4$:\n$u_h = [u_0, u_1, u_2, u_3, u_4]^T = [0, 0.2, 0.3, 0.1, 0]^T$.\n\n**Step 1: Compute $L_h(u_h)$ and $I_h^H L_h(u_h)$**\n\nThe nonlinear coefficient is $\\kappa(u) = 1+u^2$. We evaluate this at the fine-grid nodes:\n$\\kappa(u_0) = 1+0^2 = 1.00$\n$\\kappa(u_1) = 1+0.2^2 = 1.04$\n$\\kappa(u_2) = 1+0.3^2 = 1.09$\n$\\kappa(u_3) = 1+0.1^2 = 1.01$\n$\\kappa(u_4) = 1+0^2 = 1.00$\n\nThe face coefficients $K_{i+1/2} = \\frac{1}{2}(\\kappa(u_{i+1}) + \\kappa(u_i))$ are:\n$K_{1/2} = \\frac{1}{2}(1.04+1.00) = 1.02$\n$K_{3/2} = \\frac{1}{2}(1.09+1.04) = 1.065$\n$K_{5/2} = \\frac{1}{2}(1.01+1.09) = 1.05$\n$K_{7/2} = \\frac{1}{2}(1.00+1.01) = 1.005$\n\nThe fine-grid operator $L_h$ at an interior node $x_i$ is, with $h=1/4$ ($h^2=1/16$):\n$[L_h(u_h)]_i = -16 \\left( K_{i+1/2}(u_{i+1}-u_i) - K_{i-1/2}(u_i-u_{i-1}) \\right)$.\nWe need this at the interior fine nodes $x_1=0.25$, $x_2=0.5$, and $x_3=0.75$:\n- At $x_1=0.25$ ($i=1$):\n$[L_h(u_h)]_1 = -16 \\left( K_{3/2}(u_2-u_1) - K_{1/2}(u_1-u_0) \\right) = -16 \\left( 1.065(0.3-0.2) - 1.02(0.2-0) \\right)$\n$= -16(0.1065 - 0.204) = -16(-0.0975) = 1.56$\n- At $x_2=0.5$ ($i=2$):\n$[L_h(u_h)]_2 = -16 \\left( K_{5/2}(u_3-u_2) - K_{3/2}(u_2-u_1) \\right) = -16 \\left( 1.05(0.1-0.3) - 1.065(0.3-0.2) \\right)$\n$= -16(-0.21 - 0.1065) = -16(-0.3165) = 5.064$\n- At $x_3=0.75$ ($i=3$):\n$[L_h(u_h)]_3 = -16 \\left( K_{7/2}(u_4-u_3) - K_{5/2}(u_3-u_2) \\right) = -16 \\left( 1.005(0-0.1) - 1.05(0.1-0.3) \\right)$\n$= -16(-0.1005 - (-0.21)) = -16(0.1095) = -1.752$\n\nLet $w_h = L_h(u_h)$. We restrict $w_h$ to the coarse grid at node $X_1=0.5$ using full weighting:\n$[I_h^H w_h]_1 = \\frac{1}{4}w_1 + \\frac{1}{2}w_2 + \\frac{1}{4}w_3 = \\frac{1}{4}(1.56) + \\frac{1}{2}(5.064) + \\frac{1}{4}(-1.752) = 0.39 + 2.532 - 0.438 = 2.484$.\nThus, $[I_h^H L_h(u_h)]_1 = 2.484$.\n\n**Step 2: Compute $L_H(\\hat{u}_H)$**\n\nThe restricted fine-grid solution $\\hat{u}_H$ is obtained by injection:\n$\\hat{u}_{H,0} = u_h(0) = 0$\n$\\hat{u}_{H,1} = u_h(0.5) = 0.3$\n$\\hat{u}_{H,2} = u_h(1) = 0$\nSo, $\\hat{u}_H = [0, 0.3, 0]^T$.\n\nWe evaluate $\\kappa$ at the coarse-grid nodes using these values:\n$\\kappa(\\hat{u}_{H,0}) = 1+0^2 = 1.00$\n$\\kappa(\\hat{u}_{H,1}) = 1+0.3^2 = 1.09$\n$\\kappa(\\hat{u}_{H,2}) = 1+0^2 = 1.00$\n\nThe coarse-grid face coefficients are:\n$K_ {1/2} = \\frac{1}{2}(\\kappa(\\hat{u}_{H,1}) + \\kappa(\\hat{u}_{H,0})) = \\frac{1}{2}(1.09+1.00) = 1.045$\n$K_ {3/2} = \\frac{1}{2}(\\kappa(\\hat{u}_{H,2}) + \\kappa(\\hat{u}_{H,1})) = \\frac{1}{2}(1.00+1.09) = 1.045$\n\nThe coarse-grid operator $L_H$ at the interior node $X_1=0.5$ is, with $H=1/2$ ($H^2=1/4$):\n$[L_H(\\hat{u}_H)]_1 = -4 \\left( K_{3/2}(\\hat{u}_{H,2}-\\hat{u}_{H,1}) - K_{1/2}(\\hat{u}_{H,1}-\\hat{u}_{H,0}) \\right)$\n$= -4 \\left( 1.045(0-0.3) - 1.045(0.3-0) \\right)$\n$= -4(-0.3135 - 0.3135) = -4(-0.627) = 2.508$.\n\n**Step 3: Compute $\\tau_H$**\n\nNow we compute the $\\tau$-correction at $X_1$:\n$[\\tau_H]_1 = [L_H(\\hat{u}_H)]_1 - [I_h^H L_h(u_h)]_1 = 2.508 - 2.484 = 0.024$.\nRounded to six significant figures, the value is $0.0240000$.\n\n**Coarse-Grid Equations**\n\nTo write the full equations, we need the coarse-grid operator $L_H(u_H)$ for an unknown solution $u_H = [0, U_1, 0]^T$ and the restricted right-hand side $f_H$.\nThe operator $L_H(u_H)$ at $X_1$ is:\n$K_{1/2} = \\frac{1}{2}(\\kappa(U_1)+\\kappa(0)) = \\frac{1}{2}(1+U_1^2+1) = 1 + \\frac{1}{2}U_1^2$.\n$K_{3/2} = \\frac{1}{2}(\\kappa(0)+\\kappa(U_1)) = 1 + \\frac{1}{2}U_1^2$.\n$[L_H(u_H)]_1 = -4 \\left( K_{3/2}(0-U_1) - K_{1/2}(U_1-0) \\right) = -4 \\left( -(1+\\frac{1}{2}U_1^2)U_1 - (1+\\frac{1}{2}U_1^2)U_1 \\right) = 8U_1 + 4U_1^3$.\n\nThe coarse-grid right-hand side is $f_H = I_h^H f_h$. With $f_{h,i}=1$ for $i=1,2,3$:\n$[f_H]_1 = \\frac{1}{4}f_{h,1} + \\frac{1}{2}f_{h,2} + \\frac{1}{4}f_{h,3} = \\frac{1}{4}(1) + \\frac{1}{2}(1) + \\frac{1}{4}(1) = 1$.\n\nThe coarse-grid equation at $X_1$ **without** the $\\tau$-correction is a naive coarse-grid approximation:\n$L_H(u_H)_1 = f_{H,1} \\implies 8U_1 + 4U_1^3 = 1$.\n\nThe coarse-grid equation **with** the $\\tau$-correction is the FAS equation:\n$L_H(u_H)_1 = f_{H,1} + \\tau_{H,1} \\implies 8U_1 + 4U_1^3 = 1 + 0.024 = 1.024$.\n\n**Explanation for Improved Convergence**\n\nThe purpose of the coarse-grid problem in a two-grid cycle is to compute a correction that efficiently reduces the low-frequency error components of the fine-grid solution. For a nonlinear problem $L_h(u_h) = f_h$, the exact error $v_h = u_h^{exact} - u_h^{approx}$ satisfies $L_h(u_h^{approx} + v_h) - L_h(u_h^{approx}) = f_h - L_h(u_h^{approx}) = r_h$, where $r_h$ is the fine-grid residual.\n\nThe FAS method correctly approximates this relationship on the coarse grid. The FAS equation is $L_H(u_H) - L_H(\\hat{u}_H) = I_h^H r_h$. This formulation ensures a crucial consistency property. If the fine-grid solution were to converge, i.e., $r_h \\to 0$, then the FAS equation becomes $L_H(u_H) - L_H(\\hat{u}_H) = 0$. This equation has the obvious solution $u_H = \\hat{u}_H$. This means the coarse-grid correction $v_H = u_H - \\hat{u}_H$ would be zero. Thus, a converged fine-grid solution is a fixed point of the coarse-grid correction step.\n\nThe $\\tau_H$ term is the mechanism that enforces this consistency. By defining the coarse-grid right-hand side as $f_H^{FAS} = f_H + \\tau_H = I_h^H f_h + (L_H(\\hat{u}_H) - I_h^H L_h(u_h))$, we force the coarse grid problem to solve $L_H(u_H) \\approx I_h^H L_h(u_h)$. It corrects for the fact that the coarse grid operator $L_H$ is not the same as the restricted fine-grid operator $I_h^H L_h$.\n\nIn contrast, the naive coarse-grid approximation $L_H(u_H) = f_H = I_h^H f_h$ lacks this consistency. If the fine-grid solution were converged ($L_h(u_h) = f_h$), the naive coarse-grid equation would be $L_H(u_H) = I_h^H L_h(u_h)$. The solution $u_H$ to this equation is generally not equal to $\\hat{u}_H = I_h^H u_h$, because in general $L_H(I_h^H u_h) \\ne I_h^H L_h(u_h)$. The difference is precisely the $\\tau$-term. In our case, $[\\tau_H]_1=0.024 \\ne 0$. This implies that even for a converged fine-grid solution, the naive coarse grid would calculate a spurious, non-zero correction, which would then be prolongated back to the fine grid, destroying the solution and preventing convergence. The inclusion of $\\tau_H$ removes this inconsistency, ensuring that the coarse grid correctly models the fine grid's error dynamics, which is the foundation of multigrid efficiency.", "answer": "$$\n\\boxed{0.0240000}\n$$", "id": "3322340"}, {"introduction": "The true power of Full Multigrid is demonstrated in its application to complex, coupled multiphysics problems, which are at the forefront of modern CFD research. This capstone practice challenges you to design an FMG solver for a Cahn-Hilliard–Navier–Stokes system, a model for two-phase flows. This task requires tackling the challenges of an indefinite saddle-point structure by implementing a suitable block smoother, providing hands-on experience in building a robust and efficient solver for a research-level problem [@problem_id:3322398].", "problem": "Consider the coupling of the Cahn–Hilliard equation to the incompressible Navier–Stokes equations on the unit square with homogeneous Dirichlet boundary conditions for all fields. The continuous model consists of the momentum balance, incompressibility constraint, mass transport, and chemical potential definition. Let $u(x,y)$ and $v(x,y)$ denote the velocity components, $p(x,y)$ the pressure, $\\mu(x,y)$ the chemical potential, and $\\phi(x,y)$ the phase field. The linearized steady model to be solved at each time step is abstracted to the following system on a bounded domain with no-slip ($u=0, v=0$) and homogeneous boundary conditions for $\\mu$ and $\\phi$:\n- Momentum balance: $-\\nu \\Delta u + \\partial_x p + \\gamma \\partial_x \\mu = 0$ and $-\\nu \\Delta v + \\partial_y p + \\gamma \\partial_y \\mu = 0$,\n- Incompressibility: $\\partial_x u + \\partial_y v = 0$,\n- Cahn–Hilliard diffusion: $M \\Delta \\mu = g(x,y)$,\n- Chemical potential definition (linearized): $\\mu - \\left(-\\epsilon^2 \\Delta + I\\right)\\phi = 0$,\nwhere $\\nu > 0$ is viscosity, $M > 0$ is mobility, $\\epsilon > 0$ is interfacial width, $\\gamma \\ge 0$ is a coupling strength, and $I$ denotes the identity operator. The source $g(x,y)$ is a smooth, localized forcing of the Cahn–Hilliard diffusion, specified below.\n\nDiscretize the system on a sequence of nested cell-centered uniform grids with $n \\times n$ interior points, using second-order finite differences for the Laplacian and first-order centered differences for gradient and divergence operators that respect the discrete adjoint relation $D = -G^\\top$. Let $h = 1/(n+1)$ and let the discrete positive-definite Laplacian $L$ represent $- \\Delta$ under homogeneous Dirichlet boundary conditions. Assemble the following block linear system for the unknown vector $x = [u; v; p; \\mu; \\phi] \\in \\mathbb{R}^{5N}$, with $N = n^2$:\n$$\n\\begin{bmatrix}\n\\alpha I + \\nu L & 0 & G_x & \\gamma G_x & 0 \\\\\n0 & \\alpha I + \\nu L & G_y & \\gamma G_y & 0 \\\\\n-D_x & -D_y & \\beta I & 0 & 0 \\\\\n0 & 0 & 0 & M L & 0 \\\\\n0 & 0 & 0 & I & -\\left(\\epsilon^2 L + I\\right)\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\ v \\\\ p \\\\ \\mu \\\\ \\phi\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ g \\\\ 0\n\\end{bmatrix},\n$$\nwhere $I$ is the identity on $\\mathbb{R}^N$, $G_x$ and $G_y$ are the discrete gradient operators mapping pressure or chemical potential to velocity components, $D_x = -G_x^\\top$ and $D_y = -G_y^\\top$ are the discrete divergence operators mapping velocity components to pressure, $\\alpha > 0$ is a positive reaction coefficient included to ensure the velocity block is strictly positive definite, and $\\beta > 0$ is a small pressure stabilization to avoid a singular saddle-point system under homogeneous boundary conditions. The source $g(x,y)$ is given by\n$$\ng(x,y) = \\exp\\left(-100 \\left[(x - 0.5)^2 + (y - 0.5)^2\\right]\\right).\n$$\nDiscretize $g(x,y)$ at cell centers.\n\nDesign and implement a Full Multigrid (FMG) solution strategy for this coupled saddle-point system using block smoothers suitable for indefinite systems. Use a block-Jacobi smoother that updates the blocks $[u,v,p,\\mu,\\phi]$ with diagonal inverses of each block and sequential updates, respecting the block structure. The FMG procedure must:\n- Build a hierarchy of three levels with $n = 8, 16, 32$ interior points on each side (so $N = 64, 256, 1024$).\n- On the coarsest level, compute the exact solution via a sparse direct solve.\n- Prolongate the solution to the next level and perform one multigrid V-cycle per level to refine the approximation.\n- On the finest level, continue performing V-cycles until the Euclidean norm of the residual is reduced by a prescribed factor relative to the norm after FMG prolongation to the finest grid.\n\nThe multigrid components must be:\n- Restriction: $2 \\times 2$ full-weighting (simple averaging) applied fieldwise.\n- Prolongation: bilinear interpolation applied fieldwise.\n- Smoother: block-Jacobi with diagonal scaling of each block and relaxation parameters chosen to ensure damping for symmetric positive-definite blocks; for the pressure block, use the stabilization diagonal $\\beta I$.\n\nUse the following fixed parameters for all tests: $\\nu = 1$ (dimensionless viscosity), $\\alpha = 1$ (dimensionless reaction), $\\gamma = 0.1$ (dimensionless coupling), $\\beta = 10^{-3}$ (dimensionless pressure stabilization). The parameters that vary are the mobility $M$ and the interfacial width $\\epsilon$, both treated as dimensionless in this exercise.\n\nConvergence tracking requirement:\n- Let $\\|r\\|_2$ denote the Euclidean norm of the residual vector on the finest level.\n- After completing the FMG transfer to the finest grid (that is, after the initial single V-cycle at this level), record $\\|r_0\\|_2$.\n- Continue applying V-cycles on the finest level until the residual norm $\\|r_k\\|_2$ satisfies $\\|r_k\\|_2 \\le 10^{-6} \\|r_0\\|_2$ or until $k$ reaches a maximum of $20$ V-cycles.\n- For each parameter pair $(M,\\epsilon)$ in the test suite, report the integer number $k$ of V-cycles used on the finest level (capped at $20$ if the criterion is not met).\n\nTest suite:\n- Case 1 (happy path): $M = 10^{-2}$, $\\epsilon = 2 \\times 10^{-2}$.\n- Case 2 (low mobility edge): $M = 10^{-4}$, $\\epsilon = 2 \\times 10^{-2}$.\n- Case 3 (narrow interface edge): $M = 10^{-2}$, $\\epsilon = 5 \\times 10^{-3}$.\n- Case 4 (wide interface variation): $M = 10^{-3}$, $\\epsilon = 10^{-1}$.\n\nYour program should produce a single line of output containing the integer results as a comma-separated list enclosed in square brackets, in the order of the test suite cases (for example, $[k_1,k_2,k_3,k_4]$). All quantities are dimensionless in this problem; no physical units are required. Angles do not appear; no angle units are required. Percentages must be expressed in decimal form as ratios; in this problem, residual reduction is expressed directly as a ratio $10^{-6}$.", "solution": "The user has provided a valid, well-posed problem statement from the field of computational fluid dynamics and numerical analysis. The task is to design and implement a Full Multigrid (FMG) solver for a linearized, coupled Cahn-Hilliard-Navier-Stokes system on a 2D domain. All necessary equations, parameters, boundary conditions, and algorithmic components are specified. The problem is scientifically grounded and computationally feasible. I will now proceed with a detailed description of the solution methodology, followed by the complete implementation.\n\n### Methodological Overview\n\nThe core of the problem is to solve a large, sparse, block-structured linear system of the form $Ax=b$ on a sequence of nested grids. The system arises from a finite difference discretization of a coupled set of partial differential equations (PDEs). The matrix $A$ is non-symmetric and indefinite, characteristic of saddle-point problems like the incompressible Navier-Stokes equations. The solution will be obtained using a Full Multigrid (FMG) strategy, which is renowned for its optimal complexity, achieving a solution in a time proportional to the number of unknowns on the finest grid.\n\n### 1. Discretization and System Assembly\n\nThe continuous PDE system is discretized on a hierarchy of three cell-centered grids with $n \\times n$ interior cells, where $n \\in \\{32, 16, 8\\}$. This sequence implies a standard cell-centered coarsening strategy where the number of cells is halved in each dimension, i.e., $n_{\\text{coarse}} = n_{\\text{fine}}/2$. The mesh size is taken as $h = 1/n$. Although the problem statement mentions $h=1/(n+1)$, this corresponds to a node-centered grid and is inconsistent with the $n=32, 16, 8$ sequence under standard geometric coarsening ($h_{\\text{coarse}} = 2h_{\\text{fine}}$). We adopt $h=1/n$ as the consistent choice for a cell-centered framework.\n\nThe state vector $x$ is composed of five fields: two velocity components ($u,v$), pressure ($p$), chemical potential ($\\mu$), and phase field ($\\phi$). Each field is discretized on the $n \\times n$ grid, leading to a total of $N=n^2$ unknowns per field and $5N$ unknowns in total. The vector is ordered as $x = [u; v; p; \\mu; \\phi]$.\n\nThe discrete operators are constructed using sparse matrices, leveraging Kronecker products for efficiency and clarity:\n- **Discrete Laplacian ($L$):** A standard 5-point stencil for the negative Laplacian $(-\\Delta)$ with homogeneous Dirichlet boundary conditions is used. For a 1D grid with $n$ points, the operator $L_{1D}$ is a tridiagonal matrix. The 2D operator is then $L = L_{1D} \\otimes I_n + I_n \\otimes L_{1D}$, where $I_n$ is the $n \\times n$ identity matrix and $\\otimes$ is the Kronecker product.\n- **Discrete Gradient ($G_x, G_y$):** First-order centered differences are used. On a 1D grid, this is a bidiagonal matrix $G_{1D}$. The 2D operators are constructed as $G_x = G_{1D} \\otimes I_n$ and $G_y = I_n \\otimes G_{1D}$.\n- **Discrete Divergence ($D_x, D_y$):** The problem specifies the discrete adjoint relationship $D = -G^\\top$, so we define $D_x = -G_x^\\top$ and $D_y = -G_y^\\top$.\n\nWith these operators, the $5 \\times 5$ block matrix $A$ and the right-hand side vector $b$ are assembled for each grid level as specified in the problem. The source term $g(x,y)$ is evaluated at the cell centers $(x_i, y_j) = ((i-0.5)h, (j-0.5)h)$ for $i,j=1,\\ldots,n$.\n\n### 2. Multigrid Components\n\nThe multigrid algorithm requires three fundamental components: a smoother, a restriction operator, and a prolongation operator.\n\n- **Smoother:** A block-Jacobi smoother is specified. The update rule for the solution vector $x$ is $x_{k+1} = x_k + \\omega D_A^{-1}(b - Ax_k)$, where $D_A$ is the block-diagonal part of $A$. The problem further clarifies this as \"diagonal scaling of each block,\" which is interpreted as approximating the inverse of each diagonal block, e.g., $(A_{uu})^{-1}$, by the inverse of its main diagonal, $\\text{diag}(A_{uu})^{-1}$. This results in a computationally inexpensive point-wise damped Jacobi-type iteration over the entire system. The diagonal entries are:\n  - $\\text{diag}(A_{uu}) = \\text{diag}(A_{vv}) = (\\alpha + \\nu \\frac{4}{h^2})I$\n  - $\\text{diag}(A_{pp}) = \\beta I$\n  - $\\text{diag}(A_{\\mu\\mu}) = (M \\frac{4}{h^2})I$\n  - $\\text{diag}(A_{\\phi\\phi}) = -(\\epsilon^2 \\frac{4}{h^2} + 1)I$\n  A relaxation parameter $\\omega=0.7$ is used to provide damping, which is crucial for smoothing high-frequency error components.\n\n- **Restriction ($R$):** This operator transfers a fine-grid vector (e.g., the residual) to the next coarser grid. As specified, we use \"2x2 full-weighting (simple averaging),\" which maps a $2 \\times 2$ block of fine cells to a single coarse cell by averaging their values. For each of the five fields, the restriction is applied independently.\n\n- **Prolongation ($P$):** This operator interpolates a coarse-grid vector (e.g., the error correction) to the next finer grid. The problem specifies \"bilinear interpolation.\" For cell-centered grids, this corresponds to a 9-point stencil which is the transpose of the standard 9-point full-weighting restriction operator. Although this operator is not the algebraic transpose of the specified restriction operator (a common situation in practical multigrid codes), we adhere to the problem's explicit instructions.\n\n### 3. V-Cycle and Full Multigrid (FMG)\n\nThe components are orchestrated within a V-cycle algorithm and the overarching FMG strategy.\n\n- **V-Cycle:** A recursive function that moves from a fine grid down to the coarsest and back up. At each level (except the coarsest), it performs:\n  1.  **Pre-smoothing:** A fixed number of smoother sweeps ($\\nu_1=2$) to reduce high-frequency errors.\n  2.  **Coarse-Grid Correction:** Computes the residual, restricts it to the coarse grid, recursively calls the V-cycle to solve for the error on the coarse grid, prolongates the error correction back to the fine grid, and adds it to the solution.\n  3.  **Post-smoothing:** Another fixed number of smoother sweeps ($\\nu_2=2$) to smooth out errors introduced by prolongation.\n  On the coarsest grid ($n=8$), the system is solved exactly using a sparse direct solver (`scipy.sparse.linalg.spsolve`).\n\n- **Full Multigrid (FMG) Cycle:** The FMG strategy provides an excellent initial guess on the finest grid.\n  1.  Solve the problem exactly on the coarsest grid ($n=8$).\n  2.  Prolongate the solution to the next finer grid ($n=16$).\n  3.  Perform a single V-cycle on this grid to improve the interpolated solution.\n  4.  Repeat the process: prolongate the solution from $n=16$ to $n=32$ and perform one V-cycle.\nThe result is an initial approximate solution on the finest grid.\n\n### 4. Convergence and Final Answer\n\nAfter obtaining the initial solution $x_0$ from the FMG cycle on the finest grid ($n=32$), we calculate the norm of the initial residual, $\\|r_0\\|_2 = \\|b-Ax_0\\|_2$. Then, we iteratively apply V-cycles to the solution on the finest grid. Let $x_k$ be the solution after the $k$-th V-cycle. The iteration continues until the residual norm $\\|r_k\\|_2$ is reduced by a factor of $10^6$ relative to the initial FMG residual norm, i.e., $\\|r_k\\|_2 \\le 10^{-6}\\|r_0\\|_2$. The number of V-cycles, $k$, required to meet this criterion is recorded. If convergence is not achieved after a maximum of $20$ cycles, $k=20$ is reported. This procedure is repeated for each of the four test cases defined by the parameter pairs $(M, \\epsilon)$, and the resulting integers are reported in a list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef get_system(n, params):\n    \"\"\"\n    Assembles the discrete system matrix A and right-hand side b for a given grid size n.\n    \"\"\"\n    nu, alpha, gamma, beta, M, epsilon = params\n    # Use h=1/n for cell-centered grids, consistent with n=8,16,32 sequence.\n    h = 1.0 / n\n    N = n * n\n\n    e = np.ones(n)\n    # 1D Laplacian L1D for -d^2/dx^2 with homogeneous Dirichlet BCs\n    L1D = sparse.spdiags([-e, 2 * e, -e], [-1, 0, 1], n, n, format='csr') / (h * h)\n    # 1D Gradient G1D for d/dx with centered differences\n    G1D = sparse.spdiags([-e, e], [-1, 1], n, n, format='csr') / (2 * h)\n\n    I_n = sparse.identity(n, format='csr')\n    # 2D operators using Kronecker products\n    L = sparse.kron(L1D, I_n) + sparse.kron(I_n, L1D)\n    G_x = sparse.kron(G1D, I_n)\n    G_y = sparse.kron(I_n, G1D)\n    D_x = -G_x.T\n    D_y = -G_y.T\n\n    I_N = sparse.identity(N, format='csr')\n    \n    # Diagonal blocks of the system matrix\n    A_uu = alpha * I_N + nu * L\n    A_vv = alpha * I_N + nu * L\n    A_pp = beta * I_N\n    A_mumu = M * L if M > 0 else sparse.csr_matrix((N, N))\n    A_phiphi = -(epsilon**2 * L + I_N)\n\n    # Assemble the full 5N x 5N system matrix A\n    row1 = [A_uu, sparse.csr_matrix((N, N)), G_x, gamma * G_x, sparse.csr_matrix((N, N))]\n    row2 = [sparse.csr_matrix((N, N)), A_vv, G_y, gamma * G_y, sparse.csr_matrix((N, N))]\n    row3 = [-D_x, -D_y, A_pp, sparse.csr_matrix((N, N)), sparse.csr_matrix((N, N))]\n    row4 = [sparse.csr_matrix((N, N)), sparse.csr_matrix((N, N)), sparse.csr_matrix((N, N)), A_mumu, sparse.csr_matrix((N, N))]\n    row5 = [sparse.csr_matrix((N, N)), sparse.csr_matrix((N, N)), sparse.csr_matrix((N, N)), I_N, A_phiphi]\n    \n    A = sparse.bmat([row1, row2, row3, row4, row5], format='csr')\n\n    # Assemble the RHS vector b\n    b = np.zeros(5 * N)\n    x_coords = np.linspace(h / 2, 1 - h / 2, n)\n    y_coords = np.linspace(h / 2, 1 - h / 2, n)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    g_grid = np.exp(-100 * ((xx - 0.5)**2 + (yy - 0.5)**2))\n    b[3*N:4*N] = g_grid.flatten()\n\n    return A, b\n\ndef restrict(x_fine, n_fine):\n    \"\"\"Restriction: 2x2 simple averaging.\"\"\"\n    n_coarse = n_fine // 2\n    x_fine_5d = x_fine.reshape(5, n_fine, n_fine)\n    x_coarse_5d = 0.25 * (x_fine_5d[:, 0::2, 0::2] + x_fine_5d[:, 1::2, 0::2] +\n                          x_fine_5d[:, 0::2, 1::2] + x_fine_5d[:, 1::2, 1::2])\n    return x_coarse_5d.flatten()\n\ndef prolongate(x_coarse, n_coarse):\n    \"\"\"Prolongation: Bilinear interpolation for cell-centered grids.\"\"\"\n    n_fine = n_coarse * 2\n    x_coarse_5d = x_coarse.reshape((5, n_coarse, n_coarse))\n    x_fine_5d = np.zeros((5, n_fine, n_fine))\n\n    x_coarse_padded = np.pad(x_coarse_5d, ((0, 0), (1, 1), (1, 1)), 'constant')\n\n    for I in range(n_coarse):\n        for J in range(n_coarse):\n            i_p, j_p = I + 1, J + 1\n\n            v_im1_jm1 = x_coarse_padded[:, i_p - 1, j_p - 1]\n            v_i_jm1   = x_coarse_padded[:, i_p,     j_p - 1]\n            v_im1_j   = x_coarse_padded[:, i_p - 1, j_p]\n            v_i_j     = x_coarse_padded[:, i_p,     j_p]\n            v_ip1_j   = x_coarse_padded[:, i_p + 1, j_p]\n            v_i_jp1   = x_coarse_padded[:, i_p,     j_p + 1]\n            v_ip1_jp1 = x_coarse_padded[:, i_p + 1, j_p + 1]\n            v_im1_jp1 = x_coarse_padded[:, i_p - 1, j_p + 1]\n            v_ip1_jm1 = x_coarse_padded[:, i_p + 1, j_p - 1]\n\n            i_f, j_f = 2 * I, 2 * J\n            \n            x_fine_5d[:, i_f,     j_f]     = (9 * v_i_j + 3 * v_im1_j + 3 * v_i_jm1 + 1 * v_im1_jm1) / 16.0\n            x_fine_5d[:, i_f + 1, j_f]     = (9 * v_i_j + 3 * v_ip1_j + 3 * v_i_jm1 + 1 * v_ip1_jm1) / 16.0\n            x_fine_5d[:, i_f,     j_f + 1] = (9 * v_i_j + 3 * v_im1_j + 3 * v_i_jp1 + 1 * v_im1_jp1) / 16.0\n            x_fine_5d[:, i_f + 1, j_f + 1] = (9 * v_i_j + 3 * v_ip1_j + 3 * v_i_jp1 + 1 * v_ip1_jp1) / 16.0\n            \n    return x_fine_5d.flatten()\n\ndef smoother(A, x, b, n, params, num_sweeps, omega=0.7):\n    \"\"\"Smoother: Damped block-Jacobi with diagonal scaling.\"\"\"\n    nu, alpha, gamma, beta, M, epsilon = params\n    h = 1.0 / n\n    N = n * n\n    \n    diag_L_val = 4.0 / (h*h)\n    \n    inv_diag_uu = 1.0 / (alpha + nu * diag_L_val)\n    inv_diag_vv = 1.0 / (alpha + nu * diag_L_val)\n    inv_diag_pp = 1.0 / beta\n    inv_diag_mumu = 1.0 / (M * diag_L_val) if M > 1e-12 else 0.0\n    inv_diag_phiphi = 1.0 / -(epsilon**2 * diag_L_val + 1.0)\n    \n    inv_diag_A = np.concatenate([np.full(N, inv_diag_uu), np.full(N, inv_diag_vv),\n                                 np.full(N, inv_diag_pp), np.full(N, inv_diag_mumu),\n                                 np.full(N, inv_diag_phiphi)])\n\n    for _ in range(num_sweeps):\n        r = b - A.dot(x)\n        x += omega * inv_diag_A * r\n    return x\n\ndef v_cycle(level, x_guess, b, systems, ns, params, nu1, nu2):\n    \"\"\"Recursive V-cycle implementation.\"\"\"\n    A = systems[level]['A']\n    n = ns[level]\n\n    x = smoother(A, x_guess, b, n, params, nu1)\n    \n    if level  len(systems) - 1: # Not on coarsest level\n        r = b - A.dot(x)\n        r_coarse = restrict(r, n)\n        e_coarse = np.zeros_like(r_coarse)\n        e_coarse = v_cycle(level + 1, e_coarse, r_coarse, systems, ns, params, nu1, nu2)\n        e_fine = prolongate(e_coarse, ns[level+1])\n        x += e_fine\n        x = smoother(A, x, b, n, params, nu2)\n    else: # On coarsest level\n        x = spsolve(A, b)\n    \n    return x\n\ndef fmg_solve(systems, ns, params, nu1, nu2):\n    \"\"\"Full Multigrid (FMG) initial guess computation.\"\"\"\n    coarsest_level = len(systems) - 1\n    x = spsolve(systems[coarsest_level]['A'], systems[coarsest_level]['b'])\n    \n    for level in range(coarsest_level - 1, -1, -1):\n        x = prolongate(x, ns[level+1])\n        b_fine = systems[level]['b']\n        x = v_cycle(level, x, b_fine, systems, ns, params, nu1, nu2)\n    \n    return x\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (10**-2, 2 * 10**-2),  # Case 1\n        (10**-4, 2 * 10**-2),  # Case 2\n        (10**-2, 5 * 10**-3),  # Case 3\n        (10**-3, 10**-1),      # Case 4\n    ]\n\n    fixed_params = {'nu': 1.0, 'alpha': 1.0, 'gamma': 0.1, 'beta': 1e-3}\n    ns = [32, 16, 8]\n    nu1, nu2 = 2, 2  # Pre- and post-smoothing sweeps\n    \n    results = []\n\n    for M, epsilon in test_cases:\n        params = (fixed_params['nu'], fixed_params['alpha'], fixed_params['gamma'], \n                  fixed_params['beta'], M, epsilon)\n        \n        systems = [{'A': get_system(n, params)[0], 'b': get_system(n, params)[1]} for n in ns]\n        \n        x_k = fmg_solve(systems, ns, params, nu1, nu2)\n\n        A_fine, b_fine = systems[0]['A'], systems[0]['b']\n        \n        r0 = b_fine - A_fine.dot(x_k)\n        norm_r0 = np.linalg.norm(r0)\n        \n        if norm_r0 == 0:\n            results.append(0)\n            continue\n            \n        k = 0\n        max_cycles = 20\n        target_reduction = 1e-6\n        \n        for i in range(1, max_cycles + 1):\n            x_k = v_cycle(0, x_k, b_fine, systems, ns, params, nu1, nu2)\n            r_k = b_fine - A_fine.dot(x_k)\n            norm_rk = np.linalg.norm(r_k)\n            \n            if norm_rk = target_reduction * norm_r0:\n                k = i\n                break\n        else:\n            k = max_cycles\n        \n        results.append(k)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3322398"}]}