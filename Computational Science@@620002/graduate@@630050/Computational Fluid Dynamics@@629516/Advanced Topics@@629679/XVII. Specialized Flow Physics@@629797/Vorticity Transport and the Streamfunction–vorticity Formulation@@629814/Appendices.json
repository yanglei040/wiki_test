{"hands_on_practices": [{"introduction": "Transitioning from theory to practice, our first exercise involves building a complete solver for the steady, two-dimensional Navier-Stokes equations. This practice utilizes a fixed-point iterative scheme to handle the nonlinear coupling between the streamfunction and vorticity fields. By employing the Method of Manufactured Solutions, you will verify the correctness of your implementation against a known analytical solution, a fundamental skill in computational code development [@problem_id:3389266].", "problem": "Consider the two-dimensional, incompressible Navier–Stokes equations on a square domain of side length $L=1$ with periodic boundary conditions in both spatial directions. Let $\\boldsymbol{u} = (u, v)$ denote the velocity field, $p$ denote the pressure, and $\\nu$ denote the kinematic viscosity. The governing equations in dimensionless form are\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}, \\quad \\nabla \\cdot \\boldsymbol{u} = 0.\n$$\nDefine the scalar vorticity $\\omega$ by $\\omega = \\partial v/\\partial x - \\partial u/\\partial y$ and introduce the streamfunction $\\psi$ such that $\\boldsymbol{u} = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right)$. For two-dimensional incompressible flow, the streamfunction and vorticity are related by the Poisson equation\n$$\n\\nabla^2 \\psi = -\\omega.\n$$\nStarting from the incompressible Navier–Stokes equations, the vorticity transport equation in two dimensions is\n$$\n\\frac{\\partial \\omega}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\omega = \\nu \\nabla^2 \\omega + S,\n$$\nwhere $S$ is a scalar source term equal to the curl of the body force $\\boldsymbol{f}$:\n$$\nS = \\left(\\nabla \\times \\boldsymbol{f}\\right)_z.\n$$\nIn the streamfunction–vorticity formulation, the coupling is nonlinear because $\\boldsymbol{u}$ depends on $\\psi$, which depends on $\\omega$, and the advection $\\boldsymbol{u} \\cdot \\nabla \\omega$ depends on both $\\boldsymbol{u}$ and $\\omega$.\n\nYour task is to implement a fixed-point splitting iteration (Picard iteration) that approximates a steady solution of the vorticity transport equation by alternating between solving the Poisson equation for the streamfunction and updating the vorticity with an explicit pseudo-time step. The iteration at pseudo-time step $n$ proceeds as follows:\n1. Given the current vorticity field $\\omega^n$, solve the Poisson equation for the streamfunction $\\psi^n$:\n   $$\n   \\nabla^2 \\psi^n = -\\omega^n.\n   $$\n2. Compute the velocity field $\\boldsymbol{u}^n = \\left(\\frac{\\partial \\psi^n}{\\partial y}, -\\frac{\\partial \\psi^n}{\\partial x}\\right)$.\n3. Update the vorticity explicitly using\n   $$\n   \\omega^{n+1} = \\omega^n + \\Delta t \\left( -\\nabla \\cdot \\left( \\omega^n \\boldsymbol{u}^n \\right) + \\nu \\nabla^2 \\omega^n + S \\right),\n   $$\n   where the advection term is discretized in conservative form as the divergence of the vorticity flux, and $\\nu = 1/\\mathrm{Re}$ with $\\mathrm{Re}$ the Reynolds number. The iteration aims to converge to the steady state satisfying\n   $$\n   \\nabla \\cdot \\left( \\omega \\boldsymbol{u} \\right) = \\nu \\nabla^2 \\omega + S \\quad \\text{with} \\quad \\boldsymbol{u} = \\left(\\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x}\\right), \\quad \\nabla^2 \\psi = -\\omega.\n   $$\n\nTo make the problem well-posed and verifiable, use the method of manufactured solutions. Consider the exact streamfunction\n$$\n\\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y),\n$$\nwith the corresponding exact velocity\n$$\n\\boldsymbol{u}_{\\text{exact}}(x,y) = \\left( \\frac{\\partial \\psi_{\\text{exact}}}{\\partial y}, -\\frac{\\partial \\psi_{\\text{exact}}}{\\partial x} \\right),\n$$\nand exact vorticity\n$$\n\\omega_{\\text{exact}}(x,y) = -\\nabla^2 \\psi_{\\text{exact}}(x,y).\n$$\nDefine the source term $S$ to be consistent with the discrete conservative advection and spectral diffusion used in your algorithm:\n$$\nS := \\nabla \\cdot \\left( \\omega_{\\text{exact}} \\boldsymbol{u}_{\\text{exact}} \\right) - \\nu \\nabla^2 \\omega_{\\text{exact}}.\n$$\nWith this $S$, the manufactured fields satisfy the steady vorticity transport equation in the chosen discrete form, making them a fixed point of the iteration under perfect resolution and sufficient convergence.\n\nAlgorithmic and numerical requirements:\n- Spatial discretization: Use a uniform grid with $N \\times N$ points over $[0,1)\\times[0,1)$ with periodic boundary conditions. The grid spacing is $h = 1/N$.\n- Spectral operations: Implement the Poisson solve and the Laplacian using a Fourier spectral method suitable for periodic domains. Specifically, if $\\widehat{f}$ denotes the Fourier transform of $f$, and $k_x, k_y$ are the discrete wavenumbers, then $\\nabla^2 f$ is represented spectrally as $-\\left(k_x^2 + k_y^2\\right)\\widehat{f}$, and the Poisson equation $\\nabla^2 \\psi = -\\omega$ is solved in Fourier space by $\\widehat{\\psi} = \\widehat{\\omega}/\\left(k_x^2 + k_y^2\\right)$ for nonzero wavenumbers, and setting the zero mode of $\\widehat{\\psi}$ to zero.\n- Velocity evaluation: Compute $\\boldsymbol{u}$ from $\\psi$ via spectral differentiation, i.e., $\\widehat{u} = i k_y \\widehat{\\psi}$ and $\\widehat{v} = -i k_x \\widehat{\\psi}$, followed by an inverse Fourier transform.\n- Advection term: Discretize $-\\boldsymbol{u}\\cdot \\nabla \\omega$ in conservative form as $-\\nabla \\cdot \\left(\\omega \\boldsymbol{u}\\right)$ using second-order centered finite differences on the periodic grid:\n  $$\n  \\nabla \\cdot \\left(\\omega \\boldsymbol{u}\\right) \\approx \\frac{F_x(i,j+1) - F_x(i,j-1)}{2h} + \\frac{F_y(i+1,j) - F_y(i-1,j)}{2h}, \\quad F_x = u \\omega, \\quad F_y = v \\omega,\n  $$\n  where $i$ and $j$ index the grid in $y$ and $x$ directions, respectively, and indices wrap periodically.\n- Diffusion term: Compute $\\nabla^2 \\omega$ spectrally as described above.\n- Iteration: Start from $\\omega^0 \\equiv 0$. For each pseudo-time step, perform the fixed-point split: solve for $\\psi^n$ from $\\omega^n$, compute $\\boldsymbol{u}^n$, then update $\\omega^{n+1}$ with the explicit step. Use a constant pseudo-time step $\\Delta t$ for the iteration.\n\nTest suite:\nImplement your program to run the following three test cases, each defined by the tuple $(N, \\mathrm{Re}, \\Delta t, \\text{steps})$, with all quantities dimensionless:\n1. Case A (moderate advection–diffusion): $(48, 100, 2.0\\times 10^{-4}, 600)$.\n2. Case B (diffusion-dominated): $(48, 5, 2.0\\times 10^{-4}, 600)$.\n3. Case C (advection-dominated): $(64, 1000, 1.0\\times 10^{-4}, 800)$.\n\nFor each case, compute the root-mean-square error at the final iteration between the numerical vorticity and the manufactured exact vorticity,\n$$\nE = \\sqrt{\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left(\\omega^{\\text{final}}_{i,j} - \\omega_{\\text{exact}, i,j}\\right)^2 }.\n$$\n\nFinal output specification:\n- The program must produce a single line of output containing the three errors for Case A, Case B, and Case C, respectively, as a comma-separated list enclosed in square brackets. Each error must be rounded to six decimal places. For example: \"[0.012345,0.001234,0.123456]\".\n- All quantities are dimensionless; no physical units are involved.\n\nYour implementation must be a complete, runnable program that adheres to the execution environment constraints specified in the final answer block.", "solution": "The problem statement has been meticulously validated and is deemed to be scientifically grounded, well-posed, and internally consistent. It presents a standard verification exercise in computational fluid dynamics, utilizing the method of manufactured solutions to test a numerical implementation of the streamfunction-vorticity formulation for the two-dimensional, incompressible Navier–Stokes equations. The specified numerical methods, including a mix of spectral and finite-difference techniques on a periodic domain, are appropriate and clearly defined. The parameters for the test cases are reasonable and should result in a stable numerical iteration. We may therefore proceed with a complete solution.\n\nThe objective is to find a steady-state solution to the vorticity transport equation,\n$$\n\\frac{\\partial \\omega}{\\partial t} + \\nabla \\cdot (\\omega \\boldsymbol{u}) = \\nu \\nabla^2 \\omega + S\n$$\nby means of a fixed-point iteration. At steady state ($\\partial \\omega / \\partial t = 0$), the equation becomes\n$$\n\\nabla \\cdot (\\omega \\boldsymbol{u}) = \\nu \\nabla^2 \\omega + S\n$$\nThis equation is coupled with the Poisson equation relating the streamfunction $\\psi$ to the vorticity $\\omega$, $\\nabla^2 \\psi = -\\omega$, and the kinematic definition of velocity from the streamfunction, $\\boldsymbol{u} = (\\partial \\psi/\\partial y, -\\partial \\psi/\\partial x)$. The proposed iterative scheme treats this system by lagging the nonlinear advection term. Given the vorticity at pseudo-timestep $n$, $\\omega^n$, the update to $\\omega^{n+1}$ is computed via an explicit forward Euler step:\n$$\n\\frac{\\omega^{n+1} - \\omega^n}{\\Delta t} = -\\nabla \\cdot \\left( \\omega^n \\boldsymbol{u}^n \\right) + \\nu \\nabla^2 \\omega^n + S\n$$\nwhere $\\boldsymbol{u}^n$ is derived from $\\omega^n$.\n\nThe spatial domain is a doubly periodic square $[0,1) \\times [0,1)$, discretized with a uniform grid of $N \\times N$ points. The grid spacing is $h=1/N$. This periodicity makes Fourier spectral methods highly effective for computing spatial derivatives and solving the Poisson equation.\n\nWe first establish the computational framework. The discrete wavenumbers for a grid of size $N$ with spacing $h$ are given by $k = 2\\pi f$, where $f$ are the discrete frequencies obtained from `numpy.fft.fftfreq(N, d=h)`. We construct two-dimensional wavenumber arrays $k_x$ and $k_y$. The spectral representation of the Laplacian operator, $\\nabla^2$, acting on a field $g$ is multiplication of its Fourier transform $\\widehat{g}$ by $-(k_x^2 + k_y^2)$. Let $K^2 = k_x^2 + k_y^2$. Then, $\\widehat{\\nabla^2 g} = -K^2 \\widehat{g}$. The Poisson equation $\\nabla^2 \\psi = -\\omega$ is solved in Fourier space as:\n$$\n\\widehat{\\psi} = - \\frac{\\widehat{\\omega}}{-K^2} = \\frac{\\widehat{\\omega}}{K^2}\n$$\nThe division by $K^2$ is undefined for the zero-wavenumber mode ($k_x=k_y=0$). For a periodic domain, the mean value of the streamfunction is arbitrary. We fix this by setting the mean value to zero, which corresponds to setting $\\widehat{\\psi}(0,0) = 0$.\n\nThe velocity components $(u, v)$ are computed from the streamfunction $\\psi$ via spectral differentiation:\n$$\n\\widehat{u} = \\widehat{\\frac{\\partial \\psi}{\\partial y}} = i k_y \\widehat{\\psi}, \\qquad \\widehat{v} = \\widehat{-\\frac{\\partial \\psi}{\\partial x}} = -i k_x \\widehat{\\psi}\n$$\nThe physical velocity fields $u$ and $v$ are then recovered via inverse Fast Fourier Transform (FFT).\n\nThe Method of Manufactured Solutions is employed for verification. We define an exact analytical solution and derive a source term $S$ that forces this solution to satisfy the discretized steady-state equation. The chosen exact streamfunction is:\n$$\n\\psi_{\\text{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)\n$$\nFrom this, we derive the exact vorticity and velocity fields:\n$$\n\\omega_{\\text{exact}} = -\\nabla^2 \\psi_{\\text{exact}} = -(-\\left(2\\pi\\right)^2 - \\left(2\\pi\\right)^2)\\psi_{\\text{exact}} = 8\\pi^2 \\sin(2\\pi x)\\sin(2\\pi y)\n$$\n$$\nu_{\\text{exact}} = \\frac{\\partial \\psi_{\\text{exact}}}{\\partial y} = 2\\pi \\sin(2\\pi x)\\cos(2\\pi y)\n$$\n$$\nv_{\\text{exact}} = -\\frac{\\partial \\psi_{\\text{exact}}}{\\partial x} = -2\\pi \\cos(2\\pi x)\\sin(2\\pi y)\n$$\nThe source term $S$ is crucial. To ensure the manufactured solution is a true fixed point of our numerical scheme, $S$ must be computed using the *same discrete operators* as in the iterative solver. The steady equation is $S = \\nabla \\cdot (\\omega \\boldsymbol{u}) - \\nu \\nabla^2 \\omega$. We thus define our discrete source term $S_{i,j}$ as:\n$$\nS_{i,j} = \\mathcal{D}_{FD}(\\omega_{\\text{exact}}, \\boldsymbol{u}_{\\text{exact}})_{i,j} - \\nu \\mathcal{L}_{SP}(\\omega_{\\text{exact}})_{i,j}\n$$\nwhere $\\mathcal{D}_{FD}$ is the second-order centered finite difference operator for the divergence term $\\nabla\\cdot(\\omega\\boldsymbol{u})$, and $\\mathcal{L}_{SP}$ is the spectral operator for the Laplacian $\\nabla^2 \\omega$. The finite difference operator, on fluxes $F_x=\\omega u$ and $F_y=\\omega v$, is:\n$$\n\\mathcal{D}_{FD} \\approx \\frac{F_x(i,j+1) - F_x(i,j-1)}{2h} + \\frac{F_y(i+1,j) - F_y(i-1,j)}{2h}\n$$\nPeriodic indexing is handled using `numpy.roll`.\n\nThe iterative algorithm proceeds as follows for each test case $(N, \\mathrm{Re}, \\Delta t, \\text{steps})$:\n1.  **Setup**: Define grid parameters ($h$), spectral parameters ($k_x, k_y, K^2$), and physical constants ($\\nu=1/\\mathrm{Re}$).\n2.  **Manufactured Solution**: Compute $\\psi_{\\text{exact}}$, $\\omega_{\\text{exact}}$, and $\\boldsymbol{u}_{\\text{exact}}$ on the discrete grid.\n3.  **Source Term**: Compute the source term $S$ using the hybrid discretization as described above.\n4.  **Initialization**: Set the initial vorticity field $\\omega^0_{i,j} = 0$.\n5.  **Iteration**: For $n$ from $0$ to $\\text{steps}-1$:\n    a. Compute the Fourier transform of the current vorticity, $\\widehat{\\omega}^n = \\text{FFT}(\\omega^n)$.\n    b. Solve for the streamfunction in Fourier space: $\\widehat{\\psi}^n = \\widehat{\\omega}^n / K^2$ (with $\\widehat{\\psi}^n(0,0)=0$).\n    c. Compute velocity fields by spectral differentiation and inverse FFT: $\\boldsymbol{u}^n = \\text{IFFT}(i k_y \\widehat{\\psi}^n, -i k_x \\widehat{\\psi}^n)$.\n    d. Compute the right-hand side (RHS) of the vorticity update equation:\n       $$\n       \\text{RHS} = -\\mathcal{D}_{FD}(\\omega^n, \\boldsymbol{u}^n) + \\nu \\mathcal{L}_{SP}(\\omega^n) + S\n       $$\n    e. Update the vorticity field using a forward Euler step in pseudo-time: $\\omega^{n+1} = \\omega^n + \\Delta t \\cdot \\text{RHS}$.\n6.  **Error Calculation**: After the final step, the root-mean-square (RMS) error between the final numerical vorticity $\\omega^{\\text{final}}$ and the exact vorticity $\\omega_{\\text{exact}}$ is computed:\n    $$\n    E = \\sqrt{\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left(\\omega^{\\text{final}}_{i,j} - \\omega_{\\text{exact}, i,j}\\right)^2}\n    $$\nThis procedure is repeated for each of the three test cases specified in the problem statement. The final output will be the list of these three computed errors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, Re, dt, steps):\n    \"\"\"\n    Solves the 2D steady vorticity transport equation using a fixed-point\n    iteration on a periodic domain with a manufactured solution for verification.\n    \"\"\"\n    # 1. Grid and Parameters\n    L = 1.0\n    h = L / N\n    nu = 1.0 / Re\n\n    # Physical grid\n    x = np.linspace(0, L, N, endpoint=False)\n    y = np.linspace(0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y)\n\n    # Spectral grid (wavenumbers)\n    kx_vec = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(N, d=h)\n    KX, KY = np.meshgrid(kx_vec, ky_vec, indexing='xy')\n\n    # Squared wavenumbers and inverse Laplacian operator\n    K_sq = KX**2 + KY**2\n    inv_K_sq = np.zeros_like(K_sq)\n    # Avoid division by zero at the (0,0) mode\n    non_zero_k = K_sq != 0\n    inv_K_sq[non_zero_k] = 1.0 / K_sq[non_zero_k]\n\n    # 2. Manufactured Solution and Source Term\n    # Exact streamfunction\n    psi_exact = np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Exact vorticity: omega = -nabla^2(psi)\n    omega_exact = 8 * (np.pi**2) * np.sin(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Exact velocity: u = d(psi)/dy, v = -d(psi)/dx\n    u_exact = 2 * np.pi * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)\n    v_exact = -2 * np.pi * np.cos(2 * np.pi * X) * np.sin(2 * np.pi * Y)\n    \n    # Helper for the centered finite-difference divergence\n    def fd_divergence(Fx, Fy, grid_spacing):\n        # Note: numpy arrays are indexed (row, col) which corresponds to (y, x).\n        # axis=1 is x-direction, axis=0 is y-direction.\n        dFx_dx = (np.roll(Fx, -1, axis=1) - np.roll(Fx, 1, axis=1)) / (2 * grid_spacing)\n        dFy_dy = (np.roll(Fy, -1, axis=0) - np.roll(Fy, 1, axis=0)) / (2 * grid_spacing)\n        return dFx_dx + dFy_dy\n        \n    # Source term S such that the exact solution is a fixed point of the discrete operators\n    # S = div(omega_exact * u_exact) [FD] - nu * laplacian(omega_exact) [Spectral]\n    \n    # Advection term computed with finite differences\n    Fx_exact = u_exact * omega_exact\n    Fy_exact = v_exact * omega_exact\n    advection_exact_term = fd_divergence(Fx_exact, Fy_exact, h)\n\n    # Diffusion term computed spectrally\n    omega_exact_hat = np.fft.fft2(omega_exact)\n    laplacian_omega_exact = np.fft.ifft2(-K_sq * omega_exact_hat).real\n    diffusion_exact_term = nu * laplacian_omega_exact\n    \n    S = advection_exact_term - diffusion_exact_term\n    \n    # 3. Iteration Loop\n    # Initialize vorticity field\n    omega = np.zeros((N, N), dtype=float)\n\n    for _ in range(steps):\n        omega_n = omega\n        \n        # 1. Solve for streamfunction psi^n from omega^n\n        omega_n_hat = np.fft.fft2(omega_n)\n        psi_n_hat = -omega_n_hat * inv_K_sq\n        \n        # 2. Compute velocity u^n\n        u_n_hat = 1j * KY * psi_n_hat\n        v_n_hat = -1j * KX * psi_n_hat\n        u_n = np.fft.ifft2(u_n_hat).real\n        v_n = np.fft.ifft2(v_n_hat).real\n        \n        # 3. Compute RHS of vorticity update equation\n        # RHS = -div(omega*u) [FD] + nu*laplacian(omega) [Spectral] + S\n        \n        # Advection term: -div(omega*u) [FD]\n        Fx_n = u_n * omega_n\n        Fy_n = v_n * omega_n\n        advection_n_term = fd_divergence(Fx_n, Fy_n, h)\n        \n        # Diffusion term: nu*laplacian(omega) [Spectral]\n        laplacian_omega_n = np.fft.ifft2(-K_sq * omega_n_hat).real\n        diffusion_n_term = nu * laplacian_omega_n\n\n        # Assemble RHS\n        rhs = -advection_n_term + diffusion_n_term + S\n        \n        # 4. Update vorticity (Forward Euler in pseudo-time)\n        omega = omega_n + dt * rhs\n\n    # 4. Calculate Error\n    error = np.sqrt(np.mean((omega - omega_exact)**2))\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (N, Re, dt, steps)\n        (48, 100, 2.0e-4, 600),\n        # Case B: (N, Re, dt, steps)\n        (48, 5, 2.0e-4, 600),\n        # Case C: (N, Re, dt, steps)\n        (64, 1000, 1.0e-4, 800),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, Re, dt, steps = case\n        rms_error = run_simulation(N, Re, dt, steps)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```", "id": "3389266"}, {"introduction": "While the previous exercise used periodic boundaries for simplicity, most real-world flows involve solid walls, which present a key challenge for the streamfunction-vorticity formulation. Since vorticity is not a primary variable, its value at a no-slip boundary must be numerically derived, and errors in this step can lead to non-physical \"vorticity leakage.\" This practice explores how implementing a high-order compact finite difference scheme, designed to be compatible with the no-slip condition, can dramatically improve the accuracy of the near-wall vorticity computation compared to a standard second-order method [@problem_id:3389276].", "problem": "Consider the two-dimensional incompressible flow in the streamfunction–vorticity formulation of the Navier–Stokes equations, where the velocity field is represented by the streamfunction $\\psi(x,y)$ via $u = \\partial \\psi / \\partial y$ and $v = -\\partial \\psi / \\partial x$, and the scalar vorticity is $\\omega = \\partial v / \\partial x - \\partial u / \\partial y = - \\nabla^2 \\psi$. For a stationary impermeable no-slip wall aligned with the coordinate axes, the streamfunction boundary conditions are $\\psi = \\text{constant}$ on the wall (no penetration) and $\\partial \\psi / \\partial n = 0$ on the wall (no slip), where $\\partial \\psi / \\partial n$ is the derivative normal to the wall. In the streamfunction–vorticity formulation, numerical errors in discretizing $\\nabla^2 \\psi$ near walls directly contaminate the computed vorticity $\\omega$, a phenomenon commonly called vorticity leakage at high Reynolds number (Re) where near-wall gradients are sharp.\n\nYour task is to build and assess a high-order compact finite difference discretization for $\\nabla^2 \\psi$ on a uniform Cartesian grid that respects the no-slip boundary structure. Work in a nondimensional square domain $[0,1]\\times[0,1]$ with a uniform grid of $N\\times N$ points and grid spacing $h = 1/(N-1)$. Use the following manufactured smooth streamfunction that enforces both no-penetration and no-slip exactly:\n$$\n\\psi(x,y) = \\sin^2\\!\\big(k\\pi x\\big)\\,\\sin^2\\!\\big(k\\pi y\\big),\n$$\nwhere $k$ is a positive integer controlling the sharpness of near-wall gradients (larger $k$ mimics a higher Reynolds number regime by creating thinner effective layers). For this choice, the exact vorticity is\n$$\n\\omega_{\\text{true}}(x,y) \\equiv -\\nabla^2 \\psi(x,y) = -2\\,(k\\pi)^2\\left[\\cos\\!\\big(2k\\pi x\\big)\\,\\sin^2\\!\\big(k\\pi y\\big) + \\cos\\!\\big(2k\\pi y\\big)\\,\\sin^2\\!\\big(k\\pi x\\big)\\right].\n$$\n\nImplement and compare the following two discrete approximations of $\\omega = -\\nabla^2 \\psi$ on the interior grid points:\n\n- Baseline second-order scheme (denote by S2): use the standard five-point stencil for the Laplacian at interior points $(i,j)$,\n$$\n(\\nabla^2 \\psi)^{\\text{S2}}_{i,j} = \\frac{\\psi_{i+1,j} - 2\\psi_{i,j} + \\psi_{i-1,j}}{h^2} + \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{h^2},\n$$\nwith boundary values $\\psi=0$ used where needed to close the stencil. Then $\\omega^{\\text{S2}}_{i,j} = -(\\nabla^2 \\psi)^{\\text{S2}}_{i,j}$.\n\n- High-order compact scheme (denote by HC4): compute the second derivatives in each Cartesian direction by a fourth-order accurate compact explicit centered formula with a five-point stencil in one dimension,\n$$\n\\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j}^{\\text{HC4}} = \\frac{-\\psi_{i+2,j} + 16\\psi_{i+1,j} - 30\\psi_{i,j} + 16\\psi_{i-1,j} - \\psi_{i-2,j}}{12\\,h^2},\n$$\n$$\n\\left(\\frac{\\partial^2 \\psi}{\\partial y^2}\\right)_{i,j}^{\\text{HC4}} = \\frac{-\\psi_{i,j+2} + 16\\psi_{i,j+1} - 30\\psi_{i,j} + 16\\psi_{i,j-1} - \\psi_{i,j-2}}{12\\,h^2}.\n$$\nNear walls where indices $i\\pm 2$ or $j\\pm 2$ lie outside the domain, enforce the no-slip-compatible compact closure by even reflection across the wall, i.e., for any out-of-range index $p<0$ replace $\\psi_{p,\\cdot}$ by $\\psi_{-p,\\cdot}$ and for any out-of-range index $p>N-1$ replace $\\psi_{p,\\cdot}$ by $\\psi_{2(N-1)-p,\\cdot}$ in the corresponding direction. This realizes a local even extension about the wall, consistent with $\\partial \\psi / \\partial n = 0$ there. Then set\n$$\n\\omega^{\\text{HC4}}_{i,j} = -\\left[\\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j}^{\\text{HC4}} + \\left(\\frac{\\partial^2 \\psi}{\\partial y^2}\\right)_{i,j}^{\\text{HC4}}\\right].\n$$\n\nDefine the near-wall band $\\mathcal{B}$ as the set of interior indices within one interior cell of any wall:\n$$\n\\mathcal{B} = \\left\\{(i,j)\\,:\\,1\\le i \\le N-2,\\,1\\le j \\le N-2,\\,\\min\\big(i,\\,j,\\,N-1-i,\\,N-1-j\\big)=1\\right\\}.\n$$\nFor each scheme X in $\\{\\text{S2},\\text{HC4}\\}$, define a leakage metric in the band $\\mathcal{B}$ as the relative root-mean-square error of the computed vorticity against the exact vorticity, normalized by the maximum absolute exact vorticity in the band,\n$$\n\\mathcal{E}^{\\text{X}} = \\frac{\\left(\\frac{1}{|\\mathcal{B}|}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\omega^{\\text{X}}_{i,j} - \\omega_{\\text{true}}(x_i,y_j)\\right)^2\\right)^{1/2}}{\\max_{(i,j)\\in\\mathcal{B}}\\left|\\omega_{\\text{true}}(x_i,y_j)\\right|}.\n$$\n\nImplement a program that, for the manufactured streamfunction above and the specified discretizations S2 and HC4, evaluates whether the high-order compact scheme reduces the near-wall leakage metric compared to the second-order scheme, i.e., whether $\\mathcal{E}^{\\text{HC4}} < \\mathcal{E}^{\\text{S2}}$, for the following test suite of grid resolutions and sharpness parameters:\n- Test case $1$: $N = 65$, $k = 3$.\n- Test case $2$: $N = 17$, $k = 3$.\n- Test case $3$: $N = 65$, $k = 6$.\n- Test case $4$: $N = 17$, $k = 6$.\n\nAll quantities are nondimensional; no physical units are required. Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets, in the order of the test suite, for example, \"[True,False,True,True]\".", "solution": "The problem is valid. It is a well-posed numerical analysis exercise grounded in the fundamental principles of computational fluid dynamics, specifically the streamfunction-vorticity formulation of the Navier-Stokes equations. All provided definitions, equations, and boundary conditions are scientifically sound, consistent, and sufficient to proceed with a solution.\n\nThe task is to compare the accuracy of two finite difference schemes for computing vorticity, $\\omega = -\\nabla^2 \\psi$, from a given smooth streamfunction, $\\psi$, in the vicinity of a no-slip wall. The comparison is performed on a 2D uniform Cartesian grid for several parameter sets. The core of the solution involves the careful implementation of these schemes and a specified error metric.\n\nFirst, we establish the computational domain and grid. The domain is a unit square, $[0,1]\\times[0,1]$, discretized by an $N \\times N$ grid of points. The grid spacing is uniform, given by $h = 1/(N-1)$. The grid coordinates $(x_i, y_j)$ are given by $x_i = i \\cdot h$ and $y_j = j \\cdot h$ for indices $i, j$ ranging from $0$ to $N-1$. Using these coordinates, we evaluate the manufactured streamfunction $\\psi(x,y) = \\sin^2(k\\pi x)\\,\\sin^2(k\\pi y)$ and the exact vorticity $\\omega_{\\text{true}}(x,y) = -2\\,(k\\pi)^2[\\cos(2k\\pi x)\\,\\sin^2(k\\pi y) + \\cos(2k\\pi y)\\,\\sin^2(k\\pi x)]$ at all grid points $(x_i, y_j)$, storing them in $N \\times N$ arrays.\n\nNext, we implement the two numerical schemes to approximate the vorticity $\\omega = -\\nabla^2\\psi$ at the interior grid points, where indices $(i,j)$ are in the range $[1, N-2] \\times [1, N-2]$.\n\n1.  **Second-Order Scheme (S2)**: The vorticity $\\omega^{\\text{S2}}$ is computed using the standard five-point stencil for the Laplacian, $\\nabla^2$. For an interior point $(i,j)$, the formula is:\n    $$\n    \\omega^{\\text{S2}}_{i,j} = - \\left( \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} \\right)\n    $$\n    This is implemented efficiently for all interior points simultaneously using `numpy` array slicing. The stencil naturally incorporates the boundary values of $\\psi$ (where $\\psi=0$) when applied to points adjacent to the boundary (e.g., at $i=1$, the term $\\psi_{i-1,j} = \\psi_{0,j}$ is used).\n\n2.  **High-Order Compact Scheme (HC4)**: This scheme approximates the Laplacian by summing the fourth-order accurate approximations of the second partial derivatives, $\\partial^2\\psi/\\partial x^2$ and $\\partial^2\\psi/\\partial y^2$. The one-dimensional five-point stencil for the second derivative, for instance in the $x$-direction, is:\n    $$\n    \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{i,j} = \\frac{-\\psi_{i-2,j} + 16\\psi_{i-1,j} - 30\\psi_{i,j} + 16\\psi_{i+1,j} - \\psi_{i+2,j}}{12\\,h^2}\n    $$\n    A key aspect of this problem is handling this stencil near the boundaries where it requires 'ghost' points outside the domain. The problem specifies a closure compatible with the no-slip condition $\\partial\\psi/\\partial n = 0$, which implies an even reflection across the boundary. For example, at the wall $x=0$ (index $i=0$), this means $\\psi(-x, y) = \\psi(x, y)$. In terms of grid indices, this gives $\\psi_{-p,j} = \\psi_{p,j}$.\n    - For a point at $i=1$, the stencil requires $\\psi_{-1,j}$. Using the even reflection rule, we substitute $\\psi_{1,j}$, resulting in a modified stencil for $\\partial^2\\psi/\\partial x^2$:\n      $$\n      \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{1,j} = \\frac{16\\psi_{0,j} - 31\\psi_{1,j} + 16\\psi_{2,j} - \\psi_{3,j}}{12\\,h^2}\n      $$\n    - Similarly, at $i=N-2$, the stencil requires $\\psi_{N,j}$. The reflection rule across the wall at $x=1$ (index $N-1$) is $\\psi_{N-1+p, j} = \\psi_{N-1-p, j}$, which gives $\\psi_{N,j} = \\psi_{N-2,j}$. The stencil becomes:\n      $$\n      \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{N-2,j} = \\frac{-\\psi_{N-4,j} + 16\\psi_{N-3,j} - 31\\psi_{N-2,j} + 16\\psi_{N-1,j}}{12\\,h^2}\n      $$\n    Analogous stencil modifications are applied for the $y$-derivative at $j=1$ and $j=N-2$. The interior points away from the walls (indices in $[2, N-3]\\times[2,N-3]$) use the standard five-point HC4 stencil. The computed vorticity is then $\\omega^{\\text{HC4}}_{i,j} = -[(\\partial^2\\psi/\\partial x^2)^{\\text{HC4}}_{i,j} + (\\partial^2\\psi/\\partial y^2)^{\\text{HC4}}_{i,j}]$. These calculations are also vectorized using `numpy` slices for the bulk interior and for the near-wall rows/columns separately.\n\nFinally, we calculate the leakage metric $\\mathcal{E}^{\\text{X}}$ for each scheme $\\text{X} \\in \\{\\text{S2}, \\text{HC4}\\}$. The near-wall band $\\mathcal{B}$ is identified as the set of interior points $(i,j)$ where $i=1$, $j=1$, $i=N-2$, or $j=N-2$. A boolean mask is created to represent this band. The metric is the Root-Mean-Square (RMS) error of the computed vorticity within this band, normalized by the maximum absolute true vorticity in the same band:\n$$\n\\mathcal{E}^{\\text{X}} = \\frac{\\sqrt{\\frac{1}{|\\mathcal{B}|}\\sum_{(i,j)\\in\\mathcal{B}}(\\omega^{\\text{X}}_{i,j} - \\omega_{\\text{true}}(x_i,y_j))^2}}{\\max_{(i,j)\\in\\mathcal{B}}|\\omega_{\\text{true}}(x_i,y_j)|}\n$$\nThe value of $|\\mathcal{B}|$ is the total number of points in the band. For each test case defined by a pair $(N, k)$, we compute $\\mathcal{E}^{\\text{S2}}$ and $\\mathcal{E}^{\\text{HC4}}$ and determine if the high-order scheme yields a lower error, i.e., if $\\mathcal{E}^{\\text{HC4}} < \\mathcal{E}^{\\text{S2}}$. The resulting boolean values are collected and printed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The scipy library is permitted but not required for this solution.\n\ndef solve_case(N, k):\n    \"\"\"\n    Solves a single test case for a given grid size N and parameter k.\n    \"\"\"\n    # 1. Grid Setup\n    h = 1.0 / (N - 1)\n    grid_pts = np.linspace(0, 1, N)\n    # Use 'ij' indexing so that the first index corresponds to x and the second to y\n    X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n    # 2. Evaluate Exact Fields\n    kp = k * np.pi\n    psi = (np.sin(kp * X)**2) * (np.sin(kp * Y)**2)\n    omega_true = -2 * kp**2 * (\n        np.cos(2 * kp * X) * np.sin(kp * Y)**2 +\n        np.cos(2 * kp * Y) * np.sin(kp * X)**2\n    )\n\n    # Define slices for the interior domain\n    interior_slice = slice(1, N - 1)\n    \n    # 3. Compute S2 vorticity\n    h2 = h**2\n    omega_s2 = np.zeros_like(psi)\n    \n    # Standard 5-point Laplacian stencil for all interior points\n    lap_s2 = (psi[2:N, interior_slice] + psi[0:N-2, interior_slice] +\n              psi[interior_slice, 2:N] + psi[interior_slice, 0:N-2] -\n              4 * psi[interior_slice, interior_slice]) / h2\n    \n    omega_s2[interior_slice, interior_slice] = -lap_s2\n\n    # 4. Compute HC4 vorticity\n    omega_hc4 = np.zeros_like(psi)\n    d2psidx2 = np.zeros_like(psi)\n    d2psidy2 = np.zeros_like(psi)\n    \n    # Check for grid size, HC4 logic requires N > 3.\n    if N > 3:\n        # 4a. d2psi/dx^2 calculation\n        j_slice = slice(1, N - 1)\n        # Bulk interior rows: i in [2, N-3]\n        if N > 4:\n            d2psidx2[2:N-2, j_slice] = (\n                -psi[0:N-4, j_slice] + 16 * psi[1:N-3, j_slice] -\n                 30 * psi[2:N-2, j_slice] + 16 * psi[3:N-1, j_slice] -\n                 psi[4:N, j_slice]\n            )\n        # Row i=1 (near wall x=0)\n        d2psidx2[1, j_slice] = (\n            16 * psi[0, j_slice] - 31 * psi[1, j_slice] + 16 * psi[2, j_slice] - psi[3, j_slice]\n        )\n        # Row i=N-2 (near wall x=1)\n        d2psidx2[N-2, j_slice] = (\n            -psi[N-4, j_slice] + 16 * psi[N-3, j_slice] - \n            31 * psi[N-2, j_slice] + 16 * psi[N-1, j_slice]\n        )\n\n        # 4b. d2psi/dy^2 calculation\n        i_slice = slice(1, N - 1)\n        # Bulk interior columns: j in [2, N-3]\n        if N > 4:\n            d2psidy2[i_slice, 2:N-2] = (\n                -psi[i_slice, 0:N-4] + 16 * psi[i_slice, 1:N-3] -\n                 30 * psi[i_slice, 2:N-2] + 16 * psi[i_slice, 3:N-1] -\n                 psi[i_slice, 4:N]\n            )\n        # Column j=1 (near wall y=0)\n        d2psidy2[i_slice, 1] = (\n            16 * psi[i_slice, 0] - 31 * psi[i_slice, 1] + 16 * psi[i_slice, 2] - psi[i_slice, 3]\n        )\n        # Column j=N-2 (near wall y=1)\n        d2psidy2[i_slice, N-2] = (\n            -psi[i_slice, N-4] + 16 * psi[i_slice, N-3] - \n            31 * psi[i_slice, N-2] + 16 * psi[i_slice, N-1]\n        )\n\n    # Combine derivatives and apply coefficient\n    c = 1.0 / (12 * h2)\n    omega_hc4[interior_slice, interior_slice] = -c * (d2psidx2[interior_slice, interior_slice] + d2psidy2[interior_slice, interior_slice])\n\n    # 5. Define Near-Wall Band and Calculate Error Metrics\n    band_mask = np.zeros_like(psi, dtype=bool)\n    if N > 2:\n        band_mask[1, 1:N-1] = True\n        band_mask[N-2, 1:N-1] = True\n        band_mask[1:N-1, 1] = True\n        band_mask[1:N-1, N-2] = True\n    \n    num_band_points = np.sum(band_mask)\n    if num_band_points == 0:\n        return False # No data to compare\n\n    def calculate_leakage(omega_num):\n        err = omega_num - omega_true\n        err_band = err[band_mask]\n        omega_true_band = omega_true[band_mask]\n        \n        sse = np.sum(err_band**2)\n        rms_err = np.sqrt(sse / num_band_points)\n        \n        max_omega_abs = np.max(np.abs(omega_true_band))\n        if max_omega_abs == 0:\n            return float('inf') if rms_err > 0 else 0.0\n        \n        return rms_err / max_omega_abs\n\n    E_s2 = calculate_leakage(omega_s2)\n    E_hc4 = calculate_leakage(omega_hc4)\n\n    return E_hc4 < E_s2\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (65, 3),  # Test case 1: N = 65, k = 3\n        (17, 3),  # Test case 2: N = 17, k = 3\n        (65, 6),  # Test case 3: N = 65, k = 6\n        (17, 6),  # Test case 4: N = 17, k = 6\n    ]\n\n    results = []\n    for N, k in test_cases:\n        result = solve_case(N, k)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    # The boolean values are converted to string 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3389276"}, {"introduction": "The heart of the vorticity transport equation is the nonlinear advection term, $J(\\psi, \\omega)$, which is responsible for the rich dynamics of fluid flow and is a primary source of numerical error. When using pseudo-spectral methods, this nonlinearity gives rise to aliasing, where unresolved high-frequency interactions contaminate the solution. This exercise provides hands-on experience in diagnosing and mitigating aliasing by comparing a naive solver with common dealiasing techniques, demonstrating their impact on the conservation of physical invariants like energy and enstrophy [@problem_id:3389248].", "problem": "Consider the two-dimensional incompressible Euler equations in the streamfunction–vorticity formulation on a doubly periodic square domain of side length $2\\pi$. The vorticity field $\\omega(x,y,t)$ evolves according to the vorticity transport equation $\\,\\partial_t \\omega - J(\\psi,\\omega) = 0\\,$, where the streamfunction $\\psi(x,y,t)$ satisfies the Poisson equation $-\\nabla^2 \\psi = \\omega$ and the Jacobian $J(\\psi,\\omega)$ is $J(\\psi,\\omega) = \\partial_x \\psi\\,\\partial_y \\omega - \\partial_y \\psi\\,\\partial_x \\omega$. The velocity components are $u = \\partial_y \\psi$ and $v = -\\partial_x \\psi$. Assume non-dimensional variables throughout. You must derive and implement a pseudo-spectral solver using the Fast Fourier Transform (FFT) for spatial derivatives, with the nonlinear Jacobian evaluated in physical space. The starting point for your derivation must be the incompressible Euler equations and the definitions of the streamfunction, vorticity, and Jacobian given above. You must reason from these to design a numerically consistent algorithm.\n\nYour task is to quantify numerical aliasing in the Jacobian $J(\\psi,\\omega)$ by comparing three different treatments of the nonlinear term:\n- No dealiasing (direct pseudo-spectral evaluation).\n- Two-thirds wavenumber truncation (commonly called $\\frac{2}{3}$ dealiasing).\n- Physical-space Gaussian filtering of the computed Jacobian.\n\nUse the inviscid double-shear-layer instability as the initial condition. Let the initial velocity be\n$$\nu(x,y,0) = U(y),\\quad v(x,y,0) = \\varepsilon \\sin(x),\n$$\nwith\n$$\nU(y) = \\tanh\\!\\left(\\frac{y - \\frac{\\pi}{2}}{\\delta}\\right) - \\tanh\\!\\left(\\frac{y - \\frac{3\\pi}{2}}{\\delta}\\right),\n$$\nand vorticity\n$$\n\\omega(x,y,0) = \\partial_x v(x,y,0) - \\partial_y u(x,y,0) = \\varepsilon \\cos(x) - U'(y),\\quad U'(y) = \\frac{1}{\\delta}\\,\\mathrm{sech}^2\\!\\left(\\frac{y - \\frac{\\pi}{2}}{\\delta}\\right) - \\frac{1}{\\delta}\\,\\mathrm{sech}^2\\!\\left(\\frac{y - \\frac{3\\pi}{2}}{\\delta}\\right).\n$$\nWork on the periodic domain $[0,2\\pi)\\times[0,2\\pi)$ with uniform grids of size $N\\times N$. In Fourier space, compute spatial derivatives by multiplying by the appropriate wavenumbers $k_x$ and $k_y$ that correspond to the Fourier series of functions with period $2\\pi$. For all cases, advance the solution in time using a three-stage Strong Stability Preserving Runge–Kutta scheme of formal order three, applied to $\\partial_t \\omega = J(\\psi,\\omega)$.\n\nDefine the following diagnostics to quantify aliasing:\n- The kinetic energy\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\int_{0}^{2\\pi}\\left(u^2+v^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n- The enstrophy\n$$\nZ(t) = \\frac{1}{2}\\int_{0}^{2\\pi}\\int_{0}^{2\\pi}\\omega^2\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n- The final-time high-wavenumber enstrophy fraction $f_{\\mathrm{high}}(T)$ defined as the ratio of enstrophy contained in Fourier modes with either $|k_x|>\\kappa_c$ or $|k_y|>\\kappa_c$ to the total enstrophy, where $\\kappa_c$ is the cutoff $\\,\\kappa_c = \\left\\lfloor\\frac{N}{3}\\right\\rfloor\\,$, and $N$ is the number of grid points in each direction.\n\nCompute the relative drifts of the invariants over the simulation interval $[0,T]$:\n$$\n\\Delta E/E_0 = \\frac{E(T)-E(0)}{E(0)},\\qquad \\Delta Z/Z_0 = \\frac{Z(T)-Z(0)}{Z(0)}.\n$$\n\nImplement three nonlinear Jacobian treatments:\n- No dealiasing: compute $J(\\psi,\\omega)$ in physical space directly from spectral derivatives without any truncation or filtering.\n- Two-thirds dealiasing: before forming the physical-space products that comprise $J(\\psi,\\omega)$, truncate the Fourier spectra of the differentiated fields to zero outside the rectangular region $|k_x|\\le \\kappa_c$, $|k_y|\\le \\kappa_c$, and then compute products in physical space.\n- Physical-space filtering: compute $J(\\psi,\\omega)$ directly and then convolve it with a normalized, separable Gaussian kernel of integer radius $r$ and standard deviation $\\sigma$ (in grid-point units), using periodic wrap-around in both directions.\n\nDesign your program to run the following test suite, each specified by the tuple $(N,\\delta,\\varepsilon,\\Delta t, \\text{steps}, \\text{method}, r, \\sigma)$, where $r$ and $\\sigma$ are only used for physical-space filtering:\n- Test $1$: $(N=32,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0010,\\ \\text{steps}=150,\\ \\text{method}=\\text{none},\\ r=0,\\ \\sigma=0.0)$.\n- Test $2$: $(N=32,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0010,\\ \\text{steps}=150,\\ \\text{method}=\\text{two\\_thirds},\\ r=0,\\ \\sigma=0.0)$.\n- Test $3$: $(N=32,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0010,\\ \\text{steps}=150,\\ \\text{method}=\\text{physical},\\ r=1,\\ \\sigma=0.70)$.\n- Test $4$: $(N=64,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0007,\\ \\text{steps}=150,\\ \\text{method}=\\text{none},\\ r=0,\\ \\sigma=0.0)$.\n- Test $5$: $(N=64,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0007,\\ \\text{steps}=150,\\ \\text{method}=\\text{two\\_thirds},\\ r=0,\\ \\sigma=0.0)$.\n- Edge Test $6$: $(N=48,\\ \\delta=0.05,\\ \\varepsilon=0.05,\\ \\Delta t=0.0009,\\ \\text{steps}=150,\\ \\text{method}=\\text{physical},\\ r=2,\\ \\sigma=1.00)$.\n\nFor each test, compute and report the triple $[\\Delta E/E_0,\\ \\Delta Z/Z_0,\\ f_{\\mathrm{high}}(T)]$ as real numbers (unitless). Your program should produce a single line of output containing the results as a comma-separated list of these triples, enclosed in square brackets, for example $[\\,[a,b,c],\\,[d,e,f],\\,\\dots]$. You must round each reported float to six decimal places in the final output formatting. No external input or files are permitted; all constants must be defined within the program. The numerical algorithm must be reproducible across platforms that implement the same Fast Fourier Transform semantics.", "solution": "The problem requires the development of a pseudo-spectral solver for the two-dimensional incompressible Euler equations in the streamfunction-vorticity formulation to study the effects of numerical aliasing. The analysis will be performed on a test case involving the double-shear-layer instability.\n\nThe governing equations are the vorticity transport equation,\n$$\n\\partial_t \\omega - J(\\psi,\\omega) = 0\n$$\nand the Poisson equation relating the streamfunction $\\psi$ to the vorticity $\\omega$,\n$$\n-\\nabla^2 \\psi = \\omega\n$$\nwhere $\\nabla^2 = \\partial_x^2 + \\partial_y^2$. The domain is a doubly periodic square $[0, 2\\pi) \\times [0, 2\\pi)$. The velocity components $(u, v)$ are given by $u = \\partial_y \\psi$ and $v = -\\partial_x \\psi$. The Jacobian operator, representing the advection of vorticity by the velocity field, is defined as\n$$\nJ(\\psi, \\omega) = (\\partial_x \\psi)(\\partial_y \\omega) - (\\partial_y \\psi)(\\partial_x \\omega)\n$$\n\nWe will discretize the domain using a uniform grid of size $N \\times N$, with grid points $(x_i, y_j) = (i \\frac{2\\pi}{N}, j \\frac{2\\pi}{N})$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. A pseudo-spectral method leverages the efficiency and accuracy of the Fast Fourier Transform (FFT) for computing spatial derivatives in problems with periodic boundary conditions.\n\nA function $f(x, y)$ on this grid is represented by its discrete Fourier series:\n$$\nf(x_i, y_j) = \\sum_{k_x=-N/2+1}^{N/2} \\sum_{k_y=-N/2+1}^{N/2} \\hat{f}(k_x, k_y) e^{i(k_x x_i + k_y y_j)}\n$$\nwhere $\\hat{f}(k_x, k_y)$ are the discrete Fourier coefficients and $k_x, k_y$ are integer wavenumbers. The DFT and its inverse (IDFT) provide a mapping between the physical-space representation $f(x_i, y_j)$ and the spectral-space representation $\\hat{f}(k_x, k_y)$. Crucially, spatial derivatives are transformed into algebraic multiplications in spectral space:\n$$\n\\mathcal{F}(\\partial_x f) = i k_x \\hat{f}, \\quad \\mathcal{F}(\\partial_y f) = i k_y \\hat{f}\n$$\nHere, $\\mathcal{F}$ denotes the DFT. In our numerical implementation, the wavenumbers corresponding to the DFT arrays are provided by `numpy.fft.fftfreq(N) * N`, which generates the sequence of integers $\\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$.\n\nThe Poisson equation $-\\nabla^2 \\psi = \\omega$ becomes trivial to solve in spectral space:\n$$\n-( (i k_x)^2 + (i k_y)^2 ) \\hat{\\psi} = \\hat{\\omega} \\implies (k_x^2 + k_y^2) \\hat{\\psi} = \\hat{\\omega}\n$$\nThus, the streamfunction coefficients are found via:\n$$\n\\hat{\\psi}(k_x, k_y) = \\frac{\\hat{\\omega}(k_x, k_y)}{k_x^2 + k_y^2}, \\quad \\text{for } k_x^2+k_y^2 \\neq 0\n$$\nFor the mean mode $(k_x, k_y) = (0, 0)$, the continuous vorticity field has a zero-mean due to periodicity ($\\iint \\omega \\,dx\\,dy = \\oint (\\mathbf{u} \\cdot d\\mathbf{l}) = 0$). This ensures $\\hat{\\omega}(0, 0) = 0$. We set $\\hat{\\psi}(0, 0) = 0$, as the mean of the streamfunction is physically irrelevant.\n\nThe vorticity transport equation is an ordinary differential equation (ODE) in time for the Fourier coefficients $\\hat{\\omega}$:\n$$\n\\frac{d\\hat{\\omega}}{dt} = \\mathcal{F}\\{ J(\\psi, \\omega) \\}\n$$\nThe nonlinear Jacobian term $J(\\psi, \\omega)$ is computed in physical space to avoid the expensive convolutions required by a fully spectral method. This \"pseudo-spectral\" approach proceeds as follows:\n$1$. Given $\\hat{\\omega}(t)$, solve for $\\hat{\\psi}(t)$ using the spectral Poisson solver.\n$2$. Compute the spectral coefficients of the required derivatives: $\\widehat{\\partial_x\\psi} = ik_x\\hat{\\psi}$, $\\widehat{\\partial_y\\psi} = ik_y\\hat{\\psi}$, $\\widehat{\\partial_x\\omega} = ik_x\\hat{\\omega}$, and $\\widehat{\\partial_y\\omega} = ik_y\\hat{\\omega}$.\n$3$. Apply an IDFT to each of these four fields to obtain their physical-space representations $\\partial_x\\psi$, $\\partial_y\\psi$, $\\partial_x\\omega$, and $\\partial_y\\omega$.\n$4$. Compute the pointwise product in physical space: $J(x_i, y_j) = (\\partial_x\\psi)(\\partial_y\\omega) - (\\partial_y\\psi)(\\partial_x\\omega)$.\n$5$. Apply a DFT to $J(x_i, y_j)$ to obtain $\\mathcal{F}\\{J(\\psi, \\omega)\\}$, which is the right-hand side of the ODE for $\\hat{\\omega}$.\n\nThe product in step $4$ can introduce aliasing errors. If the input fields contain wavenumbers up to $k_{max} \\approx N/2$, their product can contain wavenumbers up to $2k_{max} \\approx N$. Wavenumbers greater than $N/2$ are misrepresented (aliased) as lower wavenumbers on the $N$-point grid, contaminating the solution. We will investigate three treatments for this term:\n\n$1$. **No dealiasing**: The procedure described above is followed directly. This is the most computationally efficient but also the most susceptible to aliasing instability.\n\n$2$. **Two-thirds wavenumber truncation**: Before step $3$, the spectral coefficients of the four derivative fields are truncated. Any coefficient $\\hat{f}(k_x, k_y)$ for which $|k_x| > \\kappa_c$ or $|k_y| > \\kappa_c$ is set to zero, where $\\kappa_c = \\lfloor N/3 \\rfloor$. This ensures that the highest wavenumber in the product is approximately $2\\kappa_c \\approx 2N/3$. While this is still greater than the Nyquist wavenumber $N/2$, it removes the highest-wavenumber interactions, which are the primary source of aliasing instability.\n\n$3$. **Physical-space Gaussian filtering**: After step $4$, the computed Jacobian $J(x_i, y_j)$ is filtered by convolving it with a discrete, normalized, $2$D Gaussian kernel. The convolution is performed with periodic boundary conditions. The kernel is separable, constructed from a $1$D kernel $K_1[i] = \\exp(-((i-r)/\\sigma)^2/2)$ for $i \\in \\{0, \\dots, 2r\\}$, where $r$ is the integer radius and $\\sigma$ is the standard deviation. This filter smooths the Jacobian, damping the high-wavenumber components that result from aliasing.\n\nFor time integration of the semi-discrete equation $d\\hat{\\omega}/dt = \\mathcal{L}(\\hat{\\omega})$, we use a three-stage, third-order accurate Strong Stability Preserving Runge-Kutta (SSP-RK$3$) scheme:\n$$\n\\begin{aligned}\n\\hat{\\omega}^{(1)} &= \\hat{\\omega}^n + \\Delta t \\mathcal{L}(\\hat{\\omega}^n) \\\\\n\\hat{\\omega}^{(2)} &= \\frac{3}{4} \\hat{\\omega}^n + \\frac{1}{4} \\hat{\\omega}^{(1)} + \\frac{1}{4} \\Delta t \\mathcal{L}(\\hat{\\omega}^{(1)}) \\\\\n\\hat{\\omega}^{n+1} &= \\frac{1}{3} \\hat{\\omega}^n + \\frac{2}{3} \\hat{\\omega}^{(2)} + \\frac{2}{3} \\Delta t \\mathcal{L}(\\hat{\\omega}^{(2)})\n\\end{aligned}\n$$\nThis scheme is applied at each time step $\\Delta t$ to advance the solution from $t$ to $t+\\Delta t$.\n\nThe initial condition is the double-shear-layer, with vorticity $\\omega(x,y,0) = \\varepsilon \\cos(x) - U'(y)$, where $U'(y) = \\frac{1}{\\delta}\\,\\mathrm{sech}^2(\\frac{y - \\pi/2}{\\delta}) - \\frac{1}{\\delta}\\,\\mathrm{sech}^2(\\frac{y - 3\\pi/2}{\\delta})$. This field is initialized on the physical grid and transformed to spectral space to obtain $\\hat{\\omega}(0)$.\n\nDiagnostics are computed to quantify the performance of each method. The total kinetic energy $E(t)$ and enstrophy $Z(t)$ are inviscid invariants of the continuous Euler equations. Their numerical drift indicates error accumulation. They are computed via numerical integration over the physical grid:\n$$\nE(t) = \\frac{1}{2} \\left(\\frac{2\\pi}{N}\\right)^2 \\sum_{i,j=0}^{N-1} (u_{ij}^2+v_{ij}^2), \\quad Z(t) = \\frac{1}{2} \\left(\\frac{2\\pi}{N}\\right)^2 \\sum_{i,j=0}^{N-1} \\omega_{ij}^2\n$$\nThe velocity components $u$ and $v$ are obtained by transforming $\\hat{u} = ik_y\\hat{\\psi}$ and $\\hat{v} = -ik_x\\hat{\\psi}$ to physical space. The aliasing error is also quantified by the fraction of final-time enstrophy residing in high-wavenumber modes, $f_{\\mathrm{high}}(T)$, computed in spectral space:\n$$\nf_{\\mathrm{high}}(T) = \\frac{\\sum_{|k_x|>\\kappa_c \\text{ or } |k_y|>\\kappa_c} |\\hat{\\omega}(k_x, k_y, T)|^2}{\\sum_{\\text{all } k_x, k_y} |\\hat{\\omega}(k_x, k_y, T)|^2}\n$$\nThese diagnostics allow for a quantitative comparison of the aliasing control methods.", "answer": "```python\nimport numpy as np\nimport scipy.signal\n\ndef solve():\n    \"\"\"\n    Solves the 2D Euler equations using a pseudo-spectral method\n    to analyze aliasing effects based on the problem specification.\n    \"\"\"\n\n    test_cases = [\n        # (N, delta, epsilon, dt, steps, method, r, sigma)\n        (32, 0.05, 0.05, 0.0010, 150, 'none', 0, 0.0),\n        (32, 0.05, 0.05, 0.0010, 150, 'two_thirds', 0, 0.0),\n        (32, 0.05, 0.05, 0.0010, 150, 'physical', 1, 0.70),\n        (64, 0.05, 0.05, 0.0007, 150, 'none', 0, 0.0),\n        (64, 0.05, 0.05, 0.0007, 150, 'two_thirds', 0, 0.0),\n        (48, 0.05, 0.05, 0.0009, 150, 'physical', 2, 1.00),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N, delta, epsilon, dt, steps, method, r, sigma = case\n        \n        # Grid and Wavenumbers\n        L = 2 * np.pi\n        dx = L / N\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        kx = np.fft.fftfreq(N, d=1.0/N)\n        ky = np.fft.fftfreq(N, d=1.0/N)\n        kxx, kyy = np.meshgrid(kx, ky, indexing='ij')\n\n        ksq = kxx**2 + kyy**2\n        ksq_inv = np.zeros_like(ksq)\n        ksq_inv[ksq > 0] = 1.0 / ksq[ksq > 0]\n\n        # Dealiasing masks\n        kappa_c = int(N / 3)\n        dealias_mask = (np.abs(kxx) = kappa_c)  (np.abs(kyy) = kappa_c)\n        high_k_mask = (np.abs(kxx) > kappa_c) | (np.abs(kyy) > kappa_c)\n        \n        # Gaussian filter kernel for physical-space filtering\n        gauss_kernel = None\n        if method == 'physical' and r > 0:\n            kernel_indices = np.arange(2 * r + 1)\n            kernel_coords = kernel_indices - r\n            kernel_1d = np.exp(-kernel_coords**2 / (2 * sigma**2))\n            kernel_1d /= np.sum(kernel_1d)\n            gauss_kernel = np.outer(kernel_1d, kernel_1d)\n\n        # Initial Condition\n        def sech(z):\n            return 1.0 / np.cosh(z)\n\n        U_prime = (1.0/delta) * (sech((yy - L/4) / delta)**2 - sech((yy - 3*L/4) / delta)**2)\n        omega0_phys = epsilon * np.cos(xx) - U_prime\n        omega_hat = np.fft.fftn(omega0_phys)\n\n        def get_diagnostics(omega_hat_current):\n            # Enstrophy\n            omega_phys = np.real(np.fft.ifftn(omega_hat_current))\n            enstrophy = 0.5 * dx**2 * np.sum(omega_phys**2)\n            \n            # Kinetic Energy\n            psi_hat = -omega_hat_current * ksq_inv\n            u_hat = 1j * kyy * psi_hat\n            v_hat = -1j * kxx * psi_hat\n            u_phys = np.real(np.fft.ifftn(u_hat))\n            v_phys = np.real(np.fft.ifftn(v_hat))\n            energy = 0.5 * dx**2 * np.sum(u_phys**2 + v_phys**2)\n            \n            return energy, enstrophy\n\n        E0, Z0 = get_diagnostics(omega_hat)\n\n        def calculate_rhs(omega_hat_t):\n            psi_hat = -omega_hat_t * ksq_inv\n            \n            psi_x_hat = 1j * kxx * psi_hat\n            psi_y_hat = 1j * kyy * psi_hat\n            omega_x_hat = 1j * kxx * omega_hat_t\n            omega_y_hat = 1j * kyy * omega_hat_t\n            \n            if method == 'two_thirds':\n                psi_x_hat *= dealias_mask\n                psi_y_hat *= dealias_mask\n                omega_x_hat *= dealias_mask\n                omega_y_hat *= dealias_mask\n            \n            psi_x = np.real(np.fft.ifftn(psi_x_hat))\n            psi_y = np.real(np.fft.ifftn(psi_y_hat))\n            omega_x = np.real(np.fft.ifftn(omega_x_hat))\n            omega_y = np.real(np.fft.ifftn(omega_y_hat))\n            \n            jacobian_phys = psi_x * omega_y - psi_y * omega_x\n            \n            if method == 'physical' and gauss_kernel is not None:\n                jacobian_phys = scipy.signal.convolve2d(\n                    jacobian_phys, gauss_kernel, mode='same', boundary='wrap'\n                )\n\n            return np.fft.fftn(jacobian_phys)\n\n        # SSP-RK3 Time Stepping\n        for _ in range(steps):\n            # Stage 1\n            rhs1 = calculate_rhs(omega_hat)\n            omega_hat1 = omega_hat + dt * rhs1\n            \n            # Stage 2\n            rhs2 = calculate_rhs(omega_hat1)\n            omega_hat2 = 0.75 * omega_hat + 0.25 * (omega_hat1 + dt * rhs2)\n            \n            # Stage 3\n            rhs3 = calculate_rhs(omega_hat2)\n            omega_hat = (1.0/3.0) * omega_hat + (2.0/3.0) * (omega_hat2 + dt * rhs3)\n        \n        # Final diagnostics\n        EF, ZF = get_diagnostics(omega_hat)\n        \n        delta_E_rel = (EF - E0) / E0 if E0 != 0 else 0.0\n        delta_Z_rel = (ZF - Z0) / Z0 if Z0 != 0 else 0.0\n        \n        total_enstrophy_spec = np.sum(np.abs(omega_hat)**2)\n        high_k_enstrophy_spec = np.sum(np.abs(omega_hat[high_k_mask])**2)\n        f_high = high_k_enstrophy_spec / total_enstrophy_spec if total_enstrophy_spec != 0 else 0.0\n        \n        results.append([delta_E_rel, delta_Z_rel, f_high])\n\n    # Format output\n    formatted_results = []\n    for res_triple in results:\n        formatted_triple = [f\"{x:.6f}\" for x in res_triple]\n        formatted_results.append(f\"[{','.join(formatted_triple)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3389248"}]}