{"hands_on_practices": [{"introduction": "A cornerstone of developing reliable numerical methods is the ability to construct and analyze finite difference schemes from first principles. This is particularly crucial at domain boundaries, where standard centered stencils are not applicable. This first practice challenges you to derive a high-order, one-sided finite difference formula using the method of undetermined coefficients, a powerful technique that relies on Taylor series expansions to systematically enforce accuracy constraints [@problem_id:3364228]. By completing this analytical exercise, you will gain a deep appreciation for the direct link between the algebraic structure of a stencil and its truncation error, which dictates the scheme's order of accuracy.", "problem": "Consider a smooth scalar field $u(x)$ that represents a component of velocity in a one-dimensional incompressible flow near a solid wall at the left boundary $x=x_{0}$. The spatial grid is uniform with spacing $h>0$ and grid points $x_{j}=x_{0}+j h$ for $j=0,1,2,3$. From first principles, use Taylor’s theorem with remainder about $x=x_{0}$ to derive a one-sided linear finite difference approximation to the first derivative $u^{\\prime}(x_{0})$ of order three that uses only the nodal values $u(x_{0}),u(x_{1}),u(x_{2}),u(x_{3})$. Formulate and solve the order conditions that enforce exactness for polynomials through degree $3$ in the expansion, and state explicitly the boundary regularity assumptions on $u$ needed to justify your truncation error analysis.\n\nThen, using your derived stencil and Taylor expansions, compute the leading-order truncation error term for this approximation, expressed as a multiple of $h^{3} u^{(4)}(x_{0})$. Your final answer must be a single closed-form analytic expression equal to the leading-order truncation error term. No numerical rounding is required, and no units should be included in the final answer.", "solution": "The problem requires the derivation of a one-sided, third-order accurate finite difference approximation for the first derivative $u'(x_{0})$ using the function values at four points: $u(x_{0})$, $u(x_{1})$, $u(x_{2})$, and $u(x_{3})$. The grid is uniform with spacing $h$, such that $x_{j} = x_{0} + j h$ for $j=0, 1, 2, 3$. The derivation will proceed via the method of undetermined coefficients using Taylor's theorem, as stipulated. This will be followed by an analysis of the truncation error.\n\nFirst, we propose a linear approximation of the form:\n$$\nu'(x_{0}) \\approx D_{h}[u](x_0) = c_{0} u(x_{0}) + c_{1} u(x_{1}) + c_{2} u(x_{2}) + c_{3} u(x_{3})\n$$\nwhere $c_{0}$, $c_{1}$, $c_{2}$, and $c_{3}$ are the coefficients to be determined.\n\nThe core of the method is to expand each function value $u(x_{j})$ in a Taylor series about the point $x_{0}$. For this analysis, we must assume that the function $u(x)$ is sufficiently smooth. The required smoothness, or regularity, will be determined by the order of the approximation. To derive a scheme with a truncation error of order $O(h^{3})$, we must carry the Taylor expansions to terms of order $h^{4}$ to capture the leading error term. This requires that $u(x)$ is at least four times continuously differentiable in the interval $[x_{0}, x_{3}]$. We state this as the boundary regularity assumption: $u \\in C^{4}([x_{0}, x_{3}])$.\n\nThe Taylor expansions for $u(x_{j})$ around $x_{0}$ are:\n$$\nu(x_{1}) = u(x_{0}+h) = u(x_{0}) + h u'(x_{0}) + \\frac{h^{2}}{2} u''(x_{0}) + \\frac{h^{3}}{6} u'''(x_{0}) + \\frac{h^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n$$\nu(x_{2}) = u(x_{0}+2h) = u(x_{0}) + (2h) u'(x_{0}) + \\frac{(2h)^{2}}{2} u''(x_{0}) + \\frac{(2h)^{3}}{6} u'''(x_{0}) + \\frac{(2h)^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n$$\nu(x_{3}) = u(x_{0}+3h) = u(x_{0}) + (3h) u'(x_{0}) + \\frac{(3h)^{2}}{2} u''(x_{0}) + \\frac{(3h)^{3}}{6} u'''(x_{0}) + \\frac{(3h)^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n\nSubstituting these expansions into the formula for $D_{h}[u](x_0)$ and grouping terms by the derivatives of $u$ at $x_{0}$:\n\\begin{align*}\nD_{h}[u](x_0) &= c_{0} u(x_{0}) + c_{1} \\left( u(x_{0}) + h u'(x_{0}) + \\dots \\right) + c_{2} \\left( u(x_{0}) + 2h u'(x_{0}) + \\dots \\right) + c_{3} \\left( u(x_{0}) + 3h u'(x_{0}) + \\dots \\right) \\\\\n&= (c_{0} + c_{1} + c_{2} + c_{3}) u(x_{0}) \\\\\n&\\quad + h (c_{1} + 2c_{2} + 3c_{3}) u'(x_{0}) \\\\\n&\\quad + \\frac{h^{2}}{2} (c_{1} + 4c_{2} + 9c_{3}) u''(x_{0}) \\\\\n&\\quad + \\frac{h^{3}}{6} (c_{1} + 8c_{2} + 27c_{3}) u'''(x_{0}) \\\\\n&\\quad + \\frac{h^{4}}{24} (c_{1} + 16c_{2} + 81c_{3}) u^{(4)}(x_{0}) + O(h^{5})\n\\end{align*}\n\nFor this expression to be an approximation of $u'(x_{0})$ with an error of order $O(h^{3})$, we must match the coefficients of the derivatives on the right-hand side to those of $u'(x_{0})$ itself. This means the coefficient of $u'(x_{0})$ must be $1$, and the coefficients of $u(x_{0})$, $u''(x_{0})$, and $u'''(x_{0})$ must be $0$. This ensures the scheme is exact for any polynomial of degree up to $3$, as requested. These are the order conditions:\n\\begin{enumerate}\n    \\item Coeff of $u(x_{0})$: $c_{0} + c_{1} + c_{2} + c_{3} = 0$\n    \\item Coeff of $u'(x_{0})$: $h(c_{1} + 2c_{2} + 3c_{3}) = 1 \\implies c_{1} + 2c_{2} + 3c_{3} = \\frac{1}{h}$\n    \\item Coeff of $u''(x_{0})$: $\\frac{h^{2}}{2}(c_{1} + 4c_{2} + 9c_{3}) = 0 \\implies c_{1} + 4c_{2} + 9c_{3} = 0$\n    \\item Coeff of $u'''(x_{0})$: $\\frac{h^{3}}{6}(c_{1} + 8c_{2} + 27c_{3}) = 0 \\implies c_{1} + 8c_{2} + 27c_{3} = 0$\n\\end{enumerate}\n\nWe now solve this system of four linear equations for the four coefficients. Let's first solve the subsystem for $c_{1}, c_{2}, c_{3}$ (equations 2, 3, 4).\nSubtracting equation (3) from (4):\n$(c_{1} + 8c_{2} + 27c_{3}) - (c_{1} + 4c_{2} + 9c_{3}) = 0 - 0 \\implies 4c_{2} + 18c_{3} = 0$, which simplifies to $2c_{2} + 9c_{3} = 0$.\n\nSubtracting equation (2) from (3):\n$(c_{1} + 4c_{2} + 9c_{3}) - (c_{1} + 2c_{2} + 3c_{3}) = 0 - \\frac{1}{h} \\implies 2c_{2} + 6c_{3} = -\\frac{1}{h}$.\n\nWe now have a system of two equations for $c_{2}$ and $c_{3}$:\n$$\n\\begin{cases}\n2c_{2} + 9c_{3} = 0 \\\\\n2c_{2} + 6c_{3} = -\\frac{1}{h}\n\\end{cases}\n$$\nSubtracting the second of these new equations from the first gives:\n$(2c_{2} + 9c_{3}) - (2c_{2} + 6c_{3}) = 0 - (-\\frac{1}{h}) \\implies 3c_{3} = \\frac{1}{h} \\implies c_{3} = \\frac{1}{3h}$.\n\nSubstituting $c_{3}$ back into $2c_{2} + 9c_{3} = 0$:\n$2c_{2} + 9(\\frac{1}{3h}) = 0 \\implies 2c_{2} + \\frac{3}{h} = 0 \\implies c_{2} = -\\frac{3}{2h}$.\n\nSubstituting $c_{2}$ and $c_{3}$ into equation (3):\n$c_{1} + 4(-\\frac{3}{2h}) + 9(\\frac{1}{3h}) = 0 \\implies c_{1} - \\frac{6}{h} + \\frac{3}{h} = 0 \\implies c_{1} = \\frac{3}{h}$.\n\nFinally, using equation (1) to find $c_{0}$:\n$c_{0} + \\frac{3}{h} - \\frac{3}{2h} + \\frac{1}{3h} = 0 \\implies c_{0} = -\\frac{3}{h} + \\frac{3}{2h} - \\frac{1}{3h} = \\frac{-18+9-2}{6h} = -\\frac{11}{6h}$.\n\nThe coefficients for the finite difference approximation are:\n$c_{0} = -\\frac{11}{6h}$, $c_{1} = \\frac{3}{h} = \\frac{18}{6h}$, $c_{2} = -\\frac{3}{2h} = -\\frac{9}{6h}$, $c_{3} = \\frac{1}{3h} = \\frac{2}{6h}$.\n\nThe resulting third-order one-sided finite difference formula is:\n$$\nD_{h}[u](x_0) = \\frac{-11 u(x_{0}) + 18 u(x_{1}) - 9 u(x_{2}) + 2 u(x_{3})}{6h}\n$$\n\nThe truncation error $T$ is defined as the difference between the approximation and the true derivative, $T = D_{h}[u](x_0) - u'(x_{0})$. The leading-order term of this error comes from the first non-zero term in the Taylor expansion of $D_{h}[u](x_0)$ after the $u'(x_{0})$ term. This is the term involving $u^{(4)}(x_{0})$.\n$$\nT = \\frac{h^{4}}{24} (c_{1} + 16c_{2} + 81c_{3}) u^{(4)}(x_{0}) + O(h^{5})\n$$\nWe substitute the values of the coefficients into the expression $c_{1} + 16c_{2} + 81c_{3}$:\n$$\nc_{1} + 16c_{2} + 81c_{3} = \\frac{3}{h} + 16\\left(-\\frac{3}{2h}\\right) + 81\\left(\\frac{1}{3h}\\right) = \\frac{3}{h} - \\frac{48}{2h} + \\frac{81}{3h} = \\frac{3}{h} - \\frac{24}{h} + \\frac{27}{h} = \\frac{3-24+27}{h} = \\frac{6}{h}\n$$\nNow, substitute this result back into the expression for the truncation error:\n$$\nT = \\frac{h^{4}}{24} \\left(\\frac{6}{h}\\right) u^{(4)}(x_{0}) + O(h^{4}) = \\frac{6h^{3}}{24} u^{(4)}(x_{0}) + O(h^{4}) = \\frac{1}{4}h^{3} u^{(4)}(x_{0}) + O(h^{4})\n$$\nThe leading-order truncation error term is therefore $\\frac{1}{4}h^{3} u^{(4)}(x_{0})$.\nThis confirms that the order of accuracy of the scheme is $3$, as the error is proportional to $h^3$.", "answer": "$$\\boxed{\\frac{1}{4} h^{3} u^{(4)}(x_{0})}$$", "id": "3364228"}, {"introduction": "While analytical derivations provide the theoretical order of accuracy, the performance of a numerical scheme in practice is governed by the realities of floating-point arithmetic. Algebraically identical expressions can yield dramatically different results due to round-off errors. This computational exercise explores the phenomenon of catastrophic cancellation, where subtracting two nearly equal numbers leads to a significant loss of precision [@problem_id:3364188]. By testing different formulations for a flux derivative, you will see how a theoretically second-order scheme can fail to achieve its expected convergence rate, providing a critical lesson in writing numerically robust code.", "problem": "Consider the one-dimensional periodic domain of length $L$, with spatial coordinate $x \\in [0,L)$ measured in radians, and a smooth scalar field $u(x)$. In the context of a conservative hyperbolic law, the spatial derivative of the flux $F(u)$ appears as $dF(u)/dx$. The objective is to study how floating-point round-off interacts with truncation error when the same discrete flux-gradient operator is computed through different algebraic rearrangements that are analytically identical, and to quantify the observed order of accuracy for each rearrangement across mesh refinements.\n\nStarting from the fundamental base:\n- A conservation law has the form $\\partial u/\\partial t + \\partial F(u)/\\partial x = 0$, where $F(u)$ is a smooth flux function.\n- For a smooth field $u(x)$, the spatial derivative of the flux $F(u)$ is $dF(u)/dx$, and for $F(u)=u^2/2$, one has $dF(u)/dx = u \\, du/dx$.\n- On a periodic grid with $N$ points and spacing $\\Delta x = L/N$, the central difference operator uses neighboring values at $x_{i-1}$ and $x_{i+1}$ to approximate a spatial derivative at $x_i$.\n\nYou must implement three computational rearrangements of the same central discrete flux-gradient operator for the flux $F(u) = u^2/2$ at grid points $x_i$ under periodic boundary conditions. Two of the rearrangements must be algebraically identical in exact arithmetic to the central difference of the flux values, but differ in their sequence of operations. A third rearrangement must still compute the same discrete operator, but use a numerically compensated way to form the needed pairwise sums and differences. Your program must:\n1. Use the test function $u(x) = U_0 + \\varepsilon \\sin(k x)$ with the angle $x$ in radians, for specified values of $(U_0,\\varepsilon,k)$.\n2. For each grid size $N$ in a refinement sequence, construct the grid, evaluate $u(x)$, compute the three rearrangements of the same discrete central flux-gradient operator, and compute the exact derivative $dF(u)/dx = u \\cdot du/dx$ using analytical differentiation of $u(x)$.\n3. For each rearrangement and each grid size $N$, compute the discrete $L^2$ error defined by\n$$\nE(N) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( D_i - \\frac{dF(u)}{dx}(x_i) \\right)^2 \\right)^{1/2},\n$$\nwhere $D_i$ is the approximation from the rearrangement at index $i$ and $\\Delta x = L/N$.\n4. Using all refinement levels in the test suite, estimate the measured order of accuracy $\\alpha$ for each rearrangement via a least-squares fit of $\\log(E(N))$ versus $\\log(\\Delta x)$; that is, fit $\\log(E) \\approx \\alpha \\log(\\Delta x) + C$ and report $\\alpha$.\n5. Aggregate the results for all test cases into a single line of output containing the measured orders of accuracy for the three rearrangements per test case.\n\nTest suite:\n- Domain length: $L = 2\\pi$ (radians).\n- Refinement sequence: $N \\in \\{64,128,256,512,1024,2048,4096,8192,16384,32768\\}$.\n- Four test cases of $(U_0,\\varepsilon,k)$:\n  - Case 1 (happy path): $(0.0, 1.0, 3)$.\n  - Case 2 (moderate cancellation): $(1.0, 10^{-2}, 3)$.\n  - Case 3 (severe cancellation): $(1.0, 10^{-12}, 3)$.\n  - Case 4 (high frequency): $(1.0, 10^{-2}, 500)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The outer list must contain one element per test case, and each element must be a list of three floating-point numbers corresponding to the measured orders of accuracy for the three rearrangements, in the fixed order of computation that you implement.\n- For example, the output format should resemble\n$$\n[\\,[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3]\\,],\n$$\nprinted as a single line with no spaces.\n\nAll angle quantities must be treated in radians. No physical units other than radians appear in this problem, and no conversion of units is required. The final output must be floats. The program must be complete, runnable without user input, and must adhere to the specified execution environment.", "solution": "The user-provided problem has been analyzed and validated. It is a well-posed and scientifically sound problem in the field of computational fluid dynamics and numerical analysis. The task is to investigate the effects of floating-point arithmetic on the accuracy of different but algebraically equivalent formulations of a finite difference operator.\n\nThe problem centers on computing the spatial derivative of a flux function, $\\frac{dF(u)}{dx}$, for $F(u)=\\frac{u^2}{2}$ on a one-dimensional periodic domain. The analytical derivative is given by the chain rule: $\\frac{dF}{dx} = \\frac{dF}{du}\\frac{du}{dx} = u \\frac{du}{dx}$. We are to approximate this derivative using a second-order central difference scheme applied to a discrete field $u_i = u(x_i)$ on a grid with spacing $\\Delta x$. The standard central difference of the flux $F_i = F(u_i)$ at grid point $x_i$ is given by:\n$$\nD_i = \\frac{F_{i+1} - F_{i-1}}{2\\Delta x}\n$$\nwhere the indices $i-1$ and $i+1$ refer to the neighboring grid points, handled with periodic boundary conditions. Substituting $F(u) = u^2/2$, we obtain the discrete operator:\n$$\nD_i = \\frac{u_{i+1}^2/2 - u_{i-1}^2/2}{2\\Delta x} = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}\n$$\nThis problem requires the implementation and comparison of three distinct computational rearrangements of this single discrete operator. In exact arithmetic, all three must be identical. Their numerical behavior, however, will differ due to the properties of floating-point arithmetic, particularly when dealing with the subtraction of nearly equal numbers (catastrophic cancellation).\n\nThe three chosen rearrangements are:\n1.  **Direct Flux Differencing (R1)**: This is the most straightforward evaluation of the formula, computed as $D_i = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}$. When $u$ contains a large constant component $U_0$ and a small perturbation $\\varepsilon$, such that $u \\approx U_0$, both $u_{i+1}^2$ and $u_{i-1}^2$ are large numbers close to $U_0^2$. Their subtraction can lead to a significant loss of relative precision, an effect known as catastrophic cancellation.\n\n2.  **Product Form (R2)**: This form exploits the algebraic identity $a^2-b^2 = (a+b)(a-b)$. The operator is computed as $D_i = \\frac{(u_{i+1} - u_{i-1})(u_{i+1} + u_{i-1})}{4\\Delta x}$. This rearrangement is numerically superior to R1 in the presence of a large mean value. The small difference $u_{i+1} - u_{i-1}$ is computed first, preserving the precision of the small-scale variation of $u$. This small difference is then multiplied by the well-behaved sum $u_{i+1} + u_{i-1}$.\n\n3.  **Compensated Form (R3)**: This method leverages the known constant part $U_0$ of the test function $u(x) = U_0 + \\varepsilon\\sin(kx)$. We define a perturbation field $v(x) = u(x) - U_0$. The flux difference $F_{i+1} - F_{i-1}$ is expanded analytically and then computed:\n    $$\n    F_{i+1} - F_{i-1} = \\frac{(U_0+v_{i+1})^2}{2} - \\frac{(U_0+v_{i-1})^2}{2} = U_0(v_{i+1}-v_{i-1}) + \\frac{v_{i+1}^2 - v_{i-1}^2}{2}\n    $$\n    This expression is algebraically equivalent to the original but is computed by first stripping the large constant part $U_0$ from $u_i$ to get $v_i$. All arithmetic operations are then performed on these smaller, better-conditioned numbers. The term $\\frac{v_{i+1}^2 - v_{i-1}^2}{2}$ is also computed using its product form $\\frac{(v_{i+1}-v_{i-1})(v_{i+1}+v_{i-1})}{2}$ for maximal robustness. This rearrangement is expected to be the most accurate, especially in cases designed to induce severe cancellation errors.\n\nThe numerical experiment proceeds as follows. For each of the four test cases $(U_0, \\varepsilon, k)$ and for each grid resolution $N$ in the specified refinement sequence, we perform these steps:\n1.  Construct the periodic grid $x_i$ for $i=0, \\dots, N-1$.\n2.  Evaluate the test function $u(x_i) = U_0 + \\varepsilon\\sin(kx_i)$ and its exact flux derivative $\\frac{dF}{dx}(x_i) = u(x_i) \\cdot (\\varepsilon k \\cos(kx_i))$.\n3.  Compute the three discrete derivative approximations $D_{1,i}, D_{2,i}, D_{3,i}$ for all $i$.\n4.  Calculate the discrete $L^2$ error, $E(N)$, for each rearrangement against the exact derivative.\n5.  After collecting the errors for all refinement levels, the order of accuracy $\\alpha$ for each rearrangement is estimated. This is done by performing a linear least-squares fit on the logarithm of the error versus the logarithm of the grid spacing: $\\log(E) = \\alpha \\log(\\Delta x) + C$. The slope of this fit is the measured order of accuracy, $\\alpha$.\n\nThe theoretical order of accuracy for a second-order central difference scheme is $2$, meaning the error $E$ should scale as $E \\propto (\\Delta x)^2$. We expect the measured order $\\alpha$ to be close to $2$ when the truncation error dominates. However, as $\\Delta x$ decreases, the truncation error shrinks, and eventually, the constant-in-magnitude round-off error becomes dominant. This \"error floor\" causes the total error to stop decreasing or even increase, spoiling the log-log linear relationship and reducing the measured order of accuracy $\\alpha$.\n\n- **Case 1 ($U_0=0$)**: All rearrangements are computationally similar. We expect $\\alpha \\approx 2$ for all three.\n- **Case 2 & 3 ($U_0=1.0$, small $\\varepsilon$)**: R1 is expected to perform poorly due to catastrophic cancellation, yielding a small or even zero $\\alpha$. R2 and R3 should be robust, showing $\\alpha \\approx 2$. The effect will be more pronounced in Case 3 due to the extremely small value of $\\varepsilon$.\n- **Case 4 (high frequency $k$)**: The truncation error, which scales with derivatives of the solution (and thus with $k$), will be much larger. It will dominate the round-off error over the entire range of $\\Delta x$. Consequently, all three methods are expected to show $\\alpha \\approx 2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 3),         # Case 1 (happy path)\n        (1.0, 1e-2, 3),        # Case 2 (moderate cancellation)\n        (1.0, 1e-12, 3),       # Case 3 (severe cancellation)\n        (1.0, 1e-2, 500),      # Case 4 (high frequency)\n    ]\n    \n    # Domain and refinement settings\n    L = 2.0 * np.pi\n    N_vals = np.array([64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768])\n\n    all_results = []\n    \n    for U0, eps, k in test_cases:\n        delta_x_vals = []\n        errors1, errors2, errors3 = [], [], []\n\n        for N in N_vals:\n            dx = L / N\n            x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n            delta_x_vals.append(dx)\n\n            # 1. Evaluate analytical fields\n            u = U0 + eps * np.sin(k * x)\n            dudx_exact = eps * k * np.cos(k * x)\n            dFdx_exact = u * dudx_exact\n\n            # Get neighbor values for central difference using periodic boundaries\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n\n            # 2. Compute the three numerical derivative rearrangements\n            # Rearrangement 1: Direct flux difference (prone to cancellation)\n            D1 = (u_p1**2 - u_m1**2) / (4.0 * dx)\n\n            # Rearrangement 2: Product of sum and difference (more robust)\n            D2 = (u_p1 - u_m1) * (u_p1 + u_m1) / (4.0 * dx)\n\n            # Rearrangement 3: Compensated form using known mean U0\n            # F(U0+v) = F(U0) + F'(U0)v + F''(U0)v^2/2 = F(U0) + U0*v + v^2/2\n            # F(i+1)-F(i-1) = U0*(v_p1-v_m1) + (v_p1^2-v_m1^2)/2\n            v_p1 = u_p1 - U0\n            v_m1 = u_m1 - U0\n            term1 = U0 * (v_p1 - v_m1)\n            term2 = (v_p1 - v_m1) * (v_p1 + v_m1) / 2.0\n            D3 = (term1 + term2) / (2.0 * dx)\n            \n            # 3. Compute L2 errors\n            err1 = np.sqrt(dx * np.sum((D1 - dFdx_exact)**2))\n            err2 = np.sqrt(dx * np.sum((D2 - dFdx_exact)**2))\n            err3 = np.sqrt(dx * np.sum((D3 - dFdx_exact)**2))\n            \n            errors1.append(err1)\n            errors2.append(err2)\n            errors3.append(err3)\n\n        # 4. Estimate order of accuracy via least-squares on log-log data\n        log_dx = np.log(np.array(delta_x_vals))\n        \n        alphas = []\n        for errors in [errors1, errors2, errors3]:\n            # Use only finite error values for the log-log fit, in case any error is zero.\n            errors_arr = np.array(errors, dtype=np.float64)\n            valid_indices = np.isfinite(errors_arr) & (errors_arr > 0)\n            \n            if np.sum(valid_indices) > 1:\n                log_err = np.log(errors_arr[valid_indices])\n                log_dx_fit = log_dx[valid_indices]\n                # polyfit returns [slope, intercept] for degree 1\n                alpha = np.polyfit(log_dx_fit, log_err, 1)[0]\n                alphas.append(alpha)\n            else:\n                # If fit is not possible (e.g., all errors are zero), alpha is ill-defined.\n                # A constant error results in alpha = 0.\n                alphas.append(0.0)\n                \n        all_results.append(alphas)\n\n    # Final print statement in the exact required format.\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```", "id": "3364188"}, {"introduction": "Building on the distinct concepts of truncation and round-off error, this final practice moves into the realm of time-dependent simulations, where these errors accumulate and interact in complex ways. You will implement a time-reversibility experiment for the linear advection equation, a classic technique for assessing the total numerical error in a conservative system without needing to know the exact solution [@problem_id:3364199]. By fitting the results to an error model that accounts for spatial truncation ($O(h^p)$), temporal truncation ($O(\\Delta t^q)$), and accumulated round-off ($O(\\sqrt{N}\\epsilon_{\\mathrm{mach}})$), you will practice a sophisticated verification technique used to diagnose and quantify the distinct sources of error in a full CFD simulation.", "problem": "You are to design and implement a time-reversibility experiment for inviscid linear advection within a periodic domain, quantify the error recovered after reversing time, and decompose this error into truncation and round-off contributions. The governing equation is the linear advection equation\n$$u_t + a\\,u_x = 0$$\non the periodic interval $[0,2\\pi]$ with advection speed $a>0$. Use the periodic initial condition\n$$u(x,0)=\\sin(x)+\\tfrac{1}{4}\\cos(3x)+\\tfrac{1}{10}\\sin(5x)$$\nwith angles measured in radians. Let the final time be $T=1$.\n\nImplement the spatial discretization and time integration using a single-step, second-order accurate Lax–Wendroff finite difference scheme with periodic boundary conditions. Let the uniform grid have $M$ points, grid spacing $h=2\\pi/M$, and the time step be $\\Delta t=T/N$ for a given number of steps $N$. Denote by $u^0$ the discrete initial state, integrate forward for $N$ steps to obtain $u^N$, then integrate backward for $N$ steps using the same scheme applied with negative time step $-\\Delta t$ to recover $u^{0,\\mathrm{rec}}$. Compute the discrete $L^2$-norm error at recovery as\n$$\nE = \\left(\\,h\\sum_{j=0}^{M-1}\\left(u^{0,\\mathrm{rec}}_j - u^0_j\\right)^2\\,\\right)^{1/2}.\n$$\n\nModel the recovered error $E$ as the sum of a truncation component and an accumulated round-off component. The truncation component follows the order-of-accuracy scalings $O(h^p)$ and $O(\\Delta t^q)$ with method orders $p=2$ and $q=2$. The accumulated round-off component follows the scaling $O(\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}})$ where $\\epsilon_{\\mathrm{mach}}$ is the machine epsilon of double-precision floating-point arithmetic. Using the set of test cases below, estimate coefficients $\\alpha$, $\\beta$, and $\\gamma$ in the linear model\n$$\nE \\approx \\alpha\\,h^p + \\beta\\,\\Delta t^q + \\gamma\\,\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}.\n$$\nPerform a least-squares fit over the provided test suite to determine $\\alpha$, $\\beta$, and $\\gamma$, and then, for each test case, report the decomposition into the truncation contribution $E_{\\mathrm{trunc}}=\\alpha\\,h^p+\\beta\\,\\Delta t^q$ and the accumulated round-off contribution $E_{\\mathrm{round}}=\\gamma\\,\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}$.\n\nFor each test case, compute and output the triple $[E, E_{\\mathrm{trunc}}, E_{\\mathrm{round}}]$ as real numbers. Your program should produce a single line of output containing the results as a comma-separated list of these triples enclosed in square brackets, for example, $[[e_1,t_1,r_1],[e_2,t_2,r_2],\\dots]$.\n\nUse the following test suite, which specifies $(a,M,N)$ for each case, with $a=1$ in all cases. Ensure the Courant–Friedrichs–Lewy (CFL) number $a\\,\\Delta t/h$ remains within a stable range for the chosen scheme.\n\n- Case $1$: $(a,M,N)=(1,128,200)$,\n- Case $2$: $(a,M,N)=(1,128,1000)$,\n- Case $3$: $(a,M,N)=(1,32,200)$,\n- Case $4$: $(a,M,N)=(1,512,200)$,\n- Case $5$: $(a,M,N)=(1,64,11)$.\n\nYour program must implement the described experiment and decomposition, with all angles in radians. The final output must be a single line formatted exactly as $[[E_1,E_{\\mathrm{trunc},1},E_{\\mathrm{round},1}],\\dots,[E_5,E_{\\mathrm{trunc},5},E_{\\mathrm{round},5}]]$, where each entry is a real number.", "solution": "The user's problem is first assessed for validity.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The one-dimensional linear advection equation, $u_t + a\\,u_x = 0$, with advection speed $a>0$.\n- **Domain**: A periodic interval $[0, 2\\pi]$.\n- **Initial Condition**: $u(x,0) = \\sin(x) + \\tfrac{1}{4}\\cos(3x) + \\tfrac{1}{10}\\sin(5x)$.\n- **Final Time**: $T=1$.\n- **Numerical Method**: A second-order accurate Lax–Wendroff finite difference scheme.\n- **Discretization**:\n    - A uniform grid with $M$ points.\n    - Grid spacing $h=2\\pi/M$.\n    - Number of time steps $N$.\n    - Time step size $\\Delta t = T/N$.\n- **Experiment Protocol**:\n    1. Discretize the initial condition to get $u^0$.\n    2. Integrate forward in time for $N$ steps to obtain $u^N$.\n    3. Starting from $u^N$, integrate backward in time for $N$ steps using a time step of $-\\Delta t$ to obtain the recovered state $u^{0,\\mathrm{rec}}$.\n- **Error Metric**: The discrete $L^2$-norm of the recovery error is defined as $E = \\left(\\,h\\sum_{j=0}^{M-1}\\left(u^{0,\\mathrm{rec}}_j - u^0_j\\right)^2\\,\\right)^{1/2}$.\n- **Error Model**: The total error $E$ is modeled as a sum of truncation and round-off components: $E \\approx \\alpha\\,h^p + \\beta\\,\\Delta t^q + \\gamma\\,\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}$.\n- **Model Parameters**: The orders of accuracy are given as $p=2$ and $q=2$. $\\epsilon_{\\mathrm{mach}}$ is the machine epsilon for double-precision floating-point arithmetic.\n- **Task**:\n    1. Perform a least-squares fit on a set of test cases to find the coefficients $\\alpha$, $\\beta$, and $\\gamma$.\n    2. Decompose the total error $E$ into a truncation part, $E_{\\mathrm{trunc}}=\\alpha\\,h^p+\\beta\\,\\Delta t^q$, and a round-off part, $E_{\\mathrm{round}}=\\gamma\\,\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}$.\n- **Test Suite**: A set of five test cases defined by $(a,M,N)$ triplets: $(1,128,200)$, $(1,128,1000)$, $(1,32,200)$, $(1,512,200)$, $(1,64,11)$.\n- **Output Format**: For each test case, provide the triple $[E, E_{\\mathrm{trunc}}, E_{\\mathrm{round}}]$ in a single comma-separated list of lists: $[[E_1, E_{\\mathrm{trunc},1}, E_{\\mathrm{round},1}],\\dots,[E_5, E_{\\mathrm{trunc},5}, E_{\\mathrm{round},5}]]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is well-grounded in the principles of numerical analysis for partial differential equations, specifically within computational fluid dynamics. It addresses the fundamental concepts of numerical stability, truncation error, and round-off error using standard methods (Lax-Wendroff scheme) and models.\n- **Well-Posed**: The linear advection equation with the specified periodic initial condition constitutes a well-posed problem. The numerical task is also well-posed. The Lax-Wendroff scheme is conditionally stable, and the provided test cases result in Courant–Friedrichs–Lewy (CFL) numbers within the stability limit of $|\\nu| \\le 1$. The least-squares problem for finding the three coefficients $(\\alpha, \\beta, \\gamma)$ is overdetermined with five data points, and the design matrix is full-rank, ensuring a unique solution.\n- **Objective**: The problem is stated with mathematical precision and contains no subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a standard numerical experiment that is scientifically sound, well-posed, and completely specified. A solution will be provided.\n\n### Solution\n\nThe solution to this problem involves several stages: implementing the numerical scheme for the time-reversibility experiment, collecting the error data, performing a least-squares fit to an error model, and finally decomposing the error for each case.\n\n**1. Numerical Scheme: Lax-Wendroff Method**\nThe governing equation is the linear advection equation, $u_t + a\\,u_x = 0$. The Lax-Wendroff scheme is a second-order accurate method in both time and space. It can be derived from a Taylor series expansion of $u(x, t+\\Delta t)$ in time:\n$$\nu(x, t+\\Delta t) = u(x,t) + \\Delta t u_t(x,t) + \\frac{\\Delta t^2}{2} u_{tt}(x,t) + O(\\Delta t^3)\n$$\nFrom the governing equation, we have $u_t = -a u_x$ and $u_{tt} = (-a u_x)_t = -a(u_t)_x = -a(-a u_x)_x = a^2 u_{xx}$. Substituting these into the Taylor expansion gives:\n$$\nu(x, t+\\Delta t) = u(x,t) - a \\Delta t u_x(x,t) + \\frac{a^2 \\Delta t^2}{2} u_{xx}(x,t) + O(\\Delta t^3)\n$$\nWe discretize the spatial derivatives using second-order central differences on a uniform grid $x_j = jh$ with spacing $h=2\\pi/M$. Let $u_j^n \\approx u(x_j, n\\Delta t)$.\n$$\nu_x(x_j, n\\Delta t) \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2h}\n$$\n$$\nu_{xx}(x_j, n\\Delta t) \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2}\n$$\nSubstituting these into the time-expanded equation yields the Lax-Wendroff update rule:\n$$\nu_j^{n+1} = u_j^n - \\frac{a \\Delta t}{2h}(u_{j+1}^n - u_{j-1}^n) + \\frac{a^2 \\Delta t^2}{2h^2}(u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\nLetting $\\nu = a \\Delta t/h$ be the CFL number, we can write the scheme in a compact stencil form:\n$$\nu_j^{n+1} = \\frac{\\nu(\\nu-1)}{2} u_{j+1}^n + (1-\\nu^2) u_j^n + \\frac{\\nu(\\nu+1)}{2} u_{j-1}^n\n$$\nThis scheme is stable for $|\\nu| \\le 1$. Periodic boundary conditions are enforced by ensuring that for a grid with indices $j=0, \\dots, M-1$, the neighbor of $j=0$ at index $j-1$ is $j=M-1$, and the neighbor of $j=M-1$ at index $j+1$ is $j=0$.\n\n**2. Time-Reversibility Experiment**\nThe experiment consists of a forward integration followed by a backward integration.\n- **Forward Integration**: Starting with the discrete initial condition $u^0$, we apply the Lax-Wendroff scheme for $N$ steps with a positive time step $\\Delta t$, resulting in a CFL number $\\nu = a\\Delta t/h$. This yields the state $u^N$.\n- **Backward Integration**: Starting from $u^N$, we integrate for $N$ steps using a negative time step, $-\\Delta t$. This new CFL number is $\\nu' = a(-\\Delta t)/h = -\\nu$. The stencil for the backward step is obtained by substituting $\\nu'$ into the scheme formula. This is equivalent to reversing the direction of advection. The final state is the recovered initial state, $u^{0, \\mathrm{rec}}$.\n\nIn the absence of numerical errors (both truncation and round-off), the scheme would be perfectly reversible, and we would find $u^{0, \\mathrm{rec}} = u^0$. The difference $u^{0, \\mathrm{rec}} - u^0$ quantifies the accumulated numerical error. The total error is computed using the specified discrete $L^2$-norm:\n$$\nE = \\left(\\,h\\sum_{j=0}^{M-1}\\left(u^{0,\\mathrm{rec}}_j - u^0_j\\right)^2\\,\\right)^{1/2}\n$$\n\n**3. Error Model and Parameter Estimation**\nThe problem posits that the total error $E$ can be modeled as the sum of three components:\n$$\nE \\approx \\alpha\\,h^2 + \\beta\\,\\Delta t^2 + \\gamma\\,\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}\n$$\n- The $h^2$ term represents a second-order spatial truncation error.\n- The $\\Delta t^2$ term represents a second-order temporal truncation error.\n- The $\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}$ term models the accumulation of round-off error, which behaves like a random walk over $N$ steps, with each step contributing an error of size $\\epsilon_{\\mathrm{mach}}$ (machine epsilon).\n\nTo find the unknown coefficients $\\alpha, \\beta, \\gamma$, we run the experiment for the five given test cases. For each case $i \\in \\{1, \\dots, 5\\}$, we compute the total error $E_i$ and the values of the basis functions: $x_{i,1} = h_i^2$, $x_{i,2} = \\Delta t_i^2$, and $x_{i,3} = \\sqrt{N_i}\\,\\epsilon_{\\mathrm{mach}}$. This creates an overdetermined system of linear equations:\n$$\nA \\mathbf{c} \\approx \\mathbf{b}\n$$\nwhere $\\mathbf{c} = [\\alpha, \\beta, \\gamma]^T$, $\\mathbf{b} = [E_1, \\dots, E_5]^T$, and $A$ is the $5 \\times 3$ design matrix whose $i$-th row is $[x_{i,1}, x_{i,2}, x_{i,3}]$.\nThe vector $\\mathbf{c}$ is found by solving this system in the least-squares sense, i.e., finding the $\\mathbf{c}$ that minimizes $\\|A \\mathbf{c} - \\mathbf{b}\\|_2$. This is a standard procedure available in numerical libraries.\n\nOnce the coefficients $\\alpha, \\beta, \\gamma$ are determined, the total error for each case is decomposed into its truncation and round-off components:\n$$\nE_{\\mathrm{trunc}} = \\alpha h^2 + \\beta \\Delta t^2\n$$\n$$\nE_{\\mathrm{round}} = \\gamma \\sqrt{N} \\epsilon_{\\mathrm{mach}}\n$$\nWe then report the triple $[E, E_{\\mathrm{trunc}}, E_{\\mathrm{round}}]$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a time-reversibility experiment for the linear\n    advection equation, and decomposes the recovered error into truncation and\n    round-off components.\n    \"\"\"\n    # Define constants and test cases from the problem statement.\n    T = 1.0\n    EPS_MACH = np.finfo(float).eps\n    \n    test_cases = [\n        (1, 128, 200),  # Case 1\n        (1, 128, 1000), # Case 2\n        (1, 32, 200),   # Case 3\n        (1, 512, 200),  # Case 4\n        (1, 64, 11),    # Case 5\n    ]\n\n    def lw_step(u, nu):\n        \"\"\"\n        Performs a single time step using the Lax-Wendroff scheme for\n        u_t + a*u_x = 0, vectorized for periodic boundary conditions.\n\n        Args:\n            u (np.ndarray): The solution vector at the current time step.\n            nu (float): The Courant-Friedrichs-Lewy (CFL) number.\n\n        Returns:\n            np.ndarray: The solution vector at the next time step.\n        \"\"\"\n        # Coefficients for the stencil from the derivation\n        # u_j^{n+1} = c_{j+1}*u_{j+1} + c_j*u_j + c_{j-1}*u_{j-1}\n        # c_{j-1} = nu*(nu+1)/2, corresponding to np.roll(u, 1)\n        # c_{j+1} = nu*(nu-1)/2, corresponding to np.roll(u, -1)\n        c_m1 = nu * (nu + 1.0) / 2.0\n        c_0 = 1.0 - nu**2\n        c_p1 = nu * (nu - 1.0) / 2.0\n        \n        u_new = c_m1 * np.roll(u, 1) + c_0 * u + c_p1 * np.roll(u, -1)\n        return u_new\n\n    measured_errors = []\n    design_matrix_rows = []\n\n    for a, M, N in test_cases:\n        # Discretization parameters\n        h = 2.0 * np.pi / M\n        dt = T / N\n\n        # Create grid and initial condition\n        x = np.linspace(0, 2.0 * np.pi, M, endpoint=False)\n        u0 = np.sin(x) + 0.25 * np.cos(3.0 * x) + 0.1 * np.sin(5.0 * x)\n\n        # Time-reversibility experiment\n        # 1. Forward integration\n        u_current = u0.copy()\n        nu_fwd = a * dt / h\n        for _ in range(N):\n            u_current = lw_step(u_current, nu_fwd)\n        u_N = u_current\n\n        # 2. Backward integration\n        u_current = u_N.copy()\n        nu_bwd = a * (-dt) / h\n        for _ in range(N):\n            u_current = lw_step(u_current, nu_bwd)\n        u0_rec = u_current\n        \n        # 3. Calculate L2 error\n        error = np.sqrt(h * np.sum((u0_rec - u0)**2))\n        measured_errors.append(error)\n\n        # 4. Assemble row for the design matrix for the least-squares fit\n        row = [h**2, dt**2, np.sqrt(N) * EPS_MACH]\n        design_matrix_rows.append(row)\n\n    # Perform least-squares fit to find coefficients alpha, beta, gamma\n    A = np.array(design_matrix_rows)\n    b = np.array(measured_errors)\n    \n    coeffs, residuals, rank, singular_values = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = coeffs\n\n    # Decompose error for each test case\n    results = []\n    for i, (a, M, N) in enumerate(test_cases):\n        h = 2.0 * np.pi / M\n        dt = T / N\n        \n        total_error = measured_errors[i]\n        \n        # Truncation error component\n        trunc_error = alpha * (h**2) + beta * (dt**2)\n        \n        # Round-off error component\n        roundoff_error = gamma * np.sqrt(N) * EPS_MACH\n        \n        results.append([total_error, trunc_error, roundoff_error])\n        \n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([f\"[{e},{t},{r}]\" for e, t, r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3364199"}]}