{"hands_on_practices": [{"introduction": "In multiphysics simulations using partitioned schemes, the coupled system of equations is solved iteratively. Before assessing the overall discretization error, we must first ensure this algebraic iteration converges. This exercise [@problem_id:3504785] provides a fundamental analysis of this process for a model thermo-mechanical problem. By deriving the spectral radii, $\\rho$, of the Block-Jacobi and Block-Gauss–Seidel error-propagation matrices, you will gain insight into what controls the convergence rate and why one scheme might be preferred over another.", "problem": "A one-dimensional linear thermoelastic rod of length $L$ and cross-sectional area $A$ is modeled under small strain and small temperature rise about a reference absolute temperature $\\theta_{0}$. The rod is clamped at the left end and axially displaced by $u$ at the right end; the temperature field is assumed uniform and represented by a single degree of freedom $T$. The mechanical balance is quasi-static (no inertia), and the thermal balance uses Fourier conduction with heat capacity. Consider one backward (implicit) Euler time step of size $\\Delta t$ from time $t^{n}$ to $t^{n+1}$, and a single linear two-node bar in a single degree-of-freedom reduction for both mechanics and heat. The resulting monolithic linear system for the unknowns $(u^{n+1}, T^{n+1})$ takes the block form\n$$\n\\begin{pmatrix}\nK  -C \\\\\nD_{\\mathrm{eff}}  H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\\nr_{T}\n\\end{pmatrix},\n$$\nwith\n- $K = E A / L$ the axial stiffness,\n- $H = c \\rho A L / \\Delta t + \\kappa A / L$ the thermal backward Euler effective capacity-plus-conductance,\n- $C = E A \\alpha_{\\mathrm{th}}$ the thermoelastic thermal load coefficient entering the mechanical equation,\n- $D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$ the effective thermoelastic coupling entering the thermal equation after time discretization,\nwhere $E$ is Young’s modulus, $\\alpha_{\\mathrm{th}}$ is the coefficient of thermal expansion, $\\kappa$ is the thermal conductivity, $c$ is the specific heat, and $\\rho$ is the mass density. Assume the right-hand side $(r_{u}, r_{T})$ is bounded.\n\nTwo partitioned fixed-point strategies are considered to solve this coupled system:\n- Block-Jacobi (simultaneous) partitioned iteration: at iteration $k+1$, solve the mechanical and thermal subproblems using, respectively, $T^{k}$ and $u^{k}$ on the right-hand sides.\n- Block-Gauss–Seidel (sequential) partitioned iteration: at iteration $k+1$, update $u^{k+1}$ from the mechanical subproblem using $T^{k}$, then update $T^{k+1}$ from the thermal subproblem using $u^{k+1}$.\n\nTasks:\n1) Starting from the definitions of the two partitioned iterations and the monolithic block system above, derive the linear error propagation mappings for the iteration errors $e_{u}^{k} = u^{k} - u^{\\star}$ and $e_{T}^{k} = T^{k} - T^{\\star}$, where $(u^{\\star}, T^{\\star})$ solves the monolithic system. Then, using only linear algebra and the definition of spectral radius, express the spectral radii $\\rho_{\\mathrm{J}}$ and $\\rho_{\\mathrm{GS}}$ of the Block-Jacobi and Block-Gauss–Seidel error propagation matrices in terms of $K$, $H$, $C$, and $D_{\\mathrm{eff}}$.\n2) Using the physically consistent parameters\n- $E = 210 \\times 10^{9}$, $A = 10^{-4}$, $L = 1$, $\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$,\n- $\\kappa = 45$, $c = 450$, $\\rho = 7800$, $\\theta_{0} = 293$, $\\Delta t = 1$,\ncompute $K$, $H$, $C$, and $D_{\\mathrm{eff}}$ and then evaluate the numerical values of $\\rho_{\\mathrm{J}}$ and $\\rho_{\\mathrm{GS}}$.\n\nAnswer specification:\n- Provide your final answer as the ordered pair $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$.\n- Round both $\\rho_{\\mathrm{J}}$ and $\\rho_{\\mathrm{GS}}$ to four significant figures.\n- The final answer is dimensionless and must be reported without units.", "solution": "The problem is first validated by extracting all given information and checking for scientific consistency, completeness, and clarity.\n\n## Problem Validation\n\n### Step 1: Extract Givens\n- **System**: One-dimensional linear thermoelastic rod of length $L$ and area $A$.\n- **Assumptions**: Small strain, small temperature rise about $\\theta_{0}$, quasi-static mechanics, Fourier conduction with heat capacity.\n- **Discretization**: Single two-node linear element, one degree of freedom for displacement ($u$) and one for temperature ($T$). Single backward Euler time step of size $\\Delta t$.\n- **Monolithic System**:\n$$\n\\begin{pmatrix}\nK  -C \\\\\nD_{\\mathrm{eff}}  H\n\\end{pmatrix}\n\\begin{pmatrix}\nu^{n+1} \\\\\nT^{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nr_{u} \\\\\nr_{T}\n\\end{pmatrix}\n$$\n- **Coefficient Definitions**:\n  - Stiffness: $K = E A / L$\n  - Thermal effective matrix: $H = c \\rho A L / \\Delta t + \\kappa A / L$\n  - Mechanical coupling: $C = E A \\alpha_{\\mathrm{th}}$\n  - Thermal coupling: $D_{\\mathrm{eff}} = \\theta_{0} \\alpha_{\\mathrm{th}} E A / \\Delta t$\n- **Physical Parameters**:\n  - Young's modulus: $E = 210 \\times 10^{9}$\n  - Area: $A = 10^{-4}$\n  - Length: $L = 1$\n  - Thermal expansion coefficient: $\\alpha_{\\mathrm{th}} = 1.2 \\times 10^{-5}$\n  - Thermal conductivity: $\\kappa = 45$\n  - Specific heat: $c = 450$\n  - Mass density: $\\rho = 7800$\n  - Reference temperature: $\\theta_{0} = 293$\n  - Time step: $\\Delta t = 1$\n- **Partitioned Schemes**:\n  - Block-Jacobi: $u^{k+1}$ and $T^{k+1}$ solved using $u^k$ and $T^k$ from previous iteration.\n  - Block-Gauss-Seidel: $u^{k+1}$ solved using $T^k$, then $T^{k+1}$ solved using the new $u^{k+1}$.\n- **Tasks**:\n  1. Derive expressions for the spectral radii $\\rho_{\\mathrm{J}}$ and $\\rho_{\\mathrm{GS}}$ of the error propagation matrices.\n  2. Compute the numerical values of $\\rho_{\\mathrm{J}}$ and $\\rho_{\\mathrm{GS}}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard, simplified model of linear thermoelasticity, a staple in computational multiphysics. The governing equations, coefficient definitions, and physical parameters are consistent with established principles of continuum mechanics and heat transfer. The discretization methods (FEM in space, backward Euler in time) are standard. The parameters provided are realistic for steel. The problem is self-contained, well-posed, and objective. It does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n## Solution\n\nLet the exact solution to the monolithic system be $(u^{\\star}, T^{\\star})$. This solution satisfies:\n$$ K u^{\\star} - C T^{\\star} = r_{u} $$\n$$ D_{\\mathrm{eff}} u^{\\star} + H T^{\\star} = r_{T} $$\nThe iteration errors at step $k$ are defined as $e_{u}^{k} = u^{k} - u^{\\star}$ and $e_{T}^{k} = T^{k} - T^{\\star}$.\n\n### Task 1: Derivation of Spectral Radii\n\n**Block-Jacobi Partitioned Iteration**\n\nThe Block-Jacobi scheme is defined by solving the diagonal blocks independently, using values from the previous iteration $k$ for the off-diagonal coupling terms:\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k} $$\nSubtracting the exact solution equations from the iteration equations yields the error propagation equations:\n$$ K (u^{k+1} - u^{\\star}) = C (T^{k} - T^{\\star}) \\implies K e_{u}^{k+1} = C e_{T}^{k} $$\n$$ H (T^{k+1} - T^{\\star}) = -D_{\\mathrm{eff}} (u^{k} - u^{\\star}) \\implies H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k} $$\nArranging these into a system for the error vector $\\mathbf{e}^{k+1} = \\begin{pmatrix} e_{u}^{k+1}  e_{T}^{k+1} \\end{pmatrix}^T$:\n$$ e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} e_{u}^{k} $$\nThe error propagation is governed by the matrix relationship $\\mathbf{e}^{k+1} = G_{\\mathrm{J}} \\mathbf{e}^{k}$, where $G_{\\mathrm{J}}$ is the Block-Jacobi iteration matrix:\n$$ G_{\\mathrm{J}} = \\begin{pmatrix} 0  K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}}  0 \\end{pmatrix} $$\nThe spectral radius $\\rho_{\\mathrm{J}}$ is the maximum absolute value of the eigenvalues $\\lambda$ of $G_{\\mathrm{J}}$. The eigenvalues are found from the characteristic equation $\\det(G_{\\mathrm{J}} - \\lambda I) = 0$:\n$$ \\det \\begin{pmatrix} -\\lambda  K^{-1} C \\\\ -H^{-1} D_{\\mathrm{eff}}  -\\lambda \\end{pmatrix} = (-\\lambda)(-\\lambda) - (K^{-1} C)(-H^{-1} D_{\\mathrm{eff}}) = \\lambda^2 + K^{-1} H^{-1} C D_{\\mathrm{eff}} = 0 $$\n$$ \\lambda^2 = - \\frac{C D_{\\mathrm{eff}}}{K H} $$\nSince all coefficients $K, H, C, D_{\\mathrm{eff}}$ are positive scalars, the eigenvalues are purely imaginary:\n$$ \\lambda = \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\nThe spectral radius is the magnitude of these eigenvalues:\n$$ \\rho_{\\mathrm{J}} = \\left| \\pm i \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} \\right| = \\sqrt{\\frac{C D_{\\mathrm{eff}}}{K H}} $$\n\n**Block-Gauss-Seidel Partitioned Iteration**\n\nThe Block-Gauss-Seidel scheme updates the variables sequentially. First, $u^{k+1}$ is computed using $T^k$, and then this new value $u^{k+1}$ is immediately used to compute $T^{k+1}$:\n$$ K u^{k+1} = r_{u} + C T^{k} $$\n$$ H T^{k+1} = r_{T} - D_{\\mathrm{eff}} u^{k+1} $$\nAgain, we subtract the exact solution equations to find the error propagation:\n$$ K e_{u}^{k+1} = C e_{T}^{k} \\implies e_{u}^{k+1} = K^{-1} C e_{T}^{k} $$\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} e_{u}^{k+1} $$\nSubstitute the expression for $e_{u}^{k+1}$ from the first equation into the second:\n$$ H e_{T}^{k+1} = -D_{\\mathrm{eff}} (K^{-1} C e_{T}^{k}) \\implies e_{T}^{k+1} = -H^{-1} D_{\\mathrm{eff}} K^{-1} C e_{T}^{k} $$\nThe error propagation equations can be written in matrix form as $\\mathbf{e}^{k+1} = G_{\\mathrm{GS}} \\mathbf{e}^{k}$:\n$$ \\begin{pmatrix} e_{u}^{k+1} \\\\ e_{T}^{k+1} \\end{pmatrix} = \\begin{pmatrix} 0  K^{-1} C \\\\ 0  -H^{-1} D_{\\mathrm{eff}} K^{-1} C \\end{pmatrix} \\begin{pmatrix} e_{u}^{k} \\\\ e_{T}^{k} \\end{pmatrix} $$\nThe iteration matrix is:\n$$ G_{\\mathrm{GS}} = \\begin{pmatrix} 0  K^{-1} C \\\\ 0  - \\frac{C D_{\\mathrm{eff}}}{K H} \\end{pmatrix} $$\nSince $G_{\\mathrm{GS}}$ is an upper triangular matrix, its eigenvalues are its diagonal entries: $\\lambda_1 = 0$ and $\\lambda_2 = - \\frac{C D_{\\mathrm{eff}}}{K H}$.\nThe spectral radius $\\rho_{\\mathrm{GS}}$ is the maximum of their absolute values:\n$$ \\rho_{\\mathrm{GS}} = \\max \\left( |0|, \\left|- \\frac{C D_{\\mathrm{eff}}}{K H}\\right| \\right) = \\frac{C D_{\\mathrm{eff}}}{K H} $$\nNote that $\\rho_{\\mathrm{GS}} = (\\rho_{\\mathrm{J}})^2$, a known result for this class of problems.\n\n### Task 2: Numerical Evaluation\n\nFirst, we compute the numerical values of the coefficients using the provided physical parameters in SI units.\n- $K = \\frac{E A}{L} = \\frac{(210 \\times 10^{9}) (10^{-4})}{1} = 2.1 \\times 10^{7}$\n- $C = E A \\alpha_{\\mathrm{th}} = (210 \\times 10^{9}) (10^{-4}) (1.2 \\times 10^{-5}) = 252$\n- $D_{\\mathrm{eff}} = \\frac{\\theta_{0} \\alpha_{\\mathrm{th}} E A}{\\Delta t} = \\frac{293 \\times (1.2 \\times 10^{-5}) (210 \\times 10^{9}) (10^{-4})}{1} = 293 \\times 252 = 73836$\n- $H = \\frac{c \\rho A L}{\\Delta t} + \\frac{\\kappa A}{L} = \\frac{450 \\times 7800 \\times 10^{-4} \\times 1}{1} + \\frac{45 \\times 10^{-4}}{1} = 351 + 0.0045 = 351.0045$\n\nNext, we compute the dimensionless coupling parameter $\\gamma = \\frac{C D_{\\mathrm{eff}}}{K H}$:\n$$ \\gamma = \\frac{252 \\times 73836}{(2.1 \\times 10^{7}) \\times 351.0045} = \\frac{18606672}{7371094500} \\approx 0.002524263 $$\nNow we can compute the spectral radii:\n- $\\rho_{\\mathrm{GS}} = \\gamma \\approx 0.002524263$\n- $\\rho_{\\mathrm{J}} = \\sqrt{\\gamma} \\approx \\sqrt{0.002524263} \\approx 0.050242048$\n\nRounding to four significant figures as requested:\n- $\\rho_{\\mathrm{GS}} = 0.002524$\n- $\\rho_{\\mathrm{J}} = 0.05024$\n\nThe final answer is the ordered pair $(\\rho_{\\mathrm{J}}, \\rho_{\\mathrm{GS}})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.05024  0.002524\n\\end{pmatrix}\n}\n$$", "id": "3504785"}, {"introduction": "Verifying that a numerical solution's error $E$ converges to zero at the expected rate, such as $E \\propto h^p$ for grid size $h$, is a cornerstone of code verification. This coding exercise [@problem_id:3504784] guides you through this process using the Method of Manufactured Solutions. It reveals a crucial pitfall where iteration error, controlled by a tolerance $\\tau$, can mask the true discretization error, causing the observed convergence order to be less than the theoretical order $p$. This practice demonstrates how to design a numerical experiment to separate these distinct error sources.", "problem": "Consider a one-dimensional, steady, two-field, linearly coupled reaction–diffusion system on the spatial interval $[0,1]$ with homogeneous Dirichlet boundary conditions. The unknown fields are $u(x)$ and $v(x)$, and the governing equations are\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x), \\quad -\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x),\n$$\nwith $u(0)=u(1)=0$ and $v(0)=v(1)=0$. Assume a manufactured exact solution $u_e(x) = \\sin(\\pi x)$ and $v_e(x) = \\sin(2\\pi x)$. Let the positive reaction coefficients be $a=1$ and $c=2$, and the coupling coefficients be $b=0.1$ and $d=0.2$. The source terms are constructed so that the manufactured solution satisfies the continuous equations:\n$$\ns_u(x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x), \\quad s_v(x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x).\n$$\n\nYou will discretize the spatial domain using a uniform grid with $N$ points (including boundaries), grid spacing $h=1/(N-1)$, and second-order central differences for the diffusion operator. For interior grid points, the discrete operator approximating $-u''$ (and analogously $-v''$) is\n$$\n\\frac{2 u_i - u_{i-1} - u_{i+1}}{h^2},\n$$\nand the reaction terms are treated pointwise. The resulting uncoupled discrete operators for $u$ and $v$ are tridiagonal and strictly diagonally dominant. To treat coupling, use a partitioned Gauss–Seidel iteration at the algebraic level: given an iterate $(u^{(k)}, v^{(k)})$ on the interior grid, compute the next iterate by solving the following two linear systems in sequence,\n$$\nA\\,u^{(k+1)} = s_u - b\\,v^{(k)}, \\quad C\\,v^{(k+1)} = s_v - d\\,u^{(k+1)},\n$$\nwhere $A$ and $C$ are the discrete uncoupled operators for $u$ and $v$, and $s_u, s_v$ are the discrete source vectors obtained by sampling the analytical $s_u(x), s_v(x)$ at interior grid points. Initialize $u^{(0)}=0$ and $v^{(0)}=0$ on the interior. Terminate iterations based on a tolerance on the combined change between successive iterates,\n$$\n\\| (u^{(k+1)} - u^{(k)}, v^{(k+1)} - v^{(k)}) \\|_{2,h} \\le \\mathrm{tol},\n$$\nwhere the discrete $L^2$ norm on the interior grid is defined as\n$$\n\\| (x,y) \\|_{2,h} = \\left( h \\sum_{i} x_i^2 + h \\sum_{i} y_i^2 \\right)^{1/2}.\n$$\n\nThe central questions are about discretization error, consistency, and convergence, and about how coupling iteration error can mask asymptotic discretization error. The total numerical error (relative to the continuous manufactured solution sampled on the grid) can be thought of as the sum of two contributions for sufficiently small errors:\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol}),\n$$\nwhere $E_{\\mathrm{disc}}(h)$ is due to spatial discretization (with expected order $p=2$ for second-order central differences under sufficient smoothness), and $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ is due to premature termination of the coupling iteration. If $\\mathrm{tol}$ is fixed (not scaled with $h$), then as $h \\to 0$, $E_{\\mathrm{disc}}(h) \\to 0$ while $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ stays approximately constant, masking the discretization error and destroying the observed asymptotic rate.\n\nTask: Implement a program that carries out numerical experiments to quantify and separate these error contributions. For each run, compute the discrete $L^2$ errors of $u$ and $v$ combined:\n$$\nE_{\\mathrm{tot}}(h,\\mathrm{tol}) = \\left( h \\sum_{i} \\left(u^{(k_{\\mathrm{final})}}_i - u_e(x_i)\\right)^2 + h \\sum_{i} \\left(v^{(k_{\\mathrm{final})}}_i - v_e(x_i)\\right)^2 \\right)^{1/2}.\n$$\nAlso, when comparing two runs at the same $h$, estimate the coupling iteration error by\n$$\nE_{\\mathrm{iter,est}}(h) = \\left( h \\sum_{i} \\left(u_{\\mathrm{loose},i} - u_{\\mathrm{tight},i}\\right)^2 + h \\sum_{i} \\left(v_{\\mathrm{loose},i} - v_{\\mathrm{tight},i}\\right)^2 \\right)^{1/2},\n$$\nwhere “tight” denotes a run with an extremely small tolerance and “loose” denotes a run with a fixed tolerance.\n\nDesign a test suite comprising three runs, each evaluated on three grid resolutions $N\\in\\{33,65,129\\}$:\n\n- Case A (tight tolerance, near-monolithic convergence): $\\mathrm{tol} = 10^{-12}$ and maximum iterations $500$.\n- Case B (loose tolerance, masking expected): $\\mathrm{tol} = 10^{-4}$ and maximum iterations $500$.\n- Case C (severely under-iterated, edge case): $\\mathrm{tol}$ arbitrary and maximum iterations $1$.\n\nFor each case, compute the total error on each grid and then estimate the observed order of accuracy $p_{\\mathrm{obs}}$ using the two finest grids:\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)},\n$$\nwhere $h_2=1/(65-1)$ and $h_3=1/(129-1)$. Additionally, for Case B on the finest grid ($N=129$), compute the ratio\n$$\nr_{\\mathrm{fine}} = \\frac{E_{\\mathrm{iter,est}}(h_3)}{E_{\\mathrm{tot}}(h_3,\\mathrm{tol}_{\\mathrm{loose}})}.\n$$\n\nYour program must produce a single line of output containing a comma-separated list in square brackets with the following six entries:\n- The observed order $p_{\\mathrm{obs}}$ for Case A using the two finest grids, as a floating-point number.\n- The observed order $p_{\\mathrm{obs}}$ for Case B using the two finest grids, as a floating-point number.\n- The observed order $p_{\\mathrm{obs}}$ for Case C using the two finest grids, as a floating-point number.\n- The ratio $r_{\\mathrm{fine}}$ for Case B at $N=129$, as a floating-point number in $[0,1]$.\n- A boolean indicating whether the tight-tolerance observed order lies in $[1.8,2.2]$.\n- A boolean indicating whether masking is observed in Case B, defined as simultaneously $p_{\\mathrm{obs}}1.0$ and $r_{\\mathrm{fine}}0.5$.\n\nAll quantities are dimensionless, so no physical units are required. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[p_A,p_B,p_C,r_{\\mathrm{fine}},\\mathrm{bool}_A,\\mathrm{bool}_B]$). The program must be self-contained and run without any inputs or external files. The numerical experiments must adhere to the described discretization and coupling iteration procedure exactly, and use the specified test suite parameters verbatim.", "solution": "The user provided a valid, well-posed problem. This response provides the solution.\n\n### 1. Theoretical Framework\n\nThe problem requires a numerical investigation of a coupled, one-dimensional, steady-state reaction-diffusion system. The governing partial differential equations (PDEs) for the two fields, $u(x)$ and $v(x)$, on the domain $x \\in [0,1]$ are:\n$$\n-\\,u''(x) + a\\,u(x) + b\\,v(x) = s_u(x)\n$$\n$$\n-\\,v''(x) + c\\,v(x) + d\\,u(x) = s_v(x)\n$$\nThese are subject to homogeneous Dirichlet boundary conditions, $u(0)=u(1)=0$ and $v(0)=v(1)=0$. The coefficients are given as $a=1$, $c=2$, $b=0.1$, and $d=0.2$.\n\nTo facilitate a quantitative error analysis, the Method of Manufactured Solutions is employed. We prescribe exact analytical solutions, $u_e(x) = \\sin(\\pi x)$ and $v_e(x) = \\sin(2\\pi x)$, which conveniently satisfy the boundary conditions. The source terms, $s_u(x)$ and $s_v(x)$, are then derived by substituting these exact solutions back into the governing equations:\n$$\ns_u(x) = -(-\\pi^2 \\sin(\\pi x)) + a \\sin(\\pi x) + b \\sin(2\\pi x) = \\pi^2 \\sin(\\pi x) + a \\sin(\\pi x) + b \\sin(2\\pi x)\n$$\n$$\ns_v(x) = -(-(2\\pi)^2 \\sin(2\\pi x)) + c \\sin(2\\pi x) + d \\sin(\\pi x) = (2\\pi)^2 \\sin(2\\pi x) + c \\sin(2\\pi x) + d \\sin(\\pi x)\n$$\nWith these source terms, the continuous problem has a known, unique solution, providing a benchmark against which our numerical solution can be compared.\n\n### 2. Numerical Discretization and Solution Strategy\n\nThe continuous domain is discretized using a uniform grid of $N$ points, $x_i = i \\cdot h$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $h=1/(N-1)$. The interior grid points are indexed from $i=1$ to $N-2$.\n\nThe second derivative terms, $-u''$ and $-v''$, are approximated using a second-order accurate central finite difference scheme. For an interior grid point $x_i$, this approximation is:\n$$\n-u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2}\n$$\nwhere $u_i$ is the numerical approximation of $u(x_i)$. Applying this to the first PDE at each interior point $i$ yields a system of linear equations:\n$$\n\\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} + a u_i + b v_i = (s_u)_i\n$$\nRearranging terms for the $u$ field allows us to express the discrete system in matrix form. Let $\\mathbf{u}$ be the vector of unknown values $[u_1, u_2, \\dots, u_{N-2}]^T$. The uncoupled operator for $u$ can be written as a matrix $A$ such that the equations become $A\\mathbf{u} + b\\mathbf{v} = \\mathbf{s}_u$. The matrix $A$ is an $(N-2) \\times (N-2)$ tridiagonal matrix with diagonal entries $(2/h^2 + a)$ and off-diagonal entries $-1/h^2$. Since the reaction coefficient $a=1$ is positive, the matrix $A$ is strictly diagonally dominant, which guarantees its invertibility and the stability of numerical solvers. The same construction yields a matrix $C$ for the $v$ field, which is also tridiagonal and strictly diagonally dominant as $c=2 > 0$.\n\nThe fully coupled discrete system is a block matrix system:\n$$\n\\begin{pmatrix} A  \\mathrm{diag}(b) \\\\ \\mathrm{diag}(d)  C \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\mathbf{v} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{s}_u \\\\ \\mathbf{s}_v \\end{pmatrix}\n$$\nTo solve this system, a partitioned (or block) Gauss-Seidel iterative scheme is adopted. Starting with an initial guess, typically $\\mathbf{u}^{(0)}=\\mathbf{0}$ and $\\mathbf{v}^{(0)}=\\mathbf{0}$, the scheme iterates for $k=0, 1, 2, \\dots$ by solving two smaller, uncoupled systems in sequence:\n1.  **Solve for** $\\mathbf{u}^{(k+1)}$: $A\\,\\mathbf{u}^{(k+1)} = \\mathbf{s}_u - b\\,\\mathbf{v}^{(k)}$\n2.  **Solve for** $\\mathbf{v}^{(k+1)}$: $C\\,\\mathbf{v}^{(k+1)} = \\mathbf{s}_v - d\\,\\mathbf{u}^{(k+1)}$\n\nIn each step, a tridiagonal linear system is solved. This is performed efficiently using a specialized algorithm such as the Thomas algorithm (or by using a library function like `scipy.linalg.solve_banded`). The iteration continues until the change between successive iterates is smaller than a specified tolerance, $\\mathrm{tol}$, measured in a discrete $L^2$-norm:\n$$\n\\| (\\mathbf{u}^{(k+1)} - \\mathbf{u}^{(k)}, \\mathbf{v}^{(k+1)} - \\mathbf{v}^{(k)}) \\|_{2,h} = \\left( h \\sum_{i=1}^{N-2} (u_i^{(k+1)} - u_i^{(k)})^2 + h \\sum_{i=1}^{N-2} (v_i^{(k+1)} - v_i^{(k)})^2 \\right)^{1/2} \\le \\mathrm{tol}\n$$\n\n### 3. Error Analysis and Experimental Design\n\nThe objective is to distinguish between two sources of error in the final numerical solution:\n1.  **Discretization Error ($E_{\\mathrm{disc}}$)**: This error arises from approximating the continuous differential operators with finite difference formulas. For the second-order scheme used, we expect this error to decrease quadratically with the grid spacing, i.e., $E_{\\mathrm{disc}} \\propto h^2$.\n2.  **Iteration Error ($E_{\\mathrm{iter}}$)**: This error is due to terminating the iterative Gauss-Seidel solver before it has fully converged to the exact solution of the discrete algebraic system. This error is controlled by the tolerance $\\mathrm{tol}$.\n\nThe total error, $E_{\\mathrm{tot}}$, is the sum of these contributions: $E_{\\mathrm{tot}}(h,\\mathrm{tol}) \\approx E_{\\mathrm{disc}}(h) + E_{\\mathrm{iter}}(h,\\mathrm{tol})$. If the tolerance $\\mathrm{tol}$ is held constant while the grid is refined (i.e., $h \\to 0$), the discretization error $E_{\\mathrm{disc}}(h)$ will decrease. However, the iteration error $E_{\\mathrm{iter}}(h,\\mathrm{tol})$ will remain roughly constant, eventually becoming the dominant component of the total error. This phenomenon, known as **error masking**, prevents the observed convergence rate from reaching its theoretical asymptotic value, $p=2$.\n\nTo demonstrate this, three numerical experiments are conducted on a sequence of grids with $N \\in \\{33, 65, 129\\}$:\n-   **Case A (Tight Tolerance)**: With $\\mathrm{tol} = 10^{-12}$, the iteration error is driven to a negligible level. The total error $E_{\\mathrm{tot}}$ should be dominated by the discretization error $E_{\\mathrm{disc}}$, and the observed order of accuracy, $p_{\\mathrm{obs}}$, should approach the theoretical value of $2$.\n-   **Case B (Loose Tolerance)**: With $\\mathrm{tol} = 10^{-4}$, the iteration error is significant. On coarse grids, it may be smaller than the discretization error, but on fine grids, it will dominate, causing $p_{\\mathrm{obs}}$ to drop significantly below $2$.\n-   **Case C (Under-iterated)**: With only one iteration, the solution is far from converged. The resulting error is large, and the \"order of accuracy\" calculation is not expected to yield a meaningful value, highlighting the importance of sufficient iteration.\n\nThe observed order of accuracy is computed from the total errors on the two finest grids ($N_2=65$, $N_3=129$) using the formula:\n$$\np_{\\mathrm{obs}} = \\frac{\\ln\\left( E_{\\mathrm{tot}}(h_2,\\mathrm{tol}) / E_{\\mathrm{tot}}(h_3,\\mathrm{tol}) \\right)}{\\ln\\left( h_2 / h_3 \\right)}\n$$\nFinally, for the finest grid, the iteration error is directly estimated by comparing the loose-tolerance solution (Case B) to the tight-tolerance solution (Case A, taken as a proxy for the exact discrete solution). The ratio of this estimated iteration error to the total error in the loose case, $r_{\\mathrm{fine}}$, quantifies the extent of error masking.\n\nThe implementation will proceed by systematically running these cases, computing the errors, and deriving the specified quantities for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(N, tol, max_iter):\n    \"\"\"\n    Solves the coupled reaction-diffusion system for a given grid size,\n    tolerance, and max iterations.\n    \n    Args:\n        N (int): Number of grid points (including boundaries).\n        tol (float): Convergence tolerance for the Gauss-Seidel iteration.\n        max_iter (int): Maximum number of Gauss-Seidel iterations.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, float]: Tuple containing the final solution\n        vector u, the final solution vector v, and the total L2 error.\n    \"\"\"\n    # 1. Setup grid and parameters\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    x_int = x[1:-1]  # Interior points\n    num_int_pts = N - 2\n    \n    # Coefficients from problem statement\n    a, c = 1.0, 2.0\n    b, d = 0.1, 0.2\n    \n    # 2. Manufactured solution and source terms on the interior grid\n    pi = np.pi\n    u_exact_int = np.sin(pi * x_int)\n    v_exact_int = np.sin(2 * pi * x_int)\n    \n    s_u_int = pi**2 * u_exact_int + a * u_exact_int + b * v_exact_int\n    s_v_int = (2*pi)**2 * v_exact_int + c * v_exact_int + d * u_exact_int\n    \n    # 3. Construct uncoupled operators A and C in banded format for SciPy\n    # The banded format for a tridiagonal matrix (l=1, u=1) requires 3 rows:\n    # row 0: upper diagonal (shifted left)\n    # row 1: main diagonal\n    # row 2: lower diagonal (shifted right)\n    \n    # Matrix A for -u'' + a*u\n    A_banded = np.zeros((3, num_int_pts))\n    A_banded[0, 1:] = -1.0 / h**2\n    A_banded[1, :]  = 2.0 / h**2 + a\n    A_banded[2, :-1] = -1.0 / h**2\n    \n    # Matrix C for -v'' + c*v\n    C_banded = np.zeros((3, num_int_pts))\n    C_banded[0, 1:] = -1.0 / h**2\n    C_banded[1, :]  = 2.0 / h**2 + c\n    C_banded[2, :-1] = -1.0 / h**2\n    \n    # 4. Partitioned Gauss-Seidel Iteration\n    u_k = np.zeros(num_int_pts)\n    v_k = np.zeros(num_int_pts)\n    \n    for k in range(max_iter):\n        u_prev = u_k.copy()\n        v_prev = v_k.copy()\n        \n        # Solve for u^(k+1)\n        rhs_u = s_u_int - b * v_k\n        u_k = solve_banded((1, 1), A_banded, rhs_u)\n        \n        # Solve for v^(k+1)\n        rhs_v = s_v_int - d * u_k\n        v_k = solve_banded((1, 1), C_banded, rhs_v)\n        \n        # Check for convergence\n        diff_u = u_k - u_prev\n        diff_v = v_k - v_prev\n        norm_diff = np.sqrt(h * (np.sum(diff_u**2) + np.sum(diff_v**2)))\n        \n        if norm_diff = tol:\n            break\n            \n    # 5. Calculate total error against the exact manufactured solution\n    err_u = u_k - u_exact_int\n    err_v = v_k - v_exact_int\n    total_error = np.sqrt(h * (np.sum(err_u**2) + np.sum(err_v**2)))\n    \n    return u_k, v_k, total_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and compute the final results.\n    \"\"\"\n    # Define test parameters\n    resolutions = [33, 65, 129]\n    cases = {\n        'A': {'tol': 1e-12, 'max_iter': 500},\n        'B': {'tol': 1e-4,  'max_iter': 500},\n        'C': {'tol': 1e-4,  'max_iter': 1}  # tol is arbitrary for 1 iteration\n    }\n    \n    # Store results from all runs\n    results_data = {}\n    \n    # Run simulations for all cases and resolutions\n    for case_name, params in cases.items():\n        results_data[case_name] = {}\n        for N in resolutions:\n            u, v, error = run_simulation(N, params['tol'], params['max_iter'])\n            results_data[case_name][N] = {'u': u, 'v': v, 'error': error}\n    \n    # ---------- Calculate Final Outputs ----------\n    \n    # 1. Observed order of accuracy (p_obs) for each case\n    h_values = {N: 1.0 / (N - 1) for N in resolutions}\n    p_obs = {}\n    for case_name in cases:\n        err_h2 = results_data[case_name][65]['error']\n        err_h3 = results_data[case_name][129]['error']\n        h2 = h_values[65]\n        h3 = h_values[129]\n        # p_obs = log(E2/E3) / log(h2/h3) where h2/h3 = 2\n        p_obs[case_name] = np.log(err_h2 / err_h3) / np.log(2.0)\n        \n    pA = p_obs['A']\n    pB = p_obs['B']\n    pC = p_obs['C']\n    \n    # 2. Ratio r_fine for Case B at N=129\n    N_fine = 129\n    h_fine = h_values[N_fine]\n    \n    # 'tight' solution is from Case A, 'loose' is from Case B\n    u_tight = results_data['A'][N_fine]['u']\n    v_tight = results_data['A'][N_fine]['v']\n    u_loose = results_data['B'][N_fine]['u']\n    v_loose = results_data['B'][N_fine]['v']\n    \n    # Estimate iteration error as difference between loose and tight solutions\n    diff_u_iter = u_loose - u_tight\n    diff_v_iter = v_loose - v_tight\n    iter_err_est = np.sqrt(h_fine * (np.sum(diff_u_iter**2) + np.sum(diff_v_iter**2)))\n    \n    # Total error for the loose case at the finest grid\n    total_err_loose_fine = results_data['B'][N_fine]['error']\n    \n    r_fine = iter_err_est / total_err_loose_fine\n\n    # 3. Boolean checks\n    # Check if tight-tolerance order is close to theoretical value of 2\n    bool_A = 1.8 = pA = 2.2\n    # Check if error masking is observed in Case B\n    bool_B = (pB  1.0) and (r_fine > 0.5)\n\n    # Compile final results into a list\n    final_list = [pA, pB, pC, r_fine, bool_A, bool_B]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_list))}]\")\n\nsolve()\n```", "id": "3504784"}, {"introduction": "This practice [@problem_id:3504818] extends convergence analysis to time-dependent problems, where error depends on both spatial grid size $h$ and time step size $\\Delta t$. You will implement separate refinement studies to verify the second-order accuracy of the chosen schemes. This exercise introduces the critical distinction between preasymptotic and asymptotic convergence regimes, explaining why theoretical rates are often only observed once $h$ and $\\Delta t$ are sufficiently small and how to identify this transition in practice.", "problem": "Consider a one-dimensional coupled system posed on the spatial domain $[0,1]$ and on the time interval $[0,T]$, intended to represent a simplified multiphysics coupling between a diffusion process and a reaction process. The coupled system consists of a parabolic partial differential equation for $u(x,t)$ with homogeneous Dirichlet boundary conditions and a linear ordinary differential equation for $v(t)$:\n- $u_t(x,t) = \\kappa\\,u_{xx}(x,t) + \\gamma\\,v(t)\\,\\phi(x) + s(x,t)$ for $x \\in (0,1)$ and $t \\in (0,T]$,\n- $u(0,t)=0$, $u(1,t)=0$ for $t \\in [0,T]$,\n- $u(x,0)=u_0(x)$ for $x \\in [0,1]$,\n- $v'(t) = -\\lambda\\,v(t) + r(t)$ for $t \\in (0,T]$,\n- $v(0)=v_0$.\n\nAll quantities are dimensionless. The function $\\phi(x)$ is a given smooth function. For a manufactured-solution study, use the following exact fields:\n- $u(x,t) = \\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2\\,t\\right) + t^2 \\sin(2\\pi x)$,\n- $v(t) = \\exp(-\\lambda t) + t^3$,\n- $\\phi(x) = \\sin(\\pi x)$.\n\nLet $s(x,t)$ and $r(t)$ be chosen so that the exact manufactured fields satisfy the coupled system for any positive parameters $\\kappa$, $\\gamma$, and $\\lambda$. By direct differentiation and substitution into the coupled system, this requirement uniquely determines $s(x,t)$ and $r(t)$:\n- $u_t(x,t) = -\\kappa\\,\\pi^2\\,\\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2 t\\right) + 2t\\,\\sin(2\\pi x)$,\n- $u_{xx}(x,t) = -\\pi^2\\,\\sin(\\pi x)\\,\\exp\\!\\left(-\\kappa\\,\\pi^2 t\\right) - 4\\pi^2 t^2 \\sin(2\\pi x)$,\n- $s(x,t) = 2t\\,\\sin(2\\pi x) + 4\\kappa\\,\\pi^2 t^2 \\sin(2\\pi x) - \\gamma\\,v(t)\\,\\sin(\\pi x)$,\n- $v'(t) = -\\lambda \\exp(-\\lambda t) + 3 t^2$,\n- $r(t) = v'(t) + \\lambda v(t) = 3 t^2 + \\lambda t^3$,\n- $u_0(x) = u(x,0) = \\sin(\\pi x)$,\n- $v_0 = v(0) = 1$.\n\nDiscretize space on a uniform grid with $N$ interior points and spacing $h = 1/(N+1)$. Use the standard second-order central finite difference for $u_{xx}$ on the interior with homogeneous Dirichlet boundary conditions. For time stepping with step $\\Delta t$, use a second-order, unconditionally stable Crank–Nicolson method for the parabolic equation, coupled to the second-order trapezoidal rule for the ordinary differential equation. Denote the discrete Laplacian operator by $L_h$ acting on interior grid values by\n$$\n(L_h \\mathbf{w})_i = \\frac{\\mathbf{w}_{i-1} - 2 \\mathbf{w}_i + \\mathbf{w}_{i+1}}{h^2}, \\quad i=1,\\dots,N, \\quad \\mathbf{w}_0=\\mathbf{w}_{N+1}=0.\n$$\nLet $t^n = n\\,\\Delta t$ and denote $u_i^n \\approx u(x_i,t^n)$ at interior nodes $x_i=i h$, and $v^n \\approx v(t^n)$. The fully discrete scheme is\n- Trapezoidal rule for $v$:\n$$\n\\frac{v^{n+1}-v^n}{\\Delta t} = -\\frac{\\lambda}{2}(v^{n+1}+v^n) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right).\n$$\n- Crank–Nicolson for $u$:\n$$\n\\frac{\\mathbf{u}^{n+1}-\\mathbf{u}^{n}}{\\Delta t} = \\frac{\\kappa}{2}\\left(L_h \\mathbf{u}^{n+1}+ L_h \\mathbf{u}^n\\right) + \\frac{\\gamma}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{1}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right),\n$$\nwhere $\\boldsymbol{\\phi}_i = \\phi(x_i)$ and $\\mathbf{s}_i(t) = s(x_i,t)$.\n\nThe goal is to design and execute a numerical study that identifies the transition from the preasymptotic regime to the asymptotic convergence regime, and to compute observed orders of accuracy for both space and time refinements. Use the following principles:\n- Spatial refinement study: fix a sufficiently small $\\Delta t$ so that the temporal error is negligible compared to the spatial error over the chosen range of $N$. Compute the discrete $L^2$-in-space error of $u(\\cdot,T)$,\n$$\nE_h = \\left( h \\sum_{i=1}^N \\left(u_i^T - u(x_i,T)\\right)^2 \\right)^{1/2},\n$$\nand for consecutive refinements with spacings $h_j$ and $h_{j+1}$ compute local observed spatial orders\n$$\np_{h,j} = \\frac{\\log(E_{h_j}/E_{h_{j+1}})}{\\log(h_j/h_{j+1})}.\n$$\n- Temporal refinement study: fix a sufficiently fine spatial resolution $N$ so that the spatial error is negligible compared to the temporal error over the chosen range of $\\Delta t$. Compute the corresponding errors $E_{\\Delta t}$ and local observed temporal orders\n$$\np_{\\Delta t,j} = \\frac{\\log(E_{\\Delta t_j}/E_{\\Delta t_{j+1}})}{\\log(\\Delta t_j/\\Delta t_{j+1})}.\n$$\n\nDefine the design order for both space and time as $p^\\star = 2$. Define a transition-detection rule: given a tolerance $\\tau  0$ and a requirement of $m \\in \\mathbb{N}$ consecutive levels, declare that the asymptotic regime has been entered at the first index $j$ such that\n$$\n|p_{(\\cdot),j} - p^\\star| \\le \\tau, \\quad |p_{(\\cdot),j+1} - p^\\star| \\le \\tau, \\quad \\dots, \\quad |p_{(\\cdot),j+m-1} - p^\\star| \\le \\tau.\n$$\nIf no such index exists in the available sequence, report $j=0$.\n\nImplement the solver and run the two refinement studies for each of the following test cases. All quantities are dimensionless. For each case, produce the observed asymptotic orders and transition indices for space and time refinements. Use $m=2$ and $\\tau=0.2$.\n\nTest Suite:\n- Case $1$: $\\kappa=0.5$, $\\gamma=1.0$, $\\lambda=2.0$, $T=0.2$.\n  - Space refinement: $N \\in \\{16,32,64,128\\}$, fixed $\\Delta t = 0.0001$.\n  - Time refinement: fixed $N=256$, $\\Delta t \\in \\{T/40, T/80, T/160, T/320, T/640\\}$.\n- Case $2$: $\\kappa=0.1$, $\\gamma=0.2$, $\\lambda=0.5$, $T=0.05$.\n  - Space refinement: $N \\in \\{12,24,48,96\\}$, fixed $\\Delta t = 0.00005$.\n  - Time refinement: fixed $N=256$, $\\Delta t \\in \\{T/20, T/40, T/80, T/160, T/320\\}$.\n- Case $3$: $\\kappa=2.0$, $\\gamma=0.5$, $\\lambda=5.0$, $T=0.1$.\n  - Space refinement: $N \\in \\{16,32,64,128\\}$, fixed $\\Delta t = 0.0001$.\n  - Time refinement: fixed $N=256$, $\\Delta t \\in \\{T/20, T/40, T/80, T/160, T/320\\}$.\n\nYour program must:\n- Implement the above discretization with the manufactured source terms $s(x,t)$ and $r(t)$ and initial data $u_0(x)$ and $v_0$.\n- Compute the discrete $L^2$-in-space error in $u(\\cdot,T)$ for each refinement level.\n- For each study, compute local observed orders between consecutive refinements and detect the preasymptotic-to-asymptotic transition index using the specified rule with $p^\\star=2$, $\\tau=0.2$, and $m=2$.\n- For each case, return a $4$-tuple of the form $[p_h^{\\mathrm{asy}}, j_h, p_{\\Delta t}^{\\mathrm{asy}}, j_{\\Delta t}]$, where $p_h^{\\mathrm{asy}}$ is the last local observed spatial order (a float), $j_h$ is the detected spatial transition index (an integer, report $0$ if not found), $p_{\\Delta t}^{\\mathrm{asy}}$ is the last local observed temporal order (a float), and $j_{\\Delta t}$ is the detected temporal transition index (an integer, report $0$ if not found). Express $p_h^{\\mathrm{asy}}$ and $p_{\\Delta t}^{\\mathrm{asy}}$ as decimal numbers rounded to three decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list representing a case, e.g., \"[[result_case1],[result_case2],[result_case3]]\". Do not print any additional text.\n\nNo angles or physical units are used here. All values are dimensionless. Percentages must not be used in outputs; report only decimal numbers as specified. The solution should be general and implementable in any modern programming language, but your final answer must be an executable program as specified. The discretization error, consistency, and convergence analysis must be derived from the governing equations and the chosen numerical scheme without using any pre-provided shortcut formulas.", "solution": "The problem requires the implementation and analysis of a numerical solution to a coupled system of a partial differential equation (PDE) and an ordinary differential equation (ODE). The analysis involves a convergence study using the method of manufactured solutions to verify the theoretical second-order accuracy of the chosen numerical schemes.\n\nThe coupled system is given by:\n$$ u_t(x,t) = \\kappa\\,u_{xx}(x,t) + \\gamma\\,v(t)\\,\\phi(x) + s(x,t) $$\n$$ v'(t) = -\\lambda\\,v(t) + r(t) $$\nwith specified initial and boundary conditions. The analysis will be performed using a fully discrete scheme. Space is discretized using a second-order central finite difference, and time is advanced using a coupled second-order implicit scheme: the trapezoidal rule for the ODE and the Crank-Nicolson method for the PDE.\n\nFirst, we formulate the algebraic equations that must be solved at each discrete time step. Let $t^n = n\\,\\Delta t$ be the time at step $n$. We seek to find the state $(v^{n+1}, \\mathbf{u}^{n+1})$ given the state $(v^n, \\mathbf{u}^n)$.\n\nThe trapezoidal rule for the ODE $v'(t) = -\\lambda v(t) + r(t)$ is:\n$$ \\frac{v^{n+1}-v^n}{\\Delta t} = -\\frac{\\lambda}{2}(v^{n+1}+v^n) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\nThis is a linear equation for $v^{n+1}$. Rearranging the terms to solve for $v^{n+1}$, we group all terms with $v^{n+1}$ on the left-hand side:\n$$ v^{n+1}\\left(\\frac{1}{\\Delta t} + \\frac{\\lambda}{2}\\right) = v^n\\left(\\frac{1}{\\Delta t} - \\frac{\\lambda}{2}\\right) + \\frac{1}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\nMultiplying by $\\Delta t$ yields:\n$$ v^{n+1}\\left(1 + \\frac{\\lambda \\Delta t}{2}\\right) = v^n\\left(1 - \\frac{\\lambda \\Delta t}{2}\\right) + \\frac{\\Delta t}{2}\\left(r(t^{n+1})+r(t^n)\\right) $$\nSince this is a one-to-one coupling where the PDE depends on the ODE but not vice-versa, we can solve for $v^{n+1}$ first. The explicit update formula for $v^{n+1}$ is:\n$$ v^{n+1} = \\frac{\\left(1 - \\frac{\\lambda \\Delta t}{2}\\right)v^n + \\frac{\\Delta t}{2}\\left(r(t^{n+1})+r(t^n)\\right)}{1 + \\frac{\\lambda \\Delta t}{2}} $$\n\nNext, we formulate the equation for the PDE component, $u(x,t)$. The Crank-Nicolson method applied to the PDE is:\n$$ \\frac{\\mathbf{u}^{n+1}-\\mathbf{u}^{n}}{\\Delta t} = \\frac{\\kappa}{2}\\left(L_h \\mathbf{u}^{n+1}+ L_h \\mathbf{u}^n\\right) + \\frac{\\gamma}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{1}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\nwhere $\\mathbf{u}^n$ is the vector of numerical solution values at the interior spatial grid points $x_i = ih$ at time $t^n$, and $L_h$ is the discrete Laplacian operator. We rearrange this equation to group the unknown terms at time $t^{n+1}$ on the left-hand side and the known terms from time $t^n$ on the right-hand side.\n$$ \\mathbf{u}^{n+1} - \\frac{\\kappa\\Delta t}{2}L_h \\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\frac{\\kappa\\Delta t}{2}L_h \\mathbf{u}^n + \\frac{\\gamma\\Delta t}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{\\Delta t}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\nLet $A_h$ be the $N \\times N$ matrix representation of the discrete Laplacian $L_h$ on the interior grid points with homogeneous Dirichlet boundary conditions. The matrix $A_h$ is a symmetric tridiagonal matrix with $-2/h^2$ on the main diagonal and $1/h^2$ on the sub- and super-diagonals. Let $I$ be the $N \\times N$ identity matrix. The equation for $\\mathbf{u}^{n+1}$ becomes a system of linear algebraic equations:\n$$ \\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right) \\mathbf{u}^{n+1} = \\mathbf{b}^n $$\nwhere the right-hand side vector $\\mathbf{b}^n$ is composed of all known quantities:\n$$ \\mathbf{b}^n = \\left(I + \\frac{\\kappa\\Delta t}{2}A_h\\right)\\mathbf{u}^n + \\frac{\\gamma\\Delta t}{2}\\left(v^{n+1}+v^n\\right)\\,\\boldsymbol{\\phi} + \\frac{\\Delta t}{2}\\left(\\mathbf{s}(t^{n+1})+\\mathbf{s}(t^n)\\right) $$\n\nThe overall time-stepping algorithm from $t^n$ to $t^{n+1}$ proceeds as follows:\n1.  With known values of $v^n$ and $\\mathbf{u}^n$, first compute $v^{n+1}$ using its direct update formula derived from the trapezoidal rule.\n2.  Construct the right-hand side vector $\\mathbf{b}^n$ for the $u$-system. This involves evaluating the manufactured source terms $r(t)$ and $\\mathbf{s}(t)$ at times $t^n$ and $t^{n+1}$, applying the known matrix operator $(I + \\frac{\\kappa\\Delta t}{2}A_h)$ to $\\mathbf{u}^n$, and including the coupling term involving $v^n$ and the newly computed $v^{n+1}$.\n3.  Solve the linear system $\\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right) \\mathbf{u}^{n+1} = \\mathbf{b}^n$ for the unknown vector $\\mathbf{u}^{n+1}$. The system matrix $\\left(I - \\frac{\\kappa\\Delta t}{2}A_h\\right)$ is tridiagonal, symmetric, and positive-definite, allowing for a very efficient solution using a specialized banded linear solver, such as the Thomas algorithm.\n\nThis procedure is initiated with the discrete initial conditions $\\mathbf{u}^0_i = u_0(x_i)$ and $v^0 = v_0$, and is repeated until the final time $T$ is reached.\n\nFor the convergence study, we conduct two sets of numerical experiments for each test case: a spatial refinement study and a temporal refinement study.\n- In the spatial study, we fix the time step $\\Delta t$ to a small value and run simulations for a sequence of decreasing grid spacings $h_j$ (i.e., increasing $N_j$).\n- In the temporal study, we fix the spatial grid $h$ to be very fine (large $N$) and run simulations for a sequence of decreasing time steps $\\Delta t_j$.\n\nFor each simulation, the discrete $L^2$-in-space error is computed at the final time $T$:\n$$ E = \\left( h \\sum_{i=1}^N \\left(u_i^T - u(x_i,T)\\right)^2 \\right)^{1/2} $$\nwhere $u_i^T$ is the numerical solution and $u(x_i,T)$ is the exact manufactured solution at grid point $x_i$ and final time $T$.\n\nFrom the sequence of errors $\\{E_j\\}$ obtained from a sequence of refinements $\\{h_j\\}$ or $\\{\\Delta t_j\\}$, the local observed order of accuracy is calculated between consecutive refinements:\n$$ p_j = \\frac{\\log(E_j/E_{j+1})}{\\log(h_j/h_{j+1})} \\quad \\text{or} \\quad p_j = \\frac{\\log(E_j/E_{j+1})}{\\log(\\Delta t_j/\\Delta t_{j+1})} $$\nGiven that the refinement ratios are $2$ in this problem, this simplifies to $p_j = \\log_2(E_j/E_{j+1})$.\n\nThe transition from the preasymptotic to the asymptotic regime is identified by finding the first index $j$ in the sequence of observed orders $\\{p_j\\}$ such that $|p_k - p^\\star| \\le \\tau$ for $m$ consecutive orders starting from $p_j$, where the design order is $p^\\star=2$, the tolerance is $\\tau=0.2$, and the number of consecutive levels is $m=2$. If no such index is found, a transition index of $0$ is reported. The final reported asymptotic order is the last computed local order in the sequence, $p_{N-1}$ where $N$ is the number of refinements.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and print the final results.\n    \"\"\"\n\n    def u_exact(x, t, kappa):\n        pi = np.pi\n        return np.sin(pi * x) * np.exp(-kappa * pi**2 * t) + t**2 * np.sin(2 * pi * x)\n\n    def v_exact(t, lambda_val):\n        return np.exp(-lambda_val * t) + t**3\n\n    def phi_func(x):\n        return np.sin(np.pi * x)\n        \n    def r_source(t, lambda_val):\n        return 3 * t**2 + lambda_val * t**3\n\n    def s_source(x, t, kappa, gamma, lambda_val):\n        pi = np.pi\n        v_val = v_exact(t, lambda_val)\n        term1 = 2 * t * np.sin(2 * pi * x)\n        term2 = 4 * kappa * pi**2 * t**2 * np.sin(2 * pi * x)\n        term3 = -gamma * v_val * np.sin(pi * x)\n        return term1 + term2 + term3\n\n    def find_transition_index(orders, p_star, m, tau):\n        \"\"\"\n        Finds the transition index to the asymptotic regime.\n        Index is 1-based.\n        \"\"\"\n        if len(orders)  m:\n            return 0\n        for j in range(len(orders) - m + 1):\n            is_asymptotic = True\n            for k in range(m):\n                if abs(orders[j + k] - p_star)  tau:\n                    is_asymptotic = False\n                    break\n            if is_asymptotic:\n                return j + 1\n        return 0\n\n    def run_simulation(N, dt, T, kappa, gamma, lambda_val):\n        \"\"\"\n        Runs a single simulation for a given set of discretization parameters.\n        Returns the final L2 error in u.\n        \"\"\"\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n        num_steps = int(round(T / dt))\n\n        # Initial conditions\n        u_n = u_exact(x, 0, kappa)\n        v_n = v_exact(0, lambda_val)\n        \n        # Assemble constant LHS matrix for the u-system\n        # M = I - (kappa*dt/2) * A_h\n        main_diag_val = 1.0 + kappa * dt / h**2\n        off_diag_val = -kappa * dt / (2 * h**2)\n        \n        # Banded matrix for scipy.linalg.solve_banded: (l, u), ab, b\n        # ab is (3, N) for l=1, u=1. ab[0,1:], ab[1,:], ab[2,:-1]\n        ab = np.zeros((3, N))\n        ab[0, 1:] = off_diag_val\n        ab[1, :] = main_diag_val\n        ab[2, :-1] = off_diag_val\n\n        phi_vec = phi_func(x)\n\n        for n in range(num_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n\n            # Step 1: Solve for v_np1\n            r_n = r_source(t_n, lambda_val)\n            r_np1 = r_source(t_np1, lambda_val)\n            v_num = (1 - lambda_val * dt / 2) * v_n + (dt / 2) * (r_np1 + r_n)\n            v_den = 1 + lambda_val * dt / 2\n            v_np1 = v_num / v_den\n\n            # Step 2: Construct RHS for u-system\n            # Part 1: (I + (kappa*dt/2) * A_h) * u_n\n            u_padded = np.concatenate(([0], u_n, [0]))\n            A_h_u_n = (u_padded[:-2] - 2 * u_padded[1:-1] + u_padded[2:]) / h**2\n            rhs_pde_part = u_n + (kappa * dt / 2) * A_h_u_n\n            \n            # Part 2: Source and coupling terms\n            s_n = s_source(x, t_n, kappa, gamma, lambda_val)\n            s_np1 = s_source(x, t_np1, kappa, gamma, lambda_val)\n            rhs_forcing_part = (gamma * dt / 2) * (v_np1 + v_n) * phi_vec + \\\n                               (dt / 2) * (s_np1 + s_n)\n            \n            rhs = rhs_pde_part + rhs_forcing_part\n\n            # Step 3: Solve for u_np1\n            u_np1 = solve_banded((1, 1), ab, rhs)\n\n            # Update for next step\n            u_n = u_np1\n            v_n = v_np1\n        \n        # Compute final error\n        u_exact_final = u_exact(x, T, kappa)\n        error = np.sqrt(h * np.sum((u_n - u_exact_final)**2))\n        return error\n\n    def run_convergence_study(params, is_spatial):\n        kappa, gamma, lambda_val, T = params[:4]\n\n        if is_spatial:\n            N_list, dt_fixed = params[4], params[5]\n            refinements = [1.0 / (N + 1) for N in N_list]\n            errors = [run_simulation(N, dt_fixed, T, kappa, gamma, lambda_val) for N in N_list]\n        else: # Temporal\n            N_fixed, dt_divs = params[6], params[7]\n            dt_list = [T / div for div in dt_divs]\n            refinements = dt_list\n            errors = [run_simulation(N_fixed, dt, T, kappa, gamma, lambda_val) for dt in dt_list]\n\n        orders = []\n        if len(errors)  1:\n            for j in range(len(errors) - 1):\n                # Ratio of refinements is expected to be 2\n                ratio_ref = refinements[j] / refinements[j+1]\n                if errors[j]  0 and errors[j+1]  0:\n                    orders.append(np.log(errors[j] / errors[j+1]) / np.log(ratio_ref))\n                else:\n                    orders.append(0.0)\n        \n        last_order = orders[-1] if orders else 0.0\n        p_star, m, tau = 2.0, 2, 0.2\n        trans_idx = find_transition_index(orders, p_star, m, tau)\n        \n        return round(last_order, 3), trans_idx\n\n    test_cases = [\n        # Case 1: kappa, gamma, lambda, T, N_space, dt_space, N_time, dt_time_divs\n        (0.5, 1.0, 2.0, 0.2, [16, 32, 64, 128], 0.0001, 256, [40, 80, 160, 320, 640]),\n        # Case 2\n        (0.1, 0.2, 0.5, 0.05, [12, 24, 48, 96], 0.00005, 256, [20, 40, 80, 160, 320]),\n        # Case 3\n        (2.0, 0.5, 5.0, 0.1, [16, 32, 64, 128], 0.0001, 256, [20, 40, 80, 160, 320])\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        p_h_asy, j_h = run_convergence_study(case_params, is_spatial=True)\n        p_dt_asy, j_dt = run_convergence_study(case_params, is_spatial=False)\n        all_results.append(f\"[{p_h_asy},{j_h},{p_dt_asy},{j_dt}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3504818"}]}