{"hands_on_practices": [{"introduction": "Before deploying finite elements in complex multiphysics simulations, it is crucial to verify that their implementation is fundamentally correct. This practice guides you through the construction of a standard verification suite to test the cornerstone properties of the bilinear isoparametric element. By performing the patch test and checking for affine invariance, you will confirm that the element can exactly reproduce constant strain states, a necessary condition for convergence and a hallmark of a reliable implementation [@problem_id:3525426].", "problem": "Construct a complete and runnable program that verifies, for bilinear isoparametric quadrilateral elements, the linear patch test, consistency under numerical quadrature, and affine invariance of interpolation and strain for prescribed affine mappings. Work in a purely mathematical and logical setting without physical units. All definitions must be implemented from first principles of isoparametric finite elements: the isoparametric mapping, bilinear Lagrange shape functions on the reference square, small-strain kinematics, and Gaussian quadrature. No pre-derived finite element formulas beyond these core definitions may be assumed.\n\nStart from the following foundational base:\n\n- The reference element is the square $[-1,1]\\times[-1,1]$ with local coordinates $(\\xi,\\eta)$ and node ordering: $1:(-1,-1)$, $2:(1,-1)$, $3:(1,1)$, $4:(-1,1)$.\n- Bilinear Lagrange shape functions $N_i(\\xi,\\eta)$ are the unique polynomials that are linear in each variable, equal to $1$ at node $i$ and $0$ at the other nodes.\n- The isoparametric mapping from reference to physical coordinates is $x(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,X_i$ and $y(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,Y_i$, where $(X_i,Y_i)$ are the physical coordinates of node $i$.\n- The Jacobian matrix is $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi & \\partial x/\\partial \\eta\\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta\\end{bmatrix}$, and derivatives with respect to physical coordinates satisfy $\\nabla_{x} N_i = J^{-1}\\,\\nabla_{\\xi\\eta} N_i$.\n- The small-strain tensor in two dimensions for displacement field $u=(u,v)$ is $\\varepsilon=\\begin{bmatrix}\\varepsilon_{xx}\\\\ \\varepsilon_{yy}\\\\ \\gamma_{xy}\\end{bmatrix}=\\begin{bmatrix}\\partial u/\\partial x\\\\ \\partial v/\\partial y\\\\ \\partial u/\\partial y + \\partial v/\\partial x\\end{bmatrix}$.\n- The element strain-displacement matrix $B$ for a bilinear quadrilateral has size $3\\times 8$ and is built from $\\partial N_i/\\partial x$ and $\\partial N_i/\\partial y$ so that $\\varepsilon = B\\,d_e$, where $d_e=[u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4]^T$ are the element nodal displacement degrees of freedom.\n- The plane-stress constitutive matrix for an isotropic solid of modulus $E$ and Poisson ratio $\\nu$ is $D = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix}1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$, and the element stiffness is $K_e=\\int_{-1}^{1}\\int_{-1}^{1} B^T D B \\,\\det(J)\\, d\\xi\\, d\\eta$.\n- Tensor-product Gaussian quadrature on $[-1,1]$ with $1\\times 1$ points uses point $(\\xi,\\eta)=(0,0)$ and weight $w=4$, and with $2\\times 2$ points uses $(\\xi,\\eta)=\\left(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\right)$ with unit weights.\n\nUse the following prescribed affine mappings from the reference to the physical domain, given by $x = A\\,\\hat{x} + t$ with $\\hat{x}=(\\xi,\\eta)^T$, $A\\in\\mathbb{R}^{2\\times 2}$ invertible and $t\\in\\mathbb{R}^2$:\n\n- Mapping $\\mathcal{A}_1$: $A_1=\\begin{bmatrix}1 & 0\\\\ 0 & 1\\end{bmatrix}$, $t_1=\\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- Mapping $\\mathcal{A}_2$: $A_2=\\begin{bmatrix}1.7320508075688772 & -0.25\\\\ 1.0 & 0.4330127018922193\\end{bmatrix}$, $t_2=\\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- Mapping $\\mathcal{A}_3$: $A_3=\\begin{bmatrix}1.5 & 0.9\\\\ 0.0 & 1.5\\end{bmatrix}$, $t_3=\\begin{bmatrix}0.3\\\\ -0.2\\end{bmatrix}$.\n- Mapping $\\mathcal{A}_4$: $A_4=\\begin{bmatrix}1.0 & 0.3\\\\ 0.0 & 0.001\\end{bmatrix}$, $t_4=\\begin{bmatrix}0.0\\\\ 0.0\\end{bmatrix}$.\n\nUse the following linear displacement field in physical coordinates:\n$$\nu(x,y)=a_0 + a_1 x + a_2 y,\\qquad v(x,y)=b_0 + b_1 x + b_2 y,\n$$\nwith coefficients $a_0=0.1$, $a_1=0.2$, $a_2=-0.3$, $b_0=-0.05$, $b_1=0.4$, $b_2=0.25$. The exact small strains for this field are constants:\n$$\n\\varepsilon_{xx}^{\\text{exact}}=a_1,\\quad \\varepsilon_{yy}^{\\text{exact}}=b_2,\\quad \\gamma_{xy}^{\\text{exact}}=a_2+b_1.\n$$\n\nImplement and evaluate the following tests:\n\n- Interpolation affine invariance test (one element): For each mapping $\\mathcal{A}_k$, construct a single bilinear quadrilateral element by mapping the four reference corners $(-1,-1)$, $(1,-1)$, $(1,1)$, $(-1,1)$. Compute the nodal displacement values by evaluating the given linear field at the physical node coordinates. For the four reference sampling points $(\\xi,\\eta)\\in\\{(0,0),\\, (1/\\sqrt{3},-1/\\sqrt{3}),\\, (-0.3,0.9),\\, (0.8,0.1)\\}$, evaluate the isoparametric interpolation of $(u,v)$ and compare it to the exact $(u,v)$ evaluated at the mapped physical point. Report a boolean for each mapping indicating whether the maximum absolute componentwise error over the four points is at most $\\varepsilon_{\\text{interp}}=10^{-10}$.\n\n- Strain affine invariance test (one element): For each mapping $\\mathcal{A}_k$, using the same element and nodal displacement values as above, construct the strain-displacement matrix $B$ and compute the finite element strain $\\varepsilon=B\\,d_e$ at $(\\xi,\\eta)=(0,0)$. Report a boolean for each mapping indicating whether the Euclidean norm of the error $\\|\\varepsilon-\\varepsilon^{\\text{exact}}\\|_2$ is at most $\\varepsilon_{\\text{strain}}=\\varepsilon_{\\text{abs}}+\\varepsilon_{\\text{rel}}\\|\\varepsilon^{\\text{exact}}\\|_2$ with $\\varepsilon_{\\text{abs}}=10^{-12}$ and $\\varepsilon_{\\text{rel}}=10^{-8}$.\n\n- Consistency under quadrature (one element): For mapping $\\mathcal{A}_2$, compute the element stiffness matrix $K_e$ once with $1\\times 1$ Gaussian quadrature and once with $2\\times 2$ Gaussian quadrature. Report a boolean indicating whether the relative Frobenius norm difference is at most $\\varepsilon_{K}=10^{-12}$.\n\n- Linear patch test on a $2\\times 2$ mesh: Build a $2\\times 2$ mesh of bilinear quadrilateral elements by subdividing the reference square $[-1,1]\\times[-1,1]$ into four congruent squares with nodes at the $3\\times 3$ grid $\\{(-1,0,1)\\}\\times\\{(-1,0,1)\\}$, then map all nodes by $\\mathcal{A}_3$. Assemble the global stiffness matrix using the plane-stress constitutive model with $E=1.0$, $\\nu=0.25$, thickness $t=1$. Impose Dirichlet boundary conditions by prescribing the exact displacement values at all boundary nodes. Let the interior node be free with its displacement equal to the exact value. Form the global internal force vector $f^{\\text{int}}=K\\,d$ with zero external forces. Report a boolean indicating whether the Euclidean norm of the residual at the two interior degrees of freedom is at most $\\varepsilon_{\\text{patch}}=10^{-12}$.\n\nYour program must implement the above from the definitions and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The results must be ordered as:\n$[\\text{I}_1,\\text{I}_2,\\text{I}_3,\\text{I}_4,\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{K}_{\\text{consistency}},\\text{P}_{\\text{patch}}]$,\nwhere $\\text{I}_k$ are the interpolation test booleans, $\\text{S}_k$ are the strain test booleans, $\\text{K}_{\\text{consistency}}$ is the quadrature consistency boolean, and $\\text{P}_{\\text{patch}}$ is the patch test boolean. The program must be self-contained and run without user input.\n\nTest Suite Summary:\n- Affine mappings: $\\mathcal{A}_1$, $\\mathcal{A}_2$, $\\mathcal{A}_3$, $\\mathcal{A}_4$ as specified above.\n- Sampling points: $(0,0)$, $(1/\\sqrt{3},-1/\\sqrt{3})$, $(-0.3,0.9)$, $(0.8,0.1)$.\n- Displacement coefficients: $a_0=0.1$, $a_1=0.2$, $a_2=-0.3$, $b_0=-0.05$, $b_1=0.4$, $b_2=0.25$.\n- Plane-stress parameters: $E=1.0$, $\\nu=0.25$, thickness $t=1$.\n- Tolerances: $\\varepsilon_{\\text{interp}}=10^{-10}$, $\\varepsilon_{\\text{abs}}=10^{-12}$, $\\varepsilon_{\\text{rel}}=10^{-8}$, $\\varepsilon_{K}=10^{-12}$, $\\varepsilon_{\\text{patch}}=10^{-12}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true,...]\").", "solution": "The provided problem is a well-posed and scientifically sound verification suite for the bilinear isoparametric quadrilateral finite element. It tests fundamental properties required for a correct implementation, namely the ability to exactly represent linear displacement fields (interpolation), the ability to exactly reproduce constant strain states resulting from those fields (strain invariance), the consistency of the stiffness matrix formulation under different numerical integration schemes for a special case, and the satisfaction of equilibrium for a patch of elements under a constant strain state (the patch test). All definitions and data required are provided, and the tests are structured to yield clear, verifiable boolean outcomes. The problem is valid and can be solved as stated.\n\nThe solution is constructed by implementing the core components of the isoparametric finite element method from the first principles specified in the problem statement.\n\n### 1. Foundational Implementation: Shape Functions and Isoparametric Mapping\n\nThe starting point is the reference square element in the $(\\xi, \\eta)$ local coordinate system, where $\\xi, \\eta \\in [-1, 1]$. The four nodes are ordered counter-clockwise starting from $(-1, -1)$. The bilinear Lagrange shape functions $N_i(\\xi, \\eta)$ are defined as:\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) &= \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) &= \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) &= \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) &= \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThese functions satisfy the Kronecker delta property, $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$, at the nodal coordinates $(\\xi_j, \\eta_j)$. A key property is the partition of unity: $\\sum_{i=1}^{4} N_i(\\xi, \\eta) = 1$ for all $(\\xi, \\eta)$.\n\nThe isoparametric mapping relates the local coordinates to the physical coordinates $(x, y)$ using these same shape functions:\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,X_i, \\qquad y(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,Y_i\n$$\nwhere $(X_i, Y_i)$ are the physical coordinates of node $i$. When the physical element is formed by an affine mapping of the reference element, $x=A\\hat{x}+t$, the physical node coordinates are $X_i=A\\hat{x}_i+t$, where $\\hat{x}_i$ are the reference node coordinates. Due to the property that the shape functions reproduce linear functions, specifically $\\sum N_i \\xi_i = \\xi$ and $\\sum N_i \\eta_i = \\eta$, the mapping simplifies to:\n$$\nx(\\xi,\\eta) = A \\begin{pmatrix} \\xi \\\\ \\eta \\end{pmatrix} + t\n$$\nThe Jacobian matrix of this transformation, $J = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$, is therefore constant for any element generated by an affine map and is equal to the matrix $A$:\n$$\nJ(\\xi,\\eta) = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix} = A\n$$\nThis is a significant simplification over a general quadrilateral element where $J$ would be a linear function of $(\\xi, \\eta)$.\n\n### 2. Strain Analysis: B-Matrix and Strain Reproduction\n\nThe small-strain tensor $\\varepsilon = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ is computed from the nodal displacements $d_e$ via the strain-displacement matrix $B$, such that $\\varepsilon = B\\,d_e$. The $B$ matrix is of size $3 \\times 8$ and is constructed from the physical derivatives of the shape functions, $\\partial N_i/\\partial x$ and $\\partial N_i/\\partial y$. These are obtained from the local-coordinate derivatives using the inverse of the Jacobian:\n$$\n\\begin{pmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix} = A^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix}\n$$\nSince the derivatives $\\partial N_i/\\partial \\xi$ and $\\partial N_i/\\partial \\eta$ are linear functions of $\\xi$ and $\\eta$, and $A^{-1}$ is constant, the physical derivatives $\\partial N_i/\\partial x$ and $\\partial N_i/\\partial y$ are also linear in $\\xi, \\eta$. The $B$ matrix is formed by arranging these derivatives for each node $i=1..4$:\n$$\nB_i(\\xi, \\eta) = \\begin{bmatrix} \\partial N_i/\\partial x & 0 \\\\ 0 & \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y & \\partial N_i/\\partial x \\end{bmatrix}, \\qquad B = [B_1, B_2, B_3, B_4]\n$$\nA fundamental property of the isoparametric formulation is that it exactly reproduces any displacement field that is present in its basis. Since the basis contains linear terms, a linear field $u(x,y) = a_0+a_1x+a_2y$ is interpolated exactly. Consequently, its derivatives are also reproduced exactly. The calculated strain vector $\\varepsilon(\\xi,\\eta) = B(\\xi,\\eta) d_e$ will be constant throughout the element and equal to the exact strain vector $[\\varepsilon_{xx}^{\\text{exact}}, \\varepsilon_{yy}^{\\text{exact}}, \\gamma_{xy}^{\\text{exact}}]^T = [a_1, b_2, a_2+b_1]^T$.\n\n### 3. Verification Tests\n\nThe problem prescribes four tests to verify these properties numerically.\n\n**Interpolation and Strain Invariance Tests:** These tests confirm the properties discussed above. For each affine mapping $\\mathcal{A}_k$, we form a single element. Nodal displacements are computed from the given linear field. The interpolated displacement at various sample points should match the exact field to machine precision. Similarly, the strain computed at the element center should match the constant exact strain vector to within a specified tolerance. These tests are expected to pass for all non-degenerate affine mappings.\n\n**Consistency under Quadrature Test:** This test compares the element stiffness matrix $K_e$ computed using two different Gaussian quadrature rules: $1 \\times 1$ and $2 \\times 2$. The stiffness matrix is given by the integral:\n$$\nK_e=\\int_{-1}^{1}\\int_{-1}^{1} B^T(\\xi,\\eta) D B(\\xi,\\eta) \\,\\det(J)\\, d\\xi\\, d\\eta\n$$\nHere, $D$ is the constant plane-stress constitutive matrix and $\\det(J) = \\det(A)$ is constant. The entries of the $B$ matrix are linear in $\\xi$ and $\\eta$. Therefore, the integrand $B^T D B$ is a matrix of quadratic polynomials in $\\xi$ and $\\eta$. A $2 \\times 2$ Gaussian quadrature rule integrates polynomials up to degree $3$ exactly, so it will compute the integral for $K_e$ exactly. A $1 \\times 1$ rule is only exact for polynomials up to degree $1$. Since the integrand is quadratic, the $1 \\times 1$ rule will not yield the exact integral in general. Thus, the two computed stiffness matrices, $K_{e,1 \\times 1}$ and $K_{e,2 \\times 2}$, are not expected to be identical. The test, as specified, will be implemented, and the boolean result will reflect this mathematical fact.\n\n**Linear Patch Test:** This test verifies that an assembly of elements can collectively reproduce a state of constant strain without generating spurious nodal forces. A $2 \\times 2$ mesh is created and mapped by $\\mathcal{A}_3$. We prescribe the exact displacements from the linear field to all nodes. The global internal force vector is computed as $f^{\\text{int}} = K d$. The patch test is passed if the forces at the unconstrained interior node's degrees of freedom are zero (to machine precision). Since the bilinear element can reproduce a constant strain state exactly, the internal stress field is in equilibrium, and the resultant forces at any free node must be zero. This test should pass, provided an integration rule that is sufficiently accurate is used to compute the element stiffness matrices. A $2 \\times 2$ quadrature rule, being exact for these parallelogram elements, is the appropriate choice.\n\nThe implementation will proceed by creating functions for each of these mathematical constructs and tests.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all verification tests for a bilinear isoparametric quadrilateral element.\n    \"\"\"\n\n    # --- Problem Givens ---\n\n    # Affine Mappings: x = A*x_hat + t\n    mappings = {\n        'A1': (np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([0.0, 0.0])),\n        'A2': (np.array([[1.7320508075688772, -0.25], [1.0, 0.4330127018922193]]), np.array([0.0, 0.0])),\n        'A3': (np.array([[1.5, 0.9], [0.0, 1.5]]), np.array([0.3, -0.2])),\n        'A4': (np.array([[1.0, 0.3], [0.0, 0.001]]), np.array([0.0, 0.0]))\n    }\n\n    # Linear Displacement Field Coefficients\n    disp_coeffs = {'a0': 0.1, 'a1': 0.2, 'a2': -0.3, 'b0': -0.05, 'b1': 0.4, 'b2': 0.25}\n\n    # Material and Geometric Properties for Stiffness\n    E, nu, thickness = 1.0, 0.25, 1.0\n\n    # Test Tolerances\n    epsilon_interp = 1e-10\n    epsilon_strain_abs = 1e-12\n    epsilon_strain_rel = 1e-8\n    epsilon_K = 1e-12\n    epsilon_patch = 1e-12\n    \n    # Reference element nodes\n    ref_nodes = np.array([[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0]])\n\n    # --- Core FEM Functions ---\n\n    def shape_functions(xi, eta):\n        return 0.25 * np.array([\n            (1-xi)*(1-eta),\n            (1+xi)*(1-eta),\n            (1+xi)*(1+eta),\n            (1-xi)*(1+eta)\n        ])\n\n    def shape_function_derivatives(xi, eta):\n        # Returns derivatives wrt xi and eta for each shape function\n        # Shape: (4, 2) where row i is [dNi/dxi, dNi/deta]\n        return 0.25 * np.array([\n            [-(1-eta), -(1-xi)],\n            [ (1-eta), -(1+xi)],\n            [ (1+eta),  (1+xi)],\n            [-(1+eta),  (1-xi)]\n        ])\n\n    def get_B_matrix(xi, eta, node_coords):\n        dN_dxieta = shape_function_derivatives(xi, eta)\n        \n        # For an affine map x = A*xi + t, the Jacobian J = A\n        # Here we compute it generally for correctness.\n        # J = node_coords.T @ dN_dxieta would be correct due to specific data structure\n        # Let's use the property J = A for affine mappings for robustness and simplicity\n        # Element nodes are X_i = A*ref_nodes_i + t\n        # x(xi,eta) = sum(N_i * X_i) = A * sum(N_i*ref_nodes_i) + t * sum(N_i) = A*[xi,eta]^T + t\n        # So J = A. We need A. We can recover A from node_coords.\n        # X1 = A*[-1,-1]+t, X2=A*[1,-1]+t, X4=A*[-1,1]+t\n        # X2-X1 = A*[2,0], X4-X1 = A*[0,2]\n        # A_col1 = (X2-X1)/2, A_col2 = (X4-X1)/2\n        A = np.zeros((2, 2))\n        A[:, 0] = (node_coords[1] - node_coords[0]) / 2.0\n        A[:, 1] = (node_coords[3] - node_coords[0]) / 2.0\n        \n        J_inv = np.linalg.inv(A)\n        \n        # Derivatives wrt x, y\n        # dN_dxy = dN_dxieta @ J_inv.T\n        dN_dxy = dN_dxieta @ J_inv.T\n\n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2*i]     = dN_dxy[i, 0]\n            B[1, 2*i + 1] = dN_dxy[i, 1]\n            B[2, 2*i]     = dN_dxy[i, 1]\n            B[2, 2*i + 1] = dN_dxy[i, 0]\n        return B\n\n    def get_constitutive_matrix(E, nu):\n        factor = E / (1 - nu**2)\n        return factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2.]\n        ])\n\n    def exact_displacement(x, y, coeffs):\n        u = coeffs['a0'] + coeffs['a1'] * x + coeffs['a2'] * y\n        v = coeffs['b0'] + coeffs['b1'] * x + coeffs['b2'] * y\n        return np.array([u, v])\n\n    def exact_strain(coeffs):\n        return np.array([\n            coeffs['a1'],\n            coeffs['b2'],\n            coeffs['a2'] + coeffs['b1']\n        ])\n\n    # --- Test Implementations ---\n\n    def run_interpolation_test(A, t, coeffs, tol):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        nodal_disps = np.zeros((4, 2))\n        for i in range(4):\n            nodal_disps[i, :] = exact_displacement(phys_nodes[i, 0], phys_nodes[i, 1], coeffs)\n\n        sample_points = [(0, 0), (1/np.sqrt(3), -1/np.sqrt(3)), (-0.3, 0.9), (0.8, 0.1)]\n        max_err = 0.0\n\n        for xi, eta in sample_points:\n            N = shape_functions(xi, eta)\n            phys_pt = N @ phys_nodes\n            interp_disp = N @ nodal_disps\n            exact_disp = exact_displacement(phys_pt[0], phys_pt[1], coeffs)\n            \n            err = np.max(np.abs(interp_disp - exact_disp))\n            if err > max_err:\n                max_err = err\n        \n        return max_err <= tol\n\n    def run_strain_test(A, t, coeffs, tol_abs, tol_rel):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        d_e = np.zeros(8)\n        for i in range(4):\n            disp = exact_displacement(phys_nodes[i, 0], phys_nodes[i, 1], coeffs)\n            d_e[2*i] = disp[0]\n            d_e[2*i+1] = disp[1]\n\n        xi, eta = 0.0, 0.0\n        B = get_B_matrix(xi, eta, phys_nodes)\n        fe_strain = B @ d_e\n        \n        true_strain = exact_strain(coeffs)\n        \n        err_norm = np.linalg.norm(fe_strain - true_strain)\n        tolerance = tol_abs + tol_rel * np.linalg.norm(true_strain)\n        \n        return err_norm <= tolerance\n\n    def compute_element_stiffness(phys_nodes, D, thickness, qp_points, qp_weights):\n        Ke = np.zeros((8, 8))\n        for i in range(len(qp_points)):\n            xi, eta = qp_points[i]\n            w = qp_weights[i]\n            \n            # Recompute A for Jacobian for generality/safety, although it's constant\n            A = np.zeros((2, 2))\n            A[:, 0] = (phys_nodes[1] - phys_nodes[0]) / 2.0\n            A[:, 1] = (phys_nodes[3] - phys_nodes[0]) / 2.0\n            detJ = np.linalg.det(A)\n            \n            B = get_B_matrix(xi, eta, phys_nodes)\n            Ke += B.T @ D @ B * detJ * w * thickness\n        return Ke\n        \n    def run_quadrature_test(A, t, E, nu, thickness, tol):\n        phys_nodes = (A @ ref_nodes.T).T + t\n        D = get_constitutive_matrix(E, nu)\n        \n        # 1x1 Quadrature\n        qp1 = [(0.0, 0.0)]\n        qw1 = [4.0]\n        K1 = compute_element_stiffness(phys_nodes, D, thickness, qp1, qw1)\n        \n        # 2x2 Quadrature\n        p = 1.0 / np.sqrt(3)\n        qp2 = [(-p, -p), (p, -p), (p, p), (-p, p)]\n        qw2 = [1.0, 1.0, 1.0, 1.0]\n        K2 = compute_element_stiffness(phys_nodes, D, thickness, qp2, qw2)\n        \n        diff_norm = np.linalg.norm(K1 - K2, 'fro')\n        norm_K2 = np.linalg.norm(K2, 'fro')\n        \n        if norm_K2 == 0: return diff_norm <= tol # Should not happen\n        return (diff_norm / norm_K2) <= tol\n\n    def run_patch_test(A, t, coeffs, E, nu, thickness, tol):\n        # 2x2 mesh on [-1,1]x[-1,1] reference domain, mapped by A, t\n        ref_grid_pts = np.array([\n            [-1,-1], [0,-1], [1,-1],\n            [-1, 0], [0, 0], [1, 0],\n            [-1, 1], [0, 1], [1, 1]\n        ])\n        \n        phys_grid_pts = (A @ ref_grid_pts.T).T + t\n        \n        # Node connectivity for 4 elements (0-indexed)\n        # Elem 1 (BL), 2(BR), 3(TL), 4(TR)\n        # My previous thought was: Elem 1: 0,1,4,3, Elem 2: 1,2,5,4, Elem 3: 3,4,7,6, Elem 4: 4,5,8,7\n        # Correctly following the node numbering of the grid:\n        # e.g., 0,1,2 / 3,4,5 / 6,7,8 -> Elem BL uses nodes 0,1,4,3.\n        connectivity = [\n            [0, 1, 4, 3], # Bottom-left\n            [1, 2, 5, 4], # Bottom-right\n            [3, 4, 7, 6], # Top-left\n            [4, 5, 8, 7]  # Top-right\n        ]\n        \n        D = get_constitutive_matrix(E, nu)\n        \n        # Quadrature for assembly (2x2 is standard for full integration)\n        p = 1.0 / np.sqrt(3)\n        qp2 = [(-p, -p), (p, -p), (p, p), (-p, p)]\n        qw2 = [1.0, 1.0, 1.0, 1.0]\n        \n        K_global = np.zeros((18, 18))\n        \n        # Assembly\n        for elem_nodes_g_idx in connectivity:\n            phys_nodes_elem = phys_grid_pts[elem_nodes_g_idx, :]\n            Ke = compute_element_stiffness(phys_nodes_elem, D, thickness, qp2, qw2)\n            \n            dof_map = []\n            for node_idx in elem_nodes_g_idx:\n                dof_map.extend([2*node_idx, 2*node_idx + 1])\n            \n            for i_loc in range(8):\n                for j_loc in range(8):\n                    i_glob = dof_map[i_loc]\n                    j_glob = dof_map[j_loc]\n                    K_global[i_glob, j_glob] += Ke[i_loc, j_loc]\n                    \n        # Global displacement vector d\n        d_global = np.zeros(18)\n        for i in range(9):\n            disp = exact_displacement(phys_grid_pts[i,0], phys_grid_pts[i,1], coeffs)\n            d_global[2*i] = disp[0]\n            d_global[2*i+1] = disp[1]\n\n        # Internal forces F_int = K*d\n        f_internal = K_global @ d_global\n        \n        # Check residual at interior node (node 4, DOFs 8 and 9)\n        interior_node_idx = 4\n        residual = f_internal[2*interior_node_idx : 2*interior_node_idx + 2]\n        \n        return np.linalg.norm(residual) <= tol\n\n    # --- Execute Tests and Collect Results ---\n    \n    results = []\n\n    # Interpolation tests\n    for k in ['A1', 'A2', 'A3', 'A4']:\n        A, t = mappings[k]\n        results.append(run_interpolation_test(A, t, disp_coeffs, epsilon_interp))\n        \n    # Strain tests\n    for k in ['A1', 'A2', 'A3', 'A4']:\n        A, t = mappings[k]\n        results.append(run_strain_test(A, t, disp_coeffs, epsilon_strain_abs, epsilon_strain_rel))\n\n    # Quadrature consistency test\n    A_q, t_q = mappings['A2']\n    results.append(run_quadrature_test(A_q, t_q, E, nu, thickness, epsilon_K))\n\n    # Patch test\n    A_p, t_p = mappings['A3']\n    results.append(run_patch_test(A_p, t_p, disp_coeffs, E, nu, thickness, epsilon_patch))\n\n    # --- Format and Print Final Output ---\n    # Convert booleans to lowercase strings as per Python's str(True) -> 'True' -> 'true'\n    str_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3525426"}, {"introduction": "While straight-sided elements are foundational, real-world problems demand elements that can conform to curved boundaries. This exercise delves into the critical implications of the isoparametric mapping on numerical integration, where the non-constant Jacobian can significantly increase the complexity of the integrand. You will determine the minimal Gauss quadrature order needed to exactly integrate a coupled thermomechanical term, learning to prevent the introduction of artificial physical effects that arise from under-integration [@problem_id:3525420].", "problem": "Consider a single isoparametric quadrilateral element for the Finite Element Method (FEM) with bi-cubic field approximation, commonly denoted as $Q_3$. The reference domain is the square $[-1,1]\\times[-1,1]$ in parametric coordinates $(\\xi,\\eta)$. The $Q_3$ element uses a tensor-product of one-dimensional Lagrange polynomials of degree $3$ with nodes at $\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}$ in each parametric direction. The isoparametric mapping to the physical space $(x,y)$ uses the same $Q_3$ shape functions. For a coupled thermomechanical energy functional, consider exclusively the volumetric thermomechanical coupling term\n$$\n\\mathcal{I}_c[T,\\boldsymbol{u}] \\;=\\; \\int_{\\Omega} \\beta\\,T\\,\\nabla\\cdot\\boldsymbol{u}\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\beta$ is a constant coupling coefficient, $T$ is temperature, and $\\boldsymbol{u}$ is displacement. Set $\\beta=1$ so that $\\beta$ carries no units. Use the standard isoparametric change of variables from the physical domain $\\Omega$ to the reference domain, and the identity $J^{-1}\\det J = \\operatorname{adj}(\\mathbf{J})^{\\top}$, where $\\mathbf{J}$ is the Jacobian of the mapping, $\\det J$ is its determinant, and $\\operatorname{adj}(\\mathbf{J})$ is its adjugate. The coupling integral transforms as\n$$\n\\mathcal{I}_c[T,\\boldsymbol{u}] \\;=\\; \\int_{-1}^1 \\int_{-1}^1 T(\\xi,\\eta)\\,\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J}(\\xi,\\eta))^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}(\\xi,\\eta)\\right)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\n$$\nwhich is a bivariate polynomial when $T$ and $\\boldsymbol{u}$ are $Q_3$ and the geometry is isoparametric $Q_3$. Here $\\nabla_{\\xi}\\boldsymbol{u}$ denotes the $2\\times 2$ matrix whose columns are the derivatives of $\\boldsymbol{u}$ with respect to $\\xi$ and $\\eta$, respectively.\n\nYour task is to determine, from first principles, the minimal one-dimensional Gaussâ€“Legendre (GL) quadrature order $p$ per direction required to integrate $\\mathcal{I}_c$ exactly and thereby avoid artificial coupling caused by quadrature error. Use the fundamental fact that a one-dimensional GL rule with $p$ points integrates exactly all polynomials up to degree $2p-1$ in one dimension, and that the tensor-product GL rule in two dimensions is exact for any bivariate polynomial whose degree in each variable does not exceed $2p-1$.\n\nWork in two test cases that collectively form the test suite:\n\n- Test Case A (curved cubic geometry): The physical coordinates $(x(\\xi,\\eta),y(\\xi,\\eta))$ are prescribed by the following $Q_3$-representable polynomials,\n$$\n\\begin{aligned}\nx(\\xi,\\eta) &= 1 + \\xi + 0.1\\,\\eta + 0.15\\,\\xi\\eta + 0.05\\,\\xi^3 - 0.04\\,\\eta^3,\\\\\ny(\\xi,\\eta) &= -0.2 + 0.2\\,\\xi + \\eta + 0.07\\,\\xi^2 - 0.05\\,\\eta^2 + 0.03\\,\\xi^2\\eta.\n\\end{aligned}\n$$\nThese expressions define the physical nodal coordinates by evaluation at the $Q_3$ nodal locations $(\\xi,\\eta)\\in\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}^2$. The temperature and displacement fields are $Q_3$-interpolated from nodal values obtained by sampling the following polynomials:\n$$\n\\begin{aligned}\nT(\\xi,\\eta) &= 0.7 + 0.9\\,\\xi - 0.6\\,\\eta + 0.5\\,\\xi^2 + 0.3\\,\\xi\\eta - 0.4\\,\\eta^2 + 0.2\\,\\xi^3 - 0.25\\,\\xi^2\\eta + 0.15\\,\\xi\\eta^2 + 0.1\\,\\eta^3,\\\\\nu_x(\\xi,\\eta) &= 0.4 - 0.5\\,\\xi + 0.6\\,\\eta + 0.3\\,\\xi^2 - 0.2\\,\\xi\\eta + 0.1\\,\\eta^2 + 0.05\\,\\xi^3 - 0.07\\,\\xi^2\\eta + 0.02\\,\\xi\\eta^2,\\\\\nu_y(\\xi,\\eta) &= -0.2 + 0.3\\,\\xi - 0.4\\,\\eta + 0.25\\,\\xi^2 + 0.05\\,\\xi\\eta - 0.15\\,\\eta^2 + 0.08\\,\\eta^3 + 0.04\\,\\xi^3.\n\\end{aligned}\n$$\n\n- Test Case B (affine geometry): The physical coordinates are bilinear (and therefore exactly representable by the $Q_3$ isoparametric mapping),\n$$\nx(\\xi,\\eta) = 1.2 + 1.0\\,\\xi + 0.2\\,\\eta,\\qquad y(\\xi,\\eta) = -0.3 + 0.1\\,\\xi + 0.9\\,\\eta,\n$$\nwith the same $T(\\xi,\\eta)$, $u_x(\\xi,\\eta)$, and $u_y(\\xi,\\eta)$ as in Test Case A for generating nodal values.\n\nIn both cases, use the $Q_3$ Lagrange interpolation on the tensor grid $\\{-1,-\\tfrac{1}{3},\\tfrac{1}{3},1\\}^2$ to define the isoparametric geometry and fields. Implement the $Q_3$ shape functions and their first derivatives with respect to $\\xi$ and $\\eta$. For the integrand, use the identity\n$$\n\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J})^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}\\right) \\;=\\; y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta},\n$$\nwhere commas denote partial derivatives with respect to the indicated parameter.\n\nDerive from first principles the maximal polynomial degree per variable in the coupling integrand for both Test Case A and Test Case B, and from that, determine the minimal $p$ such that $2p-1$ is at least that maximal degree in each variable. Then, verify the prediction numerically by scanning $p$ upward and comparing the numerical integral $\\mathcal{I}_c$ against a high-order reference computed with $p_{\\mathrm{ref}}=20$. Declare the smallest $p$ that attains agreement within an absolute tolerance of $10^{-11}$ as the discovered minimal order.\n\nYour program must output a single line with a comma-separated list inside square brackets containing, in order:\n- the theoretically predicted minimal $p$ for Test Case A as an integer,\n- the discovered minimal $p$ for Test Case A as an integer,\n- a boolean indicating whether the discovered minimal $p$ matches the theoretical prediction for Test Case A,\n- the theoretically predicted minimal $p$ for Test Case B as an integer,\n- the discovered minimal $p$ for Test Case B as an integer,\n- a boolean indicating whether the discovered minimal $p$ matches the theoretical prediction for Test Case B,\n- a boolean indicating whether under-integration by one order below the predicted minimal $p$ in Test Case A causes a non-negligible discrepancy (absolute error greater than $10^{-8}$) relative to the reference,\n- a boolean indicating the analogous under-integration discrepancy in Test Case B.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6,result7,result8]\"). No additional text should be printed.", "solution": "### Step 1: Extract Givens\n- **Element Type**: A single $Q_3$ isoparametric quadrilateral element.\n- **Reference Domain**: A square in parametric coordinates $(\\xi, \\eta)$ where $\\xi \\in [-1, 1]$ and $\\eta \\in [-1, 1]$.\n- **Interpolation Basis**: Tensor-product of one-dimensional Lagrange polynomials of degree $3$.\n- **1D Nodal Coordinates**: The set of points $\\{ -1, -\\frac{1}{3}, \\frac{1}{3}, 1 \\}$ in each parametric direction $\\xi$ and $\\eta$.\n- **Coupling Integral**: The volumetric thermomechanical coupling term is $\\mathcal{I}_c[T,\\boldsymbol{u}] = \\int_{\\Omega} \\beta\\,T\\,\\nabla\\cdot\\boldsymbol{u}\\,\\mathrm{d}\\Omega$.\n- **Coupling Coefficient**: $\\beta=1$.\n- **Transformed Integral**: In the reference domain, the integral is $\\mathcal{I}_c = \\int_{-1}^1 \\int_{-1}^1 T(\\xi,\\eta)\\,\\mathrm{tr}\\!\\left(\\operatorname{adj}(\\mathbf{J}(\\xi,\\eta))^{\\top}\\,\\nabla_{\\xi} \\boldsymbol{u}(\\xi,\\eta)\\right)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$.\n- **Integrand Identity**: The trace term expands to $\\mathrm{tr}(\\dots) = y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta}$, where the comma denotes a partial derivative (e.g., $y_{,\\eta} = \\partial y / \\partial \\eta$).\n- **Quadrature Rule**: A one-dimensional Gauss-Legendre (GL) rule with $p$ points integrates polynomials of degree up to $2p-1$ exactly. A tensor-product GL rule is exact for bivariate polynomials if the degree in each variable is at most $2p-1$.\n- **Task**: Determine the theoretically minimal GL quadrature order $p$ for exact integration and verify it numerically.\n- **Test Case A (Curved Geometry)**:\n  - $x(\\xi,\\eta) = 1 + \\xi + 0.1\\,\\eta + 0.15\\,\\xi\\eta + 0.05\\,\\xi^3 - 0.04\\,\\eta^3$\n  - $y(\\xi,\\eta) = -0.2 + 0.2\\,\\xi + \\eta + 0.07\\,\\xi^2 - 0.05\\,\\eta^2 + 0.03\\,\\xi^2\\eta$\n  - $T(\\xi,\\eta) = 0.7 + 0.9\\,\\xi - 0.6\\,\\eta + 0.5\\,\\xi^2 + 0.3\\,\\xi\\eta - 0.4\\,\\eta^2 + 0.2\\,\\xi^3 - 0.25\\,\\xi^2\\eta + 0.15\\,\\xi\\eta^2 + 0.1\\,\\eta^3$\n  - $u_x(\\xi,\\eta) = 0.4 - 0.5\\,\\xi + 0.6\\,\\eta + 0.3\\,\\xi^2 - 0.2\\,\\xi\\eta + 0.1\\,\\eta^2 + 0.05\\,\\xi^3 - 0.07\\,\\xi^2\\eta + 0.02\\,\\xi\\eta^2$\n  - $u_y(\\xi,\\eta) = -0.2 + 0.3\\,\\xi - 0.4\\,\\eta + 0.25\\,\\xi^2 + 0.05\\,\\xi\\eta - 0.15\\,\\eta^2 + 0.08\\,\\eta^3 + 0.04\\,\\xi^3$\n- **Test Case B (Affine Geometry)**:\n  - $x(\\xi,\\eta) = 1.2 + 1.0\\,\\xi + 0.2\\,\\eta$\n  - $y(\\xi,\\eta) = -0.3 + 0.1\\,\\xi + 0.9\\,\\eta$\n  - $T, u_x, u_y$ are the same as in Test Case A.\n- **Numerical Verification**: Compare results from scanning $p$ upward against a reference integral computed with $p_{\\mathrm{ref}}=20$. Agreement is defined by an absolute tolerance of $10^{-11}$. Under-integration discrepancy is checked with an absolute tolerance of $10^{-8}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation:\n- **Scientifically Grounded**: The problem is rooted in the Finite Element Method (FEM), specifically concerning isoparametric mapping and numerical quadrature, which are standard, well-established topics in computational mechanics and applied mathematics. The equations and concepts are correct.\n- **Well-Posed**: The problem asks for the determination of a specific integer, the quadrature order $p$, based on a clear criterion (exact integration of a polynomial). This is a well-defined mathematical task with a unique solution. The numerical verification procedure is also unambiguously specified.\n- **Objective**: The problem is stated in precise, formal, and unbiased language.\n- **Incomplete or Contradictory Setup**: The problem provides all necessary information, including the element definition, explicit polynomial forms for geometry and fields, the integral expression, the property of the quadrature rule, and tolerances for numerical checks. There are no apparent contradictions.\n- **Unrealistic or Infeasible**: The setup represents a standard, albeit complex, academic exercise in FEM. The polynomial coefficients are arbitrary but do not pose any physical or mathematical absurdity.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is a rigorous and self-contained problem in computational engineering science. A detailed solution will be provided.\n\n### Principle-Based Solution\n\nThe objective is to find the minimum number of Gauss-Legendre quadrature points, $p$, required per direction to exactly integrate the thermomechanical coupling term $\\mathcal{I}_c$ over a $Q_3$ isoparametric element. The governing principle is that a $p$-point Gauss-Legendre rule integrates any one-dimensional polynomial of degree up to $2p-1$ exactly. For the two-dimensional tensor-product rule used here, exactness is achieved if the integrand's polynomial degree in each variable, $\\xi$ and $\\eta$, does not exceed $2p-1$.\n\nLet $d(f) = (\\deg_{\\xi}(f), \\deg_{\\eta}(f))$ denote the pair of maximal polynomial degrees of a function $f(\\xi, \\eta)$ in each of its variables. The degree of a product of polynomials is the sum of their degrees, $d(fg) = d(f) + d(g)$, and the degree of a sum of polynomials is the component-wise maximum of their degrees.\n\nThe integrand is given by $I(\\xi, \\eta) = T(\\xi, \\eta) \\cdot S(\\xi, \\eta)$, where $S(\\xi, \\eta) = y_{,\\eta}\\,u_{x,\\xi} + x_{,\\xi}\\,u_{y,\\eta} - y_{,\\xi}\\,u_{y,\\xi} - x_{,\\eta}\\,u_{x,\\eta}$. The degree of the integrand is $d(I) = d(T) + d(S)$.\n\nThe geometry $(x, y)$ and fields $(T, u_x, u_y)$ are defined by $Q_3$ Lagrange interpolation. The provided analytic expressions for these quantities are polynomials of bi-degree at most $(3, 3)$ and are therefore exactly representable by the $Q_3$ basis. We can thus work directly with the degrees of the given polynomials.\n\n#### Test Case A: Curved Cubic Geometry\nFirst, we determine the degrees of the geometry, fields, and their derivatives.\n\n- $d(x) = (3, 3) \\implies d(x_{,\\xi}) = (2, 3), d(x_{,\\eta}) = (3, 2)$\n- $d(y) = (2, 2) \\implies d(y_{,\\xi}) = (1, 2), d(y_{,\\eta}) = (2, 1)$\n- $d(T) = (3, 3)$\n- $d(u_x) = (3, 2) \\implies d(u_{x,\\xi}) = (2, 2), d(u_{x,\\eta}) = (3, 1)$\n- $d(u_y) = (3, 3) \\implies d(u_{y,\\xi}) = (2, 3), d(u_{y,\\eta}) = (3, 2)$\n\nNext, we find the degree of each term in $S(\\xi, \\eta)$:\n1.  $d(y_{,\\eta} u_{x,\\xi}) = d(y_{,\\eta}) + d(u_{x,\\xi}) = (2, 1) + (2, 2) = (4, 3)$\n2.  $d(x_{,\\xi} u_{y,\\eta}) = d(x_{,\\xi}) + d(u_{y,\\eta}) = (2, 3) + (3, 2) = (5, 5)$\n3.  $d(y_{,\\xi} u_{y,\\xi}) = d(y_{,\\xi}) + d(u_{y,\\xi}) = (1, 2) + (2, 3) = (3, 5)$\n4.  $d(x_{,\\eta} u_{x,\\eta}) = d(x_{,\\eta}) + d(u_{x,\\eta}) = (3, 2) + (3, 1) = (6, 3)$\n\nThe degree of $S(\\xi, \\eta)$ is the component-wise maximum of the degrees of its terms:\n$d(S) = (\\max(4, 5, 3, 6), \\max(3, 5, 5, 3)) = (6, 5)$.\n\nThe degree of the full integrand $I(\\xi, \\eta) = T \\cdot S$ is:\n$d(I) = d(T) + d(S) = (3, 3) + (6, 5) = (9, 8)$.\n\nThe maximal polynomial degree to be integrated is $d_{\\max} = \\max(9, 8) = 9$. To ensure exact integration, we require:\n$2p_A - 1 \\ge d_{\\max} \\implies 2p_A - 1 \\ge 9 \\implies 2p_A \\ge 10 \\implies p_A \\ge 5$.\nThe minimal integer order is $p_A = 5$.\n\n#### Test Case B: Affine Geometry\nThe analysis is repeated for the affine geometry. The fields $T, u_x, u_y$ and their derivatives have the same degrees as in Case A. The geometry is now bilinear.\n\n- $d(x) = (1, 1) \\implies d(x_{,\\xi}) = (0, 0), d(x_{,\\eta}) = (0, 0)$ (since $x_{,\\xi}=1.0, x_{,\\eta}=0.2$)\n- $d(y) = (1, 1) \\implies d(y_{,\\xi}) = (0, 0), d(y_{,\\eta}) = (0, 0)$ (since $y_{,\\xi}=0.1, y_{,\\eta}=0.9$)\n\nThe geometry derivatives are constants (degree $0$). The degrees of the terms in $S(\\xi, \\eta)$ are now determined solely by the field derivatives:\n1.  $d(y_{,\\eta} u_{x,\\xi}) = (0,0) + (2,2) = (2, 2)$\n2.  $d(x_{,\\xi} u_{y,\\eta}) = (0,0) + (3,2) = (3, 2)$\n3.  $d(y_{,\\xi} u_{y,\\xi}) = (0,0) + (2,3) = (2, 3)$\n4.  $d(x_{,\\eta} u_{x,\\eta}) = (0,0) + (3,1) = (3, 1)$\n\nThe degree of $S(\\xi, \\eta)$ becomes:\n$d(S) = (\\max(2, 3, 2, 3), \\max(2, 2, 3, 1)) = (3, 3)$.\n\nThe degree of the full integrand $I(\\xi, \\eta) = T \\cdot S$ is:\n$d(I) = d(T) + d(S) = (3, 3) + (3, 3) = (6, 6)$.\n\nThe maximal polynomial degree to be integrated is $d_{\\max} = \\max(6, 6) = 6$. The requirement for exact integration is:\n$2p_B - 1 \\ge d_{\\max} \\implies 2p_B - 1 \\ge 6 \\implies 2p_B \\ge 7 \\implies p_B \\ge 3.5$.\nThe minimal integer order is $p_B = 4$.\n\n#### Summary of Theoretical Predictions\n- For Test Case A (curved geometry), the theoretically predicted minimal quadrature order is $p_A = 5$.\n- For Test Case B (affine geometry), the theoretically predicted minimal quadrature order is $p_B = 4$.\n\nThese predictions will be confirmed by the numerical implementation.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\nclass Q3Evaluator:\n    \"\"\"\n    Evaluates Q3 fields and their derivatives based on nodal values.\n    The interpolation is based on 1D Lagrange polynomials over the nodes\n    [-1, -1/3, 1/3, 1].\n    \"\"\"\n    def __init__(self):\n        self.nodes_1d = np.array([-1.0, -1.0/3.0, 1.0/3.0, 1.0])\n        self.num_nodes_1d = len(self.nodes_1d)\n        degree = self.num_nodes_1d - 1\n\n        self.L_polys = []\n        self.L_prime_polys = []\n\n        for i in range(self.num_nodes_1d):\n            y = np.zeros(self.num_nodes_1d)\n            y[i] = 1.0\n            # Use np.polyfit to find coefficients of the Lagrange polynomial\n            coeffs = np.polyfit(self.nodes_1d, y, degree)\n            poly = np.poly1d(coeffs)\n            self.L_polys.append(poly)\n            self.L_prime_polys.append(poly.deriv())\n\n    def eval_1d_basis(self, xi):\n        \"\"\"Evaluates 1D basis functions and their derivatives at a point xi.\"\"\"\n        L_vals = np.array([p(xi) for p in self.L_polys])\n        L_prime_vals = np.array([dp(xi) for dp in self.L_prime_polys])\n        return L_vals, L_prime_vals\n\n    def evaluate_field(self, xi, eta, nodal_values):\n        \"\"\"Evaluates a field given its 4x4 nodal values.\"\"\"\n        L_xi, _ = self.eval_1d_basis(xi)\n        L_eta, _ = self.eval_1d_basis(eta)\n        # Tensor product summation: value = sum_{i,j} nodal_values[i,j] * L_i(xi) * L_j(eta)\n        # Note: numpy einsum is efficient, but nodal_values should be (i,j)\n        # corresponding to (xi, eta) directions. We will use (eta, xi) for ij indexing.\n        return np.einsum('j,i,ij->', L_eta, L_xi, nodal_values)\n\n    def evaluate_derivatives(self, xi, eta, nodal_values):\n        \"\"\"Evaluates field derivatives w.r.t. xi and eta.\"\"\"\n        L_xi, L_prime_xi = self.eval_1d_basis(xi)\n        L_eta, L_prime_eta = self.eval_1d_basis(eta)\n        \n        # Derivative w.r.t. xi\n        deriv_xi = np.einsum('j,i,ij->', L_eta, L_prime_xi, nodal_values)\n        # Derivative w.r.t. eta\n        deriv_eta = np.einsum('j,i,ij->', L_prime_eta, L_xi, nodal_values)\n        \n        return deriv_xi, deriv_eta\n\ndef get_nodal_values(poly_func, evaluator):\n    \"\"\"Samples a polynomial function at the Q3 nodes.\"\"\"\n    nodal_values = np.zeros((evaluator.num_nodes_1d, evaluator.num_nodes_1d))\n    for i, xi_node in enumerate(evaluator.nodes_1d):\n        for j, eta_node in enumerate(evaluator.nodes_1d):\n            nodal_values[j, i] = poly_func(xi_node, eta_node)\n    return nodal_values\n\ndef compute_integral(p_order, integrand_func):\n    \"\"\"Performs 2D Gauss-Legendre quadrature.\"\"\"\n    points, weights = roots_legendre(p_order)\n    integral_val = 0.0\n    for i in range(p_order):\n        for j in range(p_order):\n            xi, w_xi = points[i], weights[i]\n            eta, w_eta = points[j], weights[j]\n            integrand_val = integrand_func(xi, eta)\n            integral_val += w_xi * w_eta * integrand_val\n    return integral_val\n\ndef solve():\n    \"\"\"Main solver function to perform the analysis for both test cases.\"\"\"\n    \n    # Polynomial definitions from the problem statement\n    polys = {\n        'A': {\n            'x': lambda xi, eta: 1 + xi + 0.1*eta + 0.15*xi*eta + 0.05*xi**3 - 0.04*eta**3,\n            'y': lambda xi, eta: -0.2 + 0.2*xi + eta + 0.07*xi**2 - 0.05*eta**2 + 0.03*xi**2*eta,\n        },\n        'B': {\n            'x': lambda xi, eta: 1.2 + 1.0*xi + 0.2*eta,\n            'y': lambda xi, eta: -0.3 + 0.1*xi + 0.9*eta,\n        },\n        'fields': {\n            'T': lambda xi, eta: 0.7 + 0.9*xi - 0.6*eta + 0.5*xi**2 + 0.3*xi*eta - 0.4*eta**2 + 0.2*xi**3 - 0.25*xi**2*eta + 0.15*xi*eta**2 + 0.1*eta**3,\n            'ux': lambda xi, eta: 0.4 - 0.5*xi + 0.6*eta + 0.3*xi**2 - 0.2*xi*eta + 0.1*eta**2 + 0.05*xi**3 - 0.07*xi**2*eta + 0.02*xi*eta**2,\n            'uy': lambda xi, eta: -0.2 + 0.3*xi - 0.4*eta + 0.25*xi**2 + 0.05*xi*eta - 0.15*eta**2 + 0.08*eta**3 + 0.04*xi**3,\n        }\n    }\n    \n    test_cases = [\n        ('A', polys['A'], 5),\n        ('B', polys['B'], 4),\n    ]\n\n    all_results = []\n\n    for case_name, geo_polys, p_theory in test_cases:\n        evaluator = Q3Evaluator()\n        \n        # Generate nodal values for all functions\n        x_nodes = get_nodal_values(geo_polys['x'], evaluator)\n        y_nodes = get_nodal_values(geo_polys['y'], evaluator)\n        T_nodes = get_nodal_values(polys['fields']['T'], evaluator)\n        ux_nodes = get_nodal_values(polys['fields']['ux'], evaluator)\n        uy_nodes = get_nodal_values(polys['fields']['uy'], evaluator)\n        \n        def integrand(xi, eta):\n            T_val = evaluator.evaluate_field(xi, eta, T_nodes)\n            x_dxi, x_deta = evaluator.evaluate_derivatives(xi, eta, x_nodes)\n            y_dxi, y_deta = evaluator.evaluate_derivatives(xi, eta, y_nodes)\n            ux_dxi, ux_deta = evaluator.evaluate_derivatives(xi, eta, ux_nodes)\n            uy_dxi, uy_deta = evaluator.evaluate_derivatives(xi, eta, uy_nodes)\n            \n            trace_term = y_deta * ux_dxi + x_dxi * uy_deta - y_dxi * uy_dxi - x_deta * ux_deta\n            \n            return T_val * trace_term\n            \n        # Compute reference integral\n        p_ref = 20\n        ref_integral = compute_integral(p_ref, integrand)\n        \n        # Find minimal p for convergence\n        p_discovered = -1\n        for p in range(1, p_ref):\n            current_integral = compute_integral(p, integrand)\n            if np.isclose(current_integral, ref_integral, atol=1e-11, rtol=0):\n                p_discovered = p\n                break\n        \n        # Check for under-integration discrepancy\n        p_under = p_theory - 1\n        if p_under > 0:\n            under_integral = compute_integral(p_under, integrand)\n            under_int_discrepancy = abs(under_integral - ref_integral) > 1e-8\n        else:\n            under_int_discrepancy = True # p_under=0 is definitely an under-integration\n\n        all_results.append({\n            'p_theory': p_theory,\n            'p_discovered': p_discovered,\n            'match': p_discovered == p_theory,\n            'under_int_discrepancy': under_int_discrepancy\n        })\n\n    # Format final output string\n    final_list = [\n        all_results[0]['p_theory'], all_results[0]['p_discovered'], all_results[0]['match'],\n        all_results[1]['p_theory'], all_results[1]['p_discovered'], all_results[1]['match'],\n        all_results[0]['under_int_discrepancy'], all_results[1]['under_int_discrepancy']\n    ]\n\n    formatted_results = []\n    for item in final_list:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3525420"}, {"introduction": "Many multiphysics problems, like coupled fluid flow and heat transport, rely on accurately modeling vector flux fields that must obey local conservation laws. This practice demonstrates how to correctly map such fields from the reference domain to a curved physical element using the Piola transformation, which is essential for H(div)-conforming elements. By numerically verifying the divergence theorem, you will solidify your understanding of how to construct discretizations that are inherently conservative, a critical feature for the stability and physical fidelity of transport models [@problem_id:3525417].", "problem": "Consider the steady coupled Darcyâ€“heat transport problem on a single two-dimensional curvilinear quadrilateral element. The fluid mass conservation is governed by the divergence form and the heat transport includes an advective contribution. The discretization is mixed, using the Sobolev space of square-integrable divergence (H(div)) for the Darcy flux and the first-order Sobolev space (H$^1$) for the temperature. The geometry is represented by an isoparametric bilinear mapping from the reference square using bilinear shape functions.\n\nStarting from the following fundamental base and core definitions:\n- The divergence theorem for a vector field states that the integral of the divergence over a domain equals the outward normal flux integrated over the boundary.\n- The isoparametric concept maps the reference element to the physical element using the same family of shape functions for geometry and fields.\n- Mixed Raviartâ€“Thomas of lowest order (piecewise-constant normal flux per face on the reference element) in H(div) supports normal-flux degrees of freedom and piecewise-constant divergence.\n- The heat transport uses an H$^1$ space with bilinear shape functions for temperature, enabling computation of gradients within elements.\n\nYou are to implement a computational check of local conservation on curved (non-affine) quadrilateral elements by:\n1. Representing the physical quadrilateral using the isoparametric bilinear map from the reference square with coordinates $(\\xi,\\eta) \\in [-1,1]^2$.\n2. Constructing a lowest-order Raviartâ€“Thomas flux on the reference element whose normal flux is constant on each reference face. Let the reference flux be a vector field of the form $\\hat{\\boldsymbol{q}}(\\xi,\\eta) = [a + b\\,\\xi,\\;c + d\\,\\eta]$, with face-integrated normal flux degrees of freedom prescribed on the four reference faces. The integral of the divergence over the reference element is then constant and must equal the sum of face-integrated normal fluxes, by the divergence theorem.\n3. Mapping the reference flux to the physical element by the isoparametric bilinear map and the associated transformation appropriate to H(div), and computing the outward normal flux integrated along the physical boundary (taken in counterclockwise orientation).\n4. Defining a source term in the physical coordinates such that local conservation holds at the continuous level. Then, numerically evaluating the area integral of the source over the physical element and comparing with the boundary flux integral, thereby verifying local conservation numerically.\n5. Including an H$^1$ temperature field using bilinear shape functions on the same geometry and computing its gradient, thereby demonstrating the mixed H(div)/H$^1$ discretization context. The advective term need not be reported; it is sufficient to compute the gradient internally to ensure the gradient calculation is consistent with the mapping.\n\nYour program must:\n- Implement the bilinear isoparametric map with shape functions $N_i(\\xi,\\eta)$ for the quadrilateral vertices, and compute the Jacobian $\\boldsymbol{J}(\\xi,\\eta)$ and its determinant.\n- Construct the reference Raviartâ€“Thomas coefficients $(a,b,c,d)$ from prescribed face-integrated normal fluxes on the reference element.\n- Map the reference flux to the physical element and perform numerical quadrature:\n  - For the boundary flux integral, integrate $ \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n}\\, \\mathrm{d}s $ by parameterizing the four physical edges in counterclockwise orientation and using the rotated tangent formula for the outward normal measure.\n  - For the source term integral, integrate $ \\int_{\\Omega} f\\, \\mathrm{d}\\Omega $ using quadrature over the reference square with the appropriate Jacobian determinant weighting.\n- Return, for each test case, the absolute residual $R = \\left| \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n}\\,\\mathrm{d}s \\;-\\; \\int_{\\Omega} f\\, \\mathrm{d}\\Omega \\right|$ as a floating-point number.\n\nAll quantities are to be treated as dimensionless for this exercise; no physical units are required. Angles do not appear and need not be specified. Your program must produce a single line of output containing the residuals for all test cases as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$).\n\nUse the following bilinear shape functions on the reference square:\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\nDefine the reference Raviartâ€“Thomas face-integrated normal flux degrees of freedom as four given numbers on the left, right, bottom, and top faces, respectively. The reference vector field is $\\hat{\\boldsymbol{q}}(\\xi,\\eta) = [a + b\\,\\xi,\\;c + d\\,\\eta]$, where $(a,b,c,d)$ are determined uniquely by those four prescribed face-integrated fluxes.\n\nFor the source term, define $f(\\boldsymbol{x}(\\xi,\\eta))$ such that $f(\\boldsymbol{x}(\\xi,\\eta)) = \\dfrac{b+d}{\\det \\boldsymbol{J}(\\xi,\\eta)}$, which ensures that the physically mapped divergence integrates consistently with the boundary flux for any non-affine bilinear map. The program should use Gaussian quadrature with sufficient accuracy on both the element interior and each edge to evaluate the integrals.\n\nTest Suite:\nProvide four test cases, each consisting of the four vertex coordinates of the physical quadrilateral in counterclockwise order and the four reference face-integrated normal fluxes $(F_{\\text{left}},F_{\\text{right}},F_{\\text{bottom}},F_{\\text{top}})$:\n\n- Case $1$ (non-affine, warped quadrilateral; general \"happy path\"):\n  - Vertices: $(0,0)$, $(2,0.2)$, $(2.1,1.9)$, $(0.1,2.0)$.\n  - Reference face-integrated fluxes: $F_{\\text{left}} = 0.7$, $F_{\\text{right}} = 1.1$, $F_{\\text{bottom}} = -0.4$, $F_{\\text{top}} = 0.2$.\n\n- Case $2$ (affine parallelogram; constant Jacobian determinant):\n  - Vertices: $(0,0)$, $(1.5,0.0)$, $(2.2,1.0)$, $(0.7,1.0)$.\n  - Reference face-integrated fluxes: $F_{\\text{left}} = -0.3$, $F_{\\text{right}} = 0.6$, $F_{\\text{bottom}} = 0.15$, $F_{\\text{top}} = -0.05$.\n\n- Case $3$ (skewed but valid; zero flux edge case):\n  - Vertices: $(0,0)$, $(1.0,0.0)$, $(1.1,0.2)$, $(0.2,1.1)$.\n  - Reference face-integrated fluxes: $F_{\\text{left}} = 0.0$, $F_{\\text{right}} = 0.0$, $F_{\\text{bottom}} = 0.0$, $F_{\\text{top}} = 0.0$.\n\n- Case $4$ (strongly warped quadrilateral; sensitive Jacobian variation):\n  - Vertices: $(0,0)$, $(2.0,-0.2)$, $(2.2,1.8)$, $(0.0,2.1)$.\n  - Reference face-integrated fluxes: $F_{\\text{left}} = 1.0$, $F_{\\text{right}} = -0.5$, $F_{\\text{bottom}} = 0.3$, $F_{\\text{top}} = -0.1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of floating-point residuals for Cases $1$ to $4$, enclosed in square brackets; for example, $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the absolute residual defined above. No other text should be printed.", "solution": "The user-provided problem is a valid, well-posed computational exercise in the field of numerical methods for partial differential equations, specifically the finite element method (FEM). It requires the implementation and verification of fundamental concepts related to isoparametric mapping of H(div)-conforming vector fields. The problem is scientifically sound, self-contained, and all data and definitions required for its solution are provided. We will proceed with a full solution.\n\nThe core of the problem is to numerically verify the divergence theorem on a single, general curvilinear quadrilateral element. The theorem states that for a sufficiently smooth vector field $\\boldsymbol{q}$ on a domain $\\Omega$ with boundary $\\partial \\Omega$, the following identity holds:\n$$\n\\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{q}) \\, d\\Omega = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds\n$$\nwhere $\\boldsymbol{n}$ is the outward unit normal to the boundary. The problem defines a source term $f = \\nabla \\cdot \\boldsymbol{q}$, so the identity to be verified is $\\int_{\\Omega} f \\, d\\Omega = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds$. The verification consists of computing both integrals independently through numerical quadrature and comparing the results.\n\nHere is a step-by-step derivation and explanation of the required computations.\n\n### 1. Isoparametric Mapping and Geometric Factors\n\nThe geometry of the physical quadrilateral element $\\Omega$ is described by an isoparametric mapping from a reference square $\\hat{\\Omega} = [-1,1]^2$ with local coordinates $(\\xi, \\eta)$. The mapping $\\boldsymbol{x}: \\hat{\\Omega} \\to \\Omega$ is given by:\n$$\n\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\nwhere $\\boldsymbol{x}_i = (x_i, y_i)$ are the coordinates of the four vertices of the physical element, and $N_i$ are the bilinear shape functions provided:\n$$\nN_1 = \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2 = \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\quad N_3 = \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4 = \\tfrac{1}{4}(1-\\xi)(1+\\eta)\n$$\nThe transformation's local behavior is characterized by the Jacobian matrix $\\boldsymbol{J}$, whose components are the partial derivatives of the mapping function:\n$$\n\\boldsymbol{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} x_i & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} x_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} y_i & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{pmatrix}\n$$\nThe determinant of the Jacobian, $\\det \\boldsymbol{J}$, relates the differential area elements: $d\\Omega = \\det \\boldsymbol{J}(\\xi, \\eta) \\, d\\xi d\\eta$.\n\n### 2. Lowest-Order Raviartâ€“Thomas (RT$_0$) Flux\n\nOn the reference element, a vector field $\\hat{\\boldsymbol{q}}$ is defined in the lowest-order Raviartâ€“Thomas space. Its form is given as:\n$$\n\\hat{\\boldsymbol{q}}(\\xi, \\eta) = \\begin{pmatrix} a + b\\xi \\\\ c + d\\eta \\end{pmatrix}\n$$\nThe four coefficients $(a,b,c,d)$ are uniquely determined by the four degrees of freedom, which are the integrated normal fluxes over the four faces of the reference square. Let the prescribed fluxes be $F_{\\text{left}}, F_{\\text{right}}, F_{\\text{bottom}}, F_{\\text{top}}$. The relations are:\n- Left face $(\\xi=-1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(-1, \\eta) \\cdot \\begin{pmatrix}-1 \\\\ 0\\end{pmatrix} d\\eta = \\int_{-1}^1 -(a-b) \\, d\\eta = -2(a-b) = F_{\\text{left}}$\n- Right face $(\\xi=1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(1, \\eta) \\cdot \\begin{pmatrix}1 \\\\ 0\\end{pmatrix} d\\eta = \\int_{-1}^1 (a+b) \\, d\\eta = 2(a+b) = F_{\\text{right}}$\n- Bottom face $(\\eta=-1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(\\xi, -1) \\cdot \\begin{pmatrix}0 \\\\ -1\\end{pmatrix} d\\xi = \\int_{-1}^1 -(c-d) \\, d\\xi = -2(c-d) = F_{\\text{bottom}}$\n- Top face $(\\eta=1)$: $\\int_{-1}^1 \\hat{\\boldsymbol{q}}(\\xi, 1) \\cdot \\begin{pmatrix}0 \\\\ 1\\end{pmatrix} d\\xi = \\int_{-1}^1 (c+d) \\, d\\xi = 2(c+d) = F_{\\text{top}}$\n\nSolving this linear system for the coefficients yields:\n$$\na = \\frac{F_{\\text{right}} - F_{\\text{left}}}{4}, \\quad b = \\frac{F_{\\text{right}} + F_{\\text{left}}}{4}, \\quad c = \\frac{F_{\\text{top}} - F_{\\text{bottom}}}{4}, \\quad d = \\frac{F_{\\text{top}} + F_{\\text{bottom}}}{4}\n$$\n\n### 3. Source Term and its Integral\n\nThe source term $f$ is defined to ensure local conservation, $f = \\nabla \\cdot \\boldsymbol{q}$. The divergence of an H(div) field transforms from the reference element via the Piola identity: $\\nabla \\cdot \\boldsymbol{q} = (\\det \\boldsymbol{J})^{-1} (\\hat{\\nabla} \\cdot \\hat{\\boldsymbol{q}})$. For our reference field, the divergence is $\\hat{\\nabla} \\cdot \\hat{\\boldsymbol{q}} = \\frac{\\partial}{\\partial\\xi}(a+b\\xi) + \\frac{\\partial}{\\partial\\eta}(c+d\\eta) = b+d$.\nThus, the source term is:\n$$\nf(\\boldsymbol{x}(\\xi, \\eta)) = \\frac{b+d}{\\det \\boldsymbol{J}(\\xi, \\eta)}\n$$\nThe integral of this source term over the physical element $\\Omega$ is computed by changing variables to the reference element $\\hat{\\Omega}$:\n$$\nI_{\\text{src}} = \\int_{\\Omega} f \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 f(\\boldsymbol{x}(\\xi, \\eta)) \\det \\boldsymbol{J}(\\xi, \\eta) \\, d\\xi d\\eta = \\int_{-1}^1 \\int_{-1}^1 \\left(\\frac{b+d}{\\det \\boldsymbol{J}}\\right) \\det \\boldsymbol{J} \\, d\\xi d\\eta = \\int_{-1}^1 \\int_{-1}^1 (b+d) \\, d\\xi d\\eta\n$$\nThis integral evaluates analytically to $4(b+d)$. As per the problem's instruction, it will be computed using 2D Gaussian quadrature to test the integration machinery.\n\n### 4. Boundary Flux Integral\n\nThe boundary integral $I_{\\text{bnd}} = \\int_{\\partial \\Omega} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, ds$ is computed by summing the integrals over the four edges of the physical quadrilateral. The physical flux $\\boldsymbol{q}$ is obtained from the reference flux $\\hat{\\boldsymbol{q}}$ using the Piola transformation for covariant vectors:\n$$\n\\boldsymbol{q}(\\boldsymbol{x}(\\xi, \\eta)) = \\frac{1}{\\det \\boldsymbol{J}(\\xi, \\eta)} \\boldsymbol{J}(\\xi, \\eta) \\hat{\\boldsymbol{q}}(\\xi, \\eta)\n$$\nThe boundary integrals are evaluated by parameterizing each edge and evaluating the dot product of the physical flux with the outward normal differential element. For a path $\\boldsymbol{c}(t)$ traversed counter-clockwise, the outward normal measure is given by $(c_y'(t), -c_x'(t)) \\, dt$. We apply this to each of the four edges, which are parameterized by $\\xi$ or $\\eta$ along the boundary of the reference square. The total boundary flux is the sum of four 1D integrals, which are computed using Gaussian quadrature.\n\n-   **Edge 1 (Bottom, 1â†’2):** $\\eta=-1$, $\\xi \\in [-1,1]$. Normal measure is $(\\frac{\\partial y}{\\partial \\xi}, -\\frac{\\partial x}{\\partial \\xi}) d\\xi$.\n-   **Edge 2 (Right, 2â†’3):** $\\xi=1$, $\\eta \\in [-1,1]$. Normal measure is $(\\frac{\\partial y}{\\partial \\eta}, -\\frac{\\partial x}{\\partial \\eta}) d\\eta$.\n-   **Edge 3 (Top, 3â†’4):** $\\eta=1$. Path is from $\\xi=1$ to $\\xi=-1$. The normal measure is $(-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi}) d\\xi$. The integral runs from $\\xi=1$ to $-1$.\n-   **Edge 4 (Left, 4â†’1):** $\\xi=-1$. Path is from $\\eta=1$ to $\\eta=-1$. The normal measure is $(-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta}) d\\eta$. The integral runs from $\\eta=1$ to $-1$.\n\nThese integrals can be implemented by remapping the integration domain to $[-1,1]$ and applying standard Gaussian quadrature rules.\n\n### 5. H$^1$ (Lagrange) Temperature Field\n\nFor context, the problem requires considering an H$^1$-conforming temperature field, defined using the same bilinear shape functions: $T(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) T_i$, where $T_i$ are nodal temperatures. The physical gradient $\\nabla T$ is related to the reference gradient $\\hat{\\nabla} T$ by $\\nabla T = \\boldsymbol{J}^{-T} \\hat{\\nabla} T$. This calculation is performed internally to demonstrate the full mixed-element context but does not contribute to the final residual.\n\n### 6. Residual Calculation\n\nThe final result is the absolute residual $R = |I_{\\text{bnd}} - I_{\\text{src}}|$. This value should be close to zero, with any non-zero value attributable to the numerical error of the Gaussian quadrature, since the identity holds exactly at the continuous level by construction. Using a sufficiently high order of quadrature will minimize this error.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the local conservation residual for a series of curvilinear quadrilaterals.\n    \"\"\"\n\n    # Defines shape functions and their derivatives on the reference square [-1,1]^2\n    N_funcs = [\n        lambda xi, eta: 0.25 * (1 - xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + xi) * (1 + eta),\n        lambda xi, eta: 0.25 * (1 - xi) * (1 + eta)\n    ]\n    # Derivatives w.r.t. xi\n    dN_dxi_funcs = [\n        lambda xi, eta: -0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 - eta),\n        lambda xi, eta: 0.25 * (1 + eta),\n        lambda xi, eta: -0.25 * (1 + eta)\n    ]\n    # Derivatives w.r.t. eta\n    dN_deta_funcs = [\n        lambda xi, eta: -0.25 * (1 - xi),\n        lambda xi, eta: -0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 + xi),\n        lambda xi, eta: 0.25 * (1 - xi)\n    ]\n\n    class IsoparametricQuad:\n        \"\"\"\n        Handles all calculations related to a single isoparametric quadrilateral element.\n        \"\"\"\n        def __init__(self, vertices, n_quad_pts=16):\n            self.vertices = np.array(vertices) # Shape (4, 2)\n            self.x_coords = self.vertices[:, 0]\n            self.y_coords = self.vertices[:, 1]\n            \n            # Gaussian quadrature points and weights for high precision\n            self.xi_pts, self.w_pts = np.polynomial.legendre.leggauss(n_quad_pts)\n\n        def jacobian(self, xi, eta):\n            \"\"\"Computes the Jacobian matrix at a point (xi, eta) in the reference element.\"\"\"\n            dx_dxi = sum(dNi_dxi(xi, eta) * self.x_coords[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dx_deta = sum(dNi_deta(xi, eta) * self.x_coords[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            dy_dxi = sum(dNi_dxi(xi, eta) * self.y_coords[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dy_deta = sum(dNi_deta(xi, eta) * self.y_coords[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            return np.array([[dx_dxi, dx_deta], [dy_dxi, dy_deta]])\n\n        def jacobian_det(self, xi, eta):\n            \"\"\"Computes the determinant of the Jacobian.\"\"\"\n            J = self.jacobian(xi, eta)\n            return np.linalg.det(J)\n            \n        def compute_temperature_gradient(self, xi, eta, nodal_temps):\n            \"\"\"Computes the physical temperature gradient (for context, not used in residual).\"\"\"\n            J = self.jacobian(xi, eta)\n            det_J = np.linalg.det(J)\n            J_inv_T = (1.0 / det_J) * np.array([[J[1, 1], -J[1, 0]], [-J[0, 1], J[0, 0]]])\n            \n            dT_dxi = sum(dNi_dxi(xi, eta) * nodal_temps[i] for i, dNi_dxi in enumerate(dN_dxi_funcs))\n            dT_deta = sum(dNi_deta(xi, eta) * nodal_temps[i] for i, dNi_deta in enumerate(dN_deta_funcs))\n            \n            grad_T_ref = np.array([dT_dxi, dT_deta])\n            \n            grad_T_phys = J_inv_T @ grad_T_ref\n            return grad_T_phys\n\n\n    def compute_residual(vertices, face_fluxes):\n        \"\"\"\n        Computes the conservation residual for a given element geometry and flux data.\n        R = | integral(div(q)) dV - integral(q.n) dA |\n        \"\"\"\n        F_left, F_right, F_bottom, F_top = face_fluxes\n\n        # 1. Determine Raviart-Thomas coefficients\n        a = (F_right - F_left) / 4.0\n        b = (F_right + F_left) / 4.0\n        c = (F_top - F_bottom) / 4.0\n        d = (F_top + F_bottom) / 4.0\n\n        quad = IsoparametricQuad(vertices)\n\n        # 2. Compute the source integral over the element area\n        # Integrand in reference space is simply (b+d)\n        # Using 2D quadrature as required by the problem statement\n        source_integral = 0.0\n        for i in range(len(quad.xi_pts)):\n            for j in range(len(quad.xi_pts)):\n                w_i = quad.w_pts[i]\n                w_j = quad.w_pts[j]\n                integrand = b + d\n                source_integral += integrand * w_i * w_j\n\n        # This is an internal check for the H1-gradient calculation part of the problem.\n        # This function call is made to satisfy the prompt's requirement but its output is not used further.\n        _ = quad.compute_temperature_gradient(0.5, -0.5, np.array([1.0, 2.0, 3.0, 4.0]))\n\n        # 3. Compute the boundary flux integral\n        def q_phys(xi, eta):\n            q_ref = np.array([a + b * xi, c + d * eta])\n            J = quad.jacobian(xi, eta)\n            det_J = np.linalg.det(J)\n            if abs(det_J) < 1e-12: # Avoid division by zero for degenerate mappings\n                return np.array([0.0, 0.0])\n            return (1.0 / det_J) * (J @ q_ref)\n\n        boundary_integral = 0.0\n        # Edge 1 (bottom: eta = -1)\n        for i, xi in enumerate(quad.xi_pts):\n            eta = -1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([J[1, 0], -J[0, 0]])\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n            \n        # Edge 2 (right: xi = 1)\n        for i, eta in enumerate(quad.xi_pts):\n            xi = 1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([J[1, 1], -J[0, 1]])\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n\n        # Edge 3 (top: eta = 1)\n        for i, xi in enumerate(quad.xi_pts):\n            eta = 1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([-J[1, 0], J[0, 0]]) # Outward normal is opposite to bottom\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n\n        # Edge 4 (left: xi = -1)\n        for i, eta in enumerate(quad.xi_pts):\n            xi = -1.0\n            J = quad.jacobian(xi, eta)\n            normal_measure = np.array([-J[1, 1], J[0, 1]]) # Outward normal is opposite to right\n            boundary_integral += np.dot(q_phys(xi, eta), normal_measure) * quad.w_pts[i]\n            \n        # 4. Compute the absolute residual\n        return abs(boundary_integral - source_integral)\n\n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"vertices\": [(0, 0), (2, 0.2), (2.1, 1.9), (0.1, 2.0)],\n            \"fluxes\": (0.7, 1.1, -0.4, 0.2)\n        },\n        {\n            \"vertices\": [(0, 0), (1.5, 0.0), (2.2, 1.0), (0.7, 1.0)],\n            \"fluxes\": (-0.3, 0.6, 0.15, -0.05)\n        },\n        {\n            \"vertices\": [(0, 0), (1.0, 0.0), (1.1, 0.2), (0.2, 1.1)],\n            \"fluxes\": (0.0, 0.0, 0.0, 0.0)\n        },\n        {\n            \"vertices\": [(0, 0), (2.0, -0.2), (2.2, 1.8), (0.0, 2.1)],\n            \"fluxes\": (1.0, -0.5, 0.3, -0.1)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        residual = compute_residual(case[\"vertices\"], case[\"fluxes\"])\n        results.append(residual)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3525417"}]}