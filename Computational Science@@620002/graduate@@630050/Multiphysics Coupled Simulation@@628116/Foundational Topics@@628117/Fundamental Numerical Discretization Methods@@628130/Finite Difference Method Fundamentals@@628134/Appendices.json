{"hands_on_practices": [{"introduction": "We begin our practical journey with a classic problem in physics and engineering: the one-dimensional wave equation. This exercise guides you through the fundamental process of deriving an explicit finite difference scheme from Taylor series expansions and implementing it to simulate wave propagation [@problem_id:3129202]. The primary goal is to gain hands-on experience with time-stepping methods and to empirically investigate the crucial concept of numerical stability, governed by the Courant-Friedrichs-Lewy (CFL) condition.", "problem": "Consider the one-dimensional wave equation for the displacement $u(x,t)$ of a taut string on the interval $[0,L]$ with fixed ends, governed by the partial differential equation $$u_{tt}(x,t) = c^2 u_{xx}(x,t),$$ where $c$ is the wave speed. The string is held fixed at the ends, meaning the boundary conditions are $u(0,t) = 0$ and $u(L,t) = 0$ for all $t \\ge 0$. The initial displacement is prescribed as $$u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right),$$ and the initial velocity is $$u_t(x,0) = 0.$$ All distances must be treated in meters, times in seconds, and the wave speed $c$ in meters per second. By convention, the sine function uses radians.\n\nYour task is to derive and implement a second-order accurate explicit finite difference method in both space and time for this equation using uniform grid spacings. Start from the fundamental base of Taylor expansion and the definition of central differences to approximate $u_{tt}$ and $u_{xx}$ on a uniform grid and derive the update rule needed to advance the solution from discrete time level $n$ to $n+1$. Do not assume any pre-existing scheme: construct the method directly from the definitions. Treat the two endpoints with the fixed boundary conditions for all time levels. For the very first time step, use a consistent second-order accurate formula based on the given initial position and initial velocity to obtain the solution at time level $n=1$.\n\nEmpirically assess stability using the Courant–Friedrichs–Lewy (CFL) condition by running the scheme for a selection of parameter values and observing whether the numerical solution remains bounded or blows up. Define an empirical blow-up detector as follows: let $M_0$ be the maximum absolute value of $u(x,0)$ over the spatial grid. During time stepping, compute $M_n$, the maximum absolute value over all spatial points at time level $n$. If at any time $M_n$ becomes undefined (not-a-number), infinite, or exceeds $10 M_0$, declare the simulation as unstable (blown up); otherwise, declare it stable. This detector must be implemented in your program.\n\nFor spatial discretization, use a uniform grid of $N_x$ points over $[0,L]$, with spacing $\\Delta x = L/(N_x - 1)$ meters. For temporal discretization, use a uniform time step $\\Delta t$ seconds and simulate up to a final time $T$ seconds. For each test case, compute the boolean stability outcome where $True$ means stable and $False$ means blown up.\n\nImplement your program to run the following test suite that covers a typical case, a boundary case near the CFL limit, and cases beyond the limit:\n- Test $1$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.008$ seconds, $T = 0.5$ seconds.\n- Test $2$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.010$ seconds, $T = 0.5$ seconds.\n- Test $3$: $c = 1.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.015$ seconds, $T = 1.0$ seconds.\n- Test $4$: $c = 2.0$ meters per second, $L = 1.0$ meters, $N_x = 101$, $\\Delta t = 0.010$ seconds, $T = 0.5$ seconds.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_k$ is the boolean stability outcome for Test $k$ computed by your empirical blow-up detector. No additional text should be printed. The output booleans have no physical units. The inputs and computations involving $c$, $L$, $\\Delta x$, $\\Delta t$, and $T$ must consistently use meters and seconds as specified.", "solution": "We begin from the fundamental definitions of central differences obtained via Taylor expansion. On a uniform spatial grid with spacing $\\Delta x$ and a uniform temporal grid with spacing $\\Delta t$, let $x_i = i \\Delta x$ for $i = 0,1,\\dots,N_x-1$ and $t^n = n \\Delta t$ for $n = 0,1,2,\\dots$. Let $u_i^n$ denote the numerical approximation to $u(x_i,t^n)$.\n\nThe second-order central difference approximation for the second temporal derivative at the point $(x_i,t^n)$ follows from the Taylor expansions\n$$u(x_i,t^{n\\pm 1}) = u(x_i,t^n) \\pm \\Delta t \\, u_t(x_i,t^n) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,t^n) \\pm \\frac{\\Delta t^3}{6} u_{ttt}(x_i,t^n) + \\cdots,$$\nwhich yields\n$$u_{tt}(x_i,t^n) \\approx \\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2}.$$\nSimilarly, for the second spatial derivative, using the Taylor expansions in space,\n$$u(x_{i\\pm 1},t^n) = u(x_i,t^n) \\pm \\Delta x \\, u_x(x_i,t^n) + \\frac{\\Delta x^2}{2} u_{xx}(x_i,t^n) \\pm \\frac{\\Delta x^3}{6} u_{xxx}(x_i,t^n) + \\cdots,$$\nwe obtain\n$$u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n\nSubstituting these approximations into the wave equation $u_{tt} = c^2 u_{xx}$ at the interior points $i = 1,2,\\dots,N_x-2$ gives the discrete equation\n$$\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\nRearranging for the update from time level $n$ to $n+1$ yields the explicit scheme\n$$u_i^{n+1} = 2 u_i^n - u_i^{n-1} + r^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\nwhere we define the dimensionless Courant number\n$$r = \\frac{c \\, \\Delta t}{\\Delta x}.$$\n\nThe boundary conditions are $u_0^n = 0$ and $u_{N_x-1}^n = 0$ for all $n$. The initial condition provides $u_i^0 = \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ for all $i$, consistent with fixed ends since $\\sin(0) = 0$ and $\\sin(\\pi) = 0$. To initialize the scheme, we also need $u_i^1$. Using a second-order accurate Taylor expansion in time around $t=0$ and the given initial velocity $u_t(x,0) = 0$, we obtain\n$$u(x_i,\\Delta t) \\approx u(x_i,0) + \\Delta t \\, u_t(x_i,0) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,0).$$\nReplacing $u_{tt}(x_i,0)$ by $c^2 u_{xx}(x_i,0)$ and applying the central spatial difference at time $n=0$ gives\n$$u_i^1 = u_i^0 + \\Delta t \\cdot 0 + \\frac{1}{2} r^2 \\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right), \\quad \\text{for } i=1,\\dots,N_x-2,$$\nwith $u_0^1 = 0$ and $u_{N_x-1}^1 = 0$.\n\nThe Courant–Friedrichs–Lewy (CFL) condition arises from stability analysis (for example, via a von Neumann Fourier mode analysis). For the explicit second-order central difference scheme above, the amplification factor $G$ applied to a single Fourier mode satisfies a stability constraint that leads to the requirement\n$$r \\le 1.$$\nWhen $r \\le 1$, all Fourier modes have $|G| \\le 1$ and the method is stable; when $r > 1$, some modes have $|G| > 1$, which causes exponential growth and numerical blow-up.\n\nAlgorithmic design principles:\n- Define physical and numerical parameters $c$, $L$, $N_x$, $\\Delta t$, $T$ using meters and seconds.\n- Compute the grid spacing $\\Delta x = L/(N_x-1)$ and the Courant number $r = c \\Delta t / \\Delta x$.\n- Initialize $u_i^0 = \\sin(\\pi x_i / L)$ for $i=0,\\dots,N_x-1$ and $u_t(x,0) = 0$.\n- Compute $u^1$ using the second-order formula that incorporates $u_{tt}(x,0) = c^2 u_{xx}(x,0)$.\n- For $n \\ge 1$, advance $u^{n+1}$ using the explicit update at interior points and enforce boundary conditions at the endpoints.\n- At each time step, compute $M_n = \\max_i |u_i^n|$ and apply the empirical blow-up detector: if $M_n$ becomes not-a-number, infinite, or exceeds $10 M_0$ where $M_0 = \\max_i |u_i^0|$, declare instability; otherwise continue until the final time $T$.\n- Return a boolean indicating stability.\n\nTest suite rationale:\n- Test $1$ selects $r = 0.8$ ($c = 1.0$, $\\Delta t = 0.008$, $\\Delta x = 0.01$) as a typical stable case.\n- Test $2$ sets $r = 1.0$ as a boundary case which should remain stable for this scheme.\n- Test $3$ uses $r = 1.5$ and a longer final time to ensure that instability manifests empirically.\n- Test $4$ uses $r = 2.0$, which is well beyond the CFL limit, and blows up rapidly.\n\nExpected outcomes based on the CFL condition and empirical detection:\n- Test $1$: $True$ (stable).\n- Test $2$: $True$ (stable).\n- Test $3$: $False$ (blows up).\n- Test $4$: $False$ (blows up).\n\nThe final program aggregates these booleans and prints them as a single comma-separated list enclosed in square brackets, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_wave_1d_stability(c, L, Nx, dt, T):\n    \"\"\"\n    Simulate the 1D wave equation u_tt = c^2 u_xx with fixed ends using\n    second-order central differences in space and time. Empirically detect\n    instability (blow-up) via amplitude growth and NaN/Inf checks.\n\n    Parameters:\n        c  (float): wave speed (m/s)\n        L  (float): domain length (m)\n        Nx (int):   number of spatial grid points\n        dt (float): time step (s)\n        T  (float): final time (s)\n\n    Returns:\n        bool: True if stable (no blow-up detected), False otherwise.\n    \"\"\"\n    # Spatial discretization\n    dx = L / (Nx - 1)\n    x = np.linspace(0.0, L, Nx)\n\n    # Courant number\n    r = c * dt / dx\n\n    # Initial displacement u(x,0) = sin(pi x / L), initial velocity = 0\n    u0 = np.sin(np.pi * x / L)\n    # Boundary conditions are fixed ends: u(0,t) = 0, u(L,t) = 0\n    u0[0] = 0.0\n    u0[-1] = 0.0\n\n    # Prepare arrays for time stepping\n    u_prev = u0.copy()\n\n    # Compute u^1 using second-order accurate initialization:\n    # u^1 = u^0 + dt * v^0 + (dt^2 / 2) * c^2 * u_xx^0\n    # with v^0 = 0 and u_xx^0 approximated by central differences\n    u_curr = u0.copy()\n    # interior update for the first step\n    # u_curr[i] = u_prev[i] + 0 + 0.5 * r^2 * (u_prev[i+1] - 2*u_prev[i] + u_prev[i-1])\n    for i in range(1, Nx - 1):\n        u_curr[i] = u_prev[i] + 0.5 * (r ** 2) * (u_prev[i + 1] - 2.0 * u_prev[i] + u_prev[i - 1])\n    # Enforce boundary conditions\n    u_curr[0] = 0.0\n    u_curr[-1] = 0.0\n\n    # Empirical blow-up detector thresholds\n    M0 = np.max(np.abs(u0))\n    if not np.isfinite(M0):\n        return False  # pathological, treat as blow-up\n    threshold = 10.0 * (M0 if M0 > 0 else 1.0)  # avoid zero threshold\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time stepping\n    for _ in range(1, n_steps):\n        u_next = u_curr.copy()\n        # Explicit update for interior points:\n        # u_next[i] = 2*u_curr[i] - u_prev[i] + r^2 * (u_curr[i+1] - 2*u_curr[i] + u_curr[i-1])\n        for i in range(1, Nx - 1):\n            u_next[i] = (\n                2.0 * u_curr[i]\n                - u_prev[i]\n                + (r ** 2) * (u_curr[i + 1] - 2.0 * u_curr[i] + u_curr[i - 1])\n            )\n        # Enforce boundary conditions\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Check for blow-up\n        M_n = np.max(np.abs(u_next))\n        if not np.isfinite(M_n) or M_n > threshold:\n            return False\n\n        # Rotate time levels\n        u_prev, u_curr = u_curr, u_next\n\n    # If reached final time without blow-up, declare stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (c, L, Nx, dt, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.008, 0.5),  # r = 0.8, expected stable\n        (1.0, 1.0, 101, 0.010, 0.5),  # r = 1.0, expected stable\n        (1.0, 1.0, 101, 0.015, 1.0),  # r = 1.5, expected unstable\n        (2.0, 1.0, 101, 0.010, 0.5),  # r = 2.0, expected unstable\n    ]\n\n    results = []\n    for c, L, Nx, dt, T in test_cases:\n        result = simulate_wave_1d_stability(c, L, Nx, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129202"}, {"introduction": "After tackling a time-dependent hyperbolic problem, we now shift our focus to the steady-state behavior described by elliptic partial differential equations, exemplified by the Poisson equation. This practice involves deriving the well-known five-point stencil for the Laplacian and solving the resulting linear system [@problem_id:3228788]. The key skill you will develop here is code verification, where you will numerically measure the scheme's convergence rate and compare it to theoretical expectations, demonstrating the vital link between local truncation error and global accuracy.", "problem": "Consider the two-dimensional Poisson equation on the unit square domain $\\Omega = (0,1) \\times (0,1)$ with Dirichlet boundary condition,\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{in } \\Omega, \n\\qquad\nu(x,y) = g(x,y) \\quad \\text{on } \\partial\\Omega.\n$$\nStart from the definition of the Laplace operator in two dimensions and the classical central difference approximation for second derivatives derived from Taylor expansions. Using only these fundamentals, derive the standard five-point finite difference method on a uniform grid of mesh spacing $h = 1/N$ with interior nodes $(x_i,y_j) = (ih,jh)$ for $i,j \\in \\{1,\\dots,N-1\\}$:\n$$\n\\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j},\n$$\nwhere boundary values $u_{i,j}$ on $\\partial\\Omega$ are prescribed by $g(x,y)$. Explain why, under the assumption $u \\in C^4(\\overline{\\Omega})$, the local truncation error is $\\mathcal{O}(h^2)$ and how the discrete maximum principle leads to a global error bound $\\lVert u - u_h \\rVert_\\infty = \\mathcal{O}(h^2)$.\n\nNext, implement a solver for the discrete linear system that arises from this scheme using the Conjugate Gradient iteration applied to the symmetric positive definite matrix associated with the five-point stencil. The solver must be matrix-free: apply the discrete operator to grid functions directly via the stencil, and account for Dirichlet boundary data by adding known boundary contributions to the right-hand side. Use a stopping criterion based on the reduction of the residual norm to a user-specified tolerance relative to the right-hand side norm.\n\nYou will validate error estimates and observed convergence rates for two exact solutions. In each case, set $g(x,y) = u(x,y)$ on $\\partial \\Omega$ and set $f(x,y) = -\\Delta u(x,y)$ in $\\Omega$. For each mesh size, compute the discrete solution $u_h$, embed it into the full grid including boundary nodes, and compute the maximum-norm error\n$$\nE(h) = \\max_{0 \\le i,j \\le N} \\left| u(x_i,y_j) - u_h(x_i,y_j) \\right|.\n$$\nGiven a list of mesh spacings $\\{h_k\\}$ with corresponding errors $\\{E(h_k)\\}$, estimate the Experimental Order of Convergence (EOC) as the least-squares slope $p$ in the relation $\\log E(h) \\approx \\log C + p \\log h$.\n\nUse the following two exact solutions:\n- Smooth solution: $u_s(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, for which $f_s(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ and $g_s = u_s$.\n- Singular solution: $u_{sg}(x,y) = r^\\alpha$ with $\\alpha = 3/2$ and $r = \\sqrt{x^2 + y^2}$, for which for $r>0$ one has $\\Delta u_{sg}(x,y) = \\alpha^2 r^{\\alpha - 2}$, hence $f_{sg}(x,y) = -\\alpha^2 r^{\\alpha - 2}$ and $g_{sg} = u_{sg}$. Define $f_{sg}(0,0)$ by continuity if needed; note that $(0,0)$ is a boundary point and therefore not an interior node.\n\nDesign a program that performs the following test suite and reports the EOC for each case:\n- Case A (happy path, smooth and well-resolved): use $N \\in \\{8,16,32,64\\}$ with $u_s$.\n- Case B (reduced regularity, singular near a boundary corner): use $N \\in \\{8,16,32,64\\}$ with $u_{sg}$ and $\\alpha = 3/2$.\n- Case C (boundary coarse resolution edge case): use $N \\in \\{4,8,16\\}$ with $u_s$.\n\nYour program must implement the five-point method, the matrix-free Conjugate Gradient solver, the error computation in the maximum norm, and the least-squares EOC estimation. For each case, perform a linear regression of $\\log E(h)$ against $\\log h$ and report the estimated slope $p$.\n\nNo physical units are involved. All angles, where present, are in radians. The final output must be a single line containing a comma-separated list of the three EOC estimates for the cases A, B, and C, rounded to three decimal places and enclosed in square brackets, in the order [A,B,C]. For example, if the three estimated orders are $p_A$, $p_B$, and $p_C$, your program should output a single line of the form\n$[p_A,p_B,p_C]$.", "solution": "The problem is valid as it represents a well-posed, standard exercise in the numerical analysis of partial differential equations, grounded in established mathematical principles. It is self-contained, objective, and its requirements are algorithmically formalizable.\n\nThe task involves deriving the five-point finite difference scheme for the Poisson equation, analyzing its error, and implementing a matrix-free Conjugate Gradient solver to compute the experimental order of convergence (EOC) for two different test cases.\n\n### Part 1: Derivation of the Five-Point Stencil\n\nWe start with the two-dimensional Poisson equation on the unit square $\\Omega = (0,1) \\times (0,1)$:\n$$\n-\\Delta u(x,y) = f(x,y)\n$$\nwhere $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$ is the Laplace operator. The domain is discretized using a uniform grid with mesh spacing $h=1/N$ in both directions. The grid points are $(x_i, y_j) = (ih, jh)$ for integers $i,j \\in \\{0, 1, \\dots, N\\}$. We seek an approximation $u_{i,j} \\approx u(x_i, y_j)$.\n\nThe core of the finite difference method is to approximate derivatives using Taylor series expansions. Consider the expansion of a sufficiently smooth function $u(x,y)$ around a point $(x_i, y_j)$:\n$$\nu(x_i \\pm h, y_j) = u(x_i, y_j) \\pm h \\frac{\\partial u}{\\partial x}(x_i, y_j) + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}(x_i, y_j) + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^5)\n$$\nSumming the expansions for $u(x_i+h, y_j)$ and $u(x_i-h, y_j)$:\n$$\nu(x_{i+1}, y_j) + u(x_{i-1}, y_j) = 2u(x_i, y_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^6)\n$$\nRearranging to solve for the second partial derivative with respect to $x$ gives the second-order central difference approximation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nBy an identical argument for the $y$ direction:\n$$\n\\frac{\\partial^2 u}{\\partial y^2}(x_i, y_j) = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nSumming these two expressions provides an approximation for the Laplacian:\n$$\n\\Delta u(x_i, y_j) = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nWe define the discrete Laplacian operator, denoted $\\Delta_h$, as:\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\nSubstituting this into the Poisson equation, $-\\Delta u(x_i, y_j) = f(x_i, y_j)$, and ignoring the higher-order terms leads to the five-point finite difference scheme for interior nodes $(i,j)$ where $i,j \\in \\{1, \\dots, N-1\\}$:\n$$\n-\\Delta_h u_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}\n$$\nwhere $f_{i,j} = f(x_i, y_j)$. This is the desired formula.\n\n### Part 2: Local Truncation Error and Global Error\n\nThe local truncation error (LTE), $\\tau_{i,j}$, is the residual obtained when the exact solution $u(x,y)$ is inserted into the discrete equation. Let $L_h = -\\Delta_h$. The discrete system is $L_h u_h = f$, where $u_h$ is the numerical solution vector. Applying the operator to the exact solution $u$:\n$$\n\\tau_{i,j} = L_h u(x_i, y_j) - f(x_i, y_j) = L_h u(x_i, y_j) - (-\\Delta u(x_i, y_j))\n$$\nFrom the Taylor expansion analysis above, we have:\n$$\n\\Delta_h u(x_i, y_j) = \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\nTherefore, the LTE is:\n$$\n\\tau_{i,j} = - \\left( \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right) + \\mathcal{O}(h^4) \\right) + \\Delta u(x_i, y_j)\n$$\n$$\n\\tau_{i,j} = - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4}(x_i,y_j) + \\frac{\\partial^4 u}{\\partial y^4}(x_i,y_j) \\right) + \\mathcal{O}(h^4)\n$$\nIf the exact solution $u$ is in $C^4(\\overline{\\Omega})$, meaning its fourth-order partial derivatives are continuous and thus bounded on the closed domain $\\overline{\\Omega}$, then there exists a constant $M$ such that $|\\frac{\\partial^4 u}{\\partial x^4}| \\le M$ and $|\\frac{\\partial^4 u}{\\partial y^4}| \\le M$. Consequently, the maximum norm of the LTE is bounded by:\n$$\n\\lVert \\tau \\rVert_\\infty = \\max_{i,j} |\\tau_{i,j}| \\le \\frac{h^2}{12} (M+M) + \\mathcal{O}(h^4) = \\mathcal{O}(h^2)\n$$\nThe scheme is consistent with order $2$.\n\nThe global error is defined as $e_{i,j} = u(x_i, y_j) - u_{h, i,j}$, where $u_h$ is the solution of the discrete system. Applying the discrete operator $L_h$ to the error:\n$$\nL_h e_{i,j} = L_h (u_{i,j} - u_{h, i,j}) = L_h u_{i,j} - L_h u_{h, i,j}\n$$\nBy definition, $L_h u_{h, i,j} = f_{i,j}$ and $L_h u_{i,j} = f_{i,j} + \\tau_{i,j}$. Subtracting these, we obtain the error equation:\n$$\nL_h e_{i,j} = \\tau_{i,j}\n$$\nfor all interior nodes. On the boundary $\\partial\\Omega$, the error is zero, $e_{i,j} = 0$, since both the exact solution and the numerical solution take the prescribed boundary values $g(x,y)$.\n\nThe connection between the LTE and the global error is made through the stability of the discrete operator $L_h$. The operator $L_h$ satisfies a discrete maximum principle (DMP). For an operator like $L_h$, the DMP states that if $L_h v_{i,j} \\ge 0$ at all interior nodes, then the maximum value of $v$ over the entire grid must occur on the boundary. A key consequence of the DMP is the stability of its inverse in the maximum norm. That is, there exists a constant $C > 0$, independent of $h$, such that for any grid function $z$, the solution $v$ to $L_h v = z$ with zero boundary conditions satisfies:\n$$\n\\lVert v \\rVert_\\infty \\le C \\lVert z \\rVert_\\infty\n$$\nThis is expressed as $\\lVert L_h^{-1} \\rVert_\\infty \\le C$. Applying this stability estimate to the error equation $e = L_h^{-1} \\tau$:\n$$\n\\lVert e \\rVert_\\infty = \\lVert L_h^{-1} \\tau \\rVert_\\infty \\le \\lVert L_h^{-1} \\rVert_\\infty \\lVert \\tau \\rVert_\\infty \\le C \\lVert \\tau \\rVert_\\infty\n$$\nSince we have shown that $\\lVert \\tau \\rVert_\\infty = \\mathcal{O}(h^2)$, the global error in the maximum norm is also second-order accurate:\n$$\n\\lVert u - u_h \\rVert_\\infty = \\lVert e \\rVert_\\infty = \\mathcal{O}(h^2)\n$$\nThis establishes that, for a sufficiently smooth solution ($u \\in C^4(\\overline{\\Omega})$), the five-point scheme converges globally at a rate of $2$.\n\n### Part 3: Algorithmic Design\n\nThe implementation will consist of a matrix-free Conjugate Gradient (CG) solver. The linear system $A u_h = b$ must be constructed, where $A$ corresponds to the discrete operator $L_h$ on the $(N-1)^2$ interior nodes.\n\n**System Construction:** The vector $u_h$ contains the unknown values at interior nodes. The matrix $A$ represents the five-point stencil. The right-hand side vector $b$ combines the source term $f(x,y)$ and the contributions from the known Dirichlet boundary values $g(x,y)$. For an interior node $(x_i,y_j)$:\n$$\nb_{i,j} = f(x_i, y_j) + \\frac{1}{h^2} \\left[ \\delta_{i,1}g(x_0,y_j) + \\delta_{i,N-1}g(x_N,y_j) + \\delta_{j,1}g(x_i,y_0) + \\delta_{j,N-1}g(x_i,y_N) \\right]\n$$\nwhere $\\delta_{k,l}$ is the Kronecker delta. This formulation moves all known boundary terms to the right side of the equation.\n\n**Matrix-Free CG:** The CG algorithm iteratively solves a symmetric positive-definite system. The matrix for the five-point stencil has this property. The key operation in CG is the matrix-vector product $A\\vec{p}$. In a matrix-free approach, we do not assemble the $(N-1)^2 \\times (N-1)^2$ matrix $A$. Instead, we implement a function that computes the action of the operator $L_h$ on a grid function $\\vec{p}$ (representing the search direction). This is done by applying the five-point stencil at each interior node.\n\n**EOC Estimation:** The EOC $p$ is estimated from errors $E(h_k)$ at a sequence of mesh sizes $h_k$ via the model $\\log E(h) \\approx \\log C + p \\log h$. This is a linear regression problem for the pairs $(\\log h_k, \\log E_k)$. The slope $p$ is calculated using the standard least-squares formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute EOC for all cases.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Smooth solution u_s(x,y) = sin(pi*x)sin(pi*y)\n    u_s = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    f_s = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    # Case 2: Singular solution u_sg(x,y) = r^(3/2)\n    def u_sg(x, y):\n        r = np.sqrt(x**2 + y**2)\n        # Handle r=0 case to avoid 0**negative power in f_sg\n        return np.power(r, 1.5)\n\n    def f_sg(x, y):\n        # f is evaluated only at interior points, so r > 0.\n        r = np.sqrt(x**2 + y**2)\n        alpha = 1.5\n        return -alpha**2 * np.power(r, alpha - 2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case A: Smooth solution, standard refinement\n        {'name': 'A', 'Ns': [8, 16, 32, 64], 'u_func': u_s, 'f_func': f_s},\n        # Case B: Singular solution\n        {'name': 'B', 'Ns': [8, 16, 32, 64], 'u_func': u_sg, 'f_func': f_sg},\n        # Case C: Smooth solution, coarse grids\n        {'name': 'C', 'Ns': [4, 8, 16], 'u_func': u_s, 'f_func': f_s},\n    ]\n\n    eoc_results = []\n\n    for case in test_cases:\n        h_values = []\n        error_values = []\n\n        for N in case['Ns']:\n            h = 1.0 / N\n            u_func = case['u_func']\n            f_func = case['f_func']\n            g_func = u_func # Boundary condition is the exact solution\n\n            # 1. Set up grid and coordinates\n            # Grid for interior points (1..N-1)\n            int_coords = np.linspace(h, 1.0 - h, N - 1)\n            X_int, Y_int = np.meshgrid(int_coords, int_coords, indexing='ij')\n\n            # Full grid for error calculation (0..N)\n            full_coords = np.linspace(0, 1.0, N + 1)\n            X_full, Y_full = np.meshgrid(full_coords, full_coords, indexing='ij')\n\n            # 2. Construct the right-hand side (RHS) vector 'b'\n            b = f_func(X_int, Y_int)\n            h2_inv = 1.0 / (h**2)\n            \n            # Add boundary contributions\n            # j = 1, ..., N-1\n            b[0, :] += h2_inv * g_func(0, int_coords)  # Left boundary i=0\n            b[-1, :] += h2_inv * g_func(1, int_coords) # Right boundary i=N\n            # i = 1, ..., N-1\n            b[:, 0] += h2_inv * g_func(int_coords, 0)  # Bottom boundary j=0\n            b[:, -1] += h2_inv * g_func(int_coords, 1) # Top boundary j=N\n\n            # 3. Solve the linear system using matrix-free Conjugate Gradient\n            u_h_interior = cg_solver(b, h, tol=1e-12)\n\n            # 4. Construct full solution grid and compute error\n            u_h_full = np.zeros((N + 1, N + 1))\n            # Set boundary values\n            u_h_full[0, :] = g_func(0, full_coords)\n            u_h_full[N, :] = g_func(1, full_coords)\n            u_h_full[:, 0] = g_func(full_coords, 0)\n            u_h_full[:, N] = g_func(full_coords, 1)\n            # Fill interior\n            u_h_full[1:N, 1:N] = u_h_interior\n\n            u_exact_full = u_func(X_full, Y_full)\n            \n            error = np.max(np.abs(u_exact_full - u_h_full))\n            \n            h_values.append(h)\n            error_values.append(error)\n\n        # 5. Compute EOC using least-squares fit\n        log_h = np.log(np.array(h_values))\n        log_e = np.log(np.array(error_values))\n        \n        # Fit a line (degree 1 polynomial) to (log_h, log_e)\n        # The slope is the first coefficient returned by polyfit.\n        p_eoc = np.polyfit(log_h, log_e, 1)[0]\n        eoc_results.append(p_eoc)\n    \n    # Final print statement\n    print(f\"[{','.join(f'{p:.3f}' for p in eoc_results)}]\")\n\ndef apply_A_matvec(v, h):\n    \"\"\"\n    Computes the matrix-free matrix-vector product for the 5-point stencil.\n    Assumes zero boundary conditions for the input vector v.\n    \n    Args:\n        v (np.ndarray): A 2D numpy array of size (N-1)x(N-1) representing the vector.\n        h (float): The mesh spacing.\n    \n    Returns:\n        np.ndarray: The result of Av, a 2D array of size (N-1)x(N-1).\n    \"\"\"\n    if v.shape[0] == 0:\n        return np.array([])\n    N_minus_1 = v.shape[0]\n    Av = np.zeros_like(v)\n    h2_inv = 1.0 / (h**2)\n    \n    # Pad with zeros for boundary conditions\n    v_padded = np.pad(v, pad_width=1, mode='constant', constant_values=0)\n    \n    for i in range(N_minus_1):\n        for j in range(N_minus_1):\n            # Convert to padded indices\n            ip, jp = i + 1, j + 1\n            center = v_padded[ip, jp]\n            left = v_padded[ip - 1, jp]\n            right = v_padded[ip + 1, jp]\n            down = v_padded[ip, jp - 1]\n            up = v_padded[ip, jp + 1]\n            \n            Av[i, j] = h2_inv * (4 * center - left - right - down - up)\n            \n    return Av\n\ndef cg_solver(b, h, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves Ax=b using matrix-free Conjugate Gradient method.\n    \n    Args:\n        b (np.ndarray): The right-hand side vector as a 2D (N-1)x(N-1) array.\n        h (float): The mesh spacing.\n        tol (float): The relative tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n    \n    Returns:\n        np.ndarray: The solution vector x as a 2D (N-1)x(N-1) array.\n    \"\"\"\n    if b.size == 0:\n        return np.array([])\n    x = np.zeros_like(b)\n    r = b - apply_A_matvec(x, h)\n    p = r.copy()\n    rs_old = np.sum(r**2)\n    \n    b_norm = np.sqrt(np.sum(b**2))\n    if b_norm == 0:\n        return x\n\n    for k in range(max_iter):\n        Ap = apply_A_matvec(p, h)\n        pAp = np.sum(p * Ap)\n\n        if pAp == 0:\n            break\n            \n        alpha = rs_old / pAp\n        x += alpha * p\n        r -= alpha * Ap\n        \n        rs_new = np.sum(r**2)\n        \n        if np.sqrt(rs_new)  tol * b_norm:\n            break\n            \n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return x\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228788"}, {"introduction": "Our final practice addresses a challenge at the heart of multiphysics simulation: the interaction between coupled fields. Using the method of manufactured solutions, we will set up and solve a coupled boundary value problem to investigate a subtle but critical source of numerical error [@problem_id:3507199]. This exercise demonstrates how inconsistencies in the discretization, specifically at the boundaries, can lead to \"error leakage\" that degrades the accuracy of the entire system, emphasizing the importance of consistent formulation in coupled models.", "problem": "Construct a self-contained numerical experiment to analyze how inconsistent boundary closures affect a coupled finite difference system and to quantify the leakage of error across coupling. Consider the following symmetric, linear, steady, coupled boundary value problem on the domain $[0,1]$:\n- Interior equations: $-u''(x) + \\kappa\\,(u(x) - v(x)) = s_u(x)$ and $-v''(x) + \\kappa\\,(v(x) - u(x)) = s_v(x)$ for $x \\in (0,1)$, where $\\kappa \\ge 0$ is a constant coupling strength.\n- Boundary conditions: $u(0) = u_{\\text{exact}}(0)$ and $v(0) = v_{\\text{exact}}(0)$ at $x=0$ (Dirichlet), and $u'(1) = u'_{\\text{exact}}(1)$ and $v'(1) = v'_{\\text{exact}}(1)$ at $x=1$ (Neumann).\n\nUse the method of manufactured solutions. Define the exact fields by\n$$u_{\\text{exact}}(x) = \\sin(2\\pi x) + x,$$\n$$v_{\\text{exact}}(x) = \\cos(2\\pi x) - \\tfrac{1}{2}x,$$\nand compute the sources $s_u(x)$ and $s_v(x)$ from the interior equations so that the exact fields satisfy the continuous problem for any chosen $\\kappa$:\n$$s_u(x) = -u_{\\text{exact}}''(x) + \\kappa\\left(u_{\\text{exact}}(x) - v_{\\text{exact}}(x)\\right),$$\n$$s_v(x) = -v_{\\text{exact}}''(x) + \\kappa\\left(v_{\\text{exact}}(x) - u_{\\text{exact}}(x)\\right).$$\n\nDiscretize on a uniform grid with $N$ equal subintervals and spacing $\\Delta x = 1/N$, with grid points $x_i = i\\,\\Delta x$ for $i \\in \\{0,1,\\dots,N\\}$. Use the following finite difference method fundamentals:\n- Approximate second derivatives in the interior with the standard second-order centered difference: $w''(x_i) \\approx \\left(w_{i-1} - 2 w_i + w_{i+1}\\right)/\\Delta x^2$ for $i \\in \\{1,2,\\dots,N-1\\}$, where $w$ stands for $u$ or $v$.\n- Enforce the Dirichlet data at $x=0$ by directly using the exact values $u_0 = u_{\\text{exact}}(0)$ and $v_0 = v_{\\text{exact}}(0)$ in the interior stencils; no boundary equation is needed at $x=0$.\n- Enforce the Neumann boundary conditions at $x=1$ by replacing the interior equation at $i=N$ with a one-sided finite difference closure for the derivative. Two closures are available:\n  1. First-order backward difference: $w'(1) \\approx \\left(w_N - w_{N-1}\\right)/\\Delta x$.\n  2. Second-order backward difference: $w'(1) \\approx \\left(3 w_N - 4 w_{N-1} + w_{N-2}\\right)/(2\\Delta x)$.\nHere $w$ again stands for $u$ or $v$. You must be able to assign different closure orders to $u$ and $v$ at $x=1$ to intentionally create inconsistent boundary closures.\n\nTasks to implement:\n- Assemble and solve the discrete linear system for $(u_i,v_i)$ at the grid nodes for $i \\in \\{1,2,\\dots,N\\}$ under the above rules.\n- For a given $N$, compute the discrete $\\ell^2$-norm of the nodal error for each field, defined by\n$$\\|e_u\\|_{2,h} = \\sqrt{\\Delta x \\sum_{i=0}^{N} \\left(u_i - u_{\\text{exact}}(x_i)\\right)^2}, \\quad \\|e_v\\|_{2,h} = \\sqrt{\\Delta x \\sum_{i=0}^{N} \\left(v_i - v_{\\text{exact}}(x_i)\\right)^2},$$\nwhere $u_0$ and $v_0$ are the imposed exact Dirichlet values, and $u_i$, $v_i$ for $i \\ge 1$ are the computed unknowns.\n- Quantify the observed order of accuracy by grid refinement using $N$ and $2N$:\n$$p_u = \\log_2\\left(\\frac{\\|e_u\\|_{2,h}}{\\|e_u\\|_{2,h/2}}\\right), \\quad p_v = \\log_2\\left(\\frac{\\|e_v\\|_{2,h}}{\\|e_v\\|_{2,h/2}}\\right).$$\n\nDesign a test suite that exposes the effect of inconsistent boundary closures and the leakage of error across coupling:\n- Test case $1$: $\\kappa = 1$, first-order Neumann closure for $u$ at $x=1$, second-order Neumann closure for $v$ at $x=1$.\n- Test case $2$: $\\kappa = 1$, second-order Neumann closure for $u$ at $x=1$, first-order Neumann closure for $v$ at $x=1$.\n- Test case $3$: $\\kappa = 0$ (decoupled), first-order Neumann closure for $u$ at $x=1$, second-order Neumann closure for $v$ at $x=1$.\n- Test case $4$: $\\kappa = 1$, second-order Neumann closure for both $u$ and $v$ at $x=1$.\n\nFor each test case, compute $(p_u,p_v)$ using a refinement pair $(N,2N)$ with sufficiently large $N$ to reach the asymptotic regime. Your program should use $N=64$ and $2N=128$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_u^{(1)},p_v^{(1)},p_u^{(2)},p_v^{(2)},p_u^{(3)},p_v^{(3)},p_u^{(4)},p_v^{(4)}]$, where the superscript indicates the test case index. Each entry must be a floating-point number. No physical units are involved, and angle units are irrelevant to this problem.\n\nThe goal is to analyze and report how a first-order boundary closure in one field degrades the global accuracy of the coupled system and to confirm that using matched second-order closures for both fields restores second-order accuracy $O(\\Delta x^2)$.", "solution": "The problem requires the construction of a numerical experiment to study the effects of inconsistent boundary condition discretizations on a coupled system of two second-order ordinary differential equations. The method of manufactured solutions is employed to provide an exact analytical solution against which the numerical approximation can be compared. The analysis focuses on how a low-order boundary closure for one variable contaminates the solution accuracy of both variables through the coupling term.\n\nThe continuous problem is defined on the domain $x \\in [0,1]$ by the coupled equations:\n$$ -u''(x) + \\kappa\\,(u(x) - v(x)) = s_u(x) $$\n$$ -v''(x) + \\kappa\\,(v(x) - u(x)) = s_v(x) $$\nwith mixed boundary conditions: Dirichlet at $x=0$ and Neumann at $x=1$. The coupling strength is given by the constant $\\kappa \\ge 0$. The source terms $s_u(x)$ and $s_v(x)$ are manufactured to ensure the exact solutions $u_{\\text{exact}}(x) = \\sin(2\\pi x) + x$ and $v_{\\text{exact}}(x) = \\cos(2\\pi x) - \\frac{1}{2}x$ satisfy the system.\n\nThe first step is to discretize the problem using the finite difference method on a uniform grid of $N+1$ points $x_i = i\\Delta x$ for $i \\in \\{0, 1, \\dots, N\\}$, where the grid spacing is $\\Delta x = 1/N$. The unknowns of our discrete system are the nodal values $\\{u_i, v_i\\}$ for $i \\in \\{1, 2, \\dots, N\\}$, as $u_0$ and $v_0$ are given by the Dirichlet boundary conditions. This gives a total of $2N$ unknowns, which we can arrange into a single vector $\\mathbf{z} = [u_1, u_2, \\dots, u_N, v_1, v_2, \\dots, v_N]^T$.\n\nFor the interior grid points, $i \\in \\{1, 2, \\dots, N-1\\}$, we approximate the second derivative using the standard second-order centered difference formula: $w''(x_i) \\approx (w_{i-1} - 2w_i + w_{i+1})/\\Delta x^2$. Applying this to the governing equations yields:\n$$ -\\frac{u_{i-1} - 2u_i + u_{i+1}}{\\Delta x^2} + \\kappa(u_i - v_i) = s_u(x_i) $$\n$$ -\\frac{v_{i-1} - 2v_i + v_{i+1}}{\\Delta x^2} + \\kappa(v_i - u_i) = s_v(x_i) $$\nMultiplying by $\\Delta x^2$ and grouping the unknown terms on the left-hand side, we obtain the algebraic equations for node $i$:\n$$ -u_{i-1} + (2 + \\kappa\\Delta x^2)u_i - u_{i+1} - \\kappa\\Delta x^2 v_i = \\Delta x^2 s_u(x_i) $$\n$$ -v_{i-1} + (2 + \\kappa\\Delta x^2)v_i - v_{i+1} - \\kappa\\Delta x^2 u_i = \\Delta x^2 s_v(x_i) $$\n\nspecial care is needed at the boundaries.\nAt $x_0 = 0$, the Dirichlet conditions $u_0 = u_{\\text{exact}}(0)$ and $v_0 = v_{\\text{exact}}(0)$ are prescribed. For the equations at $i=1$, the terms involving $u_0$ and $v_0$ are known constants and are moved to the right-hand side of the linear system:\n$$ (2 + \\kappa\\Delta x^2)u_1 - u_2 - \\kappa\\Delta x^2 v_1 = \\Delta x^2 s_u(x_1) + u_{\\text{exact}}(0) $$\n$$ (2 + \\kappa\\Delta x^2)v_1 - v_2 - \\kappa\\Delta x^2 u_1 = \\Delta x^2 s_v(x_1) + v_{\\text{exact}}(0) $$\n\nAt $x_N = 1$, the Neumann conditions $u'(1) = u'_{\\text{exact}}(1)$ and $v'(1) = v'_{\\text{exact}}(1)$ are enforced. The interior equations are replaced by discrete approximations of these derivative conditions.\nThe first-order backward difference for a generic function $w$ is:\n$$ \\frac{w_N - w_{N-1}}{\\Delta x} = w'_{\\text{exact}}(1) \\implies -w_{N-1} + w_N = \\Delta x \\, w'_{\\text{exact}}(1) $$\nThe second-order backward difference is:\n$$ \\frac{3w_N - 4w_{N-1} + w_{N-2}}{2\\Delta x} = w'_{\\text{exact}}(1) \\implies w_{N-2} - 4w_{N-1} + 3w_N = 2\\Delta x \\, w'_{\\text{exact}}(1) $$\nThese equations for $u$ and $v$ (depending on the test case) provide the final two rows of the linear system. Notably, these specific boundary closure equations are uncoupled; the equation for $u_N$ involves only other $u_i$ values, and similarly for $v_N$.\n\nCombining these $2N$ equations results in a linear system of the form $A\\mathbf{z} = \\mathbf{b}$, where $A$ is a $2N \\times 2N$ matrix. The matrix $A$ has a $2 \\times 2$ block structure:\n$$ A = \\begin{pmatrix} A_{uu}  A_{uv} \\\\ A_{vu}  A_{vv} \\end{pmatrix} $$\nThe matrices $A_{uu}$ and $A_{vv}$ contain the discretized second derivative operator and the diagonal part of the coupling term. They are tridiagonal for the first $N-1$ rows and are modified in the final row by the Neumann boundary condition stencil. The matrices $A_{uv}$ and $A_{vu}$ represent the off-diagonal coupling and are diagonal matrices, specifically $A_{uv} = A_{vu} = -\\kappa\\Delta x^2 I_{N \\times N}$, except for their last row, which is zero due to the uncoupled nature of the chosen Neumann stencils. The right-hand side vector $\\mathbf{b}$ contains the evaluated source terms and the known boundary values.\n\nAfter solving the system $A\\mathbf{z} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{z}$, we obtain the numerical solutions $u_i$ and $v_i$ for $i \\in \\{1, \\dots, N\\}$. We then compute the discrete $\\ell^2$-norm of the error for each field, $\\|e_u\\|_{2,h}$ and $\\|e_v\\|_{2,h}$, using the provided formula. This process is performed for two grid resolutions, $N$ and $2N$. The observed order of accuracy, $p$, is then calculated as\n$$ p = \\log_2\\left(\\frac{\\|e\\|_{2,h}}{\\|e\\|_{2,h/2}}\\right) $$\nfor each field, where $h = 1/N$.\n\nThis framework is applied to the four specified test cases.\n- Case 1 ($\\kappa=1$, $u$-closure 1st-order, $v$-closure 2nd-order): A first-order error source in the $u$-variable is expected to pollute the $v$-variable through the coupling term, resulting in $p_u \\approx 1$ and $p_v \\approx 1$.\n- Case 2 (Symmetric to Case 1): Similarly, we expect $p_u \\approx 1$ and $p_v \\approx 1$.\n- Case 3 ($\\kappa=0$, decoupled system): The error in each variable is determined solely by its own discretization. We expect $p_u \\approx 1$ (due to its 1st-order boundary condition) and $p_v \\approx 2$ (as its discretization is consistently 2nd-order).\n- Case 4 ($\\kappa=1$, both closures 2nd-order): The entire discretization is second-order accurate. Both fields should exhibit second-order convergence, $p_u \\approx 2$ and $p_v \\approx 2$.\n\nThe implementation will construct the matrix $A$ and vector $\\mathbf{b}$ for each case and resolution, solve the linear system, and then compute the convergence orders $p_u$ and $p_v$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_and_solve(N, kappa, u_closure_order, v_closure_order):\n    \"\"\"\n    Assembles and solves the linear system for the coupled BVP.\n\n    Args:\n        N (int): Number of subintervals on the grid.\n        kappa (float): Coupling strength.\n        u_closure_order (int): Order of the Neumann closure for u (1 or 2).\n        v_closure_order (int): Order of the Neumann closure for v (1 or 2).\n\n    Returns:\n        tuple: A tuple containing the L2 error norms for u and v.\n    \"\"\"\n    # --- Define exact solutions and source terms ---\n    def u_exact(x):\n        return np.sin(2 * np.pi * x) + x\n    def v_exact(x):\n        return np.cos(2 * np.pi * x) - 0.5 * x\n    def u_prime_exact(x):\n        return 2 * np.pi * np.cos(2 * np.pi * x) + 1.0\n    def v_prime_exact(x):\n        return -2 * np.pi * np.sin(2 * np.pi * x) - 0.5\n    def u_dprime_exact(x):\n        return -4 * np.pi**2 * np.sin(2 * np.pi * x)\n    def v_dprime_exact(x):\n        return -4 * np.pi**2 * np.cos(2 * np.pi * x)\n    def s_u(x, k):\n        return -u_dprime_exact(x) + k * (u_exact(x) - v_exact(x))\n    def s_v(x, k):\n        return -v_dprime_exact(x) + k * (v_exact(x) - u_exact(x))\n\n    # --- Discretization setup ---\n    dim = 2 * N\n    A = np.zeros((dim, dim))\n    b = np.zeros(dim)\n    dx = 1.0 / N\n    k_dx2 = kappa * dx**2\n    x_grid = np.linspace(0, 1, N + 1)\n    \n    # --- Evaluate exact solutions and sources on grid ---\n    u_ex_grid = u_exact(x_grid)\n    v_ex_grid = v_exact(x_grid)\n    su_grid = s_u(x_grid, kappa)\n    sv_grid = s_v(x_grid, kappa)\n\n    # --- Assemble matrix A and vector b ---\n\n    # Interior equations for i = 1, ..., N-1\n    for i in range(1, N):\n        # Equation for u_i\n        row = i - 1\n        A[row, i - 1] = 2.0 + k_dx2         # u_i term\n        if i  N -1 : # The u_{i+1} term is zero for the last interior equation as u_N is handled separately\n             A[row, i] = -1.0                    # u_{i+1} term\n        if i > 1:\n            A[row, i - 2] = -1.0            # u_{i-1} term\n        A[row, N + i - 1] = -k_dx2          # v_i term\n        b[row] = dx**2 * su_grid[i]\n        if i == 1:\n            b[row] += u_ex_grid[0]          # u_0 Dirichlet term\n\n        # Equation for v_i\n        row = N + i - 1\n        A[row, N + i - 1] = 2.0 + k_dx2     # v_i term\n        if i  N-1: # The v_{i+1} term is zero for the last interior equation as v_N is handled separately\n            A[row, N + i] = -1.0                # v_{i+1} term\n        if i > 1:\n            A[row, N + i - 2] = -1.0        # v_{i-1} term\n        A[row, i - 1] = -k_dx2              # u_i term\n        b[row] = dx**2 * sv_grid[i]\n        if i == 1:\n            b[row] += v_ex_grid[0]          # v_0 Dirichlet term\n\n    # Modify equations for i = N-1 to account for u_N and v_N unknowns\n    A[N - 2, N - 1] = -1.0\n    A[2*N - 2, 2*N - 1] = -1.0\n\n    # Neumann boundary equation for u_N (at i=N)\n    row_uN = N - 1\n    if u_closure_order == 1:\n        A[row_uN, N - 1] = 1.0\n        A[row_uN, N - 2] = -1.0\n        b[row_uN] = dx * u_prime_exact(1.0)\n    elif u_closure_order == 2:\n        A[row_uN, N - 1] = 3.0\n        A[row_uN, N - 2] = -4.0\n        A[row_uN, N - 3] = 1.0\n        b[row_uN] = 2 * dx * u_prime_exact(1.0)\n\n    # Neumann boundary equation for v_N (at i=N)\n    row_vN = 2 * N - 1\n    if v_closure_order == 1:\n        A[row_vN, 2 * N - 1] = 1.0\n        A[row_vN, 2 * N - 2] = -1.0\n        b[row_vN] = dx * v_prime_exact(1.0)\n    elif v_closure_order == 2:\n        A[row_vN, 2 * N - 1] = 3.0\n        A[row_vN, 2 * N - 2] = -4.0\n        A[row_vN, 2 * N - 3] = 1.0\n        b[row_vN] = 2 * dx * v_prime_exact(1.0)\n        \n    # --- Solve the linear system ---\n    sol = np.linalg.solve(A, b)\n\n    # --- Compute error norm ---\n    # Unpack solution and prepend Dirichlet values\n    u_num = np.concatenate(([u_ex_grid[0]], sol[:N]))\n    v_num = np.concatenate(([v_ex_grid[0]], sol[N:]))\n    \n    # Calculate discrete L2 norm\n    error_u = u_num - u_ex_grid\n    error_v = v_num - v_ex_grid\n    norm_u = np.sqrt(dx * np.sum(error_u**2))\n    norm_v = np.sqrt(dx * np.sum(error_v**2))\n    \n    return norm_u, norm_v\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, u_closure_order, v_closure_order)\n        (1.0, 1, 2),  # Case 1\n        (1.0, 2, 1),  # Case 2\n        (0.0, 1, 2),  # Case 3\n        (1.0, 2, 2),  # Case 4\n    ]\n    \n    N_coarse = 64\n    N_fine = 128\n    \n    results = []\n    \n    for kappa, u_closure, v_closure in test_cases:\n        # Solve for coarse grid (h)\n        err_u_h, err_v_h = build_and_solve(N_coarse, kappa, u_closure, v_closure)\n        \n        # Solve for fine grid (h/2)\n        err_u_h2, err_v_h2 = build_and_solve(N_fine, kappa, u_closure, v_closure)\n        \n        # Compute observed order of accuracy\n        p_u = np.log2(err_u_h / err_u_h2) if err_u_h2 > 0 else 0\n        p_v = np.log2(err_v_h / err_v_h2) if err_v_h2 > 0 else 0\n        \n        results.extend([p_u, p_v])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507199"}]}