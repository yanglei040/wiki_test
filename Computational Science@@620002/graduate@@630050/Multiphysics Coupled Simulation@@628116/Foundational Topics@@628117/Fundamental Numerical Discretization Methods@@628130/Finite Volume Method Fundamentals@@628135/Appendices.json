{"hands_on_practices": [{"introduction": "We begin by building a finite volume scheme from the ground up for a classic reactive-diffusion problem. This exercise will solidify your understanding of how the integral form of a conservation law translates into a discrete algebraic system. By implementing an implicit, operator-split method, you will tackle the critical challenges of ensuring numerical stability and preserving the physical non-negativity of concentrations, skills that are essential for any robust simulation code. [@problem_id:3507785]", "problem": "Consider the scalar reactive diffusion equation for a conserved extensive quantity per unit volume, expressed in purely conservative form over a spatial domain,\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c),\n$$\nwhere $c$ is the concentration in $\\mathrm{mol/m^3}$, $D$ is a diffusion coefficient in $\\mathrm{m^2/s}$, and $R(c)$ is a source term with units $\\mathrm{mol/(m^3\\,s)}$. Starting from the local conservation law and the divergence theorem, construct a cell-centered finite volume method on a one-dimensional domain with zero-flux (homogeneous Neumann) boundary conditions that enforces exact discrete conservation of fluxes and preserves non-negativity of the concentration. Treat diffusion implicitly via a backward Euler step and split the source term implicitly using a production-destruction decomposition that guarantees $c \\ge 0$. The splitting must be such that the flux part alone preserves total mass exactly, while the full update preserves total mass in the special case $R \\equiv 0$ and, in general, changes total mass in a manner that is exactly equal to the discrete integral of the source term.\n\nYou must derive from first principles of conservation the discrete fluxes across control-volume faces. Use a two-point flux approximation at faces that is consistent with variable diffusion coefficient $D$ and that enforces positivity for spatially monotone states. Assemble the resulting linear system for the implicit diffusion step. Then, for the source term, express $R(c)$ as a production-destruction split $R(c) = P(c) - Q(c)\\,c$ with $P(c) \\ge 0$ and $Q(c) \\ge 0$, and design a backward Euler update that is local to each control volume and preserves $c \\ge 0$.\n\nImplement a single implicit operator-split time step consisting of:\n- An implicit diffusion step,\n- Followed by an implicit source step based on the production-destruction split.\n\nWork on a one-dimensional domain $x \\in [0,L]$ with uniform cells and unit cross-sectional area. Use homogeneous Neumann boundary conditions (zero diffusive flux at $x=0$ and $x=L$). The total mass should be computed as the Riemann sum $M = \\sum_i c_i\\,\\Delta x$ (units $\\mathrm{mol/m^2}$, representing total moles per unit cross-sectional area). You must check the following properties numerically for each test case:\n- Non-negativity: after the full step, verify that $\\min_i c_i \\ge 0$.\n- Flux conservation: after the diffusion step (before the source step), verify that the total mass $M$ is unchanged to within a specified absolute tolerance.\n- Source consistency: after the source step, verify that the total mass change equals the discrete integral of the source, i.e., $M^{n+1} - M^{n+1/2} = \\Delta t \\sum_i \\left[P_i - Q_i\\,c_i^{n+1}\\right]\\,\\Delta x$, to within a specified absolute tolerance.\n\nYour program must implement the above method and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry corresponds to one test case and is a boolean indicating whether both non-negativity and mass properties passed. The absolute tolerance to be used for mass checks in all cases is $10^{-10}$.\n\nExpress all physical parameters using the units specified above. Angles are not used. All results in the output are dimensionless booleans.\n\nTest Suite:\n- Case $1$ (diffusion-only, variable diffusivity):\n  - Domain length $L = 1\\,\\mathrm{m}$, number of cells $N = 50$, time step $\\Delta t = 1\\,\\mathrm{s}$.\n  - Initial condition $c(x) = 1 + 0.1 \\cos(2\\pi x/L)$ in $\\mathrm{mol/m^3}$.\n  - Diffusivity $D(x) = 10^{-3} + 5\\times 10^{-4} \\sin(2\\pi x/L)$ in $\\mathrm{m^2/s}$.\n  - Source split $P \\equiv 0$ and $Q \\equiv 0$.\n  - Boundary conditions: homogeneous Neumann at $x=0$ and $x=L$.\n- Case $2$ (stiff decay with diffusion):\n  - Domain length $L = 1\\,\\mathrm{m}$, number of cells $N = 100$, time step $\\Delta t = 10^{-2}\\,\\mathrm{s}$.\n  - Initial condition $c(x) = 1\\times 10^{-3} + \\exp\\left(-\\dfrac{(x - 0.5 L)^2}{5\\times 10^{-3}}\\right)$ in $\\mathrm{mol/m^3}$.\n  - Diffusivity $D(x) = 10^{-3}\\left(1 + 0.9\\,\\exp\\left(-\\dfrac{(x - 0.5 L)^2}{10^{-2}} \\right)\\right)$ in $\\mathrm{m^2/s}$.\n  - Source split $P \\equiv 0$, $Q \\equiv k$ with $k = 10^{3}\\,\\mathrm{s^{-1}}$.\n  - Boundary conditions: homogeneous Neumann at $x=0$ and $x=L$.\n- Case $3$ (stiff production-destruction with diffusion):\n  - Domain length $L = 1\\,\\mathrm{m}$, number of cells $N = 80$, time step $\\Delta t = 5\\times 10^{-2}\\,\\mathrm{s}$.\n  - Initial condition $c(x) = 0.2 + 0.2 \\sin(3\\pi x/L)$ in $\\mathrm{mol/m^3}$.\n  - Diffusivity $D(x) = 5\\times 10^{-4}$ in $\\mathrm{m^2/s}$.\n  - Source split $P \\equiv 0.5\\,\\mathrm{mol/(m^3\\,s)}$, $Q \\equiv 200\\,\\mathrm{s^{-1}}$.\n  - Boundary conditions: homogeneous Neumann at $x=0$ and $x=L$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[r_1,r_2,r_3]`, where each $r_i$ is either the string `True` or `False`.", "solution": "The problem requires the construction and implementation of a one-dimensional, cell-centered finite volume method (FVM) for a scalar reactive diffusion equation. The scheme must be positivity-preserving and discretely conservative. The derivation begins with the integral form of the local conservation law.\n\nThe governing partial differential equation is:\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c)\n$$\nwhere $c$ is the concentration, $D$ is the diffusion coefficient, and $R(c)$ is the reaction source term.\n\nWe discretize the one-dimensional domain $x \\in [0, L]$ into $N$ uniform control volumes (cells), each of width $\\Delta x = L/N$. The $i$-th cell, $V_i$, spans the interval $[x_{i-1/2}, x_{i+1/2}]$, with its center at $x_i = (i+0.5)\\Delta x$ for $i=0, 1, \\dots, N-1$. The cell-average concentration is defined as $c_i(t) \\approx \\frac{1}{\\Delta x} \\int_{V_i} c(x,t) dx$.\n\nIntegrating the PDE over the control volume $V_i$ (assuming unit cross-sectional area) yields:\n$$\n\\int_{V_i} \\partial_t c \\, dx = \\int_{V_i} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial c}{\\partial x} \\right) dx + \\int_{V_i} R(c) \\, dx\n$$\nApplying the fundamental theorem of calculus (the 1D divergence theorem) to the diffusion term and approximating the integrals gives the semi-discrete equation for the cell-average concentration $c_i$:\n$$\n\\frac{d c_i}{dt} \\Delta x = \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i+1/2}} - \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i-1/2}} + R(c_i) \\Delta x\n$$\nLet $F = D \\frac{\\partial c}{\\partial x}$ be the diffusive flux. The equation becomes:\n$$\n\\frac{d c_i}{dt} = \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + R(c_i)\n$$\nFor a consistent and conservative scheme, the flux $F_{i+1/2}$ at the face between cell $i$ and cell $i+1$ is approximated using a two-point flux approximation (TPFA). The gradient is approximated by a central difference, $\\frac{\\partial c}{\\partial x} \\approx \\frac{c_{i+1}-c_i}{\\Delta x}$. To handle a variable diffusion coefficient $D(x)$, the effective diffusivity at the face, $D_{i+1/2}$, is computed using the harmonic mean of the values in the adjacent cells, $D_i = D(x_i)$ and $D_{i+1} = D(x_{i+1})$:\n$$\nF_{i+1/2} \\approx D_{i+1/2} \\frac{c_{i+1} - c_i}{\\Delta x}, \\quad \\text{where} \\quad D_{i+1/2} = \\frac{2 D_i D_{i+1}}{D_i + D_{i+1}}\n$$\nThis choice ensures flux continuity and physical consistency. Homogeneous Neumann boundary conditions correspond to zero flux at the domain boundaries: $F_{-1/2} = 0$ at $x=0$ and $F_{N-1/2} = 0$ at $x=L$.\n\nA first-order operator splitting (Lie splitting) is used to handle the diffusion and reaction terms separately. A single time step from $t^n$ to $t^{n+1}=t^n+\\Delta t$ consists of two sequential sub-steps:\n1.  **Implicit Diffusion Step**: Solve $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (D \\nabla c)$ from $t^n$ to $t^{n+1}$ to get an intermediate solution $c^{n+1/2}$.\n2.  **Implicit Source Step**: Solve $\\frac{\\partial c}{\\partial t} = R(c)$ from $t^n$ to $t^{n+1}$ using $c^{n+1/2}$ as the initial condition to get the final solution $c^{n+1}$.\n\nThe diffusion step is discretized using the backward Euler method for unconditional stability:\n$$\n\\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} = \\frac{1}{\\Delta x} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2})\n$$\nSubstituting the flux approximation gives a linear system of equations for the unknown concentrations $\\mathbf{c}^{n+1/2} = [c_0^{n+1/2}, \\dots, c_{N-1}^{n+1/2}]^T$. For an interior cell $i \\in [1, N-2]$:\n$$\nc_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} \\left[ D_{i+1/2}(c_{i+1}^{n+1/2} - c_i^{n+1/2}) - D_{i-1/2}(c_i^{n+1/2} - c_{i-1}^{n+1/2}) \\right] = c_i^n\n$$\nRearranging terms for cell $i$:\n$$\n-\\frac{\\Delta t}{\\Delta x^2} D_{i-1/2} c_{i-1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} (D_{i+1/2} + D_{i-1/2})\\right) c_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} D_{i+1/2} c_{i+1}^{n+1/2} = c_i^n\n$$\nFor the boundary cells, we apply the zero-flux conditions.\nFor cell $i=0$: $F_{-1/2}=0$, so the equation is $-\\frac{\\Delta t}{\\Delta x^2} D_{1/2} c_{1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{1/2}\\right) c_0^{n+1/2} = c_0^n$.\nFor cell $i=N-1$: $F_{N-1/2}=0$, so the equation is $-\\frac{\\Delta t}{\\Delta x^2} D_{N-3/2} c_{N-2}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{N-3/2}\\right) c_{N-1}^{n+1/2} = c_{N-1}^n$.\nThis forms a symmetric, diagonally dominant tridiagonal linear system $\\mathbf{A} \\mathbf{c}^{n+1/2} = \\mathbf{c}^n$, which can be solved efficiently. The resulting matrix $\\mathbf{A}$ is an M-matrix, which ensures that if $c_i^n \\ge 0$ for all $i$, then $c_i^{n+1/2} \\ge 0$.\n\nThe total mass for the diffusion step, $M = \\sum_i c_i \\Delta x$, is conserved. Summing the semi-discrete diffusion equation over all cells:\n$$\n\\sum_{i=0}^{N-1} \\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} \\Delta x = \\sum_{i=0}^{N-1} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2}) = F_{N-1/2}^{n+1/2} - F_{-1/2}^{n+1/2}\n$$\nThe sum on the right is a telescoping series. With zero-flux boundary conditions, $F_{-1/2} = F_{N-1/2} = 0$, so $\\sum_i (c_i^{n+1/2} - c_i^n) = 0$. This confirms exact discrete mass conservation for the diffusion step.\n\nThe source step solves the system of ordinary differential equations $\\frac{dc_i}{dt} = R(c_i)$ for each cell, starting from $c_i^{n+1/2}$. The source term is split into production and destruction components, $R(c) = P(c) - Q(c)c$, with $P(c) \\ge 0$ and $Q(c) \\ge 0$. Applying the backward Euler method gives:\n$$\n\\frac{c_i^{n+1} - c_i^{n+1/2}}{\\Delta t} = P(c_i^{n+1}) - Q(c_i^{n+1}) c_i^{n+1}\n$$\nFor the test cases, $P$ and $Q$ are constant. This allows for a direct solution for $c_i^{n+1}$:\n$$\nc_i^{n+1} (1 + \\Delta t Q) = c_i^{n+1/2} + \\Delta t P \\quad \\implies \\quad c_i^{n+1} = \\frac{c_i^{n+1/2} + \\Delta t P}{1 + \\Delta t Q}\n$$\nThis update guarantees positivity: since the diffusion step ensures $c_i^{n+1/2} \\ge 0$, and given $\\Delta t > 0$, $P \\ge 0$, $Q \\ge 0$, the numerator is non-negative and the denominator is positive, thus $c_i^{n+1} \\ge 0$.\n\nThe change in total mass during the source step is consistent with the integrated source term. From the update rule:\n$$\nc_i^{n+1} - c_i^{n+1/2} = \\Delta t (P - Q c_i^{n+1})\n$$\nSumming over all cells and multiplying by $\\Delta x$:\n$$\n\\sum_i (c_i^{n+1} - c_i^{n+1/2}) \\Delta x = \\Delta t \\sum_i (P - Q c_i^{n+1}) \\Delta x\n$$\n$$\nM^{n+1} - M^{n+1/2} = \\Delta t \\sum_i R(c_i^{n+1}) \\Delta x\n$$\nThis verifies that the change in total mass is exactly equal to the discrete integral of the source term evaluated at the new time level, as required for an implicit method.\nThe overall scheme is first-order accurate in time, second-order accurate in space for constant $D$, and is designed to be robustly conservative and positivity-preserving.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_one_step(params):\n    \"\"\"\n    Performs a single operator-split time step for the reactive diffusion equation\n    and verifies conservation and positivity properties.\n    \"\"\"\n    L, N, dt, c_init_func, D_func, P, Q, tol = params\n\n    # 1. Setup Grid and Initial Conditions\n    dx = L / N\n    # Cell centers\n    x_centers = (np.arange(N) + 0.5) * dx\n    c_n = c_init_func(x_centers, L)\n\n    # 2. Implicit Diffusion Step\n    \n    # Calculate D at cell centers\n    D_cell = D_func(x_centers, L)\n    \n    # Calculate D at internal faces using harmonic mean.\n    # D_face[i] corresponds to face between cell i and i+1\n    D_face = 2 * D_cell[:-1] * D_cell[1:] / (D_cell[:-1] + D_cell[1:] + 1e-30) # Add epsilon for safety\n    \n    # Assemble the tridiagonal system matrix A for A * c_half = c_n\n    # The system is rearranged from c_h - c_n = dt * Op * c_h to (I - dt*Op)c_h = c_n\n    alpha = dt / dx**2\n    \n    # The matrix for solve_banded is specified by its diagonals.\n    # It has shape (l+u+1, N), where l=1, u=1 are lower/upper bandwidths.\n    # ab[0, 1:] = upper diagonal\n    # ab[1, :]  = main diagonal\n    # ab[2, :-1]= lower diagonal\n    ab = np.zeros((3, N))\n    \n    # Upper/Lower diagonals (symmetric matrix)\n    # The element in the upper diagonal of row i is -alpha * D_{i+1/2}\n    # solve_banded expects ab[0, i+1] to be the (i, i+1) element.\n    # The element in the lower diagonal of row i is -alpha * D_{i-1/2}\n    # solve_banded expects ab[2, i-1] to be the (i, i-1) element.\n    \n    diag_val = -alpha * D_face\n    ab[0, 1:] = diag_val\n    ab[2, :-1] = diag_val\n    \n    # Main diagonal: 1 + alpha*(D_{i+1/2} + D_{i-1/2})\n    # For i=0, it's 1 + alpha*D_{1/2}. For i=N-1, it's 1 + alpha*D_{N-3/2}\n    main_diag = np.ones(N)\n    main_diag[:-1] += alpha * D_face\n    main_diag[1:] += alpha * D_face\n    ab[1, :] = main_diag\n\n    # Solve the tridiagonal system\n    c_half_step = solve_banded((1, 1), ab, c_n)\n    \n    # 3. Implicit Source Step\n    c_final = (c_half_step + dt * P) / (1.0 + dt * Q)\n    \n    # 4. Verification Checks\n    \n    # 4.1. Non-negativity of the final concentration\n    pass_negativity = np.min(c_final) >= 0.0\n    \n    # 4.2. Mass conservation during the diffusion step\n    mass_n = np.sum(c_n) * dx\n    mass_half = np.sum(c_half_step) * dx\n    pass_flux_cons = np.abs(mass_half - mass_n) < tol\n\n    # 4.3. Consistency of mass change with the source term\n    mass_final = np.sum(c_final) * dx\n    mass_change_actual = mass_final - mass_half\n    \n    # Theoretical mass change from source term integral: dt * sum(R(c_final)) * dx\n    # Where R(c) = P - Q*c is evaluated implicitly\n    source_integral = dt * np.sum(P - Q * c_final) * dx\n    pass_source_cons = np.abs(mass_change_actual - source_integral) < tol\n\n    return pass_negativity and pass_flux_cons and pass_source_cons\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation and verification for each.\n    \"\"\"\n    tol = 1e-10\n\n    test_cases = [\n        # Case 1: Diffusion-only, variable D\n        (\n            1.0, 50, 1.0, \n            lambda x, L: 1.0 + 0.1 * np.cos(2 * np.pi * x / L),\n            lambda x, L: 1e-3 + 5e-4 * np.sin(2 * np.pi * x / L),\n            0.0, 0.0, tol\n        ),\n        # Case 2: Stiff decay with diffusion\n        (\n            1.0, 100, 1e-2,\n            lambda x, L: 1e-3 + np.exp(-(x - 0.5 * L)**2 / 5e-3),\n            lambda x, L: 1e-3 * (1.0 + 0.9 * np.exp(-(x - 0.5 * L)**2 / 1e-2)),\n            0.0, 1e3, tol\n        ),\n        # Case 3: Stiff production-destruction with diffusion\n        (\n            1.0, 80, 5e-2,\n            lambda x, L: 0.2 + 0.2 * np.sin(3 * np.pi * x / L),\n            lambda x, L: 5e-4 + 0*x, # Constant D\n            0.5, 200.0, tol\n        ),\n    ]\n\n    results = []\n    for params in test_cases:\n        test_passed = run_one_step(params)\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507785"}, {"introduction": "Real-world simulations often involve moving or deforming boundaries, requiring a more general formulation than a static grid allows. This practice introduces the Arbitrary Lagrangian-Eulerian (ALE) framework, where control volumes themselves can move and deform. You will implement and verify the Geometric Conservation Law (GCL), a fundamental constraint ensuring that mesh motion itself does not create artificial mass, and see firsthand how it guarantees the correct behavior of the scheme. [@problem_id:3507787]", "problem": "Consider a two-dimensional finite volume discretization of a passive scalar on a skewed polygonal mesh whose vertices undergo an affine motion between time $t^n$ and $t^{n+1} = t^n + \\Delta t$. The objective is to verify conservation properties that are fundamental to the Finite Volume Method (FVM) in the context of Arbitrary Lagrangian-Eulerian (ALE) formulations for multiphysics coupled simulation. The starting point is the integral conservation law and the Reynolds transport theorem: the rate of change of the integral of a conserved quantity inside a moving control volume equals the net flux across the boundary plus sources. In the ALE form for a passive scalar $\\phi$, the governing equation in integral form is\n$$\n\\frac{d}{dt} \\int_{V(t)} \\phi \\, dV \\;+\\; \\oint_{\\partial V(t)} \\phi \\, (\\boldsymbol{u} - \\boldsymbol{w}) \\cdot \\boldsymbol{n} \\, dA \\;=\\; \\int_{V(t)} S \\, dV,\n$$\nwhere $\\boldsymbol{u}$ is the physical velocity, $\\boldsymbol{w}$ is the grid (mesh) velocity, $\\boldsymbol{n}$ is the outward unit normal, and $S$ is a source term. For the Geometric Conservation Law (GCL), the geometric identity\n$$\n\\frac{d}{dt} \\, V(t) \\;=\\; \\oint_{\\partial V(t)} \\boldsymbol{w} \\cdot \\boldsymbol{n} \\, dA\n$$\nensures that a uniform scalar field is preserved under pure mesh motion when $\\boldsymbol{u} = \\boldsymbol{0}$ and $S = 0$, provided the discrete fluxes exactly satisfy the discrete counterpart of this identity.\n\nYour task is to implement a program that, starting from these fundamental principles, constructs a skewed polygonal mesh, applies an affine mesh motion, and evaluates conservative ALE finite volume updates and flux balances using face-based fluxes. All geometric quantities must be computed from first principles: polygon areas via the shoelace formula, face lengths, and outward unit normals from edge vectors. All face fluxes must be assembled using midpoint evaluation for the grid velocity. Physical units must be respected: positions in meters, time in seconds, and velocities in meters per second. Angle units are not required. No percentage outputs are permitted; express any ratio or change as a decimal.\n\nDefinitions on first use:\n- Finite Volume Method (FVM): a method that evolves cell-averaged quantities using face fluxes consistent with integral conservation laws.\n- Arbitrary Lagrangian-Eulerian (ALE): a formulation that allows the mesh to move with an arbitrary velocity $\\boldsymbol{w}$ while physical fields advect with velocity $\\boldsymbol{u}$ relative to the mesh.\n- Geometric Conservation Law (GCL): the discrete identity equating the control volume change to the net mesh-swept volume across its faces.\n\nDiscretization requirements:\n- For a polygonal cell with vertices $\\{\\boldsymbol{x}_i\\}_{i=0}^{N-1}$ in counter-clockwise order at time $t^n$, define edges $\\boldsymbol{e}_i = \\boldsymbol{x}_{i+1} - \\boldsymbol{x}_i$ with indices modulo $N$. The outward unit normal $\\boldsymbol{n}_i$ must be the right-handed rotation of $\\boldsymbol{e}_i$ divided by its length.\n- The face flux due to mesh motion at the midpoint $\\boldsymbol{x}_f$ must be evaluated as $\\boldsymbol{w}(\\boldsymbol{x}_f) \\cdot \\boldsymbol{n}_i \\, L_i$, where $L_i$ is the face length.\n- For ALE scalar update over one time step, use the conservative update\n$$\nM^{n+1} \\;=\\; M^n \\;-\\; \\Delta t \\sum_{f} \\phi_f \\, (\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f \\, L_f,\n$$\nwith $M^n = \\phi^n \\, V^n$, and $\\phi_f$ selected by upwind with respect to $(\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f$. For pure mesh motion verification, set $\\boldsymbol{u} = \\boldsymbol{0}$ and use $\\phi_f = \\phi^n$ for a uniform field. Compute $\\phi^{n+1} = M^{n+1} / V^{n+1}$.\n\nTest suite specification:\nImplement the following test suite with specified parameters and produce the aggregated results in the exact format described below.\n\nMesh definition (two skewed quadrilateral cells sharing an internal face), at time $t^n$ with positions in meters:\n- Cell $0$: vertices (counter-clockwise) $[(0,0),\\, (1.2,0.0),\\, (1.4,1.0),\\, (0.2,1.0)]$.\n- Cell $1$: vertices (counter-clockwise) $[(1.2,0.0),\\, (2.0,0.0),\\, (2.1,1.0),\\, (1.4,1.0)]$.\n\nAffine mesh motion from $t^n$ to $t^{n+1}$:\n- Time step $\\Delta t = 0.2\\,$s.\n- Grid velocity $\\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{a} + \\boldsymbol{B} \\boldsymbol{x}$ with $\\boldsymbol{a} = (0.05,\\, -0.02)\\,$m/s and\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} 0.0 & 0.1 \\\\ -0.05 & 0.0 \\end{bmatrix} \\;\\text{(in s}^{-1}\\text{)}.\n$$\nUpdate vertices via $\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t \\, \\boldsymbol{w}(\\boldsymbol{x}^n)$.\n\nPhysical advection case on a stationary mesh:\n- Physical velocity $\\boldsymbol{u} = (0.6,\\, -0.3)\\,$m/s, stationary mesh $\\boldsymbol{w} = \\boldsymbol{0}$.\n- No-flow boundary condition on all external faces: set boundary advective fluxes to $0$.\n- Upwind selection for $\\phi_f$ on the shared internal face.\n\nScalar initial conditions:\n- Uniform field case: $\\phi^n = 3.7$ (dimensionless constant) for both cells.\n- Nonuniform field case: $\\phi^n = [2.0,\\, 1.0]$ for cells $[0,\\,1]$.\n\nTolerance:\n- Use absolute tolerance $\\varepsilon = 10^{-12}$ for boolean checks.\n\nRequired outputs for the test suite:\n1. Local discrete GCL check on Cell $0$: compute $\\Delta V = V^{n+1} - V^n$ and the discrete swept-volume sum $S = \\Delta t \\sum_f \\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f \\, L_f$, and return the boolean $|\\Delta V - S| \\le \\varepsilon$.\n2. Local discrete GCL check on Cell $1$: same boolean as in $1$ for Cell $1$.\n3. Uniform field preservation under pure mesh motion: compute $\\phi^{n+1}$ for both cells with $\\boldsymbol{u} = \\boldsymbol{0}$, and return the boolean that the maximum absolute deviation satisfies $\\max_i |\\phi_i^{n+1} - \\phi^n| \\le \\varepsilon$.\n4. Global mass conservation for physical advection on the stationary mesh with no-flow boundaries: using $\\boldsymbol{u}$ and nonuniform $\\phi^n = [2.0,\\, 1.0]$, compute the total scalar mass change over one time step and return it as a float $\\Delta M_{\\text{total}} = \\sum_i M_i^{n+1} - \\sum_i M_i^n$ (in consistent units of the scalar times area). This value should be numerically near $0$; do not round it and do not attach units in the output.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r_1, r_2, r_3, r_4]$, where $r_1$ and $r_2$ are booleans for the GCL checks, $r_3$ is a boolean for uniform field preservation, and $r_4$ is a float for global mass change. For example, an output could look like `[True,True,True,1.234e-16]`.", "solution": "The problem statement poses a well-defined and scientifically grounded task in the field of computational fluid dynamics, specifically concerning the finite volume method (FVM) for Arbitrary Lagrangian-Eulerian (ALE) formulations. All required data, definitions, and discretization rules are provided, and they are internally consistent and conform to established principles. The problem is valid.\n\nThe solution will be implemented by first establishing geometric and kinematic utility functions based on the provided specifications. We will then proceed to carry out the four required calculations in sequence.\n\n**1. Geometric and Kinematic Preliminaries**\n\nFirst, we define the computational framework, including the mesh, motion, and physical parameters, and implement the necessary helper functions.\n\nThe initial positions (in meters, $m$) of the vertices for Cell $0$ and Cell $1$ at time $t^n$ are given as:\n- Cell $0$: $C_0^n = \\{(0,0), (1.2,0.0), (1.4,1.0), (0.2,1.0)\\}$\n- Cell $1$: $C_1^n = \\{(1.2,0.0), (2.0,0.0), (2.1,1.0), (1.4,1.0)\\}$\n\nThe time step is $\\Delta t = 0.2 \\, s$. The affine grid velocity field is $\\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{a} + \\boldsymbol{B} \\boldsymbol{x}$, with vector $\\boldsymbol{a} = (0.05, -0.02) \\, m/s$ and matrix $\\boldsymbol{B} = \\begin{bmatrix} 0.0 & 0.1 \\\\ -0.05 & 0.0 \\end{bmatrix} \\, s^{-1}$. The vertex positions at time $t^{n+1}$ are computed using a forward Euler update: $\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t \\, \\boldsymbol{w}(\\boldsymbol{x}^n)$.\n\nA function to compute the area of a polygon is required. The shoelace formula provides a direct method: for a polygon with $N$ vertices $(\\boldsymbol{x}_i)_{i=0}^{N-1}$ ordered counter-clockwise, the area $V$ is:\n$$\nV = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nwhere the index $i+1$ is taken modulo $N$.\n\nFor each face of a cell, defined by edge vector $\\boldsymbol{e}_i = \\boldsymbol{x}_{i+1} - \\boldsymbol{x}_i = (\\Delta x_i, \\Delta y_i)$, we need its length $L_i$, its outward unit normal $\\boldsymbol{n}_i$, and its midpoint $\\boldsymbol{x}_{f,i}$. For a counter-clockwise ordered polygon, the outward normal is obtained by a right-handed rotation of the edge vector.\n$$\nL_i = \\|\\boldsymbol{e}_i\\| = \\sqrt{\\Delta x_i^2 + \\Delta y_i^2}\n$$\n$$\n\\boldsymbol{n}_i = \\frac{(\\Delta y_i, -\\Delta x_i)}{L_i}\n$$\n$$\n\\boldsymbol{x}_{f,i} = \\frac{\\boldsymbol{x}_i + \\boldsymbol{x}_{i+1}}{2}\n$$\n\n**2. Task 1 & 2: Discrete Geometric Conservation Law (GCL) Check**\n\nThe discrete GCL verifies that the change in the computed volume of a cell equals the total volume swept by its faces. The change in volume is $\\Delta V = V^{n+1} - V^n$. The volume swept by the faces, approximated using a first-order scheme with midpoint evaluation, is $S = \\Delta t \\sum_f \\boldsymbol{w}(\\boldsymbol{x}_f) \\cdot \\boldsymbol{n}_f L_f$. The check requires evaluating whether $|\\Delta V - S| \\le \\varepsilon$ for a tolerance $\\varepsilon=10^{-12}$.\n\nFor Cell $0$ and Cell $1$:\n- We compute their initial areas, $V_0^n$ and $V_1^n$, using the shoelace formula on the initial vertices.\n- We compute the new vertex positions for both cells at $t^{n+1}$.\n- We compute the new areas, $V_0^{n+1}$ and $V_1^{n+1}$, from the updated vertices.\n- For each cell, we iterate through its faces at $t^n$, calculate the face length $L_f$, outward normal $\\boldsymbol{n}_f$, and midpoint $\\boldsymbol{x}_f$. At the midpoint, we evaluate the grid velocity $\\boldsymbol{w}_f = \\boldsymbol{w}(\\boldsymbol{x}_f)$ and compute the flux contribution $\\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f L_f$.\n- The sum of these contributions, multiplied by $\\Delta t$, gives the total swept volume $S$ for each cell.\n- Finally, we compare $|\\Delta V - S|$ with $\\varepsilon$ for each cell.\n\n**3. Task 3: Uniform Field Preservation**\n\nThis task verifies a key consequence of the GCL: a spatially uniform scalar field should remain uniform under pure mesh motion ($\\boldsymbol{u}=\\boldsymbol{0}$) if the GCL is satisfied by the numerical scheme.\nThe initial condition is a uniform scalar field $\\phi^n = 3.7$ for both cells. The conservative ALE update for the total amount of scalar $M = \\phi V$ in a cell is:\n$$\nM^{n+1} = M^n - \\Delta t \\sum_f \\phi_f (\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f L_f\n$$\nWith $\\boldsymbol{u}=\\boldsymbol{0}$ and the specified upwind choice $\\phi_f = \\phi^n$ for a uniform field, this simplifies to:\n$$\nM^{n+1} = M^n - \\Delta t \\sum_f \\phi^n (-\\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f L_f = \\phi^n V^n + \\Delta t \\, \\phi^n \\sum_f \\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f L_f = \\phi^n (V^n + S/\\Delta t)\n$$\nThe new scalar value is $\\phi^{n+1} = M^{n+1}/V^{n+1}$. Substituting the expression for $M^{n+1}$:\n$$\n\\phi^{n+1} = \\frac{\\phi^n(V^n + S/\\Delta t)}{V^{n+1}} = \\phi^n \\frac{V^n \\Delta t + S}{\\Delta t V^{n+1}}\n$$\nThe deviation from the original uniform value is $|\\phi^{n+1} - \\phi^n| = |\\phi^n| \\frac{|V^n - V^{n+1} + S/\\Delta t|}{V^{n+1}} = |\\phi^n| \\frac{|S - \\Delta V|}{\\Delta t V^{n+1}}$. This shows that uniform field preservation is directly tied to the GCL satisfaction. We compute $\\phi_0^{n+1}$ and $\\phi_1^{n+1}$ using the full update formula and check if $\\max_i |\\phi_i^{n+1} - \\phi^n| \\le \\varepsilon$.\n\n**4. Task 4: Global Mass Conservation**\n\nThis task verifies that the scheme conserves the total amount of scalar in a closed system. The setup involves a stationary mesh ($\\boldsymbol{w}=\\boldsymbol{0}$), a constant physical velocity $\\boldsymbol{u}=(0.6, -0.3) \\, m/s$, and no-flow boundary conditions on all external faces. The initial scalar field is non-uniform: $\\phi^n = [2.0, 1.0]$.\n\nSince the mesh is stationary, $V^{n+1}=V^n$. The update law is $M^{n+1} = M^n - \\Delta t \\sum_f \\phi_f (\\boldsymbol{u} \\cdot \\boldsymbol{n}_f) L_f$.\nThe no-flow condition means fluxes across external faces are zero. The only non-zero flux is across the shared internal face between Cell $0$ and Cell $1$. Let this face have length $L_{int}$ and a normal $\\boldsymbol{n}_{01}$ pointing from Cell $0$ to Cell $1$. The normal for Cell $1$ on this face is $\\boldsymbol{n}_{10} = -\\boldsymbol{n}_{01}$.\nThe convective velocity across the face is $v_n = \\boldsymbol{u} \\cdot \\boldsymbol{n}_{01}$.\nThe upwind scheme selects the scalar value from the \"upwind\" cell:\n- If $v_n > 0$, flow is from $0 \\to 1$, so $\\phi_f = \\phi_0^n$.\n- If $v_n < 0$, flow is from $1 \\to 0$, so $\\phi_f = \\phi_1^n$.\nThe total flux out of Cell $0$ is $F_0 = \\phi_f \\cdot v_n \\cdot L_{int}$.\nThe total flux out of Cell $1$ is $F_1 = \\phi_f \\cdot (\\boldsymbol{u} \\cdot \\boldsymbol{n}_{10}) \\cdot L_{int} = \\phi_f \\cdot (-\\boldsymbol{u} \\cdot \\boldsymbol{n}_{01}) \\cdot L_{int} = -F_0$.\nThe updates are $M_0^{n+1} = M_0^n - \\Delta t F_0$ and $M_1^{n+1} = M_1^n - \\Delta t F_1 = M_1^n + \\Delta t F_0$.\nThe total final mass is $M_{total}^{n+1} = M_0^{n+1} + M_1^{n+1} = (M_0^n - \\Delta t F_0) + (M_1^n + \\Delta t F_0) = M_0^n + M_1^n = M_{total}^n$.\nTherefore, the total change in mass, $\\Delta M_{total} = M_{total}^{n+1} - M_{total}^n$, should be zero up to floating-point precision. We compute this value directly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ALE FVM problem by performing four verification tasks.\n    \"\"\"\n    \n    # ------------------\n    # 1. SETUP: Parameters and Geometry\n    # ------------------\n    \n    # Constants and parameters from the problem statement\n    dt = 0.2  # s\n    a = np.array([0.05, -0.02])  # m/s\n    B = np.array([[0.0, 0.1], [-0.05, 0.0]])  # 1/s\n    u_phys = np.array([0.6, -0.3])  # m/s\n    epsilon = 1e-12\n    phi_uniform = 3.7\n    phi_nonuniform = [2.0, 1.0]\n\n    # Initial mesh vertices (t=t^n)\n    cell0_verts_n = [\n        np.array([0.0, 0.0]), np.array([1.2, 0.0]),\n        np.array([1.4, 1.0]), np.array([0.2, 1.0])\n    ]\n    cell1_verts_n = [\n        np.array([1.2, 0.0]), np.array([2.0, 0.0]),\n        np.array([2.1, 1.0]), np.array([1.4, 1.0])\n    ]\n    cells_n = [cell0_verts_n, cell1_verts_n]\n\n    # Helper functions\n    def polygon_area(vertices):\n        \"\"\"Calculates polygon area using the shoelace formula.\"\"\"\n        area = 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            area += p1[0] * p2[1] - p2[0] * p1[1]\n        return 0.5 * abs(area)\n\n    def get_face_props(v1, v2):\n        \"\"\"Calculates face length, outward normal, and midpoint.\"\"\"\n        edge_vec = v2 - v1\n        length = np.linalg.norm(edge_vec)\n        if length < epsilon:\n            return 0.0, np.array([0.0, 0.0]), (v1 + v2) / 2.0\n        # Right-handed rotation for CCW polygon: (dy, -dx)\n        normal_vec = np.array([edge_vec[1], -edge_vec[0]])\n        unit_normal = normal_vec / length\n        midpoint = (v1 + v2) / 2.0\n        return length, unit_normal, midpoint\n\n    def w_vel(x):\n        \"\"\"Calculates grid velocity at a point x.\"\"\"\n        return a + B @ x\n\n    # ------------------\n    # Pre-calculations for all tasks\n    # ------------------\n\n    # Initial volumes\n    V_n = [polygon_area(c) for c in cells_n]\n\n    # Calculate all unique vertices at t^n and update them to t^{n+1}\n    all_verts_n = {}\n    for cell in cells_n:\n        for v in cell:\n            all_verts_n[tuple(v)] = v\n            \n    updated_verts_map = {\n        key: v + dt * w_vel(v) for key, v in all_verts_n.items()\n    }\n\n    # Construct cells at t^{n+1}\n    cells_nplus1 = []\n    for cell_n in cells_n:\n        cell_nplus1 = [updated_verts_map[tuple(v)] for v in cell_n]\n        cells_nplus1.append(cell_nplus1)\n    \n    # Volumes at t^{n+1}\n    V_nplus1 = [polygon_area(c) for c in cells_nplus1]\n\n\n    # ------------------\n    # TASK 1 & 2: Local Discrete GCL Check\n    # ------------------\n    \n    delta_V = [V_nplus1[i] - V_n[i] for i in range(2)]\n    S_discrete = [0.0, 0.0]\n\n    for i in range(2):\n        cell_verts = cells_n[i]\n        num_verts = len(cell_verts)\n        flux_sum = 0.0\n        for j in range(num_verts):\n            v1 = cell_verts[j]\n            v2 = cell_verts[(j + 1) % num_verts]\n            L, n, x_f = get_face_props(v1, v2)\n            w_f = w_vel(x_f)\n            flux_sum += np.dot(w_f, n) * L\n        S_discrete[i] = flux_sum\n\n    S_total = [dt * s for s in S_discrete]\n\n    r1 = abs(delta_V[0] - S_total[0]) <= epsilon\n    r2 = abs(delta_V[1] - S_total[1]) <= epsilon\n\n    # ------------------\n    # TASK 3: Uniform Field Preservation\n    # ------------------\n    \n    M_n_uniform = [phi_uniform * v for v in V_n]\n    phi_nplus1_uniform = [0.0, 0.0]\n\n    for i in range(2):\n        flux_sum = 0.0\n        cell_verts = cells_n[i]\n        num_verts = len(cell_verts)\n        for j in range(num_verts):\n            v1 = cell_verts[j]\n            v2 = cell_verts[(j + 1) % num_verts]\n            L, n, x_f = get_face_props(v1, v2)\n            w_f = w_vel(x_f)\n            # u=0 for pure mesh motion, so v_rel = -w_f\n            v_rel = -w_f  \n            # phi_f = phi^n for uniform field test\n            flux_sum += phi_uniform * np.dot(v_rel, n) * L\n\n        M_nplus1_i = M_n_uniform[i] - dt * flux_sum\n        phi_nplus1_uniform[i] = M_nplus1_i / V_nplus1[i]\n\n    max_dev = max(abs(p - phi_uniform) for p in phi_nplus1_uniform)\n    r3 = max_dev <= epsilon\n\n    # ------------------\n    # TASK 4: Global Mass Conservation\n    # ------------------\n\n    M_total_n = phi_nonuniform[0] * V_n[0] + phi_nonuniform[1] * V_n[1]\n\n    # Identify internal face (from cell 0's perspective)\n    # Cell 0: [(0,0), (1.2,0), (1.4,1), (0.2,1)]; Face is (1.2,0)->(1.4,1)\n    v1_int = cells_n[0][1]\n    v2_int = cells_n[0][2]\n\n    # Get internal face properties from cell 0's perspective\n    L_int, n_int_0, _ = get_face_props(v1_int, v2_int)\n    \n    # Normal velocity relative to cell 0's outward normal\n    v_n = np.dot(u_phys, n_int_0)\n    \n    # Upwind flux\n    if v_n > 0: # Flow 0 -> 1\n        phi_f = phi_nonuniform[0]\n    else: # Flow 1 -> 0 or zero flow\n        phi_f = phi_nonuniform[1]\n        \n    # Flux out of Cell 0 across the internal face\n    flux_0_out = phi_f * v_n * L_int\n\n    # Update masses. Stationary mesh, so V is constant.\n    M0_n, M1_n = phi_nonuniform[0] * V_n[0], phi_nonuniform[1] * V_n[1]\n    \n    # Flux into Cell 1 is flux out of Cell 0. So flux out of Cell 1 is -flux_0_out\n    M0_nplus1 = M0_n - dt * flux_0_out\n    M1_nplus1 = M1_n - dt * (-flux_0_out)\n\n    M_total_nplus1 = M0_nplus1 + M1_nplus1\n    \n    r4 = M_total_nplus1 - M_total_n\n\n    # ------------------\n    # Final Output\n    # ------------------\n    results = [r1, r2, r3, r4]\n    \n    # Use str() to get 'True'/'False' for booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507787"}, {"introduction": "Multiphysics simulations often involve coupling distinct domains that are discretized with non-matching grids. This exercise tackles the critical task of transferring fluxes conservatively across such an interface using a mortar method. By implementing a robust algorithm to project flux from a donor to a receiver mesh, you will learn how to ensure that no mass or energy is artificially lost or gained at the coupling boundary, a cornerstone of any valid multiphysics simulation. [@problem_id:3507765]", "problem": "Consider a planar interface $\\Gamma$ between two computational subdomains in a multiphysics setting, discretized for the Finite Volume Method (FVM). The interface is represented by a one-dimensional segment of total length $L$ embedded in two-dimensional space with unit depth, so that face area is equal to the segment length times a unit depth of $1$. On each side of the interface, the mesh partitions $\\Gamma$ into faces whose projections onto the interface are intervals. Let the left-side interface partition be $\\{I_i\\}_{i=1}^{N_L}$ with endpoints $\\{x^L_i\\}_{i=0}^{N_L}$, and the right-side interface partition be $\\{J_j\\}_{j=1}^{N_R}$ with endpoints $\\{x^R_j\\}_{j=0}^{N_R}$. The partitions satisfy $x^L_0 = x^R_0 = 0$, $x^L_{N_L} = x^R_{N_R} = L$, and are strictly increasing.\n\nSuppose the normal flux density on the donor side (for definiteness, choose the left side) is piecewise constant across faces: on $I_i$ it is $f_i$, representing $\\mathbf{F}\\cdot\\mathbf{n}$ for a unit normal that is globally consistent across both sides of the interface. The integrated flux across a face is $f_i A_i$, where $A_i$ is the face area equal to the segment length $|I_i|$ times the unit depth of $1$. A conservative mortar transfer defines a receiver-side flux density $g_j$ on each $J_j$ such that integrated flux is conserved over every receiver face:\n$$\ng_j\\,|J_j| \\;=\\; \\sum_{i=1}^{N_L} f_i\\,|I_i \\cap J_j|\\,,\n$$\nwhere $|I_i \\cap J_j|$ is the measure (length) of the overlap of the donor face $I_i$ with the receiver face $J_j$.\n\nStarting from the local conservation law and the divergence theorem, and from the FVM definition of flux across an interface as the sum of face-integrated normal fluxes, derive the mortar transfer rule above from first principles and design an algorithm that, given donor partition endpoints $\\{x^L_i\\}$, donor flux densities $\\{f_i\\}$, and receiver partition endpoints $\\{x^R_j\\}$, computes $\\{g_j\\}$ using only interval overlaps. Then, implement a program that verifies global conservation to machine precision by checking that\n$$\n\\sum_{i=1}^{N_L} f_i\\,|I_i| \\;\\text{ and }\\; \\sum_{j=1}^{N_R} g_j\\,|J_j|\n$$\nare equal up to a tolerance threshold $\\tau$, where $\\tau$ is chosen as $10^{-12}$. Equality is to be interpreted as $|\\sum_{i=1}^{N_L} f_i\\,|I_i| - \\sum_{j=1}^{N_R} g_j\\,|J_j|| \\le \\tau$.\n\nPhysical units: Treat $\\mathbf{F}\\cdot\\mathbf{n}$ as heat flux density in $\\mathrm{W\\,m^{-2}}$, face area $A_f$ in $\\mathrm{m^2}$, and integrated flux $f_i A_i$ in $\\mathrm{W}$. The programâ€™s outputs are boolean values and thus unitless, but the inputs are physically consistent.\n\nAngle unit: Not applicable; no angles are used.\n\nYour algorithm must not assume matching meshes and must compute overlaps robustly. Use a two-pointer sweep to compute overlaps in linear time in $N_L+N_R$.\n\nTest Suite. For each test case, the interface length is $L=1.0$ meters and the unit depth is $1.0$ meters, so face area is equal to segment length. Normals are aligned consistently from left to right on both sides.\n\nDefine four test cases that exercise different aspects of conservative mortar transfer:\n\n$1.$ Happy path nonmatching partitions with mixed positive and negative flux density. Donor (left) to receiver (right):\n- Left endpoints: $\\{0.0, 0.3, 0.7, 1.0\\}$, so $N_L=3$.\n- Left flux densities $\\{f_i\\}$ in $\\mathrm{W\\,m^{-2}}$: $\\{1.5, -2.0, 3.25\\}$.\n- Right endpoints: $\\{0.0, 0.5, 1.0\\}$, so $N_R=2$.\nCheck $|\\sum_i f_i |I_i| - \\sum_j g_j |J_j|| \\le \\tau$ with $\\tau = 10^{-12}$.\n\n$2.$ Reverse direction mapping (right donor to left receiver) with a different nonmatching partition and zero flux on one face:\n- Right endpoints: $\\{0.0, 0.4, 0.9, 1.0\\}$, so $N_R=3$.\n- Right flux densities in $\\mathrm{W\\,m^{-2}}$: $\\{-1.0, 0.0, 2.0\\}$.\n- Left endpoints: $\\{0.0, 0.2, 0.6, 0.65, 0.85, 1.0\\}$, so $N_L=5$.\nMap from right to left and check conservation with the same tolerance $\\tau = 10^{-12}$.\n\n$3.$ Boundary case with a single receiver face covering the entire interface:\n- Left endpoints: $\\{0.0, 0.25, 0.5, 0.75, 1.0\\}$, so $N_L=4$.\n- Left flux densities in $\\mathrm{W\\,m^{-2}}$: $\\{2.0, 2.0, 2.0, 2.0\\}$.\n- Right endpoints: $\\{0.0, 1.0\\}$, so $N_R=1$.\nMap from left to right and check conservation with $\\tau = 10^{-12}$.\n\n$4.$ Edge case with a very small donor segment and varied flux densities:\n- Left endpoints: $\\{0.0, 1.0\\times 10^{-6}, 0.4, 1.0\\}$, so $N_L=3$.\n- Left flux densities in $\\mathrm{W\\,m^{-2}}$: $\\{1000.0, -250.0, 500.0\\}$.\n- Right endpoints: $\\{0.0, 0.3, 0.7, 1.0\\}$, so $N_R=3$.\nMap from left to right and check conservation with $\\tau = 10^{-12}$.\n\nRequired final output format: Your program should produce a single line of output containing the results of the four test cases as a comma-separated list enclosed in square brackets, for example, `[True,True,True,True]` if all tests pass. Each entry must be a boolean indicating whether global conservation holds within tolerance $\\tau$ for that test case. No other text should be printed.", "solution": "The problem requires the derivation and implementation of a conservative mortar transfer method for coupling fluxes between non-conforming meshes at a planar interface in a Finite Volume Method (FVM) context.\n\n### 1. Derivation of the Conservative Mortar Transfer Rule\n\nThe derivation begins from the fundamental principle of local conservation for a physical quantity, governed by a conservation law. For a steady-state problem without sources or sinks within the control volume, the conservation law for a flux vector $\\mathbf{F}$ is expressed as:\n$$\n\\nabla \\cdot \\mathbf{F} = 0\n$$\nIntegrating this equation over an arbitrary control volume $V$ and applying the Gauss-divergence theorem yields:\n$$\n\\int_V \\nabla \\cdot \\mathbf{F} \\, dV = \\oint_{\\partial V} \\mathbf{F} \\cdot \\mathbf{n} \\, dA = 0\n$$\nThis states that the net flux across the boundary $\\partial V$ of any control volume is zero.\n\nIn the Finite Volume Method, the computational domain is partitioned into a set of discrete control volumes (cells). The integral flux conservation is enforced for each cell. The boundary integral is approximated as a sum of integrated fluxes over the faces of the cell:\n$$\n\\sum_{f \\in \\text{faces}(V)} \\int_{A_f} \\mathbf{F} \\cdot \\mathbf{n}_f \\, dA = 0\n$$\nwhere $A_f$ is the area of face $f$ and $\\mathbf{n}_f$ is its outward-pointing normal vector. The term $\\mathcal{F}_f = \\int_{A_f} \\mathbf{F} \\cdot \\mathbf{n}_f \\, dA$ represents the integrated flux through face $f$.\n\nNow, let us consider the interface $\\Gamma$ between two subdomains, a \"donor\" (left) and a \"receiver\" (right). The total flux transferred across this interface, from the donor to the receiver, must be conserved. Let $\\mathbf{n}$ be the unit normal vector pointing from the donor to the receiver side, consistent across $\\Gamma$. The total flux across the interface is:\n$$\n\\mathcal{F}_{\\Gamma} = \\int_{\\Gamma} \\mathbf{F} \\cdot \\mathbf{n} \\, dA\n$$\nThe problem specifies that on the donor side, the interface $\\Gamma$ is partitioned into a set of faces $\\{I_i\\}_{i=1}^{N_L}$. The flux density normal to the interface, $\\mathbf{F} \\cdot \\mathbf{n}$, is assumed to be piecewise constant on this partition, with a value of $f_i$ on face $I_i$. Thus, the total flux can be written as the sum of fluxes over the donor faces:\n$$\n\\mathcal{F}_{\\Gamma} = \\sum_{i=1}^{N_L} \\int_{I_i} (\\mathbf{F} \\cdot \\mathbf{n}) \\, dA = \\sum_{i=1}^{N_L} f_i \\int_{I_i} dA = \\sum_{i=1}^{N_L} f_i A_i\n$$\nGiven the problem's simplification to a two-dimensional setting with unit depth ($1$), the face area $A_i$ is numerically equal to the length of the segment $I_i$, denoted $|I_i|$.\n$$\n\\mathcal{F}_{\\Gamma,\\text{donor}} = \\sum_{i=1}^{N_L} f_i |I_i|\n$$\nSimilarly, on the receiver side, the interface is partitioned into faces $\\{J_j\\}_{j=1}^{N_R}$. We define a piecewise constant flux density $g_j$ for each receiver face $J_j$. The total flux calculated from the receiver side is:\n$$\n\\mathcal{F}_{\\Gamma,\\text{receiver}} = \\sum_{j=1}^{N_R} g_j |J_j|\n$$\nGlobal conservation demands $\\mathcal{F}_{\\Gamma,\\text{donor}} = \\mathcal{F}_{\\Gamma,\\text{receiver}}$. However, a stronger, more local form of conservation is required for a physically consistent and stable numerical coupling. A conservative mortar method enforces this by projecting the flux from the donor partition onto the receiver partition. This is achieved by requiring that the integrated flux entering each individual receiver face $J_j$ must equal the total flux exiting the donor domain across the same geometric region $J_j$.\n\nThe integrated flux into receiver face $J_j$ is, by definition, $g_j |J_j|$.\n\nThe flux exiting the donor side over the region covered by $J_j$ is $\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA$. Since the donor flux density is piecewise constant ($f_i$ on $I_i$), this integral must be decomposed according to the donor partition:\n$$\n\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA = \\sum_{i=1}^{N_L} \\int_{I_i \\cap J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA\n$$\nOn the overlap region $I_i \\cap J_j$, the donor flux density is $f_i$. Therefore:\n$$\n\\int_{J_j} (\\mathbf{F} \\cdot \\mathbf{n})_{\\text{donor}} \\, dA = \\sum_{i=1}^{N_L} f_i \\int_{I_i \\cap J_j} dA = \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j|\n$$\nEquating the flux into the receiver face $J_j$ with the flux from the donor over the same region gives the local conservation law, which is the specified mortar transfer rule:\n$$\ng_j |J_j| = \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j|\n$$\nThis derivation confirms the provided formula is a direct consequence of enforcing flux conservation on each receiver face by projecting the given piecewise constant donor flux distribution. Summing this relation over all receiver faces $j$ demonstrates that it implies global conservation:\n$$\n\\sum_{j=1}^{N_R} g_j |J_j| = \\sum_{j=1}^{N_R} \\sum_{i=1}^{N_L} f_i |I_i \\cap J_j| = \\sum_{i=1}^{N_L} f_i \\left( \\sum_{j=1}^{N_R} |I_i \\cap J_j| \\right)\n$$\nSince the receiver partition $\\{J_j\\}_{j=1}^{N_R}$ covers the entire interface, the sum of the lengths of the overlaps of a given donor face $I_i$ with all receiver faces is equal to the length of $I_i$ itself: $\\sum_{j=1}^{N_R} |I_i \\cap J_j| = |I_i|$. This leads to:\n$$\n\\sum_{j=1}^{N_R} g_j |J_j| = \\sum_{i=1}^{N_L} f_i |I_i|\n$$\nThus, local conservation on each receiver face guarantees global conservation across the entire interface, which the program is tasked to verify.\n\n### 2. Algorithmic Design\n\nThe core task is to compute the integrated flux on each receiver face, $g_j |J_j|$, which requires summing up the contributions $f_i |I_i \\cap J_j|$ from all donor faces $I_i$. A naive double loop over $i$ and $j$ would have a time complexity of $O(N_L N_R)$. A more efficient linear-time algorithm, $O(N_L + N_R)$, can be designed using a two-pointer sweep, which leverages the fact that both partitions are sorted along the interface.\n\nLet the donor partition be defined by endpoints $\\{x^D_i\\}_{i=0}^{N_D}$ and flux densities $\\{f_i\\}_{i=1}^{N_D}$. A donor face $I_i$ is the interval $[x^D_{i-1}, x^D_i]$.\nLet the receiver partition be defined by endpoints $\\{x^R_j\\}_{j=0}^{N_R}$. A receiver face $J_j$ is the interval $[x^R_{j-1}, x^R_j]$.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization**:\n    -   Initialize two pointers (indices): a donor pointer $i = 1$ and a receiver pointer $j = 1$.\n    -   Create an array, `integrated_receiver_flux`, of size $N_R$, initialized to zeros. `integrated_receiver_flux[j-1]` will accumulate the value of $g_j|J_j|$.\n\n2.  **Sweep Loop**:\n    -   Iterate while $i \\le N_D$ and $j \\le N_R$. In each step, we consider the current donor face $I_i = [x^D_{i-1}, x^D_i]$ and receiver face $J_j = [x^R_{j-1}, x^R_j]$.\n    -   **Compute Overlap**: Calculate the intersection of the two intervals. The start of the overlap is $\\text{start} = \\max(x^D_{i-1}, x^R_{j-1})$ and the end is $\\text{end} = \\min(x^D_i, x^R_j)$. The length of the overlap is $\\text{length} = \\max(0, \\text{end} - \\text{start})$.\n    -   **Accumulate Flux**: If the overlap length is positive, calculate the flux contribution from this overlap and add it to the corresponding receiver face's integrated flux:\n        `integrated_receiver_flux[j-1] += f_i * length`\n    -   **Advance Pointers**: Compare the endpoints of the current intervals to decide which pointer to advance. The pointer corresponding to the interval that finishes first is advanced, as that interval cannot overlap with any subsequent intervals on the other side.\n        -   If $x^D_i < x^R_j$: The donor face $I_i$ is exhausted. Move to the next donor face by incrementing $i$.\n        -   If $x^R_j < x^D_i$: The receiver face $J_j$ is exhausted. Move to the next receiver face by incrementing $j$.\n        -   If $x^D_i = x^R_j$: Both faces end at the same point. Both are exhausted with respect to each other. Increment both $i$ and $j$.\n\n3.  **Termination and Verification**:\n    -   The loop terminates when one of the pointers goes beyond the end of its partition. Since both partitions cover the same total interval $[0, L]$, both pointers will reach the end.\n    -   Calculate the total donor flux: $\\mathcal{F}_{\\text{donor}} = \\sum_{i=1}^{N_D} f_i (x^D_i - x^D_{i-1})$.\n    -   Calculate the total receiver flux: $\\mathcal{F}_{\\text{receiver}} = \\sum_{j=1}^{N_R} \\text{integrated\\_receiver\\_flux}[j-1]$.\n    -   Verify global conservation by checking if $|\\mathcal{F}_{\\text{donor}} - \\mathcal{F}_{\\text{receiver}}| \\le \\tau$, where $\\tau$ is the specified tolerance ($10^{-12}$).\n\nThis algorithm processes each face from both partitions exactly once, moving from left to right along the interface. The total number of pointer increments is at most $N_D + N_R$, leading to the desired linear time complexity.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the mortar transfer test suite.\n    \"\"\"\n    \n    # Define the tolerance for the conservation check.\n    tau = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path nonmatching, mixed flux\n        {\n            \"donor_endpoints\": np.array([0.0, 0.3, 0.7, 1.0]),\n            \"donor_fluxes\": np.array([1.5, -2.0, 3.25]),\n            \"receiver_endpoints\": np.array([0.0, 0.5, 1.0]),\n        },\n        # Case 2: Reverse direction (right-to-left), zero flux\n        {\n            \"donor_endpoints\": np.array([0.0, 0.4, 0.9, 1.0]),  # Right side is donor\n            \"donor_fluxes\": np.array([-1.0, 0.0, 2.0]),\n            \"receiver_endpoints\": np.array([0.0, 0.2, 0.6, 0.65, 0.85, 1.0]), # Left side is receiver\n        },\n        # Case 3: Boundary case with single receiver face\n        {\n            \"donor_endpoints\": np.array([0.0, 0.25, 0.5, 0.75, 1.0]),\n            \"donor_fluxes\": np.array([2.0, 2.0, 2.0, 2.0]),\n            \"receiver_endpoints\": np.array([0.0, 1.0]),\n        },\n        # Case 4: Edge case with a very small donor segment\n        {\n            \"donor_endpoints\": np.array([0.0, 1.0e-6, 0.4, 1.0]),\n            \"donor_fluxes\": np.array([1000.0, -250.0, 500.0]),\n            \"receiver_endpoints\": np.array([0.0, 0.3, 0.7, 1.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        is_conserved = check_conservation(\n            case[\"donor_endpoints\"],\n            case[\"donor_fluxes\"],\n            case[\"receiver_endpoints\"],\n            tau\n        )\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_conservation(donor_endpoints, donor_fluxes, receiver_endpoints, tolerance):\n    \"\"\"\n    Computes flux transfer using a two-pointer sweep algorithm and verifies global conservation.\n\n    Args:\n        donor_endpoints (np.ndarray): Sorted endpoints of the donor partition.\n        donor_fluxes (np.ndarray): Flux densities for each donor face.\n        receiver_endpoints (np.ndarray): Sorted endpoints of the receiver partition.\n        tolerance (float): The tolerance for checking conservation.\n\n    Returns:\n        bool: True if global flux is conserved within the tolerance, False otherwise.\n    \"\"\"\n    \n    # Calculate total integrated flux from the donor side\n    donor_lengths = np.diff(donor_endpoints)\n    total_donor_flux = np.sum(donor_fluxes * donor_lengths)\n\n    # Initialize variables for the two-pointer sweep\n    num_donor_faces = len(donor_fluxes)\n    num_receiver_faces = len(receiver_endpoints) - 1\n    \n    integrated_receiver_flux = np.zeros(num_receiver_faces)\n    \n    donor_idx = 0\n    receiver_idx = 0\n    \n    # Two-pointer sweep algorithm\n    while donor_idx < num_donor_faces and receiver_idx < num_receiver_faces:\n        # Get current donor and receiver interval endpoints\n        donor_start = donor_endpoints[donor_idx]\n        donor_end = donor_endpoints[donor_idx + 1]\n        \n        receiver_start = receiver_endpoints[receiver_idx]\n        receiver_end = receiver_endpoints[receiver_idx + 1]\n        \n        # Calculate overlap interval and length\n        overlap_start = max(donor_start, receiver_start)\n        overlap_end = min(donor_end, receiver_end)\n        overlap_length = max(0.0, overlap_end - overlap_start)\n        \n        # If there is an overlap, add its flux contribution to the receiver face\n        if overlap_length > 0:\n            flux_density = donor_fluxes[donor_idx]\n            integrated_receiver_flux[receiver_idx] += flux_density * overlap_length\n        \n        # Advance the pointer of the interval that ends first\n        if donor_end < receiver_end:\n            donor_idx += 1\n        elif receiver_end < donor_end:\n            receiver_idx += 1\n        else:  # Endpoints coincide\n            donor_idx += 1\n            receiver_idx += 1\n            \n    # Calculate total integrated flux on the receiver side\n    total_receiver_flux = np.sum(integrated_receiver_flux)\n    \n    # Check for conservation within the specified tolerance\n    return abs(total_donor_flux - total_receiver_flux) <= tolerance\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3507765"}]}