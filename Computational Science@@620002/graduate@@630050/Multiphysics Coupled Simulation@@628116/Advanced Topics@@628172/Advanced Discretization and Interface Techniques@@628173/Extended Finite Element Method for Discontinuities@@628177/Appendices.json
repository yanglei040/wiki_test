{"hands_on_practices": [{"introduction": "This first practice is a foundational exercise that takes you to the core of XFEM's mathematical machinery. By manually deriving the enriched contribution to an element matrix for a simple Heaviside enrichment, you will gain a concrete understanding of how the integral over a standard element is modified to account for the discontinuity. This \"pencil-and-paper\" calculation demystifies the integration over sub-domains and is essential for grasping how enrichment functions alter the discrete system of equations [@problem_id:3506679].", "problem": "Consider a single isoparametric bilinear quadrilateral element used in the Extended Finite Element Method (XFEM), where the approximation of a scalar field (e.g., temperature in a thermoelastic multiphysics setting) is enriched to capture a strong discontinuity. The enrichment uses the Heaviside function such that the enrichment function is defined by $\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$, with a level set $\\phi(\\boldsymbol{x})$ representing the discontinuity. In the element’s parent (reference) coordinates, denote $\\boldsymbol{\\xi} = (\\xi,\\eta)$ with $\\xi,\\eta \\in [-1,1]$. Let the discontinuity be represented by the straight line $\\phi(\\boldsymbol{\\xi}) = \\xi$, so that the zero level set $\\phi(\\boldsymbol{\\xi}) = 0$ divides the element into the two subdomains $\\xi  0$ and $\\xi  0$, and $H(\\phi(\\boldsymbol{\\xi}))$ equals $1$ for $\\xi \\ge 0$ and $0$ for $\\xi  0$. The scalar field approximation adopts the partition of unity enrichment\n$$\nu_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi}),\n$$\nwhere $N_{i}(\\boldsymbol{\\xi})$ are the bilinear shape functions associated with the four corner nodes of the quadrilateral.\n\nAssume the element maps the parent domain $[-1,1]\\times[-1,1]$ to a rectangular physical element of width $w$ and height $h$ via the standard bilinear isoparametric mapping, so that the Jacobian determinant is constant and given by $|J| = \\frac{w h}{4}$, and $d\\Omega = |J|\\,d\\xi\\,d\\eta$. Define the enriched nodal contribution matrix $M^{\\mathrm{enr}} \\in \\mathbb{R}^{4\\times 4}$ by\n$$\n(M^{\\mathrm{enr}})_{ij} \\equiv \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega,\n$$\nwith $i,j \\in \\{1,2,3,4\\}$.\n\nStarting from the definitions above and using only the fundamental properties of the Heaviside function and the bilinear shape functions, compute the exact closed-form expression of $M^{\\mathrm{enr}}$ for the given straight discontinuity $\\phi(\\boldsymbol{\\xi}) = \\xi$. Also, from first principles, determine and explicitly list the nodal enriched degrees of freedom $a_{i}$ that receive nonzero enriched support in this element. Express your final matrix $M^{\\mathrm{enr}}$ as an analytic expression in terms of $w$ and $h$. No numerical rounding is required, and the final answer must be a single closed-form analytic expression.", "solution": "The user has provided a well-posed problem in the context of the Extended Finite Element Method (XFEM). I will proceed with the validation and then the solution.\n\n### Step 1: Extract Givens\n- **Methodology**: Extended Finite Element Method (XFEM) for a strong discontinuity in a single isoparametric bilinear quadrilateral element.\n- **Scalar Field Approximation**: $u_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi})$, where $N_i$ are bilinear shape functions, $u_i$ are standard nodal degrees of freedom, and $a_i$ are enriched nodal degrees of freedom.\n- **Enrichment Function**: $\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$, where $H$ is the Heaviside function.\n- **Level Set Function**: In parent coordinates $\\boldsymbol{\\xi} = (\\xi,\\eta) \\in [-1,1]\\times[-1,1]$, the discontinuity is defined by $\\phi(\\boldsymbol{\\xi}) = \\xi$.\n- **Heaviside Function**: $H(\\phi(\\boldsymbol{\\xi})) = 1$ for $\\xi \\ge 0$ and $H(\\phi(\\boldsymbol{\\xi})) = 0$ for $\\xi  0$.\n- **Isoparametric Mapping**: The parent domain $[-1,1]\\times[-1,1]$ maps to a rectangular physical element of width $w$ and height $h$.\n- **Jacobian and Area Element**: The Jacobian determinant is constant, $|J| = \\frac{w h}{4}$, and the differential area is $d\\Omega = |J|\\,d\\xi\\,d\\eta$.\n- **Matrix Definition**: The enriched nodal contribution matrix $M^{\\mathrm{enr}}$ is defined by $(M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega$ for $i,j \\in \\{1,2,3,4\\}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on established principles of the Finite Element Method and its extension, XFEM. The use of a Heaviside function to model strong discontinuities via a partition of unity enrichment is a cornerstone of the method. All definitions are standard. The problem is scientifically sound.\n- **Well-Posed**: All necessary information is provided. The functions are defined, the domain of integration is specified, and the quantity to be computed is explicitly given. The problem is well-posed and admits a unique solution.\n- **Objective**: The problem is stated using precise, unambiguous mathematical and engineering terminology. It is free from subjective or opinion-based claims.\n- **Conclusion**: The problem is free of any of the flaws listed in the validation checklist. It is valid.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. I will proceed with a full, reasoned solution.\n\n### Detailed Solution\n\nThe primary task is to compute the enriched nodal contribution matrix $M^{\\mathrm{enr}}$, whose components are defined as:\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega $$\nThe integration is performed over the entire element domain $\\Omega_e$. By transforming the integral to the parent domain $\\boldsymbol{\\xi} \\in [-1,1]\\times[-1,1]$, we use $d\\Omega = |J|\\,d\\xi\\,d\\eta$. Substituting the given expressions for $\\psi(\\boldsymbol{\\xi})$ and $|J|$ yields:\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,H(\\xi)\\,\\frac{wh}{4}\\,d\\xi\\,d\\eta $$\nThe Heaviside function $H(\\xi)$ is $0$ for $\\xi  0$ and $1$ for $\\xi \\ge 0$. This property restricts the domain of integration for the variable $\\xi$ from $[-1,1]$ to $[0,1]$.\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\int_{0}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,d\\eta\\,d\\xi $$\nThe bilinear shape functions $N_i(\\xi,\\eta)$ for a 4-node quadrilateral element, with nodes numbered counter-clockwise starting from node $1$ at $(\\xi,\\eta)=(-1,-1)$, are:\n$N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\nThe product of two shape functions $N_i N_j$ is:\n$$ N_{i}(\\xi,\\eta) N_{j}(\\xi,\\eta) = \\frac{1}{16} (f_i(\\xi)g_i(\\eta)) (f_j(\\xi)g_j(\\eta)) = \\frac{1}{16} [f_i(\\xi)f_j(\\xi)][g_i(\\eta)g_j(\\eta)] $$\nwhere the functions $f_k(\\xi)$ and $g_k(\\eta)$ are either $(1\\pm\\xi)$ or $(1\\pm\\eta)$. This separability allows us to write the integral for $(M^{\\mathrm{enr}})_{ij}$ as a product of two one-dimensional integrals:\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\frac{1}{16} \\left(\\int_{0}^{1} f_i(\\xi)f_j(\\xi)\\,d\\xi\\right) \\left(\\int_{-1}^{1} g_i(\\eta)g_j(\\eta)\\,d\\eta\\right) $$\nLet's compute the one-dimensional integrals.\nFor the $\\eta$ coordinate, integrating over $[-1,1]$:\n$$ \\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta = \\left[-\\frac{(1-\\eta)^3}{3}\\right]_{-1}^{1} = 0 - \\left(-\\frac{2^3}{3}\\right) = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1+\\eta)^2 \\, d\\eta = \\left[\\frac{(1+\\eta)^3}{3}\\right]_{-1}^{1} = \\frac{2^3}{3} - 0 = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1-\\eta)(1+\\eta) \\, d\\eta = \\int_{-1}^{1} (1-\\eta^2) \\, d\\eta = \\left[\\eta - \\frac{\\eta^3}{3}\\right]_{-1}^{1} = \\left(1-\\frac{1}{3}\\right) - \\left(-1+\\frac{1}{3}\\right) = \\frac{4}{3} $$\n\nFor the $\\xi$ coordinate, integrating over $[0,1]$:\n$$ \\int_{0}^{1} (1-\\xi)^2 \\, d\\xi = \\left[-\\frac{(1-\\xi)^3}{3}\\right]_{0}^{1} = 0 - \\left(-\\frac{1^3}{3}\\right) = \\frac{1}{3} $$\n$$ \\int_{0}^{1} (1+\\xi)^2 \\, d\\xi = \\left[\\frac{(1+\\xi)^3}{3}\\right]_{0}^{1} = \\frac{2^3}{3} - \\frac{1^3}{3} = \\frac{7}{3} $$\n$$ \\int_{0}^{1} (1-\\xi)(1+\\xi) \\, d\\xi = \\int_{0}^{1} (1-\\xi^2) \\, d\\xi = \\left[\\xi - \\frac{\\xi^3}{3}\\right]_{0}^{1} = 1 - \\frac{1}{3} = \\frac{2}{3} $$\n\nWe can now compute each element of the matrix $(M^{\\mathrm{enr}})_{ij}$. For example, for the $(1,1)$ component:\n$f_1(\\xi) = 1-\\xi$, $g_1(\\eta) = 1-\\eta$.\n$$ (M^{\\mathrm{enr}})_{11} = \\frac{wh}{64} \\left(\\int_{0}^{1} (1-\\xi)^2 \\, d\\xi\\right) \\left(\\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta\\right) = \\frac{wh}{64} \\left(\\frac{1}{3}\\right) \\left(\\frac{8}{3}\\right) = \\frac{8wh}{576} = \\frac{wh}{72} $$\nLet's express all entries as a multiple of a common factor. Let $\\mathbf{m}$ be the matrix of the integrals such that $M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m}$.\n$$ m_{ij} = \\left(\\int f_i f_j\\right)\\left(\\int g_i g_j\\right) $$\n$m_{11} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\n$m_{12} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{13} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{14} = (\\frac{1}{3})(\\frac{4}{3}) = \\frac{4}{9}$\n$m_{22} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{23} = (\\frac{7}{3})(\\frac{4}{3}) = \\frac{28}{9}$\n$m_{24} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{33} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{34} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{44} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\nThe matrix $\\mathbf{m}$ is symmetric, so $m_{ji}=m_{ij}$. Assembling the matrix:\n$$ \\mathbf{m} = \\frac{1}{9} \\begin{pmatrix}\n8  16  8  4 \\\\\n16  56  28  8 \\\\\n8  28  56  16 \\\\\n4  8  16  8\n\\end{pmatrix} = \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\nFinally, we compute $M^{\\mathrm{enr}}$:\n$$ M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m} = \\frac{wh}{64} \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} = \\frac{wh}{144} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\n\nRegarding the second part of the question, we must identify which nodal enriched degrees of freedom $a_i$ receive nonzero support. In the standard XFEM approach for strong discontinuities, enrichment is applied to all nodes of any element that is cut by the discontinuity. In this problem, the single element under consideration is cut by the discontinuity line $\\phi(\\boldsymbol{\\xi}) = \\xi = 0$. Therefore, all four nodes of the element are enriched. The enriched degrees of freedom $a_1$, $a_2$, $a_3$, and $a_4$ are all active and receive nonzero support.", "answer": "$$ \\boxed{ \\frac{wh}{144} \\begin{pmatrix} 2  4  2  1 \\\\ 4  14  7  2 \\\\ 2  7  14  4 \\\\ 1  2  4  2 \\end{pmatrix} } $$", "id": "3506679"}, {"introduction": "A key advantage of XFEM is its ability to model discontinuities that evolve over time without remeshing. This exercise moves from the static formulation to the dynamic tracking of an interface, a crucial component in simulations of crack propagation or phase change. You will implement a semi-Lagrangian scheme to solve the advection equation for a level-set function, providing a hands-on experience in how the geometric representation of the discontinuity is updated and how this update drives the selection of enriched elements [@problem_id:3506750].", "problem": "Consider the Extended Finite Element Method (XFEM), which augments the standard finite element approximation space to represent discontinuities without aligning the mesh to interfaces. An important step in multiphysics coupled simulation is robust advection of an implicitly represented interface and consistent update of the enrichment pattern for the partially cut elements. Let the interface be represented by a level set function $ \\phi(x,y,t) $, where the zero isocontour $ \\phi(x,y,t)=0 $ defines the moving interface. The scalar advection equation governing the transport of $ \\phi $ by a prescribed velocity field $ v(x,y) $ is $$ \\partial_t \\phi + v \\cdot \\nabla \\phi = 0. $$ The domain is the unit square $ \\Omega = [0,1] \\times [0,1] $ in dimensionless units. The initial level-set function is the signed distance to a circle of radius $ r = 0.25 $ centered at $ (x_0,y_0)=(0.5,0.5) $, that is $$ \\phi(x,y,0) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - 0.25. $$ Use a structured, uniform quadrilateral finite element mesh with $ N_x $ nodes in the $ x $-direction and $ N_y $ nodes in the $ y $-direction, both including boundary nodes. Let $ \\Delta t $ denote the time step. The enrichment pattern at a given time is defined by marking each element whose four corner nodal values of $ \\phi $ have mixed signs or include zeros as enriched, corresponding to the Heaviside-type discontinuity crossing the element interior.\n\nYour task is to:\n- Starting from the advection equation and the method of characteristics as fundamental principles, implement a physically consistent single-step time advancement for $ \\phi $ from $ t^n $ to $ t^{n+1}=t^n+\\Delta t $ on the mesh nodes, under a prescribed steady velocity field $ v(x,y) $, assuming dimensionless units. Angles, when present (e.g., angular velocity), must be interpreted in radians per unit time.\n- After advancing $ \\phi $, update the enrichment pattern by marking elements cut by the updated interface, defined as those elements for which the set of four corner nodal values of $ \\phi $ at $ t^{n+1} $ contains both positive and negative values or any value equal to zero (to numerical tolerance).\n- Output, for each test case in the test suite, the integer count of enriched elements at the updated time $ t^{n+1} $.\n\nYou must produce a program that uses the following test suite of cases, each specifying $ N_x $, $ N_y $, $ \\Delta t $, and a velocity field $ v(x,y) $:\n\n- Case A (general translation): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (0.3, 0.0) $.\n- Case B (solid-body rotation about the domain center): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = \\left( -\\omega (y-0.5), \\, \\omega (x-0.5) \\right) $ with $ \\omega = 1.0 $ radians per unit time.\n- Case C (simple shear): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (y, 0.0) $.\n- Case D (no motion, edge case): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (0.0, 0.0) $.\n\nNumerically, treat the backtraced foot of characteristics that leave $ \\Omega $ by clamping to the nearest boundary point in $ \\Omega $, so that the numerical interpolation for $ \\phi $ remains well-defined everywhere. Use a small numerical tolerance $ \\varepsilon $ to decide sign and zero values for enrichment detection, and justify the selection in your solution.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite cases, for example $ [\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D] $. Each $ \\text{result}_\\cdot $ must be an integer equal to the number of enriched elements after the single time update for that case.", "solution": "The user-provided problem is assessed as **valid**. It is scientifically sound, well-posed, and all necessary information for a unique numerical solution is provided. The problem asks for the implementation of a standard numerical method for a partial differential equation within a relevant engineering context.\n\nThe solution proceeds as follows: First, the physical and mathematical principles are established. Second, the numerical algorithm is designed based on these principles. Finally, this algorithm is applied to the specified test cases.\n\n### Governing Principles and Method of Characteristics\n\nThe problem requires solving the scalar advection equation for a level set function $ \\phi(x,y,t) $:\n$$ \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\nwhere $ \\vec{v}(x,y) $ is a prescribed, steady velocity field. This equation describes the transport of the scalar quantity $ \\phi $ with the flow defined by $ \\vec{v} $.\n\nThe Method of Characteristics is a technique for solving such first-order hyperbolic partial differential equations. The equation can be interpreted as stating that the total derivative of $ \\phi $ is zero along specific curves in spacetime called characteristics. These characteristic curves, $ \\vec{x}(t) $, are defined by the ordinary differential equation:\n$$ \\frac{d\\vec{x}}{dt} = \\vec{v}(\\vec{x}(t)) $$\nAlong these curves, the rate of change of $ \\phi $ is given by:\n$$ \\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + \\frac{d\\vec{x}}{dt} \\cdot \\nabla\\phi = \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\nThis implies that $ \\phi $ is constant along a characteristic curve. Therefore, to find the value of $ \\phi $ at a grid point $ \\vec{x}_p $ at the new time $ t^{n+1} $, we can trace its characteristic curve backward in time to find its position at the previous time $ t^n $. This starting position is called the departure point, $ \\vec{x}_d $. The principle gives:\n$$ \\phi(\\vec{x}_p, t^{n+1}) = \\phi(\\vec{x}_d, t^n) $$\n\n### Numerical Implementation: Semi-Lagrangian Scheme\n\nA numerical scheme based on this principle is known as a semi-Lagrangian method. We are given the values of $ \\phi^n $ at all nodes of a uniform grid at time $ t^n $. To find the values $ \\phi^{n+1} $ at these same grid nodes at time $ t^{n+1} = t^n + \\Delta t $, we perform the following steps for each grid node $ \\vec{x}_p $:\n\n1.  **Back-tracing**: Approximate the departure point $ \\vec{x}_d $. The characteristic ODE $ d\\vec{x}/dt = \\vec{v} $ is solved backward in time over one time step $ \\Delta t $. A first-order explicit Euler (backward) integration is the simplest approach:\n    $$ \\vec{x}_d \\approx \\vec{x}_p - \\vec{v}(\\vec{x}_p) \\Delta t $$\n    This first-order scheme is a direct and standard implementation for a \"single-step time advancement\" as requested. While higher-order methods (e.g., Runge-Kutta) exist for greater accuracy, the first-order method is sufficient and consistent with the problem statement.\n\n2.  **Boundary Handling**: The departure point $ \\vec{x}_d $ may lie outside the computational domain $ \\Omega = [0,1] \\times [0,1] $. As specified, we clamp its coordinates to the domain boundaries:\n    $$ \\vec{x}_{d, \\text{clamped}} = \\text{clip}(\\vec{x}_d, [0,1]) $$\n    This ensures that the interpolation step remains well-defined.\n\n3.  **Interpolation**: The departure point $ \\vec{x}_{d, \\text{clamped}} $ will generally not coincide with a grid node from time $ t^n $. Therefore, the value $ \\phi(\\vec{x}_{d, \\text{clamped}}, t^n) $ must be interpolated from the known nodal values of $ \\phi^n $. For the specified structured quadrilateral mesh, bilinear interpolation is the natural and appropriate choice. Given a point within a grid cell, its value is interpolated from the four corner nodal values. This entire procedure (back-tracing, clamping, and interpolation) is applied to all grid nodes to compute the full field $ \\phi^{n+1} $.\n\n### Enrichment Pattern Update\n\nAfter computing the updated level set field $ \\phi^{n+1} $, the set of enriched elements is determined. An element (a quadrilateral cell in the mesh) is defined by four corner nodes. According to the problem statement, an element is marked as \"enriched\" if it is cut by the interface (the zero-isocontour of $ \\phi $). The criterion for this is: \"the set of four corner nodal values of $ \\phi $ at $ t^{n+1} $ contains both positive and negative values or any value equal to zero (to numerical tolerance)\".\n\nTo implement this robustly, we introduce a small numerical tolerance $ \\varepsilon $. A suitable value is $ \\varepsilon = 10^{-9} $, which is small enough to be negligible compared to the physical scale of $ \\phi $ but large enough to handle floating-point inaccuracies near zero. For each element, let $ \\Phi_{\\text{corners}} $ be the set of the four corner nodal values of $ \\phi^{n+1} $. The element is considered enriched if:\n$$ (\\max(\\Phi_{\\text{corners}})  \\varepsilon \\text{ and } \\min(\\Phi_{\\text{corners}})  -\\varepsilon) \\quad \\lor \\quad (\\min(|\\phi_i|) \\le \\varepsilon \\text{ for any } \\phi_i \\in \\Phi_{\\text{corners}}) $$\nThis logic correctly identifies elements with a sign change across their corners, as well as elements where the interface passes very close to or through a node. The total count of such enriched elements is the required output for each test case.\n\nThe entire process is vectorized for efficiency. The departure points and velocities for all grid nodes are calculated in array operations. The interpolation for all departure points is performed in a single call using SciPy's `RegularGridInterpolator`, which is configured to use linear interpolation.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the number of enriched elements after one time step of advecting a level set function.\n    The advection is performed using a first-order semi-Lagrangian method on a uniform grid.\n    \"\"\"\n    \n    # Define the test suite of cases.\n    test_cases = [\n        {\n            'name': 'A (translation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.3 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'B (rotation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (-1.0 * (y - 0.5), 1.0 * (x - 0.5))\n        },\n        {\n            'name': 'C (shear)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (y, 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'D (no motion)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.0 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n    ]\n\n    results = []\n    # Numerical tolerance for checking for zero values.\n    eps = 1e-9\n\n    for case in test_cases:\n        Nx, Ny, dt = case['Nx'], case['Ny'], case['dt']\n        v_field = case['v_field']\n\n        # 1. Create mesh grid and define the initial level set function.\n        # The domain is the unit square [0,1] x [0,1].\n        x_coords = np.linspace(0.0, 1.0, Nx)\n        y_coords = np.linspace(0.0, 1.0, Ny)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # Initial level set: signed distance to a circle r=0.25 at (0.5, 0.5).\n        phi_initial = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2) - 0.25\n\n        # 2. Advance the level set field one time step.\n        # This is a semi-Lagrangian advection step.\n\n        # Create an interpolator for the initial field phi_initial.\n        # This will be used to find phi at the departure points.\n        # We use linear interpolation, which is bilinear for a 2D grid.\n        interpolator = RegularGridInterpolator(\n            (x_coords, y_coords), phi_initial, \n            method='linear', bounds_error=False, fill_value=None\n        )\n\n        # Calculate the velocity field at all grid points (X, Y).\n        Vx, Vy = v_field(X, Y)\n\n        # Calculate the departure points using first-order Euler back-tracing.\n        Xd = X - Vx * dt\n        Yd = Y - Vy * dt\n\n        # Clamp the departure points to the domain boundaries as per the problem.\n        Xd_clamped = np.clip(Xd, 0.0, 1.0)\n        Yd_clamped = np.clip(Yd, 0.0, 1.0)\n        \n        # Prepare points for the interpolator: a (N, 2) array.\n        departure_points = np.stack([Xd_clamped.ravel(), Yd_clamped.ravel()], axis=-1)\n\n        # Interpolate phi at departure points to find the field at the next time step.\n        phi_next_flat = interpolator(departure_points)\n        phi_next = phi_next_flat.reshape((Nx, Ny))\n\n        # 3. Count the number of enriched elements based on the updated field.\n        enriched_count = 0\n        # Iterate over all elements. An element is defined by its bottom-left node (i, j).\n        for i in range(Nx - 1):\n            for j in range(Ny - 1):\n                # Collect the four corner nodal values of phi_next for the element.\n                corner_values = np.array([\n                    phi_next[i, j],\n                    phi_next[i + 1, j],\n                    phi_next[i, j + 1],\n                    phi_next[i + 1, j + 1]\n                ])\n\n                # Check enrichment criterion: mixed signs or includes a zero (with tolerance).\n                has_pos = np.any(corner_values > eps)\n                has_neg = np.any(corner_values  -eps)\n                has_zero = np.any(np.abs(corner_values) = eps)\n\n                if (has_pos and has_neg) or has_zero:\n                    enriched_count += 1\n        \n        results.append(enriched_count)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3506750"}, {"introduction": "Building upon the concepts of enrichment and interface representation, this final practice delves into a more advanced and realistic application: solving a nonlinear cohesive crack problem. You will implement a Newton-Raphson solver to handle the nonlinear traction-separation law at the crack interface, a common feature in multiphysics fracture models. This exercise demonstrates how XFEM provides a robust framework for tackling complex, nonlinear phenomena, highlighting its power as a practical engineering tool [@problem_id:3506770].", "problem": "Consider a small-strain, quasi-static interface model of a single straight crack embedded in a one-dimensional elastic bar using the Extended Finite Element Method (XFEM). The crack is represented by a two-node enriched interface, and the crack opening field is interpolated at a single integration point using linear shape functions. The physical coupling considered is multiphysics: a fluid pressure acts on the crack faces to open the crack, and a thermal load contributes to the effective opening force. The cohesive traction across the crack follows a nonlinear traction-separation law that is piecewise defined for opening and compression. All quantities in this problem are nondimensionalized; no physical units are required.\n\nStarting from the balance of linear momentum in the absence of inertia and body forces, the traction equilibrium across the crack faces implies that the internal cohesive traction must balance the structural resistance and external crack-face loads. Let the enriched degrees of freedom be the vector $w = [w_1, w_2]^T$, representing the displacement jump parameters at the two enriched nodes. The crack opening at the integration point is interpolated as\n$$\nw_g = N_1 w_1 + N_2 w_2,\n$$\nwith linear shape functions $N_1 = N_2 = \\frac{1}{2}$. Define the enriched stiffness matrix\n$$\nK = k_e \\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix},\n$$\nwhere $k_e  0$ is the enriched structural stiffness and $0 \\le \\rho  1$ quantifies coupling between the enriched degrees of freedom. The fluid pressure load $p \\ge 0$ acts uniformly on the crack faces and contributes to the residual via shape-function weighting. A thermal load parameter $\\theta \\ge 0$ contributes as an effective opening force proportional to the shape functions.\n\nThe cohesive traction-separation law is defined as\n$$\nT(w_g) = \\begin{cases}\n\\sigma_0 \\left(1 - e^{-\\beta w_g}\\right),  \\text{if } w_g \\ge 0 \\quad \\text{(opening)}, \\\\\nk_c\\, w_g,  \\text{if } w_g  0 \\quad \\text{(compression/contact)},\n\\end{cases}\n$$\nwhere $\\sigma_0  0$ is the cohesive strength scale, $\\beta  0$ characterizes nonlinearity of the softening law, and $k_c  0$ is the contact penalty stiffness for compression. The derivative of the traction with respect to the crack opening is\n$$\n\\frac{dT}{dw_g} = \\begin{cases}\n\\sigma_0 \\beta\\, e^{-\\beta w_g},  \\text{if } w_g \\ge 0, \\\\\nk_c,  \\text{if } w_g  0.\n\\end{cases}\n$$\n\nUsing the Heaviside enrichment in XFEM and applying the weighted residual statement at the interface integration point, the discrete nonlinear residual for the two enriched degrees of freedom is\n$$\nR_i(w) = \\sum_{j=1}^{2} K_{ij} w_j + N_i\\, T(w_g) - N_i\\, p - N_i\\, \\theta, \\quad i=1,2,\n$$\nwith $N_1 = N_2 = \\frac{1}{2}$ and $w_g = \\frac{1}{2}(w_1 + w_2)$.\n\nThe consistent tangent (Jacobian) matrix required by Newton's method is derived from the residual. Using the chain rule,\n$$\nJ_{ij}(w) = \\frac{\\partial R_i}{\\partial w_j} = K_{ij} + N_i \\frac{dT}{dw_g} N_j, \\quad i,j=1,2,\n$$\nwhich can be compactly written as\n$$\nJ(w) = K + \\frac{dT}{dw_g} \\, (N \\otimes N),\n$$\nwhere $N = \\begin{bmatrix}\\frac{1}{2}  \\frac{1}{2}\\end{bmatrix}^T$ and $\\otimes$ denotes the outer product.\n\nTask: Implement a Newton–Raphson solver for the nonlinear system $R(w) = 0$ using the above residual and tangent, with an optional backtracking line search that reduces the step length to ensure decrease of the residual norm. The Newton update is\n$$\nJ(w^{(k)}) \\, \\Delta w^{(k)} = - R(w^{(k)}), \\quad w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)},\n$$\nwhere $0  \\lambda^{(k)} \\le 1$ is determined by the line search if enabled, otherwise $\\lambda^{(k)} = 1$. Use the Euclidean norm of the residual vector to assess convergence. Use the stopping criterion $\\|R(w^{(k)})\\| \\le \\varepsilon$ with a specified tolerance $\\varepsilon  0$ or a maximum number of iterations.\n\nYour program must, for each test case, return a list containing three values:\n- The integer number of Newton iterations performed until termination (either convergence or reaching the maximum).\n- The final residual norm as a float.\n- The total integer count of line search step reductions applied across all iterations (zero if line search is disabled).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is represented as its own bracketed comma-separated list. For example, the output format for two test cases would be \"[[n1,r1,ls1],[n2,r2,ls2]]\".\n\nImplement the solver for the following test suite, which explores a range of behaviors, including a typical convergent case, high loading, initial compressive states, and the effect of disabling the line search. All quantities are nondimensional.\n\nTest case 1 (happy path):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$.\n- Initial guess $w^{(0)} = [0.0, 0.0]^T$.\n- Line search enabled.\n- Tolerance $\\varepsilon = 10^{-10}$, maximum iterations $50$.\n\nTest case 2 (high fluid pressure):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 8.0$, $\\theta = 0.0$.\n- Initial guess $w^{(0)} = [0.1, 0.1]^T$.\n- Line search enabled.\n- Tolerance $\\varepsilon = 10^{-10}$, maximum iterations $50$.\n\nTest case 3 (initial compression regime):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 30.0$, $p = 0.5$, $\\theta = 0.2$.\n- Initial guess $w^{(0)} = [-0.3, -0.1]^T$.\n- Line search enabled.\n- Tolerance $\\varepsilon = 10^{-10}$, maximum iterations $50$.\n\nTest case 4 (no line search comparison):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$.\n- Initial guess $w^{(0)} = [0.0, 0.0]^T$.\n- Line search disabled.\n- Tolerance $\\varepsilon = 10^{-10}$, maximum iterations $50$.\n\nYour program should produce a single line of output containing the list of results for the four test cases in the exact format \"[[n1,r1,ls1],[n2,r2,ls2],[n3,r3,ls3],[n4,r4,ls4]]\", where $n_i$ are integers and $r_i$ are floats. Angles do not appear in this problem; therefore, no angle unit specification is required. All quantities are nondimensional, so no physical unit specification is required. The program must be self-contained and not require any user input.", "solution": "The problem is valid as it presents a well-posed, scientifically grounded scenario in computational mechanics that is self-contained and free of contradictions or ambiguities. The task is to implement a standard numerical method, the Newton-Raphson algorithm, to solve a system of nonlinear equations derived from an Extended Finite Element Method (XFEM) model of a crack. All necessary equations, parameters, and boundary conditions are provided.\n\nThe core of the problem is to find the vector of enriched degrees of freedom $w = [w_1, w_2]^T$ that satisfies the nonlinear system of equations $R(w) = 0$, where $R$ is the residual vector. The Newton-Raphson method is an iterative procedure for finding successively better approximations to the roots of a real-valued function. The update rule for this problem is derived as follows.\n\nGiven an approximation $w^{(k)}$ at iteration $k$, we seek a correction $\\Delta w^{(k)}$ such that $w^{(k+1)} = w^{(k)} + \\Delta w^{(k)}$ is a better approximation. We linearize the residual function $R(w)$ around $w^{(k)}$ using a first-order Taylor expansion:\n$$\nR(w^{(k+1)}) \\approx R(w^{(k)}) + J(w^{(k)}) (w^{(k+1)} - w^{(k)}) = R(w^{(k)}) + J(w^{(k)}) \\Delta w^{(k)}\n$$\nwhere $J(w^{(k)})$ is the Jacobian matrix of $R$ evaluated at $w^{(k)}$. Setting $R(w^{(k+1)}) = 0$, we obtain the linear system for the update step:\n$$\nJ(w^{(k)}) \\Delta w^{(k)} = - R(w^{(k)})\n$$\nOnce $\\Delta w^{(k)}$ is computed, the new approximation is $w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)}$, where $\\lambda^{(k)} \\in (0, 1]$ is a step length parameter determined by a line search algorithm to ensure robust convergence. If no line search is used, $\\lambda^{(k)} = 1$. The process is repeated until the Euclidean norm of the residual, $\\|R(w^{(k)})\\|$, falls below a specified tolerance $\\varepsilon$, or a maximum number of iterations is reached.\n\nThe specific components of the algorithm for this problem are:\n\n1.  **System Variables and Parameters**:\n    The system is described by the enriched DOF vector $w = [w_1, w_2]^T$. The crack opening at the single integration point is given by $w_g = \\frac{1}{2}(w_1 + w_2)$. The model parameters are the enriched structural stiffness $k_e$, the coupling term $\\rho$, the cohesive law parameters $\\sigma_0$, $\\beta$, and $k_c$, and the external load parameters $p$ and $\\theta$.\n\n2.  **Residual Vector $R(w)$**:\n    The residual vector is a $2 \\times 1$ vector defined as:\n    $$\n    R(w) = K w + N T(w_g) - N(p + \\theta)\n    $$\n    where $K = k_e \\begin{bmatrix}1  \\rho \\\\ \\rho  1\\end{bmatrix}$ is the enriched stiffness matrix, $N = [\\frac{1}{2}, \\frac{1}{2}]^T$ is the shape function vector, and $T(w_g)$ is the piecewise cohesive traction:\n    $$\n    T(w_g) = \\begin{cases}\n    \\sigma_0 (1 - e^{-\\beta w_g}),  w_g \\ge 0 \\\\\n    k_c w_g,  w_g  0\n    \\end{cases}\n    $$\n    At each iteration, $w_g$ is computed from the current $w^{(k)}$, which determines which branch of the traction law to use for calculating $T(w_g)$.\n\n3.  **Jacobian Matrix $J(w)$**:\n    The Jacobian (or consistent tangent) is a $2 \\times 2$ matrix given by:\n    $$\n    J(w) = K + \\frac{dT}{dw_g} (N \\otimes N)\n    $$\n    where $N \\otimes N$ is the outer product $N N^T$, and the derivative of the traction is:\n    $$\n    \\frac{dT}{dw_g} = \\begin{cases}\n    \\sigma_0 \\beta e^{-\\beta w_g},  w_g \\ge 0 \\\\\n    k_c,  w_g  0\n    \\end{cases}\n    $$\n    The term $\\frac{dT}{dw_g}$ is also evaluated using the current $w_g$. The resulting Jacobian matrix is:\n    $$\n    J(w) = \\begin{bmatrix} k_e + \\frac{1}{4}\\frac{dT}{dw_g}  k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g} \\\\ k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g}  k_e + \\frac{1}{4}\\frac{dT}{dw_g} \\end{bmatrix}\n    $$\n\n4.  **Backtracking Line Search**:\n    If enabled, a backtracking line search is employed to find an appropriate step length $\\lambda^{(k)}$. Starting with $\\lambda^{(k)}=1$, the algorithm checks if the proposed update reduces the residual norm, i.e., if $\\|R(w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)})\\|  \\|R(w^{(k)})\\|$. If this condition is not met, $\\lambda^{(k)}$ is successively reduced (e.g., halved) until the condition is satisfied or a maximum number of reductions is performed. The number of such reductions is tracked.\n\n**Iterative Procedure:**\nThe implemented algorithm follows these steps for each test case:\n\n1.  Initialize iteration counter $k=0$, total line search reductions $ls\\_count = 0$, and the initial guess $w^{(0)}$. The stiffness matrix $K$ and shape function vector $N$ are constructed.\n2.  Begin the main loop, for $k$ from $0$ to `max_iterations-1`:\n    a. Calculate $w_g = N^T w^{(k)}$.\n    b. Evaluate $T(w_g)$ and the total external force $(p+\\theta)$.\n    c. Compute the residual vector $R(w^{(k)}) = K w^{(k)} + N(T(w_g) - p - \\theta)$.\n    d. Calculate the Euclidean norm $\\|R(w^{(k)})\\|$. If $\\|R(w^{(k)})\\| \\le \\varepsilon$, convergence is achieved. The loop is terminated.\n    e. Evaluate $\\frac{dT}{dw_g}$ based on $w_g$.\n    f. Assemble the Jacobian matrix $J(w^{(k)}) = K + \\frac{dT}{dw_g} (N N^T)$.\n    g. Solve the linear system $J(w^{(k)}) \\Delta w^{(k)} = -R(w^{(k)})$ for $\\Delta w^{(k)}$.\n    h. If line search is enabled:\n        i. Initialize $\\lambda = 1$ and a counter for reductions in this step.\n        ii. Enter a loop: compute the trial solution $w_{trial} = w^{(k)} + \\lambda \\Delta w^{(k)}$ and the corresponding residual $R_{trial}$. If $\\|R_{trial}\\|  \\|R(w^{(k)})\\|$, break the loop. Otherwise, set $\\lambda \\leftarrow \\lambda/2$, increment the reduction counter, and repeat.\n        iii. Add the number of reductions to $ls\\_count$.\n    i. If line search is disabled, set $\\lambda = 1$.\n    j. Update the solution: $w^{(k+1)} = w^{(k)} + \\lambda \\Delta w^{(k)}$.\n3.  After the loop terminates (either by convergence or reaching `max_iterations`), the final number of iterations, the final residual norm, and the total line search reduction count are returned.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_raphson_solver(params, initial_w, settings):\n    \"\"\"\n    Solves the nonlinear system R(w) = 0 using the Newton-Raphson method.\n\n    Args:\n        params (tuple): Physical parameters (k_e, rho, sigma_0, beta, k_c, p, theta).\n        initial_w (np.ndarray): Initial guess for w = [w1, w2].\n        settings (tuple): Solver settings (tolerance, max_iterations, line_search_enabled).\n\n    Returns:\n        tuple: (iteration_count, final_residual_norm, total_line_search_reductions).\n    \"\"\"\n    k_e, rho, sigma_0, beta, k_c, p, theta = params\n    tolerance, max_iterations, line_search_enabled = settings\n\n    w = np.array(initial_w, dtype=float)\n    \n    K = k_e * np.array([[1.0, rho], [rho, 1.0]])\n    N = np.array([0.5, 0.5])\n    \n    total_ls_reductions = 0\n    residual_norm = float('inf')\n    \n    for i in range(max_iterations):\n        # 1. Calculate crack opening\n        w_g = np.dot(N, w)\n        \n        # 2. Evaluate traction T and its derivative dT/dw_g\n        if w_g >= 0:\n            exp_term = np.exp(-beta * w_g)\n            T_wg = sigma_0 * (1.0 - exp_term)\n            dT_dwg = sigma_0 * beta * exp_term\n        else:\n            T_wg = k_c * w_g\n            dT_dwg = k_c\n            \n        # 3. Compute residual vector R\n        F_ext = p + theta\n        R = K @ w + N * (T_wg - F_ext)\n        residual_norm = np.linalg.norm(R)\n        \n        # 4. Check for convergence\n        if residual_norm = tolerance:\n            return i, residual_norm, total_ls_reductions\n            \n        # 5. Assemble Jacobian matrix J\n        N_outer_N = np.outer(N, N)\n        J = K + dT_dwg * N_outer_N\n        \n        # 6. Solve for the update step delta_w\n        try:\n            delta_w = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, cannot proceed\n            return i + 1, residual_norm, total_ls_reductions\n\n        # 7. Apply backtracking line search (if enabled)\n        step_lambda = 1.0\n        if line_search_enabled:\n            current_residual_norm = residual_norm\n            num_reductions = 0\n            max_ls_steps = 10 # Avoid infinite loops\n            \n            for ls_step in range(max_ls_steps):\n                w_trial = w + step_lambda * delta_w\n                w_g_trial = np.dot(N, w_trial)\n                \n                if w_g_trial >= 0:\n                    exp_term_trial = np.exp(-beta * w_g_trial)\n                    T_wg_trial = sigma_0 * (1.0 - exp_term_trial)\n                else:\n                    T_wg_trial = k_c * w_g_trial\n                \n                R_trial = K @ w_trial + N * (T_wg_trial - F_ext)\n                trial_residual_norm = np.linalg.norm(R_trial)\n                \n                if trial_residual_norm  current_residual_norm:\n                    break\n                else:\n                    step_lambda /= 2.0\n                    num_reductions += 1\n            total_ls_reductions += num_reductions\n        \n        # 8. Update solution vector w\n        w += step_lambda * delta_w\n        \n    # If loop finishes, max iterations was reached\n    # Re-calculate final residual norm for the last state\n    w_g = np.dot(N, w)\n    if w_g >= 0:\n        exp_term = np.exp(-beta * w_g)\n        T_wg = sigma_0 * (1.0 - exp_term)\n    else:\n        T_wg = k_c * w_g\n    F_ext = p + theta\n    R = K @ w + N * (T_wg - F_ext)\n    final_residual_norm = np.linalg.norm(R)\n\n    return max_iterations, final_residual_norm, total_ls_reductions\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 8.0, 0.0),\n            \"initial_w\": [0.1, 0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 30.0, 0.5, 0.2),\n            \"initial_w\": [-0.3, -0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, False)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n_iters, final_resid, ls_count = newton_raphson_solver(\n            case[\"params\"],\n            case[\"initial_w\"],\n            case[\"settings\"]\n        )\n        results.append([n_iters, final_resid, ls_count])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3506770"}]}