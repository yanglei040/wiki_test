{"hands_on_practices": [{"introduction": "Operator splitting provides a powerful framework for coupling different physical models, but naive implementations can introduce numerical instabilities. This first exercise explores a common pitfall—spurious oscillations at coupled interfaces—using a minimal model of thermal interaction [@problem_id:3519194]. By deriving and analyzing the one-step amplification factor for the interfacial temperature jump, you will develop a practical strategy based on flux blending to optimize stability and ensure physically meaningful results.", "problem": "Consider a minimal, dimensionless model of a thermally coupled interface between two subsystems, denoted by A and B, that arises from a semi-discrete finite-volume treatment of the heat equation where each subsystem contributes a single interfacial control volume. Let $u_A(t)$ and $u_B(t)$ denote the interfacial temperatures on each side. The fundamental energy balance for these control volumes is\n$$\nC_A \\frac{d u_A}{d t} \\;=\\; -F(t), \\qquad C_B \\frac{d u_B}{d t} \\;=\\; F(t),\n$$\nwhere $C_A>0$ and $C_B>0$ are the heat capacities (or lumped thermal masses) of the interfacial control volumes, and $F(t)$ is the interfacial heat flux oriented from subsystem A to subsystem B. At the continuous level, the exact conductance is not required for this problem; instead, suppose that, at a given discrete time level $t^n$, two independent solvers propose interfacial flux predictions consistent with Fourier’s law using their own interfacial conductance models:\n$$\nF_A^n \\;=\\; k_A \\,\\big(u_A^n - u_B^n\\big), \\qquad F_B^n \\;=\\; k_B \\,\\big(u_A^n - u_B^n\\big),\n$$\nwith $k_A>0$ and $k_B>0$. In an operator-splitting (fractional step) context, a common practice is to compute a single conservative flux by blending the two predictions as\n$$\nF^{n} \\;=\\; F^\\star \\;=\\; \\theta \\,F_A^n + \\big(1-\\theta\\big)\\,F_B^n \\;=\\; k_\\theta \\,\\big(u_A^n - u_B^n\\big), \\quad \\text{with} \\quad k_\\theta \\;=\\; \\theta k_A + (1-\\theta) k_B,\n$$\nwhere $\\theta \\in [0,1]$ is a blending parameter. Then, using an explicit first-order fractional step over a time step $\\Delta t>0$, the update reads\n$$\nu_A^{n+1} \\;=\\; u_A^n \\;-\\; \\frac{\\Delta t}{C_A}\\,F^{n}, \\qquad\nu_B^{n+1} \\;=\\; u_B^n \\;+\\; \\frac{\\Delta t}{C_B}\\,F^{n}.\n$$\nDefine the interfacial jump as $d^n \\;=\\; u_A^n - u_B^n$. Starting from the fundamental energy balances above and the stated explicit update, do the following:\n\n1) Derive the closed-form linear recurrence for $d^{n+1}$ in terms of $d^n$, $\\Delta t$, $C_A$, $C_B$, and $k_\\theta$. Use this to precisely define what constitutes a spurious oscillation in this setting after one time step, and state the condition under which such oscillations occur.\n\n2) Consider the family of blended fluxes parameterized by $\\theta \\in [0,1]$. For a fixed set of positive parameters $\\Delta t$, $C_A$, $C_B$, $k_A$, and $k_B$, determine the value $\\theta(\\Delta t)$ that minimizes the one-step amplification magnitude of the interfacial jump. Your derivation must:\n- Identify the effective target conductance that would eliminate the jump in one step if it were attainable.\n- Convert the optimal effective conductance into an admissible $\\theta$ by respecting the convexity constraint $k_\\theta \\in [\\min(k_A,k_B),\\max(k_A,k_B)]$ that follows from $\\theta \\in [0,1]$.\n- Explicitly handle the degenerate case $k_A = k_B$, where all $\\theta$ produce the same $k_\\theta$.\n- Provide the resulting minimized amplification magnitude and specify whether the one-step update is oscillatory at this optimal $\\theta$.\n\n3) Implement a program that, for each test case below, computes and returns:\n- The minimizing $\\theta(\\Delta t)$ in $[0,1]$,\n- The minimized one-step amplification magnitude for the interfacial jump,\n- A boolean indicating whether the one-step update is oscillatory at the minimizing $\\theta$.\n\nThe test suite consists of the following five parameter sets $(C_A, C_B, k_A, k_B, \\Delta t)$:\n- Case 1 (happy path, exact cancellation achievable): $(1.0,\\,1.0,\\,4.0,\\,1.0,\\,0.4)$.\n- Case 2 (large time step, oscillatory regime; lower bound active): $(1.0,\\,1.0,\\,4.0,\\,1.0,\\,1.0)$.\n- Case 3 (small time step; upper bound active): $(1.0,\\,1.0,\\,4.0,\\,1.0,\\,0.05)$.\n- Case 4 (unequal capacities, exact cancellation achievable): $(2.0,\\,1.0,\\,3.0,\\,0.5,\\,0.3)$.\n- Case 5 (degenerate conductances $k_A=k_B$): $(1.0,\\,3.0,\\,2.0,\\,2.0,\\,0.4)$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing a Python-style list of results for the five cases in the order given above.\n- Each result must be a list of the form $[\\theta^\\star,\\,|g^\\star|,\\,\\text{oscillatory}]$, where $\\theta^\\star$ is the minimizing value in $[0,1]$, $|g^\\star|$ is the minimized one-step amplification magnitude, and $\\text{oscillatory}$ is a boolean that is true if the one-step update is oscillatory at $\\theta^\\star$ and false otherwise.\n- All floating-point numbers in the output must be printed with ten digits after the decimal point.\n- Example overall formatting: $[[\\theta_1,|g_1|,\\text{bool}_1],[\\theta_2,|g_2|,\\text{bool}_2],\\dots]$.\n\nYour program must be complete and runnable as provided, and must not require any user input or external files. The expected outputs are purely numerical (floats and booleans) with no physical units.", "solution": "Starting from the fundamental energy balances\n$$\nC_A \\frac{d u_A}{d t} \\;=\\; -F(t), \\qquad C_B \\frac{d u_B}{d t} \\;=\\; F(t),\n$$\nand the blended explicit update with time step $\\Delta t$,\n$$\nu_A^{n+1} \\;=\\; u_A^n \\;-\\; \\frac{\\Delta t}{C_A} F^{n}, \\qquad\nu_B^{n+1} \\;=\\; u_B^n \\;+\\; \\frac{\\Delta t}{C_B} F^{n},\n$$\nwe have, for the interfacial flux at time level $n$,\n$$\nF^{n} \\;=\\; F^\\star \\;=\\; \\theta F_A^n + (1-\\theta) F_B^n \\;=\\; \\big(\\theta k_A + (1-\\theta) k_B\\big)\\,\\big(u_A^n - u_B^n\\big) \\;=\\; k_\\theta \\, d^n,\n$$\nwhere $d^n \\;=\\; u_A^n - u_B^n$ denotes the interfacial jump and $k_\\theta \\;=\\; \\theta k_A + (1-\\theta) k_B$.\n\nDefine the sum\n$$\nS \\;=\\; \\frac{1}{C_A} + \\frac{1}{C_B}.\n$$\nSubtract the two explicit updates to obtain the jump recurrence:\n$$\nd^{n+1} \\;=\\; u_A^{n+1} - u_B^{n+1} \\;=\\; \\Big(u_A^n - \\frac{\\Delta t}{C_A} k_\\theta d^n\\Big) \\;-\\; \\Big(u_B^n + \\frac{\\Delta t}{C_B} k_\\theta d^n\\Big)\n\\;=\\; d^n - \\Delta t\\,k_\\theta \\Big(\\frac{1}{C_A} + \\frac{1}{C_B}\\Big) d^n.\n$$\nTherefore,\n$$\nd^{n+1} \\;=\\; g(\\theta)\\, d^n, \\qquad \\text{with} \\quad g(\\theta) \\;=\\; 1 - \\Delta t\\,k_\\theta\\,S \\;=\\; 1 - \\Delta t\\,S\\,\\big(\\theta k_A + (1-\\theta) k_B\\big).\n$$\n\nSpurious oscillations in one time step correspond to a sign reversal of the interfacial jump, i.e., $d^{n+1}$ and $d^n$ have opposite signs. Since the recurrence is scalar, this happens if and only if\n$$\ng(\\theta) \\;<\\; 0 \\quad \\Longleftrightarrow \\quad 1 - \\Delta t\\,k_\\theta\\,S \\;<\\; 0 \\quad \\Longleftrightarrow \\quad \\Delta t\\,k_\\theta\\,S \\;>\\; 1.\n$$\nHence, oscillations occur when the one-step amplification factor $g(\\theta)$ is negative.\n\nTo minimize oscillations, we minimize the magnitude of the one-step amplification factor:\n$$\n\\min_{\\theta \\in [0,1]} \\; \\big|g(\\theta)\\big| \\;=\\; \\min_{\\theta \\in [0,1]} \\; \\big|1 - \\Delta t\\,S\\,k_\\theta\\big|.\n$$\nLet\n$$\nk_{\\min} \\;=\\; \\min(k_A,k_B), \\qquad k_{\\max} \\;=\\; \\max(k_A,k_B).\n$$\nBecause $k_\\theta$ is a convex combination, $k_\\theta \\in [k_{\\min},k_{\\max}]$ for $\\theta \\in [0,1]$. Define the target conductance that would nullify the jump in one step:\n$$\nk_{\\text{target}} \\;=\\; \\frac{1}{\\Delta t\\,S}.\n$$\nIf $k_{\\text{target}} \\in [k_{\\min},k_{\\max}]$, then the exact minimizer sets $k_\\theta = k_{\\text{target}}$, yielding\n$$\ng(\\theta^\\star) \\;=\\; 1 - \\Delta t\\,S\\,k_{\\text{target}} \\;=\\; 0,\n$$\nso the jump is eliminated in one step and no oscillation occurs.\n\nIf $k_{\\text{target}} \\notin [k_{\\min},k_{\\max}]$, the minimizer is attained at the nearest bound:\n$$\nk_\\theta^\\star \\;=\\; \\begin{cases}\nk_{\\min}, & \\text{if } k_{\\text{target}} \\le k_{\\min},\\\\\nk_{\\max}, & \\text{if } k_{\\text{target}} \\ge k_{\\max},\n\\end{cases}\n$$\nwhich gives the minimized magnitude\n$$\n\\big|g^\\star\\big| \\;=\\; \\big|1 - \\Delta t\\,S\\,k_\\theta^\\star\\big|.\n$$\n\nTo map the optimal effective conductance $k_\\theta^\\star$ back to $\\theta^\\star$, use the affine relation $k_\\theta = k_B + \\theta (k_A - k_B)$. If $k_A \\neq k_B$, then\n$$\n\\theta^\\star \\;=\\; \\operatorname{clip}_{[0,1]}\\!\\left(\\frac{k_{\\text{target}} - k_B}{k_A - k_B}\\right),\n$$\nwhere the clipping enforces the interval $[0,1]$ and implicitly implements the bound selection described above. If $k_A = k_B$, then $k_\\theta$ is independent of $\\theta$, so all $\\theta$ are equivalent; a natural convention is to set $\\theta^\\star = \\tfrac{1}{2}$.\n\nFinally, the update is oscillatory at the minimizing $\\theta^\\star$ if and only if $g^\\star = 1 - \\Delta t\\,S\\,k_\\theta^\\star < 0$.\n\nAlgorithm for each test case $(C_A, C_B, k_A, k_B, \\Delta t)$:\n- Compute $S \\leftarrow \\tfrac{1}{C_A} + \\tfrac{1}{C_B}$.\n- Compute $k_{\\text{target}} \\leftarrow \\tfrac{1}{\\Delta t\\,S}$.\n- If $k_A \\neq k_B$, set\n$$\n\\theta^\\star \\leftarrow \\operatorname{clip}_{[0,1]}\\!\\left(\\frac{k_{\\text{target}} - k_B}{k_A - k_B}\\right).\n$$\nElse set $\\theta^\\star \\leftarrow \\tfrac{1}{2}$.\n- Compute $k_\\theta^\\star \\leftarrow k_B + \\theta^\\star (k_A - k_B)$.\n- Compute $g^\\star \\leftarrow 1 - \\Delta t\\,S\\,k_\\theta^\\star$.\n- Report $\\theta^\\star$, $\\big|g^\\star\\big|$, and the boolean $(g^\\star < 0)$.\n\nApplying this to the provided cases (with exact arithmetic reasoning):\n- Case 1: $C_A=C_B=1$, $S=2$, $\\Delta t=0.4$, $k_A=4$, $k_B=1$. Then $k_{\\text{target}}=\\tfrac{1}{0.4\\cdot 2}=1.25 \\in [1,4]$. Thus $\\theta^\\star = \\tfrac{1.25-1}{4-1}=\\tfrac{1}{12}$, $g^\\star = 0$, non-oscillatory.\n- Case 2: Same $S=2$, $\\Delta t=1.0$, $k_{\\text{target}}=\\tfrac{1}{2}=0.5 \\le k_{\\min}=1$. Thus $\\theta^\\star=0$, $k_\\theta^\\star=1$, $g^\\star=1-1\\cdot 2\\cdot 1=-1$, oscillatory.\n- Case 3: Same $S=2$, $\\Delta t=0.05$, $k_{\\text{target}}=\\tfrac{1}{0.1}=10 \\ge k_{\\max}=4$. Thus $\\theta^\\star=1$, $k_\\theta^\\star=4$, $g^\\star=1-0.05\\cdot 2\\cdot 4=0.6$, non-oscillatory.\n- Case 4: $C_A=2$, $C_B=1$, $S=\\tfrac{1}{2}+1=\\tfrac{3}{2}$, $\\Delta t=0.3$, $k_A=3$, $k_B=0.5$. Then $k_{\\text{target}}=\\tfrac{1}{0.3\\cdot 1.5}=\\tfrac{1}{0.45}=\\tfrac{20}{9}\\approx 2.222\\in[0.5,3]$. Thus $\\theta^\\star=\\dfrac{\\frac{20}{9}-0.5}{3-0.5}=\\dfrac{\\frac{20}{9}-\\frac{1}{2}}{\\frac{5}{2}}=\\dfrac{\\frac{40-9}{18}}{\\frac{5}{2}}=\\dfrac{\\frac{31}{18}}{\\frac{5}{2}}=\\frac{31}{45}\\approx 0.688\\overline{8}$, $g^\\star=0$, non-oscillatory.\n- Case 5: $C_A=1$, $C_B=3$, $S=1+\\tfrac{1}{3}=\\tfrac{4}{3}$, $\\Delta t=0.4$, $k_A=k_B=2$. Any $\\theta$ gives $k_\\theta^\\star=2$, so set $\\theta^\\star=\\tfrac{1}{2}$ by convention. Then $g^\\star = 1 - 0.4\\cdot \\tfrac{4}{3}\\cdot 2 = 1 - \\tfrac{16}{15} = -\\tfrac{1}{15} \\approx -0.066\\overline{6}$, oscillatory with small magnitude.\n\nThe program implements these computations and prints the results in the required single-line format with ten digits after the decimal point for floating-point values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef compute_theta_star_and_gain(CA, CB, kA, kB, dt):\n    # Compute S = 1/CA + 1/CB\n    S = (1.0 / CA) + (1.0 / CB)\n    # Target conductance to nullify the jump in one step\n    k_target = 1.0 / (dt * S)\n    # Handle degenerate case where kA == kB\n    if abs(kA - kB) < 1e-15:\n        theta_star = 0.5  # by convention; any theta yields the same k_theta\n    else:\n        # Compute unclipped theta that would achieve k_target exactly\n        theta_unclipped = (k_target - kB) / (kA - kB)\n        # Clip to [0, 1]\n        theta_star = 0.0 if theta_unclipped < 0.0 else (1.0 if theta_unclipped > 1.0 else theta_unclipped)\n    # Effective conductance at theta_star\n    k_theta = kB + theta_star * (kA - kB)\n    # One-step amplification factor g\n    g = 1.0 - dt * S * k_theta\n    # Magnitude and oscillatory boolean\n    abs_g = abs(g)\n    oscillatory = g < 0.0\n    return theta_star, abs_g, oscillatory\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (C_A, C_B, k_A, k_B, Delta t)\n    test_cases = [\n        (1.0, 1.0, 4.0, 1.0, 0.4),   # Case 1\n        (1.0, 1.0, 4.0, 1.0, 1.0),   # Case 2\n        (1.0, 1.0, 4.0, 1.0, 0.05),  # Case 3\n        (2.0, 1.0, 3.0, 0.5, 0.3),   # Case 4\n        (1.0, 3.0, 2.0, 2.0, 0.4),   # Case 5\n    ]\n\n    results = []\n    for CA, CB, kA, kB, dt in test_cases:\n        theta_star, abs_g, oscillatory = compute_theta_star_and_gain(CA, CB, kA, kB, dt)\n        # Format with ten digits after decimal for floats\n        results.append(f\"[{theta_star:.10f},{abs_g:.10f},{'True' if oscillatory else 'False'}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3519194"}, {"introduction": "Real-world systems often involve phenomena occurring on vastly different timescales, leading to mathematically 'stiff' problems. This exercise tackles a canonical reactive-advection equation to compare the operator splitting approach with a powerful alternative: Implicit-Explicit (IMEX) methods [@problem_id:3519207]. You will investigate how the choice of time integrator for the stiff chemistry term impacts critical physical properties like positivity and entropy stability, revealing the subtle but crucial differences between these advanced numerical techniques.", "problem": "You are asked to analyze and implement first-order operator splitting and implicit–explicit (IMEX) integration for a one-dimensional reactive advection equation that models a single species mass fraction. The mathematical model is the scalar conservation law with linear relaxation source on the periodic domain $x \\in [0,1)$:\n$$\n\\partial_t y(x,t) + a\\,\\partial_x y(x,t) = -k\\,(y(x,t) - y_{\\mathrm{eq}}),\n$$\nwhere $a>0$ is a constant advection speed, $k>0$ is a stiffness parameter, and $y_{\\mathrm{eq}}>0$ is a constant equilibrium state. The state $y$ is dimensionless and represents a species mass fraction, so physical realism demands $y \\ge 0$. To assess thermodynamic consistency of the source term, use the convex mathematical entropy density\n$$\n\\eta(y) = y \\ln\\!\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) - (y - y_{\\mathrm{eq}}), \\quad y > 0,\n$$\nand the discrete entropy functional\n$$\nH(\\mathbf{y}) = \\sum_{i=0}^{N-1} \\eta(y_i)\\,\\Delta x,\n$$\nwhere $\\mathbf{y} = (y_0,\\dots,y_{N-1})^\\top$ is the vector of cell averages on a uniform periodic grid with $N$ cells and spacing $\\Delta x = 1/N$.\n\nStarting from the fundamental base of conservation laws and standard finite volume discretization, proceed as follows.\n\n- Discretize the advection operator $B$ using a first-order upwind flux consistent with the sign of $a$ and forward Euler time stepping. Use periodic boundary conditions.\n\n- Discretize the stiff chemistry operator $A$ using two options: backward Euler (fully implicit) and forward Euler (fully explicit) time stepping applied to the linear relaxation ordinary differential equation $\\dot{y} = -k(y - y_{\\mathrm{eq}})$ independently at each cell.\n\n- Construct two first-order Lie operator-split methods over a time step $\\Delta t$: $A \\circ B$ with $A$ implemented by backward Euler for the chemistry step, and $A \\circ B$ with $A$ implemented by forward Euler for the chemistry step. In each case, apply the chemistry substep over $\\Delta t$ followed by the advection substep over $\\Delta t$.\n\n- Construct a first-order IMEX Euler method in which the advection term is treated explicitly and the chemistry term is treated implicitly within the same full time step $\\Delta t$.\n\nYour tasks:\n\n1) From the definitions of forward Euler, backward Euler, and first-order upwind finite volume discretization for $a>0$, derive the update formulas for each method (both operator-split and IMEX) in terms of the grid function values. Use the facts that forward Euler applied to $\\dot{y} = f(y)$ gives $y^{n+1} = y^n + \\Delta t\\,f(y^n)$ and backward Euler gives $y^{n+1} = y^n + \\Delta t\\,f(y^{n+1})$. Show that backward Euler applied to the linear relaxation is unconditionally positivity-preserving for $y^n \\ge 0$, while forward Euler can produce negative values when $k \\Delta t$ is sufficiently large relative to $y^n$ and $y_{\\mathrm{eq}}$.\n\n2) Prove that the entropy density $\\eta$ is strictly convex for $y>0$ and attains its unique minimum at $y = y_{\\mathrm{eq}}$. Conclude that any time integrator for the chemistry that is a contraction towards $y_{\\mathrm{eq}}$ is entropy dissipative in the sense that $H$ does not increase over that substep. Explain why, for the linear relaxation, the backward Euler chemistry step is entropy stable for any $\\Delta t>0$.\n\n3) Implement and compare three methods on a uniform periodic grid with $N = 100$, $\\Delta x = 1/N$, $a = 0.5$, $y_{\\mathrm{eq}} = 0.05$, and final time $T = 0.2$. Use the initial condition\n$$\ny(x,0) = y_{\\mathrm{eq}} + 0.4\\,\\exp\\big(-200\\,(x-0.25)^2\\big) + 0.2\\,\\exp\\big(-400\\,(x-0.75)^2\\big).\n$$\nEvolve to $T$ by repeating steps of size $\\Delta t$ and, if $T/\\Delta t$ is not an integer, use a final shortened step so that the total simulated time equals $T$ exactly.\n\n4) For the following test suite of $(k,\\Delta t)$ pairs, run all three methods:\n   - Case A (happy path): $(k,\\Delta t) = (1000, 0.001)$.\n   - Case B (very stiff): $(k,\\Delta t) = (8000, 0.01)$.\n   - Case C (CFL boundary): $(k,\\Delta t) = (500, 0.02)$.\n\nFor each case, compute the following seven outputs:\n   - $p_{\\mathrm{BE}}$: a boolean indicating whether all degrees of freedom remain nonnegative after the final time using operator splitting with backward Euler chemistry.\n   - $e_{\\mathrm{BE}}$: a boolean indicating whether the discrete entropy $H$ after each chemistry substep does not increase relative to immediately before that substep, throughout the simulation with backward Euler chemistry.\n   - $p_{\\mathrm{IMEX}}$: a boolean indicating whether all degrees of freedom remain nonnegative after the final time using the IMEX Euler method.\n   - $e_{\\mathrm{IMEX}}$: a boolean indicating whether the discrete entropy $H$ after each full IMEX step does not increase relative to immediately before that step, throughout the simulation.\n   - $p_{\\mathrm{EE}}$: a boolean indicating whether all degrees of freedom remain nonnegative after the final time using operator splitting with forward Euler chemistry.\n   - $e_{\\mathrm{EE}}$: a boolean indicating whether the discrete entropy $H$ after each forward Euler chemistry substep does not increase relative to immediately before that substep, throughout the simulation.\n   - $d_{\\mathrm{L1}}$: the discrete $\\ell^1$ difference between the IMEX and backward-Euler-split final states, defined as $\\sum_i |y^{\\mathrm{IMEX}}_i - y^{\\mathrm{BE\\mbox{-}split}}_i|\\,\\Delta x$ as a floating-point number.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a sublist of the form $[p_{\\mathrm{BE}}, e_{\\mathrm{BE}}, p_{\\mathrm{IMEX}}, e_{\\mathrm{IMEX}}, p_{\\mathrm{EE}}, e_{\\mathrm{EE}}, d_{\\mathrm{L1}}]$. For example, the final output format must be like\n$[[\\text{case A outputs}],[\\text{case B outputs}],[\\text{case C outputs}]]$.", "solution": "The problem avers a one-dimensional reactive advection equation, a standard partial differential equation (PDE) in transport phenomena. All parameters, initial conditions, and numerical methods are well-defined within the established mathematical and computational sciences literature. The problem is scientifically sound, self-contained, and well-posed. The tasks involve standard derivations and the implementation of canonical numerical schemes (operator splitting, IMEX) for such equations. The problem is therefore deemed valid.\n\n### Task 1: Derivation of Numerical Schemes\n\nThe governing PDE is $\\partial_t y + a\\,\\partial_x y = -k(y - y_{\\mathrm{eq}})$, which can be written in the form $\\partial_t y = A(y) + B(y)$, where $A(y) = -k(y - y_{\\mathrm{eq}})$ is the chemistry operator and $B(y) = -a\\,\\partial_x y$ is the advection operator.\n\nWe discretize the spatial domain $[0,1)$ into $N$ cells of width $\\Delta x = 1/N$. Let $y_i(t)$ be the cell-averaged value in cell $i$.\n\n**Advection Operator ($B$) Discretization**\nThe advection operator $B(y) = -a\\,\\partial_x y$ is discretized using a first-order upwind finite volume method. Since $a>0$, the flux at the interface $i+1/2$ between cells $i$ and $i+1$ is $F_{i+1/2} = a y_i$. The semi-discrete equation for cell $i$ is:\n$$\n\\frac{d y_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = -\\frac{a y_i - a y_{i-1}}{\\Delta x}\n$$\nApplying a forward Euler step over a time step $\\Delta t$ to the equation $\\dot{\\mathbf{y}} = \\mathcal{B}(\\mathbf{y})$, where $\\mathcal{B}$ is the discrete advection operator, gives the update:\n$$\ny_i^* = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)\n$$\nwhere periodic boundary conditions imply $y_{-1}^n = y_{N-1}^n$.\n\n**Chemistry Operator ($A$) Discretization**\nThe chemistry operator $A(y) = -k(y - y_{\\mathrm{eq}})$ corresponds to the ordinary differential equation (ODE) $\\dot{y} = -k(y-y_{\\mathrm{eq}})$ applied independently in each cell.\n\n- **Forward Euler (FE) Discretization**:\n  The update rule is $y^{n+1} = y^n + \\Delta t \\, f(y^n)$, where $f(y) = -k(y - y_{\\mathrm{eq}})$.\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^n - y_{\\mathrm{eq}})) = y^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n  $$\n  For positivity, if $y^n \\ge 0$, we require $y^{n+1} \\ge 0$. If $k\\Delta t > 1$, the term $(1-k\\Delta t)$ is negative. Positivity can be violated. For example, if $k\\Delta t=2$ and $y^n > 2y_{\\mathrm{eq}}$, then $y^{n+1} = -y^n+2y_{\\mathrm{eq}} < 0$. Thus, the FE scheme for this reaction is not unconditionally positivity-preserving.\n\n- **Backward Euler (BE) Discretization**:\n  The update rule is $y^{n+1} = y^n + \\Delta t \\, f(y^{n+1})$.\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^{n+1} - y_{\\mathrm{eq}}))\n  $$\n  Solving for $y^{n+1}$:\n  $y^{n+1}(1 + k \\Delta t) = y^n + k \\Delta t y_{\\mathrm{eq}}$\n  $$\n  y^{n+1} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n  $$\n  Since $y^n \\ge 0$, $k > 0$, $\\Delta t > 0$, and $y_{\\mathrm{eq}} > 0$, both the numerator and the denominator are strictly positive. Thus, $y^{n+1} > 0$. The BE scheme is unconditionally positivity-preserving.\n\n**Construction of Full Schemes**\n\n1.  **Operator-Split, Backward Euler Chemistry ($A \\circ B$)**:\n    This is a first-order Lie-Trotter splitting where the chemistry substep is applied first, followed by the advection substep.\n    -   Step 1 (Chemistry, BE): For each cell $i=0, \\dots, N-1$:\n        $$\n        y_i^{**} = \\frac{y_i^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n        $$\n    -   Step 2 (Advection, FE): For each cell $i=0, \\dots, N-1$:\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n2.  **Operator-Split, Forward Euler Chemistry ($A \\circ B$)**:\n    Similar to the above, but the chemistry substep uses Forward Euler.\n    -   Step 1 (Chemistry, FE): For each cell $i=0, \\dots, N-1$:\n        $$\n        y_i^{**} = y_i^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n        $$\n    -   Step 2 (Advection, FE): For each cell $i=0, \\dots, N-1$:\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n3.  **IMEX Euler Method**:\n    The IMEX Euler method treats the non-stiff advection term explicitly and the stiff chemistry term implicitly within a single step.\n    $$\n    \\frac{y_i^{n+1} - y_i^n}{\\Delta t} = \\underbrace{-k(y_i^{n+1} - y_{\\mathrm{eq}})}_{\\text{Implicit}} + \\underbrace{\\left(-\\frac{a}{\\Delta x}(y_i^n - y_{i-1}^n)\\right)}_{\\text{Explicit}}\n    $$\n    Rearranging to solve for $y_i^{n+1}$:\n    $y_i^{n+1} - y_i^n = -k \\Delta t y_i^{n+1} + k \\Delta t y_{\\mathrm{eq}} - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)$\n    $y_i^{n+1}(1 + k \\Delta t) = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}}$\n    $$\n    y_i^{n+1} = \\frac{1}{1 + k \\Delta t} \\left( y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}} \\right)\n    $$\n\n### Task 2: Entropy Analysis\n\nThe mathematical entropy density is given by $\\eta(y) = y \\ln(y/y_{\\mathrm{eq}}) - (y - y_{\\mathrm{eq}})$ for $y>0$.\n\n**Convexity and Minimum of $\\eta(y)$**\nFirst, we find the first and second derivatives of $\\eta(y)$ with respect to $y$:\n$$\n\\eta'(y) = \\frac{d}{dy} \\left( y \\ln y - y \\ln y_{\\mathrm{eq}} - y + y_{\\mathrm{eq}} \\right) = (\\ln y + 1) - \\ln y_{\\mathrm{eq}} - 1 = \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right)\n$$\n$$\n\\eta''(y) = \\frac{d}{dy} \\left( \\ln y - \\ln y_{\\mathrm{eq}} \\right) = \\frac{1}{y}\n$$\nFor the physical domain of the mass fraction $y > 0$, the second derivative $\\eta''(y) = 1/y$ is strictly positive. This proves that $\\eta(y)$ is a strictly convex function for $y>0$.\n\nThe unique minimum of a strictly convex function occurs where its first derivative is zero.\n$$\n\\eta'(y) = 0 \\implies \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) = 0 \\implies \\frac{y}{y_{\\mathrm{eq}}} = 1 \\implies y = y_{\\mathrm{eq}}\n$$\nThus, $\\eta(y)$ attains its unique global minimum at the equilibrium state $y = y_{\\mathrm{eq}}$. The minimum value is $\\eta(y_{\\mathrm{eq}}) = y_{\\mathrm{eq}} \\ln(1) - (y_{\\mathrm{eq}} - y_{\\mathrm{eq}}) = 0$.\n\n**Entropy Dissipation and Contractions**\nThe discrete entropy is $H(\\mathbf{y}) = \\sum_i \\eta(y_i) \\Delta x$. An integrator for the chemistry ODE is entropy dissipative (or entropy stable) if $H$ does not increase over one step. Since $\\eta(y)$ is convex with its minimum at $y_{\\mathrm{eq}}$, any update $y^n \\to y^{n+1}$ that moves the state closer to $y_{\\mathrm{eq}}$ (i.e., is a contraction towards $y_{\\mathrm{eq}}$) will result in $\\eta(y^{n+1}) \\le \\eta(y^n)$. If this holds for all cells $i$, then $H(\\mathbf{y}^{n+1}) \\le H(\\mathbf{y}^n)$.\n\n**Entropy Stability of the Backward Euler Chemistry Step**\nLet us analyze the distance from equilibrium for the BE update $y^* = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}$.\n$$\ny^* - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t} - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}} - y_{\\mathrm{eq}}(1 + k \\Delta t)}{1 + k \\Delta t} = \\frac{y^n - y_{\\mathrm{eq}}}{1 + k \\Delta t}\n$$\nTaking the absolute value:\n$$\n|y^* - y_{\\mathrm{eq}}| = \\frac{1}{1 + k \\Delta t} |y^n - y_{\\mathrm{eq}}|\n$$\nSince $k>0$ and $\\Delta t>0$, the factor $1/(1+k\\Delta t)$ is strictly less than $1$. This shows that the BE step is a strict contraction mapping towards the equilibrium point $y_{\\mathrm{eq}}$ for any time step $\\Delta t > 0$. Consequently, $\\eta(y^*) < \\eta(y^n)$ for any $y^n \\neq y_{\\mathrm{eq}}$, and $\\eta(y^*) = \\eta(y^n)$ if $y^n = y_{\\mathrm{eq}}$. Therefore, the BE chemistry step is unconditionally entropy stable.\n\nA similar analysis for the IMEX scheme shows that it can be interpreted as an explicit upwind advection step, which is entropy stable due to the convexity of $\\eta$, followed by an unconditionally entropy-stable BE reaction step. We therefore expect the full IMEX step to be entropy stable. The explicit FE chemistry step, however, is not a contraction for $k \\Delta t > 2$ and is expected to violate entropy stability in stiff regimes.\n\n### Implementation and Comparison\nThe three numerical methods—operator splitting with backward Euler chemistry (Split-BE), operator splitting with forward Euler chemistry (Split-FE), and IMEX Euler—are implemented. The system is evolved from the specified initial condition up to time $T=0.2$. For each of the three test cases $(k, \\Delta t)$, the simulation is run with each method. During the simulation, we track two properties:\n1.  **Positivity**: Whether the solution vector $\\mathbf{y}$ remains non-negative at all grid points. This is checked at the final time $T$.\n2.  **Entropy Stability**: For each relevant step (chemistry substep for split methods, full step for IMEX), we compute the discrete entropy $H(\\mathbf{y})$ before and after the step and verify that it does not increase. A boolean flag, initialized to true, is set to false upon the first violation.\nThe final state of the Split-BE and IMEX methods are compared using a discrete $\\ell^1$-norm to quantify their difference. The results are systematically collected for each test case as per the problem specification. The implementation details are provided in the final answer code block.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactive advection problem using three different numerical methods\n    and reports on their stability properties and differences.\n    \"\"\"\n    # Global parameters\n    N = 100\n    L = 1.0\n    dx = L / N\n    a = 0.5\n    y_eq = 0.05\n    T = 0.2\n    x = np.linspace(0, L, N, endpoint=False)\n\n    # Initial condition\n    y0 = y_eq + 0.4 * np.exp(-200 * (x - 0.25)**2) + 0.2 * np.exp(-400 * (x - 0.75)**2)\n\n    # Entropy function eta(y)\n    # Define eta(0) = y_eq for continuity as y*ln(y) -> 0 for y->0+\n    def eta(y, y_eq_val):\n        # Use np.where to handle y=0 case to avoid log(0) warnings\n        y_safe = np.where(y > 0, y, 1.0) # a dummy value for log, result not used\n        log_term = np.where(y > 0, y_safe * np.log(y_safe / y_eq_val), 0)\n        return log_term - (y - y_eq_val)\n\n    # Discrete entropy functional H(y)\n    def discrete_entropy(y, y_eq_val, dx_val):\n        return np.sum(eta(y, y_eq_val)) * dx_val\n\n    # --- Method Implementations ---\n\n    def run_split_be(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Backward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = (y + k * t_step * y_eq_val) / (1.0 + k * t_step)\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem > H_before_chem + 1e-12: # Check with tolerance\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n        \n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    def run_split_fe(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n\n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Forward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = y * (1.0 - k * t_step) + k * t_step * y_eq_val\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem > H_before_chem + 1e-12:\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n\n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    def run_imex(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time > 1e-12:\n            time_steps.append(remaining_time)\n        \n        for t_step in time_steps:\n            H_before = discrete_entropy(y, y_eq_val, dx_val)\n            \n            # IMEX update\n            cfl_step = a_val * t_step / dx_val\n            advection_term = y - cfl_step * (y - np.roll(y, 1))\n            numerator = advection_term + k * t_step * y_eq_val\n            denominator = 1.0 + k * t_step\n            y = numerator / denominator\n            \n            H_after = discrete_entropy(y, y_eq_val, dx_val)\n            if H_after > H_before + 1e-12:\n                entropy_stable = False\n        \n        positivity = np.all(y >= 0)\n        return y, positivity, entropy_stable\n\n    # Test cases\n    test_cases = [\n        (1000, 0.001),  # Case A\n        (8000, 0.01),   # Case B\n        (500, 0.02),    # Case C\n    ]\n    \n    all_results = []\n\n    for k_val, dt_val in test_cases:\n        y_be, p_be, e_be = run_split_be(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_imex, p_imex, e_imex = run_imex(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_ee, p_ee, e_ee = run_split_fe(y0, k_val, dt_val, T, a, y_eq, dx)\n        \n        d_l1 = np.sum(np.abs(y_imex - y_be)) * dx\n        \n        case_results = [p_be, e_be, p_imex, e_imex, p_ee, e_ee, d_l1]\n        all_results.append(case_results)\n\n    # Format output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v)\n        if isinstance(v, np.bool_):\n            return str(v)\n        return f\"{v:.15g}\"\n\n    sublist_strs = []\n    for res in all_results:\n        sublist_strs.append(f\"[{','.join(format_val(v) for v in res)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3519207"}, {"introduction": "Fractional step methods are indispensable for simulating incompressible flows, where they decouple the computation of velocity and pressure. This decomposition, however, introduces an intermediate pressure subproblem that requires its own carefully derived boundary conditions [@problem_id:3519215]. This practice guides you through the process of deriving a physically consistent pressure boundary condition at an outflow and quantifies the spurious numerical reflections that arise from a seemingly plausible but incorrect choice, a common source of error in computational fluid dynamics codes.", "problem": "Consider an incompressible Newtonian fluid modeled by the incompressible Navier–Stokes equations in a straight channel occupying the spatial domain $\\Omega = \\{(x,y) \\in \\mathbb{R}^{2} : 0 \\le x \\le L,\\, 0 \\le y \\le H\\}$, with density $\\rho$ and dynamic viscosity $\\mu$. Let the outward normal at the outflow boundary $\\Gamma_{\\text{out}} = \\{x=L\\}$ be $\\mathbf{n} = \\mathbf{e}_{x}$. The flow is predominantly aligned with $\\mathbf{e}_{x}$ and has a steady outflow speed $U_{b} > 0$ at $\\Gamma_{\\text{out}}$. A first-order pressure-projection fractional step (also called operator splitting) scheme advances the velocity via\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n},\n$$\nand then enforces incompressibility by solving the pressure subproblem\n$$\n\\nabla^{2} p^{n+1} = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*},\n$$\nfollowed by the velocity correction\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}.\n$$\nYou may assume a smooth solution and that viscous normal stresses at the outflow are negligible compared to convective transport, a regime typical of moderate to high Reynolds number channel outflows.\n\nTask 1 (derivation): Starting from the incompressible Navier–Stokes momentum equation and the above fractional-step framework, linearize the normal component of the momentum balance at $\\Gamma_{\\text{out}}$ around the steady outflow speed $U_{b}$, and impose a convective radiation condition for the velocity at the outflow,\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}},\n$$\nwhere $u_{n} = \\mathbf{u} \\cdot \\mathbf{n}$. Under the stated assumptions, derive the corresponding pressure boundary condition at $\\Gamma_{\\text{out}}$ that is consistent with the fractional-step projection, expressed as a Neumann condition for $p^{n+1}$.\n\nTask 2 (quantification of spurious reflection under mis-specification): Consider a one-dimensional surrogate of the pressure subproblem along the streamwise direction $x \\in [0,L]$ with the right-hand side chosen as a single Fourier mode representative of the divergence of the intermediate velocity field,\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\!\\left(\\frac{\\pi x}{L}\\right),\n$$\nwith $G$ a constant. At the inflow boundary $x=0$, take a reference pressure condition $p(0) = 0$. For the outflow boundary $x=L$:\n- Case A (physically consistent outflow): Impose the Neumann boundary condition derived in Task 1 and compute $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$.\n- Case B (mis-specified outflow): Impose a Dirichlet condition $p(L) = 0$ instead of the Neumann condition and compute $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$.\n\nDefine the reflection coefficient $\\mathcal{R}$ as the ratio of the magnitude of the outflow-normal velocity correction induced by the mis-specified Dirichlet condition in Case B to the magnitude of the inflow-normal velocity correction in Case A, both measured at the boundaries. Using the velocity correction relation\n$$\nu_{n}^{\\text{corr}}(x) = - \\frac{\\Delta t}{\\rho} \\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x},\n$$\nexpress $\\mathcal{R}$ as\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}.\n$$\n\nAnswer specification: Provide your final answer as a two-entry row matrix containing, in order, the outflow pressure Neumann boundary condition value from Task 1 (as a number or closed-form expression evaluated at $x=L$) and the reflection coefficient $\\mathcal{R}$ from Task 2. No rounding is required. The reflection coefficient is dimensionless. Do not include units in your final boxed answer.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard analysis of numerical boundary conditions for projection methods in computational fluid dynamics. I will now proceed with the solution.\n\nThe problem consists of two tasks. Task 1 is to derive a Neumann boundary condition for the pressure at the outflow boundary of a channel flow simulation that uses a fractional-step projection method. Task 2 is to quantify the spurious reflection at the outflow caused by using an incorrect pressure boundary condition, analyzed through a simplified one-dimensional model.\n\n### Task 1: Derivation of the Outflow Pressure Boundary Condition\n\nThe goal is to find a boundary condition for the pressure $p^{n+1}$ at the outflow boundary $\\Gamma_{\\text{out}} = \\{x=L\\}$ that is consistent with the imposed convective radiation condition for the velocity. The normal vector at this boundary is $\\mathbf{n} = \\mathbf{e}_{x}$, so the normal direction corresponds to the $x$-direction, and the normal velocity is $u_{n} = \\mathbf{u} \\cdot \\mathbf{n} = u_{x}$. The normal derivative is $\\frac{\\partial}{\\partial n} = \\frac{\\partial}{\\partial x}$.\n\nThe velocity correction step of the fractional-step method is given by:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}\n$$\nTaking the dot product with the outward normal $\\mathbf{n}$ at the boundary $\\Gamma_{\\text{out}}$ yields the normal velocity component at the new time step $n+1$:\n$$\nu_{n}^{n+1} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\nThis equation relates the desired pressure Neumann condition, $\\frac{\\partial p^{n+1}}{\\partial n}$, to the velocities at the boundary. To solve for it, we need an expression for $u_n^{n+1}$ on $\\Gamma_{\\text{out}}$.\n\nThe problem imposes a convective radiation condition for the velocity at the outflow:\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\nWe can discretize this equation in time using a first-order explicit scheme (forward Euler for the time derivative, evaluation at time $n$ for the spatial derivative) consistent with the overall first-order temporal accuracy of the given projection scheme:\n$$\n\\frac{u_{n}^{n+1} - u_{n}^{n}}{\\Delta t} + U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} = 0\n$$\nSolving for $u_{n}^{n+1}$ gives the target normal velocity at the outflow for the new time step:\n$$\nu_{n}^{n+1} = u_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\nNow, we substitute this expression for $u_n^{n+1}$ into the normal component of the velocity correction equation:\n$$\nu_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n}\n$$\nRearranging to solve for the pressure gradient gives:\n$$\n\\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} = (u_{n}^{*} - u_{n}^{n}) + \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\nThe term $(u_{n}^{*} - u_{n}^{n})$ is determined by the momentum predictor step:\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n}\n$$\nTaking the normal component of this equation gives:\n$$\n\\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n} \\right] \\cdot \\mathbf{n}\n$$\nSubstituting this into our expression for the pressure gradient:\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} + \\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\nNow, we apply the assumptions provided in the problem statement, evaluated at time level $n$ and on the boundary $\\Gamma_{\\text{out}}$:\n1.  Linearization of the convective term around the steady outflow speed $U_b$: $(\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} \\approx U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}$.\n2.  Viscous normal stresses are negligible: This implies that the normal component of the viscous force term at the outflow is negligible, so $\\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} \\approx 0$.\n\nApplying these assumptions to the equation for the pressure gradient:\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} \\approx \\left[ - \\rho \\left( U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} \\right) + 0 + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = - \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} + f_{n}^{n} + \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\nThe convective terms cancel out, leaving:\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = f_{n}^{n}\n$$\nThe problem does not specify the body force $\\mathbf{f}^{n}$. In typical applications and model problems of this nature, body forces are often assumed to be zero unless stated otherwise. For the result to be a specific value and to ensure consistency with Task 2 (which implicitly has no body force term), we assume $\\mathbf{f}^{n} = \\mathbf{0}$. Therefore, $f_n^n = 0$.\nThe resulting Neumann boundary condition for the pressure at the outflow is:\n$$\n\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x=L} = 0\n$$\n\n### Task 2: Quantification of Spurious Reflection\n\nWe analyze the one-dimensional surrogate problem for the pressure, given by the ordinary differential equation:\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\nThe general solution can be found by integrating twice with respect to $x$:\n$$\n\\frac{\\mathrm{d} p}{\\mathrm{d} x} = \\int G \\sin\\left(\\frac{\\pi x}{L}\\right) \\mathrm{d}x = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\n$$\n$$\np(x) = \\int \\left(-G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\\right) \\mathrm{d}x = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right) + C_1 x + C_2\n$$\n\n**Case A: Physically consistent outflow**\nThe boundary conditions are $p(0) = 0$ (inflow) and $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$ (outflow, from Task 1).\n\nApplying $p(0) = 0$:\n$$\np(0) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(0) + C_1(0) + C_2 = 0 \\implies C_2=0\n$$\nApplying $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$:\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi L}{L}\\right) + C_1 = -G \\frac{L}{\\pi} \\cos(\\pi) + C_1 = 0\n$$\n$$\n-G \\frac{L}{\\pi} (-1) + C_1 = 0 \\implies C_1 = -G \\frac{L}{\\pi}\n$$\nThe pressure gradient for Case A is $\\frac{\\mathrm{d} p_A}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi}$.\n\n**Case B: Mis-specified outflow**\nThe boundary conditions are $p(0) = 0$ (inflow) and $p(L) = 0$ (outflow).\n\nApplying $p(0) = 0$ gives $C_2 = 0$, as before.\nApplying $p(L) = 0$:\n$$\np(L) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi L}{L}\\right) + C_1 L = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(\\pi) + C_1 L = 0\n$$\n$$\n0 + C_1 L = 0 \\implies C_1 = 0\n$$\nThe pressure gradient for Case B is $\\frac{\\mathrm{d} p_B}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right)$.\n\n**Calculation of the Reflection Coefficient $\\mathcal{R}$**\nThe reflection coefficient is defined as:\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}\n$$\nFirst, we evaluate the numerator:\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) \\right) \\right|_{x=L} = -G \\frac{L}{\\pi} \\cos(\\pi) = G \\frac{L}{\\pi}\n$$\nNext, we evaluate the denominator:\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi} \\right) \\right|_{x=0} = -G \\frac{L}{\\pi} \\cos(0) - G \\frac{L}{\\pi} = -G \\frac{L}{\\pi} - G \\frac{L}{\\pi} = -2G \\frac{L}{\\pi}\n$$\nNow, we compute the ratio of their magnitudes:\n$$\n\\mathcal{R} = \\frac{\\left| G \\frac{L}{\\pi} \\right|}{\\left| -2G \\frac{L}{\\pi} \\right|} = \\frac{|G| \\frac{L}{\\pi}}{2|G| \\frac{L}{\\pi}} = \\frac{1}{2}\n$$\n\nThe final answer requires the outflow pressure Neumann boundary condition value from Task 1, which is $0$, and the reflection coefficient $\\mathcal{R}$ from Task 2, which is $\\frac{1}{2}$. These are provided in a two-entry row matrix.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{1}{2} \\end{pmatrix}}\n$$", "id": "3519215"}]}