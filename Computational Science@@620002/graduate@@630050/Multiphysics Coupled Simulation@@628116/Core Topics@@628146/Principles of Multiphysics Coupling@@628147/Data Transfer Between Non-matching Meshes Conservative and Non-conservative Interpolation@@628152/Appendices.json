{"hands_on_practices": [{"introduction": "This first exercise guides you through the foundational principles of conservative data transfer. By deriving and implementing a 1D conservative operator from scratch based on geometric overlap, you will gain a concrete understanding of how conservation is achieved by preserving the integral of a piecewise-reconstructed field [@problem_id:3501827]. This practice provides a direct comparison with a simple non-conservative sampling method, allowing you to verify the critical properties of conservation and boundedness that distinguish these two approaches.", "problem": "You are given two one-dimensional meshes on the closed interval $[0,1]$. A mesh is specified by a strictly increasing list of cell-edge coordinates, and the associated data are cell averages of a scalar field over each cell. Let the source mesh have $N_{\\mathrm{s}}$ cells with edges $\\{x^{\\mathrm{s}}_{0},x^{\\mathrm{s}}_{1},\\dots,x^{\\mathrm{s}}_{N_{\\mathrm{s}}}\\}$ and cell lengths $L^{\\mathrm{s}}_{i}=x^{\\mathrm{s}}_{i+1}-x^{\\mathrm{s}}_{i}$ for $i=0,\\dots,N_{\\mathrm{s}}-1$. Let the target mesh have $N_{\\mathrm{t}}$ cells with edges $\\{x^{\\mathrm{t}}_{0},x^{\\mathrm{t}}_{1},\\dots,x^{\\mathrm{t}}_{N_{\\mathrm{t}}}\\}$ and cell lengths $L^{\\mathrm{t}}_{j}=x^{\\mathrm{t}}_{j+1}-x^{\\mathrm{t}}_{j}$ for $j=0,\\dots,N_{\\mathrm{t}}-1$. The source data are cell averages $\\bar{q}^{\\mathrm{s}}_{i}$, defined by $\\bar{q}^{\\mathrm{s}}_{i}=\\frac{1}{L^{\\mathrm{s}}_{i}}\\int_{x^{\\mathrm{s}}_{i}}^{x^{\\mathrm{s}}_{i+1}}u(x)\\,\\mathrm{d}x$ for some unknown integrable $u(x)$.\n\nYour task is to derive from first principles and implement two linear transfer operators that map the source cell-average vector to a target cell-average vector on a non-matching mesh:\n\n- A conservative operator, assembled from the geometric overlap between source and target cells, which preserves the total integral exactly when the target domain equals the source domain. Starting only from the definition of cell averages and the requirement that total integral be preserved, derive how to assemble this operator using geometric information.\n\n- A non-conservative operator based on nearest cell-center sampling, which assigns to each target cell the value of the source cell average corresponding to the source cell containing the target cell center.\n\nFor both operators, apply them to given source cell-average vectors and assess two properties:\n\n- Conservation: whether $\\sum_{i=0}^{N_{\\mathrm{s}}-1}\\bar{q}^{\\mathrm{s}}_{i}L^{\\mathrm{s}}_{i}$ equals $\\sum_{j=0}^{N_{\\mathrm{t}}-1}\\bar{q}^{\\mathrm{t}}_{j}L^{\\mathrm{t}}_{j}$ within a specified tolerance.\n\n- Boundedness: whether $\\min_{j}\\bar{q}^{\\mathrm{t}}_{j}\\ge \\min_{i}\\bar{q}^{\\mathrm{s}}_{i}$ and $\\max_{j}\\bar{q}^{\\mathrm{t}}_{j}\\le \\max_{i}\\bar{q}^{\\mathrm{s}}_{i}$ within a specified tolerance.\n\nAssume the target domain equals the source domain, and do not use any units; treat all quantities as dimensionless.\n\nImplement a program that:\n\n- Assembles the conservative operator solely from cell-edge coordinates and the cell-length normalization implied by the definition of cell averages.\n\n- Assembles the non-conservative operator by mapping each target cell center $c^{\\mathrm{t}}_{j}=\\frac{1}{2}(x^{\\mathrm{t}}_{j}+x^{\\mathrm{t}}_{j+1})$ to the unique source cell that contains it.\n\n- Applies both operators to the provided source cell-average vectors, and for each case returns booleans for conservation and boundedness.\n\nUse the following test suite of meshes and data:\n\n- Case A (general non-matching, smooth-to-mixed data):\n    - Source edges: $[0.0,\\,0.2,\\,0.5,\\,0.7,\\,1.0]$.\n    - Target edges: $[0.0,\\,0.1,\\,0.4,\\,0.6,\\,0.85,\\,1.0]$.\n    - Source cell averages: $[0.0,\\,1.0,\\,-0.5,\\,2.0]$.\n\n- Case B (boundary alignment, constant data):\n    - Source edges: $[0.0,\\,0.3,\\,0.6,\\,1.0]$.\n    - Target edges: $[0.0,\\,0.3,\\,0.8,\\,1.0]$.\n    - Source cell averages: $[1.0,\\,1.0,\\,1.0]$.\n\n- Case C (extreme size ratios, oscillatory data):\n    - Source edges: $[0.0,\\,0.01,\\,0.02,\\,0.5,\\,1.0]$.\n    - Target edges: $[0.0,\\,0.9,\\,0.95,\\,0.975,\\,1.0]$.\n    - Source cell averages: $[10.0,\\,-10.0,\\,0.0,\\,1.0]$.\n\nFor each case, compute and return in order the following four booleans:\n\n- Conservative operator: conservation check.\n- Conservative operator: boundedness check.\n- Non-conservative operator: conservation check.\n- Non-conservative operator: boundedness check.\n\nUse an absolute tolerance of $\\varepsilon=10^{-12}$ for both conservation and boundedness checks.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the booleans for Case A followed by Case B followed by Case C, each case contributing four booleans in the order above. For example, a valid output format is $[{\\mathrm{True}},{\\mathrm{False}},{\\mathrm{True}},{\\mathrm{True}},\\dots]$.", "solution": "The problem requires the derivation and implementation of two data transfer operators between non-matching one-dimensional meshes: a conservative operator and a non-conservative nearest-neighbor operator. We will first derive the mathematical formulation of each operator from first principles and analyze their properties regarding conservation and boundedness.\n\nLet the source mesh be defined by a set of $N_{\\mathrm{s}}+1$ strictly increasing edge coordinates $\\{x^{\\mathrm{s}}_{0}, x^{\\mathrm{s}}_{1}, \\dots, x^{\\mathrm{s}}_{N_{\\mathrm{s}}}\\}$ on the interval $[0, 1]$, such that $x^{\\mathrm{s}}_{0}=0$ and $x^{\\mathrm{s}}_{N_{\\mathrm{s}}}=1$. The $i$-th source cell is the interval $[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]$ for $i=0, \\dots, N_{\\mathrm{s}}-1$, with length $L^{\\mathrm{s}}_{i} = x^{\\mathrm{s}}_{i+1} - x^{\\mathrm{s}}_{i}$. The source data are cell averages $\\bar{q}^{\\mathrm{s}}_{i}$ of an unknown integrable function $u(x)$, given by $\\bar{q}^{\\mathrm{s}}_{i} = \\frac{1}{L^{\\mathrm{s}}_{i}} \\int_{x^{\\mathrm{s}}_{i}}^{x^{\\mathrm{s}}_{i+1}} u(x) \\, \\mathrm{d}x$.\n\nSimilarly, the target mesh consists of $N_{\\mathrm{t}}$ cells defined by edges $\\{x^{\\mathrm{t}}_{0}, x^{\\mathrm{t}}_{1}, \\dots, x^{\\mathrm{t}}_{N_{\\mathrm{t}}}\\}$ on $[0, 1]$, with $x^{\\mathrm{t}}_{0}=0$ and $x^{\\mathrm{t}}_{N_{\\mathrm{t}}}=1$. The $j$-th target cell is $[x^{\\mathrm{t}}_{j}, x^{\\mathrm{t}}_{j+1}]$ with length $L^{\\mathrm{t}}_{j} = x^{\\mathrm{t}}_{j+1} - x^{\\mathrm{t}}_{j}$. Our goal is to compute the target cell averages $\\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} u(x) \\, \\mathrm{d}x$.\n\n**1. Conservative Operator**\n\nThe derivation of the conservative operator begins with the fundamental definition of the target cell average $\\bar{q}^{\\mathrm{t}}_{j}$:\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} u(x) \\, \\mathrm{d}x $$\nSince $u(x)$ is unknown, we must approximate it using the available source data. A common choice in finite volume methods, which naturally leads to a conservative scheme, is to reconstruct $u(x)$ as a piecewise-constant function, where the constant value in each source cell $i$ is its cell average, $\\bar{q}^{\\mathrm{s}}_{i}$. Let this reconstructed function be $\\tilde{u}(x)$:\n$$ \\tilde{u}(x) = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\cdot \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) $$\nwhere $\\mathbf{1}_{A}(x)$ is the indicator function, equal to $1$ if $x \\in A$ and $0$ otherwise.\n\nSubstituting $\\tilde{u}(x)$ for $u(x)$ in the integral for $\\bar{q}^{\\mathrm{t}}_{j}$:\n$$ \\bar{q}^{\\mathrm{t}}_{j} \\approx \\frac{1}{L^{\\mathrm{t}}_{j}} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} \\left( \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\cdot \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) \\right) \\mathrm{d}x $$\nBy linearity of the integral, we can swap the summation and integration:\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\int_{x^{\\mathrm{t}}_{j}}^{x^{\\mathrm{t}}_{j+1}} \\mathbf{1}_{[x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}]}(x) \\, \\mathrm{d}x $$\nThe integral term represents the length of the intersection between source cell $i$ and target cell $j$. Let this intersection length be $\\Delta L_{ij}$:\n$$ \\Delta L_{ij} = \\text{length}([x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}] \\cap [x^{\\mathrm{t}}_{j}, x^{\\mathrm{t}}_{j+1}]) = \\max(0, \\min(x^{\\mathrm{s}}_{i+1}, x^{\\mathrm{t}}_{j+1}) - \\max(x^{\\mathrm{s}}_{i}, x^{\\mathrm{t}}_{j})) $$\nThe formula for the target cell average becomes:\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\left( \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}} \\right) \\bar{q}^{\\mathrm{s}}_{i} $$\nThis is a linear transformation from the source vector $\\bar{\\mathbf{q}}^{\\mathrm{s}}$ to the target vector $\\bar{\\mathbf{q}}^{\\mathrm{t}}$, $\\bar{\\mathbf{q}}^{\\mathrm{t}} = M \\bar{\\mathbf{q}}^{\\mathrm{s}}$, where the transfer matrix $M$ has entries $M_{ji} = \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}$.\n\n**Conservation Analysis**: Conservation requires that the total integral of the quantity is preserved, i.e., $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} L^{\\mathrm{s}}_{i}$.\nStarting with the left-hand side:\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{j=0}^{N_{\\mathrm{t}}-1} L^{\\mathrm{t}}_{j} \\left( \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\Delta L_{ij} \\right) = \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\Delta L_{ij} $$\nSwapping the order of summation:\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\left( \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij} \\right) $$\nThe inner sum, $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij}$, is the sum of lengths of intersections of source cell $i$ with all target cells. Since the target mesh covers the entire domain $[0, 1]$, this sum is precisely the length of the source cell $i$, i.e., $\\sum_{j=0}^{N_{\\mathrm{t}}-1} \\Delta L_{ij} = L^{\\mathrm{s}}_{i}$. Thus:\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} L^{\\mathrm{s}}_{i} $$\nThe operator is therefore conservative by construction.\n\n**Boundedness Analysis**: Boundedness requires $\\min_{j} \\bar{q}^{\\mathrm{t}}_{j} \\ge \\min_{i} \\bar{q}^{\\mathrm{s}}_{i}$ and $\\max_{j} \\bar{q}^{\\mathrm{t}}_{j} \\le \\max_{i} \\bar{q}^{\\mathrm{s}}_{i}$.\nThe formula $\\bar{q}^{\\mathrm{t}}_{j} = \\sum_{i=0}^{N_{\\mathrm{s}}-1} (\\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}) \\bar{q}^{\\mathrm{s}}_{i}$ expresses $\\bar{q}^{\\mathrm{t}}_{j}$ as a weighted average of the source values $\\bar{q}^{\\mathrm{s}}_{i}$. The weights are $w_{i} = \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}}$.\nThese weights are non-negative, since $\\Delta L_{ij} \\ge 0$ and $L^{\\mathrm{t}}_{j} > 0$.\nThe sum of the weights for a given target cell $j$ is:\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\frac{\\Delta L_{ij}}{L^{\\mathrm{t}}_{j}} = \\frac{1}{L^{\\mathrm{t}}_{j}} \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\Delta L_{ij} $$\nThe sum $\\sum_{i} \\Delta L_{ij}$ is the sum of lengths of intersections of target cell $j$ with all source cells, which equals the length of target cell $j$, $L^{\\mathrm{t}}_{j}$. So, $\\sum_{i=0}^{N_{\\mathrm{s}}-1} w_{i} = \\frac{L^{\\mathrm{t}}_{j}}{L^{\\mathrm{t}}_{j}} = 1$.\nSince $\\bar{q}^{\\mathrm{t}}_{j}$ is a convex combination of the values $\\bar{q}^{\\mathrm{s}}_{i}$ (non-negative weights summing to unity), its value must be bounded by the minimum and maximum of the $\\bar{q}^{\\mathrm{s}}_{i}$ values. This property guarantees that the operator is bounded.\n\n**2. Non-Conservative Operator (Nearest Cell-Center Sampling)**\n\nThis operator is defined by a direct value assignment. For each target cell $j$, we first compute its center coordinate $c^{\\mathrm{t}}_{j} = \\frac{1}{2}(x^{\\mathrm{t}}_{j} + x^{\\mathrm{t}}_{j+1})$. We then find the unique source cell $i$ that contains this point, i.e., $x^{\\mathrm{s}}_{i} \\le c^{\\mathrm{t}}_{j}  x^{\\mathrm{s}}_{i+1}$ (or $x^{\\mathrm{s}}_{i} \\le c^{\\mathrm{t}}_{j} \\le x^{\\mathrm{s}}_{i+1}$ for the rightmost cell). The target cell average is then set to the average of that source cell:\n$$ \\bar{q}^{\\mathrm{t}}_{j} = \\bar{q}^{\\mathrm{s}}_{i} \\quad \\text{where } c^{\\mathrm{t}}_{j} \\in [x^{\\mathrm{s}}_{i}, x^{\\mathrm{s}}_{i+1}] $$\n\n**Conservation Analysis**: The total integral on the target mesh is:\n$$ \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{t}}_{j} L^{\\mathrm{t}}_{j} = \\sum_{j=0}^{N_{\\mathrm{t}}-1} \\bar{q}^{\\mathrm{s}}_{\\text{map}(j)} L^{\\mathrm{t}}_{j} $$\nwhere $\\text{map}(j)$ is the index of the source cell containing the center of target cell $j$. We can group terms by the source cell index $i$:\n$$ \\sum_{i=0}^{N_{\\mathrm{s}}-1} \\bar{q}^{\\mathrm{s}}_{i} \\left( \\sum_{j \\text{ s.t. } \\text{map}(j)=i} L^{\\mathrm{t}}_{j} \\right) $$\nThe term in the parenthesis is the sum of the lengths of all target cells whose centers fall within source cell $i$. This sum is not, in general, equal to the length of the source cell $i$, $L^{\\mathrm{s}}_{i}$. Therefore, the total integral is not preserved, and the operator is non-conservative.\n\n**Boundedness Analysis**: For any target cell $j$, the value $\\bar{q}^{\\mathrm{t}}_{j}$ is simply a copy of one of the source values $\\bar{q}^{\\mathrm{s}}_{i}$. This means the set of all target values $\\{\\bar{q}^{\\mathrm{t}}_{j}\\}_{j=0}^{N_{\\mathrm{t}}-1}$ is a subset of the set of all source values $\\{\\bar{q}^{\\mathrm{s}}_{i}\\}_{i=0}^{N_{\\mathrm{s}}-1}$. Consequently, the minimum of the target values cannot be less than the minimum of the source values, and the maximum of the target values cannot be greater than the maximum of the source values. The operator is therefore inherently bounded.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests conservative and non-conservative\n    interpolation operators between non-matching 1D meshes.\n    \"\"\"\n    test_cases = [\n        # Case A (general non-matching, smooth-to-mixed data)\n        {\n            \"s_edges\": [0.0, 0.2, 0.5, 0.7, 1.0],\n            \"t_edges\": [0.0, 0.1, 0.4, 0.6, 0.85, 1.0],\n            \"s_data\": [0.0, 1.0, -0.5, 2.0],\n        },\n        # Case B (boundary alignment, constant data)\n        {\n            \"s_edges\": [0.0, 0.3, 0.6, 1.0],\n            \"t_edges\": [0.0, 0.3, 0.8, 1.0],\n            \"s_data\": [1.0, 1.0, 1.0],\n        },\n        # Case C (extreme size ratios, oscillatory data)\n        {\n            \"s_edges\": [0.0, 0.01, 0.02, 0.5, 1.0],\n            \"t_edges\": [0.0, 0.9, 0.95, 0.975, 1.0],\n            \"s_data\": [10.0, -10.0, 0.0, 1.0],\n        }\n    ]\n\n    tolerance = 1e-12\n    all_results = []\n\n    for case in test_cases:\n        s_edges = np.array(case[\"s_edges\"], dtype=float)\n        t_edges = np.array(case[\"t_edges\"], dtype=float)\n        s_data = np.array(case[\"s_data\"], dtype=float)\n\n        s_lens = np.diff(s_edges)\n        t_lens = np.diff(t_edges)\n        \n        num_s_cells = len(s_data)\n        num_t_cells = len(t_lens)\n\n        s_integral = np.sum(s_data * s_lens)\n        s_min, s_max = np.min(s_data), np.max(s_data)\n        \n        # 1. Conservative Operator\n        \n        # Assemble transfer matrix M_ji = overlap(s_i, t_j) / L_t_j\n        transfer_matrix_cons = np.zeros((num_t_cells, num_s_cells))\n        for j in range(num_t_cells):\n            t_start, t_end = t_edges[j], t_edges[j+1]\n            for i in range(num_s_cells):\n                s_start, s_end = s_edges[i], s_edges[i+1]\n                \n                # Calculate intersection length\n                overlap = max(0.0, min(s_end, t_end) - max(s_start, t_start))\n                \n                if t_lens[j] > 0:\n                    transfer_matrix_cons[j, i] = overlap / t_lens[j]\n\n        # Apply operator\n        t_data_cons = transfer_matrix_cons @ s_data\n        \n        # Check properties for conservative operator\n        t_integral_cons = np.sum(t_data_cons * t_lens)\n        cons_is_conserved = abs(s_integral - t_integral_cons) = tolerance\n        \n        t_min_cons = np.min(t_data_cons) if t_data_cons.size > 0 else 0\n        t_max_cons = np.max(t_data_cons) if t_data_cons.size > 0 else 0\n        \n        cons_is_bounded = (t_min_cons >= s_min - tolerance) and \\\n                          (t_max_cons = s_max + tolerance)\n\n        all_results.extend([cons_is_conserved, cons_is_bounded])\n\n        # 2. Non-Conservative Operator (Nearest Cell-Center)\n        \n        t_centers = (t_edges[:-1] + t_edges[1:]) / 2.0\n        \n        # Find the index of the source cell containing each target center\n        # np.searchsorted with side='right' finds insertion points to maintain order.\n        # For a value v and array a, it finds i such that a[:i] = v  a[i:].\n        # Subtracting 1 gives the index of the interval.\n        s_indices = np.searchsorted(s_edges, t_centers, side='right') - 1\n        \n        # The above can yield -1 or num_s_cells if t_centers are outside s_edges range.\n        # Although problem states domains match, clip for robustness.\n        s_indices = np.clip(s_indices, 0, num_s_cells - 1)\n        \n        # Apply operator\n        t_data_noncons = s_data[s_indices]\n        \n        # Check properties for non-conservative operator\n        t_integral_noncons = np.sum(t_data_noncons * t_lens)\n        noncons_is_conserved = abs(s_integral - t_integral_noncons) = tolerance\n        \n        t_min_noncons = np.min(t_data_noncons) if t_data_noncons.size > 0 else 0\n        t_max_noncons = np.max(t_data_noncons) if t_data_noncons.size > 0 else 0\n        \n        noncons_is_bounded = (t_min_noncons >= s_min - tolerance) and \\\n                             (t_max_noncons = s_max + tolerance)\n                             \n        all_results.extend([noncons_is_conserved, noncons_is_bounded])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3501827"}, {"introduction": "Building on the foundational concepts, this practice shifts the focus to a realistic application within a finite volume method (FVM) framework. You will implement a common non-conservative scheme—piecewise-linear nodal interpolation—and quantify its error in a physically meaningful way as a global 'mass defect' [@problem_id:3501756]. This exercise powerfully demonstrates that even seemingly smooth and reasonable interpolation methods can violate fundamental conservation laws, leading to unphysical results in a simulation.", "problem": "You are given a one-dimensional domain and two node-centered meshes: a donor mesh and a receptor mesh, which are non-matching (different node locations and associated control volumes). You must implement a non-conservative nodal interpolation of a scalar density field from the donor nodes to the receptor nodes, then compute the resulting global mass defect, defined as the difference between the integrated mass on the receptor mesh and the integrated mass on the donor mesh. The output must be a single line aggregating results for multiple prescribed test cases.\n\nFundamental base and definitions:\n- Conservation of mass states that, for a scalar density field, total mass is preserved under physically correct coupling between fields. In one dimension, with constant cross-sectional area, the mass is defined by the integral of the density over the domain.\n- Let the domain be $\\Omega = [0,L]$ with $L$ in meters, and a constant cross-sectional area $A$ in square meters. The mass corresponding to a density field $\\rho(x)$ is\n$$\nM = \\int_{0}^{L} \\rho(x)\\, A\\, dx.\n$$\n- In node-centered Finite Volume Method (FVM), the discrete mass on a nodal mesh with nodes $\\{x_i\\}$ and associated Voronoi control volumes of length $\\{V_i\\}$ is\n$$\nM \\approx \\sum_{i} \\rho(x_i)\\, A\\, V_i,\n$$\nwhere $V_i$ are defined by half-distances to adjacent nodes:\n$$\nV_0 = \\frac{x_1 - x_0}{2}, \\quad V_i = \\frac{x_{i+1} - x_{i-1}}{2}\\text{ for interior nodes}, \\quad V_{N-1} = \\frac{x_{N-1} - x_{N-2}}{2}.\n$$\nThis definition ensures $\\sum_i V_i = L$.\n\nNon-conservative nodal interpolation:\n- Given donor nodal coordinates $\\{x^{(d)}_i\\}$ and donor nodal densities $\\{\\rho^{(d)}_i\\}$, define receptor nodal densities $\\{\\rho^{(r)}_j\\}$ by piecewise-linear interpolation on the donor mesh. For a receptor node at $x^{(r)}_j$, find indices $i$ such that $x^{(d)}_i \\le x^{(r)}_j \\le x^{(d)}_{i+1}$, and compute\n$$\n\\rho^{(r)}_j = \\alpha\\, \\rho^{(d)}_i + (1-\\alpha)\\, \\rho^{(d)}_{i+1}, \\quad \\alpha = \\frac{x^{(d)}_{i+1} - x^{(r)}_j}{x^{(d)}_{i+1} - x^{(d)}_i},\n$$\nwith the convention that if $x^{(r)}_j = x^{(d)}_i$ then $\\rho^{(r)}_j = \\rho^{(d)}_i$. This mapping is non-conservative because it does not enforce integral consistency across meshes.\n\nGlobal mass defect:\n- Compute donor mass $M^{(d)} = \\sum_i \\rho^{(d)}_i\\, A\\, V^{(d)}_i$, receptor mass $M^{(r)} = \\sum_j \\rho^{(r)}_j\\, A\\, V^{(r)}_j$, and the global mass defect\n$$\n\\Delta M = M^{(r)} - M^{(d)}.\n$$\nYou must report $\\Delta M$ in kilograms, rounded to six decimal places.\n\nAngles and units:\n- All trigonometric function arguments must be in radians.\n- Express mass defect in kilograms (kg), rounded to six decimal places.\n\nTest suite:\nFor all cases, use $L = 1$ meter and $A = 1$ square meter. Node coordinates are in meters, density in kilograms per cubic meter.\n\n- Case $1$ (smooth trigonometric field, moderately mismatched meshes):\n  - Donor nodes: $\\{0,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1\\}$.\n  - Receptor nodes: $\\{0,\\, 0.2,\\, 0.6,\\, 1\\}$.\n  - Density: $\\rho(x) = 1000 + 100 \\sin(2\\pi x)$.\n- Case $2$ (polynomial field with curvature, different uniform meshes):\n  - Donor nodes: $\\{0,\\, 0.1,\\, 0.2,\\, 0.3,\\, 0.4,\\, 0.5,\\, 0.6,\\, 0.7,\\, 0.8,\\, 0.9,\\, 1\\}$.\n  - Receptor nodes: $\\{0,\\, \\frac{1}{6},\\, \\frac{2}{6},\\, \\frac{3}{6},\\, \\frac{4}{6},\\, \\frac{5}{6},\\, 1\\}$.\n  - Density: $\\rho(x) = 800 + 50 x + 20 x^2$.\n- Case $3$ (constant field, nonuniform meshes; tests zero-defect condition):\n  - Donor nodes: $\\{0,\\, 0.1,\\, 0.4,\\, 0.9,\\, 1\\}$.\n  - Receptor nodes: $\\{0,\\, 0.05,\\, 0.2,\\, 0.8,\\, 1\\}$.\n  - Density: $\\rho(x) = 900$.\n- Case $4$ (localized Gaussian peak with clustered nodes; tests sensitivity near steep gradients):\n  - Donor nodes: $\\{0,\\, 0.3,\\, 0.31,\\, 0.9,\\, 1\\}$.\n  - Receptor nodes: $\\{0,\\, 0.295,\\, 0.305,\\, 0.92,\\, 1\\}$.\n  - Density: $\\rho(x) = 950 + 200 \\exp\\!\\left(-\\frac{(x-0.3)^2}{0.0004}\\right)$.\n\nRequired output format:\n- Your program should produce a single line of output containing the mass defects for the four test cases as a comma-separated list enclosed in square brackets, rounded to six decimal places, for example, $\\left[\\Delta M_1, \\Delta M_2, \\Delta M_3, \\Delta M_4\\right]$.", "solution": "The problem requires the implementation of a non-conservative nodal interpolation of a scalar density field between two non-matching one-dimensional meshes and the subsequent computation of the global mass defect. The procedure is grounded in the principles of numerical methods for multiphysics simulations, specifically within the context of the Finite Volume Method (FVM).\n\nThe fundamental principle is the conservation of mass. In a continuous one-dimensional domain $\\Omega = [0, L]$ with a constant cross-sectional area $A$, the total mass $M$ for a given density field $\\rho(x)$ is defined by the integral:\n$$\nM = \\int_{0}^{L} \\rho(x) A \\, dx\n$$\nIn a discrete numerical setting, this integral is approximated by a sum over finite control volumes. The problem specifies a node-centered FVM discretization. For a mesh with $N$ nodes at locations $\\{x_i\\}_{i=0}^{N-1}$, the mass is approximated as:\n$$\nM_{\\text{discrete}} \\approx \\sum_{i=0}^{N-1} \\rho(x_i) A V_i\n$$\nwhere $\\rho(x_i)$ is the density at node $i$, and $V_i$ is the length of the control volume associated with that node.\n\nThe algorithmic procedure to calculate the mass defect $\\Delta M$ involves the following steps:\n\n1.  **Donor Mass Calculation**: First, the total mass on the donor mesh is computed.\n    - Given the donor mesh nodal coordinates $\\{x^{(d)}_i\\}_{i=0}^{N_d-1}$ and the analytical density function $\\rho(x)$, the nodal densities are evaluated as $\\rho^{(d)}_i = \\rho(x^{(d)}_i)$.\n    - The control volumes $\\{V^{(d)}_i\\}$ for the donor mesh are calculated according to the specified Voronoi-like scheme:\n    $$\n    V^{(d)}_0 = \\frac{x^{(d)}_1 - x^{(d)}_0}{2}\n    $$\n    $$\n    V^{(d)}_i = \\frac{x^{(d)}_{i+1} - x^{(d)}_{i-1}}{2}, \\quad \\text{for } i \\in [1, N_d-2]\n    $$\n    $$\n    V^{(d)}_{N_d-1} = \\frac{x^{(d)}_{N_d-1} - x^{(d)}_{N_d-2}}{2}\n    $$\n    This definition ensures that the sum of all control volume lengths equals the domain length, $\\sum_{i=0}^{N_d-1} V^{(d)}_i = x^{(d)}_{N_d-1} - x^{(d)}_0 = L$.\n    - The discrete mass on the donor mesh, $M^{(d)}$, is then calculated as:\n    $$\n    M^{(d)} = A \\sum_{i=0}^{N_d-1} \\rho^{(d)}_i V^{(d)}_i\n    $$\n\n2.  **Receptor Density Interpolation**: The density field, defined by discrete values on the donor mesh, is transferred to the receptor mesh nodes.\n    - Given the receptor mesh nodal coordinates $\\{x^{(r)}_j\\}_{j=0}^{N_r-1}$, we find the corresponding density values $\\{\\rho^{(r)}_j\\}$ by piecewise-linear interpolation of the donor field.\n    - For each receptor node at $x^{(r)}_j$, we identify the adjacent donor nodes $x^{(d)}_i$ and $x^{(d)}_{i+1}$ such that $x^{(d)}_i \\le x^{(r)}_j \\le x^{(d)}_{i+1}$. The interpolated density $\\rho^{(r)}_j$ is given by:\n    $$\n    \\rho^{(r)}_j = (1-\\beta) \\rho^{(d)}_i + \\beta \\rho^{(d)}_{i+1}, \\quad \\text{where } \\beta = \\frac{x^{(r)}_j - x^{(d)}_i}{x^{(d)}_{i+1} - x^{(d)}_i}\n    $$\n    This is equivalent to the formula given in the problem statement with $\\beta = 1-\\alpha$. This type of interpolation does not inherently conserve the integral of the field, leading to a mass defect.\n\n3.  **Receptor Mass Calculation**: The total mass on the receptor mesh is computed using the newly interpolated density values.\n    - The control volumes $\\{V^{(r)}_j\\}$ for the receptor mesh are calculated using the same formulas as for the donor mesh, applied to the receptor node coordinates $\\{x^{(r)}_j\\}$.\n    - The discrete mass on the receptor mesh, $M^{(r)}$, is then:\n    $$\n    M^{(r)} = A \\sum_{j=0}^{N_r-1} \\rho^{(r)}_j V^{(r)}_j\n    $$\n\n4.  **Global Mass Defect**: Finally, the global mass defect, $\\Delta M$, is the difference between the receptor mass and the donor mass.\n    $$\n    \\Delta M = M^{(r)} - M^{(d)}\n    $$\n    A non-zero value for $\\Delta M$ indicates that the data transfer process is non-conservative. This artifact is a critical consideration in coupled multiphysics simulations, where failure to conserve quantities like mass, momentum, or energy can lead to unphysical and unstable solutions.\n\nThis procedure is systematically applied to each of the four test cases provided, using the specified meshes, density functions, and constants ($L=1$, $A=1$), to determine the mass defect for each scenario.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the global mass defect resulting from non-conservative nodal\n    interpolation between non-matching 1D meshes for a series of test cases.\n    \"\"\"\n\n    def get_control_volumes(nodes: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the node-centered control volumes for a 1D mesh.\n        \n        Args:\n            nodes: A 1D numpy array of node coordinates, sorted in increasing order.\n\n        Returns:\n            A 1D numpy array of control volume lengths.\n        \"\"\"\n        n = len(nodes)\n        if n  2:\n            # The problem definition for volumes is valid for n >= 2.\n            # Test cases all satisfy this condition.\n            return np.array([nodes[-1] - nodes[0]]) if n == 1 else np.array([])\n        \n        volumes = np.zeros(n)\n        # Boundary nodes\n        volumes[0] = (nodes[1] - nodes[0]) / 2.0\n        volumes[n-1] = (nodes[n-1] - nodes[n-2]) / 2.0\n        # Interior nodes\n        if n > 2:\n            volumes[1:-1] = (nodes[2:] - nodes[:-2]) / 2.0\n            \n        return volumes\n\n    # General parameters for all test cases\n    L = 1.0  # meter\n    A = 1.0  # square meter\n\n    # Define the test cases\n    test_cases = [\n        {\n            \"name\": \"Case 1: Trigonometric field, mismatched meshes\",\n            \"donor_nodes\": np.array([0.0, 0.25, 0.5, 0.75, 1.0]),\n            \"receptor_nodes\": np.array([0.0, 0.2, 0.6, 1.0]),\n            \"rho_func\": lambda x: 1000.0 + 100.0 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"name\": \"Case 2: Polynomial field, different uniform meshes\",\n            \"donor_nodes\": np.linspace(0.0, 1.0, 11),\n            \"receptor_nodes\": np.linspace(0.0, 1.0, 7),\n            \"rho_func\": lambda x: 800.0 + 50.0 * x + 20.0 * x**2\n        },\n        {\n            \"name\": \"Case 3: Constant field, nonuniform meshes\",\n            \"donor_nodes\": np.array([0.0, 0.1, 0.4, 0.9, 1.0]),\n            \"receptor_nodes\": np.array([0.0, 0.05, 0.2, 0.8, 1.0]),\n            \"rho_func\": lambda x: 900.0 + 0.0 * x # Ensure it works on arrays\n        },\n        {\n            \"name\": \"Case 4: Gaussian peak, clustered nodes\",\n            \"donor_nodes\": np.array([0.0, 0.3, 0.31, 0.9, 1.0]),\n            \"receptor_nodes\": np.array([0.0, 0.295, 0.305, 0.92, 1.0]),\n            \"rho_func\": lambda x: 950.0 + 200.0 * np.exp(-(x - 0.3)**2 / 0.0004)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract case data\n        donor_x = case[\"donor_nodes\"]\n        receptor_x = case[\"receptor_nodes\"]\n        rho_func = case[\"rho_func\"]\n\n        # 1. Calculate donor mass\n        donor_rho = rho_func(donor_x)\n        donor_v = get_control_volumes(donor_x)\n        mass_d = A * np.sum(donor_rho * donor_v)\n\n        # 2. Interpolate densities to receptor nodes\n        # np.interp performs piecewise-linear interpolation, as required.\n        receptor_rho = np.interp(receptor_x, donor_x, donor_rho)\n\n        # 3. Calculate receptor mass\n        receptor_v = get_control_volumes(receptor_x)\n        mass_r = A * np.sum(receptor_rho * receptor_v)\n\n        # 4. Compute mass defect and store result\n        delta_m = mass_r - mass_d\n        results.append(delta_m)\n\n    # Format the final output string as specified, rounding to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3501756"}, {"introduction": "Real-world simulations often involve sharp interfaces or discontinuities, which pose a significant challenge for data interpolation. This advanced exercise explores the behavior of different transfer schemes when faced with a discontinuous field, where high-order methods can introduce spurious oscillations (Gibbs phenomenon) [@problem_id:3501733]. You will compare a non-conservative spline interpolation against a sophisticated, conservative method that uses a slope limiter to ensure monotonicity, providing insight into how to design robust schemes that prevent unphysical oscillations while strictly preserving the mapped quantity.", "problem": "Consider one-dimensional data transfer across a non-matching interface between two computational meshes in a multiphysics coupled simulation. Let the physical domain be the closed interval $[0,1]$. A source mesh partitions $[0,1]$ into $N_s$ cells with edges $\\{x^s_0, x^s_1, \\dots, x^s_{N_s}\\}$, $x^s_0 = 0$, $x^s_{N_s} = 1$, and a target mesh partitions $[0,1]$ into $N_t$ cells with edges $\\{x^t_0, x^t_1, \\dots, x^t_{N_t}\\}$, $x^t_0 = 0$, $x^t_{N_t} = 1$. Denote source cell $i$ by $[x^s_i, x^s_{i+1}]$ and target cell $j$ by $[x^t_j, x^t_{j+1}]$. Define source cell centers $c^s_i = \\frac{1}{2}(x^s_i + x^s_{i+1})$ and target cell centers $c^t_j = \\frac{1}{2}(x^t_j + x^t_{j+1})$, and cell lengths $\\Delta x^s_i = x^s_{i+1} - x^s_i$, $\\Delta x^t_j = x^t_{j+1} - x^t_j$.\n\nThe known source field is specified as cell averages $\\bar{u}^s_i$, interpreted as the average of an underlying scalar field $u(x)$ over each source cell:\n$$\n\\bar{u}^s_i = \\frac{1}{\\Delta x^s_i} \\int_{x^s_i}^{x^s_{i+1}} u(x)\\,dx.\n$$\nFor this problem, let $u(x)$ be a unit Heaviside step located at position $x_\\star \\in (0,1)$, that is, $u(x) = 0$ for $x  x_\\star$ and $u(x) = 1$ for $x \\ge x_\\star$.\n\nTwo distinct data transfer methods must be implemented:\n\n1. A non-conservative high-order interpolation method that maps $\\bar{u}^s_i$ defined at the source centers $c^s_i$ to pointwise values $v^t_j$ at the target centers $c^t_j$ using a natural cubic spline $S(x)$ fit to the data $\\{(c^s_i, \\bar{u}^s_i)\\}$. The mapped target values are $v^t_j = S(c^t_j)$. Treat $v^t_j$ as the target cell averages for the purpose of diagnostics. This method is expected to produce Gibbs-type oscillations near the discontinuity at $x_\\star$ and is not integral-conservative.\n\n2. A conservative monotonicity-preserving remap using piecewise linear reconstruction with the minimum-modulus (minmod) slope limiter. Define limited slopes $s_i$ at each source cell center by\n$$\ns_i = \\operatorname{minmod}\\left(\\frac{\\bar{u}^s_i - \\bar{u}^s_{i-1}}{c^s_i - c^s_{i-1}},\\; \\frac{\\bar{u}^s_{i+1} - \\bar{u}^s_i}{c^s_{i+1} - c^s_i}\\right),\n$$\nwith boundary slopes $s_0 = 0$ and $s_{N_s-1} = 0$, and where the minimum-modulus function is\n$$\n\\operatorname{minmod}(a,b) = \\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } a\\,b > 0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nReconstruct in each source cell $i$ a linear profile\n$$\nu_i(x) = \\bar{u}^s_i + s_i \\left(x - c^s_i\\right), \\quad x \\in [x^s_i, x^s_{i+1}],\n$$\nand define the target cell averages by exact overlap integration of the reconstructed source profiles:\n$$\n\\bar{u}^t_j = \\frac{1}{\\Delta x^t_j} \\sum_{i=0}^{N_s-1} \\int_{\\max(x^t_j, x^s_i)}^{\\min(x^t_{j+1}, x^s_{i+1})} u_i(x)\\,dx,\n$$\nwith the convention that the integral over an empty interval is zero. This method is integral-conservative by construction and, due to the minmod limiter, does not create new extrema and thus avoids Gibbs-type oscillations.\n\nDiagnostics to quantify interface oscillations and conservation must be computed for both methods:\n\n- Discrete integral (total mass) on the source mesh:\n$$\nM_s = \\sum_{i=0}^{N_s-1} \\bar{u}^s_i \\,\\Delta x^s_i.\n$$\n- Discrete integral on the target mesh for the non-conservative method:\n$$\nM_t^{\\mathrm{nc}} = \\sum_{j=0}^{N_t-1} v^t_j \\,\\Delta x^t_j,\n$$\nand for the conservative method:\n$$\nM_t^{\\mathrm{c}} = \\sum_{j=0}^{N_t-1} \\bar{u}^t_j \\,\\Delta x^t_j.\n$$\nReport the absolute conservation errors $E^{\\mathrm{nc}} = |M_t^{\\mathrm{nc}} - M_s|$ and $E^{\\mathrm{c}} = |M_t^{\\mathrm{c}} - M_s|$.\n\n- Oscillation amplitude (overshoot violation) near the interface quantified as follows. For each target center $c^t_j$, find the index $i^\\star$ of the nearest source center, and define the local source envelope\n$$\nm_j^- = \\min\\{\\bar{u}^s_{i^\\star-1}, \\bar{u}^s_{i^\\star}, \\bar{u}^s_{i^\\star+1}\\}, \\quad m_j^+ = \\max\\{\\bar{u}^s_{i^\\star-1}, \\bar{u}^s_{i^\\star}, \\bar{u}^s_{i^\\star+1}\\},\n$$\nwith indices clamped to the valid range. For the non-conservative method, the local violation is\n$$\n\\delta^{\\mathrm{nc}}_j = \\max\\left(0,\\; v^t_j - m_j^+,\\; m_j^- - v^t_j\\right),\n$$\nand for the conservative method, replace $v^t_j$ by $\\bar{u}^t_j$ to obtain $\\delta^{\\mathrm{c}}_j$. Report the oscillation amplitudes $A^{\\mathrm{nc}} = \\max_j \\delta^{\\mathrm{nc}}_j$ and $A^{\\mathrm{c}} = \\max_j \\delta^{\\mathrm{c}}_j$.\n\n- Discrete Total Variation (TV) defined for a sequence $\\{w_k\\}$ by\n$$\n\\operatorname{TV}(\\{w_k\\}) = \\sum_{k=1}^{K-1} |w_k - w_{k-1}|.\n$$\nCompute $\\operatorname{TV}_s = \\operatorname{TV}(\\{\\bar{u}^s_i\\}_{i=0}^{N_s-1})$, $\\operatorname{TV}_t^{\\mathrm{nc}} = \\operatorname{TV}(\\{v^t_j\\}_{j=0}^{N_t-1})$, and $\\operatorname{TV}_t^{\\mathrm{c}} = \\operatorname{TV}(\\{\\bar{u}^t_j\\}_{j=0}^{N_t-1})$. Report TV increases $\\Delta \\operatorname{TV}^{\\mathrm{nc}} = \\operatorname{TV}_t^{\\mathrm{nc}} - \\operatorname{TV}_s$ and $\\Delta \\operatorname{TV}^{\\mathrm{c}} = \\operatorname{TV}_t^{\\mathrm{c}} - \\operatorname{TV}_s$.\n\n- Monotonicity preservation booleans $B^{\\mathrm{nc}}$ and $B^{\\mathrm{c}}$ indicating whether $A^{\\mathrm{nc}} = 0$ and $A^{\\mathrm{c}} = 0$, respectively, within a numerical tolerance.\n\nImplement the above for the following test suite (each case specifies source mesh, target mesh, and $x_\\star$):\n\n- Case $1$ (uniform non-matching meshes, interface at mid-domain): Source mesh uniform with $N_s = 16$; target mesh uniform with $N_t = 21$; step location $x_\\star = 0.5$.\n\n- Case $2$ (nearly checkerboard non-matching meshes, off-center interface): Source mesh with alternating cell lengths pattern $[0.03, 0.07]$ repeated to fill $[0,1]$, trimming the final cell to end exactly at $1$; target mesh with alternating pattern $[0.07, 0.03]$ repeated and trimmed similarly; step location $x_\\star = 0.31$.\n\n- Case $3$ (uniform meshes, interface near boundary): Source mesh uniform with $N_s = 10$; target mesh uniform with $N_t = 12$; step location $x_\\star = 0.05$.\n\nFor each case, compute and return the list\n$$\n\\left[ A^{\\mathrm{nc}},\\; E^{\\mathrm{nc}},\\; \\Delta \\operatorname{TV}^{\\mathrm{nc}},\\; B^{\\mathrm{nc}},\\; A^{\\mathrm{c}},\\; E^{\\mathrm{c}},\\; \\Delta \\operatorname{TV}^{\\mathrm{c}},\\; B^{\\mathrm{c}} \\right].\n$$\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets (for example, \"[[c1_result1,c1_result2,...],[c2_result1,c2_result2,...],[c3_result1,c3_result2,...]]\"). All reported quantities are dimensionless real numbers or booleans; no physical units are required. No user input is needed; all parameters are predetermined as above.", "solution": "The problem requires the implementation and comparison of two data transfer methods between non-matching one-dimensional meshes: a non-conservative cubic spline interpolation and a conservative, monotonicity-preserving piecewise linear remap. The performance of these methods will be evaluated on a discontinuous test case (a Heaviside step function) using a suite of diagnostics measuring conservation error, spurious oscillations, and total variation.\n\nFirst, we establish the computational framework. The domain is the interval $[0, 1]$. A source mesh is defined by $N_s+1$ edges $\\{x^s_i\\}_{i=0}^{N_s}$ with $x^s_0=0$ and $x^s_{N_s}=1$, forming $N_s$ cells. Similarly, a target mesh is defined by $N_t+1$ edges $\\{x^t_j\\}_{j=0}^{N_t}$. The source cell $i$ is $[x^s_i, x^s_{i+1}]$ with length $\\Delta x^s_i = x^s_{i+1} - x^s_i$ and center $c^s_i = (x^s_i + x^s_{i+1}) / 2$. Correspondingly, target cell $j$ is $[x^t_j, x^t_{j+1}]$ with length $\\Delta x^t_j$ and center $c^t_j$.\n\nThe underlying data field is a unit Heaviside step function located at $x_\\star \\in (0,1)$:\n$$\nU(x) = \\begin{cases} 0  x  x_\\star \\\\ 1  x \\ge x_\\star \\end{cases}\n$$\nThe input to our mapping algorithms is not the continuous function $U(x)$, but its cell-average values over the source mesh, $\\bar{u}^s_i$. These are calculated by integrating $U(x)$ over each source cell:\n$$\n\\bar{u}^s_i = \\frac{1}{\\Delta x^s_i} \\int_{x^s_i}^{x^s_{i+1}} U(x)\\,dx = \\frac{\\max(0, x^s_{i+1} - \\max(x^s_i, x_\\star))}{\\Delta x^s_i}\n$$\nFor any cell $[x^s_i, x^s_{i+1}]$ entirely to the left of $x_\\star$ (i.e., $x^s_{i+1} \\le x_\\star$), $\\bar{u}^s_i=0$. For any cell entirely to the right (i.e., $x^s_i \\ge x_\\star$), $\\bar{u}^s_i=1$. For the single cell that contains $x_\\star$, so that $x^s_i  x_\\star  x^s_{i+1}$, the average value is $\\bar{u}^s_i = (x^s_{i+1}-x_\\star)/\\Delta x^s_i$, which lies strictly between $0$ and $1$.\n\nThe first transfer method is a **non-conservative, high-order interpolation**. We construct a natural cubic spline, denoted $S(x)$, that interpolates the source data pairs $\\{(c^s_i, \\bar{u}^s_i)\\}_{i=0}^{N_s-1}$. A natural spline is defined by the condition that its second derivatives at the endpoints are zero, i.e., $S''(c^s_0)=0$ and $S''(c^s_{N_s-1})=0$. This choice is standard when no other boundary information is known. The data are then transferred to the target mesh by evaluating the spline at the target cell centers:\n$$\nv^t_j = S(c^t_j)\n$$\nFor diagnostic purposes, these pointwise values $v^t_j$ are treated as cell averages for the target mesh. High-order interpolation is known to capture smooth functions accurately but often introduces spurious oscillations (Gibbs phenomenon) near discontinuities, and it does not typically conserve integral quantities.\n\nThe second method is a **conservative, monotonicity-preserving remap**. This method is constructed to conserve the total integral of the quantity and to prevent the creation of new oscillations. It consists of three steps: reconstruction, integration, and averaging. First, a piecewise linear representation of the data, $u_i(x)$, is reconstructed in each source cell $i$:\n$$\nu_i(x) = \\bar{u}^s_i + s_i (x - c^s_i) \\quad \\text{for } x \\in [x^s_i, x^s_{i+1}]\n$$\nTo ensure monotonicity, the slope $s_i$ is calculated using the minimum-modulus (minmod) limiter, which selects the slope of smallest magnitude between the centered-difference slopes to the left and right, or zero if they have opposite signs.\n$$\ns_i = \\operatorname{minmod}\\left(\\frac{\\bar{u}^s_i - \\bar{u}^s_{i-1}}{c^s_i - c^s_{i-1}}, \\frac{\\bar{u}^s_{i+1} - \\bar{u}^s_i}{c^s_{i+1} - c^s_i}\\right) \\quad \\text{for } i \\in [1, N_s-2]\n$$\nwith boundary slopes $s_0 = 0$ and $s_{N_s-1} = 0$. The minmod function is defined as $\\operatorname{minmod}(a,b) = \\operatorname{sign}(a)\\min(|a|, |b|)$ if $ab>0$, and $0$ otherwise. This reconstruction ensures that no new local extrema are created.\n\nNext, the target cell averages $\\bar{u}^t_j$ are obtained by integrating this piecewise linear source reconstruction over each target cell. This is achieved through exact integration over the intersection of each source cell $i$ and target cell $j$:\n$$\n\\bar{u}^t_j = \\frac{1}{\\Delta x^t_j} \\sum_{i=0}^{N_s-1} \\int_{x_\\text{start}}^{x_\\text{end}} u_i(x)\\,dx, \\quad \\text{where } [x_\\text{start}, x_\\text{end}] = [x^t_j, x^t_{j+1}] \\cap [x^s_i, x^s_{i+1}]\n$$\nThe integral of the linear function $u_i(x)$ over an interval $[a,b]$ is given by $[(\\bar{u}^s_i - s_i c^s_i)x + \\frac{1}{2}s_i x^2]_a^b$. Summing these integral contributions over all source cells $i$ for a given target cell $j$ and dividing by the target cell length $\\Delta x^t_j$ completes the conservative transfer. By construction, this method ensures $\\sum_j \\bar{u}^t_j \\Delta x^t_j = \\sum_i \\bar{u}^s_i \\Delta x^s_i$ up to machine precision.\n\nFinally, we compute several diagnostics to quantify the performance.\n- The **absolute conservation errors**, $E^{\\mathrm{nc}} = |M_t^{\\mathrm{nc}} - M_s|$ and $E^{\\mathrm{c}} = |M_t^{\\mathrm{c}} - M_s|$, measure the change in the total integrated quantity, where $M_s = \\sum_i \\bar{u}^s_i \\Delta x^s_i$ and $M_t = \\sum_j \\bar{u}^t_j \\Delta x^t_j$ (using $v^t_j$ for the non-conservative case). We expect $E^{\\mathrm{c}} \\approx 0$.\n- The **oscillation amplitudes**, $A^{\\mathrm{nc}}$ and $A^{\\mathrm{c}}$, measure the degree to which the mapped values violate the local bounds of the source data. For each target cell $j$, a local source envelope $[m_j^-, m_j^+]$ is determined from the minimum and maximum of the source data in the neighborhood of the target cell center. The violation is the amount by which a target value exceeds this envelope. $A$ is the maximum violation across all target cells. We expect $A^{\\mathrm{c}} = 0$, indicating monotonicity, while $A^{\\mathrm{nc}} > 0$. The corresponding booleans $B^{\\mathrm{c}}$ and $B^{\\mathrm{nc}}$ formalize this check.\n- The **change in total variation (TV)**, $\\Delta\\operatorname{TV} = \\operatorname{TV}(\\text{target data}) - \\operatorname{TV}(\\text{source data})$, where $\\operatorname{TV}(\\{w_k\\}) = \\sum_{k} |w_{k+1} - w_k|$. Monotonicity-preserving schemes are expected to be non-increasing in total variation, so we expect $\\Delta\\operatorname{TV}^{\\mathrm{c}} \\le 0$, while the oscillatory spline method will likely increase TV, so $\\Delta\\operatorname{TV}^{\\mathrm{nc}} > 0$.\n\nBy applying these methods and diagnostics to the specified test cases, we can quantitatively demonstrate the fundamental trade-offs between high-order accuracy and the preservation of physical principles like conservation and monotonicity.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef generate_mesh(N=None, pattern=None):\n    \"\"\"Generates a mesh on [0,1] either uniformly or from a pattern.\"\"\"\n    if N is not None:  # Uniform mesh\n        edges = np.linspace(0, 1, N + 1)\n    elif pattern is not None:  # Pattern-based mesh\n        edges = [0.0]\n        current_x = 0.0\n        i = 0\n        while current_x  1.0 - 1e-9: # Loop until we are at or past 1.0\n            current_x += pattern[i % len(pattern)]\n            edges.append(current_x)\n            i += 1\n        edges[-1] = 1.0  # Trim the last edge to be exactly 1.0\n        edges = np.array(edges)\n    else:\n        raise ValueError(\"Either N or pattern must be provided.\")\n    \n    centers = 0.5 * (edges[:-1] + edges[1:])\n    lengths = edges[1:] - edges[:-1]\n    return edges, centers, lengths\n\ndef minmod(a, b):\n    \"\"\"The minmod slope limiter function.\"\"\"\n    return np.sign(a) * np.minimum(np.abs(a), np.abs(b)) * (np.sign(a) == np.sign(b))\n\ndef calculate_tv(data):\n    \"\"\"Computes the total variation of a 1D array.\"\"\"\n    return np.sum(np.abs(np.diff(data)))\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for data transfer between non-matching meshes.\n    \"\"\"\n    source_mesh_def, target_mesh_def, x_star = case_params\n    \n    # 1. Generate meshes and source data\n    x_s, c_s, dx_s = generate_mesh(**source_mesh_def)\n    x_t, c_t, dx_t = generate_mesh(**target_mesh_def)\n    N_s = len(c_s)\n    N_t = len(c_t)\n\n    # Calculate source cell-average data from Heaviside step function\n    u_s_bar = np.maximum(0, x_s[1:] - np.maximum(x_s[:-1], x_star)) / dx_s\n\n    # 2. Method 1: Non-conservative spline interpolation\n    spline = CubicSpline(c_s, u_s_bar, bc_type='natural')\n    v_t = spline(c_t)\n\n    # 3. Method 2: Conservative piecewise linear remap\n    # 3.1. Calculate limited slopes\n    s = np.zeros(N_s)\n    # Slopes are zero for cells not adjacent to the discontinuity\n    disc_idx = np.where( (u_s_bar > 0)  (u_s_bar  1) )[0]\n    if len(disc_idx) > 0:\n        idx = disc_idx[0]\n        # Calculate slopes only around the discontinuity.\n        for i in range(max(1, idx - 1), min(N_s - 1, idx + 2)):\n            slope_L = (u_s_bar[i] - u_s_bar[i-1]) / (c_s[i] - c_s[i-1])\n            slope_R = (u_s_bar[i+1] - u_s_bar[i]) / (c_s[i+1] - c_s[i])\n            s[i] = minmod(slope_L, slope_R)\n\n    # 3.2. Overlap integration\n    u_t_bar = np.zeros(N_t)\n    for j in range(N_t):\n        total_integral = 0.0\n        for i in range(N_s):\n            # Find intersection of source cell i and target cell j\n            x_start = np.maximum(x_t[j], x_s[i])\n            x_end = np.minimum(x_t[j+1], x_s[i+1])\n\n            if x_start  x_end:\n                # Indefinite integral: I(x) = (u_bar - s*c)*x + 0.5*s*x^2\n                const_term = u_s_bar[i] - s[i] * c_s[i]\n                integral_val = (const_term * (x_end - x_start) + \n                                0.5 * s[i] * (x_end**2 - x_start**2))\n                total_integral += integral_val\n        u_t_bar[j] = total_integral / dx_t[j]\n\n    # 4. Diagnostics\n    tol = 1e-12\n    \n    # 4.1. Conservation Error\n    M_s = np.sum(u_s_bar * dx_s)\n    M_t_nc = np.sum(v_t * dx_t)\n    M_t_c = np.sum(u_t_bar * dx_t)\n    \n    E_nc = np.abs(M_t_nc - M_s)\n    E_c = np.abs(M_t_c - M_s)\n\n    # 4.2. Oscillation Amplitude\n    # Find nearest source center for each target center\n    dist_matrix = np.abs(c_s.reshape(-1, 1) - c_t.reshape(1, -1))\n    i_star_indices = np.argmin(dist_matrix, axis=0)\n    \n    delta_nc, delta_c = np.zeros(N_t), np.zeros(N_t)\n    for j in range(N_t):\n        i_star = i_star_indices[j]\n        # Clamp indices to valid range\n        idx_min = max(0, i_star - 1)\n        idx_max = min(N_s - 1, i_star + 1)\n        local_u_s = u_s_bar[idx_min : idx_max + 1]\n        \n        m_j_minus = np.min(local_u_s)\n        m_j_plus = np.max(local_u_s)\n        \n        delta_nc[j] = np.max([0, v_t[j] - m_j_plus, m_j_minus - v_t[j]])\n        delta_c[j] = np.max([0, u_t_bar[j] - m_j_plus, m_j_minus - u_t_bar[j]])\n        \n    A_nc = np.max(delta_nc)\n    A_c = np.max(delta_c)\n\n    # 4.3. Total Variation\n    TV_s = calculate_tv(u_s_bar)\n    TV_t_nc = calculate_tv(v_t)\n    TV_t_c = calculate_tv(u_t_bar)\n    \n    dTV_nc = TV_t_nc - TV_s\n    dTV_c = TV_t_c - TV_s\n\n    # 4.4. Monotonicity Booleans\n    B_nc = (A_nc  tol)\n    B_c = (A_c  tol)\n    \n    return [A_nc, E_nc, dTV_nc, B_nc, A_c, E_c, dTV_c, B_c]\n\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: Uniform non-matching, mid-domain interface\n        ({'N': 16}, {'N': 21}, 0.5),\n        # Case 2: Checkerboard non-matching, off-center interface\n        ({'pattern': [0.03, 0.07]}, {'pattern': [0.07, 0.03]}, 0.31),\n        # Case 3: Uniform, interface near boundary\n        ({'N': 10}, {'N': 12}, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(run_case(case))\n    \n    # Format the output as specified: [[r1,r2,...],[r1,r2,...],...]\n    str_results = []\n    for res_list in results:\n        # Format each item in the sublist to string\n        # The problem does not specify float precision, so use default str representation\n        # Booleans will be 'True' or 'False'\n        str_items = [str(item) for item in res_list]\n        str_results.append(f\"[{','.join(str_items)}]\")\n        \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```", "id": "3501733"}]}