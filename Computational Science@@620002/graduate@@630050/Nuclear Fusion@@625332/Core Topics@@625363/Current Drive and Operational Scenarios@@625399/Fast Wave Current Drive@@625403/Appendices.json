{"hands_on_practices": [{"introduction": "At its core, driving a current with radio-frequency waves is about transferring momentum from the waves to the plasma electrons. This exercise provides a foundational understanding of this process by employing a simplified fluid model of the electron population. You will analyze the steady-state momentum balance, weighing the forward push from the fast wave against the collisional drag from ions and the influence of a co-existing inductive electric field, which also drives current ohmically. By solving this force balance, you will derive and quantify the non-inductive current fraction, a critical metric for assessing the performance of any current drive system [@problem_id:3699485].", "problem": "A homogeneous, axisymmetric tokamak plasma is sustained by a Fast Wave (FW) in the Ion Cyclotron Range of Frequencies (ICRF) that drives current via electron Landau damping, while a finite inductive loop electric field also acts. Consider a steady-state slab model of the electron fluid along the magnetic field. The Radio Frequency (RF) wave has parallel wavenumber $k_{\\parallel}$ and angular frequency $\\omega$, and deposits a power density $P_{\\text{abs}}$ into the electrons. The inductive loop electric field is $E_{\\parallel}^{\\text{loop}}$. Assume the electron parallel momentum balance is between the loop electric field, electron-ion collisional friction characterized by the electron-ion collision frequency $\\nu_{ei}$, and the RF deposition of parallel momentum density $S_{\\text{RF}}$.\n\nUse the following foundational facts:\n- The steady-state electron parallel momentum equation is $0 = - e n_{e} E_{\\parallel}^{\\text{loop}} - m_{e} n_{e} \\nu_{ei} u_{e} + S_{\\text{RF}}$, where $u_{e}$ is the electron parallel flow velocity, $e$ is the elementary charge, $m_{e}$ is the electron mass, and $n_{e}$ is the electron number density.\n- The total current density is $J = - e n_{e} u_{e}$.\n- The collisional electron-ion frequency in a fully ionized plasma with singly charged ions is $\\nu_{ei} = \\dfrac{4 \\sqrt{2\\pi}\\, n_{e} e^{4} \\ln\\Lambda}{3 \\left(4\\pi \\epsilon_{0}\\right)^{2} m_{e}^{1/2} \\left(k_{B} T_{e}\\right)^{3/2}}$, where $\\epsilon_{0}$ is the vacuum permittivity, $k_{B}$ is the Boltzmann constant, $T_{e}$ is the electron temperature, and $\\ln\\Lambda$ is the Coulomb logarithm.\n- The RF-deposited parallel momentum density is related to the absorbed power density by $S_{\\text{RF}} = \\dfrac{k_{\\parallel}}{\\omega} P_{\\text{abs}}$ (the ratio of parallel momentum to energy carried by the wave quanta).\n\nDefine the noninductive current density contribution due to the RF momentum deposition by $J_{\\text{RF}} \\equiv J\\big|_{E_{\\parallel}^{\\text{loop}}=0}$ and the total current density by $J$. The net noninductive current fraction is $f_{\\text{NI}} \\equiv \\dfrac{J_{\\text{RF}}}{J}$. Using the data below, derive an analytic expression for $f_{\\text{NI}}$ from the above principles and compute its numerical value.\n\nGiven parameters and constants:\n- $n_{e} = 5.0 \\times 10^{19}\\ \\text{m}^{-3}$, $T_{e} = 5.0\\ \\text{keV}$, $\\ln\\Lambda = 17$,\n- $E_{\\parallel}^{\\text{loop}} = 0.050\\ \\text{V/m}$,\n- $P_{\\text{abs}} = 1.5 \\times 10^{6}\\ \\text{W/m}^{3}$,\n- $k_{\\parallel} = -25\\ \\text{m}^{-1}$, $\\omega = 2\\pi \\times 80\\ \\text{MHz}$,\n- $e = 1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C}$, $m_{e} = 9.109\\,383\\,56 \\times 10^{-31}\\ \\text{kg}$,\n- $\\epsilon_{0} = 8.854\\,187\\,817 \\times 10^{-12}\\ \\text{F/m}$, $k_{B} = 1.380\\,649 \\times 10^{-23}\\ \\text{J/K}$.\n\nExpress the final answer for $f_{\\text{NI}}$ as a decimal number without a percentage sign. Round your answer to four significant figures.", "solution": "The problem requires the derivation of an analytical expression for the net noninductive current fraction, $f_{\\text{NI}}$, and the computation of its numerical value. The definition provided is $f_{\\text{NI}} \\equiv \\dfrac{J_{\\text{RF}}}{J}$, where $J$ is the total parallel current density and $J_{\\text{RF}}$ is the noninductive current density.\n\nThe starting point is the provided steady-state electron parallel momentum balance equation for the electron fluid in a slab model:\n$$0 = - e n_{e} E_{\\parallel}^{\\text{loop}} - m_{e} n_{e} \\nu_{ei} u_{e} + S_{\\text{RF}}$$\nIn this equation, the terms represent force densities on the electron fluid: the first term, $- e n_{e} E_{\\parallel}^{\\text{loop}}$, is the force from the inductive electric field; the second term, $- m_{e} n_{e} \\nu_{ei} u_{e}$, is the collisional friction (drag) force from ions, opposing the electron parallel flow velocity $u_{e}$; and the third term, $S_{\\text{RF}}$, is the parallel momentum density deposited by the radio-frequency (RF) wave. The variables are the elementary charge $e$, electron number density $n_{e}$, parallel inductive electric field $E_{\\parallel}^{\\text{loop}}$, electron mass $m_{e}$, and electron-ion collision frequency $\\nu_{ei}$.\n\nWe can rearrange the momentum equation to solve for the electron flow velocity $u_{e}$:\n$$m_{e} n_{e} \\nu_{ei} u_{e} = S_{\\text{RF}} - e n_{e} E_{\\parallel}^{\\text{loop}}$$\n$$u_{e} = \\frac{S_{\\text{RF}} - e n_{e} E_{\\parallel}^{\\text{loop}}}{m_{e} n_{e} \\nu_{ei}}$$\n\nThe total parallel current density, $J$, is produced by the motion of electrons and is defined as:\n$$J = - e n_{e} u_{e}$$\nSubstituting the expression for $u_{e}$ into the definition of $J$:\n$$J = - e n_{e} \\left( \\frac{S_{\\text{RF}} - e n_{e} E_{\\parallel}^{\\text{loop}}}{m_{e} n_{e} \\nu_{ei}} \\right)$$\n$$J = - \\frac{e S_{\\text{RF}} - e^2 n_{e} E_{\\parallel}^{\\text{loop}}}{m_{e} \\nu_{ei}} = \\frac{e^2 n_{e} E_{\\parallel}^{\\text{loop}} - e S_{\\text{RF}}}{m_{e} \\nu_{ei}}$$\nThis expression for the total current density $J$ is the sum of two components: the Ohmic current driven by the loop electric field, $J_{\\text{OH}} = \\dfrac{e^2 n_{e} E_{\\parallel}^{\\text{loop}}}{m_{e} \\nu_{ei}}$, and the current driven by the RF wave.\n\nThe problem defines the noninductive current density $J_{\\text{RF}}$ as the total current density in the absence of an inductive electric field, i.e., $J_{\\text{RF}} \\equiv J\\big|_{E_{\\parallel}^{\\text{loop}}=0}$. Applying this definition to our expression for $J$ by setting $E_{\\parallel}^{\\text{loop}} = 0$:\n$$J_{\\text{RF}} = \\frac{e^2 n_{e} (0) - e S_{\\text{RF}}}{m_{e} \\nu_{ei}} = -\\frac{e S_{\\text{RF}}}{m_{e} \\nu_{ei}}$$\nWith this, the total current can be written compactly as $J = J_{\\text{OH}} + J_{\\text{RF}}$.\n\nNow we derive the analytical expression for the net noninductive current fraction $f_{\\text{NI}}$:\n$$f_{\\text{NI}} = \\frac{J_{\\text{RF}}}{J}$$\nSubstituting the derived expressions for $J$ and $J_{\\text{RF}}$:\n$$f_{\\text{NI}} = \\frac{-\\dfrac{e S_{\\text{RF}}}{m_{e} \\nu_{ei}}}{\\dfrac{e^2 n_{e} E_{\\parallel}^{\\text{loop}} - e S_{\\text{RF}}}{m_{e} \\nu_{ei}}}$$\nThe term $m_{e} \\nu_{ei}$ in the denominator of both the numerator and the denominator cancels out. This is a significant simplification, as it means the detailed expression and value for the collision frequency $\\nu_{ei}$ are not required to determine the fraction $f_{\\text{NI}}$.\n$$f_{\\text{NI}} = \\frac{-e S_{\\text{RF}}}{e^2 n_{e} E_{\\parallel}^{\\text{loop}} - e S_{\\text{RF}}}$$\nDividing the numerator and denominator by $e$ gives:\n$$f_{\\text{NI}} = \\frac{-S_{\\text{RF}}}{e n_{e} E_{\\parallel}^{\\text{loop}} - S_{\\text{RF}}}$$\nThis is the required analytical expression for $f_{\\text{NI}}$.\n\nTo compute the numerical value, we first calculate the intermediate quantities $S_{\\text{RF}}$ and $e n_{e} E_{\\parallel}^{\\text{loop}}$ using the provided data, ensuring all values are in SI units.\nThe RF-deposited parallel momentum density $S_{\\text{RF}}$ is related to the absorbed power density $P_{\\text{abs}}$ by $S_{\\text{RF}} = \\dfrac{k_{\\parallel}}{\\omega} P_{\\text{abs}}$.\nGiven: $k_{\\parallel} = -25\\ \\text{m}^{-1}$, $\\omega = 2\\pi \\times 80\\ \\text{MHz} = 2\\pi \\times 80 \\times 10^6\\ \\text{s}^{-1}$, and $P_{\\text{abs}} = 1.5 \\times 10^{6}\\ \\text{W/m}^{3}$.\n$$S_{\\text{RF}} = \\frac{-25\\ \\text{m}^{-1}}{2\\pi \\times 80 \\times 10^6\\ \\text{s}^{-1}} (1.5 \\times 10^6\\ \\text{W/m}^3) = \\frac{-25 \\times 1.5}{160\\pi}\\ \\text{N/m}^3 \\approx -0.0746133\\ \\text{N/m}^3$$\n\nNext, we compute the force density term from the loop electric field, $e n_{e} E_{\\parallel}^{\\text{loop}}$.\nGiven: $e = 1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C}$, $n_e = 5.0 \\times 10^{19}\\ \\text{m}^{-3}$, and $E_{\\parallel}^{\\text{loop}} = 0.050\\ \\text{V/m}$.\n$$e n_{e} E_{\\parallel}^{\\text{loop}} = (1.602\\,176\\,634 \\times 10^{-19}\\ \\text{C}) (5.0 \\times 10^{19}\\ \\text{m}^{-3}) (0.050\\ \\text{V/m})$$\n$$e n_{e} E_{\\parallel}^{\\text{loop}} = (1.602\\,176\\,634 \\times 5.0 \\times 0.050)\\ \\text{N/m}^3 \\approx 0.4005442\\ \\text{N/m}^3$$\n\nNow, we substitute these numerical values into the analytical expression for $f_{\\text{NI}}$:\n$$f_{\\text{NI}} = \\frac{-S_{\\text{RF}}}{e n_{e} E_{\\parallel}^{\\text{loop}} - S_{\\text{RF}}} = \\frac{-(-0.0746133\\ \\text{N/m}^3)}{0.4005442\\ \\text{N/m}^3 - (-0.0746133\\ \\text{N/m}^3)}$$\n$$f_{\\text{NI}} = \\frac{0.0746133}{0.4005442 + 0.0746133} = \\frac{0.0746133}{0.4751575} \\approx 0.157028$$\n\nThe problem requests the final answer to be rounded to four significant figures.\n$$f_{\\text{NI}} \\approx 0.1570$$", "answer": "$$\\boxed{0.1570}$$", "id": "3699485"}, {"introduction": "While fluid models offer valuable intuition, a deeper understanding of current drive requires a kinetic approach that resolves the wave's influence on the electron velocity distribution function, $f(u)$. This practice moves beyond the fluid picture into the realm of quasilinear theory, where you will solve a simplified Fokker-Planck equation to model how waves reshape $f(u)$ to create a current-carrying \"tail\" of energetic electrons. This computational exercise specifically investigates the powerful concept of synergy, where combining Fast Waves (FW) and Lower Hybrid (LH) waves can produce a current drive efficiency far greater than the sum of its parts [@problem_id:3699495].", "problem": "You are to implement a numerical solver to quantify synergy between Fast Wave Current Drive (FWCD) and Lower Hybrid Current Drive (LHCD) using a one-dimensional, steady-state, quasilinear Fokker–Planck model along the parallel velocity coordinate. Your task is to compute a synergy factor that measures how the figure-of-merit, current-per-power, improves when the two Radio Frequency (RF) waves are applied together versus each applied alone.\n\nModel assumptions and fundamental base:\n- Start from the one-dimensional, steady-state kinetic equation for the electron distribution function $f(u)$ in the presence of linearized Coulomb collisions and quasilinear diffusion along the normalized parallel velocity $u \\doteq v_{\\parallel}/v_{te}$, where $v_{te}$ is the electron thermal speed. Normalize such that the collision frequency is a constant $\\nu = 1$ and $v_{te}^{2} = 1$. The steady-state equation along $u$ reads\n$$\n\\frac{d}{du}\\left[\\nu\\,u\\,f(u) + \\left(\\nu + D(u)\\right)\\frac{df}{du}\\right] = 0,\n$$\nwhere $D(u)$ is a nonnegative quasilinear diffusion coefficient due to RF waves.\n- Impose a zero-flux condition at the boundaries $u = \\pm u_{\\max}$, which implies that the total flux in $u$-space is zero everywhere,\n$$\n\\nu\\,u\\,f(u) + \\left(\\nu + D(u)\\right)\\frac{df}{du} = 0.\n$$\nWith the chosen normalization $\\nu = 1$, this reduces to\n$$\n\\frac{df}{du} = -\\frac{u}{1 + D(u)} f(u).\n$$\n- The solution can be written in quadrature as\n$$\nf(u) = C\\,\\exp\\left(-\\int_{0}^{u} \\frac{s}{1 + D(s)}\\,ds\\right),\n$$\nwith the normalization constant $C$ determined by $\\int_{-u_{\\max}}^{u_{\\max}} f(u)\\,du = 1$, which fixes the electron density in these normalized units.\n\nWave modeling and figures of merit:\n- Model the quasilinear diffusion coefficient for each wave as a Gaussian in the parallel velocity,\n$$\nD_{\\mathrm{FW}}(u) = A_{\\mathrm{FW}}\\,\\exp\\left(-\\frac{(u - u_{\\mathrm{FW}})^{2}}{2 w_{\\mathrm{FW}}^{2}}\\right),\\quad\nD_{\\mathrm{LH}}(u) = A_{\\mathrm{LH}}\\,\\exp\\left(-\\frac{(u - u_{\\mathrm{LH}})^{2}}{2 w_{\\mathrm{LH}}^{2}}\\right),\n$$\nwith amplitudes $A_{\\mathrm{FW}}, A_{\\mathrm{LH}} \\ge 0$, centers $u_{\\mathrm{FW}}, u_{\\mathrm{LH}} \\ge 0$, and widths $w_{\\mathrm{FW}}, w_{\\mathrm{LH}} > 0$. For combined waves, use $D_{\\mathrm{tot}}(u) = D_{\\mathrm{FW}}(u) + D_{\\mathrm{LH}}(u)$.\n- Define the dimensionless driven current (per unit density and charge, in normalized units consistent with $v_{te}=1$) as\n$$\nJ[D] \\doteq \\int_{-u_{\\max}}^{u_{\\max}} u\\, f_{D}(u)\\,du,\n$$\nwhere $f_{D}(u)$ is the steady-state solution obtained with the given $D(u)$.\n- Define a positive-definite dimensionless absorbed power for a given diffusion profile $D_{w}(u)$ acting on a steady-state distribution $f(u)$ as\n$$\nP[D_{w}; f] \\doteq \\int_{-u_{\\max}}^{u_{\\max}} D_{w}(u)\\,\\left(\\frac{df}{du}\\right)^{2}\\,du.\n$$\nFor a single-wave case, use $P[D_{\\mathrm{FW}}; f_{\\mathrm{FW}}]$ with $f_{\\mathrm{FW}}$ computed from $D_{\\mathrm{FW}}$ alone; similarly for $P[D_{\\mathrm{LH}}; f_{\\mathrm{LH}}]$. For the combined case, use $P[D_{\\mathrm{tot}}; f_{\\mathrm{tot}}]$ with $f_{\\mathrm{tot}}$ computed from $D_{\\mathrm{tot}}$.\n- Define the current-drive figure of merit for any case as\n$$\n\\Phi[D] \\doteq \\frac{J[D]}{P[D; f_{D}]},\n$$\nwith the convention that if the denominator is zero, then $\\Phi[D]$ is defined to be $0$.\n- Define the synergy factor as the improvement relative to the better of the two single-wave figures of merit,\n$$\n\\mathcal{S} \\doteq \\frac{\\Phi[D_{\\mathrm{tot}}]}{\\max\\left(\\Phi[D_{\\mathrm{FW}}],\\,\\Phi[D_{\\mathrm{LH}}]\\right)}.\n$$\nBy this definition, $\\mathcal{S} > 1$ indicates beneficial synergy, $\\mathcal{S} = 1$ indicates no synergy relative to the better single-wave case, and $\\mathcal{S}  1$ indicates degradation. All quantities are dimensionless in this normalization, so no physical unit specification is required for the outputs.\n\nDiscretization and numerical constraints:\n- Discretize $u \\in [-u_{\\max}, u_{\\max}]$ uniformly with $N_{u}$ odd, include $u=0$, and evaluate the integral in the exponent using a consistent, second-order accurate trapezoidal rule to construct $f(u)$ from the first-order ordinary differential equation. Normalize $f(u)$ by numerical quadrature so that $\\int f\\,du = 1$. Compute $df/du$ using a second-order centered finite difference in the interior and one-sided second-order differences at the endpoints. Compute all integrals by the trapezoidal rule.\n- Use the same grid and numerical operators for all cases so that ratios are meaningful.\n\nTest suite:\nFor each test case, you are given $u_{\\max}$ and $N_{u}$, and the FW and LH diffusion parameters $\\{A_{\\mathrm{FW}}, u_{\\mathrm{FW}}, w_{\\mathrm{FW}}\\}$ and $\\{A_{\\mathrm{LH}}, u_{\\mathrm{LH}}, w_{\\mathrm{LH}}\\}$. Your program must compute $\\mathcal{S}$ for each case and aggregate the results. Use the following four scientifically plausible cases that probe different regimes:\n- Case #1 (overlapping resonances, expected synergy): $u_{\\max} = 6$, $N_{u} = 2001$, $A_{\\mathrm{FW}} = 0.6$, $u_{\\mathrm{FW}} = 3.0$, $w_{\\mathrm{FW}} = 0.6$, $A_{\\mathrm{LH}} = 0.4$, $u_{\\mathrm{LH}} = 2.0$, $w_{\\mathrm{LH}} = 0.5$.\n- Case #2 (separated resonances, weak synergy): $u_{\\max} = 6$, $N_{u} = 2001$, $A_{\\mathrm{FW}} = 0.6$, $u_{\\mathrm{FW}} = 5.0$, $w_{\\mathrm{FW}} = 0.6$, $A_{\\mathrm{LH}} = 0.4$, $u_{\\mathrm{LH}} = 1.5$, $w_{\\mathrm{LH}} = 0.4$.\n- Case #3 (LH only, boundary case): $u_{\\max} = 6$, $N_{u} = 2001$, $A_{\\mathrm{FW}} = 0.0$, $u_{\\mathrm{FW}} = 3.0$, $w_{\\mathrm{FW}} = 0.6$, $A_{\\mathrm{LH}} = 0.5$, $u_{\\mathrm{LH}} = 2.2$, $w_{\\mathrm{LH}} = 0.5$.\n- Case #4 (FW dominant, small synergy): $u_{\\max} = 6$, $N_{u} = 2001$, $A_{\\mathrm{FW}} = 1.0$, $u_{\\mathrm{FW}} = 3.5$, $w_{\\mathrm{FW}} = 0.7$, $A_{\\mathrm{LH}} = 0.2$, $u_{\\mathrm{LH}} = 2.0$, $w_{\\mathrm{LH}} = 0.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the synergy factors for the four cases as a comma-separated list enclosed in square brackets (e.g., $[s_1,s_2,s_3,s_4]$), where each $s_i$ is a real number in decimal notation.", "solution": "The problem is valid. It presents a scientifically grounded, well-posed, and computationally tractable model of radio-frequency current drive synergy in fusion plasmas. All necessary equations, parameters, and numerical methods are provided, forming a complete and consistent specification for a numerical solution.\n\nThe task is to compute a synergy factor $\\mathcal{S}$ for four different physical scenarios involving Fast Wave (FW) and Lower Hybrid (LH) current drives. The solution requires the numerical evaluation of the electron distribution function, driven current, and absorbed power based on a one-dimensional, steady-state, quasilinear Fokker-Planck model.\n\nThe core of the model is the ordinary differential equation for the electron distribution function $f(u)$ in normalized parallel velocity $u$:\n$$\n\\frac{df}{du} = -\\frac{u}{1 + D(u)} f(u)\n$$\nwhere $D(u)$ is the quasilinear diffusion coefficient due to the applied radio-frequency waves. The solution to this equation is found by quadrature:\n$$\nf(u) = C\\,\\exp\\left(-\\int_{0}^{u} \\frac{s}{1 + D(s)}\\,ds\\right)\n$$\nThe constant $C$ is determined by the normalization condition $\\int_{-u_{\\max}}^{u_{\\max}} f(u)\\,du = 1$. The diffusion coefficients for the individual waves, $D_{\\mathrm{FW}}(u)$ and $D_{\\mathrm{LH}}(u)$, are given as Gaussian functions. When both waves are applied, the total diffusion coefficient is $D_{\\mathrm{tot}}(u) = D_{\\mathrm{FW}}(u) + D_{\\mathrm{LH}}(u)$.\n\nThe numerical implementation proceeds through the following steps for each case (FW only, LH only, and combined):\n\n1.  **Grid and Diffusion Coefficient Setup**: A uniform grid for the normalized velocity $u$ is established over the domain $[-u_{\\max}, u_{\\max}]$ with $N_{u}$ points. The grid spacing is $\\Delta u = 2u_{\\max}/(N_u-1)$. The diffusion coefficients $D_{\\mathrm{FW}}(u)$, $D_{\\mathrm{LH}}(u)$, and $D_{\\mathrm{tot}}(u)$ are evaluated and stored as arrays on this grid.\n\n2.  **Distribution Function Calculation**: For a given diffusion coefficient $D(u)$, the distribution function $f(u)$ is computed.\n    - First, the integrand of the exponent, $g(s) = s / (1 + D(s))$, is calculated at each grid point.\n    - The definite integral $I(u) = \\int_{0}^{u} g(s) ds$ is computed for all $u$ on the grid. This is accomplished using the trapezoidal rule, specifically with `scipy.integrate.cumulative_trapezoid`. Since the grid is constructed to include $u=0$ at index $i_{\\text{zero}}$, the integral from $0$ to $u_i$ is found by taking the cumulative integral over the entire grid and subtracting the value at $i_{\\text{zero}}$.\n    - The unnormalized distribution function is then $f_{\\text{un}}(u) = \\exp(-I(u))$.\n    - The normalization constant $C$ is found by computing the integral of $f_{\\text{un}}(u)$ over the domain $[-u_{\\max}, u_{\\max}]$ using the trapezoidal rule (`numpy.trapz`). The final, normalized distribution function is $f(u) = f_{\\text{un}}(u) / \\int f_{\\text{un}}(u) du$.\n\n3.  **Current and Power Calculation**:\n    - The dimensionless driven current $J$ is computed by the trapezoidal integration of $u f(u)$ over the domain:\n      $$\n      J = \\int_{-u_{\\max}}^{u_{\\max}} u f(u) du\n      $$\n    - The derivative of the distribution function, $df/du$, is calculated numerically as specified. A second-order centered finite difference scheme is used for interior grid points, and second-order one-sided schemes are used for the boundary points $u = \\pm u_{\\max}$.\n    - The dimensionless absorbed power $P$ is computed by the trapezoidal integration of $D(u) (df/du)^2$:\n      $$\n      P = \\int_{-u_{\\max}}^{u_{\\max}} D(u) \\left(\\frac{df}{du}\\right)^2 du\n      $$\n\n4.  **Figure of Merit and Synergy Factor**:\n    - For each case (FW, LH, tot), the figure of merit is calculated as $\\Phi = J/P$. If $P=0$, $\\Phi$ is defined as $0$. This procedure yields $\\Phi_{\\mathrm{FW}}$, $\\Phi_{\\mathrm{LH}}$, and $\\Phi_{\\mathrm{tot}}$.\n    - The final synergy factor $\\mathcal{S}$ is computed as the ratio of the combined figure of merit to the better of the two individual ones:\n      $$\n      \\mathcal{S} = \\frac{\\Phi_{\\mathrm{tot}}}{\\max(\\Phi_{\\mathrm{FW}}, \\Phi_{\\mathrm{LH}})}\n      $$\n    A special case where the denominator is zero (i.e., both $\\Phi_{\\mathrm{FW}}$ and $\\Phi_{\\mathrm{LH}}$ are zero) is handled by defining $\\mathcal{S}=1$, though this does not occur in the provided test suite. For Test Case #3 where $A_{\\mathrm{FW}}=0$, $D_{\\mathrm{FW}}=0$ and thus $\\Phi_{\\mathrm{FW}}=0$. Because $D_{\\mathrm{tot}} = D_{\\mathrm{LH}}$, it follows that $\\Phi_{\\mathrm{tot}} = \\Phi_{\\mathrm{LH}}$, correctly yielding $\\mathcal{S} = 1$.\n\nThis entire process is encapsulated in a Python script utilizing the `numpy` and `scipy` libraries, which iterates through the four specified test cases and computes the corresponding synergy factor for each. The results are then aggregated and printed in the required format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the FWCD/LHCD synergy problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Overlapping resonances, expected synergy\n        {'u_max': 6.0, 'N_u': 2001, 'A_FW': 0.6, 'u_FW': 3.0, 'w_FW': 0.6, 'A_LH': 0.4, 'u_LH': 2.0, 'w_LH': 0.5},\n        # Case 2: Separated resonances, weak synergy\n        {'u_max': 6.0, 'N_u': 2001, 'A_FW': 0.6, 'u_FW': 5.0, 'w_FW': 0.6, 'A_LH': 0.4, 'u_LH': 1.5, 'w_LH': 0.4},\n        # Case 3: LH only, boundary case\n        {'u_max': 6.0, 'N_u': 2001, 'A_FW': 0.0, 'u_FW': 3.0, 'w_FW': 0.6, 'A_LH': 0.5, 'u_LH': 2.2, 'w_LH': 0.5},\n        # Case 4: FW dominant, small synergy\n        {'u_max': 6.0, 'N_u': 2001, 'A_FW': 1.0, 'u_FW': 3.5, 'w_FW': 0.7, 'A_LH': 0.2, 'u_LH': 2.0, 'w_LH': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        synergy_factor = compute_synergy_factor(**params)\n        results.append(synergy_factor)\n    \n    # Format the output as specified: [s_1,s_2,s_3,s_4]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_diffusion_coeff(u_grid, A, u_center, w):\n    \"\"\"Calculates the Gaussian diffusion coefficient.\"\"\"\n    if A == 0:\n        return np.zeros_like(u_grid)\n    return A * np.exp(-(u_grid - u_center)**2 / (2 * w**2))\n\ndef calculate_fom(D, u_grid):\n    \"\"\"\n    Calculates the figure-of-merit (FoM) for a given diffusion coefficient.\n    The FoM is defined as J/P (current over power).\n    \"\"\"\n    N_u = len(u_grid)\n    du = u_grid[1] - u_grid[0]\n    \n    # --- 1. Calculate the electron distribution function f(u) ---\n    \n    # Integrand for the exponent in f(u)\n    integrand_exp = u_grid / (1.0 + D)\n    \n    # The integral in the exponent is from 0 to u.\n    # We use cumulative_trapezoid and adjust for the starting point at u=0.\n    # N_u is odd, so u=0 is exactly in the middle of the grid.\n    zero_idx = (N_u - 1) // 2\n    \n    # Compute the cumulative integral from u_min to u\n    cum_integral = cumulative_trapezoid(integrand_exp, u_grid, initial=0.0)\n    \n    # The exponent is - integral from 0 to u\n    exponent_val = -(cum_integral - cum_integral[zero_idx])\n    \n    f_unnormalized = np.exp(exponent_val)\n    \n    # Normalize f(u) such that integral(f_unnormalized) du = 1\n    norm_const = np.trapz(f_unnormalized, u_grid)\n    if norm_const  1e-15: # Avoid division by zero, though unlikely\n        f = np.zeros_like(u_grid)\n    else:\n        f = f_unnormalized / norm_const\n\n    # --- 2. Calculate driven current J ---\n    J = np.trapz(u_grid * f, u_grid)\n\n    # --- 3. Calculate absorbed power P ---\n    \n    # If there is no diffusion, power is zero.\n    if np.all(D == 0):\n        P = 0.0\n    else:\n        # Calculate df/du using second-order finite differences\n        dfdu = np.zeros(N_u)\n        \n        # Interior points (centered difference)\n        dfdu[1:-1] = (f[2:] - f[:-2]) / (2 * du)\n        \n        # Endpoints (one-sided differences)\n        # At u_min (i=0): second-order forward difference\n        dfdu[0] = (-3 * f[0] + 4 * f[1] - f[2]) / (2 * du)\n        # At u_max (i=N_u-1): second-order backward difference\n        dfdu[-1] = (3 * f[-1] - 4 * f[-2] + f[-3]) / (2 * du)\n        \n        P = np.trapz(D * (dfdu**2), u_grid)\n        \n    # --- 4. Calculate Figure of Merit (FoM) Phi ---\n    if P  1e-15:\n        return 0.0\n    \n    return J / P\n\ndef compute_synergy_factor(u_max, N_u, A_FW, u_FW, w_FW, A_LH, u_LH, w_LH):\n    \"\"\"\n    Computes the synergy factor S for a given set of wave parameters.\n    \"\"\"\n    u_grid = np.linspace(-u_max, u_max, N_u)\n    \n    # Calculate diffusion coefficients for FW, LH, and total\n    D_FW = get_diffusion_coeff(u_grid, A_FW, u_FW, w_FW)\n    D_LH = get_diffusion_coeff(u_grid, A_LH, u_LH, w_LH)\n    D_tot = D_FW + D_LH\n    \n    # Calculate figure-of-merit for each case\n    phi_fw = calculate_fom(D_FW, u_grid)\n    phi_lh = calculate_fom(D_LH, u_grid)\n    phi_tot = calculate_fom(D_tot, u_grid)\n    \n    # Calculate synergy factor\n    max_phi_single = max(phi_fw, phi_lh)\n    \n    if max_phi_single  1e-15:\n        # If both individual FoMs are zero, no synergy can be meaningfully defined.\n        # If phi_tot is also zero, S=1 indicates no change. If phi_tot0, this is infinite synergy.\n        # Problem constraints ensure this denominator is non-zero for the test cases.\n        # A value of 1.0 is a reasonable default.\n        return 1.0\n        \n    synergy = phi_tot / max_phi_single\n    \n    return synergy\n    \nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3699495"}, {"introduction": "The ability to accurately model current drive naturally leads to the desire to optimize it. For a real-world FWCD system with numerous control parameters, such as antenna phasing or plasma conditions, finding the optimal setup is a formidable challenge. This practice introduces the adjoint method, a sophisticated and highly efficient computational technique for calculating the sensitivity of a performance metric—in this case, the current drive efficiency $\\eta$—to changes in control parameters. By implementing an adjoint solver for a model wave equation, you will compute the gradient $\\nabla\\eta$, the essential information needed for any gradient-based optimization algorithm, providing a direct glimpse into the state-of-the-art methods used to design and operate fusion experiments [@problem_id:3699504].", "problem": "Implement an adjoint-based gradient computation for a simplified Fast Wave Current Drive (FWCD) efficiency model, starting from first principles of electromagnetics and linear wave propagation in a cold plasma, and verify it numerically. The goal is to compute the gradient of a model FWCD efficiency with respect to antenna phasing and edge density, and to explain how such gradients can be used for launch optimization.\n\nAssume a one-dimensional slab plasma occupying a normalized spatial interval $x \\in [0,1]$ with a cold-plasma, linear, time-harmonic electromagnetic field described by a scalar wave potential amplitude $\\psi(x)$ that satisfies a reduced scalar Helmholtz equation derived from Maxwell’s equations in the frequency domain. Use a centered finite-difference discretization on a uniform grid of $N$ interior points (with $N$ large enough for numerical convergence; for concreteness use $N = 256$) and homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$. Model a spatially localized radio-frequency (RF) source by a volumetric Gaussian source term $s(x)$ centered near the left boundary.\n\nUse the following physically motivated, dimensionless model ingredients, chosen to be scientifically plausible and internally consistent:\n\n- The discretized state equation for the complex field vector $\\boldsymbol{\\psi} \\in \\mathbb{C}^{N}$ is\n$$\n\\mathbf{M}(\\boldsymbol{p})\\,\\boldsymbol{\\psi} = \\boldsymbol{b},\n$$\nwhere $\\mathbf{M}(\\boldsymbol{p})$ is the $N \\times N$ tridiagonal matrix corresponding to the second-order finite-difference Laplacian with homogeneous Dirichlet endpoints minus a diagonal operator representing the spatially varying complex squared refractive index, and $\\boldsymbol{b} \\in \\mathbb{C}^{N}$ is the discretized source. Let the parameter vector be $\\boldsymbol{p} = (\\phi, n_{\\mathrm{edge}})$, where $\\phi$ is the antenna phasing (an angle in radians) and $n_{\\mathrm{edge}}$ is the edge electron density normalized to the critical density.\n\n- Let the background wavenumber be $k_0 = 2\\pi$ (dimensionless). Let the spatial grid have spacing $h = 1/(N+1)$ and interior grid points $x_i = i h$ for $i \\in \\{1,\\dots,N\\}$. The finite-difference operator is\n$$\n(\\mathbf{M}\\boldsymbol{\\psi})_i = -\\psi_{i-1} + \\left(2 - h^2 k_i^2(\\boldsymbol{p})\\right)\\psi_i - \\psi_{i+1},\n$$\nwith $\\psi_0 = \\psi_{N+1} = 0$. The discretized source is $(\\boldsymbol{b})_i = h^2 s(x_i)$ with a Gaussian $s(x) = s_0 \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)$, where $s_0 = 1$, $x_0 = 0.1$, and $\\sigma = 0.03$ are dimensionless.\n\n- Model the density profile as\n$$\nn_e(x;\\,n_{\\mathrm{edge}}) = n_{\\mathrm{edge}} + \\left(n_{\\mathrm{core}} - n_{\\mathrm{edge}}\\right)\\,g(x),\n$$\nwith $n_{\\mathrm{core}} = 0.8$ and $g(x) = 1 - \\exp\\!\\left(-\\frac{x}{\\ell}\\right)$, $\\ell = 0.2$, all dimensionless.\n\n- Model the phasing-dependent parallel refractive index as\n$$\nN_{\\parallel}(\\phi) = N_0 + N_1 \\sin(\\phi),\n$$\nwith $N_0 = 1.2$ and $N_1 = 0.8$ (dimensionless). Assume an effective complex squared wavenumber\n$$\nk^2(x;\\,\\boldsymbol{p}) = k_0^2 \\left(1 - n_e(x;\\,n_{\\mathrm{edge}})\\right) + i\\,\\alpha(x;\\,\\boldsymbol{p}),\n$$\nwhere the dimensionless absorption coefficient is\n$$\n\\alpha(x;\\,\\boldsymbol{p}) = a_0\\,n_e(x;\\,n_{\\mathrm{edge}})\\,N_{\\parallel}(\\phi)^2 + a_b,\n$$\nwith $a_0 = 0.1$ and $a_b = 0.01$ (dimensionless).\n\n- Define the FWCD efficiency metric as a Rayleigh quotient in terms of spatially weighted field energy densities,\n$$\n\\eta(\\boldsymbol{\\psi},\\boldsymbol{p}) = \\frac{\\boldsymbol{\\psi}^{\\dagger}\\,\\mathbf{W}_J(\\boldsymbol{p})\\,\\boldsymbol{\\psi}}{\\boldsymbol{\\psi}^{\\dagger}\\,\\mathbf{W}_P(\\boldsymbol{p})\\,\\boldsymbol{\\psi}},\n$$\nwith diagonal weight matrices $\\mathbf{W}_J$ and $\\mathbf{W}_P$ defined pointwise by\n$$\nw_J(x;\\,\\boldsymbol{p}) = c_0\\,n_e(x;\\,n_{\\mathrm{edge}})\\,N_{\\parallel}(\\phi),\\qquad\nw_P(x;\\,\\boldsymbol{p}) = \\alpha(x;\\,\\boldsymbol{p}),\n$$\nand $c_0 = 1$ (dimensionless). Here $\\dagger$ denotes conjugate-transpose.\n\nTasks:\n\n- Starting from Maxwell’s equations in a linear, cold plasma and the definition of a time-harmonic field, justify the scalar Helmholtz reduction used above as a consistent simplified model. From this base, derive the discrete state equation $\\mathbf{M}(\\boldsymbol{p})\\,\\boldsymbol{\\psi} = \\boldsymbol{b}$ on a uniform grid with homogeneous Dirichlet boundary conditions.\n\n- Using Lagrange multipliers and the adjoint-state method, derive an expression for the gradient $\\nabla_{\\boldsymbol{p}} \\eta$ with respect to $\\phi$ and $n_{\\mathrm{edge}}$. To handle complex-valued fields, reformulate the problem in a purely real $2N$-dimensional system by stacking real and imaginary parts. Derive the adjoint equation in this real formulation and the resulting gradient formula that separates implicit dependence through $\\boldsymbol{\\psi}$ and explicit dependence through $\\mathbf{W}_J$, $\\mathbf{W}_P$, and $\\mathbf{M}$.\n\n- Implement a program that:\n  - Discretizes the domain with $N = 256$ interior points and constructs $\\mathbf{M}(\\boldsymbol{p})$ and $\\boldsymbol{b}$ as specified.\n  - Solves for $\\boldsymbol{\\psi}$ for any input $(\\phi, n_{\\mathrm{edge}})$.\n  - Computes $\\eta(\\boldsymbol{\\psi},\\boldsymbol{p})$.\n  - Forms the real-augmented system and solves the adjoint equation to obtain the adjoint vector.\n  - Computes the gradient components $\\partial \\eta/\\partial \\phi$ and $\\partial \\eta/\\partial n_{\\mathrm{edge}}$ via the adjoint method.\n  - Verifies both gradient components against central finite differences with small steps $\\delta_{\\phi} = 10^{-3}$ (radians) and $\\delta_{n} = 10^{-4}$ (dimensionless). Compute, for each test case, the relative Euclidean error between the adjoint gradient vector and the finite-difference gradient vector.\n\n- Angle unit specification: all angles must be in radians.\n\n- Units: all quantities are dimensionless by construction in this simplified model.\n\nTest suite:\n\n- Use the following parameter sets $(\\phi, n_{\\mathrm{edge}})$:\n  - Case $1$: $(\\phi, n_{\\mathrm{edge}}) = \\left(\\frac{\\pi}{4},\\,0.1\\right)$.\n  - Case $2$: $(\\phi, n_{\\mathrm{edge}}) = \\left(\\frac{\\pi}{2},\\,0.2\\right)$.\n  - Case $3$: $(\\phi, n_{\\mathrm{edge}}) = \\left(0,\\,0.05\\right)$.\n  - Case $4$: $(\\phi, n_{\\mathrm{edge}}) = \\left(\\frac{3\\pi}{4},\\,0.3\\right)$.\n\nAnswer specification:\n\n- For each test case, your program must output a list with three floats:\n  - The adjoint gradient component $\\partial \\eta/\\partial \\phi$ (dimensionless per radian).\n  - The adjoint gradient component $\\partial \\eta/\\partial n_{\\mathrm{edge}}$ (dimensionless).\n  - The relative Euclidean error between the adjoint gradient vector and the central finite-difference gradient vector (dimensionless), computed as the Euclidean norm of their difference divided by the Euclidean norm of the finite-difference vector, with a small positive floor in the denominator to avoid division by zero.\n\n- Final output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists in a single pair of square brackets, for example\n\"[ [gphi1,gn1,err1], [gphi2,gn2,err2], [gphi3,gn3,err3], [gphi4,gn4,err4] ]\"\nwith each entry a decimal float. No additional text should be printed.", "solution": "The problem requires the implementation of an adjoint-based gradient computation for a simplified one-dimensional model of Fast Wave Current Drive (FWCD) efficiency in a plasma. The solution involves three main theoretical parts: first, justifying the physical model and deriving its discrete form; second, deriving the adjoint equations and the gradient expression; and third, implementing the model and the adjoint calculus numerically.\n\n### 1. Model Justification and Discretization\n\nThe physical system is modeled by a scalar Helmholtz-like equation for a complex wave potential $\\psi(x)$ in a one-dimensional slab geometry $x \\in [0,1]$:\n$$\n-\\frac{d^2\\psi}{dx^2} - k^2(x; \\boldsymbol{p}) \\psi = s(x)\n$$\nThis equation is a common simplification of the full vectorial Maxwell's equations for wave propagation in a magnetized plasma. Starting from $\\nabla \\times (\\nabla \\times \\mathbf{E}) - k_0^2 \\boldsymbol{\\epsilon} \\cdot \\mathbf{E} = i\\omega\\mu_0 \\mathbf{J}_{\\text{ant}}$, where $\\boldsymbol{\\epsilon}$ is the plasma dielectric tensor, a reduction to a scalar equation is possible under assumptions about the geometry (1D slab), wave polarization (e.g., the fast wave branch), and propagation direction. The complex wavenumber $k^2(x; \\boldsymbol{p})$ encapsulates the plasma's response, including refractive effects through the electron density $n_e(x)$ and dissipative effects (power absorption) through the phenomenological absorption coefficient $\\alpha(x; \\boldsymbol{p})$. The source term $s(x)$ represents the power launched by an antenna. This simplified model, while not capturing all the complexities of wave physics in a tokamak, provides a tractable and physically relevant framework for studying the fundamentals of wave propagation, absorption, and current drive efficiency.\n\nTo solve this equation numerically, we use a centered finite-difference scheme on a uniform grid with $N$ interior points $x_i = i h$ for $i=1, \\dots, N$, where the grid spacing is $h = 1/(N+1)$. The second derivative is approximated as $\\frac{d^2\\psi}{dx^2}\\big|_{x_i} \\approx (\\psi_{i-1} - 2\\psi_i + \\psi_{i+1})/h^2$. Substituting this into the differential equation and multiplying by $h^2$ gives the discrete equation at each grid point $x_i$:\n$$\n-\\psi_{i-1} + 2\\psi_i - \\psi_{i+1} - h^2 k^2(x_i; \\boldsymbol{p}) \\psi_i = h^2 s(x_i)\n$$\nRearranging and incorporating the homogeneous Dirichlet boundary conditions, $\\psi_0 = \\psi_{N+1} = 0$, we arrive at the linear system for the vector of field values $\\boldsymbol{\\psi} = (\\psi_1, \\dots, \\psi_N)^T$:\n$$\n\\mathbf{M}(\\boldsymbol{p})\\,\\boldsymbol{\\psi} = \\boldsymbol{b}\n$$\nHere, $\\boldsymbol{b}$ is the discretized source vector with components $(\\boldsymbol{b})_i = h^2 s(x_i)$, and $\\mathbf{M}(\\boldsymbol{p})$ is an $N \\times N$ complex tridiagonal matrix with entries:\n$$\n(\\mathbf{M}\\boldsymbol{\\psi})_i = -\\psi_{i-1} + \\left(2 - h^2 k_i^2(\\boldsymbol{p})\\right)\\psi_i - \\psi_{i+1}\n$$\n\n### 2. Adjoint-Based Gradient Derivation\n\nThe objective is to compute the gradient of the efficiency metric $\\eta(\\boldsymbol{p}) = \\eta(\\boldsymbol{\\psi}(\\boldsymbol{p}), \\boldsymbol{p})$ with respect to the parameters $\\boldsymbol{p} = (\\phi, n_{\\mathrm{edge}})$. The efficiency is defined as a Rayleigh quotient:\n$$\n\\eta = \\frac{J}{P} = \\frac{\\boldsymbol{\\psi}^{\\dagger}\\,\\mathbf{W}_J(\\boldsymbol{p})\\,\\boldsymbol{\\psi}}{\\boldsymbol{\\psi}^{\\dagger}\\,\\mathbf{W}_P(\\boldsymbol{p})\\,\\boldsymbol{\\psi}}\n$$\nTo handle the complex variables, we reformulate the problem in a real-valued system of size $2N$. Let $\\boldsymbol{\\psi} = \\boldsymbol{\\psi}_R + i\\boldsymbol{\\psi}_I$ and $\\mathbf{M} = \\mathbf{M}_R + i\\mathbf{M}_I$. The state equation $\\mathbf{M}\\boldsymbol{\\psi} = \\boldsymbol{b}$ (with real source $\\boldsymbol{b}$) separates into:\n$$\n\\begin{pmatrix} \\mathbf{M}_R  -\\mathbf{M}_I \\\\ \\mathbf{M}_I  \\mathbf{M}_R \\end{pmatrix}\n\\begin{pmatrix} \\boldsymbol{\\psi}_R \\\\ \\boldsymbol{\\psi}_I \\end{pmatrix}\n=\n\\begin{pmatrix} \\boldsymbol{b} \\\\ \\mathbf{0} \\end{pmatrix}\n$$\nWe denote this as $\\mathbf{A}(\\boldsymbol{p})\\mathbf{y} = \\mathbf{c}$, where $\\mathbf{y} = (\\boldsymbol{\\psi}_R^T, \\boldsymbol{\\psi}_I^T)^T$. Since the weight matrices $\\mathbf{W}_J$ and $\\mathbf{W}_P$ are real, the efficiency metric becomes:\n$$\n\\eta = \\frac{\\mathbf{y}^T \\mathbf{W}_{J, \\text{aug}} \\mathbf{y}}{\\mathbf{y}^T \\mathbf{W}_{P, \\text{aug}} \\mathbf{y}}, \\quad \\text{where} \\quad \\mathbf{W}_{\\text{aug}} = \\begin{pmatrix} \\mathbf{W}  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{W} \\end{pmatrix}\n$$\nThe total derivative of $\\eta$ with respect to a parameter $p_k$ is given by the chain rule: $\\frac{d\\eta}{dp_k} = \\frac{\\partial\\eta}{\\partial p_k} + \\frac{\\partial\\eta}{\\partial \\mathbf{y}} \\frac{d\\mathbf{y}}{dp_k}$. The adjoint method provides an efficient way to compute the second term without forming the expensive sensitivity matrix $\\frac{d\\mathbf{y}}{dp_k}$. We define an adjoint state vector $\\boldsymbol{\\lambda}_{\\text{real}} \\in \\mathbb{R}^{2N}$ as the solution to the adjoint equation:\n$$\n\\mathbf{A}(\\boldsymbol{p})^T \\boldsymbol{\\lambda}_{\\text{real}} = -\\left(\\frac{\\partial\\eta}{\\partial\\mathbf{y}}\\right)^T\n$$\nWith this definition, the gradient expression simplifies to:\n$$\n\\frac{d\\eta}{dp_k} = \\frac{\\partial\\eta}{\\partial p_k} + \\boldsymbol{\\lambda}_{\\text{real}}^T \\left( \\frac{\\partial \\mathbf{A}}{\\partial p_k} \\mathbf{y} \\right)\n$$\nThe terms on the right-hand side can be derived as follows. The explicit derivative is $\\frac{\\partial\\eta}{\\partial p_k} = \\frac{1}{P}(\\frac{\\partial J}{\\partial p_k} - \\eta \\frac{\\partial P}{\\partial p_k})$, where $\\frac{\\partial J}{\\partial p_k} = \\mathbf{y}^T \\frac{\\partial \\mathbf{W}_{J, \\text{aug}}}{\\partial p_k}\\mathbf{y}$ and $\\frac{\\partial P}{\\partial p_k} = \\mathbf{y}^T \\frac{\\partial \\mathbf{W}_{P, \\text{aug}}}{\\partial p_k}\\mathbf{y}$. The source for the adjoint equation is derived from the derivatives of $J$ and $P$ with respect to $\\mathbf{y}$:\n$$\n-\\left(\\frac{\\partial\\eta}{\\partial\\mathbf{y}}\\right)^T = -\\frac{2}{P} \\left( \\mathbf{W}_{J, \\text{aug}} - \\eta \\mathbf{W}_{P, \\text{aug}} \\right)\\mathbf{y}\n$$\nThe procedure is as follows:\n1.  Solve the state equation $\\mathbf{A}\\mathbf{y}=\\mathbf{c}$ for the state vector $\\mathbf{y}$.\n2.  Calculate the efficiency $\\eta$ and the denominators $P = \\mathbf{y}^T \\mathbf{W}_{P, \\text{aug}} \\mathbf{y}$.\n3.  Solve the adjoint equation $\\mathbf{A}^T\\boldsymbol{\\lambda}_{\\text{real}} = -\\frac{2}{P}(\\mathbf{W}_{J, \\text{aug}} - \\eta \\mathbf{W}_{P, \\text{aug}})\\mathbf{y}$ for the adjoint vector $\\boldsymbol{\\lambda}_{\\text{real}}$.\n4.  For each parameter $p_k$, compute the total derivative $\\frac{d\\eta}{dp_k}$ by summing the explicit term $\\frac{\\partial\\eta}{\\partial p_k}$ and the implicit term $\\boldsymbol{\\lambda}_{\\text{real}}^T (\\frac{\\partial \\mathbf{A}}{\\partial p_k} \\mathbf{y})$.\n\nThis gradient, $\\nabla_{\\boldsymbol{p}}\\eta$, points in the direction of the steepest ascent of the FWCD efficiency in the parameter space $(\\phi, n_{\\mathrm{edge}})$. It can be used in optimization algorithms to find parameter settings that maximize efficiency.\n\n### 3. Numerical Implementation\n\nThe program implements the derived adjoint method. It defines functions for the physical quantities ($n_e$, $N_\\parallel$, $k^2$, etc.) and their derivatives with respect to the control parameters $\\phi$ and $n_{\\mathrm{edge}}$. For each test case, it assembles and solves the linear systems for the state vector $\\boldsymbol{\\psi}$ and the real-valued adjoint vector $\\boldsymbol{\\lambda}_{\\text{real}}$. Finally, it combines the various derivative terms to compute the gradient components $\\partial\\eta/\\partial\\phi$ and $\\partial\\eta/\\partial n_{\\mathrm{edge}}$. These results are verified by comparison against gradients computed using a central finite-difference approximation, and the relative error is reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adjoint-based gradient computation for a simplified \n    Fast Wave Current Drive (FWCD) efficiency model and verifies it numerically.\n    \"\"\"\n    \n    # -- Problem Constants --\n    N = 256\n    k0 = 2 * np.pi\n    s0 = 1.0\n    x0 = 0.1\n    sigma = 0.03\n    n_core = 0.8\n    ell = 0.2\n    N0 = 1.2\n    N1 = 0.8\n    a0 = 0.1\n    a_b = 0.01\n    c0 = 1.0\n    delta_phi = 1e-3\n    delta_n_edge = 1e-4\n\n    # -- Grid and Source --\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n\n    def s(x_pts):\n        return s0 * np.exp(-((x_pts - x0)**2) / (2 * sigma**2))\n\n    b = h**2 * s(x)\n    c = np.concatenate([b, np.zeros(N)]) # Real augmented source vector\n\n    # -- Model Functions and Their Derivatives --\n    \n    # Density profile and its derivative w.r.t. n_edge\n    def g(x_pts):\n        return 1.0 - np.exp(-x_pts / ell)\n\n    def ne(x_pts, n_edge):\n        return n_edge + (n_core - n_edge) * g(x_pts)\n\n    def dne_dn_edge(x_pts):\n        return 1.0 - g(x_pts)\n\n    # Parallel refractive index and its derivative w.r.t. phi\n    def N_parallel(phi):\n        return N0 + N1 * np.sin(phi)\n\n    def dN_parallel_dphi(phi):\n        return N1 * np.cos(phi)\n\n    # Absorption coefficient and its derivatives\n    def alpha(x_pts, phi, n_edge):\n        ne_vals = ne(x_pts, n_edge)\n        N_par_val = N_parallel(phi)\n        return a0 * ne_vals * N_par_val**2 + a_b\n\n    def dalpha_dphi(x_pts, phi, n_edge):\n        ne_vals = ne(x_pts, n_edge)\n        N_par_val = N_parallel(phi)\n        dN_par_dphi_val = dN_parallel_dphi(phi)\n        return 2 * a0 * ne_vals * N_par_val * dN_par_dphi_val\n\n    def dalpha_dn_edge(x_pts, phi):\n        dne_dne_vals = dne_dn_edge(x_pts)\n        N_par_val = N_parallel(phi)\n        return a0 * dne_dne_vals * N_par_val**2\n\n    # Wavenumber squared and its derivatives\n    def k_squared(x_pts, phi, n_edge):\n        ne_vals = ne(x_pts, n_edge)\n        alpha_vals = alpha(x_pts, phi, n_edge)\n        return k0**2 * (1.0 - ne_vals) + 1j * alpha_vals\n\n    def dk_squared_dphi(x_pts, phi, n_edge):\n        return 1j * dalpha_dphi(x_pts, phi, n_edge)\n\n    def dk_squared_dn_edge(x_pts, phi):\n        dne_dne_vals = dne_dn_edge(x_pts)\n        dalpha_dne_vals = dalpha_dn_edge(x_pts, phi)\n        return -k0**2 * dne_dne_vals + 1j * dalpha_dne_vals\n\n    # Weighting functions and their derivatives\n    def w_J(x_pts, phi, n_edge):\n        ne_vals = ne(x_pts, n_edge)\n        N_par_val = N_parallel(phi)\n        return c0 * ne_vals * N_par_val\n\n    def dw_J_dphi(x_pts, phi, n_edge):\n        ne_vals = ne(x_pts, n_edge)\n        dN_par_dphi_val = dN_parallel_dphi(phi)\n        return c0 * ne_vals * dN_par_dphi_val\n\n    def dw_J_dn_edge(x_pts, phi):\n        dne_dne_vals = dne_dn_edge(x_pts)\n        N_par_val = N_parallel(phi)\n        return c0 * dne_dne_vals * N_par_val\n        \n    def w_P(x_pts, phi, n_edge):\n        return alpha(x_pts, phi, n_edge)\n        \n    def dw_P_dphi(x_pts, phi, n_edge):\n        return dalpha_dphi(x_pts, phi, n_edge)\n        \n    def dw_P_dn_edge(x_pts, phi):\n        return dalpha_dn_edge(x_pts, phi)\n\n    def get_efficiency_and_field(phi, n_edge):\n        \"\"\"Solves the state equation and computes efficiency.\"\"\"\n        # Construct complex matrix M\n        k2_vals = k_squared(x, phi, n_edge)\n        diag_M = 2.0 - h**2 * k2_vals\n        off_diag = -1.0 * np.ones(N - 1)\n        M = np.diag(diag_M) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        # Solve M * psi = b\n        psi = np.linalg.solve(M, b)\n        \n        # Construct weight matrices W_J, W_P\n        W_J_diag = w_J(x, phi, n_edge)\n        W_P_diag = w_P(x, phi, n_edge)\n        \n        # Compute efficiency\n        J = np.vdot(psi, W_J_diag * psi).real\n        P = np.vdot(psi, W_P_diag * psi).real\n        \n        eta = J / P if P != 0 else 0.0\n        \n        return eta, psi, M, W_J_diag, W_P_diag\n\n    def compute_gradient(phi, n_edge):\n        \"\"\"Computes the gradient using the adjoint method.\"\"\"\n        # 1. Solve forward problem\n        eta, psi, M, W_J_diag, W_P_diag = get_efficiency_and_field(phi, n_edge)\n        \n        # Real augmented representation\n        y = np.concatenate([psi.real, psi.imag])\n        M_R = M.real\n        M_I = M.imag\n        \n        # Form 2N x 2N real matrix A\n        A = np.block([[M_R, -M_I], [M_I, M_R]])\n        \n        # Augmented weight matrices\n        W_J_aug = np.diag(np.concatenate([W_J_diag, W_J_diag]))\n        W_P_aug = np.diag(np.concatenate([W_P_diag, W_P_diag]))\n        \n        # Numerator and denominator of eta\n        J_val = y.T @ W_J_aug @ y\n        P_val = y.T @ W_P_aug @ y\n        \n        # 2. Solve adjoint problem: A.T * lambda_real = f\n        f = (-2.0 / P_val) * (W_J_aug - eta * W_P_aug) @ y\n        lambda_real = np.linalg.solve(A.T, f)\n\n        # 3. Compute gradient components\n        grad = {}\n        for p_name, p_val in [('phi', phi), ('n_edge', n_edge)]:\n            if p_name == 'phi':\n                dk2_dp_vals = dk_squared_dphi(x, phi, n_edge)\n                dwJ_dp_vals = dw_J_dphi(x, phi, n_edge)\n                dwP_dp_vals = dw_P_dphi(x, phi, n_edge)\n            else: # n_edge\n                dk2_dp_vals = dk_squared_dn_edge(x, phi)\n                dwJ_dp_vals = dw_J_dn_edge(x, phi)\n                dwP_dp_vals = dw_P_dn_edge(x, phi)\n\n            # Derivatives of matrices\n            dM_dp_diag = -h**2 * dk2_dp_vals\n            dM_R_dp = np.diag(dM_dp_diag.real)\n            dM_I_dp = np.diag(dM_dp_diag.imag)\n            \n            dA_dp = np.block([[dM_R_dp, -dM_I_dp], [dM_I_dp, dM_R_dp]])\n            \n            dW_J_aug_dp = np.diag(np.concatenate([dwJ_dp_vals, dwJ_dp_vals]))\n            dW_P_aug_dp = np.diag(np.concatenate([dwP_dp_vals, dwP_dp_vals]))\n            \n            # Explicit term\n            d_eta_d_p_explicit = (1.0 / P_val) * (y.T @ dW_J_aug_dp @ y - eta * (y.T @ dW_P_aug_dp @ y))\n            \n            # Implicit term\n            d_eta_d_p_implicit = lambda_real.T @ dA_dp @ y\n            \n            grad[p_name] = d_eta_d_p_explicit + d_eta_d_p_implicit\n            \n        return grad['phi'], grad['n_edge']\n\n    def compute_gradient_fd(phi, n_edge):\n        \"\"\"Computes gradient via central finite differences for verification.\"\"\"\n        eta_p_phi, _, _, _, _ = get_efficiency_and_field(phi + delta_phi / 2, n_edge)\n        eta_m_phi, _, _, _, _ = get_efficiency_and_field(phi - delta_phi / 2, n_edge)\n        grad_phi = (eta_p_phi - eta_m_phi) / delta_phi\n        \n        eta_p_n, _, _, _, _ = get_efficiency_and_field(phi, n_edge + delta_n_edge / 2)\n        eta_m_n, _, _, _, _ = get_efficiency_and_field(phi, n_edge - delta_n_edge / 2)\n        grad_n_edge = (eta_p_n - eta_m_n) / delta_n_edge\n        \n        return grad_phi, grad_n_edge\n\n    test_cases = [\n        (np.pi / 4, 0.1),\n        (np.pi / 2, 0.2),\n        (0.0, 0.05),\n        (3 * np.pi / 4, 0.3)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        phi_val, n_edge_val = case\n        \n        # Adjoint gradient\n        grad_phi_adj, grad_n_adj = compute_gradient(phi_val, n_edge_val)\n        \n        # Finite difference gradient\n        grad_phi_fd, grad_n_fd = compute_gradient_fd(phi_val, n_edge_val)\n        \n        # Relative error\n        g_adj = np.array([grad_phi_adj, grad_n_adj])\n        g_fd = np.array([grad_phi_fd, grad_n_fd])\n        \n        diff_norm = np.linalg.norm(g_adj - g_fd)\n        fd_norm = np.linalg.norm(g_fd)\n        \n        rel_error = diff_norm / (fd_norm + 1e-12) # Add floor for stability\n        \n        results.append([grad_phi_adj, grad_n_adj, rel_error])\n\n    print(f\"[{','.join([f'[{r[0]:.6f},{r[1]:.6f},{r[2]:.6e}]' for r in results])}]\")\n\nsolve()\n```", "id": "3699504"}]}