{"hands_on_practices": [{"introduction": "A key feature of quasi-isodynamic (QI) stellarators is the specific topology of their magnetic field strength, $B$, on a flux surface. This practice provides a hands-on method to computationally verify one of these features: whether the contours of maximum magnetic field strength are \"poloidally closed\" as a function of the poloidal angle $\\theta$ and toroidal angle $\\zeta$. By translating this geometric property into a concrete algorithm involving connected-component analysis, you will develop a practical tool for classifying magnetic field configurations. [@problem_id:3715836]", "problem": "You are given the magnitude of the magnetic field $B(\\theta,\\zeta)$ on a nested toroidal flux surface labeled by the toroidal flux $\\psi$, expressed in Boozer angles $(\\theta,\\zeta)$, where $\\theta \\in [0,2\\pi)$ is the poloidal angle and $\\zeta \\in [0,2\\pi)$ is the toroidal angle. Angles must be treated in radians. For any fixed $\\psi$, the quasi-isodynamic stellarator condition implies that the contours of constant field magnitude near the global maximum $B_{\\max}(\\psi)$ are poloidally closed on the surface. In this problem, you will algorithmically determine whether the set of points satisfying $B(\\theta,\\zeta)=B_{\\max}(\\psi)$ forms one or more poloidally closed loops on the $(\\theta,\\zeta)$-torus.\n\nFundamental base and definitions:\n- The level set at the maximum is $S=\\{(\\theta,\\zeta)\\in[0,2\\pi)\\times[0,2\\pi): B(\\theta,\\zeta)=B_{\\max}(\\psi)\\}$, where $B_{\\max}(\\psi)=\\max_{\\theta,\\zeta} B(\\theta,\\zeta)$ on the surface $\\psi$.\n- A connected component $C\\subset S$ is said to be poloidally closed if, when viewed on the torus, it closes without net toroidal winding. In computational terms on a uniform angular grid, we will detect this by the following discrete proxy: a component is classified as poloidally closed if its minimal circular span in $\\zeta$ is small (bounded by a threshold) while its coverage in $\\theta$ is near full.\n\nDiscrete algorithm to be implemented:\n1. Discretize the domain into a uniform grid of $N_\\theta$ and $N_\\zeta$ points, with $\\theta_i = 2\\pi i/N_\\theta$ for $i\\in\\{0,\\dots,N_\\theta-1\\}$ and $\\zeta_j = 2\\pi j/N_\\zeta$ for $j\\in\\{0,\\dots,N_\\zeta-1\\}$. Use $N_\\theta=N_\\zeta=360$.\n2. For each test case, compute the array $B_{ij}=B(\\theta_i,\\zeta_j)$ and the discrete maximum $B_{\\max}=\\max_{i,j} B_{ij}$.\n3. Define the discrete level-set mask $M_{ij}$ as true if $|B_{ij}-B_{\\max}|\\le \\tau$ and false otherwise, where $\\tau=10^{-12}$.\n4. Identify connected components of $M$ using $8$-connectivity with periodic boundary conditions in both $\\theta$ and $\\zeta$. Two true cells are neighbors if their index differences $(\\Delta i,\\Delta j)$ satisfy $\\Delta i\\in\\{-1,0,1\\}$ and $\\Delta j\\in\\{-1,0,1\\}$ (excluding $(0,0)$), with indices computed modulo $N_\\theta$ and $N_\\zeta$.\n5. For each component, compute:\n   - The set of distinct poloidal indices $I_\\theta \\subset \\{0,\\dots,N_\\theta-1\\}$ in the component and its coverage fraction $f_\\theta = |I_\\theta|/N_\\theta$.\n   - The set of distinct toroidal indices $I_\\zeta \\subset \\{0,\\dots,N_\\zeta-1\\}$ in the component and its minimal circular span $w_\\zeta$. To compute $w_\\zeta$, sort $I_\\zeta$ ascending and let the circular gaps be the differences between consecutive indices, including the wrap-around gap from the last to the first plus $N_\\zeta$. Let $g_{\\max}$ be the largest such gap. Then $w_\\zeta = N_\\zeta - g_{\\max}$.\n6. Declare a component poloidally closed if $w_\\zeta \\le \\lceil 0.05 N_\\zeta \\rceil$ and $f_\\theta \\ge 0.9$.\n7. The boolean result for each test case is true if and only if every connected component of $S$ is classified as poloidally closed by the above rule.\n\nAngle unit requirement: All trigonometric functions must use angles in radians.\n\nTest suite to implement and evaluate:\n- Case A (poloidally closed maxima): $B(\\theta,\\zeta)=B_0 + A - \\sin^2(\\zeta)$ with $B_0=1.0$ and $A=0.3$. Here $B_{\\max}=B_0+A$, achieved for all $\\theta$ at $\\zeta\\in\\{0,\\pi\\}$, producing poloidally closed loops.\n- Case B (toroidally closed maxima): $B(\\theta,\\zeta)=B_0 + A - \\sin^2(\\theta)$ with $B_0=1.0$ and $A=0.2$. Here $B_{\\max}=B_0+A$, achieved for all $\\zeta$ at $\\theta\\in\\{0,\\pi\\}$, producing toroidally closed loops.\n- Case C (helical maxima): $B(\\theta,\\zeta)=B_0 + A - \\sin^2(\\theta-\\zeta)$ with $B_0=1.0$ and $A=0.25$. Here $B_{\\max}=B_0+A$, achieved along helical lines $\\theta-\\zeta\\in\\{0,\\pi\\}$, which are not poloidally closed.\n\nFor each case, compute the boolean as specified. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true]\"). Use Python boolean formatting (\"True\" or \"False\").\n\nThere are no physical units to report beyond the requirement that angles are in radians. All numerical thresholds are unitless. The final output is a list of booleans, one per test case, in the order A, B, C.", "solution": "The user has provided a computational problem related to the analysis of magnetic field topology in quasi-isodynamic stellarators. The task is to implement a specific algorithm to determine if the maximum-field contours on a toroidal surface are \"poloidally closed\".\n\n### Problem Validation\n\nFirst, I will validate the problem statement as per the required procedure.\n\n#### Step 1: Extract Givens\n- **Task**: Algorithmically determine if the set of points where the magnetic field magnitude $B(\\theta, \\zeta)$ is at its maximum, $B_{\\max}$, forms poloidally closed loops.\n- **Domain**: A toroidal surface parameterized by Boozer angles $(\\theta, \\zeta) \\in [0, 2\\pi) \\times [0, 2\\pi)$. Angles are in radians.\n- **Discretization**: A uniform grid of $N_\\theta = 360$ and $N_\\zeta = 360$ points. $\\theta_i = 2\\pi i/N_\\theta$ and $\\zeta_j = 2\\pi j/N_\\zeta$.\n- **Maximum-Field Set Proxy**: A discrete mask $M_{ij}$ is defined as `true` if $|B(\\theta_i, \\zeta_j) - B_{\\max}| \\le \\tau$, where $\\tau = 10^{-12}$.\n- **Connected Components**: Find connected components of `true` values in the mask $M$ using $8$-connectivity with periodic boundary conditions in both $\\theta$ and $\\zeta$.\n- **Component Analysis**: For each component, calculate:\n    1.  Poloidal coverage fraction $f_\\theta = |I_\\theta| / N_\\theta$, where $I_\\theta$ is the set of unique poloidal indices $\\{i\\}$ in the component.\n    2.  Toroidal minimal circular span $w_\\zeta = N_\\zeta - g_{\\max}$. Here, $g_{\\max}$ is the largest gap between consecutive sorted toroidal indices $\\{j\\}$ in the component, including the wrap-around gap.\n- **Classification Rule**: A component is \"poloidally closed\" if $w_\\zeta \\le \\lceil 0.05 N_\\zeta \\rceil$ and $f_\\theta \\ge 0.9$.\n- **Final Verdict per Case**: The result for a test case is `true` if and only if every identified connected component is classified as poloidally closed.\n- **Test Cases**:\n    - Case A: $B(\\theta, \\zeta) = B_0 + A - \\sin^2(\\zeta)$ with $B_0=1.0, A=0.3$.\n    - Case B: $B(\\theta, \\zeta) = B_0 + A - \\sin^2(\\theta)$ with $B_0=1.0, A=0.2$.\n    - Case C: $B(\\theta, \\zeta) = B_0 + A - \\sin^2(\\theta - \\zeta)$ with $B_0=1.0, A=0.25$.\n- **Output Format**: A single line with a list of booleans, e.g., `[True,False,False]`.\n\n#### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is well-grounded in the field of plasma physics and nuclear fusion, specifically stellarator design. Boozer coordinates, quasi-isodynamicity, and analysis of magnetic field contours are all standard and critical concepts in this domain. The provided magnetic field forms are simplified but represent physically meaningful topologies (poloidal, toroidal, and helical structures).\n- **Well-Posed**: The problem is exceptionally well-posed. It provides a complete, unambiguous, and step-by-step algorithm. All numerical parameters ($N_\\theta, N_\\zeta, \\tau$), thresholds, and rules (connectivity, classification) are explicitly defined. This ensures a unique, deterministic solution can be computed.\n- **Objective**: The problem is stated with objective and formal language. The abstract concept of \"poloidally closed\" is given a precise, quantitative, and operational definition, leaving no room for subjective interpretation.\n\nThe problem statement passes all validation criteria and has no identifiable flaws.\n\n#### Step 3: Verdict and Action\n- **Verdict**: The problem is valid.\n- **Action**: I will proceed to develop the solution.\n\n### Algorithmic Design and Principles\n\nThe solution requires implementing the algorithm described in the problem statement. The core of this task involves a connected-component labeling (CCL) algorithm tailored for a periodic grid, followed by a geometric analysis of each component.\n\n1.  **Grid Generation and Field Evaluation**: For each test case, a $N_\\theta \\times N_\\zeta$ grid of angles $(\\theta_i, \\zeta_j)$ is constructed. The given function $B(\\theta, \\zeta)$ is evaluated on this grid to produce a 2D array $B_{ij}$. This directly discretizes the continuous magnetic field on the toroidal surface.\n\n2.  **Level-Set Masking**: The global maximum $B_{\\max}$ of the array $B_{ij}$ is found. A boolean mask $M_{ij}$ is then created. A cell $(i, j)$ is set to `true` if its corresponding field value $B_{ij}$ is within a small tolerance $\\tau$ of $B_{\\max}$. This mask $M$ represents the discrete approximation of the level set $S = \\{(\\theta, \\zeta) | B(\\theta, \\zeta) = B_{\\max}\\}$. The tolerance $\\tau$ is necessary to account for floating-point inaccuracies and to capture points sufficiently close to the maximum.\n\n3.  **Connected Component Labeling (CCL)**: This is the most complex part of the algorithm. We need to identify all distinct groups of connected `true` cells in the mask $M$.\n    - **Algorithm Choice**: A Breadth-First Search (BFS) is a suitable choice. We will iterate through every cell $(i, j)$ of the mask. If we find a `true` cell that has not yet been assigned to a component (i.e., not visited), we initiate a BFS starting from that cell.\n    - **BFS on a Torus**: The BFS explores neighbors of a cell. The problem specifies $8$-connectivity (a cell and its eight adjacent neighbors). Crucially, the grid is periodic (\"wraps around\") in both $i$ ($\\theta$ direction) and $j$ ($\\zeta$ direction). When finding the coordinates of a neighbor $(ni, nj)$ for a cell $(ci, cj)$ with displacement $(di, dj)$, we must use the modulo operator: $ni = (ci + di) \\pmod{N_\\theta}$ and $nj = (cj + dj) \\pmod{N_\\zeta}$.\n    - **Implementation**: A 'visited' array, with the same dimensions as $M$, is used to track cells that have already been explored. The BFS queue stores $(i, j)$ tuples of cells to visit. The search starting from a single unvisited `true` cell will discover all cells belonging to one connected component. This process is repeated until all `true` cells have been visited and assigned to a component.\n\n4.  **Component Analysis and Classification**: Once all connected components are identified, each is analyzed against the specified criteria.\n    - **Data Extraction**: For a given component (which is a list of cell coordinates $(i, j)$), we extract the unique set of poloidal indices, $I_\\theta$, and toroidal indices, $I_\\zeta$.\n    - **Poloidal Coverage ($f_\\theta$)**: The fraction $f_\\theta = |I_\\theta| / N_\\theta$ is computed. This measures how fully the component wraps around the poloidal direction. A value near $1.0$ indicates it spans nearly all poloidal angles.\n    - **Toroidal Span ($w_\\zeta$)**: This metric quantifies the \"width\" of the component in the toroidal direction. It is defined as $w_\\zeta = N_\\zeta - g_{\\max}$, where $g_{\\max}$ is the largest gap found between consecutive elements in the sorted list of toroidal indices $I_\\zeta$. The \"wrap-around\" gap between the last and first index must also be considered. A small $w_\\zeta$ implies the component is tightly clustered in the $\\zeta$ direction, while a large $w_\\zeta$ (near $N_\\zeta$) implies it is spread out toroidally.\n    - **Decision**: The component is classified as poloidally closed if it meets both thresholds: $f_\\theta \\ge 0.9$ and $w_\\zeta \\le \\lceil 0.05 N_\\zeta \\rceil$.\n\n5.  **Final Result**: For each test case, the overall result is `True` only if *all* connected components found in the mask are classified as poloidally closed. If no components are found (an empty mask), the condition is vacuously `True`. The results for all test cases are then collected and formatted as required.\n\nThis structured approach translates the physics-based criteria for quasi-isodynamicity into a deterministic and verifiable computational procedure.", "answer": "```python\nimport numpy as np\nimport math\nfrom collections import deque\n\ndef find_components(M, N_theta, N_zeta):\n    \"\"\"\n    Finds connected components in a boolean mask with periodic boundary conditions.\n    \n    Args:\n        M (np.ndarray): The 2D boolean mask.\n        N_theta (int): The size of the first dimension (rows).\n        N_zeta (int): The size of the second dimension (columns).\n        \n    Returns:\n        list[list[tuple[int, int]]]: A list of components, where each component\n                                     is a list of (row, col) coordinates.\n    \"\"\"\n    visited = np.zeros_like(M, dtype=bool)\n    components = []\n    \n    for i in range(N_theta):\n        for j in range(N_zeta):\n            if M[i, j] and not visited[i, j]:\n                current_component = []\n                q = deque([(i, j)])\n                visited[i, j] = True\n                \n                while q:\n                    ci, cj = q.popleft()\n                    current_component.append((ci, cj))\n                    \n                    # 8-connectivity with periodic boundaries\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            if di == 0 and dj == 0:\n                                continue\n                            \n                            ni = (ci + di) % N_theta\n                            nj = (cj + dj) % N_zeta\n                            \n                            if M[ni, nj] and not visited[ni, nj]:\n                                visited[ni, nj] = True\n                                q.append((ni, nj))\n                components.append(current_component)\n                \n    return components\n\ndef is_poloidally_closed(component, N_theta, N_zeta):\n    \"\"\"\n    Checks if a given component satisfies the \"poloidally closed\" criteria.\n    \n    Args:\n        component (list[tuple[int, int]]): A list of (row, col) coordinates for the component.\n        N_theta (int): The size of the theta dimension.\n        N_zeta (int): The size of the zeta dimension.\n        \n    Returns:\n        bool: True if the component is poloidally closed, False otherwise.\n    \"\"\"\n    # Define thresholds as per the problem statement\n    w_zeta_thresh = math.ceil(0.05 * N_zeta)\n    f_theta_thresh = 0.9\n\n    if not component:\n        # An empty component technically satisfies the condition vacuously\n        return True\n\n    # Step 5a: Compute poloidal coverage fraction f_theta\n    I_theta_set = {coords[0] for coords in component}\n    f_theta = len(I_theta_set) / N_theta\n\n    # Step 5b: Compute toroidal minimal circular span w_zeta\n    I_zeta_set = {coords[1] for coords in component}\n    I_zeta_list = sorted(list(I_zeta_set))\n\n    if len(I_zeta_list) <= 1:\n        # A single point or empty set has a span of 0.\n        w_zeta = 0\n    else:\n        # Calculate gaps between consecutive sorted indices\n        gaps = np.diff(I_zeta_list)\n        # Calculate the wrap-around gap\n        wrap_gap = (I_zeta_list[0] + N_zeta) - I_zeta_list[-1]\n        \n        all_gaps = np.append(gaps, wrap_gap)\n        g_max = np.max(all_gaps)\n        w_zeta = N_zeta - g_max\n\n    # Step 6: Declare if poloidally closed\n    return w_zeta <= w_zeta_thresh and f_theta >= f_theta_thresh\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    # Step 1: Discretization parameters\n    N_theta = 360\n    N_zeta = 360\n    tau = 1e-12\n\n    # Define test cases\n    test_cases_defs = [\n        {'func': lambda th, ze, B0, A: B0 + A - np.sin(ze)**2, 'B0': 1.0, 'A': 0.3}, # Case A\n        {'func': lambda th, ze, B0, A: B0 + A - np.sin(th)**2, 'B0': 1.0, 'A': 0.2}, # Case B\n        {'func': lambda th, ze, B0, A: B0 + A - np.sin(th - ze)**2, 'B0': 1.0, 'A': 0.25} # Case C\n    ]\n\n    results = []\n\n    # Grid generation\n    theta = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    zeta = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n    # meshgrid with 'xy' indexing (default) aligns with (row,col) -> (y,x) -> (theta,zeta)\n    zeta_grid, theta_grid = np.meshgrid(zeta, theta)\n\n    for case_def in test_cases_defs:\n        B_func = case_def['func']\n        \n        # Step 2: Compute B field and B_max\n        B = B_func(theta_grid, zeta_grid, case_def['B0'], case_def['A'])\n        B_max = np.max(B)\n\n        # Step 3: Define the discrete level-set mask\n        M = np.abs(B - B_max) <= tau\n        \n        # Step 4: Identify connected components\n        components = find_components(M, N_theta, N_zeta)\n\n        # Step 7: Check if all components are poloidally closed\n        if not components:\n            # If no components are found, the condition is vacuously true\n            case_result = True\n        else:\n            is_case_valid = all(\n                is_poloidally_closed(comp, N_theta, N_zeta) for comp in components\n            )\n            case_result = is_case_valid\n        \n        results.append(case_result)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3715836"}, {"introduction": "After identifying the geometric properties of a QI field, we now turn to the underlying physics of particle confinement. The quality of confinement for trapped particles is directly related to how the second adiabatic invariant, $J_{\\parallel}$, varies across a flux surface. This practice guides you through the process of numerically calculating $J_{\\parallel}$ and its derivative with respect to the field-line label $\\alpha$, providing a quantitative metric to compare the confinement performance of different stellarator designs. [@problem_id:3715774]", "problem": "You are given two dimensionless model magnetic field spectra, one intended to represent a Quasi-Symmetric (QS) configuration and one intended to represent a Quasi-Isodynamic (QI) configuration, on a torus parameterized by poloidal angle $\\theta$ and toroidal angle $\\zeta$, both in radians. The QS model uses a single helical harmonic, while the QI model uses predominantly toroidal variation with weak poloidal variation. The field-line label is $\\alpha = \\theta - \\iota \\,\\zeta$, where $\\iota$ is the rotational transform, such that along a field line $\\theta(\\zeta) = \\alpha + \\iota \\,\\zeta$. In dimensionless guiding-center theory, the second adiabatic invariant $J_{\\parallel}$ for a trapped particle with dimensionless energy $E$ and pitch parameter $\\lambda$ is defined as the bounce integral $J_{\\parallel}(\\alpha, E, \\lambda) = \\oint v_{\\parallel} \\, dl$, where the parallel speed is $v_{\\parallel}(\\zeta) = \\sqrt{2E}\\,\\sqrt{\\max\\{0,\\,1 - \\lambda \\, B(\\theta(\\zeta),\\zeta)\\}}$ and the line element factor is taken as $dl/d\\zeta = 1$ for simplicity. Use radians for all angles, and treat all quantities as dimensionless.\n\nYour task is to compute the numerical central finite-difference approximation to the derivative $\\partial J_{\\parallel} / \\partial \\alpha$ for both spectra across multiple test cases, and then assess which design better confines trapped particles by comparing the magnitudes of these derivatives. A smaller magnitude of $\\partial J_{\\parallel} / \\partial \\alpha$ implies better confinement of trapped particles.\n\nUse the following spectra with parameters that are scientifically plausible and self-consistent for a reduced model:\n- QS spectrum: $B_{\\mathrm{QS}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon \\cos(m\\,\\theta - n\\,\\zeta) \\right]$.\n- QI spectrum: $B_{\\mathrm{QI}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon_{\\zeta}\\cos(n\\,\\zeta) + \\varepsilon_{\\theta}\\cos(m\\,\\theta) \\right]$.\n\nUse $B_0 = 1$, $\\varepsilon = 0.3$, $\\varepsilon_{\\zeta} = 0.25$, $\\varepsilon_{\\theta} = 0.05$, $m = 1$, $n = 4$, and $\\iota = 0.45$. These choices make both spectra have the same extrema, with $B_{\\min} \\approx 0.7$ and $B_{\\max} \\approx 1.3$, ensuring that trapped-particle conditions are comparable across the two designs for the chosen pitches.\n\nDefine the bounce invariant numerically as\n$$\nJ_{\\parallel}(\\alpha, E, \\lambda) = 2 \\sqrt{2E}\\,\\int_{0}^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda\\,B(\\alpha + \\iota \\zeta, \\zeta)\\}}\\, d\\zeta,\n$$\nwhich integrates the positive part of the parallel speed over one full period and doubles it to cover the full bounce cycle between turning points. Approximate the derivative by the central difference\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}(\\alpha, E, \\lambda) \\approx \\frac{J_{\\parallel}(\\alpha + \\delta\\alpha, E, \\lambda) - J_{\\parallel}(\\alpha - \\delta\\alpha, E, \\lambda)}{2\\,\\delta\\alpha},\n$$\nwith a small step $\\delta\\alpha$.\n\nImplement the numerical integral using a uniform grid in $\\zeta \\in [0, 2\\pi]$ with a sufficiently fine resolution to capture bounce turning points induced by the spectrum. Use $\\delta\\alpha = 10^{-4}$ and a grid of $N = 20001$ points in $\\zeta$.\n\nFor each test case below, compute $\\left|\\partial J_{\\parallel}/\\partial \\alpha\\right|$ for both spectra and output a boolean indicating whether the QI spectrum yields a strictly smaller magnitude than the QS spectrum (true meaning QI is better for that case). If the particle is not trapped for either spectrum in a given case, set $J_{\\parallel} = 0$ in the computation, which will lead to a derivative of $0$, and proceed with the comparison as stated.\n\nTest suite of parameter triples $(\\alpha, E, \\lambda)$, all dimensionless and with angles in radians:\n1. $(\\alpha, E, \\lambda) = (0.7, 0.5, 1.0)$, a typical trapped case.\n2. $(\\alpha, E, \\lambda) = (2.2, 1.5, 1.3)$, a case closer to the upper trapping boundary.\n3. $(\\alpha, E, \\lambda) = (3.0, 0.2, 0.77)$, a case near the lower trapping boundary.\n4. $(\\alpha, E, \\lambda) = (1.1, 1.0, 0.9)$, another typical trapped case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each entry is a boolean corresponding to the respective test case.", "solution": "The problem requires a comparison of trapped particle confinement in two simplified stellarator magnetic field configurations: a Quasi-Symmetric (QS) model and a Quasi-Isodynamic (QI) model. The core principle being tested is that superior confinement of trapped particles in a magnetic fusion device is achieved when the second adiabatic invariant, $J_{\\parallel}$, is nearly constant across a given magnetic flux surface. A magnetic flux surface is a surface on which the magnetic field lines lie. In this simplified model, the field-line label $\\alpha$ acts as a proxy for the spatial coordinate on the flux surface, perpendicular to the magnetic field line itself. Therefore, better confinement corresponds to a smaller magnitude of the gradient of $J_{\\parallel}$ with respect to $\\alpha$, i.e., a smaller value of $|\\partial J_{\\parallel}/\\partial\\alpha|$. Our task is to calculate this quantity for both the QS and QI magnetic spectra for a given set of test parameters and determine which configuration yields a smaller value, indicating better performance for confining trapped particles.\n\nFirst, we define the mathematical components of the problem. The magnetic field-line trajectories are given by $\\theta(\\zeta) = \\alpha + \\iota\\,\\zeta$, where $\\theta$ is the poloidal angle, $\\zeta$ is the toroidal angle, $\\alpha$ is the field-line label, and $\\iota$ is the rotational transform. All angles are in radians.\n\nThe two model magnetic field spectra are given as:\n1.  Quasi-Symmetric (QS) spectrum: $B_{\\mathrm{QS}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon \\cos(m\\,\\theta - n\\,\\zeta) \\right]$. This form depends on a single helical angle $m\\theta - n\\zeta$, characteristic of a quasi-symmetric design.\n2.  Quasi-Isodynamic (QI) spectrum: $B_{\\mathrm{QI}}(\\theta,\\zeta) = B_0 \\left[ 1 + \\varepsilon_{\\zeta}\\cos(n\\,\\zeta) + \\varepsilon_{\\theta}\\cos(m\\,\\theta) \\right]$. This form is dominated by toroidal variation, which is a feature of certain quasi-isodynamic designs.\n\nThe problem specifies the following dimensionless parameters: $B_0 = 1$, $\\varepsilon = 0.3$, $\\varepsilon_{\\zeta} = 0.25$, $\\varepsilon_{\\theta} = 0.05$, $m = 1$, $n = 4$, and $\\iota = 0.45$.\n\nThe second adiabatic invariant, $J_{\\parallel}$, for a trapped particle with energy $E$ and pitch parameter $\\lambda$ is defined by the bounce integral of its parallel velocity, $v_{\\parallel}$, along a field line. The problem provides a specific numerical formulation, which integrates over one full toroidal period ($\\zeta \\in [0, 2\\pi]$) and doubles the result to account for the full bounce motion between turning points:\n$$\nJ_{\\parallel}(\\alpha, E, \\lambda) = 2 \\sqrt{2E}\\,\\int_{0}^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda\\,B(\\alpha + \\iota \\zeta, \\zeta)\\}}\\, d\\zeta\n$$\nThe $\\max\\{0, \\dots\\}$ term ensures that the integrand is zero in regions where the particle is reflected (i.e., where $1 - \\lambda B < 0$), which are outside the trapping well. If a particle is not trapped at all ($1 - \\lambda B \\le 0$ for all $\\zeta$), this integral correctly yields $J_{\\parallel} = 0$.\n\nTo evaluate the confinement quality, we must compute the derivative $\\partial J_{\\parallel}/\\partial\\alpha$. We will use the central finite-difference approximation with a small step size $\\delta\\alpha$:\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}(\\alpha, E, \\lambda) \\approx \\frac{J_{\\parallel}(\\alpha + \\delta\\alpha, E, \\lambda) - J_{\\parallel}(\\alpha - \\delta\\alpha, E, \\lambda)}{2\\,\\delta\\alpha}\n$$\nThe problem specifies a step size of $\\delta\\alpha = 10^{-4}$.\n\nThe numerical procedure is as follows:\n1.  For each of the four test cases $(\\alpha, E, \\lambda)$ and for each magnetic spectrum ($B_{\\mathrm{QS}}$ and $B_{\\mathrm{QI}}$), we will calculate $J_{\\parallel}$.\n2.  The integral for $J_{\\parallel}$ will be computed numerically using the trapezoidal rule over a fine, uniform grid of $N=20001$ points for $\\zeta$ in the range $[0, 2\\pi]$.\n3.  To calculate the derivative $\\partial J_{\\parallel}/\\partial\\alpha$, we compute $J_{\\parallel}$ at two slightly perturbed values of the field-line label, $\\alpha + \\delta\\alpha$ and $\\alpha - \\delta\\alpha$.\n4.  We then substitute these two values into the central difference formula to get an approximation for $\\partial J_{\\parallel}/\\partial\\alpha$.\n5.  Finally, we take the absolute value of the derivatives for both spectra, $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QS}}$ and $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QI}}$.\n6.  The result for each test case is a boolean value indicating whether the QI configuration is superior, which is true if and only if $|\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QI}} < |\\partial J_{\\parallel}/\\partial\\alpha|_{\\mathrm{QS}}$. This entire process will be implemented in a Python script, adhering strictly to the specified libraries and formatting.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the gradient of the second adiabatic invariant for\n    Quasi-Symmetric (QS) and Quasi-Isodynamic (QI) stellarator magnetic fields.\n    \"\"\"\n\n    # Define physical and numerical constants from the problem statement\n    B0 = 1.0\n    EPSILON = 0.3\n    EPSILON_ZETA = 0.25\n    EPSILON_THETA = 0.05\n    M_MODE = 1\n    N_MODE = 4\n    IOTA = 0.45\n    \n    # Numerical parameters for the calculation\n    DELTA_ALPHA = 1e-4\n    N_POINTS = 20001\n    \n    # Define the grid for the toroidal angle zeta\n    ZETA_GRID = np.linspace(0, 2 * np.pi, N_POINTS)\n\n    # Define the model magnetic field spectra\n    def b_qs(theta, zeta):\n        \"\"\"QS spectrum: B = B0 * (1 + epsilon * cos(m*theta - n*zeta))\"\"\"\n        return B0 * (1 + EPSILON * np.cos(M_MODE * theta - N_MODE * zeta))\n\n    def b_qi(theta, zeta):\n        \"\"\"QI spectrum: B = B0 * (1 + epsilon_zeta*cos(n*zeta) + epsilon_theta*cos(m*theta))\"\"\"\n        return B0 * (1 + EPSILON_ZETA * np.cos(N_MODE * zeta) + EPSILON_THETA * np.cos(M_MODE * theta))\n\n    def compute_j_parallel(b_func, alpha, E, lambda_val):\n        \"\"\"\n        Computes the second adiabatic invariant J_parallel numerically.\n        The variable lambda is a keyword in Python, so lambda_val is used.\n        \"\"\"\n        if E == 0:\n            return 0.0\n            \n        # Calculate theta along the field line for the given alpha\n        theta = alpha + IOTA * ZETA_GRID\n        \n        # Calculate the magnetic field strength along the field line\n        b_values = b_func(theta, ZETA_GRID)\n        \n        # Calculate the integrand for J_parallel, handling the turning points\n        integrand = np.sqrt(np.maximum(0, 1 - lambda_val * b_values))\n        \n        # Perform the numerical integration using the trapezoidal rule\n        integral_val = np.trapz(integrand, ZETA_GRID)\n        \n        # Final formula for J_parallel\n        return 2 * np.sqrt(2 * E) * integral_val\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (0.7, 0.5, 1.0),  # Case 1\n        (2.2, 1.5, 1.3),  # Case 2\n        (3.0, 0.2, 0.77), # Case 3\n        (1.1, 1.0, 0.9),  # Case 4\n    ]\n\n    results = []\n    for alpha, E, lambda_val in test_cases:\n        # --- QS Calculation ---\n        # J_parallel for alpha + delta_alpha\n        j_plus_qs = compute_j_parallel(b_qs, alpha + DELTA_ALPHA, E, lambda_val)\n        # J_parallel for alpha - delta_alpha\n        j_minus_qs = compute_j_parallel(b_qs, alpha - DELTA_ALPHA, E, lambda_val)\n        # Central difference for the derivative\n        dj_dalpha_qs = (j_plus_qs - j_minus_qs) / (2 * DELTA_ALPHA)\n\n        # --- QI Calculation ---\n        # J_parallel for alpha + delta_alpha\n        j_plus_qi = compute_j_parallel(b_qi, alpha + DELTA_ALPHA, E, lambda_val)\n        # J_parallel for alpha - delta_alpha\n        j_minus_qi = compute_j_parallel(b_qi, alpha - DELTA_ALPHA, E, lambda_val)\n        # Central difference for the derivative\n        dj_dalpha_qi = (j_plus_qi - j_minus_qi) / (2 * DELTA_ALPHA)\n        \n        # Compare the magnitudes of the derivatives\n        # A smaller magnitude implies better confinement\n        is_qi_better = np.abs(dj_dalpha_qi) < np.abs(dj_dalpha_qs)\n        results.append(is_qi_better)\n\n    # Format the output as a comma-separated list of booleans in brackets\n    # The str() of a boolean is 'True' or 'False' (capitalized)\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3715774"}, {"introduction": "Designing a fusion reactor involves balancing competing objectives, a challenge that is at the forefront of modern stellarator research. This exercise simulates this process by framing the design problem as a multi-objective optimization between physics performance (achieving a quasi-isodynamic state) and engineering feasibility (coil simplicity). By constructing and evaluating a weighted cost function, you will learn how to make quantitative tradeoffs and select an optimal design from a set of candidates, mirroring the state-of-the-art approach in the field. [@problem_id:3715782]", "problem": "You are tasked with constructing and evaluating a simplified, yet physically grounded, multi-objective optimization to quantify the tradeoff between Quasi-Isodynamic (QI) stellarator metrics and coil complexity. The objective is to identify which magnetic field design, represented by a small set of Fourier harmonics, best balances the tendency toward quasi-isodynamic behavior against coil design simplicity under specified weights. Your final program must implement the described formulation and produce a single line result aggregating the answers for all provided test cases.\n\nStart from the guiding-center invariants and the definition of field-line labeling in Boozer coordinates. Use the following fundamental base:\n\n- The second adiabatic invariant $J_{\\parallel}$ is defined as the bounce integral $J_{\\parallel} = \\oint v_{\\parallel} \\, \\mathrm{d}l$, where $v_{\\parallel}$ is the parallel component of the particle velocity and $l$ is the coordinate along the magnetic field line.\n- The Quasi-Isodynamic (QI) requirement can be expressed as small variation of $J_{\\parallel}$ with respect to the field-line label, such that $|\\partial J_{\\parallel} / \\partial \\alpha|$ is small, where $\\alpha$ is the Boozer field-line label.\n- In Boozer coordinates, use $\\alpha = \\theta - \\iota \\, \\zeta$, where $\\theta$ is the poloidal angle, $\\zeta$ is the toroidal angle, and $\\iota$ is the rotational transform.\n- Assume a magnetic field strength model on a flux surface given by a truncated Fourier series\n$$\nB(\\theta,\\zeta) = B_0 \\left( 1 + \\sum_{k=1}^{K} A_k \\cos(m_k \\theta - n_k \\zeta) \\right),\n$$\nwhere $B_0$ is the reference magnetic field strength, $(m_k,n_k)$ are integer harmonic indices, and $A_k$ are the corresponding amplitudes. Take $B_0 = 1$ (dimensionless units).\n- Assume the particle speed has been normalized to $v=1$ and define the pitch parameter $\\lambda$ such that $v_{\\parallel}^2 = 1 - \\lambda B(\\theta,\\zeta)$. Model trapped-passing behavior by setting $v_{\\parallel}(\\theta,\\zeta) = \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\theta,\\zeta)\\}}$.\n\nConstruct the QI variation metric as the root-mean-square of the derivative of $J_{\\parallel}$ with respect to $\\alpha$ across a uniform grid of $\\alpha$ values:\n$$\nQ = \\sqrt{\\frac{1}{N_\\alpha} \\sum_{j=1}^{N_\\alpha} \\left( \\frac{\\partial J_{\\parallel}(\\alpha_j)}{\\partial \\alpha} \\right)^2 },\n$$\nwith the finite-difference approximation for the derivative using periodic boundary conditions on $\\alpha \\in [0,2\\pi)$.\n\nApproximate $J_{\\parallel}(\\alpha)$ by integrating along a field line parameterized by $\\zeta \\in [0,2\\pi)$ using the field-line mapping $\\theta(\\zeta) = \\alpha + \\iota \\zeta$ and a constant line element factor such that\n$$\nJ_{\\parallel}(\\alpha) \\approx \\int_0^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\alpha + \\iota \\zeta,\\,\\zeta)\\}} \\,\\mathrm{d}\\zeta,\n$$\nwhich is dimensionless under the stated normalizations. Use angle units in radians.\n\nDefine a coil complexity proxy by a weighted squared amplitude measure:\n$$\nC = \\sum_{k=1}^{K} w_k A_k^2, \\quad \\text{with} \\quad w_k = m_k^2 + n_k^2,\n$$\nwhich penalizes higher-order harmonics and thus represents increased coil complexity.\n\nForm a weighted-sum multi-objective scalarized cost for each candidate design:\n$$\n\\Phi = w_{\\text{QI}} \\, \\tilde{Q} + w_{\\text{coil}} \\, \\tilde{C},\n$$\nwhere $\\tilde{Q}$ and $\\tilde{C}$ are min-max normalized across all candidate designs being compared under the same test case,\n$$\n\\tilde{Q} = \\frac{Q - Q_{\\min}}{Q_{\\max} - Q_{\\min} + \\epsilon}, \\quad \\tilde{C} = \\frac{C - C_{\\min}}{C_{\\max} - C_{\\min} + \\epsilon},\n$$\nwith a small $\\epsilon$ to avoid division by zero. This normalization ensures that the weights $w_{\\text{QI}}$ and $w_{\\text{coil}}$ operate on comparable scales of the two objectives. All quantities are dimensionless.\n\nYour program must evaluate the following fixed set of harmonics and candidate amplitude vectors:\n- Harmonic set (with phases set to zero): $(m_k,n_k) \\in \\{(1,0),(0,1),(1,1),(2,1),(2,3)\\}$ for $k=1,\\dots,5$.\n- Candidate amplitude vectors $\\mathbf{A}$:\n    1. $\\mathbf{A}^{(0)} = [0.02, 0.03, 0.04, 0.00, 0.00]$\n    2. $\\mathbf{A}^{(1)} = [0.05, 0.03, 0.08, 0.04, 0.02]$\n    3. $\\mathbf{A}^{(2)} = [0.01, 0.02, 0.06, 0.00, 0.03]$\n    4. $\\mathbf{A}^{(3)} = [0.00, 0.00, 0.10, 0.00, 0.00]$\n\nUse the following test suite of cases, each defined by $(w_{\\text{QI}}, w_{\\text{coil}}, \\iota, \\lambda)$:\n- Case 1 (balanced): $(0.6, 0.4, 0.9, 0.7)$\n- Case 2 (QI-only): $(1.0, 0.0, 0.9, 0.7)$\n- Case 3 (coil-only): $(0.0, 1.0, 0.9, 0.7)$\n- Case 4 (near-bounce emphasis): $(0.6, 0.4, 0.5, 0.85)$\n\nFor numerical implementation:\n- Use $N_{\\alpha} = 64$ equispaced samples on $[0,2\\pi)$.\n- Use $N_{\\zeta} = 512$ equispaced samples on $[0,2\\pi)$ for the integral approximation of $J_{\\parallel}(\\alpha)$.\n- Use periodic central differences to approximate $\\partial J_{\\parallel}/\\partial \\alpha$ from the discrete $J_{\\parallel}(\\alpha_j)$ sequence.\n\nTask:\n- For each test case, compute the scalarized cost $\\Phi$ for each candidate amplitude vector.\n- Identify the candidate index (using zero-based indexing consistent with the list above) that minimizes $\\Phi$ for that test case.\n\nAngle units must be radians. All computed quantities are dimensionless. Your program should produce a single line of output containing the indices of the minimizing candidates for the four test cases as a comma-separated list enclosed in square brackets, for example $[\\text{idx}_1,\\text{idx}_2,\\text{idx}_3,\\text{idx}_4]$.", "solution": "The user-provided problem is assessed to be **valid**. It is a well-posed, scientifically grounded computational problem in the domain of stellarator plasma physics. All necessary parameters, equations, and constraints are provided, allowing for a unique and verifiable solution. The underlying model, while a simplification of a real-world design problem, is based on established principles of magnetic confinement fusion, including Boozer coordinates, the second adiabatic invariant, and Fourier representations of magnetic fields. The task is to implement a specified multi-objective optimization algorithm to identify the best magnetic field configuration from a set of candidates under different weighting scenarios.\n\nThe core of the problem is to implement a computational procedure that, for each of four test cases, identifies which of four candidate stellarator magnetic field designs is optimal. Optimality is defined by minimizing a scalarized cost function $\\Phi$, which represents a weighted tradeoff between a physics-based metric for quasi-isodynamic (QI) quality, $Q$, and a proxy for engineering coil complexity, $C$.\n\nThe procedure can be broken down into the following logical steps, which will be implemented for each test case.\n\n**1. Definition of Candidate Designs and Objective Functions**\n\nEach of the four candidate designs is defined by a vector of Fourier amplitudes $\\mathbf{A} = [A_1, \\dots, A_5]$ for a fixed set of harmonic mode numbers $(m_k, n_k)$. The total cost function is given by:\n$$\n\\Phi = w_{\\text{QI}} \\, \\tilde{Q} + w_{\\text{coil}} \\, \\tilde{C}\n$$\nHere, $w_{\\text{QI}}$ and $w_{\\text{coil}}$ are weights specified by the test case. $\\tilde{Q}$ and $\\tilde{C}$ are the normalized values of the QI metric and the coil complexity metric, respectively.\n\n**2. Calculation of the Coil Complexity Metric ($C$)**\n\nThe coil complexity metric, $C$, is a proxy that penalizes magnetic field harmonics with higher mode numbers, as these generally require more complex and difficult-to-manufacture magnet coils. It is calculated as a weighted sum of the squared amplitudes:\n$$\nC = \\sum_{k=1}^{K} w_k A_k^2, \\quad \\text{where} \\quad w_k = m_k^2 + n_k^2\n$$\nThe fixed harmonic mode numbers are $(m_k,n_k) \\in \\{(1,0),(0,1),(1,1),(2,1),(2,3)\\}$. The corresponding weights are $w_k \\in \\{1, 1, 2, 5, 13\\}$. The values of $C$ are computed for each of the four candidate amplitude vectors $\\mathbf{A}^{(0)}, \\mathbf{A}^{(1)}, \\mathbf{A}^{(2)}, \\mathbf{A}^{(3)}$. Since this calculation does not depend on the test case parameters $(\\iota, \\lambda)$, the four values of $C$ can be pre-calculated.\n\n**3. Calculation of the Quasi-Isodynamic Metric ($Q$)**\n\nThe QI metric, $Q$, quantifies the deviation from the ideal quasi-isodynamic condition, which requires that the second adiabatic invariant, $J_{\\parallel}$, does not vary on a flux surface. The variation is measured with respect to the Boozer field-line label $\\alpha = \\theta - \\iota \\zeta$. A smaller value of $Q$ indicates a better approximation to the QI state.\n\nThe calculation of $Q$ for a single candidate design and a given test case $(\\iota, \\lambda)$ involves several sub-steps:\n\n**a. Discretization:** We establish a uniform grid of $N_{\\alpha}=64$ points for the field-line label, $\\alpha_j \\in [0, 2\\pi)$, and a uniform grid of $N_{\\zeta}=512$ points for the toroidal angle, $\\zeta_l \\in [0, 2\\pi)$, to perform numerical integration and differentiation.\n\n**b. Computing $J_{\\parallel}(\\alpha)$:** The second adiabatic invariant $J_{\\parallel}$ is approximated for each discrete value $\\alpha_j$ by the integral:\n$$\nJ_{\\parallel}(\\alpha_j) \\approx \\int_0^{2\\pi} \\sqrt{\\max\\{0,\\,1 - \\lambda B(\\alpha_j + \\iota \\zeta,\\,\\zeta)\\}} \\,\\mathrm{d}\\zeta\n$$\nThis integral is numerically evaluated using the trapezoidal rule. For each point $\\zeta_l$ on the integration grid, we first calculate the corresponding poloidal angle $\\theta_l = \\alpha_j + \\iota \\zeta_l$. Then, the magnetic field strength $B(\\theta_l, \\zeta_l)$ is computed using its Fourier series representation:\n$$\nB(\\theta_l,\\zeta_l) = 1 + \\sum_{k=1}^{K} A_k \\cos(m_k \\theta_l - n_k \\zeta_l)\n$$\nThe integrand $\\sqrt{\\max\\{0, 1-\\lambda B\\}}$ is evaluated at each $\\zeta_l$, and the values are summed and multiplied by the step size $d\\zeta = 2\\pi / N_{\\zeta}$ to yield $J_{\\parallel}(\\alpha_j)$. This process is repeated for all $j=1, \\dots, N_{\\alpha}$, producing an array of $J_{\\parallel}$ values.\n\n**c. Computing the Derivative $\\partial J_{\\parallel} / \\partial \\alpha$:** The derivative of $J_{\\parallel}$ with respect to $\\alpha$ is approximated from the discrete array of $J_{\\parallel}(\\alpha_j)$ values using a periodic central difference scheme:\n$$\n\\frac{\\partial J_{\\parallel}}{\\partial \\alpha}\\bigg|_{\\alpha_j} \\approx \\frac{J_{\\parallel}(\\alpha_{j+1}) - J_{\\parallel}(\\alpha_{j-1})}{2 \\, d\\alpha}\n$$\nwhere $d\\alpha = 2\\pi / N_{\\alpha}$. Periodic boundary conditions are applied at the endpoints of the $\\alpha$ grid.\n\n**d. Computing $Q$:** Finally, the QI metric $Q$ is calculated as the root-mean-square of the computed derivative values:\n$$\nQ = \\sqrt{\\frac{1}{N_\\alpha} \\sum_{j=1}^{N_\\alpha} \\left( \\frac{\\partial J_{\\parallel}(\\alpha_j)}{\\partial \\alpha} \\right)^2 }\n$$\n\nThis entire procedure is performed for each of the four candidate designs to obtain a set of four $Q$ values for the current test case.\n\n**4. Normalization and Optimization**\n\nWith the sets of four raw values $\\{C^{(i)}\\}_{i=0}^3$ and $\\{Q^{(i)}\\}_{i=0}^3$ computed, they are separately normalized to the range $[0, 1]$ using min-max scaling to ensure they are on a comparable basis for the weighted sum:\n$$\n\\tilde{X} = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min} + \\epsilon}\n$$\nwhere $X$ is either $Q$ or $C$, and $\\epsilon$ is a small positive constant (e.g., $10^{-9}$) to prevent division by zero in the case that all values of an objective are identical.\n\nThe final scalarized cost $\\Phi^{(i)}$ is then computed for each candidate $i$ using the weights $w_{\\text{QI}}$ and $w_{\\text{coil}}$ for the current test case. The index $i$ corresponding to the minimum value of $\\Phi^{(i)}$ is identified as the optimal choice for that test case.\n\nThis complete process is repeated for all four test cases, and the resulting indices of the optimal candidates are aggregated into a final list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stellarator design optimization problem by calculating the optimal\n    candidate index for each test case.\n    \"\"\"\n    # Define fixed problem parameters\n    harmonics_mn = np.array([(1, 0), (0, 1), (1, 1), (2, 1), (2, 3)])\n    m_k = harmonics_mn[:, 0]\n    n_k = harmonics_mn[:, 1]\n    \n    candidate_A = [\n        np.array([0.02, 0.03, 0.04, 0.00, 0.00]),\n        np.array([0.05, 0.03, 0.08, 0.04, 0.02]),\n        np.array([0.01, 0.02, 0.06, 0.00, 0.03]),\n        np.array([0.00, 0.00, 0.10, 0.00, 0.00]),\n    ]\n\n    test_cases = [\n        # (w_QI, w_coil, iota, lambda)\n        (0.6, 0.4, 0.9, 0.7),   # Case 1: balanced\n        (1.0, 0.0, 0.9, 0.7),   # Case 2: QI-only\n        (0.0, 1.0, 0.9, 0.7),   # Case 3: coil-only\n        (0.6, 0.4, 0.5, 0.85),  # Case 4: near-bounce emphasis\n    ]\n\n    # Numerical integration and differentiation parameters\n    N_alpha = 64\n    N_zeta = 512\n    epsilon = 1e-9\n\n    # --- Helper Functions ---\n\n    def calculate_C(A, m, n):\n        \"\"\"Calculates the coil complexity metric C.\"\"\"\n        w = m**2 + n**2\n        return np.sum(w * A**2)\n\n    def calculate_Q(A, m, n, iota, lambda_val):\n        \"\"\"Calculates the quasi-isodynamic metric Q.\"\"\"\n        alpha_grid = np.linspace(0, 2 * np.pi, N_alpha, endpoint=False)\n        zeta_grid = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n        d_zeta = 2 * np.pi / N_zeta\n        d_alpha = 2 * np.pi / N_alpha\n\n        J_parallel_values = np.zeros(N_alpha)\n\n        for j, alpha_j in enumerate(alpha_grid):\n            theta_vals = alpha_j + iota * zeta_grid\n\n            # Calculate B field strength across the zeta grid for this alpha\n            B_vals = np.ones_like(zeta_grid) # B0 = 1\n            for k in range(len(A)):\n                if A[k] != 0:\n                    B_vals += A[k] * np.cos(m[k] * theta_vals - n[k] * zeta_grid)\n            \n            # Calculate the integrand for J_parallel\n            integrand = np.sqrt(np.maximum(0, 1 - lambda_val * B_vals))\n            \n            # Approximate the integral using the trapezoidal rule (sum * step)\n            J_parallel_values[j] = np.sum(integrand) * d_zeta\n        \n        # Calculate derivative using periodic central differences\n        dJ_dalpha = (np.roll(J_parallel_values, -1) - np.roll(J_parallel_values, 1)) / (2 * d_alpha)\n        \n        # Calculate Q as the RMS of the derivative\n        Q = np.sqrt(np.mean(np.square(dJ_dalpha)))\n        return Q\n\n    def normalize(values):\n        \"\"\"Performs min-max normalization on a numpy array.\"\"\"\n        val_min = np.min(values)\n        val_max = np.max(values)\n        denominator = val_max - val_min + epsilon\n        if denominator < epsilon:\n            return np.zeros_like(values)\n        return (values - val_min) / denominator\n\n    # --- Main Calculation Loop ---\n    \n    # Pre-calculate C values as they are constant across test cases\n    c_values_all = np.array([calculate_C(A, m_k, n_k) for A in candidate_A])\n\n    results = []\n    for case in test_cases:\n        w_qi, w_coil, iota, lambda_val = case\n        \n        # Calculate Q values for each candidate for the current test case\n        q_values_case = np.array([calculate_Q(A, m_k, n_k, iota, lambda_val) for A in candidate_A])\n        \n        # Normalize Q and C values across the candidates for this case\n        q_norm = normalize(q_values_case)\n        c_norm = normalize(c_values_all)\n        \n        # Calculate the scalarized cost function Phi for each candidate\n        phi_values = w_qi * q_norm + w_coil * c_norm\n        \n        # Find the index of the candidate with the minimum cost\n        best_idx = np.argmin(phi_values)\n        results.append(best_idx)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3715782"}]}