{"hands_on_practices": [{"introduction": "The cornerstone of assessing quasi-symmetry lies in analyzing the magnetic field's structure in Boozer coordinates, where an ideal configuration exhibits a simplified spectrum. This exercise provides a concrete starting point by guiding you through the process of computing the Fourier spectrum of a model magnetic field and using it to quantify its degree of quasi-symmetry. Mastering this foundational skill is essential for diagnosing the performance of any stellarator configuration [@problem_id:3719824].", "problem": "You are given the task of computing the two-dimensional Fourier spectrum of the magnetic field strength in Boozer coordinates to assess quasi-symmetry (QS) on a selected flux surface. Begin from the magnetic field representation in straight-fieldline coordinates and the definition of Boozer coordinates on a flux surface. Assume the following fundamental relations as the base of your derivation: (i) the magnetic field in straight-fieldline angles has the contravariant representation $\\mathbf{B} = \\nabla \\psi \\times \\nabla \\theta + \\iota(\\psi)\\,\\nabla \\phi \\times \\nabla \\psi$, (ii) in Boozer coordinates the covariant components of $\\mathbf{B}$ are flux functions so that the Boozer Jacobian $J_{\\mathrm{B}}$ satisfies $J_{\\mathrm{B}}(\\psi,\\theta,\\phi) = \\left(G(\\psi)+\\iota(\\psi) I(\\psi)\\right)/B^{2}(\\psi,\\theta,\\phi)$, and (iii) the magnetic field strength on a given surface can be expanded as a double Fourier series in Boozer angles, $B(\\theta,\\phi) = \\sum_{m=-m_{\\max}}^{m_{\\max}} \\sum_{n=-n_{\\max}}^{n_{\\max}} B_{m,n}\\,\\mathrm{e}^{\\mathrm{i}(m\\theta - n\\phi)}$. Quasi-symmetry with integers $M$ and $N$ is characterized by the dominance of modes satisfying the selection rule $mM - nN = 0$, which corresponds to $B(\\theta,\\phi)$ depending primarily on a helical angle combination.\n\nYour program must:\n1. Construct synthetic Boozer-coordinate fields $B(\\theta,\\phi)$ on a specified uniform angle grid using superpositions of a dominant helical mode and several subdominant off-resonant modes. Work in radians for all angles.\n2. Compute the discrete Fourier coefficients $B_{m,n}$ using the standard unweighted double-angle average:\n$$\nB_{m,n} \\approx \\frac{1}{N_{\\theta} N_{\\phi}} \\sum_{j=0}^{N_{\\theta}-1}\\sum_{k=0}^{N_{\\phi}-1} B(\\theta_{j},\\phi_{k})\\,\\mathrm{e}^{-\\mathrm{i}(m\\theta_{j} - n\\phi_{k})},\n$$\nwhere $\\theta_{j} = 2\\pi j/N_{\\theta}$ and $\\phi_{k} = 2\\pi k/N_{\\phi}$. This approximation is exact for the synthetic cosine content defined below on a uniform grid.\n3. Quantify quasi-symmetry by the ratio\n$$\n\\mathcal{R} = \\frac{\\sum_{(m,n)\\in \\mathcal{S}} \\lvert B_{m,n}\\rvert^{2}}{\\sum_{(m,n)\\neq (0,0)} \\lvert B_{m,n}\\rvert^{2}},\n$$\nwhere $\\mathcal{S} = \\{(m,n) \\in \\mathbb{Z}^{2} : mM - nN = 0,\\ (m,n)\\neq(0,0)\\}$. Exclude the mean mode $(0,0)$ from both numerator and denominator. If the denominator vanishes (uniform field), define $\\mathcal{R} = 1$.\n4. Compare $\\mathcal{R}$ to a case-specific threshold $\\tau$ and return a boolean indicating whether $\\mathcal{R} \\ge \\tau$.\n\nYou are provided with a test suite of four cases. In each case, treat $I(\\psi)$ and $G(\\psi)$ as given flux functions (constants on the surface); they are included for completeness from the Variational Moments Equilibrium Code (VMEC) outputs but are not needed to compute the Fourier series from a uniform Boozer grid. All angles must be in radians, and the base magnetic field strength $B_{0}$ must be interpreted in tesla; however, the final outputs are dimensionless booleans and require no units. For each case, synthesize\n$$\nB(\\theta,\\phi) = B_{0}\\left[1 + \\varepsilon \\cos(m_{0}\\theta - n_{0}\\phi)\\right] + \\sum_{\\ell=1}^{L} a_{\\ell}\\cos(m_{\\ell}\\theta - n_{\\ell}\\phi + \\varphi_{\\ell}),\n$$\nwith specified amplitudes and phases $\\varphi_{\\ell}$.\n\nTest suite (each case is a tuple of parameters):\n- Case $1$ (happy path, strong quasi-symmetry):\n    - Grid: $N_{\\theta} = 64$, $N_{\\phi} = 64$.\n    - VMEC-like flux functions: $I(\\psi) = 2.0$, $G(\\psi) = 3.0$.\n    - Symmetry integers: $M=1$, $N=1$.\n    - Base field: $B_{0} = 3.0$ tesla.\n    - Dominant mode: $(m_{0},n_{0}) = (1,1)$ with $\\varepsilon = 0.2$.\n    - Off-resonant modes: $[(2,1,0.02,0.0), (1,0,0.015,0.3), (3,2,0.01,1.0)]$, interpreted as $(m_{\\ell},n_{\\ell},a_{\\ell},\\varphi_{\\ell})$.\n    - Spectral bounds: $m_{\\max}=4$, $n_{\\max}=4$.\n    - Threshold: $\\tau = 0.9$.\n- Case $2$ (near boundary, moderate quasi-symmetry):\n    - Grid: $N_{\\theta} = 64$, $N_{\\phi} = 64$.\n    - VMEC-like flux functions: $I(\\psi) = 1.0$, $G(\\psi) = 2.5$.\n    - Symmetry integers: $M=2$, $N=1$.\n    - Base field: $B_{0} = 2.5$ tesla.\n    - Dominant mode: $(m_{0},n_{0}) = (1,2)$ with $\\varepsilon = 0.05$.\n    - Off-resonant modes: $[(1,0,0.04,0.2), (0,1,0.03,0.5), (3,1,0.03,0.7)]$.\n    - Spectral bounds: $m_{\\max}=4$, $n_{\\max}=4$.\n    - Threshold: $\\tau = 0.6$.\n- Case $3$ (non-quasi-symmetric, failure expected):\n    - Grid: $N_{\\theta} = 64$, $N_{\\phi} = 64$.\n    - VMEC-like flux functions: $I(\\psi) = 0.5$, $G(\\psi) = 3.5$.\n    - Symmetry integers: $M=3$, $N=1$.\n    - Base field: $B_{0} = 2.8$ tesla.\n    - Dominant mode: none (set $\\varepsilon = 0$).\n    - Off-resonant modes: $[(1,0,0.06,0.1), (2,3,0.05,0.4), (3,0,0.04,1.1)]$.\n    - Spectral bounds: $m_{\\max}=5$, $n_{\\max}=5$.\n    - Threshold: $\\tau = 0.5$.\n- Case $4$ (edge case, uniform field):\n    - Grid: $N_{\\theta} = 64$, $N_{\\phi} = 64$.\n    - VMEC-like flux functions: $I(\\psi) = 1.0$, $G(\\psi) = 1.0$.\n    - Symmetry integers: $M=1$, $N=1$.\n    - Base field: $B_{0} = 3.2$ tesla.\n    - Dominant mode: none (set $\\varepsilon = 0$).\n    - Off-resonant modes: empty list.\n    - Spectral bounds: $m_{\\max}=3$, $n_{\\max}=3$.\n    - Threshold: $\\tau = 0.99$.\n\nYour program must:\n- Implement the synthesis of $B(\\theta,\\phi)$ for each case, compute the discrete spectrum $B_{m,n}$ over the prescribed spectral bounds, compute $\\mathcal{R}$, compare to $\\tau$, and output a single line containing a list with four boolean values $[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$ indicating whether each case satisfies quasi-symmetry under the stated criterion.\n- The final output must be exactly one line, with the list printed in Python boolean literal form enclosed in square brackets.", "solution": "The problem is valid as it is scientifically grounded in the principles of plasma physics and stellarator theory, is well-posed with a clear objective and all necessary data, and is expressed in objective, formal language. We can therefore proceed with a solution.\n\nThe objective is to assess the degree of quasi-symmetry (QS) for a synthetically generated magnetic field strength $B$ on a flux surface. Quasi-symmetry is a property of the magnetic field configuration in a stellarator where the magnetic field strength, when expressed in Boozer coordinates $(\\theta, \\phi)$, is a function of a single helical angle, $B = B(m\\theta - n\\phi)$. This implies that the Fourier spectrum of $B$ is dominated by modes $(m, n)$ that satisfy a specific linear relationship, $mM - nN = 0$, for some integers $M$ and $N$.\n\nThe problem provides a synthetic model for the magnetic field strength on a given flux surface:\n$$\nB(\\theta,\\phi) = B_{0}\\left[1 + \\varepsilon \\cos(m_{0}\\theta - n_{0}\\phi)\\right] + \\sum_{\\ell=1}^{L} a_{\\ell}\\cos(m_{\\ell}\\theta - n_{\\ell}\\phi + \\varphi_{\\ell})\n$$\nWe are asked to compute the two-dimensional Fourier spectrum $B_{m,n}$ and use it to calculate a quasi-symmetry metric $\\mathcal{R}$. The magnetic field is represented by the Fourier series:\n$$\nB(\\theta,\\phi) = \\sum_{m,n} B_{m,n}\\,\\mathrm{e}^{\\mathrm{i}(m\\theta - n\\phi)}\n$$\nThe problem states that for the given synthetic form of $B(\\theta,\\phi)$, the provided discrete Fourier transform formula yields exact results. This allows us to determine the coefficients $B_{m,n}$ analytically, which is more precise than a numerical implementation of the DFT.\n\nWe use Euler's formula, $\\cos(x) = \\frac{1}{2}(\\mathrm{e}^{\\mathrm{i}x} + \\mathrm{e}^{-\\mathrm{i}x})$, to decompose each cosine term in the expression for $B(\\theta, \\phi)$.\nA general term of the form $\\alpha \\cos(m_k\\theta - n_k\\phi + \\varphi_k)$ can be written as:\n$$\n\\alpha \\cos(m_k\\theta - n_k\\phi + \\varphi_k) = \\frac{\\alpha}{2}\\left( \\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi + \\varphi_k)} + \\mathrm{e}^{-\\mathrm{i}(m_k\\theta - n_k\\phi + \\varphi_k)} \\right)\n$$\n$$\n= \\left(\\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_k}\\right)\\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi)} + \\left(\\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_k}\\right)\\mathrm{e}^{\\mathrm{i}(-m_k\\theta - (-n_k)\\phi)}\n$$\nBy comparing this with the Fourier series definition, we can identify the coefficients:\n- The term $\\mathrm{e}^{\\mathrm{i}(m_k\\theta - n_k\\phi)}$ contributes to the coefficient $B_{m_k,n_k}$.\n- The term $\\mathrm{e}^{\\mathrm{i}(-m_k\\theta - (-n_k)\\phi)}$ contributes to the coefficient $B_{-m_k,-n_k}$.\n\nThus, for each cosine component, we have a pair of non-zero Fourier coefficients:\n- $B_{m_k,n_k} = \\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_k}$\n- $B_{-m_k,-n_k} = \\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_k} = (B_{m_k,n_k})^*$\n\nThe full set of analytical coefficients for the given $B(\\theta,\\phi)$ is:\n1.  The constant term $B_0$ corresponds to the $(m,n)=(0,0)$ mode: $B_{0,0} = B_0$.\n2.  The \"dominant\" mode with amplitude $\\varepsilon B_0$ and phase $\\varphi_0=0$ gives:\n    $B_{m_0,n_0} = \\frac{\\varepsilon B_0}{2}$ and $B_{-m_0,-n_0} = \\frac{\\varepsilon B_0}{2}$.\n3.  Each \"off-resonant\" mode $\\ell$ with amplitude $a_\\ell$ and phase $\\varphi_\\ell$ gives:\n    $B_{m_\\ell,n_\\ell} = \\frac{a_\\ell}{2}\\mathrm{e}^{\\mathrm{i}\\varphi_\\ell}$ and $B_{-m_\\ell,-n_\\ell} = \\frac{a_\\ell}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi_\\ell}$.\n\nWith these coefficients, we compute the quasi-symmetry ratio $\\mathcal{R}$:\n$$\n\\mathcal{R} = \\frac{\\sum_{(m,n)\\in \\mathcal{S}} \\lvert B_{m,n}\\rvert^{2}}{\\sum_{(m,n)\\neq (0,0)} \\lvert B_{m,n}\\rvert^{2}}\n$$\nwhere $\\mathcal{S} = \\{(m,n) \\in \\mathbb{Z}^{2} : mM - nN = 0, (m,n)\\neq(0,0)\\}$. The numerator is the sum of the squared magnitudes of all non-zero, non-DC Fourier coefficients that satisfy the quasi-symmetry condition. The denominator is the sum of the squared magnitudes of all non-DC Fourier coefficients.\nIf the denominator is zero (i.e., the field is uniform, $B=B_0$), $\\mathcal{R}$ is defined to be $1$.\n\nThe algorithm for each test case is as follows:\n1.  Initialize a dictionary to store the complex Fourier coefficients $B_{m,n}$ for non-zero, non-DC modes.\n2.  Analytically compute the coefficients for the dominant and off-resonant modes and populate the dictionary. For a mode $(m, n, \\alpha, \\varphi)$, we add $\\frac{\\alpha}{2}\\mathrm{e}^{\\mathrm{i}\\varphi}$ to the dictionary entry for $(m,n)$ and $\\frac{\\alpha}{2}\\mathrm{e}^{-\\mathrm{i}\\varphi}$ to the entry for $(-m,-n)$.\n3.  Calculate the denominator term by summing $|B_{m,n}|^2$ over all entries in the dictionary.\n4.  Calculate the numerator term by summing $|B_{m,n}|^2$ only for those entries $(m,n)$ that satisfy the case-specific symmetry condition $mM - nN = 0$.\n5.  Compute $\\mathcal{R}$, handling the special case of a zero denominator.\n6.  Compare $\\mathcal{R}$ with the threshold $\\tau$ and determine the boolean result.\n\nThis analytical method is exact for the given problem structure and avoids the complexities and potential floating-point inaccuracies of a numerical FFT implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the quasi-symmetry problem for a suite of four test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, strong quasi-symmetry)\n        {\n            \"grid\": (64, 64), \"vmec\": (2.0, 3.0), \"symmetry\": (1, 1),\n            \"base_field\": 3.0, \"dominant_mode\": (1, 1, 0.2), \n            \"off_resonant_modes\": [(2, 1, 0.02, 0.0), (1, 0, 0.015, 0.3), (3, 2, 0.01, 1.0)],\n            \"spectral_bounds\": (4, 4), \"threshold\": 0.9\n        },\n        # Case 2 (near boundary, moderate quasi-symmetry)\n        {\n            \"grid\": (64, 64), \"vmec\": (1.0, 2.5), \"symmetry\": (2, 1),\n            \"base_field\": 2.5, \"dominant_mode\": (1, 2, 0.05),\n            \"off_resonant_modes\": [(1, 0, 0.04, 0.2), (0, 1, 0.03, 0.5), (3, 1, 0.03, 0.7)],\n            \"spectral_bounds\": (4, 4), \"threshold\": 0.6\n        },\n        # Case 3 (non-quasi-symmetric, failure expected)\n        {\n            \"grid\": (64, 64), \"vmec\": (0.5, 3.5), \"symmetry\": (3, 1),\n            \"base_field\": 2.8, \"dominant_mode\": (0, 0, 0.0),\n            \"off_resonant_modes\": [(1, 0, 0.06, 0.1), (2, 3, 0.05, 0.4), (3, 0, 0.04, 1.1)],\n            \"spectral_bounds\": (5, 5), \"threshold\": 0.5\n        },\n        # Case 4 (edge case, uniform field)\n        {\n            \"grid\": (64, 64), \"vmec\": (1.0, 1.0), \"symmetry\": (1, 1),\n            \"base_field\": 3.2, \"dominant_mode\": (0, 0, 0.0),\n            \"off_resonant_modes\": [],\n            \"spectral_bounds\": (3, 3), \"threshold\": 0.99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        M, N = case[\"symmetry\"]\n        B0 = case[\"base_field\"]\n        m0, n0, epsilon = case[\"dominant_mode\"]\n        off_resonant = case[\"off_resonant_modes\"]\n        tau = case[\"threshold\"]\n\n        # Use a defaultdict to store complex Fourier coefficients B_mn\n        # for (m,n) != (0,0)\n        coeffs = defaultdict(complex)\n\n        # Process dominant mode\n        if epsilon > 0.0:\n            m, n = m0, n0\n            alpha = B0 * epsilon\n            # For a cosine term alpha*cos(m*theta - n*phi), the coefficients are\n            # B_mn = alpha/2 and B_-m,-n = alpha/2\n            if m != 0 or n != 0:\n                coeffs[(m, n)] += alpha / 2.0\n                coeffs[(-m, -n)] += alpha / 2.0\n\n        # Process off-resonant modes\n        for m_l, n_l, a_l, phi_l in off_resonant:\n            m, n = m_l, n_l\n            alpha = a_l\n            val = (alpha / 2.0) * np.exp(1j * phi_l)\n            # For a term a*cos(m*theta - n*phi + phi_l), the coefficients are\n            # B_mn = (a/2)*exp(i*phi_l) and B_-m,-n = (a/2)*exp(-i*phi_l)\n            if m != 0 or n != 0:\n                coeffs[(m, n)] += val\n                coeffs[(-m, -n)] += np.conj(val)\n\n        # Calculate the numerator and denominator for the ratio R\n        numerator_sum_sq = 0.0\n        denominator_sum_sq = 0.0\n\n        for (m, n), b_mn in coeffs.items():\n            power = np.abs(b_mn)**2\n            denominator_sum_sq += power\n            \n            # Check for quasi-symmetry condition: mM - nN = 0\n            if m * M - n * N == 0:\n                numerator_sum_sq += power\n\n        # Calculate R\n        if denominator_sum_sq == 0.0:\n            # Uniform field case, as defined in the problem\n            R = 1.0\n        else:\n            R = numerator_sum_sq / denominator_sum_sq\n            \n        results.append(R >= tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3719824"}, {"introduction": "In practical applications, the Fourier coefficients of a magnetic field are computed using numerical quadrature on a discrete grid, not through symbolic integration. This practice explores how the choice of this grid critically affects the accuracy of the calculated spectrum and the resulting quasi-symmetry metric [@problem_id:3719877]. By comparing a simple uniform grid with a more sophisticated Gauss-Legendre grid, you will gain valuable insight into the trade-offs between computational cost and numerical fidelity that are central to reliable physics simulations.", "problem": "You are given a periodic function on the angular torus that represents the magnitude of the magnetic field on a fixed flux surface in a stellarator, written in terms of the poloidal angle $\\theta$ and the toroidal angle $\\zeta$, both measured in radians. In the context of nuclear fusion and stellarator optimization by quasi-symmetry (QS), define the complex double-Fourier coefficients $B_{m,n}$ by the fundamental relation\n$$\nB_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta,\n$$\nfor integers $m$ and $n$. Consider the analytic magnetic field magnitude\n$$\nB(\\theta,\\zeta) = B_0 + \\epsilon_1 \\cos(\\bar{m}\\,\\theta - \\bar{n}\\,\\zeta) + \\epsilon_2 \\cos(2\\theta) + \\epsilon_3 \\cos(3\\zeta) + \\epsilon_4 \\cos(2\\bar{m}\\,\\theta - 2\\bar{n}\\,\\zeta),\n$$\nwith parameters $B_0$, $\\epsilon_1$, $\\epsilon_2$, $\\epsilon_3$, $\\epsilon_4$, and target quasi-symmetry direction $(\\bar{m},\\bar{n})$. The quasi-symmetry (QS) metric is defined from the same fundamental base as a ratio of spectral energy off the QS helical line to the total non-constant spectral energy. Let the QS helical set $\\mathcal{S}$ within a truncation domain be\n$$\n\\mathcal{S} = \\{(k\\bar{m}, k\\bar{n}) : k \\in \\mathbb{Z} \\text{ and } (k\\bar{m}, k\\bar{n}) \\text{ is in the truncation}\\},\n$$\nand define the QS metric\n$$\n\\mathcal{M}_{\\mathrm{QS}} = \\frac{\\sum_{(m,n) \\in \\mathcal{R} \\setminus (\\mathcal{S} \\cup \\{(0,0)\\})} |B_{m,n}|^2}{\\sum_{(m,n) \\in \\mathcal{R} \\setminus \\{(0,0)\\}} |B_{m,n}|^2},\n$$\nwhere $\\mathcal{R}$ is the chosen rectangular truncation in $(m,n)$-space. Angles must be handled strictly in radians.\n\nYour task is to quantify the effect of collocation grid choice in $(\\theta,\\zeta)$ on the accuracy of the computed $B_{m,n}$ and the QS metric. Use two quadrature strategies to approximate the double integral: \n- a uniform periodic trapezoidal grid with $N_\\theta$ and $N_\\zeta$ points and equal weights $w_\\theta = 2\\pi/N_\\theta$, $w_\\zeta = 2\\pi/N_\\zeta$, and\n- a tensor-product Gauss–Legendre grid with $N_\\theta$ and $N_\\zeta$ nodes mapped from $[-1,1]$ to $[0,2\\pi]$, where the mapped nodes are $\\theta_i = \\pi(x_i+1)$ and $\\zeta_j = \\pi(y_j+1)$ and the mapped weights are $w_{\\theta,i} = \\pi\\,\\omega_i$, $w_{\\zeta,j} = \\pi\\,\\nu_j$, for nodes $(x_i,\\omega_i)$ and $(y_j,\\nu_j)$ respectively.\n\nFrom first principles, the discrete approximations to $B_{m,n}$ are obtained by replacing the integrals with the corresponding weighted sums over the chosen nodes. Using these, compute the approximated QS metric for each grid, and compare it to the analytic ground truth obtained directly from the given $B(\\theta,\\zeta)$.\n\nUse the following parameter values and truncation:\n- Target helical direction $(\\bar{m},\\bar{n}) = (2,1)$.\n- Coefficients: $B_0 = 1.0$, $\\epsilon_1 = 0.3$, $\\epsilon_2 = 0.1$, $\\epsilon_3 = 0.08$, $\\epsilon_4 = 0.05$.\n- Truncation rectangle $\\mathcal{R}$ given by $m \\in \\{-M,\\ldots,M\\}$ and $n \\in \\{-N,\\ldots,N\\}$ with $M = 6$ and $N = 6$.\n\nDefine the test suite of three collocation grids $(N_\\theta,N_\\zeta)$:\n- Test $1$: $(N_\\theta,N_\\zeta) = (16,16)$.\n- Test $2$: $(N_\\theta,N_\\zeta) = (8,8)$.\n- Test $3$: $(N_\\theta,N_\\zeta) = (64,16)$.\n\nFor each test case, compute:\n- The absolute QS metric error for Gauss–Legendre and uniform grids, defined as $|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$, where $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$ is the metric computed from the numerical $B_{m,n}$ and $\\mathcal{M}_{\\mathrm{QS}}$ is the analytic metric.\n- The relative $\\ell_2$ error in the full coefficient array over $\\mathcal{R}$ for Gauss–Legendre and uniform grids, defined as \n$$\n\\frac{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}}.\n$$\n\nFinally, recommend a grid type that minimizes QS metric error across the suite by comparing the average absolute QS metric error over the three test cases. Encode the recommendation as an integer: output $0$ if the uniform grid has lower or equal average QS metric error, and $1$ if the Gauss–Legendre grid does.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order:\n$[$error$_{\\mathrm{GL},1}$, error$_{\\mathrm{U},1}$, coeffErr$_{\\mathrm{GL},1}$, coeffErr$_{\\mathrm{U},1}$, error$_{\\mathrm{GL},2}$, error$_{\\mathrm{U},2}$, coeffErr$_{\\mathrm{GL},2}$, coeffErr$_{\\mathrm{U},2}$, error$_{\\mathrm{GL},3}$, error$_{\\mathrm{U},3}$, coeffErr$_{\\mathrm{GL},3}$, coeffErr$_{\\mathrm{U},3}$, recommendation$]$.\n\nAll angles must be treated in radians, and all outputs must be real numbers (floats) or integers as specified. No other text should be printed.", "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe problem provides the following information:\n\n1.  **Magnetic Field Function**: The magnitude of the magnetic field on a flux surface is given as a periodic function of poloidal angle $\\theta$ and toroidal angle $\\zeta$:\n    $B(\\theta,\\zeta) = B_0 + \\epsilon_1 \\cos(\\bar{m}\\,\\theta - \\bar{n}\\,\\zeta) + \\epsilon_2 \\cos(2\\theta) + \\epsilon_3 \\cos(3\\zeta) + \\epsilon_4 \\cos(2\\bar{m}\\,\\theta - 2\\bar{n}\\,\\zeta)$.\n2.  **Fourier Coefficients**: The complex double-Fourier coefficients $B_{m,n}$ are defined by:\n    $B_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta$.\n3.  **Quasi-Symmetry (QS) Metric**: The QS metric, $\\mathcal{M}_{\\mathrm{QS}}$, is defined as a ratio of spectral power:\n    $\\mathcal{M}_{\\mathrm{QS}} = \\frac{\\sum_{(m,n) \\in \\mathcal{R} \\setminus (\\mathcal{S} \\cup \\{(0,0)\\})} |B_{m,n}|^2}{\\sum_{(m,n) \\in \\mathcal{R} \\setminus \\{(0,0)\\}} |B_{m,n}|^2}$.\n4.  **QS Helical Set**: The set of quasi-symmetric modes, $\\mathcal{S}$, is defined as:\n    $\\mathcal{S} = \\{(k\\bar{m}, k\\bar{n}) : k \\in \\mathbb{Z} \\text{ and } (k\\bar{m}, k\\bar{n}) \\text{ is in the truncation}\\}$.\n5.  **Parameters**:\n    *   Target quasi-symmetry direction: $(\\bar{m},\\bar{n}) = (2,1)$.\n    *   Field coefficients: $B_0 = 1.0$, $\\epsilon_1 = 0.3$, $\\epsilon_2 = 0.1$, $\\epsilon_3 = 0.08$, $\\epsilon_4 = 0.05$.\n6.  **Truncation Domain**: The rectangular truncation $\\mathcal{R}$ is defined by $m \\in \\{-6, \\dots, 6\\}$ and $n \\in \\{-6, \\dots, 6\\}$.\n7.  **Numerical Methods**:\n    *   Uniform periodic trapezoidal grid with $N_\\theta, N_\\zeta$ points and weights $w_\\theta = 2\\pi/N_\\theta$, $w_\\zeta = 2\\pi/N_\\zeta$.\n    *   Tensor-product Gauss–Legendre grid with $N_\\theta, N_\\zeta$ nodes mapped from $[-1,1]$ to $[0,2\\pi]$.\n8.  **Test Cases**: Three collocation grids $(N_\\theta, N_\\zeta)$:\n    *   Test 1: $(16,16)$.\n    *   Test 2: $(8,8)$.\n    *   Test 3: $(64,16)$.\n9.  **Error Metrics**:\n    *   Absolute QS metric error: $|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$.\n    *   Relative $\\ell_2$ coefficient error: $\\frac{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{(m,n)\\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}}$.\n10. **Final Task**: Recommend a grid type (uniform or Gauss-Legendre) based on the average absolute QS metric error across the three tests, encoded as $0$ for uniform (if its error is less than or equal to GL) and $1$ for Gauss-Legendre (if its error is strictly less).\n11. **Output Format**: A single line, comma-separated list of results enclosed in square brackets.\n\n#### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria:\n\n*   **Scientifically Grounded**: The problem is firmly rooted in the field of nuclear fusion, specifically the design of stellarator magnetic confinement devices. The concepts of quasi-symmetry, Fourier analysis of magnetic fields on a torus, and numerical quadrature are standard and fundamental in this area.\n*   **Well-Posed**: The problem is well-posed. All parameters, functions, and objectives are clearly defined. The analytic form of the magnetic field allows for the calculation of an exact ground truth, against which the numerical methods can be unambiguously compared. A unique solution exists for all required calculations.\n*   **Objective**: The language is precise, quantitative, and free of subjectivity.\n*   **Consistency and Completeness**: The problem provides all necessary data and definitions. There are no apparent contradictions. The request to compare numerical quadrature methods against an analytic solution is a standard and valuable exercise in computational science.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, reliance on pseudoscience, incompleteness, or ambiguity.\n\n#### Step 3: Verdict and Action\n\nThe problem is **valid**. Proceeding to the solution.\n\n### Solution\n\nThe objective is to assess the accuracy of two numerical quadrature schemes—the uniform periodic trapezoidal rule and Gauss-Legendre quadrature—for computing the Fourier spectrum and a derived quasi-symmetry (QS) metric of a stellarator magnetic field.\n\n#### 1. Analytic Ground Truth Calculation\n\nThe first step is to determine the exact Fourier coefficients, $B_{m,n}$, of the given magnetic field $B(\\theta,\\zeta)$. The field is a sum of cosine terms, and its coefficients can be found by leveraging Euler's formula, $\\cos(x) = \\frac{1}{2}(e^{ix} + e^{-ix})$, and the orthogonality of complex exponentials over the domain $[0, 2\\pi] \\times [0, 2\\pi]$.\n\nThe definition of the Fourier coefficient is:\n$$B_{m,n} = \\frac{1}{4\\pi^2} \\int_{0}^{2\\pi} \\int_{0}^{2\\pi} B(\\theta,\\zeta)\\, e^{-i(m\\theta - n\\zeta)} \\, d\\theta \\, d\\zeta$$\nFor a term of the form $C \\cos(A\\theta - B\\zeta) = \\frac{C}{2}(e^{i(A\\theta - B\\zeta)} + e^{-i(A\\theta - B\\zeta)})$, the integral is non-zero only when the exponents cancel. The term $e^{i(A\\theta - B\\zeta)}$ contributes to $B_{A,B}$ and the term $e^{-i(A\\theta - B\\zeta)}$ contributes to $B_{-A,-B}$. In both cases, the coefficient is $\\frac{C}{2}$.\n\nFor the given $B(\\theta,\\zeta)$ with parameters $(\\bar{m},\\bar{n}) = (2,1)$, $B_0=1.0$, $\\epsilon_1=0.3$, $\\epsilon_2=0.1$, $\\epsilon_3=0.08$, $\\epsilon_4=0.05$, the non-zero analytic coefficients are:\n*   $B_{0,0} = B_0 = 1.0$ (from the constant term)\n*   $B_{2,1} = B_{-2,-1} = \\epsilon_1/2 = 0.15$ (from $\\epsilon_1 \\cos(2\\theta - \\zeta)$)\n*   $B_{2,0} = B_{-2,0} = \\epsilon_2/2 = 0.05$ (from $\\epsilon_2 \\cos(2\\theta)$)\n*   $B_{0,3} = B_{0,-3} = \\epsilon_3/2 = 0.04$ (from $\\epsilon_3 \\cos(3\\zeta) = \\epsilon_3 \\cos(0\\theta - (-3)\\zeta)$)\n*   $B_{4,2} = B_{-4,-2} = \\epsilon_4/2 = 0.025$ (from $\\epsilon_4 \\cos(4\\theta - 2\\zeta)$)\nAll other $B_{m,n}$ coefficients are zero.\n\nNext, we compute the analytic QS metric, $\\mathcal{M}_{\\mathrm{QS}}$. The truncation domain is $\\mathcal{R} = \\{(m,n) | m,n \\in \\{-6, ..., 6\\}\\}$. The QS helical set is $\\mathcal{S} = \\{(2k, k)\\}$ for integer $k$. The non-zero modes in $\\mathcal{S}$ are $(\\pm 2, \\pm 1)$ and $(\\pm 4, \\pm 2)$. The modes not in $\\mathcal{S}$ (the \"non-QS\" modes) are $(\\pm 2, 0)$ and $(0, \\pm 3)$.\n\nThe numerator of $\\mathcal{M}_{\\mathrm{QS}}$ is the sum of squared magnitudes of non-zero, non-constant, non-QS modes:\n$$ \\sum_{\\text{non-QS}} |B_{m,n}|^2 = |B_{2,0}|^2 + |B_{-2,0}|^2 + |B_{0,3}|^2 + |B_{0,-3}|^2 = 2 \\cdot (0.05)^2 + 2 \\cdot (0.04)^2 = 0.0082 $$\nThe denominator is the sum of squared magnitudes of all non-zero, non-constant modes:\n$$ \\sum_{\\text{non-zero AC}} |B_{m,n}|^2 = 2|B_{2,1}|^2 + 2|B_{2,0}|^2 + 2|B_{0,3}|^2 + 2|B_{4,2}|^2 $$\n$$ = 2 \\cdot (0.15)^2 + 2 \\cdot (0.05)^2 + 2 \\cdot (0.04)^2 + 2 \\cdot (0.025)^2 = 0.045 + 0.005 + 0.0032 + 0.00125 = 0.05445 $$\nThe analytic QS metric is:\n$$ \\mathcal{M}_{\\mathrm{QS}} = \\frac{0.0082}{0.05445} \\approx 0.15059687786960515 $$\n\n#### 2. Numerical Quadrature Schemes\n\nThe integral for $B_{m,n}$ is approximated by a weighted sum over a discrete grid of points $(\\theta_i, \\zeta_j)$:\n$$ \\widehat{B}_{m,n} = \\frac{1}{4\\pi^2} \\sum_{i=1}^{N_\\theta} \\sum_{j=1}^{N_\\zeta} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} \\, w_{\\theta,i} w_{\\zeta,j} $$\n\n**Uniform Periodic Trapezoidal Grid**:\nThe nodes are equally spaced: $\\theta_i = \\frac{2\\pi i}{N_\\theta}$ for $i=0, \\dots, N_\\theta - 1$ and $\\zeta_j = \\frac{2\\pi j}{N_\\zeta}$ for $j=0, \\dots, N_\\zeta - 1$. The weights are constant: $w_{\\theta,i} = \\frac{2\\pi}{N_\\theta}$ and $w_{\\zeta,j} = \\frac{2\\pi}{N_\\zeta}$.\nThe approximation becomes:\n$$ \\widehat{B}_{m,n} = \\frac{1}{N_\\theta N_\\zeta} \\sum_{i=0}^{N_\\theta-1} \\sum_{j=0}^{N_\\zeta-1} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} $$\nThis is a 2D discrete Fourier transform, which is known to be spectrally accurate for band-limited periodic functions if the grid is fine enough to satisfy the Nyquist criterion.\n\n**Gauss-Legendre Grid**:\nThis method uses nodes and weights optimized for integrating polynomials. The standard Gauss-Legendre nodes $x_k$ and weights $\\omega_k$ are defined on $[-1,1]$. They are mapped to the $[0, 2\\pi]$ interval:\n*   Nodes: $\\theta_i = \\pi(x_i+1)$, $\\zeta_j = \\pi(y_j+1)$\n*   Weights: $w_{\\theta,i} = \\pi \\omega_{\\theta,i}$, $w_{\\zeta,j} = \\pi \\omega_{\\zeta,j}$ (The factor $\\pi$ comes from the Jacobian of the linear transformation $d\\theta = \\pi dx$).\nThe approximation is:\n$$ \\widehat{B}_{m,n} = \\frac{1}{4} \\sum_{i=1}^{N_\\theta} \\sum_{j=1}^{N_\\zeta} B(\\theta_i,\\zeta_j)\\, e^{-i(m\\theta_i - n\\zeta_j)} \\, \\omega_{\\theta,i} \\omega_{\\zeta,j} $$\nWhile designed for polynomials, Gauss-Legendre quadrature is also highly effective for smooth non-polynomial functions, often converging faster than the trapezoidal rule.\n\n#### 3. Error Metrics & Algorithm\n\nFor each test case and grid type, we compute the numerical coefficients $\\widehat{B}_{m,n}$ for all $(m,n)$ in the truncation domain $\\mathcal{R}$. From these, we calculate the numerical QS metric, $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$. We then compute two errors:\n1.  **QS Metric Absolute Error**: $|\\widehat{\\mathcal{M}}_{\\mathrm{QS}} - \\mathcal{M}_{\\mathrm{QS}}|$\n2.  **Coefficient Relative $\\ell_2$ Error**: This measures the error in the entire spectral representation:\n    $$ E_{\\ell_2} = \\frac{\\left(\\sum_{m,n \\in \\mathcal{R}} | \\widehat{B}_{m,n} - B_{m,n} |^2\\right)^{1/2}}{\\left(\\sum_{m,n \\in \\mathcal{R}} | B_{m,n} |^2\\right)^{1/2}} $$\n\nThe overall algorithm is as follows:\n1.  Compute the analytic coefficients $B_{m,n}$, the analytic metric $\\mathcal{M}_{\\mathrm{QS}}$, and the total $\\ell_2$ norm of the analytic coefficient vector.\n2.  Iterate through each test case $(N_\\theta, N_\\zeta)$.\n3.  For each case, perform the following for both Gauss-Legendre and uniform grids:\n    a.  Construct the 2D grid of nodes and weights.\n    b.  Evaluate the magnetic field function $B(\\theta, \\zeta)$ on the grid.\n    c.  Compute the matrix of numerical coefficients $\\widehat{B}_{m,n}$ over the domain $\\mathcal{R}$ using the corresponding discrete summation formula.\n    d.  Calculate the numerical QS metric $\\widehat{\\mathcal{M}}_{\\mathrm{QS}}$ from the $\\widehat{B}_{m,n}$ values.\n    e.  Calculate and store the QS metric error and the coefficient error.\n4.  After processing all test cases, calculate the average QS metric error for each grid type.\n5.  Recommend the grid type with the lower average error, encoding the choice as $0$ for uniform (or tied) and $1$ for Gauss-Legendre.\n6.  Format all computed results into a single comma-separated list for output.\n\nThis systematic comparison will reveal the impact of grid choice and resolution on the accuracy of spectral calculations in stellarator optimization studies. In particular, the under-resolved case $(N_\\theta, N_\\zeta) = (8,8)$ is expected to highlight the different convergence properties of the two methods, as the uniform grid will suffer from aliasing while the Gauss-Legendre grid may still yield reasonable accuracy.", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Computes and compares errors in stellarator quasi-symmetry metrics\n    derived from uniform and Gauss-Legendre quadrature grids.\n    \"\"\"\n    # 1. Define problem parameters\n    B0 = 1.0\n    eps1, eps2, eps3, eps4 = 0.3, 0.1, 0.08, 0.05\n    m_bar, n_bar = 2, 1\n    M, N = 6, 6\n\n    test_cases = [\n        (16, 16),\n        (8, 8),\n        (64, 16),\n    ]\n\n    # 2. Analytic Ground Truth Calculation\n    B_mn_analytic = {}\n    B_mn_analytic[(0, 0)] = complex(B0, 0)\n    B_mn_analytic[(m_bar, n_bar)] = complex(eps1 / 2, 0)\n    B_mn_analytic[(-m_bar, -n_bar)] = complex(eps1 / 2, 0)\n    B_mn_analytic[(2, 0)] = complex(eps2 / 2, 0)\n    B_mn_analytic[(-2, 0)] = complex(eps2 / 2, 0)\n    B_mn_analytic[(0, 3)] = complex(eps3 / 2, 0)\n    B_mn_analytic[(0, -3)] = complex(eps3 / 2, 0)\n    B_mn_analytic[(2 * m_bar, 2 * n_bar)] = complex(eps4 / 2, 0)\n    B_mn_analytic[(-2 * m_bar, -2 * n_bar)] = complex(eps4 / 2, 0)\n\n    m_vals = np.arange(-M, M + 1)\n    n_vals = np.arange(-N, N + 1)\n\n    qs_modes = set()\n    # Allowing k to be larger than M, N ensures we capture all possible modes within the truncation\n    k_range = max(M // abs(m_bar) if m_bar != 0 else M, N // abs(n_bar) if n_bar != 0 else N)\n    for k in range(-k_range, k_range + 2):\n        m, n = k * m_bar, k * n_bar\n        if abs(m) = M and abs(n) = N:\n            qs_modes.add((m, n))\n\n    sum_sq_off_qs = 0.0\n    sum_sq_total_ac = 0.0\n    B_analytic_matrix = np.zeros((2 * M + 1, 2 * N + 1), dtype=complex)\n    norm_B_analytic_sq = 0.0\n\n    for i, m in enumerate(m_vals):\n        for j, n in enumerate(n_vals):\n            val = B_mn_analytic.get((m, n), 0)\n            B_analytic_matrix[i, j] = val\n            norm_B_analytic_sq += np.abs(val)**2\n            if (m, n) == (0, 0):\n                continue\n            \n            sum_sq_total_ac += np.abs(val)**2\n            if (m, n) not in qs_modes:\n                sum_sq_off_qs += np.abs(val)**2\n\n    M_qs_analytic = sum_sq_off_qs / sum_sq_total_ac if sum_sq_total_ac != 0 else 0.0\n    norm_B_analytic = np.sqrt(norm_B_analytic_sq)\n\n    def B_field(theta, zeta):\n        return (B0 +\n                eps1 * np.cos(m_bar * theta - n_bar * zeta) +\n                eps2 * np.cos(2 * theta) +\n                eps3 * np.cos(3 * zeta) +\n                eps4 * np.cos(2 * m_bar * theta - 2 * n_bar * zeta))\n\n    def compute_errors(N_theta, N_zeta, grid_type):\n        if grid_type == 'uniform':\n            theta_nodes = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n            zeta_nodes = np.linspace(0, 2 * np.pi, N_zeta, endpoint=False)\n            theta_weights = np.full(N_theta, 2 * np.pi / N_theta)\n            zeta_weights = np.full(N_zeta, 2 * np.pi / N_zeta)\n        elif grid_type == 'gauss':\n            theta_x, theta_w = leggauss(N_theta)\n            zeta_x, zeta_w = leggauss(N_zeta)\n            theta_nodes = np.pi * (theta_x + 1)\n            zeta_nodes = np.pi * (zeta_x + 1)\n            theta_weights = np.pi * theta_w\n            zeta_weights = np.pi * zeta_w\n        else:\n            raise ValueError(\"Unknown grid_type\")\n\n        theta_grid, zeta_grid = np.meshgrid(theta_nodes, zeta_nodes, indexing='ij')\n        weights_grid = np.outer(theta_weights, zeta_weights)\n        B_on_grid = B_field(theta_grid, zeta_grid)\n\n        B_hat_matrix = np.zeros_like(B_analytic_matrix, dtype=complex)\n        for i, m in enumerate(m_vals):\n            for j, n in enumerate(n_vals):\n                exponent = -1j * (m * theta_grid - n * zeta_grid)\n                integrand = B_on_grid * np.exp(exponent)\n                integral = np.sum(integrand * weights_grid)\n                B_hat_matrix[i, j] = integral / (4 * np.pi**2)\n\n        num_sum_sq_off_qs = 0.0\n        num_sum_sq_total_ac = 0.0\n        for i, m in enumerate(m_vals):\n            for j, n in enumerate(n_vals):\n                val_sq = np.abs(B_hat_matrix[i, j])**2\n                if (m, n) == (0, 0):\n                    continue\n                num_sum_sq_total_ac += val_sq\n                if (m, n) not in qs_modes:\n                    num_sum_sq_off_qs += val_sq\n\n        M_qs_hat = num_sum_sq_off_qs / num_sum_sq_total_ac if num_sum_sq_total_ac != 0 else 0.0\n        \n        qs_metric_error = np.abs(M_qs_hat - M_qs_analytic)\n        \n        diff_matrix = B_hat_matrix - B_analytic_matrix\n        norm_diff_sq = np.sum(np.abs(diff_matrix)**2)\n        coeff_error = np.sqrt(norm_diff_sq) / norm_B_analytic if norm_B_analytic != 0 else 0.0\n        \n        return qs_metric_error, coeff_error\n\n    final_results = []\n    gl_qs_errors = []\n    u_qs_errors = []\n\n    for n_theta, n_zeta in test_cases:\n        err_gl, coeff_err_gl = compute_errors(n_theta, n_zeta, 'gauss')\n        err_u, coeff_err_u = compute_errors(n_theta, n_zeta, 'uniform')\n        \n        final_results.extend([err_gl, err_u, coeff_err_gl, coeff_err_u])\n        gl_qs_errors.append(err_gl)\n        u_qs_errors.append(err_u)\n\n    avg_err_gl = np.mean(gl_qs_errors)\n    avg_err_u = np.mean(u_qs_errors)\n    recommendation = 1 if avg_err_gl  avg_err_u else 0\n    final_results.append(recommendation)\n\n    print(f\"[{','.join(f'{x:.10g}' for x in final_results)}]\")\n\nsolve()\n```", "id": "3719877"}, {"introduction": "Analyzing a stellarator's performance is a precursor to the ultimate goal: optimizing its design. This final exercise bridges the gap from analysis to optimization by focusing on the sensitivity of a quasi-symmetry metric to changes in the magnetic field's Fourier coefficients [@problem_id:3719834]. By deriving and verifying the gradient and Hessian of a quasi-symmetry functional, you will learn how to build a predictive model that is the core engine of modern, gradient-based stellarator optimization algorithms.", "problem": "Consider a stellarator configuration characterized by a poloidal angle $\\theta$ and a toroidal angle $\\zeta$ (angles must be treated in radians). In quasi-symmetry (QS), the magnitude of the magnetic field $B$ should depend only on a helical angle $\\alpha$ defined by $\\alpha = M \\theta - N \\zeta$, where $M$ and $N$ are fixed integers describing the quasi-symmetric helicity. A fundamental characterization of quasi-symmetry is that departures of $B(\\theta,\\zeta)$ from a univariate dependence on $\\alpha$ are penalized by a functional that measures the component of $\\nabla B$ orthogonal to the direction associated with changes in $\\alpha$.\n\nStart from the following fundamental base:\n- In a toroidal system with periodic angles, any sufficiently smooth $B(\\theta,\\zeta)$ can be represented by a finite Fourier series. The helical harmonics $\\cos(m \\theta - n \\zeta)$ and $\\sin(m \\theta - n \\zeta)$ form an orthogonal basis over the $2\\pi$-periodic torus.\n- If $B(\\theta,\\zeta)$ depends only on $\\alpha = M \\theta - N \\zeta$, then the gradient $\\nabla B$ lies entirely in the span of the vector $(M,-N)$ in the $(\\theta,\\zeta)$ plane, so any component of $\\nabla B$ orthogonal to $(M,-N)$ indicates quasi-symmetry violation.\n- The quasi-symmetry violation functional $\\mathcal{R}_{\\mathrm{QS}}$ can be defined as the area integral over the $2\\pi$-periodic domain of the squared magnitude of the component of $\\nabla B$ that is orthogonal to $(M,-N)$.\n\nLet the magnitude of the magnetic field be approximated by the Fourier series\n$$\nB(\\theta,\\zeta) = B_0 + \\sum_{k=1}^{K} \\left[a_k \\cos(m_k \\theta - n_k \\zeta) + b_k \\sin(m_k \\theta - n_k \\zeta)\\right],\n$$\nwhere $B_0$ is a constant, and $\\{(m_k,n_k)\\}_{k=1}^{K}$ are prescribed integer mode pairs. Let the parameter vector $x \\in \\mathbb{R}^{2K}$ collect the Fourier coefficients as $x = (a_1,\\dots,a_K,b_1,\\dots,b_K)$. Consider a small perturbation of the boundary shape represented by a direction $p \\in \\mathbb{R}^{2K}$ and an amplitude $\\varepsilon \\in \\mathbb{R}$, leading to the perturbed coefficients $x(\\varepsilon) = x_0 + \\varepsilon p$.\n\nTasks:\n1. Using the definitions above, derive from first principles the quadratic form of $\\mathcal{R}_{\\mathrm{QS}}(x)$ in terms of the Fourier coefficients $\\{a_k,b_k\\}$, the helicity $(M,N)$, and the mode integers $(m_k,n_k)$. Then, derive the gradient $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ and the Hessian $H(x)$ with respect to $x$.\n2. For a given $x_0$, direction $p$, and small amplitude $\\varepsilon$, derive the second-order Taylor prediction of the change in $\\mathcal{R}_{\\mathrm{QS}}$:\n$$\n\\Delta^{(2)}(\\varepsilon) = \\frac{1}{2}\\varepsilon^2\\, p^\\top H(x_0)\\, p.\n$$\nAlso derive the finite-difference central second derivative along $p$ at $\\varepsilon = 0$:\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - 2\\,\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\mathcal{R}_{\\mathrm{QS}}(x_0-\\varepsilon p)}{\\varepsilon^2}.\n$$\n3. Verify the quadratic model by checking two conditions for each test case:\n   - The central second derivative $D^{(2)}_{\\mathrm{FD}}(\\varepsilon)$ matches $p^\\top H(x_0)\\, p$ within a specified tolerance.\n   - The actual change $\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon\\, \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p$ equals $\\Delta^{(2)}(\\varepsilon)$ within the same tolerance.\n\nAll quantities in this problem are dimensionless. Angles must be treated in radians. Your program must implement the derived expressions and perform the verification for the following test suite of parameter values:\n\n- Test case $1$ (general case):\n  - $(M,N) = (1,4)$,\n  - Modes: $[(1,0),(2,1),(3,-2)]$,\n  - $x_0$: $a = [0.3,-0.12,0.05]$, $b = [0.1,0.2,-0.07]$,\n  - $p$: $p_a = [0.05,-0.03,0.02]$, $p_b = [-0.02,0.01,0.04]$,\n  - $\\varepsilon = 10^{-3}$,\n  - Tolerance: $10^{-12}$.\n\n- Test case $2$ (helically aligned, boundary condition):\n  - $(M,N) = (2,3)$,\n  - Modes: $[(2,3)]$,\n  - $x_0$: $a = [0.7]$, $b = [-0.5]$,\n  - $p$: $p_a = [0.1]$, $p_b = [-0.2]$,\n  - $\\varepsilon = 10^{-6}$,\n  - Tolerance: $10^{-18}$.\n\n- Test case $3$ (zero base coefficients):\n  - $(M,N) = (1,1)$,\n  - Modes: $[(1,2),(2,1)]$,\n  - $x_0$: $a = [0.0,0.0]$, $b = [0.0,0.0]$,\n  - $p$: $p_a = [0.2,-0.15]$, $p_b = [0.05,0.1]$,\n  - $\\varepsilon = 10^{-4}$,\n  - Tolerance: $10^{-12}$.\n\n- Test case $4$ (very small perturbation amplitude):\n  - $(M,N) = (3,1)$,\n  - Modes: $[(1,1),(2,3),(4,-1)]$,\n  - $x_0$: $a = [0.25,-0.08,0.12]$, $b = [-0.05,0.06,-0.09]$,\n  - $p$: $p_a = [0.01,0.02,-0.015]$, $p_b = [0.02,-0.01,0.005]$,\n  - $\\varepsilon = 10^{-12}$,\n  - Tolerance: $10^{-18}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is a boolean indicating whether both verifications in task $3$ passed for the corresponding test case.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of plasma physics and stellarator design, specifically the concept of quasi-symmetry. The problem is well-posed, with all necessary mathematical definitions, parameters, and constraints provided. The language is objective and formal. The tasks constitute a standard exercise in calculus, linear algebra, and numerical verification, which is self-contained and free of contradictions or ambiguities.\n\n### Derivations\n\nThe solution requires the derivation of the quasi-symmetry residual functional $\\mathcal{R}_{\\mathrm{QS}}$, its gradient, and its Hessian, followed by the verification of its quadratic model.\n\n**1. Derivation of the Functional $\\mathcal{R}_{\\mathrm{QS}}(x)$**\n\nThe problem defines the quasi-symmetry violation functional $\\mathcal{R}_{\\mathrm{QS}}$ as the area integral of the squared magnitude of the component of the magnetic field gradient $\\nabla B$ that is orthogonal to the helical direction vector.\n\nThe helical direction in the $(\\theta, \\zeta)$ coordinate plane is given by the vector $v_h = (M, -N)$. A vector orthogonal to $v_h$ is $v_h^{\\perp} = (N, M)$. The squared magnitude of the component of $\\nabla B$ orthogonal to $v_h$ is given by the squared projection of $\\nabla B$ onto $v_h^{\\perp}$:\n$$\n\\left| \\text{proj}_{v_h^{\\perp}}(\\nabla B) \\right|^2 = \\frac{(\\nabla B \\cdot v_h^{\\perp})^2}{\\|v_h^{\\perp}\\|^2} = \\frac{\\left( N \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} \\right)^2}{N^2 + M^2}\n$$\nThe functional $\\mathcal{R}_{\\mathrm{QS}}$ is the integral of this quantity over the toroidal domain, which spans $2\\pi$ in both $\\theta$ and $\\zeta$:\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\int_0^{2\\pi} \\int_0^{2\\pi} \\frac{1}{M^2+N^2} \\left( N \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} \\right)^2 d\\theta d\\zeta\n$$\nThe magnetic field $B(\\theta, \\zeta)$ is given by the Fourier series:\n$$\nB(\\theta,\\zeta) = B_0 + \\sum_{k=1}^{K} \\left[a_k \\cos(m_k \\theta - n_k \\zeta) + b_k \\sin(m_k \\theta - n_k \\zeta)\\right]\n$$\nIts partial derivatives are:\n$$\n\\frac{\\partial B}{\\partial \\theta} = \\sum_{k=1}^{K} \\left[ -a_k m_k \\sin(m_k \\theta - n_k \\zeta) + b_k m_k \\cos(m_k \\theta - n_k \\zeta) \\right]\n$$\n$$\n\\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\left[ a_k n_k \\sin(m_k \\theta - n_k \\zeta) - b_k n_k \\cos(m_k \\theta - n_k \\zeta) \\right]\n$$\nWe form the linear combination inside the integral's parenthesis:\n$$\nN \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\left[ (-N m_k a_k + M n_k a_k) \\sin(\\phi_k) + (N m_k b_k - M n_k b_k) \\cos(\\phi_k) \\right]\n$$\nwhere $\\phi_k = m_k \\theta - n_k \\zeta$. Let $\\delta_k = M n_k - N m_k$. The expression simplifies to:\n$$\nN \\frac{\\partial B}{\\partial \\theta} + M \\frac{\\partial B}{\\partial \\zeta} = \\sum_{k=1}^{K} \\delta_k \\left[ a_k \\sin(\\phi_k) - b_k \\cos(\\phi_k) \\right]\n$$\nSubstituting this into the integral and squaring the sum leads to:\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\int_0^{2\\pi} \\int_0^{2\\pi} \\left( \\sum_{k=1}^{K} \\delta_k [a_k \\sin(\\phi_k) - b_k \\cos(\\phi_k)] \\right) \\left( \\sum_{j=1}^{K} \\delta_j [a_j \\sin(\\phi_j) - b_j \\cos(\\phi_j)] \\right) d\\theta d\\zeta\n$$\nDue to the orthogonality of the trigonometric basis functions over the domain $[0, 2\\pi] \\times [0, 2\\pi]$, the integrals of cross-terms (where $k \\neq j$) are zero. We use the identities (for non-zero modes $(m_k,n_k)$):\n$$\n\\int_0^{2\\pi} \\int_0^{2\\pi} \\sin^2(\\phi_k) d\\theta d\\zeta = 2\\pi^2, \\quad \\int_0^{2\\pi} \\int_0^{2\\pi} \\cos^2(\\phi_k) d\\theta d\\zeta = 2\\pi^2, \\quad \\int_0^{2\\pi} \\int_0^{2\\pi} \\sin(\\phi_k)\\cos(\\phi_k) d\\theta d\\zeta = 0\n$$\nThe functional thus reduces to a sum over the diagonal terms ($k=j$):\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 \\int_0^{2\\pi} \\int_0^{2\\pi} [a_k^2 \\sin^2(\\phi_k) + b_k^2 \\cos^2(\\phi_k)] d\\theta d\\zeta\n$$\n$$\n\\mathcal{R}_{\\mathrm{QS}} = \\frac{1}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 [a_k^2 (2\\pi^2) + b_k^2 (2\\pi^2)]\n$$\nThis gives the final quadratic form for the functional in terms of the coefficients $x = (a_1, \\dots, a_K, b_1, \\dots, b_K)$:\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x) = \\frac{2\\pi^2}{M^2+N^2} \\sum_{k=1}^{K} (M n_k - N m_k)^2 (a_k^2 + b_k^2)\n$$\n\n**2. Derivation of the Gradient $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ and Hessian $H(x)$**\n\nThe gradient $\\nabla \\mathcal{R}_{\\mathrm{QS}}(x)$ is a $2K$-dimensional vector of partial derivatives with respect to the components of $x$. For a given mode index $j \\in \\{1, \\dots, K\\}$:\n$$\n\\frac{\\partial \\mathcal{R}_{\\mathrm{QS}}}{\\partial a_j} = \\frac{\\partial}{\\partial a_j} \\left( \\frac{2\\pi^2}{M^2+N^2} \\sum_{k=1}^{K} \\delta_k^2 (a_k^2 + b_k^2) \\right) = \\frac{2\\pi^2}{M^2+N^2} \\delta_j^2 (2 a_j) = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2 a_j\n$$\nSimilarly, for the coefficient $b_j$:\n$$\n\\frac{\\partial \\mathcal{R}_{\\mathrm{QS}}}{\\partial b_j} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2 b_j\n$$\nThe Hessian $H(x)$ is the $2K \\times 2K$ matrix of second partial derivatives. Since $\\mathcal{R}_{\\mathrm{QS}}(x)$ is a purely quadratic function with no cross-terms between different modes or between $a_k$ and $b_j$, the Hessian is a constant diagonal matrix. The diagonal elements are:\n$$\nH_{a_j, a_j} = \\frac{\\partial^2 \\mathcal{R}_{\\mathrm{QS}}}{\\partial a_j^2} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2\n$$\n$$\nH_{b_j, b_j} = \\frac{\\partial^2 \\mathcal{R}_{\\mathrm{QS}}}{\\partial b_j^2} = \\frac{4\\pi^2}{M^2+N^2} (M n_j - N m_j)^2\n$$\nAll off-diagonal elements are zero. The diagonal elements corresponding to $a_k$ and $b_k$ for a given $k$ are identical.\n\n**3. Verification Expressions**\n\nThe problem requires verifying two identities based on a Taylor expansion around $x_0$.\nThe Taylor series of $\\mathcal{R}_{\\mathrm{QS}}(x_0 + \\varepsilon p)$ is:\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0 + \\varepsilon p) = \\mathcal{R}_{\\mathrm{QS}}(x_0) + \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p + \\frac{1}{2} \\varepsilon^2 p^\\top H(x_0) p + O(\\varepsilon^3)\n$$\nSince $\\mathcal{R}_{\\mathrm{QS}}$ is a quadratic polynomial, the expansion is exact and the terms of order $O(\\varepsilon^3)$ and higher are zero.\n\n- **Condition 1 Verification: $D^{(2)}_{\\mathrm{FD}}(\\varepsilon) = p^\\top H(x_0) p$**\nThe central finite difference formula for the second derivative is:\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - 2\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\mathcal{R}_{\\mathrm{QS}}(x_0-\\varepsilon p)}{\\varepsilon^2}\n$$\nUsing the exact Taylor expansion for $\\mathcal{R}_{\\mathrm{QS}}(x_0 \\pm \\varepsilon p)$:\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0 \\pm \\varepsilon p) = \\mathcal{R}_{\\mathrm{QS}}(x_0) \\pm \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p + \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p\n$$\nSubstituting into the numerator of $D^{(2)}_{\\mathrm{FD}}(\\varepsilon)$:\n$$\n\\text{Numerator} = \\left(\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\dots\\right) - 2\\mathcal{R}_{\\mathrm{QS}}(x_0) + \\left(\\mathcal{R}_{\\mathrm{QS}}(x_0) - \\dots\\right)\n$$\n$$\n= (\\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p) + (\\frac{1}{2}\\varepsilon^2 p^\\top H p + \\frac{1}{2}\\varepsilon^2 p^\\top H p) = \\varepsilon^2 p^\\top H(x_0) p\n$$\nTherefore, analytically:\n$$\nD^{(2)}_{\\mathrm{FD}}(\\varepsilon) = \\frac{\\varepsilon^2 p^\\top H(x_0) p}{\\varepsilon^2} = p^\\top H(x_0) p\n$$\nThe numerical check verifies $|D^{(2)}_{\\mathrm{FD}}(\\varepsilon) - p^\\top H(x_0) p| \\le \\text{tolerance}$.\n\n- **Condition 2 Verification: $\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p = \\Delta^{(2)}(\\varepsilon)$**\nThe left-hand side (LHS) represents the actual change minus the first-order Taylor approximation. The right-hand side (RHS) is the second-order term $\\Delta^{(2)}(\\varepsilon) = \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p$.\nFrom the exact Taylor expansion:\n$$\n\\mathcal{R}_{\\mathrm{QS}}(x_0+\\varepsilon p) - \\mathcal{R}_{\\mathrm{QS}}(x_0) - \\varepsilon \\nabla \\mathcal{R}_{\\mathrm{QS}}(x_0)^\\top p = \\frac{1}{2}\\varepsilon^2 p^\\top H(x_0) p\n$$\nThis shows that LHS is analytically equal to RHS. The numerical check verifies $| \\text{LHS} - \\text{RHS} | \\le \\text{tolerance}$.\nBoth conditions are identities for a quadratic function, so the verification primarily tests for implementation correctness and assesses floating-point precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"M\": 1, \"N\": 4,\n            \"modes\": np.array([[1, 0], [2, 1], [3, -2]]),\n            \"x0_a\": np.array([0.3, -0.12, 0.05]),\n            \"x0_b\": np.array([0.1, 0.2, -0.07]),\n            \"p_a\": np.array([0.05, -0.03, 0.02]),\n            \"p_b\": np.array([-0.02, 0.01, 0.04]),\n            \"eps\": 1e-3,\n            \"tol\": 1e-12\n        },\n        {\n            \"M\": 2, \"N\": 3,\n            \"modes\": np.array([[2, 3]]),\n            \"x0_a\": np.array([0.7]),\n            \"x0_b\": np.array([-0.5]),\n            \"p_a\": np.array([0.1]),\n            \"p_b\": np.array([-0.2]),\n            \"eps\": 1e-6,\n            \"tol\": 1e-18\n        },\n        {\n            \"M\": 1, \"N\": 1,\n            \"modes\": np.array([[1, 2], [2, 1]]),\n            \"x0_a\": np.array([0.0, 0.0]),\n            \"x0_b\": np.array([0.0, 0.0]),\n            \"p_a\": np.array([0.2, -0.15]),\n            \"p_b\": np.array([0.05, 0.1]),\n            \"eps\": 1e-4,\n            \"tol\": 1e-12\n        },\n        {\n            \"M\": 3, \"N\": 1,\n            \"modes\": np.array([[1, 1], [2, 3], [4, -1]]),\n            \"x0_a\": np.array([0.25, -0.08, 0.12]),\n            \"x0_b\": np.array([-0.05, 0.06, -0.09]),\n            \"p_a\": np.array([0.01, 0.02, -0.015]),\n            \"p_b\": np.array([0.02, -0.01, 0.005]),\n            \"eps\": 1e-12,\n            \"tol\": 1e-18\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_verification(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calc_R_QS(M, N, modes, coeffs):\n    \"\"\"\n    Calculates the quasi-symmetry residual R_QS for a given set of coefficients.\n    \n    Args:\n        M, N (int): Helicity integers.\n        modes (np.ndarray): Array of (m_k, n_k) mode pairs, shape (K, 2).\n        coeffs (np.ndarray): Vector of coefficients [a_1,..,a_K, b_1,..,b_K].\n\n    Returns:\n        float: The value of the R_QS functional.\n    \"\"\"\n    K = modes.shape[0]\n    a = coeffs[:K]\n    b = coeffs[K:]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return 0.0\n\n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (2 * np.pi**2) / (M**2 + N**2)\n    \n    sum_term = np.sum(delta_sq * (a**2 + b**2))\n    \n    return prefactor * sum_term\n\ndef calc_grad_R_QS(M, N, modes, coeffs):\n    \"\"\"\n    Calculates the gradient of R_QS.\n    \"\"\"\n    K = modes.shape[0]\n    a = coeffs[:K]\n    b = coeffs[K:]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return np.zeros_like(coeffs)\n\n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (4 * np.pi**2) / (M**2 + N**2)\n    \n    grad_a = prefactor * delta_sq * a\n    grad_b = prefactor * delta_sq * b\n    \n    return np.concatenate([grad_a, grad_b])\n\ndef calc_hessian_diag(M, N, modes):\n    \"\"\"\n    Calculates the diagonal of the Hessian of R_QS.\n    \"\"\"\n    K = modes.shape[0]\n    \n    m = modes[:, 0]\n    n = modes[:, 1]\n    \n    if M**2 + N**2 == 0:\n        return np.zeros(2*K)\n    \n    delta = M * n - N * m\n    delta_sq = delta**2\n    \n    prefactor = (4 * np.pi**2) / (M**2 + N**2)\n    \n    h_k = prefactor * delta_sq\n    \n    return np.concatenate([h_k, h_k])\n\ndef run_verification(params):\n    \"\"\"\n    Runs the two verification conditions for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        bool: True if both conditions pass, False otherwise.\n    \"\"\"\n    M, N = params[\"M\"], params[\"N\"]\n    modes = params[\"modes\"]\n    x0_a, x0_b = params[\"x0_a\"], params[\"x0_b\"]\n    p_a, p_b = params[\"p_a\"], params[\"p_b\"]\n    eps, tol = params[\"eps\"], params[\"tol\"]\n\n    x0 = np.concatenate([x0_a, x0_b])\n    p = np.concatenate([p_a, p_b])\n\n    # --- Condition 1 Verification ---\n    # Compare D_FD^{(2)}(eps) with p^T H p\n    \n    # Calculate p^T H p\n    H_diag = calc_hessian_diag(M, N, modes)\n    pT_H_p = np.sum(H_diag * p**2)\n\n    # Calculate D_FD^{(2)}\n    R_plus = calc_R_QS(M, N, modes, x0 + eps * p)\n    R_zero = calc_R_QS(M, N, modes, x0)\n    R_minus = calc_R_QS(M, N, modes, x0 - eps * p)\n    \n    # Avoid division by zero if eps is extremely small\n    if eps**2  1e-30:\n        # For a quadratic, D2_FD is independent of eps and equals pT_H_p\n        D2_FD = pT_H_p \n    else:    \n        D2_FD = (R_plus - 2 * R_zero + R_minus) / eps**2\n    \n    cond1_passed = abs(D2_FD - pT_H_p) = tol\n    \n    # --- Condition 2 Verification ---\n    # Compare actual change minus linear term with the 2nd-order Taylor term\n    \n    # Calculate LHS: actual change - linear term\n    grad_R0 = calc_grad_R_QS(M, N, modes, x0)\n    grad_term = eps * np.dot(grad_R0, p)\n    actual_change = R_plus - R_zero - grad_term\n    \n    # Calculate RHS: 2nd-order Taylor term Delta^(2)\n    taylor_approx = 0.5 * eps**2 * pT_H_p\n    \n    cond2_passed = abs(actual_change - taylor_approx) = tol\n\n    return cond1_passed and cond2_passed\n\nsolve()\n\n```", "id": "3719834"}]}