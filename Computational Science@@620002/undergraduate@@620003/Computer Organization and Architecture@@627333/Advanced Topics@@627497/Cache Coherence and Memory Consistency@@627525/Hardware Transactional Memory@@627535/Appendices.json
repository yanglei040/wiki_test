{"hands_on_practices": [{"introduction": "The power of Hardware Transactional Memory (HTM) is often limited by transaction aborts, which occur when concurrent operations conflict. To build efficient transactional programs, it's crucial to understand the factors that drive these conflicts. This first exercise provides a foundational model for quantifying the probability of a conflict abort based on thread-level parallelism and data access patterns ([@problem_id:3645919]). By working through this idealized scenario, you'll develop a core intuition for how contention scales in a multicore system.", "problem": "A microbenchmark is designed to stress test conflict behavior in Hardware Transactional Memory (HTM). There are $N$ concurrent threads. Each thread performs exactly one transaction that executes the following steps atomically: pick a single cache line uniformly at random from an array and write one machine word to it. The array has total size $M$ bytes, is aligned to cache-line boundaries, and the cache-line size is $L$ bytes. Assume $M$ is an integer multiple of $L$, so there are exactly $M/L$ distinct cache lines in the array. The hardware detects conflicts on write-write and write-read overlaps at cache-line granularity, and a transaction aborts if any other concurrent transaction accesses (reads or writes) any cache line in its write set. In this benchmark, all transactions write and do not read, so the only possible conflicts are write-write overlaps on a cache line. All $N$ transactions overlap in time and attempt to commit concurrently. Each thread’s choice of cache line is independent and uniformly distributed over the $M/L$ cache lines.\n\nUsing only the core definitions of HTM conflict detection and fundamental probability rules, derive an exact closed-form expression for the probability that a particular thread’s transaction aborts due to a conflict, as a function of $N$, $M$, and $L$. Express your final answer as a simplified symbolic expression in terms of $N$, $M$, and $L$. Do not approximate and do not round.", "solution": "The problem statement has been critically validated and is deemed to be valid. It is scientifically grounded in the principles of computer architecture and probability theory, well-posed, objective, and self-contained. Therefore, a solution will be provided.\n\nLet $N$ be the number of concurrent threads, $M$ be the total size of the array in bytes, and $L$ be the size of a cache line in bytes. The problem states that $M$ is an integer multiple of $L$. The total number of distinct cache lines, which we will denote by $C$, is therefore given by:\n$$C = \\frac{M}{L}$$\nEach of the $N$ threads executes a transaction that involves writing to a single cache line chosen independently and uniformly at random from the $C$ available cache lines.\n\nWe are asked to find the probability that a *particular* thread's transaction aborts. Let us arbitrarily select one thread, say Thread $1$, and calculate the probability that its transaction aborts. An abort occurs if there is a conflict. According to the problem, a conflict for Thread $1$ happens if any other concurrent transaction accesses the same cache line that Thread $1$ has chosen for its write operation. Since there are $N$ threads in total, there are $N-1$ other threads that could potentially cause a conflict with Thread $1$.\n\nThe transaction of Thread $1$ will abort if at least one of the other $N-1$ threads chooses the same cache line as Thread $1$. It is often simpler in probability to calculate the complementary event: the probability that the transaction of Thread $1$ *succeeds* (i.e., does not abort). Let's denote the event of an abort for Thread $1$ as $A$, and the event of success as $A^c$. The probability we seek is $P(A)$. We will first calculate $P(A^c)$ and then use the relation $P(A) = 1 - P(A^c)$.\n\nThe transaction of Thread $1$ succeeds if and only if *all* of the other $N-1$ threads choose a cache line that is *different* from the one chosen by Thread $1$.\n\nLet $c_i$ be the cache line chosen by thread $i$, for $i \\in \\{1, 2, \\dots, N\\}$. Each $c_i$ is an independent random variable uniformly distributed over the set of $C$ cache lines.\n\nLet's consider one of the other threads, say Thread $j$, where $j \\in \\{2, 3, \\dots, N\\}$. The cache line chosen by Thread $1$, $c_1$, can be any of the $C$ lines. The cache line chosen by Thread $j$, $c_j$, can also be any of the $C$ lines. Since the choices are uniform, the probability that Thread $j$ chooses the exact same cache line as Thread $1$ is:\n$$P(c_j = c_1) = \\frac{1}{C}$$\nConsequently, the probability that Thread $j$ chooses a *different* cache line from Thread $1$ is:\n$$P(c_j \\neq c_1) = 1 - P(c_j = c_1) = 1 - \\frac{1}{C} = \\frac{C-1}{C}$$\nThe event $A^c$ (Thread $1$ succeeds) occurs if the condition $c_j \\neq c_1$ holds true for all other threads, i.e., for $j = 2, 3, \\dots, N$.\n$$A^c \\equiv (c_2 \\neq c_1) \\land (c_3 \\neq c_1) \\land \\dots \\land (c_N \\neq c_1)$$\nThe problem states that each thread's choice of cache line is independent. Therefore, the probability of this compound event is the product of the individual probabilities:\n$$P(A^c) = P(c_2 \\neq c_1) \\times P(c_3 \\neq c_1) \\times \\dots \\times P(c_N \\neq c_1)$$\nSince there are $N-1$ such threads and the probability is the same for each, we have:\n$$P(A^c) = \\left( \\frac{C-1}{C} \\right)^{N-1}$$\nNow, we can find the probability of an abort, $P(A)$, which is what the problem asks for:\n$$P(A) = 1 - P(A^c) = 1 - \\left( \\frac{C-1}{C} \\right)^{N-1}$$\nThe final step is to substitute the expression for $C$ in terms of the given variables $M$ and $L$.\n$$C = \\frac{M}{L}$$\nSubstituting this into our expression for $P(A)$:\n$$P(A) = 1 - \\left( \\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} \\right)^{N-1}$$\nWe can simplify the term inside the parentheses:\n$$\\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} = 1 - \\frac{1}{\\frac{M}{L}} = 1 - \\frac{L}{M}$$\nTherefore, the exact closed-form expression for the probability that a particular thread's transaction aborts is:\n$$P(A) = 1 - \\left( 1 - \\frac{L}{M} \\right)^{N-1}$$\nThis expression is a function of $N$, $M$, and $L$, as required.", "answer": "$$ \\boxed{1 - \\left(1 - \\frac{L}{M}\\right)^{N-1}} $$", "id": "3645919"}, {"introduction": "Conflict detection in real-world HTM systems often operates at the granularity of a cache line, a practical design choice that can lead to a performance pitfall known as 'false sharing.' This occurs when two transactions access different data objects that happen to reside on the same cache line, causing an unnecessary abort. This exercise challenges you to act as a performance engineer, using data structure padding to control object layout and minimize the probability of these wasteful false conflicts ([@problem_id:3645968]).", "problem": "A multiprocessor implements Hardware Transactional Memory (HTM) that detects conflicts at cache-line granularity: two concurrent transactions conflict if they access different objects that reside on the same cache line and at least one access is a write. Consider an array of identical structs stored contiguously in memory. Each struct has a payload of size $S$ bytes. You may insert explicit padding of size $P$ bytes after each struct so that the per-object stride is $B = S + P$ bytes. The allocator aligns the start of the array to a cache-line boundary, and you must respect an alignment constraint that $B$ is a multiple of $a$ bytes. Assume $B \\le L$, so no object crosses a cache-line boundary. Under these conditions, each cache line contains exactly $k = \\left\\lfloor \\frac{L}{B} \\right\\rfloor$ objects.\n\nWorkload model: In each conflict-detection window, there are exactly two concurrent transactions. They select, uniformly at random and without replacement, two distinct objects from a hot working set consisting of $W$ contiguous cache lines that are fully populated by array objects. Each transaction performs a write to its selected object. A false conflict occurs if and only if the two selected objects are different but mapped to the same cache line.\n\nUsing only the core definitions above (cache-line-granular conflict detection and uniform selection without replacement from the $W$-line working set), determine the smallest integer padding $P$ (in bytes) such that the probability of a false conflict is less than or equal to a given threshold $\\theta$.\n\nUse the following parameters:\n- Cache line size: $L = 64$ bytes.\n- Struct payload size: $S = 20$ bytes.\n- Required stride alignment: $a = 8$ bytes.\n- Working set size: $W = 32$ cache lines.\n- Threshold: $\\theta = 0.02$.\n\nState your final answer as the minimum padding $P$ in bytes. No rounding is required. Express the final answer as a single number of bytes.", "solution": "The user wants me to solve the following problem after validating it.\n\n### Step 1: Extract Givens\n- Hardware Transactional Memory (HTM) with conflict detection at cache-line granularity.\n- Conflict condition: two concurrent transactions access different objects on the same cache line, and at least one access is a write.\n- An array of identical structs is stored contiguously in memory.\n- Struct payload size: $S$ bytes.\n- Explicit padding per struct: $P$ bytes.\n- Per-object stride: $B = S + P$ bytes.\n- Array start is aligned to a cache-line boundary.\n- Alignment constraint: $B$ must be a multiple of $a$ bytes.\n- Constraint on stride: $B \\le L$.\n- Number of objects per cache line: $k = \\left\\lfloor \\frac{L}{B} \\right\\rfloor$.\n- Workload: two concurrent transactions in each conflict-detection window.\n- Object selection: two distinct objects are selected uniformly at random and without replacement from a hot working set.\n- Working set: $W$ contiguous cache lines, fully populated by array objects.\n- Access type: each transaction performs a write.\n- False conflict: the two selected objects are different but map to the same cache line.\n- Objective: Find the smallest integer padding $P$ (in bytes) such that the probability of a false conflict is less than or equal to a threshold $\\theta$.\n- Parameters:\n    - Cache line size: $L = 64$ bytes.\n    - Struct payload size: $S = 20$ bytes.\n    - Required stride alignment: $a = 8$ bytes.\n    - Working set size: $W = 32$ cache lines.\n    - Threshold: $\\theta = 0.02$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it uses a standard, simplified model of cache behavior and Hardware Transactional Memory common in computer architecture studies. The concepts of cache lines, padding, alignment, and conflict detection are well-defined. The problem is well-posed, providing all necessary parameters and a clear objective (minimizing an integer $P$ subject to a probabilistic constraint). The language is objective and formal. The setup is internally consistent and does not violate any physical or mathematical principles. The problem is a non-trivial application of combinatorial probability to a computer architecture scenario. Therefore, it is valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Solution Derivation\nThe goal is to find the smallest integer padding $P \\ge 0$ that satisfies a set of constraints. Let us first derive the expression for the probability of a false conflict, $P_f$.\n\nThe working set consists of $W$ cache lines. Each cache line is fully populated with $k$ objects, where $k = \\lfloor \\frac{L}{B} \\rfloor$ and $B = S + P$. The total number of objects in the working set is $N = W \\cdot k$.\n\nThe workload consists of selecting two distinct objects from these $N$ objects, uniformly at random and without replacement. The total number of ways to choose two distinct objects is given by the binomial coefficient $\\binom{N}{2}$:\n$$ \\text{Total pairs} = \\binom{N}{2} = \\frac{N(N-1)}{2} $$\nA false conflict occurs if the two selected objects are different but reside on the same cache line. To count the number of such pairs, we can consider each cache line individually. Within one cache line, there are $k$ objects. The number of ways to choose two distinct objects from this single cache line is $\\binom{k}{2}$.\n$$ \\text{Conflicting pairs per line} = \\binom{k}{2} = \\frac{k(k-1)}{2} $$\nSince there are $W$ independent cache lines in the working set, the total number of pairs that cause a false conflict is $W$ times this value:\n$$ \\text{Total conflicting pairs} = W \\cdot \\binom{k}{2} = W \\frac{k(k-1)}{2} $$\nThe probability of a false conflict, $P_f$, is the ratio of the number of conflicting pairs to the total number of pairs:\n$$ P_f = \\frac{W \\frac{k(k-1)}{2}}{\\frac{N(N-1)}{2}} = \\frac{W k(k-1)}{N(N-1)} $$\nSubstituting $N = Wk$ into the expression for $P_f$:\n$$ P_f = \\frac{W k(k-1)}{Wk(Wk-1)} = \\frac{k-1}{Wk-1} $$\nThis expression for $P_f$ is valid for $k > 1$. If $k=1$, there is only one object per cache line, making it impossible to select two distinct objects from the same line. In this case, the number of conflicting pairs is $0$, so $P_f = 0$. The formula $\\frac{k-1}{Wk-1}$ correctly yields $0$ for $k=1$.\n\nWe need to find the smallest integer $P \\ge 0$ that satisfies the following conditions:\n$1$. The stride $B = S + P$ must be a multiple of $a$.\n$2$. The stride $B$ must not exceed the cache line size, $B \\le L$.\n$3$. The probability of a false conflict must be at most $\\theta$, i.e., $P_f \\le \\theta$.\n\nSubstituting the given parameters: $S=20$, $L=64$, $a=8$, $W=32$, and $\\theta=0.02$.\nThe stride is $B = 20 + P$. The number of objects per cache line is $k = \\lfloor \\frac{64}{20+P} \\rfloor$.\nThe conditions become:\n$1$. $20+P$ must be a multiple of $8$.\n$2$. $20+P \\le 64$, which implies $P \\le 44$.\n$3$. $\\frac{k-1}{32k-1} \\le 0.02$.\n\nLet's analyze the constraints. The function $f(k) = \\frac{k-1}{Wk-1}$ is monotonically increasing with $k$ for $k \\ge 1$ (since $W > 1$). To satisfy $P_f \\le \\theta$, we need to make $P_f$ smaller. This requires making $k$ smaller. To make $k = \\lfloor L/B \\rfloor$ smaller, we must make the stride $B = S+P$ larger. Therefore, we need to find the smallest padding $P$ that makes $B$ large enough to reduce $k$ to a level where the probability constraint is met.\n\nWe can systematically test the permissible values of $P$, starting from the smallest possible value, until we find one that satisfies all conditions.\nFrom constraint $1$, $20+P$ must be a multiple of $8$. Since $20 \\pmod 8 = 4$, we must have $(4+P) \\pmod 8 = 0$. This means $P$ must be of the form $8m - 4$ for some positive integer $m$. The smallest non-negative integer values for $P$ are obtained by taking $m=1, 2, 3, \\dots$:\n- $m=1: P = 8(1)-4 = 4$\n- $m=2: P = 8(2)-4 = 12$\n- $m=3: P = 8(3)-4 = 20$\n- And so on. All these potential values of $P$ are less than or equal to $44$.\n\nLet's test the smallest possible value, $P=4$.\n- **Test $P=4$**:\n    - This is the smallest non-negative integer $P$ that satisfies the alignment constraint.\n    - Calculate the stride: $B = S+P = 20+4 = 24$ bytes.\n    - Check constraint $2$: $B=24 \\le 64$. This is satisfied.\n    - Calculate the number of objects per cache line: $k = \\lfloor \\frac{L}{B} \\rfloor = \\lfloor \\frac{64}{24} \\rfloor = \\lfloor 2.66\\dots \\rfloor = 2$.\n    - Calculate the probability of false conflict for $k=2$:\n      $$ P_f = \\frac{k-1}{Wk-1} = \\frac{2-1}{32(2)-1} = \\frac{1}{64-1} = \\frac{1}{63} $$\n    - Check the probability constraint (condition $3$):\n      $$ \\frac{1}{63} \\le 0.02 $$\n      To check this inequality, we can write $0.02$ as $\\frac{2}{100} = \\frac{1}{50}$. The inequality is $\\frac{1}{63} \\le \\frac{1}{50}$, which is true.\n      Alternatively, $1 \\le 0.02 \\times 63 = 1.26$, which is also true.\n\nSince the smallest possible padding $P=4$ that adheres to the alignment constraint also satisfies the probability threshold, it is the minimum required padding. There is no need to test larger values of $P$.\n\nThe minimum integer padding is $4$ bytes.", "answer": "$$\\boxed{4}$$", "id": "3645968"}, {"introduction": "When a transaction aborts, the system must decide on a recovery strategy, a choice that critically impacts overall performance under contention. Simply retrying immediately might lead to repeated conflicts, while waiting too long wastes valuable execution time. This final practice delves into the crucial topic of abort handling policies, asking you to model and compare the expected performance of a simple bounded-retry scheme versus a more adaptive exponential backoff strategy ([@problem_id:3645908]). Through this analysis, you will learn how to quantitatively reason about the trade-offs involved in designing robust and efficient transactional systems.", "problem": "A processor implements Hardware Transactional Memory (HTM). Consider a single thread using HTM in a stationary environment with many symmetric contenders. Model conflicting critical-section arrivals from other threads as a Poisson process of rate $\\lambda$. A transaction’s vulnerable execution window has length $t_s$, and the contention level is defined as $c \\equiv \\lambda t_s$. By the properties of a Poisson process, the probability that an HTM attempt sees zero conflicting arrivals during its vulnerable window is $\\exp(-\\lambda t_s)=\\exp(-c)$. Each HTM attempt that succeeds completes in time $t_s$. Each HTM attempt that aborts incurs the work of the attempt plus an abort penalty $h$, for a total cost $t_s+h$. Upon exhausting the retry budget, the thread falls back to a non-transactional slow path of fixed time $t_f$.\n\nTwo retry policies are considered:\n- Bounded retries without backoff: Up to $r$ transactional attempts are made back-to-back (no deliberate waiting), then the slow path is invoked if all transactional attempts abort. Under this policy, assume the per-attempt success probability is constant and equal to $\\exp(-c)$.\n- Exponential backoff: Before the $k$-th transactional attempt, the thread waits a backoff duration $w_k=d_0 \\alpha^{k-1}$ for some fixed $d_0>0$ and $\\alpha>1$. Assume that this coordinated backoff reduces the effective conflict rate for attempt $k$ to $\\lambda/\\alpha^{k-1}$, so the success probability for attempt $k$ is $\\exp\\!\\big(-\\lambda t_s/\\alpha^{k-1}\\big)=\\exp\\!\\big(-c/\\alpha^{k-1}\\big)$. If all $R_b$ backoff-governed attempts abort, the slow path is taken.\n\nStarting only from the definition of $c$ and the Poisson “no-arrivals” law, and standard probability for independent tries:\n1) Derive an analytic expression for the expected time-to-success $E[T]$ for the bounded-retry policy as a function of $r$, $c$, $t_s$, $h$, and $t_f$.\n2) Derive an analytic expression for the expected time-to-success $E[T]$ for the exponential-backoff policy limited to $R_b$ attempts, as a function of $c$, $\\alpha$, $d_0$, $t_s$, $h$, and $t_f$.\n3) Using your expression from part (1), determine the optimal integer retry limit $r^{\\*}$ that minimizes the bounded-retry $E[T]$ for the parameter set\n- $t_s = 20$ microseconds,\n- $h = 5$ microseconds,\n- $t_f = 120$ microseconds,\n- $c = 2$.\nThen, with the same parameters and exponential-backoff parameters\n- $d_0 = 10$ microseconds,\n- $\\alpha = 2$,\n- $R_b = 3$,\nevaluate numerically the bounded-retry $E[T]$ at $r^{\\*}$ and the exponential-backoff $E[T]$ at $R_b$ attempts.\n\nRound all numerical time values to $4$ significant figures. Express times in microseconds. Report your final answer as a row matrix $\\big(r^{\\*},\\,E[T]_{\\text{bounded at }r^{\\*}},\\,E[T]_{\\text{backoff at }R_b}\\big)$.", "solution": "The user has provided a problem on modeling the performance of Hardware Transactional Memory (HTM) under two different retry policies. I will first validate the problem statement and then proceed to a full solution.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Process Model**: Conflicting critical-section arrivals are modeled as a Poisson process of rate $\\lambda$.\n- **Vulnerable Window**: A transaction's vulnerable execution window has length $t_s$.\n- **Contention Level**: $c \\equiv \\lambda t_s$.\n- **Success Probability (General)**: The probability of zero conflicting arrivals during the vulnerable window is $\\exp(-\\lambda t_s) = \\exp(-c)$.\n- **Attempt Costs**:\n    - A successful HTM attempt completes in time $t_s$.\n    - An aborted HTM attempt costs $t_s+h$, where $h$ is an abort penalty.\n- **Fallback Path**: A non-transactional slow path of fixed time $t_f$ is taken after exhausting the retry budget.\n\n- **Policy 1: Bounded Retries without Backoff**\n    - **Retry Limit**: Up to $r$ attempts are made back-to-back.\n    - **Success Probability**: The per-attempt success probability is constant, $P_s = \\exp(-c)$.\n\n- **Policy 2: Exponential Backoff**\n    - **Retry Limit**: Up to $R_b$ attempts.\n    - **Backoff Wait**: Before the $k$-th attempt, the thread waits $w_k = d_0 \\alpha^{k-1}$ for $d_0>0$ and $\\alpha>1$.\n    - **Success Probability**: The success probability for attempt $k$ is $P_{s,k} = \\exp(-c/\\alpha^{k-1})$.\n\n- **Numerical Parameters for Part 3**:\n    - $t_s = 20$ microseconds\n    - $h = 5$ microseconds\n    - $t_f = 120$ microseconds\n    - $c = 2$\n    - $d_0 = 10$ microseconds\n    - $\\alpha = 2$\n    - $R_b = 3$\n\n- **Required Outputs**:\n    1. Analytic expression for expected time-to-success $E[T]$ for the bounded-retry policy.\n    2. Analytic expression for expected time-to-success $E[T]$ for the exponential-backoff policy.\n    3. Optimal integer retry limit $r^*$ for the bounded-retry policy with given parameters.\n    4. Numerical values for $E[T]$ for both policies at their specified retry limits ($r^*$ and $R_b$). The final answer is to be presented as a row matrix: $(r^{\\*},\\,E[T]_{\\text{bounded at }r^{\\*}},\\,E[T]_{\\text{backoff at }R_b}\\big)$, with time values rounded to $4$ significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is well-grounded in the field of computer architecture, specifically performance modeling of concurrency control mechanisms like HTM. The use of a Poisson process to model conflicts and the concept of exponential backoff are standard, well-established techniques in this domain.\n- **Well-Posed**: The problem is well-posed. The assumptions are clearly stated, allowing for the derivation of unique analytical expressions for the expected time-to-success. The numerical part has all necessary data to produce a specific numerical answer.\n- **Objective**: The problem is stated in precise, objective language. All terms are defined mathematically.\n- **No Flaws**: The problem does not violate any of the invalidity criteria. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, ill-posed, pseudo-profound, or outside scientific verifiability. The assumptions are simplifications of reality, but they are explicitly provided to create a self-contained, solvable mathematical model, which is standard practice in performance analysis.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. I will proceed with the detailed solution.\n\n### Solution\n\nThe expected time to success, $E[T]$, is the sum of the time taken for each possible execution path multiplied by the probability of that path.\n\n**1) Bounded-Retry Policy**\n\nFor this policy, the probability of success for any given attempt is $P_s = \\exp(-c)$, and the probability of failure (abort) is $P_f = 1 - P_s = 1 - \\exp(-c)$. The attempts are made back-to-back, so there is no waiting time.\n\nAn execution can terminate in one of two ways:\n- **Success on attempt $k$ (where $1 \\le k \\le r$)**: This requires $k-1$ failures followed by one success. The probability of this path is $P_f^{k-1} P_s$. The time taken is $(k-1)$ failed attempts, each costing $t_s+h$, plus one successful attempt costing $t_s$. Total time: $(k-1)(t_s+h) + t_s$.\n- **Fallback after $r$ failures**: This occurs if all $r$ attempts fail. The probability is $P_f^r$. The time taken is $r$ failed attempts plus the fallback time $t_f$. Total time: $r(t_s+h) + t_f$.\n\nThe expected time $E[T]$ is the sum over all these mutually exclusive paths:\n$$E[T] = \\sum_{k=1}^{r} \\left[ ((k-1)(t_s+h) + t_s) P_f^{k-1} P_s \\right] + (r(t_s+h) + t_f) P_f^r$$\nThis expression is a valid analytic result. However, a more compact form can be derived. Let $E_i$ be the expected time remaining, given that $i-1$ attempts have already failed. We want to find $E[T] = E_1$.\nFor an attempt $i \\le r$, it succeeds with probability $P_s$ taking time $t_s$, or it fails with probability $P_f$, taking time $t_s+h$ and then we proceed to attempt $i+1$. For the final fallback, we can define $E_{r+1} = t_f$.\nThe recurrence relation is:\n$$E_i = t_s P_s + (t_s+h + E_{i+1})P_f \\quad \\text{for } 1 \\leq i \\leq r$$\n$E_i = t_s(1-P_f) + (t_s+h)P_f + E_{i+1}P_f = t_s + hP_f + E_{i+1}P_f$.\nLet $C = t_s + hP_f$. The recurrence is $E_i = C + P_f E_{i+1}$. Unrolling this from $i=1$:\n$E_1 = C + P_f E_2 = C + P_f(C + P_f E_3) = C(1+P_f) + P_f^2 E_3 = \\dots$\n$E_1 = C \\sum_{j=0}^{r-1} P_f^j + P_f^r E_{r+1} = C \\left(\\frac{1-P_f^r}{1-P_f}\\right) + t_f P_f^r$.\nSubstituting $C=t_s+hP_f$ and $1-P_f=P_s$, and using $P_f=1-\\exp(-c)$:\n$$E[T] = (t_s + h(1-\\exp(-c))) \\frac{1 - (1-\\exp(-c))^r}{\\exp(-c)} + t_f (1-\\exp(-c))^r$$\nThis is the required analytical expression.\n\n**2) Exponential-Backoff Policy**\n\nFor this policy, the parameters for the $k$-th attempt (for $1 \\le k \\le R_b$) are:\n- Wait time: $w_k = d_0 \\alpha^{k-1}$\n- Success probability: $P_{s,k} = \\exp(-c/\\alpha^{k-1})$\n- Failure probability: $P_{f,k} = 1 - P_{s,k}$\nThe cost of a successful $k$-th attempt is $w_k+t_s$. The cost of a failed $k$-th attempt is $w_k+t_s+h$.\n\nWe sum over all possible paths:\n- **Success on attempt $k$ ($1 \\le k \\le R_b$)**: This requires attempts $1, \\dots, k-1$ to fail.\n    - Probability: $P(\\text{success at } k) = \\left(\\prod_{j=1}^{k-1} P_{f,j}\\right) P_{s,k}$.\n    - Time: The total time is the sum of costs of $k-1$ failed attempts and one successful attempt: $T_k = \\sum_{j=1}^{k-1} (w_j+t_s+h) + (w_k+t_s)$.\n- **Fallback after $R_b$ failures**:\n    - Probability: $P(\\text{fallback}) = \\prod_{j=1}^{R_b} P_{f,j}$.\n    - Time: The total time is the sum of costs of $R_b$ failed attempts plus the fallback time: $T_{fall} = \\sum_{j=1}^{R_b} (w_j+t_s+h) + t_f$.\n\nThe expected time $E[T]$ is the sum of (Time $\\times$ Probability) over these paths:\n$$E[T] = \\sum_{k=1}^{R_b} \\left[ \\left( \\sum_{j=1}^{k-1}(w_j+t_s+h) + w_k+t_s \\right) P_{s,k} \\prod_{j=1}^{k-1} P_{f,j} \\right] + \\left( \\left( \\sum_{j=1}^{R_b}(w_j+t_s+h) \\right) + t_f \\right) \\prod_{j=1}^{R_b}P_{f,j}$$\nwhere an empty product is $1$ and an empty sum is $0$. This is the required analytic expression.\n\n**3) Numerical Evaluation**\n\nWe are given the parameters: $t_s=20$, $h=5$, $t_f=120$, $c=2$, $d_0=10$, $\\alpha=2$, $R_b=3$. All times are in microseconds.\n\n**Bounded-Retry Optimal Retry Limit $r^*$**\nThe expression for $E[T](r)$ is of the form $A + B \\cdot p^r$, where $p=P_f=1-\\exp(-c)$.\n$$E[T](r) = \\frac{t_s+hP_f}{P_s} (1-P_f^r) + t_f P_f^r = \\frac{t_s+hP_f}{P_s} + \\left( t_f - \\frac{t_s+hP_f}{P_s} \\right) P_f^r$$\nLet's evaluate the coefficient of $P_f^r$:\nWith $c=2$, $P_s = \\exp(-2)$ and $P_f = 1-\\exp(-2)$.\n$$ \\frac{t_s+hP_f}{P_s} = \\frac{20+5(1-\\exp(-2))}{\\exp(-2)} = \\frac{25-5\\exp(-2)}{\\exp(-2)} = 25\\exp(2)-5 $$\n$t_f - \\frac{t_s+hP_f}{P_s} = 120 - (25\\exp(2)-5) = 125 - 25\\exp(2)$.\nSince $\\exp(2) \\approx 7.389$, we have $125 - 25(7.389) = 125 - 184.725 = -59.725  0$.\nSo, $E[T](r)$ is of the form $C_1 - C_2 \\cdot P_f^r$, where $C_1, C_2  0$ and $0  P_f  1$.\nAs $r$ increases, $P_f^r$ decreases, so $-C_2 P_f^r$ increases. Thus, $E[T](r)$ is a strictly increasing function of $r$. The problem asks for an optimal integer retry limit, which we take to mean $r \\ge 1$. The minimum expected time is therefore achieved at the smallest possible value of $r$, which is $r^*=1$.\n\n**Evaluation of $E[T]_{\\text{bounded at }r^*=1}$**\nUsing the formula for $E[T](r)$ with $r=1$:\n$$E[T](1) = (t_s+hP_f) \\frac{1-P_f}{P_s} + t_f P_f = (t_s+hP_f) \\frac{P_s}{P_s} + t_f P_f = t_s + hP_f + t_f P_f = t_s + (h+t_f)P_f$$\n$$E[T](1) = 20 + (5+120)(1-\\exp(-2)) = 20 + 125(1-\\exp(-2))$$\n$$E[T](1) = 145 - 125\\exp(-2) \\approx 145 - 125(0.135335) \\approx 145 - 16.9169 = 128.0831 \\mu s$$\nRounding to $4$ significant figures, $E[T]_{\\text{bounded at }r^*=1} \\approx 128.1 \\mu s$.\n\n**Evaluation of $E[T]_{\\text{backoff at }R_b=3}$**\nWe calculate the parameters for each attempt ($k=1, 2, 3$):\n- Attempt 1: $w_1 = 10(2^0)=10$. $P_{s,1}=\\exp(-2)$. $P_{f,1}=1-\\exp(-2)$. Time for success is $w_1+t_s=30$. Time for abort is $w_1+t_s+h=35$.\n- Attempt 2: $w_2 = 10(2^1)=20$. $P_{s,2}=\\exp(-2/2)=\\exp(-1)$. $P_{f,2}=1-\\exp(-1)$. Time for success is $w_2+t_s=40$. Time for abort is $w_2+t_s+h=45$.\n- Attempt 3: $w_3 = 10(2^2)=40$. $P_{s,3}=\\exp(-2/4)=\\exp(-0.5)$. $P_{f,3}=1-\\exp(-0.5)$. Time for success is $w_3+t_s=60$. Time for abort is $w_3+t_s+h=65$.\n\nNow we sum the (Time $\\times$ Probability) for each possible path:\n- Success at $k=1$:\n    - Time = $30$. Prob = $P_{s,1} = \\exp(-2)$.\n- Fail at $k=1$, Success at $k=2$:\n    - Time = $35+40=75$. Prob = $P_{f,1}P_{s,2} = (1-\\exp(-2))\\exp(-1)$.\n- Fail at $k=1,2$, Success at $k=3$:\n    - Time = $35+45+60=140$. Prob = $P_{f,1}P_{f,2}P_{s,3} = (1-\\exp(-2))(1-\\exp(-1))\\exp(-0.5)$.\n- Fail at $k=1,2,3$, Fallback:\n    - Time = $35+45+65+t_f = 145+120=265$. Prob = $P_{f,1}P_{f,2}P_{f,3} = (1-\\exp(-2))(1-\\exp(-1))(1-\\exp(-0.5))$.\n\n$$E[T]_{\\text{backoff}} = 30\\exp(-2) + 75(1-\\exp(-2))\\exp(-1) + 140(1-\\exp(-2))(1-\\exp(-1))\\exp(-0.5) + 265(1-\\exp(-2))(1-\\exp(-1))(1-\\exp(-0.5))$$\n$$E[T]_{\\text{backoff}} \\approx 30(0.135335) + 75(0.864665)(0.367879) + 140(0.864665)(0.632121)(0.606531) + 265(0.864665)(0.632121)(0.393469)$$\n$$E[T]_{\\text{backoff}} \\approx 4.060058 + 23.834054 + 46.409943 + 57.001506 \\approx 131.30556 \\mu s$$\nRounding to $4$ significant figures, $E[T]_{\\text{backoff at }R_b=3} \\approx 131.3 \\mu s$.\n\nThe final results are $r^*=1$, $E[T]_{\\text{bounded at }r^*=1} \\approx 128.1 \\mu s$, and $E[T]_{\\text{backoff at }R_b=3} \\approx 131.3 \\mu s$.", "answer": "$$ \\boxed{ \\begin{pmatrix} 1  128.1  131.3 \\end{pmatrix} } $$", "id": "3645908"}]}