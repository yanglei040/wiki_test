{"hands_on_practices": [{"introduction": "In parallel computing, performance can be mysteriously degraded by a phenomenon known as \"false sharing,\" where logically independent data items happen to reside on the same cache line. This exercise [@problem_id:3658524] challenges you to quantify the coherence traffic caused by this issue by meticulously tracking cache line states and counting invalidation events. By comparing the scenario before and after re-aligning the data, you will gain a concrete understanding of why data layout is critical for performance in multi-core systems.", "problem": "A symmetric multiprocessor has $4$ identical cores, each with a private level-$1$ data cache that is write-back, write-allocate, and enforces coherence by a snooping protocol that is either Modified–Exclusive–Shared–Invalid (MESI) or Modified–Owned–Exclusive–Shared–Invalid (MOESI). The cache line size is $64$ bytes. All caches are initially empty.\n\nConsider a data structure consisting of $4$ unrelated $8$-byte counters laid out contiguously in memory at addresses $A_0 + 8k$ for $k \\in \\{0,1,2,3\\}$, where $A_0$ is aligned to a $64$-byte cache line boundary. Thus, all $4$ counters occupy the same cache line. Core $k$ repeatedly executes a tight loop that increments its own counter at address $A_0 + 8k$ exactly $W$ times, where $W = 10^{6}$. There are no other memory accesses to these addresses. The execution is scheduled in strict round-robin order across cores, one store per core per time slot, so that ownership of the shared cache line alternates between cores on every store. Define an invalidation event as a coherence-induced transition of a cache line in some core from a valid state ($M$, $E$, $S$, or $O$) to the invalid state ($I$) because of another core’s request.\n\nUsing only the standard semantics of MESI and MOESI states, write-allocate behavior, and the fact that two addresses map to the same cache line if and only if they fall within the same $64$-byte block, answer the following:\n\n- Derive, under MESI, the total number of invalidation events caused by the $4W$ stores to the $4$ counters in the given layout and schedule.\n- Argue whether this total changes under MOESI for this specific write–write pattern and justify your conclusion from first principles.\n- Propose a transformation that segregates these $4$ unrelated counters across cache lines (for example, padding so that each counter starts at the beginning of a distinct $64$-byte line with $64$-byte alignment), and derive the total number of invalidation events under the same schedule and $W$ after this transformation.\n\nLet $D$ denote the difference between the total number of invalidation events before the transformation and the total number after the transformation. Compute $D$ as a single integer. Express your final answer as an integer with no units. Do not round.", "solution": "The problem asks for an analysis of cache coherence-induced invalidations in a symmetric multiprocessor system under two different data layouts. The core of the problem is to understand the state transitions of a cache line under MESI and MOESI protocols in a \"false sharing\" scenario versus a scenario with proper data alignment.\n\nFirst, we establish the fundamental states and transitions relevant to the problem. The MESI protocol defines four states for a cache line:\n- **Modified ($M$)**: The line is present only in the current cache, is dirty (modified), and its value in main memory is stale.\n- **Exclusive ($E$)**: The line is present only in the current cache, is clean, and matches the value in main memory.\n- **Shared ($S$)**: The line is present in this cache and at least one other cache, is clean, and matches main memory.\n- **Invalid ($I$)**: The line is not present in the cache.\n\nThe MOESI protocol adds a fifth state:\n- **Owned ($O$)**: The line is present in this cache and may be present in other caches in the $S$ state. The line is dirty, and this cache is responsible for writing it back to memory. Main memory's copy is stale. The $O$ state allows sharing of dirty data without a write-back to memory.\n\nAn invalidation event is defined as a transition from any valid state ($M$, $E$, $S$, or $O$) to the $I$ state, triggered by another core's bus request. A write miss by a core causes it to issue a read-with-intent-to-modify (RWITM) bus request, often denoted as `BusRdX`. When a cache holding a line in state $M$ or $O$ snoops a `BusRdX` from another core for that same line, it must relinquish ownership and invalidate its copy.\n\nThe system has $4$ cores, and each performs $W = 10^6$ increments. The total number of stores is $4W$. The schedule is a strict round-robin of stores: $C_0, C_1, C_2, C_3, C_0, C_1, \\ldots$.\n\n**Part 1: Analysis Before Transformation (False Sharing)**\n\nIn this scenario, all $4$ counters, each of size $8$ bytes, reside in a single $64$-byte cache line, as the base address $A_0$ is aligned and $4 \\times 8 = 32 < 64$. This is a classic false sharing situation, where logically independent data items cause coherence traffic because they physically share a cache line.\n\n**Derivation of Invalidations under MESI:**\nLet's trace the state of the shared cache line across the $4$ cores, $P_0, P_1, P_2, P_3$. Initially, the line is $I$ in all caches.\n\n1.  **Store 1 (Core $P_0$):** $P_0$ has a write miss. It issues a `BusRdX` for the line. Since all other caches have the line in state $I$, main memory provides the data. $P_0$'s cache loads the line and sets its state to $M$. No other core holds a valid copy.\n    - State: $P_0:M, P_1:I, P_2:I, P_3:I$.\n    - Invalidation Events: $0$.\n\n2.  **Store 2 (Core $P_1$):** $P_1$ has a write miss and issues a `BusRdX`. $P_0$ snoops this request and sees it has the line in state $M$. To maintain coherence, $P_0$ must provide the data to $P_1$ (or let it go to memory first, while writing back its version) and then invalidate its own copy. $P_0$'s line state transitions from $M \\to I$. $P_1$ loads the line and sets its state to $M$.\n    - State: $P_0:I, P_1:M, P_2:I, P_3:I$.\n    - Invalidation Events: $1$ (in $P_0$).\n\n3.  **Store 3 (Core $P_2$):** $P_2$ has a write miss and issues a `BusRdX`. $P_1$ snoops this request, has the line in state $M$, provides the data, and invalidates its copy ($M \\to I$). $P_2$ sets its line state to $M$.\n    - State: $P_0:I, P_1:I, P_2:M, P_3:I$.\n    - Invalidation Events: $1$ (in $P_1$).\n\nThis pattern repeats. For every store from the second store onwards, the core that performed the previous store holds the line exclusively in the $M$ state. The current core's `BusRdX` request forces the previous owner to invalidate its copy.\n\nThe total number of stores is $4W$. The first store causes $0$ invalidations. Each of the subsequent $(4W-1)$ stores causes exactly one invalidation.\nTherefore, the total number of invalidation events before the transformation, $N_{before}$, is:\n$$N_{before} = 0 + (4W-1) \\times 1 = 4W-1$$\n\n**Justification for MOESI:**\nWe must argue whether this total changes under the MOESI protocol. The MOESI protocol introduces the $O$ state to optimize read-sharing of dirty lines. A transition from $M$ to $O$ happens when a core holding a line in state $M$ snoops a read request (`BusRd`). The owner supplies the data to the requester (which enters state $S$) and transitions its own state to $O$.\n\nHowever, the workload described in this problem consists *exclusively* of writes (increments are read-modify-write operations, which culminate in a store and, from a coherence perspective, are treated as writes that require exclusive ownership). A write miss always generates a `BusRdX` request. When a core in state $M$ (or $O$) snoops a `BusRdX`, it must invalidate its copy. The $O$ state is never entered because there are no simple read requests from other cores that would trigger the $M \\to O$ transition. The sequence of events is therefore identical to the MESI protocol. The cache line is always in state $M$ in exactly one cache and $I$ in all others. The total number of invalidations remains $4W-1$ under MOESI for this specific write-only, migratory access pattern.\n\n**Part 2: Analysis After Transformation**\n\nThe proposed transformation involves padding the data structure so that each of the $4$ counters resides on its own separate, dedicated $64$-byte cache line. Let's denote these lines as $L_0, L_1, L_2, L_3$. Core $P_k$ exclusively accesses line $L_k$.\n\nLet's analyze the accesses for a single core, say $P_0$ accessing line $L_0$.\n1.  **First Store by $P_0$:** $P_0$ has a write miss on line $L_0$. It issues a `BusRdX` for $L_0$. Since this is a distinct line, no other core has a copy. The line is fetched from memory, and $P_0$'s cache sets the state of $L_0$ to $M$.\n    - Invalidation Events: $0$.\n\n2.  **Subsequent $W-1$ Stores by $P_0$:** For all subsequent increments, $P_0$ finds line $L_0$ in its cache in state $M$. These are write hits. The writes are performed locally without generating any bus traffic.\n\nCrucially, no other core ($P_1, P_2, P_3$) ever accesses line $L_0$. An invalidation of $L_0$ in $P_0$'s cache would only occur if another core issued a `BusRd` or `BusRdX` for $L_0$. As this never happens, the line $L_0$ remains in state $M$ in $P_0$'s cache for the duration of its $W$ writes after the initial miss.\n\nThe same logic applies independently to cores $P_1, P_2,$ and $P_3$ and their respective dedicated lines $L_1, L_2,$ and $L_3$. Each core loads its line once, and it remains in state $M$ in that core's cache. No coherence traffic is generated for these lines after the initial compulsory miss for each.\n\nConsequently, there are zero coherence-induced invalidation events. The total number of invalidations after the transformation, $N_{after}$, is:\n$$N_{after} = 0$$\nThis result is independent of whether the protocol is MESI or MOESI.\n\n**Part 3: Final Calculation**\n\nThe problem asks for the difference, $D$, between the total number of invalidations before and after the transformation.\nWe are given $W = 10^6$.\n\n$$D = N_{before} - N_{after}$$\n$$D = (4W - 1) - 0$$\n$$D = 4 \\times 10^6 - 1$$\n$$D = 4,000,000 - 1$$\n$$D = 3,999,999$$\n\nThis substantial difference highlights the severe performance penalty of false sharing and the effectiveness of data padding as a mitigation strategy.", "answer": "$$\\boxed{3999999}$$", "id": "3658524"}, {"introduction": "The MOESI protocol's introduction of the `Owned` state is a key optimization designed to reduce memory bus traffic. This practice problem [@problem_id:3658496] allows you to see this optimization in action by analyzing a specific trace of memory accesses with defined latencies for cache and memory operations. By carefully calculating the completion time of a critical request under both MESI and MOESI, you will quantify the precise performance gain achieved by allowing a dirty cache line to be shared without an immediate write-back to memory.", "problem": "A shared-bus multiprocessor with $4$ private, write-back, write-allocate caches implements a snooping directory-less protocol. Consider a single cache line $X$ that is not present in any cache at time $t=0$ and is clean in main memory. The system obeys the Single-Writer, Multiple-Reader (SWMR) invariant: at any instant, at most one cache may hold a writable copy, while any number of caches may hold read-only copies. Two coherence protocols are considered: Modified, Exclusive, Shared, Invalid (MESI) and Modified, Owner, Exclusive, Shared, Invalid (MOESI). All cores issue coherence requests on a single broadcast address bus. The following fixed-latency response model holds for all requests, with latencies measured from the cycle when the request’s address is broadcast:\n- Main memory data response latency is $L_{\\mathrm{mem}}=20$ cycles.\n- Cache-to-cache data response latency from a cache that supplies data (only caches in state Modified under MESI, and in states Modified or Owner under MOESI) is $L_{\\mathrm{cc}}=8$ cycles.\n- Invalidation acknowledgments from each sharer arrive $L_{\\mathrm{inv}}=4$ cycles after the address broadcast. A requester may proceed with a write only after all required invalidation acknowledgments have been received and line data has arrived; the completion time is the maximum of these two arrival times.\n- If both a cache and main memory could supply data for the same request, the first valid data response to appear on the data bus “wins” and all later data responses are aborted. Caches in state Shared or Exclusive do not supply data; only main memory supplies clean data in those cases. In MESI, on a read that hits a Modified line in some other cache, the Modified cache supplies data and downgrades to Shared and the memory is updated (treated as clean) by the transaction completion. In MOESI, on a read that hits a Modified line, the supplier downgrades to Owner and memory remains stale.\n\nThe following trace of requests occurs at the given timestamps (in cycles), where “BusRd” denotes a read miss that requests a read-only copy, and “BusRdX” denotes a read-for-ownership (write miss) that requests a writable copy:\n- At time $t=0$, core $C_{0}$ issues BusRd for $X$.\n- At time $t=25$, core $C_{1}$ issues BusRd for $X$.\n- At time $t=50$, core $C_{0}$ issues a write to $X$ (this issues BusUpgr if it holds $X$ in Shared).\n- At time $t=60$, core $C_{2}$ issues BusRd for $X$.\n- At time $t=80$, core $C_{3}$ issues BusRdX for $X$.\n\nAssume arbitration grants the address bus immediately at each timestamp shown (i.e., the address broadcast occurs exactly at the stated time), and that data transfers and invalidation acknowledgments take place asynchronously according to the fixed latencies above. There are no structural hazards on the data bus beyond the winner-takes-all rule for concurrent potential data suppliers for the same request.\n\nTasks:\n- For each request, order the snoop responses and determine which agent (a cache or main memory) supplies the data, consistent with the given latencies and the SWMR invariant. Determine the coherence state transitions of $X$ in the involved caches at the completion of each request under both Modified, Exclusive, Shared, Invalid (MESI) and Modified, Owner, Exclusive, Shared, Invalid (MOESI).\n- Let $T_{\\mathrm{MESI}}$ be the completion time (in cycles) at which core $C_{3}$’s BusRdX for $X$ becomes able to perform the write under MESI, and let $T_{\\mathrm{MOESI}}$ be the corresponding completion time under MOESI. Compute the difference $\\Delta T = T_{\\mathrm{MESI}} - T_{\\mathrm{MOESI}}$.\n\nExpress your final answer for $\\Delta T$ as an integer number of cycles. No rounding is required.", "solution": "We will trace the state of cache line $X$ in the four caches ($C_0, C_1, C_2, C_3$) and main memory for both MESI and MOESI protocols. The initial state at $t=0$ for all caches is Invalid (I).\n\n**MESI Protocol Analysis**\n\n1.  **$t=0$: $C_0$ issues BusRd for $X$.**\n    - $C_0$ has a read miss. It broadcasts a BusRd request.\n    - No other cache holds $X$. Main memory must supply the data.\n    - Data arrives at $t = 0 + L_{\\mathrm{mem}} = 20$.\n    - At $t=20$, $C_0$ receives the data. Since it is the only cache with a copy, its state becomes Exclusive (E).\n    - States at $t=20$: $C_0(\\text{E}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, Mem(clean).\n\n2.  **$t=25$: $C_1$ issues BusRd for $X$.**\n    - $C_1$ has a read miss and broadcasts BusRd.\n    - $C_0$ snoops the request and sees it has the line in state E. As per the rules, a cache in state E does not supply data. Main memory supplies the clean data.\n    - Data arrives at $C_1$ at $t = 25 + L_{\\mathrm{mem}} = 45$.\n    - The presence of a sharer forces $C_0$ to downgrade its state.\n    - At $t=45$, the transaction completes. $C_1$ transitions to Shared (S), and $C_0$ transitions from E to S.\n    - States at $t=45$: $C_0(\\text{S}), C_1(\\text{S}), C_2(\\text{I}), C_3(\\text{I})$, Mem(clean).\n\n3.  **$t=50$: $C_0$ issues a write to $X$.**\n    - $C_0$ holds the line in S, requiring an upgrade to gain write permission. It broadcasts a BusUpgr request (equivalent to a BusRdX without data request).\n    - $C_1$ snoops the request and must invalidate its copy. It sends an invalidation acknowledgment (ack).\n    - The ack from $C_1$ arrives at $C_0$ at $t = 50 + L_{\\mathrm{inv}} = 54$.\n    - $C_0$ already has the data. It can perform the write after receiving all acks. The write completes at $t=54$.\n    - Upon completion, $C_0$ transitions to Modified (M). $C_1$ transitions to I.\n    - States at $t=54$: $C_0(\\text{M}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, Mem(stale).\n\n4.  **$t=60$: $C_2$ issues BusRd for $X$.**\n    - $C_2$ has a read miss and broadcasts BusRd.\n    - $C_0$ snoops the request and sees it holds the line in M. According to the rules, $C_0$ must supply the data. This is a cache-to-cache transfer.\n    - Data arrives at $C_2$ at $t = 60 + L_{\\mathrm{cc}} = 68$.\n    - The MESI rule for this case states the supplier ($C_0$) downgrades to S and memory is updated. The transaction completes at $t=68$.\n    - $C_2$ transitions to S. $C_0$ transitions from M to S.\n    - States at $t=68$: $C_0(\\text{S}), C_1(\\text{I}), C_2(\\text{S}), C_3(\\text{I})$, Mem(clean).\n\n5.  **$t=80$: $C_3$ issues BusRdX for $X$.**\n    - $C_3$ has a write miss and broadcasts BusRdX.\n    - $C_0$ and $C_2$ both hold the line in S. They must invalidate their copies and send acks.\n    - Acks from $C_0$ and $C_2$ arrive at $t = 80 + L_{\\mathrm{inv}} = 84$.\n    - Since the existing copies in $C_0$ and $C_2$ are clean (S state), main memory supplies the data to $C_3$.\n    - Data arrives at $C_3$ at $t = 80 + L_{\\mathrm{mem}} = 100$.\n    - $C_3$ can perform its write after both data and all acks have arrived. Completion time is $\\max(100, 84) = 100$.\n    - Thus, $T_{\\mathrm{MESI}} = 100$ cycles.\n\n**MOESI Protocol Analysis**\n\nThe first three events are identical to the MESI protocol.\n\n1.  **$t=0$: $C_0$ issues BusRd for $X$.**\n    - Completion at $t=20$. States: $C_0(\\text{E}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, Mem(clean).\n2.  **$t=25$: $C_1$ issues BusRd for $X$.**\n    - Completion at $t=45$. States: $C_0(\\text{S}), C_1(\\text{S}), C_2(\\text{I}), C_3(\\text{I})$, Mem(clean).\n3.  **$t=50$: $C_0$ issues a write to $X$.**\n    - Completion at $t=54$. States: $C_0(\\text{M}), C_1(\\text{I}), C_2(\\text{I}), C_3(\\text{I})$, Mem(stale).\n\n4.  **$t=60$: $C_2$ issues BusRd for $X$.**\n    - $C_2$ has a read miss and broadcasts BusRd.\n    - $C_0$ snoops the request and holds the line in M. It must supply the data.\n    - Data arrives at $C_2$ at $t = 60 + L_{\\mathrm{cc}} = 68$.\n    - Here, the MOESI protocol diverges. The rule states: \"the supplier downgrades to Owner and memory remains stale.\"\n    - At transaction completion ($t=68$), $C_0$ transitions from M to Owner (O), and $C_2$ transitions to S. Memory is not updated.\n    - States at $t=68$: $C_0(\\text{O}), C_1(\\text{I}), C_2(\\text{S}), C_3(\\text{I})$, Mem(stale).\n\n5.  **$t=80$: $C_3$ issues BusRdX for $X$.**\n    - $C_3$ has a write miss and broadcasts BusRdX.\n    - $C_0$ (in state O) and $C_2$ (in state S) are sharers. They must invalidate and send acks.\n    - Acks arrive at $t = 80 + L_{\\mathrm{inv}} = 84$.\n    - The rule states that a cache in state O must supply data. $C_0$ is the owner and holds the most recent copy. Main memory is stale.\n    - $C_0$ supplies the data to $C_3$. This is a cache-to-cache transfer.\n    - Data arrives at $C_3$ at $t = 80 + L_{\\mathrm{cc}} = 88$.\n    - $C_3$ can perform its write after both data and acks have arrived. Completion time is $\\max(88, 84) = 88$.\n    - Thus, $T_{\\mathrm{MOESI}} = 88$ cycles.\n\n**Final Calculation**\n\nThe problem asks for the difference $\\Delta T = T_{\\mathrm{MESI}} - T_{\\mathrm{MOESI}}$.\n- $T_{\\mathrm{MESI}} = 100$ cycles.\n- $T_{\\mathrm{MOESI}} = 88$ cycles.\n\n$$\n\\Delta T = T_{\\mathrm{MESI}} - T_{\\mathrm{MOESI}} = 100 - 88 = 12\n$$\nThe difference in completion time arises because in the final step, the data for $C_3$'s request is supplied by slow main memory ($L_{\\mathrm{mem}}=20$) in the MESI case, whereas it is supplied by a fast cache-to-cache transfer ($L_{\\mathrm{cc}}=8$) from the Owner cache in the MOESI case.", "answer": "$$\\boxed{12}$$", "id": "3658496"}, {"introduction": "Real-world multi-core systems must gracefully handle simultaneous requests for the same data. This thought experiment [@problem_id:3658513] delves into the resolution of a race condition where two cores attempt to gain exclusive write access to a shared cache line at the same time. Working through this scenario will clarify how bus arbitration and the write-invalidate rules of the MESI protocol work in concert to serialize conflicting requests and guarantee that the system's single-writer invariant is never violated.", "problem": "A shared-memory multiprocessor uses a snooping write-invalidate cache coherence protocol implementing Modified–Exclusive–Shared–Invalid (MESI). The interconnect is a single arbitration-based bus that serializes transactions: in any instant, only one coherence transaction can be on the bus, and the arbiter grants the bus to one requester while causing any contending requester to receive a negative acknowledgment (NACK), which forces a retry later. Caches perform write-back, and the protocol supports the following coherence requests: BusRd (read), BusRdX (read-for-ownership), and BusUpgr (upgrade-to-exclusive when the requester already holds the line in Shared). Read For Ownership (RFO) is realized as BusUpgr if the requester holds the line in Shared, otherwise as BusRdX.\n\nInitially, cores $\\mathrm{C}0$ and $\\mathrm{C}1$ each hold cache line $X$ in the Shared state $S$. At time $t_0$, both cores simultaneously execute a store to $X$, causing both to issue an RFO on $X$.\n\nStarting only from the core definitions of MESI states and the write-invalidate rule—namely:\n- Invariant: at most one cache may hold a line in Modified $M$ at any time, and any write requires exclusive ownership (no other valid copies).\n- Semantics: BusUpgr invalidates all other sharers and upgrades the requester’s $S$ to $M$ without fetching data; BusRdX obtains the line and invalidates all other copies, granting the requester $M$.\n\nAssume typical snoop responses and that a core whose request is NACKed must retry later after snooping and processing any intervening bus transactions.\n\nPredict the race resolution under MESI when the two RFOs occur “simultaneously,” and compute the total number of invalidations broadcast on the bus and the number of retries required until both stores complete (i.e., until each core has, in turn, written $X$ once). Which option best matches the correct mechanism and counts?\n\nA. One RFO wins arbitration first and issues BusUpgr, invalidating the other sharer (total invalidations so far $=1$). The loser snoops this and invalidates its own copy; its outstanding request is NACKed and must be retried once later as BusRdX (because it now holds $I$). That second transaction invalidates the current $M$ owner (adding $1$ invalidation) and transfers ownership. Totals: invalidations $=2$, retries $=1$.\n\nB. The snooping fabric merges the two upgrades; both caches move to $M$ simultaneously without further traffic. Totals: invalidations $=0$, retries $=0$.\n\nC. Arbitration places both upgrades back-to-back without NACKs; the first invalidates the second, but the second proceeds anyway and succeeds because there are no remaining sharers. Totals: invalidations $=1$, retries $=0$.\n\nD. The first requester’s BusUpgr invalidates the other sharer (invalidations $=1$). The loser must back off and retry twice before success, and when it finally retries, the current owner merely downgrades to Shared without being invalidated. Totals: invalidations $=1$, retries $=2$.", "solution": "We proceed from the core MESI definitions and the write-invalidate discipline.\n\nFundamental base facts:\n- MESI states: Modified ($M$), Exclusive ($E$), Shared ($S$), Invalid ($I$). The coherence invariant requires that at most one cache holds a given line in $M$ at any time. Any write requires exclusive ownership, meaning no valid copies exist elsewhere.\n- Write-invalidate rule: A requester that wishes to write must ensure all other sharers are invalidated. If the requester holds $S$, it may issue BusUpgr to invalidate others without fetching data, then transition $S \\rightarrow M$. If the requester holds $I$, it issues BusRdX to fetch the line and invalidate others, transitioning $I \\rightarrow M$.\n- Bus serialization and NACK: With a single arbitration-based snooping bus, simultaneous requests are serialized. One requester is granted the bus; any contending requester is NACKed and must retry later. Meanwhile, all caches snoop bus transactions and update their states accordingly.\n\nInitial condition at time $t_0$: cores $\\mathrm{C}0$ and $\\mathrm{C}1$ both hold $X$ in $S$ and both issue RFOs. Because each holds $S$, each will attempt BusUpgr.\n\nDerivation of the race resolution:\n- Step $1$: Bus arbitration chooses one requester (say $\\mathrm{C}0$) at time $t_0$. $\\mathrm{C}0$’s BusUpgr appears on the bus. By the write-invalidate rule, BusUpgr broadcasts an invalidation to all other sharers. There is exactly one other sharer ($\\mathrm{C}1$), so the number of invalidations in this step is $1$.\n- Step $2$: $\\mathrm{C}1$ snoops the BusUpgr and invalidates its copy, transitioning $S \\rightarrow I$. Because the bus is serialized, $\\mathrm{C}1$’s simultaneous BusUpgr cannot also be on the bus at the same instant; it is either not issued or is NACKed due to losing arbitration. Under the stated assumption, the loser’s outstanding request is NACKed and must be retried later. Therefore, the number of retries needed so far is $1$ (for $\\mathrm{C}1$).\n- Step $3$: After $\\mathrm{C}0$’s BusUpgr completes, $\\mathrm{C}0$ transitions $S \\rightarrow M$ and performs its write. At this point, $\\mathrm{C}0$ is the sole $M$ owner of $X$; $\\mathrm{C}1$ holds $I$.\n- Step $4$: When $\\mathrm{C}1$ retries, it no longer holds $S$. To write $X$, it must issue BusRdX (an RFO from $I$). BusRdX invalidates all other valid copies. There is exactly one such copy, held by $\\mathrm{C}0$ in $M$. Hence, this step generates $1$ invalidation directed at $\\mathrm{C}0$’s copy. The current $M$ owner ($\\mathrm{C}0$) supplies or forwards data and transitions to $I$, while $\\mathrm{C}1$ transitions $I \\rightarrow M$ and performs its write.\n\nCounting the events until both stores complete (i.e., both $\\mathrm{C}0$ and $\\mathrm{C}1$ have written $X$ once):\n- Total invalidations: $1$ (from the first BusUpgr invalidating the other sharer) $+ 1$ (from the later BusRdX invalidating the current $M$ owner) $= 2$.\n- Total retries: The loser’s initial RFO is NACKed once and must be retried once later. No further retries are required under the stated fair arbitration and standard snoop behavior. Thus, retries $= 1$.\n\nNote on why other outcomes are incorrect:\n- It is impossible for both caches to be in $M$ simultaneously under MESI’s single-writer invariant. Therefore, any “merge” that grants $M$ to both (or lets both upgrades succeed without serialization) violates the fundamental coherence invariant.\n- After the loser is invalidated, it cannot “upgrade” because it no longer holds a valid copy; it must perform BusRdX, which necessarily invalidates the current owner to obtain exclusivity for a write.\n\nOption-by-option analysis:\n- Option A: Matches the derived sequence. First BusUpgr invalidates the other sharer (invalidations so far $=1$). The loser’s initial request is NACKed and must be retried once; upon retry from $I$, it uses BusRdX, which invalidates the current $M$ owner (adding $1$ invalidation). Totals: invalidations $=2$, retries $=1$. Verdict: Correct.\n- Option B: Claims a merged success with both in $M$, generating no invalidations or retries. This contradicts MESI’s single-writer invariant and the bus serialization assumption; at least one invalidation must occur to eliminate other sharers before a write, and both cannot hold $M$. Verdict: Incorrect.\n- Option C: Suggests both upgrades proceed back-to-back without NACKs and the second succeeds immediately after being invalidated by the first. This is internally inconsistent: the second requester would have invalidated its own copy due to snooping the first upgrade, so it can no longer perform an “upgrade” from $S$; it must issue BusRdX later, which both requires a retry and invalidates the current owner. Moreover, without a NACK, two transactions cannot occupy the bus simultaneously under the given model. Verdict: Incorrect.\n- Option D: Posits two retries and no invalidation of the owner upon the second request, with the owner merely downgrading to $S$. Under MESI, a write requires exclusivity; the current owner must be invalidated, not merely downgraded to $S$, for the requester to obtain $M$. The extra retry count is also unjustified under the stated fair arbiter assumption. Verdict: Incorrect.\n\nAdditional context on Modified–Owned–Exclusive–Shared–Invalid (MOESI): If the second access were a read rather than a write, MOESI’s Owned ($O$) state could allow the prior $M$ owner to supply data and remain a designated owner without immediate write-back. However, in this scenario both accesses are writes (RFOs), so exclusivity still requires invalidating the other holder; the counts above remain as derived for MESI.", "answer": "$$\\boxed{A}$$", "id": "3658513"}]}