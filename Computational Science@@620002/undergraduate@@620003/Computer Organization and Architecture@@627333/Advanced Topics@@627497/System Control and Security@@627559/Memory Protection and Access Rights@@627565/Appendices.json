{"hands_on_practices": [{"introduction": "At the heart of memory protection lies a simple yet powerful mechanism: the read ($r$), write ($w$), and execute ($x$) permission bits. This first practice grounds your understanding in this fundamental hardware behavior. By tracking changes to a page's permissions over time and calculating the resulting protection faults, you will see directly how the Memory Management Unit (MMU) enforces access rights for every memory operation [@problem_id:3658221].", "problem": "A single virtual memory page in a computer system is protected by three permission bits maintained in the page table entry: the read bit $r$, the write bit $w$, and the execute bit $x$. The Memory Management Unit (MMU) enforces these permissions: a memory read is permitted if and only if $r$ is set, a memory write is permitted if and only if $w$ is set, and an instruction fetch (execution) is permitted if and only if $x$ is set. Any attempted operation not permitted by the current permission bits causes a protection exception (fault). Assume that permission changes are atomic and take effect immediately at the indicated times, with no caching delays.\n\nAt times $t_0<t_1<t_2$, the operating system updates the permissions for the page as follows:\n- At time $t_0$: $(r,w,x)$.\n- At time $t_1$: $(r,\\neg w,\\neg x)$.\n- At time $t_2$: $(\\neg r,\\neg w,\\neg x)$.\n\nA process attempts the following batches of operations exactly at each $t_i$:\n- At $t_0$: $A_0=5$ reads, $B_0=9$ writes, $C_0=7$ instruction fetches.\n- At $t_1$: $A_1=11$ reads, $B_1=4$ writes, $C_1=6$ instruction fetches.\n- At $t_2$: $A_2=3$ reads, $B_2=2$ writes, $C_2=1$ instruction fetches.\n\nStarting from the core definitions of permission enforcement described above, construct the permission timeline and, for each $t_i$, map which operation types would raise faults. Then, using that mapping, compute the total number of faults across all three times $t_0$, $t_1$, and $t_2$. Provide the final answer as a single integer. No rounding is required.", "solution": "The problem asks for the total number of protection faults generated by a series of memory access attempts at specific points in time, governed by a changing set of permissions. The core of the problem lies in the logical rules enforced by the Memory Management Unit (MMU).\n\nLet us formalize the state of the permission bits. We can represent the permission set as a vector $(r, w, x)$, where a bit is $1$ if the permission is granted (set) and $0$ if it is denied (not set, or $\\neg$). The three operation types are read, write, and instruction fetch (execute).\n\nThe enforcement rules are:\n1.  A read operation is permitted if and only if $r=1$. An attempted read when $r=0$ causes a fault.\n2.  A write operation is permitted if and only if $w=1$. An attempted write when $w=0$ causes a fault.\n3.  An execute operation (instruction fetch) is permitted if and only if $x=1$. An attempted execute when $x=0$ causes a fault.\n\nThe problem states that at each time $t_i$, for $i \\in \\{0, 1, 2\\}$, the permissions are updated, and a batch of operations is attempted. The number of faults for a given operation type is the number of attempts if the corresponding permission bit is $0$, and zero if the bit is $1$.\n\nLet $F_i$ be the total number of faults at time $t_i$. Let $(r_i, w_i, x_i)$ be the permission state at time $t_i$. Let $A_i, B_i, C_i$ be the number of attempted reads, writes, and executes at time $t_i$, respectively.\n\nThe number of faults for each operation type at time $t_i$ can be expressed as:\n- Read faults: $F_{read, i} = A_i \\cdot (1 - r_i)$\n- Write faults: $F_{write, i} = B_i \\cdot (1 - w_i)$\n- Execute faults: $F_{exec, i} = C_i \\cdot (1 - x_i)$\n\nThe total faults at time $t_i$ is $F_i = F_{read, i} + F_{write, i} + F_{exec, i}$. The total faults across all time points is $F_{total} = F_0 + F_1 + F_2$.\n\nWe will now analyze the events at each time point.\n\n**Analysis at time $t_0$:**\n- The permissions are set to $(r, w, x)$. In our binary notation, this is the state $(r_0, w_0, x_0) = (1, 1, 1)$.\n-\n  - Read permission is granted ($r_0=1$).\n  - Write permission is granted ($w_0=1$).\n  - Execute permission is granted ($x_0=1$).\n- The attempted operations are $A_0=5$ reads, $B_0=9$ writes, and $C_0=7$ instruction fetches.\n- We calculate the faults at $t_0$:\n  - Read faults: $F_{read, 0} = A_0 (1-r_0) = 5(1-1) = 5 \\cdot 0 = 0$.\n  - Write faults: $F_{write, 0} = B_0 (1-w_0) = 9(1-1) = 9 \\cdot 0 = 0$.\n  - Execute faults: $F_{exec, 0} = C_0 (1-x_0) = 7(1-1) = 7 \\cdot 0 = 0$.\n- The total number of faults at $t_0$ is $F_0 = 0 + 0 + 0 = 0$.\n\n**Analysis at time $t_1$:**\n- The permissions are updated to $(r, \\neg w, \\neg x)$. In our binary notation, this is the state $(r_1, w_1, x_1) = (1, 0, 0)$.\n-\n  - Read permission is granted ($r_1=1$).\n  - Write permission is denied ($w_1=0$).\n  - Execute permission is denied ($x_1=0$).\n- The attempted operations are $A_1=11$ reads, $B_1=4$ writes, and $C_1=6$ instruction fetches.\n- We calculate the faults at $t_1$:\n  - Read faults: $F_{read, 1} = A_1 (1-r_1) = 11(1-1) = 11 \\cdot 0 = 0$.\n  - Write faults: $F_{write, 1} = B_1 (1-w_1) = 4(1-0) = 4 \\cdot 1 = 4$.\n  - Execute faults: $F_{exec, 1} = C_1 (1-x_1) = 6(1-0) = 6 \\cdot 1 = 6$.\n- The total number of faults at $t_1$ is $F_1 = 0 + 4 + 6 = 10$.\n\n**Analysis at time $t_2$:**\n- The permissions are updated to $(\\neg r, \\neg w, \\neg x)$. In our binary notation, this is the state $(r_2, w_2, x_2) = (0, 0, 0)$.\n-\n  - Read permission is denied ($r_2=0$).\n  - Write permission is denied ($w_2=0$).\n  - Execute permission is denied ($x_2=0$).\n- The attempted operations are $A_2=3$ reads, $B_2=2$ writes, and $C_2=1$ instruction fetch.\n- We calculate the faults at $t_2$:\n  - Read faults: $F_{read, 2} = A_2 (1-r_2) = 3(1-0) = 3 \\cdot 1 = 3$.\n  - Write faults: $F_{write, 2} = B_2 (1-w_2) = 2(1-0) = 2 \\cdot 1 = 2$.\n  - Execute faults: $F_{exec, 2} = C_2 (1-x_2) = 1(1-0) = 1 \\cdot 1 = 1$.\n- The total number of faults at $t_2$ is $F_2 = 3 + 2 + 1 = 6$.\n\n**Total Faults Calculation:**\nTo find the total number of faults, we sum the faults from each time point:\n$$F_{total} = F_0 + F_1 + F_2$$\n$$F_{total} = 0 + 10 + 6 = 16$$\nTherefore, across the three time points, a total of $16$ protection faults will be generated.", "answer": "$$\n\\boxed{16}\n$$", "id": "3658221"}, {"introduction": "Building on the basic mechanics, we now scale up to a system-level view where multiple processes interact with multiple memory pages. This exercise models access rights using a permission matrix and introduces critical security invariants, such as the 'Write XOR Execute' (W^X) policy. Your task is to modify permissions to satisfy a request while upholding these system-wide rules, teaching you to reason about the dependencies and consequences of permission changes [@problem_id:3658191].", "problem": "Consider a system that enforces process-page memory protection via a permission matrix $M \\in \\mathbb{Z}^{n \\times m}$, where entry $M_{ij}$ encodes the access rights of process $i$ to page $j$. Each entry is a bitmask over the set $\\{r,w,x\\}$ with $r \\mapsto 1$, $w \\mapsto 2$, and $x \\mapsto 4$. Rights are combined by bitwise addition, so, for example, $r \\wedge w$ is encoded as $3$ and $r \\wedge x$ as $5$. The matrix is currently\n$$\nM=\n\\begin{pmatrix}\n5 & 1 & 0 \\\\\n1 & 3 & 4 \\\\\n0 & 0 & 0 \\\\\n1 & 1 & 0\n\\end{pmatrix},\n$$\nwith rows indexed by processes $i \\in \\{1,2,3,4\\}$ and columns by pages $j \\in \\{1,2,3\\}$. Two system invariants must hold at all times:\n\n1. Single-writer per page: for every page $j$, \n$$\n\\sum_{i=1}^{n} \\mathbf{1}_{\\{w \\in M_{ij}\\}} \\leq 1,\n$$\nwhere $\\mathbf{1}_{\\{w \\in M_{ij}\\}}$ equals $1$ if $w$ is present in $M_{ij}$ and $0$ otherwise.\n\n2. Write XOR Execute (W^X) policy: if there exists any process $i$ such that $x \\in M_{ij}$ for a page $j$, then for all processes $k$,\n$$\nw \\notin M_{kj}.\n$$\n\nA workflow requires that process $p=3$ obtain $(r,w)$ access on page $q=2$ only for the duration of a transaction. Access rights may be changed by toggling individual permission bits in entries $M_{ij}$; a single bit toggle changes one of $\\{r,w,x\\}$ in a single $M_{ij}$ from present to absent or vice versa. The original matrix must be restored after the transaction completes. Determine the minimal total number of bit toggles required to (i) reach a state in which process $3$ has $(r,w)$ on page $2$ while both invariants hold, and then (ii) restore the matrix to its original state, ensuring both invariants hold at all times during the sequence of changes. Provide the final answer as an integer count of bit toggles. No rounding is required.", "solution": "First, we decode the initial permission matrix $M$ from its integer representation into sets of permissions using the bitmask definitions ($r=1, w=2, x=4$).\n$$\nM=\n\\begin{pmatrix}\n5 & 1 & 0 \\\\\n1 & 3 & 4 \\\\\n0 & 0 & 0 \\\\\n1 & 1 & 0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\{r,x\\} & \\{r\\} & \\{\\} \\\\\n\\{r\\} & \\{r,w\\} & \\{x\\} \\\\\n\\{\\} & \\{\\} & \\{\\} \\\\\n\\{r\\} & \\{r\\} & \\{\\}\n\\end{pmatrix}\n$$\nWe verify that this initial state satisfies the two invariants. The single-writer invariant holds, as only process 2 has write access to page 2, and no other page has a writer. The W^X invariant holds, as pages 1 and 3, which have execute permissions, have no writers.\n\nThe problem is divided into two phases: acquiring permissions and restoring them.\n\n**Phase (i): Acquiring Permissions for Process 3**\n\nThe goal is to give process 3 $\\{r,w\\}$ access on page 2. This means changing $M_{32}$ from $0$ ($\\{\\}$) to $3$ ($\\{r,w\\}$). This requires two bit toggles: turning 'r' ON and turning 'w' ON.\n\nHowever, the invariants must hold at all times. The 'w' toggle is critical. Initially, process 2 has write permission on page 2 ($M_{22}=\\{r,w\\}$). If we simply grant write permission to process 3, page 2 would have two writers, violating the single-writer invariant.\n\nTo maintain the invariant, we must first revoke write permission from process 2 before granting it to process 3. This requires an additional bit toggle. The sequence of minimal changes is:\n1.  Toggle 'w' OFF for $M_{22}$ (changes from $3$ to $1$). Now page 2 has no writers. ($1$ toggle)\n2.  Toggle 'r' ON for $M_{32}$ (changes from $0$ to $1$). ($1$ toggle)\n3.  Toggle 'w' ON for $M_{32}$ (changes from $1$ to $3$). Now process 3 is the sole writer. ($1$ toggle)\n\nA minimum of $3$ bit toggles are required for this phase.\n\n**Phase (ii): Restoring the Original State**\n\nNow we must reverse the changes to restore the original matrix. The starting state for this phase has $M_{22}=1$ and $M_{32}=3$. The target is the original state where $M_{22}=3$ and $M_{32}=0$.\nThis requires:\n- Changing $M_{32}$ from $3$ to $0$. This means toggling 'r' OFF and 'w' OFF (2 toggles).\n- Changing $M_{22}$ from $1$ to $3$. This means toggling 'w' ON (1 toggle).\n\nAgain, we must respect the single-writer invariant. Before granting write permission back to process 2, we must first revoke it from process 3.\nThe minimal sequence is:\n1.  Toggle 'w' OFF for $M_{32}$ (changes from $3$ to $1$). Now page 2 has no writers. ($1$ toggle)\n2.  Toggle 'w' ON for $M_{22}$ (changes from $1$ to $3$). Now process 2 is the sole writer. ($1$ toggle)\n3.  Toggle 'r' OFF for $M_{32}$ (changes from $1$ to $0$). ($1$ toggle)\n\nA minimum of $3$ bit toggles are also required for this restoration phase.\n\n**Total Toggles**\nThe total minimal number of bit toggles is the sum from both phases:\nTotal toggles = $3$ (acquire) + $3$ (restore) = $6$.", "answer": "$$\\boxed{6}$$", "id": "3658191"}, {"introduction": "Theory meets reality in this final practice, which explores the practical challenges of enforcing memory protection on page-based hardware. You will analyze a common scenario where a program's code and data segments are not neatly aligned with page boundaries, creating a violation of the strict code-data separation policy. Your goal is to determine the new, compliant memory layout, providing insight into how operating systems manage virtual address spaces to ensure security [@problem_id:3658208].", "problem": "A virtual memory subsystem enforces strict separation of instruction and data: no page may simultaneously permit both writing and instruction fetch, and no page may contain both code bytes and data bytes. Each page has size $P = 4$ KiB (that is, $P = 4096$ bytes), and permissions are assigned per page. A process currently has a single contiguous region mapped with permissive rights (read, write, and execute) spanning the half-open interval $\\left[0x00400000, 0x00409000\\right)$ in virtual addresses (measured in bytes). Within this region, the actual code bytes occupy the half-open interval $\\left[0x00400080, 0x00401F20\\right)$ and the actual data bytes occupy the half-open interval $\\left[0x00401F20, 0x00408AB5\\right)$. All addresses are virtual and assumed to be byte-addressable. The subranges outside these code and data intervals but inside the original mapping are unused padding.\n\nTo bring the mapping into compliance with the strict separation policy, the operating system must:\n- Re-map the code onto a set of whole pages that cover all code bytes and no data bytes, granting those pages read and execute permission only.\n- Re-map the data onto a disjoint set of whole pages that cover all data bytes and no code bytes, granting those pages read and write permission with no execute permission.\n- Use the minimal coverage that satisfies the above (that is, no extra pages beyond what is required to cover the original bytes), and preserve the half-open interval convention $\\left[\\text{start}, \\text{end}\\right)$.\n\nCompute the two new half-open virtual address ranges for the code and the data after page-granularity alignment and separation. Express your final answer as four hexadecimal virtual addresses in ascending order $\\left(C_{\\text{start}}, C_{\\text{end}}, D_{\\text{start}}, D_{\\text{end}}\\right)$, where $\\left[C_{\\text{start}}, C_{\\text{end}}\\right)$ is the executable code range and $\\left[D_{\\text{start}}, D_{\\text{end}}\\right)$ is the writable non-executable data range. No rounding is needed beyond page alignment. Provide the addresses in hexadecimal with the $0x$ prefix. All addresses are measured in bytes.", "solution": "The core of this problem lies in page alignment and the enforcement of strict code/data separation. The page size is $P = 4096$ bytes, which is $0x1000$ in hexadecimal. Page boundaries thus occur at addresses that are multiples of $0x1000$.\n\n**1. Identify the Conflict**\nThe original code segment occupies the interval $[0x00400080, 0x00401F20)$, and the data segment starts immediately after at $[0x00401F20, 0x00408AB5)$. The boundary address, $0x00401F20$, is not a multiple of the page size ($0x1000$). This means that the virtual memory page that contains this address, which is the page spanning $[0x00401000, 0x00402000)$, contains both code bytes (from $0x00401000$ to $0x00401F1F$) and data bytes (from $0x00401F20$ onwards).\n\nThis violates the rule that \"no page may contain both code bytes and data bytes.\" To fix this, the operating system must \"re-map\" the segments. The most logical and standard approach is to move the data segment so it starts on a fresh page boundary, creating a small gap in the virtual address space.\n\n**2. Calculate the New Code Range**\nThe OS needs to create a minimal page-aligned mapping that covers all original code bytes.\n- The original code starts at $0x00400080$. To cover this, the new mapping must start at or before this address. The closest page boundary below it is $C_{\\text{start}} = 0x00400000$.\n- The original code ends just before $0x00401F20$. To cover all code up to this point, the mapping must extend to the next page boundary. The closest page boundary at or after $0x00401F20$ is $C_{\\text{end}} = 0x00402000$.\n- The new code range is $[C_{\\text{start}}, C_{\\text{end}}) = [0x00400000, 0x00402000)$. This region will be mapped with read and execute permissions. It now contains all original code bytes (and some padding) and no data bytes.\n\n**3. Calculate the New Data Range**\nThe data segment is relocated to begin on the first available page boundary after the new code range ends.\n- The new data start address is $D_{\\text{start}} = C_{\\text{end}} = 0x00402000$.\n- We must calculate the size of the original data to determine its new end point.\n  Data size = $0x00408AB5 - 0x00401F20 = 0x6B95$ bytes.\n- The relocated data logically occupies the interval $[0x00402000, 0x00402000 + 0x6B95)$, which is $[0x00402000, 0x00408B95)$.\n- This new data region must also be covered by a minimal set of whole pages. The start $D_{\\text{start}}$ is already page-aligned. The end must be aligned up to the next page boundary.\n- The closest page boundary at or after the logical end $0x00408B95$ is $D_{\\text{end}} = 0x00409000$.\n- The new data range is $[D_{\\text{start}}, D_{\\text{end}}) = [0x00402000, 0x00409000)$. This region will be mapped with read and write permissions.\n\n**4. Final Answer**\nThe resulting four virtual addresses are:\n- Code start: $C_{\\text{start}} = 0x00400000$\n- Code end: $C_{\\text{end}} = 0x00402000$\n- Data start: $D_{\\text{start}} = 0x00402000$\n- Data end: $D_{\\text{end}} = 0x00409000$\nThese values satisfy the ascending order requirement $C_{\\text{start}} \\le C_{\\text{end}} \\le D_{\\text{start}} \\le D_{\\text{end}}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0x00400000 & 0x00402000 & 0x00402000 & 0x00409000\n\\end{pmatrix}\n}\n$$", "id": "3658208"}]}