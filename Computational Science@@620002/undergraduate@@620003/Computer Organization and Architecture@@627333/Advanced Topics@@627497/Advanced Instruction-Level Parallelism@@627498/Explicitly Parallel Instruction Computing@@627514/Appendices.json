{"hands_on_practices": [{"introduction": "The essence of Explicitly Parallel Instruction Computing (EPIC) lies in shifting the complex task of finding parallelism from the hardware to the compiler. This first practice puts you in the role of an advanced compiler, tasked with scheduling a sequence of instructions into fixed-size bundles. You must navigate the dual constraints of data dependencies and a limited set of hardware templates to discover the most efficient schedule that minimizes execution time, a core challenge in harnessing the power of EPIC architectures. [@problem_id:3640835]", "problem": "An Explicitly Parallel Instruction Computing (EPIC) processor issues fixed-width bundles of exactly $3$ instructions per cycle, using templates that constrain which functional unit types can appear together. A bundle template specifies the three slot types in order, and only the following templates are available:\n- $\\mathsf{MMI}$,\n- $\\mathsf{MII}$,\n- $\\mathsf{MIF}$,\n- $\\mathsf{FII}$,\n- $\\mathsf{MIB}$.\n\nHere $\\mathsf{M}$ denotes a memory operation (load or store), $\\mathsf{I}$ denotes an integer arithmetic or compare, $\\mathsf{F}$ denotes a floating-point operation, and $\\mathsf{B}$ denotes a branch. If a slot type in a chosen template cannot be filled by a ready instruction of that type, the slot must be occupied by a no-operation of that type, denoted $\\mathsf{NOP}$, which still consumes the slot.\n\nAll instructions within a bundle are assumed to be in the same stop group; therefore, any read-after-write dependency forces the consumer instruction to be scheduled in a strictly later bundle than its producer. Reordering across the original program order is permitted as long as data and control dependencies are preserved.\n\nConsider the following straight-line code fragment with $8$ instructions, their types, and dependencies:\n- $\\text{L}_{1}$: $\\mathsf{M}$ load $r_{1} \\leftarrow [a]$.\n- $\\text{L}_{2}$: $\\mathsf{M}$ load $r_{2} \\leftarrow [b]$.\n- $\\text{A}_{1}$: $\\mathsf{I}$ add $r_{3} \\leftarrow r_{1} + r_{5}$, depends on $\\text{L}_{1}$.\n- $\\text{A}_{2}$: $\\mathsf{I}$ add $r_{4} \\leftarrow r_{2} + r_{6}$, depends on $\\text{L}_{2}$.\n- $\\text{S}_{1}$: $\\mathsf{M}$ store $[c] \\leftarrow r_{3}$, depends on $\\text{A}_{1}$.\n- $\\text{F}_{1}$: $\\mathsf{F}$ multiply $f_{1} \\leftarrow f_{2} \\times f_{3}$, independent of all others.\n- $\\text{C}_{1}$: $\\mathsf{I}$ compare $p_{1} \\leftarrow r_{4}, r_{7}$, depends on $\\text{A}_{2}$.\n- $\\text{B}_{1}$: $\\mathsf{B}$ branch on $p_{1}$, depends on $\\text{C}_{1}$.\n\nTask:\n- Taking into account the template set $\\{\\mathsf{MMI}, \\mathsf{MII}, \\mathsf{MIF}, \\mathsf{FII}, \\mathsf{MIB}\\}$, the $3$-slot bundle width, and the no-intra-bundle dependency rule, determine the minimal number of bundles needed to schedule all $8$ instructions while preserving semantics. You may reorder instructions as needed, but each bundle must use one of the allowed templates, inserting type-appropriate $\\mathsf{NOP}$s where necessary.\n- In your reasoning, explicitly demonstrate how template limitations prevent perfectly packing intuitive triples such as two loads with a floating-point operation, and propose a valid bundle-by-bundle instruction ordering that attains the minimum.\n\nReport only the minimal number of bundles as your final answer. No rounding is required.", "solution": "The problem asks for the minimum number of bundles required to schedule a given sequence of $8$ instructions on an Explicitly Parallel Instruction Computing (EPIC) processor with specific architectural constraints.\n\nFirst, we must rigorously validate the problem statement.\nThe problem provides a complete set of givens: an EPIC processor model with $3$-slot bundles, a fixed set of five bundle templates ($\\{\\mathsf{MMI}, \\mathsf{MII}, \\mathsf{MIF}, \\mathsf{FII}, \\mathsf{MIB}\\}$), a list of $8$ instructions with their types ($\\mathsf{M}, \\mathsf{I}, \\mathsf{F}, \\mathsf{B}$), and the data dependencies between them. The scheduling rule regarding read-after-write (RAW) dependencies (no-intra-bundle dependency) is clearly stated. The problem is scientifically grounded in the principles of computer architecture and compiler optimization, presents a well-posed objective, and is free of ambiguity or contradiction. Thus, the problem is valid.\n\nTo solve the problem, we first analyze the dependencies to determine the theoretical minimum number of bundles. The dependencies can be represented as a directed acyclic graph (DAG):\n- $\\text{L}_{1} \\rightarrow \\text{A}_{1} \\rightarrow \\text{S}_{1}$\n- $\\text{L}_{2} \\rightarrow \\text{A}_{2} \\rightarrow \\text{C}_{1} \\rightarrow \\text{B}_{1}$\n- $\\text{F}_{1}$ (independent)\n\nThe instructions and their types are:\n- $\\text{L}_{1}$: $\\mathsf{M}$\n- $\\text{L}_{2}$: $\\mathsf{M}$\n- $\\text{A}_{1}$: $\\mathsf{I}$\n- $\\text{A}_{2}$: $\\mathsf{I}$\n- $\\text{S}_{1}$: $\\mathsf{M}$\n- $\\text{F}_{1}$: $\\mathsf{F}$\n- $\\text{C}_{1}$: $\\mathsf{I}$\n- $\\text{B}_{1}$: $\\mathsf{B}$\n\nThe \"no intra-bundle dependency\" rule states that if instruction $\\text{J}$ depends on instruction $\\text{I}$, $\\text{J}$ must be scheduled in a bundle strictly later than the bundle containing $\\text{I}$. The length of the longest path in the dependency graph, known as the critical path, therefore establishes a lower bound on the number of bundles required.\n\nIn this case, the longest dependency chain is $\\text{L}_{2} \\rightarrow \\text{A}_{2} \\rightarrow \\text{C}_{1} \\rightarrow \\text{B}_{1}$. This path has a length of $4$ (it contains $4$ instructions). This means that at least $4$ separate bundles are required to schedule these four instructions alone: one for $\\text{L}_{2}$, a subsequent one for $\\text{A}_{2}$, a third for $\\text{C}_{1}$, and a fourth for $\\text{B}_{1}$. Therefore, the minimum number of bundles is at least $4$. The theoretical minimum based on instruction count, $\\lceil 8/3 \\rceil = 3$, is superseded by this dependency constraint.\n\nOur task is now to determine if a schedule with exactly $4$ bundles is achievable given the available templates: $\\{\\mathsf{MMI}, \\mathsf{MII}, \\mathsf{MIF}, \\mathsf{FII}, \\mathsf{MIB}\\}$. We will attempt to construct such a schedule.\n\n**Bundle 1:**\nThe set of instructions ready to be scheduled (those with no unsatisfied dependencies) are $\\text{L}_{1}(\\mathsf{M})$, $\\text{L}_{2}(\\mathsf{M})$, and $\\text{F}_{1}(\\mathsf{F})$. An optimal heuristic is to schedule instructions from the longest dependency chains as early as possible. Here, both $\\text{L}_{1}$ and $\\text{L}_{2}$ start dependency chains.\n\nThe problem asks to demonstrate how template limitations constrain scheduling. An intuitive approach would be to schedule the three ready instructions $\\{\\text{L}_{1}, \\text{L}_{2}, \\text{F}_{1}\\}$ together. This would require a bundle template of type $\\mathsf{MMF}$ (or its permutations). However, inspecting the available templates, $\\{\\mathsf{MMI}, \\mathsf{MII}, \\mathsf{MIF}, \\mathsf{FII}, \\mathsf{MIB}\\}$, reveals that no such template exists. The template set cannot accommodate two memory operations and one floating-point operation in a single bundle. This is a key constraint.\n\nTo maximize parallel execution in subsequent cycles, we should execute both loads, $\\text{L}_{1}$ and $\\text{L}_{2}$, as early as possible. This makes their dependents, $\\text{A}_{1}$ and $\\text{A}_{2}$, ready sooner. The $\\mathsf{MMI}$ template allows scheduling two memory operations. The third slot, for an $\\mathsf{I}$-type instruction, cannot be filled as no $\\mathsf{I}$-type instruction is ready. Thus, we must use a no-operation instruction, $\\text{NOP}_{\\mathsf{I}}$.\n- **Bundle 1:** $\\{\\text{L}_{1}(\\mathsf{M}), \\text{L}_{2}(\\mathsf{M}), \\text{NOP}_{\\mathsf{I}}\\}$ using template $\\mathsf{MMI}$.\n\n**Bundle 2:**\nAfter Bundle 1, instructions $\\text{L}_{1}$ and $\\text{L}_{2}$ are completed. The new set of ready instructions is:\n- $\\text{A}_{1}(\\mathsf{I})$, which depends on $\\text{L}_{1}$.\n- $\\text{A}_{2}(\\mathsf{I})$, which depends on $\\text{L}_{2}$.\n- $\\text{F}_{1}(\\mathsf{F})$, which was ready from the start.\nWe have one $\\mathsf{F}$-type and two $\\mathsf{I}$-type ready instructions. The template $\\mathsf{FII}$ is a perfect match for this set.\n- **Bundle 2:** $\\{\\text{F}_{1}(\\mathsf{F}), \\text{A}_{1}(\\mathsf{I}), \\text{A}_{2}(\\mathsf{I})\\}$ using template $\\mathsf{FII}$. The order within the bundle does not matter as there are no dependencies among them.\n\n**Bundle 3:**\nAfter Bundle 2, instructions $\\text{A}_{1}$, $\\text{A}_{2}$, and $\\text{F}_{1}$ are completed. The new set of ready instructions is:\n- $\\text{S}_{1}(\\mathsf{M})$, which depends on $\\text{A}_{1}$.\n- $\\text{C}_{1}(\\mathsf{I})$, which depends on $\\text{A}_{2}$.\nWe have one $\\mathsf{M}$-type and one $\\mathsf{I}$-type instruction ready. The instruction $\\text{B}_{1}$ is not yet ready, as it depends on $\\text{C}_{1}$. We must choose a template that can accommodate $\\text{S}_{1}$ and $\\text{C}_{1}$. Several templates could work with a $\\text{NOP}$, for example $\\mathsf{MII}$ or $\\mathsf{MIF}$. Let's use $\\mathsf{MII}$.\n- **Bundle 3:** $\\{\\text{S}_{1}(\\mathsf{M}), \\text{C}_{1}(\\mathsf{I}), \\text{NOP}_{\\mathsf{I}}\\}$ using template $\\mathsf{MII}$.\n\n**Bundle 4:**\nAfter Bundle 3, instructions $\\text{S}_{1}$ and $\\text{C}_{1}$ are completed. Only one instruction remains:\n- $\\text{B}_{1}(\\mathsf{B})$, which depends on $\\text{C}_{1}$ (now completed).\nThe only template that supports a branch ($\\mathsf{B}$) instruction is $\\mathsf{MIB}$. The other two slots must be filled with NOPs as there are no other ready instructions.\n- **Bundle 4:** $\\{\\text{NOP}_{\\mathsf{M}}, \\text{NOP}_{\\mathsf{I}}, \\text{B}_{1}(\\mathsf{B})\\}$ using template $\\mathsf{MIB}$.\n\nAll $8$ instructions have been scheduled in $4$ bundles.\nThe final schedule is:\n1.  $\\{\\text{L}_{1}, \\text{L}_{2}, \\text{NOP}_{\\mathsf{I}}\\}$\n2.  $\\{\\text{F}_{1}, \\text{A}_{1}, \\text{A}_{2}\\}$\n3.  $\\{\\text{S}_{1}, \\text{C}_{1}, \\text{NOP}_{\\mathsf{I}}\\}$\n4.  $\\{\\text{NOP}_{\\mathsf{M}}, \\text{NOP}_{\\mathsf{I}}, \\text{B}_{1}\\}$\n\nSince we established a theoretical minimum of $4$ bundles due to the critical path length, and we have successfully constructed a valid $4$-bundle schedule, we can conclude that the minimal number of bundles is $4$.", "answer": "$$\\boxed{4}$$", "id": "3640835"}, {"introduction": "While manual scheduling reveals the mechanics of packing instructions, a key question for any architecture is its overall efficiency. This exercise moves from a specific code snippet to a higher-level performance analysis, using a probabilistic model to represent a typical instruction stream. By calculating the expected number of utilized and wasted instruction slots, you will quantify a fundamental performance challenge in EPIC designs: the inevitable waste that occurs when a program's dynamic instruction mix does not perfectly match the processor's static functional units. [@problem_id:3640780]", "problem": "Consider an Explicitly Parallel Instruction Computing (EPIC) machine that issues Very Long Instruction Word (VLIW) bundles of width $3$, with exactly one slot per functional unit class: memory $(M)$, arithmetic $(A)$, and branch $(B)$. The template enforces that, within a single bundle issued in a single cycle, at most one instruction of each class may be placed. Assume a steady-state instruction stream in which each instruction’s class is independently and identically distributed with type probabilities $(\\mu_{M}, \\mu_{A}, \\mu_{B})$, where $\\mu_{M} + \\mu_{A} + \\mu_{B} = 1$ and $\\mu_{M}, \\mu_{A}, \\mu_{B} \\in [0,1]$.\n\nA compiler performs in-order, greedy bundling as follows: when starting a new bundle, it scans the instruction stream in program order, placing each encountered instruction into the current bundle if and only if that bundle’s slot for the instruction’s class is still empty; upon encountering an instruction whose class slot in the current bundle is already occupied, the current bundle is immediately closed and issued, and a new bundle is started beginning with that instruction. A bundle is also closed immediately when all three slots have been filled.\n\nAssume there are no data or control dependences restricting placement beyond the structural template, and that all instruction classes are independent in the probabilistic sense described above. Using only fundamental probability and expectation laws, derive closed-form analytic expressions, as functions of $\\mu_{M}$, $\\mu_{A}$, and $\\mu_{B}$, for:\n- the expected number of utilized slots per issued bundle, and\n- the expected number of wasted slots per issued bundle.\n\nProvide your final result as a $1 \\times 2$ row matrix $\\bigl[\\,U \\;\\; W\\,\\bigr]$, where $U$ is the expected number of utilized slots per bundle and $W$ is the expected number of wasted slots per bundle. No numerical substitution is required, and no rounding is needed. Express your answer in simplest closed form in terms of $\\mu_{M}$, $\\mu_{A}$, and $\\mu_{B}$.", "solution": "The user wants me to solve a probability problem related to computer architecture.\n\n**1. Problem Validation**\n\nFirst, I will validate the problem statement.\n\n*   **Step 1: Extract Givens**\n    *   Machine: Explicitly Parallel Instruction Computing (EPIC) with Very Long Instruction Word (VLIW) bundles.\n    *   Bundle width: $3$ slots.\n    *   Slot classes: Memory $(M)$, Arithmetic $(A)$, Branch $(B)$. One slot per class.\n    *   Instruction stream: Steady-state, independently and identically distributed (i.i.d.) instructions.\n    *   Instruction class probabilities: $(\\mu_{M}, \\mu_{A}, \\mu_{B})$ with $\\mu_{M} + \\mu_{A} + \\mu_{B} = 1$ and $\\mu_{M}, \\mu_{A}, \\mu_{B} \\in [0,1]$.\n    *   Compiler bundling algorithm: In-order, greedy.\n    *   Placement rule: An instruction is placed in the current bundle if its class slot is empty.\n    *   Termination rule 1 (conflict): If an instruction's class slot is occupied, the current bundle is closed and issued. The new bundle starts with this conflicting instruction.\n    *   Termination rule 2 (full): If all three slots are filled, the bundle is closed and issued.\n    *   Assumptions: No data or control dependencies. Probabilistic independence of instruction classes.\n    *   Objective: Derive expressions for $U$, the expected number of utilized slots per bundle, and $W$, the expected number of wasted slots per bundle.\n\n*   **Step 2: Validate Using Extracted Givens**\n    *   **Scientifically Grounded:** The problem is a well-defined exercise in computer architecture performance analysis, using a standard simplified model of a VLIW/EPIC processor. The use of probability theory to model instruction streams is a common and valid technique.\n    *   **Well-Posed:** The problem provides a complete set of rules for the bundling process and a complete probabilistic model. The quantities to be calculated (expectations) are well-defined, leading to a unique solution.\n    *   **Objective:** The problem is stated using precise, objective terminology from computer architecture and probability theory.\n    *   **Conclusion:** The problem is free of scientific flaws, ambiguities, or contradictions. It is a valid, solvable problem.\n\n*   **Step 3: Verdict and Action**\n    *   **Verdict:** The problem is valid.\n    *   **Action:** Proceed with the solution.\n\n**2. Solution Derivation**\n\nThe problem asks for the expected number of utilized slots, $U$, and wasted slots, $W$, per VLIW bundle. Each bundle has a fixed width of $3$ slots. Therefore, the number of utilized slots plus the number of wasted slots for any given bundle is always $3$. By the linearity of expectation, this relationship also holds for their expected values: $U + W = 3$. Our primary goal is to derive $U$.\n\nLet $N$ be the random variable representing the number of utilized slots (instructions) in a completed bundle. The problem's rules imply that $N$ can take values in $\\{1, 2, 3\\}$. The expected number of utilized slots is $U = E[N]$.\n\nA powerful identity for the expectation of a non-negative integer-valued random variable is $E[N] = \\sum_{k=1}^{\\infty} P(N \\ge k)$. Since the maximum bundle size is $3$, this sum truncates:\n$$U = E[N] = P(N \\ge 1) + P(N \\ge 2) + P(N \\ge 3)$$\n\nWe will now calculate each of these probabilities based on the greedy bundling process. Let $T_i$ denote the class (type) of the $i$-th instruction in the program-ordered stream. The types are i.i.d. with probabilities $P(T_i=M) = \\mu_M$, $P(T_i=A) = \\mu_A$, and $P(T_i=B) = \\mu_B$.\n\n*   **Calculating $P(N \\ge 1)$:**\n    The bundling process starts by taking the first available instruction and placing it into an empty bundle. This is always possible. Therefore, every bundle contains at least one instruction.\n    $$P(N \\ge 1) = 1$$\n\n*   **Calculating $P(N \\ge 2)$:**\n    A bundle will contain at least two instructions if and only if the second instruction in the stream, $T_2$, does not conflict with the first, $T_1$. A conflict occurs if they are of the same class. Thus, we need $T_2 \\neq T_1$.\n    $$P(N \\ge 2) = P(T_2 \\neq T_1) = 1 - P(T_2 = T_1)$$\n    The event $T_2 = T_1$ can be partitioned based on the specific class. Using the law of total probability and the independence of $T_1$ and $T_2$:\n    $$P(T_2 = T_1) = P(T_1=M, T_2=M) + P(T_1=A, T_2=A) + P(T_1=B, T_2=B)$$\n    $$P(T_2 = T_1) = P(T_1=M)P(T_2=M) + P(T_1=A)P(T_2=A) + P(T_1=B)P(T_2=B)$$\n    $$P(T_2 = T_1) = \\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2}$$\n    Therefore, the probability of having at least two instructions is:\n    $$P(N \\ge 2) = 1 - (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2})$$\n\n*   **Calculating $P(N \\ge 3)$:**\n    A bundle will contain at least three instructions if and only if the first two instructions are of different classes ($T_2 \\neq T_1$), and the third instruction is of a class different from both of the first two ($T_3 \\notin \\{T_1, T_2\\}$). If this condition is met, the third instruction is placed, and the bundle is full (containing one instruction of each class: $M$, $A$, and $B$). Since a full bundle is immediately closed, the condition for $N \\ge 3$ is identical to the condition for $N=3$.\n    The event $N=3$ occurs if the sequence of instruction types $(T_1, T_2, T_3)$ is a permutation of $(M, A, B)$. There are $3! = 6$ such permutations. The probability of one specific permutation, e.g., $(M, A, B)$, is $\\mu_{M}\\mu_{A}\\mu_{B}$ due to independence. Summing over all $6$ permutations:\n    $$P(N \\ge 3) = P(N=3) = \\mu_{M}\\mu_{A}\\mu_{B} + \\mu_{M}\\mu_{B}\\mu_{A} + \\mu_{A}\\mu_{M}\\mu_{B} + \\mu_{A}\\mu_{B}\\mu_{M} + \\mu_{B}\\mu_{M}\\mu_{A} + \\mu_{B}\\mu_{A}\\mu_{M}$$\n    $$P(N \\ge 3) = 6\\mu_{M}\\mu_{A}\\mu_{B}$$\n\n*   **Calculating $U = E[N]$:**\n    We can now sum the probabilities to find the expected number of utilized slots.\n    $$U = P(N \\ge 1) + P(N \\ge 2) + P(N \\ge 3)$$\n    $$U = 1 + \\left(1 - (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2})\\right) + 6\\mu_{M}\\mu_{A}\\mu_{B}$$\n    Combining terms gives the final expression for $U$:\n    $$U = 2 - (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2}) + 6\\mu_{M}\\mu_{A}\\mu_{B}$$\n\n*   **Calculating $W$:**\n    The expected number of wasted slots, $W$, is the total number of slots, $3$, minus the expected number of utilized slots.\n    $$W = 3 - U$$\n    $$W = 3 - \\left(2 - (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2}) + 6\\mu_{M}\\mu_{A}\\mu_{B}\\right)$$\n    $$W = 3 - 2 + (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2}) - 6\\mu_{M}\\mu_{A}\\mu_{B}$$\n    $$W = 1 + \\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2} - 6\\mu_{M}\\mu_{A}\\mu_{B}$$\n\nThe derived expressions for $U$ and $W$ are the required closed-form analytic functions of $\\mu_{M}$, $\\mu_{A}$, and $\\mu_{B}$.", "answer": "$$\\boxed{\\begin{pmatrix} 2 - (\\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2}) + 6\\mu_{M}\\mu_{A}\\mu_{B} & 1 + \\mu_{M}^{2} + \\mu_{A}^{2} + \\mu_{B}^{2} - 6\\mu_{M}\\mu_{A}\\mu_{B} \\end{pmatrix}}$$", "id": "3640780"}, {"introduction": "EPIC architectures achieve high performance through aggressive speculative execution, often executing instructions before it's certain they are on the correct program path. This practice presents a critical thought experiment exploring the interaction between predication and speculative memory loads that might cause exceptions. By analyzing what happens with and without a deferred exception mechanism, you will uncover why such features are not just optimizations but are essential for upholding the architectural contract and ensuring program correctness in the face of speculation. [@problem_id:3640849]", "problem": "Consider the foundational semantics of predication in Explicitly Parallel Instruction Computing (EPIC): a predicated instruction is guarded by a Boolean predicate $p \\in \\{0,1\\}$, and the architectural contract requires that when $p=1$ the instruction has its usual effect on architectural state, while when $p=0$ the instruction has no architectural effect of any kind, including the prohibition of raising synchronous exceptions (such as page faults) that would otherwise occur. Also recall the fundamental rule of memory exceptions in a conventional von Neumann machine model: a load that references an invalid or unmapped address raises a synchronous exception at the point of use and prevents subsequent architectural state updates from committing.\n\nAn EPIC microarchitecture may issue predicated instructions in parallel to exploit static instruction-level parallelism, potentially before the final value of $p$ is known, provided it preserves the architectural predication contract. A common mechanism to preserve this contract is deferred exceptions: a speculative load produces a poison value that carries a deferred-exception tag (for example, a Not a Thing (NaT) bit in the Intel Itanium family), and the exception is only raised later if and when the program’s control logically demands the value under a true predicate, as verified by an explicit check instruction. Without such deferral, the machine may raise an exception immediately on an invalid access, even if the instruction is predicated false.\n\nDesign the following experiment to make the interaction between predication and data-dependent loads explicit. Assume the memory system has the following properties:\n- All virtual addresses strictly less than $4096$ are invalid and raise a page fault if dereferenced by a normal load.\n- The memory contents satisfy $\\text{mem}[8192] = 12288$ and $\\text{mem}[12288] = 7$.\n\nConsider a statically scheduled EPIC bundle that contains $2$ predicated loads and no branches:\n- Load $L_1$: if $p$ then compute $r_1 \\leftarrow \\text{mem}[r_2]$.\n- Load $L_2$: if $p$ then compute $r_3 \\leftarrow \\text{mem}[r_1]$.\nAll other instructions in the bundle are independent and side-effect free. The microarchitecture issues $L_1$ and $L_2$ in parallel in the same cycle, before $p$ is finally resolved for commit. The bundle is executed under two test conditions:\n- Test condition $\\mathsf{T\\_A}$: $p=1$ and $r_2=8192$ at issue time.\n- Test condition $\\mathsf{T\\_B}$: $p=0$ and $r_2=0$ at issue time.\n\nAnalyze the experiment under two architectural policies:\n- Policy $\\mathsf{ND}$ (No Deferral): all loads are normal, and any exception is raised immediately when the memory system detects an invalid access.\n- Policy $\\mathsf{DE}$ (Deferred Exceptions): loads $L_1$ and $L_2$ are speculative, each producing a poison value with a deferred-exception tag if their address would fault; the exception is only raised later by an explicit check that executes under $p=1$, and poison propagates through dependent uses.\n\nWhich of the following statements correctly characterize the outcomes of the experiment?\n\nA. Under policy $\\mathsf{ND}$ in test condition $\\mathsf{T\\_B}$, the machine can raise a synchronous exception due to $L_1$ even though $p=0$, violating the architectural predication contract.\n\nB. Under policy $\\mathsf{DE}$, test condition $\\mathsf{T\\_B}$ does not raise an exception because the poison value from $L_1$ (and any propagated poison to $L_2$) is never architecturally demanded when $p=0$, while test condition $\\mathsf{T\\_A}$ produces $r_3=7$.\n\nC. The data dependency from $L_1$ to $L_2$ makes deferred exceptions insufficient; an exception will always be raised by $L_2$ in test condition $\\mathsf{T\\_B}$ because address computation is independent of the predicate $p$.\n\nD. A correct EPIC implementation that speculatively issues predicated loads must ensure predicate evaluation precedes address translation; thus, in all cases, no exceptions can be raised for $p=0$ even without deferred exceptions.", "solution": "The problem statement is a well-defined thought experiment in computer architecture, specifically on the topic of Explicitly Parallel Instruction Computing (EPIC). All provided information is scientifically grounded, internally consistent, and sufficient for a rigorous analysis. The terms such as predication, deferred exceptions, speculative execution, and page faults are used in accordance with their standard meanings in the field. The problem is therefore valid.\n\nWe will analyze the outcomes of the experiment for each combination of architectural policy and test condition. The bundle consists of two data-dependent loads:\n- $L_1$: if $p$ then compute $r_1 \\leftarrow \\text{mem}[r_2]$.\n- $L_2$: if $p$ then compute $r_3 \\leftarrow \\text{mem}[r_1]$.\n\nThe instructions $L_1$ and $L_2$ are issued in parallel in the same cycle, before the predicate $p$ is resolved. This implies speculative execution. The data dependency from $L_1$ to $L_2$ means the execution of the memory access for $L_2$ must wait for the result of $L_1$. We assume a standard forwarding path from $L_1$'s execution stage to $L_2$'s address-calculation stage.\n\nThe memory system has the following defined properties:\n- Any address $A < 4096$ is invalid and causes a page fault.\n- $\\text{mem}[8192] = 12288$.\n- $\\text{mem}[12288] = 7$.\n\n### Analysis of Policy $\\mathsf{ND}$ (No Deferral)\n\nUnder this policy, any exception is raised immediately upon detection by the memory system.\n\n**Test Condition $\\mathsf{T\\_A}$:** $p=1$, $r_2=8192$.\n1.  $L_1$ is speculatively executed. It computes its address as the value of $r_2$, which is $8192$.\n2.  The address $8192$ is valid (i.e., $\\ge 4096$). The memory system reads $\\text{mem}[8192]$, which is $12288$.\n3.  $L_2$ is speculatively executed. It requires the result of $L_1$ to compute its address. The value $12288$ is forwarded from $L_1$.\n4.  $L_2$ computes its address as $12288$. This is a valid address. The memory system reads $\\text{mem}[12288]$, which is $7$.\n5.  The predicate $p$ is resolved to $1$. Both instructions are on the correct path.\n6.  The results are committed to the architectural state: $r_1$ is updated to $12288$ and $r_3$ is updated to $7$. No exception occurs.\n\n**Test Condition $\\mathsf{T\\_B}$:** $p=0$, $r_2=0$.\n1.  $L_1$ is speculatively executed. It computes its address as the value of $r_2$, which is $0$.\n2.  The address $0$ is invalid (i.e., $< 4096$).\n3.  Under policy $\\mathsf{ND}$, the memory system immediately raises a synchronous exception (a page fault).\n4.  This exception occurs during the speculative execution of $L_1$, before the predicate $p$ is resolved and used to squash the instruction. The machine halts or transfers control to an exception handler.\n5.  The architectural contract for predication states that for $p=0$, the instruction must have no architectural effect, which includes not raising exceptions. By faulting on an instruction that should have been nullified, the microarchitecture violates the architectural contract.\n\n### Analysis of Policy $\\mathsf{DE}$ (Deferred Exceptions)\n\nUnder this policy, an invalid memory access during speculative execution does not raise an immediate exception. Instead, it produces a \"poison\" value (e.g., a Not-a-Thing or NaT bit is set on the result register). This poison propagates through dependent instructions. The exception is only raised if an instruction attempts to use the poisoned value under a true predicate.\n\n**Test Condition $\\mathsf{T\\_A}$:** $p=1$, $r_2=8192$.\nThe execution proceeds identically to the $\\mathsf{ND}$ case.\n1.  $L_1$ accesses the valid address $8192$ and reads the value $12288$. No poison is generated.\n2.  $L_2$ accesses the valid address $12288$ and reads the value $7$. No poison is generated.\n3.  The predicate $p$ is $1$. The results are not poison, so any checks for deferred exceptions pass. The results $r_1 \\leftarrow 12288$ and $r_3 \\leftarrow 7$ are committed. The final value in $r_3$ is $7$.\n\n**Test Condition $\\mathsf{T\\_B}$:** $p=0$, $r_2=0$.\n1.  $L_1$ is speculatively executed. It computes its address as $0$.\n2.  The address $0$ is invalid. Instead of faulting, the microarchitecture generates a poison value for the destination register $r_1$.\n3.  $L_2$ is speculatively executed. It needs the result of $L_1$ for its address. The policy states that poison propagates. When $L_2$ attempts to use the poisoned value of $r_1$, its own result, destined for $r_3$, is also marked as poison. The memory access for $L_2$ may be suppressed entirely.\n4.  The predicate $p$ is resolved to $0$.\n5.  The architectural contract for $p=0$ dictates that the predicated instructions have no effect. The poisoned results for $r_1$ and $r_3$ are discarded. The architectural registers are not updated.\n6.  The deferred exception is never raised because the poison values are never \"architecturally demanded\" under a true predicate. The condition for raising the exception (an explicit check under $p=1$) is not met. Thus, no exception occurs.\n\n### Evaluation of Options\n\n**A. Under policy $\\mathsf{ND}$ in test condition $\\mathsf{T\\_B}$, the machine can raise a synchronous exception due to $L_1$ even though $p=0$, violating the architectural predication contract.**\nOur analysis of policy $\\mathsf{ND}$ for condition $\\mathsf{T\\_B}$ shows that $L_1$ attempts to access the invalid address $0$. Because exceptions are not deferred, a page fault is raised immediately. This happens speculatively, before the false predicate ($p=0$) could nullify the instruction. This is a direct violation of the EPIC architectural contract, which requires no architectural side-effects for instructions with a false predicate.\n**Verdict: Correct.**\n\n**B. Under policy $\\mathsf{DE}$, test condition $\\mathsf{T\\_B}$ does not raise an exception because the poison value from $L_1$ (and any propagated poison to $L_2$) is never architecturally demanded when $p=0$, while test condition $\\mathsf{T\\_A}$ produces $r_3=7$.**\nThis statement has two parts.\n1.  For $\\mathsf{DE}$ and $\\mathsf{T\\_B}$ ($p=0$, $r_2=0$): Our analysis shows that a poison value is generated by $L_1$ and propagated to $L_2$. Because $p=0$, the predicated instructions are nullified, their results (including the poison tags) are discarded, and the deferred exception is never triggered. So, no exception is raised. This part is correct.\n2.  For $\\mathsf{DE}$ and $\\mathsf{T\\_A}$ ($p=1$, $r_2=8192$): Our analysis shows that $L_1$ loads $\\text{mem}[8192]=12288$, and $L_2$ then loads $\\text{mem}[12288]=7$. Since $p=1$, the result $r_3=7$ is committed. This part is also correct.\nSince both parts of the statement are true, the entire statement is correct.\n**Verdict: Correct.**\n\n**C. The data dependency from $L_1$ to $L_2$ makes deferred exceptions insufficient; an exception will always be raised by $L_2$ in test condition $\\mathsf{T\\_B}$ because address computation is independent of the predicate $p$.**\nThis statement claims the deferred exception mechanism is insufficient. Our analysis of policy $\\mathsf{DE}$ in condition $\\mathsf{T\\_B}$ proves otherwise. The mechanism of poison generation and propagation, combined with the final check against the predicate, correctly handles the situation. An exception is *not* raised because $p=0$. The premise that address computation is independent of the predicate is why speculation is risky, but it is precisely the problem that deferred exceptions are designed to solve. Therefore, the conclusion that an exception will always be raised is false.\n**Verdict: Incorrect.**\n\n**D. A correct EPIC implementation that speculatively issues predicated loads must ensure predicate evaluation precedes address translation; thus, in all cases, no exceptions can be raised for $p=0$ even without deferred exceptions.**\nThis statement proposes a specific, conservative implementation strategy as a mandatory requirement for correctness (\"must ensure\"). This strategy involves resolving the predicate before the memory access, which would indeed prevent the fault in condition $\\mathsf{T\\_B}$. However, doing so would introduce a control dependency that could severely limit instruction-level parallelism, undermining a key goal of the EPIC philosophy. The problem describes deferred exceptions as a \"common mechanism\" to preserve the architectural contract *while* allowing speculative loads to issue before the predicate is known. The existence of the deferred exception mechanism as a solution proves that the strategy proposed in option D is not the *only* way to build a correct implementation. Therefore, the \"must ensure\" claim is false.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{AB}$$", "id": "3640849"}]}