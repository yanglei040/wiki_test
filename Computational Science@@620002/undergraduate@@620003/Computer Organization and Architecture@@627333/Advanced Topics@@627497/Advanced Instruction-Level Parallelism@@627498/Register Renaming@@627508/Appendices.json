{"hands_on_practices": [{"introduction": "To truly understand register renaming, we must trace its operation at the microarchitectural level. This first practice guides you through the process for a short sequence of instructions, focusing on how the Rename Map Table (RMT) and the free list of physical registers evolve. By tracking the state cycle-by-cycle, you will see precisely how name dependences like Write-After-Write (WAW) and Write-After-Read (WAR) are systematically eliminated, paving the way for out-of-order execution. [@problem_id:3672363]", "problem": "Consider an out-of-order superscalar processor that uses register renaming with a rename map table (RMT), an Architectural Map Table (AMT), and a free list of physical registers to eliminate name dependences. There are $4$ architectural registers $\\{R_1, R_2, R_3, R_4\\}$ and a total of $P$ physical registers $\\{p_1, p_2, \\dots, p_P\\}$. Initially, the AMT and RMT are identical and map one-to-one as $R_1 \\mapsto p_1$, $R_2 \\mapsto p_2$, $R_3 \\mapsto p_3$, $R_4 \\mapsto p_4$. The free list initially contains $\\langle p_5, p_6, \\dots, p_P \\rangle$ in that order.\n\nThe processor uses the following renaming and freeing rules derived from the standard definitions of register renaming for precise exceptions:\n- On renaming an instruction that writes an architectural destination register $R_d$, the renamer allocates a fresh physical register $p_{\\text{new}}$ from the head of the free list and updates the RMT entry to $R_d \\mapsto p_{\\text{new}}$. The instruction records the physical register $p_{\\text{old}}$ that was previously mapped to $R_d$ in the RMT at that moment as its prior mapping.\n- Source operands are renamed by reading the current RMT at rename time. Reads use the producer’s physical registers, removing write-after-read (WAR) hazards.\n- At in-order commit of a writing instruction to $R_d$, the AMT is updated to the instruction’s destination physical register, and the recorded prior mapping $p_{\\text{old}}$ for $R_d$ is returned to the free list. No physical register is freed before commit. Commit is strictly in program order.\n- There are no exceptions or squashes in this scenario.\n\nThe following three instructions enter the pipeline and are renamed back-to-back before any instruction commits:\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$\n- $I_2$: $R_2 \\leftarrow R_4$\n- $I_3$: $R_1 \\leftarrow R_1 + 1$\n\nTasks:\n- Trace the RMT and free list after the renaming of each instruction $I_1$, $I_2$, and $I_3$, explaining how WAR and write-after-write (WAW) hazards are eliminated in this sequence by the renaming process. Use the rules above and assume no instruction commits until all three are renamed.\n- Based on the trace and the stated rules, determine the minimum total number of physical registers $P$ required to avoid a rename stall (i.e., to ensure the free list is never empty when a destination allocation is needed) during the renaming of this three-instruction sequence.\n\nProvide your final answer as a single integer for $P$. No rounding is required.", "solution": "To solve this problem, we will trace the state of the Rename Map Table (RMT) and the free list as each instruction is renamed.\n\n**Initial State:**\n*   RMT: $\\{R_1 \\mapsto p_1, R_2 \\mapsto p_2, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n*   Free List: $\\langle p_5, p_6, p_7, \\dots, p_P \\rangle$\n\n**1. Rename $I_1: R_1 \\leftarrow R_2 + R_3$**\n*   **Sources**: The RMT is read for $R_2$ and $R_3$, yielding source operands $p_2$ and $p_3$.\n*   **Destination**: $R_1$. A new physical register, $p_5$, is allocated from the head of the free list. The old mapping for $R_1$ ($p_1$) is recorded with $I_1$ to be freed upon $I_1$'s commit.\n*   **RMT Update**: The RMT is updated to map $R_1$ to its new physical register: $R_1 \\mapsto p_5$.\n*   **Renamed Instruction**: $p_5 \\leftarrow p_2 + p_3$.\n*   **State After $I_1$ Rename**:\n    *   RMT: $\\{R_1 \\mapsto p_5, R_2 \\mapsto p_2, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_6, p_7, \\dots, p_P \\rangle$\n    *   Live Registers: $\\{p_1, p_2, p_3, p_4, p_5\\}$. Note that $p_1$ is still live, holding the previous architectural value of $R_1$ until $I_1$ commits.\n\n**2. Rename $I_2: R_2 \\leftarrow R_4$**\n*   **Source**: The RMT is read for $R_4$, yielding source operand $p_4$.\n*   **Destination**: $R_2$. A new physical register, $p_6$, is allocated from the free list. The old mapping for $R_2$ ($p_2$) is recorded with $I_2$ to be freed upon its commit.\n*   **RMT Update**: $R_2 \\mapsto p_6$.\n*   **Renamed Instruction**: $p_6 \\leftarrow p_4$.\n*   **Hazard Elimination**: This step resolves the **Write-After-Read (WAR)** hazard between $I_1$ and $I_2$. $I_1$ needs to read the old value of $R_2$ (from $p_2$), while $I_2$ writes a new value to $R_2$. By allocating a new physical register $p_6$ for $I_2$'s destination, $I_2$ can execute and write to $p_6$ without affecting the value in $p_2$ that $I_1$ needs.\n*   **State After $I_2$ Rename**:\n    *   RMT: $\\{R_1 \\mapsto p_5, R_2 \\mapsto p_6, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_7, \\dots, p_P \\rangle$\n    *   Live Registers: $\\{p_1, p_2, p_3, p_4, p_5, p_6\\}$.\n\n**3. Rename $I_3: R_1 \\leftarrow R_1 + 1$**\n*   **Source**: The RMT is read for $R_1$. The current mapping is $R_1 \\mapsto p_5$, which is the destination of $I_1$. This correctly captures the **Read-After-Write (RAW)** true dependence of $I_3$ on $I_1$. $I_3$ will read from $p_5$.\n*   **Destination**: $R_1$. A new physical register, $p_7$, is allocated. The old mapping for $R_1$ ($p_5$) is recorded with $I_3$ to be freed upon its commit.\n*   **RMT Update**: $R_1 \\mapsto p_7$.\n*   **Renamed Instruction**: $p_7 \\leftarrow p_5 + 1$.\n*   **Hazard Elimination**: This step resolves the **Write-After-Write (WAW)** hazard between $I_1$ and $I_3$, both of which write to $R_1$. By allocating distinct physical registers ($p_5$ for $I_1$ and $p_7$ for $I_3$), the two writes can complete out of order without corrupting the final state.\n*   **State After $I_3$ Rename**:\n    *   RMT: $\\{R_1 \\mapsto p_7, R_2 \\mapsto p_6, R_3 \\mapsto p_3, R_4 \\mapsto p_4\\}$\n    *   Free List: $\\langle p_8, \\dots, p_P \\rangle$\n    *   Live Registers: $\\{p_1, p_2, p_3, p_4, p_5, p_6, p_7\\}$.\n\n**Minimum Number of Physical Registers ($P$)**:\nTo rename all three instructions without stalling, the free list must supply a new physical register for each of the three writing instructions.\n- Initial state requires 4 physical registers for the architectural mapping: $p_1, p_2, p_3, p_4$.\n- $I_1$ allocates $p_5$.\n- $I_2$ allocates $p_6$.\n- $I_3$ allocates $p_7$.\nImmediately after renaming $I_3$, a total of 7 physical registers are simultaneously live:\n- $p_1, p_2, p_5$: Stale mappings waiting for their corresponding instructions to commit.\n- $p_3, p_4$: Current architectural state for $R_3, R_4$.\n- $p_6, p_7$: New speculative mappings for $R_2, R_1$.\nTo supply $p_5, p_6, p_7$ from the free list, the total number of physical registers $P$ must be at least 7. If $P=6$, the free list would have been empty when $I_3$ needed to be renamed, causing a stall. Therefore, the minimum number of physical registers required is 7.", "answer": "$$\\boxed{7}$$", "id": "3672363"}, {"introduction": "After seeing how register renaming works, the next critical question is why it is so essential in modern processors. This exercise demonstrates the profound impact of renaming on performance by analyzing a common scenario: a loop where a register is reused in every iteration. By comparing the execution throughput with and without renaming, you will quantify how breaking false dependencies unlocks significant instruction-level parallelism and dramatically improves performance. [@problem_id:3672407]", "problem": "An out-of-order superscalar processor implements register renaming using a Register Alias Table (RAT) that maps architectural registers to physical registers in a large physical register file. Data dependence types are defined as follows: read-after-write (RAW) is a true dependence, write-after-read (WAR) and write-after-write (WAW) are name dependences. A name dependence constrains issue without register renaming but is eliminated when distinct physical registers are assigned to different dynamic instances of the same architectural register.\n\nConsider the following loop, written in idealized assembly-like pseudocode, where $R1$ is an accumulator (architectural register carrying a true loop-carried dependence), $R2$ is a temporary architectural register reused each iteration, $R3$ is a load destination, and $R5$ is a constant multiplier:\n1. $R3 \\leftarrow \\text{load}(A[i])$\n2. $R1 \\leftarrow R1 + R3$\n3. $R2 \\leftarrow R3 \\times R5$\n4. $R8 \\leftarrow R2 + R9$\n\nAssume:\n- The processor can issue up to $w = 4$ instructions per cycle, with at most $1$ memory operation per cycle, at most $1$ multiply per cycle, and at most $2$ integer arithmetic logic unit (ALU) operations per cycle.\n- Latencies to produce results are: load-to-use $= 3$ cycles, integer add $= 1$ cycle, multiply $= 3$ cycles. The multiplier is fully pipelined (it can accept $1$ new multiply per cycle and produces a result $3$ cycles later). Integer ALU operations are single-cycle and fully bypassed.\n- Perfect branch prediction and perfect caches; no structural or memory aliasing hazards beyond the unit limits above.\n- The physical register file has at least $32$ integer physical registers, sufficient to hold independent physical versions of $R2$ for multiple in-flight iterations.\n- Architectural $R1$ carries a true loop-carried RAW dependence: $R1$ produced in one iteration is consumed by the next iteration’s instruction $2$. Architectural $R2$ is only a temporary within each iteration and is not read by subsequent iterations except as constrained by name dependences without renaming.\n\nTwo execution modes are considered:\n- Mode N (no renaming of $R2$): the machine enforces WAR and WAW constraints on architectural $R2$, so an iteration’s write to $R2$ cannot be issued before any earlier scheduled read of $R2$ from a previous iteration, and multiple writes to $R2$ must complete in program order.\n- Mode R (register renaming): each iteration’s architectural $R2$ is mapped to an independent physical register $P2_i$, eliminating WAR and WAW on $R2$ across iterations. The true dependence on $R1$ remains.\n\nUnder steady-state conditions, determine the initiation interval (II), defined as the average number of cycles per completed loop iteration in steady state, for Mode N and Mode R, and the corresponding speedup (Mode R relative to Mode N). Choose the correct statement.\n\nA. With register renaming, steady-state initiation interval is $1$ cycle per iteration; without renaming it is $4$ cycles per iteration; speedup is $4\\times$.\n\nB. With register renaming, steady-state initiation interval is $2$ cycles per iteration; without renaming it is $4$ cycles per iteration; speedup is $2\\times$.\n\nC. Register renaming yields no throughput benefit: both modes have steady-state initiation interval $= 1$ cycle per iteration due to the true dependence on $R1$.\n\nD. With register renaming, steady-state initiation interval is $3$ cycles per iteration; without renaming it is $3$ cycles per iteration; speedup is $1\\times$.", "solution": "To determine the initiation interval (II), we must find the maximum of the resource-constrained II ($ResII$) and the recurrence-constrained II ($RecII$).\n\n**1. Resource-Constrained II ($ResII$)**\nThe loop body contains 4 instructions: 1 load, 1 multiply, and 2 ALU adds. The processor resources are: 1 memory unit, 1 multiply unit, and 2 ALU units, with an issue width of 4.\n- Memory constraint: $\\lceil 1 \\text{ load} / 1 \\text{ unit} \\rceil = 1$ cycle.\n- Multiply constraint: $\\lceil 1 \\text{ mul} / 1 \\text{ unit} \\rceil = 1$ cycle.\n- ALU constraint: $\\lceil 2 \\text{ adds} / 2 \\text{ units} \\rceil = 1$ cycle.\n- Issue width constraint: $\\lceil 4 \\text{ instructions} / 4 \\text{ slots} \\rceil = 1$ cycle.\nThe most restrictive resource constraint is $ResII = \\max(1, 1, 1, 1) = 1$ cycle. This means the hardware can, in principle, start a new iteration every cycle.\n\n**2. Mode R (with Register Renaming)**\nWith register renaming, all name dependences (WAR, WAW) are eliminated. We only need to consider true (RAW) loop-carried dependences.\n- The problem states a true RAW dependence on $R1$: The add instruction $I2_i: R1 \\leftarrow R1 + R3$ in iteration $i$ depends on the result of $I2_{i-1}$ from the previous iteration.\n- This creates a recurrence cycle $I2_{i-1} \\rightarrow I2_i$.\n- The length of this recurrence path is the latency of the instruction itself, which is the 1-cycle latency of the add operation.\n- Therefore, $RecII_R = 1$ cycle.\nThe overall initiation interval for Mode R is $II_R = \\max(ResII, RecII_R) = \\max(1, 1) = 1$ cycle per iteration.\n\n**3. Mode N (No Renaming of $R2$)**\nWithout renaming $R2$, the processor must enforce name dependences on this register across iterations. This creates new loop-carried recurrences in addition to the RAW on $R1$.\n- **Write-After-Read (WAR) on $R2$**: Instruction $I4$ from iteration $i-1$ ($I4_{i-1}$) reads $R2$, and instruction $I3$ from iteration $i$ ($I3_i$) writes to $R2$. To prevent a hazard, $I3_i$ cannot execute before $I4_{i-1}$ reads its operand. In an out-of-order machine, this means $I3_i$ cannot issue before $I4_{i-1}$ issues.\n- This creates a loop-carried dependence chain: $I3_{i-1} \\xrightarrow{\\text{RAW on R2}} I4_{i-1} \\xrightarrow{\\text{WAR on R2}} I3_i$.\n- Let's trace the total latency of this chain:\n    1. $I3_{i-1}$ (multiply) takes 3 cycles to produce a result for $R2$.\n    2. $I4_{i-1}$ (add) can issue after $I3_{i-1}$'s result is ready. If $I3_{i-1}$ issues at cycle $T$, its result is ready at $T+3$. $I4_{i-1}$ can issue at $T+3$.\n    3. $I3_i$ must issue after $I4_{i-1}$ issues. So, $T_{issue}(I3_i) \\ge T_{issue}(I4_{i-1}) + 1 = (T+3) + 1 = T+4$.\n- The minimum time between the issue of $I3$ in one iteration and the issue of $I3$ in the next iteration is 4 cycles. Thus, the recurrence created by the WAR hazard gives $RecII_{WAR} = 4$ cycles.\n- **Write-After-Write (WAW) on $R2$**: $I3_i$ must write to $R2$ after $I3_{i-1}$ has written to it. A conservative machine enforces this by ensuring $I3_i$ does not issue until $I3_{i-1}$ completes. This creates a recurrence on $I3$ with a latency equal to the multiply latency, so $RecII_{WAW} = 3$ cycles.\nThe most constraining recurrence is the WAR hazard. So, $RecII_N = \\max(RecII_{R1-RAW}, RecII_{WAR}, RecII_{WAW}) = \\max(1, 4, 3) = 4$ cycles.\nThe overall initiation interval for Mode N is $II_N = \\max(ResII, RecII_N) = \\max(1, 4) = 4$ cycles per iteration.\n\n**4. Speedup**\nSpeedup is the ratio of the baseline execution time (Mode N) to the enhanced execution time (Mode R).\nSpeedup = $\\frac{II_N}{II_R} = \\frac{4 \\text{ cycles/iteration}}{1 \\text{ cycle/iteration}} = 4\\times$.\n\n**Conclusion**\nThe initiation interval is 1 cycle/iteration with renaming and 4 cycles/iteration without renaming. The speedup is $4\\times$. This corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "3672407"}, {"introduction": "The final step in mastering a concept is to understand its place within the broader engineering context. While a larger physical register file (PRF) reduces performance-degrading stalls, it also consumes more chip area and dynamic energy. This practice challenges you to think like a processor designer, using a mathematical model to find the optimal PRF size that balances the cost of stalls against the energy cost of register accesses, revealing the fundamental trade-offs at the heart of computer architecture. [@problem_id:3672398]", "problem": "Consider an out-of-order (OoO) superscalar core that implements register renaming with a physical register file (PRF) of size $P$ entries. A rename stall occurs when the free list of physical registers is empty, forcing the front end to stop dispatching new instructions until a commit frees entries. In a steady state with instruction-level parallelism assumed stationary, let the mean number of live physical registers held by the window and committed-but-not-yet-freed state be $L$, where $L$ is treated as a constant with respect to $P$.\n\nAssume the following scientifically grounded first-order models:\n- Due to wordline/bitline length and decoder complexity, the dynamic energy per PRF read scales approximately linearly with PRF size. Model read energy as $E_{r}(P) = \\epsilon_{r} P$, and write energy as $E_{w}(P) = \\epsilon_{w} P$, with $\\epsilon_{r} > 0$ and $\\epsilon_{w} > 0$.\n- Each instruction, on average, performs $r$ PRF reads and $w$ PRF writes, with $r \\ge 0$ and $w \\ge 0$ treated as constants.\n- The expected rename stall penalty per instruction is modeled as inversely proportional to the free-list slack $P - L$. Specifically, the expected penalty contributes a cost term $\\frac{C_{s}}{P - L}$, with $C_{s} > 0$ aggregating the energy-equivalent cost of performance loss due to stalls.\n\nUnder these assumptions, define the per-instruction objective function $J(P)$ that combines energy of PRF accesses and rename stall penalty. Derive, from first principles and calculus, the PRF size $P^{*}$ that minimizes $J(P)$ subject to $P > L$. Express $P^{*}$ as a single closed-form analytic expression in terms of $L$, $C_{s}$, $\\epsilon_{r}$, $\\epsilon_{w}$, $r$, and $w$. No rounding is required; provide the exact symbolic expression. The final answer must be the expression for $P^{*}$ only.", "solution": "The physical register file (PRF) is the pool from which register renaming allocates destinations for decoded instructions, decoupling architectural registers from physical storage. A rename stall occurs when the free list of physical registers is exhausted, which is more likely when the slack $P - L$ (the number of free entries on average) is small.\n\nWe start by constructing a scientifically grounded objective function from core definitions and well-tested scaling laws:\n1. Dynamic energy per access in a memory-like structure scales with line lengths and decoder effort. The dominant dynamic energy term is $E = \\frac{1}{2} C V^{2}$, where capacitance $C$ grows with wire length and fanout. For a PRF whose wordlines and bitlines lengthen with the number of rows or columns, a first-order model for per-access energy is linear in $P$. Therefore, we model per-read energy as $E_{r}(P) = \\epsilon_{r} P$ and per-write energy as $E_{w}(P) = \\epsilon_{w} P$, with $\\epsilon_{r} > 0$ and $\\epsilon_{w} > 0$. If each instruction on average performs $r$ reads and $w$ writes, the expected PRF-access energy per instruction is\n$$\nE_{\\text{PRF}}(P) = r E_{r}(P) + w E_{w}(P) = r \\epsilon_{r} P + w \\epsilon_{w} P = (\\epsilon_{r} r + \\epsilon_{w} w) P.\n$$\n\n2. Rename stalls arise when the free list contains zero entries. Let $L$ represent the average number of live physical registers held by in-flight instructions and not yet returned to the free list, a property determined by the instruction window, retirement latency, and live-range statistics. For $P > L$, the free-list slack is $P - L$. In a first-order occupancy approximation (large-slack regime), the chance of encountering a free-list exhaustion event per instruction decreases approximately in inverse proportion to slack, capturing the intuitive effect that each additional free entry reduces the risk of transient saturation. We hence model the expected rename stall penalty per instruction as\n$$\nE_{\\text{stall}}(P) = \\frac{C_{s}}{P - L},\n$$\nwith $C_{s} > 0$ aggregating the energy-equivalent impact of lost performance due to stalls.\n\nCombining these terms, the per-instruction objective function is\n$$\nJ(P) = E_{\\text{PRF}}(P) + E_{\\text{stall}}(P) = (\\epsilon_{r} r + \\epsilon_{w} w) P + \\frac{C_{s}}{P - L},\n$$\ndefined for $P > L$.\n\nWe seek $P^{*}$ that minimizes $J(P)$. We use calculus to find stationary points by differentiating $J(P)$ with respect to $P$:\n$$\n\\frac{d J}{d P} = \\frac{d}{dP} \\left[ (\\epsilon_{r} r + \\epsilon_{w} w) P + C_{s}(P-L)^{-1} \\right] = (\\epsilon_{r} r + \\epsilon_{w} w) - C_s (P-L)^{-2} = (\\epsilon_{r} r + \\epsilon_{w} w) - \\frac{C_{s}}{(P - L)^{2}}.\n$$\nSet the derivative to zero for an extremum:\n$$\n(\\epsilon_{r} r + \\epsilon_{w} w) - \\frac{C_{s}}{(P - L)^{2}} = 0\n\\quad \\Longrightarrow \\quad\n(\\epsilon_{r} r + \\epsilon_{w} w) = \\frac{C_{s}}{(P - L)^{2}}.\n$$\nSolve for $P - L$:\n$$\n(P - L)^{2} = \\frac{C_{s}}{\\epsilon_{r} r + \\epsilon_{w} w}\n\\quad \\Longrightarrow \\quad\nP - L = \\sqrt{\\frac{C_{s}}{\\epsilon_{r} r + \\epsilon_{w} w}},\n$$\nwhere we take the positive root because $P - L > 0$ by the domain constraint. Hence,\n$$\nP^{*} = L + \\sqrt{\\frac{C_{s}}{\\epsilon_{r} r + \\epsilon_{w} w}}.\n$$\n\nTo confirm that this stationary point is a minimum, we compute the second derivative:\n$$\n\\frac{d^{2} J}{d P^{2}} = - C_{s} \\frac{d}{dP}\\left((P - L)^{-2}\\right) = - C_{s} \\left(-2\\right) (P - L)^{-3} = \\frac{2 C_{s}}{(P - L)^{3}}.\n$$\nFor $P > L$ and $C_{s} > 0$, we have $\\frac{d^{2} J}{d P^{2}} > 0$, verifying convexity and that the stationary point is the unique global minimizer in the feasible domain.\n\nTherefore, the PRF size that balances the linear growth of PRF access energy against the inverse-slack rename stall penalty is\n$$\nP^{*} = L + \\sqrt{\\frac{C_{s}}{\\epsilon_{r} r + \\epsilon_{w} w}}.\n$$", "answer": "$$\\boxed{L + \\sqrt{\\frac{C_{s}}{\\epsilon_{r} r + \\epsilon_{w} w}}}$$", "id": "3672398"}]}