{"hands_on_practices": [{"introduction": "A key goal in GPU programming is to maximize *occupancy*—the number of active warps on a Streaming Multiprocessor (SM), which is crucial for hiding the long latency of memory operations. Achieving high occupancy requires a careful balancing act between the resources a thread block consumes (registers, shared memory) and the SM's finite capacity. This exercise [@problem_id:3644790] guides you through a fundamental performance tuning task: selecting the optimal thread block size, $T$, by modeling how resource usage impacts the number of blocks that can run concurrently.", "problem": "A Streaming Multiprocessor (SM) in a Graphics Processing Unit (GPU) executes Single Instruction Multiple Threads (SIMT) work in groups of threads called warps. The occupancy of an SM is defined as the ratio of active warps to the maximum warps the SM can support. Consider a GPU with the following characteristics: warp size $W=32$, maximum warps per SM $W_{\\max}=64$, maximum threads per SM $T_{\\mathrm{SM}}^{\\max}=2048$, maximum blocks per SM $B_{\\mathrm{SM}}^{\\max}=32$, register file size per SM $R_{\\mathrm{SM}}=65536$ (32-bit registers), shared memory per SM $S_{\\mathrm{SM}}=65536$ bytes, and maximum threads per block $T_{\\mathrm{blk}}^{\\max}=1024$.\n\nA kernel is launched with a thread block size $T$ (threads per block), where $T$ must be a positive integer multiple of $W$. For this kernel, the per-thread register usage is modeled as $r(T)=r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right)$ with $r_{0}=28$ and $\\alpha=4$, and the per-block shared memory usage is modeled as $S(T)=s_{0}+\\beta T$ with $s_{0}=2048\\,\\text{bytes}$ and $\\beta=16\\,\\text{bytes/thread}$. Instruction-Level Parallelism (ILP) is considered harmed if $r(T)<r_{\\min}$, where $r_{\\min}=32$.\n\nStarting from fundamental definitions of occupancy, warps, and resource constraints, derive the occupancy as a function of $T$ that respects the SM limits on registers, shared memory, threads, and blocks. Then, determine the integer block size $T^{*}$ (in threads per block), constrained to be a multiple of $W$, that maximizes occupancy without violating the ILP constraint $r(T)\\geq r_{\\min}$ and the hardware limits stated above. Express the final answer as the value of $T^{*}$ in threads per block. No rounding is required; $T^{*}$ must be an exact integer.", "solution": "The problem as stated is scientifically grounded in the principles of GPU architecture and is a well-posed optimization problem with a complete and consistent set of givens. All parameters are physically realistic for a modern streaming multiprocessor. Therefore, we may proceed with a formal solution.\n\nOur objective is to find the integer thread block size $T^{*}$ that maximizes the occupancy of the Streaming Multiprocessor (SM). Occupancy, $\\mathcal{O}$, is defined as the ratio of active warps, $W_{\\text{active}}$, to the maximum number of warps an SM can support, $W_{\\max}$.\n$$\n\\mathcal{O} = \\frac{W_{\\text{active}}}{W_{\\max}}\n$$\nMaximizing occupancy is equivalent to maximizing the number of active warps, $W_{\\text{active}}$, subject to the hardware and kernel constraints. The number of active warps is the product of the number of concurrently resident thread blocks on the SM, $B_{\\text{active}}$, and the number of warps per block, $W_{\\text{blk}}$.\n\nThe number of threads per block, $T$, is constrained to be a positive integer multiple of the warp size $W=32$. Therefore, the number of warps per block is an integer, given by:\n$$\nW_{\\text{blk}} = \\frac{T}{W} = \\frac{T}{32}\n$$\nThe total number of active warps is then:\n$$\nW_{\\text{active}}(T) = B_{\\text{active}}(T) \\times W_{\\text{blk}} = B_{\\text{active}}(T) \\times \\frac{T}{32}\n$$\nThe number of active blocks, $B_{\\text{active}}(T)$, is limited by the SM's finite resources. For a given block size $T$, the number of blocks that can be simultaneously active is the minimum of the limits imposed by the maximum number of blocks, threads, registers, and shared memory.\n\nLet us determine the limit on $B_{\\text{active}}$ from each resource:\n1.  **Maximum Blocks per SM:** The hardware supports a maximum of $B_{\\mathrm{SM}}^{\\max}$ blocks.\n    $$B_{\\text{active}} \\le B_{\\mathrm{SM}}^{\\max} = 32$$\n\n2.  **Maximum Threads per SM:** The total number of threads across all active blocks cannot exceed $T_{\\mathrm{SM}}^{\\max}$.\n    $$B_{\\text{active}} \\times T \\le T_{\\mathrm{SM}}^{\\max} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\right\\rfloor = \\left\\lfloor \\frac{2048}{T} \\right\\rfloor$$\n    Note that this constraint is equivalent to the maximum warp constraint, since $W_{\\text{active}} = B_{\\text{active}} \\frac{T}{W} \\le \\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor \\frac{T}{W} \\le \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\frac{T}{W} = \\frac{T_{\\mathrm{SM}}^{\\max}}{W} = \\frac{2048}{32} = 64 = W_{\\max}$.\n\n3.  **Register File Size per SM:** The total registers used by all active blocks cannot exceed $R_{\\mathrm{SM}}$. The number of registers per block is the product of threads per block, $T$, and registers per thread, $r(T)$.\n    $$r(T) = r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right) = 28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)$$\n    $$B_{\\text{active}} \\times T \\times r(T) \\le R_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{T \\left(28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)\\right)} \\right\\rfloor$$\n\n4.  **Shared Memory per SM:** The total shared memory used by all active blocks cannot exceed $S_{\\mathrm{SM}}$. The shared memory per block is given by $S(T)$.\n    $$S(T) = s_{0}+\\beta T = 2048 + 16T$$\n    $$B_{\\text{active}} \\times S(T) \\le S_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{S_{\\mathrm{SM}}}{S(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor$$\n\nCombining these, the number of active blocks for a given $T$ is:\n$$\nB_{\\text{active}}(T) = \\min\\left(32, \\left\\lfloor \\frac{2048}{T} \\right\\rfloor, \\left\\lfloor \\frac{65536}{T \\cdot r(T)} \\right\\rfloor, \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor\\right)\n$$\nWe must now determine the valid range for the block size $T$. The problem specifies three constraints on $T$:\n1.  $T$ must be a positive integer multiple of $W=32$.\n2.  $T \\le T_{\\mathrm{blk}}^{\\max} = 1024$.\n3.  The Instruction-Level Parallelism (ILP) constraint must be satisfied: $r(T) \\ge r_{\\min} = 32$.\n    $$28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 32 \\implies 4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 4 \\implies \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 1 \\implies \\frac{T}{32} \\ge 2 \\implies T \\ge 64$$\nThe set of feasible block sizes $T$ is therefore $\\{64, 96, 128, 160, \\dots, 1024\\}$. We will evaluate $W_{\\text{active}}(T)$ for this discrete set of values to find the maximum.\n\nLet's compute $B_{\\text{active}}(T)$ and $W_{\\text{active}}(T)$ for several feasible values of $T$.\n\nFor $T=64$:\n$r(64) = 28+4\\log_2(2) = 32$. $S(64) = 2048+16(64) = 3072$.\n$B_{\\text{active}}(64) = \\min\\left(32, \\lfloor\\frac{2048}{64}\\rfloor, \\lfloor\\frac{65536}{64 \\cdot 32}\\rfloor, \\lfloor\\frac{65536}{3072}\\rfloor\\right) = \\min(32, 32, 32, 21) = 21$.\n$W_{\\text{active}}(64) = 21 \\times \\frac{64}{32} = 21 \\times 2 = 42$.\n\nFor $T=96$:\n$r(96) = 28+4\\log_2(3) \\approx 34.34$. $S(96) = 2048+16(96) = 3608$.\n$B_{\\text{active}}(96) = \\min\\left(32, \\lfloor\\frac{2048}{96}\\rfloor, \\lfloor\\frac{65536}{96 \\cdot (28+4\\log_2(3))}\\rfloor, \\lfloor\\frac{65536}{3608}\\rfloor\\right) = \\min(32, 21, 19, 18) = 18$.\n$W_{\\text{active}}(96) = 18 \\times \\frac{96}{32} = 18 \\times 3 = 54$.\n\nFor $T=128$:\n$r(128) = 28+4\\log_2(4) = 36$. $S(128) = 2048+16(128) = 4096$.\n$B_{\\text{active}}(128) = \\min\\left(32, \\lfloor\\frac{2048}{128}\\rfloor, \\lfloor\\frac{65536}{128 \\cdot 36}\\rfloor, \\lfloor\\frac{65536}{4096}\\rfloor\\right) = \\min(32, 16, 14, 16) = 14$.\n$W_{\\text{active}}(128) = 14 \\times \\frac{128}{32} = 14 \\times 4 = 56$.\n\nFor $T=160$:\n$r(160) = 28+4\\log_2(5) \\approx 37.29$. $S(160) = 2048+16(160) = 4608$.\n$B_{\\text{active}}(160) = \\min\\left(32, \\lfloor\\frac{2048}{160}\\rfloor, \\lfloor\\frac{65536}{160 \\cdot (28+4\\log_2(5))}\\rfloor, \\lfloor\\frac{65536}{4608}\\rfloor\\right) = \\min(32, 12, 10, 14) = 10$.\n$W_{\\text{active}}(160) = 10 \\times \\frac{160}{32} = 10 \\times 5 = 50$.\n\nFor $T=192$:\n$r(192) = 28+4\\log_2(6) \\approx 38.34$. $S(192) = 2048+16(192) = 5120$.\n$B_{\\text{active}}(192) = \\min\\left(32, \\lfloor\\frac{2048}{192}\\rfloor, \\lfloor\\frac{65536}{192 \\cdot (28+4\\log_2(6))}\\rfloor, \\lfloor\\frac{65536}{5120}\\rfloor\\right) = \\min(32, 10, 8, 12) = 8$.\n$W_{\\text{active}}(192) = 8 \\times \\frac{192}{32} = 8 \\times 6 = 48$.\n\nThe calculated values for active warps are $42, 54, 56, 50, 48, \\dots$. The function $W_{\\text{active}}(T)$ is not monotonic due to the floor functions and the interplay of different constraints. However, the trend suggests a peak around $T=128$. For $T > 128$, the register limit $\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\rfloor$ and thread limit $\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor$ become increasingly restrictive, causing both $B_{\\text{active}}(T)$ and subsequently $W_{\\text{active}}(T)$ to decrease. The calculation for $T=192$ confirms this downward trend.\n\nThe maximum number of active warps found is $56$, which occurs at a block size of $T=128$. This corresponds to an occupancy of $\\mathcal{O} = 56/64 = 0.875$.\n\nTherefore, the integer block size $T^{*}$ that maximizes occupancy under all stated constraints is $128$.", "answer": "$$\n\\boxed{128}\n$$", "id": "3644790"}, {"introduction": "Beyond general occupancy, performance often hinges on the efficient use of the memory hierarchy, especially the fast on-chip shared memory. However, its performance can be degraded by *bank conflicts*, which occur when multiple threads in a warp access the same memory bank simultaneously. This practice [@problem_id:3644845] presents a classic scenario of a matrix transpose and challenges you to derive a simple data layout modification—padding—to guarantee conflict-free access, showcasing a powerful technique to resolve hardware-level contention.", "problem": "A graphics processing unit (GPU) executes threads in groups following the Single Instruction, Multiple Threads (SIMT) model, where a warp consists of $32$ threads that access on-chip shared memory. The shared memory is organized into $B=32$ banks, each servicing one $4$-byte word per cycle without conflict. The bank index for a $4$-byte word at a given word address $a$ is given by the fundamental mapping rule $a \\bmod B$. A bank conflict occurs if two or more threads in the same warp access different addresses that map to the same bank during the same instruction. Consider a tiled matrix transpose implemented using shared memory with a tile declared as a row-major array of dimensions $T \\times (T+p)$, where $T$ is the tile size and $p$ is an integer column padding. Each element is a $4$-byte word. In the second phase of the transpose, a full warp of $32$ threads reads a column of the tile (i.e., thread $t$ reads element with row index $t$ and a fixed column index) from shared memory.\n\nStarting from the bank mapping rule and the definition of a bank conflict, derive the minimal nonnegative integer padding $p$ (as a symbolic expression in terms of $T$) that guarantees the column read by a full warp is bank-conflict-free for all columns of the tile. Assume the shared-memory base address of the tile is aligned to a bank boundary so that the first element of the tile has bank index $0$. Express your final answer as a single analytic expression in terms of $T$. No rounding is required.", "solution": "The problem asks for the minimal nonnegative integer padding, $p$, to ensure that a column-wise read from a shared memory tile by a full warp of threads is free of bank conflicts.\n\nThe shared memory tile is declared as a row-major array of dimensions $T \\times (T+p)$. The elements are $4$-byte words. The number of memory banks is $B=32$. The word address $a(i, j)$ of the element at $(i, j)$ is:\n$$a(i, j) = A_{base} + i \\cdot (T+p) + j$$\nwhere $A_{base}$ is the base address of the tile.\n\nThe bank index $b(i, j)$ for this address is given by the rule $a \\bmod B$:\n$$b(i, j) = (A_{base} + i \\cdot (T+p) + j) \\bmod B$$\n\nThe problem states that the base address is aligned such that the first element $(0, 0)$ maps to bank $0$. This means $b(0, 0) = 0$, which implies $A_{base} \\bmod B = 0$. This simplifies the bank index calculation for any element $(i, j)$:\n$$b(i, j) = (i \\cdot (T+p) + j) \\bmod B$$\n\nThe operation under consideration is a full warp of $32$ threads reading a single column $j$ of the tile. A warp consists of $32$ threads, indexed from $t=0$ to $t=31$. Thread $t$ reads the element at row $t$. Thus, thread $t$ accesses the element at $(t, j)$.\n\nThe bank index accessed by thread $t$ is:\n$$b_t = b(t, j) = (t \\cdot (T+p) + j) \\bmod 32$$\n\nA bank conflict occurs if any two distinct threads, $t_1$ and $t_2$ (where $t_1 \\ne t_2$ and both are in $\\{0, 1, \\dots, 31\\}$), access the same bank. That is, if $b_{t_1} = b_{t_2}$. To guarantee a conflict-free read, we must ensure that $b_{t_1} \\ne b_{t_2}$ for all $t_1 \\ne t_2$. This means the set of $32$ bank indices $\\{b_0, b_1, \\dots, b_{31}\\}$ must all be distinct. Since there are only $B=32$ banks, this set must be a permutation of $\\{0, 1, \\dots, 31\\}$.\n\nThe set of bank indices $\\{ (t \\cdot (T+p) + j) \\bmod 32 \\}_{t=0}^{31}$ forms an arithmetic progression modulo $32$, with a common difference of $(T+p)$. For all elements of such a sequence to be distinct, the common difference must be relatively prime (coprime) to the modulus.\nTherefore, the condition for a conflict-free access is:\n$$\\gcd(T+p, 32) = 1$$\n\nThe prime factorization of $32$ is $2^5$. For a number to be coprime to $32$, it must not be divisible by $2$. In other words, $T+p$ must be an odd number.\n$$T+p \\equiv 1 \\pmod{2}$$\n\nWe need to find the minimal nonnegative integer $p$ that satisfies this condition. We analyze two cases based on the parity of $T$.\n\nCase 1: $T$ is an even number.\nIf $T$ is even, then $T \\equiv 0 \\pmod{2}$. The condition becomes:\n$$0 + p \\equiv 1 \\pmod{2}$$\nThis implies $p$ must be odd. The smallest nonnegative odd integer is $1$. So, for even $T$, the minimal padding is $p=1$.\n\nCase 2: $T$ is an odd number.\nIf $T$ is odd, then $T \\equiv 1 \\pmod{2}$. The condition becomes:\n$$1 + p \\equiv 1 \\pmod{2}$$\nThis implies $p$ must be even ($p \\equiv 0 \\pmod{2}$). The smallest nonnegative even integer is $0$. So, for odd $T$, the minimal padding is $p=0$.\n\nWe can combine these two cases into a single analytical expression for $p$ in terms of $T$. The relationship is $p=1$ if $T \\bmod 2 = 0$, and $p=0$ if $T \\bmod 2 = 1$. This can be expressed concisely as:\n$$p = (T+1) \\bmod 2$$\nThis expression correctly yields $1$ for even $T$ and $0$ for odd $T$. Thus, the minimal nonnegative integer padding $p$ that guarantees conflict-free column reads is given by $(T+1) \\bmod 2$.", "answer": "$$\n\\boxed{(T+1) \\bmod 2}\n$$", "id": "3644845"}, {"introduction": "Optimizations often involve trade-offs, and *kernel fusion* is a prime example. While fusing multiple simple kernels into one can dramatically reduce costly global memory traffic, it also increases the register pressure and complexity of the resulting kernel. This exercise [@problem_id:3644777] asks you to determine the limits of this technique by calculating how many operations can be fused before the increased register usage per thread lowers occupancy below a critical threshold, highlighting the delicate balance between different optimization goals.", "problem": "A Graphics Processing Unit (GPU) processor using Single Instruction Multiple Threads (SIMT) executes elementwise kernels that stream over arrays larger than cache. Consider a pipeline of $k$ elementwise operations on an array of $N$ elements, where each operation reads one $4$-byte input value and writes one $4$-byte output value per element. When these operations are executed as $k$ separate kernels, the total memory traffic per element is proportional to the number of kernels, while when they are fused into a single kernel, the array is read once and written once, reducing total memory traffic by a factor approximately equal to $k$.\n\nHowever, kernel fusion increases per-thread register usage. Assume the following for a single Streaming Multiprocessor (SM):\n- The SM has a register file of size $R_{\\mathrm{SM}} = 65536$ registers (each register is $32$-bit).\n- The hardware limit on threads per SM is $T_{\\max} = 2048$.\n- The maximum resident thread blocks per SM is $B_{\\max} = 8$.\n- Each thread block contains $t_b = 256$ threads.\n- The hardware limit on registers per thread is $r_{\\mathrm{thr\\_max}} = 255$.\n- The base unfused kernel ($k=1$) uses $r_0 = 20$ registers per thread.\n- Each additional fused elementwise operation increases per-thread register usage by $\\alpha = 8$ registers, due to live temporaries and instruction-level parallelism, so the per-thread register use when fusing $k$ operations is $r(k) = r_0 + \\alpha(k - 1)$.\n- Neglect all resource limits other than registers, thread count, and block count. Assume registers are allocated exactly per thread without granularity effects.\n\nOccupancy is defined as resident threads per SM divided by $T_{\\max}$. To maintain latency hiding, require that occupancy be at least $0.5$. Resident blocks per SM are limited by registers, threads, and block count as $\\min\\!\\left(B_{\\max}, \\left\\lfloor \\dfrac{R_{\\mathrm{SM}}}{r(k)\\, t_b} \\right\\rfloor, \\left\\lfloor \\dfrac{T_{\\max}}{t_b} \\right\\rfloor \\right)$.\n\nUnder these assumptions, determine the largest integer $k$ for which the fused kernel maintains occupancy at least $0.5$. Provide only the maximal integer value of $k$ as your final answer.", "solution": "First, let's formalize the requirement on occupancy. Occupancy, denoted as $O$, is defined as the ratio of resident threads on a Streaming Multiprocessor (SM) to the maximum possible threads per SM, $T_{\\max}$. The number of resident threads is the product of the number of resident thread blocks, $B_{\\mathrm{res}}$, and the number of threads per block, $t_b$. The constraint is $O \\ge 0.5$.\n\n$$O = \\frac{B_{\\mathrm{res}} \\times t_b}{T_{\\max}} \\ge 0.5$$\n\nWe are given $T_{\\max} = 2048$ and $t_b = 256$. Substituting these values, we can solve for the minimum required number of resident blocks, $B_{\\mathrm{res}}$:\n\n$$\\frac{B_{\\mathrm{res}} \\times 256}{2048} \\ge 0.5$$\n$$\\frac{B_{\\mathrm{res}}}{8} \\ge 0.5$$\n$$B_{\\mathrm{res}} \\ge 4$$\n\nSince the number of thread blocks must be an integer, this inequality implies that at least $4$ thread blocks must be resident on the SM.\n\nThe number of resident blocks per SM, $B_{\\mathrm{res}}$, is limited by three factors: the maximum number of blocks per SM ($B_{\\max}$), the total register file size ($R_{\\mathrm{SM}}$), and the maximum number of threads per SM ($T_{\\max}$). The formula provided is:\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(B_{\\max}, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor, \\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor \\right)$$\n\nLet's evaluate the constant terms in this expression. We are given $B_{\\max} = 8$. The limit imposed by the thread count is:\n\n$$\\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor = \\left\\lfloor \\frac{2048}{256} \\right\\rfloor = \\lfloor 8 \\rfloor = 8$$\n\nThus, the formula for $B_{\\mathrm{res}}$ simplifies to:\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right)$$\n\nNow, we combine this with our derived condition, $B_{\\mathrm{res}} \\ge 4$:\n\n$$\\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right) \\ge 4$$\n\nFor the minimum of two quantities to be at least $4$, both quantities must be at least $4$. The first condition, $8 \\ge 4$, is trivially true. The second condition gives us the primary constraint on the system:\n\n$$\\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\ge 4$$\n\nFor an expression $\\lfloor x \\rfloor$ to be greater than or equal to an integer $n$, the value of $x$ must be greater than or equal to $n$. Therefore:\n\n$$\\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\ge 4$$\n\nThis inequality sets an upper limit on the number of registers per thread, $r(k)$. We can solve for $r(k)$:\n\n$$r(k) \\le \\frac{R_{\\mathrm{SM}}}{4 \\cdot t_b}$$\n\nSubstituting the given values $R_{\\mathrm{SM}} = 65536$ and $t_b = 256$:\n\n$$r(k) \\le \\frac{65536}{4 \\times 256} = \\frac{65536}{1024} = 64$$\n\nSo, to maintain the required occupancy, the register usage per thread cannot exceed $64$. We note that this value is well below the hardware limit of $r_{\\mathrm{thr\\_max}} = 255$ registers per thread, so that limit is not the binding constraint.\n\nThe problem provides a model for register usage as a function of the number of fused operations, $k$:\n\n$$r(k) = r_0 + \\alpha(k - 1)$$\n\nWe are given the base register usage $r_0 = 20$ and the increment per fused operation $\\alpha = 8$. For $k \\ge 1$, we have:\n\n$$r(k) = 20 + 8(k - 1)$$\n\nNow we apply our derived constraint $r(k) \\le 64$:\n\n$$20 + 8(k - 1) \\le 64$$\n\nWe solve this inequality for $k$:\n\n$$8(k - 1) \\le 64 - 20$$\n$$8(k - 1) \\le 44$$\n$$k - 1 \\le \\frac{44}{8}$$\n$$k - 1 \\le 5.5$$\n$$k \\le 6.5$$\n\nThe problem asks for the largest integer value of $k$. Since $k$ must be an integer and $k \\le 6.5$, the maximum possible integer value for $k$ is $6$.\n\nTo verify, if $k = 6$, $r(6) = 20 + 8(6-1) = 20 + 40 = 60$. Then $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{60 \\times 256} \\rfloor) = \\min(8, \\lfloor \\frac{65536}{15360} \\rfloor) = \\min(8, \\lfloor 4.26\\dots \\rfloor) = \\min(8, 4) = 4$. Occupancy is $\\frac{4 \\times 256}{2048} = \\frac{1024}{2048} = 0.5$, which meets the requirement.\nIf $k = 7$, $r(7) = 20 + 8(7-1) = 20 + 48 = 68$. Then $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{68 \\times 256} \\rfloor) = \\min(8, \\lfloor \\frac{65536}{17408} \\rfloor) = \\min(8, \\lfloor 3.76\\dots \\rfloor) = \\min(8, 3) = 3$. Occupancy is $\\frac{3 \\times 256}{2048} = \\frac{768}{2048} = 0.375$, which is below the required $0.5$.\nThus, the largest integer $k$ is $6$.", "answer": "$$\\boxed{6}$$", "id": "3644777"}]}