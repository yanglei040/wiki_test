{"hands_on_practices": [{"introduction": "Mastering the simplification of Boolean expressions is a cornerstone of efficient digital logic design. This first practice focuses on the Karnaugh map (K-map), a powerful visual tool for minimizing functions into their Product-of-Sums (POS) form. By learning to group the 'zeros' on the map, you will develop the fundamental skill of transforming a complex canonical expression into an optimized, minimal circuit [@problem_id:1952650].", "problem": "A digital control system for an industrial process is governed by a three-variable Boolean function $F(A,B,C)$. The function is specified in its canonical Product of Sums (POS) form, which represents the conditions under which the system outputs a logical LOW (0). The function is given as:\n$$F(A,B,C) = (A+B+C)(A+B+\\overline{C})(\\overline{A}+\\overline{B}+C)(\\overline{A}+\\overline{B}+\\overline{C})$$\nTo optimize the logic circuit for implementation, it is necessary to simplify this function. Using a Karnaugh map, determine the minimal POS expression for the function $F(A,B,C)$. Your final answer should be a simplified expression in terms of the variables A, B, and C.", "solution": "We are given the canonical POS\n$$F(A,B,C)=(A+B+C)(A+B+\\overline{C})(\\overline{A}+\\overline{B}+C)(\\overline{A}+\\overline{B}+\\overline{C})$$\nwhich lists the maxterms (zeros) of $F$. Each sum term equals zero only for the assignment that makes each literal in it zero. Therefore the zeros occur at:\n- $(A+B+C)=0$ when $A=0$, $B=0$, $C=0$, i.e., at index $0$.\n- $(A+B+\\overline{C})=0$ when $A=0$, $B=0$, $C=1$, i.e., at index $1$.\n- $(\\overline{A}+\\overline{B}+C)=0$ when $A=1$, $B=1$, $C=0$, i.e., at index $6$.\n- $(\\overline{A}+\\overline{B}+\\overline{C})=0$ when $A=1$, $B=1$, $C=1$, i.e., at index $7$.\n\nThus the K-map has zeros at indices $0,1,6,7$ and ones at $2,3,4,5$. Grouping zeros for a minimal POS:\n- A vertical pair at $0$ and $1$ has $A=0$ and $B=0$ constant while $C$ varies. For POS grouping, a variable that is constantly $0$ contributes uncomplemented to the sum term, so this pair yields the factor $(A+B)$.\n- A vertical pair at $6$ and $7$ has $A=1$ and $B=1$ constant while $C$ varies. A variable that is constantly $1$ contributes complemented in the sum term, so this pair yields the factor $(\\overline{A}+\\overline{B})$.\n\nHence the minimal POS is\n$$F=(A+B)(\\overline{A}+\\overline{B}).$$\n\nThis result can also be confirmed directly by Boolean algebra using the identity $(X+Z)(X+\\overline{Z})=X$:\n$$\n\\begin{aligned}\nF=(A+B+C)(A+B+\\overline{C})(\\overline{A}+\\overline{B}+C)(\\overline{A}+\\overline{B}+\\overline{C})\\\\\n=\\big[(A+B+C)(A+B+\\overline{C})\\big]\\big[(\\overline{A}+\\overline{B}+C)(\\overline{A}+\\overline{B}+\\overline{C})\\big]\\\\\n=(A+B)(\\overline{A}+\\overline{B}).\n\\end{aligned}\n$$\nThis expression is independent of $C$, and it is minimal in POS form.", "answer": "$$\\boxed{(A+B)(\\overline{A}+\\overline{B})}$$", "id": "1952650"}, {"introduction": "Beyond simple gate counts, a robust digital design must account for the dynamic behavior of circuits, especially the potential for unintended signal glitches. This exercise explores the practical implications of choosing between a Sum-of-Products (SOP) and a Product-of-Sums (POS) implementation, revealing how each form has different vulnerabilities to static hazards. By analyzing a control circuit with reconvergent fanout, you will learn to select the logic structure that ensures reliability and prevents spurious behavior in asynchronous systems [@problem_id:3669871].", "problem": "A combinational control block drives an active-low request line $R_{\\mathrm{n}}$ for an asynchronous peripheral. The control is generated from three binary condition inputs $A$, $B$, and $C$. Due to reconvergent fanout inside the block, the signal $A$ is used on two logically complementary paths that later recombine. The request line is defined as $R_{\\mathrm{n}}=\\overline{f(A,B,C)}$, with $f$ specified by the truth table whose $1$-set (minterm indices in binary order $\\langle A,B,C\\rangle$) is $\\{2,3,5,7\\}$. Equivalently, the canonical disjunctive form (sum of minterms) of $f$ is the sum of the minterms at indices $2$, $3$, $5$, and $7$.\n\nTasks:\n1. Using only the axioms of Boolean algebra (including associativity, commutativity, distributivity, idempotence, absorption) and standard minimization via the Karnaugh map (K-map), derive a minimal sum-of-products (SOP) expression for $f(A,B,C)$ from its canonical disjunctive form. State the final minimal SOP expression.\n2. Using only the dual Boolean laws and K-map grouping of the $0$-set (maxterms), derive a minimal product-of-sums (POS) expression for $f(A,B,C)$ from its canonical conjunctive form. State the final minimal POS expression.\n3. Starting from the formal definitions of static hazards in two-level logic, analyze which realization path for the active-low line $R_{\\mathrm{n}}=\\overline{f}$ is less prone to negative-going spurious pulses when $R_{\\mathrm{n}}$ should remain high: implementing $f$ as minimal SOP and then inverting to obtain $R_{\\mathrm{n}}$, versus implementing $f$ as minimal POS and then inverting to obtain $R_{\\mathrm{n}}$. Base your conclusion on the well-known duality of static-$1$ versus static-$0$ hazards in two-level AND–OR versus OR–AND networks, and on the presence of reconvergent fanout on $A$.\n4. Define the indicator $I$ by $I=1$ if the path “minimal SOP for $f$ then invert to obtain $R_{\\mathrm{n}}$” is less hazard-prone for the active-low control than the path “minimal POS for $f$ then invert to obtain $R_{\\mathrm{n}}$,” and $I=0$ otherwise. Report the value of $I$.\n\nYour final reported value must be a single real number. No rounding is required; do not include units.", "solution": "The problem requires a four-part solution involving the analysis of a Boolean function $f(A,B,C)$ and its complemented form $R_{\\mathrm{n}}$.\n\n**Part 1: Minimal Sum-of-Products (SOP) Expression for $f(A,B,C)$**\n\nThe function $f(A,B,C)$ is defined by the set of minterm indices where its value is $1$, which is $\\{2, 3, 5, 7\\}$. The binary inputs are in the order $\\langle A,B,C \\rangle$. The corresponding minterms are:\n- Index $2$: binary $010 \\implies \\overline{A}B\\overline{C}$\n- Index $3$: binary $011 \\implies \\overline{A}BC$\n- Index $5$: binary $101 \\implies A\\overline{B}C$\n- Index $7$: binary $111 \\implies ABC$\n\nThe canonical disjunctive form (sum-of-products) is:\n$$ f(A,B,C) = \\overline{A}B\\overline{C} + \\overline{A}BC + A\\overline{B}C + ABC $$\nTo find the minimal SOP expression, we use a Karnaugh map (K-map) for $3$ variables. The map is populated with $1$s at the positions corresponding to the minterms in the $1$-set. The K-map for $f(A,B,C)$ is as follows, with $A$ as the row variable and $BC$ as the column variables:\n\n$$ \\begin{array}{c|cccc}  BC    \\\\ A  00  01  11  10 \\\\ \\hline 0  0  0  1_{m_3}  1_{m_2} \\\\ 1  0  1_{m_5}  1_{m_7}  0 \\\\ \\end{array} $$\n\nWe group adjacent $1$s to form prime implicants.\n1.  A group of two $1$s is formed by $m_2(\\overline{A}B\\overline{C})$ and $m_3(\\overline{A}BC)$. In the K-map, these are the cells $(A=0, BC=10)$ and $(A=0, BC=11)$. They are adjacent. The variable $A$ is $0$ ($\\overline{A}$) and $B$ is $1$ ($B$), while $C$ changes. This group gives the prime implicant $\\overline{A}B$.\n2.  A second group of two $1$s is formed by $m_5(A\\overline{B}C)$ and $m_7(ABC)$. In the K-map, these are the cells $(A=1, BC=01)$ and $(A=1, BC=11)$. They are adjacent. The variable $A$ is $1$ ($A$) and $C$ is $1$ ($C$), while $B$ changes. This group gives the prime implicant $AC$.\n\nThese two prime implicants, $\\overline{A}B$ and $AC$, cover all the $1$s in the K-map. Thus, the minimal SOP expression for $f$ is the sum of these prime implicants.\nFinal minimal SOP expression: $f(A,B,C) = \\overline{A}B + AC$.\n\n**Part 2: Minimal Product-of-Sums (POS) Expression for $f(A,B,C)$**\n\nTo find the minimal POS expression for $f$, we can find the minimal SOP expression for its complement, $\\overline{f}$, and then apply De Morgan's laws.\nThe $0$-set of $f$ is the set of minterm indices where $f$ is $0$. This is the complement of the $1$-set, so the $0$-set is $\\{0, 1, 4, 6\\}$.\nThe function $\\overline{f}$ can be written as the sum of these minterms:\n$$ \\overline{f}(A,B,C) = \\sum m(0, 1, 4, 6) $$\nThe K-map for $\\overline{f}$ is:\n$$ \\begin{array}{c|cccc}  BC    \\\\ A  00  01  11  10 \\\\ \\hline 0  1_{m_0}  1_{m_1}  0  0 \\\\ 1  1_{m_4}  0  0  1_{m_6} \\\\ \\end{array} $$\nWe group the $1$s in the K-map for $\\overline{f}$:\n1.  A group of two $1$s is formed by $m_0(\\overline{A}\\overline{B}\\overline{C})$ and $m_1(\\overline{A}\\overline{B}C)$. This corresponds to the term $\\overline{A}\\overline{B}$.\n2.  A group of two $1$s is formed by $m_4(A\\overline{B}\\overline{C})$ and $m_6(AB\\overline{C})$. This corresponds to the term $A\\overline{C}$.\nThe minimal SOP for $\\overline{f}$ is $\\overline{f}(A,B,C) = \\overline{A}\\overline{B} + A\\overline{C}$. Note that the consensus term, $\\overline{B}\\overline{C}$ (from grouping $m_0$ and $m_4$), is redundant and thus omitted for a minimal expression.\n\nNow, we obtain $f$ by complementing $\\overline{f}$ and applying De Morgan's laws:\n$$ f(A,B,C) = \\overline{\\overline{f}(A,B,C)} = \\overline{\\overline{A}\\overline{B} + A\\overline{C}} = (\\overline{\\overline{A}\\overline{B}}) \\cdot (\\overline{A\\overline{C}}) = (A+B)(\\overline{A}+C) $$\nFinal minimal POS expression: $f(A,B,C) = (A+B)(\\overline{A}+C)$.\n\n**Part 3: Hazard Analysis**\n\nWe need to determine which implementation of $R_{\\mathrm{n}} = \\overline{f}$ is less prone to negative-going spurious pulses ($1 \\to 0 \\to 1$) when $R_{\\mathrm{n}}$ should remain high. A $1 \\to 0 \\to 1$ glitch is a static-1 hazard. The condition \"when $R_{\\mathrm{n}}$ should remain high\" means we are analyzing transitions where $R_{\\mathrm{n}}$ starts and ends at logic $1$. This corresponds to transitions where $f$ starts and ends at logic $0$.\n\nLet's analyze the two implementation paths for $R_{\\mathrm{n}}$:\n- **Path 1**: Implement $f$ as minimal SOP and then invert.\n  $$ R_{\\mathrm{n}} = \\overline{f_{SOP}} = \\overline{\\overline{A}B + AC} $$\n  Applying De Morgan's laws, we get:\n  $$ R_{\\mathrm{n}} = (A+\\overline{B})(\\overline{A}+\\overline{C}) $$\n  This is a Product-of-Sums (POS) realization for $R_{\\mathrm{n}}$, typically implemented with a two-level OR-AND logic structure. According to hazard theory, OR-AND circuits are susceptible to static-0 hazards but are inherently free from static-1 hazards.\n\n- **Path 2**: Implement $f$ as minimal POS and then invert.\n  $$ R_{\\mathrm{n}} = \\overline{f_{POS}} = \\overline{(A+B)(\\overline{A}+C)} $$\n  Applying De Morgan's laws, we get:\n  $$ R_{\\mathrm{n}} = \\overline{(A+B)} + \\overline{(\\overline{A}+C)} = \\overline{A}\\overline{B} + A\\overline{C} $$\n  This is a Sum-of-Products (SOP) realization for $R_{\\mathrm{n}}$, typically implemented with a two-level AND-OR logic structure. AND-OR circuits are susceptible to static-1 hazards.\n\nA static-1 hazard can occur in a SOP implementation if two adjacent minterms (which are $1$s on the K-map) are not covered by the same prime implicant. The problem states there is reconvergent fanout on $A$, making transitions involving a change in $A$ susceptible to hazards.\n\nLet's examine the K-map for $R_{\\mathrm{n}}$. The $1$-set of $R_{\\mathrm{n}}$ is the $0$-set of $f$, which is $\\{0, 1, 4, 6\\}$.\n$$ R_{\\mathrm{n}}(A,B,C) = \\sum m(0, 1, 4, 6) $$\nThe K-map for $R_{\\mathrm{n}}$ is identical to the K-map for $\\overline{f}$ we drew in Part 2. The minimal SOP expression is $R_{\\mathrm{n}} = \\overline{A}\\overline{B} + A\\overline{C}$, which is exactly the expression from Path 2.\n\nConsider a transition where $A$ changes from $0$ to $1$ while $B=0$ and $C=0$. The input changes from $(0,0,0)$ to $(1,0,0)$.\n- At $(0,0,0)$, $R_{\\mathrm{n}} = \\overline{0}\\overline{0} + 0\\overline{0} = 1 \\cdot 1 + 0 = 1$.\n- At $(1,0,0)$, $R_{\\mathrm{n}} = \\overline{1}\\overline{0} + 1\\overline{0} = 0 + 1 \\cdot 1 = 1$.\nThe output $R_{\\mathrm{n}}$ should remain high at $1$.\nThe minterms for this transition are $m_0$ and $m_4$. On the K-map for $R_{\\mathrm{n}}$, $m_0$ is covered by the prime implicant $\\overline{A}\\overline{B}$, while $m_4$ is covered by the prime implicant $A\\overline{C}$. Since these two adjacent $1$s are not covered by a common prime implicant, a static-1 hazard exists. Due to the delay in inverting $A$ to get $\\overline{A}$, for a moment both terms $\\overline{A}\\overline{B}$ and $A\\overline{C}$ can evaluate to $0$, causing $R_{\\mathrm{n}}$ to glitch to $0$.\n\nThe implementation from Path 1, which results in a POS form for $R_{\\mathrm{n}}$, is not susceptible to this static-1 hazard. Therefore, Path 1 is the less hazard-prone realization for the specified requirement.\n\n**Part 4: Indicator Value $I$**\n\nThe indicator $I$ is defined as:\n$I=1$ if the path “minimal SOP for $f$ then invert to obtain $R_{\\mathrm{n}}$” is less hazard-prone.\n$I=0$ otherwise.\n\nOur analysis in Part 3 concluded that this path (Path 1) yields a POS circuit for $R_{\\mathrm{n}}$ that is free of static-1 hazards, whereas the alternative path (Path 2) yields a SOP circuit for $R_{\\mathrm{n}}$ that exhibits a static-1 hazard.\nTherefore, the first path is less prone to the specified hazard.\nThis means $I=1$.", "answer": "$$\\boxed{1}$$", "id": "3669871"}, {"introduction": "Theory meets practice in this final exercise, where you will use simulation to verify the dynamic behavior of logic circuits—a core task in modern hardware engineering. You will write a program to model gate-level propagation delays, allowing you to observe a static hazard glitch in a POS implementation and confirm its absence in an equivalent SOP form. This hands-on coding problem makes the abstract concept of a hazard tangible and demonstrates the power of adding a redundant consensus term to create a glitch-free design [@problem_id:3669940].", "problem": "You are given a two-level logic implementation for an asynchronous chip-select line that is active-low. Let the logic inputs be $A$, $B$, and $C$, each taking binary values in $\\{0,1\\}$. The enable-low output is $E_L$, which is defined as $E_L = \\overline{Z}$, where $Z$ is implemented in canonical Product-of-Sums (POS) form as:\n$$\nZ = (A + B)(\\overline{A} + C).\n$$\nIn addition, consider an equivalent two-level Sum-of-Products (SOP) implementation of $E_L$ obtained by Boolean algebra. Using De Morgan's law, the ideal function for $E_L$ is:\n$$\nE_L = \\overline{(A + B)(\\overline{A} + C)} = \\overline{A}\\overline{B} + A\\overline{C}.\n$$\nThis problem asks you to evaluate glitch susceptibility due to static hazards under asynchronous input transitions by simulating gate-level propagation delays. Specifically, you must:\n- Simulate the POS network for $Z$ followed by an inverter to produce $E_L = \\overline{Z}$.\n- Simulate the SOP network that directly produces $E_L = \\overline{A}\\overline{B} + A\\overline{C}$.\n- Identify cases where a static-$0$ hazard in $Z$ produces a spurious assertion (logic low) on $E_L$ during a transition that should not change the ideal output value.\n- Apply the consensus theorem to add a redundant sum term to the POS network, thereby removing the static-$0$ hazard without altering steady-state functionality. The hazard-mitigated POS is:\n$$\nZ_{\\text{fixed}} = (A + B)(\\overline{A} + C)(B + C),\n$$\nand $E_L^{\\text{fixed}} = \\overline{Z_{\\text{fixed}}}$.\n\nSimulation model and assumptions:\n- Time is discretized in integer steps, where each time step represents $1$ ns.\n- Each logic gate incurs an integer propagation delay (in ns). The output of a gate at time $t$ equals the gate’s boolean function applied to its inputs as they were at time $t - d$, where $d$ is the gate’s delay. This is a causal transport-delay model. Negative-time indexing should be interpreted as the time-$0$ value.\n- The two-level POS network consists of two distinct sum (logical OR) gates feeding one product (logical AND) gate, then an inverter:\n  - First sum: $(A + B)$ with delay $d_{\\text{or1}}$.\n  - Second sum: $(\\overline{A} + C)$ with delay $d_{\\text{or2}}$.\n  - Product: the AND of the two sums with delay $d_{\\text{and}}$.\n  - Inverter: final inversion to produce $E_L = \\overline{Z}$ with delay $d_{\\text{inv}}$.\n- The hazard-mitigated POS adds a third sum gate $(B + C)$ with delay $d_{\\text{or3}}$ feeding the same product gate.\n- The SOP $E_L = \\overline{A}\\overline{B} + A\\overline{C}$ is implemented with two product (logical AND) gates feeding one sum (logical OR) gate:\n  - First product: $\\overline{A}\\overline{B}$ with delay $d_{\\text{and1}}$.\n  - Second product: $A\\overline{C}$ with delay $d_{\\text{and2}}$.\n  - Sum: the OR of the two products with delay $d_{\\text{orsop}}$.\n- The ideal output $E_L^{\\text{ideal}}(t)$ at each time $t$ is computed directly from inputs at time $t$ with zero delay using the boolean expression $E_L^{\\text{ideal}}(t) = \\overline{A}\\overline{B} + A\\overline{C}$.\n\nHazard detection rule:\n- A static hazard is reported for an implementation if, over the full simulation horizon, the ideal output $E_L^{\\text{ideal}}(t)$ is constant, but the simulated output deviates from this constant value at any time step.\n- If $E_L^{\\text{ideal}}(t)$ changes value at any time step, then no static hazard is reported for that test case (the deviation is an intended transition).\n\nYour task is to write a complete, runnable C program that:\n1. Runs the three test cases below.\n2. Simulates the POS, SOP, and hazard-mitigated POS networks under the specified delays and input transitions.\n3. Detects whether a static hazard occurs for each network in each test case according to the rule above.\n4. Produces a single line of output containing the hazard results flattened into a comma-separated list enclosed in square brackets.\n\nTest suite (each case runs for $T$ time steps, each step is $1$ ns):\n- Test Case $1$ (balanced delays, intended no hazard; $E_L^{\\text{ideal}}$ remains constant):\n  - Initial values at $t = 0$: $A = 0$, $B = 0$, $C = 0$.\n  - Transitions: $A$ changes to $1$ at $t = 10$; $B$ and $C$ remain constant.\n  - Delays (ns): $d_{\\text{or1}} = 3$, $d_{\\text{or2}} = 3$, $d_{\\text{or3}} = 3$, $d_{\\text{and}} = 2$, $d_{\\text{inv}} = 1$, $d_{\\text{and1}} = 3$, $d_{\\text{and2}} = 3$, $d_{\\text{orsop}} = 2$.\n  - Horizon: $T = 40$.\n- Test Case $2$ (unbalanced POS delays produce a static-$0$ hazard in $Z$, which spuriously asserts $E_L$ low; SOP chosen to avoid glitch; $E_L^{\\text{ideal}}$ remains constant):\n  - Initial values at $t = 0$: $A = 0$, $B = 0$, $C = 0$.\n  - Transitions: $A$ changes to $1$ at $t = 10$; $B$ and $C$ remain constant.\n  - Delays (ns): $d_{\\text{or1}} = 1$, $d_{\\text{or2}} = 5$, $d_{\\text{or3}} = 3$, $d_{\\text{and}} = 2$, $d_{\\text{inv}} = 1$, $d_{\\text{and1}} = 5$, $d_{\\text{and2}} = 1$, $d_{\\text{orsop}} = 2$.\n  - Horizon: $T = 40$.\n- Test Case $3$ (intended logic change; deviations are not counted as hazards):\n  - Initial values at $t = 0$: $A = 0$, $B = 0$, $C = 1$.\n  - Transitions: $A$ changes to $1$ at $t = 10$; $B$ and $C$ remain constant.\n  - Delays (ns): $d_{\\text{or1}} = 1$, $d_{\\text{or2}} = 5$, $d_{\\text{or3}} = 3$, $d_{\\text{and}} = 2$, $d_{\\text{inv}} = 1$, $d_{\\text{and1}} = 5$, $d_{\\text{and2}} = 1$, $d_{\\text{orsop}} = 2$.\n  - Horizon: $T = 40$.\n\nFinal output format:\n- Your program should produce a single line of output containing nine boolean integers ($0$ or $1$) corresponding to hazard detection results in the order:\n  - For each test case $i$ in ascending order, append three values: $\\text{POS}_i$, $\\text{SOP}_i$, $\\text{POSfixed}_i$.\n- The line must be a comma-separated list enclosed in square brackets, for example:\n$$\n[\\text{POS}_1,\\text{SOP}_1,\\text{POSfixed}_1,\\text{POS}_2,\\text{SOP}_2,\\text{POSfixed}_2,\\text{POS}_3,\\text{SOP}_3,\\text{POSfixed}_3].\n$$", "solution": "The core of the problem lies in the concept of a **static hazard**. A static hazard exists in a combinational logic circuit if a single input variable change can cause a momentary, spurious change in the output, which should have remained constant. There are two types:\n1.  **Static-1 Hazard**: The output is supposed to remain at logic $1$ but momentarily dips to $0$.\n2.  **Static-0 Hazard**: The output is supposed to remain at logic $0$ but momentarily spikes to $1$.\n\nThe problem defines an active-low enable signal $E_L$. A spurious assertion of this signal means it incorrectly goes to logic $0$. If the signal was intended to be high (inactive, logic $1$), this corresponds to a static-1 hazard on the signal $E_L$.\n\nThe problem presents three implementations for $E_L$:\n1.  A standard Product-of-Sums (POS) implementation derived from $E_L = \\overline{Z}$, where $Z = (A + B)(\\overline{A} + C)$.\n2.  A standard Sum-of-Products (SOP) implementation $E_L = \\overline{A}\\overline{B} + A\\overline{C}$.\n3.  A hazard-mitigated POS implementation, $E_L^{\\text{fixed}} = \\overline{Z_{\\text{fixed}}}$, where $Z_{\\text{fixed}} = (A + B)(\\overline{A} + C)(B + C)$. The term $(B+C)$ is the consensus term of $(A+B)$ and $(\\overline{A}+C)$, which is added to a POS expression to eliminate the static-0 hazard in $Z$.\n\nThe simulation employs a causal transport-delay model. The output of a gate at time $t$ is determined by its inputs at time $t-d$, where $d$ is the gate's propagation delay.\n\nWe will analyze each test case based on these principles.\n\n**Test Case 1: Balanced Delays**\n- Initial State: $A=0, B=0, C=0$. Transition: $A$ changes to $1$ at $t=10$.\n- Ideal Output $E_L^{\\text{ideal}}(t) = \\overline{A}\\overline{B} + A\\overline{C}$:\n  - For $t10$: $E_L^{\\text{ideal}} = (\\overline{0}\\cdot\\overline{0}) + (0\\cdot\\overline{0}) = 1+0=1$.\n  - For $t\\geq10$: $E_L^{\\text{ideal}} = (\\overline{1}\\cdot\\overline{0}) + (1\\cdot\\overline{0}) = 0+1=1$.\n- The ideal output is constant at $1$. We must check for hazards.\n- **POS Network**: $Z = (A+B)(\\overline{A}+C)$. The OR gate delays are balanced ($d_{\\text{or1}}=d_{\\text{or2}}=3$ ns). The term $(A+B)$ transitions $0 \\to 1$ at $t = 10+3=13$. The term $(\\overline{A}+C)$ transitions $1 \\to 0$ at $t=10+3=13$. Since the inputs to the AND gate change simultaneously, there is no interval where both are $1$. Thus, $Z$ remains $0$, and $E_L = \\overline{Z}$ remains $1$. No hazard is expected.\n- **SOP Network**: $E_L = \\overline{A}\\overline{B} + A\\overline{C}$. The AND gate delays are balanced ($d_{\\text{and1}}=d_{\\text{and2}}=3$ ns). The term $\\overline{A}\\overline{B}$ transitions $1 \\to 0$ at $t=10+3=13$. The term $A\\overline{C}$ transitions $0 \\to 1$ at $t=10+3=13$. The inputs to the final OR gate change simultaneously, ensuring one input is always $1$. The output $E_L$ remains $1$. No hazard is expected.\n- **Fixed POS Network**: The consensus term $(B+C)$ evaluates to $0+0=0$. This term forces the AND gate output $Z_{\\text{fixed}}$ to be $0$, so $E_L^{\\text{fixed}}$ is always $1$. No hazard is possible.\n- **Expected Result for Case 1**: $[0, 0, 0]$.\n\n**Test Case 2: Unbalanced Delays**\n- Same transition as Case 1, but with unbalanced delays. Ideal output is again constant at $1$.\n- **POS Network**: Delays are $d_{\\text{or1}}=1$ and $d_{\\text{or2}}=5$.\n  - The output of OR1, $(A+B)$, transitions $0 \\to 1$ at $t=10+1=11$.\n  - The output of OR2, $(\\overline{A}+C)$, transitions $1 \\to 0$ at $t=10+5=15$.\n  - In the time interval $[11, 14]$, both inputs to the AND gate are $1$. This causes $Z$ to briefly become $1$. This is a static-0 hazard for $Z$.\n  - This pulse on $Z$ propagates through the final inverter. The output $E_L=\\overline{Z}$ will glitch from $1 \\to 0 \\to 1$. A hazard is present.\n- **SOP Network**: Delays are $d_{\\text{and1}}=5$ and $d_{\\text{and2}}=1$.\n  - The term $\\overline{A}\\overline{B}$ transitions $1 \\to 0$ at $t=10+5=15$.\n  - The term $A\\overline{C}$ transitions $0 \\to 1$ at $t=10+1=11$.\n  - The input to the final OR gate that is turning on becomes $1$ *before* the input that is turning off becomes $0$. At all times, at least one input to the OR gate is $1$. The output $E_L$ remains stable at $1$. No hazard is expected.\n- **Fixed POS Network**: As in Case 1, the consensus term $(B+C)$ is constantly $0$, clamping $Z_{\\text{fixed}}$ to $0$ and thus $E_L^{\\text{fixed}}$ to $1$. No hazard is possible.\n- **Expected Result for Case 2**: $[1, 0, 0]$.\n\n**Test Case 3: Intended Output Change**\n- Initial State: $A=0, B=0, C=1$. Transition: $A$ changes to $1$ at $t=10$.\n- Ideal Output $E_L^{\\text{ideal}}(t) = \\overline{A}\\overline{B} + A\\overline{C}$:\n  - For $t10$: $E_L^{\\text{ideal}} = (\\overline{0}\\cdot\\overline{0}) + (0\\cdot\\overline{1}) = 1+0=1$.\n  - For $t\\geq10$: $E_L^{\\text{ideal}} = (\\overline{1}\\cdot\\overline{0}) + (1\\cdot\\overline{1}) = 0+0=0$.\n- The ideal output changes from $1$ to $0$. According to the problem's hazard detection rule, if the ideal output is not constant, no static hazard is reported for that test case, regardless of any transient behavior in the simulated signals.\n- **Expected Result for Case 3**: $[0, 0, 0]$.\n\nCombining these results gives the final expected output: $[0,0,0,1,0,0,0,0,0]$. The C program will implement the specified discrete-time simulation to verify this analysis.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int A0, B0, C0; // Initial values\n    int A_trans_t, B_trans_t, C_trans_t; // Transition times, -1 if no transition\n    int T; // Simulation horizon\n    // Delays\n    int d_or1, d_or2, d_or3, d_and, d_inv; // POS delays\n    int d_and1, d_and2, d_orsop;         // SOP delays\n} TestCase;\n\n// Helper to get past signal value, handling t-d  0 by using the value at t=0\nstatic inline int get_past_value(const int *history, int current_time, int delay) {\n    int index = current_time - delay;\n    return history[index  0 ? 0 : index];\n}\n\n// Ideal output function (zero delay)\nstatic inline int calculate_ideal(int a, int b, int c) {\n    return ((!a  !b) || (a  !c));\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { // Test Case 1\n            .A0 = 0, .B0 = 0, .C0 = 0,\n            .A_trans_t = 10, .B_trans_t = -1, .C_trans_t = -1,\n            .T = 40,\n            .d_or1 = 3, .d_or2 = 3, .d_or3 = 3, .d_and = 2, .d_inv = 1,\n            .d_and1 = 3, .d_and2 = 3, .d_orsop = 2\n        },\n        { // Test Case 2\n            .A0 = 0, .B0 = 0, .C0 = 0,\n            .A_trans_t = 10, .B_trans_t = -1, .C_trans_t = -1,\n            .T = 40,\n            .d_or1 = 1, .d_or2 = 5, .d_or3 = 3, .d_and = 2, .d_inv = 1,\n            .d_and1 = 5, .d_and2 = 1, .d_orsop = 2\n        },\n        { // Test Case 3\n            .A0 = 0, .B0 = 0, .C0 = 1,\n            .A_trans_t = 10, .B_trans_t = -1, .C_trans_t = -1,\n            .T = 40,\n            .d_or1 = 1, .d_or2 = 5, .d_or3 = 3, .d_and = 2, .d_inv = 1,\n            .d_and1 = 5, .d_and2 = 1, .d_orsop = 2\n        }\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases * 3];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int T = tc.T;\n\n        // Signal histories for the simulation\n        int A[T], B[T], C[T];\n        int E_ideal[T];\n        \n        int or1_out[T], or2_out[T], Z_pos[T], E_pos[T];\n        int and1_out[T], and2_out[T], E_sop[T];\n        int or3_out[T], Z_fixed[T], E_fixed[T];\n        \n        // --- Simulation Loop ---\n        for (int t = 0; t  T; ++t) {\n            // 1. Update inputs based on transition times\n            A[t] = (tc.A_trans_t != -1  t = tc.A_trans_t) ? !tc.A0 : tc.A0;\n            B[t] = (tc.B_trans_t != -1  t = tc.B_trans_t) ? !tc.B0 : tc.B0;\n            C[t] = (tc.C_trans_t != -1  t = tc.C_trans_t) ? !tc.C0 : tc.C0;\n\n            // 2. Calculate ideal output (zero delay)\n            E_ideal[t] = calculate_ideal(A[t], B[t], C[t]);\n            \n            // 3. Simulate POS network: E_pos = !((A+B)(!A+C))\n            or1_out[t] = get_past_value(A, t, tc.d_or1) || get_past_value(B, t, tc.d_or1);\n            or2_out[t] = !get_past_value(A, t, tc.d_or2) || get_past_value(C, t, tc.d_or2);\n            Z_pos[t] = get_past_value(or1_out, t, tc.d_and)  get_past_value(or2_out, t, tc.d_and);\n            E_pos[t] = !get_past_value(Z_pos, t, tc.d_inv);\n\n            // 4. Simulate SOP network: E_sop = (!A !B) + (A !C)\n            and1_out[t] = !get_past_value(A, t, tc.d_and1)  !get_past_value(B, t, tc.d_and1);\n            and2_out[t] = get_past_value(A, t, tc.d_and2)  !get_past_value(C, t, tc.d_and2);\n            E_sop[t] = get_past_value(and1_out, t, tc.d_orsop) || get_past_value(and2_out, t, tc.d_orsop);\n\n            // 5. Simulate Fixed POS network: E_fixed = !((A+B)(!A+C)(B+C))\n            // The first two OR gates are the same as in the standard POS network.\n            or3_out[t] = get_past_value(B, t, tc.d_or3) || get_past_value(C, t, tc.d_or3);\n            Z_fixed[t] = get_past_value(or1_out, t, tc.d_and)  \n                         get_past_value(or2_out, t, tc.d_and)  \n                         get_past_value(or3_out, t, tc.d_and);\n            E_fixed[t] = !get_past_value(Z_fixed, t, tc.d_inv);\n        }\n\n        // --- Hazard Detection Logic ---\n        int ideal_is_static = 1;\n        int ideal_static_val = E_ideal[0];\n        for (int t = 1; t  T; ++t) {\n            if (E_ideal[t] != ideal_static_val) {\n                ideal_is_static = 0;\n                break;\n            }\n        }\n        \n        int hazard_pos = 0, hazard_sop = 0, hazard_fixed = 0;\n        if (ideal_is_static) {\n            for (int t = 0; t  T; ++t) {\n                if (E_pos[t] != ideal_static_val) hazard_pos = 1;\n                if (E_sop[t] != ideal_static_val) hazard_sop = 1;\n                if (E_fixed[t] != ideal_static_val) hazard_fixed = 1;\n            }\n        }\n        \n        results[i * 3 + 0] = hazard_pos;\n        results[i * 3 + 1] = hazard_sop;\n        results[i * 3 + 2] = hazard_fixed;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[\");\n    for (int i = 0; i  num_cases * 3; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases * 3 - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3669940"}]}