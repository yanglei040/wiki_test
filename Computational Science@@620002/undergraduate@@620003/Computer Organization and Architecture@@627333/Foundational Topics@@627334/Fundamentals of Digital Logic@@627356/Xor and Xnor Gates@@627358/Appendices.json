{"hands_on_practices": [{"introduction": "Understanding XOR and XNOR gates goes beyond their truth tables; it involves knowing how to manipulate them algebraically to optimize circuits. This first exercise explores this by challenging you to transform a standard multiplexer circuit into an equivalent form using XOR gates [@problem_id:3688749]. By comparing the performance of both versions, you will gain hands-on experience in how abstract Boolean identities translate into tangible differences in circuit speed.", "problem": "A $2$-to-$1$ multiplexer (MUX) with select input $s$ and data inputs $a$ and $b$ is specified by the Boolean function $z=(s \\land a)\\lor(\\overline{s}\\land b)$. Using only fundamental Boolean algebra and the defining properties of the exclusive OR (XOR) operation—commutativity, associativity, identity $x\\oplus 0=x$, and self-inverse $x\\oplus x=0$—derive an equivalent expression for $z$ that employs an XOR-centric structure in which one of the inputs is $b$ and the other is a product of $s$ with an XOR of $a$ and $b$. Then, within a standard cell model that permits only $2$-input gates $\\{\\text{AND}, \\text{OR}, \\text{XOR}\\}$ and the inverter, define the gate depth of a circuit as the maximum number of gate levels on any input-to-output path, counting an inverter as one level. Determine the gate depth for both the sum-of-products implementation and your XOR-centric implementation.\n\nAssume the following propagation delays for $2$-input gates and the inverter: $t_{\\text{AND}}=45\\,\\text{ps}$, $t_{\\text{OR}}=45\\,\\text{ps}$, $t_{\\text{XOR}}=110\\,\\text{ps}$, $t_{\\text{INV}}=20\\,\\text{ps}$. Model the worst-case propagation delay as the sum of delays along the longest logic chain on a critical input-to-output path, and assume inputs change simultaneously.\n\nLet $T_{\\text{SOP}}$ be the worst-case propagation delay of the sum-of-products implementation and $T_{\\text{XOR}}$ be that of the XOR-centric implementation you derived. Compute the scalar difference $\\Delta T = T_{\\text{XOR}} - T_{\\text{SOP}}$ and express your final answer in nanoseconds. Round your answer to three significant figures.", "solution": "We begin from the Boolean definition of the $2$-to-$1$ multiplexer (MUX) with select input $s$ and data inputs $a$ and $b$:\n$$\nz=(s\\land a)\\lor(\\overline{s}\\land b).\n$$\nWe will derive an equivalent XOR-centric form using fundamental properties of the exclusive OR (XOR). The XOR operation satisfies commutativity and associativity, the identity property $x\\oplus 0=x$, and the self-inverse property $x\\oplus x=0$. Additionally, the MUX semantics are that when $s=0$ the output equals $b$, and when $s=1$ the output equals $a$.\n\nConsider the candidate structure $b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$ and verify equivalence by conditioning on $s$:\n- If $s=0$, then\n$$\nb\\oplus\\big(0\\cdot(a\\oplus b)\\big)=b\\oplus 0=b,\n$$\nwhich matches $z=(0\\land a)\\lor(1\\land b)=b$.\n- If $s=1$, then\n$$\nb\\oplus\\big(1\\cdot(a\\oplus b)\\big)=b\\oplus(a\\oplus b).\n$$\nBy associativity and commutativity of XOR,\n$$\nb\\oplus(a\\oplus b)=(b\\oplus b)\\oplus a=0\\oplus a=a,\n$$\nwhich matches $z=(1\\land a)\\lor(0\\land b)=a$.\n\nSince the two expressions agree for both $s=0$ and $s=1$, they are equivalent for all input combinations. Therefore, the XOR-centric form is\n$$\nz=b\\oplus\\big(s\\cdot(a\\oplus b)\\big).\n$$\n\nNext, we compare gate depth for the sum-of-products (SOP) implementation and the XOR-centric implementation under the given gate set.\n\nFor the SOP implementation $z=(s\\land a)\\lor(\\overline{s}\\land b)$:\n- The path from $s$ to $z$ traverses an inverter to form $\\overline{s}$, then a $2$-input AND, then a $2$-input OR. Counting each gate as one level, this path has depth $3$.\n- The path from $a$ to $z$ goes through an AND then an OR, depth $2$; similarly from $b$ through an AND and an OR, depth $2$.\n- The gate depth of the circuit is the maximum over all input-to-output paths, hence depth $3$.\n\nFor the XOR-centric implementation $z=b\\oplus\\big(s\\cdot(a\\oplus b)\\big)$:\n- The computation of $a\\oplus b$ uses one XOR gate (depth $1$ along $a$ and $b$).\n- Multiplying by $s$ adds one AND gate after the inner XOR, so along $a$ (or $b$) a path becomes XOR then AND, which is depth $2$; along $s$ it is just the AND, depth $1$ so far.\n- The final outer XOR with $b$ adds one more level. The longest chain is along $a$ (or the inner $b$) as inner XOR $\\rightarrow$ AND $\\rightarrow$ outer XOR, for a depth of $3$. The direct $b$ input to the outer XOR only traverses that one XOR, but the overall gate depth is determined by the longest chain, which is $3$.\n\nThus, both implementations have gate depth $3$.\n\nNow we compute worst-case propagation delays using the provided per-gate delays. Let $t_{\\text{AND}}=45\\,\\text{ps}$, $t_{\\text{OR}}=45\\,\\text{ps}$, $t_{\\text{XOR}}=110\\,\\text{ps}$, and $t_{\\text{INV}}=20\\,\\text{ps}$.\n\nFor the SOP implementation, the critical path is from $s$ through the inverter, the AND, and the OR:\n$$\nT_{\\text{SOP}}=t_{\\text{INV}}+t_{\\text{AND}}+t_{\\text{OR}}=20\\,\\text{ps}+45\\,\\text{ps}+45\\,\\text{ps}=110\\,\\text{ps}.\n$$\n\nFor the XOR-centric implementation, the critical path is from $a$ (or the inner $b$) through the inner XOR, the AND with $s$, and then the outer XOR:\n$$\nT_{\\text{XOR}}=t_{\\text{XOR}}+t_{\\text{AND}}+t_{\\text{XOR}}=110\\,\\text{ps}+45\\,\\text{ps}+110\\,\\text{ps}=265\\,\\text{ps}.\n$$\n\nThe difference is\n$$\n\\Delta T=T_{\\text{XOR}}-T_{\\text{SOP}}=265\\,\\text{ps}-110\\,\\text{ps}=155\\,\\text{ps}.\n$$\nConverting picoseconds to nanoseconds, using $1\\,\\text{ns}=1000\\,\\text{ps}$,\n$$\n\\Delta T=\\frac{155}{1000}\\,\\text{ns}=0.155\\,\\text{ns}.\n$$\nRounded to three significant figures, the result remains $0.155\\,\\text{ns}$.\n\nTherefore, the requested numeric answer (in nanoseconds) is $0.155$.", "answer": "$$\\boxed{0.155}$$", "id": "3688749"}, {"introduction": "Moving from simple combinational logic to sequential systems introduces the critical dimension of time and state. Here, we analyze the classic 'XOR swap' algorithm, not as an abstract trick, but as a sequence of micro-operations on a physical processor datapath [@problem_id:3688756]. This practice will force you to consider the detailed timing of register reads and writes, revealing potential pitfalls like data hazards and the unexpected consequences of register aliasing.", "problem": "A synchronous datapath has a register file of width $n$ with two read ports and one write port, and a functional unit that computes bitwise Exclusive OR (XOR), denoted $\\oplus$. Each micro-operation takes one clock cycle: both source registers are read using their values captured at the beginning of the cycle, and the destination register is written at the end of the same cycle. Let $x$ and $y$ be logical register names that may or may not refer to the same physical register (aliasing). Consider the three-step sequence intended to swap $x$ and $y$:\n$x \\leftarrow x \\oplus y$; $y \\leftarrow x \\oplus y$; $x \\leftarrow x \\oplus y$.\nYour task is to reason from first principles—namely, the bitwise truth table of XOR and synchronous register-read/write semantics—about the correctness and hazards of this sequence in hardware.\n\nSelect all statements that are correct.\n\nA. Under the stated single-issue, one-operation-per-cycle semantics, if $x$ and $y$ are distinct physical registers, the sequence completes a correct swap in $3$ cycles without extra storage. If $x$ and $y$ alias the same physical register, both end with the all-zero value because $x \\oplus x = 0$ bitwise.\n\nB. If the three assignments are placed in one clocked block using non-blocking updates in a Hardware Description Language (HDL), then the swap works for all cases, including when $x$ and $y$ alias, because all right-hand sides use pre-clock values and are applied simultaneously.\n\nC. If control erroneously issues the first two assignments in the same clock cycle so that both right-hand sides read the pre-cycle values of $x$ and $y$ and both writes occur together, the intended flow dependence from the first update of $x$ to the second update of $y$ is violated, constituting a Read-After-Write (RAW) hazard; consequently, the swap fails even when $x$ and $y$ are distinct.\n\nD. When $x$ and $y$ alias, the first assignment effectively feeds the same signal to both inputs of an XOR gate; the gate outputs logic high for equal inputs, so the register is driven to the all-ones value rather than zero.", "solution": "Let the initial values of the registers be $x_{init}$ and $y_{init}$. We analyze each statement based on the specified synchronous read-at-start, write-at-end semantics.\n\n**A. Analysis of the standard swap sequence:**\n- **Case 1: Distinct Registers.** The sequence proceeds over three cycles.\n  - Cycle 1: $x \\leftarrow x_{init} \\oplus y_{init}$. At the start of cycle 2, the value of register $x$ is $x_{init} \\oplus y_{init}$.\n  - Cycle 2: $y \\leftarrow (x_{init} \\oplus y_{init}) \\oplus y_{init} = x_{init} \\oplus (y_{init} \\oplus y_{init}) = x_{init}$. The second instruction correctly reads the updated value of $x$. At the start of cycle 3, the value of register $y$ is $x_{init}$.\n  - Cycle 3: $x \\leftarrow (x_{init} \\oplus y_{init}) \\oplus x_{init} = (x_{init} \\oplus x_{init}) \\oplus y_{init} = y_{init}$. The third instruction reads the updated value of $y$. The final value of $x$ is $y_{init}$.\n  The final state is $x=y_{init}$ and $y=x_{init}$, a correct swap.\n- **Case 2: Aliased Registers ($x$ and $y$ are the same).**\n  - Cycle 1: $x \\leftarrow x_{init} \\oplus x_{init} = 0$. The register is zeroed out. Subsequent steps will also result in 0.\n- **Conclusion:** Statement A is a correct summary of these two outcomes.\n\n**B. Analysis of non-blocking HDL assignments:**\n- In an HDL, non-blocking assignments (`<=`) in a single clocked block evaluate all right-hand sides using pre-clock values before any updates occur. If the three assignments were executed this way, the second and third steps would use the original values of $x$ and $y$, not the updated ones from prior steps. This breaks the algorithm's required data dependency. The statement's claim that the swap \"works\" is false.\n\n**C. Analysis of simultaneous issue hazard:**\n- If the first two instructions ($x \\leftarrow x \\oplus y$ and $y \\leftarrow x \\oplus y$) are issued in the same cycle, both will read the pre-cycle values $x_{init}$ and $y_{init}$.\n  - The new value for $x$ becomes $x_{init} \\oplus y_{init}$.\n  - The new value for $y$ also becomes $x_{init} \\oplus y_{init}$ because it reads the old $x_{init}$, not the new value being computed for $x$.\n- This is a classic Read-After-Write (RAW) data hazard. The swap fails because the dependency is violated. The statement is correct.\n\n**D. Analysis of XOR vs. XNOR behavior:**\n- The XOR truth table dictates that for equal inputs, the output is 0 (e.g., $1 \\oplus 1 = 0$). An XNOR gate outputs 1 for equal inputs. The statement incorrectly claims the XOR gate outputs a logic high for equal inputs. Therefore, the operation $x \\oplus x$ results in a bitwise all-zero value, not all-ones. The statement is incorrect.\n\nBased on this analysis, statements A and C are correct.", "answer": "$$\\boxed{AC}$$", "id": "3688756"}, {"introduction": "The power of a logic gate is truly revealed when designing large-scale computational structures. This final practice focuses on a common 64-bit operation, parity calculation, to illustrate a fundamental trade-off in computer architecture: serial versus parallel design [@problem_id:3688782]. You will analyze and compare a simple 'ripple' chain against a sophisticated parallel 'tree' structure, quantifying the dramatic speed advantage that parallelism offers for associative operations like XOR.", "problem": "A pipeline stage must compute the parity of $64$ independent input bits, where parity is defined as the bitwise exclusive-OR (XOR) of all $64$ inputs. Two alternative combinational topologies are under consideration to implement the parity function using only two-input exclusive-OR (XOR) gates and dedicated two-way fan-out buffers:\n\n- Ripple XOR chain: Connect the $64$ inputs in a linear chain of two-input XOR gates so that the output of one XOR feeds one input of the next XOR, producing the parity at the end of the chain.\n\n- Kogge–Stone–style XOR prefix network: Arrange the $64$ inputs in a full parallel reduction in which each logic level combines disjoint pairs by two-input XOR gates, and each subsequent level combines disjoint pairs of the previous level’s results, continuing until a single parity output remains. This reduction pairs signals at each level, thereby halving the number of signals per level until one remains.\n\nAssume the following delay model, which includes the effect of limited fan-out drive using explicit buffers:\n\n- Each two-input XOR gate has propagation delay $t_{\\text{XOR}} = 80\\,\\text{ps}$ when its output drives exactly one gate input in the next level.\n\n- An explicit two-way fan-out buffer cell is used whenever a node’s output must drive two consumers in the next level. This buffer adds propagation delay $t_{b} = 30\\,\\text{ps}$ on the critical path for that signal. The buffer is idealized to produce two replicas of its input signal and is inserted immediately after the producing gate. Ignore wire delay and assume sizing has been chosen so that $t_{\\text{XOR}}$ is load-independent when the buffer is used to enforce two-way fan-out.\n\n- In the ripple XOR chain, each XOR output drives only one XOR input in the next stage, so no fan-out buffers are needed anywhere on the critical path.\n\n- In the Kogge–Stone–style XOR prefix network, there are $\\lceil \\log_{2}(64) \\rceil$ logic levels of two-input XOR gates along the critical path. Further, at each of the first $\\lceil \\log_{2}(64) \\rceil - 1$ levels, the on-path node’s output must be replicated to supply two consumers in the next level, so exactly one two-way fan-out buffer with delay $t_{b}$ lies on the critical path after each of those levels. The final level’s output directly produces the parity result and does not require replication.\n\nUsing only the definitions of the exclusive-OR (XOR) operation and the concept of critical path delay as the maximum sum of gate delays along any input-to-output path, derive the critical path delay for each topology, then compute the ratio of the ripple-chain critical path delay to the Kogge–Stone–style prefix-network critical path delay. Express the final ratio as an exact value with no units.", "solution": "The parity of $64$ inputs is the associative combination $x_{0} \\oplus x_{1} \\oplus \\cdots \\oplus x_{63}$, where $\\oplus$ denotes exclusive-OR (XOR). Because XOR is associative and commutative, we may realize the function either as a linear chain (ripple) or as a parallel reduction (prefix/tree). The critical path delay is the sum of the delays of all elements traversed by the slowest input-to-output path.\n\nFirst, consider the ripple XOR chain. To XOR $64$ inputs using two-input XOR gates in a linear chain, we need $64 - 1 = 63$ XOR gates in sequence. Each XOR gate output drives only one gate input next, so no fan-out buffers are required on the critical path. With the given delay model, the ripple critical path delay is\n$$\nD_{\\text{ripple}} \\;=\\; 63 \\cdot t_{\\text{XOR}} \\;=\\; 63 \\cdot 80\\,\\text{ps} \\;=\\; 5040\\,\\text{ps}.\n$$\n\nNext, consider the Kogge–Stone–style XOR prefix network. A full parallel reduction that halves the number of signals at each level requires $\\lceil \\log_{2}(64) \\rceil$ levels of two-input XOR gates on the critical path. Since $64 = 2^{6}$, we have\n$$\n\\lceil \\log_{2}(64) \\rceil \\;=\\; 6.\n$$\nThus there are $6$ XOR logic levels along the critical path. By the stated constraint, at each of the first $6 - 1 = 5$ levels, the on-path node’s output must be replicated to drive two consumers at the next level, and so one two-way fan-out buffer of delay $t_{b}$ lies on the critical path after each of those levels. The output of the final (sixth) XOR level produces the parity and is not replicated.\n\nTherefore, the Kogge–Stone–style critical path delay is the sum of $6$ XOR delays and $5$ buffer delays:\n$$\nD_{\\text{KS}} \\;=\\; 6 \\cdot t_{\\text{XOR}} \\;+\\; 5 \\cdot t_{b}\n\\;=\\; 6 \\cdot 80\\,\\text{ps} \\;+\\; 5 \\cdot 30\\,\\text{ps}\n\\;=\\; 480\\,\\text{ps} \\;+\\; 150\\,\\text{ps}\n\\;=\\; 630\\,\\text{ps}.\n$$\n\nFinally, the requested ratio of the ripple-chain critical path delay to the Kogge–Stone–style critical path delay is\n$$\n\\frac{D_{\\text{ripple}}}{D_{\\text{KS}}}\n\\;=\\;\n\\frac{5040\\,\\text{ps}}{630\\,\\text{ps}}\n\\;=\\;\n8.\n$$\nThis ratio is exact and dimensionless, as required.", "answer": "$$\\boxed{8}$$", "id": "3688782"}]}