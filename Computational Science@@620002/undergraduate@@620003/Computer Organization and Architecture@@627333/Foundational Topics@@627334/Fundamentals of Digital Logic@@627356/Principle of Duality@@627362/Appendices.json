{"hands_on_practices": [{"introduction": "At the heart of a processor's control unit lies instruction decoding, which often involves comparing a bit-field from an instruction against a fixed pattern. This can be framed as either detecting a mismatch (if any bit is different) or confirming a match (if all bits are identical). This exercise [@problem_id:3668156] challenges you to apply the principle of duality to transform a mismatch detector, based on a logical disjunction (OR), into its dual match detector, which you will find is based on logical conjunction (AND), providing a foundational insight into digital comparator design.", "problem": "A central processing unit (CPU) decodes an instruction field by testing whether a runtime bit-vector equals a fixed pattern. Let the runtime field be the bit-vector $\\mathbf{b} = (b_{0}, b_{1}, \\dots, b_{m-1})$ and the fixed pattern be $\\mathbf{p} = (p_{0}, p_{1}, \\dots, p_{m-1})$, where each $b_{i} \\in \\{0,1\\}$ and $p_{i} \\in \\{0,1\\}$ for $i \\in \\{0,1,\\dots,m-1\\}$. Consider a mismatch detector built from per-bit exclusive-or, defined by $d_{i} = b_{i} \\oplus p_{i}$, and an aggregate mismatch output defined as the associative logical disjunction across all bits, written in Boolean algebra as\n$$\nM(\\mathbf{b}, \\mathbf{p}) = \\sum_{i=0}^{m-1} d_{i},\n$$\nwhere $\\sum$ denotes associative logical disjunction and $\\cdot$ denotes associative logical conjunction. Using the fundamental definitions and laws of Boolean algebra (including the Principle of Duality, De Morgan's laws, and the canonical definitions of exclusive-or and biconditional), derive the dual match detector $N(\\mathbf{b}, \\mathbf{p})$ that outputs $1$ exactly when all bits of $\\mathbf{b}$ match the corresponding bits of $\\mathbf{p}$. Express $N(\\mathbf{b}, \\mathbf{p})$ as a single closed-form analytic expression in terms of $\\mathbf{b}$ and $\\mathbf{p}$, using the associative logical conjunction $\\prod$ and the biconditional operator $\\leftrightarrow$ or, equivalently, only $+$, $\\cdot$, and $\\overline{(\\cdot)}$. Your final answer must be a single analytic expression. No numerical approximation is required.", "solution": "The problem requires the derivation of a Boolean expression for a match detector, $N(\\mathbf{b}, \\mathbf{p})$, which is described as the dual of a given mismatch detector, $M(\\mathbf{b}, \\mathbf{p})$. The derivation must be based on the principles of Boolean algebra.\n\nFirst, we establish the definitions and relationships.\n- The per-bit mismatch detector $d_i = b_i \\oplus p_i$ evaluates to $1$ if $b_i \\neq p_i$ and to $0$ if $b_i = p_i$.\n- The aggregate mismatch function is the logical OR of all per-bit mismatch signals:\n$$ M(\\mathbf{b}, \\mathbf{p}) = d_0 + d_1 + \\dots + d_{m-1} = \\sum_{i=0}^{m-1} (b_i \\oplus p_i) $$\nThis function $M$ is $1$ if any $d_i$ is $1$, which signifies at least one mismatch. It is $0$ only if all $d_i$ are $0$, which signifies a perfect match.\n\nThe desired match detector $N(\\mathbf{b}, \\mathbf{p})$ must output $1$ for a perfect match and $0$ for any mismatch. This behavior is the logical negation of the mismatch detector $M(\\mathbf{b}, \\mathbf{p})$. Therefore, we define the match detector as:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\overline{M(\\mathbf{b}, \\mathbf{p})} $$\nSubstituting the expression for $M$:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\overline{\\left( \\sum_{i=0}^{m-1} d_i \\right)} = \\overline{d_0 + d_1 + \\dots + d_{m-1}} $$\nThe problem invokes the Principle of Duality and De Morgan's laws. Applying De Morgan's law (a direct consequence of duality) transforms the logical sum (OR) into a logical product (AND), and complements each term:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\overline{d_0} \\cdot \\overline{d_1} \\cdot \\dots \\cdot \\overline{d_{m-1}} $$\nUsing the notation for associative logical conjunction ($\\prod$), this is written as:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} \\overline{d_i} $$\nThis expression shows the structural duality: the wide OR-gate for the mismatch detector becomes a wide AND-gate for the match detector.\n\nNow, we must find an expression for the complemented per-bit signal, $\\overline{d_i}$.\nGiven $d_i = b_i \\oplus p_i$. Then $\\overline{d_i} = \\overline{b_i \\oplus p_i}$.\nThe logical negation of the exclusive-or (XOR) operation is the biconditional operator (also known as equivalence or XNOR), denoted by $\\leftrightarrow$. The biconditional operator $A \\leftrightarrow B$ evaluates to $1$ if and only if $A = B$. This is precisely the function of a per-bit *match* detector.\nSo, $\\overline{d_i} = b_i \\leftrightarrow p_i$.\n\nSubstituting this back into our expression for $N(\\mathbf{b}, \\mathbf{p})$:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} (b_i \\leftrightarrow p_i) $$\nThis expression is the final closed-form representation of the match detector. It states that the overall match is true (evaluates to $1$) if and only if the bit-wise match is true for all bits from $i=0$ to $m-1$. This fulfills all conditions of the problem.\n\nFor completeness, we can also express this using only the basic operators $+, \\cdot$, and $\\overline{(\\cdot)}$. The biconditional operator can be defined as $A \\leftrightarrow B = (A \\cdot B) + (\\overline{A} \\cdot \\overline{B})$. Thus, the expression for $N$ can also be written as:\n$$ N(\\mathbf{b}, \\mathbf{p}) = \\prod_{i=0}^{m-1} (b_i p_i + \\overline{b_i}\\overline{p_i}) $$\nThe form using the biconditional operator is more compact and directly relates to the conceptual transformation from a mismatch detector (XOR) to a match detector (XNOR/biconditional).", "answer": "$$\n\\boxed{\\prod_{i=0}^{m-1} (b_i \\leftrightarrow p_i)}\n$$", "id": "3668156"}, {"introduction": "Modern Arithmetic Logic Units (ALUs) cleverly implement subtraction by adding the two's complement of the subtrahend, reusing the adder circuitry for maximum efficiency. This practice explores the profound, non-obvious duality that arises from this design choice between the carry-out flag ($C_{add}$) from the addition and the conceptual borrow flag ($C_{sub}$) from the subtraction. By deriving the relationship between these two flags from first principles of binary arithmetic [@problem_id:3668114], you will uncover a hidden symmetry that is critical for implementing efficient comparison and conditional branch instructions in hardware.", "problem": "Consider an $n$-bit Arithmetic Logic Unit (ALU) that implements subtraction $A - B$ using two’s complement as the addition $A + \\overline{B} + 1$, where $\\overline{B}$ is the bitwise complement of $B$. Let $A, B \\in \\{0, 1, \\dots, 2^{n} - 1\\}$ be interpreted as unsigned $n$-bit integers, and let $C_{add}$ denote the carry-out bit from the Most Significant Bit (MSB) produced by the addition $A + \\overline{B} + 1$. Define the subtraction borrow flag $C_{sub}$ to be $1$ if a borrow occurs in $A - B$ (equivalently, if $A < B$), and $0$ otherwise.\n\nStarting only from the fundamental definitions of two’s complement, unsigned $n$-bit ranges, and the meaning of carry-out and borrow, derive an expression for the borrow flag $C_{sub}$ entirely in terms of $C_{add}$ (not involving $A$ or $B$ explicitly). You must justify the expression from first principles of binary arithmetic.\n\nThen, for $n = 8$ with the specific operands $A = 0101\\,1110_{2}$ and $B = 1010\\,0011_{2}$, evaluate the value of the borrow flag $C_{sub}$ produced by the ALU using the $A + \\overline{B} + 1$ implementation. Report the value of $C_{sub}$ as your final answer. No rounding is required and no physical units are involved.", "solution": "The problem asks for two things: first, to derive a general expression for the subtraction borrow flag $C_{sub}$ in terms of the addition carry-out flag $C_{add}$, and second, to calculate $C_{sub}$ for a specific case.\n\n**Part 1: Derivation of the relationship between $C_{sub}$ and $C_{add}$**\n\nAn $n$-bit ALU performs the subtraction $A - B$ by computing the addition $S = A + \\overline{B} + 1$. The term $\\overline{B} + 1$ is the two's complement of $B$.\n        \nThe bitwise complement $\\overline{B}$ is arithmetically equivalent to $(2^n - 1) - B$ for an unsigned $n$-bit integer $B$.\n        \nSubstituting this into the ALU's operation, the full integer sum is:\n$$ S = A + ((2^n - 1) - B) + 1 = A - B + 2^n $$\nThe $n$-bit ALU calculates this sum modulo $2^n$. The carry-out bit, $C_{add}$, is 1 if the full integer sum $S$ is greater than or equal to $2^n$, and 0 otherwise.\n\nWe now analyze this based on the definition of the borrow flag, $C_{sub}$.\n- **Case 1: No borrow occurs ($A \\ge B$)**. By definition, this means the borrow flag $C_{sub} = 0$. Since $A \\ge B$, the difference $A - B$ is non-negative ($A-B \\ge 0$). Therefore, the full sum is $S = (A - B) + 2^n \\ge 2^n$. Because the sum is at least $2^n$, the $n$-bit addition will produce a carry-out. Thus, $C_{add} = 1$. In this case, $C_{sub} = 0$ corresponds to $C_{add} = 1$.\n\n- **Case 2: A borrow occurs ($A  B$)**. By definition, this means the borrow flag $C_{sub} = 1$. Since $A  B$, the difference $A - B$ is negative. The smallest possible value is $0 - (2^n-1) = -(2^n-1)$. So, $- (2^n - 1) \\le A - B \\le -1$. The full sum is $S = (A - B) + 2^n$. The range for S is $-(2^n-1) + 2^n \\le S \\le -1 + 2^n$, which simplifies to $1 \\le S \\le 2^n - 1$. Because the sum is strictly less than $2^n$, the $n$-bit addition will not produce a carry-out. Thus, $C_{add} = 0$. In this case, $C_{sub} = 1$ corresponds to $C_{add} = 0$.\n\nCombining both cases, we find that $C_{sub}$ is always the logical negation of $C_{add}$.\n$$ C_{sub} = \\overline{C_{add}} $$\nThis demonstrates the non-obvious duality between the carry-out of the addition-based subtraction and the conceptual borrow flag.\n\n**Part 2: Calculation for specific operands**\n\nGiven $n=8$ and the operands:\n- $A = 0101\\,1110_2$\n- $B = 1010\\,0011_2$\n\nTo find $C_{sub}$, we first compute $C_{add}$ from the operation $A + \\overline{B} + 1$.\nFirst, find the bitwise complement of $B$:\n$$ \\overline{B} = \\overline{1010\\,0011_2} = 0101\\,1100_2 $$\nNow, perform the 8-bit addition $A + (\\overline{B} + 1)$:\n```\n   1111 11    (carries)\n  0101 1110   (A)\n+ 0101 1100   (B-bar)\n+ 0000 0001   (cin = 1)\n-----------\n(0) 1011 1011   (Result)\n```\nThe addition is $0101\\,1110_2 + 0101\\,1101_2$.\nThe 8-bit result is $1011\\,1011_2$. There is no carry-out from the most significant bit position. Therefore, $C_{add} = 0$.\n\nUsing the derived relationship:\n$$ C_{sub} = \\overline{C_{add}} = \\overline{0} = 1 $$\nAs a sanity check, we can convert the numbers to decimal: $A = 94_{10}$ and $B = 163_{10}$. Since $A  B$, a borrow is indeed required for the subtraction $A - B$, so $C_{sub}=1$ is correct.", "answer": "$$ \\boxed{1} $$", "id": "3668114"}, {"introduction": "High-performance processor pipelines depend on sophisticated control logic to detect and resolve data hazards, which could otherwise produce incorrect results. This exercise [@problem_id:3668128] models the logic for a common \"load-use\" hazard using Boolean vectors, demonstrating the duality between a \"hazard mask\" that signals a stall and an \"issue-permit\" vector that gives the green light to proceed. You will apply duality to derive the issue-permit logic and then analyze its real-world impact on performance by tracing an instruction sequence through the pipeline, solidifying your understanding of how abstract Boolean principles govern concrete system behavior.", "problem": "Consider a scalar, in-order, single-issue, five-stage pipeline with stages instruction fetch (IF), instruction decode and register read (ID), execute (EX), memory access (MEM), and write back (WB). The pipeline implements full bypassing (forwarding) for arithmetic and logic instructions whose results are produced in the execute stage, but a load-use hazard remains: if an instruction in the execute stage is a load, the value it will write to its destination register is not available until the end of the memory access stage in the next cycle, so an immediately following instruction that needs that value cannot enter the execute stage in the next cycle.\n\nDefine the following Boolean vector signals over a register file of size $N=8$ (registers $r_0,\\dots,r_7$):\n- The read-demand vector $R_d(t)$ at cycle $t$ has bit $i$ set to $1$ if, at cycle $t$, the instruction in the instruction decode and register read stage reads register $r_i$, and $0$ otherwise.\n- The write-pending vector $W_s(t)$ at cycle $t$ has bit $i$ set to $1$ if, at cycle $t$, there is a load instruction in the execute stage that will write register $r_i$ and whose value will not be available to the next cycle’s execute stage, and $0$ otherwise.\n\nA bitwise hazard mask is defined by the Boolean conjunction $mask(t) = R_d(t) \\cdot W_s(t)$, where the dot denotes bitwise conjunction across the $N$ bits. The pipeline interlock uses a dual “issue-permit” vector $unmask(t)$ to decide safety: issue is permitted in cycle $t$ if and only if every bit of $unmask(t)$ is $1$; otherwise a single-cycle bubble is inserted, holding the instruction in the instruction decode and register read stage and freezing instruction fetch.\n\nStarting only from the axioms of Boolean algebra and the principle of duality, derive an expression for $unmask(t)$ in terms of $R_d(t)$ and $W_s(t)$ without introducing any new primitives. Then, apply your derived $unmask(t)$ to evaluate the following instruction sequence under the stated pipeline rules. Assume all arithmetic and logic instructions produce results in the execute stage that can be forwarded without stalls; the load-use hazard is the only source of stalls. The instruction sequence is:\n\n$I_1$: load $r_1 \\leftarrow M[r_2]$  \n$I_2$: add $r_3 \\leftarrow r_1 + r_4$  \n$I_3$: add $r_5 \\leftarrow r_3 + r_6$  \n$I_4$: load $r_3 \\leftarrow M[r_7]$  \n$I_5$: add $r_0 \\leftarrow r_3 + r_1$  \n$I_6$: add $r_7 \\leftarrow r_0 + r_3$\n\nCompute the total number of clock cycles required to complete all $6$ instructions, including initial pipeline fill and any stalls induced by the interlock using your $unmask(t)$ expression. Express your final answer as a single integer number of cycles. No rounding is needed.", "solution": "The problem asks for two main tasks: first, to derive an expression for an \"issue-permit\" vector, $unmask(t)$, based on the principle of duality; and second, to apply this logic to a given instruction sequence to determine the total execution time in clock cycles.\n\n### Part 1: Derivation of the `unmask(t)` Vector Expression\n\nThe core of the task is to derive the expression for $unmask(t)$ using the principle of duality. Let us formalize the hazard and issue conditions.\n\nA load-use hazard occurs if the instruction in the ID stage needs to read a register that is the destination of a `load` instruction currently in the EX stage.\nIn terms of the given vectors:\n- $R_{d,i}(t) = 1$ means the instruction in ID reads register $r_i$.\n- $W_{s,i}(t) = 1$ means a `load` in EX writes to register $r_i$.\n\nA hazard exists for a specific register $r_i$ if both conditions are met, i.e., if the $i$-th bit of the hazard mask, $mask_i(t) = R_{d,i}(t) \\cdot W_{s,i}(t)$, is $1$.\n\nThe pipeline must stall if a hazard exists for *any* register. This corresponds to the condition that at least one bit in the $mask(t)$ vector is $1$. The overall stall signal, $S(t)$, can be expressed as the OR-reduction of the $mask(t)$ vector:\n$$S(t) = \\bigvee_{i=0}^{N-1} mask_i(t) = \\bigvee_{i=0}^{N-1} (R_{d,i}(t) \\cdot W_{s,i}(t))$$\nA stall occurs if $S(t)=1$.\n\nThe problem states that issue is permitted if and only if all bits of $unmask(t)$ are $1$. This global \"issue permit\" signal, $P(t)$, is the AND-reduction of the $unmask(t)$ vector:\n$$P(t) = \\bigwedge_{i=0}^{N-1} unmask_i(t)$$\nIssue is permitted if $P(t)=1$.\n\nLogically, issue is permitted if and only if there is no stall condition. Thus, $P(t) = \\neg S(t)$.\n$$P(t) = \\neg \\left( \\bigvee_{i=0}^{N-1} (R_{d,i}(t) \\cdot W_{s,i}(t)) \\right)$$\nThe principle of duality in Boolean algebra is expressed through De Morgan's theorem. Applying De Morgan's theorem to the expression for $P(t)$:\n$$P(t) = \\bigwedge_{i=0}^{N-1} \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\nWe now have two expressions for the global issue permit signal $P(t)$:\n$$P(t) = \\bigwedge_{i=0}^{N-1} unmask_i(t) = \\bigwedge_{i=0}^{N-1} \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\nFor this equality to hold for any combination of input vectors, we must have equality for each bit:\n$$unmask_i(t) = \\neg(R_{d,i}(t) \\cdot W_{s,i}(t))$$\nThis is the bitwise Boolean NAND operation. In vector form, the expression for the dual \"issue-permit\" vector is the bitwise complement of the hazard mask vector:\n$$unmask(t) = \\neg mask(t) = \\neg(R_d(t) \\cdot W_s(t))$$\nUsing De Morgan's law on the single-bit expression, we can also write this as $unmask_i(t) = \\neg R_{d,i}(t) + \\neg W_{s,i}(t)$.\n\n### Part 2: Pipeline Execution Analysis\n\nWe now analyze the execution of the given instruction sequence to determine the total number of clock cycles. The only source of stalls is the load-use hazard. An arithmetic-logic unit (ALU) to ALU dependency (e.g., an `add` followed by an `add` that uses its result) does not cause a stall due to \"full bypassing (forwarding)\". A load-use dependency (e.g., a `load` followed by an `add` that uses the loaded value) incurs a one-cycle stall.\n\nThe dependencies in the sequence are:\n1.  $I_1 \\rightarrow I_2$: `load r1` is followed by `add r3 - r1 + ...`. This is a load-use dependency. A stall is expected.\n2.  $I_2 \\rightarrow I_3$: `add r3` is followed by `add r5 - r3 + ...`. This is an ALU-ALU dependency. No stall due to forwarding.\n3.  $I_4 \\rightarrow I_5$: `load r3` is followed by `add r0 - r3 + ...`. This is a load-use dependency. A stall is expected.\n4.  $I_5 \\rightarrow I_6$: `add r0` is followed by `add r7 - r0 + ...`. This is an ALU-ALU dependency. No stall due to forwarding.\n5.  $I_4 \\rightarrow I_6$: `load r3` is followed by `add r7 - ... + r3`. This dependency is resolved without a stall via the register file write/read timing, as the result from $I_4$ is written back before $I_6$ reads its registers.\n\nLet's trace the pipeline execution cycle-by-cycle. A `*` indicates a stall cycle for the instruction in the ID stage.\n\n| Cycle | $I_1$ (load) | $I_2$ (add) | $I_3$ (add) | $I_4$ (load) | $I_5$ (add) | $I_6$ (add) | Notes |\n|:-----:|:------------:|:-----------:|:-----------:|:------------:|:-----------:|:-----------:|:-------------------------------------------|\n| 1     | IF           |             |             |              |             |             |                                            |\n| 2     | ID           | IF          |             |              |             |             |                                            |\n| 3     | EX           | ID          | IF          |              |             |             | $I_2$ reads $r_1$, $I_1$ is `load` in EX. **Stall**. |\n| 4     | MEM          | ID*         | IF*         |              |             |             | $I_2$ stalled. Bubble enters EX. IF is frozen. |\n| 5     | WB           | EX          | ID          | IF           |             |             | $I_2$ proceeds. $r_1$ forwarded from $I_1$.    |\n| 6     |              | MEM         | EX          | ID           | IF          |             | $r_3$ forwarded from $I_2$ to $I_3$.         |\n| 7     |              | WB          | MEM         | EX           | ID          | IF          | $I_5$ reads $r_3$, $I_4$ is `load` in EX. **Stall**. |\n| 8     |              |             | WB          | MEM          | ID*         | IF*         | $I_5$ stalled. Bubble enters EX. IF is frozen. |\n| 9     |              |             |             | WB           | EX          | ID          | $I_5$ proceeds. $r_3$ forwarded from $I_4$.    |\n| 10    |              |             |             |              | MEM         | EX          | $r_0$ forwarded from $I_5$ to $I_6$.         |\n| 11    |              |             |             |              | WB          | MEM         |                                            |\n| 12    |              |             |             |              |             | WB          | $I_6$ completes.                           |\n\nThe baseline number of cycles for $k=6$ instructions in an $m=5$ stage pipeline is $m-1+k = 5-1+6 = 10$ cycles.\nThere are two load-use hazards identified that cause stalls:\n1.  The dependency of $I_2$ on $I_1$ causes one stall cycle (in cycle 4).\n2.  The dependency of $I_5$ on $I_4$ causes one stall cycle (in cycle 8).\n\nEach stall adds one cycle to the total execution time.\nTotal cycles = Baseline cycles + Stall cycles\nTotal cycles = $10 + 2 = 12$.\n\nThe final instruction, $I_6$, completes its WB stage at the end of cycle $12$. Therefore, the total number of clock cycles required is $12$.", "answer": "$$\\boxed{12}$$", "id": "3668128"}]}