{"hands_on_practices": [{"introduction": "The first step to mastering floating-point representation is learning to decode the raw binary data. This practice guides you through the process of taking a 32-bit pattern and, using the rules of the IEEE 754 standard, converting it back into a familiar number [@problem_id:3642294]. By working from first principles, you will solidify your understanding of the sign, biased exponent, and fraction fields that form the foundation of floating-point arithmetic.", "problem": "A $32$-bit word is stored using the Institute of Electrical and Electronics Engineers (IEEE) $754$ binary32 format. The raw bit pattern, written from most significant bit to least significant bit, is\n$$11000010001010100000000000000000.$$\nUsing only the canonical layout and semantics of IEEE $754$ binary32 as your starting point, decode this word. Derive, from first principles, the field decomposition, the category of the value (normal, subnormal, $0$, $+\\infty$, $-\\infty$, or Not a Number (NaN)), and the exact real number it represents if it is finite. Report the category in your reasoning, but for your final numerical result, express the decoded real value as an exact rational number in lowest terms. Do not round. If the value is non-finite, then your final result should be the appropriate symbolic value $+\\infty$, $-\\infty$, or $\\mathrm{NaN}$.", "solution": "The problem statement is a well-posed and self-contained exercise in applying the IEEE $754$ binary32 standard. It provides a specific $32$-bit pattern and asks for its decoding into a real number according to the rules of the standard. The problem is scientifically grounded, objective, and contains all necessary information. Therefore, the problem is valid and a solution can be derived.\n\nThe IEEE $754$ standard for $32$-bit binary floating-point numbers (binary32) defines a specific layout for the bits within a $32$-bit word. The word is partitioned into three fields, read from the most significant bit (MSB) to the least significant bit (LSB):\n1.  Sign ($S$): $1$ bit (bit $31$).\n2.  Exponent ($E$): $8$ bits (bits $30$ through $23$).\n3.  Fraction ($F$): $23$ bits (bits $22$ through $0$).\n\nThe given $32$-bit word is:\n$$\n11000010001010100000000000000000\n$$\nWe partition this bit pattern according to the binary32 format:\n$$\n\\underset{S}{\\underbrace{1}} \\quad \\underset{E}{\\underbrace{10000100}} \\quad \\underset{F}{\\underbrace{01010100000000000000000}}\n$$\nFrom this decomposition, we extract the values for the three fields:\n-   The sign bit $S$ is the MSB, which is $1$.\n-   The exponent field $E$ consists of the $8$ bits `10000100`. We convert this binary integer to its decimal equivalent:\n    $$\n    E = (10000100)_2 = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 128 + 4 = 132.\n    $$\n-   The fraction field $F$ consists of the remaining $23$ bits: `01010100000000000000000`.\n\nNext, we determine the category of the floating-point number. This is dictated by the value of the exponent field $E$. For the binary32 format, the exponent bias is $B = 2^{8-1} - 1 = 127$. The special values for $E$ are $0$ and $255$.\n-   If $E = 255$, the number is either an infinity or a NaN (Not a Number).\n-   If $E = 0$, the number is either zero or a subnormal number.\n-   If $0  E  255$, the number is a normal number.\n\nIn this case, the exponent field value is $E=132$. Since $0  132  255$, the number is a **normal** number.\n\nFor a normal number, the value $V$ it represents is given by the formula:\n$$\nV = (-1)^S \\times 2^{e} \\times M\n$$\nwhere $e = E - B$ is the true exponent, and $M$ is the significand, which is constructed from the fraction field $F$ by prepending an implicit leading bit of $1$. That is, $M = (1.F)_2$.\n\nLet us compute the components of this formula.\n-   The sign is determined by $S=1$, so $(-1)^S = (-1)^1 = -1$.\n-   The true exponent is $e = E - B = 132 - 127 = 5$.\n-   The significand $M$ is formed from the fraction field $F = (010101000...)_2$. The trailing zeros do not affect the value.\n    $$\n    M = (1.F)_2 = (1.010101)_2\n    $$\n    We convert this binary representation to a rational number:\n    $$\n    M = 1 \\cdot 2^0 + 0 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4} + 0 \\cdot 2^{-5} + 1 \\cdot 2^{-6}\n    $$\n    $$\n    M = 1 + \\frac{1}{2^2} + \\frac{1}{2^4} + \\frac{1}{2^6} = 1 + \\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64}\n    $$\n    To sum these fractions, we find a common denominator, which is $64$:\n    $$\n    M = \\frac{64}{64} + \\frac{16}{64} + \\frac{4}{64} + \\frac{1}{64} = \\frac{64+16+4+1}{64} = \\frac{85}{64}\n    $$\n\nFinally, we substitute these components back into the formula for $V$:\n$$\nV = (-1) \\times 2^5 \\times \\frac{85}{64}\n$$\nSince $2^5 = 32$, we have:\n$$\nV = -32 \\times \\frac{85}{64} = - \\frac{32 \\times 85}{64}\n$$\nWe can simplify the fraction by canceling the factor of $32$:\n$$\nV = - \\frac{85}{2}\n$$\nThe numbers $85$ and $2$ are coprime ($85 = 5 \\times 17$), so this fraction is in lowest terms. The exact real number represented by the given bit pattern is $-\\frac{85}{2}$.", "answer": "$$\n\\boxed{-\\frac{85}{2}}\n$$", "id": "3642294"}, {"introduction": "While most floating-point numbers are 'normalized,' the IEEE 754 standard includes special 'subnormal' numbers to handle values extremely close to zero. This exercise explores the crucial concept of gradual underflow, a mechanism that uses subnormal numbers to maintain precision and prevent abrupt drops to zero [@problem_id:3642263]. You will compare the accuracy of systems with and without this feature, revealing why it is a cornerstone of modern numerical computing.", "problem": "Consider arithmetic compliant with the Institute of Electrical and Electronics Engineers (IEEE) Standard for Floating-Point Arithmetic (IEEE 754) in the binary32 format (single precision), which uses $1$ sign bit, $8$ exponent bits, and $23$ fraction bits with an implicit leading $1$ for normalized numbers. In this format, subnormal (denormal) numbers occur when the exponent field is all zeros; they have no implicit leading $1$, and their spacing is uniform. The smallest positive subnormal magnitude is $2^{-149}$, and the next larger representable (subnormal or normal) value is obtained by adding $2^{-149}$.\n\nA processor supports two underflow handling modes for the operation $x = y - z$ on real operands $y$ and $z$:\n- Gradual underflow: the exact real difference is rounded to the nearest representable binary32 value using round-to-nearest, ties-to-even.\n- Flush-to-zero: any nonzero subnormal result is replaced by $0$, while normal rounding is otherwise used.\n\nAssume $y > z > 0$ are real numbers such that the exact difference is\n$$d = y - z = \\frac{101}{200}\\cdot 2^{-149},$$\nwith $|d|  2^{-149}$. Define the scalar quantity\n$$R = \\frac{\\text{absolute error under flush-to-zero}}{\\text{absolute error under gradual underflow}},$$\nwhere “absolute error” means the absolute value of the difference between the computed result and the exact real result $d$.\n\nUsing only the foundational properties of IEEE 754 binary32 (format structure, subnormal spacing, and round-to-nearest ties-to-even), determine the exact value of $R$ as a single real number. No unit is required. Do not round; provide your answer in exact form.", "solution": "The problem will first be validated for scientific soundness, self-consistency, and well-posedness.\n\n### Step 1: Extract Givens\nThe data and conditions explicitly provided in the problem statement are as follows:\n- **Floating-Point System**: Institute of Electrical and Electronics Engineers (IEEE) Standard 754, `binary32` format (single precision).\n- **Format Structure**: $1$ sign bit, $8$ exponent bits, $23$ fraction bits.\n- **Normalized Numbers**: Implicit leading $1$.\n- **Subnormal Numbers**: Exponent field is all zeros, no implicit leading $1$, uniform spacing.\n- **Smallest Positive Subnormal**: Magnitude is $s_{min} = 2^{-149}$.\n- **Subnormal Spacing**: The spacing between adjacent subnormal numbers is $2^{-149}$. This is also the difference between the largest subnormal and smallest normal number.\n- **Operation**: $x = y - z$, where $y$ and $z$ are real numbers with $y > z > 0$.\n- **Exact Difference**: $d = y - z = \\frac{101}{200} \\cdot 2^{-149}$. It is also noted that $|d|  2^{-149}$.\n- **Underflow Mode 1 (Gradual Underflow)**: The exact real difference $d$ is rounded to the nearest representable `binary32` value using the round-to-nearest, ties-to-even rule.\n- **Underflow Mode 2 (Flush-to-Zero)**: Any nonzero subnormal result is replaced by $0$. Normal rounding is otherwise used.\n- **Quantity to Find**: The ratio $R = \\frac{\\text{absolute error under flush-to-zero}}{\\text{absolute error under gradual underflow}}$.\n- **Error Definition**: \"Absolute error\" is the absolute value of the difference between the computed result and the exact real result $d$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is grounded in the well-defined IEEE 754 standard for floating-point arithmetic.\n- **Scientific Soundness**: The `binary32` format details are correct. The biased exponent range is $[-126, 127]$ for normalized numbers. An exponent field of all zeros signals a subnormal number or zero; for subnormals, the effective exponent is fixed at that of the smallest normalized numbers, which is $1 - \\text{bias} = 1 - 127 = -126$. A subnormal number's value is $v = (-1)^S \\times 0.F \\times 2^{-126}$, where $F$ is the $23$-bit fraction. The smallest positive subnormal value occurs when the fraction $F$ has its least significant bit set to $1$ and all other bits are $0$, so $F = 2^{-23}$. The value is thus $2^{-23} \\times 2^{-126} = 2^{-149}$. The statement that the smallest positive subnormal magnitude is $2^{-149}$ is correct. The spacing of subnormal numbers is uniform, with a quantum of $2^{-149}$, which is also correctly stated. The definitions for gradual underflow and flush-to-zero are standard. The problem is scientifically sound.\n- **Well-Posedness**: The problem provides all necessary information to determine the computed value in both modes, calculate the respective errors, and find their ratio. The question is unambiguous and leads to a unique, stable solution.\n- **Objectivity**: The language is technical and precise.\n\nThe problem statement is valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Solution\nThe objective is to compute the ratio $R = \\frac{E_{flush}}{E_{grad}}$, where $E_{flush}$ and $E_{grad}$ are the absolute errors for the flush-to-zero and gradual underflow modes, respectively. The exact difference is given as $d = \\frac{101}{200} \\cdot 2^{-149}$.\n\nFirst, we analyze the set of representable `binary32` numbers near zero. The subnormal numbers are integer multiples of the smallest positive subnormal value, $s_{min} = 2^{-149}$. The positive representable numbers near zero are $\\{0, 1 \\cdot 2^{-149}, 2 \\cdot 2^{-149}, 3 \\cdot 2^{-149}, \\dots\\}$.\n\nThe exact result is $d = \\frac{101}{200} \\cdot 2^{-149} = 0.505 \\cdot 2^{-149}$. This value is not an integer multiple of $2^{-149}$, so it is not a representable `binary32` number. It must be rounded.\n\n**1. Calculation for Gradual Underflow**\n\nUnder gradual underflow, the exact result $d$ is rounded to the nearest representable number. The rule specified is round-to-nearest, ties-to-even. The value $d$ lies between two consecutive representable numbers: $0$ and $s_{min} = 1 \\cdot 2^{-149}$.\n\nTo determine the nearest representable number, we compare $d$ to the midpoint between $0$ and $s_{min}$.\nThe midpoint $m$ is:\n$$m = \\frac{0 + s_{min}}{2} = \\frac{1}{2} s_{min} = \\frac{1}{2} \\cdot 2^{-149} = 0.5 \\cdot 2^{-149}$$\n\nWe compare $d$ with $m$:\n$$d = 0.505 \\cdot 2^{-149}$$\n$$m = 0.5 \\cdot 2^{-149}$$\nSince $0.505 > 0.5$, we have $d > m$. This means $d$ is closer to $s_{min}$ than it is to $0$. As this is not a tie, the \"ties-to-even\" part of the rule is irrelevant. The result is rounded to the nearest value, which is $s_{min}$.\n\nThe computed result under gradual underflow is $x_{grad}$:\n$$x_{grad} = s_{min} = 2^{-149}$$\n\nThe absolute error under gradual underflow, $E_{grad}$, is the absolute difference between the computed result and the exact result:\n$$E_{grad} = |x_{grad} - d| = |2^{-149} - \\frac{101}{200} \\cdot 2^{-149}|$$\nFactoring out $2^{-149}$:\n$$E_{grad} = |1 - \\frac{101}{200}| \\cdot 2^{-149} = |\\frac{200 - 101}{200}| \\cdot 2^{-149} = \\frac{99}{200} \\cdot 2^{-149}$$\n\n**2. Calculation for Flush-to-Zero**\n\nIn the flush-to-zero mode, any result that would be a nonzero subnormal number is forced to zero. The exact result $d = 0.505 \\cdot 2^{-149}$ is in the subnormal range, as its magnitude is less than the smallest positive normalized number ($2^{-126}$) but greater than zero. The IEEE 754 standard specifies that underflow occurs when the exact result is tiny (in the subnormal range) and would cause a loss of accuracy. In flush-to-zero mode, such a result is replaced by zero.\n\nThe computed result under flush-to-zero is $x_{flush}$:\n$$x_{flush} = 0$$\n\nThe absolute error under flush-to-zero, $E_{flush}$, is:\n$$E_{flush} = |x_{flush} - d| = |0 - \\frac{101}{200} \\cdot 2^{-149}|$$\n$$E_{flush} = \\frac{101}{200} \\cdot 2^{-149}$$\n\n**3. Calculation of the Ratio R**\n\nThe ratio $R$ is defined as the quotient of the two absolute errors:\n$$R = \\frac{E_{flush}}{E_{grad}}$$\nSubstituting the expressions we derived:\n$$R = \\frac{\\frac{101}{200} \\cdot 2^{-149}}{\\frac{99}{200} \\cdot 2^{-149}}$$\nThe common factor of $\\frac{1}{200} \\cdot 2^{-149}$ in the numerator and denominator cancels out.\n$$R = \\frac{101}{99}$$\nThis is the final exact value as requested.", "answer": "$$\\boxed{\\frac{101}{99}}$$", "id": "3642263"}, {"introduction": "Floating-point numbers can only approximate most real numbers, a limitation that has profound consequences for arithmetic. This problem demonstrates the phenomenon of 'catastrophic cancellation,' where subtracting two nearly equal numbers can cause a dramatic loss of significant digits [@problem_id:3642283]. By tracing the conversion and subtraction of two seemingly precise decimal values, you will uncover the hidden representation errors and see how they can dominate a calculation's result.", "problem": "Consider arithmetic performed in the Institute of Electrical and Electronics Engineers (IEEE $754$) Standard for Floating-Point Arithmetic, specifically the binary$32$ format with one sign bit, eight exponent bits with bias $127$, and $23$ fraction bits with an implicit leading $1$ for normalized numbers. Two decimal inputs $x = 123456.78$ and $y = 123456.77$ are first converted to binary$32$ using round-to-nearest, ties-to-even, then the subtraction $x - y$ is performed with correct rounding to binary$32$ under the same rule. Starting only from the structural definition of binary$32$ and normalization, determine the exact decimal value that the hardware returns for the subtraction.\n\nExpress the final answer as an exact decimal number. No unit is required.", "solution": "The user wants me to solve a floating-point arithmetic problem.\n\n### Step 1: Extract Givens\n- **Standard**: IEEE $754$ binary$32$ format.\n- **Format**: $1$ sign bit, $8$ exponent bits, $23$ fraction bits.\n- **Bias**: Exponent bias of $127$.\n- **Normalization**: Implicit leading $1$ for normalized numbers.\n- **Rounding Rule**: Round-to-nearest, ties-to-even.\n- **Input `x`**: $x = 123456.78$\n- **Input `y`**: $y = 123456.77$\n- **Operation**:\n  1. Convert $x$ to its binary$32$ representation, let's call it $x_{b32}$.\n  2. Convert $y$ to its binary$32$ representation, let's call it $y_{b32}$.\n  3. Compute the difference $d = x_{b32} - y_{b32}$ and round the result to binary$32$.\n- **Objective**: Find the exact decimal value of the final computed result.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is based on the IEEE $754$ standard, which is a fundamental and universally accepted standard in computer architecture and numerical computation. The principles are scientifically and mathematically sound.\n- **Well-Posedness**: The problem provides all necessary parameters: the number format (binary$32$), the specific inputs ($x$ and $y$), and the exact arithmetic rules (rounding mode). This ensures that a unique, deterministic solution exists.\n- **Objectivity**: The problem statement is precise and technical, free of ambiguity or subjective language.\n\nThe problem does not violate any of the invalidity criteria. It is a well-posed, standard problem in numerical analysis, specifically concerning representation error and catastrophic cancellation in floating-point arithmetic.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nThe problem requires us to simulate the process of floating-point conversion and subtraction as it would be performed by hardware adhering to the IEEE $754$ binary$32$ standard.\n\n**1. Determine the relevant floating-point precision (ULP)**\n\nFirst, we must determine the magnitude of the input numbers, $x = 123456.78$ and $y = 123456.77$. We can find the bracketing powers of $2$:\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\nSince $2^{16}  x, y  2^{17}$, any normalized binary$32$ representation of these numbers will have an unbiased exponent of $e=16$.\nThe value of a normalized number in this format is given by $v = (-1)^s \\times (1.f)_2 \\times 2^e$, where $s$ is the sign bit and $f$ is the $23$-bit fraction. The biased exponent stored in the $8$-bit exponent field is $E = e + 127 = 16 + 127 = 143$.\n\nThe precision of numbers in this range is determined by the value of the least significant bit of the significand. This is known as the Unit in the Last Place (ULP).\n$$\\text{ULP} = 2^e \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\nAs a decimal, the ULP is:\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\nEvery real number in the range $[2^{16}, 2^{17})$ is mapped to the nearest multiple of this ULP value.\n\n**2. Convert input `x` to binary32 format**\n\nTo find the binary$32$ representation of $x = 123456.78$, we divide $x$ by the ULP to find which multiple it is closest to.\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\nThis number represents the significand scaled by $2^{23}$. According to the \"round-to-nearest, ties-to-even\" rule, we must round this to the nearest integer. Since the fractional part $0.84$ is greater than $0.5$, we round up.\n$$N_x = \\text{round}(15802467.84) = 15802468$$\nThe stored value for $x$, which we call $x_{b32}$, is this integer multiple of the ULP.\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. Convert input `y` to binary32 format**\n\nWe repeat the same process for $y = 123456.77$.\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\nThe fractional part $0.56$ is greater than $0.5$, so we round up. Note that this is not a tie, so the \"ties-to-even\" part of the rule is not invoked.\n$$N_y = \\text{round}(15802466.56) = 15802467$$\nThe stored value for $y$, which we call $y_{b32}$, is:\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. Perform the subtraction and determine the final result**\n\nThe hardware performs the subtraction on the stored representations $x_{b32}$ and $y_{b32}$. The exact result of this subtraction is:\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\nThe final step is to ensure this result $d$ is correctly stored in a binary$32$ register, which may involve another rounding step. We must check if $d$ is exactly representable.\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\nThis value can be written in normalized floating-point form as $1.0_2 \\times 2^{-7}$.\n- The sign is positive ($s=0$).\n- The significand is $1.0_2$, so the fraction part $f$ is all zeros.\n- The unbiased exponent is $e = -7$.\nThis exponent is within the valid range for normalized binary$32$ numbers, which is $[-126, 127]$. Since the value is a power of two, it is exactly representable in binary floating-point format. Therefore, no rounding is required for the final result.\n\nThe value returned by the hardware is the exact result of the subtraction of the stored values.", "answer": "$$\n\\boxed{0.0078125}\n$$", "id": "3642283"}]}