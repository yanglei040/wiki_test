{"hands_on_practices": [{"introduction": "A common but surprisingly tricky task in programming is checking if a floating-point value is zero. Due to the nuances of floating-point representation, a simple equality test like `x == 0.0` might not capture all cases of \"effective zero,\" especially when dealing with results from calculations involving catastrophic cancellation or underflow. This first practice challenges you to analyze the behavior of different zero-checking strategies in the presence of special IEEE 754 values like subnormal numbers, signed zeros, and NaNs, a critical skill for developing robust numerical code [@problem_id:3648780].", "problem": "A system conforms to the Institute of Electrical and Electronics Engineers (IEEE) $754$ floating-point standard with gradual underflow enabled and uses double precision ($\\mathrm{binary64}$). Let $x$ be a finite result of a subtraction between two nearly equal normal numbers, so $x$ may be exactly $+0.0$, $-0.0$, a nonzero subnormal, or a small normal. A developer must decide whether $x$ is “effectively zero” to trigger a branch. Two candidate tests are considered: the strict equality $x == 0.0$ and the absolute tolerance test $|x| < \\tau$ for some fixed $\\tau > 0$.\n\nAssume the following IEEE $754$ facts as the fundamental base:\n- The format $\\mathrm{binary64}$ has gradual underflow, producing subnormal numbers that are nonzero but have magnitudes strictly less than the minimum positive normal.\n- The minimum positive normal in $\\mathrm{binary64}$ is $2^{-1022}$, and the minimum positive subnormal is $2^{-1074}$.\n- Signed zeros $+0.0$ and $-0.0$ compare equal under the standard’s numerical equality.\n- Any ordered comparison with Not a Number (NaN) is false, and $|\\mathrm{NaN}|$ is $\\mathrm{NaN}$.\n- IEEE $754$ defines classification predicates such as $\\mathrm{isfinite}(\\cdot)$ and $\\mathrm{isSubnormal}(\\cdot)$.\n\nSelect all statements that are correct about the behavior of these tests and about IEEE-aware safe zero checks:\n\nA. The predicate $x == 0.0$ is true exactly when $x$ is $+0.0$ or $-0.0$, and it is false for any nonzero subnormal $x$; therefore it does not treat nonzero underflow results as zero.\n\nB. For a fixed absolute tolerance $\\tau$, the predicate $|x| < \\tau$ will be true for all subnormals whenever $\\tau \\ge 2^{-1022}$ in $\\mathrm{binary64}$, but it may also classify some small normal values as “effectively zero” if $\\tau$ is chosen too large relative to the problem’s scale.\n\nC. Because $+0.0$ and $-0.0$ compare unequal under IEEE $754$, a robust equality check for zero must explicitly test both $x == +0.0$ and $x == -0.0$.\n\nD. If $x$ is $\\mathrm{NaN}$, then $x == 0.0$ evaluates true while $|x| < \\tau$ evaluates false; hence only the tolerance test safely avoids misclassifying $\\mathrm{NaN}$ as zero.\n\nE. An IEEE-aware predicate to treat subnormals as “effectively zero” without misclassifying nonzero normals is $\\mathrm{isfinite}(x) \\wedge \\left( x == 0.0 \\vee \\mathrm{isSubnormal}(x) \\right)$, using the standard’s classification functions.\n\nF. When an absolute tolerance is desired, a safe predicate is $\\mathrm{isfinite}(x) \\wedge |x| \\le \\tau$, with $\\tau$ selected relative to the computation’s scale; this treats all subnormals as zero whenever $\\tau \\ge 2^{-1022}$ in $\\mathrm{binary64}$ and does not misclassify $\\mathrm{NaN}$ as zero.", "solution": "The problem statement has been critically validated and found to be valid. It is scientifically grounded in the IEEE $754$ standard for floating-point arithmetic, well-posed, and expressed in objective, formal language. All provided facts about the $\\mathrm{binary64}$ format, including the values for the minimum normal and subnormal numbers, and the behavior of signed zeros and $\\mathrm{NaNs}$, are correct. The scenario presented—differentiating true zero from results of catastrophic cancellation—is a classic problem in numerical computation. We may therefore proceed with a full analysis.\n\nThe task is to evaluate a set of statements about two methods for testing if a floating-point number, $x$, is \"effectively zero.\" The number $x$ is a finite result of a subtraction of two nearly equal normal numbers. The two tests are strict equality, $x == 0.0$, and an absolute tolerance test, $|x| < \\tau$ for some positive tolerance $\\tau$.\n\nAn analysis of each statement follows:\n\nA. The predicate $x == 0.0$ is true exactly when $x$ is $+0.0$ or $-0.0$, and it is false for any nonzero subnormal $x$; therefore it does not treat nonzero underflow results as zero.\n\nThis statement is a correct description of the IEEE $754$ equality operator. The standard specifies that the comparison $x == y$ is true if and only if $x$ and $y$ are numerically equal. The values $+0.0$ and $-0.0$ are defined to be numerically equal, so $(+0.0) == (-0.0)$ is true, and $x == 0.0$ correctly evaluates to true for both signed zeros. A subnormal number is a specific class of nonzero floating-point number with a magnitude smaller than the minimum positive normal number. Since a subnormal number is, by definition, nonzero, the comparison $x == 0.0$ will be false if $x$ is any subnormal number. Consequently, this test distinguishes between true zero and any nonzero result, including those that have underflowed to the subnormal range. The statement is accurate in its entirety.\n\n**Verdict: Correct.**\n\nB. For a fixed absolute tolerance $\\tau$, the predicate $|x| < \\tau$ will be true for all subnormals whenever $\\tau \\ge 2^{-1022}$ in $\\mathrm{binary64}$, but it may also classify some small normal values as “effectively zero” if $\\tau$ is chosen too large relative to the problem’s scale.\n\nLet's analyze the number ranges. The minimum positive normal number in $\\mathrm{binary64}$ is $N_{min} = 2^{-1022}$. Nonzero subnormal numbers have magnitudes $|x_s|$ in the range $[2^{-1074}, S_{max}]$, where the maximum subnormal magnitude $S_{max}$ is strictly less than $N_{min}$. Specifically, $S_{max} = (1 - 2^{-52}) \\times 2^{-1022} < 2^{-1022}$.\nIf we choose a tolerance $\\tau$ such that $\\tau \\ge 2^{-1022}$, then for any subnormal number $x_s$, its magnitude satisfies $|x_s| < 2^{-1022} \\le \\tau$. This implies that $|x_s| < \\tau$ is always true for any subnormal number. The first part of the statement is correct.\nFor the second part, if $\\tau$ is chosen to be larger than $N_{min}$, for example, $\\tau = 2^{-1021}$, then normal numbers $x$ with magnitudes in the range $[2^{-1022}, 2^{-1021})$ will satisfy the condition $|x| < \\tau$. For instance, the minimum positive normal $N_{min} = 2^{-1022}$ would be classified as effectively zero. Thus, choosing $\\tau$ too large can indeed classify small normal values as zero. The statement is entirely correct.\n\n**Verdict: Correct.**\n\nC. Because $+0.0$ and $-0.0$ compare unequal under IEEE $754$, a robust equality check for zero must explicitly test both $x == +0.0$ and $x == -0.0$.\n\nThis statement is founded on a false premise. The problem explicitly provides as a fact that \"Signed zeros $+0.0$ and $-0.0$ compare equal under the standard’s numerical equality.\" Therefore, the condition $(+0.0) == (-0.0)$ evaluates to true. The premise of statement C is in direct contradiction with the IEEE $754$ standard. Consequently, the conclusion that one must test for both signed zeros explicitly is also false; a single test $x == 0.0$ is sufficient.\n\n**Verdict: Incorrect.**\n\nD. If $x$ is $\\mathrm{NaN}$, then $x == 0.0$ evaluates true while $|x| < \\tau$ evaluates false; hence only the tolerance test safely avoids misclassifying $\\mathrm{NaN}$ as zero.\n\nThis statement contains multiple incorrect claims. First, a fundamental property of $\\mathrm{NaN}$ (Not a Number) under IEEE $754$ is that any ordered comparison involving a $\\mathrm{NaN}$ operand, including equality ($==$), yields false. Thus, if $x$ is $\\mathrm{NaN}$, the expression $x == 0.0$ evaluates to false, not true.\nThe second part of the clause claims $|x| < \\tau$ evaluates false. This is correct: $|\\mathrm{NaN}|$ evaluates to $\\mathrm{NaN}$, and the comparison $\\mathrm{NaN} < \\tau$ is false.\nHowever, the conclusion \"hence only the tolerance test safely avoids misclassifying $\\mathrm{NaN}$ as zero\" is incorrect because it is based on the false assertion that the strict equality test fails. In reality, both tests correctly evaluate to false when $x$ is $\\mathrm{NaN}$, thereby avoiding its misclassification as zero. The flawed premise makes the entire statement incorrect.\n\n**Verdict: Incorrect.**\n\nE. An IEEE-aware predicate to treat subnormals as “effectively zero” without misclassifying nonzero normals is $\\mathrm{isfinite}(x) \\wedge \\left( x == 0.0 \\vee \\mathrm{isSubnormal}(x) \\right)$, using the standard’s classification functions.\n\nLet's evaluate the behavior of this logical predicate for all classes of floating-point values:\n- If $x$ is $+0.0$ or $-0.0$: $\\mathrm{isfinite}(x)$ is true, and $x == 0.0$ is true. The expression evaluates to true.\n- If $x$ is a subnormal number: $\\mathrm{isfinite}(x)$ is true, and $\\mathrm{isSubnormal}(x)$ is true. The expression evaluates to true.\n- If $x$ is a normal number (nonzero): $\\mathrm{isfinite}(x)$ is true, but both $x == 0.0$ and $\\mathrm{isSubnormal}(x)$ are false. The expression evaluates to false.\n- If $x$ is an infinity ($\\pm\\infty$): $\\mathrm{isfinite}(x)$ is false. The expression evaluates to false.\n- If $x$ is a $\\mathrm{NaN}$: $\\mathrm{isfinite}(x)$ is false. The expression evaluates to false.\nThe predicate precisely identifies the set of values comprising true zeros and all subnormal numbers, while correctly excluding all normal numbers, infinities, and $\\mathrm{NaNs}$. The statement's description of the predicate's function is perfectly accurate.\n\n**Verdict: Correct.**\n\nF. When an absolute tolerance is desired, a safe predicate is $\\mathrm{isfinite}(x) \\wedge |x| \\le \\tau$, with $\\tau$ selected relative to the computation’s scale; this treats all subnormals as zero whenever $\\tau \\ge 2^{-1022}$ in $\\mathrm{binary64}$ and does not misclassify $\\mathrm{NaN}$ as zero.\n\nThis statement describes a robust implementation of an absolute tolerance test.\n- The use of $\\mathrm{isfinite}(x)$ ensures safety against non-finite inputs. If $x$ is $\\mathrm{NaN}$ or infinity, $\\mathrm{isfinite}(x)$ is false, causing the entire predicate to be false. Thus, it correctly \"does not misclassify $\\mathrm{NaN}$ as zero.\"\n- The condition \"treats all subnormals as zero whenever $\\tau \\ge 2^{-1022}$\" is correct. As established in the analysis of option B, the magnitude of any subnormal number $|x_s|$ is strictly less than $2^{-1022}$. If $\\tau \\ge 2^{-1022}$, then $|x_s| < 2^{-1022} \\le \\tau$, which implies $|x_s| \\le \\tau$ is true.\n- The advice to select $\\tau$ \"relative to the computation's scale\" is standard best practice for applying tolerance-based comparisons.\nThe statement makes a series of claims about the behavior and proper use of the given predicate, and each of these claims is factually correct. Note that this predicate, with $\\tau = 2^{-1022}$, will classify the smallest normal number $2^{-1022}$ as zero because $|2^{-1022}| \\le 2^{-1022}$ is true. This is a different behavior from the predicate in E, but the description given in statement F is nonetheless accurate.\n\n**Verdict: Correct.**", "answer": "$$\\boxed{ABEF}$$", "id": "3648780"}, {"introduction": "Having explored the conceptual differences between various special values, we now move to a hands-on calculation demonstrating how they are created. This exercise focuses on signed zero, a feature of the IEEE 754 standard that preserves the sign of an infinitesimal result that underflows to zero. You will construct a scenario where the subtraction of two nearly identical numbers, when rounded to a lower precision, produces both $+0$ and $-0$, revealing the tangible impact of the sign bit on subsequent operations like division [@problem_id:3648797].", "problem": "A processor implements arithmetic according to the Institute of Electrical and Electronics Engineers (IEEE) 754 floating-point standard. In this implementation, subtraction is performed in binary64 precision (commonly called double precision), and then the result is rounded and stored in binary16 precision (commonly called half precision). The rounding mode is round-toward-zero.\n\nLet $b = 1$ be represented exactly in binary64. Let $a$ be the next representable binary64 number greater than $1$, that is, $a = \\operatorname{nextUp}_{64}(1)$. Consider the two subtractions computed exactly in binary64 and then rounded to binary16 under round-toward-zero:\n- $r_{1} = \\operatorname{round}_{16}(a - b)$,\n- $r_{2} = \\operatorname{round}_{16}(b - a)$,\nwhere $\\operatorname{round}_{16}(\\cdot)$ denotes rounding the exact real result to the nearest representable binary16 value using round-toward-zero.\n\nYou may use only the following fundamental facts and core definitions of IEEE 754:\n- A binary $p$-precision significand has $p-1$ fraction bits with an implicit leading $1$ for normal numbers; in binary64, $p = 53$, so the spacing at $1$ is $2^{-(p-1)}$.\n- The smallest positive subnormal in binary16 has value $2^{1-\\beta} \\cdot 2^{-(p_{16}-1)}$, where $p_{16} = 11$ and the bias $\\beta = 15$.\n- Under round-toward-zero, any nonzero exact result with magnitude strictly less than the smallest positive subnormal rounds to signed zero with the sign of the exact result.\n- Signed zeros propagate their sign bit: the sign bit of a rounded zero equals the sign of the exact result under round-toward-zero.\n- In IEEE 754 comparisons, $+0$ and $-0$ compare equal, and division by signed zero produces signed infinities with $\\frac{1}{+0} = +\\infty$ and $\\frac{1}{-0} = -\\infty$.\n\nDefine the indicator $I(\\cdot)$ to be $1$ if its logical condition is true and $0$ otherwise, and define the sign-bit function $\\operatorname{sb}(x)$ to be $1$ if $x$ has a $1$ sign bit (including $-0$) and $0$ otherwise. Consider the following branch-sensitive code outcomes encoded into the integer\n$$\nE \\;=\\; 100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2}) < 0\\big) \\;+\\; I(r_{1} = r_{2}).\n$$\n\nStarting from the fundamental facts listed above, justify the sign propagation into $r_{1}$ and $r_{2}$ and the comparison outcomes that appear in $E$, and then compute the value of $E$. Your final answer must be a single real-valued number. No rounding instruction is needed for this answer.", "solution": "The problem statement will first be validated to ensure it is scientifically grounded, self-contained, and well-posed.\n\n### Step 1: Extract Givens\nThe problem provides the following data and definitions:\n- **Arithmetic Context**: IEEE 754 standard, with subtraction in binary64 precision and subsequent rounding to binary16 precision.\n- **Rounding Mode**: Round-toward-zero.\n- **Initial Values**:\n    - $b = 1$, represented exactly in binary64.\n    - $a = \\operatorname{nextUp}_{64}(1)$, the next representable binary64 number greater than $1$.\n- **Computed Values**:\n    - $r_{1} = \\operatorname{round}_{16}(a - b)$\n    - $r_{2} = \\operatorname{round}_{16}(b - a)$\n- **IEEE 754 Definitions**:\n    - For a normal number in a binary $p$-precision format, the significand has $p-1$ fraction bits with an implicit leading $1$.\n    - For binary64, precision $p = 53$. The spacing (unit in the last place, ulp) at $1$ is $2^{-(p-1)}$.\n    - For binary16, precision $p_{16} = 11$ and bias $\\beta = 15$.\n    - The smallest positive subnormal number in binary16 is $2^{1-\\beta} \\cdot 2^{-(p_{16}-1)}$.\n    - **Rounding Rule**: For round-toward-zero, any non-zero exact result with magnitude strictly less than the smallest positive subnormal rounds to a signed zero, with the sign of the exact result.\n    - **Signed Zero Propagation**: The sign bit of a rounded zero equals the sign of the exact result under round-toward-zero.\n    - **Comparisons**: $+0$ and $-0$ compare as equal.\n    - **Division by Zero**: $\\frac{1}{+0} = +\\infty$ and $\\frac{1}{-0} = -\\infty$.\n- **Helper Functions**:\n    - Indicator function $I(\\cdot)$ is $1$ if its condition is true, $0$ otherwise.\n    - Sign-bit function $\\operatorname{sb}(x)$ is $1$ if $x$ has a $1$ sign bit (i.e., is negative, including $-0$), and $0$ otherwise.\n- **Expression to Evaluate**:\n    - $E \\;=\\; 100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2}) < 0\\big) \\;+\\; I(r_{1} = r_{2})$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the specified criteria.\n- **Scientifically Grounded**: The problem is based entirely on the formal definitions and properties of the IEEE 754 floating-point standard, a cornerstone of computer organization and architecture. All provided facts are correct aspects of the standard.\n- **Well-Posed**: The problem is clearly defined. The inputs ($a$, $b$), operations (subtraction, rounding), and rules (rounding mode, properties of special values) are specified precisely, leading to a unique, determinable result for $E$.\n- **Objective**: The language is formal and unambiguous. The definitions for `round_16`, `sb`, and `I` are explicit.\nThe problem is free of any scientific unsoundness, incompleteness, or ambiguity. It is a formal, tractable problem within its specified domain.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete solution will now be derived.\n\n### Solution Derivation\n\nThe solution requires computing the values of $r_1$ and $r_2$, and then using them to evaluate the expression for $E$.\n\n**1. Determine the exact values of the subtractions**\n\nThe value $b=1$ is a power of $2$ and is represented exactly in binary64. Its representation is $1.0 \\times 2^0$.\nThe value $a = \\operatorname{nextUp}_{64}(1)$ is the smallest representable binary64 number greater than $1$. The gap between representable numbers around $1$ is the unit in the last place (ulp). The problem states the spacing at $1$ for a binary format with precision $p$ is $2^{-(p-1)}$. For binary64, $p=53$.\nThus, the spacing is $2^{-(53-1)} = 2^{-52}$.\nThis quantity is the machine epsilon for binary64, $\\epsilon_{64}$.\nSo, $a = 1 + 2^{-52}$.\n\nThe exact result of the first subtraction, $a-b$, is:\n$$ x_1 = a - b = (1 + 2^{-52}) - 1 = 2^{-52} $$\nThe exact result is a small positive number.\n\nThe exact result of the second subtraction, $b-a$, is:\n$$ x_2 = b - a = 1 - (1 + 2^{-52}) = -2^{-52} $$\nThe exact result is a small negative number.\n\n**2. Determine the rounding behavior**\n\nThe results $x_1$ and $x_2$ are computed in binary64 and then rounded to binary16 using the round-toward-zero mode. The problem states that if the magnitude of an exact result is strictly less than the smallest positive subnormal number, it rounds to a signed zero.\n\nFirst, we must calculate the value of the smallest positive subnormal number in binary16, which we denote as $s_{min,16}$. According to the provided formula, with $p_{16} = 11$ and bias $\\beta = 15$:\n$$ s_{min,16} = 2^{1-\\beta} \\cdot 2^{-(p_{16}-1)} = 2^{1-15} \\cdot 2^{-(11-1)} = 2^{-14} \\cdot 2^{-10} = 2^{-24} $$\n\nNow, we compare the magnitudes of $x_1$ and $x_2$ to $s_{min,16}$:\n$$ |x_1| = |2^{-52}| = 2^{-52} $$\n$$ |x_2| = |-2^{-52}| = 2^{-52} $$\nSince $52 > 24$, it follows that $2^{-52} < 2^{-24}$. Therefore, the magnitudes of both $x_1$ and $x_2$ are strictly less than $s_{min,16}$.\n\nAccording to the given rounding rule for round-toward-zero, both $x_1$ and $x_2$ will underflow and be rounded to signed zero. The sign is preserved from the exact result.\n\nFor $r_1$: The exact result is $x_1 = 2^{-52}$, which is positive.\n$$ r_1 = \\operatorname{round}_{16}(2^{-52}) = +0 $$\n\nFor $r_2$: The exact result is $x_2 = -2^{-52}$, which is negative.\n$$ r_2 = \\operatorname{round}_{16}(-2^{-52}) = -0 $$\n\n**3. Evaluate the expression for E**\n\nThe expression for $E$ is $100 \\cdot \\operatorname{sb}(r_{1}) \\;+\\; 10 \\cdot I\\!\\big((1/r_{2}) < 0\\big) \\;+\\; I(r_{1} = r_{2})$. We evaluate each term.\n\n- **Term 1: $100 \\cdot \\operatorname{sb}(r_{1})$**\nThe function $\\operatorname{sb}(x)$ is $1$ if the sign bit of $x$ is $1$ (negative), and $0$ otherwise. We have $r_1 = +0$. The sign bit of $+0$ is $0$.\nTherefore, $\\operatorname{sb}(r_{1}) = \\operatorname{sb}(+0) = 0$.\nThe value of the first term is $100 \\cdot 0 = 0$.\n\n- **Term 2: $10 \\cdot I\\!\\big((1/r_{2}) < 0\\big)$**\nWe have $r_2 = -0$. The problem provides the rule for division by signed zero: $\\frac{1}{-0} = -\\infty$.\nThe condition inside the indicator function is $(1/r_2) < 0$, which becomes $-\\infty < 0$. This inequality is true.\nSince the condition is true, the indicator function $I(\\cdot)$ evaluates to $1$.\nThe value of the second term is $10 \\cdot 1 = 10$.\n\n- **Term 3: $I(r_{1} = r_{2})$**\nWe need to evaluate the comparison $r_1 = r_2$. We have $r_1 = +0$ and $r_2 = -0$.\nThe problem states that in IEEE 754 comparisons, $+0$ and $-0$ compare as equal. So, the condition $r_1 = r_2$ is true.\nSince the condition is true, the indicator function $I(\\cdot)$ evaluates to $1$.\nThe value of the third term is $1$.\n\n**4. Compute the final value of E**\n\nSumming the values of the three terms:\n$$ E = 0 + 10 + 1 = 11 $$\nThe final value of the integer expression $E$ is $11$.", "answer": "$$\n\\boxed{11}\n$$", "id": "3648797"}, {"introduction": "Underflow does not always result in a value being flushed to zero. The IEEE 754 standard features a powerful mechanism called \"gradual underflow\" that uses subnormal numbers to represent values between zero and the smallest positive normal number, preventing an abrupt loss of precision. This final practice guides you through the construction of a specific arithmetic case where the result of a subtraction is too small to be a normal number but is perfectly represented as a non-zero subnormal, offering a clear illustration of how the standard preserves information at the limits of its range [@problem_id:3648788].", "problem": "You are working under the Institute of Electrical and Electronics Engineers (IEEE) $754$ binary$32$ format with round-to-nearest, ties-to-even, gradual underflow enabled, and the default rule that tininess is detected after rounding. The binary$32$ format has a $1$-bit sign, an $8$-bit biased exponent, and a $23$-bit fraction. A normalized positive value has the form $1.f \\times 2^{e}$, with exponent $e \\in \\{-126, \\ldots, 127\\}$ and unit-in-the-last-place (ULP) at exponent $e$ equal to $2^{e-23}$. Subnormal positive values have the form $m \\times 2^{-149}$ with integer $m \\in \\{1,2,\\ldots,2^{23}-1\\}$. The smallest positive normal is $2^{-126}$ and the smallest positive subnormal is $2^{-149}$.\n\nYour goal is to construct a reproducible test from first principles that guarantees a pair of operands whose sum is an exact normalized result while their difference produces a nonzero subnormal result, and then to analyze exception flag behavior under the IEEE $754$ rules.\n\n- Define two target binary$32$ values by their exact real values:\n  - $x_{\\mathrm{fp}} = \\left(2^{23} + 4\\right)\\,2^{-149}$,\n  - $y_{\\mathrm{fp}} = \\left(2^{23} + 2\\right)\\,2^{-149}$.\n  Let $U = 2^{-149}$ denote the ULP at exponent $-126$.\n\n- Inputs are real numbers $x$ and $y$ that are first rounded to binary$32$ before any arithmetic is performed. Under round-to-nearest, ties-to-even, a real $r$ rounds to the unique floating-point value $n\\,U$ whose integer index $n$ satisfies $r \\in \\left[n - \\tfrac{1}{2},\\, n + \\tfrac{1}{2}\\right]\\,U$, with midpoints going to the even $n$.\n\nTasks:\n- Provide explicit nonempty real intervals $I_x$ and $I_y$ such that any $x \\in I_x$ rounds to $x_{\\mathrm{fp}}$ and any $y \\in I_y$ rounds to $y_{\\mathrm{fp}}$ in binary$32$ under round-to-nearest, ties-to-even. Express the endpoints of $I_x$ and $I_y$ in terms of $U$ and integer indices, and justify why ties map to the intended even-index values.\n- Using only the core IEEE $754$ definitions above, argue that for any such $x \\in I_x$ and $y \\in I_y$ the binary$32$ addition $x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$ is an exact normalized result, while the binary$32$ subtraction $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ is a nonzero subnormal result. Then, determine which of the five IEEE $754$ status flags (invalid, divide-by-zero, overflow, underflow, inexact) are raised by each operation under the “tininess after rounding” rule, and explain how gradual underflow manifests in this test.\n- Finally, compute the exact real value of $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ and present it in the simplest exact power-of-two form.\n\nYour final answer must be a single exact expression with no units.", "solution": "The problem statement is subjected to validation before proceeding to a solution.\n\n**Step 1: Extract Givens**\n- Standard: IEEE $754$ binary$32$ format.\n- Format details: $1$-bit sign, $8$-bit biased exponent, $23$-bit fraction.\n- Rounding mode: Round-to-nearest, ties-to-even.\n- Underflow handling: Gradual underflow enabled.\n- Tininess detection: Detected after rounding.\n- Normalized positive value: $1.f \\times 2^{e}$, with exponent $e \\in \\{-126, \\ldots, 127\\}$.\n- Unit in the last place (ULP) at exponent $e$: $2^{e-23}$.\n- Subnormal positive value: $m \\times 2^{-149}$ with integer $m \\in \\{1, 2, \\ldots, 2^{23}-1\\}$.\n- Smallest positive normal: $N_{min} = 2^{-126}$.\n- Smallest positive subnormal: $S_{min} = 2^{-149}$.\n- Target value $x_{\\mathrm{fp}} = \\left(2^{23} + 4\\right)\\,2^{-149}$.\n- Target value $y_{\\mathrm{fp}} = \\left(2^{23} + 2\\right)\\,2^{-149}$.\n- Definition of spacing unit: $U = 2^{-149}$, stated as the ULP at exponent $-126$.\n- Rounding rule stated for real $r$: $r$ rounds to $n\\,U$ if $r \\in \\left[n - \\tfrac{1}{2},\\, n + \\tfrac{1}{2}\\right]\\,U$, with midpoints rounding to the number with the even integer index $n$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is well-grounded in the IEEE $754$ standard for floating-point arithmetic, a fundamental topic in computer science and engineering. All definitions provided are consistent with the standard.\n- **Well-Posedness and Consistency**: The problem provides a complete set of specifications. Let's verify internal consistency. The ULP at exponent $e=-126$ is indeed $2^{-126-23} = 2^{-149}$, matching the given definition of $U$. The smallest normal number is $N_{min} = 1.0 \\times 2^{-126} = 2^{23} \\times 2^{-23} \\times 2^{-126} = 2^{23} \\times 2^{-149} = 2^{23}U$. The values $x_{\\mathrm{fp}} = (2^{23}+4)U$ and $y_{\\mathrm{fp}}=(2^{23}+2)U$ are slightly larger than $N_{min}$ and are valid normalized numbers in the binary$32$ format with exponent $e=-126$. The rounding rule is correctly stated for \"round-to-nearest, ties-to-even\" in a region of constant spacing $U$. The problem is self-contained, consistent, and well-posed.\n- **Objectivity**: The problem is stated in precise, objective, and formal mathematical language.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Solution**\n\nThe problem asks for three tasks: defining rounding intervals, analyzing the sum and difference of two floating-point numbers, and computing the exact value of the difference.\n\n**Task 1: Rounding Intervals**\n\nWe need to find nonempty real intervals $I_x$ and $I_y$ such that any $x \\in I_x$ rounds to $x_{\\mathrm{fp}}$ and any $y \\in I_y$ rounds to $y_{\\mathrm{fp}}$. The unit of spacing in the region of interest is given as $U=2^{-149}$.\n\nThe target value $x_{\\mathrm{fp}}$ can be written as $n_x U$, where the integer index is $n_x = 2^{23} + 4$. Since $2^{23}$ is an even number, $n_x$ is even.\nThe target value $y_{\\mathrm{fp}}$ can be written as $n_y U$, where the integer index is $n_y = 2^{23} + 2$. Similarly, $n_y$ is even.\n\nAccording to the specified rounding rule, a real number $r$ rounds to the floating-point number $nU$ if it falls within the interval $\\left[\\left(n - \\frac{1}{2}\\right)U, \\left(n + \\frac{1}{2}\\right)U\\right]$. At the endpoints (midpoints or \"ties\"), the value is rounded to the neighbor with an even index $n$.\n\nFor $x_{\\mathrm{fp}}$, the index $n_x = 2^{23} + 4$ is even. Therefore, any real number in the closed interval centered at $x_{\\mathrm{fp}}$ will round to $x_{\\mathrm{fp}}$.\nThe lower bound of this interval is $\\left(n_x - \\frac{1}{2}\\right)U$, which is a tie between $(n_x-1)U$ and $n_xU$. Since $n_x$ is even, $n_x-1$ is odd, and the tie rounds to $n_xU$.\nThe upper bound is $\\left(n_x + \\frac{1}{2}\\right)U$, a tie between $n_xU$ and $(n_x+1)U$. Since $n_x$ is even, $n_x+1$ is odd, and the tie rounds to $n_xU$.\nThus, the interval $I_x$ is inclusive of its endpoints:\n$$I_x = \\left[\\left(2^{23} + 4 - \\frac{1}{2}\\right)U, \\left(2^{23} + 4 + \\frac{1}{2}\\right)U\\right] = \\left[\\left(2^{23} + \\frac{7}{2}\\right)U, \\left(2^{23} + \\frac{9}{2}\\right)U\\right]$$\n\nFor $y_{\\mathrm{fp}}$, the index $n_y = 2^{23} + 2$ is also even. The same logic applies. The rounding interval $I_y$ is:\n$$I_y = \\left[\\left(2^{23} + 2 - \\frac{1}{2}\\right)U, \\left(2^{23} + 2 + \\frac{1}{2}\\right)U\\right] = \\left[\\left(2^{23} + \\frac{3}{2}\\right)U, \\left(2^{23} + \\frac{5}{2}\\right)U\\right]$$\nBoth intervals are nonempty as required.\n\n**Task 2: Analysis of Sum and Difference Operations**\n\nFirst, we represent $x_{\\mathrm{fp}}$ and $y_{\\mathrm{fp}}$ in the standard binary$32$ form.\n$x_{\\mathrm{fp}} = (2^{23}+4)2^{-149} = 2^{-126} + 4 \\cdot 2^{-149} = 2^{-126} + 2^{-147} = 2^{-126}(1 + 2^{-21})$.\nThis is a normalized number with exponent $e = -126$ and a significand of $1 + 2^{-21}$. The $23$-bit fraction has a $1$ at the $21^{\\text{st}}$ position.\n\n$y_{\\mathrm{fp}} = (2^{23}+2)2^{-149} = 2^{-126} + 2 \\cdot 2^{-149} = 2^{-126} + 2^{-148} = 2^{-126}(1 + 2^{-22})$.\nThis is a normalized number with exponent $e = -126$ and a significand of $1 + 2^{-22}$. The $23$-bit fraction has a $1$ at the $22^{\\text{nd}}$ position.\n\n**Addition: $x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$**\nThe exponents are equal, so we add the significands and re-normalize.\nThe exact sum $S$ is:\n$$S = x_{\\mathrm{fp}} + y_{\\mathrm{fp}} = \\left( (1+2^{-21}) + (1+2^{-22}) \\right) \\times 2^{-126}$$\n$$S = (2 + 2 \\cdot 2^{-22} + 2^{-22}) \\times 2^{-126} = (2 + 3 \\cdot 2^{-22}) \\times 2^{-126}$$\nTo normalize, we factor out a $2$:\n$$S = (1 + 3 \\cdot 2^{-23}) \\times 2 \\times 2^{-126} = (1 + (2+1) \\cdot 2^{-23}) \\times 2^{-125} = (1 + 2^{-22} + 2^{-23}) \\times 2^{-125}$$\nThe result has an exponent $e = -125$, which is in the normalized range. The significand $1 + 2^{-22} + 2^{-23}$ is exactly representable using $23$ fraction bits (with $1$s at the $22^{\\text{nd}}$ and $23^{\\text{rd}}$ positions). Therefore, the mathematical sum $S$ is an exact binary$32$ floating-point number.\nThe operation $x_{\\mathrm{fp}} \\oplus y_{\\mathrm{fp}}$ returns this exact value without rounding.\n\n*Flag Analysis for Addition:*\n- **Invalid, Divide-by-zero, Overflow**: Not applicable.\n- **Inexact**: The result is exact, so the inexact flag is **not** raised.\n- **Underflow**: The result is a normal number, so the underflow flag is **not** raised.\nNo flags are raised for the addition.\n\n**Subtraction: $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$**\nThe exponents are equal, so we subtract the significands.\nThe exact difference $D$ is:\n$$D = x_{\\mathrm{fp}} - y_{\\mathrm{fp}} = \\left( (1+2^{-21}) - (1+2^{-22}) \\right) \\times 2^{-126}$$\n$$D = (2 \\cdot 2^{-22} - 2^{-22}) \\times 2^{-126} = 2^{-22} \\times 2^{-126} = 2^{-148}$$\nNow we must round this exact result $D$ to the binary$32$ format. The smallest positive normal number is $N_{min} = 2^{-126}$. Since $D = 2^{-148} < N_{min}$, the result, if representable, must be subnormal.\nSubnormal numbers have the form $m \\times 2^{-149}$ for integers $m \\in \\{1, \\ldots, 2^{23}-1\\}$.\nWe can write $D$ as:\n$$D = 2^{-148} = 2 \\times 2^{-149}$$\nThis corresponds to the subnormal form with $m=2$. Since $m=2$ is in the allowed range, $D=2 \\times 2^{-149}$ is an exactly representable subnormal number.\nThe operation $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ returns this exact value without rounding.\n\n*Flag Analysis for Subtraction:*\n- **Invalid, Divide-by-zero, Overflow**: Not applicable.\n- **Inexact**: The mathematical result is exactly representable, so the inexact flag is **not** raised.\n- **Underflow**: The underflow exception signals that a result is tiny. With tininess detected after rounding, we check if the final result's magnitude is less than $N_{min}$. The final result is $2^{-148}$, and $2^{-148} < 2^{-126}$. Therefore, the result is tiny. The IEEE $754$ standard specifies that the underflow flag is raised for any tiny, non-zero result that is delivered to the user (in the default, non-trapping mode, this may also require loss of accuracy, but the creation of a subnormal number is often flagged in itself as it implies a loss of available precision). The production of a subnormal number is the direct manifestation of gradual underflow. For a test designed to demonstrate this, it is standard to consider the underflow flag as being raised. This signals that the result has entered the subnormal range. Therefore, the underflow flag is **raised**.\n\n**Manifestation of Gradual Underflow**: The subtraction of two nearby normal numbers has resulted in a significant cancellation of leading bits. The exact result $2^{-148}$ is smaller than the smallest normal number. Instead of being flushed to zero, the result is represented as the subnormal number $2 \\times 2^{-149}$. This preserves two bits of the mantissa relative to the subnormal exponent, demonstrating a \"gradual\" loss of precision rather than an abrupt drop to zero, which is the purpose of the gradual underflow mechanism.\n\n**Task 3: Final Value of the Difference**\n\nThe final task is to compute the exact real value of the floating-point operation $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$. As determined above, the mathematical difference is $D = 2^{-148}$. This value is exactly representable as a subnormal binary$32$ number. Therefore, the computed result of the operation is identical to the mathematical result.\nThe exact real value of $x_{\\mathrm{fp}} \\ominus y_{\\mathrm{fp}}$ is $2^{-148}$.", "answer": "$$\\boxed{2^{-148}}$$", "id": "3648788"}]}