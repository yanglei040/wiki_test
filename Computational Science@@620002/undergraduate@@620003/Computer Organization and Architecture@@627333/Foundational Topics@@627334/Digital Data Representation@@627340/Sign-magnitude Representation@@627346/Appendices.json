{"hands_on_practices": [{"introduction": "One of the first challenges in digital design is allocating the right amount of resources for a given task. This exercise asks you to determine the minimum number of bits required to represent a specific range of integer values using the sign-magnitude format. Solving this problem correctly requires a clear understanding of how the sign bit and magnitude bits together define the representational capacity of a binary register. [@problem_id:1960341]", "problem": "A team of engineers is designing a simple digital data acquisition system for a physics experiment. The system needs to record a specific physical quantity that can fluctuate both positively and negatively around a zero-point. The values are integers ranging from -63 to +63, inclusive. The engineers decide to use the sign-magnitude representation to store these values in a binary register.\n\nIn the sign-magnitude number system, the Most Significant Bit (MSB), which is the leftmost bit, serves as the sign bit. A sign bit of 0 indicates a positive number or zero, while a sign bit of 1 indicates a negative number. The remaining bits in the register are used to represent the magnitude of the number as a standard unsigned binary integer.\n\nGiven that the register must be able to represent every integer value from -63 to +63, what is the minimum total number of bits required for this register?", "solution": "Let the register use one sign bit and $m$ magnitude bits. In sign-magnitude representation, the magnitude field is an unsigned binary integer ranging from $0$ to $2^{m}-1$. To represent all required absolute values $|x| \\in \\{0,1,\\dots,63\\}$, the magnitude must satisfy\n$$2^{m}-1 \\ge 63.$$\nThis is equivalent to\n$$2^{m} \\ge 64,$$\nso the minimal integer $m$ is\n$$m = \\lceil \\log_{2}(64) \\rceil = 6.$$\nIncluding the single sign bit, the total number of bits required is\n$$1 + m = 1 + 6 = 7.$$", "answer": "$$\\boxed{7}$$", "id": "1960341"}, {"introduction": "While storing numbers is one task, performing arithmetic on them is another, and sign-magnitude representation presents unique challenges. This problem simulates how a simple processor's Arithmetic Logic Unit (ALU) might handle addition, revealing how overflow can occur in the magnitude portion even when the mathematical result seems within range. This exercise highlights the special rules and potential pitfalls that make sign-magnitude arithmetic more complex than its two's complement counterpart. [@problem_id:1960327]", "problem": "A processor in a basic embedded control system operates on integers using a 5-bit sign-magnitude representation. In this format, the most significant bit (MSB) serves as the sign bit, where 0 indicates a positive number and 1 indicates a negative number. The remaining 4 bits represent the magnitude of the number. The system's Arithmetic Logic Unit (ALU) is designed to add two numbers, $A = -9$ and $B = -8$.\n\nThe ALU's procedure for adding two numbers of the same sign is as follows: it performs a binary addition of their 4-bit magnitudes using a 4-bit adder. The 4-bit result of this addition is stored as the magnitude of the final answer, and the sign bit of the result is the same as the sign of the two input numbers. An overflow flag is set to 1 if and only if a carry is generated from the most significant bit of the 4-bit magnitude addition; otherwise, the flag is 0.\n\nBased on this specific hardware implementation, which of the following options correctly describes the final 5-bit binary pattern stored in the result register and the state of the overflow flag?\n\nA. The pattern is `10001` and the overflow flag is set.\n\nB. The pattern is `10001` and the overflow flag is not set.\n\nC. The pattern is `110001` and the overflow flag is set.\n\nD. The pattern is `11111` and the overflow flag is not set.\n\nE. The pattern is `00001` and the overflow flag is set.", "solution": "In a 5-bit sign-magnitude system, a number is represented as $[s\\,m_{3}m_{2}m_{1}m_{0}]$ where $s$ is the sign bit and $m_{3}m_{2}m_{1}m_{0}$ is the 4-bit magnitude. For $A=-9$ and $B=-8$, the magnitudes are $9$ and $8$, whose 4-bit binary forms are $1001$ and $1000$, respectively. Thus,\n$$A = 1\\,1001,\\quad B = 1\\,1000.$$\nThe ALU rule for adding two numbers of the same sign is: add the 4-bit magnitudes with a 4-bit adder, store the 4-bit sum as the magnitude, keep the input sign as the result sign, and set the overflow flag if and only if there is a carry out from the most significant bit of the 4-bit addition.\n\nCompute the 4-bit magnitude sum:\n$$1001 + 1000 = 1\\,0001,$$\nwhere the leftmost $1$ is the carry out from the most significant bit of the 4-bit adder, and the 4-bit sum retained is $0001$.\n\nTherefore:\n- The magnitude stored is $0001$.\n- The sign bit of the result is $1$ (negative), matching the inputs.\n- The overflow flag is set to $1$ because a carry is generated from the most significant bit of the 4-bit magnitude addition.\n\nHence, the final 5-bit pattern is $1\\,0001$ and the overflow flag is set, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1960327"}, {"introduction": "This final practice is a capstone exercise where you will design a complete division algorithm from first principles. It synthesizes everything you have learned about sign-magnitude: decoding words into signs and magnitudes, handling special values like $+0$ and $-0$, applying rules for determining the result's sign, and correctly encoding the final quotient and remainder. This task moves beyond simple calculation to the domain of algorithmic thinking, which is central to hardware and software engineering. [@problem_id:3676522]", "problem": "You are to implement an integer division procedure over fixed-width sign-magnitude representation suitable for hardware-level reasoning. Let the word width be $w = 8$ bits, where bit $b_{7}$ is the sign bit and bits $b_{6}\\dots b_{0}$ encode the magnitude. A word encodes a mathematical integer $v$ as follows: if the magnitude $m$ is zero, the word may encode either $+0$ or $-0$ (both must be treated as the same mathematical zero); otherwise the value is $v = (-1)^{s} \\cdot m$ where $s \\in \\{0,1\\}$ is the sign bit and $m \\in \\{1,2,\\dots,127\\}$ is the magnitude. The word value itself is an unsigned integer in $\\{0,1,\\dots,255\\}$ whose binary form matches the sign-magnitude layout.\n\nStarting from the definition of sign-magnitude representation and the fundamental existence and uniqueness properties of integer long division on nonnegative integers (that for any nonnegative integers $a$ and $b \\neq 0$ there exist unique integers $q$ and $r$ such that $a = qb + r$ and $0 \\le r  b$), derive and implement a division algorithm for sign-magnitude operands using only the following principles:\n- Operate on magnitudes with classical long division to determine the magnitudes of the quotient and remainder.\n- Ensure that the signed result $(q,r)$ satisfies the identity $x = y \\cdot q + r$ with $|r|  |y|$ whenever the divisor is nonzero, where $|\\cdot|$ is the magnitude and $x$ and $y$ are the mathematical integers represented by the input words.\n- Determine the sign of the quotient from the operand signs using parity of negativity (i.e., the quotient is positive if and only if the operand signs are equal).\n- Choose a consistent and justified convention for the remainder sign that makes the above identity hold with truncation toward zero.\n- Treat both $+0$ and $-0$ in the inputs as zero magnitudes. In all outputs, canonicalize zero so that the sign bit of a zero result is cleared to $0$.\n- Define behavior on division by zero explicitly: when the divisor’s magnitude is zero, produce a designated error indicator and choose deterministic output words for quotient and remainder consistent with your conventions.\n\nYour implementation must:\n- Accept no input and instead run a fixed test suite of sign-magnitude word pairs using $w = 8$ bits.\n- For each test case, produce three unsigned integers: the encoded quotient word, the encoded remainder word, and an error flag where $e \\in \\{0,1\\}$ denotes “no error” and $1$ denotes “division by zero.”\n- Aggregate the results for all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[q_{1},r_{1},e_{1},q_{2},r_{2},e_{2},\\dots]$ where $q_{i}$ and $r_{i}$ are the encoded result words and $e_{i} \\in \\{0,1\\}$ is the error flag.\n\nUse the following test suite. Each operand is given as its $8$-bit sign-magnitude encoded word interpreted as an unsigned integer in $\\{0,\\dots,255\\}$:\n- Test $1$: dividend $x = 25$, divisor $y = 6$.\n- Test $2$: dividend $x = 153$, divisor $y = 6$. (This encodes $-25$ divided by $+6$.)\n- Test $3$: dividend $x = 153$, divisor $y = 134$. (This encodes $-25$ divided by $-6$.)\n- Test $4$: dividend $x = 5$, divisor $y = 7$.\n- Test $5$: dividend $x = 133$, divisor $y = 7$. (This encodes $-5$ divided by $+7$.)\n- Test $6$: dividend $x = 0$, divisor $y = 135$. (This encodes $+0$ divided by $-7$.)\n- Test $7$: dividend $x = 128$, divisor $y = 7$. (This encodes $-0$ divided by $+7$.)\n- Test $8$: dividend $x = 13$, divisor $y = 0$. (Division by zero.)\n- Test $9$: dividend $x = 141$, divisor $y = 128$. (This encodes $-13$ divided by $-0$; division by zero.)\n- Test $10$: dividend $x = 152$, divisor $y = 6$. (This encodes $-24$ divided by $+6$.)\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of the test suite and with no spaces, for example [$q_{1},r_{1},e_{1},\\dots,q_{10},r_{10},e_{10}$].", "solution": "The problem statement is found to be valid as it is scientifically grounded in the principles of computer arithmetic, well-posed with sufficient and consistent constraints, and expressed in objective, formal language. We may therefore proceed with a solution.\n\n**1. Formalism of Sign-Magnitude Representation**\n\nAn $8$-bit word, which is an unsigned integer $W \\in \\{0, 1, \\dots, 255\\}$, represents a mathematical integer $v$. The most significant bit, $b_7$, is the sign bit $s$. The remaining $7$ bits, $b_6 \\dots b_0$, represent the magnitude $m$.\nThe sign bit $s$ is extracted as $s = \\lfloor W / 2^7 \\rfloor = (W \\gg 7)$.\nThe magnitude $m$ is extracted as $m = W \\pmod{2^7} = W \\ (2^7-1)$, where the bitwise AND mask is $0x7F$ in hexadecimal, equivalent to the decimal value $127$.\nThe mathematical integer value $v$ is given by $v = (-1)^s \\cdot m$.\nAccording to this definition, a magnitude of $m=0$ can be represented by two words: $W=0$ (for $s=0$, representing $+0$) and $W=128$ (for $s=1$, representing $-0$). Both are treated as the mathematical integer $0$. The magnitude can range from $m \\in \\{0, 1, \\dots, 127\\}$.\n\n**2. Derivation of the Division Algorithm**\n\nLet the dividend and divisor be represented by the mathematical integers $x$ and $y$, which are encoded as the words $W_x$ and $W_y$, respectively. Our goal is to find the quotient $q$ and remainder $r$ such that the fundamental division identity $x = y \\cdot q + r$ holds, with the constraint $|r|  |y|$. The division must truncate towards zero.\n\n**2.1. Handling Division by Zero**\n\nThe divisor $y$ is zero if and only if its magnitude, $m_y$, is zero. This occurs when the word $W_y$ is either $0$ ($+0$) or $128$ ($-0$). In this case, the division is undefined. The problem requires setting an error flag $e=1$ and producing deterministic output words for the quotient and remainder. A standard and logical choice is to output canonical zero for both. Thus, if $m_y=0$, the result is:\n- Error flag $e = 1$.\n- Quotient word $W_q = 0$.\n- Remainder word $W_r = 0$.\n\n**2.2. Division of Magnitudes**\n\nFor a non-zero divisor ($m_y \\neq 0$), the core operation is based on the Euclidean division theorem for non-negative integers. We operate on the magnitudes $m_x$ and $m_y$. The theorem guarantees the existence of unique non-negative integers $m_q$ (quotient magnitude) and $m_r$ (remainder magnitude) such that:\n$$m_x = m_y \\cdot m_q + m_r \\quad \\text{with} \\quad 0 \\le m_r  m_y$$\nThese are computed using standard integer division:\n- $m_q = \\lfloor m_x / m_y \\rfloor$\n- $m_r = m_x \\pmod{m_y}$\n\n**2.3. Determining the Sign of the Quotient**\n\nThe problem specifies that the quotient is positive if and only if the operand signs are equal. This corresponds to the exclusive OR (XOR) operation on the sign bits. Let $s_x$ and $s_y$ be the sign bits of the dividend and divisor, respectively. The sign bit of the quotient, $s_q$, is:\n$$s_q = s_x \\oplus s_y$$\nThe mathematical value of the quotient is $q = (-1)^{s_q} \\cdot m_q$. This definition corresponds to truncation towards zero. For example, if $x/y = -4.16$ in real arithmetic, truncating to zero gives $q=-4$.\n\n**2.4. Determining the Sign of the Remainder**\n\nThe sign of the remainder, $s_r$, must be chosen to satisfy the division identity $x = y \\cdot q + r$. Rearranging for $r$, we get:\n$$r = x - y \\cdot q$$\nSubstituting the sign-magnitude definitions:\n- $x = (-1)^{s_x} m_x$\n- $y = (-1)^{s_y} m_y$\n- $q = (-1)^{s_q} m_q = (-1)^{s_x \\oplus s_y} m_q$\n\nThe product $y \\cdot q$ is:\n$$y \\cdot q = ((-1)^{s_y} m_y) \\cdot ((-1)^{s_x \\oplus s_y} m_q) = (-1)^{s_y + (s_x \\oplus s_y)} (m_y \\cdot m_q)$$\nThe exponent $s_y + (s_x \\oplus s_y)$ simplifies to an expression with the same parity as $s_x$. For example, if $s_y=0$, the exponent is $s_x$. If $s_y=1$, the exponent is $1 + (s_x \\oplus 1)$. If $s_x=0$, this gives $1+1=2$ (even parity). If $s_x=1$, this gives $1+0=1$ (odd parity). In all cases, $(-1)^{s_y + (s_x \\oplus s_y)} = (-1)^{s_x}$.\nTherefore, $y \\cdot q = (-1)^{s_x} (m_y \\cdot m_q)$.\n\nNow, we substitute this back into the equation for $r$:\n$$r = (-1)^{s_x} m_x - (-1)^{s_x} (m_y \\cdot m_q)$$\n$$r = (-1)^{s_x} (m_x - m_y \\cdot m_q)$$\nFrom the division of magnitudes, we know $m_r = m_x - m_y \\cdot m_q$. Thus:\n$$r = (-1)^{s_x} m_r$$\nThis proves that the sign of the remainder must be the same as the sign of the dividend ($s_r = s_x$). This convention ensures the identity holds for division that truncates toward zero and also preserves the required property $|r|  |y|$ because $m_r  m_y$.\n\n**3. Algorithm Summary and Encoding**\n\nThe complete algorithm is as follows:\n1.  Decode inputs $W_x, W_y$ into signs ($s_x, s_y$) and magnitudes ($m_x, m_y$).\n2.  If $m_y = 0$, set $e=1$, $W_q=0$, $W_r=0$, and terminate.\n3.  If $m_y \\neq 0$, set $e=0$.\n4.  Compute $m_q = \\lfloor m_x / m_y \\rfloor$ and $m_r = m_x \\pmod{m_y}$.\n5.  Determine signs: $s_q = s_x \\oplus s_y$ and $s_r = s_x$.\n6.  Encode quotient: If $m_q=0$, $W_q=0$ (canonical zero). Otherwise, `W_q = (s_q  7) | m_q`.\n7.  Encode remainder: If $m_r=0$, $W_r=0$ (canonical zero). Otherwise, `W_r = (s_r  7) | m_r`.\n\nThis procedure is applied to each test case. For example, for Test 2 ($W_x=153$, $W_y=6$):\n- $x$: $s_x=1, m_x=25$ (value $-25$)\n- $y$: $s_y=0, m_y=6$ (value $+6$)\n- $e=0$.\n- $m_q = \\lfloor 25/6 \\rfloor = 4$. $m_r = 25 \\pmod 6 = 1$.\n- $s_q = 1 \\oplus 0 = 1$. $s_r = 1$.\n- $q$: value $-4$. $W_q = (1 \\ll 7) | 4 = 128 | 4 = 132$.\n- $r$: value $-1$. $W_r = (1 \\ll 7) | 1 = 128 | 1 = 129$.\n- Result: $(132, 129, 0)$.\n\nThis logic is implemented for the full test suite.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n#include complex.h\n#include threads.h\n#include stdatomic.h\n\n/**\n * @brief A structure to hold the parameters for a single test case.\n * Operands are the 8-bit sign-magnitude encoded words.\n */\ntypedef struct {\n    unsigned char x_word;\n    unsigned char y_word;\n} TestCase;\n\n/**\n * @brief Performs integer division on two 8-bit sign-magnitude numbers.\n *\n * @param x_word The 8-bit word for the dividend.\n * @param y_word The 8-bit word for the divisor.\n * @param q_word Pointer to store the resulting 8-bit quotient word.\n * @param r_word Pointer to store the resulting 8-bit remainder word.\n * @param error_flag Pointer to store the error flag (1 for div by zero, 0 otherwise).\n */\nvoid sign_magnitude_divide(unsigned char x_word, unsigned char y_word,\n                           unsigned char* q_word, unsigned char* r_word,\n                           int* error_flag) {\n    // 1. Decode operands into sign and magnitude\n    // The sign bit is bit 7. The magnitude is bits 6-0.\n    // The mask 0x7F is 127, or 0b01111111.\n    unsigned char s_x = (x_word  7)  1;\n    unsigned char m_x = x_word  0x7F;\n\n    unsigned char s_y = (y_word  7)  1;\n    unsigned char m_y = y_word  0x7F;\n\n    // 2. Handle division by zero\n    // A divisor is zero if its magnitude is zero. This covers both +0 and -0.\n    if (m_y == 0) {\n        *error_flag = 1;\n        *q_word = 0; // Per problem, produce a deterministic output. Canonical zero is chosen.\n        *r_word = 0;\n        return;\n    }\n\n    *error_flag = 0;\n\n    // 3. Perform division on magnitudes\n    unsigned char m_q = m_x / m_y;\n    unsigned char m_r = m_x % m_y;\n\n    // 4. Determine signs of quotient and remainder\n    // Quotient sign is positive iff operand signs are the same (XOR is 0).\n    unsigned char s_q = s_x ^ s_y;\n    // Remainder sign matches the dividend sign for truncation towards zero.\n    unsigned char s_r = s_x;\n\n    // 5. Encode results back into sign-magnitude words\n    // Canonicalize zero: if magnitude is 0, the word is 0, clearing the sign bit.\n    if (m_q == 0) {\n        *q_word = 0;\n    } else {\n        *q_word = (s_q  7) | m_q;\n    }\n\n    if (m_r == 0) {\n        *r_word = 0;\n    } else {\n        *r_word = (s_r  7) | m_r;\n    }\n}\n\nint main(void) {\n    // Define the fixed test suite from the problem statement.\n    TestCase test_cases[] = {\n        {25, 6},    // Test 1: +25 / +6\n        {153, 6},   // Test 2: -25 / +6\n        {153, 134}, // Test 3: -25 / -6\n        {5, 7},     // Test 4: +5 / +7\n        {133, 7},   // Test 5: -5 / +7\n        {0, 135},   // Test 6: +0 / -7\n        {128, 7},   // Test 7: -0 / +7\n        {13, 0},    // Test 8: +13 / +0 (Div by zero)\n        {141, 128}, // Test 9: -13 / -0 (Div by zero)\n        {152, 6}    // Test 10: -24 / +6\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    unsigned int all_results[num_cases * 3];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        unsigned char q_res, r_res;\n        int err_res;\n        sign_magnitude_divide(test_cases[i].x_word, test_cases[i].y_word, q_res, r_res, err_res);\n        all_results[3 * i + 0] = q_res;\n        all_results[3 * i + 1] = r_res;\n        all_results[3 * i + 2] = err_res;\n    }\n\n    // Print the results in the EXACT required format.\n    // Format: [q1,r1,e1,q2,r2,e2,...,qn,rn,en] with no spaces.\n    printf(\"[\");\n    for (int i = 0; i  num_cases * 3; ++i) {\n        printf(\"%u\", all_results[i]);\n        if (i  (num_cases * 3 - 1)) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3676522"}]}