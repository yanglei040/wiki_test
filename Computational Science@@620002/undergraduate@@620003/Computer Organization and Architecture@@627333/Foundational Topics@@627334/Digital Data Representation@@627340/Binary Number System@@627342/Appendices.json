{"hands_on_practices": [{"introduction": "This problem goes to the heart of data representation: determining the minimum number of bits required to uniquely identify every symbol in a given set. This exercise grounds the abstract concept of binary capacity in the practical context of character encoding, like the ubiquitous ASCII standard, and introduces crucial hardware considerations like byte alignment [@problem_id:3622814]. Understanding this principle is the first step toward designing efficient data structures and communication protocols.", "problem": "A computing system must encode a unified symbol set for a device-independent text and control interface. The symbol set consists of all characters defined by the American Standard Code for Information Interchange (ASCII) and an additional device-specific control set. The American Standard Code for Information Interchange (ASCII) defines $128$ distinct code points. The device-specific control set adds $24$ new, distinct control symbols to this unified symbol set. The system designer mandates a fixed-length binary code for each symbol, where each code word has exactly $b$ bits, and every symbol must be mapped injectively to a unique $b$-bit string.\n\nStarting from the fundamental definition that a fixed-length binary word of length $b$ over an alphabet of two symbols $\\{0,1\\}$ has $2^{b}$ distinct patterns, derive the minimal integer number of bits $b$ required to encode the unified symbol set. In your reasoning, justify the historical use of $7$ versus $8$ bits for text encoding and explain how hardware byte alignment in typical memory systems influences the choice of $b$. Provide the final answer as a single integer. No rounding is required, and no physical units are involved. Express only the minimal number of bits $b$ as your final answer.", "solution": "The problem requires the determination of the minimum integer number of bits, $b$, to uniquely encode a unified symbol set. The solution must be derived from fundamental principles of information theory and computer architecture.\n\nFirst, we must establish the total number of distinct symbols that require a unique binary representation. A binary word of length $b$ consists of a sequence of $b$ bits, where each bit can be one of two symbols, typically $\\{0, 1\\}$. The total number of distinct patterns or code words that can be formed with $b$ bits is given by the expression $2^b$. For a fixed-length encoding to be valid, every symbol in the set must be mapped injectively to a unique code word. This requires that the number of available code words is at least equal to the total number of symbols to be encoded. If we denote the total number of symbols by $N$, this condition is formally expressed by the inequality:\n$$2^b \\ge N$$\n\nThe problem specifies that the unified symbol set is composed of two subsets: the American Standard Code for Information Interchange (ASCII) symbol set and a device-specific control set.\n\nThe number of symbols in the ASCII set is given as $N_{ASCII} = 128$.\nThe number of additional, distinct symbols in the device-specific control set is given as $N_{device} = 24$.\n\nThe total number of symbols in the unified set, $N$, is the sum of the symbols in these two disjoint sets:\n$$N = N_{ASCII} + N_{device} = 128 + 24 = 152$$\n\nNow, we must find the minimal integer $b$ that satisfies the inequality $2^b \\ge 152$. We can solve this by testing successive integer powers of $2$:\nFor $b=1$, $2^1 = 2$\nFor $b=2$, $2^2 = 4$\nFor $b=3$, $2^3 = 8$\nFor $b=4$, $2^4 = 16$\nFor $b=5$, $2^5 = 32$\nFor $b=6$, $2^6 = 64$\nFor $b=7$, $2^7 = 128$. This is insufficient, as $128 < 152$.\nFor $b=8$, $2^8 = 256$. This is sufficient, as $256 \\ge 152$.\n\nThe smallest integer value of $b$ for which the inequality holds is $b=8$.\n\nAlternatively, we can solve the inequality $2^b \\ge N$ by taking the base-$2$ logarithm of both sides:\n$$b \\ge \\log_2(N)$$\nSubstituting $N=152$, we get:\n$$b \\ge \\log_2(152)$$\nWe know that $\\log_2(128) = 7$ and $\\log_2(256) = 8$. Since $128 < 152 < 256$, it follows that $7 < \\log_2(152) < 8$. As $b$ must be an integer, the smallest integer value for $b$ that satisfies this condition is $b=8$. This is equivalent to calculating the ceiling of the logarithm: $b = \\lceil \\log_2(152) \\rceil = 8$.\n\nThe problem also requests a justification for the historical use of $7$ versus $8$ bits for text encoding and the influence of hardware byte alignment.\n\nThe original ASCII standard used $7$ bits, providing $2^7 = 128$ code points. This was sufficient for the uppercase and lowercase English alphabet, numerals, punctuation, and a set of control characters. In systems of that era, data was often transmitted serially, and the $8$-th bit of a byte could be used as a parity bit for error detection, or it was simply set to $0$.\n\nThe transition to using a full $8$ bits for the character code itself, rather than just $7$ bits plus a parity bit, allowed for \"extended ASCII\". This extension provided an additional $128$ code points, for a total of $2^8 = 256$. These extra positions were used to encode symbols not present in the original ASCII, such as foreign language-specific letters (e.g., é, ä, ç), currency symbols, and block graphics characters. This $8$-bit encoding became dominant.\n\nThe influence of hardware byte alignment is a critical factor in system design. Modern computer memory and processors are almost universally designed to operate on data in units of bytes, where a byte is defined as $8$ bits. Memory is byte-addressable, meaning each byte has a unique memory address. Data buses are designed to transfer data in multiples of $8$ bits. Consequently, using a code length that is not a multiple of $8$ is highly inefficient. For example, storing a stream of $7$-bit characters in an $8$-bit byte-addressable memory would either waste one bit per byte or require complex bit-packing and unpacking operations (shifting and masking), which incurs significant computational overhead and complicates hardware and software design.\n\nFor this problem, the minimum required number of bits is mathematically determined to be $8$. This aligns perfectly with the hardware standard of the $8$-bit byte. Even if the symbol set had required, for example, $9$ bits (e.g., if $N=300$), a practical system design would almost certainly allocate $16$ bits (two bytes) per symbol to maintain byte alignment and the associated efficiencies in memory addressing and data handling. Therefore, the choice of $b=8$ is not only mathematically necessary to accommodate the $152$ symbols but is also the most practical and efficient choice from a computer architecture perspective.", "answer": "$$\\boxed{8}$$", "id": "3622814"}, {"introduction": "Processors perform arithmetic at lightning speed by leveraging clever tricks embedded in the binary system itself, rather than performing long multiplication or division as we do on paper. This problem explores the fundamental relationship between bitwise shift operations and integer arithmetic, revealing how simple left or right shifts can function as efficient multiplication or division by powers of two [@problem_id:3622840]. Mastering these equivalences is key to writing highly optimized code and understanding how compilers and hardware achieve peak performance.", "problem": "An $n$-bit register stores bit-vectors $\\langle b_{n-1}\\,b_{n-2}\\,\\dots\\,b_{1}\\,b_{0}\\rangle$ where $b_{i}\\in\\{0,1\\}$. Interpretations and shift operations are as follows:\n- Unsigned interpretation: the value is $\\sum_{i=0}^{n-1} b_i 2^i$.\n- Signed interpretation using two’s complement: the value is $-b_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} b_i 2^i$.\n- Logical left shift by $k$ bits, $\\operatorname{LSL}_k$, drops the top $k$ bits and appends $k$ zeros on the right.\n- Logical right shift by $k$ bits, $\\operatorname{LSR}_k$, drops the bottom $k$ bits and prepends $k$ zeros on the left.\n- Arithmetic right shift by $k$ bits, $\\operatorname{ASR}_k$, drops the bottom $k$ bits and replicates the original most significant bit on the left $k$ times.\n\nAssume $0 \\le k < n$. For concreteness, take $n=8$ for any numerical examples. Let $\\lfloor\\cdot\\rfloor$ denote the floor function and $\\lceil\\cdot\\rceil$ denote the ceiling function. Let $\\operatorname{trunc}(r)$ denote real $r$ truncated toward zero.\n\nSelect all options that are true.\n\nA. For any $n$-bit unsigned integer $x$ and any $k$ with $0 \\le k < n$, $\\operatorname{LSR}_k(x) = \\left\\lfloor x / 2^k \\right\\rfloor$.\n\nB. For any $n$-bit unsigned integer $x$ and any $k$ with $0 \\le k < n$, $\\operatorname{LSL}_k(x) = (x \\cdot 2^k) \\bmod 2^n$, and in particular $\\operatorname{LSL}_k(x) = x \\cdot 2^k$ if and only if the upper $k$ bits of $x$ are all zero.\n\nC. For any $n$-bit signed two’s complement integer $s$ and any $k$ with $0 \\le k < n$, $\\operatorname{ASR}_k(s) = \\left\\lfloor s / 2^k \\right\\rfloor$.\n\nD. For $n=8$ and unsigned $x=157$, one has $\\operatorname{LSL}_3(x) = 232$ and $\\operatorname{LSR}_3(x) = 19$.\n\nE. For $n=8$ and signed two’s complement $s=-75$, $\\operatorname{ASR}_2(s) = -18 = \\operatorname{trunc}(s/4)$.\n\nF. For any $n$-bit signed two’s complement integer $s$ and any $k$ with $0 \\le k < n$, if the lower $k$ bits of $s$ are all zero, then $\\operatorname{ASR}_k(s) = s / 2^k$ exactly (no rounding).", "solution": "The problem statement is validated as follows.\n\n**Step 1: Extract Givens**\n-   An $n$-bit register stores bit-vectors $\\langle b_{n-1}\\,b_{n-2}\\,\\dots\\,b_{1}\\,b_{0}\\rangle$ where $b_{i}\\in\\{0,1\\}$.\n-   Unsigned interpretation: the value is $\\sum_{i=0}^{n-1} b_i 2^i$.\n-   Signed interpretation using two’s complement: the value is $-b_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} b_i 2^i$.\n-   Logical left shift by $k$ bits, $\\operatorname{LSL}_k$, drops the top $k$ bits and appends $k$ zeros on the right.\n-   Logical right shift by $k$ bits, $\\operatorname{LSR}_k$, drops the bottom $k$ bits and prepends $k$ zeros on the left.\n-   Arithmetic right shift by $k$ bits, $\\operatorname{ASR}_k$, drops the bottom $k$ bits and replicates the original most significant bit on the left $k$ times.\n-   Assumption: $0 \\le k < n$.\n-   For numerical examples, $n=8$.\n-   Notation: $\\lfloor\\cdot\\rfloor$ for floor, $\\lceil\\cdot\\rceil$ for ceiling, $\\operatorname{trunc}(r)$ for truncation of real $r$ toward zero.\n-   The task is to select all true options.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is based on the standard definitions of binary number representations (unsigned, two's complement) and bitwise shift operations ($\\operatorname{LSL}$, $\\operatorname{LSR}$, $\\operatorname{ASR}$) used in computer organization and architecture. These are fundamental, well-established concepts. The problem is scientifically sound.\n-   **Well-Posed**: The problem provides clear definitions and asks for an evaluation of specific mathematical statements. Each statement can be proven true or false based on the givens. A unique solution (the set of true statements) exists.\n-   **Objective**: The problem is stated using precise mathematical language and definitions. There is no subjective or ambiguous terminology.\n-   **Complete and Consistent**: All necessary definitions for interpreting the bit-vectors and operations are provided. The constraints on variables like $n$ and $k$ are clear. There are no internal contradictions.\n-   **Realistic and Feasible**: The context of $n$-bit registers and the specified operations are standard in modern processors. The choice of $n=8$ is a common byte size. The problem is entirely realistic.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is scientifically sound, well-posed, objective, and complete. I will proceed with solving the problem and evaluating each option.\n\n**Option-by-Option Analysis**\n\n**A. For any $n$-bit unsigned integer $x$ and any $k$ with $0 \\le k < n$, $\\operatorname{LSR}_k(x) = \\left\\lfloor x / 2^k \\right\\rfloor$.**\nLet the unsigned integer $x$ be represented by the bit-vector $\\langle b_{n-1}\\,b_{n-2}\\,\\dots\\,b_{0}\\rangle$. Its value is $x = \\sum_{i=0}^{n-1} b_i 2^i$.\nDividing by $2^k$ gives:\n$$ \\frac{x}{2^k} = \\frac{1}{2^k} \\sum_{i=0}^{n-1} b_i 2^i = \\sum_{i=0}^{n-1} b_i 2^{i-k} = \\sum_{i=k}^{n-1} b_i 2^{i-k} + \\sum_{i=0}^{k-1} b_i 2^{i-k} $$\nThe first term, $\\sum_{i=k}^{n-1} b_i 2^{i-k}$, is an integer. The second term, $\\sum_{i=0}^{k-1} b_i 2^{i-k}$, is the fractional part, which is non-negative.\nTaking the floor of this expression eliminates the fractional part:\n$$ \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor = \\sum_{i=k}^{n-1} b_i 2^{i-k} $$\nLet's re-index the sum with $j = i-k$, so $i = j+k$. When $i=k$, $j=0$. When $i=n-1$, $j=n-1-k$.\n$$ \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor = \\sum_{j=0}^{n-1-k} b_{j+k} 2^j $$\nNow consider $\\operatorname{LSR}_k(x)$. The operation shifts the bits of $x$ to the right by $k$ positions, filling the newly opened most significant $k$ bits with zeros. The new bit-vector $\\langle b'_{n-1}\\,\\dots\\,b'_{0}\\rangle$ is defined by $b'_j = b_{j+k}$ for $0 \\le j \\leq n-1-k$, and $b'_j = 0$ for $n-k \\le j \\leq n-1$.\nThe value of the resulting unsigned integer is:\n$$ \\operatorname{LSR}_k(x) = \\sum_{j=0}^{n-1} b'_j 2^j = \\sum_{j=0}^{n-1-k} b_{j+k} 2^j + \\sum_{j=n-k}^{n-1} 0 \\cdot 2^j = \\sum_{j=0}^{n-1-k} b_{j+k} 2^j $$\nThe expressions for $\\operatorname{LSR}_k(x)$ and $\\lfloor x/2^k \\rfloor$ are identical.\nVerdict: **Correct**.\n\n**B. For any $n$-bit unsigned integer $x$ and any $k$ with $0 \\le k < n$, $\\operatorname{LSL}_k(x) = (x \\cdot 2^k) \\bmod 2^n$, and in particular $\\operatorname{LSL}_k(x) = x \\cdot 2^k$ if and only if the upper $k$ bits of $x$ are all zero.**\nLet $x = \\sum_{i=0}^{n-1} b_i 2^i$. Multiplication by $2^k$ gives:\n$$ x \\cdot 2^k = \\sum_{i=0}^{n-1} b_i 2^{i+k} = \\sum_{i=0}^{n-1-k} b_i 2^{i+k} + \\sum_{i=n-k}^{n-1} b_i 2^{i+k} $$\nThe operation $(x \\cdot 2^k) \\bmod 2^n$ keeps only the part of the sum with powers of $2$ less than $n$. The second term $\\sum_{i=n-k}^{n-1} b_i 2^{i+k}$ consists of terms where the exponent $i+k \\ge n$, so each term is a multiple of $2^n$. Thus, this sum is congruent to $0 \\pmod{2^n}$.\n$$ (x \\cdot 2^k) \\bmod 2^n = \\left( \\sum_{i=0}^{n-1-k} b_i 2^{i+k} \\right) \\bmod 2^n $$\nSince for any $i \\le n-1-k$, we have $i+k \\le n-1$, the sum is less than $2^n$. The modulo operation is redundant.\n$$ (x \\cdot 2^k) \\bmod 2^n = \\sum_{i=0}^{n-1-k} b_i 2^{i+k} $$\nNow consider $\\operatorname{LSL}_k(x)$. The bit-vector is shifted left by $k$, dropping the top $k$ bits and appending $k$ zeros. The new bit-vector $\\langle b'_{n-1}\\,\\dots\\,b'_{0}\\rangle$ is defined by $b'_j = b_{j-k}$ for $k \\le j \\le n-1$, and $b'_j=0$ for $0 \\le j \\le k-1$.\nThe value is:\n$$ \\operatorname{LSL}_k(x) = \\sum_{j=0}^{n-1} b'_j 2^j = \\sum_{j=k}^{n-1} b_{j-k} 2^j $$\nRe-indexing with $i=j-k$ (so $j=i+k$):\n$$ \\operatorname{LSL}_k(x) = \\sum_{i=0}^{n-1-k} b_{i} 2^{i+k} $$\nThis matches the expression for $(x \\cdot 2^k) \\bmod 2^n$. The first part of the statement is true.\nFor the second part, $\\operatorname{LSL}_k(x) = x \\cdot 2^k$ if and only if the \"overflow\" term is zero, i.e., $\\sum_{i=n-k}^{n-1} b_i 2^{i+k} = 0$. Since $b_i \\ge 0$, this requires $b_i=0$ for all $i$ from $n-k$ to $n-1$. These are precisely the top $k$ bits of $x$. So the second part is also true.\nVerdict: **Correct**.\n\n**C. For any $n$-bit signed two’s complement integer $s$ and any $k$ with $0 \\le k < n$, $\\operatorname{ASR}_k(s) = \\left\\lfloor s / 2^k \\right\\rfloor$.**\nLet $s$ be represented by $\\langle b_{n-1}\\,\\dots\\,b_{0}\\rangle$. Let $U = \\sum_{i=0}^{n-1} b_i 2^i$ be its unsigned value. The two's complement value is $s = U - b_{n-1} 2^n$.\nThe arithmetic right shift $\\operatorname{ASR}_k$ on $\\langle b_{n-1}\\,\\dots\\,b_{0}\\rangle$ produces a new bit-vector. The new unsigned value, $U'$, is obtained by shifting $U$ right by $k$ and filling the top $k$ bits with copies of $b_{n-1}$.\n$$ U' = \\lfloor U/2^k \\rfloor + b_{n-1} \\sum_{j=n-k}^{n-1} 2^j = \\lfloor U/2^k \\rfloor + b_{n-1}(2^n - 2^{n-k}) $$\nThe new MSB is $b_{n-1}$. The new signed value, $s'$, is $s' = U' - b_{n-1}2^n$.\n$$ s' = \\left( \\lfloor U/2^k \\rfloor + b_{n-1}(2^n - 2^{n-k}) \\right) - b_{n-1}2^n = \\lfloor U/2^k \\rfloor - b_{n-1}2^{n-k} $$\nWe want to check if $s' = \\lfloor s/2^k \\rfloor$.\n$$ \\left\\lfloor \\frac{s}{2^k} \\right\\rfloor = \\left\\lfloor \\frac{U - b_{n-1}2^n}{2^k} \\right\\rfloor = \\left\\lfloor \\frac{U}{2^k} - b_{n-1}2^{n-k} \\right\\rfloor $$\nSince $0 \\le k < n$, $n-k \\ge 1$, which means $2^{n-k}$ is an integer. For any real number $a$ and integer $m$, $\\lfloor a - m \\rfloor = \\lfloor a \\rfloor - m$. Let $a = U/2^k$ and $m = b_{n-1}2^{n-k}$.\n$$ \\left\\lfloor \\frac{s}{2^k} \\right\\rfloor = \\lfloor U/2^k \\rfloor - b_{n-1}2^{n-k} $$\nThis expression is identical to the one for $s'$. This holds for both positive ($b_{n-1}=0$) and negative ($b_{n-1}=1$) numbers.\nVerdict: **Correct**.\n\n**D. For $n=8$ and unsigned $x=157$, one has $\\operatorname{LSL}_3(x) = 232$ and $\\operatorname{LSR}_3(x) = 19$.**\nFirst, represent $x=157$ as an $8$-bit binary number.\n$157 = 128 + 29 = 128 + 16 + 8 + 4 + 1 = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0$.\nSo, $x = 10011101_2$.\n$\\operatorname{LSL}_3(x)$: Shift $10011101_2$ left by $3$ bits. The top $3$ bits ($100$) are discarded, and three $0$s are appended to the right. The result is $11101000_2$.\nThe decimal value is $1 \\cdot 2^7 + 1 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^3 = 128 + 64 + 32 + 8 = 232$. The first part is correct.\n$\\operatorname{LSR}_3(x)$: Shift $10011101_2$ right by $3$ bits. The bottom $3$ bits ($101$) are discarded, and three $0$s are prepended to the left. The result is $00010011_2$.\nThe decimal value is $1 \\cdot 2^4 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 16 + 2 + 1 = 19$. The second part is correct.\nSince both claims are correct, the entire statement is correct.\nVerdict: **Correct**.\n\n**E. For $n=8$ and signed two’s complement $s=-75$, $\\operatorname{ASR}_2(s) = -18 = \\operatorname{trunc}(s/4)$.**\nFirst, find the $8$-bit two's complement representation of $s=-75$. The representation of $+75$ is $64+8+2+1 = 01001011_2$. To find $-75$, we invert the bits and add $1$: $10110100_2 + 1 = 10110101_2$. So $s = 10110101_2$. The MSB is $1$.\n$\\operatorname{ASR}_2(s)$: Shift $10110101_2$ right by $2$ bits, replicating the MSB ($1$) twice on the left.\nOriginal: $\\langle 1,0,1,1,0,1,0,1 \\rangle$.\nShifted: $\\langle 1,1,1,0,1,1,0,1 \\rangle$. The bit-vector is $11101101_2$.\nThe value is $-1 \\cdot 2^7 + (1\\cdot 2^6+1\\cdot 2^5+0\\cdot 2^4+1\\cdot 2^3+1\\cdot 2^2+0\\cdot 2^1+1\\cdot 2^0) = -128 + (64+32+8+4+1) = -128 + 109 = -19$.\nSo, $\\operatorname{ASR}_2(-75) = -19$.\nThe statement claims $\\operatorname{ASR}_2(s) = -18$. This is false.\nLet's check the other parts of the statement.\n$\\operatorname{trunc}(s/4) = \\operatorname{trunc}(-75/4) = \\operatorname{trunc}(-18.75) = -18$. This equality is correct.\nHowever, the initial equality $\\operatorname{ASR}_2(s) = -18$ is false. The statement as a whole is therefore false.\nNote that based on option C, $\\operatorname{ASR}_2(s) = \\lfloor s/2^2 \\rfloor = \\lfloor -75/4 \\rfloor = \\lfloor -18.75 \\rfloor = -19$. This confirms our calculation. Arithmetic right shift corresponds to floor division, not truncation towards zero.\nVerdict: **Incorrect**.\n\n**F. For any $n$-bit signed two’s complement integer $s$ and any $k$ with $0 \\le k < n$, if the lower $k$ bits of $s$ are all zero, then $\\operatorname{ASR}_k(s) = s / 2^k$ exactly (no rounding).**\nThe condition \"lower $k$ bits of $s$ are all zero\" means that the bit representation $\\langle b_{n-1},\\dots,b_0 \\rangle$ has $b_i = 0$ for $0 \\le i \\le k-1$.\nThe value of $s$ is $s = -b_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} b_i 2^i$.\nWith the condition, the sum is over $i$ from $k$ to $n-2$: $s = -b_{n-1}2^{n-1} + \\sum_{i=k}^{n-2} b_i 2^i$.\nEvery term in the expression for $s$ contains a factor of at least $2^k$ (since $n-1 \\ge k$ and $i \\ge k$).\nTherefore, $s$ is an integer multiple of $2^k$.\nWhen $s$ is an integer multiple of $2^k$, the division $s / 2^k$ is exact, resulting in an integer.\nFor any integer $z$, $\\lfloor z \\rfloor = z$.\nSo, if $s/2^k$ is an integer, $\\lfloor s/2^k \\rfloor = s/2^k$.\nFrom option C, we know $\\operatorname{ASR}_k(s) = \\lfloor s/2^k \\rfloor$.\nSubstituting this, we get $\\operatorname{ASR}_k(s) = s/2^k$ exactly.\nVerdict: **Correct**.\n\nFinal Summary of Correct Options: A, B, C, D, F.", "answer": "$$\\boxed{ABCDF}$$", "id": "3622840"}, {"introduction": "Modern CPUs prize speed, and conditional branches can slow things down by disrupting the instruction pipeline. This challenge guides you through a classic \"bit-twiddling\" technique: computing the absolute value of a number using only bitwise and arithmetic operations, completely avoiding branches [@problem_id:3622812]. This practice demonstrates the profound power of two's complement representation, allowing you to encode complex conditional logic directly into a simple, lightning-fast sequence of mathematical steps.", "problem": "A Central Processing Unit (CPU) using a two’s complement binary number system and a fixed word size of $w$ bits supports bitwise exclusive OR (XOR), addition, subtraction, and arithmetic right shift. In two’s complement, the numeric value of a $w$-bit vector $x = x_{w-1} x_{w-2} \\dots x_{0}$ is given by $-x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$, where the Most Significant Bit (MSB) $x_{w-1}$ is the sign bit. An arithmetic right shift replicates $x_{w-1}$ in every vacated position.\n\n- Using only these fundamental definitions and operations, derive a mask $m(x)$ built from the sign bit such that $m(x)$ equals $0$ for non-negative $x$ and equals $-1$ (that is, all bits set to $1$ in two’s complement) for negative $x$.\n- From first principles, derive a branchless closed-form expression that computes the absolute value $\\mathrm{abs}(x)$ using only $\\oplus$, $+$ or $-$, and the mask $m(x)$; justify why it produces the correct result for all representable $x$ except possibly the extreme value $x = -2^{w-1}$.\n- Apply your derived expression in a $w=32$ bit setting to the signed integer $x$ whose two’s complement representation is the hexadecimal $0x\\mathrm{F0A3B7C9}$ and compute $\\mathrm{abs}(x)$. Express the final result as a base-$10$ integer. No rounding is required.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- The system is a Central Processing Unit (CPU) using a two’s complement binary number system.\n- The word size is fixed at $w$ bits.\n- Supported operations are bitwise exclusive OR (XOR, denoted as $\\oplus$), addition ($+$), subtraction ($-$), and arithmetic right shift.\n- The numeric value of a $w$-bit vector $x = x_{w-1} x_{w-2} \\dots x_{0}$ is given by the formula $\\mathrm{Value}(x) = -x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$.\n- The Most Significant Bit (MSB), $x_{w-1}$, is the sign bit.\n- An arithmetic right shift of $x$ by $k$ positions replicates the sign bit $x_{w-1}$ into the $k$ vacated positions.\n- **Task 1**: Derive a mask $m(x)$ such that $m(x)$ is the integer $0$ for non-negative $x$ (i.e., $x \\ge 0$) and the integer $-1$ for negative $x$ (i.e., $x < 0$). In two's complement, the integer $-1$ is represented by a bit vector where all bits are $1$.\n- **Task 2**: Derive a branchless closed-form expression for the absolute value, $\\mathrm{abs}(x)$, using only the operations $\\oplus$, $+$, $-$, and the mask $m(x)$. Justify its correctness for all representable values of $x$ except possibly the extreme value $x = -2^{w-1}$.\n- **Task 3**: Apply the derived expression in a $w=32$ bit setting to the signed integer $x$ whose two’s complement representation is the hexadecimal value $0x\\mathrm{F0A3B7C9}$. Compute $\\mathrm{abs}(x)$ and express the result as a base-$10$ integer.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientific Soundness**: The problem statement is based on standard, fundamental concepts in computer organization and architecture. The definitions for two's complement representation and arithmetic right shift are correct and widely used.\n- **Well-Posedness**: The tasks are clearly defined with explicit constraints on the allowed operations. The problem provides sufficient information to derive the required expressions and compute the final value. A unique solution is expected.\n- **Objectivity**: The problem is stated in precise, formal language, free from ambiguity or subjective elements.\n\nThe problem does not exhibit any flaws such as factual unsoundness, incompleteness, contradiction, or reliance on pseudoscience. All aspects are formalizable and verifiable within the principles of mathematics and computer science.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution Derivation\n\n**Part 1: Derivation of the Mask $m(x)$**\n\nThe problem requires a mask $m(x)$ that is selectively either $0$ or $-1$ based on the sign of $x$. In the two's complement system described, the sign of an integer $x$ is determined solely by its most significant bit (MSB), $x_{w-1}$.\n- If $x \\ge 0$, its sign bit is $x_{w-1} = 0$.\n- If $x < 0$, its sign bit is $x_{w-1} = 1$.\n\nWe need $m(x)$ to be a bit pattern of all zeros (representing the integer $0$) when $x_{w-1}=0$, and a bit pattern of all ones (representing the integer $-1$) when $x_{w-1}=1$.\n\nThe arithmetic right shift operation is defined to replicate the sign bit. Let's denote an arithmetic right shift by $k$ bits as $\\gg_a k$. When we perform an arithmetic right shift on $x$ by $w-1$ positions, the original $w-1$ least significant bits are shifted out. The MSB, $x_{w-1}$, is replicated to fill all $w-1$ vacated bit positions. The MSB itself remains $x_{w-1}$. Consequently, all $w$ bits of the resulting number become equal to the original sign bit, $x_{w-1}$.\n\nLet's analyze the result of the operation $x \\gg_a (w-1)$:\n- If $x \\ge 0$, then $x_{w-1} = 0$. The operation $x \\gg_a (w-1)$ produces a $w$-bit vector of all zeros. The numeric value of this vector is $0$.\n- If $x < 0$, then $x_{w-1} = 1$. The operation $x \\gg_a (w-1)$ produces a $w$-bit vector of all ones. In two's complement, a bit vector of all ones represents the integer $-1$.\n\nThis behavior precisely matches the requirements for the mask $m(x)$. Therefore, the mask can be expressed as:\n$$m(x) = x \\gg_a (w-1)$$\n\n**Part 2: Derivation and Justification of $\\mathrm{abs}(x)$**\n\nThe absolute value function is defined as:\n$$ \\mathrm{abs}(x) = \\begin{cases} x & \\text{if } x \\ge 0 \\\\ -x & \\text{if } x < 0 \\end{cases} $$\nWe need to construct a single, branchless expression that implements this logic using the allowed operations and the mask $m(x)$. In two's complement, the negation of a number $y$, $-y$, is computed as $(\\sim y) + 1$, where $\\sim y$ is the bitwise NOT of $y$. The bitwise NOT operation can be implemented using XOR, since for any bit $b$, $b \\oplus 1 = \\sim b$. A bitwise NOT on a $w$-bit number $y$ is thus equivalent to $y \\oplus (-1)$, because $-1$ is represented as a bit vector of all ones. Therefore, $-y = (y \\oplus (-1)) + 1$.\n\nLet's propose the following expression for $\\mathrm{abs}(x)$:\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) $$\n\nWe must justify this expression for both cases of $x$'s sign.\n\nCase 1: $x \\ge 0$.\nIn this case, $m(x) = 0$. Substituting this into the expression gives:\n$$ (x \\oplus 0) - 0 $$\nThe XOR operation $x \\oplus 0$ results in $x$. The expression simplifies to $x - 0 = x$. This is the correct result for a non-negative number.\n\nCase 2: $x < 0$.\nIn this case, $m(x) = -1$. Substituting this into the expression gives:\n$$ (x \\oplus (-1)) - (-1) = (x \\oplus (-1)) + 1 $$\nAs established earlier, the term $x \\oplus (-1)$ is the bitwise NOT of $x$ (i.e., $\\sim x$). The expression thus becomes $(\\sim x) + 1$, which is the standard formula for two's complement negation. The result is $-x$. This is the correct absolute value for a negative number.\n\nThus, the formula $\\mathrm{abs}(x)=(x \\oplus m(x)) - m(x)$ is correct for all values where the result is representable.\n\nJustification for the exception $x = -2^{w-1}$:\nThe range of representable integers for a $w$-bit two's complement system is $[-2^{w-1}, 2^{w-1}-1]$. For the minimum value $x = -2^{w-1}$, its mathematical absolute value is $|-2^{w-1}| = 2^{w-1}$, which is outside the representable range.\nLet's trace the execution of our formula for $x = -2^{w-1}$. This value is represented by the bit vector $100\\dots0$.\nSince $x < 0$, $m(x) = -1$.\nThe expression evaluates to $(x \\oplus (-1)) + 1$.\n- $x$ is $100\\dots0$.\n- $-1$ is $111\\dots1$.\n- $x \\oplus (-1)$ yields $011\\dots1$. This is the bit representation for $2^{w-1}-1$.\n- Adding $1$ to this result: $(2^{w-1}-1) + 1 = 2^{w-1}$. However, this is performed using $w$-bit arithmetic.\n- The addition $(011\\dots1) + (000\\dots1)$ results in $100\\dots0$, with a carry-out that is discarded.\nThe final bit pattern is $100\\dots0$, which represents the original number, $-2^{w-1}$.\nSo, for $x=-2^{w-1}$, the expression yields $-2^{w-1}$, which is not the mathematical absolute value. This behavior is a consequence of integer overflow, inherent to fixed-width two's complement arithmetic, and it confirms the problem's specified limitation.\n\n**Part 3: Application for $w=32$ and $x=0x\\mathrm{F0A3B7C9}$**\n\nWe are given $w=32$ and the hexadecimal representation of $x$ as $0x\\mathrm{F0A3B7C9}$.\n\nFirst, we determine the sign of $x$. The MSB of the hexadecimal representation is `F`, which is $1111_2$. The MSB of the $32$-bit integer is therefore $1$, indicating that $x$ is a negative number.\n\nSince $x < 0$, the mask $m(x)$ is $-1$. For $w=32$, $-1$ is represented in hexadecimal as $0x\\mathrm{FFFFFFFF}$.\n\nWe apply the derived formula for the absolute value:\n$$ \\mathrm{abs}(x) = (x \\oplus m(x)) - m(x) = (x \\oplus (-1)) + 1 $$\n\nLet's perform the operations in hexadecimal:\n- $x = 0x\\mathrm{F0A3B7C9}$\n- $m(x) = -1 = 0x\\mathrm{FFFFFFFF}$\n\n1.  Compute the XOR operation: $x \\oplus m(x)$.\n    $$ 0x\\mathrm{F0A3B7C9} \\oplus 0x\\mathrm{FFFFFFFF} = 0x\\mathrm{0F5C4836} $$\n    This operation is equivalent to a bitwise NOT.\n\n2.  Subtract the mask: $(x \\oplus m(x)) - m(x)$. This is equivalent to adding $1$.\n    $$ 0x\\mathrm{0F5C4836} - (0x\\mathrm{FFFFFFFF}) = 0x\\mathrm{0F5C4836} + 1 = 0x\\mathrm{0F5C4837} $$\n\nThe result, $\\mathrm{abs}(x)$, is represented in hexadecimal as $0x\\mathrm{0F5C4837}$.\n\nFinally, we convert this hexadecimal result to its base-$10$ integer value:\n$$ 0x\\mathrm{0F5C4837} = (0 \\times 16^7) + (15 \\times 16^6) + (5 \\times 16^5) + (12 \\times 16^4) + (4 \\times 16^3) + (8 \\times 16^2) + (3 \\times 16^1) + (7 \\times 16^0) $$\n$$ = 15 \\times 16777216 + 5 \\times 1048576 + 12 \\times 65536 + 4 \\times 4096 + 8 \\times 256 + 3 \\times 16 + 7 \\times 1 $$\n$$ = 251658240 + 5242880 + 786432 + 16384 + 2048 + 48 + 7 $$\n$$ = 257706039 $$\n\nThe value of $\\mathrm{abs}(x)$ is $257,706,039$.", "answer": "$$ \\boxed{257706039} $$", "id": "3622812"}]}