{"hands_on_practices": [{"introduction": "To truly master the hexadecimal system, we must first build a strong foundation in its relationship with the decimal system we use daily. This initial practice focuses on the fundamental skill of conversion. By working through the conversion of a hexadecimal number that includes a fractional part [@problem_id:1941855], you will reinforce your understanding of positional notation and see how the principles of base-10 extend to base-16.", "problem": "In digital systems and computer science, the hexadecimal number system (base-16) is a positional numeral system that represents numbers using a base of 16. It uses sixteen distinct symbols, most often the symbols \"0\"–\"9\" to represent values zero to nine, and \"A\"–\"F\" to represent values ten to fifteen.\n\nConsider the hexadecimal number $A.4C_{16}$. Your task is to convert this number into its equivalent decimal (base-10) representation. Express your final answer as a decimal number.", "solution": "In a base-$b$ positional system, a numeral with integer digits $d_{k}\\dots d_{0}$ and fractional digits $f_{1}f_{2}\\dots$ has value\n$$\n\\sum_{i=0}^{k} d_{i} b^{i} + \\sum_{j=1}^{\\infty} f_{j} b^{-j}.\n$$\nFor hexadecimal, $b=16$. The hexadecimal digits map to decimal values with $A=10$, $C=12$. Thus for $A.4C_{16}$,\n$$\nA.4C_{16} = 10 \\cdot 16^{0} + 4 \\cdot 16^{-1} + 12 \\cdot 16^{-2}.\n$$\nUsing $16^{0}=1$, $16^{-1}=\\frac{1}{16}$, and $16^{-2}=\\frac{1}{256}$, this becomes\n$$\n10 + \\frac{4}{16} + \\frac{12}{256} = 10 + \\frac{1}{4} + \\frac{3}{64}.\n$$\nCombine the fractional terms with common denominator $64$:\n$$\n10 + \\frac{16}{64} + \\frac{3}{64} = 10 + \\frac{19}{64} = \\frac{659}{64}.\n$$\nConverting to a decimal yields\n$$\n\\frac{659}{64} = 10.296875.\n$$\nTherefore, the decimal representation of $A.4C_{16}$ is $10.296875$.", "answer": "$$\\boxed{10.296875}$$", "id": "1941855"}, {"introduction": "Moving beyond simple representation, we now explore how hexadecimal values function within a processor's arithmetic logic unit (ALU). CPUs often handle operands of varying sizes, such as a 12-bit immediate value in a 32-bit instruction. This practice [@problem_id:3647781] investigates the crucial process of sign extension, which preserves the value of signed numbers when they are promoted to a larger bit width, and contrasts it with a faulty zero-extension to reveal its importance.", "problem": "A 32-bit reduced instruction set architecture (RISC) core uses two's complement representation for signed integers and implements immediate operands with a width of $12$ bits. In an addition instruction executed by the Arithmetic Logic Unit (ALU), the $12$-bit immediate field is the hexadecimal value $0xF7F$, and the destination register initially contains the hexadecimal value $0x10001000$. The architecture specification requires that immediates be sign-extended to $32$ bits before being consumed by the ALU, but a faulty implementation zero-extends the immediate instead.\n\nStarting from first principles of positional numeral systems and two's complement arithmetic, determine the exact magnitude of the discrepancy in the computed register value when comparing the correct sign-extension behavior to the faulty zero-extension behavior. Concretely, let $I_{\\text{sext}}$ be the correct $32$-bit sign-extended value of the $12$-bit immediate $0xF7F$, and let $I_{\\text{zext}}$ be the faulty $32$-bit zero-extended value of the same immediate. The ALU computes $R'_{\\text{sext}} = R + I_{\\text{sext}}$ under correct behavior and $R'_{\\text{zext}} = R + I_{\\text{zext}}$ under faulty behavior, where $R = 0x10001000$. Compute the exact value of\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|,$$\nand express your final answer as a base-$10$ integer. No rounding is required, and no physical units are involved.", "solution": "The problem requires the determination of the magnitude of the discrepancy, $D$, between the result of an addition using a correctly sign-extended immediate and a faulty zero-extended immediate.\n\nThe quantity to be computed is the magnitude of the difference between the correct and faulty results:\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|$$\nSubstituting the definitions for $R'_{\\text{sext}}$ and $R'_{\\text{zext}}$:\n$$D = \\left|(R + I_{\\text{sext}}) - (R + I_{\\text{zext}})\\right|$$\nSimplifying the expression, the register's initial value $R$ cancels out:\n$$D = \\left|R + I_{\\text{sext}} - R - I_{\\text{zext}}\\right| = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right|$$\nThus, the problem reduces to finding the magnitude of the difference between the sign-extended value and the zero-extended value of the immediate. The initial register value $R = 0x10001000$ is extraneous information.\n\nLet us analyze the immediate value from first principles. The immediate is a $12$-bit hexadecimal value $0xF7F$.\nIn a positional numeral system with base $b$, a number represented by digits $d_{n-1}d_{n-2}...d_0$ has the value $\\sum_{i=0}^{n-1} d_i b^i$.\nFirst, we convert the $12$-bit hexadecimal value to its binary representation. Each hexadecimal digit corresponds to $4$ binary digits (bits):\n- $F_{16} = 15_{10} = 1111_2$\n- $7_{16} = 7_{10} = 0111_2$\n- $F_{16} = 15_{10} = 1111_2$\n\nCombining these, the $12$-bit immediate in binary is $111101111111_2$. Let us denote this bit pattern as $J$.\n\nIn two's complement representation, the sign of a number is determined by its most significant bit (MSB). For a $12$-bit number, the MSB is bit $11$ (counting from bit $0$). In the pattern $111101111111_2$, the MSB is $1$. This indicates that the immediate represents a negative value.\n\nLet $j_{11}j_{10}...j_0$ be the binary representation of the $12$-bit immediate $J$.\nThe value of a signed $12$-bit two's complement integer is given by the formula:\n$$V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\nThe value of an unsigned $12$-bit integer is:\n$$V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i = j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\nZero-extension to $32$ bits involves prepending $32 - 12 = 20$ zeros. The resulting $32$-bit number, $I_{\\text{zext}}$, is interpreted by the system as a positive number whose value is simply the unsigned value of the original $12$-bit pattern.\n$$V(I_{\\text{zext}}) = V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i$$\n\nSign-extension to $32$ bits involves prepending $20$ copies of the MSB ($j_{11}$) of the original $12$-bit number. This process preserves the signed numerical value of the original number.\n$$V(I_{\\text{sext}}) = V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\nNow we compute the difference in their values:\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = \\left(-j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right) - \\left(j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right)$$\nThe summation terms cancel out:\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -j_{11} \\cdot 2^{11} - j_{11} \\cdot 2^{11} = -2 \\cdot j_{11} \\cdot 2^{11} = -j_{11} \\cdot 2^{12}$$\nFor the given immediate $0xF7F$, the binary representation is $111101111111_2$, so its MSB is $j_{11} = 1$.\nSubstituting $j_{11} = 1$ into the difference formula:\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -1 \\cdot 2^{12} = -2^{12}$$\nThe discrepancy $D$ is the magnitude of this difference:\n$$D = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right| = \\left|V(I_{\\text{sext}}) - V(I_{\\text{zext}})\\right| = \\left|-2^{12}\\right| = 2^{12}$$\nFinally, we compute the base-$10$ value:\n$$2^{10} = 1024$$\n$$2^{11} = 2 \\times 1024 = 2048$$\n$$2^{12} = 2 \\times 2048 = 4096$$\nThe magnitude of the discrepancy is $4096$.\nThis result is general: for a $k$-bit immediate whose MSB is $1$, a faulty zero-extension instead of sign-extension will produce a value that is precisely $2^k$ greater than the correct value. If the MSB were $0$, both extensions would be identical, and the discrepancy would be $0$.", "answer": "$$\\boxed{4096}$$", "id": "3647781"}, {"introduction": "Hexadecimal notation truly shines in low-level programming, where it serves as a compact and readable proxy for manipulating binary data. This final practice delves into a core technique used in operating systems and embedded programming: bitmasking. Here, you will use bitwise operations with hexadecimal masks to precisely modify a specific field within a 32-bit register [@problem_id:3647874], a skill essential for controlling hardware and managing packed data structures.", "problem": "In a Central Processing Unit (CPU) data path, mask-based field insertion is routinely used to set specific bit fields in a word while leaving all other bits unchanged. Consider a word-sized register of width $32$ bits, with bit positions numbered from $0$ (least significant bit) to $31$ (most significant bit). Let $x$ denote the content of the register, initially $x = 0x12345678$. The goal is to set bits $8$ through $11$ of $x$ equal to the hexadecimal nibble $0xA$, and to leave all other bits unchanged.\n\nStarting only from the definitions of the bitwise operations bitwise AND ($\\$), bitwise OR ($|$), bitwise NOT ($\\sim$), and left shift ($$), and from the positional meaning of hexadecimal digits over binary (each hexadecimal digit equals four contiguous bits), derive a correct mask-and-insert procedure from first principles that accomplishes the required field insertion. Then apply your derived procedure to the given $x$ to compute the resulting register value.\n\nExpress your final answer as a single hexadecimal integer with the prefix $0x$. No rounding is required.", "solution": "The task is to modify a specific bit field within a $32$-bit register. Let the initial content of the register be denoted by the variable $x$. The goal is to set bits $8$ through $11$ to the hexadecimal value $0xA$, while preserving the state of all other bits. This operation is commonly known as field insertion and can be derived from first principles using bitwise logical operations.\n\nThe procedure consists of two fundamental steps:\n1.  **Clearing the target bit field**: First, we must set the bits in the target field (bits $8$ through $11$) to $0$. This ensures that the subsequent insertion step does not corrupt the final value. This is achieved using a bitwise AND ($$) operation with a \"clearing mask\".\n2.  **Inserting the new value**: Second, we must place the new value into the now-cleared target field. This is accomplished using a bitwise OR ($|$) operation with an \"insertion value\".\n\nLet's derive the necessary masks and values from the problem statement. The register width is $32$ bits. The target field spans from bit $i=8$ to bit $j=11$. The width of this field is $w = j - i + 1 = 11 - 8 + 1 = 4$ bits. The new value for this field is $v = 0xA$.\n\n**Step 1: Derivation of the Clearing Mask**\n\nTo clear the target field in $x$, we use a clearing mask, let's call it $M_{clear}$. This mask must have $0$s in bit positions $8$ through $11$ and $1$s in all other $28$ positions. Performing $x \\; \\ \\; M_{clear}$ will set the target bits to $0$ while leaving all other bits of $x$ unchanged (since $b \\; \\ \\; 1 = b$ and $b \\; \\ \\; 0 = 0$ for any bit $b$).\n\nWe can construct $M_{clear}$ by first defining a mask that has $1$s only in the target bit field, and then taking its bitwise complement ($\\sim$). Let's call this intermediate mask $M_{field}$. $M_{field}$ has $4$ consecutive $1$s starting at bit position $8$. A block of $w$ ones is represented by the integer $2^w - 1$. For $w=4$, this is $2^4 - 1 = 15$, which is $0xF$ in hexadecimal.\n\nTo position these $1$s at the correct location, we must left-shift ($$) this value by the starting bit position, $i=8$.\n$$M_{field} = (0xF)  8$$\nIn a $32$-bit system, a hexadecimal number is a sequence of $8$ nibbles (4-bit groups). A left shift by $8$ bits corresponds to shifting by two hexadecimal positions.\nThe hexadecimal constant $0xF$ is represented in $32$ bits as $0x0000000F$.\n$$M_{field} = 0x0000000F  8 = 0x00000F00$$\nThe clearing mask $M_{clear}$ is the bitwise NOT of $M_{field}$:\n$$M_{clear} = \\sim M_{field} = \\sim (0x00000F00)$$\nPerforming the bitwise NOT on this $32$-bit value gives:\n$$M_{clear} = 0xFFFFF0FF$$\nThe operation to clear the field in $x$ is thus $x \\; \\ \\; 0xFFFFF0FF$.\n\n**Step 2: Derivation of the Insertion Value**\n\nThe new value to be inserted is $v = 0xA$. This $4$-bit value must be positioned correctly within the $32$-bit word so that it aligns with the target field (bits $8-11$). This is also achieved with a left shift operation. Let the prepared value be $V_{insert}$.\n$$V_{insert} = v  i = 0xA  8$$\nThe hexadecimal constant $0xA$ is represented in $32$ bits as $0x0000000A$.\n$$V_{insert} = 0x0000000A  8 = 0x00000A00$$\nThis value will be combined with the cleared version of $x$ using a bitwise OR operation. Since the target field in the cleared $x$ is all zeros, the OR operation will insert the bits of $V_{insert}$ without affecting any other bits (since $b \\; | \\; 0 = b$ for any bit $b$).\n\n**The Complete Procedure**\n\nCombining the two steps, the final value, $x_{new}$, is calculated as:\n$$x_{new} = (x \\; \\ \\; M_{clear}) \\; | \\; V_{insert}$$\nSubstituting the derived expressions:\n$$x_{new} = (x \\; \\ \\; (\\sim(0xF  8))) \\; | \\; (0xA  8)$$\n\n**Application to the Given Data**\n\nNow we apply this procedure to the given initial register content $x = 0x12345678$.\n\nFirst, we clear the target field:\n$$x_{cleared} = x \\; \\ \\; M_{clear} = 0x12345678 \\; \\ \\; 0xFFFFF0FF$$\nThis operation preserves all hexadecimal digits of $x$ where the mask has a digit of $F$, and zeroes out the digit where the mask has a digit of $0$. The mask has a $0$ at the position corresponding to bits $8-11$, which aligns with the digit '$6$' in $0x12345678$.\n$$x_{cleared} = 0x12345078$$\n\nNext, we insert the new value:\n$$x_{new} = x_{cleared} \\; | \\; V_{insert} = 0x12345078 \\; | \\; 0x00000A00$$\nThe OR operation places the value $A$ into the third nibble from the right (bits $8-11$), which was previously cleared to $0$.\n$$x_{new} = 0x12345A78$$\n\nThe resulting register value is $0x12345A78$.", "answer": "$$\\boxed{0x12345A78}$$", "id": "3647874"}]}