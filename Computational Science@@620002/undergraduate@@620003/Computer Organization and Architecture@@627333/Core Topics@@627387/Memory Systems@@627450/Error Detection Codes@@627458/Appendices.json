{"hands_on_practices": [{"introduction": "Moving from abstract theory to concrete implementation is a cornerstone of engineering. This exercise challenges you to translate the mathematical definition of parity—an exclusive-or sum—into a physical circuit using only universal NAND gates. By constructing the logic from first principles and analyzing its gate count, you will gain a practical understanding of the hardware cost and complexity behind this fundamental error detection mechanism [@problem_id:3640130].", "problem": "A memory subsystem uses an even-parity bit to detect single-bit errors on each transmitted data word. For a data word of length $n$, the even-parity bit $p$ is defined by the modulo-$2$ sum $p = d_{1} \\oplus d_{2} \\oplus \\cdots \\oplus d_{n}$, where $\\oplus$ denotes the exclusive-or (XOR) of Boolean variables and $d_{i} \\in \\{0,1\\}$. You are to design a combinational logic parity generator using only 2-input NAND gates, assuming unlimited fan-out and that only uncomplemented primary inputs $d_{i}$ are available.\n\nStarting only from the Boolean-algebra definitions of NAND and XOR and standard identities, carry out the following steps:\n\n- Construct a 2-input XOR subcircuit using only 2-input NAND gates, and justify its correctness by algebraic manipulation of Boolean expressions.\n- Use a balanced binary reduction tree of identical 2-input XOR subcircuits to implement $p = d_{1} \\oplus \\cdots \\oplus d_{n}$.\n- Derive the exact total number $G(n)$ of 2-input NAND gates required by the entire parity generator as a function of $n$.\n\nFor context and comparison (do not include this in the requested final value), also state in your reasoning how the NAND-only gate count compares to a baseline that uses 2-input XOR gates as primitives in the same balanced tree (counting each XOR primitive as one gate).\n\nProvide your final answer as the single closed-form expression $G(n)$ in terms of $n$. No numerical approximation or rounding is required.", "solution": "The problem asks for the derivation of the total number of 2-input NAND gates, $G(n)$, required to build an $n$-bit even-parity generator. The design is constrained to use only 2-input NAND gates, with uncomplemented primary inputs, and must be structured as a balanced binary reduction tree of identical 2-input XOR subcircuits.\n\nThe derivation will proceed in three steps as requested by the problem statement. First, we will construct a 2-input XOR subcircuit using only 2-input NAND gates and prove its correctness. Second, we will analyze the structure of the balanced binary tree to determine the number of such XOR subcircuits required. Finally, we will combine these results to derive the total gate count $G(n)$.\n\n**Step 1: Construction of a 2-Input XOR Subcircuit from 2-Input NAND Gates**\n\nLet the inputs to the XOR function be $A$ and $B$. The Boolean expression for XOR is:\n$$A \\oplus B = A'B + AB'$$\nThe Boolean expression for a 2-input NAND gate is:\n$$A \\uparrow B = (A \\cdot B)' = A' + B'$$\nwhere we use the operator $\\uparrow$ to denote the NAND operation.\n\nWe must construct a circuit equivalent to $A \\oplus B$ using only the $\\uparrow$ operator. While several implementations exist, a well-known and efficient circuit uses four 2-input NAND gates. Its structure is given by the following Boolean expression:\n$$F = (A \\uparrow (A \\uparrow B)) \\uparrow (B \\uparrow (A \\uparrow B))$$\n\nTo justify the correctness of this construction, we will algebraically manipulate this expression to show it is equivalent to $A \\oplus B$. Let's define an intermediate signal $G_1 = A \\uparrow B$. The expression for the output $F$ becomes:\n$$F = (A \\uparrow G_1) \\uparrow (B \\uparrow G_1)$$\nExpanding this using the definition of the NAND operation:\n$$F = ( (A \\uparrow G_1) \\cdot (B \\uparrow G_1) )'$$\n$$F = ( (A \\cdot G_1)' \\cdot (B \\cdot G_1)' )'$$\nApplying De Morgan's Law, which states that $(X' \\cdot Y')' = X + Y$, we can simplify this expression. Let $X = A \\cdot G_1$ and $Y = B \\cdot G_1$.\n$$F = (A \\cdot G_1) + (B \\cdot G_1)$$\nUsing the distributive law, we can factor out $G_1$:\n$$F = (A+B) \\cdot G_1$$\nNow, we substitute the expression for $G_1 = A \\uparrow B = (A \\cdot B)'$:\n$$F = (A+B) \\cdot (A \\cdot B)'$$\nApplying De Morgan's Law to $(A \\cdot B)'$ gives $A' + B'$:\n$$F = (A+B) \\cdot (A' + B')$$\nWe expand this expression using the distributive law:\n$$F = A \\cdot (A' + B') + B \\cdot (A' + B')$$\n$$F = (A \\cdot A') + (A \\cdot B') + (B \\cdot A') + (B \\cdot B')$$\nAccording to the axioms of Boolean algebra, $X \\cdot X' = 0$. Therefore, $A \\cdot A' = 0$ and $B \\cdot B' = 0$. The expression simplifies to:\n$$F = 0 + A \\cdot B' + A' \\cdot B + 0$$\n$$F = A'B + AB'$$\nThis final expression is the definition of the exclusive-or function, $A \\oplus B$. Thus, the circuit built from four 2-input NAND gates correctly implements a 2-input XOR function. The number of gates required for one such subcircuit is $4$. The problem's constraint that only uncomplemented inputs are available is satisfied, as this design takes inputs $A$ and $B$ directly.\n\n**Step 2: Analysis of the Balanced Binary Reduction Tree**\n\nThe parity bit $p$ is defined as the XOR sum of $n$ data bits:\n$$p = d_{1} \\oplus d_{2} \\oplus \\cdots \\oplus d_{n}$$\nThe XOR operation is associative, meaning $(A \\oplus B) \\oplus C = A \\oplus (B \\oplus C)$. This allows us to compute the $n$-input XOR sum by cascading 2-input XOR operations in a tree structure. A balanced binary reduction tree is specified to minimize the propagation delay.\n\nTo compute the XOR sum of $n$ inputs using 2-input gates, we require a total of $n-1$ such gates. We can demonstrate this by induction. Let $N_{\\text{XOR}}(n)$ be the number of 2-input XOR subcircuits required for $n$ inputs.\n- For $n=2$, we need $1$ subcircuit, so $N_{\\text{XOR}}(2) = 1 = 2-1$.\n- For $n=3$, we compute $(d_1 \\oplus d_2) \\oplus d_3$, which requires $2$ subcircuits. So $N_{\\text{XOR}}(3) = 2 = 3-1$.\n- For a general $n$, a balanced tree structure partitions the $n$ inputs into two groups of size $\\lceil n/2 \\rceil$ and $\\lfloor n/2 \\rfloor$. The XOR sums of these two groups are computed recursively, and their results are combined with one final XOR gate. The recurrence relation is:\n$$N_{\\text{XOR}}(n) = N_{\\text{XOR}}(\\lceil n/2 \\rceil) + N_{\\text{XOR}}(\\lfloor n/2 \\rfloor) + 1$$\nwith the base case $N_{\\text{XOR}}(1) = 0$.\nAssuming the inductive hypothesis $N_{\\text{XOR}}(k) = k-1$ for all $k < n$:\n$$N_{\\text{XOR}}(n) = (\\lceil n/2 \\rceil - 1) + (\\lfloor n/2 \\rfloor - 1) + 1$$\n$$N_{\\text{XOR}}(n) = \\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor - 1$$\nFor any integer $n$, the identity $\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n$ holds. Therefore:\n$$N_{\\text{XOR}}(n) = n - 1$$\nThis proves that a total of $n-1$ identical 2-input XOR subcircuits are needed to implement the $n$-bit parity generator.\n\n**Step 3: Derivation of the Total NAND Gate Count $G(n)$**\n\nWe have established the following:\n1.  Each 2-input XOR subcircuit is implemented using $4$ two-input NAND gates.\n2.  The entire $n$-bit parity generator requires $n-1$ of these identical XOR subcircuits, arranged in a balanced tree.\n\nEach XOR subcircuit in the tree receives as its inputs either the primary inputs $d_i$ or the uncomplemented outputs from a preceding level of XOR subcircuits. Since each subcircuit is a self-contained module, there are no opportunities for gate sharing between them.\n\nThe total number of 2-input NAND gates, $G(n)$, is therefore the product of the number of XOR subcircuits and the number of NAND gates per subcircuit:\n$$G(n) = (\\text{Number of XOR subcircuits}) \\times (\\text{NAND gates per XOR subcircuit})$$\n$$G(n) = (n-1) \\times 4$$\n$$G(n) = 4(n-1)$$\n\nFor context and comparison, as requested, a baseline design using primitive 2-input XOR gates would require $n-1$ gates in total. Our NAND-only implementation requires $4(n-1)$ gates, which is a factor of $4$ larger. This factor directly reflects the gate complexity of synthesizing an XOR function from a NAND-only logic family under the given constraints.\n\nThe final derived expression for the total number of 2-input NAND gates for an $n$-bit parity generator is $G(n) = 4(n-1)$.", "answer": "$$\\boxed{4(n-1)}$$", "id": "3640130"}, {"introduction": "In high-performance computing, every cycle counts. This practice moves beyond simple implementation to explore architectural optimization within an Arithmetic Logic Unit (ALU). You will investigate how the algebraic properties of parity can be exploited to predict the parity of an operation's result from its operands' parities, avoiding a costly full recalculation. This problem illuminates the elegant connection between Boolean logic and tangible performance gains in processor design [@problem_id:3640148].", "problem": "A processor’s Arithmetic Logic Unit (ALU) updates a parity flag for each operation on $n$-bit operands by computing the even parity of the result word. Let the parity function be $P(x) = \\left(\\sum_{i=0}^{n-1} x_i\\right) \\bmod 2$, where $x_i \\in \\{0,1\\}$ are the bits of $x$. In the baseline design, parity is obtained by a balanced reduction tree of two-input exclusive-or gates across the $n$ result bits, requiring $n-1$ parity-XOR operations for each instruction. Consider $n=64$, so the baseline cost per instruction is $63$ parity-XOR operations.\n\nThe ALU supports bit-wise exclusive-or ($\\oplus$) and bit-wise conjunction ($\\land$). Assume the parity bits $P(a)$ and $P(b)$ of operands $a$ and $b$ are available to the parity logic at zero additional cost for every instruction. A microarchitect aims to avoid recomputing full parity wherever possible by exploiting algebraic structure relating $P(a \\oplus b)$ and $P(a \\land b)$ to operand parities and other primitive quantities.\n\nStarting from the fundamental definition of parity and the standard set identities on Hamming weights, do the following:\n\n1. Derive $P(a \\oplus b)$ in terms of $P(a)$ and $P(b)$ only, using first principles of modulo-$2$ addition on bit positions.\n\n2. Derive an expression that links $P(a \\land b)$ to $P(a)$, $P(b)$, and one additional primitive parity quantity that is computable from $a$ and $b$ without scanning all result bits of $a \\land b$. Identify the minimal such additional parity quantity and justify why $P(a \\land b)$ cannot, in general, be determined from $P(a)$ and $P(b)$ alone.\n\n3. Given a workload of $M = 2.50 \\times 10^{7}$ ALU instructions with a fraction $\\alpha = 0.45$ being $\\oplus$ and the remainder being $\\land$, quantify the total number of parity-XOR operations saved relative to the baseline if:\n   - For $\\oplus$, you use the derived relationship to compute $P(a \\oplus b)$ directly from $P(a)$ and $P(b)$, replacing the $63$-XOR reduction with a single two-input XOR on the operand parities.\n   - For $\\land$, you do not have the additional primitive parity available and must use the baseline $63$-XOR reduction.\n\nExpress the final result as a single real-valued number equal to the total count of parity-XOR operations saved over the entire workload, and round your answer to four significant figures. No physical units are required in the answer.", "solution": "The problem is valid and can be solved by addressing the three requested parts in sequence. We will use the provided definitions and first principles of digital logic and modular arithmetic. Let $H(x)$ denote the Hamming weight of a bit-string $x$, which is the number of bits with value $1$. The parity function $P(x)$ is defined as the Hamming weight modulo $2$, i.e., $P(x) = H(x) \\bmod 2$. For an $n$-bit word $x = (x_{n-1}, \\dots, x_0)$, this is $P(x) = \\left(\\sum_{i=0}^{n-1} x_i\\right) \\bmod 2$.\n\n1. Derivation of $P(a \\oplus b)$:\n\nLet $a$ and $b$ be two $n$-bit operands. The bitwise exclusive-or is $c = a \\oplus b$, where each bit $c_i$ is given by $c_i = a_i \\oplus b_i$. We want to find $P(a \\oplus b) = H(a \\oplus b) \\bmod 2$.\n\nThe Hamming weight of $a \\oplus b$ is the sum of its bits: $H(a \\oplus b) = \\sum_{i=0}^{n-1} (a_i \\oplus b_i)$.\nFor single bits, the XOR operation $a_i \\oplus b_i$ yields $1$ if and only if $a_i \\neq b_i$. The relationship between arithmetic sum and XOR for single bits is $a_i \\oplus b_i = a_i + b_i - 2(a_i \\land b_i)$, where $a_i \\land b_i$ is equivalent to the product $a_ib_i$.\nSumming over all $n$ bit positions:\n$$H(a \\oplus b) = \\sum_{i=0}^{n-1} (a_i + b_i - 2(a_i \\land b_i)) = \\left(\\sum_{i=0}^{n-1} a_i\\right) + \\left(\\sum_{i=0}^{n-1} b_i\\right) - 2\\left(\\sum_{i=0}^{n-1} (a_i \\land b_i)\\right)$$\nIn terms of Hamming weights, this is the well-known identity:\n$$H(a \\oplus b) = H(a) + H(b) - 2H(a \\land b)$$\nTo find the parity $P(a \\oplus b)$, we take the expression modulo $2$:\n$$P(a \\oplus b) = H(a \\oplus b) \\bmod 2 = \\big(H(a) + H(b) - 2H(a \\land b)\\big) \\bmod 2$$\nThe term $2H(a \\land b)$ is an integer multiple of $2$, so its value modulo $2$ is $0$. Therefore, the expression simplifies to:\n$$P(a \\oplus b) = \\big(H(a) + H(b)\\big) \\bmod 2$$\nUsing the property of modular arithmetic that $(x+y) \\bmod k = ((x \\bmod k) + (y \\bmod k)) \\bmod k$, we get:\n$$P(a \\oplus b) = \\big((H(a) \\bmod 2) + (H(b) \\bmod 2)\\big) \\bmod 2$$\nBy definition, $P(a) = H(a) \\bmod 2$ and $P(b) = H(b) \\bmod 2$. Thus:\n$$P(a \\oplus b) = (P(a) + P(b)) \\bmod 2$$\nThe addition of single bits modulo $2$ is equivalent to the exclusive-or operation. Therefore, we arrive at the final expression:\n$$P(a \\oplus b) = P(a) \\oplus P(b)$$\n\n2. Derivation and justification for $P(a \\land b)$:\n\nTo find an expression for $P(a \\land b)$, we use a different fundamental identity for Hamming weights which relates bitwise AND, OR, and the operand weights:\n$$H(a \\lor b) = H(a) + H(b) - H(a \\land b)$$\nThis identity arises from the principle of inclusion-exclusion applied to the sets of bit positions where $a$ and $b$ have a $1$.\nRearranging this identity to solve for $H(a \\land b)$:\n$$H(a \\land b) = H(a) + H(b) - H(a \\lor b)$$\nTo find the parity $P(a \\land b)$, we take this expression modulo $2$:\n$$P(a \\land b) = H(a \\land b) \\bmod 2 = \\big(H(a) + H(b) - H(a \\lor b)\\big) \\bmod 2$$\nTreating subtraction modulo $2$ as addition modulo $2$ (or XOR), and applying the properties of modular arithmetic as before:\n$$P(a \\land b) = (P(a) + P(b) + P(a \\lor b)) \\bmod 2$$\nThis is equivalent to:\n$$P(a \\land b) = P(a) \\oplus P(b) \\oplus P(a \\lor b)$$\nThis expression links $P(a \\land b)$ to $P(a)$, $P(b)$, and the additional primitive parity quantity $P(a \\lor b)$, which is the parity of the bitwise OR of the operands.\n\nTo justify why $P(a \\land b)$ cannot be determined from $P(a)$ and $P(b)$ alone, we provide a counterexample. Consider an operand width of $n=2$.\nCase I: Let $a = (0, 1)$ and $b = (1, 0)$.\nThe parities of the operands are $P(a) = (0+1) \\bmod 2 = 1$ and $P(b) = (1+0) \\bmod 2 = 1$.\nThe bitwise AND is $a \\land b = (0 \\land 1, 1 \\land 0) = (0, 0)$.\nThe parity of the result is $P(a \\land b) = (0+0) \\bmod 2 = 0$.\n\nCase II: Let $a' = (1, 0)$ and $b' = (1, 0)$.\nThe parities of the operands are $P(a') = (1+0) \\bmod 2 = 1$ and $P(b') = (1+0) \\bmod 2 = 1$.\nThe bitwise AND is $a' \\land b' = (1 \\land 1, 0 \\land 0) = (1, 0)$.\nThe parity of the result is $P(a' \\land b') = (1+0) \\bmod 2 = 1$.\n\nIn both cases, the input parities are $(P(a), P(b))=(1, 1)$, but the resulting parity $P(a \\land b)$ is $0$ in Case I and $1$ in Case II. Since the same pair of input parities can produce different output parities, $P(a \\land b)$ cannot be determined solely from $P(a)$ and $P(b)$.\n\n3. Quantification of saved operations:\n\nThe problem specifies the following parameters:\n- Operand size: $n=64$ bits.\n- Baseline cost for parity computation: $n-1 = 63$ parity-XOR operations.\n- Total instructions in workload: $M = 2.50 \\times 10^{7}$.\n- Fraction of $\\oplus$ instructions: $\\alpha = 0.45$.\n\nThe number of $\\oplus$ instructions is $N_\\oplus = \\alpha M = 0.45 \\times 2.50 \\times 10^{7} = 1.125 \\times 10^{7}$.\nThe number of $\\land$ instructions is $N_\\land = (1 - \\alpha)M = 0.55 \\times 2.50 \\times 10^{7} = 1.375 \\times 10^{7}$.\n\nFor each $\\oplus$ instruction, the optimization is applied. The new cost is computing $P(a) \\oplus P(b)$, which requires a single 2-input XOR operation.\n- Saving per $\\oplus$ instruction = (Baseline Cost) - (Optimized Cost) = $63 - 1 = 62$ XORs.\n- Total savings from $\\oplus$ instructions = $S_\\oplus = N_\\oplus \\times 62 = (1.125 \\times 10^{7}) \\times 62$.\n\nFor each $\\land$ instruction, the problem states the baseline method is used, as the additional primitive $P(a \\lor b)$ is not available.\n- Saving per $\\land$ instruction = (Baseline Cost) - (Baseline Cost) = $63 - 63 = 0$ XORs.\n- Total savings from $\\land$ instructions = $S_\\land = N_\\land \\times 0 = 0$.\n\nThe total number of parity-XOR operations saved is the sum of savings from both types of instructions:\n$$S_{total} = S_\\oplus + S_\\land = (1.125 \\times 10^{7}) \\times 62 + 0$$\n$$S_{total} = 69.75 \\times 10^{7}$$\nWriting this in standard scientific notation gives:\n$$S_{total} = 6.975 \\times 10^{8}$$\nThe problem asks for the result to be rounded to four significant figures. The calculated value $6.975 \\times 10^8$ already has exactly four significant figures ($6, 9, 7, 5$), so no further rounding is necessary.", "answer": "$$\\boxed{6.975 \\times 10^8}$$", "id": "3640148"}, {"introduction": "An error detection code is only as good as its ability to handle the types of errors that actually occur. This problem confronts the limitations of simple parity by modeling a realistic physical-layer fault: crosstalk between adjacent wires on a data bus. By analyzing how this phenomenon generates correlated two-bit errors, you will see precisely why parity fails in this scenario and quantify the probability of an undetected error. This hands-on analysis demonstrates the critical need for codes that can handle more complex error patterns found in real-world systems [@problem_id:3640110].", "problem": "A parallel data bus with 32 data wires and one parity wire implements even parity error detection, meaning the parity generator sets the parity bit so that the total number of logical ones across the 33 transmitted bits is even. The receiver recomputes parity on the received data and compares to the received parity bit to detect discrepancies. Each data transmission is one word (32 data bits plus one parity bit) sent simultaneously over physically adjacent microstrip traces on a printed circuit board. Because the traces are long and closely spaced, capacitive coupling induces crosstalk between adjacent wires.\n\nModel the physical error mechanisms during a single word transmission as follows:\n- Independent single-wire bit flips occur due to random noise with probability $p$ per wire per transmission, and these events are independent across wires.\n- In addition, for each physically adjacent wire pair, a coupled two-wire simultaneous flip (both wires invert together) occurs with probability $q$ per adjacent pair per transmission, independent across pairs and independent of single-wire flips.\n\nAssume a linear physical arrangement of the 33 wires: $D_{0}, D_{1}, \\ldots, D_{31}, P$, where $D_{i}$ are data wires and $P$ is the parity wire. In this arrangement, there are 32 adjacent pairs: $(D_{0},D_{1}), (D_{1},D_{2}), \\ldots, (D_{30},D_{31}), (D_{31},P)$. For this case study, take $p = 1.2 \\times 10^{-6}$ and $q = 3.0 \\times 10^{-8}$.\n\nStarting from the definition of even parity and the axioms of elementary probability, and using a rare-event approximation that neglects all terms of order $p^{2}$, $pq$, and $q^{2}$ (i.e., assume at most one error event occurs per transmission), derive and compute the probability that an error occurs but is not detected by the parity check. Express your final probability as a decimal in scientific notation and round your answer to four significant figures.", "solution": "The problem asks for the probability that an error occurs but is not detected by the even parity check. An even parity check detects an error if and only if an odd number of bits are flipped. Consequently, an error is undetected if and only if a non-zero, even number of bits are flipped.\n\nThe problem specifies two types of error events for a single word transmission:\n1. A single-wire bit flip, occurring with probability $p$ for each of the 33 wires. This flips 1 bit (an odd number), so it is always **detected**.\n2. A coupled two-wire simultaneous flip on an adjacent pair, occurring with probability $q$ for each of the 32 adjacent pairs. This flips 2 bits (an even number), so it is always **undetected**.\n\nThe problem requires a rare-event approximation, where all terms of order $p^2$, $pq$, and $q^2$ are neglected. This is equivalent to assuming that at most one error event (of either type) occurs during a single transmission.\n\nUnder this approximation, the only type of event that can lead to an undetected error is a single coupled two-wire flip. The problem thus reduces to calculating the probability that one such event occurs across any of the possible locations.\n\nThe bus has a linear arrangement of 33 wires, which means there are $33 - 1 = 32$ adjacent pairs where a coupled flip can occur.\n\nLet $P_{undetected}$ be the probability of an undetected error. Let $C_i$ be the event of a coupled flip on the $i$-th adjacent pair, for $i \\in \\{1, 2, \\ldots, 32\\}$. The probability of each such event is given as $P(C_i) = q$.\n\nThe event of an undetected error is the union of all possible single coupled-flip events: $P_{undetected} = P(C_1 \\cup C_2 \\cup \\ldots \\cup C_{32})$.\n\nBecause the rare-event approximation directs us to ignore the possibility of two or more error events occurring (e.g., $C_i \\cap C_j$, which has probability $q^2$), we can treat these events as mutually exclusive. The probability of the union is therefore the sum of the individual probabilities:\n$$P_{undetected} \\approx \\sum_{i=1}^{32} P(C_i)$$\nSince there are 32 such pairs, each with a flip probability of $q$, the total probability is:\n$$P_{undetected} \\approx 32 \\times q$$\nNow, we substitute the given numerical values:\n- Number of adjacent pairs: 32\n- Probability of a coupled flip per pair: $q = 3.0 \\times 10^{-8}$\n\nThe probability of an undetected error is:\n$$P_{undetected} \\approx 32 \\times (3.0 \\times 10^{-8}) = 96 \\times 10^{-8}$$\nTo express this in standard scientific notation, we adjust the coefficient to be between 1 and 10:\n$$P_{undetected} \\approx 9.6 \\times 10^{-7}$$\nThe problem requires the answer to be rounded to four significant figures.\n$$P_{undetected} \\approx 9.600 \\times 10^{-7}$$\nThe probability $p$ for single-wire flips is not used in this calculation because single-bit errors are always detected by a parity check and thus do not contribute to the probability of an *undetected* error.", "answer": "$$\\boxed{9.600 \\times 10^{-7}}$$", "id": "3640110"}]}