{"hands_on_practices": [{"introduction": "The journey from high-level code to execution begins with translating human-readable assembly into binary machine code. This practice challenges you to step into the role of an assembler, making decisions about instruction encoding. By working with a feature inspired by real-world ISAs like RISC-V, you will explore the trade-offs between standard, fixed-width instructions and their modern compressed counterparts, gaining a tangible understanding of how these choices impact code size and efficiency [@problem_id:3655278].", "problem": "A Reduced Instruction Set Computer Five (RISC-V) 32-bit Integer base (RV32I) program is to be encoded both with only the baseline RV32I $32$-bit instructions and with the RISC-V Compressed (RVC) extension, which introduces $16$-bit encodings for certain cases. The code starts at address $0x1000$ and executes in increasing address order.\n\nYou are given the following subset of instruction semantics and encoding facts to serve as the fundamental base:\n\n- Baseline RV32I:\n  - All baseline instructions occupy $32$ bits, i.e., $4$ bytes each.\n  - Program Counter (PC) advances by the instruction width after each fetch.\n  - The semantics of the following instructions are standard:\n    - $\\mathrm{ADDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s + i$.\n    - $\\mathrm{ADD}\\ r_d, r_s1, r_s2$: $r_d \\leftarrow r_{s1} + r_{s2}$.\n    - $\\mathrm{ANDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\,\\&\\, i$.\n    - $\\mathrm{ORI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\,|\\, i$.\n    - $\\mathrm{LW}\\ r_d, u(r_s)$: $r_d \\leftarrow \\mathrm{MEM}[r_s + u]$, where $u$ is a byte offset.\n    - $\\mathrm{SW}\\ r_s2, u(r_s1)$: $\\mathrm{MEM}[r_{s1} + u] \\leftarrow r_{s2}$.\n    - $\\mathrm{BEQ}\\ r_s1, r_s2, \\mathrm{label}$: If $r_{s1} = r_{s2}$ then branch to $\\mathrm{label}$ using a PC-relative displacement $\\delta$ computed as $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$; $\\delta$ must be a signed multiple of $2$ bytes within the architectural range to be encodable.\n- RISC-V Compressed (RVC) $16$-bit forms used in this problem (all not mentioned forms are unavailable):\n  - $\\mathrm{C.ADDI}\\ r_d, i$: Available when $r_d \\neq x0$ and $i \\in \\{-32, -31, \\ldots, -1, 1, \\ldots, 31\\}$; semantics identical to $\\mathrm{ADDI}\\ r_d, r_d, i$; width $16$ bits.\n  - $\\mathrm{C.ANDI}\\ r_d, i$: Available when $r_d \\in \\{x8, x9, \\ldots, x15\\}$ and $i \\in \\{-32, -31, \\ldots, 31\\}$; semantics identical to $\\mathrm{ANDI}\\ r_d, r_d, i$; width $16$ bits.\n  - $\\mathrm{C.LW}\\ r_d, u(r_s)$: Available when $r_d, r_s \\in \\{x8, x9, \\ldots, x15\\}$ and $u$ is an unsigned byte offset that is a multiple of $4$ and lies in $\\{0, 4, 8, \\ldots, 252\\}$; semantics identical to $\\mathrm{LW}$; width $16$ bits.\n  - $\\mathrm{C.SW}\\ r_s2, u(r_s1)$: Available when $r_s2, r_s1 \\in \\{x8, x9, \\ldots, x15\\}$ and $u$ is an unsigned byte offset that is a multiple of $4$ and lies in $\\{0, 4, 8, \\ldots, 252\\}$; semantics identical to $\\mathrm{SW}$; width $16$ bits.\n  - $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$: Available when $r_s \\in \\{x8, x9, \\ldots, x15\\}$; branches if $r_s = x0$ using a displacement $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$ that must be a signed multiple of $2$ bytes within the set $\\{-256, -254, \\ldots, -2, 0, 2, \\ldots, 254\\}$; width $16$ bits.\n  - There is no $\\mathrm{C.ORI}$ in this subset; $\\mathrm{ORI}$ remains $32$-bit.\n- All memory accesses are naturally aligned and legal; the register $x0$ is hardwired to zero; the register names $x0, x1, \\ldots, x31$ refer to the standard RISC-V integer registers.\n- The notion of execution equivalence required here is that replacing a baseline instruction by its compressed form (when available) preserves the architectural state transitions for registers and memory, and preserves control flow targets.\n\nConsider the following RV32I assembly snippet, with label and base address as indicated:\n- Base address: $\\mathrm{addr}(\\mathrm{start}) = 0x1000$.\n- Code:\n  1) $\\mathrm{ADDI}\\ x8, x8, 12$\n  2) $\\mathrm{LW}\\ x9, 16(x8)$\n  3) $\\mathrm{ADD}\\ x5, x6, x7$\n  4) $\\mathrm{SW}\\ x9, 20(x8)$\n  5) $\\mathrm{ORI}\\ x10, x10, 512$\n  6) $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$\n  7) $\\mathrm{ADDI}\\ x3, x3, 100$\n  8) $\\mathrm{L1}: \\mathrm{ANDI}\\ x12, x12, 31$\n\nTasks:\n1) For each instruction, decide whether an RVC $16$-bit form as defined above applies and name it if applicable; otherwise, it remains $32$-bit.\n2) Using the RV32I-only assumption (all instructions $32$-bit), compute the address of each instruction and the branch displacement $\\delta_{\\mathrm{RV32I}}$ used by the $\\mathrm{BEQ}$ at line $6$.\n3) Using RVC wherever applicable from Task $1$, compute the address of each instruction under the mixed-width encoding and the branch displacement $\\delta_{\\mathrm{RVC}}$ used by the $\\mathrm{C.BEQZ}$ at line $6$ (if compressible).\n4) Compute the total code size in bytes for both encodings and the code-size compression ratio\n   $$R \\equiv \\frac{\\text{total compressed bytes}}{\\text{total baseline bytes}}.$$\n   Express $R$ as a reduced fraction. No rounding is required.\n5) Briefly justify that, under the stated constraints, the compressed substitutions preserve execution equivalence for this snippet.\n\nYour final answer must be the single value of $R$ only, presented as a reduced fraction with no units, and nothing else.", "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem in computer architecture, specifically concerning the RISC-V instruction set. The provided rules, though a subset of the full specification and containing specific definitions for branch displacement calculation, are self-contained and consistent.\n\nThe solution proceeds by addressing each of the five tasks outlined in the problem statement.\n\n**Task 1: RVC Applicability Analysis**\n\nWe analyze each instruction in the provided snippet to determine if it can be replaced by a $16$-bit RVC equivalent according to the given rules.\n\n1.  $\\mathrm{ADDI}\\ x8, x8, 12$: This instruction matches the form $\\mathrm{ADDI}\\ r_d, r_d, i$. The destination register is $r_d = x8$, which is not $x0$. The immediate is $i = 12$, which is within the allowed range $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ for $\\mathrm{C.ADDI}$. Thus, this instruction is compressible into $\\mathrm{C.ADDI}\\ x8, 12$. Its width is $16$ bits ($2$ bytes).\n\n2.  $\\mathrm{LW}\\ x9, 16(x8)$: The registers are $r_d = x9$ and $r_s = x8$. Both are in the required set $\\{x8, x9, \\ldots, x15\\}$ for $\\mathrm{C.LW}$. The offset is $u = 16$. This is an unsigned multiple of $4$ and falls within the allowed range $\\{0, 4, \\ldots, 252\\}$. Thus, this instruction is compressible into $\\mathrm{C.LW}\\ x9, 16(x8)$. Its width is $16$ bits ($2$ bytes).\n\n3.  $\\mathrm{ADD}\\ x5, x6, x7$: This is a three-operand register-register instruction. The problem provides no $16$-bit RVC equivalent for this form. Therefore, it remains a $32$-bit ($4$ byte) baseline instruction.\n\n4.  $\\mathrm{SW}\\ x9, 20(x8)$: The registers are $r_{s2} = x9$ and $r_{s1} = x8$. Both are in the required set $\\{x8, x9, \\ldots, x15\\}$ for $\\mathrm{C.SW}$. The offset is $u = 20$. This is an unsigned multiple of $4$ and falls within the allowed range $\\{0, 4, \\ldots, 252\\}$. Thus, this instruction is compressible into $\\mathrm{C.SW}\\ x9, 20(x8)$. Its width is $16$ bits ($2$ bytes).\n\n5.  $\\mathrm{ORI}\\ x10, x10, 512$: The problem statement explicitly notes that \"There is no $\\mathrm{C.ORI}$ in this subset\". Furthermore, the immediate value $i=512$ is far outside the typical small immediate range for RVC instructions. This instruction remains a $32$-bit ($4$ byte) baseline instruction.\n\n6.  $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$: This instruction branches if register $x10$ is equal to register $x0$ (which is hardwired to zero). This is equivalent to branching if $x10$ is zero. The RVC form $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$ is available if $r_s \\in \\{x8, \\ldots, x15\\}$. Here, $r_s = x10$, which satisfies the condition. The validity of the compression also depends on the branch displacement, which we will analyze later, but the instruction form is compressible. Assuming the displacement is valid, its width is $16$ bits ($2$ bytes).\n\n7.  $\\mathrm{ADDI}\\ x3, x3, 100$: This matches the form for potential compression to $\\mathrm{C.ADDI}$. However, the immediate is $i = 100$. This value is not in the allowed range $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$. Thus, this instruction is not compressible and remains a $32$-bit ($4$ byte) baseline instruction.\n\n8.  $\\mathrm{ANDI}\\ x12, x12, 31$: This instruction has $r_d = x12$, which is in the required set $\\{x8, \\ldots, x15\\}$ for $\\mathrm{C.ANDI}$. The immediate is $i = 31$, which is in the allowed range $\\{-32, \\ldots, 31\\}$. Thus, this instruction is compressible into $\\mathrm{C.ANDI}\\ x12, 31$. Its width is $16$ bits ($2$ bytes).\n\n**Task 2: Analysis with Baseline RV32I Instructions Only**\n\nAssuming all $8$ instructions are $32$-bit ($4$ bytes) wide, we can determine the address of each instruction starting from the base address $0x1000$.\n\n- Instruction 1 ($\\mathrm{ADDI}$): Address $ = 0x1000$\n- Instruction 2 ($\\mathrm{LW}$): Address $ = 0x1000 + 4 = 0x1004$\n- Instruction 3 ($\\mathrm{ADD}$): Address $ = 0x1004 + 4 = 0x1008$\n- Instruction 4 ($\\mathrm{SW}$): Address $ = 0x1008 + 4 = 0x100C$\n- Instruction 5 ($\\mathrm{ORI}$): Address $ = 0x100C + 4 = 0x1010$\n- Instruction 6 ($\\mathrm{BEQ}$): Address $ = 0x1010 + 4 = 0x1014$\n- Instruction 7 ($\\mathrm{ADDI}$): Address $ = 0x1014 + 4 = 0x1018$\n- Instruction 8 ($\\mathrm{L1}: \\mathrm{ANDI}$): Address $ = 0x1018 + 4 = 0x101C$\n\nThe total size of the code is $8 \\times 4 = 32$ bytes.\n\nThe branch displacement for the $\\mathrm{BEQ}$ instruction at address $\\mathrm{PC} = 0x1014$ is calculated using the provided formula $\\delta_{\\mathrm{RV32I}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$. The target label $\\mathrm{L1}$ is at address $0x101C$.\n$$ \\delta_{\\mathrm{RV32I}} = 0x101C - (0x1014 + 4) = 0x101C - 0x1018 = 4 $$\nThe displacement is $4$ bytes, which is a signed multiple of $2$ bytes and is well within the standard architectural range for a B-type instruction.\n\n**Task 3: Analysis with RVC substitutions**\n\nUsing the compressibility results from Task 1, we determine the new instruction addresses.\nCompressed sizes: $2$, $2$, $4$, $2$, $4$, $2$, $4$, $2$ bytes.\n\n- Instruction 1 ($\\mathrm{C.ADDI}$): Address $ = 0x1000$, Size $ = 2$\n- Instruction 2 ($\\mathrm{C.LW}$): Address $ = 0x1000 + 2 = 0x1002$, Size $ = 2$\n- Instruction 3 ($\\mathrm{ADD}$): Address $ = 0x1002 + 2 = 0x1004$, Size $ = 4$\n- Instruction 4 ($\\mathrm{C.SW}$): Address $ = 0x1004 + 4 = 0x1008$, Size $ = 2$\n- Instruction 5 ($\\mathrm{ORI}$): Address $ = 0x1008 + 2 = 0x100A$, Size $ = 4$\n- Instruction 6 ($\\mathrm{C.BEQZ}$): Address $ = 0x100A + 4 = 0x100E$, Size $ = 2$\n- Instruction 7 ($\\mathrm{ADDI}$): Address $ = 0x100E + 2 = 0x1010$, Size $ = 4$\n- Instruction 8 ($\\mathrm{L1}: \\mathrm{C.ANDI}$): Address $ = 0x1010 + 4 = 0x1014$, Size $ = 2$\n\nThe total size of the compressed code is $2+2+4+2+4+2+4+2 = 22$ bytes.\n\nThe branch displacement for the $\\mathrm{C.BEQZ}$ instruction at address $\\mathrm{PC} = 0x100E$ is calculated using the provided formula $\\delta_{\\mathrm{RVC}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$. The target label $\\mathrm{L1}$ is now at address $0x1014$.\n$$ \\delta_{\\mathrm{RVC}} = 0x1014 - (0x100E + 2) = 0x1014 - 0x1010 = 4 $$\nThe displacement is $4$ bytes. This value is a signed multiple of $2$ and lies in the set $\\{-256, \\dots, 254\\}$ specified for $\\mathrm{C.BEQZ}$. Therefore, the compression of the branch instruction is valid.\n\n**Task 4: Code Size and Compression Ratio**\n\n- Total baseline code size (RV32I-only): $32$ bytes.\n- Total compressed code size (with RVC): $22$ bytes.\n\nThe code-size compression ratio $R$ is defined as:\n$$ R = \\frac{\\text{total compressed bytes}}{\\text{total baseline bytes}} = \\frac{22}{32} $$\nReducing this fraction by dividing the numerator and denominator by their greatest common divisor, which is $2$:\n$$ R = \\frac{11}{16} $$\n\n**Task 5: Justification of Execution Equivalence**\n\nThe substitution of baseline instructions with their RVC forms preserves execution equivalence for this specific snippet.\n1.  **State Preservation**: For every compressible instruction ($\\mathrm{ADDI}$, $\\mathrm{LW}$, $\\mathrm{SW}$, $\\mathrm{ANDI}$), the RVC semantics are defined to be identical to their RV32I counterparts, given that the specific constraints on operands (register numbers, immediate values) are met. For example, $\\mathrm{C.ADDI}\\ r_d, i$ is semantically identical to $\\mathrm{ADDI}\\ r_d, r_d, i$. Since our analysis confirmed all constraints were met, each compressed instruction performs the exact same operation on the registers and/or memory as the original $32$-bit instruction.\n2.  **Control Flow Preservation**: The conditional branch $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$ is replaced by $\\mathrm{C.BEQZ}\\ x10, \\mathrm{L1}$. Both branch if and only if the content of register $x10$ is zero. The branch target is the label $\\mathrm{L1}$. Although the absolute address of $\\mathrm{L1}$ changes between the two encodings (from $0x101C$ to $0x1014$), the branch instructions use PC-relative addressing. We calculated the displacements ($\\delta_{\\mathrm{RV32I}} = 4$ and $\\delta_{\\mathrm{RVC}} = 4$) and confirmed they correctly encode the jump from the branch instruction to the target instruction in their respective memory layouts. Since the branching condition and the logical target are the same, the control flow is preserved.\n\nTherefore, the sequence of architectural state changes is identical for both program encodings.", "answer": "$$\\boxed{\\frac{11}{16}}$$", "id": "3655278"}, {"introduction": "Beyond single instructions, assembly language is used to build the fundamental control-flow structures that underpin our programs. This exercise guides you through the implementation of a relocation-free jump table, a mechanism often used by compilers to implement `switch-case` statements efficiently. You will formalize the logic for calculating target addresses in a way that is independent of where the code is loaded in memory, a critical concept for creating modern, shareable libraries [@problem_id:3655275].", "problem": "You are asked to formalize and implement, in a general-purpose programming language, the core idea behind a relocation-free jump table as found in machine language and assembly. The fundamental base is the definition of the Program Counter (PC), which in a typical Instruction Set Architecture (ISA) is a byte-addressed register that points to the current instruction to be executed. In a table-driven control transfer mechanism, a block of contiguous code entries of equal size may serve as jump targets selected by an index.\n\nStarting from the fundamental definitions:\n- The Program Counter $PC$ is a byte address.\n- A code region is characterized by a base address $B$, a fixed stride $S$ in bytes per entry, and a logical capacity $n$ entries.\n- Indexing must be invariant under relocation: if both the region and $PC$ are shifted by a displacement $\\delta$, the computed index must be unchanged.\n- Alignment and bounds correctness are required: only entries aligned to the declared stride and within the logical capacity are valid targets.\n- Sparsity is permitted: some logical indices may deliberately have no assigned handler.\n\nYour task is to derive from these definitions the normalization procedure that maps $PC$ to a logical index $i$ for the table, with all necessary checks for bounds and alignment, and with graceful handling of sparse indices. You must then implement this procedure in a complete, runnable program that, given a small test suite of parameter sets, computes the selected handler identifier or a well-defined error code.\n\nImplementation model and correctness requirements:\n- Treat addresses as byte addresses. Use non-negative integers for handler identifiers. Use negative handler identifiers to denote sparse (missing) entries.\n- The result for each test case must be one integer:\n  - Return a non-negative integer equal to the handler identifier when the normalized index is valid and the entry is present.\n  - Return $-1$ if the $PC$ is out of bounds for the region specified by $B$, $S$, and $n$.\n  - Return $-2$ if the $PC$ is within bounds but not aligned to the stride $S$.\n  - Return $-3$ if the normalized index is valid but the entry is sparse (missing).\n- The normalization must be relocation-free: for any displacement $\\delta$, if $B \\mapsto B + \\delta$ and $PC \\mapsto PC + \\delta$, the computed index $i$ must be identical.\n\nTest suite:\nProvide results for the following test cases, each specified by $(B, S, n, PC, \\text{handlers}[0..n-1])$ with addresses in hexadecimal literals and strides and capacities in decimal. Handlers are in decimal, and any negative handler denotes a missing entry.\n\n- Case A (happy path): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 2 \\cdot 8, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case B (out-of-bounds below): $(B = 0x1000, S = 8, n = 5, PC = 0x0, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case C (misaligned within bounds): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 3 \\cdot 8 + 4, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case D (sparse missing entry): $(B = 0x2000, S = 4, n = 6, PC = 0x2000 + 3 \\cdot 4, \\text{handlers} = [0, -1, 2, -1, 4, 5])$.\n- Case E (relocation invariance): $(B = 0x1000 + 0x300, S = 8, n = 5, PC = (0x1000 + 2 \\cdot 8) + 0x300, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case F (upper boundary inclusive): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 3 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- Case G (end boundary exclusive): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 4 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- Case H (large stride): $(B = 0x80000000, S = 512, n = 3, PC = 0x80000000 + 512, \\text{handlers} = [7, 8, 9])$.\n- Case I (base entry): $(B = 0x5000, S = 32, n = 2, PC = 0x5000, \\text{handlers} = [42, 43])$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_A,\\text{result}_B,\\dots]$). No other text should be printed.", "solution": "The problem is well-defined, scientifically grounded in the principles of computer architecture, and provides a complete set of specifications for deriving and implementing a procedure. It contains no contradictions or ambiguities. Therefore, the problem is deemed valid.\n\nThe task is to formalize and implement a procedure that maps a program counter address, $PC$, to a logical index, $i$, for a relocation-free jump table. The table is defined by a base address $B$, a fixed-size stride $S$ per entry, and a total capacity of $n$ entries. The procedure must perform all necessary checks for bounds and alignment, and handle sparse entries.\n\nThe derivation of the normalization procedure proceeds step-by-step from the given requirements.\n\n1.  **Relocation Invariance**: The fundamental constraint is that the indexing mechanism must be position-independent. This means that if the entire code segment, including the jump table and the current program counter, is relocated by some displacement $\\delta$, the computed index must remain unchanged. Let the original base address be $B$ and the program counter be $PC$. After relocation, the new addresses are $B' = B + \\delta$ and $PC' = PC + \\delta$. For the index to be invariant, its calculation must depend only on the relative offset between $PC$ and $B$, which is $\\Delta = PC - B$. This is because the new offset $\\Delta' = PC' - B' = (PC + \\delta) - (B + \\delta) = PC - B = \\Delta$. Thus, all subsequent checks and calculations must be based on this relative offset, $\\Delta$. For computational purposes, addresses are treated as non-negative unsigned integers.\n\n2.  **Bounds Checking**: The jump table consists of $n$ entries, each of size $S$ bytes. The memory region occupied by the table starts at address $B$ and ends immediately before address $B + n \\cdot S$. Therefore, the valid range of addresses for any target within the table is $[B, B + n \\cdot S)$. A given program counter $PC$ is within the bounds of this region if and only if the condition $B \\le PC < B + n \\cdot S$ is satisfied. This is the first check to be performed. If $PC$ is outside this range, it is considered out of bounds. The problem specifies that in this case, the procedure must return the error code $-1$.\n\n3.  **Alignment Checking**: A valid jump target must correspond to the beginning of one of the table entries. The addresses of these entry points are $B$, $B+S$, $B+2S$, ..., $B+(n-1)S$. This implies that the relative offset of $PC$ from the base $B$, which is $\\Delta = PC - B$, must be an integer multiple of the stride $S$. This property is known as alignment. It can be verified by checking if the remainder of the division of $\\Delta$ by $S$ is zero. That is, $(PC - B) \\pmod S = 0$. This check should be performed for any $PC$ that is within bounds. If an in-bounds $PC$ is not aligned to the stride $S$, the procedure must return the error code $-2$.\n\n4.  **Index Calculation**: If a $PC$ passes both the bounds and alignment checks, it points to a valid entry. The logical index $i$ of this entry corresponds to how many strides of size $S$ are contained in the offset from the base address. This is calculated using integer division:\n    $$i = \\frac{PC - B}{S}$$\n    Given the bounds check ($0 \\le PC - B < n \\cdot S$), the calculated index $i$ is guaranteed to be within the valid range for an array of size $n$, i.e., $0 \\le i < n$.\n\n5.  **Sparsity Handling**: The problem permits \"sparse\" tables, where certain logical indices may not have a corresponding handler. These sparse entries are denoted by negative values in the provided `handlers` array. After a valid index $i$ is calculated, the procedure must retrieve the handler identifier from `handlers`[$i$]. If this value is negative (i.e., $\\text{handlers}[i] < 0$), it signifies a sparse entry. In this case, the procedure must return the error code $-3$.\n\n6.  **Successful Lookup**: If the retrieved handler identifier is non-negative (i.e., $\\text{handlers}[i] \\ge 0$), the lookup is successful. The procedure's final result is this non-negative handler identifier.\n\nIn summary, the complete algorithm for a given set of parameters $(B, S, n, PC, \\text{handlers})$ is as follows:\n1.  Check if $PC < B$ or $PC \\ge B + n \\cdot S$. If true, return $-1$.\n2.  Calculate the offset $\\Delta = PC - B$.\n3.  Check if $\\Delta \\pmod S \\neq 0$. If true, return $-2$.\n4.  Calculate the index $i = \\Delta / S$.\n5.  Retrieve the handler identifier $h = \\text{handlers}[i]$.\n6.  Check if $h < 0$. If true, return $-3$.\n7.  Otherwise, return $h$.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    unsigned long long B;\n    int S;\n    int n;\n    unsigned long long PC;\n    const int* handlers;\n} TestCase;\n\n/**\n * @brief Computes the handler identifier for a given Program Counter (PC)\n *        based on a jump table's properties.\n *\n * @param tc The TestCase struct containing B, S, n, PC, and handlers.\n * @return An integer representing the handler ID or an error code:\n *         - Non-negative: The handler identifier.\n *         - -1: PC is out of bounds.\n *         - -2: PC is misaligned.\n *         - -3: The entry is sparse (missing).\n */\nint get_handler_id(TestCase tc) {\n    // 1. Bounds Checking\n    // The valid memory region is [B, B + n * S).\n    // An unsigned long long is used for the region end to prevent overflow\n    // with large addresses or strides.\n    unsigned long long region_end = tc.B + (unsigned long long)tc.n * tc.S;\n    if (tc.PC < tc.B || tc.PC >= region_end) {\n        return -1; // Out of bounds\n    }\n\n    // 2. Alignment Checking\n    // The offset from the base must be a multiple of the stride.\n    unsigned long long offset = tc.PC - tc.B;\n    if (offset % tc.S != 0) {\n        return -2; // Misaligned\n    }\n\n    // 3. Index Calculation\n    int index = offset / tc.S;\n\n    // 4. Sparsity Handling\n    int handler_id = tc.handlers[index];\n    if (handler_id < 0) {\n        return -3; // Sparse entry\n    }\n\n    // 5. Successful Lookup\n    return handler_id;\n}\n\nint main(void) {\n    // Define the handler arrays for the test cases.\n    const int handlers_A_B_C_E[] = {10, 11, 12, 13, 14};\n    const int handlers_D[] = {0, -1, 2, -1, 4, 5};\n    const int handlers_F_G[] = {100, 101, 102, 103};\n    const int handlers_H[] = {7, 8, 9};\n    const int handlers_I[] = {42, 43};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Case A (happy path)\n        {0x1000, 8, 5, 0x1000 + 2 * 8, handlers_A_B_C_E},\n        // Case B (out-of-bounds below)\n        {0x1000, 8, 5, 0x0, handlers_A_B_C_E},\n        // Case C (misaligned within bounds)\n        {0x1000, 8, 5, 0x1000 + 3 * 8 + 4, handlers_A_B_C_E},\n        // Case D (sparse missing entry)\n        {0x2000, 4, 6, 0x2000 + 3 * 4, handlers_D},\n        // Case E (relocation invariance)\n        {0x1000 + 0x300, 8, 5, (0x1000 + 2 * 8) + 0x300, handlers_A_B_C_E},\n        // Case F (upper boundary inclusive)\n        {0x3000, 16, 4, 0x3000 + 3 * 16, handlers_F_G},\n        // Case G (end boundary exclusive)\n        {0x3000, 16, 4, 0x3000 + 4 * 16, handlers_F_G},\n        // Case H (large stride) - use ULL suffix for 64-bit constant\n        {0x80000000ULL, 512, 3, 0x80000000ULL + 512, handlers_H},\n        // Case I (base entry)\n        {0x5000, 32, 2, 0x5000, handlers_I},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = get_handler_id(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3655275"}, {"introduction": "When separate pieces of software, potentially from different compilers or for different hardware, need to communicate, they must agree on a common language. This 'language' is the Application Binary Interface (ABI), a set of rules governing data layout, function calls, and register usage. This practice presents a realistic debugging scenario where you must diagnose a system failure by identifying violations of the ABI, including endianness conflicts, data alignment errors, and improper register handling, demonstrating why these low-level details are critical for robust software systems [@problem_id:3655203].", "problem": "A producer module $P$ and a consumer module $C$ communicate via a shared-memory ring buffer. $P$ runs on a big-endian $64$-bit Microprocessor without Interlocked Pipeline Stages ($\\text{MIPS64}$, big-endian) using its native Application Binary Interface (ABI), and $C$ runs on a little-endian $64$-bit $\\text{x86\\_64}$ system using the System V AMD64 Application Binary Interface (ABI). The Instruction Set Architecture (ISA) thus differs across the two modules. Both sides used the same C source declaration of a message record with fields: an unsigned $8$-bit tag, an unsigned $32$-bit identifier, and an unsigned $16$-bit length. Prior to writing each record, $P$ zero-initializes the entire record storage it will write into.\n\nIn one ring slot written by $P$, the field values are: tag $=\\texttt{0x12}$, identifier $=\\texttt{0xAABBCCDD}$, length $=\\texttt{0x0021}$. A raw byte dump of the $P$-written slot as observed by $C$ reads (in increasing address order within the slot):\n$\\left[\\texttt{0x12},\\texttt{0x00},\\texttt{0x00},\\texttt{0x00},\\texttt{0xAA},\\texttt{0xBB},\\texttt{0xCC},\\texttt{0xDD},\\texttt{0x00},\\texttt{0x21},\\texttt{0x00},\\texttt{0x00}\\right]$.\n\nThe consumer $C$ parses the first slot using fixed offsets $0$ for the tag, $4$ for the identifier, and $8$ for the length, and prints: identifier $=\\texttt{0xDDCCBBAA}$, length $=\\texttt{0x2100}$. However, to advance to the next slot, $C$ increments its pointer by $\\lvert\\text{Msg}\\rvert$ computed at compile time from its own structure definition, which in $C$’s build is $\\texttt{7}$ bytes due to a translation-unit-local packing directive. After several iterations, $C$ is observed to desynchronize from $P$’s slot boundaries.\n\nAdditionally, $C$ invokes a callback function pointer published by $P$ through a small machine-language thunk on $\\text{x86\\_64}$. After returning from this callback, a loop index that $C$ keeps in the $\\mathrm{RBX}$ register has changed unexpectedly, even though $C$’s own code did not modify it between uses. Examination of the thunk reveals that it saves and restores $\\mathrm{RBP}$ and $\\mathrm{R12}$–$\\mathrm{R15}$, but not $\\mathrm{RBX}$.\n\nWhich of the following root causes must be present to explain all of the observations? Select all that apply.\n\nA. The two modules disagree on the byte order of multi-byte fields: $P$ is big-endian and $C$ is little-endian, so the same byte sequence yields reversed multi-byte values when interpreted by $C$.\n\nB. The two modules use different structure packing and alignment, so $P$ writes slots whose size includes padding that $C$’s packed layout omits, causing $C$’s stride of $\\texttt{7}$ bytes to drift relative to $P$’s larger slot size.\n\nC. The callback invocation violates the caller–callee register preservation rules on $\\text{x86\\_64}$ System V AMD64 by allowing the callee (via the thunk) to clobber $\\mathrm{RBX}$, which the ABI requires the callee to preserve.\n\nD. The observed reversal in the $32$-bit identifier within a slot can be fully explained by structure padding alone, even if both sides used the same endianness.\n\nE. Matching the total structure size on both sides to $\\texttt{12}$ bytes with explicit tail padding would remove the identifier and length reversals, even if endianness remains different.", "solution": "To explain all three observed system failures, we must analyze each phenomenon and identify its direct cause among the provided options.\n\n1.  **Incorrect Data Values (`identifier` and `length`):** The producer $P$ on a big-endian system writes the $32$-bit integer $\\texttt{0xAABBCCDD}$ into memory as the byte sequence `[AA, BB, CC, DD]`. The consumer $C$ on a little-endian system reads this sequence and interprets the byte at the lowest address as the least significant, reconstructing the value as $\\texttt{0xDDCCBBAA}$. The same logic applies to the $16$-bit length, which is read as $\\texttt{0x2100}$ instead of $\\texttt{0x0021}$. This byte-swapping is a direct consequence of the producer and consumer having different endianness. **Therefore, root cause A must be present.**\n\n2.  **Ring Buffer Desynchronization:** The producer $P$ uses its native MIPS64 ABI, which enforces data alignment. For a structure containing an $8$-bit, a $32$-bit, and a $16$-bit field, the compiler adds padding bytes to align each field to its natural boundary and to pad the total structure size. The provided $12$-byte raw dump confirms this, showing a layout with padding. Thus, $P$ writes records that are $12$ bytes long. The consumer $C$, however, uses a packing directive that eliminates all padding, resulting in a structure size of $1+4+2=7$ bytes. When $C$ increments its read pointer by $7$ bytes per record while $P$ writes $12$-byte records, their positions will inevitably drift apart. **Therefore, root cause B must be present.**\n\n3.  **Register Corruption (`RBX`):** The consumer $C$ runs on an $\\text{x86\\_64}$ system using the System V AMD64 ABI. In this ABI, the $\\mathrm{RBX}$ register is defined as \"callee-saved.\" This means any called function (the \"callee\") must preserve the value of $\\mathrm{RBX}$ and restore it before returning to the caller. The problem states that the thunk (the callee) modifies $\\mathrm{RBX}$ but does not save and restore it. This is a direct violation of the ABI contract, which explains why the caller's loop index stored in $\\mathrm{RBX}$ is corrupted. **Therefore, root cause C must be present.**\n\n**Analysis of other options:**\n- **D:** Structure padding inserts bytes between or after fields; it does not reorder the bytes *within* a multi-byte integer. The observed byte reversal is exclusively an endianness issue.\n- **E:** Matching the total structure size would solve the desynchronization problem (cause B), but it would not change how each system interprets the byte order within the multi-byte fields. The data would still appear reversed due to the endianness mismatch (cause A).\n\nSince the three observations are independent, all three root causes (A, B, and C) must be present to explain the complete set of failures.", "answer": "$$\n\\boxed{ABC}\n$$", "id": "3655203"}]}