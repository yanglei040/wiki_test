{"hands_on_practices": [{"introduction": "Before we can analyze cache performance, we must first understand its fundamental structure. This exercise guides you through the process of deconstructing a physical memory address into its constituent parts—tag, index, and offset—based on a cache's high-level specifications. By determining these parameters for a set-associative cache [@problem_id:3635260], you are effectively drawing the blueprint that dictates how all memory requests are mapped and located.", "problem": "A byte-addressable processor uses 32-bit physical addresses and a physically indexed, physically tagged data cache. The cache has a total data capacity of $32\\,\\mathrm{KiB}$ and uses blocks of size $64\\,\\mathrm{B}$. The cache is 4-way set-associative. Ignore all metadata overhead (such as valid bits, dirty bits, or replacement state) when reasoning about capacity.\n\nStarting only from the fundamental definitions that a physical address is partitioned into a tag field of $t$ bits, an index field of $i$ bits that selects a set, and a block offset of $o$ bits that selects a byte within a block, and that set-associativity organizes the cache into sets each containing a fixed number of blocks, determine the values of the tag size $t$, the index size $i$, the block offset size $o$, and the number of sets $S$ for this cache.\n\nProvide your final answer as the ordered quadruple $\\left(t,\\, i,\\, o,\\, S\\right)$. No rounding is required, and no units should be included in the final answer.", "solution": "The problem is well-posed and scientifically grounded within the domain of computer organization and architecture. All necessary parameters are provided, and there are no contradictions. We can proceed with a formal derivation.\n\nThe problem asks for the determination of four parameters for a set-associative cache: the tag size $t$, the index size $i$, the block offset size $o$, and the number of sets $S$. The solution is derived from the fundamental principles governing cache memory organization. A physical address is partitioned into three fields: a tag, an index, and a block offset.\n\nThe total size of the physical address is given as $32$ bits. This gives the primary relationship:\n$$t + i + o = 32$$\n\nWe will determine each of the parameters $o$, $i$, $S$, and finally $t$ in a logical sequence.\n\nFirst, we determine the block offset size, $o$. The processor is byte-addressable, and a cache block contains multiple bytes. The block offset is the portion of the address used to select a specific byte within a block. The number of bits required for the offset, $o$, is determined by the block size, $B$.\nThe given block size is $B = 64\\,\\mathrm{B}$. To uniquely address $64$ bytes, we require a number of bits $o$ such that $2^o = 64$.\n$$o = \\log_{2}(64) = \\log_{2}(2^{6}) = 6$$\nThus, the block offset field is $6$ bits long.\n\nNext, we determine the number of sets, $S$. The total data capacity of the cache, $C$, is given as $32\\,\\mathrm{KiB}$, and the associativity, $k$, is given as $4$-way. We must first convert the cache capacity to bytes. Using the fact that $1\\,\\mathrm{KiB} = 2^{10}\\,\\mathrm{B} = 1024\\,\\mathrm{B}$:\n$$C = 32\\,\\mathrm{KiB} = 32 \\times 2^{10}\\,\\mathrm{B} = 2^{5} \\times 2^{10}\\,\\mathrm{B} = 2^{15}\\,\\mathrm{B}$$\nThe total number of blocks in the cache, $N_{blocks}$, is the total capacity divided by the block size:\n$$N_{blocks} = \\frac{C}{B} = \\frac{2^{15}\\,\\mathrm{B}}{64\\,\\mathrm{B}} = \\frac{2^{15}}{2^{6}} = 2^{15-6} = 2^{9} = 512$$\nSo, the cache contains a total of $512$ blocks.\nIn a $k$-way set-associative cache, these blocks are organized into sets, where each set contains $k$ blocks. The number of sets, $S$, is the total number of blocks divided by the associativity $k$.\n$$S = \\frac{N_{blocks}}{k} = \\frac{512}{4} = \\frac{2^{9}}{2^{2}} = 2^{9-2} = 2^{7} = 128$$\nThe cache has $128$ sets.\n\nNow we can determine the index size, $i$. The index field of the address is used to select which of the $S$ sets a memory block maps to. The number of bits required for the index, $i$, is determined by the number of sets.\n$$i = \\log_{2}(S) = \\log_{2}(128) = \\log_{2}(2^{7}) = 7$$\nThe index field is therefore $7$ bits long.\n\nFinally, we determine the tag size, $t$. The remaining bits of the physical address form the tag. We use the initial relationship for the physical address partition:\n$$t + i + o = 32$$\nSubstituting the values we have found for $i$ and $o$:\n$$t + 7 + 6 = 32$$\n$$t + 13 = 32$$\n$$t = 32 - 13 = 19$$\nThe tag field is $19$ bits long.\n\nIn summary, the calculated parameters for the cache are:\n- Tag size, $t = 19$ bits.\n- Index size, $i = 7$ bits.\n- Block offset size, $o = 6$ bits.\n- Number of sets, $S = 128$.\n\nThe final answer is requested as the ordered quadruple $(t, i, o, S)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n19 & 7 & 6 & 128\n\\end{pmatrix}\n}\n$$", "id": "3635260"}, {"introduction": "A cache's performance is not always optimal; in fact, certain access patterns can lead to a worst-case scenario known as \"thrashing,\" where every access results in a miss. This practice [@problem_id:3625110] challenges you to construct such an adversarial trace for a simple direct-mapped cache and analyze its dramatic effect on performance by calculating the Average Memory Access Time (AMAT). This exploration vividly demonstrates why understanding memory access patterns is critical and motivates the need for more advanced cache designs like set-associativity.", "problem": "A byte-addressed machine uses a single-level, direct-mapped cache with associativity $A=1$, number of sets $S=64$, and block size $B=64$ bytes. The cache begins empty. Consider read-only accesses of aligned blocks. You will analyze a deliberately adversarial access pattern with $2$-cycle periodicity that maximally thrashes this cache.\n\nTask:\n1) Construct two distinct block-aligned addresses $x$ and $y$ such that repeatedly alternating accesses $x,y,x,y,\\dots$ produce maximal thrashing in this direct-mapped cache. Justify your choice by explicitly computing the set index and tag for each of $x$ and $y$ using the standard decomposition of $\\lfloor \\text{addr}/B \\rfloor$ into a set index in $\\{0,\\dots,S-1\\}$ and a tag, and by showing that the two blocks map to the same set but have different tags.\n\n2) Starting from the empty cache, argue from first principles what the steady-state miss rate of the alternating trace $x,y,x,y,\\dots$ must be.\n\n3) Given a cache hit time of $t_{h}=0.85$ nanoseconds and a miss penalty of $t_{m}=73.6$ nanoseconds (defined as the additional latency beyond the hit time when a miss occurs), compute the Average Memory Access Time (AMAT) for the alternating trace in steady state. Express your final AMAT in nanoseconds and round your answer to four significant figures.\n\nYour final submitted answer must be the single numerical value for the AMAT as specified above. All intermediate reasoning, including the mapping justification for your chosen $x$ and $y$, should be shown in your working.", "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n**Step 1: Extract Givens**\n- Machine addressing: Byte-addressed\n- Cache level: Single-level\n- Cache mapping: Direct-mapped (associativity $A=1$)\n- Number of cache sets: $S=64$\n- Block size: $B=64$ bytes\n- Initial cache state: Empty\n- Access characteristics: Read-only, aligned blocks\n- Access trace: Repeatedly alternating accesses $x, y, x, y, \\dots$\n- Objective: Maximal thrashing\n- Cache hit time: $t_h=0.85$ nanoseconds\n- Cache miss penalty: $t_m=73.6$ nanoseconds (defined as additional latency beyond hit time)\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it deals with fundamental principles of computer architecture, specifically cache memory organization and performance evaluation. The parameters given ($S=64$, $B=64$ bytes, $A=1$) are standard and realistic for a simple cache model. The terminology used, such as \"byte-addressed\", \"direct-mapped\", \"block size\", \"miss penalty\", and \"AMAT\", is precise and standard. The problem is well-posed; it asks for the construction of an example demonstrating a specific behavior (thrashing) and the calculation of a resulting performance metric (AMAT), for which all necessary data is provided. The definition of \"miss penalty\" as an *additional* time is explicitly stated, removing ambiguity. The problem is objective, complete, and contains no contradictions or scientifically unsound premises.\n\n**Verdict:** The problem is valid.\n\n**Solution**\n\nThe analysis proceeds in three parts as requested by the problem statement.\n\n**Part 1: Construction of Addresses for Maximal Thrashing**\n\nA memory address is partitioned into three fields: tag, set index, and block offset. We first determine the number of bits for each field.\nThe machine is byte-addressed.\nThe block size is $B=64$ bytes. The number of bits for the block offset is $\\log_2(B) = \\log_2(64) = 6$ bits.\nThe number of sets is $S=64$. The number of bits for the set index is $\\log_2(S) = \\log_2(64) = 6$ bits.\nThe remaining high-order bits of the address constitute the tag.\n\nAn address `addr` is mapped to a cache set using the formula for the set index:\n$$ \\text{Set Index} = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod S $$\nThe tag is computed as:\n$$ \\text{Tag} = \\left\\lfloor \\frac{\\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{\\text{addr}}{B \\times S} \\right\\rfloor $$\nThe term $\\lfloor \\text{addr}/B \\rfloor$ is the block address.\n\nMaximal thrashing for a direct-mapped cache under an alternating access pattern $x,y,x,y,\\dots$ occurs when the memory blocks corresponding to addresses $x$ and $y$ map to the same cache set but are distinct blocks (i.e., have different tags). This ensures that each access evicts the block needed for the subsequent access.\n\nThe problem states that accesses are to aligned blocks. An address `addr` is block-aligned if it is a multiple of the block size $B$. This means $\\text{addr} \\pmod B = 0$.\n\nWe need to find two distinct block-aligned addresses, $x$ and $y$, such that:\n1. $\\text{SetIndex}(x) = \\text{SetIndex}(y)$\n2. $\\text{Tag}(x) \\neq \\text{Tag}(y)$\n\nLet's choose an arbitrary set index, for instance, set $1$.\nWe require $\\lfloor x/B \\rfloor \\pmod S = 1$ and $\\lfloor y/B \\rfloor \\pmod S = 1$.\n\nLet's construct address $x$. We choose the simplest block address that maps to set $1$, which is the block address $1$.\nLet $\\lfloor x/B \\rfloor = 1$. Since $x$ must be block-aligned, we have $x = 1 \\times B = 1 \\times 64 = 64$.\nFor $x=64$:\n- Block address: $\\lfloor 64/64 \\rfloor = 1$.\n- Set Index: $1 \\pmod{64} = 1$.\n- Tag: $\\lfloor 1/64 \\rfloor = 0$.\n\nNow, let's construct address $y$. We need another block address that also maps to set $1$ but has a different tag. This means the block address must be of the form $k \\cdot S + 1$ for some integer $k$, where the tag $\\lfloor (k \\cdot S + 1)/S \\rfloor = k$ is different from the tag of $x$, which is $0$.\nLet's choose the simplest non-zero integer for $k$, which is $k=1$.\nThe new block address is $1 \\cdot S + 1 = 1 \\cdot 64 + 1 = 65$.\nLet $\\lfloor y/B \\rfloor = 65$. Since $y$ must be block-aligned, we have $y = 65 \\times B = 65 \\times 64 = 4160$.\nFor $y=4160$:\n- Block address: $\\lfloor 4160/64 \\rfloor = 65$.\n- Set Index: $65 \\pmod{64} = 1$.\n- Tag: $\\lfloor 65/64 \\rfloor = 1$.\n\nThe chosen addresses are $x=64$ and $y=4160$. Both are block-aligned. They both map to set index $1$. Their tags, $0$ and $1$, are different. Thus, they satisfy all conditions for causing maximal thrashing.\n\n**Part 2: Steady-State Miss Rate**\n\nWe analyze the trace $x,y,x,y,\\dots$ starting from an empty cache.\n1. Access $x$: The cache is empty. This is a compulsory miss. The block containing address $x$ is fetched from memory and placed into set $1$. The tag stored in set $1$ is $\\text{Tag}(x)$.\n2. Access $y$: The processor requests address $y$. The hardware checks set $1$. The tag stored in set $1$ is $\\text{Tag}(x)$, which does not match $\\text{Tag}(y)$. This is a conflict miss. The block for $x$ is evicted, and the block for $y$ is fetched and placed into set $1$. The tag is updated to $\\text{Tag}(y)$.\n3. Access $x$: The processor requests address $x$. The hardware checks set $1$. The tag stored is now $\\text{Tag}(y)$, which does not match $\\text{Tag}(x)$. This is another conflict miss. The block for $y$ is evicted and replaced by the block for $x$.\n4. Access $y$: This access will again be a conflict miss, evicting the block for $x$.\n\nThe steady state is reached after the first access. In this state, every subsequent access results in a conflict miss. The block needed for the current access is never the one present in the cache because it was evicted by the immediately preceding access.\nTherefore, in the steady state, every access is a miss.\nThe miss rate is the ratio of misses to total accesses. In steady state, this is $1/1$.\n$$ \\text{Miss Rate} = 1 $$\n\n**Part 3: Average Memory Access Time (AMAT)**\n\nThe Average Memory Access Time (AMAT) is the weighted average of the time for a hit and the time for a miss. The general formula is:\n$$ \\text{AMAT} = (\\text{Hit Rate} \\times \\text{Time}_\\text{hit}) + (\\text{Miss Rate} \\times \\text{Time}_\\text{miss}) $$\nThe problem defines the miss penalty ($t_m$) as the *additional* time required on a miss, beyond the hit time ($t_h$).\nSo, $\\text{Time}_\\text{hit} = t_h$.\nAnd $\\text{Time}_\\text{miss} = t_h + t_m$.\n\nSubstituting these into the AMAT formula:\n$$ \\text{AMAT} = ((1 - \\text{Miss Rate}) \\times t_h) + (\\text{Miss Rate} \\times (t_h + t_m)) $$\nSimplifying this expression:\n$$ \\text{AMAT} = t_h - (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_h) + (\\text{Miss Rate} \\times t_m) $$\n$$ \\text{AMAT} = t_h + (\\text{Miss Rate} \\times t_m) $$\n\nWe are given the following values:\n- Hit time $t_h = 0.85$ ns.\n- Miss penalty $t_m = 73.6$ ns.\n- From Part 2, the steady-state Miss Rate is $1$.\n\nSubstituting these values into the derived formula:\n$$ \\text{AMAT} = 0.85 + (1 \\times 73.6) $$\n$$ \\text{AMAT} = 0.85 + 73.6 $$\n$$ \\text{AMAT} = 74.45 \\text{ ns} $$\n\nThe problem asks for the answer to be rounded to four significant figures. The calculated value $74.45$ already has exactly four significant figures.", "answer": "$$\\boxed{74.45}$$", "id": "3625110"}, {"introduction": "When a cache set is full and a new block must be brought in, which existing block should be evicted? This crucial decision is governed by the cache's replacement policy, and the choice of algorithm can significantly impact performance. In this hands-on simulation [@problem_id:3635229], you will trace a sequence of memory accesses on a set-associative cache, comparing the outcomes of the popular Least Recently Used (LRU) policy against a Random policy to see firsthand how different strategies handle contention.", "problem": "Consider a cache on a 32-bit system configured as a 2-way set-associative cache with $S=2$ sets ($E=2$ lines per set) and block size $B=64$ bytes. The set index for a memory address $a$ is defined by the fundamental mapping rule $i=\\left\\lfloor \\frac{a}{B} \\right\\rfloor \\bmod S$, and the tag is the remaining higher-order bits of $\\left\\lfloor \\frac{a}{B} \\right\\rfloor$. Assume a cold-start (initially empty cache), write-allocate on misses, and that only reads occur. Define the replacement policies precisely: Least Recently Used (LRU) always evicts the line whose block has been unused for the longest time within its set; Random replacement (RAND) chooses uniformly between the $E$ lines in the set when an eviction is required. For reproducibility, when RAND must evict, use the following deterministic tie-breaking surrogate for randomness: for the k-th eviction encountered in the trace, a fixed coin outcome $c_{k} \\in \\{H,T\\}$ is provided, where $H$ means evict the least recently used (LRU) line and $T$ means evict the most recently used (MRU) line.\n\nYou are given the following address trace (in bytes):\n$$[\\,0,\\;128,\\;256,\\;0,\\;128,\\;0,\\;128,\\;0,\\;128,\\;256,\\;0,\\;128\\,]$$\nand the corresponding coin outcomes for RAND in the order of evictions encountered:\n$$[\\,T,\\;T,\\;T,\\;T,\\;T,\\;T,\\;H,\\;H\\,].$$\n\nTasks:\n- Using only the above fundamental definitions of set-associative caches and replacement, determine the total number of misses under LRU, $M_{\\text{LRU}}$, and under RAND with the fixed outcomes, $M_{\\text{rand}}$.\n- For each conflict (an access that misses when its target set is full), identify exactly which block is evicted under LRU and under RAND.\n- Express your final answer as the single scalar difference $M_{\\text{rand}} - M_{\\text{LRU}}$. No rounding is needed, and no units are required.", "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem in computer organization and architecture, containing all necessary parameters, definitions, and data for a unique solution. The setup adheres to established principles of cache memory operation.\n\nThe core of the problem is to simulate the behavior of a 2-way set-associative cache under two different replacement policies, Least Recently Used (LRU) and a deterministic variant of Random (RAND), for a given memory address trace.\n\nFirst, we must analyze the cache geometry and the memory address mapping.\nThe system has 32-bit addresses.\nCache parameters are:\n- Number of sets, $S = 2$.\n- Associativity (lines per set), $E = 2$.\n- Block size, $B = 64$ bytes.\n\nThe number of bits for the block offset is $\\log_2(B) = \\log_2(64) = 6$ bits.\nThe number of bits for the set index is $\\log_2(S) = \\log_2(2) = 1$ bit.\nThe remaining bits are for the tag: $32 - 6 - 1 = 25$ bits.\n\nThe set index $i$ for a byte address $a$ is given by $i = \\lfloor \\frac{a}{B} \\rfloor \\bmod S$.\nThe tag $t$ is the higher-order part of the block address $\\lfloor \\frac{a}{B} \\rfloor$, specifically $t = \\left\\lfloor \\frac{\\lfloor a/B \\rfloor}{S} \\right\\rfloor = \\left\\lfloor \\frac{a}{B \\times S} \\right\\rfloor$.\nWith $B=64$ and $S=2$, the formulas are:\n- Set index: $i = \\lfloor \\frac{a}{64} \\rfloor \\bmod 2$.\n- Tag: $t = \\lfloor \\frac{a}{128} \\rfloor$.\n\nLet's compute the set index and tag for the unique addresses in the trace: $[\\,0, 128, 256\\,]$.\n- For address $a=0$:\n  - Block address: $\\lfloor 0/64 \\rfloor = 0$.\n  - Set index: $0 \\bmod 2 = 0$.\n  - Tag: $\\lfloor 0/128 \\rfloor = 0$. Let's denote this as $t_0$.\n- For address $a=128$:\n  - Block address: $\\lfloor 128/64 \\rfloor = 2$.\n  - Set index: $2 \\bmod 2 = 0$.\n  - Tag: $\\lfloor 128/128 \\rfloor = 1$. Let's denote this as $t_1$.\n- For address $a=256$:\n  - Block address: $\\lfloor 256/64 \\rfloor = 4$.\n  - Set index: $4 \\bmod 2 = 0$.\n  - Tag: $\\lfloor 256/128 \\rfloor = 2$. Let's denote this as $t_2$.\n\nAll three unique memory blocks map to Set $0$. Set $1$ will remain empty throughout the simulation. We only need to trace the state of Set $0$, which has $E=2$ lines. The address trace in terms of tags is: $[\\,t_0, t_1, t_2, t_0, t_1, t_0, t_1, t_0, t_1, t_2, t_0, t_1\\,]$.\n\n**Part 1: LRU Replacement Policy Simulation**\n\nWe track the contents of Set $0$ and the recency of their use. The state is represented as an ordered list `[MRU, LRU]`. Cache is initially empty.\n\n1.  **Access $0$ ($t_0$):** Miss (compulsory). Set $0$ is not full.\n    - Set $0$ state: $[t_0]$. Misses: $1$.\n2.  **Access $128$ ($t_1$):** Miss (compulsory). Set $0$ is not full.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $2$.\n3.  **Access $256$ ($t_2$):** Miss (conflict). Set $0$ is full. LRU evicts the LRU block, which is $t_0$.\n    - Evicted: $t_0$.\n    - Set $0$ state: $[t_2, t_1]$. Misses: $3$.\n4.  **Access $0$ ($t_0$):** Miss (conflict). Set $0$ is full. LRU evicts $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $4$.\n5.  **Access $128$ ($t_1$):** Miss (conflict). Set $0$ is full. LRU evicts $t_2$.\n    - Evicted: $t_2$.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $5$.\n6.  **Access $0$ ($t_0$):** Hit. $t_0$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_0, t_1]$. Misses: $5$.\n7.  **Access $128$ ($t_1$):** Hit. $t_1$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $5$.\n8.  **Access $0$ ($t_0$):** Hit. $t_0$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_0, t_1]$. Misses: $5$.\n9.  **Access $128$ ($t_1$):** Hit. $t_1$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $5$.\n10. **Access $256$ ($t_2$):** Miss (conflict). Set $0$ is full. LRU evicts $t_0$.\n    - Evicted: $t_0$.\n    - Set $0$ state: $[t_2, t_1]$. Misses: $6$.\n11. **Access $0$ ($t_0$):** Miss (conflict). Set $0$ is full. LRU evicts $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $7$.\n12. **Access $128$ ($t_1$):** Miss (conflict). Set $0$ is full. LRU evicts $t_2$.\n    - Evicted: $t_2$.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $8$.\n\nThe total number of misses for the LRU policy is $M_{\\text{LRU}} = 8$.\n\n**Part 2: RAND Replacement Policy Simulation (with deterministic surrogate)**\n\nThe coin outcomes are $[\\,T, T, T, T, T, T, H, H\\,]$. $T$ means evict MRU, $H$ means evict LRU. We maintain an eviction counter $k$.\n\n1.  **Access $0$ ($t_0$):** Miss (compulsory).\n    - Set $0$ state: $[t_0]$. Misses: $1$.\n2.  **Access $128$ ($t_1$):** Miss (compulsory).\n    - Set $0$ state: $[t_1, t_0]$. Misses: $2$.\n3.  **Access $256$ ($t_2$):** Miss (conflict). Eviction $k=1$. Coin is $T$. Evict MRU, which is $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_2, t_0]$. Misses: $3$.\n4.  **Access $0$ ($t_0$):** Hit. $t_0$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $3$.\n5.  **Access $128$ ($t_1$):** Miss (conflict). Eviction $k=2$. Coin is $T$. Evict MRU, which is $t_0$.\n    - Evicted: $t_0$.\n    - Set $0$ state: $[t_1, t_2]$. Misses: $4$.\n6.  **Access $0$ ($t_0$):** Miss (conflict). Eviction $k=3$. Coin is $T$. Evict MRU, which is $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $5$.\n7.  **Access $128$ ($t_1$):** Miss (conflict). Eviction $k=4$. Coin is $T$. Evict MRU, which is $t_0$.\n    - Evicted: $t_0$.\n    - Set $0$ state: $[t_1, t_2]$. Misses: $6$.\n8.  **Access $0$ ($t_0$):** Miss (conflict). Eviction $k=5$. Coin is $T$. Evict MRU, which is $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $7$.\n9.  **Access $128$ ($t_1$):** Miss (conflict). Eviction $k=6$. Coin is $T$. Evict MRU, which is $t_0$.\n    - Evicted: $t_0$.\n    - Set $0$ state: $[t_1, t_2]$. Misses: $8$.\n10. **Access $256$ ($t_2$):** Hit. $t_2$ is in the cache. It becomes MRU.\n    - Set $0$ state: $[t_2, t_1]$. Misses: $8$.\n11. **Access $0$ ($t_0$):** Miss (conflict). Eviction $k=7$. Coin is $H$. Evict LRU, which is $t_1$.\n    - Evicted: $t_1$.\n    - Set $0$ state: $[t_0, t_2]$. Misses: $9$.\n12. **Access $128$ ($t_1$):** Miss (conflict). Eviction $k=8$. Coin is $H$. Evict LRU, which is $t_2$.\n    - Evicted: $t_2$.\n    - Set $0$ state: $[t_1, t_0]$. Misses: $10$.\n\nThe total number of misses for the RAND policy is $M_{\\text{rand}} = 10$.\n\nSummary of evicted blocks for each conflict:\n- **LRU Policy:**\n  - Access $3$ ($t_2$): evicts $t_0$\n  - Access $4$ ($t_0$): evicts $t_1$\n  - Access $5$ ($t_1$): evicts $t_2$\n  - Access $10$ ($t_2$): evicts $t_0$\n  - Access $11$ ($t_0$): evicts $t_1$\n  - Access $12$ ($t_1$): evicts $t_2$\n- **RAND Policy:**\n  - Access $3$ ($t_2$): evicts $t_1$ (MRU)\n  - Access $5$ ($t_1$): evicts $t_0$ (MRU)\n  - Access $6$ ($t_0$): evicts $t_1$ (MRU)\n  - Access $7$ ($t_1$): evicts $t_0$ (MRU)\n  - Access $8$ ($t_0$): evicts $t_1$ (MRU)\n  - Access $9$ ($t_1$): evicts $t_0$ (MRU)\n  - Access $11$ ($t_0$): evicts $t_1$ (LRU)\n  - Access $12$ ($t_1$): evicts $t_2$ (LRU)\n\nFinally, we calculate the required difference between the number of misses.\nDifference = $M_{\\text{rand}} - M_{\\text{LRU}} = 10 - 8 = 2$.", "answer": "$$\\boxed{2}$$", "id": "3635229"}]}