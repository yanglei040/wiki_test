{"hands_on_practices": [{"introduction": "This practice explores one of the most common applications of base-plus-offset addressing: accessing elements within multi-dimensional arrays. By deriving the addressing formula for a row-major layout from first principles, you will see how a logical array index $(i, j)$ is translated into a physical memory offset. This exercise [@problem_id:3622182] further connects this addressing scheme to system performance by analyzing how data layout and element size impact cache efficiency.", "problem": "A two-dimensional array $A$ of dimensions $M \\times N$ is stored in main memory in row-major order, where each element occupies $w$ bytes. The base address of the array (the address of $A[0][0]$) is $B$ bytes from address zero. The memory system uses a cache with a cache line of size $L$ bytes. You may assume that $B$ is aligned to a cache line boundary. Consider the following two scenarios that differ only in the element width:\n- Scenario $\\mathrm{S1}$: $M$ and $N$ are fixed at $M=128$, $N=96$, the element width is $w_{1}=4$ bytes, and the cache line size is $L=64$ bytes. The base address is $B=2^{28}$ bytes.\n- Scenario $\\mathrm{S2}$: Identical to Scenario $\\mathrm{S1}$ except that the element width is $w_{2}=8$ bytes.\n\nBegin from the foundational definitions that (i) row-major layout stores consecutive elements of a row contiguously in memory, and rows follow each other with no gaps, and (ii) base-plus-offset addressing forms the effective address as the base plus a byte offset counting from the first element. Using only these definitions as your starting point, do the following:\n\n1. Derive an expression for the effective address in bytes, $\\mathrm{EA}(i,j)$, of $A[i][j]$ as a function of $B$, $i$, $j$, $N$, and $w$.\n2. Using your derived expression, compute the numerical effective address (in bytes) of the element $A[i_{0}][j_{0}]$ with $i_{0}=37$ and $j_{0}=58$ under Scenario $\\mathrm{S1}$.\n3. For a fixed row index $i_{0}$, consider a streaming access pattern that reads $A[i_{0}][j]$ for $j=0,1,\\dots,N-1$ starting from a cold cache, and suppose there are no conflict or capacity effects beyond compulsory line fills. Using first principles, determine how many distinct cache lines are fetched to read that one row in Scenario $\\mathrm{S1}$ and in Scenario $\\mathrm{S2}$, explaining how $N$, $w$, $L$, and base alignment govern this count.\n4. Let $r$ be the ratio of the number of compulsory cache line fills per row in Scenario $\\mathrm{S2}$ to that in Scenario $\\mathrm{S1}$. Compute $r$ explicitly.\n\nProvide $r$ as your final answer. No rounding is required. Express intermediate addresses in bytes if you compute them, but your final answer must be the single number $r$ without units.", "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information for a complete solution. We proceed by addressing each of the four required parts in order.\n\n### Part 1: Derivation of the Effective Address Expression\n\nThe problem specifies two foundational definitions to be used as a starting point.\n(i) Row-major layout stores an array such that consecutive elements of a row are contiguous in memory, and entire rows are stored one after another.\n(ii) Base-plus-offset addressing calculates the effective address of a memory location as the sum of a base address and a byte offset.\n\nLet the two-dimensional array be $A$, with $M$ rows and $N$ columns, indexed from $0$. Let $A[i][j]$ denote the element in row $i$ and column $j$, where $0 \\le i  M$ and $0 \\le j  N$. The base address, $B$, is the memory address of the first element, $A[0][0]$. Each element occupies $w$ bytes.\n\nTo find the address of an arbitrary element $A[i][j]$, we must calculate its byte offset from the base address $B$. In row-major order, to reach the beginning of row $i$, we must first traverse all the preceding $i$ rows (from row $0$ to row $i-1$). Each of these rows contains $N$ elements. Therefore, the number of elements preceding row $i$ is $i \\times N$.\n\nWithin row $i$, the element $A[i][j]$ is preceded by $j$ other elements (from column $0$ to column $j-1$).\n\nThus, the total number of elements preceding $A[i][j]$ in memory is the sum of elements in prior rows and elements in the current row: $(i \\cdot N) + j$.\n\nSince each element has a size of $w$ bytes, the total byte offset from the start of the array is the total number of preceding elements multiplied by the size of each element.\n$$ \\text{Byte Offset} = (i \\cdot N + j) \\cdot w $$\n\nAccording to the principle of base-plus-offset addressing, the effective address $\\mathrm{EA}(i,j)$ is the sum of the base address $B$ and this byte offset.\n$$ \\mathrm{EA}(i,j) = B + (iN + j)w $$\nThis expression provides the effective address in bytes for the element $A[i][j]$ as a function of $B$, $i$, $j$, $N$, and $w$.\n\n### Part 2: Numerical Effective Address for Scenario S1\n\nFor Scenario $\\mathrm{S1}$, we are given the following values:\nBase address $B = 2^{28}$ bytes.\nNumber of columns $N = 96$.\nElement width $w_1 = 4$ bytes.\nThe specific element is $A[i_0][j_0]$ with $i_0 = 37$ and $j_0 = 58$.\n\nUsing the derived formula for $\\mathrm{EA}(i,j)$:\n$$ \\mathrm{EA}(i_0, j_0) = B + (i_0 N + j_0) w_1 $$\nSubstituting the numerical values for Scenario $\\mathrm{S1}$:\n$$ \\mathrm{EA}(37, 58) = 2^{28} + (37 \\cdot 96 + 58) \\cdot 4 $$\nFirst, we compute the term inside the parentheses:\n$$ 37 \\cdot 96 = 3552 $$\n$$ 3552 + 58 = 3610 $$\nNow, we multiply by the element width and add the base address:\n$$ \\mathrm{EA}(37, 58) = 2^{28} + (3610) \\cdot 4 $$\n$$ \\mathrm{EA}(37, 58) = 2^{28} + 14440 $$\nThe value of $2^{28}$ is $268,435,456$.\n$$ \\mathrm{EA}(37, 58) = 268,435,456 + 14440 = 268,449,896 $$\nSo, the numerical effective address of $A[37][58]$ is $268,449,896$ bytes.\n\n### Part 3: Number of Cache Line Fetches\n\nThe number of compulsory cache line fetches for a sequential memory access depends on the starting address of the access relative to a cache line boundary and the total number of bytes accessed. The problem states that the cache is initially cold and there are no other cache effects (conflict/capacity misses), so every line accessed for the first time results in a compulsory miss and a fetch.\n\nA single row $i_0$ of the array is read, from $A[i_0][0]$ to $A[i_0][N-1]$.\nThe total number of bytes in one row is $N \\cdot w$.\nThe cache line size is $L$.\nThe starting address of row $i_0$ is $\\mathrm{EA}(i_0, 0) = B + i_0 N w$.\nThe problem states that the base address $B$ is aligned to a cache line boundary, meaning $B$ is an integer multiple of $L$, or $B \\pmod{L} = 0$.\n\nThe alignment of the starting address of row $i_0$ therefore depends on the term $(i_0 N w) \\pmod{L}$. If this term is $0$, the row starts exactly on a cache line boundary, which simplifies the calculation.\n\n**Scenario S1:**\n- $N = 96$, $w_1 = 4$ bytes, $L = 64$ bytes.\nThe total number of bytes per row is $N \\cdot w_1 = 96 \\cdot 4 = 384$ bytes.\nLet's check the size of a row relative to the cache line size:\n$$ \\frac{N w_1}{L} = \\frac{384}{64} = 6 $$\nThis shows that the byte size of one complete row is exactly $6$ cache lines.\nSince the base address $B$ is aligned to an $L$-byte boundary, and the size of each row ($N w_1$) is an integer multiple of $L$, the starting address of *every* row $i$ must also be aligned to a cache line boundary.\n$$ \\mathrm{EA}(i, 0) \\pmod{L} = (B + i N w_1) \\pmod{L} = (B \\pmod{L} + (i \\cdot 6L) \\pmod{L}) \\pmod{L} = (0 + 0) \\pmod{L} = 0 $$\nBecause the access starts on a cache line boundary and spans exactly an integer number of cache lines, the number of cache lines fetched, $C_1$, is simply the total row size in bytes divided by the cache line size.\n$$ C_1 = \\frac{N w_1}{L} = \\frac{384}{64} = 6 $$\nThus, in Scenario $\\mathrm{S1}$, $6$ distinct cache lines are fetched to read one row.\n\n**Scenario S2:**\n- $N = 96$, $w_2 = 8$ bytes, $L = 64$ bytes.\nThe total number of bytes per row is $N \\cdot w_2 = 96 \\cdot 8 = 768$ bytes.\nLet's check this row size relative to the cache line size:\n$$ \\frac{N w_2}{L} = \\frac{768}{64} = 12 $$\nSimilar to Scenario $\\mathrm{S1}$, the byte size of one complete row is an exact multiple of the cache line size. By the same reasoning, the starting address of any row $i$ is aligned to a cache line boundary.\nTherefore, the number of cache lines fetched, $C_2$, is:\n$$ C_2 = \\frac{N w_2}{L} = \\frac{768}{64} = 12 $$\nIn Scenario $\\mathrm{S2}$, $12$ distinct cache lines are fetched to read one row.\n\n### Part 4: Computation of the Ratio r\n\nThe ratio $r$ is defined as the number of compulsory cache line fills per row in Scenario $\\mathrm{S2}$ divided by that in Scenario $\\mathrm{S1}$.\n$$ r = \\frac{C_2}{C_1} $$\nUsing the values computed in Part 3:\n$$ r = \\frac{12}{6} = 2 $$\nAlternatively, we can express the ratio symbolically before substituting values:\n$$ r = \\frac{N w_2 / L}{N w_1 / L} = \\frac{w_2}{w_1} $$\nGiven $w_2 = 8$ bytes and $w_1 = 4$ bytes:\n$$ r = \\frac{8}{4} = 2 $$\nThe ratio of compulsory cache line fills is $2$.", "answer": "$$\\boxed{2}$$", "id": "3622182"}, {"introduction": "Base-plus-offset addressing is the backbone of procedure calls in modern systems, enabling functions to access their parameters and local variables. This problem [@problem_id:3622117] challenges you to reconstruct the memory layout of a function's stack frame according to a given Application Binary Interface (ABI). You will use the frame pointer ($FP$) as a stable base address to calculate the precise offsets for accessing data on the stack, revealing the intricate mechanics behind function execution.", "problem": "A $64$-bit machine uses a downward-growing stack and base-plus-offset addressing, where an effective address (EA) is computed as a base register plus a signed displacement. The Application Binary Interface (ABI) specifies the following rules. Before a call, the caller aligns the stack pointer to a multiple of $16$ bytes. On function entry, the hardware pushes a return address of size $8$ bytes. The callee’s prologue then saves the previous frame pointer by pushing it (size $8$ bytes) and sets the new frame pointer equal to the current stack pointer, so that $FP = SP$ after saving the old frame pointer. After this, the callee allocates space for locals by subtracting a frame size that must be a multiple of $16$ bytes to keep $SP$ $16$-byte aligned throughout the function body.\n\nAssume all function parameters are passed on the stack by the caller, pushed right-to-left. The caller lays out parameters with natural alignment: $4$-byte integers are aligned at addresses congruent to $0 \\bmod 4$, $8$-byte pointers and $8$-byte floating-point numbers (doubles) are aligned at addresses congruent to $0 \\bmod 8$, and vectors of size $32$ bytes are aligned at addresses congruent to $0 \\bmod 16$. The caller inserts padding between parameters as needed to satisfy each parameter’s alignment in the callee’s view, and also inserts any overall padding so that just before the call instruction the stack pointer is aligned to a multiple of $16$ bytes. Within the callee, the saved frame pointer is located at address $FP + 0$, and the return address at $FP + 8$.\n\nConsider a function with signature $f(\\text{double } p_1, \\text{int } p_2, \\text{void* } p_3)$ that declares two local variables in this order: a temporary $\\texttt{t}$ of size $8$ bytes and alignment $8$, followed by a vector $\\texttt{v}$ of size $32$ bytes and alignment $16$. Locals are allocated in declaration order from higher to lower addresses (that is, from $FP - 1$ downward), placing each at the next address that meets its alignment, and inserting any padding required by alignment. Using base-plus-offset addressing of the form $EA = FP + d$, where positive $d$ accesses parameters and negative $d$ accesses locals, determine:\n\n- The constant $k$ such that the effective address of parameter $p_2$ is $EA = FP + (+k)$.\n- The constant $m$ such that the effective address of the base of local $\\texttt{v}$ is $EA = FP + (-m)$.\n\nState $k$ and $m$ in bytes as exact integers. No rounding is required. Your final answer must be the two constants in a single row matrix in the order $k, m$.", "solution": "The problem is valid as it is scientifically grounded in the principles of computer architecture, specifically stack frame layout and addressing modes. It is well-posed, objective, and internally consistent, providing all necessary information to deduce the memory layout.\n\nThe solution requires determining the offsets of a parameter and a local variable relative to the frame pointer ($FP$). This involves a step-by-step construction of the stack frame according to the provided Application Binary Interface (ABI) rules.\n\nFirst, we determine the layout of the parameters on the stack, which is prepared by the caller. The function signature is $f(\\text{double } p_1, \\text{int } p_2, \\text{void* } p_3)$. Parameters are pushed onto the stack in right-to-left order. The stack grows downwards (towards lower addresses). The stack pointer ($SP$) must be aligned to a $16$-byte boundary right before the `call` instruction. Let's denote this stack pointer value as $SP_{pre-call}$. The parameters are placed at addresses higher than or equal to $SP_{pre-call}$.\n\n1.  **Parameter Layout (by Caller):**\n    The caller pushes $p_3$, then $p_2$, then $p_1$. We determine their positions relative to $SP_{pre-call}$, ensuring each parameter's natural alignment.\n    -   Parameter $p_1$ is a `double` (size $8$ bytes, alignment $8$ bytes). It is the last one pushed, so it is at the top of the parameter block. Its base address will be $SP_{pre-call}$. The ABI rule states that $SP_{pre-call}$ is aligned to a $16$-byte boundary, so $SP_{pre-call} \\equiv 0 \\pmod{16}$. This address is also a multiple of $8$, so the alignment for $p_1$ is met. $p_1$ occupies the memory range $[SP_{pre-call}, SP_{pre-call} + 7]$.\n    -   Parameter $p_2$ is an `int` (size $4$ bytes, alignment $4$ bytes). It is pushed before $p_1$, so it resides at higher addresses. The next available address is $SP_{pre-call} + 8$. Since $SP_{pre-call}$ is a multiple of $16$, $SP_{pre-call} + 8$ is a multiple of $8$, and therefore also a multiple of $4$. The alignment for $p_2$ is met. $p_2$ occupies the memory range $[SP_{pre-call} + 8, SP_{pre-call} + 11]$.\n    -   Parameter $p_3$ is a `void*` (size $8$ bytes, alignment $8$ bytes). It is pushed before $p_2$. The next available address is $SP_{pre-call} + 12$. This address is not a multiple of $8$. To satisfy the alignment, the caller must insert padding. The next higher address that is a multiple of $8$ is $SP_{pre-call} + 16$. Thus, $4$ bytes of padding are inserted at $[SP_{pre-call} + 12, SP_{pre-call} + 15]$. $p_3$ is placed at address $SP_{pre-call} + 16$. It occupies the memory range $[SP_{pre-call} + 16, SP_{pre-call} + 23]$.\n\nThe stack layout for parameters, from low to high address, is: $p_1$, $p_2$, padding, $p_3$.\n\n2.  **Frame Pointer Setup (by Callee):**\n    -   The `call` instruction is executed when $SP = SP_{pre-call}$. It pushes the $8$-byte return address onto the stack. The stack pointer becomes $SP = SP_{pre-call} - 8$.\n    -   The callee's prologue first saves the old frame pointer by pushing it. This is another $8$ bytes. The stack pointer becomes $SP = (SP_{pre-call} - 8) - 8 = SP_{pre-call} - 16$.\n    -   The callee then sets the new frame pointer to the current stack pointer: $FP = SP = SP_{pre-call} - 16$.\n    -   From this, we establish the crucial relationship between the new frame pointer and the pre-call stack pointer: $SP_{pre-call} = FP + 16$.\n    -   As a check, the saved frame pointer is at address $FP$, and the return address is at $FP+8$. This matches the problem statement.\n\n3.  **Determine the offset $k$ for parameter $p_2$:**\n    The address of $p_2$ is $EA(p_2) = SP_{pre-call} + 8$.\n    Substituting the expression for $SP_{pre-call}$:\n    $$EA(p_2) = (FP + 16) + 8 = FP + 24$$\n    The problem states $EA(p_2) = FP + k$. Therefore, $k = 24$.\n\n4.  **Local Variable Layout (by Callee):**\n    Local variables are allocated on the stack below the frame pointer (at addresses less than $FP$). They are allocated in declaration order: `t`, then `v`. The allocation proceeds from higher to lower addresses, starting from just below $FP$. We know $FP$ is a multiple of $16$ because $FP = SP_{pre-call} - 16$ and $SP_{pre-call}$ is a multiple of $16$.\n\n    -   Local `t` (size $8$ bytes, alignment $8$ bytes):\n        The region for `t` starts at the highest possible address below $FP$ that satisfies its alignment. The base address $A_t$ must be a multiple of $8$. The block of memory is $[A_t, A_t+7]$, and it must be entirely below $FP$, so $A_t+7  FP$, which means $A_t \\le FP-8$. Since $FP$ is a multiple of $16$, $FP-8$ is a multiple of $8$. The highest-address (closest to $FP$) choice for $A_t$ is $FP-8$. So, `t` is allocated at $EA(t) = FP - 8$. It occupies $[FP-8, FP-1]$.\n\n    -   Local `v` (size $32$ bytes, alignment $16$ bytes):\n        `v` must be allocated below `t`. The available memory addresses are less than $FP-8$. The base address of `v`, $A_v$, must be a multiple of $16$. The block of memory is $[A_v, A_v+31]$, and it must be entirely below `t`'s region, so $A_v+31  FP-8$, which simplifies to $A_v \\le FP-40$.\n        We need to find the largest multiple of $16$ that is less than or equal to $FP-40$. Since $FP$ is a multiple of $16$, let $FP = 16N$ for some integer $N$. We require $A_v \\le 16N - 40$. The multiples of $16$ below $FP$ are $FP-16$, $FP-32$, $FP-48$, etc.\n        -   Is $FP-16 \\le FP-40$? No.\n        -   Is $FP-32 \\le FP-40$? No.\n        -   Is $FP-48 \\le FP-40$? Yes.\n        Thus, the highest possible aligned base address for `v` is $FP-48$.\n        So, `v` is allocated at $EA(v) = FP - 48$.\n\n5.  **Determine the offset $m$ for local `v`:**\n    The base address of `v` is $EA(v) = FP - 48$.\n    The problem states $EA(v) = FP + (-m) = FP - m$. Therefore, $m = 48$.\n\n6.  **Final ABI Consistency Check:**\n    The total space allocated for locals spans from the base of `v` ($FP-48$) to the top of `t` ($FP-1$). The total size to be subtracted from SP is from $FP$ down to the new $SP$, which will be at the base of the entire local variable area. The new $SP$ will be $FP-48$. The amount subtracted is $48$ bytes. The ABI requires this frame size to be a multiple of $16$. Since $48 = 3 \\times 16$, this condition is satisfied. The new stack pointer, $SP_{new} = FP - 48$, is also $16$-byte aligned because $FP$ is. All rules are consistently met.\n\nThe values are $k=24$ and $m=48$.", "answer": "$$\\boxed{\\begin{pmatrix} 24  48 \\end{pmatrix}}$$", "id": "3622117"}, {"introduction": "The efficiency of memory access often depends on how data aligns with the underlying hardware, particularly the cache. This exercise [@problem_id:3622073] presents a scenario where a single memory load using base-plus-offset addressing straddles a cache line boundary, a common source of performance degradation. By calculating the number of cache misses and the resulting time penalty, you will gain a concrete understanding of why data alignment is a critical consideration for performance-conscious programming.", "problem": "A 64-bit processor implements base-plus-offset addressing for load instructions within a Level-1 (L1) data cache that uses physically indexed, physically tagged cache lines of size $64$ bytes. Cache lines are aligned to addresses that are integer multiples of $64$, so a line starting address is denoted by $L$ and covers the half-open interval $\\left[L, L+64\\right)$. Consider an array of structures in memory. For a particular element $s$ in this array, the compiler has placed the base address of $s$ in a general-purpose register, and the load of a $16$-byte field within $s$ uses a single load instruction with a base-plus-offset addressing mode.\n\nAssume the following concrete scenario:\n- The base address of the structure instance $s$ is $\\texttt{0x10004000} + 52$. Let $L = \\texttt{0x10004000}$, which is aligned to a $64$-byte cache line boundary. Thus the address of $s$ is $L + 52$.\n- The field being loaded starts at byte offset $8$ from the start of $s$, and its width is $w = 16$ bytes. The load instruction addresses this field with a base-plus-offset effective address $EA$ using that offset.\n- The memory system behavior under cold-start conditions is as follows: on a miss in the Level-1 (L1) data cache, the request misses in the Level-2 (L2) and Level-3 (L3) caches as well, and each distinct $64$-byte line fetch from main memory takes $180$ cycles to complete. Ignore any overlap or pipelining; treat each line fill as an additive $180$-cycle cost. Do not count processor core execution latency for L1 hits; only count the cycles attributable to lower-level memory traffic caused by misses.\n\nTasks:\n1. Compute the effective address $EA$ of the $16$-byte field load using the given base and offset.\n2. Determine whether the $16$-byte load starting at $EA$ is fully contained within the line $\\left[L, L+64\\right)$ or whether it crosses into the next line. If it crosses, identify the exact byte ranges in $\\left[L, L+64\\right)$ and $\\left[L+64, L+128\\right)$ that are touched by this single load.\n3. Under the stated cold-start miss behavior, determine how many distinct $64$-byte line fills from main memory are triggered by this single load and compare this with the number that would be triggered if the same-width load were fully contained in a single cache line.\n4. What is the extra number of memory cycles attributable solely to the crossing of the cache line boundary by this single load, relative to a same-width load that does not cross a cache line boundary? Provide your final answer as a single integer number of cycles. No rounding is needed. Units are cycles; do not include units in your final numerical answer.", "solution": "The problem is first validated to ensure it is scientifically sound, self-contained, and well-posed.\n\n### Step 1: Extract Givens\n- Processor architecture: $64$-bit\n- Addressing mode: Base-plus-offset\n- L1 data cache line size: $64$ bytes\n- Cache line alignment: Start address $L$ is an integer multiple of $64$. A line covers the interval $[L, L+64)$.\n- Base address of structure $s$: Let $L = \\texttt{0x10004000}$, which is a $64$-byte aligned address. The address of $s$ is $L + 52$.\n- Field offset within $s$: $8$ bytes.\n- Field width (load width): $w = 16$ bytes.\n- Memory system behavior: Cold-start. A miss in L1, L2, and L3 caches results in a fetch from main memory.\n- Main memory latency: $180$ cycles per distinct $64$-byte line fill. This cost is additive and not overlapped.\n- Cost accounting: Ignore L1 hit latency; only count cycles from lower-level memory traffic due to misses.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem describes a canonical scenario in computer architecture involving memory hierarchies, specifically the performance implications of unaligned memory accesses that cross cache line boundaries. All concepts—base-plus-offset addressing, cache lines, miss penalties—are fundamental and correctly represented.\n- **Well-Posed:** The problem provides all necessary numerical values and constraints to calculate a unique answer for each task. The question is unambiguous.\n- **Objective:** The problem is stated using precise, technical language free of subjectivity.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is a standard and well-formed problem in computer organization and architecture. The solution process may proceed.\n\n### Solution Derivation\n\nThe solution is approached by completing the four tasks outlined in the problem statement.\n\n**Task 1: Compute the effective address $EA$**\n\nThe effective address ($EA$) is the memory location where the load operation begins. It is calculated using the base-plus-offset addressing mode.\nThe base address is the starting address of the structure instance $s$.\n$$ \\text{Base Address} = \\text{Address of } s $$\nThe problem states that the address of $s$ is $L + 52$, where $L = \\texttt{0x10004000}$.\n$$ \\text{Base Address} = L + 52 $$\nThe offset is the distance in bytes from the start of the structure $s$ to the beginning of the field being loaded. This is given as $8$ bytes.\n$$ \\text{Offset} = 8 $$\nThe effective address is the sum of the base address and the offset.\n$$ EA = \\text{Base Address} + \\text{Offset} $$\n$$ EA = (L + 52) + 8 = L + 60 $$\nNumerically, this corresponds to the address $\\texttt{0x10004000} + 60$, which is $\\texttt{0x1000403C}$.\n\n**Task 2: Determine if the load crosses a cache line boundary**\n\nA cache line is a $64$-byte block of memory, aligned to a $64$-byte boundary. The first cache line of interest starts at address $L$ and covers the half-open interval of byte addresses $[L, L+64)$. The next concentric cache line starts at $L+64$ and covers the interval $[L+64, L+128)$.\n\nThe load operation is for a field of width $w=16$ bytes, starting at the effective address $EA = L+60$. The load, therefore, accesses all bytes in the memory interval:\n$$ [EA, EA+w) = [L+60, L+60+16) = [L+60, L+76) $$\nTo determine if this access crosses a boundary, we compare this interval to the intervals of the cache lines.\nThe first cache line is $[L, L+64)$.\nThe second cache line is $[L+64, L+128)$.\n\nThe access starts at $L+60$, which is within the first cache line since $L \\le L+60  L+64$.\nThe access ends just before $L+76$. The end address, $L+75$, is within the second cache line since $L+64 \\le L+75  L+128$.\nSince the start of the access is in one cache line and the end is in another, the $16$-byte load **crosses the cache line boundary** at address $L+64$.\n\nThe exact byte ranges touched by this load are:\n- In the first cache line, $[L, L+64)$: The load accesses bytes from its start address $L+60$ up to the line boundary, which is the interval $[L+60, L+64)$. This constitutes $64 - 60 = 4$ bytes.\n- In the second cache line, $[L+64, L+128)$: The load accesses bytes from the line boundary $L+64$ up to its end, which is the interval $[L+64, L+76)$. This constitutes $76 - 64 = 12$ bytes.\nThe total number of bytes accessed is $4 + 12 = 16$, which correctly matches the field width $w$.\n\n**Task 3: Determine the number of distinct line fills**\n\nThe problem specifies cold-start conditions, meaning the required data is not in any level of the cache. A memory access to an address will cause a cache miss, triggering a fetch of the entire $64$-byte cache line containing that address from main memory.\nThe load operation requires data from two distinct cache lines:\n1. The line containing address $L+60$. This is the line starting at address $L$ (since $L = \\lfloor (L+60)/64 \\rfloor \\times 64$).\n2. The line containing address $L+64$. This is the line starting at address $L+64$.\n\nBecause the load spans two different cache lines and the cache is cold, it will generate two separate cache misses. Each miss will trigger a distinct $64$-byte line fill from main memory. Therefore, the single load instruction triggers **$2$** distinct line fills.\n\nFor comparison, if the same-width ($16$-byte) load were fully contained within a single cache line (e.g., if it started at an address like $L+0$ or $L+32$), it would only touch addresses within one $64$-byte aligned block. Under cold-start conditions, this would cause only **$1$** cache miss and thus trigger only **$1$** line fill.\n\n**Task 4: Calculate the extra number of memory cycles**\n\nThe penalty for a single line fill from main memory is given as $180$ cycles.\nThe total memory latency for the boundary-crossing load is the sum of the latencies for all triggered line fills.\n$$ \\text{Total Cycles}_{\\text{crossing}} = (\\text{Number of line fills}) \\times (\\text{Cycles per fill}) $$\n$$ \\text{Total Cycles}_{\\text{crossing}} = 2 \\times 180_{\\text{cycles}} = 360_{\\text{cycles}} $$\nThe total memory latency for a hypothetical, non-crossing (aligned) load of the same width would be:\n$$ \\text{Total Cycles}_{\\text{aligned}} = 1 \\times 180_{\\text{cycles}} = 180_{\\text{cycles}} $$\nThe extra number of memory cycles attributable solely to the crossing of the cache line boundary is the difference between these two scenarios.\n$$ \\text{Extra Cycles} = \\text{Total Cycles}_{\\text{crossing}} - \\text{Total Cycles}_{\\text{aligned}} $$\n$$ \\text{Extra Cycles} = 360 - 180 = 180 $$\nAlternatively, the boundary-crossing event causes one extra line fill compared to the aligned case. The cost of this one extra line fill is $180$ cycles.\nThus, the extra number of memory cycles is $180$.", "answer": "$$\n\\boxed{180}\n$$", "id": "3622073"}]}