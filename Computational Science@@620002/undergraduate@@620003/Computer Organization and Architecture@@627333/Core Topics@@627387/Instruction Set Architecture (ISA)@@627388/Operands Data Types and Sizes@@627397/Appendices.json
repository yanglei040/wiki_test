{"hands_on_practices": [{"introduction": "Right shift operations are fundamental for efficient division by powers of two, but their behavior depends critically on whether the data is signed or unsigned. A logical right shift fills vacated bits with zeros, suitable for unsigned numbers, while an arithmetic right shift preserves the sign bit, essential for two's complement arithmetic. This exercise challenges you to design a definitive test to distinguish between these two behaviors in a black-box ALU, reinforcing your understanding of how negative numbers are represented and manipulated at the bit level [@problem_id:3662568].", "problem": "A black-box Arithmetic Logic Unit (ALU) performs a right-shift operation on an $n$-bit operand. You do not know whether the shift is an arithmetic right shift (sign-extending) or a logical right shift (zero-fill). You can provide any $n$-bit operand encoded in standard two's complement form and a shift count $k$ with $1 \\leq k < n$. The ALU returns the $n$-bit result and sets a sign flag equal to the most significant bit (MSB) of the result. Design a single-shot test that distinguishes the two kinds of shifts by choosing an operand whose sign behavior after shifting forces a difference in the sign flag between the two possibilities. Then, using only the standard definitions of two's complement encoding and of arithmetic and logical right shifts, derive the exact signed-integer difference between the logical-right-shift result and the arithmetic-right-shift result produced by this test, expressed in closed form as a function of $n$ and $k$. Your final answer must be a single analytic expression in terms of $n$ and $k$. No rounding is required.", "solution": "The problem requires us to design a single-shot test to distinguish between a logical right shift (LSR) and an arithmetic right shift (ASR) performed by a black-box ALU, and then to derive the signed-integer difference between the results of these two operations for the chosen test case.\n\nFirst, we analyze the definitions of the two shift operations for an $n$-bit operand. A logical right shift by $k$ positions, denoted LSR, shifts all bits to the right by $k$ positions, discarding the $k$ least significant bits and filling the $k$ most significant bit positions with zeros. An arithmetic right shift by $k$ positions, denoted ASR, also shifts all bits to the right by $k$ positions, but it fills the $k$ most significant bit positions with copies of the original most significant bit (MSB), which is the sign bit in a two's complement representation.\n\nThe key difference lies in the fill-bit for the MSB positions. For a non-negative operand, the MSB is $0$. Both LSR and ASR will fill the vacated bit positions with $0$. Consequently, for any non-negative operand, the results of LSR and ASR are identical. To distinguish them, we must choose an operand for which the fill-bits are different. This necessitates choosing a negative operand, for which the MSB is $1$.\n\nFor a negative operand, LSR will fill with $0$s, resulting in a new MSB of $0$ (a positive number), and thus a sign flag of $0$. In contrast, ASR will fill with $1$s (sign extension), resulting in a new MSB of $1$ (a negative number), and a sign flag of $1$. The difference in the sign flag provides a definitive test.\n\nWe must select a specific $n$-bit negative operand. A canonical and simple choice is the most negative number representable in $n$-bit two's complement, which is $X_0 = -2^{n-1}$. The binary representation of $X_0$ is a $1$ followed by $n-1$ zeros:\n$$\nX_0 = (100...0)_2\n$$\nLet us denote the value of the result of the logical shift as $V_{LSR}$ and the value of the result of the arithmetic shift as $V_{ASR}$. We are asked to find the difference $V_{LSR} - V_{ASR}$.\n\n**1. Logical Right Shift (LSR) Result**\nApplying LSR to $X_0 = (100...0)_2$ by a shift count of $k$ positions, where $1 \\le k < n$, shifts the bits to the right and fills the $k$ most significant positions with $0$s. The original MSB, a $1$ at bit position $n-1$, is shifted to position $n-1-k$. All other bits are $0$.\nThe resulting $n$-bit pattern, which we call $R_{LSR}$, is:\n$$\nR_{LSR} = (\\underbrace{00...0}_{k \\text{ zeros}}1\\underbrace{00...0}_{n-k-1 \\text{ zeros}})_2\n$$\nThe MSB of $R_{LSR}$ is $0$, so it represents a positive integer. The value is determined by the position of the single '1' bit, which is at index $n-k-1$ (with the LSB being at index $0$). Therefore, the signed integer value $V_{LSR}$ is:\n$$\nV_{LSR} = 1 \\times 2^{n-k-1} = 2^{n-k-1}\n$$\nThe sign flag for this operation is $0$.\n\n**2. Arithmetic Right Shift (ASR) Result**\nApplying ASR to $X_0 = (100...0)_2$ by $k$ positions shifts the bits to the right and fills the $k$ most significant positions by replicating the original MSB, which is $1$. The new $n$-bit pattern, $R_{ASR}$, is thus formed by $k$ copies of the original MSB, followed by the top $n-k$ bits of the original operand.\n$$\nR_{ASR} = (\\underbrace{11...1}_{k \\text{ ones}} \\underbrace{100...0}_{n-k \\text{ bits from } X_0})_2 = (\\underbrace{11...1}_{k \\text{ ones}} 1 \\underbrace{00...0}_{n-k-1 \\text{ zeros}})_2\n$$\nThe resulting pattern has $k+1$ leading ones, followed by $n-k-1$ zeros.\nTo find the value $V_{ASR}$ of this two's complement number, we can use the formula $V = -b_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} b_i 2^i$. The bits $b_{n-1}$ through $b_{n-k-1}$ are $1$.\n$$\nV_{ASR} = -1 \\cdot 2^{n-1} + \\sum_{i=n-k-1}^{n-2} 1 \\cdot 2^i\n$$\nThe summation is a geometric series: $\\sum_{i=n-k-1}^{n-2} 2^i = 2^{n-k-1} + \\dots + 2^{n-2}$. This sum is equal to $2^{n-1} - 2^{n-k-1}$.\nSubstituting this into the expression for $V_{ASR}$:\n$$\nV_{ASR} = -2^{n-1} + (2^{n-1} - 2^{n-k-1}) = -2^{n-k-1}\n$$\nAlternatively, we can find the value by negating $R_{ASR}$. To negate, we flip the bits and add $1$.\nFlipping the bits of $R_{ASR} = (\\underbrace{1...1}_{k+1} \\underbrace{0...0}_{n-k-1})_2$ gives $(\\underbrace{0...0}_{k+1} \\underbrace{1...1}_{n-k-1})_2$. The value of this is $2^{n-k-1}-1$.\nAdding $1$ gives $2^{n-k-1}$. Thus, the magnitude of $R_{ASR}$ is $2^{n-k-1}$, and since it is a negative number, its value is $V_{ASR} = -2^{n-k-1}$.\nThe MSB of $R_{ASR}$ is $1$, so the sign flag is $1$.\nSince the sign flags are different ($0$ for LSR, $1$ for ASR), this operand successfully distinguishes the two operations.\n\n**3. The Difference**\nFinally, we compute the required difference:\n$$\nV_{LSR} - V_{ASR} = (2^{n-k-1}) - (-2^{n-k-1})\n$$\n$$\nV_{LSR} - V_{ASR} = 2^{n-k-1} + 2^{n-k-1} = 2 \\cdot 2^{n-k-1}\n$$\n$$\nV_{LSR} - V_{ASR} = 2^{n-k}\n$$\nThis expression is the closed-form difference as a function of $n$ and $k$.", "answer": "$$\n\\boxed{2^{n-k}}\n$$", "id": "3662568"}, {"introduction": "Beyond single operations, bit-level control allows us to engineer highly efficient data structures. In memory-constrained environments like embedded systems or performance-critical applications like network protocols, packing multiple, smaller data fields into a single machine word is a common and vital optimization. This practice will guide you through the process of designing and populating a custom bitfield structure, applying your skills in bit masking and shifting, and confronting the real-world challenge of data serialization by considering system endianness [@problem_id:3662512].", "problem": "A computer system uses a fixed-width unsigned word of size $32$ bits. Bits are numbered from $0$ (least significant bit (LSB)) to $31$ (most significant bit (MSB)). You are asked to design a packed layout for four unsigned fields of sizes $3$, $5$, $6$, and $10$ bits, together with the remaining bits reserved and set to zero. The layout must satisfy the following constraints:\n\n- The $3$-bit field occupies bits $[2:0]$.\n- The $5$-bit field immediately follows, occupying bits $[7:3]$.\n- The $6$-bit field immediately follows, occupying bits $[13:8]$.\n- The $10$-bit field immediately follows, occupying bits $[23:14]$.\n- Bits $[31:24]$ are reserved and must be set to zero.\n\nStarting from first principles in binary positional representation and the definitions of bit masking and logical shifting, derive the bit masks for each field and the reserved region. Then, using your masks and shifts, pack the following unsigned field values into a single $32$-bit word that respects the layout above:\n- $3$-bit field value $= 5$,\n- $5$-bit field value $= 17$,\n- $6$-bit field value $= 42$,\n- $10$-bit field value $= 777$.\n\nFinally, explain how the resulting $32$-bit word is serialized into a contiguous $4$-byte memory buffer on a big-endian and on a little-endian machine, and explicitly state the four serialized byte values in each case. Express the final packed word as an unsigned integer in decimal. No rounding is required; provide the exact value.", "solution": "The process of packing data into a bitfield structure relies on the principles of positional number systems and bitwise logical operations. An unsigned $32$-bit integer, $W$, is represented by the sum $W = \\sum_{i=0}^{31} b_i 2^i$, where $b_i \\in \\{0, 1\\}$ is the value of the bit at position $i$. The core operations for packing are the bitwise left shift (`<<`) and the bitwise OR (`|`).\n\n**1. Derivation of Bit Masks**\n\nA bit mask for a field of width $w$ bits, starting at bit position $s$ (the LSB of the field), can be generated with the expression $(2^w - 1) << s$. The term $(2^w - 1)$ creates a sequence of $w$ ones. The left shift `<< s` moves this sequence to the correct bit position.\n\n- **Field 1 Mask ($[2:0]$)**: Width $w=3$, start position $s=0$.\n  Mask $= (2^3 - 1) << 0 = 7 << 0 = 7$.\n  In hexadecimal: $0x7$.\n  In binary: $0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0111_2$.\n\n- **Field 2 Mask ($[7:3]$)**: Width $w=5$, start position $s=3$.\n  Mask $= (2^5 - 1) << 3 = 31 << 3 = 248$.\n  In hexadecimal: $0xF8$.\n  In binary: $0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 1111\\ 1000_2$.\n\n- **Field 3 Mask ($[13:8]$)**: Width $w=6$, start position $s=8$.\n  Mask $= (2^6 - 1) << 8 = 63 << 8 = 16128$.\n  In hexadecimal: $0x3F00$.\n  In binary: $0000\\ 0000\\ 0000\\ 0000\\ 0011\\ 1111\\ 0000\\ 0000_2$.\n\n- **Field 4 Mask ($[23:14]$)**: Width $w=10$, start position $s=14$.\n  Mask $= (2^{10} - 1) << 14 = 1023 << 14 = 16760832$.\n  In hexadecimal: $0xFFC000$.\n  In binary: $0000\\ 0000\\ 1111\\ 1111\\ 1100\\ 0000\\ 0000\\ 0000_2$.\n\n- **Reserved Field Mask ($[31:24]$)**: Width $w=8$, start position $s=24$.\n  Mask $= (2^8 - 1) << 24 = 255 << 24 = 4278190080$.\n  In hexadecimal: $0xFF000000$.\n  In binary: $1111\\ 1111\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000_2$.\n\n**2. Packing the Field Values**\n\nTo pack the values, each field value is shifted left to its starting bit position. Since the fields are non-overlapping and the input values are guaranteed to fit, the final packed word $W$ is the bitwise OR of all the shifted components.\n\nThe values to be packed are:\n- $v_1 = 5$ ($101_2$) for field 1 (start bit $s_1=0$).\n- $v_2 = 17$ ($10001_2$) for field 2 (start bit $s_2=3$).\n- $v_3 = 42$ ($101010_2$) for field 3 (start bit $s_3=8$).\n- $v_4 = 777$ ($1100001001_2$) for field 4 (start bit $s_4=14$).\n- $v_5 = 0$ ($0_2$) for the reserved field (start bit $s_5=24$).\n\nThe packed word $W$ is calculated as:\n$W = (v_1 << s_1) | (v_2 << s_2) | (v_3 << s_3) | (v_4 << s_4) | (v_5 << s_5)$\n$W = (5 << 0) | (17 << 3) | (42 << 8) | (777 << 14) | (0 << 24)$\n\nLet's compute each component:\n- $(5 << 0) = 5 \\times 2^0 = 5$\n- $(17 << 3) = 17 \\times 2^3 = 17 \\times 8 = 136$\n- $(42 << 8) = 42 \\times 2^8 = 42 \\times 256 = 10752$\n- $(777 << 14) = 777 \\times 2^{14} = 777 \\times 16384 = 12730368$\n- $(0 << 24) = 0$\n\nSumming these values gives the final packed word in decimal:\n$W = 5 + 136 + 10752 + 12730368 + 0 = 12741261$\n\nTo verify, let's construct the binary representation of $W$ by concatenating the binary values of the fields in their respective positions:\n- Bits $[31:24]$ (reserved): $00000000_2$\n- Bits $[23:14]$ (field 4): $1100001001_2$\n- Bits $[13:8]$ (field 3): $101010_2$\n- Bits $[7:3]$ (field 2): $10001_2$\n- Bits $[2:0]$ (field 1): $101_2$\n\nAssembled as a single $32$-bit word (MSB to LSB):\n$W_{bin} = \\underbrace{00000000}_{[31:24]} \\underbrace{1100001001}_{[23:14]} \\underbrace{101010}_{[13:8]} \\underbrace{10001}_{[7:3]} \\underbrace{101}_{[2:0]}$\n\nGrouping into bytes for clarity:\n$W_{bin} = 00000000\\ 11000010\\ 01101010\\ 10001101_2$\n\nConverting to hexadecimal by grouping into nibbles (4-bit groups):\n$W_{hex} = \\underbrace{0000}_0 \\underbrace{0000}_0\\ \\underbrace{1100}_C \\underbrace{0010}_2\\ \\underbrace{0110}_6 \\underbrace{1010}_A\\ \\underbrace{1000}_8 \\underbrace{1101}_D$\nSo, $W = 0x00C26A8D$.\n\nConverting this hexadecimal value to decimal confirms our result:\n$W = 12 \\times 16^5 + 2 \\times 16^4 + 6 \\times 16^3 + 10 \\times 16^2 + 8 \\times 16^1 + 13 \\times 16^0 = 12741261$.\n\n**3. Endianness and Memory Serialization**\n\nThe $32$-bit packed word $W = 0x00C26A8D$ consists of four $8$-bit bytes. Let's label them from most significant to least significant:\n- Most Significant Byte (MSB): $0x00$\n- Byte 2: $0xC2$\n- Byte 1: $0x6A$\n- Least Significant Byte (LSB): $0x8D$\n\nEndianness determines the order in which these bytes are stored in a contiguous memory buffer.\n\n- **Big-Endian Serialization**: The \"big end\" (most significant byte) is stored first, at the lowest memory address. For a buffer starting at address $A$, the byte order is:\n  - Address $A$: $0x00$\n  - Address $A+1$: $0xC2$\n  - Address $A+2$: $0x6A$\n  - Address $A+3$: $0x8D$\n  The serialized sequence of $4$ bytes is: $00, C2, 6A, 8D$.\n\n- **Little-Endian Serialization**: The \"little end\" (least significant byte) is stored first, at the lowest memory address. For a buffer starting at address $A$, the byte order is:\n  - Address $A$: $0x8D$\n  - Address $A+1$: $0x6A$\n  - Address $A+2$: $0xC2$\n  - Address $A+3$: $0x00$\n  The serialized sequence of $4$ bytes is: $8D, 6A, C2, 00$.\n\nThe final result requested is the packed word expressed as an unsigned integer in decimal.\n$W = 12741261$.", "answer": "$$\\boxed{12741261}$$", "id": "3662512"}, {"introduction": "The abstract properties of data types have direct, tangible consequences for hardware design. This exercise makes that connection explicit by analyzing a parallel algorithm for computing an operand's population count (the number of set bits), a surprisingly useful function in fields from cryptography to bioinformatics. Your task is to determine the minimum bit-width required for the accumulators at each stage of a computational tree, demonstrating how the potential range of a value dictates the physical resources needed to process it [@problem_id:3662552].", "problem": "A processor design requires computing the population count (the number of set bits equal to $1$) of a $64$-bit register operand using a balanced reduction tree composed of partial sums over $8$-bit, $16$-bit, and $32$-bit segments, culminating in a final $64$-bit total. The tree operates as follows: the $64$ input bits are partitioned into $8$ contiguous $8$-bit groups; each $8$-bit group is reduced to its local population count; adjacent local counts are then summed to form $16$-bit segment counts; adjacent $16$-bit segment counts are summed to form $32$-bit segment counts; finally, the two $32$-bit segment counts are summed to obtain the $64$-bit population count.\n\nAssume that at each node in the tree, the partial sum is held in an unsigned accumulator register sized just large enough to represent the full range of possible values for that partial sum without overflow. You may assume ideal, exact addition at each combining step, and treat each partial sum as the exact count of set bits over its covered input segment.\n\nUsing only fundamental principles about integer ranges and binary representation (for example, that the sum of $k$ independent single-bit values lies in $[0,k]$ and that an unsigned binary register of width $w$ can represent exactly $2^{w}$ distinct values $0$ through $2^{w}-1$), determine the minimal total number of accumulator bits required across the entire tree if each partial sum at every stage is stored once (that is, count all accumulators at the $8$-bit stage, all at the $16$-bit stage, all at the $32$-bit stage, and the final $64$-bit sum).\n\nProvide your final answer as an exact integer, with no units.", "solution": "The problem requires the calculation of the total number of bits for all accumulators in a specified reduction tree for computing the population count of a $64$-bit operand. The core principle is that for a partial sum representing the population count of a segment of $k$ bits, the maximum possible value is $k$. An unsigned binary accumulator of width $w$ can represent integers from $0$ to $2^w-1$. Therefore, to store a population count for a $k$-bit segment without overflow, the accumulator width $w$ must be the smallest integer that satisfies the inequality $2^w - 1 \\ge k$. This is equivalent to finding the smallest integer $w$ such that $2^w > k$, which can be formally written as $w = \\lfloor \\log_2(k) \\rfloor + 1$. We will apply this principle to each stage of the reduction tree described.\n\nThe reduction tree has four stages of accumulation:\n1.  Partial sums for $8$-bit segments.\n2.  Partial sums for $16$-bit segments.\n3.  Partial sums for $32$-bit segments.\n4.  The final sum for the $64$-bit operand.\n\nWe will calculate the number of accumulators and the bit-width required for each at every stage.\n\nStage 1: $8$-bit segment population counts.\nThe $64$-bit operand is partitioned into $N_1 = \\frac{64}{8} = 8$ contiguous $8$-bit groups. For each group, a local population count is computed.\nThe maximum value for the population count of an $8$-bit segment is $k_1 = 8$.\nThe minimal accumulator width, $w_1$, must satisfy $2^{w_1} - 1 \\ge 8$.\nFor $w=3$, $2^3 - 1 = 7$, which is insufficient.\nFor $w=4$, $2^4 - 1 = 15$, which is sufficient.\nThus, each of the $8$ accumulators at this stage must have a width of $w_1 = 4$ bits.\nThe total number of bits for this stage is $B_1 = N_1 \\times w_1 = 8 \\times 4 = 32$.\n\nStage 2: $16$-bit segment population counts.\nThe $8$ local counts are combined in pairs, resulting in $N_2 = \\frac{8}{2} = 4$ accumulators. Each of these represents the population count of a $16$-bit segment of the original operand.\nThe maximum value for the population count of a $16$-bit segment is $k_2 = 16$.\nThe minimal accumulator width, $w_2$, must satisfy $2^{w_2} - 1 \\ge 16$.\nFor $w=4$, $2^4 - 1 = 15$, which is insufficient.\nFor $w=5$, $2^5 - 1 = 31$, which is sufficient.\nThus, each of the $4$ accumulators at this stage must have a width of $w_2 = 5$ bits.\nThe total number of bits for this stage is $B_2 = N_2 \\times w_2 = 4 \\times 5 = 20$.\n\nStage 3: $32$-bit segment population counts.\nThe $4$ counts from the previous stage are combined in pairs, resulting in $N_3 = \\frac{4}{2} = 2$ accumulators. Each represents the population count of a $32$-bit segment.\nThe maximum value for the population count of a $32$-bit segment is $k_3 = 32$.\nThe minimal accumulator width, $w_3$, must satisfy $2^{w_3} - 1 \\ge 32$.\nFor $w=5$, $2^5 - 1 = 31$, which is insufficient.\nFor $w=6$, $2^6 - 1 = 63$, which is sufficient.\nThus, each of the $2$ accumulators at this stage must have a width of $w_3 = 6$ bits.\nThe total number of bits for this stage is $B_3 = N_3 \\times w_3 = 2 \\times 6 = 12$.\n\nStage 4: $64$-bit total population count.\nThe $2$ counts from the previous stage are summed to produce the final result, which is stored in $N_4 = \\frac{2}{2} = 1$ final accumulator. This represents the total population count of the $64$-bit operand.\nThe maximum value for this final count is $k_4 = 64$.\nThe minimal accumulator width, $w_4$, must satisfy $2^{w_4} - 1 \\ge 64$.\nFor $w=6$, $2^6 - 1 = 63$, which is insufficient.\nFor $w=7$, $2^7 - 1 = 127$, which is sufficient.\nThus, the final accumulator must have a width of $w_4 = 7$ bits.\nThe total number of bits for this stage is $B_4 = N_4 \\times w_4 = 1 \\times 7 = 7$.\n\nTo find the minimal total number of accumulator bits required across the entire tree, we sum the bits from each stage.\n$B_{total} = B_1 + B_2 + B_3 + B_4$\n$B_{total} = 32 + 20 + 12 + 7$\n$B_{total} = 71$\n\nThe minimal total number of bits required for all accumulators in the tree is $71$.", "answer": "$$\\boxed{71}$$", "id": "3662552"}]}