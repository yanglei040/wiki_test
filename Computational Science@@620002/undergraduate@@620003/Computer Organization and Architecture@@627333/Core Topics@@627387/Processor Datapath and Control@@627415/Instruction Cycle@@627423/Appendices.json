{"hands_on_practices": [{"introduction": "The instruction cycle begins with the fetch stage, but what does \"fetching\" truly entail at the hardware level? This fundamental process is more than a single abstract step; it's a sequence of precise micro-operations constrained by the processor's architecture. This first practice [@problem_id:3649590] challenges you to bridge the gap between the conceptual fetch stage and its physical implementation, considering real-world factors like bus width and endianness to correctly assemble an instruction from memory.", "problem": "A processor implements the instruction cycle in the usual fetch-decode-execute sequence. The memory system is byte-addressable, the external data bus is $8$-bit wide, and each instruction is exactly $16$ bits (that is, $2$ bytes). The Program Counter (PC) holds byte addresses. The Instruction Register (IR) is $16$ bits and stores the fetched instruction before decode. The system uses little-endian instruction encoding: the lower-addressed byte of an instruction is the Least Significant Byte (LSB), and the higher-addressed byte is the Most Significant Byte (MSB). The Control Unit (CU) issues micro-operations to the Memory Address Register (MAR) and the Memory Data Register (MDR) to perform memory accesses.\n\nStarting from the fundamental definitions that (i) a byte-addressable memory returns exactly $8$ bits on a read through an $8$-bit bus, (ii) an instruction of $16$ bits must be assembled from two consecutive byte-address reads, and (iii) under little-endian encoding the lower-addressed byte is the LSB of the $16$-bit instruction, determine which control sequence correctly implements the fetch stage using a $2$-fetch scheme, including the correct $PC$ increments and the correct assembly of bytes into $IR$. Assume that each memory read takes one bus cycle, that $MAR \\leftarrow PC$ places the current byte address on the memory interface, and that after a memory read, $MDR$ holds the returned byte. Use the conventional bit-slice notation $IR[7:0]$ for the low byte and $IR[15:8]$ for the high byte.\n\nWhich option specifies a correct sequence of micro-operations for the fetch phase?\n\n- A. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 1$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.\n\n- B. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 1$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.\n\n- C. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 2$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 2$.\n\n- D. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$; $IR \\leftarrow MDR$; $PC \\leftarrow PC + 2$.\n\nChoose the single best option that is both consistent with the $8$-bit bus constraint and correctly handles the little-endian assembly and $PC$ advancement across the $2$ byte fetches.", "solution": "The problem statement is subjected to validation before proceeding to a solution.\n\n**Step 1: Extract Givens**\n- Processor instruction cycle: fetch-decode-execute.\n- Memory: byte-addressable.\n- External data bus: $8$-bit wide.\n- Instruction size: $16$ bits ($2$ bytes).\n- Program Counter (PC): holds byte addresses.\n- Instruction Register (IR): $16$ bits.\n- Instruction encoding: little-endian (lower-addressed byte is the Least Significant Byte (LSB); higher-addressed byte is the Most Significant Byte (MSB)).\n- Micro-operations: $MAR \\leftarrow PC$ places the PC content into the Memory Address Register; after a memory read, the Memory Data Register (MDR) holds the returned byte.\n- Notation: $IR[7:0]$ is the low byte of IR; $IR[15:8]$ is the high byte of IR.\n- Fundamental definitions:\n    - (i) A memory read on an $8$-bit bus returns exactly $8$ bits.\n    - (ii) A $16$-bit instruction must be assembled from two consecutive byte-address reads.\n    - (iii) Little-endian means the byte at the lower address is the LSB.\n- The fetch stage uses a $2$-fetch scheme.\n- Each memory read takes one bus cycle.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is scientifically grounded, well-posed, and objective.\n1.  **Scientific/Factual Soundness**: The described architecture is a standard, albeit simplified, model used in computer organization education. The concepts of byte-addressability, data bus width, endianness, and the roles of PC, MAR, MDR, and IR are fundamental and correctly represented.\n2.  **Completeness and Consistency**: The problem provides all necessary information to deduce the sequence of micro-operations. The constraints—$8$-bit bus, $16$-bit instruction, and little-endian encoding—are consistent and work together to define the problem unambiguously. The statement that a $16$-bit instruction requires two reads from an $8$-bit bus is a logical consequence of the setup, not a contradiction.\n3.  **Well-Posedness**: The question asks for a specific sequence of operations derivable from the given rules. A unique, logical solution exists. The terminology is standard in the field of computer architecture.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be derived.\n\n**Derivation of the Correct Fetch Sequence**\n\nThe task is to fetch a $16$-bit instruction into the $16$-bit IR. The system has an $8$-bit data bus, so this must be done in two separate memory read cycles. Let the initial address of the instruction be contained in the Program Counter, $PC = P$.\n\n1.  **First Fetch Cycle (for the LSB):**\n    - The processor must first fetch the byte at address $P$. The address is transferred from the PC to the Memory Address Register (MAR): $MAR \\leftarrow PC$.\n    - A memory read operation is initiated. The memory controller fetches the $8$-bit byte from address $P$ and places it in the Memory Data Register (MDR). This can be written as $MDR \\leftarrow \\text{Mem}[MAR]$.\n    - According to the little-endian specification, the byte at the lower address ($P$) is the Least Significant Byte (LSB) of the $16$-bit instruction.\n    - This LSB must be loaded into the lower half of the Instruction Register, which is denoted by $IR[7:0]$. The micro-operation is: $IR[7:0] \\leftarrow MDR$.\n    - To prepare for fetching the next byte, the PC must be updated to point to the address of the second byte of the instruction, which is $P+1$. The micro-operation is: $PC \\leftarrow PC + 1$.\n\n2.  **Second Fetch Cycle (for the MSB):**\n    - The PC now holds the address $P+1$. This address is transferred to the MAR to fetch the second byte: $MAR \\leftarrow PC$.\n    - A memory read operation is performed for address $P+1$, and the resulting $8$-bit byte is loaded into the MDR: $MDR \\leftarrow \\text{Mem}[MAR]$.\n    - This second byte, from the higher address ($P+1$), is the Most Significant Byte (MSB) of the instruction.\n    - The MSB is loaded into the upper half of the Instruction Register, denoted by $IR[15:8]$. The micro-operation is: $IR[15:8] \\leftarrow MDR$.\n    - After the entire $16$-bit instruction has been fetched, the PC must point to the address of the *next* instruction. Since each instruction is $2$ bytes long, the next instruction is at address $P+2$. The PC currently holds $P+1$, so it must be incremented again: $PC \\leftarrow PC + 1$. The final value of PC will be $(P+1)+1 = P+2$.\n\n**Combined Correct Sequence:**\n- Cycle $t_0$: $MAR \\leftarrow PC$; memory read ($MDR \\leftarrow \\text{Mem}[MAR]$); $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.\n- Cycle $t_1$: $MAR \\leftarrow PC$; memory read ($MDR \\leftarrow \\text{Mem}[MAR]$); $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.\n\nThis derived sequence will now be used to evaluate the given options.\n\n**Option-by-Option Analysis**\n\n- **A. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 1$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.**\n  - This option perfectly matches the derived sequence. In $t_0$, it fetches the first byte from the address in PC, correctly identifies it as the LSB ($IR[7:0]$) due to little-endian encoding, and increments PC by $1$. In $t_1$, it uses the new PC value to fetch the second byte, correctly places it in the MSB position ($IR[15:8]$), and increments PC again to point to the next instruction.\n  - **Verdict: Correct.**\n\n- **B. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 1$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 1$.**\n  - This option incorrectly handles the endianness. In cycle $t_0$, it fetches the byte from the lower address but places it into the MSB part of the IR ($IR[15:8]$). This describes a big-endian fetch, which contradicts the problem's explicit statement that the system is little-endian.\n  - **Verdict: Incorrect.**\n\n- **C. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[7:0] \\leftarrow MDR$; $PC \\leftarrow PC + 2$. Cycle $t_1$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR]$; $IR[15:8] \\leftarrow MDR$; $PC \\leftarrow PC + 2$.**\n  - This option has incorrect PC update logic. In cycle $t_0$, after fetching the first byte from address $P$, it increments PC by $2$, so $PC$ becomes $P+2$. In cycle $t_1$, the operation $MAR \\leftarrow PC$ would then attempt to read from address $P+2$, which is the start of the next instruction, not the second byte of the current one. The second byte, residing at $P+1$, is skipped entirely.\n  - **Verdict: Incorrect.**\n\n- **D. Cycle $t_0$: $MAR \\leftarrow PC$; memory read; $MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$; $IR \\leftarrow MDR$; $PC \\leftarrow PC + 2$.**\n  - This option violates several fundamental constraints specified in the problem statement.\n    1.  The operation $MDR \\leftarrow \\text{Mem}[MAR \\ldots MAR+1]$ implies a single memory read that fetches $16$ bits of data. This is impossible with an $8$-bit data bus as stated in premise (i).\n    2.  It contradicts premise (ii), which requires assembly from two consecutive byte reads. This option describes a single read.\n    3.  The problem states that after a memory read, \"MDR holds the returned byte\" ($8$ bits), but this option implies MDR can hold $16$ bits ($IR \\leftarrow MDR$).\n  - **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3649590"}, {"introduction": "Modern processors execute instructions in a pipelined fashion, overlapping the fetch-decode-execute cycles of multiple instructions to increase throughput. While this \"assembly line\" approach boosts performance, it also introduces conflicts known as hazards. This exercise [@problem_id:3649602] requires you to perform a manual, cycle-by-cycle trace of a program on a pipelined processor, giving you a direct feel for how data dependencies and control flow changes create stalls and flushes that the hardware must manage.", "problem": "A toy Reduced Instruction Set Computer (RISC) uses a classic five-stage instruction pipeline implementing the fetch-decode-execute paradigm with stages: Instruction Fetch (IF), Instruction Decode/Register Read (ID), Execute/Address Calculation (EX), Memory Access (MEM), and Register Write-Back (WB). The processor has the following properties and rules:\n\n- The Program Counter (PC) holds a byte address and increments by $4$ on sequential fetch.\n- The Instruction Register (IR) refers to the instruction latched at the ID stage in a given cycle.\n- The register file has $32$ integer registers. Register $R0$ is hardwired to $0$.\n- One instruction issues per cycle when not stalled.\n- Forwarding is available from EX/MEM and MEM/WB pipeline registers to the EX stage inputs, eliminating all arithmetic data hazards except the load-use hazard.\n- A load-use hazard occurs when an instruction in ID needs a register that is the destination of a load currently in EX or MEM; in this case, the hazard unit inserts exactly one bubble (a no-operation in EX) and stalls IF and ID for one cycle. After the stall, forwarding supplies the needed value.\n- Branches are resolved in the EX stage. There is no branch prediction; the pipeline always fetches the fall-through path. On a taken branch, the instructions in IF and ID at the moment of branch resolution are flushed (converted to bubbles), and the PC is redirected to the target starting in the next cycle. The branch itself does not write a register.\n- The instruction memory and data memory each respond in one cycle; there are no cache misses.\n- All arithmetic and logical operations complete in the EX stage with a single-cycle latency.\n\nThe instruction set includes the following operations with their semantics:\n- Load Word: $\\text{LW } R_d, \\text{offset}(R_s)$ loads the $32$-bit word from memory at address $R[R_s] + \\text{offset}$ into register $R_d$ in WB.\n- Add: $\\text{ADD } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] + R[R_t]$ in WB.\n- Subtract: $\\text{SUB } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] - R[R_t]$ in WB.\n- Bitwise Or: $\\text{OR } R_d, R_s, R_t$ writes $R_d \\leftarrow R[R_s] \\,|\\, R[R_t]$ in WB.\n- Branch if Equal: $\\text{BEQ } R_s, R_t, \\text{imm}$ compares $R[R_s]$ and $R[R_t]$; if equal, the next PC becomes $\\text{PC} + 4 + 4 \\times \\text{imm}$; otherwise, it remains $\\text{PC} + 4$.\n\nConsider the following program beginning at byte address $\\text{PC} = 0$ (each instruction is $4$ bytes):\n- At address $0$: $\\text{LW } R1, 0(R0)$\n- At address $4$: $\\text{ADD } R2, R1, R0$\n- At address $8$: $\\text{SUB } R3, R2, R1$\n- At address $12$: $\\text{BEQ } R3, R0, +1$\n- At address $16$: $\\text{ADD } R4, R4, R1$\n- At address $20$: $\\text{OR } R5, R2, R3$\n\nInitial architectural state at cycle $1$ (before any pipeline activity):\n- Registers: $R0 = 0$ (hardwired), $R4 = 7$, and all other general-purpose registers are $0$.\n- Memory: the $32$-bit word at byte address $0$ equals $5$; other memory locations are irrelevant.\n\nTask:\n- Manually step through the program cycle by cycle under the five-stage pipeline with the rules above. For each cycle, log:\n  - The PC value used in IF for that cycle, as a byte address.\n  - The IR content in ID for that cycle (write the mnemonic and operands of the instruction in ID, or indicate a bubble if none).\n  - The architectural register state after WB in that cycle for the registers $R1$, $R2$, $R3$, $R4$, $R5$.\n- Explain precisely where and why any stalls or flushes occur, referring to the fetch-decode-execute flow and the hazard rules.\n\nAnswer specification:\n- After completing the manual step-through and explanations, report the total number of cycles elapsed from the first fetch (cycle $1$) through and including the cycle in which the last committed instruction of the program completes its WB stage. Provide only this total as your final numeric answer. No rounding is needed. Do not include any units in your final numeric answer.", "solution": "We begin from the definitions of the instruction cycle and the five-stage pipeline rules: each instruction progresses through IF, ID (where the Instruction Register holds the current instruction), EX (where arithmetic or address computation and branch condition evaluation occur), MEM (for loads and stores), and WB (where register writes occur). With full forwarding except for the load-use hazard, arithmetic dependencies are resolved without stalls, but a use of a load result by the immediately following instruction requires exactly one stall. Branches are resolved in EX with no prediction; if taken, the instructions in IF and ID at that moment are flushed, incurring a two-instruction penalty.\n\nWe label the instructions for reference:\n- $I_1$: $\\text{LW } R1, 0(R0)$ at address $0$.\n- $I_2$: $\\text{ADD } R2, R1, R0$ at address $4$.\n- $I_3$: $\\text{SUB } R3, R2, R1$ at address $8$.\n- $I_4$: $\\text{BEQ } R3, R0, +1$ at address $12$.\n- $I_5$: $\\text{ADD } R4, R4, R1$ at address $16$.\n- $I_6$: $\\text{OR } R5, R2, R3$ at address $20$.\n\nInitial state before cycle $1$:\n- Registers: $R0 = 0$, $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Memory: $\\text{Mem}[0] = 5$.\n\nWe simulate cycle by cycle, tracking three items per cycle: PC in IF, IR in ID, and register state after WB.\n\nCycle $1$:\n- IF: fetches $I_1$ at $\\text{PC} = 0$; next sequential PC becomes $4$.\n- ID: empty (pipeline fill).\n- EX/MEM/WB: empty.\n- IR in ID: $\\varnothing$.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $2$:\n- IF: fetches $I_2$ at $\\text{PC} = 4$; next PC becomes $8$.\n- ID: $I_1$; reads $R0 = 0$ for address calculation later.\n- EX/MEM/WB: empty.\n- IR in ID: $I_1$ is in ID.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $3$:\n- IF: fetches $I_3$ at $\\text{PC} = 8$; next PC becomes $12$.\n- ID: $I_2$; $I_2$ needs $R1$ and $R0$.\n- EX: $I_1$ computes effective address $R[R0] + 0 = 0$.\n- MEM/WB: empty.\n- IR in ID: $I_2$.\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $4$:\n- Hazard analysis: $I_2$ in ID needs $R1$ which is the destination of $I_1$ (a load) currently in MEM this cycle. This is a classic load-use hazard. By rule, one bubble is inserted in EX and IF/ID are stalled for one cycle.\n- IF: stalled; PC remains $\\text{PC} = 8$ and the fetched $I_3$ is held.\n- ID: $I_2$ remains in ID (stalled).\n- EX: bubble (no instruction).\n- MEM: $I_1$ performs the memory read from address $0$.\n- WB: empty.\n- IR in ID: $I_2$ (stalled).\n- WB effect: none.\n- Registers after WB: $R1 = 0$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Explanation of stall: The load result from $I_1$ is not available for $I_2$’s EX stage in this cycle; forwarding cannot supply it until after MEM completes. The pipeline therefore holds $I_2$ in ID and inserts a bubble in EX.\n\nCycle $5$:\n- IF: fetches $I_4$ at $\\text{PC} = 12$ (the previously held $I_3$ advances to ID).\n- ID: $I_3$; reads $R2$ and $R1$.\n- EX: $I_2$ executes using forwarded $R1 = 5$ (available after the load completes MEM in cycle $4$ and is written in WB in this cycle or forwarded via MEM/WB), and $R0 = 0$; computes $R2 = 5 + 0 = 5$.\n- MEM: empty for $I_2$ (ALU instruction passes through).\n- WB: $I_1$ writes back $R1 \\leftarrow \\text{Mem}[0] = 5$.\n- IR in ID: $I_3$.\n- WB effect: $R1 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $6$:\n- IF: fetches $I_5$ at $\\text{PC} = 16$.\n- ID: $I_4$.\n- EX: $I_3$ executes with operands $R2$ and $R1$. With forwarding, $R2 = 5$ is forwarded from $I_2$’s EX/MEM pipeline register (computed in cycle $5$), and $R1 = 5$ is already in the register file from $I_1$’s WB in cycle $5$. Computes $R3 = 5 - 5 = 0$.\n- MEM: $I_2$ in MEM (ALU op passes through).\n- WB: empty.\n- IR in ID: $I_4$.\n- WB effect: none in this cycle.\n- Registers after WB: $R1 = 5$, $R2 = 0$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $7$:\n- IF: fetches $I_6$ at $\\text{PC} = 20$.\n- ID: $I_5$ (this instruction will be subject to branch control hazard).\n- EX: $I_4$ evaluates branch condition. It needs $R3$ and $R0$; $R3 = 0$ is forwarded from $I_3$’s EX/MEM register (computed in cycle $6$), and $R0 = 0$. Condition is equal, so the branch is taken; branch target is $\\text{PC}_{I_4} + 4 + 4 \\times 1 = 12 + 4 + 4 = 20$.\n- MEM: $I_3$ in MEM (ALU op passes).\n- WB: $I_2$ writes back $R2 \\leftarrow 5$.\n- IR in ID: $I_5$.\n- WB effect: $R2 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n- Explanation of branch flush: Because the branch resolves as taken in EX, the instructions currently in IF ($I_6$ at address $20$) and ID ($I_5$ at address $16$) are on the mis-speculated fall-through path. Both are flushed at the end of this cycle, incurring a two-instruction control hazard penalty. The PC is redirected to $20$ for the next cycle’s fetch.\n\nCycle $8$:\n- IF: fetches from the branch target $\\text{PC} = 20$, i.e., $I_6$.\n- ID: bubble (flushed $I_5$).\n- EX: bubble (the flushed bubble from ID advances).\n- MEM: $I_4$ in MEM (branch occupies stages but writes no register).\n- WB: $I_3$ writes back $R3 \\leftarrow 0$.\n- IR in ID: $\\varnothing$ (bubble).\n- WB effect: $R3 \\leftarrow 0$ (no change in value but architectural write occurs).\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $9$:\n- IF: fetches next sequential $\\text{PC} = 24$ (content irrelevant; the program’s last committed instruction is $I_6$).\n- ID: $I_6$.\n- EX: bubble.\n- MEM: bubble.\n- WB: $I_4$ (branch) in WB does not write.\n- IR in ID: $I_6$.\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $10$:\n- IF: fetches $\\text{PC} = 28$ (irrelevant).\n- ID: bubble (as $I_6$ moves to EX).\n- EX: $I_6$ executes: computes $R5 = R2 \\,|\\, R3 = 5 \\,|\\, 0 = 5$.\n- MEM: bubble.\n- WB: bubble.\n- IR in ID: $\\varnothing$ (bubble).\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $11$:\n- IF: fetches $\\text{PC} = 32$ (irrelevant).\n- ID: bubble.\n- EX: bubble.\n- MEM: $I_6$.\n- WB: bubble.\n- IR in ID: $\\varnothing$.\n- WB effect: none.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 0$.\n\nCycle $12$:\n- IF: fetches $\\text{PC} = 36$ (irrelevant).\n- ID: bubble.\n- EX: bubble.\n- MEM: bubble.\n- WB: $I_6$ writes back $R5 \\leftarrow 5$.\n- IR in ID: $\\varnothing$.\n- WB effect: $R5 \\leftarrow 5$.\n- Registers after WB: $R1 = 5$, $R2 = 5$, $R3 = 0$, $R4 = 7$, $R5 = 5$.\n\nStalls and flushes explained:\n- The single load-use stall occurs in cycle $4$ because $I_2$ depends on the result of $I_1$ and the loaded data is not available for EX until after $I_1$ completes MEM. The hazard unit inserts one bubble in EX and holds IF/ID, as reflected by the repeated $\\text{PC} = 8$ and $I_2$ remaining in ID in cycle $4$.\n- The taken branch in $I_4$ is resolved in EX in cycle $7$, flushing the instructions in IF and ID ($I_6$ and $I_5$) and redirecting the PC to the target ($20$). This creates two bubbles that appear in ID and EX in cycle $8$, and the pipeline refetches $I_6$ from the correct target.\n\nFinal committed instruction and total cycles:\n- The last committed instruction is $I_6$ at address $20$, which completes its WB stage in cycle $12$.\n- Counting from the initial fetch in cycle $1$ through the completion of WB for $I_6$, the total number of cycles is $12$.\n\nTherefore, the required total cycle count is $12$.", "answer": "$$\\boxed{12}$$", "id": "3649602"}, {"introduction": "Understanding how individual hazards cause stalls is essential, but how do these small delays accumulate to affect overall program runtime? To answer this, we move from a micro-level trace to a macro-level performance analysis. This final practice [@problem_id:3649545] introduces the critical metric of Cycles Per Instruction ($CPI$), showing you how to calculate it by systematically accounting for the performance costs of structural, data, and control hazards based on a program's statistical profile.", "problem": "A single-issue, five-stage pipeline implements the instruction cycle with instruction fetch, decode, execute, memory access, and register writeback. In the absence of hazards and resource conflicts, the machine sustains an ideal throughput of one instruction per cycle. A stall cycle is defined as a cycle in which no new instruction begins fetch, so the Program Counter (PC) remains unchanged; the PC increments by $\\;4\\;$ bytes only when an instruction fetch starts.\n\nConsider a workload of $N=200{,}000$ dynamic instructions with the following statistically steady composition and behavior:\n- The fraction of memory-accessing instructions is $f_{\\text{mem}}$, consisting of loads with fraction $f_{\\text{ld}}=0.25$ and stores with fraction $f_{\\text{st}}=0.10$; assume a unified, single-ported memory that cannot serve an instruction fetch and a data access in the same cycle, so when a load or store reaches the memory stage the processor must insert a single stall cycle to avoid conflict.\n- The fraction of immediately dependent instruction pairs (where the next instruction consumes a value produced by the previous instruction) is $p_{\\text{dep}}=0.20$. Among these dependent pairs, the fraction that are load-use pairs is $p_{\\text{lu}}=0.50$. Due to latency beyond what forwarding can hide, a fraction $p_{\\text{unres}}=0.80$ of these load-use pairs require insertion of $2$ stall cycles to satisfy the data dependency.\n- The fraction of branch instructions is $f_{\\text{br}}=0.20$. The branch predictor exhibits a misprediction probability $p_{\\text{misp}}=0.10$, and each misprediction triggers a pipeline flush that costs $3$ stall cycles before the correct next PC is fetched.\n\nUsing the core definitions that Cycles Per Instruction (CPI) is the average number of cycles per retired instruction and that each stall adds cycles in which the PC does not advance, derive from first principles the expected average stall cycles per instruction contributed by structural, data, and control effects for this workload. Then compute the expected total number of cycles needed to retire all $N$ instructions.\n\nProvide your final answer as a single real number representing the expected total cycles. No rounding is required.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in computer architecture concerning pipeline performance analysis. All data and conditions provided are sufficient and consistent for deriving a unique solution.\n\nThe total number of cycles, $C$, required to execute a program is the product of the number of dynamic instructions, $N$, and the average Cycles Per Instruction, $CPI$.\n$$C = N \\times CPI$$\nThe $CPI$ can be decomposed into an ideal component and a stall component. For a single-issue pipeline without hazards, one instruction completes per cycle, making the ideal $CPI$ equal to $1$. Any deviation from this ideal performance is due to stall cycles introduced by various hazards.\n$$CPI = CPI_{\\text{ideal}} + CPI_{\\text{stall}}$$\nwhere $CPI_{\\text{ideal}} = 1$. The term $CPI_{\\text{stall}}$ represents the average number of stall cycles incurred per instruction. This can be calculated by summing the contributions from all sources of stalls. The problem describes three types of hazards: structural, data, and control. Let $S_{\\text{struct}}$, $S_{\\text{data}}$, and $S_{\\text{control}}$ be the average stall cycles per instruction contributed by each type of hazard, respectively.\n$$CPI_{\\text{stall}} = S_{\\text{struct}} + S_{\\text{data}} + S_{\\text{control}}$$\nOur primary task is to derive these three components from first principles based on the provided workload characteristics.\n\n**1. Structural Hazard Stalls ($S_{\\text{struct}}$)**\n\nThe structural hazard arises from the single-ported memory, which cannot service an instruction fetch and a data access (load or store) in the same cycle. When an instruction performing a memory access reaches the memory (MEM) stage of the $5$-stage pipeline, a stall must be inserted to prevent conflict with the fetch of a subsequent instruction.\nThe frequency of this event is determined by the fraction of instructions that perform a memory access. These are the load and store instructions.\n- Fraction of load instructions: $f_{\\text{ld}} = 0.25$\n- Fraction of store instructions: $f_{\\text{st}} = 0.10$\nThe total fraction of memory-accessing instructions is $f_{\\text{mem}} = f_{\\text{ld}} + f_{\\text{st}}$.\nEach occurrence of this hazard costs $1$ stall cycle.\nThe average number of stall cycles per instruction due to this structural hazard is the product of the frequency of memory-access instructions and the stall cost per occurrence.\n$$S_{\\text{struct}} = (f_{\\text{ld}} + f_{\\text{st}}) \\times 1 = (0.25 + 0.10) \\times 1 = 0.35$$\n\n**2. Data Hazard Stalls ($S_{\\text{data}}$)**\n\nData hazards cause stalls when a dependency cannot be resolved by the pipeline's forwarding logic in time. The problem specifies a cascade of conditions for a data hazard stall to occur.\n- The fraction of instruction pairs that are immediately dependent is $p_{\\text{dep}} = 0.20$. This means the probability that an instruction depends on the result of the immediately preceding instruction is $0.20$.\n- Among these dependent pairs, the fraction that are load-use pairs (where the consumer instruction uses a value loaded from memory by the producer instruction) is $p_{\\text{lu}} = 0.50$.\n- Among these load-use pairs, a fraction $p_{\\text{unres}} = 0.80$ cannot be resolved by forwarding and require stalls.\nThe probability that any given instruction will trigger a data hazard stall is the product of these probabilities, as they form a sequence of conditional events. Let this probability be $P(\\text{data stall})$.\n$$P(\\text{data stall}) = p_{\\text{dep}} \\times p_{\\text{lu}} \\times p_{\\text{unres}}$$\nEach occurrence of such an unresolved load-use dependency costs $2$ stall cycles.\nThe average number of stall cycles per instruction due to data hazards is the product of the probability of the event and its cost.\n$$S_{\\text{data}} = P(\\text{data stall}) \\times 2 = (p_{\\text{dep}} \\times p_{\\text{lu}} \\times p_{\\text{unres}}) \\times 2$$\nSubstituting the given values:\n$$S_{\\text{data}} = (0.20 \\times 0.50 \\times 0.80) \\times 2 = (0.10 \\times 0.80) \\times 2 = 0.08 \\times 2 = 0.16$$\n\n**3. Control Hazard Stalls ($S_{\\text{control}}$)**\n\nControl hazards arise from branch mispredictions. When a branch is mispredicted, the instructions that were speculatively fetched from the wrong path must be flushed from the pipeline, and the pipeline must be refilled from the correct target address. This process incurs stall cycles.\n- The fraction of all instructions that are branches is $f_{\\text{br}} = 0.20$.\n- The probability that a branch is mispredicted is $p_{\\text{misp}} = 0.10$.\nThe probability that any given instruction is a mispredicted branch is the product of the fraction of branches and the misprediction probability. Let this be $P(\\text{control stall})$.\n$$P(\\text{control stall}) = f_{\\text{br}} \\times p_{\\text{misp}}$$\nEach misprediction costs $3$ stall cycles.\nThe average number of stall cycles per instruction due to control hazards is the product of the probability of a mispredicted branch and the associated penalty.\n$$S_{\\text{control}} = P(\\text{control stall}) \\times 3 = (f_{\\text{br}} \\times p_{\\text{misp}}) \\times 3$$\nSubstituting the given values:\n$$S_{\\text{control}} = (0.20 \\times 0.10) \\times 3 = 0.02 \\times 3 = 0.06$$\n\n**4. Total Cycles Calculation**\n\nNow we can compute the total $CPI_{\\text{stall}}$ by summing the contributions from each hazard type.\n$$CPI_{\\text{stall}} = S_{\\text{struct}} + S_{\\text{data}} + S_{\\text{control}} = 0.35 + 0.16 + 0.06 = 0.57$$\nThe total CPI for the processor on this workload is:\n$$CPI = CPI_{\\text{ideal}} + CPI_{\\text{stall}} = 1 + 0.57 = 1.57$$\nFinally, we can calculate the expected total number of cycles, $C$, to execute the entire workload of $N = 200,000$ instructions.\n$$C = N \\times CPI = 200,000 \\times 1.57$$\n$$C = 314,000$$\nThus, the expected total number of cycles to retire all $N$ instructions is $314,000$.", "answer": "$$\\boxed{314000}$$", "id": "3649545"}]}