{"hands_on_practices": [{"introduction": "Understanding the performance of a pipelined processor requires quantifying the impact of various hazards. This first practice problem [@problem_id:3664950] challenges you to calculate the average Cycles Per Instruction (CPI) for a code loop, integrating the effects of both data hazards from load-use dependencies and stalls from probabilistic cache misses. By working through this, you'll develop a crucial skill: analyzing how instruction scheduling and memory behavior collectively determine real-world processor throughput.", "problem": "Consider a single-issue, in-order, classic 5-stage pipeline with stages Instruction Fetch (IF), Instruction Decode/Register Read (ID), Execute (EX), Memory (MEM), and Write Back (WB). The processor implements full data forwarding for Arithmetic Logic Unit (ALU) operations, so ALU-to-ALU read-after-write data dependencies incur no stalls. However, a load-use dependency where an instruction immediately consumes the result of a preceding load requires exactly 1 stall cycle if the load hits in the first-level data cache. The branch predictor is perfect, so there are no control hazard penalties. There are no structural hazards.\n\nAssume the following loop body repeats in steady state for a large number of iterations so that startup and wind-down effects are negligible:\n- $1.$ $\\mathrm{LD}\\ r_1,\\ 0(r_A)$\n- $2.$ $\\mathrm{ADD}\\ r_5,\\ r_5,\\ r_6$\n- $3.$ $\\mathrm{XOR}\\ r_7,\\ r_7,\\ r_8$\n- $4.$ $\\mathrm{ADD}\\ r_2,\\ r_1,\\ r_9$  (consumes the value loaded into $r_1$)\n- $5.$ $\\mathrm{LD}\\ r_3,\\ 0(r_B)$\n- $6.$ $\\mathrm{ADD}\\ r_4,\\ r_3,\\ r_{10}$ (consumes the value loaded into $r_3$)\n- $7.$ $\\mathrm{SUB}\\ r_A,\\ r_A,\\ r_{11}$\n- $8.$ $\\mathrm{BNE}\\ r_A,\\ r_Z,\\ \\text{loop}$\n\nAll ALU operations have single-cycle execute latency and can forward results with zero additional stalls if they are not load-use dependencies. The only memory operations are the two loads listed above. Each load independently misses in the cache with probability $p \\in [0,1]$. On a cache hit, the MEM stage takes $1$ cycle. On a cache miss, the loadâ€™s MEM stage incurs a blocking miss penalty of $m$ additional cycles, during which the pipeline is stalled; thus, the MEM stage of a missing load occupies $1 + m$ cycles, and no new instructions can pass the stall while the miss is outstanding. At most one miss can be outstanding.\n\nUsing only these facts, derive a closed-form analytic expression, in terms of $p$ and $m$, for the long-run average cycles per instruction (CPI), where CPI is defined as cycles per instruction (CPI). Your answer must be a single simplified expression. Do not approximate or round.", "solution": "The problem asks for the long-run average cycles per instruction (CPI). The analysis will be performed for a single, steady-state iteration of the given loop. The CPI is defined as the average number of cycles required per instruction. For a loop, this can be calculated as:\n$$\n\\text{CPI} = \\frac{\\text{Average cycles per loop iteration}}{\\text{Instructions per loop iteration}}\n$$\nThe loop body consists of $N_{\\text{instr}} = 8$ instructions. Let $E[C]$ be the average number of cycles per loop iteration.\n$$\n\\text{CPI} = \\frac{E[C]}{8}\n$$\nThe number of cycles for one loop iteration is the sum of the ideal execution cycles and any additional stall cycles. In a single-issue pipeline with no hazards, one instruction would complete every cycle, so the ideal number of cycles for $8$ instructions is $8$.\n$$\nE[C] = C_{\\text{ideal}} + E[C_{\\text{stall}}] = 8 + E[C_{\\text{stall}}]\n$$\nOur task is to determine the average number of stall cycles per iteration, $E[C_{\\text{stall}}]$. We must identify all sources of stalls in the provided instruction sequence.\n\n1.  **Data Hazards (Read-After-Write):**\n    *   **Dependency $\\mathrm{I1} \\to \\mathrm{I4}$**: Instruction $4$ ($\\mathrm{ADD}\\ r_2,\\ r_1,\\ r_9$) uses the result of instruction $1$ ($\\mathrm{LD}\\ r_1,\\ 0(r_A)$). However, these two instructions are separated by instructions $2$ and $3$. In the $5$-stage pipeline, this separation is sufficient to resolve the hazard without a stall, using standard data forwarding. The value loaded by `I1` is available from its MEM stage, and by the time `I4` reaches its EX stage, `I1` has already passed the MEM stage. Thus, no stall cycles are incurred for this dependency.\n    *   **Dependency $\\mathrm{I5} \\to \\mathrm{I6}$**: Instruction $6$ ($\\mathrm{ADD}\\ r_4,\\ r_3,\\ r_{10}$) immediately consumes the result of instruction $5$ ($\\mathrm{LD}\\ r_3,\\ 0(r_B)$). This is a classic load-use hazard. The problem specifies that this exact scenario incurs a $1$-cycle stall, but only if the load (`I5`) is a cache hit. If `I5` misses, the long cache-miss penalty stall resolves the hazard, so the $1$-cycle stall is not added on top. The probability of instruction `I5` being a cache hit is $(1-p)$.\n    *   **Other data hazards**: ALU-to-ALU dependencies (e.g., `I7` to `I8` and `I7` to `I1` of the next iteration) are fully resolved by forwarding with no stalls, as per the problem statement.\n\n2.  **Control Hazards:** The branch predictor is perfect, so there are $0$ stall cycles due to the `BNE` instruction.\n\n3.  **Structural Hazards:** The problem explicitly states there are no structural hazards.\n\n4.  **Cache Misses:** There are two load instructions, `I1` and `I5`. Each can miss independently with probability $p$. A miss stalls the pipeline for $m$ additional cycles. Since the pipeline is in-order and blocking, if both loads in an iteration miss, their stall penalties are additive.\n\nWe can calculate the total expected stall cycles per iteration by summing the expected stalls from each independent source, thanks to the linearity of expectation.\n\n*   **Expected stall from the $\\mathrm{I5} \\to \\mathrm{I6}$ load-use hazard ($E[S_1]$):**\n    A $1$-cycle stall occurs only if `I5` is a cache hit.\n    $$ E[S_1] = (1 \\text{ cycle}) \\times P(\\text{I5 hits}) + (0 \\text{ cycles}) \\times P(\\text{I5 misses}) = 1 \\cdot (1-p) = 1-p $$\n\n*   **Expected stall from a cache miss on `I1` ($E[S_2]$):**\n    An $m$-cycle stall occurs if `I1` misses.\n    $$ E[S_2] = (m \\text{ cycles}) \\times P(\\text{I1 misses}) + (0 \\text{ cycles}) \\times P(\\text{I1 hits}) = m \\cdot p $$\n\n*   **Expected stall from a cache miss on `I5` ($E[S_3]$):**\n    An $m$-cycle stall occurs if `I5` misses.\n    $$ E[S_3] = (m \\text{ cycles}) \\times P(\\text{I5 misses}) + (0 \\text{ cycles}) \\times P(\\text{I5 hits}) = m \\cdot p $$\n\nThe total expected number of stall cycles per iteration is the sum of these expectations:\n$$\nE[C_{\\text{stall}}] = E[S_1] + E[S_2] + E[S_3] = (1-p) + mp + mp = 1 - p + 2mp\n$$\nNow we can compute the average total cycles per iteration, $E[C]$:\n$$\nE[C] = C_{\\text{ideal}} + E[C_{\\text{stall}}] = 8 + (1 - p + 2mp) = 9 - p + 2mp\n$$\nThis expression can be rewritten by factoring out $p$:\n$$\nE[C] = 9 + p(2m - 1)\n$$\nFinally, we compute the average CPI by dividing the average cycles per iteration by the number of instructions in the iteration:\n$$\n\\text{CPI} = \\frac{E[C]}{N_{\\text{instr}}} = \\frac{9 - p + 2mp}{8}\n$$\nThis is the final, simplified, closed-form analytic expression for the CPI.", "answer": "$$\n\\boxed{\\frac{9 - p + 2mp}{8}}\n$$", "id": "3664950"}, {"introduction": "Beyond data dependencies, control hazards pose a significant threat to pipeline efficiency, especially those arising from function calls and returns. This exercise [@problem_id:3664987] presents a scenario where deep recursion causes a Return Address Stack (RAS) to overflow, leading to predictable control mispredictions. You will calculate the resulting stall penalty and see how a software solution, tail-call optimization, can completely eliminate this hardware-level problem, illustrating the powerful synergy between compiler design and microarchitecture.", "problem": "Consider a single-issue, in-order pipeline with the following 6 stages: Instruction Fetch (IF, stage $1$), Instruction Decode (ID, stage $2$), Register Read (RR, stage $3$), Execute (EX, stage $4$), Memory (MEM, stage $5$), and Write-Back (WB, stage $6$). Control transfers, including function returns, are resolved when the return instruction reaches the Execute (EX) stage, and at that moment all younger instructions in earlier stages are squashed if the predicted next program counter was incorrect.\n\nA dynamic predictor uses a Return Address Stack (RAS) with capacity $C$ entries. The RAS stores return addresses on function calls and supplies them on returns. Assume:\n- Each stage takes exactly $1$ cycle.\n- A mispredicted return causes a pipeline flush of all younger stages present when the return is resolved.\n- The recursion is self-tail after the main computation, so each invocation performs a single tail call to itself until a base case is met.\n- All non-return control transfers other than returns are perfectly predicted.\n\nA compiler does not perform tail-call optimization on a particular recursive function that reaches a maximum recursion depth of $D = 50$ frames (including the base case). The microarchitecture provides an RAS of capacity $C = 16$. When the recursion unwinds, returns beyond the RAS capacity pop incorrect addresses due to earlier overflows, causing mispredictions.\n\nStarting only from the core definitions of pipeline hazards (control hazards from unresolved branch targets), pipeline stage timing, and the behavior of the Return Address Stack (RAS) under overflow, derive the total stall penalty in cycles due to return mispredictions for the baseline (no tail-call optimization) case. Then, propose tail-call optimization that converts the recursive tail call into an equivalent loop, eliminating per-invocation returns along the recursive chain. Under this optimization, assume there is only a single final return at the end of the loop and the RAS never overflows.\n\nCompute the net number of stall cycles eliminated by tail-call optimization compared to the baseline recursion scenario. Express your final answer as an exact integer number of cycles. No rounding is required, and no physical units need to be reported inside the final answer box.", "solution": "We begin from the fundamental notions of pipeline hazards and predictor behavior:\n\n- A control hazard arises when the next program counter is not known early enough, such that the pipeline may fetch down the wrong path. If a prediction is wrong, the instructions fetched along the wrong path in younger stages must be squashed, incurring stall cycles.\n- In a $6$-stage pipeline with stages numbered $1$ through $6$, if a control transfer resolves at stage $k$, then there are $k-1$ younger stages ($1$ through $k-1$) that may hold wrong-path instructions at the moment of resolution. Squashing those instructions and redirecting the fetch incurs a penalty of $k-1$ cycles in a simple in-order pipeline with one cycle per stage.\n- A Return Address Stack (RAS) pushes the return address on a call and pops it on the matching return. If the recursion depth $D$ exceeds the RAS capacity $C$, then pushes beyond $C$ overwrite or displace older entries so that the earliest $D-C$ returns will pop incorrect addresses. Each such incorrect pop constitutes a mispredicted return.\n\nWe apply these principles to the given pipeline and recursion:\n\n1. The return resolves at Execute (EX), which is stage $k = 4$ in the given pipeline (IF is $1$, ID is $2$, RR is $3$, EX is $4$). Therefore, a mispredicted return incurs a stall penalty of\n   $$ p = k - 1 = 4 - 1 = 3 \\text{ cycles}. $$\n\n2. The recursion reaches depth $D = 50$, while the RAS capacity is $C = 16$. Under overflow, the number of returns that will be popped with incorrect addresses during unwinding is\n   $$ N_{\\text{mispred}} = D - C = 50 - 16 = 34. $$\n\n3. Each mispredicted return incurs $p = 3$ cycles of penalty. Therefore, the total stall penalty due to return mispredictions in the baseline (no tail-call optimization) scenario is\n   $$ S_{\\text{baseline}} = N_{\\text{mispred}} \\cdot p = 34 \\cdot 3 = 102. $$\n\nNow we consider tail-call optimization:\n\n- Tail-call optimization rewrites the self-tail call so that the function no longer pushes a new frame for the tail call; instead, it becomes a loop that iterates until the base case. This eliminates per-invocation returns along the recursive chain and thus eliminates the series of returns that would have caused RAS overflows and mispredictions.\n- Under the optimization, there is only a single final return after the loop finishes. With only $1$ return and RAS capacity $C = 16$, there is no overflow, so the RAS pop is correct. By assumption, non-return control transfers are perfectly predicted, and we treat the final return as correctly handled by the RAS. Therefore, the stall penalty due to return mispredictions after optimization is\n  $$ S_{\\text{optimized}} = 0. $$\n\nThe net stall cycles eliminated by tail-call optimization, relative to the baseline, is\n$$ \\Delta S = S_{\\text{baseline}} - S_{\\text{optimized}} = 102 - 0 = 102. $$\n\nHence, the exact integer number of cycles saved is $102$.", "answer": "$$\\boxed{102}$$", "id": "3664987"}, {"introduction": "Effective hazard detection is critical, but overly conservative checks can create unnecessary stalls, hurting performance. This final practice [@problem_id:3665019] delves into the microarchitectural details of dependency checking, focusing on 'false' Read-After-Write (RAW) hazards that occur with subword register updates. You will first construct a code sequence that exposes this flaw and then calculate the hardware complexity needed to implement a more precise, mask-based detection unit, providing insight into the design trade-offs at the heart of modern CPUs.", "problem": "A scalar machine with 64-bit general-purpose registers supports subword operations that read or write contiguous, naturally aligned fields of size 1, 2, 4, or 8 bytes within a register. The pipeline currently uses a naive dependence checking rule for Read After Write (RAW): a younger instruction that reads register $r$ is considered RAW-dependent on any older in-flight instruction that writes register $r$, regardless of which subword fields are actually read or written.\n\nPart A (conceptual setup): Construct a two-instruction sequence, expressed at the level of intent (naming which subword fields are accessed), that triggers a false positive RAW under this naive rule but has no true data dependence because the written and read subwords are disjoint. You may assume a generic arithmetic instruction that reads only the high 32 bits of a source register and a byte-write instruction that writes only the lowest 8 bits of a destination register.\n\nPart B (derivation and calculation): To eliminate such false positives without missing true hazards, you redesign the hazard detection unit to track per-byte masks. For each older in-flight instruction $j$ that will write some destination register $d_{j}$, you store:\n- a register identifier, and\n- an 8-bit write mask $W_{j}$, where bit $k \\in \\{0,\\dots,7\\}$ indicates whether byte $k$ of $d_{j}$ will be written.\n\nFor each source operand $i$ of the newly decoded instruction, you obtain:\n- a register identifier $r_{i}$, and\n- an 8-bit read mask $R_{i}$, where bit $k$ indicates whether byte $k$ of $r_{i}$ will be read.\n\nA true RAW exists between source operand $i$ and older instruction $j$ if and only if $r_{i} = d_{j}$ and the intersection of accessed bytes is nonempty, that is, if and only if the bitwise intersection $W_{j} \\wedge R_{i}$ has at least one $1$ bit.\n\nYou are asked to quantify the minimum mask-based dependency tracking complexity in terms of bit-level operations needed per cycle in the decode stage to evaluate RAW hazards for one newly decoded instruction, under the following constraints:\n- There are at most $f$ older in-flight writer instructions relevant to RAW checking.\n- The new instruction has at most $r$ source operands.\n- The hazard unit must compute all pairwise mask overlaps $W_{j} \\wedge R_{i}$ for all pairs $(i,j)$ without time-multiplexing (that is, all required bitwise-AND operations are performed within the cycle).\n- You are to count only the number of $1$-bit AND operations used to form these pairwise overlap vectors (ignore the cost of register-identifier equality comparisons and any OR-reductions used to test nonemptiness).\n\nDerive, from first principles, a closed-form expression for the minimum number of $1$-bit AND operations required as a function of $r$, $f$, and the number of bytes per register $b$. Then evaluate this expression for $r = 3$, $f = 24$, and $b = 8$. Express the final answer as a single number. No units are required, and no rounding is needed.", "solution": "**Part A: Conceptual False Positive RAW Hazard**\n\nA false positive Read-After-Write (RAW) hazard occurs when the hardware detects a dependency that does not actually exist at the data level, leading to an unnecessary pipeline stall. The naive rule, which checks for dependency at the whole-register level, is susceptible to such errors when subword operations are involved.\n\nLet us consider a sequence of two instructions, an older instruction $I_1$ and a younger instruction $I_2$, both operating on the same 64-bit register, which we will call $R_A$. A 64-bit register consists of 8 bytes, which we can index from byte 0 (least significant) to byte 7 (most significant).\n\n1.  **Older Instruction, $I_1$**: This is the byte-write instruction specified in the problem. It writes a value to register $R_A$, but only modifies the lowest byte.\n    - **Action**: Writes to byte $0$ of register $R_A$ (bits $7$ through $0$).\n    - **Bytes Written**: $\\{0\\}$\n\n2.  **Younger Instruction, $I_2$**: This is the arithmetic instruction specified in the problem. It uses register $R_A$ as a source operand but only requires the value stored in the high 32 bits.\n    - **Action**: Reads the high 32 bits, which correspond to the upper 4 bytes of register $R_A$.\n    - **Bytes Read**: $\\{4, 5, 6, 7\\}$\n\n**Analysis of Dependency:**\n\n- **Naive Rule Application**: The hazard detection unit sees that $I_1$ writes to register $R_A$ and a subsequent instruction, $I_2$, reads from register $R_A$. Based on its rule, it flags a RAW dependency. This forces the pipeline to stall $I_2$ until $I_1$ has completed its write-back stage, ensuring that $I_2$ reads the \"correct\" value of $R_A$.\n\n- **True Dependency Analysis**: A true data dependency exists only if the execution of $I_1$ affects the result of $I_2$. This would happen if $I_2$ reads a part of the register that $I_1$ has modified. In this case, the set of bytes written by $I_1$ is $\\{0\\}$, and the set of bytes read by $I_2$ is $\\{4, 5, 6, 7\\}$. The intersection of these two sets is empty: $\\{0\\} \\cap \\{4, 5, 6, 7\\} = \\emptyset$. Therefore, the value read by $I_2$ is completely independent of the write performed by $I_1$. The RAW hazard flagged by the naive checker is a **false positive**. The stall was unnecessary, resulting in a loss of performance.\n\n**Part B: Derivation and Calculation of Hardware Complexity**\n\nThe redesigned hazard detection unit aims to eliminate these false positives by tracking dependencies at the byte level using bitmasks. We need to derive a closed-form expression for the total number of $1$-bit AND operations required per cycle to perform this more precise check.\n\nLet $N$ be the total number of $1$-bit AND operations.\nThe problem provides the following parameters:\n- $r$: the maximum number of source operands for the newly decoded instruction.\n- $f$: the maximum number of older, in-flight instructions that write to a register.\n- $b$: the number of bytes per register. This corresponds to the length of the read and write masks.\n\nThe logic for a true RAW hazard for a given source operand $i$ and an older writer instruction $j$ is:\n$(r_i = d_j) \\wedge (\\text{non-zero}(W_j \\wedge R_i))$\nwhere $r_i$ and $d_j$ are register identifiers, and $W_j$ and $R_i$ are the respective $b$-bit write and read masks.\n\nWe are asked to count only the $1$-bit AND operations used to form the pairwise overlap vectors, $W_j \\wedge R_i$.\n\n1.  **Operations per Pair**: For a single pair consisting of one source operand $i$ and one older writer $j$, we need to compute the bitwise AND of their masks, $W_j \\wedge R_i$. Since each mask is a $b$-bit vector, computing their bitwise AND requires performing $b$ independent $1$-bit AND operations.\n\n2.  **Number of Pairs**: The check must be performed for every source operand of the new instruction against every older writer instruction.\n    - Number of source operands = $r$.\n    - Number of older writers = $f$.\n    - The hardware must evaluate all possible pairings in parallel within a single cycle. The total number of such pairs $(i, j)$ is the product of the number of source operands and the number of older writers, which is $r \\times f$.\n\n3.  **Total Operations**: The total number of $1$-bit AND operations, $N$, is the number of pairs multiplied by the number of $1$-bit AND operations per pair.\n    $$ N = (\\text{Number of pairs}) \\times (\\text{Operations per pair}) $$\n    Substituting the expressions from the steps above:\n    $$ N = (r \\times f) \\times b $$\n    Thus, the closed-form expression is:\n    $$ N = rfb $$\n\n**Evaluation for Specific Parameters**:\nWe are asked to evaluate this expression for the given values:\n- $r = 3$\n- $f = 24$\n- $b = 8$ (since the registers are 64-bit, meaning $64/8 = 8$ bytes)\n\nSubstituting these values into our derived expression:\n$$ N = (3) \\times (24) \\times (8) $$\nFirst, we compute the product of $r$ and $f$:\n$$ 3 \\times 24 = 72 $$\nThen, we multiply this result by $b$:\n$$ N = 72 \\times 8 $$\n$$ N = 576 $$\nTherefore, a minimum of $576$ individual $1$-bit AND gates are required to compute all the necessary overlap masks in parallel for a single new instruction in one cycle.", "answer": "$$\\boxed{576}$$", "id": "3665019"}]}