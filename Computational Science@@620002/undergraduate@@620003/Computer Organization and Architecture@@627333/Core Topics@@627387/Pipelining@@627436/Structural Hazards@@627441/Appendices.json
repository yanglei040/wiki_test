{"hands_on_practices": [{"introduction": "A structural hazard occurs when a piece of hardware is needed by more than one instruction at the same time. This first practice provides a clear, foundational example of this issue within the register file, a critical component of the CPU. By analyzing the mismatch between an instruction's demands and the available hardware ports, you will calculate the direct impact on performance, quantified by Cycles Per Instruction (CPI), and see how a single bottleneck can slow down the entire pipeline [@problem_id:3682639].", "problem": "Consider a scalar, five-stage pipeline in a Central Processing Unit (CPU) with the following stages: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). In the absence of hazards, each stage occupies exactly $1$ clock cycle per instruction, and the pipeline issues at most one instruction per cycle. The register file can service up to $R$ read ports and $W$ write ports per cycle. A triadic instruction requires reading $3$ source registers and writing $1$ destination register. Reads are performed only in the ID stage, and writes are performed only in the WB stage. The register file cannot perform more than $R$ reads or more than $W$ writes in the same cycle, and the ID stage cannot move forward to the EX stage until all required register reads for the instruction have been completed. Hazard resolution is performed solely by stalling: a stage that cannot complete its required work in the current cycle holds its instruction and prevents upstream stages from advancing.\n\nConsider a long steady-state sequence of such triadic instructions with no data dependencies, no control hazards, and no memory operations in the MEM stage, so that the only potential hazards are structural hazards arising from the register file ports. Let $R=2$ and $W=1$. Under optimal scheduling consistent with the given constraints, what is the steady-state average Cycles Per Instruction (CPI) of this pipeline?\n\nExpress your final answer as a single real number. No rounding is necessary.", "solution": "The foundational definitions are as follows. A structural hazard arises when hardware resources required in a given cycle exceed their available capacity. In a pipelined CPU, if a stage cannot complete its required operations due to insufficient resources, that stage must stall, which prevents upstream stages from advancing and can reduce throughput. The average Cycles Per Instruction (CPI) in steady state for a scalar pipeline with balanced stages and no hazards is $1$. If one stage requires more than $1$ cycle per instruction due to resource limits, then that stage becomes the throughput bottleneck: the pipeline cannot issue new instructions faster than that stage can accept them, and the steady-state CPI equals the number of cycles per instruction required by the bottleneck stage.\n\nApply these principles to the given scenario. Each triadic instruction requires $3$ register reads in the Instruction Decode and Register Read (ID) stage and $1$ register write in the Write Back (WB) stage. The register file has $R=2$ read ports and $W=1$ write port. The WB stage for a single-issue pipeline with $W=1$ can handle at most $1$ write per cycle, but since there is only one instruction in WB at a time (single issue), WB is not a bottleneck for this instruction mix. The critical resource is the read ports in ID.\n\nIn the ID stage, at most $R=2$ registers can be read per cycle. A triadic instruction requires $3$ reads, which cannot be completed in a single cycle because $3 > R=2$. Therefore, the ID stage must retain the instruction for multiple cycles. Specifically, in the first ID cycle the instruction can read $2$ operands, and in the second ID cycle it can read the remaining $1$ operand. Thus the ID stage occupancy per instruction is\n$$\n\\left\\lceil \\frac{3}{R} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2 \\text{ cycles}.\n$$\nBecause hazard resolution is performed solely by stalling and the pipeline is single issue, the ID stage holding an instruction for $2$ cycles prevents the next instruction from entering ID until those reads complete. This imposes a $1$-cycle stall per instruction relative to the hazard-free case where ID would complete in $1$ cycle.\n\nWe can make this explicit by outlining the schedule for one instruction, denoted $I_1$:\n- Cycle $1$: $I_1$ in IF.\n- Cycle $2$: $I_1$ in ID (reads $2$ registers).\n- Cycle $3$: $I_1$ in ID (reads $1$ register, completing reads).\n- Cycle $4$: $I_1$ in EX.\n- Cycle $5$: $I_1$ in MEM.\n- Cycle $6$: $I_1$ in WB (performs $1$ write, which is within $W=1$).\n\nFor the next instruction $I_2$, the earliest it can enter ID is after cycle $3$, because the ID stage is occupied by $I_1$ in cycles $2$ and $3$. Therefore, even in steady state with a long sequence of such instructions and no other hazards, the ID stage processes instructions at a rate of $1$ instruction per $2$ cycles. Since all other stages are $1$ cycle, the ID stage is the throughput-limiting bottleneck.\n\nConsequently, the steady-state throughput is $0.5$ instructions per cycle, and the steady-state average Cycles Per Instruction is\n$$\n\\mathrm{CPI} = 2.\n$$\nNo rounding is necessary because this is an exact value derived from the integer resource constraints and stage occupancies.", "answer": "$$\\boxed{2}$$", "id": "3682639"}, {"introduction": "In modern processors, distinguishing between different types of hazards is essential for correct and efficient execution. This exercise presents a scenario in a dual-issue processor that is designed to look like a data hazard but is, in fact, a structural hazard involving a shared Address Generation Unit (AGU). This practice will sharpen your ability to diagnose the root cause of a pipeline stall by applying the precise definitions of data and structural hazards, a key skill for debugging performance issues [@problem_id:3682664].", "problem": "Consider an in-order, dual-issue pipeline executing integer and memory instructions. The machine has the following properties:\n\n- The front end can fetch and decode up to $2$ instructions per cycle and attempts to issue them in program order as a pair.\n- There is one Address Generation Unit (AGU) resource. Any load or store requires the AGU for exactly $1$ cycle when performing effective address computation. The AGU cannot be shared within the same cycle, so at most one memory instruction can use the AGU per cycle.\n- The Arithmetic Logic Unit (ALU) executes integer arithmetic/logical instructions, with at most $1$ ALU instruction per cycle. ALU instructions do not use the AGU.\n- Loads and stores have no cache misses; ignore memory latency beyond the fact that loads and stores each require an AGU-use cycle to compute their effective addresses. The issue logic stalls the second instruction of a pair when a structural conflict is detected, allowing the first to proceed.\n- Hazard detection is standard: a data hazard exists only when there is a true dependence on a value (read-after-write). Reading the same register in two consecutive instructions without an intervening write is not a data hazard.\n\nConstruct an instruction sequence that appears to be a data hazard but is actually a structural hazard due to the shared AGU by using the same base register for two consecutive memory operations. Then, for the specific loop body below, explain the distinction and quantify the stalls caused purely by AGU contention.\n\nLoop body (one iteration), written in a register-transfer style:\n\n- Instruction $1$: load $R4 \\leftarrow \\mathrm{Mem}[R1 + $ $0$ $]$.\n- Instruction $2$: store $\\mathrm{Mem}[R1 + $ $8$ $] \\leftarrow R5$.\n- Instruction $3$: integer add $R6 \\leftarrow R6 + R9$.\n- Instruction $4$: integer subtract $R10 \\leftarrow R11 - R12$.\n\nAssume the front end attempts to issue instructions $1$ and $2$ together in the first cycle of the iteration, and thereafter continues in program order attempting to fill both issue slots each cycle, subject to the resource constraints above.\n\nTasks:\n\n1. Using the fundamental definitions of structural and data hazards, justify why the interaction between instructions $1$ and $2$ is a structural hazard rather than a data hazard.\n2. Determine the number of stall cycles incurred per iteration of the loop solely due to the shared AGU.\n3. For $N = $ $100$ iterations of this loop body, compute the total number of stall cycles caused by the AGU contention. Express your final result as a number of stall cycles. No rounding is required.", "solution": "1.  **Justification of Hazard Type**\nA **data hazard** (specifically, a Read-After-Write or RAW hazard) occurs when an instruction needs to read a value that a preceding, not-yet-completed instruction writes. Here, Instruction 1 (`load R4 - Mem[R1 + 0]`) writes to register `R4`. Instruction 2 (`store Mem[R1 + 8] - R5`) reads registers `R1` and `R5`, but not `R4`. Since Instruction 2 does not depend on the result of Instruction 1, there is no data hazard between them.\n\nA **structural hazard** occurs when two instructions require the same hardware resource in the same clock cycle. In this case:\n- Instruction 1 (`load`) requires the Address Generation Unit (AGU) to compute `R1 + 0`.\n- Instruction 2 (`store`) requires the AGU to compute `R1 + 8`.\n\nSince the dual-issue processor attempts to issue both instructions in the same cycle and there is only one AGU, they are in direct contention for this resource. This resource conflict is a structural hazard.\n\n2.  **Stall Cycles per Iteration**\nThe pipeline processes instructions in pairs. Let's trace the execution for one iteration:\n- **Cycle 1:** The processor attempts to issue the pair (Instruction 1, Instruction 2). Both require the single AGU, causing a structural hazard. The policy dictates that Instruction 1 is issued and Instruction 2 is stalled.\n- **Cycle 2:** The processor issues the stalled Instruction 2, which now uses the AGU.\n\nThe pair (Instruction 1, Instruction 2), which would ideally take 1 cycle on a dual-issue machine, takes 2 cycles to issue. This represents $2 - 1 = 1$ stall cycle. This stall is caused solely by the AGU contention. (Note: A similar structural hazard occurs for the pair (Instruction 3, Instruction 4) on the single ALU, but the question specifically asks about AGU contention.)\n\n3.  **Total Stall Cycles**\nThe AGU contention causes 1 stall cycle per iteration. For $N = 100$ iterations, the total number of stall cycles is:\nTotal stalls = (Stall cycles per iteration) $\\times$ (Number of iterations) = $1 \\times 100 = 100$.", "answer": "$$\n\\boxed{100}\n$$", "id": "3682664"}, {"introduction": "As we scale up from a single processor core to a system with many pipelines, contention for shared resources like memory buses becomes a major performance limiter. This final practice moves beyond simple cycle counting and introduces a powerful analytical tool from queueing theory to model such scenarios. By treating the shared bus as a server and writeback requests as customers, you will calculate key performance metrics like contention probability and expected stall time, gaining insight into how architects analyze and predict the behavior of complex systems [@problem_id:3682652].", "problem": "A shared $64$-bit writeback data bus is used by $M$ identical pipelines. Each pipeline may generate a writeback request when it completes a store or a dirty eviction. In each cycle, each pipeline independently produces a writeback request with probability $\\alpha$, and requests are enqueued to a single bus arbiter that serves them in First-Come, First-Served (FCFS) order. The bus can transfer $B$ aligned $64$-bit words per cycle, and each writeback transfers on average $s$ aligned $64$-bit words. If the bus is busy when a writeback request arrives, the originating pipelineâ€™s writeback stage stalls until service begins.\n\nAssume the following parameters: $M = 16$, $\\alpha = 0.01$, $B = 2$ (words per cycle), and $s = 8$ (words per writeback). Treat the aggregate arrival process across pipelines as sufficiently sparse to be approximated by a Poisson process per cycle, and treat the service time per writeback as deterministic at its mean. Starting from foundational definitions of structural hazards as shared-resource conflicts and using well-tested queueing results applicable to memory and interconnect arbitration in computer systems, derive the contention probability that a newly arriving writeback request finds the bus busy and the expected stall time (in cycles) experienced by a writeback request before it begins service.\n\nProvide your final numerical answers for the contention probability as a dimensionless decimal and for stall time in cycles. Round both quantities to four significant figures. Express the stall time in cycles.", "solution": "This scenario of multiple pipelines contending for a shared bus can be modeled using queueing theory. The problem specifies that the aggregate arrival process can be approximated as a Poisson process and the service time is deterministic. This corresponds to a standard **M/D/1 queue** (Markovian arrivals, Deterministic service time, 1 server), a common model for analyzing such structural hazards in computer systems.\n\n**1. Define Queueing Parameters**\n\n*   **Arrival Rate ($\\lambda$)**: With $M=16$ pipelines each generating a request with probability $\\alpha=0.01$ per cycle, the total mean arrival rate to the bus arbiter is:\n    $$ \\lambda = M \\times \\alpha = 16 \\times 0.01 = 0.16 \\text{ requests/cycle} $$\n*   **Service Time ($T_s$)**: Each request is for $s=8$ words, and the bus has a bandwidth of $B=2$ words/cycle. The deterministic time to service one request is:\n    $$ T_s = \\frac{s}{B} = \\frac{8 \\text{ words}}{2 \\text{ words/cycle}} = 4 \\text{ cycles/request} $$\n*   **Server Utilization ($\\rho$)**: This represents the fraction of time the bus is busy and is calculated as the product of the arrival rate and the service time.\n    $$ \\rho = \\lambda \\times T_s = 0.16 \\text{ requests/cycle} \\times 4 \\text{ cycles/request} = 0.64 $$\n    Since $\\rho  1$, the system is stable.\n\n**2. Calculate Contention Probability and Stall Time**\n\n*   **Contention Probability**: This is the probability that a new request arrives to find the bus busy. For a queue with Poisson arrivals (due to the PASTA property), this probability is equal to the server's steady-state utilization, $\\rho$.\n    $$ P(\\text{bus busy}) = \\rho = 0.64 $$\n*   **Expected Stall Time ($E[T_q]$)**: This is the average time a request waits in the queue before its service begins. For an M/D/1 queue, the expected waiting time is given by the Pollaczek-Khinchine formula simplified for deterministic service times:\n    $$ E[T_q] = \\frac{\\lambda T_s^2}{2(1-\\rho)} $$\n    Plugging in our values:\n    $$ E[T_q] = \\frac{0.16 \\times 4^2}{2(1 - 0.64)} = \\frac{0.16 \\times 16}{2 \\times 0.36} = \\frac{2.56}{0.72} = \\frac{32}{9} \\approx 3.555... \\text{ cycles} $$\n\n**3. Final Results**\nRounding the results to four significant figures as requested:\n*   Contention Probability: $0.6400$\n*   Expected Stall Time: $3.556$ cycles", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.6400  3.556\n\\end{pmatrix}\n}\n$$", "id": "3682652"}]}