{"hands_on_practices": [{"introduction": "Moving from the theoretical elegance of parallel-prefix graphs to practical implementation reveals a critical trade-off: speed versus area. The Kogge-Stone adder is famous for its minimal logic depth, but this performance comes at the cost of a high gate count and complex wiring. This practice [@problem_id:3619315] provides a concrete, hands-on method for quantifying this cost by guiding you through a transistor-level analysis of both the Kogge-Stone and Brent-Kung architectures. By calculating the total number of transistors required for each, you will gain a tangible understanding of the hardware resources associated with these advanced designs.", "problem": "A parallel-prefix adder computes carries by combining bit-level generate and propagate signals with the associative prefix operator. Consider a radix-$2$ Kogge–Stone and a Brent–Kung adder, each of size $n=32$, implemented in static Complementary Metal–Oxide–Semiconductor (CMOS) using only the following primitive gates and transistor models:\n\n- Inverter: $2$ transistors.\n- $2$-input NAND: $4$ transistors.\n- $2$-input NOR: $4$ transistors.\n- $2$-input AND is realized as a NAND followed by an inverter: $6$ transistors.\n- $2$-input OR is realized as a NOR followed by an inverter: $6$ transistors.\n- $2$-input exclusive-OR (XOR) is realized in fully static CMOS: $12$ transistors.\n\nAssume no other complex gates are available, no transmission gates are used, and there is no additional buffering or wire cost. Let the bit-level generate and propagate be defined as $g_i = a_i b_i$ and $p_i = a_i \\oplus b_i$, with the group operator on pairs $(g,p)$ defined by\n$$\n(g_k, p_k) \\circ (g_j, p_j) = \\big(g_k \\lor (p_k \\land g_j),\\; p_k \\land p_j\\big),\n$$\nwhere $\\lor$ and $\\land$ denote Boolean OR and AND, respectively. A black cell implements the full operator $\\circ$ (outputs both group generate and group propagate), while a gray cell outputs only the group generate $g_k \\lor (p_k \\land g_j)$.\n\nFor each adder:\n- Pre-processing: form all $p_i$ and $g_i$ for $i \\in \\{0,\\dots,31\\}$ using one XOR and one AND per bit.\n- Prefix network: use the standard radix-$2$ topology for each architecture. In Kogge–Stone, use black cells in all but the last stage and gray cells in the last stage. In Brent–Kung, use a reduction tree of black cells followed by an expansion tree of gray cells.\n- Post-processing: form all sums $s_i = p_i \\oplus c_i$ for $i \\in \\{0,\\dots,31\\}$ with one XOR per bit, where $c_i$ are the carries provided by the prefix network (the carry-in $c_0$ is incorporated within the prefix network in the standard way).\n\nStarting from the above definitions and the transistor models, derive:\n$1.$ The transistor count of a black cell and of a gray cell under the stated gate library.\n$2.$ The total transistor count of the $n=32$ Kogge–Stone adder.\n$3.$ The total transistor count of the $n=32$ Brent–Kung adder.\n\nFinally, compute the ratio of the total transistor count of Kogge–Stone to Brent–Kung for $n=32$. Round your answer to $4$ significant figures. The final answer must be this single rounded ratio value (unitless).", "solution": "The problem requires a detailed analysis of the transistor counts for two types of $32$-bit parallel-prefix adders, Kogge-Stone (KS) and Brent-Kung (BK), based on a specific set of primitive CMOS gates and their transistor costs. The final objective is to compute the ratio of the total transistor count of the Kogge-Stone adder to that of the Brent-Kung adder.\n\nFirst, we determine the transistor count for the two types of cells used in the prefix networks: black cells and gray cells. The transistor costs for the primitive gates are given as:\n- Inverter: $2$ transistors\n- $2$-input NAND: $4$ transistors\n- $2$-input NOR: $4$ transistors\n- $2$-input AND (NAND + Inverter): $4+2=6$ transistors\n- $2$-input OR (NOR + Inverter): $4+2=6$ transistors\n- $2$-input XOR: $12$ transistors\n\nThe group operator on $(g, p)$ pairs is defined as $(g_k, p_k) \\circ (g_j, p_j) = \\big(g_k \\lor (p_k \\land g_j),\\; p_k \\land p_j\\big)$.\n\n1.  **Transistor Count of a Gray Cell**\nA gray cell implements only the group generate part of the operator: $G = g_k \\lor (p_k \\land g_j)$. This expression requires one $2$-input AND operation ($p_k \\land g_j$) and one $2$-input OR operation. Using the provided gate library:\n- Cost of $2$-input AND: $6$ transistors\n- Cost of $2$-input OR: $6$ transistors\nThe total transistor count for a gray cell is the sum of these costs:\n$$\n\\text{Cost}_{\\text{gray}} = \\text{Cost}(AND_2) + \\text{Cost}(OR_2) = 6 + 6 = 12 \\text{ transistors}.\n$$\n\n2.  **Transistor Count of a Black Cell**\nA black cell implements the full group operator, producing both the group generate and group propagate signals: $G = g_k \\lor (p_k \\land g_j)$ and $P = p_k \\land p_j$. This requires the same logic as the gray cell, plus an additional $2$-input AND gate for the group propagate term.\n- Logic for $G$: one $2$-input AND and one $2$-input OR.\n- Logic for $P$: one $2$-input AND.\nThe total transistor count for a black cell is:\n$$\n\\text{Cost}_{\\text{black}} = \\text{Cost}(AND_2) + \\text{Cost}(OR_2) + \\text{Cost}(AND_2) = 6 + 6 + 6 = 18 \\text{ transistors}.\n$$\n\nNext, we analyze the total transistor count for each adder architecture. Both adders consist of three stages: pre-processing, the prefix network, and post-processing. The adder size is $n=32$.\n\n**Common Stages: Pre-processing and Post-processing**\n- **Pre-processing**: For each bit $i \\in \\{0, \\dots, 31\\}$, the signals $g_i = a_i b_i$ and $p_i = a_i \\oplus b_i$ are generated. This requires one $2$-input AND gate and one $2$-input XOR gate per bit.\n    - Cost per bit: $\\text{Cost}(AND_2) + \\text{Cost}(XOR_2) = 6 + 12 = 18$ transistors.\n    - Total pre-processing cost: $T_{PP} = 32 \\times 18 = 576$ transistors.\n- **Post-processing**: For each bit $i \\in \\{0, \\dots, 31\\}$, the sum $s_i = p_i \\oplus c_i$ is computed. The problem specifies one $2$-input XOR gate per bit for all $32$ bits.\n    - Cost per bit: $\\text{Cost}(XOR_2) = 12$ transistors.\n    - Total post-processing cost: $T_{Sum} = 32 \\times 12 = 384$ transistors.\nThe combined cost of these two stages for both adders is $T_{PP} + T_{Sum} = 576 + 384 = 960$ transistors.\n\n**Total Transistor Count for the $n=32$ Kogge-Stone Adder**\nThe Kogge-Stone prefix network for $n=32$ has a depth of $\\log_2(n) = \\log_2(32) = 5$ stages, indexed $k=0, \\dots, 4$. In a standard radix-$2$ KS topology, stage $k$ contains $n - 2^k$ operator cells. The problem states that the last stage ($k=4$) uses gray cells, and all preceding stages ($k=0, 1, 2, 3$) use black cells.\n- Number of black cells:\n    - Stage $k=0$: $32 - 2^0 = 31$ cells\n    - Stage $k=1$: $32 - 2^1 = 30$ cells\n    - Stage $k=2$: $32 - 2^2 = 28$ cells\n    - Stage $k=3$: $32 - 2^3 = 24$ cells\n    - Total black cells = $31 + 30 + 28 + 24 = 113$.\n- Number of gray cells:\n    - Stage $k=4$: $32 - 2^4 = 16$ cells.\nThe cost of the KS prefix network is:\n$$\nT_{\\text{Network, KS}} = (113 \\times \\text{Cost}_{\\text{black}}) + (16 \\times \\text{Cost}_{\\text{gray}}) = (113 \\times 18) + (16 \\times 12) = 2034 + 192 = 2226 \\text{ transistors}.\n$$\nThe total transistor count for the Kogge-Stone adder is the sum of all three stages:\n$$\nT_{\\text{KS}} = T_{PP} + T_{Sum} + T_{\\text{Network, KS}} = 960 + 2226 = 3186 \\text{ transistors}.\n$$\n\n**Total Transistor Count for the $n=32$ Brent-Kung Adder**\nThe Brent-Kung prefix network consists of a reduction tree followed by an expansion tree. For $n$ bits, the total number of cells in a BK network is $2n - 2 - \\log_2(n)$. For $n=32$, this is $2(32) - 2 - \\log_2(32) = 64 - 2 - 5 = 57$ cells.\n- **Reduction Tree**: The reduction tree consists of $n-1 = 32-1=31$ cells. As per the problem, these are black cells.\n- **Expansion Tree**: The expansion tree consists of the remaining cells: $57 - 31 = 26$ cells. These are specified as gray cells. (This count also matches the formula $n - 1 - \\log_2(n) = 32 - 1 - 5 = 26$).\nThe cost of the BK prefix network is:\n$$\nT_{\\text{Network, BK}} = (31 \\times \\text{Cost}_{\\text{black}}) + (26 \\times \\text{Cost}_{\\text{gray}}) = (31 \\times 18) + (26 \\times 12) = 558 + 312 = 870 \\text{ transistors}.\n$$\nThe total transistor count for the Brent-Kung adder is the sum of all three stages:\n$$\nT_{\\text{BK}} = T_{PP} + T_{Sum} + T_{\\text{Network, BK}} = 960 + 870 = 1830 \\text{ transistors}.\n$$\n\n**Final Ratio**\nFinally, we compute the ratio of the total transistor count of the Kogge-Stone adder to that of the Brent-Kung adder.\n$$\n\\text{Ratio} = \\frac{T_{\\text{KS}}}{T_{\\text{BK}}} = \\frac{3186}{1830} \\approx 1.7409836...\n$$\nRounding this value to $4$ significant figures, we get $1.741$.", "answer": "$$\\boxed{1.741}$$", "id": "3619315"}, {"introduction": "Beyond the simple trade-off between gate count and logic depth, practical circuit design involves other crucial performance limiters. The Sklansky, or divide-and-conquer, adder topology is known for achieving logarithmic delay with fewer prefix operators than a Kogge-Stone design, but it introduces a severe fanout problem on certain nodes. This exercise [@problem_id:3619383] challenges you to analyze these second-order effects by calculating the critical path delay and identifying the maximum fanout in a Sklansky adder, and then proposing a real-world buffering strategy to manage it.", "problem": "A $32$-bit parallel-prefix adder using the Sklansky (divide-and-conquer) topology is built from $2$-input logic gates. The adder is specified using the standard generate and propagate definitions for each bit position $i$:\n- Bitwise generate $g_i = a_i b_i$,\n- Bitwise propagate $p_i = a_i \\oplus b_i$,\nand the group generate and propagate for a contiguous range of bit positions $[i:j]$ defined recursively by\n$$\nG_{i:j} = G_i \\lor \\left(P_i G_{i-1:j}\\right), \\quad P_{i:j} = P_i P_{i-1:j}.\n$$\nAssume the least significant bit (LSB) is at index $i=0$, the most significant bit (MSB) is at index $i=31$, and there is no incoming carry, so $c_0 = 0$ and $c_{32} = G_{31:0}$. The Sklansky topology computes these group signals by forming successively larger groups whose size doubles at each prefix stage, until the full-width group is formed.\n\nImplementation constraints and the logic depth model:\n- Each bitwise generate $g_i$ is computed by a single $2$-input logical AND gate level.\n- Each prefix operator instance that produces a new pair $\\left(G_{i:j}, P_{i:j}\\right)$ from two previously available pairs is implemented using exactly one level of $2$-input logical AND gates (to form $P_i P_{i-1:j}$ and $P_i G_{i-1:j}$) followed by one level of $2$-input logical OR gates (to form $G_i \\lor \\left(P_i G_{i-1:j}\\right)$); that is, two gate levels per prefix operator instance.\n- Exclusive-OR gates used to form $p_i$ do not lie on the carry path to $c_{32}$ and are not counted toward the carry logic depth.\n\nTasks:\n1. Starting only from these definitions and constraints, derive the number of $2$-input gate logic levels on the critical carry path from the inputs $\\left(a_0, b_0\\right)$ to the final carry $c_{32}$ in this Sklansky adder.\n2. Identify which group node in the prefix structure experiences the maximum electrical fanout and determine its fanout value under Sklansky's broadcast pattern.\n3. Suppose a physical design rule caps the maximum allowed fanout to $f = 4$ loads for any single driver. Propose a buffering strategy that respects this cap for the maximum-fanout node you identified, and compute the minimal number of buffer cells required at that node to distribute its signal to all of its destinations without violating the fanout cap. You may assume ideal buffers that only provide drive strength and add no logical transformation.\n\nAnswer specification:\n- Report only the logic level count $L$ from Task $1$ as your final numeric answer.\n- No rounding is required.\n- Do not include any units in your reported value.", "solution": "The solution is presented by addressing the three tasks in order.\n\n### Task 1: Logic Level Count on the Critical Carry Path\n\nThe critical path for the carry logic determines the overall speed of the adder. This path begins with the inputs $a_i, b_i$ and terminates at the final carry-out bit $c_{32}$. The adder has a width of $N=32$ bits.\n\n1.  **Initial Signal Generation**: The process starts with the computation of bitwise generate ($g_i$) and propagate ($p_i$) signals for each bit position $i$.\n    -   $g_i = a_i b_i$\n    -   $p_i = a_i \\oplus b_i$\n    The problem specifies that each $g_i$ is computed by a single $2$-input AND gate level. The inputs to the entire prefix network are the pairs $(G_{i:i}, P_{i:i}) = (g_i, p_i)$. The critical path for carry generation depends on the arrival time of these signals. The $g_i$ signals are available after $1$ gate logic level. The problem states that the XOR gates for $p_i$ are not on the carry path, so we consider the inputs to the prefix network to be available after the initial $1$-level delay required for the $g_i$ signals.\n\n2.  **Prefix Network Logic Depth**: The Sklansky parallel-prefix adder computes all carry-in signals $c_i = G_{i-1:0}$ in parallel. The final carry-out is $c_{32} = G_{31:0}$. The computation of the most significant prefix, $G_{31:0}$, determines the critical path depth of the prefix network.\n\n    In any parallel-prefix scheme that achieves logarithmic depth (such as Sklansky or Kogge-Stone), the computation of the full-width group generate/propagate, $(G_{N-1:0}, P_{N-1:0})$, follows a binary-tree dependency structure. The computation of $(G_{31:0}, P_{31:0})$ is performed by a prefix operator combining two half-width groups:\n    $$ (G_{31:0}, P_{31:0}) = (G_{31:16}, P_{31:16}) \\bullet (G_{15:0}, P_{15:0}) $$\n    where $\\bullet$ denotes the prefix operator. In turn, $(G_{15:0}, P_{15:0})$ is computed from $(G_{15:8}, P_{15:8})$ and $(G_{7:0}, P_{7:0})$, and so on. This creates a dependency chain for the most significant prefix that has a depth of $\\log_2(N)$ prefix operators.\n\n    For $N=32$, the number of prefix operator stages on this critical path is:\n    $$ \\text{Number of prefix stages} = \\log_2(32) = 5 $$\n    The problem states that each prefix operator instance requires $2$ levels of logic ($1$ for AND, $1$ for OR).\n    Therefore, the logic depth of the prefix network itself is:\n    $$ L_{\\text{prefix}} = (\\text{Number of prefix stages}) \\times (\\text{Levels per stage}) = 5 \\times 2 = 10 \\text{ levels} $$\n\n3.  **Total Critical Path Logic Level Count ($L$)**: The total logic level count on the critical carry path is the sum of the initial generate signal delay and the prefix network delay.\n    $$ L = L_{\\text{initial gen}} + L_{\\text{prefix}} = 1 + 10 = 11 $$\n    The critical path from inputs $(a_i, b_i)$ to output $c_{32}$ consists of $11$ levels of $2$-input logic gates.\n\n### Task 2: Maximum Fanout Identification\n\nThe Sklansky topology is known for minimizing the number of logic cells compared to other logarithmic-depth adders like Kogge-Stone, but at the cost of high electrical fanout on certain nodes. Fanout is the number of gate inputs a single gate output drives.\n\nIn a Sklansky adder, prefix blocks of size $2^k$ are computed and then \"broadcast\" to be combined with smaller groups to form all prefixes up to size $2^{k+1}-1$. The node that computes the generate/propagate signals for the entire lower half of the adder, $(G_{N/2-1:0}, P_{N/2-1:0})$, experiences the maximum fanout.\n\nFor $N=32$, the maximum fanout occurs at the node producing the signals for the lower $16$ bits, which is $(G_{15:0}, P_{15:0})$. These signals are required for the final prefix computation stage of every bit in the upper half of the adder, i.e., for bits $i = 16, 17, \\dots, 31$. For each such bit $i$, the prefix $G_{i:0}$ is formed by an operator that takes $(G_{15:0}, P_{15:0})$ as one of its inputs.\n\nThe number of destinations (loads) is the number of bits in the upper half:\n$$ \\text{Fanout}_{\\text{max}} = (31 - 16) + 1 = 16 $$\nThus, the node producing $(G_{15:0}, P_{15:0})$ has a maximum fanout of $16$.\n\n### Task 3: Buffering Strategy\n\nA physical design rule caps the maximum allowed fanout to $f=4$. The node identified in Task 2 has a fanout of $16$, which violates this rule. A buffer tree must be inserted to distribute the signal while respecting the fanout constraint. We need to buffer both the $G_{15:0}$ and $P_{15:0}$ signals. Let's analyze the buffering for one signal, say $G_{15:0}$.\n\nWe have $1$ source and must drive $16$ loads, with each driver (the source gate or a buffer) being able to drive at most $f=4$ loads. We seek the minimal number of buffers. To achieve this, we should maximize the fanout at each level of the buffer tree.\n\nThe number of drivers required at the final level of the buffer tree (the one driving the actual loads) is:\n$$ n_{\\text{final-level}} = \\left\\lceil \\frac{\\text{Number of loads}}{f} \\right\\rceil = \\left\\lceil \\frac{16}{4} \\right\\rceil = 4 $$\nSo, we need $4$ buffers at the last level. Each of these buffers will drive $16/4 = 4$ loads, which respects the fanout constraint $f=4$.\n\nNow, these $4$ buffers must themselves be driven. The number of drivers required for this is:\n$$ n_{\\text{prev-level}} = \\left\\lceil \\frac{n_{\\text{final-level}}}{f} \\right\\rceil = \\left\\lceil \\frac{4}{4} \\right\\rceil = 1 $$\nThis single required driver can be the original source gate that produces the $G_{15:0}$ signal. Its fanout would be $4$ (to drive the four buffers), which is within the allowed cap.\n\nThis structure consists of a single level of buffering. The minimal number of buffers required for the $G_{15:0}$ signal is $4$. The signal path is:\nSource gate $\\rightarrow$ $4$ buffers $\\rightarrow$ $16$ loads.\n\nThe same buffering strategy is required for the $P_{15:0}$ signal. Therefore, the total number of buffer cells required at the node\n$(G_{15:0}, P_{15:0})$ is $4$ for the $G$ signal and $4$ for the $P$ signal, for a total of $8$ buffer cells.", "answer": "$$\n\\boxed{11}\n$$", "id": "3619383"}, {"introduction": "Why do we invest so much complexity in advanced adder designs? The answer lies in overcoming the worst-case carry propagation delay that cripples simple ripple-carry adders. This practice [@problem_id:3686546] is a conceptual exercise that gets to the heart of this issue by analyzing an adder's behavior under the specific input condition of adding a number to its own two's complement, an operation that generates a full-length carry chain. By examining the resulting propagate and generate signals, you will understand precisely how this scenario exercises the worst-case delay paths in both carry-lookahead and carry-skip adders, solidifying your intuition for carry logic.", "problem": "An $n$-bit two's complement arithmetic unit implements subtraction by feeding operand $a$ directly into one input of a binary adder, bitwise inverting operand $b$ into the other input, and seeding the adder's initial carry-in with $c_0 = 1$. Thus, to compute $x + (-x)$, the unit presents $a = x$, $b = \\overline{x}$, and $c_0 = 1$ to the adder. Consider two different adder organizations used inside the unit: a carry-lookahead adder (CLA) and a carry-skip adder (CSK), both designed in the standard way using per-bit propagate and generate definitions as their core interface to carry logic. Using only fundamental definitions of two's complement representation and propagate/generate carry logic, determine which statements about the worst-case carry behavior when computing $x + (-x)$ are correct.\n\nA. In this implementation, when adding $x + (-x)$ with $a = x$, $b = \\overline{x}$, and $c_0 = 1$, the per-bit propagate and generate satisfy $P_i = 1$ and $G_i = 0$ for all bit positions $i$. Therefore, a CLA produces the final carry-out entirely through its group-propagate chain, which realizes its worst-case logical depth.\n\nB. In a CSK partitioned into equal-sized blocks, when computing $x + (-x)$ under the same interface, every block's skip condition is asserted, so the critical path traverses all skip elements across blocks; this exercises the CSK's worst-case skip path even though no block produces a generate.\n\nC. The worst-case carry chain for $x + (-x)$ occurs only when $x$ has an alternating bit pattern such as $0101\\ldots$, because only then are propagates aligned; for other $x$, some bit kills the carry and shortens the chain.\n\nD. Because the arithmetic result of $x + (-x)$ is $0$, the carry cannot traverse beyond the least significant bit; hence neither CLA nor CSK encounters its worst-case path in this operation.\n\nE. If $x$ has exactly $t$ trailing zeros (with $0 \\le t \\le n-1$), the carry ripples through exactly $t+1$ bits and then stops; therefore, a CLA avoids its worst case unless $t = n-1$.\n\nSelect all correct statements.", "solution": "**Derivation of Carry Logic Behavior**\n\nWe analyze the behavior of the per-bit propagate ($P_i$) and generate ($G_i$) signals for the given operation. The inputs to the $i$-th full adder are $a_i = x_i$ and $b_i = \\overline{x_i}$. The standard definitions for propagate and generate signals are:\n- Generate: $G_i = a_i \\cdot b_i$\n- Propagate: $P_i = a_i \\oplus b_i$\n\nLet us compute these values for the given inputs:\n- For the generate signal $G_i$:\n$$G_i = a_i \\cdot b_i = x_i \\cdot \\overline{x_i} = 0$$\nThis is true for all bit positions $i \\in \\{0, 1, \\ldots, n-1\\}$, as a bit cannot be both $1$ and $0$ simultaneously.\n\n- For the propagate signal $P_i$:\n$$P_i = a_i \\oplus b_i = x_i \\oplus \\overline{x_i} = 1$$\nThis is true for all bit positions $i$, as a bit is always different from its complement.\n\nTherefore, for the operation $x + (-x)$ implemented as $x + \\overline{x} + 1$, every bit position $i$ intrinsically generates no carry ($G_i=0$) and propagates any incoming carry ($P_i=1$).\n\nThe carry-out from each bit stage, $c_{i+1}$, is defined by the recurrence relation:\n$$c_{i+1} = G_i + P_i \\cdot c_i$$\nSubstituting our derived values for $G_i$ and $P_i$:\n$$c_{i+1} = 0 + 1 \\cdot c_i = c_i$$\nThe problem states the initial carry-in is $c_0=1$. Using the recurrence, we find:\n- $c_1 = c_0 = 1$\n- $c_2 = c_1 = 1$\n- ...\n- $c_n = c_{n-1} = \\ldots = c_1 = c_0 = 1$\n\nThis demonstrates that the initial carry-in $c_0=1$ is propagated through every single bit stage of the adder, from bit $0$ to bit $n-1$. A carry chain spanning the entire width of the adder is the definition of the worst-case carry propagation scenario for ripple-carry adders and is the condition that fast adders like CLA and CSK are designed to accelerate.\n\nThe sum bits $S_i$ are calculated as $S_i = a_i \\oplus b_i \\oplus c_i = P_i \\oplus c_i$.\nSince $P_i=1$ and we have just shown $c_i=1$ for all $i \\in \\{0, 1, \\ldots, n-1\\}$, the sum bits are:\n$$S_i = 1 \\oplus 1 = 0$$\nThe result of the sum is an $n$-bit vector of all zeros, which correctly represents the value $0$. The final carry-out $c_n=1$ is discarded in two's complement arithmetic.\n\n**Evaluation of Options**\n\n**A. In this implementation, when adding $x + (-x)$ with $a = x$, $b = \\overline{x}$, and $c_0 = 1$, the per-bit propagate and generate satisfy $P_i = 1$ and $G_i = 0$ for all bit positions $i$. Therefore, a CLA produces the final carry-out entirely through its group-propagate chain, which realizes its worst-case logical depth.**\n\nOur derivation confirms that $P_i = 1$ and $G_i = 0$ for all $i$. In a CLA, the carry-out of the adder, $c_n$, is computed by a lookahead logic unit. In general, $c_n$ is a sum-of-products expression where each term corresponds to a position where a carry could be generated and then propagated to the end. The most general form can be expressed using group-propagate ($P^*$) and group-generate ($G^*$) signals. The carry out of a block spanning bits $i$ to $j$ is $c_{j+1} = G^*_{i,j} + P^*_{i,j} \\cdot c_i$.\nSince all $G_i=0$, any group generate $G^*_{i,j}$ will also be $0$. Since all $P_i=1$, any group propagate $P^*_{i,j} = \\prod_{k=i}^j P_k$ will be $1$.\nThe final carry $c_n$ then depends solely on the total group-propagate term for the entire adder, $P^*_{0,n-1}$, and the initial carry-in $c_0$:\n$$c_n = G^*_{0,n-1} + P^*_{0,n-1} \\cdot c_0 = 0 + 1 \\cdot c_0 = c_0$$\nThe evaluation of the term $P^*_{0,n-1} \\cdot c_0$ requires the logic to check if all bits from $0$ to $n-1$ are propagating. This path through the lookahead unit, often called the group-propagate chain, is the longest and determines the worst-case delay of the CLA. Thus, this operation forces the CLA into its worst-case performance scenario. The statement is correct.\n\nVerdict: **Correct**.\n\n**B. In a CSK partitioned into equal-sized blocks, when computing $x + (-x)$ under the same interface, every block's skip condition is asserted, so the critical path traverses all skip elements across blocks; this exercises the CSK's worst-case skip path even though no block produces a generate.**\n\nA carry-skip adder (CSK) uses a block-propagate signal, $P_{block}$, as the \"skip\" condition. For a block spanning bits $i$ to $j$, this signal is $P_{block} = \\prod_{k=i}^j P_k$. As we derived, $P_k=1$ for all $k$. Consequently, for any block in the adder, $P_{block}=1$. This means the skip condition for every single block is asserted.\nThe worst-case path in a CSK is typically when a carry is introduced at the beginning of the first block, must ripple to establish the skip condition for that block, then travels through the skip logic of all intermediate blocks, and finally ripples through the last block. With $c_0=1$ and all skip conditions pre-asserted due to $P_i=1$, the carry signal propagates from the input of the first block, across the skip chain of all blocks in sequence, to the final stage. This path, which traverses the entire series of skip multiplexers, is the critical path that determines the worst-case delay of the CSK. The clause that no block produces a generate is also true, as all $G_i=0$. The statement is correct.\n\nVerdict: **Correct**.\n\n**C. The worst-case carry chain for $x + (-x)$ occurs only when $x$ has an alternating bit pattern such as $0101\\ldots$, because only then are propagates aligned; for other $x$, some bit kills the carry and shortens the chain.**\n\nThis statement is false. Our analysis shows that the condition for maximum carry propagation, $P_i=1$ and $G_i=0$, is achieved for *any* value of the operand $x$. This is because the inputs to the $i$-th adder stage are $x_i$ and $\\overline{x_i}$, and $x_i \\oplus \\overline{x_i}$ is always $1$ regardless of whether $x_i$ is $0$ or $1$. The bit-pattern of $x$ is irrelevant to the state of the propagate signals. A carry \"kill\" condition ($G_i=0$ and $P_i=0$) never occurs in this operation. Thus, the carry chain is always maximal and does not depend on the pattern of $x$.\n\nVerdict: **Incorrect**.\n\n**D. Because the arithmetic result of $x + (-x)$ is $0$, the carry cannot traverse beyond the least significant bit; hence neither CLA nor CSK encounters its worst-case path in this operation.**\n\nThis statement presents a fallacious argument. While the arithmetic result is indeed $0$, this outcome is a direct consequence of the full-length carry propagation. As shown in the initial derivation, the sum bit $S_i = P_i \\oplus c_i$. Our analysis proved that $P_i=1$ and $c_i=1$ for all $i \\ge 0$. The sum bit $S_i$ becomes $0$ precisely because the propagated carry $c_i=1$ cancels the partial sum $P_i = a_i \\oplus b_i = 1$. The carry must propagate through the entire adder for the result to be $0$. The statement's premise is flawed and its conclusion is the opposite of the truth; this operation specifically triggers the worst-case path for both CLA and CSK adders.\n\nVerdict: **Incorrect**.\n\n**E. If $x$ has exactly $t$ trailing zeros (with $0 \\le t \\le n-1$), the carry ripples through exactly $t+1$ bits and then stops; therefore, a CLA avoids its worst case unless $t = n-1$.**\n\nThis statement is incorrect. It confuses the behavior of the operation $x + (-x)$ with that of other operations, such as increment ($x+1$) or decrement ($x-1$). For the operation $x+(-x)$ as implemented, we have established that the carry propagation chain extends across all $n$ bits for *any* operand $x$, irrespective of its bit pattern, including the number of trailing zeros. The carry does not stop after $t+1$ bits; it propagates completely. The logic described in the statement applies to different arithmetic contexts, not the one specified in the problem.\n\nVerdict: **Incorrect**.", "answer": "$$\\boxed{\\text{AB}}$$", "id": "3686546"}]}