{"hands_on_practices": [{"introduction": "Understanding processor performance begins with the fundamental concept of Cycles Per Instruction (CPI). Since different types of instructions (like arithmetic, memory access, and branching) require varying numbers of clock cycles to complete, the average CPI is a weighted average based on the program's specific instruction mix. This first practice exercise [@problem_id:3631197] walks you through this essential calculation, connecting the instruction mix, CPI, and clock frequency to determine the total execution time.", "problem": "A simple in-order microarchitecture executes three instruction classes: arithmetic and logic unit operations (ALU), load/store memory operations (LDST), and control-flow branch operations (BR). Over a long program run, the observed instruction mix fractions are $(\\alpha_{ALU}, \\alpha_{LDST}, \\alpha_{BR}) = (0.5, 0.3, 0.2)$. The per-class cycles per instruction values are $1$ for ALU, $3$ for LDST, and $5$ for BR. The Central Processing Unit (CPU) clock frequency is $f = 2.5$ GHz, and the program’s Instruction Count (IC) is $5 \\times 10^{8}$ instructions.\n\nUsing first principles that relate long-run averages to probability-weighted expectations and that relate cycle rate to time, determine the average Cycles Per Instruction (CPI) for the program and the total execution time $T$ for the program. Express the average CPI as a pure number and the execution time in seconds. Provide exact values (no rounding).", "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of computer architecture, well-posed with all necessary information provided, and objective in its formulation. The provided data are self-consistent and realistic.\n\nThe core task is to determine two key performance metrics for a Central Processing Unit (CPU): the average Cycles Per Instruction ($CPI_{\\text{avg}}$) and the total program execution time ($T$). The solution is derived from first principles.\n\nFirst, we calculate the average Cycles Per Instruction for the program. The average $CPI$ is a weighted average of the $CPI$ values for each instruction class, where the weights are the respective instruction mix fractions. The general formula is:\n$$\nCPI_{\\text{avg}} = \\sum_{i} \\alpha_i \\cdot CPI_i\n$$\nwhere $\\alpha_i$ is the fraction of instructions of class $i$, and $CPI_i$ is the cycles per instruction for that class.\n\nThe problem provides the following data:\nInstruction mix fractions: $(\\alpha_{\\text{ALU}}, \\alpha_{\\text{LDST}}, \\alpha_{\\text{BR}}) = (0.5, 0.3, 0.2)$.\nCycles per instruction for each class: $CPI_{\\text{ALU}} = 1$, $CPI_{\\text{LDST}} = 3$, and $CPI_{\\text{BR}} = 5$.\n\nSubstituting these values into the formula for the weighted average:\n$$\nCPI_{\\text{avg}} = (\\alpha_{\\text{ALU}} \\cdot CPI_{\\text{ALU}}) + (\\alpha_{\\text{LDST}} \\cdot CPI_{\\text{LDST}}) + (\\alpha_{\\text{BR}} \\cdot CPI_{\\text{BR}})\n$$\n$$\nCPI_{\\text{avg}} = (0.5 \\cdot 1) + (0.3 \\cdot 3) + (0.2 \\cdot 5)\n$$\nPerforming the multiplication for each term:\n$$\nCPI_{\\text{avg}} = 0.5 + 0.9 + 1.0\n$$\nSumming the terms gives the average $CPI$:\n$$\nCPI_{\\text{avg}} = 2.4\n$$\nThis value represents the average number of clock cycles required to execute one instruction for this specific program and hardware. Note that the sum of the fractions is $\\alpha_{\\text{ALU}} + \\alpha_{\\text{LDST}} + \\alpha_{\\text{BR}} = 0.5 + 0.3 + 0.2 = 1.0$, which is a necessary condition for a complete instruction mix.\n\nSecond, we calculate the total execution time, $T$. The execution time is determined by the total number of cycles required to execute the program, divided by the clock frequency. The total number of cycles is the product of the total number of instructions (Instruction Count, $IC$) and the average cycles per instruction ($CPI_{\\text{avg}}$). The fundamental CPU performance equation is:\n$$\nT = \\frac{\\text{Total Cycles}}{\\text{Clock Frequency}} = \\frac{IC \\cdot CPI_{\\text{avg}}}{f}\n$$\nThe problem provides the following additional data:\nInstruction Count: $IC = 5 \\times 10^8$ instructions.\nCPU clock frequency: $f = 2.5 \\text{ GHz} = 2.5 \\times 10^9 \\text{ cycles per second (Hz)}$.\n\nWe substitute the known values into the performance equation:\n$$\nT = \\frac{(5 \\times 10^8) \\cdot 2.4}{2.5 \\times 10^9}\n$$\nWe can simplify the expression by rearranging the terms:\n$$\nT = \\frac{5 \\cdot 2.4}{2.5} \\cdot \\frac{10^8}{10^9}\n$$\nFirst, evaluate the numerical part:\n$$\n\\frac{5 \\cdot 2.4}{2.5} = \\frac{12}{2.5} = \\frac{120}{25} = 4.8\n$$\nNext, evaluate the power of $10$ part:\n$$\n\\frac{10^8}{10^9} = 10^{8-9} = 10^{-1}\n$$\nCombining these results gives the total execution time $T$:\n$$\nT = 4.8 \\times 10^{-1} = 0.48 \\text{ seconds}\n$$\nAlternatively, we can evaluate the fraction directly:\n$$\nT = \\frac{1.2 \\times 10^9}{2.5 \\times 10^9} = \\frac{1.2}{2.5} = 0.48 \\text{ seconds}\n$$\nThus, the average Cycles Per Instruction is $2.4$, and the total program execution time is $0.48$ seconds.", "answer": "$$\n\\boxed{\\begin{pmatrix} 2.4 & 0.48 \\end{pmatrix}}\n$$", "id": "3631197"}, {"introduction": "Real-world processor performance is often limited by pipeline stalls, and one of the most significant sources of stalls is branch misprediction. Optimizing the branch predictor is a critical task in CPU design, and its impact can be precisely measured using CPI analysis. This problem [@problem_id:3631172] demonstrates how to quantify the performance gain from such an optimization by calculating the change in average CPI, or $\\Delta \\mathrm{CPI}$, and the resulting reduction in total execution time.", "problem": "A team optimizes the branch prediction unit of a Central Processing Unit (CPU). Consider a program that executes an instruction count of $1.5 \\times 10^{9}$ dynamic instructions on a single-issue pipeline. Conditional branches constitute a fraction $0.20$ of the dynamic instruction stream. Before the optimization, each conditional branch is mispredicted with probability $0.08$; after the optimization, the misprediction probability becomes $0.03$. Each mispredicted branch incurs a fixed, fully serialized penalty of $12$ clock cycles, and no other aspect of the pipeline or memory system changes. Assume that the optimization does not alter the instruction count or the base cycles per instruction for correctly predicted and non-branch instructions, and that penalties do not overlap with useful work.\n\nThe machine’s clock frequency is $3.2 \\times 10^{9}$ cycles per second. Using only first principles, reason from the definitions of cycles per instruction and execution time to derive the change in the average cycles per instruction, $\\Delta \\mathrm{CPI}$, and then compute the corresponding change in total execution time, $\\Delta T$, for this program.\n\nRound both $\\Delta \\mathrm{CPI}$ and $\\Delta T$ to four significant figures. Express $\\Delta T$ in seconds. Provide your final answer as two numbers in the order $(\\Delta \\mathrm{CPI}, \\Delta T)$.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- Total dynamic instruction count: $I_C = 1.5 \\times 10^{9}$\n- Fraction of conditional branches: $f_{branch} = 0.20$\n- Misprediction probability before optimization: $P_{mp, before} = 0.08$\n- Misprediction probability after optimization: $P_{mp, after} = 0.03$\n- Misprediction penalty: $P_{penalty} = 12$ clock cycles\n- Clock frequency: $f_{clk} = 3.2 \\times 10^{9}$ cycles per second\n- The optimization does not alter $I_C$ or the base cycles per instruction ($\\mathrm{CPI}_{base}$).\n- Penalties are fixed, fully serialized, and do not overlap with useful work.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the principles of computer architecture and organization. The CPU performance equation and the concepts of Cycles Per Instruction (CPI), branch prediction, and misprediction penalties are standard, fundamental topics in this field. The provided values are realistic.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary data and constraints to uniquely determine the change in CPI and execution time. The question is unambiguous.\n- **Objectivity**: The language is technical, precise, and free of subjective content.\n- **Completeness and Consistency**: The problem is self-contained and internally consistent. The assumptions, such as a constant base CPI and non-overlapping penalties, are clearly stated and serve to define a solvable model.\n- **Feasibility**: All numerical values are physically and technologically plausible for a modern processor.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived from first principles.\n\nThe total execution time, $T$, of a program is determined by the fundamental CPU performance equation:\n$$T = I_C \\times \\mathrm{CPI} \\times T_{clk}$$\nwhere $I_C$ is the instruction count, $\\mathrm{CPI}$ is the average number of clock cycles per instruction, and $T_{clk}$ is the clock period. The clock period is the reciprocal of the clock frequency, $f_{clk}$, so $T_{clk} = 1/f_{clk}$. The equation can be rewritten as:\n$$T = \\frac{I_C \\times \\mathrm{CPI}}{f_{clk}}$$\nThe average CPI is the sum of an ideal, or base, CPI ($\\mathrm{CPI}_{base}$) and additional CPI components resulting from pipeline stalls and other penalties. In this problem, the only changing source of penalty is branch misprediction. The total CPI can be expressed as:\n$$\\mathrm{CPI} = \\mathrm{CPI}_{base} + \\mathrm{CPI}_{penalty}$$\nThe penalty component, $\\mathrm{CPI}_{penalty}$, is the average number of penalty cycles per instruction due to branch mispredictions. It is calculated by determining the total number of penalty cycles and dividing by the total number of instructions, $I_C$.\n\nThe total number of branch instructions is $I_C \\times f_{branch}$.\nThe number of mispredicted branches is the total number of branches multiplied by the misprediction probability, $P_{mp}$:\n$$\\text{Number of mispredictions} = I_C \\times f_{branch} \\times P_{mp}$$\nEach misprediction incurs a penalty of $P_{penalty}$ cycles. The total number of penalty cycles is:\n$$\\text{Total penalty cycles} = (\\text{Number of mispredictions}) \\times P_{penalty} = I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}$$\nThe CPI contribution from this penalty is therefore:\n$$\\mathrm{CPI}_{penalty} = \\frac{\\text{Total penalty cycles}}{I_C} = \\frac{I_C \\times f_{branch} \\times P_{mp} \\times P_{penalty}}{I_C} = f_{branch} \\times P_{mp} \\times P_{penalty}$$\nThe problem asks for the change in the average cycles per instruction, $\\Delta \\mathrm{CPI}$, due to the optimization. This is the difference between the CPI after optimization and the CPI before optimization.\n$$\\mathrm{CPI}_{before} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty}$$\n$$\\mathrm{CPI}_{after} = \\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}$$\nThe change, $\\Delta \\mathrm{CPI}$, is:\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}$$\n$$\\Delta \\mathrm{CPI} = (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, after} \\times P_{penalty}) - (\\mathrm{CPI}_{base} + f_{branch} \\times P_{mp, before} \\times P_{penalty})$$\nThe base CPI, $\\mathrm{CPI}_{base}$, is constant and cancels out:\n$$\\Delta \\mathrm{CPI} = f_{branch} \\times P_{penalty} \\times (P_{mp, after} - P_{mp, before})$$\nSubstituting the given values:\n$$\\Delta \\mathrm{CPI} = 0.20 \\times 12 \\times (0.03 - 0.08) = 2.4 \\times (-0.05) = -0.12$$\nThe problem requires this value to be rounded to four significant figures.\n$$\\Delta \\mathrm{CPI} = -0.1200$$\nThe negative sign correctly indicates a decrease in CPI, which constitutes a performance improvement.\n\nNext, we calculate the corresponding change in total execution time, $\\Delta T$.\n$$\\Delta T = T_{after} - T_{before}$$\nUsing the execution time formula $T = (I_C \\times \\mathrm{CPI}) / f_{clk}$:\n$$\\Delta T = \\frac{I_C \\times \\mathrm{CPI}_{after}}{f_{clk}} - \\frac{I_C \\times \\mathrm{CPI}_{before}}{f_{clk}}$$\nFactoring out the constant terms $I_C$ and $f_{clk}$:\n$$\\Delta T = \\frac{I_C}{f_{clk}} (\\mathrm{CPI}_{after} - \\mathrm{CPI}_{before}) = \\frac{I_C}{f_{clk}} \\Delta \\mathrm{CPI}$$\nSubstituting the known and previously calculated values:\n$$I_C = 1.5 \\times 10^9 \\text{ instructions}$$\n$$f_{clk} = 3.2 \\times 10^9 \\text{ cycles/second}$$\n$$\\Delta \\mathrm{CPI} = -0.12$$\n$$\\Delta T = \\frac{1.5 \\times 10^{9}}{3.2 \\times 10^{9}} \\times (-0.12) = \\frac{1.5}{3.2} \\times (-0.12)$$\n$$\\Delta T = 0.46875 \\times (-0.12) = -0.05625 \\text{ seconds}$$\nThis value has exactly four significant figures, so no further rounding is needed. The negative sign signifies a reduction in execution time.\n\nThe final answers are $\\Delta \\mathrm{CPI} = -0.1200$ and $\\Delta T = -0.05625$ seconds.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-0.1200 & -0.05625\n\\end{pmatrix}\n}\n$$", "id": "3631172"}, {"introduction": "Performance optimization often involves complex trade-offs rather than simple improvements. For instance, refactoring code to use fewer instructions might result in more complex instructions that each take more cycles to execute, thus increasing the average CPI. This final practice [@problem_id:3631477] explores this classic trade-off between instruction count (IC) and CPI, teaching you how to evaluate whether a proposed optimization results in a net performance gain or loss.", "problem": "A compute-bound application runs on a single-issue in-order processor whose clock period is constant throughout all experiments. Let the baseline execution of the program have an instruction count (IC) of $IC_{0}$ and a cycles per instruction (CPI) of $CPI_{0}$. A code refactoring reduces the total instruction count by a fraction $\\Delta$ (so the new instruction count becomes $(1-\\Delta)IC_{0}$), but the average cycles per instruction increases by an additive amount $\\epsilon$ (so the new cycles per instruction becomes $CPI_{0}+\\epsilon$). Assume the processor’s clock frequency and microarchitectural conditions other than the stated $\\epsilon$ change remain unchanged.\n\nFor a concrete instance, take $IC_{0}=2.40\\times 10^{9}$, $CPI_{0}=1.20$, $\\Delta=0.18$, and $\\epsilon=0.25$. Determine the performance scaling factor $S$, defined as the ratio of the baseline execution time to the refactored execution time. Express your final result as a pure number (no units). Round your answer to four significant figures.", "solution": "The analysis begins with the fundamental CPU performance equation, which relates execution time ($T_{exec}$) to instruction count ($IC$), average cycles per instruction ($CPI$), and the clock period ($T_{clk}$):\n$$T_{exec} = IC \\times CPI \\times T_{clk}$$\nThe clock period $T_{clk}$ is the reciprocal of the clock frequency and is given as constant for this problem.\n\nLet the subscript $0$ denote the baseline execution and the subscript $1$ denote the execution after the code refactoring.\n\nFor the baseline case, the execution time, $T_0$, is given by:\n$$T_0 = IC_0 \\times CPI_0 \\times T_{clk}$$\nHere, $IC_0$ is the initial instruction count and $CPI_0$ is the initial average cycles per instruction.\n\nFor the refactored case, the problem states that the instruction count is reduced by a fraction $\\Delta$ and the CPI is increased by an additive amount $\\epsilon$. Therefore, the new instruction count, $IC_1$, and the new CPI, $CPI_1$, are:\n$$IC_1 = IC_0 \\times (1 - \\Delta)$$\n$$CPI_1 = CPI_0 + \\epsilon$$\nThe execution time for the refactored program, $T_1$, is then:\n$$T_1 = IC_1 \\times CPI_1 \\times T_{clk}$$\nSubstituting the expressions for $IC_1$ and $CPI_1$, we get:\n$$T_1 = (IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}$$\n\nThe performance scaling factor, $S$, is defined as the ratio of the baseline execution time to the refactored execution time. A value of $S > 1$ represents a speedup, while $S  1$ indicates a slowdown.\n$$S = \\frac{T_0}{T_1}$$\nWe substitute the expressions for $T_0$ and $T_1$ into this definition:\n$$S = \\frac{IC_0 \\times CPI_0 \\times T_{clk}}{(IC_0 \\times (1 - \\Delta)) \\times (CPI_0 + \\epsilon) \\times T_{clk}}$$\nThe terms $IC_0$ and $T_{clk}$ appear in both the numerator and the denominator, so they cancel out. This reveals that the performance scaling factor is independent of the initial instruction count and the clock speed, depending only on the initial CPI and the fractional/additive changes.\n$$S = \\frac{CPI_0}{(1 - \\Delta)(CPI_0 + \\epsilon)}$$\n\nNow, we substitute the given numerical values into this symbolic expression:\n$IC_0 = 2.40 \\times 10^9$ (note: this value is not needed for the final calculation of $S$)\n$CPI_0 = 1.20$\n$\\Delta = 0.18$\n$\\epsilon = 0.25$\n\nThe calculation for $S$ is:\n$$S = \\frac{1.20}{(1 - 0.18) \\times (1.20 + 0.25)}$$\nFirst, we evaluate the two terms in the denominator's product:\n$$1 - \\Delta = 1 - 0.18 = 0.82$$\n$$CPI_0 + \\epsilon = 1.20 + 0.25 = 1.45$$\nSubstitute these results back into the expression for $S$:\n$$S = \\frac{1.20}{0.82 \\times 1.45}$$\nNext, compute the product in the denominator:\n$$0.82 \\times 1.45 = 1.189$$\nFinally, perform the division to find the value of $S$:\n$$S = \\frac{1.20}{1.189} \\approx 1.0092514718...$$\n\nThe problem requires the result to be rounded to four significant figures. The first four significant figures are $1$, $0$, $0$, and $9$. The fifth significant figure is $2$. Since $2$ is less than $5$, we round down, meaning the fourth significant figure remains unchanged.\nThe value of $S$ rounded to four significant figures is $1.009$.", "answer": "$$\\boxed{1.009}$$", "id": "3631477"}]}