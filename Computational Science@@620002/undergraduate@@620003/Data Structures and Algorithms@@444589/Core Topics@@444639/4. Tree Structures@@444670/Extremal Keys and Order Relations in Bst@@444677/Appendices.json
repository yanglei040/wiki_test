{"hands_on_practices": [{"introduction": "Beyond simple lookups, many applications require us to understand the relative ordering and rank of elements. This practice introduces the powerful concept of an order-statistic tree, a Binary Search Tree augmented with subtree sizes. By maintaining the size of each subtree, we can answer rank-based queries like \"find the $k$-th smallest element\" in time proportional to the tree's height, $O(h)$, a vast improvement over linear-time scans. This exercise [@problem_id:3233472] is fundamental for building systems that require efficient data ranking and selection.", "problem": "You are to design and implement an augmented Binary Search Tree (BST) data structure to support order-based queries. Begin from the core definition of a Binary Search Tree (BST): for any node with key $x$, all keys in the left subtree are strictly less than $x$, and all keys in the right subtree are strictly greater than $x$. A BST’s in-order traversal visits keys in strictly increasing order. Your task is to augment each node with the size of its subtree and use this to compute extremal and order-based queries efficiently.\n\nDefine the generalized $m$-th successor of a real-valued query key $k$ in a set of distinct integer keys stored in a BST as follows. Let $r(k)$ be the count of keys in the tree that are less than or equal to $k$. Let $n$ be the total number of keys in the tree. The generalized $m$-th successor of $k$ is the key having in-order rank $r(k)+m$ when ranks are counted starting at $1$. If $r(k)+m$ is not in the interval $[1,n]$, the generalized $m$-th successor does not exist. This definition permits $k$ to be absent from the tree and permits $m$ to be zero. In particular, when $m=1$ and $k$ is present, this coincides with the conventional successor; when $m=0$, it returns the largest key less than or equal to $k$ if it exists.\n\nImplement a program that:\n- Builds a BST from a given finite list of distinct integer keys. Keys are distinct by assumption; if an insertion attempts to add a duplicate, it must be ignored without changing the tree.\n- Augments each node with its subtree size, defined as $1+\\text{size(left)}+\\text{size(right)}$, where an empty subtree has size $0$.\n- Supports two operations in time proportional to the tree height:\n  - $r(k)$: returns the number of keys less than or equal to $k$.\n  - $\\text{select}(t)$: returns the key whose in-order rank is $t$ (with $t$ starting at $1$).\n- Computes the generalized $m$-th successor of $k$ as $\\text{select}(r(k)+m)$ when the target rank lies in $[1,n]$, and reports a sentinel value otherwise.\n\nOrder relation and domain assumptions:\n- All keys are integers in the half-open interval $[0,10^9)$.\n- The strict total order is the standard integer less-than relation $$.\n- Queries may use any integer $k$ (not necessarily within $[0,10^9)$); $m$ is a nonnegative integer.\n- If the generalized $m$-th successor does not exist, output the sentinel integer $-1$.\n\nTest suite and required output format:\n- For each of the following parameter sets, construct the BST from the provided list of keys (ignoring duplicates if any), then compute the generalized $m$-th successor of the given $(k,m)$ using the definition above. The program must aggregate the results for all cases and print a single line that is a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,\\dots,x_T]$ where each $x_i$ is the integer answer for test case $i$.\n\nUse the following test suite:\n- Case $1$: keys $[20,10,30,5,15,25,35]$, query $(k=10,m=1)$.\n- Case $2$: keys $[20,10,30,5,15,25,35]$, query $(k=10,m=0)$.\n- Case $3$: keys $[20,10,30,5,15,25,35]$, query $(k=10,m=3)$.\n- Case $4$: keys $[20,10,30,5,15,25,35]$, query $(k=34,m=1)$.\n- Case $5$: keys $[20,10,30,5,15,25,35]$, query $(k=35,m=1)$.\n- Case $6$: keys $[20,10,30,5,15,25,35]$, query $(k=-100,m=1)$.\n- Case $7$: keys $[1,2,3,4]$, query $(k=2,m=2)$.\n- Case $8$: keys $[1,2,3,4]$, query $(k=2,m=10)$.\n- Case $9$: keys $[1,2,3,4]$, query $(k=100,m=0)$.\n- Case $10$: keys $[]$ (empty tree), query $(k=5,m=1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,\\dots,x_{10}]$ where each $x_i$ is an integer result for case $i$.", "solution": "The problem requires the design and implementation of an augmented Binary Search Tree (BST) to efficiently answer order-based queries. The core task is to compute the generalized $m$-th successor of a key $k$, which is defined as the key with in-order rank $r(k)+m$, where $r(k)$ is the number of keys in the tree less than or equal to $k$.\n\nThe solution is based on an order-statistic tree, a BST where each node is augmented with the size of the subtree rooted at it. This augmentation allows for the efficient computation of rank-based queries.\n\n**1. Data Structure: Augmented BST Node**\n\nWe define a `Node` for the BST. In addition to the standard `key`, `left` child pointer, and `right` child pointer, each node will store an attribute `size`. The `size` of a node is defined as the total number of nodes in the subtree rooted at that node (including the node itself).\n$$\n\\text{node.size} = 1 + \\text{size}(\\text{node.left}) + \\text{size}(\\text{node.right})\n$$\nwhere `size(null node)` is defined as $0$. A newly inserted leaf node has a size of $1$.\n\n**2. Core Operations**\n\nThe functionality is built upon three main operations: `insert`, `r` (rank), and `select`. All these operations are designed to have a time complexity proportional to the height of the tree, which is $O(h)$. For a balanced tree, this is $O(\\log n)$, and for a degenerate tree, it is $O(n)$, where $n$ is the number of keys.\n\n**2.1. Insertion (`insert(key)`)**\n\nThe `insert` operation follows the standard BST insertion logic to find the correct position for the new key.\n- If the tree is empty, the new key becomes the root, with its `size` initialized to $1$.\n- We traverse the tree from the root, comparing the key to be inserted with the key of the current node. If the new key is smaller, we go left; if larger, we go right.\n- If a node with the same key is found, the insertion is aborted to avoid duplicates, as per the problem specification.\n- When traversing the tree to find the insertion point, we must update the `size` attribute of each node along the path. Upon returning from the recursive call that inserts the new node, the `size` of the parent node is recomputed. This ensures that the `size` of every node from the new leaf up to the root is correctly incremented by $1$.\n\n**2.2. Rank Query (`r(k)`)**\n\nThe function $r(k)$ computes the number of keys in the tree that are less than or equal to $k$. This is equivalent to finding the in-order rank of the largest key that is less than or equal to $k$.\nThe algorithm traverses the tree from the root:\n- Let the current node be $x$.\n- If $k  x.\\text{key}$: All keys less than or equal to $k$ must be in the left subtree of $x$. We recursively search in $x.\\text{left}$.\n- If $k > x.\\text{key}$: All keys in the left subtree of $x$, plus $x$ itself, are less than or equal to $k$. The count from this part of the tree is $\\text{size}(x.\\text{left}) + 1$. We add this to the result of a recursive search in the right subtree, $x.\\text{right}$.\n- If $k = x.\\text{key}$: All keys in the left subtree of $x$, plus $x$ itself, are less than or equal to $k$. The count is $\\text{size}(x.\\text{left}) + 1$. The search terminates.\n- If we reach a null pointer, the count is $0$.\n\n**2.3. Select Query (`select(t)`)**\n\nThe function $\\text{select}(t)$ finds the key with a given in-order rank $t$, where ranks are $1$-indexed.\nThe algorithm leverages the `size` attribute to navigate the tree:\n- Let the current node be $x$. Let the size of its left subtree be $s_L = \\text{size}(x.\\text{left})$.\n- The rank of the key $x.\\text{key}$ itself is $s_L + 1$.\n- If $t = s_L + 1$: The current node $x$ is the target. We return $x.\\text{key}$.\n- If $t  s_L + 1$: The target key is in the left subtree. We recursively search for the key with rank $t$ in $x.\\text{left}$.\n- If $t > s_L + 1$: The target key is in the right subtree. We have skipped the $s_L + 1$ keys in the left subtree and the root. We must therefore find the key with rank $t - (s_L + 1)$ in the right subtree, $x.\\text{right}$.\n\n**3. Computing the Generalized m-th Successor**\n\nWith the `r` and `select` functions, computing the generalized $m$-th successor of a query key $k$ is straightforward. Let $n$ be the total number of keys in the tree, which is simply the size of the root node.\n1. Compute the rank of $k$: $\\text{rank}_k = r(k)$.\n2. Calculate the target rank: $\\text{target\\_rank} = \\text{rank}_k + m$.\n3. Check if the target rank is valid. A rank $t$ is valid if and only if $1 \\le t \\le n$.\n4. If $1 \\le \\text{target\\_rank} \\le n$, the result is $\\text{select}(\\text{target\\_rank})$.\n5. Otherwise, the generalized successor does not exist, and we return the sentinel value $-1$. This handles cases where the tree is empty ($n=0$) or the target rank is outside the valid range.\n\nThis design fulfills all requirements of the problem, providing the specified functionality with the required time complexity for each operation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in an augmented Binary Search Tree.\n    Each node stores its key, pointers to left and right children,\n    and the size of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.size = 1\n\nclass AugmentedBST:\n    \"\"\"\n    An augmented Binary Search Tree that supports order-statistic queries.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _get_size(self, node):\n        \"\"\"Helper to get size of a node's subtree, returns 0 if node is None.\"\"\"\n        return node.size if node else 0\n\n    def insert(self, key):\n        \"\"\"Inserts a key into the BST, ignoring duplicates.\"\"\"\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        \"\"\"Recursively inserts a key and updates subtree sizes.\"\"\"\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else: # Key already exists, do nothing.\n            return node\n            \n        # Update the size of the current node\n        node.size = 1 + self._get_size(node.left) + self._get_size(node.right)\n        return node\n\n    def r(self, k):\n        \"\"\"Returns the number of keys in the tree less than or equal to k.\"\"\"\n        return self._r_recursive(self.root, k)\n\n    def _r_recursive(self, node, k):\n        \"\"\"Recursive helper for rank query.\"\"\"\n        if not node:\n            return 0\n        \n        if k  node.key:\n            return self._r_recursive(node.left, k)\n        elif k > node.key:\n            return self._get_size(node.left) + 1 + self._r_recursive(node.right, k)\n        else: # k == node.key\n            return self._get_size(node.left) + 1\n\n    def select(self, t):\n        \"\"\"Returns the key with the t-th in-order rank (1-indexed).\"\"\"\n        if not self.root or not (1 = t = self.root.size):\n            return None # Or raise an error, indicates invalid rank\n        return self._select_recursive(self.root, t)\n\n    def _select_recursive(self, node, t):\n        \"\"\"Recursive helper for select query.\"\"\"\n        if not node:\n            # This case should not be reached if initial rank is valid.\n            return None\n\n        left_size = self._get_size(node.left)\n        current_rank = left_size + 1\n        \n        if t == current_rank:\n            return node.key\n        elif t  current_rank:\n            return self._select_recursive(node.left, t)\n        else: # t > current_rank\n            return self._select_recursive(node.right, t - current_rank)\n\n    def generalized_successor(self, k, m):\n        \"\"\"\n        Computes the generalized m-th successor of k.\n        \"\"\"\n        n = self._get_size(self.root)\n        if n == 0:\n            return -1\n            \n        rank_k = self.r(k)\n        target_rank = rank_k + m\n        \n        if 1 = target_rank = n:\n            return self.select(target_rank)\n        else:\n            return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 0)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 3)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (34, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (35, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (-100, 1)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 2)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 10)}),\n        ({'keys': [1, 2, 3, 4], 'query': (100, 0)}),\n        ({'keys': [], 'query': (5, 1)}),\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        k, m = case['query']\n        \n        bst = AugmentedBST()\n        for key in keys:\n            bst.insert(key)\n        \n        result = bst.generalized_successor(k, m)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3233472"}, {"introduction": "After mastering rank-based queries, we can tackle another common problem: finding an extremal value within a specific range of keys, such as $[L, R]$. This exercise explores a different augmentation strategy, where each node stores the minimum key within its own subtree. This augmentation, combined with the BST's intrinsic ordering property, allows for an elegant and efficient algorithm that can prune large sections of the tree from the search space. This practice [@problem_id:3233410] demonstrates how a tailored augmentation can solve complex query types with remarkable efficiency, achieving $O(h)$ performance.", "problem": "You are to design and implement an algorithm that augments a Binary Search Tree (BST) to answer queries of the form: given a closed interval $[L,R]$, return the minimum key stored in the tree that lies in that interval, or return $-1$ if the interval contains no stored key. Your design and implementation must be justified from first principles based on the fundamental properties of Binary Search Trees (BSTs) and must achieve time complexity $O(\\log n)$ on height-balanced trees, where $n$ is the number of keys stored.\n\nBegin from the following base principles:\n- A Binary Search Tree (BST) over totally ordered keys satisfies: for any node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n- A height-balanced BST has height $h=O(\\log n)$, which implies that any single root-to-leaf path has length $O(\\log n)$.\n- Augmenting a data structure means storing at each node additional fields that are functions of that node’s subtree, computed and maintained without violating the BST ordering invariant.\n\nYour task:\n1. Augment each node with a field that stores the minimum key in its subtree (including the node itself). This field must be computable in $O(1)$ time from its children and the node’s own key, once the children are known.\n2. Using only the BST ordering property and the augmentation above, design an $O(h)$ algorithm (with $h$ the height of the tree) that finds the minimum key in a given interval $[L,R]$, or returns $-1$ if no key lies in the interval. On height-balanced BSTs where $h=O(\\log n)$, this achieves the target $O(\\log n)$ time.\n3. Your algorithm must not scan all keys or perform an $O(n)$ traversal in the worst case; it must rely on visiting $O(h)$ nodes and using the augmentation to account for entire subtrees in $O(1)$ time each.\n\nOperational constraints:\n- All keys are distinct integers.\n- Intervals are closed and inclusive. If $LR$, treat the interval as empty and return $-1$.\n- If no key lies in $[L,R]$, return $-1$.\n- There are no physical units involved.\n\nImplementation requirements:\n- Construct height-balanced BSTs for the test cases by building from sorted arrays (for example, by recursively choosing medians), ensuring height $h=O(\\log n)$.\n- Implement a function that, given $L$ and $R$, returns the minimum key in $[L,R]$ using the augmentation in $O(h)$ time.\n\nTest suite:\nFor this assignment, build BSTs from the specified sets of keys and answer the listed queries. Each test case is independent; you may rebuild the BST for each case. The expected final answers must be integers. Use the following test cases:\n- Case $1$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=5$, $R=13$.\n- Case $2$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=15$, $R=20$.\n- Case $3$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=7$, $R=7$.\n- Case $4$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=0$, $R=2$.\n- Case $5$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=-5$, $R=100$.\n- Case $6$: keys $[1,3,4,6,7,8,10,13,14]$, query $L=9$, $R=5$.\n- Case $7$: keys $[42]$, query $L=10$, $R=100$.\n- Case $8$: keys $[42]$, query $L=43$, $R=50$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the cases above as a comma-separated list enclosed in square brackets, for example, $[a_1,a_2,\\dots,a_8]$, where each $a_i$ is the integer answer for case $i$ in order. No additional text should be printed.", "solution": "The problem requires the design and implementation of an algorithm to find the minimum key within a closed interval $[L, R]$ in an augmented Binary Search Tree (BST). The algorithm must achieve a time complexity of $O(h)$, where $h$ is the height of the tree, which corresponds to $O(\\log n)$ for a height-balanced BST with $n$ nodes.\n\nWe begin by establishing the foundational principles.\n\nA Binary Search Tree (BST) is a node-based binary tree data structure which has the following properties for any node $x$ with key $k$:\n1.  All keys in the left subtree of $x$ are strictly less than $k$.\n2.  All keys in the right subtree of $x$ are strictly greater than $k$.\n3.  Both the left and right subtrees are also binary search trees.\n\nFor this problem, we augment the BST. Augmentation involves adding extra information to each node to support new queries efficiently. The integrity of the augmentation must be maintained during any tree modifications, and its value must be computable from the node's local information and the augmented information from its children.\n\n**1. Node Augmentation**\n\nAs stipulated, we augment each node $x$ in the BST with an additional field, which we shall denote as $x.min\\_key$. This field stores the minimum key found in the entire subtree rooted at $x$ (including $x$ itself).\n\nThe value of $x.min\\_key$ can be computed from the node's own key and the augmented fields of its children. Let $x.key$ be the key of node $x$, and let $x.left$ and $x.right$ be its left and right children, respectively. Based on the BST property, any key in the right subtree of $x$ is greater than $x.key$, and any key in the left subtree is less than $x.key$. Therefore, the minimum key in the subtree rooted at $x$ must be either $x.key$ itself (if $x$ has no left child) or a key within the left subtree. The minimum key in the left subtree is, by definition, stored in $x.left.min\\_key$.\n\nThus, the value of $x.min\\_key$ is given by the recurrence:\n$$\nx.min\\_key =\n\\begin{cases}\nx.left.min\\_key  \\text{if } x.left \\text{ is not null} \\\\\nx.key  \\text{if } x.left \\text{ is null}\n\\end{cases}\n$$\nThis computation requires only a reference to the left child's augmented field, taking $O(1)$ time per node. When constructing the tree, these values can be computed efficiently in a post-order traversal fashion (i.e., after the children's values have been computed). For the required recursive construction from a sorted array, this computation occurs naturally as the recursion unwinds.\n\n**2. Algorithm Design**\n\nWe now design an algorithm, `FindMinInRange(node, L, R)`, that finds the minimum key in the subtree of `node` that falls within the interval $[L, R]$. The algorithm will return a special value, $\\infty$, if no such key exists. The main function will handle the initial call and the conversion of $\\infty$ to the required output of $-1$.\n\nThe algorithm leverages both the fundamental BST ordering property and the `min_key` augmentation to prune the search space efficiently. The search for a minimum value prioritizes exploring portions of the tree with smaller keys first: the left subtree, then the current node, then the right subtree.\n\nThe recursive algorithm is as follows:\n\n`FindMinInRange(node, L, R)`:\n\n1.  **Base Case**: If `node` is null, the subtree is empty and contains no keys. Return $\\infty$.\n\n2.  **Pruning with Augmentation**: We first check if the entire subtree can be discarded. The smallest key in the subtree is `node.min_key`. If this minimum is greater than the upper bound of the interval, `R`, then no key in the entire subtree can be in $[L, R]$.\n    If `R  node.min_key`, return $\\infty$.\n\n3.  **Pruning with BST Property**: If the key of the current node, `node.key`, is less than the lower bound of the interval, `L`, then by the BST property, `node.key` and all keys in its left subtree are outside the interval $[L, R]$. The only possibility for a solution is in the right subtree.\n    If `node.key  L`, return `FindMinInRange(node.right, L, R)`.\n\n4.  **Recursive Search**: If the algorithm has reached this point, we know that `node.key >= L` and `node.min_key = R`. This means a valid key might exist in the subtree. Since we are looking for the minimum, we must search in increasing order of key values.\n    a. **Search Left Subtree**: The smallest potential candidates reside in the left subtree. We recursively search it:\n       `result_left = FindMinInRange(node.left, L, R)`\n       If this search finds a valid key (i.e., `result_left` is not $\\infty$), this key is guaranteed to be smaller than `node.key` and any key in the right subtree. Therefore, it is the minimum valid key in the entire subtree of `node`. We can immediately return it.\n       If `result_left \\neq \\infty`, return `result_left`.\n\n    b. **Check Current Node**: If the search in the left subtree yielded no result, the next smallest candidate is the key of the current node, `node.key`. We already established that `node.key >= L`. We now check if it also satisfies the upper bound.\n       If `node.key = R`, then `node.key` is the smallest valid key (since the left subtree contained none). Return `node.key`.\n\n    c. **Search Right Subtree**: If the left subtree was fruitless and the current node's key is not in the interval (i.e., `node.key > R`), the only remaining possibility is the right subtree.\n       Return `FindMinInRange(node.right, L, R)`.\n\n**3. Complexity Analysis**\n\nAt each node in the recursion, the algorithm performs a constant number of comparisons and may make one or two recursive calls. However, an analysis of the control flow shows that the total number of visited nodes is proportional to the height of the tree, $h$. The logic ensures that after exploring a branch (e.g., the left subtree), the algorithm either terminates or continues down a single path. For instance, if a solution is found in the left subtree, the function returns immediately without exploring the current node or the right subtree. This structure limits the traversal. In the worst-case scenario, the search path resembles a path from the root to a leaf. Therefore, the time complexity is $O(h)$. For a height-balanced BST, where $h = O(\\log n)$, the complexity is $O(\\log n)$, satisfying the problem requirements.\n\nThe special case where $L > R$ defines an empty interval. This is handled by a check in the main wrapper function before initiating the recursive search, returning $-1$ in $O(1)$ time.", "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the augmented Binary Search Tree.\n    Each node stores its key, left and right children, and the minimum key\n    in the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        # Augmentation: stores the minimum key in the subtree of this node.\n        self.min_key = key\n\ndef build_balanced_bst(keys):\n    \"\"\"\n    Constructs a height-balanced BST from a sorted list of keys.\n    The augmentation field (min_key) is computed recursively.\n    \n    Args:\n        keys: A sorted list of unique integer keys.\n    \n    Returns:\n        The root node of the constructed BST, or None if the list is empty.\n    \"\"\"\n    if not keys:\n        return None\n\n    # Recursively choose the median as the root to ensure balance.\n    mid_idx = len(keys) // 2\n    root = Node(keys[mid_idx])\n\n    root.left = build_balanced_bst(keys[:mid_idx])\n    root.right = build_balanced_bst(keys[mid_idx+1:])\n\n    # Compute the augmentation field after children are constructed.\n    # The minimum key in a subtree is the minimum of its leftmost branch.\n    if root.left:\n        root.min_key = root.left.min_key\n    else:\n        root.min_key = root.key\n        \n    return root\n\ndef _find_min_in_range_recursive(node, L, R):\n    \"\"\"\n    Recursive helper to find the minimum key in the interval [L, R].\n    \n    Args:\n        node: The current node in the BST.\n        L: The lower bound of the interval (inclusive).\n        R: The upper bound of theinterval (inclusive).\n        \n    Returns:\n        The minimum key in the interval, or np.inf if no such key exists.\n    \"\"\"\n    # Base Case: If the node is null, there are no keys in this subtree.\n    if node is None:\n        return np.inf\n\n    # Pruning Step 1 (using augmentation): If the smallest key in the entire\n    # subtree is greater than R, no key in this subtree can be in the range.\n    if R  node.min_key:\n        return np.inf\n\n    # Pruning Step 2 (using BST property): If the current node's key is less than L,\n    # then itself and its entire left subtree are out of range. Search right.\n    if node.key  L:\n        return _find_min_in_range_recursive(node.right, L, R)\n\n    # At this point, node.key >= L. A solution might be in the left subtree,\n    # at the current node, or in the right subtree. We search in that order\n    # to find the minimum.\n\n    # 1. Search the left subtree.\n    result_left = _find_min_in_range_recursive(node.left, L, R)\n    if result_left != np.inf:\n        # If a valid key is found in the left subtree, it's guaranteed to be\n        # the smallest possible answer in this branch.\n        return result_left\n\n    # 2. Check the current node.\n    if node.key = R:\n        # The left subtree had no solution. If the current node is valid,\n        # it is the smallest valid key we can find from this point on.\n        return node.key\n\n    # 3. Search the right subtree.\n    # This is reached only if the left subtree had no solution and the\n    # current node's key was invalid (i.e., node.key > R).\n    return _find_min_in_range_recursive(node.right, L, R)\n\ndef find_min_in_range(root, L, R):\n    \"\"\"\n    Wrapper function for the interval minimum query.\n    \n    Args:\n        root: The root of the augmented BST.\n        L: The lower bound of the interval.\n        R: The upper bound of the interval.\n        \n    Returns:\n        The minimum key in [L, R], or -1 if the interval is invalid or no key is found.\n    \"\"\"\n    # An empty interval [L, R] with L > R contains no keys.\n    if L > R:\n        return -1\n\n    result = _find_min_in_range_recursive(root, L, R)\n\n    # The recursive helper uses np.inf to signal \"not found\".\n    # Convert this to the required output format of -1.\n    return int(result) if result != np.inf else -1\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (5, 13)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (15, 20)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (7, 7)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (0, 2)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (-5, 100)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (9, 5)},\n        {'keys': [42], 'query': (10, 100)},\n        {'keys': [42], 'query': (43, 50)},\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        L, R = case['query']\n        \n        # Build the augmented, height-balanced BST for the current case.\n        root = build_balanced_bst(keys)\n        \n        # Perform the query and store the result.\n        result = find_min_in_range(root, L, R)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3233410"}, {"introduction": "Data structures in real-world systems can become corrupted, and a robust understanding of their core invariants is essential for diagnosing such errors. This problem challenges you to leverage the most fundamental property of a BST: that an in-order traversal of its nodes yields a sorted sequence of keys. By identifying predictable violations in this sequence, you can diagnose a specific corruption—two swapped keys—without modifying the tree or using complex augmentations. This classic exercise in algorithmic diagnostics [@problem_id:3233436] hones your problem-solving skills, requiring careful state management within a space-efficient traversal.", "problem": "You are given the formal setting of a Binary Search Tree (BST). A Binary Search Tree (BST) is a rooted binary tree where each node stores a distinct key $k \\in \\mathbb{Z}$ such that, for any node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. An in-order traversal of a valid Binary Search Tree (BST) visits keys in strictly increasing order. Consider a tree that is a valid Binary Search Tree (BST) except that exactly two nodes have had their keys swapped. Your task is to locate the two swapped keys using only $O(h)$ additional space, where $h$ is the height of the tree, without modifying the tree structure.\n\nFundamental base and facts you may assume:\n- Definition of Binary Search Tree (BST) order: for each node with key $k$, keys in the left subtree are $ k$ and keys in the right subtree are $ k$.\n- In-order traversal of a valid Binary Search Tree (BST) with distinct keys yields a strictly increasing sequence of keys.\n\nYour program must:\n- Construct a Binary Search Tree (BST) by inserting the given keys, in the specified order, into an initially empty tree using the standard Binary Search Tree (BST) insert rule.\n- Swap the keys of the two specified nodes (identified by their original keys before any swap).\n- Detect and return the two swapped keys as a list of two integers in increasing order, using at most $O(h)$ additional space.\n- Repeat for all provided test cases and print all results on a single line in the specified output format.\n\nConstraints and requirements:\n- All keys are distinct integers.\n- There is exactly one pair of nodes whose keys have been swapped.\n- Additional space usage must be $O(h)$, where $h$ is the height of the tree. Time complexity should be $O(n)$ for $n$ nodes, by a single in-order traversal with an explicit stack of size $O(h)$.\n\nTest suite to cover general and edge cases. Each test case is specified by an insertion sequence and a pair of keys to swap:\n- Test case $1$: insertion sequence $[4,2,6,1,3,5,7]$, swap pair $(3,6)$.\n- Test case $2$: insertion sequence $[4,2,6,1,3,5,7]$, swap pair $(3,4)$.\n- Test case $3$: insertion sequence $[1,2,3,4,5,6]$, swap pair $(1,6)$.\n- Test case $4$: insertion sequence $[1,2]$, swap pair $(1,2)$.\n- Test case $5$: insertion sequence $[10,5,15,2,7,12,20,1,3,6,8,11,13,18,25]$, swap pair $(1,25)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is itself a two-element list $[a,b]$ of the detected swapped keys in increasing order for test case $i$.\n- For the above test suite, your program must print exactly one line in the format $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4],[a_5,b_5]]$ with no spaces.", "solution": "### Principle-Based Solution\n\nThe resolution of this problem hinges on a foundational property of Binary Search Trees (BSTs): an in-order traversal of a valid BST yields a sequence of keys that is strictly increasing. Let the sequence of keys obtained from an in-order traversal of a BST with $n$ nodes be $S = (k_1, k_2, \\dots, k_n)$. For a valid BST, it must hold that $k_i  k_{i+1}$ for all $i \\in \\{1, 2, \\dots, n-1\\}$.\n\nWhen the keys of exactly two nodes are swapped, this strictly increasing property is violated. Our objective is to identify the two nodes involved in the swap by detecting these violations during a single in-order traversal, while adhering to an $O(h)$ space complexity constraint, where $h$ is the height of the tree.\n\nAn iterative in-order traversal using an explicit stack of nodes satisfies this space constraint, as the maximum depth of the stack is equal to the height $h$ of the tree. During this traversal, we can compare each visited node's key with the key of the previously visited node to find any inversions.\n\nLet the original, correct, sorted sequence of keys be $(x_1, x_2, \\dots, x_n)$. Suppose the keys $x_i$ and $x_j$ are swapped, where $i  j$ and thus $x_i  x_j$. The resulting in-order sequence will be perturbed. We analyze two distinct cases for the locations of these violations.\n\n**Case 1: Non-adjacent keys are swapped.**\nThe original sequence is $(\\dots, x_{i-1}, x_i, x_{i+1}, \\dots, x_{j-1}, x_j, x_{j+1}, \\dots)$.\nAfter swapping $x_i$ and $x_j$, the sequence becomes $(\\dots, x_{i-1}, x_j, x_{i+1}, \\dots, x_{j-1}, x_i, x_{j+1}, \\dots)$.\nLet's examine the points of non-monotonicity:\n1.  At the position of the former $x_i$, we now have $x_j$. The pair of keys is $(x_j, x_{i+1})$. Since $i+1 \\le j$, we have $x_{i+1} \\le x_j$. As all keys are distinct, if $i+1  j$, then $x_{i+1}  x_j$. This gives the first violation: $x_j  x_{i+1}$. The first out-of-place element is $x_j$.\n2.  At the position of the former $x_j$, we now have $x_i$. The preceding key is $x_{j-1}$. The pair is $(x_{j-1}, x_i)$. Since $i  j-1$, we have $x_i  x_{j-1}$. This gives the second violation: $x_{j-1}  x_i$. The second out-of-place element is $x_i$.\n\nIn this scenario, we will find two pairs of adjacent keys $(k_p, k_{p+1})$ in the traversed sequence such that $k_p  k_{p+1}$. The first key of the first pair ($k_p$) and the second key of the second pair ($k_{p+1}$) constitute the swapped pair.\n\n**Case 2: Adjacent keys are swapped.**\nThe original sequence is $(\\dots, x_{i-1}, x_i, x_{i+1}, x_{i+2}, \\dots)$, where we swap $x_i$ and $x_{i+1}$.\nThe sequence becomes $(\\dots, x_{i-1}, x_{i+1}, x_i, x_{i+2}, \\dots)$.\nThere is only one point of non-monotonicity: the pair $(x_{i+1}, x_i)$, where $x_{i+1}  x_i$. In this case, we will find exactly one pair of adjacent keys $(k_p, k_{p+1})$ such that $k_p  k_{p+1}$. These two keys, $k_p$ and $k_{p+1}$, are precisely the swapped keys.\n\n**Algorithmic Strategy**\nA unified algorithm can handle both cases. We perform an iterative in-order traversal, keeping track of the previously visited node. We maintain three pointers to nodes (or variables for their keys): `first`, `middle`, and `last`.\n\n1.  Initialize `prev` (previous node in traversal), `first`, `middle`, `last` to a null state.\n2.  Perform an iterative in-order traversal using a stack. For each visited node `curr`:\n3.  If `prev` is not null and `prev.key > curr.key`, a violation is found.\n    a. If `first` is null, this is the first violation encountered. We record `first = prev` and `middle = curr`. `first` holds the first element of the out-of-place pair, and `middle` holds the second element (in case this is the only violation, as in the adjacent swap).\n    b. If `first` is not null, this is the second violation. We record `last = curr`. This `curr` node is the second element of the out-of-place pair for the non-adjacent case.\n4.  Update `prev = curr` and continue the traversal.\n5.  After the traversal is complete:\n    a. If `last` is not null (i.e., we found two violations), the swapped keys are `first.key` and `last.key`.\n    b. If `last` is null (i.e., we found only one violation), the swapped keys are `first.key` and `middle.key`.\n6.  The final result is the pair of detected keys, sorted in increasing order.\n\nThis algorithm correctly identifies the swapped keys in $O(n)$ time due to the single full traversal of the tree, and requires $O(h)$ auxiliary space for the traversal stack, satisfying all problem constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a Binary Search Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef insert_node(root, key):\n    \"\"\"Inserts a key into the BST and returns the root.\"\"\"\n    if root is None:\n        return Node(key)\n    \n    current = root\n    while True:\n        if key  current.key:\n            if current.left is None:\n                current.left = Node(key)\n                return root\n            current = current.left\n        else: # key > current.key, as keys are distinct\n            if current.right is None:\n                current.right = Node(key)\n                return root\n            current = current.right\n\ndef find_node(root, key):\n    \"\"\"Finds and returns the node with the given key.\"\"\"\n    current = root\n    while current is not None:\n        if key == current.key:\n            return current\n        elif key  current.key:\n            current = current.left\n        else:\n            current = current.right\n    return None\n\ndef find_swapped_keys(root):\n    \"\"\"\n\n    Finds the two swapped keys in a BST using an iterative in-order traversal.\n    Space complexity: O(h), where h is the tree height.\n    Time complexity: O(n), where n is the number of nodes.\n    \"\"\"\n    stack = []\n    current = root\n    \n    prev_node = None\n    first_violator = None\n    middle_violator = None\n    last_violator = None\n\n    while current is not None or stack:\n        while current is not None:\n            stack.append(current)\n            current = current.left\n            \n        current = stack.pop()\n        \n        # In-order processing logic\n        if prev_node is not None and prev_node.key > current.key:\n            # A violation is found\n            if first_violator is None:\n                # First violation\n                first_violator = prev_node\n                middle_violator = current\n            else:\n                # Second violation\n                last_violator = current\n\n        prev_node = current\n        current = current.right\n\n    if last_violator:\n        # Non-adjacent swap\n        key1 = first_violator.key\n        key2 = last_violator.key\n    else:\n        # Adjacent swap\n        key1 = first_violator.key\n        key2 = middle_violator.key\n        \n    return sorted([key1, key2])\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 6)},\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 4)},\n        {'insert': [1, 2, 3, 4, 5, 6], 'swap': (1, 6)},\n        {'insert': [1, 2], 'swap': (1, 2)},\n        {'insert': [10, 5, 15, 2, 7, 12, 20, 1, 3, 6, 8, 11, 13, 18, 25], 'swap': (1, 25)},\n    ]\n\n    results_str = []\n    for case in test_cases:\n        # 1. Construct the BST\n        root = None\n        for key in case['insert']:\n            root = insert_node(root, key)\n            \n        # 2. Find and swap the specified nodes' keys\n        key_to_swap1, key_to_swap2 = case['swap']\n        node1 = find_node(root, key_to_swap1)\n        node2 = find_node(root, key_to_swap2)\n        if node1 and node2:\n            node1.key, node2.key = node2.key, node1.key\n\n        # 3. Detect the swapped keys\n        swapped_pair = find_swapped_keys(root)\n        \n        # 4. Format the result string\n        results_str.append(f\"[{swapped_pair[0]},{swapped_pair[1]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3233436"}]}