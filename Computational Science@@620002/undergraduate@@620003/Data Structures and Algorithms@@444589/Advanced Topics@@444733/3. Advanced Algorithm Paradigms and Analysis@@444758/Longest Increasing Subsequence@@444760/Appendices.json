{"hands_on_practices": [{"introduction": "Before diving into complex algorithms, it's crucial to understand why they are necessary. This first exercise [@problem_id:3247982] presents a seemingly intuitive \"greedy\" strategy for finding an increasing subsequence. By working through this example, you will discover a classic pitfall and see firsthand why such myopic approaches can fail to find the true longest increasing subsequence, motivating the need for more powerful dynamic programming techniques.", "problem": "Consider the following definitions. A subsequence of a sequence $A = (a_{1}, a_{2}, \\dots, a_{n})$ is any sequence $(a_{i_{1}}, a_{i_{2}}, \\dots, a_{i_{k}})$ with $1 \\leq i_{1}  i_{2}  \\dots  i_{k} \\leq n$. An increasing subsequence is a subsequence with $a_{i_{1}}  a_{i_{2}}  \\dots  a_{i_{k}}$. The longest increasing subsequence (LIS) of $A$ is an increasing subsequence of maximum possible length. For two finite sequences $(x_{1}, x_{2}, \\dots, x_{p})$ and $(y_{1}, y_{2}, \\dots, y_{q})$, the lexicographic order is defined by comparing $x_{j}$ and $y_{j}$ at the first index $j$ where they differ; the sequence with the smaller $j$-th element is lexicographically smaller, and if one sequence is a prefix of the other, then the shorter sequence is lexicographically smaller.\n\nDefine the following lexicographic-greedy construction of an increasing subsequence: starting from the globally minimal element of $A$ (if there are multiple equal minima, take the leftmost by index), repeatedly append the smallest possible value to the subsequence among those elements strictly larger than the last chosen value and occurring to the right in $A$; stop when no such element exists. Denote the resulting subsequence by $G(A)$.\n\nLet $A$ be the sequence of length $12$ given by\n$$\nA = (1,\\, 100,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200,\\, 2).\n$$\nCompute the value\n$$\nd = \\operatorname{length}(\\text{LIS of }A) - \\operatorname{length}(G(A)).\n$$\nYour final answer must be a single real-valued number. No rounding is required.", "solution": "The problem requires us to compute the difference $d$ between the length of the longest increasing subsequence (LIS) of a given sequence $A$ and the length of an increasing subsequence $G(A)$ constructed by a specific greedy algorithm.\n\nThe sequence is given as $A = (1,\\, 100,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200,\\, 2)$. The length of the sequence is $n=12$.\n\nFirst, we determine the length of the LIS of $A$.\nAn increasing subsequence is formed by picking elements from $A$ in order of their appearance, such that each picked element is strictly greater than the previous one. We seek an increasing subsequence of the maximum possible length.\nBy inspection, we can identify a long increasing subsequence. If we select the first element, $1$, we can then select the subsequence $(3, 4, 5, 6, 7, 8, 9, 10)$ and finally the element $200$. This gives the increasing subsequence $(1,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200)$. The elements are $a_1=1$, $a_3=3$, $a_4=4$, $\\dots$, $a_{10}=10$, $a_{11}=200$. The indices are $1  3  4  \\dots  10  11$, and the values are $1  3  4  \\dots  10  200$. The length of this subsequence is $10$.\nThe total length of sequence $A$ is $12$. An increasing subsequence cannot be longer than the sequence itself. Can we find an increasing subsequence of length $11$ or $12$? An increasing subsequence of length $12$ would require the sequence $A$ itself to be sorted, which it is not. An increasing subsequence of length $11$ could be formed by removing one element from $A$ to make the remaining sequence sorted. However, removing any single element does not make the remaining $11$ elements sorted. For example, removing $100$ leaves $(1, 3, \\dots, 10, 200, 2)$, which is not sorted because of the final $2$. Thus, the maximum possible length of an increasing subsequence is less than $11$.\nSince we have found an increasing subsequence of length $10$, and we have argued that no longer increasing subsequence exists, the length of the LIS is $10$.\nSo, $\\operatorname{length}(\\text{LIS of }A) = 10$.\n\nNext, we construct the subsequence $G(A)$ following the specified greedy algorithm.\nThe sequence is $A = (1,\\, 100,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200,\\, 2)$.\n1.  The algorithm starts with the globally minimal element of $A$. The minimum value in $A$ is $1$, which appears at the first position (index $1$). So, the first element of $G(A)$ is $1$. Let's denote the subsequence being built as $S$.\n    $S = (1)$. The last element added was $1$ from index $1$.\n\n2.  Next, we repeatedly append the smallest possible value to $S$ from the elements in $A$ that are strictly greater than the last chosen value and appear to its right.\n    The last element added to $S$ is $1$. The elements to the right of index $1$ in $A$ are $(100,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200,\\, 2)$.\n    We need to find the smallest value in this set of candidates that is strictly greater than $1$. All candidates are greater than $1$. The set of candidate values is $\\{100,\\, 3,\\, 4,\\, 5,\\, 6,\\, 7,\\, 8,\\, 9,\\, 10,\\, 200,\\, 2\\}$. The minimum among these values is $2$.\n    We append $2$ to our subsequence $S$. The element $2$ is at index $12$ in $A$.\n    $S = (1, 2)$. The last element added was $2$ from index $12$.\n\n3.  We repeat the process. The last element added to $S$ is $2$. We must look for elements in $A$ to the right of index $12$ that are strictly greater than $2$. Since the element $2$ is the last element of the sequence $A$ (at index $12$), there are no elements to its right.\n\n4.  The process terminates as no more elements can be appended.\nThe resulting subsequence is $G(A) = (1, 2)$.\n\nThe length of this subsequence is $2$.\nSo, $\\operatorname{length}(G(A)) = 2$.\n\nFinally, we compute the value of $d$:\n$$d = \\operatorname{length}(\\text{LIS of }A) - \\operatorname{length}(G(A))$$\n$$d = 10 - 2 = 8$$\nThe greedy strategy is \"myopic\" in that it chooses the smallest possible next value ($2$) without regard for its position in the sequence. By choosing $2$, which is located at the very end of $A$, it prematurely terminates the construction of the subsequence, leading to a result much shorter than the LIS.", "answer": "$$\\boxed{8}$$", "id": "3247982"}, {"introduction": "Having established the need for a robust algorithm, we now turn to the canonical $O(n \\log n)$ solution for the LIS problem. This practice [@problem_id:3247924] guides you through implementing this efficient method, which cleverly uses binary search to maintain candidate subsequences. You will also tackle a common real-world challenge by using coordinate compression to handle inputs with very large numerical values, demonstrating how to make the algorithm independent of the value range.", "problem": "Consider a finite sequence of integers $A = (A_1, A_2, \\dots, A_n)$ where each $A_i$ can be as large as $10^{18}$. The Longest Increasing Subsequence (LIS) is defined as the maximum length of a subsequence $A_{i_1} lt; A_{i_2} lt; \\dots lt; A_{i_k}$ with $1 \\le i_1 lt; i_2 lt; \\dots lt; i_k \\le n$. The task must be implemented using a coordinate-compressed representation of $A$ to avoid any dependence on the absolute magnitude of values. The fundamental base includes the definition of strictly increasing subsequence and the observation that order-preserving transformations of the value domain do not alter inequalities between elements.\n\nYour objectives are:\n- Derive why replacing $A$ by its coordinate-compressed sequence $C$ preserves the LIS length. Formally, construct a strictly increasing mapping $f$ from the sorted set of distinct values in $A$ to consecutive integers starting from $0$ and set $C_i = f(A_i)$. Explain why $A_{i} lt; A_{j}$ if and only if $C_{i} lt; C_{j}$ for all $i,j$, and therefore the LIS length is invariant under this transformation.\n- Implement an algorithm that computes the LIS length on the compressed sequence using a binary-search-based minimal-tail construction. Maintain an array of tails where $tails[\\ell]$ stores the smallest possible tail value in the compressed domain of any strictly increasing subsequence of length $\\ell+1$. For each $C_i$, perform a binary search over $tails$ to find the first index $\\ell$ such that $tails[\\ell] \\ge C_i$ and replace it with $C_i$, or append $C_i$ if no such $\\ell$ exists. Count the total number of element-to-element comparisons performed inside all binary searches; define one comparison as the evaluation of a predicate of the form $tails[m] \\ge C_i$, where $m$ is a midpoint index in the binary search.\n- Analyze corner cases where values are sparse versus dense and articulate how compression affects the number of binary search steps through its effect on the evolving length of the $tails$ array. Your program must report, for each test case, both the LIS length and the cumulative count of comparisons executed inside all binary searches.\n\nUse the following test suite of sequences, crafted to cover a happy path, boundary conditions, and significant edge cases (sparse versus dense, duplicates, monotonic sequences, and empty input). For each case, the sequence is given explicitly:\n1. Sparse high-magnitude interleaving: $[10^{18}-3,\\;1,\\;10^{18}-2,\\;2,\\;10^{18}-1,\\;3]$.\n2. Dense small increasing: $[1,\\;2,\\;3,\\;4,\\;5,\\;6,\\;7,\\;8,\\;9]$.\n3. All equal large: $[10^{18},\\;10^{18},\\;10^{18},\\;10^{18},\\;10^{18}]$.\n4. Strictly decreasing large: $[10^{18},\\;10^{18}-1,\\;10^{18}-2,\\;10^{18}-3,\\;10^{18}-4,\\;10^{18}-5,\\;10^{18}-6,\\;10^{18}-7]$.\n5. Alternating duplicates and growth: $[10^{18}-5,\\;5,\\;10^{18}-5,\\;6,\\;10^{18}-4,\\;7,\\;10^{18}-3,\\;8]$.\n6. Dense with duplicates near large values: $[10^{18}-10,\\;10^{18}-9,\\;10^{18}-9,\\;10^{18}-8,\\;10^{18}-7,\\;10^{18}-7,\\;10^{18}-6,\\;10^{18}-5]$.\n7. Boundary empty sequence: $[]$.\n\nFor each test case $A$, the required outputs are:\n- The LIS length, an integer.\n- The total number of comparisons in all binary searches, an integer.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test caseâ€™s result is itself a two-element list $[\\text{lis\\_length},\\;\\text{comparison\\_count}]$. For example, an output with two test cases would look like $[[3,7],[5,9]]$. No physical units, angles, or percentages are involved; all outputs are integers.", "solution": "### 1. Invariance of LIS Length under Coordinate Compression\n\nThe core of the problem is to compute the longest increasing subsequence (LIS) of a sequence of integers $A = (A_1, A_2, \\dots, A_n)$. The values $A_i$ can be very large, up to $10^{18}$, but their absolute magnitude is irrelevant; only their relative order matters for determining an increasing subsequence. This property is the foundation for using coordinate compression.\n\nLet $V$ be the set of unique values present in the sequence $A$. We can sort these unique values to obtain an ordered set $v_1  v_2  \\dots  v_m$, where $m \\le n$ is the number of unique elements.\n\nCoordinate compression is the process of defining a mapping $f$ that transforms the original values in $A$ to a smaller, consecutive range of integers. We define the mapping $f: \\{v_1, \\dots, v_m\\} \\to \\{0, 1, \\dots, m-1\\}$ as:\n$$f(v_j) = j-1$$\nThis function maps the smallest unique value $v_1$ to $0$, the second smallest $v_2$ to $1$, and so on. The function $f$ is strictly increasing because if $v_j  v_k$, then by their sorted order, the index $j$ must be less than $k$, which implies $f(v_j) = j-1  k-1 = f(v_k)$.\n\nThe compressed sequence $C$ is then constructed by applying this mapping to each element of $A$:\n$$C_i = f(A_i) \\quad \\text{for } i=1, \\dots, n$$\n\nWe must now prove that the LIS length is invariant under this transformation. This requires showing that the relative order of any two elements is preserved. That is, for any indices $i$ and $j$:\n$$A_i  A_j \\iff C_i  C_j$$\n\n**Proof:**\n1.  **Forward direction ($\\implies$):** Assume $A_i  A_j$. Since $A_i$ and $A_j$ are elements from the set of unique values $V$, let $A_i = v_p$ and $A_j = v_q$ for some indices $p, q \\in \\{1, \\dots, m\\}$. The condition $A_i  A_j$ implies $v_p  v_q$. Because the values $v_k$ are sorted, this means their indices must satisfy $p  q$. By the definition of our mapping $f$, we have $C_i = f(A_i) = f(v_p) = p-1$ and $C_j = f(A_j) = f(v_q) = q-1$. Since $p  q$, it follows that $p-1  q-1$, and therefore $C_i  C_j$.\n\n2.  **Backward direction ($\\impliedby$):** Assume $C_i  C_j$. By definition of $C$, this means $f(A_i)  f(A_j)$. Since the mapping $f$ is strictly increasing, its inverse $f^{-1}$ must also be strictly increasing. Applying $f^{-1}$ to both sides of the inequality $f(A_i)  f(A_j)$ yields $f^{-1}(f(A_i))  f^{-1}(f(A_j))$, which simplifies to $A_i  A_j$.\n\nSince the strict inequality relationship is preserved for any pair of elements, a subsequence $(A_{i_1}, A_{i_2}, \\dots, A_{i_k})$ is strictly increasing if and only if the corresponding compressed subsequence $(C_{i_1}, C_{i_2}, \\dots, C_{i_k})$ is strictly increasing. Consequently, the set of all increasing subsequences in $A$ is in one-to-one correspondence with the set of all increasing subsequences in $C$. This proves that the length of the longest increasing subsequence is invariant under coordinate compression.\n\n### 2. Algorithmic Implementation\n\nThe LIS of the compressed sequence $C$ can be computed efficiently in $O(n \\log n)$ time. The algorithm maintains an auxiliary array, which we will call `tails`. The array `tails` stores the smallest tail (last element) of all increasing subsequences of a given length. Specifically, `tails[k]` will hold the smallest value that can terminate an increasing subsequence of length $k+1$. By construction, the `tails` array will always be sorted in increasing order.\n\nThe algorithm proceeds as follows:\n1.  Initialize an empty list `tails` and a counter for comparisons `total_comparisons = 0`.\n2.  For each element $c$ in the compressed sequence $C$:\n    a. Perform a binary search on the `tails` array to find the index `j` of the first element that is greater than or equal to $c$. The problem defines a comparison as the evaluation of the predicate `tails[m] >= c`, where `m` is a midpoint index in the binary search. The number of such evaluations for the current step is tallied and added to `total_comparisons`.\n    b. If such an element is found at index `j`, it means we have found an increasing subsequence of length $j+1$ that ends with $c$. Since $c \\le \\text{tails}[j]$, this new subsequence has a smaller or equal tail compared to the previous one of the same length. We update `tails[j] = c` to reflect this potentially better subsequence.\n    c. If no such element is found (i.e., $c$ is greater than all elements in `tails`), it means we can extend the longest increasing subsequence found so far. We append $c$ to the `tails` array, effectively creating a new, longer LIS.\n3.  After iterating through all elements of $C$, the length of the `tails` array is the length of the LIS of $C$, and thus of $A$.\n\n### 3. Analysis of Corner Cases\n\nThe problem asks to analyze how sparsity versus density of values affects the number of binary search steps.\n\nCoordinate compression transforms the input values, regardless of their original sparsity (e.g., $[10, 10^{18}]$) or density (e.g., $[10, 11]$), into a compact set of consecutive integers $\\{0, 1, \\dots, m-1\\}$. Therefore, the sparsity of the original values has no direct impact on the performance of the LIS algorithm *after* compression. The complexity of the compression step itself is $O(n \\log n)$ due to sorting the unique elements.\n\nThe number of comparisons performed by the binary searches depends on two factors:\n1.  The number of elements in the sequence, $n$.\n2.  The rate at which the length of the `tails` array grows.\n\nThe growth of the `tails` array is determined by the structure of the compressed sequence $C$, not the range of its values.\n-   **Strictly Increasing Sequence (e.g., Test Case 2):** For a sequence like $[1, 2, \\dots, 9]$, after compression we get $[0, 1, \\dots, 8]$. Each element is greater than all previous elements, so it will always be appended to `tails`. The length of `tails` increases by one at each step. The total number of comparisons will be the sum of comparisons for binary searches on arrays of sizes $0, 1, 2, \\dots, n-1$. This leads to approximately $\\sum_{k=1}^{n-1} \\log_2(k)$ comparisons, which is $O(n \\log n)$.\n-   **Strictly Decreasing Sequence (e.g., Test Case 4):** For a sequence like $[100, 99, \\dots, 93]$, after compression we get $[7, 6, \\dots, 0]$. The first element initializes `tails` to length $1$. Every subsequent element is smaller than the current element in `tails`, so it will replace `tails[0]`. The `tails` array never grows beyond length $1$. The binary search at each step (after the first) is on an array of size $1$, taking a constant number of comparisons (typically one). The total comparisons will be $O(n)$.\n-   **Sequence with Duplicates (e.g., Test Case 3):** For a sequence of identical values, like $[10^{18}, \\dots, 10^{18}]$, the compressed sequence is $[0, 0, \\dots, 0]$. The first $0$ initializes `tails=[0]`. Every subsequent $0$ will be found to be equal to `tails[0]`, leading to the update `tails[0] = 0`. The `tails` array never grows, and the LIS length is $1$. The total comparisons will be $O(n)$, similar to the decreasing case.\n\nIn summary, coordinate compression standardizes the value domain, making the performance of the LIS algorithm dependent only on the length and relative order of the sequence elements, not on the magnitude or spacing of the original numbers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the LIS problem for a predefined test suite.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        [10**18 - 3, 1, 10**18 - 2, 2, 10**18 - 1, 3], # 1. Sparse high-magnitude interleaving\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],                     # 2. Dense small increasing\n        [10**18, 10**18, 10**18, 10**18, 10**18],       # 3. All equal large\n        [10**18, 10**18 - 1, 10**18 - 2, 10**18 - 3, 10**18 - 4, 10**18 - 5, 10**18 - 6, 10**18 - 7], # 4. Strictly decreasing large\n        [10**18 - 5, 5, 10**18 - 5, 6, 10**18 - 4, 7, 10**18 - 3, 8], # 5. Alternating duplicates and growth\n        [10**18 - 10, 10**18 - 9, 10**18 - 9, 10**18 - 8, 10**18 - 7, 10**18 - 7, 10**18 - 6, 10**18 - 5], # 6. Dense with duplicates near large values\n        [],                                               # 7. Boundary empty sequence\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_lis_with_stats(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    # e.g., [[3, 7], [5, 9]]\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_lis_with_stats(A):\n    \"\"\"\n    Computes the LIS length and total binary search comparisons for a sequence.\n\n    Args:\n        A (list): A list of integers.\n\n    Returns:\n        list: A list containing [lis_length, total_comparisons].\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return [0, 0]\n\n    # Step 1: Coordinate Compression\n    unique_vals = np.unique(A)\n    val_to_rank = {val: i for i, val in enumerate(unique_vals)}\n    C = [val_to_rank[val] for val in A]\n\n    # Step 2: LIS with binary search and comparison counting\n    tails = []\n    total_comparisons = 0\n\n    for c_val in C:\n        # Custom binary search (lower_bound) to count comparisons.\n        # A comparison is defined as `tails[m] >= c_val`.\n        lo, hi = 0, len(tails)\n        num_comps_this_step = 0\n        \n        while lo  hi:\n            mid = lo + (hi - lo) // 2\n            num_comps_this_step += 1\n            if tails[mid] >= c_val:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        total_comparisons += num_comps_this_step\n        \n        idx = lo\n        if idx == len(tails):\n            tails.append(c_val)\n        else:\n            tails[idx] = c_val\n    \n    lis_length = len(tails)\n    return [lis_length, total_comparisons]\n\n# Execute the main function.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3247924"}, {"introduction": "Once you have mastered finding the length of the LIS, a natural next question is: how many such subsequences exist? This advanced problem [@problem_id:3247972] challenges you to extend the dynamic programming approach to count the number of distinct longest increasing subsequences. To maintain the $O(n \\log n)$ efficiency, you will explore how to use a more sophisticated data structure to aggregate not just lengths, but also counts from preceding subproblems.", "problem": "You are given a finite sequence of integers $A = (A_1, A_2, \\dots, A_n)$ of length $n$. A subsequence of $A$ is any sequence $(A_{i_1}, A_{i_2}, \\dots, A_{i_k})$ where $1 \\le i_1  i_2  \\dots  i_k \\le n$. A subsequence is strictly increasing if $A_{i_1}  A_{i_2}  \\dots  A_{i_k}$. The Longest Increasing Subsequence (LIS) is any strictly increasing subsequence with maximum possible length; denote this maximum length by $L$. Two subsequences are considered distinct if their index sequences $(i_1, i_2, \\dots, i_k)$ differ in at least one position. The task is to count the number of distinct LIS subsequences of maximum length $L$.\n\nStarting only from the definition of a strictly increasing subsequence and the notion of a maximum over preceding indices satisfying strict inequality, design an algorithm and justify its correctness that computes both the maximum length $L$ and the count of distinct LIS subsequences of that length, for any input sequence $A$. Your algorithm must achieve time complexity $O(n \\log n)$ and use coordinate compression to handle $A$ values drawn from an arbitrary integer domain. Your design must explicitly address how duplicates in $A$ (that is, positions $p \\ne q$ with $A_p = A_q$) are handled so that strictly increasing comparisons $A_{i}  A_{j}$ are enforced and no double counting occurs. The algorithm must be derived from first principles (definitions of subsequences and maxima under strict inequality), and your data structure must be justified by a property that lets you combine results from value ranges efficiently while preserving counts.\n\nImplement the algorithm as a complete, runnable program that internally computes answers for the following test suite. For each test one-dimensional array $A$, the expected output per test is a list of two integers $[L, C]$, where $L$ is the LIS length and $C$ is the number of distinct LIS subsequences of length $L$:\n- Test $1$: $A = [1,2,3,4]$ (a general increasing case).\n- Test $2$: $A = [4,3,2,1]$ (a strictly decreasing boundary case).\n- Test $3$: $A = [2,2,2]$ (all elements equal, duplicates-heavy boundary case).\n- Test $4$: $A = [1,3,5,4,7]$ (a mixed case with multiple LIS and no equal-adjacent transitions).\n- Test $5$: $A = [3,1,2,1,2,3]$ (a mixed case with duplicates at multiple values).\n- Test $6$: $A = [1,2,2,3,3,4]$ (a case where duplicates multiply the number of maximum-length choices).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test in the same order as above. Each element must be a list of two integers $[L, C]$. For example, an output for three tests would have the overall shape $[[L_1,C_1],[L_2,C_2],[L_3,C_3]]$. The program must not read input; it must compute the results for the given test suite and print them directly. No physical units, angle units, or percentage representations are involved in this problem; all outputs are integers.", "solution": "The problem asks for an algorithm to find both the length, $L$, of the Longest Increasing Subsequence (LIS) of a given integer sequence $A = (A_1, A_2, \\dots, A_n)$, and the number of distinct such subsequences, $C$. The algorithm must have a time complexity of $O(n \\log n)$.\n\nLet us first develop a solution from first principles using dynamic programming. For each element $A_i$ in the sequence, we are interested in the properties of strictly increasing subsequences that end at this element. We define two quantities for each index $i \\in \\{1, \\dots, n\\}$:\n1.  $L_i$: The length of the longest strictly increasing subsequence ending with the element $A_i$.\n2.  $C_i$: The number of distinct such subsequences of length $L_i$ that end with $A_i$.\n\nTo compute $L_i$ for an element $A_i$, we must extend an existing increasing subsequence. An increasing subsequence ending at some $A_j$ with $j  i$ can be extended by $A_i$ if and only if $A_j  A_i$. The length of the resulting subsequence would be $L_j + 1$. To maximize the length $L_i$, we must choose the longest possible subsequence to extend. This leads to the recurrence relation for $L_i$:\n$$L_i = 1 + \\max(\\{L_j \\mid j  i \\text{ and } A_j  A_i\\} \\cup \\{0\\})$$\nThe base case, where no such $j$ exists (the set is empty), is handled by the $\\max$ with $\\{0\\}$, resulting in $L_i = 1$. This corresponds to the subsequence consisting only of $A_i$.\n\nTo compute $C_i$, we count how many ways we can form an increasing subsequence of length $L_i$ ending at $A_i$. Each such subsequence is formed by appending $A_i$ to an increasing subsequence of length $L_i - 1$ ending at some $A_j$ where $j  i$ and $A_j  A_i$. To get the total count $C_i$, we must sum the counts $C_j$ for all such valid preceding subsequences. This yields the recurrence for $C_i$:\n$$C_i = \\sum \\{C_j \\mid j  i, A_j  A_i, \\text{ and } L_j = L_i - 1\\}$$\nIf no such $j$ exists (i.e., $L_i = 1$), the count $C_i$ is $1$, for the subsequence $(A_i)$ itself.\n\nAfter computing $(L_i, C_i)$ for all $i = 1, \\dots, n$, the overall LIS length $L$ is the maximum value among all $L_i$: $L = \\max_{i=1}^n L_i$. The total count $C$ is the sum of counts $C_i$ for all indices $i$ where the length $L_i$ equals the maximum length $L$: $C = \\sum \\{C_i \\mid L_i = L\\}$.\n\nA direct implementation of these recurrences involves, for each $i$, iterating through all $j  i$, leading to an $O(n^2)$ time complexity. To achieve the required $O(n \\log n)$ complexity, we must optimize the process of finding the maximum length and corresponding count sum. For each element $A_i$, the computation requires querying the aggregated information for all processed elements $A_j$ with values $A_j  A_i$. This is a prefix query problem on the values of the elements.\n\nThe values in $A$ can be from an arbitrary integer domain. To handle this efficiently, we employ coordinate compression. We identify all unique values in $A$, sort them, and assign each value a rank from $0$ to $m-1$, where $m$ is the number of unique values. This maps the problem into a compact integer range, making it suitable for data structures indexed by these ranks. The sorting step for coordinate compression takes $O(n \\log n)$ time.\n\nThe core of the optimization is a data structure that can efficiently perform the required queries. We need a structure that, for any rank $r$, can return the aggregated $(L, C)$ pair for all subsequences ending in elements with ranks less than $r$. A segment tree is an appropriate choice. The key insight is that the process of combining results from different value ranges is associative. Let's define a `combine` operation on two pairs $(L_1, C_1)$ and $(L_2, C_2)$:\n$$ \\text{combine}((L_1, C_1), (L_2, C_2)) =\n\\begin{cases}\n(L_1, C_1)  \\text{if } L_1  L_2 \\\\\n(L_2, C_2)  \\text{if } L_2  L_1 \\\\\n(L_1, C_1 + C_2)  \\text{if } L_1 = L_2\n\\end{cases}\n$$\nThis operation is associative, allowing a segment tree to efficiently compute range queries.\n\nThe algorithm using a segment tree proceeds as follows:\n1.  **Preprocessing**: Perform coordinate compression on $A$. Let $m$ be the number of unique values. This gives a mapping from each value to a rank in $[0, m-1]$.\n2.  **Data Structure**: Create a segment tree over the range of ranks $[0, m-1]$. Each leaf of the tree corresponds to a rank and stores an aggregate $(L, C)$ pair. Internal nodes store the `combine`d result of their children. All nodes are initialized to $(0, 0)$, which serves as the identity for the `combine` operation.\n3.  **Main Loop**: Iterate through each element $A_i$ of the sequence. For each $A_i$:\n    a. Let $r$ be the rank of $A_i$.\n    b. Query the segment tree for the range $[0, r-1]$. This query takes $O(\\log m)$ time and returns the pair $(L_{prev}, C_{prev})$, representing the maximal length and corresponding count for all increasing subsequences ending in a value strictly smaller than $A_i$.\n    c. Based on the query result, compute the new pair for subsequences ending at $A_i$. If $L_{prev}=0$, no such smaller predecessor exists, so we have a new LIS of length $1$, giving $(L_{new}, C_{new}) = (1, 1)$. Otherwise, we extend the found subsequences, giving $(L_{new}, C_{new}) = (L_{prev} + 1, C_{prev})$.\n    d. Update the segment tree. An element $A_i$ contributes a new set of subsequences of length $L_{new}$ with count $C_{new}$ that end with value $A_i$ (rank $r$). If other elements with the same value have already been processed, we must aggregate their contributions. A point update on the segment tree at rank $r$ handles this. We retrieve the current pair $(L_{curr}, C_{curr})$ stored for rank $r$, combine it with our new pair $(L_{new}, C_{new})$, and update the leaf for rank $r$ with the result. This point update takes $O(\\log m)$ time.\n4.  **Final Result**: After iterating through all $n$ elements, the root of the segment tree contains the aggregated $(L, C)$ pair over the entire range of ranks $[0, m-1]$. This pair is the final answer $(L, C)$.\n\nThe explicit handling of duplicates is embedded in this process. Two elements $A_p = A_q$ have the same rank. When processing the second occurrence, say at index $q  p$, the query for ranks smaller than $A_q$'s rank ensures we only consider extending subsequences ending with strictly smaller values, upholding the problem's definition. The update step at the same rank correctly accumulates the counts. For example, if two separate elements $A_p$ and $A_q$ (with $p \\ne q$) both create LISs of length $k$ and count $c_1$ and $c_2$ respectively, and both can be extended by a later element $A_r$, the total number of ways to form a LIS of length $k+1$ ending at $A_r$ will correctly sum up these counts as $c_1+c_2$.\n\nThe total time complexity is dominated by coordinate compression ($O(n \\log n)$) and the main loop, which performs $n$ iterations, each taking $O(\\log m)$ for segment tree operations. Since $m \\le n$, the total complexity is $O(n \\log n)$. The space complexity is $O(m)$ for the coordinate compression map and the segment tree, which is $O(n)$ in the worst case. This design meets all problem requirements.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the number of longest increasing subsequences problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2],\n        [1, 3, 5, 4, 7],\n        [3, 1, 2, 1, 2, 3],\n        [1, 2, 2, 3, 3, 4]\n    ]\n\n    def combine(p1, p2):\n        \"\"\"Combines two (length, count) pairs.\"\"\"\n        l1, c1 = p1\n        l2, c2 = p2\n        if l1 > l2:\n            return p1\n        if l2 > l1:\n            return p2\n        return (l1, c1 + c2)\n\n    class SegmentTree:\n        \"\"\"\n        Segment Tree for range queries with a custom combine operation.\n        \"\"\"\n        def __init__(self, size):\n            self.size = size\n            self.tree = [(0, 0)] * (4 * size)\n\n        def _update(self, node, start, end, idx, val):\n            if start == end:\n                self.tree[node] = combine(self.tree[node], val)\n                return\n\n            mid = (start + end) // 2\n            if start = idx = mid:\n                self._update(2 * node, start, mid, idx, val)\n            else:\n                self._update(2 * node + 1, mid + 1, end, idx, val)\n            \n            self.tree[node] = combine(self.tree[2 * node], self.tree[2 * node + 1])\n\n        def update(self, idx, val):\n            self._update(1, 0, self.size - 1, idx, val)\n\n        def _query(self, node, start, end, l, r):\n            if r  start or end  l or l > r:\n                return (0, 0)\n            if l = start and end = r:\n                return self.tree[node]\n            \n            mid = (start + end) // 2\n            p1 = self._query(2 * node, start, mid, l, r)\n            p2 = self._query(2 * node + 1, mid + 1, end, l, r)\n            \n            return combine(p1, p2)\n\n        def query(self, l, r):\n            return self._query(1, 0, self.size - 1, l, r)\n            \n        def get_total_lis(self):\n            return self.tree[1]\n\n    def calculate_lis_count(A):\n        \"\"\"\n        Calculates the length and count of LIS for a single sequence A.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return [0, 0]\n\n        # Coordinate Compression\n        unique_vals = sorted(list(set(A)))\n        m = len(unique_vals)\n        rank_map = {val: i for i, val in enumerate(unique_vals)}\n\n        # Segment Tree initialized for the range of ranks\n        st = SegmentTree(m)\n\n        for x in A:\n            r = rank_map[x]\n            \n            # Query for LIS ending in values smaller than x\n            # Query range of ranks is [0, r-1]\n            if r > 0:\n                l_prev, c_prev = st.query(0, r - 1)\n            else:\n                l_prev, c_prev = 0, 0\n\n            # Calculate new LIS pair for current element\n            if l_prev == 0:\n                # No smaller element seen, start a new LIS of length 1\n                new_pair = (1, 1)\n            else:\n                new_pair = (l_prev + 1, c_prev)\n            \n            # Update the segment tree at rank r with the new information\n            st.update(r, new_pair)\n            \n        # The root of the segment tree holds the final aggregated result\n        l_final, c_final = st.get_total_lis()\n        \n        return [l_final, c_final]\n        \n    results = []\n    for case in test_cases:\n        result = calculate_lis_count(case)\n        results.append(result)\n\n    # Format the entire output as a single string\n    formatted_results = \",\".join([str(r) for r in results])\n    print(f\"[{formatted_results.replace(' ', '')}]\")\n\nsolve()\n\n```", "id": "3247972"}]}