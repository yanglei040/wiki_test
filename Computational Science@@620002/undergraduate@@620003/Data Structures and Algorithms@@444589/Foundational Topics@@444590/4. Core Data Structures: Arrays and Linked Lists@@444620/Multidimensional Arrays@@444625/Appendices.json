{"hands_on_practices": [{"introduction": "This practice explores the fundamental task of in-place matrix rotation. Beyond being a common interview question, this exercise provides deep insights into how to manipulate array indices directly and efficiently, without allocating extra memory. By decomposing the rotation into a series of four-element cycles, you will gain a hands-on understanding of permutation cycles and how to process a matrix layer-by-layer [@problem_id:3254560].", "problem": "Given a square Two-Dimensional (2D) array interpreted as an $n \\times n$ grid indexed from $0$ to $n-1$ in both dimensions, design and implement an in-place algorithm that rotates the array by $90$ degrees clockwise, measured in degrees. The algorithm must proceed layer-by-layer, performing four-element cycles without allocating another array, and may use a single temporary variable to hold an element during a four-way swap. Use the following fundamental base: indices, permutations, and cycle decompositions induced by the mapping from original coordinates to rotated coordinates.\n\nDefine a \"write\" operation as any assignment of a value into an array cell $A[i][j]$. For analysis, define the following metrics:\n- The total number of array writes performed by your in-place algorithm.\n- The number of distinct elements whose final index differs from their initial index (the \"moved element count\").\n- The total Manhattan displacement, defined as the sum over all cells of the Manhattan distance between the original index $(i,j)$ and its rotated index $(j, n-1-i)$, that is $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right)$.\n\nYour program must:\n1. Construct each test matrix $A$ of size $n \\times n$ with entries $A[i][j] = i \\cdot n + j$ for $0 \\le i,j < n$.\n2. Rotate $A$ in-place by $90$ degrees clockwise via layer-by-layer four-element cycles, counting the exact number of array writes as defined above.\n3. Compute the number of four-element cycles executed by the layer-by-layer algorithm.\n4. Compute the moved element count using only the mapping $(i,j) \\mapsto (j, n-1 - i)$ and index logic.\n5. Compute the total Manhattan displacement $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right)$.\n6. Derive, justify, and implement a closed-form expression for the number of writes as a function of $n$, and verify that the measured write count matches this expression. Also derive and verify a closed-form expression for the total Manhattan displacement as a function of $n$.\n7. Output, for each test case, the following list in order:\n   - The rotated array flattened in row-major order as a list of integers.\n   - The total number of writes (an integer).\n   - The total number of four-element cycles executed (an integer).\n   - The moved element count (an integer).\n   - A boolean indicating whether the measured write count matches your derived closed-form expression for writes.\n   - The total Manhattan displacement (an integer).\n   - A boolean indicating whether the measured Manhattan displacement matches your derived closed-form expression for displacement.\n\nAngle unit specification: use degrees. No physical units are involved. All outputs must be unitless integer or boolean types, except for the flattened array which is a list of integers.\n\nTest suite specification:\n- Use $n$ values $n \\in \\{1,2,3,4,5\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the exact order described above. For example, the final output must be of the form $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_k]$, where each $\\text{result}_t$ is a list corresponding to one test case.", "solution": "The user's problem is to design, implement, and analyze an in-place algorithm for rotating a square $n \\times n$ matrix by $90$ degrees clockwise. The problem is well-posed, scientifically grounded, and provides sufficient detail for a unique and verifiable solution.\n\n### 1. The Rotational Transformation as a Permutation\nA $90$-degree clockwise rotation of an $n \\times n$ grid maps an element at an initial coordinate $(i, j)$ to a final coordinate $(i', j')$. The transformation rule is given by:\n$$ T: (i, j) \\mapsto (i', j') = (j, n-1-i) $$\nwhere indices $i, j, i', j'$ range from $0$ to $n-1$. This transformation $T$ is a permutation on the set of $n^2$ index pairs. To understand the structure of this permutation, we analyze its cycle decomposition. Applying the transformation four times yields:\n1.  $T(i, j) = (j, n-1-i)$\n2.  $T^2(i, j) = T(j, n-1-i) = (n-1-i, n-1-j)$\n3.  $T^3(i, j) = T(n-1-i, n-1-j) = (n-1-j, n-1-(n-1-i)) = (n-1-j, i)$\n4.  $T^4(i, j) = T(n-1-j, i) = (i, n-1-(n-1-j)) = (i, j)$\n\nSince $T^4$ is the identity transformation, all cycles in this permutation have a length that divides $4$, i.e., lengths $1$, $2$, or $4$.\n- A cycle of length $1$ is a fixed point, where $T(i, j) = (i, j)$. This requires $(i, j) = (j, n-1-i)$, which implies $i=j$ and $i = n-1-i$, or $2i = n-1$. An integer solution for $i$ exists if and only if $n-1$ is even, meaning $n$ is odd. If $n$ is odd, the unique fixed point is the center of the matrix at $(\\frac{n-1}{2}, \\frac{n-1}{2})$. If $n$ is even, there are no fixed points.\n- A cycle of length $2$ would require $T^2(i, j) = (i, j)$ but $T(i, j) \\neq (i, j)$. This implies $(n-1-i, n-1-j) = (i, j)$, so $i = n-1-i$ and $j=n-1-j$, giving $2i = n-1$ and $2j = n-1$. This implies that a cycle of length $2$ can only exist if $n$ is odd, and it would involve the center element, which is a fixed point. Therefore, there are no cycles of length $2$.\n\nThus, the permutation consists exclusively of $4$-element cycles and, if $n$ is odd, one $1$-element cycle (a fixed point).\n\n### 2. In-Place Algorithm: Layer-by-Layer Cycle Swaps\nThe problem mandates an in-place algorithm that proceeds layer-by-layer. An $n \\times n$ matrix contains $\\lfloor n/2 \\rfloor$ concentric square \"layers\". Let the outermost layer be layer $k=0$, the next one be $k=1$, and so on, up to $k = \\lfloor n/2 \\rfloor - 1$.\n\nFor each layer $k$, we can iterate along its top edge to identify the distinct $4$-element cycles. The elements on the top edge of layer $k$ are at coordinates $(k, j)$ where $j$ ranges from $k$ to $n-1-k$. To avoid processing each cycle four times, we only initiate a cycle swap for elements on the top edge, excluding the last element (which is part of a cycle initiated by an element on the left edge). We iterate $j$ from $k$ to $n-2-k$. This gives $n-2k-1$ cycles for layer $k$.\n\nFor each starting element at $(k, j)$, the four elements in its cycle are:\n- $p_1 = (k, j)$\n- $p_2 = (j, n-1-k)$\n- $p_3 = (n-1-k, n-1-j)$\n- $p_4 = (n-1-j, k)$\n\nA four-way swap to achieve the rotation $v_1 \\to p_2, v_2 \\to p_3, v_3 \\to p_4, v_4 \\to p_1$ can be implemented with one temporary variable and four array writes:\n1.  `temp = A[p_1]`\n2.  `A[p_1] = A[p_4]` (Write 1)\n3.  `A[p_4] = A[p_3]` (Write 2)\n4.  `A[p_3] = A[p_2]` (Write 3)\n5.  `A[p_2] = temp` (Write 4)\n\n### 3. Derivation of Closed-Form Expressions\n\n#### Number of Cycles and Writes\nThe number of $4$-element cycles for layer $k$ is $n-2k-1$. The total number of cycles is the sum over all layers:\n$$ \\text{Cycles} = \\sum_{k=0}^{\\lfloor n/2 \\rfloor - 1} (n - 2k - 1) $$\nLet $m = \\lfloor n/2 \\rfloor$. The sum is $\\sum_{k=0}^{m-1} (n-1) - 2\\sum_{k=0}^{m-1} k = m(n-1) - 2\\frac{(m-1)m}{2} = m(n-1 - (m-1)) = m(n-m)$.\n- If $n$ is even, $n=2p$, then $m=p$. Cycles = $p(2p-p) = p^2 = (n/2)^2 = n^2/4$.\n- If $n$ is odd, $n=2p+1$, then $m=p$. Cycles = $p(2p+1-p) = p(p+1) = \\frac{n-1}{2}(\\frac{n+1}{2}) = \\frac{n^2-1}{4}$.\nA single expression for the number of cycles is $\\lfloor n^2/4 \\rfloor$.\n\nSince each cycle requires $4$ writes, the total number of writes is:\n$$ \\text{Writes} = 4 \\times \\lfloor n^2/4 \\rfloor $$\n- If $n$ is even, Writes = $4 \\times (n^2/4) = n^2$.\n- If $n$ is odd, Writes = $4 \\times ((n^2-1)/4) = n^2-1$.\n\n#### Moved Element Count\nAn element moves if it is not a fixed point of the rotation. As established, a single fixed point exists if and only if $n$ is odd. The total number of elements is $n^2$.\n- If $n$ is even, there are $0$ fixed points. All $n^2$ elements move.\n- If $n$ is odd, there is $1$ fixed point. The remaining $n^2-1$ elements move.\nThe count of moved elements is therefore $n^2$ (for even $n$) or $n^2-1$ (for odd $n$). This is identical to the total number of writes.\n\n#### Total Manhattan Displacement\nThe total Manhattan displacement is defined as:\n$$ D(n) = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right) $$\nThis sum can be split:\n$$ D(n) = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j| + \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |j - (n-1 - i)| $$\nLet's analyze the second term. By setting $k = n-1-i$, as $i$ ranges from $0$ to $n-1$, $k$ ranges from $n-1$ to $0$. The sum is independent of the order of summation.\n$$ \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |j - (n-1 - i)| = \\sum_{k=0}^{n-1} \\sum_{j=0}^{n-1} |j - k| $$\nThis is identical to the first term. Therefore, $D(n) = 2 \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j|$.\nThe inner sum for a fixed $i$ is $\\sum_{j=0}^{n-1} |i-j| = \\sum_{j=0}^{i-1} (i-j) + \\sum_{j=i+1}^{n-1} (j-i) = \\frac{i(i+1)}{2} + \\frac{(n-1-i)(n-i)}{2}$.\nSumming this over all $i$:\n$$ \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j| = \\sum_{i=0}^{n-1} \\left( \\frac{i(i+1)}{2} \\right) + \\sum_{i=0}^{n-1} \\left( \\frac{(n-1-i)(n-i)}{2} \\right) $$\nThe two sums on the right are equivalent. So the total is $2 \\sum_{i=0}^{n-1} \\frac{i(i+1)}{2} = \\sum_{i=0}^{n-1} (i^2+i) = \\sum_{i=0}^{n-1} i^2 + \\sum_{i=0}^{n-1} i$.\nUsing the formulas for sums of powers, for sums up to $n-1$:\n$$ \\sum_{i=0}^{n-1} i = \\frac{(n-1)n}{2} \\quad \\text{and} \\quad \\sum_{i=0}^{n-1} i^2 = \\frac{(n-1)n(2n-1)}{6} $$\nThe sum $\\sum_{i,j} |i-j|$ becomes:\n$$ \\frac{(n-1)n(2n-1)}{6} + \\frac{(n-1)n}{2} = \\frac{n(n-1)}{6} ( (2n-1) + 3) = \\frac{n(n-1)(2n+2)}{6} = \\frac{n(n-1)2(n+1)}{6} = \\frac{n(n^2-1)}{3} $$\nFinally, the total Manhattan displacement is:\n$$ D(n) = 2 \\times \\frac{n(n^2-1)}{3} = \\frac{2n(n^2-1)}{3} $$\nThe product $n(n-1)(n+1)$ is a product of three consecutive integers, which is always divisible by $3! = 6$. Therefore, $D(n)$ is always an integer.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the matrix rotation problem for the specified test cases.\n    \"\"\"\n    test_cases_n = [1, 2, 3, 4, 5]\n    all_results = []\n\n    for n in test_cases_n:\n        # 1. Construct the matrix A\n        A = np.arange(n * n, dtype=np.int64).reshape((n, n))\n\n        # 6. Derive closed-form expressions\n        # Number of 4-element cycles\n        closed_form_cycles = n**2 // 4\n        \n        # Total number of writes\n        if n % 2 == 0:\n            closed_form_writes = n**2\n        else:\n            closed_form_writes = n**2 - 1\n            \n        # Total Manhattan displacement\n        closed_form_displacement = (2 * n * (n**2 - 1)) // 3\n\n        # 2. Rotate A in-place and count writes\n        measured_writes = 0\n        num_layers = n // 2\n        for k in range(num_layers):\n            # Iterate through elements on one side of the layer k to start cycles\n            for j in range(k, n - 1 - k):\n                # Cycle positions\n                p1 = (k, j)\n                p2 = (j, n - 1 - k)\n                p3 = (n - 1 - k, n - 1 - j)\n                p4 = (n - 1 - j, k)\n                \n                # Perform 4-way swap using a temporary variable\n                temp = A[p1]\n                A[p1] = A[p4]\n                A[p4] = A[p3]\n                A[p3] = A[p2]\n                A[p2] = temp\n                \n                # Each swap involves 4 write operations as defined\n                measured_writes += 4\n        \n        # 3. Compute the number of four-element cycles\n        # Since each cycle involves 4 writes, we can calculate this from the write count.\n        measured_cycles = measured_writes // 4\n\n        # 4. Compute the moved element count\n        moved_element_count = 0\n        for i in range(n):\n            for j in range(n):\n                # The mapping is (i, j) -> (j, n-1-i)\n                rot_i, rot_j = j, n - 1 - i\n                if i != rot_i or j != rot_j:\n                    moved_element_count += 1\n        \n        # 5. Compute the total Manhattan displacement\n        measured_displacement = 0\n        for i in range(n):\n            for j in range(n):\n                rot_i, rot_j = j, n - 1 - i\n                measured_displacement += abs(i - rot_i) + abs(j - rot_j)\n\n        # 7. Verification and final output assembly\n        writes_match = (measured_writes == closed_form_writes) and (measured_cycles == closed_form_cycles)\n        disp_match = (measured_displacement == closed_form_displacement)\n\n        result_for_n = [\n            A.flatten().tolist(),\n            measured_writes,\n            measured_cycles,\n            moved_element_count,\n            writes_match,\n            int(measured_displacement),\n            disp_match\n        ]\n        all_results.append(result_for_n)\n\n    # Final print statement must produce a single line with the specified format\n    # The default str() for a list produces a string '[...]' which matches the needed format when joined.\n    final_output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3254560"}, {"introduction": "How can we answer questions about the sum of any rectangular region in a large matrix instantly? This practice introduces the concept of an integral image, also known as a prefix-sum array. You will implement a pre-computation step that, once completed, allows any rectangular sum query to be answered in constant time, a powerful trade-off between pre-processing time and query speed. The derivation relies on the elegant inclusion-exclusion principle, a cornerstone of combinatorial mathematics [@problem_id:3254618].", "problem": "Consider a rectangular two-dimensional array $A$ with $d=2$, where $A \\in \\mathbb{Z}^{n \\times m}$ is indexed with $0$-based inclusive coordinates. The task is to design, derive, and implement a method to answer arbitrary axis-aligned rectangle sum queries over $A$ in constant time after a one-time preprocessing step. Begin from fundamental definitions and the inclusion-exclusion principle, and do not assume any pre-derived formulas.\n\nFundamental base:\n- Define the rectangle sum over a subset of entries of $A$ as follows. For indices $r_1, r_2, c_1, c_2$ with $0 \\le r_1 \\le r_2 < n$ and $0 \\le c_1 \\le c_2 < m$, the rectangle sum is\n$$\nS(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j]\n$$\n.\n- Define a two-dimensional prefix-sum array (also called an integral image) $P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$ constructed from $A$ such that each entry of $P$ encodes the sum of a contiguous subarray of $A$ whose top-left corner is at the origin. Use $1$-based padding for $P$ to avoid boundary special cases, so that indices of $P$ run from $0$ to $n$ in rows and from $0$ to $m$ in columns, with $P[0,\\cdot] = 0$ and $P[\\cdot,0] = 0$.\n\nYour tasks:\n1. Using only the above definitions and the inclusion-exclusion principle, derive a formula that expresses $S(r_1, c_1, r_2, c_2)$ in terms of $P$ that achieves $O(1)$ time per query. Your derivation must be logically sound and based on summation properties and inclusion-exclusion; do not introduce or assume any shortcut formulas.\n2. From first principles, derive the recurrence to build $P$ using $A$ so that all entries of $P$ are correct. Clearly explain why this build takes $O(nm)$ time.\n3. Implement a program that:\n   - Builds $P$ from each test caseâ€™s $A$.\n   - Computes the specified rectangle sum query $S(r_1, c_1, r_2, c_2)$ in $O(1)$ time using your derived inclusion-exclusion formula over $P$.\n   - Produces a single line of output containing the results as a comma-separated list enclosed in square brackets, for all provided test cases, in the order they appear.\n\nIndexing and correctness requirements:\n- Use $0$-based inclusive indices $(r_1, c_1, r_2, c_2)$ for rectangle queries over $A$.\n- Use $1$-based padding for $P$ as specified to avoid ambiguous boundary cases.\n- All arrays and indices must be treated consistently with the stated conventions.\n\nTest suite:\n- Test case $1$: $n = 3$, $m = 4$, matrix $A^{(1)}$ has rows $[1, 2, 3, 4]$, $[5, 6, 7, 8]$, $[9, 10, 11, 12]$, query $(r_1, c_1, r_2, c_2) = (1, 1, 2, 3)$.\n- Test case $2$: same $A^{(1)}$, query $(r_1, c_1, r_2, c_2) = (0, 0, 2, 3)$.\n- Test case $3$: same $A^{(1)}$, query $(r_1, c_1, r_2, c_2) = (0, 0, 0, 0)$.\n- Test case $4$: $n = 2$, $m = 2$, matrix $A^{(4)}$ has rows $[-1, 2]$, $[3, -4]$, query $(r_1, c_1, r_2, c_2) = (0, 0, 1, 1)$.\n- Test case $5$: $n = 3$, $m = 3$, matrix $A^{(5)}$ has rows $[0, 0, 0]$, $[0, 1, 0]$, $[0, 0, 0]$, query $(r_1, c_1, r_2, c_2) = (0, 0, 1, 2)$.\n\nExpected output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, `[result_1,result_2,result_3]`). Each $\\text{result}_k$ must be the integer value of the corresponding rectangle sum $S(r_1, c_1, r_2, c_2)$ for the $k$-th test case, in the order given above.", "solution": "The problem statement is evaluated to be **valid**. It is scientifically grounded in established principles of computer science and mathematics, specifically regarding data structures (multidimensional arrays) and algorithms (prefix sums). The problem is well-posed, with clear, unambiguous definitions, consistent constraints, and a verifiable set of test cases. It is self-contained and requires no external information or subjective interpretation. Therefore, a formal solution can be derived and implemented.\n\nThe derivation and implementation proceed in two stages as requested: deriving the constant-time query formula and the linear-time build recurrence, followed by the implementation.\n\n### 1. Derivation of the Constant-Time Query Formula\n\nThe objective is to compute the sum of an arbitrary rectangular sub-array, $S(r_1, c_1, r_2, c_2)$, in $O(1)$ time using a precomputed prefix-sum array, $P$.\n\n**Definition of the Prefix-Sum Array ($P$)**\n\nThe problem defines a prefix-sum array $P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$ with $1$-based padding. The value at $P[i,j]$ represents the sum of all elements in the rectangle of the original array $A$ from the origin $(0,0)$ to the point $(i-1, j-1)$, inclusive. Formally, for $i > 0$ and $j > 0$:\n$$\nP[i, j] = \\sum_{k=0}^{i-1} \\sum_{l=0}^{j-1} A[k,l]\n$$\nThe padding ensures that $P[i,j] = 0$ if $i=0$ or $j=0$. This convention simplifies the query formula by eliminating the need for boundary checks.\n\n**Derivation using the Inclusion-Exclusion Principle**\n\nThe query asks for the sum $S(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j]$. This sum corresponds to the area of a rectangle defined by the corners $(r_1, c_1)$ and $(r_2, c_2)$. We can compute this sum by starting with a larger rectangle originating at $(0,0)$ and systematically subtracting the parts that are not in the query rectangle. This is a direct application of the inclusion-exclusion principle.\n\nLet's define a helper function, $Sum(r, c) = \\sum_{k=0}^{r} \\sum_{l=0}^{c} A[k,l]$, which represents the sum of the rectangle from $(0,0)$ to $(r,c)$. In terms of our prefix-sum array $P$, this is $Sum(r, c) = P[r+1, c+1]$.\n\nThe desired sum, $S(r_1, c_1, r_2, c_2)$, can be visualized as the area of a large rectangle with its two smaller adjacent rectangles removed, plus a small corner rectangle that was removed twice.\n\n1.  **Include the large rectangle:** Start with the sum of all elements from the origin $(0,0)$ up to the bottom-right corner of the query rectangle, $(r_2, c_2)$. This sum is $Sum(r_2, c_2) = P[r_2+1, c_2+1]$. This area, let's call it $D$, contains the desired rectangle plus three other regions.\n\n2.  **Exclude the top rectangle:** The region above the query rectangle spans from $(0,0)$ to $(r_1-1, c_2)$. Its sum is $Sum(r_1-1, c_2) = P[(r_1-1)+1, c_2+1] = P[r_1, c_2+1]$. Let's call this area $C$. Subtracting this removes the elements above our target rectangle.\n\n3.  **Exclude the left rectangle:** The region to the left of the query rectangle spans from $(0,0)$ to $(r_2, c_1-1)$. Its sum is $Sum(r_2, c_1-1) = P[r_2+1, (c_1-1)+1] = P[r_2+1, c_1]$. Let's call this area $B$. Subtracting this removes the elements to the left of our target rectangle.\n\n4.  **Re-include the doubly-excluded corner:** When we subtracted the top rectangle ($C$) and the left rectangle ($B$), we subtracted their intersection twice. This intersection is the small rectangle from $(0,0)$ to $(r_1-1, c_1-1)$. Its sum is $Sum(r_1-1, c_1-1) = P[(r_1-1)+1, (c_1-1)+1] = P[r_1, c_1]$. Let's call this area $A$. To correct for the double subtraction, we must add this sum back once.\n\nCombining these steps gives the final formula:\n$$\nS(r_1, c_1, r_2, c_2) = D - B - C + A\n$$\n$$\nS(r_1, c_1, r_2, c_2) = P[r_2+1, c_2+1] - P[r_2+1, c_1] - P[r_1, c_2+1] + P[r_1, c_1]\n$$\nThis formula requires exactly $4$ lookups in the precomputed array $P$ and $3$ arithmetic operations (two subtractions, one addition). Since these operations take constant time, any query can be answered in $O(1)$ time. The use of a padded array $P$ elegantly handles cases where $r_1=0$ or $c_1=0$, as the corresponding terms like $P[r_2+1, 0]$ or $P[0, c_2+1]$ correctly evaluate to $0$.\n\n### 2. Derivation of the Build Recurrence for the Prefix-Sum Array\n\nThe second task is to derive a recurrence relation to build the prefix-sum array $P$ from the input array $A$ in $O(nm)$ time.\n\nFrom the definition of $P$, the value of a single element $A[i-1, j-1]$ can be expressed using values from $P$. This is equivalent to applying our query formula to a $1 \\times 1$ rectangle:\n$$\nA[i-1, j-1] = S(i-1, j-1, i-1, j-1)\n$$\nUsing the derived formula with $r_1=r_2=i-1$ and $c_1=c_2=j-1$:\n$$\nA[i-1, j-1] = P[(i-1)+1, (j-1)+1] - P[(i-1)+1, (j-1)] - P[(i-1), (j-1)+1] + P[(i-1), (j-1)]\n$$\n$$\nA[i-1, j-1] = P[i, j] - P[i, j-1] - P[i-1, j] + P[i-1, j-1]\n$$\nOur goal is to find a recurrence for $P[i,j]$. We can rearrange the above equation to solve for $P[i,j]$:\n$$\nP[i,j] = A[i-1, j-1] + P[i-1, j] + P[i, j-1] - P[i-1, j-1]\n$$\nThis is the desired recurrence relation. It states that the prefix sum up to cell $(i-1, j-1)$ of $A$ can be calculated from the current element $A[i-1, j-1]$ and the three adjacent, previously computed prefix sums in $P$: the one above ($P[i-1,j]$), the one to the left ($P[i,j-1]$), and the one diagonally top-left ($P[i-1, j-1]$).\n\nTo build the entire array $P$, we can iterate through its indices, for $i$ from $1$ to $n$ and for $j$ from $1$ to $m$, applying this recurrence at each step. The base cases are the padded rows and columns, which are initialized to $0$.\nA nested loop structure computes each of the $n \\times m$ non-padding entries of $P$:\n```\nfor i from 1 to n:\n  for j from 1 to m:\n    P[i,j] = A[i-1, j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n```\nSince the calculation for each $P[i,j]$ involves a constant number of arithmetic operations and array lookups ($O(1)$), and this is performed for all $n \\times m$ cells, the total time complexity for building the prefix-sum array $P$ is $O(nm)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rectangle sum query problem for a suite of test cases.\n    It follows a two-phase process:\n    1. Preprocessing: Builds a 2D prefix-sum array (integral image).\n    2. Querying: Uses the prefix-sum array to answer queries in O(1) time.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (1, 1, 2, 3)\n        },\n        # Test case 2\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 2, 3)\n        },\n        # Test case 3\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 0, 0)\n        },\n        # Test case 4\n        {\n            \"A\": np.array([\n                [-1, 2],\n                [3, -4]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 1)\n        },\n        # Test case 5\n        {\n            \"A\": np.array([\n                [0, 0, 0],\n                [0, 1, 0],\n                [0, 0, 0]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 2)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case[\"A\"]\n        query_coords = case[\"query\"]\n        \n        # Get dimensions of the original matrix A.\n        # A is 0-indexed, with dimensions n x m.\n        n, m = A.shape\n        \n        # 1. Preprocessing Step: Build the prefix-sum array P.\n        # P is (n+1) x (m+1) with 1-based padding for simplified calculations.\n        # P[0,:] and P[:,0] are all 0s by initialization.\n        P = np.zeros((n + 1, m + 1), dtype=np.int64)\n        \n        # Build P using the derived recurrence relation:\n        # P[i,j] = A[i-1,j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                P[i, j] = A[i - 1, j - 1] + P[i - 1, j] + P[i, j - 1] - P[i - 1, j - 1]\n                \n        # 2. Query Step: Compute the sum in O(1) time.\n        # The query is for the rectangle with inclusive 0-based coordinates\n        # (r1, c1) to (r2, c2).\n        r1, c1, r2, c2 = query_coords\n        \n        # Use the derived inclusion-exclusion formula:\n        # S(r1, c1, r2, c2) = P[r2+1, c2+1] - P[r1, c2+1] - P[r2+1, c1] + P[r1, c1]\n        # The indices of P are offset by +1 relative to A's indices.\n        sum_val = P[r2 + 1, c2 + 1] - P[r1, c2 + 1] - P[r2 + 1, c1] + P[r1, c1]\n        \n        results.append(sum_val)\n\n    # Final print statement in the exact required format.\n    # np.int64 objects must be converted to standard Python ints for str()\n    # to format them without any type-specific annotations.\n    print(f\"[{','.join(map(str, [int(r) for r in results]))}]\")\n\nsolve()\n```", "id": "3254618"}, {"introduction": "This exercise tackles a classic algorithmic challenge: finding the contiguous submatrix with the largest sum. The key to solving this problem lies in a powerful technique known as dimension reduction. You will learn how to cleverly reduce the two-dimensional problem into a series of one-dimensional problems, which can then be solved efficiently using the well-known Kadane's algorithm. This practice demonstrates how complex multidimensional problems can often be conquered by breaking them down into simpler, well-understood parts [@problem_id:3254593].", "problem": "A developer is given integer-valued multidimensional arrays and must compute maximum-sum contiguous regions within them by reasoning from first principles about sums and contiguity in arrays. Begin from the following base definitions: a two-dimensional array has shape $n \\times m$ and a three-dimensional array has shape $n \\times m \\times k$; a contiguous subarray in one dimension is specified by an index interval $[i,j]$ with $0 \\le i \\le j$; a contiguous submatrix in two dimensions is specified by intervals $[r_1,r_2]$ and $[c_1,c_2]$; a contiguous sub-cuboid in three dimensions is specified by intervals $[r_1,r_2]$, $[c_1,c_2]$, and $[z_1,z_2]$. The sum of any such region is defined by adding all entries with indices in the specified ranges. The one-dimensional maximum contiguous subarray problem asks for a contiguous interval with maximal sum; it is known to admit a linear-time solution by dynamic programming (Dynamic Programming (DP)) that uses only constant extra space. Using these foundations, the task is to derive and implement two algorithms: first, for a two-dimensional matrix, derive an approach that iteratively selects pairs of row boundaries and reduces the problem to a one-dimensional maximum contiguous subarray across columns for an appropriately constructed compressed array; second, for a three-dimensional tensor, generalize the idea by fixing two dimensions (rows and columns) to form a one-dimensional array across the remaining depth dimension and compute the maximal contiguous depth interval. The developer must present the algorithms as programs that compute the required maximum sums for the provided test suite and then, in accompanying analysis, quantify the time complexity in terms of $n$, $m$, and $k$ for both algorithms, making clear the effect of any precomputation used.\n\nThe program must be completely self-contained (no input from the user) and produce a single line of output that aggregates the integer results for all provided test cases into a comma-separated list enclosed in square brackets, in the exact order listed below. No physical units or angles are involved in this problem, and there is no rounding.\n\nImplement the two algorithms described above and apply them to the following test suite.\n\nTwo-Dimensional (2D) matrices:\n- Matrix $A_1$ of shape $4 \\times 5$:\n  `[[1, -2, -1, 4, -1], [-8, 3, 4, -2, 2], [3, -1, 2, 1, -5], [-4, 2, -1, 3, 1]]`\n- Matrix $A_2$ of shape $2 \\times 2$ (all negative, to test the boundary case):\n  `[[-5, -1], [-2, -3]]`\n\nThree-Dimensional (3D) tensors:\n- Tensor $B_1$ of shape $3 \\times 3 \\times 4$, given as four layers along the depth dimension (each layer is a $3 \\times 3$ matrix):\n  Layer $z=0$: `[[1, -2, 0], [-1, 3, -1], [2, -1, 1]]`\n  Layer $z=1$: `[[-2, 1, 4], [3, -1, 2], [-1, 2, -3]]`\n  Layer $z=2$: `[[0, 2, -1], [-3, 4, 1], [2, -2, 0]]`\n  Layer $z=3$: `[[-1, -2, 3], [1, 0, -1], [2, 1, -2]]`\n- Tensor $B_2$ of shape $3 \\times 3 \\times 1$ (depth of $1$, serving as a reduction to a single 2D layer):\n  Single layer $z=0$: `[[-1, 2, -3], [4, -5, 6], [-7, 8, -9]]`\n\nFor each $2$D test case, compute the maximum sum over all contiguous submatrices. For each $3$D test case, compute the maximum sum over all contiguous sub-cuboids. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order `[A_1, A_2, B_1, B_2]`, for example `[r1, r2, r3, r4]`, where $r_i$ are integers representing the corresponding maximum sums.\n\nDesign for coverage:\n- The case $A_1$ is a general mixed-sign $2$D instance that exercises the reduction to one dimension across column accumulations.\n- The case $A_2$ is a $2$D boundary instance with all negative entries to ensure the algorithm correctly returns the largest single entry when all sums are negative.\n- The case $B_1$ is a mixed-sign $3$D instance that requires fixing two dimensions and using an efficient per-layer rectangle summation to build a one-dimensional depth series for the one-dimensional maximum contiguous subarray algorithm.\n- The case $B_2$ is a $3$D boundary instance with $k=1$, which reduces to the $2$D maximum sum submatrix problem.", "solution": "The problem is assessed to be valid. It is a well-posed algorithmic challenge grounded in the established principles of dynamic programming and computational complexity within the field of data structures and algorithms. The definitions are clear, the objectives are formalizable, and the test cases are concrete and serve to validate the correctness of the derived algorithms under various conditions.\n\nThe core of the problem is to find the maximum-sum contiguous region in two-dimensional ($2$D) and three-dimensional ($3$D) integer-valued arrays by generalizing a known one-dimensional ($1$D) solution.\n\n### 1. The One-Dimensional Base Case: Maximum Contiguous Subarray Sum\n\nThe foundation for this problem is the one-dimensional maximum contiguous subarray sum problem. Given a $1$D array $A$ of length $N$, the goal is to find indices $i$ and $j$ ($0 \\le i \\le j < N$) such that the sum $\\sum_{k=i}^{j} A[k]$ is maximized.\n\nThis problem can be solved in $O(N)$ time with $O(1)$ extra space using Kadane's algorithm, a classic dynamic programming approach. The core idea is to iterate through the array, maintaining the maximum sum of a subarray ending at the current position. Let $c_i$ be the maximum sum of a contiguous subarray ending at index $i$, and $g$ be the global maximum sum found so far. The recurrence relation is:\n$c_i = \\max(A[i], c_{i-1} + A[i])$\n$g_i = \\max(g_{i-1}, c_i)$\n\nThis logic correctly handles arrays with all negative numbers, in which case the result is the largest (least negative) single element in the array.\n\n### 2. Derivation of the Two-Dimensional Algorithm\n\nFor a two-dimensional matrix $A$ of shape $n \\times m$, we are asked to find the contiguous submatrix with the maximum sum. The problem requires an approach that reduces this $2$D problem to a series of $1$D problems.\n\nThe algorithm proceeds as follows:\n1.  Initialize a global maximum sum, $S_{max}$, to a very small number (e.g., $-\\infty$).\n2.  Iterate through all possible pairs of top and bottom row boundaries, denoted by indices $r_1$ and $r_2$ where $0 \\le r_1 \\le r_2 < n$.\n3.  For each fixed pair $(r_1, r_2)$, we create a temporary $1$D array, let's call it `col_sums`, of size $m$. Each element `col_sums[c]` will store the sum of the elements in column $c$ from row $r_1$ to $r_2$. That is, $\\text{col\\_sums}[c] = \\sum_{r=r_1}^{r_2} A[r][c]$.\n4.  This `col_sums` array represents a \"compressed\" view of the submatrix defined by rows $r_1$ to $r_2$. Any contiguous subarray in `col_sums` with sum $S$ corresponds to a contiguous submatrix in the original matrix $A$ (spanning rows $r_1$ to $r_2$ and the corresponding column interval) with the same sum $S$.\n5.  Apply the $1$D maximum contiguous subarray algorithm (Kadane's) to the `col_sums` array to find the maximum sum for the fixed rows $r_1$ and $r_2$.\n6.  Update the global maximum sum $S_{max}$ with the result from step 5 if it is greater.\n\nAfter iterating through all possible pairs of $(r_1, r_2)$, $S_{max}$ will hold the maximum submatrix sum.\n\n**Complexity Analysis (2D):**\n- The outer loop for $r_1$ runs $n$ times.\n- The inner loop for $r_2$ runs on average $n/2$ times, so $O(n)$.\n- Inside the loops, we construct the `col_sums` array. This can be done efficiently. For a fixed $r_1$, as $r_2$ increments, we can update `col_sums` by adding the values from the new row $r_2$. This update takes $O(m)$ time.\n- Applying Kadane's algorithm to `col_sums` takes $O(m)$ time.\n- The total time complexity is the product of these nested operations: $O(n \\cdot n \\cdot (m + m)) = O(n^2 m)$.\n- The space complexity is $O(m)$ to store the `col_sums` array. No precomputation is specified or necessary for this method.\n\n### 3. Derivation of the Three-Dimensional Algorithm\n\nFor a three-dimensional tensor $B$ of shape $n \\times m \\times k$, we generalize the strategy above. The problem asks us to fix boundaries in two dimensions (rows and columns) and reduce the problem to a $1$D search along the third dimension (depth).\n\nThe algorithm is as follows:\n1.  Initialize a global maximum sum, $S_{max}$, to $-\\infty$.\n2.  Iterate through all possible rectangular cross-sections in the $n \\times m$ plane. This is defined by four boundary indices: $r_1, r_2, c_1, c_2$ where $0 \\le r_1 \\le r_2 < n$ and $0 \\le c_1 \\le c_2 < m$.\n3.  For each fixed rectangular region $(r_1, c_1)$ to $(r_2, c_2)$, create a temporary $1$D array, `depth_sums`, of size $k$.\n4.  Each element `depth_sums[z]` is the sum of all elements within the fixed rectangle at depth slice $z$. That is, $\\text{depth\\_sums}[z] = \\sum_{r=r_1}^{r_2} \\sum_{c=c_1}^{c_2} B[r][c][z]$.\n5.  Apply the $1$D maximum contiguous subarray algorithm (Kadane's) to `depth_sums`. The result gives the maximum sum for a contiguous sub-cuboid whose cross-section is the fixed rectangle.\n6.  Update the global maximum sum $S_{max}$ with the result from step 5.\n\n**Complexity Analysis (3D):**\nA naive calculation of the sum in step 4 for each rectangle and each depth slice would be inefficient. A direct implementation would have a complexity of roughly $O(n^2 \\cdot m^2 \\cdot k \\cdot n \\cdot m) = O(n^3 m^3 k)$. This is computationally prohibitive.\n\nTo make this feasible, we introduce a precomputation step.\n- **Precomputation:** For each of the $k$ depth slices, we compute a $2$D summed-area table (SAT). A SAT, $S$, for a matrix $M$ is defined as $S[i][j] = \\sum_{x=0}^{i} \\sum_{y=0}^{j} M[x][y]$. Building a SAT for an $n \\times m$ matrix takes $O(nm)$ time. Since there are $k$ slices, the total time for this precomputation is $O(nmk)$.\n- **Main Computation:** With the SATs, the sum of any rectangular region (step 4) can be calculated in $O(1)$ time.\nThe main algorithm consists of four nested loops for $r_1, r_2, c_1, c_2$, giving $O(n^2 m^2)$ choices for the rectangular cross-section. For each choice:\n  - Building the `depth_sums` array of size $k$ takes $O(k)$ time, since each sum is an $O(1)$ lookup.\n  - Applying Kadane's algorithm to `depth_sums` takes $O(k)$ time.\nThe total time for the main computation is $O(n^2 m^2 \\cdot k)$.\n- **Overall Complexity:** The total complexity is the sum of precomputation and main computation: $O(nmk + n^2 m^2 k)$. Since the second term dominates, the overall time complexity is $O(n^2 m^2 k)$. The space complexity is $O(nmk)$ to store the SATs. The prompt's requirement to discuss precomputation is addressed by this choice of an optimized algorithm.\n\nThe algorithms are now fully specified and their complexities are analyzed. These will be implemented to solve for the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies algorithms for finding the maximum-sum contiguous sub-region\n    in 2D and 3D arrays, as per the problem specification.\n    \"\"\"\n\n    def kadane(arr: np.ndarray) -> int:\n        \"\"\"\n        Computes the maximum contiguous subarray sum in O(N) time using Kadane's algorithm.\n        Handles the all-negative case correctly.\n        \"\"\"\n        if arr.size == 0:\n            return 0\n        \n        max_so_far = arr[0]\n        current_max = arr[0]\n        for i in range(1, arr.size):\n            x = arr[i]\n            current_max = max(x, current_max + x)\n            max_so_far = max(max_so_far, current_max)\n        return max_so_far\n\n    def max_sum_2d(matrix: np.ndarray) -> int:\n        \"\"\"\n        Computes the maximum sum of a contiguous submatrix.\n        Complexity: O(n*n*m) where shape is (n, m).\n        \"\"\"\n        n, m = matrix.shape\n        if n == 0 or m == 0:\n            return 0\n\n        max_overall_sum = -float('inf')\n\n        for r1 in range(n):\n            col_sums = np.zeros(m, dtype=int)\n            for r2 in range(r1, n):\n                # Update column sums by adding the new row r2\n                col_sums += matrix[r2, :]\n                \n                # Apply Kadane's algorithm to find the max sum for the submatrix from r1 to r2\n                current_max = kadane(col_sums)\n                max_overall_sum = max(max_overall_sum, current_max)\n                \n        return int(max_overall_sum)\n\n    def get_sum_from_2d_sat(sat_2d: np.ndarray, r1: int, c1: int, r2: int, c2: int) -> int:\n        \"\"\"\n        Calculates the sum of a rectangle from a 2D summed-area table in O(1).\n        \"\"\"\n        res = sat_2d[r2, c2]\n        if r1 > 0:\n            res -= sat_2d[r1 - 1, c2]\n        if c1 > 0:\n            res -= sat_2d[r2, c1 - 1]\n        if r1 > 0 and c1 > 0:\n            res += sat_2d[r1 - 1, c1 - 1]\n        return res\n\n    def max_sum_3d(tensor: np.ndarray) -> int:\n        \"\"\"\n        Computes the maximum sum of a contiguous sub-cuboid.\n        Complexity: O(n*n*m*m*k) where shape is (n, m, k), using precomputation.\n        \"\"\"\n        n, m, k = tensor.shape\n        if n == 0 or m == 0 or k == 0:\n            return 0\n        \n        # Precomputation: Build a 2D summed-area table for each depth slice.\n        # Complexity: O(n*m*k)\n        sats = np.zeros_like(tensor, dtype=int)\n        for z in range(k):\n            sats[:, :, z] = np.cumsum(np.cumsum(tensor[:, :, z], axis=0), axis=1)\n\n        max_overall_sum = -float('inf')\n\n        # Main computation: Iterate over all possible (r,c) rectangles, then find max\n        # contiguous sum along depth.\n        # Complexity: O(n^2 * m^2 * k)\n        for r1 in range(n):\n            for r2 in range(r1, n):\n                for c1 in range(m):\n                    for c2 in range(c1, m):\n                        # Construct a 1D array of sums along the depth dimension\n                        # for the fixed rectangle (r1,c1)-(r2,c2).\n                        depth_sums = np.zeros(k, dtype=int)\n                        for z in range(k):\n                            depth_sums[z] = get_sum_from_2d_sat(sats[:, :, z], r1, c1, r2, c2)\n                        \n                        current_max = kadane(depth_sums)\n                        max_overall_sum = max(max_overall_sum, current_max)\n        \n        return int(max_overall_sum)\n\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [1, -2, -1, 4, -1],\n        [-8, 3, 4, -2, 2],\n        [3, -1, 2, 1, -5],\n        [-4, 2, -1, 3, 1]\n    ], dtype=int)\n\n    A2 = np.array([\n        [-5, -1],\n        [-2, -3]\n    ], dtype=int)\n\n    B1_layers = [\n        np.array([[1, -2, 0], [-1, 3, -1], [2, -1, 1]], dtype=int),\n        np.array([[-2, 1, 4], [3, -1, 2], [-1, 2, -3]], dtype=int),\n        np.array([[0, 2, -1], [-3, 4, 1], [2, -2, 0]], dtype=int),\n        np.array([[-1, -2, 3], [1, 0, -1], [2, 1, -2]], dtype=int)\n    ]\n    B1 = np.stack(B1_layers, axis=2)\n\n    B2_layers = [\n        np.array([[-1, 2, -3], [4, -5, 6], [-7, 8, -9]], dtype=int)\n    ]\n    B2 = np.stack(B2_layers, axis=2)\n\n    # Calculate results for all test cases\n    results = [\n        max_sum_2d(A1),\n        max_sum_2d(A2),\n        max_sum_3d(B1),\n        max_sum_3d(B2)\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3254593"}]}