{"hands_on_practices": [{"introduction": "Before we can trust our simulations to reveal new physics, we must first verify that our numerical code works correctly. This first practice guides you through implementing the widely-used fourth-order Runge-Kutta (RK4) method to solve the pendulum equation. By systematically measuring how the simulation error scales with the time step size $h$, you will numerically determine the method's order of convergence—a fundamental skill for validating any scientific simulation [@problem_id:2420941].", "problem": "Consider the nonlinear simple pendulum of length $L$ under a uniform gravitational field of magnitude $g$, governed by the second-order ordinary differential equation\n$$ \\frac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\frac{g}{L} \\sin(\\theta) = 0 $$\nwhere $\\theta(t)$ is the angular displacement in radians and $t$ is time in seconds. Define the state vector $ \\mathbf{y}(t) = \\begin{bmatrix} \\theta(t) \\\\ \\omega(t) \\end{bmatrix} $ with $ \\omega(t) = \\dfrac{\\mathrm{d} \\theta}{\\mathrm{d} t} $. This yields the first-order system $ \\dfrac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{y}(t) = \\begin{bmatrix} \\omega(t) \\\\ -\\dfrac{g}{L} \\sin(\\theta(t)) \\end{bmatrix} $ with given initial condition $ \\mathbf{y}(0) = \\begin{bmatrix} \\theta_0 \\\\ \\omega_0 \\end{bmatrix} $. Angles must be in radians and time in seconds.\n\nFor a fixed total simulation time $T$, let $N$ be a positive integer and $h = T / N$ the uniform time step. Let $ \\Phi_h^N(\\mathbf{y}_0) $ denote the numerical state at time $T$ obtained by applying an explicit classical fourth-order one-step method with step size $h$ for $N$ steps starting from $ \\mathbf{y}_0 $. The method is defined by, for each step from $(t_n, \\mathbf{y}_n)$ to $(t_{n+1}, \\mathbf{y}_{n+1})$ with $t_{n+1} = t_n + h$,\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(t_n, \\mathbf{y}_n), \\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1\\right), \\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\!\\left(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2\\right), \\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\!\\left(t_n + h, \\mathbf{y}_n + h\\,\\mathbf{k}_3\\right), \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right),\n\\end{aligned}\n$$\nwhere $ \\mathbf{f}(t,\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix} $.\n\nDefine the final-state error at step size $h$ by\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2,\n$$\nwhere $h_{\\mathrm{ref}} = T / N_{\\mathrm{ref}}$ and $N_{\\mathrm{ref}}$ is a sufficiently large positive integer so that $ \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) $ serves as a reference solution at time $T$. The Euclidean norm $ \\| \\cdot \\|_2 $ is taken in $ \\mathbb{R}^2 $.\n\nFor a fixed problem instance, define the observed global error order $p$ as the slope of the least-squares best-fit line of the mapping $ \\log(h) \\mapsto \\log(E(h)) $ computed over the finite set of step sizes corresponding to $ N \\in \\{ 64, 128, 256, 512, 1024 \\} $.\n\nYour task is to write a complete, runnable program that, for each of the following test cases, computes the observed global error order $p$ as defined above. Use $ g = 9.81 \\,\\mathrm{m/s^2} $ and express angles in radians and angular velocities in radians per second. The reference discretization must use $ N_{\\mathrm{ref}} = 65536 $ for each test case.\n\nTest suite (all angles in radians, time in seconds, lengths in meters, angular velocities in radians per second):\n- Test A: $L = 1.0$, $\\theta_0 = 0.3$, $\\omega_0 = 0.0$, $T = 10.0$.\n- Test B: $L = 1.0$, $\\theta_0 = 2.5$, $\\omega_0 = 0.0$, $T = 10.0$.\n- Test C: $L = 2.0$, $\\theta_0 = 1.0$, $\\omega_0 = 1.0$, $T = 20.0$.\n- Test D: $L = 1.0$, $\\theta_0 = 1.2$, $\\omega_0 = 0.0$, $T = 40.0$.\n\nYour program must produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, in the order of Tests A, B, C, D, with each value rounded to two decimal places (unitless), for example, \"[4.00,4.01,3.99,3.98]\".", "solution": "The problem as stated is valid. It is scientifically grounded in classical mechanics and numerical analysis, well-posed with all necessary conditions and parameters provided, and formulated with objective and unambiguous language. There are no contradictions, missing information, or logical flaws. We may therefore proceed with the solution.\n\nThe problem requires the computation of the observed experimental order of convergence, $p$, for the classical fourth-order Runge-Kutta (RK4) method applied to the nonlinear pendulum equation. The governing equation is a second-order ordinary differential equation (ODE):\n$$\n\\frac{\\mathrm{d}^2 \\theta}{\\mathrm{d} t^2} + \\frac{g}{L} \\sin(\\theta) = 0\n$$\nThis is transformed into a system of two first-order ODEs by defining the state vector $\\mathbf{y}(t) = [\\theta(t), \\omega(t)]^T$, where $\\omega(t) = \\frac{\\mathrm{d}\\theta}{\\mathrm{d}t}$ is the angular velocity. The system is then:\n$$\n\\frac{\\mathrm{d}\\mathbf{y}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} \\omega \\\\ -\\frac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\nThis constitutes an initial value problem (IVP) with the initial condition $\\mathbf{y}(0) = [\\theta_0, \\omega_0]^T$. The function $\\mathbf{f}$ is autonomous, meaning it does not explicitly depend on time $t$.\n\nThe order of convergence of a numerical method characterizes the rate at which the global error decreases as the step size $h$ is reduced. For a method of order $p$, the global error $E(h)$ at a fixed final time $T$ is expected to scale according to the relation $E(h) \\propto h^p$. The problem defines the error $E(h)$ as the Euclidean norm of the difference between a numerical solution $\\Phi_h^N(\\mathbf{y}_0)$ and a high-precision reference solution $\\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$:\n$$\nE(h) = \\left\\| \\Phi_h^N(\\mathbf{y}_0) - \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0) \\right\\|_2\n$$\nTo determine the order $p$ from numerical data, we can take the logarithm of the error relation:\n$$\n\\log(E(h)) \\approx p \\log(h) + C'\n$$\nwhere $C'$ is a constant. This equation reveals a linear relationship between $\\log(E(h))$ and $\\log(h)$, with the slope being the order of convergence $p$. The problem specifies that $p$ should be computed as the slope of the least-squares best-fit line to the data points $(\\log(h), \\log(E(h)))$ generated for a prescribed set of step sizes. The classical Runge-Kutta method is known to be a fourth-order method, so we anticipate that the computed value of $p$ will be very close to $4$.\n\nThe computational procedure to solve the problem for each test case is as follows:\n\n1.  **Define System Parameters**: For each test case, the parameters $L$, $\\theta_0$, $\\omega_0$, and $T$ are specified. The gravitational acceleration is fixed at $g = 9.81 \\, \\mathrm{m/s^2}$. The initial state vector is $\\mathbf{y}_0 = [\\theta_0, \\omega_0]^T$.\n\n2.  **Implement the RK4 Integrator**: A function will be created to implement the one-step RK4 scheme as defined in the problem statement. This function will advance the state vector $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ over a time step $h$. Another function will orchestrate the integration over the full interval $[0, T]$ by repeatedly applying the one-step function for $N = T/h$ steps.\n\n3.  **Compute the Reference Solution**: For each test case, a highly accurate reference solution, $\\mathbf{y}_{\\mathrm{ref}} = \\Phi_{h_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}}(\\mathbf{y}_0)$, is computed at the final time $T$. The problem specifies a large number of steps, $N_{\\mathrm{ref}} = 65536$, to ensure this solution is a reliable benchmark.\n\n4.  **Compute Approximate Solutions and Errors**: For the set of step counts $N \\in \\{ 64, 128, 256, 512, 1024 \\}$, the corresponding step sizes $h = T/N$ are determined. For each $N$, the numerical solution $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$ is computed. The error $E(h) = \\| \\mathbf{y}_N - \\mathbf{y}_{\\mathrm{ref}} \\|_2$ is then calculated and stored along with its corresponding step size $h$.\n\n5.  **Determine the Order of Convergence**: With the set of pairs $(h, E(h))$, we compute the corresponding logarithmic pairs $(\\log(h), \\log(E(h)))$. A linear least-squares regression is performed on these logarithmic data points. The slope of the resulting best-fit line is the observed order of convergence, $p$.\n\nThis entire procedure is repeated for all four test cases provided (Test A, B, C, D). The final results for $p$ are collected, rounded to two decimal places, and formatted into the required output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed global error order for the RK4 method applied\n    to the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Define gravitational constant\n    g = 9.81  # m/s^2\n\n    # Test cases: (L, theta0, omega0, T)\n    test_cases = [\n        (1.0, 0.3, 0.0, 10.0),  # Test A\n        (1.0, 2.5, 0.0, 10.0),  # Test B\n        (2.0, 1.0, 1.0, 20.0),  # Test C\n        (1.0, 1.2, 0.0, 40.0),  # Test D\n    ]\n\n    # Parameters for the numerical experiment\n    N_values = [64, 128, 256, 512, 1024]\n    N_ref = 65536\n\n    results = []\n    \n    # Define the system of ODEs: d(y)/dt = f(t, y)\n    # y = [theta, omega]\n    # f returns [d(theta)/dt, d(omega)/dt]\n    # The system is autonomous, so t is not used.\n    def f(t, y, g_over_L):\n        theta, omega = y\n        return np.array([omega, -g_over_L * np.sin(theta)])\n\n    def integrate_rk4(y0, T, N, g_over_L):\n        \"\"\"\n        Solves the ODE system from t=0 to t=T using N steps of RK4.\n        \"\"\"\n        h = T / N\n        y = np.copy(y0)\n        t = 0.0\n        \n        for _ in range(N):\n            k1 = f(t, y, g_over_L)\n            k2 = f(t + h / 2.0, y + h / 2.0 * k1, g_over_L)\n            k3 = f(t + h / 2.0, y + h / 2.0 * k2, g_over_L)\n            k4 = f(t + h, y + h * k3, g_over_L)\n            \n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y\n\n    for case in test_cases:\n        L, theta0, omega0, T = case\n        g_over_L = g / L\n        y0 = np.array([theta0, omega0])\n\n        # 1. Compute the reference solution with N_ref steps\n        y_ref = integrate_rk4(y0, T, N_ref, g_over_L)\n\n        h_values = []\n        errors = []\n\n        # 2. Compute solutions and errors for a range of N\n        for N in N_values:\n            h = T / N\n            y_approx = integrate_rk4(y0, T, N, g_over_L)\n            \n            # 3. Calculate the Euclidean norm of the error vector\n            error = np.linalg.norm(y_approx - y_ref, 2)\n            \n            h_values.append(h)\n            errors.append(error)\n        \n        # 4. Perform linear regression on log(error) vs log(h)\n        # We expect log(error) = p * log(h) + C\n        log_h = np.log(h_values)\n        log_E = np.log(errors)\n        \n        # numpy.polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_E, 1)\n        \n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.2f}', results))}]\")\n\nsolve()\n```", "id": "2420941"}, {"introduction": "For a conservative system like the ideal pendulum, total energy should be constant, yet many numerical methods fail to preserve this property over long simulations. This exercise introduces the Euler-Cromer method, a simple 'symplectic' integrator designed to have superior long-term stability. By simulating for thousands of oscillations, you will observe that while the numerical energy is not perfectly conserved, its error remains bounded, demonstrating a key advantage of using physics-aware integrators for Hamiltonian systems [@problem_id:2420954].", "problem": "Consider an undamped rigid pendulum of point mass and massless rod moving in a vertical plane without friction. Let the angular displacement from the downward vertical be denoted by $ \\theta(t) $ (in radians), and the angular velocity be $ \\omega(t) = \\dot{\\theta}(t) $ (in radians per second). The equation of motion is the nonlinear second-order ordinary differential equation\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin\\!\\big(\\theta(t)\\big) = 0 ,\n$$\nwhere $ L $ is the length of the pendulum (in meters) and $ g $ is the gravitational acceleration (in meters per second squared). The total mechanical energy for mass $ m $ is\n$$\nE(\\theta,\\omega) = m g L \\big(1 - \\cos\\theta\\big) + \\frac{1}{2} m L^2 \\omega^2 .\n$$\nTake $ m = 1 $ kilogram throughout. Use radians for all angles and seconds for all times.\n\nDefine the following time discretization based on the small-angle period $ T_0 $:\n$$\nT_0 = 2\\pi \\sqrt{\\frac{L}{g}}, \\quad \\Delta t = \\frac{T_0}{N_{\\text{pp}}}, \\quad N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} ,\n$$\nwhere $ N_{\\text{pp}} $ is the number of time steps per small-angle period, and $ N_{\\text{per}} $ is the number of periods to simulate (periods are counted in units of $ T_0 $). Use the discrete-time update rule\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t, \\qquad\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t ,\n$$\nwith initial conditions\n$$\n\\theta_0 = \\theta(0) = \\theta_{\\text{init}}, \\qquad \\omega_0 = \\omega(0) = 0 .\n$$\nAt each step, compute the total energy\n$$\nE_n = g L \\big(1 - \\cos\\theta_n\\big) + \\frac{1}{2} L^2 \\omega_n^2,\n$$\nand define the relative energy deviation from the initial energy $ E_0 $ as\n$$\n\\varepsilon_n = \n\\begin{cases}\n\\left| \\dfrac{E_n - E_0}{E_0} \\right|, & \\text{if } E_0 \\neq 0, \\\\\n0, & \\text{if } E_0 = 0 .\n\\end{cases}\n$$\nFor each parameter set in the test suite below, simulate for $ N_{\\text{steps}} $ steps and report the maximum relative energy deviation\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\varepsilon_n $$ .\n\nTest Suite (each tuple is $ (L \\ \\text{in m}, \\ g \\ \\text{in m/s}^2, \\ \\theta_{\\text{init}} \\ \\text{in rad}, \\ N_{\\text{pp}}, \\ N_{\\text{per}}) $):\n- Case $1$: $(1.0, \\ 9.81, \\ 0.3, \\ 64, \\ 2500)$,\n- Case $2$: $(1.0, \\ 9.81, \\ 1.2, \\ 64, \\ 2500)$,\n- Case $3$: $(2.0, \\ 9.81, \\ 2.5, \\ 96, \\ 2000)$,\n- Case $4$: $(0.5, \\ 9.81, \\ 0.1, \\ 32, \\ 3000)$,\n- Case $5$: $(1.0, \\ 9.81, \\ 3.0, \\ 128, \\ 1500)$.\n\nYour program must, for each case, compute $ \\varepsilon_{\\max} $ as a floating-point number and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to eight decimal places (for example, $ [0.00123456,0.01234567] $). Use meters for $ L $, meters per second squared for $ g $, radians for $ \\theta $, and seconds for time. The output must aggregate the results in the order of the test suite cases as $ [\\varepsilon_{\\max}^{(1)}, \\varepsilon_{\\max}^{(2)}, \\varepsilon_{\\max}^{(3)}, \\varepsilon_{\\max}^{(4)}, \\varepsilon_{\\max}^{(5)}] $.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The problem is a standard exercise in computational physics, concerning the numerical integration of a conservative dynamical system.\n\nThe physical system is a simple rigid pendulum, whose motion is described by the nonlinear second-order ordinary differential equation\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\sin(\\theta(t)) = 0,\n$$\nwhere $ \\theta(t) $ is the angular displacement, $ \\omega(t) = \\dot{\\theta}(t) $ is the angular velocity, $ L $ is the pendulum length, and $ g $ is the acceleration due to gravity. As this system is conservative (undamped and unforced), its total mechanical energy $ E(\\theta, \\omega) $ is a constant of motion. For a point mass $ m $, this energy is the sum of potential and kinetic energies:\n$$\nE(\\theta,\\omega) = \\underbrace{m g L (1 - \\cos\\theta)}_{\\text{Potential Energy}} + \\underbrace{\\frac{1}{2} m L^2 \\omega^2}_{\\text{Kinetic Energy}}.\n$$\nWith the specified mass $ m = 1 \\ \\text{kg} $, the energy expression simplifies to\n$$\nE(\\theta,\\omega) = g L (1 - \\cos\\theta) + \\frac{1}{2} L^2 \\omega^2.\n$$\nThe task is to simulate the pendulum's dynamics using a specific numerical method and to quantify the method's accuracy by calculating the maximum relative deviation of the computed energy from its initial value. An ideal numerical integrator for a conservative system would preserve the energy exactly. Real integrators introduce errors, causing the numerical energy to deviate.\n\nThe prescribed numerical integration scheme is\n$$\n\\omega_{n+1} = \\omega_n - \\frac{g}{L} \\sin(\\theta_n)\\,\\Delta t,\n$$\n$$\n\\theta_{n+1} = \\theta_n + \\omega_{n+1}\\,\\Delta t,\n$$\nwhere $ (\\theta_n, \\omega_n) $ is the state at time $ t_n = n \\Delta t $, and $ \\Delta t $ is the discrete time step. This scheme is known as the Euler-Cromer method. It is a modification of the standard Euler method where the updated velocity $ \\omega_{n+1} $ is used to calculate the new position $ \\theta_{n+1} $. This seemingly minor change makes the integrator symplectic. Symplectic integrators are particularly well-suited for long-term simulations of Hamiltonian systems, such as this pendulum. While they do not conserve the exact energy $ E $, they do conserve a nearby quantity, a \"shadow\" Hamiltonian. Consequently, the energy error for a symplectic integrator typically remains bounded over time, oscillating around the initial value, whereas for a non-symplectic method like the forward Euler, the energy error tends to grow unboundedly. The problem asks for the maximum amplitude of this energy oscillation, quantified by $ \\varepsilon_{\\max} $.\n\nThe algorithm to compute $ \\varepsilon_{\\max} $ for each given parameter set is as follows:\n\n1.  **Initialization**: Given a test case with parameters $(L, g, \\theta_{\\text{init}}, N_{\\text{pp}}, N_{\\text{per}})$, first compute the derived simulation constants:\n    - The period for small-angle oscillations: $ T_0 = 2\\pi\\sqrt{L/g} $.\n    - The time step size: $ \\Delta t = T_0 / N_{\\text{pp}} $.\n    - The total number of simulation steps: $ N_{\\text{steps}} = N_{\\text{pp}} \\times N_{\\text{per}} $.\n\n2.  **Initial Conditions**: Set the initial state of the system at time $ t=0 $ ($n=0$):\n    - Initial angle: $ \\theta_0 = \\theta_{\\text{init}} $.\n    - Initial angular velocity: $ \\omega_0 = 0 $.\n\n3.  **Initial Energy and Error**: Compute the initial energy $ E_0 $ using the initial state:\n    $$\n    E_0 = g L (1 - \\cos\\theta_0).\n    $$\n    The relative energy deviation $ \\varepsilon_n $ is defined as $ \\varepsilon_n = |(E_n - E_0) / E_0| $ for $ E_0 \\ne 0 $. For the given initial conditions, $ E_0 $ is non-zero, as $ \\theta_{\\text{init}} $ is never a multiple of $ 2\\pi $. The initial deviation is $ \\varepsilon_0 = 0 $. The maximum deviation found so far is initialized as $ \\varepsilon_{\\max} = 0 $.\n\n4.  **Time Evolution Loop**: Iterate from $n=0$ to $ N_{\\text{steps}}-1 $ to simulate the motion. In each iteration, starting with the state $(\\theta_n, \\omega_n)$:\n    a.  Compute the new state $ (\\theta_{n+1}, \\omega_{n+1}) $ using the Euler-Cromer update rules.\n    b.  Calculate the total energy at the new step, $ E_{n+1} = g L (1 - \\cos\\theta_{n+1}) + \\frac{1}{2} L^2 \\omega_{n+1}^2 $.\n    c.  Calculate the relative energy deviation $ \\varepsilon_{n+1} = |(E_{n+1} - E_0) / E_0| $.\n    d.  Update the maximum deviation: $ \\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_{n+1}) $.\n    e.  The new state $ (\\theta_{n+1}, \\omega_{n+1}) $ becomes the current state for the next iteration.\n\n5.  **Result**: After $ N_{\\text{steps}} $ iterations, the final value of $ \\varepsilon_{\\max} $ is the result for the given test case. This procedure is repeated for all five test suites, and the results are collected. The final output is formatted as a list of these values, rounded to eight decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear pendulum problem for a suite of test cases.\n    \"\"\"\n    # Test Suite (L in m, g in m/s^2, theta_init in rad, N_pp, N_per)\n    test_cases = [\n        (1.0, 9.81, 0.3, 64, 2500),\n        (1.0, 9.81, 1.2, 64, 2500),\n        (2.0, 9.81, 2.5, 96, 2000),\n        (0.5, 9.81, 0.1, 32, 3000),\n        (1.0, 9.81, 3.0, 128, 1500),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, g, theta_init, N_pp, N_per = case\n        \n        # Calculate simulation parameters\n        T0 = 2.0 * np.pi * np.sqrt(L / g)\n        dt = T0 / N_pp\n        N_steps = N_pp * N_per\n        \n        # Initial conditions\n        theta = theta_init\n        omega = 0.0\n        \n        # Calculate initial energy\n        # The problem states m=1, so we omit it.\n        # E = g * L * (1 - cos(theta)) + 0.5 * L**2 * omega**2\n        E0 = g * L * (1.0 - np.cos(theta_init))\n        \n        # Initialize maximum relative energy deviation\n        # Epsilon_0 is 0 by definition.\n        epsilon_max = 0.0\n\n        # Handle the case where initial energy is zero to avoid division by zero.\n        # For the given test cases, theta_init is never a multiple of 2*pi, so E0 is not zero.\n        if E0 == 0.0:\n            results.append(0.0)\n            continue\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # Update state using the Euler-Cromer method\n            omega = omega - (g / L) * np.sin(theta) * dt\n            theta = theta + omega * dt\n            \n            # Calculate total energy at the current step\n            E_n = g * L * (1.0 - np.cos(theta)) + 0.5 * L**2 * omega**2\n            \n            # Calculate relative energy deviation\n            epsilon_n = np.abs((E_n - E0) / E0)\n            \n            # Update the maximum deviation\n            if epsilon_n > epsilon_max:\n                epsilon_max = epsilon_n\n        \n        results.append(epsilon_max)\n\n    # Format results to eight decimal places and print\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420954"}, {"introduction": "Having built and validated tools for a single pendulum, we can now apply them to explore more complex collective phenomena. This practice challenges you to simulate a 'pendulum wave,' a captivating pattern created by an array of pendula with finely tuned lengths. You will investigate how the predictions based on a simplified, linear model diverge from the rich behavior of the full nonlinear system, highlighting the power of numerical simulation to explore physics beyond what is analytically tractable [@problem_id:2403226].", "problem": "Consider a collection of simple pendula modeled as point masses attached to massless rigid rods of varying lengths. For each pendulum indexed by $n \\in \\{1,2,\\dots,N\\}$, let $\\theta_n(t)$ denote its angular displacement from the downward vertical at time $t$, with positive direction chosen consistently. Assume planar motion, no driving, and no dissipation. By Newton’s second law for rotational motion, the dynamics of each pendulum are governed by the ordinary differential equation (ODE) \n$$\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin\\big(\\theta_n(t)\\big) = 0\n$$,\nwith initial conditions \n$$\n\\theta_n(0)=\\theta_0,\\quad \\frac{d\\theta_n}{dt}(0)=0\n$$,\nwhere $g$ is the gravitational acceleration in $\\mathrm{m/s^2}$, $L_n$ is the length of the $n$–th pendulum in $\\mathrm{m}$, and angles are expressed in radians. To generate a pendulum-wave pattern, consider a set of target periods $\\{T_n\\}_{n=1}^N$ designed so that, in the small-angle limit, each pendulum completes an integer number of oscillations over a common alignment time $T_{\\mathrm{align}}$, namely $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$ with integers $K_n$. In the small-angle approximation, the period is $T_n = 2\\pi \\sqrt{\\frac{L_n}{g}}$, which implies the length choice \n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\nIn all tasks below, use the full nonlinear ODE with the exact $\\sin(\\theta_n)$ term, not the small-angle approximation. Use units: lengths in $\\mathrm{m}$, $g$ in $\\mathrm{m/s^2}$, time in $\\mathrm{s}$, and angles in radians.\n\nTest suite and required outputs:\n\n- Test case A (small-amplitude rephasing in the linear-design limit):\n  - Parameters: $N=15$, $g=9.81\\,\\mathrm{m/s^2}$, $\\theta_0=0.05\\,\\mathrm{rad}$, $T_{\\mathrm{align}}=60\\,\\mathrm{s}$, and $K_n = K_0 + N - n$ with $K_0=46$. Thus, $K_1=60$, $K_{15}=46$, and $L_n = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2$ for $n \\in \\{1,\\dots,15\\}$. Simulate each pendulum over $t \\in [0,T_{\\mathrm{align}}]$. Define the scalar\n  $$\n  E_A = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  Report $E_A$ as a floating-point number in radians.\n\n- Test case B (nonlinear dephasing at larger amplitude):\n  - Parameters: identical to Test case A except $\\theta_0=0.5\\,\\mathrm{rad}$. Simulate over $t \\in [0,T_{\\mathrm{align}}]$. Define\n  $$\n  E_B = \\max_{1 \\le n \\le N} \\left|\\theta_n(T_{\\mathrm{align}}) - \\theta_0\\right|.\n  $$\n  Report $E_B$ as a floating-point number in radians.\n\n- Test case C (degenerate pair with identical lengths):\n  - Parameters: $N=2$, $L_1=L_2=1.0\\,\\mathrm{m}$, $g=9.81\\,\\mathrm{m/s^2}$, $\\theta_0=0.1\\,\\mathrm{rad}$, and simulation interval $t \\in [0,T]$ with $T=10\\,\\mathrm{s}$. For these two pendula with identical initial conditions and lengths, define\n  $$\n  E_C = \\max_{t \\in [0,T]} \\left|\\theta_1(t) - \\theta_2(t)\\right|.\n  $$\n  Report $E_C$ as a floating-point number in radians.\n\nYour program must compute $(E_A, E_B, E_C)$ using the ODE stated above with the specified parameters and initial conditions. The final output must be a single line containing a comma-separated list enclosed in square brackets in the order $[E_A,E_B,E_C]$, for example $[x_A,x_B,x_C]$, where each entry is a floating-point number in radians. No other text should be printed.", "solution": "The starting point is the torque balance for a simple pendulum, which is derived from first principles. For a point mass $m$ at the end of a rigid massless rod of length $L_n$ under gravity $g$, the gravitational torque about the pivot is $\\tau = - m g L_n \\sin(\\theta_n)$. The moment of inertia is $I = m L_n^2$. Newton’s second law for rotation gives $I \\frac{d^2 \\theta_n}{dt^2} = \\tau$, hence\n$$\nm L_n^2 \\frac{d^2 \\theta_n}{dt^2} = - m g L_n \\sin(\\theta_n)\n\\quad \\Rightarrow \\quad\n\\frac{d^2 \\theta_n}{dt^2} + \\frac{g}{L_n} \\sin(\\theta_n) = 0.\n$$\nThis is a second-order nonlinear ordinary differential equation (ODE) initial value problem (IVP). With the initial conditions $\\theta_n(0) = \\theta_0$ and $\\frac{d\\theta_n}{dt}(0) = 0$, the solution is uniquely determined for each $n$.\n\nTo produce a pendulum-wave pattern, one selects lengths so that, in the small-angle limit, each pendulum completes an integer number of oscillations over a common alignment time $T_{\\mathrm{align}}$. If the small-angle period is $T_n = 2\\pi \\sqrt{L_n/g}$ and we enforce $T_n = \\frac{T_{\\mathrm{align}}}{K_n}$ for integers $K_n$, then the lengths follow\n$$\nL_n = g \\left(\\frac{T_n}{2\\pi}\\right)^2 = g \\left(\\frac{T_{\\mathrm{align}}}{2\\pi K_n}\\right)^2.\n$$\nChoosing a strictly decreasing sequence of integers $K_n$ with $n$ ensures strictly increasing lengths $L_n$ with $n$. In Test cases A and B, the choice $K_n = K_0 + N - n$ yields $K_1 = K_0 + N - 1$ down to $K_N = K_0$, and thus $L_1 < L_2 < \\cdots < L_N$.\n\nFor Test case A, the initial displacement $\\theta_0$ is small. In the linear limit, after $K_n$ complete oscillations, each pendulum returns to its initial state at $t = T_{\\mathrm{align}}$, implying $\\theta_n(T_{\\mathrm{align}}) = \\theta_0$ and thus $E_A = 0$. However, solving the exact nonlinear ODE with $\\sin(\\theta_n)$ produces a small deviation because the period depends on amplitude in the nonlinear regime; the numerical value $E_A$ quantifies this deviation.\n\nFor Test case B, the initial displacement $\\theta_0$ is larger, and the amplitude-dependent period shift is more significant. The sequence of $L_n$ is unchanged, but $E_B$ is expected to be larger because the nonlinear effects induce dephasing relative to the linear-design alignment time $T_{\\mathrm{align}}$.\n\nFor Test case C, with two pendula of identical length $L_1 = L_2$ and identical initial data $\\theta_1(0) = \\theta_2(0) = \\theta_0$ and $\\frac{d\\theta_1}{dt}(0) = \\frac{d\\theta_2}{dt}(0) = 0$, the ODEs are identical, and by uniqueness of solutions for smooth ODEs, $\\theta_1(t) \\equiv \\theta_2(t)$ for all $t$. Therefore, analytically $E_C = 0$. A numerical solution will yield a value close to zero, with any deviation attributable to numerical error and sampling.\n\nAlgorithmic outline consistent with these principles:\n- Express each second-order ODE as a first-order system by introducing $\\omega_n = \\frac{d\\theta_n}{dt}$:\n  $$\n  \\frac{d\\theta_n}{dt} = \\omega_n,\\quad \\frac{d\\omega_n}{dt} = -\\frac{g}{L_n} \\sin(\\theta_n).\n  $$\n- For Test cases A and B, for each $n \\in \\{1,\\dots,N\\}$, integrate the system from $t=0$ to $t=T_{\\mathrm{align}}$ with initial conditions $(\\theta_n(0),\\omega_n(0)) = (\\theta_0,0)$, and evaluate $\\theta_n(T_{\\mathrm{align}})$. Compute $E_A$ or $E_B$ as the maximum absolute deviation from $\\theta_0$ across $n$.\n- For Test case C, integrate both identical pendula over $t \\in [0,T]$ with the same initial conditions, sample $\\theta_1(t)$ and $\\theta_2(t)$ on a sufficiently fine time grid, and compute $E_C$ as the maximum absolute difference $|\\theta_1(t)-\\theta_2(t)|$ over the grid.\n- Use the specified units: $g$ in $\\mathrm{m/s^2}$, lengths in $\\mathrm{m}$, time in $\\mathrm{s}$, angles in radians.\n\nThe final program computes the three scalars $(E_A,E_B,E_C)$ and prints them in a single line as a comma-separated list in the required order $[E_A,E_B,E_C]$, with values in radians.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef pendulum_rhs(t, y, g, L):\n    theta, omega = y\n    return [omega, -(g / L) * np.sin(theta)]\n\ndef simulate_endpoint_theta(L, theta0, g, t_end, rtol=1e-10, atol=1e-12, method=\"DOP853\"):\n    # Integrate one pendulum to time t_end and return theta(t_end)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, t_end),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=[t_end],\n        dense_output=False,\n        vectorized=False,\n    )\n    theta_T = sol.y[0, -1]\n    return theta_T\n\ndef simulate_theta_time_series(L, theta0, g, T, num_points=5001, rtol=1e-11, atol=1e-13, method=\"DOP853\"):\n    # Integrate one pendulum over [0,T] and return time grid and theta(t) array\n    t_eval = np.linspace(0.0, T, num_points)\n    sol = solve_ivp(\n        fun=lambda t, y: pendulum_rhs(t, y, g, L),\n        t_span=(0.0, T),\n        y0=[theta0, 0.0],\n        method=method,\n        rtol=rtol,\n        atol=atol,\n        t_eval=t_eval,\n        dense_output=False,\n        vectorized=False,\n    )\n    return sol.t, sol.y[0, :]\n\ndef compute_lengths_for_alignment(N, g, T_align, K0):\n    # K_n = K0 + N - n yields increasing lengths with n\n    Ks = np.array([K0 + N - n for n in range(1, N + 1)], dtype=float)\n    # L_n = g * (T_align / (2*pi*K_n))^2\n    Ls = g * (T_align / (2.0 * np.pi * Ks))**2\n    return Ls\n\ndef main():\n    # Constants\n    g = 9.81  # m/s^2\n\n    results = []\n\n    # Test case A\n    N_A = 15\n    T_align_A = 60.0  # s\n    K0_A = 46\n    theta0_A = 0.05  # rad\n    Ls_A = compute_lengths_for_alignment(N_A, g, T_align_A, K0_A)\n    deviations_A = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_A, g, T_align_A)\n        deviations_A.append(abs(theta_T - theta0_A))\n    E_A = float(np.max(deviations_A))\n    results.append(E_A)\n\n    # Test case B (same lengths, larger amplitude)\n    theta0_B = 0.5  # rad\n    deviations_B = []\n    for L in Ls_A:\n        theta_T = simulate_endpoint_theta(L, theta0_B, g, T_align_A)\n        deviations_B.append(abs(theta_T - theta0_B))\n    E_B = float(np.max(deviations_B))\n    results.append(E_B)\n\n    # Test case C (two identical pendula)\n    L_C = 1.0  # m\n    theta0_C = 0.1  # rad\n    T_C = 10.0  # s\n    t_grid, theta1 = simulate_theta_time_series(L_C, theta0_C, g, T_C)\n    _, theta2 = simulate_theta_time_series(L_C, theta0_C, g, T_C)  # identical parameters\n    E_C = float(np.max(np.abs(theta1 - theta2)))\n    results.append(E_C)\n\n    # Print results in required format\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "2403226"}]}