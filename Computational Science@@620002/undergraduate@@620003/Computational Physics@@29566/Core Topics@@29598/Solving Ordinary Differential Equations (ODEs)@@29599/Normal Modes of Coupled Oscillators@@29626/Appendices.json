{"hands_on_practices": [{"introduction": "This first exercise is a foundational step into the computational analysis of coupled oscillators. You will model a one-dimensional chain of masses and springs, focusing on the crucial task of translating a physical description into a computational model. The main goal is to construct the stiffness matrix $K$ that correctly represents the interactions and boundary conditions of the system. By solving the resulting eigenvalue problem for the squared normal-mode frequencies $\\omega^2$, and specifically investigating the effect of a variable 'soft' boundary condition [@problem_id:2418616], you will build a solid workflow for tackling more complex oscillator systems.", "problem": "Consider a one-dimensional chain of $N$ identical point masses of mass $m$ connected by linear springs of stiffness $k$. The left end of the chain is attached to a fixed wall by a spring of stiffness $k$, and the right end is attached to a fixed wall by a spring of stiffness $k_{\\text{end}}$. All springs obey Hooke’s law and there is no damping. Let $x_i(t)$ denote the displacement of the $i$-th mass from its equilibrium position along the line, where $i \\in \\{1,2,\\dots,N\\}$ and $t$ is time.\n\nUsing only the fundamental laws of mechanics, determine the smallest positive normal-mode angular frequency $\\omega_1$ (in radians per second) of small oscillations for the chain described above, for each parameter set in the test suite below. Express each $\\omega_1$ in radians per second, rounded to six decimal places.\n\nTest suite (each item is $(N, m, k, k_{\\text{end}})$ with $m$ in kilograms, $k$ and $k_{\\text{end}}$ in newtons per meter):\n- $(5,\\, 0.20,\\, 50.0,\\, 50.0)$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{-3})$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{6})$\n- $(1,\\, 1.0,\\, 100.0,\\, 100.0)$\n- $(2,\\, 1.0,\\, 10.0,\\, 0.0)$\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example, \"[r1,r2,r3,r4,r5]\". Each $r_j$ must be the float representation of $\\omega_1$ for the $j$-th test case, rounded to six decimal places, in radians per second.", "solution": "The problem requires the determination of the lowest normal-mode angular frequency for a one-dimensional chain of coupled oscillators. The analysis proceeds from first principles of classical mechanics.\n\nThe system consists of $N$ point masses, each of mass $m$. Let $x_i(t)$ be the displacement of the $i$-th mass from its equilibrium position, where $i \\in \\{1, 2, \\dots, N\\}$. The masses are connected and attached to fixed walls by massless springs obeying Hooke's Law.\n\nThe cornerstone of the derivation is Newton's Second Law, $F_i = m \\ddot{x}_i$, applied to each mass. The force $F_i$ is the net force exerted by the springs attached to the $i$-th mass.\n\nWe must consider three distinct cases for the equations of motion: the first mass ($i=1$), an interior mass ($1 < i < N$), and the last mass ($i=N$).\n\nFor an interior mass $i$, where $1 < i < N$, it is connected to mass $i-1$ and mass $i+1$ by springs of stiffness $k$. The force from the left spring is $k(x_{i-1} - x_i)$ and the force from the right spring is $k(x_{i+1} - x_i)$. The total force is:\n$$F_i = k(x_{i-1} - x_i) + k(x_{i+1} - x_i) = k(x_{i-1} - 2x_i + x_{i+1})$$\nThe equation of motion is therefore:\n$$m \\ddot{x}_i = k(x_{i-1} - 2x_i + x_{i+1})$$\n\nFor the first mass, $i=1$, it is connected to a fixed wall ($x_0 = 0$) by a spring of stiffness $k$ and to mass $2$ by another spring of stiffness $k$. The force from the left spring is $k(x_0 - x_1) = -kx_1$. The force from the right spring is $k(x_2 - x_1)$. The total force is:\n$$F_1 = -kx_1 + k(x_2 - x_1) = kx_2 - 2kx_1$$\nThe equation of motion for the first mass is:\n$$m \\ddot{x}_1 = k(x_2 - 2x_1)$$\n\nFor the last mass, $i=N$, it is connected to mass $N-1$ by a spring of stiffness $k$ and to a fixed wall ($x_{N+1} = 0$) by a spring of stiffness $k_{\\text{end}}$. The force from the left spring is $k(x_{N-1} - x_N)$. The force from the right spring is $k_{\\text{end}}(x_{N+1} - x_N) = -k_{\\text{end}}x_N$. The total force is:\n$$F_N = k(x_{N-1} - x_N) - k_{\\text{end}}x_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\nThe equation of motion for the last mass is:\n$$m \\ddot{x}_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\n\nTo find the normal modes, we assume a solution where all masses oscillate with the same angular frequency $\\omega$. We express the displacements in complex form as $x_i(t) = A_i e^{i\\omega t}$, where $A_i$ is the complex amplitude of the $i$-th mass. The second time derivative is $\\ddot{x}_i(t) = -\\omega^2 A_i e^{i\\omega t} = -\\omega^2 x_i(t)$. Substituting this into the equations of motion and cancelling the common factor $e^{i\\omega t}$ yields a system of linear algebraic equations for the amplitudes $A_i$:\n$$-m\\omega^2 A_1 = kA_2 - 2kA_1$$\n$$-m\\omega^2 A_i = k(A_{i-1} - 2A_i + A_{i+1}) \\quad \\text{for } 1 < i < N$$\n$$-m\\omega^2 A_N = kA_{N-1} - (k + k_{\\text{end}})A_N$$\n\nThese equations can be rearranged and expressed in matrix form. Let $\\mathbf{A}$ be the column vector of amplitudes, $[A_1, A_2, \\dots, A_N]^T$. The system of equations is equivalent to the eigenvalue problem $\\mathbf{K}\\mathbf{A} = m\\omega^2\\mathbf{A}$, where $\\mathbf{K}$ is the $N \\times N$ stiffness matrix. This is a generalized eigenvalue problem, which simplifies to a standard one:\n$$\\frac{1}{m}\\mathbf{K}\\mathbf{A} = \\omega^2\\mathbf{A}$$\nThe matrix $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ is the dynamical matrix. Its eigenvalues $\\lambda_j = \\omega_j^2$ are the squares of the normal-mode angular frequencies.\n\nThe stiffness matrix $\\mathbf{K}$ is a real, symmetric, tridiagonal matrix constructed from the coefficients of the amplitudes $A_i$ in the force equations:\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\n2k & -k & 0 & \\dots & 0 \\\\\n-k & 2k & -k & \\dots & 0 \\\\\n0 & -k & 2k & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & 2k & -k \\\\\n0 & 0 & \\dots & -k & k+k_{\\text{end}}\n\\end{pmatrix}\n$$\nThe potential energy of the system, $U = \\frac{1}{2}\\mathbf{x}^T\\mathbf{K}\\mathbf{x} = \\frac{1}{2} k x_1^2 + \\frac{1}{2} k \\sum_{i=1}^{N-1} (x_{i+1}-x_i)^2 + \\frac{1}{2} k_{\\text{end}} x_N^2$, is positive for any non-zero displacement vector provided $k > 0$. Therefore, the matrix $\\mathbf{K}$ is positive definite, and all its eigenvalues $\\omega_j^2$ are strictly positive.\n\nThe problem is thus reduced to a computational task: for each set of parameters $(N, m, k, k_{\\text{end}})$, construct the matrix $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ and compute its eigenvalues. The smallest positive normal-mode angular frequency $\\omega_1$ is the square root of the smallest eigenvalue, $\\lambda_{\\text{min}}$.\n$$\\omega_1 = \\sqrt{\\lambda_{\\text{min}}}$$\n\nThe solution is found by implementing this procedure. For a given $N$, we construct the $N \\times N$ matrix $\\mathbf{K}$ with diagonal elements $K_{ii} = 2k$ for $i < N$ and $K_{NN} = k + k_{\\text{end}}$, and off-diagonal elements $K_{i, i+1} = K_{i+1, i} = -k$. Then, we find the eigenvalues of $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$. Since $\\mathbf{C}$ is real and symmetric, its eigenvalues are real and can be computed efficiently. The smallest of these eigenvalues gives the required frequency $\\omega_1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the smallest positive normal-mode angular frequency for a 1D chain of\n    masses and springs with specified boundary conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, m, k, k_end)\n    test_cases = [\n        (5, 0.20, 50.0, 50.0),\n        (5, 0.20, 50.0, 1e-3),\n        (5, 0.20, 50.0, 1e6),\n        (1, 1.0, 100.0, 100.0),\n        (2, 1.0, 10.0, 0.0),\n    ]\n\n    results = []\n    for N, m, k, k_end in test_cases:\n        # The problem reduces to solving the eigenvalue problem (1/m)K * A = omega^2 * A,\n        # where K is the stiffness matrix. The eigenvalues are the squared angular frequencies.\n        # We construct the dynamical matrix C = (1/m)K and find its eigenvalues.\n\n        # The stiffness matrix K is a real, symmetric, tridiagonal NxN matrix.\n        if N == 1:\n            # For N=1, the matrix K is a 1x1 matrix with element k + k_end.\n            main_diag = np.array([k + k_end])\n            K = np.diag(main_diag)\n        else:\n            # For N > 1, construct the tridiagonal matrix K.\n            # Main diagonal elements: 2k for the first N-1 masses.\n            main_diag = np.full(N, 2 * k)\n            # The last mass has a different diagonal term.\n            main_diag[N - 1] = k + k_end\n            \n            # Off-diagonal elements: -k for connections between masses.\n            off_diag = np.full(N - 1, -k)\n            \n            # Construct K using numpy.diag.\n            K = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # The dynamical matrix C.\n        C = (1 / m) * K\n\n        # Find the eigenvalues of the real symmetric matrix C.\n        # numpy.linalg.eigvalsh is efficient for this and returns eigenvalues\n        # sorted in ascending order.\n        eigenvalues = np.linalg.eigvalsh(C)\n        \n        # The smallest eigenvalue is the first element of the sorted array.\n        # For a stable system with k > 0, all eigenvalues are positive.\n        lambda_min = eigenvalues[0]\n        \n        # The smallest normal mode angular frequency is the square root of the smallest eigenvalue.\n        omega_1 = np.sqrt(lambda_min)\n        \n        results.append(round(omega_1, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2418616"}, {"introduction": "Building on the single-stiffness chain, we now explore a system with a periodically varying property: a 'diatomic' chain with alternating spring constants, $k_1$ and $k_2$. This seemingly small change introduces remarkably rich physics, splitting the frequency spectrum into distinct 'acoustic' and 'optical' bands and opening a 'band gap'—a range of frequencies where no vibrational modes can propagate. In this practice [@problem_id:2418660], you are tasked with a two-pronged approach: numerically calculating the band gap for a finite-ring system and analytically deriving it for an infinite chain, providing a powerful link between computational results and theoretical predictions from solid-state physics.", "problem": "Consider a one-dimensional periodic chain of $N$ identical point masses with mass $m$ (in $\\mathrm{kg}$), arranged on a ring (periodic boundary conditions). Neighboring masses are connected by linear springs that alternate between two spring constants $k_1$ and $k_2$ (in $\\mathrm{N/m}$) along the chain, in the sequence $k_1, k_2, k_1, k_2, \\dots$ around the ring. Assume $N$ is even so that the alternation closes consistently. The displacements are small, and all springs obey Hooke’s law. Your goal is to simulate the normal modes and analyze the resulting band structure of this diatomic stiffness chain from first principles.\n\nStarting only from Newton’s second law and Hooke’s law, the small oscillations of the system can be written as a system of linear ordinary differential equations in the displacements. Normal modes are solutions with sinusoidal time dependence, and their angular frequencies (in $\\mathrm{rad/s}$) are obtained by solving an appropriate eigenvalue problem that depends on the mass matrix and the stiffness matrix assembled from the spring connections. For an infinite chain with a two-site unit cell and alternating spring constants, a Bloch-wave analysis yields two branches (an acoustic branch and an optical branch) and a frequency gap between them at the edge of the Brillouin zone; this gap depends on $m$, $k_1$, and $k_2$.\n\nTasks:\n- Derive the linear equations of motion from Newton’s second law and Hooke’s law for the finite periodic ring with $N$ masses and alternating springs. Identify the mass matrix and stiffness matrix, and explain why the normal modes satisfy a generalized eigenvalue problem whose eigenvalues give squared angular frequencies.\n- Implement a program that constructs the stiffness matrix for given $(N,m,k_1,k_2)$ under periodic boundary conditions, computes all normal mode angular frequencies in $\\mathrm{rad/s}$, sorts them in ascending order, and identifies the acoustic and optical bands. Define the band gap as the difference between the smallest angular frequency of the upper band and the largest angular frequency of the lower band. For an alternating-stiffness chain with even $N$, there are $N/2$ modes in each band; therefore, if the sorted list of angular frequencies is $\\{\\omega_0 \\le \\omega_1 \\le \\dots \\le \\omega_{N-1}\\}$, the numerical band gap is $\\omega_{N/2} - \\omega_{N/2-1}$.\n- Independently, perform a Bloch-wave analysis for the two-site unit cell to obtain a theoretical expression for the band gap at the Brillouin zone boundary as a function of $m$, $k_1$, and $k_2$ (do not assume any pre-existing formula; derive it from first principles). Compute this theoretical band gap for each test case.\n\nNumerical requirements:\n- For each case below, compute three quantities in $\\mathrm{rad/s}$: the numerical band gap from the finite-ring eigenproblem, the theoretical band gap from your Bloch analysis, and the absolute difference between them. Round each reported value to $6$ decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case contributes its own sublist in the form $[\\text{gap\\_numeric},\\text{gap\\_theory},\\text{abs\\_difference}]$. For example: $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$.\n\nTest suite (covering a general case, equality of spring constants, strong contrast, and a small system size):\n- Case $1$: $N=200$, $m=1.0\\,\\mathrm{kg}$, $k_1=10.0\\,\\mathrm{N/m}$, $k_2=40.0\\,\\mathrm{N/m}$.\n- Case $2$: $N=100$, $m=2.0\\,\\mathrm{kg}$, $k_1=30.0\\,\\mathrm{N/m}$, $k_2=30.0\\,\\mathrm{N/m}$.\n- Case $3$: $N=200$, $m=0.5\\,\\mathrm{kg}$, $k_1=1.0\\,\\mathrm{N/m}$, $k_2=100.0\\,\\mathrm{N/m}$.\n- Case $4$: $N=4$, $m=1.5\\,\\mathrm{kg}$, $k_1=5.0\\,\\mathrm{N/m}$, $k_2=15.0\\,\\mathrm{N/m}$.\n\nUnit specification:\n- All angular frequencies must be expressed in $\\mathrm{rad/s}$.\n- Angles used implicitly in the Bloch analysis are in radians.\n\nFinal output format:\n- Your program must print exactly one line: a single bracketed, comma-separated list of the four per-case sublists, each sublist containing the three floats $[\\text{gap\\_numeric},\\text{gap\\_theory},\\text{abs\\_difference}]$, each rounded to $6$ decimal places, with no extra whitespace or text. For example: $[[1.234000,1.234000,0.000000],[\\dots],\\dots]$.", "solution": "We model a one-dimensional periodic chain of $N$ identical masses connected by alternating springs using Newton’s second law and Hooke’s law. Let $x_i(t)$ denote the displacement of the $i$th mass from equilibrium, with indices $i \\in \\{0,1,\\dots,N-1\\}$ and periodic boundary conditions $x_{i+N}=x_i$. The mass of each particle is $m$ (in $\\mathrm{kg}$). The spring connecting mass $i$ to mass $i+1$ has stiffness $k_i$ (in $\\mathrm{N/m}$), where $k_i = k_1$ if $i$ is even and $k_i = k_2$ if $i$ is odd, so the sequence of springs alternates $k_1,k_2,k_1,k_2,\\dots$ around the ring.\n\nBy Hooke’s law, the force from a spring with stiffness $k$ connecting masses at displacements $x$ and $y$ is $-k(x-y)$ on the $x$ mass and $-k(y-x)$ on the $y$ mass. The net force on mass $i$ comes from the spring to its left (between $i-1$ and $i$) with stiffness $k_{i-1}$ and the spring to its right (between $i$ and $i+1$) with stiffness $k_i$. Newton’s second law yields\n$$\nm \\,\\ddot{x}_i \\;=\\; -k_i(x_i - x_{i+1}) \\;-\\; k_{i-1}(x_i - x_{i-1})\n\\;=\\; -(k_i+k_{i-1})\\, x_i \\;+\\; k_i x_{i+1} \\;+\\; k_{i-1} x_{i-1}.\n$$\nCollecting all $N$ equations in vector form with $x(t) = (x_0(t),x_1(t),\\dots,x_{N-1}(t))^\\top$, we obtain the linear system\n$$\nM \\,\\ddot{x}(t) + K\\, x(t) = 0,\n$$\nwhere $M = m\\,I$ is the mass matrix and $K$ is the symmetric stiffness matrix determined by the spring network. For a spring with stiffness $k$ between indices $i$ and $j$, $K$ receives the standard contributions $K_{ii} \\mathrel{+}= k$, $K_{jj} \\mathrel{+}= k$, $K_{ij} \\mathrel{-}= k$, and $K_{ji} \\mathrel{-}= k$.\n\nNormal modes have the form $x(t) = v \\, e^{\\mathrm{i}\\omega t}$, leading to the generalized eigenvalue problem\n$$\nK\\, v \\;=\\; \\omega^2\\, M\\, v.\n$$\nSince $M = m\\,I$, this reduces to the standard symmetric eigenproblem\n$$\nK\\, v \\;=\\; \\lambda\\, v, \\qquad \\omega^2 \\;=\\; \\frac{\\lambda}{m},\n$$\nwith $\\lambda \\ge 0$ because $K$ is positive semidefinite. There is always a rigid translation mode with $\\omega = 0$.\n\nBand identification and numerical band gap for the finite ring:\nBecause of the two-spring alternation, the system behaves as a diatomic chain with two bands: an acoustic band containing $N/2$ modes (including the zero-frequency mode) and an optical band containing $N/2$ modes. Sorting the angular frequencies $\\{\\omega_i\\}_{i=0}^{N-1}$ in ascending order, the acoustic band is $\\{\\omega_0,\\dots,\\omega_{N/2-1}\\}$ and the optical band is $\\{\\omega_{N/2},\\dots,\\omega_{N-1}\\}$. The numerical band gap is then\n$$\n\\Delta \\omega_{\\text{num}} \\;=\\; \\omega_{N/2} - \\omega_{N/2-1}.\n$$\n\nTheoretical band structure by Bloch analysis:\nFor the infinite chain, define a two-site unit cell with displacements $u_n$ and $v_n$ for the two masses in the $n$th cell. The alternating springs are $k_1$ within a cell (connecting $u_n$ to $v_n$) and $k_2$ between cells (connecting $v_n$ to $u_{n+1}$). The equations of motion become\n$$\nm \\,\\ddot{u}_n = -(k_1+k_2) u_n + k_1 v_n + k_2 v_{n-1}, \\qquad\nm \\,\\ddot{v}_n = -(k_1+k_2) v_n + k_1 u_n + k_2 u_{n+1}.\n$$\nWith the Bloch ansatz $u_n = U\\, e^{\\mathrm{i}(q n a_c - \\omega t)}$ and $v_n = V\\, e^{\\mathrm{i}(q n a_c - \\omega t)}$ for lattice period $a_c$ equal to twice the single-mass spacing, we obtain the eigenvalue condition\n$$\n\\begin{pmatrix}\n(k_1+k_2) - \\omega^2 m & -(k_1 + k_2 e^{-\\mathrm{i} q a_c}) \\\\\n-(k_1 + k_2 e^{\\mathrm{i} q a_c}) & (k_1+k_2) - \\omega^2 m\n\\end{pmatrix}\n\\begin{pmatrix} U \\\\ V \\end{pmatrix}\n= 0.\n$$\nRequiring a nontrivial solution gives\n$$\n\\big[(k_1+k_2) - \\omega^2 m\\big]^2 \\;-\\; \\big|k_1 + k_2 e^{\\mathrm{i} q a_c}\\big|^2 \\;=\\; 0,\n$$\nso that\n$$\n\\omega^2(q) \\;=\\; \\frac{(k_1+k_2) \\pm \\sqrt{k_1^2 + k_2^2 + 2 k_1 k_2 \\cos(q a_c)}}{m},\n$$\nwith the minus sign yielding the acoustic branch and the plus sign the optical branch. At the Brillouin zone boundary $q = \\pi/a_c$, we have $\\cos(q a_c) = \\cos \\pi = -1$, hence\n$$\n\\omega_{\\text{ac}}^2\\big(\\tfrac{\\pi}{a_c}\\big) = \\frac{(k_1+k_2) - |k_1 - k_2|}{m} = \\frac{2 \\min(k_1,k_2)}{m}, \\quad\n\\omega_{\\text{op}}^2\\big(\\tfrac{\\pi}{a_c}\\big) = \\frac{(k_1+k_2) + |k_1 - k_2|}{m} = \\frac{2 \\max(k_1,k_2)}{m}.\n$$\nTherefore the theoretical band gap at the zone boundary is\n$$\n\\Delta \\omega_{\\text{theory}} \\;=\\; \\sqrt{\\frac{2\\,\\max(k_1,k_2)}{m}} \\;-\\; \\sqrt{\\frac{2\\,\\min(k_1,k_2)}{m}} \\quad \\text{in } \\mathrm{rad/s}.\n$$\nNote that if $k_1 = k_2$, then $\\Delta \\omega_{\\text{theory}} = 0$.\n\nAlgorithmic implementation:\n- Assemble the stiffness matrix $K$ by looping over the $N$ springs with periodic wrap-around. For the spring between $i$ and $j=(i+1)\\bmod N$, use $k=k_1$ if $i$ is even and $k=k_2$ if $i$ is odd, and add the standard $2 \\times 2$ contributions to $K$ at indices $(i,i)$, $(j,j)$, $(i,j)$, and $(j,i)$.\n- Compute the eigenvalues $\\{\\lambda_\\ell\\}$ of $K$ using a symmetric eigensolver. Convert to squared frequencies via $\\omega_\\ell^2 = \\lambda_\\ell/m$, clip small negative numerical errors to $0$, and then take square roots to get $\\omega_\\ell$ in $\\mathrm{rad/s}$. Sort $\\{\\omega_\\ell\\}$ ascending.\n- Compute $\\Delta \\omega_{\\text{num}} = \\omega_{N/2} - \\omega_{N/2-1}$.\n- Compute $\\Delta \\omega_{\\text{theory}}$ from the closed-form expression above.\n- For each test case, report $[\\Delta \\omega_{\\text{num}}, \\Delta \\omega_{\\text{theory}}, |\\Delta \\omega_{\\text{num}} - \\Delta \\omega_{\\text{theory}}|]$, with all values in $\\mathrm{rad/s}$ and rounded to $6$ decimal places.\n- Print one line containing the list of the four sublists in the exact format required.\n\nThis method is principled because it starts from Newton’s second law and Hooke’s law, constructs the physical stiffness and mass matrices, and uses the definition of normal modes to reduce to an eigenvalue problem. The Bloch-wave derivation provides a first-principles theoretical prediction of the band structure and its gap, enabling a quantitative comparison with the finite-ring simulation. The test suite covers a typical case, the no-gap limit $k_1=k_2$, a strong-contrast case with a wide gap, and a small system size where the Brillouin zone edge is sampled exactly.", "answer": "```python\nimport numpy as np\n\ndef build_stiffness_matrix(N: int, k1: float, k2: float) -> np.ndarray:\n    \"\"\"\n    Construct the NxN stiffness matrix K for a ring of N masses with alternating springs.\n    Spring between i and (i+1)%N has stiffness k1 if i is even, else k2.\n    \"\"\"\n    K = np.zeros((N, N), dtype=float)\n    for i in range(N):\n        j = (i + 1) % N\n        k = k1 if (i % 2 == 0) else k2\n        # Add spring contributions\n        K[i, i] += k\n        K[j, j] += k\n        K[i, j] -= k\n        K[j, i] -= k\n    return K\n\ndef numerical_gap(N: int, m: float, k1: float, k2: float) -> float:\n    \"\"\"\n    Compute the numerical band gap for the finite ring as the difference between\n    the smallest optical frequency and the largest acoustic frequency.\n    \"\"\"\n    K = build_stiffness_matrix(N, k1, k2)\n    # Since M = m I, eigenvalues of K are lambda = m * omega^2\n    evals = np.linalg.eigvalsh(K)\n    # Frequencies in rad/s\n    omega2 = np.clip(evals / m, 0.0, None)\n    omega = np.sqrt(omega2)\n    omega.sort()\n    # Acoustic band: first N//2 modes, Optical band: last N//2 modes\n    gap = omega[N // 2] - omega[N // 2 - 1]\n    return float(gap)\n\ndef theoretical_gap(m: float, k1: float, k2: float) -> float:\n    \"\"\"\n    Theoretical band gap at the Brillouin zone boundary for alternating springs:\n    Δω = sqrt(2*max(k1,k2)/m) - sqrt(2*min(k1,k2)/m)\n    \"\"\"\n    kmax = max(k1, k2)\n    kmin = min(k1, k2)\n    return float(np.sqrt(2.0 * kmax / m) - np.sqrt(2.0 * kmin / m))\n\ndef format_results_no_spaces(results):\n    \"\"\"\n    Format a list of lists of floats as a bracketed string with no spaces,\n    e.g., [[1.0,2.0,3.0],[...],...]\n    \"\"\"\n    sublists = []\n    for sub in results:\n        sub_str = \"[\" + \",\".join(f\"{x:.6f}\" for x in sub) + \"]\"\n        sublists.append(sub_str)\n    return \"[\" + \",\".join(sublists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, m [kg], k1 [N/m], k2 [N/m])\n    test_cases = [\n        (200, 1.0, 10.0, 40.0),   # General case\n        (100, 2.0, 30.0, 30.0),   # Equal springs -> zero gap\n        (200, 0.5, 1.0, 100.0),   # Strong contrast\n        (4,   1.5, 5.0, 15.0),    # Small system size\n    ]\n\n    results = []\n    for (N, m, k1, k2) in test_cases:\n        gap_num = numerical_gap(N, m, k1, k2)\n        gap_th = theoretical_gap(m, k1, k2)\n        abs_diff = abs(gap_num - gap_th)\n        # Round to 6 decimal places for reporting\n        results.append([round(gap_num, 6), round(gap_th, 6), round(abs_diff, 6)])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_results_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2418660"}, {"introduction": "In this final practice, we expand our analysis from one-dimensional chains to a three-dimensional structure: a square pyramid. This leap requires generalizing your approach to handle vector displacements and to construct the stiffness matrix from first principles in 3D space, where forces are projections of relative displacements onto spring axes. A key challenge in this problem [@problem_id:2418576] is to computationally distinguish the system's true vibrational modes from the zero-frequency rigid-body modes that correspond to overall translation and rotation. Successfully modeling this system demonstrates the power and generality of the normal mode framework for analyzing the vibrations of complex molecules and structures.", "problem": "You are to model the small-amplitude vibrational normal modes of a three-dimensional square pyramid formed by point masses connected by linear springs. There are five ($5$) point masses placed at the vertices of a square base and a single apex above the center of the square. Let the base be a square of side length $\\ell$ lying in the plane $z=0$ and centered at the origin. The base vertices are at positions $\\left(-\\frac{\\ell}{2},-\\frac{\\ell}{2},0\\right)$, $\\left(\\frac{\\ell}{2},-\\frac{\\ell}{2},0\\right)$, $\\left(\\frac{\\ell}{2},\\frac{\\ell}{2},0\\right)$, and $\\left(-\\frac{\\ell}{2},\\frac{\\ell}{2},0\\right)$. The apex is located at $\\left(0,0,h\\right)$, where $h$ is the height in meters.\n\nEach of the four ($4$) base vertices has mass $m_{\\mathrm{base}}$ (in kilograms), and the apex has mass $m_{\\mathrm{apex}}$ (in kilograms). Springs connect the masses as follows: each pair of adjacent base vertices is connected (four base edges), the two opposite base vertices are connected by the two base diagonals, and each base vertex is connected to the apex (four side edges). The spring stiffnesses (in newtons per meter) may be distinct for the base edges ($k_{\\mathrm{base}}$), side edges ($k_{\\mathrm{side}}$), and base diagonals ($k_{\\mathrm{diag}}$). Assume all springs are at their rest lengths in the reference geometry defined above, and neglect gravity.\n\nUnder the small oscillation approximation, treat each mass as a point mass moving in three spatial dimensions with small displacements. Construct the mass matrix and the stiffness matrix implied by this network and compute the angular frequencies of the vibrational normal modes by solving the generalized eigenvalue problem. Discard the rigid-body modes with zero angular frequency and report the smallest nine ($9$) strictly positive angular frequencies $\\omega$ (in radians per second) in ascending order for each parameter set below.\n\nAll outputs must be expressed in radians per second and rounded to six ($6$) decimal places.\n\nUse the following test suite of parameter sets. Each set is given in the order $\\left[\\ell\\ \\mathrm{(m)},\\ h\\ \\mathrm{(m)},\\ m_{\\mathrm{base}}\\ \\mathrm{(kg)},\\ m_{\\mathrm{apex}}\\ \\mathrm{(kg)},\\ k_{\\mathrm{base}}\\ \\mathrm{(N/m)},\\ k_{\\mathrm{side}}\\ \\mathrm{(N/m)},\\ k_{\\mathrm{diag}}\\ \\mathrm{(N/m)}\\right]$:\n- Test $1$: $\\left[1.0,\\ 1.0,\\ 1.0,\\ 1.0,\\ 100.0,\\ 100.0,\\ 100.0\\right]$.\n- Test $2$: $\\left[1.0,\\ 1.0,\\ 1.0,\\ 3.0,\\ 100.0,\\ 100.0,\\ 100.0\\right]$.\n- Test $3$: $\\left[1.0,\\ 0.7,\\ 1.5,\\ 1.0,\\ 300.0,\\ 100.0,\\ 300.0\\right]$.\n- Test $4$: $\\left[1.0,\\ 2.0,\\ 2.0,\\ 0.5,\\ 200.0,\\ 200.0,\\ 200.0\\right]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the nine ($9$) ascending positive angular frequencies rounded to six ($6$) decimal places. For example, the output format must be:\n\"[ [w1_1,w1_2,...,w1_9],[w2_1,...,w2_9],[w3_1,...,w3_9],[w4_1,...,w4_9] ]\" with no additional text.", "solution": "The system consists of $N=5$ point masses, whose small displacements from their equilibrium positions are described. Each mass has three translational degrees of freedom, so the configuration of the system is described by a generalized coordinate vector $\\mathbf{q}$ of dimension $3N = 15$. We can write $\\mathbf{q}$ as the concatenation of the displacement vectors $\\mathbf{u}_i = (u_{ix}, u_{iy}, u_{iz})$ for each mass $i=1, \\dots, 5$:\n$$\n\\mathbf{q} = [u_{1x}, u_{1y}, u_{1z}, u_{2x}, u_{2y}, u_{2z}, \\dots, u_{5x}, u_{5y}, u_{5z}]^T\n$$\n\nIn the small oscillations approximation, the kinetic energy $T$ and potential energy $V$ of the system can be expressed as quadratic forms of the generalized velocities $\\dot{\\mathbf{q}}$ and displacements $\\mathbf{q}$, respectively.\nThe kinetic energy is given by:\n$$\nT = \\frac{1}{2} \\sum_{i=1}^{5} m_i ||\\dot{\\mathbf{u}}_i||^2 = \\frac{1}{2} \\dot{\\mathbf{q}}^T M \\dot{\\mathbf{q}}\n$$\nHere, $M$ is the mass matrix. For this system of point masses, $M$ is a $15 \\times 15$ diagonal matrix. The diagonal entries corresponding to the degrees of freedom of the four base masses are $m_{\\mathrm{base}}$, and those for the apex mass are $m_{\\mathrm{apex}}$.\n$$\nM = \\mathrm{diag}( m_{\\mathrm{base}}, m_{\\mathrm{base}}, m_{\\mathrm{base}}, \\dots, m_{\\mathrm{base}}, m_{\\mathrm{apex}}, m_{\\mathrm{apex}}, m_{\\mathrm{apex}} )\n$$\n\nThe potential energy $V$ is stored in the springs. Since the springs are at their rest lengths in the equilibrium configuration, the potential energy is zero at equilibrium. For small displacements, the change in potential energy is approximately:\n$$\nV \\approx \\frac{1}{2} \\mathbf{q}^T K \\mathbf{q}\n$$\nwhere $K$ is the $15 \\times 15$ stiffness matrix. The matrix $K$ is constructed by summing the contributions from each spring in the system. Consider a single spring with stiffness $k_{ij}$ connecting masses $i$ and $j$ at equilibrium positions $\\mathbf{r}_i^0$ and $\\mathbf{r}_j^0$. The initial length of the spring is $L_{ij}^0 = ||\\mathbf{r}_j^0 - \\mathbf{r}_i^0||$, and the unit vector along it is $\\hat{\\mathbf{n}}_{ij} = (\\mathbf{r}_j^0 - \\mathbf{r}_i^0) / L_{ij}^0$. For small displacements $\\mathbf{u}_i$ and $\\mathbf{u}_j$, the change in spring length $\\Delta L_{ij}$ is the projection of the relative displacement vector onto the spring's direction:\n$$\n\\Delta L_{ij} \\approx (\\mathbf{u}_j - \\mathbf{u}_i) \\cdot \\hat{\\mathbf{n}}_{ij}\n$$\nThe potential energy stored in this spring is $V_{ij} = \\frac{1}{2} k_{ij} (\\Delta L_{ij})^2$. Summing over all springs gives the total potential energy $V = \\sum_{\\text{springs}} V_{ij}$. This quadratic form defines the stiffness matrix $K$.\n\nA practical method to construct $K$ is to consider the contribution of each spring individually. For a spring between masses $i$ and $j$, its contribution to the global stiffness matrix can be expressed in terms of a $3 \\times 3$ matrix $K_{ij}^{\\text{block}} = k_{ij} (\\hat{\\mathbf{n}}_{ij} \\otimes \\hat{\\mathbf{n}}_{ij}) = k_{ij} \\hat{\\mathbf{n}}_{ij} \\hat{\\mathbf{n}}_{ij}^T$. The global stiffness matrix $K$ is populated by adding and subtracting this block as follows, where $K_{ab}$ denotes the $3 \\times 3$ submatrix of $K$ that couples mass $a$ with mass $b$:\n$$\n\\begin{cases}\nK_{ii} \\mathrel{+}= K_{ij}^{\\text{block}} \\\\\nK_{jj} \\mathrel{+}= K_{ij}^{\\text{block}} \\\\\nK_{ij} \\mathrel{-}= K_{ij}^{\\text{block}} \\\\\nK_{ji} \\mathrel{-}= K_{ij}^{\\text{block}}\n\\end{cases}\n$$\nThis procedure is repeated and summed for all springs in the network, yielding the complete symmetric, positive semi-definite matrix $K$.\n\nThe Lagrangian of the system is $L = T - V$. The Euler-Lagrange equations, $\\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_k} - \\frac{\\partial L}{\\partial q_k} = 0$, lead to the system of second-order linear differential equations:\n$$\nM \\ddot{\\mathbf{q}} + K \\mathbf{q} = \\mathbf{0}\n$$\nTo find the normal modes, we seek solutions of the form $\\mathbf{q}(t) = \\mathbf{a} e^{i\\omega t}$, where $\\mathbf{a}$ is a constant amplitude vector and $\\omega$ is the angular frequency. Substituting this into the equation of motion gives:\n$$\n(-\\omega^2 M \\mathbf{a} + K \\mathbf{a}) e^{i\\omega t} = \\mathbf{0}\n$$\nThis must hold for all $t$, which leads to the generalized eigenvalue problem:\n$$\nK \\mathbf{a} = \\omega^2 M \\mathbf{a}\n$$\nThe eigenvalues of this problem are $\\lambda_k = \\omega_k^2$, and the eigenvectors $\\mathbf{a}_k$ are the normal mode vectors. For a $3D$ system of $N$ free masses, there are $3N$ modes in total. Six of these are rigid-body modes (3 translations and 3 rotations) with $\\omega = 0$. The remaining $3N-6$ modes are vibrational modes with strictly positive frequencies. For this problem with $N=5$, we expect $15 - 6 = 9$ vibrational modes.\n\nThe computational strategy is as follows:\n1.  Define the equilibrium positions of the $5$ masses based on the parameters $\\ell$ and $h$.\n2.  Construct the diagonal $15 \\times 15$ mass matrix $M$.\n3.  Initialize a $15 \\times 15$ zero matrix for $K$.\n4.  Iterate through all $10$ springs. For each spring, calculate its unit direction vector $\\hat{\\mathbf{n}}_{ij}$ and stiffness $k_{ij}$. Compute the $3 \\times 3$ block matrix $K_{ij}^{\\text{block}}$ and update the corresponding submatrices of $K$.\n5.  Solve the generalized eigenvalue problem $K \\mathbf{a} = \\lambda M \\mathbf{a}$ to find the eigenvalues $\\lambda_k$.\n6.  Calculate the angular frequencies $\\omega_k = \\sqrt{\\lambda_k}$. Due to numerical precision, eigenvalues for rigid-body modes may be small non-zero numbers, so a tolerance is used to identify them.\n7.  Collect the $9$ strictly positive frequencies, sort them in ascending order, and round to the required precision. This procedure is repeated for each parameter set provided.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves for the vibrational normal modes of a square pyramid system\n    for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0, 100.0, 100.0, 100.0), # Test 1\n        (1.0, 1.0, 1.0, 3.0, 100.0, 100.0, 100.0), # Test 2\n        (1.0, 0.7, 1.5, 1.0, 300.0, 100.0, 300.0), # Test 3\n        (1.0, 2.0, 2.0, 0.5, 200.0, 200.0, 200.0), # Test 4\n    ]\n\n    results = []\n    for params in test_cases:\n        freqs = calculate_frequencies(*params)\n        results.append(freqs)\n\n    # Format the final output string precisely as specified.\n    case_strings = []\n    for case_res in results:\n        # Round final results to 6 decimal places and format as a string\n        num_strings = [f\"{val:.6f}\" for val in case_res]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    final_print_string = f\"[{','.join(case_strings)}]\"\n    print(final_print_string)\n\ndef calculate_frequencies(ell, h, m_base, m_apex, k_base, k_side, k_diag):\n    \"\"\"\n    Calculates the 9 smallest positive angular frequencies for the pyramid system.\n\n    Args:\n        ell (float): Side length of the square base.\n        h (float): Height of the apex.\n        m_base (float): Mass of each base vertex.\n        m_apex (float): Mass of the apex vertex.\n        k_base (float): Stiffness of base edge springs.\n        k_side (float): Stiffness of side edge springs.\n        k_diag (float): Stiffness of base diagonal springs.\n\n    Returns:\n        list: A list of the 9 smallest positive angular frequencies, sorted ascending.\n    \"\"\"\n    num_masses = 5\n    dim = 3\n    dof = num_masses * dim\n\n    # Define equilibrium positions of the 5 masses\n    # Masses 0-3 are base, Mass 4 is apex\n    l2 = ell / 2.0\n    positions = np.array([\n        [-l2, -l2, 0.0],\n        [ l2, -l2, 0.0],\n        [ l2,  l2, 0.0],\n        [-l2,  l2, 0.0],\n        [0.0, 0.0,   h]\n    ])\n\n    # Construct the Mass Matrix M (15x15)\n    mass_array = np.array([m_base] * 4 + [m_apex] * 1)\n    M = np.diag(np.repeat(mass_array, dim))\n\n    # Define spring connections: (mass_idx_1, mass_idx_2, stiffness)\n    connections = [\n        # Base edges\n        (0, 1, k_base), (1, 2, k_base), (2, 3, k_base), (3, 0, k_base),\n        # Base diagonals\n        (0, 2, k_diag), (1, 3, k_diag),\n        # Side edges\n        (0, 4, k_side), (1, 4, k_side), (2, 4, k_side), (3, 4, k_side)\n    ]\n\n    # Construct the Stiffness Matrix K (15x15)\n    K = np.zeros((dof, dof))\n    for i, j, k_spring in connections:\n        r_i = positions[i]\n        r_j = positions[j]\n        \n        vec = r_j - r_i\n        dist = np.linalg.norm(vec)\n        if dist  1e-9:\n            continue\n        \n        unit_vec = vec / dist\n        \n        # Calculate the 3x3 stiffness block for this spring\n        k_block = k_spring * np.outer(unit_vec, unit_vec)\n        \n        # Add contributions to the global stiffness matrix K\n        s_i = i * dim\n        s_j = j * dim\n        e_i = s_i + dim\n        e_j = s_j + dim\n        \n        K[s_i:e_i, s_i:e_i] += k_block\n        K[s_j:e_j, s_j:e_j] += k_block\n        K[s_i:e_i, s_j:e_j] -= k_block\n        K[s_j:e_j, s_i:e_i] -= k_block\n\n    # Solve the generalized eigenvalue problem: K*v = w^2*M*v\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = eigh(K, M)\n\n    # Frequencies are sqrt of eigenvalues. Filter out small/negative values\n    # from numerical noise, which correspond to rigid-body modes.\n    # Take the smallest 9 positive frequencies.\n    tolerance = 1e-9\n    positive_eigenvalues = eigenvalues[eigenvalues > tolerance]\n    angular_frequencies = np.sqrt(positive_eigenvalues)\n    \n    # We expect 9 vibrational modes.\n    # Sort and take the first 9, just in case of numerical issues.\n    sorted_freqs = np.sort(angular_frequencies)\n    num_modes = dof - 6\n    \n    return [round(w, 6) for w in sorted_freqs[:num_modes]]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2418576"}]}