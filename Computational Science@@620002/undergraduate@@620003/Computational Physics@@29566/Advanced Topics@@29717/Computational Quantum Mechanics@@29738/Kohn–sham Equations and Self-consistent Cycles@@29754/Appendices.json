{"hands_on_practices": [{"introduction": "The Kohn-Sham effective potential is a sum of the external, Hartree, and exchange-correlation potentials. The Hartree potential, which describes the classical electrostatic repulsion among electrons, is found by solving the Poisson equation for a given electron density $\\rho(x)$. This exercise [@problem_id:2405650] isolates this crucial component, allowing you to master the numerical solution of a boundary value problem using the finite-difference method before tackling the full self-consistent cycle.", "problem": "You are to write a complete program that computes the Hartree potential $v_H(x)$ for a one-dimensional model system used in Density Functional Theory (DFT), by solving the boundary value problem\n$$\n\\frac{\\mathrm{d}^2 v_H}{\\mathrm{d}x^2}(x) \\;=\\; -\\,4\\pi\\,\\rho(x),\n$$\non a finite interval $x \\in [0,L]$ with boundary conditions $v_H(0)=0$ and $v_H(L)=0$. Use Hartree atomic units, where the length is in bohr and the potential $v_H$ is in Hartree. In this one-dimensional model, treat $\\rho(x)$ as a given scalar field so that the equation above is dimensionally consistent in these units. Your program must compute $v_H(x)$ on a uniform grid of $N$ points including both endpoints.\n\nYou will be given a fixed domain length $L$ and grid size $N$, and several explicit charge density profiles $\\rho(x)$. For each specified density and query position $x_q$, you must compute the corresponding Hartree potential at that position, $v_H(x_q)$, by solving the boundary value problem on the stated grid.\n\nParameters for all test cases:\n- Domain length $L = 10.0$ bohr.\n- Number of grid points $N = 401$ (uniform grid including both endpoints).\n\nTest suite (four cases), each defined by a density profile $\\rho(x)$ on $[0,L]$ and a query position $x_q$:\n1. Case 1 (happy path, zero source): $\\rho(x) = 0$ for all $x$, with $x_q = L/2$.\n2. Case 2 (uniform source with known closed-form solution): $\\rho(x) = \\rho_0$ with $\\rho_0 = 0.01$, with $x_q = L/2$.\n3. Case 3 (oscillatory source satisfying interior symmetry): $\\rho(x) = \\rho_1 \\cos\\!\\left(\\pi x / L\\right)$ with $\\rho_1 = 0.02$, with $x_q = L/2$.\n4. Case 4 (localized source away from center): $\\rho(x) = A \\exp\\!\\left(-\\frac{(x-a)^2}{2\\sigma^2}\\right)$ with $A=0.1$, $a=3.0$, $\\sigma=0.5$, with $x_q = a$.\n\nYour program must:\n- Construct the uniform grid of $N$ points on $[0,L]$.\n- For each test case, compute $v_H(x)$ that satisfies the differential equation and boundary conditions on that grid.\n- Evaluate $v_H(x_q)$ at the provided query position $x_q$. The query positions in this test suite lie exactly on grid points.\n\nFinal output format:\n- Produce a single line of output containing a list with four floating-point numbers corresponding to $v_H(x_q)$ for the four cases, in the same order as the cases above.\n- Express each number in Hartree and round each to six digits after the decimal point.\n- The line must be a single Python list literal with comma-separated values and no additional text, for example: \"[0.000000,1.234567,0.000000,0.987654]\".", "solution": "The problem statement is valid. It presents a well-posed, one-dimensional boundary value problem for the Poisson equation, which is fundamental in electrostatics and constitutes a core component of Density Functional Theory calculations—specifically for determining the Hartree potential $v_H(x)$ from a given charge density $\\rho(x)$. The problem is scientifically grounded, free of ambiguity, and all parameters required for a numerical solution are provided.\n\nThe task is to solve the second-order ordinary differential equation:\n$$\n\\frac{\\mathrm{d}^2 v_H}{\\mathrm{d}x^2}(x) = -4\\pi\\rho(x)\n$$\non a domain $x \\in [0, L]$ with Dirichlet boundary conditions $v_H(0) = 0$ and $v_H(L) = 0$.\n\nA robust and standard method for solving such a problem is the Finite Difference Method (FDM). This method involves discretizing the continuous domain and approximating the differential operator with finite differences, which transforms the differential equation into a system of linear algebraic equations.\n\nFirst, we discretize the spatial domain $[0, L]$ into a uniform grid of $N$ points. Let the grid points be $x_i = i \\cdot \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L / (N-1)$. We denote the unknown potential at these grid points as $v_i \\equiv v_H(x_i)$. The given boundary conditions fix the potential at the endpoints: $v_0 = v_H(x_0) = v_H(0) = 0$ and $v_{N-1} = v_H(x_{N-1}) = v_H(L) = 0$. The potential must be computed for the interior points $i = 1, 2, \\dots, N-2$.\n\nNext, we approximate the second derivative operator $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ using a second-order central difference formula:\n$$\n\\frac{\\mathrm{d}^2 v_H}{\\mathrm{d}x^2}(x_i) \\approx \\frac{v_{i-1} - 2v_i + v_{i+1}}{(\\Delta x)^2}\n$$\nThis approximation is second-order accurate, with an error proportional to $(\\Delta x)^2$.\n\nSubstituting this approximation into the original differential equation for each interior grid point $x_i$ ($i=1, \\dots, N-2$) yields a system of $N-2$ linear equations:\n$$\n\\frac{v_{i-1} - 2v_i + v_{i+1}}{(\\Delta x)^2} = -4\\pi\\rho(x_i)\n$$\nRearranging this, we obtain:\n$$\nv_{i-1} - 2v_i + v_{i+1} = -4\\pi(\\Delta x)^2\\rho_i\n$$\nwhere $\\rho_i = \\rho(x_i)$.\n\nThis system of equations can be expressed in matrix form $A \\mathbf{v} = \\mathbf{b}$, where $\\mathbf{v} = [v_1, v_2, \\dots, v_{N-2}]^T$ is the vector of unknown potential values at the interior points. The matrix $A$ is an $(N-2) \\times (N-2)$ symmetric tridiagonal matrix defined by the finite difference stencil:\n$$\nA = \\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\cdots & 0 \\\\\n0 & 1 & -2 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & -2 & 1 \\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ is an $(N-2)$-dimensional vector whose components are determined by the source term $\\rho(x)$ and the boundary conditions. For $i=1$, the equation is $v_0 - 2v_1 + v_2 = -4\\pi(\\Delta x)^2\\rho_1$. Since $v_0=0$, it simplifies to $-2v_1 + v_2 = -4\\pi(\\Delta x)^2\\rho_1$. For $i=N-2$, the equation is $v_{N-3} - 2v_{N-2} + v_{N-1} = -4\\pi(\\Delta x)^2\\rho_{N-2}$. Since $v_{N-1}=0$, this becomes $v_{N-3} - 2v_{N-2} = -4\\pi(\\Delta x)^2\\rho_{N-2}$. Thus, the vector $\\mathbf{b}$ is given by:\n$$\n\\mathbf{b} = -4\\pi(\\Delta x)^2 \\begin{pmatrix} \\rho_1 \\\\ \\rho_2 \\\\ \\vdots \\\\ \\rho_{N-2} \\end{pmatrix}\n$$\nThe algorithm proceeds as follows for each test case:\n$1$. Define the parameters: domain length $L=10.0$ and number of points $N=401$. This defines the grid $x_i$ and spacing $\\Delta x$.\n$2$. Construct the $(N-2) \\times (N-2)$ matrix $A$. This matrix is constant for all test cases.\n$3$. For the specific charge density $\\rho(x)$, evaluate it at the interior grid points $x_1, \\dots, x_{N-2}$ to form the vector $\\mathbf{\\rho}_{int}$.\n$4$. Construct the right-hand side vector $\\mathbf{b} = -4\\pi(\\Delta x)^2 \\mathbf{\\rho}_{int}$.\n$5$. Solve the linear system $A \\mathbf{v} = \\mathbf{b}$ for the vector of interior potentials $\\mathbf{v}$. A standard linear algebra solver is sufficient.\n$6$. Reconstruct the full solution vector $[v_0, v_1, \\dots, v_{N-1}]$ by prepending and appending the known boundary values of $0$.\n$7$. Identify the grid index corresponding to the query position $x_q$ and extract the computed potential $v_H(x_q)$.\n\nThis procedure is implemented to calculate the required potential values for the four specified cases. The results are then formatted as required.", "answer": "```python\nimport numpy as np\n\ndef solve_bvp(L, N, rho_func, x_q):\n    \"\"\"\n    Solves the 1D Poisson boundary value problem using the finite difference method.\n\n    Args:\n        L (float): The length of the domain [0, L].\n        N (int): The number of grid points (including endpoints).\n        rho_func (callable): A function that takes a numpy array of x values\n                             and returns the charge density rho(x).\n        x_q (float): The query position to find the potential at.\n\n    Returns:\n        float: The value of the Hartree potential v_H at position x_q.\n    \"\"\"\n    # 1. Discretize the domain.\n    # The grid includes N points from 0 to L.\n    x_grid = np.linspace(0.0, L, N)\n    dx = L / (N - 1)\n\n    # The number of interior points where the potential is unknown.\n    num_interior_points = N - 2\n    \n    # 2. Set up the linear system A*v = b for the interior points.\n    # Construct the tridiagonal matrix A for the second derivative operator.\n    # A has -2 on the main diagonal and 1 on the super- and sub-diagonals.\n    A = np.diag(np.full(num_interior_points, -2.0)) + \\\n        np.diag(np.ones(num_interior_points - 1), k=1) + \\\n        np.diag(np.ones(num_interior_points - 1), k=-1)\n    \n    # 3. Construct the right-hand side vector b.\n    # Evaluate the density rho at the interior grid points.\n    interior_x = x_grid[1:-1]\n    rho_values = rho_func(interior_x)\n    \n    # Calculate the vector b from the source term rho(x).\n    b = -4.0 * np.pi * (dx**2) * rho_values\n    \n    # The homogeneous boundary conditions v_H(0)=0 and v_H(L)=0 mean no additional\n    # terms are moved to the right-hand side.\n\n    # 4. Solve the linear system A*v = b for the interior potentials.\n    v_internal = np.linalg.solve(A, b)\n    \n    # 5. Reconstruct the full solution vector v_H including boundaries.\n    v_H = np.zeros(N)\n    v_H[1:-1] = v_internal\n    \n    # 6. Find and return the potential at the query position x_q.\n    # The problem guarantees that x_q is a grid point.\n    # We find its index by scaling and rounding.\n    idx_q = int(round(x_q / dx))\n        \n    return v_H[idx_q]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define global parameters for all test cases.\n    L = 10.0\n    N = 401\n    \n    # Define the four test cases as per the problem description.\n    # Each case has a density function rho(x) and a query position x_q.\n    test_cases = [\n        {\n            # Case 1: Zero density.\n            \"rho_func\": lambda x: np.zeros_like(x), \n            \"x_q\": L / 2\n        },\n        {\n            # Case 2: Uniform density.\n            \"rho_func\": lambda x, rho0=0.01: rho0 * np.ones_like(x), \n            \"x_q\": L / 2\n        },\n        {\n            # Case 3: Cosine density.\n            \"rho_func\": lambda x, rho1=0.02: rho1 * np.cos(np.pi * x / L), \n            \"x_q\": L / 2\n        },\n        {\n            # Case 4: Gaussian density.\n            \"rho_func\": lambda x, A=0.1, a=3.0, sigma=0.5: A * np.exp(-(x - a)**2 / (2 * sigma**2)), \n            \"x_q\": 3.0\n        },\n    ]\n\n    results = []\n    # Iterate through each case, solve the BVP, and store the result.\n    for case in test_cases:\n        v_at_xq = solve_bvp(L, N, case[\"rho_func\"], case[\"x_q\"])\n        results.append(v_at_xq)\n        \n    # Format the results to six decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2405650"}, {"introduction": "With the ability to relate density to potential, we can now assemble the components into a complete, albeit simplified, Density Functional Theory calculation. The essence of the Kohn-Sham method is its self-consistent nature: the potential depends on the density, which is calculated from orbitals that are, in turn, solutions of a Schrödinger-like equation involving that same potential. This practice [@problem_id:2405708] guides you through implementing this entire iterative loop, from setting up an initial guess to mixing densities and checking for convergence, solidifying your understanding of the self-consistent field (SCF) procedure.", "problem": "Implement a complete program that solves a one-dimensional Kohn–Sham problem under a Local Density Approximation (LDA) for exchange–correlation, based on a toy functional for a uniform one-dimensional electron gas with exchange–correlation energy functional of the form\n$$\nE_{xc}[\\rho] = -C \\int \\rho(x)^3 \\, dx,\n$$\nwhere $C$ is a given positive constant, and $\\rho(x)$ is the total electron density. Consider spin-degenerate electrons (degeneracy factor $g_s = 2$) confined by a scalar external potential\n$$\nv_{ext}(x) = \\tfrac{1}{2}\\,\\omega^2 x^2,\n$$\nwith angular frequency $\\omega$, in a finite domain $x \\in [-L, L]$. Use atomic units, where $\\hbar = 1$ and the electron mass $m_e = 1$. The one-dimensional Kohn–Sham equations are\n$$\n\\left(-\\tfrac{1}{2}\\frac{d^2}{dx^2} + v_{ext}(x) + v_{xc}[\\rho](x)\\right)\\,\\varphi_i(x) = \\varepsilon_i\\,\\varphi_i(x),\n$$\nwith Dirichlet boundary conditions $\\varphi_i(-L) = \\varphi_i(L) = 0$, and the spin-unpolarized density obtained from the occupied orbitals $\\varphi_i(x)$ is\n$$\n\\rho(x) = \\sum_{i} f_i \\, |\\varphi_i(x)|^2,\n$$\nwhere $f_i \\in \\{0,1,2\\}$ are occupation numbers consistent with a total electron number $N$ and spin degeneracy $g_s = 2$. The exchange–correlation potential is the functional derivative\n$$\nv_{xc}[\\rho](x) = \\frac{\\delta E_{xc}}{\\delta \\rho(x)} = -3C\\,\\rho(x)^2.\n$$\nDefine the total ground-state energy (with no Hartree term) by\n$$\nE_{tot} = \\sum_i f_i\\,\\varepsilon_i \\;-\\; \\int v_{xc}[\\rho](x)\\,\\rho(x)\\,dx \\;+\\; E_{xc}[\\rho].\n$$\nAll quantities must be expressed in atomic units, and all energies must be reported in Hartree (Ha).\n\nYour program must:\n- For each specified test case, find a self-consistent solution for $\\rho(x)$, the occupied Kohn–Sham orbitals $\\varphi_i(x)$, and their eigenvalues $\\varepsilon_i$ at zero temperature.\n- Use a uniform real-space grid with $M$ points on $[-L,L]$, with Dirichlet boundary conditions at the endpoints and the standard second-order central finite-difference representation of the kinetic-energy operator $-\\tfrac{1}{2}\\frac{d^2}{dx^2}$.\n- Conserve the total number of electrons $N$ in the density at every iteration.\n- Use a simple density mixing parameter $\\alpha \\in (0,1]$ for the fixed-point iteration of the self-consistent cycle and stop when the maximum absolute pointwise change in $\\rho(x)$ between two consecutive iterations is below a tolerance $\\mathrm{tol}$, or when the maximum number of iterations $\\mathrm{max\\_iter}$ is reached.\n- For each test case, output the converged total energy $E_{tot}$ as a floating-point number rounded to exactly $6$ decimal places.\n\nTest suite:\n- Case $1$: $N = 2$, $\\omega = 0.5$, $L = 10.0$, $M = 300$, $\\alpha = 0.5$, $\\mathrm{tol} = 10^{-6}$, $\\mathrm{max\\_iter} = 200$, $C = 0.05$.\n- Case $2$: $N = 1$, $\\omega = 0.2$, $L = 12.0$, $M = 320$, $\\alpha = 0.5$, $\\mathrm{tol} = 10^{-6}$, $\\mathrm{max\\_iter} = 200$, $C = 0.05$.\n- Case $3$: $N = 3$, $\\omega = 1.0$, $L = 8.0$, $M = 280$, $\\alpha = 0.5$, $\\mathrm{tol} = 10^{-6}$, $\\mathrm{max\\_iter} = 200$, $C = 0.05$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example\n$[E_1,E_2,E_3]$,\nwhere each $E_k$ is the total energy for case $k$ rounded to exactly $6$ decimal places. The units of the printed energies must be Hartree (Ha), but no unit symbol should be printed.\n\nAngle units are not applicable in this problem. Percentages are not applicable in this problem. All numerical answers must be provided as floating-point numbers in Hartree (Ha) with exactly $6$ digits after the decimal point.", "solution": "The problem is well-posed and scientifically grounded. It presents a standard exercise in computational physics: the implementation of a self-consistent field (SCF) cycle to solve the one-dimensional Kohn–Sham equations for a model system under the Local Density Approximation (LDA). All parameters, equations, and numerical procedures are clearly defined.\n\nThe solution is found by iteratively solving the Kohn–Sham equations until a self-consistent electron density is obtained. The methodology comprises the following stages: discretization of the problem, implementation of the SCF algorithm, and calculation of the total energy upon convergence.\n\n**1. Discretization and Hamiltonian Construction**\n\nThe problem is defined on a continuous domain $x \\in [-L, L]$. For a numerical solution, we discretize this domain into a uniform grid of $M$ points $x_j$, where $j=0, 1, \\dots, M-1$, with a grid spacing of $dx = 2L/(M-1)$. The Dirichlet boundary conditions, $\\varphi_i(-L) = \\varphi_i(L) = 0$, imply that the wavefunctions are non-zero only on the $M_{int} = M-2$ interior points of the grid.\n\nThe Kohn–Sham equation is an eigenvalue problem for the effective Hamiltonian operator $H_{KS}$:\n$$\nH_{KS}\\,\\varphi_i(x) = \\left(-\\tfrac{1}{2}\\frac{d^2}{dx^2} + v_{eff}(x)\\right)\\,\\varphi_i(x) = \\varepsilon_i\\,\\varphi_i(x)\n$$\nThe kinetic energy operator, $T = -\\tfrac{1}{2}\\frac{d^2}{dx^2}$, is approximated using a second-order central finite difference scheme. This results in a symmetric tridiagonal matrix representation of size $M_{int} \\times M_{int}$. The diagonal elements are $T_{jj} = \\frac{1}{dx^2}$ and the off-diagonal elements are $T_{j, j\\pm 1} = -\\frac{1}{2dx^2}$.\n\nThe effective potential, $v_{eff}(x) = v_{ext}(x) + v_{xc}(x)$, is a local potential that depends only on the value of the density $\\rho$ at point $x$. On the grid, its matrix representation is a diagonal matrix $V$ with elements $V_{jj} = v_{eff}(x_j)$. The specific potentials are:\n$$\nv_{ext}(x_j) = \\tfrac{1}{2}\\omega^2 x_j^2\n$$\n$$\nv_{xc}(x_j) = -3C \\rho(x_j)^2\n$$\nThe full Kohn–Sham Hamiltonian matrix is $H = T + V$. Since both $T$ and $V$ are symmetric, and $T$ is tridiagonal while $V$ is diagonal, the resulting matrix $H$ is also a real, symmetric, tridiagonal matrix.\n\n**2. Self-Consistent Field (SCF) Algorithm**\n\nThe core of the solution is the iterative SCF procedure, which finds a density $\\rho(x)$ that generates an effective potential $v_{eff}(x)$ whose ground state, in turn, reproduces the same density $\\rho(x)$.\n\n**Step 0: Initialization**\nAn initial guess for the electron density, $\\rho_{in}^{(0)}(x)$, is required. A physically motivated choice is the ground-state density of the non-interacting system, which is obtained by solving the Kohn–Sham equations once with the exchange–correlation term set to zero ($C=0$).\n\n**Step $k$: Iterative Refinement**\nFor each iteration $k=1, 2, \\dots, \\mathrm{max\\_iter}$:\n1.  **Construct Hamiltonian**: Build the Kohn–Sham matrix $H^{(k)}$ using the input density from the previous step, $\\rho_{in}^{(k-1)}(x)$, to compute the exchange–correlation potential $v_{xc}^{(k-1)}(x) = -3C(\\rho_{in}^{(k-1)}(x))^2$.\n2.  **Solve Eigenproblem**: Solve the matrix eigenvalue problem $H^{(k)}\\vec{\\varphi}_i^{(k)} = \\varepsilon_i^{(k)}\\vec{\\varphi}_i^{(k)}$. Since $H^{(k)}$ is a real symmetric tridiagonal matrix, this can be done efficiently. This yields a set of eigenvalues $\\varepsilon_i^{(k)}$ and their corresponding eigenvectors $\\vec{\\varphi}_i^{(k)}$. The eigenvectors must be normalized to represent continuous wavefunctions, such that the integral $\\int |\\varphi_i(x)|^2 dx = 1$ is approximated by the sum $\\sum_j |\\varphi_{i,j}|^2 dx = 1$. This requires scaling the eigenvectors from the numerical solver by a factor of $1/\\sqrt{dx}$.\n3.  **Compute New Density**: Determine the occupation numbers $f_i$ based on the total electron number $N$ and spin degeneracy $g_s=2$. At zero temperature, orbitals are filled from the lowest energy upwards. The number of occupied orbitals is $N_{occ} = \\lceil N/g_s \\rceil = \\lceil N/2 \\rceil$. The first $N_{pairs} = \\lfloor N/g_s \\rfloor = \\lfloor N/2 \\rfloor$ orbitals are doubly occupied ($f_i=2$), and if $N$ is odd, the next orbital is singly occupied ($f_i=1$). The new density is then computed as:\n    $$\n    \\rho_{out}^{(k)}(x) = \\sum_{i=0}^{N_{occ}-1} f_i |\\varphi_i^{(k)}(x)|^2\n    $$\n    As required, this density is explicitly normalized at each step to conserve the total number of electrons: $\\int \\rho_{out}^{(k)}(x) dx = N$.\n4.  **Check Convergence**: The process is considered converged if the maximum absolute pointwise difference between the new and old densities is below a tolerance $\\mathrm{tol}$:\n    $$\n    \\max_j |\\rho_{out}^{(k)}(x_j) - \\rho_{in}^{(k-1)}(x_j)| < \\mathrm{tol}\n    $$\n5.  **Density Mixing**: If convergence is not reached, a new input density for the next iteration is formed by simple mixing:\n    $$\n    \\rho_{in}^{(k)}(x) = (1-\\alpha)\\rho_{in}^{(k-1)}(x) + \\alpha\\rho_{out}^{(k)}(x)\n    $$\n    where $\\alpha$ is the mixing parameter.\n\n**3. Total Energy Calculation**\n\nUpon convergence, the final self-consistent density $\\rho(x)$, orbitals $\\varphi_i(x)$, and eigenvalues $\\varepsilon_i$ are used to calculate the total ground-state energy. The formula provided is:\n$$\nE_{tot} = \\sum_i f_i \\varepsilon_i - \\int v_{xc}[\\rho](x) \\rho(x) dx + E_{xc}[\\rho]\n$$\nSubstituting $v_{xc}[\\rho](x) = -3C\\rho(x)^2$ and $E_{xc}[\\rho] = -C\\int\\rho(x)^3 dx$, the expression simplifies:\n$$\nE_{tot} = \\sum_i f_i \\varepsilon_i - \\int (-3C \\rho(x)^3) dx + \\left(-C \\int \\rho(x)^3 dx\\right) = \\sum_i f_i \\varepsilon_i + 2C \\int \\rho(x)^3 dx\n$$\nThe sum runs over the occupied orbitals, and the integral is computed numerically over the grid using the converged density $\\rho(x)$. This final value $E_{tot}$ is reported in Hartree atomic units.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve_case(N, omega, L, M, alpha, tol, max_iter, C):\n    \"\"\"\n    Solves the 1D Kohn-Sham problem for a single test case.\n    \"\"\"\n    # 1. Grid setup\n    x = np.linspace(-L, L, M)\n    dx = x[1] - x[0]\n    x_int = x[1:-1]\n    M_int = M - 2\n\n    # 2. Kinetic energy operator (off-diagonal part is constant)\n    # The factor of -0.5 is for the kinetic energy operator (-1/2) * d^2/dx^2\n    off_diag_T = -0.5 / dx**2 * np.ones(M_int - 1)\n\n    # 3. External potential (constant)\n    v_ext = 0.5 * omega**2 * x_int**2\n    \n    # 4. Initial guess for density from non-interacting system (C=0)\n    # The diagonal of the non-interacting Hamiltonian H_0 = T + v_ext\n    diag_H0 = 1.0 / dx**2 + v_ext\n    eps0, eigvecs0 = eigh_tridiagonal(diag_H0, off_diag_T)\n    \n    # Occupation numbers\n    num_pairs = N // 2\n    num_single = N % 2\n    \n    # Normalize eigenvectors to represent continuous wavefunctions\n    psis_norm_0 = eigvecs0 / np.sqrt(dx)\n    \n    # Construct initial density rho_in\n    rho_in = np.zeros(M_int)\n    for i in range(num_pairs):\n        rho_in += 2.0 * np.abs(psis_norm_0[:, i])**2\n    if num_single == 1:\n        rho_in += np.abs(psis_norm_0[:, num_pairs])**2\n        \n    # Conserve electron number N in initial density\n    current_N = np.sum(rho_in) * dx\n    if current_N > 1e-9: # Avoid division by zero\n        rho_in *= N / current_N\n\n    # 5. Self-Consistent Field (SCF) loop\n    converged = False\n    for iteration in range(max_iter):\n        # Calculate exchange-correlation potential from rho_in\n        v_xc = -3.0 * C * rho_in**2\n        \n        # Effective potential\n        v_eff = v_ext + v_xc\n        \n        # Build and solve KS Hamiltonian\n        diag_H = 1.0 / dx**2 + v_eff\n        eps, eigvecs = eigh_tridiagonal(diag_H, off_diag_T)\n        \n        # Normalize eigenvectors\n        psis_norm = eigvecs / np.sqrt(dx)\n        \n        # Calculate output density rho_out\n        rho_out = np.zeros(M_int)\n        for i in range(num_pairs):\n            rho_out += 2.0 * np.abs(psis_norm[:, i])**2\n        if num_single == 1:\n            rho_out += np.abs(psis_norm[:, num_pairs])**2\n            \n        # Conserve electron number N in output density\n        current_N = np.sum(rho_out) * dx\n        if current_N > 1e-9:\n            rho_out *= N / current_N\n\n        # Check for convergence\n        diff = np.max(np.abs(rho_out - rho_in))\n        if diff < tol:\n            rho_in = rho_out # Use the latest density for energy calculation\n            converged = True\n            break\n            \n        # Mix densities for the next iteration\n        rho_in = (1 - alpha) * rho_in + alpha * rho_out\n    \n    # 6. Post-convergence calculation of total energy\n    # The converged density is rho_in\n    \n    # Sum of occupied eigenvalues (Kohn-Sham kinetic energy)\n    num_orbitals = num_pairs + num_single\n    occupied_eps = eps[:num_orbitals]\n    occupations = np.full(num_pairs, 2.0)\n    if num_single == 1:\n        occupations = np.append(occupations, 1.0)\n    sum_fi_epsi = np.sum(occupations * occupied_eps)\n    \n    # Use the simplified energy formula: E_tot = sum(f_i*eps_i) + 2*C*integral(rho^3 dx)\n    # The integral is computed as a sum over the grid points\n    integral_rho3 = np.sum(rho_in**3) * dx\n    E_tot = sum_fi_epsi + 2.0 * C * integral_rho3\n\n    return E_tot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, omega, L, M, alpha, tol, max_iter, C)\n        (2, 0.5, 10.0, 300, 0.5, 1e-6, 200, 0.05),\n        (1, 0.2, 12.0, 320, 0.5, 1e-6, 200, 0.05),\n        (3, 1.0, 8.0, 280, 0.5, 1e-6, 200, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, omega, L, M, alpha, tol, max_iter, C = case\n        total_energy = solve_case(N, omega, L, M, alpha, tol, max_iter, C)\n        results.append(f\"{total_energy:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2405708"}, {"introduction": "In practical applications, achieving self-consistency is not always straightforward, as simple density mixing can lead to oscillations or fail to converge. This often occurs in systems with a small energy gap between the highest occupied and lowest unoccupied molecular orbitals (HOMO-LUMO gap). This final exercise [@problem_id:2405696] introduces level shifting, an advanced technique that stabilizes the SCF cycle by artificially increasing this gap, addressing a common numerical challenge and providing a glimpse into the robust algorithms required in modern electronic structure software.", "problem": "Implement a self-consistent Kohn–Sham cycle with level shifting for a minimal lattice model that mimics a difficult convergence scenario. The implementation must be a complete, runnable program that constructs a discrete Kohn–Sham effective Hamiltonian in an orthonormal basis and iterates to self-consistency using linear density mixing and level shifting on the unoccupied subspace.\n\nStart from the following foundations:\n- The Kohn–Sham equations define single-particle orbitals as eigenvectors of an effective Hamiltonian built from a core one-electron part plus a potential functional of the electronic density. In a finite orthonormal basis, write the core Hamiltonian as a real symmetric matrix $H_{\\text{core}} \\in \\mathbb{R}^{N \\times N}$, the density matrix as $P \\in \\mathbb{R}^{N \\times N}$, and the effective Hamiltonian as $F[n] = H_{\\text{core}} + V[n]$, where $V[n]$ is diagonal in the site basis with entries depending on the site density $n_i = P_{ii}$.\n- Consider a one-dimensional tight-binding chain with $N$ sites, nearest-neighbor hopping amplitude $t > 0$, and zero on-site energy. The core Hamiltonian is given by $(H_{\\text{core}})_{i,i} = 0$ and $(H_{\\text{core}})_{i,i+1} = (H_{\\text{core}})_{i+1,i} = -t$ for $i = 1,\\dots,N-1$, with all other elements zero. All quantities are in atomic units.\n- Use a spin-restricted closed-shell model with an even number of electrons $N_e$, so the number of occupied spatial orbitals is $M = N_e/2$. The initial density can be built from an initial effective Hamiltonian obtained by assuming a uniform density $n_i^{(0)} = N_e/N$.\n- Approximate electron interaction by an on-site Hartree term with coupling $U > 0$. For a given spin-summed density vector $n \\in \\mathbb{R}^N$ with components $n_i = P_{ii}$, define a diagonal potential $V[n]$ by $V_{ii}[n] = U \\, n_i/2$. The corresponding total energy (with double-counting removed) is\n$$\nE_{\\text{tot}}[P] = \\operatorname{Tr}\\!\\big(P H_{\\text{core}}\\big) + \\operatorname{Tr}\\!\\big(P V[n]\\big) - \\frac{U}{4}\\sum_{i=1}^N n_i^2,\n$$\nwith $n_i = P_{ii}$ and $P = 2 \\sum_{k=1}^M \\vert \\phi_k \\rangle \\langle \\phi_k \\vert$ for the $M$ lowest-energy eigenvectors $\\phi_k$ of the effective Hamiltonian used in that iteration.\n- Implement linear density mixing: given a trial density matrix $P^{(k)}$ and the density matrix $P^{\\text{KS}}$ constructed from the $M$ lowest eigenvectors at the current iteration, update $P^{(k+1)} = (1-\\alpha) P^{(k)} + \\alpha P^{\\text{KS}}$ with a mixing parameter $\\alpha \\in (0,1]$.\n- Implement level shifting with shift value $\\Delta \\ge 0$ using a projector onto the virtual (unoccupied) subspace from the previous iteration. If $C_{\\text{occ}}^{(k-1)} \\in \\mathbb{R}^{N \\times M}$ holds the occupied eigenvectors (as columns) from iteration $k-1$, define the virtual-space projector as\n$$\nQ_{\\text{virt}}^{(k-1)} = I - C_{\\text{occ}}^{(k-1)} \\left(C_{\\text{occ}}^{(k-1)}\\right)^{\\mathsf{T}},\n$$\nand diagonalize the shifted Hamiltonian\n$$\nF_{\\text{shift}}^{(k)} = F\\!\\left[n^{(k)}\\right] + \\Delta \\, Q_{\\text{virt}}^{(k-1)}\n$$\nto obtain the current $C^{(k)}$ and its occupied block $C_{\\text{occ}}^{(k)}$. For $k=0$, obtain $C_{\\text{occ}}^{(0)}$ by diagonalizing the unshifted $F[n^{(0)}]$ built from the uniform initial density.\n- Use the Frobenius norm as the convergence metric: declare convergence if\n$$\n\\left\\| P^{(k+1)} - P^{(k)} \\right\\|_{\\mathrm{F}} < \\varepsilon,\n$$\nfor a specified tolerance $\\varepsilon > 0$.\n\nYour program must:\n1. Construct $H_{\\text{core}}$ for a chain of $N$ sites with parameters $t$ and $U$ specified below.\n2. Initialize with a uniform density $n_i^{(0)} = N_e/N$, build $F[n^{(0)}]$, diagonalize to get $C^{(0)}$ and $P^{(0)}$, then iterate the self-consistent cycle with linear mixing and level shifting as above until convergence or a maximum number of iterations is reached.\n3. On convergence, compute $E_{\\text{tot}}$ using the unshifted $F[n]$ ingredients, with the double-counting correction as specified. All energies must be expressed in Hartree (atomic units). Report energies rounded to eight decimal places.\n4. If the iteration does not converge within the maximum number of iterations, still return the last computed energy rounded to eight decimal places and the iteration count used; the energy is to be computed from the final $P$ reached by the loop.\n\nUse the following fixed model parameters for all test cases:\n- Number of sites: $N = 8$.\n- Number of electrons: $N_e = 8$ (closed shell, so $M = 4$ occupied spatial orbitals).\n- Hopping amplitude: $t = 1.0$.\n- On-site interaction: $U = 4.0$.\n- Convergence tolerance: $\\varepsilon = 10^{-8}$.\n- Maximum number of iterations: $200$.\n\nImplement and run the self-consistent cycle for the following test suite, where each test case is a pair $(\\Delta, \\alpha)$:\n- Test A (happy path, no level shift): $(\\Delta, \\alpha) = (0.0, 0.5)$.\n- Test B (difficult mixing stabilized by level shift): $(\\Delta, \\alpha) = (1.5, 1.0)$.\n- Test C (strong level shift): $(\\Delta, \\alpha) = (3.0, 0.7)$.\n- Test D (boundary mixing, no level shift): $(\\Delta, \\alpha) = (0.0, 1.0)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test, append the converged total energy in Hartree (rounded to eight decimal places) followed by the integer number of iterations used to reach the stopping criterion. The order must be Test A, Test B, Test C, Test D. For example, the output must have the form\n\"[E_A,it_A,E_B,it_B,E_C,it_C,E_D,it_D]\"\nwhere $E_{\\text{X}}$ is a float with eight digits after the decimal point and $it_{\\text{X}}$ is an integer.", "solution": "The problem requires the implementation of a self-consistent Kohn-Sham cycle for a one-dimensional tight-binding model. The validity of the problem statement is confirmed as it is scientifically grounded in established principles of computational physics, is well-posed with all necessary parameters and algorithms defined, and is expressed in objective, formal language. We will now construct the solution.\n\nThe system is a chain of $N$ sites described by an orthonormal basis. The electronic structure is determined by solving the Kohn-Sham equations iteratively. The core of the iteration is the construction and diagonalization of an effective single-particle Hamiltonian, or Kohn-Sham matrix, $F$.\n\nThe core Hamiltonian, $H_{\\text{core}}$, describes the kinetic energy of the electrons (hopping between adjacent sites) and any static external potential. For a chain with $N=8$ sites, nearest-neighbor hopping amplitude $t=1.0$, and zero on-site energies, $H_{\\text{core}}$ is an $8 \\times 8$ real symmetric matrix with elements:\n$$\n(H_{\\text{core}})_{ij} = \n\\begin{cases}\n-t & \\text{if } |i-j| = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nwhere indices $i, j$ range from $1$ to $N$.\n\nThe electron-electron interaction is approximated by an on-site Hartree potential. The potential experienced by an electron at site $i$ is proportional to the electron density $n_i$ at that site. The spin-summed density $n_i$ is the diagonal element $P_{ii}$ of the density matrix $P$. The potential matrix $V[n]$ is diagonal, with entries:\n$$\nV_{ii}[n] = \\frac{U}{2} n_i\n$$\nwhere $U=4.0$ is the on-site interaction strength. The factor of $1/2$ is conventional for the Hartree potential functional derivative.\n\nThe total Kohn-Sham matrix for a given density $n$ is $F[n] = H_{\\text{core}} + V[n]$. The self-consistent cycle proceeds as follows.\n\n**Step 0: Initialization**\nThe iteration must begin with an initial guess for the electron density. A common and simple choice is a uniform density distribution:\n$$\nn_i^{(0)} = \\frac{N_e}{N} = \\frac{8}{8} = 1.0 \\quad \\forall i=1, \\dots, N\n$$\nUsing this density, we construct the initial Kohn-Sham matrix $F^{(0)} = F[n^{(0)}]$. This matrix is diagonalized to find its eigenvalues (orbital energies) and eigenvectors (Kohn-Sham orbitals). Since we have $N_e=8$ electrons in a spin-restricted model, we occupy the $M = N_e/2 = 4$ orbitals with the lowest energies. These $M$ eigenvectors form the columns of the matrix $C_{\\text{occ}}^{(0)} \\in \\mathbb{R}^{N \\times M}$. This set of orbitals provides the starting point for the iterative cycle. The initial density matrix to begin the main loop is formed as $P^{(0)} = 2 C_{\\text{occ}}^{(0)} (C_{\\text{occ}}^{(0)})^{\\mathsf{T}}$. The factor of $2$ accounts for spin degeneracy (two electrons per spatial orbital).\n\n**Step $k$: Iterative Refinement ($k \\ge 1$)**\nAt the beginning of iteration $k$, we have the input density matrix $P^{(k-1)}$ and the occupied orbitals $C_{\\text{occ}}^{(k-1)}$ from the previous step. The process is:\n1.  **Construct Hamiltonian**: Extract the site densities $n_i^{(k-1)} = (P^{(k-1)})_{ii}$ and build the current Kohn-Sham matrix $F^{(k)} = F[n^{(k-1)}]$.\n2.  **Apply Level Shifting**: To aid convergence in difficult cases, the Hamiltonian is modified by adding a level-shifting term. This term penalizes the mixing of occupied and virtual (unoccupied) orbitals. It is constructed using the projector onto the virtual subspace of the *previous* iteration, $Q_{\\text{virt}}^{(k-1)} = I - C_{\\text{occ}}^{(k-1)} (C_{\\text{occ}}^{(k-1)})^{\\mathsf{T}}$, where $I$ is the identity matrix. The shifted Hamiltonian is:\n    $$\n    F_{\\text{shift}}^{(k)} = F^{(k)} + \\Delta \\, Q_{\\text{virt}}^{(k-1)}\n    $$\n    The shift $\\Delta \\ge 0$ raises the energy of the virtual orbitals, stabilizing the calculation. For $\\Delta=0$, the standard, unshifted Hamiltonian is used.\n3.  **Diagonalize**: Solve the eigenvalue problem for the (potentially shifted) Hamiltonian: $F_{\\text{shift}}^{(k)} C^{(k)} = C^{(k)} E^{(k)}$, where $C^{(k)}$ is the matrix of new eigenvectors and $E^{(k)}$ is the diagonal matrix of new eigenvalues.\n4.  **Form New Density**: Select the $M$ eigenvectors corresponding to the $M$ lowest eigenvalues to form the new matrix of occupied orbitals, $C_{\\text{occ}}^{(k)}$. From this, construct the new \"output\" density matrix, $P_{\\text{KS}}^{(k)} = 2 C_{\\text{occ}}^{(k)} (C_{\\text{occ}}^{(k)})^{\\mathsf{T}}$.\n5.  **Mix Densities**: To prevent large oscillations between iterations, the new input density matrix for the next cycle, $P^{(k)}$, is formed by linearly mixing the old input and new output matrices:\n    $$\n    P^{(k)} = (1-\\alpha) P^{(k-1)} + \\alpha P_{\\text{KS}}^{(k)}\n    $$\n    where $\\alpha \\in (0, 1]$ is the mixing parameter.\n6.  **Check Convergence**: The cycle is repeated until the change in the density matrix is negligible. Convergence is declared when the Frobenius norm of the difference between successive density matrices falls below a tolerance $\\varepsilon = 10^{-8}$:\n    $$\n    \\left\\| P^{(k)} - P^{(k-1)} \\right\\|_{\\mathrm{F}} < \\varepsilon\n    $$\nThe loop also terminates if a maximum of $200$ iterations is reached.\n\n**Final Energy Calculation**\nUpon convergence at iteration $k_{final}$, the final density matrix is $P_{final} = P^{(k_{final})}$. The total electronic energy must be calculated using the final density and the *unshifted* Hamiltonian ingredients to avoid including the artificial level shift. The total energy expression, which corrects for the double-counting of electron-electron interactions inherent in the sum of orbital energies, is given by:\n$$\nE_{\\text{tot}}[P_{final}] = \\operatorname{Tr}\\!\\big(P_{final} H_{\\text{core}}\\big) + \\operatorname{Tr}\\!\\big(P_{final} V[n_{final}]\\big) - \\frac{U}{4}\\sum_{i=1}^N (n_{final,i})^2\n$$\nwhere $n_{final,i} = (P_{final})_{ii}$. This expression is evaluated to obtain the final result for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the SCF calculations for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test A (happy path, no level shift)\n        (0.0, 0.5),\n        # Test B (difficult mixing stabilized by level shift)\n        (1.5, 1.0),\n        # Test C (strong level shift)\n        (3.0, 0.7),\n        # Test D (boundary mixing, no level shift)\n        (0.0, 1.0),\n    ]\n\n    # Fixed model parameters\n    params = {\n        'N': 8,              # Number of sites\n        'Ne': 8,             # Number of electrons\n        't': 1.0,            # Hopping amplitude\n        'U': 4.0,            # On-site interaction\n        'eps': 1e-8,         # Convergence tolerance\n        'max_iter': 200,     # Maximum number of iterations\n    }\n\n    results = []\n    for delta, alpha in test_cases:\n        energy, iters = run_scf(delta, alpha, params)\n        results.extend([energy, iters])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" if isinstance(res, float) else str(res) for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_scf(delta, alpha, params):\n    \"\"\"\n    Performs a self-consistent Kohn-Sham calculation for a given set of parameters.\n\n    Args:\n        delta (float): Level shifting parameter.\n        alpha (float): Linear mixing parameter.\n        params (dict): Dictionary of fixed model parameters.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The converged total energy, rounded to 8 decimal places.\n            - int: The number of iterations performed.\n    \"\"\"\n    # Unpack parameters\n    N = params['N']\n    Ne = params['Ne']\n    t = params['t']\n    U = params['U']\n    eps = params['eps']\n    max_iter = params['max_iter']\n    \n    # Number of occupied spatial orbitals\n    M = Ne // 2\n\n    # Step 1: Construct the core Hamiltonian H_core\n    H_core = np.zeros((N, N))\n    for i in range(N - 1):\n        H_core[i, i + 1] = H_core[i + 1, i] = -t\n\n    # Step 2: Initialization (Step 0)\n    # Start with a uniform density guess\n    n_vec_0 = np.full(N, Ne / N)\n    \n    # Build initial potential and Kohn-Sham matrix\n    V_0 = np.diag(U * n_vec_0 / 2.0)\n    F_0 = H_core + V_0\n\n    # Diagonalize to get initial orbitals\n    _, C_0 = linalg.eigh(F_0)\n    C_occ_prev = C_0[:, :M]\n    \n    # Form initial density matrix for the SCF loop\n    P_prev = 2.0 * C_occ_prev @ C_occ_prev.T\n    \n    # Step 3: Start the SCF cycle\n    it = 0\n    for i in range(1, max_iter + 1):\n        it = i\n        \n        # Get density vector from previous density matrix\n        n_vec = np.diag(P_prev)\n        \n        # Build Kohn-Sham matrix F[n]\n        V_mat = np.diag(U * n_vec / 2.0)\n        F = H_core + V_mat\n        \n        # Build virtual space projector Q_virt\n        Q_virt = np.eye(N) - C_occ_prev @ C_occ_prev.T\n        \n        # Build shifted Hamiltonian\n        F_shift = F + delta * Q_virt\n        \n        # Diagonalize F_shift to get new orbitals\n        _, C_curr = linalg.eigh(F_shift)\n        C_occ_curr = C_curr[:, :M]\n        \n        # Form new \"output\" density matrix\n        P_out = 2.0 * C_occ_curr @ C_occ_curr.T\n        \n        # Linear mixing to get new \"input\" density matrix\n        P_new = (1.0 - alpha) * P_prev + alpha * P_out\n        \n        # Check for convergence\n        diff = np.linalg.norm(P_new - P_prev, 'fro')\n        \n        # Update for next iteration\n        P_prev = P_new\n        C_occ_prev = C_occ_curr\n        \n        if diff < eps:\n            break\n            \n    # Step 4: Calculate final total energy\n    P_final = P_prev\n    n_final = np.diag(P_final)\n    V_final = np.diag(U * n_final / 2.0)\n    \n    # E_tot = Tr(P H_core) + Tr(P V) - Double_counting_correction\n    E_core = np.trace(P_final @ H_core)\n    E_pot = np.trace(P_final @ V_final)\n    E_dc = (U / 4.0) * np.sum(n_final**2)\n    \n    E_total = E_core + E_pot - E_dc\n\n    return round(E_total, 8), it\n\nsolve()\n```", "id": "2405696"}]}