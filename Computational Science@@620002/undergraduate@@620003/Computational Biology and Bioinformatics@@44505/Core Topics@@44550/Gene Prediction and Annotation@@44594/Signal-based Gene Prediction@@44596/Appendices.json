{"hands_on_practices": [{"introduction": "The complexity of the eukaryotic genome arises not just from the number of genes, but from how those genes are expressed. This first practice explores the immense combinatorial space created by alternative splicing, a key mechanism for generating protein diversity. By calculating the number of possible transcripts from a gene with a set of optional 'cassette' exons, you will develop a concrete feel for the scale of the challenge that gene prediction algorithms must address [@problem_id:2429057].", "problem": "A signal-based gene prediction model assigns valid splice donor and acceptor signals to each exon boundary in a eukaryotic gene. Consider a gene with a fixed promoter and a fixed polyadenylation site, whose transcribed region consists of two constitutive exons flanking a segment that contains $N$ cassette exons. A cassette exon is defined here as an exon that may be either included in the mature messenger ribonucleic acid (mRNA) or omitted by splicing, without altering the order of exons or the positions of constitutive exons. Assume that, conditioned on the presence of splice signals, the inclusion or skipping of each cassette exon is an independent decision made by the splicing machinery, and that all resulting spliced transcripts are distinct with respect to their exon content. Ignore any reading-frame constraints, nonsense-mediated decay, or other downstream selection effects.\n\nUnder these assumptions, what is the total number of distinct spliced mRNA transcript variants that can be generated from this gene as a function of $N$? Express your answer as a closed-form analytic expression in terms of $N$. No rounding is required.", "solution": "The problem statement will first be subjected to a rigorous validation process.\n\nStep 1: Extract Givens\nThe givens are listed verbatim from the problem statement:\n- A gene has a \"fixed promoter and a fixed polyadenylation site\".\n- The transcribed region consists of \"two constitutive exons flanking a segment that contains $N$ cassette exons\".\n- A cassette exon is an exon that \"may be either included in the mature messenger ribonucleic acid (mRNA) or omitted by splicing\".\n- The \"inclusion or skipping of each cassette exon is an independent decision\".\n- \"all resulting spliced transcripts are distinct with respect to their exon content\".\n- The problem requires ignoring \"any reading-frame constraints, nonsense-mediated decay, or other downstream selection effects\".\n- The objective is to find \"the total number of distinct spliced mRNA transcript variants\" as a \"closed-form analytic expression in terms of $N$\".\n\nStep 2: Validate Using Extracted Givens\nThe problem is evaluated against the established criteria for validity.\n\n- **Scientific Grounding**: The problem is scientifically grounded. The concepts of promoters, polyadenylation, constitutive exons, cassette exons, and alternative splicing are fundamental principles in molecular biology and bioinformatics. The model presented is a simplified but standard combinatorial approach to modeling the outcomes of alternative splicing. It does not violate established scientific facts.\n- **Well-Posedness**: The problem is well-posed. It defines a discrete set of components ($N$ cassette exons) and a binary choice for each (inclusion or exclusion). The assumption of independence simplifies the problem into a standard combinatorial counting exercise, which has a unique and meaningful solution.\n- **Objectivity**: The problem is stated in objective, formal language. It is free of subjective claims or ambiguity.\n- **Completeness and Consistency**: The problem is self-contained. The assumptions (e.g., independence, disregard for downstream effects) are explicitly stated, providing all necessary information to construct a solution. There are no internal contradictions.\n\nThe problem does not exhibit any of the flaws that would render it invalid. It is a formalizable, relevant, and well-structured problem in computational biology.\n\nStep 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\nThe problem asks for the total number of distinct mRNA transcripts that can be produced from a gene with a specific architecture. This is a problem of combinatorics. The structure of the gene involves two types of exons: constitutive and cassette.\n\nThe two constitutive exons are, by definition, always present in any mature mRNA transcript produced from this gene. Let us denote the upstream constitutive exon as $E_{C1}$ and the downstream one as $E_{C2}$. Since their inclusion is mandatory, they do not contribute to the variability of the transcript population. For each of these exons, there is only one possibility: inclusion. The number of choices for the constitutive part of the transcript is therefore $1 \\times 1 = 1$.\n\nThe segment between the constitutive exons contains $N$ cassette exons. Let us denote these exons as $E_{K1}, E_{K2}, \\dots, E_{KN}$. A cassette exon is defined as an optional unit; it can either be included in the final transcript or be excluded (skipped). Therefore, for each cassette exon $E_{Ki}$ where $i \\in \\{1, 2, \\dots, N\\}$, there are exactly $2$ possible outcomes:\n1.  Exon $E_{Ki}$ is included.\n2.  Exon $E_{Ki}$ is excluded.\n\nThe problem states that the splicing decision for each cassette exon is an \"independent decision\". This is a critical piece of information. In combinatorics, the total number of outcomes for a sequence of independent events is the product of the number of outcomes for each individual event. This is known as the multiplication principle or the rule of product.\n\nApplying this principle to the $N$ cassette exons:\n- For exon $E_{K1}$, there are $2$ choices.\n- For exon $E_{K2}$, there are $2$ choices, regardless of the choice for $E_{K1}$.\n- This pattern continues for all $N$ cassette exons.\n- For exon $E_{KN}$, there are $2$ choices, regardless of the choices for the preceding $N-1$ exons.\n\nThe total number of distinct combinations of included and excluded cassette exons is the product of the number of choices for each of the $N$ exons.\nLet $T$ be the total number of distinct transcript variants.\n$$T = \\underbrace{2 \\times 2 \\times \\dots \\times 2}_{N \\text{ times}}$$\n\nThis product is equivalent to $2$ raised to the power of $N$.\n$$T = 2^{N}$$\n\nThe problem also states that \"all resulting spliced transcripts are distinct with respect to their exon content\". This confirms that each unique combination of exon inclusion/exclusion choices results in a unique transcript variant, so no two combinations are redundant. The presence of the fixed constitutive exons does not alter this count, as they form a constant background in every single one of these $2^{N}$ variants.\n\nTherefore, the total number of distinct spliced mRNA transcript variants, expressed as a function of the number of cassette exons $N$, is $2^{N}$. This is the closed-form analytic expression required.", "answer": "$$\\boxed{2^{N}}$$", "id": "2429057"}, {"introduction": "To navigate the vast search space of potential gene structures, we need a way to score the key signals that define them, such as splice sites. This practice delves into the heart of many signal models: the Position Weight Matrix (PWM). You will perform an *in silico* perturbation analysis to quantify how mutations affect a splice site's score, revealing which positions are most informative and functionally constrained [@problem_id:2429077].", "problem": "You are given a finite alphabet $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ and a windowed sequence model of length $L$ around a putative splice site. For a sequence $s$ of length $L$ over $\\Sigma$, its score $S(s)$ under a Position Weight Matrix (PWM) model is defined by\n$$\nS(s) \\;=\\; \\sum_{i=1}^{L} \\ln\\!\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right),\n$$\nwhere $b_i \\in \\Sigma$ is the base at position $i$ in $s$, $P_{i,\\cdot}$ is the position-specific multinomial distribution over $\\Sigma$ for position $i$, $Q_{\\cdot}$ is the background multinomial distribution over $\\Sigma$, and $\\ln(\\cdot)$ denotes the natural logarithm. The order of nucleotides within any vector is fixed as $[\\text{A},\\text{C},\\text{G},\\text{T}]$.\n\nFor each position $i \\in \\{1,\\dots,L\\}$ and each possible point mutation that replaces the reference base $r_i$ with a different base $b \\in \\Sigma \\setminus \\{r_i\\}$, define the single-mutation change in score\n$$\n\\Delta S(i,b) \\;=\\; S\\big(s^{(i \\rightarrow b)}\\big) \\;-\\; S(s),\n$$\nwhere $s^{(i \\rightarrow b)}$ is the sequence equal to $s$ except at position $i$ where it has base $b$ instead of $r_i$. For each position $i$, define the positional sensitivity as the most deleterious single-mutation change\n$$\n\\Delta S_{\\min}(i) \\;=\\; \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b).\n$$\n\nYour task is to compute $\\Delta S_{\\min}(i)$ for all positions $i$ in each test case below, rounding each value to $6$ decimal places.\n\nTest Suite (all probabilities are given in the order $[\\text{A},\\text{C},\\text{G},\\text{T}]$):\n\n- Test case $1$ (donor-like PWM with strong $\\text{G}\\text{T}$ at positions around the splice junction):\n  - Length $L = 9$.\n  - Background distribution $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$.\n  - Reference sequence $s = \\text{\"CAGGTAAGT\"}$.\n  - PWM probabilities $P$ as rows $P_{i,\\cdot}$ for $i=1,\\dots,9$:\n    - $i=1$: $[\\,0.35,\\,0.25,\\,0.25,\\,0.15\\,]$\n    - $i=2$: $[\\,0.40,\\,0.20,\\,0.25,\\,0.15\\,]$\n    - $i=3$: $[\\,0.45,\\,0.15,\\,0.25,\\,0.15\\,]$\n    - $i=4$: $[\\,0.07,\\,0.07,\\,0.80,\\,0.06\\,]$\n    - $i=5$: $[\\,0.06,\\,0.07,\\,0.07,\\,0.80\\,]$\n    - $i=6$: $[\\,0.30,\\,0.25,\\,0.25,\\,0.20\\,]$\n    - $i=7$: $[\\,0.60,\\,0.15,\\,0.15,\\,0.10\\,]$\n    - $i=8$: $[\\,0.20,\\,0.20,\\,0.50,\\,0.10\\,]$\n    - $i=9$: $[\\,0.20,\\,0.20,\\,0.10,\\,0.50\\,]$\n\n- Test case $2$ (same PWM and background as test case $1$, different reference sequence):\n  - Length $L = 9$.\n  - Background distribution $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$.\n  - Reference sequence $s = \\text{\"TAGGTGAGT\"}$.\n  - PWM probabilities $P$ identical to those in test case $1$.\n\n- Test case $3$ (uninformative PWM equal to background, edge case):\n  - Length $L = 6$.\n  - Background distribution $Q = [\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$.\n  - Reference sequence $s = \\text{\"ACGTAC\"}$.\n  - PWM probabilities $P$ with every row equal to $[\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated nested list enclosed in square brackets, where each inner list corresponds to one test case and contains $L$ floating-point values for $\\Delta S_{\\min}(i)$ in positional order $i=1$ to $i=L$. For example, an output with three test cases must look like $[[x_{1,1},\\dots,x_{1,L_1}],[x_{2,1},\\dots,x_{2,L_2}],[x_{3,1},\\dots,x_{3,L_3}]]$, where each $x_{t,i}$ is rounded to $6$ decimal places. No units are involved, and no additional text should be printed.", "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded in the principles of bioinformatics and statistical sequence analysis, is well-posed with all necessary information provided, and is formulated objectively using precise mathematical definitions. No flaws were found. We may proceed with the solution.\n\nThe problem asks for the computation of the positional sensitivity, $\\Delta S_{\\min}(i)$, for each position $i$ in a given nucleotide sequence $s$. This sensitivity is defined as the most deleterious change in a sequence score $S(s)$ resulting from a single point mutation at that position. The score itself is based on a Position Weight Matrix (PWM) model, which is a common representation of sequence motifs.\n\nThe score $S(s)$ for a sequence $s = b_1 b_2 \\dots b_L$ is a log-likelihood ratio, given by:\n$$\nS(s) = \\sum_{i=1}^{L} \\ln\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right)\n$$\nHere, $P_{i,b_i}$ is the probability of observing base $b_i$ at position $i$ according to the motif model, and $Q_{b_i}$ is the probability of observing base $b_i$ according to a background model. This score quantifies how much more likely the sequence $s$ is under the motif model compared to the background.\n\nWe are asked to find the change in score, $\\Delta S(i,b)$, when the reference base $r_i$ at a single position $i$ is mutated to a new base $b \\in \\Sigma \\setminus \\{r_i\\}$. The original sequence is $s$, and the mutated sequence is $s^{(i \\rightarrow b)}$. The change in score is:\n$$\n\\Delta S(i,b) = S\\big(s^{(i \\rightarrow b)}\\big) - S(s)\n$$\n\nLet us expand this expression. The score for the original sequence $s$, which has reference bases $r_j$ at each position $j$, is:\n$$\nS(s) = \\sum_{j=1}^{L} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) = \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{j,r_j}}\\right)\n$$\nThe score for the mutated sequence $s^{(i \\rightarrow b)}$, which differs only at position $i$, is:\n$$\nS\\big(s^{(i \\rightarrow b)}\\big) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right)\n$$\nWhen we compute the difference $\\Delta S(i,b)$, the summation term, which represents the contribution from all unchanged positions, cancels out completely. This significantly simplifies the calculation:\n$$\n\\Delta S(i,b) = \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right) - \\left( \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right)\n$$\n$$\n\\Delta S(i,b) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\nThis shows that the change in the total score due to a mutation at position $i$ depends only on the probabilities defined for that specific position. Let us define the log-odds score for a base $x$ at position $i$ as $L_i(x) = \\ln(P_{i,x}/Q_x)$. Then, $\\Delta S(i,b) = L_i(b) - L_i(r_i)$.\n\nThe positional sensitivity, $\\Delta S_{\\min}(i)$, is the minimum such change over all possible mutations at position $i$.\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b)\n$$\nSubstituting our simplified expression for $\\Delta S(i,b)$:\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) \\right)\n$$\nSince the term $\\ln(P_{i,r_i}/Q_{r_i})$ is constant with respect to the minimization variable $b$, we can write:\n$$\n\\Delta S_{\\min}(i) = \\left( \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) \\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\n\nThe algorithm to compute $\\Delta S_{\\min}(i)$ for each position $i=1, \\dots, L$ is as follows:\n1.  For each position $i$ in the reference sequence $s$, identify the reference base $r_i$.\n2.  Using the provided PWM $P$ and background distribution $Q$, calculate the log-odds score for the reference base: $L_i(r_i) = \\ln(P_{i,r_i}/Q_{r_i})$.\n3.  For each of the three possible mutant bases $b \\in \\Sigma \\setminus \\{r_i\\}$, calculate its corresponding log-odds score: $L_i(b) = \\ln(P_{i,b}/Q_b)$.\n4.  Find the minimum value among the three mutant log-odds scores: $L_{i, \\text{min\\_mut}} = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} L_i(b)$.\n5.  The positional sensitivity is the difference between the minimum mutant score and the reference score: $\\Delta S_{\\min}(i) = L_{i, \\text{min\\_mut}} - L_i(r_i)$.\n6.  This procedure is repeated for all positions $i=1, \\dots, L$ for each test case. The results are rounded to $6$ decimal places.\n\nFor the special case where the PWM is uninformative and equal to the background distribution (i.e., $P_{i,b} = Q_b$ for all $i, b$), the log-odds score for any base at any position is $\\ln(1) = 0$. Consequently, $\\Delta S(i,b) = 0 - 0 = 0$ for all mutations, and thus $\\Delta S_{\\min}(i) = 0$ for all positions. This is confirmed by the calculation for Test Case $3$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the positional sensitivity problem for the given test suite.\n    \"\"\"\n    \n    # Define a mapping from nucleotide characters to array indices.\n    base_to_idx = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    idx_to_base = ['A', 'C', 'G', 'T']\n    \n    # Define the test cases from the problem statement.\n    p_matrix_tc1 = np.array([\n        [0.35, 0.25, 0.25, 0.15],\n        [0.40, 0.20, 0.25, 0.15],\n        [0.45, 0.15, 0.25, 0.15],\n        [0.07, 0.07, 0.80, 0.06],\n        [0.06, 0.07, 0.07, 0.80],\n        [0.30, 0.25, 0.25, 0.20],\n        [0.60, 0.15, 0.15, 0.10],\n        [0.20, 0.20, 0.50, 0.10],\n        [0.20, 0.20, 0.10, 0.50]\n    ])\n    \n    p_matrix_tc3 = np.array([\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n    ])\n\n    test_cases = [\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"CAGGTAAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"TAGGTGAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 6,\n            \"Q\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"s\": \"ACGTAC\",\n            \"P\": p_matrix_tc3\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        Q = case[\"Q\"]\n        s = case[\"s\"]\n        P = case[\"P\"]\n        \n        positional_sensitivities = []\n        for i in range(L):\n            # Identify reference base and its index\n            ref_base = s[i]\n            ref_idx = base_to_idx[ref_base]\n            \n            # Get the PWM probabilities for the current position\n            p_row = P[i]\n            \n            # Calculate log-odds score for the reference base\n            ref_log_odds = np.log(p_row[ref_idx] / Q[ref_idx])\n\n            # Calculate log-odds scores for all possible mutations\n            mutant_log_odds = []\n            for b_idx in range(4): # 4 bases in the alphabet\n                if b_idx != ref_idx:\n                    log_odds = np.log(p_row[b_idx] / Q[b_idx])\n                    mutant_log_odds.append(log_odds)\n            \n            # Find the minimum (most deleterious) mutant score\n            min_mutant_log_odds = min(mutant_log_odds)\n\n            # Calculate positional sensitivity delta_S_min(i)\n            delta_s_min = min_mutant_log_odds - ref_log_odds\n            \n            # Round to 6 decimal places and append\n            positional_sensitivities.append(round(delta_s_min, 6))\n            \n        all_results.append(positional_sensitivities)\n\n    # Format the final output string as a nested list string.\n    # The str() representation of a Python list is exactly the format required.\n    # Whitespace must be removed for exact match.\n    output_str = f\"[{','.join(str(res).replace(' ', '') for res in all_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2429077"}, {"introduction": "Identifying individual signals is only half the battle; the ultimate goal is to assemble them into the most plausible complete gene structure. This final, integrative practice treats gene prediction as an optimization problem, challenging you to find the 'lowest-cost path' through a graph of potential signals like promoters, exons, and introns. By implementing a dynamic programming solution, you will see how computational models weigh evidence from different signals and segment lengths to decode the single most likely gene from a complex set of possibilities [@problem_id:2429125].", "problem": "You are given a formal model of signal-based gene prediction that treats the decoding of a gene as a constrained minimization problem over a directed acyclic graph whose nodes are candidate genomic signals. Each candidate is a putative biological signal on a DNA sequence, such as a promoter, a start codon, a splice donor site, a splice acceptor site, or a stop codon. Positions are measured in base pairs (bp). You are provided with candidates, their positions, and their nonnegative signal costs. The goal is to select an ordered subset of these candidates that forms a valid gene structure with minimal total cost. The total cost combines the contributions from selected signal costs and length-model penalties for exons and introns.\n\nDefinitions and notation:\n- Let $S$ be a DNA sequence of length $N$ base pairs (bp).\n- Each candidate signal $j$ has:\n  - A type $t_j \\in \\{\\text{P}, \\text{S}, \\text{D}, \\text{A}, \\text{T}\\}$, denoting Promoter (P), Start codon (S), splice Donor (D), splice Acceptor (A), and Stop codon (T), respectively.\n  - A genomic position $p_j \\in \\{1,2,\\dots,N\\}$ in bp.\n  - A nonnegative signal cost $c_j \\ge 0$.\n- A valid gene structure is an ordered sequence of candidates whose types follow the pattern:\n  - One Promoter $\\rightarrow$ one Start codon $\\rightarrow$ zero or more repetitions of (Donor $\\rightarrow$ Acceptor) pairs $\\rightarrow$ one Stop codon.\n  - The positions must be strictly increasing along the selected sequence: if candidates $i$ and $k$ are consecutive in the sequence, then $p_i < p_k$.\n- The promoter-to-start distance must satisfy a constraint: if promoter is at $p_{\\text{P}}$ and start is at $p_{\\text{S}}$, then the distance $d = p_{\\text{S}} - p_{\\text{P}}$ must satisfy $D_{\\min} \\le d \\le D_{\\max}$.\n- Exon segments are contiguous coding stretches between:\n  - Start $\\rightarrow$ Donor,\n  - Acceptor $\\rightarrow$ Donor (for internal exons),\n  - Acceptor $\\rightarrow$ Stop,\n  - Start $\\rightarrow$ Stop (for single-exon genes with no intron).\n- Intron segments are contiguous noncoding stretches between Donor $\\rightarrow$ Acceptor.\n- Let $L$ denote a segment length in bp. Exon lengths incur a penalty $f_{\\text{exon}}(L)$ and intron lengths incur a penalty $f_{\\text{intron}}(L)$, where\n  $$f_{\\text{exon}}(L) = \\frac{(L - \\mu_{\\text{e}})^2}{2 \\sigma_{\\text{e}}^2}, \\quad f_{\\text{intron}}(L) = \\frac{(L - \\mu_{\\text{i}})^2}{2 \\sigma_{\\text{i}}^2}.$$\n  Here $\\mu_{\\text{e}}$ and $\\sigma_{\\text{e}}$ are the exon length mean and standard deviation, and $\\mu_{\\text{i}}$ and $\\sigma_{\\text{i}}$ are the intron length mean and standard deviation.\n- For a valid gene structure that selects the ordered sequence of signals $(j_1, j_2, \\dots, j_m)$ with strictly increasing positions $(p_{j_1} < p_{j_2} < \\dots < p_{j_m})$, the total cost $C$ is the sum of:\n  - All signal costs $\\sum_{r=1}^{m} c_{j_r}$,\n  - Plus the exon penalty $f_{\\text{exon}}(L)$ for each exon segment,\n  - Plus the intron penalty $f_{\\text{intron}}(L)$ for each intron segment,\n  where $L$ for a segment connecting consecutive signals at positions $p_{u} < p_{v}$ is defined as $L = p_{v} - p_{u} - 1$ bp.\n\nGlobal constants for all test cases:\n- Exon length parameters: $\\mu_{\\text{e}} = 150$, $\\sigma_{\\text{e}} = 30$ (bp).\n- Intron length parameters: $\\mu_{\\text{i}} = 200$, $\\sigma_{\\text{i}} = 40$ (bp).\n- Promoter-to-start distance constraint: $D_{\\min} = 20$, $D_{\\max} = 1000$ (bp).\n\nValidity constraints:\n- Only the following consecutive signal-type transitions are allowed:\n  - $\\text{P} \\rightarrow \\text{S}$, with the promoter-to-start distance constraint $D_{\\min} \\le p_{\\text{S}} - p_{\\text{P}} \\le D_{\\max}$ and no segment penalty.\n  - $\\text{S} \\rightarrow \\text{D}$ with exon penalty $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{S}} - 1)$.\n  - $\\text{A} \\rightarrow \\text{D}$ with exon penalty $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{A}} - 1)$.\n  - $\\text{D} \\rightarrow \\text{A}$ with intron penalty $f_{\\text{intron}}(p_{\\text{A}} - p_{\\text{D}} - 1)$.\n  - $\\text{S} \\rightarrow \\text{T}$ with exon penalty $f_{\\text{exon}}(p_{\\text{T}} - p_{\\text{S}} - 1)$.\n  - $\\text{A} \\rightarrow \\text{T}$ with exon penalty $f_{\\text{exon}}(p_{\\text{T}} - p_{\\text{A}} - 1)$.\n- The selected sequence must include exactly one promoter, exactly one start, exactly one stop, and zero or more properly ordered donor-acceptor pairs, all with strictly increasing positions.\n\nObjective:\n- Among all valid gene structures, find the one that minimizes the total cost $C$.\n\nOutput specification:\n- For each test case, output the selected signalsâ€™ genomic positions as integers in bp, in order, as a list: $[\\text{promoter}, \\text{start}, (\\text{donor}, \\text{acceptor})^*, \\text{stop}]$.\n- If multiple valid structures achieve the same minimal cost up to a tolerance of $\\varepsilon = 10^{-9}$, select the one whose list of positions is lexicographically smallest.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[...],[...],[...]]\") with no spaces. All positions must be integers in base pairs (bp).\n\nTest suite (three independent cases). For each case, $N$ is the sequence length (bp), followed by candidates with their type, position $p$, and cost $c$:\n\n- Case 1:\n  - $N = 1000$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=100, c=0.5)$, $(\\text{P}, p=300, c=0.2)$.\n    - Starts: $(\\text{S}, p=350, c=0.2)$, $(\\text{S}, p=600, c=0.4)$.\n    - Donors: $(\\text{D}, p=500, c=0.25)$, $(\\text{D}, p=650, c=0.45)$.\n    - Acceptors: $(\\text{A}, p=720, c=0.25)$, $(\\text{A}, p=800, c=0.5)$.\n    - Stops: $(\\text{T}, p=900, c=0.2)$.\n- Case 2:\n  - $N = 500$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=30, c=0.15)$.\n    - Starts: $(\\text{S}, p=100, c=0.25)$.\n    - Donors: $(\\text{D}, p=200, c=0.3)$.\n    - Acceptors: $(\\text{A}, p=150, c=0.2)$.\n    - Stops: $(\\text{T}, p=480, c=0.25)$.\n- Case 3:\n  - $N = 1200$.\n  - Candidates:\n    - Promoters: $(\\text{P}, p=101, c=0.1)$, $(\\text{P}, p=100, c=0.22)$, $(\\text{P}, p=80, c=0.4)$.\n    - Starts: $(\\text{S}, p=120, c=0.2)$.\n    - Donors: $(\\text{D}, p=270, c=0.28)$, $(\\text{D}, p=300, c=0.3)$.\n    - Acceptors: $(\\text{A}, p=440, c=0.31)$, $(\\text{A}, p=470, c=0.35)$.\n    - Stops: $(\\text{T}, p=700, c=0.25)$.\n\nFinal output format:\n- Your program must print a single line representing a list of three lists, one per case, with no spaces. Each inner list is the ordered integer positions (in bp) of the chosen signals, for example: \"[[p1,p2,...],[q1,q2,...],[r1,r2,...]]\".", "solution": "The problem presented is to identify the optimal gene structure from a set of candidate genomic signals by minimizing a total cost function. This cost function is an aggregation of signal-specific costs and length-dependent penalties for the inferred exon and intron segments. This formulation is a classic optimization problem that can be rigorously solved using dynamic programming. The problem is valid, scientifically grounded in the principles of computational gene finding, and mathematically well-posed.\n\nWe model this problem as finding the minimum-cost path in a Directed Acyclic Graph (DAG).\nThe nodes of the graph $G=(V, E)$ are the candidate signals provided in the input. Let the set of all candidates be $\\mathcal{S}$. The vertex set is $V = \\mathcal{S}$.\nAn edge $(i, j)$ exists in the edge set $E$ if and only if a transition from candidate signal $i$ to candidate signal $j$ is permitted by the rules of gene structure, and the position of $j$ is greater than the position of $i$, i.e., $p_j > p_i$. The cost of traversing an edge $(i, j)$ is defined as the sum of the signal cost of the destination node $j$, $c_j$, and the penalty associated with the genomic segment between $i$ and $j$, if any.\n\nThe objective is to find a path $(j_1, j_2, \\dots, j_m)$ that starts with a Promoter (P), ends with a Stop codon (T), and follows the specified gene grammar, such that the total path cost is minimized. The total cost is the sum of the initial signal cost $c_{j_1}$ and the costs of all subsequent transitions.\n\nWe will employ dynamic programming to solve this shortest path problem. Let the set of all candidates be sorted by their genomic position $p_j$. Let this sorted sequence of candidates be denoted by $s_1, s_2, \\dots, s_{|V|}$. We define $C(k)$ as the minimum cost of a valid partial gene structure ending at candidate $s_k$. We also define $\\Pi(k)$ as the list of genomic positions corresponding to the optimal path ending at $s_k$.\n\nThe dynamic programming algorithm proceeds by computing $C(k)$ and $\\Pi(k)$ for each candidate $s_k$ in the order of their genomic positions.\n\nThe recurrence relations are defined based on the type of the candidate signal $s_k$:\nLet $s_k$ be a candidate signal with type $t_k$, position $p_k$, and cost $c_k$.\n\n1.  If $t_k = \\text{P}$ (Promoter):\n    A promoter can only be the start of a gene. The cost is its own signal cost.\n    $$C(k) = c_k$$\n    $$\\Pi(k) = [p_k]$$\n\n2.  If $t_k = \\text{S}$ (Start codon):\n    A start codon must be preceded by a promoter $s_j$ (where $j<k$).\n    $$(C(k), \\Pi(k)) = \\min_{\\substack{j<k, t_j=\\text{P} \\\\ D_{\\min} \\le p_k - p_j \\le D_{\\max}}} \\left( C(j) + c_k, \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    where $\\oplus$ denotes list concatenation. The minimization is performed lexicographically on the tuple `(cost, path)`.\n\n3.  If $t_k = \\text{D}$ (Donor site):\n    A donor site must be preceded by either a start codon $s_j$ or an acceptor site $s_j$. The segment is an exon.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j \\in \\{\\text{S}, \\text{A}\\}} \\left( C(j) + c_k + f_{\\text{exon}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    The exon length penalty is $f_{\\text{exon}}(L) = \\frac{(L - \\mu_{\\text{e}})^2}{2 \\sigma_{\\text{e}}^2}$.\n\n4.  If $t_k = \\text{A}$ (Acceptor site):\n    An acceptor site must be preceded by a donor site $s_j$. The segment is an intron.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j=\\text{D}} \\left( C(j) + c_k + f_{\\text{intron}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n    The intron length penalty is $f_{\\text{intron}}(L) = \\frac{(L - \\mu_{\\text{i}})^2}{2 \\sigma_{\\text{i}}^2}$.\n\n5.  If $t_k = \\text{T}$ (Stop codon):\n    A stop codon must be preceded by either a start codon $s_j$ (for single-exon genes) or an acceptor site $s_j$. The segment is the final exon.\n    $$(C(k), \\Pi(k)) = \\min_{j<k, t_j \\in \\{\\text{S}, \\text{A}\\}} \\left( C(j) + c_k + f_{\\text{exon}}(p_k - p_j - 1), \\quad \\Pi(j) \\oplus [p_k] \\right)$$\n\nThe initial values for $C(k)$ are set to $\\infty$ for all non-promoter signals. The algorithm iterates through the position-sorted candidates $s_k$ for $k=1, \\dots, |V|$, calculating $(C(k), \\Pi(k))$ by considering all valid predecessors $s_j$ with $j < k$.\n\nThe tie-breaking rule specifies that if two paths yield the same minimal cost (within a tolerance $\\varepsilon = 10^{-9}$), the one with the lexicographically smaller list of positions must be chosen. This is handled at each minimization step. When comparing a newly computed path cost `new_cost` with the current minimum `C(k)`, if `abs(new_cost - C(k)) <= \\varepsilon`, we then compare their corresponding paths $\\Pi_{new}$ and $\\Pi(k)$ lexicographically.\n\nAfter computing $(C(k), \\Pi(k))$ for all candidates, the final solution is the path corresponding to the minimum cost found among all stop codons. Let $\\mathcal{T}$ be the set of indices of all stop codons. The final optimal path $\\Pi_{\\text{opt}}$ is given by:\n$$(\\_, \\Pi_{\\text{opt}}) = \\min_{k \\in \\mathcal{T}} (C(k), \\Pi(k))$$\nThis procedure guarantees finding the valid gene structure with the globally minimum cost, respecting all constraints and the tie-breaking condition.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene prediction problem for the given test cases using dynamic programming.\n    \"\"\"\n    # Global constants\n    MU_E, SIGMA_E = 150.0, 30.0\n    MU_I, SIGMA_I = 200.0, 40.0\n    D_MIN, D_MAX = 20, 1000\n    EPSILON = 1e-9\n\n    def f_exon(L):\n        \"\"\"Calculates exon length penalty.\"\"\"\n        return (L - MU_E)**2 / (2 * SIGMA_E**2)\n\n    def f_intron(L):\n        \"\"\"Calculates intron length penalty.\"\"\"\n        return (L - MU_I)**2 / (2 * SIGMA_I**2)\n\n    test_cases_data = [\n        # Case 1\n        [\n            ('P', 100, 0.5), ('P', 300, 0.2),\n            ('S', 350, 0.2), ('S', 600, 0.4),\n            ('D', 500, 0.25), ('D', 650, 0.45),\n            ('A', 720, 0.25), ('A', 800, 0.5),\n            ('T', 900, 0.2)\n        ],\n        # Case 2\n        [\n            ('P', 30, 0.15),\n            ('S', 100, 0.25),\n            ('D', 200, 0.3),\n            ('A', 150, 0.2),\n            ('T', 480, 0.25)\n        ],\n        # Case 3\n        [\n            ('P', 101, 0.1), ('P', 100, 0.22), ('P', 80, 0.4),\n            ('S', 120, 0.2),\n            ('D', 270, 0.28), ('D', 300, 0.3),\n            ('A', 440, 0.31), ('A', 470, 0.35),\n            ('T', 700, 0.25)\n        ]\n    ]\n\n    results = []\n    \n    for case_data in test_cases_data:\n        # Sort candidates by position, and then by type as a secondary key for stability\n        candidates = sorted(case_data, key=lambda x: (x[1], x[0]))\n        num_candidates = len(candidates)\n        \n        # dp[i] stores a tuple (minimum_cost, path_list) to reach candidate i\n        dp = [(float('inf'), []) for _ in range(num_candidates)]\n\n        for i in range(num_candidates):\n            cand_i_type, cand_i_pos, cand_i_cost = candidates[i]\n\n            # Base case: Promoter\n            if cand_i_type == 'P':\n                dp[i] = (cand_i_cost, [cand_i_pos])\n                continue\n\n            # Iterate through all preceding candidates to find valid predecessors\n            for j in range(i):\n                cand_j_type, cand_j_pos, _ = candidates[j]\n                \n                # If predecessor path is invalid, skip\n                if dp[j][0] == float('inf'):\n                    continue\n\n                new_cost = -1\n                pred_cost, pred_path = dp[j]\n\n                if cand_i_type == 'S' and cand_j_type == 'P':\n                    dist = cand_i_pos - cand_j_pos\n                    if D_MIN = dist = D_MAX:\n                        new_cost = pred_cost + cand_i_cost\n                \n                elif cand_i_type == 'D' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    if length >= 0:\n                        penalty = f_exon(length)\n                        new_cost = pred_cost + cand_i_cost + penalty\n                \n                elif cand_i_type == 'A' and cand_j_type == 'D':\n                    length = cand_i_pos - cand_j_pos - 1\n                    if length >= 0:\n                        penalty = f_intron(length)\n                        new_cost = pred_cost + cand_i_cost + penalty\n\n                elif cand_i_type == 'T' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    if length >= 0:\n                        penalty = f_exon(length)\n                        new_cost = pred_cost + cand_i_cost + penalty\n                \n                if new_cost != -1:\n                    new_path = pred_path + [cand_i_pos]\n                    \n                    # Update DP table with tie-breaking\n                    current_cost, current_path = dp[i]\n                    if new_cost  current_cost - EPSILON:\n                        dp[i] = (new_cost, new_path)\n                    elif abs(new_cost - current_cost) = EPSILON:\n                        if not current_path or new_path  current_path:\n                            dp[i] = (new_cost, new_path)\n\n        # Find the best path among all stop codons\n        best_overall_cost = float('inf')\n        best_overall_path = []\n\n        for i in range(num_candidates):\n            if candidates[i][0] == 'T':\n                cost, path = dp[i]\n                if path: # Ensure a valid path was found\n                    if cost  best_overall_cost - EPSILON:\n                        best_overall_cost = cost\n                        best_overall_path = path\n                    elif abs(cost - best_overall_cost) = EPSILON:\n                        if not best_overall_path or path  best_overall_path:\n                             best_overall_path = path\n        \n        results.append(best_overall_path)\n\n    # Format final output as a single line string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{','.join(map(str, res))}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2429125"}]}