{"hands_on_practices": [{"introduction": "Before solving equations on a structured grid, we must first master the language of coordinate transformations. This involves translating the derivatives from our familiar physical coordinates, like $(x,y)$, into the grid's native computational coordinates, such as $(\\xi, \\eta)$. This fundamental exercise guides you through a foundational derivation using the chain rule, establishing the mathematical machinery needed to express any partial differential equation in a general curvilinear coordinate system. Mastering this transformation is the first and most critical step in developing numerical solvers for complex geometries. [@problem_id:2436304]", "problem": "Consider the two-dimensional non-conservative momentum equation in Cartesian physical coordinates $(x,y)$ for the $x$-velocity component $u(x,y,t)$,\n$$\nu_{t} + u\\,u_{x} + v\\,u_{y} = -\\,p_{x},\n$$\nwhere $v(x,y,t)$ is the $y$-velocity component and $p(x,y,t)$ is the kinematic pressure. Let there be a smooth, one-to-one, time-independent mapping from a structured computational domain $(\\xi,\\eta)$ to the physical domain, given by the mapping functions $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$. Denote the metric derivatives by $x_{\\xi}$, $x_{\\eta}$, $y_{\\xi}$, and $y_{\\eta}$, and define the Jacobian determinant\n$$\nJ(\\xi,\\eta) = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}.\n$$\nUsing only first principles (the chain rule and properties of the Jacobian of a change of variables), transform the equation into computational space $(\\xi,\\eta)$ so that all spatial derivatives are expressed in terms of $\\xi$- and $\\eta$-derivatives, and the coefficients are written in terms of $x_{\\xi}$, $x_{\\eta}$, $y_{\\xi}$, $y_{\\eta}$, and $J$.\n\nAnswer specification:\n- Your derivation must be fully consistent with the definitions above and must not assume grid motion.\n- For grading, report only the final compact analytic expression for the transformed pressure-gradient term $-p_{x}$ written solely in terms of $x_{\\xi}$, $x_{\\eta}$, $y_{\\xi}$, $y_{\\eta}$, $J$, $p_{\\xi}$, and $p_{\\eta}$. Do not include any additional symbols or equations in your final answer.\n- No rounding is required. Express your final answer as an exact analytic expression with no units.", "solution": "The problem statement is subjected to rigorous validation before any attempt at a solution.\n\nStep 1: Extract Givens.\nThe provided information is as follows:\n- The governing equation is the two-dimensional non-conservative momentum equation for the $x$-velocity component $u(x,y,t)$:\n$$\nu_{t} + u\\,u_{x} + v\\,u_{y} = -\\,p_{x}\n$$\n- $v(x,y,t)$ is the $y$-velocity component.\n- $p(x,y,t)$ is the kinematic pressure.\n- The physical coordinates are $(x,y)$ and the computational coordinates are $(\\xi,\\eta)$.\n- The mapping from computational to physical space is given by $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$, and is specified as smooth, one-to-one, and time-independent.\n- The metric derivatives are defined as $x_{\\xi}$, $x_{\\eta}$, $y_{\\xi}$, and $y_{\\eta}$.\n- The Jacobian determinant is defined as $J(\\xi,\\eta) = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$.\n\nStep 2: Validate Using Extracted Givens.\nThe problem is examined against the required criteria.\n- **Scientifically Grounded**: The problem concerns the transformation of a partial differential equation, specifically a simplified form of the Euler equations, from a physical coordinate system to a computational one. This is a fundamental and standard procedure in computational fluid dynamics and computational engineering. The definitions of the coordinate transformation and the Jacobian are standard. The problem is scientifically sound.\n- **Well-Posed**: The problem asks for the derivation of a specific term in the transformed equation. The mapping is defined as smooth and one-to-one, which ensures that the Jacobian determinant $J$ is non-zero, making the transformation invertible and well-defined. The objective is clear and has a unique analytical solution based on the principles of multivariate calculus.\n- **Objective**: The problem is stated using precise mathematical language and definitions, free from ambiguity or subjective content.\n\nStep 3: Verdict and Action.\nThe problem is valid. It is a standard, well-posed problem in applied mathematics and computational engineering that is based on established principles. A solution will be derived.\n\nThe objective is to express the spatial derivatives with respect to the physical coordinates $(x,y)$ in terms of derivatives with respect to the computational coordinates $(\\xi,\\eta)$. This is achieved by applying the chain rule of calculus for a multivariable function.\n\nLet $f$ be any differentiable function of $(x,y)$, where $x$ and $y$ are themselves functions of $(\\xi,\\eta)$. The derivatives of $f$ with respect to $\\xi$ and $\\eta$ are given by the chain rule:\n$$\n\\frac{\\partial f}{\\partial \\xi} = \\frac{\\partial f}{\\partial x} \\frac{\\partial x}{\\partial \\xi} + \\frac{\\partial f}{\\partial y} \\frac{\\partial y}{\\partial \\xi}\n$$\n$$\n\\frac{\\partial f}{\\partial \\eta} = \\frac{\\partial f}{\\partial x} \\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial f}{\\partial y} \\frac{\\partial y}{\\partial \\eta}\n$$\nUsing the subscript notation provided in the problem statement ($f_{x} = \\frac{\\partial f}{\\partial x}$, $x_{\\xi} = \\frac{\\partial x}{\\partial \\xi}$, etc.), this system of equations is written as:\n$$\nf_{\\xi} = f_{x} x_{\\xi} + f_{y} y_{\\xi}\n$$\n$$\nf_{\\eta} = f_{x} x_{\\eta} + f_{y} y_{\\eta}\n$$\nThis constitutes a system of two linear algebraic equations for the unknown physical-space derivatives, $f_{x}$ and $f_{y}$. In matrix form, this is:\n$$\n\\begin{pmatrix} x_{\\xi} & y_{\\xi} \\\\ x_{\\eta} & y_{\\eta} \\end{pmatrix}\n\\begin{pmatrix} f_{x} \\\\ f_{y} \\end{pmatrix}\n=\n\\begin{pmatrix} f_{\\xi} \\\\ f_{\\eta} \\end{pmatrix}\n$$\nTo solve for $f_{x}$ and $f_{y}$, we must invert the coefficient matrix. The determinant of this matrix is $\\Delta = x_{\\xi} y_{\\eta} - y_{\\xi} x_{\\eta}$, which is precisely the Jacobian determinant $J$ defined in the problem statement. Since the mapping is one-to-one, $J \\neq 0$, and the matrix is invertible. The inverse of the matrix is:\n$$\n\\begin{pmatrix} x_{\\xi} & y_{\\xi} \\\\ x_{\\eta} & y_{\\eta} \\end{pmatrix}^{-1}\n=\n\\frac{1}{J}\n\\begin{pmatrix} y_{\\eta} & -y_{\\xi} \\\\ -x_{\\eta} & x_{\\xi} \\end{pmatrix}\n$$\nMultiplying both sides of the matrix equation by this inverse gives the solution for the vector of physical derivatives:\n$$\n\\begin{pmatrix} f_{x} \\\\ f_{y} \\end{pmatrix}\n=\n\\frac{1}{J}\n\\begin{pmatrix} y_{\\eta} & -y_{\\xi} \\\\ -x_{\\eta} & x_{\\xi} \\end{pmatrix}\n\\begin{pmatrix} f_{\\xi} \\\\ f_{\\eta} \\end{pmatrix}\n$$\nFrom this matrix-vector product, we extract the expressions for $f_{x}$ and $f_{y}$:\n$$\nf_{x} = \\frac{1}{J} (y_{\\eta} f_{\\xi} - y_{\\xi} f_{\\eta})\n$$\n$$\nf_{y} = \\frac{1}{J} (x_{\\xi} f_{\\eta} - x_{\\eta} f_{\\xi})\n$$\nThe problem specifically asks for the transformed expression for the pressure-gradient term, $-p_{x}$. To find this, we simply substitute $f = p$ into the expression for $f_{x}$:\n$$\np_{x} = \\frac{1}{J} (y_{\\eta} p_{\\xi} - y_{\\xi} p_{\\eta})\n$$\nTherefore, the required term is:\n$$\n-p_{x} = - \\frac{1}{J} (y_{\\eta} p_{\\xi} - y_{\\xi} p_{\\eta})\n$$\nThis expression can be rearranged for notational simplicity by distributing the negative sign into the parenthesis:\n$$\n-p_{x} = \\frac{1}{J} (y_{\\xi} p_{\\eta} - y_{\\eta} p_{\\xi})\n$$\nThis final form expresses $-p_{x}$ solely in terms of the specified quantities: the metric derivatives $y_{\\xi}$ and $y_{\\eta}$, the computational-space pressure derivatives $p_{\\xi}$ and $p_{\\eta}$, and the Jacobian $J$.\n\nFor completeness, the entire momentum equation is transformed. The derivatives $u_{x}$ and $u_{y}$ are obtained by setting $f=u$ in the general formulas:\n$$\nu_{x} = \\frac{1}{J} (y_{\\eta} u_{\\xi} - y_{\\xi} u_{\\eta})\n$$\n$$\nu_{y} = \\frac{1}{J} (x_{\\xi} u_{\\eta} - x_{\\eta} u_{\\xi})\n$$\nThe time derivative $\\frac{\\partial u}{\\partial t}$ is taken at a fixed physical point $(x,y)$. Since the mapping is time-independent, a fixed point $(x,y)$ corresponds to a fixed computational point $(\\xi,\\eta)$. Thus, the time derivative transforms directly: $(\\frac{\\partial u}{\\partial t})_{(x,y)} = (\\frac{\\partial u}{\\partial t})_{(\\xi,\\eta)} = u_{t}$.\nSubstituting these expressions into the original equation yields the fully transformed equation in computational coordinates:\n$$\nu_{t} + u \\left[\\frac{1}{J} (y_{\\eta} u_{\\xi} - y_{\\xi} u_{\\eta})\\right] + v \\left[\\frac{1}{J} (x_{\\xi} u_{\\eta} - x_{\\eta} u_{\\xi})\\right] = \\frac{1}{J} (y_{\\xi} p_{\\eta} - y_{\\eta} p_{\\xi})\n$$\nThis is the complete transformation. However, the problem requires only the final expression for the pressure term.", "answer": "$$\n\\boxed{\\frac{1}{J} (y_{\\xi} p_{\\eta} - y_{\\eta} p_{\\xi})}\n$$", "id": "2436304"}, {"introduction": "The transformation from a physical to a computational domain inevitably introduces geometric distortion, which must be precisely quantified for accurate simulations. Key to this are the metric tensor components $g_{ij}$ and the Jacobian determinant $J$, which describe how lengths, angles, and areas are warped by the mapping. This practice moves from pure theory to practical implementation, challenging you to write code that computes these essential geometric quantities for several common analytical grid types. This exercise will sharpen your ability to translate abstract mathematical definitions into concrete, computable values that are the bedrock of any simulation on a structured grid. [@problem_id:2436332]", "problem": "You are given smooth, two-dimensional, analytical transformations from a computational coordinate system $(\\xi,\\eta)$ to a physical coordinate system $(x,y)$. Let $\\boldsymbol{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$. The covariant base vectors are defined as $\\boldsymbol{r}_{\\xi} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\xi}$ and $\\boldsymbol{r}_{\\eta} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\eta}$. The covariant metric tensor components are defined by $g_{ij} = \\boldsymbol{r}_{i} \\cdot \\boldsymbol{r}_{j}$ for $i,j \\in \\{\\xi,\\eta\\}$, specifically $g_{\\xi\\xi}$, $g_{\\xi\\eta}$, and $g_{\\eta\\eta}$. The Jacobian determinant is defined by $J = \\det\\left(\\dfrac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$. All quantities are dimensionless. All angles, when they appear in the transformations, must be treated in radians.\n\nWrite a program that, for each transformation and evaluation point listed below, computes the list $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$ and rounds each entry to $8$ decimal places.\n\nThe required test suite is as follows, where every parameter and evaluation coordinate is given explicitly:\n\n- Test case $1$ (affine mapping): $x(\\xi,\\eta) = a\\,\\xi + b\\,\\eta + c$, $y(\\xi,\\eta) = d\\,\\xi + e\\,\\eta + f$, with $(a,b,c,d,e,f) = (\\,2,\\,1,\\,0.5,\\,-1,\\,3,\\,1\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.3,\\,-0.7\\,)$.\n- Test case $2$ (polynomial skew): $x(\\xi,\\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$, $y(\\xi,\\eta) = \\eta + \\beta\\,\\xi^{2}$, with $(\\alpha,\\beta) = (\\,0.4,\\,-0.2\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.5,\\,-1.0\\,)$.\n- Test case $3$ (polar-type mapping): $x(\\xi,\\eta) = r\\cos\\theta$, $y(\\xi,\\eta) = r\\sin\\theta$, where $(\\xi,\\eta) = (r,\\theta)$, evaluated at $(r,\\theta) = (\\,2.0,\\,\\pi/6\\,)$. Angles are in radians.\n- Test case $4$ (trigonometric warp): $x(\\xi,\\eta) = \\xi + A\\sin(\\pi \\xi)\\sin(\\pi \\eta)$, $y(\\xi,\\eta) = \\eta + B\\sin(\\pi \\xi)\\sin(\\pi \\eta)$, with $(A,B) = (\\,0.1,\\,-0.15\\,)$ evaluated at $(\\xi,\\eta) = (\\,0.25,\\,0.75\\,)$.\n\nYour program must output a single line containing a list of lists, where each inner list corresponds to one test case in the order above, and each inner list is $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$ with each float rounded to $8$ decimal places. For example, your output should have the form\n$[[v_{11},v_{12},v_{13},v_{14}],[v_{21},v_{22},v_{23},v_{24}],[v_{31},v_{32},v_{33},v_{34}],[v_{41},v_{42},v_{43},v_{44}]]$\nwhere each $v_{ij}$ is a float rounded to $8$ decimal places. No additional text should be printed.", "solution": "The problem as stated is valid. It is a well-posed problem in applied differential geometry, fundamental to the field of computational engineering, specifically for the analysis of structured grids. All definitions, transformations, and parameters are provided, are scientifically sound, and free from ambiguity or contradiction. A unique solution exists for each test case. The solution will proceed by direct calculation based on the provided definitions.\n\nThe transformation from computational coordinates $(\\xi, \\eta)$ to physical coordinates $(x, y)$ is given by $\\boldsymbol{r}(\\xi, \\eta) = (x(\\xi, \\eta), y(\\xi, \\eta))$. The covariant base vectors are $\\boldsymbol{r}_{\\xi} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$ and $\\boldsymbol{r}_{\\eta} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$.\n\nFrom these vectors, the components of the covariant metric tensor $g_{ij}$ and the Jacobian determinant $J$ are calculated.\nThe metric tensor components are given by the dot products of the base vectors:\n$$g_{\\xi\\xi} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\xi}\\right)^2$$\n$$g_{\\eta\\eta} = \\boldsymbol{r}_{\\eta} \\cdot \\boldsymbol{r}_{\\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\eta}\\right)^2$$\n$$g_{\\xi\\eta} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\eta} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}$$\nThe Jacobian determinant, representing the local ratio of area elements, is given by:\n$$J = \\det\\left(\\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$$\nWe will now calculate these four quantities for each of the specified test cases.\n\nTest case $1$: Affine mapping\nThe transformation is $x(\\xi,\\eta) = a\\xi + b\\eta + c$ and $y(\\xi,\\eta) = d\\xi + e\\eta + f$, with parameters $(a,b,c,d,e,f) = (2, 1, 0.5, -1, 3, 1)$. The partial derivatives are constants:\n$\\frac{\\partial x}{\\partial \\xi} = a = 2$\n$\\frac{\\partial x}{\\partial \\eta} = b = 1$\n$\\frac{\\partial y}{\\partial \\xi} = d = -1$\n$\\frac{\\partial y}{\\partial \\eta} = e = 3$\nThese values are independent of the evaluation point $(\\xi,\\eta) = (0.3, -0.7)$.\n$g_{\\xi\\xi} = (2)^2 + (-1)^2 = 4 + 1 = 5$\n$g_{\\eta\\eta} = (1)^2 + (3)^2 = 1 + 9 = 10$\n$g_{\\xi\\eta} = (2)(1) + (-1)(3) = 2 - 3 = -1$\n$J = (2)(3) - (1)(-1) = 6 + 1 = 7$\nThe required list is $[5.0, -1.0, 10.0, 7.0]$.\n\nTest case $2$: Polynomial skew\nThe transformation is $x(\\xi,\\eta) = \\xi + \\alpha\\xi\\eta$ and $y(\\xi,\\eta) = \\eta + \\beta\\xi^2$, with parameters $(\\alpha, \\beta) = (0.4, -0.2)$.\nThe partial derivatives are:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = \\alpha\\xi$\n$\\frac{\\partial y}{\\partial \\xi} = 2\\beta\\xi$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\nEvaluating at $(\\xi, \\eta) = (0.5, -1.0)$:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.4)(-1.0) = 1 - 0.4 = 0.6$\n$\\frac{\\partial x}{\\partial \\eta} = (0.4)(0.5) = 0.2$\n$\\frac{\\partial y}{\\partial \\xi} = 2(-0.2)(0.5) = -0.2$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n$g_{\\xi\\xi} = (0.6)^2 + (-0.2)^2 = 0.36 + 0.04 = 0.4$\n$g_{\\eta\\eta} = (0.2)^2 + (1)^2 = 0.04 + 1 = 1.04$\n$g_{\\xi\\eta} = (0.6)(0.2) + (-0.2)(1) = 0.12 - 0.2 = -0.08$\n$J = (0.6)(1) - (0.2)(-0.2) = 0.6 + 0.04 = 0.64$\nThe required list is $[0.4, -0.08, 1.04, 0.64]$.\n\nTest case $3$: Polar-type mapping\nThe transformation is $x(r,\\theta) = r\\cos\\theta$ and $y(r,\\theta) = r\\sin\\theta$, with computational coordinates identified as $(\\xi, \\eta) = (r, \\theta)$.\nThe partial derivatives with respect to $\\xi=r$ and $\\eta=\\theta$ are:\n$\\frac{\\partial x}{\\partial \\xi} = \\cos\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = -\\xi\\sin\\eta$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\xi\\cos\\eta$\nEvaluating at $(\\xi, \\eta) = (2.0, \\pi/6)$:\n$\\frac{\\partial x}{\\partial \\xi} = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n$\\frac{\\partial x}{\\partial \\eta} = -2\\sin(\\pi/6) = -2(\\frac{1}{2}) = -1$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin(\\pi/6) = \\frac{1}{2}$\n$\\frac{\\partial y}{\\partial \\eta} = 2\\cos(\\pi/6) = 2(\\frac{\\sqrt{3}}{2}) = \\sqrt{3}$\n$g_{\\xi\\xi} = (\\frac{\\sqrt{3}}{2})^2 + (\\frac{1}{2})^2 = \\frac{3}{4} + \\frac{1}{4} = 1$\n$g_{\\eta\\eta} = (-1)^2 + (\\sqrt{3})^2 = 1 + 3 = 4$\n$g_{\\xi\\eta} = (\\frac{\\sqrt{3}}{2})(-1) + (\\frac{1}{2})(\\sqrt{3}) = 0$\n$J = (\\frac{\\sqrt{3}}{2})(\\sqrt{3}) - (-1)(\\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2} = 2$\nThe required list is $[1.0, 0.0, 4.0, 2.0]$.\n\nTest case $4$: Trigonometric warp\nThe transformation is $x(\\xi,\\eta) = \\xi + A\\sin(\\pi\\xi)\\sin(\\pi\\eta)$ and $y(\\xi,\\eta) = \\eta + B\\sin(\\pi\\xi)\\sin(\\pi\\eta)$, with parameters $(A, B) = (0.1, -0.15)$.\nThe partial derivatives are:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + A\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial x}{\\partial \\eta} = A\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\xi} = B\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + B\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\nEvaluating at $(\\xi, \\eta) = (0.25, 0.75)$:\nWe have $\\pi\\xi = \\pi/4$ and $\\pi\\eta = 3\\pi/4$.\n$\\cos(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\sin(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\cos(3\\pi/4) = -\\frac{\\sqrt{2}}{2}$, $\\sin(3\\pi/4) = \\frac{\\sqrt{2}}{2}$.\nThus, $\\cos(\\pi\\xi)\\sin(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(\\frac{\\sqrt{2}}{2}) = 0.5$ and $\\sin(\\pi\\xi)\\cos(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(-\\frac{\\sqrt{2}}{2}) = -0.5$.\nSubstituting these values:\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.1)\\pi(0.5) = 1 + 0.05\\pi$\n$\\frac{\\partial x}{\\partial \\eta} = (0.1)\\pi(-0.5) = -0.05\\pi$\n$\\frac{\\partial y}{\\partial \\xi} = (-0.15)\\pi(0.5) = -0.075\\pi$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + (-0.15)\\pi(-0.5) = 1 + 0.075\\pi$\n$g_{\\xi\\xi} = (1+0.05\\pi)^2 + (-0.075\\pi)^2 = 1 + 0.1\\pi + 0.0025\\pi^2 + 0.005625\\pi^2 = 1 + 0.1\\pi + 0.008125\\pi^2 \\approx 1.39435068$\n$g_{\\eta\\eta} = (-0.05\\pi)^2 + (1+0.075\\pi)^2 = 0.0025\\pi^2 + 1 + 0.15\\pi + 0.005625\\pi^2 = 1 + 0.15\\pi + 0.008125\\pi^2 \\approx 1.55142551$\n$g_{\\xi\\eta} = (1+0.05\\pi)(-0.05\\pi) + (-0.075\\pi)(1+0.075\\pi) = -0.05\\pi - 0.0025\\pi^2 - 0.075\\pi - 0.005625\\pi^2 = -0.125\\pi - 0.008125\\pi^2 \\approx -0.47289237$\n$J = (1+0.05\\pi)(1+0.075\\pi) - (-0.05\\pi)(-0.075\\pi) = 1 + 0.125\\pi + 0.00375\\pi^2 - 0.00375\\pi^2 = 1 + 0.125\\pi \\approx 1.39269908$\nThe required list, rounded to $8$ decimal places, is $[1.39435068, -0.47289237, 1.55142551, 1.39269908]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the metric tensor components and Jacobian for four\n    different coordinate transformations.\n    \"\"\"\n\n    def case1():\n        \"\"\"Affine mapping.\"\"\"\n        a, b, c, d, e, f = 2, 1, 0.5, -1, 3, 1\n        # xi, eta = 0.3, -0.7 # Not needed as derivatives are constant\n        \n        # Partial derivatives\n        x_xi = a\n        x_eta = b\n        y_xi = d\n        y_eta = e\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case2():\n        \"\"\"Polynomial skew.\"\"\"\n        alpha, beta = 0.4, -0.2\n        xi, eta = 0.5, -1.0\n        \n        # Partial derivatives\n        x_xi = 1 + alpha * eta\n        x_eta = alpha * xi\n        y_xi = 2 * beta * xi\n        y_eta = 1\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case3():\n        \"\"\"Polar-type mapping.\"\"\"\n        xi, eta = 2.0, np.pi / 6.0 # (r, theta)\n        \n        # Partial derivatives\n        x_xi = np.cos(eta)       # dx/dr\n        x_eta = -xi * np.sin(eta) # dx/dtheta\n        y_xi = np.sin(eta)       # dy/dr\n        y_eta = xi * np.cos(eta)  # dy/dtheta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case4():\n        \"\"\"Trigonometric warp.\"\"\"\n        A, B = 0.1, -0.15\n        xi, eta = 0.25, 0.75\n        \n        pi_xi = np.pi * xi\n        pi_eta = np.pi * eta\n        \n        # Common trigonometric terms\n        cos_xi_sin_eta = np.cos(pi_xi) * np.sin(pi_eta)\n        sin_xi_cos_eta = np.sin(pi_xi) * np.cos(pi_eta)\n        \n        # Partial derivatives\n        x_xi = 1 + A * np.pi * cos_xi_sin_eta\n        x_eta = A * np.pi * sin_xi_cos_eta\n        y_xi = B * np.pi * cos_xi_sin_eta\n        y_eta = 1 + B * np.pi * sin_xi_cos_eta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    results = []\n    case_functions = [case1, case2, case3, case4]\n\n    for func in case_functions:\n        raw_result = func()\n        rounded_result = [round(val, 8) for val in raw_result]\n        results.append(rounded_result)\n    \n    # Generate the output string exactly as specified, without spaces\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2436332"}, {"introduction": "Not all points on a structured grid are created equal; some, known as singularities, require special attention. A classic example is the origin ($r=0$) in a polar or cylindrical coordinate system, where terms like $\\frac{1}{r}$ can cause numerical schemes to fail. This hands-on practice presents a crucial case study, challenging you to solve the Poisson equation on a disk and compare a naive numerical scheme with a carefully derived method that correctly handles the singularity. This problem highlights why a deep understanding of the underlying grid transformations is not just a theoretical exercise but a practical necessity for achieving accurate and stable solutions. [@problem_id:2436320]", "problem": "Consider the axisymmetric Poisson equation in polar coordinates on the closed unit disk. Let $u(r)$ denote a scalar field that depends only on the radius $r \\in [0,1]$. The governing equation is\n$$\n\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r),\n$$\nwith the boundary condition $u(1)=0$ and the regularity condition that $u(r)$ remains finite as $r \\to 0$. For this problem, use the exact smooth solution $u_{\\text{exact}}(r) = 1 - r^2$, which implies $f(r) = -4$ for all $r \\in [0,1]$.\n\nYou must investigate how the singularity of the polar mapping at $r=0$ influences a numerical approximation on a structured grid, and demonstrate a mitigation strategy. Proceed as follows, using only the mathematical definitions provided here:\n\n- Construct a uniform structured radial grid with $N$ intervals and spacing $h = 1/N$, with nodal locations $r_i = i h$ for $i=0,1,\\dots,N$.\n- Compute two independent numerical approximations of $u(r)$ on this grid:\n  1. A baseline approximation that treats $r=0$ as an ordinary grid point but imposes the inconsistent boundary value $u(0) = 0$ at the origin and $u(1)=0$ at the outer boundary. This baseline is intentionally inconsistent with the true solution at $r=0$ and serves to quantify how the singular mapping can pollute the discrete solution.\n  2. A mitigated approximation that uses any mathematically justified strategy derived from first principles to correctly remove the effect of the singular mapping at $r=0$ while enforcing $u(1)=0$. Any choice that is consistent with the underlying continuous problem is acceptable, provided it produces a well-posed discrete system.\n\nFor each approximation, quantify the error by the relative area-weighted discrete $L^2$ norm over the disk:\n$$\nE = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}.\n$$\nIn your program, approximate these integrals on the grid $\\{r_i\\}_{i=0}^N$ using the composite trapezoidal rule in $r$, that is, with weights $w_0 = w_N = \\tfrac{1}{2}$ and $w_i = 1$ for $i=1,\\dots,N-1$, and spacing $h = 1/N$.\n\nTest Suite:\n- Use $N \\in \\{8,16,32,64\\}$.\n- For each $N$, compute and report two numbers: $E_{\\text{baseline}}(N)$ and $E_{\\text{mitigated}}(N)$ as defined above.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[E_{\\text{baseline}}(8), E_{\\text{mitigated}}(8), E_{\\text{baseline}}(16), E_{\\text{mitigated}}(16), E_{\\text{baseline}}(32), E_{\\text{mitigated}}(32), E_{\\text{baseline}}(64), E_{\\text{mitigated}}(64)\\right].\n$$\nNo physical units are involved. Angles, where implicitly relevant to polar coordinates, are in radians, but the present problem is purely radial.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Governing Equation**: $\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r)$ on $r \\in [0,1]$.\n- **Boundary and Regularity Conditions**: $u(1)=0$ and $u(r)$ is finite as $r \\to 0$.\n- **Exact Solution**: $u_{\\text{exact}}(r) = 1 - r^2$.\n- **Source Term**: $f(r) = -4$.\n- **Grid**: Uniform with $N$ intervals, spacing $h = 1/N$, nodes $r_i = i h$ for $i=0,1,\\dots,N$.\n- **Baseline Approximation**: $u(0)=0$, $u(1)=0$, and standard finite differences for $r_i, i \\in \\{1, \\dots, N-1\\}$.\n- **Mitigated Approximation**: Mathematically justified strategy to handle the singularity at $r=0$, with $u(1)=0$.\n- **Error Metric**: Relative area-weighted discrete $L^2$ norm, $E = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}$.\n- **Numerical Integration**: Composite trapezoidal rule on $\\{r_i\\}_{i=0}^N$.\n- **Test Suite**: $N \\in \\{8,16,32,64\\}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it concerns the numerical solution of the Poisson equation in polar coordinates, a fundamental problem in engineering and physics. The coordinate singularity at $r=0$ is a classic numerical challenge that requires special treatment, and the problem correctly frames this as a comparative study between a naive and a principled approach. The problem is well-posed; it provides all necessary equations, boundary conditions, and definitions to construct a unique numerical solution for each case. The language is objective and mathematically precise. There are no scientific or logical flaws, contradictions, or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Mathematical Formulation and Discretization**\n\nThe governing equation is the axisymmetric Poisson equation in one spatial dimension, the radius $r$:\n$$\n\\frac{d^2 u}{d r^2} + \\frac{1}{r}\\frac{d u}{d r} = f(r)\n$$\nfor $r \\in (0, 1]$, with boundary condition $u(1)=0$ and source term $f(r)=-4$. A uniform grid is defined with $N$ intervals of spacing $h=1/N$, such that the grid nodes are located at $r_i=ih$ for $i=0, 1, \\dots, N$. The numerical solution at these nodes is denoted $u_i \\approx u(r_i)$.\n\nFor an interior node $r_i$ where $i \\in \\{1, \\dots, N-1\\}$, the derivatives are approximated using second-order central finite differences:\n$$\n\\frac{d^2 u}{d r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n$$\n\\frac{d u}{d r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\nSubstituting these into the governing equation and using $r_i=ih$ yields the general discrete equation for an interior node:\n$$\n\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{ih} \\left(\\frac{u_{i+1} - u_{i-1}}{2h}\\right) = f_i\n$$\nwhere $f_i = f(r_i) = -4$. This equation can be rearranged into a linear relationship between adjacent nodal values:\n$$\n\\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} = h^2 f_i\n$$\nThis forms the basis for a system of linear algebraic equations. The treatment of the boundaries at $i=0$ and $i=N$ distinguishes the two required approximation schemes.\n\n**Baseline Approximation**\n\nThis approach imposes the Dirichlet boundary conditions $u_0 = 0$ and $u_N = 0$. The condition $u_0=0$ is inconsistent with the exact solution $u_{\\text{exact}}(0) = 1 - 0^2 = 1$, and is used to demonstrate the effect of incorrect handling of the origin. The unknowns are the nodal values $u_1, u_2, \\dots, u_{N-1}$. A system of $N-1$ linear equations is formed by applying the general discrete equation for each $i \\in \\{1, \\dots, N-1\\}$. This results in an $(N-1) \\times (N-1)$ tridiagonal system of equations $A_{\\text{base}} \\mathbf{u}_{\\text{base}} = \\mathbf{b}_{\\text{base}}$, which can be solved for the vector of unknowns $\\mathbf{u}_{\\text{base}} = [u_1, \\dots, u_{N-1}]^T$.\n\n**Mitigated Approximation**\n\nA correct formulation must properly handle the singular term $\\frac{1}{r}\\frac{du}{dr}$ at $r=0$. From the regularity condition, the solution $u(r)$ must be smooth on the disk. For an axisymmetric function, this implies that the first derivative must vanish at the origin due to symmetry: $\\frac{du}{dr}|_{r=0} = 0$. Applying L'HÃ´pital's rule to the singular term gives:\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{du}{dr} = \\lim_{r\\to 0} \\frac{\\frac{d^2u}{dr^2}}{\\frac{d}{dr}(r)} = \\frac{d^2u}{dr^2}\\bigg|_{r=0}\n$$\nTherefore, at $r=0$, the governing equation takes the non-singular form:\n$$\n2 \\frac{d^2u}{dr^2}\\bigg|_{r=0} = f(0)\n$$\nTo discretize this equation at $r_0=0$, we use a second-order central difference for the second derivative. By axisymmetry, the solution profile is even, so $u(-r) = u(r)$, which implies $u(r_{-1}) = u(-h) = u(h) = u_1$. The finite difference approximation at $r_0=0$ is:\n$$\n\\frac{d^2u}{dr^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}\n$$\nSubstituting this into the specialized governing equation at $r=0$ yields the discrete equation for the center node $u_0$:\n$$\n2 \\left( \\frac{2u_1 - 2u_0}{h^2} \\right) = f_0 \\quad \\implies \\quad -4u_0 + 4u_1 = h^2f_0\n$$\nThe system of equations for the mitigated case consists of this equation at $i=0$ and the general finite difference equations for $i = 1, \\dots, N-1$. Together with the boundary condition $u_N=0$, this forms a well-posed $N \\times N$ system of equations $A_{\\text{mit}} \\mathbf{u}_{\\text{mit}} = \\mathbf{b}_{\\text{mit}}$ for the unknowns $\\mathbf{u}_{\\text{mit}} = [u_0, \\dots, u_{N-1}]^T$.\n\n**Error Quantification**\n\nThe error is quantified by the relative area-weighted $L^2$ norm. The factor of $2\\pi$ for the area element $2\\pi r \\, dr$ cancels from the numerator and denominator:\n$$\nE = \\frac{\\left(\\int_0^1 r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}\n$$\nThe integrals are approximated numerically using the composite trapezoidal rule. For an integrand $g(r)$, the integral is $\\int_0^1 g(r) \\, dr \\approx h \\sum_{i=0}^N w_i g(r_i)$, with weights $w_0=w_N=1/2$ and $w_i=1$ for $i \\in \\{1,\\dots,N-1\\}$. For the numerator, the integrand is $g_{\\text{num}}(r) = r(u_{\\text{num}}(r)-u_{\\text{exact}}(r))^2$. For the denominator, it is $g_{\\text{den}}(r) = r(u_{\\text{exact}}(r))^2$. Both integrands are zero at $r=0$ (due to the factor of $r$) and at $r=1$ (since $u_{\\text{num}}(1)=u_{\\text{exact}}(1)=0$). The numerical solution is obtained for each $N \\in \\{8,16,32,64\\}$, and the corresponding errors $E_{\\text{baseline}}(N)$ and $E_{\\text{mitigated}}(N)$ are computed.", "answer": "```python\nimport numpy as np\n\ndef calculate_error(u_num, u_exact, r):\n    \"\"\"\n    Calculates the relative area-weighted discrete L2 norm.\n    The area element is 2*pi*r*dr, but 2*pi cancels.\n    \"\"\"\n    # Numerator integrand: r * (u_num - u_exact)^2\n    error_sq = (u_num - u_exact)**2\n    integrand_num = r * error_sq\n    \n    # Denominator integrand: r * (u_exact)^2\n    u_exact_sq = u_exact**2\n    integrand_den = r * u_exact_sq\n    \n    # Integrate using the composite trapezoidal rule provided by numpy.\n    # np.trapz(y, x) computes the integral of y(x) dx.\n    integral_num = np.trapz(integrand_num, r)\n    integral_den = np.trapz(integrand_den, r)\n    \n    if integral_den == 0:\n        # This case is unlikely with the given exact solution.\n        return np.inf\n\n    # The error E is the square root of the ratio of the integrals.\n    E = np.sqrt(integral_num / integral_den)\n    return E\n\ndef solve():\n    \"\"\"\n    Solves the axisymmetric Poisson equation using two different treatments\n    of the singularity at r=0 and computes the error for each case.\n    \"\"\"\n    test_cases = [8, 16, 32, 64]\n    results = []\n\n    for N in test_cases:\n        h = 1.0 / N\n        # Grid points r_i = i*h for i = 0, ..., N\n        r = np.linspace(0.0, 1.0, N + 1)\n        # Exact solution u(r) = 1 - r^2\n        u_exact = 1.0 - r**2\n        # Source term f(r) = -4\n        f = -4.0\n\n        # --- Baseline Approximation ---\n        # Solves for unknowns u_1, ..., u_{N-1}. Size (N-1)x(N-1).\n        # Boundary conditions: u_0 = 0, u_N = 0.\n        size_base = N - 1\n        if size_base > 0:\n            # Main diagonal of the matrix A\n            diag_main = -2.0 * np.ones(size_base)\n\n            # Sub-diagonal terms: (1 - 1/(2*i)) for u_{i-1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sub = np.arange(2, N) # i goes from 2 to N-1\n            diag_sub = 1.0 - 1.0 / (2.0 * i_sub)\n\n            # Super-diagonal terms: (1 + 1/(2*i)) for u_{i+1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sup = np.arange(1, N - 1) # i goes from 1 to N-2\n            diag_sup = 1.0 + 1.0 / (2.0 * i_sup)\n            \n            A_base = np.diag(diag_main) + np.diag(diag_sub, k=-1) + np.diag(diag_sup, k=1)\n            b_base = np.full(size_base, f * h**2)\n\n            u_sol_base = np.linalg.solve(A_base, b_base)\n\n            # Construct full solution vector [u_0, ..., u_N]\n            u_num_base = np.zeros(N + 1)\n            u_num_base[1:N] = u_sol_base # u_num_base at 0 and N remain 0\n        else: # Case N=1\n             u_num_base = np.zeros(N + 1)\n        \n        error_base = calculate_error(u_num_base, u_exact, r)\n        results.append(error_base)\n\n        # --- Mitigated Approximation ---\n        # Solves for unknowns u_0, ..., u_{N-1}. Size NxN.\n        # Boundary conditions: Special equation at r=0, and u_N = 0.\n        size_mit = N\n        A_mit = np.zeros((size_mit, size_mit))\n        b_mit = np.full(size_mit, f * h**2)\n\n        # Row 0: Equation at r=0 is -4*u_0 + 4*u_1 = f*h^2\n        A_mit[0, 0] = -4.0\n        if size_mit > 1:\n            A_mit[0, 1] = 4.0\n\n        # Rows 1 to N-1 (grid indices i=1 to N-1)\n        for i in range(1, size_mit): # i is both matrix row and grid index\n            # Main diagonal term\n            A_mit[i, i] = -2.0\n            # Sub-diagonal term: (1 - 1/(2i)) for u_{i-1}\n            A_mit[i, i - 1] = 1.0 - 1.0 / (2.0 * i)\n            # Super-diagonal term: (1 + 1/(2i)) for u_{i+1}\n            if i  size_mit - 1:\n                A_mit[i, i + 1] = 1.0 + 1.0 / (2.0 * i)\n\n        u_sol_mit = np.linalg.solve(A_mit, b_mit)\n\n        # Construct full solution vector [u_0, ..., u_N]\n        u_num_mit = np.zeros(N + 1)\n        u_num_mit[0:N] = u_sol_mit # u_num_mit at N remains 0\n\n        error_mit = calculate_error(u_num_mit, u_exact, r)\n        results.append(error_mit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2436320"}]}