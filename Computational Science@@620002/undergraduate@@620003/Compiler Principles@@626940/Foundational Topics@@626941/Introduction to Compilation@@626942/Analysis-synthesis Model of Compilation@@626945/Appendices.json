{"hands_on_practices": [{"introduction": "To begin, we'll explore how the analysis-synthesis model operates on a local scale by optimizing simple expressions. The key idea is that the analysis phase can decorate the program's intermediate representation with crucial semantic information, such as whether an expression has side effects or can throw an exception. This exercise [@problem_id:3621439] demonstrates how the synthesis phase uses these annotations to make a concrete decision: whether it is safe to convert a short-circuiting Boolean operator into a more efficient, eager (or branchless) one.", "problem": "A compiler for a language with Boolean expressions uses the analysis–synthesis model of compilation: an analysis pass annotates Intermediate Representation (IR) with semantic facts, and a synthesis pass performs semantics-preserving rewrites guided by those facts. The language has short-circuit conjunction and disjunction, written as $\\land_{\\mathrm{sc}}$ and $\\lor_{\\mathrm{sc}}$, with left-to-right evaluation order. The eager Boolean operators $\\land$ and $\\lor$ evaluate both operands. Observational equivalence means equality of the final produced value, the multiset of externally visible side effects, and the exception behavior.\n\nThe analysis annotates each IR node $e$ with three facts:\n- $pure(e)$ is $\\mathrm{true}$ if $e$ is referentially transparent (no side effects).\n- $nothrow(e)$ is $\\mathrm{true}$ if evaluating $e$ cannot raise any exception or undefined behavior.\n- $order\\_independent(e)$ is $\\mathrm{true}$ if evaluating $e$ does not impose any constraint on relative evaluation order with other expressions (in particular, no inter-expression dependence via side effects).\n\nSuppose the IR contains four Boolean-valued expressions $e_1$, $e_2$, $e_3$, $e_4$ with the following analysis facts:\n- $pure(e_1)=\\mathrm{true}$, $nothrow(e_1)=\\mathrm{true}$, $order\\_independent(e_1)=\\mathrm{true}$.\n- $pure(e_2)=\\mathrm{false}$, $nothrow(e_2)=\\mathrm{true}$, $order\\_independent(e_2)=\\mathrm{false}$.\n- $pure(e_3)=\\mathrm{true}$, $nothrow(e_3)=\\mathrm{false}$, $order\\_independent(e_3)=\\mathrm{true}$.\n- $pure(e_4)=\\mathrm{true}$, $nothrow(e_4)=\\mathrm{true}$, $order\\_independent(e_4)=\\mathrm{true}$.\n\nConsider the IR expression\n$$\nE \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,).\n$$\n\nThe synthesis pass is permitted to convert short-circuiting operators to branchless eager evaluation only when the IR indicates no side effects and safe evaluation order. Which of the following candidate transformations are sound under these rules (i.e., they preserve observational equivalence of $E$ while making only transformations the rules permit)? Choose all that apply.\n\nA. Replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$, leaving the outer $\\lor_{\\mathrm{sc}}$ and the right $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ unchanged.\n\nB. Replace $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ by $e_2 \\;\\land\\; e_3$, leaving the outer $\\lor_{\\mathrm{sc}}$ and the left $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ unchanged.\n\nC. Replace the outer $\\lor_{\\mathrm{sc}}$ by eager $\\lor$, and simultaneously replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$, yielding $E'=(\\, e_1 \\;\\land\\; e_4 \\,) \\;\\lor\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$.\n\nD. Rewrite $E$ into the arithmetic expression\n$$\nE'' \\;=\\; 1 \\;-\\; \\big( 1 - e_1 e_4 \\big)\\, \\big( 1 - e_2 e_3 \\big),\n$$\nwith Boolean values represented as $0$ and $1$, and multiplication and subtraction interpreted over $\\{0,1\\}$, to obtain fully branchless eager evaluation.\n\nAnswer choices should be evaluated strictly under the stated analysis facts and rule: conversion to branchless eager evaluation is allowed only when $pure(\\cdot)$, $nothrow(\\cdot)$, and $order\\_independent(\\cdot)$ indicate safety for the specific operands being converted.", "solution": "The core of the problem is to understand when a short-circuit operator $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ can be replaced by an eager one $A \\;\\text{op}\\; B$.\n\nLet's analyze the difference between $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ and $A \\;\\text{op}\\; B$.\n*   For $A \\;\\land_{\\mathrm{sc}}\\; B$: $B$ is evaluated only if $A$ is $\\mathrm{true}$.\n*   For $A \\;\\lor_{\\mathrm{sc}}\\; B$: $B$ is evaluated only if $A$ is $\\mathrm{false}$.\n*   For $A \\;\\land\\; B$ and $A \\;\\lor\\; B$: Both $A$ and $B$ are always evaluated.\n\nThe transformation from $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ to $A \\;\\text{op}\\; B$ is safe (preserves observational equivalence) if and only if evaluating $B$ when it would have been skipped does not change the program's behavior. The \"skipped\" cases are when $A$ is $\\mathrm{false}$ for $\\land_{\\mathrm{sc}}$ and when $A$ is $\\mathrm{true}$ for $\\lor_{\\mathrm{sc}}$. If we now evaluate $B$ in these cases, what could go wrong?\n1.  **Side Effects:** $B$ could have side effects. If $B$ is skipped, its side effects do not occur. If it is evaluated, they do. This violates observational equivalence. To prevent this, $B$ must be pure. So, we need $pure(B) = \\mathrm{true}$.\n2.  **Exceptions:** $B$ could raise an exception. If $B$ is skipped, no exception is raised (from $B$). If it is evaluated, it might raise an exception. This violates observational equivalence. To prevent this, evaluating $B$ must not raise an exception. So, we need $nothrow(B) = \\mathrm{true}$.\n\nThe problem states a specific rule: \"conversion... is allowed only when the IR indicates no side effects and safe evaluation order.\" It further clarifies this as \"when $pure(\\cdot)$, $nothrow(\\cdot)$, and $order\\_independent(\\cdot)$ indicate safety for the specific operands being converted.\" For the transformation of $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ to be safe, the properties of both operands matter, especially if the evaluation order can change. The most conservative and robust rule, which aligns with the prompt, is that both operands should be pure, non-throwing, and order-independent to allow conversion to an eager, potentially reordered evaluation. However, given the left-to-right evaluation of short-circuiting operators, the most critical constraints apply to the right-hand operand, which might be evaluated when it wasn't before.\n\nLet's restate the properties of $e_1, e_2, e_3, e_4$:\n*   $e_1$: $pure(e_1)=\\mathrm{true}$, $nothrow(e_1)=\\mathrm{true}$, $order\\_independent(e_1)=\\mathrm{true}$.\n*   $e_2$: $pure(e_2)=\\mathrm{false}$, $nothrow(e_2)=\\mathrm{true}$, $order\\_independent(e_2)=\\mathrm{false}$.\n*   $e_3$: $pure(e_3)=\\mathrm{true}$, $nothrow(e_3)=\\mathrm{false}$, $order\\_independent(e_3)=\\mathrm{true}$.\n*   $e_4$: $pure(e_4)=\\mathrm{true}$, $nothrow(e_4)=\\mathrm{true}$, $order\\_independent(e_4)=\\mathrm{true}$.\n\nThe original expression is $E \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$.\nLet $L = e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ and $R = e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$. So $E = L \\lor_{\\mathrm{sc}} R$.\n\nLet's evaluate the options.\n\n**Candidate A: Replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$.**\nThe transformation is $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\rightarrow e_1 \\;\\land\\; e_4$. The operands are $e_1$ and $e_4$.\n- $e_1$: $pure=\\mathrm{true}$, $nothrow=\\mathrm{true}$, $order\\_independent=\\mathrm{true}$.\n- $e_4$: $pure=\\mathrm{true}$, $nothrow=\\mathrm{true}$, $order\\_independent=\\mathrm{true}$.\nBoth operands are pure, non-throwing, and order-independent. The transformation causes $e_4$ to be evaluated even if $e_1$ is false. Since $e_4$ is pure and non-throwing, this extra evaluation has no side effects and cannot raise an exception. The final value is unchanged. The transformation is permitted by the rules and is sound.\nVerdict: **Correct**.\n\n**Candidate B: Replace $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ by $e_2 \\;\\land\\; e_3$.**\nThe transformation is $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\rightarrow e_2 \\;\\land\\; e_3$. The operands are $e_2$ and $e_3$.\n- $e_2$: is not pure and not order-independent.\n- $e_3$: can throw.\nThe transformation would cause $e_3$ to be evaluated even if $e_2$ is false. Since $nothrow(e_3) = \\mathrm{false}$, this could introduce a new exception, violating observational equivalence. The rule states conversion is only allowed when the IR indicates safety. Both operands have properties that make the conversion unsafe.\nVerdict: **Incorrect**.\n\n**Candidate C: Replace the outer $\\lor_{\\mathrm{sc}}$ by eager $\\lor$, and simultaneously replace $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ by $e_1 \\;\\land\\; e_4$, yielding $E'=(\\, e_1 \\;\\land\\; e_4 \\,) \\;\\lor\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$.**\nThis requires transforming the outer $\\lor_{\\mathrm{sc}}$. The operands are $A = (e_1 \\land e_4)$ and $B = (e_2 \\land_{\\mathrm{sc}} e_3)$. We must check the properties of these composite expressions.\n- Properties of $B = (e_2 \\land_{\\mathrm{sc}} e_3)$: Since $e_2$ has side effects ($pure(e_2)=\\mathrm{false}$) and is always evaluated as part of $B$, the expression $B$ itself is not pure. Since $e_3$ can throw ($nothrow(e_3)=\\mathrm{false}$), the expression $B$ can also throw.\nThe transformation of the outer $\\lor_{\\mathrm{sc}}$ would cause $B$ to be evaluated even if $A$ is true. This would introduce the side effects from $e_2$ and a potential exception from $e_3$ in cases where they would not have occurred. The transformation is not permitted and is not sound.\nVerdict: **Incorrect**.\n\n**Candidate D: Rewrite $E$ into the arithmetic expression $E'' \\;=\\; 1 \\;-\\; \\big( 1 - e_1 e_4 \\big)\\, \\big( 1 - e_2 e_3 \\big)$.**\nThis arithmetic expression is equivalent to $(e_1 \\land e_4) \\lor (e_2 \\land e_3)$. This implies a \"fully branchless eager evaluation\", meaning $e_1, e_2, e_3, e_4$ are all evaluated.\nThis is not sound. For example, if $e_1$ and $e_4$ are both true, the original expression $E$ evaluates to $\\mathrm{true}$ without evaluating $e_2$ or $e_3$. The transformed expression $E''$, however, evaluates all four subexpressions. This unconditionally executes $e_2$ (introducing its side effects) and $e_3$ (introducing a potential exception). This violates observational equivalence and is not permitted by the rules.\nVerdict: **Incorrect**.\n\nBased on the analysis, only transformation A is both permitted by the compiler's rules and sound in that it preserves observational equivalence. The operands $e_1$ and $e_4$ are \"perfectly safe\" for this optimization, while any transformation that alters the evaluation conditions for $e_2$ or $e_3$ is unsafe.", "answer": "$$\\boxed{A}$$", "id": "3621439"}, {"introduction": "Next, we move from simple values to the more complex world of memory. One of the most challenging tasks for a compiler is understanding how pointers and memory references interact, a process known as alias analysis. This practice problem [@problem_id:3621393] illustrates a critical concept: the precision of the analysis directly determines the power of the synthesis phase. You will see how increasingly sophisticated alias analysis techniques unlock the ability to safely reorder memory reads and writes, a fundamental optimization for modern processors.", "problem": "In the analysis–synthesis model of compilation, the analysis phase computes conservative alias information that the synthesis (transformation) phase uses to justify memory reordering. A fundamental criterion for reordering a memory read and a write is that the transformation is semantics-preserving in a sequential, single-threaded, non-volatile program if the two memory operations are proven to not access the same abstract location. Equivalently, if two memory operations may access the same abstract location and at least one is a write, there exists a potential memory dependence and the reordering is disallowed.\n\nConsider alias analysis with precision parameter $\\alpha \\in \\{0,1,2\\}$, with the following interpretation:\n- $\\alpha=0$: flow-insensitive, field-insensitive, context-insensitive, heap-insensitive; all pointers of compatible type may alias, and all fields of a structure are merged into one abstract location class.\n- $\\alpha=1$: flow-insensitive, field-sensitive (distinct fields of the same structure are separate abstract locations), context-insensitive, heap-insensitive (all heap allocations are merged into one abstract location class).\n- $\\alpha=2$: flow-insensitive, field-sensitive, context-insensitive, heap allocation–site sensitive (different syntactic allocation sites are distinct abstract locations); additionally, allocations are modeled as returning fresh, non-overlapping memory.\n\nAssume a language with strict sequential semantics, no concurrency, no volatile accesses, and no undefined behavior. Consider the following two straight-line fragments and proposed optimization sequences that attempt to reorder a load and a store. All variables denote pointers to integers, and $\\rightarrow$ denotes field selection through a pointer to a structure instance.\n\nFragment A (structure fields):\n- Program: Let $p$ be a pointer to a structure with integer fields $x$ and $y$. Execute in order:\n  $$\n  S_x:\\; p \\rightarrow x := 1;\\quad L_y:\\; t := p \\rightarrow y.\n  $$\n- Proposed sequence $\\Sigma_A$: Reorder the load before the store, i.e., transform to\n  $$\n  L_y:\\; t := p \\rightarrow y;\\quad S_x:\\; p \\rightarrow x := 1.\n  $$\n\nFragment B (distinct heap allocation sites):\n- Program: Let $a := \\mathrm{alloc}_1()$ and $b := \\mathrm{alloc}_2()$, where $\\mathrm{alloc}_1$ and $\\mathrm{alloc}_2$ denote syntactically distinct allocation sites that each return a fresh, non-overlapping heap object. Execute in order:\n  $$\n  S_a:\\; *a := 0;\\quad L_b:\\; u := *b.\n  $$\n- Proposed sequence $\\Sigma_B$: Reorder the load before the store, i.e., transform to\n  $$\n  L_b:\\; u := *b;\\quad S_a:\\; *a := 0.\n  $$\n\nQuestion. Using only the definitions above and the legality criterion stated at the beginning, which option correctly characterizes which of $\\Sigma_A$ and $\\Sigma_B$ are semantics-preserving under each $\\alpha \\in \\{0,1,2\\}$?\n\nA. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_A$ is legal; under $\\alpha=2$: both $\\Sigma_A$ and $\\Sigma_B$ are legal.\n\nB. Under $\\alpha=0$: $\\Sigma_A$ is legal; under $\\alpha=1$: both $\\Sigma_A$ and $\\Sigma_B$ are legal; under $\\alpha=2$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal.\n\nC. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: neither is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.\n\nD. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_B$ is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.", "solution": "The core of the problem is to determine whether a proposed reordering of a store and a subsequent load is legal. The legality criterion states that such a reordering is permissible if and only if the alias analysis can prove that the two memory operations access distinct abstract locations. If the analysis concludes that the locations *may alias*, a potential memory dependence exists, and the reordering is disallowed. We will evaluate the legality of transformations $\\Sigma_A$ and $\\Sigma_B$ for each precision level $\\alpha \\in \\{0, 1, 2\\}$.\n\n**Analysis for $\\alpha=0$**\nThis level of analysis is defined as flow-insensitive, field-insensitive, context-insensitive, and heap-insensitive.\n\n-   **Fragment A ($\\Sigma_A$)**: The operations are a store $S_x: p \\rightarrow x := 1$ and a load $L_y: t := p \\rightarrow y$. Because the analysis is **field-insensitive**, it merges all fields of a structure into a single abstract location. Thus, from the analyzer's perspective, the abstract location of $p \\rightarrow x$ is indistinguishable from the abstract location of $p \\rightarrow y$. They are considered to *may alias*. Consequently, the compiler must assume a dependence between $S_x$ and $L_y$, making the reordering in $\\Sigma_A$ **not legal**.\n\n-   **Fragment B ($\\Sigma_B$)**: The operations are a store $S_a: *a := 0$ and a load $L_b: u := *b$. The pointers $a$ and $b$ are of compatible types (pointers to integers). The analysis is **heap-insensitive**, meaning all heap allocations are merged into a single abstract location class. The analyzer cannot distinguish between the memory allocated at $\\mathrm{alloc}_1()$ and the memory allocated at $\\mathrm{alloc}_2()$. It must conservatively assume that $a$ and $b$ could point to the same location within this single abstract heap region. Therefore, $*a$ and $*b$ *may alias*. The compiler must assume a dependence, and the reordering in $\\Sigma_B$ is **not legal**.\n\n-   **Conclusion for $\\alpha=0$**: Neither $\\Sigma_A$ nor $\\Sigma_B$ is legal.\n\n**Analysis for $\\alpha=1$**\nThis level of analysis is flow-insensitive, **field-sensitive**, context-insensitive, and heap-insensitive.\n\n-   **Fragment A ($\\Sigma_A$)**: The analysis is **field-sensitive**. This is the crucial difference from $\\alpha=0$. It treats distinct fields ($x$ and $y$) of the same structure as separate abstract locations. The analyzer can therefore prove that $p \\rightarrow x$ and $p \\rightarrow y$ access disjoint memory regions. With no memory dependence between $S_x$ and $L_y$, the reordering in $\\Sigma_A$ is semantics-preserving and thus **legal**.\n\n-   **Fragment B ($\\Sigma_B$)**: The analysis remains **heap-insensitive**. As with $\\alpha=0$, all heap allocations are collapsed into a single abstract location. The improvement in field sensitivity does not apply here. The analysis is still unable to distinguish between the memory pointed to by $a$ (from $\\mathrm{alloc}_1()$) and by $b$ (from $\\mathrm{alloc}_2()$). It must conservatively assume $*a$ and $*b$ *may alias*. The reordering in $\\Sigma_B$ is **not legal**.\n\n-   **Conclusion for $\\alpha=1$**: Only $\\Sigma_A$ is legal.\n\n**Analysis for $\\alpha=2$**\nThis level of analysis is flow-insensitive, **field-sensitive**, context-insensitive, and **heap allocation-site sensitive**.\n\n-   **Fragment A ($\\Sigma_A$)**: The analysis is field-sensitive, just as for $\\alpha=1$. It can prove that $p \\rightarrow x$ and $p \\rightarrow y$ are distinct locations. Therefore, the reordering in $\\Sigma_A$ remains **legal**.\n\n-   **Fragment B ($\\Sigma_B$)**: The analysis is **heap allocation-site sensitive**. This means it can distinguish objects created at different syntactic allocation sites. Since $a$ is assigned the result of $\\mathrm{alloc}_1()$ and $b$ is assigned the result of $\\mathrm{alloc}_2()$, and these are syntactically distinct sites, the analyzer models the memory locations they point to as distinct and non-overlapping abstract locations. It can prove that $*a$ and $*b$ do not alias. With no memory dependence, the reordering in $\\Sigma_B$ is **legal**.\n\n-   **Conclusion for $\\alpha=2$**: Both $\\Sigma_A$ and $\\Sigma_B$ are legal.\n\n**Summary of Conclusions:**\n-   For $\\alpha=0$: Neither $\\Sigma_A$ nor $\\Sigma_B$ is legal.\n-   For $\\alpha=1$: Only $\\Sigma_A$ is legal.\n-   For $\\alpha=2$: Both $\\Sigma_A$ and $\\Sigma_B$ are legal.\n\n**Evaluation of Options:**\n\n-   **A. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_A$ is legal; under $\\alpha=2$: both $\\Sigma_A$ and $\\Sigma_B$ are legal.**\n    This statement perfectly matches our derived conclusions for all three values of $\\alpha$.\n    **Verdict: Correct.**\n\n-   **B. Under $\\alpha=0$: $\\Sigma_A$ is legal; under $\\alpha=1$: both $\\Sigma_A$ and $\\Sigma_B$ are legal; under $\\alpha=2$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal.**\n    This statement is incorrect on all three counts.\n    **Verdict: Incorrect.**\n\n-   **C. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: neither is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.**\n    This statement is incorrect for $\\alpha=1$ (where $\\Sigma_A$ is legal) and for $\\alpha=2$ (where $\\Sigma_A$ is also legal).\n    **Verdict: Incorrect.**\n\n-   **D. Under $\\alpha=0$: neither $\\Sigma_A$ nor $\\Sigma_B$ is legal; under $\\alpha=1$: only $\\Sigma_B$ is legal; under $\\alpha=2$: only $\\Sigma_B$ is legal.**\n    This statement is incorrect for $\\alpha=1$ (it reverses the legalities of $\\Sigma_A$ and $\\Sigma_B$) and for $\\alpha=2$ (where $\\Sigma_A$ is also legal).\n    **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3621393"}, {"introduction": "Finally, we scale up our perspective to see how the analysis-synthesis model enables powerful global optimizations that restructure the entire program. This exercise [@problem_id:3621417] delves into global code motion, an optimization that moves instructions across basic blocks to reduce redundant computations, often by hoisting them to positions where they dominate all their uses. By working with a Control Flow Graph (CFG) in Static Single Assignment (SSA) form, you will act as the synthesis phase, using pre-computed safety information and dominator analysis to determine the optimal placement for each piece of code.", "problem": "A compiler applies the analysis-synthesis model to perform global code motion on a program in Static Single Assignment (SSA) form over a Control Flow Graph (CFG). The analysis phase has computed, for each instruction node $n$, a Boolean flag $MotionSafe(n)$ indicating whether moving $n$ to an earlier CFG block preserves the observable semantics, including memory effects and exceptions. The synthesis phase must place each movable computation to a block that dominates all its uses, subject to operand availability and the constraint that side-effecting or potentially-exceptional operations remain stationary wherever $MotionSafe(n)$ is not satisfied. For correctness, the synthesis must place each movable node into the minimal block (in the dominator tree) that still dominates all its uses, so as not to increase live ranges beyond necessity.\n\nConsider the following CFG with blocks $b_0$ (entry), $b_1$, $b_2$, $b_3$, and $b_4$:\n- Control-flow: $b_0 \\to b_1$, $b_1$ branches to $b_2$ and $b_3$, and both $b_2$ and $b_3$ go to $b_4$. The dominator relationships are: $b_0$ dominates $b_1$, and $b_1$ dominates $b_2$, $b_3$, and $b_4$. The immediate dominators are $idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$.\n- Instructions (SSA names in math):\n  - In $b_1$: $n_1$: $x := a + b$, with $MotionSafe(n_1) = \\mathrm{true}$. Then branch on $p$.\n  - In $b_2$: $n_2$: $t_2 := x \\times 2$, with $MotionSafe(n_2) = \\mathrm{true}$. Then $n_3$: $store(s, t_2)$, with $MotionSafe(n_3) = \\mathrm{false}$. Then goto $b_4$.\n  - In $b_3$: $n_4$: $t_4 := x \\times 3$, with $MotionSafe(n_4) = \\mathrm{true}$. Then $n_5$: $t_5 := u / v$, with $MotionSafe(n_5) = \\mathrm{false}$ due to potential divide-by-zero exception. Then goto $b_4$.\n  - In $b_4$: $\\phi$: $y := \\phi(t_2, t_4)$. Then $n_6a$: $l := load(q)$, with $MotionSafe(n_6a) = \\mathrm{true}$ and alias analysis guarantees the store to $s$ does not alias $q$. Then $n_6b$: $z := y + l$, with $MotionSafe(n_6b) = \\mathrm{true}$.\n\nDefinitions:\n- Dominance: A block $d$ dominates a block $m$ if every path from $b_0$ to $m$ contains $d$.\n- Minimal dominating placement: For a node $n$ with uses in blocks $\\{u_i\\}$, a legal placement block $d$ must dominate every $u_i$ and be minimal in the dominator tree, meaning no strict descendant of $d$ also dominates all $\\{u_i\\}$.\n\nSubject to these rules:\n- Only nodes $n$ with $MotionSafe(n) = \\mathrm{true}$ may be moved earlier.\n- Nodes with $MotionSafe(n) = \\mathrm{false}$ remain stationary and must not be reordered across control-flow such that their execution frequency or ordering changes.\n- A moved node must be placed where all its operands are available (i.e., the block of placement must dominate the definitions of its operands) and the node must dominate all its uses.\n\nWhich of the following scheduling choices is both legal and consistent with the minimal dominating placement policy?\n\nA. Keep $n_1$ in $b_1$. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$. Keep $n_6a$ and $n_6b$ in $b_4$.\n\nB. Move $n_1$ from $b_1$ to $b_0$. Move $n_2$ from $b_2$ to $b_0$. Move $n_4$ from $b_3$ to $b_0$. Move $n_6a$ from $b_4$ to $b_0$. Move $n_6b$ from $b_4$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$.\n\nC. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Move $n_5$ from $b_3$ to $b_1$. Move $n_6b$ from $b_4$ to $b_1$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, and $n_6a$ in $b_4$.\n\nD. Move $n_2$ from $b_2$ to $b_1$. Keep $n_4$ in $b_3$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, $n_5$ in $b_3$, and $n_6a$, $n_6b$ in $b_4$.", "solution": "The synthesis phase must determine the correct placement for each movable instruction (where $MotionSafe(n) = \\mathrm{true}$) based on the rules. Stationary instructions ($MotionSafe(n) = \\mathrm{false}$) are $n_3$ in $b_2$ and $n_5$ in $b_3$.\n\nFirst, let's establish the dominator tree from the given immediate dominators: $b_0$ is the parent of $b_1$, and $b_1$ is the parent of $b_2$, $b_3$, and $b_4$.\n\nWe will now analyze each movable instruction according to the placement rules.\n\n1.  **Instruction $n_1: x := a + b$ (originally in $b_1$)**\n    -   $MotionSafe(n_1) = \\mathrm{true}$.\n    -   **Uses**: The result $x$ is used by $n_2$ in block $b_2$ and by $n_4$ in block $b_3$. The set of use blocks is $\\{b_2, b_3\\}$.\n    -   **Dominance Requirement**: The placement block must dominate both $b_2$ and $b_3$. The common dominators of $b_2$ and $b_3$ are $\\{b_0, b_1\\}$.\n    -   **Minimal Placement**: The minimal dominating block in the dominator tree is $b_1$.\n    -   **Operand Availability**: Operands $a$ and $b$ are global or parameters, assumed available at the entry, so they are available in $b_1$.\n    -   **Conclusion**: The optimal placement for $n_1$ is its original block, $b_1$. It should be kept in $b_1$.\n\n2.  **Instruction $n_2: t_2 := x \\times 2$ (originally in $b_2$)**\n    -   $MotionSafe(n_2) = \\mathrm{true}$.\n    -   **Uses**: The result $t_2$ is used by $n_3$ in $b_2$ and as an input to the $\\phi$-function in $b_4$. The set of use blocks is $\\{b_2, b_4\\}$.\n    -   **Dominance Requirement**: The placement block must dominate both $b_2$ and $b_4$. The common dominators are $\\{b_0, b_1\\}$.\n    -   **Minimal Placement**: The minimal dominating block is $b_1$.\n    -   **Operand Availability**: The operand is $x$, which is defined by $n_1$ in block $b_1$. Since $b_1$ is the target placement block, the operand $x$ is available.\n    -   **Conclusion**: $n_2$ should be moved from $b_2$ to $b_1$.\n\n3.  **Instruction $n_4: t_4 := x \\times 3$ (originally in $b_3$)**\n    -   $MotionSafe(n_4) = \\mathrm{true}$.\n    -   **Uses**: The result $t_4$ is used as an input to the $\\phi$-function in $b_4$. The set of use blocks is $\\{b_4\\}$.\n    -   **Dominance Requirement**: The placement block must dominate $b_4$. The legal hoisting targets that dominate the original block $b_3$ are $\\{b_0, b_1\\}$. Both also dominate the use block $b_4$.\n    -   **Minimal Placement**: Between $\\{b_0, b_1\\}$, the minimal one is $b_1$.\n    -   **Operand Availability**: The operand is $x$, defined by $n_1$ in $b_1$. The operand is available in the target block $b_1$.\n    -   **Conclusion**: $n_4$ should be moved from $b_3$ to $b_1$.\n\n4.  **Instruction $n_{6a}: l := load(q)$ (originally in $b_4$)**\n    -   $MotionSafe(n_{6a}) = \\mathrm{true}$.\n    -   **Uses**: The result $l$ is used by $n_{6b}$ in $b_4$. The set of use blocks is $\\{b_4\\}$.\n    -   **Dominance Requirement**: The placement block must dominate $b_4$. The set of dominators of $b_4$ is $\\{b_0, b_1, b_4\\}$.\n    -   **Minimal Placement**: The minimal dominating block is $b_4$ itself.\n    -   **Conclusion**: The optimal placement for $n_{6a}$ is its original block, $b_4$. It should be kept in $b_4$.\n\n5.  **Instruction $n_{6b}: z := y + l$ (originally in $b_4$)**\n    -   $MotionSafe(n_{6b}) = \\mathrm{true}$.\n    -   **Uses**: The problem implies $z$ is used after this instruction within $b_4$ or is live-out from $b_4$. So the use block is $b_4$.\n    -   **Operand Availability**: The operands are $y$ and $l$. The operand $y$ is defined by a $\\phi$-function at the entry of $b_4$. The value from a $\\phi$-function is only available *within* the block where it is defined. Therefore, $y$ is not available in any block that strictly dominates $b_4$ (i.e., not in $b_1$ or $b_0$).\n    -   **Conclusion**: Due to operand $y$ being unavailable outside of $b_4$, $n_{6b}$ cannot be moved. It must be kept in $b_4$.\n\n**Summary of Optimal Placements**:\n- $n_1$: Keep in $b_1$.\n- $n_2$: Move to $b_1$.\n- $n_3$: Keep in $b_2$ (stationary).\n- $n_4$: Move to $b_1$.\n- $n_5$: Keep in $b_3$ (stationary).\n- $n_{6a}$: Keep in $b_4$.\n- $n_{6b}$: Keep in $b_4$.\n\n### Option-by-Option Analysis\n\n**A. Keep $n_1$ in $b_1$. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$. Keep $n_6a$ and $n_6b$ in $b_4$.**\nThis option matches our derived schedule in every detail.\n**Verdict: Correct.**\n\n**B. Move $n_1$ from $b_1$ to $b_0$. Move $n_2$ from $b_2$ to $b_0$. Move $n_4$ from $b_3$ to $b_0$. Move $n_{6a}$ from $b_4$ to $b_0$. Move $n_{6b}$ from $b_4$ to $b_1$. Keep $n_3$ in $b_2$ and $n_5$ in $b_3$.**\nThis option violates the minimal dominating placement rule for $n_1$, $n_2$, and $n_4$ (placing them too high). It also illegally moves $n_{6b}$ where its operand $y$ is unavailable.\n**Verdict: Incorrect.**\n\n**C. Move $n_2$ from $b_2$ to $b_1$. Move $n_4$ from $b_3$ to $b_1$. Move $n_5$ from $b_3$ to $b_1$. Move $n_{6b}$ from $b_4$ to $b_1$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, and $n_{6a}$ in $b_4$.**\nThis option illegally moves $n_5$ ($MotionSafe=\\mathrm{false}$) and $n_{6b}$ (operand unavailable).\n**Verdict: Incorrect.**\n\n**D. Move $n_2$ from $b_2$ to $b_1$. Keep $n_4$ in $b_3$. Keep $n_1$ in $b_1$, $n_3$ in $b_2$, $n_5$ in $b_3$, and $n_{6a}$, $n_{6b}$ in $b_4$.**\nThis option fails to move $n_4$, which is movable and for which the synthesis policy dictates a move to $b_1$ is optimal. Keeping it in $b_3$ is inconsistent with the required optimization policy.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3621417"}]}