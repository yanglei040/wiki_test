{"hands_on_practices": [{"introduction": "Before diving into complex constructions, it's crucial to master the fundamental mechanics of NFA simulation with $\\varepsilon$-transitions. This practice challenges you to trace a given input string through an NFA, step-by-step, correctly applying the concept of $\\varepsilon$-closure. By calculating the set of active states after each input symbol, you will solidify your understanding of how an NFA explores multiple paths simultaneously, including those that don't consume input. [@problem_id:1388210]", "problem": "A computer scientist is designing a simple lexical analysis tool based on a Nondeterministic Finite Automaton (NFA) to detect a specific pattern in a binary data stream. The NFA is formally defined with the following components:\n- A set of states $Q = \\{q_0, q_1, q_2, q_3\\}$.\n- An input alphabet $\\Sigma = \\{0, 1\\}$.\n- A start state $q_{start} = q_0$.\n- A set of accept states $F = \\{q_3\\}$.\n\nThe transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the power set of $Q$ and $\\varepsilon$ denotes the empty string, is given by the following table of rules. Note that if a state-input pair is not listed, its transition leads to the empty set $\\emptyset$.\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\varepsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\nGiven the input string `101`, determine the set of all possible states the machine could be in after processing the entire string. Select the correct set from the options below.\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "For an NFA with $\\varepsilon$-transitions, at each step we compute the $\\varepsilon$-closure of the current set of states, then move on the input symbol, and finally take the $\\varepsilon$-closure again. Let $\\text{E}(S)$ denote the $\\varepsilon$-closure of a set $S$. Unspecified transitions go to the empty set.\n\nInitial closure:\n$$\nS_0 = \\text{E}(\\{q_0\\}) = \\{q_0\\}\n$$\n\nAfter reading the first symbol $1$:\n$$\nT_1 = \\bigcup_{q \\in S_0} \\delta(q, 1) = \\delta(q_0, 1) = \\{q_0, q_1\\}\n$$\n$$\nS_1 = \\text{E}(T_1) = \\{q_0, q_1\\} \\cup \\delta(q_1, \\varepsilon) = \\{q_0, q_1, q_2\\}\n$$\n\nAfter reading the second symbol $0$:\n$$\nT_2 = \\bigcup_{q \\in S_1} \\delta(q, 0) = \\delta(q_0, 0) \\cup \\delta(q_1, 0) \\cup \\delta(q_2, 0) = \\{q_0\\} \\cup \\{q_2\\} \\cup \\emptyset = \\{q_0, q_2\\}\n$$\n$$\nS_2 = \\text{E}(T_2) = \\{q_0, q_2\\}\n$$\n\nAfter reading the third symbol $1$:\n$$\nT_3 = \\bigcup_{q \\in S_2} \\delta(q, 1) = \\delta(q_0, 1) \\cup \\delta(q_2, 1) = \\{q_0, q_1\\} \\cup \\{q_3\\} = \\{q_0, q_1, q_3\\}\n$$\n$$\nS_3 = \\text{E}(T_3) = \\{q_0, q_1, q_3\\} \\cup \\delta(q_1, \\varepsilon) = \\{q_0, q_1, q_2, q_3\\}\n$$\n\nTherefore, after processing the entire string `101`, the set of possible states is $\\{q_0, q_1, q_2, q_3\\}$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "Having practiced the mechanics of simulation, let's explore the conceptual impact of $\\varepsilon$-transitions on the language an NFA recognizes. This thought experiment demonstrates how adding a single $\\varepsilon$-edge can subtly but significantly alter an automaton's behavior, causing it to accept strings it previously rejected. By comparing the original NFA with its modified version, you will gain a deeper intuition for how $\\varepsilon$-moves create \"shortcuts\" and enable the recognition of optional or alternative patterns. [@problem_id:3683714]", "problem": "Consider a Non-deterministic Finite Automaton (NFA) $\\mathcal{N}_0$ over the alphabet $\\Sigma = \\{a, b\\}$, with state set $Q = \\{q_0, q_1, q_2, q_3\\}$, start state $q_0$, accept set $F = \\{q_3\\}$, and transition function $\\delta$ given by:\n- $\\delta(q_0, a) = \\{q_1\\}$,\n- $\\delta(q_1, b) = \\{q_2\\}$,\n- $\\delta(q_2, a) = \\{q_3\\}$,\n- all other $\\delta(q_i, x)$ for $x \\in \\{a, b\\}$ are $\\emptyset$,\n- there are no $\\varepsilon$-transitions in $\\mathcal{N}_0$.\n\nA modified NFA $\\mathcal{N}_1$ is obtained by adding a single $\\varepsilon$-transition from the mid-state $q_2$ to the accept state $q_3$, i.e., $\\delta(q_2, \\varepsilon) = \\{q_3\\}$, while leaving all other components unchanged. Intuitively, this change may cause $\\mathcal{N}_1$ to accept certain prefixes of strings that $\\mathcal{N}_0$ originally required to be extended with a final symbol.\n\nUsing first principles of NFA acceptance with $\\varepsilon$-transitions and $\\varepsilon$-closure, determine which of the following input strings are accepted by $\\mathcal{N}_1$ but not accepted by $\\mathcal{N}_0$. Select all that apply.\n\nA. $ab$\n\nB. $aba$\n\nC. $a$\n\nD. $\\varepsilon$\n\nE. $b$", "solution": "To determine which strings are accepted by $\\mathcal{N}_1$ but not by $\\mathcal{N}_0$, we must first analyze the language accepted by each automaton.\n\n**Language of $\\mathcal{N}_0$**\n\nThe automaton $\\mathcal{N}_0$ has no $\\varepsilon$-transitions. To reach the sole accept state $q_3$, one must follow the path $q_0 \\xrightarrow{a} q_1 \\xrightarrow{b} q_2 \\xrightarrow{a} q_3$. This path corresponds to the input string `aba`. Therefore, the language accepted by $\\mathcal{N}_0$ is $L(\\mathcal{N}_0) = \\{aba\\}$. None of the other option strings form a valid path to an accepting state in $\\mathcal{N}_0$.\n\n**Language of $\\mathcal{N}_1$**\n\nThe automaton $\\mathcal{N}_1$ is identical to $\\mathcal{N}_0$ but with an added $\\varepsilon$-transition from $q_2$ to $q_3$. We analyze the acceptance of each option string for $\\mathcal{N}_1$:\n\n- **String `ab`**: The input `ab` leads the automaton to state $q_2$ via the path $q_0 \\xrightarrow{a} q_1 \\xrightarrow{b} q_2$. From state $q_2$, the automaton can take a \"free\" $\\varepsilon$-transition to state $q_3$. Since $q_3$ is an accept state, the string `ab` is **accepted** by $\\mathcal{N}_1$.\n\n- **String `aba`**: This string is still accepted, as it leads to state $q_3$ just as in $\\mathcal{N}_0$.\n\n- **Strings `a`, `b`, `$\\varepsilon$`**: None of these strings lead to a state from which an accept state is reachable (even with the new $\\varepsilon$-transition). For example, after input `a`, the automaton is in state $q_1$, from which there is no path to $q_3$.\n\n**Conclusion**\n\n- String `ab`: Not accepted by $\\mathcal{N}_0$, but accepted by $\\mathcal{N}_1$. This matches the condition.\n- String `aba`: Accepted by both $\\mathcal{N}_0$ and $\\mathcal{N}_1$. This does not match.\n- All other options are accepted by neither.\n\nTherefore, the only string accepted by $\\mathcal{N}_1$ but not by $\\mathcal{N}_0$ is `ab`.", "answer": "$$\\boxed{A}$$", "id": "3683714"}, {"introduction": "The final hands-on challenge bridges theory and practice by asking you to implement the $\\varepsilon$-closure algorithm itself. Computing the $\\varepsilon$-closure is equivalent to a graph reachability search, a fundamental computer science problem that can be solved efficiently using algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS). This coding exercise will solidify your understanding by requiring you to translate the abstract definition into a working function that correctly handles edge cases such as cycles, disconnected components, and empty sets. [@problem_id:3683779]", "problem": "You are to implement, in a general-purpose programming language, a robust function that computes the $\\varepsilon$-closure of a set of states in a Nondeterministic Finite Automaton (NFA). Your program must embed and execute a predefined unit test suite that probes correctness over edge cases including self-loops, multi-edges, disconnected components, cycles, empty transition sets, and empty starting sets. The program must produce the results for all test cases as a single, precisely formatted line.\n\nFundamental base and definitions to be used:\n- An NFA is a quintuple $(Q,\\Sigma,\\delta,q_0,F)$, where $Q$ is a finite set of states, $\\Sigma$ is an input alphabet, $\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$ is a transition function, $q_0 \\in Q$ is the start state, and $F \\subseteq Q$ is the set of accepting states. Only $\\varepsilon$-transitions are relevant in this problem.\n- For a set of states $S \\subseteq Q$, the $\\varepsilon$-closure, $\\varepsilon\\text{-closure}(S)$, is defined as the least set $C \\subseteq Q$ such that:\n  - $S \\subseteq C$, and\n  - for any $p \\in C$, if there exists an $\\varepsilon$-transition from $p$ to $q$ (i.e., $q \\in \\delta(p,\\varepsilon)$), then $q \\in C$.\n- The least set here is with respect to set inclusion, and can be characterized as the set of all states reachable from $S$ by following zero or more $\\varepsilon$-transitions.\n\nRepresentation and constraints:\n- States are identified by nonnegative integers, $Q = \\{0,1,\\dots,N-1\\}$ for some integer $N \\ge 1$.\n- The $\\varepsilon$-transition relation is represented as a directed graph on $Q$ by a multiset of ordered pairs $E_\\varepsilon \\subseteq Q \\times Q$. Multi-edges are permitted; that is, the same ordered pair may appear multiple times. Self-loops are also permitted.\n- The input alphabet $\\Sigma$, the non-$\\varepsilon$ transitions, and acceptance are irrelevant to this task and must be ignored.\n\nYour $\\varepsilon$-closure function must accept a set $S \\subseteq Q$ (possibly empty) and return the set $\\varepsilon\\text{-closure}(S)$ as a sorted list of distinct state identifiers in ascending order.\n\nTest suite specification to embed in the program:\n- Use the following seven test cases. For each test case, you are given the number of states $N$, the multiset of $\\varepsilon$-edges $E_\\varepsilon$ listed as ordered pairs, and the starting set $S$.\n  - Test case $1$ (self-loop plus forward chain):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(0,0),(0,1),(1,2)\\}$\n    - $S = \\{0\\}$\n  - Test case $2$ (multi-edges):\n    - $N = 4$\n    - $E_\\varepsilon = \\{(1,2),(1,2),(2,3),(2,3)\\}$\n    - $S = \\{1\\}$\n  - Test case $3$ (disconnected components; isolated query):\n    - $N = 6$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(3,4)\\}$\n    - $S = \\{5\\}$\n  - Test case $4$ (empty $\\varepsilon$-transition graph; multi-source set):\n    - $N = 3$\n    - $E_\\varepsilon = \\varnothing$\n    - $S = \\{0,2\\}$\n  - Test case $5$ (cycle via $\\varepsilon$-transitions):\n    - $N = 5$\n    - $E_\\varepsilon = \\{(0,1),(1,0),(1,2),(2,1)\\}$\n    - $S = \\{0\\}$\n  - Test case $6$ (empty starting set on a graph with a self-loop):\n    - $N = 1$\n    - $E_\\varepsilon = \\{(0,0)\\}$\n    - $S = \\varnothing$\n  - Test case $7$ (branching, union over multiple components, and an unreachable self-loop):\n    - $N = 7$\n    - $E_\\varepsilon = \\{(0,1),(1,2),(1,3),(3,5),(4,4),(2,6)\\}$\n    - $S = \\{1,4\\}$\n\nAlgorithmic expectations:\n- The computation must rely solely on the definition of $\\varepsilon\\text{-closure}(S)$ as the least fixed point under $\\varepsilon$-reachability. This can be operationalized by a graph reachability computation over $\\varepsilon$-edges starting from $S$, maintaining a visited set to avoid infinite regress on cycles and to collapse multi-edges.\n- Self-loops, cycles, and multi-edges must not cause nontermination or duplication in the output; duplicates must be eliminated by set semantics and the final output must be sorted ascending.\n\nAnswer type and final output format:\n- For each test case, the result is a list of integers representing $\\varepsilon\\text{-closure}(S)$ in ascending order. For the empty set, output an empty list.\n- Your program should produce a single line of output containing the results for the seven test cases as a comma-separated list enclosed in square brackets, where each individual result is itself a bracketed, comma-separated list of state identifiers in ascending order with no spaces. For example, an output conforming to this specification looks like `[[0,1],[2],[]]` where the third result is an empty list. Your program must exactly print the aggregated results in this single-line format with no additional characters or whitespace.", "solution": "The core of the problem is to compute the $\\varepsilon$-closure of a given set of states $S$ in a Nondeterministic Finite Automaton (NFA). The NFA's states are given as a set $Q = \\{0, 1, \\dots, N-1\\}$, and its $\\varepsilon$-transitions are represented as a directed graph $G = (Q, E_\\varepsilon)$, where $E_\\varepsilon$ is a multiset of ordered pairs denoting the transitions.\n\nThe definition of $\\varepsilon\\text{-closure}(S)$ is the smallest set containing $S$ that is closed under the $\\varepsilon$-transition relation. This is equivalent to finding all states in $Q$ that are reachable from any state in $S$ by traversing zero or more $\\varepsilon$-edges. This recharacterization frames the problem as one of graph reachability.\n\nA standard and efficient algorithm for determining reachability in a directed graph is a graph traversal, such as a Depth-First Search (DFS) or a Breadth-First Search (BFS). We will use a DFS-based approach.\n\nThe algorithm proceeds as follows:\n$1$. **Graph Representation**: The input multiset of edges $E_\\varepsilon$ is first converted into an adjacency list representation. For each state $u \\in Q$, we maintain a list of states $v$ for which an edge $(u, v) \\in E_\\varepsilon$ exists. This allows for efficient retrieval of all states reachable from a given state in a single step.\n\n$2$. **Initialization**: We require two auxiliary data structures:\n    - A set to store the states that have been visited during the traversal, to avoid redundant processing and to correctly handle cycles. A boolean array of size $N$, let's call its conceptual representation $V$, initialized to false, serves this purpose.\n    - A stack, which we can call the `worklist`, to manage the states to be visited as part of the DFS.\n\n$3$. **Seeding the Traversal**: The traversal starts from the initial set of states $S$. For each state $s \\in S$, we mark its corresponding entry in $V$ as true and push $s$ onto the `worklist`. This ensures that all states in $S$ are part of the final closure, satisfying the condition $S \\subseteq \\varepsilon\\text{-closure}(S)$.\n\n$4$. **Iterative Deepening**: The main part of the algorithm is a loop that continues as long as the `worklist` is not empty. In each iteration:\n    - A state $u$ is popped from the `worklist`.\n    - We look up the neighbors of $u$ in the adjacency list. For each neighbor $v$ (i.e., for each transition $u \\xrightarrow{\\varepsilon} v$):\n    - If $v$ has not yet been visited (i.e., its entry in $V$ is false), we mark it as visited by setting its entry in $V$ to true and push $v$ onto the `worklist`.\n\n$5$. **Result Extraction**: When the `worklist` becomes empty, the traversal is complete. The set of all visited states, represented by the true entries in $V$, constitutes the $\\varepsilon\\text{-closure}(S)$. To produce the required sorted output, we can iterate from state $0$ to $N-1$ and collect all states $i$ for which the $i$-th entry in $V$ is true. This process naturally yields a sorted list of the states in the closure.\n\nThis algorithmic approach is robust and correctly manages all specified edge cases:\n- **Cycles and Self-Loops**: The use of the visited set $V$ ensures that each state is processed at most once, preventing the traversal from entering an infinite loop.\n- **Multi-edges**: The construction of the adjacency list or the logic within the traversal naturally handles multi-edges. While a state may be added as a neighbor multiple times, the check against the visited set $V$ ensures it is pushed to the `worklist` only on its first encounter.\n- **Disconnected Components**: The traversal algorithm only explores states reachable from the initial set $S$. Any states in components not reachable from $S$ will never be visited.\n- **Empty Starting Set ($S = \\varnothing$)}: If $S$ is empty, the `worklist` is never seeded, the main loop does not execute, and the resulting closure is correctly identified as the empty set.\n- **Empty Transition Set ($E_\\varepsilon = \\varnothing$)}: If there are no transitions, no new states can be reached from $S$. The algorithm will visit only the states in $S$ itself, correctly yielding $\\varepsilon\\text{-closure}(S) = S$.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration of the helper function for computing epsilon-closure.\nvoid compute_epsilon_closure(int N, const void* edges, int edge_count, const int* S, int s_count, int* closure, int* closure_count);\n\n// A helper struct for defining an edge (transition).\ntypedef struct {\n    int from;\n    int to;\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;\n    const Edge* edges;\n    int edge_count;\n    const int* S;\n    int s_count;\n} TestCase;\n\nint main(void) {\n    // ---- Test Case 1: self-loop plus forward chain ----\n    const Edge edges1[] = {{0,0}, {0,1}, {1,2}};\n    const int s1[] = {0};\n\n    // ---- Test Case 2: multi-edges ----\n    const Edge edges2[] = {{1,2}, {1,2}, {2,3}, {2,3}};\n    const int s2[] = {1};\n\n    // ---- Test Case 3: disconnected components; isolated query ----\n    const Edge edges3[] = {{0,1}, {1,2}, {3,4}};\n    const int s3[] = {5};\n\n    // ---- Test Case 4: empty epsilon-transition graph; multi-source set ----\n    const Edge edges4[] = {};\n    const int s4[] = {0,2};\n\n    // ---- Test Case 5: cycle via epsilon-transitions ----\n    const Edge edges5[] = {{0,1}, {1,0}, {1,2}, {2,1}};\n    const int s5[] = {0};\n\n    // ---- Test Case 6: empty starting set on a graph with a self-loop ----\n    const Edge edges6[] = {{0,0}};\n    const int s6[] = {};\n\n    // ---- Test Case 7: branching, union over multiple components, and an unreachable self-loop ----\n    const Edge edges7[] = {{0,1}, {1,2}, {1,3}, {3,5}, {4,4}, {2,6}};\n    const int s7[] = {1,4};\n\n    // Define the test cases from the problem statement.\n    const TestCase test_cases[] = {\n        {4, edges1, sizeof(edges1)/sizeof(Edge), s1, sizeof(s1)/sizeof(int)},\n        {4, edges2, sizeof(edges2)/sizeof(Edge), s2, sizeof(s2)/sizeof(int)},\n        {6, edges3, sizeof(edges3)/sizeof(Edge), s3, sizeof(s3)/sizeof(int)},\n        {3, edges4, sizeof(edges4)/sizeof(Edge), s4, sizeof(s4)/sizeof(int)},\n        {5, edges5, sizeof(edges5)/sizeof(Edge), s5, sizeof(s5)/sizeof(int)},\n        {1, edges6, sizeof(edges6)/sizeof(Edge), s6, sizeof(s6)/sizeof(int)},\n        {7, edges7, sizeof(edges7)/sizeof(Edge), s7, sizeof(s7)/sizeof(int)},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        int N = test_cases[i].N;\n        // Use a Variable Length Array (VLA) for results, which is fine in C23.\n        int result[N];\n        int result_count = 0;\n        \n        compute_epsilon_closure(\n            N,\n            test_cases[i].edges,\n            test_cases[i].edge_count,\n            test_cases[i].S,\n            test_cases[i].s_count,\n            result,\n            &result_count\n        );\n        \n        printf(\"[\");\n        for (int j = 0; j < result_count; ++j) {\n            printf(\"%d\", result[j]);\n            if (j < result_count - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"]\");\n        \n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Computes the epsilon-closure of a set of states in an NFA.\n *\n * This function implements a Depth-First Search (DFS) to find all states\n * reachable from an initial set S via zero or more epsilon transitions.\n *\n * @param N The total number of states in the NFA, labeled 0 to N-1.\n * @param edges A pointer to an array of Edge structs representing epsilon transitions.\n * @param edge_count The number of edges in the epsilon transition graph.\n * @param S A pointer to an array of integers representing the initial set of states.\n * @param s_count The number of states in the initial set S.\n * @param closure A pointer to an integer array where the resulting closure set will be stored.\n * @param closure_count A pointer to an integer that will be updated with the size of the closure set.\n */\nvoid compute_epsilon_closure(int N, const void* edges_void, int edge_count, const int* S, int s_count, int* closure, int* closure_count) {\n    if (N <= 0) {\n        *closure_count = 0;\n        return;\n    }\n    const Edge* edges = (const Edge*) edges_void;\n\n    // A node for the adjacency list.\n    typedef struct AdjNode {\n        int state;\n        struct AdjNode* next;\n    } AdjNode;\n    \n    // 1. Build adjacency list representation of the graph.\n    AdjNode** adj = (AdjNode**)calloc(N, sizeof(AdjNode*));\n    if (!adj) return; // Allocation failure.\n\n    for (int i = 0; i < edge_count; ++i) {\n        AdjNode* newNode = (AdjNode*)malloc(sizeof(AdjNode));\n        if (!newNode) { // Allocation failure\n             // Cleanup previously allocated nodes\n            for (int k = 0; k < N; ++k) {\n                AdjNode* current = adj[k];\n                while(current) {\n                    AdjNode* temp = current;\n                    current = current->next;\n                    free(temp);\n                }\n            }\n            free(adj);\n            return;\n        }\n        newNode->state = edges[i].to;\n        newNode->next = adj[edges[i].from];\n        adj[edges[i].from] = newNode;\n    }\n\n    // 2. Initialize data structures for DFS.\n    int* stack = (int*)malloc(N * sizeof(int));\n    char* visited = (char*)calloc(N, sizeof(char)); // Use char for boolean flag.\n    if (!stack || !visited) { // Allocation failure\n        if (stack) free(stack);\n        if (visited) free(visited);\n        // ... cleanup adj list ...\n        return;\n    }\n    int stack_top = -1;\n\n    // 3. Initialize stack and visited array with the starting set S.\n    for (int i = 0; i < s_count; ++i) {\n        int start_state = S[i];\n        if (start_state >= 0 && start_state < N && !visited[start_state]) {\n            visited[start_state] = 1;\n            stack[++stack_top] = start_state;\n        }\n    }\n\n    // 4. Perform DFS.\n    while (stack_top != -1) {\n        int u = stack[stack_top--];\n        for (AdjNode* v_node = adj[u]; v_node != NULL; v_node = v_node->next) {\n            int v = v_node->state;\n            if (v >= 0 && v < N && !visited[v]) {\n                visited[v] = 1;\n                stack[++stack_top] = v;\n            }\n        }\n    }\n\n    // 5. Collect results from the visited array.\n    *closure_count = 0;\n    for (int i = 0; i < N; ++i) {\n        if (visited[i]) {\n            closure[(*closure_count)++] = i;\n        }\n    }\n\n    // 6. Free allocated memory.\n    free(stack);\n    free(visited);\n    for (int i = 0; i < N; ++i) {\n        AdjNode* current = adj[i];\n        while (current != NULL) {\n            AdjNode* temp = current;\n            current = current->next;\n            free(temp);\n        }\n    }\n    free(adj);\n}\n\n\n```", "id": "3683779"}]}