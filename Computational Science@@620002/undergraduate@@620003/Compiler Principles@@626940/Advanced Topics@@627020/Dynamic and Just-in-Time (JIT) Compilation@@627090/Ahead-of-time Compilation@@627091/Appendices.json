{"hands_on_practices": [{"introduction": "A key challenge in Ahead-of-Time (AOT) compilation is managing the trade-off between optimization aggressiveness and the compiler's own resource consumption. This exercise [@problem_id:3620650] frames the classic function inlining decision as a 0-1 knapsack problem, where the goal is to maximize runtime performance benefit without exceeding a fixed compilation-time budget. By applying a fast, AOT-suitable greedy heuristic, you will gain insight into how real-world compilers make pragmatic, resource-aware optimization choices.", "problem": "An ahead-of-time (AOT) compiler must decide which candidate call sites to inline before execution, under a strict compilation-time budget. For each candidate function $f_i$, suppose a static cost model estimates an incremental compilation-time weight $w_i$ and an execution-time benefit $b_i$, both nonnegative and measured in consistent units. Let the total compilation-time budget be $T_{\\max}$. The compiler seeks a subset $\\mathcal{S}$ of candidates to inline that respects the budget while improving performance.\n\nUse the following foundational base for modeling and design. The $0$-$1$ knapsack problem is defined as: given items with weights $w_i$ and values $v_i$, choose a subset to maximize $\\sum_{i \\in \\mathcal{S}} v_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le W$. It is a well-known, widely studied combinatorial optimization problem that is $\\mathsf{NP}$-hard in general, with exact pseudo-polynomial dynamic programming algorithms and various approximation heuristics. In an AOT compiler, predictability and bounded compilation overhead are essential, so any inlining controller should be simple and fast, relying on static estimates only. Assume recursion and mutually recursive cycles are disallowed for inlining in this scenario.\n\nConsider $5$ candidate functions with the following estimates and budget:\n- $f_1$: $w_1 = 4$, $b_1 = 9$,\n- $f_2$: $w_2 = 5$, $b_2 = 10$,\n- $f_3$: $w_3 = 3$, $b_3 = 6$,\n- $f_4$: $w_4 = 2$, $b_4 = 4$,\n- $f_5$: $w_5 = 4$, $b_5 = 7$,\nwith $T_{\\max} = 10$.\n\nWhich option correctly casts the decision as a $0$-$1$ knapsack, proposes an AOT-suitable static heuristic derived from that model with predictable low overhead, and gives the subset that this heuristic selects for the above instance, including its total benefit and total weight?\n\nA. Model the selection as $0$-$1$ knapsack with objective $\\max \\sum_{i \\in \\mathcal{S}} b_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$. Use exact dynamic programming (DP) to compute the optimal subset. For the instance, DP returns $\\{f_2, f_3, f_4\\}$ with total benefit $20$ and total weight $10$.\n\nB. Model the selection as $0$-$1$ knapsack with objective $\\max \\sum_{i \\in \\mathcal{S}} b_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$. Use a static greedy heuristic that sorts candidates by ratio $r_i = b_i / w_i$ in descending order, breaking ties by larger $b_i$, and then adds items while respecting the budget. For the instance, the order is $f_1$ ($2.25$), then $f_2$ ($2.0$), $f_3$ ($2.0$), $f_4$ ($2.0$), then $f_5$ ($1.75$). The heuristic selects $\\{f_1, f_2\\}$ with total benefit $19$ and total weight $9$.\n\nC. Model the selection as $0$-$1$ knapsack, but use a benefit-only greedy heuristic that sorts by $b_i$ descending and picks until the budget is reached, ignoring $w_i$ during ranking. For the instance, the order is $f_2$, $f_1$, $f_5$, $f_3$, $f_4$. The heuristic selects $\\{f_2, f_1\\}$ with total benefit $19$ and total weight $9$.\n\nD. Model the selection as $0$-$1$ knapsack and apply a threshold rule: pick all items with $b_i \\ge w_i$ and if the budget is exceeded, drop the smallest-weight items first. For the instance, all items satisfy $b_i \\ge w_i$, so the rule picks $\\{f_2, f_1, f_4\\}$, then drops $f_4$ due to budget overflow and claims $\\{f_2, f_1\\}$ is the final choice with total benefit $19$ and total weight $9$.", "solution": "The problem statement will first be validated for scientific and logical integrity.\n\n### Step 1: Extract Givens\n- **Problem Context**: An ahead-of-time (AOT) compiler must select a subset of candidate functions $\\mathcal{S}$ to inline.\n- **Constraints**: There is a strict total compilation-time budget, $T_{\\max}$. The inlining controller must be simple, fast, and rely only on static estimates. Recursion and mutual recursion are disallowed for inlining.\n- **Function Model**: For each candidate function $f_i$, we have:\n  - $w_i$: incremental compilation-time weight (nonnegative).\n  - $b_i$: execution-time benefit (nonnegative).\n- **Optimization Goal**: Find a subset $\\mathcal{S}$ that respects the budget ($\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$) while improving performance (interpreted as maximizing $\\sum_{i \\in \\mathcal{S}} b_i$).\n- **Analogical Model**: The problem is to be modeled after the $0$-$1$ knapsack problem, which is to maximize $\\sum_{i \\in \\mathcal{S}} v_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le W$.\n- **Problem Instance Data**:\n  - $f_1$: $w_1 = 4$, $b_1 = 9$\n  - $f_2$: $w_2 = 5$, $b_2 = 10$\n  - $f_3$: $w_3 = 3$, $b_3 = 6$\n  - $f_4$: $w_4 = 2$, $b_4 = 4$\n  - $f_5$: $w_5 = 4$, $b_5 = 7$\n  - Budget: $T_{\\max} = 10$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is well-grounded in compiler theory. Function inlining is a standard optimization, and the trade-off between compile-time cost and runtime benefit is a central concern. Modeling this trade-off as a knapsack problem is a classic and valid approach in the literature on compiler heuristics.\n- **Well-Posed**: The problem is clearly stated. It provides a concrete instance of a well-defined optimization problem and asks for an evaluation of different heuristic approaches consonant with the practical constraints of AOT compilation.\n- **Objective**: The language is precise and technical. All terms are defined, and the data is quantitative.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically sound, self-contained, and objective. I will now proceed to the solution.\n\n### Problem Analysis\nThe task is to choose a subset of functions to inline. This can be formally cast as a $0$-$1$ knapsack problem.\n- The items to place in the knapsack are the candidate functions $\\{f_1, f_2, f_3, f_4, f_5\\}$.\n- The \"weight\" of each item $f_i$ is its compilation-time cost, $w_i$.\n- The \"value\" of each item $f_i$ is its execution-time benefit, $b_i$.\n- The knapsack's capacity is the total compilation-time budget, $W = T_{\\max} = 10$.\n- The objective is to choose a subset of functions $\\mathcal{S}$ that maximizes the total benefit $\\sum_{i \\in \\mathcal{S}} b_i$ subject to the constraint that the total weight does not exceed the budget: $\\sum_{i \\in \\mathcal{S}} w_i \\le 10$.\n\nThe problem explicitly states that for an AOT compiler, the decision-making process must be \"simple and fast\" with \"predictable low overhead\". This is a critical constraint on the choice of algorithm.\n\nLet us evaluate the provided options.\n\n### Option-by-Option Analysis\n\n**A. Model the selection as $0$-$1$ knapsack with objective $\\max \\sum_{i \\in \\mathcal{S}} b_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$. Use exact dynamic programming (DP) to compute the optimal subset. For the instance, DP returns $\\{f_2, f_3, f_4\\}$ with total benefit $20$ and total weight $10$.**\n\nThe modeling is correct. Let's verify the calculation. An exact algorithm like dynamic programming will find the true optimal solution. Let's find this optimum by examining combinations.\n- The set $\\{f_2, f_3, f_4\\}$ has a total weight of $w_2 + w_3 + w_4 = 5 + 3 + 2 = 10$, which meets the budget $T_{\\max}=10$.\n- The total benefit is $b_2 + b_3 + b_4 = 10 + 6 + 4 = 20$.\n- Let's check if another combination yields a higher benefit. Another high-benefit combination is $\\{f_1, f_2\\}$, with weight $4+5=9$ and benefit $9+10=19$. Another is $\\{f_1, f_3, f_4\\}$, with weight $4+3+2=9$ and benefit $9+6+4=19$.\n- The exhaustive search confirms that $\\{f_2, f_3, f_4\\}$ with benefit $20$ is indeed the optimal solution.\nHowever, the problem requires an \"AOT-suitable static heuristic\" that is \"simple and fast\". Dynamic programming for knapsack has a time complexity of $\\mathcal{O}(N \\cdot W)$, where $N$ is the number of items and $W$ is the capacity. In this context, $\\mathcal{O}(5 \\cdot 10)$, which is trivial. But for a real AOT-compiler scenario with thousands of candidate functions ($N$) and a large budget ($T_{\\max}$), this pseudo-polynomial complexity can be prohibitive. More importantly, DP is an *exact algorithm*, not a *heuristic*, and is generally considered more complex to implement and run than a simple greedy sort. The problem's constraints on simplicity and speed make the choice of DP questionable for the specified AOT context.\n\nVerdict: **Incorrect**. The proposed method (exact DP) is not a \"heuristic\" and is generally not considered \"simple and fast\" enough for the AOT compilation context described, even though its calculation for this specific small instance is correct.\n\n**B. Model the selection as $0$-$1$ knapsack with objective $\\max \\sum_{i \\in \\mathcal{S}} b_i$ subject to $\\sum_{i \\in \\mathcal{S}} w_i \\le T_{\\max}$. Use a static greedy heuristic that sorts candidates by ratio $r_i = b_i / w_i$ in descending order, breaking ties by larger $b_i$, and then adds items while respecting the budget. For the instance, the order is $f_1$ ($2.25$), then $f_2$ ($2.0$), $f_3$ ($2.0$), $f_4$ ($2.0$), then $f_5$ ($1.75$). The heuristic selects $\\{f_1, f_2\\}$ with total benefit $19$ and total weight $9$.**\n\nThe modeling is correct. The proposed greedy heuristic based on benefit-to-weight ratio (value density) is the canonical, standard heuristic for the knapsack problem. It is simple to implement and fast, with complexity dominated by the sort, $\\mathcal{O}(N \\log N)$. This fits the \"AOT-suitable\" criteria perfectly.\n\nLet's verify the calculation:\n1.  Calculate ratios $r_i = b_i / w_i$:\n    - $f_1$: $r_1 = 9/4 = 2.25$\n    - $f_2$: $r_2 = 10/5 = 2.0$\n    - $f_3$: $r_3 = 6/3 = 2.0$\n    - $f_4$: $r_4 = 4/2 = 2.0$\n    - $f_5$: $r_5 = 7/4 = 1.75$\n2.  Sort by $r_i$ descending. The tie-breaking rule is to prioritize larger $b_i$.\n    - The highest ratio is $r_1 = 2.25$ for $f_1$.\n    - Next is a tie at $r=2.0$ for $f_2, f_3, f_4$. We sort them by $b_i$ descending: $b_2=10 > b_3=6 > b_4=4$. So the order is $f_2, f_3, f_4$.\n    - The lowest ratio is $r_5 = 1.75$ for $f_5$.\n    - The final sorted order is: $f_1, f_2, f_3, f_4, f_5$.\n3.  Select items in this order until the budget $T_{\\max} = 10$ is full:\n    - Select $f_1$: current weight = $4$. Remaining budget = $6$. Selected set: $\\{f_1\\}$.\n    - Select $f_2$: weight $5 \\le 6$. New weight = $4+5=9$. Remaining budget = $1$. Selected set: $\\{f_1, f_2\\}$.\n    - Consider $f_3$: weight $3 > 1$. Cannot select.\n    - Consider $f_4$: weight $2 > 1$. Cannot select.\n    - Consider $f_5$: weight $4 > 1$. Cannot select.\n4.  The final selected set is $\\mathcal{S} = \\{f_1, f_2\\}$.\n    - Total weight: $w_1 + w_2 = 4+5=9$.\n    - Total benefit: $b_1 + b_2 = 9+10=19$.\n\nThe proposed heuristic is highly suitable, and the calculation is correct.\n\nVerdict: **Correct**. This option correctly identifies the problem, proposes the most standard and suitable heuristic for the context, and correctly applies it to the given data.\n\n**C. Model the selection as $0$-$1$ knapsack, but use a benefit-only greedy heuristic that sorts by $b_i$ descending and picks until the budget is reached, ignoring $w_i$ during ranking. For the instance, the order is $f_2$, $f_1$, $f_5$, $f_3$, $f_4$. The heuristic selects $\\{f_2, f_1\\}$ with total benefit $19$ and total weight $9$.**\n\nThe modeling is correct. The proposed heuristic (greedy by benefit) is also simple and fast ($\\mathcal{O}(N \\log N)$), making it AOT-suitable. However, ignoring the item weights ($w_i$) when ranking is a less sophisticated strategy for a knapsack problem, as it can favor high-benefit items that are also very \"expensive\" in terms of weight, potentially leading to a suboptimal use of the budget.\n\nLet's verify the calculation:\n1.  Sort by $b_i$ descending:\n    - $f_2$ ($b_2=10$), $f_1$ ($b_1=9$), $f_5$ ($b_5=7$), $f_3$ ($b_3=6$), $f_4$ ($b_4=4$). The order is correct.\n2.  Select items with budget $T_{\\max}=10$:\n    - Select $f_2$: current weight = $5$. Remaining budget = $5$. Selected set: $\\{f_2\\}$.\n    - Select $f_1$: weight $4 \\le 5$. New weight = $5+4=9$. Remaining budget = $1$. Selected set: $\\{f_2, f_1\\}$.\n    - Consider $f_5$: weight $4 > 1$. Cannot select.\n3.  The final selected set is $\\mathcal{S} = \\{f_1, f_2\\}$.\n    - Total weight: $9$. Total benefit: $19$.\n\nThe calculation is correct. However, compared to Option B, this heuristic is less principled. The core of the knapsack problem is the tension between benefit and weight. A heuristic based on the benefit-to-weight ratio directly addresses this tension, whereas a benefit-only heuristic ignores one side of the trade-off during its primary decision-making step (sorting). While both heuristics are AOT-suitable and coincidentally yield the same result for this specific instance, the ratio-based heuristic is a superior and more standard choice for the general problem.\n\nVerdict: **Incorrect**. While the calculation is correct for the proposed (and plausible) heuristic, the heuristic itself is less well-founded for the knapsack problem than the one in Option B. Option B provides a more canonical and robust approach.\n\n**D. Model the selection as $0$-$1$ knapsack and apply a threshold rule: pick all items with $b_i \\ge w_i$ and if the budget is exceeded, drop the smallest-weight items first. For the instance, all items satisfy $b_i \\ge w_i$, so the rule picks $\\{f_2, f_1, f_4\\}$, then drops $f_4$ due to budget overflow and claims $\\{f_2, f_1\\}$ is the final choice with total benefit $19$ and total weight $9$.**\n\nThe modeling is correct, but the proposed heuristic is convoluted and described inconsistently. Let's analyze the rule as stated: \"pick all items with $b_i \\ge w_i$ and if the budget is exceeded, drop the smallest-weight items first.\"\n1.  Initial selection based on $b_i \\ge w_i$:\n    - $f_1: 9 \\ge 4$ (Yes), $f_2: 10 \\ge 5$ (Yes), $f_3: 6 \\ge 3$ (Yes), $f_4: 4 \\ge 2$ (Yes), $f_5: 7 \\ge 4$ (Yes).\n    - All $5$ functions are selected. The initial set is $\\{f_1, f_2, f_3, f_4, f_5\\}$.\n2.  Check budget: Total weight is $4+5+3+2+4=18$. This exceeds the budget $T_{\\max}=10$.\n3.  Drop items: The rule says to \"drop the smallest-weight items first\".\n    - The weights are $w_4=2$, $w_3=3$, $w_1=4$, $w_5=4$, $w_2=5$.\n    - Drop $f_4$ (weight $2$). New weight is $18-2=16$. Still $>10$.\n    - Drop $f_3$ (weight $3$). New weight is $16-3=13$. Still $>10$.\n    - Drop $f_1$ (weight $4$, assuming tie-break by index over $f_5$). New weight is $13-4=9$. This is $\\le 10$.\n    - The final set would be $\\{f_2, f_5\\}$ with weight $5+4=9$ and benefit $10+7=17$.\nThe option's description of its own process is \"the rule picks $\\{f_2, f_1, f_4\\}$\". This is not what the stated rule implies. The stated rule implies picking all eligible items first, then dropping. Furthermore, it claims it \"drops $f_4$ from this set...claims $\\{f_2, f_1\\}$ is the final choice\". This is an ad-hoc description of a process, not the application of a consistent rule. The logic is self-contradictory and ill-defined.\n\nVerdict: **Incorrect**. The proposal is logically flawed, as the description of the heuristic's application does not match the definition of the heuristic itself. The rule is also poorly designed (dropping smallest-weight items is an odd strategy to reduce total weight).\n\n### Conclusion\nOption B presents the most appropriate solution. It correctly formulates the problem, proposes the standard and most effective greedy heuristic (value-density), which is perfectly suited for the AOT compiler context, and correctly applies this heuristic to the given instance.", "answer": "$$\\boxed{B}$$", "id": "3620650"}, {"introduction": "Compilers must often choose between multiple strategies to implement a single high-level language construct, each with different performance and memory footprints. This practice [@problem_id:3620661] delves into the decision of how to lower a `switch` statement, modeling the choice between a fast, memory-intensive jump table and a slower, more compact binary search tree. You will derive a formal density threshold that allows the AOT compiler to make an optimal, data-driven choice based on a weighted cost model.", "problem": "An Ahead-Of-Time (AOT) compiler must lower a multiway branch (a switch over integers) with $k$ distinct case labels whose numeric values span a contiguous integer interval of width $W$. Define the density as $\\delta = \\frac{k}{W}$, with $0 < \\delta \\leq 1$. Two canonical lowering strategies are considered:\n\n- A jump table: a table of $W$ entries that indexes directly to landing pads. This strategy entails a fixed control-flow overhead and data footprint proportional to $W$ entries.\n- A balanced binary search decision tree over the sorted case labels: this strategy entails control-flow depth proportional to $\\log_{2}(k)$ and static code size proportional to the number of decision nodes required.\n\nAssume the following cost model, grounded in core facts about these strategies:\n\n1. Code size cost is measured in bytes and execution-time cost is measured in cycles. The compiler optimizes a weighted total cost\n$$\nC \\;=\\; \\lambda \\cdot S \\;+\\; (1 - \\lambda) \\cdot T,\n$$\nwhere $S$ is code size, $T$ is execution-time for one dispatch, and $0 < \\lambda < 1$ is the policy weight that trades code size against time.\n\n2. For the jump table:\n   - Let $s_{\\mathrm{jt}}$ be the fixed overhead in bytes for emitting the jump-table dispatch logic.\n   - Let $p$ be the per-entry byte cost for the table, so the table contributes $p \\cdot W$ bytes.\n   - Let $r$ be the per-landing-pad byte cost, so landing pads contribute $r \\cdot k$ bytes.\n   - Let $t_{\\mathrm{jt}}$ be the constant cycle cost of one dispatch via the jump table, assuming the table lookup is an $O(1)$ operation and indirect branch resolution is constant on average.\n\n3. For the balanced binary search decision tree:\n   - Let $s_{\\mathrm{bs}}$ be the fixed overhead in bytes for emitting the decision-tree dispatch logic.\n   - Let $b$ be the per-decision-node byte cost. A balanced tree over $k$ labels uses $k-1$ internal decision nodes, so the decision code contributes $b \\cdot (k - 1)$ bytes.\n   - The landing pads still contribute $r \\cdot k$ bytes.\n   - Let $t_{\\mathrm{lvl}}$ be the cycle cost per decision level, so the dispatch time scales as $t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$.\n\nAdopt the above model, and use $\\delta = \\frac{k}{W}$ to relate the jump-table footprint to the density. Derive the density threshold $\\delta^{*}(k)$ at which the weighted total cost of the jump table equals that of the binary search decision tree. Your final expression must be a closed-form analytic expression for $\\delta^{*}(k)$ in terms of $k$, $\\lambda$, $p$, $b$, $s_{\\mathrm{jt}}$, $s_{\\mathrm{bs}}$, $t_{\\mathrm{jt}}$, and $t_{\\mathrm{lvl}}$. If no rounding is necessary, provide the exact expression. State no units in your final answer.", "solution": "The problem asks for the derivation of the density threshold, denoted $\\delta^{*}(k)$, at which the weighted total cost of implementing a multiway branch using a jump table equals that of using a balanced binary search decision tree. The total cost $C$ is a weighted sum of code size cost $S$ and execution-time cost $T$, given by the policy $C = \\lambda \\cdot S + (1 - \\lambda) \\cdot T$.\n\nFirst, we formulate the total cost for each of the two strategies based on the parameters provided in the problem statement.\n\nFor the jump table strategy, the code size cost, $S_{\\mathrm{jt}}$, is the sum of a fixed overhead $s_{\\mathrm{jt}}$, the table size cost $p \\cdot W$, and the landing pad code size $r \\cdot k$.\n$$S_{\\mathrm{jt}} = s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k$$\nThe execution-time cost, $T_{\\mathrm{jt}}$, is a constant value $t_{\\mathrm{jt}}$.\n$$T_{\\mathrm{jt}} = t_{\\mathrm{jt}}$$\nTherefore, the total cost for the jump table, $C_{\\mathrm{jt}}$, is:\n$$C_{\\mathrm{jt}} = \\lambda \\cdot S_{\\mathrm{jt}} + (1 - \\lambda) \\cdot T_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}}$$\n\nFor the balanced binary search strategy, the code size cost, $S_{\\mathrm{bs}}$, is the sum of a fixed overhead $s_{\\mathrm{bs}}$, the decision node code size $b \\cdot (k - 1)$, and the same landing pad code size $r \\cdot k$.\n$$S_{\\mathrm{bs}} = s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k$$\nThe execution-time cost, $T_{\\mathrm{bs}}$, is proportional to the depth of the tree, given as $t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$.\n$$T_{\\mathrm{bs}} = t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$$\nTherefore, the total cost for the binary search tree, $C_{\\mathrm{bs}}$, is:\n$$C_{\\mathrm{bs}} = \\lambda \\cdot S_{\\mathrm{bs}} + (1 - \\lambda) \\cdot T_{\\mathrm{bs}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$$\n\nThe density threshold $\\delta^{*}(k)$ is the value of the density $\\delta$ for which the two costs are equal, i.e., $C_{\\mathrm{jt}} = C_{\\mathrm{bs}}$. We set up the equality:\n$$ \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\nThe term $\\lambda \\cdot r \\cdot k$, representing the cost of the landing pads' code size, appears on both sides of the equation. This is a common cost to both strategies and thus does not influence the decision threshold. We can cancel this term from both sides:\n$$ \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1)) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\nThe problem defines the density $\\delta$ as $\\delta = \\frac{k}{W}$. We need to solve for $\\delta$. To do this, we first express $W$ in terms of $\\delta$ and $k$: $W = \\frac{k}{\\delta}$. We substitute this into the equation:\n$$ \\lambda \\cdot \\left(s_{\\mathrm{jt}} + p \\cdot \\frac{k}{\\delta}\\right) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1)) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\nExpanding the terms involving $\\lambda$:\n$$ \\lambda s_{\\mathrm{jt}} + \\frac{\\lambda p k}{\\delta} + (1 - \\lambda) t_{\\mathrm{jt}} = \\lambda s_{\\mathrm{bs}} + \\lambda b (k - 1) + (1 - \\lambda) t_{\\mathrm{lvl}} \\log_{2}(k) $$\nOur goal is to isolate $\\delta$. We begin by isolating the term containing $\\delta$:\n$$ \\frac{\\lambda p k}{\\delta} = \\lambda s_{\\mathrm{bs}} + \\lambda b (k - 1) + (1 - \\lambda) t_{\\mathrm{lvl}} \\log_{2}(k) - \\lambda s_{\\mathrm{jt}} - (1 - \\lambda) t_{\\mathrm{jt}} $$\nWe can group terms on the right-hand side by the weighting factor $\\lambda$:\n$$ \\frac{\\lambda p k}{\\delta} = \\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}}) $$\nTo solve for $\\delta$, we can first solve for its reciprocal, $\\frac{1}{\\delta}$, by dividing both sides by $\\lambda p k$. This is permissible as $\\lambda > 0$, $p$ (a byte cost) must be positive, and $k$ (number of labels) must be at least $1$.\n$$ \\frac{1}{\\delta} = \\frac{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})}{\\lambda p k} $$\nFinally, we take the reciprocal of both sides to find the expression for the density threshold, $\\delta^{*}(k)$:\n$$ \\delta^{*}(k) = \\frac{\\lambda p k}{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})} $$\nThis is the closed-form analytic expression for the density threshold $\\delta^{*}(k)$ in terms of the given parameters. The compiler would choose the jump table strategy if the actual density $\\delta$ is greater than this threshold $\\delta^{*}(k)$, and the binary search strategy if it is less, assuming the denominator is positive.", "answer": "$$ \\boxed{ \\frac{\\lambda p k}{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})} } $$", "id": "3620661"}, {"introduction": "The primary directive for any compiler optimization is to preserve the correctness of the program. This exercise [@problem_id:3620671] explores the crucial concept of optimization soundness, particularly in the presence of potential Undefined Behavior (UB) like division by zero. Using a formal semantics with `poison` values, you will analyze why seemingly obvious algebraic simplifications can be unsafe, and how static analysis enables sound transformations that respect the language's semantic rules.", "problem": "An Ahead-of-Time (AOT) compiler applies constant folding on an Intermediate Representation (IR) before program inputs are known. Consider a straight-line subset of the IR where expressions are formed from integer variables and constants using integer addition $+$, multiplication $\\times$, bitwise and $\\wedge$, and integer division $\\div$. We model potential Undefined Behavior (UB) with a poison-aware denotational semantics to preserve soundness constraints during optimization.\n\nFoundational base: let the value domain be $V = \\mathbb{Z} \\cup \\{\\mathsf{poison}\\}$. The evaluation function $\\llbracket e \\rrbracket : \\mathbb{Z}^{k} \\to V$ maps an expression $e$ with $k$ free integer variables to either an integer or $\\mathsf{poison}$. The semantics is defined by the following well-tested rules:\n- Pure propagation of poison: for any binary operator $\\circ \\in \\{+, \\times, \\wedge, \\div\\}$ and operands $v_1, v_2 \\in V$, if $v_1 = \\mathsf{poison}$ or $v_2 = \\mathsf{poison}$, then $v_1 \\circ v_2 = \\mathsf{poison}$.\n- Integer division: for $a, b \\in \\mathbb{Z}$, $a \\div b = \\mathsf{poison}$ if $b = 0$, and otherwise $a \\div b$ is the mathematical integer quotient; bitwise and and the other operators behave as standard over $\\mathbb{Z}$ when both operands are in $\\mathbb{Z}$.\n- Observability: returning $\\mathsf{poison}$ (or using it in control) constitutes UB at runtime; integer results in $\\mathbb{Z}$ are defined behaviors.\n\nA local rewrite $e \\Rightarrow e'$ is said to be AOT-sound under poison-preserving semantics if, for all environments $\\rho \\in \\mathbb{Z}^{k}$ that assign integer values to the free variables of $e$,\n- if $\\llbracket e \\rrbracket(\\rho) \\in \\mathbb{Z}$ then $\\llbracket e' \\rrbracket(\\rho) = \\llbracket e \\rrbracket(\\rho)$ (no change on defined behaviors), and\n- if $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$ then $\\llbracket e' \\rrbracket(\\rho) = \\mathsf{poison}$ (poison is preserved rather than silently eliminated).\n\nThis semantics captures the requirement that an AOT compiler must not fold away input-dependent UB.\n\nConsider the following candidate constant-folding rules, each intended to be applied locally without evaluating subexpressions and without peeking at runtime inputs:\n- A. For all expressions $e$, rewrite $0 \\times e \\Rightarrow 0$.\n\n- B. For all variables $x$, rewrite $x \\div x \\Rightarrow 1$.\n\n- C. For all variables $x$, rewrite $x + 0 \\Rightarrow x$.\n\n- D. For all expressions $e$, rewrite $e \\wedge 0 \\Rightarrow 0$.\n\n- E. For all variables $x$, under a proven static precondition at the program point that $x \\neq 0$, rewrite $x \\div x \\Rightarrow 1$.\n\nWhich of the above rules are AOT-sound under the poison-preserving semantics defined above? Select all that apply.", "solution": "The problem statement is first validated to ensure it is scientifically grounded, well-posed, objective, and self-contained.\n\n### Step 1: Extract Givens\n- **Value Domain**: $V = \\mathbb{Z} \\cup \\{\\mathsf{poison}\\}$.\n- **Evaluation Function**: $\\llbracket e \\rrbracket : \\mathbb{Z}^{k} \\to V$ for an expression $e$ with $k$ free integer variables. The environment $\\rho \\in \\mathbb{Z}^{k}$ assigns integer values to these variables.\n- **Semantics of Binary Operators**:\n    1.  **Poison Propagation**: For any binary operator $\\circ \\in \\{+, \\times, \\wedge, \\div\\}$ and operands $v_1, v_2 \\in V$, if $v_1 = \\mathsf{poison}$ or $v_2 = \\mathsf{poison}$, then $v_1 \\circ v_2 = \\mathsf{poison}$. This implies all operators are strict.\n    2.  **Integer Division**: For $a, b \\in \\mathbb{Z}$, $a \\div b = \\mathsf{poison}$ if $b = 0$. Otherwise, $a \\div b$ is the standard integer quotient.\n    3.  **Other Operators**: For $a, b \\in \\mathbb{Z}$, the operators $+, \\times, \\wedge$ behave as standard integer addition, multiplication, and bitwise AND, respectively.\n- **Definition of AOT-Soundness**: A rewrite $e \\Rightarrow e'$ is AOT-sound if for all environments $\\rho \\in \\mathbb{Z}^{k}$:\n    1.  If $\\llbracket e \\rrbracket(\\rho) \\in \\mathbb{Z}$, then $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$. (Preserves the value of defined behavior.)\n    2.  If $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$, then $\\llbracket e' \\rrbracket(\\rho) = \\mathsf{poison}$. (Preserves undefined behavior.)\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is a formal exercise in denotational semantics applied to compiler optimization, a standard topic in computer science.\n- **Scientifically Grounded**: The model uses established formal methods (denotational semantics) to reason about program transformations. The concept of a `poison` value to represent potential undefined behavior is a well-known technique used in modern compilers (e.g., LLVM's `poison` and `undef` values). The setup is logically consistent and grounded in compiler theory.\n- **Well-Posed**: The definitions of the value domain, operator semantics, and soundness are precise and unambiguous. The task is to check a finite list of proposed rules against these definitions, which admits a unique and stable answer for each rule.\n- **Objective**: The problem is expressed in formal mathematical and logical language, free of subjectivity or ambiguity.\n- **Completeness and Consistency**: The problem provides all necessary definitions to perform the required analysis. There are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution process will now proceed by analyzing each candidate rule against the provided definition of AOT-soundness.\n\nLet $e_{LHS}$ denote the left-hand side expression and $e_{RHS}$ the right-hand side expression of a rewrite rule. For a rule to be AOT-sound, it must satisfy two conditions for all environments $\\rho$:\n1. If $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$, then $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$.\n2. If $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$, then $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\n\nWe will evaluate each candidate rule against these two conditions.\n\n### Option-by-Option Analysis\n\n**A. For all expressions $e$, rewrite $0 \\times e \\Rightarrow 0$.**\n\nLet $e_{LHS} = 0 \\times e$ and $e_{RHS} = 0$. We test the second AOT-soundness condition. We must check if $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ implies $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\nLet's choose an expression $e$ and an environment $\\rho$ such that $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$. For example, let $e$ be the expression $x \\div 0$ for some variable $x$. For any environment $\\rho$, $\\llbracket x \\div 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div 0 = \\mathsf{poison}$.\nNow, let's evaluate $e_{LHS}$ with this choice of $e$.\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket 0 \\times (x \\div 0) \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) \\times \\llbracket x \\div 0 \\rrbracket(\\rho) = 0 \\times \\mathsf{poison}$.\nAccording to the \"Pure propagation of poison\" rule, $0 \\times \\mathsf{poison} = \\mathsf{poison}$. So, $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\nNow, let's evaluate $e_{RHS}$:\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) = 0$.\nHere, we have a case where $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ but $\\llbracket e_{RHS} \\rrbracket(\\rho) = 0$. The rewrite changes a `poison` value to an integer `0`, thus violating the second condition. This transformation illicitly removes potential Undefined Behavior.\n\nVerdict: **Incorrect**.\n\n**B. For all variables $x$, rewrite $x \\div x \\Rightarrow 1$.**\n\nLet $e_{LHS} = x \\div x$ and $e_{RHS} = 1$. We test the second condition.\nConsider an environment $\\rho$ where $\\rho(x) = 0$.\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket x \\div x \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket x \\rrbracket(\\rho) = 0 \\div 0$.\nAccording to the integer division rule, division by zero results in `poison`. So, $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\nNow, we evaluate $e_{RHS}$:\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 1 \\rrbracket(\\rho) = 1$.\nThis is a case where $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ but $\\llbracket e_{RHS} \\rrbracket(\\rho) = 1$. The transformation removes the UB associated with $0 \\div 0$ and replaces it with the defined value $1$. This violates the second soundness condition.\n\nVerdict: **Incorrect**.\n\n**C. For all variables $x$, rewrite $x + 0 \\Rightarrow x$.**\n\nLet $e_{LHS} = x + 0$ and $e_{RHS} = x$.\nThe environment $\\rho$ maps the variable $x$ to an integer value, say $\\rho(x) = v_x \\in \\mathbb{Z}$. By definition, $\\llbracket x \\rrbracket(\\rho) = v_x$.\n\n1.  **Condition 1**: Assume $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$.\n    $\\llbracket x + 0 \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) + \\llbracket 0 \\rrbracket(\\rho) = v_x + 0 = v_x$. This value is always in $\\mathbb{Z}$.\n    We must check if $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$.\n    $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) = v_x$.\n    Since $v_x = v_x$, the condition holds.\n\n2.  **Condition 2**: Assume $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\n    As shown above, $\\llbracket x + 0 \\rrbracket(\\rho) = v_x + 0 = v_x$, where $v_x$ is an integer. The result is never $\\mathsf{poison}$. The premise of this condition, $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$, is false for all environments $\\rho$. Therefore, the implication is vacuously true.\n\nBoth AOT-soundness conditions are met for all environments $\\rho$.\n\nVerdict: **Correct**.\n\n**D. For all expressions $e$, rewrite $e \\wedge 0 \\Rightarrow 0$.**\n\nLet $e_{LHS} = e \\wedge 0$ and $e_{RHS} = 0$. This case is analogous to rule A.\nWe test the second condition. Let's find an $e$ and $\\rho$ such that $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$. As before, let $e$ be $x \\div 0$.\n$\\llbracket e_{LHS} \\rrbracket(\\rho) = \\llbracket (x \\div 0) \\wedge 0 \\rrbracket(\\rho) = \\llbracket x \\div 0 \\rrbracket(\\rho) \\wedge \\llbracket 0 \\rrbracket(\\rho) = \\mathsf{poison} \\wedge 0$.\nBy the poison propagation rule, $\\mathsf{poison} \\wedge 0 = \\mathsf{poison}$. So, $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$.\nNow, we evaluate $e_{RHS}$:\n$\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 0 \\rrbracket(\\rho) = 0$.\nWe have a case where $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ but $\\llbracket e_{RHS} \\rrbracket(\\rho) = 0$. This violates the second soundness condition. The fact that bitwise AND with $0$ is mathematically always $0$ is irrelevant; the strict poison semantics must be obeyed.\n\nVerdict: **Incorrect**.\n\n**E. For all variables $x$, under a proven static precondition at the program point that $x \\neq 0$, rewrite $x \\div x \\Rightarrow 1$.**\n\nLet $e_{LHS} = x \\div x$ and $e_{RHS} = 1$. The analysis is restricted to environments $\\rho$ that satisfy the precondition, i.e., where $\\rho(x) = v_x$ and $v_x \\neq 0$.\n\n1.  **Condition 1**: Assume $\\llbracket e_{LHS} \\rrbracket(\\rho) \\in \\mathbb{Z}$ for an environment $\\rho$ where $\\rho(x) = v_x \\neq 0$.\n    $\\llbracket x \\div x \\rrbracket(\\rho) = \\llbracket x \\rrbracket(\\rho) \\div \\llbracket x \\rrbracket(\\rho) = v_x \\div v_x$.\n    Since $v_x$ is a non-zero integer, the division is well-defined and equals $1$. So, $\\llbracket e_{LHS} \\rrbracket(\\rho) = 1 \\in \\mathbb{Z}$.\n    We must check if $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket e_{LHS} \\rrbracket(\\rho)$.\n    $\\llbracket e_{RHS} \\rrbracket(\\rho) = \\llbracket 1 \\rrbracket(\\rho) = 1$.\n    Since $1 = 1$, the condition holds.\n\n2.  **Condition 2**: Assume $\\llbracket e_{LHS} \\rrbracket(\\rho) = \\mathsf{poison}$ for an environment $\\rho$ where $\\rho(x) = v_x \\neq 0$.\n    As shown above, for any such environment, $\\llbracket x \\div x \\rrbracket(\\rho) = 1$. The result is never $\\mathsf{poison}$. The premise of this condition is always false for the set of applicable environments. Therefore, the implication is vacuously true.\n\nBoth AOT-soundness conditions are met for all environments satisfying the precondition. The precondition is what distinguishes this rule from the unsound rule B, as it explicitly rules out the problematic case where $x=0$.\n\nVerdict: **Correct**.", "answer": "$$\\boxed{CE}$$", "id": "3620671"}]}