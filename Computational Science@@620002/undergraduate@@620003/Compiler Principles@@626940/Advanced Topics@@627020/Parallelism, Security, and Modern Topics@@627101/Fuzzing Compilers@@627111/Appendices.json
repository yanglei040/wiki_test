{"hands_on_practices": [{"introduction": "Compilers are permitted to make strong assumptions about code that invokes Undefined Behavior (UB), a freedom they use to perform powerful optimizations. This exercise simulates a fuzzing approach to detect when such optimizations might lead to unexpected outcomes [@problem_id:3642978]. You will implement a mutation operator that models an aggressive compiler by removing checks for potential UB, and then compare its behavior to a safe, reference interpreter to reveal semantic differences.", "problem": "You are given a simplified setting to explore fuzzing compilers by detecting reliance on undefined behavior using a mutation operator. The task is to construct a small interpreter for a toy expression language that models integer computations and a notion of undefined behavior, apply a systematic mutation operator that removes undefined-guarded branches, and compare the outputs of the original program (interpreted under a defined semantics) with the mutated program. The comparison is done over a finite test suite of input environments.\n\nFundamental base and definitions:\n- The guiding principle of compiler optimization correctness is semantic preservation: an optimization must not change the observable semantics of a program. If a compiler relies on Undefined Behavior (UB), it may assume certain conditions that are not guaranteed by the defined semantics. We model UB by a partial semantics that can fail to produce a defined integer result.\n- Consider a toy expression language over integer inputs with variables $x$, $y$, and $z$, and the following expressions: constants, variables, addition, subtraction, multiplication, a checked division, a definedness predicate, and a conditional expression. Formally, expressions $E$ are built from:\n  1. $E ::= c$ where $c \\in \\mathbb{Z}$,\n  2. $E ::= x \\mid y \\mid z$,\n  3. $E ::= E_1 + E_2 \\mid E_1 - E_2 \\mid E_1 \\times E_2$,\n  4. $E ::= \\mathrm{div\\_checked}(E_1,E_2)$,\n  5. $E ::= \\mathrm{is\\_defined}(E)$,\n  6. $E ::= \\mathrm{if}(C, T, F)$ where $C$ is a condition expression that yields an integer interpreted as a Boolean (nonzero is true, zero is false).\n- The semantics maps expressions to either a defined integer or an undefined result. Let $\\llbracket E \\rrbracket(\\rho)$ denote the evaluation of $E$ under an environment $\\rho$ assigning integer values to variables $x$, $y$, and $z$. We define:\n  1. Constants and variables: $\\llbracket c \\rrbracket(\\rho) = \\langle \\mathrm{def}, c \\rangle$, $\\llbracket x \\rrbracket(\\rho) = \\langle \\mathrm{def}, \\rho(x) \\rangle$, similarly for $y$ and $z$.\n  2. Binary arithmetic: For $E_1 \\circ E_2$ with $\\circ \\in \\{+, -, \\times\\}$, if either $\\llbracket E_1 \\rrbracket(\\rho)$ or $\\llbracket E_2 \\rrbracket(\\rho)$ is undefined, the result is undefined; otherwise it is the integer arithmetic result.\n  3. Checked division: $\\llbracket \\mathrm{div\\_checked}(E_1,E_2) \\rrbracket(\\rho)$ is undefined if either operand is undefined or if the divisor evaluates to $0$; otherwise it is integer division $E_1 / E_2$.\n  4. Definedness predicate: $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho) = \\langle \\mathrm{def}, b \\rangle$ where $b = 1$ if $\\llbracket E \\rrbracket(\\rho)$ is defined, and $b = 0$ otherwise. This predicate does not itself become undefined.\n  5. Conditional: $\\llbracket \\mathrm{if}(C,T,F) \\rrbracket(\\rho)$ evaluates $C$ first. If $C$ is undefined, the defined semantics treats it as false, choosing $F$; if $C$ is defined and nonzero, it evaluates and returns $\\llbracket T \\rrbracket(\\rho)$; if $C$ is defined and zero, it evaluates and returns $\\llbracket F \\rrbracket(\\rho)$. If the chosen branch evaluates to undefined, the result is undefined.\n\nMutation operator:\n- A mutation operator models a class of compiler transforms that rely on undefined behavior by removing guards that check for definedness. The operator $\\mathcal{M}$ acts on the abstract syntax tree and replaces any conditional of the form $\\mathrm{if}(\\mathrm{is\\_defined}(E), T, F)$ with the branch $T$, thereby systematically removing the “undefined” branch $F$. The operator recurses into subexpressions to produce a mutated program $\\mathcal{M}(E)$.\n\nTask:\n- Implement an interpreter for the toy language as defined above, and implement the mutation operator $\\mathcal{M}$.\n- For each test case below, instantiate the program as an abstract syntax tree $E$, apply $\\mathcal{M}$ to obtain the mutated program $\\mathcal{M}(E)$, and compare the outputs of $\\llbracket E \\rrbracket(\\rho)$ and $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ over the specified input environments $\\rho$. An environment $\\rho$ is a triple $(x,y,z) \\in \\mathbb{Z}^3$. A result is considered equal if both are defined and equal integers; otherwise they differ.\n- The final output of your program must be a single line that contains a comma-separated list of integers $0$ or $1$ enclosed in square brackets, where each entry corresponds to a test case and is $1$ if the mutated program is observationally equivalent to the original over all listed environments, and $0$ otherwise.\n\nTest suite:\n- Test case $1$ (basic guarded division with fallback):\n  - Program $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$.\n  - Environments: $(10,2,0)$, $(10,0,0)$, $(0,5,0)$, $(-9,3,0)$.\n- Test case $2$ (always-defined guard, happy path):\n  - Program $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$.\n  - Environments: $(7,123,0)$, $(-8,42,0)$, $(0,999,0)$.\n- Test case $3$ (nested guards, multiple potential undefined points):\n  - Program $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$.\n  - Environments: $(12,3,2)$, $(12,0,2)$, $(12,3,0)$, $(0,10,2)$, $(9,-3,-3)$.\n- Test case $4$ (guard removal is semantics-preserving due to identical branches):\n  - Program $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$.\n  - Environments: $(5,100,0)$, $(-1,2,0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i \\in \\{0,1\\}$ corresponds to the equivalence check for test case $i$.", "solution": "The user-provided problem statement is valid. It is a well-posed, scientifically grounded problem within the domain of computer science, specifically concerning compiler theory and program semantics. It provides a formal system consisting of a toy programming language, a defined operational semantics including the concept of undefined behavior, and a mutation operator designed to model compiler optimizations that rely on assumptions about undefined behavior. The task is to implement this system, apply it to a given set of test cases, and determine the observational equivalence between the original and mutated programs. The problem is self-contained, logically consistent, and free of ambiguity.\n\nThe solution proceeds by first constructing the necessary data structures to represent the abstract syntax tree (AST) of the language. Then, two primary functions are implemented: an interpreter that computes the value of an expression according to the specified semantics, and a mutation function that transforms an expression's AST according to the given operator rule. Finally, each test case is executed by building the program's AST, mutating it, and comparing the evaluation results of both the original and mutated ASTs over a suite of input environments.\n\n### 1. Data Representation and Semantics\n\nAn expression $E$ is represented as a node in an AST. Each node contains a type tag and a payload corresponding to that type (e.g., a constant value, a variable identifier, or pointers to child nodes for operations).\n\nThe evaluation semantics $\\llbracket E \\rrbracket(\\rho)$ maps an expression $E$ and an environment $\\rho$ (a mapping from variables $x, y, z$ to integer values) to a result. The result is a pair $\\langle \\text{status}, \\text{value} \\rangle$, where status is either defined or undefined. This is implemented using a structure containing a boolean flag and an integer value.\n\nThe interpreter is a recursive function, `eval(E, rho)`, which traverses the AST.\n- For constants and variables, it returns the defined value directly from the AST node or the environment $\\rho$.\n- For arithmetic operations $E_1 \\circ E_2$ (where $\\circ \\in \\{+, -, \\times\\}$), it recursively evaluates $E_1$ and $E_2$. If either sub-evaluation results in an undefined status, the operation's result is also undefined. Otherwise, the integer operation is performed.\n- For $\\mathrm{div\\_checked}(E_1, E_2)$, it follows the arithmetic operation logic but adds a check for the divisor: if the value of $\\llbracket E_2 \\rrbracket(\\rho)$ is $0$, the result is undefined.\n- The predicate $\\llbracket \\mathrm{is\\_defined}(E) \\rrbracket(\\rho)$ evaluates $E$. It returns a defined result of $\\langle \\mathrm{def}, 1 \\rangle$ if $\\llbracket E \\rrbracket(\\rho)$ is defined, and $\\langle \\mathrm{def}, 0 \\rangle$ if it is not. This operation itself never yields an undefined result.\n- The conditional $\\llbracket \\mathrm{if}(C, T, F) \\rrbracket(\\rho)$ is unique. It first evaluates the condition $C$. If $\\llbracket C \\rrbracket(\\rho)$ is undefined, the semantics specify treating this as a false condition, thus evaluating the false-branch $F$. If $\\llbracket C \\rrbracket(\\rho)$ is defined, its integer value is treated as a boolean ($0$ is false, non-zero is true) to select either the $T$ or $F$ branch for evaluation.\n\n### 2. Mutation Operator\n\nThe mutation operator $\\mathcal{M}$ is implemented as a recursive function, `mutate(E)`, that constructs a new, mutated AST. The transformation is compositional:\n- For expression types other than `if`, the operator recurses on the subexpressions and rebuilds the same expression type with the mutated subexpressions. For example, $\\mathcal{M}(E_1+E_2) = \\mathcal{M}(E_1) + \\mathcal{M}(E_2)$.\n- For a conditional expression $\\mathrm{if}(C, T, F)$, the operator inspects the condition $C$.\n  - If $C$ is of the form $\\mathrm{is\\_defined}(E')$, the entire `if` expression is replaced by the result of mutating the true branch, $T$. That is, $\\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(E'), T, F)) = \\mathcal{M}(T)$. This models the compiler assuming the guard is always true and thus eliminating the check and the false branch.\n  - Otherwise, the operator recurses into all three subexpressions: $\\mathcal{M}(\\mathrm{if}(C, T, F)) = \\mathrm{if}(\\mathcal{M}(C), \\mathcal{M}(T), \\mathcal{M}(F))$.\n\n### 3. Test Case Analysis\n\nA program is observationally equivalent to its mutation for a given test case if and only if for every specified environment $\\rho$, $\\llbracket E \\rrbracket(\\rho)$ and $\\llbracket \\mathcal{M}(E) \\rrbracket(\\rho)$ are either both undefined, or both defined with the same integer value.\n\n**Test Case 1:** $E_1 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{div\\_checked}(x,y) + 1,\\, 0)$\n- Mutated program: $\\mathcal{M}(E_1) = \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + 1) = \\mathrm{div\\_checked}(x,y) + 1$.\n- Environment $(10, 0, 0)$:\n  - $\\llbracket E_1 \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0)$ is undefined. $\\mathrm{is\\_defined}(\\dots)$ is false ($0$). The `if` evaluates its false branch, yielding a defined result of $0$.\n  - $\\llbracket \\mathcal{M}(E_1) \\rrbracket((10,0,0))$: $\\mathrm{div\\_checked}(10,0) + 1$ attempts to evaluate division by zero, resulting in an undefined result.\n- The results differ ($0$ vs. undefined). Thus, equivalence is $0$.\n\n**Test Case 2:** $E_2 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x \\times 2,\\, -1)$\n- Mutated program: $\\mathcal{M}(E_2) = \\mathcal{M}(x \\times 2) = x \\times 2$.\n- The condition $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ is always true for any integer $x$, since division by $1$ is always defined.\n- Therefore, $\\llbracket E_2 \\rrbracket(\\rho)$ always evaluates the true branch, $x \\times 2$, which is identical to the mutated program $\\mathcal{M}(E_2)$.\n- The programs are equivalent for all inputs. Thus, equivalence is $1$.\n\n**Test Case 3:** $E_3 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,y)),\\, \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)),\\, \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z),\\, 7),\\, 8)$\n- Mutated program: The mutation operator is applied recursively. The outer `if` condition matches the pattern, so it is replaced by the mutation of its true branch. The true branch is another `if` that also matches the pattern.\n  - $\\mathcal{M}(E_3) = \\mathcal{M}(\\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(y,z)), \\dots, 7))$\n  - $= \\mathcal{M}(\\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)) = \\mathrm{div\\_checked}(x,y) + \\mathrm{div\\_checked}(y,z)$.\n- Environment $(12, 0, 2)$:\n  - $\\llbracket E_3 \\rrbracket((12,0,2))$: $\\mathrm{div\\_checked}(12,0)$ is undefined. The outer `is_defined` is false ($0$). The `if` evaluates the false branch, yielding a defined result of $8$.\n  - $\\llbracket \\mathcal{M}(E_3) \\rrbracket((12,0,2))$: $\\mathrm{div\\_checked}(12,0) + \\mathrm{div\\_checked}(0,2)$ is undefined due to the first term.\n- The results differ ($8$ vs. undefined). Thus, equivalence is $0$.\n\n**Test Case 4:** $E_4 = \\mathrm{if}(\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1)),\\, x + 0,\\, x + 0)$\n- Mutated program: $\\mathcal{M}(E_4) = \\mathcal{M}(x+0) = x+0$.\n- The condition $\\mathrm{is\\_defined}(\\mathrm{div\\_checked}(x,1))$ is always true. The original program always evaluates the true branch, $x+0$.\n- The true and false branches are identical, and the mutated program is also equivalent to $x+0$. Therefore, both original and mutated programs will produce identical results for all inputs.\n- The programs are equivalent. Thus, equivalence is $1$.\n\nThe final results for the test cases are $[0, 1, 0, 1]$.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include stdbool.h\n#include string.h\n#include math.h\n\n// --- Data Structures for AST and Evaluation ---\n\n// Defines the type of an expression node in the AST.\ntypedef enum {\n    EXPR_CONST, EXPR_VAR,\n    EXPR_ADD, EXPR_SUB, EXPR_MUL,\n    EXPR_DIV_CHECKED, EXPR_IS_DEFINED, EXPR_IF\n} ExprType;\n\n// Forward declaration for the expression structure.\ntypedef struct Expr Expr;\n\n// The structure for an Abstract Syntax Tree (AST) node.\nstruct Expr {\n    ExprType type;\n    union {\n        int value; // For EXPR_CONST\n        int var_idx; // 0 for x, 1 for y, 2 for z\n        struct { Expr *e1; Expr *e2; } bin_op;\n        struct { Expr *e; } un_op;\n        struct { Expr *cond; Expr *t_branch; Expr *f_branch; } if_op;\n    } as;\n};\n\n// Represents the result of an evaluation, which can be defined or undefined.\ntypedef struct {\n    bool is_defined;\n    int value;\n} Result;\n\n// Represents an input environment (x, y, z).\ntypedef struct {\n    int x;\n    int y;\n    int z;\n} Environment;\n\n\n// --- AST Node Factory Functions ---\n\nExpr* make_const(int value) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_CONST;\n    e-as.value = value;\n    return e;\n}\n\nExpr* make_var(int var_idx) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_VAR;\n    e-as.var_idx = var_idx;\n    return e;\n}\n\nExpr* make_bin_op(ExprType type, Expr* e1, Expr* e2) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = type;\n    e-as.bin_op.e1 = e1;\n    e-as.bin_op.e2 = e2;\n    return e;\n}\n\nExpr* make_is_defined(Expr* sub_expr) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_IS_DEFINED;\n    e-as.un_op.e = sub_expr;\n    return e;\n}\n\nExpr* make_if(Expr* cond, Expr* t_branch, Expr* f_branch) {\n    Expr* e = malloc(sizeof(Expr));\n    e-type = EXPR_IF;\n    e-as.if_op.cond = cond;\n    e-as.if_op.t_branch = t_branch;\n    e-as.if_op.f_branch = f_branch;\n    return e;\n}\n\n// Recursively frees an AST.\nvoid free_expr(Expr* e) {\n    if (e == NULL) return;\n    switch (e-type) {\n        case EXPR_CONST:\n        case EXPR_VAR:\n            break;\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED:\n            free_expr(e-as.bin_op.e1);\n            free_expr(e-as.bin_op.e2);\n            break;\n        case EXPR_IS_DEFINED:\n            free_expr(e-as.un_op.e);\n            break;\n        case EXPR_IF:\n            free_expr(e-as.if_op.cond);\n            free_expr(e-as.if_op.t_branch);\n            free_expr(e-as.if_op.f_branch);\n            break;\n    }\n    free(e);\n}\n\n// --- Interpreter and Mutation Operator ---\n\n// Evaluates an expression AST according to the defined semantics.\nResult eval(const Expr* e, const Environment* rho) {\n    if (e == NULL) return (Result){false, 0};\n\n    switch (e-type) {\n        case EXPR_CONST:\n            return (Result){true, e-as.value};\n        case EXPR_VAR: {\n            int val = 0;\n            if (e-as.var_idx == 0) val = rho-x;\n            else if (e-as.var_idx == 1) val = rho-y;\n            else val = rho-z;\n            return (Result){true, val};\n        }\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED: {\n            Result r1 = eval(e-as.bin_op.e1, rho);\n            if (!r1.is_defined) return r1;\n            Result r2 = eval(e-as.bin_op.e2, rho);\n            if (!r2.is_defined) return r2;\n\n            if (e-type == EXPR_ADD) return (Result){true, r1.value + r2.value};\n            if (e-type == EXPR_SUB) return (Result){true, r1.value - r2.value};\n            if (e-type == EXPR_MUL) return (Result){true, r1.value * r2.value};\n            if (e-type == EXPR_DIV_CHECKED) {\n                if (r2.value == 0) return (Result){false, 0};\n                return (Result){true, r1.value / r2.value};\n            }\n        }\n        case EXPR_IS_DEFINED: {\n            Result r = eval(e-as.un_op.e, rho);\n            return (Result){true, r.is_defined ? 1 : 0};\n        }\n        case EXPR_IF: {\n            Result c_res = eval(e-as.if_op.cond, rho);\n            if (!c_res.is_defined) {\n                return eval(e-as.if_op.f_branch, rho);\n            }\n            if (c_res.value != 0) {\n                return eval(e-as.if_op.t_branch, rho);\n            } else {\n                return eval(e-as.if_op.f_branch, rho);\n            }\n        }\n    }\n    return (Result){false, 0}; // Should be unreachable\n}\n\n// Creates a new, mutated AST based on the mutation operator rules.\nExpr* mutate(const Expr* e) {\n    if (e == NULL) return NULL;\n\n    if (e-type == EXPR_IF  e-as.if_op.cond-type == EXPR_IS_DEFINED) {\n        // Special rule: if(is_defined(E), T, F) - M(T)\n        return mutate(e-as.if_op.t_branch);\n    }\n    \n    switch (e-type) {\n        case EXPR_CONST:\n            return make_const(e-as.value);\n        case EXPR_VAR:\n            return make_var(e-as.var_idx);\n        case EXPR_ADD:\n        case EXPR_SUB:\n        case EXPR_MUL:\n        case EXPR_DIV_CHECKED:\n            return make_bin_op(e-type, mutate(e-as.bin_op.e1), mutate(e-as.bin_op.e2));\n        case EXPR_IS_DEFINED:\n            return make_is_defined(mutate(e-as.un_op.e));\n        case EXPR_IF:\n             return make_if(mutate(e-as.if_op.cond),\n                            mutate(e-as.if_op.t_branch),\n                            mutate(e-as.if_op.f_branch));\n    }\n    return NULL; // Should be unreachable\n}\n\n// --- Test Case Definitions ---\n\n// Test Case 1: E1 = if(is_defined(div_checked(x,y)), div_checked(x,y) + 1, 0)\nExpr* build_e1() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1))),\n        make_bin_op(EXPR_ADD, make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1)), make_const(1)),\n        make_const(0)\n    );\n}\n\n// Test Case 2: E2 = if(is_defined(div_checked(x,1)), x * 2, -1)\nExpr* build_e2() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_const(1))),\n        make_bin_op(EXPR_MUL, make_var(0), make_const(2)),\n        make_const(-1)\n    );\n}\n\n// Test Case 3: E3 = if(is_defined(div_checked(x,y)), if(is_defined(div_checked(y,z)), div_checked(x,y) + div_checked(y,z), 7), 8)\nExpr* build_e3() {\n    Expr* inner_if = make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(1), make_var(2))),\n        make_bin_op(EXPR_ADD,\n            make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1)),\n            make_bin_op(EXPR_DIV_CHECKED, make_var(1), make_var(2))\n        ),\n        make_const(7)\n    );\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_var(1))),\n        inner_if,\n        make_const(8)\n    );\n}\n\n// Test Case 4: E4 = if(is_defined(div_checked(x,1)), x + 0, x + 0)\nExpr* build_e4() {\n    return make_if(\n        make_is_defined(make_bin_op(EXPR_DIV_CHECKED, make_var(0), make_const(1))),\n        make_bin_op(EXPR_ADD, make_var(0), make_const(0)),\n        make_bin_op(EXPR_ADD, make_var(0), make_const(0))\n    );\n}\n\n// Structure for a complete test case.\ntypedef struct {\n    Expr* (*builder)(void);\n    Environment* envs;\n    int num_envs;\n} TestCase;\n\nint main(void) {\n    Environment envs1[] = {{10,2,0}, {10,0,0}, {0,5,0}, {-9,3,0}};\n    Environment envs2[] = {{7,123,0}, {-8,42,0}, {0,999,0}};\n    Environment envs3[] = {{12,3,2}, {12,0,2}, {12,3,0}, {0,10,2}, {9,-3,-3}};\n    Environment envs4[] = {{5,100,0}, {-1,2,0}};\n\n    TestCase test_cases[] = {\n        {build_e1, envs1, sizeof(envs1) / sizeof(envs1[0])},\n        {build_e2, envs2, sizeof(envs2) / sizeof(envs2[0])},\n        {build_e3, envs3, sizeof(envs3) / sizeof(envs3[0])},\n        {build_e4, envs4, sizeof(envs4) / sizeof(envs4[0])},\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i  num_cases; ++i) {\n        Expr* original_e = test_cases[i].builder();\n        Expr* mutated_e = mutate(original_e);\n        \n        int is_equivalent = 1; // Assume equivalence until a counterexample is found.\n        for (int j = 0; j  test_cases[i].num_envs; ++j) {\n            Result r_orig = eval(original_e, test_cases[i].envs[j]);\n            Result r_mut = eval(mutated_e, test_cases[i].envs[j]);\n            \n            bool are_equal = (r_orig.is_defined == r_mut.is_defined) \n                             (!r_orig.is_defined || r_orig.value == r_mut.value);\n            \n            if (!are_equal) {\n                is_equivalent = 0;\n                break;\n            }\n        }\n        results[i] = is_equivalent;\n        \n        free_expr(original_e);\n        free_expr(mutated_e);\n    }\n    \n    printf(\"[%d,%d,%d,%d]\", results[0], results[1], results[2], results[3]);\n    \n    return EXIT_SUCCESS;\n}\n```", "id": "3642978"}, {"introduction": "A program's logic is captured by its Control Flow Graph (CFG), but some Intermediate Representations (IRs) also rely on the linear layout of basic blocks for implicit fallthroughs. This exercise involves a core compiler task: making all control flow explicit to create a layout-independent IR [@problem_id:3643018]. By verifying that the set of reachable blocks remains identical after this transformation, you will confirm that the program's fundamental structure is preserved.", "problem": "You are to implement a self-contained Intermediate Representation (IR) level fuzzer that operates on a Control Flow Graph (CFG) representation of a function and verifies that reordering independent basic blocks does not change the semantics with respect to reachability from the entry block. Work from first principles of CFG semantics.\n\nUse the following formal base. A Control Flow Graph is a directed graph $G=(V,E)$ where $V$ is the finite set of basic blocks and $E \\subseteq V \\times V$ is the finite set of directed edges representing possible control transfers. The designated entry block is denoted $entry \\in V$ and is fixed. The reachability set $R(entry) \\subseteq V$ is the set of all blocks that are reachable from $entry$ via zero or more edges in $E$. In a linear IR layout, an implicit fallthrough exists when a basic block has zero out-degree and is not the final block in the linear order; formally, if block $b_i$ has out-degree $0$ and $i  |V|-1$, then control implicitly flows to $b_{i+1}$.\n\nYour fuzzer must:\n- Take a CFG with an implicit linear layout $b_0=entry, b_1, \\dots, b_{n-1}$, where $n=|V|$.\n- Compute $R(entry)$ under implicit fallthrough semantics, that is, treat each block $b_i$ with out-degree $0$ and $in-1$ as having an implicit edge to $b_{i+1}$.\n- Rewrite the CFG by inserting explicit fallthrough edges for every applicable block $b_i$ (for $in-1$) that has out-degree $0$, thereby eliminating layout-dependent semantics.\n- Randomly permute the linear order of basic blocks while preserving $b_0=entry$. This permutation must be layout-only; it must not relabel nodes or modify $E$ beyond explicit fallthrough insertion. After this transformation, compute $R(entry)$ again using only explicit edges (i.e., no implicit fallthroughs).\n- Assert equivalence by checking that the pre-transformation and post-transformation reachability sets from $entry$ are identical.\n\nConstruct your program to run a fixed test suite without external input. For reproducibility, use a deterministic pseudo-random shuffle with a fixed seed for the permutation.\n\nTest suite specification. Implement the following four CFGs, each defined by a block count $n$ and directed edge set $E$ over the block indices $\\{0,1,\\dots,n-1\\}$.\n- Test $1$ (general case with implicit fallthrough and explicit branch): $n=4$, $E=\\{(0,1),(2,3)\\}$. Here $b_1$ has an implicit fallthrough to $b_2$ in the original layout.\n- Test $2$ (boundary: single block): $n=1$, $E=\\emptyset$.\n- Test $3$ (unreachable blocks present): $n=5$, $E=\\{(0,1),(1,3),(3,3)\\}$. Blocks $2$ and $4$ are unreachable from $entry$ under both implicit and explicit semantics.\n- Test $4$ (loop structure): $n=4$, $E=\\{(0,1),(1,2),(2,1)\\}$.\n\nRequired output. For each test case $i \\in \\{1,2,3,4\\}$, produce an integer result $r_i$ where $r_i=1$ if the pre- and post-transformation reachability sets $R(entry)$ are equal, and $r_i=0$ otherwise. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, that is, the string representing the list $[r_1,r_2,r_3,r_4]$. No other output is permitted.", "solution": "The problem requires the implementation of a verification routine, framed as a fuzzer, to confirm a fundamental principle of compiler correctness: that making implicit control flow explicit preserves program semantics with respect to basic block reachability. The fuzzer must operate on a Control Flow Graph (CFG) and validate this principle across a suite of test cases.\n\nFirst, we formalize the components of the problem. A CFG is a directed graph $G=(V, E)$, where $V$ is a set of basic blocks, indexed from $0$ to $n-1$ where $n=|V|$, and $E$ is a set of directed edges representing explicit jumps or branches. The block $b_0$ is the designated, fixed entry block, denoted $entry$. The program semantics under consideration is the reachability set $R(entry)$, which contains all blocks reachable from $entry$.\n\nThe problem introduces layout-dependent semantics through the rule of **implicit fallthrough**. A linear arrangement of blocks in memory, $b_0, b_1, \\dots, b_{n-1}$, implies that if a block $b_i$ has an out-degree of $0$ (i.e., it does not end in an explicit branch) and it is not the last block in the sequence ($i  n-1$), control flow implicitly transfers to the next block in the sequence, $b_{i+1}$.\n\nThe process involves two main stages of analysis for each test case.\n\n**1. Pre-Transformation Analysis: Semantics with Implicit Fallthrough**\n\nIn this stage, we determine the reachability set based on the initial layout-dependent semantics.\nLet the initial CFG be $G_{orig}=(V, E_{explicit})$ with the linear layout $L_{orig}=(b_0, b_1, \\dots, b_{n-1})$.\nWe first identify all implicit edges. For each block $b_i$ where $0 \\le i  n-1$, we calculate its out-degree based solely on the explicit edge set $E_{explicit}$. If the out-degree of $b_i$ is $0$, we introduce an implicit edge $(b_i, b_{i+1})$. Let the set of these newly identified edges be $E_{implicit}$.\nAn \"effective\" CFG, $G_{effective}=(V, E_{explicit} \\cup E_{implicit})$, is constructed. The pre-transformation reachability set, $R_{pre}(entry)$, is then computed on this graph. This set represents the complete control flow behavior of the program in its original, layout-dependent form.\n\nTo compute the reachability set, a graph traversal algorithm such as a Depth-First Search (DFS) or Breadth-First Search (BFS) is employed. Starting from the entry block $b_0$, the algorithm explores all reachable blocks by following the edges in $G_{effective}$. The set of all visited blocks constitutes $R_{pre}(entry)$.\n\n**2. Post-Transformation Analysis: Semantics with Explicit Fallthrough**\n\nThe core of the transformation is to make the CFG's semantics layout-independent. This is achieved by converting all implicit fallthrough edges into explicit edges. The rewritten CFG, $G_{rewritten}=(V, E_{rewritten})$, has an edge set $E_{rewritten} = E_{explicit} \\cup E_{implicit}$. By definition, this graph is identical to $G_{effective}$.\n\nThe problem states that after this rewriting, the block layout is randomly permuted (while keeping $b_0$ as the entry) and reachability is re-computed. This permutation is the \"fuzzing\" aspect, designed to test if the program semantics have become truly layout-independent. The key instruction is that this new reachability calculation must use \"only explicit edges (i.e., no implicit fallthroughs)\". Since all control flow in $G_{rewritten}$ is explicit, its reachability is inherently independent of any linear block layout. Therefore, permuting the blocks has no effect on the reachability calculation for $G_{rewritten}$.\n\nThe post-transformation reachability set, $R_{post}(entry)$, is computed by performing the same traversal algorithm (DFS or BFS) on $G_{rewritten}$, starting from $entry=b_0$.\n\n**3. Verification**\n\nThe final step is to assert the equivalence of the semantics before and after the transformation. This is done by comparing the two reachability sets: $R_{pre}(entry)$ and $R_{post}(entry)$. The assertion holds if and only if $R_{pre}(entry) = R_{post}(entry)$.\n\nSince $G_{effective}$ and $G_{rewritten}$ are constructed to be the same graph, their reachability sets from the same entry point must be identical. Thus, for any valid CFG, the check $R_{pre}(entry) = R_{post}(entry)$ must always pass. The program's output, a list of $1$s, serves as a computational proof of this principle for the given test cases.\n\nThe implementation will therefore proceed as follows for each test case:\n- Represent the CFG using an adjacency matrix.\n- Construct the initial graph $G_{orig}$ with only explicit edges from the test case specification.\n- Construct the effective graph $G_{effective}$ by adding edges corresponding to implicit fallthroughs in the original layout.\n- Compute the reachability set $R_{pre}$ on $G_{effective}$ using DFS from block $0$.\n- The post-transformation graph $G_{rewritten}$ is identical to $G_{effective}$.\n- The conceptual permutation of blocks is implemented but is irrelevant to the subsequent calculation, as per the problem's explicit instruction to use only explicit edges.\n- Compute the reachability set $R_{post}$ on $G_{rewritten}$ (which is the same as $G_{effective}$) using DFS from block $0$.\n- Compare $R_{pre}$ and $R_{post}$. If they are identical, the result for the test case is $1$; otherwise, it is $0$.\n\nThe final output for all test cases will be $[1,1,1,1]$, verifying the correctness of the layout-independent transformation.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n// #include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to represent a directed edge in the CFG.\ntypedef struct {\n    int from;\n    int to;\n} Edge;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int n;           // Number of basic blocks\n    Edge* edges;     // Array of explicit edges\n    int num_edges;   // Number of explicit edges\n} TestCase;\n\n/**\n * @brief Computes the set of reachable blocks from a starting block using DFS.\n *\n * @param u The current block being visited.\n * @param n The total number of blocks in the CFG.\n * @param adj The n x n adjacency matrix of the CFG.\n * @param visited An array of size n to mark visited blocks.\n */\nvoid compute_reachability_dfs(int u, int n, int adj[][n], int visited[]) {\n    visited[u] = 1;\n    for (int v = 0; v  n; ++v) {\n        if (adj[u][v]  !visited[v]) {\n            compute_reachability_dfs(v, n, adj, visited);\n        }\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    Edge edges1[] = {{0, 1}, {2, 3}};\n    Edge edges2[] = {};\n    Edge edges3[] = {{0, 1}, {1, 3}, {3, 3}};\n    Edge edges4[] = {{0, 1}, {1, 2}, {2, 1}};\n\n    TestCase test_cases[] = {\n        {4, edges1, sizeof(edges1) / sizeof(edges1[0])},\n        {1, edges2, sizeof(edges2) / sizeof(edges2[0])},\n        {5, edges3, sizeof(edges3) / sizeof(edges3[0])},\n        {4, edges4, sizeof(edges4) / sizeof(edges4[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        int n = test_cases[i].n;\n        Edge* edges = test_cases[i].edges;\n        int num_edges = test_cases[i].num_edges;\n\n        // VLA for adjacency matrix. C23 standard supports this.\n        int adj_explicit[n][n];\n        memset(adj_explicit, 0, sizeof(adj_explicit));\n        for (int j = 0; j  num_edges; ++j) {\n            adj_explicit[edges[j].from][edges[j].to] = 1;\n        }\n\n        // --- Pre-Transformation Analysis ---\n        // Build the effective CFG including implicit fallthroughs.\n        int adj_effective[n][n];\n        memcpy(adj_effective, adj_explicit, sizeof(adj_effective));\n\n        for (int j = 0; j  n - 1; ++j) {\n            int out_degree = 0;\n            for (int k = 0; k  n; ++k) {\n                out_degree += adj_explicit[j][k];\n            }\n            if (out_degree == 0) {\n                adj_effective[j][j + 1] = 1; // Add implicit fallthrough edge.\n            }\n        }\n\n        // Compute reachability on the layout-dependent (effective) CFG.\n        int reachable_pre[n];\n        memset(reachable_pre, 0, sizeof(reachable_pre));\n        if (n  0) {\n            compute_reachability_dfs(0, n, adj_effective, reachable_pre);\n        }\n\n        // --- Post-Transformation Analysis ---\n        // The transformation creates a new CFG with explicit fallthroughs. This\n        // is identical to our `adj_effective` graph.\n        \n        // The problem mentions permuting the layout to fuzz test. We implement\n        // this step, but as per the rules, the subsequent reachability check\n        // uses only explicit edges, making the layout irrelevant.\n        int layout[n  0 ? n : 1];\n        for(int j=0; jn; ++j) layout[j] = j;\n\n        if (n  1) { // Shuffle only if there's more than one block\n            srand(42); // Fixed seed for reproducibility\n            // Fisher-Yates shuffle on blocks {1, ..., n-1}\n            for (int j = n - 1; j  1; --j) {\n                int k = 1 + rand() % j; // k is in [1, j]\n                int temp = layout[j];\n                layout[j] = layout[k];\n                layout[k] = temp;\n            }\n        }\n        \n        // Compute reachability on the rewritten, layout-independent CFG.\n        int reachable_post[n];\n        memset(reachable_post, 0, sizeof(reachable_post));\n        if (n  0) {\n            // The graph is `adj_effective`, which now contains all edges explicitly.\n            compute_reachability_dfs(0, n, adj_effective, reachable_post);\n        }\n\n        // --- Verification ---\n        // Assert that the reachability sets are identical.\n        int are_equal = 1;\n        for (int j = 0; j  n; ++j) {\n            if (reachable_pre[j] != reachable_post[j]) {\n                are_equal = 0;\n                break;\n            }\n        }\n        results[i] = are_equal;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643018"}, {"introduction": "Optimizations like Loop Invariant Code Motion (LICM) depend on proving that moving an instruction will not change the program's meaning, which for memory operations requires rigorous alias analysis. This practice provides a hands-on look at this challenge by tasking you with implementing a verifier for LICM safety [@problem_id:3643001]. You will apply a formal model of memory aliasing to determine if a load can be safely hoisted from a loop, grappling with the same dependency-checking logic used in modern compilers.", "problem": "You are to write a complete, runnable program that evaluates the safety of hoisting loads out of loops under Loop Invariant Code Motion (LICM) using a simplified, sound model of alias analysis. The purpose is to simulate a fuzzing harness that generates pointer-intensive patterns and verifies whether LICM would only hoist loads that are provably invariant by no-alias reasoning.\n\nFundamental base. Begin from the following standard definitions in compiler theory:\n\n- A memory address is modeled as a pair $\\left(i, o\\right)$, where $i$ is a memory object identifier (an integer index for a distinct allocation), and $o$ is a byte offset within that object. Two addresses $\\left(i, o\\right)$ and $\\left(j, p\\right)$ alias if and only if $i = j$ and $o = p$.\n- A loop induction variable $k$ ranges over integers with unit stride, $k \\in \\left[L, U\\right)$, where $L$ and $U$ are integers and the iteration set is $\\{L, L+1, \\dots, U-1\\}$.\n- A load address is an affine (linear) function of the loop variable, $o_L(k) = a_L \\cdot k + b_L$ for integers $a_L$ and $b_L$. A store address is similar, $o_S(k) = a_S \\cdot k + b_S$.\n- A loop-invariant expression is one whose value does not change across iterations of the loop. For the load address, this means $a_L = 0$ (so $o_L(k) = b_L$ is constant for all $k$).\n- Loop Invariant Code Motion (LICM) may hoist a load from inside a loop to a point before the loop if and only if the load’s address is loop-invariant and the memory location read is not clobbered by any store in the loop. Under the above alias model, this means that there must be no store whose address aliases the load’s address for any iteration $k \\in [L,U)$.\n\nYour program must implement the following logical derivation and decision procedure:\n\n1. For a given load address $o_L(k) = a_L \\cdot k + b_L$, a necessary condition for hoisting is loop-invariance of the address. That is, check $a_L = 0$. If $a_L \\neq 0$, the load cannot be hoisted.\n2. Assuming $a_L = 0$, the load address is the constant offset $b_L$ within object $i_L$. For every store in the loop with address $o_S(k) = a_S \\cdot k + b_S$ to object $i_S$:\n   - If $i_S \\neq i_L$, the store cannot alias the load by definition of distinct objects, and can be ignored.\n   - If $i_S = i_L$ and $a_S = 0$, then the store aliases the load if and only if $b_S = b_L$.\n   - If $i_S = i_L$ and $a_S \\neq 0$, the store aliases the load if and only if there exists an integer $k \\in [L, U)$ such that $a_S \\cdot k + b_S = b_L$. This is equivalent to the existence of an integer solution\n     $$ k = \\frac{b_L - b_S}{a_S} $$\n     that satisfies both $a_S \\mid (b_L - b_S)$ and $L \\le k  U$.\n3. LICM hoisting is safe if and only if the address is loop-invariant and no store in the loop aliases the load for any iteration.\n\nModeling notes:\n\n- The alias model treats different memory object identifiers as disjoint by construction, representing a no-alias proof derived from allocation provenance or qualified disjointness. Within the same object, aliasing reduces to integer equality of offsets.\n- The loop is unit-stride, so the iteration set is a contiguous integer interval. You must use exact integer arithmetic to test divisibility and bounds.\n\nInput model. There is no input. Your program must embed and evaluate the following fixed test suite. Each test consists of bounds $L$, $U$, a load description $(i_L, a_L, b_L)$, and a list of stores $\\{(i_{S_t}, a_{S_t}, b_{S_t})\\}_{t=1}^m$.\n\nTest Suite:\n\n- Test $1$: $L=0$, $U=10$, load $(i_L=0, a_L=0, b_L=16)$; stores $\\{(1, 1, 0)\\}$.\n- Test $2$: $L=0$, $U=7$, load $(i_L=0, a_L=0, b_L=16)$; stores $\\{(0, 0, 24)\\}$.\n- Test $3$: $L=0$, $U=5$, load $(i_L=0, a_L=0, b_L=16)$; stores $\\{(0, 0, 16)\\}$.\n- Test $4$: $L=0$, $U=4$, load $(i_L=2, a_L=0, b_L=8)$; stores $\\{(2, 4, 0)\\}$.\n- Test $5$: $L=0$, $U=3$, load $(i_L=5, a_L=0, b_L=8)$; stores $\\{(5, 3, 1)\\}$.\n- Test $6$: $L=0$, $U=5$, load $(i_L=1, a_L=2, b_L=0)$; stores $\\{\\}$.\n- Test $7$: $L=0$, $U=10$, load $(i_L=6, a_L=0, b_L=8)$; stores $\\{(7, 0, 8), (6, 0, 12), (6, 2, 1)\\}$.\n\nYour program must, for each test, compute the boolean decision “safe to hoist” according to the derivation above, where the result is $1$ for “safe to hoist” and $0$ for “not safe to hoist”.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact form\n$$ [r_1,r_2,r_3,r_4,r_5,r_6,r_7] $$\nwhere each $r_t$ is either $0$ or $1$ for test $t$ in order. No spaces are permitted in the output string. There are no physical units and no angles in this problem, and any fractional values must be computed with exact integer arithmetic as specified.", "solution": "The problem requires the implementation of a decision procedure to determine the safety of hoisting a load instruction out of a loop, a common compiler optimization known as Loop Invariant Code Motion (LICM). The safety check is based on a defined model of memory addresses and alias analysis. The solution is derived by systematically applying the provided rules.\n\nA memory address is a pair $(i, o)$, where $i$ is an integer object identifier and $o$ is a byte offset. Aliasing occurs between two addresses $(i, o)$ and $(j, p)$ if and only if $i = j$ and $o = p$. The loop-dependent addresses for a load and a store are modeled as affine functions of the loop induction variable $k$, which iterates over the integer range $[L, U)$, i.e., $k \\in \\{L, L+1, \\dots, U-1\\}$. The load address offset is $o_L(k) = a_L \\cdot k + b_L$, and a store address offset is $o_S(k) = a_S \\cdot k + b_S$.\n\nThe decision procedure follows a two-step logical progression.\n\nFirst, a load can be considered for hoisting only if its effective address is loop-invariant. This means its value does not change from one iteration to the next. For the address function $o_L(k) = a_L \\cdot k + b_L$, this requires that the coefficient of the loop induction variable $k$ must be zero.\n$$ a_L = 0 $$\nIf $a_L \\neq 0$, the load address changes with each iteration, making it inherently loop-variant. Such a load cannot be hoisted, and the procedure determines it is unsafe.\n\nSecond, if the load address is loop-invariant (i.e., $a_L = 0$, so the address is the constant offset $b_L$ within object $i_L$), we must guarantee that no store instruction within the loop modifies (clobbers) this memory location. This requires checking every store in the loop against the load. For each store, described by $(i_S, a_S, b_S)$, we analyze potential aliasing.\n\nThe alias analysis proceeds with the following case distinctions for each store:\n1.  **Disjoint Memory Objects**: If the store operates on a different memory object than the load, i.e., $i_S \\neq i_L$, they are guaranteed not to alias by the problem's definition. The store is benign with respect to the load.\n\n2.  **Same Memory Object, Invariant Store Address**: If the store is to the same object ($i_S = i_L$) and its address is also loop-invariant ($a_S = 0$), then both the load and the store access constant offsets. An alias occurs if and only if these constant offsets are equal:\n    $$ b_S = b_L $$\n    If this condition holds, the load is clobbered in every iteration, and hoisting is unsafe.\n\n3.  **Same Memory Object, Variant Store Address**: If the store is to the same object ($i_S = i_L$) but its address is loop-variant ($a_S \\neq 0$), an alias occurs if there exists an integer iteration $k$ in the range $[L, U)$ for which the store's address equals the load's address. We must solve the following equation for an integer $k$:\n    $$ a_S \\cdot k + b_S = b_L $$\n    Rearranging for $k$ gives:\n    $$ k = \\frac{b_L - b_S}{a_S} $$\n    For an alias to exist, two conditions must be met simultaneously:\n    a. The equation must have an integer solution for $k$. This is true if and only if the numerator is an integer multiple of the denominator, which can be checked using the modulo operator: $(b_L - b_S) \\pmod{a_S} = 0$.\n    b. The integer solution $k$ must fall within the loop's iteration set, i.e., $L \\le k  U$.\n\nIf for any store an alias is detected through either case $2$ or $3$, the no-alias guarantee is violated, and hoisting is unsafe.\n\nLICM is determined to be safe if and only if the load address is loop-invariant ($a_L = 0$) and absolutely no store within the loop aliases the load's address for any iteration $k \\in [L, U)$. The program implements this logic for each test case, producing a result of $1$ for \"safe to hoist\" and $0$ for \"not safe to hoist\".", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n// #include string.h\n// #include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to model a memory access, either a load or a store.\n// The address offset is modeled as o(k) = a*k + b.\ntypedef struct {\n    int obj_id;\n    int a;\n    int b;\n} MemoryAccess;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int L;\n    int U;\n    MemoryAccess load;\n    const MemoryAccess* stores;\n    int num_stores;\n} TestCase;\n\n// Function to check if hoisting is safe for a given test case.\n// Returns 1 if safe, 0 if unsafe.\nint is_hoisting_safe(const TestCase* tc) {\n    // 1. A necessary condition for hoisting is loop-invariance of the address.\n    // This means the coefficient of the loop variable must be 0.\n    if (tc-load.a != 0) {\n        return 0; // Unsafe: load address is not loop-invariant.\n    }\n\n    // The load address is invariant, with constant offset tc-load.b in object tc-load.obj_id.\n    // 2. Check for aliasing with every store in the loop.\n    for (int i = 0; i  tc-num_stores; ++i) {\n        const MemoryAccess* store = tc-stores[i];\n\n        // If store is to a different object, it cannot alias by definition.\n        if (store-obj_id != tc-load.obj_id) {\n            continue;\n        }\n\n        // The store is to the same memory object as the load.\n        if (store-a == 0) {\n            // Case: Store address is also loop-invariant.\n            // Alias occurs if the constant offsets are identical.\n            if (store-b == tc-load.b) {\n                return 0; // Unsafe: aliasing invariant store found.\n            }\n        } else {\n            // Case: Store address is loop-variant.\n            // Alias occurs if a_S * k + b_S = b_L has an integer solution k in [L, U).\n            int numerator = tc-load.b - store-b;\n            int denominator = store-a;\n\n            // Check for integer divisibility.\n            if (numerator % denominator == 0) {\n                int k = numerator / denominator;\n                // Check if the integer solution k is within the loop's iteration bounds.\n                if (k = tc-L  k  tc-U) {\n                    return 0; // Unsafe: aliasing variant store found for k.\n                }\n            }\n        }\n    }\n\n    // If we checked all stores and found no alias, hoisting is safe.\n    return 1;\n}\n\nint main(void) {\n    // Define the store arrays for each test case as per the problem statement.\n    const MemoryAccess stores1[] = {{1, 1, 0}};\n    const MemoryAccess stores2[] = {{0, 0, 24}};\n    const MemoryAccess stores3[] = {{0, 0, 16}};\n    const MemoryAccess stores4[] = {{2, 4, 0}};\n    const MemoryAccess stores5[] = {{5, 3, 1}};\n    // Test 6 has an empty set of stores.\n    const MemoryAccess stores7[] = {{7, 0, 8}, {6, 0, 12}, {6, 2, 1}};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        /* Test 1 */ {0, 10, {0, 0, 16}, stores1, 1},\n        /* Test 2 */ {0, 7,  {0, 0, 16}, stores2, 1},\n        /* Test 3 */ {0, 5,  {0, 0, 16}, stores3, 1},\n        /* Test 4 */ {0, 4,  {2, 0, 8},  stores4, 1},\n        /* Test 5 */ {0, 3,  {5, 0, 8},  stores5, 1},\n        /* Test 6 */ {0, 5,  {1, 2, 0},  NULL,    0},\n        /* Test 7 */ {0, 10, {6, 0, 8},  stores7, 3},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = is_hoisting_safe(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643001"}]}