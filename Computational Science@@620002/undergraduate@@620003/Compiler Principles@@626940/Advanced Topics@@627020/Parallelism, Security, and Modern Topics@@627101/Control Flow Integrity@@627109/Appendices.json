{"hands_on_practices": [{"introduction": "The effectiveness of Control Flow Integrity (CFI) hinges on the precision of the static analysis used to compute the set of valid control-flow targets. This exercise demonstrates how standard compiler optimizations, such as partial evaluation and constant propagation, can directly enhance security by refining these target sets. By working through this problem, you will learn to quantify the reduction in the size of a target set, $\\lvert T \\rvert$, providing a concrete measure of how optimizing a program can also make it more secure [@problem_id:3632876].", "problem": "A compiler enforces Control Flow Integrity (CFI) at an indirect call site by requiring that the dynamic target belongs to a statically computed target set $T$. Consider a program in which the target of the indirect call is selected by a table-driven dispatcher indexed by a triple $(\\text{type}, \\text{op}, \\text{mode})$. The static analysis that computes $T$ proceeds from the following conservative but uniform facts, which hold before any specialization:\n- There are $N$ distinct runtime types that may reach the call site.\n- For each runtime type, exactly $u$ operations are deemed safe by static analysis to be paired with that type at this call site.\n- For each pair $(\\text{type}, \\text{op})$ that is safe, exactly $v$ modes are deemed safe.\n\nAll quantities $N$, $u$, and $v$ are positive integers. Assume the safety judgments are uniform across types and operations in the sense described above.\n\nNow suppose the compiler performs Partial Evaluation (PE) and constant propagation before computing $T$ for enforcement. The following compile-time facts become known:\n- The reaching runtime type at the call site is a single known constant type.\n- A global configuration constant forces the dispatcher to restrict modes to a subset of size $v_{s}$ for every safe $(\\text{type}, \\text{op})$, where $v_{s}$ is a positive integer with $v_{s} \\leq v$.\n- A preceding specialization step replaces a data-dependent operation filter with a constant, restricting the set of safe operations for the known type to a subset of size $w$, where $w$ is a positive integer with $w \\leq u$.\n\nUnder these assumptions, model the CFI target set as the set of all handler entries that remain feasible after the respective analyses, using only basic counting principles for finite sets. Using first principles (the definition of CFI as restricting dynamic targets to a statically determined finite set, the definition of Partial Evaluation as specialization with respect to known constants, and the product rule for cardinalities of independent finite choices), derive a closed-form symbolic expression for the absolute reduction in target set size,\n$$\\Delta \\;=\\; \\lvert T \\rvert \\;-\\; \\lvert T' \\rvert,$$\nwhere $T$ is computed before specialization and $T'$ is computed after specialization. Express your final answer as a single analytic expression in terms of $N$, $u$, $v$, $w$, and $v_{s}$.", "solution": "The problem statement is critically validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- The Control Flow Integrity (CFI) target set is denoted by $T$.\n- The target of the indirect call is selected by a triple $(\\text{type}, \\text{op}, \\text{mode})$.\n- Before specialization, the following facts hold for the computation of $T$:\n    - The number of distinct runtime types is $N$.\n    - For each type, the number of safe operations is $u$.\n    - For each safe $(\\text{type}, \\text{op})$ pair, the number of safe modes is $v$.\n- All quantities $N$, $u$, and $v$ are positive integers.\n- After Partial Evaluation (PE) and constant propagation, a new target set $T'$ is computed based on the following compile-time facts:\n    - The number of reaching runtime types is $1$.\n    - The number of safe operations for the known type is a subset of size $w$, where $w$ is a positive integer and $w \\leq u$.\n    - The number of safe modes for every safe $(\\text{type}, \\text{op})$ pair is a subset of size $v_{s}$, where $v_{s}$ is a positive integer and $v_{s} \\leq v$.\n- The objective is to derive a closed-form symbolic expression for the absolute reduction in target set size, $\\Delta = \\lvert T \\rvert - \\lvert T' \\rvert$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the established criteria:\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of compiler design and computer security. The concepts of Control Flow Integrity (CFI), static analysis, Partial Evaluation (PE), and constant propagation are standard and well-defined topics in computer science. The problem models a common scenario where compiler optimizations refine static analysis results, which is a scientifically sound premise.\n- **Well-Posed:** The problem provides all necessary variables ($N, u, v, w, v_s$) and relationships to uniquely determine the sizes of the sets $T$ and $T'$. The goal is explicitly stated as finding the difference of their cardinalities, $\\Delta$. The constraints $w \\leq u$ and $v_s \\leq v$ ensure the specialized set is a subset of what would have been allowed for that choice, which is logical. A unique, meaningful solution exists.\n- **Objective:** The language is formal and precise, using established terminology from the field of compilers. There are no subjective or ambiguous statements.\n\nThe problem does not exhibit any of the defined invalidity flaws. It is a well-structured, formalizable problem based on established scientific principles.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived.\n\n### Solution Derivation\n\nThe core of the problem is to determine the cardinalities of the two target sets, $T$ (before specialization) and $T'$ (after specialization), and then compute their difference. The problem states that the targets are indexed by a triple $(\\text{type}, \\text{op}, \\text{mode})$. The total number of valid targets is therefore the total number of unique, valid triples that can be formed. We will use the fundamental product rule of counting, which states that if a procedure can be broken down into a sequence of independent choices, the total number of outcomes is the product of the number of options at each stage.\n\nFirst, we calculate the size of the initial target set, $\\lvert T \\rvert$, before any specialization is performed.\n1.  The choice of `type` can be any of the $N$ distinct runtime types that may reach the call site. So, there are $N$ options for the first element of the triple.\n2.  For each of these $N$ types, the static analysis deems exactly $u$ operations to be safe. Thus, for any given choice of `type`, there are $u$ options for the `op`.\n3.  For each safe pair of $(\\text{type}, \\text{op})$, there are exactly $v$ safe modes. So, for any given choice of the first two elements of the triple, there are $v$ options for the `mode`.\n\nSince the choices are independent, the total number of valid triples $(\\text{type}, \\text{op}, \\text{mode})$ is the product of the number of options at each stage.\n$$\\lvert T \\rvert = N \\times u \\times v$$\n\nNext, we calculate the size of the specialized target set, $\\lvert T' \\rvert$, after Partial Evaluation and other optimizations have been applied.\n1.  The compiler determines that the reaching runtime type is a single known constant. This reduces the number of options for `type` from $N$ to $1$.\n2.  For this single known type, a specialization step has restricted the set of safe operations to a subset of size $w$. So, there are now $w$ options for the `op`.\n3.  A global configuration constant restricts the number of allowed modes to a subset of size $v_s$ for every safe $(\\text{type}, \\text{op})$ pair. This means for our single known type and any of its $w$ safe operations, there are $v_s$ options for the `mode`.\n\nApplying the product rule again for the specialized case:\n$$\\lvert T' \\rvert = 1 \\times w \\times v_s = w v_s$$\n\nThe problem asks for the absolute reduction in the target set size, which is $\\Delta = \\lvert T \\rvert - \\lvert T' \\rvert$. Substituting the expressions for $\\lvert T \\rvert$ and $\\lvert T' \\rvert$ that we derived:\n$$\\Delta = (Nuv) - (wv_s)$$\n\nThis expression represents the total number of control flow paths that were pruned by the compiler's specialization and constant propagation optimizations. It is a closed-form symbolic expression in terms of the given parameters $N$, $u$, $v$, $w$, and $v_{s}$.", "answer": "$$\\boxed{Nuv - w v_{s}}$$", "id": "3632876"}, {"introduction": "Implementing CFI requires translating abstract policies into concrete code instrumentation. This practice challenges you to design a security check for a common programming construct: a `switch` statement compiled into an indexed jump table. You will use interval arithmetic, a lightweight form of static analysis, to derive the tightest possible bounds check on the computed jump index, thereby guaranteeing that the indirect branch is both safe and correct [@problem_id:3632863].", "problem": "A compiler lowers a structured multi-branch statement to a jump-table indexed by an integer expression. Under Control Flow Integrity (CFI), every indirect branch must be instrumented so that it can target only a statically determined set of valid basic blocks. Consider a structured switch on integral cases that the compiler has laid out as a contiguous jump table covering case labels $0, 1, \\dots, 20$ and a separate default block. The index used to address the table is computed from program variables $x$ and $y$ as\n$$\nj \\;=\\; \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64,\n$$\nwhere $\\lfloor \\cdot \\rfloor$ denotes the floor function and the modulo operation yields the nonnegative remainder in $\\{0,1,\\dots,63\\}$. A static range analysis has established the input ranges $x \\in [-4,12]$ and $y \\in [1,9]$ at the program point of the switch.\n\nYou are to suggest a CFI-compliant instrumentation method for jump-table switches that uses a single bounds check on the computed index before performing the indirect jump. Using interval arithmetic and well-defined semantics of integer floor and modulo, derive the tightest constant upper bound $U$ such that inserting a guard of the form “perform the indirect jump only if $j < U$, otherwise branch to the default block” guarantees that the indirect jump can only target entries $0$ through $20$ for all $x \\in [-4,12]$ and $y \\in [1,9]$.\n\nProvide the minimal such constant $U$ as your final answer. No rounding is required.", "solution": "The objective is to determine the minimal integer constant $U$ for a security check of the form $j < U$. This check must guarantee that any indirect jump, indexed by $j$, targets only the valid entries of a jump table, which are specified as $\\{0, 1, \\dots, 20\\}$. The check must also be correct in that it permits all valid, reachable jump targets. The index $j$ is computed based on program variables $x$ and $y$ with known ranges.\n\nThe index $j$ is given by the expression:\n$$\nj = \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64\n$$\nThe static analysis provides the ranges for the variables $x$ and $y$ as $x \\in [-4, 12]$ and $y \\in [1, 9]$. We assume $x$ and $y$ can be any real numbers within these closed intervals. The modulo operation is defined to yield a non-negative remainder in $\\{0, 1, \\dots, 63\\}$.\n\nFirst, we must determine the set of all possible values for $j$ by applying interval arithmetic to the expression. Let the argument of the floor function be $V$:\n$$\nV = \\frac{3x - 2y + 7}{2}\n$$\nWe derive the interval for the numerator, $3x - 2y + 7$:\n1.  The term $3x$: Since $x \\in [-4, 12]$, multiplying by $3$ gives $3x \\in [3 \\times (-4), 3 \\times 12] = [-12, 36]$.\n2.  The term $-2y$: Since $y \\in [1, 9]$, $2y \\in [2, 18]$. Negating this interval gives $-2y \\in [-18, -2]$.\n3.  Adding the intervals for $3x$, $-2y$, and the constant $7$:\n    The lower bound is $-12 + (-18) + 7 = -23$.\n    The upper bound is $36 + (-2) + 7 = 41$.\n    Thus, $3x - 2y + 7 \\in [-23, 41]$.\n\nNow, we find the interval for $V$ by dividing by $2$:\n$$\nV \\in \\left[\\frac{-23}{2}, \\frac{41}{2}\\right] = [-11.5, 20.5]\n$$\n\nLet $k = \\lfloor V \\rfloor = \\lfloor \\frac{3x - 2y + 7}{2} \\rfloor$. Since the floor function is non-decreasing, we can find the range of $k$ by taking the floor of the endpoints of the interval for $V$.\nThe minimum value of $k$ is $\\lfloor -11.5 \\rfloor = -12$.\nThe maximum value of $k$ is $\\lfloor 20.5 \\rfloor = 20$.\nThe interval for $V$ is continuous and has a width of $20.5 - (-11.5) = 32$, which is greater than $1$. Therefore, $k$ can take on any integer value between its minimum and maximum.\nSo, the set of possible values for $k$ is $\\{-12, -11, \\dots, 19, 20\\}$.\n\nNext, we compute the final index $j = k \\bmod 64$. We analyze two cases for the values of $k$:\n1.  For non-negative $k$, where $k \\in \\{0, 1, \\dots, 20\\}$:\n    In this range, $j = k \\bmod 64 = k$.\n    Thus, this part of the range of $k$ produces the set of indices $\\{0, 1, \\dots, 20\\}$. These are all valid jump targets.\n2.  For negative $k$, where $k \\in \\{-12, -11, \\dots, -1\\}$:\n    The problem specifies that the modulo operation yields a non-negative remainder. This corresponds to the mathematical definition $a \\bmod n = a - n \\lfloor a/n \\rfloor$. For negative $a$ and positive $n$, this is equivalent to $a + n$.\n    For $k = -1$, $j = -1 \\bmod 64 = 63$.\n    For $k = -2$, $j = -2 \\bmod 64 = 62$.\n    ...\n    For $k = -12$, $j = -12 \\bmod 64 = 52$.\n    Thus, this part of the range of $k$ produces the set of indices $\\{52, 53, \\dots, 63\\}$. These are all invalid jump targets, as they lie outside the valid range of $\\{0, 1, \\dots, 20\\}$.\n\nCombining both cases, the set $S$ of all possible computed values for the index $j$ is:\n$$\nS = \\{0, 1, \\dots, 20\\} \\cup \\{52, 53, \\dots, 63\\}\n$$\nThe Control Flow Integrity (CFI) guard is `if (j  U) jump() else default()`. This mechanism must satisfy two conditions:\n1.  **Safety**: It must prevent all jumps to invalid targets. Any computed index $j$ that passes the check (i.e., $j  U$) must be a valid target. The set of computed indices that pass the check is $S \\cap \\{0, 1, \\dots, U-1\\}$. This set must be a subset of the valid targets $\\{0, 1, \\dots, 20\\}$.\n    $$\n    S \\cap \\{0, 1, \\dots, U-1\\} \\subseteq \\{0, 1, \\dots, 20\\}\n    $$\n    The invalid indices in $S$ are $\\{52, 53, \\dots, 63\\}$. For the condition to hold, none of these invalid indices can pass the check $j  U$. This means for any $j_{invalid} \\in \\{52, 53, \\dots, 63\\}$, we must have $j_{invalid} \\ge U$. The most restrictive case is for the smallest of these invalid indices, which is $52$. So, we must have $52 \\ge U$.\n\n2.  **Correctness**: It must not prevent valid program execution. All valid case labels that can be reached must be allowed by the check. The set of valid targets that are reachable is $\\{0, 1, \\dots, 20\\}$. For each of these values $j_{valid}$, the check $j_{valid}  U$ must be true.\n    This must hold for all $j \\in \\{0, 1, \\dots, 20\\}$. The most restrictive case is for the largest of these valid indices, which is $20$. So, we must have $20  U$.\n\nCombining the two conditions, $U$ must be an integer satisfying $20  U$ and $U \\le 52$. This means $U$ can be any integer in the range $[21, 52]$.\nThe problem asks for the *minimal* such constant $U$. This corresponds to making the check as tight as possible without violating correctness. The minimal integer value for $U$ that satisfies $20  U$ is $21$. This value also satisfies $U \\le 52$.\n\nTherefore, the minimal constant upper bound is $U=21$. With this bound, the check is $j  21$.\n- If a computed index $j$ is in $\\{0, 1, \\dots, 20\\}$, the check $j  21$ passes, and the valid jump is performed.\n- If a computed index $j$ is in $\\{52, 53, \\dots, 63\\}$, the check $j  21$ fails, and the program correctly branches to the default block, preventing an invalid jump.\nThis fulfills all requirements.", "answer": "$$\\boxed{21}$$", "id": "3632863"}, {"introduction": "A robust CFI mechanism must handle not only well-behaved call-return sequences but also complex, non-local control transfers like those caused by exception handling. This practice explores the critical interaction between a shadow stack—a mechanism to enforce return address integrity—and the stack unwinding process during an exception. You will determine the necessary actions to keep the shadow stack synchronized with the program's runtime state, ensuring the call-return discipline remains intact even when functions terminate abruptly [@problem_id:3632877].", "problem": "A compiler inserts Control Flow Integrity (CFI) instrumentation into a program and maintains a separate shadow stack to enforce well-bracketed matching of $call$ and $return$ control-flow edges. Consider the following scenario that involves structured exception handling. A function $\\mathsf{main}$ calls $\\mathsf{A}$, which in turn calls $\\mathsf{B}$; $\\mathsf{B}$ calls $\\mathsf{C}$. Inside $\\mathsf{A}$ there is a handler that catches exceptions thrown by $\\mathsf{C}$ and continues execution at a landing pad $\\mathsf{L_A}$ within $\\mathsf{A}$. When $\\mathsf{C}$ throws, the runtime unwinds past $\\mathsf{C}$ and $\\mathsf{B}$, executes their cleanups, and transfers control directly into $\\mathsf{A}$'s handler at $\\mathsf{L_A}$, bypassing the normal returns of $\\mathsf{C}$ and $\\mathsf{B}$.\n\nModel the control flow with a control-flow graph $\\mathsf{G} = (V, E)$ and partition $E$ into forward edges and return edges. Let $E_{\\text{call}} \\subseteq E$ denote call edges and $E_{\\text{return}} \\subseteq E$ denote return edges paired with call sites under normal execution. The call-return discipline corresponds to a well-bracketed property: if $\\sigma$ is the sequence of dynamic control transfers, the subsequence of edges from $E_{\\text{call}} \\cup E_{\\text{return}}$ forms a Dyck language over matched parentheses where calls are pushes and returns are pops. A shadow stack $S$ abstracts the expected return targets by storing, at each dynamic call, a label $\\ell$ for the unique return site permitted by the CFI policy. At a $return$, the CFI mechanism validates that control transfers to the label $\\ell$ at the top of $S$ and pops the top element.\n\nIn the exception scenario above, the hardware stack is unwound by the language runtime to reach $\\mathsf{L_A}$ in $\\mathsf{A}$, skipping the normal epilogues of $\\mathsf{C}$ and $\\mathsf{B}$. The CFI policy, to remain sound, must preserve the well-bracketed matching of $call$ and $return$ edges despite this non-local transfer. Which option best describes the required actions of a shadow stack integrated with CFI during such exception unwinding to ensure that subsequent $return$ edges still match their corresponding $call$ edges?\n\nA. Maintain a shadow stack $S$ of expected return labels; on each dynamic $call$, push the unique allowed return label onto $S$. During exception unwinding, for each frame removed from the hardware stack, pop one element from $S$ to discard the now-invalid expected return, and transfer control only to a landing pad that is allowed by the forward-edge CFI policy. After handler entry, allow a $return$ only if its target equals the label at the top of $S$.\n\nB. Leave the shadow stack $S$ unchanged during exception unwinding to preserve pre-exception call history; after the handler runs, permit the next $return$ as long as it targets any statically valid site, since the exception has logically terminated the skipped frames.\n\nC. Replace return-target checking with a check that the hardware stack pointer monotonically increases during unwinding; if this holds, consider the call-return matching preserved, because the physical stack already encodes the correct nesting.\n\nD. During exception unwinding, patch the code of all skipped frames to invalidate their $return$ instructions at runtime, thereby preventing mismatched returns; the shadow stack $S$ is not updated until the program returns from the handler.\n\nSelect the correct option. Your reasoning should start from the formal definitions of control-flow graphs, well-bracketed call-return discipline, and the shadow stack abstraction, and establish how exception-induced non-local control transfers must be reflected in $S$ to maintain the Dyck-language property of call-return edges under CFI enforcement. Assume that forward edges, including indirect jumps to landing pads, are separately validated against $\\mathsf{G}$ by the CFI policy, and focus on the correctness of matching for $E_{\\text{return}}$.", "solution": "The problem statement describes a scenario involving Control Flow Integrity (CFI) enforced via a shadow stack and its interaction with structured exception handling, which involves non-local control transfers. The core task is to determine the necessary actions on the shadow stack during stack unwinding to maintain the integrity of call-return matching.\n\n### Step 1: Extract Givens\n\n1.  **System Components**: A compiler that inserts CFI instrumentation and uses a shadow stack.\n2.  **Control Flow Model**: A control-flow graph $\\mathsf{G} = (V, E)$, with edges partitioned into forward edges and return edges. $E_{\\text{call}} \\subseteq E$ are call edges, and $E_{\\text{return}} \\subseteq E$ are return edges.\n3.  **CFI Invariant**: The dynamic sequence of edges from $E_{\\text{call}} \\cup E_{\\text{return}}$ must form a Dyck language, representing well-bracketed matching of calls and returns.\n4.  **Shadow Stack Mechanism**: A shadow stack $S$ stores labels $\\ell$ for permitted return sites.\n    -   On a dynamic `call`, a label $\\ell$ for the unique return site is pushed onto $S$.\n    -   On a `return`, the control transfer target must match the label $\\ell$ at the top of $S$. If it matches, $S$ is popped.\n5.  **Execution Scenario**:\n    -   A call chain: $\\mathsf{main} \\rightarrow \\mathsf{A} \\rightarrow \\mathsf{B} \\rightarrow \\mathsf{C}$.\n    -   Function $\\mathsf{C}$ throws an exception.\n    -   An exception handler exists within function $\\mathsf{A}$, with an entry point (landing pad) at $\\mathsf{L_A}$.\n    -   The runtime unwinds the stack, bypassing the normal returns of $\\mathsf{C}$ and $\\mathsf{B}$. This involves executing cleanup code for $\\mathsf{C}$ and $\\mathsf{B}$ and transferring control directly to $\\mathsf{L_A}$.\n6.  **Problem Question**: What actions must the shadow stack mechanism perform during this exception-induced unwinding to maintain the well-bracketed matching property for subsequent returns?\n7.  **Assumption**: Forward-edge CFI, including the jump to the landing pad $\\mathsf{L_A}$, is handled separately and correctly. The focus is on the correctness of matching for edges in $E_{\\text{return}}$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is evaluated against the validation criteria.\n\n1.  **Scientifically Grounded**: The problem is firmly grounded in established concepts from computer science, specifically compiler design and system security. Control Flow Integrity, shadow stacks, exception handling semantics, and stack unwinding are all well-defined and standard topics. The formalization using control-flow graphs and Dyck languages is standard practice in the analysis of program control flow.\n2.  **Well-Posed**: The problem is well-posed. It describes a specific, concrete scenario and asks for the necessary operation to maintain a clearly defined invariant (the Dyck language property). The context is sufficiently constrained to allow for a unique, logical conclusion.\n3.  **Objective**: The language is technical, precise, and objective. It avoids ambiguity and subjectivity by defining its terms formally.\n4.  **Flaw Checklist**:\n    -   **Scientific Unsoundness**: None. The model of computation is standard.\n    -   **Non-Formalizable**: None. The problem is already partially formalized and is amenable to further formal reasoning.\n    -   **Incomplete/Contradictory**: None. The setup is self-contained and consistent. The call chain, exception source, handler location, and the effect of unwinding are all clearly specified. The assumption to focus only on return-edge integrity is a valid simplification, not a flaw.\n    -   **Unrealistic/Infeasible**: None. This is a critical and realistic issue that real-world CFI implementations (like Microsoft's Control Flow Guard or Clang's CFI) must address to correctly handle exceptions in C++, for example.\n    -   **Ill-Posed**: None. A unique and stable solution can be derived from the principles.\n    -   **Pseudo-Profound/Trivial**: None. The problem requires a solid understanding of the interplay between program execution state (the call stack) and the security metadata (the shadow stack). It is not trivial.\n    -   **Outside Scientific Verifiability**: None. The reasoning is verifiable through formal logic and algorithmic analysis.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is scientifically sound, well-posed, and objective. I will now proceed to derive the solution.\n\n### Derivation of the Correct Mechanism\n\nThe fundamental principle of a shadow stack CFI mechanism is that the shadow stack $S$ must serve as an abstract model of the program's call stack, specifically regarding expected return targets. For the CFI guarantee to hold, the state of $S$ must remain synchronized with the logical nesting of active function calls.\n\n1.  **Initial State**: Let us trace the state of the hardware stack and the shadow stack $S$.\n    -   `main` calls `A`. The return address into `main`, let's call it $r_A$, is pushed onto the hardware stack. The CFI mechanism pushes a corresponding label, which we can also denote as $r_A$, onto the shadow stack $S$. State: $S = [r_A]$.\n    -   `A` calls `B`. The return address into `A`, $r_B$, is pushed onto the hardware stack. The shadow stack becomes $S = [r_A, r_B]$.\n    -   `B` calls `C`. The return address into `B`, $r_C$, is pushed onto the hardware stack. The shadow stack becomes $S = [r_A, r_B, r_C]$.\n\n    At this point, just before `C` throws, the hardware stack contains activation records for `main`, `A`, `B`, and `C`. The shadow stack $S$ contains the sequence of expected return targets for each active call. The top of $S$, $r_C$, corresponds to the expected return from `C` to `B`.\n\n2.  **Exception and Unwinding**: Function `C` throws an exception. The language runtime begins stack unwinding to find a handler.\n    -   The runtime inspects the frame for `C`. No handler is found. The frame must be unwound.\n    -   The runtime inspects the frame for `B`. No handler is found. The frame must be unwound.\n    -   The runtime inspects the frame for `A`. A handler is found. The unwinding stops here.\n\n    The \"unwinding\" of the frames for `C` and `B` means these function activations are being forcibly terminated. They will never execute their normal `return` instructions to the sites $r_C$ and $r_B$, respectively. The control flow path that led to these expected returns has been aborted.\n\n3.  **Maintaining the Invariant**: The CFI invariant is that the sequence of dynamic calls and returns forms a Dyck language. A `call` is an opening parenthesis `(`, and a `return` is a closing parenthesis `)`. At the point of the exception, the sequence of events on the shadow stack is `push(r_A)`, `push(r_B)`, `push(r_C)`, which corresponds to the string `(((`.\n    The exception unwinding effectively cancels the two most recent calls (`A` to `B`, and `B` to `C`) without corresponding returns. To maintain the well-bracketed property for future execution, the state of the shadow stack must reflect this cancellation. The two open parentheses `((` corresponding to these calls must be removed.\n\n4.  **Required Shadow Stack Action**: Since the activation records for `C` and `B` are removed from the hardware stack, their corresponding return targets $r_C$ and $r_B$ stored on the shadow stack are now invalid and must be discarded. The only way to do this in a stack data structure is to pop them.\n    -   As the frame for `C` is unwound, the CFI runtime must pop $r_C$ from $S$. $S$ becomes $[r_A, r_B]$.\n    -   As the frame for `B` is unwound, the CFI runtime must pop $r_B$ from $S$. $S$ becomes $[r_A]$.\n\n    This operation synchronizes the shadow stack $S$ with the hardware call stack. After unwinding, the active call stack consists of frames for `main` and `A`, and the shadow stack correctly contains just $r_A$.\n\n5.  **Post-Unwinding Execution**: Control is transferred to the landing pad $\\mathsf{L_A}$ within `A`. Execution of `A` resumes. When `A` eventually finishes and executes its `return` instruction, it will target $r_A$. The CFI mechanism checks this target against the top of the shadow stack, which is also $r_A$. The check passes, $r_A$ is popped from $S$, and control returns to `main`. The call-return pair for `A` is correctly matched, and the CFI invariant is preserved.\n\n### Evaluation of Options\n\n**A. Maintain a shadow stack $S$ of expected return labels; on each dynamic $call$, push the unique allowed return label onto $S$. During exception unwinding, for each frame removed from the hardware stack, pop one element from $S$ to discard the now-invalid expected return, and transfer control only to a landing pad that is allowed by the forward-edge CFI policy. After handler entry, allow a $return$ only if its target equals the label at the top of $S$.**\n-   This option accurately describes the process derived above. It correctly identifies that the shadow stack must be synchronized with the hardware stack during unwinding by popping elements for each unwound frame. This ensures that the state of $S$ correctly reflects the remaining active calls, preserving the call-return matching for subsequent returns. The mention of forward-edge CFI for the landing pad is consistent with a complete CFI system.\n-   **Verdict: Correct.**\n\n**B. Leave the shadow stack $S$ unchanged during exception unwinding to preserve pre-exception call history; after the handler runs, permit the next $return$ as long as it targets any statically valid site, since the exception has logically terminated the skipped frames.**\n-   This approach is fundamentally flawed. If $S$ is left unchanged, its state becomes $[r_A, r_B, r_C]$. When function `A` later returns to $r_A$, the CFI check will fail because it expects a return to $r_C$. This would cause a spurious CFI violation. The \"pre-exception call history\" is precisely what has been rendered partially invalid by the unwinding. Relaxing the CFI check to allow a return to \"any statically valid site\" would defeat the purpose of precise, dynamic call-return matching provided by the shadow stack.\n-   **Verdict: Incorrect.**\n\n**C. Replace return-target checking with a check that the hardware stack pointer monotonically increases during unwinding; if this holds, consider the call-return matching preserved, because the physical stack already encodes the correct nesting.**\n-   This option confuses two distinct security properties. Checking the stack pointer's movement verifies a property of the unwinding mechanism itself (i.e., that it is deallocating frames correctly), but it does not enforce control-flow integrity for the `return` instruction. The shadow stack's purpose is to validate the *target address* of a `return`, not the value of the stack pointer. This option improperly proposes abandoning the core CFI check for `return` edges.\n-   **Verdict: Incorrect.**\n\n**D. During exception unwinding, patch the code of all skipped frames to invalidate their $return$ instructions at runtime, thereby preventing mismatched returns; the shadow stack $S$ is not updated until the program returns from the handler.**\n-   This mechanism is both overly complex and ineffective. The `return` instructions in the skipped frames (`B` and `C`) will not be executed anyway, so patching them is pointless. The fundamental problem remains: the shadow stack $S$ is out of sync with the call stack. By not updating $S$, this approach suffers from the same flaw as option B, leading to a false positive CFI violation when the handler's function (`A`) returns.\n-   **Verdict: Incorrect.**\n\nBased on the rigorous derivation from the first principles of shadow stack operation and the goal of maintaining the Dyck language property, option A is the only one that correctly describes the necessary procedure.", "answer": "$$\\boxed{A}$$", "id": "3632877"}]}