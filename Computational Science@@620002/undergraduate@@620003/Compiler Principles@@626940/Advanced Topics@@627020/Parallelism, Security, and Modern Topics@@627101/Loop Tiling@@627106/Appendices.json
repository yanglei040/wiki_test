{"hands_on_practices": [{"introduction": "The effectiveness of loop tiling hinges on selecting a tile size that allows the working set of data to reside within the cache. This fundamental exercise challenges you to determine the optimal tile size by considering two primary constraints: the cache's total capacity and the potential for conflict misses arising from data layout and access patterns. Mastering this calculation is the first step toward harnessing tiling for performance, as it directly connects the abstract algorithm to the concrete realities of the hardware memory system [@problem_id:3653910].", "problem": "Consider the following doubly nested loop over a two-dimensional array stored in row-major order:\nfor i in 0..N-1:\n    for j in 0..M-1:\n        A[i][j] = A[i][j] + 1\n\nYou will apply loop tiling to the loop nest with a square tile of side length $T$, that is, you choose $T_i = T_j = T$ and iterate tiles as:\nfor i0 in 0..N-1 step T:\n    for j0 in 0..M-1 step T:\n        for ii in 0..T-1:\n            for jj in 0..T-1:\n                A[i0+ii][j0+jj] = A[i0+ii][j0+jj] + 1\n\nAssume the following concrete machine and data characteristics:\n- The array $A$ has dimensions $N \\times M$ with $N$ and $M$ both large enough that boundary tiles can be ignored. Take $M = 1024$.\n- The array $A$ elements are of size $E = 8$ bytes (doubles).\n- Memory layout is strictly row-major: the address of $A[i][j]$ is $A_{\\text{base}} + (i \\cdot M + j) \\cdot E$.\n- The Level-1 (L1) cache is direct-mapped with capacity $C = 32768$ bytes and cache line size $L = 64$ bytes. There are $S = C / L$ cache lines/sets.\n- The central processing unit (CPU) executes the inner loops in the order shown; within each tile, elements are visited with $j$ varying fastest. Assume no other arrays are accessed and the L1 cache is cold at the start of each tile but not perturbed by other activity while a tile is processed.\n\nYour goal is to choose the largest integer tile side length $T$ such that, while processing any single tile:\n1) The total cache footprint of the tile never exceeds the L1 cache capacity in terms of distinct cache lines that must be held simultaneously (so as to avoid capacity evictions within the tile), and\n2) The access pattern across the $T$ rows in the tile at a fixed column offset does not cause conflict thrashing in the direct-mapped L1 cache (so as to avoid conflict evictions within the tile).\n\nDerive these two constraints from first principles of row-major addressing and direct-mapped cache indexing, and compute the largest integer $T$ that satisfies both. Report only this $T$ as your final answer (no units). No rounding instructions are necessary because $T$ is an integer by definition.", "solution": "The goal is to find the largest integer tile side length $T$ that satisfies both a capacity constraint and a conflict constraint.\n\nFirst, we establish the relevant machine parameters from the problem description:\n- Cache Capacity: $C = 32768$ bytes\n- Cache Line Size: $L = 64$ bytes\n- Element Size (double): $E = 8$ bytes\n- Array Width (for row-major layout): $M = 1024$\n- The cache is direct-mapped, so the number of cache sets (or lines) is $S = C/L = 32768 / 64 = 512$.\n\n**Constraint 1: Cache Capacity**\n\nThe working set for a tile of size $T \\times T$ must fit entirely within the L1 cache to avoid capacity misses. The tile consists of $T$ contiguous row segments, each of length $T$.\n- The size of one row segment is $T \\times E = 8T$ bytes.\n- The number of cache lines required to store one row segment is $\\lceil \\frac{8T}{L} \\rceil = \\lceil \\frac{8T}{64} \\rceil = \\lceil \\frac{T}{8} \\rceil$.\n- The total number of distinct cache lines for the entire $T \\times T$ tile is the sum of lines for each of the $T$ row segments. A safe upper bound for the footprint is $T$ times the lines per segment.\n- The total footprint in cache lines must not exceed the total number of lines in the cache:\n$$ T \\cdot \\lceil \\frac{T}{8} \\rceil \\le S $$\n$$ T \\cdot \\lceil \\frac{T}{8} \\rceil \\le 512 $$\nWe test integer values of $T$ to find the maximum that satisfies this inequality.\n- For $T=64$: $64 \\cdot \\lceil \\frac{64}{8} \\rceil = 64 \\cdot 8 = 512$. Since $512 \\le 512$, $T=64$ is valid.\n- For $T=65$: $65 \\cdot \\lceil \\frac{65}{8} \\rceil = 65 \\cdot \\lceil 8.125 \\rceil = 65 \\cdot 9 = 585$. Since $585 > 512$, $T=65$ is invalid.\nThus, the capacity constraint implies $T \\le 64$.\n\n**Constraint 2: Conflict Misses**\n\nIn a direct-mapped cache, a conflict miss occurs when two memory locations map to the same cache line. The most likely source of conflicts is accessing elements in the same column across different rows of the tile, i.e., $A[i_0+k][j_0+jj]$ for $k=0, 1, ..., T-1$.\n- The address of an element $A[i][j]$ is given by $A_{\\text{base}} + (i \\cdot M + j) \\cdot E$.\n- The memory address stride between two consecutive elements in a column, $A[i][j]$ and $A[i+1][j]$, is:\n  $$ \\Delta_{\\text{addr}} = \\text{address}(A[i+1][j]) - \\text{address}(A[i][j]) = M \\cdot E = 1024 \\times 8 = 8192 \\text{ bytes} $$\n- The cache index for a memory address is calculated as $(\\text{address} / L) \\pmod S$.\n- The difference in cache indices for these two vertically adjacent elements is $(\\Delta_{\\text{addr}} / L) \\pmod S$.\n  $$ \\text{Index Stride} = (8192 / 64) \\pmod{512} = 128 \\pmod{512} = 128 $$\n- This means that for a fixed column, the cache lines for $A[i_0][j_0+jj]$, $A[i_0+1][j_0+jj]$, $A[i_0+2][j_0+jj]$, ... will map to cache indices $idx_0, (idx_0+128)\\pmod{512}, (idx_0+256)\\pmod{512}, (idx_0+384)\\pmod{512}, (idx_0+512)\\pmod{512}=idx_0, \\dots$.\n- The sequence of cache indices repeats every $S / \\gcd(\\text{Index Stride}, S)$ accesses.\n  $$ \\text{Period} = \\frac{512}{\\gcd(128, 512)} = \\frac{512}{128} = 4 $$\n- This means that only 4 distinct rows within a tile column can be accessed before a conflict occurs. To avoid conflict thrashing, the tile height $T$ must be less than or equal to this period.\n  $$ T \\le 4 $$\n\n**Conclusion**\n\nTo satisfy both constraints, $T$ must be no larger than the minimum of the bounds derived from capacity and conflict analysis.\n$$ T \\le \\min(T_{\\text{capacity}}, T_{\\text{conflict}}) $$\n$$ T \\le \\min(64, 4) $$\n$$ T \\le 4 $$\nThe largest integer tile side length $T$ that satisfies both conditions is 4.", "answer": "$$\n\\boxed{4}\n$$", "id": "3653910"}, {"introduction": "While performance is the goal, program correctness is a non-negotiable prerequisite for any optimization. Loop tiling is not universally applicable; it is only legal if it preserves the original program's data dependencies. This practice explores a scenario where a loop-carried dependence prevents straightforward tiling and introduces loop skewing, an essential transformation that adjusts the iteration space to make tiling legal. By analyzing dependence vectors, you will grasp the formal theory that underpins the correctness of advanced compiler transformations [@problem_id:3653878].", "problem": "Consider a perfectly nested two-loop program with iteration domain $\\{(i,j) \\mid 0 \\le i \\le N-1,\\ 0 \\le j \\le M-1\\}$ executed by the default lexicographic schedule $(i,j)$, and a single statement that induces a loop-carried dependence with distance vector $d=(1,0)$ measured in the $(i,j)$ space. Assume you wish to apply rectangular loop tiling (strip-mining) to both loops with tile sizes $T_i$ and $T_j$ and then execute tiles in lexicographic order of their tile indices. You may also apply a unimodular skew transformation of the form $j' = j + S i$ (with $S$ an integer) before tiling.\n\nStarting only from the foundational definitions of loop-carried dependence, legal schedules as topological orders of the dependence graph, and the effect of affine transformations on dependence distance vectors, answer the following:\n\n- Explain, using the dependence vector $d=(1,0)$ and the definition of legality of schedules, why tiling along $j$ alone does not require skewing to maintain legality, while tiling along $i$ in a two-dimensional band $(i,j)$ may require skewing of $j$ with respect to $i$ to satisfy a sufficient legality condition that all in-band dependence components are nonnegative and the component along the last tiled dimension is strictly positive.\n- Construct the minimal integer skew factor $S$ such that, after applying the skew $j' = j + S i$, tiling the band $(i,j')$ by rectangles of sizes $T_i$ and $T_j$ and executing tiles in lexicographic order of $(\\lfloor i/T_i \\rfloor,\\ \\lfloor j'/T_j \\rfloor)$ yields a schedule whose projection of the dependence onto the tiled band has nonnegative components and a strictly positive component along the last dimension.\n\nYour final answer must be the minimal integer $S$ and must be a single number. If you provide a numerical value, no rounding is required.", "solution": "A loop-carried dependence is represented by a distance vector $\\vec{d}$. A dependence exists from an iteration $\\vec{p}$ to an iteration $\\vec{q} = \\vec{p} + \\vec{d}$. A schedule is legal if, for every dependence, the source of the dependence $\\vec{p}$ is executed before its sink $\\vec{q}$. For a lexicographic schedule over an iteration vector $\\vec{x}$, this means that the schedule vector for $\\vec{q}$ must be lexicographically greater than the schedule vector for $\\vec{p}$. The given initial schedule is lexicographic on $(i,j)$, and the dependence distance vector is $\\vec{d} = (1,0)$. A dependence exists from iteration $(i,j)$ to $(i+1,j)$. The schedule vector difference is $(i+1,j) - (i,j) = (1,0)$, which is lexicographically positive. Thus, the original untiled loop is legal.\n\nLoop tiling partitions the iteration space into blocks (tiles) and adds outer loops to iterate over these tiles. A common tile execution schedule is lexicographic on the tile indices. A sufficient condition for the legality of tiling, as specified in the problem, is that any dependence vector must have all non-negative components, and the component corresponding to the last tiled dimension must be strictly positive.\n\n**Case 1: Tiling along $j$ alone**\nTiling only the $j$ dimension partitions the iteration space into vertical strips. The tiled band is one-dimensional, consisting of the $j$ loop. The dependence vector is $\\vec{d} = (1,0)$. The projection of this dependence onto the $(j)$ band is its $j$-component, which is $0$. A dependence whose vector projected onto the tiled band is the zero vector is an intra-tile dependence. It does not cross tile boundaries, so the execution order of tiles does not affect this dependence. The original lexicographical order of $(i,j)$ within each tile is sufficient to preserve legality. Thus, no skewing is required.\n\n**Case 2: Tiling the two-dimensional band $(i,j)$**\nHere, both loops are tiled. The tiled band is $(i,j)$, and the dependence vector within this band is $\\vec{d} = (1,0)$. We apply the problem's stated legality condition to this vector:\n1. All components must be non-negative. The components of $\\vec{d}$ are $d_i=1$ and $d_j=0$. Both $1 \\ge 0$ and $0 \\ge 0$ are true. This part of the condition is satisfied.\n2. The component along the last tiled dimension must be strictly positive. The last tiled dimension is $j$. The $j$-component of the dependence vector is $d_j=0$. This is not strictly positive ($0 \\not> 0$).\nThe condition is violated. Therefore, to satisfy this legality condition, the dependence vector must be transformed via skewing.\n\n**Constructing the Minimal Skew Factor**\nWe apply the skew transformation $j' = j+Si$. The transformation matrix $M_S$ maps original coordinates $(i,j)$ to new coordinates $(i,j')$.\n$$\n\\begin{pmatrix} i' \\\\ j' \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ S & 1 \\end{pmatrix} \\begin{pmatrix} i \\\\ j \\end{pmatrix}\n$$\nThe effect of this linear transformation on a dependence vector $\\vec{d}$ is multiplication by $M_S$. The original dependence vector is $\\vec{d} = (1,0)$. The new dependence vector $\\vec{d'}$ in the skewed $(i, j')$ space is:\n$$\n\\vec{d'} = M_S \\vec{d} = \\begin{pmatrix} 1 & 0 \\\\ S & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (1)(1) + (0)(0) \\\\ (S)(1) + (1)(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ S \\end{pmatrix}\n$$\nAfter skewing, we tile the two-dimensional band $(i,j')$. The dependence vector is $\\vec{d'} = (1,S)$. We now apply the legality condition to $\\vec{d'}$.\n1. All components must be non-negative:\n   - The first component is $1$, and $1 \\ge 0$ is always true.\n   - The second component is $S$, so we require $S \\ge 0$.\n2. The component along the last tiled dimension must be strictly positive:\n   - The last tiled dimension is $j'$. The corresponding component of the dependence vector is $S$.\n   - We require $S > 0$.\n\nCombining the conditions $S \\ge 0$ and $S > 0$ requires that $S$ must be a positive integer. The problem asks for the minimal integer skew factor. The set of positive integers is $\\{1, 2, 3, \\dots\\}$. The minimal value in this set is $1$.\nThus, the minimal integer skew factor is $S=1$.", "answer": "$$\n\\boxed{1}\n$$", "id": "3653878"}, {"introduction": "Once we can create correct tiles that fit in cache, the next step is to quantify their impact on performance. This exercise introduces the Roofline performance model, a powerful tool for reasoning about whether a program is limited by memory bandwidth or computational throughput. You will calculate the arithmetic intensity of a tiled kernel to determine the precise point at which tiling provides enough data reuse to shift the performance bottleneck from the memory system to the processor itself, achieving a compute-bound state [@problem_id:3653939].", "problem": "Consider a two-dimensional blur kernel applied to an $N \\times N$ array of double-precision values. Each output point is computed from a $3 \\times 3$ neighborhood (radius $r=1$), performing $9$ multiplies and $8$ adds per output, for a total of $f=17$ floating-point operations per output. Assume the following foundational facts:\n\n- Arithmetic intensity $AI$ is defined as the total floating-point operations divided by the total bytes transferred to or from main memory.\n- The Roofline performance model (RPM) characterizes the ridge point as $R = P_{\\text{peak}} / B$, where $P_{\\text{peak}}$ is the peak floating-point throughput (in floating-point operations per second) and $B$ is the sustainable main-memory bandwidth (in bytes per second). If $AI \\ge R$, the kernel is compute-bound; otherwise, it is memory-bound.\n- Double precision values occupy $8$ bytes.\n- Streaming stores are used, so each output write contributes exactly one $8$-byte store to memory without any read-for-ownership traffic.\n- Within a tile, all input data brought from memory are fully reused until the tileâ€™s outputs are computed; there is no reuse across different tiles, and capacity/conflict misses within the tile can be ignored because the tile footprint fits in cache.\n\nYou will compare two tiling strategies:\n\n1. Rectangular tiling: a tile computes $t_x \\times t_y$ outputs, loading the $r=1$ halo, so its unique input footprint is $(t_x+2)\\times(t_y+2)$ and it writes $t_x t_y$ outputs.\n2. Strip tiling (tiling only one dimension): a strip computes $s \\times 1$ outputs across a single row. To compute those $s$ outputs with $r=1$, the strip loads $3$ rows of input spanning $(s+2)$ columns (the middle row and its vertical neighbors), and writes $s$ outputs.\n\nAssume the machine has peak performance $P_{\\text{peak}} = 100 \\times 10^{9}$ floating-point operations per second and sustainable bandwidth $B = 200 \\times 10^{9}$ bytes per second. Using only the definitions above and careful accounting of reuse within each tile:\n\n- Derive the arithmetic intensity $AI_{\\text{strip}}(s)$ for the strip as a function of $s$.\n- Use the Roofline ridge point $R$ to determine the smallest real strip width $s$ such that $AI_{\\text{strip}}(s)$ equals $R$ exactly.\n\nProvide the final threshold value of $s$ as a single number. No rounding is required.", "solution": "The goal is to find the smallest real strip width, $s$, for which the given blur kernel becomes compute-bound. According to the Roofline performance model, this threshold is where the kernel's arithmetic intensity, $AI$, exactly equals the machine's ridge point, $R$.\n\nFirst, we calculate the ridge point $R$ using the provided machine parameters: peak floating-point throughput $P_{\\text{peak}} = 100 \\times 10^{9}$ FLOPS/s and sustainable main-memory bandwidth $B = 200 \\times 10^{9}$ bytes/s.\n\nThe ridge point $R$ is defined as:\n$$R = \\frac{P_{\\text{peak}}}{B}$$\nSubstituting the given values:\n$$R = \\frac{100 \\times 10^{9} \\text{ FLOPS/s}}{200 \\times 10^{9} \\text{ bytes/s}} = 0.5 \\frac{\\text{FLOPS}}{\\text{byte}}$$\n\nNext, we derive the arithmetic intensity for the strip tiling strategy, $AI_{\\text{strip}}(s)$, as a function of the strip width $s$. Arithmetic intensity is the ratio of total floating-point operations to total bytes transferred with main memory.\n$$AI_{\\text{strip}}(s) = \\frac{\\text{Total Floating-Point Operations}}{\\text{Total Bytes Transferred}}$$\n\nWe calculate the numerator and denominator for a strip tile that computes $s \\times 1$ outputs.\n\n**Total Floating-Point Operations:**\nThe strip computes $s$ output points. Each output requires $f=17$ floating-point operations.\n$$\\text{Total FLOPS} = s \\times f = 17s$$\n\n**Total Bytes Transferred:**\nThis is the sum of bytes read from memory (loads) and bytes written to memory (stores).\n- **Bytes Loaded:** To compute $s$ outputs in a row with a radius of $r=1$, the kernel must read $3$ rows of input data, each spanning $(s+2)$ columns. Each element is an 8-byte double.\n  $$\\text{Bytes Loaded} = 3 \\times (s+2) \\times 8 = 24(s+2) = 24s + 48$$\n- **Bytes Stored:** The tile computes $s$ output points. Each output is an 8-byte write.\n  $$\\text{Bytes Stored} = s \\times 8 = 8s$$\nThe total bytes transferred is the sum of loads and stores:\n$$\\text{Total Bytes Transferred} = (24s + 48) + 8s = 32s + 48$$\n\nNow we can write the expression for the arithmetic intensity of the strip tile:\n$$AI_{\\text{strip}}(s) = \\frac{17s}{32s + 48}$$\n\nTo find the threshold strip width $s$, we set the arithmetic intensity equal to the ridge point $R$:\n$$AI_{\\text{strip}}(s) = R$$\n$$\\frac{17s}{32s + 48} = 0.5$$\n\nWe solve this equation for $s$:\n$$17s = 0.5 \\times (32s + 48)$$\n$$17s = 16s + 24$$\n$$17s - 16s = 24$$\n$$s = 24$$\n\nThus, the smallest strip width $s$ for which the arithmetic intensity exactly equals the ridge point is 24. For any $s > 24$, the kernel will be compute-bound, and for any $s  24$, it will be memory-bound.", "answer": "$$ \\boxed{24} $$", "id": "3653939"}]}