{"hands_on_practices": [{"introduction": "One of the most powerful applications of whole-program analysis is enabling optimizations that are impossible to perform one function at a time. This first practice dives into interprocedural constant folding, a technique where the compiler deduces that an expression has a constant value even when its components are computed across different function calls. To achieve this, we will use a form of abstract interpretation with a range-based abstract domain, allowing us to create summaries of what each function does and compose these summaries at call sites [@problem_id:3682735]. This exercise is fundamental to understanding how a compiler can reason abstractly about program states to produce more efficient code.", "problem": "Consider a simple whole-program analysis task in compiler principles that aims to perform interprocedural constant folding for arithmetic expressions using range summaries. The program consists of four procedures and a main procedure with the following operational semantics written in terms of assignment statements over integers:\n\n- Procedure $f$ takes one integer parameter $a$ and executes:\n  $r_1 \\leftarrow a + a$, $r_2 \\leftarrow r_1 + 3$, and returns $r_2$.\n- Procedure $g$ takes one integer parameter $b$ and executes:\n  $t \\leftarrow b + 2$, $u \\leftarrow t + b$, and returns $u + 1$.\n- Procedure $h$ takes no parameters and returns $0$.\n- Procedure $k$ takes no parameters and returns $1$.\n- The main procedure executes:\n  $x \\leftarrow f(h())$, $y \\leftarrow g(k())$, and returns $x + y$.\n\nYour task is to formulate an interprocedural range analysis using abstract interpretation to enable constant folding. Start from core definitions of abstract interpretation with an interval abstract domain, map concrete semantics to abstract transfer functions, derive sound range summaries for procedures $f$, $g$, $h$, and $k$, and then compose these summaries across calls in the main procedure to obtain the abstract value of $x$, $y$, and finally $x + y$.\n\nAssume the interval abstract domain consists of all closed integer intervals $[l,u]$ with $l \\leq u$, ordered by the subset relation on their concretizations, and that arithmetic is standard integer arithmetic. Use only sound reasoning from the concrete semantics to derive each abstract transfer function; do not assume any pre-given shortcut formula. Show explicitly why the composed analysis yields singleton intervals for $x$ and $y$ and explain why this suffices for constant folding.\n\nWhat is the constant value to which the expression $x + y$ in the main procedure can be folded under this interprocedural range analysis? Express your final answer as an exact integer with no rounding.", "solution": "The user wants me to solve a problem about interprocedural constant folding.\n\n### Step 1: Extract Givens\n- Procedure $f(a)$: $r_1 \\leftarrow a + a$, $r_2 \\leftarrow r_1 + 3$, returns $r_2$.\n- Procedure $g(b)$: $t \\leftarrow b + 2$, $u \\leftarrow t + b$, returns $u + 1$.\n- Procedure $h()$: returns $0$.\n- Procedure $k()$: returns $1$.\n- Main procedure: $x \\leftarrow f(h())$, $y \\leftarrow g(k())$, returns $x + y$.\n- Abstract Domain: Closed integer intervals $[l, u]$ with $l \\leq u$.\n- Analysis Task: Perform interprocedural range analysis to find the constant value of $x+y$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a standard application of abstract interpretation, a well-established technique in compiler theory and static program analysis. It is well-posed, with a clear set of procedures and a defined analysis goal. The language is objective and precise. The problem is self-contained and provides all necessary information to derive a solution. No scientific laws are violated, and the setup is internally consistent.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\nThe problem requires an interprocedural range analysis based on abstract interpretation. We begin by defining the components of our abstract interpretation framework.\n\nThe abstract domain is the set of closed integer intervals, denoted as $\\mathcal{D} = \\{ [l, u] \\mid l, u \\in \\mathbb{Z}, l \\leq u \\} \\cup \\{ \\bot \\}$, where $\\mathbb{Z}$ is the set of integers and $\\bot$ represents the unreachable state. The concretization function $\\gamma: \\mathcal{D} \\to \\mathcal{P}(\\mathbb{Z})$ maps an abstract value to the set of concrete integer values it represents:\n$\\gamma([l, u]) = \\{ z \\in \\mathbb{Z} \\mid l \\leq z \\leq u \\}$\n$\\gamma(\\bot) = \\emptyset$\n\nWe must define the abstract transfer functions for the operations in the program. The only arithmetic operation is addition. For two variables with abstract values $[l_1, u_1]$ and $[l_2, u_2]$, their sum $v_1 + v_2$ can take any concrete value $z = z_1 + z_2$ where $z_1 \\in \\gamma([l_1, u_1])$ and $z_2 \\in \\gamma([l_2, u_2])$. The minimum possible value for $z$ is $l_1 + l_2$ and the maximum is $u_1 + u_2$. Therefore, the sound abstract transfer function for addition, denoted by $\\oplus$, is:\n$$[l_1, u_1] \\oplus [l_2, u_2] = [l_1 + l_2, u_1 + u_2]$$\nConstants are represented as singleton intervals. For example, the constant $c$ is represented by the abstract value $[c, c]$.\n\nNext, we derive the range summaries for each procedure. A summary is a function that maps the abstract values of the input parameters to the abstract value of the return result.\n\n**Procedure $h()$**:\nThis procedure takes no parameters and returns the constant $0$.\nThe concrete return value is the set $\\{0\\}$.\nThe most precise abstract value that contains this set is the interval $[0, 0]$.\nThus, the summary for $h$ is $S_h() = [0, 0]$.\n\n**Procedure $k()$**:\nThis procedure takes no parameters and returns the constant $1$.\nThe concrete return value is the set $\\{1\\}$.\nThe most precise abstract value is the interval $[1, 1]$.\nThus, the summary for $k$ is $S_k() = [1, 1]$.\n\n**Procedure $f(a)$**:\nThis procedure takes one integer parameter $a$. Let the abstract value for $a$ be $[l_a, u_a]$.\n1.  The first statement is $r_1 \\leftarrow a + a$.\n    The abstract value for $r_1$ is computed as $[l_a, u_a] \\oplus [l_a, u_a] = [l_a + l_a, u_a + u_a] = [2l_a, 2u_a]$.\n2.  The second statement is $r_2 \\leftarrow r_1 + 3$. The abstract value for the constant $3$ is $[3, 3]$.\n    The abstract value for $r_2$ is computed as $[2l_a, 2u_a] \\oplus [3, 3] = [2l_a + 3, 2u_a + 3]$.\n3.  The procedure returns $r_2$.\nThe summary for $f$ is a function of the input abstract state: $S_f([l_a, u_a]) = [2l_a + 3, 2u_a + 3]$.\n\n**Procedure $g(b)$**:\nThis procedure takes one integer parameter $b$. Let the abstract value for $b$ be $[l_b, u_b]$.\n1.  First statement: $t \\leftarrow b + 2$. The abstract value for $2$ is $[2, 2]$.\n    The abstract value for $t$ is $[l_b, u_b] \\oplus [2, 2] = [l_b + 2, u_b + 2]$.\n2.  Second statement: $u \\leftarrow t + b$.\n    The abstract value for $u$ is $[l_b + 2, u_b + 2] \\oplus [l_b, u_b] = [(l_b + 2) + l_b, (u_b + 2) + u_b] = [2l_b + 2, 2u_b + 2]$.\n3.  The procedure returns $u + 1$. The abstract value for $1$ is $[1, 1]$.\n    The abstract return value is $[2l_b + 2, 2u_b + 2] \\oplus [1, 1] = [2l_b + 3, 2u_b + 3]$.\nThe summary for $g$ is a function of the input abstract state: $S_g([l_b, u_b]) = [2l_b + 3, 2u_b + 3]$.\n\nNow, we analyze the `main` procedure using these summaries to determine the abstract values of $x$ and $y$.\n\n**Analysis of $x \\leftarrow f(h())$**:\n1.  The argument to $f$ is the result of the call $h()$. We use the summary for $h$ to find its abstract return value: $S_h() = [0, 0]$.\n2.  This abstract value $[0, 0]$ becomes the input for the analysis of $f$. We apply the summary for $f$ with the input abstract value $[0, 0]$ for the parameter $a$. So, we set $l_a = 0$ and $u_a = 0$.\n3.  The abstract value for $x$ is $S_f([0, 0]) = [2(0) + 3, 2(0) + 3] = [3, 3]$.\nThe abstract value for $x$ is the singleton interval $[3, 3]$.\n\n**Analysis of $y \\leftarrow g(k())$**:\n1.  The argument to $g$ is the result of the call $k()$. We use the summary for $k$: $S_k() = [1, 1]$.\n2.  This abstract value $[1, 1]$ becomes the input for the analysis of $g$. We apply the summary for $g$ with the input abstract value $[1, 1]$ for the parameter $b$. So, we set $l_b = 1$ and $u_b = 1$.\n3.  The abstract value for $y$ is $S_g([1, 1]) = [2(1) + 3, 2(1) + 3] = [2 + 3, 2 + 3] = [5, 5]$.\nThe abstract value for $y$ is the singleton interval $[5, 5]$.\n\n**Final Return Value**:\nThe main procedure returns the value of the expression $x + y$. We compute the abstract value of this sum using the abstract values we found for $x$ and $y$.\nAbstract value of $x+y$ is $[3, 3] \\oplus [5, 5] = [3 + 5, 3 + 5] = [8, 8]$.\n\nThe analysis concludes that the expression $x + y$ evaluates to the abstract value $[8, 8]$. A singleton interval $[c, c]$ signifies that the variable or expression can only hold the single concrete value $c$. In this case, $x$ is always $3$, $y$ is always $5$, and their sum $x+y$ is always $8$. This allows a compiler to perform constant folding, replacing the entire expression $x+y$ with the constant integer $8$.\n\nThe constant value to which the expression $x+y$ can be folded is therefore $8$.", "answer": "$$\n\\boxed{8}\n$$", "id": "3682735"}, {"introduction": "Our previous practice assumed we knew exactly which function was being called at every point in the program. However, in languages with higher-order functions—where functions can be passed as arguments or returned as results—the call graph itself is not static. This exercise challenges you to construct an approximation of the call graph using Control Flow Analysis (CFA), a cornerstone of analyzing modern functional and object-oriented programs. You will explore the trade-off between precision and cost by comparing a context-insensitive analysis (0-CFA) with a simple context-sensitive one (1-CFA), revealing how a compiler can map out the dynamic flow of a program [@problem_id:3682742].", "problem": "Consider the following small, first-order syntax for a call-by-value functional core language with higher-order functions. Abstractions are labeled by $L_i$ and call sites by $c_i$ solely for identification. The program is whole, closed, and has no side effects other than returning values. Arithmetic is primitive and irrelevant to the call-target approximation.\n\nProgram:\n- let id = (label $L_1$) fun x - x\n- let make_inc = (label $L_2$) fun n - (label $L_3$) fun y - y + n\n- let compose = (label $L_4$) fun f g - (label $L_5$) fun x - f ((call $c_7$) g x)  where the application of f is at (call $c_8$)\n- let chooser = (label $L_6$) fun f g cond - if cond then f else g\n- main:\n  - let inc1 = (call $c_1$) make_inc $1$\n  - let inc2 = (call $c_2$) make_inc $2$\n  - let comp = (call $c_3$) compose inc1 id\n  - let chosen = (call $c_4$) chooser inc2 inc1 input_cond\n  - let r1 = (call $c_5$) comp $10$\n  - let r2 = (call $c_6$) chosen $20$\n\nAssumptions:\n- The variable input_cond is an unknown Boolean input; the analysis must conservatively assume both branches at $L_6$ are possible.\n- A call graph edge is of the form $c \\to \\alpha$, where $c$ is a call-site label and $\\alpha$ is an abstract function. Under $k$-CFA (Control Flow Analysis), an abstract function is represented by a pair $(L_i, \\kappa)$, where $L_i$ is a lambda label and $\\kappa$ is a call string of length at most $k$ summarizing the most recent call sites on the dynamic call stack at the time the closure is allocated (not when it is called). For $0$-CFA, $\\kappa$ is the empty string $\\epsilon$ for all functions; for $1$-CFA, $\\kappa$ is the most recent call site at the closure’s allocation.\n- Top-level functions $L_1$, $L_2$, $L_4$, $L_6$ are allocated in a distinguished initial context and can be treated as singletons.\n- Whole-program analysis means all bindings are in scope for the analysis; arithmetic and condition evaluation do not affect call targets beyond flowing values to function parameters.\n\nTask:\nUsing only the core definitions of whole-program $k$-CFA as stated above (abstract closures by $(L_i,\\kappa)$ with call-string length $k$ at allocation time, monotone propagation of abstract values through bindings, and conservative treatment of unknown conditionals), derive the call-target approximations at the call sites $c_5$, $c_6$, $c_7$, and $c_8$ under $0$-CFA and under $1$-CFA. Then, select the option that correctly summarizes the resulting call-graph edges.\n\nOptions:\nA. Under $0$-CFA:\n- $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\nUnder $1$-CFA:\n- $c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_1)$.\n\nB. Under $0$-CFA:\n- $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\nUnder $1$-CFA:\n- $c_5 \\to (L_5@c_3)$, $c_6 \\to (L_3@c_1)$ only, $c_7 \\to L_1$, $c_8 \\to \\{(L_3@c_1), (L_3@c_2)\\}$.\n\nC. Under $0$-CFA:\n- $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to \\{L_1, L_3\\}$, $c_8 \\to L_3$.\nUnder $1$-CFA:\n- $c_5 \\to (L_5@c_5)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_3)$.\n\nD. Under $0$-CFA:\n- $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\nUnder $1$-CFA:\n- $c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_2)$.\n\nSelect the single best answer.", "solution": "The problem statement is a valid application of whole-program Control Flow Analysis ($k$-CFA), a standard technique in compiler theory. The definitions, program structure, and assumptions are self-contained, scientifically grounded, and well-posed. We proceed with the analysis.\n\nThe analysis hinges on tracking the set of abstract values that can be bound to each variable. An abstract value represents a function (closure). For $0$-CFA, an abstract value is simply the label $L_i$ of the function's definition (lambda abstraction). For $1$-CFA, an abstract value is a pair $(L_i, \\kappa)$, where $L_i$ is the label and $\\kappa$ is the call-site context of length $1$ where the closure was allocated. Top-level functions ($L_1, L_2, L_4, L_6$) are considered allocated in a special initial context, so for $1$-CFA their abstract value is effectively $(L_i, \\epsilon)$, which we denote as just $L_i$. A call graph edge $c \\to \\alpha$ means a call at site $c$ can target the abstract function $\\alpha$. Let $\\mathcal{V}(x)$ denote the set of abstract values for a variable $x$.\n\n### I. $0$-CFA Analysis ($k=0$)\nIn $0$-CFA, abstract values are just the lambda labels, e.g., $L_i$. Context is ignored.\n\n1.  **Initial Bindings**: The top-level functions are bound to their respective labels.\n    -   $\\mathcal{V}(\\text{id}) = \\{L_1\\}$\n    -   $\\mathcal{V}(\\text{make_inc}) = \\{L_2\\}$\n    -   $\\mathcal{V}(\\text{compose}) = \\{L_4\\}$\n    -   $\\mathcal{V}(\\text{chooser}) = \\{L_6\\}$\n\n2.  `let inc1 = (call $c_1$) make_inc $1$`: The function `make_inc` is called. Its abstract value is $L_2$. This call creates and returns a closure for the lambda labeled $L_3$. In $0$-CFA, the abstract value for this closure is simply $L_3$.\n    -   $\\mathcal{V}(\\text{inc1}) = \\{L_3\\}$.\n\n3.  `let inc2 = (call $c_2$) make_inc $2$`: This is identical to the creation of `inc1` from a $0$-CFA perspective. A call to `make_inc` ($L_2$) returns a closure for $L_3$.\n    -   $\\mathcal{V}(\\text{inc2}) = \\{L_3\\}$.\n\n4.  `let comp = (call $c_3$) compose inc1 id`: The function `compose` ($L_4$) is called. Its parameters `f` and `g` are bound to the abstract values of `inc1` and `id`, respectively. Inside this call, $\\mathcal{V}(f) = \\mathcal{V}(\\text{inc1}) = \\{L_3\\}$ and $\\mathcal{V}(g) = \\mathcal{V}(\\text{id}) = \\{L_1\\}$. The function returns a closure for the lambda labeled $L_5$.\n    -   $\\mathcal{V}(\\text{comp}) = \\{L_5\\}$. The returned closure captures the environment where $\\mathcal{V}(f) = \\{L_3\\}$ and $\\mathcal{V}(g) = \\{L_1\\}$.\n\n5.  `let chosen = (call $c_4$) chooser inc2 inc1 input_cond`: The function `chooser` ($L_6$) is called. Its parameters `f` and `g` are bound to the abstract values of `inc2` and `inc1`. Inside this call, $\\mathcal{V}(f) = \\mathcal{V}(\\text{inc2}) = \\{L_3\\}$ and $\\mathcal{V}(g) = \\mathcal{V}(\\text{inc1}) = \\{L_3\\}$. Due to the unknown `input_cond`, the analysis must be conservative and assume the result can be from either branch of the `if` statement. The set of returned values is $\\mathcal{V}(f) \\cup \\mathcal{V}(g) = \\{L_3\\} \\cup \\{L_3\\} = \\{L_3\\}$.\n    -   $\\mathcal{V}(\\text{chosen}) = \\{L_3\\}$.\n\nNow, we determine the call targets.\n-   **Call site $c_5$**: `(call $c_5$) comp $10$`. The function called is `comp`, and $\\mathcal{V}(\\text{comp}) = \\{L_5\\}$.\n    -   The call target is $L_5$. Thus, **$c_5 \\to L_5$**.\n-   **Call site $c_6$**: `(call $c_6$) chosen $20$`. The function called is `chosen`, and $\\mathcal{V}(\\text{chosen}) = \\{L_3\\}$.\n    -   The call target is $L_3$. Thus, **$c_6 \\to L_3$**.\n-   **Call site $c_7, c_8$**: These are inside the body of $L_5$, which is executed when `comp` is called at $c_5$. We use the environment captured when the $L_5$ closure was created (step 4).\n    -   In that environment, $\\mathcal{V}(g) = \\{L_1\\}$ and $\\mathcal{V}(f) = \\{L_3\\}$.\n    -   The expression is `f ((call $c_7$) g x)`.\n    -   For **call site $c_7$**, the function `g` is called. The target is given by $\\mathcal{V}(g)$. Thus, **$c_7 \\to L_1$**.\n    -   The outer call is `(call $c_8$) f ...`. For **call site $c_8$**, the function `f` is called. The target is given by $\\mathcal{V}(f)$. Thus, **$c_8 \\to L_3$**.\n\n**$0$-CFA Summary:** $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\n\n### II. $1$-CFA Analysis ($k=1$)\nIn $1$-CFA, an abstract value is a pair $(L_i, c_j)$ of a lambda label and its allocation-site context. We denote this $L_i@c_j$.\n\n1.  **Initial Bindings**: Same as $0$-CFA, top-level functions have an empty context.\n    -   $\\mathcal{V}(\\text{id}) = \\{L_1\\}$\n    -   $\\mathcal{V}(\\text{make_inc}) = \\{L_2\\}$\n    -   $\\mathcal{V}(\\text{compose}) = \\{L_4\\}$\n    -   $\\mathcal{V}(\\text{chooser}) = \\{L_6\\}$\n\n2.  `let inc1 = (call $c_1$) make_inc $1$`: The function `make_inc` ($L_2$) is called at site $c_1$. Inside this call, a closure for $L_3$ is allocated. The allocation context is the current call site, $c_1$.\n    -   $\\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$.\n\n3.  `let inc2 = (call $c_2$) make_inc $2$`: The function `make_inc` ($L_2$) is called at site $c_2$. A closure for $L_3$ is allocated in the context of $c_2$.\n    -   $\\mathcal{V}(\\text{inc2}) = \\{L_3@c_2\\}$.\n    -   Note that $\\mathcal{V}(\\text{inc1})$ and $\\mathcal{V}(\\text{inc2})$ are now distinct abstract values.\n\n4.  `let comp = (call $c_3$) compose inc1 id`: `compose` ($L_4$) is called at site $c_3$. It allocates a closure for $L_5$ in the context of $c_3$.\n    -   $\\mathcal{V}(\\text{comp}) = \\{L_5@c_3\\}$.\n    -   The captured environment for this closure $L_5@c_3$ binds `f` to $\\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$ and `g` to $\\mathcal{V}(\\text{id}) = \\{L_1\\}$.\n\n5.  `let chosen = (call $c_4$) chooser inc2 inc1 input_cond`: `chooser` ($L_6$) is called at $c_4$. The parameters are bound as $\\mathcal{V}(f) = \\mathcal{V}(\\text{inc2}) = \\{L_3@c_2\\}$ and $\\mathcal{V}(g) = \\mathcal{V}(\\text{inc1}) = \\{L_3@c_1\\}$. The conservative `if` returns the union of the abstract values from both branches.\n    -   $\\mathcal{V}(\\text{chosen}) = \\mathcal{V}(f) \\cup \\mathcal{V}(g) = \\{L_3@c_2\\} \\cup \\{L_3@c_1\\} = \\{L_3@c_1, L_3@c_2\\}$.\n\nNow, we determine the call targets.\n-   **Call site $c_5$**: `(call $c_5$) comp $10$`. The function is `comp`, with $\\mathcal{V}(\\text{comp}) = \\{L_5@c_3\\}$.\n    -   The call target is $L_5@c_3$. Thus, **$c_5 \\to (L_5@c_3)$**.\n-   **Call site $c_6$**: `(call $c_6$) chosen $20$`. The function is `chosen`, with $\\mathcal{V}(\\text{chosen}) = \\{L_3@c_1, L_3@c_2\\}$.\n    -   There are two possible targets. Thus, **$c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$**.\n-   **Call site $c_7, c_8$**: These are inside the body of the closure called at $c_5$, which is $L_5@c_3$. We use the environment captured when this specific closure was created (step 4).\n    -   In that environment, $\\mathcal{V}(f) = \\{L_3@c_1\\}$ and $\\mathcal{V}(g) = \\{L_1\\}$.\n    -   For **call site $c_7$**, `g` is called. The target is from $\\mathcal{V}(g)$. Thus, **$c_7 \\to L_1$**.\n    -   For **call site $c_8$**, `f` is called. The target is from $\\mathcal{V}(f)$. Thus, **$c_8 \\to (L_3@c_1)$**.\n\n**$1$-CFA Summary:** $c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_1)$.\n\n### III. Option Evaluation\n\n-   **Option A**:\n    -   Under $0$-CFA: $c_5 \\to L_5$, $c_6 \\to L_3$, $c_7 \\to L_1$, $c_8 \\to L_3$.\n    -   Under $1$-CFA: $c_5 \\to (L_5@c_3)$, $c_6 \\to \\{(L_3@c_1), (L_3@c_2)\\}$, $c_7 \\to L_1$, $c_8 \\to (L_3@c_1)$.\n    -   This perfectly matches our derived results for both $0$-CFA and $1$-CFA.\n    -   Verdict: **Correct**.\n\n-   **Option B**:\n    -   Under $1$-CFA, it claims $c_6 \\to (L_3@c_1)$ only. This is incorrect. The analysis of `chooser` shows that $\\mathcal{V}(\\text{chosen})$ contains both $L_3@c_1$ and $L_3@c_2$.\n    -   It also claims $c_8 \\to \\{(L_3@c_1), (L_3@c_2)\\}$. This is incorrect. The closure for `comp` ($L_5@c_3$) was created in a context where its parameter `f` was bound only to `inc1` ($L_3@c_1$).\n    -   Verdict: **Incorrect**.\n\n-   **Option C**:\n    -   Under $0$-CFA, it claims $c_7 \\to \\{L_1, L_3\\}$. This is incorrect. Inside the `comp` closure, the parameter `g` is unambiguously bound to `id` ($L_1$).\n    -   Under $1$-CFA, it claims $c_5 \\to (L_5@c_5)$. This is incorrect. The abstract value of a closure is determined by its allocation context, not its call context. The closure for `comp` ($L_5$) was allocated at call site $c_3$.\n    -   Verdict: **Incorrect**.\n\n-   **Option D**:\n    -   Under $1$-CFA, it claims $c_8 \\to (L_3@c_2)$. This is incorrect. The closure for `comp` ($L_5@c_3$) has a captured environment where `f` is bound to `inc1`, whose abstract value is $L_3@c_1$, not `inc2` ($L_3@c_2$).\n    -   Verdict: **Incorrect**.\n\nOnly Option A provides the correct call-target approximations for both analyses.", "answer": "$$\\boxed{A}$$", "id": "3682742"}, {"introduction": "While many analyses aim to compute properties for the entire program, some of the most practical tools are demand-driven, answering targeted questions like, \"What parts of the code could possibly affect the value of this variable right here?\" This practice introduces you to backward program slicing, a powerful technique for debugging, refactoring, and security analysis. Starting from a \"slicing criterion\"—a point of interest in the program—you will trace data and control dependencies backward to identify the minimal set of statements relevant to that criterion [@problem_id:3682778]. This exercise will equip you with a new way of thinking about program dependencies and their practical applications.", "problem": "Consider a small procedural program with global variables and four functions. The slicing criterion is the output value returned by the function $main$. You are asked to perform a backward slice under whole-program analysis, removing irrelevant functions and globals. Assume all functions terminate, there are no exceptions, and all calls are strict (the callee executes completely before the caller continues). Use standard interprocedural slicing semantics: statements are kept in the slice if and only if they have a data or control dependence on the slicing criterion. A data dependence exists if a statement defines a value subsequently used by a statement in the slice; a control dependence exists if a statement’s outcome determines whether a statement in the slice executes. Treat each of the following line items as a single source-level statement. A statement is one of the following: a global initialization (assignment), a function-local assignment (including arithmetic), a function call that appears on the right-hand side of an assignment, a conditional test (the “if” predicate itself), or a return. Do not count the “else” label as a separate statement.\n\nGlobals (each line is a separate statement):\n- $G1$: $A := 5$\n- $G2$: $B := 10$\n- $G3$: $C := 0$\n- $G4$: $D := 7$\n\nFunction $square(x)$:\n- $S1$: $r := x \\times x$\n- $S2$: $C := C + 1$\n- $S3$: return $r$\n\nFunction $noise(y)$:\n- $N1$: $B := B + y$\n- $N2$: return $B$\n\nFunction $choose(p)$:\n- $H1$: if $p  0$\n- $H2$: return $p$  (then-branch)\n- $H3$: return $D$  (else-branch)\n\nFunction $unusedGlobalFun()$:\n- $U1$: $A := A + B$\n- $U2$: return $A$\n\nFunction $main()$:\n- $M1$: $t1 := square(A)$\n- $M2$: $t2 := choose(t1 - B)$\n- $M3$: if $(t2 \\bmod 2 = 0)$\n- $M4$: $z := square(t2)$\n- $M5$: return $z - D$  (then-branch)\n- $M7$: $noise(t2)$      (else-branch)\n- $M8$: return $t2 + A$  (else-branch)\n\nPerform a whole-program backward slice with respect to the output of $main$ (the value returned by $main$). Remove from the slice any function and any global initialization that is irrelevant under data or control dependence to this slicing criterion. Count the number of statements that remain in the backward slice after removal. Express your final answer as an exact integer count. No rounding is required and no units are needed.", "solution": "The user wants me to perform a whole-program backward slice on a small procedural program.\n\n**1. Understand the Goal:**\nThe core task is to identify which statements in the program are relevant to the final output of the `main` function. This is a classic backward slicing problem. I need to count the number of statements that remain in the slice.\n\n**2. Define the Slicing Criterion:**\nThe problem states: \"The slicing criterion is the output value returned by the function $main$\". This means I need to consider *all* return statements in `main` as the starting points for the slice.\n- `M5: return z - D`\n- `M8: return t2 + A`\n\n**3. Define the Rules of Slicing:**\n- **Backward Slice:** I start from the criterion and work backward.\n- **Whole-program analysis:** I must cross function boundaries (interprocedural).\n- **Dependence:** A statement is in the slice if another statement *already in the slice* has a data or control dependence on it.\n    - **Data Dependence:** `S_j` depends on `S_i` if `S_i` defines a variable `v` and `S_j` uses `v`, and there's a path from `S_i` to `S_j` where `v` is not redefined.\n    - **Control Dependence:** `S_j` depends on `S_i` if `S_i` is a predicate that determines whether `S_j` executes.\n\n**4. Initial Set for the Slice:**\nThe slicing criterion consists of the two return statements in `main`.\n- `$M5$: return $z - D$`\n- `$M8$: return $t2 + A$`\n\nLet `S` be the set of statements in the slice.\nInitially, `S = {M5, M8}`.\n\n**5. Iterative Slicing Process:**\nI will work backward from the initial set, adding statements that `$M5$` and `$M8$` depend on. Then I'll add statements that those new statements depend on, and so on, until no new statements can be added.\n\n**Iteration 1: Analyze dependencies of `$M5$` and `$M8$`**\n\n*   **Analyze `$M5: \\text{return } z - D$`:**\n    *   **Data Dependence:** `$M5$` uses variables `$z$` and `$D$`.\n        *   Where is `$z$` defined? `$M4: z := \\text{square}(t2)$`. So, `$M4$` is in the slice.\n        *   Where is `$D$` defined? The global initialization `$G4: D := 7$`. So, `$G4$` is in the slice.\n    *   **Control Dependence:** `$M5$` is inside the `then` branch of the `if` statement `$M3: \\text{if } (t2 \\bmod 2 = 0)$`. Therefore, `$M5$` is control-dependent on `$M3$`. So, `$M3$` is in the slice.\n    *   **New statements for the slice:** `{$M4$, $G4$, $M3$}`.\n\n*   **Analyze `$M8: \\text{return } t2 + A$`:**\n    *   **Data Dependence:** `$M8$` uses variables `$t2$` and `$A$`.\n        *   Where is `$t2$` defined? `$M2: t2 := \\text{choose}(t1 - B)$`. So, `$M2$` is in the slice.\n        *   Where is `$A$` defined? The global initialization `$G1: A := 5$`. So, `$G1$` is in the slice.\n    *   **Control Dependence:** `$M8$` is inside the `else` branch of the `if` statement `$M3: \\text{if } (t2 \\bmod 2 = 0)$`. Therefore, `$M8$` is control-dependent on `$M3$`. So, `$M3$` is in the slice (it's already added, but this confirms its importance).\n    *   **New statements for the slice:** `{$M2$, $G1$}`.\n\n*   **Current Slice `S`:** `{$M5$, $M8$, $M4$, $G4$, $M3$, $M2$, $G1$}`.\n\n**Iteration 2: Analyze dependencies of newly added statements (`$M4$`, `$M3$`, `$M2$`)**\n\n*   **Analyze `$M4: z := \\text{square}(t2)$`:**\n    *   **Data Dependence:** `$M4$` uses the variable `$t2$` and calls the function `square`.\n        *   Where is `$t2$` defined? `$M2: t2 := \\text{choose}(t1 - B)$`. `$M2$` is already in the slice.\n        *   The call to `square(t2)` means we must now slice the `square` function with respect to its return value.\n        *   Let's analyze `square` with its return value (`$r$`) as the criterion.\n            *   Start with `$S3: \\text{return } r$`. `$S3$` is in the slice.\n            *   `$S3$` uses `$r$`. `$r$` is defined at `$S1: r := x \\times x$`. So, `$S1$` is in the slice.\n            *   `$S1$` uses `$x$`. `$x$` is the formal parameter of `square`. The actual parameter at the call site `$M4$` is `$t2$`. Since `$t2$`'s definition is already being tracked (`$M2$`), the dependency flows through the parameter passing.\n            *   What about `$S2: C := C + 1$`? This statement modifies the global `$C$` but does not affect the return value `$r$`. The return value `$r$` does not depend on `$C$`. So `$S2$` is NOT in the slice. The global initialization `$G3: C := 0$` is also NOT in the slice (unless something else needs it, which seems unlikely).\n        *   **New statements for the slice from `square`:** `{$S3$, $S1$}`.\n\n*   **Analyze `$M3: \\text{if } (t2 \\bmod 2 = 0)$`:**\n    *   **Data Dependence:** `$M3$` uses the variable `$t2$`.\n        *   Where is `$t2$` defined? `$M2: t2 := \\text{choose}(t1 - B)$`. `$M2$` is already in the slice.\n    *   **No new statements added from `$M3$`'s dependencies.**\n\n*   **Analyze `$M2: t2 := \\text{choose}(t1 - B)$`:**\n    *   **Data Dependence:** `$M2$` uses variables `$t1$` and `$B$` and calls the function `choose`.\n        *   Where is `$t1$` defined? `$M1: t1 := \\text{square}(A)$`. So, `$M1$` is in the slice.\n        *   Where is `$B$` defined? The global initialization `$G2: B := 10$`. So, `$G2$` is in the slice.\n        *   The call to `choose(t1 - B)` means we must slice the `choose` function with respect to its return value.\n        *   Let's analyze `choose` with its return value as the criterion. `choose` has two return statements.\n            *   Start with `{$H2: \\text{return } p, $H3: \\text{return } D$}`. So, `{$H2$, $H3$}` are in the slice.\n            *   `$H2$` uses `$p$`. `$p$` is the formal parameter. Its definition is tracked via the call site.\n            *   `$H3$` uses `$D$`. `$D$` is a global variable. Its definition is `$G4: D := 7$`. `$G4$` is already in the slice.\n            *   `$H2$` and `$H3$` are control-dependent on the predicate `$H1: \\text{if } p  0$`. So, `$H1$` is in the slice.\n            *   `$H1$` uses `$p$`. `$p$` is the formal parameter.\n        *   **New statements for the slice from `choose`:** `{$H2$, $H3$, $H1$}`.\n\n*   **Current Slice `S`:** `{$M5$, $M8$, $M4$, $G4$, $M3$, $M2$, $G1$, $S3$, $S1$, $M1$, $G2$, $H2$, $H3$, $H1$}`.\n\n**Iteration 3: Analyze dependencies of newly added statements (`$M1$`)**\n\n*   **Analyze `$M1: t1 := \\text{square}(A)$`:**\n    *   **Data Dependence:** `$M1$` uses variable `$A$` and calls the function `square`.\n        *   Where is `$A$` defined? `$G1: A := 5$`. `$G1$` is already in the slice.\n        *   The call to `square(A)` means we must again slice the `square` function with respect to its return value. We already did this when analyzing `$M4$` and found that statements `{$S1$, $S3$}` are relevant. These are already in the slice. This call site just confirms their relevance. The parameter `$A$` is used, and its definition `$G1$` is already in the slice.\n    *   **No new statements added from `$M1$`'s dependencies.**\n\nThe iterative process has stabilized. No further statements can be added to the slice.\n\n**Final Review of All Program Statements**\n\nWe now classify every statement as either IN or OUT of the slice.\n\n*   **Globals:**\n    *   `$G1: A := 5$`: **IN**. The value of `$A$` is used in `$M8$` and passed to `square` in `$M1$`, which influences `$t1$`, `$t2$`, and thus both return paths.\n    *   `$G2: B := 10$`: **IN**. The value of `$B$` is used in `$M2$` to calculate the argument to `choose`, which determines `$t2$`.\n    *   `$G3: C := 0$`: **OUT**. It initializes global `$C$`, which is only modified in `$S2$`. Since `$S2$` does not affect the return value of `square`, `$S2$` is not in the slice, and neither is `$G3$`.\n    *   `$G4: D := 7$`: **IN**. The value of `$D$` is used in the return statement `$M5$` and the return statement `$H3$`, both of which are in the slice.\n\n*   **Function `square(x)`:**\n    *   `$S1: r := x \\times x$`: **IN**. It defines `$r$`, which is used in the return statement `$S3$`.\n    *   `$S2: C := C + 1$`: **OUT**. It modifies the global `$C$`, but this has no data or control influence on the return value `$r` or any other statement in the slice.\n    *   `$S3: \\text{return } r$`: **IN**. The return value is used by the callers `$M1$` and `$M4$`, whose results are essential for the final output.\n\n*   **Function `noise(y)`:**\n    *   `$M7: \\text{noise}(t2)$` is the call site. This statement is in the `else` branch of `$M3$`, which leads to the return statement `$M8: \\text{return } t2 + A$`. The function `noise` modifies the global `$B$`. However, the value of `$B$` is not used again by any statement in the slice after `$M7$`. Specifically, `$M8$` does not use `$B$`. Therefore, the side effect of `noise` is irrelevant to the slicing criterion. `$M7$` is **OUT** of the slice. Consequently, the entire `noise` function (`$N1$`, `$N2$`) is irrelevant and **OUT**.\n\n*   **Function `choose(p)`:**\n    *   `$H1: \\text{if } p  0$`: **IN**. It determines which value is returned by `choose`, directly affecting `$t2$`.\n    *   `$H2: \\text{return } p$`: **IN**. It is one of the return paths of the function.\n    *   `$H3: \\text{return } D$`: **IN**. It is the other return path.\n    The entire function `choose` is relevant because its return value dictates the value of `$t2$`, which is critical for the control flow and data flow in `main`.\n\n*   **Function `unusedGlobalFun()`:**\n    *   This function is never called in the program. It is therefore irrelevant and all its statements (`$U1$`, `$U2$`) are **OUT**.\n\n*   **Function `main()`:**\n    *   `$M1: t1 := \\text{square}(A)$`: **IN**. It defines `$t1$`, which is used in `$M2$`.\n    *   `$M2: t2 := \\text{choose}(t1 - B)$`: **IN**. It defines `$t2$`, used in `$M3$`, `$M4$`, and `$M8$`.\n    *   `$M3: \\text{if } (t2 \\bmod 2 = 0)$`: **IN**. It controls which of the two return paths in `main` is executed.\n    *   `$M4: z := \\text{square}(t2)$`: **IN**. It defines `$z$`, which is used in the return statement `$M5$`.\n    *   `$M5: \\text{return } z - D$`: **IN**. It is part of the slicing criterion.\n    *   `$M7: \\text{noise}(t2)$`: **OUT**. As explained above, its side effect is irrelevant to the slice.\n    *   `$M8: \\text{return } t2 + A$`: **IN**. It is part of the slicing criterion.\n\n**Final Count of Statements in the Slice**\n\nWe sum the number of statements that were included in the slice:\n*   Globals: `$G1$`, `$G2$`, `$G4$` (3 statements)\n*   Function `square`: `$S1$`, `$S3$` (2 statements)\n*   Function `choose`: `$H1$`, `$H2$`, `$H3$` (3 statements)\n*   Function `main`: `$M1$`, `$M2$`, `$M3$`, `$M4$`, `$M5$`, `$M8$` (6 statements)\n\nTotal count = $3 + 2 + 3 + 6 = 14$.", "answer": "$$\n\\boxed{14}\n$$", "id": "3682778"}]}