{"hands_on_practices": [{"introduction": "Resolving indirect calls in languages like C is a fundamental challenge for compilers, especially when function pointers are involved. This exercise tasks you with performing a points-to analysis, a classic technique to determine the set of possible functions a pointer might refer to at runtime [@problem_id:3625920]. By systematically applying a set of inclusion-based rules to a program fragment involving structures and pointer assignments, you will build the necessary information to construct a sound and conservative call graph.", "problem": "A compiler must build a conservative call graph for a C program that uses function pointers stored in and accessed through structures. Assume the analysis is a whole-program, flow-insensitive, context-insensitive, inclusion-based points-to analysis (often called Andersen-style). The analysis is field-sensitive for structures (each distinct structure field of each distinct allocation site or variable produces its own abstract field location), but array elements are modeled in a collapsed fashion as a single abstract array element location per array variable. Function names are modeled as abstract function-label locations. The analysis obeys the following foundational rules, which are treated as core definitions for this problem:\n\n- Address-of: if an assignment takes the form x = &y, then the abstract location for y is included in the points-to set $\\mathrm{Pt}(x)$.\n- Copy: if an assignment takes the form x = y, then $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(y)$.\n- Store through a pointer to a structure field: if the assignment is x->f = y, then for each abstract location $o \\in \\mathrm{Pt}(x)$, the relation $\\mathrm{Pt}(o.f) \\supseteq \\mathrm{Pt}(y)$ holds. If $y$ is a function name, include that function label in $\\mathrm{Pt}(o.f)$.\n- Load from a structure field: if the assignment is x = y->f, then for each abstract location $o \\in \\mathrm{Pt}(y)$, the relation $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(o.f)$ holds.\n- Collapsed arrays: for an array variable arr, all element writes `arr[i] = y` update a single abstract element location arr$[\\ast]$, so that $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(y)$; reads `x = arr[i]` load from $\\mathrm{Pt}(\\text{arr}[\\ast])$.\n\nA call graph includes a directed edge from an indirect call site to a function label for every function in the points-to set of the function-pointer expression at that site, according to the above points-to semantics. Two edges that share the same callee but arise from different call sites are counted as distinct edges. Let the call sites be identified as $c_{1}$ and $c_{2}$.\n\nConsider the following C program fragment (types and statements shown; other code such as function bodies is irrelevant to the analysis):\n\n```c\ntypedef void (*F)(int);\n\nvoid A(int x) {}\nvoid B(int x) {}\nvoid C(int x) {}\nvoid D(int x) {}\n\nstruct S { F f; };\nstruct T { struct S *ps; F g; };\n\nint main() {\n  struct S s1, s2, s3;\n  struct T t1, t2;\n  struct S *p, *q;\n  struct T *pt;\n  struct S *arr[2];\n\n  s1.f = A;\n  s2.f = B;\n  s3.f = C;\n\n  t1.ps = \n  t2.ps = \n\n  p = \n  q = p;\n  q->f = B;\n\n  t1.g = D;\n\n  arr[0] = \n  arr[1] = t2.ps;\n\n  if (/* unknown */) { pt =  } else { pt =  }\n\n  /* c1 */ pt->ps->f(/* arg */);\n  /* c2 */ arr[i]->f(/* arg */);\n}\n```\n\nUsing only the foundational rules stated above, derive the least conservative points-to information necessary to resolve the potential targets of the two indirect call sites $c_{1}$ and $c_{2}$:\n- $c_{1}$ is the call `pt->ps->f(...)`\n- $c_{2}$ is the call `arr[i]->f(...)`\n\nTreat the array `arr` as collapsed into a single abstract element location arr$[\\ast]$, and assume $i$ is unknown at compile time. Also assume that no implicit null or uninitialized values are added by the analysis; the only abstract locations present are those introduced by the assignments in the program and the function labels.\n\nFrom first principles, compute the total number of distinct indirect call graph edges implied by the analysis, counting edges as ordered pairs $(c_{j}, \\text{callee})$. Provide your final answer as a single integer with exact value (no rounding).", "solution": "The problem requires the construction of a conservative call graph for a given C program fragment. The analysis method is specified as a whole-program, flow-insensitive, context-insensitive, inclusion-based points-to analysis. This is a standard Andersen-style analysis. The analysis is further defined as being field-sensitive for structures but field-insensitive (collapsed) for arrays.\n\nFirst, we must validate the problem statement.\n1.  **Extract Givens**: The problem provides a C code fragment, a set of specific rules for a points-to analysis (address-of, copy, store, load, array collapsing), and a definition for constructing call graph edges from points-to sets. The goal is to compute the total number of indirect call graph edges from two specified call sites, $c_1$ and $c_2$.\n2.  **Validate**: The problem is scientifically grounded in the well-established field of compiler static analysis. The rules for Andersen-style analysis are standard. The problem is well-posed, with all necessary information provided to derive a unique solution based on the given rules. The language is objective and precise. The problem does not violate any of the invalidity criteria.\n3.  **Verdict**: The problem is valid.\n\nWe now proceed with the solution. The analysis is flow-insensitive, so we process all assignments in the `main` function as a single set of constraints that must hold simultaneously. The points-to relations are inclusion-based, meaning that the points-to set of an abstract location, denoted $\\mathrm{Pt}(L)$, only grows as constraints are added.\n\nLet us define the abstract locations. The stack-allocated structure variables `s1`, `s2`, `s3`, `t1`, and `t2` are distinct abstract locations, which we will denote by $s_1, s_2, s_3, t_1, t_2$. Their fields produce distinct abstract field locations, e.g., $s_1.f$, $t_1.ps$. The function names `A`, `B`, `C`, `D` represent distinct function-label locations. Pointer variables `p`, `q`, `pt` have points-to sets $\\mathrm{Pt}(p)$, $\\mathrm{Pt}(q)$, $\\mathrm{Pt}(pt)$. The array `arr` is collapsed into a single abstract element location $\\text{arr}[\\ast]$.\n\nWe derive the points-to sets by applying the given rules to each assignment statement:\n1.  `s1.f = A;`: This creates the relation $A \\in \\mathrm{Pt}(s_1.f)$.\n2.  `s2.f = B;`: This creates the relation $B \\in \\mathrm{Pt}(s_2.f)$.\n3.  `s3.f = C;`: This creates the relation $C \\in \\mathrm{Pt}(s_3.f)$.\n4.  `t1.ps = `: The address-of rule implies $s_1 \\in \\mathrm{Pt}(t_1.ps)$. Note that `t1.ps` is a field, not a pointer variable, so it directly contains the abstract location. More precisely, an assignment `x.f = ` implies $y \\in \\mathrm{Pt}(x.f)$.\n5.  `t2.ps = `: Similarly, $s_2 \\in \\mathrm{Pt}(t_2.ps)$.\n6.  `p = `: The address-of rule implies $s_1 \\in \\mathrm{Pt}(p)$.\n7.  `q = p;`: The copy rule states $\\mathrm{Pt}(q) \\supseteq \\mathrm{Pt}(p)$. From the previous step, this implies $s_1 \\in \\mathrm{Pt}(q)$.\n8.  `q->f = B;`: This is a store-through-pointer rule. For each abstract location $o \\in \\mathrm{Pt}(q)$, we add the constraint $\\mathrm{Pt}(o.f) \\supseteq \\{B\\}$. Since $\\mathrm{Pt}(q) = \\{s_1\\}$, this means $\\mathrm{Pt}(s_1.f) \\supseteq \\{B\\}$. Because the analysis is inclusion-based, we combine this with constraint (1), yielding $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$.\n9.  `t1.g = D;`: This implies $D \\in \\mathrm{Pt}(t_1.g)$. This information is not used for the target call sites but is part of the complete analysis state.\n10. `arr[0] = `: The collapsed array rule implies $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_3\\}$.\n11. `arr[1] = t2.ps;`: This is a copy from a structure field to a collapsed array element. It translates to the constraint $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(t_2.ps)$. From constraint (5), $\\mathrm{Pt}(t_2.ps)=\\{s_2\\}$, so we have $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_2\\}$. Combining with (10), we get $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$.\n12. `if (/*...*/) { pt =  } else { pt =  }`: Flow-insensitivity means both branches are considered. This gives two constraints: $t_1 \\in \\mathrm{Pt}(pt)$ and $t_2 \\in \\mathrm{Pt}(pt)$. Thus, $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$.\n\nSummary of the final points-to sets relevant to the call sites:\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$\n- $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$\n- $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$\n- $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$\n- $\\mathrm{Pt}(s_2.f) = \\{B\\}$\n- $\\mathrm{Pt}(s_3.f) = \\{C\\}$\n- $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$\n\nNow we resolve the call targets for each call site.\n\n**Call Site $c_1$: `pt->ps->f(/* arg */)`**\nThe function being invoked is determined by the points-to set of the expression `pt->ps->f`. We resolve this expression step-by-step.\nFirst, we find the set of locations pointed to by `pt->ps`. Let's use a temporary abstract pointer `temp_1`. The expression `temp_1 = pt->ps` corresponds to a load `x = y->f`, where $x$ is `temp_1`, $y$ is `pt`, and $f$ is `ps`.\nThe rule is: for each $o \\in \\mathrm{Pt}(pt)$, we have $\\mathrm{Pt}(\\text{temp}_1) \\supseteq \\mathrm{Pt}(o.ps)$.\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$.\n- For $o = t_1$, we add $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$ to $\\mathrm{Pt}(\\text{temp}_1)$.\n- For $o = t_2$, we add $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$ to $\\mathrm{Pt}(\\text{temp}_1)$.\n- Thus, the set of locations for `pt->ps` is $\\mathrm{Pt}(\\text{temp}_1) = \\{s_1, s_2\\}$.\n\nNext, we resolve the call target `temp_1->f`. The set of potential callees is the union of the points-to sets of the `.f` field for each location in $\\mathrm{Pt}(\\text{temp}_1)$.\n- For location $s_1 \\in \\mathrm{Pt}(\\text{temp}_1)$, the callees are from $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$.\n- For location $s_2 \\in \\mathrm{Pt}(\\text{temp}_1)$, the callees are from $\\mathrm{Pt}(s_2.f) = \\{B\\}$.\nThe total set of targets for $c_1$ is the union $\\{A, B\\} \\cup \\{B\\} = \\{A, B\\}$.\nThis results in two distinct call graph edges: $(c_1, A)$ and $(c_1, B)$.\n\n**Call Site $c_2$: `arr[i]->f(/* arg */)`**\nThe function is determined by the points-to set of `arr[i]->f`.\nFirst, we resolve `arr[i]`. Let this be represented by a temporary pointer `temp_2`. This is an array load `x = arr[i]`, where $x$ is `temp_2`.\nThe rule for collapsed arrays is $\\mathrm{Pt}(\\text{temp}_2) \\supseteq \\mathrm{Pt}(\\text{arr}[\\ast])$.\n- We have determined that $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$.\n- Therefore, the set of locations for `arr[i]` is $\\mathrm{Pt}(\\text{temp}_2) = \\{s_2, s_3\\}$.\n\nNext, we resolve the call target `temp_2->f`. The callees are the union of the `.f` field's points-to sets for each location in $\\mathrm{Pt}(\\text{temp}_2)$.\n- For location $s_2 \\in \\mathrm{Pt}(\\text{temp}_2)$, the callees are from $\\mathrm{Pt}(s_2.f) = \\{B\\}$.\n- For location $s_3 \\in \\mathrm{Pt}(\\text{temp}_2)$, the callees are from $\\mathrm{Pt}(s_3.f) = \\{C\\}$.\nThe total set of targets for $c_2$ is the union $\\{B\\} \\cup \\{C\\} = \\{B, C\\}$.\nThis results in two distinct call graph edges: $(c_2, B)$ and $(c_2, C)$.\n\n**Total Number of Edges**\nThe problem specifies that edges from different call sites are distinct even if the callee is the same. The distinct edges are:\n1.  $(c_1, A)$\n2.  $(c_1, B)$\n3.  $(c_2, B)$\n4.  $(c_2, C)$\n\nThe total number of distinct indirect call graph edges is the sum of the number of edges from each call site: $2 + 2 = 4$.", "answer": "$$\\boxed{4}$$", "id": "3625920"}, {"introduction": "Object-oriented languages introduce dynamic dispatch, where the target of a method call depends on the object's runtime type. This practice explores call graph construction in this context, contrasting statically resolved `super` calls with dynamically resolved `this` calls [@problem_id:3625899]. You will apply Rapid Type Analysis (RTA), a technique that leverages information about which classes are instantiated in the program, to precisely determine the potential callees for virtual method invocations.", "problem": "Consider a Java-like, single-inheritance, nominally typed, statically typed, object-oriented language in which all instance methods are virtual, and expressions of the form `super.m()` use the immediate superclass resolution rule. Assume whole-program, context-insensitive, flow-insensitive Rapid Type Analysis (RTA), defined as follows: given a call site inside an instance method body, the receiver type set $T(\\text{this})$ at that site is the set of runtime classes that may dynamically invoke the enclosing method in the analyzed program. For a virtual call `this.m()`, the call graph adds one edge to the unique target that the dynamic lookup would select for each receiver class $R \\in T(\\text{this})$; if different receivers map to the same target method, duplicate edges are merged. For a supercall `super.m()`, the call graph adds a single edge to the method body defined in the immediate superclass of the class in which the call lexically appears; this target does not depend on $T(\\text{this})$.\n\nThe class hierarchy and methods are as follows (method bodies are irrelevant except where they contain calls):\n- Class A defines instance methods `m()`, `n()`, and `k()`.\n- Class B extends A and overrides `m()` and `n()`. Class B additionally defines an instance method `t()` whose body contains, in this order, the four call sites: `super.m()`, `this.m()`, `super.n()`, `this.n()`.\n- Class C extends B and overrides `m()` but does not override `n()`.\n- Class D extends B and overrides `n()` but does not override `m()`.\n\nThe entry point performs allocations and calls as follows:\n- Allocate one instance of B and one instance of C.\n- Invoke `t()` on both allocated instances (for example, via variables of static type B).\n- No instance of D is ever allocated, and there are no other allocations or calls.\n\nUsing only the above semantics and the fundamental dynamic method lookup rule for single inheritance—namely, that a virtual call on a receiver of dynamic class $R$ resolves to the most specific override of the method declared in the static receiver type found by searching $R$, then its superclass, and so on—construct the call graph edges contributed by the four call sites in the body of `B.t()`. Compute the total number of distinct call graph edges added by these four call sites under the specified Rapid Type Analysis. Express your answer as a single integer. No rounding is required.", "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed.\n\n### Step 1: Extract Givens\n- **Language and Semantics**: A Java-like, single-inheritance, nominally typed, statically typed, object-oriented language. All instance methods are virtual. `super.m()` calls resolve to the method in the immediate superclass of the class containing the call site.\n- **Analysis Type**: Whole-program, context-insensitive, flow-insensitive Rapid Type Analysis (RTA).\n- **RTA Definition for Virtual Calls**: For a virtual call `this.m()` inside a method, the call graph includes an edge to the target method resolved via dynamic lookup for each runtime class $R \\in T(\\text{this})$. $T(\\text{this})$ is the set of runtime classes that can invoke the enclosing method. Duplicate edges to the same target are merged.\n- **RTA Definition for Super Calls**: For a `super.m()` call, a single edge is added to the method defined in the immediate superclass of the class where the call lexically appears. This resolution is independent of $T(\\text{this})$.\n- **Class Hierarchy**:\n    - `class A` defines methods $m()$, $n()$, and $k()$.\n    - `class B extends A` overrides $m()$ and $n()$. It defines a new method $t()$ with a body containing the calls: `super.m()`, `this.m()`, `super.n()`, `this.n()`.\n    - `class C extends B` overrides $m()$. It does not override $n()$.\n    - `class D extends B` overrides $n()$. It does not override $m()$.\n- **Program Execution (Entry Point)**:\n    - One instance of class $B$ is allocated.\n    - One instance of class $C$ is allocated.\n    - The method $t()$ is invoked on both the instance of $B$ and the instance of $C$.\n    - No instance of class $D$ is ever allocated.\n    - No other allocations or calls occur in the program.\n- **Task**: Determine the total number of distinct call graph edges added by the four call sites within the body of $B.t()$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and grounded in the established principles of compiler design and program analysis.\n- **Scientifically Grounded**: The problem describes Rapid Type Analysis (RTA) and standard object-oriented dispatch semantics (virtual and super calls), which are core concepts in compiler theory. The model is a simplified but accurate representation of how such analyses work.\n- **Well-Posed**: The class hierarchy, method definitions, and program behavior are specified precisely. The rules for constructing the call graph are explicit. This setup allows for a unique and determinable solution.\n- **Objective and Complete**: The problem is stated in formal, unambiguous terms. All necessary information to perform the analysis is provided. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\n### Solution\nThe objective is to compute the number of distinct call graph edges originating from the four call sites in the method $B.t()$. This requires identifying the set of possible runtime receiver types for the method $B.t()$ and then analyzing each call site according to the rules of Rapid Type Analysis (RTA).\n\n**1. Determine the Receiver Type Set for $B.t()$**\nThe RTA receiver type set, denoted as $T(\\text{this})$, for the method $B.t()$ is the set of all runtime classes of objects on which the method $t()$ is dynamically invoked.\n- The program allocates an instance of class $B$ and calls $t()$ on it. The dynamic type of the receiver is $B$. The dynamic dispatch for $t()$ on a $B$ object starts at class $B$. Since $B$ defines $t()$, the call resolves to $B.t()$. Thus, $B \\in T(\\text{this})$.\n- The program allocates an instance of class $C$ and calls $t()$ on it. The dynamic type of the receiver is $C$. The dynamic dispatch for $t()$ on a $C$ object starts at class $C$. Class $C$ does not define $t()$, so the search proceeds to its superclass, $B$. Class $B$ defines $t()$, so the call resolves to $B.t()$. Thus, $C \\in T(\\text{this})$.\n- No instance of class $D$ is ever allocated, so it cannot be a receiver for any method call.\nBased on the whole-program information, the set of runtime classes that may dynamically invoke $B.t()$ is $\\{B, C\\}$. Therefore, for all call sites within $B.t()$, the receiver type set is $T(\\text{this}) = \\{B, C\\}$.\n\n**2. Analyze the Call Sites in $B.t()$**\nThe body of $B.t()$ contains four call sites. We analyze each to determine the call graph edges they contribute.\n\n**Call Site 1: `super.m()`**\n- According to the RTA rule for `super` calls, the target is determined statically by the lexical context.\n- The call `super.m()` appears within the method $B.t()$, which is defined in class $B$.\n- The immediate superclass of $B$ is $A$.\n- The call resolves to the implementation of $m()$ in class $A$.\n- This adds one edge to the call graph: $B.t() \\rightarrow A.m()$.\n\n**Call Site 2: `this.m()`**\n- This is a virtual call. The targets depend on the types in $T(\\text{this}) = \\{B, C\\}$.\n- For a receiver of runtime type $B$: The dynamic lookup for $m()$ starts at class $B$. Class $B$ overrides $m()$. The target is $B.m()$. This adds the edge $B.t() \\rightarrow B.m()$.\n- For a receiver of runtime type $C$: The dynamic lookup for $m()$ starts at class $C$. Class $C$ overrides $m()$. The target is $C.m()$. This adds the edge $B.t() \\rightarrow C.m()$.\n- These two targets, $B.m()$ and $C.m()$, are distinct. Thus, this call site contributes two distinct edges.\n\n**Call Site 3: `super.n()`**\n- This is another `super` call, resolved statically.\n- The call is in a method of class $B$. The immediate superclass is $A$.\n- The call resolves to the implementation of $n()$ in class $A$.\n- This adds one edge to the call graph: $B.t() \\rightarrow A.n()$.\n\n**Call Site 4: `this.n()`**\n- This is a virtual call. The targets depend on the types in $T(\\text{this}) = \\{B, C\\}$.\n- For a receiver of runtime type $B$: The dynamic lookup for $n()$ starts at class $B$. Class $B$ overrides $n()$. The target is $B.n()$. This adds the edge $B.t() \\rightarrow B.n()$.\n- For a receiver of runtime type $C$: The dynamic lookup for $n()$ starts at class $C$. Class $C$ does not override $n()$, so the search continues to its superclass, $B$. Class $B$ overrides $n()$. The target is $B.n()$.\n- Both runtime types $B$ and $C$ resolve to the same target method, $B.n()$. The RTA definition states that duplicate edges are merged.\n- Therefore, this call site contributes only one distinct edge: $B.t() \\rightarrow B.n()$.\n\n**3. Summation of Distinct Edges**\nWe list all unique edges contributed by the four call sites from the source $B.t()$:\n1. From `super.m()`: $B.t() \\rightarrow A.m()$\n2. From `this.m()`: $B.t() \\rightarrow B.m()$\n3. From `this.m()`: $B.t() \\rightarrow C.m()$\n4. From `super.n()`: $B.t() \\rightarrow A.n()$\n5. From `this.n()`: $B.t() \\rightarrow B.n()$\n\nAll five target methods ($A.m()$, $B.m()$, $C.m()$, $A.n()$, and $B.n()$) are distinct implementations. Consequently, the five edges are distinct.\nThe total number of distinct call graph edges added is the sum of the edges from each analysis: $1$ edge from `super.m()`, $2$ edges from `this.m()`, $1$ edge from `super.n()`, and $1$ edge from `this.n()`.\nTotal edges = $1 + 2 + 1 + 1 = 5$.", "answer": "$$\n\\boxed{5}\n$$", "id": "3625899"}, {"introduction": "The ultimate test of understanding an algorithm is to implement it, translating theory into a working program. This capstone practice requires you to build a tool that performs both Class Hierarchy Analysis (CHA) and Rapid Type Analysis (RTA) to resolve virtual calls [@problem_id:3625922]. By implementing these two related techniques and comparing their results, you will gain a concrete understanding of how compilers approximate dynamic dispatch and how runtime feedback can significantly improve analytical precision.", "problem": "You are to implement a self-contained program that constructs call graph edges under Class Hierarchy Analysis (CHA) and Rapid Type Analysis (RTA) with runtime type feedback. The fundamental base is the semantics of dynamic dispatch in single-inheritance object-oriented languages and the definition of a call graph in compiler analysis. A call graph is a directed graph where nodes correspond to methods and edges represent possible calls between methods. For a virtual call at site $i$ invoking method $m_i$ on a receiver with static type $T_i$, dynamic dispatch selects the most specific non-abstract implementation of $m_i$ along the receiver's class lineage. Class Hierarchy Analysis (CHA) safely approximates dynamic dispatch by considering all subclasses of $T_i$ that have an effective implementation of $m_i$. Rapid Type Analysis (RTA) refines CHA by intersecting this set with a runtime-observed set of receiver classes $Types_{seen}$.\n\nFormally, let $\\preceq$ denote the reflexive-transitive closure of the single-inheritance \"is-a-subclass-of\" relation. Define, for each call site $i$ with static receiver type $T_i$ and invoked method $m_i$, the CHA target set as\n$$\nTargets^{\\mathrm{CHA}}_i = \\{ C \\mid C \\preceq T_i \\land C \\text{ has an effective implementation of } m_i \\}.\n$$\nGiven a global runtime type feedback set $Types_{seen}$ containing class names observed as receiver dynamic types, define the RTA target set as\n$$\nTargets^{\\mathrm{RTA}}_i = Targets^{\\mathrm{CHA}}_i \\cap Types_{seen}.\n$$\nDefine the total edge counts\n$$\nE_{\\mathrm{CHA}} = \\sum_{i} \\left| Targets^{\\mathrm{CHA}}_i \\right|, \\quad E_{\\mathrm{RTA}} = \\sum_{i} \\left| Targets^{\\mathrm{RTA}}_i \\right|.\n$$\nYou must compute $E_{\\mathrm{CHA}}$ and $E_{\\mathrm{RTA}}$ for each test case described below. The program must be a complete, runnable implementation that performs these computations exactly as specified, without reading any input.\n\nAlgorithmic requirements:\n- Represent a finite class hierarchy with single inheritance. Each class has a name, an optional parent class name (root classes have no parent), and a finite set of method names it declares. A class \"has an effective implementation\" of a method if it declares the method or inherits a non-abstract implementation from some ancestor along $\\preceq$.\n- For each virtual call site with static receiver type $T_i$ and method name $m_i$, compute $Targets^{\\mathrm{CHA}}_i$ by enumerating all classes $C$ such that $C \\preceq T_i$ and $C$ has an effective implementation of $m_i$.\n- Given $Types_{seen}$ for the test case, compute $Targets^{\\mathrm{RTA}}_i$ by intersecting $Targets^{\\mathrm{CHA}}_i$ with $Types_{seen}$.\n- Sum the cardinalities across call sites to get $E_{\\mathrm{CHA}}$ and $E_{\\mathrm{RTA}}$.\n\nTest suite:\nProvide exact computations for the following $4$ test cases. Each test case defines classes, methods, call sites, and $Types_{seen}$:\n\n- Test case $1$ (happy path with overrides and inheritance):\n  - Classes and methods:\n    - Class $A$ (root): declares methods: `foo`, `bar`.\n    - Class $B$ (child of $A$): declares no new methods.\n    - Class $C$ (child of $B$): declares methods: `foo`, `baz`.\n    - Class $D$ (child of $C$): declares no new methods.\n  - Call sites:\n    - $s_1$: static type $A$, method `foo`.\n    - $s_2$: static type $B$, method `foo`.\n    - $s_3$: static type $C$, method `bar`.\n    - $s_4$: static type $A$, method `baz`.\n  - Runtime types seen: $Types_{seen} = \\{ B, D \\}$.\n- Test case $2$ (boundary: method absent everywhere):\n  - Classes and methods:\n    - Class `Base` (root): declares method: `g`.\n    - Class `Left` (child of `Base`): declares no new methods.\n    - Class `Right` (child of `Base`): declares no new methods.\n  - Call sites:\n    - $t_1$: static type `Base`, method `ghost`.\n    - $t_2$: static type `Left`, method `ghost`.\n  - Runtime types seen: $Types_{seen} = \\{ \\text{Left}, \\text{Right} \\}$.\n- Test case $3$ (coverage: RTA equals CHA when all types are seen):\n  - Classes and methods:\n    - Class $M$ (root): declares method: `draw`.\n    - Class $N$ (child of $M$): declares method: `draw`.\n    - Class $O$ (child of $M$): declares method: `draw`.\n    - Class $P$ (child of $N$): declares method: `draw`.\n  - Call sites:\n    - $u_1$: static type $M$, method `draw`.\n    - $u_2$: static type $O$, method `draw`.\n  - Runtime types seen: $Types_{seen} = \\{ M, N, O, P \\}$.\n- Test case $4$ (edge: heavy pruning under RTA due to narrow $Types_{seen}$):\n  - Classes and methods:\n    - Class $U$ (root): declares method: `id`.\n    - Class $V$ (child of $U$): declares no new methods.\n    - Class $W$ (child of $U$): declares method: `toString`.\n    - Class $X$ (child of $V$): declares no new methods.\n  - Call sites:\n    - $v_1$: static type $U$, method `id`.\n    - $v_2$: static type $U$, method `toString`.\n  - Runtime types seen: $Types_{seen} = \\{ X \\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the pairs $\\left(E_{\\mathrm{CHA}}, E_{\\mathrm{RTA}}\\right)$ for test cases $1$, $2$, $3$, and $4$ flattened into a single list. Concretely, your program must print\n$[E_{\\mathrm{CHA}_1},E_{\\mathrm{RTA}_1},E_{\\mathrm{CHA}_2},E_{\\mathrm{RTA}_2},E_{\\mathrm{CHA}_3},E_{\\mathrm{RTA}_3},E_{\\mathrm{CHA}_4},E_{\\mathrm{RTA}_4}]$.\nNo units, angles, or percentage formats are involved; all outputs are integers.", "solution": "The problem statement is well-defined, scientifically grounded in the principles of compiler theory, and internally consistent. It provides all necessary definitions, data, and constraints to derive a unique, verifiable solution. Therefore, the problem is deemed valid and a full solution is presented below.\n\nThe core task is to compute the number of call graph edges resolved by two static analysis techniques: Class Hierarchy Analysis (CHA) and Rapid Type Analysis (RTA). These analyses are used in compilers for object-oriented languages to approximate the set of possible targets for a dynamically dispatched (virtual) method call, enabling optimizations like inlining.\n\nLet the set of all classes be $\\mathcal{C}$. The single-inheritance relationship defines a partial order on $\\mathcal{C}$. We use $C \\preceq T$ to denote that class $C$ is a subclass of class $T$, or $C$ is $T$ itself (the reflexive-transitive closure of the subclass-of relation). Each virtual call site $i$ is characterized by a static receiver type $T_i$ and a method name $m_i$.\n\n**Class Hierarchy Analysis (CHA)**\n\nCHA determines the set of possible runtime types for the receiver at a call site $i$ by considering the class hierarchy. A call to method $m_i$ on an object of static type $T_i$ can, at runtime, resolve to any class $C$ that is a subtype of $T_i$ and provides an implementation for $m_i$. A class $C$ has an \"effective implementation\" of a method if it either declares the method itself or inherits it from one of its ancestors. The set of potential target classes under CHA is formally defined as:\n$$\nTargets^{\\mathrm{CHA}}_i = \\{ C \\mid C \\preceq T_i \\land C \\text{ has an effective implementation of } m_i \\}\n$$\nThe total number of CHA edges, $E_{\\mathrm{CHA}}$, is the sum of the sizes of these sets over all call sites $i$:\n$$\nE_{\\mathrm{CHA}} = \\sum_{i} \\left| Targets^{\\mathrm{CHA}}_i \\right|\n$$\n\n**Rapid Type Analysis (RTA)**\n\nRTA refines CHA by incorporating runtime feedback. It operates on a globally maintained set, $Types_{seen}$, which contains the names of all classes that have been observed to be instantiated at runtime. RTA posits that a call can only resolve to a type that has been instantiated. Therefore, it refines the CHA target set by intersecting it with the set of seen types:\n$$\nTargets^{\\mathrm{RTA}}_i = Targets^{\\mathrm{CHA}}_i \\cap Types_{seen}\n$$\nThe total number of RTA edges, $E_{\\mathrm{RTA}}$, is calculated by summing the cardinalities of these refined sets:\n$$\nE_{\\mathrm{RTA}} = \\sum_{i} \\left| Targets^{\\mathrm{RTA}}_i \\right|\n$$\n\n**Algorithmic Design and Implementation**\n\nTo compute $E_{\\mathrm{CHA}}$ and $E_{\\mathrm{RTA}}$, we will implement a program that embodies these definitions.\n\n1.  **Data Structures**: The class hierarchy is represented using an array of structures. Each class structure stores its name, a reference to its parent class (using an index for efficiency), and a list of method names it directly declares. Call sites are similarly represented by structures containing the static receiver type and method name. A pre-processing step resolves all class names (for parent links and static types) into integer indices for efficient lookups.\n\n2.  **Core Predicates**: Two key helper functions are required:\n    *   `is_subclass(C_idx, T_idx)`: This function evaluates the $C \\preceq T$ predicate. It takes two class indices, `C_idx` and `T_idx`, and returns true if the class at `C_idx` is a subtype of (or is the same as) the class at `T_idx`. This is implemented by traversing up the inheritance chain from `C_idx` and checking if `T_idx` is encountered.\n    *   `has_effective_implementation(C_idx, method_name)`: This function checks if a class has an implementation for a given method. It starts at the class `C_idx` and checks its declared methods. If the method is not found, it recursively traverses up to the parent class, continuing until the method is found or the root of the hierarchy is surpassed.\n\n3.  **Main Computation Loop**: For each test case, the algorithm iterates through each call site $i$:\n    *   It initializes an empty set `targets_cha`.\n    *   It then iterates through every class $C$ in the entire hierarchy.\n    *   For each class $C$, it checks if $C \\preceq T_i$ and if $C$ has an effective implementation of $m_i$ using the helper functions.\n    *   If both conditions are met, $C$ is added to `targets_cha`.\n    *   The cardinality of `targets_cha` is added to the total $E_{\\mathrm{CHA}}$.\n    *   Next, it computes the RTA targets. It iterates through the classes in `targets_cha`. For each class, it checks if its name is present in the test case's $Types_{seen}$ set.\n    *   The count of classes that pass this filter gives $|Targets^{\\mathrm{RTA}}_i|$, which is added to the total $E_{\\mathrm{RTA}}$.\n\n**Walkthrough: Test Case 1**\n\nLet's trace the execution for the first test case to illustrate the process.\n\n*   **Hierarchy**: $A \\leftarrow B \\leftarrow C \\leftarrow D$ (where $\\leftarrow$ means \"is parent of\").\n*   **Methods**: $A$: declares `foo`, `bar`. $B$: no new methods. $C$: declares `foo`, `baz`. $D$: no new methods.\n*   **Call Sites**: $s_1(A, \\text{foo})$, $s_2(B, \\text{foo})$, $s_3(C, \\text{bar})$, $s_4(A, \\text{baz})$.\n*   **$Types_{seen}$**: $\\{B, D\\}$.\n\nWe analyze each call site:\n\n*   **Site $s_1(A, \\text{foo})$**:\n    *   Static type $T_1 = A$. Subclasses of $A$ are $\\{A, B, C, D\\}$.\n    *   Effective implementations of `foo` are in $A$ (declares), $B$ (inherits from $A$), $C$ (declares), $D$ (inherits from $C$).\n    *   $Targets^{\\mathrm{CHA}}_{s_1} = \\{A, B, C, D\\}$, so $|Targets^{\\mathrm{CHA}}_{s_1}| = 4$.\n    *   $Targets^{\\mathrm{RTA}}_{s_1} = \\{A, B, C, D\\} \\cap \\{B, D\\} = \\{B, D\\}$, so $|Targets^{\\mathrm{RTA}}_{s_1}| = 2$.\n\n*   **Site $s_2(B, \\text{foo})$**:\n    *   Static type $T_2 = B$. Subclasses of $B$ are $\\{B, C, D\\}$.\n    *   Effective implementations of `foo` are in $B$ (inherits), $C$ (declares), $D$ (inherits).\n    *   $Targets^{\\mathrm{CHA}}_{s_2} = \\{B, C, D\\}$, so $|Targets^{\\mathrm{CHA}}_{s_2}| = 3$.\n    *   $Targets^{\\mathrm{RTA}}_{s_2} = \\{B, C, D\\} \\cap \\{B, D\\} = \\{B, D\\}$, so $|Targets^{\\mathrm{RTA}}_{s_2}| = 2$.\n\n*   **Site $s_3(C, \\text{bar})$**:\n    *   Static type $T_3 = C$. Subclasses of $C$ are $\\{C, D\\}$.\n    *   Effective implementations of `bar` are in $C$ (inherits from $A$) and $D$ (inherits from $A$).\n    *   $Targets^{\\mathrm{CHA}}_{s_3} = \\{C, D\\}$, so $|Targets^{\\mathrm{CHA}}_{s_3}| = 2$.\n    *   $Targets^{\\mathrm{RTA}}_{s_3} = \\{C, D\\} \\cap \\{B, D\\} = \\{D\\}$, so $|Targets^{\\mathrm{RTA}}_{s_3}| = 1$.\n\n*   **Site $s_4(A, \\text{baz})$**:\n    *   Static type $T_4 = A$. Subclasses of $A$ are $\\{A, B, C, D\\}$.\n    *   Effective implementations of `baz` are in $C$ (declares) and $D$ (inherits from $C$).\n    *   $Targets^{\\mathrm{CHA}}_{s_4} = \\{C, D\\}$, so $|Targets^{\\mathrm{CHA}}_{s_4}| = 2$.\n    *   $Targets^{\\mathrm{RTA}}_{s_4} = \\{C, D\\} \\cap \\{B, D\\} = \\{D\\}$, so $|Targets^{\\mathrm{RTA}}_{s_4}| = 1$.\n\nFinally, we sum the cardinalities:\n$E_{\\mathrm{CHA}_1} = 4 + 3 + 2 + 2 = 11$.\n$E_{\\mathrm{RTA}_1} = 2 + 2 + 1 + 1 = 6$.\n\nThis procedure is repeated for all test cases to obtain the final results.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// #include complex.h\n// #include threads.h\n// #include stdatomic.h\n\n// A struct to represent a class definition.\ntypedef struct {\n    const char* name;\n    const char* parent_name; \n    const char** declared_methods;\n    int num_declared_methods;\n    // An index to the parent in the classes array, -1 for root.\n    // This is populated during preprocessing.\n    int parent_idx; \n} ClassDef;\n\n// A struct to represent a virtual call site.\ntypedef struct {\n    const char* static_type_name;\n    const char* method_name;\n    // An index to the static type in the classes array.\n    // This is populated during preprocessing.\n    int static_type_idx;\n} CallSiteDef;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    ClassDef* classes;\n    int num_classes;\n    CallSiteDef* call_sites;\n    int num_call_sites;\n    const char** types_seen;\n    int num_types_seen;\n} TestCase;\n\n// Helper to find a class's index by its name. Returns -1 if not found.\nint find_class_idx_by_name(const char* name, const ClassDef classes[], int num_classes) {\n    for (int i = 0; i  num_classes; ++i) {\n        if (strcmp(name, classes[i].name) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Checks if class `sub_idx` is a subclass of `super_idx` (reflexive-transitive).\nint is_subclass(int sub_idx, int super_idx, const ClassDef classes[]) {\n    int current_idx = sub_idx;\n    while (current_idx != -1) {\n        if (current_idx == super_idx) {\n            return 1; // True\n        }\n        current_idx = classes[current_idx].parent_idx;\n    }\n    return 0; // False\n}\n\n// Checks if a class has an effective implementation of a method (by declaring or inheriting it).\nint has_effective_implementation(int class_idx, const char* method_name, const ClassDef classes[]) {\n    int current_idx = class_idx;\n    while (current_idx != -1) {\n        const ClassDef* current_class = classes[current_idx];\n        for (int i = 0; i  current_class-num_declared_methods; ++i) {\n            if (strcmp(method_name, current_class-declared_methods[i]) == 0) {\n                return 1; // True\n            }\n        }\n        current_idx = current_class-parent_idx;\n    }\n    return 0; // False\n}\n\n// Checks if a class name is in the set of seen types.\nint is_in_seen_set(const char* class_name, const char* types_seen[], int num_types_seen) {\n    for (int i = 0; i  num_types_seen; ++i) {\n        if (strcmp(class_name, types_seen[i]) == 0) {\n            return 1; // True\n        }\n    }\n    return 0; // False\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    const char* methods_A[] = {\"foo\", \"bar\"};\n    const char* methods_C[] = {\"foo\", \"baz\"};\n    ClassDef tc1_classes[] = {\n        {\"A\", NULL, methods_A, 2, -1},\n        {\"B\", \"A\", NULL, 0, -1},\n        {\"C\", \"B\", methods_C, 2, -1},\n        {\"D\", \"C\", NULL, 0, -1}\n    };\n    CallSiteDef tc1_call_sites[] = {\n        {\"A\", \"foo\", -1}, {\"B\", \"foo\", -1}, {\"C\", \"bar\", -1}, {\"A\", \"baz\", -1}\n    };\n    const char* tc1_types_seen[] = {\"B\", \"D\"};\n\n    // --- Test Case 2 Data ---\n    const char* methods_Base[] = {\"g\"};\n    ClassDef tc2_classes[] = {\n        {\"Base\", NULL, methods_Base, 1, -1},\n        {\"Left\", \"Base\", NULL, 0, -1},\n        {\"Right\", \"Base\", NULL, 0, -1}\n    };\n    CallSiteDef tc2_call_sites[] = {\n        {\"Base\", \"ghost\", -1}, {\"Left\", \"ghost\", -1}\n    };\n    const char* tc2_types_seen[] = {\"Left\", \"Right\"};\n\n    // --- Test Case 3 Data ---\n    const char* methods_draw[] = {\"draw\"};\n    ClassDef tc3_classes[] = {\n        {\"M\", NULL, methods_draw, 1, -1},\n        {\"N\", \"M\", methods_draw, 1, -1},\n        {\"O\", \"M\", methods_draw, 1, -1},\n        {\"P\", \"N\", methods_draw, 1, -1}\n    };\n    CallSiteDef tc3_call_sites[] = {\n        {\"M\", \"draw\", -1}, {\"O\", \"draw\", -1}\n    };\n    const char* tc3_types_seen[] = {\"M\", \"N\", \"O\", \"P\"};\n    \n    // --- Test Case 4 Data ---\n    const char* methods_U[] = {\"id\"};\n    const char* methods_W[] = {\"toString\"};\n    ClassDef tc4_classes[] = {\n        {\"U\", NULL, methods_U, 1, -1},\n        {\"V\", \"U\", NULL, 0, -1},\n        {\"W\", \"U\", methods_W, 1, -1},\n        {\"X\", \"V\", NULL, 0, -1}\n    };\n    CallSiteDef tc4_call_sites[] = {\n        {\"U\", \"id\", -1}, {\"U\", \"toString\", -1}\n    };\n    const char* tc4_types_seen[] = {\"X\"};\n\n    // === Array of all test cases ===\n    TestCase test_cases[] = {\n        {tc1_classes, 4, tc1_call_sites, 4, tc1_types_seen, 2},\n        {tc2_classes, 3, tc2_call_sites, 2, tc2_types_seen, 2},\n        {tc3_classes, 4, tc3_call_sites, 2, tc3_types_seen, 4},\n        {tc4_classes, 4, tc4_call_sites, 2, tc4_types_seen, 1}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases * 2];\n\n    // Preprocessing: Resolve names to indices for faster lookups.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase* tc = test_cases[i];\n        for (int j = 0; j  tc-num_classes; ++j) {\n            if (tc-classes[j].parent_name != NULL) {\n                tc-classes[j].parent_idx = find_class_idx_by_name(tc-classes[j].parent_name, tc-classes, tc-num_classes);\n            }\n        }\n        for (int j = 0; j  tc-num_call_sites; ++j) {\n            tc-call_sites[j].static_type_idx = find_class_idx_by_name(tc-call_sites[j].static_type_name, tc-classes, tc-num_classes);\n        }\n    }\n    \n    // Main calculation logic\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase* tc = test_cases[i];\n        int E_cha_total = 0;\n        int E_rta_total = 0;\n\n        for (int j = 0; j  tc-num_call_sites; ++j) {\n            CallSiteDef* site = tc-call_sites[j];\n            int static_type_idx = site-static_type_idx;\n            const char* method_name = site-method_name;\n\n            // Compute Targets_CHA\n            int targets_cha_classes[tc-num_classes];\n            int targets_cha_count = 0;\n            for (int k = 0; k  tc-num_classes; ++k) {\n                if (is_subclass(k, static_type_idx, tc-classes)  \n                    has_effective_implementation(k, method_name, tc-classes)) {\n                    targets_cha_classes[targets_cha_count++] = k;\n                }\n            }\n            E_cha_total += targets_cha_count;\n\n            // Compute Targets_RTA from Targets_CHA\n            int targets_rta_count = 0;\n            for (int k = 0; k  targets_cha_count; ++k) {\n                int class_idx = targets_cha_classes[k];\n                if (is_in_seen_set(tc-classes[class_idx].name, tc-types_seen, tc-num_types_seen)) {\n                    targets_rta_count++;\n                }\n            }\n            E_rta_total += targets_rta_count;\n        }\n        results[i * 2] = E_cha_total;\n        results[i * 2 + 1] = E_rta_total;\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases * 2; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases * 2 - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3625922"}]}