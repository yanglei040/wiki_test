{"hands_on_practices": [{"introduction": "To analyze large programs efficiently, compilers avoid re-analyzing a function for every call. Instead, they create a *summary* of the function's behavior. This first practice [@problem_id:3647898] guides you through creating one of the most fundamental summaries: Mod-Ref sets, which capture the memory locations a function might read from (Ref) or write to (Mod). You will apply these summaries to reason about function purity, a key property for many optimizations.", "problem": "You are given a small library of functions over integers designed to study interprocedural analysis foundations. The program has global symbols partitioned as follows:\n- Mutable globals: $G_a$, $G_b$.\n- Read-only constants: $C_a$, $C_b$.\n- A pseudo-global $I$ that summarizes all Input/Output (I/O) effects.\n\nThe following functions are defined (all arithmetic is pure integer arithmetic and terminates):\n- $f_1(x)$: returns $x + C_a$.\n- $f_2(x)$: assigns $G_a := G_a + 1$ and returns $x$.\n- $f_3(x)$: computes $t := f_1(x)$ and returns $t + C_b$.\n- $f_4(x)$: if $x$ is odd, assigns $G_b := x$; in all cases returns $f_2(x)$.\n- $f_5(x)$: returns $f_3(x) + f_1(0)$.\n- $f_6(x)$: reads the current value of $G_b$ and returns $x + G_b$.\n- $f_7(x)$: performs a $print(x)$ (modeled as an I/O effect) and returns $x$.\n- $f_8(x)$: returns $f_5(x) + f_6(0) - f_2(0)$.\n\nAssume a whole-program, context-insensitive, flow-insensitive mod-ref analysis. For each function $f$, the analysis computes two sets: $\\mathrm{Mod}(f)$, the set of globals that $f$ may write, and $\\mathrm{Ref}(f)$, the set of globals that $f$ may read. The sets are defined by these foundational rules:\n- If the body of $f$ directly writes a global $g$, then $g \\in \\mathrm{Mod}(f)$; if it directly reads a global $g$, then $g \\in \\mathrm{Ref}(f)$.\n- If $f$ calls a function $h$, then $\\mathrm{Mod}(h) \\subseteq \\mathrm{Mod}(f)$ and $\\mathrm{Ref}(h) \\subseteq \\mathrm{Ref}(f)$.\n- For conditional control flow, the analysis takes set unions across branches (flow-insensitivity).\n- The built-in $print$ is modeled as $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ and $\\mathrm{Ref}(\\text{print}) = \\varnothing$.\n- A function $f$ is considered pure if and only if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$; that is, it does not write any mutable global or $I$, and it reads only read-only constants.\n\nDefine the composition of two functions $f$ and $g$ on argument $x$ as $(f \\circ g)(x) = f(g(x))$.\n\nTask:\n- Using only the above definitions, infer $\\mathrm{Mod}(f_i)$ and $\\mathrm{Ref}(f_i)$ for all $i \\in \\{1,2,3,4,5,6,7,8\\}$, and determine which functions are pure.\n- Let $S = \\{f_1,f_2,f_3,f_4,f_5,f_6,f_7,f_8\\}$. Using the same analysis, a composed function $f \\circ g$ is considered pure if, under the interprocedural mod-ref rules, it satisfies the purity criterion. Let $N$ be the number of ordered pairs $(f,g) \\in S \\times S$ such that $f \\circ g$ is provably pure by this analysis.\n- Compute the value of $N$. Provide your answer as a single integer. No rounding is needed.", "solution": "The analysis is defined as a whole-program, context-insensitive, and flow-insensitive mod-ref analysis. The sets $\\mathrm{Mod}(f)$ and $\\mathrm{Ref}(f)$ for a function $f$ are computed by aggregating the effects from the function's body and all functions it transitively calls. For a function $f$ that calls a set of functions $H$, the rules are:\n$$ \\mathrm{Mod}(f) = (\\text{direct modifications in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Mod}(h) $$\n$$ \\mathrm{Ref}(f) = (\\text{direct references in } f) \\cup \\bigcup_{h \\in H} \\mathrm{Ref}(h) $$\nSince the entire program's source is available, these sets can be determined by finding the least fixed point of this system of equations. The call graph among the functions $f_1, \\dots, f_8$ is a Directed Acyclic Graph (DAG), so we can compute the sets in a single pass following a reverse topological sort of the call graph.\n\nFirst, we determine the direct effects and calls for each function:\n- $f_1(x)$: Reads $C_a$. No calls. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{C_a\\}$.\n- $f_2(x)$: Reads and writes $G_a$. No calls. Direct-Mod: $\\{G_a\\}$, Direct-Ref: $\\{G_a\\}$.\n- $f_3(x)$: Calls $f_1$. Reads $C_b$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{C_b\\}$. Calls: $\\{f_1\\}$.\n- $f_4(x)$: Writes $G_b$ (flow-insensitivity means we include effects from all branches). Calls $f_2$. Direct-Mod: $\\{G_b\\}$, Direct-Ref: $\\varnothing$. Calls: $\\{f_2\\}$.\n- $f_5(x)$: Calls $f_3$ and $f_1$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{f_1, f_3\\}$.\n- $f_6(x)$: Reads $G_b$. No calls. Direct-Mod: $\\varnothing$, Direct-Ref: $\\{G_b\\}$.\n- $f_7(x)$: Calls `print`. The problem states $\\mathrm{Mod}(\\text{print}) = \\{I\\}$ and $\\mathrm{Ref}(\\text{print}) = \\varnothing$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{\\text{print}\\}$.\n- $f_8(x)$: Calls $f_5, f_6, f_2$. Direct-Mod: $\\varnothing$, Direct-Ref: $\\varnothing$. Calls: $\\{f_2, f_5, f_6\\}$.\n\nNow, we compute the final $\\mathrm{Mod}$ and $\\mathrm{Ref}$ sets for each function by propagating effects up the call graph.\n\n1.  **Functions with no calls to other $f_i$ (leaves of the call graph):**\n    -   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$; $\\mathrm{Ref}(f_1) = \\{C_a\\}$.\n    -   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\}$; $\\mathrm{Ref}(f_2) = \\{G_a\\}$.\n    -   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$; $\\mathrm{Ref}(f_6) = \\{G_b\\}$.\n    -   $f_7$: $\\mathrm{Mod}(f_7) = \\mathrm{Mod}(\\text{print}) = \\{I\\}$; $\\mathrm{Ref}(f_7) = \\mathrm{Ref}(\\text{print}) = \\varnothing$.\n\n2.  **Functions calling the above:**\n    -   $f_3$ calls $f_1$:\n        $\\mathrm{Mod}(f_3) = \\mathrm{Mod}(f_1) = \\varnothing$.\n        $\\mathrm{Ref}(f_3) = \\{C_b\\} \\cup \\mathrm{Ref}(f_1) = \\{C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$.\n    -   $f_4$ calls $f_2$:\n        $\\mathrm{Mod}(f_4) = \\{G_b\\} \\cup \\mathrm{Mod}(f_2) = \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b\\}$.\n        $\\mathrm{Ref}(f_4) = \\mathrm{Ref}(f_2) = \\{G_a\\}$.\n\n3.  **Functions calling the above:**\n    -   $f_5$ calls $f_3$ and $f_1$:\n        $\\mathrm{Mod}(f_5) = \\mathrm{Mod}(f_3) \\cup \\mathrm{Mod}(f_1) = \\varnothing \\cup \\varnothing = \\varnothing$.\n        $\\mathrm{Ref}(f_5) = \\mathrm{Ref}(f_3) \\cup \\mathrm{Ref}(f_1) = \\{C_a, C_b\\} \\cup \\{C_a\\} = \\{C_a, C_b\\}$.\n\n4.  **Top-level function:**\n    -   $f_8$ calls $f_5, f_6, f_2$:\n        $\\mathrm{Mod}(f_8) = \\mathrm{Mod}(f_5) \\cup \\mathrm{Mod}(f_6) \\cup \\mathrm{Mod}(f_2) = \\varnothing \\cup \\varnothing \\cup \\{G_a\\} = \\{G_a\\}$.\n        $\\mathrm{Ref}(f_8) = \\mathrm{Ref}(f_5) \\cup \\mathrm{Ref}(f_6) \\cup \\mathrm{Ref}(f_2) = \\{C_a, C_b\\} \\cup \\{G_b\\} \\cup \\{G_a\\} = \\{G_a, G_b, C_a, C_b\\}$.\n\nNext, we identify which functions are pure. A function $f$ is pure if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$.\n-   $f_1$: $\\mathrm{Mod}(f_1) = \\varnothing$ and $\\mathrm{Ref}(f_1) = \\{C_a\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_2$: $\\mathrm{Mod}(f_2) = \\{G_a\\} \\neq \\varnothing$. Not pure.\n-   $f_3$: $\\mathrm{Mod}(f_3) = \\varnothing$ and $\\mathrm{Ref}(f_3) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_4$: $\\mathrm{Mod}(f_4) = \\{G_a, G_b\\} \\neq \\varnothing$. Not pure.\n-   $f_5$: $\\mathrm{Mod}(f_5) = \\varnothing$ and $\\mathrm{Ref}(f_5) = \\{C_a, C_b\\} \\subseteq \\{C_a, C_b\\}$. **Pure**.\n-   $f_6$: $\\mathrm{Mod}(f_6) = \\varnothing$ but $\\mathrm{Ref}(f_6) = \\{G_b\\} \\not\\subseteq \\{C_a, C_b\\}$. Not pure.\n-   $f_7$: $\\mathrm{Mod}(f_7) = \\{I\\} \\neq \\varnothing$. Not pure.\n-   $f_8$: $\\mathrm{Mod}(f_8) = \\{G_a\\} \\neq \\varnothing$. Not pure.\n\nThe set of pure functions is $P = \\{f_1, f_3, f_5\\}$.\n\nThe final task is to find the number $N$ of ordered pairs $(f, g) \\in S \\times S$ such that the composition $(f \\circ g)(x) = f(g(x))$ is provably pure. To analyze $f \\circ g$, we conceptualize it as a new function, $h(x)$, whose body consists of calls to $f$ and $g$. Due to the context-insensitive and flow-insensitive nature of the analysis, the effects of $h$ are the union of the effects of its constituent calls.\n$$ \\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) $$\n$$ \\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) $$\nFor $f \\circ g$ to be pure, it must satisfy the purity conditions:\n1.  $\\mathrm{Mod}(f \\circ g) = \\mathrm{Mod}(f) \\cup \\mathrm{Mod}(g) = \\varnothing$. This holds if and only if $\\mathrm{Mod}(f) = \\varnothing$ and $\\mathrm{Mod}(g) = \\varnothing$.\n2.  $\\mathrm{Ref}(f \\circ g) = \\mathrm{Ref}(f) \\cup \\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$. This holds if and only if $\\mathrm{Ref}(f) \\subseteq \\{C_a, C_b\\}$ and $\\mathrm{Ref}(g) \\subseteq \\{C_a, C_b\\}$.\n\nThese two conditions together are equivalent to stating that both function $f$ and function $g$ must themselves be pure. Therefore, we are looking for the number of ordered pairs $(f, g)$ where both $f$ and $g$ are elements of the set of pure functions $P$.\nThe set of pure functions is $P = \\{f_1, f_3, f_5\\}$, which has a size of $|P| = 3$.\nThe number of such ordered pairs is the size of the Cartesian product $P \\times P$.\n$$ N = |P \\times P| = |P| \\times |P| = 3 \\times 3 = 9 $$\nThe value of $N$ is $9$.", "answer": "$$\n\\boxed{9}\n$$", "id": "3647898"}, {"introduction": "A function summary tells us what a function does, but interprocedural analysis also needs to know where the function's results return. A simple analysis might incorrectly assume a function can return to *any* site that calls it, creating 'unrealizable paths' that do not exist in actual executions. This exercise [@problem_id:3647942] provides a classic example of this pitfall, showing how ignoring the strict call-return discipline can lead to spurious bug reports in a taint analysis.", "problem": "Consider the following program skeleton with explicit sources and return values. Variable names, function names, and constants are all mathematical entities and are written in LaTeX.\n\nFunction $id$ takes two parameters $x$ and $d$ and is defined as:\n- If $d = 0$, return $x$.\n- Otherwise, return $id(x, d - 1)$.\n\nProcedure $callerTainted$:\n- $a := \\text{source}()$ which returns a tainted integer,\n- $r_1 := id(a, 1)$,\n- $\\text{sinkTainted}(r_1)$.\n\nProcedure $callerClean$:\n- $b := 0$,\n- $r_2 := id(b, 1)$,\n- $y := r_2$.\n\nProcedure $main$:\n- call $callerTainted$,\n- call $callerClean$.\n\nAssume a standard Interprocedural Control Flow Graph (ICFG) model in which call edges connect a call site to the callee’s entry and return edges connect the callee’s exit back to the caller’s return site. A valid interprocedural path respects matched call-return discipline: each return must go back to the dynamic caller that issued the most recent unmatched call (i.e., a well-balanced parentheses condition corresponding to a pushdown system).\n\nNow consider an interprocedural taint analysis that, in the presence of recursion, performs graph reachability over the ICFG but ignores the return-to-caller matching constraint, effectively treating return edges as ordinary edges that may connect to any post-call site of the same function (call-site insensitivity for returns). The taint source is $\\text{source}()$ in $callerTainted$. Taint propagates along def-use chains and along returns of $id$ because $id$ returns its argument by the above definition.\n\nWhich statement correctly characterizes the analysis outcome under this “ignore return-to-caller matching” approximation?\n\nA. Only $r_1$ is tainted; $y$ stays untainted under both sound and unsound analyses, because recursion does not affect propagation of returns.\n\nB. $y$ becomes spuriously tainted: a mismatched return path from the recursive invocation of $id$ in $callerTainted$ can flow to the post-call site in $callerClean$, over-tainting $r_2$ and thus $y$.\n\nC. Both $r_1$ and $r_2$ are legitimately tainted even with properly matched returns; recursion causes $id$ to return a tainted value in all contexts.\n\nD. No variables are tainted under any interprocedural analysis because returns do not propagate taint across procedure boundaries.", "solution": "The core of the problem lies in understanding the behavior of an interprocedural taint analysis that uses a simplified model for function returns. The analysis performs graph reachability on an Interprocedural Control Flow Graph (ICFG), but it \"ignores the return-to-caller matching constraint.\" This means that when a function, say $f$, returns, the analysis assumes the control flow (and data flow) can proceed to the statement following *any* call to $f$ in the program, not just the one that initiated the current execution of $f$. This is a form of context-insensitivity.\n\nLet us trace the analysis step-by-step.\n\nThe program execution begins in `main`, which first calls `callerTainted` and then `callerClean`.\n\n1.  **Analysis of `callerTainted`:**\n    *   The statement $a := \\text{source}()$ is executed. By definition, the value assigned to $a$ is tainted.\n    *   The function $id$ is called with $r_1 := id(a, 1)$. Since $a$ is tainted, the first argument to $id$, let's call it $x$, becomes tainted. The second argument, $d$, is $1$.\n    *   Inside $id(x, 1)$, the condition $d = 0$ is false. The function recursively calls itself: $id(x, d - 1)$, which is $id(x, 0)$. The tainted value of $x$ is passed to this recursive call.\n    *   Inside $id(x, 0)$, the condition $d = 0$ is true. The function returns its argument $x$. Since $x$ is tainted, the return value of $id$ is tainted.\n    *   This tainted value is returned from the recursive call back to the outer $id(x, 1)$, which then promptly returns it.\n    *   At the exit point of the top-level $id(a, 1)$ call, a tainted value is returned.\n\n2.  **Analysis of Return Flow and `callerClean`:**\n    *   A sound analysis, which respects matched call-return pairs, would propagate this tainted return value only to its corresponding call site in `callerTainted`. This would taint $r_1$ and the analysis of `callerTainted` would conclude. The subsequent analysis of `callerClean` would start with no tainted data.\n    *   However, the problem specifies an analysis that **ignores the return-to-caller matching constraint**. The analysis model connects the exit of $id$ to all possible return sites.\n    *   The program contains two top-level call sites for $id$:\n        1.  In `callerTainted`: $r_1 := id(a, 1)$. Let its return site be $RS_1$.\n        2.  In `callerClean`: $r_2 := id(b, 1)$. Let its return site be $RS_2$.\n    *   When the tainted value is produced at the exit of $id$ (originating from the call in `callerTainted`), the unsound analysis creates data-flow paths to both $RS_1$ and $RS_2$.\n    *   The path to $RS_1$ is legitimate. It results in $r_1$ being assigned the tainted value.\n    *   The path to $RS_2$ is spurious. It creates a \"cross-talk\" or \"unrealizable path\" where the result of one function call ($id(a, 1)$) appears to be the result of a completely different call ($id(b, 1)$).\n    *   Due to this spurious path, the analysis concludes that the call $id(b, 1)$ in `callerClean` can return a tainted value.\n    *   Consequently, the variable $r_2$ is marked as tainted.\n    *   The next statement is $y := r_2$. Due to this definition-use relationship, the taint propagates from $r_2$ to $y$.\n    *   Therefore, $y$ becomes tainted in this analysis. This is a false positive, as no real execution of the program can cause $y$ to hold a tainted value.\n\nIn summary, the specified analysis correctly identifies $r_1$ as tainted but spuriously identifies $r_2$ and $y$ as tainted due to its inability to distinguish between different calling contexts for the function $id$.\n\nNow, we evaluate each option:\n\n**A. Only $r_1$ is tainted; $y$ stays untainted under both sound and unsound analyses, because recursion does not affect propagation of returns.**\nThis statement is **Incorrect**. While $y$ would stay untainted under a sound analysis, the problem explicitly describes an unsound analysis where mismatched returns are allowed. As derived above, this specific unsoundness leads to $y$ being spuriously tainted. The reason provided is also flawed; the combination of recursion and a shared function called from different contexts is precisely what exposes the imprecision of the analysis model.\n\n**B. $y$ becomes spuriously tainted: a mismatched return path from the recursive invocation of $id$ in $callerTainted$ can flow to the post-call site in $callerClean$, over-tainting $r_2$ and thus $y$.**\nThis statement is **Correct**. It accurately describes the outcome ($y$ becomes spuriously tainted) and the exact mechanism causing it. The analysis creates a \"mismatched return path\" from the call chain initiated in `callerTainted` to the return site in `callerClean`. This leads to the tainting of $r_2$ and subsequently $y$. This aligns perfectly with our derivation.\n\n**C. Both $r_1$ and $r_2$ are legitimately tainted even with properly matched returns; recursion causes $id$ to return a tainted value in all contexts.**\nThis statement is **Incorrect**. The tainting of $r_2$ (and $y$) is not legitimate; it's a false positive resulting from the analysis's imprecision. An analysis with \"properly matched returns\" (a sound, context-sensitive analysis) would find that the call $id(b, 1)$ in `callerClean` operates only on clean data ($b=0$) and thus its return value is clean. Recursion does not cause a function to be tainted in all contexts, only in contexts where its inputs are tainted.\n\n**D. No variables are tainted under any interprocedural analysis because returns do not propagate taint across procedure boundaries.**\nThis statement is **Incorrect**. It makes a factual claim that contradicts a premise given in the problem statement. The problem explicitly states that \"Taint propagates along def-use chains and along returns of $id$\". The function $id$ is an identity function on its first argument, so it is a classic example of a function that precisely propagates data (and thus taint) from its argument to its return value across a procedure boundary. Therefore, $r_1$ must be tainted.", "answer": "$$\\boxed{B}$$", "id": "3647942"}, {"introduction": "Interprocedural analysis is not just for classic compiler optimizations; it is a powerful tool for finding bugs by verifying that code respects API protocols, such as ensuring a file is opened before it is read. In this final practice [@problem_id:3647964], you will act as the analysis engine itself, summarizing functions as 'state transformers' within a type-state system. Your goal is to trace the state of a resource across a series of function calls to detect subtle protocol violations.", "problem": "You are given a simple type-state protocol for a single resource, with states and operations defined as follows. The resource type-state is modeled by the finite set $\\{U,O,X,E\\}$, where $U$ means unopened, $O$ means open, $X$ means closed, and $E$ is an error sink state. The intended protocol is to call open exactly once on an unopened resource to enter state $O$, to call write any number of times while in state $O$, and to call close exactly once from state $O$ to enter state $X$. Any operation applied in a state where it is not permitted immediately transitions the abstract state to $E$ and is a misuse. Once in $E$, the abstract state remains $E$ under any operation, and operations on $E$ do not generate additional misuse reports. The primitive operations have pointwise effects on singleton states:\n- $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n- $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n- $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n\nConsider the following program in pseudo-code, where $b_1$ and $b_2$ are nondeterministic booleans (both branches are considered possible), and calls are by reference to a single shared resource $r$:\n\nproc h(r):\n  write(r)\n\nproc k(r):\n  if b2? then close(r) else write(r)\n\nproc f(r):\n  if b1? then open(r)\n  h(r)\n\nproc g(r):\n  f(r)\n  k(r)\n\nmain:\n  r := new Resource()  // initial state is U\n  g(r)\n  close(r)\n\nWe perform a forward, flow-sensitive, context-insensitive, may analysis in the framework of monotone dataflow analysis. The abstract domain is $D=\\mathcal{P}(\\{U,O,X,E\\})$ with pointwise lifting of the single-state transfer functions so that, for $S \\subseteq \\{U,O,X,E\\}$, $T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$. Within a procedure, control-flow joins are modeled by set union on $D$. At a call site, interprocedural summarization is used: each procedure $p \\in \\{h,k,f,g\\}$ is summarized by a monotone transformer $\\tau_p:D \\to D$ that maps the abstract input state at call entry to the abstract output state at return. A misuse is flagged at a specific operation site if, at that site, there exists a reachable non-error abstract state $s \\in \\{U,O,X\\}$ from which the operation is not permitted by the protocol. Operations executed while in state $E$ do not generate new misuse flags.\n\nStarting from the initial abstract state $\\{U\\}$ at the entry of main, derive, from first principles of monotone dataflow frameworks and interprocedural summarization, the summaries $\\tau_h$, $\\tau_k$, $\\tau_f$, and $\\tau_g$, and then compute the abstract state at main’s final close site. Using these results, determine the set of distinct operation sites in the whole program that are flagged as misuses under this analysis. Report, as your final answer, the number of distinct flagged operation sites. Your answer must be a single integer with no units. If you choose to write the number in words, also include the numeral in parentheses. No rounding is required.", "solution": "This problem requires performing a forward, flow-sensitive, may dataflow analysis to find type-state protocol violations. The misuse condition for an operation `op` with pre-state $S$ is flagged if $S$ contains a non-error state for which the operation is invalid:\n- `open(r)`: Misuse if $S \\cap \\{O, X\\} \\neq \\emptyset$.\n- `write(r)`: Misuse if $S \\cap \\{U, X\\} \\neq \\emptyset$.\n- `close(r)`: Misuse if $S \\cap \\{U, X\\} \\neq \\emptyset$.\n\nWe trace the analysis of `main` starting with the resource in abstract state $S_0 = \\{U\\}$.\n\n1.  **Call `g(r)` with input $\\{U\\}$:** This requires analyzing the procedures called by `g`.\n    - **Call `f(r)` with input $\\{U\\}$**:\n        - Inside `f`, the nondeterministic `if b1?` creates two paths.\n        - *Path 1 (`then` branch)*: `open(r)` is executed. The pre-state is $\\{U\\}$. No misuse is flagged since $\\{U\\} \\cap \\{O, X\\} = \\emptyset$. The state becomes $T_{\\mathrm{open}}(\\{U\\}) = \\{O\\}$.\n        - *Path 2 (`else` branch)*: No operation is performed. The state remains $\\{U\\}$.\n        - The analysis is flow-sensitive, so before the call to `h(r)`, the state is the join of the two paths: $\\{U\\} \\cup \\{O\\} = \\{U, O\\}$.\n    - **Call `h(r)` with input $\\{U, O\\}$**:\n        - Inside `h`, the operation `write(r)` is executed.\n        - The pre-state is $\\{U, O\\}$. A misuse is flagged because this set contains $U$, and writing an unopened resource is not permitted ($\\{U,O\\} \\cap \\{U, X\\} = \\{U\\} \\neq \\emptyset$). **This is Misuse #1.**\n        - The post-state is $T_{\\mathrm{write}}(\\{U, O\\}) = T_{\\mathrm{write}}(\\{U\\}) \\cup T_{\\mathrm{write}}(\\{O\\}) = \\{E\\} \\cup \\{O\\} = \\{O, E\\}$.\n        - This state $\\{O, E\\}$ is returned from `h` and is the exit state of `f`.\n    - **In `g`, after `f(r)` returns, the state is $\\{O, E\\}$.**\n    - **Call `k(r)` with input $\\{O, E\\}$**:\n        - Inside `k`, the nondeterministic `if b2?` creates two paths.\n        - *Path 1 (`then` branch)*: `close(r)` is executed. The pre-state is $\\{O, E\\}$. No misuse is flagged since $\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$. The post-state is $T_{\\mathrm{close}}(\\{O, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} = \\{X, E\\}$.\n        - *Path 2 (`else` branch)*: `write(r)` is executed. The pre-state is $\\{O, E\\}$. No misuse is flagged since $\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$. The post-state is $T_{\\mathrm{write}}(\\{O, E\\}) = T_{\\mathrm{write}}(\\{O\\}) \\cup T_{\\mathrm{write}}(\\{E\\}) = \\{O\\} \\cup \\{E\\} = \\{O, E\\}$.\n        - The state at the exit of `k` is the join of the two paths: $\\{X, E\\} \\cup \\{O, E\\} = \\{O, X, E\\}$.\n    - **This state $\\{O, X, E\\}$ is returned from `k` and is the exit state of `g`.**\n\n2.  **In `main`, after `g(r)` returns, the state is $\\{O, X, E\\}$.**\n\n3.  **Execute final `close(r)` in `main`**:\n    - The pre-state is $\\{O, X, E\\}$.\n    - A misuse is flagged because this set contains $X$, and closing an already closed resource is not permitted ($\\{O,X,E\\} \\cap \\{U, X\\} = \\{X\\} \\neq \\emptyset$). **This is Misuse #2.**\n    - The final state becomes $T_{\\mathrm{close}}(\\{O, X, E\\}) = \\{X, E\\}$.\n\nThe analysis identifies misuses at two distinct operation sites:\n1. The `write(r)` operation within procedure `h`.\n2. The final `close(r)` operation within `main`.\n\nThe total number of distinct flagged operation sites is 2.", "answer": "$$\\boxed{2}$$", "id": "3647964"}]}