{"hands_on_practices": [{"introduction": "The core of a 'must' analysis like available expressions lies in how it combines information from different control flow paths. This practice [@problem_id:3622923] focuses on the fundamental scenario of an if-else statement, where two paths merge at a join point. By working through this example, you will gain a concrete understanding of how the set intersection meet operator ensures an expression is only considered available if it survives along *every* possible path.", "problem": "You are given the following program fragment and its control flow, where all variables ($x$, $y$, $t$, $u$, $v$, $w$) range over arbitrary integer values, and branching condition $c$ is an arbitrary Boolean expression not involving assignments. The program fragment is:\n```\n1. if ($c$) then\n2.    $t := x \\times y$;\n3.    $u := t + 1$;\n4. else\n5.    $x := x + 1$;\n6.    $v := y - 1$;\n7. end if\n8. $L$: $w := y + 2$;\n```\nAssume a standard Control Flow Graph (CFG) with one entry to the conditional, two branches for the then and else blocks, and a join at label $L$ after both branches. Consider classical forward data flow analysis of Available Expressions, treated as a must analysis: an expression $e$ is available at a program point $p$ if and only if along every path from the entry to $p$, $e$ has been evaluated and, since its last evaluation on that path, none of $e$’s operands have been redefined.\n\nLet the candidate expression of interest be $x \\times y$. Define the availability indicator at the program point $L$ as\n$$\nA_{L} \\in \\{0,1\\}, \\quad A_{L} = 1 \\text{ if } x \\times y \\text{ is available at } L, \\text{ and } A_{L} = 0 \\text{ otherwise.}\n$$\n\nUsing only the foundational definitions of available expressions analysis (forward, must, with meet as set intersection and transfer functions defined by per-block generate and kill effects), determine $A_{L}$ for the expression $x \\times y$ at the program point $L$. Then, based solely on that determination, conclude whether hoisting a computation of $x \\times y$ to immediately before the conditional (that is, to the unique predecessor of both branches) would be semantics-preserving.\n\nReport only the numeric value of $A_{L}$ as the final answer. No rounding is required and no units are involved. The discussion of code motion is part of your reasoning, but the only item to submit as the final answer is the single number $A_{L}$.", "solution": "The problem requires us to determine if the expression $x \\times y$ is available at the program point $L$. We will use the framework of forward data flow analysis for Available Expressions. This is a \"must\" analysis, meaning an expression is available at a point $p$ only if it is available along *every* path from the entry to $p$. The meet operator for a must analysis is set intersection ($\\cap$).\n\nLet $AE_{in}[B]$ and $AE_{out}[B]$ be the set of available expressions at the entry and exit of a basic block $B$, respectively. The transfer function for a basic block $B$ is defined as:\n$$\nAE_{out}[B] = \\text{gen}[B] \\cup (AE_{in}[B] - \\text{kill}[B])\n$$\nwhere $\\text{gen}[B]$ is the set of expressions computed (generated) within $B$, and $\\text{kill}[B]$ is the set of expressions whose operands are redefined (killed) within $B$.\n\nThe control flow graph has two basic blocks for the conditional branches:\n1.  $B_{then}$: The `then` branch (lines $2$ and $3$).\n2.  $B_{else}$: The `else` branch (lines $5$ and $6$).\n\nThe point $L$ is the join point immediately following these two branches. The set of available expressions at $L$, which we denote as $AE_{in}[L]$, is the meet of the available expression sets from the exits of the predecessor blocks:\n$$\nAE_{in}[L] = AE_{out}[B_{then}] \\cap AE_{out}[B_{else}]\n$$\nAssuming no expressions are available at the entry to the conditional statement, the set of available expressions at the entry of both $B_{then}$ and $B_{else}$ is the empty set, $\\emptyset$.\n\nFor the `then` branch ($B_{then}$):\n*   The instruction $t := x \\times y$ generates the expression $x \\times y$.\n*   Neither $x$ nor $y$ is redefined in this block.\n*   Therefore, $\\text{gen}[B_{then}]$ contains $\\{x \\times y\\}$, and $\\text{kill}[B_{then}]$ is empty with respect to expressions involving $x$ and $y$.\n*   The output set is $AE_{out}[B_{then}] = \\text{gen}[B_{then}] \\cup (AE_{in}[B_{then}] - \\text{kill}[B_{then}])$. With $AE_{in}[B_{then}] = \\emptyset$, we have $AE_{out}[B_{then}]$ contains $\\{x \\times y\\}$.\n\nFor the `else` branch ($B_{else}$):\n*   The instruction $x := x + 1$ redefines the variable $x$. Any expression using $x$, including $x \\times y$, is killed.\n*   The expression $x \\times y$ is not computed in this block.\n*   Therefore, $\\text{gen}[B_{else}]$ is empty with respect to $x \\times y$, and $\\text{kill}[B_{else}]$ contains $\\{x \\times y\\}$.\n*   The output set $AE_{out}[B_{else}]$ will not contain $x \\times y$.\n\nNow, we compute the set of available expressions at the join point $L$:\n$$\nAE_{in}[L] = AE_{out}[B_{then}] \\cap AE_{out}[B_{else}]\n$$\nSince $x \\times y$ is in $AE_{out}[B_{then}]$ but is not in $AE_{out}[B_{else}]$, the intersection cannot contain $x \\times y$. The expression $x \\times y$ is not available at point $L$. According to the problem definition, this means $A_L = 0$.\n\nRegarding semantics-preserving hoisting: Since $A_L=0$, we know there is at least one path to $L$ (the `else` path) where the original value of $x \\times y$ is not valid. If we were to hoist the computation of $x \\times y$ to before the conditional, its result would become stale on the `else` path due to the redefinition of $x$. Using this stale, hoisted value after the join point would be incorrect. Therefore, the transformation is not semantics-preserving.", "answer": "$$\n\\boxed{0}\n$$", "id": "3622923"}, {"introduction": "Building upon the concept of join points, we now apply available expressions analysis to loops, which are critical targets for compiler optimization. This exercise [@problem_id:3622919] presents a nested loop structure to explore how definitions in an outer loop impact availability within an inner loop. Mastering this scenario is key to understanding the preconditions for powerful optimizations like Loop-Invariant Code Motion, where we must guarantee an expression's value is constant throughout a loop's execution.", "problem": "Consider the following structured three-address code that forms a two-level loop nest. The program computes the expression $x+y$ only in the inner loop body and modifies $x$ only in the outer loop body. Assume $N$ and $M$ are positive integers, and variables $x$, $y$, $i$, $j$, and $t$ are scalars.\n\nEntry block $B_{0}$:\n- Initialize $x$ and $y$ to arbitrary values.\n- Set $i \\leftarrow 0$.\n\nOuter loop header $B_{1}$:\n- Test $i  N$; if true, branch to $B_{2}$; otherwise, exit.\n\nOuter loop body prologue $B_{2}$:\n- Update $x \\leftarrow x + 1$.\n- Set $j \\leftarrow 0$.\n- Jump to $B_{3}$.\n\nInner loop header $B_{3}$:\n- Test $j  M$; if true, branch to $B_{4}$; otherwise, branch to $B_{5}$.\n\nInner loop body $B_{4}$:\n- Compute $t \\leftarrow x + y$.\n- Update $j \\leftarrow j + 1$.\n- Jump to $B_{3}$.\n\nOuter loop latch $B_{5}$:\n- Update $i \\leftarrow i + 1$.\n- Jump to $B_{1}$.\n\nExit block:\n- Return $t$.\n\nPerform classical forward available expressions analysis over the Control Flow Graph (CFG) for the universe of expressions $\\mathcal{E} = \\{x+y\\}$. Use the standard definition: an expression $e$ is available at a program point $p$ if along every path from the program entry to $p$, $e$ has been evaluated and, since its last evaluation, none of its operands have been redefined. Use the standard forward data-flow framework with intersection as the meet operator, transfer function $\\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B])$, and boundary condition $\\mathrm{IN}[\\text{entry}] = \\varnothing$.\n\nLet the inner loop header point be the beginning of $B_{3}$ and the outer loop header point be the beginning of $B_{1}$. Define indicator variables $A_{\\text{in}}$ and $A_{\\text{out}}$ where $A_{\\text{in}} = 1$ if $x+y$ is available at the inner loop header and $A_{\\text{in}} = 0$ otherwise; similarly, $A_{\\text{out}} = 1$ if $x+y$ is available at the outer loop header and $A_{\\text{out}} = 0$ otherwise. Report a single integer code\n$$C = A_{\\text{in}} + 2 A_{\\text{out}}.$$\nCompute $C$ exactly. Your final answer must be a single integer with no units.", "solution": "The problem requires a determination of the availability of the expression $x+y$ at two specific program points—the headers of the inner and outer loops—using classical forward available expressions analysis.\n\nFirst, we establish the Control Flow Graph (CFG) from the problem description. The basic blocks are $B_0$ through $B_5$. The predecessors of each block are as follows:\n- $\\mathrm{pred}(B_0) = \\emptyset$ (Entry block)\n- $\\mathrm{pred}(B_1) = \\{B_0, B_5\\}$\n- $\\mathrm{pred}(B_2) = \\{B_1\\}$\n- $\\mathrm{pred}(B_3) = \\{B_2, B_4\\}$\n- $\\mathrm{pred}(B_4) = \\{B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_3\\}$\n\nThe analysis is performed for the universe of expressions $\\mathcal{E} = \\{x+y\\}$. We define the sets $\\mathrm{GEN}[B]$ (expressions generated in block $B$) and $\\mathrm{KILL}[B]$ (expressions killed in block $B$) for each basic block $B$. An expression is killed if one of its operands is redefined.\n- $B_0$: Initializes $x$ and $y$. This redefines both operands of $x+y$.\n  $\\mathrm{GEN}[B_0] = \\emptyset$, $\\mathrm{KILL}[B_0] = \\{x+y\\}$.\n- $B_1$: Contains only a test. No operands are modified, and no expressions are computed.\n  $\\mathrm{GEN}[B_1] = \\emptyset$, $\\mathrm{KILL}[B_1] = \\emptyset$.\n- $B_2$: The statement $x \\leftarrow x + 1$ redefines $x$.\n  $\\mathrm{GEN}[B_2] = \\emptyset$, $\\mathrm{KILL}[B_2] = \\{x+y\\}$.\n- $B_3$: Contains only a test.\n  $\\mathrm{GEN}[B_3] = \\emptyset$, $\\mathrm{KILL}[B_3] = \\emptyset$.\n- $B_4$: The statement $t \\leftarrow x + y$ computes the expression $x+y$. No operand is redefined.\n  $\\mathrm{GEN}[B_4] = \\{x+y\\}$, $\\mathrm{KILL}[B_4] = \\emptyset$.\n- $B_5$: The variable $i$ is updated, which is not an operand of $x+y$.\n  $\\mathrm{GEN}[B_5] = \\emptyset$, $\\mathrm{KILL}[B_5] = \\emptyset$.\n\nThe data-flow analysis framework is specified as a forward analysis with intersection ($\\cap$) as the meet operator. The data-flow equations for the set of available expressions at the entry ($\\mathrm{IN}[B]$) and exit ($\\mathrm{OUT}[B]$) of each block $B$ are:\n$$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n$$ \\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B]) $$\nThe boundary condition is $\\mathrm{IN}[B_0] = \\emptyset$.\n\nWe solve this system of equations to find a fixed point.\n1.  **Inner Loop Header ($B_3$):** The predecessors are $B_2$ and $B_4$. Thus, $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_4]$.\n    - Block $B_2$ contains a redefinition of $x$, so it kills $x+y$. Its transfer function ensures that $\\mathrm{OUT}[B_2]$ will not contain $\\{x+y\\}$. Therefore, $\\mathrm{OUT}[B_2] \\cap \\{x+y\\} = \\emptyset$.\n    - Because the intersection of any set with the empty set is the empty set, $\\mathrm{IN}[B_3]$ must be $\\emptyset$. The expression $x+y$ is killed on the entry path to the inner loop (via $B_2$), so it cannot be available at the inner loop header.\n2.  **Outer Loop Header ($B_1$):** The predecessors are $B_0$ and $B_5$. Thus, $\\mathrm{IN}[B_1] = \\mathrm{OUT}[B_0] \\cap \\mathrm{OUT}[B_5]$.\n    - Block $B_0$ initializes $x$ and $y$, killing $x+y$. Thus, $\\mathrm{OUT}[B_0]$ does not contain $\\{x+y\\}$.\n    - This is sufficient to conclude that $\\mathrm{IN}[B_1]$ is $\\emptyset$, as the intersection with $\\mathrm{OUT}[B_0]$ will be empty. On the first path to the outer loop header, the expression has not yet been computed, so it cannot be available.\n\nThe fixed-point solution for the IN sets at the loop headers is:\n- $\\mathrm{IN}[B_1] = \\emptyset$\n- $\\mathrm{IN}[B_3] = \\emptyset$\n\nNow we compute the indicator variables $A_{\\text{out}}$ and $A_{\\text{in}}$.\n- $A_{\\text{out}}$ corresponds to the availability of $x+y$ at the beginning of the outer loop header, $B_1$. This is determined by $\\mathrm{IN}[B_1]$. Since $\\mathrm{IN}[B_1] = \\emptyset$, the expression is not available. Thus, $A_{\\text{out}} = 0$.\n- $A_{\\text{in}}$ corresponds to the availability of $x+y$ at the beginning of the inner loop header, $B_3$. This is determined by $\\mathrm{IN}[B_3]$. Since $\\mathrm{IN}[B_3] = \\emptyset$, the expression is not available. Thus, $A_{\\text{in}} = 0$.\n\nFinally, we compute the integer code $C$:\n$$ C = A_{\\text{in}} + 2 A_{\\text{out}} = 0 + 2 \\times 0 = 0 $$", "answer": "$$\\boxed{0}$$", "id": "3622919"}, {"introduction": "Real-world programs, especially in languages like C and C++, make extensive use of pointers, introducing ambiguity through memory aliasing. For an analysis to be safe, it must be conservative and account for all possibilities. This practice [@problem_id:3622890] delves into this challenge by demonstrating how the results of a separate alias analysis directly influence the `KILL` set of an available expressions analysis, forcing us to invalidate any expression that *might* be affected by a pointer write.", "problem": "Consider forward data-flow analysis for Available Expressions in a basic block. Begin from the standard semantics: an expression is available at a program point if along every path to that point the expression has been computed and none of its constituent memory locations have been subsequently modified. For a direct assignment to a scalar variable, any expression containing that variable ceases to be guaranteed available after the assignment. For a store through a pointer, the set of possibly modified variables is given by the may-point-to set computed by alias analysis; expressions containing any of those variables cease to be guaranteed available. No algebraic identities (such as commutativity) are assumed for syntactic equality, so, for example, $a+b$ and $b+a$ are considered distinct expressions.\n\nYou are given the following program fragment in a single basic block (source-level pseudocode), where all variables denote scalar integer locations and the operator symbols denote standard arithmetic on those locations:\n```\n1.  $r_1 := a + b$\n2.  $r_2 := x \\times y$\n3.  $r_3 := y + a$\n4.  $r_4 := x + y$\n5.  $r_5 := z + a$\n6.  $r_6 := z \\times y$\n7.  $r_7 := a \\times y$\n8.  $r_8 := b + a$\n9.  $r_9 := x + a$\n10. $*p := 3$\n```\nLet the universe of candidate expressions for Available Expressions analysis be the set of all right-hand-side arithmetic expressions that syntactically appear in the above fragment:\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}.\n$$\nA flow-insensitive alias analysis reports the may-point-to set for the pointer $p$ as\n$$\n\\mathrm{pts}(p) = \\{\\, x,\\; z \\,\\},\n$$\nand that $p$ does not may-alias any of $a$, $b$, or $y$. Under a conservative Available Expressions analysis, determine the cardinality of the $KILL$ set for statement $10$ relative to the universe $\\mathcal{E}$, where $KILL$ collects all expressions from $\\mathcal{E}$ that cease to be guaranteed available immediately after statement $10$ due to potential modification by $*p := 3$.\n\nProvide your final answer as a single integer. No rounding is required.", "solution": "An expression is available if it has been previously computed and its constituent variables have not been modified since. The problem asks us to determine the `KILL` set for statement $10$, `$*p := 3$`. In Available Expressions analysis, a statement's `KILL` set comprises all expressions from the universe of interest that are invalidated by the statement. An expression is invalidated, or \"killed\", if the statement modifies one or more of its constituent variables.\n\nThe statement in question, `$*p := 3$`, is a store through a pointer `$p$`. To determine which variables are modified, we must consult the results of an alias analysis. The problem provides the may-point-to set for `$p$` as `$\\mathrm{pts}(p) = \\{\\, x,\\; z \\,\\}`. This means that the pointer `$p$` may be an alias for (i.e., may point to the memory location of) either variable `$x$` or variable `$z$`.\n\nA conservative data-flow analysis must account for all possibilities. Therefore, the statement `$*p := 3$` must be treated as potentially modifying any variable in the may-point-to set. The set of variables potentially modified by statement $10$ is `$\\{\\, x,\\; z \\,\\}`. Consequently, any expression containing either `$x$` or `$z$` as an operand is killed by this statement. The problem also states that `$p$` does not may-alias `$a$`, `$b$`, or `$y$`, confirming that these variables are not affected by the assignment.\n\nThe universe of expressions under consideration is given as:\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}\n$$\nWe will now examine each expression in `$\\mathcal{E}$` to determine if it is killed by the potential modification of `$x$` or `$z$`. Let `$\\mathrm{vars}(e)$` denote the set of variables in an expression `$e$`. An expression `$e$` is in the `KILL` set for statement $10$ if `$\\mathrm{vars}(e) \\cap \\{\\, x,\\; z \\,\\} \\neq \\emptyset$`.\n\n1.  `$a+b$`: `$\\mathrm{vars}(a+b) = \\{\\,a, b\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\emptyset$`. This expression is not killed.\n2.  `$x\\times y$`: `$\\mathrm{vars}(x\\times y) = \\{\\,x, y\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\{\\,x\\,\\}$`. This expression is killed.\n3.  `$y+a$`: `$\\mathrm{vars}(y+a) = \\{\\,y, a\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\emptyset$`. This expression is not killed.\n4.  `$x+y$`: `$\\mathrm{vars}(x+y) = \\{\\,x, y\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\{\\,x\\,\\}$`. This expression is killed.\n5.  `$z+a$`: `$\\mathrm{vars}(z+a) = \\{\\,z, a\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\{\\,z\\,\\}$`. This expression is killed.\n6.  `$z\\times y$`: `$\\mathrm{vars}(z\\times y) = \\{\\,z, y\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\{\\,z\\,\\}$`. This expression is killed.\n7.  `$a\\times y$`: `$\\mathrm{vars}(a\\times y) = \\{\\,a, y\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\emptyset$`. This expression is not killed.\n8.  `$b+a$`: `$\\mathrm{vars}(b+a) = \\{\\,b, a\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\emptyset$`. This expression is not killed.\n9.  `$x+a$`: `$\\mathrm{vars}(x+a) = \\{\\,x, a\\,\\}$`. Intersection with `$\\{\\,x, z\\,\\}$` is `$\\{\\,x\\,\\}$`. This expression is killed.\n\nBased on this analysis, the `KILL` set for statement $10$ is:\n$$\n\\mathrm{KILL}_{10} = \\{\\, x\\times y,\\; x+y,\\; z+a,\\; z\\times y,\\; x+a \\,\\}\n$$\nThe problem asks for the cardinality of this set. By counting the elements, we find:\n$$\n|\\mathrm{KILL}_{10}| = 5\n$$", "answer": "$$\n\\boxed{5}\n$$", "id": "3622890"}]}