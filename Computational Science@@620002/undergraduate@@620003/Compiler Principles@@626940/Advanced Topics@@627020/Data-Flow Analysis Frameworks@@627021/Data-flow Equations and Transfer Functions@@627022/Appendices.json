{"hands_on_practices": [{"introduction": "Robust program analyses are often built by composing simpler ones to track multiple properties simultaneously. This exercise [@problem_id:3635977] guides you through this process by constructing a *product lattice* that combines sign and parity information. You will derive a transfer function for a simple arithmetic statement from first principles, giving you a deep appreciation for how abstract domains model the semantics of concrete operations.", "problem": "Consider a forward data-flow analysis that tracks, for each program point, the abstract sign and parity of each integer variable. The analysis uses a product lattice built from a sign lattice and a parity lattice, and uses a confluence operator at branch merges that is the greatest lower bound (meet) with respect to the chosen partial order. Your task is to derive this product lattice from first principles, craft the transfer function for the assignment $x := 2y + 1$, and reason about the information flow through a simple control-flow graph. Ultimately, you will compute the height of the product lattice. Report only this height as your final answer.\n\nStart from the following fundamentals:\n\n1. The analysis uses a finite lattice for sign information, denoted $\\mathcal{S}$, and a finite lattice for parity information, denoted $\\mathcal{P}$. Each lattice element abstracts a set of integers via a concretization function. The confluence operator at branch merges is the greatest lower bound (meet) in the lattice’s partial order.\n\n2. The sign lattice $\\mathcal{S}$ abstracts the following sets of integers: the set of all integers (denote the element by $\\mathsf{AnyS}$), negative integers (denote by $\\mathsf{Neg}$), zero (denote by $\\mathsf{Zero}$), positive integers (denote by $\\mathsf{Pos}$), and the empty set (denote by $\\mathsf{NoneS}$). The concretization function $\\gamma_{\\mathcal{S}}$ maps these elements to the corresponding sets of integers. The lattice order $\\preceq_{\\mathcal{S}}$ is defined by reverse set inclusion on concretizations: for $a, b \\in \\mathcal{S}$,\n$$\na \\preceq_{\\mathcal{S}} b \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n$$\nThus $\\mathsf{AnyS}$ is the least element and $\\mathsf{NoneS}$ is the greatest element of $\\mathcal{S}$; the elements $\\mathsf{Neg}$, $\\mathsf{Zero}$, and $\\mathsf{Pos}$ lie strictly between them and are pairwise incomparable. The meet operator $\\sqcap_{\\mathcal{S}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{S}}$.\n\n3. The parity lattice $\\mathcal{P}$ abstracts the following sets of integers: the set of all integers (denote the element by $\\mathsf{AnyP}$), the even integers (denote by $\\mathsf{Even}$), the odd integers (denote by $\\mathsf{Odd}$), and the empty set (denote by $\\mathsf{NoneP}$). The concretization function $\\gamma_{\\mathcal{P}}$ and the order $\\preceq_{\\mathcal{P}}$ are defined analogously by reverse set inclusion: for $p, q \\in \\mathcal{P}$,\n$$\np \\preceq_{\\mathcal{P}} q \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{P}}(p) \\supseteq \\gamma_{\\mathcal{P}}(q).\n$$\nThus $\\mathsf{AnyP}$ is the least element, $\\mathsf{NoneP}$ is the greatest element, and $\\mathsf{Even}$ and $\\mathsf{Odd}$ are incomparable atoms between them. The meet operator $\\sqcap_{\\mathcal{P}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{P}}$.\n\n4. The product lattice $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ is ordered componentwise: for $(s_{1}, p_{1}), (s_{2}, p_{2}) \\in \\mathcal{L}$,\n$$\n(s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\text{if and only if}\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\;\\text{and}\\;\\; p_{1} \\preceq_{\\mathcal{P}} p_{2}.\n$$\nThe meet is $\\sqcap_{\\mathcal{L}}$ given componentwise by\n$$\n(s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n$$\n\nYou are given the following straight-line control-flow graph (CFG) with a single merge, using a nondeterministic conditional. The CFG nodes are:\n- Entry node initializes the abstract state for both $x$ and $y$ to $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Then a branching node with two successors:\n  - Branch $B_{1}$ assigns $y := 0$.\n  - Branch $B_{2}$ assigns $y := -1$.\n- The two branches merge at node $M$, which assigns $x := 2y + 1$.\n- There are no further statements.\n\nTasks you must complete in your reasoning:\n- Use the fundamental definition of abstract interpretation for expressions to derive the transfer function $f_{n}$ at node $M$ for the assignment $x := 2y + 1$ on the product lattice $\\mathcal{L}$. Your derivation must explicitly argue from the arithmetic properties of doubling and adding one on abstract sign and parity.\n- Use the confluence operator at the merge to compute the abstract input for $M$ from the two predecessor facts, and then apply $f_{n}$ to obtain the abstract output for $x$ at $M$.\n- From the structural properties of product lattices and the definitions of $\\mathcal{S}$ and $\\mathcal{P}$ above, derive the height $h_{\\mathcal{L}}$ of the product lattice $\\mathcal{L}$, where the height is the number of elements in a longest strictly ascending chain under $\\preceq_{\\mathcal{L}}$.\n\nReport only the value of $h_{\\mathcal{L}}$ as your final answer. No rounding is required. No units are applicable.", "solution": "We begin by formalizing the abstract domains and the confluence operator precisely, then derive the transfer function for $x := 2y + 1$, compute the merge at $M$, and finally compute the height of the product lattice.\n\nFoundational setup of the base lattices:\n- The sign lattice $\\mathcal{S}$ consists of the elements $\\{\\mathsf{AnyS}, \\mathsf{Neg}, \\mathsf{Zero}, \\mathsf{Pos}, \\mathsf{NoneS}\\}$, with concretization $\\gamma_{\\mathcal{S}}$ given by:\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{AnyS}) = \\mathbb{Z}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Neg}) = \\{ n \\in \\mathbb{Z} \\mid n < 0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Zero}) = \\{ 0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Pos}) = \\{ n \\in \\mathbb{Z} \\mid n > 0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{NoneS}) = \\varnothing$.\n  The partial order is defined by reverse set inclusion:\n  $$\n  a \\preceq_{\\mathcal{S}} b \\;\\;\\Leftrightarrow\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n  $$\n  Thus $\\mathsf{AnyS}$ is the least element, $\\mathsf{NoneS}$ is the greatest element, and the three atoms $\\mathsf{Neg}$, $\\mathsf{Zero}$, $\\mathsf{Pos}$ lie strictly between them and are pairwise incomparable. The meet $\\sqcap_{\\mathcal{S}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{S}}$. Concretely, because $\\preceq_{\\mathcal{S}}$ is reverse-inclusion on concretizations, $\\sqcap_{\\mathcal{S}}$ corresponds to set union at the concrete level:\n  $$\n  \\gamma_{\\mathcal{S}}(a \\sqcap_{\\mathcal{S}} b) \\;=\\; \\gamma_{\\mathcal{S}}(a) \\cup \\gamma_{\\mathcal{S}}(b).\n  $$\n  Hence, for example, $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Pos} = \\mathsf{AnyS}$ and $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Zero} = \\mathsf{AnyS}$, while $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Neg} = \\mathsf{Neg}$.\n\n- The parity lattice $\\mathcal{P}$ consists of $\\{\\mathsf{AnyP}, \\mathsf{Even}, \\mathsf{Odd}, \\mathsf{NoneP}\\}$, with concretization $\\gamma_{\\mathcal{P}}$:\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{AnyP}) = \\mathbb{Z}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Even}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 0 \\pmod{2} \\}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Odd}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 1 \\pmod{2} \\}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{NoneP}) = \\varnothing$.\n  The order is $\\preceq_{\\mathcal{P}}$ with the same reverse-inclusion definition, and the meet $\\sqcap_{\\mathcal{P}}$ satisfies\n  $$\n  \\gamma_{\\mathcal{P}}(p \\sqcap_{\\mathcal{P}} q) \\;=\\; \\gamma_{\\mathcal{P}}(p) \\cup \\gamma_{\\mathcal{P}}(q).\n  $$\n  Thus $\\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{AnyP}$ and $\\mathsf{Odd} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{Odd}$.\n\nProduct lattice and confluence:\n- The product lattice is $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ with componentwise order $\\preceq_{\\mathcal{L}}$ and meet $\\sqcap_{\\mathcal{L}}$:\n  $$\n  (s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\Leftrightarrow\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\wedge\\; p_{1} \\preceq_{\\mathcal{P}} p_{2},\n  $$\n  $$\n  (s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n  $$\n  At branch merges, we use $\\sqcap_{\\mathcal{L}}$ as the confluence operator.\n\nTransfer function for $x := 2y + 1$:\n- We derive the abstract effect on parity and sign separately and then combine them.\n\nParity component. For any integer $y$, $2y$ is even and $2y + 1$ is odd. Therefore, regardless of the incoming parity of $y$ (except the unreachable $\\mathsf{NoneP}$), the parity of $x := 2y+1$ is deterministically $\\mathsf{Odd}$. Formally, define $f^{\\mathcal{P}}_{n} : \\mathcal{P} \\to \\mathcal{P}$ by\n$$\nf^{\\mathcal{P}}_{n}(p) \\;=\\; \n\\begin{cases}\n\\mathsf{Odd}, & \\text{if } p \\neq \\mathsf{NoneP} \\\\\n\\mathsf{NoneP}, & \\text{if } p = \\mathsf{NoneP}\n\\end{cases}\n$$\n\nSign component. For any integer $y$, $2y + 1 \\neq 0$ because $2y$ is even and adding $1$ yields an odd number. The sign of $2y + 1$ is positive if $y \\geq 0$ and negative if $y \\leq -1$. On abstract elements, the precise result depends on the input:\n- If $y$ is exactly $\\mathsf{Zero}$, then $x = 1$ so the sign is $\\mathsf{Pos}$.\n- If $y$ is exactly $\\mathsf{Pos}$, then $2y + 1 \\geq 3$, so the sign is $\\mathsf{Pos}$.\n- If $y$ is exactly $\\mathsf{Neg}$, then $2y + 1 \\leq -1$, so the sign is $\\mathsf{Neg}$.\n- If $y$ is $\\mathsf{AnyS}$, then the concrete set of possible signs is $\\{\\mathsf{Neg}, \\mathsf{Pos}\\}$; since our lattice does not have a dedicated $\\mathsf{NonZero}$ element, the most precise representable abstract sign is $\\mathsf{AnyS}$.\n- If $y$ is $\\mathsf{NoneS}$, then the output is $\\mathsf{NoneS}$.\n\nThus define $f^{\\mathcal{S}}_{n} : \\mathcal{S} \\to \\mathcal{S}$ by\n$$\nf^{\\mathcal{S}}_{n}(s) \\;=\\;\n\\begin{cases}\n\\mathsf{Pos}, & \\text{if } s \\in \\{ \\mathsf{Zero}, \\mathsf{Pos} \\} \\\\\n\\mathsf{Neg}, & \\text{if } s = \\mathsf{Neg} \\\\\n\\mathsf{AnyS}, & \\text{if } s = \\mathsf{AnyS} \\\\\n\\mathsf{NoneS}, & \\text{if } s = \\mathsf{NoneS}\n\\end{cases}\n$$\n\nProduct transfer function. The node $M$ assigns $x := 2y+1$ and leaves $y$ unchanged. Therefore, the transfer function $f_{n} : \\mathcal{L}^{\\{x,y\\}} \\to \\mathcal{L}^{\\{x,y\\}}$ on environments for variables $\\{x,y\\}$ is\n$$\nf_{n}\\big((s_{x}, p_{x}), (s_{y}, p_{y})\\big) \\;=\\; \\Big( \\big(f^{\\mathcal{S}}_{n}(s_{y}),\\, f^{\\mathcal{P}}_{n}(p_{y})\\big),\\; (s_{y}, p_{y}) \\Big),\n$$\nwhere the first component is the new abstract value for $x$ and the second is the unchanged abstract value for $y$.\n\nFlow through the control-flow graph:\n- Entry initializes both $x$ and $y$ to $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Branch $B_{1}$ assigns $y := 0$, so the abstract fact at the end of $B_{1}$ for $y$ is $(\\mathsf{Zero}, \\mathsf{Even})$; $x$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Branch $B_{2}$ assigns $y := -1$, so the abstract fact at the end of $B_{2}$ for $y$ is $(\\mathsf{Neg}, \\mathsf{Odd})$; $x$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n\nConfluence at $M$ uses the meet $\\sqcap_{\\mathcal{L}}$ componentwise (recall that under our reverse-inclusion order this operator corresponds to taking the union of concretizations). For $y$’s input to $M$ we have\n$$\n(\\mathsf{Zero}, \\mathsf{Even}) \\;\\sqcap_{\\mathcal{L}}\\; (\\mathsf{Neg}, \\mathsf{Odd}) \\;=\\; \\big(\\,\\mathsf{Zero} \\sqcap_{\\mathcal{S}} \\mathsf{Neg},\\; \\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd}\\,\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{AnyP}).\n$$\nApplying $f_{n}$ at $M$ then yields for $x$:\n$$\n\\big(f^{\\mathcal{S}}_{n}(\\mathsf{AnyS}),\\; f^{\\mathcal{P}}_{n}(\\mathsf{AnyP})\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{Odd}),\n$$\nand $y$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$. This illustrates that the joint product abstraction captures the guaranteed odd parity of $2y+1$ while sign cannot be refined beyond $\\mathsf{AnyS}$ in this domain.\n\nHeight of the product lattice:\n- The height of a finite poset is the number of elements in a longest strictly ascending chain. For $\\mathcal{S}$, the longest chain under $\\preceq_{\\mathcal{S}}$ is\n$$\n\\mathsf{AnyS} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{Neg} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{NoneS},\n$$\nor similarly using $\\mathsf{Zero}$ or $\\mathsf{Pos}$ as the middle atom. Thus the height of $\\mathcal{S}$ is\n$$\nh_{\\mathcal{S}} \\;=\\; 3.\n$$\n- For $\\mathcal{P}$, the longest chain under $\\preceq_{\\mathcal{P}}$ is\n$$\n\\mathsf{AnyP} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{Even} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{NoneP},\n$$\nor with $\\mathsf{Odd}$ as the middle atom. Thus\n$$\nh_{\\mathcal{P}} \\;=\\; 3.\n$$\n- For the product lattice $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ with componentwise order, the height satisfies\n$$\nh_{\\mathcal{L}} \\;=\\; h_{\\mathcal{S}} \\;+\\; h_{\\mathcal{P}} \\;-\\; 1,\n$$\nbecause any strictly ascending chain in the product must increase in at least one component at each step, and we can interleave maximal chains from $\\mathcal{S}$ and $\\mathcal{P}$ while noting the shared starting element. Substituting the values gives\n$$\nh_{\\mathcal{L}} \\;=\\; 3 \\;+\\; 3 \\;-\\; 1 \\;=\\; 5.\n$$\n\nTherefore, the height of the product lattice is $5$.", "answer": "$$\\boxed{5}$$", "id": "3635977"}, {"introduction": "Loops are a primary source of complexity in static analysis, as their behavior must be summarized without actually running them. This practice [@problem_id:3635973] focuses on the core iterative algorithm used to compute a *fixpoint*—a stable data-flow summary—for a loop. By manually tracing the state of abstract machine flags through successive iterations, you will develop an intuitive understanding of how the analysis converges to a sound and useful approximation of the loop's behavior.", "problem": "Consider a forward data-flow analysis over a loop in a compiler intermediate representation designed to track two machine flags for $32$-bit two's complement integers: the sign flag $S$ and the zero flag $Z$. The sign flag $S$ is defined to be $\\mathsf{T}$ if and only if the most significant bit (bit index $31$) of the current value $x$ is $1$ and $\\mathsf{F}$ if that bit is $0$. The zero flag $Z$ is defined to be $\\mathsf{T}$ if and only if the current value $x$ equals $0$ and $\\mathsf{F}$ otherwise. Each flag is abstracted independently in a three-valued lattice $\\{\\mathsf{T},\\mathsf{F},\\mathsf{U}\\}$, where $\\mathsf{U}$ denotes “unknown.” The precision order on this lattice is such that $\\mathsf{T} \\preceq \\mathsf{U}$ and $\\mathsf{F} \\preceq \\mathsf{U}$, with $\\mathsf{T}$ and $\\mathsf{F}$ incomparable. Let the control-flow graph (CFG) of the following loop be given:\n$$\n\\text{do }\\{\\, x := x \\,\\&\\, 0x\\text{FFFFFFFE};\\quad x := x \\,|\\, 0x\\text{00000001}; \\,\\}\\ \\text{while }(\\text{unknown condition})\n$$\nAssume the loop condition is arbitrary and may cause any number of iterations $\\geq 1$. At the program point immediately before entering the loop body on the first iteration (the loop header), the abstract facts are $S=\\mathsf{U}$ and $Z=\\mathsf{U}$, reflecting that the incoming value $x$ is unconstrained.\n\nYou are asked to compute the abstract facts for $(S,Z)$ at the loop exit using a fixpoint formulation in a monotone data-flow framework, under the following rules for transfer functions that use only the facts $S$ and $Z$ and are conservative with respect to the semantics of the bitwise operations:\n\n- For the statement $y := x \\,\\&\\, m$ with a constant mask $m$, if the most significant bit of $m$ is $1$, then $S$ is unchanged; otherwise, $S$ becomes $\\mathsf{U}$. In the absence of any information beyond $S$ and $Z$, set $Z$ to $\\mathsf{U}$ unless $m=0$, in which case $Z=\\mathsf{T}$.\n- For the statement $y := x \\,|\\, c$ with a constant $c$, if the most significant bit of $c$ is $1$, then $S=\\mathsf{T}$; if it is $0$, then $S$ is unchanged. If $c \\neq 0$, then $Z=\\mathsf{F}$; if $c=0$, then $Z$ is unchanged.\n\nIn the given loop body, $m=0x\\text{FFFFFFFE}$ and $c=0x\\text{00000001}$. The loop executes the body at least once (do-while semantics). Use the standard least fixpoint semantics for forward data-flow over a finite-height lattice with monotone transfer functions. Encode the final abstract facts for $(S,Z)$ at the loop exit as a numeric row matrix using the mapping $\\mathsf{T}\\mapsto 2$, $\\mathsf{U}\\mapsto 1$, and $\\mathsf{F}\\mapsto 0$. Provide your final answer solely as this row matrix. No rounding is required, and there are no physical units involved.", "solution": "The problem requires us to compute the abstract state $(S,Z)$ at the exit of a `do-while` loop. This is a forward data-flow analysis problem, which we solve by finding the least fixpoint of the data-flow equations for the loop.\n\nThe abstract domain for a single flag is the three-point lattice $L = \\{\\mathsf{T}, \\mathsf{F}, \\mathsf{U}\\}$ with the ordering $\\mathsf{F} \\preceq \\mathsf{U}$ and $\\mathsf{T} \\preceq \\mathsf{U}$. The join operation $\\sqcup$ for two elements $a,b \\in L$ is their least upper bound: $a \\sqcup b = a$ if $a=b$, and $a \\sqcup b = \\mathsf{U}$ otherwise. The state of our analysis is a pair $(S,Z)$, an element of the product lattice $L \\times L$, where the join operation is performed component-wise.\n\nFirst, we determine the transfer function for the loop body, $f_{body}$. The body consists of two instructions. Let the state at the beginning of the loop body be $(S_{in}, Z_{in})$.\n\nThe first instruction is $x := x \\,\\&\\, m$, with $m=0x\\text{FFFFFFFE}$.\n- **Sign Flag $S$**: The most significant bit (MSB) of the mask $m$ is $1$. According to the given rule, a mask with MSB=$1$ leaves $S$ unchanged. Thus, the sign flag after this operation, $S_{mid}$, is equal to $S_{in}$.\n- **Zero Flag $Z$**: The mask $m=0x\\text{FFFFFFFE}$ is not equal to $0$. The rule states that for $m \\neq 0$, $Z$ becomes $\\mathsf{U}$. So, $Z_{mid} = \\mathsf{U}$.\nThe state after the first instruction is $(S_{mid}, Z_{mid}) = (S_{in}, \\mathsf{U})$.\n\nThe second instruction is $x := x \\,|\\, c$, with $c=0x\\text{00000001}$. This instruction operates on the value of $x$ produced by the first instruction, so its input abstract state is $(S_{mid}, Z_{mid})$.\n- **Sign Flag $S$**: The MSB of the constant $c$ is $0$. The rule states that if the MSB of $c$ is $0$, $S$ is unchanged. Thus, the final sign flag, $S_{out}$, is equal to $S_{mid}$, which is $S_{in}$. So, $S_{out} = S_{in}$.\n- **Zero Flag $Z$**: The constant $c=0x\\text{00000001}$ is not equal to $0$. The rule states that if $c \\neq 0$, $Z$ becomes $\\mathsf{F}$. So, $Z_{out} = \\mathsf{F}$.\nThe state after the second instruction is $(S_{out}, Z_{out}) = (S_{in}, \\mathsf{F})$.\n\nCombining these, the transfer function for the entire loop body is $f_{body}(S_{in}, Z_{in}) = (S_{in}, \\mathsf{F})$.\n\nNext, we must find the fixpoint for the abstract state at the loop header. Let $H$ be the state at the loop header. $H$ is the join of the state from before the loop, $H_{pre}$, and the state from the back edge of the loop, $H_{back}$.\nThe problem states that the incoming abstract fact at the loop header is $(\\mathsf{U},\\mathsf{U})$. This is $H_{pre}$.\nSo, $H_{pre} = (\\mathsf{U}, \\mathsf{U})$.\nThe state on the back edge, $H_{back}$, is the result of applying the loop body's transfer function to the state at the header, i.e., $H_{back} = f_{body}(H)$.\nThe fixpoint equation for the loop header is:\n$$H = H_{pre} \\sqcup H_{back} = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H)$$\nWe can solve this by iteration, starting with an initial approximation for $H$. A standard approach is to initialize with the \"bottom\" element, representing no information. Let's denote it by $(\\bot, \\bot)$, with the property that $v \\sqcup \\bot = v$ for any $v$.\n\nIteration $0$: $H_0 = (\\bot, \\bot)$.\n\nIteration $1$:\n$$H_1 = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H_0) = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(\\bot, \\bot)$$\nFrom our derived transfer function, $f_{body}(S, Z) = (S, \\mathsf{F})$, so $f_{body}(\\bot, \\bot) = (\\bot, \\mathsf{F})$.\n$$H_1 = (\\mathsf{U}, \\mathsf{U}) \\sqcup (\\bot, \\mathsf{F}) = (\\mathsf{U} \\sqcup \\bot, \\mathsf{U} \\sqcup \\mathsf{F})$$\nUsing the definition of the join operation: $\\mathsf{U} \\sqcup \\bot = \\mathsf{U}$ and $\\mathsf{U} \\sqcup \\mathsf{F} = \\mathsf{U}$.\n$$H_1 = (\\mathsf{U}, \\mathsf{U})$$\n\nIteration $2$:\n$$H_2 = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H_1) = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(\\mathsf{U}, \\mathsf{U})$$\nApplying the transfer function: $f_{body}(\\mathsf{U}, \\mathsf{U}) = (\\mathsf{U}, \\mathsf{F})$.\n$$H_2 = (\\mathsf{U}, \\mathsf{U}) \\sqcup (\\mathsf{U}, \\mathsf{F}) = (\\mathsf{U} \\sqcup \\mathsf{U}, \\mathsf{U} \\sqcup \\mathsf{F}) = (\\mathsf{U}, \\mathsf{U})$$\nSince $H_2 = H_1$, the iteration has converged. The least fixpoint (and loop invariant) at the header is $H_{fixpoint} = (\\mathsf{U}, \\mathsf{U})$.\n\nFinally, we need to determine the abstract state at the loop exit. For a `do-while` loop, the conditional branch occurs after the loop body is executed. The state at the exit is the state flowing from the conditional branch when the condition is false. This state is precisely the state after the execution of the loop body, before the branch decision is made.\nTherefore, the state at the loop exit, $H_{exit}$, is the result of applying the loop body's transfer function to the fixpoint state at the header.\n$$H_{exit} = f_{body}(H_{fixpoint}) = f_{body}(\\mathsf{U}, \\mathsf{U}) = (\\mathsf{U}, \\mathsf{F})$$\n\nThe final abstract state at the loop exit is $(S,Z) = (\\mathsf{U}, \\mathsf{F})$. We must encode this using the given mapping: $\\mathsf{T} \\mapsto 2$, $\\mathsf{U} \\mapsto 1$, $\\mathsf{F} \\mapsto 0$.\n- $S = \\mathsf{U}$ maps to $1$.\n- $Z = \\mathsf{F}$ maps to $0$.\n\nThe result is the pair $(1, 0)$, to be presented as a row matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 0\n\\end{pmatrix}\n}\n$$", "id": "3635973"}, {"introduction": "A well-designed data-flow solver must be both correct and precise, which involves careful handling of program control flow. This problem [@problem_id:3635901] investigates a critical aspect of solver design: the treatment of *unreachable code*. By simulating a worklist-based solver, you will discover how correct initialization and propagation logic prevent impossible program paths from polluting the analysis results, thereby maintaining precision.", "problem": "Consider a forward data-flow analysis on a Control Flow Graph (CFG), which is a directed graph of basic blocks with edges corresponding to possible control transfers. You are given a program with four basic blocks: $B_{\\mathrm{entry}}$, $B_{1}$, $B_{2}$, and $B_{3}$. The blocks and edges are as follows.\n\n- Block $B_{\\mathrm{entry}}$: contains the single statement $y := 0$, then an unconditional jump to $B_{2}$.\n- Block $B_{1}$: contains a loop that never receives control from $B_{\\mathrm{entry}}$ (it is unreachable from $B_{\\mathrm{entry}}$). Its statements are $x := 7$ and then a conditional branch that either jumps back to $B_{1}$ or jumps to $B_{3}$. Thus, $B_{1}$ has a self-loop edge and an edge to $B_{3}$, but there is no incoming edge to $B_{1}$ from any block reachable from $B_{\\mathrm{entry}}$.\n- Block $B_{2}$: contains the single statement $x := 1$, then an unconditional jump to $B_{3}$.\n- Block $B_{3}$: contains the single statement $z := x$. There are two incoming edges to $B_{3}$: one from $B_{2}$ and one from $B_{1}$.\n\nFormally, the edge set is $\\{(B_{\\mathrm{entry}},B_{2}),(B_{1},B_{1}),(B_{1},B_{3}),(B_{2},B_{3})\\}$.\n\nLet the data-flow problem be Reaching Definitions for the single variable $x$ only. The domain consists of definition sites of $x$, which are:\n- $d_{u}$: the definition $x := 7$ in $B_{1}$,\n- $d_{r}$: the definition $x := 1$ in $B_{2}$.\n\nUse the monotone framework for forward, path-insensitive, may analyses over the finite powerset lattice, starting from core definitions only (lattice ordering and meet for “may,” block-local $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets, and the standard composition of transfer functions). Assume a standard worklist solver that:\n- initializes $\\mathrm{IN}[B_{\\mathrm{entry}}]$ to the least element $\\bot$ of the lattice,\n- initializes all other data-flow sets to $\\bot$,\n- seeds the worklist with only $B_{\\mathrm{entry}}$ and then propagates along CFG edges until a fixed point is reached.\n\nDerive the data-flow equations from these principles and solve them to the fixed point under the specified boundary condition. In particular, determine the number of distinct reaching definitions of $x$ at the entry of $B_{3}$ (that is, the cardinality of $\\mathrm{IN}[B_{3}]$ for $x$) produced by the solver under the given boundary condition. As part of your reasoning, justify why the unreachable loop in $B_{1}$ does not taint the solution at $B_{3}$ when $\\mathrm{IN}[B_{\\mathrm{entry}}]=\\bot$, and explain why this boundary condition matters in the presence of unreachable code.\n\nReport only the final number. No rounding is required.", "solution": "The problem asks for the number of reaching definitions for the variable $x$ at the entry of basic block $B_{3}$. This is a forward, \"may\" data-flow analysis problem.\n\n### 1. Formal Framework\n- **Direction**: Forward analysis.\n- **Set of Definitions for $x$**: $D = \\{d_{u}, d_{r}\\}$, where $d_{u}$ is $x := 7$ in $B_1$ and $d_{r}$ is $x := 1$ in $B_2$.\n- **Domain**: The lattice is the powerset of $D$, denoted $\\mathcal{P}(D)$. The elements are sets of reaching definitions.\n- **Lattice Properties**:\n    - The partial order is set inclusion, $\\subseteq$.\n    - The meet operator ($\\wedge$) for a \"may\" analysis is set union, $\\cup$. This is used at join points in the Control Flow Graph (CFG).\n    - The bottom element is $\\bot = \\emptyset$, representing no definitions reach.\n    - The top element is $T = D = \\{d_{u}, d_{r}\\}$, representing all definitions may reach.\n- **Data-flow Equations**: For a basic block $B$, the IN and OUT sets are related by:\n$$ \\mathrm{OUT}[B] = F_B(\\mathrm{IN}[B]) $$\n$$ \\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\nwhere $\\mathrm{pred}(B)$ is the set of predecessors of $B$. For the entry block, $\\mathrm{IN}[B_{\\mathrm{entry}}]$ is a boundary condition.\n\n### 2. GEN and KILL Sets\nThe transfer function $F_B$ for a block $B$ is defined using its local effects, captured by $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets. For a set of incoming definitions $S$, the outgoing definitions are $F_B(S) = (S \\setminus \\mathrm{KILL}_B) \\cup \\mathrm{GEN}_B$. We determine these sets for each block with respect to the variable $x$.\n\n- **Block $B_{\\mathrm{entry}}$**: Contains $y := 0$. This does not define or use $x$.\n    - $\\mathrm{GEN}[B_{\\mathrm{entry}}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{\\mathrm{entry}}] = \\emptyset$\n\n- **Block $B_{1}$**: Contains $x := 7$ (definition $d_{u}$). This definition kills all other definitions of $x$.\n    - $\\mathrm{GEN}[B_{1}] = \\{d_u\\}$\n    - $\\mathrm{KILL}[B_{1}] = D \\setminus \\{d_u\\} = \\{d_r\\}$\n\n- **Block $B_{2}$**: Contains $x := 1$ (definition $d_{r}$). This definition kills all other definitions of $x$.\n    - $\\mathrm{GEN}[B_{2}] = \\{d_r\\}$\n    - $\\mathrm{KILL}[B_{2}] = D \\setminus \\{d_r\\} = \\{d_u\\}$\n\n- **Block $B_{3}$**: Contains $z := x$. This does not define $x$.\n    - $\\mathrm{GEN}[B_{3}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{3}] = \\emptyset$\n\n### 3. Transfer Functions\nBased on the $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets, the transfer functions are:\n- $F_{B_{\\mathrm{entry}}}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n- $F_{B_1}(S) = (S \\setminus \\{d_r\\}) \\cup \\{d_u\\}$\n- $F_{B_2}(S) = (S \\setminus \\{d_u\\}) \\cup \\{d_r\\}$\n- $F_{B_3}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n\n### 4. Worklist Algorithm Simulation\nThe problem specifies a worklist solver with the following initialization:\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\bot = \\emptyset$.\n- For all other blocks $B \\neq B_{\\mathrm{entry}}$, all data-flow sets (IN and OUT) are initialized to $\\bot = \\emptyset$.\n- The worklist is seeded with only the entry block: $W = \\{B_{\\mathrm{entry}}\\}$.\n\nLet's trace the execution of the algorithm.\n\n**Initial State:**\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\emptyset$, $\\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$\n- $\\mathrm{IN}[B_{1}] = \\emptyset$, $\\mathrm{OUT}[B_{1}] = \\emptyset$\n- $\\mathrm{IN}[B_{2}] = \\emptyset$, $\\mathrm{OUT}[B_{2}] = \\emptyset$\n- $\\mathrm{IN}[B_{3}] = \\emptyset$, $\\mathrm{OUT}[B_{3}] = \\emptyset$\n- $W = \\{B_{\\mathrm{entry}}\\}$\n\n**Step 1:**\n- Pop $B_{\\mathrm{entry}}$ from $W$. ($W = \\emptyset$)\n- $\\mathrm{IN}[B_{\\mathrm{entry}}]$ is the boundary condition $\\emptyset$.\n- Compute new $\\mathrm{OUT}[B_{\\mathrm{entry}}]$: $F_{B_{\\mathrm{entry}}}(\\emptyset) = \\emptyset$.\n- The value of $\\mathrm{OUT}[B_{\\mathrm{entry}}]$ does not change from its initial value of $\\emptyset$.\n- The algorithm propagates to successors. The successor of $B_{\\mathrm{entry}}$ is $B_2$.\n- Add $B_2$ to $W$. ($W = \\{B_2\\}$)\n\n**Step 2:**\n- Pop $B_2$ from $W$. ($W = \\emptyset$)\n- Compute $\\mathrm{IN}[B_2]$: $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$.\n- Compute new $\\mathrm{OUT}[B_2]$: $new\\_OUT = F_{B_2}(\\mathrm{IN}[B_2]) = F_{B_2}(\\emptyset) = (\\emptyset \\setminus \\{d_u\\}) \\cup \\{d_r\\} = \\{d_r\\}$.\n- The current $\\mathrm{OUT}[B_2]$ is $\\emptyset$. Since $new\\_OUT \\neq \\mathrm{OUT}[B_2]$, we update: $\\mathrm{OUT}[B_2] := \\{d_r\\}$.\n- The successor of $B_2$ is $B_3$.\n- Add $B_3$ to $W$. ($W = \\{B_3\\}$)\n\n**Step 3:**\n- Pop $B_3$ from $W$. ($W = \\emptyset$)\n- Compute $\\mathrm{IN}[B_3]$. The predecessors of $B_3$ are $B_1$ and $B_2$.\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$.\n- From the initial state, $\\mathrm{OUT}[B_1]$ is still $\\emptyset$. From Step 2, $\\mathrm{OUT}[B_2]$ is $\\{d_r\\}$.\n- $\\mathrm{IN}[B_3] = \\emptyset \\cup \\{d_r\\} = \\{d_r\\}$.\n- Compute new $\\mathrm{OUT}[B_3]$: $new\\_OUT = F_{B_3}(\\mathrm{IN}[B_3]) = F_{B_3}(\\{d_r\\}) = \\{d_r\\}$.\n- The current $\\mathrm{OUT}[B_3]$ is $\\emptyset$. Since $new\\_OUT \\neq \\mathrm{OUT}[B_3]$, we update: $\\mathrm{OUT}[B_3] := \\{d_r\\}$.\n- Block $B_3$ has no successors, so no blocks are added to the worklist.\n\n**Termination:**\n- The worklist $W$ is now empty. The algorithm terminates.\n\n**Final Fixed-Point Solution:**\n- $\\mathrm{IN}[B_3] = \\{d_r\\}$\n- The cardinality of this set is $|\\mathrm{IN}[B_3]| = |\\{d_r\\}| = 1$.\n\n### 5. Justification Regarding Unreachable Code\nThe problem asks why the unreachable loop in $B_1$ does not \"taint\" the solution and why the boundary and initialization conditions are important.\n\nThe worklist algorithm specified begins with only the entry block $B_{\\mathrm{entry}}$ on the worklist. New blocks are added to the worklist only when they are successors of a block whose OUT set has changed. Since there is no path in the CFG from $B_{\\mathrm{entry}}$ to $B_1$, $B_1$ is never added to the worklist.\n\nConsequently, the data-flow sets for $B_1$, specifically $\\mathrm{OUT}[B_1]$, remain at their initial value of $\\bot = \\emptyset$ throughout the analysis. When computing the input for $B_3$, the join operation is $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$. With $\\mathrm{OUT}[B_1]=\\emptyset$, this becomes $\\mathrm{IN}[B_3] = \\emptyset \\cup \\mathrm{OUT}[B_2] = \\mathrm{OUT}[B_2]$. The value $\\emptyset$ is the identity element for the set union operator, so the contribution from the unreachable block $B_1$ has no effect on the result.\n\nThe initialization scheme is critical. If, for instance, a different algorithm were used, such as a naive iterative method that processes all blocks in each round regardless of reachability, the result would be less precise. Such an algorithm would compute $\\mathrm{OUT}[B_1]=\\{d_u\\}$ and propagate it to $B_3$, yielding $\\mathrm{IN}[B_3] = \\{d_u, d_r\\}$. The specified initialization ($\\mathrm{IN}[B] = \\bot$ for all $B \\neq B_{\\mathrm{entry}}$) and starting the worklist with only $B_{\\mathrm{entry}}$ ensures that the analysis is path-sensitive with respect to reachability from the program entry. This produces the most precise solution possible for a path-insensitive analysis, correctly reflecting that definitions from unreachable code cannot reach any point in the executable part of the program.\n\nThe final answer is the cardinality of the set of reaching definitions at the entry of $B_3$. As derived, $\\mathrm{IN}[B_3] = \\{d_r\\}$. The number of definitions is $1$.", "answer": "$$\\boxed{1}$$", "id": "3635901"}]}