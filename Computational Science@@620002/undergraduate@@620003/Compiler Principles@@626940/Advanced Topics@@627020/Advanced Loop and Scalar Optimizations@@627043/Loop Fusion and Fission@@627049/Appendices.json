{"hands_on_practices": [{"introduction": "Before a compiler can transform a program, it must prove the transformation is safe and preserves the original semantics. This first exercise focuses on data dependence analysis, the cornerstone of any correct loop optimization. By analyzing a classic producer-consumer pattern, you will practice identifying the crucial Read-After-Write (RAW) data dependence that connects the two loops and see how this dependence dictates the legal ordering of statements within a fused loop [@problem_id:3652559]. This practice is essential for building a solid foundation in how compilers reason about program correctness.", "problem": "Consider arrays $A$ and $B$ of length $N$, and two loops over the common iteration space $i \\in \\{0,1,\\dots,N-1\\}$:\n- Loop $1$: for each $i$, assign $A[i] \\leftarrow i$.\n- Loop $2$: for each $i$, assign $B[A[i]] \\leftarrow i$.\n\nAssume sequential program semantics where each statement in program order observes the effects of all earlier statements, and assume $A$ and $B$ refer to disjoint memory regions. You are asked to evaluate the legality of loop fusion and the need for temporaries under the following reasoning bases:\n- The definitions of data dependences: a Read-After-Write (RAW) or true dependence exists when a statement $S_2$ reads a memory location previously written by a statement $S_1$; a Write-After-Read (WAR) or anti-dependence exists when $S_2$ writes a location previously read by $S_1$; and a Write-After-Write (WAW) or output dependence exists when both $S_1$ and $S_2$ write the same location. Correct transformations must preserve all true dependences and avoid creating behavior-changing anti- or output dependences.\n- The definition of loop fusion: combining two loops with the same iteration space into a single loop over that space, preserving sequential semantics.\n\nConsider fusing Loop $1$ and Loop $2$ into a single loop and analyze whether fusion causes a Write-After-Read hazard and whether temporaries are needed if statement reordering is desired. Select all correct statements:\n\nA. Fusing into a single loop with the per-iteration order $A[i] \\leftarrow i$ followed by $B[A[i]] \\leftarrow i$ is legal and does not introduce a Write-After-Read hazard; no temporary is required under the stated assumptions.\n\nB. Fusion is illegal because the fused body necessarily introduces a Write-After-Read hazard on $A[i]$ even if $A[i] \\leftarrow i$ is executed before $B[A[i]] \\leftarrow i$.\n\nC. Fusion is legal, and if one wishes to reorder the fused body to execute the $B$ update before updating $A$, introducing a temporary $t$ as $t \\leftarrow i$ and using $B[t] \\leftarrow i$ together with $A[i] \\leftarrow t$ eliminates any anti-dependence on $A[i]$ while preserving the original semantics.\n\nD. Fusion creates an output dependence on $B$ across iterations that makes the transformation unsafe unless $A$ is strictly monotonic; therefore, it is unsafe for $A[i]=i$.", "solution": "The user wants me to validate and solve a problem concerning loop fusion and data dependence analysis in compiler theory.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   Arrays: $A$ and $B$ of length $N$.\n-   Iteration space: $i \\in \\{0, 1, \\dots, N-1\\}$.\n-   Loop $1$: For each $i$, assign $A[i] \\leftarrow i$. Let this statement in iteration $i$ be $S_{1,i}$.\n-   Loop $2$: For each $i$, assign $B[A[i]] \\leftarrow i$. Let this statement in iteration $i$ be $S_{2,i}$.\n-   Program semantics: Sequential, effects of earlier statements are visible to later ones.\n-   Memory regions: $A$ and $B$ are disjoint.\n-   Reasoning bases:\n    -   Data dependences: Read-After-Write (RAW, true), Write-After-Read (WAR, anti), Write-After-Write (WAW, output).\n    -   Correctness criteria: Transformations must preserve all true dependences and avoid creating behavior-changing anti- or output dependences.\n    -   Loop fusion: Combining two loops with the same iteration space into one.\n-   Task: Analyze the legality of fusing Loop $1$ and Loop $2$ and the need for temporaries.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded:** The problem is firmly rooted in the well-established field of compiler optimization, specifically dependence analysis and loop transformations. The concepts of data dependences (RAW, WAR, WAW) and loop fusion are standard topics in computer science and engineering curricula. The problem is scientifically and factually sound.\n-   **Well-Posed:** The problem is clearly defined. The initial state (two sequential loops), the transformation (loop fusion), and the criteria for correctness (dependence preservation) are all explicitly given. A definite answer regarding the legality of fusion and the properties of the transformed code can be derived.\n-   **Objective:** The problem statement is phrased in precise, technical language, free from any subjective or ambiguous terms.\n-   **Completeness and Consistency:** The problem is self-contained. All necessary information (loop bounds, loop bodies, memory disjointness) is provided. There are no internal contradictions.\n-   **Other Flaws:** The problem does not exhibit any other flaws such as being unrealistic, ill-posed, trivial, or unverifiable. It is a standard, non-trivial exercise in applying compiler principles.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. I will proceed to derive the solution.\n\n### Solution Derivation\n\nFirst, we analyze the data dependences in the original, unfused program.\n-   Loop $1$ (for $i \\in \\{0, \\dots, N-1\\}$): $S_{1,i}: A[i] \\leftarrow i$. This loop writes to the array $A$. After its completion, $A[i]$ holds the value $i$ for all $i$ in the iteration space.\n-   Loop $2$ (for $i \\in \\{0, \\dots, N-1\\}$): $S_{2,i}: B[A[i]] \\leftarrow i$. This loop reads from array $A$ and writes to array $B$.\n\nThe crucial dependence is between the loops. For any given index $k \\in \\{0, \\dots, N-1\\}$, the statement $S_{1,k}$ writes to $A[k]$, and the statement $S_{2,k}$ reads from $A[k]$. Since Loop $1$ executes entirely before Loop $2$, $S_{2,k}$ reads the value written by $S_{1,k}$. This constitutes a Read-After-Write (RAW), or true, dependence from $S_{1,k}$ to $S_{2,k}$. Any legal transformation must preserve this set of dependences for all $k$.\n\nIn the original program, since $A[k]$ becomes $k$ after Loop $1$, Loop $2$ effectively executes $B[k] \\leftarrow k$ for all $k \\in \\{0, \\dots, N-1\\}$. The final state is $A[i]=i$ and $B[i]=i$ for all $i$.\n\nNow, let's analyze the proposed fusion and the options. The fused loop would combine the bodies of Loop $1$ and Loop $2$:\n$$\n\\text{for } i \\in \\{0, \\dots, N-1\\} \\{ \\\\\n\\quad \\dots \\text{fused body} \\dots \\\\\n\\}\n$$\n\n### Option-by-Option Analysis\n\n**A. Fusing into a single loop with the per-iteration order $A[i] \\leftarrow i$ followed by $B[A[i]] \\leftarrow i$ is legal and does not introduce a Write-After-Read hazard; no temporary is required under the stated assumptions.**\n\nThe fused loop body would be:\n1.  $S_A: A[i] \\leftarrow i$\n2.  $S_B: B[A[i]] \\leftarrow i$\n\nLet's analyze this fused loop. Within a single iteration $i$:\n-   $S_A$ writes the value $i$ to the memory location $A[i]$.\n-   $S_B$ then reads the memory location $A[i]$. Because of the sequential execution within the loop body, it reads the value $i$ that was just written. The assignment thus becomes $B[i] \\leftarrow i$.\n\nThis execution preserves the original true dependence. The original inter-loop dependence ($S_{1,i} \\rightarrow S_{2,i}$) is transformed into an intra-iteration dependence in the fused loop. The final state of arrays $A$ and $B$ is identical to the original program ($A[i]=i$ and $B[i]=i$). Therefore, the fusion is legal.\n\nA Write-After-Read (WAR) hazard would occur if a statement writes to a location that a preceding statement reads. Here, $S_A$ does not read from memory (its right-hand side is the induction variable $i$). $S_B$ reads from $A[i]$, but $S_A$ does not read from any location that $S_B$ writes. The dependence on $A[i]$ is that $S_A$ writes to it, and $S_B$ reads from it. This is a Read-After-Write (RAW) flow, not a Write-After-Read (WAR) anti-dependence. No new, problematic WAR hazard is introduced. Since the fusion is legal and directly implements the logic, no temporary variable is needed.\n\n**Verdict: Correct.**\n\n**B. Fusion is illegal because the fused body necessarily introduces a Write-After-Read hazard on $A[i]$ even if $A[i] \\leftarrow i$ is executed before $B[A[i]] \\leftarrow i$.**\n\nThis statement claims fusion is illegal. As demonstrated in the analysis for option A, fusion is legal. The statement also incorrectly identifies the dependence on $A[i]$ as a WAR hazard. The dependence is RAW ($A[i]$ is written, then read). The presence of a dependence does not automatically make a transformation illegal; legality depends on preserving the original program's semantics, which this fusion does.\n\n**Verdict: Incorrect.**\n\n**C. Fusion is legal, and if one wishes to reorder the fused body to execute the B update before updating A, introducing a temporary $t$ as $t \\leftarrow i$ and using $B[t] \\leftarrow i$ together with $A[i] \\leftarrow t$ eliminates any anti-dependence on A[i] while preserving the original semantics.**\n\n-   **Fusion is legal**: This part is correct.\n-   **Reordering**: Consider naively reordering the statements in the fused body to be $S_B$ then $S_A$:\n    1.  $B[A[i]] \\leftarrow i$\n    2.  $A[i] \\leftarrow i$\n    This reordering is illegal. The first statement reads $A[i]$ *before* it is updated in the current iteration, violating the original program's true dependence. This illegal ordering introduces a WAR (anti-dependence) on $A[i]$: the read in the first statement is followed by a write to the same location in the second statement.\n-   **Proposed Transformation**: The option suggests a new loop body to enable the conceptual reordering:\n    1.  $t \\leftarrow i$\n    2.  $B[t] \\leftarrow i$\n    3.  $A[i] \\leftarrow t$\n    This sequence calculates $B[i] \\leftarrow i$ and $A[i] \\leftarrow i$, which correctly reproduces the final state of the original program.\n-   **Eliminates anti-dependence**: Let's analyze the dependences between the new statements for updating $A$ and $B$: $S_{C,A}: A[i] \\leftarrow t$ and $S_{C,B}: B[t] \\leftarrow i$. Neither statement reads a location that the other writes. They are independent with respect to memory arrays $A$ and $B$. Therefore, they can be scheduled in any order after $t \\leftarrow i$. This successfully eliminates the dependence on $A[i]$ that prevented the naive reordering, and thus resolves the associated anti-dependence.\nThe statement accurately describes a valid compiler technique (often involving scalar replacement or renaming) to increase instruction-level parallelism by breaking data dependences.\n\n**Verdict: Correct.**\n\n**D. Fusion creates an output dependence on $B$ across iterations that makes the transformation unsafe unless $A$ is strictly monotonic; therefore, it is unsafe for $A[i]=i$.**\n\n-   **Output Dependence (WAW)**: An output dependence exists between an operation in iteration $i$ and an operation in a later iteration $j$ if they both write to the same memory location. The write to $B$ is specified by $B[A[i]] \\leftarrow i$.\n-   **Analysis for $A[i]=i$**: In the fused loop, $A[i]$ is set to $i$ before the write to $B$. Thus, the write is to $B[i]$. For two different iterations $i$ and $j$ ($i \\neq j$), the writes are to $B[i]$ and $B[j]$, which are distinct memory locations. Therefore, for the specific case $A[i]=i$, there is **no** output dependence on $B$ across iterations.\n-   **Logical Flaw**: The statement has a logical contradiction. It posits a condition for safety (\"unsafe unless $A$ is strictly monotonic\") and then applies it to a case where the condition is met ($A[i]=i$ is strictly monotonic), but draws the opposite conclusion (\"therefore, it is unsafe for $A[i]=i$\"). If the premise were true, the conclusion for $A[i]=i$ should be that it is safe.\n-   As shown, the premise itself is false, as no output dependence exists for this problem. The transformation is perfectly safe.\n\n**Verdict: Incorrect.**", "answer": "$$\\boxed{AC}$$", "id": "3652559"}, {"introduction": "A transformation that is correct is not always beneficial. Modern compilers make sophisticated decisions based on profitability models to determine whether an optimization is likely to improve performance. In this exercise, you will step into the role of a compiler's analysis engine and build a quantitative model to evaluate the speedup from loop fusion [@problem_id:3652519]. Using profile data and a realistic machine model, you will weigh the performance gains from improved data locality and reduced memory traffic against factors like branch misprediction costs, providing a clear, data-driven justification for the optimization.", "problem": "A compiler backend for a Central Processing Unit (CPU) considers fusing two adjacent loops, $L_1$ and $L_2$, that iterate over the same range of $i \\in \\{0,\\dots,N-1\\}$ with $N = 10^7$. Loop $L_1$ computes $a[i]$ from $b[i]$, and loop $L_2$ consumes $a[i]$ to produce $d[i]$. Profile-guided optimization has produced the following per-iteration measurements for the program version where the loops are not fused:\n- Loop $L_1$: arithmetic base cost $c_1 = 2$ cycles; memory references per iteration $R_1 = 2$; average Level $1$ (L$1$) data cache miss rate per memory reference $m_1 = 0.05$; loop-control branch base cost $c_{\\mathrm{br}} = 1$ cycle per iteration; branch misprediction probability per iteration $p_1 = 0.003$.\n- Loop $L_2$: arithmetic base cost $c_2 = 3$ cycles; memory references per iteration $R_2 = 2$; average L$1$ data cache miss rate per memory reference $m_2 = 0.12$; branch misprediction probability per iteration $p_2 = 0.007$.\n\nThe machine model uses the following constants, derived from hardware performance monitoring:\n- L$1$ miss penalty $L = 40$ cycles.\n- Memory reference hit cost $C_h = 1$ cycle per reference.\n- Branch misprediction penalty $B = 15$ cycles.\n\nAssume the following when the loops are fused:\n- Dependence analysis allows scalar replacement, so the producer-consumer temporary $a[i]$ is not materialized in memory inside the fused loop. Consequently, the two references to $a[i]$ (the store in $L_1$ and the load in $L_2$) are eliminated from the steady-state memory traffic of the fused loop.\n- The remaining references inherit their miss behavior from the original loops: the $b[i]$ load has per-reference miss probability $m_1$, and the $d[i]$ store has per-reference miss probability $m_2$. No other references are introduced.\n- The fused loop has a single loop-control branch with misprediction probability $p_f = 0.004$ and the same base cost $c_{\\mathrm{br}}$ per iteration as above.\n\nUsing only fundamental definitions (expected cost as probability-weighted penalty plus base costs, linearity over iterations), construct a profitability model for the expected cycles and compute the speedup $S$ of the fused version over the unfused version. Express $S$ as the ratio of total expected execution cycles of the unfused code to that of the fused code for the same $N$, and give a single numerical value. Round your answer to $4$ significant figures.", "solution": "The problem asks for the speedup $S$ of a fused loop version over an unfused version. The speedup is defined as the ratio of the total expected execution time (in cycles) of the unfused version to that of the fused version. Since both versions perform the same number of iterations, $N = 10^7$, the speedup can be calculated as the ratio of the expected cycles per iteration.\n$$S = \\frac{\\text{Total Cycles}_{\\text{unfused}}}{\\text{Total Cycles}_{\\text{fused}}} = \\frac{N \\times T_{\\text{unfused, per iter}}}{N \\times T_{\\text{fused, per iter}}} = \\frac{T_{\\text{unfused, per iter}}}{T_{\\text{fused, per iter}}}$$\nWe will construct a profitability model for the expected number of cycles per iteration for each case. The total expected cost per iteration, $T_{\\text{iter}}$, is the sum of the costs from three main components: arithmetic operations, memory accesses, and loop control branching.\n\n$T_{\\text{iter}} = T_{\\text{arith}} + T_{\\text{mem}} + T_{\\text{branch}}$\n\nThe cost for each component is modeled as follows:\n-   Arithmetic cost, $T_{\\text{arith}}$, is the given base cost $c_{\\text{arith}}$.\n-   Memory cost, $T_{\\text{mem}}$, is the sum of expected costs for all memory references in the iteration. The expected cost for a single memory reference with miss rate $m$ is the sum of the hit cost $C_h$ and the expected penalty for a miss, which is the miss probability $m$ times the miss penalty $L$.\n    Expected Cost per Reference $= C_h + m \\times L$\n-   Branch cost, $T_{\\text{branch}}$, is the sum of the base cost for the branch instruction, $c_{\\mathrm{br}}$, and the expected penalty for a branch misprediction, which is the misprediction probability $p$ times the misprediction penalty $B$.\n    $T_{\\text{branch}} = c_{\\mathrm{br}} + p \\times B$\n\nFirst, we calculate the total expected cycles per iteration for the unfused version, $T_{\\text{unfused}}$. This is the sum of the per-iteration costs of loop $L_1$ and loop $L_2$.\n\nFor loop $L_1$:\n-   Arithmetic base cost: $c_1 = 2$ cycles.\n-   Memory references: $R_1 = 2$, with an average miss rate $m_1 = 0.05$.\n-   Branch misprediction probability: $p_1 = 0.003$.\nThe loop control branch has a base cost $c_{\\mathrm{br}} = 1$ cycle. The machine constants are L$1$ miss penalty $L = 40$ cycles, memory hit cost $C_h = 1$ cycle, and branch misprediction penalty $B = 15$ cycles.\n\nThe expected cost per iteration for $L_1$, denoted $T_1$, is:\n$$T_1 = c_1 + R_1 \\times (C_h + m_1 \\times L) + (c_{\\mathrm{br}} + p_1 \\times B)$$\n$$T_1 = 2 + 2 \\times (1 + 0.05 \\times 40) + (1 + 0.003 \\times 15)$$\n$$T_1 = 2 + 2 \\times (1 + 2) + (1 + 0.045)$$\n$$T_1 = 2 + 2 \\times 3 + 1.045$$\n$$T_1 = 2 + 6 + 1.045 = 9.045 \\text{ cycles}$$\n\nFor loop $L_2$:\n-   Arithmetic base cost: $c_2 = 3$ cycles.\n-   Memory references: $R_2 = 2$, with an average miss rate $m_2 = 0.12$.\n-   Branch misprediction probability: $p_2 = 0.007$.\nThe loop also has a control branch with base cost $c_{\\mathrm{br}} = 1$.\n\nThe expected cost per iteration for $L_2$, denoted $T_2$, is:\n$$T_2 = c_2 + R_2 \\times (C_h + m_2 \\times L) + (c_{\\mathrm{br}} + p_2 \\times B)$$\n$$T_2 = 3 + 2 \\times (1 + 0.12 \\times 40) + (1 + 0.007 \\times 15)$$\n$$T_2 = 3 + 2 \\times (1 + 4.8) + (1 + 0.105)$$\n$$T_2 = 3 + 2 \\times 5.8 + 1.105$$\n$$T_2 = 3 + 11.6 + 1.105 = 15.705 \\text{ cycles}$$\n\nThe total expected cycles per iteration for the unfused version is the sum of the costs for $L_1$ and $L_2$:\n$$T_{\\text{unfused}} = T_1 + T_2 = 9.045 + 15.705 = 24.75 \\text{ cycles}$$\n\nNext, we calculate the expected cycles per iteration for the fused version, $T_{\\text{fused}}$.\n-   Arithmetic cost: The operations of both loops are combined, so the arithmetic base cost is $c_f = c_1 + c_2 = 2 + 3 = 5$ cycles.\n-   Memory cost: The temporary array $a[i]$ is eliminated. The original memory references were a load from $b[i]$ and a store to $a[i]$ in $L_1$, and a load from $a[i]$ and a store to $d[i]$ in $L_2$. After fusion, the two references to $a[i]$ are removed. The remaining two references are the load from $b[i]$ and the store to $d[i]$. The problem states their miss probabilities are $m_1$ and $m_2$ respectively. The total memory cost is the sum of the expected costs for these two individual references.\n    $$T_{\\text{mem,fused}} = (\\text{cost of load } b[i]) + (\\text{cost of store } d[i])$$\n    $$T_{\\text{mem,fused}} = (C_h + m_1 \\times L) + (C_h + m_2 \\times L)$$\n    $$T_{\\text{mem,fused}} = (1 + 0.05 \\times 40) + (1 + 0.12 \\times 40)$$\n    $$T_{\\text{mem,fused}} = (1 + 2) + (1 + 4.8) = 3 + 5.8 = 8.8 \\text{ cycles}$$\n-   Branch cost: The fused loop has a single loop control structure with base cost $c_{\\mathrm{br}} = 1$ and a new misprediction probability $p_f = 0.004$.\n    $$T_{\\text{branch,fused}} = c_{\\mathrm{br}} + p_f \\times B = 1 + 0.004 \\times 15 = 1 + 0.06 = 1.06 \\text{ cycles}$$\n\nThe total expected cycles per iteration for the fused version is the sum of these components:\n$$T_{\\text{fused}} = T_{\\text{arith,fused}} + T_{\\text{mem,fused}} + T_{\\text{branch,fused}}$$\n$$T_{\\text{fused}} = 5 + 8.8 + 1.06 = 14.86 \\text{ cycles}$$\n\nFinally, we compute the speedup $S$:\n$$S = \\frac{T_{\\text{unfused}}}{T_{\\text{fused}}} = \\frac{24.75}{14.86} \\approx 1.665545087...$$\nRounding the result to $4$ significant figures gives $1.666$.", "answer": "$$\\boxed{1.666}$$", "id": "3652519"}, {"introduction": "Optimizations rarely exist in isolation; their true power often comes from how they interact. This advanced practice explores the synergy between loop fusion and predication (if-conversion) for handling conditional logic inside loops. You will analyze a scenario where fusing loops enables the compiler to replace an unpredictable, and therefore expensive, conditional branch with a branch-free sequence of predicated instructions [@problem_id:3652603]. This problem illuminates the trade-offs between different microarchitectural costs and demonstrates how a combination of optimizations can unlock significant performance gains that neither could achieve alone.", "problem": "Consider two consecutive loops over an array $A[0\\,..\\,N-1]$ on a Central Processing Unit (CPU) with a hardware Branch Prediction Unit (BPU). The first loop conditionally updates $A[i]$ only if a data-dependent predicate $P(i)$ holds, and the second loop subsequently uses $A[i]$ unconditionally to accumulate into a scalar $S$. The semantics are:\n- First loop: for each $i$, if $P(i)$ is true, perform $A[i] \\leftarrow A[i] + C$, otherwise do nothing.\n- Second loop: for each $i$, perform $S \\leftarrow S + A[i]$.\n\nAssume the following foundational facts and cost model for a single iteration $i$:\n- $P(i)$ is true with probability $p$, independently across iterations.\n- The BPU predicts the branch outcome for the $P(i)$ guard with accuracy $a$.\n- A correctly resolved branch has base cost $B$ cycles; a mispredicted branch incurs an additional penalty of $M$ cycles.\n- Evaluating the predicate (the compare computing $P(i)$) costs $Q$ cycles.\n- A load of $A[i]$ costs $L$ cycles; a store to $A[i]$ costs $T$ cycles.\n- Each scalar addition (either updating $A[i]$ by $C$ or accumulating into $S$) costs $U$ cycles.\n- A conditional move (predicated select without branching) costs $R$ cycles.\n- Cache behavior is stable: $L$ and $T$ are constant, and memory dependencies do not change costs across the two transformations.\n- The two loops are large enough that steady-state per-iteration expectations apply, and instruction overlap effects can be ignored.\n\nYou propose to fuse the loops with predication to eliminate the control-flow branch, preserving semantics by computing a selected value of $A[i]$ and using it once per iteration. The fused, predicated scheme is:\n- For each $i$, compute the boolean value of $P(i)$; load $A[i]$ once; compute the candidate update $A_{\\text{new}} = A[i] + C$; use a conditional move to select $A'[i] = P(i) ? A_{\\text{new}} : A[i]$; store $A'[i]$; and accumulate $S \\leftarrow S + A'[i]$.\n\nUnder the numerical parameters $p = 0.3$, $a = 0.85$, $B = 1$, $M = 12$, $Q = 1$, $L = 4$, $T = 4$, $U = 1$, and $R = 1$ (all costs in cycles), derive from first principles the expected steady-state per-iteration cycle counts for:\n- The unfused baseline of two loops (with the guarded update in the first loop and unconditional use in the second), and\n- The fused predicated loop as specified above,\n\nand then compute the speedup ratio defined as the baseline expected cycles per iteration divided by the fused expected cycles per iteration. Express the final speedup as a single scalar value. No rounding is required, and the ratio is dimensionless.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and objective. It presents a standard performance modeling task in computer architecture and compiler optimization, based on established principles. All necessary data and definitions are provided.\n\nThe objective is to compute the speedup ratio, defined as the expected per-iteration cycle count of the original two-loop structure (the baseline) divided by the expected per-iteration cycle count of the transformed single-loop structure (fused and predicated).\n\nLet $E_{\\text{baseline}}$ be the expected cycle cost per iteration for the unfused baseline, and let $E_{\\text{fused}}$ be the cycle cost per iteration for the fused loop. The speedup $S$ is given by $S = \\frac{E_{\\text{baseline}}}{E_{\\text{fused}}}$.\n\nFirst, we calculate $E_{\\text{baseline}}$. This is the sum of the expected costs of the two individual loops. Let $E_1$ be the expected cost of the first loop and $E_2$ be the cost of the second loop.\n$E_{\\text{baseline}} = E_1 + E_2$.\n\nThe first loop is: for each $i$, if $P(i)$ is true, perform $A[i] \\leftarrow A[i] + C$.\nThe cost for one iteration of this loop, $E_1$, is the sum of the costs of its constituent operations.\n- The predicate $P(i)$ must be evaluated in every iteration. This costs $Q$.\n- A conditional branch is executed in every iteration. The branch is predicted correctly with accuracy $a$. A misprediction occurs with probability $1-a$ and incurs a penalty of $M$ cycles. The base cost of a resolved branch is $B$. The expected cost of the branch, $E_{\\text{branch}}$, is therefore:\n$$E_{\\text{branch}} = a \\cdot B + (1-a) \\cdot (B+M) = B + (1-a)M$$\n- The body of the conditional statement is executed only when $P(i)$ is true, which occurs with probability $p$. The operations in the body are a load from $A[i]$ (cost $L$), an addition (cost $U$), and a store to $A[i]$ (cost $T$). The expected cost of the body is:\n$$E_{\\text{body}} = p \\cdot (L + U + T)$$\nSumming these components gives the total expected cost for the first loop per iteration:\n$$E_1 = Q + E_{\\text{branch}} + E_{\\text{body}} = Q + B + (1-a)M + p(L+U+T)$$\nSubstituting the given numerical values: $p = 0.3$, $a = 0.85$, $B = 1$, $M = 12$, $Q = 1$, $L = 4$, $T = 4$, and $U = 1$.\n$$E_1 = 1 + 1 + (1-0.85) \\cdot 12 + 0.3 \\cdot (4+1+4)$$\n$$E_1 = 2 + (0.15) \\cdot 12 + 0.3 \\cdot 9$$\n$$E_1 = 2 + 1.8 + 2.7 = 6.5 \\text{ cycles}$$\n\nThe second loop is: for each $i$, perform $S \\leftarrow S + A[i]$.\nThis loop is unconditional. The cost per iteration, $E_2$, is the sum of the costs of its operations: a load from $A[i]$ (cost $L$) and an addition (cost $U$).\n$$E_2 = L + U$$\nSubstituting the given values:\n$$E_2 = 4 + 1 = 5 \\text{ cycles}$$\n\nThe total expected cost for the baseline is the sum of the costs of the two loops:\n$$E_{\\text{baseline}} = E_1 + E_2 = 6.5 + 5 = 11.5 \\text{ cycles}$$\n\nNext, we calculate $E_{\\text{fused}}$. The fused loop eliminates the conditional branch using predication (a conditional move). All operations are executed in every iteration, so the cost is deterministic.\nThe sequence of operations per iteration is:\n1. Evaluate predicate $P(i)$: cost $Q$.\n2. Load $A[i]$: cost $L$.\n3. Compute candidate update $A_{\\text{new}} = A[i] + C$: cost $U$.\n4. Select between $A[i]$ and $A_{\\text{new}}$ using a conditional move: cost $R$.\n5. Store the selected result $A'[i]$ back to memory: cost $T$.\n6. Accumulate $A'[i]$ into $S$: cost $U$.\n\nThe total cost, $E_{\\text{fused}}$, is the sum of the costs of these operations, as instruction overlap is to be ignored.\n$$E_{\\text{fused}} = Q + L + U + R + T + U = Q + L + T + R + 2U$$\nSubstituting the given numerical values: $Q = 1$, $L = 4$, $T = 4$, $R = 1$, and $U = 1$.\n$$E_{\\text{fused}} = 1 + 4 + 4 + 1 + 2(1)$$\n$$E_{\\text{fused}} = 1 + 4 + 4 + 1 + 2 = 12 \\text{ cycles}$$\n\nFinally, we compute the speedup ratio $S$:\n$$S = \\frac{E_{\\text{baseline}}}{E_{\\text{fused}}} = \\frac{11.5}{12}$$\nTo express this as an exact fraction:\n$$S = \\frac{11.5 \\cdot 2}{12 \\cdot 2} = \\frac{23}{24}$$", "answer": "$$\\boxed{\\frac{23}{24}}$$", "id": "3652603"}]}