{"hands_on_practices": [{"introduction": "At the heart of induction variable optimization lies the powerful technique of strength reduction. This practice challenges you to apply this core concept by transforming a loop where a variable is calculated using multiplication into a more efficient version that uses only addition. By deriving the transformed code and proving that it produces the exact same result, you will gain a foundational understanding of how compilers can make programs faster while guaranteeing correctness [@problem_id:3644333].", "problem": "In the context of global optimization strategies in compiler principles, consider the loop strength reduction of an induction variable. Let $A$ be an array over the integers defined by $A[k] = k$ for all integers $k$. Let $L$, $U$, $s$, and $c$ be integers with $s \\in \\mathbb{Z}_{0}$, $U  L$, and $s$ divides $U - L$. Consider the following program fragment that accumulates into a scalar $sum$:\n- Initialize $sum := 0$.\n- For $i := L$; while $i  U$; do $i := i + s$:\n  - Let $x := i \\cdot 2 + c$.\n  - Update $sum := sum + A[x]$.\n\nUsing only the operational semantics of the loop and the definition of an induction variable, derive a strength-reduced version of this loop that replaces the multiplication by $2$ inside the loop with an increment of a derived variable that is updated by a loop-invariant increment each iteration, while preserving the programâ€™s observable behavior on $sum$. Prove that the transformation is semantics-preserving by explicitly relating the values accumulated before and after the transformation.\n\nFinally, compute a closed-form analytic expression for the value of $sum$ at loop exit in terms of $L$, $U$, $s$, and $c$. Express your answer as a single simplified analytic expression. No rounding is required, and no units are involved. The final answer must be a single expression.", "solution": "The problem asks for three things: first, to perform loop strength reduction on a given program fragment; second, to prove that this transformation is semantics-preserving; and third, to compute a closed-form analytic expression for the final value of the accumulator variable `sum`.\n\nThe original program fragment is:\n- Initialize $sum := 0$.\n- For $i := L$; while $i  U$; do $i := i + s$:\n  - Let $x := i \\cdot 2 + c$.\n  - Update $sum := sum + A[x]$.\n\nThe givens are:\n- $A$ is an array such that $A[k] = k$ for all integers $k$.\n- $L, U, s, c$ are integers.\n- $s \\in \\mathbb{Z}_{0}$, $U  L$, and $s$ divides $U - L$.\n\n**Part 1: Loop Strength Reduction**\n\nThe variable $i$ is the basic induction variable of the loop. It is initialized to $L$ and incremented by the loop-invariant value $s$ in each iteration.\nThe variable $x$ is a derived induction variable, as its value in each iteration is a linear function of the basic induction variable $i$: $x = 2i + c$.\n\nLet's analyze the values of $i$ and $x$ in successive iterations. Let $i_j$ and $x_j$ be the values of $i$ and $x$ in iteration $j$ (for $j=0, 1, 2, \\dots$).\nThe value of $i$ in the next iteration, $i_{j+1}$, is $i_{j+1} = i_j + s$.\nThe corresponding value of $x$, $x_{j+1}$, is:\n$$x_{j+1} = 2 \\cdot i_{j+1} + c = 2 \\cdot (i_j + s) + c = (2 \\cdot i_j + c) + 2 \\cdot s$$\nRecognizing that $x_j = 2 \\cdot i_j + c$, we have the recurrence relation:\n$$x_{j+1} = x_j + 2s$$\nThis shows that the value of $x$ is incremented by a loop-invariant constant, $2s$, in each iteration. The multiplication $i \\cdot 2$ can therefore be replaced by an addition. This is the core of strength reduction.\n\nWe introduce a new variable, let's call it $x'$, that will track the value of $x$.\n1.  Before the loop, $x'$ must be initialized to the value $x$ would have in the first iteration. The first value of $i$ is $L$, so we initialize $x' := 2 \\cdot L + c$.\n2.  Inside the loop, we use $x'$ in place of the expression $2 \\cdot i + c$. The update to `sum` becomes $sum := sum + A[x']$.\n3.  After its use, we update $x'$ for the next iteration using the derived recurrence: $x' := x' + 2s$.\n\nThe strength-reduced program fragment is:\n- Initialize $sum := 0$.\n- Initialize $x' := 2 \\cdot L + c$.\n- For $i := L$; while $i  U$; do $i := i + s$:\n  - Update $sum := sum + A[x']$.\n  - Update $x' := x' + 2s$.\n\n**Part 2: Proof of Semantics Preservation**\n\nWe must prove that the strength-reduced loop computes the same final value for `sum` as the original loop.\nLet the sequence of values taken by the loop control variable $i$ be $i_0, i_1, \\dots, i_{N-1}$, where $N$ is the total number of iterations. We have $i_j = L + j \\cdot s$.\n\nIn the original loop, the value of $x$ used in iteration $j$ is $x_j$:\n$$x_j = 2 \\cdot i_j + c = 2(L + j \\cdot s) + c = 2L + c + 2sj$$\nThe sequence of values added to `sum` is $A[x_0], A[x_1], \\dots, A[x_{N-1}]$.\n\nIn the transformed loop, a new variable $x'$ is used. Let's denote its value at the beginning of iteration $j$ as $x'_j$.\n- Initialization: Before the loop starts, $x'$ is initialized to $x'_0 = 2L + c$. This is the value used in the first iteration ($j=0$).\n- Update: At the end of iteration $j$, $x'$ is updated to be used in iteration $j+1$: $x'_{j+1} = x'_j + 2s$.\n\nWe can find a closed-form for $x'_j$ by unrolling the recurrence:\n$x'_0 = 2L + c$\n$x'_1 = x'_0 + 2s = (2L+c) + 2s$\n$x'_2 = x'_1 + 2s = (2L+c) + 2s + 2s = 2L+c + 2(2s)$\nBy induction, the value of $x'$ used in iteration $j$ is:\n$$x'_j = 2L + c + j \\cdot 2s$$\nComparing the value $x_j$ from the original loop and $x'_j$ from the transformed loop, we see that $x_j = x'_j$ for all $j=0, 1, \\dots, N-1$.\nSince the sequence of values used as indices into array $A$ is identical for both loops ($x_0, x_1, \\dots$ and $x'_0, x'_1, \\dots$), and the `sum` variable is initialized to $0$ in both cases, the sequence of values $A[x_j]$ added to `sum` is identical. Therefore, the final value of `sum` is the same, and the transformation is semantics-preserving.\n\n**Part 3: Closed-Form Expression for `sum`**\n\nThe final value of `sum` is the sum of $A[x]$ over all loop iterations. Since $A[k]=k$, this is the sum of the values of $x$ themselves.\n$$sum = \\sum_{j=0}^{N-1} x_j$$\nFirst, we determine the number of iterations, $N$. The loop continues as long as $i  U$. The values of $i$ are $L, L+s, L+2s, \\dots, L+(N-1)s$. The loop terminates when $i \\ge U$. So, the last iteration is the one for which $L+(N-1)s  U$.\n$$ (N-1)s  U-L \\implies N-1  \\frac{U-L}{s} \\implies N  \\frac{U-L}{s} + 1 $$\nWe are given that $s$ divides $U-L$. Let $\\frac{U-L}{s} = K$, where $K$ is a positive integer.\nThe condition becomes $N  K+1$. Since $N$ must be an integer, the number of iterations is $N=K$.\nThus, the number of iterations is $N = \\frac{U-L}{s}$.\n\nNow we compute the sum. The terms being added, $x_j = 2L + c + 2sj$, form an arithmetic progression.\nThe sum of an arithmetic progression is given by $S_N = \\frac{N}{2}(\\text{first term} + \\text{last term})$.\n- Number of terms: $N = \\frac{U-L}{s}$.\n- First term ($j=0$): $x_0 = 2L + c$.\n- Last term ($j=N-1$): $x_{N-1} = 2L + c + 2s(N-1)$.\n\nThe sum is:\n$$ sum = \\frac{N}{2}(x_0 + x_{N-1}) = \\frac{N}{2}((2L+c) + (2L+c+2s(N-1))) $$\n$$ sum = \\frac{N}{2}(4L + 2c + 2s(N-1)) = N(2L+c+s(N-1)) $$\nNow, substitute $N = \\frac{U-L}{s}$:\n$$ sum = \\left(\\frac{U-L}{s}\\right) \\left(2L+c+s\\left(\\frac{U-L}{s}-1\\right)\\right) $$\n$$ sum = \\left(\\frac{U-L}{s}\\right) (2L+c+(U-L)-s) $$\nSimplifying the expression in the parentheses:\n$$ sum = \\left(\\frac{U-L}{s}\\right) (L+U+c-s) $$\nThis is the final closed-form analytic expression for `sum`.", "answer": "$$ \\boxed{\\frac{(U-L)(L+U+c-s)}{s}} $$", "id": "3644333"}, {"introduction": "Compiler optimizations are most powerful when they work in synergy. This exercise explores the crucial interplay between loop unrolling and induction variable elimination, a common pairing in high-performance computing. You will analyze an unrolled loop and discover how to eliminate redundant address calculations, ultimately deriving a formula that quantifies the significant performance gains in terms of saved multiplication operations [@problem_id:3645835].", "problem": "Consider a loop over an induction variable (IV) $i$ that computes an elementwise sum into a destination array with affine index expressions. Let $X$, $Y$, and $Z$ be arrays of elements (assume unit element size for simplicity), and let $p_{X}$, $p_{Y}$, $p_{Z}$ be constant base offsets and $s_{X}$, $s_{Y}$, $s_{Z}$ be constant strides, all known at compile time. The loop is\n$$\n\\text{for } i = 0, 1, \\dots, n-1:\\quad Z[p_{Z} + s_{Z} \\cdot i] \\leftarrow X[p_{X} + s_{X} \\cdot i] + Y[p_{Y} + s_{Y} \\cdot i].\n$$\nAssume $n$ is a positive integer divisible by a chosen unroll factor $u \\geq 2$. Unroll the loop by factor $u$, introducing the derived induction variables $i+0, i+1, \\dots, i+(u-1)$ to index the $u$ lanes within each unrolled group. Work under the following cost model for integer address arithmetic:\n- Evaluating an affine index $p + s \\cdot q$ at runtime incurs exactly one integer multiplication (for $s \\cdot q$) and one integer addition (for adding $p$), when $q$ is a runtime-varying quantity.\n- Adding a compile-time constant to a runtime value incurs exactly one integer addition and incurs no integer multiplications.\n- All constants $p_{X}$, $p_{Y}$, $p_{Z}$, $s_{X}$, $s_{Y}$, $s_{Z}$, and the lane index $k \\in \\{0,1,\\dots,u-1\\}$ are compile-time constants.\n\nTasks:\n1. Using the definitions of an induction variable and loop unrolling, express the $u$ lane indices in terms of $i$ and $k$ and write the naive unrolled affine indices for each of $X$, $Y$, and $Z$.\n2. Show how to eliminate the $u$ derived IVs $i+0, i+1, \\dots, i+(u-1)$ from the affine indices by introducing, for each array, a base pointer computed once per unrolled group and multiple constant offsets for the $u$ lanes. Provide the resulting affine forms for all three arrays in a single unrolled group.\n3. Under the stated cost model, compare the naive unrolled address computation to the induction-variable-eliminated computation and derive a closed-form expression, in terms of $n$ and $u$, for the total number of integer multiplications saved across the entire execution of the unrolled loop (assume no remainder iteration, i.e., $n$ divisible by $u$). Provide your final result as a single analytic expression.\n\nNo numerical rounding is required. The final answer must be a single closed-form analytic expression in $n$ and $u$.", "solution": "**Task 1: Naive Unrolled Affine Indices**\n\nThe original loop iterates with an induction variable $i$ from $0$ to $n-1$.\n$$ \\text{for } i = 0, 1, \\dots, n-1: \\quad Z[p_{Z} + s_{Z} \\cdot i] \\leftarrow X[p_{X} + s_{X} \\cdot i] + Y[p_{Y} + s_{Y} \\cdot i] $$\nUnrolling this loop by a factor of $u$ transforms it into a new loop that executes $n/u$ times. The new loop's induction variable, which we will continue to call $i$, iterates through the values $0, u, 2u, \\dots, n-u$. Each iteration of this new loop performs the work of $u$ iterations of the original loop.\n\nThe group of original iterations corresponding to a single new iteration $i$ are those for original indices $i+k$, where the lane index $k$ ranges from $0$ to $u-1$. To obtain the naive unrolled code, we substitute $i+k$ for the original induction variable in the address calculation expressions.\n\nFor each array $A \\in \\{X, Y, Z\\}$ and for each lane $k \\in \\{0, 1, \\dots, u-1\\}$, the affine index expression is:\n$$ \\text{address}(A, i, k) = p_{A} + s_{A} \\cdot (i+k) $$\nThe unrolled loop body thus consists of $u$ statements of the form:\n$$ Z[p_{Z} + s_{Z} \\cdot (i+k)] \\leftarrow X[p_{X} + s_{X} \\cdot (i+k)] + Y[p_{Y} + s_{Y} \\cdot (i+k)] $$\nfor $k = 0, 1, \\dots, u-1$. These are the naive unrolled affine indices.\n\n**Task 2: Elimination of Derived Induction Variables**\n\nThe goal is to reduce the number of expensive operations (multiplications) required for address calculation. We achieve this through algebraic manipulation of the affine index expression. This technique is a form of strength reduction.\n\nConsider the naive affine index for an arbitrary array $A$:\n$$ p_{A} + s_{A} \\cdot (i+k) $$\nUsing the distributive property of multiplication over addition, we can rewrite this as:\n$$ p_{A} + s_{A} \\cdot i + s_{A} \\cdot k $$\nWe can regroup the terms based on whether they depend on the runtime loop variable $i$ or are compile-time constants:\n$$ \\left( p_{A} + s_{A} \\cdot i \\right) + \\left( s_{A} \\cdot k \\right) $$\nThis form suggests a more efficient way to compute the addresses.\nFor each unrolled group (i.e., for each iteration of the new loop variable $i$):\n1.  Compute a base pointer for each array, once per group. This base pointer corresponds to the address for the first lane ($k=0$):\n    $$ \\text{base\\_ptr}_{A}(i) = p_{A} + s_{A} \\cdot i $$\n2.  For each lane $k \\in \\{0, 1, \\dots, u-1\\}$, compute the final address by adding a constant offset to the base pointer. This offset is known at compile-time:\n    $$ \\text{offset}_{A}(k) = s_{A} \\cdot k $$\nThe resulting affine form for lane $k$ is:\n$$ \\text{address}(A, i, k) = \\text{base\\_ptr}_{A}(i) + \\text{offset}_{A}(k) $$\nThis reformulation eliminates the multiplication by the runtime variable $i$ from the calculation for each of the $u-1$ subsequent lanes, replacing it with an addition of a pre-computed constant.\n\n**Task 3: Cost Comparison and Savings**\n\nWe now analyze the total number of integer multiplications under the provided cost model for both the naive and optimized unrolled loops, and then calculate the savings. The analysis covers the entire execution of the loop, which consists of $n/u$ iterations of the unrolled loop.\n\n**Cost of Naive Unrolled Address Computation:**\nThe new loop runs $n/u$ times. In each iteration, we process $u$ lanes. For each lane $k$, we compute $3$ addresses (for $X$, $Y$, and $Z$). The address calculation is of the form $p_{A} + s_{A} \\cdot (i+k)$. Since $i$ is a runtime variable, the quantity $i+k$ is also a runtime-varying quantity. According to the cost model, evaluating $p+s \\cdot q$ where $q$ varies at runtime costs $1$ multiplication.\n- Multiplications per lane: $3$ (one for each of $X, Y, Z$).\n- Multiplications per unrolled group: $u \\text{ lanes} \\times 3 \\text{ mults/lane} = 3u$.\n- Total multiplications for the entire loop: $(n/u) \\text{ groups} \\times 3u \\text{ mults/group} = 3n$.\nSo, the total number of multiplications in the naive unrolled loop is $M_{\\text{naive}} = 3n$. This is identical to the original, non-unrolled loop.\n\n**Cost of Induction-Variable-Eliminated Computation:**\nThe new loop runs $n/u$ times. In each iteration of the unrolled loop (for a given $i$):\n1.  We compute the $3$ base pointers, one for each array: $\\text{base\\_ptr}_{X}(i)$, $\\text{base\\_ptr}_{Y}(i)$, $\\text{base\\_ptr}_{Z}(i)$. Each computation is of the form $p_A + s_A \\cdot i$. Since $i$ is a runtime variable, this costs $1$ multiplication per base pointer.\n    - Multiplications for all base pointers in one group: $3$.\n2.  For each of the $u$ lanes, we compute the final address by adding a compile-time constant offset: $\\text{address}(A, i, k) = \\text{base\\_ptr}_{A}(i) + \\text{offset}_{A}(k)$. According to the cost model, adding a constant to a runtime value costs $0$ multiplications.\n    - Multiplications for lane-specific offsets: $0$.\n- Total multiplications per unrolled group: $3 + 0 = 3$.\n- Total multiplications for the entire loop: $(n/u) \\text{ groups} \\times 3 \\text{ mults/group} = \\frac{3n}{u}$.\nSo, the total number of multiplications in the optimized loop is $M_{\\text{optimized}} = \\frac{3n}{u}$.\n\n**Total Integer Multiplications Saved:**\nThe savings are the difference between the cost of the naive computation and the optimized computation.\n$$ \\text{Savings} = M_{\\text{naive}} - M_{\\text{optimized}} $$\n$$ \\text{Savings} = 3n - \\frac{3n}{u} $$\nFactoring out $3n$, we get:\n$$ \\text{Savings} = 3n \\left(1 - \\frac{1}{u}\\right) $$\nWriting this as a single fraction gives the final closed-form expression:\n$$ \\text{Savings} = \\frac{3n(u-1)}{u} $$", "answer": "$$\n\\boxed{\\frac{3n(u-1)}{u}}\n$$", "id": "3645835"}, {"introduction": "The best optimizations are those that are tailored to the underlying hardware. This hands-on problem moves from abstract theory to practical application by introducing a realistic architectural constraint: the limited size of immediate values in instructions. Your task is to find the optimal loop stride that maximizes performance by reducing loop iterations, while ensuring the resulting pointer arithmetic is valid on the target machine, showcasing the constrained nature of real-world compiler design [@problem_id:3645833].", "problem": "Consider a loop in a compiler intermediate representation that computes an accumulation over two arrays with linear index expressions derived from a single loop counter. Let $A$ and $B$ be arrays of $32$-bit integers, so each element has size $e=4$ bytes. The loop is\n$$\n\\text{for } i = 0,1,2,\\dots,N-1:\\quad x \\leftarrow x + g\\!\\left(A[2i + c_1],\\, B[3i + c_2]\\right),\n$$\nwhere $N=4080$ and $c_1,c_2 \\in \\mathbb{Z}$ are fixed offsets chosen so that all accesses are within bounds. Assume a Reduced Instruction Set Computer (RISC) architecture where pointer increments use a single add-immediate instruction whose immediate field is a signed $12$-bit constant. This makes the representable byte increment bounded by $I_{\\max} = 2047$.\n\nYou are to perform induction variable analysis and elimination. Formalize $i$ as a Basic Induction Variable (BIV) and recognize both $2i+c_1$ and $3i+c_2$ as linear functions of an induction variable. Introduce pointer variables $p_A$ and $p_B$ such that the loop is rewritten using independent pointer bumps with strides proportional to a chosen BIV stride $s \\in \\mathbb{Z}_{0}$ (in iterations), eliminating $i$ from address arithmetic. In this transformed loop, the pointer update per iteration is in bytes,\n$$\n\\Delta_A(s) = (2s)\\,e,\\qquad \\Delta_B(s) = (3s)\\,e.\n$$\n\nUnder the following constraints:\n- Both pointer increments must be encodable as a single add-immediate, i.e., $|\\Delta_A(s)| \\leq I_{\\max}$ and $|\\Delta_B(s)| \\leq I_{\\max}$.\n- The BIV stride must evenly partition the trip count to avoid a remainder loop, i.e., $s \\mid N$.\n\nChoose $s$ to minimize the dynamic loop overhead by reducing the number of iterations, which is equivalent to maximizing $s$ subject to the constraints above. Determine the optimal stride $s^{\\ast}$.\n\nYour final answer must be the single integer value of $s^{\\ast}$. No rounding is required, and no units should be included in the final boxed answer.", "solution": "The problem asks for the optimal stride $s^{\\ast}$ for loop transformation, specifically induction variable elimination. The goal is to maximize the stride $s \\in \\mathbb{Z}_{0}$ in order to minimize the total number of loop iterations, subject to architectural and loop structure constraints.\n\nThe problem can be formulated as an optimization problem:\nMaximize $s$\nSubject to:\n1.  The pointer increments for arrays $A$ and $B$ must be encodable within a single instruction.\n2.  The stride $s$ must evenly divide the total number of iterations $N$.\n\nLet's analyze each constraint mathematically.\n\nThe givens are:\n- The loop trip count is $N=4080$.\n- The element size for the arrays $A$ and $B$ is $e=4$ bytes (for $32$-bit integers).\n- The maximum immediate value for the pointer increment instruction is $I_{\\max} = 2047$.\n- The pointer increments per transformed loop iteration (which corresponds to a stride of $s$ original iterations) are given as $\\Delta_A(s) = (2s)e$ and $\\Delta_B(s) = (3s)e$.\n- The stride $s$ must be a positive integer, $s \\in \\mathbb{Z}_{0}$.\n\nConstraint 1: Instruction Encoding\nThe magnitude of the pointer increments in bytes must not exceed the maximum value representable by the immediate field of the instruction. This is given by:\n$$|\\Delta_A(s)| \\leq I_{\\max}$$\n$$|\\Delta_B(s)| \\leq I_{\\max}$$\n\nSince $s$ is a positive integer ($s  0$) and the element size $e=4$ is positive, the increments $\\Delta_A(s)$ and $\\Delta_B(s)$ are always positive. Therefore, the absolute value signs are redundant. The constraints become:\n$$(2s)e \\leq I_{\\max}$$\n$$(3s)e \\leq I_{\\max}$$\n\nWe can solve these inequalities for $s$.\nFor the first inequality, involving array $A$:\n$$s \\leq \\frac{I_{\\max}}{2e}$$\nSubstituting the given values $I_{\\max} = 2047$ and $e=4$:\n$$s \\leq \\frac{2047}{2 \\times 4} = \\frac{2047}{8} = 255.875$$\n\nFor the second inequality, involving array $B$:\n$$s \\leq \\frac{I_{\\max}}{3e}$$\nSubstituting the given values $I_{\\max} = 2047$ and $e=4$:\n$$s \\leq \\frac{2047}{3 \\times 4} = \\frac{2047}{12} \\approx 170.583$$\n\nFor $s$ to be a valid stride, it must satisfy both conditions simultaneously. Therefore, $s$ must be less than or equal to the minimum of the two upper bounds:\n$$s \\leq \\min\\left(\\frac{2047}{8}, \\frac{2047}{12}\\right)$$\nThe more restrictive (smaller) bound is from the second inequality:\n$$s \\leq \\frac{2047}{12}$$\nSince $s$ must be an integer, we take the floor of this value:\n$$s \\leq \\left\\lfloor \\frac{2047}{12} \\right\\rfloor$$\nTo find the floor, we perform the division: $2047 = 12 \\times 170 + 7$. Thus, $\\lfloor \\frac{2047}{12} \\rfloor = 170$.\nSo, the instruction encoding constraint imposes an upper bound on the stride:\n$$s \\leq 170$$\n\nConstraint 2: Loop Partitioning\nThe problem states that the chosen stride $s$ must evenly partition the total loop trip count $N$ to avoid a \"remainder\" or \"epilogue\" loop. This is a divisibility constraint:\n$$s \\mid N$$\nGiven $N=4080$, this means $s$ must be a divisor of $4080$.\n\nCombining the Constraints\nWe are looking for the optimal stride $s^{\\ast}$ which is the maximum value of $s$ that satisfies both constraints:\n1.  $s \\leq 170$\n2.  $s \\mid 4080$\n\nThe problem is now reduced to finding the largest divisor of $4080$ that is less than or equal to $170$.\nWe can find this by checking integers downwards from $170$ to see if they are divisors of $4080$. The first such integer we find will be the maximum possible value for $s$.\n\nLet's test $s=170$. We need to check if $170$ divides $4080$.\n$$\\frac{4080}{170} = \\frac{408}{17}$$\nPerforming the division:\n$17 \\times 20 = 340$.\n$408 - 340 = 68$.\n$17 \\times 4 = 68$.\nSo, $17 \\times 24 = 408$.\nTherefore, $\\frac{4080}{170} = 24$.\nSince the result is an integer, $170$ is a divisor of $4080$.\n\nThe value $s=170$ satisfies both constraints:\n1.  $170 \\leq 170$ (True)\n2.  $170 \\mid 4080$ (True)\n\nSince we seek to maximize $s$, and we have found a value $s=170$ that satisfies the divisibility constraint and is also the maximum value allowed by the encoding constraint, this must be the optimal stride.\nAny value of $s  170$ would violate the encoding constraint for $\\Delta_B$. Any divisor of $4080$ smaller than $170$ would result in a less optimal (smaller) stride.\nThus, the optimal stride is $s^{\\ast} = 170$.\nWith this stride, the transformed loop will run for $N/s^{\\ast} = 4080/170 = 24$ iterations, significantly reducing loop overhead. The pointer increments within the new loop body will be $\\Delta_A = 2 \\times 170 \\times 4 = 1360$ bytes and $\\Delta_B = 3 \\times 170 \\times 4 = 2040$ bytes. Both are less than or equal to $I_{\\max}=2047$.", "answer": "$$\\boxed{170}$$", "id": "3645833"}]}