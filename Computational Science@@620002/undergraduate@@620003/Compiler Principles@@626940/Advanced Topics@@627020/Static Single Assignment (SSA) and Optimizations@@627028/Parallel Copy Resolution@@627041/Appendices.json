{"hands_on_practices": [{"introduction": "Resolving a parallel copy boils down to breaking dependency cycles. This first practice focuses on the elementary case of a single 3-cycle, the essential building block for understanding the entire problem. By working through this hypothetical scenario [@problem_id:3661088], you will prove from first principles why a temporary register is indispensable and derive the minimal number of instructions required, establishing a foundational rule for more complex cases.", "problem": "You are given a machine model with a finite set of registers and only a single-operand move operation available, denoted $\\mathrm{mov}(s, d)$, which copies the current contents of source register $s$ into destination register $d$, overwriting $d$. Consider the following parallel copy specification (a simultaneous assignment) over registers $r_1, r_2, r_3$:\n- $r_1 := r_3$\n- $r_2 := r_1$\n- $r_3 := r_2$\n\nAssume the initial contents of $r_1, r_2, r_3$ are distinct symbolic values $x_1, x_2, x_3$, respectively, and that only register-to-register moves are allowed (no memory, no swap primitives, no arithmetic). You may use at most one extra scratch register $t$ as a temporary buffer. A sequentialization is a finite sequence of $\\mathrm{mov}$ operations that, when executed from the initial state, realizes exactly the effect of the parallel copy (so that at the end, $r_1$ contains $x_3$, $r_2$ contains $x_1$, and $r_3$ contains $x_2$).\n\nFrom first principles of parallel copy semantics and move operations, do the following:\n- Argue precisely why any attempt to realize this parallel copy with zero temporaries must fail.\n- Construct a correct sequentialization using at most one temporary register $t$.\n- Prove a lower bound on the number of move instructions required by any correct sequentialization under these constraints, and show that your construction meets this bound.\n\nLet $M^{\\star}$ denote the minimal possible number of $\\mathrm{mov}$ instructions among all correct sequentializations that use the fewest possible temporaries under the stated constraints. What is $M^{\\star}$? Provide only the value of $M^{\\star}$ as your final numerical answer. No rounding is needed, and include no units with your answer.", "solution": "We formalize the situation and derive lower bounds from core definitions.\n\nFundamental definitions and facts:\n- A parallel copy is a simultaneous assignment that maps each destination register to the value of its specified source in the pre-state. The required final state means $r_1$ gets the original value of $r_3$, $r_2$ gets the original of $r_1$, and $r_3$ gets the original of $r_2$. This corresponds to the assignments $r_1 := r_3$, $r_2 := r_1$, and $r_3 := r_2$. The initial values are $r_1 = x_1$, $r_2 = x_2$, $r_3 = x_3$, where $x_1, x_2, x_3$ are pairwise distinct.\n- A move operation $\\mathrm{mov}(s, d)$ copies the current content of $s$ into $d$, overwriting $d$. It cannot read from or write to more than one register at a time, and there is no atomic swap. The only way to preserve a value that is about to be overwritten is to copy it somewhere else before it is destroyed.\n\nStep $1$: Why zero temporaries are impossible.\n- The assignments form a directed dependency cycle $r_1 \\to r_3 \\to r_2 \\to r_1$ of length $3$. In such a cycle, every register’s current value is required as the source for some other register’s target.\n- Suppose there were a correct sequentialization with zero temporaries. Consider the first move $\\mathrm{mov}(s, d)$. Since all targets $r_1, r_2, r_3$ must eventually be written, $d$ must be one of $\\{r_1, r_2, r_3\\}$. Without loss of generality, say the first move is $\\mathrm{mov}(r_1, r_2)$. After this move, $r_2$ holds $x_1$, but the original value $x_2$ previously in $r_2$ has been destroyed and exists nowhere else, because no temporary or memory is available and we have not previously saved it. However, the parallel copy requires that $x_2$ be placed into $r_3$ at the end, which is now impossible. The same contradiction arises regardless of which edge is realized first, because the cycle has no node with in-degree $0$ that could be safely overwritten first.\n- Therefore, at least one temporary buffer is necessary to preserve one value while its register is overwritten. Hence, zero temporaries are impossible.\n\nStep $2$: A correct sequentialization using one temporary.\n- Introduce a single scratch register $t$ and use it exactly once as a buffer. One valid sequence is:\n  - $\\mathrm{mov}(r_1, t)$, so $t \\leftarrow x_1$.\n  - $\\mathrm{mov}(r_3, r_1)$, so $r_1 \\leftarrow x_3$.\n  - $\\mathrm{mov}(r_2, r_3)$, so $r_3 \\leftarrow x_2$.\n  - $\\mathrm{mov}(t, r_2)$, so $r_2 \\leftarrow x_1$.\n- Final state: $r_1 = x_3$, $r_2 = x_1$, $r_3 = x_2$, exactly matching the parallel copy. This sequence uses $1$ temporary and has $4$ moves.\n\nStep $3$: A lower bound on the number of moves.\nWe argue a lower bound that applies to any correct sequentialization under the stated constraints.\n\n- Each destination register in $\\{r_1, r_2, r_3\\}$ must be written at least once to realize the new values. Let $W_D$ denote the number of writes to the destination set $D = \\{r_1, r_2, r_3\\}$. Then $W_D \\geq 3$, because each of $r_1, r_2, r_3$ must receive its final value via some move.\n- From Step $1$, at least one temporary is necessary. Let $W_T$ denote the number of writes to any temporary registers. Because at least one value must be buffered before its original register is overwritten, we must write to a temporary at least once, so $W_T \\geq 1$.\n- The total number of move instructions $W$ is the number of writes to destinations plus the number of writes to temporaries, counting that any write to a temporary is not a write to a destination: $W = W_D + W_T$. Combining the bounds gives $W \\geq 3 + 1 = 4$.\n- Therefore, any correct sequentialization must use at least $4$ moves.\n\nStep $4$: Tightness of the bound and minimality.\n- The sequence in Step $2$ uses exactly $1$ temporary and $4$ moves, meeting the lower bound. Hence the bound is tight.\n- Consequently, the minimal possible number of moves among sequentializations that use the fewest possible temporaries is $M^{\\star} = 4$.\n\nThus, $M^{\\star}$ equals $4$.", "answer": "$$\\boxed{4}$$", "id": "3661088"}, {"introduction": "While a single cycle is a great learning tool, real-world parallel copies often involve numerous assignments across many registers. The key is to see that these complex sets can be decomposed into independent, disjoint cycles that can be solved separately. This exercise [@problem_id:3661148] challenges you to perform this decomposition and then apply the cycle-resolution algorithm to find the total number of moves for a larger permutation.", "problem": "A compiler backend must resolve a parallel copy arising during register allocation in Static Single Assignment (SSA) form. The semantics of a parallel copy are that all assignments happen simultaneously: for each assignment $d := s$ in the set, the post-copy value in destination register $d$ must equal the pre-copy value that was in source register $s$ before any assignment executes. The machine provides only simple move instructions of the form $x := y$, and no swap or rotate instructions. You are allowed to use a single temporary register per cycle to preserve values during resolution.\n\nConsider the machine registers $r_1, r_2, \\dots, r_{10}$ and the following parallel copy, specified as a set of destination–source assignments:\n- $r_1 := r_4$\n- $r_4 := r_1$\n- $r_2 := r_5$\n- $r_5 := r_7$\n- $r_7 := r_2$\n- $r_3 := r_9$\n- $r_9 := r_6$\n- $r_6 := r_3$\n- $r_8 := r_8$\n- $r_{10} := r_{10}$\n\nTasks:\n1. Starting from first principles of parallel copy semantics, argue why this set of assignments defines a permutation on registers with some fixed points, and decompose the permutation into disjoint cycles and fixed points.\n2. For each nontrivial cycle (of length greater than $1$), design an optimal sequential move sequence that uses exactly one temporary register for that cycle and preserves the parallel copy semantics. Justify the optimality of the number of moves for each cycle from fundamental reasoning.\n3. Compute the minimal total number of move instructions that your optimal scheme emits to realize the entire parallel copy. Your final submitted answer must be this single integer, expressed with no units and no rounding.", "solution": "The problem asks for an analysis of a parallel copy operation, its decomposition into a permutation, the design of an optimal move sequence for its constituent cycles, and the calculation of the total number of moves required.\n\n**1. Permutation Definition and Decomposition**\n\nA parallel copy is a set of assignments $\\{d_i := s_i\\}$ that are conceptually executed simultaneously. This means that for every assignment $d_i := s_i$, the value read from the source register $s_i$ is its value *before* any of the assignments take place.\n\nThis set of assignments can be modeled as a permutation $\\pi$ on the set of registers $R = \\{r_1, r_2, \\dots, r_{10}\\}$. The assignment $d := s$ means that the value from source register $s$ moves to destination register $d$. Since each register in $R$ appears as a destination exactly once, the mapping is a bijection on the finite set $R$, and is therefore a permutation.\n\nThe data dependencies are as follows:\n- $r_1 := r_4$ and $r_4 := r_1$ form the dependency cycle $r_1 \\to r_4 \\to r_1$.\n- $r_2 := r_5$, $r_5 := r_7$, and $r_7 := r_2$ form the dependency cycle $r_2 \\to r_7 \\to r_5 \\to r_2$.\n- $r_3 := r_9$, $r_9 := r_6$, and $r_6 := r_3$ form the dependency cycle $r_3 \\to r_6 \\to r_9 \\to r_3$.\n- $r_8 := r_8$ and $r_{10} := r_{10}$ are self-dependencies, or fixed points.\n\nAny permutation on a finite set can be uniquely decomposed into a set of disjoint cycles. By tracing the dependencies, we find:\n\n- Starting with $r_1$: The value of $r_1$ goes to $r_4$, and the value of $r_4$ goes to $r_1$. This is a 2-cycle, which can be written as $(r_1, r_4)$.\n- Starting with $r_2$: The value of $r_2$ goes to $r_7$, $r_7$ to $r_5$, and $r_5$ back to $r_2$. This is a 3-cycle: $(r_2, r_7, r_5)$.\n- Starting with $r_3$: The value of $r_3$ goes to $r_6$, $r_6$ to $r_9$, and $r_9$ back to $r_3$. This is a 3-cycle: $(r_3, r_6, r_9)$.\n- For $r_8$: The value of $r_8$ stays in $r_8$. This is a 1-cycle or fixed point: $(r_8)$.\n- For $r_{10}$: The value of $r_{10}$ stays in $r_{10}$. This is also a fixed point: $(r_{10})$.\n\nThe complete decomposition of the permutation into disjoint cycles is: $(r_1, r_4)$, $(r_2, r_7, r_5)$, $(r_3, r_6, r_9)$, $(r_8)$, and $(r_{10})$.\n\n**2. Optimal Move Sequence for a Cycle**\n\nA cycle of length $k=1$ (a fixed point) corresponds to an assignment of the form $r := r$. This is an identity operation and requires $0$ moves to execute, as the register's value does not change.\n\nA nontrivial cycle of length $k > 1$ represents a cyclic dependency. To execute these assignments sequentially using only simple moves, we must break this dependency. Since there is no `swap` instruction, it is impossible to resolve a cycle with only $k$ moves, as any initial move would destroy a needed value.\n\nTo break the cyclic dependency, we must use a temporary register, let's call it $t$. The standard algorithm for resolving a $k$-cycle requires $k+1$ moves.\n1. Save the value of one register, say $x_1$, into the temporary register. This is $1$ move: $t := x_1$.\n2. Now, $x_1$ can be safely overwritten. We can perform the remaining $k-1$ assignments in a chain. For a cycle $(x_1, x_2, \\dots, x_k)$, the assignments are $x_2 := x_1, x_3 := x_2, \\dots, x_1 := x_k$. A valid sequence is to perform the copies \"backwards\" against the data flow: $x_1 := x_k$, then $x_k := x_{k-1}$, and so on, down to $x_3 := x_2$. This takes $k-1$ moves.\n3. Finally, the value of $x_1$ (saved in $t$) must be moved to its destination, $x_2$. This is $1$ move: $x_2 := t$.\n\nThe total number of moves is $1 + (k-1) + 1 = k+1$. This is optimal because we need at least $k$ moves to change the values of $k$ registers, and at least one extra move is required to break the cycle by using a temporary.\n\nFor the given nontrivial cycles:\n- Cycle $(r_1, r_4)$: Length $k=2$. Requires $k+1 = 2+1 = 3$ moves. (e.g., $t := r_1; r_1 := r_4; r_4 := t$)\n- Cycle $(r_2, r_7, r_5)$: Length $k=3$. Requires $k+1 = 3+1 = 4$ moves. (e.g., $t := r_2; r_2 := r_5; r_5 := r_7; r_7 := t$)\n- Cycle $(r_3, r_6, r_9)$: Length $k=3$. Requires $k+1 = 3+1 = 4$ moves. (e.g., $t := r_3; r_3 := r_9; r_9 := r_6; r_6 := t$)\n\n**3. Minimal Total Number of Moves**\n\nThe total number of moves to realize the entire parallel copy is the sum of the moves required for each disjoint cycle. Since the cycles operate on disjoint sets of registers, we can simply sum the costs.\n\n- Moves for cycle $(r_1, r_4)$ (length $k=2$): $3$\n- Moves for cycle $(r_2, r_7, r_5)$ (length $k=3$): $4$\n- Moves for cycle $(r_3, r_6, r_9)$ (length $k=3$): $4$\n- Moves for fixed point $(r_8)$ (length $k=1$): $0$\n- Moves for fixed point $(r_{10})$ (length $k=1$): $0$\n\nThe minimal total number of move instructions is the sum:\n$$ \\text{Total Moves} = 3 + 4 + 4 + 0 + 0 = 11 $$", "answer": "$$ \\boxed{11} $$", "id": "3661148"}, {"introduction": "Generating correct code is only half the battle; generating *efficient* code is what makes a compiler truly powerful. This practice introduces an economic trade-off common in compiler backends: choosing between generic move instructions and a specialized, but potentially more expensive, exchange instruction. By analyzing the costs for cycles of different lengths [@problem_id:3661053], you will learn how to make optimal, hardware-aware decisions to minimize execution time.", "problem": "Consider a back-end for a compiler targeting an Instruction Set Architecture (ISA) that must realize a set of parallel copies at a single program point. The parallel copies specify a permutation of register contents: each register $r_i$ must ultimately hold the value currently in some register $r_j$, and all copies are logically simultaneous. The ISA provides two relevant instructions: a general register-to-register move that copies the source into the destination at a cost of $c_m$ cycles per move, and a dedicated exchange instruction $\\mathsf{xchg}(r_i,r_j)$ that atomically swaps the contents of $r_i$ and $r_j$ at a cost of $c_x$ cycles per exchange. Assume there is exactly one scratch register $t$ available when using general moves, and that instruction costs add linearly (no overlap or pipelining). The costs are $c_m = 5$ and $c_x = 8$.\n\nThe parallel copy specification on registers $r_1$ through $r_{16}$ is the following permutation (written as source $\\mapsto$ destination pairs):\n$r_1 \\mapsto r_2$, $r_2 \\mapsto r_1$; $r_3 \\mapsto r_4$, $r_4 \\mapsto r_5$, $r_5 \\mapsto r_3$; $r_6 \\mapsto r_7$, $r_7 \\mapsto r_8$, $r_8 \\mapsto r_9$, $r_9 \\mapsto r_6$; $r_{10} \\mapsto r_{11}$, $r_{11} \\mapsto r_{12}$, $r_{12} \\mapsto r_{13}$, $r_{13} \\mapsto r_{14}$, $r_{14} \\mapsto r_{10}$; $r_{15} \\mapsto r_{16}$, $r_{16} \\mapsto r_{15}$.\n\nThese mappings form disjoint cycles of lengths $2$, $3$, $4$, $5$, and $2$, respectively. You may choose, cycle by cycle, whether to realize the cycle using only general moves (with the single scratch $t$) or using only $\\mathsf{xchg}$ instructions. Your goal is to minimize the total cycle cost across all cycles, subject to the atomicity requirement of the parallel copy semantics.\n\nWhat is the minimal total number of cycles required to realize the entire permutation? Express the final answer as a pure number of cycles. No rounding is necessary.", "solution": "The problem asks for the minimum total cost to realize a set of parallel copy operations. The set of copies forms a permutation, which can be decomposed into disjoint cycles. Since the cycles are disjoint, the total cost is the sum of the minimum costs to implement each cycle independently. We must therefore determine, for a cycle of a given length, the cheaper implementation method.\n\nThe permutation is defined on registers $r_1$ through $r_{16}$ and consists of five disjoint cycles with lengths $2$, $3$, $4$, $5$, and $2$. Let us analyze the cost to implement a single cycle of length $k \\ge 2$.\n\n**Strategy 1: Implementation using register-to-register moves**\n\nThis strategy uses general move instructions, each with a cost of $c_m = 5$, and a single available scratch register, $t$. A cycle of length $k$ represents a cyclic dependency. To break this dependency, we must use the scratch register. A standard algorithm requires $k+1$ move instructions:\n1. Save the content of one register, say $x_1$, into the scratch register $t$. This is 1 move.\n2. The register $x_1$ can now be overwritten. Perform the chain of $k-1$ assignments required by the cycle. For example, for a cycle where the value of $x_k$ goes to $x_1$, $x_{k-1}$ goes to $x_k$, etc., we execute $x_1 := x_k$, $x_k := x_{k-1}$, ..., $x_3 := x_2$.\n3. The original value of $x_1$ (saved in $t$) is copied to its destination, $x_2$. This is 1 final move.\n\nThe total number of move instructions is $1 + (k-1) + 1 = k+1$.\nThe cost for implementing a $k$-cycle using moves is therefore:\n$$C_{\\text{moves}}(k) = (k+1) c_m$$\n\n**Strategy 2: Implementation using exchange instructions**\n\nThis strategy uses the $\\mathsf{xchg}$ instruction, which atomically swaps the contents of two registers at a cost of $c_x = 8$. A permutation cycle of length $k$ can be decomposed into a product of $k-1$ transpositions (swaps). For example, the cyclic permutation $(x_1, x_2, \\dots, x_k)$ can be implemented by the sequence of $k-1$ exchanges: $\\mathsf{xchg}(x_1, x_2)$, then $\\mathsf{xchg}(x_1, x_3)$, and so on, up to $\\mathsf{xchg}(x_1, x_k)$. Each of these is a single instruction. Thus, a $k$-cycle can be realized with $k-1$ exchange instructions.\nThe cost for implementing a $k$-cycle using exchanges is:\n$$C_{\\text{xchg}}(k) = (k-1) c_x$$\n\n**Cost Comparison and Calculation**\n\nWe must now find the minimum cost for each cycle length present in the permutation by comparing the two strategies, using the given costs $c_m = 5$ and $c_x = 8$.\nThe cost functions are $C_{\\text{moves}}(k) = 5(k+1)$ and $C_{\\text{xchg}}(k) = 8(k-1)$.\n\nThe permutation consists of the following cycles:\n- Two cycles of length $k=2$.\n- One cycle of length $k=3$.\n- One cycle of length $k=4$.\n- One cycle of length $k=5$.\n\nLet us calculate the minimum cost for each length:\n\n- For a cycle of length $k=2$:\n  - $C_{\\text{moves}}(2) = (2+1) \\times 5 = 3 \\times 5 = 15$.\n  - $C_{\\text{xchg}}(2) = (2-1) \\times 8 = 1 \\times 8 = 8$.\n  - The minimum cost is $\\min(15, 8) = 8$. This is achieved using the $\\mathsf{xchg}$ instruction.\n\n- For a cycle of length $k=3$:\n  - $C_{\\text{moves}}(3) = (3+1) \\times 5 = 4 \\times 5 = 20$.\n  - $C_{\\text{xchg}}(3) = (3-1) \\times 8 = 2 \\times 8 = 16$.\n  - The minimum cost is $\\min(20, 16) = 16$. This is achieved using $\\mathsf{xchg}$ instructions.\n\n- For a cycle of length $k=4$:\n  - $C_{\\text{moves}}(4) = (4+1) \\times 5 = 5 \\times 5 = 25$.\n  - $C_{\\text{xchg}}(4) = (4-1) \\times 8 = 3 \\times 8 = 24$.\n  - The minimum cost is $\\min(25, 24) = 24$. This is achieved using $\\mathsf{xchg}$ instructions.\n\n- For a cycle of length $k=5$:\n  - $C_{\\text{moves}}(5) = (5+1) \\times 5 = 6 \\times 5 = 30$.\n  - $C_{\\text{xchg}}(5) = (5-1) \\times 8 = 4 \\times 8 = 32$.\n  - The minimum cost is $\\min(30, 32) = 30$. This is achieved using move instructions.\n\n**Total Minimal Cost**\n\nThe total minimal cost is the sum of the minimal costs for each of the five disjoint cycles.\n- Two cycles of length $2$: Cost = $2 \\times 8 = 16$.\n- One cycle of length $3$: Cost = $16$.\n- One cycle of length $4$: Cost = $24$.\n- One cycle of length $5$: Cost = $30$.\n\nTotal Cost = (Cost for two $k=2$ cycles) + (Cost for one $k=3$ cycle) + (Cost for one $k=4$ cycle) + (Cost for one $k=5$ cycle)\n$$ \\text{Total Cost} = (2 \\times 8) + 16 + 24 + 30 $$\n$$ \\text{Total Cost} = 16 + 16 + 24 + 30 $$\n$$ \\text{Total Cost} = 32 + 24 + 30 $$\n$$ \\text{Total Cost} = 56 + 30 $$\n$$ \\text{Total Cost} = 86 $$\n\nThe minimal total number of cycles required to realize the entire permutation is $86$.", "answer": "$$\\boxed{86}$$", "id": "3661053"}]}