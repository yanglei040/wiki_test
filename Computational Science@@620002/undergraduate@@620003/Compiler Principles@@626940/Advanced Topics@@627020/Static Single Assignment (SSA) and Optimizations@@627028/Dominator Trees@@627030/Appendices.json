{"hands_on_practices": [{"introduction": "The most significant application of dominator analysis is in the construction of Static Single Assignment (SSA) form, a prerequisite for many powerful compiler optimizations. This exercise guides you through the fundamental process of placing $\\phi$-functions, which merge different versions of a variable at control-flow join points. By calculating the dominance frontier and iterated dominance frontier from first principles, you will see precisely how this formalism identifies the minimal, correct locations for $\\phi$-functions, especially for handling variables within loops. [@problem_id:3638820]", "problem": "Consider the following Control-Flow Graph (CFG) with basic blocks labeled $S$, $H$, $B$, $B_1$, $B_2$, $B_3$, $J$, and $T$. The directed edges are: $S \\to H$, $H \\to B$, $H \\to T$, $B \\to B_1$, $B \\to B_2$, $B_1 \\to J$, $B_2 \\to B_3$, $B_3 \\to J$, and $J \\to H$. The block $H$ is the loop header, and the backedge is $J \\to H$. Assume that a scalar variable $x$ is defined initially in $S$, updated in exactly two distinct loop-body blocks $B_1$ and $B_3$, and used at $J$ (before taking the backedge), at $H$ in the loop continuation test, and at $T$ after loop exit. The Static Single Assignment (SSA) form is to be constructed using the iterated dominance frontier method, and assume pruned SSA placement with liveness as specified by the aforementioned uses.\n\nTasks:\n- Compute the dominance sets and the immediate dominator tree rooted at $S$ for the given CFG.\n- From first principles, compute the dominance frontier of the loop header $H$ and justify each element of the set.\n- Using only the definitions of dominance, immediate dominator, and dominance frontier, determine the minimal SSA $\\phi$-function placement for $x$ via the iterated dominance frontier of its definition sites. Explain, in particular, how the dominance frontier of $H$ guides $\\phi$-function placement for loop-carried values.\n- Finally, report the total number of distinct basic blocks that must contain a $\\phi$-function for $x$ after minimal SSA placement using iterated dominance frontiers, under the given liveness assumptions.\n\nYour final answer must be a single integer equal to the number of distinct basic blocks containing a $\\phi$-function for $x$. Do not include any units. No rounding is required.", "solution": "The problem statement is valid. It is a well-posed problem in compiler theory, grounded in the established principles of Control-Flow Graphs (CFGs), dominator analysis, and Static Single Assignment (SSA) form construction. The givens are self-contained and consistent, allowing for a unique solution.\n\nThe problem describes a CFG with a set of basic blocks $V = \\{S, H, B, B_1, B_2, B_3, J, T\\}$. The entry block is $S$. The set of directed edges is $E = \\{(S, H), (H, B), (H, T), (B, B_1), (B, B_2), (B_1, J), (B_2, B_3), (B_3, J), (J, H)\\}$. A variable $x$ is defined in blocks $\\{S, B_1, B_3\\}$ and used in blocks $\\{H, J, T\\}$.\n\n**1. Dominance Sets and Immediate Dominator Tree**\n\nA node $N$ dominates a node $M$ if every path from the entry node $S$ to $M$ includes $N$. A node $N$ strictly dominates $M$ if $N$ dominates $M$ and $N \\neq M$. The immediate dominator of $M$, denoted $idom(M)$, is the strict dominator of $M$ that is closest to $M$ on any path from the entry.\n\nBy analyzing all paths from the entry node $S$ to every other node, we compute the dominance sets $Dom(N)$ for each node $N \\in V$:\n- $Dom(S) = \\{S\\}$\n- $Dom(H) = \\{S, H\\}$. Any path to $H$ must either be $S \\to H$ or pass through $H$ itself via the loop.\n- $Dom(B) = \\{S, H, B\\}$. Any path to $B$ is of the form $S \\to \\dots \\to H \\to B$.\n- $Dom(T) = \\{S, H, T\\}$. Any path to $T$ is of the form $S \\to \\dots \\to H \\to T$.\n- $Dom(B_1) = \\{S, H, B, B_1\\}$. Any path to $B_1$ is of the form $S \\to \\dots \\to H \\to B \\to B_1$.\n- $Dom(B_2) = \\{S, H, B, B_2\\}$. Any path to $B_2$ is of the form $S \\to \\dots \\to H \\to B \\to B_2$.\n- $Dom(B_3) = \\{S, H, B, B_2, B_3\\}$. Any path to $B_3$ is of the form $S \\to \\dots \\to H \\to B \\to B_2 \\to B_3$.\n- $Dom(J) = \\{S, H, B, J\\}$. Paths to $J$ are $S \\to \\dots \\to B_1 \\to J$ and $S \\to \\dots \\to B_3 \\to J$. The common dominators of $B_1$ and $B_3$ are $\\{S, H, B\\}$, so these must be on any path to $J$.\n\nFrom the dominance sets, we determine the immediate dominator $idom(N)$ for each node $N \\neq S$:\n- $idom(H) = S$\n- $idom(B) = H$\n- $idom(T) = H$\n- $idom(B_1) = B$\n- $idom(B_2) = B$\n- $idom(B_3) = B_2$\n- $idom(J) = B$. The predecessors of $J$ are $B_1$ and $B_3$. The lowest common ancestor of $B_1$ and $B_3$ in the dominator tree is $B$.\n\nThe resulting immediate dominator tree, rooted at $S$, is:\n$S$ is the parent of $H$.\n$H$ is the parent of $B$ and $T$.\n$B$ is the parent of $B_1$, $B_2$, and $J$.\n$B_2$ is the parent of $B_3$.\n\n**2. Dominance Frontier of the Loop Header $H$**\n\nThe dominance frontier of a node $N$, denoted $DF(N)$, is the set of all nodes $Y$ such that $N$ dominates an immediate predecessor of $Y$ in the CFG, but $N$ does not strictly dominate $Y$. Formally:\n$$DF(N) = \\{ Y \\in V \\mid (\\exists P \\in pred_{CFG}(Y) \\text{ s.t. } N \\in Dom(P)) \\land (N \\notin Dom(Y) \\setminus \\{Y\\}) \\}$$\nWe compute $DF(H)$ from this first principle. We must find nodes $Y$ such that $H$ dominates a predecessor $P$ of $Y$, but $H$ does not strictly dominate $Y$. The set of nodes not strictly dominated by $H$ is $\\{S, H\\}$. We only need to check these $2$ nodes as potential candidates for $Y$.\n- **Candidate $Y=S$**: The node $S$ has no predecessors in the given CFG. The condition $(\\exists P \\in pred_{CFG}(S))$ is false. Thus, $S \\notin DF(H)$.\n- **Candidate $Y=H$**: The predecessors of $H$ are $S$ and $J$.\n    - Consider the predecessor $P=S$: $H$ does not dominate $S$ (in fact, $S$ dominates $H$), so this predecessor does not satisfy the condition.\n    - Consider the predecessor $P=J$: $H$ dominates $J$, since $Dom(J) = \\{S, H, B, J\\}$. The first part of the condition is met. Now we check the second part: does $H$ not strictly dominate $H$? Yes, $H$ dominates itself, but not strictly. The second part of the condition is also met.\nTherefore, $H \\in DF(H)$.\n\nSince no other nodes can be in the dominance frontier of $H$, we conclude that $DF(H) = \\{H\\}$. This result is characteristic of loop headers; they are merge points for control flow from outside the loop and from the loop's backedge.\n\n**3. Minimal SSA $\\phi$-function Placement**\n\nThe minimal set of $\\phi$-functions for a variable $x$ is placed at the iterated dominance frontier, $IDF(Defs(x))$, of the set of blocks containing definitions of $x$. The initial definition sites are $Defs(x) = \\{S, B_1, B_3\\}$. The $IDF$ is computed using a worklist algorithm.\n\nFirst, we need the dominance frontiers of the definition sites and any sites where we subsequently place $\\phi$-functions.\n- $DF(S) = \\emptyset$, as $S$ has no predecessors and its only successor, $H$, is strictly dominated by $S$.\n- $DF(B_1) = \\{J\\}$. $B_1$ has one successor, $J$. A predecessor of $J$ is $B_1$, which is dominated by $B_1$. However, $B_1$ does not strictly dominate $J$ (in fact, $B$ does). Thus, $J \\in DF(B_1)$.\n- $DF(B_3) = \\{J\\}$. A predecessor of $J$ is $B_3$, which is dominated by $B_3$. However, $B_3$ does not strictly dominate $J$. Thus, $J \\in DF(B_3)$.\n- $DF(J) = \\{H\\}$. A predecessor of $H$ is $J$, which is dominated by $J$. However, $J$ does not strictly dominate $H$. Thus, $H \\in DF(J)$.\n- $DF(H) = \\{H\\}$, as computed previously.\n\nThe worklist algorithm proceeds as follows:\n- Initialize worklist $W = \\{S, B_1, B_3\\}$. Initialize the set of nodes with $\\phi$-functions, $\\Phi = \\emptyset$.\n- **Step 1**: Pop $S$ from $W$. Compute $DF(S) = \\emptyset$. No new $\\phi$-functions are added. $W = \\{B_1, B_3\\}$.\n- **Step 2**: Pop $B_1$ from $W$. Compute $DF(B_1) = \\{J\\}$. Since $J \\notin \\Phi$, add a $\\phi$-function to $J$. Update $\\Phi = \\{J\\}$ and add $J$ to the worklist: $W = \\{B_3, J\\}$.\n- **Step 3**: Pop $B_3$ from $W$. Compute $DF(B_3) = \\{J\\}$. Since $J \\in \\Phi$, do nothing. $W = \\{J\\}$.\n- **Step 4**: Pop $J$ from $W$. Compute $DF(J) = \\{H\\}$. Since $H \\notin \\Phi$, add a $\\phi$-function to $H$. Update $\\Phi = \\{J, H\\}$ and add $H$ to the worklist: $W = \\{H\\}$.\n- **Step 5**: Pop $H$ from $W$. Compute $DF(H) = \\{H\\}$. Since $H \\in \\Phi$, do nothing. $W = \\emptyset$.\n\nThe worklist is now empty. The algorithm terminates. The set of blocks requiring $\\phi$-functions is $\\Phi = \\{J, H\\}$.\n\nThe problem specifies *pruned* SSA placement, which means a $\\phi$-function is placed at a node $Y$ only if the variable $x$ is live at the entry of $Y$.\n- A $\\phi$-function is placed at $J$. The problem states $x$ is used at $J$. Therefore, $x$ is live on entry to $J$, and this $\\phi$-function is necessary.\n- A $\\phi$-function is placed at $H$. The problem states $x$ is used at $H$ for the loop test. Therefore, $x$ is live on entry to $H$, and this $\\phi$-function is necessary.\nThe liveness analysis confirms that both $\\phi$-functions are required.\n\nThe placement of a $\\phi$-function at the loop header $H$ is crucial for handling loop-carried values. A value of $x$ is considered loop-carried if it is defined in one iteration and used in a subsequent one. In this case, definitions of $x$ occur in the loop body ($B_1$, $B_3$). These definitions reach the end of the iteration at block $J$. The backedge $J \\to H$ carries this value to the start of the next iteration. The loop header $H$ is a merge point for two different sets of reaching definitions of $x$: the initial value from $S$ (on the first entry) and the value from the previous iteration from $J$. The dominance frontier formalism correctly identifies $H$ as this merge point. The iterated algorithm first finds the join point $J$ for the two paths inside the loop body ($DF(B_1) \\cup DF(B_3) = \\{J\\}$). Then, treating $J$ as a new definition site, the algorithm finds the join point for the loop itself ($DF(J)=\\{H\\}$). The $\\phi$-function at $H$ thus correctly merges the initial value of $x$ with the loop-carried value of $x$.\n\n**4. Final Count**\n\nThe set of distinct basic blocks that must contain a $\\phi$-function for $x$ is $\\{J, H\\}$. The total number of such blocks is $2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3638820"}, {"introduction": "Optimizing compilers often need to insert code on the *edges* of a Control-Flow Graph (CFG), but basic blocks represent code at the *nodes*. This exercise explores a standard solution: splitting a 'critical edge' by inserting a new, empty basic block. You will analyze how this local graph modification affects the global properties of dominance and dominance frontiers, providing insight into which analyses are preserved and how such transformations enable further optimizations. [@problem_id:3638838]", "problem": "Consider the following directed Control Flow Graph (CFG), where CFG stands for Control Flow Graph. The entry block is denoted by $R$, and the unique exit block is denoted by $X$. The set of basic blocks is $\\{R, A, B, C, D, E, F, X\\}$ with directed edges:\n- $R \\to A$\n- $A \\to B$, $A \\to C$, $A \\to F$\n- $B \\to D$\n- $C \\to E$\n- $D \\to F$\n- $E \\to F$\n- $F \\to X$\n\nAssume the standard definitions: a node $d$ dominates a node $n$ if every path from $R$ to $n$ contains $d$; the immediate dominator $\\mathrm{idom}(n)$ is the unique strict dominator of $n$ that does not dominate any other strict dominator of $n$; the dominator tree is the tree formed by parent pointers $\\mathrm{idom}(\\cdot)$; and the dominance frontier $\\mathrm{DF}(X)$ is the set of all nodes $Y$ such that $X$ dominates a predecessor of $Y$ but $X$ does not strictly dominate $Y$. An edge $u \\to v$ is called critical if the out-degree of $u$ is $> 1$ and the in-degree of $v$ is $> 1$.\n\n1) Identify a critical edge in the CFG above and split it by inserting a fresh block $S$ on that edge, replacing $u \\to v$ with $u \\to S$ and $S \\to v$.\n\n2) Using only the core definitions stated above (dominance, immediate dominance, dominator tree, and dominance frontier), reason about the effect of this edge split on dominance and dominance frontiers.\n\nSelect all statements that are true after performing the split as described:\n\nA. After splitting the critical edge $A \\to F$ by inserting a new block $S$ (so the edges become $A \\to S$ and $S \\to F$), the immediate dominators among the original nodes $\\{R, A, B, C, D, E, F, X\\}$ remain unchanged; the dominator tree restricted to these original nodes is identical to that before the split.\n\nB. After the split, the dominance frontier of $B$ with respect to the original nodes no longer contains $F$ because $B$ no longer dominates any predecessor of $F$.\n\nC. After the split, the dominance frontiers computed on the augmented graph can differ due to the presence of the new node $S$ (for example, $\\mathrm{DF}(S)$ includes $F$), even though for every original node $Y$, the set $\\mathrm{DF}(Y)$ intersected with the original nodes is unchanged.\n\nD. Splitting the critical edge $A \\to F$ can change which original nodes dominate $F$, potentially changing $\\mathrm{idom}(F)$ among the original nodes.\n\nE. Splitting a critical edge provides a unique program point on that edge, which can be useful in later transformations such as Static Single Assignment (SSA) form construction (SSA stands for Static Single Assignment), but it does not by itself require moving any $\\phi$-functions from join nodes; dominance among original nodes is unaffected.", "solution": "The user has requested a detailed analysis of a problem concerning Control Flow Graphs (CFGs), dominators, and dominance frontiers. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n\n-   **Graph Structure:** A directed Control Flow Graph (CFG).\n-   **Entry Block:** $R$.\n-   **Exit Block:** $X$.\n-   **Set of Basic Blocks:** $\\{R, A, B, C, D, E, F, X\\}$.\n-   **Directed Edges:**\n    -   $R \\to A$\n    -   $A \\to B$, $A \\to C$, $A \\to F$\n    -   $B \\to D$\n    -   $C \\to E$\n    -   $D \\to F$\n    -   $E \\to F$\n    -   $F \\to X$\n-   **Definitions:**\n    -   **Dominance:** A node $d$ dominates a node $n$ if every path from $R$ to $n$ contains $d$.\n    -   **Immediate Dominator:** $\\mathrm{idom}(n)$ is the unique strict dominator of $n$ that does not dominate any other strict dominator of $n$. A node $d$ strictly dominates $n$ if $d$ dominates $n$ and $d \\neq n$.\n    -   **Dominator Tree:** The tree formed by parent pointers $\\mathrm{idom}(\\cdot)$.\n    -   **Dominance Frontier:** $\\mathrm{DF}(X)$ is the set of all nodes $Y$ such that $X$ dominates a predecessor of $Y$ but $X$ does not strictly dominate $Y$.\n    -   **Critical Edge:** An edge $u \\to v$ is called critical if the out-degree of $u$ is $> 1$ and the in-degree of $v$ is $> 1$.\n-   **Task:**\n    1.  Identify a critical edge and split it by inserting a fresh block $S$ on that edge, replacing $u \\to v$ with $u \\to S$ and $S \\to v$.\n    2.  Reason about the effect of this edge split on dominance and dominance frontiers.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Grounding (Critical):** The problem is based on standard, well-established concepts in compiler theory, specifically static program analysis. The definitions of CFG, dominance, immediate dominator, dominator tree, dominance frontier, and critical edge are all canonical. The problem is scientifically and mathematically sound. **Pass.**\n-   **Well-Posed:** The graph is fully specified, all terms are defined, and the task is unambiguous. The analysis of the graph transformation has a determinate outcome based on the provided definitions. **Pass.**\n-   **Objective (Critical):** The problem is stated using precise, formal language common in computer science. It is free from subjective or ambiguous terminology. **Pass.**\n-   **Completeness:** The problem provides all necessary information (the graph structure and all relevant definitions) to perform the required analysis. It is self-contained. **Pass.**\n-   **Consistency:** There are no contradictions in the provided graph structure or definitions. **Pass.**\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The analysis can proceed.\n\n### Solution Derivation\n\nThe analysis will proceed in three stages:\n1.  Analyze the original CFG to establish a baseline for dominance and dominance frontiers.\n2.  Perform the specified edge-splitting transformation.\n3.  Analyze the modified CFG and compare its properties to the original.\n4.  Evaluate each option based on this comparative analysis.\n\n**1. Analysis of the Original CFG**\n\nFirst, let's determine the in-degrees and out-degrees of the nodes to identify the critical edge.\n-   $\\mathrm{out}(R)=1, \\mathrm{in}(R)=0$\n-   $\\mathrm{out}(A)=3, \\mathrm{in}(A)=1$\n-   $\\mathrm{out}(B)=1, \\mathrm{in}(B)=1$\n-   $\\mathrm{out}(C)=1, \\mathrm{in}(C)=1$\n-   $\\mathrm{out}(D)=1, \\mathrm{in}(D)=1$\n-   $\\mathrm{out}(E)=1, \\mathrm{in}(E)=1$\n-   $\\mathrm{out}(F)=1, \\mathrm{in}(F)=3$\n-   $\\mathrm{out}(X)=0, \\mathrm{in}(X)=1$\n\nA critical edge $u \\to v$ requires $\\mathrm{out}(u) > 1$ and $\\mathrm{in}(v) > 1$. The only edge satisfying this is $A \\to F$, since $\\mathrm{out}(A)=3$ and $\\mathrm{in}(F)=3$. The problem asks to analyze the split of this edge.\n\n**Dominators (Original CFG):**\n-   $\\mathrm{dom}(R) = \\{R\\}$\n-   Every path to any other node must pass through $A$. Thus, $A$ dominates all nodes except $R$.\n-   $\\mathrm{dom}(A) = \\{R, A\\}$\n-   $\\mathrm{dom}(B) = \\{R, A, B\\}$\n-   $\\mathrm{dom}(C) = \\{R, A, C\\}$\n-   $\\mathrm{dom}(D) = \\{R, A, B, D\\}$\n-   $\\mathrm{dom}(E) = \\{R, A, C, E\\}$\n-   The paths to $F$ are $R \\to A \\to F$, $R \\to A \\to B \\to D \\to F$, and $R \\to A \\to C \\to E \\to F$. The common nodes are $R$ and $A$. So, $\\mathrm{dom}(F) = \\{R, A, F\\}$.\n-   All paths to $X$ must pass through $F$. So, $\\mathrm{dom}(X) = \\mathrm{dom}(F) \\cup \\{X\\} = \\{R, A, F, X\\}$.\n\n**Immediate Dominators (Original CFG):**\n-   $\\mathrm{idom}(A) = R$\n-   $\\mathrm{idom}(B) = A$\n-   $\\mathrm{idom}(C) = A$\n-   $\\mathrm{idom}(F) = A$\n-   $\\mathrm{idom}(D) = B$\n-   $\\mathrm{idom}(E) = C$\n-   $\\mathrm{idom}(X) = F$\n\n**Dominance Frontiers (Original CFG):**\nWe apply the definition: $Y \\in \\mathrm{DF}(Z)$ if $Z$ dominates a predecessor of $Y$ but $Z$ does not strictly dominate $Y$.\n-   $\\mathrm{DF}(B)$: $B$ dominates $D$, a predecessor of $F$. $B$ does not dominate $F$, so it does not strictly dominate $F$. Thus, $F \\in \\mathrm{DF}(B)$.\n-   $\\mathrm{DF}(C)$: $C$ dominates $E$, a predecessor of $F$. $C$ does not strictly dominate $F$. Thus, $F \\in \\mathrm{DF}(C)$.\n-   $\\mathrm{DF}(D)$: $D$ dominates itself, a predecessor of $F$. $D$ does not strictly dominate $F$. Thus, $F \\in \\mathrm{DF}(D)$.\n-   $\\mathrm{DF}(E)$: $E$ dominates itself, a predecessor of $F$. $E$ does not strictly dominate $F$. Thus, $F \\in \\mathrm{DF}(E)$.\n-   $\\mathrm{DF}(A)$: The only potential join point for paths from $A$ is $F$. However, $A$ strictly dominates $F$ (since $\\mathrm{idom}(F)=A$). The condition \"$A$ does not strictly dominate $Y$\" is false for $Y=F$. For any other node $Y$ where $A$ dominates a predecessor, $A$ also strictly dominates $Y$. Thus, $\\mathrm{DF}(A) = \\emptyset$.\n-   Hence, $\\mathrm{DF}(B) = \\{F\\}$, $\\mathrm{DF}(C) = \\{F\\}$, $\\mathrm{DF}(D) = \\{F\\}$, $\\mathrm{DF}(E) = \\{F\\}$.\n\n**2. The Edge-Splitting Transformation**\n\nThe critical edge $A \\to F$ is split by inserting a new block $S$.\n-   The edge $A \\to F$ is removed.\n-   New edges $A \\to S$ and $S \\to F$ are added.\n-   The set of blocks becomes $\\{R, A, B, C, D, E, S, F, X\\}$.\n-   The predecessors of $S$ are $\\{A\\}$.\n-   The predecessors of $F$ are now $\\{D, E, S\\}$.\n\n**3. Analysis of the Modified CFG**\n\n**Impact on Dominance:**\nLet's consider two original nodes $U$ and $V$. A node $D$ dominates $N$ if every path from $R$ to $N$ contains $D$.\nAny path in the original graph that did not use the edge $A \\to F$ remains a path in the new graph.\nAny path in the original graph of the form $\\dots \\to A \\to F \\to \\dots$ becomes a path $\\dots \\to A \\to S \\to F \\to \\dots$ in the new graph. The set of original nodes on this path is unchanged.\nConsequently, if an original node $D$ was on every path from $R$ to an original node $N$ before the split, it remains on every such path after the split. If there was a path from $R$ to $N$ that avoided $D$ before, that path (or its S-inserted version) still exists and avoids $D$.\nTherefore, for any two original nodes $U, V$, $U$ dominates $V$ in the new graph if and only if $U$ dominated $V$ in the old graph. This means the dominance relation, the strict dominance relation, and the immediate dominator relation among the original nodes are all unchanged.\n\n-   $\\mathrm{dom}_{\\text{new}}(N) = \\mathrm{dom}_{\\text{old}}(N)$ for any original node $N$.\n-   $\\mathrm{idom}_{\\text{new}}(N) = \\mathrm{idom}_{\\text{old}}(N)$ for any original node $N$.\n-   $\\mathrm{dom}(S) = \\mathrm{dom}(A) \\cup \\{S\\} = \\{R, A, S\\}$, so $\\mathrm{idom}(S) = A$.\n\n**Impact on Dominance Frontiers:**\nLet's re-evaluate the DFs.\n-   For any original node $Y$, is $\\mathrm{DF}_{\\text{new}}(Y)$ different from $\\mathrm{DF}_{\\text{old}}(Y)$ when restricted to original nodes?\n-   The only change in predecessors for an original node is for $F$: $\\mathrm{preds}_{\\text{new}}(F) = \\{D, E, S\\}$.\n-   Let's check $\\mathrm{DF}_{\\text{new}}(B)$. We check if $F \\in \\mathrm{DF}_{\\text{new}}(B)$. $B$ must dominate a predecessor of $F$ and not strictly dominate $F$.\n    -   $\\mathrm{preds}_{\\text{new}}(F) = \\{D, E, S\\}$. $B$ does not dominate $S$ or $E$. However, $B$ still dominates $D$.\n    -   $B$ does not strictly dominate $F$.\n    -   Both conditions hold. Thus, $F \\in \\mathrm{DF}_{\\text{new}}(B)$.\n-   The same logic holds for $C, D, E$. Their dominance frontiers still contain $F$.\n-   No other predecessor sets for original nodes have changed. The dominance relations between original nodes are unchanged. Therefore, for any original node $Y$, $\\mathrm{DF}_{\\text{new}}(Y)$ restricted to original nodes is identical to $\\mathrm{DF}_{\\text{old}}(Y)$.\n-   What about new DFs? Let's compute $\\mathrm{DF}(S)$.\n    -   We check node $F$. The predecessor of $F$ from $S$ is $S$ itself. $S$ dominates its predecessor $S$.\n    -   Does $S$ strictly dominate $F$? $\\mathrm{dom}(F)=\\{R, A, F\\}$. $S$ is not in this set, so $S$ does not dominate $F$.\n    -   The conditions are met. Thus, $F \\in \\mathrm{DF}(S)$.\n\n**4. Option-by-Option Evaluation**\n\n**A. After splitting the critical edge $A \\to F$ by inserting a new block $S$ (so the edges become $A \\to S$ and $S \\to F$), the immediate dominators among the original nodes $\\{R, A, B, C, D, E, F, X\\}$ remain unchanged; the dominator tree restricted to these original nodes is identical to that before the split.**\nOur analysis shows that the dominance relation between any two original nodes is invariant under this transformation. As a direct consequence, the immediate dominator for any original node remains the same. The structure of the dominator tree connecting the original nodes is therefore identical.\n**Verdict: Correct.**\n\n**B. After the split, the dominance frontier of $B$ with respect to the original nodes no longer contains $F$ because $B$ no longer dominates any predecessor of $F$.**\nThe premise of this statement is false. The new predecessors of $F$ are $\\{D, E, S\\}$. Node $B$ still dominates node $D$, as established in our analysis. Since $B$ dominates a predecessor of $F$ (namely $D$) and $B$ does not strictly dominate $F$, $F$ remains in the dominance frontier of $B$.\n**Verdict: Incorrect.**\n\n**C. After the split, the dominance frontiers computed on the augmented graph can differ due to the presence of the new node $S$ (for example, $\\mathrm{DF}(S)$ includes $F$), even though for every original node $Y$, the set $\\mathrm{DF}(Y)$ intersected with the original nodes is unchanged.**\nThis statement has two parts.\n1.  \"the dominance frontiers computed on the augmented graph can differ due to the presence of the new node $S$ (for example, $\\mathrm{DF}(S)$ includes $F$)\" — Our analysis showed that $F \\in \\mathrm{DF}(S)$. This is a new dominance frontier relationship that did not exist before. This part is true.\n2.  \"for every original node $Y$, the set $\\mathrm{DF}(Y)$ intersected with the original nodes is unchanged.\" — Our analysis showed that for any original node $Y$, its dominance frontier set containing original nodes remains the same. The set of predecessors changed only for $F$, but for every node $Z$ that previously had $F$ in its DF, there is still a predecessor of $F$ that $Z$ dominates. So $\\mathrm{DF}_{\\text{new}}(Y) = \\mathrm{DF}_{\\text{old}}(Y)$ for all original nodes $Y$. The intersection clause is thus satisfied. This part is true.\nSince both parts of the statement are true, the entire statement is true.\n**Verdict: Correct.**\n\n**D. Splitting the critical edge $A \\to F$ can change which original nodes dominate $F$, potentially changing $\\mathrm{idom}(F)$ among the original nodes.**\nThis contradicts our finding in the analysis for option A. The set of dominators of $F$, $\\mathrm{dom}(F)$, is determined by taking the intersection of nodes on all paths from $R$ to $F$. The transformation adds $S$ to some paths, but the set of *original* nodes on any path is unchanged. Thus, the intersection of these sets of original nodes is also unchanged. `dom(F)` among original nodes is not altered, and therefore $\\mathrm{idom}(F)$ is not altered.\n**Verdict: Incorrect.**\n\n**E. Splitting a critical edge provides a unique program point on that edge, which can be useful in later transformations such as Static Single Assignment (SSA) form construction (SSA stands for Static Single Assignment), but it does not by itself require moving any $\\phi$-functions from join nodes; dominance among original nodes is unaffected.**\nThis is a conceptual statement. Let's validate its parts.\n1.  \"Splitting a critical edge provides a unique program point on that edge\": This is the primary purpose of edge splitting. The new block $S$ serves as a unique location to place code that logically belongs on the edge $A \\to F$. This is true.\n2.  \"useful in later transformations such as ... SSA\": True. Code motion and insertion of compensation code (e.g., register moves for $\\phi$-functions) is problematic on critical edges. Splitting them resolves this issue.\n3.  \"it does not by itself require moving any $\\phi$-functions from join nodes\": In SSA construction, $\\phi$-functions are placed at nodes in the iterated dominance frontiers of nodes containing variable definitions. As shown in the analysis for C, the dominance frontiers of original nodes remain unchanged. Therefore, the placement criteria for $\\phi$-functions at original nodes are unchanged. No $\\phi$-functions need to be moved from one original node to another. This is true.\n4.  \"dominance among original nodes is unaffected\": As established in the analysis for A, this is true.\nAll constituent claims are correct statements in compiler theory and are consistent with our specific analysis of this graph.\n**Verdict: Correct.**", "answer": "$$\\boxed{ACE}$$", "id": "3638838"}, {"introduction": "Standard loop analyses and optimizations rely on a key structural property: every loop has a single 'header' node that dominates all other nodes within the loop body. This exercise confronts a scenario where this property is violated, a structure known as an 'irreducible' flow graph. You will first learn to detect irreducibility using the definition of dominance and then apply a deterministic node-splitting algorithm to repair the graph, making it 'reducible' and thus amenable to a wide range of standard loop optimizations. [@problem_id:3638857]", "problem": "Consider the following Control Flow Graph (CFG) with a unique entry node $S$ and a unique exit node $T$. The nodes are $S, A, B, C, D, E, F, T$. Directed edges are:\n- $S \\to A$,\n- $A \\to B$, $A \\to C$, $A \\to F$,\n- $F \\to D$,\n- $B \\to D$,\n- $D \\to C$,\n- $C \\to E$,\n- $E \\to B$, $E \\to T$.\n\nThis CFG contains a strongly connected component (SCC) on the node set $\\{B, C, D, E\\}$ with the cycle $B \\to D \\to C \\to E \\to B$. We will regard this SCC as a loop candidate.\n\nYou will use the following foundational definitions:\n- Dominance: In a CFG with entry $S$, a node $X$ dominates a node $Y$ if every path from $S$ to $Y$ includes $X$.\n- Loop header: A loop header is a node that dominates all nodes in its loop body.\n- Reducible flow graph: A CFG is reducible if every cycle is single-entry; equivalently, each loop has a single header that dominates all nodes in the loop body.\n- Irreducible flow graph: A CFG is irreducible if there exists some cycle with multiple distinct entry edges from outside the SCC into different nodes of the SCC, so that no single node dominates the entire SCC.\n\nTask:\n1) Using only the definitions above, argue whether node $B$ can serve as a loop header for the SCC $\\{B, C, D, E\\}$ by checking whether $B$ dominates $C$ and $D$. Based on your reasoning, decide whether the SCC is irreducible with respect to $B$.\n\n2) To repair irreducibility, apply the following deterministic node-splitting procedure with $B$ designated as the header $H$:\n   - Define the unique headerward successor mapping on the SCC by the edges $B \\mapsto D$, $D \\mapsto C$, $C \\mapsto E$, $E \\mapsto B$. This choice induces, for any $v \\in \\{B,C,D,E\\}$, a unique headerward path to $H = B$ by repeatedly following this mapping until $B$ is reached.\n   - For every edge $(u \\to v)$ where $u \\notin \\{B,C,D,E\\}$ and $v \\in \\{B,C,D,E\\}$ with $v \\neq B$, perform node splitting along the headerward path from $v$ to $B$:\n     • Create fresh copies of each node on the headerward path starting at $v$ and ending just before $B$. If the path is $v = w_{0} \\to w_{1} \\to \\dots \\to w_{k-1} \\to w_{k} = B$, create fresh nodes $w_{0}', w_{1}', \\dots, w_{k-1}'$.\n     • Redirect $(u \\to v)$ to $(u \\to w_{0}')$ and add edges $w_{i}' \\to w_{i+1}'$ for $i = 0, \\dots, k-2$, and $w_{k-1}' \\to B$.\n     • For any original exit edge from any $w_{i}$ to a node outside the SCC, add the same exit edge from $w_{i}'$ to that outside target.\n     • Do not share copies between distinct external entry edges; each external entry produces its own set of fresh copies along its path to $B$.\n   - Do nothing for $(u \\to v)$ if $v = B$ (the header).\n\n3) Let $N$ be the total number of fresh node copies created by this repair procedure on the given CFG. Compute $N$. Your final answer must be a single real number. No rounding is required.", "solution": "We begin from the definitions of dominance, loop header, and reducible versus irreducible flow graphs.\n\nStep 1: Detecting irreducibility and non-dominance.\n- The SCC $\\{B, C, D, E\\}$ forms a cycle via $B \\to D \\to C \\to E \\to B$, so these four nodes are mutually reachable. This is a loop candidate.\n- External entry edges into this SCC are edges from nodes outside the SCC into nodes inside the SCC. From the edge list:\n  • $A \\to B$ enters the SCC at $B$.\n  • $A \\to C$ enters the SCC at $C$.\n  • $F \\to D$ enters the SCC at $D$.\n  Thus, there are three distinct entry edges into the SCC, targeting $B$, $C$, and $D$.\n- To test if $B$ can be a loop header, we must verify whether $B$ dominates every node in the SCC. Using the definition of dominance, check $C$ and $D$:\n  • For $C$: There exists a path $S \\to A \\to C$ that reaches $C$ without passing through $B$. Therefore, not every path from $S$ to $C$ includes $B$, so $B$ does not dominate $C$.\n  • For $D$: There exists a path $S \\to A \\to F \\to D$ that reaches $D$ without passing through $B$. Therefore, $B$ does not dominate $D$.\n  Since $B$ fails to dominate at least $C$ and $D$, $B$ cannot serve as a loop header for the SCC. The presence of multiple external entries $(A \\to C)$ and $(F \\to D)$ into distinct nodes of the SCC implies the SCC is irreducible with respect to $B$ by the single-entry criterion.\n\nStep 2: Applying the deterministic node-splitting repair with headerward successor mapping.\n- The headerward successor mapping is specified as $B \\mapsto D$, $D \\mapsto C$, $C \\mapsto E$, $E \\mapsto B$. This yields unique headerward paths to $B$ for any node in the SCC:\n  • From $C$: $C \\to E \\to B$.\n  • From $D$: $D \\to C \\to E \\to B$.\n  • From $E$: $E \\to B$.\n  • From $B$: already at $B$.\n- We must process each external entry $(u \\to v)$ with $u \\notin \\{B,C,D,E\\}$ and $v \\in \\{B,C,D,E\\}$, $v \\neq B$.\n\nThere are two such edges:\n- Edge $(A \\to C)$ with $v = C \\neq B$.\n  • Headerward path from $C$ to $B$ is $C \\to E \\to B$. The nodes strictly before $B$ on this path are $C$ and $E$.\n  • Create fresh copies $C_{1}$ and $E_{1}$.\n  • Redirect $A \\to C$ to $A \\to C_{1}$.\n  • Add edges $C_{1} \\to E_{1}$ and $E_{1} \\to B$.\n  • Replicate exit edges from the originals to outside the SCC: $E$ has an exit edge $E \\to T$, so add $E_{1} \\to T$. Node $C$ has no exit to outside the SCC in the original graph, so no exit replication is needed for $C_{1}$.\n  • Fresh node count contributed by this external entry is $2$ (the nodes $C_{1}$ and $E_{1}$).\n\n- Edge $(F \\to D)$ with $v = D \\neq B$.\n  • Headerward path from $D$ to $B$ is $D \\to C \\to E \\to B$. The nodes strictly before $B$ on this path are $D$, $C$, and $E$.\n  • Create fresh copies $D_{2}$, $C_{2}$, and $E_{2}$.\n  • Redirect $F \\to D$ to $F \\to D_{2}$.\n  • Add edges $D_{2} \\to C_{2}$, $C_{2} \\to E_{2}$, and $E_{2} \\to B$.\n  • Replicate exit edges from the originals to outside the SCC: $E$ has exit $E \\to T$, so add $E_{2} \\to T$. Nodes $D$ and $C$ have no exits to outside the SCC in the original graph, so no exit replication is needed for $D_{2}$ or $C_{2}$.\n  • Fresh node count contributed by this external entry is $3$ (the nodes $D_{2}$, $C_{2}$, and $E_{2}$).\n\nPer the procedure, copies are not shared between distinct external entries. Therefore, the total number of fresh nodes created is the sum of the contributions from these two entries.\n\nStep 3: Compute $N$.\n- From $(A \\to C)$: $2$ fresh nodes.\n- From $(F \\to D)$: $3$ fresh nodes.\nThus,\n$$\nN = 2 + 3 = 5.\n$$\n\nStep 4: Postcondition check (why this repair works conceptually).\n- After these transformations, the only remaining edge from outside the SCC $\\{B, C, D, E\\}$ into the original SCC nodes is $A \\to B$ (the header). The redirected edges now enter the fresh copies and then reach $B$ or exit at $T$ without entering any original SCC node other than $B$.\n- Consequently, every path from $S$ to any node in the original SCC must pass through $B$, so $B$ now dominates all nodes in the SCC, making the loop single-entry and the CFG reducible with respect to that loop.\n- The computed $N$ quantifies the size of the repair via node splitting under the specified deterministic procedure.\n\nTherefore, the total number of fresh node copies created is $5$.", "answer": "$$\\boxed{5}$$", "id": "3638857"}]}