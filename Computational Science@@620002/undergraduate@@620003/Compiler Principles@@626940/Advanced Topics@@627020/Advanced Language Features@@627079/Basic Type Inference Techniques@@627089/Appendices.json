{"hands_on_practices": [{"introduction": "Inferring the type of the `foldr` function is a classic milestone in understanding Hindley-Milner type inference. This exercise challenges you to apply Algorithm W to a recursive, higher-order function, generating and solving constraints to derive its powerful polymorphic type. Successfully completing this practice demonstrates a comprehensive grasp of how type variables, unification, and generalization work together to handle complex functional patterns. [@problem_id:3624329]", "problem": "You are given a core functional language with lambda abstraction and algebraic data types, equipped with Hindley–Milner (HM) polymorphic type inference using Algorithm W. Lists are provided with the empty list constructor $[]$ and the cons constructor $:$, with the following typing facts taken as foundational base:\n- The empty list has type $\\forall \\alpha.\\ \\mathrm{List}\\ \\alpha$.\n- The cons constructor has type $\\forall \\alpha.\\ \\alpha \\to \\mathrm{List}\\ \\alpha \\to \\mathrm{List}\\ \\alpha$.\n- Pattern matching on lists follows the standard typing rule that if an expression $e$ has type $\\mathrm{List}\\ \\alpha$ for some $\\alpha$, then in the branch for $[]$ the result has some type $\\tau$, and in the branch for $x:xs$ under the environment extended with $x:\\alpha$ and $xs:\\mathrm{List}\\ \\alpha$, the branch result must also have type $\\tau$; the whole match expression then has type $\\tau$.\n\nConsider the recursive definition of $foldr$ as a top-level recursive binding:\n$$\n\\mathrm{let\\ rec}\\ foldr = \\lambda f.\\ \\lambda z.\\ \\lambda xs.\\ \\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\{ [] \\to z;\\ (x:xs') \\to f\\ x\\ (foldr\\ f\\ z\\ xs') \\}\\ \\mathrm{in}\\ foldr.\n$$\nAssume Algorithm W for HM polymorphism extended to recursive bindings by initially assigning a fresh monotype to the recursively bound variable and unifying it with the type inferred for its right-hand side.\n\nTask:\n1. Using Algorithm W, construct the typing constraints generated by the above definition sufficient to infer a principal type for $foldr$. Treat each lambda parameter as bound to a fresh type variable, and treat the recursive occurrence of $foldr$ according to the described rule for recursive bindings.\n2. Solve the constraints by first-order unification to derive the principal type scheme of $foldr$.\n3. Let $M$ denote the total number of arrow constructors $\\to$ appearing in the entire principal type of $foldr$ (count all occurrences, including those nested inside argument types), and let $V$ denote the number of distinct universally quantified type variables in the principal type scheme. Compute the value $P = M \\times V$.\n\nProvide only the value of $P$ as your final result. No rounding is required, and no units are involved. The final answer must be a single real-valued number.", "solution": "The task is to infer the principal type of the $\\mathrm{foldr}$ function and then perform a calculation based on its structure. The definition of $\\mathrm{foldr}$ is:\n$$\n\\mathrm{let\\ rec}\\ \\mathrm{foldr} = \\lambda f.\\ \\lambda z.\\ \\lambda xs.\\ \\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\{ [] \\to z;\\ (x:xs') \\to f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs') \\}\n$$\nWe use Algorithm W to infer the type.\n\n**Step 1: Set up the typing environment and constraints.**\nAccording to the rule for $\\mathrm{let\\ rec}$, we introduce a fresh monotype variable for $\\mathrm{foldr}$, say $\\tau_{fr}$, in the environment used to type the function's body. The initial environment is $\\Gamma_0 = \\{ \\mathrm{foldr} : \\tau_{fr} \\}$.\n\nThe body is a series of lambda abstractions. We introduce fresh type variables for each parameter:\n- $f$ gets type $\\tau_f$.\n- $z$ gets type $\\tau_z$.\n- $xs$ gets type $\\tau_{xs}$.\n\nThe environment for typing the $\\mathrm{case}$ expression is $\\Gamma_1 = \\Gamma_0 \\cup \\{ f:\\tau_f, z:\\tau_z, xs:\\tau_{xs} \\}$. The type of the entire lambda expression will be $\\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$, where $\\tau_{case}$ is the type of the $\\mathrm{case}$ expression.\n\n**Step 2: Type the `case` expression.**\nThe expression is $\\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\dots$. The type of $xs$ is $\\tau_{xs}$. For it to be used in a list pattern match, its type must be a list type. This generates our first constraint:\n(1) $\\tau_{xs} = \\mathrm{List}\\ \\alpha$, for a fresh type variable $\\alpha$.\n\nThe result type of the $\\mathrm{case}$ expression, $\\tau_{case}$, must be the same as the type of each branch.\n\n*Branch 1: `[] -> z`*\nThe empty list $[]$ has type $\\forall \\beta. \\mathrm{List}\\ \\beta$. Instantiating it, we get $\\mathrm{List}\\ \\beta'$ for a fresh $\\beta'$. For the pattern to match, we unify $\\tau_{xs}$ with $\\mathrm{List}\\ \\beta'$, so $\\mathrm{List}\\ \\alpha = \\mathrm{List}\\ \\beta'$, which implies $\\alpha = \\beta'$. The expression in this branch is $z$, which has type $\\tau_z$ from the environment $\\Gamma_1$. So, the type of this branch is $\\tau_z$.\n\n*Branch 2: `(x:xs') -> f x (foldr f z xs')`*\nThe cons constructor $:$ has type $\\forall \\gamma. \\gamma \\to \\mathrm{List}\\ \\gamma \\to \\mathrm{List}\\ \\gamma$. Instantiating it gives $\\gamma' \\to \\mathrm{List}\\ \\gamma' \\to \\mathrm{List}\\ \\gamma'$. The pattern $x:xs'$ binds $x$ to type $\\gamma'$ and $xs'$ to type $\\mathrm{List}\\ \\gamma'$. For the pattern match to be valid, we unify $\\tau_{xs}$ with $\\mathrm{List}\\ \\gamma'$, so $\\mathrm{List}\\ \\alpha = \\mathrm{List}\\ \\gamma'$, which implies $\\alpha = \\gamma'$.\nThe environment for this branch's body is $\\Gamma_2 = \\Gamma_1 \\cup \\{ x:\\alpha, xs':\\mathrm{List}\\ \\alpha \\}$.\n\nNow we type the body of this branch: $f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs')$.\nFirst, we type the recursive call $\\mathrm{foldr}\\ f\\ z\\ xs'$ in $\\Gamma_2$.\n- $\\mathrm{foldr}$ has type $\\tau_{fr}$.\n- $f$ has type $\\tau_f$.\n- $z$ has type $\\tau_z$.\n- $xs'$ has type $\\mathrm{List}\\ \\alpha$.\nThe application requires $\\tau_{fr}$ to be a function type that accepts these arguments. Let the return type of this recursive call be $\\tau_{rec}$. This generates the constraint:\n(2) $\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_{rec}$.\n\nNext, we type the outer application $f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs')$.\n- $f$ has type $\\tau_f$.\n- $x$ has type $\\alpha$.\n- The expression $(\\mathrm{foldr}\\ f\\ z\\ xs')$ has type $\\tau_{rec}$.\nThe application requires $\\tau_f$ to be a function that accepts $x$ and the result of the recursive call. Let the final type of this branch be $\\tau_{branch2}$. This generates the constraint:\n(3) $\\tau_f = \\alpha \\to \\tau_{rec} \\to \\tau_{branch2}$.\n\nThe types of both branches must be equal. The type of Branch 1 was $\\tau_z$.\n(4) $\\tau_{branch2} = \\tau_z$.\n\nThe type of the entire $\\mathrm{case}$ expression, $\\tau_{case}$, is this common branch type.\n(5) $\\tau_{case} = \\tau_z$.\n\n**Step 3: Solve the system of constraints.**\nThe type inferred for the body of the $\\mathrm{let\\ rec}$ (the whole lambda expression) is $\\tau_E = \\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$.\nThe rule for $\\mathrm{let\\ rec}$ requires us to unify the assumed type $\\tau_{fr}$ with the inferred type $\\tau_E$:\n(6) $\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$.\n\nNow we substitute our findings into this central equation.\nUsing (1) $\\tau_{xs} = \\mathrm{List}\\ \\alpha$ and (5) $\\tau_{case} = \\tau_z$, equation (6) becomes:\n$\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z$.\n\nWe have two expressions for $\\tau_{fr}$, from (2) and from the line above. We must unify them:\n$$\n\\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_{rec}\n$$\nThis unification succeeds if and only if their component types unify. This implies:\n(7) $\\tau_z = \\tau_{rec}$.\n\nNow we can simplify our other constraints using this new information.\nSubstitute (4) $\\tau_{branch2} = \\tau_z$ and (7) $\\tau_{rec} = \\tau_z$ into (3):\n$\\tau_f = \\alpha \\to \\tau_z \\to \\tau_z$.\n\nWe have now resolved all interdependencies. Let's substitute this final form of $\\tau_f$ back into our expression for $\\tau_{fr}$:\n$$\n\\tau_{fr} = (\\alpha \\to \\tau_z \\to \\tau_z) \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z\n$$\nThis is the most general monotype for $\\mathrm{foldr}$.\n\n**Step 4: Generalize to find the principal type scheme.**\nThe type variables in this expression are $\\alpha$ and $\\tau_z$. Since this is a top-level definition, the initial context is empty, so there are no free variables to restrict generalization. We can universally quantify over both $\\alpha$ and $\\tau_z$. For convention, we rename them to $\\alpha$ and $\\beta$. The principal type scheme for $\\mathrm{foldr}$ is:\n$$\n\\forall \\alpha, \\beta.\\ (\\alpha \\to \\beta \\to \\beta) \\to \\beta \\to \\mathrm{List}\\ \\alpha \\to \\beta\n$$\n\n**Step 5: Compute M and V.**\nWe need to find $V$, the number of distinct universally quantified type variables, and $M$, the total number of arrow constructors ($\\to$).\n\n-   $V$: The quantified variables are $\\alpha$ and $\\beta$. There are $2$ distinct variables.\n    $$ V = 2 $$\n\n-   $M$: We count the occurrences of the arrow constructor $\\to$ in the type $(\\alpha \\to \\beta \\to \\beta) \\to \\beta \\to \\mathrm{List}\\ \\alpha \\to \\beta$.\n    Let's write it with full parenthesization for clarity, remembering that $\\to$ is right-associative:\n    $$ ((\\alpha \\to (\\beta \\to \\beta))) \\to (\\beta \\to ((\\mathrm{List}\\ \\alpha) \\to \\beta)) $$\n    We can count the arrows:\n    1.  $\\alpha \\to (\\dots)$ in the first argument's type.\n    2.  $\\beta \\to \\beta$ in the first argument's type.\n    3.  The main arrow separating the first argument from the rest of the function type.\n    4.  The arrow separating the second argument, $\\beta$, from the rest.\n    5.  The arrow separating the third argument, $\\mathrm{List}\\ \\alpha$, from the final result type.\n    Total number of arrows is $M = 1+1+1+1+1=5$.\n    $$ M = 5 $$\n\n**Step 6: Compute P.**\nThe problem asks for the value of $P = M \\times V$.\n$$ P = 5 \\times 2 = 10 $$\nThe value of $P$ is $10$.", "answer": "$$\n\\boxed{10}\n$$", "id": "3624329"}, {"introduction": "While accepting correct programs is crucial, a type system's utility also hinges on its ability to diagnose errors effectively. This practice shifts our focus to ill-typed programs, introducing the concept of a minimal unsatisfiable core to pinpoint the exact source of a type conflict. By identifying the smallest set of contradictory constraints, you will learn a more formal and precise approach to debugging type errors. [@problem_id:3624432]", "problem": "Consider a simply typed, call-by-value, functional core with disjoint sums and pattern matching. The base types are $\\mathsf{int}$ and $\\mathsf{bool}$. The disjoint sum type is written $t_1 + t_2$ with canonical constructors $\\text{Left}: t_1 \\to t_1 + t_2$ and $\\text{Right}: t_2 \\to t_1 + t_2$. A pattern match has the form $\\text{match}\\ e\\ \\text{with}\\ \\text{Left}\\ x \\to e_1\\ \\mid\\ \\text{Right}\\ y \\to e_2$. Assume the standard typing rule for sums: if $e: t_1 + t_2$, then in the left branch $x: t_1$ and in the right branch $y: t_2$, and both $e_1$ and $e_2$ must have the same type $\\tau$, which is the type of the whole match. The integer addition operator has type $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$ and unary boolean negation has type $\\mathsf{bool} \\to \\mathsf{bool}$. Use standard Algorithm W for Hindley–Milner (HM) type inference to generate constraints as equalities over type expressions before any unification or substitution is applied.\n\nAnalyze the term $\\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$ under the assumptions above. Generate the set of primitive type equality constraints that arise from applying syntax-directed typing rules and operator types, without performing unification. Then determine the cardinality of a smallest unsatisfiable subset (a minimal unsatisfiable core) of these primitive constraints.\n\nYour final answer must be a single number equal to the size of such a smallest unsatisfiable subset. No rounding is required and no units are involved.", "solution": "The problem requires an analysis of a given $\\lambda$-term within a simply typed functional language with disjoint sums and pattern matching. The task is to apply the principles of Hindley-Milner type inference, specifically Algorithm W, to generate a set of primitive type equality constraints. Subsequently, we must determine the cardinality of a smallest unsatisfiable subset of these constraints, also known as a minimal unsatisfiable core.\n\nThe term to analyze is $E = \\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$.\n\nWe proceed by performing a syntax-directed traversal of the term, assigning fresh type variables to unknown types and generating constraints based on the given typing rules.\n\nLet $\\tau_E$ be the type of the entire expression $E$.\nThe expression is a $\\lambda$-abstraction. According to the typing rule for function abstraction, its type will be a function type. Let $\\alpha_v$ be a fresh type variable for the bound variable $v$, and let $\\alpha_{body}$ be a fresh type variable for the body of the abstraction. The type of $E$ is then $\\tau_E = \\alpha_v \\to \\alpha_{body}$. This defines the final type structure but does not generate a unification constraint in itself.\n\nThe body of the abstraction is the `match` expression, $M = \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to e_2$. The type of this expression is $\\alpha_{body}$.\nThe typing rules for pattern matching on a disjoint sum impose several constraints:\n1.  The type of the expression being matched (the scrutinee), $v$, which is $\\alpha_v$, must be a sum type. We introduce two fresh type variables, $\\alpha_L$ and $\\alpha_R$, to represent the types of the left and right components of the sum. This gives our first constraint, which involves a type constructor:\n    $$C_1: \\alpha_v = \\alpha_L + \\alpha_R$$\n2.  Both branches of the `match` expression must evaluate to the same type. Let $\\alpha_{e1}$ be the type of the first branch expression, $x + 1$, and $\\alpha_{e2}$ be the type of the second branch expression, $\\text{not}\\ y$. This yields a crucial equality constraint:\n    $$C_2: \\alpha_{e1} = \\alpha_{e2}$$\n3.  The type of the entire `match` expression, $\\alpha_{body}$, is the common type of its branches.\n    $$C_3: \\alpha_{body} = \\alpha_{e1}$$\n\nNext, we analyze the types of the branch expressions to generate further constraints.\nIn the left branch, $\\text{Left}\\ x \\to x + 1$, the pattern variable $x$ is bound to the value from the `Left` constructor. Its type is therefore $\\alpha_L$. The expression is $x + 1$. The integer addition operator '$+$' has the declared type $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$, which corresponds to the curried function type $\\mathsf{int} \\to (\\mathsf{int} \\to \\mathsf{int})$.\nFor the application $(+) x$ to be well-typed, the type of $x$, which is $\\alpha_L$, must be equal to the argument type of '$+$', which is $\\mathsf{int}$.\n$$C_4: \\alpha_L = \\mathsf{int}$$\nThe result of $(+) x$ is a function of type $\\mathsf{int} \\to \\mathsf{int}$. This function is then applied to the integer literal $1$, which has type $\\mathsf{int}$. The application is well-typed, and the final type of the expression $x+1$, which is $\\alpha_{e1}$, is the return type $\\mathsf{int}$.\n$$C_5: \\alpha_{e1} = \\mathsf{int}$$\n\nIn the right branch, $\\text{Right}\\ y \\to \\text{not}\\ y$, the pattern variable $y$ has type $\\alpha_R$. The expression is $\\text{not}\\ y$. The unary boolean negation operator 'not' has the declared type $\\mathsf{bool} \\to \\mathsf{bool}$.\nFor the application `not y` to be well-typed, the type of $y$, which is $\\alpha_R$, must be equal to the argument type of 'not', which is $\\mathsf{bool}$.\n$$C_6: \\alpha_R = \\mathsf{bool}$$\nThe result of this application is of type $\\mathsf{bool}$. This is the type of the expression $\\text{not}\\ y$, which is $\\alpha_{e2}$.\n$$C_7: \\alpha_{e2} = \\mathsf{bool}$$\n\nWe have now generated the complete set of primitive equality constraints that are subject to unification:\n$\\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{body} = \\alpha_{e1}, \\alpha_L = \\mathsf{int}, \\alpha_{e1} = \\mathsf{int}, \\alpha_R = \\mathsf{bool}, \\alpha_{e2} = \\mathsf{bool} \\}$.\nThe type system would now attempt to find a substitution (a unifier) that satisfies all these equalities simultaneously.\nHowever, this set is unsatisfiable. The contradiction arises from the following subset of constraints:\n- $C_2: \\alpha_{e1} = \\alpha_{e2}$ (The types of the two branches must be identical.)\n- $C_5: \\alpha_{e1} = \\mathsf{int}$ (The type of the first branch is inferred to be $\\mathsf{int}$.)\n- $C_7: \\alpha_{e2} = \\mathsf{bool}$ (The type of the second branch is inferred to be $\\mathsf{bool}$.)\n\nCombining these three constraints leads to the equality $\\mathsf{int} = \\mathsf{bool}$. Since $\\mathsf{int}$ and $\\mathsf{bool}$ are distinct, non-unifiable base types, this constitutes a contradiction. The term is ill-typed.\n\nThe problem asks for the cardinality of a smallest unsatisfiable subset of these primitive constraints. Let us consider the subset $S_{core} = \\{ C_2, C_5, C_7 \\} = \\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool} \\}$. We have already established that $S_{core}$ is unsatisfiable. To confirm it is a minimal unsatisfiable core (MUC), we must show that removing any single constraint from it results in a satisfiable set.\n\n1.  Removing $C_2$: The set $\\{\\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool}\\}$ is satisfiable by the substitution $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$.\n2.  Removing $C_5$: The set $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e2} = \\mathsf{bool}\\}$ is satisfiable by the substitution $\\{\\alpha_{e1} \\mapsto \\mathsf{bool}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$.\n3.  Removing $C_7$: The set $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}\\}$ is satisfiable by the substitution $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{int}\\}$.\n\nSince each subset of size $2$ is satisfiable, $S_{core}$ is a minimal unsatisfiable core. An unsatisfiable core of size $1$ is impossible as no primitive constraint is of the form $T_1 = T_2$ for distinct constants $T_1, T_2$. An unsatisfiable core of size $2$ would require two constraints like $\\{\\alpha = T_1, \\alpha = T_2\\}$, which do not appear directly in our generated set. Thus, a MUC cannot have a size smaller than $3$. As we have found a MUC of size $3$, this is the size of a smallest unsatisfiable subset.\n\nThe cardinality of this smallest unsatisfiable subset is $3$.", "answer": "$$\\boxed{3}$$", "id": "3624432"}, {"introduction": "To truly understand an algorithm, there is no substitute for implementing it. This final practice moves from paper-and-pencil derivations to tangible code, guiding you to build a miniature constraint solver. By representing types and their domains, and by implementing unification as set intersection, you will make the abstract machinery of type inference concrete and executable. [@problem_id:3624368]", "problem": "Design and implement a complete, runnable program that performs basic type inference by solving type constraints for the simply typed lambda calculus expression $\\lambda x.\\,\\lambda y.\\,(x == y)$, where $==$ denotes the built-in equality operator constrained to a specific set of types. The program must use the following fundamental base from compiler principles and programming language theory: the simply typed lambda calculus, type variables, type environments, and unification via constraint satisfaction on types.\n\nStart from the following core definitions and facts:\n- A type environment associates term variables with type variables or concrete types. For the expression $\\lambda x.\\,\\lambda y.\\,(x == y)$, binders introduce fresh type variables for $x$ and $y$, denoted by $\\alpha$ and $\\beta$.\n- In the simply typed lambda calculus, the typing of $==$ requires both operands to have the same type, and the operator returns a boolean result. The operator $==$ is only defined on a specified set of admissible types, which we denote by $S$.\n- Unification of type constraints is performed by solving equations between types (for example, $\\alpha = \\beta$) together with domain restrictions (for example, $\\alpha \\in S$, $\\beta \\in S$), using set-theoretic intersection on allowed domains.\n\nIn this task, $S$ is fixed to $S = \\{\\text{Int}, \\text{Bool}\\}$, and $==$ is only well-typed when both operands are of the same type from $S$. The expression body $(x == y)$ therefore generates the constraints $\\alpha = \\beta$, $\\alpha \\in S$, and $\\beta \\in S$ for the operand types of $x$ and $y$. From first principles, solving these constraints reduces to computing the intersection of the admissible domains of $\\alpha$ and $\\beta$ with $S$. If the intersection is empty, there is no valid typing for $(x == y)$ under the given assumptions. If the intersection is non-empty, each element in the intersection gives a valid instantiation for both $x$ and $y$, and the entire expression is well-typed with $==$ producing a boolean result.\n\nYour program must implement a small constraint solver for this setting, with the following precise behavior:\n- Represent types using integer codes: $0 \\mapsto \\text{Int}$, $1 \\mapsto \\text{Bool}$, $2 \\mapsto \\text{Float}$, and $3 \\mapsto \\text{Var}$, where $\\text{Var}$ denotes an unconstrained type variable prior to applying constraints. Only $\\text{Int}$ and $\\text{Bool}$ are admissible for $==$; $\\text{Float}$ is included solely to test failure scenarios.\n- Given initial annotations for $x$ and $y$ (each one being one of $0$, $1$, $2$, or $3$), the solver must:\n    1. Interpret $3$ (i.e., $\\text{Var}$) as having the domain $S$.\n    2. Interpret concrete annotations $0$, $1$, and $2$ as singleton domains $\\{\\text{Int}\\}$, $\\{\\text{Bool}\\}$, and $\\{\\text{Float}\\}$ respectively.\n    3. Enforce the equality constraint $\\alpha = \\beta$ and admissibility $\\alpha \\in S$, $\\beta \\in S$ by intersecting the domains of $x$ and $y$ with $S$ and then intersecting the resulting domains with each other.\n    4. Return the list of possible operand type codes for the intersection, restricted to $S$. If there are no solutions, return the empty list $[]$.\n\nDefine and run the following test suite of parameter values. Each test case is a pair $(x\\_\\text{init}, y\\_\\text{init})$ with codes as specified above, designed to cover general and edge conditions:\n- Test case $1$: $(3, 3)$, both $x$ and $y$ unconstrained type variables.\n- Test case $2$: $(0, 3)$, $x$ annotated as $\\text{Int}$ and $y$ unconstrained.\n- Test case $3$: $(1, 1)$, both $x$ and $y$ annotated as $\\text{Bool}$.\n- Test case $4$: $(0, 1)$, $x$ annotated as $\\text{Int}$ and $y$ annotated as $\\text{Bool}$.\n- Test case $5$: $(2, 3)$, $x$ annotated as $\\text{Float}$ (not admissible) and $y$ unconstrained.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed, comma-separated list of the admissible codes corresponding to the operand type solutions. For example, a valid output format is $[[0,1],[0],[1],[],[]]$ for the above test suite if those are the computed solutions. No units or angles are involved. All outputs are integral codes, and empty lists represent no valid solutions.\n\nThe program must be self-contained, require no input, and exactly print the aggregate result list for the specified test suite. The solver must be implemented using principled unification of type domains under the constraints $\\alpha = \\beta$, $\\alpha \\in S$, and $\\beta \\in S$, and must not rely on hard-coded case-by-case outcomes beyond the test case parameters and the admissible set $S$.", "solution": "The problem requires the design and implementation of a program to perform basic type inference for the simply typed lambda calculus expression $\\lambda x.\\,\\lambda y.\\,(x == y)$. This task falls within the domain of compiler theory and programming language semantics, specifically focusing on type systems and constraint-based unification. The core of the problem is to solve a system of type constraints derived from the expression's structure and the typing rules of its operators.\n\nThe expression is $\\lambda x.\\,\\lambda y.\\,(x == y)$. In the simply typed lambda calculus, this expression defines a function that takes two arguments, $x$ and $y$, and compares them for equality. The type inference process proceeds by assigning fresh type variables to the term variables introduced by lambda abstractions. Let the type of $x$ be $\\alpha$ and the type of $y$ be $\\beta$. The type environment $\\Gamma$ is initially populated as $\\Gamma = \\{x : \\alpha, y : \\beta\\}$.\n\nThe body of the function is the expression $(x == y)$. The typing rule for the equality operator, $==$, imposes constraints on the types of its operands. As specified, the operator requires both operands to have the same type, and this type must belong to a predefined set of admissible types, denoted by $S$. The operator itself is defined to return a result of type $\\text{Bool}$. These semantics generate the following set of constraints:\n$1$. Operand type equality: $\\alpha = \\beta$.\n$2$. Admissibility of the first operand's type: $\\alpha \\in S$.\n$3$. Admissibility of the second operand's type: $\\beta \\in S$.\n\nThe set of admissible types for the $==$ operator is given as $S = \\{\\text{Int}, \\text{Bool}\\}$. The problem requires us to represent these types, along with others, using integer codes: $0 \\mapsto \\text{Int}$, $1 \\mapsto \\text{Bool}$, and $2 \\mapsto \\text{Float}$. The code $3$ represents an unconstrained type variable, denoted $\\text{Var}$. With this encoding, the admissible set $S$ corresponds to the set of codes $S_{code} = \\{0, 1\\}$.\n\nThe problem reduces to solving these constraints for different initial annotations of $\\alpha$ and $\\beta$. We can model the types and constraints using set theory. Each type variable is associated with a domain, which is a set of possible concrete types it can instantiate. Constraint solving is then performed by set intersection.\n\nLet $D_x$ be the initial domain of possible types for $x$ (type $\\alpha$), and $D_y$ be the initial domain for $y$ (type $\\beta$). These initial domains are determined by the provided annotations:\n- For a concrete type annotation (codes $0, 1, 2$), the domain is a singleton set. For example, if $x$ is annotated as $\\text{Int}$ (code $0$), then $D_x = \\{\\text{Int}\\} = \\{0\\}$.\n- For a type variable annotation (code $3$), the problem specifies that its domain is interpreted as the admissible set $S$. Thus, if $x$ is annotated as $\\text{Var}$, $D_x = S = \\{\\text{Int}, \\text{Bool}\\} = \\{0, 1\\}$.\n\nThe overall solution for the permissible types of $x$ and $y$ is the set of types that simultaneously satisfies all three constraints. The constraints $\\alpha \\in S$ and $\\beta \\in S$ restrict the domains $D_x$ and $D_y$ to $D_x \\cap S_{code}$ and $D_y \\cap S_{code}$, respectively. The equality constraint $\\alpha = \\beta$ requires that the final type must be common to both, which is achieved by intersecting their restricted domains. The final domain of valid solutions, $D_{sol}$, is therefore:\n$$ D_{sol} = (D_x \\cap S_{code}) \\cap (D_y \\cap S_{code}) $$\nBy the associativity and commutativity of set intersection, this is equivalent to:\n$$ D_{sol} = D_x \\cap D_y \\cap S_{code} $$\nAn empty set $D_{sol} = \\emptyset$ signifies that the constraints are unsatisfiable and the expression is ill-typed for the given initial annotations.\n\nWe now apply this procedure to each test case.\n\n**Test Case 1:** $(x_\\text{init}, y_\\text{init}) = (3, 3)$. Both $x$ and $y$ are unconstrained variables ($\\text{Var}$).\n- Initial domain for $x$: $D_x = D(3) = \\{0, 1\\}$.\n- Initial domain for $y$: $D_y = D(3) = \\{0, 1\\}$.\n- Admissible set: $S_{code} = \\{0, 1\\}$.\n- Solution: $D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0, 1\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\}$.\n- Resulting codes: $[0, 1]$.\n\n**Test Case 2:** $(x_\\text{init}, y_\\text{init}) = (0, 3)$. $x$ is $\\text{Int}$, $y$ is $\\text{Var}$.\n- Initial domain for $x$: $D_x = D(0) = \\{0\\}$.\n- Initial domain for $y$: $D_y = D(3) = \\{0, 1\\}$.\n- Admissible set: $S_{code} = \\{0, 1\\}$.\n- Solution: $D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0\\}$.\n- Resulting codes: $[0]$.\n\n**Test Case 3:** $(x_\\text{init}, y_\\text{init}) = (1, 1)$. Both $x$ and $y$ are $\\text{Bool}$.\n- Initial domain for $x$: $D_x = D(1) = \\{1\\}$.\n- Initial domain for $y$: $D_y = D(1) = \\{1\\}$.\n- Admissible set: $S_{code} = \\{0, 1\\}$.\n- Solution: $D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{1\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\{1\\}$.\n- Resulting codes: $[1]$.\n\n**Test Case 4:** $(x_\\text{init}, y_\\text{init}) = (0, 1)$. $x$ is $\\text{Int}$, $y$ is $\\text{Bool}$.\n- Initial domain for $x$: $D_x = D(0) = \\{0\\}$.\n- Initial domain for $y$: $D_y = D(1) = \\{1\\}$.\n- Admissible set: $S_{code} = \\{0, 1\\}$.\n- Solution: $D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\emptyset$.\n- Resulting codes: $[]$.\n\n**Test Case 5:** $(x_\\text{init}, y_\\text{init}) = (2, 3)$. $x$ is $\\text{Float}$, $y$ is $\\text{Var}$.\n- Initial domain for $x$: $D_x = D(2) = \\{2\\}$.\n- Initial domain for $y$: $D_y = D(3) = \\{0, 1\\}$.\n- Admissible set: $S_{code} = \\{0, 1\\}$.\n- Solution: $D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{2\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\emptyset$. The intersection of $\\{2\\}$ with either $\\{0, 1\\}$ is empty.\n- Resulting codes: $[]$.\n\nThe program will implement this set-based logic. Domains will be represented as arrays of boolean flags, and intersection will be implemented as a logical AND operation across these arrays. The final output aggregates the results from all test cases into the specified format.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// math.h is permitted but not necessary for this problem.\n#include <math.h> \n// complex.h, threads.h, and stdatomic.h are permitted but not used.\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n// The number of distinct type codes (0: Int, 1: Bool, 2: Float, 3: Var).\n#define NUM_TYPES 4\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int x_init;\n    int y_init;\n} TestCase;\n\n// A domain is represented as an array of integers acting as booleans.\n// domain[i] is 1 if type code i is in the set, and 0 otherwise.\ntypedef int Domain[NUM_TYPES];\n\n// get_initial_domain initializes a domain based on a type code annotation.\n// As per the problem, a 'Var' (code 3) is initialized with the domain S = {Int, Bool}.\n// Concrete types (0, 1, 2) are initialized with singleton domains.\nvoid get_initial_domain(int type_code, Domain out_domain) {\n    // Initialize the domain to be an empty set.\n    for (int i = 0; i < NUM_TYPES; ++i) {\n        out_domain[i] = 0;\n    }\n\n    if (type_code == 3) { // Var's domain is S = {Int, Bool}\n        out_domain[0] = 1; // Int\n        out_domain[1] = 1; // Bool\n    } else if (type_code >= 0 && type_code < NUM_TYPES) {\n        out_domain[type_code] = 1; // Singleton domain {type_code}\n    }\n}\n\n// intersect_domains computes the set intersection of two domains.\n// The result is stored in out_domain.\nvoid intersect_domains(const Domain d1, const Domain d2, Domain out_domain) {\n    for (int i = 0; i < NUM_TYPES; ++i) {\n        // Logical AND corresponds to set intersection.\n        out_domain[i] = d1[i] && d2[i];\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {3, 3}, // Test case 1: (Var, Var)\n        {0, 3}, // Test case 2: (Int, Var)\n        {1, 1}, // Test case 3: (Bool, Bool)\n        {0, 1}, // Test case 4: (Int, Bool)\n        {2, 3}  // Test case 5: (Float, Var)\n    };\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    // Define the admissible set S = {Int, Bool} for the '==' operator.\n    const Domain s_domain = {1, 1, 0, 0}; // {Int, Bool, Float, Var}\n\n    // Array to store the resulting solution domain for each test case.\n    Domain results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        Domain domain_x, domain_y, temp_domain;\n\n        // 1. Get initial domains based on annotations.\n        get_initial_domain(test_cases[i].x_init, domain_x);\n        get_initial_domain(test_cases[i].y_init, domain_y);\n\n        // 2. Compute Dx ∩ Dy.\n        intersect_domains(domain_x, domain_y, temp_domain);\n\n        // 3. Compute (Dx ∩ Dy) ∩ S to get the final solution domain.\n        intersect_domains(temp_domain, s_domain, results[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format: [[...],[...],...]\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        // Add a comma separator between test case results.\n        if (i > 0) {\n            printf(\",\");\n        }\n        \n        printf(\"[\");\n        int first_element_printed = 0;\n        // Iterate through possible type codes to print the elements of the solution set.\n        for (int j = 0; j < NUM_TYPES; ++j) {\n            if (results[i][j]) { // If type code j is in the solution set.\n                if (first_element_printed) {\n                    printf(\",\");\n                }\n                printf(\"%d\", j);\n                first_element_printed = 1;\n            }\n        }\n        printf(\"]\");\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3624368"}]}