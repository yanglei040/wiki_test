{"hands_on_practices": [{"introduction": "This practice addresses the most fundamental challenge in implementing closures that outlive their creator: the \"upward funarg\" problem. We will explore how to ensure a closure's captured variables remain valid even after their defining function's stack frame is deallocated. Analyzing the trade-offs of different implementation strategies illuminates why selectively moving captured variables to the heap is the canonical and most efficient solution. [@problem_id:3680362]", "problem": "Consider a conventional call stack on a machine with a distinguished Frame Pointer (FP) and Stack Pointer (SP). An activation record contains, in order from high to low addresses: a saved Return Address (RA), a saved old Frame Pointer (old FP), callee-saved register saves, compiler-generated spill slots and temporaries, space for local variables and parameters treated as locals, and an outgoing-argument area for calls made by the callee. By standard definition, a stack-allocated object’s lifetime ends when its activation record is popped, and a closure that outlives its creating call must preserve the storage of its lexical environment beyond the lifetime of the creating activation record.\n\nA function $f$ has local variables $x$ and $y$ and returns a closure $k$ that references $x$ and $y$ after $f$ returns. You must transform $f$ so that $k$ is valid when invoked later. Assume lexical scoping, pass-by-value parameters, and that $f$ does not pass references to its locals to other threads. The implementation supports a closure object consisting of a code pointer and an environment pointer (EP) to a heap-allocated block.\n\nWhich of the following compiler strategies correctly identifies what must move from $f$’s activation record to the heap and how lifetimes and pointers must be adjusted to preserve semantics with minimal overhead?\n\nA. Move the entire activation record of $f$ (including saved RA, saved old FP, callee-saved register saves, spill slots, locals, and outgoing-argument area) into the heap when returning the closure. Later invocations of $k$ reuse this heap-resident frame directly, requiring no code rewriting for accesses.\n\nB. Allocate a heap environment containing exactly the captured locals of $f$ (here, $x$ and $y$, and any other locals actually referenced by the closure). Rewrite all accesses in the closure’s code to load and store through the environment pointer (EP) instead of $FP$-relative addresses. Do not move saved RA, saved old $FP$, callee-saved register saves, spill slots not captured, or the outgoing-argument area. If the address of a captured local was taken inside $f$, rewrite that address to refer to the corresponding cell inside the heap environment so that aliases remain valid.\n\nC. Keep the original stack frame of $f$ alive by not popping it on return; pass the original $FP$ as the closure’s environment pointer. This preserves the validity of all $FP$-relative addresses and avoids any code rewriting.\n\nD. Move the captured locals and the callee-saved register save area to the heap so that the register state at the time of closure creation is preserved. Keep the saved RA in the heap as well to allow stack unwinding if needed. Rewrite any static links to point to the old $FP$.\n\nE. Copy only the values of the captured locals to the heap environment, but leave any previously taken addresses of those locals pointing to their original stack slots. On each invocation of $k$, synchronize by copying values between the heap environment and the original stack slots to preserve by-reference semantics of aliases.\n\nSelect the single best strategy.", "solution": "The problem statement describes a classic scenario in compiler design and runtime systems known as the \"upward funarg problem\". A function $f$ creates a closure $k$ that captures, or forms a lexical binding to, local variables of $f$. This closure $k$ is then returned from $f$, meaning its lifetime may exceed that of the activation record of $f$. Since the captured variables, $x$ and $y$, are typically allocated on the stack within $f$'s activation record, they will be deallocated when $f$ returns. Any subsequent invocation of $k$ would then access invalid memory, leading to undefined behavior. The task is to identify the correct compiler strategy to resolve this while preserving program semantics and maintaining efficiency (\"minimal overhead\").\n\nA valid strategy must ensure that the storage for any captured variable (an \"escaping\" variable) persists as long as the closure itself can be invoked. The standard and most efficient way to achieve this is to allocate such variables on the heap rather than the stack. The problem states that the implementation provides for a closure object consisting of a code pointer and an environment pointer ($EP$) to a heap-allocated block, which is the standard mechanism for this purpose.\n\nThe core principles of a correct solution are:\n$1$. **Identification:** The compiler must identify which variables' lifetimes need to be extended. These are the variables local to $f$ that are referenced (\"captured\") by the closure $k$. In this case, we are told these are $x$ and $y$. This process is known as escape analysis.\n$2$. **Storage Migration:** The storage for these identified variables must be moved from the stack to a location that will outlive the stack frame, which is the heap.\n$3$. **Access Rewriting:** Code that accesses these migrated variables, both within the original function $f$ and within the closure $k$, must be rewritten. Original accesses would be relative to the Frame Pointer ($FP$). The new accesses must be relative to the pointer to the heap-allocated environment, which is the Environment Pointer ($EP$) stored in the closure object.\n$4. **Semantic Preservation:** The transformation must be semantically transparent. This is particularly important if the address of a captured variable is taken. All pointers to that variable must refer to a single, canonical memory location. If the variable is moved to the heap, any operation that takes its address must yield the address of its heap location, not its original (and now non-existent) stack location.\n$5$. **Efficiency:** The strategy should have minimal overhead. This means moving only the necessary data and avoiding complex, inefficient runtime machinery.\n\nBased on these principles, let us evaluate the given options.\n\n**A. Move the entire activation record of $f$ (including saved RA, saved old FP, callee-saved register saves, spill slots, locals, and outgoing-argument area) into the heap when returning the closure. Later invocations of $k$ reuse this heap-resident frame directly, requiring no code rewriting for accesses.**\n\nThis strategy is grossly inefficient. The activation record contains much data that is irrelevant to the closure $k$. The saved Return Address ($RA$) and saved old Frame Pointer (old $FP$) are part of the dynamic link chain for the call to $f$ and have no meaning for $k$. Callee-saved registers are saved by $f$ for its caller and are restored upon $f$'s return. The outgoing-argument area is for calls that $f$ makes, not for calls $k$ makes. Moving all this data to the heap incurs significant, unnecessary copy overhead and memory usage. It violates the \"minimal overhead\" requirement. While it might seem to simplify access by avoiding some code rewriting, it's a heavyweight and conceptually impure solution.\n**Verdict: Incorrect.**\n\n**B. Allocate a heap environment containing exactly the captured locals of $f$ (here, $x$ and $y$, and any other locals actually referenced by the closure). Rewrite all accesses in the closure’s code to load and store through the environment pointer (EP) instead of $FP$-relative addresses. Do not move saved RA, saved old $FP$, callee-saved register saves, spill slots not captured, or the outgoing-argument area. If the address of a captured local was taken inside $f$, rewrite that address to refer to the corresponding cell inside the heap environment so that aliases remain valid.**\n\nThis strategy aligns perfectly with the principles derived above.\n- It is efficient (\"minimal overhead\") because it only allocates space on the heap for the variables that actually escape ($x$ and $y$).\n- It correctly identifies the need to rewrite accesses to be relative to the Environment Pointer ($EP$).\n- Crucially, it correctly addresses the aliasing problem. By ensuring that any operation generating an address of a captured variable (e.g., `x`) now produces the address of the heap-allocated instance, it maintains a single canonical location for the variable, thereby preserving the program's semantics even in the presence of pointers. This is the standard, correct, and efficient technique used in modern compilers for languages like ML, Lisp, and Scala.\n**Verdict: Correct.**\n\n**C. Keep the original stack frame of $f$ alive by not popping it on return; pass the original $FP$ as the closure’s environment pointer. This preserves the validity of all $FP$-relative addresses and avoids any code rewriting.**\n\nThis strategy is known as a \"spaghetti stack\" because it breaks the strict Last-In, First-Out (LIFO) discipline of a conventional call stack. If $f$'s stack frame is not popped, it creates a \"hole\" in the stack that normal stack management mechanisms ($SP$ manipulation) cannot handle. This complicates memory management immensely, essentially requiring a garbage collector for the stack. The problem specifies a \"conventional call stack,\" which this approach violates. It is impractical and not used in mainstream architectures or compilers due to its complexity and inefficiency.\n**Verdict: Incorrect.**\n\n**D. Move the captured locals and the callee-saved register save area to the heap so that the register state at the time of closure creation is preserved. Keep the saved RA in the heap as well to allow stack unwinding if needed.**\n\nThis is another example of moving unnecessary information. The callee-saved registers are restored by $f$ before it returns, so their saved state is ephemeral and irrelevant after $f$'s execution completes. The closure $k$, when invoked, will have its own execution context and will manage registers according to the calling convention. Similarly, the saved $RA$ of $f$ is for returning from $f$ to its caller; it has no relevance to the execution of $k$. Moving these components to the heap violates the minimal overhead principle and serves no correct semantic purpose.\n**Verdict: Incorrect.**\n\n**E. Copy only the values of the captured locals to the heap environment, but leave any previously taken addresses of those locals pointing to their original stack slots. On each invocation of $k$, synchronize by copying values between the heap environment and the original stack slots to preserve by-reference semantics of aliases.**\n\nThis strategy is fundamentally flawed because it breaks pointer semantics. If a pointer to a local variable $x$ is created, `p = x`, this pointer `p` will refer to a location on the stack. After $f$ returns, this stack location is deallocated, and `p` becomes a dangling pointer. The proposed \"synchronization\" does not fix this; it's an attempt to patch over a broken model. It creates two separate copies of the data (one on the stack, one on the heap), which violates the principle that a variable should have a single canonical storage location. Any update via the dangling pointer `p` would be to invalid memory, and updates to the heap copy would not be reflected in what `p` points to. This strategy fails to preserve program semantics.\n**Verdict: Incorrect.**\n\nThus, strategy B is the only one that correctly and efficiently solves the problem by migrating only the necessary data to the heap and rewriting accesses to maintain semantic correctness, including for aliases.", "answer": "$$\\boxed{B}$$", "id": "3680362"}, {"introduction": "Building on the concept of a closure's environment, this exercise examines a notorious bug that arises from misinterpreting capture semantics. By comparing capture-by-reference with capture-by-value within a loop, you will diagnose a classic programming error where all created closures unexpectedly share the final state of a loop variable. This analysis is crucial for writing correct code in languages with closures and for appreciating the design of modern compiler warnings. [@problem_id:3627909]", "problem": "In a lexically scoped language with first-class functions, a closure is a function packaged with an environment that binds each of its free variables to a storage location. Formally, an environment maps a variable name to a location, and the store maps locations to values; a variable reference reads the value from its location, and an assignment updates the value at that location. A closure may either capture a variable by reference (binding the name to an existing location) or by value (allocating a fresh location initialized with the current value). If a variable’s location must outlive the activation record in which it was introduced, the implementation lifts that location to the heap so that the closures can safely access it after the function returns.\n\nConsider two closure factories that produce a vector of closures by iterating an index variable $i$ from $0$ to $N-1$ and, for each iteration, appending a zero-argument closure that returns the current loop index. The factories differ only in how the loop index $i$ is captured:\n- Factory $\\mathrm{R}$ (reference capture): each closure’s environment maps $i$ to the single loop location for $i$ used by the loop, so all closures share that one location. The implementation reuses exactly one mutable location for the loop index $i$ across all iterations of the loop. If any closure escapes the factory, the compiler lifts that single location to the heap.\n- Factory $\\mathrm{V}$ (value capture): on each iteration, before creating the closure, the compiler allocates a fresh location and initializes it with the current value of $i$, and the closure’s environment maps the index name to that fresh location. Thus, each closure has its own distinct location initialized to the then-current value of $i$.\n\nAssume the closures are invoked only after the factory returns. Let $N=3$ and define the result vectors as follows:\n- For factory $\\mathrm{R}$: evaluate each closure in order of construction and collect their return values into a vector $\\mathrm{res}_{\\mathrm{R}}$.\n- For factory $\\mathrm{V}$: similarly form $\\mathrm{res}_{\\mathrm{V}}$.\n\nA compiler designer wishes to add a static diagnostic to help programmers avoid the classic late-binding loop-capture bug associated with factory $\\mathrm{R}$. Which option best characterizes the observable results and proposes a sound, actionable compiler warning grounded in the above model?\n\nA. $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; emit a warning when a loop variable captured by reference flows into an escaping closure: “loop variable $i$ captured by reference in an escaping closure; capture by value or introduce a per-iteration binding.”\n\nB. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,1,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; no warning is necessary because the compiler must transparently rewrite reference capture to value capture inside loops.\n\nC. $\\mathrm{res}_{\\mathrm{R}}=\\left[2,2,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[2,2,2\\right]$; emit a warning about potential integer overflow of $i$ at $N=3$.\n\nD. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,0,0\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; emit a warning: “closures should not return values; return statements inside closures are deprecated.”", "solution": "The problem statement describes a formal model for closures in a lexically scoped language, distinguishing between capture-by-reference and capture-by-value semantics. It asks for the evaluation of two specific scenarios and the formulation of an appropriate compiler diagnostic.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Language: Lexically scoped, first-class functions.\n- Closure: A function packaged with an environment.\n- Environment: Maps variable names to storage locations.\n- Store: Maps locations to values.\n- Capture by reference (Factory $\\mathrm{R}$): A closure's environment maps a variable name to an existing, shared location. Specifically, all closures created in the loop share the single location for the loop index $i$.\n- Capture by value (Factory $\\mathrm{V}$): A closure's environment maps a variable name to a fresh location, which is initialized with the variable's value at the time of closure creation.\n- Heap lifting: A location is moved to the heap if it must outlive its original activation record.\n- Loop: Iterates with index $i$ from $0$ to $N-1$.\n- Parameter: $N=3$.\n- Scenario: Two factories, $\\mathrm{R}$ and $\\mathrm{V}$, each produce a vector of zero-argument closures. Each closure, when invoked, returns the value of the loop index $i$.\n- Execution: All closures are invoked *after* their respective factory function has returned.\n- Outputs: $\\mathrm{res}_{\\mathrm{R}}$ and $\\mathrm{res}_{\\mathrm{V}}$ are vectors containing the return values of the closures from factories $\\mathrm{R}$ and $\\mathrm{V}$, respectively.\n- Question: Characterize $\\mathrm{res}_{\\mathrm{R}}$ and $\\mathrm{res}_{\\mathrm{V}}$ and propose a sound, actionable compiler warning for the situation in factory $\\mathrm{R}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically and technically sound. The model of closures, environments, stores, and capture semantics is a standard and fundamental concept in compiler design and programming language theory. The problem is well-posed: the initial conditions are clear, the process is deterministic, and the question is specific. There are no contradictions, ambiguities, or missing information. The scenario described is a classic and highly practical illustration of closure behavior, often referred to as the \"late-binding loop problem\" in languages like Python or JavaScript. The problem is objective and formalizable.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed with the derivation and analysis.\n\n### Derivation of Results\n\nThe loop iterates for an index variable $i$ from $0$ to $N-1$. Given $N=3$, the loop body will execute for $i=0$, $i=1$, and $i=2$. A standard loop construct, such as `for (i = 0; i  N; ++i)`, will terminate when the condition $i  3$ is no longer true. This occurs after $i$ is incremented from $2$ to $3$. Therefore, the value of the single loop variable $i$ after the loop has completed is $3$.\n\n**Analysis of Factory $\\mathrm{R}$ (Reference Capture)**\nAccording to the problem description, factory $\\mathrm{R}$ uses a single, mutable location for the loop index $i$. All closures created within the loop capture a reference to this same location.\n1.  A single storage location, let's call it $L_i$, is allocated for the variable $i$.\n2.  During the loop's execution ($i=0, 1, 2$), three closures are created and appended to a vector. Each of these closures' environments contains a binding from the name '$i$' to the location $L_i$.\n3.  The loop completes. The final value stored in location $L_i$ is $3$.\n4.  The factory function returns. Since the closures have escaped the function's scope, the location $L_i$ is lifted to the heap to ensure it remains valid, preserving its final value of $3$.\n5.  After the factory returns, the closures are invoked. When each closure is called, it resolves the variable $i$ by accessing the location $L_i$ via its environment. At the time of invocation, the value stored at $L_i$ is $3$.\n6.  Each of the three closures will read and return the value $3$.\nTherefore, the resulting vector is $\\mathrm{res}_{\\mathrm{R}} = \\left[3, 3, 3\\right]$.\n\n**Analysis of Factory $\\mathrm{V}$ (Value Capture)**\nAccording to the problem description, factory $\\mathrm{V}$ allocates a fresh location for each closure, initialized with the current value of $i$.\n1.  **Iteration $i=0$**: A new location, $L_{V0}$, is allocated and initialized with the value $0$. The first closure is created with an environment mapping '$i$' to $L_{V0}$.\n2.  **Iteration $i=1$**: A new location, $L_{V1}$, is allocated and initialized with the value $1$. The second closure is created with an environment mapping '$i$' to $L_{V1}$.\n3.  **Iteration $i=2$**: A new location, $L_{V2}$, is allocated and initialized with the value $2$. The third closure is created with an environment mapping '$i$' to $L_{V2}$.\n4.  The loop completes. The original loop variable location is of no consequence to the created closures, as they each have their own private location for $i$.\n5.  After the factory returns, the closures are invoked.\n6.  The first closure reads from its location $L_{V0}$ and returns $0$.\n7.  The second closure reads from its location $L_{V1}$ and returns $1$.\n8.  The third closure reads from its location $L_{V2}$ and returns $2$.\nTherefore, the resulting vector is $\\mathrm{res}_{\\mathrm{V}} = \\left[0, 1, 2\\right]$.\n\n**Compiler Warning**\nThe behavior of factory $\\mathrm{R}$ is a common source of bugs. Programmers often intend to capture the value of the loop variable for each iteration, not a reference to the single, changing variable. A compiler diagnostic should help prevent this error. A sound warning must correctly identify the problematic pattern: a loop variable captured by reference in a closure that outlives the loop (an \"escaping\" closure). An actionable warning should suggest a correct alternative, such as explicitly capturing by value or creating a new, per-iteration variable and capturing that instead (which simulates capture-by-value).\n\n### Option-by-Option Analysis\n\n**A. $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; emit a warning when a loop variable captured by reference flows into an escaping closure: “loop variable $i$ captured by reference in an escaping closure; capture by value or introduce a per-iteration binding.”**\n-   **Result Characterization**: The calculated results, $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$ and $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$, match my derivation precisely.\n-   **Proposed Warning**: The warning correctly identifies the specific conditions that lead to the surprising behavior (loop variable, reference capture, escaping closure). The suggested remedies (\"capture by value\" or \"introduce a per-iteration binding\") are the standard, correct ways to achieve the likely intended behavior. The warning is both sound and actionable.\n-   **Verdict**: **Correct**.\n\n**B. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,1,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; no warning is necessary because the compiler must transparently rewrite reference capture to value capture inside loops.**\n-   **Result Characterization**: The result for $\\mathrm{res}_{\\mathrm{R}}$ is incorrect. It fails to account for the fact that all closures reference the same location, which holds the final value of $i$ after the loop.\n-   **Proposed Action**: The assertion that a compiler *must* perform this rewrite is a language design choice, not a universal truth. Many languages (e.g., C++) provide explicit control over capture mode, and automatically changing the programmer's specified semantics would be incorrect and could break code that intentionally relies on reference capture. A warning is a more appropriate and safer static analysis tool.\n-   **Verdict**: **Incorrect**.\n\n**C. $\\mathrm{res}_{\\mathrm{R}}=\\left[2,2,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[2,2,2\\right]$; emit a warning about potential integer overflow of $i$ at $N=3$.**\n-   **Result Characterization**: Both results are incorrect. For $\\mathrm{res}_{\\mathrm{R}}$, the final value of $i$ is $3$ (the value that causes the loop to terminate), not $2$ (the last value used in an iteration). For $\\mathrm{res}_{\\mathrm{V}}$, the values should be distinct per iteration, i.e., $\\left[0,1,2\\right]$.\n-   **Proposed Warning**: The warning about integer overflow is completely irrelevant to the problem. The value $3$ is well within the capacity of any standard integer type. The core issue is about variable binding and scope, not arithmetic limits.\n-   **Verdict**: **Incorrect**.\n\n**D. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,0,0\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; emit a warning: “closures should not return values; return statements inside closures are deprecated.”**\n-   **Result Characterization**: The result for $\\mathrm{res}_{\\mathrm{R}}$ is incorrect. It mistakenly assumes the closures capture the initial value of $i$ ($0$), rather than a reference to a location whose value is updated to $3$. The result for $\\mathrm{res}_{\\mathrm{V}}$ is correct.\n-   **Proposed Warning**: The warning is nonsensical. Closures are first-class functions, and returning values is a primary and essential capability. Declaring this as \"deprecated\" contradicts the fundamental principles of functional and modern multi-paradigm programming. The warning does not address the actual problem of capture semantics.\n-   **Verdict**: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3627909"}, {"introduction": "While heap-allocating an environment is necessary, it introduces overhead that compilers strive to minimize. This practice applies a standard data-flow analysis technique—live-variable analysis—to perform a key optimization: eliminating dead captures. By tracing the flow of data, you will determine the minimal set of variables that are actually used by the closure, thereby reducing the size and cost of its environment. [@problem_id:3627881]", "problem": "Consider an intermediate representation of a program in a compiler that implements lexical closures under capture-by-reference semantics. A lexical closure is created at a specific program point and may be invoked after subsequent control flow. The closure environment stores bindings for free variables referenced by the closure. To eliminate dead captures, we wish to include only variables whose live ranges intersect the closure creation point. Use standard backward live-variable Data Flow Analysis (DFA) on a Control Flow Graph (CFG), with the following fundamental definitions:\n- A variable $v$ is live at program point $p$ if and only if there exists a path from $p$ to a use of $v$ that does not pass through a redefinition of $v$.\n- For each basic block $n$, the live-variable equations are\n$$\\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup \\left(\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]\\right), \\qquad \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s],$$\nwhere $\\mathrm{USE}[n]$ is the set of variables used before any definition in $n$, $\\mathrm{DEF}[n]$ is the set of variables defined in $n$, and $\\mathrm{Succ}(n)$ are the successors of $n$ in the CFG.\n\nThe program has outer-scope local variables $a$, $b$, $c$, $d$ with byte sizes $s_a = 8$, $s_b = 8$, $s_c = 4$, $s_d = 16$. The closure is created at the end of basic block $B_3$. To model liveness across the closure boundary, add an edge from $B_3$ to the entry of the closure body, $G_1$, in the CFG. The outer program and the closure body are given in three-address code by the following basic blocks:\n\n- Outer program:\n  - $B_1$: $a := 1;$ $b := 2;$ $c := b + a;$ goto $B_2$.\n  - $B_2$ branches to $B_2^\\mathrm{T}$ or $B_2^\\mathrm{F}$:\n    - $B_2^\\mathrm{T}$: if cond then $a := a + 1;$ goto $B_3$.\n    - $B_2^\\mathrm{F}$: else $c := b + 3;$ goto $B_3$.\n  - $B_3$: $t := \\mathrm{closure}(\\lambda u.\\ \\text{body } G);$ if cond2 then $d := a + c$ else $b := b + 5;$ goto $B_4$.\n  - $B_4$: call $h(t);$ return.\n\n- Closure body:\n  - $G_1$: $x := a + c;$ goto $G_2$.\n  - $G_2$: if $\\phi$ then $y := b$ else $y := a;$ goto $G_3$.\n  - $G_3$: return $x + y$.\n\nAssume variables $x$ and $y$ are local to the closure and are not part of the outer variable set. Using the live-variable DFA definitions above, compute the minimal closure environment as the set of outer variables whose live ranges intersect the closure creation point at the end of $B_3$. Then, compute the total environment size in bytes as the sum of the sizes $s_v$ for $v$ in that minimal set. Express your final answer as an exact integer number of bytes. No rounding is required. State your final numeric answer in bytes.", "solution": "The problem requires the computation of the minimal size of a lexical closure's environment. This is achieved by identifying the set of free variables of the closure whose live ranges intersect the closure's creation point. The problem specifies using backward live-variable data flow analysis (DFA) on the program's Control Flow Graph (CFG).\n\nFirst, we establish the CFG and determine the `USE` and `DEF` sets for each basic block. The program consists of an outer function with blocks $B_1, B_2, B_2^\\mathrm{T}, B_2^\\mathrm{F}, B_3, B_4$ and a closure body with blocks $G_1, G_2, G_3$. The outer-scope variables are $\\{a, b, c, d\\}$, and the closure's local variables are $\\{x, y\\}$.\n\nThe CFG successor relationships, $\\mathrm{Succ}(n)$, are as follows:\n- $\\mathrm{Succ}(B_1) = \\{B_2\\}$\n- For simplicity in analysis, we can combine the empty branching block $B_2$ with its successors. However, following the given structure: $\\mathrm{Succ}(B_2) = \\{B_2^\\mathrm{T}, B_2^\\mathrm{F}\\}$.\n- $\\mathrm{Succ}(B_2^\\mathrm{T}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_2^\\mathrm{F}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_3) = \\{B_4, G_1\\}$. The edge from $B_3$ to $G_1$ is explicitly added to model liveness for the closure invocation.\n- $\\mathrm{Succ}(B_4) = \\emptyset$ (due to the `return` statement).\n- $\\mathrm{Succ}(G_1) = \\{G_2\\}$\n- $\\mathrm{Succ}(G_2) = \\{G_3\\}$\n- $\\mathrm{Succ}(G_3) = \\emptyset$ (due to the `return` statement).\n\nNext, we determine the $\\mathrm{USE}[n]$ and $\\mathrm{DEF}[n]$ sets for each basic block $n$. $\\mathrm{USE}[n]$ contains variables used in $n$ before any definition, and $\\mathrm{DEF}[n]$ contains variables defined in $n$.\n- $B_1: a := 1; b := 2; c := b + a;$\n  - $\\mathrm{USE}[B_1] = \\emptyset$\n  - $\\mathrm{DEF}[B_1] = \\{a, b, c\\}$\n- $B_2$: branches\n  - $\\mathrm{USE}[B_2] = \\emptyset$\n  - $\\mathrm{DEF}[B_2] = \\emptyset$\n- $B_2^\\mathrm{T}: a := a + 1;$\n  - $\\mathrm{USE}[B_2^\\mathrm{T}] = \\{a\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{T}] = \\{a\\}$\n- $B_2^\\mathrm{F}: c := b + 3;$\n  - $\\mathrm{USE}[B_2^\\mathrm{F}] = \\{b\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{F}] = \\{c\\}$\n- $B_3: t := \\mathrm{closure}(...); \\text{if cond2 then } d := a + c \\text{ else } b := b + 5;$\n  - $\\mathrm{USE}[B_3] = \\{a, b, c\\}$\n  - $\\mathrm{DEF}[B_3] = \\{b, d\\}$ (variables that may be defined)\n- $B_4: \\text{call } h(t); \\text{return};$\n  - $\\mathrm{USE}[B_4] = \\emptyset$ (with respect to $\\{a, b, c, d, x, y\\}$)\n  - $\\mathrm{DEF}[B_4] = \\emptyset$\n- $G_1: x := a + c;$\n  - $\\mathrm{USE}[G_1] = \\{a, c\\}$\n  - $\\mathrm{DEF}[G_1] = \\{x\\}$\n- $G_2: \\text{if } \\phi \\text{ then } y := b \\text{ else } y := a;$\n  - $\\mathrm{USE}[G_2] = \\{a, b\\}$\n  - $\\mathrm{DEF}[G_2] = \\{y\\}$\n- $G_3: \\text{return } x + y;$\n  - $\\mathrm{USE}[G_3] = \\{x, y\\}$\n  - $\\mathrm{DEF}[G_3] = \\emptyset$\n\nWe apply the live-variable equations iteratively until the $\\mathrm{IN}$ and $\\mathrm{OUT}$ sets converge. We initialize all sets to $\\emptyset$.\n$$ \\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup (\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]) $$\n$$ \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s] $$\n\n**Iteration 1:**\n- $\\mathrm{OUT}[B_4] = \\emptyset$\n- $\\mathrm{IN}[B_4] = \\mathrm{USE}[B_4] \\cup (\\mathrm{OUT}[B_4] \\setminus \\mathrm{DEF}[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$\n- $\\mathrm{OUT}[G_3] = \\emptyset$\n- $\\mathrm{IN}[G_3] = \\mathrm{USE}[G_3] \\cup (\\mathrm{OUT}[G_3] \\setminus \\mathrm{DEF}[G_3]) = \\{x, y\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y\\}$\n- $\\mathrm{OUT}[G_2] = \\mathrm{IN}[G_3] = \\{x, y\\}$\n- $\\mathrm{IN}[G_2] = \\mathrm{USE}[G_2] \\cup (\\mathrm{OUT}[G_2] \\setminus \\mathrm{DEF}[G_2]) = \\{a, b\\} \\cup (\\{x, y\\} \\setminus \\{y\\}) = \\{a, b, x\\}$\n- $\\mathrm{OUT}[G_1] = \\mathrm{IN}[G_2] = \\{a, b, x\\}$\n- $\\mathrm{IN}[G_1] = \\mathrm{USE}[G_1] \\cup (\\mathrm{OUT}[G_1] \\setminus \\mathrm{DEF}[G_1]) = \\{a, c\\} \\cup (\\{a, b, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_3] = \\mathrm{IN}[B_4] \\cup \\mathrm{IN}[G_1] = \\emptyset \\cup \\{a, b, c\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_3] = \\mathrm{USE}[B_3] \\cup (\\mathrm{OUT}[B_3] \\setminus \\mathrm{DEF}[B_3]) = \\{a, b, c\\} \\cup (\\{a, b, c\\} \\setminus \\{b, d\\}) = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{T}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{T}] = \\mathrm{USE}[B_2^\\mathrm{T}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{T}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{T}]) = \\{a\\} \\cup (\\{a, b, c\\} \\setminus \\{a\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{F}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{F}] = \\mathrm{USE}[B_2^\\mathrm{F}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{F}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{F}]) = \\{b\\} \\cup (\\{a, b, c\\} \\setminus \\{c\\}) = \\{b\\} \\cup \\{a, b\\} = \\{a, b\\}$\n- $\\mathrm{OUT}[B_2] = \\mathrm{IN}[B_2^\\mathrm{T}] \\cup \\mathrm{IN}[B_2^\\mathrm{F}] = \\{a, b, c\\} \\cup \\{a, b\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2] = \\mathrm{USE}[B_2] \\cup (\\mathrm{OUT}[B_2] \\setminus \\mathrm{DEF}[B_2]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_1] = \\mathrm{IN}[B_2] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_1] = \\mathrm{USE}[B_1] \\cup (\\mathrm{OUT}[B_1] \\setminus \\mathrm{DEF}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\{a, b, c\\}) = \\emptyset$\n\nA second iteration reveals that all $\\mathrm{IN}$ and $\\mathrm{OUT}$ sets are unchanged, so the analysis has converged to a fixed point.\n\nThe problem states that the \"minimal closure environment as the set of outer variables whose live ranges intersect the closure creation point at the end of basic block $B_3$\". In the context of DFA on basic blocks, the set of variables live at the end of a block $n$ is $\\mathrm{OUT}[n]$.\n\nFrom our analysis, the set of live variables at the end of block $B_3$ is:\n$$ \\mathrm{OUT}[B_3] = \\{a, b, c\\} $$\nThese variables are live due to their subsequent uses, either in the closure body (path to $G_1$) or in the main program flow (path to $B_4$, although in this case $\\mathrm{IN}[B_4]=\\emptyset$). The liveness of $\\{a, b, c\\}$ is entirely determined by their use inside the closure body, propagated backwards to become $\\mathrm{IN}[G_1]$, which in turn determines $\\mathrm{OUT}[B_3]$.\n\nThe set of outer-scope variables is $\\{a, b, c, d\\}$. The minimal closure environment consists of the variables in this set that are also in $\\mathrm{OUT}[B_3]$.\n$$ \\text{Captured Variables} = \\mathrm{OUT}[B_3] \\cap \\{a, b, c, d\\} = \\{a, b, c\\} $$\nThe variable $d$ is not captured because it is not live after block $B_3$; there is no path from the end of $B_3$ to a use of $d$.\n\nFinally, we compute the total size of this environment using the given sizes of the captured variables: $s_a = 8$ bytes, $s_b = 8$ bytes, and $s_c = 4$ bytes.\n$$ \\text{Total Size} = s_a + s_b + s_c = 8 + 8 + 4 = 20 \\text{ bytes} $$\nThe total environment size is $20$ bytes.", "answer": "$$\\boxed{20}$$", "id": "3627881"}]}