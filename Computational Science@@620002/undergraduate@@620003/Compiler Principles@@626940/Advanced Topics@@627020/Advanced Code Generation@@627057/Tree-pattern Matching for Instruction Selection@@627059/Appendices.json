{"hands_on_practices": [{"introduction": "The core of tree-pattern matching for instruction selection is a dynamic programming algorithm that finds a minimum-cost 'tiling' of an expression tree with instruction patterns. This first exercise provides a direct, hands-on application of this principle. By calculating and comparing the costs of covering an expression tree with two different sets of available instructions, you will gain a practical understanding of how an instruction selector makes optimal, cost-based decisions [@problem_id:3679133].", "problem": "You are designing a teaching Instruction Set Architecture (ISA) to illustrate tree-pattern matching for instruction selection. The ISA supports the following instruction tiles, each of which emits exactly one machine instruction when selected:\n\n- A binary addition tile that matches the tree pattern $+(x,y)$ with cost $1$.\n- A shift-left-by-constant tile that matches the tree pattern $\\ll(x,k)$ for integral $k$ with cost $1$.\n- A family of addressing-mode tiles (generalized Load Effective Address, written as $LEA$) that match either $+(x,\\ll(x,k))$ or $+(\\ll(x,k),x)$ when the same subexpression $x$ appears twice. For these tiles:\n  - If $k \\in \\{0,1,2,3\\}$, the cost is $1$.\n  - If $k \\in \\{4,5\\}$, the cost is $2$.\n  - If $k \\notin \\{0,1,2,3,4,5\\}$, the pattern cannot be matched.\n\nAssume leaves $a$, $b$, $c$ are already resident in registers and can be used as operands with zero cost. No reassociation or algebraic rewrites are permitted beyond matching both $+(x,\\ll(x,k))$ and $+(\\ll(x,k),x)$ as the same $LEA$ pattern. You must use bottom-up tree-pattern matching and compute an optimal cover of the given expression tree by minimizing the sum of tile costs.\n\nConsider the expression tree\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\nLet $C_{\\text{base}}$ denote the minimal total cost when only the addition and shift tiles are available (i.e., $LEA$ tiles are disallowed). Let $C_{\\text{lea}}$ denote the minimal total cost when all the above tiles, including the $LEA$ family, are available as separate tiles for each encodable $k$ with the stated costs.\n\nCompute the single numeric quantity\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\nProvide your final answer as a single real number. No rounding is required. No units are necessary.", "solution": "The user wants me to solve the following problem:\nYou are designing a teaching Instruction Set Architecture (ISA) to illustrate tree-pattern matching for instruction selection. The ISA supports the following instruction tiles, each of which emits exactly one machine instruction when selected:\n\n- A binary addition tile that matches the tree pattern $+(x,y)$ with cost $1$.\n- A shift-left-by-constant tile that matches the tree pattern $\\ll(x,k)$ for integral $k$ with cost $1$.\n- A family of addressing-mode tiles (generalized Load Effective Address, written as $LEA$) that match either $+(x,\\ll(x,k))$ or $+(\\ll(x,k),x)$ when the same subexpression $x$ appears twice. For these tiles:\n  - If $k \\in \\{0,1,2,3\\}$, the cost is $1$.\n  - If $k \\in \\{4,5\\}$, the cost is $2$.\n  - If $k \\notin \\{0,1,2,3,4,5\\}$, the pattern cannot be matched.\n\nAssume leaves $a$, $b$, $c$ are already resident in registers and can be used as operands with zero cost. No reassociation or algebraic rewrites are permitted beyond matching both $+(x,\\ll(x,k))$ and $+(\\ll(x,k),x)$ as the same $LEA$ pattern. You must use bottom-up tree-pattern matching and compute an optimal cover of the given expression tree by minimizing the sum of tile costs.\n\nConsider the expression tree\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\nLet $C_{\\text{base}}$ denote the minimal total cost when only the addition and shift tiles are available (i.e., $LEA$ tiles are disallowed). Let $C_{\\text{lea}}$ denote the minimal total cost when all the above tiles, including the $LEA$ family, are available as separate tiles for each encodable $k$ with the stated costs.\n\nCompute the single numeric quantity\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\nProvide your final answer as a single real number. No rounding is required. No units are necessary.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement.\n\n#### 1.1. Extract Givens\n- **Tiles (Base):**\n  1. `$+(x,y)$`, cost `$1$`.\n  2. `$\\ll(x,k)$` for integral `$k$`, cost `$1$`.\n- **Tiles (LEA):**\n  1. `$+(x,\\ll(x,k))$` or `$+(`\\ll(x,k)`, `x)`.\n     - Cost `$1$` if `$k \\in \\{0,1,2,3\\}$`.\n     - Cost `$2$` if `$k \\in \\{4,5\\}$`.\n- **Operands:** Leaves `$a, b, c$` have cost `$0$`.\n- **Method:** Bottom-up tree-pattern matching (dynamic programming) for minimal cost.\n- **Constraints:** No reassociation or algebraic rewrites beyond the specific $LEA$ pattern.\n- **Expression Tree:** `$E = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big)$`.\n- **Quantities to Find:**\n  - `$C_{\\text{base}}$`: minimal cost with only base tiles.\n  - `$C_{\\text{lea}}$`: minimal cost with all tiles.\n  - `$D = C_{\\text{base}} - C_{\\text{lea}}$`.\n\n#### 1.2. Validate Using Extracted Givens\nThe problem is well-defined within the domain of compiler theory, specifically instruction selection via tree-pattern matching. This is a standard application of dynamic programming on trees.\n- **Scientifically Grounded:** The concepts are fundamental to compiler design. The ISA is a simplified but plausible model for educational purposes. All principles are sound within computer science.\n- **Well-Posed:** The expression tree, tile set, costs, and optimization goal (minimum total cost) are all explicitly defined. This structure guarantees a unique minimal cost for each case, making the problem well-posed.\n- **Objective and Complete:** The problem is stated using formalisms and contains all necessary information to derive a solution. There are no subjective or ambiguous terms.\n\n#### 1.3. Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Step 2: Solution Derivation\n\nThe problem requires computing the minimal cost to cover the given expression tree with two different sets of instruction tiles. We will use a bottom-up dynamic programming approach, computing the minimal cost for each subtree. Let `$cost(N)$` denote the minimal cost to evaluate the subtree rooted at node `$N$`. The cost for the leaves `$a, b, c$` is given as `$0$`.\n\nLet us decompose the expression tree `$E$` into its primary subtrees:\n- `$E_1 = +(a, \\ll(a,3))$`\n- `$E_2 = +(b, \\ll(b,4))$`\n- `$E_3 = +(\\ll(c,5), c)`\nThe full tree is `$E = +\\big(+(E_1, E_2), E_3\\big)`.\n\n#### 2.1. Calculation of $C_{\\text{base}}$\n\nIn this scenario, only the addition tile (`cost = 1`) and shift tile (`cost = 1`) are available. Let `$cost_B(N)$` be the cost of a subtree `$N$`.\n\n1.  **Cost of shift subtrees:**\n    - `$cost_B(\\ll(a,3)) = \\text{cost}(\\ll) + cost_B(a) = 1 + 0 = 1$`. A single shift tile is used.\n    - `$cost_B(\\ll(b,4)) = \\text{cost}(\\ll) + cost_B(b) = 1 + 0 = 1$`.\n    - `$cost_B(\\ll(c,5)) = \\text{cost}(\\ll) + cost_B(c) = 1 + 0 = 1$`.\n\n2.  **Cost of subtrees $E_1, E_2, E_3$:**\n    - For `$E_1 = +(a, \\ll(a,3))`, we must use an addition tile. The cost is the tile cost plus the costs of its children's subtrees:\n      `$cost_B(E_1) = \\text{cost}(+) + cost_B(a) + cost_B(\\ll(a,3)) = 1 + 0 + 1 = 2$`.\n    - Similarly for `$E_2 = +(b, \\ll(b,4))`:\n      `$cost_B(E_2) = \\text{cost}(+) + cost_B(b) + cost_B(\\ll(b,4)) = 1 + 0 + 1 = 2$`.\n    - And for `$E_3 = +(\\ll(c,5), c)`:\n      `$cost_B(E_3) = \\text{cost}(+) + cost_B(\\ll(c,5)) + cost_B(c) = 1 + 1 + 0 = 2$`.\n\n3.  **Cost of intermediate and root nodes:**\n    - The next node is `_`$+(E_1, E_2)`:\n      `$cost_B(+(E_1, E_2)) = \\text{cost}(+) + cost_B(E_1) + cost_B(E_2) = 1 + 2 + 2 = 5$`.\n    - The root node is `$E = +\\big(+(E_1, E_2), E_3\\big)`:\n      `$cost_B(E) = \\text{cost}(+) + cost_B(+(E_1, E_2)) + cost_B(E_3) = 1 + 5 + 2 = 8$`.\n\nTherefore, the minimal cost using only the base tiles is `$C_{\\text{base}} = 8$`.\n\n#### 2.2. Calculation of $C_{\\text{lea}}$\n\nNow, we introduce the `$LEA$` family of tiles. At each `+` node, we must check if a `$LEA$` tile can provide a less expensive cover. Let `$cost_L(N)$` be the cost of a subtree `$N$`.\n\n1.  **Cost of shift subtrees:** These are unaffected as no new tiles match them.\n    - `$cost_L(\\ll(a,3)) = 1$`\n    - `$cost_L(\\ll(b,4)) = 1$`\n    - `$cost_L(\\ll(c,5)) = 1$`\n\n2.  **Cost of subtree $E_1 = +(a, \\ll(a,3))$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(a) + cost_L(\\ll(a,3)) = 1 + 0 + 1 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+(x, \\ll(x,k))$` matches with `$x=a$` and `$k=3$`. Since `$k=3` is in the set `$\\{0,1,2,3\\}$`, the cost of this tile is `$1$`. This tile covers the entire subtree `$E_1$`.\n    - The minimal cost is `$cost_L(E_1) = \\min(2, 1) = 1$`.\n\n3.  **Cost of subtree $E_2 = +(b, \\ll(b,4))$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(b) + cost_L(\\ll(b,4)) = 1 + 0 + 1 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+(x, \\ll(x,k))$` matches with `$x=b$` and `$k=4$`. Since `$k=4$` is in the set `$\\{4,5\\}$`, the cost of this tile is `$2$`.\n    - The minimal cost is `$cost_L(E_2) = \\min(2, 2) = 2$`.\n\n4.  **Cost of subtree $E_3 = +(\\ll(c,5), c)$:**\n    - **Option 1 (ADD tile):** `$cost_L = \\text{cost}(+) + cost_L(\\ll(c,5)) + cost_L(c) = 1 + 1 + 0 = 2$`.\n    - **Option 2 (LEA tile):** The pattern `$+(`\\ll(x,k)`, `x)` matches with `$x=c$` and `$k=5$`. Since `$k=5$` is in the set `$\\{4,5\\}$`, the cost of this tile is `$2$`.\n    - The minimal cost is `$cost_L(E_3) = \\min(2, 2) = 2$`.\n\n5.  **Cost of intermediate and root nodes:**\n    - The node `_`$+(E_1, E_2)` does not match any `$LEA$` pattern. We must use an addition tile.\n      `$cost_L(+(E_1, E_2)) = \\text{cost}(+) + cost_L(E_1) + cost_L(E_2) = 1 + 1 + 2 = 4$`.\n    - The root node `$E = +\\big(+(E_1, E_2), E_3\\big)` also does not match any `$LEA$` pattern. We must use an addition tile.\n      `$cost_L(E) = \\text{cost}(+) + cost_L(+(E_1, E_2)) + cost_L(E_3) = 1 + 4 + 2 = 7$`.\n\nTherefore, the minimal cost using all available tiles is `$C_{\\text{lea}} = 7$`.\n\n#### 2.3. Final Calculation\n\nWe are asked to compute `$D = C_{\\text{base}} - C_{\\text{lea}}$`.\nUsing our calculated values:\n`$D = 8 - 7 = 1$`.\nThe difference in cost is due to the ability to cover the subtree `$+(a, \\ll(a,3))$` with a single, lower-cost `$LEA$` instruction (cost `$1$`) instead of a combination of a shift and an add instruction (total cost `$2$`). For the other two potential `$LEA$` matches, the special tile offered no cost improvement over the generic composition.", "answer": "$$\n\\boxed{1}\n$$", "id": "3679133"}, {"introduction": "While minimizing cost is a primary goal, the foremost requirement for any compiler transformation is correctness. A pattern match that is structurally valid but semantically incorrect is one of the most subtle and dangerous bugs in a compiler. This problem [@problem_id:3679147] explores this critical dimension by examining the popular optimization of replacing division by a power of two with a bit-shift, revealing how differences in rounding behavior require careful, type-aware handling by the matcher.", "problem": "A compiler backend performs Instruction Selection (IS) for a tree-structured Intermediate Representation (IR). Consider the IR node representing integer division by a constant power of two, written as the binary operator tree $/(x,2)$ where the operator $/$ denotes integer division by $2$ and the operand $x$ is a value of some machine integer type. The target architecture provides an arithmetic right shift instruction $\\text{SAR}(u,k)$ that sign-extends $u$ and shifts right by $k$ bits, and a logical right shift instruction $\\text{SHR}(u,k)$ that zero-extends $u$ and shifts right by $k$ bits. The compiler’s IR is typed and distinguishes signed from unsigned integer operations.\n\nStarting from the following fundamental bases:\n- In two’s-complement representation, an arithmetic right shift $\\text{SAR}(x,1)$ replicates the sign bit and is algebraically equivalent to multiplying by $2^{-1}$ with rounding toward negative infinity for negative odd $x$.\n- A logical right shift $\\text{SHR}(x,1)$ zero-fills the high-order bits and corresponds to division by $2$ for unsigned integers with truncation that matches unsigned integer division semantics.\n- Language or IR semantics for signed integer division may specify rounding toward zero; this differs from rounding toward negative infinity for negative odd $x$.\n\nYou are designing a tree-pattern matcher that may rewrite $\\mathrm{sdiv}(x,2)$ to a shift when legal. Which option correctly proposes a pattern that uses $\\text{SAR}(x,1)$ only when $x$ is signed and also specifies how the matcher must incorporate type information or guards to avoid illegal matches?\n\nA. Match the typed signed-division node $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SAR}(x,1)$, but only under the guard that either the IR’s signed division semantics round toward negative infinity or that a proven range analysis ensures $x \\ge 0$. Otherwise, do not match.\n\nB. Match any occurrence of $/(x,2)$ where $x$ is of a signed type and unconditionally rewrite to $\\text{SAR}(x,1)$, because signedness alone guarantees equivalence.\n\nC. Match $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SHR}(x,1)$ whenever $x$ is signed, since right shifts always implement division by $2$ regardless of sign.\n\nD. Match $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SAR}(x,2)$ whenever $x$ is signed, since the shift amount should equal the divisor.", "solution": "The user wants me to validate the problem statement and, if it is valid, provide a detailed solution.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The context is instruction selection (IS) in a compiler backend for a tree-structured Intermediate Representation (IR).\n- The IR node is $/(x,2)$, representing integer division of an operand $x$ by the constant $2$.\n- The operand $x$ is a machine integer type.\n- The target architecture has two relevant instructions:\n    - $\\text{SAR}(u,k)$: arithmetic right shift, which sign-extends $u$ and shifts it right by $k$ bits.\n    - $\\text{SHR}(u,k)$: logical right shift, which zero-extends $u$ and shifts it right by $k$ bits.\n- The IR is typed, distinguishing between signed and unsigned integers.\n- The problem provides the following semantic definitions:\n    1.  The architecture uses two's-complement representation.\n    2.  $\\mathrm{SAR}(x,1)$ is equivalent to multiplication by $2^{-1}$ with rounding toward negative infinity (floor) for negative odd $x$.\n    3.  $\\mathrm{SHR}(x,1)$ corresponds to division by $2$ for unsigned integers, which truncates (rounds toward zero).\n    4.  The language or IR semantics for signed integer division may specify rounding toward zero (truncation).\n    5.  Rounding toward zero differs from rounding toward negative infinity for negative odd values of $x$.\n- The task is to identify the correct pattern-matching rule to rewrite a signed division by $2$ (denoted $\\mathrm{sdiv}(x,2)$) into an arithmetic right shift by $1$ ($\\mathrm{SAR}(x,1)$), including any necessary guards to ensure correctness.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of compiler design, computer architecture, and digital arithmetic. The behaviors of shift instructions, two's-complement arithmetic, and different integer division rounding modes are standard and well-documented topics in computer science and engineering. The problem is factually sound.\n- **Well-Posed:** The problem is clearly stated. It provides the semantics of the source operation ($\\mathrm{sdiv}$ with potential round-to-zero semantics) and the target operation ($\\mathrm{SAR}$ with round-to-negative-infinity semantics) and asks for the conditions under which a transformation between them is valid. This structure allows for a unique and logical solution.\n- **Objective:** The language is precise, technical, and free of ambiguity or subjectivity. Terms like \"two's-complement\", \"arithmetic right shift\", \"rounding toward zero\", and \"rounding toward negative infinity\" have rigorous, universally accepted definitions.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. It is a well-formed, technically sound question representative of real-world challenges in compiler optimization. I will proceed to derive the solution.\n\n### Solution Derivation\n\nThe central task is to determine when a signed integer division by $2$, denoted $\\mathrm{sdiv}(x,2)$, can be legally replaced by an arithmetic right shift by $1$, denoted $\\mathrm{SAR}(x,1)$. The problem highlights a crucial difference in semantics: $\\mathrm{sdiv}$ may round toward zero, while $\\mathrm{SAR}$ rounds toward negative infinity.\n\nLet's analyze the behavior of these two operations on a signed integer $x$ in two's complement.\n\nLet $f_{sdiv}(x) = \\mathrm{sdiv}(x,2)$ denote division with rounding toward zero (truncation).\nLet $f_{sar}(x) = \\mathrm{SAR}(x,1)$ denote an arithmetic right shift, which is equivalent to division with rounding toward negative infinity (floor).\n\nWe analyze the equivalence of $f_{sdiv}(x)$ and $f_{sar}(x)$.\n\n**Case 1: $x \\ge 0$ (Non-negative integers)**\nFor any non-negative number $z$, rounding toward zero ($\\mathrm{trunc}(z)$) and rounding toward negative infinity ($\\mathrm{floor}(z)$) produce the same result.\nFor example, $\\mathrm{trunc}(3.5) = 3$ and $\\mathrm{floor}(3.5) = 3$.\nTherefore, for any $x \\ge 0$, we have:\n$\\mathrm{sdiv}(x,2) = \\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = \\mathrm{SAR}(x,1)$\nThe transformation is always valid when $x$ is known to be non-negative.\n\n**Case 2: $x  0$ (Negative integers)**\nFor a negative number $z$, rounding toward zero and rounding toward negative infinity differ if $z$ is not an integer.\nSpecifically, $\\mathrm{trunc}(z) = \\lceil z \\rceil$ for $z0$, while $\\mathrm{floor}(z)$ remains floor.\n- If $x$ is a negative even number, then $x/2$ is an integer. In this case, $\\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = x/2$.\n  For example, if $x = -8$, $\\mathrm{sdiv}(-8,2) = -4$ and $\\mathrm{SAR}(-8,1) = -4$. They are equal.\n- If $x$ is a negative odd number, then $x/2$ is not an integer (e.g., $-3.5$).\n  In this case, $\\mathrm{trunc}(x/2) \\ne \\mathrm{floor}(x/2)$.\n  For example, if $x = -7$, then $x/2 = -3.5$.\n  $\\mathrm{sdiv}(-7,2) = \\mathrm{trunc}(-3.5) = -3$\n  $\\mathrm{SAR}(-7,1) = \\mathrm{floor}(-3.5) = -4$\n  The results are not equal.\n\n**Conclusion of Derivation**\nA direct substitution of $\\mathrm{sdiv}(x,2)$ with $\\mathrm{SAR}(x,1)$ is only correct if the IR semantics for signed division guarantee rounding toward negative infinity, or if it can be proven that the operand $x$ will never be a negative odd number. A sufficient condition for the latter is proving that $x \\ge 0$. If the IR semantics specify rounding toward zero (a common standard in languages like C99/C++/Java), the transformation is illegal for negative odd inputs and cannot be applied unconditionally. A correct pattern-matching rule must incorporate these conditions as guards.\n\n### Option-by-Option Analysis\n\n**A. Match the typed signed-division node $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SAR}(x,1)$, but only under the guard that either the IR’s signed division semantics round toward negative infinity or that a proven range analysis ensures $x \\ge 0$. Otherwise, do not match.**\nThis option proposes a guarded transformation. Let's examine the guards:\n1.  **Guard 1: \"the IR’s signed division semantics round toward negative infinity\"**: If the source operation ($\\mathrm{sdiv}$) and the target instruction ($\\mathrm{SAR}$) have identical rounding semantics, the transformation is by definition correct for all inputs. This is a valid condition.\n2.  **Guard 2: \"a proven range analysis ensures $x \\ge 0$\"**: As derived above, for all non-negative $x$, both rounding modes produce the same result. Thus, if $x$ is proven to be non-negative, the transformation is correct regardless of the IR's rounding-mode semantics for negative numbers. This is also a valid condition.\nThe rule correctly states not to perform the match if neither guard is met. This prevents the generation of incorrect code for negative odd inputs when the division semantics are round-to-zero. This option perfectly captures the necessary conditions for a safe and correct optimization.\n**Verdict: Correct**\n\n**B. Match any occurrence of $/(x,2)$ where $x$ is of a signed type and unconditionally rewrite to $\\text{SAR}(x,1)$, because signedness alone guarantees equivalence.**\nThis option proposes an unconditional rewrite. Our analysis has shown that this is incorrect. The equivalence fails for negative odd integers when the IR division rounds toward zero. The claim that \"signedness alone guarantees equivalence\" is false, as the rounding mode is a critical factor. For example, if $\\mathrm{sdiv}(-3,2)$ is defined as $-1$, $\\mathrm{SAR}(-3,1)$ would compute $-2$.\n**Verdict: Incorrect**\n\n**C. Match $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SHR}(x,1)$ whenever $x$ is signed, since right shifts always implement division by $2$ regardless of sign.**\nThis option proposes using a logical right shift ($\\mathrm{SHR}$) for a signed value. A logical right shift inserts zeros into the most significant bits. For a negative number, whose most significant bit (the sign bit) is $1$, this operation will change the sign and produce a large positive number. For example, for an $8$-bit signed integer $x=-2$ (binary `11111110`), $\\mathrm{SHR}(x,1)$ would yield `01111111`, which is $+127$. The correct result is $-1$. The premise that \"right shifts always implement division by $2$ regardless of sign\" is false; the correct type of shift (logical vs. arithmetic) must be used for the correct type of integer (unsigned vs. signed).\n**Verdict: Incorrect**\n\n**D. Match $\\mathrm{sdiv}(x,2)$ and rewrite to $\\text{SAR}(x,2)$ whenever $x$ is signed, since the shift amount should equal the divisor.**\nThis option uses the correct type of shift ($\\mathrm{SAR}$) but an incorrect shift amount. A right shift by $k$ bits is equivalent to division by $2^k$. Therefore, to implement division by $2$, the shift amount $k$ must be $1$, since $2^1=2$. A shift amount of $2$ ($\\mathrm{SAR}(x,2)$) would implement division by $2^2=4$. The claim that \"the shift amount should equal the divisor\" is fundamentally wrong.\n**Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "3679147"}, {"introduction": "An effective instruction selector must not only produce good code but must also run efficiently. As expression trees grow, the number of potential instruction coverings can become combinatorially large, slowing compilation. This exercise [@problem_id:3679162] shifts focus to the efficiency of the matching algorithm itself, demonstrating how algebraic properties like commutativity can be exploited to prune the search space and make the code generation process practical.", "problem": "In tree-pattern matching for instruction selection within a compiler, the intermediate representation of an expression is treated as an ordered binary tree whose node labels are operators and whose leaf labels are operands. A binary operator is said to be commutative if its evaluation is invariant under exchange of its two operand positions, i.e., for a binary function $f$, commutativity means $f(x,y)=f(y,x)$ for all operands $x$ and $y$. When a matcher enumerates candidate matches, it often considers distinct child orderings separately if it does not exploit commutativity, thereby inflating the search state space.\n\nConsider the three-operand addition $+(a,b,c)$ represented as a fixed left-associated binary tree $T$ with two internal nodes:\n$$T \\equiv +(+(a,b),c).$$\nAssume that the addition operator $+$ is commutative and that the matcher naively explores both left-right orders at each $+$ node independently, treating $(x,y)$ and $(y,x)$ as distinct for any child pair $(x,y)$. Starting from the fundamental definition of commutativity and the fact that the tree $T$ has two binary $+$ nodes, derive from first principles the total number of distinct subtree orderings of $T$ under this naive enumeration. Then, propose a canonicalization strategy that imposes a total order on the two children at every commutative node (for example, by a deterministic key on subtrees) so that symmetric left-right duplicates at commutative nodes are eliminated. Compute the multiplicative reduction factor in the enumeration space size when canonicalization is applied to all commutative nodes in $T$.\n\nYour final answer must be a single real number equal to this reduction factor. No rounding is required.", "solution": "The problem requires an analysis of the combinatorial expansion of tree representations due to a commutative operator and the subsequent reduction achieved by a canonicalization strategy. The context is tree-pattern matching for instruction selection in a compiler.\n\nFirst, we must validate the problem statement.\nThe givens are:\n1.  An expression $+(a,b,c)$ is represented as a fixed left-associated binary tree $T \\equiv +(+(a,b),c)$.\n2.  The binary operator $+$ is commutative, meaning $+(x,y) = +(y,x)$.\n3.  A naive matcher explores both child orderings $(x,y)$ and $(y,x)$ as distinct possibilities at each $+$ node. The choices at different nodes are independent.\n\nThe problem is scientifically grounded in the principles of compiler construction, specifically in the code generation phase. The concepts of intermediate representation (IR) as abstract syntax trees, operator properties like commutativity, and pattern matching are fundamental and well-established in computer science. The problem is well-posed, providing a specific tree structure and a clear set of rules for enumeration, leading to a unique, derivable solution. The language is objective and formal. Therefore, the problem is deemed valid.\n\nWe proceed with the solution, deriving the results from first principles as requested.\n\nLet the given tree be $T$. We can visualize its structure. Let $n_{root}$ be the root node and $n_{inner}$ be its left child, which is also an internal node.\n- The root node $n_{root}$ is an operator $+$. Its children are the subtree rooted at $n_{inner}$ and the leaf operand $c$.\n- The internal node $n_{inner}$ is also an operator $+$. Its children are the leaf operands $a$ and $b$.\n\nThe tree structure is $T = n_{root}(n_{inner}(a,b), c)$.\n\n**Part 1: Deriving the total number of naive orderings**\n\nThe problem states that the matcher naively explores both left-right orders at each $+$ node independently. Since the operator $+$ is commutative, at any node $n$ with operator $+$ and children $(L, R)$, the matcher will consider both permutations: $(L, R)$ and $(R, L)$.\n\nOur tree $T$ has two nodes with the commutative operator $+$: $n_{root}$ and $n_{inner}$.\n\n1.  **Analysis of the inner node, $n_{inner}$:** This node has the form $+(a,b)$. Its children are the operands $a$ and $b$. Due to commutativity, the matcher enumerates two distinct orderings for these children:\n    - $(a,b)$, forming the subtree $+(a,b)$.\n    - $(b,a)$, forming the subtree $+(b,a)$.\n    The number of permutations for the children of $n_{inner}$ is $2! = 2$.\n\n2.  **Analysis of the root node, $n_{root}$:** This node has the form $+(S, c)$, where $S$ is the subtree rooted at $n_{inner}$. The children of $n_{root}$ are the subtree $S$ and the operand $c$. Due to commutativity, the matcher enumerates two distinct orderings for these children:\n    - $(S, c)$, forming the tree $+(S, c)$.\n    - $(c, S)$, forming the tree $+(c, S)$.\n    The number of permutations for the children of $n_{root}$ is $2! = 2$.\n\nSince the enumeration choices at each node are independent, the total number of distinct subtree orderings, $N_{naive}$, is the product of the number of choices at each commutative node.\n$$N_{naive} = (\\text{choices at } n_{inner}) \\times (\\text{choices at } n_{root})$$\n$$N_{naive} = 2 \\times 2 = 4$$\n\nTo be exhaustive, the four distinct ordered trees enumerated by the naive matcher are:\n1.  $+(+(a,b), c)$\n2.  $+(+(b,a), c)$\n3.  $+(c, +(a,b))$\n4.  $+(c, +(b,a))$\n\nThus, the size of the enumeration space for the naive matcher is $4$.\n\n**Part 2: Canonicalization Strategy**\n\nA canonicalization strategy is designed to eliminate redundant representations that are semantically equivalent. For a commutative operator, all permutations of its operands result in the same value. The goal is to select exactly one of these permutations as the canonical form.\n\nA general and effective strategy is to impose a total order on the set of all possible subtrees. Let this ordering be defined by a key function, $key(S)$, which assigns a unique, deterministic value to any subtree $S$. For example, this key could be derived from the memory addresses of the nodes, a hash of the subtree structure, or a lexicographical ordering of the string representation of the subtree.\n\nThe canonicalization rule for any commutative node with children $(L, R)$ is to reorder them to $(L', R')$ such that $key(L') \\leq key(R')$. By applying this rule at every commutative node, any set of permutable children will be arranged into a single, unique sequence.\n\nThis strategy collapses the $2! = 2$ possible orderings at each binary commutative node into a single canonical ordering.\n\n**Part 3: Computing the Multiplicative Reduction Factor**\n\nWe now compute the size of the enumeration space after the canonicalization strategy is applied to the tree $T$.\n\n1.  **At the inner node, $n_{inner}$:** The children are $a$ and $b$. The canonicalization rule selects exactly one ordering. For example, if $key(a) \\leq key(b)$, the only valid form is $+(a,b)$. The form $+(b,a)$ is disallowed and would be transformed into $+(a,b)$. The number of choices is reduced from $2$ to $1$.\n\n2.  **At the root node, $n_{root}$:** The children are the subtree $S=n_{inner}(\\ldots)$ and the operand $c$. The canonicalization rule selects exactly one ordering based on the comparison of $key(S)$ and $key(c)$. The number of choices is reduced from $2$ to $1$.\n\nThe total number of distinct orderings in the canonicalized enumeration, $N_{canon}$, is the product of the number of choices at each node:\n$$N_{canon} = 1 \\times 1 = 1$$\n\nThe multiplicative reduction factor, $F$, is the ratio of the size of the original enumeration space to the size of the canonicalized space. This factor quantifies how many times larger the naive search space is compared to the optimized one.\n$$F = \\frac{N_{naive}}{N_{canon}}$$\n$$F = \\frac{4}{1} = 4$$\n\nThe application of a canonicalization strategy at all commutative nodes reduces the number of tree configurations to be considered from $4$ to $1$, yielding a multiplicative reduction factor of $4$.", "answer": "$$\\boxed{4}$$", "id": "3679162"}]}