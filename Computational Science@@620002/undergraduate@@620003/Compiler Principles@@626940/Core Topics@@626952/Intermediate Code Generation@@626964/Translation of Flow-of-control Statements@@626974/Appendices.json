{"hands_on_practices": [{"introduction": "Before we can generate correct control flow, we must first be able to recognize it. This practice reverses the typical compilation process, challenging you to analyze a piece of unstructured, `goto`-based code and reconstruct its equivalent structured form. By building and comparing the Control-Flow Graphs (CFGs), you will gain a deeper intuition for the equivalence between different code representations and learn to quantify complexity using standard metrics [@problem_id:3677965].", "problem": "Consider the following goto-based program that uses integer variables $i$, $n$, $s$, $t$, and $r$. The initial conditions are $s \\leftarrow 0$ and $n \\ge 0$ is a given input. Labels are denoted $L_{k}$ for integers $k$ and control transfers use conditional or unconditional jumps.\n\n$L_{0}$: $i \\leftarrow 0$; $s \\leftarrow 0$; goto $L_{1}$\n\n$L_{1}$: if $i \\ge n$ goto $L_{7}$ else goto $L_{2}$\n\n$L_{2}$: $t \\leftarrow i \\times i$; if $(t \\bmod 3) = 0$ goto $L_{5}$ else goto $L_{4}$\n\n$L_{4}$: $s \\leftarrow s + t$; goto $L_{6}$\n\n$L_{5}$: $s \\leftarrow s - i$; goto $L_{6}$\n\n$L_{6}$: $i \\leftarrow i + 1$; goto $L_{1}$\n\n$L_{7}$: if $s  0$ goto $L_{9}$ else goto $L_{8}$\n\n$L_{8}$: $r \\leftarrow s$; goto $L_{10}$\n\n$L_{9}$: $r \\leftarrow -s$; goto $L_{10}$\n\n$L_{10}$: halt\n\nStarting from the foundational principles of translating flow-of-control statements in compiler design, namely the translation of structured constructs into Intermediate Representation (IR) with labels, conditional jumps, and basic blocks, perform the following:\n\n1. Reconstruct this program into structured constructs using a loop and conditionals that are semantically equivalent to the given goto-based version, without changing the observable behavior computed for $r$.\n2. Re-lower the structured version back into a canonical three-address code Intermediate Representation (IR) using standard translation schemes for $if$-statements and $while$-loops, introducing labels and conditional/unconditional jumps to delineate basic blocks.\n3. Build the Control-Flow Graph (CFG) of the re-lowered IR, identifying its basic blocks and directed edges among them, and justify that the CFG is isomorphic to that of the original goto-based program (thus establishing equivalence of the IRs).\n4. Compute the cyclomatic complexity of the re-lowered IR’s CFG as a single real-valued number. Express the final cyclomatic complexity value as your answer. No rounding is required.\n\nYour final answer must be the cyclomatic complexity value of the re-lowered IR’s CFG.", "solution": "The problem statement is valid. It presents a well-defined task within the domain of compiler principles, providing a self-contained, logically consistent, and unambiguous goto-based program for control-flow analysis. The problem is scientifically grounded in established computer science theory and can be solved through formal, objective methods. We will proceed with the four required tasks.\n\n### 1. Reconstruction into Structured Constructs\n\nThe provided goto-based program can be analyzed to reveal its underlying structured logic.\n\n- The statements at label $L_{0}$ (`i - 0; s - 0;`) are initialization steps executed once before any looping.\n- The block starting at $L_{1}$ and ending with the jump back to $L_{1}$ from $L_{6}$ forms a loop. The entry condition at $L_{1}$ is `if i = n goto L_exit`, which is equivalent to a `while (i  n)` loop.\n- Inside this loop (labels $L_{2}$ through $L_{6}$), the program calculates `t - i * i`. Based on the condition `(t mod 3) = 0`, it follows one of two paths:\n    - If `(t mod 3) = 0` is false, it proceeds to $L_{4}$ and executes `s - s + t`.\n    - If `(t mod 3) = 0` is true, it proceeds to $L_{5}$ and executes `s - s - i`.\n    - Both paths converge at $L_{6}$, where the loop counter `i` is incremented (`i - i + 1`), and control returns to the loop condition at $L_{1}$. This structure is an `if-else` statement nested within the loop.\n- After the loop terminates (when $i \\ge n$), control transfers to $L_{7}$. The statements at labels $L_{7}$, $L_{8}$, and $L_{9}$ compute the absolute value of $s$ and store it in $r$. Specifically, `if s  0` then `r - -s`, else `r - s`.\n- Finally, the program halts at $L_{10}$.\n\nBased on this analysis, the semantically equivalent structured program is:\n```c\ns = 0;\ni = 0;\nwhile (i  n) {\n    t = i * i;\n    if ((t % 3) == 0) {\n        s = s - i;\n    } else {\n        s = s + t;\n    }\n    i = i + 1;\n}\nif (s  0) {\n    r = -s;\n} else {\n    r = s;\n}\nhalt;\n```\nNote that the initialization `s - 0` is explicitly given in the problem and also appears at $L_0$. The effect is the same.\n\n### 2. Re-lowering to Three-Address Code IR\n\nUsing standard translation schemes for structured control-flow statements, we can lower the above program into a three-address code Intermediate Representation (IR). This process involves creating basic blocks delineated by labels and jumps.\n\n- **Block $B'_{0}$ (Initialization):**\n  `i - 0`\n  `s - 0`\n  `goto B'_{1}`\n\n- **Block $B'_{1}$ (Loop Header):**\n  `if $i \\ge n$ goto B'_{6}`\n  `else goto B'_{2}`\n\n- **Block $B'_{2}$ (Loop Body, Conditional):**\n  `t - i * i`\n  `tmp - t mod 3`\n  `if tmp = 0 goto B'_{4}`\n  `else goto B'_{3}`\n\n- **Block $B'_{3}$ (Inner `else` branch):**\n  `s - s + t`\n  `goto B'_{5}`\n\n- **Block $B'_{4}$ (Inner `then` branch):**\n  `s - s - i`\n  `goto B'_{5}`\n\n- **Block $B'_{5}$ (Loop Increment):**\n  `i - i + 1`\n  `goto B'_{1}`\n\n- **Block $B'_{6}$ (Post-Loop, Absolute Value):**\n  `if $s  0$ goto B'_{8}`\n  `else goto B'_{7}`\n\n- **Block $B'_{7}$ (Absolute Value `else` branch):**\n  `r - s`\n  `goto B'_{9}`\n\n- **Block $B'_{8}$ (Absolute Value `then` branch):**\n  `r - -s`\n  `goto B'_{9}`\n\n- **Block $B'_{9}$ (Halt):**\n  `halt`\n\nThis IR consists of $10$ basic blocks, labeled $B'_{0}$ through $B'_{9}$.\n\n### 3. Control-Flow Graph (CFG) Construction and Isomorphism\n\nFirst, we identify the basic blocks of the **original** goto-based program. A basic block starts at a label that is a target of a jump or at the beginning of the program, and it ends with a jump or just before another leader instruction. The leaders in the original code are the instructions at labels $L_{0}, L_{1}, L_{2}, L_{4}, L_{5}, L_{6}, L_{7}, L_{8}, L_{9}, L_{10}$. This gives $10$ basic blocks, which we denote $B_{k}$ for the block starting at label $L_{k}$ (with $B_0, B_1, B_2, B_4, B_5, B_6, B_7, B_8, B_9, B_{10}$).\n\nThe Control-Flow Graph $G = (V, E)$ for the original program has a set of vertices $V = \\{B_{0}, B_{1}, B_{2}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}, B_{10}\\}$ ($|V| = N = 10$) and a set of directed edges $E$ determined by the jumps:\n- $E = \\{ (B_{0}, B_{1}), (B_{1}, B_{2}), (B_{1}, B_{7}), (B_{2}, B_{4}), (B_{2}, B_{5}), (B_{4}, B_{6}), (B_{5}, B_{6}), (B_{6}, B_{1}), (B_{7}, B_{8}), (B_{7}, B_{9}), (B_{8}, B_{10}), (B_{9}, B_{10}) \\}$\nThe number of edges is $|E| = 12$.\n\nThe CFG $G' = (V', E')$ for the **re-lowered IR** has a set of vertices $V' = \\{B'_{0}, B'_{1}, B'_{2}, B'_{3}, B'_{4}, B'_{5}, B'_{6}, B'_{7}, B'_{8}, B'_{9}\\}$ ($|V'| = N = 10$) and a set of directed edges $E'$:\n- $E' = \\{ (B'_{0}, B'_{1}), (B'_{1}, B'_{2}), (B'_{1}, B'_{6}), (B'_{2}, B'_{3}), (B'_{2}, B'_{4}), (B'_{3}, B'_{5}), (B'_{4}, B'_{5}), (B'_{5}, B'_{1}), (B'_{6}, B'_{7}), (B'_{6}, B'_{8}), (B'_{7}, B'_{9}), (B'_{8}, B'_{9}) \\}$\nThe number of edges is $|E'| = 12$.\n\nTo justify that $G$ and $G'$ are isomorphic, we must demonstrate a bijection $f: V \\to V'$ that preserves adjacency. Let's define the mapping based on the functional role of each block:\n- $f(B_{0}) = B'_{0}$ (Initialization)\n- $f(B_{1}) = B'_{1}$ (Loop header)\n- $f(B_{2}) = B'_{2}$ (Loop body pre-conditional)\n- $f(B_{4}) = B'_{3}$ (The `else` path of the inner `if`)\n- $f(B_{5}) = B'_{4}$ (The `then` path of the inner `if`)\n- $f(B_{6}) = B'_{5}$ (Loop increment and continue)\n- $f(B_{7}) = B'_{6}$ (Post-loop conditional)\n- $f(B_{8}) = B'_{7}$ (The `else` path of the outer `if`)\n- $f(B_{9}) = B'_{8}$ (The `then` path of the outer `if`)\n- $f(B_{10}) = B'_{9}$ (Halt/Exit)\n\nThis function $f$ is a bijection between $V$ and $V'$. We check that for any edge $(u, v) \\in E$, the edge $(f(u), f(v)) \\in E'$. For example, $(B_{6}, B_{1}) \\in E$, and the corresponding edge in $G'$ is $(f(B_{6}), f(B_{1})) = (B'_{5}, B'_{1})$, which is in $E'$. Similarly, $(B_{2}, B_{4}) \\in E$ corresponds to $(f(B_{2}), f(B_{4})) = (B'_{2}, B'_{3}) \\in E'$. A full check confirms that all $12$ edges are preserved under this mapping. Therefore, the CFG of the re-lowered IR is isomorphic to the CFG of the original program.\n\n### 4. Cyclomatic Complexity Calculation\n\nThe cyclomatic complexity $M$ of a control-flow graph can be computed using several equivalent formulas. We will use the formula based on the number of nodes, edges, and connected components of the graph. For a CFG with a single entry and single exit point, there is $P=1$ connected component. The formula is:\n$$M = E - N + 2P$$\nUsing the CFG for the re-lowered IR (which is isomorphic to the original), we have:\n- Number of nodes (basic blocks) $N = 10$.\n- Number of edges (control transfers) $E = 12$.\n- Number of connected components $P = 1$.\n\nSubstituting these values into the formula:\n$$M = 12 - 10 + 2(1) = 2 + 2 = 4$$\n\nAlternatively, we can use the formula $M = D + 1$, where $D$ is the number of decision nodes (nodes with an out-degree of $2$).\nThe decision nodes in the graph are:\n1.  $B'_{1}$ (or $B_{1}$): `if i = n`\n2.  $B'_{2}$ (or $B_{2}$): `if tmp = 0`\n3.  $B'_{6}$ (or $B_{7}$): `if s  0`\nThere are $D=3$ decision nodes. Thus, the complexity is:\n$$M = 3 + 1 = 4$$\n\nBoth methods yield the same result. The cyclomatic complexity of the CFG is $4$.", "answer": "$$\\boxed{4}$$", "id": "3677965"}, {"introduction": "Moving from analysis to synthesis, this exercise delves into the concrete mechanics of generating code for a `do-while` loop. You will calculate the precise displacement for a program counter ($PC$) relative jump, a task that requires understanding memory layout, instruction addressing, and the core backpatching technique. This practice provides a low-level perspective on how compilers resolve forward references to create functional loops [@problem_id:3677994].", "problem": "Consider a compiler that translates a high-level do-while loop into three-address code using classical backpatching for boolean expressions with short-circuit evaluation. The target machine uses program counter (PC) relative conditional branches: a conditional branch at instruction address $i$ encodes an integer displacement $\\delta$ such that control transfers to target address $T$ if and only if $T = (i + 1) + \\delta$, where addresses count instructions and labels do not occupy instruction slots.\n\nThe translation scheme for a statement of the form do $S$ while $(B)$ is based on these core definitions:\n- The semantics of do-while: the body $S$ executes at least once before the boolean expression $B$ is evaluated; if $B$ evaluates to true, control repeats the loop; otherwise, it exits the loop.\n- Backpatching for boolean expressions: translating $B$ yields a code sequence and two lists $B.true$ and $B.false$ of instruction addresses for conditional and unconditional jumps whose targets are not yet known. Backpatching $B.true$ assigns the loop-head target so that true continues the loop, and backpatching $B.false$ assigns the loop-exit target so that false leaves the loop.\n\nAssume the following concrete layout constraints for a particular do-while loop:\n- The first instruction of the loop (the loop head) is at address $pc_{0} = 1000$.\n- Translating the body $S$ produces exactly $\\ell_{S} = 73$ instructions.\n- Translating the boolean expression $B$ produces exactly $\\ell_{B} = 9$ instructions, with its final instruction at address $pc_{end}$ being the single conditional branch whose true-target is to be backpatched to the loop head. All labels occupy no instruction slots, and no additional instructions are introduced during backpatching.\n\nUnder these conditions, after placing the $B$-code immediately following the body $S$, the compiler backpatches $B.true$ to the loop head at $pc_{0}$. Using only the above fundamentals and definitions, determine the signed PC-relative displacement $\\delta$ that must be encoded in the conditional branch at $pc_{end}$ to jump back to the loop head when $B$ evaluates to true. Provide your final answer as an integer. No rounding is required.", "solution": "The problem statement has been validated and is deemed sound, self-contained, and well-posed. It presents a standard scenario in compiler construction concerning the translation of control-flow statements into machine-level instructions with program counter (PC) relative addressing. All necessary parameters are provided, and the objective is clearly defined.\n\nThe goal is to determine the signed PC-relative displacement, denoted by $\\delta$, for a conditional branch instruction. The relationship between the target address $T$, the address of the branch instruction $i$, and the displacement $\\delta$ is given by the formula:\n$$T = (i + 1) + \\delta$$\nThis formula models a common architecture where the PC is advanced to the next instruction address before the displacement is applied. To find $\\delta$, we can rearrange this equation:\n$$\\delta = T - (i + 1)$$\n\nWe must determine the values of the target address $T$ and the branch instruction address $i$ from the problem's specifications.\n\n1.  **Determining the Target Address $T$**:\n    The problem describes the translation of a `do S while (B)` loop. In such a loop, if the condition $B$ is true, control jumps back to the beginning of the loop to re-execute the body $S$. The problem states that the true-target of the conditional branch is backpatched to the loop head. The address of the loop head, which is the first instruction of the statement $S$, is given as $pc_{0}$.\n    Therefore, the target address $T$ is:\n    $$T = pc_{0} = 1000$$\n\n2.  **Determining the Branch Instruction Address $i$**:\n    The conditional branch is specified as the final instruction of the code generated for the boolean expression $B$. To find its address, we must determine the layout of the generated code in memory.\n    The structure of the generated code for `do S while (B)` is the code for $S$ followed immediately by the code for $B$.\n    - The first instruction of the loop, which is the start of the code for the body $S$, is at address $pc_{0} = 1000$.\n    - The code for $S$ consists of $\\ell_{S} = 73$ instructions. These instructions occupy the address range from $pc_{0}$ to $pc_{0} + \\ell_{S} - 1$.\n      Numerically, this is from address $1000$ to $1000 + 73 - 1 = 1072$.\n    - The code for the boolean expression $B$ immediately follows the code for $S$. Thus, its first instruction is at address $(pc_{0} + \\ell_{S} - 1) + 1 = pc_{0} + \\ell_{S}$.\n      Numerically, this is address $1073$.\n    - The code for $B$ consists of $\\ell_{B} = 9$ instructions. The final instruction of this block is the conditional branch instruction whose address we seek. Its address, $i$, which the problem denotes as $pc_{end}$, is the last address in the sequence.\n    This address can be calculated as the starting address of the $B$-block plus the number of instructions in it, minus one.\n    $$i = pc_{end} = (pc_{0} + \\ell_{S}) + \\ell_{B} - 1$$\n    Substituting the given values:\n    $$i = 1000 + 73 + 9 - 1 = 1000 + 82 - 1 = 1081$$\n    So, the conditional branch instruction is located at address $i = 1081$.\n\n3.  **Calculating the Displacement $\\delta$**:\n    Now we substitute the determined values of $T$ and $i$ into the rearranged formula for $\\delta$:\n    $$\\delta = T - (i + 1)$$\n    $$\\delta = 1000 - (1081 + 1)$$\n    $$\\delta = 1000 - 1082$$\n    $$\\delta = -82$$\n\nThe displacement is negative, which is expected for a jump that returns control to an earlier point in the program (the loop head). The magnitude of the jump, $82$, corresponds to the total number of instructions in the loop body ($S$) and the conditional check ($B$), which is $\\ell_S + \\ell_B = 73 + 9 = 82$. The jump from the instruction at address $i = 1081$ must land at $T = 1000$. The PC is first incremented to $1082$, and then the displacement $\\delta = -82$ is added, resulting in the correct target address $1082 + (-82) = 1000$.", "answer": "$$\\boxed{-82}$$", "id": "3677994"}, {"introduction": "This final practice integrates several advanced topics to address a realistic compilation scenario: translating a short-circuit logical expression. Preserving the exact semantics—including avoiding the evaluation of unnecessary operands and correctly propagating exceptions—is critical. By generating the appropriate three-address code and analyzing its expected performance under a probabilistic model, you will see how compiler design choices directly impact both program correctness and efficiency [@problem_id:3678000].", "problem": "Consider a compiler back-end that translates high-level Boolean expressions with short-circuit semantics into a low-level Intermediate Representation (IR). The IR is formed from Three-Address Code (TAC), where control is realized through conditional and unconditional jumps. The semantics of the logical disjunction are as follows: to evaluate $E_1 \\lor E_2$, the program must evaluate $E_1$ first; if $E_1$ evaluates to $\\text{true}$, then the result is $\\text{true}$ and $E_2$ must not be evaluated; if $E_1$ evaluates to $\\text{false}$, then $E_2$ is evaluated and the result is the value of $E_2$. If either $E_1$ or $E_2$ throws an exception during evaluation, the exception must be propagated immediately and $E_2$ must not be evaluated if $E_1$ throws. Your translation must preserve these short-circuit and exception semantics.\n\nThe IR primitives are:\n- Evaluation of an expression $E_i$ into a temporary $t$ as a single IR operation, which either produces a Boolean value or throws an exception. This operation has an explicit exception edge to a handler label $L_{\\mathrm{exc}}$.\n- A conditional branch of the form $\\text{if } t \\text{ goto } L$, with cost $c_{\\mathrm{if}}$.\n- An unconditional branch of the form $\\text{goto } L$, with cost $c_{\\mathrm{goto}}$.\n\nAssume the following cost model and probabilistic behavior:\n- When evaluating $E_1$:\n  - With probability $\\theta_1$, it throws an exception after executing exactly $b_1$ primitive IR instructions, followed by an exception dispatch cost $c_{\\mathrm{exc}}$.\n  - With probability $1 - \\theta_1$, it returns normally after executing exactly $a_1$ primitive IR instructions. Conditional on normal return, the Boolean result is $\\text{true}$ with probability $\\tau_1$ and $\\text{false}$ with probability $1 - \\tau_1$.\n- When evaluating $E_2$ (which occurs only if $E_1$ returns $\\text{false}$ normally):\n  - With probability $\\theta_2$, it throws an exception after executing exactly $b_2$ primitive IR instructions, followed by an exception dispatch cost $c_{\\mathrm{exc}}$.\n  - With probability $1 - \\theta_2$, it returns normally after executing exactly $a_2$ primitive IR instructions. Conditional on normal return, the Boolean result is $\\text{true}$ with probability $\\tau_2$ and $\\text{false}$ with probability $1 - \\tau_2$.\n\nTask:\n1. Starting from the fundamental definition of short-circuit semantics for $E_1 \\lor E_2$ and the role of flow-of-control translation via jumps in the IR, emit TAC that correctly implements short-circuiting and preserves exception behavior as specified. Your TAC must not evaluate $E_2$ when $E_1$ is $\\text{true}$ or throws.\n2. Using the emitted TAC and the given cost and probability model, derive the expected number of primitive IR instructions executed for a single evaluation of $E_1 \\lor E_2$ as a closed-form analytic expression in terms of $\\theta_1$, $\\tau_1$, $\\theta_2$, $\\tau_2$, $a_1$, $b_1$, $a_2$, $b_2$, $c_{\\mathrm{if}}$, $c_{\\mathrm{goto}}$, and $c_{\\mathrm{exc}}$.\n\nProvide your final answer as a single closed-form expression. No rounding is required. Do not include any units in your final answer.", "solution": "The problem is scientifically sound, self-contained, and formalizable. It poses a standard problem in compiler code generation: creating and analyzing the cost of an intermediate representation for a short-circuiting logical expression under a probabilistic model. We proceed with the two tasks.\n\n### 1. Three-Address Code (TAC) Generation\n\nTo implement the short-circuit semantics of $E_1 \\lor E_2$, we must evaluate $E_1$ first. If its result is true, we bypass the evaluation of $E_2$. If $E_1$ is false, we then proceed to evaluate $E_2$. Exception propagation must occur immediately at the point an exception is thrown. The following Three-Address Code (TAC) uses conditional jumps to correctly route the flow of control to labels $L_{\\mathrm{true}}$ or $L_{\\mathrm{false}}$ based on the expression's outcome.\n\n```\n// TAC for control flow of (E1 || E2)\n// On exception, control transfers to L_exc.\n\n   t1 = evaluate E1 (exception to L_exc)\n   if t1 goto L_true       // Short-circuit: if E1 is true, we are done.\n\n// Fall-through case: E1 was false, so evaluate E2.\n   t2 = evaluate E2 (exception to L_exc)\n   if t2 goto L_true       // If E2 is true, the overall result is true.\n\n// Fall-through case: E1 and E2 were both false.\n   goto L_false\n```\nThis sequence correctly implements the required semantics. $E_2$ is only evaluated if the first conditional branch is not taken, which occurs only when $E_1$ returns normally with a value of false. Exceptions from either evaluation immediately transfer control to $L_{\\mathrm{exc}}$.\n\n### 2. Expected Cost Derivation\n\nLet $C$ be the random variable representing the total cost (number of primitive IR instructions executed). We will derive the expected cost $E[C]$ using the law of total expectation, conditioning on the outcomes of evaluating $E_1$ and $E_2$.\n\nThe total expected cost can be seen as the cost of the $E_1$ path plus the conditional expected cost of the $E_2$ path.\n$$E[C] = E[\\text{Cost conditioned on } E_1 \\text{ outcome}] + P(\\text{Evaluate } E_2) \\times E[\\text{Cost of } E_2 \\text{ part}]$$\n\nLet's break this down using a nested conditional expectation argument.\nThe top-level expectation is conditioned on the outcome of $E_1$:\n$$E[C] = E[C | E_1 \\text{ throws}]P(E_1 \\text{ throws}) + E[C | E_1 \\text{ normal}]P(E_1 \\text{ normal})$$\n- If $E_1$ throws an exception (with probability $\\theta_1$), the cost is the evaluation cost $b_1$ plus the exception dispatch cost $c_{\\mathrm{exc}}$.\n- If $E_1$ returns normally (with probability $1-\\theta_1$), we proceed to the next step.\nSo, we have:\n$$E[C] = (b_1 + c_{\\mathrm{exc}})\\theta_1 + E[C | E_1 \\text{ normal}](1-\\theta_1)$$\n\nNow we compute $E[C | E_1 \\text{ normal}]$. If $E_1$ returns normally, we incur its evaluation cost $a_1$ and the cost of the first conditional branch, $c_{\\mathrm{if}}$. After this branch, control either terminates (if $E_1$ was true) or continues to the $E_2$ evaluation (if $E_1$ was false).\n$$E[C | E_1 \\text{ normal}] = a_1 + c_{\\mathrm{if}} + E[\\text{Cost after first branch} | E_1 \\text{ normal}]$$\nThe cost after the first branch is non-zero only if $E_1$ was false (with conditional probability $1-\\tau_1$).\n$$E[C | E_1 \\text{ normal}] = a_1 + c_{\\mathrm{if}} + (1-\\tau_1) \\times E[\\text{Cost of } E_2 \\text{ evaluation part}]$$\n\nLet $C_{E2}$ be the cost of the $E_2$ evaluation part. We can find its expectation similarly:\n$$E[C_{E2}] = E[C_{E2} | E_2 \\text{ throws}]P(E_2 \\text{ throws}) + E[C_{E2} | E_2 \\text{ normal}]P(E_2 \\text{ normal})$$\n- If $E_2$ throws (probability $\\theta_2$), the cost is $b_2 + c_{\\mathrm{exc}}$.\n- If $E_2$ returns normally (probability $1-\\theta_2$), the cost is $a_2$ plus the second `if` cost $c_{\\mathrm{if}}$, plus any further cost. The further cost is a `goto` with cost $c_{\\mathrm{goto}}$, but only if $E_2$ is false (conditional probability $1-\\tau_2$).\n$$E[C_{E2}] = (b_2 + c_{\\mathrm{exc}})\\theta_2 + (a_2 + c_{\\mathrm{if}} + (1-\\tau_2)c_{\\mathrm{goto}})(1-\\theta_2)$$\n\nSubstituting this back into the expression for $E[C | E_1 \\text{ normal}]$:\n$$E[C | E_1 \\text{ normal}] = a_1 + c_{\\mathrm{if}} + (1-\\tau_1)\\left( (b_2 + c_{\\mathrm{exc}})\\theta_2 + (a_2 + c_{\\mathrm{if}} + (1-\\tau_2)c_{\\mathrm{goto}})(1-\\theta_2) \\right)$$\n\nFinally, substituting this into the top-level expression for $E[C]$ gives the complete formula:\n$$E[C] = (b_1 + c_{\\mathrm{exc}})\\theta_1 + (1-\\theta_1)\\left( a_1 + c_{\\mathrm{if}} + (1-\\tau_1)\\left( (b_2 + c_{\\mathrm{exc}})\\theta_2 + (a_2 + c_{\\mathrm{if}} + (1-\\tau_2)c_{\\mathrm{goto}})(1-\\theta_2) \\right) \\right)$$\nThis is the closed-form analytic expression for the expected number of instructions.", "answer": "$$\n\\boxed{\\theta_1(b_1+c_{\\mathrm{exc}}) + (1-\\theta_1)\\left(a_1+c_{\\mathrm{if}}+(1-\\tau_1)\\left(\\theta_2(b_2+c_{\\mathrm{exc}}) + (1-\\theta_2)\\left(a_2+c_{\\mathrm{if}}+(1-\\tau_2)c_{\\mathrm{goto}}\\right)\\right)\\right)}\n$$", "id": "3678000"}]}