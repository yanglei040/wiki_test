{"hands_on_practices": [{"introduction": "This first exercise focuses on the fundamental operations of backpatching. We will explore how the logical negation operator, $\\lnot$, can be elegantly handled by swapping attribute lists without generating any new code. By tracing the compilation of the expression $\\lnot(p \\lor q)$, you will see how the short-circuit logic of the $\\lor$ operator is implemented through an intermediate `backpatch` step, a core mechanic that distinguishes backpatching from older multi-pass techniques [@problem_id:3623208].", "problem": "Consider a compiler that implements control-flow based code generation for boolean expressions using backpatching within a Syntax-Directed Translation (SDT) scheme, producing Three-Address Code (TAC). For any atomic predicate $r$ (such as $p$ or $q$) the code emitter follows this invariant: it emits the two-instruction pattern \"if $r$ goto ___; goto ___\" for the test $r$, thereby producing two unresolved jump targets. The attribute $r.truelist$ is the list containing the single instruction index that will jump if $r$ evaluates to true, and $r.falselist$ is the single instruction index that will jump if $r$ evaluates to false. Lists are sets of unresolved jump instructions whose target labels are to be supplied later by backpatching.\n\nThe expression under compilation is $B = \\lnot(p \\lor q)$, evaluated with short-circuit semantics. The code for $q$ is placed immediately after the code for $p$, and the compiler uses backpatching to route control such that the second operand of the disjunction $p \\lor q$ is only evaluated when the first operand is false; in particular, any jumps corresponding to the falsity of the left operand must transfer control to the start of the right operandâ€™s code.\n\nThe logical negation $\\lnot$ does not emit any code; instead, it is implemented purely at the attribute level by swapping $B.truelist$ and $B.falselist$ of its operand.\n\nAfter generating the code and attributes for $B = \\lnot(p \\lor q)$ using the rules above, the compiler performs a final backpatch step to install the target labels $L_{T}$ and $L_{F}$ for the overall context \"if $B$ then goto $L_{T}$ else goto $L_{F}$\", by patching every index in $B.truelist$ to $L_{T}$ and every index in $B.falselist$ to $L_{F}$.\n\nAssuming the atomic tests $p$ and $q$ each initially contribute exactly one index to their $r.truelist$ and one index to their $r.falselist$ (as per the two-instruction pattern above), determine the total number of distinct instruction targets that are patched in this final step for $B = \\lnot(p \\lor q)$. Provide your answer as a single integer. No rounding is required, and no units are involved.", "solution": "The problem statement poses a well-defined question within the standard theory of compiler design, specifically concerning the backpatching technique for generating three-address code for boolean expressions. All provided rules and definitions are consistent with established principles, and the problem is self-contained and free of scientific or logical flaws. Therefore, the problem is valid, and a solution can be derived by systematically applying the given rules.\n\nThe task is to determine the total number of distinct instruction targets that are patched in the final step of compiling the expression $B = \\lnot(p \\lor q)$. The \"instruction targets that are patched\" are the instructions whose jump addresses are left unresolved until this final step. These instructions are identified by their indices, which are collected in the lists $B.truelist$ and $B.falselist$. Therefore, the problem asks for the size of the set $B.truelist \\cup B.falselist$. Since these lists are disjoint by construction, this is equivalent to $|B.truelist| + |B.falselist|$.\n\nWe will trace the generation of code and the manipulation of attribute lists step-by-step. Let us assume the code generation begins at a starting address, which we can denote as $100$ for concreteness, without loss of generality.\n\n**Step 1: Code Generation for Atomic Predicate $p$**\n\nAs per the problem statement, for any atomic predicate $r$, the compiler emits two instructions: `if r goto ___` and `goto ___`. Let's apply this to $p$.\nThe code for $p$ is generated starting at address $100$:\n- Instruction at address $100$: `if p goto ___`\n- Instruction at address $101$: `goto ___`\n\nThe attributes $p.truelist$ and $p.falselist$ are lists of the indices of these unresolved jump instructions.\n- The conditional jump at $100$ is taken if $p$ is true. Thus, $p.truelist = \\{100\\}$.\n- The unconditional jump at $101$ is taken if $p$ is false (i.e., the conditional jump is not taken). Thus, $p.falselist = \\{101\\}$.\n\nThe next available instruction address is now $102$.\n\n**Step 2: Code Generation for Atomic Predicate $q$**\n\nThe problem states that the code for $q$ is placed immediately after the code for $p$. Therefore, code generation for $q$ starts at address $102$.\nThe code for $q$ is:\n- Instruction at address $102$: `if q goto ___`\n- Instruction at address $103$: `goto ___`\n\nSimilarly, the attribute lists for $q$ are:\n- $q.truelist = \\{102\\}$\n- $q.falselist = \\{103\\}$\n\nThe next available instruction address is now $104$.\n\n**Step 3: Attribute Synthesis for the Disjunction $E = p \\lor q$**\n\nWe now consider the subexpression $E = p \\lor q$, which is evaluated with short-circuit semantics. The rule for short-circuiting a disjunction is that the right-hand operand ($q$) is evaluated only if the left-hand operand ($p$) is false. This is implemented by routing the false-path jumps of $p$ to the beginning of $q$'s code.\n\n- The set of jumps for the false case of $p$ is $p.falselist = \\{101\\}$.\n- The start of $q$'s code is at address $102$.\n- The compiler performs `backpatch(p.falselist, 102)`. This action resolves the jump at instruction $101$, setting its target to $102$. The instruction at index $101$ is now fully specified and is no longer part of any unresolved list for the larger expression.\n\nNext, we synthesize the attribute lists for $E = p \\lor q$.\n- $E$ is true if $p$ is true OR if ($p$ is false AND $q$ is true). The jumps corresponding to the 'true' case for $p$ and the 'true' case for $q$ both lead to the overall expression being true. Therefore, the truelist for $E$ is the union of the truelists of its operands.\n  $E.truelist = p.truelist \\cup q.truelist = \\{100\\} \\cup \\{102\\} = \\{100, 102\\}$.\n- $E$ is false only if both $p$ and $q$ are false. The false path for $p$ leads to the evaluation of $q$. Thus, the overall falsity of the expression depends solely on the falsity of $q$.\n  $E.falselist = q.falselist = \\{103\\}$.\n\nSo, after processing $E = p \\lor q$, we have the unresolved jump lists:\n- $E.truelist = \\{100, 102\\}$\n- $E.falselist = \\{103\\}$\n\n**Step 4: Attribute Synthesis for the Negation $B = \\lnot E$**\n\nThe problem states that the logical negation operator $\\lnot$ does not generate any code but is implemented by swapping the `truelist` and `falselist` of its operand.\nFor $B = \\lnot E$, we have:\n- $B.truelist = E.falselist$\n- $B.falselist = E.truelist$\n\nSubstituting the lists derived in the previous step:\n- $B.truelist = \\{103\\}$\n- $B.falselist = \\{100, 102\\}$\n\nThese are the final lists of unresolved jump instructions for the complete expression $B = \\lnot(p \\lor q)$.\n\n**Step 5: Final Count of Patched Instructions**\n\nThe final step is to patch the instructions in the context `if B then goto $L_{T}$ else goto $L_{F}$`. This involves:\n- Patching all instruction indices in $B.truelist$ to jump to the label $L_{T}$.\n- Patching all instruction indices in $B.falselist$ to jump to the label $L_{F}$.\n\nThe question asks for the total number of distinct instruction targets that are patched in this final step. This corresponds to the total number of unique indices contained in both $B.truelist$ and $B.falselist$. This is the size of the union of these two sets: $|B.truelist \\cup B.falselist|$.\n\n- The indices in $B.truelist$ are $\\{103\\}$.\n- The indices in $B.falselist$ are $\\{100, 102\\}$.\n\nThe set of all distinct indices to be patched is $\\{103\\} \\cup \\{100, 102\\} = \\{100, 102, 103\\}$.\nThe total number of such distinct instructions is the cardinality of this set, which is $3$.\n\nThe individual instructions being patched are:\n1. The instruction at address $100$ (`if p goto ___`).\n2. The instruction at address $102$ (`if q goto ___`).\n3. The instruction at address $103$ (`goto ___` from the false-path of $q$).\n\nThe instruction at address $101$ was patched earlier, during the reduction of the `OR` expression, and is not part of this final step. Thus, exactly $3$ instruction targets are patched in the final step.", "answer": "$$\n\\boxed{3}\n$$", "id": "3623208"}, {"introduction": "Building upon the basics, this practice moves to a more complex expression involving multiple operators and precedence rules. This scenario requires you to manage the `truelist` and `falselist` attributes for an expression parsed as $E_1 \\lor (E_2 \\land E_3)$, applying the distinct backpatching logic for both conjunction and disjunction. Successfully solving this problem will solidify your ability to trace control flow through a syntax tree, a critical skill for implementing a real-world compiler parser [@problem_id:3623257].", "problem": "Consider the generation of Three-Address Code (TAC) for boolean expressions in an Intermediate Representation (IR) using short-circuit control flow with backpatching. Short-circuit semantics require that for disjunction $E_{1} \\lor E_{2}$, evaluation of $E_{2}$ proceeds only if $E_{1}$ evaluates to false, and for conjunction $E_{1} \\land E_{2}$, evaluation of $E_{2}$ proceeds only if $E_{1}$ evaluates to true. In a backpatching scheme, code for an atomic relational test $R$ is emitted as two instructions with unresolved branch targets: an instruction of the form $\\text{if } R \\text{ goto } ?$ followed by $\\text{goto } ?$, where the symbol $?$ denotes a placeholder to be filled later. The operation $\\text{makelist}(i)$ creates a list containing the index $i$ of an instruction whose target is yet to be determined, $\\text{merge}(L_{1},L_{2})$ concatenates lists of such indices, and $\\text{backpatch}(L,t)$ fills the unknown target fields of all instructions indexed by $L$ with the target address $t$.\n\nLet the next-instruction counter start at $1$, and assume the usual precedence where $\\land$ binds more tightly than $\\lor$. You have already emitted the two TAC instructions for the leftmost primitive test $xy$ as placeholders at instruction indices $1$ and $2$:\n- instruction $1$: $\\text{if } xy \\text{ goto } ?$\n- instruction $2$: $\\text{goto } ?$\n\nYou now must generate TAC with left-to-right short-circuiting for the expression $xy \\lor yz \\land u==v$. Emit code for each remaining atomic test in left-to-right order, assigning sequential instruction indices. Assume the start index of the code for $yz$ is $3$, and the start index of the code for $u==v$ is $5$. After constructing the appropriate $\\text{makelist}$ and $\\text{merge}$ results and performing all necessary $\\text{backpatch}$ operations to enforce short-circuit semantics, finally backpatch the overall truelist to the target address $100$ (the beginning of the \"then\" continuation) and the overall falselist to the target address $200$ (the beginning of the \"else\" continuation).\n\nCompute the sum $S$ of all concrete target addresses that get written into the six emitted TAC instructions' placeholder fields as a result of all $\\text{backpatch}$ operations described above. Provide $S$ as a single real-valued number. No rounding is required.", "solution": "The problem requires the generation of Three-Address Code (TAC) for the boolean expression $xy \\lor yz \\land u==v$ using backpatching and short-circuit evaluation. The final goal is to compute the sum of all target addresses that are filled into the placeholder fields of the generated TAC instructions.\n\nFirst, we must validate the problem statement.\nAll givens are extracted verbatim:\n- The expression is $xy \\lor yz \\land u==v$.\n- Operator precedence: $\\land$ has higher precedence than $\\lor$.\n- Short-circuit semantics are used for $\\lor$ and $\\land$.\n- A relational test $R$ generates two instructions: $\\text{if } R \\text{ goto } ?$ and $\\text{goto } ?$.\n- The functions $\\text{makelist}(i)$, $\\text{merge}(L_{1},L_{2})$, and $\\text{backpatch}(L,t)$ are defined for list manipulation and patching.\n- The next-instruction counter starts at $1$.\n- The first two instructions for $xy$ are already emitted at indices $1$ and $2$.\n- The code for $yz$ starts at instruction index $3$.\n- The code for $u==v$ starts at instruction index $5$.\n- The overall truelist is backpatched to target address $100$.\n- The overall falselist is backpatched to target address $200$.\n- The task is to compute the sum $S$ of all target addresses written into the six placeholder fields.\n\nThe problem is scientifically grounded in the principles of compiler design, specifically intermediate code generation. It is well-posed, objective, and contains all necessary information to derive a unique solution. The problem is valid.\n\nWe will now generate the code and perform the backpatching step-by-step, following the structure of the expression tree. Given the precedence rules, the expression is parsed as $E \\equiv (xy) \\lor ((yz) \\land (u==v))$. Let's denote the subexpressions as $E_1 \\equiv xy$, $E_2 \\equiv yz$, and $E_3 \\equiv u==v$. The expression is thus $E_1 \\lor (E_2 \\land E_3)$.\n\nWe maintain two lists of instruction indices for each subexpression $B$: $B.\\text{truelist}$, which contains indices of instructions that jump to the true-exit of $B$, and $B.\\text{falselist}$, which contains indices of instructions that jump to the false-exit of $B$.\n\n**Step 1: Process subexpression $E_1 \\equiv xy$**\nThe problem states that the code for this subexpression is already generated.\n- Instruction $1$: $\\text{if } xy \\text{ goto } ?$\n- Instruction $2$: $\\text{goto } ?$\nThe `truelist` for $E_1$ consists of the conditional jump, and the `falselist` consists of the unconditional jump.\n$E_1.\\text{truelist} = \\text{makelist}(1) = \\{1\\}$\n$E_1.\\text{falselist} = \\text{makelist}(2) = \\{2\\}$\nThe next available instruction index is $3$.\n\n**Step 2: Process the $\\lor$ operator: $E \\equiv E_1 \\lor (E_2 \\land E_3)$**\nThe semantics of short-circuit `or` are as follows: if $E_1$ is true, the entire expression is true. If $E_1$ is false, we must evaluate the second operand, $(E_2 \\land E_3)$. Therefore, the jumps in $E_1.\\text{falselist}$ must be backpatched to point to the beginning of the code for $(E_2 \\land E_3)$. The problem specifies that the code for $yz$ (the start of the second operand) begins at instruction index $3$.\nWe perform the first backpatch operation:\n$\\text{backpatch}(E_1.\\text{falselist}, 3) \\implies \\text{backpatch}(\\{2\\}, 3)$.\nThe target of instruction $2$ is set to $3$.\n- Instruction $2$ becomes: $\\text{goto } 3$.\n- The value backpatched is $3$.\n\n**Step 3: Process subexpression $E_2 \\equiv yz$**\nThe code for this subexpression starts at index $3$.\n- Instruction $3$: $\\text{if } yz \\text{ goto } ?$\n- Instruction $4$: $\\text{goto } ?$\nThe lists for $E_2$ are:\n$E_2.\\text{truelist} = \\text{makelist}(3) = \\{3\\}$\n$E_2.\\text{falselist} = \\text{makelist}(4) = \\{4\\}$\nThe next available instruction index is $5$.\n\n**Step 4: Process the $\\land$ operator: $(E_2 \\land E_3)$**\nThe semantics of short-circuit `and` require that if $E_2$ is false, the entire conjunction is false. If $E_2$ is true, we must evaluate $E_3$. Therefore, the jumps in $E_2.\\text{truelist}$ must be backpatched to point to the beginning of the code for $E_3$. The problem states that the code for $u==v$ (which is $E_3$) begins at instruction index $5$.\nWe perform the second backpatch operation:\n$\\text{backpatch}(E_2.\\text{truelist}, 5) \\implies \\text{backpatch}(\\{3\\}, 5)$.\nThe target of instruction $3$ is set to $5$.\n- Instruction $3$ becomes: $\\text{if } yz \\text{ goto } 5$.\n- The value backpatched is $5$.\n\n**Step 5: Process subexpression $E_3 \\equiv u==v$**\nThe code for this subexpression starts at index $5$.\n- Instruction $5$: $\\text{if } u==v \\text{ goto } ?$\n- Instruction $6$: $\\text{goto } ?$\nThe lists for $E_3$ are:\n$E_3.\\text{truelist} = \\text{makelist}(5) = \\{5\\}$\n$E_3.\\text{falselist} = \\text{makelist}(6) = \\{6\\}$\n\n**Step 6: Synthesize lists for the subexpression $(E_2 \\land E_3)$**\nLet's call this subexpression $B = E_2 \\land E_3$.\n- The `truelist` of $B$ consists only of the jumps that occur when $E_3$ is true (since $E_2$ must also have been true to reach $E_3$). So, $B.\\text{truelist} = E_3.\\text{truelist} = \\{5\\}$.\n- The `falselist` of $B$ consists of all jumps that lead to a false outcome for the conjunction. This happens if $E_2$ is false or if $E_3$ is false. So, we merge their falselists:\n$B.\\text{falselist} = \\text{merge}(E_2.\\text{falselist}, E_3.\\text{falselist}) = \\text{merge}(\\{4\\}, \\{6\\}) = \\{4, 6\\}$.\n\n**Step 7: Synthesize lists for the full expression $E \\equiv E_1 \\lor B$**\n- The `truelist` of $E$ consists of all jumps that lead to a true outcome. This happens if $E_1$ is true or if $B$ is true. So, we merge their truelists:\n$E.\\text{truelist} = \\text{merge}(E_1.\\text{truelist}, B.\\text{truelist}) = \\text{merge}(\\{1\\}, \\{5\\}) = \\{1, 5\\}$.\n- The `falselist` of $E$ consists of jumps that occur only when both $E_1$ and $B$ are false. Since the false-exit of $E_1$ was already rerouted to evaluate $B$, the overall false-exit is determined solely by the false-exit of $B$.\n$E.\\text{falselist} = B.\\text{falselist} = \\{4, 6\\}$.\n\n**Step 8: Final backpatching of the overall expression**\nThe problem requires backpatching the overall truelist to the target address $100$ and the overall falselist to $200$.\n- Backpatching the truelist: $\\text{backpatch}(E.\\text{truelist}, 100) \\implies \\text{backpatch}(\\{1, 5\\}, 100)$.\n  - The target of instruction $1$ is set to $100$. The value backpatched is $100$.\n  - The target of instruction $5$ is set to $100$. The value backpatched is $100$.\n- Backpatching the falselist: $\\text{backpatch}(E.\\text{falselist}, 200) \\implies \\text{backpatch}(\\{4, 6\\}, 200)$.\n  - The target of instruction $4$ is set to $200$. The value backpatched is $200$.\n  - The target of instruction $6$ is set to $200$. The value backpatched is $200$.\n\n**Step 9: Summarize and compute the sum $S$**\nWe list all the target addresses written into the placeholder fields:\n1.  Instruction $2$'s target was set to $3$.\n2.  Instruction $3$'s target was set to $5$.\n3.  Instruction $1$'s target was set to $100$.\n4.  Instruction $5$'s target was set to $100$.\n5.  Instruction $4$'s target was set to $200$.\n6.  Instruction $6$'s target was set to $200$.\n\nThe sum $S$ is the sum of these values:\n$S = 3 + 5 + 100 + 100 + 200 + 200$\n$S = 8 + 200 + 400$\n$S = 608$\n\nThe final generated TAC with all placeholders filled is:\n1: if $xy$ goto $100$\n2: goto $3$\n3: if $yz$ goto $5$\n4: goto $200$\n5: if $u==v$ goto $100$\n6: goto $200$\n...\n100: (code for true case) ...\n...\n200: (code for false case) ...", "answer": "$$\\boxed{608}$$", "id": "3623257"}, {"introduction": "Our final practice addresses a crucial real-world challenge: handling function calls with potential side effects within boolean expressions. In languages that mandate short-circuit semantics, it's vital that a function call on the right-hand side of an operator like $\\land$ is never executed if the left-hand side determines the outcome. This exercise challenges you to select the correct set of semantic actions to extend the backpatching framework, ensuring that program behavior remains correct and predictable, even in the presence of side effects [@problem_id:3623181].", "problem": "An optimizing compiler must compile short-circuit boolean expressions with function calls that may have side effects so that calls occur exactly when demanded by short-circuit semantics. Consider three-address intermediate code with conditional jumps, and the backpatching method for boolean expressions. The compiler uses attributes $E.\\text{truelist}$ and $E.\\text{falselist}$ for any boolean expression nonterminal $E$, where each attribute is a list of indices of jumps whose targets are not yet fixed. The standard helper operations are the following fundamental definitions: $\\text{makelist}(i)$ creates a list containing index $i$, $\\text{merge}(L_1,L_2)$ concatenates lists $L_1$ and $L_2$, and $\\text{backpatch}(L,i)$ fills the target of all jumps in list $L$ with instruction index $i$. The function $\\text{nextquad}()$ returns the index of the next instruction to be emitted. An auxiliary marker nonterminal $M$ is used with the synthesized attribute $M.\\text{quad}$ defined by $M \\rightarrow \\varepsilon$ with the action $M.\\text{quad} := \\text{nextquad}()$.\n\nAssume boolean-returning function calls $f()$ and $g()$ may have side effects, and the language requires left-to-right evaluation with short-circuit semantics. In particular, in $f() \\land g()$, the call to $g()$ must not occur if $f()$ evaluates to false. The intermediate code for a single boolean-returning call is produced by emitting an assignment to a fresh temporary followed by a conditional branch on that temporary and an unconditional jump on failure. Specifically, the emitted form is $\\text{emit}(t := \\text{call } \\textit{name}())$, then $\\text{emit}(\\text{if } t \\ \\text{goto } \\_)$ at position $i$, and then $\\text{emit}(\\text{goto } \\_)$ at position $j$, with $E.\\text{truelist} := \\text{makelist}(i)$ and $E.\\text{falselist} := \\text{makelist}(j)$.\n\nYou are to choose a correct extension of backpatching rules for conjunction that enforces short-circuit evaluation without reordering or duplicating calls, by using the marker $M$ to control where the right operand starts. Consider the following four candidate translation schemes for the conjunction production; in all options, the rule for a call primary $E \\rightarrow \\text{call-id}()$ is as just described above for a single call, and only the rule for conjunction differs.\n\nWhich option correctly compiles $E \\rightarrow E_1 \\land M \\ E_2$ so that in $f() \\land g()$ the call to $g()$ is not emitted on the false outcome of $f()$, and the resulting $E.\\text{truelist}$ and $E.\\text{falselist}$ reflect the truth of the conjunction?\n\nA. Use the marker $M$ before $E_2$ to begin the right operand only on the true exit of the left operand:\n- Production: $E \\rightarrow E_1 \\land \\ M \\ E_2$\n- Actions:\n  1. $\\text{backpatch}(E_1.\\text{truelist}, \\ M.\\text{quad})$\n  2. $E.\\text{truelist} := E_2.\\text{truelist}$\n  3. $E.\\text{falselist} := \\text{merge}(E_1.\\text{falselist}, \\ E_2.\\text{falselist})$\n\nB. Route the false exit of the left operand into the right operand and accumulate true exits:\n- Production: $E \\rightarrow E_1 \\land \\ M \\ E_2$\n- Actions:\n  1. $\\text{backpatch}(E_1.\\text{falselist}, \\ M.\\text{quad})$\n  2. $E.\\text{truelist} := \\text{merge}(E_1.\\text{truelist}, \\ E_2.\\text{truelist})$\n  3. $E.\\text{falselist} := E_2.\\text{falselist}$\n\nC. Place the marker $M$ after the right operand and backpatch the true exits past the right operand:\n- Production: $E \\rightarrow E_1 \\land \\ E_2 \\ M$\n- Actions:\n  1. $\\text{backpatch}(E_1.\\text{truelist}, \\ M.\\text{quad})$\n  2. $E.\\text{truelist} := E_2.\\text{truelist}$\n  3. $E.\\text{falselist} := \\text{merge}(E_1.\\text{falselist}, \\ E_2.\\text{falselist})$\n\nD. Eagerly evaluate both operands into temporaries and branch once on their conjunction:\n- Production: $E \\rightarrow E_1 \\land E_2$\n- Actions:\n  1. Translate $E_1$ and $E_2$ to produce temporaries $t_1$ and $t_2$ by emitting both calls unconditionally.\n  2. $\\text{emit}(t_3 := t_1 \\land t_2)$\n  3. $\\text{emit}(\\text{if } t_3 \\ \\text{goto } \\_)$ at position $i$; $\\text{emit}(\\text{goto } \\_)$ at position $j$\n  4. $E.\\text{truelist} := \\text{makelist}(i)$; $E.\\text{falselist} := \\text{makelist}(j)$\n\nSelect the correct option.", "solution": "### Problem Validation\n\nThe problem statement describes a standard task in compiler construction: generating intermediate code for short-circuit boolean expressions using the backpatching technique. This is a core topic in syntax-directed translation.\n\n**Step 1: Extract Givens**\n\n*   **Goal**: Compile short-circuit boolean expressions with side-effecting function calls such that calls occur only when demanded by short-circuit semantics.\n*   **Target Code**: Three-address intermediate code with conditional jumps.\n*   **Method**: Backpatching.\n*   **Attributes**: For a boolean expression nonterminal $E$, attributes are $E.\\text{truelist}$ and $E.\\text{falselist}$, which are lists of jump instruction indices.\n*   **Helper Operations**:\n    *   $\\text{makelist}(i)$: creates a list containing only the instruction index $i$.\n    *   $\\text{merge}(L_1, L_2)$: concatenates lists $L_1$ and $L_2$.\n    *   $\\text{backpatch}(L, i)$: sets the target of all jumps in list $L$ to instruction index $i$.\n*   **Helper Function**: $\\text{nextquad}()$ returns the index of the next instruction to be emitted.\n*   **Marker Nonterminal**: $M \\rightarrow \\varepsilon$ with semantic action $M.\\text{quad} := \\text{nextquad}()$. This marker records the index of the next instruction.\n*   **Language Semantics for Conjunction**: For an expression like $f() \\land g()$:\n    1.  Evaluation is left-to-right.\n    2.  Short-circuiting is required: $g()$ is not called if $f()$ evaluates to false.\n*   **Code for a Single Function Call**: For an expression $E$ consisting of a call, `call-id()`:\n    1.  Emit $\\text{emit}(t := \\text{call } \\textit{name}())$.\n    2.  Emit $\\text{emit}(\\text{if } t \\ \\text{goto } \\_)$ at instruction index $i$.\n    3.  Emit $\\text{emit}(\\text{goto } \\_)$ at instruction index $j$.\n    4.  Set attributes: $E.\\text{truelist} := \\text{makelist}(i)$ and $E.\\text{falselist} := \\text{makelist}(j)$.\n*   **Task**: Identify the correct translation scheme for the production $E \\rightarrow E_1 \\land M E_2$ that enforces the specified semantics.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded**: The problem is based on the well-established theory of compiler design, specifically syntax-directed translation and code generation for boolean expressions. Backpatching is a standard algorithm presented in canonical compiler textbooks (e.g., Aho, Lam, Sethi, Ullman, \"Compilers: Principles, Techniques, and Tools\"). The concepts are sound and part of core computer science.\n*   **Well-Posed**: The problem is clearly defined. It provides the necessary background, definitions of operations and attributes, and a specific goal. It asks to select one set of semantic actions from a list of four candidates that correctly implements the specified logic. This structure lends itself to a unique, correct answer.\n*   **Objective**: The problem is stated in precise, formal, and objective language common to computer science. It is free of ambiguity and subjective claims.\n*   **Completeness and Consistency**: The problem statement is self-contained. It defines all necessary components ($\\text{backpatch}$, $\\text{makelist}$, $M$, etc.) and the precise semantics to be implemented (left-to-right, short-circuit evaluation). There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a standard, well-posed problem from the field of compiler design. I will now proceed to derive the solution and evaluate the options.\n\n### Solution Derivation\n\nThe goal is to define the semantic actions for the production $E \\rightarrow E_1 \\land E_2$ to implement short-circuit logical `AND`. Let's analyze the required control flow.\n\n1.  The code for $E_1$ must be executed first.\n2.  If $E_1$ evaluates to `false`, the entire expression $E_1 \\land E_2$ is `false`. The evaluation of $E_2$ must be skipped. Control should transfer to the locations designated for when $E$ is false. The jumps in $E_1.\\text{falselist}$ should become part of the overall expression's falselist, $E.\\text{falselist}$.\n3.  If $E_1$ evaluates to `true`, the result of the entire expression depends on the value of $E_2$. Therefore, control must flow from the true-exits of $E_1$ to the beginning of the code for $E_2$. This ensures $E_2$ (and any associated side-effecting calls) is executed only when necessary.\n4.  After control flows to the code for $E_2$, its evaluation determines the final result of the expression $E$.\n    *   If $E_2$ evaluates to `true`, the whole expression $E$ is `true`. So, $E_2.\\text{truelist}$ should become the truelist of $E$, i.e., $E.\\text{truelist}$.\n    *   If $E_2$ evaluates to `false`, the whole expression $E$ is `false`. So, $E_2.\\text{falselist}$ should be merged into the overall expression's falselist, $E.\\text{falselist}$.\n\nLet's translate this logic into backpatching actions for the production $E \\rightarrow E_1 \\land M E_2$.\n\n*   The parser will process $E_1$, then $M$, then $E_2$.\n*   After generating code for $E_1$, we have its $E_1.\\text{truelist}$ and $E_1.\\text{falselist}$.\n*   Next, the marker $M$ is processed. Its action $M.\\text{quad} := \\text{nextquad}()$ stores the starting address of the code that follows, which is the code for $E_2$.\n*   To implement rule $3$ from above (if $E_1$ is true, evaluate $E_2$), we must backpatch the true-exits of $E_1$ to point to the start of $E_2$'s code. The action is thus $\\text{backpatch}(E_1.\\text{truelist}, M.\\text{quad})$.\n*   Next, the code for $E_2$ is generated, yielding $E_2.\\text{truelist}$ and $E_2.\\text{falselist}$.\n*   Finally, the reduction for the entire production $E \\rightarrow E_1 \\land M E_2$ occurs. We must define $E.\\text{truelist}$ and $E.\\text{falselist}$.\n    *   As per rule $4$, the final expression $E$ is true only if $E_1$ is true *and* $E_2$ is true. We have already ensured that if $E_1$ is true, we evaluate $E_2$. Therefore, the jumps that confirm the entire expression is true are exactly the jumps in $E_2.\\text{truelist}$. So, $E.\\text{truelist} := E_2.\\text{truelist}$.\n    *   As per rules $2$ and $4$, the final expression $E$ is false if $E_1$ is false, OR if $E_1$ is true and $E_2$ is false. The jumps for the first case are in $E_1.\\text{falselist}$. The jumps for the second case are in $E_2.\\text{falselist}$. Both lists of jumps should lead to the false-exit of the entire expression. So, we must combine them: $E.\\text{falselist} := \\text{merge}(E_1.\\text{falselist}, E_2.\\text{falselist})$.\n\nThe derived semantic actions are:\n1.  $\\text{backpatch}(E_1.\\text{truelist}, M.\\text{quad})$\n2.  $E.\\text{truelist} := E_2.\\text{truelist}$\n3.  $E.\\text{falselist} := \\text{merge}(E_1.\\text{falselist}, E_2.\\text{falselist})$\n\nThese actions perfectly match those provided in Option A.\n\n### Option-by-Option Analysis\n\n**A. Use the marker $M$ before $E_2$ to begin the right operand only on the true exit of the left operand:**\n*   Production: $E \\rightarrow E_1 \\land \\ M \\ E_2$\n*   Actions:\n    1.  $\\text{backpatch}(E_1.\\text{truelist}, \\ M.\\text{quad})$: This correctly implements the logic that if $E_1$ is true, evaluation must proceed to $E_2$. $M.\\text{quad}$ marks the beginning of $E_2$'s code.\n    2.  $E.\\text{truelist} := E_2.\\text{truelist}$: This is correct. The entire conjunction is true if and only if $E_1$ was true (leading to $E_2$'s evaluation) and $E_2$ is also true.\n    3.  $E.\\text{falselist} := \\text{merge}(E_1.\\text{falselist}, \\ E_2.\\text{falselist})$: This is correct. The conjunction is false if $E_1$ is false (jumps in $E_1.\\text{falselist}$) or if $E_1$ is true and $E_2$ is false (jumps in $E_2.\\text{falselist}$).\n*   **Verdict**: Correct. This scheme correctly implements short-circuit `AND` evaluation.\n\n**B. Route the false exit of the left operand into the right operand and accumulate true exits:**\n*   Production: $E \\rightarrow E_1 \\land \\ M \\ E_2$\n*   Actions:\n    1.  $\\text{backpatch}(E_1.\\text{falselist}, \\ M.\\text{quad})$: This action routes control to $E_2$ when $E_1$ is *false*. This is the logic for a short-circuit `OR` ($E_1 \\lor E_2$), not `AND`. If $E_1$ is false, an `AND` expression should immediately terminate with a false result, not evaluate $E_2$.\n*   **Verdict**: Incorrect. This describes the translation scheme for logical disjunction (`OR`), not conjunction (`AND`).\n\n**C. Place the marker $M$ after the right operand and backpatch the true exits past the right operand:**\n*   Production: $E \\rightarrow E_1 \\land \\ E_2 \\ M$\n*   Actions:\n    1.  $\\text{backpatch}(E_1.\\text{truelist}, \\ M.\\text{quad})$: In this grammar rule, the marker $M$ action runs *after* the code for $E_2$ has been generated. Thus, $M.\\text{quad}$ points to the instruction *after* $E_2$. By backpatching $E_1.\\text{truelist}$ to this address, we are making control *jump over* the code for $E_2$ when $E_1$ is true. This is the exact opposite of the required behavior for an `AND` operation.\n*   **Verdict**: Incorrect. The placement of the marker and the corresponding backpatch action result in semantically incorrect control flow.\n\n**D. Eagerly evaluate both operands into temporaries and branch once on their conjunction:**\n*   Production: $E \\rightarrow E_1 \\land E_2$\n*   Actions:\n    1.  The first action is to \"Translate $E_1$ and $E_2$ to produce temporaries $t_1$ and $t_2$ by emitting both calls unconditionally.\" This explicitly violates the problem's central requirement: \"in $f() \\land g()$, the call to $g()$ must not occur if $f()$ evaluates to false.\" This approach does not implement short-circuiting and is therefore incorrect for any language that mandates it, especially when function calls can have side effects.\n*   **Verdict**: Incorrect. This scheme fails to implement the required short-circuit semantics.", "answer": "$$\\boxed{A}$$", "id": "3623181"}]}