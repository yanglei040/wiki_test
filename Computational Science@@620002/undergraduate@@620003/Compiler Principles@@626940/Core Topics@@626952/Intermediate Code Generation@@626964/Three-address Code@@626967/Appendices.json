{"hands_on_practices": [{"introduction": "This first practice explores the translation of control flow structures into three-address code. By converting a ternary expression like $x = (a == 0 ? 0 : b / a)$ into a sequence of jumps and labels, you will see how compilers enforce short-circuiting semantics. This exercise is fundamental to understanding how TAC can structurally prevent runtime errors, such as division by zero, which is a critical aspect of generating safe and correct code [@problem_id:3675498].", "problem": "You are compiling the expression $x = (a == 0 ? 0 : b / a)$ into Three-Address Code (TAC), where Three-Address Code (TAC) uses a linearized sequence of primitive instructions with explicit temporaries and labels. The conditional operator must preserve short-circuit semantics: the right-hand alternative $b / a$ must not be evaluated if $a == 0$. In particular, division by zero must be structurally avoided by the emitted TAC.\n\nAssume the following primitive TAC instruction forms are available:\n- Conditional branch: “if $u$ relop $v$ goto $L$”.\n- Unconditional jump: “goto $L$”.\n- Binary arithmetic operation: “$t = y$ op $z$” (with division “$/$” as a specific operation).\n- Assignment: “$x = y$”.\n\nLabels are annotations for branch targets and do not themselves incur runtime cost. All temporaries must be explicitly introduced.\n\nTask:\n1) Derive a minimal TAC sequence with explicit labels and temporaries that implements $x = (a == 0 ? 0 : b / a)$, preserving short-circuit semantics and structurally avoiding division by zero. Show the branches and temporaries used.\n\n2) Suppose each executed instruction incurs a cost as follows: each conditional branch has cost $c_{\\mathrm{br}}$, each unconditional jump has cost $c_{\\mathrm{goto}}$, each division has cost $c_{\\mathrm{div}}$, and each assignment has cost $c_{\\mathrm{as}}$. Let $p = \\Pr[a = 0]$. Using only first principles (the semantics of the conditional operator and linear execution of TAC with branches), compute the expected execution cost of your TAC as a closed-form expression in $p$, $c_{\\mathrm{br}}$, $c_{\\mathrm{goto}}$, $c_{\\mathrm{div}}$, and $c_{\\mathrm{as}}$. Labels do not incur cost. Assume no other sources of cost.\n\nYour final answer must be a single closed-form analytic expression. Do not round. Do not include units.", "solution": "The problem as stated is valid. It is a well-posed problem in the domain of compiler construction, providing all necessary definitions, constraints, and data to derive a unique solution for the expected cost of a correctly generated Three-Address Code (TAC) sequence. The problem is scientifically grounded, objective, and self-contained.\n\nThe task is to compile the expression $x = (a == 0 ? 0 : b / a)$ into TAC, and then compute the expected execution cost. A critical constraint is the preservation of short-circuit semantics, meaning the sub-expression $b / a$ must not be evaluated if $a=0$.\n\n**Part 1: Derivation of the Three-Address Code**\n\nTo implement the short-circuiting behavior of the ternary operator, we must use a conditional branch instruction. The logic is as follows: first, evaluate the condition $a == 0$. If it is true, control flow must branch to a sequence of instructions that assigns $0$ to $x$. If the condition is false, control flow should continue to a sequence that computes $b / a$, assigns the result to $x$, and then unconditionally jumps over the code for the true case.\n\nLet $L_1$ be the label for the true-path code (i.e., when $a == 0$) and $L_2$ be the label for the instruction immediately following the entire ternary operation. Based on the provided primitive TAC instruction forms, a minimal sequence is:\n\n1. `if` $a == 0$ `goto` $L_1$\n2. $t_1 = b / a$\n3. $x = t_1$\n4. `goto` $L_2$\n5. $L_1$: $x = 0$\n6. $L_2$:\n\nThis sequence correctly implements the expression while satisfying all constraints:\n- The first instruction, `if` $a == 0$ `goto` $L_1$, implements the check. If $a$ is indeed $0$, control jumps to label $L_1$, completely bypassing instructions $2$, $3$, and $4$.\n- The second instruction, $t_1 = b / a$, which performs the division, is only reachable if the condition in the first instruction is false (i.e., if $a \\neq 0$). This structurally avoids division by zero. The result is stored in an explicitly introduced temporary, $t_1$.\n- The third instruction, $x = t_1$, assigns the result of the division to the target variable $x$.\n- The fourth instruction, `goto` $L_2$, is an unconditional jump to skip the code for the true path (instruction $5$) and resume execution after the conditional block.\n- The fifth instruction, $x = 0$, located at label $L_1$, is the target of the initial conditional jump. It handles the true path by assigning $0$ to $x$.\n- The label $L_2$ marks the merge point after the conditional logic is complete.\n\nThis sequence consists of $5$ instructions, which is minimal for the given instruction set and semantics.\n\n**Part 2: Expected Execution Cost Calculation**\n\nThe expected execution cost, which we denote as $E$, is determined by the costs of the two possible execution paths, weighted by their respective probabilities. We are given that $p = \\Pr[a = 0]$, so $\\Pr[a \\neq 0] = 1-p$. The costs for each type of instruction are given as $c_{\\mathrm{br}}$, $c_{\\mathrm{goto}}$, $c_{\\mathrm{div}}$, and $c_{\\mathrm{as}}$.\n\n**Path 1: Case where $a=0$ (occurs with probability $p$)**\nThe executed instructions are:\n1. `if` $a == 0$ `goto` $L_1$: The conditional branch is executed, and the jump is taken. The cost is $c_{\\mathrm{br}}$.\n2. (Control jumps to $L_1$)\n3. $x = 0$: The assignment is executed. The cost is $c_{\\mathrm{as}}$.\nThe total cost for this path, $C_{\\text{true}}$, is the sum of the costs of the executed instructions:\n$$C_{\\text{true}} = c_{\\mathrm{br}} + c_{\\mathrm{as}}$$\n\n**Path 2: Case where $a \\neq 0$ (occurs with probability $1-p$)**\nThe executed instructions are:\n1. `if` $a == 0$ `goto` $L_1$: The conditional branch is executed, but the jump is not taken (fall-through). The cost is $c_{\\mathrm{br}}$.\n2. $t_1 = b / a$: The division is performed. The cost is $c_{\\mathrm{div}}$.\n3. $x = t_1$: An assignment is performed. The cost is $c_{\\mathrm{as}}$.\n4. `goto` $L_2$: The unconditional jump is executed. The cost is $c_{\\mathrm{goto}}$.\nThe total cost for this path, $C_{\\text{false}}$, is:\n$$C_{\\text{false}} = c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}}$$\n\n**Calculating the Expected Cost**\nThe expected cost $E$ is the sum of the path costs weighted by their probabilities:\n$$E = (\\Pr[a=0] \\cdot C_{\\text{true}}) + (\\Pr[a \\neq 0] \\cdot C_{\\text{false}})$$\nSubstituting the probabilities and cost expressions:\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}})$$\nWe can simplify this expression. Notice that both paths execute the conditional branch and an assignment to $x$. We can regroup the terms:\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\nFactoring out $(c_{\\mathrm{br}} + c_{\\mathrm{as}})$ from the first two terms:\n$$E = (p + 1 - p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n$$E = 1 \\cdot (c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\nThis yields the final closed-form expression for the expected cost:\n$$E = c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\nThis expression intuitively states that the total expected cost is the cost of the instructions that are always executed ($c_{\\mathrm{br}} + c_{\\mathrm{as}}$) plus the cost of the instructions that are executed only when $a \\neq 0$ ($c_{\\mathrm{div}} + c_{\\mathrm{goto}}$), weighted by the probability of that case ($1-p$).", "answer": "$$ \\boxed{c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})} $$", "id": "3675498"}, {"introduction": "Building on the basics of sequential execution, this problem focuses on the careful handling of side effects. You will analyze the translation of a statement containing a post-increment operator, $a[i^{++}] = b + c \\cdot d$, into TAC. This practice highlights the critical role of temporary variables in preserving a value for later use, ensuring that the program's behavior correctly matches the source language's semantic rules for evaluation order [@problem_id:3675439].", "problem": "A simplified imperative source language supports integer variables and arrays, and the post-increment operator on variables. Consider the assignment statement with a post-increment in the array index:\n$$\na[i^{++}] = b + c \\cdot d.\n$$\nAssume the following foundational semantic rules.\n- Post-increment semantics: evaluating $x^{++}$ yields the current value of $x$ as the expression value and schedules the side effect $x := x + 1$ to occur after the value is obtained and before the end of the full expression containing it.\n- Assignment semantics: evaluating $L := R$ proceeds by evaluating the left-hand side expression to a location and the right-hand side expression to a value; the store to the location occurs after both sides have been evaluated. Arithmetic operations are pure and have no side effects.\n- No-aliasing and purity: variables $a$, $b$, $c$, $d$, and $i$ refer to disjoint storage; $b$, $c$, and $d$ are scalars; evaluating $b$, $c$, and $d$ has no side effects and does not read $i$; the array $a$ does not alias any of $b$, $c$, $d$, or $i$ except through its own elements.\n\nA compiler lowers the source statement into three-address code (TAC; three-address code) using temporaries $t_1$, $t_2$, $t_3$. Two candidate TAC variants are considered:\n\nVariant X:\n1. $t_1 := i$\n2. $t_2 := c \\cdot d$\n3. $t_3 := b + t_2$\n4. $a[t_1] := t_3$\n5. $i := i + 1$\n\nVariant Y:\n1. $t_1 := i$\n2. $i := i + 1$\n3. $t_2 := c \\cdot d$\n4. $t_3 := b + t_2$\n5. $a[t_1] := t_3$\n\nLet the initial value of $i$ before executing either variant be an arbitrary integer denoted $i_0$. Define $\\Delta$ to be the difference between the array index used for the store in Variant X and the array index used for the store in Variant Y:\n$$\n\\Delta := \\big(\\text{store index in X}\\big) - \\big(\\text{store index in Y}\\big).\n$$\nUnder the stated semantic rules and assumptions, determine the exact value of $\\Delta$. Your final answer must be a single real number. No rounding is required. Express the final answer as a pure number without any unit.", "solution": "The problem requires the determination of the difference, $\\Delta$, between the array indices used in the store instructions of two variants of three-address code, labeled Variant X and Variant Y.\n\nLet the initial value of the integer variable $i$ before the execution of either code variant be denoted by $i_0$. Our analysis will proceed by tracing the execution of each variant, starting from this initial state.\n\nFirst, we analyze Variant X. The sequence of instructions is as follows:\n1.  $t_1 := i$\n2.  $t_2 := c \\cdot d$\n3.  $t_3 := b + t_2$\n4.  $a[t_1] := t_3$\n5.  $i := i + 1$\n\nWe trace the values of the relevant variables, specifically $i$ and the temporary $t_1$ which is used as the array index.\n-   Initially, the value of $i$ is $i_0$.\n-   At instruction 1, $t_1 := i$, the current value of $i$, which is $i_0$, is assigned to the temporary variable $t_1$. After this instruction, $t_1$ holds the value $i_0$. The value of $i$ remains $i_0$.\n-   Instructions 2 and 3 compute the right-hand side of the original assignment. They do not involve or modify the variables $i$ or $t_1$. Thus, before instruction 4, the value of $t_1$ is still $i_0$.\n-   Instruction 4, $a[t_1] := t_3$, is the store operation. The array index used is the value of the variable $t_1$. At this point in the execution, the value of $t_1$ is $i_0$. Therefore, the store index in Variant X is $i_0$.\n-   Instruction 5, $i := i + 1$, increments the value of $i$. This occurs after the store operation has used the original value of $i$ (via $t_1$).\n\nFrom this analysis, we conclude that the store index in Variant X is $i_0$.\n\nNext, we analyze Variant Y. The sequence of instructions is:\n1.  $t_1 := i$\n2.  $i := i + 1$\n3.  $t_2 := c \\cdot d$\n4.  $t_3 := b + t_2$\n5.  $a[t_1] := t_3$\n\nWe trace the values of $i$ and $t_1$ for this variant, again starting with $i = i_0$.\n-   Initially, the value of $i$ is $i_0$.\n-   At instruction 1, $t_1 := i$, the current value of $i$, which is $i_0$, is assigned to the temporary variable $t_1$. After this instruction, $t_1$ holds the value $i_0$.\n-   At instruction 2, $i := i + 1$, the value of $i$ is incremented to $i_0 + 1$. This instruction modifies the storage location for $i$. However, it does not affect the value of the temporary variable $t_1$, which occupies a distinct storage location and already holds the value $i_0$.\n-   Instructions 3 and 4 compute the right-hand side and do not modify $i$ or $t_1$. Before instruction 5, the value of $t_1$ remains $i_0$, while the value of $i$ is $i_0+1$.\n-   Instruction 5, $a[t_1] := t_3$, is the store operation. The array index used is the value of $t_1$. At this point, the value of $t_1$ is still $i_0$. Therefore, the store index in Variant Y is $i_0$.\n\nFrom this analysis, we conclude that the store index in Variant Y is also $i_0$.\n\nThe problem defines $\\Delta$ as the difference between the store indices of the two variants:\n$$\n\\Delta := (\\text{store index in X}) - (\\text{store index in Y})\n$$\nSubstituting the values we have determined:\n$$\n\\Delta = i_0 - i_0\n$$\n$$\n\\Delta = 0\n$$\nThe difference between the array indices used for the store operation in Variant X and Variant Y is $0$. Both variants correctly capture the value of $i$ before the increment for use as the array index, as required by the post-increment semantic rule. The different placement of the increment instruction `i := i + 1` does not alter the value used for the index, which was saved in the temporary $t_1$ at the beginning of both sequences.", "answer": "$$\\boxed{0}$$", "id": "3675439"}, {"introduction": "Our final exercise scales up these concepts to one of the most powerful programming constructs: recursion. You will translate the recursive factorial function into TAC, managing parameter passing, function calls, and return values using a standardized instruction set. By tracing the dynamic creation of temporary variables through the call stack, you will gain a concrete understanding of how TAC models the execution of complex, nested procedure calls [@problem_id:3675465].", "problem": "You are given the high-level recursive definition of the factorial function $f(n)$ for an integer input $n \\ge 0$:\nIf $n \\le 1$ then return $1$, else return $n \\times f(n-1)$.\nStarting from the core definitions of three-address code (TAC) in compiler principles—where each TAC instruction has at most three addresses and follows a canonical instruction set with temporaries, labels, conditional and unconditional branches, parameter passing, procedure call, and return—perform the following tasks.\n\n1. Translate the function $f(n)$ into a canonical three-address code form using the following instruction forms:\n- Assignment of the result of a primitive operation into a new temporary: $t := x \\ \\text{op} \\ y$.\n- Assignment of a Boolean comparison into a new temporary: $t := x \\ \\text{relop} \\ y$.\n- Conditional branch: $\\text{if} \\ t \\ \\text{goto} \\ L$.\n- Unconditional jump: $\\text{goto} \\ L$.\n- Parameter passing: $\\text{param} \\ x$ for each actual.\n- Procedure call returning to a new temporary: $t := \\text{call} \\ f, k$, where $k$ is the number of actual parameters passed by preceding $\\text{param}$ instructions.\n- Return from procedure: $\\text{ret} \\ x$.\n- Label: $L:$, which is not an executable instruction.\n\nAdopt the following conventions.\n- Every executed assignment to a temporary introduces a fresh temporary $t_i$ with a globally increasing index $i \\in \\mathbb{N}$, starting at $i=1$ for the first such assignment anywhere during the entire run. The sequence $t_1, t_2, \\dots$ records the dynamic creation order of temporaries across all procedures.\n- Labels are not counted as executed instructions. The instructions $\\text{if}$, $\\text{goto}$, $\\text{param}$, $\\text{call}$, and $\\text{ret}$ are counted as executed instructions when control flows through them but do not themselves create new temporaries, except that the $\\text{call}$ form assigns the return value to a new temporary as specified above. The base-case return of the constant uses $\\text{ret} \\ 1$ directly and does not create a temporary.\n- Evaluation is left-to-right, and recursion follows the natural depth-first call sequence.\n\nA driver executes the following code to invoke $f$:\n- $\\text{param} \\ n$\n- $t := \\text{call} \\ f, 1$\n- $\\text{halt}$\n\nAssume the input is $n = 7$.\n\nDerive a correct TAC for $f(n)$ under these conventions. Then, by tracing the dynamic call sequence and the creation of temporaries $t_i$ in the order they are created at runtime (including the driver’s call), determine the index $i_{\\max}$ of the largest temporary $t_{i_{\\max}}$ created during the entire execution of the driver’s call up to the return from $f$. Your final answer must be a single number (no units, no explanation), representing $i_{\\max}$ exactly (no rounding).", "solution": "The problem statement is validated as scientifically grounded, well-posed, objective, and self-contained. It presents a standard problem in compiler theory concerning the generation and execution of three-address code for a recursive function. The provided rules for temporary creation and instruction execution are explicit and consistent, allowing for a unique, deterministic solution.\n\nFirst, we must translate the recursive factorial function $f(n)$ into the specified three-address code (TAC) format. The function is defined as:\nIf $n \\le 1$ then return $1$, else return $n \\times f(n-1)$.\n\nLet the single parameter passed to the function $f$ be denoted by the address `arg`. A canonical TAC representation for $f$ is as follows:\n\n`L_f_begin:`\n$t_a := \\text{arg} \\le 1$\n$\\text{if } t_a \\text{ goto } \\text{L_base}$\n$t_b := \\text{arg} - 1$\n$\\text{param } t_b$\n$t_c := \\text{call } f, 1$\n$t_d := \\text{arg} \\times t_c$\n$\\text{ret } t_d$\n$\\text{goto } \\text{L_end}$\n`L_base:`\n$\\text{ret } 1$\n`L_end:`\n\nHere, $t_a, t_b, t_c,$ and $t_d$ represent temporaries that are created dynamically. According to the problem's rules, each will receive a unique, globally increasing index $i$ in the sequence $t_1, t_2, \\dots$ at the moment its creating instruction is executed.\n\nThe task is to find the maximum index $i_{\\max}$ for a temporary created during the execution of $f(7)$, initiated by a driver. We must trace the dynamic execution sequence. Temporaries are created by four types of instructions in this trace:\n1. The driver's call: `t := call f, 1`\n2. The comparison: `t := arg = 1`\n3. The subtraction: `t := arg - 1`\n4. The multiplication: `t := arg * t_result`\n\nThe trace begins with the driver's execution for an input of $n=7$. Let $i$ be the global index for temporaries, initialized to $0$.\n\n1.  **Driver Execution:**\n    - `param 7` is executed.\n    - `t := call f, 1` is executed. This is the first instruction to create a temporary. The index $i$ becomes $1$. A temporary $t_1$ is created to hold the eventual return value of $f(7)$.\n    - Control passes to the function $f$ with its parameter `arg` set to $7$.\n\n2.  **Recursive Descent:** The execution proceeds down the recursive call chain.\n    - **In `f(7)`** (`arg = 7`):\n        - The condition `arg = 1` is evaluated. `t_2 := 7 = 1` is executed. $i$ becomes $2$.\n        - The branch is not taken.\n        - The argument for the next call is computed. `t_3 := 7 - 1` is executed. $i$ becomes $3$.\n        - `param t_3` is executed.\n        - The recursive call is made. `t_4 := call f, 1` is executed. $i$ becomes $4$. Control passes to `f(6)`.\n    - **In `f(6)`** (`arg = 6`):\n        - `t_5 := 6 = 1` is executed. $i$ becomes $5$.\n        - `t_6 := 6 - 1` is executed. $i$ becomes $6$.\n        - `t_7 := call f, 1` is executed. $i$ becomes $7$. Control passes to `f(5)`.\n    - **In `f(5)`** (`arg = 5`):\n        - `t_8 := 5 = 1` is executed. $i$ becomes $8$.\n        - `t_9 := 5 - 1` is executed. $i$ becomes $9$.\n        - `t_{10} := call f, 1` is executed. $i$ becomes $10$. Control passes to `f(4)`.\n    - **In `f(4)`** (`arg = 4`):\n        - `t_{11} := 4 = 1` is executed. $i$ becomes $11$.\n        - `t_{12} := 4 - 1` is executed. $i$ becomes $12$.\n        - `t_{13} := call f, 1` is executed. $i$ becomes $13$. Control passes to `f(3)`.\n    - **In `f(3)`** (`arg = 3`):\n        - `t_{14} := 3 = 1` is executed. $i$ becomes $14$.\n        - `t_{15} := 3 - 1` is executed. $i$ becomes $15$.\n        - `t_{16} := call f, 1` is executed. $i$ becomes $16$. Control passes to `f(2)`.\n    - **In `f(2)`** (`arg = 2`):\n        - `t_{17} := 2 = 1` is executed. $i$ becomes $17$.\n        - `t_{18} := 2 - 1` is executed. $i$ becomes $18$.\n        - `t_{19} := call f, 1` is executed. $i$ becomes $19$. Control passes to `f(1)`.\n\n3.  **Base Case:**\n    - **In `f(1)`** (`arg = 1`):\n        - The condition `arg = 1` is evaluated. `t_{20} := 1 = 1` is executed. The value of $i$ is now $20$.\n        - The conditional branch `if t_{20} goto L_base` is taken.\n        - `ret 1` is executed. This does not create a new temporary. The function returns the value $1$. The recursion begins to unwind.\n\n4.  **Recursive Ascent:** Control returns up the call stack.\n    - **Returning to `f(2)`:**\n        - The return value $1$ is assigned to the temporary `t_{19}`.\n        - The multiplication is performed. `t_{21} := 2 \\times t_{19}` is executed. The value of $i$ is now $21$.\n        - `ret t_{21}` is executed, returning the value $2$.\n    - **Returning to `f(3)`:**\n        - The return value $2$ is assigned to `t_{16}`.\n        - `t_{22} := 3 \\times t_{16}` is executed. The value of $i$ is now $22$.\n        - The function returns the value $6$.\n    - **Returning to `f(4)`:**\n        - The return value $6$ is assigned to `t_{13}`.\n        - `t_{23} := 4 \\times t_{13}` is executed. The value of $i$ is now $23$.\n        - The function returns the value $24$.\n    - **Returning to `f(5)`:**\n        - The return value $24$ is assigned to `t_{10}`.\n        - `t_{24} := 5 \\times t_{10}` is executed. The value of $i$ is now $24$.\n        - The function returns the value $120$.\n    - **Returning to `f(6)`:**\n        - The return value $120$ is assigned to `t_7`.\n        - `t_{25} := 6 \\times t_7` is executed. The value of $i$ is now $25$.\n        - The function returns the value $720$.\n    - **Returning to `f(7)`:**\n        - The return value $720$ is assigned to `t_4`.\n        - The final multiplication is performed. `t_{26} := 7 \\times t_4` is executed. The value of $i$ is now $26$.\n        - `ret t_{26}` is executed, returning the value $5040$.\n\n5.  **Final Return to Driver:**\n    - The return value $5040$ is assigned to the initial temporary `t_1`.\n    - The `halt` instruction is executed.\n\nThe last temporary created during this entire process is $t_{26}$. Therefore, the largest index $i_{\\max}$ is $26$.\n\nWe can generalize the count of temporaries created for an input $n > 1$:\n- $1$ temporary for the initial driver call.\n- For each recursive call from $f(n)$ down to $f(2)$ (a total of $n-1$ calls), $3$ temporaries are created on descent (`=`, `-`, `call`). Total: $3 \\times (n-1)$.\n- For the base case call $f(1)$, $1$ temporary is created (`=`).\n- For each return from $f(1)$ up to $f(n-1)$ (a total of $n-1$ returns), $1$ temporary is created for the multiplication. Total: $1 \\times (n-1)$.\nTotal temporaries for $n > 1$: $i_{\\max} = 1 + 3(n-1) + 1 + 1(n-1) = 2 + 4(n-1) = 4n - 2$.\nFor the given input $n=7$, this formula yields: $i_{\\max} = 4(7) - 2 = 28 - 2 = 26$. This confirms the result from the detailed trace.", "answer": "$$\\boxed{26}$$", "id": "3675465"}]}