{"hands_on_practices": [{"introduction": "When a program requires more variables than available registers, the compiler must \"spill\" some to memory, a costly operation. This practice dives into the heart of this decision-making process, using an interference graph model [@problem_id:3666504]. By comparing two different spill heuristics—one based on spill cost and another on graph degree—you'll see firsthand how the choice of strategy can lead to vastly different performance outcomes.", "problem": "Consider register allocation via interference graph coloring with $K$ available machine registers, where $K=3$. The interference graph is constructed by standard liveness analysis and has vertices representing live ranges $v_a$, $v_b$, $v_c$, $v_d$, $v_e$, $v_{x_1}$, $v_{x_2}$, $v_{x_3}$, $v_{y_1}$, $v_{y_2}$, and $v_{y_3}$. Adjacency is defined as follows:\n\n- The subgraph induced by $\\{v_a, v_b, v_c, v_d\\}$ is a complete graph $K_4$, i.e., each of $v_a$, $v_b$, $v_c$, and $v_d$ interferes with the other three.\n- The vertex $v_e$ interferes with $v_a$, $v_b$, $v_{x_1}$, $v_{x_2}$, $v_{x_3}$, $v_{y_1}$, $v_{y_2}$, and $v_{y_3}$.\n- The vertices $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ and $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ form a complete bipartite subgraph $K_{3,3}$: for all $i \\in \\{1,2,3\\}$ and $j \\in \\{1,2,3\\}$, $v_{x_i}$ interferes with $v_{y_j}$. There are no other interferences beyond those stated.\n\nAssume no precolored vertices, no coalescing, and no live range splitting. A spill incurs a scalar cost $c(v)$ that adds linearly to the total spill cost. The per-vertex spill costs are:\n$c(v_a)=7$, $c(v_b)=6$, $c(v_c)=5$, $c(v_d)=1$, $c(v_e)=9$, and $c(v_{x_1})=c(v_{x_2})=c(v_{x_3})=c(v_{y_1})=c(v_{y_2})=c(v_{y_3})=3$.\n\nUse the following two deterministic heuristics to choose spill candidates when no vertex has degree strictly less than $K$:\n\n- Heuristic $\\mathcal{H}_{\\text{cost}}$: choose the vertex with the smallest spill cost $c(v)$. Ties are broken alphabetically by the vertex name.\n- Heuristic $\\mathcal{H}_{\\text{degree}}$: choose the vertex of maximum degree in the current interference graph. Ties are broken alphabetically by the vertex name.\n\nAt each step, if any vertex has degree strictly less than $K$, that vertex may be simplified (pushed on the stack) rather than spilled; otherwise, a single vertex is spilled according to the heuristic, removed from the graph, and the process repeats. When the remaining graph becomes $K$-colorable, allocation proceeds without further spills. Ignore any runtime costs beyond $c(v)$ and assume that each spilled vertex contributes exactly its $c(v)$ once to the total.\n\nCompute, for the described graph and costs, the difference $\\Delta$ between the total spill cost obtained under $\\mathcal{H}_{\\text{degree}}$ and the total spill cost obtained under $\\mathcal{H}_{\\text{cost}}$, where\n$$\n\\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}).\n$$\nProvide your final answer as a single real-valued number. No rounding is required.", "solution": "The user wants me to solve a register allocation problem.\n\n### Step 1: Extract Givens\n-   **Number of Registers**: $K=3$.\n-   **Vertices**: The set of live ranges is $V = \\{v_a, v_b, v_c, v_d, v_e, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$.\n-   **Interference Graph Structure (Edges)**:\n    1.  The subgraph induced by $\\{v_a, v_b, v_c, v_d\\}$ is a complete graph $K_4$.\n    2.  $v_e$ interferes with (is adjacent to) $v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}$.\n    3.  The subgraph on $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ and $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ is a complete bipartite graph $K_{3,3}$.\n    4.  No other interferences are present.\n-   **Spill Costs**:\n    -   $c(v_a)=7$\n    -   $c(v_b)=6$\n    -   $c(v_c)=5$\n    -   $c(v_d)=1$\n    -   $c(v_e)=9$\n    -   $c(v_{x_1})=c(v_{x_2})=c(v_{x_3})=3$\n    -   $c(v_{y_1})=c(v_{y_2})=c(v_{y_3})=3$\n-   **Algorithm for Register Allocation**:\n    1.  If any vertex has a degree strictly less than $K$, it is simplified (pushed on a stack for coloring).\n    2.  If no vertex can be simplified, a single vertex is chosen as a spill candidate and removed from the graph. The selection is based on one of two heuristics.\n    3.  The process repeats.\n    4.  The process stops \"When the remaining graph becomes $K$-colorable\".\n    5.  Spilled vertices contribute their cost $c(v)$ to the total spill cost.\n-   **Spill Heuristics**:\n    -   $\\mathcal{H}_{\\text{cost}}$: Choose the vertex with the smallest spill cost $c(v)$. Ties are broken alphabetically.\n    -   $\\mathcal{H}_{\\text{degree}}$: Choose the vertex with the maximum degree. Ties are broken alphabetically.\n-   **Objective**: Compute the difference $\\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}})$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, rooted in the standard theory of register allocation in compilers. It is well-posed, with a fully specified interference graph, deterministic heuristics (due to tie-breaking rules), and a clear objective. The language is objective and precise. All necessary data are provided and there are no contradictions. The problem is valid.\n\n### Step 3: Proceed to Solution\n\nFirst, we must determine the initial state of the interference graph, specifically the degree of each vertex. The total number of available registers is $K=3$.\n-   $\\text{deg}(v_a)$: Neighbors are $\\{v_b, v_c, v_d\\}$ (from $K_4$) and $v_e$. So, $\\text{deg}(v_a) = 4$.\n-   $\\text{deg}(v_b)$: Neighbors are $\\{v_a, v_c, v_d\\}$ (from $K_4$) and $v_e$. So, $\\text{deg}(v_b) = 4$.\n-   $\\text{deg}(v_c)$: Neighbors are $\\{v_a, v_b, v_d\\}$ (from $K_4$). So, $\\text{deg}(v_c) = 3$.\n-   $\\text{deg}(v_d)$: Neighbors are $\\{v_a, v_b, v_c\\}$ (from $K_4$). So, $\\text{deg}(v_d) = 3$.\n-   $\\text{deg}(v_e)$: Neighbors are $\\{v_a, v_b, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$. So, $\\text{deg}(v_e) = 8$.\n-   $\\text{deg}(v_{x_i})$ for $i \\in \\{1,2,3\\}$: Neighbors are $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ (from $K_{3,3}$) and $v_e$. So, $\\text{deg}(v_{x_i}) = 4$.\n-   $\\text{deg}(v_{y_j})$ for $j \\in \\{1,2,3\\}$: Neighbors are $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ (from $K_{3,3}$) and $v_e$. So, $\\text{deg}(v_{y_j}) = 4$.\n\nThe problem states that spilling stops \"When the remaining graph becomes K-colorable.\" This implies a process where we iteratively simplify, and if we get stuck (the \"kernel\" of the graph has all degrees $\\ge K$), we check if this kernel is K-colorable. If it is, we stop. If not, we spill one node from the kernel and repeat the process on the new, smaller graph.\n\n**Analysis using Heuristic $\\mathcal{H}_{\\text{cost}}$**\n\n1.  **Initial Graph $G_0$**: All vertices have degree $\\ge K=3$. Thus, no vertices can be simplified. The kernel is the entire graph $G_0$.\n2.  **Colorability Check**: Is $G_0$ 3-colorable? No, it contains a $K_4$ subgraph on $\\{v_a, v_b, v_c, v_d\\}$, which requires at least 4 colors.\n3.  **Spill**: We must spill a vertex from $G_0$. Using $\\mathcal{H}_{\\text{cost}}$, we choose the vertex with the minimum spill cost.\n    -   Costs: $c(v_a)=7, c(v_b)=6, c(v_c)=5, c(v_d)=1, c(v_e)=9$, and $c(v_x, v_y)=3$.\n    -   The minimum cost is $c(v_d)=1$. We spill $v_d$.\n    -   **Total spill cost so far: $1$.**\n4.  **New Graph $G_1 = G_0 \\setminus \\{v_d\\}$**: We repeat the process on $G_1$.\n    -   **Simplify**: The degrees of $v_d$'s neighbors ($v_a, v_b, v_c$) decrease by 1.\n        -   $\\text{deg}_{G_1}(v_a)=3$, $\\text{deg}_{G_1}(v_b)=3$, $\\text{deg}_{G_1}(v_c)=2$.\n        -   Since $\\text{deg}_{G_1}(v_c) = 2 < 3$, we simplify $v_c$. Remove it and its edges.\n        -   In the new graph $G_1 \\setminus \\{v_c\\}$, the degrees of $v_c$'s neighbors ($v_a, v_b$) decrease by 1. Now $\\text{deg}(v_a)=2$ and $\\text{deg}(v_b)=2$.\n        -   We can simplify $v_a$ and $v_b$. Let's simplify $v_a$ (alphabetical).\n        -   In the remaining graph, $\\text{deg}(v_b)$ becomes $1$. We simplify $v_b$.\n    -   **Kernel**: After simplifying $v_c, v_a, v_b$, the remaining graph (the kernel) consists of the vertices $\\{v_e, v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$. Let's call this kernel $G'_{1}$. All vertices in $G'_{1}$ have degrees $\\ge 3$.\n    -   **Colorability Check**: Is $G'_{1}$ 3-colorable?\n        -   In $G'_{1}$, $v_e$ is connected to all other 6 vertices. The other 6 vertices form a $K_{3,3}$.\n        -   To 3-color $G'_{1}$, we can assign a color $C_1$ to $v_e$. Then all its neighbors must be colored with the remaining two colors, $C_2$ and $C_3$.\n        -   This is possible if and only if the subgraph induced by its neighbors is 2-colorable (bipartite).\n        -   The subgraph induced by $\\{v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$ is a $K_{3,3}$, which is bipartite. We can color $\\{v_{x_1}, v_{x_2}, v_{x_3}\\}$ with $C_2$ and $\\{v_{y_1}, v_{y_2}, v_{y_3}\\}$ with $C_3$.\n        -   Thus, $G'_{1}$ is 3-colorable.\n5.  **Stop**: Since the remaining kernel is 3-colorable, we stop spilling.\nThe total spill cost for $\\mathcal{H}_{\\text{cost}}$ is the cost of the single spilled vertex, $v_d$.\n$$ \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}) = c(v_d) = 1 $$\n\n**Analysis using Heuristic $\\mathcal{H}_{\\text{degree}}$**\n\n1.  **Initial Graph $G_0$**: As before, no vertices can be simplified. The kernel is $G_0$.\n2.  **Colorability Check**: As before, $G_0$ is not 3-colorable.\n3.  **Spill**: We must spill a vertex from $G_0$. Using $\\mathcal{H}_{\\text{degree}}$, we choose the vertex with maximum degree.\n    -   Degrees: $\\text{deg}(v_e)=8$ is the unique maximum. We spill $v_e$.\n    -   **Total spill cost so far: $9$.**\n4.  **New Graph $G_1 = G_0 \\setminus \\{v_e\\}$**: Repeat the process.\n    -   **Simplify**: The degrees of $v_e$'s neighbors decrease by 1.\n        -   $\\text{deg}_{G_1}(v_a)=3$, $\\text{deg}_{G_1}(v_b)=3$, $\\text{deg}_{G_1}(v_{x_i})=3$, $\\text{deg}_{G_1}(v_{y_j})=3$.\n        -   The degrees of $v_c$ and $v_d$ are unchanged: $\\text{deg}_{G_1}(v_c)=3$, $\\text{deg}_{G_1}(v_d)=3$.\n        -   All vertices in $G_1$ have degree 3. No vertex can be simplified. The kernel is $G_1$.\n    -   **Colorability Check**: Is $G_1$ 3-colorable? No, it still contains the $K_4$ subgraph on $\\{v_a, v_b, v_c, v_d\\}$.\n    -   **Spill**: We must spill a vertex from $G_1$. Using $\\mathcal{H}_{\\text{degree}}$, all vertices have degree 3. We break the tie alphabetically. The candidates are $\\{v_a, v_b, v_c, v_d, v_{x_1}, \\dots\\}$. The alphabetically first is $v_a$. We spill $v_a$.\n    -   **Total spill cost so far: $c(v_e) + c(v_a) = 9 + 7 = 16$.**\n5.  **New Graph $G_2 = G_1 \\setminus \\{v_a\\}$**: Repeat the process.\n    -   **Simplify**: After removing $v_a$, the degrees of its neighbors in $G_1$ ($v_b, v_c, v_d$) decrease.\n        -   In $G_2$, we now have $\\text{deg}(v_b)=2$, $\\text{deg}(v_c)=2$, $\\text{deg}(v_d)=2$. All these can be simplified.\n        -   The simplification of $\\{v_b, v_c, v_d\\}$ does not affect the degrees of the $\\{v_x, v_y\\}$ vertices, which remain at 3.\n    -   **Kernel**: After simplifying $v_b, v_c, v_d$, the remaining kernel is the subgraph on $\\{v_{x_1}, v_{x_2}, v_{x_3}, v_{y_1}, v_{y_2}, v_{y_3}\\}$, which is a $K_{3,3}$.\n    -   **Colorability Check**: Is the kernel ($K_{3,3}$) 3-colorable? Yes, it is 2-colorable, and therefore 3-colorable.\n6.  **Stop**: Since the remaining kernel is 3-colorable, we stop spilling.\nThe total spill cost for $\\mathcal{H}_{\\text{degree}}$ is the sum of costs for the spilled vertices $v_e$ and $v_a$.\n$$ \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) = c(v_e) + c(v_a) = 9 + 7 = 16 $$\n\n**Final Calculation**\n\nWe are asked to compute the difference $\\Delta$.\n$$ \\Delta = \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{degree}}) - \\text{total\\_spill\\_cost}(\\mathcal{H}_{\\text{cost}}) $$\n$$ \\Delta = 16 - 1 = 15 $$\nThe difference in total spill cost is $15$.", "answer": "$$\n\\boxed{15}\n$$", "id": "3666504"}, {"introduction": "An effective compiler not only allocates registers but also optimizes away redundant `move` instructions through a process called coalescing. This exercise explores a classic trade-off: can intentionally spilling a variable, which has an upfront cost, unlock enough coalescing opportunities to be worthwhile? You will apply the conservative coalescing rule to weigh these competing costs and find the optimal plan, revealing the subtle interplay between compiler optimizations [@problem_id:3666563].", "problem": "Consider a single straight-line basic block in a compiler’s register allocation phase with an interference graph abstraction. You have $k = 3$ allocatable general-purpose registers. The block has temporaries $a$, $b$, $c$, $d$, and $s$. The interference graph $G$ has vertex set $\\{a,b,c,d,s\\}$ and undirected edges\n$$(a,c),\\ (a,d),\\ (a,s),\\ (b,c),\\ (b,d),\\ (b,s),\\ (c,s),\\ (d,s).$$\nThere are exactly $2$ copy (move) instructions eligible for coalescing: a move $a \\rightarrow b$ and a move $c \\rightarrow d$. By construction, there is no interference edge between $a$ and $b$, and no interference edge between $c$ and $d$.\n\nThe allocator uses the following well-tested conservative copy coalescing rule due to Briggs: a move $x \\rightarrow y$ may be coalesced if and only if $x$ and $y$ do not interfere and, after hypothetically merging $x$ and $y$, the union of their neighbors whose degrees in $G$ are at least $k$ has cardinality strictly less than $k$. If the test fails, the move cannot be coalesced.\n\nAssume that choosing to spill a single temporary removes its node and all incident edges from the interference graph before running coalescing. You are allowed to consider only two plans:\n- Plan $A$: do not spill any temporary; attempt to coalesce moves under the conservative rule.\n- Plan $B$: spill the temporary $s$; then attempt to coalesce moves under the conservative rule.\n\nSpilling $s$ in this block induces the following normalized spill latency: $s$ has $1$ definition that must be stored and $2$ uses that must be reloaded, and each memory operation contributes a cost of $1$ in the same normalized units used to count residual moves. Thus, the spill latency is $spill\\_lat = 3$. If no spill is performed, $spill\\_lat = 0$.\n\nDefine the objective as\n$$\\text{cost} \\;=\\; spill\\_lat \\;+\\; moves,$$\nwhere $moves$ is the number of remaining move instructions after applying conservative coalescing under the chosen plan, and $spill\\_lat$ is as specified above. Compute the minimal achievable cost over the two plans, and report it as a single real-valued number. No rounding is required, and no physical units are used.", "solution": "The user wants me to solve a problem about register allocation.\n\n### Step 1: Extract Givens\n*   **Number of registers, `k`**: $k = 3$.\n*   **Temporaries (nodes in the graph)**: $V = \\{a,b,c,d,s\\}$.\n*   **Interference graph edges, `E`**:\n    *   $(a,c)$, $(a,d)$, $(a,s)$\n    *   $(b,c)$, $(b,d)$, $(b,s)$\n    *   $(c,s)$\n    *   $(d,s)$\n*   **Copy (move) instructions**: $a \\rightarrow b$ and $c \\rightarrow d$.\n*   **No interference edges due to moves**: $(a,b) \\notin E$ and $(c,d) \\notin E$.\n*   **Conservative Coalescing Rule (Briggs)**: A move $x \\rightarrow y$ is coalesced if:\n    1.  $(x,y) \\notin E$. (This is already given for our moves).\n    2.  Let $N(v)$ be the set of neighbors of a vertex $v$, and $\\text{deg}(v)$ be its degree.\n    3.  The condition is $|\\{v \\in N(x) \\cup N(y) \\mid \\text{deg}(v) \\ge k\\}| < k$.\n*   **Plan A**: No spill. Attempt coalescing.\n*   **Plan B**: Spill temporary $s$. Attempt coalescing.\n*   **Spill Latency**:\n    *   For Plan A: $spill\\_lat_A = 0$.\n    *   For Plan B (spilling $s$): $spill\\_lat_B = 1 \\text{ (store)} + 2 \\text{ (loads)} = 3$.\n*   **Cost Function**: $\\text{cost} = spill\\_lat + moves$, where `moves` is the number of remaining move instructions.\n*   **Goal**: Find the minimum cost between Plan A and Plan B.\n\n### Step 2: Validate Using Extracted Givens\n*   **Scientifically Grounded**: The problem is well-grounded in compiler theory, specifically register allocation using interference graphs and Briggs's conservative coalescing heuristic.\n*   **Well-Posed**: The problem is clearly defined with a specific graph, rules, and objective function, leading to a unique solvable answer.\n*   **Objective**: The language is formal and unambiguous.\n*   **Incomplete or Contradictory Setup**: The setup is complete and consistent. We can construct the graph and compute the degrees:\n    *   $\\text{deg}(a) = |\\{c, d, s\\}| = 3$\n    *   $\\text{deg}(b) = |\\{c, d, s\\}| = 3$\n    *   $\\text{deg}(c) = |\\{a, b, s\\}| = 3$\n    *   $\\deg(d) = |\\{a, b, s\\}| = 3$\n    *   $\\text{deg}(s) = |\\{a, b, c, d\\}| = 4$\n    The givens are internally consistent.\n*   **Other Flaws**: The problem is a standard, non-trivial application of a known algorithm, free from the other listed flaws.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution Derivation\n\nThe objective is to compute the minimal cost by comparing two strategies: Plan A (no spill) and Plan B (spill temporary $s$). The cost is defined as $\\text{cost} = spill\\_lat + moves$, where $moves$ is the number of move instructions remaining after attempting to coalesce.\n\n#### Analysis of Plan A: No Spill\n\nIn this plan, we use the initial interference graph $G$ with vertex set $V = \\{a,b,c,d,s\\}$ and the specified edges. The number of allocatable registers is $k = 3$. The spill latency for this plan is $spill\\_lat_A = 0$.\n\nFirst, we calculate the degree of each vertex in $G$:\n*   $\\text{deg}(a) = 3$\n*   $\\text{deg}(b) = 3$\n*   $\\text{deg}(c) = 3$\n*   $\\text{deg}(d) = 3$\n*   $\\text{deg}(s) = 4$\n\nA node is considered to have a \"significant degree\" if its degree is at least $k$. With $k=3$, all vertices $\\{a, b, c, d, s\\}$ have a significant degree.\n\nWe now apply the conservative coalescing rule to the two move instructions.\n\n**1. Consider the move $a \\rightarrow b$:**\nLet $x=a$ and $y=b$. The rule requires us to examine the neighbors of $x$ and $y$.\n*   Neighbors of $a$: $N(a) = \\{c, d, s\\}$.\n*   Neighbors of $b$: $N(b) = \\{c, d, s\\}$.\n*   The union of neighbors is $N(a) \\cup N(b) = \\{c, d, s\\}$.\n\nNext, we identify the subset of these neighbors with a degree of at least $k=3$:\n*   $\\text{deg}(c) = 3 \\ge 3$.\n*   $\\text{deg}(d) = 3 \\ge 3$.\n*   $\\text{deg}(s) = 4 \\ge 3$.\nAll neighbors in the union have a significant degree. The set of such neighbors is $\\{c, d, s\\}$. The cardinality of this set is $3$.\nThe coalescing condition is that this cardinality must be strictly less than $k$. Here, we check if $3 < 3$. This is false.\nTherefore, the move $a \\rightarrow b$ cannot be coalesced.\n\n**2. Consider the move $c \\rightarrow d$:**\nLet $x=c$ and $y=d$.\n*   Neighbors of $c$: $N(c) = \\{a, b, s\\}$.\n*   Neighbors of $d$: $N(d) = \\{a, b, s\\}$.\n*   The union of neighbors is $N(c) \\cup N(d) = \\{a, b, s\\}$.\n\nNext, we identify the subset of these neighbors with a degree of at least $k=3$:\n*   $\\text{deg}(a) = 3 \\ge 3$.\n*   $\\text{deg}(b) = 3 \\ge 3$.\n*   $\\text{deg}(s) = 4 \\ge 3$.\nThe set of significant-degree neighbors is $\\{a, b, s\\}$. The cardinality of this set is $3$.\nThe coalescing condition is $3 < 3$, which is false.\nTherefore, the move $c \\rightarrow d$ cannot be coalesced.\n\nUnder Plan A, neither of the two move instructions can be eliminated.\n*   Number of remaining moves: $moves_A = 2$.\n*   Spill latency: $spill\\_lat_A = 0$.\n*   Total cost for Plan A: $\\text{cost}_A = spill\\_lat_A + moves_A = 0 + 2 = 2$.\n\n#### Analysis of Plan B: Spill Temporary `s`\n\nIn this plan, we first spill temporary $s$. This entails a spill cost of $spill\\_lat_B = 3$. Spilling a temporary means removing its node and all incident edges from the interference graph. The new graph, $G'$, has the vertex set $V' = \\{a, b, c, d\\}$.\n\nThe edges incident to $s$, which are $(a,s), (b,s), (c,s), (d,s)$, are removed. The remaining edges in $G'$ are $E' = \\{(a,c), (a,d), (b,c), (b,d)\\}$.\n\nWe compute the degrees of the vertices in this new graph $G'$:\n*   $\\text{deg}_{G'}(a) = 2$\n*   $\\text{deg}_{G'}(b) = 2$\n*   $\\text{deg}_{G'}(c) = 2$\n*   $\\text{deg}_{G'}(d) = 2$\n\nWith $k=3$, no vertex in $G'$ has a significant degree, as all degrees are less than $3$.\n\nNow we apply the coalescing rule in the context of graph $G'$.\n\n**1. Consider the move $a \\rightarrow b$:**\nLet $x=a$ and $y=b$.\n*   Neighbors in $G'$: $N_{G'}(a) = \\{c, d\\}$ and $N_{G'}(b) = \\{c, d\\}$.\n*   Union of neighbors: $N_{G'}(a) \\cup N_{G'}(b) = \\{c, d\\}$.\n\nWe find the subset of these neighbors with degree $\\ge k=3$.\n*   $\\text{deg}_{G'}(c) = 2 < 3$.\n*   $\\text{deg}_{G'}(d) = 2 < 3$.\nThe set of significant-degree neighbors is empty, $\\emptyset$. Its cardinality is $0$.\nThe coalescing condition is $0 < 3$, which is true.\nTherefore, the move $a \\rightarrow b$ can be coalesced.\n\n**2. Consider the move $c \\rightarrow d$:**\nLet $x=c$ and $y=d$.\n*   Neighbors in $G'$: $N_{G'}(c) = \\{a, b\\}$ and $N_{G'}(d) = \\{a,b\\}$.\n*   Union of neighbors: $N_{G'}(c) \\cup N_{G'}(d) = \\{a, b\\}$.\n\nWe find the subset of these neighbors with degree $\\ge k=3$.\n*   $\\text{deg}_{G'}(a) = 2 < 3$.\n*   $\\text{deg}_{G'}(b) = 2 < 3$.\nThe set of significant-degree neighbors is empty, $\\emptyset$. Its cardinality is $0$.\nThe coalescing condition is $0 < 3$, which is true.\nTherefore, the move $c \\rightarrow d$ can be coalesced.\n\nUnder Plan B, both move instructions are successfully coalesced and eliminated. The order of coalescing does not matter as the two moves involve disjoint sets of temporaries.\n*   Number of remaining moves: $moves_B = 0$.\n*   Spill latency: $spill\\_lat_B = 3$.\n*   Total cost for Plan B: $\\text{cost}_B = spill\\_lat_B + moves_B = 3 + 0 = 3$.\n\n#### Conclusion\n\nWe compare the costs of the two plans to find the minimum.\n*   $\\text{cost}_A = 2$\n*   $\\text{cost}_B = 3$\n\nThe minimal achievable cost is $\\min(\\text{cost}_A, \\text{cost}_B) = \\min(2, 3) = 2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3666563"}, {"introduction": "In modern compilers, especially those using SSA form, register allocation can result in a set of simultaneous register-to-register moves known as a parallel copy. This practice challenges you to convert such a parallel copy into an optimal sequence of simple machine instructions [@problem_id:3661148]. You will learn to model the data flow as a permutation, decompose it into disjoint cycles, and use a temporary register to resolve cyclic dependencies with the minimum number of moves.", "problem": "A compiler backend must resolve a parallel copy arising during register allocation in Static Single Assignment (SSA) form. The semantics of a parallel copy are that all assignments happen simultaneously: for each assignment $d := s$ in the set, the post-copy value in destination register $d$ must equal the pre-copy value that was in source register $s$ before any assignment executes. The machine provides only simple move instructions of the form $x := y$, and no swap or rotate instructions. You are allowed to use a single temporary register per cycle to preserve values during resolution.\n\nConsider the machine registers $r_1, r_2, \\dots, r_{10}$ and the following parallel copy, specified as a set of destination–source assignments:\n- $r_1 := r_4$\n- $r_4 := r_1$\n- $r_2 := r_5$\n- $r_5 := r_7$\n- $r_7 := r_2$\n- $r_3 := r_9$\n- $r_9 := r_6$\n- $r_6 := r_3$\n- $r_8 := r_8$\n- $r_{10} := r_{10}$\n\nTasks:\n1. Starting from first principles of parallel copy semantics, argue why this set of assignments defines a permutation on registers with some fixed points, and decompose the permutation into disjoint cycles and fixed points.\n2. For each nontrivial cycle (of length greater than $1$), design an optimal sequential move sequence that uses exactly one temporary register for that cycle and preserves the parallel copy semantics. Justify the optimality of the number of moves for each cycle from fundamental reasoning.\n3. Compute the minimal total number of move instructions that your optimal scheme emits to realize the entire parallel copy. Your final submitted answer must be this single integer, expressed with no units and no rounding.", "solution": "The problem is deemed valid as it is scientifically grounded in compiler theory, well-posed, objective, and internally consistent.\n\nThe problem asks for an analysis of a parallel copy operation, its decomposition into a permutation, the design of an optimal move sequence for its constituent cycles, and the calculation of the total number of moves required.\n\n**1. Permutation Definition and Decomposition**\n\nA parallel copy is a set of assignments $\\{d_i := s_i\\}$ that are conceptually executed simultaneously. This means that for every assignment $d_i := s_i$, the value read from the source register $s_i$ is its value *before* any of the assignments take place.\n\nThis set of assignments can be modeled as a function $\\pi$ on the set of registers $R = \\{r_1, r_2, \\dots, r_{10}\\}$. For each assignment $d := s$, the function maps the source register $s$ to the destination register $d$, indicating that the value from $s$ moves to $d$. Thus, we define $\\pi(s) = d$.\n\nFor $\\pi$ to be a permutation, it must be a bijection (one-to-one and onto) on the set $R$. In the given problem, the set of destination registers is $\\{r_1, r_4, r_2, r_5, r_7, r_3, r_9, r_6, r_8, r_{10}\\}$, which is precisely the set $R$. Since each register in $R$ appears as a destination exactly once, the function $\\pi$ is a bijection on the finite set $R$, and is therefore a permutation.\n\nThe given assignments are:\n- $r_1 := r_4 \\implies \\pi(r_4) = r_1$\n- $r_4 := r_1 \\implies \\pi(r_1) = r_4$\n- $r_2 := r_5 \\implies \\pi(r_5) = r_2$\n- $r_5 := r_7 \\implies \\pi(r_7) = r_5$\n- $r_7 := r_2 \\implies \\pi(r_2) = r_7$\n- $r_3 := r_9 \\implies \\pi(r_9) = r_3$\n- $r_9 := r_6 \\implies \\pi(r_6) = r_9$\n- $r_6 := r_3 \\implies \\pi(r_3) = r_6$\n- $r_8 := r_8 \\implies \\pi(r_8) = r_8$\n- $r_{10} := r_{10} \\implies \\pi(r_{10}) = r_{10}$\n\nAny permutation on a finite set can be uniquely decomposed into a set of disjoint cycles. We can find these cycles by starting with an arbitrary element and repeatedly applying the permutation $\\pi$ until we return to the starting element.\n\n- Starting with $r_1$: $\\pi(r_1) = r_4$, and $\\pi(r_4) = r_1$. This forms the cycle $(r_1, r_4)$.\n- Starting with $r_2$ (which is not in the previous cycle): $\\pi(r_2) = r_7$, $\\pi(r_7) = r_5$, and $\\pi(r_5) = r_2$. This forms the cycle $(r_2, r_7, r_5)$.\n- Starting with $r_3$: $\\pi(r_3) = r_6$, $\\pi(r_6) = r_9$, and $\\pi(r_9) = r_3$. This forms the cycle $(r_3, r_6, r_9)$.\n- For $r_8$: $\\pi(r_8) = r_8$. This is a cycle of length $1$, also known as a fixed point: $(r_8)$.\n- For $r_{10}$: $\\pi(r_{10}) = r_{10}$. This is also a fixed point: $(r_{10})$.\n\nThe complete decomposition of the permutation into disjoint cycles and fixed points is: $(r_1, r_4)$, $(r_2, r_7, r_5)$, $(r_3, r_6, r_9)$, $(r_8)$, $(r_{10})$.\n\n**2. Optimal Move Sequence for a Cycle**\n\nA cycle of length $k=1$ (a fixed point) corresponds to an assignment of the form $r := r$. This is an identity operation and requires $0$ moves to execute, as the register's value does not change.\n\nA nontrivial cycle of length $k > 1$, say $(x_1, x_2, \\dots, x_k)$, corresponds to the set of parallel assignments:\n$x_2 := x_1$\n$x_3 := x_2$\n...\n$x_1 := x_k$\n\nTo execute these assignments sequentially using only simple moves of the form $d := s$, we face a problem of cyclic dependency. Every register in the cycle is both a source and a destination. For any move $x_{i+1} := x_i$ that we might execute, we overwrite the value in $x_{i+1}$, which is needed for the subsequent assignment $x_{i+2} := x_{i+1}$. Without a `swap` instruction, it is impossible to resolve this cycle with only $k$ moves, as there is no \"safe\" move to start with that doesn't destroy a needed value.\n\nTo break this cyclic dependency, we must use the available temporary register, let's call it $t$. We can save the value of one of the registers in $t$, which frees up that register to be overwritten. This allows us to resolve the rest of the assignments in a chain, and finally restore the saved value from $t$.\n\nAn optimal sequence of moves for a cycle $(x_1, x_2, \\dots, x_k)$ is as follows:\n1. Save the value of one register, say $x_k$, into the temporary register. This is $1$ move: $t := x_k$.\n2. Now, $x_k$ can be safely overwritten. We perform the chain of moves in reverse order of the cycle's data flow:\n   - $x_k := x_{k-1}$\n   - $x_{k-1} := x_{k-2}$\n   - ...\n   - $x_2 := x_1$\n   This sequence consists of $k-1$ moves.\n3. Finally, the value of $x_k$ (originally in $t$) must be moved to $x_1$. This is $1$ move: $x_1 := t$.\n\nThe total number of moves is $1 + (k-1) + 1 = k+1$.\nThis scheme is optimal. We need at least $k$ moves to change the values of $k$ registers. However, as argued, $k$ moves are insufficient due to the cyclic dependency. At least one extra move is required to break the cycle by saving a value. Therefore, $k+1$ is the minimal number of moves for a cycle of length $k > 1$.\n\nFor the given nontrivial cycles:\n- Cycle $(r_1, r_4)$: Length $k=2$. Requires $k+1 = 2+1 = 3$ moves. (e.g., $t := r_1$; $r_1 := r_4$; $r_4 := t$)\n- Cycle $(r_2, r_7, r_5)$: Length $k=3$. Requires $k+1 = 3+1 = 4$ moves. (e.g., $t := r_2$; $r_2 := r_5$; $r_5 := r_7$; $r_7 := t$)\n- Cycle $(r_3, r_6, r_9)$: Length $k=3$. Requires $k+1 = 3+1 = 4$ moves. (e.g., $t := r_3$; $r_3 := r_9$; $r_9 := r_6$; $r_6 := t$)\n\n**3. Minimal Total Number of Moves**\n\nThe total number of moves to realize the entire parallel copy is the sum of the moves required for each disjoint cycle. The resolution of one cycle does not affect the registers in another, so we can simply sum the costs.\n\n- Moves for cycle $(r_1, r_4)$ (length $k=2$): $3$\n- Moves for cycle $(r_2, r_7, r_5)$ (length $k=3$): $4$\n- Moves for cycle $(r_3, r_6, r_9)$ (length $k=3$): $4$\n- Moves for fixed point $(r_8)$ (length $k=1$): $0$\n- Moves for fixed point $(r_{10})$ (length $k=1$): $0$\n\nThe minimal total number of move instructions is the sum:\n$$ \\text{Total Moves} = 3 + 4 + 4 + 0 + 0 = 11 $$", "answer": "$$ \\boxed{11} $$", "id": "3661148"}]}