{"hands_on_practices": [{"introduction": "Efficiently accessing variables that are not in the current function's scope is a cornerstone of compiling block-structured languages. The \"display\" is a classic runtime mechanism that provides fast access to the activation records of all enclosing lexical scopes. This exercise challenges you to move from theory to practice by deriving the precise memory offset for a nonlocal variable based on its lexical depth and position, a fundamental task in compiler backend development. [@problem_id:3620063]", "problem": "You are designing code generation for a block-structured language with lexical scoping and displays. The implementation uses a display so that a nonlocal variable declared at lexical depth $l$ (where the outermost block has depth $0$ and deeper nested blocks have greater depth) is accessed by first loading the frame base address from the display entry $\\text{display}[l]$ and then adding a relative addressing offset $\\delta$ to form the effective address.\n\nAssume the following machine and runtime conventions:\n- Machine word size is $w$ bytes, with $w = 8$.\n- The display entry $\\text{display}[l]$ points to the base of the activation record for the currently active procedure at lexical depth $l$.\n- For a procedure at lexical depth $l$, the activation record begins with a control prefix whose size, measured in words, equals $2 + (l+1)$. These words consist of a saved return address ($1$ word), a dynamic link or caller state word ($1$ word), and a save area for the display entries that will be overwritten on entry ($l+1$ words). The locals area begins immediately after this control prefix.\n- Each scalar local variable occupies exactly $1$ word and is assigned a zero-based slot index $s \\in \\{0,1,2,\\dots\\}$ relative to the start of the locals area within its activation record.\n\nA currently executing procedure $Q$ at lexical depth $4$ needs to access the following nonlocal scalar variables, each identified by its declaring lexical depth $l$ and its slot index $s$ within its own activation record’s locals area:\n- Variable $a$: $l=0$, $s=5$.\n- Variable $b$: $l=1$, $s=3$.\n- Variable $c$: $l=2$, $s=9$.\n- Variable $d$: $l=0$, $s=2$.\n- Variable $e$: $l=3$, $s=1$.\n\nYour task:\n1. From first principles of the display mechanism and the given activation record layout, derive a general expression for the relative addressing offset $\\delta$ (in bytes) for a variable declared at lexical depth $l$ with slot index $s$, in terms of $w$, $l$, and $s$.\n2. Using the derived expression and the given $w$, compute $\\delta$ for each of $a$, $b$, $c$, $d$, and $e$.\n3. Let $S$ be the sum of these five offsets (i.e., $S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e$). Compute $S$ and express your final answer in bytes as an exact integer. No rounding is required.", "solution": "The problem requires the derivation of a general formula for the relative addressing offset $\\delta$ used to access a nonlocal variable in a block-structured language with a display, and then to use this formula to compute a sum of such offsets for a specific set of variables. The problem is well-posed and contains all necessary information.\n\nFirst, we will derive the general expression for the relative addressing offset $\\delta$ in bytes for a variable declared at lexical depth $l$ with slot index $s$. The access method is given by adding the offset $\\delta$ to the base address of the activation record, which is provided by the display entry $\\text{display}[l]$. Therefore, $\\delta$ represents the offset of the variable's storage location from the beginning of the activation record where it is declared.\n\nAn activation record for a procedure at lexical depth $l$ consists of two parts in sequence: a control prefix followed by a locals area. The total offset $\\delta$ is the sum of the size of the control prefix and the offset of the variable within the locals area.\n\nThe size of the control prefix for a procedure at lexical depth $l$ is specified as $2 + (l+1)$ words. Let's express this size in bytes. Given the machine word size $w$, the size of the control prefix, $P_{size}$, is:\n$$ P_{size} = (2 + (l+1)) \\times w = (l+3)w $$\n\nThe locals area begins immediately after the control prefix. A scalar local variable is assigned a zero-based slot index $s$ relative to the start of the locals area. Each such variable occupies exactly $1$ word. Therefore, the offset of a variable with slot index $s$ from the beginning of the locals area, $L_{offset}$, is:\n$$ L_{offset} = s \\times w $$\n\nThe total relative addressing offset $\\delta$ from the start of the activation record is the sum of the prefix size and the local offset:\n$$ \\delta(l, s) = P_{size} + L_{offset} = (l+3)w + sw $$\nFactoring out $w$, we obtain the general expression for $\\delta$:\n$$ \\delta(l, s) = (l + s + 3)w $$\nThis expression is in terms of the variable's lexical depth of declaration $l$, its slot index $s$, and the machine word size $w$.\n\nNext, we use this expression to compute $\\delta$ for each of the specified variables. The problem provides the word size as $w = 8$ bytes. Substituting this value into our derived formula gives:\n$$ \\delta(l, s) = (l + s + 3) \\times 8 $$\n\nWe now compute the offsets for each variable:\n- Variable $a$: $l=0$, $s=5$.\n  $$ \\delta_a = (0 + 5 + 3) \\times 8 = 8 \\times 8 = 64 \\text{ bytes} $$\n- Variable $b$: $l=1$, $s=3$.\n  $$ \\delta_b = (1 + 3 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ bytes} $$\n- Variable $c$: $l=2$, $s=9$.\n  $$ \\delta_c = (2 + 9 + 3) \\times 8 = 14 \\times 8 = 112 \\text{ bytes} $$\n- Variable $d$: $l=0$, $s=2$.\n  $$ \\delta_d = (0 + 2 + 3) \\times 8 = 5 \\times 8 = 40 \\text{ bytes} $$\n- Variable $e$: $l=3$, $s=1$.\n  $$ \\delta_e = (3 + 1 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ bytes} $$\n\nFinally, we compute the sum $S$ of these five offsets:\n$$ S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e $$\nSubstituting the computed values:\n$$ S = 64 + 56 + 112 + 40 + 56 $$\nPerforming the summation:\n$$ S = 328 \\text{ bytes} $$\nThe total sum of the offsets is $328$ bytes.", "answer": "$$\\boxed{328}$$", "id": "3620063"}, {"introduction": "Closures, which bundle a function with its lexical environment, are a powerful feature in modern programming languages. However, their behavior can be subtle, hinging on whether they capture a variable \"by reference\" (the memory location) or \"by value\" (a snapshot of the data). This practice problem explores the classic and often misunderstood scenario of creating closures within a loop, forcing you to reason about the observable outcomes under different capture semantics. [@problem_id:3620080] Mastering this distinction is crucial for writing correct and predictable code in many popular languages.", "problem": "You are given a small, lexically scoped, first-class function language with two alternative closure-capture semantics. The language is call-by-value, and let-bound names denote mutable locations. In a standard for-loop, the loop variable name denotes a single mutable location that is updated each iteration. The runtime implements proper closures, so any location captured by a closure persists after the defining function returns.\n\nConsider the function below, which constructs and returns a list of thunks (nullary closures) that read a nonlocal name, and then an application site that calls the returned closures after the loop and an intervening assignment:\n\nfunction makeF(n):\n    res = []\n    for i = 1 to n:\n        res.push( fun() { return i } )\n    i = 99\n    return res\n\nlet fs = makeF(3)\nprint fs[0](), fs[1](), fs[2]()\n\nAssume the following precise semantics and constraints:\n- Lexical scoping: the free variable $i$ in each thunk refers to the binding of $i$ in the activation of makeF that created the thunk (not to any caller’s environment).\n- Loop binding model: the name $i$ is bound, at loop entry, to a single mutable location, and each iteration assigns a new numeric value into that same location; the statement i = 99 after the loop writes into that same location.\n- Two closure-capture variants for the free variable $i$ in each thunk:\n  1) Capture-by-reference: the closure records a reference to the location denoted by $i$ in the defining environment; evaluating the thunk reads the then-current contents of that location.\n  2) Capture-by-value: the closure records a copy of the current numeric value of $i$ at thunk creation time; the thunk evaluates to that copied value.\n- The runtime performs escape-safe allocation for captured locations so that there are no dangling references when closures outlive their defining activation.\n\nNow consider also the following refactoring that introduces a fresh inner binding per iteration:\n\nfunction makeF_refactored(n):\n    res = []\n    for i = 1 to n:\n        let j = i\n        res.push( fun() { return j } )\n    i = 99\n    return res\n\nlet gs = makeF_refactored(3)\nprint gs[0](), gs[1](), gs[2]()\n\nQuestion: Which option correctly characterizes the observable outputs of the two programs under the two capture semantics, and explains the reason? Choose the single best answer.\n\nOptions:\n\nA) Under capture-by-reference, makeF prints $\\left(3, 3, 3\\right)$; under capture-by-value, makeF prints $\\left(1, 2, 3\\right)$. Under capture-by-reference, makeF_refactored prints $\\left(1, 2, 3\\right)$. Reason: capture-by-reference reads the final loop counter value, while the assignment $i = 99$ occurs after closures have already been created and does not affect them.\n\nB) Under capture-by-reference, makeF prints $\\left(99, 99, 99\\right)$; under capture-by-value, makeF prints $\\left(1, 2, 3\\right)$. Under capture-by-reference, makeF_refactored prints $\\left(1, 2, 3\\right)$. Reason: capture-by-reference shares the single location for $i$ (updated last to $99$), capture-by-value copies $1$, $2$, and $3$ at thunk creation, and introducing $j$ creates a fresh location per iteration that each thunk references.\n\nC) Under capture-by-reference, makeF prints $\\left(1, 2, 3\\right)$; under capture-by-value, makeF prints $\\left(1, 1, 1\\right)$. Under capture-by-reference, makeF_refactored prints $\\left(1, 2, 3\\right)$. Reason: capture-by-reference freezes the value at the time of closure creation for each iteration, while capture-by-value computes the value at call time from the first iteration.\n\nD) Under capture-by-reference, makeF prints $\\left(99, 99, 99\\right)$; under capture-by-value, makeF prints $\\left(3, 3, 3\\right)$. Under capture-by-reference, makeF_refactored prints $\\left(99, 99, 99\\right)$. Reason: capture-by-value records the final loop value at the end of the loop, and introducing $j$ does not change which location is referenced.\n\nE) Under capture-by-reference, makeF causes a dangling reference because $i$ is a local; under capture-by-value, both makeF and makeF_refactored print $\\left(1, 2, 3\\right)$. Reason: the loop variable $i$ resides on the stack and cannot be safely captured unless copied.", "solution": "The problem statement will first be validated for scientific soundness, completeness, and objectivity.\n\n**Step 1: Extract Givens**\n\nThe problem provides the following definitions, constraints, and code segments:\n\n-   **Language Semantics**:\n    -   Lexically scoped, first-class functions.\n    -   Call-by-value evaluation strategy.\n    -   `let`-bound names denote mutable locations.\n    -   Closures are proper and persist. The runtime performs escape-safe allocation, preventing dangling references.\n\n-   **Loop Semantics**:\n    -   In a `for` loop, the loop variable name (e.g., `$i$`) denotes a single mutable location that is updated in each iteration.\n\n-   **Closure Capture Variants**:\n    -   **Capture-by-reference**: The closure records a reference to the memory location of the free variable in its defining environment. When the closure is evaluated, it reads the value from that location at the time of the call.\n    -   **Capture-by-value**: The closure records a copy of the free variable's numeric value at the time the closure is created.\n\n-   **First Program (`makeF`)**:\n    ```\n    function makeF(n):\n        res = []\n        for i = 1 to n:\n            res.push( fun() { return i } )\n        i = 99\n        return res\n    ```\n    Executed as: `let fs = makeF(3)`, `print fs[0](), fs[1](), fs[2]()`.\n\n-   **Second Program (`makeF_refactored`)**:\n    ```\n    function makeF_refactored(n):\n        res = []\n        for i = 1 to n:\n            let j = i\n            res.push( fun() { return j } )\n        i = 99\n        return res\n    ```\n    Executed as: `let gs = makeF_refactored(3)`, `print gs[0](), gs[1](), gs[2]()`.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the validation criteria:\n\n-   **Scientifically Grounded**: The problem is firmly rooted in the principles of programming language theory and compiler design. Concepts such as lexical scoping, closures, capture-by-reference versus capture-by-value, and mutable state are fundamental and well-defined in computer science. The scenario is a classic example used to teach these concepts and is representative of behaviors in real-world languages (e.g., JavaScript's `var` vs. `let` in loops).\n-   **Well-Posed**: The problem is specified with high precision. It defines the semantics of loop variables (a single mutable location), `let` bindings (new mutable locations), and the two capture mechanisms. Given these rules, the behavior of both programs can be uniquely and logically determined.\n-   **Objective**: The language is formal and unambiguous. All terms have standard meanings within the domain of computer science.\n-   **Completeness and Consistency**: The problem is self-contained. It provides all necessary information, including the crucial detail that the loop variable `$i$` occupies a single location throughout the loop's execution and the fact that `let` creates a fresh location. It also explicitly preempts the potential for dangling-pointer issues by specifying \"escape-safe allocation.\" There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. It is a well-posed, scientifically grounded problem in programming language semantics. A rigorous derivation of the solution can now proceed.\n\n**Solution Derivation**\n\nWe will analyze the execution of both functions under the specified semantics. The call in both cases is with `$n = 3$`.\n\n**Case 1: `makeF` with Capture-by-Reference**\n\n1.  The function `$makeF$` is invoked with `$n=3$`. An empty list `$res$` is created.\n2.  The `for` loop begins. A single mutable location is allocated for the loop variable `$i$`. Let us denote this location as `$L_i$`.\n3.  **Iteration 1**: `$i` is set to `$1$`. The value in `$L_i$` is `$1$`. A thunk, `$T_0 = fun() \\{ return\\ i \\}$, is created. Under capture-by-reference, `$T_0$` captures a reference to the location of `$i$`, which is `$L_i$`.\n4.  **Iteration 2**: `$i` is set to `$2$`. The value in `$L_i$` is updated to `$2$`. A new thunk, `$T_1 = fun() \\{ return\\ i \\}$, is created. It also captures a reference to the same location, `$L_i$`.\n5.  **Iteration 3**: `$i` is set to `$3$`. The value in `$L_i$` is updated to `$3$`. A third thunk, `$T_2 = fun() \\{ return\\ i \\}$, is created, also capturing a reference to `$L_i$`.\n6.  The loop terminates. The list `$res$` now contains three thunks, `$T_0$, `$T_1$, and `$T_2$`. **Crucially, all three thunks hold a reference to the very same memory location `$L_i$`.**\n7.  The statement `$i = 99$` is executed. This writes the value `$99$` into the location denoted by `$i$`, which is `$L_i$`.\n8.  The function returns the list `$res$`, which is assigned to `$fs$`.\n9.  The print statement executes `$fs[0]()$`, `$fs[1]()$`, and `$fs[2]()$`.\n    -   `$fs[0]()$`: The thunk `$T_0$` is called. It reads the value from its captured location `$L_i$`. The current value in `$L_i$` is `$99$`. The result is `$99$`.\n    -   `$fs[1]()$`: The thunk `$T_1$` is called. It also reads from `$L_i$`. The result is `$99$`.\n    -   `$fs[2]()$`: The thunk `$T_2$` is called. It also reads from `$L_i$`. The result is `$99$`.\n10. The final output is `($99, 99, 99$)`.\n\n**Case 2: `makeF` with Capture-by-Value**\n\n1.  Steps $1-2$ are identical. A single location `$L_i$` is created for the loop variable.\n2.  **Iteration 1**: `$i` is `$1$`. A thunk `$T_0'$` is created. Under capture-by-value, `$T_0'` captures a *copy* of the current value of `$i$`. The value `$1$` is stored within the closure for `$T_0'$`.\n3.  **Iteration 2**: `$i$` is `$2$`. A thunk `$T_1'` is created, capturing the value `$2$`.\n4.  **Iteration 3**: `$i$` is `$3$`. A thunk `$T_2'` is created, capturing the value `$3$`.\n5.  The loop terminates. The list `$res$` contains `$T_0'$, `$T_1'$, and `$T_2'$`.\n6.  The statement `$i = 99$` updates the location `$L_i$`, but this has no effect on the values already copied into the thunks.\n7.  The function returns `$res$`. Upon execution:\n    -   `$fs[0]()$` returns its captured value, `$1$`.\n    -   `$fs[1]()$` returns its captured value, `$2$`.\n    -   `$fs[2]()$` returns its captured value, `$3$`.\n8.  The final output is `($1, 2, 3$)`.\n\n**Case 3: `makeF_refactored` with Capture-by-Reference**\n\n1.  The function `$makeF\\_refactored$` is invoked with `$n=3$`. An empty list `$res$` is created.\n2.  The `for` loop begins, with a single shared location `$L_i$` for the loop variable.\n3.  **Iteration 1**: `$i$` is `$1$`. The statement `let j = i` is executed. Since this `let` is inside the loop body, a **new mutable location is created for `$j$` in each iteration**. Let's call this location `$L_{j,1}$`. The value of `$i$` (`$1$`) is copied into `$L_{j,1}$`. The thunk `$G_0 = fun() \\{ return\\ j \\}$` is created. Its free variable is `$j$`. It captures by reference the location of this iteration's `$j$`, which is `$L_{j,1}$`.\n4.  **Iteration 2**: `$i$` is updated to `$2$` in `$L_i$`. The statement `let j = i` is executed again. A **new, distinct mutable location** `$L_{j,2}$` is created. The value `$2$` is copied into `$L_{j,2}$`. The thunk `$G_1$` is created and captures a reference to `$L_{j,2}$`.\n5.  **Iteration 3**: `$i$` is updated to `$3$` in `$L_i$`. A third location `$L_{j,3}$` is created for `$j$`, holding the value `$3$`. The thunk `$G_2$` is created and captures a reference to `$L_{j,3}$`.\n6.  The loop terminates. The list `$res$` contains `$G_0$, `$G_1$, and `$G_2$`, which reference three distinct locations `$L_{j,1}$, `$L_{j,2}$, and `$L_{j,3}$`, respectively.\n7.  The statement `$i = 99$` updates the location `$L_i$`. This does not affect any of the `$L_j$` locations.\n8.  The function returns `$res$`, which is assigned to `$gs$`.\n9.  The print statement executes `$gs[0]()$`, `$gs[1]()$`, and `$gs[2]()$`.\n    -   `$gs[0]()$`: Reads from its captured location `$L_{j,1}$`, returning `$1$`.\n    -   `$gs[1]()$`: Reads from its captured location `$L_{j,2}$`, returning `$2$`.\n    -   `$gs[2]()$`: Reads from its captured location `$L_{j,3}$`, returning `$3$`.\n10. The final output is `($1, 2, 3$)`.\n\n**Summary of Derived Outputs:**\n-   `$makeF$` with capture-by-reference: `($99, 99, 99$)`\n-   `$makeF$` with capture-by-value: `($1, 2, 3$)`\n-   `$makeF\\_refactored$` with capture-by-reference: `($1, 2, 3$)`\n\n**Option-by-Option Analysis**\n\n-   **A)** \"Under capture-by-reference, makeF prints $\\left(3, 3, 3\\right)$...\" This is incorrect. It ignores the statement `$i = 99$`, which updates the single shared location for `$i$` from `$3$` to `$99$` after the loop but before the thunks are called. \"Under capture-by-value, makeF prints $\\left(1, 2, 3\\right)$.\" This part is correct. \"Under capture-by-reference, makeF_refactored prints $\\left(1, 2, 3\\right)$.\" This part is also correct. However, because the first claim and the reasoning are flawed, the option as a whole is invalid.\n    **Verdict: Incorrect.**\n\n-   **B)** \"Under capture-by-reference, makeF prints $\\left(99, 99, 99\\right)$...\" This matches our derivation. \"...under capture-by-value, makeF prints $\\left(1, 2, 3\\right)$.\" This also matches our derivation. \"Under capture-by-reference, makeF_refactored prints $\\left(1, 2, 3\\right)$.\" This also matches. The reason given is: \"capture-by-reference shares the single location for $i$ (updated last to $99$),\" which correctly explains the first result. \"...capture-by-value copies $1$, $2$, and $3$ at thunk creation,\" which correctly explains the second result. \"...and introducing $j$ creates a fresh location per iteration that each thunk references,\" which correctly explains the third result. All parts of this option are consistent with our rigorous derivation.\n    **Verdict: Correct.**\n\n-   **C)** \"Under capture-by-reference, makeF prints $\\left(1, 2, 3\\right)$...\" This is incorrect. It confuses capture-by-reference with capture-by-value in the context of the refactored function. \"...under capture-by-value, makeF prints $\\left(1, 1, 1\\right)$.\" This is also incorrect. The value of `$i$` changes in each iteration, and capture-by-value captures the value at the time of creation.\n    **Verdict: Incorrect.**\n\n-   **D)** \"Under capture-by-reference, makeF prints $\\left(99, 99, 99\\right)$...\" This is correct. \"...under capture-by-value, makeF prints $\\left(3, 3, 3\\right)$.\" This is incorrect. It wrongly assumes the value is only captured after the loop finishes. \"...under capture-by-reference, makeF_refactored prints $\\left(99, 99, 99\\right)$.\" This is incorrect. It fails to recognize that `let j` creates a fresh binding per iteration, thus isolating the captured locations from each other and from the final update to `$i$`.\n    **Verdict: Incorrect.**\n\n-   **E)** \"...makeF causes a dangling reference...\" This statement is in direct contradiction to a premise of the problem: \"The runtime performs escape-safe allocation for captured locations so that there are no dangling references\". Therefore, this option is based on a false premise.\n    **Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "3620080"}, {"introduction": "While closures are powerful, they can introduce significant memory overhead if implemented naively by capturing the entire environment of their defining function. A smarter compiler will perform \"environment slicing\" to include only the variables a closure actually needs. This hands-on calculation demonstrates the practical impact of this optimization, asking you to quantify the memory savings achieved. [@problem_id:3620073] By working through this, you will gain a concrete appreciation for how compiler optimizations can lead to more efficient programs.", "problem": "A compiler implements first-class closures under lexical scoping, where a closure consists of code plus an environment record containing bindings for nonlocal names needed by the code. Two environment-capture strategies are considered: full capture and environment slicing. In full capture, each escaping closure created within an activation of a function captures the entire lexical frame of that function. In environment slicing, a closure captures only the minimal set of bindings required to evaluate its body and any nested closures it produces that escape.\n\nUse the following fundamental base to formalize environment slicing: let $FV(C)$ denote the set of free variables of closure $C$ under lexical scoping. The minimal binding set for a closure $C$ is defined to be $B(C) = FV(C)$ when $C$ does not create any escaping closures; more generally, if $C$ creates escaping closures $D_{1}, \\dots, D_{k}$, then $B(C) = FV(C) \\cup \\bigcup_{i=1}^{k} B(D_{i})$. Assume call-by-value evaluation and that all variables listed below are immutable scalars or aggregates captured by value, with sizes given in bytes. Assume each escaping closure allocates its own environment record; no sharing or inter-closure factoring is performed.\n\nConsider a program with a single activation of a function $F$ that defines the following local variables with byte sizes: $x$ ($8$), $y$ ($4$), $z$ ($24$), $u$ ($8$), $v$ ($4$), $w$ ($40$), and $t$ ($12$). Within this activation, three escaping closures are created, $C_{1}$, $C_{2}$, and $C_{3}$, with free-variable sets:\n- $FV(C_{1}) = \\{x, z, t\\}$,\n- $FV(C_{2}) = \\{y, w\\}$,\n- $FV(C_{3}) = \\{x, u, v, w\\}$.\n\nThere are no additional nested escaping closures beyond $C_{1}$, $C_{2}$, and $C_{3}$, and these closures do not create further escaping closures. Under full capture, each closure’s environment contains all locals of $F$. Under environment slicing, each closure’s environment contains exactly the bindings from its minimal set $B(C_{i})$.\n\nCompute the total environment memory allocated under full capture for the three closures and the total under environment slicing, and then report the size reduction $\\Delta S$ in bytes as the difference between these totals. Express the final answer as an exact integer in bytes. No rounding is required.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Compiler model**: First-class closures under lexical scoping. A closure consists of code and an environment record.\n- **Environment Capture Strategies**:\n    1.  **Full Capture**: The environment record for an escaping closure contains the entire lexical frame of its defining function.\n    2.  **Environment Slicing**: The environment record for a closure $C$ captures a minimal binding set $B(C)$.\n- **Definition of Minimal Binding Set $B(C)$**:\n    - If $C$ creates no escaping closures, $B(C) = FV(C)$, where $FV(C)$ is the set of free variables of $C$.\n    - If $C$ creates escaping closures $D_1, \\dots, D_k$, then $B(C) = FV(C) \\cup \\bigcup_{i=1}^{k} B(D_{i})$.\n- **Assumptions**: Call-by-value evaluation; immutable variables captured by value; each escaping closure allocates its own environment record (no sharing).\n- **Function Context**: A single activation of a function $F$.\n- **Local Variables of $F$ and their sizes in bytes**:\n    - $x$: $8$ bytes\n    - $y$: $4$ bytes\n    - $z$: $24$ bytes\n    - $u$: $8$ bytes\n    - $v$: $4$ bytes\n    - $w$: $40$ bytes\n    - $t$: $12$ bytes\n- **Escaping Closures**: Three closures, $C_1$, $C_2$, and $C_3$, are created within $F$.\n- **Free Variable Sets**:\n    - $FV(C_1) = \\{x, z, t\\}$\n    - $FV(C_2) = \\{y, w\\}$\n    - $FV(C_3) = \\{x, u, v, w\\}$\n- **Nesting Condition**: The closures $C_1$, $C_2$, and $C_3$ do not create any further escaping closures.\n- **Task**: Compute the total environment memory for full capture, the total for environment slicing, and find the difference $\\Delta S$ (reduction in size).\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of compiler design and programming language theory. The concepts of lexical scoping, closures, and environment capture strategies are standard and well-established. The problem is well-posed, providing all necessary definitions, data, and constraints to arrive at a unique, calculable solution. The language is objective and precise. The simplifying assumption that the specified closures do not create further nested closures is a valid constraint that makes the problem tractable and does not introduce a contradiction. No scientific or factual unsoundness, incompleteness, or ambiguity is present.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be derived.\n\nThe solution proceeds by first calculating the total memory allocated for environments under the full capture strategy, then under the environment slicing strategy, and finally computing the difference. Let $S_{var}(v)$ denote the size of a variable $v$ in bytes. The given sizes are:\n$S_{var}(x) = 8$\n$S_{var}(y) = 4$\n$S_{var}(z) = 24$\n$S_{var}(u) = 8$\n$S_{var}(v) = 4$\n$S_{var}(w) = 40$\n$S_{var}(t) = 12$\n\n**1. Total Memory under Full Capture ($S_{full}$)**\n\nUnder the full capture strategy, each of the three closures ($C_1$, $C_2$, and $C_3$) captures the entire lexical frame of function $F$. The lexical frame of $F$ consists of all its local variables: $\\{x, y, z, u, v, w, t\\}$.\nThe size of this entire frame, denoted $S_{frame}$, is the sum of the sizes of all its variables:\n$$S_{frame} = S_{var}(x) + S_{var}(y) + S_{var}(z) + S_{var}(u) + S_{var}(v) + S_{var}(w) + S_{var}(t)$$\n$$S_{frame} = 8 + 4 + 24 + 8 + 4 + 40 + 12 = 100 \\text{ bytes}$$\nSince three separate closures are created and each allocates its own environment of this size, the total memory allocated under full capture, $S_{full}$, is:\n$$S_{full} = 3 \\times S_{frame} = 3 \\times 100 = 300 \\text{ bytes}$$\n\n**2. Total Memory under Environment Slicing ($S_{slice}$)**\n\nUnder the environment slicing strategy, each closure captures only its minimal binding set, $B(C_i)$. The problem states that the closures $C_1$, $C_2$, and $C_3$ do not create any further escaping closures. This simplifies the general definition of the minimal binding set. For any such closure $C_i$, the set of nested escaping closures $\\{D_j\\}$ is empty. Therefore, for each of $C_1$, $C_2$, and $C_3$, the minimal binding set is identical to its set of free variables:\n$$B(C_i) = FV(C_i)$$\nThe size of the environment for each closure, $S_{env}(C_i)$, is the sum of the sizes of the variables in its minimal binding set.\n\nFor closure $C_1$:\n$B(C_1) = FV(C_1) = \\{x, z, t\\}$\n$$S_{env}(C_1) = S_{var}(x) + S_{var}(z) + S_{var}(t) = 8 + 24 + 12 = 44 \\text{ bytes}$$\n\nFor closure $C_2$:\n$B(C_2) = FV(C_2) = \\{y, w\\}$\n$$S_{env}(C_2) = S_{var}(y) + S_{var}(w) = 4 + 40 = 44 \\text{ bytes}$$\n\nFor closure $C_3$:\n$B(C_3) = FV(C_3) = \\{x, u, v, w\\}$\n$$S_{env}(C_3) = S_{var}(x) + S_{var}(u) + S_{var}(v) + S_{var}(w) = 8 + 8 + 4 + 40 = 60 \\text{ bytes}$$\n\nThe total memory allocated under environment slicing, $S_{slice}$, is the sum of the sizes of the individual environments:\n$$S_{slice} = S_{env}(C_1) + S_{env}(C_2) + S_{env}(C_3)$$\n$$S_{slice} = 44 + 44 + 60 = 148 \\text{ bytes}$$\n\n**3. Memory Size Reduction ($\\Delta S$)**\n\nThe size reduction, $\\Delta S$, is the difference between the total memory allocated under full capture and the total memory allocated under environment slicing.\n$$\\Delta S = S_{full} - S_{slice}$$\n$$\\Delta S = 300 - 148 = 152 \\text{ bytes}$$\nThe reduction in memory usage achieved by using environment slicing instead of full capture for these three closures is $152$ bytes.", "answer": "$$\\boxed{152}$$", "id": "3620073"}]}