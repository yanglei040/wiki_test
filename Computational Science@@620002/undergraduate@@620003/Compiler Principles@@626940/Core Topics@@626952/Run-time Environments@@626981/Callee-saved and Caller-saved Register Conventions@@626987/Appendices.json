{"hands_on_practices": [{"introduction": "To truly grasp the trade-off between caller-saved and callee-saved conventions, it's essential to quantify the costs involved. This practice problem [@problem_id:3626228] presents a hypothetical scenario with two mutually recursive functions, where you must decide the convention for each register individually to minimize the total execution overhead. It challenges you to apply the core definitions to a dynamic execution trace, transforming an abstract concept into a concrete optimization puzzle.", "problem": "Two mutually recursive functions $A$ and $B$ execute under a custom Application Binary Interface (ABI) where the calling convention (assignment of registers as callee-saved versus caller-saved) may be chosen per register. The architecture provides a uniform cost model: each save or restore of a register to the stack costs $\\sigma$ cycles, with $\\sigma = 5$ cycles. Every save is paired with a corresponding restore, so a save-restore pair costs $2\\sigma$ cycles. Assume no optimization eliminates redundant saves or restores, and that all saves and restores required by the chosen convention are performed.\n\nThere is a finite run in which the dynamic counts are measured as follows: the number of entries into $A$ is $N_A = 310$, the number of entries into $B$ is $N_B = 300$, the number of calls from $A$ to $B$ is $C_{AB} = 300$, and the number of calls from $B$ to $A$ is $C_{BA} = 300$. The sets of registers that are live across calls (and also used within the functions) are $L_A = \\{r_1, r_2, r_5\\}$ for function $A$, and $L_B = \\{r_2, r_3, r_5\\}$ for function $B$. The universe of general-purpose registers of interest is $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$, but only the union $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ appears in the live sets during this run.\n\nBy the foundational definitions of calling conventions:\n- If a register $r$ is designated callee-saved and a function $F$ uses $r$, then on each entry to $F$ the function must save $r$ and, on exit, restore $r$, incurring $2\\sigma$ cycles per entry to $F$.\n- If a register $r$ is designated caller-saved and is live in the caller at a call site, the caller must save $r$ before the call and restore $r$ after the call, incurring $2\\sigma$ cycles per such call.\n\nYou may assign, independently for each register in $U$, whether it is callee-saved or caller-saved. Under these rules and the given dynamic counts, determine the minimal possible total dynamic save/restore overhead across the entire run, expressed in cycles. Provide a single numerical answer; no rounding is required. Express the final answer in cycles.", "solution": "The user wants me to solve the problem by following these steps:\n1.  **Extract Givens**: I will list all provided data, variables, constants, and conditions.\n2.  **Validate**: I will check the problem for scientific soundness, self-consistency, and well-posedness.\n3.  **Solve**: If valid, I will provide a step-by-step solution.\n\n### Step 1: Extract Givens\n- Cost of a single register save or restore operation: $\\sigma = 5$ cycles.\n- Cost of a save-restore pair: $2\\sigma = 10$ cycles.\n- Number of entries into function $A$: $N_A = 310$.\n- Number of entries into function $B$: $N_B = 300$.\n- Number of calls from $A$ to $B$: $C_{AB} = 300$.\n- Number of calls from $B$ to $A$: $C_{BA} = 300$.\n- Set of registers live across calls in function $A$: $L_A = \\{r_1, r_2, r_5\\}$.\n- Set of registers live across calls in function $B$: $L_B = \\{r_2, r_3, r_5\\}$.\n- Universe of registers of interest: $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is grounded in the principles of computer architecture and compiler design, specifically regarding calling conventions and register allocation. The concepts of callee-saved and caller-saved registers, function call overhead, and liveness analysis are standard and well-defined.\n- **Well-Posedness**: The problem asks for the minimum possible overhead, which is a well-defined optimization problem. The rules for calculating overhead are explicit and unambiguous. The provided data is sufficient to calculate the costs for each possible register convention assignment.\n- **Consistency**: The dynamic counts are consistent. The $N_A = 310$ entries into function $A$ and $C_{BA} = 300$ calls from $B$ to $A$ imply that there were $N_A - C_{BA} = 310 - 300 = 10$ initial entries into $A$ from an external context. The $N_B = 300$ entries into function $B$ and $C_{AB} = 300$ calls from $A$ to $B$ imply that all entries into $B$ originated from $A$. This describes a valid execution trace.\n- **Objectivity**: The problem is stated using objective, quantitative data and formal definitions.\n\nThe problem is valid.\n\n### Step 3: Solution\nThe objective is to determine a calling convention for each register in the set $U = \\{r_1, r_2, r_3, r_5\\}$ that minimizes the total dynamic save/restore overhead. The choice for each register (callee-saved vs. caller-saved) is independent. Therefore, we can minimize the overhead for each register individually and sum the results to find the total minimum overhead.\n\nFor any register $r$, we must compare the cost of designating it as callee-saved versus caller-saved. The cost for a save-restore pair is $2\\sigma = 2 \\times 5 = 10$ cycles.\n\n**Cost of Callee-Saved Convention**\nIf a register $r$ is designated callee-saved, the callee function must save it upon entry and restore it upon exit if the function itself uses the register. The problem states that a function $F$ \"uses\" a register $r$ if $r$ is in its live set $L_F$.\nThe total cost for a callee-saved register $r$ is the sum of costs for each function that uses it.\n- If function $A$ uses $r$ (i.e., $r \\in L_A$), the cost incurred is $N_A \\times 2\\sigma$, as $A$ is entered $N_A$ times.\n- If function $B$ uses $r$ (i.e., $r \\in L_B$), the cost incurred is $N_B \\times 2\\sigma$, as $B$ is entered $N_B$ times.\n\nThe total cost for a callee-saved register $r$ is:\n$$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$$\nwhere $\\mathbb{I}(\\cdot)$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise.\n\n**Cost of Caller-Saved Convention**\nIf a register $r$ is designated caller-saved, the caller function must save it before a call and restore it after the call, if the register's value is live in the caller.\n- Function $A$ makes $C_{AB}$ calls to $B$. If $r$ is live in $A$ (i.e., $r \\in L_A$), a save/restore is needed for each of these calls. The cost is $C_{AB} \\times 2\\sigma$.\n- Function $B$ makes $C_{BA}$ calls to $A$. If $r$ is live in $B$ (i.e., $r \\in L_B$), a save/restore is needed for each of these calls. The cost is $C_{BA} \\times 2\\sigma$.\n\nThe total cost for a caller-saved register $r$ is:\n$$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$$\n\nNow, we calculate the minimum cost for each register in $U$.\n\n**For register $r_1$:**\n$r_1 \\in L_A$ and $r_1 \\notin L_B$.\n- $Cost_{callee}(r_1) = 2\\sigma \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ cycles.\n- $Cost_{caller}(r_1) = 2\\sigma \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_1$ is $\\min(3100, 3000) = 3000$ cycles. This is achieved by making $r_1$ caller-saved.\n\n**For register $r_2$:**\n$r_2 \\in L_A$ and $r_2 \\in L_B$.\n- $Cost_{callee}(r_2) = 2\\sigma \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 10 \\times 610 = 6100$ cycles.\n- $Cost_{caller}(r_2) = 2\\sigma \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 10 \\times 600 = 6000$ cycles.\nThe minimum cost for $r_2$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_2$ caller-saved.\n\n**For register $r_3$:**\n$r_3 \\notin L_A$ and $r_3 \\in L_B$.\n- $Cost_{callee}(r_3) = 2\\sigma \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ cycles.\n- $Cost_{caller}(r_3) = 2\\sigma \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ cycles.\nThe minimum cost for $r_3$ is $\\min(3000, 3000) = 3000$ cycles. The cost is the same for either convention.\n\n**For register $r_5$:**\n$r_5 \\in L_A$ and $r_5 \\in L_B$. This case is identical to $r_2$.\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ cycles.\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ cycles.\nThe minimum cost for $r_5$ is $\\min(6100, 6000) = 6000$ cycles. This is achieved by making $r_5$ caller-saved.\n\n**Total Minimal Overhead**\nThe total minimal overhead is the sum of the minimum costs for each register in $U$. Registers outside of $U$ (i.e., $r_4$ and $r_6$) are not live across any calls in $A$ or $B$, so they incur no save/restore overhead.\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\nThe minimal possible total dynamic save/restore overhead across the entire run is $18000$ cycles.", "answer": "$$\\boxed{18000}$$", "id": "3626228"}, {"introduction": "While analyzing a specific execution trace is useful, compiler designers often make decisions based on general program characteristics. This exercise [@problem_id:3626283] asks you to step into the role of an Application Binary Interface (ABI) designer and create a mathematical model to find the \"break-even\" point for choosing a caller-saved convention. By considering the probability of calling a leaf function (one that makes no further calls), you will derive an analytical expression that captures the essence of this performance trade-off.", "problem": "A compiler back end must choose a calling convention for a set of $n$ allocatable General-Purpose Registers (GPRs). Under a caller-saved convention, the caller must save and later reload any values live across a call that reside in these $n$ registers, because the callee may clobber them. Under a callee-saved convention, the callee must preserve the contents of these $n$ registers across its execution (by saving in its prologue and restoring in its epilogue) if it uses them. Consider an Application Binary Interface (ABI) design decision in which calls in the program are to leaf functions with probability $p$ and to non-leaf functions with probability $1-p$, where a leaf function is one that makes no further calls.\n\nAssume the following simplified and scientifically defensible model:\n- At a call site, the caller has an average live-across-call set of size $\\ell$ values. Only live values that currently reside in the $n$ registers under consideration can be at risk from clobbering; values beyond $n$ are already placed in memory and therefore do not incur additional saves due to the convention. Each save and each reload counts as one memory operation.\n- Under the caller-saved convention, the caller saves before the call and reloads after the call each of the $\\min(\\ell,n)$ live values occupying these $n$ registers, resulting in $2\\min(\\ell,n)$ memory operations per call.\n- Under the callee-saved convention, a leaf callee can be compiled to use $0$ of these $n$ registers (it can confine its temporaries to caller-saved resources), incurring $0$ saves and $0$ reloads. A non-leaf callee eventually uses all $n$ of these registers during its execution, causing it to save and reload all $n$, for a total of $2n$ memory operations. Thus the expected per-call memory operations under callee-saved are $2\\big(p\\cdot 0 + (1-p)\\cdot n\\big) = 2(1-p)n$.\n\nUsing these assumptions and the linearity of expectation, derive the exact threshold $p^{*}$ as a closed-form analytic expression in terms of $n$ and $\\ell$ such that for $p < p^{*}$, the caller-saved convention has strictly lower expected spill-reload cost than the callee-saved convention. Provide the expression for $p^{*}$ only; do not compute any numerical value, and do not round. Your final answer must be a single analytic expression for $p^{*}$.", "solution": "The core comparison is between the expected spill-reload cost per call under the caller-saved convention and the expected spill-reload cost per call under the callee-saved convention.\n\nBy definition of caller-saved, any live-across-call value residing in the designated $n$ registers must be saved before the call and reloaded after, because the callee may clobber them. Under the stated model, the number of such values is $\\min(\\ell,n)$ at a call site. Each save and each reload is counted as one memory operation. Therefore, the per-call cost is\n$$\nC_{\\text{caller}} \\;=\\; 2\\,\\min(\\ell,n).\n$$\n\nBy definition of callee-saved, the callee must preserve the contents of the designated $n$ registers across its execution if it uses them, accomplished by saving them in the function prologue and restoring them in the epilogue. Under the model:\n- With probability $p$, the callee is a leaf function. A leaf callee can be compiled to avoid using these $n$ registers entirely (it confines temporaries to caller-saved resources), incurring $0$ saves and $0$ reloads, i.e., $0$ memory operations.\n- With probability $1-p$, the callee is non-leaf. A non-leaf callee eventually uses all $n$ of these registers and must save and reload all $n$, i.e., $2n$ memory operations.\n\nThe expected cost under callee-saved is then\n$$\nC_{\\text{callee}} \\;=\\; \\mathbb{E}[\\text{memory ops}] \\;=\\; 2\\big(p\\cdot 0 + (1-p)\\cdot n\\big) \\;=\\; 2(1-p)\\,n,\n$$\nwhere $\\mathbb{E}[\\cdot]$ denotes expectation and linearity of expectation is used.\n\nThe caller-saved convention has strictly lower expected cost when\n$$\nC_{\\text{caller}} \\;<\\; C_{\\text{callee}}\n\\quad\\Longleftrightarrow\\quad\n2\\,\\min(\\ell,n) \\;<\\; 2(1-p)\\,n.\n$$\nDivide both sides by $2$ to obtain\n$$\n\\min(\\ell,n) \\;<\\; (1-p)\\,n.\n$$\nSolve for $p$:\n$$\n1-p \\;>\\; \\frac{\\min(\\ell,n)}{n}\n\\quad\\Longleftrightarrow\\quad\np \\;<\\; 1 \\;-\\; \\frac{\\min(\\ell,n)}{n}.\n$$\nTherefore, the threshold $p^{*}$ at which caller-saved transitions from winning to not winning (i.e., the largest $p$ for which caller-saved still wins) is\n$$\np^{*} \\;=\\; 1 \\;-\\; \\frac{\\min(\\ell,n)}{n}.\n$$\n\nThis expression is well-defined because $\\min(\\ell,n)$ is between $0$ and $n$, so $\\frac{\\min(\\ell,n)}{n}$ lies in $[0,1]$, implying $p^{*}\\in[0,1]$. Two limiting cases illustrate the interpretation:\n- If $\\ell \\ge n$, then $\\min(\\ell,n)=n$ and $p^{*}=0$, meaning caller-saved never has a lower expected cost unless $p=0$ (all calls non-leaf), consistent with $C_{\\text{caller}}=2n$ versus $C_{\\text{callee}}=2(1-p)n$.\n- If $\\ell$ is small relative to $n$, then $p^{*}$ is close to $1$, indicating caller-saved wins for a broad range of $p$ below that threshold, and callee-saved wins when most calls are leaf (large $p$), which accords with the model’s intuition.", "answer": "$$\\boxed{1-\\frac{\\min(\\ell,n)}{n}}$$", "id": "3626283"}, {"introduction": "Calling conventions are a contract that enables modularity and interoperability in software, but this contract must be rigorously verified. This problem [@problem_id:3626201] shifts the focus from performance optimization to correctness, asking you to design a robust test harness to detect violations of the callee-saved register rule. You'll need to consider how to isolate the function under test and counteract compiler optimizations that could otherwise hide bugs, a common challenge in low-level testing.", "problem": "You are evaluating whether a compiler’s code generator correctly implements the Application Binary Interface (ABI) with respect to callee-saved and caller-saved register conventions. Let the machine have a finite set of general-purpose registers denoted by $R$, partitioned into a callee-saved subset $R_c$ and a caller-saved subset $R_{k}$, such that $R = R_c \\cup R_{k}$ and $R_c \\cap R_{k} = \\varnothing$. By definition of the ABI and calling convention, for any function $f$, if $f$ is called in a context that obeys the ABI, then upon normal return, the contents of all registers in $R_c$ must be exactly those present at call entry; the caller is responsible for preserving any needed values in $R_{k}$. Assume single-threaded execution and that you can emit inline assembly and raw assembly as needed, but the optimizing compiler may reorder instructions unless prevented by a proper barrier. You want to build an automated test harness that generates randomized functions $\\{f_i\\}_{i=1}^{N}$ that claim to follow the convention, and then verifies compliance by placing canary values into $R_c$ at call entry, letting $f_i$ execute, and checking that the canaries remain unchanged at return.\n\nWhich of the following testing plans most reliably detects violations of the callee-saved convention in $R_c$ without introducing avoidable false positives or false negatives? Select all that apply.\n\nA. Build a small assembly harness that, just before calling a function under test $f_i$, performs the following steps: it loads distinct canary values into each register in $R_c$ using explicit register-targeted moves; it saves all caller-saved registers in $R_{k}$ to a private aligned stack scratch area; it issues a compiler barrier that clobbers memory and all of $R$ as seen by the high-level compiler to prevent reordering across the call site; it calls $f_i$ indirectly via a function pointer located in a separately compiled translation unit with inlining disabled; upon return, it first restores $R_{k}$ from the scratch area, then compares the current contents of all registers in $R_c$ against the original canaries. The generator produces $f_i$ that may have nested calls and arbitrary register pressure but must return normally. Any mismatch in $R_c$ is reported as a violation.\n\nB. Write a high-level language harness that stores canary constants in volatile local variables and relies on the optimizing compiler to allocate those variables into $R_c$. It then calls $f_i$ directly and, after return, compares the volatile variables to the constants. If they match, $f_i$ is deemed compliant; otherwise, noncompliant. No special compiler barriers or anti-inlining measures are used.\n\nC. Instrument each generated function $f_i$ by injecting, at its entry, stores of all registers in $R_c$ to its stack frame and, at each return, loads of the same $R_c$ locations back into the registers, then report success if the injected loads match the injected stores. Do not place canaries in the caller or check $R_c$ at the call boundary.\n\nD. Use an assembly harness that writes canaries into $R_c$, calls $f_i$, and checks $R_c$ on return. To increase coverage, enable random asynchronous signal delivery whose handlers execute arbitrary code that may touch general-purpose registers during the call. Any mismatch in $R_c$ is attributed to $f_i$ and reported as a violation.\n\nE. Use an assembly harness to place canaries into $R_c$ and immediately call $f_i$ compiled with aggressive optimizations and inlining enabled. Do not prevent inlining or tail-call optimization, and do not save $R_{k}$. After the call, check $R_c$ for equality with the canaries; if unequal, report a violation.\n\nAssume that stack alignment, shadow space, and any mandated red zones are honored by the harness in all options that use assembly. You may also assume that the canary values are drawn from a distribution over the $w$-bit word space, where $w$ is the machine word size, and that the harness records the exact canaries it wrote for later comparison. Choose the option or options that are methodologically sound under the ABI definition stated above.", "solution": "The problem requires the design of a reliable test harness to verify a compiler's adherence to the callee-saved register convention as defined by an Application Binary Interface (ABI). A reliable test must accurately detect violations (true positives) while avoiding false alarms (false positives) and missed violations (false negatives). The core principle to be tested is that for any function $f$, the values in the set of callee-saved registers, $R_c$, must be identical upon the function's return to their values at the moment of the call.\n\nLet us analyze each proposed testing plan.\n\n**A. Build a small assembly harness that, just before calling a function under test $f_i$, performs the following steps: it loads distinct canary values into each register in $R_c$ using explicit register-targeted moves; it saves all caller-saved registers in $R_{k}$ to a private aligned stack scratch area; it issues a compiler barrier that clobbers memory and all of $R$ as seen by the high-level compiler to prevent reordering across the call site; it calls $f_i$ indirectly via a function pointer located in a separately compiled translation unit with inlining disabled; upon return, it first restores $R_{k}$ from the scratch area, then compares the current contents of all registers in $R_c$ against the original canaries. The generator produces $f_i$ that may have nested calls and arbitrary register pressure but must return normally. Any mismatch in $R_c$ is reported as a violation.**\n\nThis option describes a methodologically sound and robust testing strategy.\n1.  **Assembly Harness:** Using an assembly harness provides direct, low-level control over the CPU state, which is essential for placing canaries into specific registers ($R_c$) and checking them. This bypasses the ambiguity of high-level language-to-register mapping.\n2.  **Saving $R_k$:** The harness, as a caller, may use registers in $R_k$ for its own operations (e.g., loop counters, pointers for the check phase). According to the ABI, the caller is responsible for saving these if their values are needed across a call. Doing so makes the harness itself robust and ABI-compliant, preventing its own logic from failing due to the (expected) clobbering of $R_k$ by $f_i$.\n3.  **Compiler Barrier:** The `clobber` barrier is critical. It informs the compiler that its knowledge of register and memory state is invalidated by the `call` to $f_i$. This prevents the optimizing compiler, which might be compiling the harness code, from reordering the canary setup, the function call, and the canary check. Without this, the optimizer could move the check before the call or the setup after the call, rendering the test meaningless and leading to false negatives.\n4.  **Indirect Call & No Inlining:** Calling $f_i$ indirectly through a function pointer and ensuring it is in a separately compiled unit with inlining disabled is crucial. This forces the generation of a true `call` instruction and treats $f_i$ as a black box that must communicate solely via the ABI. If $f_i$ were inlined, the compiler could perform inter-procedural optimizations, potentially \"optimizing away\" the very violation we seek to detect, leading to a false negative.\n5.  **Conclusion on A:** This plan correctly isolates the unit under test ($f_i$) and ensures the integrity of the test's setup and verification steps against compiler optimizations. It directly tests the ABI contract at the machine level. Therefore, it is a reliable method for detecting violations with a low probability of false positives or false negatives.\n\n**Verdict: Correct**\n\n**B. Write a high-level language harness that stores canary constants in volatile local variables and relies on the optimizing compiler to allocate those variables into $R_c$. It then calls $f_i$ directly and, after return, compares the volatile variables to the constants. If they match, $f_i$ is deemed compliant; otherwise, noncompliant. No special compiler barriers or anti-inlining measures are used.**\n\nThis approach is fundamentally flawed and unreliable.\n1.  **Register Allocation:** There is no standard mechanism in languages like C or C++ to force a local variable into a specific register, let alone a register from the callee-saved set $R_c$. The compiler is free to store the variable on the stack or in any register of its choosing (from $R_c$ or $R_k$). The `volatile` keyword prevents the optimizer from eliding reads/writes to the variable's memory location but does not influence register allocation. Thus, the test may not even place canaries in $R_c$, leading to massive false negatives.\n2.  **Direct Call and Inlining:** Calling $f_i$ directly with no measures to prevent inlining allows the compiler to perform optimizations across the function call boundary. As explained for option A, this can obscure or eliminate the violation, causing a false negative.\n3.  **No Barriers:** The absence of compiler barriers allows the optimizer to reorder the test logic, invalidating the test's premises.\n\n**Verdict: Incorrect**\n\n**C. Instrument each generated function $f_i$ by injecting, at its entry, stores of all registers in $R_c$ to its stack frame and, at each return, loads of the same $R_c$ locations back into the registers, then report success if the injected loads match the injected stores. Do not place canaries in the caller or check $R_c$ at the call boundary.**\n\nThis plan tests the wrong thing.\n1.  **Altering the Subject:** The described instrumentation modifies the function under test, $f_i$, into a new function, $f_i'$. The injected code (a standard function prologue/epilogue for saving/restoring $R_c$) effectively *corrects* any callee-saved violation that the original $f_i$ might have had.\n2.  **Guaranteed Success:** The instrumented function $f_i'$ will, by construction, always preserve the registers in $R_c$ from the perspective of its caller. The internal check (matching injected loads and stores) merely verifies that the instrumentation itself works, not whether the original code of $f_i$ was compliant. This will result in a $100\\%$ rate of false negatives for any non-compliant function.\n\n**Verdict: Incorrect**\n\n**D. Use an assembly harness that writes canaries into $R_c$, calls $f_i$, and checks $R_c$ on return. To increase coverage, enable random asynchronous signal delivery whose handlers execute arbitrary code that may touch general-purpose registers during the call. Any mismatch in $R_c$ is attributed to $f_i$ and reported as a violation.**\n\nThis approach introduces confounding variables, making it unreliable.\n1.  **Conflating Concerns:** The ABI for a function call is distinct from the ABI and system-level protocol for handling asynchronous signals or interrupts. When a signal is delivered, the operating system is responsible for saving the full context of the interrupted thread (including all registers in $R_c$ and $R_k$), running the signal handler, and then restoring that context.\n2.  **Source of False Positives:** If a canary value in a register from $R_c$ is corrupted, this plan attributes the fault to $f_i$. However, the corruption could be due to a bug in the OS's context-switch code for signal handling. The test is no longer isolating $f_i$; it is simultaneously testing the OS. This violates the principle of a specific unit test and is a direct cause of potential false positives.\n3.  **Context Violation:** The problem specifies analysis under the assumption of single-threaded execution. Asynchronous signals introduce a form of preemption and concurrent execution (the handler interrupting the main thread) that complicates the clean, single-threaded model the ABI is defined for.\n\n**Verdict: Incorrect**\n\n**E. Use an assembly harness to place canaries into $R_c$ and immediately call $f_i$ compiled with aggressive optimizations and inlining enabled. Do not prevent inlining or tail-call optimization, and do not save $R_{k}$. After the call, check $R_c$ for equality with the canaries; if unequal, report a violation.**\n\nThis plan contains multiple, severe methodological flaws.\n1.  **Inlining and TCO:** As with option B, allowing inlining and tail-call optimization (TCO) is fatal to the test's reliability. Inlining allows the compiler to reason about the combined code of the harness and $f_i$, potentially hiding violations (false negatives). TCO replaces a `call`/`ret` sequence with a `jmp`, which breaks the fundamental model of a function call that the ABI governs. A test of $f_i$ could become a test of a different function that $f_i$ tail-calls.\n2.  **Not Saving $R_k$:** The harness itself is a program. If its checking logic after the call to $f_i$ depends on values it held in caller-saved registers ($R_k$) before the call, failing to save them will lead to the harness's own failure. Function $f_i$ is explicitly permitted by the ABI to modify $R_k$. This makes the harness itself buggy and unreliable. Any failure could be due to the harness corrupting its own state, not a violation in $f_i$.\n\n**Verdict: Incorrect**\n\n**Summary:**\n\nOnly option A provides a complete and methodologically rigorous framework for testing callee-saved register conventions. It correctly uses low-level control, isolates the test subject, and protects the test's integrity from compiler optimizations, thus minimizing the risk of both false positives and false negatives.", "answer": "$$\\boxed{A}$$", "id": "3626201"}]}