{"hands_on_practices": [{"introduction": "Before deciding how to optimize a system, it's crucial to understand its fundamental costs. This first practice grounds the abstract concept of a display in concrete performance analysis. You will develop a simple but powerful cost model to quantify the CPU cycle overhead of using a display, accounting for both nonlocal variable accesses (reads) and scope entry/exit (updates), which is essential for making informed performance trade-offs in compiler design [@problem_id:3638318].", "problem": "A compiler for a block-structured language uses a display to implement nonlocal variable access. The display is an array indexed by static lexical level that stores the most recent Activation Record (AR) pointer for each level. On procedure entry at static level $h$, the runtime system saves the old display entry at index $h$ and installs the new AR pointer, and on procedure exit it restores the saved entry. Assume each such display update writes costs $c_{\\text{update}}$ Central Processing Unit (CPU) cycles. A nonlocal variable access from the current activation that targets a declaration at level $h$ reads the display entry at index $h$ to obtain the base address for addressing; assume this display read costs $c_{\\text{load}}$ CPU cycles. Ignore all other costs (such as arithmetic and data memory access) and focus only on display reads and writes.\n\nSuppose a particular program is run once, and dynamic instrumentation yields the following aggregate counts across the entire run:\n- For each level $h \\in \\{0,1,\\dots,H\\}$, the total number of nonlocal accesses that target declarations at level $h$ is $A_h$.\n- For each level $h \\in \\{0,1,\\dots,H\\}$, the total number of display update operations performed at index $h$ (counting both procedure entries and exits) is $U_h$.\n\nStarting from the fundamental cost-accounting principle that the total cost of a mechanism equals the sum over all distinct event types of the product of per-event cost and event frequency, derive a symbolic expression for the total display-related cost over the execution in terms of $\\{A_h\\}$, $\\{U_h\\}$, $c_{\\text{load}}$, $c_{\\text{update}}$, and $H$. Then evaluate this total cost for the following concrete data:\n- $H = 4$,\n- $c_{\\text{load}} = 3$ cycles,\n- $c_{\\text{update}} = 7$ cycles,\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$,\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$.\n\nExpress the final total cost as a single number in cycles. No rounding is required.", "solution": "To find the total display-related cost, we must account for the two types of operations that interact with the display: nonlocal variable accesses (reads) and procedure entry/exit maintenance (writes). The total cost, $C_{\\text{total}}$, is the sum of the costs from all reads and all writes.\n\n**1. Cost of Display Reads (Accesses):**\nA single nonlocal access targeting a declaration at level $h$ requires one read from the display, which costs $c_{\\text{load}}$ cycles. The total number of such accesses for level $h$ is given as $A_h$. Therefore, the total cost for all accesses to level $h$ is $A_h \\cdot c_{\\text{load}}$. Summing over all possible lexical levels from $h=0$ to $H$, the total cost of all display reads is:\n$$ C_{\\text{reads}} = \\sum_{h=0}^{H} A_h \\cdot c_{\\text{load}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right) $$\n\n**2. Cost of Display Writes (Updates):**\nA single display update operation at index $h$ costs $c_{\\text{update}}$ cycles. The total number of these updates is given as $U_h$. The total cost for all updates at level $h$ is $U_h \\cdot c_{\\text{update}}$. Summing over all levels, the total cost of all display writes is:\n$$ C_{\\text{writes}} = \\sum_{h=0}^{H} U_h \\cdot c_{\\text{update}} = c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right) $$\n\n**3. Total Cost Expression:**\nThe symbolic expression for the total display-related cost is the sum of the read and write costs:\n$$ C_{\\text{total}} = c_{\\text{load}} \\left( \\sum_{h=0}^{H} A_h \\right) + c_{\\text{update}} \\left( \\sum_{h=0}^{H} U_h \\right) $$\n\n**4. Numerical Evaluation:**\nWe now substitute the given values:\n- $c_{\\text{load}} = 3$ cycles\n- $c_{\\text{update}} = 7$ cycles\n- $\\{A_h\\}_{h=0}^{4} = \\{1500, 600, 240, 90, 20\\}$\n- $\\{U_h\\}_{h=0}^{4} = \\{2, 400, 260, 120, 40\\}$\n\nFirst, we calculate the total number of accesses and updates:\n$$ \\sum_{h=0}^{4} A_h = 1500 + 600 + 240 + 90 + 20 = 2450 $$\n$$ \\sum_{h=0}^{4} U_h = 2 + 400 + 260 + 120 + 40 = 822 $$\n\nFinally, we plug these sums into the total cost formula:\n$$ C_{\\text{total}} = (3 \\cdot 2450) + (7 \\cdot 822) = 7350 + 5754 = 13104 $$\nThe total display-related cost is 13104 CPU cycles.", "answer": "$$\n\\boxed{13104}\n$$", "id": "3638318"}, {"introduction": "Compiler design is often a game of trade-offs, and this exercise places you right in the middle of a classic optimization puzzle. You will explore the decision of whether to cache display pointers in fast but scarce CPU registers, which speeds up nonlocal access at the potential cost of increased register pressure and spilling for other computations. This practice challenges you to move from simple cost analysis to active optimization by finding the ideal balance between two competing performance factors [@problem_id:3638307].", "problem": "In a statically scoped language, nonlocal variables are accessed using a display of activation records. The display is an array of frame pointers for lexically enclosing procedures, where the entry for lexical depth $\\ell$ allows constant-time access to variables at that depth. A compiler targeting a machine with $R$ architectural registers can optionally reserve some registers to hold display entries, reducing nonlocal access latency at the cost of increased register pressure for general-purpose values. Spilling occurs when the average number of simultaneously live general-purpose values exceeds the number of registers available to hold them; each unit of spill generates an expected penalty per instruction.\n\nConsider a program with a small display depth $d = 3$. You may reserve an integer number $k$ of registers for display entries, with $0 \\leq k \\leq d$, always holding the $k$ most frequently needed display entries (assume the $k$ topmost lexical levels). The machine has $R = 16$ registers. The program’s average general-purpose live value demand is $W = 14$ registers per instruction. Each unit of register shortage per instruction yields an expected spill penalty of $c_s = 3$ cycles per instruction. Nonlocal variable accesses occur with frequency $f = 0.2$ per instruction, and the lexical depth of a nonlocal access is uniformly distributed over the $d$ possible levels. If the required display entry is in a reserved register, its cost is negligible; otherwise, loading the display entry from memory costs $M = 25$ cycles.\n\nAssume the following simple model:\n- The expected nonlocal access cost per instruction is $f$ times the expected cost of a single nonlocal access under uniform depth, given $k$ reserved display entries.\n- The spill penalty per instruction is $c_s$ times the shortage, where shortage is $\\max\\{0,\\, W - (R - k)\\}$.\n- All events are independent across instructions in steady state.\n\nDerive from first principles an expression for the expected cycles per instruction as a function of $k$, and determine the integer $k \\in \\{0,1,2,3\\}$ that minimizes this expected cost. Report only the optimal $k$ as your final answer. No rounding is required.", "solution": "The goal is to find the optimal number of registers, $k$, to reserve for the display, which minimizes the total expected cost per instruction, $C(k)$. This cost is the sum of two components: the spill penalty, $C_{\\text{spill}}(k)$, and the nonlocal access cost, $C_{\\text{nonlocal}}(k)$.\n$$ C(k) = C_{\\text{spill}}(k) + C_{\\text{nonlocal}}(k) $$\n\n**1. Spill Penalty Cost ($C_{\\text{spill}}(k)$):**\nThe machine has $R=16$ registers. If $k$ are reserved for the display, $R-k = 16-k$ registers are available for general-purpose values. The average demand is $W=14$. A shortage occurs if demand exceeds supply. The shortage is given by $S(k) = \\max\\{0, W - (R-k)\\}$.\n$$ S(k) = \\max\\{0, 14 - (16 - k)\\} = \\max\\{0, k - 2\\} $$\nThe spill penalty per instruction is this shortage multiplied by the spill cost per unit, $c_s = 3$.\n$$ C_{\\text{spill}}(k) = 3 \\cdot \\max\\{0, k - 2\\} $$\n\n**2. Nonlocal Access Cost ($C_{\\text{nonlocal}}(k)$):**\nNonlocal accesses occur with frequency $f=0.2$. The display depth is $d=3$. The probability of accessing any specific level is uniform, i.e., $1/d = 1/3$.\nIf an access is to one of the top $k$ levels, its display entry is in a register, and the cost is 0. The probability of this is $k/d$.\nIf an access is to one of the other $d-k$ levels, the entry must be loaded from memory for a cost of $M=25$. The probability of this is $(d-k)/d$.\nThe expected cost for a single nonlocal access is:\n$$ E_{\\text{access}}(k) = \\left(\\frac{k}{d}\\right) \\cdot 0 + \\left(\\frac{d-k}{d}\\right) \\cdot M = \\frac{3-k}{3} \\cdot 25 $$\nThe nonlocal access cost per instruction is this expected cost multiplied by the frequency $f$:\n$$ C_{\\text{nonlocal}}(k) = f \\cdot E_{\\text{access}}(k) = 0.2 \\cdot \\left(\\frac{3-k}{3} \\cdot 25\\right) = 5 \\cdot \\frac{3-k}{3} $$\n\n**3. Total Cost Function and Optimization:**\nCombining the two components, the total cost function is:\n$$ C(k) = 3 \\cdot \\max\\{0, k - 2\\} + 5 \\cdot \\frac{3-k}{3} $$\nWe evaluate this for each possible integer value of $k \\in \\{0, 1, 2, 3\\}$:\n-   **For $k = 0$**: $C(0) = 3 \\cdot \\max\\{0, -2\\} + 5 \\cdot \\frac{3}{3} = 3 \\cdot 0 + 5 = 5$\n-   **For $k = 1$**: $C(1) = 3 \\cdot \\max\\{0, -1\\} + 5 \\cdot \\frac{2}{3} = 3 \\cdot 0 + \\frac{10}{3} \\approx 3.33$\n-   **For $k = 2$**: $C(2) = 3 \\cdot \\max\\{0, 0\\} + 5 \\cdot \\frac{1}{3} = 3 \\cdot 0 + \\frac{5}{3} \\approx 1.67$\n-   **For $k = 3$**: $C(3) = 3 \\cdot \\max\\{0, 1\\} + 5 \\cdot \\frac{0}{3} = 3 \\cdot 1 + 0 = 3$\n\nComparing the total costs, the minimum cost is $\\frac{5}{3}$, which occurs when $k=2$. Therefore, reserving 2 registers is the optimal strategy.", "answer": "$$\\boxed{2}$$", "id": "3638307"}, {"introduction": "After analyzing costs and trade-offs, the final step is implementation. This practice provides direct, hands-on experience in building the core logic for display-based access within a compiler's intermediate representation (IR). You will implement a \"lowering\" pass that translates abstract, lexically-aware symbol references into concrete memory addresses, while also tracking data dependencies using Static Single Assignment (SSA) principles, solidifying your understanding of how high-level scoping rules are realized in machine-level operations [@problem_id:3638282].", "problem": "You are given an abstract intermediate representation that encodes lexical scoping levels and activation record offsets on each symbol as metadata. The intermediate representation consists of a sequence of operations where each symbol reference carries two integers: the lexical level $h$ at which the symbol was declared and the activation record offset $o$ for that symbol. The currently executing activation has lexical level $L$. The environment is modeled by a display array $D$ such that, for each lexical level index $k$ in the valid range, $D[k]$ stores the base address of the activation record associated with level $k$. The lowering objective is to materialize a concrete address for each symbol access and to record the Static Single Assignment (SSA) data dependencies induced by display definitions.\n\nFundamental base:\n- Lexical scoping is a well-established binding rule that organizes name resolution by static nesting. Each activation belongs to a lexical level and accesses are resolved along a lexical chain.\n- A display is a well-tested technique for fast nonlocal access under lexical scoping. The display $D$ provides $O(1)$ access to the base address of any ancestor activation by level index.\n- Static Single Assignment (SSA) form is a canonical representation in which each variable is assigned exactly once, and every read of a variable is a use of a unique definition. In the presence of redefinitions, SSA tracking for a quantity can be realized by recording, for each use, the identifier of the most recent dominating definition.\n\nTask:\n- Implement a deterministic lowering pass that, for each load of a symbol annotated with $(h, o)$, computes a concrete address by combining the base pointer retrieved from the display at lexical level $h$ with the symbol’s offset $o$. Treat both local accesses (where $h = L$) and nonlocal accesses (where $h &lt; L$) uniformly through the display mechanism. You must not assume any other addressing scheme.\n- Track data dependencies in the sense of Static Single Assignment (SSA) for display entries: every operation that defines a display entry $D[h]$ is a unique definition. For each lowered load that consults $D[h]$, record the identifier of the most recent definition that provided the base pointer for $D[h]$ at the point of use. Definition identifiers are consecutive positive integers, assigned in the chronological order in which display entries are defined within a test case.\n- The program should process a finite test suite of instruction sequences, each with a specified current lexical level $L$, an ordered sequence of display definitions, and symbol loads. The program must compute, for each load, the resulting concrete address and the identifier of the display definition on which it depends under SSA.\n\nRepresentation:\n- An operation is either a display definition or a load. A display definition carries an index $h$ and a base address $b$ and sets $D[h] \\leftarrow b$. A load carries a pair $(h, o)$ and reads the symbol declared at level $h$ with offset $o$.\n- For SSA tracking, each display definition operation is assigned a unique integer definition identifier, starting at $1$ and incremented by $1$ for each definition encountered.\n- For a load using lexical level $h$, its dependency is the most recent display definition identifier for $h$ encountered before that load.\n\nTest suite:\n- Test case $1$ (happy path coverage): $L = 3$; operations:\n  - Define $D[0] \\leftarrow 1000$,\n  - Define $D[1] \\leftarrow 2000$,\n  - Define $D[2] \\leftarrow 3000$,\n  - Define $D[3] \\leftarrow 4000$,\n  - Load $(h = 2, o = 12)$,\n  - Load $(h = 3, o = 8)$,\n  - Load $(h = 1, o = 0)$.\n- Test case $2$ (boundary conditions for global level and redefinition): $L = 1$; operations:\n  - Define $D[0] \\leftarrow 500$,\n  - Define $D[1] \\leftarrow 700$,\n  - Load $(h = 0, o = 3)$,\n  - Define $D[0] \\leftarrow 800$,\n  - Load $(h = 0, o = 5)$,\n  - Load $(h = 1, o = 10)$.\n- Test case $3$ (edge case with multiple redefinitions and zero-offset access): $L = 2$; operations:\n  - Define $D[0] \\leftarrow 100$,\n  - Define $D[1] \\leftarrow 150$,\n  - Define $D[2] \\leftarrow 180$,\n  - Load $(h = 2, o = 0)$,\n  - Load $(h = 1, o = 20)$,\n  - Define $D[2] \\leftarrow 1000$,\n  - Load $(h = 2, o = 5)$,\n  - Define $D[1] \\leftarrow 160$,\n  - Load $(h = 1, o = 1)$.\n\nAnswer specification:\n- For each test case, output a list of lists of two integers. Each inner list is of the form $[a, d]$ where $a$ is the computed concrete address for the load, and $d$ is the SSA definition identifier of the display entry $D[h]$ most recently defined before the load.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The top-level list aggregates the per-test-case lists in order. For example, the final output must look like $[[[a_1,d_1],[a_2,d_2],\\dots],[[\\dots]],[[\\dots]]]$ with no spaces.\n\nNo user input is required; the program must emit the single-line result for the built-in test suite.", "solution": "This problem requires implementing a simulation of a compiler's \"lowering\" pass, which translates abstract symbol references into concrete memory addresses using a display mechanism, while also tracking data dependencies in the style of Static Single Assignment (SSA).\n\nThe core of the simulation involves processing a sequence of operations chronologically and maintaining the state of the runtime environment. This state consists of three main components for each test case:\n1.  A **display array**, $D$, which stores the base address for the most recent activation record at each lexical level.\n2.  An **SSA dependency array**, $S$, where $S[h]$ stores the unique identifier of the most recent definition of the display entry $D[h]$.\n3.  A **definition counter**, which starts at 1 and is incremented for each `Define` operation to generate unique SSA identifiers.\n\nThe simulation proceeds by iterating through the ordered list of operations for a given test case:\n\n-   If the operation is a **`Define $D[h] \\leftarrow b$`**, it represents an update to the display. The simulation must:\n    1.  Update the display array: set $D[h] = b$.\n    2.  Assign the current value of the definition counter as the new SSA identifier for this level: set $S[h]$ to the counter's value.\n    3.  Increment the definition counter for the next definition.\n\n-   If the operation is a **`Load $(h, o)$`**, it represents a variable access. The simulation must:\n    1.  Retrieve the base address for the variable's lexical scope by reading the display: `base_address = D[h]`.\n    2.  Calculate the concrete memory address: `address = base_address + o`.\n    3.  Retrieve the SSA dependency by reading the dependency array: `dependency_id = S[h]`.\n    4.  Record the pair `[address, dependency_id]` as the result for this load operation.\n\nBy applying this procedure to each operation in the sequence for all three test cases, we can determine the final address and dependency for every load. For example, in Test Case 2, the second load of `(h = 0, o = 5)` occurs after $D[0]$ has been redefined. The simulation correctly uses the new base address (800) and the new SSA definition ID (3) to compute the result `[808, 3]`, demonstrating how SSA tracking captures the data flow through redefinitions.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Note: Headers complex.h, threads.h, stdatomic.h are permitted but unused.\n\n#define MAX_LEVELS 16\n\n// An enum to distinguish operation types\ntypedef enum {\n    OP_DEFINE,\n    OP_LOAD\n} OpType;\n\n// A struct representing a single IR operation\ntypedef struct {\n    OpType type;\n    int level; // Lexical level 'h'\n    int value; // Base address 'b' for DEFINE, offset 'o' for LOAD\n} Operation;\n\n// A struct to hold a single test case\ntypedef struct {\n    int current_level_L;\n    const Operation* operations;\n    int num_operations;\n} TestCase;\n\nint main(void) {\n    // Define the operations for each test case\n    const Operation tc1_ops[] = {\n        {OP_DEFINE, 0, 1000},\n        {OP_DEFINE, 1, 2000},\n        {OP_DEFINE, 2, 3000},\n        {OP_DEFINE, 3, 4000},\n        {OP_LOAD, 2, 12},\n        {OP_LOAD, 3, 8},\n        {OP_LOAD, 1, 0}\n    };\n\n    const Operation tc2_ops[] = {\n        {OP_DEFINE, 0, 500},\n        {OP_DEFINE, 1, 700},\n        {OP_LOAD, 0, 3},\n        {OP_DEFINE, 0, 800},\n        {OP_LOAD, 0, 5},\n        {OP_LOAD, 1, 10}\n    };\n\n    const Operation tc3_ops[] = {\n        {OP_DEFINE, 0, 100},\n        {OP_DEFINE, 1, 150},\n        {OP_DEFINE, 2, 180},\n        {OP_LOAD, 2, 0},\n        {OP_LOAD, 1, 20},\n        {OP_DEFINE, 2, 1000},\n        {OP_LOAD, 2, 5},\n        {OP_DEFINE, 1, 160},\n        {OP_LOAD, 1, 1}\n    };\n\n    // Define the test suite\n    const TestCase test_cases[] = {\n        {3, tc1_ops, sizeof(tc1_ops) / sizeof(tc1_ops[0])},\n        {1, tc2_ops, sizeof(tc2_ops) / sizeof(tc2_ops[0])},\n        {2, tc3_ops, sizeof(tc3_ops) / sizeof(tc3_ops[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    printf(\"[\");\n\n    for (int i = 0; i < num_cases; ++i) {\n        const TestCase* tc = &test_cases[i];\n\n        // State for the current test case\n        int display[MAX_LEVELS];\n        int ssa_defs[MAX_LEVELS];\n        memset(display, 0, sizeof(display));\n        memset(ssa_defs, 0, sizeof(ssa_defs));\n        int def_counter = 1;\n\n        // Count LOAD operations to allocate memory for results\n        int num_loads = 0;\n        for (int j = 0; j < tc->num_operations; ++j) {\n            if (tc->operations[j].type == OP_LOAD) {\n                num_loads++;\n            }\n        }\n\n        int (*results)[2] = malloc(num_loads * sizeof(int[2]));\n        if (num_loads > 0 && results == NULL) {\n            // Handle allocation failure if necessary, though unlikely for this size\n            return EXIT_FAILURE; \n        }\n        int load_idx = 0;\n\n        // Process all operations for the test case\n        for (int j = 0; j < tc->num_operations; ++j) {\n            const Operation* op = &tc->operations[j];\n\n            if (op->type == OP_DEFINE) {\n                if (op->level < MAX_LEVELS) {\n                    display[op->level] = op->value;\n                    ssa_defs[op->level] = def_counter;\n                    def_counter++;\n                }\n            } else if (op->type == OP_LOAD) {\n                if (op->level < MAX_LEVELS) {\n                    int base_addr = display[op->level];\n                    int ssa_def_id = ssa_defs[op->level];\n                    int concrete_addr = base_addr + op->value;\n                    \n                    if (load_idx < num_loads) {\n                        results[load_idx][0] = concrete_addr;\n                        results[load_idx][1] = ssa_def_id;\n                        load_idx++;\n                    }\n                }\n            }\n        }\n\n        // Print results for the current test case\n        if (i > 0) {\n            printf(\",\");\n        }\n        printf(\"[\");\n        for (int j = 0; j < num_loads; ++j) {\n            if (j > 0) {\n                printf(\",\");\n            }\n            printf(\"[%d,%d]\", results[j][0], results[j][1]);\n        }\n        printf(\"]\");\n\n        free(results);\n    }\n    \n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3638282"}]}