{"hands_on_practices": [{"introduction": "This first practice problem lays the groundwork for understanding different parameter passing mechanisms. By tracing the execution of a simple function call where the same variable is passed as two arguments, you will explore the distinct behaviors of pass-by-value, pass-by-reference, pass-by-result, and copy-in/copy-out. This exercise highlights how aliasing and the specific rules of each mechanism, particularly the order of operations at call entry and exit, lead to dramatically different outcomes for the same piece of code [@problem_id:3661405].", "problem": "Consider a tiny, deterministic, call-by-procedure language with integer variables and the following semantics. A function call binds actual parameters to formal parameters according to a specified parameter passing mechanism. Statements execute in program order. In an assignment $x := E$, the expression $E$ is evaluated using the current values of its variables, then the result is written to the location named by $x$. There is no alias analysis beyond the binding provided by the parameter passing mechanism. The four parameter passing mechanisms are defined as follows, and are to be taken as the foundational base for your reasoning:\n\n- Pass-by-value: Each formal parameter receives a copy of the corresponding actual parameter’s value at call entry; formals are distinct locals; modifications to formals do not affect the caller’s variables.\n- Pass-by-reference: Each formal parameter becomes an alias for the corresponding actual parameter’s storage location; if the same actual variable is supplied for multiple formals, the formals alias the same location; all reads and writes reflect and modify the caller’s variable directly.\n- Pass-by-result: Each formal parameter is a distinct uninitialized local at call entry; throughout the call, the formals are independent locals; at call exit, the final values of the formals are copied back to the corresponding actual parameters’ storage locations, in left-to-right order of the formals.\n- Copy-in/copy-out (pass-by-value-result): At call entry, each formal receives a copy of its corresponding actual parameter’s value; during the call, the formals are independent locals; at call exit, the final values of the formals are copied back to the corresponding actual parameters’ storage locations, in left-to-right order of the formals.\n\nAssume expressions use standard integer arithmetic, and the left-to-right order mentioned above is the actual order in which copy-back is performed at call exit.\n\nThe program fragment is:\n- Initial state in the caller: variable $a$ has value $a = 5$.\n- Function definition: $f(u,v)$ has body consisting of three statements executed in sequence:\n  $u := 3$;\n  $v := u + 4$;\n  $u := v + 5$.\n- Call site: the caller executes $f(a,a)$.\n\nLet $V_{\\mathrm{val}}$ be the final value of $a$ after the call under pass-by-value; let $V_{\\mathrm{ref}}$ be the final value of $a$ after the call under pass-by-reference; let $V_{\\mathrm{res}}$ be the final value of $a$ after the call under pass-by-result with left-to-right copy-back; let $V_{\\mathrm{cio}}$ be the final value of $a$ after the call under copy-in/copy-out with left-to-right copy-back.\n\nCompute the single quantity\n$$S \\;=\\; V_{\\mathrm{val}} \\;+\\; V_{\\mathrm{ref}} \\;+\\; V_{\\mathrm{res}} \\;+\\; V_{\\mathrm{cio}}.$$\nProvide the exact integer value of $S$. No rounding is required.", "solution": "The problem statement has been critically validated and is deemed valid. It is a well-posed problem within the domain of computer science, specifically concerning programming language semantics and compiler principles. The definitions of the parameter passing mechanisms are clear, self-contained, and consistent. The initial conditions and the program fragment are specified without ambiguity. Therefore, a reasoned solution can be constructed.\n\nThe problem requires us to trace the execution of the function call $f(a,a)$ under four different parameter passing mechanisms and determine the final value of the variable $a$ in the caller's scope for each case. The initial value of $a$ is given as $a=5$. The function $f(u,v)$ has the body:\n1. $u := 3$;\n2. $v := u + 4$;\n3. $u := v + 5$;\n\nLet us analyze each mechanism sequentially.\n\n### Pass-by-value ($V_{\\mathrm{val}}$)\nAccording to the definition, formal parameters receive a copy of the actual parameters' values. The formals are local variables within the function's scope, and any modifications to them do not affect the caller's variables.\n\n1.  **Call Entry:** Local variables $u$ and $v$ are created. The value of the actual parameter $a$, which is $5$, is copied into both $u$ and $v$. So, the initial state inside the function is $u=5$ and $v=5$. The caller's variable $a$ remains at its location with the value $5$, completely separate from $u$ and $v$.\n2.  **Execution of $f(u,v)$:**\n    - Statement 1: $u := 3$. The local variable $u$ is updated to $3$. State: $u=3$, $v=5$. The caller's $a$ is unaffected and remains $5$.\n    - Statement 2: $v := u + 4$. The expression $u+4$ is evaluated as $3+4=7$. This result is assigned to the local variable $v$. State: $u=3$, $v=7$. The caller's $a$ is unaffected.\n    - Statement 3: $u := v + 5$. The expression $v+5$ is evaluated as $7+5=12$. This result is assigned to the local variable $u$. State: $u=12$, $v=7$. The caller's $a$ is unaffected.\n3.  **Call Exit:** The function returns. The local variables $u$ and $v$ are destroyed. No values are copied back to the caller.\n4.  **Final Value:** The caller's variable $a$ was never modified throughout the call. Its value remains $5$.\nTherefore, $V_{\\mathrm{val}} = 5$.\n\n### Pass-by-reference ($V_{\\mathrm{ref}}$)\nAccording to the definition, formal parameters become aliases for the storage locations of the corresponding actual parameters. Since the call is $f(a,a)$, both formals $u$ and $v$ become aliases for the same storage location, that of the variable $a$. Any read from or write to $u$ or $v$ directly affects the variable $a$.\n\n1.  **Call Entry:** $u$ and $v$ both refer to the location of $a$. Initially, the value at this location is $5$.\n2.  **Execution of $f(u,v)$:**\n    - Statement 1: $u := 3$. This assignment modifies the location aliased by $u$, which is the location of $a$. The value of $a$ becomes $3$.\n    - Statement 2: $v := u + 4$. The expression reads the values of $u$ and adds $4$. Since both $u$ and $v$ alias $a$, this is equivalent to $a := a + 4$. The current value of $a$ is $3$, so the expression evaluates to $3+4=7$. This result is written to the location aliased by $v$, which is the location of $a$. The value of $a$ becomes $7$.\n    - Statement 3: $u := v + 5$. This is equivalent to $a := a + 5$. The current value of $a$ is $7$, so the expression evaluates to $7+5=12$. This result is written to the location aliased by $u$, which is the location of $a$. The value of $a$ becomes $12$.\n3.  **Call Exit:** The aliases $u$ and $v$ cease to exist.\n4.  **Final Value:** The final value of the caller's variable $a$ is $12$.\nTherefore, $V_{\\mathrm{ref}} = 12$.\n\n### Pass-by-result ($V_{\\mathrm{res}}$)\nAccording to the definition, formals are distinct, uninitialized local variables. At call exit, their final values are copied back to the actual parameters' locations in left-to-right order.\n\n1.  **Call Entry:** Two new, uninitialized local variables, $u$ and $v$, are created. They are distinct from each other and from the caller's variable $a$. The caller's $a$ remains $5$.\n2.  **Execution of $f(u,v)$:**\n    - Statement 1: $u := 3$. The local variable $u$ is assigned the value $3$. State: $u=3$.\n    - Statement 2: $v := u + 4$. The expression evaluates to $3+4=7$. The local variable $v$ is assigned the value $7$. State: $u=3$, $v=7$.\n    - Statement 3: $u := v + 5$. The expression evaluates to $7+5=12$. The local variable $u$ is updated to $12$. State: $u=12$, $v=7$.\n3.  **Call Exit (Copy-back):** The final values of the formals are copied back to the actuals. The actual parameters are $(a, a)$, and the formals are $(u, v)$. The copy-back is performed in left-to-right order of the formals.\n    - First (for $u$): The final value of $u$, which is $12$, is copied to the location of the first actual parameter, $a$. The value of $a$ becomes $12$.\n    - Second (for $v$): The final value of $v$, which is $7$, is copied to the location of the second actual parameter, $a$. The value of $a$ becomes $7$. The previous value of $12$ is overwritten.\n4.  **Final Value:** The final value of $a$ is the result of the last copy-back operation, which is $7$.\nTherefore, $V_{\\mathrm{res}} = 7$.\n\n### Copy-in/copy-out (pass-by-value-result) ($V_{\\mathrm{cio}}$)\nThis mechanism combines pass-by-value at entry and pass-by-result at exit.\n\n1.  **Call Entry (Copy-in):** Two new, distinct local variables, $u$ and $v$, are created. They are initialized with the values of the corresponding actuals.\n    - $u$ receives the value of the first actual, $a$, so $u=5$.\n    - $v$ receives the value of the second actual, $a$, so $v=5$.\n    - The caller's $a$ remains $5$ during the function's execution.\n2.  **Execution of $f(u,v)$:**\n    - Statement 1: $u := 3$. The local variable $u$ is updated to $3$. State: $u=3$, $v=5$.\n    - Statement 2: $v := u + 4$. The expression evaluates to $3+4=7$. The local variable $v$ is updated to $7$. State: $u=3$, $v=7$.\n    - Statement 3: $u := v + 5$. The expression evaluates to $7+5=12$. The local variable $u$ is updated to $12$. State: $u=12$, $v=7$.\n3.  **Call Exit (Copy-out):** The final values of the formals are copied back to the actuals' locations in left-to-right order. This step is identical to the pass-by-result case.\n    - First (for $u$): The value of $u$ ($12$) is copied to $a$. The value of $a$ becomes $12$.\n    - Second (for $v$): The value of $v$ ($7$) is copied to $a$. The value of $a$ becomes $7$.\n4.  **Final Value:** The final value of $a$ is $7$.\nTherefore, $V_{\\mathrm{cio}} = 7$.\n\nNote that for this particular function body, where the initial values of the formals are immediately overwritten before being read, the behavior of pass-by-result and copy-in/copy-out is identical.\n\n### Final Calculation\nThe problem asks for the sum $S = V_{\\mathrm{val}} + V_{\\mathrm{ref}} + V_{\\mathrm{res}} + V_{\\mathrm{cio}}$.\nSubstituting the computed values:\n$S = 5 + 12 + 7 + 7$\n$S = 17 + 14$\n$S = 31$\nThe final integer value of $S$ is $31$.", "answer": "$$\n\\boxed{31}\n$$", "id": "3661405"}, {"introduction": "This practice moves beyond simple variables to explore the consequences of aliasing with complex data structures. You will analyze a procedure that operates on overlapping array slices, which are views into a single underlying memory region. This exercise demonstrates how pass-by-reference creates immediate and interactive side effects, while copy-in/copy-out behavior depends critically on the sequence of data being copied back to the original memory locations after the function completes [@problem_id:3661407].", "problem": "Consider a simple imperative language with arrays and contiguous slices modeled as views into a single underlying memory array. A slice with base index $s$ and length $L$ maps its element access $x[i]$ to the underlying memory location $M[s+i]$ for all $i \\in \\{0,\\dots,L-1\\}$. Indices are $0$-based, and all arithmetic is integer arithmetic.\n\nLet the underlying memory be the array $M$ of length $7$ with initial state\n$$\nM = [7,1,4,2,6,3,5].\n$$\nDefine the procedure $h(a,b)$ that operates on two same-length slices $a$ and $b$ (each of length $L$) as follows. For $i$ from $0$ to $L-1$ in increasing order, the body performs the single assignment\n$$\na[i] := b[i] + b\\big((i+1) \\bmod L\\big),\n$$\nwhere $b((i+1) \\bmod L)$ denotes the element of $b$ at index $(i+1) \\bmod L$ (wrap-around indexing).\n\nA caller invokes $h$ with the actual parameters being the overlapping slices\n- $a$ is the slice of $M$ with base $s_a = 1$ and length $L = 4$, so $a[i]$ aliases $M[1+i]$ for $i \\in \\{0,1,2,3\\}$;\n- $b$ is the slice of $M$ with base $s_b = 2$ and length $L = 4$, so $b[i]$ aliases $M[2+i]$ for $i \\in \\{0,1,2,3\\}$.\n\nRun three independent experiments, each starting from the same initial $M$ given above, that differ only in the parameter passing mechanism used for both parameters:\n1. Pass-by-reference for both $a$ and $b$.\n2. Pass-by-value for both $a$ and $b$ (no results are written back to $M$ after the call).\n3. Copy-in/copy-out (also called call-by-value-result) for both $a$ and $b$: on call entry, each formal receives a fresh copy of its actual slice (copy-in); on return, each formal’s final slice contents are written back to the corresponding actual slice (copy-out) in the left-to-right order of the formal parameter list (first $a$, then $b$).\n\nLet $M_{\\mathrm{ref}}$, $M_{\\mathrm{val}}$, and $M_{\\mathrm{cio}}$ denote the final underlying memory arrays after the call in experiments $1$, $2$, and $3$, respectively. Compute the single scalar quantity\n$$\nS \\;=\\; M_{\\mathrm{ref}}[3] \\;+\\; M_{\\mathrm{val}}[3] \\;+\\; M_{\\mathrm{cio}}[3].\n$$\nProvide your answer as a single integer. No rounding is required and no units apply.", "solution": "The problem is valid as it is scientifically grounded in the principles of programming language semantics, specifically parameter passing mechanisms. It is well-posed, with all necessary data and definitions provided, leading to a unique, computable solution. The language is objective and unambiguous. We proceed with the solution.\n\nThe initial state of the underlying memory array $M$ of length $7$ is given as:\n$$ M = [7, 1, 4, 2, 6, 3, 5] $$\nThe procedure $h(a,b)$ is called with two overlapping slices of $M$, each of length $L=4$:\n- Actual parameter $a$ is the slice with base $s_a=1$, corresponding to the view on memory locations $M[1], M[2], M[3], M[4]$. Initially, this slice contains $[1, 4, 2, 6]$.\n- Actual parameter $b$ is the slice with base $s_b=2$, corresponding to the view on memory locations $M[2], M[3], M[4], M[5]$. Initially, this slice contains $[4, 2, 6, 3]$.\n\nThe procedure body executes a loop for $i$ from $0$ to $L-1=3$:\n$$ a[i] := b[i] + b\\big((i+1) \\bmod L\\big) $$\nWe analyze the three independent experiments.\n\n### Experiment 1: Pass-by-reference\n\nIn pass-by-reference, the formal parameters $a$ and $b$ are aliases for the actual parameter slices. Any modification to the formal parameters directly and immediately affects the underlying memory array $M$. The assignment $a[i] := \\dots$ modifies $M[1+i]$, and the reads from $b[\\cdot]$ access the current values in $M[2+\\cdot]$.\n\nLet's trace the execution step-by-step, starting with $M_0 = [7, 1, 4, 2, 6, 3, 5]$.\n\n- **For $i=0$**:\n  The assignment is $a[0] := b[0] + b[1]$.\n  This translates to $M[1+0] := M[2+0] + M[2+1]$, or $M[1] := M[2] + M[3]$.\n  Using the current values in $M$: $M[1] := 4 + 2 = 6$.\n  The state of $M$ becomes $[7, 6, 4, 2, 6, 3, 5]$.\n\n- **For $i=1$**:\n  The assignment is $a[1] := b[1] + b[2]$.\n  This translates to $M[1+1] := M[2+1] + M[2+2]$, or $M[2] := M[3] + M[4]$.\n  Using the current values in $M$: $M[2] := 2 + 6 = 8$.\n  The state of $M$ becomes $[7, 6, 8, 2, 6, 3, 5]$.\n\n- **For $i=2$**:\n  The assignment is $a[2] := b[2] + b[3]$.\n  This translates to $M[1+2] := M[2+2] + M[2+3]$, or $M[3] := M[4] + M[5]$.\n  Using the current values in $M$: $M[3] := 6 + 3 = 9$.\n  The state of $M$ becomes $[7, 6, 8, 9, 6, 3, 5]$.\n\n- **For $i=3$**:\n  The assignment is $a[3] := b[3] + b((3+1) \\bmod 4)$, which simplifies to $a[3] := b[3] + b[0]$.\n  This translates to $M[1+3] := M[2+3] + M[2+0]$, or $M[4] := M[5] + M[2]$.\n  Critically, we must use the **updated** value of $M[2]$, which is $8$.\n  Using the current values in $M$: $M[4] := 3 + 8 = 11$.\n  The state of $M$ becomes $[7, 6, 8, 9, 11, 3, 5]$.\n\nThe final memory array for this experiment is $M_{\\mathrm{ref}} = [7, 6, 8, 9, 11, 3, 5]$.\nTherefore, $M_{\\mathrm{ref}}[3] = 9$.\n\n### Experiment 2: Pass-by-value\n\nIn pass-by-value, the procedure receives copies of the actual parameters. The procedure $h$ operates on these local copies. The problem specifies that for this mechanism, no results are written back to $M$.\n- On entry, a local copy of slice $a$ is created: $a_{\\mathrm{local}} = [1, 4, 2, 6]$.\n- A local copy of slice $b$ is created: $b_{\\mathrm{local}} = [4, 2, 6, 3]$.\nThe procedure manipulates these local copies, but since the results are not copied back, the original array $M$ remains unchanged.\nThe final memory array is identical to the initial one: $M_{\\mathrm{val}} = [7, 1, 4, 2, 6, 3, 5]$.\nTherefore, $M_{\\mathrm{val}}[3] = 2$.\n\n### Experiment 3: Copy-in/copy-out (Call-by-value-result)\n\nThis mechanism involves three phases: copy-in, execution, and copy-out.\n\n- **Copy-in**: On call entry, local copies of the actual parameter slices are made.\n  - $a_{\\mathrm{local}}$ is a copy of the slice starting at $M[1]$: $a_{\\mathrm{local}} = [1, 4, 2, 6]$.\n  - $b_{\\mathrm{local}}$ is a copy of the slice starting at $M[2]$: $b_{\\mathrm{local}} = [4, 2, 6, 3]$.\n\n- **Execution**: The procedure runs using these local copies. The loop modifies $a_{\\mathrm{local}}$ based on reading from $b_{\\mathrm{local}}$. Since $b_{\\mathrm{local}}$ is never written to, it retains its initial copied values throughout the execution.\n  - Let's trace the updates to $a_{\\mathrm{local}}$:\n    - **$i=0$**: $a_{\\mathrm{local}}[0] := b_{\\mathrm{local}}[0] + b_{\\mathrm{local}}[1] = 4 + 2 = 6$.\n    - **$i=1$**: $a_{\\mathrm{local}}[1] := b_{\\mathrm{local}}[1] + b_{\\mathrm{local}}[2] = 2 + 6 = 8$.\n    - **$i=2$**: $a_{\\mathrm{local}}[2] := b_{\\mathrm{local}}[2] + b_{\\mathrm{local}}[3] = 6 + 3 = 9$.\n    - **$i=3$**: $a_{\\mathrm{local}}[3] := b_{\\mathrm{local}}[3] + b_{\\mathrm{local}}[0] = 3 + 4 = 7$.\n  - At the end of the procedure, the final states of the local slices are:\n    - $a_{\\mathrm{local, final}} = [6, 8, 9, 7]$.\n    - $b_{\\mathrm{local, final}} = [4, 2, 6, 3]$ (unchanged).\n\n- **Copy-out**: On return, the contents of the final local slices are copied back to the memory locations of the original actual parameters. The problem specifies the copy-out order is left-to-right: first $a$, then $b$.\n  - We start with the initial memory array: $M = [7, 1, 4, 2, 6, 3, 5]$.\n  - **Copy out $a$**: The contents of $a_{\\mathrm{local, final}}$ are written to the slice locations of $a$, which are $M[1], M[2], M[3], M[4]$.\n    - $M[1] := 6$, $M[2] := 8$, $M[3] := 9$, $M[4] := 7$.\n    - After this step, $M$ becomes $[7, 6, 8, 9, 7, 3, 5]$.\n  - **Copy out $b$**: The contents of $b_{\\mathrm{local, final}}$ are written to the slice locations of $b$, which are $M[2], M[3], M[4], M[5]$. This happens *after* the copy-out of $a$.\n    - $M[2] := 4$ (overwrites the $8$ from $a$'s copy-out).\n    - $M[3] := 2$ (overwrites the $9$ from $a$'s copy-out).\n    - $M[4] := 6$ (overwrites the $7$ from $a$'s copy-out).\n    - $M[5] := 3$ (overwrites the original $3$).\n  - The final state of $M$ is $[7, 6, 4, 2, 6, 3, 5]$.\n\nThe final memory array for this experiment is $M_{\\mathrm{cio}} = [7, 6, 4, 2, 6, 3, 5]$.\nTherefore, $M_{\\mathrm{cio}}[3] = 2$.\n\n### Final Calculation\n\nWe are asked to compute the scalar quantity $S = M_{\\mathrm{ref}}[3] + M_{\\mathrm{val}}[3] + M_{\\mathrm{cio}}[3]$.\nSubstituting the values we found:\n- $M_{\\mathrm{ref}}[3] = 9$\n- $M_{\\mathrm{val}}[3] = 2$\n- $M_{\\mathrm{cio}}[3] = 2$\n\n$$ S = 9 + 2 + 2 = 13 $$\nThe final answer is $13$.", "answer": "$$\n\\boxed{13}\n$$", "id": "3661407"}, {"introduction": "Abstract semantics have concrete performance implications, which this final practice problem explores. You will step into the role of a compiler designer to optimize a calling convention for a machine with a limited number of argument registers. By developing a heuristic to reorder parameters based on their usage frequency, you will directly quantify how an intelligent implementation of pass-by-value can minimize costly memory traffic to the stack, bridging the gap between language theory and practical system performance [@problem_id:3661409].", "problem": "A compiler backend for an internal domain-specific language targets a machine where pass-by-value parameters are transferred using a fixed number of general-purpose argument registers before spilling to the stack. The interface is internal, and the compiler is permitted to reorder the parameter list consistently at both call sites and callees without changing program semantics. Each parameter is a single machine word. The target machine exposes exactly $R$ one-word argument registers; any additional parameters are passed on the stack. Assume the following cost model for dynamic memory traffic per call:\n- Each parameter passed on the stack induces exactly $1$ dynamic word store by the caller.\n- If such a parameter is used $u_i$ times by the callee during the execution of the call, each use induces one dynamic word load from the stack by the callee (register pressure prevents reuse across uses). Thus its dynamic stack traffic per call is $1 + u_i$ words.\n- Parameters passed in argument registers cause zero dynamic stack traffic.\nArguments are assigned to registers left-to-right in the reordered list until the $R$ registers are exhausted; all remaining arguments are spilled to the stack.\n\nStarting only from core definitions of pass-by-value and calling conventions, and from the stated machine model, do the following:\n1) Derive, as a function of $N$, $R$, and the multiset $\\{u_i\\}_{i=1}^{N}$ of dynamic use counts per parameter, the number of spilled parameters and an expression for the total dynamic stack word traffic per call for an arbitrary fixed parameter order. Then, using first-principles reasoning about minimizing this cost subject to the constraint on the number of available registers, derive the minimal possible dynamic stack traffic achievable by reordering the parameters. Describe a deterministic heuristic ordering rule that attains this minimum under the model.\n2) Consider a specific call with $N = 10$ pass-by-value parameters and $R = 3$ argument registers. In the original source order, the dynamic use counts are\n$\\{u_1,u_2,\\dots,u_{10}\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$.\nCompute the minimal total dynamic stack word traffic per call that is achievable by reordering the parameters under the model above. Report only this minimal number as your final answer. No rounding is required.", "solution": "The problem statement is scrutinized and found to be valid. It is a well-posed optimization problem grounded in standard, albeit simplified, concepts of compiler design and computer architecture, specifically calling conventions and register allocation. All necessary data and definitions are provided, and there are no internal contradictions, ambiguities, or violations of scientific principles. The problem can be formalized and solved rigorously.\n\nLet $N$ be the total number of pass-by-value parameters, $R$ be the number of available general-purpose argument registers, and $\\{u_i\\}_{i=1}^{N}$ be the multiset of dynamic use counts for these parameters.\n\n**Part 1: General Derivation**\n\nThe problem specifies a calling convention where the first $R$ parameters in the list are passed in registers, and any subsequent parameters are passed on the stack. The compiler is free to reorder the parameters.\n\nFirst, we determine the number of spilled parameters for a given ordering. If the total number of parameters $N$ is less than or equal to the number of registers $R$ (i.e., $N \\le R$), all parameters can be passed in registers, and no parameters are spilled. If $N > R$, the first $R$ parameters are passed in registers, leaving the remaining $N - R$ parameters to be spilled to the stack. Thus, for any arbitrary ordering, the number of spilled parameters is $\\max(0, N - R)$.\n\nNext, we derive an expression for the total dynamic stack word traffic per call. According to the cost model:\n- A parameter passed in a register incurs $0$ stack traffic.\n- A parameter $i$ passed on the stack incurs a cost of $1$ word store by the caller and $u_i$ word loads by the callee, for a total of $1 + u_i$ dynamic stack words.\n\nLet the parameters in the chosen list order be $\\{p_1, p_2, \\dots, p_N\\}$, with corresponding use counts $\\{v_1, v_2, \\dots, v_N\\}$. Note that $\\{v_i\\}$ is a permutation of the original $\\{u_i\\}$. For this ordering, parameters $p_{R+1}, \\dots, p_N$ are spilled. The total dynamic stack traffic, $T$, is the sum of costs for these spilled parameters.\nIf $N \\le R$, $T = 0$.\nIf $N > R$, the total traffic is:\n$$ T = \\sum_{k=R+1}^{N} (1 + v_k) $$\nThis expression can be expanded:\n$$ T = \\sum_{k=R+1}^{N} 1 + \\sum_{k=R+1}^{N} v_k = (N-R) + \\sum_{k=R+1}^{N} v_k $$\nThe term $(N-R)$ represents the fixed cost of the caller storing each of the spilled parameters. This term is constant and does not depend on the parameter ordering. To minimize the total traffic $T$, we must therefore minimize the second term, $\\sum_{k=R+1}^{N} v_k$, which is the sum of the use counts of the parameters that are spilled to the stack.\n\nTo achieve this minimization, we should select the parameters with the lowest use counts to be spilled. This is logically equivalent to selecting the parameters with the highest use counts to be placed in the $R$ available registers, as this avoids incurring the largest costs of the form $(1+u_i)$.\n\nThis leads to the following deterministic ordering rule to achieve minimum stack traffic:\n1. Sort the parameters in **descending order** of their dynamic use counts, $u_i$.\n2. The compiler should arrange the parameter list in this sorted order.\n\nLet the original multiset of use counts be $\\{u_i\\}_{i=1}^{N}$. Let us sort these counts in non-decreasing (ascending) order to produce the ordered set $\\{u_{(1)}, u_{(2)}, \\dots, u_{(N)}\\}$, where $u_{(1)} \\le u_{(2)} \\le \\dots \\le u_{(N)}$.\n\nThe optimal strategy assigns the $R$ parameters with the highest use counts, $\\{u_{(N-R+1)}, \\dots, u_{(N)}\\}$, to registers. The remaining $N-R$ parameters, with the lowest use counts, $\\{u_{(1)}, \\dots, u_{(N-R)}\\}$, are spilled to the stack.\n\nThe minimal possible dynamic stack traffic, $T_{min}$, is the sum of the costs for these $N-R$ spilled parameters.\nIf $N \\le R$, $T_{min} = 0$.\nIf $N > R$, the minimal traffic is:\n$$ T_{min} = \\sum_{i=1}^{N-R} (1 + u_{(i)}) = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n\nThis strategy is provably optimal. Assume there exists an optimal assignment where a parameter $p_a$ with use count $u_a$ is in a register, and another parameter $p_b$ with use count $u_b$ is on the stack, such that $u_a < u_b$. The total cost includes the term $(1+u_b)$. If we swap them, placing $p_b$ in the register and $p_a$ on the stack, the new cost will include the term $(1+u_a)$. Since $u_a < u_b$, it follows that $(1+u_a) < (1+u_b)$, and the total cost has decreased. This contradicts the initial assumption that the assignment was optimal. Therefore, in any optimal assignment, every parameter in a register must have a use count greater than or equal to that of any parameter on the stack. The prescribed sorting rule achieves this condition.\n\n**Part 2: Specific Calculation**\n\nWe are given a specific call with:\n- Total number of parameters: $N = 10$\n- Number of argument registers: $R = 3$\n- Multiset of dynamic use counts: $\\{u_i\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$\n\nFirst, we determine the number of spilled parameters. Since $N > R$, there will be $N - R = 10 - 3 = 7$ parameters spilled to the stack. The remaining $R=3$ parameters will be passed in registers.\n\nTo minimize the total dynamic stack traffic, we must spill the $7$ parameters with the lowest use counts. We begin by sorting the multiset of use counts in non-decreasing order:\n$$ \\{0, 0, 1, 1, 1, 2, 3, 5, 8, 13\\} $$\nThe $R = 3$ parameters with the highest use counts, which are $\\{13, 8, 5\\}$, are placed in registers. Their contribution to stack traffic is $0$.\n\nThe $N-R = 7$ parameters with the lowest use counts, which are $\\{0, 0, 1, 1, 1, 2, 3\\}$, are spilled to the stack.\n\nThe minimal total dynamic stack traffic, $T_{min}$, is the sum of the costs for these $7$ spilled parameters. We use the formula derived in Part 1:\n$$ T_{min} = \\sum_{i=1}^{7} (1 + u_{(i)}) $$\nwhere $\\{u_{(i)}\\}_{i=1}^7$ are the $7$ lowest use counts.\n$$ T_{min} = (1 + 0) + (1 + 0) + (1 + 1) + (1 + 1) + (1 + 1) + (1 + 2) + (1 + 3) $$\n$$ T_{min} = 1 + 1 + 2 + 2 + 2 + 3 + 4 $$\n$$ T_{min} = 15 $$\nAlternatively, using the other form of the equation:\n$$ T_{min} = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n$$ T_{min} = 7 + (0 + 0 + 1 + 1 + 1 + 2 + 3) $$\n$$ T_{min} = 7 + 8 $$\n$$ T_{min} = 15 $$\nThe minimal total dynamic stack word traffic per call is $15$.", "answer": "$$\\boxed{15}$$", "id": "3661409"}]}