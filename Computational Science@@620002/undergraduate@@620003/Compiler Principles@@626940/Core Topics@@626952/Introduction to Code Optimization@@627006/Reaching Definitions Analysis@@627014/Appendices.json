{"hands_on_practices": [{"introduction": "To master reaching definitions analysis, we must begin with its fundamental building blocks: the `GEN` and `KILL` sets. This first exercise challenges you to apply these formal definitions to a seemingly trivial, yet highly instructive, case: a self-assignment like $x = x$. By determining the `GEN` and `KILL` sets for this single instruction, you will solidify your understanding that a \"definition\" is the act of assignment itself, which generates a new definition site and definitively kills all previous definitions of that variable, regardless of the value being assigned[@problem_id:3665861].", "problem": "In the classical forward bit-vector data-flow problem of reaching definitions for imperative programs without pointers or aliasing, a definition is any assignment to a variable. Consider the following program fragment with labeled assignment sites, where each label denotes a unique definition site:\n- $d_{1}$: $x = 1$\n- $d_{2}$: $y = x$\n- $d_{3}$: $x = y$\n- $d_{4}$: $z = 0$\n- $d_{5}$: $x = x$\n- $d_{6}$: $x = z$\n- $d_{7}$: $w = x$\n- $d_{8}$: $x = 3$\n\nLet $B$ be a basic block that contains exactly the single statement $d_{5}$ (that is, the self-assignment $x = x$). Using the standard definition of the generator set $\\mathrm{GEN}[B]$ and the killer set $\\mathrm{KILL}[B]$ for reaching definitions under kill-by-variable-name semantics (no aliasing and no indirection), determine whether the self-assignment $x = x$ kills previous definitions of $x$ and whether it generates a new definition site for $x$. Then, compute the value of the cardinality\n$$\\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right|.$$\n\nProvide your final answer as a single integer. No rounding is required, and no physical units are involved.", "solution": "The problem is valid. It is a well-posed question within the established formal framework of data-flow analysis in compiler theory. All terms are standard and clearly defined, and the premises are consistent.\n\nThe problem requires us to determine the generator set $\\mathrm{GEN}[B]$ and the killer set $\\mathrm{KILL}[B]$ for a specific basic block $B$ in the context of reaching definitions analysis. Reaching definitions is a forward data-flow problem that determines for each point in a program which definitions (i.e., assignments to variables) may have been the last one to define the value of a variable.\n\nFirst, we formalize the definitions of the $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets for a basic block $B$. Let $D$ be the set of all definition sites in the entire program.\n- The generator set, $\\mathrm{GEN}[B]$, is the set of definitions within block $B$ that reach the end of $B$. A definition $d: v = \\dots$ within $B$ reaches the end of $B$ if there are no subsequent definitions of the same variable $v$ within $B$.\n- The killer set, $\\mathrm{KILL}[B]$, is the set of definitions in the entire program (but outside of $B$) that are killed by one or more definitions within $B$. A definition $d': v = \\dots$ is killed by a definition $d: v = \\dots$ if they both assign to the same variable $v$.\n\nThe problem provides a set of $8$ unique definition sites in the program:\n$D = \\{d_{1}, d_{2}, d_{3}, d_{4}, d_{5}, d_{6}, d_{7}, d_{8}\\}$.\nThe definitions are:\n- $d_{1}: x = 1$\n- $d_{2}: y = x$\n- $d_{3}: x = y$\n- $d_{4}: z = 0$\n- $d_{5}: x = x$\n- $d_{6}: x = z$\n- $d_{7}: w = x$\n- $d_{8}: x = 3$\n\nThe basic block $B$ consists of the single statement $d_{5}: x = x$.\n\nWe now compute $\\mathrm{GEN}[B]$.\nThe block $B$ contains only one definition, $d_{5}$. Since there are no subsequent statements in $B$, this definition is not superseded within the block. Therefore, the definition $d_{5}$ reaches the end of block $B$. This means that $d_{5}$ is generated by $B$.\nThus, the generator set is:\n$$ \\mathrm{GEN}[B] = \\{d_{5}\\} $$\nThe self-assignment $d_{5}: x=x$ does indeed generate a new definition site for $x$. The value assigned is irrelevant; the act of assignment to the variable $x$ creates a new definition.\n\nNext, we compute $\\mathrm{KILL}[B]$.\nThe definition $d_{5}$ in block $B$ is an assignment to the variable $x$. According to the \"kill-by-variable-name\" semantics, this definition kills all other definitions of the variable $x$ in the program.\nFirst, we must identify all definitions of the variable $x$ in the entire program. These are:\n- $d_{1}: x = 1$\n- $d_{3}: x = y$\n- $d_{5}: x = x$\n- $d_{6}: x = z$\n- $d_{8}: x = 3$\nThe set of all definitions of $x$ is $\\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\}$.\nThe definition $d_{5}$ in block $B$ kills all other definitions of $x$. The other definitions of $x$ are $\\{d_{1}, d_{3}, d_{6}, d_{8}\\}$. These are the definitions that are in the set of all program definitions $D$ but are not $d_{5}$ itself. The $\\mathrm{KILL}[B]$ set, by definition, contains definitions from *outside* block $B$. Since $d_{5}$ is the only definition inside $B$, the set of definitions killed by $B$ is precisely this set of other definitions of $x$. A definition does not kill itself in the sense of appearing in the KILL set.\nThus, the killer set is:\n$$ \\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{6}, d_{8}\\} $$\nThis confirms that the assignment $d_5: x=x$ kills previous definitions of $x$.\n\nThe problem asks for the cardinality of the union of these two sets: $|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]|$.\nWe have:\n- $\\mathrm{GEN}[B] = \\{d_{5}\\}$\n- $\\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{6}, d_{8}\\}$\n\nBy their definitions, $\\mathrm{GEN}[B]$ contains definitions from inside block $B$, while $\\mathrm{KILL}[B]$ contains definitions from outside block $B$. Therefore, the two sets are disjoint:\n$$ \\mathrm{GEN}[B] \\cap \\mathrm{KILL}[B] = \\emptyset $$\n\nThe union of the two sets is:\n$$ \\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B] = \\{d_{5}\\} \\cup \\{d_{1}, d_{3}, d_{6}, d_{8}\\} = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\} $$\n\nThe cardinality of a set is the number of elements it contains. The cardinality of the union is the sum of the cardinalities of the individual sets since they are disjoint:\n$$ \\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right| = |\\mathrm{GEN}[B]| + |\\mathrm{KILL}[B]| $$\nThe cardinalities of the individual sets are:\n- $|\\mathrm{GEN}[B]| = 1$\n- $|\\mathrm{KILL}[B]| = 4$\n\nTherefore, the cardinality of the union is:\n$$ \\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right| = 1 + 4 = 5 $$\nThe final value is $5$.", "answer": "$$\n\\boxed{5}\n$$", "id": "3665861"}, {"introduction": "With a solid grasp of `GEN` and `KILL` sets for a single block, we can now analyze how definitions propagate through more complex control flow. This practice uses a C-like `switch` statement, complete with fallthrough semantics and conditional definitions, to model a realistic scenario[@problem_id:3665852]. You will trace definitions across multiple branching and merging paths, applying the set union meet operator at control-flow joins to conservatively determine the full set of definitions that may reach the program point after the `switch`. This exercise is crucial for learning how to handle the path explosion problem in a sound and systematic way.", "problem": "You are given a C-like fragment with a multi-way branch that includes implicit fallthrough between labeled blocks. All variables are of integral type. Consider only definitions (assignments) of the single variable $x$. The code is:\n\nint $x$ = $-1$; /* $D_1$ */\nswitch ($s$) {\n  case $0$:\n    if ($u$) { $x$ = $0$; } /* $D_2$ */\n    /* fallthrough */\n  case $1$:\n    $y$ = $x$ + $1$;\n    break;\n  case $2$:\n    $x$ = $20$; /* $D_3$ */\n    /* fallthrough */\n  case $3$:\n    $a$ = $3$;\n    /* fallthrough */\n  case $4$:\n    $x$ = $40$; /* $D_4$ */\n    break;\n  default:\n    if ($v$) { $x$ = $50$; } /* $D_5$ */\n    /* else: no definition of $x$ */\n    /* no break: falls out of the switch */\n}\n$w$ = $x$;\n\nAssume standard C-like $switch$ semantics: control transfers to the first matching label and, in the absence of a $break$, continues sequentially through subsequent labeled blocks (including into the $default$ block if it follows), with $break$ exiting the $switch$. The predicates $u$ and $v$ are nondeterministic booleans, and the analysis must conservatively consider all feasible paths given these semantics. At the point immediately after the $switch$ (just before the assignment $w = x$), perform classical forward may-reaching-definitions analysis for the single variable $x$.\n\nLet the five distinct definitions of $x$ be identified as $D_1, D_2, D_3, D_4, D_5$ in their order of appearance in the program text, as annotated in comments above. Encode the set of reaching definitions of $x$ at the $switch$ exit into a bit vector of length $5$ where bit $i$ corresponds to $D_i$, with $D_1$ mapped to the least significant bit (weight $2^{0}$) and $D_5$ to the most significant bit (weight $2^{4}$). Interpret this bit vector as a nonnegative integer in base $2$.\n\nWhat is this integer? Provide a single exact integer. No rounding is required.", "solution": "The problem is valid as it is a well-defined exercise in classical data-flow analysis, a core topic in compiler theory. It is scientifically grounded, objective, and contains all necessary information for a unique solution.\n\nThe objective is to perform a forward 'may' reaching-definitions analysis for the variable $x$. A definition $D$ of a variable $x$ is said to reach a program point $P$ if there exists at least one control-flow path from the point immediately following $D$ to $P$, along which $x$ is not redefined. We are interested in the set of all such definitions that reach the point immediately after the `switch` statement.\n\nLet the set of all definitions of $x$ be $\\mathcal{D} = \\{D_1, D_2, D_3, D_4, D_5\\}$. The analysis proceeds by tracking the set of reaching definitions, $RD$, through the program's control flow graph.\n\n1.  **Initial State**: Before the `switch` statement, the first definition $D_1: x = -1$ occurs. Therefore, the set of reaching definitions at the entry of the `switch` statement is $RD_{entry} = \\{D_1\\}$.\n\n2.  **Path Analysis through the `switch`**: We must consider all possible paths, which are determined by the value of the `switch` variable $s$ and the nondeterministic predicates $u$ and $v$.\n\n    *   **Path for $s=0$**:\n        Control transfers to `case 0`. The incoming $RD$ set is $\\{D_1\\}$.\n        The program encounters `if ($u$) { $x = 0$; }`, which is definition $D_2$.\n        - If $u$ is true, $D_2$ is executed. $D_2$ kills $D_1$ (and all other definitions of $x$). The $RD$ set becomes $\\{D_2\\}$.\n        - If $u$ is false, the `if` block is skipped, and the $RD$ set remains $\\{D_1\\}$.\n        Since this is a 'may' analysis, we take the union of the outcomes of the two branches. At the point after the `if`, $RD = \\{D_1\\} \\cup \\{D_2\\} = \\{D_1, D_2\\}$.\n        Control then falls through to `case 1`. The statement `y = x + 1;` uses $x$ but does not redefine it, so the $RD$ set is unchanged.\n        The `break` statement is executed, and control exits the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_1, D_2\\}$.\n\n    *   **Path for $s=1$**:\n        Control transfers to `case 1`. The incoming $RD$ set is $\\{D_1\\}$.\n        The statement `y = x + 1;` does not redefine $x$.\n        The `break` statement exits the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_1\\}$.\n\n    *   **Path for $s=2$**:\n        Control transfers to `case 2`. The incoming $RD$ set is $\\{D_1\\}$.\n        The definition $D_3: x = 20$ is executed, killing $D_1$. The $RD$ set becomes $\\{D_3\\}$.\n        Control falls through to `case 3`. The statement `a = 3;` does not affect $x$, so the $RD$ set is still $\\{D_3\\}$.\n        Control falls through to `case 4`. The definition $D_4: x = 40$ is executed, killing $D_3$. The $RD$ set becomes $\\{D_4\\}$.\n        The `break` statement exits the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_4\\}$.\n\n    *   **Path for $s=3$**:\n        Control transfers to `case 3`. The incoming $RD$ set is $\\{D_1\\}$.\n        The statement `a = 3;` does not affect $x$.\n        Control falls through to `case 4`. The definition $D_4: x = 40$ is executed, killing $D_1$. The $RD$ set becomes $\\{D_4\\}$.\n        The `break` statement exits the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_4\\}$.\n\n    *   **Path for $s=4$**:\n        Control transfers to `case 4`. The incoming $RD$ set is $\\{D_1\\}$.\n        The definition $D_4: x = 40$ is executed, killing $D_1$. The $RD$ set becomes $\\{D_4\\}$.\n        The `break` statement exits the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_4\\}$.\n\n    *   **Path for `default`**:\n        Control transfers to the `default` block for any other value of $s$. The incoming $RD$ set is $\\{D_1\\}$.\n        The program encounters `if ($v$) { $x = 50$; }`, which is definition $D_5$.\n        - If $v$ is true, $D_5$ is executed, killing $D_1$. The $RD$ set becomes $\\{D_5\\}$.\n        - If $v$ is false, the `if` block is skipped, and the $RD$ set remains $\\{D_1\\}$.\n        At the merge point after the `if`, the union is $RD = \\{D_1\\} \\cup \\{D_5\\} = \\{D_1, D_5\\}$.\n        There is no `break`, so control falls out of the `switch`.\n        Thus, the set of definitions reaching the exit via this path is $\\{D_1, D_5\\}$.\n\n3.  **Final Set of Reaching Definitions**: The set of all definitions that 'may' reach the program point after the `switch` is the union of the sets from all possible entry points into the `switch` statement.\n    $RD_{exit} = \\underbrace{\\{D_1, D_2\\}}_{s=0} \\cup \\underbrace{\\{D_1\\}}_{s=1} \\cup \\underbrace{\\{D_4\\}}_{s=2} \\cup \\underbrace{\\{D_4\\}}_{s=3} \\cup \\underbrace{\\{D_4\\}}_{s=4} \\cup \\underbrace{\\{D_1, D_5\\}}_{\\text{default}}$\n    $RD_{exit} = \\{D_1, D_2, D_4, D_5\\}$.\n    Note that definition $D_3$ does not reach the exit. Any path that executes $D_3$ must fall through to `case 4`, where $D_4$ is executed, thus killing $D_3$ before the path can exit the `switch`.\n\n4.  **Bit Vector Encoding**: The problem requires encoding this set into an integer. The bit vector has $5$ bits, where the $i$-th bit (1-indexed) corresponds to definition $D_i$. $D_1$ is the least significant bit (LSB, position $0$, weight $2^0$) and $D_5$ is the most significant bit (MSB, position $4$, weight $2^4$).\nThe bit vector is $(b_4, b_3, b_2, b_1, b_0)$, where $b_{i-1}=1$ if $D_i \\in RD_{exit}$ and $b_{i-1}=0$ otherwise.\n- $D_1 \\in RD_{exit} \\implies b_0 = 1$\n- $D_2 \\in RD_{exit} \\implies b_1 = 1$\n- $D_3 \\notin RD_{exit} \\implies b_2 = 0$\n- $D_4 \\in RD_{exit} \\implies b_3 = 1$\n- $D_5 \\in RD_{exit} \\implies b_4 = 1$\nThe resulting binary number is $11011_2$.\n\n5.  **Integer Conversion**: We convert the binary number to its base-$10$ integer representation.\n    Value $= 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$\n    Value $= 16 + 8 + 0 + 2 + 1 = 27$.", "answer": "$$\n\\boxed{27}\n$$", "id": "3665852"}, {"introduction": "The true power of data-flow analysis is revealed when dealing with loops, where control flow can cycle back, potentially changing the analysis results. This final practice introduces a control-flow graph with a loop, requiring you to apply the data-flow equations iteratively until a stable \"fixed point\" is reached[@problem_id:3665885]. Furthermore, by modifying the graph to make a code block unreachable, this problem demonstrates the direct link between the abstract analysis and its practical application in identifying and eliminating dead code, a key compiler optimization.", "problem": "Consider the following tiny Control Flow Graph (CFG) for a single-procedure program manipulating a single variable $x$. The variable $x$ is used in the loop header to control iteration. Blocks are labeled $B_0$ through $B_6$, and edges are explicitly listed. All assignments to $x$ are distinct definitions. The pseudo-code per basic block is:\n- $B_0$: entry; unconditional jump to $B_1$.\n- $B_1$: if $c_1$ then goto $B_2$ else goto $B_5$.\n- $B_2$: $x := 10$; goto $B_3$.\n- $B_3$: while ($x  n$) goto $B_4$ else goto $B_6$; this is the loop header using $x$.\n- $B_4$: $x := x + 1$; goto $B_3$.\n- $B_5$: $x := 20$; goto $B_3$.\n- $B_6$: exit.\n\nLet the three distinct definitions of $x$ be denoted by $d_2$ at $B_2$, $d_4$ at $B_4$, and $d_5$ at $B_5$. Assume the standard forward, may (set-union) reaching definitions analysis over this Control Flow Graph, with the usual interpretation that a definition reaches a program point if there exists a path from the definition to that point along which the variable is not redefined. Use the conventional block-local sets $GEN[b]$ and $KILL[b]$ and the standard data-flow equations for reaching definitions, and assume that the $KILL$ set for a definition of $x$ consists of all other definitions of $x$ in the program (irrespective of reachability). Assume $IN[B_0] = \\varnothing$.\n\nTasks:\n- First, analyze the original Control Flow Graph above and determine which of $d_2$, $d_4$, and $d_5$ reach the loop header $B_3$ at steady state (fixed point).\n- Next, make $B_5$ unreachable by deleting the edge from $B_1$ to $B_5$ (so that $B_1$ now has only the edge to $B_2$), leaving all other blocks and edges unchanged. Reanalyze reaching definitions and determine which of $d_2$, $d_4$, and $d_5$ reach the loop header $B_3$ at steady state in this modified Control Flow Graph.\n- Let $\\kappa$ denote the cardinality of the set $IN[B_3]$ in the modified Control Flow Graph (after $B_5$ has become unreachable). Report $\\kappa$ as your final answer. No rounding is required. Express your answer as an exact integer.", "solution": "The problem requires performing a reaching definitions analysis on a given Control Flow Graph (CFG) and then on a modified version of it. This is a standard forward, 'may' analysis problem in compiler theory. The goal is to determine, for a given program point, the set of definitions that may reach that point.\n\nThe data-flow equations for reaching definitions are:\n$$IN[b] = \\bigcup_{p \\in pred(b)} OUT[p]$$\n$$OUT[b] = GEN[b] \\cup (IN[b] \\setminus KILL[b])$$\nwhere $IN[b]$ is the set of definitions reaching the entry of a basic block $b$, $OUT[b]$ is the set of definitions reaching the exit of $b$, $pred(b)$ is the set of predecessors of $b$, $GEN[b]$ is the set of definitions generated within $b$, and $KILL[b]$ is the set of definitions in the program that are killed by definitions in $b$. The analysis proceeds by iteratively applying these equations until a fixed point is reached (i.e., the $IN$ and $OUT$ sets no longer change).\n\nThe set of all definitions in the program is $D = \\{d_2, d_4, d_5\\}$, corresponding to the assignments to variable $x$ in blocks $B_2$, $B_4$, and $B_5$, respectively.\n\nFirst, we establish the $GEN$ and $KILL$ sets for each basic block. A block $b$ that contains a definition of $x$ generates that definition. This same definition kills all other definitions of $x$ in the program.\n- $B_0$: No definition. $GEN[B_0] = \\varnothing$, $KILL[B_0] = \\varnothing$.\n- $B_1$: No definition. $GEN[B_1] = \\varnothing$, $KILL[B_1] = \\varnothing$.\n- $B_2$: Contains definition $d_2$ ($x := 10$). $GEN[B_2] = \\{d_2\\}$, $KILL[B_2] = D \\setminus \\{d_2\\} = \\{d_4, d_5\\}$.\n- $B_3$: No definition (only a use). $GEN[B_3] = \\varnothing$, $KILL[B_3] = \\varnothing$.\n- $B_4$: Contains definition $d_4$ ($x := x + 1$). $GEN[B_4] = \\{d_4\\}$, $KILL[B_4] = D \\setminus \\{d_4\\} = \\{d_2, d_5\\}$.\n- $B_5$: Contains definition $d_5$ ($x := 20$). $GEN[B_5] = \\{d_5\\}$, $KILL[B_5] = D \\setminus \\{d_5\\} = \\{d_2, d_4\\}$.\n- $B_6$: No definition. $GEN[B_6] = \\varnothing$, $KILL[B_6] = \\varnothing$.\n\n**Analysis of the Original Control Flow Graph**\n\nIn the original CFG, the loop header $B_3$ has three predecessors: $B_2$, $B_4$, and $B_5$. Therefore, $IN[B_3] = OUT[B_2] \\cup OUT[B_4] \\cup OUT[B_5]$. We seek the steady-state value of this set.\n\n1.  A path $B_0 \\to B_1 \\to B_2 \\to B_3$ exists. The definition $d_2$ is generated in $B_2$ and is not killed along the edge $B_2 \\to B_3$. Thus, $d_2$ reaches the entry of $B_3$. At steady state, $\\{d_2\\} \\subseteq OUT[B_2]$.\n2.  A path $B_0 \\to B_1 \\to B_5 \\to B_3$ exists. The definition $d_5$ is generated in $B_5$ and is not killed along the edge $B_5 \\to B_3$. Thus, $d_5$ reaches the entry of $B_3$. At steady state, $\\{d_5\\} \\subseteq OUT[B_5]$.\n3.  The loop creates a path $B_3 \\to B_4 \\to B_3$. Any definition reaching the entry of $B_3$ (i.e., in $IN[B_3]$) passes through to its exit (since $KILL[B_3] = \\varnothing$), thus reaching the entry of $B_4$. In $B_4$, definition $d_4$ is generated, and all other definitions ($d_2, d_5$) are killed. Thus, $OUT[B_4]$ will contain $d_4$. This definition flows back to the entry of $B_3$ along the edge $B_4 \\to B_3$.\n\nCombining these, the set of definitions reaching the entry of $B_3$ is the union of definitions arriving from its predecessors. At the fixed point, we have:\n- $OUT[B_2]$ contains $d_2$.\n- $OUT[B_5]$ contains $d_5$.\n- $OUT[B_4]$ contains $d_4$.\nTherefore, for the original CFG, $IN[B_3] = \\{d_2, d_4, d_5\\}$.\n\n**Analysis of the Modified Control Flow Graph**\n\nThe CFG is modified by deleting the edge from $B_1$ to $B_5$. We must re-evaluate the reaching definitions for the loop header $B_3$.\n\nThe crucial consequence of this modification is that block $B_5$ becomes unreachable. There is no longer any path from the entry block $B_0$ to $B_5$. The fundamental definition of reaching definitions states that \"a definition reaches a program point if there exists a path from the definition to that point\". This implies that the definition itself must lie on an executable path starting from the program's entry. Since $B_5$ is unreachable, the definition $d_5$ contained within it can never be created during program execution. Consequently, $d_5$ cannot reach any point in the program.\n\nWhile a blind application of the data-flow equations on the graph structure might suggest that $d_5$ propagates from the isolated $B_5$ block, this would be a misinterpretation. The analysis must reflect the semantics of program execution. We can therefore effectively prune the unreachable block $B_5$ and its outgoing edge $B_5 \\to B_3$ from the analysis.\n\nIn the modified, pruned CFG, the predecessors of $B_3$ are now $pred(B_3) = \\{B_2, B_4\\}$. The set of active definitions reduces to $\\{d_2, d_4\\}$. The analysis proceeds:\n- The path $B_0 \\to B_1 \\to B_2 \\to B_3$ is unaffected. Definition $d_2$ from $B_2$ reaches the entry of $B_3$.\n- The loop path $B_3 \\to B_4 \\to B_3$ is also unaffected. Definition $d_4$ from $B_4$ reaches the entry of $B_3$.\n- The path from $B_5$ no longer exists.\n\nThus, the set of definitions reaching the entry of $B_3$ is the union of definitions from the reachable predecessors $B_2$ and $B_4$.\n$$IN[B_3] = OUT[B_2] \\cup OUT[B_4]$$\nAt the fixed point, this resolves to:\n$$IN[B_3] = \\{d_2\\} \\cup \\{d_4\\} = \\{d_2, d_4\\}$$\n\n**Final Calculation**\n\nThe problem asks for the value of $\\kappa$, defined as the cardinality of the set $IN[B_3]$ in the modified Control Flow Graph.\n$$\\kappa = |IN[B_3]| = |\\{d_2, d_4\\}|$$\n$$\\kappa = 2$$", "answer": "$$\\boxed{2}$$", "id": "3665885"}]}