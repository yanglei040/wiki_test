{"hands_on_practices": [{"introduction": "A fundamental task for any compiler or interpreter is to correctly understand and evaluate expressions. This first exercise dives into the classic problem of resolving ambiguity in expression grammars using an attribute grammar. By annotating the parse tree with attributes for precedence ($prec$) and associativity ($assoc$), you will enforce the standard order of operations and then compute the final value of the expression, demonstrating the core principle of syntax-directed evaluation [@problem_id:3621665].", "problem": "Consider the ambiguous expression grammar $G$ with the single nonterminal $E$ and productions $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$, where $\\text{num}$ denotes a positive integer literal. In the framework of an annotated parse tree and an attribute grammar, each interior node labeled by a binary operator token is to be annotated with two attributes: a numerical precedence attribute $prec$ and an associativity attribute $assoc$. The attributes should encode the conventional arithmetic intent that exponentiation binds more tightly than multiplication, which binds more tightly than addition, and that exponentiation associates to the right while multiplication and addition associate to the left. You are to use these attributes purely to disambiguate the parse by enforcing that higher-precedence operators dominate lower-precedence ones in the tree structure, and that ties at the same precedence level are broken according to associativity.\n\nLet the intended attribute values be $prec(\\text{^})=3$, $prec(*)=2$, $prec(+)=1$, and $assoc(\\text{^})=\\text{right}$, $assoc(*)=\\text{left}$, $assoc(+)=\\text{left}$. In addition, define a synthesized attribute $val$ at each $E$-node that gives the numerical value of the subexpression at that node according to the following semantic basis: if $E \\rightarrow \\text{num}$ then $val$ is the integer value of the literal; if $E \\rightarrow E_1 + E_2$ then $val = E_1.val + E_2.val$; if $E \\rightarrow E_1 * E_2$ then $val = E_1.val \\times E_2.val$; if $E \\rightarrow E_1 \\,\\text{^}\\, E_2$ then $val = E_1.val^{E_2.val}$.\n\nStarting from the foundational definitions of parse trees for context-free grammars and annotated parse trees for attribute grammars, determine the unique parenthesization enforced by the given $prec$ and $assoc$ attributes for the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$. Then, using the above semantic basis for $val$, compute the numerical value of the root node’s $val$ for the disambiguated parse of $s$. Express the final value as an exact integer. No rounding is required.", "solution": "The problem is valid as it is a well-posed, scientifically grounded exercise in compiler theory. It provides a complete and consistent set of rules (an attribute grammar) to disambiguate an expression generated by an ambiguous context-free grammar and to compute its value. All necessary data are provided, and the task is to apply these formal rules to a specific input string.\n\nThe problem requires a two-step process: first, to determine the structure of the unique parse tree for the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$ using the provided precedence and associativity attributes; and second, to compute the synthesized attribute $val$ at the root of this tree using the given semantic rules.\n\nThe grammar is given by the productions $E \\rightarrow E \\,\\text{^}\\, E \\mid E * E \\mid E + E \\mid \\text{num}$.\nThe attributes for the operators are:\nPrecedence: $prec(\\text{^})=3$ (highest), $prec(*)=2$, $prec(+)=1$ (lowest).\nAssociativity: $assoc(\\text{^})=\\text{right}$, $assoc(*)=\\text{left}$, $assoc(+)=\\text{left}$.\n\n**Step 1: Determining the Unique Parse Tree Structure (Parenthesization)**\n\nThe structure of the parse tree is dictated by operator precedence and associativity. An operator with higher precedence is applied before an operator with lower precedence, which means it will appear at a lower level in the parse tree. For operators of equal precedence, associativity determines the grouping: left-associativity implies grouping from left to right (e.g., $a+b+c$ is $(a+b)+c$), and right-associativity implies grouping from right to left (e.g., $a\\,\\text{^}\\,b\\,\\text{^}\\,c$ is $a\\,\\text{^}\\,(b\\,\\text{^}\\,c)$).\n\nLet us analyze the input string $s = 2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2 + 4 * 5 + 6$.\nThe operators present are $\\text{^}$, $\\text{^}$, $+$, $*$, $+$.\n\n1.  **Highest Precedence:** The exponentiation operator, $\\text{^}$, has the highest precedence ($prec=3$). The operators in the string involving exponentiation form the substring $2 \\,\\text{^}\\, 3 \\,\\text{^}\\, 2$. Since there are two such operators of equal precedence, we use associativity. The attribute is $assoc(\\text{^})=\\text{right}$, which means this expression is grouped from right to left. Therefore, its structure is $2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)$. This subexpression must be evaluated before any surrounding additions or multiplications. In the parse tree, the first $\\text{^}$ will be a parent to the node representing $3\\,\\text{^}\\,2$.\n\n2.  **Next Precedence:** The multiplication operator, $*$, has the next highest precedence ($prec=2$). The substring involving multiplication is $4 * 5$. Since there is only one such operator, its grouping is simply $(4 * 5)$. This must be evaluated after any exponentiations but before any additions.\n\n3.  **Lowest Precedence:** The addition operator, $+$, has the lowest precedence ($prec=1$). The original string contains two addition operators. With the higher-precedence operations now grouped, the expression string can be seen as having the structure $(2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5) + 6$. The two addition operators have equal precedence, so we use their associativity, which is $assoc(+)=\\text{left}$. This implies grouping from left to right. Therefore, the expression is grouped as $((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$.\n\nThe final, fully parenthesized expression, which uniquely specifies the structure of the disambiguated parse tree, is:\n$$((2 \\,\\text{^}\\, (3 \\,\\text{^}\\, 2)) + (4 * 5)) + 6$$\nThe root of the parse tree for this expression corresponds to the last operation performed, which is the second addition.\n\n**Step 2: Computing the Synthesized Attribute `val`**\n\nWe now compute the numerical value by evaluating the expression according to the parenthesization derived above and the semantic rules for the `val` attribute. This process is equivalent to a post-order traversal of the annotated parse tree, where the `val` attribute of a parent node is computed from the `val` attributes of its children.\n\n1.  Evaluate the innermost parenthesized expression, $(3 \\,\\text{^}\\, 2)$. The semantic rule is $E.val = (E_1.val)^{E_2.val}$.\n    $$3^2 = 9$$\n    The expression becomes $((2 \\,\\text{^}\\, 9) + (4 * 5)) + 6$.\n\n2.  Evaluate the next innermost expression, $(2 \\,\\text{^}\\, 9)$.\n    $$2^9 = 512$$\n    The expression becomes $((512) + (4 * 5)) + 6$.\n\n3.  Evaluate the other parenthesized expression at this level, $(4 * 5)$. The semantic rule is $E.val = E_1.val \\times E_2.val$.\n    $$4 \\times 5 = 20$$\n    The expression becomes $(512 + 20) + 6$.\n\n4.  Evaluate the sum inside the remaining parentheses, $(512 + 20)$. The semantic rule is $E.val = E_1.val + E_2.val$.\n    $$512 + 20 = 532$$\n    The expression becomes $532 + 6$.\n\n5.  Finally, perform the last addition.\n    $$532 + 6 = 538$$\n\nThis final result, $538$, is the value of the synthesized attribute $val$ at the root node of the disambiguated parse tree for the input string $s$.", "answer": "$$\\boxed{538}$$", "id": "3621665"}, {"introduction": "Once a compiler has parsed source code into an abstract syntax tree (AST), it often needs to regenerate a textual representation, a process known as unparsing or pretty-printing. This practice explores that reverse challenge: how to generate a string from an AST with the minimum number of parentheses required to preserve the original structure. You will derive and apply a rule based on operator precedence ($\\operatorname{prec}$) and associativity ($\\operatorname{assoc}$) to determine precisely where parentheses are necessary, reinforcing your understanding of these concepts from a code-generation perspective [@problem_id:3621753].", "problem": "Consider an infix expression language with binary operators `+`, `-`, `*`, `/`, and `^` (exponentiation), and identifiers as leaves. The language is parsed using a context-free grammar that is disambiguated by operator precedence and associativity. Each internal node of a parse tree is annotated with two synthesized attributes: $\\operatorname{prec}$, the precedence level of the node’s operator, and $\\operatorname{assoc}$, the operator’s associativity. Identifiers are leaves with no operator; for the purpose of comparison, treat leaves as having $\\operatorname{prec} = +\\infty$. The precedence and associativity are:\n- `+` and `-`: $\\operatorname{prec} = 1$, $\\operatorname{assoc} = \\mathrm{left}$.\n- `*` and `/`: $\\operatorname{prec} = 2$, $\\operatorname{assoc} = \\mathrm{left}$.\n- `^`: $\\operatorname{prec} = 3$, $\\operatorname{assoc} = \\mathrm{right}$.\n\nThe unparser must emit the infix string of a given parse tree while inserting the minimal number of parentheses needed to guarantee that reparsing the string (using the same precedence and associativity) yields exactly the original tree.\n\nStarting from the foundational definitions of precedence as an order that resolves binding strength and associativity as a tie-breaker that resolves grouping when precedences are equal, derive an attribute-based decision rule that, for each parent node with operator precedence $\\operatorname{prec}_{p}$ and associativity $\\operatorname{assoc}_{p}$, determines whether to parenthesize a given child subtree based only on the child’s root operator precedence $\\operatorname{prec}_{c}$ and whether the child is the left or right child. Then, apply your derived rule to the concrete parse tree $T$ defined as follows:\n- The root of $T$ is operator `-` with left child $A$ and right child $B$.\n- Subtree $A$ has root `/` with left child $A_{1}$ and right child $A_{2}$.\n- Subtree $A_{1}$ has root `+` with leaves $a$ and $b$.\n- Subtree $A_{2}$ has root `*` with left leaf $c$ and right child $A_{2b}$.\n- Subtree $A_{2b}$ has root `^` with leaves $d$ and $e$.\n- Subtree $B$ has root `^` with left child $B_{1}$ and right child $B_{2}$.\n- Subtree $B_{1}$ has root `^` with leaves $f$ and $g$.\n- Subtree $B_{2}$ has root `+` with leaves $h$ and $i$.\n\nCompute the total number of parenthesis pairs that the minimal-parentheses unparser inserts when emitting the infix string for $T$. Express your final answer as an integer.", "solution": "The problem requires the derivation of a minimal parenthesization rule for unparsing an expression from its annotated parse tree and then applying this rule to a specific tree $T$ to count the number of parenthesis pairs. The goal is to ensure that reparsing the unparsed string yields the original tree structure. The disambiguation of the grammar is based on operator precedence and associativity.\n\nFirst, we derive the general decision rule. Let a parent node in the parse tree represent an operation with operator $op_p$, precedence $\\operatorname{prec}_{p}$, and associativity $\\operatorname{assoc}_{p}$. Let one of its children be a subtree whose root node represents an operation with operator $op_c$, precedence $\\operatorname{prec}_{c}$, and associativity $\\operatorname{assoc}_{c}$. The unparsed string will place the subexpression corresponding to the child adjacent to the parent's operator. Parentheses are required around the child's subexpression if, and only if, the default precedence and associativity rules would cause the parent's operator $op_p$ to bind to one of the child's operator $op_c$'s operands, thus altering the tree structure upon reparsing.\n\nWe analyze the conditions for parenthesization based on the relationship between $\\operatorname{prec}_{p}$ and $\\operatorname{prec}_{c}$.\n\n1.  **Case: $\\operatorname{prec}_{c} > \\operatorname{prec}_{p}$**\n    The child's operator $op_c$ has higher precedence than the parent's operator $op_p$. By definition of precedence, $op_c$ binds its operands more tightly than $op_p$. For example, in the expression $a - b * c$, '*' has higher precedence than '-'. The string is naturally parsed as $a - (b * c)$, which corresponds to a tree where '*' is a child of '-'. Thus, the original structure is preserved without parentheses. No parentheses are needed.\n\n2.  **Case: $\\operatorname{prec}_{c} < \\operatorname{prec}_{p}$**\n    The child's operator $op_c$ has lower precedence than the parent's operator $op_p$. Without parentheses, the higher-precedence parent operator $op_p$ would \"steal\" an operand from $op_c$. For example, if the tree structure is $a * (b + c)$, the parent operator is '*' and the child operator is '+'. Unparsing without parentheses yields $a * b + c$, which would be reparsed as $(a * b) + c$, altering the structure. To enforce the original grouping, parentheses are mandatory: $a * (b + c)$. Parentheses are always needed.\n\n3.  **Case: $\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$**\n    The operators have equal precedence. Here, associativity rules act as a tie-breaker.\n    - **Subcase 3a: The child is the left child of the parent.** The expression form is $(E_c) \\ op_p \\ E_{other}$. The unparsed string without parentheses would be $... op_c ... op_p ...$.\n        - If $\\operatorname{assoc}_{p}$ is **left**, operators are grouped from left to right. The parser would form $(... op_c ...) \\ op_p ...$, which matches the original tree structure. No parentheses are needed.\n        - If $\\operatorname{assoc}_{p}$ is **right**, operators are grouped from right to left. The parser would form $... op_c (... op_p ...)$, which contradicts the original tree structure. To force the left-to-right grouping intended by the tree, parentheses are required around the left child's expression.\n    - **Subcase 3b: The child is the right child of the parent.** The expression form is $E_{other} \\ op_p \\ (E_c)$. The unparsed string without parentheses would be $... op_p ... op_c ...$.\n        - If $\\operatorname{assoc}_{p}$ is **left**, operators are grouped from left to right. The parser would form $(... op_p ...) \\ op_c ...$, which contradicts the original tree. Parentheses are required around the right child's expression to enforce the intended right-to-left grouping relative to $op_p$.\n        - If $\\operatorname{assoc}_{p}$ is **right**, operators are grouped from right to left. The parser would form $... op_p (... op_c ...)$, which matches the original tree structure. No parentheses are needed.\n\n**Summary of the Parenthesization Rule:**\nA child subexpression with root operator $op_c$ must be parenthesized if its parent operator is $op_p$ and any of the following conditions hold:\n1.  $\\operatorname{prec}_{c} < \\operatorname{prec}_{p}$.\n2.  $\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$ and the child is the **left** child, and $\\operatorname{assoc}_{p}$ is **right**.\n3.  $\\operatorname{prec}_{c} = \\operatorname{prec}_{p}$ and the child is the **right** child, and $\\operatorname{assoc}_{p}$ is **left**.\n\nLeaves (identifiers) are given $\\operatorname{prec} = +\\infty$. Since an identifier can never have a precedence lower than or equal to any operator, it will never be parenthesized according to this rule.\n\nNow, we apply this rule to the given tree $T$. The operator attributes are:\n-   `+` and `-`: $\\operatorname{prec} = 1$, $\\operatorname{assoc} = \\mathrm{left}$.\n-   `*` and `/`: $\\operatorname{prec} = 2$, $\\operatorname{assoc} = \\mathrm{left}$.\n-   `^`: $\\operatorname{prec} = 3$, $\\operatorname{assoc} = \\mathrm{right}$.\n\nWe traverse the tree and check the condition for each parent-child pair where the child is not a leaf.\n\n-   **Parent: `-` (root of T)** ($\\operatorname{prec}_{p}=1, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   Left Child: Subtree $A$, root is `/` ($\\operatorname{prec}_{c}=2$).\n        -   Condition check: $\\operatorname{prec}_{c} = 2 > \\operatorname{prec}_{p} = 1$. No parentheses.\n    -   Right Child: Subtree $B$, root is `^` ($\\operatorname{prec}_{c}=3$).\n        -   Condition check: $\\operatorname{prec}_{c} = 3 > \\operatorname{prec}_{p} = 1$. No parentheses.\n\n-   **Parent: `/` (root of A)** ($\\operatorname{prec}_{p}=2, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   Left Child: Subtree $A_1$, root is `+` ($\\operatorname{prec}_{c}=1$).\n        -   Condition check: $\\operatorname{prec}_{c} = 1 < \\operatorname{prec}_{p} = 2$. Rule 1 applies. **Parenthesize (1)**.\n    -   Right Child: Subtree $A_2$, root is `*` ($\\operatorname{prec}_{c}=2$).\n        -   Condition check: $\\operatorname{prec}_{c} = 2 = \\operatorname{prec}_{p} = 2$. This is the right child, and $\\operatorname{assoc}_{p}$ is left. Rule 3 applies. **Parenthesize (2)**.\n\n-   **Parent: `*` (in Subtree $A_2$)** ($\\operatorname{prec}_{p}=2, \\operatorname{assoc}_{p}=\\mathrm{left}$)\n    -   Right Child: Subtree $A_{2b}$, root is `^` ($\\operatorname{prec}_{c}=3$).\n        -   Condition check: $\\operatorname{prec}_{c} = 3 > \\operatorname{prec}_{p} = 2$. No parentheses.\n\n-   **Parent: `^` (root of B)** ($\\operatorname{prec}_{p}=3, \\operatorname{assoc}_{p}=\\mathrm{right}$)\n    -   Left Child: Subtree $B_1$, root is `^` ($\\operatorname{prec}_{c}=3$).\n        -   Condition check: $\\operatorname{prec}_{c} = 3 = \\operatorname{prec}_{p} = 3$. This is the left child, and $\\operatorname{assoc}_{p}$ is right. Rule 2 applies. **Parenthesize (3)**.\n    -   Right Child: Subtree $B_2$, root is `+` ($\\operatorname{prec}_{c}=1$).\n        -   Condition check: $\\operatorname{prec}_{c} = 1 < \\operatorname{prec}_{p} = 3$. Rule 1 applies. **Parenthesize (4)**.\n\nAll other non-leaf nodes have only leaves as children. As established, leaf nodes (identifiers with $\\operatorname{prec}=+\\infty$) are never parenthesized.\n\nThe analysis yields a total of $4$ cases where parentheses are required:\n1.  Around the subtree $A_1$ ($a+b$), because its parent is `/` ($\\operatorname{prec}=2$) and its root is `+` ($\\operatorname{prec}=1$).\n2.  Around the subtree $A_2$ ($c*(d^e)$), because its parent is `/` ($\\operatorname{prec}=2$, left-assoc) and its root is `*` ($\\operatorname{prec}=2$), and it is the right child.\n3.  Around the subtree $B_1$ ($f^g$), because its parent is `^` ($\\operatorname{prec}=3$, right-assoc) and its root is `^` ($\\operatorname{prec}=3$), and it is the left child.\n4.  Around the subtree $B_2$ ($h+i$), because its parent is `^` ($\\operatorname{prec}=3$) and its root is `+` ($\\operatorname{prec}=1$).\n\nThe total count of required parenthesis pairs is $4$.\nThe resulting string would be: $((a+b) / (c * d^e)) - ((f^g)^(h+i))$.\n\nThe total number of parenthesis pairs inserted is $4$.", "answer": "$$\\boxed{4}$$", "id": "3621753"}, {"introduction": "Annotated parse trees are not just for ensuring correctness; they are also a powerful tool for optimization. This advanced exercise applies attribute grammars to the domain of matrix computations, a classic problem where evaluation order dramatically affects performance. By defining `shape` and `cost` attributes, you will implement a form of dynamic programming directly on the parse tree to find the most efficient way to multiply a chain of matrices, showcasing how syntax-directed analysis can solve complex optimization problems [@problem_id:3621717].", "problem": "You are given the ambiguous context-free grammar (Context-Free Grammar (CFG)) for matrix expressions\n$$\nM \\to M * M \\mid M + M \\mid M^{\\top} \\mid \\text{id},\n$$\nwhere $\\text{id}$ denotes a matrix identifier. Define a synthesized-attribute specification that annotates every parse tree node with two attributes:\n- $shape \\in \\mathbb{N} \\times \\mathbb{N}$, giving the matrix dimensions $(rows, cols)$ of the subexpression, and\n- $cost \\in \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$, giving a scalar-operation cost of evaluating the subexpression.\n\nAssume the following foundational rules for typing and cost:\n- If $X$ has shape $(r,k)$ and $Y$ has shape $(k,c)$, then $X * Y$ has shape $(r,c)$ and costs $r \\cdot k \\cdot c$.\n- If $X$ and $Y$ have the same shape $(r,c)$, then $X + Y$ has shape $(r,c)$ and costs $r \\cdot c$.\n- If $X$ has shape $(r,c)$, then $X^{\\top}$ has shape $(c,r)$ and costs $0$.\n- Each identifier $\\text{id}$ has a known shape from the symbol table and costs $0$.\n- Any ill-typed combination yields $cost = \\infty$ and an undefined $shape$.\n\nBecause the grammar is ambiguous for $*$ and $+$, interpret the attributes for a nonterminal $M$ as selecting, among all parse trees for the same terminal string, the finite $cost$ minimum, with $shape$ taken from the minimizing alternative.\n\nUsing this attribute-based interpretation, compute the minimal total $cost$ for the expression\n$$\nA * B * C \\; + \\; D^{\\top} * E,\n$$\nunder the symbol table\n- $A : (10,100)$,\n- $B : (100,5)$,\n- $C : (5,50)$,\n- $D : (50,10)$,\n- $E : (50,50)$.\n\nUnary transpose $^{\\top}$ binds more tightly than binary operators; binary operators are fully parenthesized by the parse and may be grouped in any way consistent with token order. Provide the minimal total $cost$ as an exact integer (no rounding). Do not include any units in your final answer.", "solution": "The problem requires finding the minimum evaluation cost for a matrix expression by resolving its grammatical ambiguity. This is a classic optimization problem, an extension of the matrix chain multiplication problem, which can be solved using dynamic programming. The \"attribute-based interpretation\" described is equivalent to finding the optimal parenthesization of the entire expression string.\n\nThe expression is $A * B * C + D^{\\top} * E$. The unary transpose $^{\\top}$ has the highest precedence, so we first evaluate its operand.\n\n1.  **Operand Attributes:**\n    -   $A$: shape $(10, 100)$, cost $0$.\n    -   $B$: shape $(100, 5)$, cost $0$.\n    -   $C$: shape $(5, 50)$, cost $0$.\n    -   $D$: shape $(50, 10)$, cost $0$.\n    -   $D^{\\top}$: shape $(10, 50)$, cost $0$.\n    -   $E$: shape $(50, 50)$, cost $0$.\n\nLet the sequence of operands be $M_1=A, M_2=B, M_3=C, M_4=D^{\\top}, M_5=E$. The operators between them are $op_1=*, op_2=*, op_3=+, op_4=*$. We need to find the minimum cost to evaluate the chain $M_1 \\, op_1 \\, M_2 \\, op_2 \\, M_3 \\, op_3 \\, M_4 \\, op_4 \\, M_5$.\n\nWe define $C[i,j]$ as the minimum cost for the sub-expression from $M_i$ to $M_j$, and $S[i,j]$ as its resulting shape. A sub-expression is only valid if all operations are well-typed (i.e., shapes are compatible).\n\n2.  **Dynamic Programming Calculation:** We find the minimum cost for all contiguous sub-chains of increasing length.\n\n    -   **Length 2 Sub-chains:**\n        -   $A*B$: $S[1,2]=(10,5)$, $C[1,2] = 10 \\cdot 100 \\cdot 5 = 5000$.\n        -   $B*C$: $S[2,3]=(100,50)$, $C[2,3] = 100 \\cdot 5 \\cdot 50 = 25000$.\n        -   $C+D^{\\top}$: $S(C)=(5,50)$, $S(D^{\\top})=(10,50)$. Shapes mismatch. $C[3,4]=\\infty$.\n        -   $D^{\\top}*E$: $S[4,5]=(10,50)$, $C[4,5] = 10 \\cdot 50 \\cdot 50 = 25000$.\n\n    -   **Length 3 Sub-chains:**\n        -   $A*B*C$: We compare $(A*B)*C$ and $A*(B*C)$.\n            -   Cost($(A*B)*C$): $C[1,2] + C[3,3] + 10 \\cdot 5 \\cdot 50 = 5000 + 0 + 2500 = 7500$.\n            -   Cost($A*(B*C)$): $C[1,1] + C[2,3] + 10 \\cdot 100 \\cdot 50 = 0 + 25000 + 50000 = 75000$.\n            -   Minimum is $7500$. So, $C[1,3]=7500$ and $S[1,3]=(10,50)$.\n        -   $B*C+D^{\\top}$ and $C+D^{\\top}*E$ involve ill-typed additions, so their costs are $\\infty$.\n\n    -   **Length 4 Sub-chains:**\n        -   $A*B*C+D^{\\top}$: The only valid grouping is $(A*B*C)+D^{\\top}$.\n            -   $S[1,3]=(10,50)$ and $S[4,4]=(10,50)$. Shapes match for addition.\n            -   Cost is $C[1,3] + C[4,4] + (10 \\cdot 50) = 7500 + 0 + 500 = 8000$.\n            -   $C[1,4]=8000$ and $S[1,4]=(10,50)$.\n        -   $B*C+D^{\\top}*E$: All groupings lead to ill-typed operations. $C[2,5]=\\infty$.\n\n    -   **Length 5 (Full Expression):** We check the final split. The expression is $M_1..M_5$. A split at $op_k$ results in cost $C[1,k] + C[k+1,5] + \\text{op_cost}$.\n        -   Split at $op_1=*$: $A*(B*C+D^{\\top}*E)$. Cost depends on $C[2,5]=\\infty$. Invalid.\n        -   Split at $op_2=*$: $(A*B)*(C+D^{\\top}*E)$. Cost depends on $C[3,5]=\\infty$. Invalid.\n        -   **Split at $op_3=+$**: $(A*B*C)+(D^{\\top}*E)$.\n            -   Operands are sub-chains [1,3] and [4,5].\n            -   $C[1,3]=7500$, $S[1,3]=(10,50)$.\n            -   $C[4,5]=25000$, $S[4,5]=(10,50)$.\n            -   Shapes match. Cost of addition is $10 \\cdot 50 = 500$.\n            -   Total cost = $7500 + 25000 + 500 = 33000$.\n        -   **Split at $op_4=*$**: $(A*B*C+D^{\\top})*E$.\n            -   Operands are sub-chains [1,4] and [5,5].\n            -   $C[1,4]=8000$, $S[1,4]=(10,50)$.\n            -   $C[5,5]=0$, $S[5,5]=(50,50)$.\n            -   Shapes $(10,50)$ and $(50,50)$ match for multiplication. Cost of multiplication is $10 \\cdot 50 \\cdot 50 = 25000$.\n            -   Total cost = $8000 + 0 + 25000 = 33000$.\n\n3.  **Conclusion:**\n    Two optimal parenthesizations, $((A*B)*C)+(D^{\\top}*E)$ and $(((A*B)*C)+D^{\\top})*E$, both yield the same minimal cost.\n\nThe minimal total cost is $33000$.", "answer": "$$\\boxed{33000}$$", "id": "3621717"}]}