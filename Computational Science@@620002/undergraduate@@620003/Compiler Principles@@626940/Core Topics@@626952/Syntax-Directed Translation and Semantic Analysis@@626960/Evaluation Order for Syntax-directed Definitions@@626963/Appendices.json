{"hands_on_practices": [{"introduction": "A syntax-directed definition is not just an abstract specification; it can precisely model the operational steps of a computation. This first exercise challenges you to design an SDD that simulates the behavior of a stack-based calculator evaluating a postfix expression. By defining and tracing attributes for stack height, you will gain a concrete understanding of how attribute dependencies guide the flow of information through a parse tree. [@problem_id:3641102]", "problem": "Consider postfix expressions over binary operators generated by the context-free grammar\n$$E \\to E\\;E\\;op \\quad\\mid\\quad num,$$\n$$op \\to + \\;\\mid\\; - \\;\\mid\\; * \\;\\mid\\; /.$$\nDesign a Syntax-Directed Definition (SDD) for this grammar that models evaluation by a single conceptual stack. Your SDD must include one inherited attribute $H_{in}$ (the stack height on entry to evaluating a subtree) and two synthesized attributes $H_{out}$ (the stack height on exit) and $H_{max}$ (the maximum stack height encountered during evaluation of a subtree). The semantic intention is that encountering a terminal $num$ causes one push, and encountering a terminal $op$ causes two pops followed by one push of the resulting value. Construct the attribute equations so that the resulting dependency graph is acyclic and the natural evaluation schedule is a topological order that mirrors the stack discipline: evaluate the left operand subtree, then the right operand subtree, then apply the operator.\n\nUsing the schedule implied by your SDD and the induced dependency graph, evaluate the following concrete postfix input (tokens are space-separated):\n$$3\\;\\;14\\;\\;+\\;\\;2\\;\\;7\\;\\;*\\;\\;9\\;\\;+\\;\\;1\\;\\;-\\;\\;5\\;\\;4\\;\\;+\\;\\;*\\;\\;6\\;\\;8\\;\\;+\\;\\;/\\;\\;*.$$\nInitialize the inherited attribute at the start with $H_{in}=0$. Under the topologically ordered schedule that respects attribute dependencies, determine the single number equal to the maximum stack height encountered during the complete evaluation of the input. Provide only this number as your final answer, with no units and no rounding instructions required.", "solution": "To solve this problem, we first design the Syntax-Directed Definition (SDD) based on the specified behavior of a stack machine. Then, we apply these rules to the given expression to find the maximum stack height.\n\n### 1. Syntax-Directed Definition (SDD) Design\n\nWe define the semantic rules for the attributes $H_{in}$, $H_{out}$, and $H_{max}$ for each production in the grammar.\n\n**For the production $E \\to num$:**\nWhen a number is encountered, it is pushed onto the stack. This increases the stack height by 1. This new height is both the exit height and the maximum height for this subtree.\n-   $E.H_{out} = E.H_{in} + 1$\n-   $E.H_{max} = E.H_{in} + 1$\n\n**For the production $E \\to E_1 E_2 op$:**\nThe evaluation proceeds by first evaluating the left operand $E_1$, then the right operand $E_2$, and finally applying the operator. The operator pops two values and pushes one, resulting in a net decrease of stack height by 1.\n-   The left child $E_1$ inherits its initial stack height from the parent $E$:\n    $E_1.H_{in} = E.H_{in}$\n-   The right child $E_2$ begins evaluation after $E_1$ is complete, so it inherits the stack height from $E_1$'s exit:\n    $E_2.H_{in} = E_1.H_{out}$\n-   After $E_2$ is evaluated, the operator is applied, which decreases the stack height by 1. This gives the parent's exit height:\n    $E.H_{out} = E_2.H_{out} - 1$\n-   The maximum stack height for the parent $E$ is the maximum of the heights reached during the evaluation of its children $E_1$ and $E_2$:\n    $E.H_{max} = \\max(E_1.H_{max}, E_2.H_{max})$\n\n### 2. Evaluation of the Input Expression\n\nWe can determine the maximum stack height by manually tracing the stack operations on the input expression `3 14 + 2 7 * 9 + 1 - 5 4 + * 6 8 + / *`, starting with a stack height of 0.\n\n-   **Initial State**: Stack is empty, height = 0. Maximum height so far = 0.\n-   `3`: Push. Stack height becomes 1. Max height = 1.\n-   `14`: Push. Stack height becomes 2. Max height = 2.\n-   `+`: Pop, Pop, Push. Stack height becomes 1.\n-   `2`: Push. Stack height becomes 2.\n-   `7`: Push. Stack height becomes 3. Max height = 3.\n-   `*`: Pop, Pop, Push. Stack height becomes 2.\n-   `9`: Push. Stack height becomes 3.\n-   `+`: Pop, Pop, Push. Stack height becomes 2.\n-   `1`: Push. Stack height becomes 3.\n-   `-`: Pop, Pop, Push. Stack height becomes 2.\n-   `5`: Push. Stack height becomes 3.\n-   `4`: Push. Stack height becomes 4. Max height = 4.\n-   `+`: Pop, Pop, Push. Stack height becomes 3.\n-   `*`: Pop, Pop, Push. Stack height becomes 2.\n-   `6`: Push. Stack height becomes 3.\n-   `8`: Push. Stack height becomes 4.\n-   `+`: Pop, Pop, Push. Stack height becomes 3.\n-   `/`: Pop, Pop, Push. Stack height becomes 2.\n-   `*`: Pop, Pop, Push. Stack height becomes 1.\n\nThroughout the evaluation, the highest the stack height ever reached was 4. The designed SDD would yield the same result by computing the $H_{max}$ attribute for the root of the parse tree, which would be 4.", "answer": "$$\\boxed{4}$$", "id": "3641102"}, {"introduction": "The way we write our grammar has profound implications for how we can evaluate attributes. This exercise explores the consequences of a common grammar transformation: left recursion elimination. You will compare the simple, bottom-up evaluation schedule of a left-recursive grammar with the mixed-mode schedule required by its right-recursive equivalent, revealing why inherited attributes are essential for preserving left-to-right operations like addition. [@problem_id:3641106]", "problem": "Consider two syntax-directed definitions (SDDs) for expression evaluation over addition that differ only in whether the expression grammar uses left recursion or its non-left-recursive equivalent. You will compare the evaluation order of attributes before and after left recursion elimination on the same input and determine which proposed schedules are valid.\n\nFundamental starting points:\n- A syntax-directed definition (SDD) associates attributes and semantic rules with a context-free grammar. An attribute instance can be evaluated only when all attributes on which it depends have already been computed. Any correct evaluation order is a topological order of the attribute-dependency graph for the given parse tree.\n- A synthesized attribute of a node is computed from attributes of its children. An inherited attribute of a node is computed from attributes of its parent and/or siblings.\n- Eliminating left recursion from a grammar transforms a left-recursive rule into an equivalent right-recursive or iterative form, which often requires converting a purely synthesized SDD into an L-attributed SDD with inherited attributes to preserve left-to-right evaluation.\n\nGrammars and SDDs:\n1) Left-recursive grammar and S-attributed SDD:\n- Grammar $G_1$:\n  - $E \\to E + T \\mid T$\n  - $T \\to n$ where $n$ is a number token with lexical value $n.lexval$.\n- Attributes and rules:\n  - For $E \\to E_1 + T$: $E.val = E_1.val + T.val$.\n  - For $E \\to T$: $E.val = T.val$.\n  - For $T \\to n$: $T.val = n.lexval$.\n  All attributes are synthesized.\n\n2) Non-left-recursive grammar and L-attributed SDD:\n- Grammar $G_2$ (after left recursion elimination):\n  - $E \\to T \\; E'$\n  - $E' \\to + \\; T \\; E' \\mid \\varepsilon$\n  - $T \\to n$\n- Attributes and rules:\n  - For $E \\to T \\; E'$: $E'.inh = T.val$, $E.val = E'.syn$.\n  - For $E' \\to + \\; T \\; E'_1$: $E'_1.inh = E'.inh + T.val$, $E'.syn = E'_1.syn$.\n  - For $E' \\to \\varepsilon$: $E'.syn = E'.inh$.\n  - For $T \\to n$: $T.val = n.lexval$.\n  Here $E'.inh$ is an inherited attribute carrying the running sum, and $E'.syn$ is synthesized back to $E$.\n\nInput and parse-shape conventions:\n- Consider the input $n_1 + n_2 + n_3$. For $G_1$, the leftmost derivation yields the parse tree $E_3 \\Rightarrow E_2 + T_3 \\Rightarrow (E_1 + T_2) + T_3 \\Rightarrow (T_1 + T_2) + T_3$. Name the three $T$-nodes from left to right $T_1, T_2, T_3$, and the three $E$-nodes from bottom to top $E_1$ (for $E \\to T$), $E_2$ (for the first $+$), and $E_3$ (root).\n- For $G_2$, the parse unfolds as $E \\to T_1 \\; E'_0$, then $E'_0 \\to + \\; T_2 \\; E'_1$, then $E'_1 \\to + \\; T_3 \\; E'_2$, then $E'_2 \\to \\varepsilon$. Name the $E'$-chain nodes $E'_0, E'_1, E'_2$.\n\nGoal:\n- Using only the SDD rules above and the principle that a valid schedule must be a topological order of the dependency graph, determine which option lists a valid evaluation order for both $G_1$ and $G_2$ on the input $n_1 + n_2 + n_3$. In all sequences below, each item names a single attribute instance to be computed at that point. Assume that reading $n_i.lexval$ is part of computing $T_i.val$.\n\nOptions:\nA) \n- For $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nB)\n- For $G_1$: $T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nC)\n- For $G_1$: $T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$.\n- For $G_2$: $E'_0.inh,\\; T_1.val,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n\nD)\n- For $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$.\n- For $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$.\n\nChoose the option that is correct. There is at least one correct option. Only select an option if both schedules it lists are valid topological orders for the corresponding SDDs.", "solution": "We start from the governing principles for attribute evaluation order:\n- For any syntax-directed definition (SDD), the attributes and equations at each node of a parse tree induce a directed acyclic graph of attribute dependencies. An attribute instance can be evaluated only after all attributes it depends on are available. Thus any valid evaluation order is a topological sort of that dependency graph.\n- For synthesized attributes, a node’s attribute depends on its children’s attributes. For inherited attributes, a node’s attribute depends on attributes of its parent and/or siblings located to its left in the derivation.\n- Eliminating left recursion from $E \\to E + T \\mid T$ yields $E \\to T E'$, $E' \\to + T E' \\mid \\varepsilon$. To preserve left-associative evaluation under an L-attributed SDD, we use an inherited attribute $E'.inh$ to carry the running total and a synthesized attribute $E'.syn$ to propagate the final value back to $E$.\n\nWe now make the dependencies explicit for the given input $n_1 + n_2 + n_3$.\n\nFor $G_1$ with S-attributed rules:\n- Tree shape: $E_3 \\to E_2 + T_3$, $E_2 \\to E_1 + T_2$, $E_1 \\to T_1$, and $T_i \\to n_i$ for $i \\in \\{1,2,3\\}$.\n- Attribute equations:\n  - $T_i.val = n_i.lexval$.\n  - $E_1.val = T_1.val$.\n  - $E_2.val = E_1.val + T_2.val$.\n  - $E_3.val = E_2.val + T_3.val$.\n- Dependencies:\n  - $E_1.val$ depends on $T_1.val$.\n  - $E_2.val$ depends on $E_1.val$ and $T_2.val$.\n  - $E_3.val$ depends on $E_2.val$ and $T_3.val$.\n  - Each $T_i.val$ depends only on $n_i.lexval$, which we treat as available when computing $T_i.val$.\n- Any valid schedule must respect these dependencies: $T_1.val$ before $E_1.val$; both $E_1.val$ and $T_2.val$ before $E_2.val$; both $E_2.val$ and $T_3.val$ before $E_3.val$.\n\nFor $G_2$ with L-attributed rules:\n- Derivation: $E \\to T_1 \\; E'_0$, $E'_0 \\to + \\; T_2 \\; E'_1$, $E'_1 \\to + \\; T_3 \\; E'_2$, $E'_2 \\to \\varepsilon$.\n- Attribute equations instantiated along the chain:\n  - $T_i.val = n_i.lexval$ for $i \\in \\{1,2,3\\}$.\n  - From $E \\to T_1 \\; E'_0$: $E'_0.inh = T_1.val$, $E.val = E'_0.syn$.\n  - From $E'_0 \\to + \\; T_2 \\; E'_1$: $E'_1.inh = E'_0.inh + T_2.val$, $E'_0.syn = E'_1.syn$.\n  - From $E'_1 \\to + \\; T_3 \\; E'_2$: $E'_2.inh = E'_1.inh + T_3.val$, $E'_1.syn = E'_2.syn$.\n  - From $E'_2 \\to \\varepsilon$: $E'_2.syn = E'_2.inh$.\n- Dependencies:\n  - $E'_0.inh$ depends on $T_1.val$.\n  - $E'_1.inh$ depends on $E'_0.inh$ and $T_2.val$.\n  - $E'_2.inh$ depends on $E'_1.inh$ and $T_3.val$.\n  - $E'_2.syn$ depends on $E'_2.inh$.\n  - $E'_1.syn$ depends on $E'_2.syn$.\n  - $E'_0.syn$ depends on $E'_1.syn$.\n  - $E.val$ depends on $E'_0.syn$.\n- Any valid schedule must compute inherited attributes when their prerequisites are available and must defer synthesized attributes until their dependencies are satisfied.\n\nWe now evaluate each option against these dependency constraints.\n\nOption A:\n- $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $T_1.val$ before $E_1.val$ — satisfied. $E_2.val$ is scheduled after both $E_1.val$ and $T_2.val$ — satisfied. $E_3.val$ is after $E_2.val$ and $T_3.val$ — satisfied. This is a valid topological order.\n- $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$.\n  - Check: $E'_0.inh$ after $T_1.val$ — satisfied. $E'_1.inh$ after $E'_0.inh$ and $T_2.val$ — satisfied. $E'_2.inh$ after $E'_1.inh$ and $T_3.val$ — satisfied. Then synthesized chain $E'_2.syn \\to E'_1.syn \\to E'_0.syn \\to E.val$ is in order. This is a valid topological order.\nVerdict: Correct.\n\nOption B:\n- $G_1$: $T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $E_2.val$ appears before $T_2.val$, but $E_2.val$ depends on $T_2.val$. This violates the dependency $T_2.val \\to E_2.val$. Invalid.\n- $G_2$: The $G_2$ schedule shown matches that of Option A and is valid, but the option requires both schedules to be valid.\nVerdict: Incorrect because the $G_1$ schedule violates dependencies.\n\nOption C:\n- $G_1$: $T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$.\n  - Check: $E_2.val$ is scheduled before $E_1.val$, but $E_2.val$ depends on $E_1.val$. This violates the dependency $E_1.val \\to E_2.val$. Invalid.\n- $G_2$: $E'_0.inh$ is scheduled before $T_1.val$, but $E'_0.inh$ depends on $T_1.val$. This violates the dependency $T_1.val \\to E'_0.inh$. Invalid.\nVerdict: Incorrect.\n\nOption D:\n- $G_1$: $T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$.\n  - Check: $E_2.val$ is after both $E_1.val$ and $T_2.val$ — satisfied. $E_3.val$ is after $E_2.val$ and $T_3.val$ — satisfied. The $G_1$ schedule is valid.\n- $G_2$: $T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$.\n  - Check: $E.val$ is scheduled before $E'_0.syn$, but $E.val$ depends on $E'_0.syn$. This violates the dependency $E'_0.syn \\to E.val$. Additionally, the synthesized chain $E'_2.syn \\to E'_1.syn \\to E'_0.syn$ is placed after $E.val$, further violating dependencies. Invalid.\nVerdict: Incorrect.\n\nConclusion: Only Option A provides valid topological orders for both SDDs. It also illustrates the structural change in evaluation after left recursion elimination: the S-attributed $G_1$ schedule is purely bottom-up over synthesized attributes on a left-recursive tree, while the L-attributed $G_2$ schedule interleaves immediate computation of $T_i.val$ with propagation of inherited attributes $E'_i.inh$, then collapses synthesized results back up via $E'_i.syn$. This difference arises directly from the introduction of inherited attributes to carry the running sum in the non-left-recursive grammar.", "answer": "$$\\boxed{A}$$", "id": "3641106"}, {"introduction": "While simple SDDs can be evaluated with a straightforward tree traversal, complex dependencies between inherited and synthesized attributes require a more general approach. The solution lies in treating attribute evaluation as a topological sort of the dependency graph. This final practice asks you to step into the role of the compiler itself and manually execute Kahn’s algorithm, a standard method for finding a valid evaluation order, reinforcing the connection between graph theory and compiler implementation. [@problem_id:3641188]", "problem": "You are studying evaluation orders for Syntax-Directed Definitions (SDD) in compiler principles. The evaluation order of attribute occurrences for a well-defined SDD is any topological order of its attribute-dependency graph, which is a Directed Acyclic Graph (DAG) under the assumption of no circular dependencies. A standard algorithm for topological sorting is Kahn’s algorithm, which repeatedly removes a node of in-degree zero and deletes its outgoing edges, adding newly freed nodes to a ready set.\n\nConsider the following SDD over a list grammar. The grammar is:\n- $L \\to L , E$\n- $L \\to E$\n- $E \\to \\mathrm{id}$\n\nAttributes:\n- Nonterminal $L$ has an inherited attribute $L.n$ and a synthesized attribute $L.\\mathrm{len}$.\n- Nonterminal $E$ has an inherited attribute $E.n$ and a synthesized attribute $E.\\mathrm{pos}$.\n\nSemantic equations:\n- For production $L \\to L_{1} , E_{r}$:\n  - $L_{1}.n = L.n$\n  - $E_{r}.n = L_{1}.n + L_{1}.\\mathrm{len}$\n  - $L.\\mathrm{len} = L_{1}.\\mathrm{len} + 1$\n- For production $L \\to E_{x}$:\n  - $E_{x}.n = L.n$\n  - $L.\\mathrm{len} = 1$\n- For production $E \\to \\mathrm{id}$:\n  - $E.\\mathrm{pos} = E.n$\n\nParse tree for the input $\\mathrm{id} , \\mathrm{id} , \\mathrm{id}$:\n- The root is $L_{0}$ with production $L \\to L , E$, having left child $L_{1}$ and right child $E_{2}$.\n- Node $L_{1}$ uses production $L \\to L , E$, having left child $L_{2}$ and right child $E_{1}$.\n- Node $L_{2}$ uses production $L \\to E$ with child $E_{0}$.\n- Each $E_{i}$ derives $\\mathrm{id}$.\n\nAssume the inherited attribute of the root is fixed: $L_{0}.n = 1$. Also, for production $L \\to E$ we have $L.\\mathrm{len} = 1$, so $L_{2}.\\mathrm{len} = 1$.\n\nDefine the attribute occurrences and their numeric identifiers as follows:\n- $1$: $L_{0}.n$\n- $2$: $L_{0}.\\mathrm{len}$\n- $3$: $L_{1}.n$\n- $4$: $L_{1}.\\mathrm{len}$\n- $5$: $L_{2}.n$\n- $6$: $L_{2}.\\mathrm{len}$\n- $7$: $E_{0}.n$\n- $8$: $E_{0}.\\mathrm{pos}$\n- $9$: $E_{1}.n$\n- $10$: $E_{1}.\\mathrm{pos}$\n- $11$: $E_{2}.n$\n- $12$: $E_{2}.\\mathrm{pos}$\n\nTask:\n- Construct the attribute-dependency edges induced by the semantic equations instantiated on this parse tree. Each edge is from a source occurrence to a target occurrence that depends on it. The resulting graph is a DAG.\n- Run Kahn’s algorithm on this DAG to obtain a topological evaluation order of the $12$ attribute occurrences. Use the following tie-breaking rule: whenever there are multiple occurrences with in-degree zero in the ready set, choose the one with the smallest numeric identifier.\n- Let $(v_{1}, v_{2}, \\ldots, v_{12})$ be the resulting ordered sequence of occurrences, and let $\\mathrm{id}(v_{i})$ denote the numeric identifier of $v_{i}$ given above. Compute the value\n$$\nS \\;=\\; \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i}).\n$$\n\nYour final answer must be the exact value of $S$ as a single number. No rounding is required.", "solution": "### 1. Constructing the Attribute-Dependency Graph\nFirst, we instantiate the semantic rules on the given parse tree to find the dependencies between the 12 numbered attribute occurrences. An edge $u \\to v$ means attribute $v$ depends on attribute $u$.\n\n-   **At root $L_0$ ($L_0 \\to L_1, E_2$):**\n    -   $L_1.n = L_0.n \\implies 1 \\to 3$\n    -   $E_2.n = L_1.n + L_1.\\mathrm{len} \\implies 3 \\to 11$ and $4 \\to 11$\n    -   $L_0.\\mathrm{len} = L_1.\\mathrm{len} + 1 \\implies 4 \\to 2$\n-   **At node $L_1$ ($L_1 \\to L_2, E_1$):**\n    -   $L_2.n = L_1.n \\implies 3 \\to 5$\n    -   $E_1.n = L_2.n + L_2.\\mathrm{len} \\implies 5 \\to 9$ and $6 \\to 9$\n    -   $L_1.\\mathrm{len} = L_2.\\mathrm{len} + 1 \\implies 6 \\to 4$\n-   **At node $L_2$ ($L_2 \\to E_0$):**\n    -   $E_0.n = L_2.n \\implies 5 \\to 7$\n    -   $L_2.\\mathrm{len} = 1 \\implies$ Attribute 6 has no dependencies.\n-   **At leaf nodes $E_0, E_1, E_2$ ($E \\to \\mathrm{id}$):**\n    -   $E_0.\\mathrm{pos} = E_0.n \\implies 7 \\to 8$\n    -   $E_1.\\mathrm{pos} = E_1.n \\implies 9 \\to 10$\n    -   $E_2.\\mathrm{pos} = E_2.n \\implies 11 \\to 12$\n-   **Initial Condition:** $L_0.n = 1$ implies attribute 1 has no dependencies.\n\n### 2. Topological Sort using Kahn's Algorithm\nWe compute the initial in-degree for each node and run the algorithm. Let $R$ be the ready set (nodes with in-degree 0) and $T$ be the topological order.\n\n**Initial In-degrees:**\n-   In-degree(1)=0, In-degree(2)=1, In-degree(3)=1, In-degree(4)=1, In-degree(5)=1, In-degree(6)=0, In-degree(7)=1, In-degree(8)=1, In-degree(9)=2, In-degree(10)=1, In-degree(11)=2, In-degree(12)=1.\n\n**Execution:**\n1.  **Initial**: $R = \\{1, 6\\}$. $T = ()$.\n2.  **Step 1**: Pop 1 from $R$ (smallest ID). $T = (1)$. Decrement in-degree of 3. $R = \\{3, 6\\}$.\n3.  **Step 2**: Pop 3 from $R$. $T = (1, 3)$. Decrement in-degrees of 5 and 11. $R = \\{5, 6\\}$.\n4.  **Step 3**: Pop 5 from $R$. $T = (1, 3, 5)$. Decrement in-degrees of 7 and 9. $R = \\{6, 7\\}$.\n5.  **Step 4**: Pop 6 from $R$. $T = (1, 3, 5, 6)$. Decrement in-degrees of 4 and 9. $R = \\{4, 7, 9\\}$.\n6.  **Step 5**: Pop 4 from $R$. $T = (1, 3, 5, 6, 4)$. Decrement in-degrees of 2 and 11. $R = \\{2, 7, 9, 11\\}$.\n7.  **Step 6**: Pop 2 from $R$. $T = (1, 3, 5, 6, 4, 2)$. $R = \\{7, 9, 11\\}$.\n8.  **Step 7**: Pop 7 from $R$. $T = (1, 3, 5, 6, 4, 2, 7)$. Decrement in-degree of 8. $R = \\{8, 9, 11\\}$.\n9.  **Step 8**: Pop 8 from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8)$. $R = \\{9, 11\\}$.\n10. **Step 9**: Pop 9 from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9)$. Decrement in-degree of 10. $R = \\{10, 11\\}$.\n11. **Step 10**: Pop 10 from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10)$. $R = \\{11\\}$.\n12. **Step 11**: Pop 11 from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11)$. Decrement in-degree of 12. $R = \\{12\\}$.\n13. **Step 12**: Pop 12 from $R$. $T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$. $R = \\{\\}$.\n\nThe topologically sorted sequence of attribute identifiers, $\\mathrm{id}(v_i)$, is $(1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$.\n\n### 3. Compute the Sum S\nWe calculate $S = \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i})$.\n$$\n\\begin{align*}\nS &= (1 \\cdot 1) + (2 \\cdot 3) + (3 \\cdot 5) + (4 \\cdot 6) + (5 \\cdot 4) + (6 \\cdot 2) \\\\\n  &\\quad + (7 \\cdot 7) + (8 \\cdot 8) + (9 \\cdot 9) + (10 \\cdot 10) + (11 \\cdot 11) + (12 \\cdot 12) \\\\\n&= 1 + 6 + 15 + 24 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n&= 637\n\\end{align*}\n$$", "answer": "$$\\boxed{637}$$", "id": "3641188"}]}