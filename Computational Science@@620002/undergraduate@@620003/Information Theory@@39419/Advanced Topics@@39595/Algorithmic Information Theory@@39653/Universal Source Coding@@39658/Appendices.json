{"hands_on_practices": [{"introduction": "The journey into universal source coding begins with understanding the fundamental mechanics of a compression algorithm. This first practice invites you to step into the role of an LZW encoder. By manually tracing the encoding process for a simple string, you will build the compression dictionary from scratch and see firsthand how the algorithm identifies and codifies recurring patterns, transforming raw data into a more compact representation [@problem_id:1636836].", "id": "1636836", "problem": "The Lempel-Ziv-Welch (LZW) algorithm is a universal lossless data compression algorithm. Its operation relies on building a dictionary of strings encountered during the compression process. The compression proceeds as follows:\n\n1.  Initialize the dictionary with a set of predefined strings and their corresponding codes.\n2.  Start with an empty 'current string' `S`.\n3.  Read the next character `C` from the input stream.\n4.  Consider the new string `S + C` (the current string appended with the new character).\n5.  If `S + C` is already in the dictionary, update the current string: `S = S + C`.\n6.  If `S + C` is not in the dictionary:\n    a) Add `S + C` to the dictionary with the next available integer code.\n    b) Output the code for the current string `S`.\n    c) Reset the current string to be just the character `C`, i.e., `S = C`.\n7.  Repeat from step 3 until the end of the input stream is reached.\n8.  After the loop terminates, output the code for the final 'current string' `S`.\n\nConsider an LZW compressor with an initial dictionary containing only two entries: `A` is assigned code `0`, and `B` is assigned code `1`. The codes for new dictionary entries start from `2` and are assigned sequentially.\n\nDetermine the sequence of output codes generated by this LZW compressor for the input string `BBAABABB`. Present your answer as a sequence of integers.\n\n", "solution": "Initialize the dictionary with $D(\\text{A})=0$ and $D(\\text{B})=1$. Let the next available code be $n=2$. Start with the current string $S$ empty.\n\nRead the first character $C=\\text{B}$. Since $S$ is empty, the concatenation $S+C=\\text{B}$ is in the dictionary, so update $S=\\text{B}$.\n\nRead the second character $C=\\text{B}$. Now $S+C=\\text{BB}$ is not in the dictionary. Add it: $D(\\text{BB})=2$ and update $n \\rightarrow 3$. Output the code for the current string $S$, which is $D(\\text{B})=1$. Reset $S=C=\\text{B}$.\n\nRead the third character $C=\\text{A}$. Now $S+C=\\text{BA}$ is not in the dictionary. Add it: $D(\\text{BA})=3$ and update $n \\rightarrow 4$. Output $D(\\text{B})=1$. Reset $S=C=\\text{A}$.\n\nRead the fourth character $C=\\text{A}$. Now $S+C=\\text{AA}$ is not in the dictionary. Add it: $D(\\text{AA})=4$ and update $n \\rightarrow 5$. Output $D(\\text{A})=0$. Reset $S=C=\\text{A}$.\n\nRead the fifth character $C=\\text{B}$. Now $S+C=\\text{AB}$ is not in the dictionary. Add it: $D(\\text{AB})=5$ and update $n \\rightarrow 6$. Output $D(\\text{A})=0$. Reset $S=C=\\text{B}$.\n\nRead the sixth character $C=\\text{A}$. Now $S+C=\\text{BA}$ is in the dictionary (with code $3$), so update $S=\\text{BA}$.\n\nRead the seventh character $C=\\text{B}$. Now $S+C=\\text{BAB}$ is not in the dictionary. Add it: $D(\\text{BAB})=6$ and update $n \\rightarrow 7$. Output $D(\\text{BA})=3$. Reset $S=C=\\text{B}$.\n\nRead the eighth character $C=\\text{B}$. Now $S+C=\\text{BB}$ is in the dictionary (with code $2$), so update $S=\\text{BB}$.\n\nEnd of input: output the code for the final current string $S$, which is $D(\\text{BB})=2$.\n\nCollecting the outputs in order gives the sequence $1, 1, 0, 0, 3, 2$.", "answer": "$$\\boxed{\\begin{pmatrix}1 & 1 & 0 & 0 & 3 & 2\\end{pmatrix}}$$"}, {"introduction": "Compression is useless without its inverse: decompression. This next exercise completes the LZW cycle by tasking you with reconstructing the original message from a sequence of compressed codes. This practice is crucial for appreciating the symmetry and elegance of the LZW algorithm, as the decompressor perfectly rebuilds the exact same dictionary the compressor used, without needing it to be sent separately. Pay close attention to how the algorithm handles codes that it hasn't officially seen yet—it's a key part of its design [@problem_id:1636893].", "id": "1636893", "problem": "The Lempel-Ziv-Welch (LZW) is a universal lossless data compression algorithm. A decompressor reconstructs the original data by reading a sequence of codes and using them to rebuild the dictionary that was created by the compressor.\n\nAssume an LZW decompressor is initialized with a dictionary containing all 256 single-character strings corresponding to the standard 8-bit ASCII character set, where the dictionary code for a character is its ASCII value. New dictionary entries are added sequentially, starting from code 256.\n\nGiven the LZW-compressed output sequence of codes `[67, 65, 256, 258, 257]`, reconstruct the original text.\n\n", "solution": "Use the standard LZW decompression procedure. Initialize the dictionary with codes $0$ through $255$ mapping to the corresponding single ASCII characters. Let $w$ denote the previous decoded string. Read the first code, output its entry, and set $w$ to that entry. For each subsequent code $k$, determine the current entry as follows: if $k$ is already in the dictionary, let $\\text{entry}=\\text{dict}[k]$; if $k$ equals the next code to be assigned (i.e., it is not yet in the dictionary), use the special case $\\text{entry}=w + \\text{first\\_char}(w)$. Then output $\\text{entry}$, add the new dictionary entry $w + \\text{first\\_char}(\\text{entry})$ with the next available code, and set $w=\\text{entry}$.\n\nProcess the given code sequence $[67,65,256,258,257]$ step by step:\n\n1) First code $67$ is in the initial dictionary and corresponds to the character C. Output C and set $w=\\text{C}$. The next available code is $256$.\n\n2) Next code $65$ is in the initial dictionary and corresponds to the character A. Output A. Add the new dictionary entry with code $256$: $w + \\text{first\\_char}(\\text{entry})=\\text{C}+\\text{A}=\\text{CA}$. Increment next code to $257$. Set $w=\\text{A}$. Output so far: CA.\n\n3) Next code $256$ is in the dictionary as $\\text{CA}$. Output CA. Add the new dictionary entry with code $257$: $w + \\text{first\\_char}(\\text{entry})=\\text{A}+\\text{C}=\\text{AC}$. Increment next code to $258$. Set $w=\\text{CA}$. Output so far: CACA.\n\n4) Next code $258$ is not yet in the dictionary. Use the special case: $\\text{entry}=w+\\text{first\\_char}(w)=\\text{CA}+\\text{C}=\\text{CAC}$. Output CAC. Add the new dictionary entry with code $258$: $w + \\text{first\\_char}(\\text{entry})=\\text{CA}+\\text{C}=\\text{CAC}$. Increment next code to $259$. Set $w=\\text{CAC}$. Output so far: CACACAC.\n\n5) Next code $257$ is in the dictionary as $\\text{AC}$. Output AC. Add the new dictionary entry with code $259$: $w + \\text{first\\_char}(\\text{entry})=\\text{CAC}+\\text{A}=\\text{CACA}$. Increment next code to $260$. Set $w=\\text{AC}$. Final output: CACACACAC.\n\nTherefore, the reconstructed original text is CACACACAC.", "answer": "$$\\boxed{\\text{CACACACAC}}$$"}, {"introduction": "Moving from the dictionary-based LZW to the sliding-window-based LZ77, this practice explores what happens when communication systems are imperfect. Rather than simply executing an algorithm, you will analyze a fault scenario where an encoder and decoder have mismatched parameters. This thought experiment highlights the operational constraints of compression schemes and deepens your understanding of why an algorithm's parameters, like the search buffer size, are critical for successful data reconstruction [@problem_id:1666833].", "id": "1666833", "problem": "A decoder receives a sequence of tuples generated by a Lempel-Ziv 77 (LZ77) compression algorithm. Each tuple is of the form `(offset, length, next_symbol)`, where `offset` is the distance back from the current position to the start of a matched sequence, `length` is the length of the match, and `next_symbol` is the literal character to be appended after the copy. A tuple with offset and length both zero, `(0, 0, char)`, represents a single literal character that was not found in the search buffer.\n\nThe received sequence of tuples, $T$, is:\n$T = [(0, 0, 'A'), (0, 0, 'B'), (0, 0, 'C'), (0, 0, 'D'), (0, 0, 'E'), (0, 0, 'F'), (6, 3, 'X'), (0, 0, 'Y'), (0, 0, 'Z')]$\n\nThis sequence of tuples was generated by an encoder from the original string $S$:\n$S = \\text{`ABCDEFABCXYZ`}$\n\nThe decoder responsible for decompression is misconfigured and uses a search buffer of size $W_d = 4$. The decoder processes the tuples in $T$ sequentially to reconstruct a string $S'$. Its operation is defined as follows:\n- For a tuple $(o, l, c)$, if $o = 0$, it appends the literal $c$ to its output string.\n- If $o > 0$ and the offset $o$ is within its search buffer size (i.e., $o \\le W_d$), it performs the copy operation as expected: it finds the starting position of the match at `current_length - o`, copies $l$ characters from that point, and appends them to the output string. It then appends the literal $c$.\n- If $o > 0$ and the offset $o$ is outside its search buffer size (i.e., $o > W_d$), a fault occurs. The decoder, in this case, treats the match length $l$ as zero (copies nothing) and appends only the literal $c$.\n\nCalculate the Hamming distance between the original string $S$ and the string $S'$ reconstructed by the misconfigured decoder. For the purpose of this problem, the Hamming distance between two strings of unequal length is the number of positions at which the corresponding characters are different, plus the number of characters in the longer string that extend beyond the end of the shorter string.\n\n", "solution": "The decoder processes the tuples sequentially with search buffer size $W_{d}=4$. For a tuple $(o,l,c)$:\n- If $o=0$, it appends the literal $c$.\n- If $o>0$ and $o\\leq W_{d}$, it copies $l$ characters from offset $o$ back, then appends $c$.\n- If $o>0$ and $o>W_{d}$, it copies nothing (treats $l=0$) and appends only $c$.\n\nProcess the given sequence $T=[(0,0,\\text{'A'}),(0,0,\\text{'B'}),(0,0,\\text{'C'}),(0,0,\\text{'D'}),(0,0,\\text{'E'}),(0,0,\\text{'F'}),(6,3,\\text{'X'}),(0,0,\\text{'Y'}),(0,0,\\text{'Z'})]$:\n- Tuples $(0,0,\\text{'A'})$ through $(0,0,\\text{'F'})$ append literals to yield $S'=\\text{ABCDEF}$.\n- Tuple $(6,3,\\text{'X'})$ has $o=6>W_{d}=4$, so a fault occurs; no copy is performed and only $\\text{'X'}$ is appended, giving $S'=\\text{ABCDEFX}$.\n- Tuple $(0,0,\\text{'Y'})$ appends $\\text{'Y'}$, giving $S'=\\text{ABCDEFXY}$.\n- Tuple $(0,0,\\text{'Z'})$ appends $\\text{'Z'}$, giving $S'=\\text{ABCDEFXYZ}$.\n\nThus the reconstructed string is $S'=\\text{ABCDEFXYZ}$, while the original is $S=\\text{ABCDEFABCXYZ}$.\n\nLet the Hamming distance for unequal lengths be\n$$\nd_{H}(S,S')=\\left|\\left\\{\\,i\\in\\{1,\\ldots,\\min(|S|,|S'|)\\}:\\ S[i]\\neq S'[i]\\,\\right\\}\\right|+\\left||S|-|S'|\\right|.\n$$\nHere $|S|=12$, $|S'|=9$, so $\\min(|S|,|S'|)=9$. Compare positions $1$ through $9$:\n- Positions $1$–$6$ match: $\\text{A,B,C,D,E,F}$.\n- Positions $7$–$9$ mismatch: $S[7..9]=\\text{A,B,C}$ versus $S'[7..9]=\\text{X,Y,Z}$, yielding $3$ mismatches.\n\nThe length difference contributes $|12-9|=3$. Therefore,\n$$\nd_{H}(S,S')=3+3=6.\n$$", "answer": "$$\\boxed{6}$$"}]}