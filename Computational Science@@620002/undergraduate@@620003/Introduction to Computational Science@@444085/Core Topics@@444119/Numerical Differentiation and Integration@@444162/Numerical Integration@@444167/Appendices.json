{"hands_on_practices": [{"introduction": "The journey into numerical integration often begins by connecting abstract mathematical techniques to tangible physical problems. This exercise grounds the theory in practice by asking you to calculate the mechanical work done by a nonlinear spring, a common scenario in physics and engineering. By implementing and comparing the composite trapezoidal and Simpson's rules, you will gain first-hand experience with how these fundamental methods work and differ in accuracy, while also discovering a key theoretical property of Simpson's rule when applied to polynomial functions [@problem_id:3214920].", "problem": "You are to design and implement a program that computes the mechanical work $W$ required to move a mass-spring system with nonlinear stiffness along a one-dimensional displacement from position $x=a$ to position $x=b$. The force law is $F(x)=kx+\\alpha x^{3}$, where $k$ and $\\alpha$ are real constants. The work is defined by the Riemann integral $W=\\int_{a}^{b}F(x)\\,dx$. Your program must approximate $W$ using two composite numerical integration schemes on a uniform partition with $n$ subintervals: the composite trapezoidal rule and the composite Simpson's rule, both derived from the standard viewpoint of approximating the integrand by low-degree polynomials over subintervals and summing their exact subinterval integrals. In addition, compute the exact work by directly integrating the given $F(x)$ and use it to quantify the absolute error of each numerical method. All work values and errors must be expressed in joules (J) as floating-point numbers.\n\nFundamental basis to use for the derivations and algorithm design: the definition of work as an integral $W=\\int_{a}^{b}F(x)\\,dx$, the properties of polynomials, and the foundational principle of Newton–Cotes quadrature that approximates an integral by integrating an interpolating polynomial of the integrand over each subinterval. Do not assume or cite any pre-derived quadrature weights in your reasoning; instead base your design on first principles of polynomial interpolation and exact integration of polynomials over finite intervals.\n\nImplement both composite rules on a uniform partition $\\{x_{i}\\}_{i=0}^{n}$ with $x_{0}=a$, $x_{n}=b$, $x_{i}=a+ih$, and $h=(b-a)/n$. For the composite Simpson's rule, $n$ must be even. For each test case below, compute:\n- the exact work $W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$,\n- the composite trapezoidal approximation $W_{\\text{trap}}$,\n- the composite Simpson approximation $W_{\\text{simp}}$,\n- the absolute trapezoidal error $e_{\\text{trap}}=| W_{\\text{trap}}-W_{\\text{exact}}|$,\n- the absolute Simpson error $e_{\\text{simp}}=| W_{\\text{simp}}-W_{\\text{exact}}|$.\n\nAngle units are not involved in this problem. All lengths $x$ are in meters (m), $k$ is in newtons per meter (N/m), $\\alpha$ is in newtons per meter cubed ($N/m^3$), and all work values must be reported in joules (J).\n\nUse the following test suite, which covers a general case, a linear boundary case, a softening nonlinearity, and a coarse-partition edge case:\n- Case $1$: $k=100$, $\\alpha=2000$, $a=0$, $b=0.2$, $n=20$.\n- Case $2$: $k=250$, $\\alpha=0$, $a=0$, $b=0.3$, $n=12$.\n- Case $3$: $k=50$, $\\alpha=-500$, $a=0.0$, $b=0.25$, $n=10$.\n- Case $4$: $k=120$, $\\alpha=8000$, $a=0.05$, $b=0.18$, $n=2$.\n\nYour program must produce a single line of output containing the aggregated results for all test cases as a comma-separated list of lists, with no spaces. For each case, the inner list must be ordered as $[W_{\\text{exact}},W_{\\text{trap}},W_{\\text{simp}},e_{\\text{trap}},e_{\\text{simp}}]$. Thus the final output must be a single line string of the form [[case1],[case2],[case3],[case4]] where each [casei] is the bracketed five-tuple in the specified order. Do not print units; the numerical values are understood to be in joules (J).", "solution": "The problem requires solving for the mechanical work $W$ done by a variable force $F(x) = kx + \\alpha x^3$ over a displacement from $x=a$ to $x=b$. The work is defined by the definite integral $W = \\int_{a}^{b} F(x) \\,dx$. We will first find the exact analytical solution for the work, and then derive the numerical approximations from first principles as required.\n\n#### 1. Exact Work Calculation ($W_{\\text{exact}}$)\nThe exact work is found by direct integration of the polynomial force function. Using the power rule for integration, $\\int x^p \\,dx = \\frac{x^{p+1}}{p+1}$:\n$$\nW_{\\text{exact}} = \\int_{a}^{b} (kx + \\alpha x^3) \\,dx = \\left[ k\\frac{x^2}{2} + \\alpha\\frac{x^4}{4} \\right]_{a}^{b}\n$$\nEvaluating the antiderivative at the limits of integration gives:\n$$\nW_{\\text{exact}} = \\left( k\\frac{b^2}{2} + \\alpha\\frac{b^4}{4} \\right) - \\left( k\\frac{a^2}{2} + \\alpha\\frac{a^4}{4} \\right)\n$$\nThis formula provides the exact ground truth against which we will compare the numerical methods.\n\n#### 2. Composite Trapezoidal Rule ($W_{\\text{trap}}$)\nThis rule approximates the integral by summing the areas of trapezoids formed under the curve in each subinterval. The integration interval $[a, b]$ is divided into $n$ uniform subintervals $[x_i, x_{i+1}]$ for $i = 0, 1, \\dots, n-1$, each of width $h = (b-a)/n$.\n\n**First Principles Derivation:**\nOn a single subinterval $[x_i, x_{i+1}]$, we approximate the function $F(x)$ by a linear polynomial $P_1(x)$ that passes through the points $(x_i, F(x_i))$ and $(x_{i+1}, F(x_{i+1}))$. The integral of this linear interpolant is the area of the trapezoid:\n$$\n\\int_{x_i}^{x_{i+1}} F(x) \\,dx \\approx \\int_{x_i}^{x_{i+1}} P_1(x) \\,dx = \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\nThe composite rule sums these approximations over all $n$ subintervals:\n$$\nW_{\\text{trap}} = \\sum_{i=0}^{n-1} \\frac{h}{2} (F(x_i) + F(x_{i+1})) = \\frac{h}{2} [ F(x_0) + 2\\sum_{i=1}^{n-1} F(x_i) + F(x_n) ]\n$$\nThis can be implemented compactly as:\n$$\nW_{\\text{trap}} = h \\left( \\frac{F(x_0) + F(x_n)}{2} + \\sum_{i=1}^{n-1} F(x_i) \\right)\n$$\n\n#### 3. Composite Simpson's Rule ($W_{\\text{simp}}$)\nThis rule uses a quadratic approximation over pairs of subintervals, requiring an even $n$.\n\n**First Principles Derivation:**\nOn a panel $[x_{2j-2}, x_{2j}]$ of width $2h$, we approximate $F(x)$ with a quadratic polynomial $P_2(x)$ that interpolates the function at the three points $x_{2j-2}$, $x_{2j-1}$, and $x_{2j}$. Integrating this polynomial gives the formula for a single panel:\n$$\n\\int_{x_{2j-2}}^{x_{2j}} F(x) \\,dx \\approx \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\nThe composite rule sums these approximations over all $n/2$ panels. Expanding and collecting terms yields the final formula:\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ F(x_0) + 4F(x_1) + 2F(x_2) + 4F(x_3) + \\dots + 2F(x_{n-2}) + 4F(x_{n-1}) + F(x_n) ]\n$$\nThis can be implemented by summing the odd-indexed and even-indexed terms separately:\n$$\nW_{\\text{simp}} = \\frac{h}{3} \\left( F(x_0) + F(x_n) + 4 \\sum_{i=1, i \\text{ odd}}^{n-1} F(x_i) + 2 \\sum_{i=2, i \\text{ even}}^{n-2} F(x_i) \\right)\n$$\nA crucial property of Simpson's rule is that it is exact for any polynomial of degree 3 or less. Since our force function $F(x) = kx + \\alpha x^3$ is a cubic polynomial, the error term for Simpson's rule, which depends on the fourth derivative of $F(x)$, is zero ($F^{(4)}(x) = 0$). Therefore, the composite Simpson's rule will calculate the exact work, $W_{\\text{simp}} = W_{\\text{exact}}$, and the error $e_{\\text{simp}}$ will be zero (or within machine floating-point precision of zero).\n\n#### 4. Absolute Error Calculation\nThe absolute errors for the trapezoidal ($e_{\\text{trap}}$) and Simpson ($e_{\\text{simp}}$) rules are calculated by taking the absolute difference between the numerical approximation and the exact value:\n$$\ne_{\\text{trap}} = | W_{\\text{trap}} - W_{\\text{exact}} |\n$$\n$$\ne_{\\text{simp}} = | W_{\\text{simp}} - W_{\\text{exact}} |\n$$\nThe implementation will proceed by coding these derived formulas for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes exact work, composite trapezoidal and Simpson's rule approximations,\n    and their absolute errors for a nonlinear spring system.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, alpha, a, b, n)\n        (100.0, 2000.0, 0.0, 0.2, 20),\n        (250.0, 0.0, 0.0, 0.3, 12),\n        (50.0, -500.0, 0.0, 0.25, 10),\n        (120.0, 8000.0, 0.05, 0.18, 2),\n    ]\n\n    results = []\n    for k, alpha, a, b, n in test_cases:\n        # Define the force function F(x) = kx + alpha*x^3\n        def F(x):\n            return k * x + alpha * x**3\n\n        # 1. Exact Work Calculation (W_exact)\n        # The analytical integral of F(x) is (k/2)*x^2 + (alpha/4)*x^4.\n        work_exact = (k / 2.0 * b**2 + alpha / 4.0 * b**4) - \\\n                     (k / 2.0 * a**2 + alpha / 4.0 * a**4)\n\n        # Set up the uniform partition for numerical integration\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = F(x)\n\n        # 2. Composite Trapezoidal Rule (W_trap)\n        # Formula: h * [ (y_0 + y_n)/2 + sum(y_i for i=1 to n-1) ]\n        if n > 0:\n            work_trap = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n        else: # Handle n=0 case, though not in test data\n            work_trap = 0.0\n\n        # 3. Composite Simpson's Rule (W_simp)\n        # Formula: (h/3) * [ y_0 + 4*sum(odd_indices) + 2*sum(even_indices) + y_n ]\n        # This rule requires n to be even, which is true for all test cases.\n        if n % 2 == 0 and n > 0:\n            sum_odd_indices = np.sum(y[1:-1:2])\n            sum_even_indices = np.sum(y[2:-1:2])\n            work_simp = (h / 3.0) * (y[0] + 4.0 * sum_odd_indices + 2.0 * sum_even_indices + y[-1])\n        else:\n            # Not applicable for odd n, but handle for completeness\n            work_simp = float('nan') \n\n        # 4. Absolute Error Calculations\n        error_trap = abs(work_trap - work_exact)\n        error_simp = abs(work_simp - work_exact)\n\n        # Append the 5-tuple of results for the current case.\n        results.append([work_exact, work_trap, work_simp, error_trap, error_simp])\n\n    # Final print statement in the exact required format.\n    # [[case1],[case2],[case3],[case4]] with no spaces.\n    case_strings = [f'[{\",\".join(map(str, res))}]' for res in results]\n    print(f'[{\",\".join(case_strings)}]')\n\nsolve()\n```", "id": "3214920"}, {"introduction": "A common rule of thumb in numerical analysis is that higher-order methods yield better accuracy. This practice problem challenges that assumption and builds a deeper, more nuanced understanding of how quadrature rules perform. By analyzing a specially constructed continuous, but non-smooth, function, you will demonstrate a scenario where the \"simpler\" trapezoidal rule is provably more accurate than the \"more advanced\" Simpson's rule [@problem_id:3258564]. This exercise is invaluable for appreciating that the performance guarantees of numerical methods are intrinsically linked to the smoothness properties of the function being integrated.", "problem": "Consider closed Newton–Cotes quadrature rules applied to a continuous function. Define the continuous function $f:[0,2]\\to\\mathbb{R}$ by\n$$\nf(x)=\n\\begin{cases}\n0, & 0 \\le x \\le 0.9, \\\\\n100(x-0.9), & 0.9 < x \\le 1, \\\\\n100(1.1-x), & 1 < x \\le 1.1, \\\\\n0, & 1.1 < x \\le 2.\n\\end{cases}\n$$\nLet $I=\\int_{0}^{2} f(x)\\,dx$ be the exact integral. Using the standard composite trapezoidal rule and the standard composite Simpson's rule, each with $N=2$ equal subintervals on $[0,2]$, compute their approximations to $I$. Then compute the absolute errors $E_{T}=\\left|T-I\\right|$ and $E_{S}=\\left|S-I\\right|$, where $T$ and $S$ denote the composite trapezoidal and composite Simpson approximations, respectively. Finally, provide the exact value of the ratio $\\left|E_{S}\\right|/\\left|E_{T}\\right|$ to demonstrate a case where Simpson’s rule is less accurate than the trapezoidal rule at this resolution. Express your final answer as an exact rational number. No rounding is required.", "solution": "The problem requires the calculation of the exact integral $I$ of the given function $f(x)$ over the interval $[0, 2]$, the approximations to this integral using the composite trapezoidal rule ($T$) and composite Simpson's rule ($S$) with $N=2$ subintervals, and finally the ratio of their absolute errors, $|E_S|/|E_T|$.\n\n**1. Calculate the Exact Integral ($I$)**\n\nThe function $f(x)$ is a piecewise linear \"tent\" or \"hat\" function. It is non-zero only on the interval $(0.9, 1.1)$. Geometrically, its graph on this interval forms a triangle with a base of width $(1.1 - 0.9) = 0.2$ and a height of $f(1) = 100(1.1 - 1) = 10$. The area of this triangle is the exact value of the integral.\n$$\nI = \\int_{0}^{2} f(x)\\,dx = \\text{Area}_{\\text{triangle}} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 0.2 \\times 10 = 1\n$$\nSo, the exact integral is $I=1$.\n\n**2. Calculate the Composite Trapezoidal Approximation ($T$)**\n\nFor $N=2$ subintervals on $[0, 2]$, the step size is $h = (2-0)/2 = 1$. The nodes are $x_0=0$, $x_1=1$, and $x_2=2$. The composite trapezoidal rule for $N=2$ is given by:\n$$\nT = \\frac{h}{2} [f(x_0) + 2f(x_1) + f(x_2)]\n$$\nWe evaluate the function at the nodes:\n- $f(x_0) = f(0) = 0$\n- $f(x_1) = f(1) = 100(1.1 - 1) = 10$\n- $f(x_2) = f(2) = 0$\n\nSubstituting these values into the formula:\n$$\nT = \\frac{1}{2} [0 + 2(10) + 0] = \\frac{20}{2} = 10\n$$\nThe absolute error for the trapezoidal rule is $E_T = |T - I| = |10 - 1| = 9$.\n\n**3. Calculate the Composite Simpson's Approximation ($S$)**\n\nFor $N=2$ subintervals, the composite Simpson's rule is equivalent to one application of the basic Simpson's 1/3 rule over the entire interval $[0, 2]$. The step size for the formula is $h = (2-0)/2 = 1$. The nodes are the same: $x_0=0$, $x_1=1$, and $x_2=2$. The formula is:\n$$\nS = \\frac{h}{3} [f(x_0) + 4f(x_1) + f(x_2)]\n$$\nSubstituting the function values:\n$$\nS = \\frac{1}{3} [0 + 4(10) + 0] = \\frac{40}{3}\n$$\nThe absolute error for Simpson's rule is $E_S = |S - I| = \\left|\\frac{40}{3} - 1\\right| = \\left|\\frac{40-3}{3}\\right| = \\frac{37}{3}$.\n\n**4. Compute the Error Ratio**\n\nFinally, we compute the ratio of the absolute errors:\n$$\n\\frac{|E_S|}{|E_T|} = \\frac{37/3}{9} = \\frac{37}{27}\n$$\nThis result demonstrates that for this specific non-smooth function and coarse grid, the higher-order Simpson's rule is less accurate than the simpler trapezoidal rule. This occurs because the error bounds for Simpson's rule rely on the fourth derivative of the function. For this piecewise linear function, the fourth derivative involves derivatives of Dirac delta functions at the \"corners\" ($x=0.9, 1, 1.1$), violating the smoothness assumptions that guarantee its superior convergence.", "answer": "$$\n\\boxed{\\frac{37}{27}}\n$$", "id": "3258564"}, {"introduction": "Many functions in science and engineering feature sharp peaks or rapid changes in localized regions, posing a challenge for methods that use a uniform grid. This advanced practice introduces adaptive quadrature, a powerful technique that intelligently concentrates computational effort where it is most needed. By implementing an adaptive Simpson's method to integrate a Gaussian function and comparing its efficiency to a uniform-grid approach, you will see the dramatic benefits of an algorithm that adapts to the local behavior of the integrand [@problem_id:3214881]. This skill is a cornerstone of modern, efficient numerical software.", "problem": "Consider the numerical evaluation of the definite integral of the function $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ on the interval $[0,1]$. The task is to implement two composite numerical integration methods based on the Simpson's rule and to compare their accuracy and computational effort:\n\n1. A uniform composite Simpson method over a partition of $[0,1]$ into $N$ equal subintervals, where $N$ is an even integer. If an odd $N$ is supplied, the implementation must increase it by $1$ so that the rule is applicable.\n\n2. An adaptive composite Simpson method with local error control, which recursively subdivides an interval until a specified local absolute tolerance $\\text{tol}$ is met. Local error control must be enforced by comparing the Simpson approximation on an interval with the sum of Simpson approximations on its two halves, and by distributing the tolerance across subintervals in a manner that ensures a globally controlled absolute error.\n\nThe implementation should build from the following fundamental base:\n\n- Polynomial interpolation: approximate a sufficiently smooth function on an interval by a quadratic interpolant through three points and integrate the interpolant exactly.\n- Error behavior of composite polynomial-based quadrature: for sufficiently smooth $f$, the Simpson's rule has a truncation error that scales with the fifth power of the interval length for a single panel and yields a fourth-order global convergence rate when applied uniformly.\n\nCompute the true value of the integral using the known antiderivative of a Gaussian function, expressed in terms of the error function, and use it as the ground truth for error calculation.\n\nFor each method, report:\n- The absolute error with respect to the true integral.\n- The number of function evaluations used.\n\nThe program must implement both methods and run the following test suite, where each test case is a pair $(\\text{tol}, N)$:\n\n- Test case 1 (happy path): $\\text{tol} = 10^{-6}$, $N = 100$.\n- Test case 2 (tighter tolerance, finer grid): $\\text{tol} = 10^{-8}$, $N = 1000$.\n- Test case 3 (looser tolerance, coarse grid): $\\text{tol} = 10^{-4}$, $N = 10$.\n- Test case 4 (edge case with minimal uniform panels): $\\text{tol} = 10^{-10}$, $N = 2$.\n- Test case 5 (very strict tolerance): $\\text{tol} = 10^{-12}$, $N = 200$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a list of four values in the following order: $[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$. For example, an output for two cases would have the form $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$.\n\nNo physical units are involved in this problem, and no angles or percentages are required. The final output values must be real numbers or integers, as appropriate, without any additional text.", "solution": "The solution requires implementing and comparing a uniform composite Simpson's rule and an adaptive composite Simpson's rule to evaluate the integral $I = \\int_0^1 f(x) \\,dx$ for $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$.\n\n**1. True Value of the Integral**\n\nThe integral of a Gaussian function can be expressed in terms of the error function, $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$. To evaluate $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$, we perform a change of variables. Let $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$. This implies $du = 10 \\,dx$, or $dx = \\frac{1}{10} \\,du$. The limits of integration for $u$ become:\n- When $x = 0$, $u = 10(0 - 0.3) = -3$.\n- When $x = 1$, $u = 10(1 - 0.3) = 7$.\n\nThe integral transforms to:\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\nUsing the definition of the error function, we can write the definite integral as:\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\nWith $a = -3$ and $b = 7$, and using the property $\\text{erf}(-z) = -\\text{erf}(z)$, the true value is:\n$$ I_{\\text{true}} = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\nThis value will serve as our ground truth for calculating the absolute error of the numerical methods.\n\n**2. Uniform Composite Simpson's Rule**\n\nThe composite Simpson's rule approximates the integral over a uniform partition of $[a, b]$ into $N$ subintervals of width $h = (b-a)/N$, where $N$ is even. The points are $x_i = a + ih$ for $i = 0, \\dots, N$. The formula is:\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\nThe number of function evaluations is $N+1$. If an odd $N$ is given, it is incremented to $N+1$, making the number of evaluations $N+2$.\n\n**3. Adaptive Composite Simpson's Rule**\n\nAdaptive quadrature concentrates evaluation points where the function changes most rapidly. For the given Gaussian, this is around the peak at $x=0.3$. The algorithm works recursively.\n\nFor an interval $[a, b]$, we compare a coarse approximation, $S_1$ (one Simpson panel), with a fine approximation, $S_2$ (two Simpson panels over the half-intervals). The error of the finer approximation $S_2$ can be estimated by $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$.\n\nThe recursive logic is as follows:\n1.  For an interval $[a, b]$ and local tolerance $\\text{tol}_{local}$, compute $S_1$ and $S_2$.\n2.  Calculate the error estimate $\\text{err} = \\frac{|S_2 - S_1|}{15}$.\n3.  If $\\text{err} < \\text{tol}_{local}$, the interval is resolved. Return the more accurate value $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$ (a Richardson extrapolation).\n4.  If $\\text{err} \\ge \\text{tol}_{local}$, subdivide the interval into two halves and recursively call the algorithm on each half, passing half the tolerance ($\\text{tol}_{local}/2$) to each call. The result is the sum of the results from the two recursive calls.\n\nThis strategy efficiently achieves the desired accuracy by performing more work in the vicinity of the Gaussian's peak and very little in the flat regions. To minimize function calls, evaluations are passed down through the recursion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate < tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3214881"}]}