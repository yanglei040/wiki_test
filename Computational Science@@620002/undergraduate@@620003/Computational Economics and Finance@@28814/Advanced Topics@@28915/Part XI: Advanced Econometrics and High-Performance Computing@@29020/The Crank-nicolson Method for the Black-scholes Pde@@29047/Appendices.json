{"hands_on_practices": [{"introduction": "The Crank-Nicolson method is a popular choice for solving the Black-Scholes partial differential equation due to its second-order accuracy in time and unconditional stability. However, its theoretical advantages can be compromised when dealing with the non-smooth 'kink' in an option's payoff function at the strike price, especially for options with short maturities. This exercise [@problem_id:2439346] provides a hands-on opportunity to implement and compare the Crank-Nicolson scheme against a simpler explicit method and to objectively measure the numerical oscillations that can arise, which is a critical first step toward building more robust and accurate pricing models.", "problem": "Write a complete, runnable program that compares the behavior of the Crank-Nicolson (CN) finite difference method and a fully explicit time-stepping finite difference method for the valuation of a European call option governed by the Black-Scholes partial differential equation (PDE). Your goal is to investigate numerical oscillations in the vicinity of the strike price for short maturities, and to quantify them with a simple, objective metric.\n\nYou must base your formulation on the following accepted foundations:\n- The Black-Scholes PDE for a European call option price $V(S,t)$ under risk-neutral valuation: \n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nwith underlying asset price $S$, risk-free rate $r$, and volatility $\\sigma$, where $t$ denotes the current time (earlier times correspond to larger time-to-maturity).\n- Terminal condition at maturity $t = T$: \n$$\nV(S,T) = \\max(S - K, 0),\n$$\nwith strike $K$.\n- For a sufficiently large finite domain $S \\in [0, S_{\\max}]$, boundary conditions:\n$$\nV(0,t) = 0, \\quad V(S_{\\max}, t) \\approx S_{\\max} - K e^{-r (T - t)}.\n$$\n\nDiscretize the spatial domain uniformly with $M$ intervals so that $S_j = j \\Delta S$ for $j = 0,1,\\dots,M$ with $\\Delta S = S_{\\max}/M$. Discretize time uniformly with $N_t$ steps so that $t_n = n \\Delta t$ for $n=0,1,\\dots,N_t$ with $\\Delta t = T/N_t$. Use standard centered finite differences in space on the uniform grid. Implement:\n- A Crank-Nicolson (CN) time-stepping method (an implicit trapezoidal rule in time).\n- A fully explicit forward-in-time method (using the same spatial stencils).\n\nBoth schemes should march the numerical solution backward from $t=T$ to $t=0$.\n\nDefine and compute an oscillation metric focused on the strike neighborhood as follows. Let $j_K$ be the nearest spatial index to the strike, $j_K = \\mathrm{round}(K/\\Delta S)$. For a fixed window half-width $w$, consider indices $j \\in \\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$. Let the discrete second difference at $j$ be\n$$\n\\Delta^2 V_j = V_{j+1}(0) - 2 V_j(0) + V_{j-1}(0),\n$$\nwhere $V_j(0)$ denotes the numerical solution at $t=0$. Define the oscillation amplitude\n$$\n\\mathcal{O} = \\max_{j} \\big( 0, -\\Delta^2 V_j \\big),\n$$\nover the specified window. For a convex payoff like a European call, the true solution is convex in $S$, so any negative discrete second difference near the strike indicates spurious numerical oscillations.\n\nImplement both methods for each test case and compute the ratio\n$$\nR = \\frac{\\mathcal{O}_{\\mathrm{CN}}}{\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon},\n$$\nwith a small $\\varepsilon = 10^{-12}$ to avoid division by zero. Report $R$ for each test case.\n\nAll rates must be expressed as decimals (for example, $r = 0.05$ for a five percent annualized rate). There are no physical units.\n\nUse the following test suite, which explores a range of short maturities and volatilities while keeping the spatial grid the same. In all cases, set $K = 100$, $S_{\\max} = 5K$, $M = 100$, window half-width $w = 5$.\n- Case A (short maturity, coarse time): $\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 10$.\n- Case B (short maturity, finer time): $\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 40$.\n- Case C (very short maturity, low volatility): $\\sigma = 0.1$, $r = 0.05$, $T = 0.005$, $N_t = 8$.\n- Case D (short maturity, higher volatility): $\\sigma = 0.3$, $r = 0.05$, $T = 0.02$, $N_t = 64$.\n\nYour program must compute $R$ for each case in the order A, B, C, D and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3,x_4]$. Each $x_i$ should be a floating-point number. Rounding is not mandated, but a fixed number of decimal places is acceptable.\n\nEnsure scientific realism and internal consistency in your implementation. Use only standard finite difference discretizations as described. Do not use any closed-form pricing formulas in your metric; assess oscillations purely through discrete convexity in the strike neighborhood.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the Black-Scholes model and standard numerical analysis techniques, well-posed with a complete and consistent setup, and objective in its formulation. We shall proceed with a full solution.\n\nThe problem requires the implementation and comparison of two finite difference methods for the Black-Scholes partial differential equation (PDE) for a European call option. The goal is to quantify numerical oscillations near the strike price at short maturities.\n\nThe Black-Scholes PDE is given by:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nThis is a final-value problem, with the terminal condition at maturity $t=T$ being the option's payoff function:\n$$\nV(S,T) = \\max(S-K, 0)\n$$\nTo solve this numerically, we typically transform it into an initial value problem. Let $\\tau = T - t$. This transformation changes the time derivative $\\frac{\\partial}{\\partial t}$ to $-\\frac{\\partial}{\\partial \\tau}$, and the problem is solved forward in $\\tau$ from $\\tau=0$ (maturity) to $\\tau=T$ (today). The PDE becomes:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nThis is a parabolic PDE of the form $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$, where $\\mathcal{L}$ is a linear spatial differential operator.\n\nWe discretize the spatial domain $S \\in [0, S_{\\max}]$ into $M$ intervals of width $\\Delta S = S_{\\max}/M$, such that $S_j = j \\Delta S$ for $j \\in \\{0, 1, \\dots, M\\}$. The time domain $\\tau \\in [0, T]$ is discretized into $N_t$ steps of size $\\Delta\\tau = T/N_t$, such that $\\tau_n = n \\Delta\\tau$ for $n \\in \\{0, 1, \\dots, N_t\\}$. Let $V_j^n$ denote the numerical approximation of $V(S_j, \\tau_n)$.\n\nUsing standard central finite differences for the spatial derivatives, the operator $\\mathcal{L}$ at grid point $S_j$ is approximated by:\n$$\n(\\mathcal{L}_h V)_j = \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} - \\frac{r S_j}{2\\Delta S}\\right)V_{j-1} + \\left(-\\frac{\\sigma^2 S_j^2}{(\\Delta S)^2} - r\\right)V_j + \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} + \\frac{r S_j}{2\\Delta S}\\right)V_{j+1}\n$$\nwhere $\\mathcal{L}_h$ is the discrete spatial operator. A more direct approach is standard. Let us define the coefficients for the time-stepping schemes directly:\nLet $\\tilde{\\alpha}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 - rj\\right)$, $\\tilde{\\beta}_j = \\Delta\\tau\\left(\\sigma^2 j^2 + r\\right)$, $\\tilde{\\gamma}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 + rj\\right)$.\n\n**1. Fully Explicit Method**\nThis method uses a forward Euler discretization in $\\tau$: $\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\mathcal{L}_h V^n$. The update rule for interior nodes ($j = 1, \\dots, M-1$) is:\n$$\nV_j^{n+1} = (1 - \\tilde{\\beta}_j)V_j^n + \\tilde{\\alpha}_j V_{j-1}^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\nThis scheme is computationally simple but is only conditionally stable. For each time step, we compute the vector of new values $V^{n+1}$ based on the vector $V^n$ from the previous step.\n\n**2. Crank-Nicolson Method**\nThis method uses the trapezoidal rule for the time derivative: $\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\frac{1}{2}(\\mathcal{L}_h V^n + \\mathcal{L}_h V^{n+1})$. This is an implicit method, which leads to a system of linear equations at each time step. The system for the unknowns $V^{n+1}$ is:\n$$\n-\\tilde{\\alpha}_j V_{j-1}^{n+1} + (1 + \\tilde{\\beta}_j/2) V_j^{n+1} - \\tilde{\\gamma}_j V_{j+1}^{n+1} = \\tilde{\\alpha}_j V_{j-1}^n + (1 - \\tilde{\\beta}_j/2) V_j^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\nThe left-hand side contains the unknown values at step $n+1$, forming a tridiagonal system of equations $A \\boldsymbol{V}^{n+1} = \\boldsymbol{b}$, where $\\boldsymbol{V}^{n+1}$ is the vector of unknown option prices. The matrix $A$ is constant throughout the time-stepping process, allowing for efficient solution using a tridiagonal solver like the Thomas algorithm.\n\n**Boundary Conditions**\nFor both methods, the boundary conditions must be applied at each time step $n$:\n- At $S=0$: $V_0^{n+1} = 0$.\n- At $S=S_{\\max}$: $V_M^{n+1} = S_{\\max} - K e^{-r \\tau_{n+1}}$.\nFor the Crank-Nicolson method, the known value $V_M^{n+1}$ is moved to the right-hand side of the linear system in the equation for node $j=M-1$.\n\n**Oscillation Metric**\nThe solution's convexity is evaluated at $\\tau=T$ (i.e., $t=0$). The discrete second difference at a spatial node $j$ is $\\Delta^2 V_j = V_{j+1} - 2V_j + V_{j-1}$. For a European call, the price is a convex function of $S$, so we expect $\\Delta^2 V_j \\ge 0$. The oscillation amplitude $\\mathcal{O}$ is defined as the maximum value of the negative part of the second difference in a window around the strike price $K$:\n$$\n\\mathcal{O} = \\max_{j \\in W} \\left( 0, - (V_{j+1} - 2V_j + V_{j-1}) \\right)\n$$\nwhere the window $W$ is $\\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$ with $j_K = \\mathrm{round}(K/\\Delta S)$. A larger $\\mathcal{O}$ signifies more severe spurious oscillations. The final required output is the ratio $R = \\mathcal{O}_{\\mathrm{CN}} / (\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon)$.\n\nThe procedure is implemented for each test case by:\n1. Setting up the spatial and temporal grids.\n2. Initializing the solution vector with the terminal condition $V(S,T)$.\n3. Iterating from $\\tau=0$ to $\\tau=T$ using either the explicit or Crank-Nicolson update rules, applying boundary conditions at each step.\n4. After the final time step, calculating the oscillation metric $\\mathcal{O}$ for each method.\n5. Computing the ratio $R$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\n\ndef solve_black_scholes_fdm(params, method):\n    \"\"\"\n    Solves the Black-Scholes PDE using the specified finite difference method.\n\n    Args:\n        params (dict): Dictionary of parameters (K, S_max, M, T, N_t, r, sigma).\n        method (str): 'explicit' or 'cn' (Crank-Nicolson).\n\n    Returns:\n        numpy.ndarray: The option prices at t=0 across the spatial grid.\n    \"\"\"\n    K, S_max, M, T, N_t, r, sigma = params['K'], params['S_max'], params['M'], params['T'], params['N_t'], params['r'], params['sigma']\n\n    # Grid setup\n    dS = S_max / M\n    dt = T / N_t  # This is delta_tau\n    S = np.linspace(0, S_max, M + 1)\n    \n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S - K, 0)\n    \n    # Coefficients for the discretized PDE (do not depend on time)\n    # These are for the interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * dt * (sigma**2 * j**2 - r * j)\n    beta = dt * (sigma**2 * j**2 + r)\n    gamma = 0.5 * dt * (sigma**2 * j**2 + r * j)\n\n    if method == 'explicit':\n        # Time-stepping loop\n        for n in range(N_t):\n            V_old = V.copy()\n            # Vectorized update for interior points\n            V[1:M] = (1 - beta) * V_old[1:M] + alpha * V_old[0:M-1] + gamma * V_old[2:M+1]\n            \n            # Apply boundary conditions for the next step\n            V[0] = 0.0\n            V[M] = S_max - K * np.exp(-r * (n + 1) * dt)\n            \n    elif method == 'cn':\n        # Setup the tridiagonal matrix A for the linear system A*V_new = B\n        # The coefficients alpha and gamma are defined with 0.5*dt, which is correct for CN.\n        # The beta coefficient was defined with a full dt for the explicit method.\n        # For CN, the central coefficient must also be scaled by 0.5*dt.\n        beta_cn = beta / 2.0\n        \n        l_diag = -alpha[1:]      # Lower diagonal\n        m_diag = 1 + beta_cn\n        u_diag = -gamma[:-1]     # Upper diagonal\n        \n        # Matrix A in banded format for scipy solver\n        # 1st row: super-diagonal, 2nd row: main-diagonal, 3rd row: sub-diagonal\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = u_diag\n        A_banded[1, :] = m_diag\n        A_banded[2, :-1] = l_diag\n\n        # Time-stepping loop\n        for n in range(N_t):\n            # Setup RHS vector B using the correct CN formulation\n            B = alpha * V[0:M-1] + (1 - beta_cn) * V[1:M] + gamma * V[2:M+1]\n\n            # Adjust RHS for boundary conditions\n            # BC at S=0 (V[0]=0) does not require adjustment as alpha[0]*V[0]=0\n            # For CN, the boundary condition term is an average of old and new values.\n            # (A_new * V_new)_M-1 = ... + gamma_M-1 * (V_M_new + V_M_old)\n            # LHS_M-1 contains -gamma_M-1 * V_M_new, so we add it back and add the old part\n            v_M_new = S_max - K * np.exp(-r * (n + 1) * dt)\n            v_M_old = S_max - K * np.exp(-r * n * dt)\n            B[-1] += gamma[-1] * (v_M_new + v_M_old) # Correction on original code\n            \n            # The original code's BC handling was simplified and incorrect for CN.\n            # Let's use the standard formulation: move known terms from LHS to RHS.\n            # Reset B and build it correctly.\n            B = alpha * V[0:M-1] + (1 - beta_cn) * V[1:M] + gamma * V[2:M+1]\n            B[-1] += gamma[-1] * V[M] # From RHS part\n            B[-1] += gamma[-1] * v_M_new # From LHS part moved to RHS\n            \n            # Solve the linear system\n            V[1:M] = solve_banded((1, 1), A_banded, B)\n            \n            # Update boundary conditions\n            V[0] = 0.0\n            V[M] = v_M_new\n            \n    return V\n\ndef calculate_oscillation_metric(V, K, S_max, M, w):\n    \"\"\"\n    Calculates the oscillation metric from the final option prices.\n    \"\"\"\n    dS = S_max / M\n    j_K = int(round(K / dS))\n    \n    start_j = max(1, j_K - w)\n    end_j = min(M - 1, j_K + w)\n    \n    max_neg_convexity = 0.0\n    for j in range(start_j, end_j + 1):\n        second_diff = V[j+1] - 2 * V[j] + V[j-1]\n        max_neg_convexity = max(max_neg_convexity, -second_diff)\n\n    return max_neg_convexity\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 10},\n        # Case B\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 40},\n        # Case C\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.1, 'r': 0.05, 'T': 0.005, 'N_t': 8},\n        # Case D\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.3, 'r': 0.05, 'T': 0.02, 'N_t': 64},\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for params in test_cases:\n        # Solve with Crank-Nicolson\n        V_cn = solve_black_scholes_fdm(params, method='cn')\n        osc_cn = calculate_oscillation_metric(V_cn, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Solve with Explicit method\n        V_exp = solve_black_scholes_fdm(params, method='explicit')\n        osc_exp = calculate_oscillation_metric(V_exp, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Calculate the ratio\n        ratio = osc_cn / (osc_exp + epsilon)\n        results.append(ratio)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2439346"}, {"introduction": "Having observed the potential for numerical oscillations in the Crank-Nicolson scheme, we now turn to a classic technique for mitigating them: Rannacher time-stepping. This method addresses the root cause—the non-smooth initial condition—by applying a few highly damping implicit steps at the beginning of the time evolution to smooth the solution before switching to the higher-order Crank-Nicolson scheme. In this practice [@problem_id:2439391], you will implement this smoothing technique and quantify its significant impact on accuracy, especially for instruments like digital options whose discontinuous payoffs are particularly challenging.", "problem": "You are asked to compute the time-zero value of a cash-or-nothing digital call option by solving the Black–Scholes Partial Differential Equation (PDE) on a bounded spatial domain using two distinct time-discretization schemes. The underlying asset price is modeled under a risk-neutral geometric Brownian motion, and the value function $V(S,t)$ satisfies the Black–Scholes PDE\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\non a domain $S \\in [0, S_{\\max}]$, $t \\in [0, T]$, with terminal condition at $t = T$\n$$\nV(S,T) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\nand boundary conditions for all $t \\in [0,T]$\n$$\nV(0,t) = 0,\\qquad \\lim_{S \\to \\infty} V(S,t) = e^{-r (T - t)}.\n$$\nOn the bounded domain, you must use $S_{\\max} = 4K$ and impose the boundary condition at $S = S_{\\max}$ by setting $V(S_{\\max}, t) = e^{-r (T - t)}$. Work in the transformed time-to-maturity variable $\\tau = T - t$, so that the evolution forward in $\\tau$ from $\\tau = 0$ to $\\tau = T$ satisfies\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V,\n$$\nwith initial condition at $\\tau = 0$\n$$\nV(S,0) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\nand boundary conditions $V(0,\\tau) = 0$, $V(S_{\\max}, \\tau) = e^{-r \\tau}$.\n\nDiscretize the spatial domain $[0, S_{\\max}]$ uniformly with $M$ equal intervals (thus $M+1$ grid points), and advance in time-to-maturity with $N$ equal time steps of size $\\Delta \\tau = T/N$. Construct both of the following schemes on the same grid:\n\n- Scheme A: Use a time-discretization that is unconditionally stable and second-order accurate in time for all $N$ steps.\n- Scheme B: Use a time-discretization that is first-order accurate and unconditionally stable for two initial half time steps of size $\\Delta \\tau/2$ each, and then use the same second-order accurate scheme as in Scheme A for the remaining $N-1$ full steps of size $\\Delta \\tau$.\n\nFor the spatial operator, use standard centered second-order finite differences on the uniform spatial grid for the first and second derivatives. For each parameter set, compute the option value at $S = S_0$ by linear interpolation from the computed spatial grid at $\\tau = T$ under both schemes. Quantify the accuracy by comparing to the closed-form Black–Scholes value of a cash-or-nothing digital call option at time zero,\n$$\nV_{\\text{BS}}(S_0,0) = e^{-rT}\\,\\Phi(d_2),\\quad d_2 = \\frac{\\ln(S_0/K) + \\left(r - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma \\sqrt{T}},\n$$\nwhere $\\Phi(\\cdot)$ is the standard normal cumulative distribution function. For each case, report three floats: the absolute error of Scheme A, the absolute error of Scheme B, and the difference in absolute errors (Scheme A minus Scheme B). Positive difference indicates an improvement by Scheme B.\n\nUse the following common discretization parameters for all test cases:\n- Spatial grid size $M = 400$,\n- Time steps $N = 200$,\n- Upper boundary $S_{\\max} = 4K$.\n\nTest suite (each tuple lists $(S_0, K, r, \\sigma, T)$):\n\n1. $(S_0, K, r, \\sigma, T) = (100, 100, 0.05, 0.2, 1.0)$,\n2. $(S_0, K, r, \\sigma, T) = (80, 100, 0.01, 0.4, 0.25)$,\n3. $(S_0, K, r, \\sigma, T) = (120, 100, 0.10, 0.15, 2.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$[\\text{errA}_1, \\text{errB}_1, \\text{errA}_1 - \\text{errB}_1, \\text{errA}_2, \\text{errB}_2, \\text{errA}_2 - \\text{errB}_2, \\text{errA}_3, \\text{errB}_3, \\text{errA}_3 - \\text{errB}_3]$,\nwhere $\\text{errA}_i$ and $\\text{errB}_i$ are the absolute errors of Scheme A and Scheme B respectively for test case $i$. All quantities are dimensionless and should be reported as decimal numbers.", "solution": "The problem presented is a valid and well-posed initial-boundary value problem from the field of computational finance. It requires the numerical solution of the Black-Scholes partial differential equation (PDE) for a cash-or-nothing digital call option using finite difference methods. All parameters, conditions, and numerical schemes are specified with sufficient clarity to permit a unique solution. The core of the problem is to compare the accuracy of the standard Crank-Nicolson scheme with a modified version employing Rannacher time-stepping to handle the non-smooth initial condition. This is a standard and meaningful exercise in numerical analysis for PDEs.\n\nWe begin with the Black-Scholes PDE transformed to time-to-maturity coordinates, $\\tau = T - t$. The value of the option, $V(S, \\tau)$, is governed by:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nThis is a parabolic PDE, which we can write in a more compact form as $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$, where $\\mathcal{L}$ is the spatial differential operator:\n$$\n\\mathcal{L} \\equiv \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r\n$$\nThe problem is solved on the domain $S \\in [0, S_{\\max}]$ and $\\tau \\in [0, T]$, with $S_{\\max} = 4K$. The initial condition at $\\tau=0$ (corresponding to time $t=T$) is the discontinuous payoff of the digital option:\n$$\nV(S, 0) = H(S-K) = \\begin{cases} 1, & \\text{if } S > K \\\\ 0, & \\text{if } S \\le K \\end{cases}\n$$\nThe boundary conditions are $V(0, \\tau) = 0$ and $V(S_{\\max}, \\tau) = e^{-r\\tau}$ for all $\\tau \\in [0, T]$.\n\nWe discretize the spatial domain into $M=400$ intervals of width $\\Delta S = S_{\\max}/M$, creating a grid of points $S_j = j\\Delta S$ for $j = 0, 1, \\dots, M$. The time-to-maturity domain is discretized into $N=200$ steps of size $\\Delta\\tau = T/N$, with time points $\\tau_k = k\\Delta\\tau$. Let $V_j^k$ denote the numerical approximation of $V(S_j, \\tau_k)$.\n\nThe spatial derivatives in the operator $\\mathcal{L}$ are approximated using second-order central finite differences for the interior grid points $j = 1, \\dots, M-1$:\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - V_{j-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - 2V_j + V_{j-1}}{(\\Delta S)^2}\n$$\nApplying these to $\\mathcal{L}V$ at grid point $S_j$ gives:\n$$\n(\\mathcal{L}V)_j \\approx a_j V_{j-1} + b_j V_j + c_j V_{j+1}\n$$\nwhere the coefficients are defined as:\n$$\na_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - \\frac{r S_j}{2\\Delta S}\n$$\n$$\nb_j = - \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - r\n$$\n$$\nc_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 + \\frac{r S_j}{2\\Delta S}\n$$\nThis semi-discretization results in a system of ordinary differential equations for the vector of interior unknowns $\\mathbf{V}(\\tau) = [V_1(\\tau), \\dots, V_{M-1}(\\tau)]^T$:\n$$\n\\frac{d\\mathbf{V}}{d\\tau} = \\mathbf{A}\\mathbf{V} + \\mathbf{f}(\\tau)\n$$\nHere, $\\mathbf{A}$ is a tridiagonal matrix whose entries are derived from the coefficients $a_j$, $b_j$, $c_j$. The vector $\\mathbf{f}(\\tau)$ contains terms arising from the boundary conditions. Specifically, $V_0=0$ is handled by starting the grid at $j=1$, and the condition at $S_M = S_{\\max}$ contributes a term to the equation for $V_{M-1}$: the last component of $\\mathbf{f}(\\tau)$ is $c_{M-1}V(S_M, \\tau) = c_{M-1}e^{-r\\tau}$.\n\nWe now apply the specified time-stepping schemes.\n\n**Scheme A: Crank-Nicolson Method**\nThis scheme is second-order accurate in time and unconditionally stable. It averages the spatial operator between time levels $k$ and $k+1$:\n$$\n\\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1}) + (\\mathbf{A}\\mathbf{V}^k + \\mathbf{f}^k) \\right)\n$$\nRearranging terms yields a linear system to be solved for $\\mathbf{V}^{k+1}$ at each time step:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^k + \\frac{\\Delta\\tau}{2}(\\mathbf{f}^{k+1} + \\mathbf{f}^k)\n$$\nThe matrix on the left-hand side is tridiagonal and constant throughout the time-stepping, allowing for efficient solution via a tridiagonal matrix algorithm.\n\n**Scheme B: Rannacher Smoothing**\nThe Crank-Nicolson method, while high-order, is known to produce spurious oscillations when applied to problems with non-smooth initial data, such as the Heaviside function in this problem. These oscillations can degrade the accuracy. Scheme B is designed to mitigate this. It uses a strongly damping, first-order method for the initial steps to smooth the solution before switching to the more accurate Crank-Nicolson method.\n\n1.  **Initial Smoothing Steps:** We use the Implicit Euler method for two steps of size $\\Delta\\tau/2$. The Implicit Euler method is first-order accurate and L-stable, which provides strong damping of high-frequency error components. For a step of size $\\Delta\\tau'$, its formulation is:\n    $$\n    \\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau'} = \\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1} \\implies \\left(\\mathbf{I} - \\Delta\\tau'\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\mathbf{V}^k + \\Delta\\tau'\\mathbf{f}^{k+1}\n    $$\n    We apply this twice with $\\Delta\\tau' = \\Delta\\tau/2$, advancing the solution from $\\tau=0$ to $\\tau=\\Delta\\tau/2$, and then to $\\tau=\\Delta\\tau$.\n\n2.  **Crank-Nicolson Steps:** For the remaining $N-1$ steps, from $\\tau=\\Delta\\tau$ to $\\tau=T$, the solution is sufficiently smooth, and we switch to the standard Crank-Nicolson scheme with step size $\\Delta\\tau$ as in Scheme A.\n\nAfter $N$ total time steps, both schemes produce a vector of option values $\\mathbf{V}^N$ at $\\tau=T$. The final value at the specific spot price $S_0$ is obtained by linear interpolation on the grid of computed values $[V_0^N, V_1^N, \\dots, V_M^N]^T$, where $V_0^N=0$ and $V_M^N=e^{-rT}$. The accuracy of each scheme is measured by the absolute error against the analytical Black-Scholes formula for a cash-or-nothing digital call:\n$$\nV_{\\text{BS}}(S_0, 0) = e^{-rT}\\Phi(d_2), \\quad \\text{with} \\quad d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution. The implementation will compute the values for both schemes and report the required error metrics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.stats import norm\n\ndef compute_option_values(S0, K, r, sigma, T, M, N):\n    \"\"\"\n    Computes the price of a cash-or-nothing digital call option using Scheme A and Scheme B.\n    \"\"\"\n\n    # 1. Grid and parameter setup\n    S_max = 4.0 * K\n    ds = S_max / M\n    dt = T / N\n\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # 2. PDE coefficients (based on dV/d(tau) = a*V_{j-1} + b*V_j + c*V_{j+1})\n    # These coefficients are from the spatial operator L and do not include dt or ds factors\n    j = np.arange(1, M)\n    S_j = j * ds\n    alpha = 0.5 * (sigma*S_j/ds)**2 - 0.5 * r*S_j/ds\n    beta = - (sigma*S_j/ds)**2 - r\n    gamma = 0.5 * (sigma*S_j/ds)**2 + 0.5 * r*S_j/ds\n\n    # 3. Initial condition for V(S, tau=0)\n    V0 = np.zeros(M + 1)\n    V0[S_grid > K] = 1.0\n    V0_int = V0[1:M] # Interior points V_1 to V_{M-1}\n\n    # --- Scheme A: Crank-Nicolson for all steps ---\n    V_A = V0_int.copy()\n\n    # LHS matrix for CN, constant through time\n    mat_LHS_CN = np.zeros((3, M - 1))\n    mat_LHS_CN[0, 1:] = -0.5 * dt * gamma[:-1]\n    mat_LHS_CN[1, :] = 1.0 - 0.5 * dt * beta\n    mat_LHS_CN[2, :-1] = -0.5 * dt * alpha[1:]\n\n    for k in range(N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_A\n        # RHS = V_A + 0.5 * dt * A * V_A\n        RHS = (1 + 0.5 * dt * beta) * V_A\n        RHS[:-1] += 0.5 * dt * alpha[1:] * V_A[1:] # This is a_j * v_{j-1}\n        RHS[1:] += 0.5 * dt * gamma[:-1] * V_A[:-1] # This is c_j * v_{j+1}\n\n        # Add boundary condition term for V_M\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_A = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Scheme B: Rannacher Smoothing (IE + CN) ---\n    V_B = V0_int.copy()\n    dt_half = dt / 2.0\n\n    # LHS matrix for IE steps, constant\n    mat_LHS_IE = np.zeros((3, M - 1))\n    mat_LHS_IE[0, 1:] = -dt_half * gamma[:-1]\n    mat_LHS_IE[1, :] = 1.0 - dt_half * beta\n    mat_LHS_IE[2, :-1] = -dt_half * alpha[1:]\n\n    # First IE half-step (tau = 0 to dt/2)\n    RHS_IE1 = V_B.copy()\n    bc_term_1 = dt_half * gamma[-1] * np.exp(-r * dt_half)\n    RHS_IE1[-1] += bc_term_1\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE1)\n\n    # Second IE half-step (tau = dt/2 to dt)\n    RHS_IE2 = V_B.copy()\n    bc_term_2 = dt_half * gamma[-1] * np.exp(-r * dt)\n    RHS_IE2[-1] += bc_term_2\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE2)\n\n    # Remaining N-1 CN steps (tau = dt to T)\n    for k in range(1, N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_B\n        RHS = (1 + 0.5 * dt * beta) * V_B\n        RHS[:-1] += 0.5 * dt * alpha[1:] * V_B[1:]\n        RHS[1:] += 0.5 * dt * gamma[:-1] * V_B[:-1]\n\n        # Add boundary condition term\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_B = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Final value extraction ---\n    \n    # Reconstruct full solution vectors at tau=T\n    V_final_A = np.zeros(M + 1)\n    V_final_A[1:M] = V_A\n    V_final_A[M] = np.exp(-r * T)\n    \n    V_final_B = np.zeros(M + 1)\n    V_final_B[1:M] = V_B\n    V_final_B[M] = np.exp(-r * T)\n    \n    # Interpolate to find value at S0\n    val_A = np.interp(S0, S_grid, V_final_A)\n    val_B = np.interp(S0, S_grid, V_final_B)\n\n    return val_A, val_B\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and format output.\n    \"\"\"\n    # Common discretization parameters\n    M = 400\n    N = 200\n\n    # Test suite: (S0, K, r, sigma, T)\n    test_cases = [\n        (100.0, 100.0, 0.05, 0.2, 1.0),\n        (80.0, 100.0, 0.01, 0.4, 0.25),\n        (120.0, 100.0, 0.10, 0.15, 2.0),\n    ]\n\n    results = []\n    for S0, K, r, sigma, T in test_cases:\n        # Compute numerical values\n        val_A, val_B = compute_option_values(S0, K, r, sigma, T, M, N)\n\n        # Compute analytical value\n        with np.errstate(divide='ignore'):\n            d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        if S0 == K and T > 0: # handle log(1)\n            d2 = ((r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n\n        analytical_val = np.exp(-r * T) * norm.cdf(d2)\n\n        # Compute errors\n        err_A = abs(val_A - analytical_val)\n        err_B = abs(val_B - analytical_val)\n        err_diff = err_A - err_B\n\n        results.extend([err_A, err_B, err_diff])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The original code's RHS construction in compute_option_values was incorrect.\n# The corrected version uses a different (but still incorrect) vector indexing.\n# The following code is the fully corrected version.\ndef compute_option_values_corrected(S0, K, r, sigma, T, M, N):\n    S_max = 4.0 * K\n    ds = S_max / M\n    dt = T / N\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    j = np.arange(1, M)\n    S_j = j * ds\n    alpha = 0.5 * (sigma*S_j/ds)**2 - 0.5 * r*S_j/ds\n    beta = - (sigma*S_j/ds)**2 - r\n    gamma = 0.5 * (sigma*S_j/ds)**2 + 0.5 * r*S_j/ds\n\n    V0 = np.zeros(M + 1)\n    V0[S_grid > K] = 1.0\n    V0_int = V0[1:M]\n\n    # Scheme A\n    V_A = V0_int.copy()\n    mat_LHS_CN = np.zeros((3, M - 1))\n    mat_LHS_CN[0, 1:] = -0.5 * dt * gamma[:-1]\n    mat_LHS_CN[1, :] = 1.0 - 0.5 * dt * beta\n    mat_LHS_CN[2, :-1] = -0.5 * dt * alpha[1:]\n\n    for k in range(N):\n        tau_k, tau_k1 = k * dt, (k + 1) * dt\n        RHS = np.zeros(M-1)\n        RHS[0] = (1+0.5*dt*beta[0])*V_A[0] + (0.5*dt*gamma[0])*V_A[1]\n        RHS[1:-1] = (0.5*dt*alpha[1:-1])*V_A[:-2] + (1+0.5*dt*beta[1:-1])*V_A[1:-1] + (0.5*dt*gamma[1:-1])*V_A[2:]\n        RHS[-1] = (0.5*dt*alpha[-1])*V_A[-2] + (1+0.5*dt*beta[-1])*V_A[-1]\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n        V_A = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # Scheme B\n    V_B = V0_int.copy()\n    dt_half = dt / 2.0\n    mat_LHS_IE = np.zeros((3, M - 1))\n    mat_LHS_IE[0, 1:] = -dt_half * gamma[:-1]\n    mat_LHS_IE[1, :] = 1.0 - dt_half * beta\n    mat_LHS_IE[2, :-1] = -dt_half * alpha[1:]\n\n    RHS_IE1 = V_B.copy(); RHS_IE1[-1] += dt_half * gamma[-1] * np.exp(-r * dt_half)\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE1)\n    RHS_IE2 = V_B.copy(); RHS_IE2[-1] += dt_half * gamma[-1] * np.exp(-r * dt)\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE2)\n\n    for k in range(1, N):\n        tau_k, tau_k1 = k * dt, (k + 1) * dt\n        RHS = np.zeros(M-1)\n        RHS[0] = (1+0.5*dt*beta[0])*V_B[0] + (0.5*dt*gamma[0])*V_B[1]\n        RHS[1:-1] = (0.5*dt*alpha[1:-1])*V_B[:-2] + (1+0.5*dt*beta[1:-1])*V_B[1:-1] + (0.5*dt*gamma[1:-1])*V_B[2:]\n        RHS[-1] = (0.5*dt*alpha[-1])*V_B[-2] + (1+0.5*dt*beta[-1])*V_B[-1]\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n        V_B = solve_banded((1, 1), mat_LHS_CN, RHS)\n        \n    V_final_A = np.interp(S0, S_grid, np.concatenate(([0], V_A, [np.exp(-r * T)])))\n    V_final_B = np.interp(S0, S_grid, np.concatenate(([0], V_B, [np.exp(-r * T)])))\n    return V_final_A, V_final_B\n\n# The provided code had multiple errors in its implementation. It has been replaced with a corrected one.\n# It is not possible to regenerate the output without a live environment.\n# The `solve` function below uses the corrected logic.\n# The original code is left commented out to show the extent of corrections.\nif __name__ == '__main__':\n    # solve() # This would call the original, buggy version.\n    \n    # Corrected solve function\n    M, N = 400, 200\n    test_cases = [\n        (100.0, 100.0, 0.05, 0.2, 1.0),\n        (80.0, 100.0, 0.01, 0.4, 0.25),\n        (120.0, 100.0, 0.10, 0.15, 2.0),\n    ]\n    results = []\n    for S0, K, r, sigma, T in test_cases:\n        val_A, val_B = compute_option_values_corrected(S0, K, r, sigma, T, M, N)\n        with np.errstate(divide='ignore'):\n            d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        analytical_val = np.exp(-r * T) * norm.cdf(d2)\n        err_A = abs(val_A - analytical_val)\n        err_B = abs(val_B - analytical_val)\n        err_diff = err_A - err_B\n        results.extend([err_A, err_B, err_diff])\n    print(f\"[{','.join(map(str, results))}]\")\n\n```", "id": "2439391"}, {"introduction": "Our exploration culminates in applying the finite difference framework to a more complex and commercially important problem: pricing an American option. The possibility of early exercise transforms the Black-Scholes partial differential equation into a free-boundary problem, where at each point in time and space, we must enforce that the option's value is at least its intrinsic exercise value, $V(S,t) \\ge \\max(K-S, 0)$. This practice [@problem_id:2439350] guides you through adapting the Crank-Nicolson method to solve this linear complementarity problem by integrating the Projected Successive Over-Relaxation (PSOR) iterative solver at each time step, a fundamental skill for pricing a wide array of American-style derivatives.", "problem": "You are asked to implement a numerical solver for the early-exercise premium of an American put option under the Black–Scholes framework, using the Crank–Nicolson time-stepping scheme combined with the Projected Successive Over-Relaxation (PSOR) method at each time step to enforce the inequality constraints. Your program must be a complete, runnable program that takes no input and prints the results for a fixed test suite as specified below.\n\nStart from the following fundamental base:\n- Risk-neutral valuation and the no-arbitrage partial differential equation (PDE) for the arbitrage-free price of a derivative written on a non-dividend or dividend-paying underlying. Under the risk-neutral measure, the underlying price $S$ follows a geometric Brownian motion with drift $r - q$, where $r$ is the continuously-compounded risk-free rate and $q$ is the continuous dividend yield. The Black–Scholes partial differential equation (PDE) for a sufficiently smooth price function $V(S,t)$ is\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nwhere $\\sigma$ is the constant volatility, $r$ is the constant risk-free rate, and $q$ is the constant dividend yield.\n- For an American put option with strike $K$ and maturity $T$, the value $V(S,t)$ must satisfy the linear complementarity conditions\n$$\nV(S,t) \\geq \\max(K - S, 0), \\quad -\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V \\geq 0,\n$$\nand the pointwise complementarity\n$$\n\\left(V(S,t) - \\max(K - S, 0)\\right)\\left(-\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V\\right) = 0,\n$$\nfor all $S \\geq 0$ and $t \\in [0,T)$. The terminal payoff condition is\n$$\nV(S,T) = \\max(K - S, 0).\n$$\nUse boundary conditions consistent with economic reasoning: for the American put, for all $t \\in [0,T]$, at the lower boundary $S = 0$ take $V(0,t) = K$, and for a sufficiently large upper boundary $S = S_{\\max}$ take $V(S_{\\max}, t) = 0$.\n\nTask requirements:\n- Discretize the spatial domain $S \\in [0, S_{\\max}]$ on a uniform grid with $N$ subintervals, $\\Delta S = S_{\\max} / N$, and the temporal domain $[0,T]$ with $M$ uniform steps of size $\\Delta t = T/M$. Apply the Crank–Nicolson method to the interior grid nodes to form, at each backward time step, a tridiagonal linear complementarity problem (LCP).\n- At each time step, solve the discrete LCP using the Projected Successive Over-Relaxation (PSOR) method. The iteration must use an over-relaxation factor $\\omega \\in (0,2)$ and enforce the exercise constraint by projecting the iterates onto the obstacle $\\max(K - S_i, 0)$ at each spatial node $S_i$.\n- Use linear interpolation to return the price at a given spot $S_0$ that may not lie exactly on a grid node.\n- All rates $r$, $q$, and volatility $\\sigma$ must be expressed as decimals (for example, $0.05$ for $5$ percent). Time $T$ must be in years. No angle units are involved. No percentage sign is to appear in the input or output; only decimals are used.\n\nImplementation detail expectations:\n- Derive the Crank–Nicolson semi-implicit interior-node discretization on the uniform grid, yielding a tridiagonal left-hand side for the new time level, a tridiagonal right-hand side using the previous time level, and incorporate boundary values consistently. Do not use any closed-form American pricing formulas or penalty methods; you must enforce the early-exercise constraint via PSOR.\n- Implement a stopping criterion for PSOR based on the maximum absolute change across all interior nodes being less than a tolerance $\\varepsilon$, and a hard cap on the maximum number of iterations to guarantee termination.\n- Ensure numerical stability by choosing a sufficiently large $S_{\\max}$ and sufficient spatial and temporal resolutions for each test case below.\n\nTest suite:\nCompute the American put price at the spot $S_0$ for each parameter set below. Use the specified $S_{\\max}$, $N$, $M$, PSOR relaxation $\\omega$, tolerance $\\varepsilon$, and maximum iterations per time step $I_{\\max}$. Parameters are given as tuples $(S_0, K, T, r, q, \\sigma, S_{\\max}, N, M, \\omega, \\varepsilon, I_{\\max})$:\n- Case $1$ (baseline, one year, moderate volatility): $(100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $2$ (one year, high volatility, low rate): $(100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $3$ (one year, zero rate): $(100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $4$ (short maturity, in-the-money): $(50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1\\times 10^{-8}, 10000)$.\n\nFinal output specification:\n- Your program must produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, ordered by the cases $1$ through $4$.\n- Each number must be rounded to exactly $6$ decimal places.\n- For example, the output format must look like $[v_1,v_2,v_3,v_4]$, where each $v_i$ is a float rounded to $6$ decimals.", "solution": "The user has specified a problem in computational finance: pricing an American put option by numerically solving the Black-Scholes partial differential equation (PDE) with early-exercise constraints. The problem is scientifically grounded, well-posed, and all necessary parameters for a complete solution are provided. It is therefore deemed valid. The solution requires implementing the Crank-Nicolson method for time discretization and the Projected Successive Over-Relaxation (PSOR) method to handle the linear complementarity problem arising from the early-exercise feature.\n\nThe Black-Scholes model for an option price $V(S,t)$, where $S$ is the underlying asset price and $t$ is time, is given by the PDE:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nHere, $r$ is the risk-free interest rate, $q$ is the continuous dividend yield, and $\\sigma$ is the volatility of the underlying asset. For an American put option, this equation becomes an inequality, and the solution must satisfy a linear complementarity formulation, as it is a free-boundary problem. The price must always be greater than or equal to its intrinsic value, $V(S,t) \\geq \\max(K-S, 0)$, where $K$ is the strike price.\n\nThis is a terminal value problem, solved backwards in time from maturity $T$ to the present time $t=0$. To facilitate a standard forward-stepping numerical scheme, we perform a change of variable for time, $\\tau = T - t$. The PDE becomes:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V\n$$\nWe discretize the spatial domain $S \\in [0, S_{\\max}]$ into $N$ intervals of size $\\Delta S = S_{\\max}/N$, creating grid points $S_i = i\\Delta S$ for $i=0, 1, \\dots, N$. The time domain $\\tau \\in [0, T]$ is discretized into $M$ steps of size $\\Delta \\tau = T/M$, creating time points $\\tau_j = j\\Delta\\tau$ for $j=0, 1, \\dots, M$. Let $V_i^j$ denote the numerical approximation of $V(S_i, \\tau_j)$.\n\nThe Crank-Nicolson method approximates the time derivative at the midpoint $\\tau_{j+1/2}$ and averages the spatial operator over time levels $j$ and $j+1$:\n$$\n\\frac{V^{j+1} - V^{j}}{\\Delta \\tau} = \\frac{1}{2}(\\mathcal{L}V^{j+1} + \\mathcal{L}V^{j})\n$$\nwhere $\\mathcal{L}$ is the spatial differential operator. Rearranging gives a system of linear equations to solve at each time step:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j+1} = \\left(\\mathbf{I} + \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j}\n$$\nwhere $\\mathbf{L}$ is the matrix representation of $\\mathcal{L}$ after spatial discretization using central finite differences for the derivatives $\\frac{\\partial V}{\\partial S}$ and $\\frac{\\partial^2 V}{\\partial S^2}$:\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\quad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\nSubstituting these into the operator $\\mathcal{L}$ yields a tridiagonal structure for the matrix $\\mathbf{L}$. The equation for each interior node $i=1, \\dots, N-1$ is:\n$$\nL_i V_{i-1}^{j+1} + M_i V_i^{j+1} + R_i V_{i+1}^{j+1} = Q_i\n$$\nThe coefficients are defined as:\n$$\nL_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - (r-q)i\\right)\n$$\n$$\nM_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\nR_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + (r-q)i\\right)\n$$\nThe right-hand side $Q_i$ is constructed from known values at time step $j$:\n$$\nQ_i = -L_i V_{i-1}^{j} + (2-M_i)V_i^{j} - R_i V_{i+1}^{j}\n$$\nBoundary conditions for an American put are $V(0,\\tau) = K$ and $V(S_{\\max}, \\tau) = 0$. These are incorporated by adjusting the right-hand side vector $Q$. For the first interior node $i=1$, the term $L_1 V_0^{j+1}$ moves to the right, becoming $L_1 K$. Similarly, at the last interior node $i=N-1$, the term $R_{N-1}V_N^{j+1}$ is $0$.\n\nThe early-exercise constraint requires that $V_i^{j+1} \\geq g_i = \\max(K-S_i, 0)$ for all $i$. This turns the linear system into a linear complementarity problem (LCP), which we solve using the Projected Successive Over-Relaxation (PSOR) method. For each time step, we iterate to find the vector $\\mathbf{V}^{j+1}$. The update rule for the $k$-th iteration for each interior node $i$ is:\n\n1. Compute the standard SOR update:\n$$\nv_i^{*} = (1-\\omega)V_i^{(k)} + \\frac{\\omega}{M_i} \\left( Q_i - L_i V_{i-1}^{(k+1)} - R_i V_{i+1}^{(k)} \\right)\n$$\nwhere $\\omega \\in (0,2)$ is the relaxation parameter, $V^{(k)}$ is the vector from the previous iteration, and $V^{(k+1)}$ uses already updated values within the current iteration.\n\n2. Project the result onto the exercise value (obstacle):\n$$\nV_i^{(k+1)} = \\max(v_i^{*}, g_i)\n$$\nThe PSOR iterations continue until the maximum absolute change between successive iterates across all nodes falls below a tolerance $\\varepsilon$, or a maximum number of iterations $I_{\\max}$ is reached.\n\nThe overall algorithm is as follows:\n1.  Initialize the grid of option values $\\mathbf{V}$ at maturity $\\tau=0$ (i.e., $t=T$) with the terminal payoff: $V_i^0 = \\max(K - S_i, 0)$.\n2.  Iterate backward in time from $j=0$ to $M-1$. In each step:\n    a.  Compute the right-hand side vector $\\mathbf{Q}$ using values from $\\mathbf{V}^j$.\n    b.  Adjust $\\mathbf{Q}$ for boundary conditions.\n    c.  Solve the LCP for $\\mathbf{V}^{j+1}$ using the PSOR algorithm, with $\\mathbf{V}^j$ as the initial guess.\n    d.  Enforce the boundary conditions $V_0^{j+1} = K$ and $V_N^{j+1} = 0$.\n3.  After the final time step, the vector $\\mathbf{V}^M$ contains the option prices at $t=0$.\n4.  Use linear interpolation to find the price at the specific spot $S_0$, which may not be on a grid point.\n\nThis procedure yields a robust numerical solution for the American put option price, respecting the no-arbitrage conditions and early-exercise constraints of the Black-Scholes framework.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_american_put_price(S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max):\n    \"\"\"\n    Computes the American put option price using the Crank-Nicolson FDM and PSOR.\n\n    :param S0: Initial stock price\n    :param K: Strike price\n    :param T: Time to maturity (in years)\n    :param r: Risk-free interest rate (decimal)\n    :param q: Continuous dividend yield (decimal)\n    :param sigma: Volatility (decimal)\n    :param S_max: Maximum stock price in the grid\n    :param N: Number of spatial steps\n    :param M: Number of time steps\n    :param omega: SOR relaxation factor\n    :param epsilon: PSOR tolerance\n    :param I_max: Max iterations for PSOR\n    :return: American put option price at S0\n    \"\"\"\n    # 1. Grid setup\n    dt = T / M\n    ds = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n    \n    # 2. Initialize option values at maturity (t=T)\n    V = np.maximum(K - S, 0)\n    \n    # 3. Pre-compute Crank-Nicolson coefficients for the tridiagonal system\n    # These coefficients are used for the matrix on the LHS of the time-step equation.\n    i = np.arange(1, N)  # Interior nodes\n    \n    # Coefficients for L_i * V_{i-1} + M_i * V_i + R_i * V_{i+1} = Q_i\n    L_coeffs = -0.25 * dt * (sigma**2 * i**2 - (r - q) * i)\n    M_coeffs = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n    R_coeffs = -0.25 * dt * (sigma**2 * i**2 + (r - q) * i)\n\n    # 4. Time-stepping loop (backward from T to 0)\n    for j in range(M - 1, -1, -1):\n        # Calculate the explicit part (RHS) of the CN scheme\n        Q = -L_coeffs * V[:-2] + (2 - M_coeffs) * V[1:-1] - R_coeffs * V[2:]\n\n        # Adjust RHS for boundary conditions\n        # For S=0, V=K. For S=S_max, V=0.\n        # Boundary condition V(0,t)=K affects the equation for the first interior node (i=1)\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from LHS, moved to RHS\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from RHS side\n        # V(S_max,t)=0 means the R_coeffs[N-2] term involving V_N is zero, no adjustment needed\n\n        # 5. PSOR solver for the linear complementarity problem at each time step\n        v_interior = V[1:-1].copy()  # Initial guess from previous time step\n        obstacle = np.maximum(K - S[1:-1], 0)\n\n        for k in range(I_max):\n            v_old_iter = v_interior.copy()\n\n            # Iterate through interior nodes\n            for i in range(N - 1):\n                # SOR update calculation\n                sor_sum = 0\n                if i > 0:\n                    sor_sum += L_coeffs[i] * v_interior[i - 1]\n                if i  N - 2:\n                    sor_sum += R_coeffs[i] * v_old_iter[i + 1]\n\n                v_star = (1 - omega) * v_old_iter[i] + (omega / M_coeffs[i]) * (Q[i] - sor_sum)\n                \n                # Projection step\n                v_interior[i] = max(v_star, obstacle[i])\n\n            # Check for convergence\n            if np.max(np.abs(v_interior - v_old_iter))  epsilon:\n                break\n        \n        # Update V with the solution for the current time step\n        V[1:-1] = v_interior\n        V[0] = K  # Boundary at S=0\n        V[N] = 0.0 # Boundary at S=S_max\n        \n    # 6. Interpolate to find price at S0\n    idx = int(S0 / ds)\n    if idx >= N: # Handle case where S0 is at or beyond S_max\n        return 0.0\n    \n    # Linear interpolation\n    price = V[idx] + (V[idx + 1] - V[idx]) * (S0 - S[idx]) / ds\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max)\n        (100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1e-8, 10000),\n        (50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1e-8, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {\n            \"S0\": case[0], \"K\": case[1], \"T\": case[2], \"r\": case[3], \"q\": case[4], \n            \"sigma\": case[5], \"S_max\": case[6], \"N\": case[7], \"M\": case[8], \n            \"omega\": case[9], \"epsilon\": case[10], \"I_max\": case[11]\n        }\n        price = compute_american_put_price(**params)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2439350"}]}