{"hands_on_practices": [{"introduction": "Many core concepts in economics are defined by the area under a curve. A classic example is consumer surplus, which measures the economic benefit consumers receive when the price of a good falls. This practice [@problem_id:2430268] provides a direct application of Simpson's rule to quantify this surplus by integrating various plausible demand functions. By working through this problem, you will gain hands-on experience in translating a fundamental microeconomic theory into a concrete numerical calculation.", "problem": "A regional planner seeks to quantify the daily consumer surplus created by a new highway that reduces the generalized travel price (measured in dollars per trip) faced by travelers. Let $Q(p)$ denote the trip demand as a function of the generalized price $p$ (dollars per trip). The microeconomic definition of consumer surplus from a price decrease is the area under the demand curve between the new and old prices. Starting from the definition of the Riemann integral and the fact that consumer surplus change from $p_0$ to $p_1$ with $p_1 < p_0$ equals the definite integral of $Q(p)$ with respect to $p$, the benefit can be written as the definite integral of $Q(p)$ over the interval from $p_1$ to $p_0$. Without using any shortcut formulas for numerical integration, implement the composite Simpson's rule with an even number of subintervals to approximate this integral for several economically plausible demand specifications.\n\nYour task is to write a program that:\n- Uses the composite Simpson's rule with an even number of subintervals to approximate the integral of $Q(p)$ over $[p_1,p_0]$ for each test case below.\n- Reports the resulting consumer surplus in dollars per day for each case, expressed as a floating-point number rounded to $6$ decimal places.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$x_1,x_2,x_3$]\").\n\nAssume the following demand specifications and parameter values (all $p$ are in dollars per trip, $Q$ is in trips per day, and results must be reported in dollars per day):\n\n- Test case $1$ (quadratic demand; general \"happy path\"):\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$\n  - Initial generalized price $p_0 = 12$, new generalized price $p_1 = 9$\n  - Number of subintervals $n = 100$ (ensure $n$ is even)\n\n- Test case $2$ (exponential demand; nonlinear curvature):\n  - $Q(p) = A e^{-k p}$\n  - $A = 100000$, $k = 0.15$\n  - $p_0 = 12$, $p_1 = 8$\n  - $n = 200$\n\n- Test case $3$ (logistic demand; saturation/market-size bound):\n  - $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$\n  - $N = 150000$, $k = 0.5$, $\\bar{p} = 10$\n  - $p_0 = 14$, $p_1 = 10$\n  - $n = 400$\n\n- Test case $4$ (quadratic demand with a very small price change; numerical stability near a boundary):\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$\n  - $p_0 = 10.00$, $p_1 = 9.99$\n  - $n = 10$\n\nRequirements:\n- Implement the integral approximation using the composite Simpson's rule over $[p_1,p_0]$ with the specified $n$ for each test.\n- Express each final numeric answer in dollars per day, rounded to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$ (e.g., \"[$r_1,r_2,r_3,r_4$]\").", "solution": "The problem statement has been critically examined and is determined to be **valid**. It is scientifically grounded in established microeconomic principles and calculus, well-posed with all necessary information and consistent constraints, and articulated with objective, unambiguous language. The task is to approximate a definite integral representing consumer surplus using a specified numerical method, which is a standard problem in computational science.\n\nThe core principle is the calculation of the change in consumer surplus ($\\Delta CS$) resulting from a price decrease from an initial price $p_0$ to a new, lower price $p_1$. In microeconomics, this is defined as the area under the demand curve, $Q(p)$, between these two prices. Mathematically, this is expressed as the definite integral of the demand function over the price interval:\n\n$$ \\Delta CS = \\int_{p_1}^{p_0} Q(p) \\, dp $$\n\nThe problem requires the approximation of this integral using the composite Simpson's rule, without recourse to pre-existing library functions for numerical integration. Simpson's rule is a numerical method for approximating the definite integral of a function $f(x)$ over an interval $[a, b]$. The composite version of the rule divides the interval $[a, b]$ into an even number of subintervals, $n$, of equal width, $h$.\n\nThe algorithm proceeds as follows:\n1.  **Define Integration Parameters**: For each test case, the interval of integration is $[a, b] = [p_1, p_0]$. The number of subintervals, $n$, is given and is an even integer.\n\n2.  **Calculate Subinterval Width**: The width, $h$, of each subinterval is calculated as:\n    $$ h = \\frac{b - a}{n} = \\frac{p_0 - p_1}{n} $$\n\n3.  **Establish Partition Points**: The interval $[p_1, p_0]$ is partitioned into $n$ subintervals by $n+1$ points. Let these points be denoted by $x_k$ to avoid confusion with the initial prices $p_0$ and $p_1$.\n    $$ x_k = p_1 + k \\cdot h, \\quad \\text{for } k = 0, 1, 2, \\ldots, n $$\n    Note that $x_0 = p_1$ and $x_n = p_0$.\n\n4.  **Apply Composite Simpson's Rule**: The formula for the composite Simpson's rule approximation, $S_n$, of the integral is:\n    $$ S_n = \\frac{h}{3} \\left[ Q(x_0) + 4\\sum_{k=1}^{n/2} Q(x_{2k-1}) + 2\\sum_{k=1}^{n/2-1} Q(x_{2k}) + Q(x_n) \\right] $$\n    This formula constructs the approximation by summing the values of the function $Q(p)$ at the partition points $x_k$, weighted according to their position. The endpoints ($x_0$ and $x_n$) have a weight of $1$. The interior points with odd indices ($x_1, x_3, \\ldots, x_{n-1}$) have a weight of $4$. The interior points with even indices ($x_2, x_4, \\ldots, x_{n-2}$) have a weight of $2$.\n\n5.  **Implementation for each Test Case**: This numerical integration procedure is applied to each of the four specified test cases.\n\n    -   **Test Case $1$**:\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$ with $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$.\n        -   Integration from $p_1 = 9$ to $p_0 = 12$ with $n = 100$ subintervals.\n        -   Since $Q(p)$ is a polynomial of degree $2$, which is less than $4$, Simpson's rule will provide the exact value of the integral.\n\n    -   **Test Case $2$**:\n        -   $Q(p) = A e^{-k p}$ with $A = 100000$, $k = 0.15$.\n        -   Integration from $p_1 = 8$ to $p_0 = 12$ with $n = 200$ subintervals.\n\n    -   **Test Case $3$**:\n        -   $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$ with $N = 150000$, $k = 0.5$, $\\bar{p} = 10$.\n        -   Integration from $p_1 = 10$ to $p_0 = 14$ with $n = 400$ subintervals.\n\n    -   **Test Case $4$**:\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$ with $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$.\n        -   Integration from $p_1 = 9.99$ to $p_0 = 10.00$ with $n = 10$ subintervals.\n        -   As in case $1$, the result will be analytically exact.\n\nThe final computed value for each case is rounded to $6$ decimal places to represent the consumer surplus in dollars per day.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer surplus problem for four different demand specifications\n    using a from-scratch implementation of the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_integrator(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of func from a to b by the\n        composite Simpson's rule, using n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n\n        h = (b - a) / n\n        x_points = np.linspace(a, b, n + 1)\n        y_points = func(x_points)\n\n        # Simpson's rule: (h/3) * [y0 + 4y1 + 2y2 + 4y3 + ... + 4y_{n-1} + yn]\n        # This is implemented by summing endpoints, odd interior points, and even interior points.\n        integral = (h / 3) * (\n            y_points[0] + \n            y_points[-1] + \n            4 * np.sum(y_points[1:-1:2]) + \n            2 * np.sum(y_points[2:-1:2])\n        )\n        \n        return integral\n\n    # Define the demand functions for each test case\n    def q_case1(p):\n        alpha, beta, gamma = 120000, 4000, 100\n        return alpha - beta * p - gamma * p**2\n\n    def q_case2(p):\n        A, k = 100000, 0.15\n        return A * np.exp(-k * p)\n\n    def q_case3(p):\n        N, k, p_bar = 150000, 0.5, 10\n        return N / (1 + np.exp(k * (p - p_bar)))\n\n    def q_case4(p):\n        alpha, beta, gamma = 80000, 5000, 50\n        return alpha - beta * p - gamma * p**2\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {'func': q_case1, 'p1': 9, 'p0': 12, 'n': 100},\n        {'func': q_case2, 'p1': 8, 'p0': 12, 'n': 200},\n        {'func': q_case3, 'p1': 10, 'p0': 14, 'n': 400},\n        {'func': q_case4, 'p1': 9.99, 'p0': 10.00, 'n': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # The integral for consumer surplus is from the new price (p1) to the old price (p0)\n        consumer_surplus = simpson_integrator(\n            case['func'], \n            case['p1'], \n            case['p0'], \n            case['n']\n        )\n        # Round the result to 6 decimal places and format as a string\n        results.append(f\"{consumer_surplus:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2430268"}, {"introduction": "Financial decisions, such as investing in education, often involve comparing cash flows over long horizons. When these cash flows are modeled continuously, their net present value ($NPV$) is found by integration. This exercise [@problem_id:2430272] challenges you to calculate the $NPV$ of an MBA, introducing the practical complication of a piecewise cash flow stream. You will learn the critical technique of splitting the integral at points of discontinuity, a necessary step for accurately handling realistic, multi-stage financial models.", "problem": "You are tasked with computing the net present value of the incremental earnings from enrolling in a Master of Business Administration (MBA) program, modeled as a continuous-time cash-flow problem. The net present value is defined as the present value integral of the difference between a post-MBA salary path and a counterfactual pre-MBA salary path, minus tuition payments during the program. All time is measured in years, and all currency values are in dollars. You must use the composite Simpson’s rule for numerical integration.\n\nLet the pre-MBA salary path be modeled as an exponentially growing function $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$, where $A$ is the initial salary at time $t=0$ and $g_{\\text{pre}}$ is the pre-MBA salary growth rate. The post-MBA salary path is piecewise: during the program of length $L$, earnings may be a constant amount $s_{\\text{prog}}$ per year; after graduation at time $t=L$, the salary starts at level $B$ and grows at rate $g_{\\text{post}}$ as $s_{\\text{post}}(t) = B \\exp(g_{\\text{post}}(t - L))$ for $t \\ge L$. Tuition is paid as a continuous outflow at constant rate $\\tau$ during the program period $[0,L)$ and is zero otherwise. The continuously compounded discount rate is $r \\ge 0$.\n\nDefine the incremental cash flow as\n$$\n\\Delta(t) = s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t),\n$$\nwhere\n$$\ns_{\\text{post}}(t) = \n\\begin{cases}\ns_{\\text{prog}}, & 0 \\le t < L,\\\\\nB \\exp\\!\\big(g_{\\text{post}}(t - L)\\big), & t \\ge L,\n\\end{cases}\n\\qquad\n\\text{tuition}(t) =\n\\begin{cases}\n\\tau, & 0 \\le t < L,\\\\\n0, & t \\ge L,\n\\end{cases}\n\\qquad\ns_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t).\n$$\nThe net present value over horizon $[0,T]$ is\n$$\n\\text{NPV} = \\int_{0}^{T} e^{- r t}\\, \\Delta(t)\\, dt.\n$$\n\nImplement a program that:\n- Approximates the integral using the composite Simpson’s rule with an even number of subintervals $n$ on each smooth subinterval. To handle the piecewise definition at the program boundary $t=L$, split the integral at $t=L$ and apply Simpson’s rule separately on $[0,L]$ and $[L,T]$ (ignoring any zero-length segment). Use a total baseline of $n_{\\text{total}}=4096$ subintervals, and allocate an even number of subintervals to each segment so that $n_1 + n_2 = n_{\\text{total}}$ with $n_1$ even for $[0,L]$ and $n_2$ even for $[L,T]$ (adjust as needed to ensure both are at least $2$ when their segment length is positive).\n- Computes the net present value for each of the following test cases, using dollars as the currency unit and years as the time unit. Express the final results in dollars, rounded to two decimals.\n\nTest suite (parameters given as $(A, g_{\\text{pre}}, L, B, g_{\\text{post}}, s_{\\text{prog}}, \\tau, r, T)$):\n- Case $1$ (general long horizon): (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40).\n- Case $2$ (boundary with zero program length $L=0$): (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35).\n- Case $3$ (zero discount rate $r=0$): (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30).\n- Case $4$ (horizon equals program length $T=L$): (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2).\n\nOutput requirements:\n- Your program should produce a single line of output containing the four net present values in order of the cases above, as a comma-separated list enclosed in square brackets, for example, $[\\text{npv}_1,\\text{npv}_2,\\text{npv}_3,\\text{npv}_4]$.\n- Each value must be in dollars, rounded to two decimals.\n\nAngle units do not apply. All exponential functions use the natural exponential. All rates $g_{\\text{pre}}$, $g_{\\text{post}}$, and $r$ are per year (continuous compounding). Ensure scientific realism and numerical stability by adhering to the splitting strategy at $t=L$ and using an even number of subintervals on each segment.", "solution": "The problem presented is a valid exercise in computational finance. It is scientifically grounded in the principles of net present value analysis, well-posed with all necessary parameters and a clear objective, and its components are mathematically and economically sound. We shall proceed with the derivation of the solution.\n\nThe objective is to compute the Net Present Value (${\\text{NPV}}$) of the incremental cash flow resulting from an investment in an MBA program over a time horizon $[0, T]$. This requires the numerical evaluation of a definite integral using the composite Simpson's rule.\n\nThe incremental cash flow at time $t$, denoted $\\Delta(t)$, is the difference between the post-MBA salary, the pre-MBA salary, and tuition costs. The functions are defined as:\n- Pre-MBA Salary: $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$\n- Post-MBA Salary: $s_{\\text{post}}(t) = \\begin{cases} s_{\\text{prog}}, & 0 \\le t < L \\\\ B \\exp(g_{\\text{post}}(t-L)), & t \\ge L \\end{cases}$\n- Tuition: $\\text{tuition}(t) = \\begin{cases} \\tau, & 0 \\le t < L \\\\ 0, & t \\ge L \\end{cases}$\n\nThe Net Present Value is the integral of the discounted incremental cash flow over the horizon $[0, T]$:\n$$\n\\text{NPV} = \\int_{0}^{T} e^{-rt} \\Delta(t) \\,dt = \\int_{0}^{T} e^{-rt} [s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t)] \\,dt\n$$\nwhere $r$ is the continuously compounded discount rate.\n\nDue to the piecewise definition of $s_{\\text{post}}(t)$ and $\\text{tuition}(t)$, the integrand is discontinuous at the point $t=L$, which marks the end of the MBA program. A rigorous evaluation of the integral requires splitting it at this point of discontinuity:\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} \\Delta(t) \\,dt + \\int_{L}^{T} e^{-rt} \\Delta(t) \\,dt\n$$\nSubstituting the appropriate definitions for each interval yields two separate integrals:\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} (s_{\\text{prog}} - \\tau - A e^{g_{\\text{pre}}t}) \\,dt + \\int_{L}^{T} e^{-rt} (B e^{g_{\\text{post}}(t-L)} - A e^{g_{\\text{pre}}t}) \\,dt\n$$\nWe denote the first integral as $\\text{NPV}_1$ and the second as $\\text{NPV}_2$. $\\text{NPV} = \\text{NPV}_1 + \\text{NPV}_2$. These integrals are to be approximated numerically.\n\nThe specified numerical method is the composite Simpson's rule. For an integral $\\int_a^b f(x) \\,dx$ over an interval divided into an even number of subintervals $n$, the approximation is given by:\n$$\n\\int_a^b f(x) \\,dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right]\n$$\nwhere $h = (b-a)/n$ is the step size and $x_i = a+ih$ are the evaluation points. This rule requires $n$ to be an even integer, $n \\ge 2$.\n\nThe problem mandates that a total of $n_{\\text{total}} = 4096$ subintervals be used, distributed between the two integration segments $[0, L]$ and $[L, T]$. Let $n_1$ be the number of subintervals for the first integral and $n_2$ for the second, such that $n_1 + n_2 = n_{\\text{total}}$. Both $n_1$ and $n_2$ must be even. A logical and systematic approach is to allocate these subintervals proportionally to the length of each integration segment.\n\nThe allocation algorithm for $n_1$ and $n_2$ is as follows:\n$1$. Handle boundary cases:\n    - If $L \\le 0$, the first integral over $[0, L]$ is zero. We set $n_1 = 0$ and $n_2 = n_{\\text{total}}$. The integration is performed only over $[0, T]$.\n    - If $T \\le L$, the second integral over $[L, T]$ is zero. We set $n_1 = n_{\\text{total}}$ and $n_2 = 0$. The integration is performed only over $[0, L]$.\n$2$. For the general case $0 < L < T$:\n    - Calculate the proportional allocation for the first interval: $n_{1, \\text{prop}} = n_{\\text{total}} \\times \\frac{L}{T}$.\n    - Round this value to the nearest even integer. A robust method is $n_1 = 2 \\times \\text{round}(n_{1, \\text{prop}}/2)$.\n    - Apply safeguards to ensure $n_1$ and $n_2$ are at least $2$ (if their corresponding interval lengths are positive). If the calculation yields $n_1 < 2$, we set $n_1=2$. If it yields $n_1 > n_{\\text{total}}-2$, we set $n_1 = n_{\\text{total}}-2$.\n    - The allocation for the second interval is then $n_2 = n_{\\text{total}} - n_1$. By construction, if $n_{\\text{total}}$ and $n_1$ are even, $n_2$ will also be even.\n\nThe implementation will consist of a function that executes Simpson's rule and a main procedure that iterates through the provided test cases. For each case, it will:\n- Define the two integrand functions based on the specific parameters.\n- Determine the subinterval counts $n_1$ and $n_2$ according to the allocation algorithm.\n- Call the Simpson's rule function for each of the two integrals (if the interval length is positive).\n- Sum the results to obtain the total $\\text{NPV}$.\n- Round the final value to two decimal places as required.\n\nThis structured approach ensures that the piecewise nature of the economic model is correctly handled by the numerical integration, providing a scientifically sound and computationally robust solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present value of enrolling in an MBA program \n    for a series of test cases using the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_rule(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of a function from a to b\n        using the composite Simpson's rule with n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even and positive).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n == 0 or a == b:\n            return 0.0\n        \n        if n  2 or n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be a positive even integer.\")\n\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x)\n\n        # Simpson's rule formula\n        # S = y[0] + y[-1] + 4 * sum(odd indices) + 2 * sum(even indices)\n        integral = h / 3.0 * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-1:2]))\n        \n        return integral\n\n    # Define the test cases from the problem statement.\n    # Parameters: (A, g_pre, L, B, g_post, s_prog, tau, r, T)\n    test_cases = [\n        (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40),\n        (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35),\n        (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30),\n        (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2),\n    ]\n\n    results = []\n    n_total = 4096\n\n    for case in test_cases:\n        A, g_pre, L, B, g_post, s_prog, tau, r, T = case\n\n        # Define the two integrands corresponding to the two time periods\n        \n        # Integrand for the period during the MBA program: [0, L]\n        # Delta(t) = s_prog - s_pre(t) - tuition(t)\n        integrand1 = lambda t: np.exp(-r * t) * (s_prog - tau - A * np.exp(g_pre * t))\n\n        # Integrand for the period after graduation: [L, T]\n        # Delta(t) = s_post(t) - s_pre(t)\n        integrand2 = lambda t: np.exp(-r * t) * (B * np.exp(g_post * (t - L)) - A * np.exp(g_pre * t))\n\n        # Allocate subintervals n1 and n2\n        n1, n2 = 0, 0\n        if L = 0:\n            # First interval has zero or negative length\n            n1 = 0\n            n2 = n_total\n            # Adjust integration range for the second part\n            L_eff = 0\n            T_eff = T\n        elif T = L:\n            # Second interval has zero or negative length\n            n1 = n_total\n            n2 = 0\n            L_eff = L\n            T_eff = L\n        else: # 0  L  T\n            # Proportional allocation\n            n1_prop = n_total * L / T\n            # Round to nearest even integer\n            n1 = int(round(n1_prop / 2.0) * 2)\n            \n            # Safeguard to ensure n1 and n2 are at least 2\n            if n1  2:\n                n1 = 2\n            if n_total - n1  2:\n                n1 = n_total - 2\n            \n            n2 = n_total - n1\n            L_eff = L\n            T_eff = T\n\n        # Calculate NPV for the first period [0, L]\n        npv1 = 0.0\n        if n1 > 0:\n            npv1 = simpson_rule(integrand1, 0, L_eff, n1)\n\n        # Calculate NPV for the second period [L, T]\n        # For L=0 case, this integral is over [0,T]\n        npv2 = 0.0\n        if n2 > 0:\n            npv2 = simpson_rule(integrand2, L_eff, T_eff, n2)\n\n        # Total NPV is the sum of the two parts\n        total_npv = npv1 + npv2\n        results.append(total_npv)\n\n    # Final print statement in the exact required format.\n    # Round to two decimal places for currency representation.\n    print(f\"[{','.join([f'{res:.2f}' for res in results])}]\")\n\nsolve()\n```", "id": "2430272"}, {"introduction": "While Simpson's rule offers a powerful way to approximate integrals, in fields like corporate finance, precision is paramount. This advanced practice [@problem_id:2430246] introduces Richardson extrapolation, a technique to significantly improve the accuracy of your numerical estimates. By combining two Simpson's rule approximations with different step sizes, you will learn how to cancel out the leading error term and achieve a higher-order result, applying this powerful numerical method to the sophisticated task of firm valuation.", "problem": "You are given a continuous-time discounted cash flow model for a firm’s enterprise value. The present value at time $0$ of a cash flow stream with instantaneous cash flow $C(t)$ and continuously compounded discount rate $r(t)$ is defined as the improper integral $$\\mathrm{EV} \\;=\\; \\int_{0}^{\\infty} C(t)\\,\\exp\\!\\left(-\\int_{0}^{t} r(s)\\,ds\\right)\\,dt.$$ In this task, assume the following structure holds:\n- For $t \\in [0,\\tau]$, the discount rate is constant $r(t)=r_{1}$ and the integrand is $f(t)=C(t)\\,\\exp(-r_{1}t)$.\n- For $t \\ge \\tau$, the cash flow grows at a constant rate $g_{\\infty}$ and the discount rate is constant $r_{\\infty}$, with $r_{\\infty}  g_{\\infty}$. The present value of the tail after time $\\tau$ is then well-defined and finite.\n\nYour goal is to compute a refined numerical estimate of the enterprise value by:\n1. Approximating the integral $\\int_{0}^{\\tau} f(t)\\,dt$ using the composite Simpson method on an evenly spaced grid with $N$ subintervals (with $N$ even), and on a refined grid with $2N$ subintervals.\n2. Applying Richardson extrapolation to the two Simpson approximations to cancel the leading-order truncation error and obtain a refined estimate for $\\int_{0}^{\\tau} f(t)\\,dt$.\n3. Adding an analytically computed terminal value at time $\\tau$ that captures the contributions from $t \\ge \\tau$ under the constant-growth and constant-discount assumptions. If $C(\\tau)$ denotes the cash flow level at time $\\tau$ for the pre-$\\tau$ model, and $r(t)=r_{1}$ for $t \\in [0,\\tau]$, then the present value at $t=0$ of the tail is given by $$\\mathrm{TV} \\;=\\; \\exp(-r_{1}\\tau)\\,\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}}.$$\n4. Reporting the total estimate $\\widehat{\\mathrm{EV}} = \\widehat{\\int_{0}^{\\tau} f(t)\\,dt} + \\mathrm{TV}$.\n\nImplement a complete, runnable program that follows the above steps for each test case below. Angles for any trigonometric functions must be in radians. All outputs must be expressed in the same currency units as $C(t)$, without any currency symbol, as decimal floating-point numbers rounded to $10$ decimal places.\n\nThe test suite consists of four cases. In each case, the cash flow for $t \\in [0,\\tau]$ is specified by\n$$C(t) \\;=\\; A\\,\\exp(g_{1} t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr),$$\nwith the understanding that parameters may be zeroed for simpler subcases. For $t \\ge \\tau$, use the terminal value with constant $r_{\\infty}$ and $g_{\\infty}$ as specified.\n\nUse the following parameter sets, one per test case:\n- Case 1 (closed-form validation via $\\tau=0$): $A=50$, $g_{1}=0.02$, $\\alpha=0$, $\\omega=0$, $\\beta=0$, $r_{1}=0.07$, $\\tau=0$, $r_{\\infty}=0.07$, $g_{\\infty}=0.02$, $N=64$. The exact value implied by the model is $A/(r_{\\infty}-g_{\\infty})$.\n- Case 2 (cyclical early phase, stable long run): $A=120$, $g_{1}=0.015$, $\\alpha=0.1$, $\\omega=0.8$, $\\beta=0$, $r_{1}=0.09$, $\\tau=8$, $r_{\\infty}=0.08$, $g_{\\infty}=0.02$, $N=128$.\n- Case 3 (near-boundary long-run gap): $A=80$, $g_{1}=0.03$, $\\alpha=0$, $\\omega=0$, $\\beta=0.05$, $r_{1}=0.05$, $\\tau=6$, $r_{\\infty}=0.04$, $g_{\\infty}=0.039$, $N=256$.\n- Case 4 (high discount early, modest long run): $A=200$, $g_{1}=0$, $\\alpha=0$, $\\omega=0$, $\\beta=0.02$, $r_{1}=0.15$, $\\tau=4$, $r_{\\infty}=0.10$, $g_{\\infty}=0.01$, $N=128$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. The list must be in the order of the cases above. Each number must be rounded to exactly $10$ decimal places. For example: $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}]$.", "solution": "The problem requires the computation of a firm's enterprise value, $\\mathrm{EV}$, based on a continuous-time discounted cash flow model. The valuation is performed using a two-stage approach: a finite projection period from time $t=0$ to $t=\\tau$, and a terminal value representing all cash flows thereafter.\n\nThe enterprise value is formally defined by the integral:\n$$ \\mathrm{EV} \\;=\\; \\int_{0}^{\\infty} C(t)\\,\\exp\\!\\left(-\\int_{0}^{t} r(s)\\,ds\\right)\\,dt $$\nwhere $C(t)$ is the instantaneous cash flow at time $t$ and $r(t)$ is the continuously compounded discount rate.\n\nFor the initial period $t \\in [0, \\tau]$, the discount rate is a constant $r(t)=r_{1}$. The cash flow function is given by:\n$$ C(t) \\;=\\; A\\,\\exp(g_{1} t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr) $$\nThe value contribution from this period is the integral of the discounted cash flow, which we denote by $I_{\\tau}$:\n$$ I_{\\tau} = \\int_{0}^{\\tau} C(t) e^{-r_{1}t} dt = \\int_{0}^{\\tau} A\\,\\exp((g_{1}-r_{1})t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr) dt $$\nThis integral does not, in general, have a simple closed-form solution and must be approximated numerically.\n\nFor the period $t \\ge \\tau$, the cash flow is assumed to grow from its level at time $\\tau$ at a constant rate $g_{\\infty}$, and the discount rate is a constant $r_{\\infty}$, with the stability condition $r_{\\infty}  g_{\\infty}$. The value of these perpetual cash flows at time $\\tau$ is given by the Gordon growth model, $\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}}$. To find its present value at $t=0$, we discount this amount back by the factor $\\exp(-r_{1}\\tau)$. Thus, the terminal value, $\\mathrm{TV}$, is:\n$$ \\mathrm{TV} \\;=\\; \\exp(-r_{1}\\tau)\\,\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}} $$\nThe total enterprise value is the sum of these two components: $\\mathrm{EV} = I_{\\tau} + \\mathrm{TV}$.\n\nThe numerical task is to obtain a high-precision estimate of $I_{\\tau}$. The specified methodology involves the composite Simpson's rule and Richardson extrapolation.\n\nThe composite Simpson's rule approximates an integral $\\int_{a}^{b} f(x)\\,dx$ using an even number of subintervals, $n$, of width $h = (b-a)/n$. The formula is:\n$$ S_{n} = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right] $$\nwhere $x_i = a+ih$. The local truncation error of this method is of order $O(h^4)$. The total error can be expressed as an asymptotic series in powers of $h$:\n$$ I_{\\tau} - S_{n} = K_{1}h^4 + K_{2}h^6 + \\dots $$\nwhere $h = \\tau/n$.\n\nRichardson extrapolation is a technique to improve the accuracy of a numerical estimate by canceling the leading error term. We compute the integral approximation with two different numbers of subintervals, $N$ and $2N$, which correspond to step sizes $h = \\tau/N$ and $h/2$, respectively. Let these approximations be $S_{N}$ and $S_{2N}$. We have:\n$$ I_{\\tau} = S_{N} + K_{1}h^4 + O(h^6) $$\n$$ I_{\\tau} = S_{2N} + K_{1}(h/2)^4 + O(h^6) = S_{2N} + \\frac{1}{16}K_{1}h^4 + O(h^6) $$\nThis system of two equations can be solved for $I_{\\tau}$ by eliminating the $K_{1}h^4$ term. Multiplying the second equation by $16$ and subtracting the first yields:\n$$ 15 I_{\\tau} = 16 S_{2N} - S_{N} + O(h^6) $$\nThe extrapolated estimate, $\\widehat{I_{\\tau}}$, is therefore:\n$$ \\widehat{I_{\\tau}} = \\frac{16S_{2N} - S_{N}}{15} = S_{2N} + \\frac{S_{2N} - S_{N}}{15} $$\nThis refined estimate has a truncation error of order $O(h^6)$, providing a significant improvement in accuracy over the original Simpson's rule approximations.\n\nThe overall algorithm for each test case is as follows:\n1.  Define the integrand $f(t) = C(t) e^{-r_{1}t}$.\n2.  For a given number of subintervals $N$, compute two Simpson's rule approximations: $S_{N}$ for $N$ subintervals and $S_{2N}$ for $2N$ subintervals over the interval $[0, \\tau]$. If $\\tau=0$, the integral $I_{\\tau}$ is exactly $0$.\n3.  Apply Richardson extrapolation to obtain the refined integral estimate $\\widehat{I_{\\tau}} = (16S_{2N} - S_{N})/15$.\n4.  Analytically compute the terminal value $\\mathrm{TV}$ using the formula provided.\n5.  Sum the two components to find the total estimated enterprise value: $\\widehat{\\mathrm{EV}} = \\widehat{I_{\\tau}} + \\mathrm{TV}$.\n\nThis procedure is applied to each of the four parameter sets. For Case $1$, where $\\tau=0$, the integral part $I_{\\tau}$ is trivially zero, and the enterprise value is given solely by the terminal value, $\\mathrm{EV} = \\mathrm{TV} = A/(r_{\\infty}-g_{\\infty})$, which serves as a validation of the terminal value calculation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the enterprise value for four test cases using a two-stage DCF model.\n    The integral part is calculated using Simpson's rule with Richardson extrapolation.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Closed-form validation via tau=0\n        dict(A=50, g1=0.02, alpha=0, omega=0, beta=0, r1=0.07, tau=0, r_inf=0.07, g_inf=0.02, N=64),\n        # Case 2: Cyclical early phase, stable long run\n        dict(A=120, g1=0.015, alpha=0.1, omega=0.8, beta=0, r1=0.09, tau=8, r_inf=0.08, g_inf=0.02, N=128),\n        # Case 3: Near-boundary long-run gap\n        dict(A=80, g1=0.03, alpha=0, omega=0, beta=0.05, r1=0.05, tau=6, r_inf=0.04, g_inf=0.039, N=256),\n        # Case 4: High discount early, modest long run\n        dict(A=200, g1=0, alpha=0, omega=0, beta=0.02, r1=0.15, tau=4, r_inf=0.10, g_inf=0.01, N=128),\n    ]\n\n    results = []\n\n    def integrand(t, A, g1, alpha, omega, beta, r1):\n        \"\"\"\n        Calculates the discounted cash flow f(t) = C(t) * exp(-r1*t) for t in [0, tau].\n        \"\"\"\n        # C(t) = A * exp(g1*t) * (1 + alpha*sin(omega*t) + beta*t)\n        # f(t) = C(t) * exp(-r1*t) = A * exp((g1-r1)*t) * (1 + alpha*sin(omega*t) + beta*t)\n        return A * np.exp((g1 - r1) * t) * (1 + alpha * np.sin(omega * t) + beta * t)\n\n    def simpson_rule(func, a, b, n, params):\n        \"\"\"\n        Composite Simpson's rule for numerical integration.\n        n must be an even integer.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n        if a == b:\n            return 0.0\n            \n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x, **params)\n        \n        integral = y[0] + y[-1]\n        integral += 4 * np.sum(y[1:-1:2]) # Odd indices\n        integral += 2 * np.sum(y[2:-1:2]) # Even indices\n        \n        return (h / 3) * integral\n\n    for case in test_cases:\n        p = case.copy() # Use a copy to avoid modifying the original dict\n        # Pop non-integrand parameters\n        tau = p.pop('tau')\n        r_inf = p.pop('r_inf')\n        g_inf = p.pop('g_inf')\n        N = p.pop('N')\n\n        # --- Step 1  2: Integral with Richardson Extrapolation ---\n        if tau == 0:\n            integral_estimate = 0.0\n        else:\n            # Simpson approximation with N subintervals\n            S_N = simpson_rule(integrand, 0, tau, N, p)\n            \n            # Simpson approximation with 2N subintervals\n            S_2N = simpson_rule(integrand, 0, tau, 2 * N, p)\n            \n            # Richardson extrapolation for O(h^4) method\n            integral_estimate = S_2N + (S_2N - S_N) / 15.0\n\n        # --- Step 3: Terminal Value ---\n        # Get full parameters back for C(tau) calculation\n        params_full = case\n        C_tau = params_full['A'] * np.exp(params_full['g1'] * tau) * \\\n                (1 + params_full['alpha'] * np.sin(params_full['omega'] * tau) + params_full['beta'] * tau)\n\n        TV = np.exp(-params_full['r1'] * tau) * C_tau / (r_inf - g_inf)\n\n        # --- Step 4: Total Enterprise Value ---\n        total_ev = integral_estimate + TV\n        results.append(f\"{total_ev:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2430246"}]}