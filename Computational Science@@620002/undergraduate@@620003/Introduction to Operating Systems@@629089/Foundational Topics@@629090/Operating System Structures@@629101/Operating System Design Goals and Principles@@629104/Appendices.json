{"hands_on_practices": [{"introduction": "As multi-core processors have become ubiquitous, ensuring an operating system's scheduler scales efficiently is a paramount design goal. This practice explores a fundamental trade-off: the simplicity of a single, global run queue versus the scalability of per-core queues. You will model the contention overhead in the global design and the load-balancing overhead in the per-core design to discover the crossover point where one approach becomes superior, providing a quantitative basis for a critical architectural decision in modern operating systems [@problem_id:3664851].", "problem": "An Operating System (OS) designer is evaluating two scheduler run-queue designs on a symmetric multiprocessor with $n$ identical cores under a saturated workload (the ready queue is never empty). Each job has a deterministic execution time of $s$ seconds. The designer’s goal is to reason from first principles about the scalability of queueing overheads as functions of $n$ and to determine when a per-core design dominates a global-queue design in terms of expected scheduler-induced latency per job.\n\nDesign A (global run queue): A single First-In First-Out (FIFO) run queue is protected by a lock. Each dequeue operation enters a critical section of fixed duration $c$ seconds. Under saturation, each core repeatedly acquires the lock, dequeues one job, executes it for $s$ seconds, and repeats. Model the lock as a single-server queue with Markovian arrivals and Markovian service times (M/M/1), where the service rate is $1/c$ and the arrival rate equals the aggregate rate of dequeue attempts. Assume stability is maintained only when the arrival rate is strictly less than the service rate.\n\nDesign B (per-core run queues): Each core has its own private run queue with local enqueue/dequeue cost $c_{\\ell}$ per job and no lock contention in the common case. Occasional load balancing occurs via work stealing: with probability $p(n)$ per job, a core performs a stealing attempt that costs $d$ seconds. For the purpose of this model, assume $p(n) = \\kappa / n$ with a constant $\\kappa \\in (0,1)$, reflecting that, under saturation, the fraction of jobs requiring cross-core movement decreases with $n$.\n\nFor both designs, define the scheduler-induced overhead per job as the expected time spent in queueing and scheduling activities excluding the job’s own execution time $s$. Using the M/M/1 stability condition and expected time-in-system for Design A’s lock, and the given per-job local and stealing costs for Design B, derive the overhead functions of $n$ for each design. Then, for the parameter values\n- $s = 5.0 \\times 10^{-4}\\,\\mathrm{s}$,\n- $c = 2.0 \\times 10^{-6}\\,\\mathrm{s}$,\n- $c_{\\ell} = 2.0 \\times 10^{-7}\\,\\mathrm{s}$,\n- $d = 1.5 \\times 10^{-5}\\,\\mathrm{s}$,\n- $\\kappa = 0.8$,\ndetermine the smallest integer $n \\geq 1$ for which the per-core design’s expected scheduler-induced overhead per job is less than or equal to the global-queue design’s expected scheduler-induced overhead per job. If the lock in Design A would be unstable for that $n$, report the smallest $n$ that meets both the dominance and stability conditions. Provide your final answer as a single integer (number of cores). No rounding instruction is needed because an integer is required. Express any intermediate quantities in seconds using $\\mathrm{s}$.", "solution": "This problem requires deriving and comparing the scheduler-induced overhead per job for two different run-queue designs as a function of the number of cores, $n$.\n\n### Design A: Global Run Queue Overhead, $O_A(n)$\nThe scheduler-induced overhead per job, $O_A(n)$, is the total time a core spends waiting for and acquiring the lock to dequeue a job. We model the lock as an M/M/1 queue.\n\nThe service rate of the lock server is $\\mu = 1/c$.\n\nThe arrival rate, $\\lambda$, is the aggregate rate of dequeue attempts from all $n$ cores. In a saturated system, each core attempts to get a new job as soon as it finishes the previous one. The time to complete one job cycle (execution plus scheduling) is dominated by the job's execution time $s$. A standard approximation for the aggregate arrival rate to the lock queue is therefore $\\lambda \\approx n/s$.\n\nThe M/M/1 queue is stable only if the arrival rate is strictly less than the service rate:\n$$ \\frac{n}{s} < \\frac{1}{c} \\implies n < \\frac{s}{c} $$\nFor a stable system, the expected time in the queueing system (waiting time + service time), which corresponds to the overhead, is given by:\n$$ O_A(n) = \\frac{1}{\\mu - \\lambda} $$\nSubstituting the expressions for $\\mu$ and $\\lambda$:\n$$ O_A(n) = \\frac{1}{\\frac{1}{c} - \\frac{n}{s}} = \\frac{cs}{s - cn} $$\nThis expression for overhead is valid only for $n$ satisfying the stability condition.\n\n### Design B: Per-Core Run Queue Overhead, $O_B(n)$\nThe overhead for the per-core design consists of a constant local cost and a probabilistic work-stealing cost.\n1.  The local enqueue/dequeue cost is $c_{\\ell}$, incurred for every job.\n2.  A work-stealing attempt, costing $d$, occurs with probability $p(n) = \\kappa/n$ for each job.\n\nThe expected overhead per job is the sum of the local cost and the expected work-stealing cost:\n$$ O_B(n) = c_{\\ell} + p(n) \\cdot d $$\nSubstituting the expression for $p(n)$:\n$$ O_B(n) = c_{\\ell} + \\frac{\\kappa d}{n} $$\n\n### Comparison and Calculation\nWe need to find the smallest integer $n \\ge 1$ such that $O_B(n) \\le O_A(n)$, while also ensuring that Design A is stable for that $n$.\n\nFirst, we determine the stability limit for Design A using the given parameters:\n-   $s = 5.0 \\times 10^{-4}\\,\\mathrm{s}$\n-   $c = 2.0 \\times 10^{-6}\\,\\mathrm{s}$\nThe stability condition is $n  s/c$:\n$$ n  \\frac{5.0 \\times 10^{-4}}{2.0 \\times 10^{-6}} = 250 $$\nThus, our search for $n$ is confined to the range $[1, 249]$.\n\nNow, we set up the inequality $O_B(n) \\leq O_A(n)$:\n$$ c_{\\ell} + \\frac{\\kappa d}{n} \\le \\frac{cs}{s - cn} $$\nSubstitute the given parameter values:\n-   $c_{\\ell} = 2.0 \\times 10^{-7}\\,\\mathrm{s}$\n-   $d = 1.5 \\times 10^{-5}\\,\\mathrm{s}$\n-   $\\kappa = 0.8$\n$$ 2.0 \\times 10^{-7} + \\frac{0.8 \\cdot (1.5 \\times 10^{-5})}{n} \\le \\frac{(2.0 \\times 10^{-6})(5.0 \\times 10^{-4})}{5.0 \\times 10^{-4} - (2.0 \\times 10^{-6})n} $$\n$$ 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{n} \\le \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - (2.0 \\times 10^{-6})n} $$\nThis inequality is complex to solve analytically. We can find the smallest integer $n$ by testing values. We observe that for small $n$, $O_A(n)$ increases slowly, while $O_B(n)$ is large due to the $1/n$ term and decreases as $n$ increases.\n\nLet's evaluate both functions for small integer values of $n$:\n\nFor $n=6$:\n$$ O_A(6) = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 6 \\cdot (2.0 \\times 10^{-6})} = \\frac{1.0 \\times 10^{-9}}{4.88 \\times 10^{-4}} \\approx 2.049 \\times 10^{-6}\\,\\mathrm{s} $$\n$$ O_B(6) = 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{6} = 2.0 \\times 10^{-7} + 2.0 \\times 10^{-6} = 2.2 \\times 10^{-6}\\,\\mathrm{s} $$\nAt $n=6$, we have $O_B(6) > O_A(6)$. The condition is not met.\n\nFor $n=7$:\n$$ O_A(7) = \\frac{1.0 \\times 10^{-9}}{5.0 \\times 10^{-4} - 7 \\cdot (2.0 \\times 10^{-6})} = \\frac{1.0 \\times 10^{-9}}{4.86 \\times 10^{-4}} \\approx 2.058 \\times 10^{-6}\\,\\mathrm{s} $$\n$$ O_B(7) = 2.0 \\times 10^{-7} + \\frac{1.2 \\times 10^{-5}}{7} \\approx 2.0 \\times 10^{-7} + 1.714 \\times 10^{-6} = 1.914 \\times 10^{-6}\\,\\mathrm{s} $$\nAt $n=7$, we have $O_B(7) \\approx 1.914 \\times 10^{-6}\\,\\mathrm{s}$ and $O_A(7) \\approx 2.058 \\times 10^{-6}\\,\\mathrm{s}$. Thus, $O_B(7)  O_A(7)$.\n\nSince the condition is not met for $n=6$ but is met for $n=7$, the smallest integer for which the per-core design's overhead is less than or equal to the global-queue design's overhead is $n=7$. The stability condition for Design A ($7  250$) is satisfied. Therefore, the smallest integer $n$ is 7.", "answer": "$$\n\\boxed{7}\n$$", "id": "3664851"}, {"introduction": "A key goal of an operating system is to maximize resource utilization, but pushing a system too far can lead to catastrophic performance collapse. This exercise examines thrashing, a state where the system spends more time servicing page faults than executing useful work. By applying the working set model to a multiprogrammed system, you will quantify memory pressure and determine the minimal corrective action to restore stability, illustrating the vital OS principle of load control [@problem_id:3664899].", "problem": "A multiprogrammed system with Random Access Memory (RAM) of size $R$ is running $n$ processes. Under the working set model, each process $i$ has a working set $W_i(\\Delta)$ within a window of the most recent $ \\Delta $ memory references; the size of this set is $|W_i|$, measured in pages or an equivalent memory unit. Thrashing is the operating condition in which the system spends a disproportionately large fraction of time handling page faults rather than executing useful work; in practical terms, this is observed when the aggregate resident memory demanded by the active working sets cannot be satisfied by the available physical memory.\n\nStarting from these principles, derive a threshold condition, expressed as an inequality involving $R$ and $\\{|W_i|\\}_{i=1}^{n}$, that marks the onset of thrashing under the working set model in steady state, assuming that each page in a working set must be resident to maintain a low page fault frequency. Then apply this condition to the following concrete scenario and determine a minimal corrective action consistent with common operating system design goals, such as maintaining throughput while preventing thrashing:\n\n- Physical RAM: $R = 16$ GiB.\n- Number of processes: $n = 7$.\n- Working set sizes in GiB: $|W_1| = 2.5$, $|W_2| = 3.0$, $|W_3| = 4.5$, $|W_4| = 1.0$, $|W_5| = 5.5$, $|W_6| = 2.0$, $|W_7| = 1.5$.\n- The operating system employs a safety headroom policy: to reduce the risk of thrashing and to accommodate short-term fluctuations, it aims to keep a free-memory headroom fraction $\\beta$ of RAM, where $\\beta = 0.2$. That is, it targets an aggregate active working set no larger than $(1 - \\beta) R$.\n\nTasks:\n1. Using only the definitions above, derive the symbolic threshold inequality that delineates the onset of thrashing in terms of $R$ and $\\{|W_i|\\}$.\n2. For the given $R$ and $\\{|W_i|\\}$, compute the total working set demand and determine whether the system is thrashing.\n3. If the system is thrashing, determine the minimal number of processes that the operating system must suspend (choose processes to suspend so as to minimize the count) so that the sum of the remaining active working set sizes does not exceed the safety target $(1 - \\beta) R$. Break ties by suspending processes with the largest $|W_i|$ values first, consistent with minimizing the number of suspensions for a given reduction.\n4. Report only the minimal number of processes to suspend as your final answer. Do not include units. No rounding instruction is necessary for this integer result. Express intermediate memory quantities in GiB as needed, but the final answer must be a pure number.", "solution": "### 1. Derivation of the Symbolic Threshold Inequality\nThe working set model states that for a process to run efficiently (i.e., avoid frequent page faults), its working set must be resident in physical memory. Thrashing occurs when the total memory demanded by the working sets of all active processes exceeds the available physical memory.\n\nLet $R$ be the total size of RAM and $|W_i|$ be the working set size for process $i$. The total memory demand from $n$ processes is:\n$$ D_{total} = \\sum_{i=1}^{n} |W_i| $$\nThe simple threshold for thrashing is $D_{total} > R$.\n\nThe problem specifies a more stringent OS policy that maintains a safety headroom fraction $\\beta$ of RAM. The available memory for allocation is therefore $(1-\\beta)R$. Under this policy, the system is considered to be in a thrashing state if the total demand exceeds this target capacity. The governing inequality is:\n$$ \\sum_{i=1}^{n} |W_i|  (1 - \\beta)R $$\n\n### 2. System State Analysis\nWe apply the derived inequality to the given scenario:\n-   $R = 16$ GiB\n-   $\\beta = 0.2$\n-   Working set sizes: $\\{2.5, 3.0, 4.5, 1.0, 5.5, 2.0, 1.5\\}$ GiB.\n\nFirst, calculate the total working set demand, $D_{total}$:\n$$ D_{total} = 2.5 + 3.0 + 4.5 + 1.0 + 5.5 + 2.0 + 1.5 = 20.0 \\text{ GiB} $$\nNext, calculate the target memory capacity, $R_{target}$, according to the safety policy:\n$$ R_{target} = (1 - \\beta)R = (1 - 0.2) \\times 16 = 0.8 \\times 16 = 12.8 \\text{ GiB} $$\nWe check if the thrashing condition is met:\n$$ D_{total} > R_{target} \\implies 20.0 \\text{ GiB} > 12.8 \\text{ GiB} $$\nThe inequality is true, so the system is thrashing according to its policy and must take corrective action.\n\n### 3. Determination of Minimal Corrective Action\nThe OS must suspend processes to reduce the total working set demand to at most $R_{target}$. The required reduction in memory demand, $\\Delta D_{req}$, is:\n$$ \\Delta D_{req} = D_{total} - R_{target} = 20.0 - 12.8 = 7.2 \\text{ GiB} $$\nTo minimize the number of suspended processes, we should suspend processes with the largest working sets first. We sort the working set sizes in descending order:\n$$ \\{5.5, 4.5, 3.0, 2.5, 2.0, 1.5, 1.0\\} $$\nNow, we sum the sizes of the largest working sets until the total freed memory meets or exceeds the required reduction of $7.2$ GiB.\n\n-   **Suspend 1 process:** Freeing the largest working set ($5.5$ GiB) is insufficient ($5.5  7.2$).\n\n-   **Suspend 2 processes:** Freeing the two largest working sets ($5.5$ GiB + $4.5$ GiB) gives a total reduction of $10.0$ GiB. This is sufficient ($10.0 \\ge 7.2$).\n\nBy suspending the two processes with the largest working sets, the new total demand becomes $20.0 - 10.0 = 10.0$ GiB, which is below the target of $12.8$ GiB. Therefore, the minimal number of processes to suspend is 2.", "answer": "$$\n\\boxed{2}\n$$", "id": "3664899"}, {"introduction": "The principle of isolation is a cornerstone of reliable and secure operating systems, ensuring that processes cannot interfere with the kernel or each other. This practice provides a concrete model of how this principle is enforced through system call filtering, a mechanism that acts as a reference monitor at the kernel boundary. By simulating a process workload against a security policy, you will directly observe how the principles of least privilege and fail-stop containment work to confine potentially misbehaving code [@problem_id:3664897].", "problem": "Design and implement a self-contained program that models the isolation principle in an operating system through an abstract, deterministic reference monitor that enforces an allowlist of system calls. The model is intended to capture the design goal of isolation via complete mediation and least privilege, similar in spirit to a system call filtering mechanism. The program must not rely on any operating system interfaces; instead, it must simulate the policy and its effects on a workload trace.\n\nBase your reasoning on the following fundamental definitions, which are to be treated as the only permitted starting point for derivation:\n\n- A system call is the sole controlled interface to kernel privileges; a reference monitor mediates each system call (complete mediation) and enforces a safety policy by either allowing or blocking the attempted system call.\n- Under a fail-stop policy, when an attempted system call is not in the allowlist of permitted calls, the process is terminated immediately, and no further system calls are attempted.\n- The least privilege principle is captured by allowing only a set of permitted system calls of size $n$, denoted as the allowlist.\n\nAbstract model and semantics:\n\n- Let the universe of system calls be indexed by integers, and let $\\mathcal{A}$ denote the set of allowed system call identifiers with $\\lvert \\mathcal{A} \\rvert = n$.\n- Let $\\mathcal{H}$ denote a set of identifiers deemed harmful.\n- Let $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$ denote a workload trace of attempted system calls, where each $w_i$ is an integer identifier.\n- Execution under the policy proceeds left-to-right on $W$ with complete mediation. If $w_i \\in \\mathcal{A}$, then $w_i$ is executed. If $w_i \\notin \\mathcal{A}$, the process terminates at index $i$ (fail-stop), and no further $w_j$ for $j  i$ is executed.\n- Define a harmful-escape indicator $E$ as follows: $E = 1$ if there exists an index $i$ such that $w_i \\in \\mathcal{H}$ and $w_i$ is executed under the policy; otherwise $E = 0$.\n- Define the allowed-executed count $C$ as the number of executed system calls before termination (or all of $W$ if no termination occurs).\n- Define the blocked index $B$ as the index at which the first disallowed call is encountered; if there is no disallowed call, let $B = -1$.\n- Define containment success $S$ as $S = 1$ if $E = 0$, and $S = 0$ otherwise.\n\nYour task:\n\n- Implement a program that, given fixed test cases specified below, simulates the execution according to the semantics above and outputs, for each test case, the quadruple $[S, C, B, E]$.\n- Booleans must be represented as integers: use $1$ for true and $0$ for false.\n- No physical units are involved.\n\nTest suite:\n\nProvide results for the following test cases. For each case, the universe size $S$ is provided for context, but only $\\mathcal{A}$, $\\mathcal{H}$, and $W$ affect the simulation.\n\n- Test case $T_1$: $S = 8$, $n = 3$, $\\mathcal{A} = \\{0, 1, 2\\}$, $\\mathcal{H} = \\{5, 6\\}$, $W = \\langle 0, 1, 5, 3, 6 \\rangle$.\n- Test case $T_2$: $S = 8$, $n = 0$, $\\mathcal{A} = \\varnothing$, $\\mathcal{H} = \\{2, 3\\}$, $W = \\langle 2, 7, 3 \\rangle$.\n- Test case $T_3$: $S = 8$, $n = 4$, $\\mathcal{A} = \\{0, 2, 5, 7\\}$, $\\mathcal{H} = \\{5, 6\\}$, $W = \\langle 0, 5, 2, 7 \\rangle$.\n- Test case $T_4$: $S = 8$, $n = 3$, $\\mathcal{A} = \\{0, 4, 6\\}$, $\\mathcal{H} = \\{6, 7\\}$, $W = \\langle 0, 4, 1, 6, 7 \\rangle$.\n- Test case $T_5$: $S = 8$, $n = 2$, $\\mathcal{A} = \\{1, 3\\}$, $\\mathcal{H} = \\{2\\}$, $W = \\langle \\rangle$ (the empty trace).\n- Test case $T_6$: $S = 8$, $n = 3$, $\\mathcal{A} = \\{1, 5, 7\\}$, $\\mathcal{H} = \\{5\\}$, $W = \\langle 1, 5, 2 \\rangle$.\n\nRequired final output format:\n\n- Your program should produce a single line of output containing the results, in order $T_1$ through $T_6$, as a comma-separated list of per-test-case lists, with no spaces. For example, the required format is exactly of the form\n$[[S_1,C_1,B_1,E_1],[S_2,C_2,B_2,E_2],\\dots,[S_6,C_6,B_6,E_6]]$,\nprinted on a single line, and nothing else.\n- The program must be self-contained, must not read any input, and must compute the results from the test suite as specified above.", "solution": "The problem requires implementing a simulation of an operating system's reference monitor based on a specified abstract model. The solution is a program that simulates the execution of a workload trace against a security policy and computes several metrics. The core logic of the simulation algorithm is as follows.\n\nFor each test case, we must process a workload trace $W = \\langle w_0, w_1, \\dots, w_{L-1} \\rangle$ against an allowlist of system calls $\\mathcal{A}$ and a set of harmful calls $\\mathcal{H}$.\n\nThe simulation proceeds by iterating through the workload trace $W$ from the first element to the last. This models the principle of **complete mediation**, where every system call is intercepted and checked.\n\n1.  Initialize state variables for each trace:\n    -   `C` (allowed-executed count) = 0\n    -   `E` (harmful-escape indicator) = 0\n    -   `B` (blocked index) = -1\n\n2.  For each call `w_i` at index `i` in the trace:\n    a.  Check if `w_i` is in the allowlist `A`. This enforces the **principle of least privilege**.\n    b.  If `w_i` is in `A`:\n        -   Increment `C`.\n        -   Check if `w_i` is also in the harmful set `H`. If so, set `E = 1`.\n        -   Proceed to the next call `w_{i+1}`.\n    c.  If `w_i` is not in `A`:\n        -   The call is blocked. This triggers the **fail-stop** policy.\n        -   Set `B = i`.\n        -   Immediately terminate the simulation for this trace. No further calls are processed.\n\n3.  After the loop finishes (either by reaching the end of the trace or by a fail-stop):\n    -   Calculate the containment success metric `S` as `S = 1 - E`.\n\n4.  The final result for the test case is the quadruple $[S, C, B, E]$.\n\nThis algorithm is implemented for each of the six test cases provided. The final output aggregates the results into a single comma-separated list as specified in the problem description. The program in the answer block is a direct implementation of this logic.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n#include complex.h\n#include threads.h\n#include stdatomic.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    const int* allowlist;\n    int n_allow;\n    const int* harmful;\n    int n_harmful;\n    const int* workload;\n    int n_workload;\n} TestCase;\n\n// Helper function to check if a value is present in an integer array (set).\nint is_in_set(int value, const int* set, int size) {\n    if (set == NULL) {\n        return 0; // False for empty set represented by NULL pointer\n    }\n    for (int i = 0; i  size; ++i) {\n        if (set[i] == value) {\n            return 1; // True\n        }\n    }\n    return 0; // False\n}\n\nint main(void) {\n    // Define the data for the test cases.\n    // Test case T1\n    const int a1[] = {0, 1, 2};\n    const int h1[] = {5, 6};\n    const int w1[] = {0, 1, 5, 3, 6};\n\n    // Test case T2 (empty allowlist)\n    const int h2[] = {2, 3};\n    const int w2[] = {2, 7, 3};\n\n    // Test case T3\n    const int a3[] = {0, 2, 5, 7};\n    const int h3[] = {5, 6};\n    const int w3[] = {0, 5, 2, 7};\n\n    // Test case T4\n    const int a4[] = {0, 4, 6};\n    const int h4[] = {6, 7};\n    const int w4[] = {0, 4, 1, 6, 7};\n\n    // Test case T5 (empty workload)\n    const int a5[] = {1, 3};\n    const int h5[] = {2};\n\n    // Test case T6\n    const int a6[] = {1, 5, 7};\n    const int h6[] = {5};\n    const int w6[] = {1, 5, 2};\n\n    // Define the array of test cases.\n    TestCase test_cases[] = {\n        {a1, sizeof(a1)/sizeof(a1[0]), h1, sizeof(h1)/sizeof(h1[0]), w1, sizeof(w1)/sizeof(w1[0])},\n        {NULL, 0, h2, sizeof(h2)/sizeof(h2[0]), w2, sizeof(w2)/sizeof(w2[0])},\n        {a3, sizeof(a3)/sizeof(a3[0]), h3, sizeof(h3)/sizeof(h3[0]), w3, sizeof(w3)/sizeof(w3[0])},\n        {a4, sizeof(a4)/sizeof(a4[0]), h4, sizeof(h4)/sizeof(h4[0]), w4, sizeof(w4)/sizeof(w4[0])},\n        {a5, sizeof(a5)/sizeof(a5[0]), h5, sizeof(h5)/sizeof(h5[0]), NULL, 0},\n        {a6, sizeof(a6)/sizeof(a6[0]), h6, sizeof(h6)/sizeof(h6[0]), w6, sizeof(w6)/sizeof(w6[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][4]; // To store [S, C, B, E] for each case\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        \n        // Initialize simulation state variables\n        int C = 0; // allowed-executed count\n        int B = -1; // blocked index\n        int E = 0; // harmful-escape indicator\n\n        // Simulate the workload trace\n        for (int j = 0; j  tc.n_workload; ++j) {\n            int current_call = tc.workload[j];\n            \n            // Complete mediation: check if the call is in the allowlist\n            if (is_in_set(current_call, tc.allowlist, tc.n_allow)) {\n                // Call is allowed\n                C++;\n                // Check if the executed call is harmful\n                if (is_in_set(current_call, tc.harmful, tc.n_harmful)) {\n                    E = 1;\n                }\n            } else {\n                // Fail-stop: call is not allowed, terminate process\n                B = j;\n                break; // Exit the simulation loop for this trace\n            }\n        }\n        \n        // Calculate containment success S\n        int S = 1 - E;\n        \n        // Store results for this test case\n        results[i][0] = S;\n        results[i][1] = C;\n        results[i][2] = B;\n        results[i][3] = E;\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%d,%d,%d]\", results[i][0], results[i][1], results[i][2], results[i][3]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3664897"}]}