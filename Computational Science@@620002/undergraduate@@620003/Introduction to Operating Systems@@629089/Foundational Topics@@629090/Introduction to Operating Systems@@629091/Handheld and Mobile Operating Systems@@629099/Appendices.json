{"hands_on_practices": [{"introduction": "Managing power is a paramount concern in mobile operating systems, as every joule of energy counts. This challenge is particularly acute for peripherals like wireless radios, which must balance connectivity needs with the strict energy budget of a battery. This practice asks you to step into the role of an OS designer optimizing a Bluetooth Low Energy (BLE) connection, a core technology for wearables and IoT devices, by finding the ideal connection interval that minimizes power while satisfying crucial latency and data throughput requirements [@problem_id:3646045].", "problem": "A wearable sensor uses Bluetooth Low Energy (BLE) to maintain a connection with a smartphone. The wearable’s operating system schedules a connection event every connection interval of length $\\tau$, during which it sends exactly one notification containing application data, and then returns to deep sleep until the next event. Assume the following scientifically grounded facts and parameters:\n\n- BLE connection events repeat with period $\\tau$ and the worst-case one-way application-layer latency equals the next-event wait, which is $\\tau$ (ignore host and controller processing delays relative to radio timing).\n- Average power over a periodic schedule equals total energy spent in one period divided by the period.\n- Each connection event has a fixed active-phase energy cost $E_{\\mathrm{act}}$ and duration $t_{\\mathrm{act}}$ that do not depend on $\\tau$, and the device otherwise sleeps at power $P_{\\mathrm{slp}}$ during the remainder of the interval.\n- BLE requires the connection interval $\\tau$ to be an integer multiple of $1.25\\ \\mathrm{ms}$ and to lie within $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$.\n\nThe wearable must stream sensor data at a sustained application data rate $R$ using one notification per connection event. Each notification carries an application payload of $M$ bytes. To meet the data rate, the achieved throughput per second must be at least $R$. To meet interactivity constraints, the worst-case one-way latency must not exceed $L_0$.\n\nGiven:\n- $E_{\\mathrm{act}} = 60\\ \\mathrm{\\mu J}$, $t_{\\mathrm{act}} = 2.5\\ \\mathrm{ms}$, $P_{\\mathrm{slp}} = 9\\ \\mathrm{\\mu W}$,\n- $M = 27\\ \\mathrm{bytes}$, $R = 750\\ \\mathrm{bytes/s}$,\n- $L_0 = 34\\ \\mathrm{ms}$,\n\nuse first principles (definitions of average power over a period, BLE timing, and basic throughput) to determine the value of the connection interval $\\tau^{\\star}$ that minimizes the average power consumption while satisfying both the latency constraint and the data-rate feasibility and quantization constraints. Express your final $\\tau^{\\star}$ in milliseconds. Do not include any units in your final boxed answer.", "solution": "We start from the definition of average power over a periodic schedule. If a system repeats a cycle of duration $\\tau$ and spends total energy $E_{\\mathrm{tot}}(\\tau)$ in that cycle, the time-averaged power is\n$$\nP(\\tau) = \\frac{E_{\\mathrm{tot}}(\\tau)}{\\tau}.\n$$\nFor the BLE-connected wearable, in each interval of length $\\tau$, there is an active radio phase of fixed duration $t_{\\mathrm{act}}$ and fixed energy cost $E_{\\mathrm{act}}$ that are independent of $\\tau$, plus a sleep phase lasting $\\tau - t_{\\mathrm{act}}$ at power $P_{\\mathrm{slp}}$. The total energy per interval is therefore\n$$\nE_{\\mathrm{tot}}(\\tau) = E_{\\mathrm{act}} + P_{\\mathrm{slp}}\\big(\\tau - t_{\\mathrm{act}}\\big).\n$$\nSubstituting into the average power expression yields\n$$\nP(\\tau) = \\frac{E_{\\mathrm{act}} + P_{\\mathrm{slp}}(\\tau - t_{\\mathrm{act}})}{\\tau}\n= P_{\\mathrm{slp}} + \\frac{E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}}{\\tau}.\n$$\nBecause $E_{\\mathrm{act}} > 0$, $P_{\\mathrm{slp}} > 0$, and $t_{\\mathrm{act}} > 0$, the numerator $E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}$ is nonnegative in realistic systems. In the given parameters, $E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}} = 60\\times 10^{-6}\\ \\mathrm{J} - 9\\times 10^{-6}\\ \\mathrm{W}\\cdot 2.5\\times 10^{-3}\\ \\mathrm{s} = 60\\times 10^{-6}\\ \\mathrm{J} - 22.5\\times 10^{-9}\\ \\mathrm{J} > 0$. Hence\n$$\n\\frac{dP}{d\\tau} = -\\frac{E_{\\mathrm{act}} - P_{\\mathrm{slp}}\\,t_{\\mathrm{act}}}{\\tau^{2}} < 0 \\quad \\text{for } \\tau > 0,\n$$\nwhich shows that $P(\\tau)$ is strictly decreasing in $\\tau$ over the feasible domain. Therefore, to minimize average power, we should choose $\\tau$ as large as permitted by the constraints.\n\nWe now formalize the constraints:\n\n1. Latency constraint. Worst-case one-way latency equals the wait until the next connection event, which is $L = \\tau$. The constraint $L \\le L_0$ therefore implies\n$$\n\\tau \\le L_0.\n$$\n\n2. Throughput constraint. One notification per event carries $M$ bytes every $\\tau$ seconds, so the achieved application throughput is\n$$\n\\frac{M}{\\tau}\\ \\mathrm{bytes/s}.\n$$\nTo meet the required rate $R$, we must have\n$$\n\\frac{M}{\\tau} \\ge R \\quad \\Longleftrightarrow \\quad \\tau \\le \\frac{M}{R}.\n$$\n\n3. BLE quantization and range. The BLE connection interval must satisfy\n$$\n\\tau \\in \\{k \\cdot 1.25\\ \\mathrm{ms} \\mid k \\in \\mathbb{Z},\\ 7.5\\ \\mathrm{ms} \\le \\tau \\le 4\\ \\mathrm{s}\\}.\n$$\n\nBecause $P(\\tau)$ decreases with $\\tau$, the optimal $\\tau^{\\star}$ is the largest BLE-permitted value that satisfies both upper bounds from items 1 and 2. Thus, before quantization,\n$$\n\\tau_{\\max} = \\min\\!\\left(L_0,\\ \\frac{M}{R}\\right).\n$$\nWe then quantize $\\tau_{\\max}$ down to the nearest allowed multiple of $1.25\\ \\mathrm{ms}$ that lies within $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$.\n\nSubstitute the given values. Compute the throughput-implied upper bound:\n$$\n\\frac{M}{R} = \\frac{27\\ \\mathrm{bytes}}{750\\ \\mathrm{bytes/s}} = 0.036\\ \\mathrm{s} = 36\\ \\mathrm{ms}.\n$$\nThe latency-implied upper bound is\n$$\nL_0 = 34\\ \\mathrm{ms}.\n$$\nTherefore,\n$$\n\\tau_{\\max} = \\min\\!\\big(34\\ \\mathrm{ms},\\ 36\\ \\mathrm{ms}\\big) = 34\\ \\mathrm{ms}.\n$$\nQuantize $34\\ \\mathrm{ms}$ down to the nearest allowed multiple of $1.25\\ \\mathrm{ms}$. Let the quantization step be $\\Delta = 1.25\\ \\mathrm{ms}$. Compute\n$$\nk = \\left\\lfloor \\frac{34\\ \\mathrm{ms}}{1.25\\ \\mathrm{ms}} \\right\\rfloor = \\left\\lfloor 27.2 \\right\\rfloor = 27,\n$$\nso the largest allowed multiple not exceeding $34\\ \\mathrm{ms}$ is\n$$\n\\tau^{\\star} = k \\Delta = 27 \\times 1.25\\ \\mathrm{ms} = 33.75\\ \\mathrm{ms}.\n$$\nThis value lies within the BLE-allowed range $[7.5\\ \\mathrm{ms}, 4\\ \\mathrm{s}]$ and satisfies both the latency and throughput constraints. Since $P(\\tau)$ is strictly decreasing in $\\tau$, this $\\tau^{\\star}$ minimizes the average power subject to the constraints.", "answer": "$$\\boxed{33.75}$$", "id": "3646045"}, {"introduction": "A seamless user experience hinges on a system's ability to remain responsive, even when background components fail. Mobile operating systems employ sophisticated inter-process communication (IPC) mechanisms, like Binder in Android, which must also propagate failure notifications efficiently. In this exercise, you will trace the journey of a failure notification from a crashed service to its final manifestation on the user's screen, calculating the end-to-end latency and quantifying the impact on the user interface [@problem_id:3646046].", "problem": "You are analyzing failure propagation in an Android-like handheld operating system that uses Binder Inter-Process Communication (IPC). In this system, clients register Binder death recipients to be notified when a remote service process dies. When a remote service process is killed, the kernel driver marks its Binder node as dead and enqueues a death notification to each registered recipient in the client processes. A client application processes this notification on a Binder thread, which posts a message to its main thread. The main thread uses an event loop (Looper) to process messages sequentially and renders visual changes at discrete display refresh boundaries (vertical synchronization) at a fixed refresh rate.\n\nConsider a single client application with the following characteristics at the moment the remote service process is killed at time $t=0$:\n- The kernel’s Binder driver posts the death notification to the client process in $t_{d} = 0.2$ milliseconds.\n- A Binder thread in the client takes $t_{p} = 0.3$ milliseconds to run the death-recipient callback and post a message to the main thread’s queue. Assume there are sufficient Binder threads so that all death recipients in this client post essentially simultaneously at time $t=t_{d}+t_{p}$.\n- The client application’s main thread has a backlog of $2$ messages taking $2$ and $1$ milliseconds, respectively, to process, for a total of $t_{q}=3$ milliseconds of work from $t=0$ onward, processed continuously.\n- The client has $m=3$ user experience (UX) components that independently registered as Binder death recipients. Each component posts a main-thread message that, when processed, updates the component’s state to reflect the failure. Each such update requires a deterministic $t_{u}=7$ milliseconds of main-thread compute time. The main thread processes these three update messages sequentially after the existing backlog, in any order.\n- The display refreshes at a constant rate of $60$ hertz, so the refresh interval is $T_{v}=\\frac{50}{3}$ milliseconds. The time from $t=0$ until the next refresh boundary is $t_{\\text{next}}=\\frac{10}{3}$ milliseconds. A UI change completed by the main thread becomes visible at the first display refresh boundary strictly after the change completes.\n\nDefine the time to propagate failure, $T_{f}$, as the elapsed time from $t=0$ until the first visible indication of failure appears in the application’s user interface. Define the impact on UX components, $I$, as the total number of display frames missed across all $m$ components before each component’s update becomes visible, where a “missed frame” for a component is counted as one for each refresh interval boundary that passes after $t=0$ and before the component’s update becomes visible.\n\nCompute $T_{f}$ and $I$ under the assumptions above. Express $T_{f}$ in milliseconds and $I$ as a dimensionless count. No rounding is required; provide exact values. Return your final answer as a two-entry row vector $\\left(T_{f}, I\\right)$ as specified.", "solution": "First, we establish the timeline of events leading to the processing of failure notifications on the application's main thread. The remote service is killed at time $t=0$.\n\n1.  **Time of Message Posting to Main Thread:**\n    The kernel's Binder driver posts the death notification to the client process in $t_{d} = 0.2$ milliseconds. A Binder thread in the client then takes $t_{p} = 0.3$ milliseconds to execute its callback and post a message to the main thread's message queue. Therefore, the death notification messages from the $m=3$ UX components are all enqueued on the main thread at time $t_{\\text{post}}$:\n    $$t_{\\text{post}} = t_{d} + t_{p} = 0.2 + 0.3 = 0.5 \\text{ ms}$$\n\n2.  **Main Thread Work Timeline:**\n    At $t=0$, the main thread has a backlog of work that takes $t_{q}=3$ milliseconds to complete. Since it processes this work continuously from $t=0$, the backlog will be cleared at $t=3$ ms. The messages posted at $t_{\\text{post}}=0.5$ ms must wait in the queue until the main thread is free.\n    The main thread will start processing the first of the three death notification messages at time $t_{\\text{start,1}}$:\n    $$t_{\\text{start,1}} = t_{q} = 3 \\text{ ms}$$\n    Each of these messages requires a compute time of $t_{u}=7$ milliseconds. The problem states they are processed sequentially in any order. For the first failure propagation, the order does not matter. The first message processing will be completed at $t_{\\text{complete,1}}$:\n    $$t_{\\text{complete,1}} = t_{\\text{start,1}} + t_{u} = 3 + 7 = 10 \\text{ ms}$$\n\n3.  **Display Refresh Timeline:**\n    The display refreshes at a constant rate of $60$ hertz. The refresh interval, $T_{v}$, is:\n    $$T_{v} = \\frac{1 \\text{ s}}{60} \\times \\frac{1000 \\text{ ms}}{1 \\text{ s}} = \\frac{1000}{60} \\text{ ms} = \\frac{50}{3} \\text{ ms}$$\n    The problem states that the time from $t=0$ until the next refresh boundary is $t_{\\text{next}}=\\frac{10}{3}$ milliseconds. Subsequent refresh boundaries occur at intervals of $T_{v}$. The time of the $k$-th refresh boundary after $t=0$ (for $k=0, 1, 2, \\dots$) is given by $t_{\\text{refresh},k}$:\n    $$t_{\\text{refresh},k} = t_{\\text{next}} + k \\cdot T_{v} = \\frac{10}{3} + k \\frac{50}{3} = \\frac{10 + 50k}{3} \\text{ ms}$$\n    The first few refresh boundaries are:\n    $t_{\\text{refresh},0} = \\frac{10}{3} \\approx 3.33$ ms\n    $t_{\\text{refresh},1} = \\frac{10 + 50}{3} = \\frac{60}{3} = 20$ ms\n    $t_{\\text{refresh},2} = \\frac{10 + 100}{3} = \\frac{110}{3} \\approx 36.67$ ms\n    $t_{\\text{refresh},3} = \\frac{10 + 150}{3} = \\frac{160}{3} \\approx 53.33$ ms\n\n4.  **Compute Time to Propagate Failure, $T_{f}$:**\n    $T_{f}$ is the time until the first visible indication of failure. A UI change becomes visible at the first display refresh boundary strictly after the change is completed by the main thread. The first UI change is completed at $t_{\\text{complete,1}} = 10$ ms. We must find the smallest $t_{\\text{refresh},k}$ such that $t_{\\text{refresh},k} > 10$ ms.\n    $t_{\\text{refresh},0} = \\frac{10}{3} < 10$ ms.\n    $t_{\\text{refresh},1} = 20 > 10$ ms.\n    Therefore, the first update becomes visible at $t=20$ ms.\n    $$T_{f} = 20 \\text{ ms}$$\n\n5.  **Compute Impact on UX Components, $I$:**\n    To compute $I$, we need the visibility time for each of the $m=3$ components. We first find the completion times for all three updates. Since they are processed sequentially, and each takes $t_{u}=7$ ms, their completion times are:\n    $$t_{\\text{complete,1}} = 3 + 7 = 10 \\text{ ms}$$\n    $$t_{\\text{complete,2}} = t_{\\text{complete,1}} + t_{u} = 10 + 7 = 17 \\text{ ms}$$\n    $$t_{\\text{complete,3}} = t_{\\text{complete,2}} + t_{u} = 17 + 7 = 24 \\text{ ms}$$\n    Note that this set of completion times is independent of the order of processing.\n\n    Next, we find the visibility time for each component's update, which is the first refresh boundary strictly after its completion time.\n    - Component 1 (completes at $10$ ms): Visible at $t_{\\text{vis,1}} = t_{\\text{refresh},1} = 20$ ms.\n    - Component 2 (completes at $17$ ms): Visible at $t_{\\text{vis,2}} = t_{\\text{refresh},1} = 20$ ms (since $17 < 20$).\n    - Component 3 (completes at $24$ ms): Visible at $t_{\\text{vis,3}} = t_{\\text{refresh},2} = \\frac{110}{3}$ ms (since $20 < 24 < 110/3$).\n\n    The impact $I$ is the total number of frames missed across all components. A missed frame is a refresh boundary that passes before an update becomes visible.\n    The number of missed frames for component $i$, $I_i$, is the count of boundaries $t_{\\text{refresh},k}$ such that $t_{\\text{refresh},k} < t_{\\text{vis},i}$.\n\n    - For Component 1: $t_{\\text{vis,1}} = 20$ ms. The boundaries before $20$ ms are $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}\\}$. So, $I_1 = 1$.\n    - For Component 2: $t_{\\text{vis,2}} = 20$ ms. The boundaries before $20$ ms are also $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}\\}$. So, $I_2 = 1$.\n    - For Component 3: $t_{\\text{vis,3}} = \\frac{110}{3}$ ms. The boundaries before $\\frac{110}{3}$ ms are $\\{t_{\\text{refresh},0} = 10/3 \\text{ ms}, t_{\\text{refresh},1} = 20 \\text{ ms}\\}$. So, $I_3 = 2$.\n\n    The total impact $I$ is the sum of the individual impacts:\n    $$I = I_1 + I_2 + I_3 = 1 + 1 + 2 = 4$$\n\nThe computed values are $T_{f} = 20$ ms and $I=4$.\nThe required output is a two-entry row vector $(T_f, I)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n20 & 4\n\\end{pmatrix}\n}\n$$", "id": "3646046"}, {"introduction": "Modern mobile OSes are increasingly 'intelligent,' using data to proactively improve the user experience and reduce digital noise. A prime example is the management of notifications, where suppressing redundant alerts can significantly reduce user frustration. This problem challenges you to apply principles of statistical decision theory to design a notification deduplication policy, deriving a precise mathematical threshold from user data models to meet a specific product requirement for accuracy [@problem_id:3646018].", "problem": "A handheld device running a modern mobile Operating System (OS) implements a lock-screen notification deduplication policy to suppress redundant alerts. Each incoming notification is represented on-device as a sparse term frequency–inverse document frequency (TF-IDF) vector. For any two notifications in the recent window, define the similarity metric $S$ as the cosine similarity between their TF-IDF vectors, so that $S \\in [0,1]$. The policy declares two notifications as duplicates and suppresses the latter if $S \\ge \\theta$, where $\\theta$ is a threshold to be chosen.\n\nFrom an on-device telemetry study collected under representative usage and resource constraints, it is found that the similarity score $S$ for truly duplicate pairs is well-approximated by a normal distribution with mean $\\mu_{D} = 0.82$ and standard deviation $\\sigma_{D} = 0.06$, while for truly non-duplicate pairs it is well-approximated by a normal distribution with mean $\\mu_{N} = 0.35$ and standard deviation $\\sigma_{N} = 0.08$. The product requirement is that duplicates should occur with probability at most $\\alpha$, meaning the probability that a truly duplicate pair is not suppressed (i.e., $S < \\theta$ for a truly duplicate pair) must be at most $\\alpha$.\n\nAssume independence across pairs and that the normal approximations hold. Starting from the definition of a cumulative distribution function and the decision rule above, derive an expression for the threshold $\\theta$ as a function of $\\mu_{D}$, $\\sigma_{D}$, and $\\alpha$, and then compute its numerical value for $\\alpha = 0.05$. Round your final numeric threshold to four significant figures. Express your final answer as a single real number with no units.", "solution": "Let $S_D$ be the random variable representing the similarity score for a pair of notifications that are truly duplicates. According to the problem statement, $S_D$ follows a normal distribution with mean $\\mu_D$ and standard deviation $\\sigma_D$, which we denote as $S_D \\sim N(\\mu_D, \\sigma_D^2)$.\n\nThe decision rule states that a notification is suppressed if $S \\ge \\theta$ and not suppressed if $S < \\theta$. The product requirement specifies that the probability of a truly duplicate pair not being suppressed is at most $\\alpha$. This can be stated mathematically as:\n$$P(S_D < \\theta) \\le \\alpha$$\nTo find the most permissive threshold $\\theta$ that satisfies this constraint, we set the probability to its maximum allowed value, $\\alpha$:\n$$P(S_D < \\theta) = \\alpha$$\nThe term $P(S_D < \\theta)$ is, by definition, the value of the cumulative distribution function (CDF) of $S_D$ evaluated at $\\theta$. Let us denote this CDF as $F_{S_D}(\\theta)$. For a continuous distribution like the normal distribution, $P(S_D < \\theta) = P(S_D \\le \\theta) = F_{S_D}(\\theta)$.\n\nTo work with the normal distribution, we standardize the random variable $S_D$. Let $Z$ be a standard normal random variable, $Z \\sim N(0, 1)$. The standardization of $S_D$ is given by:\n$$Z = \\frac{S_D - \\mu_D}{\\sigma_D}$$\nThe CDF of the standard normal distribution is commonly denoted by $\\Phi(z) = P(Z \\le z)$. We can express the CDF of $S_D$ in terms of $\\Phi$:\n$$F_{S_D}(\\theta) = P(S_D \\le \\theta) = P\\left(\\frac{S_D - \\mu_D}{\\sigma_D} \\le \\frac{\\theta - \\mu_D}{\\sigma_D}\\right) = P\\left(Z \\le \\frac{\\theta - \\mu_D}{\\sigma_D}\\right) = \\Phi\\left(\\frac{\\theta - \\mu_D}{\\sigma_D}\\right)$$\nSubstituting this into our probability equation, we get:\n$$\\Phi\\left(\\frac{\\theta - \\mu_D}{\\sigma_D}\\right) = \\alpha$$\nTo solve for $\\theta$, we apply the inverse of the standard normal CDF, $\\Phi^{-1}(p)$, also known as the quantile function. This function returns the z-score $z$ such that $\\Phi(z) = p$. Applying $\\Phi^{-1}$ to both sides of the equation yields:\n$$\\frac{\\theta - \\mu_D}{\\sigma_D} = \\Phi^{-1}(\\alpha)$$\nNow, we can isolate $\\theta$ to obtain the general expression as a function of $\\mu_D$, $\\sigma_D$, and $\\alpha$:\n$$\\theta = \\mu_D + \\sigma_D \\Phi^{-1}(\\alpha)$$\nThis is the required symbolic expression for the threshold $\\theta$.\n\nNext, we compute the numerical value for $\\theta$ using the given parameters: $\\mu_D = 0.82$, $\\sigma_D = 0.06$, and $\\alpha = 0.05$.\n\nWe need to find the value of $\\Phi^{-1}(0.05)$, which is the z-score that corresponds to a cumulative probability of $0.05$. This is the $5^{th}$ percentile of the standard normal distribution. From standard statistical tables or computational software, this value is approximately:\n$$\\Phi^{-1}(0.05) \\approx -1.64485$$\nSubstituting the numerical values into our derived expression for $\\theta$:\n$$\\theta = 0.82 + (0.06) \\times \\Phi^{-1}(0.05)$$\n$$\\theta \\approx 0.82 + (0.06) \\times (-1.64485)$$\n$$\\theta \\approx 0.82 - 0.098691$$\n$$\\theta \\approx 0.721309$$\nThe problem requires the final answer to be rounded to four significant figures. The first four significant figures are $7, 2, 1, 3$. The fifth digit is $0$, so we round down.\n$$\\theta \\approx 0.7213$$\nThus, the threshold should be set to $\\theta = 0.7213$ to ensure that the probability of failing to suppress a true duplicate notification is $5\\%$.", "answer": "$$\\boxed{0.7213}$$", "id": "3646018"}]}