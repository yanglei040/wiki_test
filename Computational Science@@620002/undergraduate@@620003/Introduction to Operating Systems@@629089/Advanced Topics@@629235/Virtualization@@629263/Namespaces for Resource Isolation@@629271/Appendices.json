{"hands_on_practices": [{"introduction": "The fundamental promise of namespaces is to provide resource isolation, preventing processes in one namespace from seeing or interacting with resources in another. This practice models the core behavior of Inter-Process Communication (IPC) namespaces, where resources such as semaphores and message queues created in one namespace are strictly partitioned and invisible to others. By simulating the rules of resource creation and visibility, you will gain a concrete, quantitative understanding of how namespaces prevent interference between process groups, a concept foundational to security and stability in containerized and multi-tenant systems. [@problem_id:3662441]", "problem": "You are to write a complete, runnable program that simulates the isolation behavior of System V Inter-Process Communication (IPC) resources under distinct IPC namespaces. The goal is to reason from first principles about operating system resource isolation and to produce a measurable visibility metric.\n\nFundamental base and core definitions: An operating system implements resource isolation with namespaces by scoping resource identifiers to a particular namespace. For System V IPC, resources such as semaphores and message queues are logically partitioned by the IPC namespace. A process listing IPC objects sees only those objects that exist in its own namespace. Formally, let the set of namespaces be $N = \\{0, 1, 2, \\dots\\}$, and let the set of IPC objects be $R$. Each IPC object $r \\in R$ is a tuple $(t, k, n)$, where $t \\in \\{\\text{sem}, \\text{mq}\\}$ is the type (semaphore or message queue), $k \\in \\mathbb{Z}$ is the key (with $k = -1$ representing the special $\\text{IPC\\_PRIVATE}$ key that forces creation of a new object), and $n \\in N$ is the owning namespace identifier. A listing operation performed by a process in namespace $n$ is defined to enumerate exactly the resources $r \\in R$ where the owner of $r$ is $n$. This isolation rule is a well-tested fact in modern operating systems that implement namespaces for resource isolation: the namespace boundary constrains visibility such that objects are not shared across distinct namespaces unless explicitly mapped.\n\nYou must implement a simulation that adheres to the following rules, specified in purely mathematical and logical terms:\n\n- Resource ownership rule: Each created IPC object is associated with exactly one namespace $n$. There is no sharing across namespaces in this model.\n- Listing visibility rule: A listing performed from namespace $n$ sees only objects with owner $n$. Therefore, defining a visibility function $V(A, B)$ that counts how many objects owned by namespace $A$ are visible when listing from namespace $B$, the isolation property requires\n$$\nV(A, B) = \n\\begin{cases}\n|R_A| & \\text{if } A = B, \\\\\n0 & \\text{if } A \\neq B,\n\\end{cases}\n$$\nwhere $R_A = \\{ r \\in R \\mid \\text{owner}(r) = A \\}$ and $|\\cdot|$ denotes cardinality.\n- Key uniqueness rule within a namespace: For any non-private key $k \\neq -1$, attempting to create an object of type $t$ with key $k$ in namespace $n$ results in no change if an object $(t, k, n)$ already exists; otherwise, a new object is added. This models the conventional effect that named keys have unique bindings per type within a namespace.\n- Private key creation rule: For $k = -1$ (representing $\\text{IPC\\_PRIVATE}$), each creation request yields a distinct new object, even if many objects are created with $k = -1$. These objects are counted in listings just like named objects; the special key only affects uniqueness semantics at creation.\n\nYour program must construct namespaces and objects purely in memory (no actual operating system calls), simulate creation operations with these rules, and compute the visibility function $V(A, B)$ for the given test suite.\n\nTest suite and parameters: Initialize two namespaces, $A$ and $B$, with identifiers $0$ and $1$, respectively. For each test case below, create objects as specified and then compute the single numeric result: $V(\\text{source}, \\text{list\\_from})$.\n\n- Test case $1$ (happy path cross-namespace isolation): In namespace $A$, create $2$ semaphores with keys $1$ and $2$, and $1$ message queue with key $42$. Namespace $B$ creates no objects. Compute $V(A, B)$. Expected isolation implies $V(A, B) = 0$.\n- Test case $2$ (boundary condition with empty sets): No objects are created in either namespace. Compute $V(A, A)$. Expect $0$ because $|R_A| = 0$.\n- Test case $3$ (same-namespace visibility with multiple objects): In namespace $B$, create $3$ semaphores with keys $10$, $11$, and $12$, and $2$ message queues with keys $20$ and $21$. Namespace $A$ creates no objects. Compute $V(B, B)$. Expect the cardinality $|R_B| = 5$.\n- Test case $4$ (cross-namespace with key collisions): Create $1$ semaphore with key $5$ in namespace $A$, and $1$ semaphore with key $5$ in namespace $B$. Compute $V(B, A)$. Isolation implies $0$ even though keys collide across namespaces.\n- Test case $5$ (duplicate named keys and private creations within a namespace): In namespace $A$, create $2$ semaphores with $k = -1$ (two distinct $\\text{IPC\\_PRIVATE}$ semaphores), and $2$ message queues with key $10$ (the second is a duplicate and should have no effect). Namespace $B$ creates $1$ semaphore with key $99$. Compute $V(A, A)$. Expect $3$ because $2$ private semaphores plus $1$ unique message queue equal $3$ total objects in $A$.\n\nFinal output format: Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets. For example, the output must be of the form $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$, specifically reflecting the computed values of $V$ in the order of the test cases $1$ through $5$. No physical units are involved. Angles are not used. Percentages are not involved. All results are integers.", "solution": "The problem statement is valid. It presents a well-defined, self-contained, and scientifically grounded simulation task based on established principles of operating system resource management, specifically namespace-based isolation for System V IPC objects. The rules are expressed with mathematical and logical precision, the test cases are unambiguous, and the required output is clearly specified. The problem is formalizable and leads to a unique, verifiable solution.\n\nThe solution is designed by directly translating the provided formal rules into a computational model. The fundamental principle is that of strict resource isolation, as defined by the **Listing visibility rule**. This rule is the cornerstone of the simulation and is mathematically expressed as:\n$$\nV(A, B) = \n\\begin{cases}\n|R_A| & \\text{if } A = B, \\\\\n0 & \\text{if } A \\neq B,\n\\end{cases}\n$$\nwhere $V(A, B)$ is the visibility function counting objects owned by namespace $A$ from a process in namespace $B$, and $|R_A|$ is the number of objects owned by namespace $A$. This rule asserts that visibility is an intra-namespace property only; there is no visibility across namespace boundaries.\n\nOur design materializes this model through three primary components: data structures for IPC objects, a mechanism to manage the collection of these objects, and a set of functions that implement the system's behavior.\n\nFirst, an IPC object, defined as a tuple $(t, k, n)$, is represented by a C `struct`. This structure stores the object's type $t \\in \\{\\text{sem}, \\text{mq}\\}$, its key $k \\in \\mathbb{Z}$, and its owning namespace identifier $n$. For programmatic clarity, the types 'sem' and 'mq' are mapped to integer constants.\n\nSecond, the set of all existing IPC objects, $R$, is managed as a dynamically allocated linked list. This data structure facilitates the addition of new objects as required by creation operations. A global pointer maintains the head of this list. A dedicated function is responsible for deallocating all nodes in the list to reset the simulation state between test cases.\n\nThird, the operational logic is implemented through a set of functions:\n1.  A creation function, `create_object(type, key, namespace_id)`, enforces the **Key uniqueness rule** and the **Private key creation rule**.\n    - If the key $k$ is $-1$ (representing `IPC_PRIVATE`), a new object is unconditionally created and added to the list. This models the guarantee of a unique resource for each `IPC_PRIVATE` request.\n    - If the key $k$ is not $-1$, the function first queries the existing object list to determine if an object with the same type $t$, key $k$, and namespace $n$ already exists. A new object is created and added only if no such object is found. This correctly models the behavior that a named key uniquely identifies an IPC resource of a given type within a specific namespace.\n\n2.  A visibility computation function, `compute_visibility(source_ns, list_from_ns)`, directly implements the `V(A, B)` definition.\n    - If the source namespace `source_ns` and the listing namespace `list_from_ns` are not identical, the function immediately returns $0$, per the $A \\neq B$ case of the visibility rule.\n    - If the namespaces are identical, the function must calculate the cardinality of the resource set for that namespace, $|R_A|$. This is accomplished by iterating through the entire linked list of IPC objects and counting how many are owned by the specified namespace.\n\nThe main program logic systematically executes each of the $5$ test cases provided. For each test case, it first resets the simulation state by clearing the object list, then performs the sequence of `create_object` calls as described, and finally invokes `compute_visibility` with the specified namespaces to calculate the result. The results for all $5$ cases are stored and then printed in a single, comma-separated line as required.\n\nFor instance, in Test Case $5$, we compute $V(A, A)$ where namespace $A$ is identifier $0$. The creation sequence is:\n- `create_object(sem, -1, 0)`: Adds object $1$ to namespace $0$.\n- `create_object(sem, -1, 0)`: Adds object $2$ to namespace $0$ (private key rule).\n- `create_object(mq, 10, 0)`: Adds object $3$ to namespace $0$.\n- `create_object(mq, 10, 0)`: No effect (key uniqueness rule).\n- `create_object(sem, 99, 1)`: Adds an object to namespace $1$.\nWhen `compute_visibility(0, 0)` is called, the condition $A=B$ is met, and the program counts the objects in namespace $0$. The count is correctly determined to be $3$. For Test Case $1$, computing $V(A, B)$, the condition $A \\neq B$ is met, and the function correctly returns $0$ without needing to inspect the object list. This design ensures a robust and accurate simulation adhering strictly to the problem's formal specification.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Represents the type of an IPC object.\ntypedef enum {\n    IPC_TYPE_SEM, // Semaphore\n    IPC_TYPE_MQ   // Message Queue\n} IpcType;\n\n// Represents a single System V IPC object in the simulation.\ntypedef struct IpcObject {\n    IpcType type;\n    int key;\n    int namespace_id;\n    struct IpcObject* next;\n} IpcObject;\n\n// Global head of the linked list for all IPC objects.\nstatic IpcObject* g_ipc_objects = NULL;\n\n// Clears all created IPC objects from the global list, resetting the simulation.\nvoid reset_simulation(void) {\n    IpcObject* current = g_ipc_objects;\n    while (current != NULL) {\n        IpcObject* next = current->next;\n        free(current);\n        current = next;\n    }\n    g_ipc_objects = NULL;\n}\n\n// Checks if a named IPC object already exists in a given namespace.\n// Returns 1 if it exists, 0 otherwise.\nstatic int object_exists(IpcType type, int key, int namespace_id) {\n    for (const IpcObject* p = g_ipc_objects; p != NULL; p = p->next) {\n        if (p->type == type && p->key == key && p->namespace_id == namespace_id) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n// Simulates the creation of an IPC object according to the problem's rules.\nvoid create_object(IpcType type, int key, int namespace_id) {\n    // Private key rule: always create a new object.\n    if (key == -1) {\n        IpcObject* new_obj = (IpcObject*)malloc(sizeof(IpcObject));\n        if (!new_obj) {\n            perror(\"Failed to allocate memory for IPC object\");\n            exit(EXIT_FAILURE);\n        }\n        new_obj->type = type;\n        new_obj->key = key;\n        new_obj->namespace_id = namespace_id;\n        new_obj->next = g_ipc_objects;\n        g_ipc_objects = new_obj;\n        return;\n    }\n\n    // Key uniqueness rule: create only if a named object does not already exist.\n    if (!object_exists(type, key, namespace_id)) {\n        IpcObject* new_obj = (IpcObject*)malloc(sizeof(IpcObject));\n        if (!new_obj) {\n            perror(\"Failed to allocate memory for IPC object\");\n            exit(EXIT_FAILURE);\n        }\n        new_obj->type = type;\n        new_obj->key = key;\n        new_obj->namespace_id = namespace_id;\n        new_obj->next = g_ipc_objects;\n        g_ipc_objects = new_obj;\n    }\n    // If a named object already exists, do nothing, as per the rule.\n}\n\n// Counts the total number of objects belonging to a specific namespace.\n// This corresponds to calculating |R_n|.\nstatic int count_objects_in_namespace(int namespace_id) {\n    int count = 0;\n    for (const IpcObject* p = g_ipc_objects; p != NULL; p = p->next) {\n        if (p->namespace_id == namespace_id) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Computes the visibility function V(source_ns, list_from_ns).\nint compute_visibility(int source_ns, int list_from_ns) {\n    // Implements the Listing visibility rule:\n    // V(A, B) = 0 if A != B\n    if (source_ns != list_from_ns) {\n        return 0;\n    }\n    \n    // V(A, A) = |R_A|\n    return count_objects_in_namespace(source_ns);\n}\n\nint main(void) {\n    // Array to store the results of the 5 test cases.\n    int results[5];\n\n    // Define namespace identifiers as specified in the problem.\n    const int NS_A = 0;\n    const int NS_B = 1;\n    const int IPC_PRIVATE = -1;\n\n    // --- Test Case 1 ---\n    reset_simulation();\n    create_object(IPC_TYPE_SEM, 1, NS_A);\n    create_object(IPC_TYPE_SEM, 2, NS_A);\n    create_object(IPC_TYPE_MQ, 42, NS_A);\n    results[0] = compute_visibility(NS_A, NS_B);\n\n    // --- Test Case 2 ---\n    reset_simulation();\n    // No objects are created in this case.\n    results[1] = compute_visibility(NS_A, NS_A);\n\n    // --- Test Case 3 ---\n    reset_simulation();\n    create_object(IPC_TYPE_SEM, 10, NS_B);\n    create_object(IPC_TYPE_SEM, 11, NS_B);\n    create_object(IPC_TYPE_SEM, 12, NS_B);\n    create_object(IPC_TYPE_MQ, 20, NS_B);\n    create_object(IPC_TYPE_MQ, 21, NS_B);\n    results[2] = compute_visibility(NS_B, NS_B);\n\n    // --- Test Case 4 ---\n    reset_simulation();\n    create_object(IPC_TYPE_SEM, 5, NS_A);\n    create_object(IPC_TYPE_SEM, 5, NS_B);\n    results[3] = compute_visibility(NS_B, NS_A);\n\n    // --- Test Case 5 ---\n    reset_simulation();\n    create_object(IPC_TYPE_SEM, IPC_PRIVATE, NS_A); // 1st private sem in A\n    create_object(IPC_TYPE_SEM, IPC_PRIVATE, NS_A); // 2nd private sem in A\n    create_object(IPC_TYPE_MQ, 10, NS_A);          // Unique MQ in A\n    create_object(IPC_TYPE_MQ, 10, NS_A);          // Duplicate, no effect\n    create_object(IPC_TYPE_SEM, 99, NS_B);         // Object in B, ignored\n    results[4] = compute_visibility(NS_A, NS_A);\n\n    // Final cleanup before exiting.\n    reset_simulation();\n\n    // Print the results in the exact required format.\n    printf(\"[%d,%d,%d,%d,%d]\\n\", results[0], results[1], results[2], results[3], results[4]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3662441"}, {"introduction": "Building on the core concept of isolation, this practice explores its powerful application in network security, a cornerstone of container technology. Network (NET) namespaces provide each container with its own independent network stack, including routing tables and firewall rules, separate from the host and other containers. This exercise asks you to model this separation by implementing a logical firewall and comparing the packet-filtering behavior in a container's namespace versus the host's, quantifying the difference in drop rates to demonstrate this crucial security mechanism. [@problem_id:3662439]", "problem": "You are asked to formalize, from first principles of operating system resource isolation, a minimal firewall laboratory in pure logic to demonstrate that packet filter rules applied inside a process groupâ€™s Network (NET) namespace do not inherit or apply host rules. To do this, model packet filtering as a deterministic function evaluated per namespace, and compute quantitative differences in packet drop rates between the host and the container namespace across a fixed test suite.\n\nFundamental base to use:\n- Namespaces in a Unix-like operating system isolate resource views by creating disjoint instances of resource tables. The Network (NET) namespace isolates network-related resources, which includes packet filter tables such as those manipulated by the Linux Netfilter and its command-line interface iptables. By the principle of resource isolation, rules in one NET namespace do not apply to packets evaluated in another NET namespace.\n- A firewall rule set can be modeled as an ordered list evaluated by first-match semantics: rules are checked in sequence, and the first matching rule determines the action. If no rule matches, a chain default policy is applied. This mirrors well-tested behavior in common packet filter frameworks.\n\nModel specification:\n- Each packet is a tuple with attributes: chain $c \\in \\{\\text{INPUT}, \\text{OUTPUT}\\}$, protocol $p \\in \\{\\text{TCP}, \\text{UDP}\\}$, destination port $d$ where $d$ is an integer with $d \\ge 0$, and a trust flag $t \\in \\{0,1\\}$ representing whether the source is trusted.\n- Each rule $r$ is a tuple $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$ where $c_r$ is the chain, $p_r$ is the protocol, $[\\ell_r, u_r]$ is a closed integer port interval with $\\ell_r \\le u_r$, $t_r \\in \\{0,1\\}$ indicates whether the rule requires trusted sources ($t=1$) or not ($t=0$ meaning no trust required), and $a_r \\in \\{\\text{ACCEPT}, \\text{DROP}\\}$ is the action. A rule $r$ matches a packet $(c, p, d, t)$ if and only if $c = c_r$, $p = p_r$, $\\ell_r \\le d \\le u_r$, and either $t_r=0$ or $t=1$.\n- A policy for a namespace is an ordered list of rules and a default action per chain. Evaluation of a packet proceeds by scanning rules in order and applying the action of the first matching rule. If no rule matches, the chain default action applies.\n- Let $R_H$ and $R_C$ denote the host and container rule lists, each evaluated only within their respective namespace. Let $P_H(c)$ and $P_C(c)$ denote host and container chain default actions for chain $c$. Let $S=\\{(c_i,p_i,d_i,t_i,n_i)\\}$ be a multiset of flows, where each flow entry specifies $n_i$ packets with identical attributes.\n\nGiven this, define the drop rate of a policy on $S$ as $$r = \\frac{\\sum_i n_i \\cdot \\mathbf{1}[\\text{action}(c_i,p_i,d_i,t_i) = \\text{DROP}]}{\\sum_i n_i},$$ where $\\mathbf{1}[\\cdot]$ is the indicator function and $\\text{action}(\\cdot)$ is determined by the evaluation procedure described above. The quantity to report per test case is the absolute difference in drop rates between the container and the host $$\\Delta = \\left| r_C - r_H \\right|.$$\n\nYour program must implement this model and compute $\\Delta$ for each of the following test cases. No external input is allowed; all parameters are embedded in the program. There must be no dependence on actual iptables or operating system calls; everything is computed symbolically according to the model.\n\nTest suite:\n- Test case $1$ (happy path isolation by explicit host DROP):\n    - Host rules: one rule that drops inbound Transmission Control Protocol (TCP) port $80$, i.e., $(\\text{INPUT}, \\text{TCP}, [80,80], 0, \\text{DROP})$.\n    - Host defaults: both chains default to ACCEPT.\n    - Container rules: none.\n    - Container defaults: both chains default to ACCEPT.\n    - Flows $S$: $50$ packets $(\\text{INPUT}, \\text{TCP}, 80, 0)$ and $50$ packets $(\\text{INPUT}, \\text{TCP}, 443, 0)$.\n- Test case $2$ (rule ordering and trust predicate):\n    - Host rules: first ACCEPT inbound TCP port $22$ if trusted, i.e., $(\\text{INPUT}, \\text{TCP}, [22,22], 1, \\text{ACCEPT})$, then DROP inbound TCP port $22$ for all, i.e., $(\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$.\n    - Host defaults: both chains default to ACCEPT.\n    - Container rules: one rule that drops inbound TCP port $22$, i.e., $(\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$.\n    - Container defaults: both chains default to ACCEPT.\n    - Flows $S$: $30$ packets $(\\text{INPUT}, \\text{TCP}, 22, 1)$ and $70$ packets $(\\text{INPUT}, \\text{TCP}, 22, 0)$.\n- Test case $3$ (default policy boundary condition):\n    - Host rules: none.\n    - Host defaults: both chains default to ACCEPT.\n    - Container rules: none.\n    - Container defaults: both chains default to DROP.\n    - Flows $S$: $40$ packets $(\\text{INPUT}, \\text{TCP}, 5000, 0)$ and $60$ packets $(\\text{INPUT}, \\text{UDP}, 5000, 0)$.\n- Test case $4$ (protocol-specific rule with container exception):\n    - Host rules: one rule that drops inbound User Datagram Protocol (UDP) port $53$, i.e., $(\\text{INPUT}, \\text{UDP}, [53,53], 0, \\text{DROP})$.\n    - Host defaults: both chains default to ACCEPT.\n    - Container rules: one rule that accepts inbound UDP port $53$ if trusted, i.e., $(\\text{INPUT}, \\text{UDP}, [53,53], 1, \\text{ACCEPT})$.\n    - Container defaults: both chains default to ACCEPT.\n    - Flows $S$: $10$ packets $(\\text{INPUT}, \\text{UDP}, 53, 1)$, $10$ packets $(\\text{INPUT}, \\text{UDP}, 53, 0)$, and $10$ packets $(\\text{INPUT}, \\text{UDP}, 67, 0)$.\n\nYour program must produce a single line of output containing the results for the four test cases as a comma-separated list of decimals enclosed in square brackets in the order of the test cases, for example, $[x_1,x_2,x_3,x_4]$, where each $x_i$ is $\\Delta$ for test case $i$ expressed as a decimal with exactly six digits after the decimal point. No other output is permitted.", "solution": "The problem statement has been critically validated and is deemed **valid**. It is scientifically grounded in the principles of operating system resource isolation, specifically network namespacing. The problem is well-posed, providing a complete and consistent formal model for packet filtering, along with all necessary data for four distinct test cases. The objective is clear and the required output format is precisely specified. The model, while a simplification of a real-world firewall, is a logically sound and computationally tractable abstraction suitable for the task.\n\nThe core principle demonstrated is that of resource isolation in modern operating systems. By creating a separate Network (NET) namespace, a group of processes (e.g., in a container) obtains an independent network stack. This includes its own network interfaces, routing tables, and, crucially for this problem, packet filtering rules (e.g., `iptables`). Rules established on the host system exist in the host's NET namespace and are not inherited by, nor do they affect, the container's namespace. The problem asks to quantify this isolation by modeling the packet filtering logic and calculating the difference in packet drop rates between a host policy and a container policy.\n\nThe model is defined as follows:\nA packet is a tuple $(c, p, d, t)$ representing its chain, protocol, destination port, and trust status.\nA rule is a tuple $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$ defining matching criteria and an action.\nA packet $(c, p, d, t)$ matches a rule $(c_r, p_r, [\\ell_r, u_r], t_r, a_r)$ if and only if all of the following conditions are met:\n$1$. The chains match: $c = c_r$.\n$2$. The protocols match: $p = p_r$.\n$3$. The destination port $d$ is within the rule's port range: $\\ell_r \\le d \\le u_r$.\n$4$. The trust requirement is satisfied. The rule's trust requirement $t_r$ can be $0$ (no trust required) or $1$ (trust required). A packet with trust flag $t$ satisfies this if $t \\ge t_r$. This correctly models the logic that a rule requiring no trust ($t_r=0$) will match any packet ($t=0$ or $t=1$), while a rule requiring trust ($t_r=1$) will only match a trusted packet ($t=1$).\n\nA policy for a namespace consists of an ordered list of rules, $R$, and a default action for each chain, $P(c)$. To determine the action for a given packet, we iterate through the list $R$. The action $a_r$ of the first matching rule is applied. If no rule in $R$ matches the packet, the default policy $P(c)$ for the packet's chain $c$ is applied.\n\nThe drop rate $r$ for a given policy and a multiset of flows $S=\\{(c_i,p_i,d_i,t_i,n_i)\\}$ is the ratio of the total number of dropped packets to the total number of packets:\n$$r = \\frac{\\sum_i n_i \\cdot \\mathbf{1}[\\text{action}(c_i,p_i,d_i,t_i) = \\text{DROP}]}{\\sum_i n_i}$$\nwhere $\\mathbf{1}[\\cdot]$ is the indicator function. The final quantity to compute is the absolute difference in drop rates, $\\Delta = \\left| r_C - r_H \\right|$, between the container and the host.\n\nLet us trace the execution for Test Case $2$ to illustrate the application of this model.\nTotal packets: $30+70=100$. The flows are $S = \\{(\\text{INPUT}, \\text{TCP}, 22, 1, 30), (\\text{INPUT}, \\text{TCP}, 22, 0, 70)\\}$.\n\n**Host Policy Evaluation ($r_H$)**:\n- Host Rules $R_H$:\n    $1$. $r_1 = (\\text{INPUT}, \\text{TCP}, [22,22], 1, \\text{ACCEPT})$\n    $2$. $r_2 = (\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$\n- Host Default $P_H(\\text{INPUT})$: $\\text{ACCEPT}$.\n\n- Flow $1$: $30$ packets of type $(\\text{INPUT}, \\text{TCP}, 22, 1)$.\n    - Check against $r_1$: $c=\\text{INPUT}$, $p=\\text{TCP}$, $d=22$, $t=1$. Rule matches ($c, p, d$ are correct, and $t \\ge t_r \\implies 1 \\ge 1$). Action is $\\text{ACCEPT}$.\n    - Total accepted from Flow $1$: $30$.\n\n- Flow $2$: $70$ packets of type $(\\text{INPUT}, \\text{TCP}, 22, 0)$.\n    - Check against $r_1$: $c=\\text{INPUT}$, $p=\\text{TCP}$, $d=22$, $t=0$. Rule does not match because the trust condition $t \\ge t_r \\implies 0 \\ge 1$ is false.\n    - Check against $r_2$: $c=\\text{INPUT}$, $p=\\text{TCP}$, $d=22$, $t=0$. Rule matches ($c, p, d$ are correct, and $t \\ge t_r \\implies 0 \\ge 0$). Action is $\\text{DROP}$.\n    - Total dropped from Flow $2$: $70$.\n\n- Host Summary: Total dropped packets = $0 + 70 = 70$. Total packets = $100$.\n- Host drop rate: $r_H = 70 / 100 = 0.7$.\n\n**Container Policy Evaluation ($r_C$)**:\n- Container Rules $R_C$:\n    $1$. $r_1 = (\\text{INPUT}, \\text{TCP}, [22,22], 0, \\text{DROP})$\n- Container Default $P_C(\\text{INPUT})$: $\\text{ACCEPT}$.\n\n- Flow $1$: $30$ packets of type $(\\text{INPUT}, \\text{TCP}, 22, 1)$.\n    - Check against $r_1$: $c=\\text{INPUT}$, $p=\\text{TCP}$, $d=22$, $t=1$. Rule matches ($c, p, d$ are correct, and $t \\ge t_r \\implies 1 \\ge 0$). Action is $\\text{DROP}$.\n    - Total dropped from Flow $1$: $30$.\n\n- Flow $2$: $70$ packets of type $(\\text{INPUT}, \\text{TCP}, 22, 0)$.\n    - Check against $r_1$: $c=\\text{INPUT}$, $p=\\text{TCP}$, $d=22$, $t=0$. Rule matches ($c, p, d$ are correct, and $t \\ge t_r \\implies 0 \\ge 0$). Action is $\\text{DROP}$.\n    - Total dropped from Flow $2$: $70$.\n\n- Container Summary: Total dropped packets = $30 + 70 = 100$. Total packets = $100$.\n- Container drop rate: $r_C = 100 / 100 = 1.0$.\n\n**Final Calculation for Test Case $2$**:\n- $\\Delta_2 = |r_C - r_H| = |1.0 - 0.7| = 0.3$.\n\nThis same deterministic procedure is applied to all four test cases to compute the required values. The implementation is realized in the following C program, which encapsulates these structures and logic.\nThe final results are:\n- Test Case $1$: $r_H = 50/100 = 0.5$, $r_C = 0/100 = 0.0$. $\\Delta_1 = |0.0 - 0.5| = 0.5$.\n- Test Case $2$: $r_H = 70/100 = 0.7$, $r_C = 100/100 = 1.0$. $\\Delta_2 = |1.0 - 0.7| = 0.3$.\n- Test Case $3$: $r_H = 0/100 = 0.0$, $r_C = 100/100 = 1.0$. $\\Delta_3 = |1.0 - 0.0| = 1.0$.\n- Test Case $4$: $r_H = 20/30$, $r_C = 0/30 = 0.0$. $\\Delta_4 = |0.0 - 20/30| = 2/3 \\approx 0.666667$.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h> // Not used\n// #include <threads.h> // Not used\n// #include <stdatomic.h> // Not used\n\n// Enums for categorical data to improve readability and correctness.\ntypedef enum { INPUT, OUTPUT } Chain_e;\ntypedef enum { TCP, UDP } Protocol_e;\ntypedef enum { ACCEPT, DROP } Action_e;\n\n// A packet is a tuple of its attributes.\ntypedef struct {\n    Chain_e chain;\n    Protocol_e protocol;\n    int port;\n    int trust; // 0 for not trusted, 1 for trusted.\n} Packet_t;\n\n// A rule defines matching criteria and an action.\ntypedef struct {\n    Chain_e chain;\n    Protocol_e protocol;\n    int port_lower;\n    int port_upper;\n    int trust; // 0 for no trust required, 1 for trust required.\n    Action_e action;\n} Rule_t;\n\n// A flow represents a number of identical packets.\ntypedef struct {\n    Packet_t packet;\n    int num_packets;\n} Flow_t;\n\n// A policy consists of an ordered list of rules and default actions.\ntypedef struct {\n    const Rule_t* rules;\n    size_t num_rules;\n    Action_e default_input;\n    Action_e default_output;\n} Policy_t;\n\n// A test case encapsulates all data for a single scenario.\ntypedef struct {\n    Policy_t host_policy;\n    Policy_t container_policy;\n    const Flow_t* flows;\n    size_t num_flows;\n} TestCase_t;\n\n// Determines the action for a packet based on a given policy.\n// It iterates through rules and applies the first match. If no rules match,\n// the chain's default policy is used.\nAction_e get_action(const Packet_t* packet, const Policy_t* policy) {\n    for (size_t i = 0; i < policy->num_rules; ++i) {\n        const Rule_t* rule = &policy->rules[i];\n        \n        // A rule matches if all its conditions are met.\n        if (packet->chain == rule->chain &&\n            packet->protocol == rule->protocol &&\n            packet->port >= rule->port_lower &&\n            packet->port <= rule->port_upper &&\n            packet->trust >= rule->trust) { // Key trust logic\n            return rule->action;\n        }\n    }\n    \n    // If no rule matched, apply the default policy for the chain.\n    if (packet->chain == INPUT) {\n        return policy->default_input;\n    } else {\n        return policy->default_output;\n    }\n}\n\n// Calculates the packet drop rate for a given policy and set of flows.\ndouble calculate_drop_rate(const Policy_t* policy, const Flow_t* flows, size_t num_flows) {\n    long long total_packets = 0;\n    long long dropped_packets = 0;\n\n    for (size_t i = 0; i < num_flows; ++i) {\n        const Flow_t* flow = &flows[i];\n        total_packets += flow->num_packets;\n        \n        Action_e action = get_action(&flow->packet, policy);\n        if (action == DROP) {\n            dropped_packets += flow->num_packets;\n        }\n    }\n    \n    if (total_packets == 0) {\n        return 0.0;\n    }\n\n    return (double)dropped_packets / (double)total_packets;\n}\n\nint main(void) {\n    // ---- Test Case 1 Data ----\n    const Rule_t tc1_host_rules[] = {\n        {INPUT, TCP, 80, 80, 0, DROP}\n    };\n    const Flow_t tc1_flows[] = {\n        {{INPUT, TCP, 80, 0}, 50},\n        {{INPUT, TCP, 443, 0}, 50}\n    };\n    \n    // ---- Test Case 2 Data ----\n    const Rule_t tc2_host_rules[] = {\n        {INPUT, TCP, 22, 22, 1, ACCEPT},\n        {INPUT, TCP, 22, 22, 0, DROP}\n    };\n    const Rule_t tc2_container_rules[] = {\n        {INPUT, TCP, 22, 22, 0, DROP}\n    };\n    const Flow_t tc2_flows[] = {\n        {{INPUT, TCP, 22, 1}, 30},\n        {{INPUT, TCP, 22, 0}, 70}\n    };\n\n    // ---- Test Case 3 Data ----\n    const Flow_t tc3_flows[] = {\n        {{INPUT, TCP, 5000, 0}, 40},\n        {{INPUT, UDP, 5000, 0}, 60}\n    };\n\n    // ---- Test Case 4 Data ----\n    const Rule_t tc4_host_rules[] = {\n        {INPUT, UDP, 53, 53, 0, DROP}\n    };\n    const Rule_t tc4_container_rules[] = {\n        {INPUT, UDP, 53, 53, 1, ACCEPT}\n    };\n    const Flow_t tc4_flows[] = {\n        {{INPUT, UDP, 53, 1}, 10},\n        {{INPUT, UDP, 53, 0}, 10},\n        {{INPUT, UDP, 67, 0}, 10}\n    };\n    \n    // Define the test cases from the problem statement.\n    TestCase_t test_cases[] = {\n        { // Test Case 1\n            .host_policy = {tc1_host_rules, 1, ACCEPT, ACCEPT},\n            .container_policy = {NULL, 0, ACCEPT, ACCEPT},\n            .flows = tc1_flows,\n            .num_flows = 2\n        },\n        { // Test Case 2\n            .host_policy = {tc2_host_rules, 2, ACCEPT, ACCEPT},\n            .container_policy = {tc2_container_rules, 1, ACCEPT, ACCEPT},\n            .flows = tc2_flows,\n            .num_flows = 2\n        },\n        { // Test Case 3\n            .host_policy = {NULL, 0, ACCEPT, ACCEPT},\n            .container_policy = {NULL, 0, DROP, DROP},\n            .flows = tc3_flows,\n            .num_flows = 2\n        },\n        { // Test Case 4\n            .host_policy = {tc4_host_rules, 1, ACCEPT, ACCEPT},\n            .container_policy = {tc4_container_rules, 1, ACCEPT, ACCEPT},\n            .flows = tc4_flows,\n            .num_flows = 3\n        }\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        double r_H = calculate_drop_rate(&test_cases[i].host_policy, test_cases[i].flows, test_cases[i].num_flows);\n        double r_C = calculate_drop_rate(&test_cases[i].container_policy, test_cases[i].flows, test_cases[i].num_flows);\n        results[i] = fabs(r_C - r_H);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[%.6f,%.6f,%.6f,%.6f]\\n\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3662439"}, {"introduction": "A modern container is not the product of a single isolation feature, but a carefully orchestrated combination of several different types of namespaces (PID, MNT, UTS, IPC, NET, and USER). This final practice challenges you to think like a container runtime developer, modeling the setup process as an algorithmic puzzle with dependencies and privilege requirements. By computing the minimal, valid sequence of steps to construct an isolated environment, you will synthesize your knowledge of individual namespaces and see how they are assembled to create the robust, sandboxed environments that power modern cloud-native applications. [@problem_id:3662442]", "problem": "You are to design and implement a complete, runnable program that computes and logs a valid, minimal sequence of steps to set up a simplified container-like runtime using operating system namespaces, under a formal model of capability and dependencies. The goal is to reason from first principles of resource isolation via namespaces, capability acquisition, and partial-order constraints, and then compute a sequence that satisfies these constraints with a precise minimality criterion.\n\nFundamental base for reasoning:\n- Namespaces provide isolation of system resources to a process. In this problem, we consider six namespaces: Process Identifier (PID), Mount (MNT), Unix Time-sharing System (UTS), Inter-Process Communication (IPC), Network (NET), and User (USER).\n- A capability model: the process has a single abstract capability, denoted by $C$, which is required to create any namespace other than the User namespace (USER). Initially, capability $C$ is present if and only if the process is privileged. Creating a USER namespace grants capability $C$ inside the new user namespace. This models the widely observed operating system behavior that user namespaces grant namespace-scoped privileges to the process.\n- A partial-order of steps: certain configuration steps must occur only after the corresponding namespace is created; finally, launching the target process must occur only after all required creations and configurations have been completed.\n\nYou will implement the following formal model.\n\n1. Steps and their codes. Define the following step codes, each represented as an integer:\n   - $1$: Create USER namespace.\n   - $2$: Create PID namespace.\n   - $3$: Create MNT namespace.\n   - $4$: Create UTS namespace.\n   - $5$: Create IPC namespace.\n   - $6$: Create NET namespace.\n   - $7$: Configure MNT (for example, mount a pseudo-filesystem) after creating MNT.\n   - $8$: Configure UTS (for example, set a hostname) after creating UTS.\n   - $9$: Configure NET (for example, bring up loopback) after creating NET.\n   - $10$: Launch the target process.\n\n2. Inputs per test case. Each test case specifies:\n   - A privilege flag $p \\in \\{0,1\\}$, where $p=1$ means the process initially has capability $C$, and $p=0$ means it does not.\n   - Desired namespaces to create, encoded as six booleans $(u, pid, mnt, uts, ipc, net)$, each in $\\{0,1\\}$, indicating whether the respective namespace is requested. The order is $(\\text{USER}, \\text{PID}, \\text{MNT}, \\text{UTS}, \\text{IPC}, \\text{NET})$.\n\n3. Capability rule. Let $C$ denote the capability required to create any namespace except USER:\n   - Initially, $C=1$ if and only if $p=1$.\n   - Creating the USER namespace sets $C=1$ for subsequent steps.\n   - If $p=0$ and $u=0$, then any request to create a namespace other than USER is impossible under this model, because $C=0$ and there is no way to acquire it. Such a test case is deemed impossible.\n\n4. Dependency rules. The valid sequence of steps must satisfy:\n   - If $u=1$ and at least one of $(pid, mnt, uts, ipc, net)$ is $1$, then the USER creation (step $1$) must occur before every other namespace creation step present.\n   - For each requested namespace $X$ among $(\\text{PID}, \\text{MNT}, \\text{UTS}, \\text{IPC}, \\text{NET})$, include the corresponding creation step code ($2$ through $6$) in the log.\n   - If $mnt=1$, include step $7$ and enforce precedence $3 \\rightarrow 7$.\n   - If $uts=1$, include step $8$ and enforce precedence $4 \\rightarrow 8$.\n   - If $net=1$, include step $9$ and enforce precedence $6 \\rightarrow 9$.\n   - The launch step $10$ must occur strictly after all included creation and configuration steps.\n   - If no namespaces are requested at all, the sequence consists only of $10$.\n\n5. Minimality criterion. Among all sequences satisfying the above, select the lexicographically minimal sequence with respect to step codes. Formally, define the set of all topological sorts of the partial order induced by the dependency rules. Choose the sequence $\\sigma$ such that for any other valid sequence $\\tau$, there exists an index $k$ with $\\sigma_i = \\tau_i$ for all $i < k$ and $\\sigma_k < \\tau_k$. Intuitively, at each choice point among currently enabled steps, pick the smallest available step code.\n\n6. Impossibility handling. If the capability rule determines the test case to be impossible, the result is the empty list $[\\,]$.\n\nYour task is to implement a program that, for a fixed test suite provided below, computes the resulting sequence for each test case and prints all results aggregated on a single line.\n\nTest suite. For each tuple, the first entry is $p$, followed by $(u, pid, mnt, uts, ipc, net)$:\n- Case $1$: $(0,\\;1,1,1,1,1,1)$.\n- Case $2$: $(0,\\;0,0,0,1,0,0)$.\n- Case $3$: $(1,\\;0,0,0,0,0,1)$.\n- Case $4$: $(1,\\;0,0,0,0,0,0)$.\n- Case $5$: $(1,\\;0,1,1,1,1,0)$.\n- Case $6$: $(0,\\;1,0,0,0,0,0)$.\n\nExpected result type. For each test case, the result is a list of integers representing the step codes in the computed log sequence; in the impossible case, an empty list. The program must output a single line containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list enclosed in square brackets. For example, a valid output format looks like $[\\,[1,2],\\,[\\,],\\,[3]\\,]$ but with the concrete results of the test suite above. No spaces should be inserted anywhere in the output string.\n\nYour program must be entirely self-contained, require no input, and produce exactly one line in the specified format.", "solution": "The user-provided problem is a valid, well-posed algorithmic challenge grounded in the principles of operating system resource isolation. It asks for the computation of a lexicographically minimal sequence of setup steps for a simplified container environment, subject to capability and dependency constraints. I will proceed with a formal solution.\n\nThe problem can be modeled as finding a specific topological sort of a Directed Acyclic Graph (DAG), where nodes represent system tasks and edges represent dependencies. The \"lexicographically minimal\" requirement implies that at any point where multiple tasks are ready to be executed, we must choose the one with the smallest integer step code. This is achieved using a variant of Kahn's algorithm for topological sorting, employing a min-priority queue.\n\nAn additional constraint is the capability model. A capability $C$, which can be initially present or absent, is required for creating non-USER namespaces. This capability can be acquired by creating a USER namespace. This introduces a state-dependent readiness condition for certain tasks, which must be integrated into the sorting algorithm.\n\n### Formal Model and Algorithm\n\n1.  **Graph Construction**: For each test case, we construct a DAG $G = (V, E)$.\n    *   The set of vertices $V$ consists of the integer codes for all steps required by the test case's input parameters.\n    *   The set of edges $E$ represents the precedence constraints:\n        *   An edge $u \\to v$ is added if step $u$ must be executed before step $v$.\n        *   These dependencies are derived from the problem's rules:\n            *   Configuration dependencies: $3 \\to 7$ (MNT), $4 \\to 8$ (UTS), $6 \\to 9$ (NET).\n            *   Launch dependency: For every other required step $s \\in V \\setminus \\{10\\}$, an edge $s \\to 10$ is added.\n            *   USER namespace dependency: If the USER namespace is created ($u=1$) and other namespaces are also requested, an edge $1 \\to k$ is added for each other requested namespace creation step $k \\in \\{2, 3, 4, 5, 6\\}$.\n\n2.  **Capability and Impossibility**:\n    *   We define a boolean state variable, `has_capability`, initialized to true if the process is privileged ($p=1$) and false otherwise ($p=0$).\n    *   The problem is deemed impossible if $p=0$, $u=0$ (no USER namespace creation), and any other namespace is requested. In this case, `has_capability` is initially false and there is no way to set it to true, making the creation of steps $\\{2,3,4,5,6\\}$ impossible. The resulting sequence is empty.\n\n3.  **Lexicographically Minimal Topological Sort with Capability Gating**: The algorithm proceeds as follows:\n    *   **Initialization**:\n        *   Calculate the in-degree for each vertex in $V$. The in-degree of a vertex is the number of incoming edges.\n        *   Initialize an empty result sequence, `S`.\n        *   Initialize a min-priority queue, `Q`, to store ready-to-execute steps.\n        *   Initialize a temporary holding list, `W` (waitlist), for steps that are topologically ready (in-degree is $0$) but blocked by the capability requirement.\n    *   **Seeding the Queue**:\n        *   Identify all vertices $v \\in V$ with an in-degree of $0$.\n        *   For each such vertex $v$:\n            *   If $v \\in \\{2, 3, 4, 5, 6\\}$ (a non-USER namespace creation) and `has_capability` is false, add $v$ to the waitlist `W`.\n            *   Otherwise, add $v$ to the priority queue `Q`.\n    *   **Execution Loop**: While `Q` is not empty:\n        *   Extract the vertex $u$ with the minimum value from `Q`.\n        *   Append $u$ to the result sequence `S`.\n        *   If $u=1$ (Create USER), set `has_capability` to true. Move all vertices from the waitlist `W` to the priority queue `Q` and clear `W`. This signifies that the capability has been acquired, and previously blocked steps are now ready.\n        *   For each neighbor $v$ of $u$ (i.e., for each edge $u \\to v$):\n            *   Decrement the in-degree of $v$.\n            *   If the in-degree of $v$ becomes $0$:\n                *   Check the capability constraint for $v$. If $v \\in \\{2, 3, 4, 5, 6\\}$ and `has_capability` is false, add $v$ to `W`.\n                *   Otherwise, add $v$ to `Q`.\n    *   **Termination**: The loop terminates when `Q` is empty. The sequence `S` is the lexicographically minimal valid sequence of steps.\n\nThis algorithm correctly finds the lexicographically smallest topological sort while respecting the dynamic state change of the capability. For a small number of vertices, the min-priority queue can be implemented with a simple array that is scanned for the minimum element at each step.\n\n### Example Walkthrough: Case 1 $(p=0, u=1, pid=1, mnt=1, uts=1, ipc=1, net=1)$\n\n1.  **Vertices**: $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}$.\n2.  **Capability**: `has_capability` is initially false ($p=0$).\n3.  **Edges and In-degrees**:\n    *   $1 \\to \\{2,3,4,5,6\\}$. In-degrees of $\\{2,3,4,5,6\\}$ are $1$.\n    *   $3 \\to 7$, $4 \\to 8$, $6 \\to 9$. In-degrees of $\\{7,8,9\\}$ are $1$.\n    *   $\\{1, \\dots, 9\\} \\to 10$. In-degree of $10$ is $9$.\n    *   The only vertex with an in-degree of $0$ is $1$.\n4.  **Execution**:\n    *   **Init**: `Q = {1}`, `W = {}`. `S = []`.\n    *   **Step 1**: Pop $1$ from `Q`. `S = [1]`. Set `has_capability` to true.\n        *   Decrement in-degrees of $\\{2,3,4,5,6\\}$, which all become $0$.\n        *   Since `has_capability` is now true, add $\\{2,3,4,5,6\\}$ to `Q`. Now `Q = {2,3,4,5,6}`.\n    *   **Step 2**: Pop $2$ from `Q`. `S = [1,2]`. Decrement in-degree of $10$.\n    *   **Step 3**: Pop $3$ from `Q`. `S = [1,2,3]`. Decrement in-degree of $7$. It becomes $0$. Add $7$ to `Q`. `Q = {4,5,6,7}`.\n    *   **Step 4**: Pop $4$ from `Q`. `S = [1,2,3,4]`. Decrement in-degree of $8$. It becomes $0$. Add $8$ to `Q`. `Q = {5,6,7,8}`.\n    *   **Step 5**: Pop $5$ from `Q`. `S = [1,2,3,4,5]`. Decrement in-degree of $10$.\n    *   **Step 6**: Pop $6$ from `Q`. `S = [1,2,3,4,5,6]`. Decrement in-degree of $9$. It becomes $0$. Add $9$ to `Q`. `Q = {7,8,9}`.\n    *   **Steps 7-9**: Pop $7, 8, 9$ in order. `S = [1,2,3,4,5,6,7,8,9]`. After each pop, decrement the in-degree of $10$.\n    *   **Final Step**: After $9$ is processed, the in-degree of $10$ becomes $0$. Add $10$ to `Q`. Pop $10$. `S = [1,2,3,4,5,6,7,8,9,10]`.\n\nThe final computed sequence is $[1,2,3,4,5,6,7,8,9,10]$. This principled approach is applied to all test cases.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h> // Included per specification, though not used.\n#include <stdbool.h> // C23 makes bool a keyword, but for compatibility with older compilers.\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int p; // privilege flag\n    // Namespace request flags (u, pid, mnt, uts, ipc, net)\n    bool namespaces[6];\n} TestCase;\n\n// Helper function to add an edge to the adjacency list representation of the graph\nvoid add_edge(int u, int v, int adj[11][10], int adj_count[11], int in_degree[11]) {\n    adj[u][adj_count[u]++] = v;\n    in_degree[v]++;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {0, {true, true, true, true, true, true}}, // Case 1\n        {0, {false, false, false, true, false, false}},// Case 2\n        {1, {false, false, false, false, false, true}},// Case 3\n        {1, {false, false, false, false, false, false}},// Case 4\n        {1, {false, true, true, true, true, false}},  // Case 5\n        {0, {true, false, false, false, false, false}}, // Case 6\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases][11];\n    int results_len[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        bool u = tc.namespaces[0], pid = tc.namespaces[1], mnt = tc.namespaces[2],\n             uts = tc.namespaces[3], ipc = tc.namespaces[4], net = tc.namespaces[5];\n\n        // 1. Impossibility check\n        if (tc.p == 0 && !u && (pid || mnt || uts || ipc || net)) {\n            results_len[i] = 0;\n            continue;\n        }\n\n        // 2. Determine active steps\n        bool active_steps[11] = {false};\n        int num_active_steps = 0;\n        bool any_ns_requested = false;\n\n        if (u) { active_steps[1] = true; any_ns_requested = true; }\n        if (pid) { active_steps[2] = true; any_ns_requested = true; }\n        if (mnt) { active_steps[3] = active_steps[7] = true; any_ns_requested = true; }\n        if (uts) { active_steps[4] = active_steps[8] = true; any_ns_requested = true; }\n        if (ipc) { active_steps[5] = true; any_ns_requested = true; }\n        if (net) { active_steps[6] = active_steps[9] = true; any_ns_requested = true; }\n        \n        if (any_ns_requested) {\n            active_steps[10] = true;\n        } else {\n             results[i][0] = 10;\n             results_len[i] = 1;\n             continue;\n        }\n        \n        for(int j = 1; j <= 10; ++j) {\n            if (active_steps[j]) num_active_steps++;\n        }\n\n        // 3. Build dependency graph\n        int in_degree[11] = {0};\n        int adj[11][10] = {{0}};\n        int adj_count[11] = {0};\n\n        if (u && any_ns_requested && (pid||mnt||uts||ipc||net)) {\n            if (pid) add_edge(1, 2, adj, adj_count, in_degree);\n            if (mnt) add_edge(1, 3, adj, adj_count, in_degree);\n            if (uts) add_edge(1, 4, adj, adj_count, in_degree);\n            if (ipc) add_edge(1, 5, adj, adj_count, in_degree);\n            if (net) add_edge(1, 6, adj, adj_count, in_degree);\n        }\n        if (mnt) add_edge(3, 7, adj, adj_count, in_degree);\n        if (uts) add_edge(4, 8, adj, adj_count, in_degree);\n        if (net) add_edge(6, 9, adj, adj_count, in_degree);\n        \n        for (int j = 1; j < 10; ++j) {\n            if (active_steps[j]) {\n                add_edge(j, 10, adj, adj_count, in_degree);\n            }\n        }\n        \n        // 4. Lexicographically minimal topological sort\n        results_len[i] = 0;\n        bool has_capability = (tc.p == 1);\n        \n        int pq[11]; int pq_count = 0;\n        int wait_list[11]; int wait_list_count = 0;\n\n        for (int s = 1; s <= 10; s++) {\n            if (active_steps[s] && in_degree[s] == 0) {\n                if (s >= 2 && s <= 6 && !has_capability) {\n                    wait_list[wait_list_count++] = s;\n                } else {\n                    pq[pq_count++] = s;\n                }\n            }\n        }\n\n        while (pq_count > 0) {\n            int min_val = 11, min_idx = -1;\n            for(int k=0; k<pq_count; ++k) {\n                if (pq[k] < min_val) {\n                    min_val = pq[k];\n                    min_idx = k;\n                }\n            }\n            int curr_step = min_val;\n            \n            for (int k = min_idx; k < pq_count - 1; ++k) pq[k] = pq[k+1];\n            pq_count--;\n            \n            results[i][results_len[i]++] = curr_step;\n            \n            if (curr_step == 1) {\n                has_capability = true;\n                for (int k = 0; k < wait_list_count; k++) {\n                    pq[pq_count++] = wait_list[k];\n                }\n                wait_list_count = 0;\n            }\n            \n            for (int k=0; k < adj_count[curr_step]; ++k) {\n                int neighbor = adj[curr_step][k];\n                in_degree[neighbor]--;\n                if (in_degree[neighbor] == 0) {\n                    if (neighbor >= 2 && neighbor <= 6 && !has_capability) {\n                        wait_list[wait_list_count++] = neighbor;\n                    } else {\n                        pq[pq_count++] = neighbor;\n                    }\n                }\n            }\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[\");\n        for (int j = 0; j < results_len[i]; ++j) {\n            printf(\"%d\", results[i][j]);\n            if (j < results_len[i] - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"]\");\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3662442"}]}