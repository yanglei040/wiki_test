{"hands_on_practices": [{"introduction": "Security vulnerabilities often hide in the most fundamental aspects of computing, such as how numbers are represented. This exercise explores the integer overflow vulnerability, a classic bug where a finite counter wraps around to zero, potentially allowing an attacker to evade resource limits. By calculating the conditions for overflow in a legacy system and comparing it to a modern, robust counter design, you will gain a concrete understanding of this common threat and its mitigation [@problem_id:3687968].", "problem": "In an operating system’s resource accounting, suppose the system tracks cumulative Central Processing Unit (CPU) time in microseconds using an unsigned 32-bit counter for legacy code paths. On each process creation event (for example, a fork), the process performs work that consumes a fixed amount of CPU time equal to $u$ microseconds, and the counter is incremented by this amount. Because the counter is unsigned and 32 bits wide, it obeys arithmetic modulo $2^{32}$, so that it wraps to zero upon exceeding $2^{32}-1$. An adversary can attempt to exploit wrap-around to evade threshold-based enforcement if the counter is near its maximum.\n\nAs a mitigation, consider a design that uses a 64-bit monotonic saturating counter that clamps at a configurable alert threshold $\\theta$ and triggers exactly once when the cumulative CPU usage first reaches $\\theta$. Specifically, the 64-bit counter $S$ starts at $S_0=0$ and updates on each fork by $S_{k+1}=\\min(\\theta, S_k+u)$; the alert fires on the first step $n$ such that $S_n=\\theta$.\n\nAssume the following concrete parameter values:\n- Per-fork CPU usage is $u=123{,}457$ microseconds.\n- The current stored value of the 32-bit counter is $C_0=c_0=3{,}500{,}000{,}000$ microseconds.\n- The alert threshold for the 64-bit saturating counter is $\\theta=600{,}000{,}000$ microseconds.\n\nDefine $n_{\\text{wrap}}$ as the smallest nonnegative integer $n$ such that the 32-bit counter wraps at least once when updated by $n$ forks from $C_0$ under modulo-$2^{32}$ addition. Define $n_{\\text{alert}}$ as the smallest nonnegative integer $n$ such that the 64-bit saturating counter reaches the alert threshold $\\theta$ when starting from $0$ and applying $n$ updates of size $u$. Compute the single quantity\n$\nD = n_{\\text{wrap}} - n_{\\text{alert}}.\n$\nProvide your answer as an integer number of forks. No rounding is required.", "solution": "The problem requires the computation of a quantity $D = n_{\\text{wrap}} - n_{\\text{alert}}$, which is the difference between the number of fork events required to trigger a counter wrap-around in a legacy 32-bit system and the number of events required to trigger an alert in a mitigated 64-bit system.\n\nFirst, we analyze the 32-bit unsigned counter. An unsigned 32-bit integer counter has a capacity determined by its bit width. The values it can represent range from $0$ to $2^{32}-1$. The total number of states is $2^{32}$. Arithmetic is performed modulo $2^{32}$. The maximum value of the counter is $2^{32}-1$, and its total range corresponds to a numerical value of $2^{32}$.\nThe value of $2^{32}$ is $4,294,967,296$.\n\nThe problem defines $n_{\\text{wrap}}$ as the smallest non-negative integer $n$ such that the 32-bit counter wraps at least once. The initial value of this counter is given as $C_0 = c_0 = 3,500,000,000$. Each fork event adds a CPU usage of $u = 123,457$ microseconds. After $n$ forks, the total accumulated time is $n \\cdot u$. The new conceptual value of the counter would be $C_0 + n \\cdot u$.\nA wrap-around occurs when this conceptual value meets or exceeds the modulus, $2^{32}$. Therefore, we must find the smallest non-negative integer $n$ that satisfies the inequality:\n$$c_0 + n \\cdot u \\ge 2^{32}$$\nRearranging the inequality to solve for $n$:\n$$n \\cdot u \\ge 2^{32} - c_0$$\n$$n \\ge \\frac{2^{32} - c_0}{u}$$\nSince $n$ must be an integer, $n_{\\text{wrap}}$ is the smallest integer satisfying this condition, which is found by taking the ceiling of the right-hand side.\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{2^{32} - c_0}{u} \\right\\rceil$$\nSubstituting the given values: $c_0 = 3,500,000,000$ and $u = 123,457$.\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{4,294,967,296 - 3,500,000,000}{123,457} \\right\\rceil$$\n$$n_{\\text{wrap}} = \\left\\lceil \\frac{794,967,296}{123,457} \\right\\rceil$$\nPerforming the division:\n$$\\frac{794,967,296}{123,457} \\approx 6440.003386$$\nThe ceiling of this value is the next integer:\n$$n_{\\text{wrap}} = 6441$$\n\nNext, we analyze the 64-bit saturating counter. This counter starts at $S_0 = 0$ and is updated according to the rule $S_{k+1} = \\min(\\theta, S_k + u)$, where $\\theta = 600,000,000$ is the alert threshold.\nThe quantity $n_{\\text{alert}}$ is defined as the smallest non-negative integer $n$ such that the counter reaches the threshold $\\theta$. Before saturation, the value of the counter after $n$ steps is simply the cumulative sum of the increments, which is $n \\cdot u$. The alert is triggered at the first step $n$ where this cumulative sum is greater than or equal to $\\theta$. This gives the inequality:\n$$n \\cdot u \\ge \\theta$$\nSolving for $n$:\n$$n \\ge \\frac{\\theta}{u}$$\nAs before, since $n$ must be an integer, $n_{\\text{alert}}$ is the smallest integer satisfying this condition, which is found by taking the ceiling:\n$$n_{\\text{alert}} = \\left\\lceil \\frac{\\theta}{u} \\right\\rceil$$\nSubstituting the given values: $\\theta = 600,000,000$ and $u = 123,457$.\n$$n_{\\text{alert}} = \\left\\lceil \\frac{600,000,000}{123,457} \\right\\rceil$$\nPerforming the division:\n$$\\frac{600,000,000}{123,457} \\approx 4860.103536$$\nThe ceiling of this value is the next integer:\n$$n_{\\text{alert}} = 4861$$\n\nFinally, we compute the required quantity $D = n_{\\text{wrap}} - n_{\\text{alert}}$.\nUsing the values we have computed for $n_{\\text{wrap}}$ and $n_{\\text{alert}}$:\n$$D = 6441 - 4861$$\n$$D = 1580$$\nThe result represents the difference in the number of forks required to trigger the respective events in the two counter systems.", "answer": "$$\\boxed{1580}$$", "id": "3687968"}, {"introduction": "In a concurrent system, the time gap between checking a permission and using the authorized resource can create a critical security flaw known as a Time-Of-Check to Time-Of-Use (TOCTTOU) vulnerability. An attacker can exploit this window to change the system's state, invalidating the original check. This practice challenges you to analyze a token-based mitigation strategy, forcing you to reason about atomicity, revocation, and the trade-offs involved in designing secure, high-performance systems [@problem_id:3687966].", "problem": "Consider a multi-user operating system in which a device driver for device $D$ authorizes operations using an Access Control List (ACL). A process $P$ performs the open system call on $D$ at time $t_0$, and later issues Input/Output (I/O) operations at times $t_1, t_2, \\ldots$. An administrator may modify the ACL at any time, including between $t_0$ and a later I/O operation. Time-Of-Check To Time-Of-Use (TOCTTOU) vulnerabilities arise whenever authorization is checked and subsequently used non-atomically in the presence of concurrent changes to shared authorization state.\n\nYou are asked to reason from first principles about a proposed mitigation: when $P$ opens $D$ at time $t_0$, the kernel issues an atomic permission token $T$ bound to the open operation. The token $T$ is associated with the identity of $P$, the target device $D$, and a set of rights $R$ determined by the ACL at $t_0$. For each subsequent I/O operation on $D$, $P$ presents $T$ to the kernel, and the kernel validates $T$ and authorizes the operation accordingly within the same system call that performs the device operation.\n\nSelect all statements that are correct about the security properties and trade-offs of this design in the threat landscape described.\n\nA. If $T$ is unforgeable and validated by the kernel immediately before performing the device operation without relinquishing control to untrusted code, the TOCTTOU window between authorization and use is eliminated for those operations that require $T$.\n\nB. The token approach cannot support revocation without reintroducing TOCTTOU and is therefore strictly inferior to holding the ACL under a lock for the entire duration of each device operation.\n\nC. Incorporating a per-device revocation version counter $v$ that the kernel compares against the version embedded in $T$ at each operation supports immediate revocation while keeping the check and use within a single atomic kernel path, at the cost of an additional check per operation.\n\nD. Because $T$ is bound at open time, any subsequent ACL changes that grant additional rights to $P$ are automatically reflected when $P$ uses $T$, which preserves the Principle of Least Privilege.\n\nE. If $T$ is stored in user space and supplied with each call, then without a kernel-enforced integrity mechanism that makes $T$ unforgeable, a malicious process could modify $T$ to escalate privileges; therefore, unforgeability and integrity of $T$ are necessary for the design to be secure.\n\nSelect all that apply.", "solution": "The problem analyzes a token-based authorization mechanism designed to prevent Time-Of-Check to Time-Of-Use (TOCTTOU) vulnerabilities. The key feature is that the token validation and the I/O operation occur within a single, atomic system call. Let's evaluate each statement.\n\n**A. Correct.** A TOCTTOU vulnerability exists in the time window between a check and its corresponding use. By design, this system performs the token validation (the check) and the device operation (the use) within the same atomic kernel-mode execution path. Since control is not returned to untrusted user space between these two steps, an attacker has no opportunity to change the system state (e.g., by getting permissions revoked). This effectively eliminates the TOCTTOU race condition for I/O operations authorized by the token, provided the token is unforgeable and correctly validated by the kernel.\n\n**B. Incorrect.** This statement makes two flawed claims. First, revocation can be implemented without reintroducing TOCTTOU. For example, the kernel can maintain a global revocation list or use a versioning scheme (as described in option C). The check for revocation can be integrated into the same atomic kernel path as the token validation. Second, the proposed alternative of holding a lock on the ACL for the duration of an I/O operation is not \"strictly superior\" due to severe performance implications. Long-held locks create serialization bottlenecks, drastically reducing system throughput. The token approach represents a common trade-off favoring performance and scalability.\n\n**C. Correct.** This describes a standard and robust mechanism for revocation. A version counter is associated with the device's ACL. When a token is created, it's stamped with the current version. When the ACL is changed, the counter is incremented. During an I/O operation, the kernel atomically validates the token's integrity and compares the token's version with the device's current version. If they don't match, the token is stale and rejected. This allows for immediate revocation while preserving the atomicity that prevents TOCTTOU attacks. The cost is a minor overhead of one integer comparison per operation.\n\n**D. Incorrect.** The problem states that the rights $R$ are determined \"at time $t_0$\" (when the device is opened). This means the permissions are fixed, or \"frozen,\" into the token at creation time. Subsequent changes to the ACL that might grant more permissions are not automatically reflected in the existing token. To acquire new rights, the process would need to obtain a new token (e.g., by closing and reopening the device handle). This behavior actually supports the Principle of Least Privilege by not automatically escalating a process's authority during its lifetime.\n\n**E. Correct.** The model implies the token is passed from user space to the kernel for each operation. If the token is stored in user space as a modifiable data structure, a malicious process could alter its contents (e.g., add permissions) before passing it to the kernel. This would completely bypass the security model. Therefore, the token must be unforgeable. This can be achieved by having the kernel manage the token internally (and the user passes a simple handle) or by using a cryptographic mechanism, like a Message Authentication Code (MAC), to protect the token's integrity. Unforgeability is a prerequisite for the entire design's security.", "answer": "$$\\boxed{ACE}$$", "id": "3687966"}, {"introduction": "The Principle of Least Privilege dictates that a user should only be granted the permissions essential to their work, but what does this mean in practice? This exercise delves into the analysis of `sudo` policies, a common mechanism for granting elevated rights on Unix-like systems. You will learn to identify how seemingly limited commands can be abused to gain full root access, providing a powerful lesson in the dangers of overly permissive configurations and the subtlety of privilege escalation [@problem_id:3687915].", "problem": "An advanced user in an Operating System (OS) is granted selective elevated privileges via the `sudo` policy in a system that enforces command-level access control using an argument-matching pattern language. Consider the following threat assessment task, grounded in the principle of least privilege and the definition of trust boundaries: a user’s effective privilege set $P$ is determined by which commands they can invoke as the superuser and how those commands can be composed. Root-level capability, denoted $R$, represents the superset of actions a superuser can perform. By first principles, if a permitted command enables arbitrary code execution or arbitrary write to trusted system state, then such permission crosses the trust boundary and yields $P \\approx R$ (root-equivalent), because the user can construct arbitrary workflows that realize any root capability.\n\nA static analyzer is proposed for `sudo` rules with wildcards to detect patterns equivalent to full root and to compute a privilege dilution score $D$. The analyzer uses the following foundational model:\n- Privilege is modeled by capability categories $C = \\{c_1, c_2, c_3, c_4, c_5\\}$, where $c_1$ is arbitrary code execution, $c_2$ is arbitrary write to system files, $c_3$ is arbitrary read of system files, $c_4$ is service control (e.g., starting/stopping services), and $c_5$ is system configuration changes (e.g., package or network configuration). Full root has all categories, so the superuser capability set corresponds to $R$ that covers all of $C$. The analyzer defines the privilege dilution score as $D = \\frac{|C_{\\text{reachable}}|}{|C|}$, where $C_{\\text{reachable}} \\subseteq C$ is the set of categories the user can reach via permitted commands. Under the closure principle, if $c_1 \\in C_{\\text{reachable}}$, then composing arbitrary code execution yields all categories in $C$, and thus $D = 1$.\n- The analyzer flags as root-equivalent any rule that allows the user to trigger arbitrary code execution, including but not limited to shells, interpreters, editors with shell escape, or utilities whose options embed command execution.\n\nSuppose the `sudo` policy encodes rules as pairs $(p, A)$, where $p$ is an absolute command path and $A$ is a pattern over the argument vector, with the wildcard symbol `*` matching any single argument token (including options, flags, and values):\n\n- Rule $r_1$: $p = \\text{`/usr/bin/find`}$, $A = \\text{['/var', '*', '-exec', '/bin/sh', '-c', '*']}$. This permits running `find` over `/var` with arbitrary predicates and then executing `/bin/sh -c …` with arbitrary command content.\n- Rule $r_2$: $p = \\text{`/usr/bin/vim`}$, $A = \\text{['/etc/*']}$. This permits running `vim` as root to edit any file under `/etc` with interactive features intact.\n- Rule $r_3$: $p = \\text{`/bin/tar`}$, $A = \\text{['*']}$. This permits running `tar` with any arguments.\n- Rule $r_4$: $p = \\text{`/usr/bin/systemctl`}$, $A = \\text{['restart', 'myservice']}$. This permits restarting a single named service.\n\nAssume a conventional environment in which `/usr/bin/vim` allows shell escape (e.g., using `:!`), `/bin/tar` supports an option to execute a command at checkpoint (e.g., `--checkpoint-action=exec=…`), and `/usr/bin/find` with `-exec /bin/sh -c …` executes arbitrary code. Using the analyzer’s model above and reasoning strictly from the principle of least privilege and trust boundary semantics, select the correct assessment of which rules are equivalent to full root and the resulting $D$ for the user.\n\n- A. The analyzer flags $r_1$, $r_2$, and $r_3$ as root-equivalent; $D = 1$.\n\n- B. The analyzer flags only $r_2$ as root-equivalent; $D = \\frac{3}{5}$.\n\n- C. The analyzer flags no rules as root-equivalent; $D = \\frac{1}{5}$.\n\n- D. The analyzer flags $r_1$ and $r_2$ as root-equivalent but not $r_3$; $D = \\frac{4}{5}$.", "solution": "The problem requires analyzing four `sudo` rules using a formal model to determine which are \"root-equivalent\" and to calculate the user's privilege dilution score, $D$. A rule is root-equivalent if it grants capability $c_1$ (arbitrary code execution). If $c_1$ is granted, the closure principle states that all other capabilities become reachable, and $D=1$.\n\n**Analysis of Rule $r_1$:** `sudo /usr/bin/find /var * -exec /bin/sh -c *`\nThis rule allows the user to execute `/usr/bin/find` and, via the `-exec` primary, run `/bin/sh -c` with an arbitrary command string provided by the user (matching the final wildcard `*`). This is a direct mechanism for arbitrary code execution as the root user. Thus, this rule grants capability $c_1$ and is **root-equivalent**.\n\n**Analysis of Rule $r_2$:** `sudo /usr/bin/vim /etc/*`\nThis rule allows the user to run the `vim` editor as root on any file in `/etc`. The problem explicitly states that `vim` allows shell escapes (e.g., via `:!`). A user can open any file (e.g., `sudo vim /etc/hosts`) and then type `:!/bin/sh` to gain an interactive root shell. This constitutes arbitrary code execution. Thus, this rule grants capability $c_1$ and is **root-equivalent**.\n\n**Analysis of Rule $r_3$:** `sudo /bin/tar *`\nThis rule allows the user to run `tar` as root with any arguments. The problem states that `tar` supports an option for command execution at checkpoints (e.g., `--checkpoint-action=exec=...`). A user can craft a command like `sudo tar --checkpoint=1 --checkpoint-action='exec=/bin/sh' -cf /dev/null /dev/null` to execute a shell as root. This is a known technique for privilege escalation using `tar`. Thus, this rule grants capability $c_1$ and is **root-equivalent**.\n\n**Analysis of Rule $r_4$:** `sudo /usr/bin/systemctl restart myservice`\nThis rule is highly constrained. It only allows the `restart` subcommand on a single, specific service, `myservice`. It does not provide a mechanism for arbitrary code execution, file manipulation, or other general capabilities. It only grants capability $c_4$ (service control). This rule is **not root-equivalent**.\n\n**Conclusion and Score Calculation:**\nRules $r_1$, $r_2$, and $r_3$ all grant capability $c_1$ (arbitrary code execution) and are therefore flagged as root-equivalent by the analyzer. Since $c_1$ is in the set of reachable capabilities ($C_{\\text{reachable}}$), the closure principle applies: \"if $c_1 \\in C_{\\text{reachable}}$, then ... $D = 1$.\"\nTherefore, the user has access to full root capabilities, and the privilege dilution score is $D=1$.\n\nThis matches the conclusions of option A.", "answer": "$$\\boxed{A}$$", "id": "3687915"}]}