{"hands_on_practices": [{"introduction": "This practice explores a critical, low-level implementation detail of stride scheduling. While the high-level concept of selecting the process with the minimum `pass` value is simple, this breaks down when `pass` accumulators are stored in finite-width integers that can wrap around. This exercise [@problem_id:3673643] will challenge you to identify why a naive comparison fails and to recognize the correct, modulo-safe comparison logic that ensures fairness even in the face of integer overflow.", "problem": "An Operating System (OS) uses a proportional-share scheduler on a single Central Processing Unit (CPU) that implements stride scheduling. Each process $i$ has a fixed positive integer stride $s_i$ and a non-decreasing accumulator $pass_i$ that is incremented by $s_i$ each time the process runs. At each selection step, the scheduler chooses the process whose $pass_i$ is minimal among all ready processes, then runs it for one time slice and updates its $pass_i := pass_i + s_i$. The accumulator $pass_i$ is stored in an $N$-bit unsigned integer and thus evolves under modular arithmetic with modulus $2^N$.\n\nFoundational facts:\n- Proportional-share fairness is achieved by selecting the process with the minimal aggregate service measure $pass_i$, because lower $pass_i$ indicates less service delivered so far on the scheduler’s scaled axis.\n- Fixed-width machine integers perform arithmetic modulo $2^N$: for any integers $x, y$, the machine-level sum is $(x + y) \\bmod 2^N$.\n\nConsider $N = 8$, so arithmetic is modulo $2^8 = 256$. Three processes $P_1, P_2, P_3$ have strides $s_1 = 60$, $s_2 = 30$, $s_3 = 20$. Immediately before a selection step, the accumulators are\n$$pass_1 = 240,\\quad pass_2 = 250,\\quad pass_3 = 245.$$\nSuppose the system had just scheduled $P_1$ in the previous step and updated $pass_1 := pass_1 + s_1$. Because $N = 8$, this update is\n$$pass_1 := (240 + 60) \\bmod 256 = 300 \\bmod 256 = 44.$$\nThus the state at the current selection step is\n$$pass_1 = 44,\\quad pass_2 = 250,\\quad pass_3 = 245.$$\n\nFrom first principles:\n- The intended order is the order of the true (conceptual) non-modular $pass$ values, but the machine stores only the residues modulo $2^N$.\n- A naive unsigned comparison that directly orders residues by the usual less-than on $\\{0,1,\\dots,2^N-1\\}$ can misorder values near wraparound and bias the scheduler, because a large true value just past the wrap (e.g., $300$) appears numerically small (e.g., $44$). Any correct comparison must respect modular arithmetic and two’s-complement representation in such a way that it reproduces the intended order of the underlying non-modular $pass$ values whenever pairwise differences are within the half-range.\n\nAssume the system is configured such that for any two concurrently ready processes $i$ and $j$, the true (non-modular) difference of their $pass$ values lies in $(-2^{N-1}, 2^{N-1})$, which is satisfied here because no single increment exceeds $2^{N-1}$ and updates occur frequently.\n\nWhich of the following option(s) both correctly address wraparound bias and, under the given state, identify the next process selected by a modulo-safe minimum comparator? Select all that apply.\n\nA. Use the usual unsigned less-than on $\\{0,\\dots,2^N-1\\}$: pick the process with the numerically smallest stored $pass_i$. Under the given state, this selects $P_1$ because $44$ is the smallest.\n\nB. Define the comparison $a \\prec b$ by computing $d := (a - b) \\bmod 2^N$ and interpreting $d$ as a signed two’s-complement integer in $\\{-2^{N-1},\\dots,2^{N-1}-1\\}$. Then $a \\prec b$ if and only if $d < 0$. Under the given state, this selects $P_3$.\n\nC. Define $a \\prec b$ if and only if the unsigned difference $(a - b)$ is less than $2^{N-1}$. Under the given state, this selects $P_1$.\n\nD. Eliminate wraparound by resetting all $pass_i := 0$ when any addition overflows, since lower values mean less service. Under the given state, the next selection should be the process with the smallest stride (i.e., $P_3$).\n\nE. Equivalently to a signed comparison, shift the origin by $2^{N-1}$: define $a \\prec b$ if and only if $((a + 2^{N-1}) \\bmod 2^N) < ((b + 2^{N-1}) \\bmod 2^N)$ using unsigned less-than. Under the given state, this selects $P_3$.", "solution": "We begin from core definitions of proportional-share stride scheduling and modular arithmetic on fixed-width integers.\n\n1. Proportional-share stride scheduling:\n- Each process $i$ has a stride $s_i \\in \\mathbb{N}$ and an accumulator $pass_i \\in \\mathbb{Z}$ conceptualizing total scaled service.\n- The scheduler selects the process with minimal $pass_i$, runs it for one slice, then sets $pass_i := pass_i + s_i$.\n- This mechanism yields allocations proportional to $1/s_i$ because smaller stride implies more frequent selection to keep $pass$ values close.\n\n2. Fixed-width integer arithmetic:\n- On hardware, $pass_i$ is stored as an $N$-bit unsigned integer, so all updates are computed modulo $2^N$.\n- Thus, for any update $pass_i := pass_i + s_i$, the stored value becomes $(pass_i + s_i) \\bmod 2^N$.\n- The set of stored values is the residue class ring $\\mathbb{Z}_{2^N}$.\n\n3. Ordering challenge at wraparound:\n- The intended schedule must order the conceptual, non-modular $pass$ values to find the minimum.\n- However, comparing residues naively can misorder values near wrap. For example, a conceptual value $300$ is stored as $44$ when $N=8$, since $300 \\equiv 44 \\pmod{256}$. Directly comparing $44$ and $250$ as unsigned numbers incorrectly claims $44$ is smaller, even though $300 > 250$ in the non-modular sense.\n\n4. A modulo-safe comparator:\n- In two’s-complement arithmetic, signed integers represent residues $\\{0,\\dots,2^{N-1}-1\\}$ as non-negative and $\\{2^{N-1},\\dots,2^N-1\\}$ as negative values offset by $2^N$.\n- For two residues $a, b \\in \\mathbb{Z}_{2^N}$ that encode conceptual values whose true difference $(a - b)_{\\text{true}}$ lies in $(-2^{N-1}, 2^{N-1})$, the signed two’s-complement interpretation of $d := (a - b) \\bmod 2^N$ recovers the sign of $(a - b)_{\\text{true}}$:\n  - If $(a - b)_{\\text{true}} > 0$, then $d \\in \\{1,\\dots,2^{N-1}-1\\}$, which as signed is $d > 0$.\n  - If $(a - b)_{\\text{true}} < 0$, then $d \\in \\{2^{N-1}+1,\\dots,2^N-1\\}$, which as signed is $d - 2^N < 0$.\n- Therefore, defining $a \\prec b$ if and only if the signed interpretation of $d$ is negative reproduces the correct order of the non-modular values within the half-range window. Equivalently, adding $2^{N-1}$ to both operands and comparing as unsigned realizes the same signed ordering, because adding $2^{N-1}$ rotates the circle so that the sign bit becomes the most significant bit that flips order appropriately.\n\nApplying these principles to the given state:\n- The state after the prior update is $pass_1 = 44$, $pass_2 = 250$, $pass_3 = 245$, with the conceptual non-modular values being $pass_1^{\\ast} = 300$, $pass_2^{\\ast} = 250$, $pass_3^{\\ast} = 245$ (for the current epoch). The intended minimum is $pass_3^{\\ast} = 245$, because $245 < 250 < 300$.\n\nLet us test each option.\n\nOption A:\n- Proposal: use unsigned less-than on residues. Under this rule, we compare $44$, $250$, $245$ directly and pick $44$ (i.e., $P_1$).\n- Analysis: This contradicts the intended order, because $pass_1^{\\ast} = 300$ is larger than both $250$ and $245$. Wraparound causes $300 \\equiv 44 \\pmod{256}$, and the naive comparator sees $44$ as the smallest, which biases selection toward recently wrapped accumulators.\n- Verdict: Incorrect. It demonstrates the biased behavior rather than correcting it, and the chosen process $P_1$ is not the correct minimal under the intended conceptual order.\n\nOption B:\n- Proposal: compute $d := (a - b) \\bmod 2^N$ and interpret $d$ as signed; declare $a \\prec b$ iff $d < 0$.\n- First, compare $pass_1$ and $pass_2$: $d = (44 - 250) \\bmod 256 = (-206) \\bmod 256 = 50$. As an $8$-bit signed integer, $50$ is positive, so $pass_1 \\succ pass_2$ (i.e., $pass_1$ is larger).\n- Next, compare $pass_2$ and $pass_3$: $d = (250 - 245) \\bmod 256 = 5$, signed positive, so $pass_2 \\succ pass_3$.\n- Consequently, $pass_3$ is minimal, and the scheduler selects $P_3$.\n- This matches the conceptual minima: $245 < 250 < 300$, and all pairwise differences ($60$, $5$, $55$) lie within the half-range $(-128, 128)$.\n- Verdict: Correct. The comparator is modulo-safe and yields the correct next selection $P_3$.\n\nOption C:\n- Proposal: $a \\prec b$ iff the unsigned difference $(a - b)$ is less than $2^{N-1}$.\n- Test $pass_1$ vs $pass_2$: Compute $(a - b)$ as unsigned, $(44 - 250) \\bmod 256 = 50$, which is less than $128$, so the rule declares $44 \\prec 250$ and would favor $P_1$ as smaller than $P_2$.\n- But the conceptual order has $300 > 250$, so $P_1$ should not be considered smaller than $P_2$.\n- This formulation flips the desired relation for differences that are within the half-range. The condition $(a - b) < 2^{N-1}$ characterizes proximity, not order direction; it cannot distinguish whether $a$ is before or after $b$ in the linearized order without considering the sign.\n- Verdict: Incorrect. The criterion misclassifies the direction and selects $P_1$, which is wrong.\n\nOption D:\n- Proposal: reset all $pass_i := 0$ on overflow to avoid wrap complications, and then select by smallest stride.\n- Analysis: Resetting accumulators discards the history of service and thus destroys proportional-share fairness. The scheduler should not select by smallest stride; it should select by minimal $pass_i$ to preserve the invariant that accumulated service balances across processes according to their shares. Moreover, resetting all $pass_i$ to $0$ would create artificial ties and biases unrelated to the true service delivered. Even if one tried to reconstruct an order from stride magnitudes, that does not correspond to least service and would drive the system away from fair proportions.\n- Verdict: Incorrect. The proposed mechanism is not modulo-safe, violates first principles of stride scheduling, and the asserted next selection based on smallest stride is unfounded.\n\nOption E:\n- Proposal: shift both operands by $2^{N-1}$ and compare as unsigned: $a \\prec b$ iff $((a + 2^{N-1}) \\bmod 2^N) < ((b + 2^{N-1}) \\bmod 2^N)$.\n- This is equivalent to a signed comparison because adding $2^{N-1}$ maps the signed range $\\{-2^{N-1},\\dots,2^{N-1}-1\\}$ to the unsigned range $\\{0,\\dots,2^N-1\\}$ while preserving order.\n- Compute transformed values: for $N=8$, $2^{N-1} = 128$. We get\n  $$f(pass_1) = (44 + 128) \\bmod 256 = 172,$$\n  $$f(pass_2) = (250 + 128) \\bmod 256 = 378 \\bmod 256 = 122,$$\n  $$f(pass_3) = (245 + 128) \\bmod 256 = 373 \\bmod 256 = 117.$$\n- Comparing $f(pass_i)$ as unsigned yields $117 < 122 < 172$, so the minimal is $f(pass_3)$, hence $pass_3$ is minimal and $P_3$ is selected.\n- This matches the result from Option B and the conceptual minima.\n- Verdict: Correct. The method is modulo-safe and selects $P_3$.\n\nConclusion:\n- Options B and E are correct because they express modulo-safe comparisons that respect two’s-complement arithmetic and correctly identify $P_3$ as the next process. Options A, C, and D are incorrect: A illustrates the bias, C confuses magnitude with order direction, and D breaks the fairness principle by discarding accumulated service.", "answer": "$$\\boxed{BE}$$", "id": "3673643"}, {"introduction": "Building on the fundamentals of stride scheduling, this exercise extends the concept to a hierarchical system, a common design in modern operating systems for managing resources among groups of processes. You will simulate a two-level scheduler where control groups (cgroups) compete for the CPU, and tasks within each group compete for the group's allocated time. This practice [@problem_id:3673648] will solidify your understanding of how proportional shares are enforced across a nested hierarchy by methodically tracking `pass` and `stride` values at each level.", "problem": "Consider a single Central Processing Unit (CPU) running a hierarchical proportional-share scheduler. Two control groups (cgroups) $G_{1}$ and $G_{2}$ contend for the CPU; within each cgroup, tasks contend according to their per-task shares. The scheduler uses hierarchical stride scheduling to implement proportional sharing. At the cgroup level, the scheduler maintains a per-cgroup pass value and a per-cgroup stride. At each scheduling decision, it selects the cgroup with the smallest pass value (ties break in favor of the lower numerical cgroup index), then increments that cgroup’s pass by its stride. Within the selected cgroup, the scheduler maintains per-task pass values and per-task strides, selects the task with the smallest pass (ties break in favor of the lower numerical task index), and then increments that task’s pass by its stride. All pass values start at $0$.\n\nYou are given the following configuration:\n- Cgroup shares: $S_{G_{1}} = 3$, $S_{G_{2}} = 2$.\n- Per-task shares in $G_{1}$: task $T_{1}$ has $s_{1} = 2$, task $T_{2}$ has $s_{2} = 1$.\n- Per-task shares in $G_{2}$: task $T_{3}$ has $s_{3} = 1$, task $T_{4}$ has $s_{4} = 3$.\n\nThe hierarchical stride scheduling uses the following stride constants:\n- Global constant $K = 30$ for cgroups, yielding the cgroup strides $\\text{stride}(G_{i}) = \\frac{K}{S_{G_{i}}}$.\n- Cgroup-local constants $K_{1} = 12$ for $G_{1}$ and $K_{2} = 12$ for $G_{2}$, yielding per-task strides within each cgroup as $\\text{stride}(T_{j}) = \\frac{K_{g}}{s_{j}}$ where $K_{g}$ is the constant for the cgroup containing task $T_{j}$.\n\nThe global identifiers of tasks are defined as follows: $T_{1}$ has identifier $1$, $T_{2}$ has identifier $2$, $T_{3}$ has identifier $3$, and $T_{4}$ has identifier $4$.\n\nStarting from all pass values equal to $0$, compute the global identifier (an integer) of the task that is selected at the $11$-th scheduling decision. No rounding is required; provide the final integer identifier.", "solution": "The problem requires the determination of the task scheduled at the $11$-th decision point by a hierarchical proportional-share scheduler. The scheduling discipline is specified as hierarchical stride scheduling. The process is deterministic, governed by pass values and strides for both control groups (cgroups) and individual tasks.\n\nFirst, we must compute the stride values for all schedulable entities. The stride is inversely proportional to the share, calculated using a provided constant.\n\nThe cgroup shares are $S_{G_{1}} = 3$ and $S_{G_{2}} = 2$. The global constant for cgroups is $K = 30$. The stride for each cgroup, $\\text{stride}(G_i)$, is given by $\\frac{K}{S_{G_i}}$.\nThe stride for cgroup $G_1$ is:\n$$ \\text{stride}(G_{1}) = \\frac{K}{S_{G_{1}}} = \\frac{30}{3} = 10 $$\nThe stride for cgroup $G_2$ is:\n$$ \\text{stride}(G_{2}) = \\frac{K}{S_{G_{2}}} = \\frac{30}{2} = 15 $$\n\nNext, we compute the strides for the tasks within each cgroup.\nFor cgroup $G_1$, the tasks are $T_1$ with share $s_1 = 2$ and $T_2$ with share $s_2 = 1$. The cgroup-local constant is $K_1 = 12$. The stride for a task $T_j$ in this group is $\\frac{K_1}{s_j}$.\nThe stride for task $T_1$ is:\n$$ \\text{stride}(T_{1}) = \\frac{K_1}{s_{1}} = \\frac{12}{2} = 6 $$\nThe stride for task $T_2$ is:\n$$ \\text{stride}(T_{2}) = \\frac{K_1}{s_{2}} = \\frac{12}{1} = 12 $$\n\nFor cgroup $G_2$, the tasks are $T_3$ with share $s_3 = 1$ and $T_4$ with share $s_4 = 3$. The cgroup-local constant is $K_2 = 12$. The stride for a task $T_j$ in this group is $\\frac{K_2}{s_j}$.\nThe stride for task $T_3$ is:\n$$ \\text{stride}(T_{3}) = \\frac{K_2}{s_{3}} = \\frac{12}{1} = 12 $$\nThe stride for task $T_4$ is:\n$$ \\text{stride}(T_{4}) = \\frac{K_2}{s_{4}} = \\frac{12}{3} = 4 $$\n\nThe initial pass values for all cgroups and tasks are $0$. Let $P(X)$ denote the pass value of entity $X$.\nInitial state: $P(G_1) = 0$, $P(G_2) = 0$, $P(T_1) = 0$, $P(T_2) = 0$, $P(T_3) = 0$, $P(T_4) = 0$.\nWe now simulate the scheduling process for $11$ steps.\n\nStep $1$:\n- Cgroup selection: $P(G_1) = 0$ and $P(G_2) = 0$. Tie is broken by lower index, so $G_1$ is selected.\n- Task selection (in $G_1$): $P(T_1) = 0$ and $P(T_2) = 0$. Tie is broken by lower index, so $T_1$ is selected.\n- Scheduled: $T_1$.\n- Update pass values: $P(T_1) \\leftarrow P(T_1) + \\text{stride}(T_1) = 0 + 6 = 6$. $P(G_1) \\leftarrow P(G_1) + \\text{stride}(G_1) = 0 + 10 = 10$.\n\nStep $2$:\n- Cgroup selection: $P(G_1) = 10$, $P(G_2) = 0$. Select $G_2$.\n- Task selection (in $G_2$): $P(T_3) = 0$, $P(T_4) = 0$. Tie, select $T_3$.\n- Scheduled: $T_3$.\n- Update pass values: $P(T_3) \\leftarrow 0 + 12 = 12$. $P(G_2) \\leftarrow 0 + 15 = 15$.\n\nStep $3$:\n- Cgroup selection: $P(G_1) = 10$, $P(G_2) = 15$. Select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 6$, $P(T_2) = 0$. Select $T_2$.\n- Scheduled: $T_2$.\n- Update pass values: $P(T_2) \\leftarrow 0 + 12 = 12$. $P(G_1) \\leftarrow 10 + 10 = 20$.\n\nStep $4$:\n- Cgroup selection: $P(G_1) = 20$, $P(G_2) = 15$. Select $G_2$.\n- Task selection (in $G_2$): $P(T_3) = 12$, $P(T_4) = 0$. Select $T_4$.\n- Scheduled: $T_4$.\n- Update pass values: $P(T_4) \\leftarrow 0 + 4 = 4$. $P(G_2) \\leftarrow 15 + 15 = 30$.\n\nStep $5$:\n- Cgroup selection: $P(G_1) = 20$, $P(G_2) = 30$. Select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 6$, $P(T_2) = 12$. Select $T_1$.\n- Scheduled: $T_1$.\n- Update pass values: $P(T_1) \\leftarrow 6 + 6 = 12$. $P(G_1) \\leftarrow 20 + 10 = 30$.\n\nStep $6$:\n- Cgroup selection: $P(G_1) = 30$, $P(G_2) = 30$. Tie, select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 12$, $P(T_2) = 12$. Tie, select $T_1$.\n- Scheduled: $T_1$.\n- Update pass values: $P(T_1) \\leftarrow 12 + 6 = 18$. $P(G_1) \\leftarrow 30 + 10 = 40$.\n\nStep $7$:\n- Cgroup selection: $P(G_1) = 40$, $P(G_2) = 30$. Select $G_2$.\n- Task selection (in $G_2$): $P(T_3) = 12$, $P(T_4) = 4$. Select $T_4$.\n- Scheduled: $T_4$.\n- Update pass values: $P(T_4) \\leftarrow 4 + 4 = 8$. $P(G_2) \\leftarrow 30 + 15 = 45$.\n\nStep $8$:\n- Cgroup selection: $P(G_1) = 40$, $P(G_2) = 45$. Select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 18$, $P(T_2) = 12$. Select $T_2$.\n- Scheduled: $T_2$.\n- Update pass values: $P(T_2) \\leftarrow 12 + 12 = 24$. $P(G_1) \\leftarrow 40 + 10 = 50$.\n\nStep $9$:\n- Cgroup selection: $P(G_1) = 50$, $P(G_2) = 45$. Select $G_2$.\n- Task selection (in $G_2$): $P(T_3) = 12$, $P(T_4) = 8$. Select $T_4$.\n- Scheduled: $T_4$.\n- Update pass values: $P(T_4) \\leftarrow 8 + 4 = 12$. $P(G_2) \\leftarrow 45 + 15 = 60$.\n\nStep $10$:\n- Cgroup selection: $P(G_1) = 50$, $P(G_2) = 60$. Select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 18$, $P(T_2) = 24$. Select $T_1$.\n- Scheduled: $T_1$.\n- Update pass values: $P(T_1) \\leftarrow 18 + 6 = 24$. $P(G_1) \\leftarrow 50 + 10 = 60$.\n\nStep $11$:\n- Cgroup selection: $P(G_1) = 60$, $P(G_2) = 60$. Tie, select $G_1$.\n- Task selection (in $G_1$): $P(T_1) = 24$, $P(T_2) = 24$. Tie, select $T_1$.\n- Scheduled: $T_1$.\n\nThe task selected at the $11$-th scheduling decision is $T_1$. The problem asks for the global identifier of this task. The identifier for $T_1$ is given as $1$.", "answer": "$$ \\boxed{1} $$", "id": "3673648"}, {"introduction": "Even the most sophisticated schedulers can exhibit surprising behavior under certain conditions. This exercise examines a pathological case within the Completely Fair Scheduler (CFS), which uses virtual runtime ($v_i$) to approximate ideal proportional sharing. You will analyze how the interaction between task weights and a practical optimization—the minimum execution granularity ($g$)—can lead to a \"convoy\" of high-weight tasks that temporarily starves a low-weight task [@problem_id:3673701]. This reveals the inherent trade-offs between fairness, latency, and system throughput in scheduler design.", "problem": "Consider a single-core system running the Completely Fair Scheduler (CFS). All tasks are continuously runnable. The scheduler maintains for each task a virtual runtime $v_i$ that increases proportionally to the task’s actual running time scaled by the inverse of its weight: when task $i$ runs for wall-clock time $\\Delta t$, its virtual runtime increases by $\\Delta v_i = \\Delta t \\cdot \\frac{1}{w_i}$. At each scheduling decision, the task with the smallest $v_i$ is chosen to run next. CFS enforces a minimum per-dispatch execution time, called the minimum granularity, so that any chosen task runs for at least $g$ wall-clock time before the scheduler considers a different task.\n\nConstruct a pathological scenario with $M$ high-weight tasks and a single low-weight task such that the low-weight task does not receive any CPU within a short measurement window because the minimum granularity causes long rotations among the high-weight tasks. Specifically, suppose there are $M = 251$ high-weight tasks, each with weight $w_H = 10$, and one low-weight task with weight $w_L = 1$. The minimum granularity is $g = 4 \\text{ ms}$. Assume that at wall-clock time $t = 0$, all tasks have equal virtual runtime $v_0$, and the low-weight task is selected first by tie-breaking to run for the minimum granularity $g$. After this, the scheduler proceeds to select among the high-weight tasks according to the CFS rule described.\n\nUnder these conditions, derive from first principles the worst-case wall-clock time until the low-weight task is scheduled again. Ignore context-switch costs and assume no external interruptions. Express your final answer in seconds and round your numerical result to four significant figures.", "solution": "The problem asks for the worst-case time until a low-weight task is scheduled again after an initial run. We are given a system with $M = 251$ high-weight tasks, each with weight $w_H = 10$, and one low-weight task with weight $w_L = 1$. The minimum granularity is $g = 4 \\text{ ms}$.\n\nLet $v_L(t)$ be the virtual runtime of the low-weight task at wall-clock time $t$, and let $v_{H_j}(t)$ be the virtual runtime of the $j$-th high-weight task, for $j \\in \\{1, 2, \\dots, M\\}$.\n\nAt the initial time $t=0$, all tasks have an equal virtual runtime, which we can denote as $v_0$.\n$$v_L(0) = v_{H_j}(0) = v_0 \\quad \\text{for all } j \\in \\{1, \\dots, M\\}$$\n\nAccording to the problem, the low-weight task $L$ is selected first by tie-breaking and runs for the minimum granularity $g$. The duration of this run is $\\Delta t = g$. The wall-clock time at the end of this run is $t_1 = g$. The virtual runtime of task $L$ increases according to the given rule:\n$$\\Delta v_L = \\Delta t \\cdot \\frac{1}{w_L} = g \\cdot \\frac{1}{w_L}$$\nSo, the virtual runtime of the low-weight task at time $t_1 = g$ is:\n$$v_L(g) = v_L(0) + \\frac{g}{w_L} = v_0 + \\frac{g}{w_L}$$\nThe virtual runtimes of the high-weight tasks do not change during this interval, as they have not run.\n$$v_{H_j}(g) = v_{H_j}(0) = v_0$$\n\nAt time $t=g$, the scheduler must select the next task. The task with the minimum virtual runtime is chosen. Comparing the virtual runtimes:\n$$v_L(g) = v_0 + \\frac{g}{w_L} = v_0 + \\frac{g}{1} = v_0 + g$$\n$$v_{H_j}(g) = v_0$$\nSince $g > 0$, we have $v_{H_j}(g) < v_L(g)$. Therefore, the scheduler will select one of the high-weight tasks. All $M$ high-weight tasks have the same minimum virtual runtime, so the scheduler will choose one of them, say $H_1$, by some tie-breaking rule.\n\nTask $H_1$ runs for at least the minimum granularity $g$. Let's assume it runs for a duration of exactly $g$. After this run, its virtual runtime becomes:\n$$v_{H_1} \\to v_0 + \\frac{g}{w_H}$$\nAt this point, the other $M-1$ high-weight tasks still have a virtual runtime of $v_0$, which is now the minimum in the system. The scheduler will thus pick another high-weight task, say $H_2$. This process repeats. This creates a \"convoy\" or \"platoon\" effect where the scheduler cycles through all $M$ high-weight tasks in a round-robin fashion, with each task running for the minimum granularity $g$. This constitutes the worst-case scenario for the low-weight task, as the high-weight tasks collectively monopolize the CPU.\n\nOne full rotation through all $M$ high-weight tasks takes a total wall-clock time of $M \\cdot g$. After one such rotation, each high-weight task has run for a duration $g$. Their virtual runtimes will all be equal:\n$$v_H(\\text{after 1 rot}) = v_0 + \\frac{g}{w_H}$$\nThe low-weight task's virtual runtime is still $v_L = v_0 + g/w_L$. Since $w_H > w_L$, we have $g/w_H < g/w_L$, which implies $v_H < v_L$. The scheduler will therefore begin another rotation of the high-weight tasks.\n\nThis cycle will continue. The high-weight tasks will keep being scheduled as long as their virtual runtime is less than that of the low-weight task. Let $k$ be the number of full rotations performed by the group of high-weight tasks. After $k$ rotations, each high-weight task has run a total of $k$ times for duration $g$ each. Their virtual runtime will be:\n$$v_{H}^{(k)} = v_0 + k \\cdot \\frac{g}{w_H}$$\nThe virtual runtime of the low-weight task remains unchanged since its initial run:\n$$v_L = v_0 + \\frac{g}{w_L}$$\nThe low-weight task will be considered for scheduling again only when its virtual runtime is no longer greater than the minimum virtual runtime in the system. This will happen when $v_{H}^{(k)}$ \"catches up\" to $v_L$. The condition for task $L$ to be eligible is $v_L \\le v_{H}^{(k)}$. We need to find the smallest integer $k$ that satisfies this inequality:\n$$v_0 + \\frac{g}{w_L} \\le v_0 + k \\cdot \\frac{g}{w_H}$$\nSubtracting $v_0$ from both sides and dividing by the positive constant $g$:\n$$\\frac{1}{w_L} \\le k \\cdot \\frac{1}{w_H}$$\n$$k \\ge \\frac{w_H}{w_L}$$\nSubstituting the given weights, $w_H=10$ and $w_L=1$:\n$$k \\ge \\frac{10}{1} \\implies k \\ge 10$$\nThe smallest integer number of rotations required is $k=10$.\n\nThe total wall-clock time, $T$, until the low-weight task is scheduled again is the sum of the time for the initial run of task $L$ and the time for the $k$ rotations of the $M$ high-weight tasks.\n$$T = (\\text{initial run of } L) + k \\times (\\text{time for one rotation of } H \\text{ tasks})$$\nThe time for one rotation is $M \\cdot g$.\n$$T = g + k \\cdot M \\cdot g = g(1 + kM)$$\nNow, we substitute the numerical values:\n$g = 4 \\text{ ms} = 4 \\times 10^{-3} \\text{ s}$\n$M = 251$\n$k = 10$\n\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (1 + (10) \\cdot (251))$$\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (1 + 2510)$$\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (2511)$$\n$$T = 10044 \\times 10^{-3} \\text{ s}$$\n$$T = 10.044 \\text{ s}$$\nThe problem requires the answer to be rounded to four significant figures. The number $10.044$ rounded to four significant figures is $10.04$.", "answer": "$$\\boxed{10.04}$$", "id": "3673701"}]}