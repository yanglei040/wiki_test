{"hands_on_practices": [{"introduction": "To begin understanding write buffering, we can simplify a complex system into a \"fluid model.\" This approach allows us to analyze the core performance dynamic: the relationship between the rate at which data arrives ($\\lambda$) and the rate at which it can be drained to storage ($\\mu$). This exercise challenges you to use first principles to determine when a write buffer is stable and when it is destined to overflow, providing a fundamental intuition for system capacity planning. [@problem_id:3690122]", "problem": "An operating system uses a write-back caching policy with a memory-resident write buffer. Multiple producer threads generate application write requests that are appended to the buffer, and a single asynchronous flusher thread drains the buffer to storage. Model the system as a continuous-rate (fluid) queue with the following definitions:\n\n- Let $Q(t)$ denote the buffered data volume at time $t$.\n- Let $\\lambda$ denote the long-term average production rate of write requests (buffer arrivals).\n- Let $\\mu$ denote the long-term average sustained drain rate of the flusher (buffer service).\n- Assume $Q(0)=Q_{0} \\ge 0$.\n- When $Q(t) > 0$, the flusher can run at rate $\\mu$; when $Q(t)=0$, the buffer cannot go negative.\n- The buffer has finite capacity $C$; an overflow occurs when $Q(t)$ first reaches $C$.\n\nStarting only from the basic conservation-of-flow principle that the instantaneous rate of change of buffered data equals the input rate minus the output rate whenever the buffer is nonempty, and that $Q(t)$ is lower bounded by $0$, answer the following:\n\n1) Using the above principles and without invoking any pre-packaged queueing results, reason about the stability of the buffer occupancy in the long run. State the condition on $\\lambda$ and $\\mu$ under which the buffer occupancy can remain bounded over time, and the condition under which it will diverge.\n\n2) Specialize to the case $\\lambda > \\mu$ and $Q(0)=Q_{0} \\in (0,C)$. Derive a closed-form expression for $Q(t)$ for $0 \\le t < t_{\\text{overflow}}$, where $t_{\\text{overflow}}$ is the first time $Q(t)$ reaches $C$.\n\n3) For a concrete system with parameters $\\lambda = 2.4$ GB/s, $\\mu = 1.8$ GB/s, $C = 12$ GB, and $Q_{0} = 1.5$ GB, compute the overflow time $t_{\\text{overflow}}$ in seconds. Express the final answer in seconds and round your answer to four significant figures.", "solution": "The problem asks for an analysis of a write buffer modeled as a continuous-rate fluid queue. The analysis must be derived from the first principle of conservation of flow.\n\nThe fundamental principle provided is that the instantaneous rate of change of the buffered data volume, $\\frac{dQ(t)}{dt}$, is equal to the input rate minus the output rate. The input rate is given as a constant average rate $\\lambda$. The output rate is a constant average rate $\\mu$, but this drain only occurs when the buffer is non-empty, i.e., $Q(t) > 0$. Furthermore, the buffer volume cannot be negative, $Q(t) \\ge 0$.\n\nThis can be formalized into a differential equation. For any time $t$ where $Q(t) > 0$, the dynamics are governed by:\n$$\n\\frac{dQ(t)}{dt} = \\lambda - \\mu\n$$\nIf $Q(t) = 0$, the volume cannot decrease further. Thus, the rate of change must be non-negative. This means $\\frac{dQ(t)}{dt} = \\max(0, \\lambda - \\mu)$ when $Q(t) = 0$.\n\n1) Stability of the buffer occupancy\nThe long-term behavior (stability) of the buffer occupancy $Q(t)$ depends entirely on the sign of the net rate, which is the constant value $\\lambda - \\mu$. We analyze the two cases presented in the question.\n\nCase I: Bounded Occupancy (Stable System)\nFor the buffer occupancy to remain bounded over time, it must not have a tendency to grow indefinitely. This occurs if the net rate of change is non-positive whenever the buffer is non-empty.\nIf $\\lambda < \\mu$, then $\\lambda - \\mu < 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} < 0$, meaning the buffer will drain. If the buffer is empty, $Q(t)=0$, it can only start to fill if there are arrivals, at which point the drain rate exceeds the arrival rate, pushing $Q(t)$ back towards $0$. The system is self-regulating, and the occupancy will remain bounded.\nIf $\\lambda = \\mu$, then $\\lambda - \\mu = 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} = 0$. The buffer level remains constant at its current value. If $Q(t) = 0$, it remains at $0$. The occupancy does not grow to infinity; it remains at its initial level $Q_0$ if $Q_0>0$. Thus, it is also bounded.\nTherefore, the condition for the buffer occupancy to remain bounded over time is $\\lambda \\le \\mu$.\n\nCase II: Divergent Occupancy (Unstable System)\nThe buffer occupancy will diverge if it has a persistent tendency to grow. This occurs if the net rate of change is positive.\nIf $\\lambda > \\mu$, then $\\lambda - \\mu > 0$. In this case, whenever $Q(t) > 0$, we have $\\frac{dQ}{dt} > 0$. The buffer volume will continuously increase. Even if the buffer starts empty, $Q(0)=0, \\frac{dQ}{dt} = \\lambda - \\mu > 0$, so it will immediately begin to fill and continue to grow. In a system with a finite capacity $C$, this growth will continue until the buffer overflows. In an uncapacitated system, $Q(t)$ would grow without bound.\nTherefore, the condition for the buffer occupancy to diverge is $\\lambda > \\mu$.\n\n2) Derivation of $Q(t)$ for $\\lambda > \\mu$\nWe are given the specific case where $\\lambda > \\mu$ and the initial condition is $Q(0) = Q_{0}$, with $Q_{0} \\in (0, C)$.\nSince $Q_{0} > 0$ and the net rate $\\lambda - \\mu$ is a positive constant, the buffer volume $Q(t)$ will increase linearly from its initial state. It will never become $0$ for $t > 0$. Thus, for the entire time interval $0 \\le t < t_{\\text{overflow}}$, the system is governed by the simpler differential equation:\n$$\n\\frac{dQ}{dt} = \\lambda - \\mu\n$$\nThis is a first-order ordinary differential equation with constant coefficients. We can solve it by integrating with respect to time from $t=0$ to a general time $t$, with the corresponding queue volumes being $Q(0)=Q_{0}$ and $Q(t)$:\n$$\n\\int_{Q_{0}}^{Q(t)} dQ' = \\int_{0}^{t} (\\lambda - \\mu) dt'\n$$\nEvaluating the integrals gives:\n$$\nQ(t) - Q_{0} = (\\lambda - \\mu)t\n$$\nSolving for $Q(t)$, we obtain the closed-form expression for the buffer volume as a function of time:\n$$\nQ(t) = Q_{0} + (\\lambda - \\mu)t\n$$\nThis expression is valid for $0 \\le t < t_{\\text{overflow}}$.\n\n3) Calculation of the overflow time $t_{\\text{overflow}}$\nWe are given the system parameters:\n- Arrival rate $\\lambda = 2.4$ GB/s\n- Service rate $\\mu = 1.8$ GB/s\n- Buffer capacity $C = 12$ GB\n- Initial buffer volume $Q_{0} = 1.5$ GB\n\nThe overflow time, $t_{\\text{overflow}}$, is the time $t$ at which the buffer volume $Q(t)$ first reaches the capacity $C$. We use the expression for $Q(t)$ from part (2) and set $Q(t_{\\text{overflow}}) = C$:\n$$\nC = Q_{0} + (\\lambda - \\mu)t_{\\text{overflow}}\n$$\nWe can now solve for $t_{\\text{overflow}}$:\n$$\nC - Q_{0} = (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n$$\nt_{\\text{overflow}} = \\frac{C - Q_{0}}{\\lambda - \\mu}\n$$\nNow, we substitute the numerical values into this equation. The units are consistent: $\\frac{\\text{GB}}{\\text{GB/s}} = \\text{s}$.\n$$\nt_{\\text{overflow}} = \\frac{12 - 1.5}{2.4 - 1.8}\n$$\n$$\nt_{\\text{overflow}} = \\frac{10.5}{0.6}\n$$\n$$\nt_{\\textoverflow} = 17.5\n$$\nThe problem asks for the answer to be rounded to four significant figures. The exact value of $17.5$ can be expressed as $17.50$ to satisfy this requirement. The unit of the result is seconds.", "answer": "$$\n\\boxed{17.50}\n$$", "id": "3690122"}, {"introduction": "Real-world operating systems use more sophisticated strategies than a single constant flush rate. They monitor the amount of \"dirty\" data and trigger different levels of writeback activity based on predefined thresholds. This hands-on coding practice lets you model this realistic behavior, simulating how a page cache's dirty page count evolves under load. By implementing this piecewise model, you will gain a concrete understanding of how kernel parameters like $\\text{dirty\\_bg\\_ratio}$ and $\\text{dirty\\_ratio}$ directly control system responsiveness and prevent buffer saturation. [@problem_id:3690239]", "problem": "Design and implement a complete, runnable program that models the dynamics of a file system page cache under a write-heavy workload in an Operating System (OS). The model uses writeback caching with dirty page thresholds and flusher threads. The goal is to predict when flusher threads kick in and whether the page cache saturates.\n\nStart from the following fundamental definitions and well-tested facts. A page cache holds recently accessed file data and accumulates dirty pages when processes write data, deferring writeback to secondary storage. Let the cache capacity be $C$ pages and the number of dirty pages at time $t$ be $D(t)$, measured in pages. Under a write-heavy workload, $N$ processes write at constant rates $\\{w_i\\}_{i=1}^N$ in pages per second, so the aggregate write rate is $W = \\sum_{i=1}^N w_i$ in pages per second. Writeback flusher threads are governed by two thresholds expressed as ratios of the cache capacity: the background dirty threshold $r_{\\text{bg}}$ and the maximum dirty threshold $r_{\\text{max}}$, where $0 < r_{\\text{bg}} < r_{\\text{max}} < 1$. When $D(t)$ crosses $r_{\\text{bg}} \\cdot C$, background flushing begins at a constant rate $f_{\\text{bg}}$ in pages per second. When $D(t)$ crosses $r_{\\text{max}} \\cdot C$, aggressive flushing begins at a higher constant rate $f_{\\text{max}}$ in pages per second. The number of dirty pages $D(t)$ is constrained by $0 \\le D(t) \\le C$.\n\nThe program must compute the following quantities for each provided test case:\n- $t_{\\text{bg}}$: the first time in seconds at which $D(t)$ reaches or exceeds $r_{\\text{bg}} \\cdot C$, meaning background flusher threads kick in.\n- $t_{\\text{max}}$: the first time in seconds at which $D(t)$ reaches or exceeds $r_{\\text{max}} \\cdot C$, meaning aggressive flusher threads kick in.\n- $t_{\\text{sat}}$: the first time in seconds at which $D(t)$ reaches $C$, meaning the page cache saturates.\n\nUse the following piecewise-linear dynamics. Let the initial dirty pages be $D(0) = D_0$. The aggregate write rate is $W = \\sum_{i=1}^N w_i$. Define the instantaneous writeback rate $f(D)$ by\n$$\nf(D) = \n\\begin{cases}\n0, & \\text{if } D < r_{\\text{bg}} \\cdot C, \\\\\nf_{\\text{bg}}, & \\text{if } r_{\\text{bg}} \\cdot C \\le D < r_{\\text{max}} \\cdot C, \\\\\nf_{\\text{max}}, & \\text{if } D \\ge r_{\\text{max}} \\cdot C,\n\\end{cases}\n$$\nand the rate of change of dirty pages by the well-tested conservation law\n$$\n\\frac{dD}{dt} = W - f(D),\n$$\nwith clamping to the interval $[0, C]$.\n\nAll times must be expressed in seconds as decimal floats. If a quantity never occurs under constant rates (for example, no writes so $W = 0$ and $D(t)$ never increases), output $-1.0$ for that quantity.\n\nTest Suite. Implement the program for the following parameter sets. For each test case, the program must output $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$.\n\n- Test case $1$ (general \"happy path\"): $C = 10000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.4$, $N = 3$, $\\{w_i\\} = \\{120, 80, 50\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 300$, $D_0 = 0$.\n- Test case $2$ (boundary where background flushing exactly balances writes): $C = 5000$, $r_{\\text{bg}} = 0.2$, $r_{\\text{max}} = 0.5$, $N = 2$, $\\{w_i\\} = \\{100, 100\\}$, $f_{\\text{bg}} = 200$, $f_{\\text{max}} = 400$, $D_0 = 0$.\n- Test case $3$ (edge case with no writes): $C = 8000$, $r_{\\text{bg}} = 0.1$, $r_{\\text{max}} = 0.3$, $N = 2$, $\\{w_i\\} = \\{0, 0\\}$, $f_{\\text{bg}} = 100$, $f_{\\text{max}} = 200$, $D_0 = 0$.\n- Test case $4$ (saturation case where even aggressive flushing cannot keep up): $C = 4000$, $r_{\\text{bg}} = 0.15$, $r_{\\text{max}} = 0.35$, $N = 4$, $\\{w_i\\} = \\{300, 250, 200, 150\\}$, $f_{\\text{bg}} = 500$, $f_{\\text{max}} = 800$, $D_0 = 0$.\n- Test case $5$ (background flusher triggers but immediately reduces dirty pages): $C = 12000$, $r_{\\text{bg}} = 0.25$, $r_{\\text{max}} = 0.6$, $N = 1$, $\\{w_i\\} = \\{100\\}$, $f_{\\text{bg}} = 150$, $f_{\\text{max}} = 400$, $D_0 = 0$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list of sublists, each sublist in the form $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$, all times in seconds as decimal floats rounded to six decimal places, enclosed in a single outer pair of square brackets. For example: $[[1.000000,2.500000,-1.000000],[\\dots]]$.", "solution": "The problem asks us to model the number of dirty pages in a page cache, $D(t)$, over time and find the specific times when certain thresholds are crossed. The system's behavior is piecewise-linear, meaning the rate of change of $D(t)$ is constant within three distinct phases determined by the number of dirty pages relative to two thresholds.\n\nFirst, we define the absolute page counts for the thresholds based on the cache capacity $C$ and the given ratios $r_{\\text{bg}}$ and $r_{\\text{max}}$:\n- Background threshold: $D_{\\text{bg}} = r_{\\text{bg}} \\cdot C$\n- Maximum threshold: $D_{\\text{max}} = r_{\\text{max}} \\cdot C$\n\nThe aggregate write rate from all processes is the sum of individual rates: $W = \\sum_{i=1}^N w_i$.\n\nThe net rate of change of dirty pages, $\\frac{dD}{dt}$, is given by the inflow rate $W$ minus the outflow (flushing) rate $f(D)$. We can analyze this rate in three phases:\n- **Phase 1: Below background threshold ($D(t)  D_{\\text{bg}}$)**\n  The flush rate is $f(D) = 0$. The net rate of change is $R_1 = W$.\n- **Phase 2: Between thresholds ($D_{\\text{bg}} \\le D(t)  D_{\\text{max}}$)**\n  The background flusher is active, so $f(D) = f_{\\text{bg}}$. The net rate of change is $R_2 = W - f_{\\text{bg}}$.\n- **Phase 3: At or above maximum threshold ($D(t) \\ge D_{\\text{max}}$)**\n  Aggressive flushing is active, so $f(D) = f_{\\text{max}}$. The net rate of change is $R_3 = W - f_{\\text{max}}$.\n\nSince the rate of change is constant in each phase, we can calculate the time taken to traverse a phase using the formula: $\\Delta t = \\frac{\\Delta D}{\\text{rate}}$. We start with $D(0) = D_0$ and calculate the times sequentially. For all test cases, $D_0 = 0$.\n\n1.  **Time to reach background threshold ($t_{\\text{bg}}$):**\n    The system starts in Phase 1. If $R_1 = W > 0$, the number of dirty pages will increase. The time to reach $D_{\\text{bg}}$ from $D_0=0$ is:\n    $$t_{\\text{bg}} = \\frac{D_{\\text{bg}} - D_0}{R_1} = \\frac{D_{\\text{bg}}}{W}$$\n    If $W \\le 0$, the threshold is never reached, so $t_{\\text{bg}} = t_{\\text{max}} = t_{\\text{sat}} = -1.0$.\n\n2.  **Time to reach maximum threshold ($t_{\\text{max}}$):**\n    This event can only happen if the system successfully reaches $D_{\\text{bg}}$ and the net rate in Phase 2 is positive ($R_2 = W - f_{\\text{bg}} > 0$). If so, the additional time $\\Delta t_2$ to go from $D_{\\text{bg}}$ to $D_{\\text{max}}$ is:\n    $$\\Delta t_2 = \\frac{D_{\\text{max}} - D_{\\text{bg}}}{R_2}$$\n    The total time from $t=0$ is $t_{\\text{max}} = t_{\\text{bg}} + \\Delta t_2$. If $R_2 \\le 0$, this threshold is never reached, so $t_{\\text{max}} = t_{\\text{sat}} = -1.0$.\n\n3.  **Time to saturation ($t_{\\text{sat}}$):**\n    This event can only happen if the system reaches $D_{\\text{max}}$ and the net rate in Phase 3 is positive ($R_3 = W - f_{\\text{max}} > 0$). If so, the additional time $\\Delta t_3$ to go from $D_{\\text{max}}$ to the full capacity $C$ is:\n    $$\\Delta t_3 = \\frac{C - D_{\\text{max}}}{R_3}$$\n    The total time from $t=0$ is $t_{\\text{sat}} = t_{\\text{max}} + \\Delta t_3$. If $R_3 \\le 0$, the cache never saturates, so $t_{\\text{sat}} = -1.0$.\n\nApplying this logic to each test case yields the specific times.", "answer": "[[4.000000,64.000000,-1.000000],[5.000000,-1.000000,-1.000000],[-1.000000,-1.000000,-1.000000],[0.666667,2.666667,28.666667],[30.000000,-1.000000,-1.000000]]", "id": "3690239"}, {"introduction": "Beyond performance, the most critical challenge of write buffering is ensuring data correctness, especially during unexpected system crashes. This practice shifts our focus from speed to safety, exploring the classic problem of making a file update \"atomic\"—an all-or-nothing operation. You will analyze a common protocol involving a temporary file and a `rename` operation to discover why it can fail without explicit synchronization. Solving this puzzle requires reasoning carefully about the ordering guarantees of file system operations and demonstrates why calls like `fsync` are essential tools for writing robust, crash-safe software. [@problem_id:3690204]", "problem": "An application on a Portable Operating System Interface (POSIX) compliant Operating System (OS) updates a configuration file using a two-step protocol to avoid partial writes. The application writes the next version of the configuration into a temporary file path `config.tmp`, then renames `config.tmp` over the existing `config` path. The storage stack uses an OS page cache and a device write-back cache; both caches are volatile and may lose buffered data on a crash unless explicitly flushed. Closing a file does not imply durability. The function `fsync` on a regular file forces that file’s data and inode metadata to reach stable storage; the function `fsync` on a directory forces directory entries (including adds, deletes, and renames) and directory metadata to reach stable storage. The rename is atomic with respect to directory entries once persisted (i.e., readers see either the old name mapping or the new name mapping, but never a mixture), yet the file’s data blocks and directory metadata may be persisted in different orders unless forced.\n\nThe application’s baseline sequence (omitting optional `fsync` calls) is:\n- Open `config.tmp` for write.\n- Write $N$ bytes of the new configuration into `config.tmp`.\n- Close `config.tmp`.\n- Rename `config.tmp` to `config` (replacing the old `config` atomically at persistence time).\n\nYou must decide where to place `fsync` calls to guarantee atomicity under the following strong crash-consistency requirement:\n\nDefinition (atomicity requirement): For any crash that occurs at any time during the update (possibly between two adjacent system calls in the sequence), the recovered system state must satisfy both invariants:\n- Invariant $\\mathrm{I1}$ (no torn content upon visibility): If `config` after recovery refers to the new version, then its contents are exactly the $N$ bytes written by the application (no truncation, zeros, or stale mixture).\n- Invariant $\\mathrm{I2}$ (post-success durability of the name switch): After the application’s last call in the chosen sequence returns success, any subsequent crash must not revert the name mapping; that is, `config` continues to refer to the new version after recovery.\n\nAssume the source and destination paths are in the same parent directory. Which of the following `fsync` placements guarantee atomicity as defined above?\n\nA. Perform no `fsync` calls at all.\n\nB. After the rename, call `fsync` on the parent directory only; do not call `fsync` on the file.\n\nC. Before the rename, call `fsync` on `config.tmp`; after the rename, do not call `fsync` on the parent directory.\n\nD. Before the rename, call `fsync` on `config.tmp`; perform the rename; then call `fsync` on the parent directory.\n\nE. Perform the rename first; then call `fsync` on `config` (the renamed file); finally call `fsync` on the parent directory.", "solution": "The goal is to find a sequence of operations that satisfies both Invariant $\\mathrm{I1}$ and Invariant $\\mathrm{I2}$ under all possible crash scenarios. Let the parent directory be denoted by `dir`.\n\n**Analysis of Invariant $\\mathrm{I1}$ (no torn content upon visibility):**\nInvariant $\\mathrm{I1}$ states that if the name `config` on the filesystem points to the new version of the file, then the contents of that file must be complete and correct. The action that makes `config` point to the new version is the `rename(\"config.tmp\", \"config\")` call. The OS and underlying storage system can persist the result of this `rename` operation (a change to the parent directory `dir`) before persisting the data blocks of the file `config.tmp`.\n\nTo prevent a violation of $\\mathrm{I1}$, we must guarantee that the data of `config.tmp` is durable *before* the link from `config` to this data can become durable. A crash could occur after the directory entry for `rename` is persisted but before the data for `config.tmp` is persisted. In this scenario, `config` would point to an inode whose data blocks on stable storage are unwritten, zeroed, or contain garbage, which is a \"torn content\" failure.\n\nThe only way to enforce the ordering `data persistence -> name-change persistence` is to explicitly force the data to stable storage before initiating the name change. The call to accomplish this is `fsync(config.tmp)`. Therefore, to satisfy $\\mathrm{I1}$, the `fsync(config.tmp)` call must complete successfully *before* the `rename(\"config.tmp\", \"config\")` call is made.\n\n**Analysis of Invariant $\\mathrm{I2}$ (post-success durability of the name switch):**\nInvariant $\\mathrm{I2}$ states that once the application's update sequence completes successfully, the name change must be durable. This means that if the application observes a successful return from its final operation, it can assume the new `config` is in place and will survive a crash.\n\nThe `rename` operation modifies the parent directory `dir`. Simply calling `rename()` provides no durability guarantee, as the change may only exist in a volatile cache. A crash occurring after `rename()` returns but before the directory change is flushed to stable storage would result in the name change being lost. This would violate $\\mathrm{I2}$ if `rename()` were the final call.\n\nTo guarantee the durability of the directory change, we must call `fsync(dir)` *after* the `rename` call. When `fsync(dir)` returns success, the `rename` operation is guaranteed to be on stable storage. Therefore, to satisfy $\\mathrm{I2}$, the final operation in the sequence must be `fsync(dir)`.\n\n**Synthesis of the Correct Sequence:**\nCombining the requirements from both invariants, we arrive at the following robust sequence:\n1.  Open `config.tmp` and write the $N$ bytes of new data.\n2.  Call `fsync(config.tmp)`. This satisfies the prerequisite for $\\mathrm{I1}$ by ensuring the file's content is durable before it can be made visible under the final name.\n3.  Call `rename(\"config.tmp\", \"config\")`. This atomically switches the directory entry.\n4.  Call `fsync(dir)`. This satisfies $\\mathrm{I2}$ by ensuring the name switch is durable, and its success signals the completion of the entire atomic update.\n\n### Option-by-Option Analysis\n\n**A. Perform no `fsync` calls at all.**\n-   **Analysis:** Without any `fsync` calls, the OS is free to reorder writes. It could persist the directory change from the `rename` before persisting the data of `config.tmp`. A crash at this moment would leave `config` pointing to a file with incomplete or garbage data, violating **$\\mathrm{I1}$**. Furthermore, if the final call is `rename`, its successful return does not guarantee durability. A crash could revert the name change, violating **$\\mathrm{I2}$**.\n-   **Verdict:** **Incorrect**.\n\n**B. After the rename, call `fsync` on the parent directory only; do not call `fsync` on the file.**\n-   **Sequence:** `...`, `rename(...)`, `fsync(dir)`.\n-   **Analysis:** This sequence satisfies $\\mathrm{I2}$ because the final `fsync(dir)` call guarantees the durability of the `rename`. However, it does not call `fsync(config.tmp)` before the `rename`. The OS could execute the `rename`, and the `fsync(dir)` could force the directory change to disk before the data blocks of `config.tmp` are written. A crash at that point leads to `config` pointing to a file with non-durable, potentially torn content. This violates **$\\mathrm{I1}$**.\n-   **Verdict:** **Incorrect**.\n\n**C. Before the rename, call `fsync` on `config.tmp`; after the rename, do not call `fsync` on the parent directory.**\n-   **Sequence:** `...`, `fsync(config.tmp)`, `rename(...)`.\n-   **Analysis:** This sequence satisfies $\\mathrm{I1}$. By calling `fsync(config.tmp)` before the `rename`, it ensures that the file's data is durable before the name switch occurs. Therefore, if the name switch is ever observed post-crash, the corresponding data will be complete. However, the sequence ends with `rename`. The successful return of `rename` does not guarantee that the directory change is on stable storage. A subsequent crash could cause the name change to be lost. This violates **$\\mathrm{I2}$**.\n-   **Verdict:** **Incorrect**.\n\n**D. Before the rename, call `fsync` on `config.tmp`; perform the rename; then call `fsync` on the parent directory.**\n-   **Sequence:** `...`, `fsync(config.tmp)`, `rename(...)`, `fsync(dir)`.\n-   **Analysis:** This sequence matches our derived correct protocol.\n    -   `fsync(config.tmp)` before `rename` ensures that the new content is on stable storage before it is made visible via `rename`. This satisfies **$\\mathrm{I1}$**.\n    -   `fsync(dir)` after `rename` ensures that the name switch itself is made durable. As the final call, its success guarantees that the entire operation will survive a crash. This satisfies **$\\mathrm{I2}$**.\n-   **Verdict:** **Correct**.\n\n**E. Perform the rename first; then call `fsync` on `config` (the renamed file); finally call `fsync` on the parent directory.**\n-   **Sequence:** `...`, `rename(...)`, `fsync(\"config\")`, `fsync(dir)`.\n-   **Analysis:** The `rename` is performed before any `fsync`. This creates a window of vulnerability. The OS can persist the directory change from `rename` before writing the file content. A crash during this window would leave `config` pointing to an incomplete file, violating **$\\mathrm{I1}$**. Calling `fsync(\"config\")` after the rename is too late; the inconsistent state (visible name, non-durable content) can already be persisted by the time the `fsync(\"config\")` call begins.\n-   **Verdict:** **Incorrect**.", "answer": "$$\\boxed{D}$$", "id": "3690204"}]}