{"hands_on_practices": [{"introduction": "This first exercise explores one of the most direct methods for managing processor power: idle injection. When a processor's power consumption must be limited to a specific cap, but its frequency is fixed, an operating system can enforce this by periodically forcing the processor into an idle state. This practice will guide you through calculating the necessary idle time to meet a power budget and quantifying the resulting impact on performance, illustrating the fundamental trade-off between power savings and throughput. [@problem_id:3639085]", "problem": "A uniprocessor operating at a fixed clock frequency has Dynamic Voltage and Frequency Scaling (DVFS) disabled. The operating system enforces a power cap by idle injection: over each enforcement window of duration $T$, it forces the processor into a deep idle state for a fraction $\\alpha$ of the time and allows it to execute the workload for the remaining fraction $1-\\alpha$. Assume that whenever the processor is executing, its instantaneous power draw is a constant $P_{\\text{busy}}$, and when forcibly idled it draws a constant $P_{\\text{idle}}$.\n\nThe workload is compute-bound, so its instruction throughput is proportional to the fraction of time the processor is executing at the fixed frequency. Ignore any overheads for entering and exiting idle.\n\nGiven $P_{\\text{busy}} = 44\\,\\text{W}$, $P_{\\text{idle}} = 8\\,\\text{W}$, and a power cap $P_{\\text{cap}} = 29\\,\\text{W}$, determine the smallest idle fraction $\\alpha$ that ensures the average power over each window satisfies $P_{\\text{avg}} \\le P_{\\text{cap}}$. Then, evaluate the performance loss as a fraction $L$ of the uncapped baseline throughput, defined as $L = 1 - \\frac{\\text{throughput under cap}}{\\text{throughput without cap}}$.\n\nReport your answer as a pair $\\left(\\alpha, L\\right)$, rounded to four significant figures. Express both values as pure numbers with no unit.", "solution": "**Derivation of Idle Fraction $\\alpha$**\nThe average power, $P_{\\text{avg}}$, over an enforcement window of duration $T$ is the weighted sum of the power consumed in the busy and idle states. The processor is busy for a duration of $(1-\\alpha)T$ and idle for a duration of $\\alpha T$.\n\nThe total energy $E$ consumed over the window is:\n$$E = P_{\\text{busy}} \\cdot (1-\\alpha)T + P_{\\text{idle}} \\cdot \\alpha T$$\n\nThe average power is this energy divided by the window duration $T$:\n$$P_{\\text{avg}} = \\frac{E}{T} = P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha$$\n\nThe problem imposes the constraint that the average power must not exceed the power cap, $P_{\\text{cap}}$:\n$$P_{\\text{avg}} \\le P_{\\text{cap}}$$\nSubstituting the expression for $P_{\\text{avg}}$:\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha \\le P_{\\text{cap}}$$\n\nWe are asked for the smallest idle fraction $\\alpha$ that satisfies this condition. Since $P_{\\text{busy}} > P_{\\text{idle}}$, the left-hand side of the inequality is a monotonically decreasing function of $\\alpha$. Therefore, the smallest value of $\\alpha$ that satisfies the inequality is the one that makes the two sides equal. We set up the equality:\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha = P_{\\text{cap}}$$\n\nWe now solve for $\\alpha$:\n$$P_{\\text{busy}} - \\alpha P_{\\text{busy}} + \\alpha P_{\\text{idle}} = P_{\\text{cap}}$$\n$$P_{\\text{busy}} - P_{\\text{cap}} = \\alpha (P_{\\text{busy}} - P_{\\text{idle}})$$\n$$\\alpha = \\frac{P_{\\text{busy}} - P_{\\text{cap}}}{P_{\\text{busy}} - P_{\\text{idle}}}$$\n\nSubstituting the given numerical values:\n$$P_{\\text{busy}} = 44\\,\\text{W}$$\n$$P_{\\text{idle}} = 8\\,\\text{W}$$\n$$P_{\\text{cap}} = 29\\,\\text{W}$$\n\n$$\\alpha = \\frac{44 - 29}{44 - 8} = \\frac{15}{36} = \\frac{5}{12}$$\n\nAs a decimal, $\\alpha = 0.41666...$. Rounded to four significant figures, this is $\\alpha = 0.4167$.\n\n**Derivation of Performance Loss $L$**\nThe problem states that instruction throughput is proportional to the fraction of time the processor is executing. Let the throughput be denoted by $\\Theta$ and the proportionality constant by $k$.\n$$\\Theta = k \\times (\\text{execution fraction})$$\n\nThe baseline (uncapped) scenario corresponds to the processor executing all the time, as the workload is compute-bound. Thus, the execution fraction is $1$.\n$$\\Theta_{\\text{without cap}} = k \\times 1 = k$$\n\nUnder the power cap, the processor executes for a fraction $1-\\alpha$ of the time.\n$$\\Theta_{\\text{under cap}} = k \\times (1-\\alpha)$$\n\nThe performance loss $L$ is defined as:\n$$L = 1 - \\frac{\\Theta_{\\text{under cap}}}{\\Theta_{\\text{without cap}}}$$\nSubstituting the expressions for throughput:\n$$L = 1 - \\frac{k(1-\\alpha)}{k} = 1 - (1-\\alpha) = \\alpha$$\n\nThus, the performance loss fraction $L$ is numerically equal to the required idle fraction $\\alpha$.\n$$L = \\alpha = \\frac{5}{12} \\approx 0.41666...$$\n\nRounded to four significant figures, the performance loss is $L = 0.4167$.\n\nThe final answer is the pair $(\\alpha, L)$.\n$$\\alpha \\approx 0.4167$$\n$$L \\approx 0.4167$$", "answer": "$$\\boxed{\\begin{pmatrix} 0.4167 & 0.4167 \\end{pmatrix}}$$", "id": "3639085"}, {"introduction": "Modern processors offer multiple sleep states, each providing greater power savings at the cost of a longer wake-up time. This presents a critical decision for the OS scheduler: when the CPU becomes idle, which sleep state is the best choice? This hands-on problem challenges you to develop a decision algorithm that selects the optimal sleep state by analyzing the trade-off between the energy saved during sleep and the energy and time costs of transitioning, a core task in dynamic power management. [@problem_id:3639092]", "problem": "You are tasked with designing a decision procedure for an energy-aware scheduler that, when the processor becomes idle with a predicted input/output (I/O) wait of duration $W$, selects a sleep state depth $d$ to minimize energy consumption while guaranteeing readiness at the end of the idle window. The decision must be based on wake-up latency $\\ell(d)$ and transition energy $E_{tr}(d)$ for each sleep depth. The goal is to encode this decision as a complete, runnable program that produces the specified output for a fixed test suite.\n\nUse the following foundational base:\n- Power is the rate of energy consumption, so energy is the integral of power over time. In a time interval where power is constant, energy equals power times time. That is, $E = \\int P(t)\\, dt$, and for constant $P$, $E = P \\cdot t$.\n- Readiness constraint: if a sleep state has wake-up latency $\\ell(d)$, then to be ready exactly at the end of the idle window, the last $\\ell(d)$ seconds of the window must be spent waking up.\n\nSystem model:\n- Baseline active idle power is $P_{idle}$ in watts (joules per second).\n- There are $D$ available sleep states with indices $d \\in \\{1, \\dots, D\\}$. Each state $d$ has:\n  - Wake-up latency $\\ell(d)$ in seconds.\n  - Transition energy $E_{tr}(d)$ in joules. This is a one-time energy overhead for entering and exiting the state during the idle window.\n  - Steady-state sleep power $P_s(d)$ in watts during the portion of the window spent sleeping.\n- The baseline \"no sleep\" choice may be modeled as state $d = 0$ with $\\ell(0) = 0$, $E_{tr}(0) = 0$, and $P_s(0) = P_{idle}$, and is always feasible.\n\nDecision policy constraints:\n- A sleep state $d \\ge 1$ is feasible only if $\\ell(d) \\le W$ (so that wake-up can complete before the end of the window).\n- If the energy for all feasible sleep states is greater than or equal to the energy of staying in baseline idle for the entire window, the scheduler must choose $d = 0$.\n- In case of a tie between states with equal energy, choose the smallest $d$.\n\nYour program must compute, for each test case with a predicted idle window $W$, the chosen sleep depth $d$ that minimizes the total energy while satisfying the readiness constraint and the above tie-breaking rule. You will need to determine the energy spent under each feasible choice using the fundamental base. All physical quantities must be handled with correct units: seconds for time, watts for power, and joules for energy.\n\nParameters:\n- Baseline power: $P_{idle} = 15$ watts.\n- Sleep states ($D = 3$):\n  - $d = 1$: $\\ell(1) = 0.005$ seconds, $E_{tr}(1) = 0.2$ joules, $P_s(1) = 8$ watts.\n  - $d = 2$: $\\ell(2) = 0.02$ seconds, $E_{tr}(2) = 0.5$ joules, $P_s(2) = 4$ watts.\n  - $d = 3$: $\\ell(3) = 0.05$ seconds, $E_{tr}(3) = 1.2$ joules, $P_s(3) = 1.5$ watts.\n\nTest suite (predicted idle windows $W$ in seconds):\n- Case A (boundary): $W = 0.0$.\n- Case B (short window, all deeper states infeasible): $W = 0.003$.\n- Case C (small window, shallow state barely feasible): $W = 0.010$.\n- Case D (moderate window, shallow and medium feasible, deep barely feasible): $W = 0.060$.\n- Case E (moderate window): $W = 0.100$.\n- Case F (longer window): $W = 0.300$.\n- Case G (very long window): $W = 2.0$.\n- Case H (boundary at deeper state latency): $W = 0.050$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the selected sleep depths for the above test cases in the given order, as a comma-separated list enclosed in square brackets. The list must contain integers only, with no spaces. For example, use the format $[\\text{result1},\\text{result2},\\dots]$.\n\nYour code must be self-contained, must not read any input, and must use the fixed parameters and test suite above. The outputs are unitless integers representing selected sleep depths.", "solution": "The task is to find the optimal sleep state depth, $d^*$, that minimizes the total energy consumed during an idle window of duration $W$. The set of possible choices for $d$ is $\\{0, 1, 2, 3\\}$.\n\n**1. Energy Consumption Model**\n\nFirst, we derive a mathematical expression for the total energy consumed, $E_{total}(d, W)$, for each possible choice of sleep depth $d$.\n\n**Baseline Energy (No Sleep, $d=0$):**\nIf the scheduler chooses not to enter a sleep state, the processor remains in the active idle state for the entire duration $W$. The power consumption is constant at $P_{idle}$.\nUsing the principle $E = P \\cdot t$, the total energy consumed is:\n$$E_{total}(0, W) = P_{idle} \\cdot W$$\nGiven $P_{idle} = 15 \\frac{J}{s}$, this is $E_{total}(0, W) = 15 \\cdot W$.\n\n**Sleep State Energy ($d \\ge 1$):**\nFor a sleep state $d \\ge 1$ to be chosen, it must be feasible. The feasibility constraint is that the wake-up latency must not exceed the idle window duration:\n$$W \\ge \\ell(d)$$\nIf this condition is met, the total energy consumed is the sum of three components:\n1.  **Transition Energy ($E_{trans}$):** This is the fixed energy cost $E_{tr}(d)$ for entering and exiting the sleep state.\n2.  **Sleep-Phase Energy ($E_{sleep}$):** According to the readiness constraint, the processor must begin waking up $\\ell(d)$ seconds before the end of the window. Therefore, the time spent in the low-power sleep state is $t_{sleep} = W - \\ell(d)$. During this time, the power consumption is $P_s(d)$. The energy consumed is:\n    $$E_{sleep} = P_s(d) \\cdot (W - \\ell(d))$$\n3.  **Wake-up-Phase Energy ($E_{wakeup}$):** The final $\\ell(d)$ seconds are spent transitioning from the sleep state back to the active state. During this wake-up period, the processor is active. As the problem does not specify a distinct wake-up power, we must infer it from the given model parameters. The only active, non-sleep power provided is $P_{idle}$. Therefore, it is a necessary and standard modeling assumption that the power consumption during wake-up is $P_{idle}$. The energy consumed during this phase is:\n    $$E_{wakeup} = P_{idle} \\cdot \\ell(d)$$\n\nCombining these three components, the total energy for a feasible sleep state $d \\ge 1$ is:\n$$E_{total}(d, W) = E_{tr}(d) + P_s(d) \\cdot (W - \\ell(d)) + P_{idle} \\cdot \\ell(d)$$\n\n**2. Decision Algorithm**\n\nFor a given idle window $W$, the scheduler must select the depth $d^*$ that minimizes $E_{total}(d, W)$ over all valid choices for $d$.\n\nThe algorithm is as follows:\n1.  Initialize the minimum energy found so far, $E_{min}$, to the baseline energy: $E_{min} = E_{total}(0, W) = P_{idle} \\cdot W$.\n2.  Initialize the best sleep depth found so far, $d_{best}$, to $0$.\n3.  Iterate through the available sleep states $d = 1, 2, ..., D$.\n4.  For each state $d$:\n    a. Check for feasibility: Is $W \\ge \\ell(d)$?\n    b. If the state is feasible, calculate its total energy consumption, $E_{current} = E_{total}(d, W)$, using the formula derived above.\n    c. Compare this energy to the minimum found so far. According to the decision policy, a deeper state is chosen only if it provides a strict energy improvement. If $E_{current} < E_{min}$, update the choice:\n       $E_{min} = E_{current}$\n       $d_{best} = d$\n5.  After checking all states, the final value of $d_{best}$ is the optimal sleep depth $d^*$.\n\nThis algorithm correctly implements the policy rules. By initializing with $d=0$, it naturally defaults to no sleep if no state offers an improvement. By iterating through $d$ in increasing order and only updating on a strict inequality ($<$), it correctly handles the tie-breaking rule (choose the smallest $d$).\n\nThis procedure will be encoded into a program to compute the results for the given test suite.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Global constants defined by the problem statement.\n#define P_IDLE 15.0\n#define NUM_SLEEP_STATES 3\n\n// A struct to hold the parameters for a single sleep state.\ntypedef struct {\n    int depth;\n    double latency;     // ell(d) in seconds\n    double trans_energy; // E_tr(d) in joules\n    double sleep_power;  // P_s(d) in watts\n} SleepState;\n\n// A struct to hold the parameters for a single test case.\n// In this problem, only the idle window duration W changes.\ntypedef struct {\n    double W; // Predicted I/O wait duration in seconds\n} TestCase;\n\nint main(void) {\n    // Define the fixed sleep states from the problem statement.\n    const SleepState sleep_states[NUM_SLEEP_STATES] = {\n        {1, 0.005, 0.2, 8.0},  // d=1\n        {2, 0.020, 0.5, 4.0},  // d=2\n        {3, 0.050, 1.2, 1.5}   // d=3\n    };\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {0.0},   // Case A\n        {0.003}, // Case B\n        {0.010}, // Case C\n        {0.060}, // Case D\n        {0.100}, // Case E\n        {0.300}, // Case F\n        {2.0},   // Case G\n        {0.050}  // Case H\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        double W = test_cases[i].W;\n\n        // Initialize with the baseline \"no sleep\" (d=0) choice.\n        int best_depth = 0;\n        double min_energy = P_IDLE * W;\n\n        // Iterate through each sleep state d=1, 2, 3 to find a better option.\n        for (int j = 0; j < NUM_SLEEP_STATES; ++j) {\n            // A sleep state is feasible only if the wake-up latency is not longer than the idle window.\n            if (W >= sleep_states[j].latency) {\n                // Calculate the total energy consumed for this feasible sleep state.\n                // E_total = E_transition + E_sleep + E_wakeup\n                double current_energy = sleep_states[j].trans_energy +\n                                        sleep_states[j].sleep_power * (W - sleep_states[j].latency) +\n                                        P_IDLE * sleep_states[j].latency;\n                \n                // Policy: Choose this state only if its energy is strictly less than the current minimum.\n                // This handles both defaulting to d=0 and the tie-breaking rule (smallest d is preferred\n                // because we iterate in increasing order of d).\n                if (current_energy < min_energy) {\n                    min_energy = current_energy;\n                    best_depth = sleep_states[j].depth;\n                }\n            }\n        }\n        results[i] = best_depth;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3639092"}, {"introduction": "On multicore processors, schedulers face a strategic choice: consolidate a workload onto a few cores running at high frequency, or spread it across many cores at a lower frequency. This decision is complicated by the interplay between dynamic power, which is highly dependent on frequency, and leakage power, which depends on the number of active cores. This practice asks you to derive the critical condition that determines which strategy is more energy-efficient, providing insight into the complex power landscape of modern CPUs. [@problem_id:3639071]", "problem": "An operating system scheduler must decide between consolidating a workload onto few processor cores (parking the rest) or spreading it across many cores at a lower frequency, taking into account leakage power. Consider a symmetric multicore processor with $M$ identical cores. A job requires $X$ clock cycles and must complete before a deadline $D$. Assume ideal parallel scaling with no overhead: if $N$ cores are active, each runs the jobâ€™s share at the same clock frequency $f$, and the aggregate throughput is $N f$, so the completion time is $T = X/(N f)$. To minimize energy under the deadline, the scheduler chooses the minimal frequency that satisfies $T \\leq D$.\n\nUse the following widely accepted physical model for complementary metal-oxide-semiconductor (CMOS) dynamic power and Dynamic Voltage and Frequency Scaling (DVFS):\n- Dynamic power per active core is $P_{\\text{dyn}} = C V^{2} f$, where $C$ is the effective switching capacitance and $V$ is the supply voltage.\n- In the operating range of interest, voltage scales approximately proportionally with frequency: $V = \\beta f$, where $\\beta$ is a technology-dependent constant.\n\nLeakage power per active core is a constant $P_{\\text{leak}}$ that does not depend on $f$ in this model. Parked cores have negligible leakage. The energy consumed is the time integral of power; under constant $f$ during execution, this is the product of power and execution time.\n\nDerive, from these bases, a closed-form analytic expression for the critical leakage power $P_{\\text{leak}}^{\\star}$ such that the total energy of running the job on all $M$ cores at the minimal frequency equals the total energy of running the job on a single core at the corresponding minimal frequency. Express your final answer in Watts. Do not compute a numerical value; provide the exact symbolic expression only.", "solution": "The objective is to find the critical leakage power per core, denoted as $P_{\\text{leak}}^{\\star}$, at which the total energy consumed to complete a job on a single core equals the total energy consumed to complete the same job on all $M$ cores of a processor.\n\nFirst, we establish a general model for the total energy consumed, $E$, when using $N$ active cores. The total power, $P_{\\text{total}}(N, f)$, is the sum of the dynamic power and leakage power across all active cores. Parked cores consume negligible power.\nThe power for a single active core running at frequency $f$ is the sum of dynamic power, $P_{\\text{dyn}}$, and leakage power, $P_{\\text{leak}}$.\n$$P_{\\text{core}} = P_{\\text{dyn}} + P_{\\text{leak}}$$\nThe dynamic power is given as $P_{\\text{dyn}} = C V^2 f$, where $V$ is the supply voltage. The voltage is related to the frequency by $V = \\beta f$. Substituting this into the dynamic power equation gives:\n$$P_{\\text{dyn}} = C (\\beta f)^2 f = C \\beta^2 f^3$$\nThus, the power for one core is $P_{\\text{core}}(f) = C \\beta^2 f^3 + P_{\\text{leak}}$. For $N$ active cores, the total power is:\n$$P_{\\text{total}}(N, f) = N \\cdot P_{\\text{core}}(f) = N (C \\beta^2 f^3 + P_{\\text{leak}})$$\nThe job requires $X$ clock cycles to complete. With $N$ cores running at frequency $f$, the aggregate throughput is $Nf$ cycles per second. The execution time $T$ is:\n$$T(N, f) = \\frac{X}{Nf}$$\nThe scheduler must meet a deadline $D$, so $T \\leq D$. To minimize energy, the scheduler selects the lowest possible frequency that satisfies this constraint. This occurs when the execution time is exactly equal to the deadline:\n$$T = \\frac{X}{Nf} = D$$\nFrom this, we can solve for the operating frequency $f$ as a function of the number of active cores $N$:\n$$f(N) = \\frac{X}{ND}$$\nNow, we can express the total energy consumed, $E(N)$, which is the product of total power and execution time, $E(N) = P_{\\text{total}}(N, f(N)) \\times T$. Since the time is fixed at $T=D$:\n$$E(N) = P_{\\text{total}}(N, f(N)) \\cdot D$$\nSubstituting the expressions for $P_{\\text{total}}$ and $f(N)$:\n$$E(N) = N \\left( C \\beta^2 \\left( \\frac{X}{ND} \\right)^3 + P_{\\text{leak}} \\right) D$$\n$$E(N) = N \\left( C \\beta^2 \\frac{X^3}{N^3 D^3} + P_{\\text{leak}} \\right) D$$\n$$E(N) = \\frac{C \\beta^2 X^3}{N^2 D^2} + N P_{\\text{leak}} D$$\nThis is the general expression for the total energy consumed as a function of the number of active cores $N$.\n\nWe now apply this general expression to the two specific cases defined in the problem.\n\nCase 1: The job runs on a single core ($N=1$).\nThe energy consumed, $E_1$, is found by setting $N=1$ in the general energy expression:\n$$E_1 = E(1) = \\frac{C \\beta^2 X^3}{1^2 D^2} + (1) P_{\\text{leak}} D = \\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}} D$$\n\nCase 2: The job runs on all $M$ cores ($N=M$).\nThe energy consumed, $E_M$, is found by setting $N=M$:\n$$E_M = E(M) = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}} D$$\n\nThe critical leakage power, $P_{\\text{leak}}^{\\star}$, is defined as the value of $P_{\\text{leak}}$ for which $E_1 = E_M$. We set up this equality, replacing $P_{\\text{leak}}$ with $P_{\\text{leak}}^{\\star}$:\n$$\\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}}^{\\star} D$$\nNow, we solve for $P_{\\text{leak}}^{\\star}$. First, group terms containing $P_{\\text{leak}}^{\\star}$ on one side and the remaining terms on the other:\n$$M P_{\\text{leak}}^{\\star} D - P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{D^2} - \\frac{C \\beta^2 X^3}{M^2 D^2}$$\nFactor out common terms on both sides:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( 1 - \\frac{1}{M^2} \\right)$$\nSimplify the term in the parenthesis:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( \\frac{M^2-1}{M^2} \\right)$$\nUsing the identity $M^2 - 1 = (M-1)(M+1)$:\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2}$$\nFor a multicore processor, we assume $M \\ge 2$, which implies $M-1 \\neq 0$. We can therefore divide both sides by $D(M-1)$:\n$$P_{\\text{leak}}^{\\star} = \\frac{1}{D(M-1)} \\left( \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2} \\right)$$\n$$P_{\\text{leak}}^{\\star} = \\frac{C \\beta^2 X^3}{D^3} \\frac{M+1}{M^2}$$\nThis is the final closed-form analytic expression for the critical leakage power.", "answer": "$$\n\\boxed{C \\beta^2 \\frac{X^3}{D^3} \\frac{M+1}{M^2}}\n$$", "id": "3639071"}]}