{"hands_on_practices": [{"introduction": "Before diving into complex algorithms, it's crucial to understand the fundamental principles that make deadlock avoidance possible. This first practice challenges you to think like a system designer by evaluating different resource reservation policies in a relatable classroom setting. By analyzing how each policy interacts with the four necessary Coffman conditions for deadlock, you will develop an intuition for why strategies like resource ordering are effective at preventing circular waits, a common culprit in deadlocked systems.", "problem": "A lab coordinator wants to model a classroom equipment checkout system as a resource allocation problem within an Operating System (OS) framework to avoid deadlock during lab rotations. There are $2$ resource types: microscopes (type $r_1$) and oscilloscopes (type $r_2$). Both are physical devices, therefore resources are non-preemptable. Lab groups arrive dynamically over time and can engage in tasks that either require one device or, for cross-disciplinary steps, require both devices simultaneously. The coordinator cannot reliably know each group’s maximum future needs in advance. The goal is to adopt a reservation policy that provably avoids deadlock while still allowing groups to make progress with one device (for example, preparing samples on a microscope while anticipating an oscilloscope) when it is safe to do so. \n\nUse the fundamental base of deadlock theory: the Coffman conditions state that deadlock can arise if all of the following hold simultaneously — mutual exclusion, hold-and-wait, no preemption, and circular wait. Deadlock avoidance can be achieved by designing policies that ensure the system never enters a state from which deadlock is possible.\n\nWhich single reservation policy best satisfies the coordinator’s constraints and objective?\n\nA. First-Come, First-Served (FCFS): approve each request when the requested device is available; if a group holds one device, allow it to wait until the second device becomes available, with no restrictions on request order.\n\nB. Impose a strict total order on resource types and require that all groups request in increasing order (for example, always request $r_1$ before $r_2$), and deny any out-of-order requests; groups may hold $r_1$ and later request $r_2$ in accordance with the order.\n\nC. Apply the Banker’s algorithm at each request even though maximum future claims per group are unknown; infer safety from current availability alone and accept any request that does not immediately exhaust devices.\n\nD. Enforce all-or-nothing combined reservation: approve a group’s request only if both $r_1$ and $r_2$ are simultaneously available; otherwise deny and require re-submission later, preventing any single-device progress while waiting.", "solution": "The problem asks for the best policy to avoid deadlock given that resources are non-preemptible and maximum claims are unknown. We analyze each option against the four Coffman conditions for deadlock: mutual exclusion, hold-and-wait, no preemption, and circular wait. Mutual exclusion and no preemption are stated givens.\n\nA. First-Come, First-Served (FCFS): This policy allows a group to hold one resource while waiting for another, which is the hold-and-wait condition. It places no restriction on the request order, which can lead to a circular wait. For example, Group $G_1$ could hold a microscope ($r_1$) and wait for an oscilloscope ($r_2$), while Group $G_2$ holds an oscilloscope ($r_2$) and waits for a microscope ($r_1$). This creates a deadlock. Therefore, this policy is incorrect.\n\nB. Impose a strict total order on resource types: This policy directly attacks the circular wait condition. By requiring all groups to request resources in a fixed order (e.g., always request $r_1$ before $r_2$), it becomes impossible to form a cycle of dependencies. A group holding $r_2$ can never request $r_1$, breaking the potential circle. This method, known as resource-ordering or resource-hierarchy, is a standard and effective deadlock prevention technique that does not require knowing maximum claims. It also satisfies the objective of allowing progress with a single device. This policy is correct.\n\nC. Apply the Banker’s algorithm: The Banker's algorithm is a deadlock avoidance strategy that requires each process to declare its maximum resource needs in advance. The problem explicitly states that \"The coordinator cannot reliably know each group’s maximum future needs in advance.\" Therefore, the Banker's algorithm is not applicable in this scenario. This policy is incorrect.\n\nD. Enforce all-or-nothing combined reservation: This policy attacks the hold-and-wait condition by requiring a group to acquire all its needed resources simultaneously or none at all. While this does prevent deadlock, it is overly restrictive and conflicts with the stated objective to \"allow[...] groups to make progress with one device... while waiting\". Policy B (Resource Ordering) is less restrictive and better aligns with the coordinator's goals. Thus, policy B is the *best* option.", "answer": "$$\\boxed{B}$$", "id": "3631764"}, {"introduction": "With a conceptual foundation in place, we now turn to the classic algorithmic solution for deadlock avoidance: the Banker's Algorithm. This problem provides a concrete scenario involving a swarm of robots and shared charging docks, tasking you with performing a safety check. You will calculate the need matrix from the given allocation and maximum claims and then systematically search for all possible safe execution sequences, reinforcing your procedural understanding of how an operating system can guarantee it never enters an unsafe state.", "problem": "A mobile robotics lab deploys a swarm of $3$ robots sharing two kinds of charging resources provided by a centralized lab scheduler in an Operating System (OS)-like manner: fast-charging docks ($F$) and standard-charging docks ($S$). Each robot needs a combination of these resources to complete its charging session. The lab scheduler models resource usage using the concepts from deadlock avoidance, specifically the notion of a safe state and the maximum-claim framework that underlies the Banker's scheduling discipline.\n\nThe total number of available resources in the lab is $\\mathbf{T} = (F, S) = (5, 6)$. At a given moment, the current resource allocation and the declared maximum claims for each robot are as follows, with rows corresponding to robots $R_1$, $R_2$, and $R_3$, and columns corresponding to $F$ and $S$:\n\nCurrent allocation matrix $\\mathbf{A}$:\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1 & 2 \\\\\n2 & 0 \\\\\n1 & 3\n\\end{pmatrix}.\n$$\n\nMaximum claims matrix $\\mathbf{M}$:\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3 & 3 \\\\\n3 & 2 \\\\\n2 & 4\n\\end{pmatrix}.\n$$\n\nStarting from the core definition of a safe state in deadlock avoidance—namely, that a state is safe if there exists some order of robot completions such that each robot can obtain its remaining needed resources from what is available plus what will be released by earlier completions—map this charging scenario to the maximum-claim framework and determine how many distinct safe charging completion sequences exist at this instant. Express your final answer as an integer. No rounding is required.", "solution": "The problem asks for the number of distinct safe completion sequences for a system of $3$ robots competing for $2$ types of resources, based on the Banker's algorithm for deadlock avoidance. A state is safe if there exists at least one sequence of robot completions such that each robot can acquire its maximum required resources. We need to find all such unique sequences.\n\nFirst, we formalize the problem using the standard terminology of the Banker's algorithm.\nThe number of processes (robots) is $n=3$, and the number of resource types (charging docks) is $m=2$.\n\nThe givens are:\n- The total number of available resources of each type, represented by the vector $\\mathbf{T} = (5, 6)$, where the first component is for fast-charging docks ($F$) and the second for standard-charging docks ($S$).\n- The current allocation matrix, $\\mathbf{A}$, which specifies how many resources of each type are currently allocated to each robot.\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1 & 2 \\\\\n2 & 0 \\\\\n1 & 3\n\\end{pmatrix}\n$$\nThe rows correspond to robots $R_1$, $R_2$, and $R_3$.\n- The maximum claims matrix, $\\mathbf{M}$, which specifies the maximum number of resources of each type that each robot may request during its entire charging session.\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n3 & 3 \\\\\n3 & 2 \\\\\n2 & 4\n\\end{pmatrix}\n$$\n\nFrom these givens, we can derive the essential components for the safety algorithm.\n\n1.  **Calculate the vector of available resources, $\\mathbf{V}$**:\nThe total number of allocated resources for each type is the sum of the columns of the allocation matrix $\\mathbf{A}$.\nTotal allocated $F$ resources: $1 + 2 + 1 = 4$.\nTotal allocated $S$ resources: $2 + 0 + 3 = 5$.\nThe vector of total allocated resources is $(4, 5)$.\n\nThe available resources vector, $\\mathbf{V}$, is the total resources vector $\\mathbf{T}$ minus the total allocated resources vector.\n$$\n\\mathbf{V} = \\mathbf{T} - (4, 5) = (5, 6) - (4, 5) = (1, 1)\n$$\nSo, initially, there is $1$ fast-charging dock and $1$ standard-charging dock available.\n\n2.  **Calculate the need matrix, $\\mathbf{N}$**:\nThe need matrix, $\\mathbf{N}$, represents the remaining resources each robot might still request. It is calculated as the difference between the maximum claims matrix $\\mathbf{M}$ and the current allocation matrix $\\mathbf{A}$.\n$$\n\\mathbf{N} = \\mathbf{M} - \\mathbf{A} = \n\\begin{pmatrix}\n3 - 1 & 3 - 2 \\\\\n3 - 2 & 2 - 0 \\\\\n2 - 1 & 4 - 3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2 & 1 \\\\\n1 & 2 \\\\\n1 & 1\n\\end{pmatrix}\n$$\nThe rows of $\\mathbf{N}$ are the need vectors for each robot:\n- Need of $R_1$: $\\mathbf{N}_1 = (2, 1)$\n- Need of $R_2$: $\\mathbf{N}_2 = (1, 2)$\n- Need of $R_3$: $\\mathbf{N}_3 = (1, 1)$\n\n3.  **Find all safe sequences using the safety algorithm**:\nThe safety algorithm checks if there's a sequence of robots $\\langle R_{i_1}, R_{i_2}, \\dots, R_{i_n} \\rangle$ such that for each robot $R_{i_k}$, its need vector $\\mathbf{N}_{i_k}$ is less than or equal to the currently available resources vector. If this condition holds, the robot can complete its task and release its allocated resources, which are then added to the available pool. We must find all such valid sequences.\n\nLet the set of unfinished robots be $\\{R_1, R_2, R_3\\}$. The initial available vector is $\\mathbf{V}^{(0)} = (1, 1)$.\n\n**Step 1: Find the first robot in a sequence.**\nWe check which robot $R_i$ satisfies the condition $\\mathbf{N}_i \\le \\mathbf{V}^{(0)}$. A vector $\\mathbf{a} \\le \\mathbf{b}$ if $a_j \\le b_j$ for all components $j$.\n- For $R_1$: Is $\\mathbf{N}_1 = (2, 1) \\le (1, 1)$? No, because $2 > 1$.\n- For $R_2$: Is $\\mathbf{N}_2 = (1, 2) \\le (1, 1)$? No, because $2 > 1$.\n- For $R_3$: Is $\\mathbf{N}_3 = (1, 1) \\le (1, 1)$? Yes, because $1 \\le 1$ and $1 \\le 1$.\n\nOnly $R_3$ can be the first robot in a safe sequence. Therefore, any safe sequence must begin with $\\langle R_3, \\dots \\rangle$.\n\n**Step 2: Find the second robot in a sequence.**\nAssuming $R_3$ runs to completion, it releases its allocated resources, $\\mathbf{A}_3 = (1, 3)$. The new available resources vector becomes:\n$$\n\\mathbf{V}^{(1)} = \\mathbf{V}^{(0)} + \\mathbf{A}_3 = (1, 1) + (1, 3) = (2, 4)\n$$\nThe set of unfinished robots is now $\\{R_1, R_2\\}$. We check which of these can run next with $\\mathbf{V}^{(1)} = (2, 4)$.\n- For $R_1$: Is $\\mathbf{N}_1 = (2, 1) \\le (2, 4)$? Yes, because $2 \\le 2$ and $1 \\le 4$.\n- For $R_2$: Is $\\mathbf{N}_2 = (1, 2) \\le (2, 4)$? Yes, because $1 \\le 2$ and $2 \\le 4$.\n\nBoth $R_1$ and $R_2$ can be the second robot in the sequence. This creates two distinct branches.\n\n**Branch A: The sequence is $\\langle R_3, R_1, \\dots \\rangle$.**\n$R_1$ runs and releases its allocated resources, $\\mathbf{A}_1 = (1, 2)$. The new available vector is:\n$$\n\\mathbf{V}^{(2A)} = \\mathbf{V}^{(1)} + \\mathbf{A}_1 = (2, 4) + (1, 2) = (3, 6)\n$$\nThe only remaining unfinished robot is $R_2$. We check if it can run.\n- For $R_2$: Is $\\mathbf{N}_2 = (1, 2) \\le (3, 6)$? Yes, because $1 \\le 3$ and $2 \\le 6$.\n$R_2$ can complete. This yields the first safe sequence: $\\langle R_3, R_1, R_2 \\rangle$.\n\n**Branch B: The sequence is $\\langle R_3, R_2, \\dots \\rangle$.**\n$R_2$ runs and releases its allocated resources, $\\mathbf{A}_2 = (2, 0)$. The new available vector is:\n$$\n\\mathbf{V}^{(2B)} = \\mathbf{V}^{(1)} + \\mathbf{A}_2 = (2, 4) + (2, 0) = (4, 4)\n$$\nThe only remaining unfinished robot is $R_1$. We check if it can run.\n- For $R_1$: Is $\\mathbf{N}_1 = (2, 1) \\le (4, 4)$? Yes, because $2 \\le 4$ and $1 \\le 4$.\n$R_1$ can complete. This yields the second safe sequence: $\\langle R_3, R_2, R_1 \\rangle$.\n\nWe have explored all possible paths. The search concludes that there are exactly two distinct safe completion sequences.\n\nThe set of safe sequences is:\n1. $\\langle R_3, R_1, R_2 \\rangle$\n2. $\\langle R_3, R_2, R_1 \\rangle$\n\nThe total number of distinct safe charging completion sequences is $2$.", "answer": "$$\\boxed{2}$$", "id": "3631832"}, {"introduction": "Real-world systems often feature complexities not captured by the classic Banker's Algorithm, which assumes all resources of a given type are identical and interchangeable. This final practice introduces the challenge of heterogeneous resources, where processes have specific compatibility requirements with particular resource instances. You must adapt the core logic of the safety algorithm, moving beyond simple resource counts to tracking the availability of specific, compatible instances. This exercise will deepen your understanding from rote application to principle-based problem-solving, demonstrating how foundational OS concepts are generalized to handle more realistic and nuanced scheduling environments.", "problem": "An operating system must avoid deadlock while scheduling processes on heterogeneous resource instances where not every process is compatible with every instance. You are asked to reason from first principles about safe states and to apply a compatibility-aware generalization of the Banker's algorithm.\n\nConsider a system with a set of processes $\\mathcal{P}=\\{P_1,P_2,P_3\\}$ and resource types $\\mathcal{R}=\\{A,B\\}$. Resource type $A$ has instance set $\\mathcal{I}_A=\\{a_1,a_2\\}$, and resource type $B$ has instance set $\\mathcal{I}_B=\\{b_1\\}$. Each process $P_i$ declares a maximum claim per type, and to finish it must be allocated resources up to that maximum. The current state is:\n- Maximum claims (per type): $Max(P_1)=(A:1,B:0)$, $Max(P_2)=(A:1,B:1)$, $Max(P_3)=(A:1,B:1)$.\n- Current allocation: $Alloc(P_1)=(A:0,B:0)$, $Alloc(P_2)=(A:0,B:1)$, $Alloc(P_3)=(A:0,B:0)$.\n- Available instances: for type $A$, both $a_1$ and $a_2$ are free; for type $B$, $b_1$ is currently allocated to $P_2$ (so $B$ has $0$ free instances).\n\nCompatibility is specified as a relation $\\kappa \\subseteq \\mathcal{P}\\times(\\mathcal{I}_A\\cup\\mathcal{I}_B)$, given by:\n- For type $A$: $P_1$ is compatible only with $a_1$; $P_2$ is compatible only with $a_2$; $P_3$ is compatible only with $a_2$.\n- For type $B$: $P_1$ is compatible with $b_1$; $P_2$ is compatible with $b_1$; $P_3$ is compatible with $b_1$.\n\nInterpret resource requests in the standard way: a request of $1$ unit of type $A$ by process $P_i$ means the operating system may, if it grants the request, allocate any currently free instance in $\\mathcal{I}_A$ that is compatible with $P_i$; similarly for type $B$. Assume all requests below respect the respective maximum claims.\n\nA state is safe if and only if there exists an order of completion of all processes such that, at each step, the next process in the order can acquire all of its remaining needed units using currently available instances to which it is compatible, complete, and release its allocated instances.\n\nQuestion: According to a compatibility-aware Banker's safety test, which of the following single-resource requests can be safely granted immediately (i.e., upon grant, the resulting state is safe)?\n\nA. Grant $P_3$ a request for $1$ unit of type $A$.\n\nB. Grant $P_2$ a request for $1$ unit of type $A$.\n\nC. Grant $P_1$ a request for $1$ unit of type $A$.\n\nD. Grant $P_3$ a request for $1$ unit of type $B$.", "solution": "The problem requires a compatibility-aware safety check. We analyze the state of the system after hypothetically granting each request. A request can be granted only if the resulting state is safe. A state is safe if there exists at least one sequence of process completions.\n\n**Initial State Analysis:**\n- Processes: $\\mathcal{P}=\\{P_1,P_2,P_3\\}$.\n- Available Instances: `Avail_Inst` = $\\{a_1, a_2\\}$ for type $A$, and {} for type $B$.\n- Allocation: $Alloc(P_1)=(A:0,B:0)$, $Alloc(P_2)=(A:0,B:1)$ holds $b_1$, $Alloc(P_3)=(A:0,B:0)$.\n- Need: $Need(P_1)=(A:1,B:0)$, $Need(P_2)=(A:1,B:0)$, $Need(P_3)=(A:1,B:1)$.\n- Compatibility: $P_1 \\leftrightarrow a_1$; $P_2 \\leftrightarrow a_2$; $P_3 \\leftrightarrow a_2$; all processes $\\leftrightarrow b_1$.\n\nWe will test each option:\n\n**A. Grant $P_3$ a request for $1$ unit of type $A$.**\n- Grant instance $a_2$ (compatible with $P_3$) to $P_3$.\n- **New State:** `Avail_Inst` for $A$ is $\\{a_1\\}$. $Alloc(P_3)$ becomes $(A:1,B:0)$ holding $a_2$. $Need(P_3)$ becomes $(A:0,B:1)$.\n- **Safety Check:** Let `Work_Inst` be the available instances.\n  - Can any process finish?\n    - $P_1$ needs $1$ unit of $A$ (compatible with $a_1$). $a_1$ is in `Work_Inst`. $P_1$ can run.\n    - $P_2$ needs $1$ unit of $A$ (compatible with $a_2$). $a_2$ is held by $P_3$. $P_2$ cannot run.\n    - $P_3$ needs $1$ unit of $B$ (compatible with $b_1$). $b_1$ is held by $P_2$. $P_3$ cannot run.\n  - Only $P_1$ can run first. Let $P_1$ finish. It releases no resources. `Work_Inst` is unchanged.\n  - Now, we check $P_2$ and $P_3$ again. $P_2$ still needs $a_2$ (held by $P_3$) and $P_3$ still needs $b_1$ (held by $P_2$). This is a deadlock.\n  - The resulting state is unsafe. **Option A is incorrect.**\n\n**B. Grant $P_2$ a request for $1$ unit of type $A$.**\n- Grant instance $a_2$ (compatible with $P_2$) to $P_2$.\n- **New State:** `Avail_Inst` for $A$ is $\\{a_1\\}$. $Alloc(P_2)$ becomes $(A:1,B:1)$ holding $a_2, b_1$. $Need(P_2)$ becomes $(A:0,B:0)$.\n- **Safety Check:**\n  - $P_2$ has met its max claim. It can finish and release its resources ($a_2, b_1$).\n  - Let's form a sequence starting with $P_2$: $\\langle P_2, \\dots \\rangle$.\n  - After $P_2$ finishes, `Work_Inst` becomes $\\{a_1, a_2\\}$ for $A$, and $\\{b_1\\}$ for $B$.\n  - Now check remaining processes $P_1, P_3$:\n    - $P_1$ needs $1$ unit of $A$ (compatible with $a_1$). $a_1$ is in `Work_Inst`. $P_1$ can run.\n    - $P_3$ needs $1$ unit of $A$ ($a_2$) and $1$ unit of $B$ ($b_1$). Both are in `Work_Inst`. $P_3$ can run.\n  - We can finish both remaining processes, e.g., in the order $P_1$ then $P_3$.\n  - A safe sequence $\\langle P_2, P_1, P_3 \\rangle$ exists. The state is safe. **Option B is correct.**\n\n**C. Grant $P_1$ a request for $1$ unit of type $A$.**\n- Grant instance $a_1$ (compatible with $P_1$) to $P_1$.\n- **New State:** `Avail_Inst` for $A$ is $\\{a_2\\}$. $Alloc(P_1)$ becomes $(A:1,B:0)$ holding $a_1$. $Need(P_1)$ becomes $(A:0,B:0)$.\n- **Safety Check:**\n  - $P_1$ has met its max claim. It can finish and release $a_1$.\n  - Let's form a sequence starting with $P_1$: $\\langle P_1, \\dots \\rangle$.\n  - After $P_1$ finishes, `Work_Inst` becomes $\\{a_1, a_2\\}$ for $A$, and {} for $B$.\n  - Now check remaining processes $P_2, P_3$:\n    - $P_2$ needs $1$ unit of $A$ ($a_2$). $a_2$ is in `Work_Inst`. $P_2$ can run. Once it gets $a_2$, its need is $(0,0)$, it can finish and release $b_1$.\n    - Let $P_2$ run next: $\\langle P_1, P_2, \\dots \\rangle$. After $P_2$ finishes, it releases $b_1$. `Work_Inst` for $B$ becomes $\\{b_1\\}$.\n    - Finally, $P_3$ needs $1$ unit of $A$ ($a_2$) and $1$ unit of $B$ ($b_1$). Both are now available. $P_3$ can run.\n  - A safe sequence $\\langle P_1, P_2, P_3 \\rangle$ exists. The state is safe. **Option C is correct.**\n\n**D. Grant $P_3$ a request for $1$ unit of type $B$.**\n- The initial number of available instances of type $B$ is $0$.\n- The request cannot be granted because there are no available resources of type $B$. The process must wait.\n- Therefore, this is not a request that can be \"granted immediately\". **Option D is incorrect.**\n\nBoth options B and C result in a safe state.", "answer": "$$\\boxed{BC}$$", "id": "3631852"}]}