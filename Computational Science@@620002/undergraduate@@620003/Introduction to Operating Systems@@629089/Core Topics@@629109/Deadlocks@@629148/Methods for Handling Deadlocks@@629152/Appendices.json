{"hands_on_practices": [{"introduction": "A key strategy for handling deadlocks is to avoid them altogether. The Banker's Algorithm provides a powerful mechanism for deadlock avoidance by carefully analyzing resource requests before granting them. This exercise [@problem_id:3658926] provides concrete practice with the safety algorithm at the core of this method, challenging you to act as the \"banker\" for the operating system and determine if a given state is safe, reinforcing the critical concepts of available resources, maximum needs, and safe execution sequences.", "problem": "In a conservative resource-allocation variant of the dining philosophers problem, all forks are treated as a single pool of identical resources. There are $n=4$ philosophers $\\{P_1,P_2,P_3,P_4\\}$ and a pool of $F=9$ identical forks. Each philosopher $P_i$ declares a maximum outstanding claim of $M_i$ forks, but to complete a meal a philosopher requires at most $2$ forks at once. However, the operating system enforces safety by the Banker's algorithm, which must conservatively assume that each $P_i$ may request up to its declared maximum $M_i$ before releasing any forks. Thus the safety check is performed against the declared maxima.\n\nThe current allocation vector (forks currently held) is $A=(2,2,2,1)$, and the declared maximum vector is $M=(5,6,5,x)$, where $x$ is a positive integer and must satisfy $1 \\le x \\le F$ to be a valid declaration. The system state is represented by $(F,M,A)$ and is considered safe if there exists an ordering of the philosophers in which, starting from the currently available forks, each philosopher can be allocated up to its remaining declared need and then complete (releasing all its allocated forks), never exceeding the available forks at any step.\n\nStarting only from the core definitions of deadlock and the safety test underlying the Banker's algorithm (without assuming any specialized shortcuts), determine the largest integer value of $x$ for which the current state $(F,M,A)$ is safe under the Banker's algorithm. Provide your final answer as a single integer.", "solution": "The problem requires determining the largest integer value of a variable $x$ that keeps a resource-allocation system in a safe state, according to the Banker's algorithm. A state is defined as safe if there exists a sequence of processes (philosophers, in this case) that can all complete their execution.\n\nFirst, we formalize the state of the system based on the provided data.\nThe number of processes (philosophers) is $n=4$.\nThe total number of identical resources (forks) is $F=9$.\n\nThe state of the system is defined by three vectors:\n1.  The maximum resource claim for each philosopher, $M$.\n2.  The current allocation of resources to each philosopher, $A$.\n3.  The number of available resources in the system, $V$.\n\nThe givens are:\nThe maximum claim vector is $M = (M_1, M_2, M_3, M_4) = (5, 6, 5, x)$.\nThe current allocation vector is $A = (A_1, A_2, A_3, A_4) = (2, 2, 2, 1)$.\n\nFrom these, we can calculate the total number of allocated resources:\n$$ \\sum_{i=1}^{n} A_i = 2 + 2 + 2 + 1 = 7 $$\nThe number of currently available resources, $V$, is the total number of resources minus the total allocated resources:\n$$ V = F - \\sum_{i=1}^{n} A_i = 9 - 7 = 2 $$\n\nNext, we calculate the `Need` vector, $N$. The `Need` for each philosopher $P_i$ is the maximum number of additional resources it might request to complete its task. It is calculated as the difference between its maximum claim and its current allocation: $N_i = M_i - A_i$.\n$$ N = M - A = (5-2, 6-2, 5-2, x-1) = (3, 4, 3, x-1) $$\n\nThe safety algorithm determines if the current state is safe. The algorithm works as follows:\n1.  Initialize a `Work` vector (in this case, a scalar since there is only one resource type) to the value of `Available` resources. Let $W = V = 2$.\n2.  Initialize a boolean vector `Finish` of length $n$, with all elements set to `false`. $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$.\n3.  Search for a philosopher $P_i$ such that both of the following conditions are met:\n    a. $Finish_i$ is `false`.\n    b. $N_i \\le W$.\n4.  If such a philosopher $P_i$ exists, we assume it can complete. We update the state by virtually releasing its resources:\n    a. $W \\leftarrow W + A_i$.\n    b. $Finish_i \\leftarrow \\text{true}$.\n    c. Go back to step 3.\n5.  If no such philosopher can be found in step 3, the algorithm terminates.\n6.  The initial state is considered safe if and only if the algorithm terminates with all elements of the `Finish` vector being `true`.\n\nWe will now apply this algorithm to the given system state to find the constraint on $x$.\nInitial state of the safety check:\n$W = 2$\n$N = (3, 4, 3, x-1)$\n$A = (2, 2, 2, 1)$\n$Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$\n\nIn the first pass of step 3, we look for a philosopher $P_i$ where $N_i \\le W = 2$ and $Finish_i$ is `false`.\n- For $P_1$: $N_1 = 3$. Is $3 \\le 2$? No.\n- For $P_2$: $N_2 = 4$. Is $4 \\le 2$? No.\n- For $P_3$: $N_3 = 3$. Is $3 \\le 2$? No.\n- For $P_4$: $N_4 = x-1$. We need to check if $x-1 \\le 2$.\n\nFor the safety algorithm to proceed beyond the first step, there must be at least one philosopher that can be satisfied with the currently available resources. From the analysis above, philosophers $P_1$, $P_2$, and $P_3$ cannot be chosen. Therefore, the algorithm can only start if philosopher $P_4$ can be chosen. This imposes a necessary condition on $x$:\n$$ N_4 \\le W \\implies x-1 \\le 2 \\implies x \\le 3 $$\nThe problem states that $x$ is a positive integer, so $x \\ge 1$. This implies that any value of $x  3$ will result in an unsafe state, because the safety algorithm would halt at the very first step with no process being able to proceed.\n\nTo find the largest integer value of $x$ for which the state is safe, we must test the maximum possible value, $x=3$. If $x=3$ yields a safe state, it will be our answer.\n\nLet's test for $x=3$:\nThe `Need` vector becomes $N = (3, 4, 3, 3-1) = (3, 4, 3, 2)$.\nInitial state: $W=2$, $Finish=(\\text{false}, \\text{false}, \\text{false}, \\text{false})$.\n\n- **Pass 1:** We search for $P_i$ with $N_i \\le W=2$. As determined before, only $P_4$ satisfies this, with $N_4=2$. We select $P_4$.\n  - Update $W \\leftarrow W + A_4 = 2 + 1 = 3$.\n  - Update $Finish \\leftarrow (\\text{false}, \\text{false}, \\text{false}, \\text{true})$.\n  - A possible safe sequence starts with $\\langle P_4 \\rangle$.\n\n- **Pass 2:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=3$.\n  - For $P_1$: $N_1 = 3$. Is $3 \\le 3$? Yes.\n  - For $P_2$: $N_2 = 4$. Is $4 \\le 3$? No.\n  - For $P_3$: $N_3 = 3$. Is $3 \\le 3$? Yes.\n  - We can choose either $P_1$ or $P_3$. Let's select $P_1$.\n  - Update $W \\leftarrow W + A_1 = 3 + 2 = 5$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{false}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1 \\rangle$.\n\n- **Pass 3:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=5$.\n  - For $P_2$: $N_2 = 4$. Is $4 \\le 5$? Yes.\n  - For $P_3$: $N_3 = 3$. Is $3 \\le 5$? Yes.\n  - We can choose either $P_2$ or $P_3$. Let's select $P_3$.\n  - Update $W \\leftarrow W + A_3 = 5 + 2 = 7$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{false}, \\text{true}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1, P_3 \\rangle$.\n\n- **Pass 4:** We search for $P_i$ with $Finish_i=\\text{false}$ and $N_i \\le W=7$.\n  - Only $P_2$ remains. $N_2=4$. Is $4 \\le 7$? Yes.\n  - We select $P_2$.\n  - Update $W \\leftarrow W + A_2 = 7 + 2 = 9$.\n  - Update $Finish \\leftarrow (\\text{true}, \\text{true}, \\text{true}, \\text{true})$.\n  - The sequence is now $\\langle P_4, P_1, P_3, P_2 \\rangle$.\n\n- **Pass 5:** All elements of the `Finish` vector are now `true`. The algorithm terminates successfully.\n\nSince a safe sequence $\\langle P_4, P_1, P_3, P_2 \\rangle$ exists for $x=3$, the state is safe for this value. We have already established that for any integer $x3$, the state is unsafe. Therefore, the largest integer value of $x$ for which the state is safe is $3$.", "answer": "$$\\boxed{3}$$", "id": "3658926"}, {"introduction": "When a deadlock is not prevented or avoided, it is crucial to understand its practical consequences and how to detect it. This practice [@problem_id:3658954] explores the tangible impact of a deadlock on system resources, contrasting the CPU waste generated by spinlocks versus the efficiency of sleeping locks. By analyzing this scenario, you will develop a deeper intuition for why lock implementation matters and how an operating system can formally diagnose a deadlock by constructing a Wait-For Graph to find the underlying circular dependency.", "problem": "Consider an Operating System (OS) running on a Symmetric Multiprocessing system with $m=2$ cores. The OS provides two kinds of locks: spinlocks and sleeping locks. A spinlock causes a thread to busy-wait in a loop, repeatedly testing a shared variable using atomic operations until the lock becomes available; a sleeping lock causes a thread to block and yield the Central Processing Unit (CPU), letting the scheduler run other threads. Two threads $T_1$ and $T_2$ contend for two spinlocks $L_1$ and $L_2$ as follows: thread $T_1$ acquires $L_1$ and then attempts to acquire $L_2$, while thread $T_2$ acquires $L_2$ and then attempts to acquire $L_1$. Neither thread releases its first lock while waiting for the second. The system supports tracking of lock ownership and waiters. The target is to reason from fundamental definitions of deadlock and resource waiting to analyze CPU waste due to spinning under deadlock and to propose a principled deadlock detection method that can be invoked from within spin loops.\n\nBase definitions: a deadlock exists when a nonempty set of threads are each waiting for an event that only another thread in the set can cause, which in the context of locks corresponds to cycles in a Wait-For Graph (WFG). The Coffman conditions for deadlock are mutual exclusion, hold-and-wait, no preemption, and circular wait. Throughput is the rate of completed critical sections per unit time; while a thread spins, it consumes CPU cycles even if it does not make progress on its critical section.\n\nWhich of the following statements are correct in this scenario?\n\nA. With $m=2$ cores, if $T_1$ and $T_2$ deadlock while spinning on $L_1$ and $L_2$, the system’s aggregate CPU utilization can reach approximately $100\\%$ while throughput remains $0$, because both cores execute busy-wait loops that do not complete any work.\n\nB. If $L_1$ and $L_2$ were implemented as sleeping locks instead of spinlocks, a deadlock could still occur between $T_1$ and $T_2$, but the scheduler would deschedule the blocked threads, reducing CPU waste without increasing throughput.\n\nC. A correct deadlock detection policy inside a spin loop can be based solely on a fixed timeout $t$; if a thread spins longer than $t$, the OS may safely conclude a deadlock and forcibly preempt the lock holder to break the cycle.\n\nD. A principled deadlock detection method for spinning threads is to periodically build a Wait-For Graph (WFG) of threads and locks from kernel-maintained ownership and waiter metadata and check for cycles; upon detecting a cycle, the OS can invoke a resolution policy such as aborting one acquisition attempt or rolling back one thread, thereby breaking circular wait.\n\nE. Spinlocks are always preferable to sleeping locks on single-processor systems because they eliminate context switch overhead and therefore cannot deadlock.", "solution": "The problem statement is analyzed and found to be valid. It is scientifically grounded in the principles of operating systems, specifically concurrency and deadlock. The scenario is well-posed, unambiguous, and free of contradictions. It presents a classic deadlock case that is suitable for rigorous analysis.\n\nThe core of the problem describes a deadlock situation involving two threads, $T_1$ and $T_2$, and two spinlocks, $L_1$ and $L_2$, on a symmetric multiprocessing system with $m=2$ cores. The sequence of lock acquisitions creates a circular dependency:\n1. Thread $T_1$ acquires lock $L_1$.\n2. Thread $T_2$ acquires lock $L_2$.\n3. Thread $T_1$ attempts to acquire $L_2$, which is held by $T_2$. $T_1$ begins to spin-wait.\n4. Thread $T_2$ attempts to acquire $L_1$, which is held by $T_1$. $T_2$ begins to spin-wait.\n\nThis situation satisfies the four necessary Coffman conditions for deadlock:\n1.  **Mutual Exclusion**: The locks $L_1$ and $L_2$ are exclusive resources.\n2.  **Hold-and-Wait**: $T_1$ holds $L_1$ while waiting for $L_2$, and $T_2$ holds $L_2$ while waiting for $L_1$.\n3.  **No Preemption**: The problem states that neither thread releases its first lock while waiting, meaning the locks cannot be preempted.\n4.  **Circular Wait**: A circular chain of waiting exists: $T_1 \\to L_2 \\to T_2 \\to L_1 \\to T_1$.\n\nGiven this deadlock, $T_1$ and $T_2$ are scheduled on the two available cores. $T_1$ executes a busy-wait loop on one core, and $T_2$ executes a busy-wait loop on the other. Neither thread can make progress.\n\n**Analysis of Option A:**\nThe statement suggests that with $m=2$ cores, the deadlocked threads $T_1$ and $T_2$ will lead to approximately $100\\%$ CPU utilization and $0$ throughput.\nIn the described deadlock, $T_1$ is executing a spin-wait loop on one core, and $T_2$ is executing a spin-wait loop on the second core. A thread in a spin-wait loop is actively executing instructions, thus keeping the CPU core it is running on fully occupied. Since both cores of the $m=2$ system are occupied by spinning threads, the aggregate CPU utilization will be $((100\\% + 100\\%) / 2) = 100\\%$. Throughput is defined as the rate of completed critical sections. Since both threads are stuck in a deadlock, neither can complete its sequence of operations. Therefore, the throughput of useful work is $0$. The reasoning provided in the statement is also sound: the cores are busy, but with non-productive work.\nVerdict: **Correct**.\n\n**Analysis of Option B:**\nThis statement considers a hypothetical scenario where the spinlocks $L_1$ and $L_2$ are replaced with sleeping locks.\nThe underlying logic for deadlock remains unchanged; the four Coffman conditions are still met. Thus, a deadlock would still occur. The difference lies in the waiting mechanism. A sleeping lock causes a thread to block and be moved by the scheduler from a `RUNNING` state to a `WAITING` or `BLOCKED` state. A blocked thread does not consume CPU cycles. Therefore, when $T_1$ and $T_2$ attempt to acquire the second lock, they will both be descheduled. This frees up the CPU cores to execute other ready threads or to enter an idle state if no other threads are ready. This directly reduces CPU waste compared to the spinlock scenario. However, the deadlock condition persists, so neither thread makes progress, and the throughput remains $0$.\nVerdict: **Correct**.\n\n**Analysis of Option C:**\nThis statement proposes a deadlock detection policy based on a fixed timeout, $t$, and a recovery action of forcibly preempting the lock holder.\nUsing a timeout to infer a deadlock is a heuristic, not a definitive method. A thread might spin for a long time not because of a deadlock, but because of high contention or because the lock holder is executing a legitimate, long-running critical section. Therefore, one cannot \"safely conclude a deadlock\" based solely on a timeout; this can lead to false positives. Furthermore, \"forcibly preempting the lock holder\" is an extremely unsafe operation. The lock holder may be at an intermediate stage of modifying a shared data structure. Preempting its lock would likely leave this structure in an inconsistent and corrupted state, which could crash the system or lead to subtle data errors. Safe preemption requires complex transaction-like rollback/recovery mechanisms, which are not implied by this simplistic policy.\nVerdict: **Incorrect**.\n\n**Analysis of Option D:**\nThis statement describes a principled method for deadlock detection and resolution. It involves constructing a Wait-For Graph (WFG), where nodes represent threads and a directed edge from $T_i$ to $T_j$ signifies that $T_i$ is waiting for a resource held by $T_j$. The problem states that the OS maintains the necessary ownership and waiter information. A cycle in the WFG is a necessary and sufficient condition for a deadlock. This is a formal and correct method for detection. Upon detecting a cycle (and thus confirming a deadlock), the OS must apply a resolution policy. The suggested policies—aborting an acquisition attempt or rolling back a thread—are standard strategies for breaking the deadlock, typically by breaking the circular wait condition. This approach is sound, robust, and represents a standard algorithm taught in operating systems courses.\nVerdict: **Correct**.\n\n**Analysis of Option E:**\nThis statement claims that spinlocks are \"always preferable\" to sleeping locks on single-processor systems because they \"cannot deadlock\".\nThis statement is fundamentally flawed. On a single-processor system, if a thread $T_A$ holding a lock is preempted and a thread $T_B$ is scheduled, and $T_B$ attempts to acquire the same lock using a spinlock, $T_B$ will spin indefinitely. Since there is only one processor, the lock-holding thread $T_A$ cannot run to release the lock because $T_B$ is consuming all available CPU time. This leads to a complete system freeze, a form of deadlock. In contrast, if $T_B$ used a sleeping lock, it would block, and the scheduler could reschedule $T_A$, which could then release the lock and allow the system to make progress. Thus, spinlocks are generally a very poor choice on uniprocessor systems, and they can most certainly cause deadlocks. The premise is false and the conclusion is also false.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{ABD}$$", "id": "3658954"}, {"introduction": "In many complex systems, deadlocks emerge not from a deterministic design but from the probabilistic interactions of many independent threads. This exercise [@problem_id:3659020] challenges you to move beyond deterministic scenarios and model the likelihood of deadlock using probability theory. By deriving the probability of a circular wait condition arising from random lock acquisitions, you will connect the theoretical Coffman conditions to a quantitative result and analyze randomized backoff, a common and practical technique for resolving deadlocks.", "problem": "Consider an operating system with two mutex locks $A$ and $B$ and $n$ independent threads that start simultaneously at time $t=0$. Each thread independently and uniformly at random chooses one of two acquisition orders: either acquire $A$ then $B$, or acquire $B$ then $A$. Each thread first attempts to acquire its chosen first lock; if multiple threads choose the same first lock, exactly one succeeds and the rest block on that lock. Any thread that acquires its first lock immediately attempts to acquire its second lock; if the second lock is not available, it blocks while holding the first lock. Locks are non-preemptive, have no timeouts, and threads do not release a held lock unless explicitly specified.\n\nUse the classical Coffman conditions for deadlock in operating systems—mutual exclusion, hold-and-wait, no preemption, and circular wait—as the fundamental base to reason about when a deadlock occurs in this system.\n\n1) Derive from first principles the probability, as a function of $n$, that a deadlock arises under the above locking behavior at time $t$ immediately after the first attempts to acquire the second lock are made.\n\n2) Now, consider a randomized backoff modification designed to reduce deadlock: if there is a configuration in which one thread holds $A$ and is blocked waiting for $B$, while simultaneously another thread holds $B$ and is blocked waiting for $A$, then in a single synchronized backoff decision epoch, each of these two blocked holders independently releases its held lock with probability $r \\in (0,1)$ and waits before retrying; otherwise, nothing changes in that epoch. Assume all other threads remain blocked on their first lock during this epoch. Under this modification, derive a closed-form analytic expression for the probability that a deadlock persists after this single backoff decision epoch, as a function of $n$ and $r$.\n\nProvide your final answer as a single closed-form analytic expression for the persistence probability from part (2). No rounding is required.", "solution": "The central task is to derive the probability that a deadlock, formed under specific conditions, persists after a single attempt at probabilistic resolution. This requires a two-step analysis: first, determining the probability that a deadlock occurs at all, and second, determining the probability that, given a deadlock, it survives the resolution mechanism. The overall probability of persistence is the product of these two probabilities.\n\nLet us begin by deriving the probability that a deadlock arises, as specified in the first part of the problem. This analysis relies on the Coffman conditions for deadlock. The problem statement establishes that the conditions of mutual exclusion (mutex locks), hold-and-wait (a thread holds its first lock while attempting to acquire the second), and no preemption (locks are not forcibly taken away) are met by design. The condition that determines the occurrence of a deadlock is, therefore, the circular wait.\n\nIn a system with $2$ locks, which we denote as $A$ and $B$, a circular wait can only occur between $2$ threads. Specifically, a thread $T_A$ holds lock $A$ and waits for lock $B$, while another thread $T_B$ holds lock $B$ and waits for lock $A$.\n\nA deadlock can only arise if at least $1$ thread attempts to acquire the locks in the order $(A, B)$ and at least $1$ thread attempts to acquire them in the order $(B, A)$. Let $n$ be the total number of threads. Each of the $n$ threads independently chooses one of the $2$ acquisition orders with uniform probability, meaning the probability of choosing a specific order is $\\frac{1}{2}$.\n\nLet $k$ be the number of threads that choose the $(A, B)$ order. Consequently, $n-k$ threads choose the $(B, A)$ order. The variable $k$ follows a binomial distribution with parameters $n$ and $p=\\frac{1}{2}$. The probability of having exactly $k$ threads choose the $(A, B)$ order is given by:\n$$P(k) = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^k \\left(\\frac{1}{2}\\right)^{n-k} = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^n$$\n\nFor a deadlock to be possible, there must be at least $1$ thread attempting to acquire $A$ first and at least $1$ thread attempting to acquire $B$ first.\nIf all threads choose the same order, no deadlock can occur. For example, if all $n$ threads choose the $(A, B)$ order, $1$ thread will acquire $A$, then it will successfully acquire $B$ (since no other thread holds it), and then release both. The other $n-1$ threads will proceed sequentially. A symmetric argument holds if all threads choose the $(B, A)$ order.\n\nA deadlock occurs if and only if the number of threads choosing the $(A, B)$ order, $k$, satisfies $k \\ge 1$, and the number of threads choosing the $(B, A)$ order, $n-k$, also satisfies $n-k \\ge 1$. This is equivalent to the condition $1 \\le k \\le n-1$.\n\nThe event of no deadlock is the complement, which occurs if and only if $k=0$ or $k=n$. Since these are mutually exclusive events, the probability of no deadlock is:\n$$P(\\text{no deadlock}) = P(k=0) + P(k=n)$$\nUsing the binomial probability formula:\n$$P(k=0) = \\binom{n}{0} \\left(\\frac{1}{2}\\right)^n = 1 \\cdot \\left(\\frac{1}{2}\\right)^n = \\frac{1}{2^n}$$\n$$P(k=n) = \\binom{n}{n} \\left(\\frac{1}{2}\\right)^n = 1 \\cdot \\left(\\frac{1}{2}\\right)^n = \\frac{1}{2^n}$$\nThus, the total probability of no deadlock is:\n$$P(\\text{no deadlock}) = \\frac{1}{2^n} + \\frac{1}{2^n} = \\frac{2}{2^n} = \\frac{1}{2^{n-1}}$$\nThe probability that a deadlock arises, which we denote as $P_d(n)$, is the complement of this:\n$$P_d(n) = 1 - P(\\text{no deadlock}) = 1 - \\frac{1}{2^{n-1}}$$\n\nNow, we proceed to the second part of the problem. We must find the probability that a deadlock, having occurred, persists after the randomized backoff epoch. Let this conditional probability be $P(\\text{persists} | \\text{deadlock})$. A deadlock state implies there is a thread $T_A$ holding lock $A$ and waiting for lock $B$, and a thread $T_B$ holding lock $B$ and waiting for $A$.\n\nAccording to the problem, in the backoff epoch, each of these $2$ threads, $T_A$ and $T_B$, independently decides whether to release its held lock. The probability of releasing a lock is $r$, where $r \\in (0, 1)$.\n- The probability that $T_A$ releases lock $A$ is $r$.\n- The probability that $T_B$ releases lock $B$ is $r$.\n\nThe complementary probabilities are:\n- The probability that $T_A$ does not release (holds) lock $A$ is $1-r$.\n- The probability that $T_B$ does not release (holds) lock $B$ is $1-r$.\n\nThe deadlock is resolved if at least one of the threads releases its lock. If $T_A$ releases $A$, $T_B$ can acquire $A$ and proceed. If $T_B$ releases $B$, $T_A$ can acquire $B$ and proceed. The circular wait is broken.\nThe deadlock persists if and only if *neither* thread releases its lock. That is, $T_A$ must hold $A$ AND $T_B$ must hold $B$. Since these events are independent, the probability of their conjunction is the product of their individual probabilities:\n$$P(\\text{persists} | \\text{deadlock}) = P(T_A \\text{ holds } A) \\times P(T_B \\text{ holds } B) = (1-r)(1-r) = (1-r)^2$$\n\nThe problem asks for the overall probability that a deadlock persists after the backoff epoch, as a function of $n$ and $r$. This is the probability of the compound event that a deadlock first arises and then subsequently survives the backoff attempt. This is calculated as:\n$$P(\\text{persistent deadlock}) = P(\\text{persists} | \\text{deadlock}) \\times P(\\text{deadlock arises})$$\nSubstituting the expressions we derived:\n$$P(\\text{persistent deadlock}) = (1-r)^2 \\times P_d(n)$$\n$$P(\\text{persistent deadlock}) = (1-r)^2 \\left(1 - \\frac{1}{2^{n-1}}\\right)$$\n\nThis is the final closed-form analytic expression for the probability that a deadlock persists, taking into account both the initial formation of the deadlock and its survival through the resolution protocol.", "answer": "$$\\boxed{\\left(1 - \\frac{1}{2^{n-1}}\\right) (1-r)^{2}}$$", "id": "3659020"}]}