{"hands_on_practices": [{"introduction": "To understand the efficiency of an algorithm, we often begin with a simplified model that captures its core behavior. This practice shows how basic probability theory can reveal a fundamental performance characteristic of the CLOCK algorithm: the average number of pages it must inspect to find a victim. Mastering this type of analysis [@problem_id:3655894] allows us to predict and reason about system performance without getting lost in the details of a specific execution trace.", "problem": "An Operating System (OS) uses the CLOCK Least Recently Used (LRU) approximation algorithm to manage a circular list of page frames. On each page fault, the CLOCK hand advances frame by frame, inspecting the hardware-maintained reference bit $R$ of each frame in order. When the hand inspects a frame with $R=1$, it sets $R \\leftarrow 0$ and advances to the next frame. When it inspects a frame with $R=0$, it selects that frame as the victim and stops scanning for that fault.\n\nConsider a transient memory pressure spike during which page faults occur in a burst. Assume that, at the start of any given fault in the burst, the reference bits $R$ of the frames not yet touched by the hand during that fault are independent across frames and identically distributed with $\\Pr(R=1)=u$ and $\\Pr(R=0)=1-u$, where $u \\in [0,1)$. Assume the number of frames is sufficiently large that the probability of a full wraparound during the scan for a single fault is negligible, so the hand may be modeled as probing an effectively infinite sequence of independent frames until it encounters the first frame with $R=0$.\n\nDefine the random variable $X$ to be the number of frames scanned during a single page fault, counting the victim frame. Starting from the definitions above and basic probability tools, derive the probability mass function of $X$ and then compute the expected value $E[X]$ as a function of $u$. Express your final answer as a closed-form analytic expression in terms of $u$. No rounding is required.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and free of contradictions or ambiguities. It describes a classic scenario in the analysis of algorithms that can be modeled using elementary probability theory. We may proceed with the solution.\n\nThe problem asks for the expected number of frames, $X$, scanned during a single page fault. The process of scanning frames is described as follows: the CLOCK hand inspects frames sequentially. If a frame's reference bit $R$ is $1$, it is reset to $0$ and the hand advances. If $R$ is $0$, the frame is chosen as the victim and the scan terminates.\n\nThe problem provides a probabilistic model for the state of the reference bits at the start of a scan for a single fault. The reference bits $R$ of the frames are independent and identically distributed random variables with:\n$$ \\Pr(R=1) = u $$\n$$ \\Pr(R=0) = 1-u $$\nwhere $u \\in [0,1)$. The scan is modeled as probing an effectively infinite sequence of such frames.\n\nThe random variable $X$ represents the total number of frames scanned. The scan stops at the first frame for which $R=0$. This is a classic sequence of independent Bernoulli trials. Let us define a \"success\" as the event of finding a frame with $R=0$, and a \"failure\" as finding a frame with $R=1$. The probability of success in any single trial (inspecting one frame) is $p = \\Pr(R=0) = 1-u$. The probability of failure is $q = \\Pr(R=1) = u$.\n\nThe random variable $X$ is the number of trials required to achieve the first success. This is, by definition, a geometrically distributed random variable. We can derive its probability mass function (PMF), denoted $P(k) = \\Pr(X=k)$, for any integer $k \\geq 1$.\n\nFor the scan to terminate at the $k$-th frame (i.e., for $X=k$ to occur), two conditions must be met:\n1. The first $k-1$ frames scanned must have their reference bit $R=1$.\n2. The $k$-th frame scanned must have its reference bit $R=0$.\n\nDue to the independence of the reference bits across frames, the probability of this sequence of events is the product of their individual probabilities:\n$$ \\Pr(X=k) = \\underbrace{\\Pr(R=1) \\times \\Pr(R=1) \\times \\dots \\times \\Pr(R=1)}_{k-1 \\text{ times}} \\times \\Pr(R=0) $$\nSubstituting the given probabilities, we get:\n$$ P(k) = \\Pr(X=k) = u^{k-1} (1-u) \\quad \\text{for } k = 1, 2, 3, \\dots $$\nThis is the PMF of the random variable $X$.\n\nThe next step is to compute the expected value of $X$, denoted $E[X]$. By the definition of expectation for a discrete random variable, we have:\n$$ E[X] = \\sum_{k=1}^{\\infty} k \\cdot \\Pr(X=k) $$\nSubstituting the PMF we derived:\n$$ E[X] = \\sum_{k=1}^{\\infty} k \\cdot u^{k-1} (1-u) $$\nWe can factor the constant term $(1-u)$ out of the summation:\n$$ E[X] = (1-u) \\sum_{k=1}^{\\infty} k u^{k-1} $$\nThe summation has the form of an arithmetico-geometric series. We can evaluate it by recalling the formula for a geometric series. For any variable $x$ with $|x|<1$, we have:\n$$ \\sum_{k=0}^{\\infty} x^k = \\frac{1}{1-x} $$\nDifferentiating both sides with respect to $x$ gives:\n$$ \\frac{d}{dx} \\left( \\sum_{k=0}^{\\infty} x^k \\right) = \\frac{d}{dx} \\left( \\frac{1}{1-x} \\right) $$\n$$ \\sum_{k=1}^{\\infty} k x^{k-1} = -1 \\cdot (1-x)^{-2} \\cdot (-1) = \\frac{1}{(1-x)^2} $$\nThe summation in our expression for $E[X]$ is precisely this form, with $x=u$. Since the problem states $u \\in [0,1)$, the condition $|u|<1$ is met, and the series converges.\nSo, we can substitute the result of the summation:\n$$ \\sum_{k=1}^{\\infty} k u^{k-1} = \\frac{1}{(1-u)^2} $$\nNow, we substitute this back into the equation for $E[X]$:\n$$ E[X] = (1-u) \\left( \\frac{1}{(1-u)^2} \\right) $$\n$$ E[X] = \\frac{1-u}{(1-u)^2} $$\nSimplifying the expression yields the final result:\n$$ E[X] = \\frac{1}{1-u} $$\nThis result is consistent with the known formula for the mean of a geometric distribution with success probability $p=1-u$, which is $1/p$.\nThe physical interpretation confirms this result. If $u$ is close to $0$, most bits are $0$, so we expect to find a victim frame very quickly, and $E[X]$ is close to $1$. If $u$ approaches $1$, most bits are $1$, and we expect to scan many frames before finding a victim, so $E[X]$ approaches infinity, which matches the behavior of the derived expression.", "answer": "$$\\boxed{\\frac{1}{1-u}}$$", "id": "3655894"}, {"introduction": "Moving from abstract models to concrete mechanics, this exercise dives into the details of the Enhanced Second-Chance algorithm. By adding a \"dirty\" bit to the decision-making process, the algorithm creates a more nuanced hierarchy of pages to evict, prioritizing clean pages over modified ones. Following the intricate, multi-pass search procedure [@problem_id:3655937] is like running a simulation on paper, building the meticulous, step-by-step precision required to implement, debug, or simply master this important LRU approximation.", "problem": "An operating system implementing a Least Recently Used (LRU) approximation uses the Enhanced Second-Chance algorithm (also known as the Clock algorithm with reference and dirty bits). The algorithm maintains a circular list of frames and a single hand that advances one frame at a time. Each frame has a reference bit $R \\in \\{0,1\\}$ and a dirty bit $D \\in \\{0,1\\}$. When a page replacement is required, the algorithm proceeds as follows:\n\n- Frames are conceptually partitioned into four classes in increasing order of preference to evict: class $0$: $(R=0,D=0)$, class $1$: $(R=0,D=1)$, class $2$: $(R=1,D=0)$, class $3$: $(R=1,D=1)$.\n- The hand starts at its current position and performs sweeps (full circular scans) in increasing class order: first sweep targets class $0$, second sweep targets class $1$, then class $2$, then class $3$. In any sweep, when the hand inspects a frame, if the frame has $R=1$, the algorithm sets $R \\leftarrow 0$ and continues. A frame qualifies for eviction in the current sweep only if its state matches the current target class before any $R$-bit clearing performed in that same sweep. The first qualifying frame encountered in that sweep is selected for eviction.\n- Upon eviction, the new page is immediately loaded into the same frame with initial bits $(R=1,D=0)$, and the hand is advanced to the next frame to continue for the next replacement. Between replacements, assume no memory references occur; the only changes to $R$ arise from the algorithm’s own clearing while scanning.\n- For the purpose of this question, define the number of clock-hand rotations as the total number of frame-to-frame advances divided by the total number of frames $N$. You must count all frame-to-frame advances taken by the hand while searching for victims across all sweeps. Do not count any advance after placing the $k$-th new page; stop immediately after that load.\n\nConsider $N=10$ frames arranged in a circle, labeled in order as frames $1$ through $10$. The initial bits $(R,D)$ of the frames at time zero, starting at frame $1$ and proceeding clockwise, are:\n- frame $1$: $(1,1)$\n- frame $2$: $(1,0)$\n- frame $3$: $(0,0)$\n- frame $4$: $(1,1)$\n- frame $5$: $(0,1)$\n- frame $6$: $(1,0)$\n- frame $7$: $(0,0)$\n- frame $8$: $(1,1)$\n- frame $9$: $(1,0)$\n- frame $10$: $(0,1)$\n\nThe hand initially points to frame $1$. The system must evict and replace $k=5$ pages in sequence, one at a time, using the Enhanced Second-Chance algorithm as specified above.\n\nCompute the exact total number of clock-hand rotations required to complete these $5$ evictions. Express your answer as a reduced fraction. Do not include units. No rounding is necessary.", "solution": "The problem statement describes a specific variant of the Enhanced Second-Chance (or Clock) page replacement algorithm and asks for the total number of clock-hand rotations to perform $k=5$ page evictions. The problem is well-posed and scientifically grounded within the domain of operating systems, although the description of the algorithm requires careful, literal interpretation.\n\nFirst, let us formalize the algorithm for finding a single page to evict, as specified in the problem statement. The algorithm involves a sequence of up to four sweeps, each targeting a specific class of frame $(R,D)$, where $R$ is the reference bit and $D$ is the dirty bit. The classes are ordered by eviction preference: class $0: (0,0)$, class $1: (0,1)$, class $2: (1,0)$, and class $3: (1,1)$.\n\nFor a single page replacement, the search for a victim frame proceeds as follows:\n1.  Begin a sweep for class $0$ frames, i.e., those with state $(R,D) = (0,0)$.\n2.  The hand starts at its current frame. For each frame inspected:\n    a. Let the frame's state be $(R_{current}, D_{current})$.\n    b. Check if $(R_{current}, D_{current})$ matches the target class for the current sweep. This check uses the frame's state *before* any modification in this step. If it matches, this frame is the victim. The search terminates.\n    c. If the frame is not the victim, check if its reference bit $R_{current}$ is $1$. If it is, set it to $0$.\n    d. If the frame was not the victim, the hand advances to the next frame. This movement constitutes one \"frame-to-frame advance\".\n3.  If a full circular scan ($N$ frame inspections) completes without finding a victim in the current sweep, a new sweep begins for the next class in the sequence (class $1$, then class $2$, etc.), starting from the hand's current position.\n\nUpon finding a victim, the new page is loaded into its frame, setting the frame's bits to $(R,D) = (1,0)$. The hand is then advanced to the next frame in the circular list, where it will begin the search for the next page replacement.\n\nWe are given $N=10$ frames, labeled $F_1$ through $F_{10}$. The initial hand position is at $F_1$. The initial states $(R,D)$ are:\n- $F_1: (1,1)$\n- $F_2: (1,0)$\n- $F_3: (0,0)$\n- $F_4: (1,1)$\n- $F_5: (0,1)$\n- $F_6: (1,0)$\n- $F_7: (0,0)$\n- $F_8: (1,1)$\n- $F_9: (1,0)$\n- $F_{10}: (0,1)$\n\nWe will trace the $k=5$ required evictions, tracking the state of all frames, the hand position, and the cumulative number of advances. Let the total number of advances be $A$. Initially, $A=0$.\n\n**Eviction 1**\n- Initial hand position: $F_1$.\n- Initial states: $[(1,1), (1,0), (0,0), (1,1), (0,1), (1,0), (0,0), (1,1), (1,0), (0,1)]$\n- The algorithm begins a sweep for a class $0$ frame, $(0,0)$.\n- **Scan:**\n    - Hand at $F_1$: State is $(1,1)$. Not a victim. Set $R \\leftarrow 0$. $F_1$ becomes $(0,1)$. Advance hand to $F_2$. ($A=1$)\n    - Hand at $F_2$: State is $(1,0)$. Not a victim. Set $R \\leftarrow 0$. $F_2$ becomes $(0,0)$. Advance hand to $F_3$. ($A=2$)\n    - Hand at $F_3$: State is $(0,0)$. This is a class $0$ frame. **Victim found.**\n- **Summary for Eviction 1:**\n    - Advances for this search: $2$.\n    - Total advances $A = 2$.\n    - Victim is $F_3$. It is replaced by a new page, so its state becomes $(1,0)$.\n    - The hand is advanced to the next frame, $F_4$.\n- **State after Eviction 1:**\n    - Frames: $[(0,1), (0,0), (1,0), (1,1), (0,1), (1,0), (0,0), (1,1), (1,0), (0,1)]$\n    - Hand at $F_4$.\n\n**Eviction 2**\n- Hand position: $F_4$.\n- The algorithm begins a sweep for a class $0$ frame, $(0,0)$.\n- **Scan:**\n    - Hand at $F_4$: State is $(1,1)$. Not a victim. Set $R \\leftarrow 0$. $F_4$ becomes $(0,1)$. Advance hand to $F_5$. ($A=2+1=3$)\n    - Hand at $F_5$: State is $(0,1)$. Not a victim. Advance hand to $F_6$. ($A=3+1=4$)\n    - Hand at $F_6$: State is $(1,0)$. Not a victim. Set $R \\leftarrow 0$. $F_6$ becomes $(0,0)$. Advance hand to $F_7$. ($A=4+1=5$)\n    - Hand at $F_7$: State is $(0,0)$. **Victim found.**\n- **Summary for Eviction 2:**\n    - Advances for this search: $3$.\n    - Total advances $A = 5$.\n    - Victim is $F_7$. It is replaced, so its state becomes $(1,0)$.\n    - The hand is advanced to the next frame, $F_8$.\n- **State after Eviction 2:**\n    - Frames: $[(0,1), (0,0), (1,0), (0,1), (0,1), (0,0), (1,0), (1,1), (1,0), (0,1)]$\n    - Hand at $F_8$.\n\n**Eviction 3**\n- Hand position: $F_8$.\n- The algorithm begins a sweep for a class $0$ frame, $(0,0)$.\n- **Scan:**\n    - Hand at $F_8$: State is $(1,1)$. Not a victim. Set $R \\leftarrow 0$. $F_8$ becomes $(0,1)$. Advance to $F_9$. ($A=5+1=6$)\n    - Hand at $F_9$: State is $(1,0)$. Not a victim. Set $R \\leftarrow 0$. $F_9$ becomes $(0,0)$. Advance to $F_{10}$. ($A=6+1=7$)\n    - Hand at $F_{10}$: State is $(0,1)$. Not a victim. Advance to $F_1$. ($A=7+1=8$)\n    - Hand at $F_1$: State is $(0,1)$. Not a victim. Advance to $F_2$. ($A=8+1=9$)\n    - Hand at $F_2$: State is $(0,0)$. **Victim found.**\n- **Summary for Eviction 3:**\n    - Advances for this search: $4$.\n    - Total advances $A = 9$.\n    - Victim is $F_2$. It is replaced, so its state becomes $(1,0)$.\n    - The hand is advanced to the next frame, $F_3$.\n- **State after Eviction 3:**\n    - Frames: $[(0,1), (1,0), (1,0), (0,1), (0,1), (0,0), (1,0), (0,1), (0,0), (0,1)]$\n    - Hand at $F_3$.\n\n**Eviction 4**\n- Hand position: $F_3$.\n- The algorithm begins a sweep for a class $0$ frame, $(0,0)$.\n- **Scan:**\n    - Hand at $F_3$: State is $(1,0)$. Not a victim. Set $R \\leftarrow 0$. $F_3$ becomes $(0,0)$. Advance to $F_4$. ($A=9+1=10$)\n    - Hand at $F_4$: State is $(0,1)$. Not a victim. Advance to $F_5$. ($A=10+1=11$)\n    - Hand at $F_5$: State is $(0,1)$. Not a victim. Advance to $F_6$. ($A=11+1=12$)\n    - Hand at $F_6$: State is $(0,0)$. **Victim found.**\n- **Summary for Eviction 4:**\n    - Advances for this search: $3$.\n    - Total advances $A = 12$.\n    - Victim is $F_6$. It is replaced, so its state becomes $(1,0)$.\n    - The hand is advanced to the next frame, $F_7$.\n- **State after Eviction 4:**\n    - Frames: $[(0,1), (1,0), (0,0), (0,1), (0,1), (1,0), (1,0), (0,1), (0,0), (0,1)]$\n    - Hand at $F_7$.\n\n**Eviction 5**\n- Hand position: $F_7$.\n- The algorithm begins a sweep for a class $0$ frame, $(0,0)$.\n- **Scan:**\n    - Hand at $F_7$: State is $(1,0)$. Not a victim. Set $R \\leftarrow 0$. $F_7$ becomes $(0,0)$. Advance to $F_8$. ($A=12+1=13$)\n    - Hand at $F_8$: State is $(0,1)$. Not a victim. Advance to $F_9$. ($A=13+1=14$)\n    - Hand at $F_9$: State is $(0,0)$. **Victim found.**\n- **Summary for Eviction 5:**\n    - Advances for this search: $2$.\n    - Total advances $A = 14$.\n    - Victim is $F_9$. It is replaced, so its state becomes $(1,0)$.\n    - The hand is advanced to the next frame, $F_{10}$.\n    - The problem requires us to stop counting advances at this point.\n\nThe total number of frame-to-frame advances for all $5$ evictions is $A = 14$.\n\nThe problem defines the number of clock-hand rotations as the total number of advances divided by the total number of frames, $N$.\n$$ \\text{Rotations} = \\frac{A}{N} = \\frac{14}{10} $$\nAs a reduced fraction, this is:\n$$ \\text{Rotations} = \\frac{7}{5} $$", "answer": "$$\\boxed{\\frac{7}{5}}$$", "id": "3655937"}, {"introduction": "LRU approximation algorithms generally perform well, but how do they behave under stress? This practice explores a \"pathological\" scenario where the interaction between a specific memory access pattern and the CLOCK algorithm leads to severe performance degradation. By analyzing this carefully constructed workload [@problem_id:3655915], we can understand the concept of thrashing—a state where the system spends more time swapping pages than doing useful work—and appreciate the importance of matching algorithms to workload characteristics.", "problem": "Consider a virtual memory system with $W \\in \\mathbb{Z}$, $W \\ge 2$, page frames and a single-bit CLOCK (second-chance) page replacement policy. Two disjoint arrays $A$ and $B$ reside in virtual memory, each array occupying one page per element, with sizes $|A| = W - 1$ and $|B| = W + 1$, respectively. The process repeatedly executes the following microbenchmark indefinitely: it performs one sequential sweep over $A$ (touching each of its pages exactly once in some fixed order), then one sequential sweep over $B$ (touching each of its pages exactly once in some fixed order), and repeats this $A$-then-$B$ super-cycle forever. Assume that the initial memory is empty, the CLOCK hand starts at frame $1$, and on every page access the hardware sets the page’s reference bit to $1$. On a page fault, CLOCK examines the frame indicated by the hand; if the reference bit is $1$, it sets it to $0$ and advances the hand; if it is $0$, it evicts that frame and loads the new page there (with its reference bit set to $1$), then advances the hand to the next frame. On a page hit, the hand does not move. No periodic reference-bit resets occur other than those performed by the CLOCK hand during replacement scans.\n\nYou are to analyze the steady-state behavior after transients vanish, focusing on how CLOCK alternates protection (reference-bit value $1$) between $A$ and $B$, producing an oscillation: during the $A$ sweep, pages of $A$ tend to be protected while pages of $B$ are demoted, and during the $B$ sweep, pages of $B$ tend to be protected while pages of $A$ are demoted. To ensure a unique answer and to isolate the oscillation, suppose the access order within each sweep is chosen so that, at the instant of switching from the $A$ sweep to the $B$ sweep in any super-cycle, the first page of $B$ that is referenced is not among the (at most one) $B$ pages currently resident in memory.\n\nLet $F(W)$ denote the exact number of page faults incurred over one complete super-cycle consisting of one sweep of $A$ followed by one sweep of $B$ in this steady state. Provide a closed-form expression for $F(W)$ as a function of $W$. Express your final answer as a symbolic expression in terms of $W$. No rounding is required, and no units are involved.", "solution": "The problem asks for the number of page faults, $F(W)$, in a steady-state super-cycle for a system with $W$ page frames running a CLOCK replacement algorithm. The workload consists of repeated sweeps over two arrays, $A$ and $B$, of sizes $|A|=W-1$ and $|B|=W+1$ respectively.\n\nLet's analyze the system's behavior over one complete super-cycle, which consists of a sweep over array $A$ followed by a sweep over array $B$. The total number of distinct pages in the workload is $|A| + |B| = (W-1) + (W+1) = 2W$. Since the number of distinct pages ($2W$) is greater than the number of available frames ($W$), page faults are inevitable. We are interested in the steady-state behavior, which implies the system's state is cyclical.\n\nFirst, we establish the state of the memory at the two major transition points of a super-cycle: (1) the beginning of the $A$ sweep (which is the end of the $B$ sweep) and (2) the beginning of the $B$ sweep (the end of the $A$ sweep).\n\n1.  **Analysis of the $B$ Sweep's Impact on Memory**\n    The sweep over array $B$ involves accessing $W+1$ distinct pages. Since there are only $W$ frames, it is impossible for all pages of $B$ to be resident simultaneously. More importantly, because the number of pages accessed in this sweep ($W+1$) is strictly greater than the number of frames ($W$), this sweep is guaranteed to flush out any pages that are not part of $B$ itself. If a page from array $A$ were to remain in memory throughout the $B$ sweep, it would imply that only $W-1$ frames were available for the $W+1$ pages of $B$, which would lead to a contradiction. Therefore, at the conclusion of the $B$ sweep, all $W$ frames must be occupied by pages from array $B$. During this sweep, each of the $W+1$ pages of $B$ is accessed once. The last $W$ of these accesses will fill the memory with $W$ distinct pages from $B$. Let's trace the final fault of the $B$ sweep: access to the $(W+1)$-th page of $B$. At this moment, the memory contains $W$ other pages from $B$, all of which have their reference bit set to $1$ because they have been recently accessed. The CLOCK algorithm must find a victim. It scans all $W$ frames, setting each reference bit from $1$ to $0$. After completing a full circle, it evicts the first page it scanned. The new page is loaded with its reference bit set to $1$.\n    Thus, at the beginning of the $A$ sweep, the memory contains $W$ pages from $B$. One of these pages (the one just loaded) has its reference bit set to $1$, while the other $W-1$ pages have their reference bits set to $0$ as a result of the CLOCK scan.\n\n2.  **Page Faults during the $A$ Sweep**\n    The $A$ sweep begins with memory containing $W$ pages from array $B$. The sweep consists of accessing the $W-1$ pages of array $A$ sequentially.\n    -   The first access, to page $a_1$, is a page fault, as no pages from $A$ are in memory. The CLOCK algorithm seeks a victim. There are $W-1$ pages from $B$ with a reference bit of $0$. The algorithm will quickly find one of these, evict it, and load $a_1$. The reference bit of $a_1$ is set to $1$.\n    -   The second access, to $a_2$, is also a page fault. Again, the algorithm will find another page from $B$ with a reference bit of $0$ to evict.\n    -   This process continues for all $W-1$ pages of $A$. Each access results in a page fault because each page of $A$ is accessed for the first time in this super-cycle. Each fault leads to the eviction of one of the initial $B$ pages.\n    Therefore, the sweep over array $A$ incurs exactly $W-1$ page faults.\n\n3.  **State of Memory at the End of the $A$ Sweep**\n    After the $A$ sweep, all $W-1$ pages of $A$ have been brought into memory, replacing $W-1$ pages of $B$. All pages of $A$ have their reference bit set to $1$, as they were just accessed. One page from array $B$ remains in memory. Let's call it $b_{rem}$. What is its reference bit? At the start of the $A$ sweep, one B-page had its bit set to $1$ and the others to $0$. The $W-1$ faults for the $A$ sweep evicted the $W-1$ pages with bit $0$. So $b_{rem}$ is the page that started with reference bit $1$. During the $A$ sweep, its bit may have been cleared to $0$ if the CLOCK hand happened to sweep past it. Whether the bit is $1$ or $0$, let's analyze the subsequent $B$ sweep. In the most thorough analysis, one can show the bit becomes $0$. During the first fault for $a_1$, the hand might have to sweep past $b_{rem}$ (clearing its bit) to find a victim with bit $0$. If not, in a later fault for some $a_i$, the hand might circularly wrap and pass it. In any steady state, this bit will be cleared. So, at the start of the $B$ sweep, memory contains the $W-1$ pages from $A$ with reference bits of $1$, and one page from $B$, $b_{rem}$, with its reference bit being $0$.\n\n4.  **Page Faults during the $B$ Sweep**\n    The $B$ sweep begins with memory containing $\\{a_1, \\ldots, a_{W-1}\\}$ (all with reference bit $1$) and $\\{b_{rem}\\}$ (with reference bit $0$). The sweep accesses the $W+1$ pages of $B$ in a fixed order.\n    -   The first access is to a page $b_1$. The problem specifies that $b_1$ is not the page currently resident, i.e., $b_1 \\neq b_{rem}$. Thus, this access is a page fault. The CLOCK algorithm needs a victim and seeks a page with reference bit $0$. The page $b_{rem}$ is the only such page. It is found and evicted. Page $b_1$ is loaded with its reference bit set to $1$.\n    -   The second access is to page $b_2$. The pages currently in memory are $\\{a_1, ..., a_{W-1}\\} \\cup \\{b_1\\}$. Page $b_2$ is not among them, so this is a page fault. To find a victim, the CLOCK hand will scan from its current position. It will find a page from $A$ whose reference bit was cleared to $0$ during the scan for the previous fault. This A-page is evicted and $b_2$ is loaded.\n    -   This pattern continues for every page access in the $B$ sweep. For each access to page $b_i$ ($i \\in \\{1, \\dots, W+1\\}$), the page is not in memory. This is because the memory can only hold $W$ pages, and the pages of $B$ are accessed sequentially for the first time in this sweep. Therefore, every access in the $B$ sweep results in a page fault.\n    The number of accesses in the $B$ sweep is $|B|=W+1$. Thus, the sweep over array $B$ incurs exactly $W+1$ page faults.\n\n5.  **Total Page Faults in a Super-cycle**\n    The total number of page faults, $F(W)$, in one steady-state super-cycle is the sum of the faults from the $A$ sweep and the $B$ sweep.\n    $$F(W) = (\\text{faults in } A \\text{ sweep}) + (\\text{faults in } B \\text{ sweep})$$\n    $$F(W) = (W-1) + (W+1)$$\n    $$F(W) = 2W$$\n    This result is consistent with the general observation that the working set for each phase of the program is just the right size to displace the working set of the other phase from memory, leading to minimal reuse of pages across super-cycle boundaries and thus high fault rates. Every memory access in the entire super-cycle results in a page fault in the steady state. The total number of accesses is $|A| + |B| = (W-1) + (W+1) = 2W$. Thus, the total number of faults is $2W$.", "answer": "$$\\boxed{2W}$$", "id": "3655915"}]}