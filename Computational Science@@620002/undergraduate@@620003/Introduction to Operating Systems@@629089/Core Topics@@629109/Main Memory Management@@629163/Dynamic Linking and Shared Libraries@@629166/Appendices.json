{"hands_on_practices": [{"introduction": "The core benefit of shared libraries is their ability to save memory by allowing multiple processes to use a single copy of the library's code. This practice delves into the mechanism that makes this possible: Position-Independent Code (PIC). By creating a computational model, you will quantify the memory overhead caused by relocations in non-PIC code and directly calculate the savings achieved by using PIC, solidifying your understanding of why it is fundamental to modern operating systems [@problem_id:3636956].", "problem": "You are to model and quantify the impact of dynamic relocation on memory sharing when loading shared libraries in an operating system that uses virtual memory with pages and copy-on-write. You will compare a non-position-independent code (non-PIC) shared object against a position-independent code (PIC) shared object. The goal is to derive, then compute, the additional private memory induced by relocations under each model across multiple processes, explain why non-PIC text relocations can fail under a strict write-xor-execute policy, and how the Global Offset Table (GOT) and Procedure Linkage Table (PLT) design move relocation writes out of the read-only text segment.\n\nFundamental base to use:\n- Definition of virtual memory pages of size $P$ bytes, with copy-on-write semantics: if $k$ processes map the same file-backed read-only page, they share one physical copy. If any process writes to that page, the operating system creates a private copy for that process. Writing to a page with copy-on-write therefore increases private memory usage by $P$ bytes per process beyond the single shared copy.\n- Dynamic relocation by the runtime linker writes resolved addresses into relocation targets.\n- In the non-position-independent model, absolute addresses in the text segment require text relocations; writing into the text segment causes either copy-on-write of those pages per process, or failure under a strict write-xor-execute policy that forbids making the text segment writable.\n- In the position-independent model, the Global Offset Table (GOT) holds addresses to be resolved, and the Procedure Linkage Table (PLT) uses indirect jumps through the GOT. Relocation writes are redirected into writable data pages (GOT), keeping the text segment read-only and fully shareable.\n\nMathematical model and required computation:\n- Let there be $N$ processes concurrently mapping the same shared object.\n- Let page size be $P$ bytes.\n- Let text segment size be $T$ bytes. Let the set of non-PIC text relocation offsets be $\\mathcal{O} = \\{o_1, o_2, \\dots, o_a\\}$, where each $o_i$ is a byte offset within $[0, T-1]$ from the start of the text segment that the dynamic linker writes to.\n- Let the GOT have total size $G$ bytes, divided into entries of size $E$ bytes. Let the set of GOT indices requiring relocation be $\\mathcal{I} = \\{i_1, i_2, \\dots, i_b\\}$, where each $i_j$ is an integer index such that $0 \\le i_j \\cdot E < G$. These GOT relocations occur under both non-PIC and PIC.\n- Define the set of text pages dirtied by relocations as $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor \\dfrac{o}{P} \\right\\rfloor \\,\\middle|\\, o \\in \\mathcal{O} \\right\\}$ with cardinality $U_{\\text{text}} = \\left|\\mathcal{P}_{\\text{text}}\\right|$.\n- Define the set of GOT pages dirtied by relocations as $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor \\dfrac{i \\cdot E}{P} \\right\\rfloor \\,\\middle|\\, i \\in \\mathcal{I} \\right\\}$ with cardinality $U_{\\text{got}} = \\left|\\mathcal{P}_{\\text{got}}\\right|$.\n- Additional private memory solely due to relocations is computed using copy-on-write semantics as follows:\n  - For non-PIC, both the text and GOT pages are dirtied: \n    $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P.$$\n  - For PIC, only the GOT pages are dirtied (text remains read-only and fully shared):\n    $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P.$$\n- A strict write-xor-execute policy indicator $\\sigma \\in \\{0,1\\}$ is given, where $\\sigma = 1$ forbids text relocations. The failure indicator is \n  $$F = \\begin{cases}\n  1, & \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0,\\\\\n  0, & \\text{otherwise.}\n  \\end{cases}$$\n\nYour program must compute, for each test case, the $4$-tuple \n$$\\left[F,\\; M_{\\text{nonpic}},\\; M_{\\text{pic}},\\; M_{\\text{nonpic}} - M_{\\text{pic}}\\right],$$ \nwhere all quantities are integers measured in bytes. The difference $M_{\\text{nonpic}} - M_{\\text{pic}}$ represents the bytes of additional private memory saved by using position-independent code; it will be non-negative under this model.\n\nUnits: All memory sizes must be expressed in bytes.\n\nAngle units: Not applicable.\n\nPercentages: Not applicable.\n\nTest suite to implement inside your program:\n- Case A (general case):\n  - $P = 4096$, $N = 10$, $T = 16384$, $G = 4096$, $E = 8$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{100, 4095, 4096, 8191\\}$,\n  - $\\mathcal{I} = \\{0, 1\\}$.\n- Case B (no text relocations, GOT relocations only, strict policy enabled):\n  - $P = 4096$, $N = 5$, $T = 4096$, $G = 4096$, $E = 8$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\emptyset$,\n  - $\\mathcal{I} = \\{0, 400\\}$.\n- Case C (all text relocations within a single page, repeated offsets, boundary condition on deduplication):\n  - $P = 1024$, $N = 3$, $T = 2048$, $G = 1024$, $E = 16$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\{0, 1, 1023\\}$,\n  - $\\mathcal{I} = \\{0\\}$.\n- Case D (GOT entries span two pages due to entry size, multiple text pages touched, smallest $N$ above $1$):\n  - $P = 4096$, $N = 2$, $T = 32768$, $G = 9000$, $E = 500$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{0, 5000, 9000, 16000, 32000\\}$,\n  - $\\mathcal{I} = \\{0, 9\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a comma-separated list of the per-test results, enclosed in a single pair of square brackets. Each per-test result must itself be a list of four integers in square brackets. No spaces are allowed anywhere in the output.\n- Example overall shape: \n  - For $k$ test cases, output should look like \n  $$\\text{\"[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],\\dots,[r_{k,1},r_{k,2},r_{k,3},r_{k,4}]]\"}.$$", "solution": "The problem requires an analysis of the memory overhead incurred by dynamic relocations for shared libraries, comparing position-independent code (PIC) with non-position-independent code (non-PIC). The analysis is situated within the context of a modern operating system employing virtual memory with paged memory management and a copy-on-write (COW) mechanism.\n\n### Fundamental Principles\n\n1.  **Virtual Memory and Paging**: The operating system provides each process with its own private virtual address space, which is mapped to physical memory in discrete units called pages. A page is a contiguous block of virtual memory of size $P$ bytes.\n\n2.  **Shared Libraries and Copy-on-Write (COW)**: To conserve physical memory, when multiple processes load the same shared library, the OS maps their corresponding virtual pages to the same physical pages of memory. Initially, these pages are marked as read-only. If any process attempts to write to such a shared page, the COW mechanism is triggered. The OS intercepts the write, allocates a new physical page, copies the content of the original shared page to it, and maps the writing process's virtual page to this new, private, writable copy. This ensures process isolation while maximizing memory sharing for read-only data. The cost of a COW fault on a single page for $N$ processes that all eventually write to it is the creation of $N-1$ new physical pages, one for each process after the first write triggers the initial split. The total private memory becomes $N \\cdot P$ bytes, an increase of $(N-1) \\cdot P$ bytes over the single shared page.\n\n3.  **Dynamic Relocation**: When a program uses a shared library, the addresses of functions and global variables in that library are not known at compile time. The dynamic linker resolves these symbolic references at load time or run time by writing the actual virtual addresses into designated locations. These write operations are called relocations.\n\n4.  **Non-Position-Independent Code (non-PIC)**: In this older model, the compiler generates code that uses absolute addresses. Consequently, the machine code itself (the `.text` segment) contains locations that must be patched by the dynamic linker with the correct addresses. These are known as text relocations. When a process loads a non-PIC shared library, the dynamic linker must write into its `.text` segment. This act of writing triggers COW for every page containing a relocation target.\n\n5.  **Position-Independent Code (PIC) and the GOT/PLT**: To avoid text relocations, modern systems use PIC. All memory accesses are made relative to the current instruction pointer. For external symbols, this is mediated by two structures:\n    *   **Global Offset Table (GOT)**: A table located in the writable data segment that stores the absolute addresses of external functions and variables.\n    *   **Procedure Linkage Table (PLT)**: A read-only table in the text segment containing small code stubs. When a function in the shared library is called for the first time, its PLT entry calls a resolver routine in the dynamic linker. The resolver finds the function's true address and writes it into the corresponding GOT entry. Subsequent calls to the same function are redirected via the PLT to the GOT, which now contains the correct address, and jump to it directly.\n\n    This design ensures that all relocation writes occur in the writable data segment (specifically, the GOT), leaving the text segment pristine (read-only). The text segment can thus be shared among all processes without ever triggering COW faults due to relocations.\n\n6.  **Write-XOR-Execute (W^X)**: A security policy that prevents a memory page from being both writable and executable simultaneously. This mitigates certain classes of exploits, such as buffer overflows that inject and execute malicious code. Under a strict W^X policy, attempting to make an executable page (like one in the `.text` segment) writable will fail. Consequently, loading a non-PIC shared library that requires text relocations is impossible under such a policy.\n\n### Mathematical Model Derivation\n\nThe problem provides a formal model to quantify the memory impact.\n\n-   **Unique Dirtied Pages**: A relocation at offset $o$ dirties the page with index $\\left\\lfloor o/P \\right\\rfloor$. Since multiple relocations can fall within the same page, we must count the number of *unique* pages affected. The set of unique text pages dirtied is $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor o/P \\right\\rfloor \\mid o \\in \\mathcal{O} \\right\\}$, and its cardinality is $U_{\\text{text}} = |\\mathcal{P}_{\\text{text}}|$. Similarly, for the GOT, a relocation for entry $i$ occurs at offset $i \\cdot E$. The set of unique GOT pages dirtied is $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor (i \\cdot E)/P \\right\\rfloor \\mid i \\in \\mathcal{I} \\right\\}$, with cardinality $U_{\\text{got}} = |\\mathcal{P}_{\\text{got}}|$.\n\n-   **Additional Private Memory Calculation**: For each unique page that is written to, $N-1$ private copies are created across the $N$ processes, each of size $P$.\n    -   For a **non-PIC** library, both text and GOT relocations occur. The total number of unique dirtied pages is $U_{\\text{text}} + U_{\\text{got}}$. The total additional private memory is therefore:\n        $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P$$\n    -   For a **PIC** library, only GOT relocations occur. The text segment is not written to, so $U_{\\text{text}}$ does not contribute to the COW overhead. The additional private memory is:\n        $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P$$\n\n-   **Failure Indicator ($F$)**: The indicator models the effect of a W^X policy. If the policy is strict ($\\sigma=1$) and there are any text relocations ($U_{\\text{text}} > 0$), the loading process fails.\n    $$F = \\begin{cases} 1, & \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0 \\\\ 0, & \\text{otherwise} \\end{cases}$$\n\n-   **Memory Savings**: The difference $M_{\\text{nonpic}} - M_{\\text{pic}}$ quantifies the memory savings achieved by using PIC, which is attributable entirely to avoiding text relocations:\n    $$M_{\\text{nonpic}} - M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{text}} \\cdot P$$\n\n### Computation for Test Cases\n\nThe solution requires calculating the 4-tuple $\\left[F, M_{\\text{nonpic}}, M_{\\text{pic}}, M_{\\text{nonpic}} - M_{\\text{pic}}\\right]$ for each provided test case. This involves determining $U_{\\text{text}}$ and $U_{\\text{got}}$ by finding the number of unique page indices for the given relocation offsets and then applying the formulas above.\n\n**Case A:** $P=4096, N=10, \\sigma=0, \\mathcal{O}=\\{100, 4095, 4096, 8191\\}, \\mathcal{I}=\\{0, 1\\}, E=8$.\n-   $U_{\\text{text}}$: Offsets $100, 4095$ map to page $\\lfloor 100/4096 \\rfloor = \\lfloor 4095/4096 \\rfloor = 0$. Offsets $4096, 8191$ map to page $\\lfloor 4096/4096 \\rfloor = \\lfloor 8191/4096 \\rfloor = 1$. The set of unique pages is $\\{0, 1\\}$, so $U_{\\text{text}}=2$.\n-   $U_{\\text{got}}$: Indices $0, 1$ give offsets $0 \\cdot 8=0$ and $1 \\cdot 8=8$. Both map to page $\\lfloor 0/4096 \\rfloor = \\lfloor 8/4096 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=0$ since $\\sigma=0$.\n-   $M_{\\text{nonpic}} = (10-1) \\cdot (2+1) \\cdot 4096 = 9 \\cdot 3 \\cdot 4096 = 110592$ bytes.\n-   $M_{\\text{pic}} = (10-1) \\cdot 1 \\cdot 4096 = 9 \\cdot 4096 = 36864$ bytes.\n-   Difference = $110592 - 36864 = 73728$ bytes.\n-   Result: $[0, 110592, 36864, 73728]$\n\n**Case B:** $P=4096, N=5, \\sigma=1, \\mathcal{O}=\\emptyset, \\mathcal{I}=\\{0, 400\\}, E=8$.\n-   $U_{\\text{text}}=0$ since $\\mathcal{O}$ is empty.\n-   $U_{\\text{got}}$: Indices $0, 400$ give offsets $0, 3200$. Both map to page $\\lfloor 0/4096 \\rfloor = \\lfloor 3200/4096 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=0$ since $U_{\\text{text}}=0$.\n-   $M_{\\text{nonpic}} = (5-1) \\cdot (0+1) \\cdot 4096 = 4 \\cdot 4096 = 16384$ bytes.\n-   $M_{\\text{pic}} = (5-1) \\cdot 1 \\cdot 4096 = 4 \\cdot 4096 = 16384$ bytes.\n-   Difference = $0$ bytes.\n-   Result: $[0, 16384, 16384, 0]$\n\n**Case C:** $P=1024, N=3, \\sigma=1, \\mathcal{O}=\\{0, 1, 1023\\}, \\mathcal{I}=\\{0\\}, E=16$.\n-   $U_{\\text{text}}$: Offsets $0, 1, 1023$ all map to page $\\lfloor 0/1024 \\rfloor = \\dots = \\lfloor 1023/1024 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{text}}=1$.\n-   $U_{\\text{got}}$: Index $0$ gives offset $0$, which maps to page $\\lfloor 0/1024 \\rfloor = 0$. The set is $\\{0\\}$, so $U_{\\text{got}}=1$.\n-   $F=1$ since $\\sigma=1$ and $U_{\\text{text}}=1 > 0$.\n-   $M_{\\text{nonpic}} = (3-1) \\cdot (1+1) \\cdot 1024 = 2 \\cdot 2 \\cdot 1024 = 4096$ bytes.\n-   $M_{\\text{pic}} = (3-1) \\cdot 1 \\cdot 1024 = 2 \\cdot 1024 = 2048$ bytes.\n-   Difference = $2048$ bytes.\n-   Result: $[1, 4096, 2048, 2048]$\n\n**Case D:** $P=4096, N=2, \\sigma=0, \\mathcal{O}=\\{0, 5000, 9000, 16000, 32000\\}, \\mathcal{I}=\\{0, 9\\}, E=500$.\n-   $U_{\\text{text}}$: Page indices are $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 5000/4096 \\rfloor=1$, $\\lfloor 9000/4096 \\rfloor=2$, $\\lfloor 16000/4096 \\rfloor=3$, $\\lfloor 32000/4096 \\rfloor=7$. The set is $\\{0, 1, 2, 3, 7\\}$, so $U_{\\text{text}}=5$.\n-   $U_{\\text{got}}$: Indices $0, 9$ give offsets $0, 4500$. Page indices are $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 4500/4096 \\rfloor=1$. The set is $\\{0, 1\\}$, so $U_{\\text{got}}=2$.\n-   $F=0$ since $\\sigma=0$.\n-   $M_{\\text{nonpic}} = (2-1) \\cdot (5+2) \\cdot 4096 = 1 \\cdot 7 \\cdot 4096 = 28672$ bytes.\n-   $M_{\\text{pic}} = (2-1) \\cdot 2 \\cdot 4096 = 1 \\cdot 2 \\cdot 4096 = 8192$ bytes.\n-   Difference = $28672 - 8192 = 20480$ bytes.\n-   Result: $[0, 28672, 8192, 20480]$", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long long P, N, T, G, E;\n    int sigma;\n    const int* O; // Pointer to array of text relocation offsets\n    int O_size;   // Size of O array\n    const int* I; // Pointer to array of GOT indices\n    int I_size;   // Size of I array\n} TestCase;\n\n// Comparison function for qsort\nstatic int compare_ints(const void *a, const void *b) {\n    int int_a = *((const int*)a);\n    int int_b = *((const int*)b);\n    if (int_a < int_b) return -1;\n    if (int_a > int_b) return 1;\n    return 0;\n}\n\n// Helper function to count unique pages dirtied by relocations.\n// For text relocations, pass entry_size = 1.\n// For GOT relocations, pass entry_size = E, and items = indices.\nstatic int count_unique_pages(const int* items, int count, long long page_size, long long entry_size) {\n    if (count == 0) {\n        return 0;\n    }\n\n    int* page_indices = malloc(count * sizeof(int));\n    if (page_indices == NULL) {\n        // This should not happen in this controlled environment.\n        fprintf(stderr, \"Fatal: Memory allocation failed.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Calculate page indices for each relocation target\n    for (int i = 0; i < count; ++i) {\n        long long offset = (long long)items[i] * entry_size;\n        page_indices[i] = (int)(offset / page_size);\n    }\n\n    // Sort to bring duplicates together\n    qsort(page_indices, count, sizeof(int), compare_ints);\n\n    // Count unique elements in the sorted array\n    int unique_count = 1;\n    for (int i = 1; i < count; ++i) {\n        if (page_indices[i] != page_indices[i - 1]) {\n            unique_count++;\n        }\n    }\n\n    free(page_indices);\n    return unique_count;\n}\n\nint main(void) {\n    // Define the relocation data for the test cases.\n    const int O_A[] = {100, 4095, 4096, 8191};\n    const int I_A[] = {0, 1};\n\n    const int* O_B = NULL; // Empty set\n    const int I_B[] = {0, 400};\n\n    const int O_C[] = {0, 1, 1023};\n    const int I_C[] = {0};\n\n    const int O_D[] = {0, 5000, 9000, 16000, 32000};\n    const int I_D[] = {0, 9};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {4096, 10, 16384, 4096, 8, 0, O_A, sizeof(O_A)/sizeof(O_A[0]), I_A, sizeof(I_A)/sizeof(I_A[0])}, // Case A\n        {4096, 5, 4096, 4096, 8, 1, O_B, 0, I_B, sizeof(I_B)/sizeof(I_B[0])}, // Case B\n        {1024, 3, 2048, 1024, 16, 1, O_C, sizeof(O_C)/sizeof(O_C[0]), I_C, sizeof(I_C)/sizeof(I_C[0])}, // Case C\n        {4096, 2, 32768, 9000, 500, 0, O_D, sizeof(O_D)/sizeof(O_D[0]), I_D, sizeof(I_D)/sizeof(I_D[0])} // Case D\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long results[num_cases][4];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // U_text: number of unique text pages dirtied\n        long long U_text = count_unique_pages(tc.O, tc.O_size, tc.P, 1);\n        \n        // U_got: number of unique GOT pages dirtied\n        long long U_got = count_unique_pages(tc.I, tc.I_size, tc.P, tc.E);\n        \n        // F: Failure indicator\n        long long F = (tc.sigma == 1 && U_text > 0) ? 1 : 0;\n        \n        // M_nonpic: Additional private memory for non-PIC\n        long long M_nonpic = (tc.N - 1) * (U_text + U_got) * tc.P;\n        \n        // M_pic: Additional private memory for PIC\n        long long M_pic = (tc.N - 1) * U_got * tc.P;\n        \n        // M_diff: Memory savings from using PIC\n        long long M_diff = M_nonpic - M_pic;\n\n        results[i][0] = F;\n        results[i][1] = M_nonpic;\n        results[i][2] = M_pic;\n        results[i][3] = M_diff;\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%lld,%lld,%lld,%lld]\", results[i][0], results[i][1], results[i][2], results[i][3]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3636956"}, {"introduction": "Beyond memory efficiency, dynamic linking offers powerful flexibility, most notably through symbol interposition. This technique allows a program to replace symbols from other libraries at runtime, enabling features like debugging, monitoring, or custom-tailored functionality. This exercise challenges you to model the dynamic linker's resolution logic, building a decision engine that predicts which version of a function will be called based on factors like `LD_PRELOAD`, secure execution mode, and symbol visibility [@problem_id:3636919].", "problem": "You will implement a complete, runnable program that models dynamic linker symbol interposition for a single symbol named \"open\" under a simplified, but scientifically sound abstraction of Executable and Linkable Format (ELF) runtime resolution. The program must determine, for a fixed test suite, which objectâ€™s definition of \"open\" is chosen by the runtime linker, and whether this choice constitutes symbol interposition via the Load Preload (LD_PRELOAD) mechanism. The program must produce a single line of output encoding these results.\n\nThe fundamental base for this task is the following well-tested facts and core definitions from operating systems and dynamic linking. The dynamic linker constructs a global resolution scope with an ordered search list; earlier entries in the list provide interposition over later ones. When LD_PRELOAD is applied, its libraries are placed at the front of the search order. In secure execution contexts (for example, set-user-ID binaries inducing secure mode in the dynamic loader), environment-based preloading is ignored. A symbol definition must be globally exported with default visibility and match the required symbol version to be eligible for resolution. Hidden visibility prevents external interposition by making the symbol non-preemptable, and version mismatches are rejected.\n\nModel the runtime resolution using the following definitions. Let there be $n$ dynamically loaded objects (including the main executable). Each object is described by a tuple of attributes $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$, where:\n- $\\text{id} \\in \\mathbb{Z}$ is the identifier to report in the result (for example, $0$ for the main executable).\n- $\\text{is\\_main} \\in \\{0,1\\}$ indicates whether the object is the main executable ($1$) or not ($0$).\n- $\\text{load\\_source} \\in \\{0,1\\}$ indicates normal dependency ($0$) or LD\\_PRELOAD ($1$).\n- $\\text{preload\\_order} \\in \\mathbb{Z}$ is the position among LD\\_PRELOAD libraries (lower numbers indicate earlier in the search list); it is set to $-1$ for non-LD\\_PRELOAD objects.\n- $\\text{dep\\_order} \\in \\mathbb{Z}$ is the dependency load order among normal dependencies (lower numbers indicate earlier in the search list); it is set to $-1$ for non-dependency objects such as the main executable.\n- $\\text{defines} \\in \\{0,1\\}$ indicates whether the object defines the symbol \"open\".\n- $\\text{visibility} \\in \\{0,1\\}$ indicates default ($0$) or hidden ($1$) visibility for the symbol \"open\".\n- $\\text{version} \\in \\mathbb{Z}$ is the symbol version provided by the object for \"open\".\n\nLet the global required version be $V_{\\text{req}} \\in \\mathbb{Z}$, and let $\\text{secure} \\in \\{0,1\\}$ indicate whether secure execution is active ($1$) or not ($0$). The dynamic linker's search order is modeled as follows:\n- If $\\text{secure} = 0$, the search list begins with LD\\_PRELOAD libraries sorted by ascending $\\text{preload\\_order}$, then the main executable (the unique object with $\\text{is\\_main} = 1$), then normal dependencies sorted by ascending $\\text{dep\\_order}$.\n- If $\\text{secure} = 1$, LD\\_PRELOAD libraries are ignored, and the search list begins with the main executable, then normal dependencies sorted by ascending $\\text{dep\\_order}$.\n\nDefine the eligibility predicate $P(o)$ for an object $o$ as $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$. The resolution function $R$ returns the $\\text{id}$ of the first object in the search list for which $P(o)$ is true, or $-1$ if no such object exists. Define the interposition indicator $I$ to be $1$ if the chosen object has $\\text{load\\_source} = 1$, and $0$ otherwise; if $R = -1$, then $I = 0$.\n\nImplement a program in the C language that hardcodes the test suite below and prints the results for all cases on a single line in the specified format. The program must not perform any file input or output, and must not rely on any operating system facilities beyond basic computation and printing. The program must compute $R$ and $I$ for each test case by constructing the search order according to the rules above and applying the predicate $P$.\n\nTest suite:\n- Case $1$ (happy path with LD\\_PRELOAD interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - Main executable $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - Preload library $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - Normal dependency $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $2$ (secure execution ignores LD\\_PRELOAD):\n  - $\\text{secure} = 1$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $3$ (hidden visibility prevents interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=1, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $4$ (version mismatch in LD\\_PRELOAD causes fallback):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $5$ (multiple LD\\_PRELOAD libraries, order determines interposition):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 4$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L3$: $(\\text{id}=3, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$.\n- Case $6$ (no eligible provider: boundary case):\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$.\n  - Objects:\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$.\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$.\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=30)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $12$ integers: for each test case $i$ from $1$ to $6$, output the chosen provider $\\text{id}$, followed by the interposition indicator. The format is $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$ with no extra whitespace or text.", "solution": "The user has provided a problem statement that requires the implementation of a computational model for dynamic linker symbol resolution. The first step is to validate the problem statement according to the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides a detailed model for dynamic linking symbol resolution, defined by the following components:\n\n- **Objects**: A set of $n$ dynamically loaded objects, each described by a tuple of attributes: $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$.\n  - $\\text{id} \\in \\mathbb{Z}$: A unique identifier.\n  - $\\text{is\\_main} \\in \\{0,1\\}$: $1$ if the object is the main executable.\n  - $\\text{load\\_source} \\in \\{0,1\\}$: $1$ if loaded via `LD_PRELOAD`, $0$ otherwise.\n  - $\\text{preload\\_order} \\in \\mathbb{Z}$: Sort key for `LD_PRELOAD` libraries (lower is first), or $-1$.\n  - $\\text{dep\\_order} \\in \\mathbb{Z}$: Sort key for normal dependencies (lower is first), or $-1$.\n  - $\\text{defines} \\in \\{0,1\\}$: $1$ if the object provides the symbol \"open\".\n  - $\\text{visibility} \\in \\{0,1\\}$: $0$ for default (globally visible), $1$ for hidden.\n  - $\\text{version} \\in \\mathbb{Z}$: The version of the provided symbol.\n- **Global State**:\n  - $V_{\\text{req}} \\in \\mathbb{Z}$: The required version of the symbol.\n  - $\\text{secure} \\in \\{0,1\\}$: $1$ if secure execution mode is active.\n- **Search Order Rules**:\n  1. If $\\text{secure} = 0$: The search order is (1) `LD_PRELOAD` libraries, sorted by ascending `preload_order`; (2) the main executable; (3) normal dependencies, sorted by ascending `dep_order`.\n  2. If $\\text{secure} = 1$: `LD_PRELOAD` libraries are ignored. The search order is (1) the main executable; (2) normal dependencies, sorted by ascending `dep_order`.\n- **Eligibility Predicate**: An object $o$ is an eligible provider if the predicate $P(o)$ is true, where $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$.\n- **Resolution Function ($R$)**: Returns the $\\text{id}$ of the *first* object in the constructed search list for which $P(o)$ is true. If no such object exists, $R$ returns $-1$.\n- **Interposition Indicator ($I$)**: $I=1$ if the resolved object has $\\text{load\\_source} = 1$. Otherwise, $I=0$. If no object is resolved ($R=-1$), $I=0$.\n- **Test Suite**: Six specific test cases are provided, enumerating all object attributes and global state variables for each case.\n- **Output Format**: A single line of text: $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is grounded in the established principles of dynamic linking in modern operating systems like Linux (which uses ELF). The concepts of search order, `LD_PRELOAD` interposition, the effect of secure execution on preloading (e.g., for `setuid` executables), symbol visibility (`default` vs. `hidden`), and symbol versioning are all accurate, albeit simplified, representations of real-world mechanisms. The model is a sound abstraction of a complex computer science topic.\n- **Well-Posed**: The problem is well-posed. The rules for constructing the search list are explicit and cover all cases defined by the `secure` flag. The sorting criteria are unambiguous. The resolution function is precisely defined to find the *first* match, ensuring a unique solution for each test case.\n- **Objective**: The problem is stated in objective, formal language. All parameters are numerical or binary flags. The logic is based on conditional rules and a precisely defined predicate, leaving no room for subjective interpretation.\n- **Completeness and Consistency**: The problem is self-contained. All necessary data for each of the six test cases are fully specified. The rules are internally consistent and sufficient to compute the required results.\n- **Feasibility and Realism**: The model is a computational abstraction and is perfectly feasible to implement. The data provided are simple integers that present no physical or dimensional inconsistencies.\n- **Structure and Clarity**: The problem is well-structured. The terms are clearly defined (e.g., $P(o)$, $R$, $I$). The logic flows from data definition to search order construction, and finally to resolution, which is a clear and logical sequence.\n- **Substance**: The problem is not trivial. It requires careful implementation of sorting and conditional logic to correctly model the linker's behavior across different scenarios. It is a legitimate test of understanding and implementing a specified algorithm.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, scientifically grounded, and computationally solvable problem. I will proceed with providing a solution.\n\n### Solution\n\nThe task is to implement an algorithm that simulates the symbol resolution process of a dynamic linker based on a set of formal rules. The solution will be structured as a C program that processes a hardcoded suite of six test cases. For each case, the program must determine the resolved object's identifier, $R$, and an interposition flag, $I$.\n\nThe core of the algorithm involves two main phases for each test case: constructing the ordered symbol search list and then iterating through that list to find the first eligible provider.\n\n**1. Data Representation**\nWe will define C structures to represent the objects and test cases described in the problem. An `Object` structure will store the tuple of attributes for a single library or executable. A `TestCase` structure will contain the global parameters for a scenario ($V_{\\text{req}}$, $\\text{secure}$), the number of objects $n$, and an array of `Object` structures.\n\n**2. Search List Construction**\nFor each test case, the ordered search list must be constructed. This process is governed by the $\\text{secure}$ flag and involves sorting.\n- First, we partition the array of objects into three categories: `LD_PRELOAD` libraries ($\\text{load\\_source} = 1$), the main executable ($\\text{is\\_main} = 1$), and normal dependencies.\n- Next, we sort the `LD_PRELOAD` libraries based on their $\\text{preload\\_order}$ in ascending order.\n- We then sort the normal dependencies based on their $\\text{dep\\_order}$ in ascending order.\n- Finally, we assemble the final search list, which is an array of pointers to `Object`s.\n  - If $\\text{secure} = 0$, the final list is formed by concatenating the sorted `LD_PRELOAD` list, the main executable, and the sorted dependency list.\n  - If $\\text{secure} = 1$, the `LD_PRELOAD` list is omitted, and the final list is formed by concatenating the main executable and the sorted dependency list.\n\nThe C standard library function `qsort` is ideally suited for performing the required sorting operations. We will implement two comparison functions: one for `preload_order` and one for `dep_order`.\n\n**3. Symbol Resolution**\nOnce the search list is constructed, we iterate through it from the beginning to the end. For each object $o$ in the list, we evaluate the eligibility predicate $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$.\n- The first object for which $P(o)$ evaluates to true is the winner of the resolution process. Its $\\text{id}$ is the result $R$.\n- We then determine the interposition indicator $I$. If the winning object has $\\text{load\\_source} = 1$, then $I=1$; otherwise, $I=0$.\n- If the loop completes without finding any object that satisfies $P(o)$, the resolution fails. In this case, $R$ is set to $-1$ and $I$ is set to $0$, as per the problem definition.\n\n**4. Final Output**\nAfter processing all six test cases, the program will have computed twelve integer results ($R_1, I_1, \\dots, R_6, I_6$). These results are then printed to standard output in the exact format specified: $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$, with no additional characters or whitespace.\n\nThe final program encapsulates this logic, hardcodes the test suite data, performs the calculations for each case, and prints the consolidated result.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the attributes of a single dynamically loaded object.\ntypedef struct {\n    int id;\n    int is_main;\n    int load_source;\n    int preload_order;\n    int dep_order;\n    int defines;\n    int visibility;\n    int version;\n} Object;\n\n// The maximum number of objects in any single test case.\n#define MAX_OBJECTS_PER_CASE 4\n#define MAX_TEST_CASES 6\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int secure;\n    int v_req;\n    int n;\n    Object objects[MAX_OBJECTS_PER_CASE];\n} TestCase;\n\n// Comparison function for qsort to sort LD_PRELOAD libraries.\nint compare_preload_order(const void *a, const void *b) {\n    const Object *objA = *(const Object **)a;\n    const Object *objB = *(const Object **)b;\n    return objA->preload_order - objB->preload_order;\n}\n\n// Comparison function for qsort to sort normal dependencies.\nint compare_dep_order(const void *a, const void *b) {\n    const Object *objA = *(const Object **)a;\n    const Object *objB = *(const Object **)b;\n    return objA->dep_order - objB->dep_order;\n}\n\nint main(void) {\n    // Hardcode the test suite as specified in the problem statement.\n    TestCase test_cases[MAX_TEST_CASES] = {\n        // Case 1: happy path with LD_PRELOAD interposition\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 1, 0, 10}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 2: secure execution ignores LD_PRELOAD\n        {\n            .secure = 1, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 3: hidden visibility prevents interposition\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 1, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 4: version mismatch in LD_PRELOAD causes fallback\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 20}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 5: multiple LD_PRELOAD libraries, order determines interposition\n        {\n            .secure = 0, .v_req = 10, .n = 4,\n            .objects = {\n                {0, 1, 0, -1, -1, 1, 0, 10}, // Main executable E\n                {3, 0, 1,  0, -1, 1, 0, 10}, // Preload library L3\n                {1, 0, 1,  1, -1, 1, 0, 10}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 10}  // Normal dependency L2\n            }\n        },\n        // Case 6: no eligible provider\n        {\n            .secure = 0, .v_req = 10, .n = 3,\n            .objects = {\n                {0, 1, 0, -1, -1, 0, 0,  0}, // Main executable E\n                {1, 0, 1,  0, -1, 1, 0, 20}, // Preload library L1\n                {2, 0, 0, -1,  0, 1, 0, 30}  // Normal dependency L2\n            }\n        }\n    };\n\n    int results[MAX_TEST_CASES * 2];\n\n    for (int i = 0; i < MAX_TEST_CASES; ++i) {\n        TestCase *tc = &test_cases[i];\n\n        // Storage for search list and categorized object pointers\n        const Object *search_list[MAX_OBJECTS_PER_CASE];\n        int search_list_size = 0;\n\n        const Object *preload_libs[MAX_OBJECTS_PER_CASE];\n        int preload_count = 0;\n        const Object *main_exec = NULL;\n        const Object *deps[MAX_OBJECTS_PER_CASE];\n        int dep_count = 0;\n\n        // Partition objects into categories\n        for (int j = 0; j < tc->n; ++j) {\n            const Object *obj = &(tc->objects[j]);\n            if (obj->load_source == 1) {\n                preload_libs[preload_count++] = obj;\n            } else if (obj->is_main == 1) {\n                main_exec = obj;\n            } else {\n                deps[dep_count++] = obj;\n            }\n        }\n\n        // Sort preload libraries and dependencies\n        if (preload_count > 1) {\n            qsort(preload_libs, preload_count, sizeof(Object *), compare_preload_order);\n        }\n        if (dep_count > 1) {\n            qsort(deps, dep_count, sizeof(Object *), compare_dep_order);\n        }\n\n        // Assemble the final search list based on the secure flag\n        if (tc->secure == 0) {\n            for (int k = 0; k < preload_count; ++k) search_list[search_list_size++] = preload_libs[k];\n        }\n        if (main_exec != NULL) search_list[search_list_size++] = main_exec;\n        for (int k = 0; k < dep_count; ++k) search_list[search_list_size++] = deps[k];\n\n        // Perform resolution\n        int resolved_id = -1;\n        int interposed = 0;\n        for (int k = 0; k < search_list_size; ++k) {\n            const Object* current_obj = search_list[k];\n            // Eligibility Predicate: P(o)\n            if (current_obj->defines == 1 && current_obj->visibility == 0 && current_obj->version == tc->v_req) {\n                resolved_id = current_obj->id;\n                if (current_obj->load_source == 1) {\n                    interposed = 1;\n                }\n                break; // First match wins\n            }\n        }\n\n        results[i * 2] = resolved_id;\n        results[i * 2 + 1] = interposed;\n    }\n\n    // Print the results in the EXACT required format.\n    printf(\"[\");\n    for (int i = 0; i < MAX_TEST_CASES; ++i) {\n        printf(\"%d,%d\", results[i * 2], results[i * 2 + 1]);\n        if (i < MAX_TEST_CASES - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3636919"}, {"introduction": "Managing the lifecycle of a dynamically loaded library is critical for building stable applications. Simply unloading a library when it's no longer needed can lead to subtle and dangerous 'use-after-unload' bugs if other parts of the program still hold references to it. In this practice, you will simulate and contrast a naive unloading policy with a robust, reference-counted approach, giving you hands-on experience with the design patterns necessary for safe library management [@problem_id:3636903].", "problem": "You are asked to design a precise, executable model of dynamic linking behavior to demonstrate hazards of unloading a shared library while callbacks into that library are still possible. Your program must implement two policies and check for a use-after-unload hazard under each policy on a fixed test suite of event sequences. The two policies model: (i) a naive unload that immediately unmaps the library on a close request, and (ii) a safe unload that defers unmapping until no references remain, incorporating an explicit shutdown hook to cancel callbacks.\n\nFundamental base. Use the following well-tested facts and core definitions as the foundation for your model. When a shared object is dynamically linked, code and data from that object are mapped into process address space; a function pointer referencing code in a shared object is valid only while its code remains mapped. If a callback pointer to a library function is invoked after that library is unloaded, the call would attempt to execute unmapped code, a use-after-unload hazard. A widely used safe pattern employs reference counting to defer unloading until all uses are released, optionally combined with an explicit shutdown hook that cancels or unregisters outstanding callbacks. Your model should faithfully capture these behaviors abstractly.\n\nFormal model. You will simulate a single process interacting with a single dynamically loaded library. Time advances in discrete steps indexed by $t \\in \\{1,2,\\dots,T\\}$. At each step, exactly one event occurs, drawn from the alphabet:\n- Register callback: token R\n- Unregister callback: token U\n- Fire callback: token F (attempts to invoke a registered callback if one exists)\n- Close request (request to unload the library): token C\n- Acquire a non-callback reference (e.g., an in-flight task): token A\n- Release a non-callback reference: token D\n- Execute shutdown hook (explicitly unregister all callbacks): token S\n\nState variables for the naive policy:\n- $L(t) \\in \\{0,1\\}$ indicates whether the library is currently mapped ($1$ means mapped).\n- $N(t) \\in \\mathbb{N}_0$ counts registered callbacks outstanding.\n- Hazard indicator $H_{\\mathrm{naive}} \\in \\{0,1\\}$ becomes $1$ if any F occurs while $L(t)=0$ and $N(t)>0$.\n\nState variables for the safe policy (reference counting with shutdown hook):\n- $L(t) \\in \\{0,1\\}$ indicates whether the library is currently mapped.\n- $W(t) \\in \\{0,1\\}$ indicates a pending close request.\n- $N(t) \\in \\mathbb{N}_0$ counts registered callbacks outstanding.\n- $Q(t) \\in \\mathbb{N}_0$ counts non-callback references (acquisitions).\n- The reference count is $R(t) = N(t) + Q(t)$.\n- Hazard indicator $H_{\\mathrm{safe}} \\in \\{0,1\\}$ becomes $1$ if any F occurs while $L(t)=0$ and $N(t)>0$.\n- Unload condition: unloading occurs if and only if $W(t)=1$ and $R(t)=0$.\n\nEvent semantics. Initialize $L(0)=1$, $W(0)=0$, $N(0)=0$, $Q(0)=0$, and both hazards to $0$.\n- R: $N \\leftarrow N+1$. In the safe policy, $R$ thereby increases by $1$.\n- U: if $N>0$ then $N \\leftarrow N-1$.\n- F: if $L=0$ and $N>0$ then set the corresponding hazard to $1$; otherwise no state change.\n- C (naive): $L \\leftarrow 0$ immediately. C (safe): $W \\leftarrow 1$; if $R=0$ then $L \\leftarrow 0$, else $L$ remains $1$ until $R$ becomes $0$.\n- A: $Q \\leftarrow Q+1$.\n- D: if $Q>0$ then $Q \\leftarrow Q-1$.\n- S (safe only): unregister all callbacks atomically, i.e., $N \\leftarrow 0$; in the naive policy this event has no effect.\n- In the safe policy, after any event change, if $W=1$ and $R=0$ then set $L \\leftarrow 0$.\n\nTask. Implement a program that:\n- Encodes the above semantics exactly.\n- Simulates both policies on each event sequence below.\n- For each sequence, outputs two results: first $H_{\\mathrm{naive}}$, then $H_{\\mathrm{safe}}$, each as $0$ or $1$.\n\nTest suite. Use the following $5$ sequences, each given as a contiguous string of event tokens:\n- Sequence $1$: RFUC\n- Sequence $2$: RCFU\n- Sequence $3$: CF\n- Sequence $4$: RACFDU\n- Sequence $5$: RCSF\n\nCoverage rationale. The suite includes a normal case (Sequence $1$), a demonstrable hazard under naive unloading where callback fires after close (Sequence $2$), a no-op close with no callbacks (Sequence $3$), interference from extra non-callback references (Sequence $4$), and use of an explicit shutdown hook to safely detach callbacks after a close request (Sequence $5$).\n\nOutput format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $10$ integers corresponding to $[H_{\\mathrm{naive}}^{(1)},H_{\\mathrm{safe}}^{(1)},H_{\\mathrm{naive}}^{(2)},H_{\\mathrm{safe}}^{(2)},\\dots,H_{\\mathrm{naive}}^{(5)},H_{\\mathrm{safe}}^{(5)}]$, in that order, with no spaces. For example: \"[0,0,1,0,0,0,1,0,1,0]\". No input should be read, and no other output should be printed.", "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is scientifically grounded in computer science principles, well-posed, objective, and self-contained. The task is to simulate two policies for handling shared library unloadingâ€”a naive policy and a safe, reference-counted policyâ€”and determine if a use-after-unload hazard occurs for a given set of event sequences.\n\nThe simulation adheres to the formal model specified. The state of the system is defined by a set of variables for each policy, which evolve in discrete time steps according to specified event semantics. The initial state at time $t=0$ for both policies is: library mapped ($L(0)=1$), no callbacks registered ($N(0)=0$), no non-callback references ($Q(0)=0$), no pending close request ($W(0)=0$), and no hazard detected ($H_{\\mathrm{naive}}=0$, $H_{\\mathrm{safe}}=0$).\n\nThe hazard condition for both policies is identical: a hazard flag ($H_{\\mathrm{naive}}$ or $H_{\\mathrm{safe}}$) is set to $1$ if a 'Fire callback' event (F) occurs at a time $t$ when the library is not mapped ($L(t)=0$) but there are still outstanding registered callbacks ($N(t)>0$).\n\nWe will now trace the evolution of the state variables for each of the $5$ test sequences under both the naive and safe policies.\n\n### Sequence 1: `RFUC`\nThis sequence represents a normal, safe operational lifecycle.\n- **Naive Policy:**\n  1. `R`: The callback count becomes $N=1$.\n  2. `F`: The library is mapped ($L=1$), so firing the callback is safe. $H_{\\mathrm{naive}}$ remains $0$.\n  3. `U`: The callback is unregistered, so $N$ becomes $0$.\n  4. `C`: A close request unloads the library, setting $L=0$. At this point, $N=0$, so no hazard is latent.\n  **Result:** $H_{\\mathrm{naive}}=0$.\n- **Safe Policy:**\n  1. `R`: Callback count $N$ becomes $1$. The total reference count is $R = N+Q = 1$.\n  2. `F`: The library is mapped ($L=1$), so the call is safe. $H_{\\mathrm{safe}}$ remains $0$.\n  3. `U`: The callback is unregistered ($N=0$), making the reference count $R=0$.\n  4. `C`: A close request is registered ($W=1$). Because the reference count $R$ is already $0$, the unload condition ($W=1 \\text{ and } R=0$) is met, and the library is immediately unloaded ($L=0$).\n  **Result:** $H_{\\mathrm{safe}}=0$.\n- **Pair Result:** $[0,0]$\n\n### Sequence 2: `RCFU`\nThis sequence is designed to expose the hazard in the naive policy.\n- **Naive Policy:**\n  1. `R`: Callback count becomes $N=1$.\n  2. `C`: The library is immediately unloaded, setting $L=0$. A callback is still registered ($N=1$).\n  3. `F`: A fire event occurs. The library is unmapped ($L=0$) while a callback exists ($N>0$). This triggers the hazard condition. $H_{\\mathrm{naive}}$ is set to $1$.\n  4. `U`: The callback is unregistered ($N=0$). The hazard flag remains set.\n  **Result:** $H_{\\mathrm{naive}}=1$.\n- **Safe Policy:**\n  1. `R`: Callback count $N$ becomes $1$, so the reference count is $R=1$.\n  2. `C`: A close request is registered ($W=1$). Because $R=1$, the library is not unloaded; $L$ remains $1$.\n  3. `F`: The fire event occurs while the library is still mapped ($L=1$). The call is safe. $H_{\\mathrm{safe}}$ remains $0$.\n  4. `U`: The callback is unregistered ($N=0$), so the reference count becomes $R=0$. The post-event check finds the unload condition is met ($W=1 \\text{ and } R=0$), so the library is now unloaded ($L=0$).\n  **Result:** $H_{\\mathrm{safe}}=0$.\n- **Pair Result:** $[1,0]$\n\n### Sequence 3: `CF`\nThis sequence tests behavior when no callbacks are ever registered.\n- **Naive Policy:**\n  1. `C`: The library is unloaded ($L=0$). The callback count is $N=0$.\n  2. `F`: A fire event occurs. Although the library is unmapped ($L=0$), there are no registered callbacks ($N=0$), so no hazard occurs.\n  **Result:** $H_{\\mathrm{naive}}=0$.\n- **Safe Policy:**\n  1. `C`: A close request is registered ($W=1$). The reference count is $R=0$. The unload condition is met, so the library is immediately unloaded ($L=0$).\n  2. `F`: A fire event occurs while $L=0$ and $N=0$. No hazard.\n  **Result:** $H_{\\mathrm{safe}}=0$.\n- **Pair Result:** $[0,0]$\n\n### Sequence 4: `RACFDU`\nThis sequence demonstrates how non-callback references also prevent premature unloading in the safe policy.\n- **Naive Policy:** The `A` (Acquire) and `D` (Release) events have no effect. The sequence effectively becomes `RCFU`.\n  1. `R`: $N=1$.\n  2. `C`: $L=0$.\n  3. `F`: $L=0$ and $N>0$. Hazard triggered. $H_{\\mathrm{naive}}$ is set to $1$.\n  **Result:** $H_{\\mathrm{naive}}=1$.\n- **Safe Policy:**\n  1. `R`: $N$ becomes $1$. Reference count $R = 1$.\n  2. `A`: A non-callback reference is acquired, $Q=1$. The reference count becomes $R = N+Q = 1+1=2$.\n  3. `C`: Close request is registered ($W=1$). Since $R=2$, the library remains loaded ($L=1$).\n  4. `F`: The fire event occurs safely as $L=1$.\n  5. `D`: The non-callback reference is released, $Q=0$. Reference count becomes $R=N+Q = 1+0=1$. The unload condition is not yet met.\n  6. `U`: The callback is unregistered, $N=0$. Reference count becomes $R=N+Q = 0+0=0$. The post-event check finds $W=1$ and $R=0$, so the library is now unloaded ($L=0$).\n  **Result:** $H_{\\mathrm{safe}}=0$.\n- **Pair Result:** $[1,0]$\n\n### Sequence 5: `RCSF`\nThis sequence shows the utility of an explicit shutdown hook.\n- **Naive Policy:** The `S` (Shutdown) event has no effect. The sequence is effectively `RCF`.\n  1. `R`: $N=1$.\n  2. `C`: $L=0$.\n  3. `F`: $L=0$ and $N>0$. Hazard triggered. $H_{\\mathrm{naive}}$ is set to $1$.\n  **Result:** $H_{\\mathrm{naive}}=1$.\n- **Safe Policy:**\n  1. `R`: $N$ becomes $1$, so $R=1$.\n  2. `C`: Close request registered ($W=1$). Library remains loaded ($L=1$) since $R>0$.\n  3. `S`: The shutdown hook runs, atomically unregistering all callbacks. $N$ becomes $0$. The reference count is now $R=0$. The post-event check finds $W=1$ and $R=0$, so the library is unloaded ($L=0$).\n  4. `F`: The fire event occurs. Although the library is unmapped ($L=0$), the shutdown hook has already cleared the callbacks ($N=0$), so the call is not attempted and no hazard occurs.\n  **Result:** $H_{\\mathrm{safe}}=0$.\n- **Pair Result:** $[1,0]$\n\n### Final Aggregated Results\nThe hazard flags for each sequence are:\n- Sequence 1: $[H_{\\mathrm{naive}}^{(1)}, H_{\\mathrm{safe}}^{(1)}] = [0,0]$\n- Sequence 2: $[H_{\\mathrm{naive}}^{(2)}, H_{\\mathrm{safe}}^{(2)}] = [1,0]$\n- Sequence 3: $[H_{\\mathrm{naive}}^{(3)}, H_{\\mathrm{safe}}^{(3)}] = [0,0]$\n- Sequence 4: $[H_{\\mathrm{naive}}^{(4)}, H_{\\mathrm{safe}}^{(4)}] = [1,0]$\n- Sequence 5: $[H_{\\mathrm{naive}}^{(5)}, H_{\\mathrm{safe}}^{(5)}] = [1,0]$\n\nCombining these results yields the final output string.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// The provided formal model does not utilize complex numbers, threading,\n// or atomics, so the corresponding headers are not included.\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    const char* test_sequences[] = {\n        \"RFUC\",\n        \"RCFU\",\n        \"CF\",\n        \"RACFDU\",\n        \"RCSF\"\n    };\n\n    // Calculate the number of test cases.\n    int num_sequences = sizeof(test_sequences) / sizeof(test_sequences[0]);\n    int num_results = num_sequences * 2;\n    int results[num_results];\n\n    // Calculate the result for each test case and each policy.\n    for (int i = 0; i < num_sequences; ++i) {\n        const char* sequence = test_sequences[i];\n        size_t seq_len = strlen(sequence);\n\n        // --- Naive Policy Simulation ---\n        int l_naive = 1; // L(t): Library mapped state\n        int n_naive = 0; // N(t): Registered callback count\n        int h_naive = 0; // H_naive: Hazard indicator\n        \n        for (size_t j = 0; j < seq_len; ++j) {\n            char event = sequence[j];\n            switch (event) {\n                case 'R': // Register callback\n                    n_naive++;\n                    break;\n                case 'U': // Unregister callback\n                    if (n_naive > 0) n_naive--;\n                    break;\n                case 'F': // Fire callback\n                    if (l_naive == 0 && n_naive > 0) {\n                        h_naive = 1;\n                    }\n                    break;\n                case 'C': // Close request (immediate unload)\n                    l_naive = 0;\n                    break;\n                case 'A': // Acquire reference (no effect in naive model)\n                case 'D': // Release reference (no effect in naive model)\n                case 'S': // Shutdown hook (no effect in naive model)\n                    break;\n            }\n        }\n        results[i * 2] = h_naive;\n\n        // --- Safe Policy Simulation ---\n        int l_safe = 1; // L(t): Library mapped state\n        int n_safe = 0; // N(t): Registered callback count\n        int q_safe = 0; // Q(t): Non-callback reference count\n        int w_safe = 0; // W(t): Pending close request\n        int h_safe = 0; // H_safe: Hazard indicator\n\n        for (size_t j = 0; j < seq_len; ++j) {\n            char event = sequence[j];\n            switch (event) {\n                case 'R': // Register callback\n                    n_safe++;\n                    break;\n                case 'U': // Unregister callback\n                    if (n_safe > 0) n_safe--;\n                    break;\n                case 'F': // Fire callback\n                    if (l_safe == 0 && n_safe > 0) {\n                        h_safe = 1;\n                    }\n                    break;\n                case 'C': // Close request (deferred unload)\n                    w_safe = 1;\n                    break;\n                case 'A': // Acquire reference\n                    q_safe++;\n                    break;\n                case 'D': // Release reference\n                    if (q_safe > 0) q_safe--;\n                    break;\n                case 'S': // Shutdown hook\n                    n_safe = 0;\n                    break;\n            }\n            \n            // Post-event check for unload condition:\n            // Unload occurs if a close has been requested AND the total reference count is zero.\n            int r_safe = n_safe + q_safe;\n            if (w_safe == 1 && r_safe == 0) {\n                l_safe = 0;\n            }\n        }\n        results[i * 2 + 1] = h_safe;\n    }\n\n    // Print the results in the EXACT required format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_results; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_results - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3636903"}]}