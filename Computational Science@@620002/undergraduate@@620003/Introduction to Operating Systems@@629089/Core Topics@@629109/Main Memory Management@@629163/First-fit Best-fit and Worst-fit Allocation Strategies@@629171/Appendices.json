{"hands_on_practices": [{"introduction": "To effectively manage memory, an operating system must choose an allocation strategy, a decision that involves inherent trade-offs. This first exercise provides a controlled environment to compare the foundational behaviors of first-fit, best-fit, and worst-fit policies [@problem_id:3644104]. By analyzing a simple cyclic workload, you will quantify two critical performance aspects: the search cost, measured by the number of blocks inspected, and the efficiency of memory use, reflected in the probability of achieving an exact-sized fit.", "problem": "Consider a single-region dynamic memory allocator in an Operating System (OS) that uses a linear free list and contiguous blocks. The allocator may operate under one of three strategies: first-fit, best-fit, or worst-fit. The free list is maintained in a fixed order and contains exactly three free blocks whose sizes are $8$, $6$, and $9$ units, in this order. A cyclic workload with period $k=3$ issues one allocation request per step with sizes $6$, $8$, and $7$ units, respectively, and then repeats indefinitely. Each allocation is immediately followed by a free of the same requested size before the next allocation request arrives. Assume splitting of a larger allocated block leaves a leftover free fragment at the point of split, and that immediate free triggers coalescing that deterministically restores the free list to its original state and order before the next request. The free list order is never changed by the allocator across the cycle.\n\nFundamental definitions:\n- A first-fit allocator selects the first block in the free list whose size is at least the requested size.\n- A best-fit allocator selects the smallest block in the free list whose size is at least the requested size; assume a naive implementation that scans the entire free list to identify the minimum adequate block.\n- A worst-fit allocator selects the largest block in the free list whose size is at least the requested size; assume a naive implementation that scans the entire free list to identify the maximum adequate block.\n\nLet $\\Pr[\\text{exact-fit}]$ denote the probability, over a single cycle of $k$ requests, that the allocator returns a block whose size is exactly equal to the requested size. Let $T$ denote the expected number of free-list block headers inspected per allocation request, averaged over the $k$ requests of the cycle, under the stated naive implementations.\n\nDetermine, for this cyclic workload, which strategy maximizes $\\Pr[\\text{exact-fit}]$ and which strategy minimizes $T$. Encode the three strategies as numbers: first-fit $=1$, best-fit $=2$, worst-fit $=3$. Report your final answer as the row matrix $\\left(s_{\\max} \\ \\ s_{\\min}\\right)$, where $s_{\\max}$ is the code of the strategy that maximizes $\\Pr[\\text{exact-fit}]$ and $s_{\\min}$ is the code of the strategy that minimizes $T$. No rounding is required, and there are no units to report. Express the final answer as a row matrix using the specified encoding.", "solution": "The problem requires an analysis of three dynamic memory allocation strategies—first-fit, best-fit, and worst-fit—under a specific, cyclic workload. We are tasked with determining which strategy maximizes the probability of an exact-fit allocation, denoted $\\Pr[\\text{exact-fit}]$, and which strategy minimizes the expected number of free-list block headers inspected per request, denoted $T$. The strategies are encoded as first-fit $=1$, best-fit $=2$, and worst-fit $=3$.\n\nThe initial state of the free list is given as an ordered sequence of block sizes: $L = (8, 6, 9)$. This list contains $3$ blocks.\nThe workload is a repeating cycle of $k=3$ allocation requests with sizes $R = (r_1, r_2, r_3) = (6, 8, 7)$.\nA critical condition is that after each allocation and an immediate free of the allocated block, the free list is deterministically restored to its original state and order, $L$. This simplification means each of the $k=3$ requests in a cycle is evaluated against the identical initial free list $L=(8, 6, 9)$.\n\nWe will analyze each strategy over a single cycle of $k=3$ requests.\n\n1. First-Fit Strategy ($s=1$)\nThis strategy selects the first available block in the free list that is large enough to satisfy the request. The list is scanned in its fixed order $(8, 6, 9)$.\n\n- Request $r_1 = 6$: The allocator scans the list from the beginning. The first block has size $8$. Since $8 \\ge 6$, this block is selected for allocation. The search stops. This is not an exact fit ($8 > 6$). The number of blocks inspected is $1$.\n- Request $r_2 = 8$: The list is restored to $(8, 6, 9)$. The allocator scans the list. The first block has size $8$. Since $8 \\ge 8$, this block is selected. This is an exact fit. The number of blocks inspected is $1$.\n- Request $r_3 = 7$: The list is restored to $(8, 6, 9)$. The allocator scans the list. The first block has size $8$. Since $8 \\ge 7$, this block is selected. This is not an exact fit ($8 > 7$). The number of blocks inspected is $1$.\n\nFor the first-fit strategy:\n- The total number of exact-fit allocations over one cycle is $1$.\n- The probability of an exact fit is $\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$.\n- The total number of block headers inspected during the cycle is $1 + 1 + 1 = 3$.\n- The expected number of inspections per request is $T_{ff} = \\frac{3}{3} = 1$.\n\n2. Best-Fit Strategy ($s=2$)\nThis strategy selects the smallest block from the entire free list that is large enough for the request. The problem specifies a naive implementation that scans the entire list of $3$ blocks for every request to find the minimum adequate block.\n\n- Request $r_1 = 6$: The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 6, 9\\}$. The smallest of these is the block of size $6$. This block is selected. This is an exact fit. The number of blocks inspected is $3$.\n- Request $r_2 = 8$: The list is restored. The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 9\\}$. The smallest of these is the block of size $8$. This block is selected. This is an exact fit. The number of blocks inspected is $3$.\n- Request $r_3 = 7$: The list is restored. The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 9\\}$. The smallest of these is the block of size $8$. This block is selected. This is not an exact fit ($8 > 7$). The number of blocks inspected is $3$.\n\nFor the best-fit strategy:\n- The total number of exact-fit allocations over one cycle is $2$.\n- The probability of an exact fit is $\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$.\n- The total number of block headers inspected is $3 + 3 + 3 = 9$.\n- The expected number of inspections per request is $T_{bf} = \\frac{9}{3} = 3$.\n\n3. Worst-Fit Strategy ($s=3$)\nThis strategy selects the largest block from the entire free list that is large enough. This also uses a naive implementation that scans the entire list of $3$ blocks for every request.\n\n- Request $r_1 = 6$: The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 6, 9\\}$. The largest of these is the block of size $9$. This block is selected. This is not an exact fit ($9 > 6$). The number of blocks inspected is $3$.\n- Request $r_2 = 8$: The list is restored. The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 9\\}$. The largest of these is the block of size $9$. This block is selected. This is not an exact fit ($9 > 8$). The number of blocks inspected is $3$.\n- Request $r_3 = 7$: The list is restored. The allocator scans the entire list $(8, 6, 9)$. The set of blocks large enough is $\\{8, 9\\}$. The largest of these is the block of size $9$. This block is selected. This is not an exact fit ($9 > 7$). The number of blocks inspected is $3$.\n\nFor the worst-fit strategy:\n- The total number of exact-fit allocations over one cycle is $0$.\n- The probability of an exact fit is $\\Pr[\\text{exact-fit}]_{wf} = \\frac{0}{3} = 0$.\n- The total number of block headers inspected is $3 + 3 + 3 = 9$.\n- The expected number of inspections per request is $T_{wf} = \\frac{9}{3} = 3$.\n\nSummary of Metrics:\n- First-fit ($s=1$): $\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$, $T_{ff} = 1$.\n- Best-fit ($s=2$): $\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$, $T_{bf} = 3$.\n- Worst-fit ($s=3$): $\\Pr[\\text{exact-fit}]_{wf} = 0$, $T_{wf} = 3$.\n\nDetermination of Optimal Strategies:\nTo find the strategy that maximizes $\\Pr[\\text{exact-fit}]$, we compare the calculated probabilities: $\\{\\frac{1}{3}, \\frac{2}{3}, 0\\}$. The maximum value is $\\frac{2}{3}$, which corresponds to the best-fit strategy. Therefore, the code for the strategy that maximizes this probability is $s_{\\max} = 2$.\n\nTo find the strategy that minimizes the expected number of inspections $T$, we compare the average inspection counts: $\\{1, 3, 3\\}$. The minimum value is $1$, which corresponds to the first-fit strategy. Therefore, the code for the strategy that minimizes this cost is $s_{\\min} = 1$.\n\nThe problem asks for the final answer to be reported as the row matrix $(s_{\\max} \\ \\ s_{\\min})$. Substituting the determined values, we obtain the matrix $\\begin{pmatrix} 2  1 \\end{pmatrix}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  1\n\\end{pmatrix}\n}\n$$", "id": "3644104"}, {"introduction": "The impact of an allocation strategy extends beyond a single request, cumulatively shaping the memory landscape over time. This practice challenges you to think adversarially and explore how policy choices can lead to vastly different long-term outcomes for external fragmentation [@problem_id:3644191]. Your task is to construct a scenario that maximizes the difference in the largest available free block between the first-fit and worst-fit strategies, revealing their core tendencies in preserving or consuming large memory regions.", "problem": "Consider a variable-sized partition memory allocator managing a free list ordered by increasing memory address. The allocator uses block splitting without compaction or coalescing during allocation: when a request of size $s$ is serviced from a free block of size $f \\ge s$, the allocator creates an allocated block of size $s$ and a leftover free block of size $f - s$ (if $f = s$, the chosen free block disappears). Define First-Fit (FF) to select the first free block in address order whose size is at least the request size, and Worst-Fit (WF) to select the largest free block whose size is at least the request size.\n\nInitially, the free list consists of $m$ small blocks, each of size $b$, followed by a single large block of size $B$, with $B  b  0$ and $m \\ge n$. You will perform $n$ allocation operations with request sizes $\\{ s_i \\}_{i=1}^{n}$ subject to $0  s_i \\le b$ for all $i$.\n\nLet $C_{\\max}^{\\mathrm{FF}}(t)$ and $C_{\\max}^{\\mathrm{WF}}(t)$ denote the size of the largest contiguous free block after $t$ operations under First-Fit and Worst-Fit, respectively. Define the difference after $n$ operations by\n$$\n\\Delta C_{\\max} \\equiv C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n).\n$$\nYour tasks are:\n- Using only the core definitions of the First-Fit and Worst-Fit strategies and the stated allocator semantics, determine the pattern in the sequence $\\{ s_i \\}$ that maximizes $\\Delta C_{\\max}$.\n- Derive, from first principles, the maximum attainable value of $\\Delta C_{\\max}$ as a closed-form expression in terms of $n$, $b$, and $B$.\n\nProvide the final answer as an exact analytic expression. No rounding is required.", "solution": "The objective is to find a request sequence $\\{s_i\\}_{i=1}^n$ that maximizes the difference $\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n)$. This requires us to select a sequence that, after $n$ allocations, makes the largest free block under First-Fit ($C_{\\max}^{\\mathrm{FF}}(n)$) as large as possible, while simultaneously making the largest free block under Worst-Fit ($C_{\\max}^{\\mathrm{WF}}(n)$) as small as possible.\n\n**1. Maximizing $C_{\\max}^{\\mathrm{FF}}(n)$**\n\nThe First-Fit (FF) strategy scans the free list, which is ordered by address, and selects the first block that is large enough. The initial free list consists of $m$ blocks of size $b$ followed by one block of size $B$. All allocation requests $s_i$ are constrained by $0  s_i \\le b$.\nFor any such request, the FF allocator will always find a suitable block among the initial $m$ small blocks. Since the problem states $m \\ge n$, there are enough small blocks to satisfy all $n$ requests. Consequently, the FF allocator will never need to inspect, let alone use, the large block of size $B$.\nTherefore, regardless of the specific values of $s_i$ (as long as they are within the constraint), the block of size $B$ will remain untouched after $n$ allocations. The largest free block under FF will be this block.\n$$ C_{\\max}^{\\mathrm{FF}}(n) = B $$\n\n**2. Minimizing $C_{\\max}^{\\mathrm{WF}}(n)$**\n\nThe Worst-Fit (WF) strategy scans the entire free list and selects the largest block that is large enough. To minimize the final largest free block size, we should choose a request sequence that maximally consumes the largest available blocks. This is achieved by making the allocation requests as large as possible, i.e., $s_i = b$ for all $i=1, \\dots, n$.\n\nLet's analyze the behavior of WF with this sequence ($s_i = b$ for all $i$):\n- Initially, the largest block is of size $B$ (since $B>b$).\n- For the first request of size $b$, WF allocates from the block of size $B$, leaving a remnant of size $B-b$.\n- For the second request, this remnant (size $B-b$) will be the largest block as long as $B-b > b$. WF will again choose it, leaving a remnant of size $B-2b$.\n- This process continues. After $k$ requests, the remnant of the original large block has size $B-kb$. WF will keep allocating from this remnant as long as it remains the largest block in the free list.\n- After all $n$ allocations, a total size of $nb$ has been allocated, preferentially from the block of size $B$. The size of the remnant of this block is $B-nb$. The other free blocks are the original small blocks of size $b$ that were not used.\n- The largest free block in the system will be either the remaining part of the large block or one of the untouched small blocks. Therefore, the size of the largest block is the maximum of these two possibilities:\n$$ C_{\\max}^{\\mathrm{WF}}(n) = \\max(b, B-nb) $$\n\n**3. Deriving the Maximum $\\Delta C_{\\max}$**\n\nWe can now substitute our results for the optimal sequence ($s_i = b$ for all $i$) into the expression for $\\Delta C_{\\max}$:\n$$\n\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n) = B - \\max(b, B-nb)\n$$\nThis expression can be evaluated by considering two cases based on the `max` function:\n\n- **Case 1: $B - nb \\le b$** (which is equivalent to $B \\le (n+1)b$).\nIn this case, $\\max(b, B-nb) = b$. The difference is:\n$$ \\Delta C_{\\max} = B - b $$\n\n- **Case 2: $B - nb > b$** (which is equivalent to $B > (n+1)b$).\nIn this case, $\\max(b, B-nb) = B - nb$. The difference is:\n$$ \\Delta C_{\\max} = B - (B - nb) = nb $$\n\nThe request sequence $s_i=b$ maximizes $C_{\\max}^{\\mathrm{FF}}(n)$ and minimizes $C_{\\max}^{\\mathrm{WF}}(n)$, thus maximizing their difference. The resulting maximum value of $\\Delta C_{\\max}$ is whichever of the two outcomes, $B-b$ or $nb$, is smaller, as determined by the relationship between $B$ and $(n+1)b$. This can be expressed compactly using the minimum function.\n\nThe maximum attainable value is therefore:\n$$ \\max(\\Delta C_{\\max}) = \\min(nb, B-b) $$\nThe pattern in the sequence $\\{s_i\\}$ that achieves this is $s_i = b$ for all $i=1, \\ldots, n$.", "answer": "$$\n\\boxed{\\min(nb, B-b)}\n$$", "id": "3644191"}, {"introduction": "Theoretical models provide insight, but practical implementation often involves balancing competing goals. This hands-on simulation bridges theory and practice by introducing a common optimization: avoiding the creation of tiny, unusable memory fragments [@problem_id:3644173]. As you will discover by implementing and testing the allocation policies, this technique to reduce external fragmentation comes at the cost of creating internal fragmentation, forcing a direct and quantifiable confrontation with one of the most fundamental trade-offs in dynamic memory management.", "problem": "You are to implement and analyze contiguous memory allocation under three selection policies—first-fit, best-fit, and worst-fit—with a threshold rule on splitting. Consider a single contiguous memory of fixed size and a deterministic sequence of allocation and free requests identified by unique process identifiers. The focus is to quantify, at the end of the sequence, the external fragmentation and internal fragmentation, and compare how these metrics change as the split threshold varies.\n\nFundamental base definitions to use:\n- Contiguous allocation maintains a list of free blocks and allocates an entire region of memory that is contiguous in address space. Allocation is based on a policy that selects a free block of sufficient size.\n- First-fit selects the first free block that is large enough.\n- Best-fit selects the smallest free block that is at least as large as the request; tie-break using the lowest starting address.\n- Worst-fit selects the largest free block; tie-break using the lowest starting address.\n- When splitting a free block of size $s$ to satisfy a request of size $r$ with remainder $t = s - r$, if $t  \\epsilon$ (strict inequality), the allocator does not split. Instead, it allocates the entire block of size $s$ to the request, recording internal waste of $s - r$ bytes for that allocation. If $t \\ge \\epsilon$, normal splitting occurs into an allocated block of size $r$ and a free block of size $t$.\n- On free, immediate coalescing is performed with any adjacent free neighbors to maintain maximal free contiguity.\n- At the end of the entire sequence, define external fragmentation $E$ by\n$$\nE \\equiv \\begin{cases}\n0,  \\text{if total free memory } F = 0,\\\\\n1 - \\dfrac{L}{F},  \\text{if } F  0,\n\\end{cases}\n$$\nwhere $F$ is the sum of sizes of all free blocks and $L$ is the size of the largest free block.\n- At the end of the entire sequence, define internal fragmentation $I$ as the sum over currently allocated blocks of $\\text{allocated\\_size} - \\text{requested\\_size}$ (in bytes). Each allocated block records its requested and allocated sizes at the time it was allocated; only blocks still allocated at the end contribute to $I$.\n\nMemory model and parameters:\n- Total memory size is $M = 100$ bytes, modeled as addresses from $0$ to $M-1$; the initial state is a single free block of size $100$.\n- Requests are a sequence of $10$ operations that either allocate or free a block, referenced by an identifier. Allocation sizes are in bytes. The sequence is:\n  - Allocate id $1$ size $20$.\n  - Allocate id $2$ size $10$.\n  - Allocate id $3$ size $15$.\n  - Free id $2$.\n  - Allocate id $4$ size $9$.\n  - Allocate id $5$ size $8$.\n  - Free id $3$.\n  - Allocate id $6$ size $12$.\n  - Free id $1$.\n  - Allocate id $7$ size $18$.\n- Use strict address ordering to represent the free list and allocated blocks; ties in block choice are resolved by choosing the lowest starting address.\n- Assume all allocations in this sequence succeed under the rule above.\n\nTest suite of split thresholds:\n- Evaluate the system for $\\epsilon \\in \\{0, 2, 4, 12\\}$, with $\\epsilon$ measured in bytes.\n\nProgram requirements:\n- Simulate the sequence for each $\\epsilon$ independently under each policy: first-fit (FF), best-fit (BF), and worst-fit (WF). The allocator operates exactly as defined above, including immediate coalescing upon free and the split-threshold rule on allocate.\n- For each pair $(\\epsilon, \\text{policy})$, compute the final external fragmentation $E$ (dimensionless) and the final internal fragmentation $I$ (in bytes). There are no other physical units involved beyond bytes, and angles are not used.\n- Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each $\\epsilon$ in ascending order $\\{0, 2, 4, 12\\}$, append six floating-point numbers in this order: $E_{\\mathrm{FF}}$, $I_{\\mathrm{FF}}$, $E_{\\mathrm{BF}}$, $I_{\\mathrm{BF}}$, $E_{\\mathrm{WF}}$, $I_{\\mathrm{WF}}$. Print each number as a floating-point value with exactly six digits after the decimal point. The final line should therefore contain $4 \\times 6 = 24$ floats in a single bracketed list, like\n$[\\dots]$.\n\nDesign goals and coverage:\n- The test suite includes $\\epsilon = 0$ as a baseline, a small threshold $\\epsilon = 2$ that affects only very small tails, a moderate threshold $\\epsilon = 4$ that suppresses more tails, and a larger threshold $\\epsilon = 12$ to stress the trade-off.\n- This covers happy-path scenarios, boundary-like cases for the threshold rule, and policy differentiation, ensuring the results are quantifiable floats aggregated into a final single-line list as specified.", "solution": "We begin from the core definitions of contiguous memory allocation strategies and fragmentation. The allocator maintains an ordered list of memory segments by starting address, each described by $(\\text{start}, \\text{size}, \\text{is\\_free})$, and for allocated blocks also recording $(\\text{id}, \\text{requested\\_size}, \\text{allocated\\_size})$. The initial state is a single free segment of size $M = 100$ bytes.\n\nAllocation selection is governed by a policy that searches the free-list:\n- First-fit returns the first free segment of size at least $r$.\n- Best-fit returns the free segment of minimal size among those with size at least $r$; ties broken by the smallest starting address.\n- Worst-fit returns the free segment of maximal size among those with size at least $r$; ties broken by the smallest starting address.\n\nOnce a candidate free block of size $s$ is selected to satisfy a request of $r$ bytes, we compute the tail $t = s - r$ and apply the split-threshold rule:\n- If $t  \\epsilon$, then the allocation consumes the entire block of size $s$, which is assigned to the request. The internal waste recorded for this block is $s - r$. No new free segment is created from this block.\n- If $t \\ge \\epsilon$, the allocator splits the free block into an allocated block of size $r$ and a free block of size $t$ at the next address. The internal waste for this allocation is $0$ because the allocated size equals the requested size.\n\nUpon a free operation of a block with identifier $\\text{id}$, the segment is marked free and coalescing is performed immediately with adjacent free neighbors on both sides, merging them into a single free block. This invariant ensures the free list remains maximally coalesced given the allocation decisions.\n\nAt the end of the entire sequence, we compute:\n- The total free memory $F$ as the sum of sizes of all free segments.\n- The largest free block $L$ as the maximum size among free segments; if there are no free segments, $F = 0$.\n- The external fragmentation $E$ as\n$$\nE = \\begin{cases}\n0,  \\text{if } F = 0,\\\\\n1 - \\dfrac{L}{F},  \\text{if } F  0.\n\\end{cases}\n$$\n- The internal fragmentation $I$ as the sum over currently allocated segments of $\\text{allocated\\_size} - \\text{requested\\_size}$. Note that this is not a cumulative-over-time metric; it is the final-state internal waste locked within allocated blocks.\n\nAlgorithmic outline for the simulator:\n1. Represent memory as a dynamic array of segments sorted by starting address. Each event mutates this array.\n2. For an allocation of size $r$ under policy $P$:\n   - Scan free segments to choose the index according to $P$.\n   - If no segment of size at least $r$ exists, the sequence would fail; however, the provided sequence is consistent so that all allocations succeed under the given constraints.\n   - Let the chosen segment have size $s$ and start $a$. Compute $t = s - r$. If $t  \\epsilon$, allocate the entire segment: mark it allocated with $\\text{requested\\_size} = r$ and $\\text{allocated\\_size} = s$. If $t \\ge \\epsilon$, split: change the chosen segment to allocated of size $r$ and insert a new free segment immediately after with size $t$ and start $a + r$.\n3. For a free of identifier $\\text{id}$:\n   - Locate the allocated segment with that $\\text{id}$ and mark it free.\n   - Coalesce with the previous neighbor if it is free by merging sizes and adjusting the start. Then coalesce with the next neighbor if it is free. Since the list is kept sorted, coalescing takes constant time per neighbor.\n4. After processing all operations, compute $F$, $L$, $E$, and $I$ as specified.\n\nIllustrative derivation for one case to demonstrate principles:\nConsider $\\epsilon = 4$ under first-fit. The deterministic sequence on $M = 100$ is:\n- Allocate id $1$ size $20$: split $100 \\to 20 + 80$ since $80 \\ge 4$.\n- Allocate id $2$ size $10$: split $80 \\to 10 + 70$ since $70 \\ge 4$.\n- Allocate id $3$ size $15$: split $70 \\to 15 + 55$ since $55 \\ge 4$.\n- Free id $2$: the $10$-byte block becomes free.\n- Allocate id $4$ size $9$: choose the first free block of size $10$. The tail would be $t = 1$, and since $1  4$, consume the whole $10$-byte block. Record internal waste $10 - 9 = 1$ on id $4$.\n- Allocate id $5$ size $8$: choose the next free block of size $55$; split into $8 + 47$ since $47 \\ge 4$.\n- Free id $3$: the $15$-byte block becomes free; its neighbors are allocated, so no coalescing beyond itself.\n- Allocate id $6$ size $12$: choose the first free block of size $15$. The tail would be $t = 3$, and since $3  4$, consume the whole $15$-byte block. Record internal waste $15 - 12 = 3$ on id $6$.\n- Free id $1$: the $20$-byte block becomes free.\n- Allocate id $7$ size $18$: choose the first free block of size $20$. The tail would be $t = 2$, and since $2  4$, consume the whole $20$-byte block. Record internal waste $20 - 18 = 2$ on id $7$.\n\nAt the end, the only free memory is the $47$-byte block; hence $F = 47$, $L = 47$, so $E = 1 - 47/47 = 0$. The internal fragmentation is $I = 1 + 3 + 2 = 6$ bytes. This demonstrates how increasing $\\epsilon$ suppresses small external fragments at the cost of increased internal waste.\n\nFor comparison, under worst-fit with the same $\\epsilon = 4$, the selection repeatedly picks the largest block, creating large tails that are always at least $\\epsilon$; therefore $I = 0$, and the final free set is three blocks whose sizes sum to $F = 65$ with $L = 27$, giving $E = 1 - 27/65 \\approx 0.584615$.\n\nBy executing the defined sequence for each $\\epsilon \\in \\{0, 2, 4, 12\\}$ and each policy, the simulator computes the final $E$ and $I$ values. The program must output a single bracketed list of $24$ floating-point numbers, ordered per $\\epsilon$ as $E_{\\mathrm{FF}}, I_{\\mathrm{FF}}, E_{\\mathrm{BF}}, I_{\\mathrm{BF}}, E_{\\mathrm{WF}}, I_{\\mathrm{WF}}$, with exactly six digits after the decimal point, separated by commas and no additional text.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\ntypedef struct {\n    int start;\n    int size;\n    int is_free;      // 1 if free, 0 if allocated\n    int id;           // allocation id if allocated, else -1\n    int req_size;     // requested size if allocated\n    int alloc_size;   // allocated size (may exceed request if tail absorbed)\n} Segment;\n\ntypedef struct {\n    int is_alloc; // 1 for alloc, 0 for free\n    int id;       // allocation id\n    int size;     // request size for alloc; ignored for free\n} Operation;\n\ntypedef struct {\n    int epsilon; // threshold in bytes\n} TestCase;\n\n// Policies\nenum { POLICY_FF = 0, POLICY_BF = 1, POLICY_WF = 2 };\n\nstatic void init_memory(Segment *segs, int *n, int mem_size) {\n    *n = 1;\n    segs[0].start = 0;\n    segs[0].size = mem_size;\n    segs[0].is_free = 1;\n    segs[0].id = -1;\n    segs[0].req_size = 0;\n    segs[0].alloc_size = 0;\n}\n\nstatic void insert_segment(Segment *segs, int *n, int idx, Segment s) {\n    // insert at position idx, shifting right\n    for (int i = *n; i  idx; --i) {\n        segs[i] = segs[i - 1];\n    }\n    segs[idx] = s;\n    (*n)++;\n}\n\nstatic void remove_segment(Segment *segs, int *n, int idx) {\n    for (int i = idx; i  *n - 1; ++i) {\n        segs[i] = segs[i + 1];\n    }\n    (*n)--;\n}\n\nstatic void coalesce(Segment *segs, int *n) {\n    // Coalesce adjacent free segments; array must be sorted by start\n    int i = 0;\n    while (i  *n - 1) {\n        if (segs[i].is_free  segs[i + 1].is_free \n            segs[i].start + segs[i].size == segs[i + 1].start) {\n            // merge i and i+1 into i\n            segs[i].size += segs[i + 1].size;\n            remove_segment(segs, n, i + 1);\n            // do not increment i; may be more to merge\n        } else {\n            i++;\n        }\n    }\n}\n\nstatic int find_block(const Segment *segs, int n, int req, int policy) {\n    int idx = -1;\n    if (policy == POLICY_FF) {\n        for (int i = 0; i  n; ++i) {\n            if (segs[i].is_free  segs[i].size = req) {\n                idx = i;\n                break;\n            }\n        }\n    } else if (policy == POLICY_BF) {\n        int best_size = 0x7fffffff;\n        int best_start = -1;\n        for (int i = 0; i  n; ++i) {\n            if (segs[i].is_free  segs[i].size = req) {\n                if (segs[i].size  best_size ||\n                    (segs[i].size == best_size  (best_start == -1 || segs[i].start  best_start))) {\n                    best_size = segs[i].size;\n                    best_start = segs[i].start;\n                    idx = i;\n                }\n            }\n        }\n    } else if (policy == POLICY_WF) {\n        int best_size = -1;\n        int best_start = -1;\n        for (int i = 0; i  n; ++i) {\n            if (segs[i].is_free  segs[i].size = req) {\n                if (segs[i].size  best_size ||\n                    (segs[i].size == best_size  (best_start == -1 || segs[i].start  best_start))) {\n                    best_size = segs[i].size;\n                    best_start = segs[i].start;\n                    idx = i;\n                }\n            }\n        }\n    }\n    return idx;\n}\n\nstatic int allocate_block(Segment *segs, int *n, int req, int id, int policy, int epsilon) {\n    int idx = find_block(segs, *n, req, policy);\n    if (idx  0) return 0; // allocation fails\n    int s = segs[idx].size;\n    int start = segs[idx].start;\n    int tail = s - req;\n\n    if (tail  epsilon) {\n        // consume entire block\n        segs[idx].is_free = 0;\n        segs[idx].id = id;\n        segs[idx].req_size = req;\n        segs[idx].alloc_size = s;\n        // size and start unchanged\n    } else {\n        // split: allocated of size req, then free of tail\n        segs[idx].is_free = 0;\n        segs[idx].id = id;\n        segs[idx].req_size = req;\n        segs[idx].alloc_size = req;\n        segs[idx].size = req;\n        Segment tail_seg;\n        tail_seg.start = start + req;\n        tail_seg.size = tail;\n        tail_seg.is_free = 1;\n        tail_seg.id = -1;\n        tail_seg.req_size = 0;\n        tail_seg.alloc_size = 0;\n        insert_segment(segs, n, idx + 1, tail_seg);\n    }\n    return 1;\n}\n\nstatic void free_block(Segment *segs, int *n, int id) {\n    for (int i = 0; i  *n; ++i) {\n        if (!segs[i].is_free  segs[i].id == id) {\n            segs[i].is_free = 1;\n            segs[i].id = -1;\n            segs[i].req_size = 0;\n            segs[i].alloc_size = 0;\n            // coalesce around i: merge with previous and next if free\n            // First coalesce with previous if adjacent and free\n            if (i - 1 = 0  segs[i - 1].is_free \n                segs[i - 1].start + segs[i - 1].size == segs[i].start) {\n                segs[i - 1].size += segs[i].size;\n                remove_segment(segs, n, i);\n                i -= 1; // current block is now at i-1\n            }\n            // Then coalesce with next if adjacent and free\n            if (i + 1  *n  segs[i].is_free  segs[i + 1].is_free \n                segs[i].start + segs[i].size == segs[i + 1].start) {\n                segs[i].size += segs[i + 1].size;\n                remove_segment(segs, n, i + 1);\n            }\n            return;\n        }\n    }\n}\n\nstatic void compute_metrics(const Segment *segs, int n, double *E_out, double *I_out) {\n    int total_free = 0;\n    int largest_free = 0;\n    double internal = 0.0;\n    for (int i = 0; i  n; ++i) {\n        if (segs[i].is_free) {\n            total_free += segs[i].size;\n            if (segs[i].size  largest_free) largest_free = segs[i].size;\n        } else {\n            internal += (double)(segs[i].alloc_size - segs[i].req_size);\n        }\n    }\n    double E = 0.0;\n    if (total_free  0) {\n        E = 1.0 - ((double)largest_free / (double)total_free);\n    } else {\n        E = 0.0;\n    }\n    *E_out = E;\n    *I_out = internal;\n}\n\nint main(void) {\n    // Define the test cases (epsilon values in bytes).\n    TestCase test_cases[] = {\n        { 0 },\n        { 2 },\n        { 4 },\n        { 12 }\n    };\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n\n    // Define the fixed operation sequence.\n    Operation ops[] = {\n        {1, 1, 20},  // alloc id=1 size=20\n        {1, 2, 10},  // alloc id=2 size=10\n        {1, 3, 15},  // alloc id=3 size=15\n        {0, 2, 0},   // free id=2\n        {1, 4, 9},   // alloc id=4 size=9\n        {1, 5, 8},   // alloc id=5 size=8\n        {0, 3, 0},   // free id=3\n        {1, 6, 12},  // alloc id=6 size=12\n        {0, 1, 0},   // free id=1\n        {1, 7, 18}   // alloc id=7 size=18\n    };\n    int num_ops = (int)(sizeof(ops) / sizeof(ops[0]));\n\n    const int MEM_SIZE = 100;\n\n    // We'll collect outputs in a flat array: for each epsilon: FF_E, FF_I, BF_E, BF_I, WF_E, WF_I\n    int outputs_per_case = 6;\n    int total_outputs = num_cases * outputs_per_case;\n    double out[64];\n    int out_idx = 0;\n\n    for (int c = 0; c  num_cases; ++c) {\n        int epsilon = test_cases[c].epsilon;\n\n        for (int policy = 0; policy  3; ++policy) {\n            // Initialize memory\n            Segment segs[256];\n            int nsegs = 0;\n            init_memory(segs, nsegs, MEM_SIZE);\n\n            // Replay operations\n            for (int i = 0; i  num_ops; ++i) {\n                if (ops[i].is_alloc) {\n                    int ok = allocate_block(segs, nsegs, ops[i].size, ops[i].id, policy, epsilon);\n                    if (!ok) {\n                        // According to problem, all allocations succeed; but if not, stop\n                        // Ensure consistent metrics: E=0, I=0\n                        // To maintain deterministic output, leave as is.\n                        ;\n                    }\n                } else {\n                    free_block(segs, nsegs, ops[i].id);\n                }\n            }\n            // Ensure coalescing invariant holds (should already be true)\n            coalesce(segs, nsegs);\n\n            // Compute metrics\n            double E = 0.0, I = 0.0;\n            compute_metrics(segs, nsegs, E, I);\n\n            out[out_idx++] = E;\n            out[out_idx++] = I;\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    // Single line, bracketed, comma-separated, each with six digits after the decimal point.\n    printf(\"[\");\n    for (int i = 0; i  total_outputs; ++i) {\n        printf(\"%.6f\", out[i]);\n        if (i != total_outputs - 1) printf(\",\");\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3644173"}]}