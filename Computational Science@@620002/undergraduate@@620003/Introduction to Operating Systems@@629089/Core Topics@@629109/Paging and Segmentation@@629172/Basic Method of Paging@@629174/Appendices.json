{"hands_on_practices": [{"introduction": "Understanding paging begins with mastering the fundamental mechanics of address translation. This first exercise guides you through converting a virtual address into a physical address in a simple, single-level paging system. By working through these concrete examples, you will practice partitioning a virtual address, using a page table for lookups, and identifying page faults when a mapping is not present.", "problem": "Consider a single-level paging system for a process with a virtual address space of size $2^{24}$ bytes. The page size is $4\\,\\text{KiB}$, which equals $2^{12}$ bytes. Physical memory is organized into frames of the same size as pages, and frame indices range from $0$ up to $2047$. A page fault occurs when a referenced virtual page has no valid mapping to a physical frame.\n\nThe process has the following partial page-to-frame mappings (a mapping absent from the list means the page is not currently resident and would cause a page fault):\n- Virtual page $7$ maps to physical frame $33$.\n- Virtual page $15$ maps to physical frame $81$.\n- Virtual page $205$ maps to physical frame $512$.\n- Virtual page $3000$ maps to physical frame $1020$.\n- Virtual page $4095$ maps to physical frame $2047$.\n\nYou are given the following virtual addresses (all in bytes):\n- $VA_1 = 28{,}795$.\n- $VA_2 = 33{,}024$.\n- $VA_3 = 842{,}752$.\n- $VA_4 = 12{,}293{,}120$.\n- $VA_5 = 16{,}777{,}215$.\n- $VA_6 = 61{,}440$.\n\nStarting from core definitions, determine for each $VA_i$ whether it refers to a resident page or incurs a page fault, and if resident, determine the corresponding physical address by translating the virtual address through the given mappings. Let $S$ be defined as the sum of the physical addresses for all resident references plus $1000$ times the number of page faults over the list. Compute $S$.\n\nExpress your final answer for $S$ in bytes as a single exact integer with no rounding and no units. While you should identify page faults in your working, only report the value of $S$.", "solution": "The problem requires us to perform virtual-to-physical address translation for a series of virtual addresses within a single-level paging system, determine which references result in page faults, and compute a final score $S$ based on the results.\n\nFirst, we establish the fundamental principles of address translation in a paging system. A virtual address, denoted as $VA$, is partitioned into two components: a virtual page number ($p$) and a page offset ($d$). The physical address, $PA$, is similarly composed of a physical frame number ($f$) and the same offset $d$. The mapping from $p$ to $f$ is managed by a page table.\n\nThe translation process is as follows:\nGiven a $VA$ and a page size $PS$:\n1.  The virtual page number is calculated by integer division: $p = \\lfloor \\frac{VA}{PS} \\rfloor$.\n2.  The offset is the remainder: $d = VA \\pmod{PS}$.\n3.  The page table is consulted to find the frame number $f$ corresponding to the page number $p$.\n    - If a valid mapping exists, the page is resident in physical memory.\n    - If no valid mapping exists, a page fault occurs.\n4.  If the page is resident, the physical address is constructed: $PA = f \\times PS + d$.\n\nFrom the problem statement, we have the following parameters:\n- The page size is $PS = 4\\,\\text{KiB} = 2^{12}\\,\\text{bytes} = 4096\\,\\text{bytes}$.\n- The partial page table mappings are:\n    - Virtual page $7 \\to$ physical frame $33$.\n    - Virtual page $15 \\to$ physical frame $81$.\n    - Virtual page $205 \\to$ physical frame $512$.\n    - Virtual page $3000 \\to$ physical frame $1020$.\n    - Virtual page $4095 \\to$ physical frame $2047$.\n\nWe will now process each given virtual address. Let $N_{faults}$ be a counter for page faults, initialized to $0$, and $\\sum PA$ be the sum of physical addresses for resident pages, initialized to $0$.\n\n1.  For $VA_1 = 28{,}795$:\n    - Virtual page number $p_1 = \\lfloor \\frac{28795}{4096} \\rfloor = \\lfloor 7.0300... \\rfloor = 7$.\n    - Offset $d_1 = 28795 \\pmod{4096} = 123$.\n    - The page table contains a mapping for virtual page $p_1 = 7$. The corresponding physical frame is $f_1 = 33$. This is a memory hit.\n    - The physical address is $PA_1 = f_1 \\times PS + d_1 = 33 \\times 4096 + 123 = 135168 + 123 = 135291$.\n    - We add this to our sum: $\\sum PA = 135291$.\n\n2.  For $VA_2 = 33{,}024$:\n    - Virtual page number $p_2 = \\lfloor \\frac{33024}{4096} \\rfloor = \\lfloor 8.0625 \\rfloor = 8$.\n    - Offset $d_2 = 33024 \\pmod{4096} = 256$.\n    - The page table does not contain a mapping for virtual page $p_2 = 8$. This is a page fault.\n    - We increment the fault counter: $N_{faults} = 1$.\n\n3.  For $VA_3 = 842{,}752$:\n    - Virtual page number $p_3 = \\lfloor \\frac{842752}{4096} \\rfloor = \\lfloor 205.75 \\rfloor = 205$.\n    - Offset $d_3 = 842752 \\pmod{4096} = 3072$.\n    - The page table contains a mapping for virtual page $p_3 = 205$. The corresponding physical frame is $f_3 = 512$. This is a memory hit.\n    - The physical address is $PA_3 = f_3 \\times PS + d_3 = 512 \\times 4096 + 3072 = 2097152 + 3072 = 2100224$.\n    - We add this to our sum: $\\sum PA = 135291 + 2100224 = 2235515$.\n\n4.  For $VA_4 = 12{,}293{,}120$:\n    - Virtual page number $p_4 = \\lfloor \\frac{12293120}{4096} \\rfloor = \\lfloor 3001.25 \\rfloor = 3001$.\n    - Offset $d_4 = 12293120 \\pmod{4096} = 1024$.\n    - The page table does not contain a mapping for virtual page $p_4 = 3001$. This is a page fault.\n    - We increment the fault counter: $N_{faults} = 2$.\n\n5.  For $VA_5 = 16{,}777{,}215$:\n    - Virtual page number $p_5 = \\lfloor \\frac{16777215}{4096} \\rfloor = \\lfloor 4095.999... \\rfloor = 4095$. Note that $16777215 = 2^{24}-1$. Thus, $p_5=\\lfloor \\frac{2^{24}-1}{2^{12}} \\rfloor = \\lfloor 2^{12} - 2^{-12} \\rfloor = 2^{12}-1=4095$.\n    - Offset $d_5 = 16777215 \\pmod{4096} = 4095$.\n    - The page table contains a mapping for virtual page $p_5 = 4095$. The corresponding physical frame is $f_5 = 2047$. This is a memory hit.\n    - The physical address is $PA_5 = f_5 \\times PS + d_5 = 2047 \\times 4096 + 4095 = 8384512 + 4095 = 8388607$.\n    - We add this to our sum: $\\sum PA = 2235515 + 8388607 = 10624122$.\n\n6.  For $VA_6 = 61{,}440$:\n    - Virtual page number $p_6 = \\lfloor \\frac{61440}{4096} \\rfloor = \\lfloor 15 \\rfloor = 15$.\n    - Offset $d_6 = 61440 \\pmod{4096} = 0$.\n    - The page table contains a mapping for virtual page $p_6 = 15$. The corresponding physical frame is $f_6 = 81$. This is a memory hit.\n    - The physical address is $PA_6 = f_6 \\times PS + d_6 = 81 \\times 4096 + 0 = 331776$.\n    - We add this to our sum: $\\sum PA = 10624122 + 331776 = 10955898$.\n\nAfter processing all virtual addresses, we have the following summary:\n- Total sum of physical addresses for resident pages: $\\sum PA = 10955898$.\n- Total number of page faults: $N_{faults} = 2$.\n\nFinally, we compute the value of $S$ using the given formula:\n$S = (\\sum PA) + 1000 \\times N_{faults}$\n$S = 10955898 + 1000 \\times 2$\n$S = 10955898 + 2000$\n$S = 10957898$.", "answer": "$$\\boxed{10957898}$$", "id": "3623012"}, {"introduction": "While single-level page tables are conceptually simple, they are impractical for the vast virtual address spaces of modern systems, which would require enormous, contiguous page tables. This practice introduces two-level paging, a common technique to make page tables manageable by breaking them into smaller pieces. You will focus on the crucial first step of any translation: deconstructing a virtual address into its constituent parts—the outer page table index, the inner page table index, and the offset—which are essential for navigating the hierarchical table structure.", "problem": "A computer system implements two-level paging in its virtual memory subsystem. A Virtual Address (VA) is a $32$-bit unsigned integer. Pages have size $4$ kibibytes (KiB), and the two-level page table layout uses $p_{1} = 10$ bits to index the outer page table and $p_{2} = 10$ bits to index the inner page table. The offset within a page uses the remaining low-order bits. The bit layout of the $32$-bit VA, from most significant to least significant bit, is therefore $[p_{1}][p_{2}][\\text{offset}]$. Assume the conventional interpretation that the most significant bit is bit $31$ and the least significant bit is bit $0$, and the layout applies to the logical bit fields of the integer value of the VA (independent of byte endianness).\n\nUsing the concrete Virtual Address (VA) value $VA = \\texttt{0xCAFEBABE}$, compute:\n- the numerical value of the outer page table index (the $p_{1}$-bit field),\n- the numerical value of the inner page table index (the $p_{2}$-bit field),\n- the numerical value of the offset within the page.\n\nExpress your final answer as a single row matrix containing the three integers in the order outer index, inner index, offset. No rounding is required, and no physical units are involved.", "solution": "The problem is first assessed for validity.\n\n### Step 1: Extract Givens\n- Virtual Address ($VA$) size: $32$-bit unsigned integer.\n- Paging scheme: two-level.\n- Page size: $4$ kibibytes (KiB).\n- Outer page table index field size: $p_1 = 10$ bits.\n- Inner page table index field size: $p_2 = 10$ bits.\n- Offset field size: remaining low-order bits.\n- $VA$ bit layout (MSB to LSB): $[p_1][p_2][\\text{offset}]$.\n- Specific $VA$ to analyze: $VA = \\texttt{0xCAFEBABE}$.\n- Required output: numerical values for the outer index, inner index, and offset.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as two-level paging is a standard memory management technique in operating systems. The given parameters are checked for internal consistency.\n\nThe page size is $4$ KiB. One kibibyte is $2^{10}$ bytes, so the page size is $4 \\times 2^{10} = 2^2 \\times 2^{10} = 2^{12}$ bytes. The number of bits required for the byte offset within a page, let's call it $d$, is determined by the page size:\n$$d = \\log_2(\\text{Page Size in bytes}) = \\log_2(2^{12}) = 12 \\text{ bits}$$\nThe total number of bits in the virtual address is the sum of the bits for the indices and the offset:\n$$\\text{Total bits} = p_1 + p_2 + d = 10 + 10 + 12 = 32 \\text{ bits}$$\nThis matches the specified $32$-bit virtual address size. The problem is self-contained, consistent, and well-posed.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived.\n\n### Solution Derivation\n\nThe virtual address is a $32$-bit value. The structure is defined from the most significant bit (MSB), bit $31$, to the least significant bit (LSB), bit $0$.\n- The outer page table index, $p_1$, consists of the $10$ most significant bits (bits $31$ down to $22$).\n- The inner page table index, $p_2$, consists of the next $10$ bits (bits $21$ down to $12$).\n- The offset, $d$, consists of the $12$ least significant bits (bits $11$ down to $0$).\n\nThe specific virtual address to analyze is given in hexadecimal as $VA = \\texttt{0xCAFEBABE}$. To extract the fields, we first convert this hexadecimal value to its $32$-bit binary representation. Each hexadecimal digit corresponds to $4$ binary bits:\n- $\\texttt{C}_{16} = 12_{10} = 1100_2$\n- $\\texttt{A}_{16} = 10_{10} = 1010_2$\n- $\\texttt{F}_{16} = 15_{10} = 1111_2$\n- $\\texttt{E}_{16} = 14_{10} = 1110_2$\n- $\\texttt{B}_{16} = 11_{10} = 1011_2$\n\nAssembling the full binary string for $VA = \\texttt{0xCAFEBABE}$:\n$$VA_{\\text{bin}} = 11001010111111101011101010111110_2$$\n\nNow, we partition this $32$-bit string into the three fields according to their specified sizes ($10$, $10$, and $12$ bits):\n$$VA_{\\text{bin}} = \\underbrace{1100101011}_{p_1 \\text{ (10 bits)}} \\underbrace{1111101011}_{p_2 \\text{ (10 bits)}} \\underbrace{101010111110}_{d \\text{ (12 bits)}}$$\n\nWe proceed to compute the decimal value for each field.\n\n1.  **Outer Page Table Index ($p_1$)**:\n    The binary value is $1100101011_2$. Its decimal equivalent is:\n    $$p_1 = 1 \\cdot 2^9 + 1 \\cdot 2^8 + 0 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$$\n    $$p_1 = 512 + 256 + 0 + 0 + 32 + 0 + 8 + 0 + 2 + 1 = 811$$\n\n2.  **Inner Page Table Index ($p_2$)**:\n    The binary value is $1111101011_2$. Its decimal equivalent is:\n    $$p_2 = 1 \\cdot 2^9 + 1 \\cdot 2^8 + 1 \\cdot 2^7 + 1 \\cdot 2^6 + 1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$$\n    $$p_2 = 512 + 256 + 128 + 64 + 32 + 0 + 8 + 0 + 2 + 1 = 1003$$\n\n3.  **Offset ($d$)**:\n    The binary value is $101010111110_2$. This corresponds to the last three hexadecimal digits, $\\texttt{ABE}_{16}$. Its decimal equivalent is:\n    $$d = 10 \\cdot 16^2 + 11 \\cdot 16^1 + 14 \\cdot 16^0$$\n    $$d = 10 \\cdot 256 + 11 \\cdot 16 + 14 \\cdot 1$$\n    $$d = 2560 + 176 + 14 = 2750$$\n    Alternatively, from its binary representation:\n    $$d = 1 \\cdot 2^{11} + 0 \\cdot 2^{10} + 1 \\cdot 2^9 + 0 \\cdot 2^8 + 1 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0$$\n    $$d = 2048 + 512 + 128 + 32 + 16 + 8 + 4 + 2 = 2750$$\n\nThe computed integer values are $811$ for the outer page table index, $1003$ for the inner page table index, and $2750$ for the offset.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n811 & 1003 & 2750\n\\end{pmatrix}\n}\n$$", "id": "3623008"}, {"introduction": "Traversing a page table for every memory reference, which may itself involve multiple memory accesses, would be prohibitively slow. To accelerate this process, modern CPUs use a specialized cache called the Translation Lookaside Buffer (TLB). This exercise introduces the concept of Effective Access Time ($EAT$), a powerful metric for analyzing memory system performance. You will learn to derive the $EAT$ by creating a probabilistic model that accounts for the significant speed-up from TLB hits and the penalty incurred by TLB misses.", "problem": "A computer system uses single-level paging with a Translation Lookaside Buffer (TLB) of capacity $64$ entries. Under a steady workload, the measured TLB hit rate is $h = 0.9$. The main memory access time is $t_m$ seconds per access. The TLB lookup is performed in parallel with main memory address translation such that, on a TLB hit, only a single main memory access is required to fetch the requested data. On a TLB miss that does not result in a page fault, the processor performs a single-level page table lookup in main memory and then proceeds to the data access, resulting in a total of two main memory accesses. Ignore page fault service time and any TLB refill overhead beyond the page-table read implied by the single-level paging model.\n\nStarting from first principles of paging and probabilistic expectation, derive the effective access time, denoted $EAT$, as a closed-form symbolic expression in terms of $t_m$. Express the final effective access time in seconds. No rounding is required.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It describes a standard model for calculating effective memory access time in a system with a Translation Lookaside Buffer (TLB) and single-level paging. The provided data are sufficient and consistent for deriving the requested expression.\n\nThe effective access time, denoted $EAT$, is the expected value of the time required for a memory access. It is calculated as a weighted average of the access times for all possible scenarios, where the weights are the probabilities of those scenarios. In this system, a memory access can result in one of two outcomes: a TLB hit or a TLB miss. We are instructed to ignore page faults.\n\nLet $h$ be the TLB hit rate, which is the probability of finding a page table entry in the TLB. The problem states that $h = 0.9$.\nThe probability of a TLB hit is $P(\\text{hit}) = h$.\nConsequently, the probability of a TLB miss is $P(\\text{miss}) = 1 - h$.\n\nNext, we must determine the time cost associated with each of these outcomes. The main memory access time is given as $t_m$ seconds.\n\nCase 1: TLB Hit\nThe problem states that on a TLB hit, the translation is found in the TLB, and then \"only a single main memory access is required to fetch the requested data.\" This means the time taken for a memory access in the event of a TLB hit, $T_{\\text{hit}}$, is the time for one access to main memory.\n$$T_{\\text{hit}} = t_m$$\nThe time for the TLB lookup itself is considered negligible as is common in such models, or it is performed in parallel and does not add to the critical path time beyond the single memory access.\n\nCase 2: TLB Miss (without a page fault)\nThe problem states that on a TLB miss, the processor first performs a page table lookup in main memory. Since this is a single-level paging system, this lookup requires one access to main memory to fetch the page table entry. After obtaining the physical frame number, the processor performs a second main memory access to fetch the actual data. The problem statement confirms this: \"...resulting in a total of two main memory accesses.\"\nThus, the time taken for a memory access in the event of a TLB miss, $T_{\\text{miss}}$, is the sum of the times for these two accesses.\n$$T_{\\text{miss}} = t_m + t_m = 2t_m$$\n\nNow, we can formulate the expression for the effective access time ($EAT$) using the principle of expected value:\n$$EAT = P(\\text{hit}) \\times T_{\\text{hit}} + P(\\text{miss}) \\times T_{\\text{miss}}$$\nSubstituting the probabilities and time costs derived above:\n$$EAT = h \\cdot T_{\\text{hit}} + (1 - h) \\cdot T_{\\text{miss}}$$\n$$EAT = h \\cdot (t_m) + (1 - h) \\cdot (2t_m)$$\n\nTo derive the closed-form symbolic expression in terms of $t_m$, we perform algebraic simplification:\n$$EAT = h \\cdot t_m + 2t_m - 2h \\cdot t_m$$\n$$EAT = (h - 2h) \\cdot t_m + 2t_m$$\n$$EAT = -h \\cdot t_m + 2t_m$$\nFactoring out $t_m$, we obtain the general symbolic expression:\n$$EAT = (2 - h)t_m$$\n\nThe problem provides a specific numerical value for the hit rate, $h = 0.9$. We substitute this value into the symbolic expression to find the final answer.\n$$EAT = (2 - 0.9)t_m$$\n$$EAT = 1.1 t_m$$\nThe units are seconds, as $t_m$ is in seconds. The TLB capacity of $64$ entries is contextual information about the system's hardware but is not required for the calculation of $EAT$.", "answer": "$$\\boxed{1.1 t_m}$$", "id": "3623058"}]}