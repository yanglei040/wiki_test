{"hands_on_practices": [{"introduction": "To truly grasp memory management, we must connect abstract programming concepts to concrete hardware events. This first exercise models a common scenario—a growing program stack—to challenge you to calculate the precise number of page faults that occur, translating a single logical operation into a sequence of low-level system actions. This practice builds foundational skills in converting linear addresses to page indices and reasoning about demand paging in a dynamic, real-world scenario [@problem_id:3680814].", "problem": "A user process runs on a system that combines segmentation with paging. The stack segment grows toward lower linear addresses. Let the stack segment have base $B$ and current logical stack pointer offset $s_{0}$, so that the current top-of-stack linear address after segmentation is $A_{0} = B + s_{0}$. Paging then divides linear memory into fixed-size pages of size $P$ bytes, aligned at multiples of $P$. A page fault occurs on the first access to any linear page that is not yet mapped; the Operating System (OS) allocates such a page on demand upon the fault and resumes the faulting instruction.\n\nAssume the following concrete scenario:\n- The stack segment base is $B = 0$, so the current top-of-stack linear address is $A_{0} = s_{0}$.\n- The current top-of-stack linear address is $A_{0} = 32780$.\n- The page size is $P = 4096$ bytes.\n- Exactly one page is currently mapped for the stack: the page that contains $A_{0}$. All lower linear pages in the stack region are unmapped.\n- The program allocates a new stack frame by decrementing the stack pointer by $\\Delta = 10000$ bytes and initializing the frame so that at least one byte is written in every page intersected by the linear address interval of this frame expansion. Concretely, the instruction sequence accesses each linear address in the closed interval $\\left[A_{0} - \\Delta + 1,\\, A_{0}\\right]$ at least once, thereby touching every page that the interval overlaps.\n- The stack segment limit is sufficiently large so that the segment bound is not violated by this operation.\n\nStarting from the core definitions that (i) segmentation produces a linear address $A = B + s$ and performs bound checks, and (ii) paging partitions the linear address space into pages of size $P$ with indices given by $\\left\\lfloor A / P \\right\\rfloor$, derive from first principles an expression for the number of distinct new pages touched when the stack pointer is decremented by $\\Delta$ from $A_{0}$, and use this to compute the number of page faults incurred under demand paging in this scenario. Provide your final answer as a single integer (no units). No rounding is required.", "solution": "The problem asks for the number of page faults incurred when a program's stack is expanded. The system uses segmentation with paging. We must first derive a general expression for the number of new pages touched and then compute the specific number of page faults for the given scenario.\n\nThe core principles are the functions that map a logical address to a linear address (segmentation) and a linear address to a physical address (paging). The problem simplifies the segmentation part by setting the segment base $B=0$, so a logical offset $s$ directly corresponds to a linear address $A=s$.\n\nPaging divides the linear address space into fixed-size pages of size $P$. A linear address $A$ is located on the page with index $p$, given by the expression:\n$$ p = \\left\\lfloor \\frac{A}{P} \\right\\rfloor $$\nwhere $\\lfloor \\cdot \\rfloor$ is the floor function. Any address $A'$ in the range $p \\times P \\le A' \\le (p+1) \\times P - 1$ belongs to the same page $p$.\n\nThe problem states that the stack grows toward lower addresses. The current top-of-stack linear address is $A_{0} = 32780$. The stack is expanded by decrementing the stack pointer by $\\Delta = 10000$ bytes. The problem specifies that this operation involves accessing every linear address in the closed interval $[A_{0} - \\Delta + 1, A_{0}]$.\n\nLet's define the boundaries of the linear address range that is accessed:\nThe highest address accessed is $A_{high} = A_{0}$.\nThe lowest address accessed is $A_{low} = A_{0} - \\Delta + 1$.\n\nUsing the given values:\n$A_{high} = 32780$.\n$A_{low} = 32780 - 10000 + 1 = 22781$.\n\nThe set of accessed linear addresses is the interval $[22781, 32780]$. To find the number of distinct pages touched, we need to find the page indices corresponding to $A_{low}$ and $A_{high}$. The page size is given as $P = 4096$ bytes.\n\nThe page index for the highest address $A_{high}$ is:\n$$ p_{high} = \\left\\lfloor \\frac{A_{high}}{P} \\right\\rfloor = \\left\\lfloor \\frac{A_{0}}{P} \\right\\rfloor $$\nThe page index for the lowest address $A_{low}$ is:\n$$ p_{low} = \\left\\lfloor \\frac{A_{low}}{P} \\right\\rfloor = \\left\\lfloor \\frac{A_{0} - \\Delta + 1}{P} \\right\\rfloor $$\nSince the memory access is contiguous over the interval $[A_{low}, A_{high}]$, all pages with indices from $p_{low}$ to $p_{high}$ are touched. The total number of distinct pages touched is:\n$$ N_{touched} = p_{high} - p_{low} + 1 $$\nA page fault occurs for each page that is touched but is not currently mapped in memory. The problem states that initially, \"exactly one page is currently mapped for the stack: the page that contains $A_{0}$\". The index of this page is $p_{high}$. All other pages, specifically those with indices lower than $p_{high}$ (since the stack grows downwards), are unmapped.\n\nThe set of all touched page indices is $\\{p_{low}, p_{low} + 1, \\dots, p_{high}\\}$.\nThe set of initially mapped pages (in this region) is $\\{p_{high}\\}$.\nThe set of pages that will cause a fault is the set of touched pages that are not in the initially mapped set:\n$$ \\{p_{low}, p_{low} + 1, \\dots, p_{high}\\} \\setminus \\{p_{high}\\} = \\{p_{low}, p_{low} + 1, \\dots, p_{high} - 1\\} $$\nThe number of page faults, $N_{faults}$, is the cardinality of this set, which is $(p_{high} - 1) - p_{low} + 1 = p_{high} - p_{low}$.\n\nThis gives us the general expression for the number of page faults:\n$$ N_{faults} = \\left\\lfloor \\frac{A_{0}}{P} \\right\\rfloor - \\left\\lfloor \\frac{A_{0} - \\Delta + 1}{P} \\right\\rfloor $$\nNow we substitute the concrete values from the problem into this expression:\n$A_{0} = 32780$\n$\\Delta = 10000$\n$P = 4096$\n\nFirst, we calculate $p_{high}$:\n$$ p_{high} = \\left\\lfloor \\frac{32780}{4096} \\right\\rfloor = \\lfloor 8.002929... \\rfloor = 8 $$\nSo, the initial top of stack is in page $8$. This is the page that is already mapped.\n\nNext, we calculate $p_{low}$:\n$$ p_{low} = \\left\\lfloor \\frac{32780 - 10000 + 1}{4096} \\right\\rfloor = \\left\\lfloor \\frac{22781}{4096} \\right\\rfloor = \\lfloor 5.561767... \\rfloor = 5 $$\nThe lowest address accessed is in page $5$.\n\nThe pages touched are pages $5, 6, 7,$ and $8$. Since page $8$ is already mapped, page faults will occur upon first access to pages $5, 6,$ and $7$.\n\nUsing our derived formula for the number of faults:\n$$ N_{faults} = p_{high} - p_{low} = 8 - 5 = 3 $$\nTherefore, a total of $3$ page faults will be incurred.", "answer": "$$\\boxed{3}$$", "id": "3680814"}, {"introduction": "Efficiently accessing large amounts of data is critical for system performance, and operating systems employ various strategies to minimize costly I/O operations. This practice explores a common optimization technique, prefetching, where the OS proactively loads data it anticipates will be needed soon. By analyzing a sequential file read, you will quantify the direct impact of this policy on the number of page faults, encouraging you to think about performance and system trade-offs [@problem_id:3680807].", "problem": "Consider an Operating System (OS) that implements segmentation with paging: each logical segment is divided into fixed-size pages of size $P$ bytes, and a segment is referenced via a segment table that points to the page table for that segment. A process maps a file of size $m$ bytes into a single segment, starting at segment offset $0$, and then performs a single sequential read of the entire mapped region from the beginning to the end. At time $t=0$, none of the segment’s pages are resident in physical memory; the OS uses demand paging, so referencing a page that is not resident triggers a page fault. Assume the following:\n- On a page fault, the OS services the fault by reading the faulting page from secondary storage and, as a read-ahead prefetch strategy, also reads the next $r$ consecutive pages in the same segment (if they exist within the $m$-byte range). These prefetched pages are brought into memory as part of handling the fault.\n- Physical memory and the page replacement policy ensure that once a page (faulted or prefetched) is brought in, it remains resident until it is accessed during this sequential read; no prefetched page is evicted before its use in this single pass.\n- Only major page faults that cause I/O to bring in a page from secondary storage are counted; accesses to pages already resident cause no faults. Translation Lookaside Buffer (TLB) behavior is irrelevant for this question.\n\nUsing only core definitions of segmentation with paging and demand paging behavior, derive a closed-form expression for the total number of page faults incurred during the single sequential pass through the $m$ bytes, as a function of $m$, $P$, and $r$. Express your final answer as a single analytic expression. No rounding is required.", "solution": "The problem asks for a closed-form expression for the total number of page faults incurred during a single sequential pass through a file of size $m$ bytes mapped into a single segment. The system uses segmentation with paging, with a page size of $P$ bytes. The key mechanisms are demand paging and a read-ahead prefetch strategy.\n\nFirst, we determine the total number of pages required for the segment. A file of size $m$ bytes mapped starting at offset $0$ will occupy bytes from offset $0$ to $m-1$. With a page size of $P$ bytes, the number of pages needed is the total size divided by the page size, rounded up to the nearest integer, because even a partially used page must be allocated. Let $N_{pages}$ be the total number of pages.\n$$N_{pages} = \\left\\lceil \\frac{m}{P} \\right\\rceil$$\nThese pages can be indexed from $0$ to $N_{pages}-1$.\n\nNext, we analyze the sequence of events as the process reads the file sequentially. Initially, at time $t=0$, no pages are resident in physical memory. The operating system uses demand paging, so pages are loaded only when they are accessed.\n\nThe sequential read begins at offset $0$, which is within page $0$. Since page $0$ is not in memory, this access triggers the first page fault.\nAccording to the specified prefetch strategy, when a page fault occurs, the OS loads the faulting page and also prefetches the next $r$ consecutive pages within the segment. Therefore, the first fault (on page $0$) causes the OS to load a block of pages. This block includes page $0$ and, if they exist, pages $1, 2, \\dots, r$. In total, up to $1+r$ pages are brought into memory as a result of this single fault.\n\nAfter the first fault is serviced, pages $0, 1, \\dots, r$ (or fewer if the segment is smaller than $r+1$ pages) are resident in memory. The process continues its sequential read through these pages. As they are all resident, no page faults occur during this phase.\n\nA subsequent page fault will only occur when the process attempts to access a byte in a page that was not loaded by the previous I/O operation. The first block of loaded pages ends at page $r$. Therefore, the next access to cause a fault will be on page $r+1$. This triggers the second page fault.\n\nServicing the second fault on page $r+1$ causes the OS to load another block of pages: the faulting page $r+1$ and the next $r$ pages, i.e., pages $r+2, \\dots, (r+1)+r = 2r+1$.\n\nThis establishes a clear pattern. A page fault is triggered each time the sequential access crosses into a page whose index is a multiple of $(r+1)$. The indices of the pages that will cause a fault are $0, (r+1), 2(r+1), 3(r+1)$, and so on.\n\nTo find the total number of page faults, we need to determine how many such fault-triggering events occur until all $N_{pages}$ are loaded into memory. Since each fault brings in a block of $1+r$ pages, the total number of faults is the total number of pages, $N_{pages}$, divided by the number of pages loaded per fault, $1+r$. We must use the ceiling function to account for the final, potentially partial, block of pages.\n\nLet $F$ be the total number of page faults.\n$$F = \\left\\lceil \\frac{N_{pages}}{r+1} \\right\\rceil$$\n\nSubstituting the expression for $N_{pages}$:\n$$F = \\left\\lceil \\frac{\\left\\lceil \\frac{m}{P} \\right\\rceil}{r+1} \\right\\rceil$$\n\nThis expression can be simplified using the mathematical identity $\\lceil \\frac{\\lceil x \\rceil}{n} \\rceil = \\lceil \\frac{x}{n} \\rceil$, which holds for any real number $x$ and any positive integer $n$. In our case, $x = m/P$ and $n = r+1$. Since the number of prefetched pages $r$ is a non-negative integer ($r \\ge 0$), $n = r+1$ is a positive integer. Applying this identity gives the final, simplified closed-form expression for the total number of page faults:\n$$F = \\left\\lceil \\frac{m/P}{r+1} \\right\\rceil = \\left\\lceil \\frac{m}{P(r+1)} \\right\\rceil$$\nThis expression correctly quantifies the number of I/O operations needed to bring the entire file into memory under the given conditions.", "answer": "$$\\boxed{\\left\\lceil \\frac{m}{P(r+1)} \\right\\rceil}$$", "id": "3680807"}, {"introduction": "The mechanisms of segmentation and paging are not just for organizing memory; they are fundamental to ensuring system security by enforcing protection boundaries. This final exercise presents a hypothetical but instructive hardware design flaw to demonstrate why the order of validation checks—specifically, comparing an offset to the segment limit—is critical. Your task is to analyze the vulnerability created by this flaw and calculate the extent of the resulting security breach, moving from simply using the abstraction to thinking critically about its correct implementation [@problem_id:3680741].", "problem": "A computer system implements segmentation with paging. Each virtual address consists of a segment selector $s$ and an offset $o$. For segment $s$, the segment descriptor contains a base $\\text{base}_s$ and a byte limit $\\text{limit}_s$. The segment’s pages have fixed size $P$ bytes, and the segment’s page table has $\\lceil \\text{limit}_s / P \\rceil$ entries. Address translation splits the offset $o$ into a page index $p = \\lfloor o / P \\rfloor$ and a page displacement $d = o \\bmod P$. The correct hardware check ordering is defined by the protection semantics of segmentation with paging: the offset must satisfy $o  \\text{limit}_s$ (so that the byte address lies within the segment), and only then may the page index $p$ be validated and used to consult the per-segment page table. In practice, validation of $p$ and use of the Translation Lookaside Buffer (TLB) must not allow memory access to occur before confirming $o  \\text{limit}_s$, especially when the last valid page is only partially populated by the segment.\n\nConsider segment $s$ with $P = 4096$ bytes and $\\text{limit}_s = 100000$ bytes. A workload generates $N = 10^{6}$ memory references uniformly distributed over byte offsets $o$ in the interval $[0, M)$ with $M = 120000$. The per-segment page table has $\\lceil \\text{limit}_s / P \\rceil$ entries. The last page that contains the segment’s logical end is present in memory and is resident in the TLB throughout the workload. In a flawed implementation, the hardware erroneously performs the $p$ bounds check and issues the memory access when there is a TLB hit before performing the $o  \\text{limit}_s$ check; the $o  \\text{limit}_s$ check completes later, but too late to prevent that access.\n\nStarting only from the above definitions and the protection requirement that a byte address is valid if and only if $o  \\text{limit}_s$, derive the correct ordering and explain why a $p$-first check cannot enforce the partial validity of the last page. Then, compute the expected number of unauthorized memory accesses that occur solely because of this wrong check order over the $N$ references. Express the final answer as a single number; do not include units. No rounding is required.", "solution": "The solution is divided into two parts: first, an explanation of the correct protection logic and the flaw in the described implementation, and second, the calculation of the expected number of unauthorized memory accesses.\n\n**Part 1: Correct Check Ordering and Flaw Analysis**\n\nThe fundamental principle of segment-based memory protection is that a virtual address, specified by a segment selector $s$ and an offset $o$, is valid if and only if the offset $o$ falls within the bounds of the segment. That is, the condition $0 \\le o  \\text{limit}_s$ must be satisfied. This check ensures that a process only accesses memory that has been allocated to it within that segment.\n\nThe use of paging underneath segmentation is a memory management technique to handle the physical placement of the segment's data. The offset $o$ is decomposed into a page index $p = \\lfloor o / P \\rfloor$ and a page displacement $d = o \\bmod P$. The page index $p$ is used to find the physical address of the page frame, and $d$ is used to locate the specific byte within that frame. This translation process is secondary to the primary protection check. A memory access is authorized only if the byte at offset $o$ is logically part of the segment.\n\nTherefore, the correct and secure hardware check ordering must be:\n1.  Validate the offset against the segment limit: check if $o  \\text{limit}_s$. If this fails, a segment violation (protection fault) must be raised, and the access must be aborted.\n2.  Only if the first check passes, proceed with the address translation: calculate $p = \\lfloor o / P \\rfloor$, check that $p$ is a valid index for the segment's page table, and then perform the memory access using the page table (or a TLB as a cache).\n\nThe problem describes a flawed implementation where the check on the page index $p$ and a subsequent TLB access occur before the definitive $o  \\text{limit}_s$ check. This ordering is insecure because the validity of a page index does not guarantee the validity of every byte offset that maps to it. This is particularly true for the last page of a segment, which is often only partially filled.\n\nLet's analyze this for the given segment $s$ with page size $P = 4096$ bytes and limit $\\text{limit}_s = 100000$ bytes.\nThe number of page table entries required for this segment is:\n$$ N_p = \\lceil \\frac{\\text{limit}_s}{P} \\rceil = \\lceil \\frac{100000}{4096} \\rceil = \\lceil 24.414... \\rceil = 25 $$\nThe valid page indices are therefore $p \\in \\{0, 1, 2, ..., 24\\}$. The last valid page index is $p_{\\text{last}} = 24$.\n\nThis last page, with index $p=24$, corresponds to byte offsets $o$ such that $\\lfloor o / 4096 \\rfloor = 24$. This inequality holds for all offsets $o$ in the range:\n$$ 24 \\times 4096 \\le o  25 \\times 4096 $$\n$$ 98304 \\le o  102400 $$\nHowever, the segment itself is only valid for offsets $o  \\text{limit}_s = 100000$. While the page with index $p=24$ covers the address range up to byte $102399$, the segment's legal addresses on this page end at byte $99999$. The offsets in the range $[100000, 102400)$ are outside the segment limit but map to a page index, $p=24$, that is considered valid by the flawed hardware.\n\nThe flawed check validates $p$ first. If a generated offset $o$ falls into the range $[100000, 102400)$, the hardware calculates $p = \\lfloor o/4096 \\rfloor = 24$. Since $p=24$ is a valid page index and the problem states this page is in the TLB, the hardware will find a TLB hit and issue the memory access. This access is unauthorized because $o \\ge \\text{limit}_s$. The check on $p$ effectively, and incorrectly, makes the entire last page accessible, failing to enforce the partial validity required by the precise segment limit.\n\n**Part 2: Calculation of Expected Unauthorized Accesses**\n\nAn unauthorized memory access occurs under the flawed implementation if the generated offset $o$ meets two conditions:\n1.  The access is invalid with respect to the segment limit: $o \\ge \\text{limit}_s$.\n2.  The access is erroneously permitted by the flawed check logic: the page index $p=\\lfloor o/P \\rfloor$ is a valid page index for the segment.\n\nFrom Part 1, the set of valid page indices is $p \\in \\{0, 1, ..., 24\\}$. This means the flawed logic permits any access for which $\\lfloor o/P \\rfloor \\le 24$. This implies $o/P  25$, or $o  25 \\times P$. With $P = 4096$, this condition is $o  25 \\times 4096 = 102400$.\n\nThe generated memory references have offsets $o$ uniformly distributed in the interval $[0, M)$ where $M = 120000$.\nThe segment limit is $\\text{limit}_s = 100000$.\n\nAn unauthorized access occurs for a generated offset $o$ that satisfies all of the following:\n- $o \\in [0, 120000)$ (it is generated by the workload)\n- $o \\ge 100000$ (it is truly invalid)\n- $o  102400$ (it is erroneously permitted by the flawed check)\n\nThe intersection of these conditions defines the interval of offsets that cause an unauthorized access:\n$$ o \\in [100000, 102400) $$\nThe length of this interval is $102400 - 100000 = 2400$.\n\nThe total range of generated offsets is $[0, 120000)$, which has a length of $M = 120000$.\nSince the offsets are uniformly distributed, the probability, $P_{\\text{unauth}}$, of a single memory reference causing an unauthorized access is the ratio of the length of the \"unauthorized\" interval to the length of the total interval:\n$$ P_{\\text{unauth}} = \\frac{102400 - 100000}{120000} = \\frac{2400}{120000} = \\frac{24}{1200} = \\frac{1}{50} = 0.02 $$\nThe total number of memory references is $N = 10^6$. The expected number of unauthorized accesses, $E$, is the total number of references multiplied by the probability of a single reference being unauthorized:\n$$ E = N \\times P_{\\text{unauth}} = 10^6 \\times 0.02 = 1000000 \\times \\frac{2}{100} = 20000 $$\nThus, we expect $20000$ unauthorized memory accesses to occur due to the flawed check ordering.", "answer": "$$\\boxed{20000}$$", "id": "3680741"}]}