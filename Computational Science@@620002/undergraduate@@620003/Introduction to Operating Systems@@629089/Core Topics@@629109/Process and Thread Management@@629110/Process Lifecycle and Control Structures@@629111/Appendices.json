{"hands_on_practices": [{"introduction": "Understanding the process lifecycle requires more than just memorizing state names like 'running' or 'ready'. This exercise challenges you to build a logical simulation of complex state transitions, including the often-misunderstood `STOPPED`, `ZOMBIE`, and `ORPHAN` states. By reasoning from a defined set of rules consistent with POSIX semantics, you will trace how signals and parent-child interactions determine a process's fate, solidifying your grasp of the core control structures that govern every process in a modern operating system. [@problem_id:3672144]", "problem": "You are to design and implement a self-contained simulation of a parent-child process interaction that is consistent with the common semantics of the Portable Operating System Interface (POSIX) signal model and process lifecycle rules. The simulation must start from first principles: the definitions of process states, the behavior of signals (including the signal named `SIGSTOP`), and the parent-child resource accounting relationship, as represented by the Process Control Block (PCB). The Process Control Block (PCB) is a logical record that holds a process's state, identifiers, and accounting information. A process has a Process Identifier (PID) and a User Identifier (UID). The parent process is the creator of the child via a fork-like operation, and is responsible for reaping the child upon termination through a wait-like action, otherwise the child can briefly enter a post-termination state that is commonly described as a zombie. When a process sends `SIGSTOP` to itself, it transitions to the stopped state, which prevents it from being scheduled until it receives a resume signal such as `SIGCONT` from an authorized process. In this model, authorization to send a resume signal is given to either the parent process while it is alive or any process with the same $UID$ as the target; a process with a different $UID$ cannot resume the target. If the parent exits while the child is still alive, the child becomes an orphan and is re-parented to a special system process that always reaps terminated orphans, thereby eliminating sustained zombie risk.\n\nFundamental base:\n- A process exists in one of the following states: $RUNNING$, $STOPPED$, $ZOMBIE$, or $REAPED$. For the purpose of observability in this simulation, orphaned running or stopped states are denoted $ORPHAN\\_RUNNING$ and $ORPHAN\\_STOPPED$.\n- The process lifecycle semantics are:\n  1. Child creation via a fork-like event yields a parent-child relationship and both processes are in $RUNNING$.\n  2. A child that sends `SIGSTOP` to itself transitions from $RUNNING$ to $STOPPED$.\n  3. A $STOPPED$ child can transition back to $RUNNING$ only upon receiving a `SIGCONT` from an authorized process. Authorization is granted to the living parent or any same-$UID$ process.\n  4. If the parent exits while the child is still alive, the child becomes orphaned and is reparented to a system process that reaps terminated children.\n  5. If a child terminates while its parent is alive and the parent does not perform a wait-like action to reap it, the child becomes $ZOMBIE$. If the parent performs a wait-like action, the child becomes $REAPED$ immediately. If the parent has already exited, the orphan is reaped by the system process, so sustained zombie risk is eliminated.\n\nYour program must implement the following logical model:\n- Start with a parent process $P$ and a child process $C$. Both begin in $RUNNING$.\n- Immediately after creation, the child $C$ sends `SIGSTOP` to itself, transitioning $C$ from $RUNNING$ to $STOPPED$.\n- The following events are parameterized per test case, each a boolean value in $\\{0,1\\}$:\n  - $c\\_p$: whether the parent $P$ attempts to send `SIGCONT` to $C$ while $P$ is alive.\n  - $e\\_p$: whether the parent $P$ exits before any successful resume of $C$ by $P$.\n  - $c\\_s$: whether a same-$UID$ third-party process attempts to send `SIGCONT` to $C$.\n  - $c\\_d$: whether a different-$UID$ third-party process attempts to send `SIGCONT` to $C$.\n  - $w\\_p$: whether the parent $P$ performs a wait-like action after $C$ terminates, provided $P$ is alive at that time.\n- A resume attempt succeeds only if issued by an authorized and alive process at the time of the attempt. If $e\\_p = 1$, then the parent $P$ cannot perform `SIGCONT` or a wait-like action afterwards.\n\nTermination and zombie-orphan semantics:\n- If $C$ is $RUNNING$, it can eventually terminate. Upon $C$ termination:\n  - If $P$ is alive and $w\\_p = 1$, $C$ transitions to $REAPED$.\n  - If $P$ is alive and $w\\_p = 0$, $C$ transitions to $ZOMBIE$.\n  - If $P$ has exited ($e\\_p = 1$), $C$ is an orphan and will be reaped by the system process, transitioning to $REAPED$ without sustained zombie risk.\n- If $C$ remains $STOPPED$ because no authorized resume succeeded, and $P$ exits, $C$ transitions to $ORPHAN\\_STOPPED$ and cannot terminate within this model without external actions not represented by the parameters.\n\nDefine the output encoding:\n- State codes: $0 \\rightarrow RUNNING$, $1 \\rightarrow STOPPED$, $2 \\rightarrow ORPHAN\\_STOPPED$, $3 \\rightarrow ORPHAN\\_RUNNING$, $4 \\rightarrow ZOMBIE$, $5 \\rightarrow REAPED$.\n- For each test case, your program must output three values in order: the final child state code, the resume success indicator, and the zombie risk indicator. The resume success indicator is $1$ if any authorized resume succeeded, else $0$. The zombie risk indicator is $1$ if $C$ enters $ZOMBIE$ due to $P$ not performing a wait-like action while alive; otherwise $0$.\n\nTest suite:\n- Test case $1$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (1, 0, 0, 0, 1)$.\n- Test case $2$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (0, 1, 1, 0, 0)$.\n- Test case $3$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (0, 1, 0, 1, 0)$.\n- Test case $4$: $(c\\_p, e\\_p, c\\_s, c\\_d, w\\_p) = (1, 0, 0, 0, 0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be the concatenation of the triples for the above test cases in order, namely $[state\\_1,resumed\\_1,zombie\\_1,state\\_2,resumed\\_2,zombie\\_2,state\\_3,resumed\\_3,zombie\\_3,state\\_4,resumed\\_4,zombie\\_4]$, where each $state\\_i$ is the final child state code and each $resumed\\_i$ and $zombie\\_i$ is a boolean in $\\{0,1\\}$.", "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of operating system process management, is well-posed with a clear and complete set of rules, and is expressed in objective, formalizable language. There are no contradictions, ambiguities, or factual errors. A unique solution can be determined by logical application of the provided rules.\n\nThe problem requires the simulation of a child process's lifecycle based on a set of parameters governing its interaction with a parent process and other processes. The final state of the child process $C$, along with indicators for resume success and zombie risk, must be determined for four distinct test cases. The states are encoded as follows: $RUNNING \\rightarrow 0$, $STOPPED \\rightarrow 1$, $ORPHAN\\_STOPPED \\rightarrow 2$, $ORPHAN\\_RUNNING \\rightarrow 3$, $ZOMBIE \\rightarrow 4$, $REAPED \\rightarrow 5$.\n\nThe initial state of the child process $C$ is $STOPPED$ (code $1$), as it sends a `SIGSTOP` signal to itself immediately after creation. The evolution from this state depends on whether a successful resume signal (`SIGCONT`) is received.\n\nThe core of the logic lies in a two-stage analysis: first, determining if the child process is resumed, and second, determining its final state based on the outcome of the resume attempt and the subsequent actions of the parent process $P$.\n\n**Stage 1: Resume Success Analysis**\n\nA resume attempt is successful if it originates from an authorized process. According to the problem specification, authorization is granted to:\n1. The parent process $P$, provided it is alive at the time of the signal. The parameter $e_p=1$ indicates the parent exits early, precluding it from sending signals. Thus, a parent's resume attempt ($c_p=1$) is successful only if $e_p=0$.\n2. Any third-party process with the same User Identifier ($UID$) as the child process. This is represented by the parameter $c_s=1$.\n3. An attempt from a different-$UID$ process ($c_d=1$) is never authorized.\n\nLet $R_s$ be a boolean indicator for resume success ($1$ for success, $0$ for failure). The condition for success is derived from the logical OR of the authorized attempts:\n$$R_s = (c_p \\land \\neg e_p) \\lor c_s$$\nwhere the parameters are interpreted as boolean values ($1$ is true, $0$ is false).\n\n**Stage 2: Final State Determination**\n\nThe final state of child $C$ depends on $R_s$ and the parameters governing parent liveness ($e_p$) and reaping behavior ($w_p$).\n\n*   **If Resume Fails ($R_s = 0$):**\n    The child process $C$ is never resumed and remains in a stopped state. Its final state is contingent on the parent's liveness:\n    *   If the parent remains alive ($e_p=0$), the child's state is $STOPPED$ (code $1$).\n    *   If the parent exits ($e_p=1$), the child becomes an orphan while stopped, and its state is $ORPHAN\\_STOPPED$ (code $2$). In this model, this is a terminal state.\n\n*   **If Resume Succeeds ($R_s = 1$):**\n    The child process $C$ transitions to $RUNNING$ and will eventually terminate. Its final state after termination depends on whether it is reaped and by whom.\n    *   If the parent remains alive ($e_p=0$): The child terminates while the parent is available to reap it.\n        *   If the parent performs a wait-like action ($w_p=1$), the child is properly reaped and its final state is $REAPED$ (code $5$). The zombie risk is $0$.\n        *   If the parent does not wait ($w_p=0$), the child enters a $ZOMBIE$ state (code $4$). This is the sole condition under which zombie risk exists, so the zombie risk indicator is $1$.\n    *   If the parent exits ($e_p=1$): The running child becomes an orphan. Its state is momentarily $ORPHAN\\_RUNNING$ (code $3$). Upon termination, it is automatically reaped by the designated system process. Its final state is $REAPED$ (code $5$), and there is no sustained zombie risk.\n\nWe now apply this formal logic to each test case.\n\n**Test Case 1: $(c_p, e_p, c_s, c_d, w_p) = (1, 0, 0, 0, 1)$**\n1.  **Resume Success ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$. Resume succeeds.\n2.  **Final State:** Since $R_s=1$ and the parent is alive ($e_p=0$), the child enters $RUNNING$ and terminates. The parent performs a wait action ($w_p=1$). The child is reaped.\n    *   Final State Code: $5$ ($REAPED$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(5, 1, 0)$\n\n**Test Case 2: $(c_p, e_p, c_s, c_d, w_p) = (0, 1, 1, 0, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 1 = 0 \\lor 1 = 1$. Resume succeeds (from same-$UID$ process).\n2.  **Final State:** Since $R_s=1$ and the parent exits ($e_p=1$), the child becomes an orphan while running ($ORPHAN\\_RUNNING$). Upon termination, it is reaped by the system.\n    *   Final State Code: $5$ ($REAPED$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(5, 1, 0)$\n\n**Test Case 3: $(c_p, e_p, c_s, c_d, w_p) = (0, 1, 0, 1, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 0 = 0 \\lor 0 = 0$. Resume fails. Note that the attempt from a different-$UID$ process ($c_d=1$) is unauthorized and has no effect.\n2.  **Final State:** Since $R_s=0$ and the parent exits ($e_p=1$), the stopped child becomes an orphan.\n    *   Final State Code: $2$ ($ORPHAN\\_STOPPED$)\n    *   Resume Success Indicator: $0$\n    *   Zombie Risk Indicator: $0$\n    *   Result: $(2, 0, 0)$\n\n**Test Case 4: $(c_p, e_p, c_s, c_d, w_p) = (1, 0, 0, 0, 0)$**\n1.  **Resume Success ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$. Resume succeeds.\n2.  **Final State:** Since $R_s=1$ and the parent is alive ($e_p=0$), the child enters $RUNNING$ and terminates. The parent does not perform a wait action ($w_p=0$). The child becomes a zombie.\n    *   Final State Code: $4$ ($ZOMBIE$)\n    *   Resume Success Indicator: $1$\n    *   Zombie Risk Indicator: $1$\n    *   Result: $(4, 1, 1)$\n\nThe concatenated list of results for the four test cases is $[5,1,0,5,1,0,2,0,0,4,1,1]$. The following C program implements this logic to generate the required output.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// State codes as defined in the problem\n#define STATE_RUNNING 0\n#define STATE_STOPPED 1\n#define STATE_ORPHAN_STOPPED 2\n#define STATE_ORPHAN_RUNNING 3\n#define STATE_ZOMBIE 4\n#define STATE_REAPED 5\n\n// A struct to hold the boolean parameters for a single test case.\n// We use int (0 or 1) as C23 standard's stdbool.h is not in the allowed list.\ntypedef struct {\n    int c_p; // Parent attempts to send SIGCONT\n    int e_p; // Parent exits early\n    int c_s; // Same-UID process attempts to send SIGCONT\n    int c_d; // Different-UID process attempts to send SIGCONT\n    int w_p; // Parent performs a wait-like action\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {1, 0, 0, 0, 1}, // Test case 1\n        {0, 1, 1, 0, 0}, // Test case 2\n        {0, 1, 0, 1, 0}, // Test case 3\n        {1, 0, 0, 0, 0}  // Test case 4\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    // Each case produces 3 integer results: state, resumed, zombie_risk\n    int results[num_cases * 3];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase current_case = test_cases[i];\n        int final_child_state;\n        int resume_success = 0;\n        int zombie_risk = 0;\n\n        // Stage 1: Determine resume success.\n        // A resume is successful if attempted by the parent (c_p=1) while it's alive (e_p=0),\n        // or if attempted by a same-UID process (c_s=1).\n        if ((current_case.c_p && !current_case.e_p) || current_case.c_s) {\n            resume_success = 1;\n        }\n\n        // Stage 2: Determine final state based on resume success and parent actions.\n        if (resume_success) {\n            // Child is resumed and will eventually terminate.\n            if (!current_case.e_p) { // Parent is alive.\n                // Parent is responsible for reaping.\n                if (current_case.w_p) {\n                    // Parent waits, child is reaped.\n                    final_child_state = STATE_REAPED;\n                } else {\n                    // Parent does not wait, child becomes a zombie.\n                    final_child_state = STATE_ZOMBIE;\n                    zombie_risk = 1;\n                }\n            } else { // Parent has exited, child is an orphan.\n                // Running orphan is reaped by the system upon termination.\n                final_child_state = STATE_REAPED;\n            }\n        } else {\n            // Resume failed, child remains stopped.\n            if (!current_case.e_p) { // Parent is alive.\n                final_child_state = STATE_STOPPED;\n            } else { // Parent has exited.\n                // Stopped child becomes an orphan.\n                final_child_state = STATE_ORPHAN_STOPPED;\n            }\n        }\n\n        results[i * 3 + 0] = final_child_state;\n        results[i * 3 + 1] = resume_success;\n        results[i * 3 + 2] = zombie_risk;\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases * 3; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases * 3 - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3672144"}, {"introduction": "Knowing what a zombie process is and how to prevent one are two different things. This practice moves from theory to design, presenting a common yet challenging scenario: launching a new program via `fork` and `execve` without leaving behind an unreaped child process. You will analyze several proposed handshake protocols to identify the one that correctly uses pipes, file descriptors, and system call ordering to guarantee a zombie-free execution, a crucial skill for writing robust, production-quality system software. [@problem_id:3672175]", "problem": "You are designing a robust parent–child handshake on a Portable Operating System Interface (POSIX) system to spawn a child process that will replace its image with a target program via `execve`, and you want to guarantee that no zombie processes are ever created. A zombie process is a process that has terminated but still has an entry in the Process Control Block (PCB) because its parent has not yet collected its termination status via `wait` or `waitpid`. You will use only pipes and ordering of `close`, `exec`, and `wait` calls, and you must consider edge cases such as `exec` failure, early child exit, and the parent performing `exec` soon after spawning. Assume the following well-tested facts and definitions as your fundamental base:\n\n- After a successful `fork`, the child inherits the parent's open File Descriptors (FDs), including both ends of any pipe the parent created, and the kernel maintains reference counts for each end.\n- A pipe read returns $0$ (end-of-file) only when all write ends referring to the pipe are closed across all processes. A read blocks when at least one write end remains open and no data is available.\n- `execve` replaces the calling process's image and FDs are preserved unless they have the Close-On-Exec (FD\\_CLOEXEC) flag set, in which case they are closed atomically during `execve`.\n- A child becomes a zombie if it terminates and its parent does not call `wait` or `waitpid` to reap it; if the parent itself terminates, the child is adopted by the system reaper (for example, process $1$ on some systems), preventing zombies for that lineage.\n- `waitpid` can be called after any blocking read completes; correct ordering matters to avoid races that could leave the child unreaped.\n\nYou will choose one design below that uses pipes to ensure the parent never leaves a child as a zombie, even if the parent intends to call `exec` soon after spawning the child. Consider the following candidate handshakes, which differ in their ordering of `close`, `exec`, and `wait`. In each, $P_{c2p}$ denotes a child-to-parent status pipe and $P_{p2c}$ a parent-to-child readiness pipe. For clarity, $r$ and $w$ denote the read and write ends, respectively.\n\nA. Parent creates two pipes $P_{c2p}$ and $P_{p2c}$. The parent sets FD\\_CLOEXEC on $P_{c2p}(w)$ and leaves $P_{c2p}(r)$ without FD\\_CLOEXEC. After `fork`:\n- Child closes $P_{c2p}(r)$ and $P_{p2c}(w)$, then performs a blocking read of $1$ byte from $P_{p2c}(r)$ to ensure the parent is ready to reap. Upon receiving the byte, the child attempts `execve`. If `execve` succeeds, FD\\_CLOEXEC closes $P_{c2p}(w)$ atomically and the child proceeds in the new image. If `execve` fails, the child writes a small error code to $P_{c2p}(w)$ and calls `_exit`.\n- Parent closes $P_{c2p}(w)$ and $P_{p2c}(r)$ immediately, writes $1$ byte to $P_{p2c}(w)$ to release the child, then reads from $P_{c2p}(r)$. If the read returns $0$, the parent infers `execve` success and calls `waitpid` to reap later when the child eventually terminates. If the read returns an error code, the parent calls `waitpid` to reap immediately and handles the failure. Only after performing `waitpid` does the parent proceed to its own `exec` or other actions. This ordering ensures that all write ends of $P_{c2p}$ are closed in the success path (producing $0$), and that the parent reaps in both success and failure paths, preventing zombies. Edge cases: if the child exits early before reading $P_{p2c}(r)$, the parent’s read of $P_{c2p}(r)$ will deliver the error code or $0$, and `waitpid` will still reap. If FD\\_CLOEXEC were not set on $P_{c2p}(w)$, the parent’s read could block forever due to the new image keeping the write end open; setting FD\\_CLOEXEC avoids this.\n\nB. Parent creates a single pipe $P_{c2p}$ but does not set FD\\_CLOEXEC on either end. After `fork`:\n- Child closes $P_{c2p}(r)$ and attempts `execve`. On failure, it writes an error code and exits; on success, the new image inherits $P_{c2p}(w)$ and keeps it open indefinitely.\n- Parent closes nothing and reads from $P_{c2p}(r)$. It interprets any $0$ as success and nonzero bytes as failure, then immediately calls `exec` without calling `waitpid`.\nThis design can deadlock or mis-signal: the parent’s read may never return $0$ because $P_{c2p}(w)$ remains open in the child’s new image, and the parent never calls `waitpid`, risking a zombie if the child exits after the parent’s `exec`.\n\nC. Parent sets the Signal (SIGCHLD) disposition to ignore and uses no pipes. After `fork`:\n- Child attempts `execve` and exits when done.\n- Parent immediately calls `exec` without calling `waitpid`, assuming `SIGCHLD` ignore guarantees auto-reap on all POSIX systems.\nThis relies on non-portable behavior; ignoring `SIGCHLD` does not universally guarantee automatic reaping across all POSIX implementations and fails to use the specified pipe-based handshake. It therefore risks zombies on systems where auto-reap is not performed.\n\nD. Parent implements a double `fork` in the child to orphan the grandchild, uses no pipes, and never calls `waitpid`. The intermediate child exits, causing the grandchild to be reparented to the system reaper (for example, process $1$), which will reap it eventually.\nWhile double `fork` can avoid zombies, it ignores the requirement to use pipes for a handshake and does not cover `exec` failure signaling to the parent; additionally, it complicates resource management and lineage tracking.\n\nWhich option correctly uses pipes and ordering of `close`, `exec`, and `wait` calls to ensure no zombie creation and handles the stated edge cases under the given assumptions?\n\nA. The two-pipe handshake with FD\\_CLOEXEC on $P_{c2p}(w)$, parent closing its write ends, releasing the child via $P_{p2c}$, reading status, and calling `waitpid` before any parent `exec`.\n\nB. The single-pipe approach without FD\\_CLOEXEC, parent not closing its write end and calling `exec` without `waitpid`.\n\nC. Ignoring `SIGCHLD` and not using pipes, relying on auto-reap.\n\nD. Double `fork` without pipes and never calling `waitpid`.", "solution": "The user-provided problem is analyzed as follows.\n\n### Step 1: Extract Givens\n- **Objective**: Design a robust parent–child handshake on a POSIX system to spawn a child, have it call `execve`, and guarantee no zombie processes are created.\n- **Zombie Definition**: A process that has terminated but its Process Control Block (PCB) entry persists because its parent has not collected its status via `wait` or `waitpid`.\n- **Constraints**: Use only pipes and the ordering of `close`, `exec`, and `wait` calls.\n- **Edge Cases**: Must handle `exec` failure, early child exit, and the parent performing `exec` soon after spawning.\n- **Fundamental Facts**:\n    1.  After `fork`, the child inherits parent's open File Descriptors (FDs), and the kernel reference-counts each pipe end.\n    2.  A pipe read returns `$0$` (end-of-file) only when all write ends are closed. A read blocks if a write end is open and no data is available.\n    3.  `execve` preserves FDs unless the `FD_CLOEXEC` (Close-On-Exec) flag is set, which closes them atomically.\n    4.  A child becomes a zombie if its live parent does not `wait`. If the parent terminates, an adopted child is reaped by the system reaper (e.g., process `$1$`).\n    5.  `waitpid` can be called after a blocking read; ordering is critical to avoid race conditions.\n- **Notation**: `$P_{c2p}$` (child-to-parent pipe), `$P_{p2c}$` (parent-to-child pipe), `$r$` (read end), `$w$` (write end).\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically evaluated for validity.\n\n- **Scientifically Grounded**: The problem is firmly rooted in the established principles of process management in POSIX-compliant operating systems. The descriptions of `fork`, `execve`, `waitpid`, pipes, file descriptors, `FD_CLOEXEC`, and zombie processes are accurate and reflect standard systems programming concepts.\n- **Well-Posed**: The problem is well-posed. It presents a clear objective (preventing zombies during an `exec` handshake), defines the constraints and available tools, and asks for the evaluation of specific proposed solutions. A unique correct design exists among the choices based on the provided axioms.\n- **Objective**: The language is technical, precise, and free of subjective or ambiguous terminology. The criteria for a successful solution are clearly defined and verifiable.\n- **Completeness and Consistency**: The problem provides all necessary definitions and assumptions to reason about the correct solution. There are no internal contradictions. The provided \"fundamental facts\" form a self-contained logical basis for the analysis.\n- **Relevance**: The problem is directly and fundamentally relevant to the topic of process lifecycle and control structures in an introduction to operating systems.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a standard, albeit intricate, problem in systems programming that tests the understanding of process control and inter-process communication primitives. The solution process may now proceed.\n\n### Principle-Based Derivation\n\nThe central challenge is to design a mechanism that simultaneously accomplishes two tasks under the specified constraints:\n1.  **Status Reporting**: The parent must be able to reliably determine whether the child's call to `execve` succeeded or failed.\n2.  **Zombie Prevention**: The child process, upon termination, must be successfully reaped by its parent via `wait` or `waitpid` to prevent it from becoming a zombie. This must hold even if the parent process itself calls `execve` after the handshake.\n\n**Status Reporting Mechanism**:\nA pipe from child to parent (`$P_{c2p}$`) is the designated tool. Failure can be signaled by the child writing an error code to the pipe before exiting. Success is more subtle, as the new process image loaded by `execve` has no knowledge of the handshake and will not write a \"success\" code. The correct way to signal success is through an implicit action: the closing of the pipe's write end.\n\nLet the parent hold the read end `$P_{c2p}(r)$` and the child hold the write end `$P_{c2p}(w)$`. After the `fork`, both processes initially have both FDs. For the communication to work, the parent must close its copy of `$P_{c2p}(w)$`, and the child must close its copy of `$P_{c2p}(r)$`. Now, the parent can perform a blocking `read()` on `$P_{c2p}(r)`.\n- If `execve` fails, the child `write()`s an error code to `$P_{c2p}(w)`. The parent's `read()` receives this data.\n- If `execve` succeeds, the program must ensure `$P_{c2p}(w)` is closed. If it remains open in the newly loaded process, the parent's `read()` will block indefinitely. The `FD_CLOEXEC` flag is essential here. By setting `FD_CLOEXEC` on `$P_{c2p}(w)` before the `fork`, a successful `execve` in the child will atomically close this file descriptor. Since the parent already closed its copy of `$P_{c2p}(w)`, this action closes the last remaining write handle, causing the parent's `read()` to unblock and return `$0$` (EOF), reliably signaling success.\n\n**Zombie Prevention Mechanism**:\nA child becomes a zombie if its parent is alive but fails to call `waitpid`. The problem states the parent might call `execve` itself. A common misconception is that this terminates the parent. It does not; it replaces the parent's process image. The parent process, with its original Process ID, continues to exist and remains the parent of the child. However, the new program loaded by `execve` will be unaware of the child and will not have the logic to call `waitpid`. Consequently, when the child eventually terminates, its parent (running the new program) will not reap it, and it will become a zombie.\n\nTo absolutely *guarantee* that no zombie is created, the original parent code must reap the child *before* it relinquishes control by calling `execve`. This means that after the parent has determined the child's `execve` status, it must call `waitpid(child\\_pid, ...)` and wait for it to complete. If the child's `execve` was successful, this implies the parent process will block until the child's entire lifecycle is complete. This creates a synchronous spawn, which may not be desirable in all cases, but it is the only way to satisfy the strict \"guarantee no zombie\" requirement under the specified constraints.\n\n### Option-by-Option Analysis\n\n**A. The two-pipe handshake with FD\\_CLOEXEC on `$P_{c2p}(w)$`, parent closing its write ends, releasing the child via `$P_{p2c}$`, reading status, and calling `waitpid` before any parent `exec`.**\n\nThis option describes a meticulous and correct implementation based on the principles derived above.\n- **Pipes**: It uses two pipes. The child-to-parent pipe (`$P_{c2p}$`) is used for status reporting as described. The parent-to-child pipe (`$P_{p2c}$`) serves as a synchronization barrier, ensuring the child does not call `execve` until the parent is fully prepared to listen for the status signal, thus preventing a race condition.\n- **`FD_CLOEXEC`**: It correctly specifies that `$P_{c2p}(w)` must have the `FD_CLOEXEC` flag set. This is the cornerstone of signaling `execve` success via EOF on the pipe.\n- **`close()` ordering**: It correctly outlines that each process closes the pipe end it does not use.\n- **Reaping**: Crucially, it states that *after* resolving the handshake (reading `$0$` or an error code from `$P_{c2p}(r)$`), the parent calls `waitpid`. In the case of `execve` failure, the child has already exited, so `waitpid` returns immediately. In the case of `execve` success, the parent blocks until the child terminates. Only after the child is reaped does the parent proceed to its own tasks, such as calling `exec`. This sequence correctly and completely prevents the creation of a zombie, satisfying all problem constraints.\n\nVerdict: **Correct**.\n\n**B. The single-pipe approach without FD\\_CLOEXEC, parent not closing its write end and calling `exec` without `waitpid`.**\n\nThis option is fundamentally flawed.\n- **No `FD_CLOEXEC`**: Without `FD_CLOEXEC`, a successful `execve` in the child will cause the new process image to inherit the write end of the pipe (`$P_{c2p}(w)$`). The parent's `read()` on `$P_{c2p}(r)` will block forever, as a write handle to the pipe remains open, but no data is being written. This leads to a deadlock.\n- **No Parent `close()`**: The parent fails to close its own copy of `$P_{c2p}(w)`. This is an additional, independent reason for the parent's `read()` to deadlock.\n- **No `waitpid`**: The parent calls `exec` without calling `waitpid`. As explained in the derivation, this guarantees a zombie process if the child terminates while the parent is still running its new image.\n\nVerdict: **Incorrect**.\n\n**C. Ignoring SIGCHLD and not using pipes, relying on auto-reap.**\n\nThis option violates the problem's explicit constraints and is not a universally robust solution.\n- **Violates Constraints**: The problem mandates the use of \"only pipes and ordering of `close`, `exec`, and `wait` calls\". This solution uses signals (`SIGCHLD`) and explicitly avoids pipes.\n- **Non-Portable**: The behavior that setting the disposition of `SIGCHLD` to `SIG_IGN` causes automatic reaping of child processes is a common extension (e.g., on Linux and BSD), but it is not specified by the POSIX standard. A robust design for a POSIX system cannot rely on this behavior.\n- **No Status Reporting**: This mechanism provides no way for the parent to know if the child's `execve` call failed.\n\nVerdict: **Incorrect**.\n\n**D. Double `fork` without pipes and never calling `waitpid`.**\n\nThis option describes a valid general pattern for daemonization but fails to meet the specific requirements of this problem.\n- **Violates Constraints**: The problem requires a pipe-based handshake. This solution uses no pipes for communication between the original parent and the process that will eventually call `execve`.\n- **No Status Reporting**: The original parent process reaps the intermediate child, which exits almost immediately. The parent has no communication channel to the grandchild (the actual worker process) and therefore cannot be notified if the grandchild's `execve` call fails.\n\nVerdict: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3672175"}, {"introduction": "What is the system-level cost of poor process management? This problem shifts our focus from controlling a single process to analyzing the collective impact of many. By modeling the creation of zombie processes as an arrival process and their reaping as a service process, you can apply the powerful tools of queueing theory. This exercise demonstrates how to quantitatively predict the steady-state resource consumption—in this case, kernel memory occupied by zombie Process Control Blocks (PCBs)—when the rate of child termination, $\\lambda$, approaches the rate of reaping, $\\mu$. [@problem_id:3672140]", "problem": "A single long-lived parent process creates child processes that eventually terminate. On termination, each child enters the zombie state, retaining only its Process Control Block (PCB) in kernel memory until the parent reaps it with a `wait`-family system call. Assume the following model.\n\n- Child terminations that create zombies arrive according to a Poisson process with rate $ \\lambda $ arrivals per second, independently of the parent’s actions.\n- The parent issues `wait` calls according to a Poisson process with rate $ \\mu $ calls per second, independently of zombie arrivals. Each `wait` call reaps exactly one zombie if at least one exists; if none exists, the call returns immediately without reaping.\n- Thus, the number of zombies $Z(t)$ evolves as a continuous-time birth–death process on the nonnegative integers, with birth rate $ \\lambda $ in every state and death rate $ \\mu $ in states with $ n \\ge 1 $ zombies (and death rate $ 0 $ in state $ 0 $).\n\nStarting from the fundamental definition of steady-state global balance for a countable-state continuous-time Markov chain, derive an expression for the steady-state expected number of zombies $ \\mathbb{E}[Z] $ in terms of $ \\lambda $ and $ \\mu $, under the condition that a stationary distribution exists. Then, given $ \\lambda = 1.5 $ and $ \\mu = 2.0 $ (both in units of per second), and that each zombie’s Process Control Block (PCB) occupies $ 4 $ KiB of kernel memory, compute the expected kernel memory occupied by zombie PCBs in steady state. Express your final answer in KiB. Do not round.", "solution": "The problem is first assessed for validity.\n\n### Step 1: Extract Givens\n- Child terminations (zombie creations) occur as a Poisson process with rate $\\lambda$ arrivals per second.\n- Parent `wait` calls occur as a Poisson process with rate $\\mu$ calls per second.\n- A `wait` call reaps one zombie if $Z \\ge 1$; it has no effect if $Z=0$.\n- The number of zombies, $Z(t)$, is a continuous-time birth-death process.\n- The birth rate in any state $n \\ge 0$ is $\\lambda_n = \\lambda$.\n- The death rate in state $n \\ge 1$ is $\\mu_n = \\mu$. The death rate in state $0$ is $\\mu_0 = 0$.\n- A stationary distribution is assumed to exist.\n- An expression for the steady-state expected number of zombies, $\\mathbb{E}[Z]$, is required.\n- Given values: $\\lambda = 1.5 \\text{ s}^{-1}$, $\\mu = 2.0 \\text{ s}^{-1}$.\n- Memory occupied by one Process Control Block (PCB) is $4$ KiB.\n- The goal is to compute the expected total kernel memory occupied by zombie PCBs in steady state.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem models the system using a birth-death process, a standard and fundamental model in queueing theory and stochastic processes. This specific configuration corresponds to an M/M/1 queue, which is a cornerstone of performance analysis in computer science and engineering. The application to operating system processes is a valid and common pedagogical example.\n- **Well-Posed**: The problem is clearly defined. It specifies the model, asks for a derivable quantity ($\\mathbb{E}[Z]$), and provides the necessary parameters. The condition for the existence of a stationary distribution for this birth-death process is that the traffic intensity $\\rho = \\lambda/\\mu$ must be less than $1$. The given values $\\lambda = 1.5$ and $\\mu = 2.0$ yield $\\rho = 0.75$, which satisfies this condition. Thus, a unique, stable, and meaningful solution exists.\n- **Objective**: The problem is stated in precise, objective mathematical and technical terms. There is no ambiguity or subjective language.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, well-posed, objective, complete, and represents a standard, non-trivial problem in its field.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Derivation of the Expected Number of Zombies\nThe system is modeled as a continuous-time birth-death process on the state space $S = \\{0, 1, 2, \\dots\\}$, where the state $n$ represents the number of zombies. The birth rates are $\\lambda_n = \\lambda$ for all $n \\ge 0$, and the death rates are $\\mu_n = \\mu$ for all $n \\ge 1$, with $\\mu_0 = 0$.\n\nLet $\\pi_n$ be the steady-state probability of being in state $n$. The fundamental definition of steady-state global balance requires that for each state $n$, the rate of transitions into state $n$ equals the rate of transitions out of state $n$.\n\nFor state $n=0$:\nThe system leaves state $0$ only by a birth (a zombie is created), at rate $\\lambda$. The system enters state $0$ only from state $1$ via a death (a zombie is reaped), at rate $\\mu$.\n$$ \\text{Rate out} = \\text{Rate in} \\implies \\pi_0 \\lambda_0 = \\pi_1 \\mu_1 \\implies \\pi_0 \\lambda = \\pi_1 \\mu $$\nThis gives the relation $\\pi_1 = \\left(\\frac{\\lambda}{\\mu}\\right) \\pi_0$.\n\nFor any state $n \\ge 1$:\nThe system leaves state $n$ via a birth (to state $n+1$) at rate $\\lambda$ or a death (to state $n-1$) at rate $\\mu$. The total rate out is $(\\lambda + \\mu)$. The system enters state $n$ from state $n-1$ via a birth (rate $\\lambda$) or from state $n+1$ via a death (rate $\\mu$).\n$$ \\pi_n (\\lambda_n + \\mu_n) = \\pi_{n-1} \\lambda_{n-1} + \\pi_{n+1} \\mu_{n+1} \\implies \\pi_n (\\lambda + \\mu) = \\pi_{n-1} \\lambda + \\pi_{n+1} \\mu $$\nThis set of equations can be solved recursively. However, for any birth-death process, the global balance equations imply the simpler detailed balance equations, which state that flow between adjacent states must be equal in both directions:\n$$ \\pi_{n-1} \\lambda_{n-1} = \\pi_n \\mu_n \\quad \\text{for } n \\ge 1 $$\nUsing the given rates, this becomes $\\pi_{n-1}\\lambda = \\pi_n \\mu$. This gives the recurrence relation:\n$$ \\pi_n = \\left(\\frac{\\lambda}{\\mu}\\right) \\pi_{n-1} $$\nLet $\\rho = \\frac{\\lambda}{\\mu}$. Then $\\pi_n = \\rho \\pi_{n-1}$. By repeated application, we find:\n$$ \\pi_n = \\rho^n \\pi_0 $$\nTo determine $\\pi_0$, we use the normalization condition that the sum of all steady-state probabilities must equal $1$:\n$$ \\sum_{n=0}^{\\infty} \\pi_n = 1 \\implies \\sum_{n=0}^{\\infty} \\rho^n \\pi_0 = 1 \\implies \\pi_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\nThe summation is a geometric series. As stated in the problem, a stationary distribution exists, which requires the series to converge. This occurs if and only if $|\\rho| < 1$, which means $\\lambda < \\mu$. The sum is $\\sum_{n=0}^{\\infty} \\rho^n = \\frac{1}{1-\\rho}$.\nSubstituting this into the normalization equation:\n$$ \\pi_0 \\left(\\frac{1}{1-\\rho}\\right) = 1 \\implies \\pi_0 = 1 - \\rho $$\nThus, the steady-state probability distribution for the number of zombies is a geometric distribution:\n$$ \\pi_n = (1 - \\rho) \\rho^n, \\quad n = 0, 1, 2, \\dots $$\nThe expected number of zombies, $\\mathbb{E}[Z]$, is the mean of this distribution:\n$$ \\mathbb{E}[Z] = \\sum_{n=0}^{\\infty} n \\cdot \\pi_n = \\sum_{n=0}^{\\infty} n (1-\\rho)\\rho^n $$\n$$ \\mathbb{E}[Z] = (1-\\rho) \\sum_{n=1}^{\\infty} n \\rho^n $$\nTo evaluate the sum, we use the derivative of the geometric series formula:\n$$ \\sum_{n=0}^{\\infty} x^n = \\frac{1}{1-x} \\quad \\text{for } |x|<1 $$\nDifferentiating with respect to $x$:\n$$ \\frac{d}{dx} \\sum_{n=0}^{\\infty} x^n = \\sum_{n=1}^{\\infty} n x^{n-1} = \\frac{d}{dx} (1-x)^{-1} = (1-x)^{-2} $$\nMultiplying by $x$:\n$$ \\sum_{n=1}^{\\infty} n x^n = \\frac{x}{(1-x)^2} $$\nSubstituting this result back into the expression for $\\mathbb{E}[Z]$ with $x=\\rho$:\n$$ \\mathbb{E}[Z] = (1-\\rho) \\left( \\frac{\\rho}{(1-\\rho)^2} \\right) = \\frac{\\rho}{1-\\rho} $$\nExpressing this in terms of the original parameters $\\lambda$ and $\\mu$:\n$$ \\mathbb{E}[Z] = \\frac{\\lambda/\\mu}{1 - \\lambda/\\mu} = \\frac{\\lambda/\\mu}{(\\mu-\\lambda)/\\mu} = \\frac{\\lambda}{\\mu-\\lambda} $$\n\n### Calculation of Expected Memory Occupancy\nWe are given the numerical values $\\lambda = 1.5$ per second and $\\mu = 2.0$ per second.\nThe condition for stability, $\\lambda < \\mu$, is satisfied since $1.5 < 2.0$.\nWe can now calculate the expected number of zombies, $\\mathbb{E}[Z]$:\n$$ \\mathbb{E}[Z] = \\frac{\\lambda}{\\mu-\\lambda} = \\frac{1.5}{2.0 - 1.5} = \\frac{1.5}{0.5} = 3 $$\nSo, in the steady state, the expected number of zombies is $3$.\n\nEach zombie's PCB occupies $M_{PCB} = 4$ KiB of kernel memory. The total memory occupied by zombies is $M = Z \\cdot M_{PCB}$. We wish to find the expected total memory, $\\mathbb{E}[M]$. By the linearity of expectation:\n$$ \\mathbb{E}[M] = \\mathbb{E}[Z \\cdot M_{PCB}] = \\mathbb{E}[Z] \\cdot M_{PCB} $$\nSubstituting the values:\n$$ \\mathbb{E}[M] = 3 \\times 4 \\text{ KiB} = 12 \\text{ KiB} $$\nThe expected kernel memory occupied by zombie PCBs in a steady state is $12$ KiB.", "answer": "$$\\boxed{12}$$", "id": "3672140"}]}