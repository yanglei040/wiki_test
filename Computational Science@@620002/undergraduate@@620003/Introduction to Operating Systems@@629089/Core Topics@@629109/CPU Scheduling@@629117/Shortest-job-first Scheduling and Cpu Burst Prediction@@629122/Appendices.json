{"hands_on_practices": [{"introduction": "Before diving into complex simulations, it's essential to grasp an algorithm's fundamental behavior under ideal conditions. This theoretical exercise challenges you to analyze non-preemptive Shortest-Job-First (SJF) scheduling in a perfect world where CPU burst times are known in advance. By deriving the maximum waiting time, you will uncover an important trade-off inherent in SJF: while it is optimal for average waiting time, it can lead to significant delays for longer jobs.[@problem_id:3682864]", "problem": "Consider $n$ independent jobs $J_1, J_2, \\dots, J_n$ that arrive simultaneously at time $0$ and each consists of a single Central Processing Unit (CPU) burst. Let the true CPU burst lengths be $b_1, b_2, \\dots, b_n$ with $b_1 < b_2 < \\dots < b_n$. A non-preemptive Shortest-Job-First (SJF) scheduler is used, and the scheduler’s CPU burst predictions are perfect, meaning the predicted burst for each $J_i$ equals its true burst $b_i$. Assume there is no context-switch overhead and no input/output blocking; once a job begins its CPU burst, it runs to completion.\n\nStarting only from the core definitions of waiting time and the non-preemptive SJF selection rule, derive a closed-form analytic expression for the maximum waiting time experienced by any job among $J_1, \\dots, J_n$ in this scenario. The waiting time $W_i$ for job $J_i$ is defined as the time elapsed from its arrival until the instant it first begins execution on the CPU. Express your final answer symbolically in terms of $b_1, \\dots, b_n$ using sigma notation where appropriate, and do not include units in your expression.", "solution": "The problem will first be validated for scientific soundness, self-consistency, and clarity before a solution is attempted.\n\n### Step 1: Extract Givens\nThe problem statement provides the following information:\n- A set of $n$ independent jobs, $J_1, J_2, \\dots, J_n$.\n- All jobs arrive simultaneously at time $0$.\n- Each job consists of a single CPU burst.\n- The true CPU burst lengths are $b_1, b_2, \\dots, b_n$.\n- The burst lengths are strictly ordered: $b_1 < b_2 < \\dots < b_n$.\n- The scheduling algorithm is non-preemptive Shortest-Job-First (SJF).\n- The scheduler's predictions are perfect, meaning the predicted burst for job $J_i$ is its true burst, $b_i$.\n- There is no context-switch overhead.\n- There is no input/output blocking.\n- The waiting time $W_i$ for job $J_i$ is defined as the time from its arrival until it begins execution.\n- The objective is to derive a closed-form analytic expression for the maximum waiting time among all jobs.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the established criteria:\n- **Scientifically Grounded**: The problem is a classic theoretical exercise in the study of CPU scheduling algorithms within the field of operating systems. Shortest-Job-First scheduling, waiting time, and CPU bursts are all fundamental, well-established concepts. The simplifying assumptions (simultaneous arrival, no overhead) are standard for isolating and analyzing the core behavior of the algorithm.\n- **Well-Posed**: The problem is clearly defined. The strict inequality $b_1 < b_2 < \\dots < b_n$ eliminates any ambiguity in job selection, as there are no ties in burst length. The non-preemptive nature and perfect prediction ensure a deterministic and unique execution sequence. Therefore, a unique, stable, and meaningful solution exists.\n- **Objective**: The problem is stated using precise, unambiguous terminology standard to computer science. All parameters and definitions are objective.\n\nThe problem does not exhibit any of the flaws listed in the validation criteria (e.g., scientific unsoundness, incompleteness, ambiguity). It is a well-structured question rooted in established computer science theory.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\n### Derivation of the Solution\nThe objective is to find the maximum waiting time, $\\max\\{W_1, W_2, \\dots, W_n\\}$. We begin by analyzing the execution order of the jobs under the non-preemptive Shortest-Job-First (SJF) scheduling policy.\n\n1.  **Execution Order**:\n    - At time $t=0$, all $n$ jobs ($J_1, \\dots, J_n$) are in the ready queue.\n    - The SJF scheduler selects the job with the shortest predicted CPU burst. Since predictions are perfect, it selects the job with the smallest true burst length, $b_i$.\n    - From the given condition $b_1 < b_2 < \\dots < b_n$, the job with the absolute shortest burst length is $J_1$.\n    - Therefore, at time $t=0$, job $J_1$ is selected for execution.\n    - Because the scheduling is non-preemptive, $J_1$ runs to completion. It starts at time $0$ and finishes at time $b_1$.\n    - At time $t=b_1$, job $J_1$ is complete. The remaining jobs are $J_2, J_3, \\dots, J_n$.\n    - The scheduler again applies the SJF rule. Among the remaining jobs, $J_2$ has the shortest burst length, $b_2$.\n    - Therefore, job $J_2$ is selected next. It starts at time $b_1$ and runs to completion, finishing at time $b_1 + b_2$.\n    - This process continues sequentially. After jobs $J_1, \\dots, J_{k-1}$ have completed, the scheduler will select job $J_k$ as it has the shortest burst length among the remaining jobs.\n    - The resulting execution order is deterministically $J_1, J_2, J_3, \\dots, J_n$.\n\n2.  **Waiting Time for an Arbitrary Job $J_k$**:\n    - The waiting time for job $J_k$, denoted $W_k$, is the time elapsed from its arrival until its execution begins.\n    - All jobs arrive at time $0$. The waiting time is therefore equal to the job's start time.\n    - Job $J_1$ starts at time $0$. Its waiting time is $W_1 = 0$.\n    - Job $J_2$ starts after $J_1$ completes. Its start time is $b_1$. Its waiting time is $W_2 = b_1$.\n    - Job $J_3$ starts after $J_1$ and $J_2$ complete. Its start time is $b_1 + b_2$. Its waiting time is $W_3 = b_1 + b_2$.\n    - Generalizing, job $J_k$ starts after jobs $J_1, J_2, \\dots, J_{k-1}$ have all completed. The start time of $J_k$ is the sum of the burst times of these preceding jobs.\n    - The waiting time for job $J_k$ is given by:\n    $$W_k = \\sum_{i=1}^{k-1} b_i$$\n    This formula is valid for $k \\ge 2$. For $k=1$, the sum is over an empty set, which is correctly defined as $0$, so $W_1 = 0$.\n\n3.  **Maximum Waiting Time**:\n    - We need to find the maximum value in the set of waiting times $\\{W_1, W_2, \\dots, W_n\\}$.\n    - The waiting times form a sequence:\n        - $W_1 = 0$\n        - $W_2 = b_1$\n        - $W_3 = b_1 + b_2$\n        - ...\n        - $W_n = b_1 + b_2 + \\dots + b_{n-1}$\n    - A CPU burst length $b_i$ represents a duration of time and must be positive, so $b_i > 0$ for all $i \\in \\{1, \\dots, n\\}$.\n    - Consider the difference between consecutive waiting times, for $k \\ge 2$:\n    $$W_k - W_{k-1} = \\left(\\sum_{i=1}^{k-1} b_i\\right) - \\left(\\sum_{i=1}^{k-2} b_i\\right) = b_{k-1}$$\n    - Since $b_{k-1} > 0$, it follows that $W_k > W_{k-1}$ for all $k \\ge 2$.\n    - This proves that the sequence of waiting times is strictly increasing: $W_1 < W_2 < \\dots < W_n$.\n    - The maximum value in a strictly increasing sequence is its last element.\n    - Therefore, the maximum waiting time is $W_n$.\n\n4.  **Final Expression**:\n    - The maximum waiting time is $W_n$, which is the sum of the burst lengths of all jobs that executed before $J_n$. These are jobs $J_1, \\dots, J_{n-1}$.\n    - The final closed-form expression for the maximum waiting time is:\n    $$\\max_{k \\in \\{1,\\dots,n\\}} W_k = W_n = \\sum_{i=1}^{n-1} b_i$$", "answer": "$$\\boxed{\\sum_{i=1}^{n-1} b_i}$$", "id": "3682864"}, {"introduction": "Theoretical models are powerful, but real-world schedulers must operate with uncertainty. This practice transitions you from pure theory to practical simulation, where you will build a non-preemptive SJF scheduler that predicts future CPU bursts using an Exponentially Weighted Moving Average (EWMA). Your task is not just to implement the scheduler, but to use it as a scientific tool to measure key performance metrics and empirically verify Little's Law, a cornerstone of queueing theory connecting average queue length ($\\overline{L}$), arrival rate ($\\lambda$), and waiting time ($\\overline{W}$).[@problem_id:3682783]", "problem": "Consider a single-processor system that schedules central processing unit (CPU) bursts using Shortest Job First (SJF), where job lengths are not known a priori and are predicted by Exponentially Weighted Moving Average (EWMA). Each process generates a sequence of CPU bursts interleaved with input/output that occurs off the CPU; each burst arrives at a specified time and requires a specified service time. Assume a stable, work-conserving system observed over a finite time window that begins at the earliest burst arrival and ends at the time when the last burst completes. The ready queue holds bursts that have arrived but are not currently executing.\n\nStarting from the following fundamental base:\n- Flow conservation: over a finite observation window, the total number of arrivals equals the total number of departures, and the time-average arrival rate equals the time-average departure rate.\n- Time-average definitions: the time-average number in system is the integral of the number in system over time divided by the length of the observation window, and similarly for the queue (excluding the job in service).\n\nFrom these principles, derive the relationship that must hold among the time-average number in system, the arrival rate, and the average time each job spends in the system. Also derive the analogous relationship for the ready queue alone, using the average waiting time before service begins. Do not assume any special distribution such as exponential; assume only stability, work conservation, and well-defined time averages over the finite window.\n\nImplement a simulation that:\n- Schedules bursts non-preemptively using SJF on predicted CPU burst lengths.\n- Predicts each process’s next CPU burst using EWMA. If $\\tau_n$ denotes the prediction for the $n$-th burst of a given process and $t_n$ denotes the actual length of that $n$-th burst, then the next prediction is $$\\tau_{n+1} = \\alpha\\, t_n + (1 - \\alpha)\\, \\tau_n,$$ where $0 \\le \\alpha \\le 1$ is a smoothing factor and $\\tau_0$ is the initial prediction for the process. When a process has not yet completed any burst, its predicted burst is $\\tau_0$. The scheduler, upon CPU becoming idle, selects from the ready queue the burst whose process’s current $\\tau$ is minimal; ties are broken by earliest arrival time, then by an implementation-defined deterministic rule.\n- Measures, for each burst $i$ with arrival time $a_i$ and service time $s_i$, the start time $b_i$ when its service begins, the completion time $c_i = b_i + s_i$, its time in system $w_i^{\\text{sys}} = c_i - a_i$, and its waiting time in queue $w_i^{\\text{q}} = b_i - a_i$.\n- Computes over the observation window $[A_{\\min}, C_{\\max}]$, where $A_{\\min} = \\min_i a_i$ and $C_{\\max} = \\max_i c_i$, the following metrics:\n  - The time-average number in system $$\\overline{L} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt,$$ where $L(t)$ is the number of bursts either waiting or executing at time $t$.\n  - The time-average number in queue $$\\overline{L_q} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt,$$ where $L_q(t)$ counts only bursts waiting in the ready queue at time $t$ (excluding the executing burst).\n  - The average arrival rate $$\\lambda = \\frac{N}{C_{\\max} - A_{\\min}},$$ where $N$ is the total number of bursts.\n  - The average time in system $$\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}},$$ and the average waiting time in queue $$\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}.$$\n- Verifies consistency by computing the absolute errors $$\\varepsilon_{\\text{sys}} = \\left| \\overline{L} - \\lambda\\, \\overline{W} \\right| \\quad \\text{and} \\quad \\varepsilon_{\\text{q}} = \\left| \\overline{L_q} - \\lambda\\, \\overline{W_q} \\right|.$$\n\nAll times must be handled in seconds ($\\text{s}$). Arrival rate $\\lambda$ is in inverse seconds ($\\text{s}^{-1}$). The time-average numbers $\\overline{L}$ and $\\overline{L_q}$ are dimensionless.\n\nTest Suite:\n- Test Case $1$ (happy path, moderate load):\n  - Processes: $3$ processes with identifiers $0$, $1$, $2$.\n  - Smoothing factor: $\\alpha = 0.5$.\n  - Initial prediction for each process: $\\tau_0 = 5.0\\,\\text{s}$.\n  - Bursts (arrival time $a_i$ in seconds, service time $s_i$ in seconds, process identifier):\n    - Process $0$: $[ (a=0.0, s=5.0), (a=12.0, s=4.0), (a=23.0, s=6.0) ]$.\n    - Process $1$: $[ (a=1.0, s=3.0), (a=7.0, s=2.0), (a=15.0, s=8.0) ]$.\n    - Process $2$: $[ (a=2.0, s=6.0), (a=9.0, s=7.0), (a=25.0, s=3.0) ]$.\n- Test Case $2$ (heavy overlap, high $\\alpha$):\n  - Processes: $3$ processes with identifiers $0$, $1$, $2$.\n  - Smoothing factor: $\\alpha = 0.9$.\n  - Initial prediction for each process: $\\tau_0 = 6.0\\,\\text{s}$.\n  - Bursts:\n    - Process $0$: $[ (a=0.0, s=9.0), (a=10.0, s=9.0), (a=20.0, s=9.0) ]$.\n    - Process $1$: $[ (a=0.1, s=2.0), (a=2.5, s=2.0), (a=4.9, s=2.0), (a=7.4, s=2.0), (a=9.8, s=2.0), (a=12.2, s=2.0) ]$.\n    - Process $2$: $[ (a=0.2, s=4.0), (a=4.3, s=4.5), (a=8.4, s=5.0), (a=12.5, s=5.2) ]$.\n- Test Case $3$ (boundary $\\alpha=0$, degenerate predictions):\n  - Processes: $3$ processes with identifiers $0$, $1$, $2$.\n  - Smoothing factor: $\\alpha = 0.0$.\n  - Initial prediction for each process: $\\tau_0 = 4.0\\,\\text{s}$.\n  - Bursts:\n    - Process $0$: $[ (a=0.0, s=1.0), (a=2.0, s=9.0) ]$.\n    - Process $1$: $[ (a=0.5, s=5.0) ]$.\n    - Process $2$: $[ (a=1.0, s=4.0), (a=3.0, s=3.0) ]$.\n\nFinal Output Format:\nYour program should produce a single line of output that aggregates the consistency errors for all test cases as a comma-separated list enclosed in square brackets. The six values, ordered by test case, are\n$[ \\varepsilon_{\\text{sys}}^{(1)}, \\varepsilon_{\\text{q}}^{(1)}, \\varepsilon_{\\text{sys}}^{(2)}, \\varepsilon_{\\text{q}}^{(2)}, \\varepsilon_{\\text{sys}}^{(3)}, \\varepsilon_{\\text{q}}^{(3)} ]$,\nrounded to six decimal places. For example, an output could be $[0.000000,0.000000,0.000000,0.000000,0.000000,0.000000]$ if perfect consistency is achieved within numerical precision.", "solution": "The problem requires two distinct components: first, a theoretical derivation of the relationships between time-average system population, arrival rate, and average time in system (and their queue-specific analogues); second, a discrete-event simulation to verify these relationships computationally under a specific scheduling policy.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **System Model**: Single-processor, work-conserving, stable system observed over a finite time window $[A_{\\min}, C_{\\max}]$.\n*   **Scheduling**: Non-preemptive Shortest Job First (SJF) based on predicted burst lengths.\n*   **Prediction**: Exponentially Weighted Moving Average (EWMA): $\\tau_{n+1} = \\alpha\\, t_n + (1 - \\alpha)\\, \\tau_n$, with $0 \\le \\alpha \\le 1$. $\\tau_0$ is the initial prediction.\n*   **Tie-Breaking**: For SJF, minimal $\\tau$, then earliest arrival time, then an implementation-defined deterministic rule.\n*   **Metrics Definitions**:\n    *   Observation window: $[A_{\\min}, C_{\\max}]$, where $A_{\\min} = \\min_i a_i$ and $C_{\\max} = \\max_i c_i$.\n    *   Time in system for burst $i$: $w_i^{\\text{sys}} = c_i - a_i$.\n    *   Waiting time in queue for burst $i$: $w_i^{\\text{q}} = b_i - a_i$.\n    *   Time-average number in system: $\\overline{L} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt$.\n    *   Time-average number in queue: $\\overline{L_q} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt$.\n    *   Average arrival rate: $\\lambda = \\frac{N}{C_{\\max} - A_{\\min}}$, with $N$ total bursts.\n    *   Average time in system: $\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}}$.\n    *   Average waiting time in queue: $\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}$.\n*   **Verification Goal**: Compute absolute errors $\\varepsilon_{\\text{sys}} = \\left| \\overline{L} - \\lambda\\, \\overline{W} \\right|$ and $\\varepsilon_{\\text{q}} = \\left| \\overline{L_q} - \\lambda\\, \\overline{W_q} \\right|$.\n*   **Test Cases**: Three fully specified test cases are provided, including process definitions, burst arrival/service times, $\\alpha$, and $\\tau_0$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in queueing theory and operating systems principles. The core relationship to be derived, $\\overline{L} = \\lambda \\overline{W}$, is a form of Little's Law, a fundamental theorem in queueing theory. The problem is well-posed, providing all necessary parameters and deterministic rules for a unique simulation outcome. The definitions are precise and objective. There are no contradictions, scientific flaws, or ambiguities.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A full solution will be provided.\n\n### Derivation of Fundamental Relationships (Little's Law)\n\nThe derivation relies on a graphical interpretation, often referred to as the \"area argument,\" applied over the finite observation window $T = C_{\\max} - A_{\\min}$.\n\nLet $L(t)$ be the number of bursts in the system (waiting or in service) at time $t$. The time-average number in the system, $\\overline{L}$, is defined as:\n$$ \\overline{L} = \\frac{1}{T} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt $$\nThe integral $\\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt$ represents the total area under the curve of $L(t)$ versus $t$. This area can be conceptualized as the total \"burst-seconds\" accumulated in the system over the observation window.\n\nAlternatively, we can compute this total accumulation by summing the contributions of each individual burst. For each burst $i$ (from $1$ to $N$), it arrives at time $a_i$ and completes at time $c_i$. The total time it spends in the system is $w_i^{\\text{sys}} = c_i - a_i$. The sum of these individual sojourn times over all $N$ bursts gives the same total burst-seconds accumulated in the system.\n$$ \\sum_{i=1}^{N} w_i^{\\text{sys}} = \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt $$\nThis equality holds because both sides represent the same quantity: the total time-integrated presence of all bursts in the system.\n\nNow, we substitute this into the definition of $\\overline{L}$:\n$$ \\overline{L} = \\frac{1}{T} \\sum_{i=1}^{N} w_i^{\\text{sys}} $$\nWe can rewrite this expression by multiplying and dividing by $N$, the total number of bursts:\n$$ \\overline{L} = \\left( \\frac{N}{T} \\right) \\left( \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}} \\right) $$\nBy substituting the problem's definitions for the average arrival rate, $\\lambda = \\frac{N}{T} = \\frac{N}{C_{\\max} - A_{\\min}}$, and the average time in system, $\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}}$, we arrive at the desired relationship:\n$$ \\overline{L} = \\lambda \\overline{W} $$\nThis result, known as Little's Law, is remarkably general and does not depend on the arrival or service time distributions, nor on the scheduling discipline, provided the system is stable and work-conserving.\n\nThe analogous relationship for the ready queue follows the exact same logic. Let $L_q(t)$ be the number of bursts in the ready queue (waiting for service) at time $t$. The time-average number in the queue is:\n$$ \\overline{L_q} = \\frac{1}{T} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt $$\nThe integral represents the total burst-seconds spent waiting in the queue. This is also equal to the sum of all individual waiting times, $w_i^{\\text{q}} = b_i - a_i$, where $b_i$ is the time service begins for burst $i$.\n$$ \\sum_{i=1}^{N} w_i^{\\text{q}} = \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt $$\nSubstituting this into the definition of $\\overline{L_q}$ and rearranging:\n$$ \\overline{L_q} = \\frac{1}{T} \\sum_{i=1}^{N} w_i^{\\text{q}} = \\left( \\frac{N}{T} \\right) \\left( \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}} \\right) $$\nUsing the definitions for $\\lambda$ and the average waiting time in queue, $\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}$, we obtain:\n$$ \\overline{L_q} = \\lambda \\overline{W_q} $$\nThe simulation will computationally verify that these identities hold to within floating-point precision.\n\n### Simulation Design and Implementation\n\nTo verify these relationships, we construct a discrete-event simulation. The simulation clock advances non-uniformly, jumping from one event to the next. The state of the system changes only at these event times.\n\n**Core Components:**\n1.  **Events**: The primary event types are `ARRIVAL` (a burst enters the ready queue) and `COMPLETION` (a burst finishes execution and leaves the system). An event is characterized by its time and the associated burst.\n2.  **Event Queue**: A priority queue holding all future events, ordered by their scheduled time. A dynamically sorted array is sufficient for this problem's scale.\n3.  **Global Clock**: A variable, `current_time`, tracks the simulation's progress. It is always updated to the time of the next event from the event queue.\n4.  **Ready Queue**: This queue holds bursts that have arrived but are not yet executing.\n5.  **CPU State**: Indicates whether the CPU is `IDLE` or `BUSY`. If `BUSY`, it tracks the burst currently in service.\n6.  **Process State**: For each process, we must maintain its current EWMA prediction, $\\tau$.\n\n**Simulation Logic:**\nThe simulation proceeds by processing events in chronological order.\n1.  **Initialization**:\n    *   All specified bursts are created. `ARRIVAL` events for each are placed into the event queue.\n    *   The event queue is sorted by time.\n    *   The simulation `current_time` is initialized to the time of the first event, which is $A_{\\min}$.\n    *   EWMA predictions ($\\tau$) for all processes are initialized to $\\tau_0$.\n    *   Metric accumulators (for total area under $L(t)$ and $L_q(t)$, and sums of $w_i^{\\text{sys}}$ and $w_i^{\\text{q}}$) are set to $0$.\n\n2.  **Main Loop**: The loop continues until the event queue is empty. In each iteration:\n    *   The next event is removed from the event queue.\n    *   The time difference, $\\Delta t$, between the new `current_time` (from the event) and the `last_event_time` is calculated.\n    *   The area accumulators are updated: `area_L += num_in_system * Δt`, `area_Lq += num_in_queue * Δt`. The values `num_in_system` and `num_in_queue` are those that were constant during the interval $(\\text{last\\_event\\_time}, \\text{current\\_time}]$.\n    *   The `current_time` and `last_event_time` are updated.\n    *   The event is processed:\n        *   If `ARRIVAL`: The burst is added to the ready queue.\n        *   If `COMPLETION`: The burst is marked as finished. Its $w_i^{\\text{sys}}$ and $w_i^{\\text{q}}$ are calculated and added to the cumulative sums. The EWMA prediction $\\tau$ for its process is updated. The CPU is set to `IDLE`.\n    *   After processing the event, the scheduler is invoked if the CPU is `IDLE` and the ready queue is non-empty.\n\n3.  **Scheduler**:\n    *   The scheduler searches the ready queue for the burst with the minimum predicted service time $\\tau$.\n    *   Ties are broken by selecting the burst with the earliest arrival time.\n    *   Any further ties are broken deterministically (e.g., by lowest process ID, then by burst index).\n    *   The selected burst is removed from the ready queue, and its service begins. Its start time $b_i$ is recorded as the `current_time`.\n    *   A new `COMPLETION` event is created for this burst at `current_time + s_i` and inserted into the event queue, which is then re-sorted. The CPU is set to `BUSY`.\n\n4.  **Finalization**:\n    *   When the simulation ends (event queue empty), the final time is $C_{\\max}$. The total observation period is $T = C_{\\max} - A_{\\min}$.\n    *   The final average metrics ($\\overline{L}$, $\\overline{L_q}$, $\\lambda$, $\\overline{W}$, $\\overline{W_q}$) are calculated from the accumulated totals.\n    *   The consistency errors, $\\varepsilon_{\\text{sys}}$ and $\\varepsilon_{\\text{q}}$, are computed as the absolute differences prescribed by Little's Law.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Enum for event types\ntypedef enum {\n    ARRIVAL,\n    COMPLETION\n} EventType;\n\n// Struct to hold burst information\ntypedef struct Burst {\n    int id;\n    int process_id;\n    double arrival_time;\n    double service_time;\n    \n    // Metrics calculated during simulation\n    double start_time;\n    double completion_time;\n} Burst;\n\n// Struct for simulation events\ntypedef struct Event {\n    EventType type;\n    double time;\n    Burst* burst_ptr;\n} Event;\n\n// Struct to hold a node in the ready queue (linked list)\ntypedef struct ReadyNode {\n    Burst* burst;\n    struct ReadyNode* next;\n} ReadyNode;\n\n// Struct to manage a single test case\ntypedef struct {\n    int num_processes;\n    double alpha;\n    double tau0;\n    Burst* bursts;\n    int num_bursts;\n} TestCase;\n\n// Comparison function for qsort'ing events by time\nint compare_events(const void* a, const void* b) {\n    Event* eventA = (Event*)a;\n    Event* eventB = (Event*)b;\n    if (eventA->time < eventB->time) return -1;\n    if (eventA->time > eventB->time) return 1;\n    return 0;\n}\n\n// Main simulation function for a single test case\nvoid run_simulation(const TestCase* tc, double* err_sys, double* err_q) {\n    // ---- Initialization ----\n    int total_bursts = tc->num_bursts;\n    if (total_bursts == 0) {\n        *err_sys = 0.0;\n        *err_q = 0.0;\n        return;\n    }\n\n    double* tau_predictions = (double*)malloc(tc->num_processes * sizeof(double));\n    for (int i = 0; i < tc->num_processes; ++i) {\n        tau_predictions[i] = tc->tau0;\n    }\n\n    // Create a mutable copy of bursts\n    Burst* sim_bursts = (Burst*)malloc(total_bursts * sizeof(Burst));\n    memcpy(sim_bursts, tc->bursts, total_bursts * sizeof(Burst));\n\n    // Event queue setup\n    int event_capacity = total_bursts * 2;\n    Event* event_queue = (Event*)malloc(event_capacity * sizeof(Event));\n    int num_events = 0;\n\n    double min_arrival_time = -1.0;\n    for (int i = 0; i < total_bursts; ++i) {\n        event_queue[num_events++] = (Event){ARRIVAL, sim_bursts[i].arrival_time, &sim_bursts[i]};\n        if (min_arrival_time < 0.0 || sim_bursts[i].arrival_time < min_arrival_time) {\n            min_arrival_time = sim_bursts[i].arrival_time;\n        }\n    }\n    qsort(event_queue, num_events, sizeof(Event), compare_events);\n\n    // Simulation state\n    double current_time = min_arrival_time;\n    double last_event_time = min_arrival_time;\n    ReadyNode* ready_queue_head = NULL;\n    int ready_queue_size = 0;\n    Burst* running_burst = NULL;\n\n    // Metric accumulators\n    double sum_w_sys = 0.0;\n    double sum_w_q = 0.0;\n    double area_L = 0.0;\n    double area_Lq = 0.0;\n\n    // ---- Simulation Loop ----\n    int processed_events = 0;\n    while(processed_events < num_events) {\n        Event current_event = event_queue[processed_events++];\n        double event_time = current_event.time;\n        \n        // Update area integrals\n        double delta_t = event_time - last_event_time;\n        int num_in_system = ready_queue_size + (running_burst ? 1 : 0);\n        area_L += num_in_system * delta_t;\n        area_Lq += ready_queue_size * delta_t;\n        \n        current_time = event_time;\n        last_event_time = event_time;\n\n        // Process event\n        if (current_event.type == ARRIVAL) {\n            ReadyNode* new_node = (ReadyNode*)malloc(sizeof(ReadyNode));\n            new_node->burst = current_event.burst_ptr;\n            new_node->next = ready_queue_head;\n            ready_queue_head = new_node;\n            ready_queue_size++;\n        } else { // COMPLETION\n            running_burst->completion_time = current_time;\n            double w_sys = running_burst->completion_time - running_burst->arrival_time;\n            double w_q = running_burst->start_time - running_burst->arrival_time;\n            sum_w_sys += w_sys;\n            sum_w_q += w_q;\n\n            // Update EWMA\n            int pid = running_burst->process_id;\n            tau_predictions[pid] = tc->alpha * running_burst->service_time + (1.0 - tc->alpha) * tau_predictions[pid];\n            \n            running_burst = NULL;\n        }\n        \n        // Scheduler invocation\n        if (running_burst == NULL && ready_queue_size > 0) {\n            ReadyNode* best_node_prev = NULL;\n            ReadyNode* best_node = NULL;\n            double min_tau = -1.0;\n\n            ReadyNode* current_node_prev = NULL;\n            ReadyNode* current_node = ready_queue_head;\n            while(current_node != NULL) {\n                Burst* b = current_node->burst;\n                double current_tau = tau_predictions[b->process_id];\n                if (best_node == NULL || \n                    current_tau < min_tau ||\n                    (current_tau == min_tau && b->arrival_time < best_node->burst->arrival_time) ||\n                    (current_tau == min_tau && b->arrival_time == best_node->burst->arrival_time && b->process_id < best_node->burst->process_id) ||\n                    (current_tau == min_tau && b->arrival_time == best_node->burst->arrival_time && b->process_id == best_node->burst->process_id && b->id < best_node->burst->id)\n                   ) {\n                    min_tau = current_tau;\n                    best_node = current_node;\n                    best_node_prev = current_node_prev;\n                }\n                current_node_prev = current_node;\n                current_node = current_node->next;\n            }\n\n            // Unlink best_node from ready queue\n            if (best_node_prev == NULL) {\n                ready_queue_head = best_node->next;\n            } else {\n                best_node_prev->next = best_node->next;\n            }\n            running_burst = best_node->burst;\n            free(best_node);\n            ready_queue_size--;\n            \n            // Start the burst\n            running_burst->start_time = current_time;\n            double completion_t = current_time + running_burst->service_time;\n            \n            event_queue[num_events++] = (Event){COMPLETION, completion_t, running_burst};\n            qsort(event_queue, num_events, sizeof(Event), compare_events);\n        }\n    }\n    \n    // ---- Final Calculations ----\n    double C_max = current_time;\n    double T_obs = C_max - min_arrival_time;\n    \n    if (T_obs > 0.0) {\n        double lambda = (double)total_bursts / T_obs;\n        double avg_W = sum_w_sys / (double)total_bursts;\n        double avg_Wq = sum_w_q / (double)total_bursts;\n        double avg_L = area_L / T_obs;\n        double avg_Lq = area_Lq / T_obs;\n\n        *err_sys = fabs(avg_L - lambda * avg_W);\n        *err_q = fabs(avg_Lq - lambda * avg_Wq);\n    } else {\n        *err_sys = 0.0;\n        *err_q = 0.0;\n    }\n    \n    // ---- Cleanup ----\n    free(tau_predictions);\n    free(sim_bursts);\n    free(event_queue);\n    // Free any remaining nodes in ready queue (should be empty but good practice)\n    while (ready_queue_head != NULL) {\n        ReadyNode* temp = ready_queue_head;\n        ready_queue_head = ready_queue_head->next;\n        free(temp);\n    }\n}\n\nint main(void) {\n    Burst tc1_bursts[] = {\n        {0, 0, 0.0, 5.0}, {1, 0, 12.0, 4.0}, {2, 0, 23.0, 6.0},\n        {3, 1, 1.0, 3.0}, {4, 1, 7.0, 2.0},  {5, 1, 15.0, 8.0},\n        {6, 2, 2.0, 6.0}, {7, 2, 9.0, 7.0},  {8, 2, 25.0, 3.0}\n    };\n    \n    Burst tc2_bursts[] = {\n        {0, 0, 0.0, 9.0}, {1, 0, 10.0, 9.0}, {2, 0, 20.0, 9.0},\n        {3, 1, 0.1, 2.0}, {4, 1, 2.5, 2.0},  {5, 1, 4.9, 2.0}, {6, 1, 7.4, 2.0}, {7, 1, 9.8, 2.0}, {8, 1, 12.2, 2.0},\n        {9, 2, 0.2, 4.0}, {10, 2, 4.3, 4.5}, {11, 2, 8.4, 5.0}, {12, 2, 12.5, 5.2}\n    };\n    \n    Burst tc3_bursts[] = {\n        {0, 0, 0.0, 1.0}, {1, 0, 2.0, 9.0},\n        {2, 1, 0.5, 5.0},\n        {3, 2, 1.0, 4.0}, {4, 2, 3.0, 3.0}\n    };\n\n    TestCase test_cases[] = {\n        {3, 0.5, 5.0, tc1_bursts, sizeof(tc1_bursts) / sizeof(tc1_bursts[0])},\n        {3, 0.9, 6.0, tc2_bursts, sizeof(tc2_bursts) / sizeof(tc2_bursts[0])},\n        {3, 0.0, 4.0, tc3_bursts, sizeof(tc3_bursts) / sizeof(tc3_bursts[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases * 2];\n\n    for (int i = 0; i < num_cases; ++i) {\n        run_simulation(&test_cases[i], &results[i*2], &results[i*2 + 1]);\n    }\n\n    printf(\"[%.6f,%.6f,%.6f,%.6f,%.6f,%.6f]\\n\", \n           results[0], results[1], results[2], results[3], results[4], results[5]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3682783"}, {"introduction": "The Shortest-Job-First algorithm has two major variants: non-preemptive, where a selected job runs to completion, and preemptive (also known as Shortest-Remaining-Time-First), which allows a running job to be interrupted by a new, shorter job. This advanced hands-on exercise asks you to implement both scheduling modes and conduct a head-to-head comparison of their impact on system responsiveness. By tackling the logic of preemption and dispatch overhead, you'll gain deep insight into the critical design trade-offs between minimizing response time and managing the costs of context switching.[@problem_id:3682843]", "problem": "Design and implement a complete, runnable program that compares Shortest-Job-First (SJF) scheduling in both non-preemptive and preemptive modes for the same workload using Central Processing Unit (CPU) burst prediction by exponential averaging. The goal is to compute, for each process, the difference in response time between the preemptive and non-preemptive variants under the same prediction model and to evaluate a formal constraint predicate that indicates when non-preemption must be enforced.\n\nYou must base your design on the following core definitions and well-tested formulas from operating systems and stochastic prediction:\n- A process has a single CPU burst with an arrival time and an actual burst length (both measured in integer time units).\n- Response time is the elapsed time from a process’s arrival until the instant it first begins executing on the Central Processing Unit (CPU) after any dispatch overheads. Formally, if a process arrives at time $a_i$ and begins executing at time $s_i$, then its response time is $R_i = s_i - a_i$.\n- Shortest-Job-First (SJF) scheduling prioritizes processes by their next CPU burst length; the preemptive variant (Shortest-Remaining-Time-First) always selects the process with the shortest remaining predicted time.\n- CPU burst prediction uses exponential averaging. Let the predicted burst before the first historical burst be $\\tau_0$. Given a sequence of historical actual CPU bursts for a process, $\\{t_1, t_2, \\dots, t_m\\}$, and a smoothing parameter $\\alpha$ with $0 \\le \\alpha \\le 1$, the predicted next burst $\\tau_{m}$ is obtained by the recurrence\n$$\n\\tau_{k+1} = \\alpha \\cdot t_{k} + (1-\\alpha)\\cdot \\tau_{k}, \\quad \\text{for } k \\in \\{0,1,\\dots,m-1\\}, \\quad \\text{with } \\tau_0 \\text{ given},\n$$\nwhere $t_0$ is interpreted as the first historical burst $t_1$.\n\nScheduling semantics to implement:\n- Non-preemptive SJF: When the CPU becomes idle, select among arrived and not-yet-completed processes the one with the smallest predicted next burst $\\tau_m$; break ties by earlier arrival time, then by lower process index. Run the selected process to completion of its CPU burst (ignoring subsequent arrivals during its execution), incurring a fixed dispatch overhead cost $c_s$ immediately before the process begins to run.\n- Preemptive SJF: Maintain the currently running process and its predicted remaining time that decreases at rate $1$ while it runs. On every arrival instant, compare the new process’s predicted next burst $\\tau_m$ to the currently running process’s predicted remaining time. If the new $\\tau_m$ is strictly smaller, preempt by switching to the new process; otherwise, continue. A dispatch overhead cost $c_s$ is incurred immediately before each dispatch when starting or resuming a process, including from idle. For selection while the CPU is idle, or immediately after a completion, choose the process with the smallest predicted remaining time (which equals $\\tau_m$ for processes that have not yet started) with the same tie-breaking rule as above.\n\nModeling constraints that may force non-preemption:\n- Define a boolean predicate that evaluates to true if and only if at least one of the following holds:\n  1. The per-dispatch overhead $c_s$ exceeds a given threshold $c_{\\max}$, that is, $c_s > c_{\\max}$.\n  2. There exists a process $i$ with a maximum non-preemptible critical section length $L_i$ strictly greater than a preemption granularity bound $G$, that is, $\\exists i : L_i > G$.\n\nYour program must:\n- Compute the predicted next burst $\\tau_m$ for each process using the exponential averaging formula above, with the per-process given historical bursts, a global $\\alpha$, and a global $\\tau_0$.\n- Simulate both non-preemptive and preemptive SJF as per the specified semantics, including dispatch overhead $c_s$.\n- Compute response times $R^{\\text{NP}}_i$ and $R^{\\text{P}}_i$ for non-preemptive and preemptive variants, respectively, and return the per-process differences $\\Delta_i = R^{\\text{P}}_i - R^{\\text{NP}}_i$ as integers for each process.\n- Evaluate the constraint predicate defined above and return its boolean value.\n\nImportant details to ensure universal applicability:\n- All times are integer time units. All outputs should be integers for the $\\Delta_i$ values and booleans for the constraint predicate. No physical units are required beyond these integer time units.\n- Comparisons of predicted times must treat “strictly smaller” as a strict inequality; ties do not trigger preemption.\n\nTest Suite and parameters to embed in your program:\n- Test Case $1$ (happy path with staggered arrivals and moderate prediction accuracy):\n  - $n=4$\n  - Arrivals: $[0, 1, 2, 3]$\n  - Actual bursts: $[8, 4, 1, 2]$\n  - Historical bursts per process: lengths $[1, 1, 1, 1]$ with histories $[[8], [5], [3], [3]]$\n  - $\\alpha = 0.5$, $\\tau_0 = 5.0$\n  - Dispatch overhead $c_s = 0$, threshold $c_{\\max} = 3$\n  - Non-preemptible maximum lengths $L = [0, 0, 0, 0]$, granularity $G = 1$\n- Test Case $2$ (boundary: all arrive simultaneously with perfect prediction):\n  - $n=3$\n  - Arrivals: $[0, 0, 0]$\n  - Actual bursts: $[3, 2, 1]$\n  - Historical bursts per process: lengths $[1, 1, 1]$ with histories $[[3], [2], [1]]$\n  - $\\alpha = 1.0$, $\\tau_0 = 0.0$\n  - Dispatch overhead $c_s = 0$, threshold $c_{\\max} = 1$\n  - Non-preemptible maximum lengths $L = [0, 0, 0]$, granularity $G = 1$\n- Test Case $3$ (edge: late-arriving short job, high context-switch overhead forces non-preemption by predicate):\n  - $n=2$\n  - Arrivals: $[0, 5]$\n  - Actual bursts: $[10, 1]$\n  - Historical bursts per process: lengths $[1, 1]$ with histories $[[10], [1]]$\n  - $\\alpha = 0.8$, $\\tau_0 = 5.0$\n  - Dispatch overhead $c_s = 4$, threshold $c_{\\max} = 3$\n  - Non-preemptible maximum lengths $L = [0, 0]$, granularity $G = 10$\n- Test Case $4$ (edge: non-preemptible critical section exceeds granularity, forcing non-preemption by predicate):\n  - $n=3$\n  - Arrivals: $[0, 2, 4]$\n  - Actual bursts: $[6, 2, 2]$\n  - Historical bursts per process: lengths $[1, 1, 1]$ with histories $[[7], [1], [3]]$\n  - $\\alpha = 0.6$, $\\tau_0 = 3.0$\n  - Dispatch overhead $c_s = 1$, threshold $c_{\\max} = 10$\n  - Non-preemptible maximum lengths $L = [0, 5, 0]$, granularity $G = 3$\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a two-element list where:\n  1. The first element is the list of per-process response time differences $\\Delta_i$ in process index order.\n  2. The second element is the boolean value of the non-preemption-forcing predicate.\n- Concretely, the overall output must be of the form\n  $$\n  \\big[\\,[\\,[\\Delta_1,\\dots,\\Delta_n],\\,\\text{bool}\\,],\\; \\dots \\,\\big]\n  $$\n  where each $\\Delta_i$ is an integer and each $\\text{bool}$ is either the literal $true$ or $false$.", "solution": "### Problem Validation\nThe problem is scientifically grounded in operating systems theory and provides a well-posed, deterministic simulation challenge. All parameters, scheduling rules, tie-breaking logic, and formulas are specified, ensuring a unique and verifiable solution exists. The problem is valid.\n\n### Solution Design\nThe solution requires implementing and comparing two distinct discrete-event simulations—non-preemptive and preemptive SJF—and evaluating a constraint predicate. The core steps are: prediction calculation, simulation execution, and metric computation.\n\n**1. CPU Burst Prediction**\nFirst, for each process, we must calculate its predicted next CPU burst length. This is done by applying the exponential averaging formula iteratively. Starting with the global initial prediction $\\tau_0$, we process the sequence of historical bursts for each process. For a process with a history of $m$ bursts $\\{h_1, h_2, \\dots, h_m\\}$, the final prediction $\\tau_{\\text{next}}$ is computed as follows:\nLet $\\tau^{(0)} = \\tau_0$.\n$\\tau^{(1)} = \\alpha \\cdot h_1 + (1-\\alpha) \\cdot \\tau^{(0)}$\n$\\tau^{(2)} = \\alpha \\cdot h_2 + (1-\\alpha) \\cdot \\tau^{(1)}$\n...\n$\\tau_{\\text{next}} = \\tau^{(m)} = \\alpha \\cdot h_m + (1-\\alpha) \\cdot \\tau^{(m-1)}$\nThis final $\\tau_{\\text{next}}$ is used as the predicted burst length for scheduling.\n\n**2. Non-Preemptive SJF Simulation**\nThis simulation can be modeled by advancing time based on process completions.\n- The simulation begins with a time of 0.\n- As long as there are incomplete processes, the scheduler identifies all processes that have arrived but not yet run (the \"ready queue\").\n- If the ready queue is empty, time is advanced to the earliest arrival time of a future process.\n- From the ready queue, the process with the smallest predicted burst time is selected. Ties are broken first by the earliest arrival time, and then by the lowest process index.\n- Once a process is selected, a dispatch occurs. Time advances by the dispatch overhead, $c_s$. The process's response time is calculated at this moment.\n- The process then runs to completion without interruption. Time advances by its full actual burst length.\n- The process is marked as completed, and the cycle repeats.\n\n**3. Preemptive SJF (SRTF) Simulation**\nThis simulation is more complex due to preemption. An event-driven approach is most suitable, where the simulation clock jumps to the next significant event.\n- **Events:** Key events are process arrivals and the completion of a running process.\n- **State:** Each process tracks its actual and predicted remaining burst times.\n- **Logic:**\n    1. The simulation clock advances to the time of the next event (the earliest of all future arrivals and the completion time of the currently running process).\n    2. At the event time, the state of the system is updated (e.g., a new process becomes \"ready\", or the running process becomes \"done\").\n    3. A scheduling decision is made. The scheduler considers the currently running process (if any) and all processes in the ready queue. The process with the minimum *predicted remaining time* is the candidate to run next.\n    4. **Preemption Check:** If a running process exists, its predicted remaining time is compared to the best candidate from the ready queue. If the ready candidate's predicted time is *strictly smaller*, the running process is preempted and returned to the ready queue.\n    5. **Dispatch:** Whenever a process is chosen to run (either starting fresh or resuming after preemption), a dispatch overhead of $c_s$ is incurred. The clock is advanced by $c_s$ before the process begins or resumes execution. The response time is recorded only the *first* time a process is dispatched.\n    6. The simulation continues until all processes are marked as done.\n\n**4. Final Metrics and Predicate Evaluation**\nAfter running both simulations, the response time for each process $i$ under both non-preemptive ($R^{\\text{NP}}_i$) and preemptive ($R^{\\text{P}}_i$) modes is obtained. The difference $\\Delta_i = R^{\\text{P}}_i - R^{\\text{NP}}_i$ is calculated.\n\nSeparately, the non-preemption constraint predicate is evaluated based on its strict definition: the predicate is `true` if $c_s > c_{\\max}$ or if there exists any process $i$ for which its maximum non-preemptible length $L_i$ is greater than the granularity bound $G$. This is a direct check of the input parameters.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\n// To avoid stdbool.h\ntypedef int bool;\n#define true 1\n#define false 0\n\ntypedef enum {\n    STATE_NEW,\n    STATE_READY,\n    STATE_RUNNING,\n    STATE_DONE\n} ProcessState;\n\ntypedef struct {\n    // Static properties\n    int id;\n    int arrival_time;\n    int actual_burst;\n    int* history;\n    int history_len;\n    int L; // Max non-preemptible critical section length\n\n    // Dynamic simulation properties\n    double predicted_burst;\n    double predicted_remaining;\n    int actual_remaining;\n    ProcessState state;\n    int start_time;\n    int response_time;\n} Process;\n\ntypedef struct {\n    int n;\n    int* arrivals;\n    int* actual_bursts;\n    int* history_lens;\n    int** histories;\n    int* Ls;\n    double alpha;\n    double tau0;\n    int c_s;\n    int c_max;\n    int G;\n} TestCase;\n\n// Forward declarations\nvoid run_simulation(const TestCase* tc, int* deltas);\nvoid calculate_predictions(Process* processes, int n, double alpha, double tau0);\nvoid simulate_non_preemptive(Process* processes, int n, int c_s, int* response_times);\nvoid simulate_preemptive(Process* processes, int n, int c_s, int* response_times);\nbool evaluate_predicate(const TestCase* tc);\nvoid reset_processes(Process* processes, int n);\n\n\nvoid calculate_predictions(Process* processes, int n, double alpha, double tau0) {\n    for (int i = 0; i < n; ++i) {\n        double current_tau = tau0;\n        for (int k = 0; k < processes[i].history_len; ++k) {\n            current_tau = alpha * processes[i].history[k] + (1.0 - alpha) * current_tau;\n        }\n        processes[i].predicted_burst = current_tau;\n    }\n}\n\nvoid reset_processes(Process* processes, int n) {\n    for (int i = 0; i < n; ++i) {\n        processes[i].state = STATE_NEW;\n        processes[i].actual_remaining = processes[i].actual_burst;\n        processes[i].predicted_remaining = processes[i].predicted_burst;\n        processes[i].start_time = -1;\n        processes[i].response_time = -1;\n    }\n}\n\nvoid simulate_non_preemptive(Process* processes, int n, int c_s, int* response_times) {\n    reset_processes(processes, n);\n    int current_time = 0;\n    int done_count = 0;\n\n    while (done_count < n) {\n        int best_proc_idx = -1;\n        double min_burst = (double)INT_MAX;\n\n        for (int i = 0; i < n; ++i) {\n            if (processes[i].state != STATE_DONE && processes[i].arrival_time <= current_time) {\n                if (processes[i].predicted_burst < min_burst) {\n                    min_burst = processes[i].predicted_burst;\n                    best_proc_idx = i;\n                } else if (processes[i].predicted_burst == min_burst) {\n                    if (processes[i].arrival_time < processes[best_proc_idx].arrival_time) {\n                        best_proc_idx = i;\n                    } else if (processes[i].arrival_time == processes[best_proc_idx].arrival_time) {\n                        if (processes[i].id < processes[best_proc_idx].id) {\n                            best_proc_idx = i;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (best_proc_idx == -1) {\n            int next_arrival = INT_MAX;\n            for (int i = 0; i < n; ++i) {\n                if (processes[i].state != STATE_DONE && processes[i].arrival_time < next_arrival) {\n                    next_arrival = processes[i].arrival_time;\n                }\n            }\n            current_time = next_arrival;\n            continue;\n        }\n\n        Process* p_run = &processes[best_proc_idx];\n        current_time += c_s;\n        p_run->start_time = current_time;\n        p_run->response_time = p_run->start_time - p_run->arrival_time;\n        current_time += p_run->actual_burst;\n        p_run->state = STATE_DONE;\n        done_count++;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        response_times[i] = processes[i].response_time;\n    }\n}\n\nvoid simulate_preemptive(Process* processes, int n, int c_s, int* response_times) {\n    reset_processes(processes, n);\n    int current_time = 0;\n    int done_count = 0;\n    Process* running_proc = NULL;\n    \n    while (done_count < n) {\n        // Update states for newly arrived processes\n        for (int i = 0; i < n; ++i) {\n            if (processes[i].state == STATE_NEW && processes[i].arrival_time <= current_time) {\n                processes[i].state = STATE_READY;\n            }\n        }\n        \n        int best_ready_idx = -1;\n        double min_rem_time = (double)INT_MAX;\n\n        // Find best candidate in ready queue\n        for (int i = 0; i < n; ++i) {\n            if (processes[i].state == STATE_READY) {\n                if (processes[i].predicted_remaining < min_rem_time) {\n                    min_rem_time = processes[i].predicted_remaining;\n                    best_ready_idx = i;\n                } else if (processes[i].predicted_remaining == min_rem_time) {\n                    if (processes[i].arrival_time < processes[best_ready_idx].arrival_time) {\n                        best_ready_idx = i;\n                    } else if (processes[i].arrival_time == processes[best_ready_idx].arrival_time) {\n                        if (processes[i].id < processes[best_ready_idx].id) {\n                            best_ready_idx = i;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check for preemption or dispatch\n        if ((running_proc != NULL && best_ready_idx != -1 && processes[best_ready_idx].predicted_remaining < running_proc->predicted_remaining) ||\n            (running_proc == NULL && best_ready_idx != -1)) {\n            \n            if (running_proc != NULL) { // Preemption\n                running_proc->state = STATE_READY;\n            }\n            \n            running_proc = &processes[best_ready_idx];\n            running_proc->state = STATE_RUNNING;\n            \n            current_time += c_s; // Dispatch overhead\n            \n            if (running_proc->start_time == -1) {\n                running_proc->start_time = current_time;\n                running_proc->response_time = running_proc->start_time - running_proc->arrival_time;\n            }\n        }\n\n        // Advance time\n        if (running_proc == NULL) {\n            int next_arrival = INT_MAX;\n            for(int i = 0; i < n; ++i) {\n                if (processes[i].state == STATE_NEW && processes[i].arrival_time < next_arrival) {\n                    next_arrival = processes[i].arrival_time;\n                }\n            }\n            current_time = (next_arrival == INT_MAX) ? current_time + 1 : next_arrival;\n            continue;\n        }\n\n        int time_to_next_arrival = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            if (processes[i].state == STATE_NEW && processes[i].arrival_time > current_time) {\n                 if (processes[i].arrival_time < time_to_next_arrival) {\n                     time_to_next_arrival = processes[i].arrival_time;\n                 }\n            }\n        }\n        int time_to_advance = time_to_next_arrival - current_time;\n        if (time_to_advance <= 0) time_to_advance = INT_MAX;\n\n        if (running_proc->actual_remaining < time_to_advance) {\n            time_to_advance = running_proc->actual_remaining;\n        }\n        if (time_to_advance == 0) time_to_advance = 1;\n\n\n        current_time += time_to_advance;\n        running_proc->actual_remaining -= time_to_advance;\n        running_proc->predicted_remaining -= time_to_advance;\n\n        if (running_proc->actual_remaining <= 0) {\n            running_proc->state = STATE_DONE;\n            running_proc = NULL;\n            done_count++;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        response_times[i] = processes[i].response_time;\n    }\n}\n\n\nbool evaluate_predicate(const TestCase* tc) {\n    if (tc->c_s > tc->c_max) {\n        return true;\n    }\n    for (int i = 0; i < tc->n; ++i) {\n        if (tc->Ls[i] > tc->G) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid run_simulation(const TestCase* tc, int* deltas) {\n    Process* processes = (Process*)malloc(tc->n * sizeof(Process));\n    for (int i = 0; i < tc->n; ++i) {\n        processes[i].id = i;\n        processes[i].arrival_time = tc->arrivals[i];\n        processes[i].actual_burst = tc->actual_bursts[i];\n        processes[i].history_len = tc->history_lens[i];\n        processes[i].history = tc->histories[i];\n        processes[i].L = tc->Ls[i];\n    }\n\n    calculate_predictions(processes, tc->n, tc->alpha, tc->tau0);\n\n    int* r_np = (int*)malloc(tc->n * sizeof(int));\n    int* r_p = (int*)malloc(tc->n * sizeof(int));\n    \n    simulate_non_preemptive(processes, tc->n, tc->c_s, r_np);\n    simulate_preemptive(processes, tc->n, tc->c_s, r_p);\n\n    for (int i = 0; i < tc->n; ++i) {\n        deltas[i] = r_p[i] - r_np[i];\n    }\n\n    free(processes);\n    free(r_np);\n    free(r_p);\n}\n\nint main(void) {\n    // Test Case 1\n    int tc1_arrivals[] = {0, 1, 2, 3};\n    int tc1_bursts[] = {8, 4, 1, 2};\n    int tc1_hist_lens[] = {1, 1, 1, 1};\n    int tc1_h0[] = {8}, tc1_h1[] = {5}, tc1_h2[] = {3}, tc1_h3[] = {3};\n    int* tc1_hists[] = {tc1_h0, tc1_h1, tc1_h2, tc1_h3};\n    int tc1_ls[] = {0, 0, 0, 0};\n\n    // Test Case 2\n    int tc2_arrivals[] = {0, 0, 0};\n    int tc2_bursts[] = {3, 2, 1};\n    int tc2_hist_lens[] = {1, 1, 1};\n    int tc2_h0[] = {3}, tc2_h1[] = {2}, tc2_h2[] = {1};\n    int* tc2_hists[] = {tc2_h0, tc2_h1, tc2_h2};\n    int tc2_ls[] = {0, 0, 0};\n\n    // Test Case 3\n    int tc3_arrivals[] = {0, 5};\n    int tc3_bursts[] = {10, 1};\n    int tc3_hist_lens[] = {1, 1};\n    int tc3_h0[] = {10}, tc3_h1[] = {1};\n    int* tc3_hists[] = {tc3_h0, tc3_h1};\n    int tc3_ls[] = {0, 0};\n\n    // Test Case 4\n    int tc4_arrivals[] = {0, 2, 4};\n    int tc4_bursts[] = {6, 2, 2};\n    int tc4_hist_lens[] = {1, 1, 1};\n    int tc4_h0[] = {7}, tc4_h1[] = {1}, tc4_h2[] = {3};\n    int* tc4_hists[] = {tc4_h0, tc4_h1, tc4_h2};\n    int tc4_ls[] = {0, 5, 0};\n\n    TestCase test_cases[] = {\n        {4, tc1_arrivals, tc1_bursts, tc1_hist_lens, tc1_hists, tc1_ls, 0.5, 5.0, 0, 3, 1},\n        {3, tc2_arrivals, tc2_bursts, tc2_hist_lens, tc2_hists, tc2_ls, 1.0, 0.0, 0, 1, 1},\n        {2, tc3_arrivals, tc3_bursts, tc3_hist_lens, tc3_hists, tc3_ls, 0.8, 5.0, 4, 3, 10},\n        {3, tc4_arrivals, tc4_bursts, tc4_hist_lens, tc4_hists, tc4_ls, 0.6, 3.0, 1, 10, 3}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    \n    printf(\"[\");\n\n    for (int i = 0; i < num_cases; ++i) {\n        int* deltas = (int*)malloc(test_cases[i].n * sizeof(int));\n        run_simulation(&test_cases[i], deltas);\n        bool predicate_val = evaluate_predicate(&test_cases[i]);\n\n        printf(\"[[\");\n        for (int j = 0; j < test_cases[i].n; ++j) {\n            printf(\"%d%s\", deltas[j], (j == test_cases[i].n - 1) ? \"\" : \",\");\n        }\n        printf(\"],%s]\", predicate_val ? \"true\" : \"false\");\n\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n        \n        free(deltas);\n    }\n\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3682843"}]}