{"hands_on_practices": [{"introduction": "Priority is not always an absolute \"first-or-nothing\" concept. In many modern schedulers, it determines a proportional share of the system's resources. This first exercise challenges you to derive the fundamental formula that links a process's assigned weight to the CPU time it can expect, reinforcing the core principle of proportional-share scheduling [@problem_id:3671520].", "problem": "An operating system uses a proportional-share scheduler to allocate Central Processing Unit (CPU) time among $n$ continuously runnable, CPU-bound classes, indexed by $i \\in \\{1,\\dots,n\\}$. Each class $i$ is assigned a positive priority weight $w_i \\in \\mathbb{R}_{>0}$. The scheduler is designed according to the following core definitions: (i) it is work-conserving, meaning the CPU never idles when any class is runnable, and (ii) it enforces proportionality, meaning that in steady state a class’s long-run service rate is proportional to its weight. The CPU capacity is normalized to $1$ unit of service per unit time. Consider an observation window of length $T > 0$ during which all $n$ classes remain runnable and the system remains in steady state.\n\nUsing only these definitions and the conservation of capacity, derive a closed-form expression for the expected CPU time allocated to class $i$ over the duration $T$ in terms of $w_i$, $\\sum_{j=1}^{n} w_j$, and $T$. Express your final answer as a single analytic expression. Do not include units in your final answer.", "solution": "The problem requires the derivation of a closed-form expression for the expected Central Processing Unit (CPU) time allocated to a specific class $i$ over a given time interval. We will formalize the provided definitions and constraints into a mathematical model to arrive at the solution.\n\nFirst, let's define the primary variables. There are $n$ runnable classes, indexed by $i \\in \\{1, \\dots, n\\}$. Each class $i$ is assigned a positive priority weight, denoted by $w_i$, where $w_i \\in \\mathbb{R}_{>0}$. The total duration of the observation window is $T > 0$. The total CPU capacity is normalized to $1$ unit of service per unit of time.\n\nLet $S_i$ be the long-run service rate allocated to class $i$. This represents the fraction of the total CPU capacity that class $i$ receives. The problem states that this rate is proportional to the class's weight $w_i$. We can express this proportionality relationship mathematically by introducing a constant of proportionality, $k$:\n$$S_i = k \\cdot w_i$$\nThis constant $k$ is the same for all classes $i=1, \\dots, n$, as it establishes the system-wide proportionality between weight and service rate.\n\nThe next piece of information is that the scheduler is work-conserving. A work-conserving scheduler ensures that the CPU does not idle as long as there is at least one runnable process. The problem statement specifies that all $n$ classes are continuously runnable throughout the observation window of length $T$. Consequently, the CPU is fully utilized during this period. The sum of the service rates allocated to all classes must therefore equal the total CPU capacity. Given that the capacity is normalized to $1$, we can write a conservation law:\n$$\\sum_{i=1}^{n} S_i = 1$$\nWe can now determine the value of the proportionality constant $k$ by substituting the expression for $S_i$ into the conservation equation:\n$$\\sum_{i=1}^{n} (k \\cdot w_i) = 1$$\nSince $k$ is a constant with respect to the summation index $i$, we can factor it out of the sum:\n$$k \\left( \\sum_{i=1}^{n} w_i \\right) = 1$$\nThe problem states that each weight $w_i$ is a positive real number. Therefore, the sum $\\sum_{j=1}^{n} w_j$ is strictly positive, and we can safely divide by it. Solving for $k$, we get:\n$$k = \\frac{1}{\\sum_{j=1}^{n} w_j}$$\nHere, we use $j$ as the summation index in the denominator as suggested by the prompt, though it is a dummy variable.\n\nWith the constant $k$ determined, we can now express the service rate $S_i$ for any class $i$ in terms of the given weights:\n$$S_i = k \\cdot w_i = \\frac{w_i}{\\sum_{j=1}^{n} w_j}$$\nThis equation gives the fraction of CPU time that class $i$ receives per unit time.\n\nFinally, we need to find the total expected CPU time allocated to class $i$ over the duration $T$. Let this quantity be denoted by $C_i(T)$. Since the system is specified to be in a steady state, the service rate $S_i$ is constant over the interval $T$. The total allocated time is the rate of allocation multiplied by the duration of the interval:\n$$C_i(T) = S_i \\times T$$\nSubstituting our derived expression for $S_i$ yields the final closed-form expression:\n$$C_i(T) = \\left( \\frac{w_i}{\\sum_{j=1}^{n} w_j} \\right) T$$\nThis can be written more compactly as:\n$$C_i(T) = \\frac{w_i T}{\\sum_{j=1}^{n} w_j}$$\nThis expression gives the expected CPU time for class $i$ in terms of its weight $w_i$, the sum of all weights $\\sum_{j=1}^{n} w_j$, and the observation time $T$, as required.", "answer": "$$\\boxed{\\frac{w_i T}{\\sum_{j=1}^{n} w_j}}$$", "id": "3671520"}, {"introduction": "One of the most classic and dangerous pitfalls in preemptive priority scheduling is priority inversion, where a high-priority task is blocked by a low-priority task indirectly. This practice presents a clear scenario to quantitatively measure the delay caused by priority inversion. By comparing the system's performance with and without Priority Inheritance, you will gain a concrete understanding of why this mechanism is critical for building reliable, responsive systems [@problem_id:3623596].", "problem": "Consider a preemptive fixed-priority time-sharing scheduler in a multiprogrammed operating system. Three tasks are present: a high-priority task $H$, a medium-priority task $M$, and a low-priority task $L$. Task $L$ currently holds a mutual exclusion (mutex) lock $X$ protecting a short critical section. At time $t=0$, task $L$ is executing inside $X$ with a remaining critical-section execution time of $c_{L}=2.4\\,\\mathrm{ms}$. At $t=0^{+}$, task $H$ arrives and immediately attempts to acquire $X$, thus blocking until $X$ is released. Also at $t=0^{+}$, task $M$ becomes ready to run with a single compute burst of $c_{M}=7.6\\,\\mathrm{ms}$ and requires no locks or input/output. Assume a single Central Processing Unit (CPU), preemptive fixed-priority scheduling, $H \\succ M \\succ L$ (higher priority denoted by $\\succ$), and that there are no other tasks or arrivals. Assume $0$ scheduling, context-switch, and lock/unlock overheads. \n\nDefine the priority inversion delay experienced by $H$ as the time from when $H$ requests $X$ at $t=0^{+}$ to when $H$ acquires $X$. Under standard scheduling without Priority Inheritance (PI), when a high-priority task $H$ blocks on a lock held by a lower-priority task $L$, any medium-priority task $M$ that is ready will preempt $L$, thereby extending $H$’s wait. Under Priority Inheritance (PI), when $H$ blocks on $X$, the lock holder $L$ temporarily inherits $H$’s priority until $X$ is released, preventing preemption by $M$.\n\nStarting from first principles of preemptive fixed-priority scheduling and the semantics of blocking and priority inheritance, derive expressions for the lock wait time of $H$ without PI and with PI. Then, compute the ratio \n$$R=\\frac{\\text{lock wait time without PI}}{\\text{lock wait time with PI}}.$$\nProvide $R$ as a pure number (dimensionless). Round your answer to four significant figures.", "solution": "This problem requires the analysis of task execution on a single Central Processing Unit (CPU) under a preemptive fixed-priority scheduling policy. The core of the problem is to determine the lock wait time experienced by a high-priority task, $H$, under two different scenarios: one without and one with the Priority Inheritance (PI) protocol. The lock wait time for task $H$ is defined as the duration from when it requests a mutex lock $X$ to when it successfully acquires it.\n\nLet us denote the priorities of the tasks as $P_H$, $P_M$, and $P_L$. The problem states that $H \\succ M \\succ L$, which translates to $P_H > P_M > P_L$. The scheduler is preemptive, meaning if a task with priority $P_{\\text{new}}$ becomes ready while a task with priority $P_{\\text{current}}$ is running, the running task will be preempted if $P_{\\text{new}} > P_{\\text{current}}$.\n\nThe initial conditions at time $t=0$ are:\n- Task $L$ (low priority) is executing in a critical section protected by mutex $X$.\n- The remaining execution time for $L$ to complete its critical section is $c_L = 2.4\\,\\mathrm{ms}$.\n\nAt time $t=0^{+}$ (an infinitesimally small time after $t=0$):\n- Task $H$ (high priority) arrives and requests lock $X$. Since $X$ is held by $L$, task $H$ enters a \"Blocked\" state.\n- Task $M$ (medium priority) becomes \"Ready\" to execute, with a CPU burst of duration $c_M = 7.6\\,\\mathrm{ms}$.\n\nWe analyze the system's evolution in two separate cases.\n\n### Case 1: Scheduling without Priority Inheritance (PI)\n\nIn this scenario, task priorities are static and do not change.\n\n1.  At $t=0^{+}$, the scheduler must decide which task to run. The states of the tasks are:\n    -   Task $H$: Blocked (waiting for lock $X$). Not eligible to run.\n    -   Task $M$: Ready.\n    -   Task $L$: Was running, but a scheduling decision must be made due to the arrival of a ready task $M$. For the purpose of scheduling, $L$ is considered Ready.\n\n2.  The scheduler compares the priorities of all *Ready* tasks: $P_M$ and $P_L$. Since $P_M > P_L$, the scheduler preempts task $L$ and dispatches task $M$.\n\n3.  From $t=0^{+}$ until task $M$ completes its CPU burst, task $M$ will occupy the CPU. This duration is $c_M = 7.6\\,\\mathrm{ms}$. During this interval, task $L$ remains in the Ready state, unable to make progress on its critical section. This is the classic priority inversion scenario where a medium-priority task delays a high-priority task.\n\n4.  At $t=c_M = 7.6\\,\\mathrm{ms}$, task $M$ completes its execution and is no longer Ready. The scheduler now re-evaluates. The only Ready task is $L$ (task $H$ is still Blocked). Therefore, the scheduler dispatches task $L$.\n\n5.  Task $L$ now runs for its remaining critical section time, $c_L = 2.4\\,\\mathrm{ms}$. It finishes its critical section at time $t = c_M + c_L = 7.6\\,\\mathrm{ms} + 2.4\\,\\mathrm{ms} = 10.0\\,\\mathrm{ms}$.\n\n6.  At $t=10.0\\,\\mathrm{ms}$, task $L$ releases the mutex lock $X$. The release of $X$ unblocks task $H$, changing its state from Blocked to Ready.\n\n7.  The scheduler must again make a decision. The Ready tasks are now $H$ and $L$. Since $P_H > P_L$, the scheduler immediately preempts $L$ and dispatches $H$. Task $H$ acquires the lock $X$ at this time.\n\nThe lock wait time for $H$ without PI, denoted $W_{\\text{noPI}}$, is the total time elapsed from its request at $t=0^{+}$ until it acquires the lock at $t=10.0\\,\\mathrm{ms}$.\n$$W_{\\text{noPI}} = c_M + c_L = 7.6\\,\\mathrm{ms} + 2.4\\,\\mathrm{ms} = 10.0\\,\\mathrm{ms}$$\n\n### Case 2: Scheduling with Priority Inheritance (PI)\n\nIn this scenario, the priority of a lock-holding task can be temporarily elevated.\n\n1.  At $t=0^{+}$, task $H$ attempts to acquire lock $X$ and blocks because $L$ holds it.\n2.  The Priority Inheritance protocol is triggered. Task $L$, the lock holder, temporarily inherits the priority of the highest-priority task it is blocking. In this case, $L$ inherits the priority of $H$. Let the effective priority of $L$ be $P'_L$. Then $P'_L = P_H$.\n3.  Simultaneously, task $M$ becomes Ready.\n4.  The scheduler must decide which task to run. The states of the tasks are:\n    -   Task $H$: Blocked.\n    -   Task $M$: Ready.\n    -   Task $L$: Ready, with an effective priority $P'_L = P_H$.\n\n5.  The scheduler compares the priorities of the Ready tasks: $M$ and $L$. Since $P'_L = P_H$ and $P_H > P_M$, the effective priority of $L$ is greater than the priority of $M$. Therefore, task $M$ cannot preempt task $L$. Task $L$ continues to run.\n\n6.  Task $L$ executes for its remaining critical section time, $c_L = 2.4\\,\\mathrm{ms}$. It starts at $t=0$ and finishes at $t=c_L = 2.4\\,\\mathrm{ms}$.\n\n7.  At $t=2.4\\,\\mathrm{ms}$, task $L$ releases the lock $X$. At this moment:\n    -   The priority of $L$ reverts to its original low value, $P_L$.\n    -   Task $H$ is unblocked and becomes Ready.\n\n8.  The scheduler makes a decision. The Ready tasks are $H$, $M$, and $L$. Their priorities are $P_H > P_M > P_L$. The scheduler dispatches the highest-priority task, $H$. Thus, task $H$ acquires the lock $X$ at $t=2.4\\,\\mathrm{ms}$.\n\nThe lock wait time for $H$ with PI, denoted $W_{\\text{PI}}$, is the total time elapsed from its request at $t=0^{+}$ until it acquires the lock at $t=2.4\\,\\mathrm{ms}$.\n$$W_{\\text{PI}} = c_L = 2.4\\,\\mathrm{ms}$$\n\n### Calculation of the Ratio R\n\nThe problem asks for the ratio $R = \\frac{\\text{lock wait time without PI}}{\\text{lock wait time with PI}}$.\n$$R = \\frac{W_{\\text{noPI}}}{W_{\\text{PI}}} = \\frac{c_M + c_L}{c_L}$$\nSubstituting the given numerical values:\n$$R = \\frac{7.6 + 2.4}{2.4} = \\frac{10.0}{2.4}$$\nTo compute the value:\n$$R = \\frac{10}{2.4} = \\frac{100}{24} = \\frac{25}{6} = 4.1666...$$\nThe problem requires the answer to be rounded to four significant figures.\n$$R \\approx 4.167$$\nThis ratio quantifies the performance improvement gained by using Priority Inheritance to mitigate the effects of priority inversion in this specific scenario.", "answer": "$$\\boxed{4.167}$$", "id": "3623596"}, {"introduction": "The ultimate test of understanding is the ability to analyze real-world behavior. In this exercise, you will act as a system detective, examining a detailed CPU execution trace. Your task is to deduce the specific scheduling algorithm in use by observing preemption patterns and timing, a skill essential for performance tuning and debugging in complex operating systems [@problem_id:3660835].", "problem": "Consider a single-processor system using a preemptive scheduler. The Central Processing Unit (CPU) executes one job at a time and can be interrupted (preempted) according to the scheduler’s policy. Assume that Round-Robin (RR) is defined as time-sliced scheduling with a fixed time quantum $Q$, applied uniformly within the scope of the RR policy; that is, a job running under RR is preempted upon consuming $Q$ units of CPU time unless it completes sooner. A single-level preemptive priority RR scheduler maintains one ready queue ordered by priority and applies the same RR time quantum $Q$ to all jobs; upon arrival of a higher-priority job, the currently running job is immediately preempted. A multilevel queue scheduler partitions jobs into multiple ready queues by priority class; the CPU is allocated strictly to the highest-priority non-empty queue, and each queue may use its own scheduling policy and parameters (for example, distinct RR time quanta or First-Come First-Served (FCFS)).\n\nYou observe the following arrival events and an execution trace. Jobs are labeled $J_1, J_2, \\dots$ with priority classes High ($H$), Medium ($M$), and Low ($L$), and each job has a total CPU demand (service time). Arrival events:\n- At time $t=0$ milliseconds, $J_1(H)$ arrives with demand $6$ milliseconds.\n- At time $t=1$ milliseconds, $J_2(M)$ arrives with demand $8$ milliseconds.\n- At time $t=2$ milliseconds, $J_3(H)$ arrives with demand $3$ milliseconds.\n- At time $t=3$ milliseconds, $J_4(L)$ arrives with demand $10$ milliseconds.\n- At time $t=5$ milliseconds, $J_5(M)$ arrives with demand $4$ milliseconds.\n- At time $t=27$ milliseconds, $J_6(H)$ arrives with demand $2$ milliseconds.\n\nThe observed CPU execution trace (context switches occur exactly at the times stated):\n- Between time $t=0$ milliseconds and time $t=2$ milliseconds, $J_1$ runs and is preempted.\n- Between time $t=2$ milliseconds and time $t=4$ milliseconds, $J_3$ runs and is preempted.\n- Between time $t=4$ milliseconds and time $t=6$ milliseconds, $J_1$ runs and is preempted.\n- Between time $t=6$ milliseconds and time $t=7$ milliseconds, $J_3$ runs and completes.\n- Between time $t=7$ milliseconds and time $t=9$ milliseconds, $J_1$ runs and completes.\n- Between time $t=9$ milliseconds and time $t=13$ milliseconds, $J_2$ runs and is preempted.\n- Between time $t=13$ milliseconds and time $t=17$ milliseconds, $J_5$ runs and completes.\n- Between time $t=17$ milliseconds and time $t=21$ milliseconds, $J_2$ runs and completes.\n- Between time $t=21$ milliseconds and time $t=27$ milliseconds, $J_4$ runs uninterrupted.\n- At time $t=27$ milliseconds, $J_6(H)$ arrives and immediately preempts $J_4$; between time $t=27$ milliseconds and time $t=29$ milliseconds, $J_6$ runs and completes.\n- Between time $t=29$ milliseconds and time $t=33$ milliseconds, $J_4$ resumes and completes.\n\nBased only on the fundamental definitions given above and the observed preemption patterns and slice durations in the trace, which scheduler is most consistent with these observations?\n- A. Multilevel queue scheduling with strict priority across queues; RR in high and medium queues using potentially distinct time quanta, and FCFS in the low-priority queue.\n- B. Single-level preemptive priority Round-Robin with a uniform time quantum applied to all jobs.\n- C. Multilevel Feedback Queue (MLFQ) with dynamic promotion and demotion based on recent CPU bursts.\n- D. Single-level non-preemptive priority scheduling.", "solution": "To identify the scheduling algorithm, we will analyze the execution trace by cross-referencing it with the job arrival times and priorities.\n\n1.  **Analysis of Priority Preemption:** The trace shows a strict, preemptive priority scheme.\n    *   From $t=0$ until $t=9$, only the high-priority jobs ($J_1$ and $J_3$) are executed, even though medium and low-priority jobs arrive during this interval ($J_2(M)$ at $t=1$, $J_4(L)$ at $t=3$, $J_5(M)$ at $t=5$). This demonstrates that the scheduler strictly prioritizes higher-priority classes.\n    *   At $t=27$, the arrival of a high-priority job, $J_6(H)$, immediately preempts the currently running low-priority job, $J_4(L)$. This confirms the scheduler is preemptive based on priority.\n    *   This evidence of strict, preemptive priority scheduling rules out option **(D) Single-level non-preemptive priority scheduling**.\n\n2.  **Analysis of Intra-Priority Scheduling Policies:** We now examine how jobs within the same priority class are scheduled.\n    *   **High-Priority Queue ($H$):** At $t=2$, when $J_3(H)$ arrives, the running job $J_1(H)$ is preempted after having run for 2 ms. The scheduler then gives the CPU to the other high-priority job, $J_3$. The trace shows them alternating in 2 ms time slices ($J_1$ from $t=0-2$, $J_3$ from $t=2-4$, $J_1$ from $t=4-6$). This is characteristic of a Round-Robin (RR) policy with a time quantum $Q_H = 2$ ms.\n    *   **Medium-Priority Queue ($M$):** This queue becomes active at $t=9$. Job $J_2$ runs from $t=9$ to $t=13$ (a 4 ms slice) and is preempted. Then, $J_5$ runs from $t=13$ to $t=17$ (a 4 ms slice) and completes. $J_2$ resumes from $t=17$ to $t=21$ (another 4 ms slice) to complete. This indicates an RR policy with a time quantum $Q_M = 4$ ms.\n    *   **Low-Priority Queue ($L$):** This queue becomes active at $t=21$. Job $J_4$ runs from $t=21$ to $t=27$ (a 6 ms slice) without being preempted by a time quantum. It is only preempted by the arrival of $J_6(H)$. This behavior is consistent with a First-Come First-Served (FCFS) policy, not RR.\n\n3.  **Evaluating the Options:**\n    *   **(A) Multilevel queue scheduling with strict priority across queues; RR in high and medium queues using potentially distinct time quanta, and FCFS in the low-priority queue.** This option perfectly matches all our observations: strict priority, RR in high queue ($Q_H=2$ ms), RR in medium queue ($Q_M=4$ ms), distinct quanta ($2 \\neq 4$), and FCFS in the low-priority queue.\n    *   **(B) Single-level preemptive priority Round-Robin with a uniform time quantum applied to all jobs.** This is incorrect because we observed two different time quanta ($Q_H=2$ ms and $Q_M=4$ ms), and the low-priority queue did not use RR at all.\n    *   **(C) Multilevel Feedback Queue (MLFQ) with dynamic promotion and demotion...** This is incorrect as there is no evidence of any job changing its priority level throughout the trace.\n    *   **(D)** was already ruled out.\n\nTherefore, the only scheduler consistent with the observations is the one described in option A.", "answer": "$$\\boxed{A}$$", "id": "3660835"}]}