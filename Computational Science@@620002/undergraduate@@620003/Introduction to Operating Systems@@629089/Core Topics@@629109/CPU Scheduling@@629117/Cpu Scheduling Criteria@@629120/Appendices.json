{"hands_on_practices": [{"introduction": "Before comparing sophisticated algorithms, it is essential to master the fundamental metrics that quantify their performance. This first practice focuses on the precise calculation of turnaround time, waiting time, and response time from first principles. By analyzing a simple First-Come, First-Served (FCFS) schedule, you will see how these metrics are derived and discover how identical jobs can experience vastly different wait and response times depending on their arrival order, a key insight into scheduling fairness [@problem_id:3630364].", "problem": "Consider a single-core Central Processing Unit (CPU) scheduled by non-preemptive First-Come, First-Served (FCFS). Context-switch overhead is negligible. Four jobs, $J_1, J_2, J_3, J_4$, each require an identical CPU burst of $4$ milliseconds. Their arrival times (in milliseconds) are $A_1 = 0$, $A_2 = 1$, $A_3 = 2$, $A_4 = 10$. Using only the fundamental definitions of response time, waiting time, turnaround time, throughput, and CPU utilization (over the interval from time $0$ until completion of the last job), carry out the following:\n\n- Construct the FCFS execution timeline.\n- For each job $J_i$, determine its response time, waiting time, and turnaround time, and then compute the averages of these metrics across all four jobs. Express all time quantities in milliseconds.\n- Compute the throughput over the interval from time $0$ until the completion of the last job, expressed in jobs per millisecond.\n- Compute the CPU utilization over the same interval as a fraction or decimal (do not use a percentage sign).\n- Briefly discuss, based on the computed times, how identical CPU bursts can nevertheless result in different response times under FCFS due to arrival order.\n\nFinally, quantify the fairness of response times by the coefficient of variation of response times across the four jobs, defined as the standard deviation divided by the mean across the jobs. Report this coefficient of variation as your final answer in an exact symbolic form (do not round). No units are required for the final reported value.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem within the domain of operating systems, specifically CPU scheduling. All necessary data and definitions are provided, and there are no internal contradictions or ambiguities.\n\nWe begin by defining the primary performance metrics based on the arrival time $A_i$, burst time $B_i$, start time $S_i$, and completion time $C_i$ for each job $J_i$.\n- **Turnaround Time ($TT_i$)**: The total time a job spends in the system, from arrival to completion. It is calculated as $TT_i = C_i - A_i$.\n- **Waiting Time ($WT_i$)**: The total time a job spends in the ready queue. For a non-preemptive algorithm, this is the time from arrival until its execution begins, calculated as $WT_i = S_i - A_i$.\n- **Response Time ($RT_i$)**: The time from a job's arrival until it receives its first response (i.e., starts executing). For non-preemptive scheduling, this is identical to the waiting time: $RT_i = S_i - A_i$.\n\nThe givens are:\n- Scheduling algorithm: Non-preemptive First-Come, First-Served (FCFS).\n- Number of jobs: $4$.\n- Arrival times: $A_1 = 0$ ms, $A_2 = 1$ ms, $A_3 = 2$ ms, $A_4 = 10$ ms.\n- CPU burst times: $B_1 = B_2 = B_3 = B_4 = 4$ ms.\n\nFirst, we construct the execution timeline (Gantt chart) based on the FCFS scheduling policy.\n\\begin{enumerate}\n    \\item At time $t=0$, job $J_1$ arrives. The ready queue is $[J_1]$. The CPU is idle, so $J_1$ starts executing immediately. Its start time is $S_1 = 0$.\n    \\item $J_1$ requires a CPU burst of $4$ ms. It will run from $t=0$ to $t=4$. Its completion time is $C_1 = S_1 + B_1 = 0 + 4 = 4$.\n    \\item During the execution of $J_1$, jobs $J_2$ (at $t=1$) and $J_3$ (at $t=2$) arrive. When $J_1$ completes at $t=4$, the ready queue, ordered by arrival time, is $[J_2, J_3]$.\n    \\item According to FCFS, $J_2$ is served next. It starts at $t=4$, so $S_2 = 4$. It runs for $4$ ms, completing at $C_2 = S_2 + B_2 = 4 + 4 = 8$.\n    \\item At $t=8$, $J_2$ completes. The ready queue now contains only $J_3$. $J_3$ starts immediately, so $S_3 = 8$. It runs for $4$ ms, completing at $C_3 = S_3 + B_3 = 8 + 4 = 12$.\n    \\item During the execution of $J_3$, job $J_4$ arrives at $t=10$. When $J_3$ completes at $t=12$, the ready queue contains $[J_4]$.\n    \\item $J_4$ starts at $t=12$, so $S_4 = 12$. It runs for $4$ ms, completing at $C_4 = S_4 + B_4 = 12 + 4 = 16$.\n\\end{enumerate}\nThe execution timeline is:\n- $J_1$: $t \\in [0, 4)$\n- $J_2$: $t \\in [4, 8)$\n- $J_3$: $t \\in [8, 12)$\n- $J_4$: $t \\in [12, 16)$\n\nNow we compute the performance metrics for each job.\n- **Job $J_1$**:\n  - $TT_1 = C_1 - A_1 = 4 - 0 = 4$ ms.\n  - $WT_1 = S_1 - A_1 = 0 - 0 = 0$ ms.\n  - $RT_1 = WT_1 = 0$ ms.\n- **Job $J_2$**:\n  - $TT_2 = C_2 - A_2 = 8 - 1 = 7$ ms.\n  - $WT_2 = S_2 - A_2 = 4 - 1 = 3$ ms.\n  - $RT_2 = WT_2 = 3$ ms.\n- **Job $J_3$**:\n  - $TT_3 = C_3 - A_3 = 12 - 2 = 10$ ms.\n  - $WT_3 = S_3 - A_3 = 8 - 2 = 6$ ms.\n  - $RT_3 = WT_3 = 6$ ms.\n- **Job $J_4$**:\n  - $TT_4 = C_4 - A_4 = 16 - 10 = 6$ ms.\n  - $WT_4 = S_4 - A_4 = 12 - 10 = 2$ ms.\n  - $RT_4 = WT_4 = 2$ ms.\n\nNext, we compute the average metrics:\n- Average Turnaround Time ($TT_{avg}$):\n$$ TT_{avg} = \\frac{TT_1 + TT_2 + TT_3 + TT_4}{4} = \\frac{4 + 7 + 10 + 6}{4} = \\frac{27}{4} = 6.75 \\text{ ms} $$\n- Average Waiting Time ($WT_{avg}$):\n$$ WT_{avg} = \\frac{WT_1 + WT_2 + WT_3 + WT_4}{4} = \\frac{0 + 3 + 6 + 2}{4} = \\frac{11}{4} = 2.75 \\text{ ms} $$\n- Average Response Time ($RT_{avg}$): Since the scheduling is non-preemptive, $RT_{avg} = WT_{avg} = 2.75$ ms.\n\nNow we compute the throughput and CPU utilization over the interval from $t=0$ to the completion of the last job, $t=16$.\n- **Throughput**: The number of jobs completed per unit time.\n$$ \\text{Throughput} = \\frac{\\text{Number of jobs}}{\\text{Total time}} = \\frac{4}{16} = \\frac{1}{4} = 0.25 \\text{ jobs/ms} $$\n- **CPU Utilization**: The fraction of time the CPU was busy.\nThe total time for the interval is $16 - 0 = 16$ ms. The total CPU busy time is the sum of all burst times: $4 \\times 4 = 16$ ms.\n$$ \\text{CPU Utilization} = \\frac{\\text{Total busy time}}{\\text{Total time}} = \\frac{16}{16} = 1 $$\n\nThe problem asks for a discussion on why identical CPU bursts can result in different response times. The computed response times are $RT_1 = 0$ ms, $RT_2 = 3$ ms, $RT_3 = 6$ ms, and $RT_4 = 2$ ms. These are clearly different despite all jobs having an identical burst time of $4$ ms. The response time, $RT_i = S_i - A_i$, depends on both the start time and the arrival time. Under FCFS, the start time $S_i$ is determined by the completion times of all previously-arrived jobs.\n- $J_1$ arrives to an idle system, so it starts immediately ($S_1=A_1$), and its response time is $0$.\n- $J_2$ arrives at $t=1$ while $J_1$ is running. It must wait in the queue until $J_1$ finishes at $t=4$. Its response time is the duration it waited after arrival, $RT_2 = 4-1=3$.\n- $J_3$ arrives at $t=2$ and must wait for both $J_1$ and $J_2$. They complete at $t=8$. Its response time is $RT_3 = 8-2=6$.\n- $J_4$ arrives late at $t=10$, while $J_3$ is running. It only needs to wait for $J_3$ to finish at $t=12$. Its response time is $RT_4 = 12-10=2$.\nThus, the response time is a function of the system's load upon a job's arrival. Jobs arriving close together during a busy period will experience longer waits, a phenomenon known as the convoy effect in FCFS.\n\nFinally, we quantify the fairness of response times using the coefficient of variation (CV), defined as the standard deviation divided by the mean. The set of response times is $\\{0, 3, 6, 2\\}$.\nThe mean response time, $\\mu_{RT}$, is:\n$$ \\mu_{RT} = \\frac{0 + 3 + 6 + 2}{4} = \\frac{11}{4} $$\nTo find the standard deviation, $\\sigma_{RT}$, we first compute the variance, $\\sigma_{RT}^2$. Using the formula $\\sigma^2 = \\frac{1}{N}\\sum_{i=1}^{N} x_i^2 - \\mu^2$:\n$$ \\sum_{i=1}^{4} RT_i^2 = 0^2 + 3^2 + 6^2 + 2^2 = 0 + 9 + 36 + 4 = 49 $$\n$$ \\sigma_{RT}^2 = \\frac{1}{4} \\sum_{i=1}^{4} RT_i^2 - \\mu_{RT}^2 = \\frac{49}{4} - \\left(\\frac{11}{4}\\right)^2 = \\frac{49}{4} - \\frac{121}{16} = \\frac{4 \\times 49}{16} - \\frac{121}{16} = \\frac{196 - 121}{16} = \\frac{75}{16} $$\nThe standard deviation is the square root of the variance:\n$$ \\sigma_{RT} = \\sqrt{\\frac{75}{16}} = \\frac{\\sqrt{25 \\times 3}}{\\sqrt{16}} = \\frac{5\\sqrt{3}}{4} $$\nThe coefficient of variation is:\n$$ CV_{RT} = \\frac{\\sigma_{RT}}{\\mu_{RT}} = \\frac{5\\sqrt{3}/4}{11/4} = \\frac{5\\sqrt{3}}{11} $$", "answer": "$$\\boxed{\\frac{5\\sqrt{3}}{11}}$$", "id": "3630364"}, {"introduction": "Different scheduling algorithms embody distinct philosophies about which jobs to prioritize. This exercise provides a direct comparison between a non-preemptive policy, First-Come, First-Served (FCFS), and a preemptive one, Round Robin (RR). You will analyze a hypothetical workload designed to create the \"convoy effect,\" where short processes get stuck behind long ones, and see how RR's time-sharing approach alters performance, revealing fundamental trade-offs between minimizing average turnaround time and ensuring responsiveness for all jobs [@problem_id:3630417].", "problem": "You are to analyze a uniprocessor system that schedules a finite workload intentionally constructed to highlight the effects of interleaving two alternating classes of processes on turnaround time. The two classes are defined as follows.\n\n- Class $\\mathcal{S}$ (short): each process has a single Central Processing Unit (CPU) burst of length $2$ time units and performs no input/output.\n- Class $\\mathcal{L}$ (long): each process has a single CPU burst of length $10$ time units and performs no input/output.\n\nThe arrival sequence alternates strictly by class, beginning with a class $\\mathcal{S}$ process at time $t=0$. Specifically, there are $6$ processes with the following arrivals and CPU burst lengths:\n- $S_1$: arrival time $0$, CPU burst $2$.\n- $L_1$: arrival time $1$, CPU burst $10$.\n- $S_2$: arrival time $2$, CPU burst $2$.\n- $L_2$: arrival time $3$, CPU burst $10$.\n- $S_3$: arrival time $4$, CPU burst $2$.\n- $L_3$: arrival time $5$, CPU burst $10$.\n\nAssume a single-core CPU, no context switching overhead, and that each process consists of exactly one CPU burst. The scheduler is work-conserving and non-idling whenever the ready queue is nonempty. For First-Come, First-Served (FCFS), when the CPU becomes free, the process with the smallest arrival time among those waiting is selected (break ties by earlier arrival index in the list above). For Round Robin (RR), use a fixed time quantum $q=2$ time units; at each quantum expiration, first enqueue all processes that have arrived at or before that instant to the tail of the ready queue in nondecreasing arrival time order, and then, if the preempted process still has remaining time, append it to the tail.\n\nUse the standard definition of turnaround time: for process $i$ with arrival time $A_i$ and completion time $C_i$, the turnaround time is $T_i=C_i-A_i$. Compute the average turnaround time across all $6$ processes under FCFS and under RR on this workload. Then, starting from these core definitions and the stated scheduling rules (without invoking any additional formulas), briefly explain how interleaving the two classes affects turnaround under the two policies.\n\nAnswer specification:\n- You must show the derivation of both average turnaround times and your explanation in your working.\n- The single reported quantity must be the ratio of the average turnaround time under FCFS to that under RR, expressed as an exact fraction in simplest terms.\n- Use time units as the unit of time; do not convert units. No rounding is required for the reported ratio.", "solution": "We begin from the definitions and the given scheduling semantics. For each process $i$, with arrival time $A_i$ and completion time $C_i$, the turnaround time is $T_i=C_i-A_i$. The average turnaround time is the arithmetic mean across all $6$ processes. We compute these under First-Come, First-Served (FCFS) and Round Robin (RR) with time quantum $q=2$.\n\nFCFS schedule:\n- At $t=0$, only $S_1$ is present, so $S_1$ runs from $t=0$ to $t=2$ and completes; $T_{S_1}=2-0=2$.\n- At $t=1$, $L_1$ arrived; at $t=2$, $S_2$ arrives. Since $L_1$ arrived earlier, it starts at $t=2$ and runs its $10$-unit burst to completion at $t=12$; $T_{L_1}=12-1=11$.\n- By $t=12$, the ready queue in order of arrival is $S_2$ (arrival $2$), $L_2$ ($3$), $S_3$ ($4$), $L_3$ ($5$).\n- $S_2$ runs $t=12$ to $t=14$, completes; $T_{S_2}=14-2=12$.\n- $L_2$ runs $t=14$ to $t=24$, completes; $T_{L_2}=24-3=21$.\n- $S_3$ runs $t=24$ to $t=26$, completes; $T_{S_3}=26-4=22$.\n- $L_3$ runs $t=26$ to $t=36$, completes; $T_{L_3}=36-5=31$.\n\nSumming FCFS turnarounds: $T_{S_1}+T_{L_1}+T_{S_2}+T_{L_2}+T_{S_3}+T_{L_3}=2+11+12+21+22+31=99$. The FCFS average is\n$$\\overline{T}_{\\mathrm{FCFS}}=\\frac{99}{6}.$$\n\nRR schedule with $q=2$:\nWe apply the stated rule: at each quantum expiration, enqueue any arrivals up to that time (inclusive) in arrival order, then requeue the preempted process if it has remaining time. We track execution, remaining times, and completion times.\n\n- $t=0$ to $t=2$: $S_1$ runs and completes ($2$ units). During this, $L_1$ arrives at $t=1$. Turnaround $T_{S_1}=2-0=2$.\n- $t=2$ to $t=4$: $L_1$ runs for one quantum, remaining $8$. During this, $S_2$ is already enqueued and $L_2$ arrives at $t=3$. At $t=4$, $S_3$ arrives; we enqueue $S_3$ and then requeue $L_1$.\n- $t=4$ to $t=6$: $S_2$ runs and completes. During this, $L_3$ arrives at $t=5$. $T_{S_2}=6-2=4$.\n- $t=6$ to $t=8$: $L_2$ runs, remaining $8$.\n- $t=8$ to $t=10$: $S_3$ runs and completes. $T_{S_3}=10-4=6$.\n- $t=10$ to $t=12$: $L_1$ runs, remaining $6$.\n- $t=12$ to $t=14$: $L_3$ runs, remaining $8$.\n- $t=14$ to $t=16$: $L_2$ runs, remaining $6$.\n- $t=16$ to $t=18$: $L_1$ runs, remaining $4$.\n- $t=18$ to $t=20$: $L_3$ runs, remaining $6$.\n- $t=20$ to $t=22$: $L_2$ runs, remaining $4$.\n- $t=22$ to $t=24$: $L_1$ runs, remaining $2$.\n- $t=24$ to $t=26$: $L_3$ runs, remaining $4$.\n- $t=26$ to $t=28$: $L_2$ runs, remaining $2$.\n- $t=28$ to $t=30$: $L_1$ runs and completes; $T_{L_1}=30-1=29$.\n- $t=30$ to $t=32$: $L_3$ runs, remaining $2$.\n- $t=32$ to $t=34$: $L_2$ runs and completes; $T_{L_2}=34-3=31$.\n- $t=34$ to $t=36$: $L_3$ runs and completes; $T_{L_3}=36-5=31$.\n\nSumming RR turnarounds: short-class totals $2+4+6=12$, long-class totals $29+31+31=91$, sum $103$. The RR average is\n$$\\overline{T}_{\\mathrm{RR}}=\\frac{103}{6}.$$\n\nRequested ratio:\n$$\\frac{\\overline{T}_{\\mathrm{FCFS}}}{\\overline{T}_{\\mathrm{RR}}}=\\frac{99/6}{103/6}=\\frac{99}{103}.$$\n\nExplanation of interleaving effects:\n- Under FCFS, once a long-class process $\\mathcal{L}$ enters service, it monopolizes the CPU until completion, creating a convoy effect: later-arriving short-class processes $\\mathcal{S}$ wait behind $\\mathcal{L}$ and experience large turnarounds (for example, $S_2$ and $S_3$ accrue turnarounds $12$ and $22$). Early long-class processes complete relatively early (for example, $L_1$ at $t=12$), which lowers their own turnarounds.\n- Under RR with a small quantum $q=2$, the CPU time is interleaved among all ready processes. Short-class processes $\\mathcal{S}$ complete quickly upon their first quanta after arrival (turnarounds $2$, $4$, $6$), improving their own waiting and response characteristics and eliminating the convoy delay. However, the repeated interleaving defers completion of early long-class processes (for example, $L_1$ completes at $t=30$ rather than $t=12$), increasing their turnarounds. In this workload, the improvement for the short class is outweighed by the delay imposed on the early long class, resulting in a larger average turnaround under RR. The ratio above quantifies this net effect.", "answer": "$$\\boxed{\\frac{99}{103}}$$", "id": "3630417"}, {"introduction": "Our analysis becomes more realistic when we account for the practical costs of running a scheduler, namely the time spent on context switching. This final practice moves beyond idealized models to explore how context-switch overhead ($c$) affects overall system efficiency, measured by CPU utilization. By performing a symbolic derivation, you will determine the conditions under which the frequent preemption of Round Robin (RR) can actually lead to lower utilization than the simpler FCFS, highlighting a crucial real-world constraint on scheduler design [@problem_id:3630455].", "problem": "Consider a uniprocessor operating system that charges a context-switch overhead of $c>0$ time units for each scheduler dispatch. A workload arrives at time $0$ consisting of $N$ identical, strictly CPU-bound processes. Each process executes a single uninterrupted CPU burst of duration $B>0$ time units and then terminates; there is no input/output and no further arrivals. Assume the scheduler uses either First-Come, First-Served (FCFS) or Round Robin (RR) with a time quantum $q>0$. For both policies, model the context-switch overhead as being incurred once per scheduled time slice (that is, before each burst or quantum begins, including the very first dispatch for each process).\n\nUsing only the core definition that Central Processing Unit (CPU) utilization is the fraction of elapsed time during which the CPU performs useful process execution rather than scheduler overhead, do the following under the stated assumptions:\n\n- Specify this workload explicitly and explain, in terms of $c$ and $q$, why FCFS can achieve higher utilization than RR when $q$ is small, even though both policies eventually complete the same useful work.\n- Derive, from first principles, symbolic expressions for the utilization achieved by FCFS and by RR as functions of $N$, $B$, $c$, and $q$ over the entire completion of the workload.\n- Compute the threshold quantum $q^{\\ast}$ such that RR’s utilization falls below FCFS whenever $0<q<q^{\\ast}$, and RR’s utilization is equal to FCFS when $q\\geq q^{\\ast}$.\n\nExpress your final answer for $q^{\\ast}$ in closed form using the given parameters. No rounding is required, and no units need be specified in the final boxed answer.", "solution": "The problem is evaluated as valid. It is a well-posed, scientifically grounded problem from the field of operating systems, free from contradictions or ambiguity. All parameters required for a solution are provided. We may proceed with the derivation.\n\nThe core definition provided is that Central Processing Unit (CPU) utilization, denoted $U$, is the fraction of elapsed time during which the CPU is performing useful process execution. This can be expressed as:\n$$\nU = \\frac{\\text{Total Useful Work Time}}{\\text{Total Elapsed Time}}\n$$\nThe total useful work time is the sum of the CPU burst durations for all processes. The workload consists of $N$ identical processes, each with a single CPU burst of duration $B$. Therefore, the total useful work time, $T_{\\text{work}}$, is:\n$$\nT_{\\text{work}} = N \\times B\n$$\nThe total elapsed time, also known as the makespan, is the sum of the total useful work time and the total overhead time incurred from context switching. The scheduling policy determines the total overhead.\n\nFirst, the workload is specified as a set of $N$ processes $\\{P_1, P_2, \\dots, P_N\\}$. For each process $P_i$, the arrival time is $A_i = 0$ and the CPU burst duration is $B_i = B$. All processes are strictly CPU-bound.\n\nLet's derive the utilization for each policy.\n\n**First-Come, First-Served (FCFS) Scheduling**\n\nUnder FCFS, processes are executed sequentially to completion. Without loss of generality, let the execution order be $P_1, P_2, \\dots, P_N$.\nFor each process $P_i$, the system incurs a context-switch overhead of $c$ to dispatch it, and then the process runs for its full burst duration $B$. The time to service a single process is thus $c+B$. Since there are $N$ processes executed one after the other, the total elapsed time, $T_{\\text{FCFS}}$, is:\n$$\nT_{\\text{FCFS}} = \\sum_{i=1}^{N} (c + B) = N(c+B)\n$$\nThe total overhead for FCFS is the sum of all context-switch times, which is $N \\times c$. The total elapsed time is indeed the sum of total work ($NB$) and total overhead ($Nc$).\nThe utilization for FCFS, $U_{\\text{FCFS}}$, is:\n$$\nU_{\\text{FCFS}} = \\frac{T_{\\text{work}}}{T_{\\text{FCFS}}} = \\frac{NB}{N(c+B)} = \\frac{B}{B+c}\n$$\n\n**Round Robin (RR) Scheduling**\n\nUnder RR, the scheduler cycles through the ready queue, dispatching each process for a time quantum of at most $q$. A context switch of cost $c$ occurs before each dispatch.\nA process with a total burst requirement of $B$ will require multiple quanta if $B > q$. The number of times a single process must be dispatched is the smallest integer greater than or equal to $B/q$, which is given by the ceiling function, $\\lceil B/q \\rceil$.\nSince there are $N$ identical processes, the total number of dispatches for the entire workload is:\n$$\n\\text{Total Dispatches}_{\\text{RR}} = N \\times \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\nEach dispatch incurs an overhead of $c$. Thus, the total overhead time for RR is:\n$$\nT_{\\text{overhead, RR}} = N c \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\nThe CPU is never idle, as there is always at least one process in the ready queue until the entire workload is complete. The total elapsed time, $T_{\\text{RR}}$, is the sum of the total useful work and the total overhead.\n$$\nT_{\\text{RR}} = T_{\\text{work}} + T_{\\text{overhead, RR}} = NB + Nc \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\nThe utilization for RR, $U_{\\text{RR}}$, is:\n$$\nU_{\\text{RR}} = \\frac{T_{\\text{work}}}{T_{\\text{RR}}} = \\frac{NB}{NB + Nc \\left\\lceil \\frac{B}{q} \\right\\rceil} = \\frac{B}{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil}\n$$\n\n**Qualitative Comparison**\n\nBoth policies complete the same amount of useful work, $NB$. Utilization is maximized by minimizing overhead.\nThe overhead for FCFS is a constant $Nc$, corresponding to one context switch per process.\nThe overhead for RR is $Nc\\lceil B/q \\rceil$. When the time quantum $q$ is small relative to the burst time $B$ (i.e., $q<B$), the term $\\lceil B/q \\rceil$ is an integer greater than $1$. As $q$ approaches $0$, $\\lceil B/q \\rceil$ approaches infinity. This means that for a small $q$, RR performs many context switches for each process, leading to a total overhead significantly larger than FCFS. This higher overhead increases the total elapsed time for the same amount of useful work, thereby reducing utilization. Consequently, for small $q$, $U_{\\text{FCFS}} > U_{\\text{RR}}$.\n\n**Derivation of the Threshold Quantum $q^{\\ast}$**\n\nWe are looking for a threshold $q^{\\ast}$ such that $U_{\\text{RR}} < U_{\\text{FCFS}}$ for $0 < q < q^{\\ast}$ and $U_{\\text{RR}} = U_{\\text{FCFS}}$ for $q \\geq q^{\\ast}$.\n\nFirst, let's find the condition for equality, $U_{\\text{RR}} = U_{\\text{FCFS}}$:\n$$\n\\frac{B}{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil} = \\frac{B}{B+c}\n$$\nSince $B > 0$, we can equate the denominators:\n$$\nB + c \\left\\lceil \\frac{B}{q} \\right\\rceil = B+c\n$$\nSubtracting $B$ from both sides gives:\n$$\nc \\left\\lceil \\frac{B}{q} \\right\\rceil = c\n$$\nSince the context-switch overhead $c > 0$, we can divide by $c$:\n$$\n\\left\\lceil \\frac{B}{q} \\right\\rceil = 1\n$$\nThe ceiling function $\\lceil x \\rceil$ equals $1$ if and only if $0 < x \\le 1$. In our case, $x = B/q$. Since $B>0$ and $q>0$, the condition $B/q > 0$ is always met. The remaining condition is:\n$$\n\\frac{B}{q} \\le 1\n$$\nThis is equivalent to $q \\ge B$. Thus, $U_{\\text{RR}} = U_{\\text{FCFS}}$ whenever $q \\ge B$. This is intuitive: if the quantum is at least as long as the burst time, each process completes in its first time slice, and RR degenerates to FCFS, resulting in one dispatch per process.\n\nNext, let's find the condition for the inequality, $U_{\\text{RR}} < U_{\\text{FCFS}}$:\n$$\n\\frac{B}{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil} < \\frac{B}{B+c}\n$$\nSince all quantities ($B, c, q, N$) are positive, the denominators are positive. We can take the reciprocal of both sides, which reverses the inequality sign:\n$$\n\\frac{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil}{B} > \\frac{B+c}{B}\n$$\n$$\n1 + \\frac{c}{B} \\left\\lceil \\frac{B}{q} \\right\\rceil > 1 + \\frac{c}{B}\n$$\nSubtracting $1$ from both sides:\n$$\n\\frac{c}{B} \\left\\lceil \\frac{B}{q} \\right\\rceil > \\frac{c}{B}\n$$\nSince $c/B > 0$, we can multiply both sides by $B/c$:\n$$\n\\left\\lceil \\frac{B}{q} \\right\\rceil > 1\n$$\nSince $\\lceil B/q \\rceil$ must be an integer, this is equivalent to $\\lceil B/q \\rceil \\ge 2$. This condition holds if and only if its argument is strictly greater than $1$:\n$$\n\\frac{B}{q} > 1\n$$\nThis is equivalent to $q < B$. Given the problem constraint $q>0$, the inequality $U_{\\text{RR}} < U_{\\text{FCFS}}$ holds for $0 < q < B$.\n\nBy comparing our findings with the problem's definition of $q^{\\ast}$:\n- $U_{\\text{RR}} < U_{\\text{FCFS}}$ for $0 < q < B$.\n- $U_{\\text{RR}} = U_{\\text{FCFS}}$ for $q \\ge B$.\n\nWe can identify the threshold value $q^{\\ast}$ as being equal to $B$.\nTherefore, the threshold quantum is $q^{\\ast} = B$.", "answer": "$$\\boxed{B}$$", "id": "3630455"}]}