{"hands_on_practices": [{"introduction": "To truly understand the robustness of aging as a solution to starvation, we must test it against the most challenging conditions imaginable. This practice guides you through a worst-case analysis, where you'll act as an adversary designing a workload specifically to starve a low-priority task. By deriving the minimum aging parameters needed to guarantee a task completes by its deadline even under this pathological, hypothetical scenario [@problem_id:3620577], you will develop a deep, first-principles understanding of how aging provides deterministic guarantees against starvation.", "problem": "Consider a uniprocessor operating system that uses preemptive, strict-priority scheduling: at any instant, the scheduler runs the ready task with the highest current priority, and preemption is instantaneous with negligible overhead. A single low-priority task arrives at time $t=0$ with base priority $P_{L0}$ and requires $C_{L}$ units of execution time. High-priority tasks arrive over time with a fixed base priority $P_{H}$ satisfying $P_{H} > P_{L0}$, and do not age. The system uses aging to raise the effective priority of the waiting low-priority task according to an aging function $f(t)$ that is nondecreasing in the task’s waiting time $t$ and updates continuously. While the low-priority task is running, its priority does not decrease and remains at least as high as the value it had upon starting to run. Assume all quantities are finite and $D > C_{L}$.\n\nYou are asked to reason from first principles of priority scheduling and aging to ensure finite delay for the low-priority task even under a pathological pattern of high-priority arrivals. Specifically:\n\n- Construct (in your reasoning) an adversarial, but scheduler-compliant, arrival pattern of high-priority jobs that maximizes the waiting time of the low-priority task before it first runs, subject only to the rule that the processor must never be idle while there exists any ready high-priority job.\n- Under that worst case, derive the minimum slope parameter $a$ for each of the following aging policies such that the low-priority task is guaranteed to complete by a given absolute deadline $D$ regardless of the adversarial high-priority arrivals:\n  1. Linear aging: $f(t)=a\\,t$.\n  2. Convex quadratic aging: $f(t)=a\\,t^{2}$.\n\nYour derivation must start only from the core definitions of preemptive strict-priority scheduling and priority aging as described above. Express your final answers as closed-form symbolic expressions in terms of $P_{H}$, $P_{L0}$, $C_{L}$, and $D$. No rounding is required. No physical units are required. Provide both minimum slope parameters as your final answer.", "solution": "The problem will first be validated for scientific soundness, self-consistency, and clarity before a solution is attempted.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n-   System type: Uniprocessor, preemptive, strict-priority scheduling.\n-   Scheduler behavior: Runs the ready task with the highest current priority. Preemption is instantaneous and has negligible overhead.\n-   Low-priority task: Arrives at time $t=0$. Base priority is $P_{L0}$. Required execution time is $C_{L}$.\n-   High-priority tasks: Arrive over time. Fixed base priority is $P_{H}$, with $P_{H} > P_{L0}$. These tasks do not age.\n-   Aging mechanism: Applies to the low-priority task. Its effective priority is $P_L(t) = P_{L0} + f(t)$, where $t$ is the task's waiting time. The aging function $f(t)$ is nondecreasing in $t$ and updates continuously.\n-   Priority lock: While the low-priority task is running, its priority does not decrease and remains at least as high as its priority upon starting execution.\n-   Constraints: All quantities are finite. The absolute deadline $D$ for the low-priority task satisfies $D > C_{L}$.\n-   Adversarial condition: The processor must never be idle while there exists any ready high-priority job.\n-   Objective: Derive the minimum slope parameter $a$ for two aging policies—$f(t)=a\\,t$ and $f(t)=a\\,t^{2}$—such that the low-priority task is guaranteed to complete by deadline $D$ under a worst-case adversarial arrival pattern.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is a theoretical exercise in operating systems scheduling theory. All concepts, including preemptive priority scheduling, starvation, and aging, are well-established within computer science. The problem is formulated with precise mathematical and logical language, free of subjective or ambiguous terminology. The givens are self-consistent and sufficient to derive a solution. For instance, the condition $D > C_{L}$ ensures that the deadline is not trivially impossible, as the allotted time $D$ is strictly greater than the required execution time $C_{L}$. The constraint $P_{H} > P_{L0}$ establishes the fundamental priority inversion scenario that aging is meant to solve. The description of the adversary and the priority lock mechanism provide a clear and well-posed framework for worst-case analysis. The problem is scientifically grounded, well-posed, objective, and complete. It does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A formal solution will be derived.\n\n**Derivation of the Solution**\n\nLet $T_L$ be the low-priority task, which arrives at time $t=0$. Its priority at time $t$, after having waited for a duration $t_w$, is given by $P_L(t_w) = P_{L0} + f(t_w)$. The system employs preemptive, strict-priority scheduling. This means $T_L$ can only enter the running state if its priority is strictly greater than all other ready tasks, or equal to the highest priority if it is already running. Since high-priority tasks have a constant priority $P_H$, $T_L$ is prevented from running as long as there is any ready high-priority task and $P_L(t_w)  P_H$.\n\nTo find the minimum required aging rate, we must analyze the worst-case scenario. The adversary's goal is to maximize the completion time of $T_L$. This is achieved by maximizing its waiting time. The most effective adversarial strategy is to keep the processor fully occupied with high-priority tasks, thereby preventing $T_L$ from ever running. This is permitted by the problem statement, which says \"the processor must never be idle while there exists any ready high-priority job\". The adversary can thus introduce a continuous stream of high-priority tasks to keep the CPU busy.\n\nThe low-priority task $T_L$ can only break this starvation cycle when its own priority, through aging, rises to at least the level of the high-priority tasks. Let $W_{max}$ be the maximum time that $T_L$ can be forced to wait. This worst-case waiting time is the time required for its priority to become equal to $P_H$. At this point, it can no longer be definitively preempted by newly arriving tasks of priority $P_H$. We find $W_{max}$ by setting the aged priority equal to the high-priority level:\n$P_L(W_{max}) = P_{H}$\n$P_{L0} + f(W_{max}) = P_{H}$\nIsolating the term dependent on the aging function gives:\n$f(W_{max}) = P_H - P_{L0}$\n\nOnce $T_L$ begins execution at time $t_{start} = W_{max}$, its priority is locked at a value of at least $P_H$. The problem states: \"While the low-priority task is running, its priority does not decrease and remains at least as high as the value it had upon starting to run.\" Since all other high-priority tasks have a priority of exactly $P_H$, there is no task with a *strictly higher* priority that could preempt $T_L$. Therefore, once $T_L$ starts, it will run to completion without interruption.\n\nThe execution of $T_L$ requires $C_L$ units of time. The total time from arrival to completion, known as the response time $R_L$, is the sum of the waiting time and the execution time. In the worst-case scenario, this is:\n$R_L = W_{max} + C_L$\n\nTo meet the system's requirement, the task must complete by its absolute deadline $D$. This imposes the constraint:\n$R_L \\le D$\nSubstituting the expression for the worst-case response time:\n$W_{max} + C_L \\le D$\nThis implies that the maximum tolerable waiting time is:\n$W_{max} \\le D - C_L$\n\nSince the aging function $f(t)$ is specified as nondecreasing, the inequality $W_{max} \\le D - C_L$ implies $f(W_{max}) \\le f(D - C_L)$. Combining this with our earlier result, $f(W_{max}) = P_H - P_{L0}$, we arrive at the fundamental condition that the aging function must satisfy:\n$P_H - P_{L0} \\le f(D - C_L)$\n\nTo find the *minimum* slope parameter $a$ that guarantees the deadline is met, we must choose the \"slowest\" possible aging function that still satisfies this inequality. This occurs at the boundary, where the inequality becomes an equality:\n$f(D - C_L) = P_H - P_{L0}$\n\nWe now apply this general result to the two specific aging policies.\n\n**1. Linear Aging Policy**\nThe aging function is $f(t) = a\\,t$. Substituting this into our derived condition:\n$a(D - C_L) = P_H - P_{L0}$\nSolving for the minimum parameter $a$ yields:\n$a = \\frac{P_H - P_{L0}}{D - C_L}$\n\n**2. Convex Quadratic Aging Policy**\nThe aging function is $f(t) = a\\,t^2$. Substituting this into our derived condition:\n$a(D - C_L)^2 = P_H - P_{L0}$\nSolving for the minimum parameter $a$ yields:\n$a = \\frac{P_H - P_{L0}}{(D - C_L)^2}$\n\nThese two expressions represent the minimum values for the parameter $a$ for their respective policies to ensure the low-priority task completes by deadline $D$ under the most adversarial, yet compliant, high-priority arrival pattern.", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{P_H - P_{L0}}{D - C_L}  \\frac{P_H - P_{L0}}{(D - C_L)^2} \\end{pmatrix}}$$", "id": "3620577"}, {"introduction": "Moving from abstract theory to practical system tuning, this exercise models a common conflict in modern operating systems: a time-sensitive audio playback process competing with a non-urgent background backup. Your task is to calculate the precise aging rate, $\\alpha$, that balances two competing goals: ensuring the background task makes progress while keeping the risk of audio glitches below a strict threshold. This problem [@problem_id:3620590] demonstrates how aging serves as a crucial control knob for system administrators and developers to manage performance trade-offs in real-world scenarios.", "problem": "A system has two runnable processes: an audio playback process and a background backup process. The scheduler is a preemptive, strict-priority, time-slice scheduler with aging. In each time slice of duration $\\tau$, the scheduler runs the process with the higher effective priority. The audio process has fixed priority $P_{A}$ and is always runnable. The backup process has a base priority $P_{B}$ and ages linearly while waiting: if it does not run in a time slice, its waiting time $w$ increases by $\\tau$, and its effective priority becomes $P_{B} + \\alpha w$. When the backup process runs for one slice, its waiting time resets to $0$, and its effective priority returns to $P_{B}$. This is the operating system aging mechanism intended to address starvation.\n\nAssume the following parameters:\n- Audio fixed priority $P_{A} = 80$.\n- Backup base priority $P_{B} = 53$.\n- Time slice duration $\\tau = 5 \\times 10^{-3}\\ \\text{s}$.\n- Required long-run Central Processing Unit (CPU) share for the backup process $\\epsilon = 0.1$ (as a fraction).\n- Audio underrun tolerance $\\delta = 0.02$ (as a fraction).\n- The audio playback uses a jitter-buffer; each time the audio is preempted by the backup for one time slice, there is an independent probability $\\theta = 0.1$ that the buffer is critically low at that instant. Under this model, the steady-state probability that audio underruns is the product of the probability of a critically low buffer at a preemption instant and the long-run fraction of slices lost to backup, i.e., $\\theta$ times the backup’s CPU share.\n\nStarting from the core definitions of strict-priority time slicing and linear aging, derive the minimal aging rate $\\alpha$ (in priority points per second) that guarantees:\n1. The backup process receives at least $\\epsilon$ fraction of CPU over the long run.\n2. The audio underrun probability is strictly less than $\\delta$.\n\nExpress your final answer as an exact value in priority points per second. Do not include units in the boxed final answer. If your derivation implies a feasibility condition, use the given parameters to verify feasibility explicitly before computing $\\alpha$.", "solution": "We begin from the scheduling and aging definitions. At any time slice, the process with higher effective priority runs. The audio process has fixed priority $P_{A}$ and is always runnable. The backup process’s effective priority at waiting time $w$ is $P_{B} + \\alpha w$. While the backup waits, $w$ increases by $\\tau$ per slice; when it runs for one slice, its waiting time resets to $0$ and its effective priority returns to $P_{B}$.\n\nBecause the audio is always runnable and has fixed priority $P_{A}$, the backup will be scheduled only when its aged priority catches up to or exceeds $P_{A}$. Let $\\Delta P = P_{A} - P_{B}$. The backup’s effective priority grows by $\\alpha \\tau$ per waiting slice. The minimum number of consecutive audio slices before the backup can run one slice is\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil.\n$$\nThe cycle then consists of $k$ audio slices followed by $1$ backup slice, and repeats. Therefore, over the long run, the backup’s CPU share is\n$$\ns_{B} = \\frac{1}{k+1}.\n$$\n\nConstraint 1 (backup share): We require $s_{B} \\geq \\epsilon$. With $s_{B} = 1/(k+1)$ and $k$ an integer, this implies\n$$\n\\frac{1}{k+1} \\geq \\epsilon \\quad \\Longleftrightarrow \\quad k \\leq \\frac{1}{\\epsilon} - 1.\n$$\nSince $k$ is an integer, the strongest allowable bound on $k$ is\n$$\nk \\leq \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor.\n$$\nTo meet this with minimal aging (smallest $\\alpha$ that still guarantees the inequality), we set $k$ to its largest permissible value:\n$$\nk_{\\max} = \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor.\n$$\nWe also have from the definition of $k$ that\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil \\leq k_{\\max}\n\\quad \\Longrightarrow \\quad\n\\frac{\\Delta P}{\\alpha \\tau} \\leq k_{\\max}\n\\quad \\Longrightarrow \\quad\n\\alpha \\geq \\frac{\\Delta P}{\\tau\\, k_{\\max}}.\n$$\nThus, the minimal aging rate that satisfies the backup share requirement is\n$$\n\\alpha_{\\min}^{(\\text{share})} = \\frac{\\Delta P}{\\tau\\, k_{\\max}}.\n$$\n\nConstraint 2 (audio underrun probability): By the given model, the steady-state audio underrun probability is the product of the probability $\\theta$ of the buffer being critically low at a preemption instant and the long-run fraction of slices lost to backup, which is $s_{B}$. Therefore,\n$$\nP_{\\text{underrun}} = \\theta\\, s_{B}.\n$$\nWe require $\\theta\\, s_{B}  \\delta$, i.e.,\n$$\ns_{B}  \\frac{\\delta}{\\theta}.\n$$\nCombining both constraints, feasibility requires there exists an integer $k$ such that\n$$\n\\epsilon \\leq \\frac{1}{k+1}  \\frac{\\delta}{\\theta}.\n$$\nEquivalently,\n$$\n\\epsilon \\leq s_{B}  \\frac{\\delta}{\\theta}.\n$$\nA necessary condition is $\\epsilon \\leq \\delta/\\theta$.\n\nNow substitute the given parameters:\n- $P_{A} = 80, P_{B} = 53 \\Rightarrow \\Delta P = P_{A} - P_{B} = 80 - 53 = 27$.\n- $\\tau = 5 \\times 10^{-3}\\ \\text{s}$.\n- $\\epsilon = 0.1$.\n- $\\delta = 0.02, \\theta = 0.1 \\Rightarrow \\delta/\\theta = 0.02/0.1 = 0.2$.\n\nCheck feasibility:\n$$\n\\epsilon = 0.1 \\leq 0.2 = \\frac{\\delta}{\\theta},\n$$\nso the constraints can be satisfied.\n\nCompute $k_{\\max}$:\n$$\nk_{\\max} = \\left\\lfloor \\frac{1}{\\epsilon} - 1 \\right\\rfloor = \\left\\lfloor 10 - 1 \\right\\rfloor = \\left\\lfloor 9 \\right\\rfloor = 9.\n$$\nHence,\n$$\n\\alpha_{\\min}^{(\\text{share})} = \\frac{\\Delta P}{\\tau\\, k_{\\max}} = \\frac{27}{(5 \\times 10^{-3}) \\cdot 9} = \\frac{27}{45 \\times 10^{-3}} = \\frac{27}{0.045} = 600.\n$$\nWith $\\alpha = 600$, we have\n$$\nk = \\left\\lceil \\frac{\\Delta P}{\\alpha \\tau} \\right\\rceil = \\left\\lceil \\frac{27}{600 \\cdot 5 \\times 10^{-3}} \\right\\rceil = \\left\\lceil \\frac{27}{3} \\right\\rceil = \\left\\lceil 9 \\right\\rceil = 9,\n$$\nso\n$$\ns_{B} = \\frac{1}{k+1} = \\frac{1}{10} = 0.1,\n$$\nmeeting $s_{B} \\geq \\epsilon$. The audio underrun probability is\n$$\nP_{\\text{underrun}} = \\theta\\, s_{B} = 0.1 \\cdot 0.1 = 0.01,\n$$\nwhich is strictly less than $\\delta = 0.02$.\n\nTherefore, the minimal aging rate that simultaneously guarantees the backup’s CPU share and the bound on audio underruns is\n$$\n\\alpha = 600 \\ \\text{priority points per second}.\n$$", "answer": "$$\\boxed{600}$$", "id": "3620590"}, {"introduction": "While theoretical analysis is essential, seeing a concept in action provides undeniable clarity. This practice involves building a simple, deterministic microbenchmark to simulate and directly observe the effects of priority scheduling. You will first create a workload that reliably induces starvation under a strict priority scheme and then implement an aging mechanism to watch fairness be restored [@problem_id:3620521]. This hands-on coding exercise solidifies the connection between scheduling theory and its practical implementation, demonstrating how a few lines of code can cure one of the classic problems in concurrency.", "problem": "You are asked to implement a deterministic, self-contained microbenchmark that simulates central processing unit scheduling to examine starvation under strict priority scheduling and its disappearance under priority aging. The objective is to encode two schedulers in a single program: one that uses strict static priorities and another that uses priority aging, then to compare observable starvation within a fixed-length simulation using reproducible parameters. The program must produce a single line output that aggregates the results for a small test suite.\n\nFundamental base for derivation and design: The definitions are as follows. A process is characterized by a static priority $p_i \\in \\mathbb{R}$ and a required burst length $b_i \\in \\mathbb{N}$ measured in discrete time ticks. Strict priority scheduling selects at each decision point the ready process with the highest static priority $p_i$; in case of equal priority, round robin with a fixed quantum is applied. Starvation is the indefinite postponement of service, formalized here as a process that receives zero service during a finite horizon $T$ despite being ready at time $0$. Priority aging defines an effective priority $e_i(t)$ as $e_i(t) = p_i + \\alpha w_i(t)$, where $w_i(t)$ is the accumulated waiting time of process $i$ measured in ticks, and $\\alpha \\ge 0$ is the aging rate. The scheduler chooses at each tick the process with maximal $e_i(t)$ (ties are broken deterministically). With aging, a lower-priority process eventually attains higher effective priority after waiting sufficiently long, which can be derived from $p_i + \\alpha w_i(t) > p_0$, where $p_0$ is the highest static priority. This inequality implies that starvation disappears for any $\\alpha > 0$ if the simulation horizon $T$ permits $w_i(t)$ to exceed $(p_0 - p_i)/\\alpha$ for all $i$.\n\nWorkload and simulation rules:\n- There are $n$ processes, indexed $i \\in \\{0,1,\\dots,n-1\\}$, all arriving at time $0$.\n- Static priorities are $p_i = n - i$, so process $i=0$ has the highest static priority $p_0 = n$.\n- Burst lengths are $b_0 = 10^9$ ticks and $b_i = 10$ ticks for all $i \\ge 1$. This ensures that under strict priority the highest-priority process remains ready throughout the horizon used here.\n- The simulation horizon is fixed to $T = 200$ ticks. Time is discretized; one tick is the unit of simulated time. There are no physical units beyond ticks.\n- There is a time quantum $q \\in \\mathbb{N}$. Under strict priority, the currently running process is permitted to run up to $q$ ticks, and then a scheduling decision is made. Because $p_0$ remains the maximal static priority and it is always ready, strict priority will reselect process $0$ in every decision unless a tie exists. Under aging, at every tick the scheduler computes effective priorities $e_i(t) = p_i + \\alpha w_i(t)$, increments $w_i(t)$ for all ready and not-running processes, and then either continues the current process if its effective priority remains maximal and the quantum has not expired, or preempts to the process with maximal effective priority, resetting the quantum to $q$. Ties are broken deterministically by selecting the lowest index.\n\nStarvation detection and fairness metric:\n- A process is considered starved within the horizon if its total served ticks is $0$ at time $T$.\n- For the aging scheduler, define the first-response time $f_i$ as the earliest tick at which process $i$ receives its first unit of service, or $-1$ if it receives none by time $T$. The fairness metric reported is the maximum first-response time over all lower-priority processes, $\\max_{i \\ge 1} f_i$, with the convention that if any $f_i = -1$ then the metric value is $-1$.\n\nYour program must implement both schedulers, execute them on each test case, and report:\n- For each test case, a list `[S_strict, S_aging, F_aging]`, where $S_{\\text{strict}} \\in \\{0,1\\}$ indicates starvation under strict priority on the given horizon, $S_{\\text{aging}} \\in \\{0,1\\}$ indicates starvation under aging with the given $\\alpha$ on the same horizon, and $F_{\\text{aging}} \\in \\mathbb{Z}$ is the fairness metric described above.\n\nTest suite:\n- Test case $1$: $(n,q,\\alpha) = (3,5,0.1)$.\n- Test case $2$ (boundary condition): $(n,q,\\alpha) = (3,5,0)$.\n- Test case $3$ (edge condition combining small quantum and many processes): $(n,q,\\alpha) = (10,1,0.05)$.\n\nOutput format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s list enclosed in square brackets in the same order as above. For example, the output must look like `[[S_strict,1,F_aging,1],[S_strict,2,F_aging,2],[S_strict,3,F_aging,3]]` with integers in place of symbols and no spaces.", "solution": "The user has requested the implementation of a microbenchmark to compare strict priority scheduling with priority aging, focusing on the phenomenon of starvation. The problem is well-defined and grounded in established computer science principles, making it a valid task. This solution will proceed by first outlining the theoretical and algorithmic design, and then providing a concrete implementation.\n\n### Principle-Based Design\n\nThe simulation adheres to the provided definitions of processes, scheduling policies, and metrics. A process $i$ is defined by its static priority $p_i$ and burst length $b_i$. The simulation runs for a finite horizon of $T=200$ discrete time ticks. All $n$ processes are assumed to arrive at time $t=0$ and are immediately ready to run.\n\n**Process State Representation**\n\nTo conduct the simulation, the state of each process $i$ must be tracked over time. The necessary state variables are:\n- A unique identifier, $i \\in \\{0, 1, \\dots, n-1\\}$.\n- Static priority, $p_i = n - i$.\n- Remaining burst length, $b_i(t)$, initialized to $b_0=10^9$ or $b_i=10$ for $i \\ge 1$.\n- Accumulated wait time, $w_i(t)$, initialized to $0$. This is the total number of ticks the process has been in the ready state but not running.\n- Total time served, initialized to $0$.\n- First-response time, $f_i$, initialized to $-1$. This is the simulation tick $t$ at which the process is first executed.\n\n**Simulation Loop**\n\nThe core of the program is a discrete-time simulation loop that iterates from $t=0$ to $t=T-1$. In each tick, the state of all processes and the scheduler are updated according to the rules of the selected scheduling policy.\n\n**1. Strict Priority Scheduler**\n\nUnder strict priority scheduling, the process with the highest static priority $p_i$ is always selected from the set of ready processes.\n- **Process Selection**: According to the problem, $p_i = n - i$, which means process $0$ has the highest static priority $p_0=n$. Since its burst length $b_0=10^9$ is far greater than the simulation horizon $T=200$, process $0$ will always be ready. Consequently, the scheduler will select process $0$ at every decision point.\n- **Quantum**: A time quantum $q$ is specified. The running process is re-evaluated after $q$ ticks. However, since process $0$ remains the highest-priority ready process, it will be immediately re-selected. Thus, process $0$ runs uninterrupted for the entire duration $T$.\n- **Simulation Logic**: For each tick $t \\in [0, T-1]$, process $0$ is executed. Its `served_time` is incremented, and its `burst_remaining` is decremented. For all other processes $i \\in \\{1, \\dots, n-1\\}$, their `wait_time` is incremented.\n- **Starvation**: As a direct consequence, processes $i \\ge 1$ never receive any CPU time. Their final `served_time` is $0$. Therefore, for all test cases, starvation is observed, and the starvation indicator $S_{\\text{strict}}$ is $1$.\n\n**2. Priority Aging Scheduler**\n\nThis scheduler is preemptive and uses a dynamic effective priority, $e_i(t)$, to prevent starvation.\n- **Effective Priority**: At any time $t$, the effective priority of process $i$ is calculated as $e_i(t) = p_i + \\alpha w_i(t)$, where $\\alpha$ is the aging rate.\n- **Scheduling Decision**: The logic is executed at the beginning of each tick $t$:\n    1.  **Update Wait Times**: For every process $j$ that was ready but not running during the previous tick ($t-1$), its wait time $w_j(t)$ is incremented.\n    2.  **Identify Best Process**: The effective priorities $e_j(t)$ are calculated for all ready processes. The process with the maximum effective priority is identified. Ties are broken by selecting the process with the lowest index $i$.\n    3.  **Preemption Check**: The scheduler checks if preemption is necessary. Preemption occurs if:\n        a. The CPU was idle.\n        b. The process that ran at $t-1$ has exhausted its time quantum $q$.\n        c. The newly identified best process is different from the one that ran at $t-1$.\n    4.  **Execution**: The selected process runs for tick $t$. Its state is updated (`burst_remaining` decremented, `served_time` incremented). If it is the process's first time running, its first-response time $f_i$ is recorded as $t$.\n    5.  **State Update**: The scheduler's state (current running process, ticks run continuously) is updated for the next cycle.\n\nWith $\\alpha > 0$, the $w_i(t)$ term ensures that a waiting process's effective priority continually increases. Eventually, $e_i(t)$ for a low-priority process $i$ will surpass the priorities of the higher-priority processes, guaranteeing it will eventually be scheduled. For $\\alpha=0$, this mechanism is disabled, and the scheduler behaves identically to the strict priority scheduler.\n\n### Metric Calculation\n\nAfter each simulation completes at $t=T$:\n- **Starvation ($S$)**: The metric $S$ is set to $1$ if there exists any process $i \\in \\{1, ..., n-1\\}$ for which the total `served_time` is $0$. Otherwise, $S=0$.\n- **Fairness Metric ($F_{\\text{aging}}$)**: This metric is the maximum first-response time among all lower-priority processes, $F_{\\text{aging}} = \\max_{i \\ge 1} f_i$. If any process $i \\ge 1$ never runs (i.e., its $f_i = -1$), then $F_{\\text{aging}}$ is defined to be $-1$.\n\nThe program implements this logic for each test case and aggregates the results into the specified output format.", "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Maximum number of processes for static allocation\n#define MAX_PROCESSES 10\n#define SIMULATION_HORIZON 200\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int n;\n    int q;\n    double alpha;\n} TestCase;\n\n// A struct to hold the state of a single process during simulation.\ntypedef struct {\n    int id;\n    double static_priority;\n    long long burst_remaining;\n    int wait_time;\n    int served_time;\n    int first_response_time;\n} Process;\n\n// A struct to hold the results of a simulation run.\ntypedef struct {\n    int starvation_occurs;\n    int max_first_response_time;\n} SimResult;\n\n// Function to run a single simulation.\nSimResult run_simulation(const TestCase* tc, int use_aging) {\n    Process processes[MAX_PROCESSES];\n    const long long b0 = 1000000000;\n    const long long bi = 10;\n\n    // Initialize processes for the simulation\n    for (int i = 0; i  tc-n; ++i) {\n        processes[i].id = i;\n        processes[i].static_priority = (double)(tc-n - i);\n        processes[i].burst_remaining = (i == 0) ? b0 : bi;\n        processes[i].wait_time = 0;\n        processes[i].served_time = 0;\n        processes[i].first_response_time = -1;\n    }\n\n    int current_runner_id = -1;\n    int ticks_ran_continuously = 0;\n\n    for (int t = 0; t  SIMULATION_HORIZON; ++t) {\n        // --- Scheduler Logic for Tick t ---\n        \n        // 1. Update wait times for non-running processes based on previous tick's runner\n        for (int i = 0; i  tc-n; ++i) {\n            if (processes[i].burst_remaining  0  i != current_runner_id) {\n                processes[i].wait_time++;\n            }\n        }\n        \n        int new_runner_id = -1;\n        int preemption = 0;\n\n        if (!use_aging) {\n            // Strict Priority Scheduler Logic\n            // Process 0 always has the highest static priority and is always ready.\n            new_runner_id = 0;\n        } else {\n            // Priority Aging Scheduler Logic\n            // 2. Find the process with the highest effective priority\n            int best_id = -1;\n            double max_eff_priority = -1.0 / 0.0; // Negative infinity\n\n            for (int i = 0; i  tc-n; ++i) {\n                if (processes[i].burst_remaining  0) {\n                    double eff_p = processes[i].static_priority + tc-alpha * processes[i].wait_time;\n                    if (eff_p  max_eff_priority) {\n                        max_eff_priority = eff_p;\n                        best_id = i;\n                    }\n                }\n            }\n\n            // 3. Preemption check and runner selection\n            if (current_runner_id == -1 || \n                (ticks_ran_continuously = tc-q  tc-q  0) || \n                (best_id != current_runner_id)) {\n                new_runner_id = best_id;\n                preemption = 1;\n            } else {\n                new_runner_id = current_runner_id;\n            }\n        }\n\n        // 4. Execute the chosen process for one tick\n        if (new_runner_id != -1) {\n            if (processes[new_runner_id].first_response_time == -1) {\n                processes[new_runner_id].first_response_time = t;\n            }\n            processes[new_runner_id].served_time++;\n            processes[new_runner_id].burst_remaining--;\n        }\n\n        // 5. Update scheduler state for the next tick\n        if (new_runner_id != current_runner_id) { // This condition implies preemption\n            ticks_ran_continuously = 1;\n        } else if (new_runner_id != -1) {\n            ticks_ran_continuously++;\n        } else {\n            ticks_ran_continuously = 0;\n        }\n        current_runner_id = new_runner_id;\n    }\n\n    // --- After simulation, calculate results ---\n    SimResult result;\n    result.starvation_occurs = 0;\n    result.max_first_response_time = 0;\n    int any_fr_is_neg_one = 0;\n\n    for (int i = 1; i  tc-n; ++i) {\n        if (processes[i].served_time == 0) {\n            result.starvation_occurs = 1;\n        }\n        if (processes[i].first_response_time == -1) {\n            any_fr_is_neg_one = 1;\n        }\n        if (processes[i].first_response_time  result.max_first_response_time) {\n            result.max_first_response_time = processes[i].first_response_time;\n        }\n    }\n    \n    if (any_fr_is_neg_one) {\n        result.max_first_response_time = -1;\n    }\n\n    return result;\n}\n\nint main(void) {\n    TestCase test_cases[] = {\n        {3, 5, 0.1},\n        {3, 5, 0.0},\n        {10, 1, 0.05}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int combined_results[num_cases][3];\n\n    for (int i = 0; i  num_cases; ++i) {\n        SimResult strict_res = run_simulation(test_cases[i], 0);\n        SimResult aging_res = run_simulation(test_cases[i], 1);\n        \n        combined_results[i][0] = strict_res.starvation_occurs;\n        combined_results[i][1] = aging_res.starvation_occurs;\n        combined_results[i][2] = aging_res.max_first_response_time;\n    }\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"[%d,%d,%d]\", combined_results[i][0], combined_results[i][1], combined_results[i][2]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3620521"}]}