{"hands_on_practices": [{"introduction": "Understanding contiguous allocation requires more than just knowing the definitions; it demands a feel for the dynamic nature of the heap. This practice provides a hands-on simulation of a memory allocator, where you will trace a sequence of allocation and free requests. By manually managing block sizes, splitting free blocks, and coalescing them upon deallocation, you will gain a concrete understanding of the core mechanics that underpin dynamic memory management [@problem_id:3627997].", "problem": "Consider a contiguous heap segment managed by a dynamic memory allocator with boundary tags (headers and footers) that enable constant-time coalescing of adjacent free blocks. The allocator maintains an explicit doubly linked free list in physical address order and uses First-Fit (FF) placement. Each block has a header and footer of size $8$ bytes each. All block sizes (including headers, footers, and payload) are multiples of $16$ bytes, and the minimum free block size that can exist in the heap is $32$ bytes. When allocating a request of $r$ bytes, the allocator rounds the payload up to the next multiple of $16$ bytes and then adds $16$ bytes of header and footer overhead to form the block size. Splitting occurs only if the remainder after placement is at least $32$ bytes; otherwise, the entire free block is consumed to satisfy the request. When a block is freed, immediate coalescing merges it with any physically adjacent free neighbor(s) using boundary tags.\n\nThe heap begins with a single free block of size $992$ bytes between a prologue and an epilogue (the prologue and epilogue are outside the managed region and do not affect sizes). The following sequence of operations is performed, in order:\n\n- Allocate $200$ bytes for block $A$.\n- Allocate $120$ bytes for block $B$.\n- Allocate $300$ bytes for block $C$.\n- Free block $B$.\n- Allocate $80$ bytes for block $D$.\n- Allocate $50$ bytes for block $E$.\n- Free block $C$.\n- Free block $A$.\n- Free block $E$.\n\nUsing only the rules stated above and starting from the core definitions of contiguous allocation, boundary tags, First-Fit, alignment, and minimum block size, determine the size (in bytes) of the largest free block present in the heap after the final operation. Express your final answer in bytes as an exact integer value. No rounding is required.", "solution": "Let's trace the state of the heap step-by-step. The required block size for a request of $r$ bytes is calculated by rounding $r$ up to the next multiple of 16, then adding 16 bytes for the header and footer.\n\n**Initial State:**\n- Heap: `[ Free(size=992) ]`\n- Free List: `[ (size=992) ]`\n\n**1. Allocate $A$ (200 bytes):**\n- Required size: `ceil(200/16)*16 + 16 = 13*16 + 16 = 208 + 16 = 224` bytes.\n- Place in the `992`-byte block. Remainder: `992 - 224 = 768`. Since `768 >= 32`, we split.\n- Heap: `[ A(alloc, 224) | Free(768) ]`\n\n**2. Allocate $B$ (120 bytes):**\n- Required size: `ceil(120/16)*16 + 16 = 8*16 + 16 = 128 + 16 = 144` bytes.\n- Place in the `768`-byte block. Remainder: `768 - 144 = 624`. Since `624 >= 32`, we split.\n- Heap: `[ A(224) | B(alloc, 144) | Free(624) ]`\n\n**3. Allocate $C$ (300 bytes):**\n- Required size: `ceil(300/16)*16 + 16 = 19*16 + 16 = 304 + 16 = 320` bytes.\n- Place in the `624`-byte block. Remainder: `624 - 320 = 304`. Since `304 >= 32`, we split.\n- Heap: `[ A(224) | B(144) | C(alloc, 320) | Free(304) ]`\n\n**4. Free block $B$:**\n- Block B (size 144) is freed. Its neighbors ($A$ and $C$) are allocated, so no coalescing occurs.\n- Heap: `[ A(224) | Free(144) | C(320) | Free(304) ]`\n- Free List (address-ordered): `[ (size=144), (size=304) ]`\n\n**5. Allocate $D$ (80 bytes):**\n- Required size: `ceil(80/16)*16 + 16 = 5*16 + 16 = 80 + 16 = 96` bytes.\n- First-Fit finds the `144`-byte block. Remainder: `144 - 96 = 48`. Since `48 >= 32`, we split.\n- Heap: `[ A(224) | D(alloc, 96) | Free(48) | C(320) | Free(304) ]`\n- Free List: `[ (size=48), (size=304) ]`\n\n**6. Allocate $E$ (50 bytes):**\n- Required size: `ceil(50/16)*16 + 16 = 4*16 + 16 = 64 + 16 = 80` bytes.\n- First-Fit checks the `48`-byte block (too small) then finds the `304`-byte block. Remainder: `304 - 80 = 224`. Since `224 >= 32`, we split.\n- Heap: `[ A | D | Free(48) | C | E(alloc, 80) | Free(224) ]`\n- Free List: `[ (size=48), (size=224) ]`\n\n**7. Free block $C$:**\n- Block C (size 320) is freed. Its preceding neighbor is `Free(48)`. Its succeeding neighbor is `E(alloc)`. Coalesce with the left neighbor.\n- New free block size: `48 + 320 = 368` bytes.\n- Heap: `[ A | D | Free(368) | E | Free(224) ]`\n- Free List: `[ (size=368), (size=224) ]`\n\n**8. Free block $A$:**\n- Block A (size 224) is freed. Its succeeding neighbor `D` is allocated. No coalescing.\n- Heap: `[ Free(224) | D | Free(368) | E | Free(224) ]`\n- Free List: `[ (size=224), (size=368), (size=224) ]`\n\n**9. Free block $E$:**\n- Block E (size 80) is freed. Its preceding neighbor is `Free(368)` and its succeeding neighbor is `Free(224)`.\n- A three-way coalesce occurs, merging the three contiguous free regions.\n- New free block size: `368 + 80 + 224 = 672` bytes.\n- Final Heap State: `[ Free(224) | D(alloc, 96) | Free(672) ]`\n- Final Free List: `[ (size=224), (size=672) ]`\n\nAfter all operations, the free blocks have sizes of 224 bytes and 672 bytes. The largest of these is 672 bytes.", "answer": "$$\\boxed{672}$$", "id": "3627997"}, {"introduction": "The choice of an allocation policy, such as best-fit or worst-fit, is not just an academic detail; it has profound effects on memory fragmentation. This exercise challenges you to think like an adversary and analyze how a specific sequence of requests can stress-test these policies. You will see firsthand how best-fit's tendency to create small, unusable holes can sometimes be less effective than worst-fit's approach of preserving a range of hole sizes [@problem_id:3628008].", "problem": "Consider contiguous memory allocation in an Operating System (OS) with policy-dependent hole selection. In contiguous allocation, each request must be placed into a single contiguous free region (hole), and allocating a request from a hole of size $h$ splits that hole into an allocated block of size equal to the request and a leftover hole of size $h$ minus the request size. Deallocation of a block returns a hole at the exact location of that block and coalesces only with immediately adjacent free regions. Under the best-fit policy, the allocator chooses the smallest hole whose size is at least the request size; under the worst-fit policy, the allocator chooses the largest available hole.\n\nStart with a single free memory region (hole) of size $64$. Perform the following initialization (these allocations all occur into the single large hole, in order, so their physical positions are consecutive, and the remaining free region stays at the high end of memory after each step):\n- Allocate block $A$ of size $10$.\n- Allocate block $B$ of size $18$.\n- Allocate block $C$ of size $12$.\n- Allocate block $D$ of size $8$.\n- Free blocks $A$ and $C$.\n\nAfter these steps, the free holes are the three nonadjacent regions of sizes $10$, $12$, and $16$, separated by the still-allocated $B$ and $D$, so no coalescing can occur among these holes at this point.\n\nNow, consider the following four candidate sequences of three subsequent allocation requests, each applied to the current set of holes $\\{10,12,16\\}$ under the best-fit and worst-fit policies:\n\n- A. Allocate $X=9$, then $Y=11$, then $Z=10$.\n\n- B. Allocate $X=9$, then $Y=9$, then $Z=9$.\n\n- C. Allocate $X=15$, then $Y=1$, then $Z=1$.\n\n- D. Allocate $X=5$, then $Y=5$, then $Z=5$.\n\nWhich option constructs an adversarial request sequence of varying sizes that maximizes external fragmentation for best-fit but not for worst-fit at the end of the three allocations, in the sense that the final hole-size distribution leaves a strictly smaller largest free hole (relative to total free memory) under best-fit than under worst-fit? Select the single best option and justify based on how the hole-size distribution evolves under each policy.", "solution": "The initial set of free holes is $\\{10, 12, 16\\}$. We will trace the allocation for each candidate sequence under both Best-Fit (BF) and Worst-Fit (WF) policies to find the one where the largest final hole under BF is strictly smaller than under WF.\n\n**A. Requests: $9, 11, 10$**\n-   **Best-Fit:**\n    1.  Request $9$ fits best in hole $10$, leaving holes $\\{1, 12, 16\\}$.\n    2.  Request $11$ fits best in hole $12$, leaving holes $\\{1, 1, 16\\}$.\n    3.  Request $10$ fits best in hole $16$, leaving holes $\\{1, 1, 6\\}$.\n    *Largest final hole: $6$.*\n-   **Worst-Fit:**\n    1.  Request $9$ fits worst in hole $16$, leaving holes $\\{10, 12, 7\\}$.\n    2.  Request $11$ fits worst in hole $12$, leaving holes $\\{10, 1, 7\\}$.\n    3.  Request $10$ fits worst in hole $10$, leaving holes $\\{0, 1, 7\\}$, which simplifies to $\\{1, 7\\}$.\n    *Largest final hole: $7$.*\n-   *Result: $6  7$. This sequence satisfies the condition.*\n\n**B. Requests: $9, 9, 9$**\n-   **Best-Fit:**\n    1.  Request $9$ from hole $10 \\to \\{1, 12, 16\\}$.\n    2.  Request $9$ from hole $12 \\to \\{1, 3, 16\\}$.\n    3.  Request $9$ from hole $16 \\to \\{1, 3, 7\\}$.\n    *Largest final hole: $7$.*\n-   **Worst-Fit:**\n    1.  Request $9$ from hole $16 \\to \\{10, 12, 7\\}$.\n    2.  Request $9$ from hole $12 \\to \\{10, 3, 7\\}$.\n    3.  Request $9$ from hole $10 \\to \\{1, 3, 7\\}$.\n    *Largest final hole: $7$.*\n-   *Result: $7 = 7$. This sequence does not satisfy the condition.*\n\n**C. Requests: $15, 1, 1$**\n-   **Best-Fit:**\n    1.  Request $15$ from hole $16 \\to \\{10, 12, 1\\}$.\n    2.  Request $1$ from hole $1 \\to \\{10, 12\\}$.\n    3.  Request $1$ from hole $10 \\to \\{9, 12\\}$.\n    *Largest final hole: $12$.*\n-   **Worst-Fit:**\n    1.  Request $15$ from hole $16 \\to \\{10, 12, 1\\}$.\n    2.  Request $1$ from hole $12 \\to \\{10, 11, 1\\}$.\n    3.  Request $1$ from hole $11 \\to \\{10, 10, 1\\}$.\n    *Largest final hole: $10$.*\n-   *Result: $12 > 10$. This sequence does not satisfy the condition.*\n\n**D. Requests: $5, 5, 5$**\n-   **Best-Fit:**\n    1.  Request $5$ from hole $10 \\to \\{5, 12, 16\\}$.\n    2.  Request $5$ from hole $5 \\to \\{12, 16\\}$.\n    3.  Request $5$ from hole $12 \\to \\{7, 16\\}$.\n    *Largest final hole: $16$.*\n-   **Worst-Fit:**\n    1.  Request $5$ from hole $16 \\to \\{10, 12, 11\\}$.\n    2.  Request $5$ from hole $12 \\to \\{10, 7, 11\\}$.\n    3.  Request $5$ from hole $11 \\to \\{10, 7, 6\\}$.\n    *Largest final hole: $10$.*\n-   *Result: $16 > 10$. This sequence does not satisfy the condition.*\n\nOnly sequence A results in a state where Best-Fit performs \"worse\" than Worst-Fit according to the problem's metric (a smaller largest remaining hole). This is a classic example of an adversarial sequence for Best-Fit, where its tendency to make tight fits consumes well-sized smaller holes, leading to poorer overall fragmentation compared to Worst-Fit in this specific scenario.", "answer": "$$\\boxed{A}$$", "id": "3628008"}, {"introduction": "Effective allocator design involves navigating subtle trade-offs, where even minor rules can have major consequences. This problem focuses on the seemingly small detail of a tie-breaking rule: what should an allocator do when multiple free blocks are equally suitable for a request? By tracing the outcome of choosing the earliest versus the latest block, you will discover how this single choice can dramatically alter the potential for future memory coalescing and determine whether large subsequent requests succeed or fail [@problem_id:3627962].", "problem": "An Operating System (OS) implements contiguous allocation in a single linear Random Access Memory (RAM) region with addresses from $0$ to $300$ (units). The allocator uses coalescing: whenever two adjacent free blocks touch, they merge immediately into one free block. Requests must be satisfied by a single contiguous block; an exact-fit incurs no splitting because the free block size equals the request.\n\nInitially, the memory layout is:\n- Allocated: $[0,60)$ of size $60$ (process $P_A$).\n- Free: $[60,80)$ of size $20$ (block $F_1$).\n- Allocated: $[80,120)$ of size $40$ (process $P_B$).\n- Free: $[120,150)$ of size $30$ (block $F_2$).\n- Allocated: $[150,200)$ of size $50$ (process $P_C$).\n- Free: $[200,230)$ of size $30$ (block $F_3$).\n- Allocated: $[230,300)$ of size $70$ (process $P_D$).\n\nA request $R_1$ arrives for size $30$, which exactly matches two free blocks: $F_2$ at $[120,150)$ and $F_3$ at $[200,230)$. The allocatorâ€™s policy for exact-fits is to choose among equal-size matches by a tie-break rule: either the earliest starting address or the latest starting address.\n\nAfter $R_1$ is allocated by one of these tie-break rules, the OS frees $P_B$ and $P_C$ (so $[80,120)$ and $[150,200)$ become free and immediately coalesce with any adjacent free blocks), and then a request $R_2$ arrives for size $100$.\n\nUsing only the foundational definitions of contiguous allocation and coalescing on adjacent free blocks, and the standard notion of external fragmentation (total free space may be sufficient but is unusable if no single free block is large enough for the request), determine how the tie-break choice for $R_1$ affects the ability to satisfy $R_2$ and the resulting fragmentation. Which statement is correct?\n\nA. Allocating $R_1$ to the earliest matching free block $F_2$ prevents later coalescing across $[120,200)$, yielding a largest free block of size $80$ so $R_2$ of size $100$ fails; allocating $R_1$ to the latest matching free block $F_3$ preserves coalescing across $[60,200)$, yielding a largest free block of size $140$ so $R_2$ succeeds.\n\nB. The tie-break has no effect; in both cases the largest free block after freeing $P_B$ and $P_C$ is at least $100$, so $R_2$ succeeds regardless of the choice.\n\nC. Allocating $R_1$ to the earliest matching free block $F_2$ yields better coalescing, producing a largest free block of size $150$, whereas allocating $R_1$ to the latest matching free block $F_3$ leaves only $80$, so $R_2$ fails with the latest choice.\n\nD. Allocating $R_1$ to the latest matching free block $F_3$ reduces the number of free blocks but not the largest free block size; in both cases $R_2$ fails because the largest free block remains below $100$.", "solution": "The problem requires analyzing two scenarios based on the tie-break rule for allocating request $R_1$ (size 30), which has two exact-fit options: $F_2$ at `[120, 150)` and $F_3$ at `[200, 230)`.\n\n**Scenario 1: Allocate $R_1$ to the earliest address ($F_2$)**\n\n1.  **Allocate $R_1$:** The block `[120, 150)` is allocated to $R_1$. This block now acts as a barrier separating the regions around it.\n2.  **Free $P_B$ and $P_C$:** The regions `[80, 120)` and `[150, 200)` are freed. Immediate coalescing is applied.\n    -   The newly freed `[80, 120)` is adjacent to the free block $F_1$ (`[60, 80)`). They merge to form a single free block: `[60, 120)` of size $20 + 40 = 60$.\n    -   The newly freed `[150, 200)` is adjacent to the free block $F_3$ (`[200, 230)`). They merge to form a single free block: `[150, 230)` of size $50 + 30 = 80$.\n    -   The allocated block for $R_1$ at `[120, 150)` prevents these two new free blocks from merging.\n3.  **Check $R_2$:** The final free blocks are of sizes $60$ and $80$. The largest free block is $80$. A request for $R_2$ of size $100$ will **fail**.\n\n**Scenario 2: Allocate $R_1$ to the latest address ($F_3$)**\n\n1.  **Allocate $R_1$:** The block `[200, 230)` is allocated to $R_1$.\n2.  **Free $P_B$ and $P_C$:** The regions `[80, 120)` and `[150, 200)` are freed.\n    -   The memory from address $60$ to $200$ now contains a series of contiguous free blocks: the original $F_1$ (`[60, 80)`), the freed $P_B$ (`[80, 120)`), the original $F_2$ (`[120, 150)`), and the freed $P_C$ (`[150, 200)`).\n    -   These four blocks all coalesce into a single, large free block spanning `[60, 200)`.\n    -   Its total size is $20 + 40 + 30 + 50 = 140$.\n3.  **Check $R_2$:** The largest (and only) free block in this area is of size $140$. A request for $R_2$ of size $100$ will **succeed**.\n\n**Conclusion:**\n- The \"earliest address\" choice for $R_1$ leads to fragmentation, creating a largest free block of size $80$ and causing $R_2$ to fail.\n- The \"latest address\" choice for $R_1$ preserves contiguity, creating a single large block of size $140$ and allowing $R_2$ to succeed.\n\nThis analysis matches the claims made in option A. The other options are inconsistent with this result.", "answer": "$$\\boxed{A}$$", "id": "3627962"}]}