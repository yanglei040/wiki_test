{"hands_on_practices": [{"introduction": "Understanding the theoretical differences between memory allocation policies is one thing, but seeing them in action is another. This exercise challenges you to trace the behavior of two fundamental search strategies, first-fit and next-fit, through a specific sequence of memory allocations and deallocations. By meticulously tracking the state of the free list and, in the case of next-fit, the position of the `rover` pointer, you will discover how these seemingly similar policies can lead to dramatically different memory layouts and levels of fragmentation [@problem_id:3653441]. This practice is essential for developing a concrete, operational understanding of allocator behavior.", "problem": "Consider an explicit free-list allocator managing a contiguous heap. The free list is a singly linked list maintained in strictly increasing address order. The allocator uses immediate coalescing with both the left and right neighbors on free, and it splits a free block on allocation if and only if the remainder is at least a minimum block size threshold $m$ (a positive constant that models header/footer and minimum payload requirements). All block sizes stated below already include any allocator metadata; they are the exact sizes taken from or returned to the free list. All sizes are multiples of a fixed word size, and requests never violate alignment. The allocator uses one of two search policies on the free list: first-fit or next-fit. First-fit always starts scanning from the head. Next-fit maintains a rover that resumes from the node where the previous search terminated (wrapping around to the head when needed); the initial rover position before any allocation is at the head; after a successful allocation from a free block that is split, the rover is set to the remainder block; if no remainder exists, the rover points to the successor of the consumed block in the free list.\n\nAssume the heap initially consists of a single free block of size $12n$ bytes, beginning at address $0$ and ending at address $12n$. Consider the following trace of operations, where each $\\mathrm{malloc}$ request is for a block whose size is exactly as stated and each $\\mathrm{free}$ releases exactly the block previously allocated by the named operation. The operations are:\n\n- Operation $1$: $\\mathrm{malloc}(3n)$ producing block $B_1$.\n- Operation $2$: $\\mathrm{malloc}(4n)$ producing block $B_2$.\n- Operation $3$: $\\mathrm{malloc}(2n)$ producing block $B_3$.\n- Operation $4$: $\\mathrm{free}(B_2)$.\n- Operation $5$: $\\mathrm{malloc}(3n)$ producing block $B_4$.\n- Operation $6$: $\\mathrm{free}(B_1)$.\n- Operation $7$: $\\mathrm{free}(B_3)$.\n\nYou are told that after Operation $7$, the observed free list (remember, it is in increasing address order) contains exactly two free blocks: the first of size $3n$, followed in address order by a second of size $6n$.\n\nWhich statement below is correct under the allocator model just described? Your answer should identify which policy or policies can produce the observed free list shape from the trace, whether the identification is unique given the stated next-fit rover semantics, and the necessary and sufficient condition(s) on $n$ (in relation to $m$) for the observation to be realizable.\n\nA. Both first-fit and next-fit can produce the observed final free list for all $n$ satisfying $n \\ge m$; therefore, the allocation policy is not uniquely identifiable from the observation.\n\nB. Only first-fit can produce the observed final free list, and it does so if and only if $n \\ge m$; under the stated next-fit rover semantics, this identification is unique because next-fit cannot produce the observation.\n\nC. Only next-fit can produce the observed final free list for any $n$; first-fit cannot.\n\nD. Neither policy can produce the observed final free list for any $n$; the observation contradicts the allocator model regardless of $n$.", "solution": "The problem statement is a well-posed and self-contained exercise in computational systems, specifically concerning the behavior of dynamic memory allocators. It is scientifically grounded in established computer science principles, and its terms are defined with sufficient precision to permit a formal analysis. The problem is therefore valid.\n\nLet us denote a block of memory by a tuple `[address, size]`. A list of such tuples enclosed in parentheses, e.g., `(...)`, will represent the free list, which is maintained in increasing address order.\n\nThe initial state of the heap is a single free block of size $12n$ at address $0$.\nInitial Heap: `[0, 12n]`\nInitial Free List (FL): `( [0, 12n] )`\n\nWe will now trace the sequence of operations for each of the two policies, First-Fit (FF) and Next-Fit (NF).\n\n### Analysis of the First-Fit (FF) Policy\n\nThe FF policy always begins its search for a suitable free block at the head of the free list.\n\n**Initial State:** FL = `( [0, 12n] )`.\n\n**Operation 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nFF finds the block `[0, 12n]`. The remainder is $12n - 3n = 9n$. Assuming a split occurs (which requires $9n \\ge m$), block $B_1$ is allocated at `[0, 3n]`.\nState: FL = `( [3n, 9n] )`. $B_1$ is `[0, 3n]`.\n\n**Operation 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nFF finds the block `[3n, 9n]`. The remainder is $9n - 4n = 5n$. Assuming a split occurs (requires $5n \\ge m$), block $B_2$ is allocated at `[3n, 4n]`.\nState: FL = `( [7n, 5n] )`. $B_2$ is `[3n, 4n]`.\n\n**Operation 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nFF finds the block `[7n, 5n]`. The remainder is $5n - 2n = 3n$. Assuming a split occurs (requires $3n \\ge m$), block $B_3$ is allocated at `[7n, 2n]`.\nState: FL = `( [9n, 3n] )`. $B_3$ is `[7n, 2n]`.\n\n**Operation 4: `\\mathrm{free}(B_2)`**\n$B_2$ at `[3n, 4n]` is freed. Its left neighbor (`B_1` at `[0, 3n]`) and right neighbor (`B_3` at `[7n, 2n]`) are both allocated. Thus, no coalescing occurs. The new free block is inserted into the free list in address order.\nState: FL = `( [3n, 4n], [9n, 3n] )`.\n\n**Operation 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nFF starts at the head of the FL, `[3n, 4n]`. This block is large enough. The remainder is $4n - 3n = n$. The `if and only if` splitting rule is critical here.\n*   **Case 1: $n \\ge m$.** The split occurs. $B_4$ is allocated at `[3n, 3n]`. A new free block, the remainder `[6n, n]`, is created.\n    The block `[3n, 4n]` is replaced in the FL by `[6n, n]`.\n    State: FL = `( [6n, n], [9n, 3n] )`. $B_4$ is `[3n, 3n]`.\n*   **Case 2: $n < m$.** The split does not occur. The entire block `[3n, 4n]` is allocated to $B_4$ (with internal fragmentation of $n$).\n    State: FL = `( [9n, 3n] )`. $B_4$ is `[3n, 4n]`.\n\nWe continue the trace for both cases.\n\n**Operation 6: `\\mathrm{free}(B_1)`**\n$B_1$ at `[0, 3n]` is freed.\n*   **Case 1 ($n \\ge m$):** The right neighbor of `[0, 3n]` is $B_4$ at `[3n, 3n]`, which is allocated. No coalescing. The new free block `[0, 3n]` is added to the head of the FL.\n    State: FL = `( [0, 3n], [6n, n], [9n, 3n] )`.\n*   **Case 2 ($n < m$):** The right neighbor of `[0, 3n]` is $B_4$ at `[3n, 4n]`, which is allocated. No coalescing. The new free block `[0, 3n]` is added to the head of the FL.\n    State: FL = `( [0, 3n], [9n, 3n] )`.\n\n**Operation 7: `\\mathrm{free}(B_3)`**\n$B_3$ at `[7n, 2n]` is freed.\n*   **Case 1 ($n \\ge m$):** We examine the neighbors of `[7n, 2n]` in the heap.\n    -   Left neighbor: At address $7n - n = 6n$, we have the free block `[6n, n]`. Coalescing occurs. The new block is `[6n, n+2n] = [6n, 3n]`.\n    -   Right neighbor of this new block (original right neighbor of $B_3$): At address $7n+2n = 9n$, we have the free block `[9n, 3n]`. Coalescing occurs. The final coalesced block is `[6n, 3n+3n] = [6n, 6n]`.\n    The FL before this operation was `( [0, 3n], [6n, n], [9n, 3n] )`. The blocks `[6n, n]` and `[9n, 3n]` are replaced by the single block `[6n, 6n]`.\n    **Final FL (FF, $n \\ge m$): `( [0, 3n], [6n, 6n] )`**. This matches the observed state: two blocks of sizes $3n$ and $6n$. This path is only taken if all splits occurred as assumed, which requires $9n \\ge m$, $5n \\ge m$, $3n \\ge m$, and $n \\ge m$. The necessary and sufficient condition is $n \\ge m$.\n\n*   **Case 2 ($n < m$):** We examine the neighbors of `[7n, 2n]`.\n    -   Left neighbor: At address $3n$, we have $B_4$ at `[3n, 4n]`, which is allocated. No left coalescing.\n    -   Right neighbor: At address $9n$, we have the free block `[9n, 3n]`. Coalescing occurs. The new block is `[7n, 2n+3n] = [7n, 5n]`.\n    The FL before this operation was `( [0, 3n], [9n, 3n] )`. The block `[9n, 3n]` is replaced by `[7n, 5n]`.\n    **Final FL (FF, $n < m$): `( [0, 3n], [7n, 5n] )`**. This does not match the observation.\n\n**Conclusion for FF:** The first-fit policy produces the observed final free list if and only if $n \\ge m$.\n\n### Analysis of the Next-Fit (NF) Policy\n\nThe NF policy maintains a `rover` pointer and begins its search from the `rover`'s position. Initially, the rover points to the head of the free list.\n\n**Initial State:** FL = `( [0, 12n] )`. Rover points to `[0, 12n]`.\n\n**Operation 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nNF finds `[0, 12n]`. Assuming splitting ($9n \\ge m$), $B_1$ is `[0, 3n]`. The remainder is `[3n, 9n]`.\nState: FL = `( [3n, 9n] )`. Rover is updated to point to the remainder, `[3n, 9n]`.\n\n**Operation 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nNF starts at `[3n, 9n]` and finds it. Assuming splitting ($5n \\ge m$), $B_2$ is `[3n, 4n]`. The remainder is `[7n, 5n]`.\nState: FL = `( [7n, 5n] )`. Rover is updated to point to the remainder, `[7n, 5n]`.\n\n**Operation 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nNF starts at `[7n, 5n]` and finds it. Assuming splitting ($3n \\ge m$), $B_3$ is `[7n, 2n]`. The remainder is `[9n, 3n]`.\nState: FL = `( [9n, 3n] )`. Rover is updated to point to the remainder, `[9n, 3n]`.\n\n**Operation 4: `\\mathrm{free}(B_2)`**\n$B_2$ at `[3n, 4n]` is freed. No coalescing occurs. A `free` operation does not affect the rover.\nState: FL = `( [3n, 4n], [9n, 3n] )`. Rover remains at `[9n, 3n]`.\n\n**Operation 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nNF starts its search at the rover, `[9n, 3n]`. This block is a perfect fit for the request of size $3n$. The remainder is $0$, which is less than $m$ (a positive constant), so no split occurs. The block is consumed entirely.\n$B_4$ is allocated at `[9n, 3n]`. The former free block `[9n, 3n]` is removed from the FL.\nThe rover update rule states that for a consumed block, the rover moves to its successor in the free list. The free list was `( [3n, 4n], [9n, 3n] )`. The successor of the tail `[9n, 3n]` is taken to be the head, `[3n, 4n]`, by wrapping around.\nState: FL = `( [3n, 4n] )`. Rover points to `[3n, 4n]`. $B_4$ is `[9n, 3n]`.\n\nThis choice is deterministic. NF must select `[9n, 3n]` because it's the first block it encounters that fits. It will not wrap around to find `[3n, 4n]`. This fundamentally distinguishes its behavior from FF at this step.\n\n**Operation 6: `\\mathrm{free}(B_1)`**\n$B_1$ at `[0, 3n]` is freed. Its right neighbor is the block `[3n, 4n]`, which is free. Coalescing occurs. A new free block `[0, 7n]` is formed. The rover was pointing to `[3n, 4n]`, which is now part of the new larger block. It's reasonable to assume the rover now points to `[0, 7n]`.\nState: FL = `( [0, 7n] )`.\n\n**Operation 7: `\\mathrm{free}(B_3)`**\n$B_3$ at `[7n, 2n]` is freed. Its left neighbor is the free block `[0, 7n]`. Coalescing occurs. A new free block `[0, 9n]` is formed. The right neighbor of $B_3$ is $B_4$ at `[9n, 3n]`, which is allocated.\n**Final FL (NF): `( [0, 9n] )`**.\n\nThis final state consists of a single free block of size $9n$. This does not match the observed state. This outcome is robust and does not change even if different assumptions about $m$ were to prevent splitting in earlier steps, as the rover's position would still lead it to select the last free block for `B_4`.\n\n**Conclusion for NF:** The next-fit policy cannot produce the observed final free list.\n\n### Evaluation of Options\n\n*   **A. Both first-fit and next-fit can produce the observed final free list for all $n$ satisfying $n \\ge m$; therefore, the allocation policy is not uniquely identifiable from the observation.**\n    This is **Incorrect**. Our analysis shows that the next-fit policy cannot produce the observed state.\n\n*   **B. Only first-fit can produce the observed final free list, and it does so if and only if $n \\ge m$; under the stated next-fit rover semantics, this identification is unique because next-fit cannot produce the observation.**\n    This is **Correct**. Our analysis concluded that FF produces the state if and only if $n \\ge m$, and that NF cannot produce the state under any circumstances. Therefore, observing this final state uniquely identifies the policy as first-fit and sets a condition on $n$ relative to $m$.\n\n*   **C. Only next-fit can produce the observed final free list for any $n$; first-fit cannot.**\n    This is **Incorrect**. It is the reverse of our findings.\n\n*   **D. Neither policy can produce the observed final free list for any $n$; the observation contradicts the allocator model regardless of $n$.**\n    This is **Incorrect**. First-fit can produce the observed state under the condition $n \\ge m$.", "answer": "$$\\boxed{B}$$", "id": "3653441"}, {"introduction": "Memory fragmentation is a critical challenge in dynamic storage allocation, manifesting as wasted space either inside allocated blocks (internal) or between them (external). This problem guides you through a thought experiment designed to demonstrate how even a seemingly optimal policy like best-fit can lead to severe fragmentation under certain conditions [@problem_id:3653485]. By analyzing a specific pattern of requests that are slightly smaller than a block size, you will quantify both internal and external fragmentation, gaining a clear insight into the trade-offs and potential pathologies of different allocation strategies.", "problem": "An operating system uses a linked-list-based free-space manager with a best-fit allocation policy and block splitting, but no coalescing during the interval of interest. The allocator implements size-class binning with bin width $b$ bytes: any request of size $x$ is rounded up to $\\lceil x / b \\rceil \\cdot b$ bytes before searching the free list. The free list is kept as a linked list, and best-fit scans the list to find the smallest free block whose size is at least the rounded size. When a free block is larger than required, it is split into an allocated portion of the rounded size and a residual free fragment. Residual free fragments smaller than $b$ bytes cannot satisfy any request in this sequence, because every rounded allocation size is at least $b$ bytes. Assume metadata overhead is negligible for this problem, and all addresses align perfectly to allow exact splits.\n\nTo demonstrate how best-fit can degenerate into many tiny fragments when requests fall near a bin boundary, consider the following allocation pattern and initial state.\n\n- Initial state: the heap’s free list contains exactly $n$ free blocks, each of size $b + \\varepsilon$ bytes, with $0 < \\varepsilon < b$. These $n$ free blocks are separated by already allocated guard blocks so that no two free blocks are adjacent; thus, no coalescing would be possible even if it were enabled. There are no other free blocks.\n- Allocation sequence: issue $n$ allocation requests, each of size $r = b - \\delta$ bytes, with $0 < \\delta < b$. Under the binning rule, each request is rounded up to $b$ bytes.\n\nUsing the standard definitions:\n- Internal fragmentation $F_{\\text{int}}$ is the total number of bytes wasted inside allocated blocks due to rounding (i.e., allocated size minus requested size).\n- External fragmentation $F_{\\text{ext}}$ is the total number of bytes of free memory that cannot be used to satisfy a subsequent request of size at least $b$ bytes (i.e., the sum of sizes of free fragments that are strictly smaller than $b$ bytes).\n\nDerive closed-form expressions for $F_{\\text{int}}$ and $F_{\\text{ext}}$ after servicing all $n$ requests, in terms of $n$, $b$, $\\delta$, and $\\varepsilon$. Express both $F_{\\text{int}}$ and $F_{\\text{ext}}$ in bytes, and provide your final result as a pair in a single row vector. No rounding is required; give exact symbolic expressions.", "solution": "We proceed from the allocator’s behavior and the formal definitions of fragmentation.\n\nFundamental definitions and rules in this setting:\n- Requests of size $x$ are rounded up to $\\lceil x / b \\rceil \\cdot b$ bytes before allocation.\n- Best-fit selects the smallest free block with size at least the rounded size, then splits any excess into a residual free fragment.\n- Internal fragmentation $F_{\\text{int}}$ is the sum, over all allocations, of $(\\text{rounded size}) - (\\text{requested size})$.\n- External fragmentation $F_{\\text{ext}}$ is the total size of free fragments that are strictly smaller than $b$ bytes, since such fragments cannot satisfy any request whose rounded size is at least $b$ bytes.\n\nInitial state and sequence:\n- The free list contains exactly $n$ free blocks, each of size $b + \\varepsilon$, with $0 < \\varepsilon < b$.\n- There are $n$ requests, each of size $r = b - \\delta$, with $0 < \\delta < b$.\n\nStep 1: Rounding behavior and per-request internal fragmentation.\n- The rounded allocation size for a request of size $r = b - \\delta$ is\n$$\n\\lceil r / b \\rceil \\cdot b \\;=\\; \\lceil (b - \\delta)/b \\rceil \\cdot b \\;=\\; \\lceil 1 - \\delta/b \\rceil \\cdot b \\;=\\; 1 \\cdot b \\;=\\; b,\n$$\nbecause $0 < \\delta < b$ implies $0 < \\delta/b < 1$, hence $1 - \\delta/b \\in (0,1)$ and its ceiling is $1$.\n- The per-request internal fragmentation is therefore\n$$\nb - r \\;=\\; b - (b - \\delta) \\;=\\; \\delta.\n$$\n- Over $n$ requests, the total internal fragmentation is\n$$\nF_{\\text{int}} \\;=\\; n \\cdot \\delta.\n$$\n\nStep 2: Best-fit selection and residual fragments.\n- At the time of each allocation, the free list contains one or more blocks of size $b + \\varepsilon$. The rounded size needed is $b$, so best-fit will choose one of the $b + \\varepsilon$ blocks (they are the smallest that fit, and all such blocks are equal in size).\n- Splitting a $b + \\varepsilon$ block to satisfy a $b$-byte allocation leaves a residual free fragment of size\n$$\n(b + \\varepsilon) - b \\;=\\; \\varepsilon.\n$$\n- By assumption, $0 < \\varepsilon < b$, so each residual fragment is strictly smaller than $b$ and thus cannot satisfy any rounded request, as every rounded request is at least $b$ bytes. Therefore, each residual fragment contributes fully to external fragmentation.\n\nStep 3: Total external fragmentation after $n$ allocations.\n- Each of the $n$ allocations produces exactly one residual free fragment of size $\\varepsilon$.\n- There are no other free blocks, because the initial $n$ free blocks are successively consumed by the $n$ allocations. Coalescing is disabled and free blocks are separated by guards, so no residual fragments merge.\n- Hence the total external fragmentation is\n$$\nF_{\\text{ext}} \\;=\\; n \\cdot \\varepsilon.\n$$\n\nStep 4: Assemble the final expressions.\n- Internal fragmentation: $F_{\\text{int}} = n \\delta$ bytes.\n- External fragmentation: $F_{\\text{ext}} = n \\varepsilon$ bytes.\n\nThese are exact symbolic expressions, and they quantify how best-fit degenerates into many tiny fragments of size $\\varepsilon$ when servicing $n$ near-boundary requests rounded to $b$ from free blocks that are just slightly larger than $b$.", "answer": "$$\\boxed{\\begin{pmatrix} n\\delta & n\\varepsilon \\end{pmatrix}}$$", "id": "3653485"}, {"introduction": "To truly grasp the importance of a core memory management mechanism, it is incredibly instructive to see what happens when it is absent. This exercise moves from tracing and analysis to implementation, asking you to build a simple memory allocator simulator to quantify the impact of coalescing—the merging of adjacent free blocks [@problem_id:3653403]. By comparing the external fragmentation that results from the same sequence of operations with and without coalescing, you will gain a practical, quantitative appreciation for why this mechanism is indispensable for maintaining the long-term usability of the heap.", "problem": "You are to implement a deterministic simulator of a contiguous memory allocator that uses a linked list of free blocks to manage free space. The allocator must support two variants that are identical except for coalescing policy on free:\n- Variant C (with boundary tags): A block freed coalesces with any immediately adjacent free block(s) by merging intervals that share a boundary.\n- Variant B (footers removed): A block freed is inserted into the free list without any coalescing, even if it is adjacent to other free blocks.\n\nUse the following core definitions as the fundamental base:\n- A contiguous memory region is modeled as integer addresses from $0$ to $M-1$, where $M \\in \\mathbb{N}$ is the total number of addressable units.\n- The free space is maintained as a sorted singly linked list of non-overlapping intervals $[b,\\ell]$ representing blocks starting at base address $b \\in \\mathbb{N}$ with length $\\ell \\in \\mathbb{N}$, meaning the free cells are $\\{b, b+1, \\dots, b+\\ell-1\\}$. Two consecutive blocks $[b_1,\\ell_1]$ and $[b_2,\\ell_2]$ are adjacent if and only if $b_1+\\ell_1=b_2$.\n- An allocation request of size $s \\in \\mathbb{N}$ uses first-fit: select the first free interval $[b,\\ell]$ with $\\ell \\ge s$, allocate the interval $[b,s]$ as payload, and update the free list to either remove $[b,\\ell]$ if $\\ell=s$, or replace it by $[b+s,\\ell-s]$ if $\\ell>s$.\n- A free operation for a previously returned allocation $[b,\\ell]$ inserts $[b,\\ell]$ back into the free list in sorted order. In Variant C, coalesce by repeatedly merging adjacent neighbors so that no two free intervals are adjacent. In Variant B, do not merge at all.\n- The external fragmentation metric is defined as\n$$\nF_{\\text{ext}} \\;=\\;\n\\begin{cases}\n0, & \\text{if } T_{\\text{free}}=0, \\\\[4pt]\n1 - \\dfrac{L_{\\max}}{T_{\\text{free}}}, & \\text{if } T_{\\text{free}} > 0,\n\\end{cases}\n$$\nwhere $T_{\\text{free}}$ is the total free space (sum of lengths of all free intervals) and $L_{\\max}$ is the size of the largest free interval.\n\nAllocation identifiers are assigned as follows. Each successful allocation is assigned the next positive integer identifier $1,2,3,\\dots$ in order of success and remains bound to the exact $[b,\\ell]$ that was returned at that time. A failed allocation (no free block sufficiently large) does not consume an identifier. A free operation specifies an identifier $k \\in \\mathbb{N}$; if $k$ is currently allocated, the corresponding block is returned to the free list according to the active variant. If $k$ is not currently allocated, the free request is ignored.\n\nImplement a program that runs both Variant B and Variant C on each of the test cases below and, for each case, computes the difference\n$$\n\\Delta \\;=\\; F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}\n$$\nafter executing the entire sequence of operations. Report each $\\Delta$ as a decimal rounded to exactly four digits after the decimal point.\n\nInput: There is no input. All parameters are fixed and embedded in the program.\n\nOperation notation: Each operation is either an allocate $A\\;s$ (allocate size $s$) or a free $F\\;k$ (free identifier $k$).\n\nTest suite (execute each independently from a fresh initial state with a single free block $[0,M]$):\n- Test case $1$:\n  - $M=64$\n  - Operations: $A\\;10,\\;A\\;12,\\;A\\;8,\\;F\\;2,\\;A\\;6,\\;F\\;3,\\;F\\;1,\\;A\\;5,\\;F\\;4$\n- Test case $2$:\n  - $M=32$\n  - Operations: $A\\;8,\\;A\\;8,\\;F\\;1,\\;A\\;4,\\;F\\;2$\n- Test case $3$:\n  - $M=50$\n  - Operations: $A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;F\\;2,\\;F\\;4,\\;A\\;3,\\;A\\;2,\\;F\\;3,\\;F\\;5,\\;F\\;1$\n\nFinal output format: Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order of the test cases:\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3]\n$$\nEach $\\Delta_i$ must be printed as a decimal rounded to four digits after the decimal point.\n\nScientific realism and derivation requirements:\n- Base your design on the above core definitions of first-fit allocation, interval coalescing, and the external fragmentation metric $F_{\\text{ext}}$.\n- Ensure that your implementation maintains a sorted linked list representation of free intervals, updates it according to the definitions for both variants, and computes $F_{\\text{ext}}$ strictly from $T_{\\text{free}}$ and $L_{\\max}$ at the end of each test case.\n- Do not use any randomization; all results must be deterministic and reproducible.\n\nYour program must be self-contained and must not read any input. The only output must be the single required line in the exact format specified above. All quantities are dimensionless. Express each result rounded to four digits after the decimal point as specified.", "solution": "The problem statement is a well-defined computational exercise in simulating memory management algorithms. We begin by validating its integrity.\n\n### Step 1: Extract Givens\n- **Memory Model**: A contiguous address space from $0$ to $M-1$.\n- **Initial State**: A single free block of size $M$, represented as the interval $[0, M]$.\n- **Free Space Representation**: A sorted singly linked list of non-overlapping intervals $[b, \\ell]$, where $b$ is the base address and $\\ell$ is the length. The list is sorted in increasing order of $b$.\n- **Adjacency**: Two consecutive free blocks $[b_1, \\ell_1]$ and $[b_2, \\ell_2]$ are adjacent if $b_1 + \\ell_1 = b_2$.\n- **Allocation Policy**: First-fit. For a request of size $s$, the first free block $[b, \\ell]$ in the list with $\\ell \\ge s$ is chosen.\n    - If $\\ell = s$, the block is removed from the free list.\n    - If $\\ell > s$, the block is updated to $[b+s, \\ell-s]$.\n- **Allocation Identifiers**: Successful allocations are assigned sequential positive integer IDs ($1, 2, 3, \\ldots$). Failed allocations do not consume an ID. An ID remains bound to the specific $[b, \\ell]$ that was allocated.\n- **Free Operation**: A request to free ID $k$. If $k$ corresponds to a currently active allocation, its block is returned to the free list. Otherwise, the request is ignored.\n- **Variant C (Coalescing)**: When a block is freed, it is inserted into the sorted free list. Then, it is merged with any adjacent free blocks. The process is repeated until no two free blocks in the list are adjacent.\n- **Variant B (No Coalescing)**: When a block is freed, it is inserted into the sorted free list without any merging, even if it is adjacent to other free blocks.\n- **External Fragmentation Metric**:\n$$\nF_{\\text{ext}} =\n\\begin{cases}\n0, & \\text{if } T_{\\text{free}}=0 \\\\\n1 - \\dfrac{L_{\\max}}{T_{\\text{free}}}, & \\text{if } T_{\\text{free}} > 0\n\\end{cases}\n$$\nwhere $T_{\\text{free}}$ is the total size of all free blocks, and $L_{\\max}$ is the size of the largest free block.\n- **Objective**: For each test case, compute the difference $\\Delta = F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}$.\n- **Test Cases**:\n    1.  $M=64$, Operations: $A\\;10, A\\;12, A\\;8, F\\;2, A\\;6, F\\;3, F\\;1, A\\;5, F\\;4$.\n    2.  $M=32$, Operations: $A\\;8, A\\;8, F\\;1, A\\;4, F\\;2$.\n    3.  $M=50$, Operations: $A\\;5, A\\;5, A\\;5, A\\;5, A\\;5, F\\;2, F\\;4, A\\;3, A\\;2, F\\;3, F\\;5, F\\;1$.\n- **Output**: A single line `[d1,d2,d3]` where $d_i$ are the $\\Delta$ values for each test case, rounded to four decimal places.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on fundamental and standard concepts from computer science, specifically operating systems and memory management. The models for contiguous allocation, first-fit, free lists, coalescing, and fragmentation are canonical.\n- **Well-Posed**: The problem is deterministic. The initial state, algorithms (first-fit), and sequence of operations are precisely specified. This ensures a unique final state for the memory layout for each variant, leading to a single, unambiguous solution for $\\Delta$.\n- **Objective**: The problem is stated using precise, formal definitions and avoids any subjective or ambiguous language.\n- **Completeness and Consistency**: The problem is self-contained. It provides all necessary parameters ($M$), initial conditions, operational semantics, and definitions required for a complete simulation. There are no internal contradictions.\n- **Feasibility**: The memory sizes and number of operations are small, making the simulation computationally trivial and readily implementable.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-posed, deterministic simulation task based on established principles of operating systems. We will proceed to develop a solution.\n\n### Algorithmic Design and Principles\n\nThe core of the solution is a deterministic simulation of the memory allocator. For each test case, we must run the simulation twice: once for Variant B (no coalescing) and once for Variant C (with coalescing), then compute the difference in their final fragmentation metrics.\n\n**Data Structures**\nTo model the system state, two primary data structures are required:\n\n1.  **Free List**: A singly linked list is used to manage the free memory blocks, as specified. Each node in the list represents a free memory interval and stores its base address $b$ and length $\\ell$. The list is always maintained in ascending order of the base addresses.\n    ```c\n    typedef struct FreeNode {\n        int base;\n        int length;\n        struct FreeNode *next;\n    } FreeNode;\n    ```\n2.  **Allocated Blocks Table**: A simple array can serve as a table to track allocated blocks. The index of the array corresponds to (allocation ID - $1$). Each entry stores the `base`, `length`, and an `is_active` flag for the corresponding allocation.\n    ```c\n    typedef struct {\n        int base;\n        int length;\n        int is_active;\n    } AllocatedBlock;\n    ```\n\n**Simulation Logic**\nThe simulation proceeds by processing a sequence of operations. Each test case starts from an identical initial state: a free list containing a single block $[0, M]$.\n\n**Allocation Operation (`A s`)**\nThe first-fit algorithm requires traversing the sorted free list from the head to find the first block $[b, \\ell]$ such that $\\ell \\ge s$.\n- If such a block is found:\n    1.  A new allocation with ID `next_id` is created for the interval $[b, s]$. This information is stored in the allocated blocks table.\n    2.  The `next_id` counter is incremented.\n    3.  The free list is updated. If the block was an exact fit ($\\ell=s$), the node is removed from the list. If it was a larger fit ($\\ell > s$), the node is modified in place to represent the remaining fragment: its base becomes $b+s$ and its length becomes $\\ell-s$.\n- If no such block is found, the allocation request fails, and the state remains unchanged.\n\n**Free Operation (`F k`)**\n1.  The request is first validated: the ID $k$ must correspond to an active allocation.\n2.  If valid, the block $[b, \\ell]$ associated with ID $k$ is retrieved from the allocated blocks table, and the allocation is marked as inactive.\n3.  The block $[b, \\ell]$ is returned to the free list. The handling of this insertion depends on the variant:\n\n    - **Variant B (No Coalescing)**: A new `FreeNode` for $[b, \\ell]$ is created and inserted into the linked list at the correct position to maintain the sorted order by base address. No merging occurs.\n\n    - **Variant C (Coalescing)**: This is the more complex case. After finding the insertion point for the new block $[b, \\ell]$ between a predecessor `prev` and a successor `curr` node, we check for adjacency to merge blocks and prevent fragmentation.\n        1.  **Merge with Predecessor**: Check if `prev` is adjacent to the new block (i.e., `prev->base + prev->length == b`).\n        2.  **Merge with Successor**: Check if the new block is adjacent to `curr` (i.e., `b + l == curr->base`).\n        \n        There are four possibilities for the block at $[b, \\ell]$:\n        a.  It merges with both `prev` and `curr`. `prev`'s length is increased by $\\ell$ plus `curr`'s length, and `curr` is removed.\n        b.  It merges only with `prev`. `prev`'s length is increased by $\\ell$.\n        c.  It merges only with `curr`. `curr`'s base is updated to $b$ and its length is increased by $\\ell$.\n        d.  It merges with neither. A new node for $[b, \\ell]$ is created and inserted between `prev` and `curr`.\n        This procedure ensures that upon completion, no two blocks in the free list are adjacent.\n\n**Fragmentation Calculation**\nAfter all operations for a test case are completed, the external fragmentation $F_{\\text{ext}}$ is calculated. This involves a final traversal of the free list to compute:\n- $T_{\\text{free}}$: The sum of the `length` of all free blocks.\n- $L_{\\max}$: The maximum `length` found among all free blocks.\n\nThe metric is then computed using the formula $F_{\\text{ext}} = 1 - (L_{\\max} / T_{\\text{free}})$, with the special case $F_{\\text{ext}}=0$ if $T_{\\text{free}}=0$.\n\nFinally, the difference $\\Delta = F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}$ is calculated. This entire process is repeated for all test cases, and the results are formatted as required.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// Represents a free block of memory.\ntypedef struct FreeNode {\n    int base;\n    int length;\n    struct FreeNode *next;\n} FreeNode;\n\n// Represents an allocated block of memory.\ntypedef struct {\n    int base;\n    int length;\n    int is_active;\n} AllocatedBlock;\n\n// Represents a single operation (Allocate or Free).\ntypedef struct {\n    char type;\n    int value;\n} Operation;\n\n// Represents a test case with its parameters.\ntypedef struct {\n    int M;\n    const Operation* ops;\n    int num_ops;\n} TestCase;\n\n// Utility to create a new FreeNode.\nFreeNode* create_node(int base, int length) {\n    FreeNode* node = (FreeNode*)malloc(sizeof(FreeNode));\n    if (!node) {\n        perror(\"Failed to allocate memory for FreeNode\");\n        exit(EXIT_FAILURE);\n    }\n    node->base = base;\n    node->length = length;\n    node->next = NULL;\n    return node;\n}\n\n// Utility to free the entire linked list.\nvoid free_list(FreeNode** head_ref) {\n    FreeNode* current = *head_ref;\n    FreeNode* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    *head_ref = NULL;\n}\n\n// Variant B: Insert a block into the sorted free list without coalescing.\nvoid insert_no_coalesce(FreeNode** head_ref, int base, int length) {\n    FreeNode* new_node = create_node(base, length);\n    if (*head_ref == NULL || (*head_ref)->base > base) {\n        new_node->next = *head_ref;\n        *head_ref = new_node;\n        return;\n    }\n    FreeNode* current = *head_ref;\n    while (current->next != NULL && current->next->base < base) {\n        current = current->next;\n    }\n    new_node->next = current->next;\n    current->next = new_node;\n}\n\n// Variant C: Insert a block into the sorted free list with coalescing.\nvoid insert_and_coalesce(FreeNode** head_ref, int base, int length) {\n    FreeNode *prev = NULL, *curr = *head_ref;\n    while (curr != NULL && curr->base < base) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    int can_merge_prev = (prev != NULL && prev->base + prev->length == base);\n    int can_merge_curr = (curr != NULL && base + length == curr->base);\n\n    if (can_merge_prev && can_merge_curr) {\n        prev->length += length + curr->length;\n        prev->next = curr->next;\n        free(curr);\n    } else if (can_merge_prev) {\n        prev->length += length;\n    } else if (can_merge_curr) {\n        curr->base = base;\n        curr->length += length;\n    } else {\n        FreeNode* new_node = create_node(base, length);\n        new_node->next = curr;\n        if (prev == NULL) {\n            *head_ref = new_node;\n        } else {\n            prev->next = new_node;\n        }\n    }\n}\n\n// Calculate the external fragmentation metric.\ndouble calculate_fragmentation(FreeNode* head) {\n    if (head == NULL) {\n        return 0.0;\n    }\n\n    double total_free = 0;\n    double max_free = 0;\n\n    for (FreeNode* current = head; current != NULL; current = current->next) {\n        total_free += current->length;\n        if (current->length > max_free) {\n            max_free = current->length;\n        }\n    }\n\n    if (total_free == 0) {\n        return 0.0;\n    }\n\n    return 1.0 - (max_free / total_free);\n}\n\n\n// Main simulation function.\ndouble run_simulation(int M, const Operation* ops, int num_ops, char variant) {\n    // ---- Initialization ----\n    FreeNode* free_list_head = create_node(0, M);\n    \n    // Max of 50 allocations is more than enough for these tests.\n    AllocatedBlock allocated_blocks[50]; \n    memset(allocated_blocks, 0, sizeof(allocated_blocks));\n    int next_alloc_id = 1;\n\n    // ---- Operation Loop ----\n    for (int i = 0; i < num_ops; ++i) {\n        Operation op = ops[i];\n\n        if (op.type == 'A') { // Allocate\n            int size = op.value;\n            FreeNode* current = free_list_head;\n            FreeNode* prev = NULL;\n\n            // First-fit search\n            while (current != NULL && current->length < size) {\n                prev = current;\n                current = current->next;\n            }\n\n            if (current != NULL) { // Block found\n                allocated_blocks[next_alloc_id - 1].base = current->base;\n                allocated_blocks[next_alloc_id - 1].length = size;\n                allocated_blocks[next_alloc_id - 1].is_active = 1;\n\n                if (current->length == size) { // Exact fit\n                    if (prev == NULL) {\n                        free_list_head = current->next;\n                    } else {\n                        prev->next = current->next;\n                    }\n                    free(current);\n                } else { // Larger fit\n                    current->base += size;\n                    current->length -= size;\n                }\n                next_alloc_id++;\n            }\n        } else if (op.type == 'F') { // Free\n            int id = op.value;\n            if (id > 0 && id < next_alloc_id && allocated_blocks[id - 1].is_active) {\n                int base = allocated_blocks[id - 1].base;\n                int length = allocated_blocks[id - 1].length;\n                allocated_blocks[id - 1].is_active = 0;\n                \n                if (variant == 'B') {\n                    insert_no_coalesce(&free_list_head, base, length);\n                } else { // Variant 'C'\n                    insert_and_coalesce(&free_list_head, base, length);\n                }\n            }\n        }\n    }\n\n    double fragmentation = calculate_fragmentation(free_list_head);\n    free_list(&free_list_head);\n    return fragmentation;\n}\n\nint main(void) {\n    const Operation tc1_ops[] = {\n        {'A', 10}, {'A', 12}, {'A', 8}, {'F', 2}, {'A', 6}, {'F', 3}, {'F', 1}, {'A', 5}, {'F', 4}\n    };\n    const Operation tc2_ops[] = {\n        {'A', 8}, {'A', 8}, {'F', 1}, {'A', 4}, {'F', 2}\n    };\n    const Operation tc3_ops[] = {\n        {'A', 5}, {'A', 5}, {'A', 5}, {'A', 5}, {'A', 5}, {'F', 2}, {'F', 4}, {'A', 3}, {'A', 2}, {'F', 3}, {'F', 5}, {'F', 1}\n    };\n\n    TestCase test_cases[] = {\n        {64, tc1_ops, sizeof(tc1_ops) / sizeof(tc1_ops[0])},\n        {32, tc2_ops, sizeof(tc2_ops) / sizeof(tc2_ops[0])},\n        {50, tc3_ops, sizeof(tc3_ops) / sizeof(tc3_ops[0])}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        double f_ext_b = run_simulation(tc.M, tc.ops, tc.num_ops, 'B');\n        double f_ext_c = run_simulation(tc.M, tc.ops, tc.num_ops, 'C');\n        results[i] = f_ext_b - f_ext_c;\n    }\n\n    printf(\"[%.4f,%.4f,%.4f]\\n\", results[0], results[1], results[2]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3653403"}]}