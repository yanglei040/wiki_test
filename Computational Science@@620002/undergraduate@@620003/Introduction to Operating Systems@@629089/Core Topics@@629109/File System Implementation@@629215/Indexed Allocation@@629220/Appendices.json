{"hands_on_practices": [{"introduction": "To truly appreciate indexed allocation, we must first understand its primary advantage: the ability to support very large files efficiently. This exercise guides you through the fundamental calculation of a file's maximum possible size based on the structure of its index node (inode). By working through the contributions of direct, single-indirect, and multi-level indirect pointers, you will develop a concrete understanding of how this hierarchical addressing scheme exponentially expands the addressable space [@problem_id:3649508].", "problem": "A file system component within an Operating System (OS) uses indexed allocation. Each file is composed of fixed-size data blocks of size $B$ bytes. The fileâ€™s inode (index node) contains $a$ direct block pointers that reference data blocks directly. It may also contain pointers to indirect index blocks providing up to depth $d$ levels of indirection. Each indirect index block is a fixed-size block that stores only block pointers, each of size $p$ bytes, so an indirect index block can hold $k$ pointers, where $k$ equals the integer capacity of a block of size $B$ when filled with $p$-byte pointers. Assume $k$ is known and that every indirect pointer at level $i$ ($i \\in \\{1,\\dots,d\\}$) ultimately references only data blocks at the leaves; intermediate levels reference further indirect blocks. The inode has exactly one pointer to each level of indirection $i \\in \\{1,\\dots,d\\}$, in addition to its $a$ direct pointers. Index blocks themselves do not contribute to the logical file size; only data blocks are counted.\n\nStarting from these definitions and fundamental counting principles, derive an analytic expression for the maximum number of addressable data blocks in a file as a function of $a$, $k$, and $d$, and then derive the maximum file size in bytes as a function of $B$, $a$, $k$, and $d$.\n\nFinally, evaluate the maximum file size for the case $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$. Express the final maximum file size in bytes. Do not round; give the exact integer value.", "solution": "The user wants me to solve a problem related to indexed file allocation in an operating system.\n\n### Step 1: Extract Givens\n- File system block size: $B$ bytes.\n- Number of direct block pointers in an inode: $a$.\n- Maximum depth of indirection: $d$.\n- Size of a block pointer: $p$ bytes.\n- Number of pointers per indirect index block: $k = \\lfloor B/p \\rfloor$.\n- Inode structure: $a$ direct pointers and one pointer for each level of indirection $i \\in \\{1, \\dots, d\\}$.\n- Task 1: Derive an analytic expression for the maximum number of addressable data blocks, $N_{blocks}$, as a function of $a$, $k$, and $d$.\n- Task 2: Derive an analytic expression for the maximum file size, $S_{max}$, as a function of $B$, $a$, $k$, and $d$.\n- Task 3: Evaluate $S_{max}$ for the specific case: $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a standard model of indexed file allocation, a fundamental concept in operating systems.\n- **Scientifically Grounded:** The model is a well-established and simplified representation of file systems like the Unix File System (UFS). All concepts are standard in computer science.\n- **Well-Posed:** The problem is clearly defined with all necessary variables ($B, p, a, d$) and relationships ($k = \\lfloor B/p \\rfloor$) provided. The structure of the inode is explicitly stated. The tasks are specific and lead to a unique solution.\n- **Objective:** The language is formal and unambiguous.\n\nThe problem does not exhibit any flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, ill-posed, or trivial. It is a standard, solvable problem in the field of operating systems.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Derivation of Maximum Number of Addressable Data Blocks\n\nLet $N_{blocks}$ be the maximum number of data blocks a file can have. This is determined by the total number of data block pointers that can be accessed starting from the file's inode. We sum the contributions from the direct and indirect pointers.\n\n1.  **Contribution from Direct Pointers:** The inode contains $a$ direct pointers. Each direct pointer references exactly one data block.\n    Contribution from direct pointers = $a$.\n\n2.  **Contribution from Indirect Pointers:** The problem states that the inode has \"exactly one pointer to each level of indirection $i \\in \\{1,\\dots,d\\}$\". This means there is one single-indirect pointer, one double-indirect pointer, ..., and one $d$-level-indirect pointer.\n\n    -   **Level 1 (Single-Indirect Pointer):** The single-indirect pointer in the inode points to an *index block*. This index block contains $k$ pointers. Each of these $k$ pointers references a data block.\n        Contribution from the level-1 pointer = $k^1 = k$.\n\n    -   **Level 2 (Double-Indirect Pointer):** The double-indirect pointer in the inode points to a first-level index block. This block contains $k$ pointers, each of which points to a second-level index block. There are thus $k$ second-level index blocks. Each of these second-level index blocks contains $k$ pointers to data blocks.\n        Contribution from the level-2 pointer = $k \\times k = k^2$.\n\n    -   **Level $i$ ($i$-level-Indirect Pointer):** Generalizing the pattern, the $i$-level-indirect pointer in the inode initiates a tree of index blocks with a depth of $i$. This structure allows addressing $k^i$ data blocks.\n        Contribution from the level-$i$ pointer = $k^i$.\n\n    The total contribution from all indirect pointers is the sum of the contributions from each level of indirection from $1$ to $d$.\n    Total contribution from indirect pointers = $\\sum_{i=1}^{d} k^i$.\n\n3.  **Total Number of Data Blocks:** The total number of addressable data blocks, $N_{blocks}$, is the sum of the blocks addressed by direct pointers and all levels of indirect pointers.\n    $$N_{blocks}(a, k, d) = a + \\sum_{i=1}^{d} k^i$$\n    This is the first required expression. The sum is a geometric series. For $k \\neq 1$, this can also be written as $N_{blocks}(a, k, d) = a + k \\frac{k^d - 1}{k - 1}$.\n\n### Derivation of Maximum File Size\n\nThe logical size of the file is determined by the content of the data blocks only. Each data block has a size of $B$ bytes. The maximum file size, $S_{max}$, is the total number of addressable data blocks multiplied by the size of each block.\n\nUsing the expression for $N_{blocks}$ derived above:\n$$S_{max}(B, a, k, d) = B \\times N_{blocks}(a, k, d)$$\nSubstituting the expression for $N_{blocks}$:\n$$S_{max}(B, a, k, d) = B \\left( a + \\sum_{i=1}^{d} k^i \\right)$$\nThis is the second required analytical expression.\n\n### Evaluation for the Specific Case\n\nWe are asked to evaluate the maximum file size for the case where $B=4\\,\\mathrm{KB}$, $p=4\\,\\mathrm{B}$, $a=12$, and $d=3$.\n\n1.  **Calculate $k$:**\n    First, we must convert $B$ to bytes.\n    $B = 4\\,\\mathrm{KB} = 4 \\times 1024\\,\\mathrm{Bytes} = 4096\\,\\mathrm{Bytes}$.\n    The size of a pointer is $p = 4\\,\\mathrm{Bytes}$.\n    The number of pointers in an index block, $k$, is:\n    $$k = \\left\\lfloor \\frac{B}{p} \\right\\rfloor = \\left\\lfloor \\frac{4096}{4} \\right\\rfloor = 1024$$\n\n2.  **Calculate the total number of blocks, $N_{blocks}$:**\n    We use the formula for $N_{blocks}$ with $a=12$, $d=3$, and $k=1024$.\n    $$N_{blocks} = a + \\sum_{i=1}^{d} k^i = 12 + \\sum_{i=1}^{3} (1024)^i$$\n    $$N_{blocks} = 12 + 1024^1 + 1024^2 + 1024^3$$\n    Let's calculate the powers of $1024$:\n    $1024^1 = 1024$\n    $1024^2 = (2^{10})^2 = 2^{20} = 1,048,576$\n    $1024^3 = (2^{10})^3 = 2^{30} = 1,073,741,824$\n    Now, we sum these values:\n    $$N_{blocks} = 12 + 1024 + 1,048,576 + 1,073,741,824$$\n    $$N_{blocks} = 1036 + 1,048,576 + 1,073,741,824$$\n    $$N_{blocks} = 1,049,612 + 1,073,741,824$$\n    $$N_{blocks} = 1,074,791,436$$\n\n3.  **Calculate the maximum file size, $S_{max}$:**\n    The maximum file size is $N_{blocks}$ multiplied by the block size $B$.\n    $$S_{max} = N_{blocks} \\times B$$\n    $$S_{max} = 1,074,791,436 \\times 4096$$\n    Performing the multiplication:\n    $$S_{max} = 4,402,345,721,856$$\nThe maximum file size is exactly $4,402,345,721,856$ bytes. This is approximately $4$ terabytes ($4\\,\\mathrm{TiB}$).", "answer": "$$\\boxed{4402345721856}$$", "id": "3649508"}, {"introduction": "Beyond theoretical capacity, a practical file system must be optimized for storage efficiency. This practice explores the crucial design trade-off involved in selecting a block size, $B$. You will analyze how this single parameter creates a tension between reducing metadata overhead (the space used for index blocks) and minimizing internal fragmentation (the wasted space in the last data block), allowing you to find the optimal block size for a given file [@problem_id:3649516].", "problem": "A storage subsystem in an Operating System (OS) uses indexed allocation with chained single-level index blocks. A data block has size $B$, chosen from the set $\\{1\\,\\mathrm{KB},2\\,\\mathrm{KB},4\\,\\mathrm{KB},8\\,\\mathrm{KB}\\}$, where $1\\,\\mathrm{KB}=1024$ bytes. Each index block consists solely of fixed-size block pointers of size $p$ bytes, with $p=8$ bytes. For a given block size $B$, the pointer capacity of an index block is $k=\\lfloor B/p\\rfloor$, and the maximum single-indirect coverage (the largest file size addressable by a single index block) is $k\\cdot B$ bytes.\n\nAssume the following storage model for a single file of size $S$ bytes:\n- The file uses $n_{d}(B)=\\lceil S/B\\rceil$ data blocks.\n- If more data blocks are needed than a single index block can address, additional index blocks are chained. The number of index blocks used is $n_{i}(B)=\\left\\lceil n_{d}(B)/k\\right\\rceil$. Each index block occupies a full block of size $B$ and stores only data block pointers. You may assume that chaining metadata is managed outside of the index blocks and does not affect $k$.\n- Internal fragmentation arises only from the last partially filled data block and is captured by the ceiling operation on $n_{d}(B)$.\n\nLet the file size be $S=15000000$ bytes, and let $p=8$ bytes.\n\nTask:\n1. For each candidate $B\\in\\{1\\,\\mathrm{KB},2\\,\\mathrm{KB},4\\,\\mathrm{KB},8\\,\\mathrm{KB}\\}$, determine $k=\\lfloor B/p\\rfloor$ and the maximum single-indirect coverage $k\\cdot B$.\n2. Using the model above, determine, for each $B$, the total allocated space $A(B)=\\big(n_{d}(B)+n_{i}(B)\\big)\\cdot B$ in bytes for the file of size $S$.\n3. Choose the block size $B^{\\star}$ that minimizes $A(B)$ (breaking ties by choosing the larger $B$), and compute the corresponding maximum single-indirect coverage $k(B^{\\star})\\cdot B^{\\star}$.\n\nExpress your final answer as a single integer number of bytes. No rounding is required. Use bytes as the unit for any intermediate computations and explanations.", "solution": "The problem requires an analysis of storage overhead in an indexed file allocation system. The goal is to determine the optimal block size $B$ from a given set that minimizes total allocated space for a file of a specific size, and then to calculate a related property for that optimal block size. The analysis will proceed by systematically evaluating each candidate block size according to the provided model.\n\nThe given parameters are:\n- File size: $S = 15000000$ bytes.\n- Block pointer size: $p = 8$ bytes.\n- Candidate block sizes: $B \\in \\{1\\,\\mathrm{KB}, 2\\,\\mathrm{KB}, 4\\,\\mathrm{KB}, 8\\,\\mathrm{KB}\\}$. We convert these to bytes using $1\\,\\mathrm{KB} = 1024$ bytes, so $B \\in \\{1024, 2048, 4096, 8192\\}$ bytes.\n\nThe model defines the following quantities for a given block size $B$:\n- The number of pointers per index block: $k(B) = \\lfloor B/p \\rfloor$.\n- The number of data blocks required for the file: $n_{d}(B) = \\lceil S/B \\rceil$.\n- The number of index blocks required to point to all data blocks: $n_{i}(B) = \\lceil n_{d}(B)/k(B) \\rceil$.\n- The total allocated space: $A(B) = (n_{d}(B) + n_{i}(B)) \\cdot B$.\n\nWe will now compute these values for each candidate block size.\n\n**Case 1: Block Size $B = 1024$ bytes**\n\nFirst, we calculate the number of pointers that can be stored in a single index block.\n$$k(1024) = \\left\\lfloor \\frac{1024}{8} \\right\\rfloor = \\lfloor 128 \\rfloor = 128$$\nThe maximum single-indirect coverage is the amount of data addressable by one index block.\n$$k(1024) \\cdot B = 128 \\cdot 1024 = 131072 \\text{ bytes}$$\nNext, we determine the number of data blocks needed for the file.\n$$n_{d}(1024) = \\left\\lceil \\frac{15000000}{1024} \\right\\rceil = \\lceil 14648.4375 \\rceil = 14649$$\nThen, we find the number of index blocks needed to address these data blocks.\n$$n_{i}(1024) = \\left\\lceil \\frac{n_{d}(1024)}{k(1024)} \\right\\rceil = \\left\\lceil \\frac{14649}{128} \\right\\rceil = \\lceil 114.4453125 \\rceil = 115$$\nFinally, we compute the total allocated space.\n$$A(1024) = (n_{d}(1024) + n_{i}(1024)) \\cdot 1024 = (14649 + 115) \\cdot 1024 = 14764 \\cdot 1024 = 15118336 \\text{ bytes}$$\n\n**Case 2: Block Size $B = 2048$ bytes**\n\nFollowing the same procedure:\n$$k(2048) = \\left\\lfloor \\frac{2048}{8} \\right\\rfloor = \\lfloor 256 \\rfloor = 256$$\nThe maximum single-indirect coverage is:\n$$k(2048) \\cdot B = 256 \\cdot 2048 = 524288 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(2048) = \\left\\lceil \\frac{15000000}{2048} \\right\\rceil = \\lceil 7324.21875 \\rceil = 7325$$\nThe number of index blocks is:\n$$n_{i}(2048) = \\left\\lceil \\frac{n_{d}(2048)}{k(2048)} \\right\\rceil = \\left\\lceil \\frac{7325}{256} \\right\\rceil = \\lceil 28.61328125 \\rceil = 29$$\nThe total allocated space is:\n$$A(2048) = (n_{d}(2048) + n_{i}(2048)) \\cdot 2048 = (7325 + 29) \\cdot 2048 = 7354 \\cdot 2048 = 15060992 \\text{ bytes}$$\n\n**Case 3: Block Size $B = 4096$ bytes**\n\nAgain, we apply the formulas:\n$$k(4096) = \\left\\lfloor \\frac{4096}{8} \\right\\rfloor = \\lfloor 512 \\rfloor = 512$$\nThe maximum single-indirect coverage is:\n$$k(4096) \\cdot B = 512 \\cdot 4096 = 2097152 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(4096) = \\left\\lceil \\frac{15000000}{4096} \\right\\rceil = \\lceil 3662.109375 \\rceil = 3663$$\nThe number of index blocks is:\n$$n_{i}(4096) = \\left\\lceil \\frac{n_{d}(4096)}{k(4096)} \\right\\rceil = \\left\\lceil \\frac{3663}{512} \\right\\rceil = \\lceil 7.154296875 \\rceil = 8$$\nThe total allocated space is:\n$$A(4096) = (n_{d}(4096) + n_{i}(4096)) \\cdot 4096 = (3663 + 8) \\cdot 4096 = 3671 \\cdot 4096 = 15036416 \\text{ bytes}$$\n\n**Case 4: Block Size $B = 8192$ bytes**\n\nLastly, for the largest block size:\n$$k(8192) = \\left\\lfloor \\frac{8192}{8} \\right\\rfloor = \\lfloor 1024 \\rfloor = 1024$$\nThe maximum single-indirect coverage is:\n$$k(8192) \\cdot B = 1024 \\cdot 8192 = 8388608 \\text{ bytes}$$\nThe number of data blocks is:\n$$n_{d}(8192) = \\left\\lceil \\frac{15000000}{8192} \\right\\rceil = \\lceil 1831.0546875 \\rceil = 1832$$\nThe number of index blocks is:\n$$n_{i}(8192) = \\left\\lceil \\frac{n_{d}(8192)}{k(8192)} \\right\\rceil = \\left\\lceil \\frac{1832}{1024} \\right\\rceil = \\lceil 1.7890625 \\rceil = 2$$\nThe total allocated space is:\n$$A(8192) = (n_{d}(8192) + n_{i}(8192)) \\cdot 8192 = (1832 + 2) \\cdot 8192 = 1834 \\cdot 8192 = 15024128 \\text{ bytes}$$\n\n**Comparison and Selection of Optimal Block Size $B^{\\star}$**\n\nWe now compare the total allocated space $A(B)$ for each block size:\n- $A(1024) = 15118336$ bytes\n- $A(2048) = 15060992$ bytes\n- $A(4096) = 15036416$ bytes\n- $A(8192) = 15024128$ bytes\n\nBy comparing these values, we find that the minimum total allocated space is $15024128$ bytes. This minimum is achieved with the block size $B = 8192$ bytes. Therefore, the optimal block size is $B^{\\star} = 8192$ bytes.\n\n**Final Calculation**\n\nThe problem asks for the maximum single-indirect coverage, $k(B^{\\star}) \\cdot B^{\\star}$, corresponding to the optimal block size $B^{\\star}$. We have already computed this value for $B=8192$.\n$$k(B^{\\star}) \\cdot B^{\\star} = k(8192) \\cdot 8192 = 1024 \\cdot 8192 = 8388608$$\nThis value represents the maximum file size that can be supported by a single index block when the block size is $B^{\\star}$.", "answer": "$$\\boxed{8388608}$$", "id": "3649516"}, {"introduction": "The true value of a data structure is often revealed through its performance under different workloads. This final hands-on exercise moves from static analysis to dynamic simulation, asking you to model and compare the performance of indexed allocation against the simpler linked allocation scheme. By implementing a simulation based on a classic disk access model, you will quantify the dramatic improvements in random-access latency that make indexed allocation a cornerstone of modern file systems [@problem_id:3649454].", "problem": "You are asked to write a complete, runnable program that simulates, under a simplified and principled disk model, the performance difference between single-indirect indexed allocation and linked allocation for a toy filesystem (file system, FS). Your program must compute both sequential throughput and random-access average latency using first-principles definitions and a minimal timing model. The program must produce a single line of output in the exact specified format.\n\nFundamental base and assumptions:\n- Single-indirect indexed allocation stores all data block addresses in one index block. Let the disk block size be $B$ bytes and the pointer size be $p$ bytes. The maximum number of data blocks addressable by a single-indirect indexed file is $P = \\left\\lfloor \\frac{B}{p} \\right\\rfloor$. A file using single-indirect indexed allocation with $L$ data blocks must satisfy $L \\le P$.\n- Linked allocation stores, within each data block, a pointer to the next data block. Random access to logical block $k$ requires following the chain from the first block through $k$ blocks.\n- Use the classic disk time components. For each block I/O that requires an independent access, the time is modeled as $T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}$, where:\n  - $T_{\\text{seek}}$ is the average seek time in milliseconds.\n  - $T_{\\text{rot}}$ is the average rotational latency in milliseconds.\n  - $T_{\\text{trans}}$ is the data transfer time for one block in milliseconds.\n- Let the sustained sequential bandwidth be $S$ Mebibytes per second (MiB/s), where one Mebibyte (MiB) equals $2^{20}$ bytes. Then the transfer time per block is\n$$\nT_{\\text{trans}} = \\frac{1000 \\cdot B}{S \\cdot 2^{20}} \\quad \\text{milliseconds.}\n$$\n- Sequential full-file read workload:\n  - Linked allocation: assume blocks are not colocated, thus each of the $L$ data block reads is an independent access with time $T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}$.\n  - Single-indirect indexed allocation: assume the index block is not cached initially and must be read once, costing $T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}$, plus the same $L$ independent data block reads as above.\n  - Let total time be $T_{\\text{seq}}$ milliseconds. The sequential throughput in MiB/s is then\n$$\n\\text{Throughput} = \\frac{L \\cdot B / 2^{20}}{T_{\\text{seq}} / 1000}.\n$$\n- Random single-block access workload:\n  - Consider $Q$ random logical block accesses drawn uniformly from $\\{1, 2, \\dots, L\\}$.\n  - Linked allocation: to access block $k$, the chain length equals $k$, so the expected chain length is $\\mathbb{E}[K] = \\frac{L + 1}{2}$, and the expected time per query is\n$$\nT_{\\text{lat, linked}} = \\mathbb{E}[K] \\cdot \\left(T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}\\right).\n$$\n  - Single-indirect indexed allocation: assume the index block is read once at the start and then cached perfectly for the remaining queries. Each query requires one random data block access. Thus the total time for $Q$ queries is\n$$\nT_{\\text{total, indexed}} = \\left(T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}\\right) + Q \\cdot \\left(T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}\\right),\n$$\nso the average latency per query is\n$$\nT_{\\text{lat, indexed}} = \\frac{Q + 1}{Q} \\cdot \\left(T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}}\\right).\n$$\n\nTasks:\n1. Implement the above formulas exactly.\n2. For each test case, compute:\n   - Indexed sequential throughput in MiB/s.\n   - Linked sequential throughput in MiB/s.\n   - Indexed average latency per random query in milliseconds.\n   - Linked average latency per random query in milliseconds.\n3. All outputs must be floating-point numbers.\n\nUnits and output requirements:\n- All times input parameters $T_{\\text{seek}}$ and $T_{\\text{rot}}$ are in milliseconds.\n- The sequential bandwidth $S$ is in MiB/s.\n- The block size $B$ and pointer size $p$ are in bytes.\n- The output throughput must be expressed in MiB/s.\n- The output latency must be expressed in milliseconds.\n- Your program should print all numeric results with exactly $6$ digits after the decimal point.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list in the order\n$$\n[\\ \\text{indexed\\_seq\\_MiBps},\\ \\text{linked\\_seq\\_MiBps},\\ \\text{indexed\\_avg\\_lat\\_ms},\\ \\text{linked\\_avg\\_lat\\_ms}\\ ].\n$$\nThe final output must be a single list of these per-test-case lists, for example:\n$[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],\\dots]$.\n\nTest suite:\nProvide exactly the following $4$ test cases inside your program:\n- Test case $1$ (happy path):\n  - $B = 4096$ bytes, $p = 4$ bytes, $L = 16$ blocks, $T_{\\text{seek}} = 8.0$ ms, $T_{\\text{rot}} = 4.0$ ms, $S = 100.0$ MiB/s, $Q = 100$.\n- Test case $2$ (single-block file, highlights index overhead and random access edge):\n  - $B = 4096$ bytes, $p = 4$ bytes, $L = 1$ block, $T_{\\text{seek}} = 8.0$ ms, $T_{\\text{rot}} = 4.0$ ms, $S = 200.0$ MiB/s, $Q = 1$.\n- Test case $3$ (boundary at single-indirect capacity):\n  - $B = 4096$ bytes, $p = 4$ bytes, $L = 1024$ blocks, $T_{\\text{seek}} = 12.0$ ms, $T_{\\text{rot}} = 3.0$ ms, $S = 150.0$ MiB/s, $Q = 1024$.\n- Test case $4$ (pointer size increase reduces index capacity):\n  - $B = 4096$ bytes, $p = 8$ bytes, $L = 512$ blocks, $T_{\\text{seek}} = 5.0$ ms, $T_{\\text{rot}} = 3.0$ ms, $S = 120.0$ MiB/s, $Q = 256$.\n\nDesign constraints:\n- The program must be self-contained and take no input.\n- If a test case violates $L \\le \\left\\lfloor \\frac{B}{p} \\right\\rfloor$, your program must still compute using the stated formulas but this test suite has been chosen so that this constraint holds exactly in all cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case in the order given above. Each floating-point number must be printed with exactly $6$ digits after the decimal point.", "solution": "The user has provided a well-defined and scientifically grounded problem. It is self-contained, consistent, and requires the implementation of a performance model for two disk-based file allocation strategies: single-indirect indexed allocation and linked allocation. The problem is valid and a solution will be provided.\n\nThe design of the program will strictly follow the mathematical models and parameters specified. The core of the solution is to calculate four performance metrics for each given test case: sequential throughput for both allocation methods and random-access latency for both.\n\nThe fundamental quantities to be calculated are derived from first principles as follows:\n\n$1$. **Block Transfer Time ($T_{\\text{trans}}$)**\nThe time to transfer a single block of size $B$ bytes over a channel with sustained bandwidth $S$ MiB/s is given. Since $1$ MiB is $2^{20}$ bytes and the desired unit for time is milliseconds, the formula is:\n$$\nT_{\\text{trans}} = \\frac{1000 \\cdot B}{S \\cdot 2^{20}} \\quad [\\text{ms}]\n$$\nThis formula correctly converts the bandwidth from MiB/s to bytes/ms in the denominator (by a factor of $2^{20}/1000$) and computes the time to transfer $B$ bytes.\n\n$2$. **Total Time for a Single I/O ($T_{\\text{access}}$)**\nThe model for a single, independent disk access is the sum of its constituent delays: seek, rotation, and transfer.\n$$\nT_{\\text{access}} = T_{\\text{seek}} + T_{\\text{rot}} + T_{\\text{trans}} \\quad [\\text{ms}]\n$$\nThis value represents the cost of reading one randomly-placed block from the disk.\n\n$3$. **Sequential Throughput**\nThroughput is defined as total data size divided by total time. For a file of $L$ blocks, each of size $B$ bytes, the total data size is $L \\cdot B$. To express this in MiB, we divide by $2^{20}$. The total time, $T_{\\text{seq}}$, is calculated in milliseconds and must be converted to seconds by dividing by $1000$.\n$$\n\\text{Throughput} = \\frac{\\text{Data Size (MiB)}}{\\text{Time (s)}} = \\frac{L \\cdot B / 2^{20}}{T_{\\text{seq}} / 1000} = \\frac{1000 \\cdot L \\cdot B}{T_{\\text{seq}} \\cdot 2^{20}} \\quad [\\text{MiB/s}]\n$$\n- For **linked allocation**, reading $L$ blocks requires $L$ independent accesses, assuming no co-location. Thus, the total time is $T_{\\text{seq, linked}} = L \\cdot T_{\\text{access}}$.\n- For **single-indirect indexed allocation**, an additional access is required to first read the index block. This leads to a total of $L+1$ accesses. The total time is $T_{\\text{seq, indexed}} = (L+1) \\cdot T_{\\text{access}}$.\n\n$4$. **Random Access Latency**\nThis metric measures the average time to read a single, randomly chosen logical block.\n- For **linked allocation**, to access logical block $k$, one must read through a chain of $k$ blocks. With a uniform random choice of $k$ from $\\{1, 2, \\dots, L\\}$, the expected number of blocks to read is $\\mathbb{E}[K] = \\frac{L+1}{2}$. The average latency is this expectation multiplied by the time per access:\n$$\nT_{\\text{lat, linked}} = \\frac{L+1}{2} \\cdot T_{\\text{access}} \\quad [\\text{ms}]\n$$\n- For **single-indirect indexed allocation**, the model assumes the index block is read once and then perfectly cached for all subsequent $Q$ queries. The total time for $Q$ queries is the sum of the initial index block read and the $Q$ individual data block reads: $(1+Q) \\cdot T_{\\text{access}}$. The average latency per query is this total time divided by $Q$:\n$$\nT_{\\text{lat, indexed}} = \\frac{Q+1}{Q} \\cdot T_{\\text{access}} \\quad [\\text{ms}]\n$$\n\nThe program will be structured to first define the test cases using a `struct`. Then, for each case, it will compute $T_{\\text{trans}}$ and $T_{\\text{access}}$ as intermediate values. Using these, it will calculate the four final metrics. All calculations will use the `double` floating-point type for accuracy. The results for all test cases will be stored and then printed in a single line, adhering precisely to the specified format `[[...],[...],...]`, with each number formatted to $6$ decimal places.", "answer": "```c\n// This program simulates and compares the performance of single-indirect indexed\n// and linked file allocation schemes based on a simplified disk model.\n// It calculates sequential throughput and random-access latency for a predefined\n// set of test cases and prints the results in a specific format.\n//\n// The code strictly adheres to the C23 standard and uses only the allowed headers.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>   // Allowed, but not used.\n#include <math.h>     // Allowed, but not used.\n// #include <complex.h> // Allowed, but not used.\n// #include <threads.h>   // Allowed, but not used.\n// #include <stdatomic.h> // Allowed, but not used.\n\n// A struct to hold the parameters for a single test case.\n// All values are stored as doubles for floating-point arithmetic.\ntypedef struct {\n    double B;       // Block size in bytes\n    double p;       // Pointer size in bytes\n    double L;       // Number of data blocks in the file\n    double T_seek;  // Average seek time in milliseconds\n    double T_rot;   // Average rotational latency in milliseconds\n    double S;       // Sustained sequential bandwidth in MiB/s\n    double Q;       // Number of random access queries\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {4096.0, 4.0, 16.0, 8.0, 4.0, 100.0, 100.0},\n        {4096.0, 4.0, 1.0, 8.0, 4.0, 200.0, 1.0},\n        {4096.0, 4.0, 1024.0, 12.0, 3.0, 150.0, 1024.0},\n        {4096.0, 8.0, 512.0, 5.0, 3.0, 120.0, 256.0}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    // A 2D array to store the 4 results for each test case.\n    double results[num_cases][4]; \n\n    // A Mebibyte (MiB) is 2^20 bytes.\n    const double MIB_IN_BYTES = 1048576.0;\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // 1. Calculate the data transfer time for one block in milliseconds.\n        double T_trans = (1000.0 * tc.B) / (tc.S * MIB_IN_BYTES);\n\n        // 2. Calculate the total time for a single independent block access.\n        double T_access = tc.T_seek + tc.T_rot + T_trans;\n\n        // --- Sequential Throughput Calculations (MiB/s) ---\n\n        // 3. For single-indirect indexed allocation:\n        // Total time includes reading 1 index block + L data blocks.\n        double T_seq_indexed = (1.0 + tc.L) * T_access;\n        // Throughput = (Total Data in MiB) / (Total Time in seconds).\n        results[i][0] = (1000.0 * tc.L * tc.B) / (T_seq_indexed * MIB_IN_BYTES);\n\n        // 4. For linked allocation:\n        // Total time includes reading L data blocks.\n        double T_seq_linked = tc.L * T_access;\n        // Since L is always >= 1, no division by zero will occur.\n        results[i][1] = (1000.0 * tc.L * tc.B) / (T_seq_linked * MIB_IN_BYTES);\n\n        // --- Random Access Latency Calculations (ms) ---\n\n        // 5. For single-indirect indexed allocation:\n        // Total time for Q queries is (1 index read + Q data reads).\n        // Average latency is Total Time / Q.\n        // Since Q is always >= 1, no division by zero will occur.\n        results[i][2] = ((tc.Q + 1.0) / tc.Q) * T_access;\n\n        // 6. For linked allocation:\n        // Expected number of reads is (L+1)/2 for a random block.\n        double expected_chain_length = (tc.L + 1.0) / 2.0;\n        results[i][3] = expected_chain_length * T_access;\n    }\n\n    // Print the results in the EXACT required format.\n    // The output is a single line, JSON-like array of arrays.\n    // Example: [[r11,r12,r13,r14],[r21,r22,r23,r24]]\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%.6f,%.6f,%.6f,%.6f]\", \n               results[i][0], \n               results[i][1], \n               results[i][2], \n               results[i][3]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3649454"}]}