{"hands_on_practices": [{"introduction": "A hard disk's performance is fundamentally tied to its physical geometry and data organization. This exercise moves beyond simple rotational speed to explore how the choice of sector size directly impacts sustained data throughput. By comparing a legacy $512$-byte sector format with a modern $4\\,\\text{KiB}$ format, you will quantify how formatting choices can lead to wasted space and reduced performance due to integer packing constraints on a track [@problem_id:3635469]. This practice provides a concrete understanding of the trade-offs involved in low-level disk formatting and its direct link to performance.", "problem": "A magnetic hard disk uses constant angular velocity. Consider a specific outer-zone track that, when formatted with $S$ contiguous data sectors of size $B$, contains exactly $S \\times B$ usable data bytes per full rotation, ignoring all non-data overhead. The sustained transfer rate for a full-track sequential read is the amount of data delivered per rotation divided by the rotation period. Use only the following fundamentals: rotations per minute to rotations per second conversion, the definition of bytes per rotation as the product of sectors per track and bytes per sector, and the definition of sustained throughput as bytes per second.\n\nGiven:\n- Rotational speed $= \\text{Rotations Per Minute (RPM)} = 7200$.\n- With $512$ byte sectors, there are $S = 1500$ sectors per track, so the track’s usable data capacity per rotation is $1500 \\times 512$ bytes.\n- Now reformat the same physical track to use $4\\,\\text{Kibibyte (KiB)}$ sectors, where $1\\,\\text{KiB} = 1024$ bytes. The controller packs as many whole $4\\,\\text{KiB}$ sectors as fit into the same per-rotation usable data capacity implied by the $512$ byte layout; any leftover space smaller than one sector is unusable for data.\n\nTasks:\n1. Compute the sustained transfer rate for a full-track sequential read with $512$ byte sectors in megabytes per second $\\left(\\text{MB/s}\\right)$, where $1\\,\\text{MB} = 10^6$ bytes. State the symbolic reasoning that leads to your result.\n2. Recompute the sustained transfer rate for the $4\\,\\text{KiB}$ sector formatting under the packing rule above, again in $\\text{MB/s}$.\n3. Let $R$ be the ratio of the $4\\,\\text{KiB}$ throughput to the $512$ byte throughput. Report $R$ as your final answer. Round $R$ to four significant figures and express it as a pure number with no units.\n4. Briefly explain, from first principles about track capacity and integer sector packing, why the two throughputs differ slightly under these assumptions, and how a real controller’s packing choices might affect the outcome.\n\nYour final answer must be only $R$, rounded to four significant figures and with no units.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains sufficient information to derive a unique solution.\n\nLet the rotational speed of the disk be $\\omega$. The problem states $\\omega = 7200$ rotations per minute (RPM). To find the sustained transfer rate in bytes per second, we must first convert the rotational speed to rotations per second. Let this be $\\omega_{\\text{rps}}$.\n$$ \\omega_{\\text{rps}} = \\frac{\\omega}{60 \\, \\text{s/min}} = \\frac{7200 \\, \\text{RPM}}{60 \\, \\text{s/min}} = 120 \\, \\text{rotations/s} $$\nThe rotation period, $T$, is the reciprocal of the rotational frequency:\n$$ T = \\frac{1}{\\omega_{\\text{rps}}} = \\frac{1}{120} \\, \\text{s} $$\nThe sustained transfer rate, or throughput $Th$, is defined as the amount of data transferred per rotation, $D$, divided by the rotation period, $T$.\n$$ Th = \\frac{D}{T} = D \\times \\omega_{\\text{rps}} $$\n\n**1. Sustained transfer rate with $512$ byte sectors**\n\nFor the initial configuration, the sector size is $B_1 = 512$ bytes, and the number of sectors per track is $S_1 = 1500$. The problem states that the usable data capacity per rotation, $D_1$, is the product of these two values.\n$$ D_1 = S_1 \\times B_1 = 1500 \\times 512 \\, \\text{bytes} = 768000 \\, \\text{bytes} $$\nThe sustained transfer rate, $Th_1$, is then:\n$$ Th_1 = D_1 \\times \\omega_{\\text{rps}} = 768000 \\, \\text{bytes} \\times 120 \\, \\text{s}^{-1} = 92160000 \\, \\text{bytes/s} $$\nThe problem asks for this rate in megabytes per second (MB/s), where $1 \\, \\text{MB} = 10^6 \\, \\text{bytes}$.\n$$ Th_1 = \\frac{92160000 \\, \\text{bytes/s}}{10^6 \\, \\text{bytes/MB}} = 92.16 \\, \\text{MB/s} $$\n\n**2. Sustained transfer rate with $4$ KiB sectors**\n\nThe problem specifies that the track is reformatted using a new sector size, $B_2$, of $4$ Kibibytes (KiB). We convert this to bytes, using $1 \\, \\text{KiB} = 1024 \\, \\text{bytes}$.\n$$ B_2 = 4 \\, \\text{KiB} \\times 1024 \\, \\text{bytes/KiB} = 4096 \\, \\text{bytes} $$\nThe key constraint is that the new sectors are packed into the same *per-rotation usable data capacity* as the original layout. This total physical capacity available for data, let's call it $C_{\\text{track}}$, is therefore equal to $D_1$.\n$$ C_{\\text{track}} = D_1 = 768000 \\, \\text{bytes} $$\nThe number of new sectors, $S_2$, that can fit into this capacity is the integer part of the ratio of the total capacity to the new sector size, as only whole sectors are allowed.\n$$ S_2 = \\left\\lfloor \\frac{C_{\\text{track}}}{B_2} \\right\\rfloor = \\left\\lfloor \\frac{768000}{4096} \\right\\rfloor = \\lfloor 187.5 \\rfloor = 187 $$\nThe new usable data capacity per rotation, $D_2$, is the product of the number of new sectors and their size.\n$$ D_2 = S_2 \\times B_2 = 187 \\times 4096 \\, \\text{bytes} = 765952 \\, \\text{bytes} $$\nThe new sustained transfer rate, $Th_2$, is:\n$$ Th_2 = D_2 \\times \\omega_{\\text{rps}} = 765952 \\, \\text{bytes} \\times 120 \\, \\text{s}^{-1} = 91914240 \\, \\text{bytes/s} $$\nIn MB/s, this is:\n$$ Th_2 = \\frac{91914240 \\, \\text{bytes/s}}{10^6 \\, \\text{bytes/MB}} = 91.91424 \\, \\text{MB/s} $$\n\n**3. Ratio of throughputs, $R$**\n\nThe ratio $R$ is defined as the throughput with $4 \\, \\text{KiB}$ sectors divided by the throughput with $512$ byte sectors.\n$$ R = \\frac{Th_2}{Th_1} = \\frac{D_2 \\times \\omega_{\\text{rps}}}{D_1 \\times \\omega_{\\text{rps}}} = \\frac{D_2}{D_1} $$\nThe rotational speed term cancels out. Substituting the values for $D_1$ and $D_2$:\n$$ R = \\frac{765952}{768000} \\approx 0.9973333... $$\nRounding to four significant figures as requested, we get:\n$$ R \\approx 0.9973 $$\n\n**4. Explanation of the throughput difference**\n\nThe two throughputs differ because the total physical capacity of the track available for data ($C_{\\text{track}} = 768000$ bytes) is not an integer multiple of the new, larger sector size ($B_2 = 4096$ bytes). The division yields $187.5$, meaning that after $187$ full sectors are written to the track, a space of $0.5 \\times 4096 = 2048$ bytes remains. According to the problem's packing rule, this leftover space is unusable for data, representing a form of internal fragmentation at the track level. This results in a slightly lower total usable data per rotation ($D_2  D_1$) and consequently a slightly lower sustained transfer rate ($Th_2  Th_1$).\n\nIn contrast, a real controller's behavior might be more complex. The problem simplifies reality by starting with a \"usable data capacity\" and treating it as the total physical capacity. A real track's fixed physical bit capacity must accommodate not only data but also significant overhead per sector (e.g., inter-sector gaps, headers, error-correction codes). When switching from many small sectors ($1500$ sectors of size $512$ bytes) to fewer large sectors ($187$ sectors of size $4096$ bytes), the total overhead associated with gaps and headers is substantially reduced. This reclaimed space could potentially be used to store more data, possibly even allowing the $188$-th sector to fit. In such a realistic scenario, the throughput for the $4 \\, \\text{KiB}$ format could be equal to or even greater than that of the $512$ byte format, contrary to the result dictated by the problem's specific assumptions. The problem's structure highlights the concept of capacity loss due to integer packing constraints in a simplified model.", "answer": "$$\\boxed{0.9973}$$", "id": "3635469"}, {"introduction": "An operating system's file system plays a crucial role as a performance architect, deciding where to physically place data on a disk. This problem models a key decision: for related data, is it better to use a different surface on the same cylinder or a different cylinder on the same surface? You will quantify the performance trade-off between a fast electronic head switch and a slower mechanical seek, providing a clear rationale for the data-locality principle of keeping related data within the same cylinder [@problem_id:3635442]. This exercise sharpens your ability to analyze performance based on the disk's three-dimensional geometry.", "problem": "A magnetic hard disk has multiple platters and surfaces. A cylinder is the set of tracks at the same radius across all surfaces. Switching which surface is being read requires a head switch, while moving the read head radially to a different cylinder requires a seek. Consider two related files that the Operating System (OS) places either on different surfaces within the same cylinder or on the same surface in adjacent cylinders. Assume the following is known from the disk’s geometry and mechanics: the head switch incurs a time cost of $t_h$ due to actuator and servo settling, and a short seek to an adjacent cylinder incurs a time cost of $t_s$. The baseline per-request time (comprising average rotational latency and block transfer time) is the same under both placements and is unaffected by whether the next request targets the same file or the other file.\n\nSuppose the Input/Output (I/O) workload is a long stream of single-block read requests such that the probability that a request targets the other file (a cross-file switch compared to the immediately preceding request) is $p$, independently across requests. The two placement strategies are:\n\n- Strategy $\\mathcal{C}$: Place the files on different surfaces within the same cylinder; each cross-file switch causes a head switch of cost $t_h$.\n- Strategy $\\mathcal{S}$: Place the files on the same surface in adjacent cylinders; each cross-file switch causes a short seek of cost $t_s$.\n\nGiven $t_h = 0.37$ milliseconds (ms), $t_s = 1.33$ ms, and $p = 0.41$, determine the expected time saved per request, in milliseconds, by choosing Strategy $\\mathcal{C}$ over Strategy $\\mathcal{S}$. Express your final answer in milliseconds (ms) and round your answer to four significant figures.", "solution": "The problem asks for the expected time saved per request by choosing Strategy $\\mathcal{C}$ over Strategy $\\mathcal{S}$. This can be determined by calculating the expected overhead time per request for each strategy and then finding the difference. The baseline per-request time is identical for both strategies and can be disregarded in this comparative analysis. The only difference in time per request arises from the penalty incurred during a cross-file switch.\n\nLet a random variable represent the type of I/O request. A request is a \"cross-file switch\" with a given probability $p$. This means the current request targets a different file than the one accessed by the immediately preceding request. The complementary event, where the request targets the same file, occurs with probability $1-p$.\n\nThe overhead cost is incurred only in the event of a cross-file switch.\nFor Strategy $\\mathcal{C}$ (files on the same cylinder, different surfaces), a cross-file switch incurs a head switch time of $t_h$. No overhead is incurred if the request is for the same file.\nFor Strategy $\\mathcal{S}$ (files on adjacent cylinders, same surface), a cross-file switch incurs a short seek time of $t_s$. No overhead is incurred if the request is for the same file.\n\nLet $E_{\\mathcal{C}}$ be the expected overhead time per request for Strategy $\\mathcal{C}$. This is the sum of the products of each possible cost and its probability of occurrence.\n$$E_{\\mathcal{C}} = (t_h \\times p) + (0 \\times (1-p)) = p \\cdot t_h$$\n\nLet $E_{\\mathcal{S}}$ be the expected overhead time per request for Strategy $\\mathcal{S}$. Similarly, this is calculated as:\n$$E_{\\mathcal{S}} = (t_s \\times p) + (0 \\times (1-p)) = p \\cdot t_s$$\n\nThe expected time saved per request by choosing Strategy $\\mathcal{C}$ over Strategy $\\mathcal{S}$, which we denote as $\\Delta T$, is the difference between their expected overhead times:\n$$\\Delta T = E_{\\mathcal{S}} - E_{\\mathcal{C}}$$\nA positive value for $\\Delta T$ indicates that Strategy $\\mathcal{C}$ is faster on average.\n\nSubstituting the expressions for $E_{\\mathcal{S}}$ and $E_{\\mathcal{C}}$:\n$$\\Delta T = p \\cdot t_s - p \\cdot t_h = p(t_s - t_h)$$\n\nNow, we substitute the given numerical values into this expression.\nThe givens are:\n- Probability of a cross-file switch, $p = 0.41$.\n- Head switch time, $t_h = 0.37$ ms.\n- Short seek time, $t_s = 1.33$ ms.\n\nPlugging these values into the equation for $\\Delta T$:\n$$\\Delta T = 0.41 \\times (1.33 - 0.37)$$\n\nFirst, we calculate the difference in time costs:\n$$t_s - t_h = 1.33 - 0.37 = 0.96 \\text{ ms}$$\n\nNext, we multiply this difference by the probability $p$:\n$$\\Delta T = 0.41 \\times 0.96$$\n$$\\Delta T = 0.3936 \\text{ ms}$$\n\nThe problem requires the answer to be rounded to four significant figures. The calculated value is $0.3936$. The significant figures are $3$, $9$, $3$, and $6$. The number already has exactly four significant figures, so no rounding is necessary.\n\nThe expected time saved per request by choosing Strategy $\\mathcal{C}$ over Strategy $\\mathcal{S}$ is $0.3936$ ms.", "answer": "$$\\boxed{0.3936}$$", "id": "3635442"}, {"introduction": "Disk scheduling algorithms like Shortest Seek Time First (SSTF) are designed to be \"smarter\" than a simple First-Come, First-Served (FCFS) approach by minimizing mechanical movement. But does a locally optimal choice always lead to a globally optimal result? This thought-provoking problem presents a specific workload where the greedy SSTF algorithm is surprisingly outperformed by FCFS [@problem_id:3635439]. By analyzing the interaction between the request order and the disk's track skew, you will uncover a classic scenario where breaking sequentiality for a short seek incurs a massive rotational latency penalty, demonstrating a critical lesson in system performance analysis.", "problem": "Consider a magnetic hard disk with the following geometry and timing properties: Rotations Per Minute (RPM) is $6000$, which implies a rotation period of $T_r = 10\\ \\text{ms}$. Each track has $N = 60$ addressable sectors indexed $0,1,\\dots,59$ uniformly spaced around the circle. The time for a single sector to pass under the head is therefore $T_s = T_r / N = 10\\ \\text{ms} / 60 = 0.166\\overline{6}\\ \\text{ms}$. A track-to-track seek (one cylinder step) takes $t_{tt} = 1\\ \\text{ms}$, and the disk employs track skew of $K = 6$ sectors between successive cylinders to support streaming across cylinder boundaries (the physical position of logical sector $0$ on cylinder $c+1$ is offset by $K$ sectors relative to logical sector $0$ on cylinder $c$). Assume one surface and ignore head-switch overhead. The disk head begins at cylinder $10$ just as sector index $30$ is arriving under the head at time $0$.\n\nYou are given a queue of read requests that are all present at time $0$ and must be serviced in a single batch. The queue order (which is also the arrival order for the purpose of First-Come, First-Served) is as follows:\n- Requests $\\mathrm{R}_1$ through $\\mathrm{R}_{30}$: sectors $(c=10, s=30)$, $(c=10, s=31)$, $\\dots$, $(c=10, s=59)$ in increasing sector index order.\n- Requests $\\mathrm{R}_{31}$ and $\\mathrm{R}_{32}$: $(c=11, s=0)$, $(c=11, s=1)$.\n- Requests $\\mathrm{R}_{33}$ and $\\mathrm{R}_{34}$: $(c=10, s=20)$, $(c=10, s=25)$.\n\nAssume the following scheduling algorithms and tie-breaking rules:\n- First-Come, First-Served (FCFS): service strictly in the given queue order.\n- Shortest Seek Time First (SSTF): at each decision point, choose the request with the smallest absolute cylinder distance from the current head cylinder. If multiple requests tie on cylinder distance, break ties by earliest arrival order in the given queue.\n\nAssume that servicing a request for sector $(c,s)$ requires the head to be at cylinder $c$ and then to wait for the sector’s angular position to come under the head. The forward angular distance in sectors from the current angular position to $s$ (taken modulo $N$) times $T_s$ gives the rotational latency, and the data transfer for one sector takes $T_s$ once the sector arrives. For cylinder changes, the head moves one cylinder in time $t_{tt}$, during which the medium continues to rotate.\n\nWhich option best describes the outcome for this workload, including which scheduler finishes sooner and a correct quantitative justification based on the disk geometry and timing?\n\nA. FCFS completes the batch in approximately $10.5\\ \\text{ms}$, whereas SSTF takes approximately $15.8\\ \\text{ms}$, because FCFS preserves a sequential cross-cylinder run that benefits from track skew, while SSTF’s reordering to same-cylinder requests breaks that alignment and incurs large rotational latencies before and after the cylinder change.\n\nB. SSTF completes the batch in approximately $9.7\\ \\text{ms}$, because minimizing seek distance always reduces total time, and track skew does not affect the outcome.\n\nC. FCFS and SSTF tie at approximately $12.0\\ \\text{ms}$, because rotational latency dominates equally regardless of request order when all requests are present at time $0$.\n\nD. The outcome cannot be determined without additional parameters about head settling time and sector interleaving, so neither scheduler can be shown to outperform the other with the given data.", "solution": "The user has requested a detailed analysis of a disk scheduling problem, including validation of the problem statement, derivation of the solution, and evaluation of the provided options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   Rotations Per Minute (RPM): $6000\\ \\text{RPM}$.\n-   Rotation period: $T_r = 10\\ \\text{ms}$.\n-   Sectors per track: $N = 60$.\n-   Sector transfer time: $T_s = T_r / N = 10\\ \\text{ms} / 60 = 1/6\\ \\text{ms} \\approx 0.166\\overline{6}\\ \\text{ms}$.\n-   Track-to-track seek time: $t_{tt} = 1\\ \\text{ms}$.\n-   Track skew: $K = 6$ sectors.\n-   Initial conditions ($t=0$): Head at cylinder $c=10$; sector $s=30$ is arriving under the head.\n-   Request Queue (all present at $t=0$):\n    -   $\\mathrm{R}_1, \\dots, \\mathrm{R}_{30}$: $(c=10, s=30), \\dots, (c=10, s=59)$.\n    -   $\\mathrm{R}_{31}, \\mathrm{R}_{32}$: $(c=11, s=0), (c=11, s=1)$.\n    -   $\\mathrm{R}_{33}, \\mathrm{R}_{34}$: $(c=10, s=20), (c=10, s=25)$.\n-   Schedulers:\n    -   First-Come, First-Served (FCFS): services requests in the given queue order.\n    -   Shortest Seek Time First (SSTF): services the request with the minimum cylinder distance; ties are broken by earliest arrival order.\n-   Timing model: Total time for a request is the sum of seek time, rotational latency, and transfer time. Disk rotates continuously, including during seeks.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Groundedness**: The problem is based on the standard model of magnetic disk drive operation, a core topic in operating systems. All concepts (RPM, seek, latency, skew) and their relationships are scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. All necessary parameters ($T_r, N, t_{tt}, K$), initial conditions, and scheduling rules are explicitly defined. This allows for the calculation of a unique completion time for each scheduling algorithm.\n-   **Objectivity**: The problem statement is objective and uses precise terminology.\n-   **Completeness and Consistency**: The given values are consistent. $6000\\ \\text{RPM} = 100\\ \\text{rotations/second}$, so the period $T_r = 1/100\\ \\text{s} = 10\\ \\text{ms}$. The sector time $T_s = 10\\ \\text{ms} / 60 = 1/6\\ \\text{ms}$ is also consistent. The setup does not contain contradictory constraints.\n-   **Realism**: The parameters are realistic for a disk drive, making it a valid and practical exercise.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. The analysis can proceed.\n\n### Solution Derivation\n\nWe will calculate the total time required to service all requests for each scheduling algorithm. We will use fractions to maintain precision. The sector time is $T_s = 1/6\\ \\text{ms}$.\n\n**First-Come, First-Served (FCFS) Analysis**\n\nThe requests are serviced in the order: $(\\mathrm{R}_1, \\dots, \\mathrm{R}_{30})$, then $(\\mathrm{R}_{31}, \\mathrm{R}_{32})$, then $(\\mathrm{R}_{33}, \\mathrm{R}_{34})$.\n\n1.  **Service requests $\\mathrm{R}_1$ to $\\mathrm{R}_{30}$ on cylinder $10$**:\n    -   At $t=0$, the head is at $c=10$ and sector $s=30$ is arriving. The first request is for $(c=10, s=30)$.\n    -   There is no seek time and no rotational latency for $\\mathrm{R}_1$.\n    -   Requests $\\mathrm{R}_1$ through $\\mathrm{R}_{30}$ are for contiguous sectors $(s=30, \\dots, 59)$. They can be read sequentially.\n    -   Number of sectors = $59 - 30 + 1 = 30$.\n    -   Time for this block = $30 \\times T_s = 30 \\times (1/6)\\ \\text{ms} = 5\\ \\text{ms}$.\n    -   At $t=5\\ \\text{ms}$, reading of sector $s=59$ is complete. The head is at $c=10$, and the angular position is now the beginning of sector $s=0$.\n\n2.  **Service requests $\\mathrm{R}_{31}, \\mathrm{R}_{32}$ on cylinder $11$**:\n    -   The next request is for $(c=11, s=0)$. A seek from $c=10$ to $c=11$ is required.\n    -   Seek time = $t_{tt} = 1\\ \\text{ms}$. The seek finishes at $t = 5 + 1 = 6\\ \\text{ms}$.\n    -   During the $1\\ \\text{ms}$ seek, the disk rotates by a number of sectors equal to $t_{tt} / T_s = 1\\ \\text{ms} / (1/6\\ \\text{ms}) = 6$ sectors.\n    -   At $t=5\\ \\text{ms}$, the angular position was the start of sector $s=0$. At $t=6\\ \\text{ms}$, the angular position is the start of sector $s=6$.\n    -   The request is for logical sector $s=0$ on $c=11$. Due to track skew $K=6$, the physical position of logical sector $s=0$ on $c=11$ is aligned with the physical position of logical sector $s=0+K=6$ on $c=10$.\n    -   The head arrives at $c=11$ just as the target sector (physical location $6$) is arriving. The rotational latency is $0$.\n    -   The requests $(c=11, s=0)$ and $(c=11, s=1)$ are for $2$ contiguous sectors.\n    -   Transfer time = $2 \\times T_s = 2 \\times (1/6)\\ \\text{ms} = 1/3\\ \\text{ms}$.\n    -   This step completes at $t = 6\\ \\text{ms} + 1/3\\ \\text{ms} = 19/3\\ \\text{ms}$.\n    -   At this time, the head is at $c=11$, having just read logical sector $s=1$. This corresponds to physical position $s=1+K=7$. The next sector to arrive has physical position $s=8$.\n\n3.  **Service requests $\\mathrm{R}_{33}, \\mathrm{R}_{34}$ on cylinder $10$**:\n    -   The next request is $\\mathrm{R}_{33}$ for $(c=10, s=20)$. A seek from $c=11$ to $c=10$ is required.\n    -   Seek time = $t_{tt} = 1\\ \\text{ms}$. The seek finishes at $t = 19/3 + 1 = 22/3\\ \\text{ms}$.\n    -   During the seek, the disk rotates another $6$ sectors. The angular position at seek completion is the start of sector $s = 8+6=14$.\n    -   The request is for $s=20$. The head must wait for sectors $14, 15, \\dots, 19$ to pass. This is a forward distance of $20-14=6$ sectors.\n    -   Rotational latency for $\\mathrm{R}_{33}$ = $6 \\times T_s = 6 \\times (1/6)\\ \\text{ms} = 1\\ \\text{ms}$.\n    -   Reading of $s=20$ begins at $t = 22/3 + 1 = 25/3\\ \\text{ms}$. Transfer takes $T_s = 1/6\\ \\text{ms}$.\n    -   $\\mathrm{R}_{33}$ is complete at $t = 25/3 + 1/6 = 51/6\\ \\text{ms}$. The angular position is now the start of sector $s=21$.\n    -   The final request is $\\mathrm{R}_{34}$ for $(c=10, s=25)$. The head must wait for sectors $21, 22, 23, 24$ to pass, a distance of $4$ sectors.\n    -   Rotational latency for $\\mathrm{R}_{34}$ = $4 \\times T_s = 4 \\times (1/6)\\ \\text{ms} = 2/3\\ \\text{ms}$.\n    -   Reading of $s=25$ begins at $t = 51/6 + 2/3 = 51/6 + 4/6 = 55/6\\ \\text{ms}$. Transfer takes $T_s = 1/6\\ \\text{ms}$.\n    -   $\\mathrm{R}_{34}$ completes at $t = 55/6 + 1/6 = 56/6\\ \\text{ms}$.\n\nTotal time for FCFS = $56/6\\ \\text{ms} = 28/3\\ \\text{ms} \\approx 9.33\\ \\text{ms}$.\n\n**Shortest Seek Time First (SSTF) Analysis**\n\nAt $t=0$, the head is at $c=10$. SSTF will service all requests on $c=10$ (seek distance $0$) before servicing requests on $c=11$ (seek distance $1$).\n\n1.  **Service all requests on cylinder $10$**:\n    -   The requests on $c=10$ are for sectors $s \\in \\{30, \\dots, 59\\}$ and $s \\in \\{20, 25\\}$.\n    -   At $t=0$, the head is at $c=10$, position $s=30$. To minimize rotational latency, the scheduler first services the contiguous block $s=30, \\dots, 59$.\n    -   Time to read $s=30, \\dots, 59$ (30 sectors) = $30 \\times T_s = 5\\ \\text{ms}$.\n    -   At $t=5\\ \\text{ms}$, this block is finished. The angular position is the start of $s=0$.\n    -   The next requests on $c=10$ are $s=20$ and $s=25$. To minimize latency, $s=20$ is serviced next.\n    -   The head must wait for sectors $0, \\dots, 19$ to pass (a distance of $20$ sectors).\n    -   Rotational latency = $20 \\times T_s = 20 \\times (1/6) = 10/3\\ \\text{ms}$.\n    -   Reading of $s=20$ begins at $t = 5 + 10/3 = 25/3\\ \\text{ms}$. Transfer time is $T_s = 1/6\\ \\text{ms}$.\n    -   $s=20$ is complete at $t=25/3 + 1/6 = 51/6\\ \\text{ms}$. Position is now start of $s=21$.\n    -   Next is $s=25$. The head must wait for sectors $21, \\dots, 24$ (a distance of $4$ sectors).\n    -   Rotational latency = $4 \\times T_s = 4 \\times (1/6) = 2/3\\ \\text{ms}$.\n    -   Reading of $s=25$ begins at $t = 51/6 + 2/3 = 55/6\\ \\text{ms}$. Transfer time is $T_s = 1/6\\ \\text{ms}$.\n    -   All requests on $c=10$ are complete at $t=55/6+1/6=56/6 = 28/3\\ \\text{ms}$.\n    -   At this time, the head is at $c=10$, and the angular position is the start of $s=26$.\n\n2.  **Service requests on cylinder $11$**:\n    -   The only remaining requests are for $(c=11, s=0)$ and $(c=11, s=1)$. A seek from $c=10$ to $c=11$ is performed.\n    -   Seek time = $t_{tt} = 1\\ \\text{ms}$. The seek finishes at $t = 28/3 + 1 = 31/3\\ \\text{ms}$.\n    -   During this $1\\ \\text{ms}$ seek, the disk rotates by $6$ sectors.\n    -   The new angular position is the start of sector $s = 26 + 6 = 32$.\n    -   The request is for logical sector $s=0$ on $c=11$. The physical position of this sector is aligned with logical sector $s=0+K=6$ on $c=10$.\n    -   The head is at physical position $32$ and needs to wait for physical position $6$. This requires waiting for almost a full rotation.\n    -   The forward angular distance is $(6 - 32 + 60) \\pmod{60} = 34$ sectors.\n    -   Rotational latency = $34 \\times T_s = 34 \\times (1/6) = 17/3\\ \\text{ms}$.\n    -   Reading begins at $t = 31/3 + 17/3 = 48/3 = 16\\ \\text{ms}$.\n    -   The $2$ contiguous sectors $(11,0)$ and $(11,1)$ are read.\n    -   Transfer time = $2 \\times T_s = 2 \\times (1/6) = 1/3\\ \\text{ms}$.\n    -   The batch is complete at $t = 16 + 1/3 = 49/3\\ \\text{ms}$.\n\nTotal time for SSTF = $49/3\\ \\text{ms} \\approx 16.33\\ \\text{ms}$.\n\n**Conclusion of Derivation**\n-   FCFS completion time: $\\approx 9.33\\ \\text{ms}$.\n-   SSTF completion time: $\\approx 16.33\\ \\text{ms}$.\n\nFCFS is substantially faster than SSTF for this specific workload. The reason is that the FCFS request order naturally forms a streaming read that crosses a cylinder boundary, and the disk's track skew of $K=6$ sectors perfectly compensates for the rotational distance traveled during the $1\\ \\text{ms}$ seek. SSTF, in its attempt to locally optimize by minimizing seek time, services all requests on the first cylinder. This breaks the sequential flow, causing it to \"miss the window\" for the track skew alignment and consequently incur a severe rotational latency penalty of nearly a full rotation when it eventually moves to the next cylinder.\n\n### Option-by-Option Analysis\n\n**A. FCFS completes the batch in approximately $10.5\\ \\text{ms}$, whereas SSTF takes approximately $15.8\\ \\text{ms}$, because FCFS preserves a sequential cross-cylinder run that benefits from track skew, while SSTF’s reordering to same-cylinder requests breaks that alignment and incurs large rotational latencies before and after the cylinder change.**\n\n-   My calculation yields $t_{FCFS} \\approx 9.33\\ \\text{ms}$ and $t_{SSTF} \\approx 16.33\\ \\text{ms}$. The quantitative values in the option ($10.5\\ \\text{ms}$ and $15.8\\ \\text{ms}$) are numerically incorrect.\n-   However, the qualitative reasoning provided is entirely correct. It correctly identifies that FCFS is faster and accurately explains that this is due to FCFS benefiting from track skew, while SSTF's reordering leads to large rotational latency. Among the given choices, this option provides the best description of the physical behavior and relative performance.\n-   Verdict: **Correct**, in the sense that it is the 'best description' despite numerical inaccuracies.\n\n**B. SSTF completes the batch in approximately $9.7\\ \\text{ms}$, because minimizing seek distance always reduces total time, and track skew does not affect the outcome.**\n\n-   This option claims SSTF is faster, which contradicts the derivation ($16.33\\ \\text{ms}$ vs $9.33\\ \\text{ms}$). The quantitative value is also incorrect.\n-   The reasoning is flawed. \"Minimizing seek distance always reduces total time\" is a common fallacy that this problem demonstrates is false; rotational latency can be a much larger factor. The claim that \"track skew does not affect the outcome\" is also false, as track skew is the critical factor in this problem.\n-   Verdict: **Incorrect**.\n\n**C. FCFS and SSTF tie at approximately $12.0\\ \\text{ms}$, because rotational latency dominates equally regardless of request order when all requests are present at time $0$.**\n\n-   The claim of a tie is false; FCFS is much faster. The quantitative value is incorrect for both.\n-   The reasoning is incorrect. Rotational latency is highly dependent on the request order, which is the central lesson of this problem.\n-   Verdict: **Incorrect**.\n\n**D. The outcome cannot be determined without additional parameters about head settling time and sector interleaving, so neither scheduler can be shown to outperform the other with the given data.**\n\n-   The problem is well-posed and contains sufficient information to determine the outcome. Standard models assume head settling time is included in the seek time unless specified otherwise. Sector interleaving is not a required concept to solve this problem as stated.\n-   Verdict: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "3635439"}]}