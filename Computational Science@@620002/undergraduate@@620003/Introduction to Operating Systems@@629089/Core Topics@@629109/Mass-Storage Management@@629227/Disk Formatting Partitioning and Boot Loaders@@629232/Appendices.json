{"hands_on_practices": [{"introduction": "Understanding the fundamental limitations of a technology is the first step toward appreciating its evolution. The Master Boot Record (MBR) was the standard for disk partitioning for decades, but its design imposed a hard ceiling on storage capacity. This exercise guides you through a foundational calculation to derive the famous \"2 TiB limit\" of MBR from first principles, connecting the binary width of an address field to a critical real-world hardware constraint. By working through this, you will see exactly why the industry had to move toward modern standards like the GUID Partition Table (GPT) [@problem_id:3635143].", "problem": "A storage subsystem is deployed with legacy boot requirements that mandate the Master Boot Record (MBR) layout. In MBR, partition entries and boot-time code assume Logical Block Addressing (LBA), where each address is a fixed-width unsigned integer that selects a sector. Suppose the following hold:\n- The bit-width of the LBA field in MBR is $32$ bits.\n- Each sector has size $s = 512$ bytes.\n- The operating system addresses storage strictly at the sector granularity; for any fixed width $w$ bits, the number of uniquely addressable sectors is $2^{w}$, and the total addressable capacity is the product of the number of sectors and sector size.\n\nStarting from these principles of binary addressing and the definition of sector-sized blocks, derive the maximum addressable capacity under MBR and express it in tebibytes, where $1$ tebibyte (TiB) equals $2^{40}$ bytes. Then, briefly explain conceptually why moving to a Globally Unique Identifier Partition Table (GPT) with $64$-bit LBA expands the theoretical capacity, and relate this change to boot loader and firmware roles (for example, the protective MBR used alongside GPT and the role typically played by the Unified Extensible Firmware Interface (UEFI)). Your explanation should be qualitative; do not provide a second numerical result as part of your final answer.\n\nExpress your final numerical answer as a single real number in tebibytes. No rounding is required because the value is exact, and do not include units in your final numerical answer.", "solution": "The problem statement is evaluated for validity before a solution is attempted.\n\n### Step 1: Extract Givens\n- The partitioning scheme is Master Boot Record (MBR).\n- The addressing scheme is Logical Block Addressing (LBA).\n- The bit-width of the LBA field in MBR is $w = 32$ bits.\n- The size of each sector is $s = 512$ bytes.\n- For a bit-width of $w$, the number of uniquely addressable sectors is $2^w$.\n- Total addressable capacity is the product of the number of sectors and the sector size.\n- $1$ tebibyte (TiB) is defined as $2^{40}$ bytes.\n- The Globally Unique Identifier Partition Table (GPT) uses $64$-bit LBA.\n- The task requires a calculation of the maximum addressable capacity for MBR in TiB and a conceptual explanation of the capacity increase with GPT, relating it to boot loaders and firmware.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes the real-world technical specifications and limitations of the MBR partitioning scheme, which is a fundamental topic in computer operating systems and data storage. The values provided ($32$-bit addressing, $512$-byte sectors) are historically standard and factually correct. The problem provides all necessary information for the calculation and a clear directive for the conceptual explanation. The question is unambiguous and its premises are internally consistent and based on established principles of binary addressing. There are no violations of scientific principles, logical fallacies, or unrealistic conditions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Derivation of Maximum Addressable Capacity\n\nThe maximum addressable capacity of a storage device under a given addressing scheme is determined by two factors: the total number of addressable units and the size of each unit.\n\nLet $w$ be the bit-width of the address field. The problem states that for MBR, the LBA field has a bit-width of $w = 32$. The number of unique addresses, and therefore the number of uniquely addressable sectors ($N_{sectors}$), is given by the total number of combinations possible with $w$ bits, which is $2^w$.\n$$N_{sectors} = 2^w = 2^{32}$$\n\nThe problem specifies that the size of each sector, $s$, is $512$ bytes. To facilitate calculations with powers of two, we express the sector size in this form:\n$$s = 512 \\text{ bytes} = 2^9 \\text{ bytes}$$\n\nThe total addressable capacity, $C_{total}$, is the product of the number of addressable sectors and the size of each sector.\n$$C_{total} = N_{sectors} \\times s$$\nSubstituting the values derived above:\n$$C_{total} = (2^{32}) \\times (2^9 \\text{ bytes})$$\nUsing the property of exponents $a^m \\times a^n = a^{m+n}$, we find the total capacity in bytes:\n$$C_{total} = 2^{32+9} \\text{ bytes} = 2^{41} \\text{ bytes}$$\n\nThe problem requires the final answer to be expressed in tebibytes (TiB). The conversion factor is given as $1 \\text{ TiB} = 2^{40} \\text{ bytes}$. To convert the total capacity from bytes to TiB, we divide by this conversion factor:\n$$C_{\\text{TiB}} = \\frac{C_{total}}{1 \\text{ TiB in bytes}} = \\frac{2^{41} \\text{ bytes}}{2^{40} \\text{ bytes}}$$\nUsing the property of exponents $a^m / a^n = a^{m-n}$:\n$$C_{\\text{TiB}} = 2^{41-40} = 2^1 = 2$$\nTherefore, the maximum addressable storage capacity under the MBR partitioning scheme is $2$ TiB.\n\n### Conceptual Explanation of GPT and Firmware Roles\n\nThe transition from MBR to the Globally Unique Identifier Partition Table (GPT) scheme fundamentally expands storage capacity by increasing the bit-width of the LBA field. GPT employs $64$-bit LBA. The number of addressable sectors thus increases from $2^{32}$ to $2^{64}$. Since the number of addressable units grows exponentially with the bit-width, this change results in a theoretical capacity of $2^{64} \\times 2^9 = 2^{73}$ bytes, or $2^{33}$ TiB ($8$ zettabytes), an astronomically larger address space. This exponential increase is the core reason for GPT's superior capacity.\n\nThis architectural change is deeply intertwined with the evolution of system firmware from legacy BIOS (Basic Input/Output System) to UEFI (Unified Extensible Firmware Interface).\n1.  **Firmware's Role:** Legacy BIOS is designed to boot from an MBR. It does so by reading the first $512$-byte sector of a disk, which contains both the partition table and the initial boot loader code, and executing that code. BIOS firmware and its associated boot loaders are generally unaware of the GPT format and are limited by the $32$-bit LBA inherent to the MBR structure they were designed to handle. In contrast, UEFI is a modern firmware standard designed specifically to overcome the limitations of BIOS. UEFI does not execute code from a boot sector; instead, it understands file systems (like FAT32) and directly loads an EFI boot loader application from a dedicated EFI System Partition (ESP). This mechanism allows UEFI to natively parse the GPT structure and utilize its full $64$-bit LBA, thereby enabling the operating system to access disks far larger than the $2$ TiB MBR limit.\n\n2.  **The Protective MBR:** To ensure backward compatibility and prevent data loss, a GPT-formatted disk includes a \"protective MBR\" in the first sector (LBA $0$), where a legacy BIOS would expect to find a standard MBR. This protective MBR contains a single partition entry of type `0xEE` that defines a partition spanning the entire disk, up to the maximum size representable by MBR's $32$-bit LBA ($2$ TiB). This single entry serves to make the disk appear \"occupied\" to legacy, MBR-only utilities, preventing them from mistakenly identifying the disk as unpartitioned and potentially overwriting the GPT data that follows. A UEFI-aware system recognizes the GPT signature and ignores this protective MBR, proceeding to read the actual GPT header and partition table, while a legacy BIOS system will see the protective partition and halt, correctly identifying that it cannot boot from or manage the disk.\n\nIn summary, the capacity expansion is a direct result of moving from $32$-bit to $64$-bit LBA. This move was enabled by replacing the legacy BIOS/MBR boot process with the more sophisticated UEFI/GPT standard, which provides a modern framework for initializing hardware and booting operating systems from very large storage devices.", "answer": "$$\n\\boxed{2}\n$$", "id": "3635143"}, {"introduction": "Beyond the grand scale of total capacity, the performance of a storage device can be sensitive to microscopic details of its layout. One such detail is partition alignment, where the starting point of a partition may not line up perfectly with the underlying filesystem's block structure or the physical geometry of the drive. This practice problem delves into this concept by having you calculate the misalignment offset for a common legacy partition setup, revealing how historical conventions can create performance bottlenecks on modern hardware [@problem_id:3635065].", "problem": "A storage device uses Logical Block Addressing (LBA), where each logical sector has size $s$ bytes. Under LBA, the starting byte address of a partition that begins at LBA index $L$ is $L \\times s$. A filesystem placed on this partition uses fixed-size filesystem blocks of size $b$ bytes (for example, $b = 4$ KiB). By definition, the partition start is block-aligned if and only if the starting byte address is an integer multiple of $b$. The misalignment offset $a$ is the smallest non-negative number of bytes that must be subtracted from the starting byte address to reach the nearest preceding filesystem block boundary. Equivalently, $a$ is the unique integer in the range $[0, b)$ satisfying $L \\times s = q \\times b + a$ for some integer $q$.\n\nConsider a legacy Master Boot Record (MBR) partition table in which the first partition begins at $L = 63$. The device has sector size $s = 512$ bytes, and the filesystem uses block size $b = 4096$ bytes (that is, $b = 4$ KiB, where kibibyte (KiB) denotes $1024$ bytes). Using only the definitions above, first derive an expression for the misalignment offset $a$ in terms of $L$, $s$, and $b$, and then evaluate it numerically for these parameters.\n\nExpress your final answer as an exact integer number of bytes. Do not include units in your final boxed answer.", "solution": "The problem requires the derivation of a general expression for the misalignment offset $a$ and its numerical evaluation for a specific case.\n\nFirst, we derive the general expression for $a$. The problem statement provides two equivalent definitions for the misalignment offset $a$. The second definition is a formal mathematical statement: $a$ is the unique integer in the range $[0, b)$ satisfying the equation $L \\times s = q \\times b + a$ for some integer $q$. This equation is the definition of the division algorithm, where $L \\times s$ is the dividend, $b$ is the divisor, $q$ is the quotient, and $a$ is the remainder.\n\nIn the language of modular arithmetic, the remainder $a$ of the division of an integer $N$ by an integer $M$ is written as $N \\pmod M$. Therefore, we can express the misalignment offset $a$ directly in terms of $L$, $s$, and $b$ as:\n$$a = (L \\times s) \\pmod b$$\nThis is the general expression for the misalignment offset.\n\nNext, we evaluate this expression for the specified parameters:\n- Partition start LBA index: $L = 63$\n- Sector size: $s = 512$ bytes\n- Filesystem block size: $b = 4096$ bytes\n\nSubstituting these values into our derived expression:\n$$a = (63 \\times 512) \\pmod{4096}$$\n\nTo compute this value, we can first calculate the product $L \\times s$:\n$$L \\times s = 63 \\times 512 = 32256$$\nSo, the starting byte address of the partition is $32256$. Now we compute the remainder of this address when divided by the block size $b = 4096$:\n$$a = 32256 \\pmod{4096}$$\n\nAlternatively, we can use the properties of the given numbers to simplify the calculation. We observe that the filesystem block size $b$ is an integer multiple of the sector size $s$:\n$$\\frac{b}{s} = \\frac{4096}{512} = 8$$\nSo, we can write $b = 8s$. Substituting this into the expression for $a$:\n$$a = (L \\times s) \\pmod{8s}$$\nWith $L=63$, we have:\n$$a = (63 \\times s) \\pmod{8s}$$\nWe can express $L=63$ in terms of the number $8$ using the division algorithm:\n$$63 = 7 \\times 8 + 7$$\nSubstitute this form of $L$ back into the expression for $a$:\n$$a = ((7 \\times 8 + 7) \\times s) \\pmod{8s}$$\nUsing the distributive property of multiplication over addition:\n$$a = (7 \\times 8 \\times s + 7 \\times s) \\pmod{8s}$$\n$$a = (7 \\times (8s) + 7s) \\pmod{8s}$$\nThe term $7 \\times (8s)$ is an integer multiple of the modulus $8s$. Therefore, its remainder is $0$:\n$$(7 \\times (8s)) \\pmod{8s} = 0$$\nThis simplifies our expression for $a$:\n$$a = (0 + 7s) \\pmod{8s}$$\n$$a = 7s \\pmod{8s}$$\nWe have $s=512$, so $7s = 7 \\times 512 = 3584$ and $8s = 8 \\times 512 = 4096$.\nSince $0 \\le 7s < 8s$ (that is, $0 \\le 3584 < 4096$), the remainder of $7s$ divided by $8s$ is simply $7s$.\n$$a = 7s$$\nFinally, we calculate the numerical value:\n$$a = 7 \\times 512 = 3584$$\nThe misalignment offset is $3584$ bytes. This result is consistent with the direct calculation: $32256 = 7 \\times 4096 + 3584$, which shows that the remainder of $32256$ divided by $4096$ is indeed $3584$. The value $a=3584$ is in the required range $[0, 4096)$.", "answer": "$$\\boxed{3584}$$", "id": "3635065"}, {"introduction": "A solid grasp of disk structures is most valuable when things go wrong. This final practice moves from static disk layouts to the dynamic process of booting and presents a realistic failure scenario. By injecting a hypothetical corruption into the Master Boot Record's executable code, you are challenged to reason through the step-by-step boot sequence of a legacy BIOS system. This exercise will test your detailed understanding of the division of labor between the BIOS firmware and the MBR's boot loader, a critical skill for effective system troubleshooting and data recovery [@problem_id:3635130].", "problem": "A disk follows the conventional Basic Input/Output System (BIOS) boot model with a Master Boot Record (MBR). The MBR occupies the first sector of the disk and has three regions: the initial boot code region, the partition table region, and the signature. Consider a failure-injection experiment where the first $n$ bytes of the MBR are corrupted with arbitrary data, where $n = 446$. All other bytes in the MBR are intact, and the disk has two primary partitions, $p_1$ and $p_2$, with $p_2$ containing a valid Volume Boot Record (VBR) and a functional boot loader that can load an operating system. The partition table entries for $p_1$ and $p_2$ are correct, and the final two signature bytes are set to $0x55AA$. Boot order is set to attempt this disk first.\n\nStart from the following base facts about the BIOS-MBR-VBR boot chain to reason about system behavior:\n- Under BIOS, the firmware reads the first sector ($512$ bytes) of the selected boot device into memory (commonly at physical address $0x7C00$), checks for the signature $0x55AA$ in the last $2$ bytes, and then transfers control to whatever code resides in that sector.\n- In an MBR scheme, the first $446$ bytes typically contain executable boot code that parses the partition table (the next $64$ bytes, consisting of $4$ entries of $16$ bytes each) to locate an active partition and then loads that partition’s VBR (the first sector of that partition, by its Logical Block Addressing (LBA) start or Cylinder-Head-Sector (CHS) coordinates) into memory and transfers control to it.\n- If the MBR boot code is corrupt, the BIOS does not itself parse the partition table; it merely executes the loaded code. If that code is invalid, the system behavior may include a hang, a fault, or unpredictable instructions being executed.\n\nYou are asked to reason about whether and how a fallback boot using chainloading from $p_2$ can succeed in this scenario, and under what conditions. Which statement is most accurate?\n\nA. Because the signature $0x55AA$ and the partition table are intact, the BIOS will automatically consult the partition table and proceed to load the VBR of $p_2$ if the MBR code fails, resulting in a successful boot from $p_2$.\n\nB. The system will not automatically boot from this disk due to corrupt MBR code, but a boot manager started from a different device can still chainload $p_2$ by reading the disk’s partition table (or using a known LBA start of $p_2$), loading $p_2$’s VBR into memory (e.g., at $0x7C00$), and transferring control to it, thereby achieving a fallback boot.\n\nC. Marking $p_2$ as the active partition in the intact partition table ensures that the BIOS will directly bypass the MBR and load the VBR of $p_2$, allowing normal boot from $p_2$ even when the first $446$ bytes are corrupt.\n\nD. The BIOS uses only the last $2$ bytes of the MBR to decide bootability; since $0x55AA$ is present, the BIOS will ignore the corrupted $446$ bytes and proceed normally to load the VBR of $p_2$ from the partition table.\n\nE. Reinstalling Boot Configuration Data (BCD) onto $p_2$ is sufficient because the BIOS can execute boot code located anywhere within the first track as long as the signature $0x55AA$ is present, so the corrupt first $446$ bytes will be bypassed and a fallback boot from $p_2$ will occur.", "solution": "The problem statement will be validated first by analyzing its components and premises based on the established principles of computer architecture and operating system boot processes.\n\n**Step 1: Extract Givens**\n\n-   **System Model:** Basic Input/Output System (BIOS) boot model with a Master Boot Record (MBR).\n-   **MBR Structure:** The MBR occupies the first sector of the disk. It comprises three regions: initial boot code, partition table, and signature. A standard sector size of $512$ bytes is implied.\n-   **Corruption Scenario:** The first $n = 446$ bytes of the MBR are corrupted with arbitrary data.\n-   **Intact Components:** All other bytes in the MBR are intact. This includes the partition table region ($64$ bytes, from byte $446$ to $509$) and the signature region (last $2$ bytes, $510$ and $511$).\n-   **Partitions:** The disk has two primary partitions, $p_1$ and $p_2$.\n-   **Partition State:** The partition table entries for $p_1$ and $p_2$ are correct. Partition $p_2$ contains a valid Volume Boot Record (VBR) and a functional boot loader capable of loading an operating system.\n-   **Signature:** The final two signature bytes of the MBR are correctly set to $0x55AA$.\n-   **Boot Configuration:** The BIOS boot order is set to attempt booting from this disk first.\n-   **Base Facts (Axioms for this problem):**\n    1.  The BIOS reads the first $512$-byte sector of the selected boot device into memory (e.g., at address $0x7C00$).\n    2.  The BIOS checks for the signature $0x55AA$ in the last $2$ bytes of the loaded sector.\n    3.  If the signature is valid, the BIOS transfers control (jumps) to the code loaded into memory.\n    4.  Standard MBR boot code (the first $446$ bytes) is responsible for parsing the partition table, locating an active partition, loading that partition's VBR, and transferring control to it.\n    5.  The BIOS itself does not parse the partition table.\n    6.  Executing corrupt code can lead to a system hang, fault, or other unpredictable behavior.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding:** The problem is firmly grounded in the well-documented and standard BIOS-MBR boot process used by personal computers for decades. The structure of the MBR ($446$ bytes for code, $64$ bytes for the partition table, $2$ bytes for the signature, totaling $512$ bytes), the role of the BIOS, the memory address $0x7C00$, the boot signature $0x55AA$, and the concept of chainloading from MBR to VBR are all factually correct and standard in computer science education.\n-   **Well-Posedness:** The problem sets up a specific failure scenario and asks for a logical deduction of its consequences. The provided \"base facts\" act as axioms, ensuring that the reasoning follows a specific, non-ambiguous model of the system. The question asks for the \"most accurate\" statement, which implies a comparative analysis leading to a single best answer.\n-   **Objectivity:** The problem statement uses precise, technical language (e.g., `$n = 446$ bytes`, `corrupted with arbitrary data`, `valid Volume Boot Record`, `chainloading`). It is free from subjective or non-technical jargon.\n\nThe problem statement does not violate any of the invalidity criteria. It is scientifically sound, well-posed, objective, and complete for the question asked.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. A solution will be derived.\n\n**Derivation of System Behavior**\n\n1.  **BIOS Initialization:** Upon power-on, the BIOS executes its start-up routines (POST) and then determines the boot device from the configured boot order. In this case, it is the specified disk.\n2.  **MBR Load:** Following the provided base facts, the BIOS reads the first sector ($512$ bytes) of the disk into memory at the conventional address $0x7C00$.\n3.  **Signature Check:** The BIOS then inspects the last two bytes of the data it just loaded into memory. The problem states these bytes are intact and hold the value $0x55AA$. The BIOS check passes, so the BIOS considers this a bootable sector.\n4.  **Control Transfer:** Having validated the sector, the BIOS's next and final action for this device is to transfer execution control to the beginning of the loaded data, i.e., it jumps to address $0x7C00$.\n5.  **Execution of Corrupt Code:** The CPU begins executing instructions starting from address $0x7C00$. The problem states that the first $446$ bytes at this location consist of \"arbitrary data.\" This data will be interpreted by the CPU as machine code. This is not the valid MBR boot loader code. The result is unpredictable but will certainly not involve the correct logic of parsing a partition table. As the base facts note, this will likely lead to an immediate system crash, an infinite loop, an illegal instruction fault, or other undefined behavior. The system will fail to boot from this disk on its own.\n6.  **BIOS Role Limitations:** Crucially, the BIOS does not monitor the code it launched. It has no mechanism to detect the failure of the MBR code and then take corrective action, such as parsing the partition table itself. The base facts confirm this: \"the BIOS does not itself parse the partition table.\" Therefore, any automatic recovery initiated by the BIOS on the same disk is impossible.\n7.  **Fallback Scenario (Chainloading):** The question asks about a fallback boot. Since the disk itself is unbootable, a fallback must be initiated by an external agent. This would typically be a boot manager loaded from a different device (e.g., a USB stick, a CD-ROM, or another hard disk selected after the first one failed and the system rebooted or was manually restarted).\n8.  **External Boot Manager Action:** Let's assume such an external boot manager is running. This software can access all connected hardware, including the original disk with the corrupted MBR.\n    -   The external boot manager can be instructed to read the MBR of the original disk.\n    -   While it would see the corrupt boot code in the first $446$ bytes, it would also find the **intact** partition table at offset $446$.\n    -   By correctly parsing this table, it can determine the location (e.g., Logical Block Address or LBA) of partition $p_2$.\n    -   The problem states $p_2$ contains a valid VBR. The external boot manager can read this VBR (the first sector of $p_2$) into memory (e.g., to address $0x7C00$, mimicking a normal MBR).\n    -   Finally, the external boot manager can transfer control to the VBR code it just loaded. Since this VBR and its associated boot loader are functional, they will proceed to load the operating system from $p_2$. This process is known as chainloading.\n\n**Conclusion:** The system cannot boot from the disk automatically. However, booting from partition $p_2$ is possible via manual intervention using a boot manager from another source that can read the intact partition table on the failed disk.\n\n**Option-by-Option Analysis**\n\n**A. Because the signature $0x55AA$ and the partition table are intact, the BIOS will automatically consult the partition table and proceed to load the VBR of $p_2$ if the MBR code fails, resulting in a successful boot from $p_2$.**\n-   **Analysis:** This statement is incorrect. It claims the BIOS will consult the partition table. This directly contradicts base fact #5: \"the BIOS does not itself parse the partition table.\" The BIOS's only job after the signature check is to transfer control to the code at the beginning of the sector. It has no concept of a partition table or a VBR.\n-   **Verdict:** Incorrect.\n\n**B. The system will not automatically boot from this disk due to corrupt MBR code, but a boot manager started from a different device can still chainload $p_2$ by reading the disk’s partition table (or using a known LBA start of $p_2$), loading $p_2$’s VBR into memory (e.g., at $0x7C00$), and transferring control to it, thereby achieving a fallback boot.**\n-   **Analysis:** This statement aligns perfectly with the derived behavior. It correctly identifies that the direct boot will fail due to corrupt MBR code. It then accurately describes the process of chainloading from an external boot manager: using a different boot device to start a program that reads the intact partition table on the faulty disk, locates the target partition ($p_2$), and loads its VBR to initiate the next stage of booting. This is the canonical method for recovering from this specific type of failure.\n-   **Verdict:** Correct.\n\n**C. Marking $p_2$ as the active partition in the intact partition table ensures that the BIOS will directly bypass the MBR and load the VBR of $p_2$, allowing normal boot from $p_2$ even when the first $446$ bytes are corrupt.**\n-   **Analysis:** This statement is incorrect. The \"active\" flag in a partition table entry is a piece of data to be interpreted by the MBR's boot code. The BIOS is completely unaware of this flag. Since the MBR's boot code is corrupt, it will never be executed, and therefore the active flag will never be read or acted upon. The BIOS cannot and will not \"bypass the MBR\" based on this flag.\n-   **Verdict:** Incorrect.\n\n**D. The BIOS uses only the last $2$ bytes of the MBR to decide bootability; since $0x55AA$ is present, the BIOS will ignore the corrupted $446$ bytes and proceed normally to load the VBR of $p_2$ from the partition table.**\n-   **Analysis:** This statement is partially correct but ultimately draws a false conclusion. The BIOS does indeed use the $0x55AA$ signature to determine if the sector is bootable. However, it does not \"ignore\" the preceding $446$ bytes. Its defined behavior is to *execute* those bytes. It also does not \"proceed normally to load the VBR,\" as this is the job of the MBR code, not the BIOS. The statement incorrectly ascribes the function of the MBR boot code to the BIOS itself.\n-   **Verdict:** Incorrect.\n\n**E. Reinstalling Boot Configuration Data (BCD) onto $p_2$ is sufficient because the BIOS can execute boot code located anywhere within the first track as long as the signature $0x55AA$ is present, so the corrupt first $446$ bytes will be bypassed and a fallback boot from $p_2$ will occur.**\n-   **Analysis:** This statement contains multiple factual errors. First, Boot Configuration Data (BCD) is a component of the modern Windows Boot Manager, which operates in both UEFI and BIOS-compatibility environments, but it is not the primary boot mechanism in the classic BIOS-MBR model described. The core boot code resides in the VBR itself. Second, the claim that the \"BIOS can execute boot code located anywhere within the first track\" is false. The BIOS boot protocol is rigid: it loads and executes code only from the very first logical sector (LBA $0$) of the designated boot device. It does not scan tracks. Therefore, the corrupt MBR code cannot be bypassed.\n-   **Verdict:** Incorrect.", "answer": "$$\\boxed{B}$$", "id": "3635130"}]}