{"hands_on_practices": [{"introduction": "One of the most fundamental rules for using condition variables is that any modification to the shared state (the predicate) and the subsequent signal must be protected by the associated mutex. This exercise explores the classic \"lost wakeup\" bug, which arises from a subtle race condition when this rule is violated. By tracing a specific interleaving of a waiter and a signaler [@problem_id:3627348], you will see precisely how a signal can be sent and lost before the waiter has a chance to block, leading to indefinite waiting.", "problem": "A program uses condition variables to notify a waiting thread when data is ready. The shared state is a Boolean predicate and synchronization objects: a Boolean variable $ready$ initialized to $0$, a mutual exclusion lock $mutex$, and a condition variable $cv$. The intended programming discipline is that the waiting thread (the \"waiter\") waits in a loop until the predicate $ready$ becomes $1$, and the notifying thread (the \"signaler\") sets $ready$ when data becomes available and then signals the condition variable to wake exactly one waiter. The actual program uses the following logic:\n\n- Waiter:\n  - $lock(mutex)$\n  - while $(ready == 0)$ do $cond\\_wait(cv, mutex)$\n  - $use\\_resource()$\n  - $unlock(mutex)$\n\n- Signaler (buggy version):\n  - $ready \\leftarrow 1$\n  - $cond\\_signal(cv)$\n\nAssume the standard semantics of condition variables as specified by the Portable Operating System Interface (POSIX): $cond\\_wait(cv, mutex)$ atomically releases $mutex$ and blocks the calling thread on $cv$ until it is woken, at which point it re-acquires $mutex$ before returning; $cond\\_signal(cv)$ wakes at most $1$ thread currently waiting on $cv$ (if any). Assume fair scheduling and no spurious failures of $lock(\\cdot)$ or $unlock(\\cdot)$. Spurious wakeups of $cond\\_wait$ are allowed by the specification but do not need to be relied on for correctness.\n\nSelect all correct statements about the possibility of a missed wake-up (the waiter blocks even though $ready = 1$) and how to fix the bug.\n\nA. The following interleaving of steps with the buggy signaler demonstrates a missed wake-up:\n- $W1$: waiter executes $lock(mutex)$.\n- $W2$: waiter evaluates the loop condition and finds $ready == 0$ is true.\n- $S1$: signaler executes $ready \\leftarrow 1$.\n- $S2$: signaler executes $cond\\_signal(cv)$; since no thread is yet waiting on $cv$, no thread is woken.\n- $W3$: waiter calls $cond\\_wait(cv, mutex)$, which atomically releases $mutex$ and blocks; there is no pending signal, so the waiter can now sleep indefinitely even though $ready = 1$.\n\nB. The atomic release-and-sleep behavior of $cond\\_wait(cv, mutex)$ alone prevents a missed wake-up in this program, even if the signaler does not acquire $mutex$.\n\nC. A correct fix is to have the signaler acquire $mutex$ before modifying $ready$, set $ready \\leftarrow 1$ while holding $mutex$, call $cond\\_signal(cv)$ still holding $mutex$, and then release $mutex$; this prevents a signal from occurring between the waiter’s evaluation of $ready$ and its call to $cond\\_wait$.\n\nD. Replacing $cond\\_signal(cv)$ with $cond\\_broadcast(cv)$ in the buggy signaler (still without holding $mutex$) eliminates the possibility of a missed wake-up in this program.\n\nChoose all that apply.", "solution": "The problem statement describes a classic race condition in concurrent programming known as a \"missed wake-up\" or \"lost signal\" when using condition variables without proper mutual exclusion. The core of the issue lies in the interaction between the waiter thread and the buggy signaler thread. The shared state consists of a Boolean predicate, $ready$, a mutex, $mutex$, and a condition variable, $cv$. The correct use of condition variables requires that any access to the shared state (the predicate $ready$)—both for reading/checking and for writing/modifying—must be protected by the associated mutex.\n\nThe waiter's logic is correct:\n1.  `lock(mutex)`\n2.  `while (ready == 0) do cond_wait(cv, mutex)`\n3.  `use_resource()`\n4.  `unlock(mutex)`\n\nThe `while` loop correctly handles spurious wakeups by re-checking the condition $ready$. The `cond_wait(cv, mutex)` call is performed while holding the $mutex$, which is the correct protocol.\n\nThe signaler's buggy logic is:\n1.  `ready - 1`\n2.  `cond_signal(cv)`\n\nThe bug is that the signaler modifies the shared variable $ready$ and signals $cv$ without holding the $mutex$. This allows for a race condition. A \"missed wake-up\" occurs if the signaler executes its logic in the time window after the waiter has checked the condition `ready == 0` but before it has called `cond_wait` to begin waiting.\n\nLet's analyze this specific interleaving:\n1.  The waiter thread acquires the lock: `lock(mutex)`.\n2.  The waiter thread evaluates the loop condition `while (ready == 0)`. Since $ready$ was initialized to $0$, the condition is true. The waiter is about to call `cond_wait(cv, mutex)`.\n3.  A context switch occurs, and the waiter thread is preempted.\n4.  The signaler thread begins execution.\n5.  The signaler sets `ready - 1`.\n6.  The signaler calls `cond_signal(cv)`. At this moment, no thread is waiting on $cv$ (the waiter has not yet executed `cond_wait`), so the signal is lost. It has no effect.\n7.  A context switch occurs, and the waiter thread resumes execution.\n8.  The waiter was preempted right before calling `cond_wait`. It now executes `cond_wait(cv, mutex)`. This function atomically releases $mutex$ and puts the waiter thread to sleep, waiting on $cv$.\n9.  The waiter is now blocked. The predicate $ready$ is $1$, but the signal that would have woken the waiter has already occurred and was lost. The waiter will sleep indefinitely, unless another, unrelated signal occurs. This constitutes a missed wake-up.\n\nBased on this analysis, we can evaluate each option.\n\n**A. The following interleaving of steps with the buggy signaler demonstrates a missed wake-up: ...**\nThis sequence of events is precisely the race condition described in the analysis above. It correctly identifies the critical window between the waiter checking the predicate and blocking on the condition variable, and shows how the buggy signaler can exploit this window to create a missed wake-up. This statement is correct.\n\n**B. The atomic release-and-sleep behavior of `cond_wait(cv, mutex)` alone prevents a missed wake-up in this program, even if the signaler does not acquire `mutex`.**\nThis statement is false. The atomicity of `cond_wait(cv, mutex)` is crucial, but it only solves the problem of a race condition *within* the `cond_wait` call itself. It does not and cannot prevent the race condition described in option A, which happens *before* `cond_wait` is even called. The signal is lost before the waiter begins the atomic \"release and wait\" operation.\n\n**C. A correct fix is to have the signaler acquire `mutex` before modifying `ready`, set `ready - 1` while holding `mutex`, call `cond_signal(cv)` still holding `mutex`, and then release `mutex`; ...**\nThis describes the canonical, correct usage of a condition variable. With this fix, the mutual exclusion provided by $mutex$ ensures that if the waiter gets the lock first, it will successfully block on `cond_wait` before the signaler can run. If the signaler gets the lock first, it sets $ready$ to $1$, and the waiter will see this and never need to wait. In both cases, the missed wake-up is prevented. The reasoning provided—that this fix \"prevents a signal from occurring between the waiter’s evaluation of `ready` and its call to `cond_wait`\"—is precisely why this solution works. This statement is correct.\n\n**D. Replacing `cond_signal(cv)` with `cond_broadcast(cv)` in the buggy signaler (still without holding `mutex`) eliminates the possibility of a missed wake-up in this program.**\nThis statement is false. The race condition occurs because the notification (whether a signal or a broadcast) is sent when *no threads are on the wait queue*. If no threads are waiting, both `cond_signal` and `cond_broadcast` have no effect. The same interleaving from option A can still occur, leading to a lost notification and a permanently sleeping waiter.", "answer": "$$\\boxed{AC}$$", "id": "3627348"}, {"introduction": "Even when the mutex is used correctly, a thread has no guarantee that the condition it was waiting for is still true when it awakens from a `cond_wait` call. This is because another thread may have \"stolen\" the resource in the interim, or the thread may have experienced a \"spurious wakeup,\" a phenomenon allowed by standards like POSIX. This practice [@problem_id:3687098] uses the bounded-buffer problem to demonstrate why guarding your wait call with a simple `if` statement is a critical error and how a `while` loop is essential for writing correct and robust concurrent code.", "problem": "Consider the bounded-buffer producer-consumer problem with shared buffer capacity $B$ and a shared counter $count$ that tracks the number of items currently in the buffer. The system enforces mutual exclusion via a mutual exclusion lock (mutex) $m$, and uses two condition variables (CVs), $notEmpty$ and $notFull$, respectively associated with the predicates $count > 0$ and $count  B$. The Portable Operating System Interface (POSIX) semantics for condition variables stipulate that $cond\\_wait(cv,m)$ atomically releases $m$ and suspends the calling thread, then reacquires $m$ before returning; $cond\\_signal(cv)$ wakes at least one waiting thread, but signals are not remembered if no thread is currently waiting, and spurious wakeups may occur.\n\nSuppose a practitioner incorrectly implements the wait protocols using $if$ instead of $while$:\n- Consumer (incorrect): acquire $m$; if $count = 0$ then $cond\\_wait(notEmpty,m)$; remove an item; $count \\leftarrow count - 1$; $cond\\_signal(notFull)$; release $m$.\n- Producer (incorrect): acquire $m$; if $count = B$ then $cond\\_wait(notFull,m)$; insert an item; $count \\leftarrow count + 1$; $cond\\_signal(notEmpty)$; release $m$.\n\nBy fundamental invariants of the bounded buffer, correct implementations must maintain $0 \\le count \\le B$ at all times and must avoid indefinite blocking when the predicate $count > 0$ or $count  B$ becomes true. Select all scenarios below that can lead to a violation of $0 \\le count \\le B$ or to indefinite blocking, specifically because the predicate is guarded by $if$ instead of $while$, and explainable from first principles of condition variable semantics and the roles of $count$ and $B$.\n\nA. Initial state: $B = 3$, $count = 0$. Two consumers $C_1$ and $C_2$ are waiting on $notEmpty$ (both previously executed the incorrect $if$-guarded check and entered $cond\\_wait$). A producer $P$ performs: acquire $m$; insert; $count \\leftarrow 1$; $cond\\_signal(notEmpty)$; release $m$. Immediately after, a third consumer $C_3$ (which was not waiting) arrives: acquire $m$; observe $count > 0$; remove; $count \\leftarrow 0$; $cond\\_signal(notFull)$; release $m$. Then $C_1$ returns from $cond\\_wait$, reacquires $m$, and — because its predicate was checked via $if$ before it slept — proceeds directly to remove without rechecking, performing $count \\leftarrow -1$.\n\nB. Initial state: $B = 2$, $count = B$. Two producers $P_1$ and $P_2$ are waiting on $notFull$ (both previously executed the incorrect $if$-guarded check and entered $cond\\_wait$). A consumer $C$ performs: acquire $m$; remove; $count \\leftarrow B - 1$; $cond\\_signal(notFull)$; release $m$. Immediately after, a third producer $P_3$ (which was not waiting) arrives: acquire $m$; observe $count  B$; insert; $count \\leftarrow B$; $cond\\_signal(notEmpty)$; release $m$. Then $P_1$ returns from $cond\\_wait$, reacquires $m$, and — because its predicate was checked via $if$ before it slept — proceeds directly to insert without rechecking, performing $count \\leftarrow B + 1$.\n\nC. Initial state: $B = 4$, $count = 0$. A consumer $C$ executes: acquire $m$; observe $count = 0$; decide to sleep; before $C$ calls $cond\\_wait(notEmpty,m)$, a producer $P$ performs: acquire $m$; insert; $count \\leftarrow 1$; $cond\\_signal(notEmpty)$; release $m$. Then $C$ calls $cond\\_wait(notEmpty,m)$ and sleeps. No other producers or consumers run. $C$ remains blocked even though $count = 1$, due to a lost signal.\n\nD. Initial state: $B = 4$, $count = 0$. A consumer $C$ executes the incorrect $if$-guarded wait: acquire $m$; observe $count = 0$; call $cond\\_wait(notEmpty,m)$. The $cond\\_wait$ returns spuriously (without any matching $cond\\_signal$), $C$ reacquires $m$, and — because the predicate was checked with $if$ — $C$ proceeds to remove without rechecking, performing $count \\leftarrow -1$.\n\nWhich options are consistent demonstrations of lost or mishandled wakeups caused by using $if$ instead of $while$, tied explicitly to the evolution of $count$ relative to $B$? Choose all that apply.", "solution": "The fundamental principle at issue is that when a thread returns from `cond_wait(cv, m)`, it reacquires the mutex $m$, but there is no guarantee that the predicate associated with the condition variable is true. The predicate might be false due to a \"stolen wakeup\" (another thread changed the state) or a \"spurious wakeup\" (the thread woke without a signal). The correct idiom is to re-check the predicate in a `while` loop. This problem analyzes the failures of an incorrect `if`-based implementation.\n\n### Option-by-Option Analysis\n\n**A. Initial state: $B = 3$, $count = 0$. A producer runs, a \"barging\" consumer runs, then the original waiting consumer resumes.**\nThis scenario describes a \"stolen wakeup.\" A producer signals one waiting consumer, $C_1$. Before $C_1$ can run, a third consumer, $C_3$, acquires the lock and consumes the only available item. When $C_1$ finally runs, the buffer is empty again. Because its wait was guarded by an `if` statement, $C_1$ does not re-check the `count`. It proceeds to remove an item from the empty buffer, corrupting the state by setting $count \\leftarrow -1$. A `while` loop would have prevented this by causing $C_1$ to go back to waiting. This is a classic failure caused by using `if` instead of `while`. Therefore, this option is correct.\n\n**B. Initial state: $B = 2$, $count = B$. A consumer runs, a \"barging\" producer runs, then the original waiting producer resumes.**\nThis is the producer-side equivalent of the \"stolen wakeup\" in option A. A consumer makes space and signals one waiting producer, $P_1$. Before $P_1$ can run, a third producer, $P_3$, acquires the lock and fills the new space. When $P_1$ finally runs, the buffer is full again. Because of the `if` guard, $P_1$ does not re-check `count`. It proceeds to insert an item into the full buffer, violating the invariant by setting $count \\leftarrow B + 1$. A `while` loop would have prevented this. Therefore, this option is correct.\n\n**C. Initial state: $B = 4$, $count = 0$. A producer signals before a consumer waits, causing a lost signal.**\nThis option describes a \"lost wakeup\" bug. However, the sequence of events is impossible under the specified protocol: \"before $C$ calls `cond_wait(notEmpty,m)`, a producer $P$ performs: acquire $m$; insert; ...\". If consumer $C$ is in its critical section (it has acquired $m$ and checked the condition), it holds the lock. Producer $P$ cannot also acquire $m$ at the same time. This scenario describes a different type of bug related to a non-atomic check-then-wait operation, not the failure to re-check the condition after waking. The `if` vs `while` distinction is irrelevant to this particular bug. Therefore, this option is incorrect.\n\n**D. Initial state: $B = 4$, $count = 0$. A consumer waits and experiences a spurious wakeup.**\nThis scenario directly tests handling of spurious wakeups. A consumer finds the buffer empty and calls `cond_wait`. The call returns spuriously, without any producer having signaled. The state of the buffer has not changed; `count` is still $0$. Because the wait is guarded by an `if` statement, the consumer does not re-check the condition. It proceeds as if the buffer has an item and attempts to remove it, decrementing `count` to $-1$. This failure is a direct consequence of not using a `while` loop to re-check the predicate after waking up. Therefore, this option is correct.", "answer": "$$\\boxed{ABD}$$", "id": "3687098"}, {"introduction": "Mastering condition variables goes beyond just following the syntactical rules; it requires understanding the logical roles of different conditions in a system. Even after ensuring that you protect state with a mutex and re-check conditions with a `while` loop, you can still create deadlocks through flawed logic. This exercise [@problem_id:3627331] examines a bounded-buffer monitor where producers and consumers mistakenly signal the wrong condition variables, creating a scenario where all threads end up permanently blocked, waiting for signals that will never arrive.", "problem": "You are designing a bounded-buffer monitor with capacity $N$ for multiple producers and consumers. The monitor maintains an integer $count$ tracking the number of items currently in the buffer, where the invariant $0 \\leq count \\leq N$ must always hold. The monitor exposes two operations, $produce(x)$ and $consume()$, and uses 2 Condition Variables (CVs), $cv\\_empty$ and $cv\\_full$, to coordinate producers and consumers. The intent is that consumers block when the buffer is empty and producers block when the buffer is full.\n\nAs foundational semantics, assume the following well-tested definitions of monitors and condition variables under the two standard models:\n- Under Mesa semantics (as in most modern systems), $wait(cv)$ atomically releases the monitor lock and blocks the calling thread; when the thread is later awakened by $signal(cv)$ or $broadcast(cv)$, it re-acquires the lock before returning from $wait$. A call to $signal(cv)$ marks one waiting thread on $cv$ as runnable, but does not transfer control immediately; the signaller continues to execute while holding the lock until it releases it.\n- Under Hoare semantics (original monitor semantics), $signal(cv)$ transfers control immediately to one waiting thread on $cv$, and the signaller waits until the awakened thread either waits again or exits the monitor.\n\nIn your design, producers should block if $count = N$ and consumers should block if $count = 0$. A common implementation pattern under Mesa semantics is that $wait$-sites are guarded by a $while$ loop that re-checks the relevant predicate upon wake-up. Consider the following two versions of the signalling policy:\n- The correct policy (intended): when a producer inserts an item and increases $count$, it signals $cv\\_empty$; when a consumer removes an item and decreases $count$, it signals $cv\\_full$.\n- A flawed policy (bug): when a producer inserts an item, it signals $cv\\_full$; when a consumer removes an item, it signals $cv\\_empty$.\n\nStarting from an initial state with $count = 0$, at least one consumer blocked waiting for the buffer to become non-empty, and at least one producer ready to run, reason about whether the flawed policy can induce a deadlock under Mesa semantics, and contrast with Hoare semantics. Then, based on first principles, select all statements that are necessarily true regarding deadlock and validation of correctness for this monitor.\n\nChoose all that apply:\n\nA. Under Mesa semantics, the flawed policy can lead to a reachable deadlock: beginning from $count = 0$, producers can fill the buffer to $N$ while repeatedly signalling $cv\\_full$ (which does not wake consumers), after which all producers block on $cv\\_full$ at $count = N$ and all consumers remain blocked on $cv\\_empty$ at $count > 0$, leaving no thread able to change $count$.\n\nB. Under Hoare semantics, signalling the wrong CV cannot cause deadlock if each $wait$ is guarded by a $while$ loop that re-checks the predicate, because the immediate handoff ensures that a waiter always runs when signalled regardless of which CV was signalled.\n\nC. A sufficient validation strategy for progress is to maintain the invariant $0 \\leq count \\leq N$ and to require edge-triggered signals: perform $signal(cv\\_empty)$ on every transition of $count$ from $0$ to $1$, and perform $signal(cv\\_full)$ on every transition of $count$ from $N$ to $N-1$. This ensures that any thread waiting on $cv\\_empty$ or $cv\\_full$ has a corresponding waker at the next enabling transition.\n\nD. To prove absence of deadlock, it is enough to show that $signal(cv\\_empty)$ is called whenever $count > 0$ and $signal(cv\\_full)$ is called whenever $count  N$, even if signals are issued without holding the lock, since this guarantees that some waiter will be awakened eventually.\n\nE. Replacing all $signal$ calls with $broadcast$ on $cv\\_empty$ and $cv\\_full$ under Mesa semantics fully eliminates deadlock caused by signalling the wrong CV, since broadcasting wakes all blocked threads.", "solution": "This problem explores a common deadlock scenario that arises from signaling the wrong condition variable. In the flawed policy, producers signal $cv\\_full$ (the condition other producers wait on) and consumers signal $cv\\_empty$ (the condition other consumers wait on). This creates a situation where threads only signal their own kind, leading to a state where no thread can make progress.\n\nLet's trace the system's execution under the flawed policy to see how this deadlock occurs, starting from the given initial state: $count = 0$, at least one consumer is blocked on $cv\\_empty$, and at least one producer is ready.\n\n1.  A producer acquires the monitor lock. Since $count = 0$, which is less than $N$, it is allowed to produce.\n2.  The producer inserts an item, incrementing $count$ to 1.\n3.  According to the flawed policy, it then calls `signal(cv_full)`. At this time, no threads are waiting on $cv\\_full$ (producers only wait when $count = N$), so the signal has no effect and is lost.\n4.  The producer releases the lock. The consumer that was waiting on $cv\\_empty$ remains blocked because it was never signaled.\n5.  This process repeats. Producers continue to run, filling the buffer. Each time, they signal $cv\\_full$, and each signal is lost because no thread is waiting on it. Consumers are never woken.\n6.  Eventually, the buffer becomes full, so $count = N$.\n7.  The next producer to run will find $count = N$, and its `while` loop condition will be true. It will call `wait(cv_full)` and block. All subsequent producers will do the same.\n\nAt this point, the system is in a deadlock state:\n- The buffer is full ($count = N$).\n- All producers are blocked on the wait queue for $cv\\_full$. They need a signal on $cv\\_full$ to wake up.\n- All consumers are blocked on the wait queue for $cv\\_empty$. They need a signal on $cv\\_empty$ to wake up.\n\nUnder the flawed policy, no thread will ever signal the condition variable on which the other type of thread is waiting. No thread can make progress.\n\nBased on this analysis, we can evaluate each option.\n\n**A. Under Mesa semantics, the flawed policy can lead to a reachable deadlock...**\nThis statement accurately describes the deadlock scenario derived above. Producers fill the buffer while their signals to `cv_full` are lost. Once the buffer is full ($count = N$), all producers block on `cv_full`, and all consumers remain blocked on `cv_empty`. No thread can proceed. This is correct.\n\n**B. Under Hoare semantics, signalling the wrong CV cannot cause deadlock...**\nThis is incorrect. The \"immediate handoff\" of Hoare semantics only occurs if there is a thread waiting on the specific condition variable that is signalled. In our scenario, a producer signals `cv_full`, but at that moment, no threads are in the `cv_full` wait queue. The signal has no one to hand off control to, and its effect is lost, just as in the Mesa case. The system proceeds to the same deadlock state.\n\n**C. A sufficient validation strategy for progress is to maintain the invariant...**\nThis statement describes the canonical correct signaling discipline. A signal is sent only when the state changes in a way that could potentially unblock a waiting thread (an \"edge-triggered\" signal). A producer enables a consumer when it makes an empty buffer non-empty ($count$ goes from $0$ to $1$). A consumer enables a producer when it makes a full buffer non-full ($count$ goes from $N$ to $N-1$). This strategy correctly ensures that a signal is sent precisely when it is needed, which prevents this class of deadlock. This is correct.\n\n**D. To prove absence of deadlock, it is enough to show that signal(...) is called ..., even if signals are issued without holding the lock...**\nThis is incorrect. Signaling without holding the lock is a critical bug that causes the \"lost wakeup\" race condition. A waiter can check the condition, be preempted, and miss the signal that is sent before it enters the wait state. The monitor lock is essential to prevent this race.\n\n**E. Replacing all `signal` calls with `broadcast` ... fully eliminates deadlock ...**\nThis is incorrect. A `broadcast` on a condition variable `cv` wakes up *all* threads waiting on that specific `cv`. In the flawed policy, a producer's call to `broadcast(cv_full)` would wake up all the other producers, who would re-check the condition ($count == N$), find it to be true, and immediately go back to waiting. No consumers would be awakened because they are waiting on `cv_empty`. The deadlock is not resolved.", "answer": "$$\\boxed{AC}$$", "id": "3627331"}]}