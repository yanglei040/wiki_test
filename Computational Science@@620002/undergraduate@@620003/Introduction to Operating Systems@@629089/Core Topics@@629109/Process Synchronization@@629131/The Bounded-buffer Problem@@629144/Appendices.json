{"hands_on_practices": [{"introduction": "Before diving into code, it's valuable to model the bounded-buffer problem using a formal structure like a Petri net. This exercise [@problem_id:3687091] helps you abstract the system to its essential components—counts of empty and full slots—and rigorously analyze its fundamental properties. By representing the producer and consumer as transitions that move tokens between places, you can mathematically prove core invariants and determine the complete set of reachable states, ensuring the system is free from deadlocks by design.", "problem": "A bounded buffer of capacity $B \\in \\mathbb{N}$ with $B \\ge 1$ is modeled as a Petri net with two places and two transitions. Place $E$ represents the count of empty slots, and place $F$ represents the count of full slots. The two transitions are $p$ (producer) and $c$ (consumer). Transition $p$ removes one token from $E$ and adds one token to $F$; transition $c$ removes one token from $F$ and adds one token to $E$. The initial marking is $M_{0}(E) = B$ and $M_{0}(F) = 0$. Tokens never appear or disappear except via these transition firings. By construction, the place invariant $M(E) + M(F) = B$ holds for all markings reachable from $M_{0}$.\n\nUsing only the standard Petri net semantics (a transition is enabled if and only if each of its input places has at least one token, and firing a transition consumes one token from each input place and produces one token on each output place), and the given invariant, determine the total number of distinct reachable markings from $M_{0}$ that are deadlock-free, as a function of $B$. Provide your final answer as a single simplified closed-form analytic expression in $B$.", "solution": "The problem asks for the total number of distinct reachable markings that are deadlock-free in a Petri net model of a bounded buffer. Let's first formalize the system based on the provided description.\n\nA marking of the Petri net is a state defined by the number of tokens in each place. We can represent a marking by the vector $M = (M(E), M(F))$, where $M(E)$ is the number of tokens in place $E$ (empty slots) and $M(F)$ is the number of tokens in place $F$ (full slots). Since token counts must be non-negative integers, $M(E) \\in \\mathbb{N}_0$ and $M(F) \\in \\mathbb{N}_0$. For conciseness, let $e = M(E)$ and $f = M(F)$, so a marking is an ordered pair $(e, f)$.\n\nThe initial marking is given as $M_0$, where $M_0(E) = B$ and $M_0(F) = 0$. In our notation, this is the state $(B, 0)$. The buffer capacity $B$ is a positive integer, $B \\in \\mathbb{N}$ and $B \\ge 1$.\n\nThe problem states a place invariant: for any marking $M$ reachable from $M_0$, the relation $M(E) + M(F) = B$ holds. In our notation, every reachable state $(e, f)$ must satisfy the equation $e + f = B$.\n\nFirst, let's identify the set of all possible markings that are reachable from $M_0$. Any reachable marking $(e, f)$ must satisfy the invariant $e+f=B$, with the constraints that $e$ and $f$ are non-negative integers. We can enumerate all possible pairs $(e, f)$ that satisfy these conditions. If we let $f$ take on integer values, the constraint $f \\ge 0$ and the invariant $e = B-f \\ge 0$ (which implies $f \\le B$) restrict $f$ to the set $\\{0, 1, 2, \\dots, B\\}$. For each of these values of $f$, the value of $e$ is uniquely determined. This gives us the following set of potential markings:\n$$\nS = \\{ (B, 0), (B-1, 1), (B-2, 2), \\dots, (1, B-1), (0, B) \\}\n$$\nThe number of distinct markings in this set is the number of possible values for $f$, which is $(B-0)+1 = B+1$.\n\nNext, we must confirm that all these $B+1$ markings are indeed reachable from the initial marking $M_0 = (B, 0)$.\nThe state transitions are governed by the firing of transitions $p$ (producer) and $c$ (consumer).\n- Transition $p$: enabled if $e \\ge 1$. Firing $p$ changes the state from $(e, f)$ to $(e-1, f+1)$.\n- Transition $c$: enabled if $f \\ge 1$. Firing $c$ changes the state from $(e, f)$ to $(e+1, f-1)$.\n\nStarting from $M_0 = (B, 0)$:\nSince $B \\ge 1$, we have $e=B \\ge 1$. So, transition $p$ is enabled. Firing $p$ leads to the state $(B-1, 1)$.\nFrom $(B-1, 1)$: If $B-1 \\ge 1$ (i.e., $B \\ge 2$), $p$ is enabled and firing it leads to $(B-2, 2)$. This can be repeated.\nBy firing transition $p$ a total of $k$ times from $M_0$, we can reach the state $(B-k, k)$, for any $k \\in \\{0, 1, \\dots, B\\}$, since the condition to fire $p$ at state $(B-i, i)$ is $B-i \\ge 1$, which holds for all $i < B$.\nSimilarly, from any state $(e, f)$ with $f \\ge 1$, we can fire transition $c$ to reach $(e+1, f-1)$. This means we can move in the reverse direction through the sequence of states.\nTherefore, all $B+1$ markings in the set $S$ are reachable from $M_0$.\n\nNow, we must determine which of these reachable markings are deadlock-free. A marking is defined as a deadlock state if no transitions are enabled from it. In our system, this means that both transition $p$ and transition $c$ must be disabled.\n- Transition $p$ is disabled if its input place $E$ has no tokens, i.e., $e < 1$, which means $e=0$.\n- Transition $c$ is disabled if its input place $F$ has no tokens, i.e., $f < 1$, which means $f=0$.\n\nA deadlock occurs if and only if the marking is $(e,f) = (0,0)$.\nWe must check if this deadlock marking is reachable. For a marking to be reachable, it must satisfy the place invariant $e+f = B$.\nIf the marking $(0,0)$ were reachable, it would have to satisfy $0+0 = B$, which implies $B=0$.\nHowever, the problem statement explicitly specifies that $B \\ge 1$.\nBecause $B \\ge 1$, the marking $(0,0)$ does not satisfy the invariant and is therefore not in the set of reachable markings.\n\nLet's examine any arbitrary reachable marking $(e,f)$. From the invariant $e+f=B$ and the condition $B \\ge 1$, it is impossible for both $e$ and $f$ to be zero simultaneously. This means that for any reachable marking, at least one of the following must be true: $e \\ge 1$ or $f \\ge 1$.\n- If $e \\ge 1$, transition $p$ is enabled.\n- If $f \\ge 1$, transition $c$ is enabled.\nSince at least one of these conditions must hold for any reachable marking, there is always at least one enabled transition. Consequently, no reachable marking is a deadlock state.\n\nThe problem asks for the number of reachable markings that are deadlock-free. Since we have established that *all* reachable markings are deadlock-free, the answer is simply the total number of distinct reachable markings.\nAs calculated earlier, the total number of distinct reachable markings is the number of non-negative integer solutions to $e+f=B$, which is $B+1$.\n\nTherefore, the total number of distinct reachable markings that are deadlock-free is $B+1$.", "answer": "$$\\boxed{B+1}$$", "id": "3687091"}, {"introduction": "While formal models establish theoretical correctness, implementing them in code introduces new challenges, especially with thread synchronization. This practice [@problem_id:3687132] explores a common pitfall in semaphore-based implementations where a subtle misordering of operations creates a critical race condition. By tracing a specific interleaving of producer and consumer threads, you will see how a premature signal can violate the buffer's capacity invariant, leading to data corruption or system failure.", "problem": "Consider the classical bounded-buffer producer-consumer problem implemented with counting semaphores and a binary mutex. Let there be two producers $P_1$ and $P_2$ and one consumer $C$. The buffer has capacity $B$, and the shared integer $count$ tracks the number of occupied slots. The system uses counting semaphores $empty$ and $full$ with initial values $empty = B - count$ and $full = count$, and a binary mutex $m$ protecting the buffer and $count$. The semantics of the primitives are: $\\text{wait}(s)$ atomically decrements semaphore $s$ or blocks if its value is $0$, and $\\text{signal}(s)$ atomically increments $s$ and wakes one blocked thread if any. The critical correctness invariant is $0 \\le count \\le B$ at all times, and modifications to the buffer and $count$ occur only while holding $m$.\n\nAssume the following intended producer sequence:\n- $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into the buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n\nHowever, the consumer is incorrectly implemented to signal $empty$ prematurely:\n- $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from the buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n\nStarting from the scientifically consistent initial state $B = 2$, $count = 2$, $empty = 0$, $full = 2$, and with both $P_1$ and $P_2$ initially blocked on $\\text{wait}(empty)$, construct an interleaving that shows how the premature $\\text{signal}(empty)$ by $C$ can lead to a violation of the invariant $count \\le B$. Then, identify a corrected consumer sequence that ensures the invariant $0 \\le count \\le B$ is preserved under all interleavings, by respecting mutual exclusion and capacity semantics.\n\nWhich option below both\n- provides a concrete interleaving (given the faulty consumer above) that makes $count$ exceed $B$, and\n- proposes a corrected consumer ordering that prevents such violations for any interleaving?\n\nA. Interleaving demonstrating violation, then corrected consumer:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Corrected consumer sequence:\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$, then $\\text{signal}(empty)$.\n\nB. Interleaving with no violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{signal}(empty)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$.\n- Proposed consumer fix (still premature):\n  - $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nC. Interleaving demonstrating violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$.\n  - $C$: $\\text{wait}(m)$ blocks while $P_1$ holds $m$.\n  - $P_1$: $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$.\n- Proposed consumer fix (moves $\\text{take}$ outside mutual exclusion):\n  - $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(empty)$, then $\\text{signal}(m)$.\n\nD. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(full)$, then $\\text{wait}(m)$.\n  - $P_1$: $\\text{wait}(full)$ succeeds, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$.\n- Proposed consumer fix (misordered and missing $\\text{signal}(empty)$):\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nSelect the single best option.", "solution": "The problem statement is subjected to validation before proceeding.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Processes: Two producers, $P_1$ and $P_2$, and one consumer, $C$.\n- Buffer Capacity: $B$.\n- Shared State: An integer $count$ tracking the number of occupied slots.\n- Synchronization Primitives:\n    - Counting semaphore $empty$, initialized to $B - count$.\n    - Counting semaphore $full$, initialized to $count$.\n    - Binary mutex $m$.\n- Primitive Semantics:\n    - $\\text{wait}(s)$: Atomically decrements semaphore $s$ or blocks if its value is $0$.\n    - $\\text{signal}(s)$: Atomically increments $s$ and wakes one blocked thread if any.\n- Correctness Invariant: $0 \\le count \\le B$ must hold at all times.\n- Producer Logic: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Faulty Consumer Logic: $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n- Specific Initial State: $B = 2$, $count = 2$, $empty = 0$, $full = 2$. Both $P_1$ and $P_2$ are initially blocked on $\\text{wait}(empty)$. The mutex $m$ is assumed to be available (value $1$).\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of concurrent programming and operating systems. It describes a classic synchronization problem (bounded-buffer) with standard primitives (semaphores, mutex). The terminology is precise and objective. The provided initial state ($B=2, count=2, empty=0, full=2$) is consistent with the definitions ($empty=B-count=2-2=0$; $full=count=2$). The problem is well-posed, asking for a specific execution trace that demonstrates a flaw and a corrected code sequence. The setup is not incomplete, contradictory, or unrealistic for a software context. It represents a common type of programming error.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A solution will be derived.\n\n### Derivation of Solution\n\nThe core of the problem lies in the interaction between the faulty consumer $C$ and a producer, say $P_1$. The invariant to be violated is $count \\le B$. We need to show how an interleaving can lead to $count > 2$.\n\n**1. Analysis of the Flaw**\n\nThe standard producer-consumer solution uses the $empty$ and $full$ semaphores to enforce the buffer capacity constraints. A producer must wait for an empty slot (by calling $\\text{wait}(empty)$) before producing, and a consumer must wait for a full slot (by calling $\\text{wait}(full)$) before consuming.\n\n- The **Producer** logic is correct: It waits for an empty slot ($\\text{wait}(empty)$), acquires a lock ($\\text{wait}(m)$) to update the shared state, adds an item and increments $count$, releases the lock ($\\text{signal}(m)$), and finally signals that a slot is now full ($\\text{signal}(full)$).\n- The **Consumer** logic is faulty. The operations $\\text{wait}(full)$ and $\\text{signal}(empty)$ should conceptually bracket the consumption of an item. However, the sequence is given as $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, etc. The consumer signals that a slot is empty *before* it has actually acquired the lock $m$ and removed the item from the buffer. This creates a race condition. The consumer advertises a resource (an empty slot) that does not yet exist.\n\n**2. Constructing a Violating Interleaving**\n\nLet's trace an execution starting from the initial state: $B=2$, $count=2$, $empty=0$, $full=2$, $m=1$. $P_1$ and $P_2$ are blocked on $\\text{wait}(empty)$.\n\n1.  $C$ starts execution. The producers are blocked, so they cannot run.\n2.  $C$ executes $\\text{wait}(full)$. The value of $full$ is $2$, so the call succeeds, and $full$ is decremented to $1$.\n3.  $C$ executes its faulty instruction: $\\text{signal}(empty)$. The value of $empty$ was $0$. This call increments $empty$ to $1$. Since $P_1$ (or $P_2$) was blocked on this semaphore, the operating system unblocks $P_1$. $P_1$ is now in the ready state, having completed its $\\text{wait}(empty)$ call.\n4.  At this point, a context switch occurs, and the scheduler chooses to run $P_1$. The consumer $C$ is preempted before it can execute $\\text{wait}(m)$.\n5.  $P_1$ executes its next instruction, $\\text{wait}(m)$. The mutex $m$ is available (value $1$), so $P_1$ acquires it, and the value of $m$ becomes $0$. $P_1$ is now in its critical section.\n6.  Inside its critical section, $P_1$ performs a $\\text{put}$ operation. The buffer, which was full, now overflows.\n7.  $P_1$ executes $count := count + 1$. The value of $count$ was $2$. It is now incremented to $3$.\n8.  At this moment, the invariant $count \\le B$ is violated, since $count = 3$ and $B = 2$. The violation has occurred. The rest of the execution sequence for $P_1$ ($\\text{signal}(m)$, $\\text{signal}(full)$) and the eventual execution of $C$ (which will block on $\\text{wait}(m)$ until $P_1$ releases it) do not alter this fact.\n\nThis interleaving demonstrates the violation successfully.\n\n**3. Proposing a Corrected Consumer Sequence**\n\nTo fix the bug, the consumer must only signal that a slot is empty *after* it has completed the removal of an item and the corresponding update of the shared variable $count$. The modification of shared state (the buffer and $count$) must be protected by the mutex $m$. Therefore, the $\\text{signal}(empty)$ call must be moved to after the critical section.\n\nThe correct, standard sequence for the consumer is:\n1.  $\\text{wait}(full)$: Wait until there is at least one item in the buffer.\n2.  $\\text{wait}(m)$: Acquire the lock to access shared state.\n3.  $\\text{take}$: Remove an item from the buffer.\n4.  $count := count - 1$: Decrement the count of items.\n5.  $\\text{signal}(m)$: Release the lock.\n6.  $\\text{signal}(empty)$: Signal to producers that a slot has been freed.\n\nThis ordering ensures that the semaphore $empty$ correctly represents the number of available slots, preventing the race condition that led to the violation.\n\n### Option-by-Option Analysis\n\n**A. Interleaving demonstrating violation, then corrected consumer:**\n- **Interleaving:** The described interleaving ($C$ runs $\\text{wait}(full)$, then $\\text{signal}(empty)$; then $P_1$ wakes up, acquires $m$, and increments $count$ to $3$) directly matches the violation trace derived above. This part is correct.\n- **Corrected consumer sequence:** The proposed sequence is $\\text{wait}(full)$, $\\text{wait}(m)$, $\\text{take}$, $count := count - 1$, $\\text{signal}(m)$, $\\text{signal}(empty)$. This is the canonical correct implementation, as derived above. This part is correct.\n- **Verdict:** **Correct**.\n\n**B. Interleaving with no violation, then incorrect consumer fix:**\n- **Interleaving:** This describes an interleaving where $C$ acquires the mutex before a context switch. As analyzed, this specific interleaving does not produce the violation. The task was to show an interleaving that *does* produce a violation. This part fails the task.\n- **Proposed consumer fix:** The proposed \"fix\" is identical to the original faulty sequence. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**C. Interleaving demonstrating violation, then incorrect consumer fix:**\n- **Interleaving:** The interleaving is described in slightly more detail than in option A (explicitly showing $C$ blocking on $m$), but it is conceptually the same correct demonstration of the violation. This part is correct.\n- **Proposed consumer fix:** The proposed sequence is $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, ... This is critically flawed. The $\\text{take}$ operation modifies the shared buffer but is placed outside the critical section protected by the mutex $m$. This introduces a different a race condition. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**D. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:**\n- **Interleaving:** The interleaving describes a different fault, a premature $\\text{signal}(full)$. The problem explicitly states the fault is a premature $\\text{signal}(empty)$. Furthermore, it incorrectly claims that producers wait on `full`, when they wait on `empty`. This part is inconsistent with the problem statement.\n- **Proposed consumer fix:** The proposed fix is missing the $\\text{take}$ operation and the $\\text{signal}(empty)$ call, which would cause the system to deadlock eventually as producers would never be signaled. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\nBased on the analysis, option A is the only one that both correctly demonstrates the violation with a valid interleaving and provides the standard, correct fix for the consumer's logic.", "answer": "$$\\boxed{A}$$", "id": "3687132"}, {"introduction": "Beyond correctness, bounded buffers are critical components in systems where performance and timeliness are paramount. This exercise [@problem_id:3687090] shifts the focus from synchronization logic to performance engineering by introducing real-time deadlines. You will derive the minimum buffer size needed to absorb a worst-case burst of items without overflow, while ensuring every admitted item is processed before its deadline, a key skill in designing responsive and reliable systems.", "problem": "A single-producer, single-consumer bounded-buffer system must guarantee that every admitted item completes service no later than a fixed per-item deadline. The buffer holds only waiting items; the consumer removes an item from the buffer to begin service and holds it during service. Assume the following foundational model.\n\n- At time $t = 0$, a worst-case burst of $X$ items becomes available simultaneously. Items are identical and are enqueued in first-come, first-served order.\n- The consumer processes items at a constant rate $\\mu$ items per second, so the deterministic service time per item is $1/\\mu$ seconds. There are no context-switch or dequeue overheads.\n- Each item must complete service within $D$ seconds of its arrival. The system employs admission control at arrival: items that cannot meet their deadlines given the current queue state are not admitted to the buffer and are immediately rejected, so as not to waste buffer space on inevitably tardy items.\n- The consumer begins processing immediately at $t = 0^{+}$ if at least one item is admitted. There are no arrivals after the burst at $t = 0$.\n\nStarting from first principles of this model, derive a closed-form expression for the minimum buffer capacity $B$ (in buffer slots) required to ensure that, under the worst-case burst described, no admitted item is lost to buffer overflow and every admitted item completes by its deadline.\n\nExpress your final answer as a single analytic expression in terms of $X$, $\\mu$, and $D$. No numerical approximation or rounding is required.", "solution": "The problem asks for the minimum buffer capacity, $B$, required for a single-producer, single-consumer system under specific conditions. The derivation proceeds from first principles by analyzing the timing of events for items processed in a first-come, first-served (FCFS) manner.\n\nLet us denote the time of arrival of the burst of $X$ items as $t_{arrival} = 0$. According to the problem statement, every admitted item must have its service completed by a deadline $D$ seconds after its arrival. Therefore, for any admitted item, its completion time, $t_{completion}$, must satisfy the condition $t_{completion} \\le D$.\n\nThe consumer processes items at a constant rate of $\\mu$ items per second. This implies that the service time for a single item is deterministic and equal to $s = 1/\\mu$ seconds. The system employs an FCFS queueing discipline. Let's analyze the completion time for the $k^{th}$ item in the sequence to be processed, where $k$ is a positive integer ($k=1, 2, 3, \\dots$).\n\nThe first item ($k = 1$) is enqueued at $t = 0$ and, since the consumer is immediately available, its service begins at $t=0^{+}$. Its service completes at time $t_{completion,1} = 1/\\mu$.\nThe second item ($k = 2$) must wait for the first item to finish. It enters service at time $1/\\mu$ and completes service at time $t_{completion,2} = 1/\\mu + 1/\\mu = 2/\\mu$.\nGeneralizing this pattern, the $k^{th}$ item to be processed will complete its service at time:\n$$t_{completion,k} = k \\times \\frac{1}{\\mu} = \\frac{k}{\\mu}$$\n\nThe system employs an admission control policy: an item is admitted only if it can meet its deadline. For the $k^{th}$ item in the processing sequence, this means its completion time must not exceed the deadline $D$.\n$$\\frac{k}{\\mu} \\le D$$\nThis inequality can be rearranged to find the maximum possible value of $k$:\n$$k \\le \\mu D$$\n\nSince $k$ must represent an integer number of items, the maximum number of items that can be processed while satisfying all deadlines, let us call this $A_{max\\_servable}$, is the greatest integer less than or equal to $\\mu D$. This is represented by the floor function:\n$$A_{max\\_servable} = \\lfloor \\mu D \\rfloor$$\n\nAt time $t=0$, a burst of $X$ items arrives. The system cannot admit more items than are available. Therefore, the actual number of admitted items, which we will denote as $A$, is the minimum of the number of available items, $X$, and the maximum number of items the system can servably process, $A_{max\\_servable}$.\n$$A = \\min(X, A_{max\\_servable}) = \\min(X, \\lfloor \\mu D \\rfloor)$$\n\nWe now need to determine the required buffer capacity, $B$. The problem states that the buffer holds only *waiting* items. The item currently being served is held by the consumer, not in the buffer. At time $t=0$, $A$ items are admitted. At time $t=0^{+}$, if $A > 0$, the first item is immediately dequeued and enters service. The remaining $A-1$ items must reside in the buffer. This moment represents the peak occupancy of the buffer, because from this point forward, no new items arrive, and the number of items in the buffer will only decrease as the consumer processes them one by one.\n\nTherefore, the minimum buffer capacity $B$ must be large enough to hold these waiting items.\n$$B = A - 1$$\n\nThis is valid for $A \\ge 1$. If $A=0$ or $A=1$, the number of waiting items is $0$. A negative buffer capacity is not physically meaningful. The buffer capacity must be a non-negative integer. Thus, the required capacity is the number of waiting items, floored at $0$.\n$$B = \\max(0, A - 1)$$\n\nSubstituting the expression for $A$ into this equation gives the final closed-form expression for the minimum required buffer capacity:\n$$B = \\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)$$\n\nThis expression correctly captures all cases. For instance, if the service time $1/\\mu$ exceeds the deadline $D$, then $\\mu D < 1$, which means $\\lfloor \\mu D \\rfloor = 0$. This leads to $A=0$ and $B=\\max(0, 0-1) = 0$, which is correct as no items can be admitted. If only one item is admitted ($A=1$), it goes directly to the consumer, and the buffer requirement is $B = \\max(0, 1-1) = 0$, which is also correct. For any $A > 1$ admitted items, one is in service and $A-1$ are in the buffer, matching the formula.", "answer": "$$\\boxed{\\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)}$$", "id": "3687090"}]}