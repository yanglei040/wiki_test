{"hands_on_practices": [{"introduction": "We begin by exploring the critical importance of operational order in concurrent algorithms. In this first exercise [@problem_id:3669544], we examine a modified version of Peterson's solution where the actions of declaring interest (setting `$flag[i]$`) and yielding priority (setting `$turn$`) are swapped. Your challenge is to determine if this seemingly minor change compromises the algorithm's fundamental guarantees and to construct a specific execution trace that demonstrates the failure.", "problem": "Consider the classic two-process Peterson’s solution to the critical-section problem. There are $2$ processes, $P_0$ and $P_1$, which share $3$ single-writer/single-reader atomic variables under Sequential Consistency (SC): a Boolean array $flag[\\,]$ where $flag[i]$ indicates intent to enter, and an integer $turn \\in \\{0,1\\}$ used as a tie-breaker. For process $P_i$, let $j = 1 - i$. The original entry protocol performs the following two actions in order before spinning: set $flag[i]$ to indicate interest, then set $turn$ to give the other process priority. In the modified version under consideration, the order of these two lines is swapped so that each $P_i$ executes, in program order:\n- $turn := j$\n- $flag[i] := \\text{true}$\n- while $\\big(flag[j] \\land (turn = j)\\big)$ do busy-wait\n- enter critical section\n- $flag[i] := \\text{false}$ upon exiting\n\nAssume SC and atomic reads/writes of $flag[\\,]$ and $turn$. Using only the core definitions of safety and liveness for critical sections:\n- Mutual exclusion: at most one process is in the critical section at any time.\n- Progress (freedom from deadlock): if no process is in the critical section and one or more processes wish to enter, then some process will eventually enter.\n\nWhich option correctly characterizes whether mutual exclusion or progress is violated by this modification, and provides a concrete interleaving schedule (a sequence of atomic actions) that demonstrates the violation?\n\nA. Mutual exclusion is violated. Example schedule with both processes starting from the remainder section and attempting to enter:\n- Step $1$: $P_0$ executes $turn := 1$.\n- Step $2$: $P_1$ executes $turn := 0$.\n- Step $3$: $P_1$ executes $flag[1] := \\text{true}$.\n- Step $4$: $P_1$ evaluates while-condition $\\big(flag[0] \\land (turn = 0)\\big)$; since $flag[0] = \\text{false}$, it enters the critical section.\n- Step $5$: $P_0$ executes $flag[0] := \\text{true}$.\n- Step $6$: $P_0$ evaluates while-condition $\\big(flag[1] \\land (turn = 1)\\big)$; since $flag[1] = \\text{true}$ and $turn = 0$, it enters the critical section.\nBoth $P_1$ and $P_0$ are in the critical section simultaneously.\n\nB. Progress is violated (both processes can be stuck spinning forever). Example schedule:\n- Step $1$: $P_0$ executes $turn := 1$, then $flag[0] := \\text{true}$.\n- Step $2$: $P_1$ executes $turn := 0$, then $flag[1] := \\text{true}$.\n- Step $3$: Both evaluate their while-conditions and spin forever because each sees the other’s $flag$ is $\\text{true}$ and $turn$ favors the other process.\n\nC. Neither mutual exclusion nor progress is violated under SC; the tie-breaker still ensures that exactly one process proceeds whenever both are interested.\n\nD. Mutual exclusion holds, but progress can be violated by a livelock where both repeatedly set $turn$ and $flag[\\,]$ and continuously defer to each other without either entering the critical section.\n\nSelect the single best option.", "solution": "The problem asks to analyze a modified version of Peterson's two-process solution for the critical-section problem. The modification involves swapping the order of the first two statements in the entry protocol. We must determine if this modification violates the properties of mutual exclusion or progress.\n\nLet the two processes be $P_0$ and $P_1$. The shared variables are a Boolean array $flag[2]$ and an integer $turn \\in \\{0,1\\}$. We assume the standard initial state where both processes are in their remainder sections, so $flag[0] = \\text{false}$ and $flag[1] = \\text{false}$. The initial value of $turn$ is arbitrary. All reads and writes to shared variables are atomic, and the system adheres to Sequential Consistency (SC).\n\nFor a process $P_i$ (where $i \\in \\{0,1\\}$ and $j = 1-i$), the modified protocol is:\n\n**Entry Section:**\n1.  $turn := j$\n2.  $flag[i] := \\text{true}$\n3.  `while` ($flag[j] \\land (turn = j)$) `do` busy-wait\n\n**Critical Section:**\n...\n\n**Exit Section:**\n1.  $flag[i] := \\text{false}$\n\nWe will analyze the two fundamental properties: mutual exclusion and progress.\n\n### Analysis of Mutual Exclusion\nMutual exclusion requires that at most one process can be in its critical section at any given time. To test for a violation, we search for a plausible interleaving of atomic operations that allows both $P_0$ and $P_1$ to enter their critical sections simultaneously.\n\nLet's consider the following sequence of events, starting from the initial state $flag[0] = \\text{false}$, $flag[1] = \\text{false}$, and an arbitrary value for $turn$.\n\n1.  **$P_0$ executes `turn := 1`**. The shared variable $turn$ now has the value $1$. The state of shared variables is ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=1$).\n2.  **$P_0$ is preempted.**\n3.  **$P_1$ executes `turn := 0`**. The shared variable $turn$ is overwritten and now has the value $0$. The state is ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=0$).\n4.  **$P_1$ executes `flag[1] := true`**. The state is ($flag[0]=\\text{false}$, $flag[1]=\\text{true}$, $turn=0$).\n5.  **$P_1$ evaluates its `while` condition**: $flag[0] \\land (turn = 0)$.\n    -   The expression $flag[0]$ evaluates to $\\text{false}$.\n    -   The entire conjunction is therefore $\\text{false}$.\n    -   $P_1$ does not loop and proceeds to enter its critical section.\n6.  **$P_1$ is in its critical section. $P_0$ resumes execution.**\n7.  **$P_0$ executes `flag[0] := true`**. The state is ($flag[0]=\\text{true}$, $flag[1]=\\text{true}$, $turn=0$).\n8.  **$P_0$ evaluates its `while` condition**: $flag[1] \\land (turn = 1)$.\n    -   The expression $flag[1]$ evaluates to $\\text{true}$.\n    -   The expression $(turn = 1)$ evaluates to $\\text{false}$, since $turn$ is currently $0$.\n    -   The entire conjunction is therefore $\\text{false}$.\n    -   $P_0$ does not loop and proceeds to enter its critical section.\n\nAt this point, both $P_1$ and $P_0$ are in their respective critical sections. This constitutes a clear violation of the mutual exclusion property. The flaw arises because a process $P_i$ can set the $turn$ variable to yield to $P_j$ before it has raised its own flag, $flag[i]$. This allows $P_j$ to see that $P_i$ is not interested ($flag[i]$ is $\\text{false}$) and proceed, while also setting $turn$ to a value that will subsequently allow $P_i$ to enter as well.\n\n### Analysis of Progress\nThe progress property, as defined, means freedom from deadlock: if no process is in its critical section and some processes wish to enter, then one of them must eventually be able to do so. A violation would occur if both processes could become permanently blocked in their `while` loops.\n\nLet's assume, for the sake of contradiction, that both processes are deadlocked.\n-   For $P_0$ to be blocked, it must be spinning in its `while` loop. This requires its condition, $flag[1] \\land (turn = 1)$, to be continuously true. This implies that $flag[1] = \\text{true}$ and $turn = 1$.\n-   For $P_1$ to be blocked, it must be spinning in its `while` loop. This requires its condition, $flag[0] \\land (turn = 0)$, to be continuously true. This implies that $flag[0] = \\text{true}$ and $turn = 0$.\n\nFor both processes to be deadlocked simultaneously, the system state must satisfy all these conditions at the same time. This would require $turn = 1$ and $turn = 0$ to both be true, which is a logical impossibility as $turn$ is a single variable. Therefore, it is impossible for both processes to be stuck in their `while` loops at the same time. At any moment, at least one of the wait conditions must be false. Consequently, deadlock cannot occur, and the progress property is not violated.\n\n### Evaluation of Options\n\n**A. Mutual exclusion is violated. Example schedule with both processes starting from the remainder section and attempting to enter: ...**\nThis option claims that mutual exclusion is violated and provides an demonstrating schedule.\n-   The schedule is:\n    1.  $P_0$ executes $turn := 1$. (State: $turn=1$)\n    2.  $P_1$ executes $turn := 0$. (State: $turn=0$)\n    3.  $P_1$ executes $flag[1] := \\text{true}$. (State: $flag[1]=\\text{true}, turn=0$)\n    4.  $P_1$ checks $flag[0] \\land (turn = 0)$. Since $flag[0]=\\text{false}$, condition is $\\text{false}$, and $P_1$ enters its critical section.\n    5.  $P_0$ executes $flag[0] := \\text{true}$. (State: $flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$)\n    6.  $P_0$ checks $flag[1] \\land (turn = 1)$. Since $turn=0$, the sub-expression $(turn=1)$ is $\\text{false}$. The condition is $\\text{false}$, and $P_0$ enters its critical section.\n-   The schedule is valid and correctly shows both processes in the critical section. The conclusion that mutual exclusion is violated is correct.\n-   **Verdict: Correct.**\n\n**B. Progress is violated (both processes can be stuck spinning forever). Example schedule: ...**\nThis option claims a progress violation (deadlock). My analysis above proved deadlock is impossible. Let's analyze the provided schedule:\n-   The schedule is:\n    1.  $P_0$ executes $turn := 1$, then $flag[0] := \\text{true}$. (State: $turn=1, flag[0]=\\text{true}$)\n    2.  $P_1$ executes $turn := 0$, then $flag[1] := \\text{true}$. (State: $turn=0, flag[0]=\\text{true}, flag[1]=\\text{true}$)\n    3.  Both evaluate their while-conditions.\n-   Let's check the conditions based on the final state ($flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$):\n    -   $P_0$'s condition: $flag[1] \\land (turn=1)$. This is $\\text{true} \\land (\\text{false})$, which is $\\text{false}$. $P_0$ does not spin; it enters the critical section.\n    -   $P_1$'s condition: $flag[0] \\land (turn=0)$. This is $\\text{true} \\land (\\text{true})$, which is $\\text{true}$. $P_1$ spins.\n-   The option's conclusion that \"Both ... spin forever\" is false. $P_0$ makes progress. Thus, the schedule does not cause deadlock.\n-   **Verdict: Incorrect.**\n\n**C. Neither mutual exclusion nor progress is violated under SC; the tie-breaker still ensures that exactly one process proceeds whenever both are interested.**\nThis option claims the algorithm is correct. Our analysis has shown a clear violation of mutual exclusion via a valid counterexample. The tie-breaker mechanism is flawed in this modified version.\n-   **Verdict: Incorrect.**\n\n**D. Mutual exclusion holds, but progress can be violated by a livelock where both repeatedly set $turn$ and $flag[\\,]$ and continuously defer to each other without either entering the critical section.**\nThis option claims mutual exclusion holds, which is false, as shown in the analysis for Option A. Furthermore, there is no mechanism in the protocol for processes to \"repeatedly set $turn$ and $flag[\\,]$\" without entering the critical section in between. Once a process sets its flag, it remains set until it exits the critical section. The premise that mutual exclusion holds is sufficient to invalidate this option.\n-   **Verdict: Incorrect.**\n\nThe analysis confirms that only mutual exclusion is violated, while progress (deadlock-freedom) is maintained. Option A correctly identifies this and provides a valid counterexample.", "answer": "$$\\boxed{A}$$", "id": "3669544"}, {"introduction": "After seeing how fragile the algorithm can be, we now turn to a potential optimization. This practice [@problem_id:3669493] introduces a variant that attempts to reduce overhead by only updating the `$turn$` variable when contention is actually detected. You will analyze whether this conditional logic is safe under the assumption of Sequential Consistency ($SC$) and whether it correctly preserves mutual exclusion, progress, and bounded waiting.", "problem": "Two processes, denoted by indices $i \\in \\{0,1\\}$ and $j = 1 - i$, share two Boolean variables $flag[0], flag[1]$ and one integer variable $turn$. All shared variables are initialized as $flag[0] = flag[1] = \\text{false}$ and $turn$ arbitrary in $\\{0,1\\}$. Assume atomic read and write operations, and a memory model providing Sequential Consistency (SC), meaning that the result of any execution is as if all operations by all processes were executed in some interleaved order that respects the program order of each individual process.\n\nConsider the following variant of Peterson’s two-process mutual exclusion protocol. Each process $i$ executes the following loop, where $j = 1 - i$:\n- Set $flag[i] \\leftarrow \\text{true}$.\n- If $flag[j]$ is observed to be $\\text{true}$, then set $turn \\leftarrow j$; otherwise, do not write $turn$.\n- Busy-wait while $flag[j] \\land (turn = j)$.\n- Execute the critical section.\n- Set $flag[i] \\leftarrow \\text{false}$.\n- Execute the remainder section.\n\nThis variant differs from the textbook Peterson’s solution only in that the write to $turn$ is conditional: $turn$ is written only when detecting that $flag[j] = \\text{true}$; in the uncontended case ($flag[j] = \\text{false}$), the write to $turn$ is skipped.\n\nFrom the fundamental definitions of mutual exclusion (at most one process is in the critical section at any time), progress (if no process is in the critical section and some process wishes to enter, then some process eventually enters), and bounded waiting (a process that wishes to enter the critical section will not be overtaken indefinitely many times by the other process), and under the SC and atomic read/write assumptions stated above, determine which statements are correct about this variant.\n\nSelect all that apply.\n\nA. Compared to the textbook Peterson’s solution, this variant reduces writes to $turn$ when there is no contention (i.e., when $flag[j] = \\text{false}$), and under SC with atomic reads/writes it still guarantees mutual exclusion, progress, and bounded waiting.\n\nB. The variant can violate mutual exclusion: if both processes observe $flag[j] = \\text{false}$ at the conditional update, both can enter the critical section because $turn$ may retain a stale value.\n\nC. The variant can deadlock: if neither process updates $turn$ (because each observed $flag[j] = \\text{false}$), both busy-wait forever with $turn$ unchanged.\n\nD. The variant preserves mutual exclusion and progress under SC but can violate bounded waiting; one process can starve while the other repeatedly re-enters.\n\nE. On architectures without SC and in the absence of appropriate memory-ordering primitives (such as memory fences), both the textbook Peterson’s solution and this variant can fail; the conditional update does not remedy weak-memory reorderings.", "solution": "The problem asks for an analysis of a variant of Peterson's two-process mutual exclusion algorithm. The analysis will be performed under the specified conditions: atomic read/write operations and a Sequential Consistency (SC) memory model. The three fundamental properties to verify are mutual exclusion, progress, and bounded waiting.\n\nThe algorithm for process $i \\in \\{0, 1\\}$, with $j = 1 - i$, is as follows:\n1. Entry Section:\n   1. $flag[i] \\leftarrow \\text{true}$.\n   2. If $flag[j]$ is observed to be $\\text{true}$, then $turn \\leftarrow j$.\n   3. Busy-wait while $(flag[j] \\land (turn = j))$.\n2. Critical Section (CS).\n3. Exit Section:\n   1. $flag[i] \\leftarrow \\text{false}$.\n4. Remainder Section.\n\nThe shared variables are initialized as $flag[0] \\leftarrow \\text{false}$, $flag[1] \\leftarrow \\text{false}$, and $turn$ is set to an arbitrary value in $\\{0, 1\\}$.\n\n### Analysis under Sequential Consistency (SC)\n\nUnder SC, all memory operations from all processes are merged into a single total order that is consistent with the program order of each individual process.\n\n#### 1. Mutual Exclusion\nTo prove mutual exclusion, we assume, for the sake of contradiction, that both processes $P_0$ and $P_1$ are in their critical sections simultaneously.\n- If $P_0$ is in its CS, it must have passed its busy-wait loop. This implies that when it last evaluated the condition $(flag[1] \\land (turn = 1))$, the condition was $\\text{false}$.\n- If $P_1$ is in its CS, it must have passed its busy-wait loop. This implies that when it last evaluated the condition $(flag[0] \\land (turn = 0))$, the condition was $\\text{false}$.\n\nFor any process $i$ to be in its CS, it must have first set $flag[i] \\leftarrow \\text{true}$. Therefore, if both are in their CS, it must be that $flag[0] = \\text{true}$ and $flag[1] = \\text{true}$.\n\nGiven that both flags are $\\text{true}$:\n- For $P_0$ to have entered, its loop condition $(\\text{true} \\land (turn = 1))$ must have been $\\text{false}$. This requires that $turn = 0$ at the time of its final check.\n- For $P_1$ to have entered, its loop condition $(\\text{true} \\land (turn = 0))$ must have been $\\text{false}$. This requires that $turn = 1$ at the time of its final check.\n\nLet $C_0$ be the final (successful) check of the loop condition by $P_0$, and $C_1$ be the final check by $P_1$. At the time of operation $C_0$, the value of $turn$ must have been $0$. At the time of operation $C_1$, the value of $turn$ must have been $1$.\n\nLet's analyze the writes to the shared variable $turn$.\n- $P_0$ writes $turn \\leftarrow 1$ only if it observes $flag[1] = \\text{true}$.\n- $P_1$ writes $turn \\leftarrow 0$ only if it observes $flag[0] = \\text{true}$.\n\nSince both processes are in the CS, both $flag[0]$ and $flag[1]$ must be $\\text{true}$. This implies that if they are contending, each process will see the other's flag as $\\text{true}$ and will attempt to write to $turn$. The SC model imposes a total order on these writes. Let the last write operation to $turn$ before both processes enter their CS be $W_{last}$.\n- Case 1: $W_{last}$ was $P_0$ writing $turn \\leftarrow 1$. After this write, the value of $turn$ is $1$. If $P_0$ then proceeds to its wait loop, it will evaluate $(flag[1] \\land (turn = 1))$, which will be $\\text{true}$ (since $flag[1]$ must be $\\text{true}$ for $P_1$ to be in its CS). Thus, $P_0$ would be blocked. It could not have entered its CS.\n- Case 2: $W_{last}$ was $P_1$ writing $turn \\leftarrow 0$. After this write, the value of $turn$ is $0$. If $P_1$ then proceeds to its wait loop, it will evaluate $(flag[0] \\land (turn = 0))$, which will be $\\text{true}$. Thus, $P_1$ would be blocked.\n\nThe process that writes to $turn$ last effectively yields to the other process, preventing it from entering the CS. The core logic of Peterson's solution is thus preserved in the contended case. In the uncontended case (e.g., $P_0$ runs while $flag[1]$ is $\\text{false}$), $P_0$ skips the write to $turn$ and immediately passes the wait loop because the $flag[1]$ part of the condition is $\\text{false}$. If $P_1$ then tries to enter, it will see $flag[0] = \\text{true}$, set $turn \\leftarrow 0$, and will be forced to wait on the condition $(flag[0] \\land (turn = 0))$.\n\nMutual exclusion is guaranteed.\n\n#### 2. Progress\nProgress requires that if some process wishes to enter its CS and no process is in its CS, then some process must eventually enter. This is primarily a question of avoiding deadlock.\nDeadlock would occur if both processes are stuck in their busy-wait loops forever.\n- $P_0$ is stuck if $(flag[1] \\land (turn = 1))$ is permanently $\\text{true}$.\n- $P_1$ is stuck if $(flag[0] \\land (turn = 0))$ is permanently $\\text{true}$.\n\nIf both are attempting to enter, both will set their flags to $\\text{true}$. For deadlock, we would need both loop conditions to be $\\text{true}$. This requires $(turn = 1)$ AND $(turn = 0)$ to hold simultaneously, which is impossible. Therefore, at any time, at most one process can be blocked by the $turn$ variable. The other process's loop condition will be $\\text{false}$, allowing it to enter its CS. Progress is guaranteed.\n\n#### 3. Bounded Waiting\nBounded waiting means that a process $P_i$ wishing to enter its CS will do so before the other process $P_j$ is allowed to enter its own CS some unbounded number of times.\nAssume $P_0$ wishes to enter its CS. It sets $flag[0] \\leftarrow \\text{true}$ and is now waiting at its loop. For $P_0$ to be waiting, it must be that $flag[1] = \\text{true}$ and $turn = 1$. This means $P_1$ is also in its entry section or critical section.\n$P_1$ can be in its CS because its wait condition $(flag[0] \\land (turn = 0))$ is $\\text{false}$ (since $turn=1$).\nNow, once $P_1$ exits its CS, it sets $flag[1] \\leftarrow \\text{false}$. This immediately makes $P_0$'s wait condition $(flag[1] \\land (turn = 1))$ become $\\text{false}$, allowing $P_0$ to proceed.\nWhat if $P_1$ is very fast and tries to re-enter its CS before $P_0$ (which is now unblocked) gets to run?\n- $P_1$ loops back and executes its entry protocol again. It sets $flag[1] \\leftarrow \\text{true}$.\n- It then observes $flag[0]$ is $\\text{true}$ (since $P_0$ is still waiting to enter).\n- Consequently, $P_1$ executes the conditional write: $turn \\leftarrow 0$.\nThis action is key. By setting $turn \\leftarrow 0$, $P_1$ guarantees that $P_0$'s wait condition $(flag[1] \\land (turn = 1))$ will be $\\text{false}$, as now $turn \\neq 1$. $P_0$ is guaranteed to be able to enter. Meanwhile, $P_1$ will now be stuck at its own wait loop, evaluating $(flag[0] \\land (turn = 0))$ as $\\text{true}$.\nThus, a waiting process $P_i$ can be overtaken by $P_j$ at most once. Bounded waiting is guaranteed.\n\n### Analysis on Architectures without Sequential Consistency\n\nOn many modern multi-core processors, memory consistency models are \"weaker\" than SC. This means the hardware can reorder memory operations for performance, e.g., a write followed by a read to different locations may not appear in program order to other processors. Peterson's algorithm (and this variant) relies on the strict ordering provided by SC. For example, process $P_i$ executes $flag[i] \\leftarrow \\text{true}$ followed by a read of $flag[j]$. On a weak memory model, the read of $flag[j]$ could be performed before the write to $flag[i]$ is made visible to $P_j$. This can lead to a state where both $P_0$ and $P_1$ read the other's flag as $\\text{false}$ and proceed to enter their critical sections, violating mutual exclusion. To prevent this, memory fences (or barrier instructions) are required to enforce the necessary ordering. The conditional update in the variant does not act as a memory fence and does not remedy this fundamental issue.\n\n### Evaluation of the Options\n\n**A. Compared to the textbook Peterson’s solution, this variant reduces writes to `turn` when there is no contention (i.e., when `flag[j] = false`), and under SC with atomic reads/writes it still guarantees mutual exclusion, progress, and bounded waiting.**\nThis statement is correct. The conditional write `if ($flag[j]$)` explicitly avoids writing to $turn$ in the uncontended case, which is an optimization. As shown in the detailed analysis above, all three correctness properties (mutual exclusion, progress, and bounded waiting) are preserved under the SC model, because in the contended case (the only difficult one), the algorithm's logic becomes identical to the textbook Peterson's solution.\n**Verdict: Correct.**\n\n**B. The variant can violate mutual exclusion: if both processes observe `flag[j] = false` at the conditional update, both can enter the critical section because `turn` may retain a stale value.**\nThis statement is incorrect. The premise that \"both processes observe $flag[j] = \\text{false}$\" is impossible under SC. For $P_0$ to observe $flag[1]=\\text{false}$, its read must occur before $P_1$'s write to $flag[1]$. For $P_1$ to observe $flag[0]=\\text{false}$, its read must occur before $P_0$'s write to $flag[0]$. However, each process writes to its own flag *before* reading the other's. This leads to a logical contradiction in the required total order of operations under SC. Thus, the premise is flawed, and mutual exclusion is not violated in this manner.\n**Verdict: Incorrect.**\n\n**C. The variant can deadlock: if neither process updates `turn` (because each observed `flag[j] = false`), both busy-wait forever with `turn` unchanged.**\nThis statement is incorrect. Firstly, as established for option B, the premise that both processes observe $flag[j] = \\text{false}$ is impossible under SC. Secondly, if a process $i$ did observe $flag[j] = \\text{false}$, the first part of its busy-wait condition $(flag[j] \\land \\dots)$ would be $\\text{false}$, and it would not busy-wait at all; it would proceed directly to the critical section. The statement is logically inconsistent.\n**Verdict: Incorrect.**\n\n**D. The variant preserves mutual exclusion and progress under SC but can violate bounded waiting; one process can starve while the other repeatedly re-enters.**\nThis statement is incorrect. It correctly identifies that mutual exclusion and progress are preserved, but incorrectly claims bounded waiting is violated. As shown in the analysis, the mechanism that ensures bounded waiting in Peterson's solution remains intact. A process $j$ attempting to re-enter the CS while $i$ is waiting is forced to set $turn \\leftarrow i$, which guarantees that $i$ gets the next turn.\n**Verdict: Incorrect.**\n\n**E. On architectures without SC and in the absence of appropriate memory-ordering primitives (such as memory fences), both the textbook Peterson’s solution and this variant can fail; the conditional update does not remedy weak-memory reorderings.**\nThis statement is correct. It is a well-known fact that software-only mutual exclusion algorithms like Peterson's are not correct on processors with weak memory models unless explicit memory fences are used to enforce program order on key memory operations. The modification in this variant (a conditional write) is a control-flow change, not a memory-ordering primitive. It does not prevent harmful reorderings and thus does not fix the algorithm's vulnerability on such architectures. Both the original algorithm and this variant would fail in the same ways.\n**Verdict: Correct.**", "answer": "$$\\boxed{AE}$$", "id": "3669493"}, {"introduction": "Our final exercise investigates a more significant structural modification to the protocol. In this variant [@problem_id:3669502], the `$turn$` variable is no longer set upon entry but is instead toggled upon exiting the critical section, creating a new mechanism for enforcing alternation. Your task is to apply rigorous analysis to determine if this redesigned protocol still upholds mutual exclusion and to characterize its specific fairness properties, such as bounded waiting.", "problem": "Consider a system with $2$ concurrent processes $P_0$ and $P_1$ that coordinate access to a shared Critical Section (CS) using a modified two-process protocol similar to Peterson's solution. The shared variables are $flag[0]$, $flag[1]$ (booleans initially $false$) and $turn \\in \\{0,1\\}$ (initially arbitrary but fixed). Each process $P_i$ follows an entry protocol that sets $flag[i] := true$ and then busy-waits on the predicate $(flag[j] \\land turn = j)$ where $j = 1 - i$. The exit protocol sets $flag[i] := false$ and toggles the shared variable $turn$ by assigning $turn := 1 - turn$ (no assignment to $turn$ happens during the entry protocol). All reads and writes to the shared variables are assumed to be atomic and obey sequential consistency. Mutual exclusion means that at no time are both processes in the CS simultaneously. Fairness in this context refers to the Bounded Waiting (BW) property: if $P_i$ sets $flag[i] := true$, then there is a finite bound on the number of times $P_j$ can enter the CS before $P_i$ eventually enters; First-Come-First-Served (FCFS) is stronger and requires that arrival order determines service order when arrivals occur without overlap.\n\nBased on the fundamental definitions above and the stated memory assumptions, which of the following statements best characterizes the mutual exclusion and fairness properties of this variant?\n\nA. Mutual exclusion is preserved. Bounded Waiting holds and, under sustained contention where $flag[0] = flag[1] = true$, the protocol enforces strict alternation of access to the CS, but it does not guarantee First-Come-First-Served across all arrival patterns.\n\nB. Mutual exclusion is preserved, but Bounded Waiting fails: one process can starve while the other enters the CS arbitrarily many times.\n\nC. Mutual exclusion is violated: when both processes set $flag[i] := true$ concurrently, both can enter the CS at the same time because toggling $turn$ occurs only on exit.\n\nD. Mutual exclusion is preserved, but fairness is worse than in the original Peterson's solution: a process can be overtaken more than once before entering the CS when both are competing continuously.", "solution": "The protocol for process $P_i$, where $i \\in \\{0,1\\}$ and $j = 1 - i$, is as follows:\n\nShared variables:\n- $flag[0], flag[1]$: boolean, initialized to $false$.\n- $turn$: integer $\\in \\{0,1\\}$, initialized to an arbitrary but fixed value.\n\nEntry Protocol for $P_i$:\n```\nflag[i] := true;\nwhile (flag[j] \\land turn = j) {\n    // busy wait\n}\n```\n\nCritical Section (CS) for $P_i$:\n```\n// Critical Section code\n```\n\nExit Protocol for $P_i$:\n```\nflag[i] := false;\nturn := 1 - turn;\n```\n\nWe will now analyze the properties of this protocol.\n\n### 1. Mutual Exclusion\n\nTo demonstrate mutual exclusion, we will use proof by contradiction. Assume that both processes $P_0$ and $P_1$ are in their respective critical sections simultaneously.\n\nIf $P_0$ is in its CS, it must have executed its entry protocol and found the condition of its `while` loop to be $false$. The condition for $P_0$ is `flag[1] \\land turn = 1`. For $P_0$ to enter the CS, it must be the case that at the time of its final check, `\\neg(flag[1] \\land turn = 1)` was true.\n\nSimilarly, if $P_1$ is in its CS, it must have found the condition of its `while` loop, `flag[0] \\land turn = 0`, to be $false$. For $P_1$ to enter the CS, it must be the case that at the time of its final check, `\\neg(flag[0] \\land turn = 0)` was true.\n\nWhen both processes are in the CS, they must have both previously set their flags to $true$. Thus, at the moment of simultaneous occupation, $flag[0] = true$ and $flag[1] = true$.\n\nLet's re-examine the loop conditions under this state ($flag[0] = true$ and $flag[1] = true$):\n- For $P_0$ to have entered, its condition `(flag[1] \\land turn = 1)` must have been $false$. Since $flag[1]$ is $true$, this implies that `turn = 1` must have been $false$. Therefore, $P_0$ must have observed $turn = 0$.\n- For $P_1$ to have entered, its condition `(flag[0] \\land turn = 0)` must have been $false$. Since $flag[0]$ is $true$, this implies that `turn = 0` must have been $false$. Therefore, $P_1$ must have observed $turn = 1$.\n\nIn order for both processes to enter the CS, the shared variable $turn$ would need to be equal to $0$ (for $P_0$ to proceed) and equal to $1$ (for $P_1$ to proceed) at the same time. Since $turn$ can only hold a single value at any given moment, this is a contradiction.\n\nTherefore, both processes cannot be in the critical section simultaneously. **Mutual exclusion is preserved.**\n\n### 2. Fairness (Bounded Waiting and Alternation)\n\nBounded Waiting requires that if a process $P_i$ indicates its desire to enter the CS (by setting $flag[i] := true$), there is a finite bound on the number of times the other process $P_j$ can enter the CS before $P_i$ is granted access.\n\nLet's consider process $P_0$ waiting to enter the CS. For $P_0$ to be stuck in its `while` loop, the condition `flag[1] \\land turn = 1` must be true. This means:\n1.  $flag[1] = true$: $P_1$ is either in its CS or also waiting to enter.\n2.  $turn = 1$: The $turn$ variable is set to favor $P_0$'s entry (since $P_0$ waits when $turn=1$). This means $P_1$ can enter, as its wait condition `(flag[0] \\land turn=0)` is false because $turn \\neq 0$.\n\nSo, if $P_0$ is waiting, it is possible for $P_1$ to be in the CS. Let's see what happens when $P_1$ exits its CS.\n$P_1$ executes its exit protocol:\n1.  $flag[1] := false$. This action alone makes $P_0$'s waiting condition `(flag[1] \\land turn = 1)` become $false$, allowing $P_0$ to proceed.\n2.  $turn := 1 - turn$. Since $P_0$ was waiting, we know $turn$ was $1$. So $P_1$ will set $turn := 1 - 1 = 0$. This also makes $P_0$'s waiting condition false.\n\nAfter $P_1$ exits the CS, $P_0$ is guaranteed to be able to enter. $P_1$ cannot re-enter the CS ahead of $P_0$ because upon exiting, $P_1$ relinquishes its claim by setting $flag[1]:=false$ and also changes $turn$ in a way that frees $P_0$. For $P_1$ to re-enter, it would have to set $flag[1]:=true$ again, but by then $P_0$ will have already passed its wait condition.\n\nThus, if $P_0$ is waiting, $P_1$ can enter the CS at most one time before $P_0$ is guaranteed entry. This is known as a $1$-bounded wait. **Bounded Waiting is preserved.**\n\nFurthermore, under sustained contention where both $flag[0]$ and $flag[1]$ are continuously $true$, the `turn := 1 - turn` statement in the exit section forces strict alternation. If $P_0$ enters, $turn$ must have been $0$. Upon exit, it sets $turn$ to $1$. Now $P_1$ can enter, and $P_0$ must wait. When $P_1$ exits, it sets $turn$ to $0$, allowing $P_0$ to enter next.\n\n### 3. First-Come-First-Served (FCFS)\n\nFCFS implies that if $P_i$ arrives (sets $flag[i] := true$) before $P_j$, then $P_i$ should enter the CS before $P_j$. Let's test this with a counterexample.\n\nAssume the initial state is $flag[0] = false$, $flag[1] = false$, and $turn = 0$.\nConsider the following sequence of events:\n1.  $P_1$ \"arrives\" and executes `flag[1] := true`.\n2.  A context switch occurs before $P_1$ can check its `while` condition.\n3.  $P_0$ runs and executes Its entry protocol: `flag[0] := true`.\n4.  The state is now: $flag[0] = true$, $flag[1] = true$, $turn = 0$.\n5.  $P_0$ checks its wait condition: `(flag[1] \\land turn = 1)`. This evaluates to `(true \\land 0 = 1)`, which is $false$. $P_0$ enters the CS.\n6.  A context switch occurs. $P_1$ resumes and checks its wait condition: `(flag[0] \\land turn = 0)`. This evaluates to `(true \\land 0 = 0)`, which is $true$. $P_1$ must wait.\n\nIn this scenario, $P_1$ set its flag first, indicating it arrived first. However, due to the initial value of $turn$ and the interleaving of instructions, $P_0$ entered the CS first. Therefore, the protocol **does not guarantee First-Come-First-Served.**\n\n### Evaluation of Options\n\n**A. Mutual exclusion is preserved. Bounded Waiting holds and, under sustained contention where $flag[0] = flag[1] = true$, the protocol enforces strict alternation of access to the CS, but it does not guarantee First-Come-First-Served across all arrival patterns.**\n- `Mutual exclusion is preserved.` - This is **Correct**, as demonstrated by our analysis.\n- `Bounded Waiting holds` - This is **Correct**. The waiting is $1$-bounded.\n- `...enforces strict alternation...` - This is **Correct**, as the `turn` variable is toggled on every exit.\n- `...does not guarantee First-Come-First-Served...` - This is **Correct**, as shown by the counterexample.\nThis statement accurately and comprehensively describes the protocol's properties.\n\n**B. Mutual exclusion is preserved, but Bounded Waiting fails: one process can starve while the other enters the CS arbitrarily many times.**\n- This is **Incorrect**. As shown in the analysis, Bounded Waiting holds. A waiting process is guaranteed to enter after the other process exits at most once. Starvation is impossible.\n\n**C. Mutual exclusion is violated: when both processes set $flag[i] := true$ concurrently, both can enter the CS at the same time because toggling $turn$ occurs only on exit.**\n- This is **Incorrect**. The `turn` variable, even though static during the entry phase, is sufficient to act as a tie-breaker and ensure that only one process can pass its `while` loop when both flags are raised. Mutual exclusion is preserved.\n\n**D. Mutual exclusion is preserved, but fairness is worse than in the original Peterson's solution: a process can be overtaken more than once before entering the CS when both are competing continuously.**\n- This is **Incorrect**. The analysis showed that a process can be \"overtaken\" at most once, resulting in a $1$-bounded wait. The original Peterson's solution also exhibits a $1$-bounded wait. Therefore, the fairness property in terms of bounded waiting is not worse; it is equivalent.\n\n**Conclusion:**\nOption A is the only statement that correctly and completely characterizes the behavior of the given synchronization protocol.", "answer": "$$\\boxed{A}$$", "id": "3669502"}]}