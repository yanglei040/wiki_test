{"hands_on_practices": [{"introduction": "The producer-consumer pattern is a cornerstone of concurrent programming, forming the basis for everything from command-line pipelines to large-scale data processing systems. This first exercise focuses on the bounded-buffer problem, where the precise ordering of synchronization operations is paramount for correctness. By diagnosing a faulty implementation, you will learn to trace thread interleavings to uncover subtle race conditions and understand why the canonical semaphore solution is structured the way it is [@problem_id:3687132].", "problem": "Consider the classical bounded-buffer producer-consumer problem implemented with counting semaphores and a binary mutex. Let there be two producers $P_1$ and $P_2$ and one consumer $C$. The buffer has capacity $B$, and the shared integer $count$ tracks the number of occupied slots. The system uses counting semaphores $empty$ and $full$ with initial values $empty = B - count$ and $full = count$, and a binary mutex $m$ protecting the buffer and $count$. The semantics of the primitives are: $\\text{wait}(s)$ atomically decrements semaphore $s$ or blocks if its value is $0$, and $\\text{signal}(s)$ atomically increments $s$ and wakes one blocked thread if any. The critical correctness invariant is $0 \\le count \\le B$ at all times, and modifications to the buffer and $count$ occur only while holding $m$.\n\nAssume the following intended producer sequence:\n- $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into the buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n\nHowever, the consumer is incorrectly implemented to signal $empty$ prematurely:\n- $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from the buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n\nStarting from the scientifically consistent initial state $B = 2$, $count = 2$, $empty = 0$, $full = 2$, and with both $P_1$ and $P_2$ initially blocked on $\\text{wait}(empty)$, construct an interleaving that shows how the premature $\\text{signal}(empty)$ by $C$ can lead to a violation of the invariant $count \\le B$. Then, identify a corrected consumer sequence that ensures the invariant $0 \\le count \\le B$ is preserved under all interleavings, by respecting mutual exclusion and capacity semantics.\n\nWhich option below both\n- provides a concrete interleaving (given the faulty consumer above) that makes $count$ exceed $B$, and\n- proposes a corrected consumer ordering that prevents such violations for any interleaving?\n\nA. Interleaving demonstrating violation, then corrected consumer:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Corrected consumer sequence:\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$, then $\\text{signal}(empty)$.\n\nB. Interleaving with no violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{wait}(m)$, then $\\text{signal}(empty)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$.\n- Proposed consumer fix (still premature):\n  - $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nC. Interleaving demonstrating violation, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(empty)$.\n  - $P_1$: $\\text{wait}(empty)$, then $\\text{wait}(m)$.\n  - $C$: $\\text{wait}(m)$ blocks while $P_1$ holds $m$.\n  - $P_1$: $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$, then $\\text{signal}(m)$.\n- Proposed consumer fix (moves $\\text{take}$ outside mutual exclusion):\n  - $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(empty)$, then $\\text{signal}(m)$.\n\nD. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:\n- Interleaving:\n  - $C$: $\\text{wait}(full)$, then $\\text{signal}(full)$, then $\\text{wait}(m)$.\n  - $P_1$: $\\text{wait}(full)$ succeeds, then $\\text{wait}(m)$, then $\\text{put}$, then $count := count + 1$ so $count = 3$ while $B = 2$.\n- Proposed consumer fix (misordered and missing $\\text{signal}(empty)$):\n  - $\\text{wait}(full)$, then $\\text{wait}(m)$, then $count := count - 1$, then $\\text{signal}(m)$.\n\nSelect the single best option.", "solution": "The problem statement is subjected to validation before proceeding.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Processes: Two producers, $P_1$ and $P_2$, and one consumer, $C$.\n- Buffer Capacity: $B$.\n- Shared State: An integer $count$ tracking the number of occupied slots.\n- Synchronization Primitives:\n    - Counting semaphore $empty$, initialized to $B - count$.\n    - Counting semaphore $full$, initialized to $count$.\n    - Binary mutex $m$.\n- Primitive Semantics:\n    - $\\text{wait}(s)$: Atomically decrements semaphore $s$ or blocks if its value is $0$.\n    - $\\text{signal}(s)$: Atomically increments $s$ and wakes one blocked thread if any.\n- Correctness Invariant: $0 \\le count \\le B$ must hold at all times.\n- Producer Logic: $\\text{wait}(empty)$, then $\\text{wait}(m)$, then $\\text{put}$ into buffer, then $count := count + 1$, then $\\text{signal}(m)$, then $\\text{signal}(full)$.\n- Faulty Consumer Logic: $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, then $\\text{take}$ from buffer, then $count := count - 1$, then $\\text{signal}(m)$.\n- Specific Initial State: $B = 2$, $count = 2$, $empty = 0$, $full = 2$. Both $P_1$ and $P_2$ are initially blocked on $\\text{wait}(empty)$. The mutex $m$ is assumed to be available (value $1$).\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of concurrent programming and operating systems. It describes a classic synchronization problem (bounded-buffer) with standard primitives (semaphores, mutex). The terminology is precise and objective. The provided initial state ($B=2, count=2, empty=0, full=2$) is consistent with the definitions ($empty=B-count=2-2=0$; $full=count=2$). The problem is well-posed, asking for a specific execution trace that demonstrates a flaw and a corrected code sequence. The setup is not incomplete, contradictory, or unrealistic for a software context. It represents a common type of programming error.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. A solution will be derived.\n\n### Derivation of Solution\n\nThe core of the problem lies in the interaction between the faulty consumer $C$ and a producer, say $P_1$. The invariant to be violated is $count \\le B$. We need to show how an interleaving can lead to $count > 2$.\n\n**1. Analysis of the Flaw**\n\nThe standard producer-consumer solution uses the $empty$ and $full$ semaphores to enforce the buffer capacity constraints. A producer must wait for an empty slot (by calling $\\text{wait}(empty)$) before producing, and a consumer must wait for a full slot (by calling $\\text{wait}(full)$) before consuming.\n\n- The **Producer** logic is correct: It waits for an empty slot ($\\text{wait}(empty)$), acquires a lock ($\\text{wait}(m)$) to update the shared state, adds an item and increments $count$, releases the lock ($\\text{signal}(m)$), and finally signals that a slot is now full ($\\text{signal}(full)$).\n- The **Consumer** logic is faulty. The operations $\\text{wait}(full)$ and $\\text{signal}(empty)$ should conceptually bracket the consumption of an item. However, the sequence is given as $\\text{wait}(full)$, then $\\text{signal}(empty)$, then $\\text{wait}(m)$, etc. The consumer signals that a slot is empty *before* it has actually acquired the lock $m$ and removed the item from the buffer. This creates a race condition. The consumer advertises a resource (an empty slot) that does not yet exist.\n\n**2. Constructing a Violating Interleaving**\n\nLet's trace an execution starting from the initial state: $B=2$, $count=2$, $empty=0$, $full=2$, $m=1$. $P_1$ and $P_2$ are blocked on $\\text{wait}(empty)$.\n\n1.  $C$ starts execution. The producers are blocked, so they cannot run.\n2.  $C$ executes $\\text{wait}(full)$. The value of $full$ is $2$, so the call succeeds, and $full$ is decremented to $1$.\n3.  $C$ executes its faulty instruction: $\\text{signal}(empty)$. The value of $empty$ was $0$. This call increments $empty$ to $1$. Since $P_1$ (or $P_2$) was blocked on this semaphore, the operating system unblocks $P_1$. $P_1$ is now in the ready state, having completed its $\\text{wait}(empty)$ call.\n4.  At this point, a context switch occurs, and the scheduler chooses to run $P_1$. The consumer $C$ is preempted before it can execute $\\text{wait}(m)$.\n5.  $P_1$ executes its next instruction, $\\text{wait}(m)$. The mutex $m$ is available (value $1$), so $P_1$ acquires it, and the value of $m$ becomes $0$. $P_1$ is now in its critical section.\n6.  Inside its critical section, $P_1$ performs a $\\text{put}$ operation. The buffer, which was full, now overflows.\n7.  $P_1$ executes $count := count + 1$. The value of $count$ was $2$. It is now incremented to $3$.\n8.  At this moment, the invariant $count \\le B$ is violated, since $count = 3$ and $B = 2$. The violation has occurred. The rest of the execution sequence for $P_1$ ($\\text{signal}(m)$, $\\text{signal}(full)$) and the eventual execution of $C$ (which will block on $\\text{wait}(m)$ until $P_1$ releases it) do not alter this fact.\n\nThis interleaving demonstrates the violation successfully.\n\n**3. Proposing a Corrected Consumer Sequence**\n\nTo fix the bug, the consumer must only signal that a slot is empty *after* it has completed the removal of an item and the corresponding update of the shared variable $count$. The modification of shared state (the buffer and $count$) must be protected by the mutex $m$. Therefore, the $\\text{signal}(empty)$ call must be moved to after the critical section.\n\nThe correct, standard sequence for the consumer is:\n1.  $\\text{wait}(full)$: Wait until there is at least one item in the buffer.\n2.  $\\text{wait}(m)$: Acquire the lock to access shared state.\n3.  $\\text{take}$: Remove an item from the buffer.\n4.  $count := count - 1$: Decrement the count of items.\n5.  $\\text{signal}(m)$: Release the lock.\n6.  $\\text{signal}(empty)$: Signal to producers that a slot has been freed.\n\nThis ordering ensures that the semaphore $empty$ correctly represents the number of available slots, preventing the race condition that led to the violation.\n\n### Option-by-Option Analysis\n\n**A. Interleaving demonstrating violation, then corrected consumer:**\n- **Interleaving:** The described interleaving ($C$ runs $\\text{wait}(full)$, then $\\text{signal}(empty)$; then $P_1$ wakes up, acquires $m$, and increments $count$ to $3$) directly matches the violation trace derived above. This part is correct.\n- **Corrected consumer sequence:** The proposed sequence is $\\text{wait}(full)$, $\\text{wait}(m)$, $\\text{take}$, $count := count - 1$, $\\text{signal}(m)$, $\\text{signal}(empty)$. This is the canonical correct implementation, as derived above. This part is correct.\n- **Verdict:** **Correct**.\n\n**B. Interleaving with no violation, then incorrect consumer fix:**\n- **Interleaving:** This describes an interleaving where $C$ acquires the mutex before a context switch. As analyzed, this specific interleaving does not produce the violation. The task was to show an interleaving that *does* produce a violation. This part fails the task.\n- **Proposed consumer fix:** The proposed \"fix\" is identical to the original faulty sequence. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**C. Interleaving demonstrating violation, then incorrect consumer fix:**\n- **Interleaving:** The interleaving is described in slightly more detail than in option A (explicitly showing $C$ blocking on $m$), but it is conceptually the same correct demonstration of the violation. This part is correct.\n- **Proposed consumer fix:** The proposed sequence is $\\text{wait}(full)$, then $\\text{take}$, then $\\text{wait}(m)$, ... This is critically flawed. The $\\text{take}$ operation modifies the shared buffer but is placed outside the critical section protected by the mutex $m$. This introduces a different a race condition. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\n**D. Interleaving demonstrating violation using $\\text{signal}(full)$ prematurely, then incorrect consumer fix:**\n- **Interleaving:** The interleaving describes a different fault, a premature $\\text{signal}(full)$. The problem explicitly states the fault is a premature $\\text{signal}(empty)$. Furthermore, it incorrectly claims that producers wait on `full`, when they wait on `empty`. This part is inconsistent with the problem statement.\n- **Proposed consumer fix:** The proposed fix is missing the $\\text{take}$ operation and the $\\text{signal}(empty)$ call, which would cause the system to deadlock eventually as producers would never be signaled. This part is incorrect.\n- **Verdict:** **Incorrect**.\n\nBased on the analysis, option A is the only one that both correctly demonstrates the violation with a valid interleaving and provides the standard, correct fix for the consumer's logic.", "answer": "$$\\boxed{A}$$", "id": "3687132"}, {"introduction": "Moving beyond basic patterns, this practice tackles a common real-world design challenge: upgrading a lock from a shared read-lock to an exclusive write-lock. While this feature is highly useful for read-modify-write cycles, a naive implementation creates a classic deadlock scenario when multiple threads attempt to upgrade simultaneously. This exercise guides you through designing a deadlock-free upgrade protocol, demonstrating how to break the circular-wait condition using atomic operations and providing insight into the construction of sophisticated synchronization primitives [@problem_id:3625789].", "problem": "A shared in-memory data structure is protected by a Read-Write Lock (RWLock). Threads may acquire the lock in shared mode (denoted by $R$) to read concurrently, or in exclusive mode (denoted by $W$) to write with mutual exclusion. We wish to support an “upgrade” operation whereby a thread holding $R$ can promote to $W$ without releasing the lock in between, so that its read-then-write critical section is linearizable. The upgrade must ensure that no other $W$ is interleaved between the read and the resulting write. Assume the following foundational model and facts:\n- Mutual exclusion for $W$: if a $W$ holder exists, then the number of concurrent readers $r$ is $0$, and there is at most $1$ writer active.\n- Shared access for $R$: if no $W$ holder exists, any number of readers may hold $R$.\n- Atomic Read-Modify-Write operations are available, specifically Compare-And-Swap (CAS).\n- Queues for waiting writers and upgraders are First-In-First-Out (FIFO).\n- Weak fairness: a thread that remains continuously enabled will eventually be scheduled; no thread holds the lock forever.\n- Linearizability of upgrade: a thread that upgrades from $R$ to $W$ must appear as if the $R$ critical section and its $W$ critical section are contiguous, with no intervening $W$ by another thread.\n- The classic Readers-Writers constraints and Coffman conditions for deadlock apply: deadlock may arise under mutual exclusion, hold-and-wait, no preemption, and circular wait.\n\nConsider the risk of deadlock when multiple threads attempt to upgrade simultaneously while holding $R$. You are asked to choose a protocol that guarantees both deadlock freedom and progress (no starvation) for upgrade requests, under the assumptions above, while preserving the linearizability requirement.\n\nWhich option describes a correct upgrade protocol that prevents deadlock and ensures progress for upgraders?\n\nA. Each upgrader holds its $R$, sets a per-thread “upgrading” flag, and busy-waits until the reader count $r$ becomes $1$, then atomically promotes to $W$. New readers are admitted normally while any upgrader waits. Multiple simultaneous upgraders are allowed.\n\nB. At most $1$ upgrader holds $R$ while waiting: an upgrader first attempts to set a global UpgradePending flag using CAS; if CAS succeeds, it continues to hold its $R$, and all new readers are blocked while UpgradePending is set or while any writers are waiting. The upgrader waits until $r=1$ and no active $W$, then atomically promotes to $W$, completes its write, clears UpgradePending, and wakes the next waiter. If CAS fails (another upgrader already holds the gate), the thread releases $R$ and enqueues on the writer FIFO. Writers and upgraders are served in FIFO order, and while writers or an upgrader are queued, new readers are blocked.\n\nC. An upgrader always releases its $R$ and then enqueues as a writer behind existing writers, with no special admission policy or barriers on new readers. When it reaches the head of the writer queue, it acquires $W$.\n\nD. Multiple simultaneous upgraders are allowed and are given strict priority over writers, but new readers are never blocked. Each upgrader busy-waits while $r \\neq 1$ and then promotes atomically to $W$ when possible. Writers wait behind any upgraders; readers always continue to be admitted.\n\nSelect the single best option.", "solution": "The user wants me to act as a STEM professor to solve a problem about read-write lock upgrade protocols in operating systems.\n\n### Problem Validation\n\nFirst, I must validate the problem statement.\n\n**Step 1: Extract Givens**\n\n- A shared in-memory data structure is protected by a Read-Write Lock (RWLock).\n- Shared mode is denoted by $R$ (read concurrently).\n- Exclusive mode is denoted by $W$ (write with mutual exclusion).\n- An \"upgrade\" operation allows a thread holding $R$ to promote to $W$ without releasing the lock.\n- The goal of the upgrade is to make the read-then-write critical section linearizable.\n- Constraint on upgrade: no other $W$ can be interleaved between the read and the resulting write.\n- Mutual exclusion for $W$: If a $W$ holder exists, the number of concurrent readers $r$ is $0$, and there is at most $1$ writer active.\n- Shared access for $R$: If no $W$ holder exists, any number of readers may hold $R$.\n- Atomic operations: Compare-And-Swap (CAS) is available.\n- Queues: Waiting writers and upgraders are served First-In-First-Out (FIFO).\n- Fairness: Weak fairness is assumed (a continuously enabled thread will eventually be scheduled). No thread holds a lock forever.\n- Linearizability of upgrade: The $R$ critical section and subsequent $W$ critical section must appear contiguous, with no intervening $W$ by another thread.\n- Deadlock context: The problem mentions the relevance of the Coffman conditions for deadlock (mutual exclusion, hold-and-wait, no preemption, circular wait).\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is a classic and fundamental topic in concurrent programming and operating systems. Read-write locks, lock upgrading, deadlock, starvation, linearizability, and atomic operations like CAS are all well-established concepts in computer science. The problem is scientifically sound.\n- **Well-Posed:** The problem is well-posed. It clearly defines the initial state (an RWLock model), the desired operation (a linearizable upgrade), the constraints (deadlock freedom, progress), and the tools available (CAS, FIFO queues). The question asks for a protocol that meets these specific requirements.\n- **Objective:** The language is formal and objective. Terms are used with their precise technical meanings.\n- **Completeness and Consistency:** The problem provides sufficient information to analyze the potential for deadlock and starvation in the proposed protocols. The requirements for linearizability, deadlock freedom, and progress are consistent with each other and form a coherent set of design goals for a concurrency primitive.\n- **No other flaws detected:** The problem is not unrealistic, ill-posed, trivial, or unverifiable. It represents a a real-world design challenge in concurrent systems.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is valid. I will proceed to the solution.\n\n### Solution Derivation\n\nThe central challenge in implementing an upgradeable read-write lock is preventing deadlock while ensuring progress and correctness (linearizability). The classic deadlock scenario arises when two or more threads, each holding a read lock ($R$), attempt to upgrade to a write lock ($W$) simultaneously.\n\nLet's analyze this deadlock using the Coffman conditions:\n1.  **Mutual Exclusion:** The write lock ($W$) is exclusive by definition. An upgrader needs exclusive access, but other threads (readers or another upgrader candidate) hold locks.\n2.  **Hold-and-Wait:** An upgrader is *holding* its read lock ($R$) while *waiting* for the condition $r=1$ to be met, which requires other readers to release their locks.\n3.  **No Preemption:** The problem specifies the upgrade happens \"without releasing the lock in between,\" which is a form of no preemption for the held resource ($R$).\n4.  **Circular Wait:** If thread $T_1$ and thread $T_2$ both hold $R$ and both decide to upgrade, $T_1$ waits for $T_2$ to release its $R$ lock (so $r$ can become $1$), and $T_2$ simultaneously waits for $T_1$ to release its $R$ lock. This forms a circular dependency.\n\nA correct protocol must break at least one of these conditions. The most practical condition to break is the circular wait. This can be achieved by allowing at most one thread to be in the \"attempting to upgrade\" state at any given time.\n\nAdditionally, to ensure progress (liveness), the protocol must prevent starvation. An upgrader waiting for the reader count $r$ to drop to $1$ can be starved if new readers are continuously admitted. Therefore, a valid protocol must temporarily block new readers once an upgrade is initiated.\n\nFinally, for linearizability, the upgrading thread must not release its $R$ lock and then re-acquire a $W$ lock. Doing so would create a window where another writer could intervene, making the data read under the $R$ lock potentially stale for the subsequent write operation.\n\nBased on these principles, a correct protocol must:\n1.  Serialize upgrade attempts to prevent circular wait deadlock (e.g., using a gate or a special flag).\n2.  Block new readers while an upgrade is pending to guarantee the reader count will drain and the upgrader will make progress.\n3.  Ensure the upgrader transitions from $R$ to $W$ without releasing the lock to maintain linearizability.\n4.  Employ a fair queuing mechanism to prevent starvation among writers and potential upgraders.\n\n### Option-by-Option Analysis\n\n**A. Each upgrader holds its $R$, sets a per-thread “upgrading” flag, and busy-waits until the reader count $r$ becomes $1$, then atomically promotes to $W$. New readers are admitted normally while any upgrader waits. Multiple simultaneous upgraders are allowed.**\n\n-   **Deadlock:** \"Multiple simultaneous upgraders are allowed.\" This protocol directly creates the deadlock scenario described above. If two threads hold $R$ and attempt to upgrade, they will wait for each other indefinitely.\n-   **Progress:** \"New readers are admitted normally\". This allows for the starvation of upgraders. A continuous stream of new readers can prevent the reader count $r$ from ever dropping to $1$.\n-   **Verdict:** **Incorrect**.\n\n**B. At most $1$ upgrader holds $R$ while waiting: an upgrader first attempts to set a global UpgradePending flag using CAS; if CAS succeeds, it continues to hold its $R$, and all new readers are blocked while UpgradePending is set or while any writers are waiting. The upgrader waits until $r=1$ and no active $W$, then atomically promotes to $W$, completes its write, clears UpgradePending, and wakes the next waiter. If CAS fails (another upgrader already holds the gate), the thread releases $R$ and enqueues on the writer FIFO. Writers and upgraders are served in FIFO order, and while writers or an upgrader are queued, new readers are blocked.**\n\n-   **Deadlock:** \"At most $1$ upgrader holds $R$ while waiting\". This is enforced by the atomic CAS on a global `UpgradePending` flag. This mechanism serves as a gate, serializing the upgrade attempts and thus breaking the circular wait condition. Deadlock between upgraders is prevented.\n-   **Progress:** \"all new readers are blocked while UpgradePending is set or while any writers are waiting\". This ensures that the current number of readers will drain, guaranteeing that the condition $r=1$ will eventually be met, allowing the upgrader to proceed. The use of a FIFO queue for writers and upgraders ensures fairness and prevents starvation.\n-   **Linearizability:** The successful upgrader (\"if CAS succeeds\") \"continues to hold its $R$\" and promotes to $W$ atomically. This satisfies the linearizability requirement by ensuring no other writer can interleave. The fallback path for a failed CAS (release $R$, enqueue as writer) is a strategy to handle contention without deadlocking; it aborts the linearizable upgrade attempt for that thread but allows the system to progress fairly. The protocol itself correctly provides a path for a linearizable upgrade.\n-   **Verdict:** **Correct**.\n\n**C. An upgrader always releases its $R$ and then enqueues as a writer behind existing writers, with no special admission policy or barriers on new readers. When it reaches the head of the writer queue, it acquires $W$.**\n\n-   **Linearizability:** \"An upgrader always releases its $R$ and then enqueues as a writer\". This explicitly violates the linearizability requirement. In the interval between releasing the $R$ lock and acquiring the $W$ lock, another thread can acquire a $W$ lock, modify the data, and release it. The upgrading thread's initial read would become disconnected from its eventual write.\n-   **Progress:** \"no special admission policy or barriers on new readers\". This creates a reader-preference system that can lead to starvation of all writers, including the thread that was attempting to upgrade.\n-   **Verdict:** **Incorrect**.\n\n**D. Multiple simultaneous upgraders are allowed and are given strict priority over writers, but new readers are never blocked. Each upgrader busy-waits while $r \\neq 1$ and then promotes atomically to $W$ when possible. Writers wait behind any upgraders; readers always continue to be admitted.**\n\n-   **Deadlock:** \"Multiple simultaneous upgraders are allowed\". As with option A, this reintroduces the classic deadlock between two or more upgrading threads.\n-   **Progress:** \"new readers are never blocked... readers always continue to be admitted.\" As with option A, this leads to starvation of the upgraders, as the reader count $r$ may never drop to $1$.\n-   **Verdict:** **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "3625789"}, {"introduction": "While logical correctness is essential, so is performance. This final practice shifts our focus from avoiding bugs like deadlock to guaranteeing throughput in a multi-stage pipeline. Here, you will analyze how timing variations, or \"jitter,\" between processing stages can impact system performance and determine the minimum buffer size needed to absorb these fluctuations without stalling the pipeline. This exercise introduces a quantitative approach to system design, linking the theory of queueing with the practical goal of engineering high-performance, resilient systems [@problem_id:3625809].", "problem": "A three-stage single-threaded processing pipeline consists of Stage $1$, Stage $2$, and Stage $3$ connected by two bounded First-In, First-Out (FIFO) buffers: buffer $B_{12}$ between Stage $1$ and Stage $2$, and buffer $B_{23}$ between Stage $2$ and Stage $3$. Each stage processes exactly one item at a time and, in steady state, sustains a long-run throughput of $Q$ items per second. Let $T = 1/Q$ denote the nominal inter-completion period.\n\nModel the timing variability as follows. There exists an ideal periodic time grid of period $T$ such that:\n- The $k$-th completion of Stage $i$ occurs no more than a bounded deviation of $J_i$ from its ideal grid instant, for all $k \\in \\mathbb{N}$ and for $i \\in \\{1,2\\}$ when considering the arrival processes into $B_{12}$ and $B_{23}$, respectively.\n- The $k$-th start of Stage $i+1$ occurs no more than a bounded deviation of $J_{i+1}$ from its ideal grid instant, for all $k \\in \\mathbb{N}$ and for $i \\in \\{1,2\\}$ when considering the departure processes from $B_{12}$ and $B_{23}$, respectively.\n\nAssume pull-at-start semantics: Stage $i+1$ removes exactly one item from its upstream buffer at the instant it starts processing that item; if the buffer is empty, Stage $i+1$ blocks until an item becomes available. Assume no item loss and no reordering.\n\nUsing only the definitions of cumulative arrival and departure counts for a FIFO buffer, and the bounded-deviation model described above (that is, do not assume or invoke any result that is not derivable from these definitions), derive a closed-form expression for the minimal integer capacities $C_{12}$ and $C_{23}$ that are sufficient to sustain the target throughput $Q$ without overflow for all time under the worst-case timing deviations consistent with $J_1,J_2,J_3$.\n\nThen, compute these capacities for the specific parameters $Q = 120\\,\\mathrm{s}^{-1}$, $J_1 = 0.015\\,\\mathrm{s}$, $J_2 = 0.020\\,\\mathrm{s}$, and $J_3 = 0.012\\,\\mathrm{s}$. Report your final answer as a row matrix $\\big(C_{12}\\;C_{23}\\big)$ with no units.\n\nExperimental verification. To check your result against empirical behavior, use the following instrumented cumulative count traces sampled at times $t \\in \\{0.04\\,\\mathrm{s}, 0.08\\,\\mathrm{s}, 0.12\\,\\mathrm{s}, 0.16\\,\\mathrm{s}\\}$:\n- For $B_{12}$: cumulative arrivals from Stage $1$ are $A_{12}(t) \\in \\{7, 11, 16, 21\\}$ and cumulative consumptions by Stage $2$ are $D_{12}(t) \\in \\{3, 8, 12, 17\\}$ at the corresponding times.\n- For $B_{23}$: cumulative arrivals from Stage $2$ are $A_{23}(t) \\in \\{7, 12, 17, 22\\}$ and cumulative consumptions by Stage $3$ are $D_{23}(t) \\in \\{4, 9, 13, 18\\}$ at the corresponding times.\n\nUsing only the definition of backlog as the difference of cumulative arrivals and departures at the same time, compute the maximum observed backlogs over the provided sample times for $B_{12}$ and $B_{23}$, and comment on whether the computed capacities $C_{12}$ and $C_{23}$ are consistent with these measurements. The final reported answer must be only the capacities as a row matrix; do not include any units in the final boxed answer.", "solution": "The problem statement is evaluated as scientifically grounded, well-posed, objective, and self-contained, presenting a classic problem in performance analysis of concurrent systems. It is therefore deemed valid.\n\nThe core of the problem is to determine the minimal capacity of a First-In, First-Out (FIFO) buffer placed between a producer stage and a consumer stage, given a bounded-deviation timing model for each. Let the producer be Stage $i$ and the consumer be Stage $i+1$. The long-run throughput is $Q$, which corresponds to a nominal processing period of $T = 1/Q$.\n\nThe timing model specifies that the $k$-th event (arrival or departure) occurs at an actual time $t_k$ which deviates from its ideal grid time $k \\cdot T$ by no more than a given jitter value $J$. This is interpreted as $|t_k - kT| \\le J$, or $t_k \\in [kT-J, kT+J]$.\n\nLet's analyze a generic buffer. The producer generates items that arrive at the buffer. The consumer removes items from the buffer.\nLet $J_p$ be the timing deviation for the producer (arrivals) and $J_c$ be the timing deviation for the consumer (departures).\nThe number of items in the buffer at any time $t$, also known as the backlog, is given by $N(t) = A(t) - D(t)$, where $A(t)$ is the cumulative number of arrivals up to time $t$ and $D(t)$ is the cumulative number of departures up to time $t$. We assume $A(0)=0$ and $D(0)=0$.\n\nThe buffer capacity, $C$, must be large enough to hold the maximum possible backlog at any time, for any sequence of events consistent with the timing model. Thus, we must find $C \\ge \\max_{t \\ge 0} N(t)$ under worst-case conditions. The worst case for backlog occurs when arrivals are as early as possible and departures are as late as possible.\n\nThe cumulative number of arrivals up to time $t$, $A(t)$, is the count of items $k$ for which the arrival time $t_{A,k}$ is less than or equal to $t$. To maximize $A(t)$, we must assume the earliest possible arrival times. According to the model, the earliest time for the $k$-th arrival is $t_{A,k}^{\\min} = kT - J_p$.\nThe maximum cumulative arrival count at time $t$ is therefore:\n$$A_{\\max}(t) = \\sup \\{ k \\in \\mathbb{N} \\mid t_{A,k}^{\\min} \\le t \\} = \\sup \\{ k \\in \\mathbb{N} \\mid kT - J_p \\le t \\}$$\nFor $t$ large enough such that $t+J_p \\ge T$, this gives:\n$$A_{\\max}(t) = \\left\\lfloor \\frac{t+J_p}{T} \\right\\rfloor$$\n\nSimilarly, to minimize the cumulative departure count $D(t)$, we must assume the latest possible departure times. The latest time for the $k$-th departure is $t_{D,k}^{\\max} = kT + J_c$.\nThe minimum cumulative departure count at time $t$ is:\n$$D_{\\min}(t) = \\sup \\{ k \\in \\mathbb{N} \\mid t_{D,k}^{\\max} \\le t \\} = \\sup \\{ k \\in \\mathbb{N} \\mid kT + J_c \\le t \\}$$\nFor $t$ large enough such that $t-J_c \\ge T$, this gives:\n$$D_{\\min}(t) = \\left\\lfloor \\frac{t-J_c}{T} \\right\\rfloor$$\n\nThe maximum backlog is the supremum of the difference $A_{\\max}(t) - D_{\\min}(t)$ over all $t \\ge 0$.\n$$N_{\\max} = \\sup_{t \\ge 0} \\left( \\left\\lfloor \\frac{t+J_p}{T} \\right\\rfloor - \\left\\lfloor \\frac{t-J_c}{T} \\right\\rfloor \\right)$$\nLet $x = \\frac{t-J_c}{T}$ and $Y = \\frac{J_p+J_c}{T}$. The expression becomes $\\sup_{x} (\\lfloor x+Y \\rfloor - \\lfloor x \\rfloor)$.\nThe function $f(x) = \\lfloor x+Y \\rfloor - \\lfloor x \\rfloor$ is periodic with period $1$. We can thus find its maximum by analyzing it over the interval $x \\in [0, 1)$. For $x \\in [0, 1)$, $\\lfloor x \\rfloor=0$, so we need to maximize $\\lfloor x+Y \\rfloor$. This is maximized as $x$ approaches $1$ from below.\nLet $x = 1 - \\epsilon$ for a small $\\epsilon > 0$. The value is $\\lfloor 1-\\epsilon+Y \\rfloor$. Let $Y = I_Y + f_Y$, where $I_Y = \\lfloor Y \\rfloor$ is the integer part and $f_Y$ is the fractional part. The expression becomes $\\lfloor 1-\\epsilon+I_Y+f_Y \\rfloor = I_Y + \\lfloor 1-\\epsilon+f_Y \\rfloor$.\nIf $Y$ is an integer, $f_Y=0$, and we get $I_Y + \\lfloor 1-\\epsilon \\rfloor = I_Y + 0 = Y$.\nIf $Y$ is not an integer, $f_Y>0$, and for sufficiently small $\\epsilon$, $1-\\epsilon+f_Y > 1$, so $\\lfloor 1-\\epsilon+f_Y \\rfloor = 1$. The value is $I_Y+1 = \\lfloor Y \\rfloor + 1$.\nThe supremum is therefore $\\lceil Y \\rceil$.\nTherefore, the minimal sufficient integer capacity $C$ is:\n$$C = \\left\\lceil Y \\right\\rceil = \\left\\lceil \\frac{J_p+J_c}{T} \\right\\rceil$$\n\nNow we apply this general formula to the two buffers in the problem.\nFor buffer $B_{12}$, the producer is Stage $1$ (deviation $J_1$) and the consumer is Stage $2$ (deviation $J_2$). So, $J_p = J_1$ and $J_c = J_2$. The capacity $C_{12}$ is:\n$$C_{12} = \\left\\lceil \\frac{J_1+J_2}{T} \\right\\rceil$$\nFor buffer $B_{23}$, the producer is Stage $2$ (deviation $J_2$) and the consumer is Stage $3$ (deviation $J_3$). So, $J_p = J_2$ and $J_c = J_3$. The capacity $C_{23}$ is:\n$$C_{23} = \\left\\lceil \\frac{J_2+J_3}{T} \\right\\rceil$$\n\nNext, we compute the numerical values for the given parameters:\n$Q = 120\\,\\mathrm{s}^{-1}$\n$J_1 = 0.015\\,\\mathrm{s}$\n$J_2 = 0.020\\,\\mathrm{s}$\n$J_3 = 0.012\\,\\mathrm{s}$\n\nThe nominal period is $T = 1/Q = 1/120\\,\\mathrm{s}$.\nFor $C_{12}$:\n$$C_{12} = \\left\\lceil \\frac{0.015\\,\\mathrm{s} + 0.020\\,\\mathrm{s}}{1/120\\,\\mathrm{s}} \\right\\rceil = \\lceil (0.035) \\cdot 120 \\rceil = \\lceil 4.2 \\rceil = 5$$\nFor $C_{23}$:\n$$C_{23} = \\left\\lceil \\frac{0.020\\,\\mathrm{s} + 0.012\\,\\mathrm{s}}{1/120\\,\\mathrm{s}} \\right\\rceil = \\lceil (0.032) \\cdot 120 \\rceil = \\lceil 3.84 \\rceil = 4$$\nThe minimal sufficient capacities are $C_{12}=5$ and $C_{23}=4$.\n\nFinally, we perform the experimental verification using the provided data. The backlog is $N(t) = A(t) - D(t)$.\nFor buffer $B_{12}$:\n- At $t=0.04\\,\\mathrm{s}$, $N_{12}(0.04) = A_{12}(0.04) - D_{12}(0.04) = 7 - 3 = 4$.\n- At $t=0.08\\,\\mathrm{s}$, $N_{12}(0.08) = A_{12}(0.08) - D_{12}(0.08) = 11 - 8 = 3$.\n- At $t=0.12\\,\\mathrm{s}$, $N_{12}(0.12) = A_{12}(0.12) - D_{12}(0.12) = 16 - 12 = 4$.\n- At $t=0.16\\,\\mathrm{s}$, $N_{12}(0.16) = A_{12}(0.16) - D_{12}(0.16) = 21 - 17 = 4$.\nThe maximum observed backlog for $B_{12}$ over the sample times is $\\max\\{4, 3, 4, 4\\}=4$. Our calculated capacity $C_{12}=5$ is sufficient to handle this observed backlog ($5 \\ge 4$). This is consistent, as an empirical trace is not guaranteed to exhibit the absolute theoretical worst-case behavior.\n\nFor buffer $B_{23}$:\n- At $t=0.04\\,\\mathrm{s}$, $N_{23}(0.04) = A_{23}(0.04) - D_{23}(0.04) = 7 - 4 = 3$.\n- At $t=0.08\\,\\mathrm{s}$, $N_{23}(0.08) = A_{23}(0.08) - D_{23}(0.08) = 12 - 9 = 3$.\n- At $t=0.12\\,\\mathrm{s}$, $N_{23}(0.12) = A_{23}(0.12) - D_{23}(0.12) = 17 - 13 = 4$.\n- At $t=0.16\\,\\mathrm{s}$, $N_{23}(0.16) = A_{23}(0.16) - D_{23}(0.16) = 22 - 18 = 4$.\nThe maximum observed backlog for $B_{23}$ is $\\max\\{3, 3, 4, 4\\}=4$. Our calculated capacity $C_{23}=4$ is exactly equal to the maximum observed backlog. This is also consistent. It implies that the observed trace, at least at time $t=0.12\\,\\mathrm{s}$ and $t=0.16\\,\\mathrm{s}$, reflects a behavior that is at or very close to the theoretical worst-case for this buffer's parameters, requiring the full calculated capacity.\n\nThe final answer is the pair of capacities $(C_{12}, C_{23})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 5 & 4 \\end{pmatrix}\n}\n$$", "id": "3625809"}]}