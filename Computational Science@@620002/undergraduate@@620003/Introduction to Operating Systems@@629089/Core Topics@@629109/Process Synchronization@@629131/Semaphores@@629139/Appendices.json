{"hands_on_practices": [{"introduction": "Before building complex concurrent systems, it is essential to internalize the fundamental rule that governs a counting semaphore's behavior. This practice reverses the typical problem-solving approach: instead of predicting the outcome of a program, you will analyze a given trace of completed operations to deduce the minimum required resources. By tracking the net number of acquired resources, you can determine the semaphore's peak demand, which reinforces the core invariant that its internal count can never become negative [@problem_id:3681948].", "problem": "A counting semaphore is an abstract data type with an integer state. Let $S$ be a single counting semaphore that protects access to an identical pool of resources. The semaphore $S$ is initialized to an unknown nonnegative integer $k$, which equals the number of resource units initially available. The operation $P(S)$ (also called wait or down) attempts to acquire one unit: it completes only if at least one unit is available, in which case the internal state of $S$ decreases by $1$; otherwise, the caller blocks and the operation cannot complete until some future $V(S)$ increases availability. The operation $V(S)$ (also called signal or up) releases one unit and increases the internal state of $S$ by $1$, potentially allowing one blocked $P(S)$ to complete. Assume there is no ownership requirement: any thread may invoke $V(S)$.\n\nYou are given a completion trace of operations on $S$ from $6$ threads $\\{A,B,C,D,E,F\\}$. The trace lists the global real-time order in which each $P(S)$ or $V(S)$ operation completed. Because the trace records only completions (not attempts), a $P(S)$ that would have blocked cannot appear in the trace until after sufficient $V(S)$ operations have completed to make a unit available.\n\nThe observed completion trace is the following ordered sequence of thread-operation pairs:\n$(A,P)$, $(B,P)$, $(C,P)$, $(B,V)$, $(D,P)$, $(E,P)$, $(C,V)$, $(F,P)$, $(A,V)$, $(D,V)$, $(B,P)$, $(E,V)$, $(F,V)$, $(C,P)$, $(B,V)$, $(A,P)$, $(A,V)$, $(C,V)$, $(D,P)$, $(D,V)$.\n\nUnder the standard counting semaphore semantics described above, determine the smallest integer $k$ for which this trace is legal, meaning that no completed $P(S)$ in the trace could have completed at a time when no unit was available. Provide your answer as a single integer (no units). If rounding were necessary, you would be instructed to round to a specified number of significant figures; however, in this problem, the exact integer is required.", "solution": "The problem asks for the smallest non-negative integer value of the initial semaphore count, $k$, for which a given trace of completed semaphore operations is legal.\n\nLet the state of the counting semaphore $S$ after the $t$-th operation in the trace has completed be denoted by $S_t$. The initial state of the semaphore is $S_0 = k$, where $k$ is a non-negative integer representing the initial number of available resources.\n\nThe standard semantics for the semaphore operations are as follows:\n1.  A $P(S)$ operation (wait) at step $t$ can complete only if the semaphore's value before the operation, $S_{t-1}$, is greater than $0$. Since the semaphore value is an integer, this is equivalent to $S_{t-1} \\ge 1$. Upon completion, the semaphore's value is decremented: $S_t = S_{t-1} - 1$.\n2.  A $V(S)$ operation (signal) at step $t$ unconditionally completes and increments the semaphore's value: $S_t = S_{t-1} + 1$.\n\nA direct consequence of these a rules is that the semaphore's internal state must always be non-negative. If $S_{t-1} \\ge 1$ for a $P$ operation, then after the operation, $S_t = S_{t-1} - 1 \\ge 0$. For a $V$ operation, if $S_{t-1} \\ge 0$, then $S_t = S_{t-1} + 1 \\ge 1$. Since the initial state $k$ is non-negative, the semaphore value $S_t$ must remain non-negative for all $t \\ge 0$.\n\nTo analyze the trace, we can define a function $C_t$ representing the net number of resources acquired after $t$ operations. This is the total number of completed $P$ operations minus the total number of completed $V$ operations up to step $t$. Let $P_t$ and $V_t$ be the cumulative counts of $P$ and $V$ operations, respectively, in the first $t$ steps of the trace. Then, $C_t = P_t - V_t$.\n\nThe value of the semaphore after $t$ operations can be expressed in terms of its initial value $k$ and the net acquisitions $C_t$:\n$$S_t = S_0 - (P_t - V_t) = k - C_t$$\n\nFor the trace to be legal, two conditions derived from the semaphore semantics must be met for all steps $t=1, \\dots, 20$:\n1.  The semaphore value must never be negative: $S_t \\ge 0$. This implies $k - C_t \\ge 0$, or $k \\ge C_t$ for all $t \\in \\{1, \\dots, 20\\}$.\n2.  For any step $t$ that is a $P$ operation, the value before the operation must be at least $1$: $S_{t-1} \\ge 1$. This implies $k - C_{t-1} \\ge 1$, or $k \\ge 1 + C_{t-1}$.\n\nLet us analyze the relationship between these two conditions. For any $P$ operation at step $t$, we have $C_t = C_{t-1} + 1$. The second condition, $k \\ge 1 + C_{t-1}$, can be rewritten as $k \\ge C_t$. This means the condition for a $P$ operation at step $t$ is equivalent to requiring $k \\ge C_t$, where $C_t$ is the net acquisition count *after* the $P$ operation.\n\nFor any $V$ operation at step $t$, we have $C_t = C_{t-1} - 1$. The first condition, $k \\ge C_t$, is less strict than $k \\ge C_{t-1}$ (which must hold because $t-1$ is a valid step in the trace). Therefore, the critical constraints on $k$ arise from ensuring $S_t \\ge 0$ for all $t$. The maximum number of concurrently held resources must not exceed the initial number of resources, $k$.\n\nCombining these, a single, necessary and sufficient condition for the entire trace to be legal is that $k$ must be greater than or equal to the net acquisition count $C_t$ at every step $t$. To find the smallest possible integer $k$, we must find the maximum value that $C_t$ attains throughout the trace.\n$$k_{min} = \\max_{t \\in \\{0, 1, \\dots, 20\\}} C_t$$\n\nWe now compute the value of $C_t$ for each step in the given trace. Let $C_0 = 0$.\n\n- $t=1: (A,P) \\implies C_1 = C_0 + 1 = 1$\n- $t=2: (B,P) \\implies C_2 = C_1 + 1 = 2$\n- $t=3: (C,P) \\implies C_3 = C_2 + 1 = 3$\n- $t=4: (B,V) \\implies C_4 = C_3 - 1 = 2$\n- $t=5: (D,P) \\implies C_5 = C_4 + 1 = 3$\n- $t=6: (E,P) \\implies C_6 = C_5 + 1 = 4$\n- $t=7: (C,V) \\implies C_7 = C_6 - 1 = 3$\n- $t=8: (F,P) \\implies C_8 = C_7 + 1 = 4$\n- $t=9: (A,V) \\implies C_9 = C_8 - 1 = 3$\n- $t=10: (D,V) \\implies C_{10} = C_9 - 1 = 2$\n- $t=11: (B,P) \\implies C_{11} = C_{10} + 1 = 3$\n- $t=12: (E,V) \\implies C_{12} = C_{11} - 1 = 2$\n- $t=13: (F,V) \\implies C_{13} = C_{12} - 1 = 1$\n- $t=14: (C,P) \\implies C_{14} = C_{13} + 1 = 2$\n- $t=15: (B,V) \\implies C_{15} = C_{14} - 1 = 1$\n- $t=16: (A,P) \\implies C_{16} = C_{15} + 1 = 2$\n- $t=17: (A,V) \\implies C_{17} = C_{16} - 1 = 1$\n- $t=18: (C,V) \\implies C_{18} = C_{17} - 1 = 0$\n- $t=19: (D,P) \\implies C_{19} = C_{18} + 1 = 1$\n- $t=20: (D,V) \\implies C_{20} = C_{19} - 1 = 0$\n\nThe sequence of values for $C_t$ for $t \\in \\{1, \\dots, 20\\}$ is:\n$\\{1, 2, 3, 2, 3, 4, 3, 4, 3, 2, 3, 2, 1, 2, 1, 2, 1, 0, 1, 0\\}$.\n\nThe maximum value in this sequence is:\n$$\\max(C_t) = 4$$\nThis maximum is reached at two points in the trace: after the $6^{th}$ operation $(E,P)$ and after the $8^{th}$ operation $(F,P)$.\n\nFor the trace to be legal, $k$ must be at least this maximum value. Thus, $k \\ge 4$. The smallest integer value for $k$ is $4$.\n\nTo verify, if we choose $k=3$, the trace would be illegal. At step $t=6$, the operation is $(E,P)$. The state before this operation would be $S_5 = k - C_5 = 3 - 3 = 0$. A $P$ operation cannot complete if the semaphore value is $0$, as it requires the value to be at least $1$. Therefore, $k=3$ is not a valid initial value.\n\nIf we choose $k=4$, the state before the $6^{th}$ operation is $S_5 = k - C_5 = 4 - 3 = 1$. This is a valid state for a $P$ operation to complete. After the operation, the state becomes $S_6 = S_5 - 1 = 0$, which is non-negative. A check of all $P$ operations confirms that $k=4$ makes the entire trace legal.\n\nTherefore, the smallest non-negative integer $k$ for which the trace is legal is $4$.", "answer": "$$\\boxed{4}$$", "id": "3681948"}, {"introduction": "In real-world programming, resource management errors often occur not in the 'happy path' but during cleanup and error handling. This exercise simulates a classic bug where an unguarded $V$ operation in a `finally` block leads to a 'double-release,' violating the semaphore's integrity. By implementing a runtime check that enforces the semaphore's capacity invariant ($s \\le C$), you will gain hands-on experience in writing robust code that can detect and prevent such subtle but critical concurrency errors [@problem_id:3681885].", "problem": "You are to implement a runtime check that detects incorrect use of semaphore signal operations caused by a misplaced $V$ (signal) in a \"finally\" block. The core concepts must be grounded in the canonical definition of a counting semaphore and its invariants, without relying on any \"shortcut\" formulas or external hints.\n\nThe fundamental base is as follows. A counting semaphore represents an available resource count $s$ with a fixed capacity $C$. The operations are $P$ (also called wait) and $V$ (also called signal). In a non-blocking model:\n- $P$ attempts to acquire a resource and, if $s \\gt 0$, decreases $s$ by $1$; otherwise it fails and leaves $s$ unchanged.\n- $V$ releases a resource and increases $s$ by $1$.\n\nThe invariant that must hold at all times is $0 \\le s \\le C$. A misplaced $V$ call in a finally-like cleanup block can cause a double release when a $V$ has already been called earlier in the body, or can release a resource that was never acquired. Your task is to demonstrate that such misuse is detectable purely by checking the invariant $0 \\le s \\le C$ after each $V$ operation. If a $V$ causes $s$ to become greater than $C$, that is a violation which must be reported.\n\nYou must write a complete, runnable program that:\n- Implements a counting semaphore with capacity $C$ and current count $s$ as integers, using atomic operations to model a realistic operating system setting.\n- Provides a non-blocking $P$ operation that returns $1$ if it successfully decrements $s$ and $0$ otherwise.\n- Provides a checked $V$ operation that increments $s$ and returns $1$ if the invariant $s \\le C$ is violated after the increment, and $0$ otherwise.\n- Simulates a \"finally\" pattern with two variants:\n  - A guarded finally that calls $V$ only if the resource is currently marked as acquired.\n  - An unguarded finally that calls $V$ unconditionally (the misplaced $V$), which can cause a double release if a $V$ was already performed in the body or a release without any prior acquisition.\n- Defines each test case by a tuple $(C, s_0, \\text{doP}, \\text{bodyV}, \\text{finallyU}, \\text{finallyG})$, where $C$ is the capacity, $s_0$ is the initial count, $\\text{doP}$ indicates whether a single $P$ is attempted ($1$ means attempt, $0$ means skip), $\\text{bodyV}$ indicates whether the body calls $V$ once if acquired ($1$ means yes, $0$ means no), $\\text{finallyU}$ indicates whether the finally block calls $V$ unconditionally ($1$ means yes, $0$ means no), and $\\text{finallyG}$ indicates whether the finally block calls $V$ only if the resource is considered acquired ($1$ means yes, $0$ means no). If both $\\text{finallyU}$ and $\\text{finallyG}$ are specified, treat $\\text{finallyU}$ as taking precedence.\n\nThe program should evaluate the following test suite and, for each case, output a boolean integer where $1$ denotes that an invariant violation was detected (i.e., some $V$ pushed $s$ above $C$) and $0$ denotes no violation:\n- Test $1$: $(C, s_0, \\text{doP}, \\text{bodyV}, \\text{finallyU}, \\text{finallyG}) = (\\,3,\\,3,\\,1,\\,0,\\,0,\\,1\\,)$, a \"happy path\" where a guarded finally releases exactly once after successful acquisition.\n- Test $2$: $(\\,1,\\,1,\\,1,\\,1,\\,1,\\,0\\,)$, a double-release case where the body releases once and the unguarded finally releases again, violating the upper-bound invariant.\n- Test $3$: $(\\,0,\\,0,\\,1,\\,0,\\,1,\\,0\\,)$, a release-without-acquisition case under zero capacity, where the unguarded finally attempts a $V$ and violates the invariant immediately.\n- Test $4$: $(\\,2,\\,1,\\,1,\\,1,\\,0,\\,1\\,)$, a boundary case where the body releases the previously acquired resource and the guarded finally correctly refrains from a second release.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is either $0$ or $1$ corresponding to the test cases above, in the same order listed. There are no physical units involved in this problem, and all boolean outputs must be integers ($0$ or $1$). The final output format must be exactly one single line of the form $[r_1,r_2,r_3,r_4]$.", "solution": "The user's request has been validated and is a well-posed problem grounded in the fundamental principles of operating systems and concurrency control. The task is to demonstrate the detection of semaphore misuse by validating a key invariant.\n\nThe core principle behind a counting semaphore is the management of a finite pool of resources. A semaphore object encapsulates a non-negative integer, let's call it $s$, representing the number of available resources. The problem specifies a bounded counting semaphore, which introduces an additional parameter, the capacity $C$, representing the maximum number of resources. The state of the semaphore must therefore always satisfy the invariant $0 \\le s \\le C$. Any operation that leads to a state outside these bounds is, by definition, an error.\n\nThe problem defines two primary operations:\n1.  $P(s)$, or `wait`: This operation attempts to acquire a resource. In a non-blocking model, it checks if $s > 0$. If true, it atomically decrements $s$ and succeeds. If false ($s=0$), it fails without changing $s$.\n2.  $V(s)$, or `signal`: This operation releases a resource, unconditionally and atomically incrementing $s$.\n\nThe problem states that misuse, such as a double-release or a release of a never-acquired resource, can be detected by checking the invariant $s \\le C$ *after* every $V$ operation. A $V$ operation that causes $s$ to exceed $C$ is a protocol violation. Our task is to implement a simulation to demonstrate this.\n\nTo model this in a realistic setting, we must use atomic operations. In a multi-threaded environment, the check and update of the semaphore count $s$ must be an indivisible operation to prevent race conditions. The C23 standard provides atomic types and operations via the `<stdatomic.h>` header, which are ideal for this purpose.\n\nThe implementation will consist of the following components:\n\n1.  A `CountingSemaphore` structure will hold the semaphore's capacity $C$ (an `int`) and its current count $s$ (an `atomic_int`).\n\n2.  The `P_op` function will implement the non-blocking wait. It will use an atomic compare-and-swap (CAS) loop. Specifically, it reads the current value of $s$, and if it's greater than $0$, it attempts to atomically replace it with $s-1$. The `atomic_compare_exchange_weak` function is suitable here; it attempts the swap and informs us if it succeeded or if another thread modified $s$ in the meantime, in which case the loop retries with the new value of $s$. The function returns $1$ on success and $0$ on failure.\n\n3.  The `V_op_checked` function will implement the checked signal operation. It must atomically increment $s$ and then check for an invariant violation. The `atomic_fetch_add` function is perfect for this, as it atomically increments the value and returns the value *before* the increment. Let the returned old value be $s_{\\text{old}}$. The new value is $s_{\\text{new}} = s_{\\text{old}} + 1$. The function then checks if $s_{\\text{new}} > C$. If this condition is met, an invariant violation has occurred, and the function returns $1$. Otherwise, it returns $0$.\n\n4.  The simulation of the `try-finally` pattern requires careful state management. A local boolean flag, let's call it `acquired`, will be used to track whether the current logical thread of execution successfully holds a resource.\n    - The simulation starts with `acquired = 0$.\n    - If a $P$ operation is attempted and succeeds, `acquired` is set to $1$.\n    - If the \"body\" of the code block performs a `V` operation, it can only do so if `acquired` is $1$. After this `V` operation, the resource is considered released, so `acquired` must be set back to $0$. This step is critical for correctly modeling the guarded `finally` block.\n    - An \"unguarded finally\" block unconditionally performs a `V` operation, regardless of the `acquired` status. This is the source of potential errors.\n    - A \"guarded finally\" block performs a `V` operation only if `acquired` is still $1$, meaning the resource was acquired but not yet released in the body.\n\nBy running the specified test cases through this simulation logic, we can determine for each case whether a `V` operation causes the semaphore count $s$ to exceed its capacity $C$. The final result for each test will be a boolean integer ($1$ for detected violation, $0$ otherwise).\n\nThe test cases are designed to cover the key scenarios:\n- **Test 1**: A correct, standard use case (`P` followed by a guarded `V` in `finally`). We expect no violation.\n- **Test 2**: A double-release error (`P`, `V` in body, then an unguarded `V` in `finally`). The second `V` should violate the invariant. We expect a violation.\n- **Test 3**: A release-without-acquire error (failed `P`, then an unguarded `V`). With $C=0$, the `V` immediately violates the invariant. We expect a violation.\n- **Test 4**: A correct use case demonstrating the guard (`P`, `V` in body, then a guarded `V` in `finally`). The guard (`acquired == 0`) should prevent the `finally` block's `V` from executing. We expect no violation.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <complex.h>\n#include <threads.h>\n#include <stdatomic.h>\n\n// A structure to represent a bounded counting semaphore.\ntypedef struct {\n    atomic_int s; // Current number of available resources.\n    int C;        // Maximum capacity of the semaphore.\n} CountingSemaphore;\n\n// A structure to hold the parameters for a single test case.\ntypedef struct {\n    int C;        // Capacity\n    int s0;       // Initial count\n    int doP;      // 1 to attempt a P operation, 0 to skip\n    int bodyV;    // 1 to call V in the main body if resource is acquired\n    int finallyU; // 1 to call V unconditionally in the 'finally' block\n    int finallyG; // 1 to call V conditionally in the 'finally' block\n} TestCase;\n\n// Initializes the semaphore with a given initial count and capacity.\nvoid semaphore_init(CountingSemaphore* sem, int s0, int C) {\n    atomic_init(&sem->s, s0);\n    sem->C = C;\n}\n\n// A non-blocking P (wait) operation.\n// Returns 1 on success (resource acquired), 0 on failure.\nint P_op(CountingSemaphore* sem) {\n    int current_s = atomic_load(&sem->s);\n    while (current_s > 0) {\n        // Attempt to decrement s from current_s to current_s - 1.\n        if (atomic_compare_exchange_weak(&sem->s, &current_s, current_s - 1)) {\n            return 1; // Success\n        }\n        // If CAS fails, current_s is automatically reloaded with the new value.\n        // The loop continues to retry.\n    }\n    return 0; // Failure (s was 0 or became 0 during the attempt)\n}\n\n// A checked V (signal) operation.\n// Increments s and returns 1 if the invariant s > C is violated, 0 otherwise.\nint V_op_checked(CountingSemaphore* sem) {\n    // Atomically increment s by 1 and get the value *before* the operation.\n    int old_s = atomic_fetch_add(&sem->s, 1);\n    int new_s = old_s + 1;\n    // Check if the upper-bound invariant is violated.\n    return (new_s > sem->C) ? 1 : 0;\n}\n\n// Runs a single test case simulation.\n// Returns 1 if an invariant violation was detected, 0 otherwise.\nint run_test_case(const TestCase* test) {\n    CountingSemaphore sem;\n    semaphore_init(&sem, test->s0, test->C);\n\n    int acquired = 0;\n    int violation_detected = 0;\n\n    // --- 'try' block: attempt to acquire a resource ---\n    if (test->doP) {\n        if (P_op(&sem)) {\n            acquired = 1;\n        }\n    }\n\n    // --- body of 'try': may release the resource ---\n    if (test->bodyV && acquired) {\n        violation_detected |= V_op_checked(&sem);\n        // The resource is now considered released by the body logic.\n        acquired = 0;\n    }\n\n    // --- 'finally' block: cleanup logic ---\n    // Unconditional V takes precedence.\n    if (test->finallyU) {\n        violation_detected |= V_op_checked(&sem);\n    } else if (test->finallyG && acquired) { // Guarded V\n        violation_detected |= V_op_checked(&sem);\n        // acquired state would be reset at scope exit.\n    }\n\n    return violation_detected;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {3, 3, 1, 0, 0, 1}, // Test 1: Happy path, guarded finally\n        {1, 1, 1, 1, 1, 0}, // Test 2: Double-release\n        {0, 0, 1, 0, 1, 0}, // Test 3: Release without acquisition\n        {2, 1, 1, 1, 0, 1}  // Test 4: Correctly guarded release\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = run_test_case(&test_cases[i]);\n    }\n\n    // Print the results in the exact required format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3681885"}, {"introduction": "Semaphores are not just for simple resource counting; they are powerful primitives for constructing higher-level synchronization tools. This advanced practice challenges you to build a dynamic barrier, a reusable component that allows a variable number of threads to wait for each other. You will learn to manage complex state transitions safely, define 'safe points' for modification, and use a two-turnstile design to prevent subtle race conditions between consecutive barrier phases [@problem_id:3681863].", "problem": "You are to implement and reason about a barrier using semaphores that supports dynamic resizing of the participating thread count. The barrier must allow threads to join or leave between barrier phases, and it must guarantee safety so that no thread can be left waiting on an outdated or incorrectly sized semaphore.\n\nStart from the following fundamental base:\n- A counting semaphore has an integer state. The wait operation decreases the count when it is positive; otherwise it blocks. The post operation increases the count; it may unblock a waiting thread.\n- A barrier is a synchronization primitive that makes $N$ threads wait until all $N$ have reached the barrier, at which point all are released to continue.\n\nYour task is to derive and implement a barrier that supports dynamic $N$ by ensuring that $N$ is frozen per phase and updated only at safe points. A safe point is when no thread is currently blocked in the barrier and the barrier is not in the process of releasing a phase. Your program must use semaphores to form the barrier’s turnstiles; mutual exclusion may be provided by locks, but the release coordination must rely on semaphores.\n\nThe barrier must provide the following operations:\n- $join()$: a thread signals it will participate in the next phase. If the barrier is not at a safe point (between phases), $join()$ must block until a safe point is reached, and only then increment the expected participant count for the next phase.\n- $leave()$: a thread signals it will stop participating starting from the next phase. If the barrier is not at a safe point, $leave()$ must block until a safe point is reached, and only then decrement the expected participant count for the next phase.\n- $wait()$: a thread participates in the current phase by calling $wait()$. The barrier must freeze the current phase’s $N$ upon the first arrival of the phase, count arrivals, and when the $N$th arrival occurs, release exactly $N$ threads using a semaphore-based turnstile. After all $N$ threads pass through the barrier’s release stage, the barrier must reopen to a safe point to allow $join()$ and $leave()$ operations for the next phase.\n\nDesign constraints:\n- The barrier must be implemented using counting semaphores for the release coordination (the “turnstiles”).\n- Resizing of $N$ must occur only at safe points, not during a phase’s arrival or release steps.\n- The implementation must be robust against arbitrary arrival orders.\n\nYou must produce a complete, runnable program that orchestrates a fixed set of worker threads through a deterministic test schedule. The test schedule is provided below. Threads are labeled with integer identifiers. All integers in this problem must be interpreted as plain counts with no physical units.\n\nDefine $4$ worker threads labeled $0,1,2,3$. For each test case, the main thread must orchestrate the following steps deterministically:\n- Apply an initial set of $join()$ operations to register threads for the first phase.\n- For each phase:\n  1. Apply any additional $join()$ operations that occur before that phase begins.\n  2. Trigger the listed participants to call $wait()$ in the specified order. Threads may block until all participants have arrived; the barrier should release all $N$ participants of that phase together.\n  3. Apply any $leave()$ operations listed for after the phase completes.\n\nDefine the result for a test case as the sum, over all phases of that test case, of the frozen participant count $N$ used by the barrier in each phase. Your program should compute these results and output them.\n\nTest Suite:\n- Test Case $1$:\n  - Initial $join()$: threads $[0,1,2]$.\n  - Phases and participants:\n    - Phase $1$: participants $[0,1,2]$.\n    - Phase $2$: participants $[2,1,0]$.\n  - $leave()$ operations after phases: none.\n- Test Case $2$:\n  - Initial $join()$: threads $[0,1]$.\n  - Phases and participants with dynamic resizing:\n    - Phase $1$: participants $[0,1]$.\n    - Before Phase $2$: $join()$ thread $[2]$.\n    - Phase $2$: participants $[0,1,2]$.\n    - After Phase $2$: $leave()$ thread $[1]$.\n    - Phase $3$: participants $[0,2]$.\n- Test Case $3$:\n  - Initial $join()$: threads $[0]$.\n  - Phases and participants:\n    - Phase $1$: participants $[0]$.\n    - Phase $2$: participants $[0]$.\n    - Phase $3$: participants $[0]$.\n  - No resizing operations between phases.\n- Test Case $4$:\n  - Initial $join()$: threads $[0,1,2]$.\n  - Phases and participants with dynamic resizing:\n    - Phase $1$: participants $[2,0,1]$; after Phase $1$: $leave()$ thread $[2]$.\n    - Phase $2$: participants $[0,1]$; before Phase $3$: $join()$ thread $[3]$.\n    - Phase $3$: participants $[3,0,1]$.\n\nAnswer specification:\n- For each test case, compute the sum of the phase participant counts $N$ actually used by the barrier in that test case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Test Case $1$ through Test Case $4$, for example, $[r_1,r_2,r_3,r_4]$ where $r_i$ are integers.\n\nNo user input is allowed. Your program must be self-contained and must use the deterministic orchestration implied by the test suite to ensure reproducibility. The final output must be exactly one line in the specified format.", "solution": "The problem requires the design and implementation of a thread barrier that supports a dynamic number of participating threads, $N$. The core challenge is to manage state transitions and resizing operations (`join()` and `leave()`) safely, ensuring that changes to $N$ only occur at \"safe points\" and do not interfere with an ongoing barrier phase. The solution must be implemented in C using semaphores for release coordination, adhering to the specified C23 standard and header restrictions.\n\nFirst, we must establish the necessary synchronization primitives. The C23 standard, via `threads.h`, provides mutexes (`mtx_t`) and condition variables (`cnd_t`), but not counting semaphores. As per the problem's definition of a semaphore, we construct one from these components. A semaphore, `sem_t`, is implemented as a structure containing an integer `count`, a mutex `mtx`, and a condition variable `cnd`. The `sem_wait` operation locks the mutex, waits on the condition variable while `count` is $0$, then decrements `count` and unlocks. The `sem_post` operation locks the mutex, increments `count`, and signals the condition variable to awaken one waiting thread.\n\nThe dynamic barrier itself is implemented as a `struct`, `DynamicBarrier`, containing the following state variables:\n- `mtx_t mtx`: A master mutex to protect all shared state variables within the barrier, ensuring atomic updates.\n- `cnd_t safe_point_cnd`: A condition variable used by `join()` and `leave()` operations to wait for a safe point.\n- `sem_t turnstiles[2]`: An array of two semaphores, both initialized to $0$. These act as alternating gates for consecutive barrier phases. Using two turnstiles prevents \"runaway\" threads (threads that complete a phase quickly and loop around) from entering the next phase prematurely and interfering with threads from the previous phase that may be slower to be released.\n- `int n_target`: Stores the number of threads expected to participate in the *next* barrier phase. This variable is modified by `join()` and `leave()`.\n- `int n_frozen`: Stores the number of threads participating in the *current* phase. This value is a snapshot of `n_target`, captured, or \"frozen,\" by the first thread to arrive at the barrier for a given phase. This is crucial for safety, as it ensures the participant count for a phase remains constant from its start to its completion.\n- `int count`: Counts the number of threads that have arrived at the barrier for the current phase.\n- `int phase_gen`: A generation counter, starting from $0$. It is incremented at the end of each phase. The participant threads of a phase will wait on `turnstiles[phase_gen % 2]`.\n- `atomic_int result_sum`: An atomic integer to accumulate the sum of `n_frozen` values for each phase within a test case, as required by the problem's output specification.\n\nThe operations are implemented as follows:\nThe `join()` and `leave()` operations provide the dynamic resizing capability. To ensure safety, they can only modify `n_target` at a safe point. A safe point is defined as any time when no phase is currently active, which corresponds to the state where `count == 0`. A thread calling `join()` or `leave()` acquires the master mutex `mtx`. It then enters a `while` loop, waiting on `safe_point_cnd` as long as `count != 0`. Once `count` is $0$, the thread proceeds to increment or decrement `n_target` and then releases the mutex.\n\nThe `wait()` operation orchestrates the core barrier logic:\n$1$. A thread calling `wait()` acquires the master mutex `mtx`. It reads the current `phase_gen` into a local variable to ensure it operates within the correct phase, even if other threads advance the global `phase_gen`.\n$2$. If `count` is $0$, the thread is the first to arrive for a new phase. It freezes the participant count by setting `n_frozen = n_target`. It also adds this `n_frozen` value to the `result_sum`.\n$3$. The `count` of arrived threads is incremented.\n$4$. If this thread is the last to arrive (i.e., `count == n_frozen`), it is responsible for releasing all participating threads and resetting the barrier for the next phase. It performs these actions:\n    a. It posts `n_frozen` times to the appropriate turnstile for the current phase (`turnstiles[phase_gen % 2]`), unblocking all `n_frozen` waiting threads (including itself).\n    b. It resets `count` to $0$. This action establishes a new safe point.\n    c. It increments `phase_gen`, moving the barrier to the next generation.\n    d. It broadcasts on `safe_point_cnd`, waking any threads that are blocked in `join()` or `leave()`.\n$5$. The thread releases the mutex.\n$6$. Finally, the thread calls `sem_wait()` on its phase's designated turnstile. It blocks until the last thread arrives and opens the gate.\n\nTo execute the deterministic test suite, the `main` thread orchestrates a set of worker threads. Each worker is controlled via a command/acknowledgment protocol using two dedicated semaphores (`cmd_sem` and `ack_sem`). The `main` thread issues a command (e.g., `JOIN`, `WAIT`) by posting to a worker's `cmd_sem` and then waits on the worker's `ack_sem`. This ensures that operations like pre-phase `join`s are completed before any participant calls `wait` for that phase, thereby guaranteeing the deterministic behavior required by the problem.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <complex.h>\n#include <threads.h>\n#include <stdatomic.h>\n\n// -- Custom Semaphore Implementation using C11 threads.h --\n\ntypedef struct {\n    mtx_t mtx;\n    cnd_t cnd;\n    int value;\n} sem_t;\n\nvoid sem_init(sem_t *sem, unsigned int value) {\n    mtx_init(&sem->mtx, mtx_plain);\n    cnd_init(&sem->cnd);\n    sem->value = value;\n}\n\nvoid sem_wait(sem_t *sem) {\n    mtx_lock(&sem->mtx);\n    while (sem->value == 0) {\n        cnd_wait(&sem->cnd, &sem->mtx);\n    }\n    sem->value--;\n    mtx_unlock(&sem->mtx);\n}\n\nvoid sem_post(sem_t *sem) {\n    mtx_lock(&sem->mtx);\n    sem->value++;\n    cnd_signal(&sem->cnd);\n    mtx_unlock(&sem->mtx);\n}\n\nvoid sem_destroy(sem_t *sem) {\n    mtx_destroy(&sem->mtx);\n    cnd_destroy(&sem->cnd);\n}\n\n// -- Dynamic Barrier Implementation --\n\ntypedef struct {\n    mtx_t mtx;\n    cnd_t safe_point_cnd;\n    sem_t turnstiles[2];\n    int n_target;\n    int n_frozen;\n    int count;\n    int phase_gen;\n    atomic_int result_sum;\n} DynamicBarrier;\n\nvoid barrier_init(DynamicBarrier *b) {\n    mtx_init(&b->mtx, mtx_plain);\n    cnd_init(&b->safe_point_cnd);\n    sem_init(&b->turnstiles[0], 0);\n    sem_init(&b->turnstiles[1], 0);\n    b->n_target = 0;\n    b->n_frozen = 0;\n    b->count = 0;\n    b->phase_gen = 0;\n    atomic_init(&b->result_sum, 0);\n}\n\nvoid barrier_destroy(DynamicBarrier *b) {\n    mtx_destroy(&b->mtx);\n    cnd_destroy(&b->safe_point_cnd);\n    sem_destroy(&b->turnstiles[0]);\n    sem_destroy(&b->turnstiles[1]);\n}\n\nvoid barrier_join(DynamicBarrier *b) {\n    mtx_lock(&b->mtx);\n    while (b->count != 0) {\n        cnd_wait(&b->safe_point_cnd, &b->mtx);\n    }\n    b->n_target++;\n    mtx_unlock(&b->mtx);\n}\n\nvoid barrier_leave(DynamicBarrier *b) {\n    mtx_lock(&b->mtx);\n    while (b->count != 0) {\n        cnd_wait(&b->safe_point_cnd, &b->mtx);\n    }\n    b->n_target--;\n    mtx_unlock(&b->mtx);\n}\n\nvoid barrier_wait(DynamicBarrier *b) {\n    mtx_lock(&b->mtx);\n\n    int my_phase = b->phase_gen;\n\n    if (b->count == 0) {\n        b->n_frozen = b->n_target;\n        atomic_fetch_add(&b->result_sum, b->n_frozen);\n    }\n\n    b->count++;\n\n    if (b->count == b->n_frozen) {\n        for (int i = 0; i < b->n_frozen; ++i) {\n            sem_post(&b->turnstiles[my_phase % 2]);\n        }\n        b->count = 0;\n        b->phase_gen++;\n        cnd_broadcast(&b->safe_point_cnd);\n    }\n\n    mtx_unlock(&b->mtx);\n    sem_wait(&b->turnstiles[my_phase % 2]);\n}\n\n// -- Test Orchestration Infrastructure --\n\n#define NUM_WORKERS 4\n\ntypedef enum {\n    CMD_IDLE,\n    CMD_JOIN,\n    CMD_LEAVE,\n    CMD_WAIT,\n    CMD_TERMINATE\n} Command;\n\ntypedef struct {\n    int id;\n    DynamicBarrier *barrier;\n    thrd_t thread_id;\n    atomic_int command;\n    sem_t cmd_sem;\n    sem_t ack_sem;\n} WorkerData;\n\nint worker_thread_func(void *arg) {\n    WorkerData *data = (WorkerData*)arg;\n    while (1) {\n        sem_wait(&data->cmd_sem);\n        int cmd = atomic_load(&data->command);\n\n        if (cmd == CMD_TERMINATE) {\n            break;\n        }\n\n        switch (cmd) {\n            case CMD_JOIN:\n                barrier_join(data->barrier);\n                break;\n            case CMD_LEAVE:\n                barrier_leave(data->barrier);\n                break;\n            case CMD_WAIT:\n                barrier_wait(data->barrier);\n                break;\n            default:\n                break;\n        }\n        atomic_store(&data->command, CMD_IDLE);\n        sem_post(&data->ack_sem);\n    }\n    return 0;\n}\n\n// -- Test Case Definitions --\n\ntypedef enum { JOIN, LEAVE } ActionType;\n\ntypedef struct {\n    int thread_id;\n    ActionType action;\n} OrchestrationStep;\n\ntypedef struct {\n    size_t num_pre_steps;\n    OrchestrationStep *pre_steps;\n    size_t num_participants;\n    int *participants;\n    size_t num_post_steps;\n    OrchestrationStep *post_steps;\n} Phase;\n\ntypedef struct {\n    const char *name;\n    size_t num_initial_joins;\n    int *initial_join_ids;\n    size_t num_phases;\n    Phase *phases;\n} TestCase;\n\nvoid run_test_case(TestCase *tc, WorkerData *workers) {\n    // Initial joins\n    for (size_t i = 0; i < tc->num_initial_joins; ++i) {\n        int tid = tc->initial_join_ids[i];\n        atomic_store(&workers[tid].command, CMD_JOIN);\n        sem_post(&workers[tid].cmd_sem);\n    }\n    for (size_t i = 0; i < tc->num_initial_joins; ++i) {\n        int tid = tc->initial_join_ids[i];\n        sem_wait(&workers[tid].ack_sem);\n    }\n\n    // Process phases\n    for (size_t p = 0; p < tc->num_phases; ++p) {\n        Phase *phase = &tc->phases[p];\n\n        // Pre-phase steps\n        for (size_t i = 0; i < phase->num_pre_steps; ++i) {\n            int tid = phase->pre_steps[i].thread_id;\n            Command cmd = (phase->pre_steps[i].action == JOIN) ? CMD_JOIN : CMD_LEAVE;\n            atomic_store(&workers[tid].command, cmd);\n            sem_post(&workers[tid].cmd_sem);\n        }\n        for (size_t i = 0; i < phase->num_pre_steps; ++i) {\n            sem_wait(&workers[phase->pre_steps[i].thread_id].ack_sem);\n        }\n\n        // Wait steps\n        for (size_t i = 0; i < phase->num_participants; ++i) {\n            int tid = phase->participants[i];\n            atomic_store(&workers[tid].command, CMD_WAIT);\n            sem_post(&workers[tid].cmd_sem);\n        }\n        for (size_t i = 0; i < phase->num_participants; ++i) {\n            sem_wait(&workers[phase->participants[i]].ack_sem);\n        }\n\n        // Post-phase steps\n        for (size_t i = 0; i < phase->num_post_steps; ++i) {\n            int tid = phase->post_steps[i].thread_id;\n            Command cmd = (phase->post_steps[i].action == JOIN) ? CMD_JOIN : CMD_LEAVE;\n            atomic_store(&workers[tid].command, cmd);\n            sem_post(&workers[tid].cmd_sem);\n        }\n        for (size_t i = 0; i < phase->num_post_steps; ++i) {\n            sem_wait(&workers[phase->post_steps[i].thread_id].ack_sem);\n        }\n    }\n}\n\nint main(void) {\n    // Test Case 1 Data\n    int tc1_initial_joins[] = {0, 1, 2};\n    int tc1_p1_parts[] = {0, 1, 2};\n    int tc1_p2_parts[] = {2, 1, 0};\n    Phase tc1_phases[] = {\n        {0, NULL, 3, tc1_p1_parts, 0, NULL},\n        {0, NULL, 3, tc1_p2_parts, 0, NULL}\n    };\n\n    // Test Case 2 Data\n    int tc2_initial_joins[] = {0, 1};\n    OrchestrationStep tc2_p2_pre[] = {{2, JOIN}};\n    int tc2_p1_parts[] = {0, 1};\n    int tc2_p2_parts[] = {0, 1, 2};\n    OrchestrationStep tc2_p2_post[] = {{1, LEAVE}};\n    int tc2_p3_parts[] = {0, 2};\n    Phase tc2_phases[] = {\n        {0, NULL, 2, tc2_p1_parts, 0, NULL},\n        {1, tc2_p2_pre, 3, tc2_p2_parts, 1, tc2_p2_post},\n        {0, NULL, 2, tc2_p3_parts, 0, NULL}\n    };\n    \n    // Test Case 3 Data\n    int tc3_initial_joins[] = {0};\n    int tc3_p_parts[] = {0};\n    Phase tc3_phases[] = {\n        {0, NULL, 1, tc3_p_parts, 0, NULL},\n        {0, NULL, 1, tc3_p_parts, 0, NULL},\n        {0, NULL, 1, tc3_p_parts, 0, NULL}\n    };\n\n    // Test Case 4 Data\n    int tc4_initial_joins[] = {0, 1, 2};\n    int tc4_p1_parts[] = {2, 0, 1};\n    OrchestrationStep tc4_p1_post[] = {{2, LEAVE}};\n    int tc4_p2_parts[] = {0, 1};\n    OrchestrationStep tc4_p3_pre[] = {{3, JOIN}};\n    int tc4_p3_parts[] = {3, 0, 1};\n    Phase tc4_phases[] = {\n        {0, NULL, 3, tc4_p1_parts, 1, tc4_p1_post},\n        {0, NULL, 2, tc4_p2_parts, 0, NULL},\n        {1, tc4_p3_pre, 3, tc4_p3_parts, 0, NULL}\n    };\n\n    TestCase test_cases[] = {\n        {\"Test Case 1\", 3, tc1_initial_joins, 2, tc1_phases},\n        {\"Test Case 2\", 2, tc2_initial_joins, 3, tc2_phases},\n        {\"Test Case 3\", 1, tc3_initial_joins, 3, tc3_phases},\n        {\"Test Case 4\", 3, tc4_initial_joins, 3, tc4_phases}\n    };\n    size_t num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (size_t i = 0; i < num_cases; ++i) {\n        DynamicBarrier barrier;\n        barrier_init(&barrier);\n        \n        WorkerData workers[NUM_WORKERS];\n        for (int j = 0; j < NUM_WORKERS; ++j) {\n            workers[j].id = j;\n            workers[j].barrier = &barrier;\n            atomic_init(&workers[j].command, CMD_IDLE);\n            sem_init(&workers[j].cmd_sem, 0);\n            sem_init(&workers[j].ack_sem, 0);\n            thrd_create(&workers[j].thread_id, worker_thread_func, &workers[j]);\n        }\n\n        run_test_case(&test_cases[i], workers);\n\n        for (int j = 0; j < NUM_WORKERS; ++j) {\n            atomic_store(&workers[j].command, CMD_TERMINATE);\n            sem_post(&workers[j].cmd_sem);\n            thrd_join(workers[j].thread_id, NULL);\n            sem_destroy(&workers[j].cmd_sem);\n            sem_destroy(&workers[j].ack_sem);\n        }\n        \n        results[i] = atomic_load(&barrier.result_sum);\n        barrier_destroy(&barrier);\n    }\n    \n    printf(\"[%d,%d,%d,%d]\\n\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3681863"}]}