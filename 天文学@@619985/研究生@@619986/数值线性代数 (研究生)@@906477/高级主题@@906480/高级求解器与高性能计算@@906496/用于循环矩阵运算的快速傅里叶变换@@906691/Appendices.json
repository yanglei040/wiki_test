{
        "hands_on_practices": [
            {
                "introduction": "尽管快速傅里叶变换 (FFT) 在处理长度为 $2$ 的幂的序列时效率极高，但许多实际应用场景需要处理任意长度（例如素数长度）的离散傅里叶变换 (DFT)。Bluestein 算法巧妙地将任意长度的 DFT 问题转化为一个卷积问题，从而可以利用标准 FFT 进行高效计算。这项实践 [@problem_id:3545333] 将引导您从基本原理出发，动手实现这一强大算法，从而将专门的 FFT 算法推广到通用的 DFT 计算中。",
                "problem": "设 $N \\in \\mathbb{N}$，并设 $x \\in \\mathbb{C}^{N}$ 表示一个长度为 $N$ 的序列。离散傅里叶变换 (DFT) 定义为一个线性映射 $X \\in \\mathbb{C}^{N}$，对于每个索引 $n \\in \\{0,1,\\dots,N-1\\}$，其由下式给出\n$$\nX_n = \\sum_{k=0}^{N-1} x_k \\exp\\!\\left(-\\frac{2\\pi \\mathrm{i}}{N} n k\\right).\n$$\n由向量 $g \\in \\mathbb{C}^{L}$ 生成的循环矩阵 $C(g) \\in \\mathbb{C}^{L \\times L}$ 具有一个性质，即其特征向量是离散傅里叶矩阵的列，并且它可以通过快速傅里叶变换 (FFT) 进行对角化，即\n$$\nC(g) = F_L^{-1} \\operatorname{diag}(F_L g)\\, F_L,\n$$\n其中 $F_L$ 是 $L \\times L$ 的离散傅里叶变换矩阵，而 $F_L^{-1}$ 是其逆矩阵。该性质使得通过 FFT 高效计算循环卷积成为可能。\n\nBluestein 算法（也称为 chirp-z 方法）将长度为 $N$ 的 DFT 计算简化为长度至多为 $2N-1$ 的线性卷积，该线性卷积随后可以利用循环矩阵实现为长度 $L \\ge 2N-1$ 的循环卷积，并通过 FFT 高效计算。在本作业中，您必须通过将 DFT 简化为与 chirp 序列的卷积，并将线性卷积嵌入到循环卷积中，利用 FFT 进行循环对角化，从而为素数长度的输入推导出一个正确的 Bluestein 算法实现。您必须从上述基本定义和有效的代数恒等式出发；不得使用预先推导出的简化公式。\n\n您必须编写一个完整的程序，该程序：\n- 直接根据其定义实现 DFT，使用 $O(N^2)$ 的算术运算，此部分不调用任何优化的 FFT 例程，以作为参考。\n- 为通用的 $N$（特别注意所提供的素数情况）实现 DFT 的 Bluestein 算法，通过将 DFT 简化为线性卷积，然后通过由长度为 $L$ 的循环矩阵实现的循环卷积来计算该卷积，该矩阵由 FFT 对角化。\n- 对于每个测试用例，选择满足 $L \\ge 2N-1$ 的最小的 2 的幂作为 $L$。\n- 将基于 Bluestein 算法的 DFT 结果与直接 DFT 结果进行比较，并报告最大绝对逐项差异是否低于预定容差。\n\n程序中和以下定义中的所有三角函数都必须使用以弧度表示的角度。\n\n使用以下测试套件，涵盖一般情况和边界情况：\n- 测试 1：$N=2$，其中 $x_0 = 1$ 且 $x_1 = -\\mathrm{i}$。\n- 测试 2：$N=7$，其中 $x_0 = 1$ 且对于所有 $k \\in \\{1,2,3,4,5,6\\}$ 都有 $x_k = 0$。\n- 测试 3：$N=13$，其中对于所有 $k \\in \\{0,1,2,\\dots,12\\}$ 都有 $x_k = k$。\n- 测试 4：$N=1$，其中 $x_0 = 42$。\n- 测试 5：$N=29$，其中对于所有 $k \\in \\{0,1,2,\\dots,28\\}$ 都有 $x_k = \\cos\\!\\left(\\frac{2\\pi k}{N}\\right) + \\mathrm{i}\\,\\sin\\!\\left(\\frac{4\\pi k}{N}\\right)$。\n- 测试 6：$N=17$，其中\n$$\nx_k = 0.3\\,\\sin(k) + 0.7\\,\\cos(k) + \\mathrm{i}\\,\\big(0.5\\,\\sin(k^2) - 0.2\\,\\cos(3k)\\big)\n$$\n对于所有 $k \\in \\{0,1,2,\\dots,16\\}$。\n\n对于每个测试用例，通过您的 Bluestein 实现和直接 $O(N^2)$ DFT 计算 DFT，并计算最大绝对差\n$$\n\\Delta = \\max_{n \\in \\{0,1,\\dots,N-1\\}} \\big| X^{(\\mathrm{Bluestein})}_n - X^{(\\mathrm{Direct})}_n \\big|.\n$$\n使用容差 $\\varepsilon = 10^{-12}$ 并返回一个布尔值，指示是否 $\\Delta  \\varepsilon$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\texttt{[result1,result2,\\dots]}$），其中每个条目是根据上述规定为相应测试用例计算的布尔值。",
                "solution": "该问题要求实现并验证用于计算离散傅里叶变换 (DFT) 的 Bluestein 算法，特别是针对素数长度的序列。解决方案必须从第一性原理推导，将 DFT 转换为线性卷积，然后使用快速傅里叶变换 (FFT) 通过循环卷积来计算该线性卷积。\n\n序列 $x \\in \\mathbb{C}^{N}$ 的 DFT 是一个序列 $X \\in \\mathbb{C}^{N}$，定义如下：\n$$\nX_n = \\sum_{k=0}^{N-1} x_k \\exp\\left(-\\frac{2\\pi \\mathrm{i}}{N} n k\\right), \\quad \\text{for } n \\in \\{0, 1, \\dots, N-1\\}\n$$\n对每个 $X_n$ 逐项直接计算此和需要 $O(N)$ 次运算，导致整个变换的总复杂度为 $O(N^2)$。这种直接方法将作为我们验证的参考。\n\nBluestein 算法重新构造 DFT 以利用 FFT 的计算效率。关键的见解是使用一个二次恒等式（称为极化恒等式）来表示指数中的乘积 $nk$：\n$$\n2nk = n^2 + k^2 - (n-k)^2\n$$\n将此代入 DFT 定义的指数中，得到：\n$$\nX_n = \\sum_{k=0}^{N-1} x_k \\exp\\left(-\\frac{\\pi \\mathrm{i}}{N} (n^2 + k^2 - (n-k)^2)\\right)\n$$\n我们可以分解指数项以分离对 $n$、$k$ 和 $(n-k)$ 的依赖关系：\n$$\nX_n = \\sum_{k=0}^{N-1} x_k \\exp\\left(-\\frac{\\pi \\mathrm{i} n^2}{N}\\right) \\exp\\left(-\\frac{\\pi \\mathrm{i} k^2}{N}\\right) \\exp\\left(\\frac{\\pi \\mathrm{i} (n-k)^2}{N}\\right)\n$$\n项 $\\exp(- \\pi \\mathrm{i} n^2 / N)$ 相对于求和索引 $k$ 是常数，可以提取出来：\n$$\nX_n = \\exp\\left(-\\frac{\\pi \\mathrm{i} n^2}{N}\\right) \\sum_{k=0}^{N-1} \\left(x_k \\exp\\left(-\\frac{\\pi \\mathrm{i} k^2}{N}\\right)\\right) \\exp\\left(\\frac{\\pi \\mathrm{i} (n-k)^2}{N}\\right)\n$$\n此表达式现在具有线性卷积的形式。我们定义两个序列：\n1.  一个预 chirp 输入序列 $a$：$a_k = x_k \\exp\\left(-\\frac{\\pi \\mathrm{i} k^2}{N}\\right)$，对于 $k \\in \\{0, 1, \\dots, N-1\\}$。\n2.  一个 chirp 序列（卷积核）$h$：$h_j = \\exp\\left(\\frac{\\pi \\mathrm{i} j^2}{N}\\right)$。\n\n使用这些定义，DFT 可以写成：\n$$\nX_n = h_n^* \\sum_{k=0}^{N-1} a_k h_{n-k}\n$$\n其中 $h_n^*$ 是 $h_n$ 的复共轭。该求和正是序列 $a$ 和 $h$ 的线性卷积，在索引 $n$ 处求值，记作 $(a * h)_n$。$h$ 的索引所需值的范围从 $n-k = 0-(N-1) = -(N-1)$ 到 $n-k = (N-1)-0 = N-1$。\n\n两个长度为 $N$ 的序列的线性卷积可以通过将其嵌入到更长长度 $L$ 的循环卷积中来高效计算。长度 $L$ 必须足够大以避免时域混叠，这意味着 $L \\ge N + N - 1 = 2N - 1$。为了获得最佳的 FFT 性能，$L$ 通常选择为 2 的幂。问题指定选择满足 $L \\ge 2N-1$ 的最小的 2 的幂作为 $L$。\n\n为使用循环卷积计算线性卷积，我们通过对 $a$ 进行零填充并构造 $h$ 的周期版本来定义两个新的长度为 $L$ 的序列 $a'$ 和 $h'$：\n*   $a'_k = a_k$ 对于 $0 \\le k  N$，以及 $a'_k = 0$ 对于 $N \\le k  L$。\n*   $h'_k = h_k$ 对于 $0 \\le k  N$，$h'_k = h_{k-L}$ 对于 $L-(N-1) \\le k  L$，其他情况下 $h'_k = 0$。项 $h_{k-L}$ 正确地捕获了 chirp 核的负索引，例如 $h'_{(L-1)} = h_{-1}$。\n\n$a'$ 和 $h'$ 的循环卷积由卷积定理给出。如问题所述，循环矩阵可由傅里叶矩阵对角化，这意味着时域中的循环卷积等价于频域中的逐元素相乘。设 $F_L$ 和 $F_L^{-1}$ 分别是 $L$ 点 DFT 和逆 DFT 算子。得到的卷积序列 $c$ 为：\n$$\nc = F_L^{-1} (F_L(a') \\odot F_L(h'))\n$$\n其中 $\\odot$ 表示逐元素相乘。此序列 $c$ 的前 $N$ 个元素对应于所需的线性卷积值，即 $c_n = (a * h)_n$ 对于 $n \\in \\{0, 1, \\dots, N-1\\}$。\n\n最后一步是乘以 post-chirp 因子：\n$$\nX_n = c_n \\cdot h_n^* = c_n \\cdot \\exp\\left(-\\frac{\\pi \\mathrm{i} n^2}{N}\\right)\n$$\n这样就完成了 Bluestein 算法的推导。\n\n完整的过程总结如下：\n1.  对于给定的长度为 $N$ 的输入序列 $x$，确定卷积长度 $L$ 为满足 $L \\ge 2N-1$ 的最小的 2 的幂。\n2.  计算预 chirp 序列 $a_k = x_k \\exp(-\\pi \\mathrm{i} k^2/N)$，对于 $k \\in \\{0, \\dots, N-1\\}$。\n3.  从 chirp $h_j = \\exp(\\pi \\mathrm{i} j^2/N)$ 构建长度为 $L$ 的填充核序列 $h'$。\n4.  计算填充序列 $a'$ 和核 $h'$ 的 FFT：$A' = F_L(a')$ 和 $H' = F_L(h')$。\n5.  在频域中执行逐元素相乘：$C' = A' \\odot H'$。\n6.  计算逆 FFT 以获得卷积结果：$c = F_L^{-1}(C')$。\n7.  提取 $c$ 的前 $N$ 个元素，并乘以 post-chirp 因子 $h_n^*$ 以获得最终的 DFT 结果 $X_n$。\n\n将此算法与 DFT 定义的直接 $O(N^2)$ 实现进行比较，以验证其在给定测试用例下的正确性，使用的最大绝对误差容差为 $\\varepsilon = 10^{-12}$。",
                "answer": "```python\nimport numpy as np\n\ndef direct_dft(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the DFT of a sequence x using the direct O(N^2) formula.\n    \"\"\"\n    N = len(x)\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n    \n    n = np.arange(N)\n    k = np.arange(N)\n    \n    # Create the DFT matrix W where W_nk = exp(-2*pi*i*n*k/N)\n    nk = np.outer(n, k)\n    W = np.exp(-2j * np.pi * nk / N)\n    \n    # Compute the DFT via matrix-vector multiplication\n    X = np.dot(W, x)\n    return X\n\ndef bluestein_dft(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the DFT of a sequence x using Bluestein's algorithm.\n    \"\"\"\n    N = len(x)\n\n    if N == 0:\n        return np.array([], dtype=np.complex128)\n    \n    # Base case N=1, DFT is identity.\n    if N == 1:\n        return x.copy()\n\n    # Step 1: Determine convolution length L\n    # L must be a power of two such that L >= 2*N - 1\n    M = 2 * N - 1\n    L = 1  (M - 1).bit_length()\n\n    # Step 2: Create pre-chirped sequence 'a' and pad it to 'a_prime'\n    k = np.arange(N)\n    # The pre-chirp factor is exp(-i*pi*k^2/N)\n    pre_chirp = np.exp(-1j * np.pi * k**2 / N)\n    a = x * pre_chirp\n    \n    a_prime = np.zeros(L, dtype=np.complex128)\n    a_prime[:N] = a\n\n    # Step 3: Create the chirp filter sequence 'h_prime'\n    h_prime = np.zeros(L, dtype=np.complex128)\n    \n    # The kernel is h_k = exp(i*pi*k^2/N). We need it for k in [-(N-1), N-1].\n    # Positive indices part: k in [0, N-1]\n    k_pos = np.arange(N)\n    h_prime[k_pos] = np.exp(1j * np.pi * k_pos**2 / N)\n    \n    # Negative indices part: k in [-(N-1), -1], which are mapped to\n    # indices [L-(N-1), L-1] in the circular convolution.\n    if N > 1:\n        k_neg_indices = np.arange(L - N + 1, L)\n        # The conceptual negative indices are k_neg_indices - L\n        k_neg_values = k_neg_indices - L\n        h_prime[k_neg_indices] = np.exp(1j * np.pi * k_neg_values**2 / N)\n\n    # Step 4-6: Perform convolution via FFT\n    A_prime = np.fft.fft(a_prime)\n    H_prime = np.fft.fft(h_prime)\n    C_prime = A_prime * H_prime\n    c_conv = np.fft.ifft(C_prime)\n\n    # Step 7: Apply post-chirp factor and extract result\n    n = np.arange(N)\n    # The post-chirp factor is exp(-i*pi*n^2/N)\n    post_chirp = np.exp(-1j * np.pi * n**2 / N)\n    X = c_conv[:N] * post_chirp\n    \n    return X\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = []\n\n    # Test 1: N=2\n    N1 = 2\n    x1 = np.array([1, -1j], dtype=np.complex128)\n    test_cases.append((N1, x1))\n\n    # Test 2: N=7\n    N2 = 7\n    x2 = np.zeros(N2, dtype=np.complex128)\n    x2[0] = 1\n    test_cases.append((N2, x2))\n\n    # Test 3: N=13\n    N3 = 13\n    x3 = np.arange(N3, dtype=np.complex128)\n    test_cases.append((N3, x3))\n\n    # Test 4: N=1\n    N4 = 1\n    x4 = np.array([42], dtype=np.complex128)\n    test_cases.append((N4, x4))\n\n    # Test 5: N=29\n    N5 = 29\n    k5 = np.arange(N5)\n    x5 = np.cos(2 * np.pi * k5 / N5) + 1j * np.sin(4 * np.pi * k5 / N5)\n    test_cases.append((N5, x5))\n\n    # Test 6: N=17\n    N6 = 17\n    k6 = np.arange(N6)\n    x6 = (0.3 * np.sin(k6) + 0.7 * np.cos(k6)) + \\\n         1j * (0.5 * np.sin(k6**2) - 0.2 * np.cos(3 * k6))\n    test_cases.append((N6, x6))\n\n    results = []\n    tolerance = 1e-12\n\n    for N, x in test_cases:\n        X_direct = direct_dft(x)\n        X_bluestein = bluestein_dft(x)\n        \n        # Calculate the maximum absolute entrywise discrepancy\n        delta = np.max(np.abs(X_bluestein - X_direct))\n        \n        # Append boolean result to the list\n        results.append(delta  tolerance)\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```",
                "id": "3545333"
            },
            {
                "introduction": "拥有了利用 FFT 对循环矩阵进行快速矩阵-向量乘法 ($C \\cdot x$) 的能力后，我们自然会思考如何将其应用于更广泛的数值算法中。此练习 [@problem_id:3545359] 将实践重点从变换计算本身转移到矩阵分析。您将探索如何应用幂迭代法来估计矩阵的谱范数 ($\\|C\\|_2$) 和条件数 ($\\kappa_2(C)$)——这两个量是分析其数值稳定性的关键指标，并深入理解算法的收敛速度如何由矩阵的谱隙决定。",
                "problem": "考虑一个 $n \\times n$ 的实循环矩阵 $C$，其中 $n$ 为偶数，其由第一列 $c \\in \\mathbb{R}^{n}$ 定义，其中 $c_{0}=3$，$c_{1}=1$，$c_{n-1}=1$，且对于所有其他索引 $j \\in \\{2,3,\\dots,n-2\\}$，$c_{j}=0$。你的任务是设计一个谱范数 $\\|C\\|_{2}$ 和 2-范数条件数 $\\kappa_{2}(C)$ 的完全显式随机估计量，该估计量使用幂迭代方案，其中的矩阵-向量乘法通过快速傅里叶变换 (FFT) 实现。从基本定义出发：循环矩阵的结构、作为酉基变换的离散傅里叶变换以及正规矩阵的谱定理。你不得假设任何预先推导出的对角化公式或捷径恒等式；相反，必须从这些基础出发，由第一性原理推导出所有关系。\n\n你的估计量应：\n- 使用一个随机初始向量 $x^{(0)} \\in \\mathbb{R}^{n}$，其分量独立同分布于一个关于 $0$ 对称的连续分布（例如，标准正态分布），从而几乎必然地，$x^{(0)}$ 在 $C$ 的每个特征向量方向上都有非零分量。\n- 实现幂迭代 $x^{(t+1)} := C x^{(t)} / \\|C x^{(t)}\\|_{2}$（对于 $t \\geq 0$），通过瑞利商 $r^{(t)} := (x^{(t)})^{\\top} C x^{(t)}$ 来估计 $\\|C\\|_{2}$，并独立地对 $C^{-1}$ 实现类似的迭代 $y^{(t+1)} := C^{-1} y^{(t)} / \\|C^{-1} y^{(t)}\\|_{2}$ 来估计 $C$ 的最小特征值。$C$ 和 $C^{-1}$ 的乘法都必须通过基于 FFT 的 $C$ 的对角化，在 $O(n \\log n)$ 时间内完成。\n- 根据从 $C$ 的特征值 $\\lambda_k$ 推断出的谱间隙，分析每次迭代的渐近收敛率。\n\n仅使用这些基础，完成以下任务：\n1. 推导 $C$ 的特征值 $\\lambda_{k}$。\n2. 证明 $C$ 是对称正定的，确定 $\\|C\\|_{2}$ 和最小特征值，并得出 $\\kappa_{2}(C)$ 的结论。\n3. 对于在 $C$ 上的幂迭代，根据第二大特征值与最大特征值的比值，推导 $x^{(t)}$ 与主特征向量之间夹角的渐近几何收敛因子。将此因子表示为 $n$ 的一个闭式函数。\n4. 对于在 $C^{-1}$ 上的幂迭代，根据 $C$ 的最小特征值与第二小特征值的比值，推导类似的渐近几何收敛因子，同样表示为 $n$ 的一个闭式函数。\n5. 以闭式形式报告一个四元组，其中包含：精确的谱范数 $\\|C\\|_{2}$、精确的条件数 $\\kappa_{2}(C)$、在 $C$ 上进行幂迭代的渐近几何收敛因子，以及在 $C^{-1}$ 上进行幂迭代的渐近几何收敛因子，每一项都纯粹用 $n$ 和常数表示。无需四舍五入。\n\n你最终报告的答案必须是一个单行矩阵，按指定顺序包含这四个量。",
                "solution": "对问题陈述进行分析后，认定其是有效的。这是一个数值线性代数中的适定问题，具有科学依据、客观且自洽。要求从基本原理推导结果是一项教学上的约束，不构成缺陷。我们开始解答。\n\n问题要求分析一个特定的实数、偶数维度的循环矩阵 $C \\in \\mathbb{R}^{n \\times n}$。矩阵 $C$ 由其第一列向量 $c \\in \\mathbb{R}^{n}$ 定义，其中 $c_0 = 3$，$c_1 = 1$，$c_{n-1} = 1$，且对于 $j \\in \\{2, 3, \\dots, n-2\\}$，$c_j = 0$。\n\n1.  **推导 $C$ 的特征值**\n\n一个循环矩阵由其第一列定义。其元素 $C_{jk}$ 由 $c_{(j-k) \\pmod n}$ 给出。对角化循环矩阵的基本原理是其特征向量是离散傅里叶变换 (DFT) 矩阵的列向量。我们必须从第一性原理推导这一点。\n\n令 $\\omega = \\exp(2\\pi i/n)$ 为 $n$ 次单位原根，其中 $i = \\sqrt{-1}$。考虑向量 $v_k \\in \\mathbb{C}^n$（对于 $k \\in \\{0, 1, \\dots, n-1\\}$），其中 $v_k$ 的第 $j$ 个分量是 $(v_k)_j = \\omega^{jk}$。我们将证明这些是 $C$ 的特征向量。\n\n让我们计算矩阵-向量乘积 $C v_k$ 的第 $j$ 个分量：\n$$ (C v_k)_j = \\sum_{m=0}^{n-1} C_{jm} (v_k)_m = \\sum_{m=0}^{n-1} c_{(j-m) \\pmod n} \\, \\omega^{mk} $$\n令 $p = (j-m) \\pmod n$。当 $m$ 从 $0$ 遍历到 $n-1$ 时，$p$ 也覆盖了集合 $\\{0, 1, \\dots, n-1\\}$。我们可以用 $p$ 表示 $m$ 为 $m = (j-p) \\pmod n$。将此代入求和式中：\n$$ (C v_k)_j = \\sum_{p=0}^{n-1} c_p \\, \\omega^{(j-p)k} = \\sum_{p=0}^{n-1} c_p \\, \\omega^{jk} \\omega^{-pk} = \\omega^{jk} \\left( \\sum_{p=0}^{n-1} c_p \\, \\omega^{-pk} \\right) $$\n括号中的项是一个依赖于 $k$ 但不依赖于 $j$ 的标量。我们把这个标量定义为 $\\lambda_k$：\n$$ \\lambda_k = \\sum_{j=0}^{n-1} c_j \\omega^{-jk} $$\n根据这个定义，我们有 $(C v_k)_j = \\lambda_k \\omega^{jk} = \\lambda_k (v_k)_j$。这个等式对所有分量 $j$ 都成立，这证明了 $v_k$ 是 $C$ 的一个特征向量，其对应的特征值为 $\\lambda_k$。特征值集合 $\\{\\lambda_k\\}_{k=0}^{n-1}$ 称为 $C$ 的谱。\n\n现在，我们将向量 $c$ 中的具体值代入 $\\lambda_k$ 的公式中：\n$$ \\lambda_k = c_0 \\omega^{-0} + c_1 \\omega^{-k} + c_{n-1} \\omega^{-(n-1)k} + \\sum_{j=2}^{n-2} c_j \\omega^{-jk} $$\n$$ \\lambda_k = 3 \\cdot 1 + 1 \\cdot \\omega^{-k} + 1 \\cdot \\omega^{-(n-1)k} + 0 = 3 + \\omega^{-k} + \\omega^{-(n-1)k} $$\n使用性质 $\\omega^n = \\exp(2\\pi i) = 1$，我们可以简化 $\\omega^{-(n-1)k} = \\omega^{-nk} \\omega^k = (\\omega^n)^{-k} \\omega^k = 1^{-k} \\omega^k = \\omega^k$。\n$$ \\lambda_k = 3 + \\omega^{-k} + \\omega^k $$\n根据欧拉公式，$\\omega^k = \\cos(2\\pi k/n) + i\\sin(2\\pi k/n)$ 且 $\\omega^{-k} = \\cos(2\\pi k/n) - i\\sin(2\\pi k/n)$。它们的和是 $2\\cos(2\\pi k/n)$。\n因此，$C$ 的特征值为：\n$$ \\lambda_k = 3 + 2\\cos\\left(\\frac{2\\pi k}{n}\\right) \\quad \\text{for } k = 0, 1, \\dots, n-1 $$\n\n2.  **对称性、正定性、谱范数和条件数**\n\n对于一个第一列为 $c$ 的实循环矩阵，其对称性（$C=C^T$）等价于条件 $c_j = c_{n-j}$ 对 $j=1, \\dots, n-1$ 成立。在我们的例子中，$c_1=1$ 且 $c_{n-1}=1$，所以该条件对 $j=1$ 成立。对于 $j \\in \\{2, \\dots, n-2\\}$，我们有 $c_j=0$。因为 $n$ 是偶数，索引 $n-j$ 也属于 $\\{2, \\dots, n-2\\}$，这意味着 $n-j \\neq j$，所以 $c_{n-j}$ 也为0。该条件对所有 $j$ 都成立，所以 $C$ 是对称的。\n\n由于 $C$ 是一个实对称矩阵，其特征值必须是实数。我们推导出的表达式 $\\lambda_k = 3 + 2\\cos(2\\pi k/n)$ 对所有 $k$ 确实是实数。为了检验正定性，我们需要证明所有特征值都严格为正。余弦函数的取值范围是 $[-1, 1]$。\n$\\cos(2\\pi k/n)$ 的最大值是 $1$，在 $k=0$ 时取到。这给出了最大的特征值：\n$$ \\lambda_{\\max} = \\lambda_0 = 3 + 2\\cos(0) = 3 + 2 = 5 $$\n$\\cos(2\\pi k/n)$ 的最小值是 $-1$，在 $k=n/2$ 时取到（因为 $n$ 是偶数，所以这是一个整数）。这给出了最小的特征值：\n$$ \\lambda_{\\min} = \\lambda_{n/2} = 3 + 2\\cos(\\pi) = 3 - 2 = 1 $$\n所有特征值 $\\lambda_k$ 都位于区间 $[1, 5]$ 内。由于 $\\lambda_{\\min} = 1 > 0$，所有特征值都是正的，因此对称矩阵 $C$ 是正定的。\n\n对于一个正规矩阵（对称矩阵是正规矩阵），谱范数 $\\|C\\|_2$ 是其谱半径，即其特征值的最大绝对值。\n$$ \\|C\\|_2 = \\max_{k} |\\lambda_k| = \\lambda_{\\max} = 5 $$\n2-范数条件数 $\\kappa_2(C)$ 由 $\\|C\\|_2 \\|C^{-1}\\|_2$ 给出。$C^{-1}$ 的特征值是 $1/\\lambda_k$。因此，$\\|C^{-1}\\|_2 = \\max_k |1/\\lambda_k| = 1/\\min_k|\\lambda_k| = 1/\\lambda_{\\min}$。\n$$ \\kappa_2(C) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} = \\frac{5}{1} = 5 $$\n\n3.  **$C$ 上幂迭代的收敛因子**\n\n幂迭代法 $x^{(t+1)} \\propto C x^{(t)}$ 收敛到对应于模最大特征值的特征向量。渐近几何收敛因子是第二大模与最大模特征值的比值。由于 $C$ 的所有特征值都是正的，我们寻求比值 $\\lambda'/\\lambda_{\\max}$，其中 $\\lambda'$ 是第二大特征值。\n\n特征值为 $\\lambda_k = 3 + 2\\cos(2\\pi k/n)$。\n最大特征值是 $\\lambda_0 = 5$，它是唯一的。\n函数 $\\cos(x)$ 在 $[0, \\pi]$ 上是严格递减的。对于 $k=1$ 和 $k=n-1$，参数 $2\\pi k/n$ 给出相同的余弦值：$\\cos(2\\pi/n) = \\cos(2\\pi(n-1)/n) = \\cos(2\\pi - 2\\pi/n)$。这个值是仅次于 $\\cos(0)=1$ 的最大值。\n因此，第二大特征值是退化的（重数为2），由以下公式给出：\n$$ \\lambda' = \\lambda_1 = \\lambda_{n-1} = 3 + 2\\cos\\left(\\frac{2\\pi}{n}\\right) $$\n渐近几何收敛因子是：\n$$ \\frac{\\lambda'}{\\lambda_{\\max}} = \\frac{3 + 2\\cos\\left(\\frac{2\\pi}{n}\\right)}{5} $$\n\n4.  **$C^{-1}$ 上幂迭代的收敛因子**\n\n应用于 $C^{-1}$ 的幂迭代（即对 $C$ 的反幂迭代）收敛到 $C^{-1}$ 对应于其模最大特征值的特征向量。该特征值为 $1/\\lambda_{\\min}$，其中 $\\lambda_{\\min}$ 是 $C$ 的模最小的特征值。收敛因子是 $C^{-1}$ 的第二大模与最大模特征值的比值，这等价于 $C$ 的最小模与第二小模特征值的比值。\n\n$C$ 的最小特征值是 $\\lambda_{\\min} = \\lambda_{n/2} = 1$，它是唯一的。\n第二小特征值对应于最接近 $-1$ 的 $\\cos(2\\pi k/n)$ 值。这在 $k=n/2-1$ 和 $k=n/2+1$ 时发生。\n$$ \\cos\\left(\\frac{2\\pi(n/2-1)}{n}\\right) = \\cos\\left(\\pi - \\frac{2\\pi}{n}\\right) = -\\cos\\left(\\frac{2\\pi}{n}\\right) $$\n$$ \\cos\\left(\\frac{2\\pi(n/2+1)}{n}\\right) = \\cos\\left(\\pi + \\frac{2\\pi}{n}\\right) = -\\cos\\left(\\frac{2\\pi}{n}\\right) $$\n因此，第二小特征值 $\\lambda''$ 也是退化的，由以下公式给出：\n$$ \\lambda'' = \\lambda_{n/2-1} = \\lambda_{n/2+1} = 3 + 2\\left(-\\cos\\left(\\frac{2\\pi}{n}\\right)\\right) = 3 - 2\\cos\\left(\\frac{2\\pi}{n}\\right) $$\n反幂迭代的渐近几何收敛因子是：\n$$ \\frac{\\lambda_{\\min}}{\\lambda''} = \\frac{1}{3 - 2\\cos\\left(\\frac{2\\pi}{n}\\right)} $$\n\n5.  **最终的四元数量组**\n\n基于以上推导，所要求的四个量是：\n1.  谱范数 $\\|C\\|_2 = 5$。\n2.  条件数 $\\kappa_2(C) = 5$。\n3.  $C$ 上幂迭代的渐近几何收敛因子：$\\frac{1}{5}\\left(3 + 2\\cos\\left(\\frac{2\\pi}{n}\\right)\\right)$。\n4.  $C^{-1}$ 上幂迭代的渐近几何收敛因子：$\\frac{1}{3 - 2\\cos\\left(\\frac{2\\pi}{n}\\right)}$。\n\n这些被汇编成一个单行矩阵作为最终答案。",
                "answer": "$$\n\\boxed{\\begin{pmatrix} 5  5  \\frac{3 + 2\\cos\\left(\\frac{2\\pi}{n}\\right)}{5}  \\frac{1}{3 - 2\\cos\\left(\\frac{2\\pi}{n}\\right)} \\end{pmatrix}}\n$$",
                "id": "3545359"
            },
            {
                "introduction": "理论上完美的数学公式在有限精度的计算机上实现时，常常会遇到数值陷阱，尤其是在处理接近零的特征值时。这项高级实践 [@problem_id:3545340] 聚焦于 Moore-Penrose 伪逆的计算及其数值稳定性问题。您将通过编程实践，亲眼见证微小的特征值如何通过倒数运算放大舍入误差，进而破坏投影算子在理论上应具备的幂等性 ($P^2 = P$)，并学习如何通过谱域正则化技术来恢复其性质。",
                "problem": "您的任务是分析一个投影算子，该算子是利用快速傅里叶变换 (FFT) 计算的离散傅里叶变换 (DFT)，由一个循环矩阵的 Moore–Penrose 伪逆构建而成。在精确算术中，该投影是幂等的，但在有限精度下，接近于零的谱值会放大舍入误差。您的目标是推导、实现并定量评估谱值过小如何破坏幂等性，并设计一种频域正则化方法来恢复近似幂等性。\n\n基本原理：\n- 一个由第一列 $c \\in \\mathbb{C}^{n}$ 生成的循环矩阵 $C \\in \\mathbb{C}^{n \\times n}$ 可被酉 DFT 矩阵 $F \\in \\mathbb{C}^{n \\times n}$ 酉对角化，满足 $F^{*} F = I$。这得到 $C = F^{*} \\,\\mathrm{diag}(\\lambda)\\, F$，其中 $\\lambda = F c$。\n- $C$ 的 Moore–Penrose 伪逆 $C^{\\dagger}$ 为 $C^{\\dagger} = F^{*}\\,\\mathrm{diag}(\\mu)\\,F$，其中对每个 $k$，当 $\\lambda_{k} \\neq 0$ 时 $\\mu_{k} = 1/\\lambda_{k}$，当 $\\lambda_{k} = 0$ 时 $\\mu_{k} = 0$。\n- 投影 $P = C^{\\dagger} C$ 在精确算术下是幂等的，即 $P^{2} = P$。\n\n任务：\n1. 从上述基本原理推导，投影 $P$ 也是循环矩阵且可被 $F$ 酉对角化，并将其谱与 $\\lambda$ 相关联。将 $p \\in \\mathbb{C}^{n}$ 定义为 $P$ 的频率响应，使得 $P = F^{*}\\,\\mathrm{diag}(p)\\,F$，然后使用 Frobenius 范数定义一个幂等性缺陷度量，\n   $$\\mathcal{E}(P) \\equiv \\frac{\\lVert P^{2} - P \\rVert_{F}}{\\lVert P \\rVert_{F}},$$\n   并仅使用酉相似性和 Frobenius 范数的性质，将其纯粹用 $p$ 表示（不含显式的稠密矩阵）。\n2. 使用酉标度（即正变换除以 $\\sqrt{n}$，逆变换乘以 $\\sqrt{n}$）的 FFT，实现以下三种 $p$ 的谱构造方法，并计算相应的幂等性缺陷：\n   - 带有放大舍入误差的朴素倒数法。设 $\\lambda \\in \\mathbb{C}^{n}$ 是通过酉 FFT 从 $c$ 获得的。对于每个 $\\lambda_{k} \\neq 0$ 的索引 $k$，定义一个受扰动的倒数\n     $$\\tilde{\\mu}_{k} = \\frac{1}{\\lambda_{k}}\\left(1 + \\delta_{k}\\right),$$\n     其中扰动 $\\delta_{k}$ 模拟了放大的舍入误差，其大小与 $\\lvert \\lambda_{k} \\rvert$ 成反比。使用\n     $$\\delta_{k} = \\xi_{k}\\,u\\,\\frac{\\tau}{\\max(\\lvert \\lambda_{k} \\rvert, 10^{-300})},$$\n     其中 $u$ 为双精度的机器单位舍入误差，$\\tau  0$ 为指定的阈值参数，实数 $\\xi_{k}$ 从标准正态分布中抽取，为保证可复现性使用固定的随机种子。对于 $\\lambda_{k} = 0$，设置 $\\tilde{\\mu}_{k} = 0$。然后设置\n     $$\\tilde{p}_{k} = \\tilde{\\mu}_{k}\\,\\lambda_{k}.$$\n     计算 $p = \\tilde{p}$ 时的 $\\mathcal{E}$。\n   - 截断谱伪逆（硬阈值法）。定义\n     $$\\mu^{(\\tau)}_{k} = \\begin{cases} \\frac{1}{\\lambda_{k}},  \\lvert \\lambda_{k} \\rvert \\ge \\tau \\\\ 0,  \\lvert \\lambda_{k} \\rvert  \\tau \\end{cases}, \\quad p^{(\\tau)}_{k} = \\mu^{(\\tau)}_{k}\\,\\lambda_{k}.$$\n     计算 $p = p^{(\\tau)}$ 时的 $\\mathcal{E}$。\n   - 频域中的 Tikhonov 型平滑。定义\n     $$p^{(\\alpha)}_{k} = \\frac{\\lvert \\lambda_{k} \\rvert^{2}}{\\lvert \\lambda_{k} \\rvert^{2} + \\alpha},$$\n     给定参数 $\\alpha  0$（在测试中您将使用 $\\alpha = \\tau^{2}$）。计算 $p = p^{(\\alpha)}$ 时的 $\\mathcal{E}$。\n3. 通过 FFT 在频域中实现所有计算。不要构建任何稠密的 $n \\times n$ 矩阵。您的幂等性缺陷必须仅使用任务 1 的结果，从谱向量 $p$ 计算。\n4. 测试套件。对于以下四种情况中的每一种，计算并报告幂等性缺陷三元组 $[\\mathcal{E}_{\\mathrm{naive}}, \\mathcal{E}_{\\mathrm{trunc}}, \\mathcal{E}_{\\mathrm{tikh}}]$：\n   - 情况 A（存在精确零模式）：$n=8$，$c = [2,\\,1,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1]^{\\top}$，$\\tau = 1\\times 10^{-8}$，$\\alpha = \\tau^{2}$，对扰动使用随机种子 $0$。\n   - 情况 B（频率 $0$ 处存在近零模式）：$n=12$，$c = [\\,1,\\,-(1-10^{-12}),\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0\\,]^{\\top}$，$\\tau = 1\\times 10^{-8}$，$\\alpha = \\tau^{2}$，种子 $1$。\n   - 情况 C（具有许多微小低频分量的离散二阶差分谱）：$n=4096$，$c = [\\,1,\\,-2,\\,1,\\,0,\\,\\ldots,\\,0\\,]^{\\top}$，$\\tau = 1\\times 10^{-5}$，$\\alpha = \\tau^{2}$，种子 $2$。\n   - 情况 D（良态单位循环矩阵）：$n=5$，$c = [\\,1,\\,0,\\,0,\\,0,\\,0\\,]^{\\top}$，$\\tau = 1\\times 10^{-8}$，$\\alpha = \\tau^{2}$，种子 $3$。\n   在所有情况下，将 $c$ 解释为虚部为零的复数。DFT 中隐含的角度单位为弧度。使用双精度算术。对于单位舍入误差，取 $u = 2^{-53}$。\n5. 最终输出格式。您的程序应产生单行输出，其中包含结果，格式为一个逗号分隔的列表，内含四个子列表，每个子列表是按 A、B、C、D 顺序排列的一个测试用例的三元组。例如：\n   $$[ [x_{A},y_{A},z_{A}], [x_{B},y_{B},z_{B}], [x_{C},y_{C},z_{C}], [x_{D},y_{D},z_{D}] ],$$\n   其中每个符号都是一个浮点数。不要打印任何额外文本。\n\n注意事项：\n- 不要使用任何稠密的 $n \\times n$ 矩阵；任务 1 中的推导必须证明如何直接从谱数据计算 Frobenius 范数。\n- 您的实现必须依靠快速傅里叶变换，并采用酉归一化来从 $c$ 获得 $\\lambda$。\n- 答案值没有物理单位。",
                "solution": "该问题要求分析一个由循环矩阵导出的投影算子的幂等性。具体来说，我们必须在谱域中推导一个幂等性缺陷度量的公式，然后实现并比较三种不同的构造投影的数值策略：一种易受舍入误差影响的朴素方法，一种硬阈值方法，以及一种 Tikhonov 正则化方法。\n\n### 任务 1：在谱域中推导幂等性缺陷\n\n设 $C \\in \\mathbb{C}^{n \\times n}$ 是一个由其第一列 $c \\in \\mathbb{C}^n$ 生成的循环矩阵。它可被酉离散傅里叶变换 (DFT) 矩阵 $F \\in \\mathbb{C}^{n \\times n}$ 对角化为 $C = F^* \\mathrm{diag}(\\lambda) F$，其中 $\\lambda = F c$ 是 $C$ 的特征值向量（即谱）。Moore-Penrose 伪逆 $C^\\dagger$ 由 $C^\\dagger = F^* \\mathrm{diag}(\\mu) F$ 给出，其中谱向量 $\\mu$ 的元素定义为：如果 $\\lambda_k \\neq 0$，则 $\\mu_k = 1/\\lambda_k$；如果 $\\lambda_k = 0$，则 $\\mu_k = 0$。\n\n到 $C$ 的值域上的投影算子是 $P = C^\\dagger C$。我们可以用 $C$ 和 $C^\\dagger$ 的谱表示来表达 $P$：\n$$\nP = C^\\dagger C = \\left( F^* \\mathrm{diag}(\\mu) F \\right) \\left( F^* \\mathrm{diag}(\\lambda) F \\right)\n$$\n由于 $F$ 是酉矩阵，有 $F F^* = I$，其中 $I$ 是单位矩阵。\n$$\nP = F^* \\mathrm{diag}(\\mu) (F F^*) \\mathrm{diag}(\\lambda) F = F^* \\mathrm{diag}(\\mu) \\mathrm{diag}(\\lambda) F\n$$\n两个对角矩阵的乘积是一个对角矩阵，其元素是相应对角元素的乘积。设 $p \\in \\mathbb{C}^n$ 是一个向量，使得对每个 $k$ 都有 $p_k = \\mu_k \\lambda_k$。那么，$\\mathrm{diag}(p) = \\mathrm{diag}(\\mu) \\mathrm{diag}(\\lambda)$，我们有：\n$$\nP = F^* \\mathrm{diag}(p) F\n$$\n此方程表明 $P$ 也可以被 DFT 矩阵 $F$ 对角化。一个矩阵是循环矩阵当且仅当它可以被 DFT 矩阵对角化。因此，$P$ 是一个循环矩阵，其谱由向量 $p$ 给出。\n\n在精确算术下，对于任何 $k$：\n- 如果 $\\lambda_k \\neq 0$，则 $\\mu_k = 1/\\lambda_k$，所以 $p_k = (1/\\lambda_k) \\lambda_k = 1$。\n- 如果 $\\lambda_k = 0$，则 $\\mu_k = 0$，所以 $p_k = 0 \\cdot 0 = 0$。\n因此，在精确算术下，投影 $P$ 的谱 $p$ 仅由 $0$ 和 $1$ 组成。\n\n幂等性缺陷定义为 $\\mathcal{E}(P) \\equiv \\frac{\\lVert P^{2} - P \\rVert_{F}}{\\lVert P \\rVert_{F}}$。我们需要用 $p$ 来表示它。Frobenius 范数的一个关键性质是其在酉变换下的不变性：对于任意矩阵 $A$ 和酉矩阵 $U$，有 $\\lVert U A U^* \\rVert_F = \\lVert A \\rVert_F$。\n\n首先，考虑 $P^2 - P$ 项：\n$$\nP^2 = \\left( F^* \\mathrm{diag}(p) F \\right) \\left( F^* \\mathrm{diag}(p) F \\right) = F^* \\mathrm{diag}(p)^2 F = F^* \\mathrm{diag}(p^2) F\n$$\n其中 $p^2$ 是向量 $p$ 的逐元素平方。\n那么，差值为：\n$$\nP^2 - P = F^* \\mathrm{diag}(p^2) F - F^* \\mathrm{diag}(p) F = F^* \\left( \\mathrm{diag}(p^2) - \\mathrm{diag}(p) \\right) F = F^* \\mathrm{diag}(p^2 - p) F\n$$\n利用 Frobenius 范数的酉不变性：\n$$\n\\lVert P^2 - P \\rVert_F = \\lVert F^* \\mathrm{diag}(p^2 - p) F \\rVert_F = \\lVert \\mathrm{diag}(p^2 - p) \\rVert_F\n$$\n对角矩阵的 Frobenius 范数是其对角元素向量的欧几里得（$L_2$）范数。\n$$\n\\lVert \\mathrm{diag}(p^2 - p) \\rVert_F = \\sqrt{\\sum_{k=0}^{n-1} |p_k^2 - p_k|^2} = \\lVert p^2 - p \\rVert_2\n$$\n\n接下来，考虑分母项 $\\lVert P \\rVert_F$：\n$$\n\\lVert P \\rVert_F = \\lVert F^* \\mathrm{diag}(p) F \\rVert_F = \\lVert \\mathrm{diag}(p) \\rVert_F = \\sqrt{\\sum_{k=0}^{n-1} |p_k|^2} = \\lVert p \\rVert_2\n$$\n\n结合分子和分母，我们得到了纯粹用谱向量 $p$ 表示的幂等性缺陷：\n$$\n\\mathcal{E}(P) = \\frac{\\lVert p^2 - p \\rVert_2}{\\lVert p \\rVert_2}\n$$\n这个公式使我们能够无需构建任何稠密的 $n \\times n$ 矩阵即可计算该缺陷，从而满足了问题的要求。如果由于数值误差，任何 $p_k$ 偏离了 $0$ 或 $1$，则分子 $\\lVert p^2 - p \\rVert_2$ 将变为非零，从而量化了幂等性的损失。\n\n### 计算策略与实现\n\n实现将严格遵循推导出的公式，在频域中执行所有计算。\n\n1.  **谱计算：** 对于每个测试用例，定义循环生成向量 $c$。使用快速傅里叶变换 (FFT) 并采用酉归一化（由 `numpy.fft.fft` 的参数 `norm=\"ortho\"` 提供）来计算其谱 $\\lambda$。\n\n2.  **谱构造：** 构造三种不同的投影谱向量 $p$：\n    -   **朴素法 ($\\tilde{p}$):** 计算一个受扰动的倒数 $\\tilde{\\mu}$，以模拟舍入误差的放大。计算扰动 $\\delta_k = \\xi_k u \\tau / \\max(|\\lambda_k|, 10^{-300})$，其中 $\\xi_k$ 是一个标准正态随机变量，$u=2^{-53}$ 是双精度的机器 epsilon，$\\tau$ 是给定的阈值。然后，对于 $\\lambda_k \\neq 0$，$\\tilde{p}_k = (1/\\lambda_k)(1+\\delta_k)\\lambda_k$；对于 $\\lambda_k=0$，$\\tilde{p}_k=0$。这种构造方法旨在针对小的非零 $|\\lambda_k|$ 值产生显著的失败。\n    -   **截断法 ($p^{(\\tau)}$):** 应用一个硬阈值 $\\tau$。仅对幅值大于等于 $\\tau$ 的特征值取倒数；否则，设为零。这导致如果 $|\\lambda_k| \\ge \\tau$，则 $p_k^{(\\tau)} = 1$；如果 $|\\lambda_k|  \\tau$，则 $p_k^{(\\tau)} = 0$。这种方法清晰地划分了哪些谱分量被保留，这应导致谱向量 $p$ 由非常接近 $0$ 和 $1$ 的值组成，从而产生较低的幂等性缺陷。\n    -   **Tikhonov 法 ($p^{(\\alpha)}$):** 应用一个平滑滤波器 $p_k^{(\\alpha)} = |\\lambda_k|^2 / (|\\lambda_k|^2 + \\alpha)$，其中 $\\alpha = \\tau^2$。这种方法在高幅值特征值（$p_k \\to 1$）通过和抑制低幅值特征值（$p_k \\to 0$）之间平滑过渡。它引入了系统性偏差，因为 $p_k$ 永远不会精确等于 $1$，这是以牺牲完美的幂等性为代价来换取数值稳定性。\n\n3.  **缺陷计算：** 对于得到的三个谱向量 $p$ 中的每一个，使用推导出的公式 $\\mathcal{E}(P) = \\lVert p^2 - p \\rVert_2 / \\lVert p \\rVert_2$ 来计算幂等性缺陷 $\\mathcal{E}$。一个辅助函数封装了此计算，使用 `numpy.linalg.norm` 计算 $L_2$ 向量范数。通过将缺陷定义为 $0$ 来处理 $\\lVert p \\rVert_2 = 0$（对应于零投影矩阵）的情况。\n\n该策略应用于四个指定的测试用例，每个用例都旨在探究一个不同的数值场景：一个真正的零特征值、一个近零特征值、一个具有许多小特征值的谱，以及一个良态谱。",
                "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for analyzing the idempotency defect\n    of circulant projection operators.\n    \"\"\"\n\n    def calculate_defect(p: np.ndarray) - float:\n        \"\"\"\n        Computes the idempotency defect from the projection's spectrum 'p'.\n        E(P) = ||p^2 - p||_2 / ||p||_2\n        \"\"\"\n        norm_p = np.linalg.norm(p)\n        if norm_p == 0.0:\n            # The zero matrix is idempotent, its defect is 0.\n            return 0.0\n        \n        # Element-wise operation for p^2 - p\n        p_err = np.square(p) - p\n        norm_p_err = np.linalg.norm(p_err)\n        \n        return norm_p_err / norm_p\n\n    def compute_defects_for_case(c_vec: np.ndarray, n: int, tau: float, seed: int) - list[float]:\n        \"\"\"\n        Computes the triple of idempotency defects [naive, truncated, tikhonov]\n        for a given circulant generator vector 'c' and parameters.\n        \"\"\"\n        u = 2**-53\n        alpha = tau**2\n        rng = np.random.default_rng(seed)\n\n        # Ensure c_vec is the correct size and complex type\n        c_full = np.zeros(n, dtype=np.complex128)\n        c_full[:len(c_vec)] = c_vec\n        \n        # Compute spectrum lambda using unitary FFT\n        lambda_vec = np.fft.fft(c_full, norm=\"ortho\")\n        lambda_abs = np.abs(lambda_vec)\n\n        # --- 1. Naive reciprocal with amplified roundoff ---\n        xi = rng.standard_normal(n)\n        # The perturbation delta is real-valued, as per problem spec (real xi_k)\n        delta = xi * u * tau / np.maximum(lambda_abs, 1e-300)\n        \n        mu_tilde = np.zeros_like(lambda_vec)\n        \n        # Handle non-zero and zero lambda_k as per the definition\n        nonzero_mask = lambda_vec != 0\n        mu_tilde[nonzero_mask] = (1.0 / lambda_vec[nonzero_mask]) * (1.0 + delta[nonzero_mask])\n        \n        p_naive = mu_tilde * lambda_vec\n        defect_naive = calculate_defect(p_naive)\n\n        # --- 2. Truncated spectral pseudoinverse (hard thresholding) ---\n        mu_trunc = np.zeros_like(lambda_vec)\n        strong_mask = lambda_abs >= tau\n        mu_trunc[strong_mask] = 1.0 / lambda_vec[strong_mask]\n        \n        p_trunc = mu_trunc * lambda_vec\n        defect_trunc = calculate_defect(p_trunc)\n\n        # --- 3. Tikhonov-type smoothing ---\n        lambda_abs_sq = np.square(lambda_abs)\n        p_tikh = lambda_abs_sq / (lambda_abs_sq + alpha)\n        defect_tikh = calculate_defect(p_tikh)\n\n        return [defect_naive, defect_trunc, defect_tikh]\n\n    # Definition of test cases from the problem statement\n    test_cases = [\n        { # Case A: exact zero mode\n            \"n\": 8,\n            \"c\": np.array([2.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]),\n            \"tau\": 1e-8,\n            \"seed\": 0\n        },\n        { # Case B: near-zero mode at frequency 0\n            \"n\": 12,\n            \"c\": np.array([1.0, -(1.0 - 1e-12)]),\n            \"tau\": 1e-8,\n            \"seed\": 1\n        },\n        { # Case C: discrete second-difference with many small frequencies\n            \"n\": 4096,\n            \"c\": np.array([1.0, -2.0, 1.0]),\n            \"tau\": 1e-5,\n            \"seed\": 2\n        },\n        { # Case D: well-conditioned identity circulant\n            \"n\": 5,\n            \"c\": np.array([1.0]),\n            \"tau\": 1e-8,\n            \"seed\": 3\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_triple = compute_defects_for_case(case[\"c\"], case[\"n\"], case[\"tau\"], case[\"seed\"])\n        all_results.append(result_triple)\n\n    # Format the final output string exactly as required\n    # Creates a list of strings like '[-1.2, 3.4, -5.6]'\n    inner_lists_str = [str(res) for res in all_results] \n    # Joins them with commas and wraps in brackets\n    output_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    # Replace spaces added by str() for a compact representation if needed, \n    # but the example implies spaces are acceptable. Let's match python's default `str` behavior.\n    print(output_str)\n\nsolve()\n```",
                "id": "3545340"
            }
        ]
    }