{
        "hands_on_practices": [
            {
                "introduction": "在评估一种算法时，第一步是理解其计算成本。本练习旨在通过量化和比较随机方法（基础版本和幂迭代版本）与经典确定性方法（Lanczos）的操作成本，来揭示随机奇异值分解（RSVD）算法的效率优势。通过推导浮点运算（flops）和数据访问次数，您将深入理解在处理大规模数据时，这些不同算法在计算资源上的权衡。 [@problem_id:3570685]",
                "problem": "考虑一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$、一个目标秩 $k \\ll \\min\\{m,n\\}$、一个过采样参数 $p \\geq 0$ 以及一个表示幂迭代次数的非负整数 $q$。定义构图大小 $\\ell = k + p$。目标是估计用于随机化奇异值分解 (SVD) 的两种随机化值域寻找过程的算法成本，并将这些成本与通过 Golub–Kahan–Lanczos 双对角化过程计算的确定性截断 SVD 进行比较。\n\n基本随机化值域寻找器通过抽取一个测试矩阵 $\\Omega \\in \\mathbb{R}^{n \\times \\ell}$，构造 $Y = A \\Omega$，并计算 $Y$ 的瘦 QR 分解（正交-三角分解），即 $Y = Q R$，其中 $Q^{\\top}Q = I_{\\ell}$，来为 $A$ 的近似值域构建一个标准正交基 $Q \\in \\mathbb{R}^{m \\times \\ell}$。其幂迭代变体通过一系列与 $A^{\\top}$ 和 $A$ 的交替乘法来构造 $Y = (A A^{\\top})^{q} A \\Omega$，从 $Y_{0} = A \\Omega$ 开始，对 $i = 1,2,\\dots,q$ 迭代 $Y_{i} = A \\big( A^{\\top} Y_{i-1} \\big)$，然后对最终的 $Y$ 进行瘦 QR 分解。\n\n对于确定性截断 SVD，考虑运行 $k$ 步的 Golub–Kahan–Lanczos 双对角化过程以获得前 $k$ 个奇异三元组，该过程在每一步中将向量分别与 $A$ 和 $A^{\\top}$ 相乘一次。\n\n采用以下运算计数模型作为成本推导的基本依据：\n- 将一个 $m \\times n$ 矩阵与一个 $n \\times r$ 矩阵相乘的成本为 $2 m n r$ 次浮点运算 (flops)。\n- 将一个 $n \\times m$ 矩阵与一个 $m \\times r$ 矩阵相乘的成本为 $2 m n r$ flops。\n- 对一个 $m \\times r$（其中 $m \\geq r$）矩阵进行瘦 Householder QR 分解（正交-三角分解）的成本为 $2 m r^{2} - \\tfrac{2}{3} r^{3}$ flops。\n- 对 $A$ 的单次遍历定义为与任何操作数（矩阵或向量）进行一次完整的 $A$ 或 $A^{\\top}$ 乘法；换言之，$A$ 的每次应用和 $A^{\\top}$ 的每次应用都计为一次遍历。\n\n在此模型下，推导出以下各项的符号表达式：\n1. 基本随机化值域寻找器所需的总浮点运算次数和对 $A$ 的遍历次数（一次乘法 $Y = A \\Omega$ 后跟一次 $Y$ 的瘦 QR 分解）。\n2. 幂迭代变体所需的总浮点运算次数和对 $A$ 的遍历次数（如上所述的 $q$ 次幂迭代，后跟一次 $Y$ 的瘦 QR 分解）。\n3. 通过运行 $k$ 步的 Golub–Kahan–Lanczos 双对角化实现的确定性截断 SVD 所需的总浮点运算次数和对 $A$ 的遍历次数。\n\n将每个成本精确地用 $m$、$n$、$k$、$p$ 和 $q$（其中 $\\ell = k + p$）表示。仅关注上述模型中指定的主要运算；忽略随机矩阵生成、与所述步骤无关的小规模稠密矩阵分解，以及确定性方法中除所述矩阵-向量乘法外的任何再正交化开销。无需进行舍入。将你的最终答案以一个单行矩阵的形式给出，该矩阵包含六个条目，顺序为：\n$(\\text{flops}_{\\text{basic}}, \\text{passes}_{\\text{basic}}, \\text{flops}_{\\text{power}}, \\text{passes}_{\\text{power}}, \\text{flops}_{\\text{Lanczos}}, \\text{passes}_{\\text{Lanczos}})$。",
                "solution": "问题陈述已解析和验证。所有需要的数据、定义和成本模型都已明确提供。该问题在数值线性代数领域有其科学依据，特别是关于矩阵分解的随机化算法。问题是适定的、客观的且内部一致的。未发现任何缺陷。因此，将推导出一个解决方案。\n\n任务是根据提供的成本模型，确定三种不同算法的浮点运算 (flop) 次数和对矩阵 $A$ 的遍历次数。设 $A \\in \\mathbb{R}^{m \\times n}$，目标秩为 $k$，过采样参数为 $p$，构图大小为 $\\ell = k + p$。幂迭代次数为 $q$。\n\n成本模型如下：\n- $m \\times n$ 矩阵与 $n \\times r$ 矩阵的矩阵乘法成本为 $2mnr$ flops。\n- $m \\times r$ 矩阵（$m \\geq r$）的瘦 Householder QR 分解成本为 $2mr^2 - \\frac{2}{3}r^3$ flops。\n- 对 $A$ 的一次遍历是与 $A$ 或 $A^\\top$ 的一次乘法。\n\n1. **基本随机化值域寻找器**\n该过程包括两个阶段：\na) 构造构图矩阵 $Y = A \\Omega$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $\\Omega \\in \\mathbb{R}^{n \\times \\ell}$。\nb) 计算 $Y \\in \\mathbb{R}^{m \\times \\ell}$ 的瘦 QR 分解。\n\na) 构造 $Y = A \\Omega$ 的成本是一个 $m \\times n$ 矩阵与一个 $n \\times \\ell$ 矩阵的矩阵-矩阵乘法。根据模型，当 $r = \\ell$ 时，成本为：\n$$ \\text{flops}(A\\Omega) = 2mn\\ell $$\n此步骤涉及一次与 $A$ 的乘法，构成对 $A$ 的 $1$ 次遍历。\n\nb) 计算 $Y \\in \\mathbb{R}^{m \\times \\ell}$ 的瘦 QR 分解的成本由模型给出，其中 $r = \\ell$：\n$$ \\text{flops}(QR(Y)) = 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n此步骤不涉及矩阵 $A$。\n\n总浮点运算次数是这些成本的总和。代入 $\\ell = k+p$：\n$$ \\text{flops}_{\\text{basic}} = 2mn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 = 2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 $$\n总遍历次数为：\n$$ \\text{passes}_{\\text{basic}} = 1 $$\n\n2. **幂迭代随机化值域寻找器**\n此过程涉及三个阶段：\na) 构造初始构图矩阵 $Y_0 = A \\Omega$。\nb) 执行 $q$ 次幂迭代：$Y_i = A (A^{\\top} Y_{i-1})$，其中 $i = 1, \\dots, q$。\nc) 计算最终矩阵 $Y = Y_q$ 的瘦 QR 分解。\n\na) 构造 $Y_0 = A \\Omega$ 的成本与基本方法的第一步相同：\n$$ \\text{flops}(Y_0) = 2mn\\ell $$\n此步骤使用对 $A$ 的 $1$ 次遍历。\n\nb) $q$ 次幂迭代中的每一次都涉及两次矩阵-矩阵乘法：\n- 首先，构造 $Z_i = A^{\\top} Y_{i-1}$，其中 $A^{\\top} \\in \\mathbb{R}^{n \\times m}$ 且 $Y_{i-1} \\in \\mathbb{R}^{m \\times \\ell}$。根据模型，成本为 $2nm\\ell$ flops。这是对 $A$ 的 $1$ 次遍历（通过 $A^\\top$）。\n- 其次，构造 $Y_i = A Z_i$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $Z_i \\in \\mathbb{R}^{n \\times \\ell}$。成本为 $2mn\\ell$ flops。这是对 $A$ 的另一次遍历。\n一次幂迭代的总成本为 $2nm\\ell + 2mn\\ell = 4mn\\ell$ flops，需要对 $A$ 进行 $2$ 次遍历。\n对于 $q$ 次迭代，总成本和遍历次数为：\n$$ \\text{flops}(\\text{power iterations}) = q \\cdot (4mn\\ell) = 4qmn\\ell $$\n$$ \\text{passes}(\\text{power iterations}) = 2q $$\n\nc) 最终 $Y_q \\in \\mathbb{R}^{m \\times \\ell}$ 的 QR 分解成本与基本方法中的相同：\n$$ \\text{flops}(QR(Y_q)) = 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n\n总浮点运算次数是所有三个阶段成本的总和。代入 $\\ell = k+p$：\n$$ \\text{flops}_{\\text{power}} = 2mn\\ell + 4qmn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 = (2+4q)mn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n$$ \\text{flops}_{\\text{power}} = 2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 $$\n总遍历次数是阶段 (a) 和 (b) 遍历次数的总和：\n$$ \\text{passes}_{\\text{power}} = 1 + 2q $$\n\n3. **通过 Golub–Kahan–Lanczos 双对角化的确定性截断 SVD**\n该过程运行 $k$ 步。问题陈述指出，每一步都将向量分别与 $A$ 和 $A^{\\top}$ 相乘一次。根据指示，我们忽略任何其他成本。\n\n矩阵-向量乘法是矩阵-矩阵乘法的一个特例，其中一个矩阵只有一列 ($r=1$)。\n- 将 $A \\in \\mathbb{R}^{m \\times n}$ 与一个向量 $\\mathbf{v} \\in \\mathbb{R}^{n \\times 1}$ 相乘的成本为 $2mn(1) = 2mn$ flops。这是对 $A$ 的 $1$ 次遍历。\n- 将 $A^{\\top} \\in \\mathbb{R}^{n \\times m}$ 与一个向量 $\\mathbf{u} \\in \\mathbb{R}^{m \\times 1}$ 相乘的成本为 $2nm(1) = 2nm$ flops。这是对 $A$ 的 $1$ 次遍历（通过 $A^\\top$）。\n\n一步的总成本是这两个乘法之和：\n$$ \\text{flops}(\\text{1 step}) = 2mn + 2nm = 4mn $$\n一步的遍历次数是 $1 + 1 = 2$。\n\n对于 $k$ 步，总成本和遍历次数为：\n$$ \\text{flops}_{\\text{Lanczos}} = k \\cdot (4mn) = 4mnk $$\n$$ \\text{passes}_{\\text{Lanczos}} = k \\cdot 2 = 2k $$\n\n结果摘要：\n- 基本随机化值域寻找器：\n  - 浮点运算次数：$2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3$\n  - 遍历次数：$1$\n- 幂迭代变体：\n  - 浮点运算次数：$2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3$\n  - 遍历次数：$1+2q$\n- Lanczos 双对角化：\n  - 浮点运算次数：$4mnk$\n  - 遍历次数：$2k$\n\n这些结果将被汇总成一个单行矩阵作为最终答案。",
                "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 & 1 & 2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 & 1+2q & 4mnk & 2k\n\\end{pmatrix}\n}\n$$",
                "id": "3570685"
            },
            {
                "introduction": "在获得一个低秩近似之后，下一个关键问题是评估其精度。本练习介绍了一种实用的随机技术——高斯残差范数估计器——用于估计近似误差，并要求您分析其核心的统计特性。通过推导该估计器的偏差和方差，您将能判断其作为近似质量度量的可靠性，这是对随机算法进行质量控制的重要一步。 [@problem_id:3570736]",
                "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 是一个固定矩阵，并设 $Q \\in \\mathbb{R}^{m \\times k}$ 具有标准正交列，这些列由随机奇异值分解（SVD）算法中的随机化值域查找器获得。定义残差算子 $B \\in \\mathbb{R}^{m \\times n}$ 为 $B = (I_{m} - Q Q^{\\top}) A$，其中 $I_{m}$ 是 $m \\times m$ 的单位矩阵。考虑一个单探针高斯残差范数估计器，它通过抽取 $z \\sim \\mathcal{N}(0, I_{n})$ 并计算可观测量\n$$\n\\widehat{S} \\;=\\; \\|B z\\|_{2}^{2} \\;=\\; z^{\\top} B^{\\top} B z,\n$$\n来构造，在实践中用于近似残差大小 $\\|A - Q Q^{\\top} A\\|$。在本问题中，将 $\\widehat{S}$ 视为平方弗罗贝尼乌斯残差\n$$\nS \\;=\\; \\|B\\|_{F}^{2} \\;=\\; \\operatorname{tr}(B^{\\top} B).\n$$\n的估计量。从概率论和线性代数的第一性原理出发，即标准正态分布的各向同性、正交投影算子的性质以及高斯二次型的矩恒等式，推导以下各项的闭式表达式：\n- $\\widehat{S}$ 作为 $S$ 的估计量的偏差，即 $\\mathbb{E}[\\widehat{S}] - S$，以及\n- 方差 $\\operatorname{Var}(\\widehat{S})$，\n用 $B$ 的奇异值 $\\{\\sigma_{i}(B)\\}_{i=1}^{\\rho}$ 明确表示，其中 $\\rho = \\operatorname{rank}(B)$。你的最终答案必须是一个单一的解析表达式，以单个行矩阵的形式包含偏差和方差，并且仅用 $\\{\\sigma_{i}(B)\\}$ 表示。不需要数值近似。",
                "solution": "我们首先回顾一下背景设定。矩阵 $Q \\in \\mathbb{R}^{m \\times k}$ 具有标准正交列，因此 $Q^{\\top} Q = I_{k}$，并且矩阵 $I_{m} - Q Q^{\\top}$ 是到 $Q$ 的列空间的正交补空间上的正交投影算子。残差算子为 $B = (I_{m} - Q Q^{\\top}) A \\in \\mathbb{R}^{m \\times n}$。高斯探针为 $z \\sim \\mathcal{N}(0, I_{n})$，因此 $z$ 的均值为零，协方差为单位矩阵，即 $\\mathbb{E}[z] = 0$ 且 $\\mathbb{E}[z z^{\\top}] = I_{n}$。估计量为 $\\widehat{S} = \\|B z\\|_{2}^{2} = z^{\\top} B^{\\top} B z$。\n\n我们的目标是以闭式形式计算 $\\widehat{S}$ 作为 $S = \\|B\\|_{F}^{2} = \\operatorname{tr}(B^{\\top} B)$ 的估计量的偏差和方差。我们使用的核心概率工具是标准正态向量中二次型的恒等式。设 $M \\in \\mathbb{R}^{n \\times n}$ 是一个固定的对称矩阵，且 $z \\sim \\mathcal{N}(0, I_{n})$。那么以下事实成立：\n1. $\\mathbb{E}[z^{\\top} M z] = \\operatorname{tr}(M)$.\n2. $\\operatorname{Var}(z^{\\top} M z) = 2 \\|M\\|_{F}^{2} = 2 \\operatorname{tr}(M^{2})$.\n\n这些结论可由标准正态分布的各向同性以及关于高斯变量四阶矩的 Wick (Isserlis) 定理得出：\n$$\n\\mathbb{E}[z_{i} z_{j} z_{k} z_{l}] = \\delta_{i j} \\delta_{k l} + \\delta_{i k} \\delta_{j l} + \\delta_{i l} \\delta_{j k},\n$$\n其中 $\\delta_{i j}$ 是克罗内克（Kronecker）δ函数。\n\n我们将这些恒等式应用于 $M = B^{\\top} B$。注意到 $M$ 是对称半正定矩阵。那么\n$$\n\\widehat{S} = z^{\\top} M z.\n$$\n\n首先，计算期望：\n$$\n\\mathbb{E}[\\widehat{S}] = \\mathbb{E}[z^{\\top} M z] = \\operatorname{tr}(M) = \\operatorname{tr}(B^{\\top} B) = \\|B\\|_{F}^{2} = S.\n$$\n因此，偏差为\n$$\n\\mathbb{E}[\\widehat{S}] - S = 0.\n$$\n\n接下来，计算方差：\n$$\n\\operatorname{Var}(\\widehat{S}) = \\operatorname{Var}(z^{\\top} M z) = 2 \\operatorname{tr}(M^{2}) = 2 \\|M\\|_{F}^{2}.\n$$\n为了用 $B$ 的奇异值表示这个结果，回忆一下，如果 $\\{\\sigma_{i}(B)\\}_{i=1}^{\\rho}$ 是 $B$ 的非零奇异值，那么 $M = B^{\\top} B$ 的特征值是 $\\{\\sigma_{i}(B)^{2}\\}_{i=1}^{\\rho}$ 以及一些零。因此，\n$$\n\\operatorname{tr}(M) = \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{2}, \\quad \\operatorname{tr}(M^{2}) = \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}.\n$$\n所以，\n$$\n\\operatorname{Var}(\\widehat{S}) = 2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}.\n$$\n\n总之，对于平方残差范数的单探针高斯估计器，\n$$\n\\widehat{S} = \\|(I_{m} - Q Q^{\\top}) A z\\|_{2}^{2},\n$$\n其偏差等于零，方差等于 $2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}$，其中 $B = (I_{m} - Q Q^{\\top}) A$，$\\{\\sigma_{i}(B)\\}$ 是其奇异值。这些恒等式是精确的，它们源于高斯二次型和奇异值分解（SVD）的基本性质。",
                "answer": "$$\\boxed{\\begin{pmatrix} 0 & 2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4} \\end{pmatrix}}$$",
                "id": "3570736"
            },
            {
                "introduction": "这个练习将理论与实践相结合，模拟了在有限内存预算下实现随机奇异值分解（RSVD）的真实场景。它要求您综合运用算法流程、理论误差界和内存占用的知识，设计一个既能满足精度要求又符合硬件限制的块处理策略。解决这个问题能锻炼您在面对实际工程约束时，优化和配置复杂数值算法的关键能力。 [@problem_id:3570738]",
                "problem": "考虑一种随机奇异值分解（RSVD）的分块实现，其目标是通过构造一个标准正交基 $Q \\in \\mathbb{R}^{m \\times r}$（其中 $r = k + p$，$p$ 是一个过采样参数）来近似一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的前 $k$ 个主要奇异分量。给定所有内存中的数组的内存预算为 $B$ 个机器字。假设存在以下算法结构和实现约束，您在推理中必须使用这些约束：\n\n- 使用一个高斯测试矩阵 $\\Omega \\in \\mathbb{R}^{n \\times r}$ 来构建样本矩阵 $Y = A \\Omega$。为了遵守内存预算，$A$ 以大小为 $s$ 的列分块形式被访问，并应用 $\\Omega$ 的相应分块，从而在对 $A$ 的列进行单次遍历时，在内存中累积生成 $Y$。\n- 使用一个数值稳定的标准正交化程序将矩阵 $Y \\in \\mathbb{R}^{m \\times r}$ 标准正交化以产生 $Q \\in \\mathbb{R}^{m \\times r}$（您可以假设该程序需要一个 $O(r^{2})$ 的内存临时存储空间，在您的内存计算中明确地将其视为一个 $r \\times r$ 的数组）。\n- 算法不显式地生成 $B = Q^{\\mathsf{T}} A \\in \\mathbb{R}^{r \\times n}$，而是通过再次以相同大小 $s$ 的列分块流式处理 $A$ 来形成 $r \\times r$ 的协方差矩阵 $F = Q^{\\mathsf{T}} A A^{\\mathsf{T}} Q$，对每个分块 $A_{j} \\in \\mathbb{R}^{m \\times s}$ 累积 $F \\leftarrow F + (Q^{\\mathsf{T}} A_{j})(Q^{\\mathsf{T}} A_{j})^{\\mathsf{T}}$。这避免了将 $B$ 或整个 $A$ 存储在内存中。\n- 您必须确保期望谱范数误差控制在 $\\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq (1 + \\epsilon)\\, \\sigma_{k+1}$ 的形式内，其中 $\\sigma_{k+1}$ 表示 $A$ 的第 $(k+1)$ 个奇异值。这需要使用标准 RSVD 幂方法中的 $q \\geq 0$ 次幂迭代和一个高斯测试矩阵。您可以假设允许过采样 $p \\geq 4$，并且高斯草图和幂迭代的经过充分检验的期望界是适用的。\n\n任务：\n- 从所涉及矩阵、分块矩阵乘积和标准正交化的核心定义出发，推导此分块 RSVD 流水线主要步骤的精确内存占用（以机器字为单位），并将其表示为 $m$、$n$、$k$、$p$ 和块大小 $s$ 的函数。明确说明在每个步骤中必须同时驻留在内存中的所有数组，以便论证一个单一的上界表达式 $M(s)$，该表达式能安全地覆盖整个算法的内存使用。\n- 使用带有 $q$ 次幂迭代的高斯 RSVD 的经过充分检验的误差界，推导出一个关于过采样 $p$ 的充分闭式不等式（用 $k$、$q$ 和 $\\epsilon$ 表示），以保证所陈述的误差目标。将此不等式转换为关于 $p$ 的一个显式闭式下界。\n- 结合内存占用和过采样要求，得出一个单一的、闭式的解析表达式，用于表示满足内存预算 $B$ 并达到误差目标的最大允许整数块大小 $s^{\\star}$。您的设计必须强制 $s^{\\star} \\leq n$ 和 $s^{\\star} \\geq 0$。\n\n请以单个闭式数学表达式的形式提供 $s^{\\star}$ 的最终答案，该表达式用 $m$、$n$、$k$、$\\epsilon$、$q$ 和 $B$ 表示。不要包含任何数值计算。最终表达式中不要包含任何单位。如果您必须使用任何非初等函数或整值算子，请在推导中隐式定义它们，但最终公式仅使用标准数学符号表示，如 $\\lfloor \\cdot \\rfloor$、$\\lceil \\cdot \\rceil$、$\\min$ 和 $\\max$。",
                "solution": "该问题是有效的，因为它科学地基于数值线性代数的原理，特别是随机算法，并且问题设定良好、客观，且包含足够的信息以得出唯一解。\n\n解决方案的推导分为三个部分：首先，确定所述算法的内存占用；其次，从给定的误差界推导出对过采样参数 $p$ 的要求；第三，结合这两个结果来找到最大允许块大小 $s^{\\star}$。\n\n**第一部分：内存占用的推导**\n\n总内存占用是算法执行过程中任意时刻所需的最大内存。该算法包括对矩阵 $A$ 的两次主要遍历。我们分析每次遍历的内存需求。草图大小为 $r = k+p$。\n\n第一次遍历：生成标准正交基 $Q$。\n此阶段计算 $Y = (A A^{\\mathsf{T}})^q A \\Omega$，然后将 $Y$ 标准正交化得到 $Q$。\n\n情况 $q=0$：样本矩阵为 $Y = A \\Omega$。计算是分块进行的：$Y = \\sum_j A_j \\Omega_j$。在此求和的每一步，内存必须容纳累加器 $Y \\in \\mathbb{R}^{m \\times r}$、当前矩阵块 $A_j \\in \\mathbb{R}^{m \\times s}$ 以及相应的测试矩阵块 $\\Omega_j \\in \\mathbb{R}^{s \\times r}$。所需内存为 $m r + m s + s r$。\n\n情况 $q \\geq 1$：样本矩阵为 $Y = (A A^{\\mathsf{T}})^q A \\Omega$。这是迭代计算的。设 $Y_{(0)} = A\\Omega$。此初始步骤的内存为 $m r + m s + s r$。然后，对于 $i=1, \\dots, q$，我们计算 $Y_{(i)} = A A^{\\mathsf{T}} Y_{(i-1)}$。这是以分块方式执行的，$Y_{(i)} = \\sum_j A_j (A_j^{\\mathsf{T}} Y_{(i-1)})$。要执行此求和中的一个更新步骤，我们需要在内存中保留：\n1. 上一次迭代的输入向量 $Y_{(i-1)} \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n2. 当前迭代输出的累加器 $Y_{(i)} \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n3. 矩阵的当前分块 $A_j \\in \\mathbb{R}^{m \\times s}$（大小为 $m s$）。\n4. 中间乘积 $A_j^{\\mathsf{T}} Y_{(i-1)} \\in \\mathbb{R}^{s \\times r}$（大小为 $s r$）。\n因此，幂迭代步骤中的峰值内存使用量为 $m s + 2 m r + s r$。这大于初始采样步骤的内存。因此，对于 $q \\ge 1$，采样的峰值内存为 $m s + 2 m r + s r$。\n\n我们可以将任意 $q \\geq 0$ 的采样内存需求表示为 $M_{samp}(s) = m s + s r + (1 + \\min(1, q)) m r$。\n\n计算出最终样本矩阵 $Y$ 后，将其标准正交化为 $Q \\in \\mathbb{R}^{m \\times r}$。此步骤需要矩阵 $Y$（大小为 $m r$）和一个大小为 $r \\times r$ 的内存临时存储空间。标准正交化的内存为 $M_{ortho} = m r + r^2$。\n\n第一次遍历的总内存是采样和标准正交化阶段的最大值：$M_{pass1}(s) = \\max(M_{samp}(s), M_{ortho}) = \\max(m s + s r + (1 + \\min(1, q)) m r, m r + r^2)$。\n\n第二次遍历：构建协方差矩阵 $F$。\n此次遍历通过累积分块更新来计算 $F = Q^{\\mathsf{T}} A A^{\\mathsf{T}} Q$：$F \\leftarrow F + (Q^{\\mathsf{T}} A_j)(Q^{\\mathsf{T}} A_j)^{\\mathsf{T}}$。在每一步，内存必须容纳：\n1. 标准正交基 $Q \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n2. 当前矩阵块 $A_j \\in \\mathbb{R}^{m \\times s}$（大小为 $m s$）。\n3. $F \\in \\mathbb{R}^{r \\times r}$ 的累加器（大小为 $r^2$）。\n4. 中间乘积 $Q^{\\mathsf{T}} A_j \\in \\mathbb{R}^{r \\times s}$（大小为 $r s$）。\n此次遍历的总内存为 $M_{pass2}(s) = m r + m s + r^2 + r s$。\n\n总内存占用 $M(s)$：\n整个算法的峰值内存为 $M(s) = \\max(M_{pass1}(s), M_{pass2}(s))$。\n$M(s) = \\max(\\max(m s + s r + (1 + \\min(1, q)) m r, m r + r^2), m r + m s + r^2 + r s)$。\n由于 $m r + m s + r^2 + r s = (m r + r^2) + s(m+r)$，第二次遍历的项严格大于标准正交化内存 $m r + r^2$（对于 $s > 0$）。\n因此，表达式简化为：\n$M(s) = \\max(m s + s r + (1 + \\min(1, q)) m r, m s + s r + m r + r^2)$。\n通过提取公因式，可以重写为：\n$M(s) = m s + s r + \\max((1 + \\min(1, q)) m r, m r + r^2)$。\n$M(s) = s(m+r) + m r + \\max(\\min(1, q) m r, r^2)$。\n\n**第二部分：过采样参数解析表达式的推导**\n\n问题要求误差界的形式为 $\\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq (1 + \\epsilon)\\, \\sigma_{k+1}$。对于带 $q$ 次幂迭代和高斯测试矩阵的 RSVD，标准的理论结果提供了一个界，在有足够谱隙的假设下（使得尾部项可忽略不计），该界可表示为：\n$$ \\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq \\left(1 + \\sqrt{\\frac{k}{p-1}}\\right)^{\\frac{1}{2q+1}} \\sigma_{k+1} $$\n为满足问题要求，我们必须有：\n$$ \\left(1 + \\sqrt{\\frac{k}{p-1}}\\right)^{\\frac{1}{2q+1}} \\leq 1 + \\epsilon $$\n将两边都取 $(2q+1)$ 次方，得到：\n$$ 1 + \\sqrt{\\frac{k}{p-1}} \\leq (1+\\epsilon)^{2q+1} $$\n$$ \\sqrt{\\frac{k}{p-1}} \\leq (1+\\epsilon)^{2q+1} - 1 $$\n将两边平方（注意当 $\\epsilon \\ge 0$ 时两边均为非负）：\n$$ \\frac{k}{p-1} \\leq \\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2 $$\n$$ p-1 \\geq \\frac{k}{\\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2} $$\n$$ p \\geq 1 + \\frac{k}{\\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2} $$\n由于 $p$ 必须是整数，且问题说明允许 $p \\geq 4$，因此 $p$ 的最小充分整数值（我们记为 $p^{\\star}$）是：\n$$ p^{\\star} = \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right) $$\n\n**第三部分：最大允许块大小的推导**\n\n我们将前面部分的结果结合起来。总内存占用 $M(s)$ 不得超过预算 $B$。我们使用最小的充分草图大小 $r^{\\star} = k+p^{\\star}$。\n$$ s(m+r^{\\star}) + m r^{\\star} + \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2) \\leq B $$\n解出 $s$：\n$$ s(m+r^{\\star}) \\leq B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2) $$\n$$ s \\leq \\frac{B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2)}{m+r^{\\star}} $$\n块大小 $s$ 必须是整数，且受 $0 \\leq s \\leq n$ 约束。因此，最大允许整数块大小 $s^{\\star}$ 是上述表达式向下取整，并以 $n$ 为上限、以 $0$ 为下限的结果。\n$$ s^{\\star} = \\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2)}{m+r^{\\star}} \\right\\rfloor\\right)\\right) $$\n将 $r^{\\star} = k+p^{\\star}$ 和 $p^{\\star}$ 的完整表达式代入，得到以给定参数表示的 $s^{\\star}$ 的最终闭式表达式。\n令 $P_0 = \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)$。\n则 $r^{\\star} = k + P_0$。\n$s^{\\star}$ 的表达式变为：\n$$ s^{\\star} = \\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m(k+P_0) - \\max(\\min(1, q) m(k+P_0), (k+P_0)^2)}{m+k+P_0} \\right\\rfloor\\right)\\right) $$\n这个表达式将所有约束合并到了一个单一的公式中。",
                "answer": "$$ \\boxed{\\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m\\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right) - \\max\\left(\\min(1,q)m\\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right), \\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right)^2\\right)}{m + k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)} \\right\\rfloor\\right)\\right)} $$",
                "id": "3570738"
            }
        ]
    }