{
        "hands_on_practices": [
            {
                "introduction": "在数值计算中，任何算法的输出都可能对其输入数据的微小扰动敏感。本练习通过一阶微扰分析，为Cholesky分解（$A \\mapsto L$）这一映射引入了分量级条件数的概念，旨在量化其敏感性。通过计算一个具体$2 \\times 2$矩阵的条件数，我们将揭示Cholesky因子的哪些部分对原始矩阵中的扰动最为敏感，从而加深对误差传播机制的理解。[@problem_id:3568076]",
                "problem": "考虑一个实对称正定 (SPD) 矩阵的 Cholesky 分解，由等式 $A = L L^{\\top}$ 定义，其中 $L$ 是一个对角线元素为正的下三角矩阵。设 $A \\in \\mathbb{R}^{2 \\times 2}$ 为 SPD 矩阵\n$$\nA = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix},\n$$\n并设 $L$ 表示其 Cholesky 因子。对于一个微小的对称扰动 $\\delta A$，通过 Cholesky 映射在 $A$ 处的 Fréchet 导数定义相应的一阶扰动 $\\delta L$。在标准的逐元素最大范数 $\\| \\cdot \\|_{\\max}$ (定义为 $\\|M\\|_{\\max} = \\max_{i,j} |m_{ij}|$) 下进行计算，并设扰动域为由其独立元素参数化的对称矩阵空间。\n\n从基本原理（定义关系 $A = L L^{\\top}$ 和一阶扰动分析）出发，推导连接 $\\delta A$ 和 $\\delta L$ 的线性化关系，并用它来为给定 $A$ 处的 Cholesky 映射 $A \\mapsto L$ 构造一个分量形式的条件数，定义为\n$$\n\\kappa_{\\max}(A) = \\sup_{\\delta A \\neq 0} \\frac{\\|\\delta L\\|_{\\max}}{\\|\\delta A\\|_{\\max}}\n$$\n在一阶上。精确计算给定 $A$ 的 $\\kappa_{\\max}(A)$，并确定当 $\\|\\delta A\\|_{\\max} = 1$ 时，$\\delta A$ 的哪些元素使该界达到等号，从而评估特定元素的紧致性和敏感度。你的最终答案必须是 $\\kappa_{\\max}(A)$ 的唯一精确值，不需要四舍五入。",
                "solution": "用户希望找到给定 $2 \\times 2$ 实对称正定 (SPD) 矩阵的 Cholesky 分解的分量形式条件数。\n\n### 步骤 1：对 A 的验证和 Cholesky 分解\n\n给定矩阵为 $A = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix}$。\n首先，我们验证 $A$ 是对称正定的。$A$ 显然是对称的。其顺序主子式为 $\\det(A_1) = 4 > 0$ 和 $\\det(A_2) = \\det(A) = 4 \\times 3 - 1 \\times 1 = 11 > 0$。由于所有顺序主子式均为正，因此 $A$ 是 SPD 矩阵，其 Cholesky 分解存在且唯一。\n\nCholesky 分解为 $A = L L^{\\top}$，其中 $L$ 是一个对角线元素为正的下三角矩阵。设 $L = \\begin{pmatrix} l_{11}  0 \\\\ l_{21}  l_{22} \\end{pmatrix}$。\n则 $A = L L^{\\top}$ 展开为：\n$$\n\\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix} = \\begin{pmatrix} l_{11}  0 \\\\ l_{21}  l_{22} \\end{pmatrix} \\begin{pmatrix} l_{11}  l_{21} \\\\ 0  l_{22} \\end{pmatrix} = \\begin{pmatrix} l_{11}^2  l_{11}l_{21} \\\\ l_{11}l_{21}  l_{21}^2 + l_{22}^2 \\end{pmatrix}\n$$\n通过令矩阵元素相等，我们求解 $L$ 的分量：\n$l_{11}^2 = 4 \\implies l_{11} = 2$ (因为 $l_{11} > 0$)。\n$l_{11}l_{21} = 1 \\implies 2l_{21} = 1 \\implies l_{21} = \\frac{1}{2}$。\n$l_{21}^2 + l_{22}^2 = 3 \\implies \\left(\\frac{1}{2}\\right)^2 + l_{22}^2 = 3 \\implies \\frac{1}{4} + l_{22}^2 = 3 \\implies l_{22}^2 = 3 - \\frac{1}{4} = \\frac{11}{4}$。\n因为 $l_{22} > 0$，我们有 $l_{22} = \\frac{\\sqrt{11}}{2}$。\n因此，Cholesky 因子为 $L = \\begin{pmatrix} 2  0 \\\\ \\frac{1}{2}  \\frac{\\sqrt{11}}{2} \\end{pmatrix}$。\n\n### 步骤 2：线性化扰动方程的推导\n\n我们从定义关系 $A = L L^{\\top}$ 开始，并考虑一阶扰动。设 $A$ 被一个对称矩阵 $\\delta A$ 扰动，$L$ 中对应的扰动为 $\\delta L$。\n$$\nA + \\delta A = (L + \\delta L)(L + \\delta L)^{\\top} = (L + \\delta L)(L^{\\top} + \\delta L^{\\top}) = L L^{\\top} + L \\delta L^{\\top} + \\delta L L^{\\top} + \\delta L \\delta L^{\\top}\n$$\n减去 $A = L L^{\\top}$ 并只保留一阶项，得到线性化关系：\n$$\n\\delta A = L \\delta L^{\\top} + \\delta L L^{\\top}\n$$\n由于 $L$ 是下三角矩阵，$\\delta L$ 也必须是下三角矩阵（$L$ 的零元素不能被扰动）。设 $\\delta A = \\begin{pmatrix} s_{11}  s_{12} \\\\ s_{12}  s_{22} \\end{pmatrix}$ 和 $\\delta L = \\begin{pmatrix} x_{11}  0 \\\\ x_{21}  x_{22} \\end{pmatrix}$。\n将 $L$、$\\delta L$ 和 $\\delta A$ 的表达式代入扰动方程：\n$$\n\\begin{pmatrix} s_{11}  s_{12} \\\\ s_{12}  s_{22} \\end{pmatrix} = \\begin{pmatrix} 2  0 \\\\ \\frac{1}{2}  \\frac{\\sqrt{11}}{2} \\end{pmatrix} \\begin{pmatrix} x_{11}  x_{21} \\\\ 0  x_{22} \\end{pmatrix} + \\begin{pmatrix} x_{11}  0 \\\\ x_{21}  x_{22} \\end{pmatrix} \\begin{pmatrix} 2  \\frac{1}{2} \\\\ 0  \\frac{\\sqrt{11}}{2} \\end{pmatrix}\n$$\n$$\n\\begin{pmatrix} s_{11}  s_{12} \\\\ s_{12}  s_{22} \\end{pmatrix} = \\begin{pmatrix} 2x_{11}  2x_{21} \\\\ \\frac{1}{2}x_{11}  \\frac{1}{2}x_{21} + \\frac{\\sqrt{11}}{2}x_{22} \\end{pmatrix} + \\begin{pmatrix} 2x_{11}  \\frac{1}{2}x_{11} \\\\ 2x_{21}  \\frac{1}{2}x_{21} + \\frac{\\sqrt{11}}{2}x_{22} \\end{pmatrix}\n$$\n$$\n\\begin{pmatrix} s_{11}  s_{12} \\\\ s_{12}  s_{22} \\end{pmatrix} = \\begin{pmatrix} 4x_{11}  \\frac{1}{2}x_{11} + 2x_{21} \\\\ \\frac{1}{2}x_{11} + 2x_{21}  x_{21} + \\sqrt{11}x_{22} \\end{pmatrix}\n$$\n这给出了一个线性方程组，将 $\\delta A$ 的独立元素 ($s_{11}, s_{12}, s_{22}$) 与 $\\delta L$ 的独立元素 ($x_{11}, x_{21}, x_{22}$) 联系起来：\n1.  $s_{11} = 4x_{11}$\n2.  $s_{12} = \\frac{1}{2}x_{11} + 2x_{21}$\n3.  $s_{22} = x_{21} + \\sqrt{11}x_{22}$\n\n### 步骤 3：用 $\\delta A$ 表示 $\\delta L$ 求解\n\n我们求解该方程组以得到 $x_{11}$、$x_{21}$ 和 $x_{22}$：\n从方程 (1)：\n$$\nx_{11} = \\frac{1}{4}s_{11}\n$$\n将此代入方程 (2)：\n$s_{12} = \\frac{1}{2}\\left(\\frac{1}{4}s_{11}\\right) + 2x_{21} \\implies 2x_{21} = s_{12} - \\frac{1}{8}s_{11} \\implies x_{21} = \\frac{1}{2}s_{12} - \\frac{1}{16}s_{11}$。\n所以，\n$$\nx_{21} = -\\frac{1}{16}s_{11} + \\frac{1}{2}s_{12}\n$$\n将 $x_{21}$ 的这个表达式代入方程 (3)：\n$s_{22} = \\left(-\\frac{1}{16}s_{11} + \\frac{1}{2}s_{12}\\right) + \\sqrt{11}x_{22} \\implies \\sqrt{11}x_{22} = s_{22} + \\frac{1}{16}s_{11} - \\frac{1}{2}s_{12}$。\n所以，\n$$\nx_{22} = \\frac{1}{16\\sqrt{11}}s_{11} - \\frac{1}{2\\sqrt{11}}s_{12} + \\frac{1}{\\sqrt{11}}s_{22}\n$$\n\n### 步骤 4：计算条件数\n\n条件数 $\\kappa_{\\max}(A)$ 定义为 $\\sup_{\\delta A \\neq 0} \\frac{\\|\\delta L\\|_{\\max}}{\\|\\delta A\\|_{\\max}}$。设 $\\delta A$ 的独立元素向量为 $\\mathbf{s} = (s_{11}, s_{12}, s_{22})^{\\top}$，$\\delta L$ 的独立元素向量为 $\\mathbf{x} = (x_{11}, x_{21}, x_{22})^{\\top}$。线性关系为 $\\mathbf{x} = M \\mathbf{s}$，其中 $M$ 是雅可比矩阵：\n$$\nM = \\begin{pmatrix}\n\\frac{1}{4}  0  0 \\\\\n-\\frac{1}{16}  \\frac{1}{2}  0 \\\\\n\\frac{1}{16\\sqrt{11}}  -\\frac{1}{2\\sqrt{11}}  \\frac{1}{\\sqrt{11}}\n\\end{pmatrix}\n$$\n问题使用逐元素最大范数，这对应于向量 $\\mathbf{s}$ 和 $\\mathbf{x}$ 上的无穷范数。因此，条件数是诱导矩阵范数 $\\|M\\|_{\\infty \\to \\infty} = \\|M\\|_{\\infty}$，即 $M$ 的最大绝对行和。\n各行的绝对和为：\n第 1 行： $\\left|\\frac{1}{4}\\right| + |0| + |0| = \\frac{1}{4}$。\n第 2 行： $\\left|-\\frac{1}{16}\\right| + \\left|\\frac{1}{2}\\right| + |0| = \\frac{1}{16} + \\frac{8}{16} = \\frac{9}{16}$。\n第 3 行： $\\left|\\frac{1}{16\\sqrt{11}}\\right| + \\left|-\\frac{1}{2\\sqrt{11}}\\right| + \\left|\\frac{1}{\\sqrt{11}}\\right| = \\frac{1}{16\\sqrt{11}} + \\frac{8}{16\\sqrt{11}} + \\frac{16}{16\\sqrt{11}} = \\frac{1+8+16}{16\\sqrt{11}} = \\frac{25}{16\\sqrt{11}}$。\n\n我们必须找出这三个值中的最大值：$\\frac{1}{4}$、$\\frac{9}{16}$ 和 $\\frac{25}{16\\sqrt{11}}$。\n$\\frac{1}{4} = \\frac{4}{16}$，它小于 $\\frac{9}{16}$。\n现在我们比较 $\\frac{9}{16}$ 和 $\\frac{25}{16\\sqrt{11}}$。这等价于比较 $9$ 和 $\\frac{25}{\\sqrt{11}}$。\n由于两个量都为正，我们可以比较它们的平方：\n$9^2 = 81$。\n$\\left(\\frac{25}{\\sqrt{11}}\\right)^2 = \\frac{625}{11} \\approx 56.8$。\n因为 $81 > \\frac{625}{11}$，所以我们有 $9 > \\frac{25}{\\sqrt{11}}$，因此 $\\frac{9}{16} > \\frac{25}{16\\sqrt{11}}$。\n\n最大绝对行和是 $\\frac{9}{16}$。\n因此，条件数是 $\\kappa_{\\max}(A) = \\|M\\|_{\\infty} = \\frac{9}{16}$。\n\n### 步骤 5：识别最敏感的扰动\n\n最大行和对应于 $M$ 的第二行，该行定义了扰动分量 $x_{21} = \\delta l_{21}$。这意味着 Cholesky 因子的元素 $l_{21}$ 对 $A$ 的扰动最敏感。当扰动 $\\delta A$ 使 $|\\delta l_{21}|$ 最大化时，上确界中的等号成立。\n$|x_{21}| = |-\\frac{1}{16}s_{11} + \\frac{1}{2}s_{12}|$。\n为了在 $\\|\\delta A\\|_{\\max} = \\max(|s_{11}|, |s_{12}|, |s_{22}|) = 1$ 的约束下最大化该值，我们选择 $|s_{11}|=1$ 和 $|s_{12}|=1$ 使得各项相加。例如，设 $s_{11}=-1$ 和 $s_{12}=1$。则\n$|x_{21}| = |(-\\frac{1}{16})(-1) + (\\frac{1}{2})(1)| = \\frac{1}{16} + \\frac{1}{2} = \\frac{9}{16}$。\n在这个选择下，我们必须验证这确实是 $|\\delta L|$ 的最大分量。\n$|x_{11}| = |\\frac{1}{4}s_{11}| = \\frac{1}{4}$。\n$|x_{22}| = |\\frac{1}{16\\sqrt{11}}s_{11} - \\frac{1}{2\\sqrt{11}}s_{12} + \\frac{1}{\\sqrt{11}}s_{22}| = |\\frac{-1}{16\\sqrt{11}} - \\frac{1}{2\\sqrt{11}} + \\frac{s_{22}}{\\sqrt{11}}| = \\frac{1}{\\sqrt{11}} |-\\frac{9}{16} + s_{22}|$。\n对于任意 $|s_{22}| \\le 1$，$|-\\frac{9}{16} + s_{22}|$ 的最大值在 $s_{22}=-1$ 处取得，得到 $|-\\frac{9}{16}-1| = \\frac{25}{16}$。所以在这种情况下 $|x_{22}|$ 的最大可能值为 $\\frac{25}{16\\sqrt{11}}$，我们已经证明它小于 $\\frac{9}{16}$。\n因此，任何具有独立元素 $(s_{11}, s_{12}, s_{22})$ 且满足 $s_{11} = \\mp 1$，$s_{12} = \\pm 1$，和 $|s_{22}| \\le 1$ 的扰动 $\\delta A$ 都将产生 $\\frac{\\|\\delta L\\|_{\\max}}{\\|\\delta A\\|_{\\max}} = \\frac{9/16}{1} = \\frac{9}{16}$。这证实了上确界是可以达到的，并且该值是精确的。\n\n分量形式条件数的最终结果是 $\\frac{9}{16}$。",
                "answer": "$$\\boxed{\\frac{9}{16}}$$",
                "id": "3568076"
            },
            {
                "introduction": "理论上适用于Cholesky分解的对称半正定矩阵，在有限精度的浮点运算中可能因舍入误差导致分解失败。本编码实践旨在解决这一稳健性问题，通过为矩阵添加一个微小的对角扰动$\\delta I$来保证分解的成功。您将需要推导保证数值稳定性的最小$\\delta$的理论界，并将其与通过数值实验找到的经验阈值进行比较，从而深入理解理论与计算实践之间的联系。[@problem_id:3568148]",
                "problem": "给定您的是实对称矩阵，这些矩阵是半正定（PSD）或接近半正定，因此在精确算术中，它们至少不是强不定的。在单位舍入误差（机器 epsilon）为 $\\varepsilon$ 的浮点运算中，即使矩阵是半正定的，标准的无主元 Cholesky 分解也可能因为舍入导致计算出的主元略微为负而失败。一个稳健的缓解此失败的方法是添加一个对角扰动，并对 $A + \\delta I$ 进行分解，其中 $\\delta \\ge 0$，$I$ 是单位矩阵。您的任务是设计这样一个扰动，并将理论推导的阈值与经验观察到的阈值进行比较。\n\n使用的基本原理：\n- 浮点运算满足标准模型 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\theta)$，其中对于每个基本算术运算 $\\circ$，都有 $|\\theta| \\le \\varepsilon$。\n- Cholesky 算法在以下意义上是后向稳定的：计算出的分解对应于 $A + \\Delta$ 的精确 Cholesky 分解，其中 $\\Delta$ 是一个对称矩阵，其谱范数受常数倍的 $n \\varepsilon \\lVert A \\rVert_2$ 限制，这里 $n$ 是矩阵维度，该常数不依赖于 $A$。\n\n问题要求：\n1. 仅从上述基本原理以及特征值和算子范数的定义出发，推导出一个关于 $\\delta$ 的充分条件，以保证 $A + \\delta I$ 的 Cholesky 分解在浮点运算中能够成功。您的推导必须用最小特征值 $\\lambda_{\\min}(A)$、谱范数 $\\lVert A \\rVert_2$、维度 $n$、机器 epsilon $\\varepsilon$ 以及与 Cholesky 后向误差界相关的适度绝对常数 $c_{\\text{chol}}$ 来表示满足您充分条件的最小 $\\delta$。除上述基本原理外，不要使用任何专门的公式。\n\n2. 使用您推导出的界，通过代入 $c_{\\text{chol}} = 5$ 和 $n = 3$ 来定义理论阈值 $\\delta_{\\text{th}}(A,\\varepsilon)$。\n\n3. 对于下面列出的每个测试矩阵 $A$，计算：\n   - 理论阈值 $\\delta_{\\text{th}}(A,\\varepsilon)$。\n   - 一个经验阈值 $\\delta_{\\text{emp}}(A,\\varepsilon)$，定义为使得标准的双精度 Cholesky 分解 $A + \\delta I$ 能够无误成功的最小 $\\delta \\ge 0$（在固定的绝对或相对容差范围内）。经验阈值必须通过一个确定性的搜索过程找到，该过程从 $\\delta = 0$ 开始，并仅在需要时增加 $\\delta$。\n\n4. 测试必须在双精度（IEEE $754$ binary64）下进行，并且 $\\varepsilon$ 必须从执行环境中获取。不涉及物理单位。\n\n5. 测试套件。使用以下对称矩阵（每个矩阵大小为 $3 \\times 3$），此处以精确十进制形式写出其元素：\n   - $$A_1 = \\begin{bmatrix}\n      1.0  0.999999999999  0.0 \\\\\n      0.999999999999  1.0  0.0 \\\\\n      0.0  0.0  1.0\\times 10^{-12}\n   \\end{bmatrix}$$\n   - $$A_2 = \\begin{bmatrix}\n      1.0  1.0  1.0 \\\\\n      1.0  1.0  1.0 \\\\\n      1.0  1.0  1.0\n   \\end{bmatrix}$$\n   - $$A_3 = \\begin{bmatrix}\n      1.0  0.0  0.0 \\\\\n      0.0  1.0\\times 10^{-8}  0.0 \\\\\n      0.0  0.0  -1.0\\times 10^{-14}\n   \\end{bmatrix}$$\n   - $$A_4 = \\begin{bmatrix}\n      1.0\\times 10^{-16}  0.0  0.0 \\\\\n      0.0  2.0\\times 10^{-16}  0.0 \\\\\n      0.0  0.0  3.0\\times 10^{-16}\n   \\end{bmatrix}$$\n\n6. 输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。对于每个 $A_i$，按此顺序输出 $\\delta_{\\text{th}}(A_i,\\varepsilon)$ 和 $\\delta_{\\text{emp}}(A_i,\\varepsilon)$ 对，并将所有测试用例的结果展平。具体来说，输出必须是以下形式\n   $[\\delta_{\\text{th}}(A_1,\\varepsilon),\\delta_{\\text{emp}}(A_1,\\varepsilon),\\delta_{\\text{th}}(A_2,\\varepsilon),\\delta_{\\text{emp}}(A_2,\\varepsilon),\\delta_{\\text{th}}(A_3,\\varepsilon),\\delta_{\\text{emp}}(A_3,\\varepsilon),\\delta_{\\text{th}}(A_4,\\varepsilon),\\delta_{\\text{emp}}(A_4,\\varepsilon)]$\n   其中每个条目都是使用语言原生格式的浮点数。\n\n澄清与约束：\n- 您必须使用对称特征值分解（即通过 $A$ 的特征值）来计算谱范数 $\\lVert A \\rVert_2$ 和最小特征值 $\\lambda_{\\min}(A)$。\n- 对于经验阈值，您必须实现一个确定性的搜索策略，该策略首先测试 $\\delta = 0$，然后单调增加 $\\delta$ 直至成功，最后进行细化以在合理的容差内逼近最小的 $\\delta$。您的方法必须对 $\\delta_{\\text{emp}}$ 极小的情况具有鲁棒性。\n- 程序必须是自包含的，并以上述指定的确切格式生成单行输出。",
                "solution": "此问题被评估为 **有效**。这是一个数值线性代数中的良构问题，其基础是浮点误差分析和矩阵理论的标准原理。所有必要的数据和定义都已提供，要求具体而客观。\n\n### 1. 理论阈值 $\\delta_{\\text{th}}$ 的推导\n\n实对称矩阵的 Cholesky 分解成功的充要条件是该矩阵是正定的。在浮点运算中，矩阵 $B$ 计算出的 Cholesky 因子 $\\hat{L}$ 是一个扰动后矩阵 $B+E$ 的精确因子，其中 $E$ 是一个表示后向误差的对称矩阵。问题提供了此误差谱范数的一个界：\n$$ \\|E\\|_2 \\le c_{\\text{chol}} n \\varepsilon \\|B\\|_2 $$\n其中 $n$ 是矩阵的维度，$\\varepsilon$ 是机器 epsilon，$c_{\\text{chol}}$ 是一个适度的常数。\n\n我们的目标是找到一个关于 $\\delta \\ge 0$ 的充分条件，使得 $B = A + \\delta I$ 的 Cholesky 分解能够成功。这意味着矩阵 $B+E = (A + \\delta I) + E$ 必须是正定的。一个矩阵是正定的当且仅当其所有特征值都严格为正。因此，我们要求 $\\lambda_{\\min}((A + \\delta I) + E) > 0$。\n\n使用 Weyl 不等式处理对称矩阵和的特征值，我们有：\n$$ \\lambda_{\\min}((A + \\delta I) + E) \\ge \\lambda_{\\min}(A + \\delta I) + \\lambda_{\\min}(E) $$\n对称矩阵 $E$ 的特征值都是实数。其谱范数为 $\\|E\\|_2 = \\max_i |\\lambda_i(E)|$。这意味着最小特征值 $\\lambda_{\\min}(E)$ 的下界是 $-\\|E\\|_2$。因此，$\\lambda_{\\min}((A + \\delta I) + E) > 0$ 的一个充分条件是：\n$$ \\lambda_{\\min}(A + \\delta I) - \\|E\\|_2 > 0 \\quad \\implies \\quad \\lambda_{\\min}(A + \\delta I) > \\|E\\|_2 $$\n$A + \\delta I$ 的特征值是 $\\lambda_i(A) + \\delta$。因此，$\\lambda_{\\min}(A + \\delta I) = \\lambda_{\\min}(A) + \\delta$。将此式以及 $E$ 的后向误差界（其中 $B = A + \\delta I$）代入不等式，我们得到：\n$$ \\lambda_{\\min}(A) + \\delta > c_{\\text{chol}} n \\varepsilon \\|A + \\delta I\\|_2 $$\n为了继续，我们需要用已知量来表示 $\\|A + \\delta I\\|_2$。对于对称矩阵，谱范数是其特征值绝对值的最大值。我们选择的 $\\delta$ 是为了使 $A+\\delta I$ 成为正定或至少是半正定的。对于一个半正定矩阵 $M$，$\\|M\\|_2 = \\lambda_{\\max}(M)$。假设我们选择的 $\\delta$ 足以使 $A+\\delta I$ 至少是半正定的（即 $\\lambda_{\\min}(A) + \\delta \\ge 0$），那么：\n$$ \\|A + \\delta I\\|_2 = \\lambda_{\\max}(A + \\delta I) = \\lambda_{\\max}(A) + \\delta $$\n对于问题中给出的接近半正定的矩阵，$\\lambda_{\\max}(A) = \\|A\\|_2$。用 $\\|A\\|_2$ 替换 $\\lambda_{\\max}(A)$ 得到：\n$$ \\|A + \\delta I\\|_2 = \\|A\\|_2 + \\delta $$\n不等式变为：\n$$ \\lambda_{\\min}(A) + \\delta > c_{\\text{chol}} n \\varepsilon (\\|A\\|_2 + \\delta) $$\n我们现在求解 $\\delta$：\n$$ \\lambda_{\\min}(A) + \\delta > c_{\\text{chol}} n \\varepsilon \\|A\\|_2 + c_{\\text{chol}} n \\varepsilon \\delta $$\n$$ \\delta (1 - c_{\\text{chol}} n \\varepsilon) > c_{\\text{chol}} n \\varepsilon \\|A\\|_2 - \\lambda_{\\min}(A) $$\n由于 $c_{\\text{chol}} n \\varepsilon \\ll 1$，项 $(1 - c_{\\text{chol}} n \\varepsilon)$ 是正的。因此，我们可以用它来除不等式两边而不改变不等号的方向：\n$$ \\delta > \\frac{c_{\\text{chol}} n \\varepsilon \\|A\\|_2 - \\lambda_{\\min}(A)}{1 - c_{\\text{chol}} n \\varepsilon} $$\n满足此充分条件的最小 $\\delta$ 是等式右侧的表达式。由于 $\\delta$ 必须为非负数，我们取该表达式与 $0$ 之间的最大值。\n\n问题指定 $c_{\\text{chol}} = 5$ 和 $n = 3$。因此，理论阈值 $\\delta_{\\text{th}}(A, \\varepsilon)$ 定义为：\n$$ \\delta_{\\text{th}}(A, \\varepsilon) = \\max\\left(0, \\frac{15 \\varepsilon \\|A\\|_2 - \\lambda_{\\min}(A)}{1 - 15 \\varepsilon}\\right) $$\n$\\lambda_{\\min}(A)$ 和 $\\|A\\|_2$ 的值由 $A$ 的特征值计算得出。\n\n### 2. 经验阈值 $\\delta_{\\text{emp}}$ 的计算方法\n\n经验阈值 $\\delta_{\\text{emp}}(A, \\varepsilon)$ 是使得 $A + \\delta I$ 的浮点 Cholesky 分解能够成功的最小非负值 $\\delta$。我们使用确定性的搜索过程来找到这个值：\n\n1.  **检查 $\\delta = 0$**：首先，尝试计算 $A$ 的 Cholesky 分解。如果成功，则 $\\delta_{\\text{emp}}(A, \\varepsilon) = 0$。\n\n2.  **寻找上界**：如果 $\\delta=0$ 时的分解失败，我们需要找到一个使分解成功的 $\\delta > 0$。我们从一个小的初始猜测值 $\\delta_{\\text{high}} = \\varepsilon \\cdot \\max(1, \\|A\\|_2)$ 开始，并重复将其加倍 ($\\delta_{\\text{high}} \\leftarrow 2\\delta_{\\text{high}}$)，直到 $A + \\delta_{\\text{high}} I$ 的分解成功。这个过程保证能找到 $\\delta_{\\text{emp}}$ 的一个上界。\n\n3.  **二分搜索**：一旦我们有了一个区间 $[\\delta_{\\text{low}}, \\delta_{\\text{high}}]$，其中在 $\\delta_{\\text{low}}$ 处的分解失败，而在 $\\delta_{\\text{high}}$ 处成功（初始时，$\\delta_{\\text{low}}$ 为 $0$ 或 $\\delta_{\\text{high}}/2$），我们使用二分法来细化估计。我们重复测试中点 $\\delta_{\\text{mid}} = (\\delta_{\\text{low}} + \\delta_{\\text{high}})/2$。如果分解成功，我们设置 $\\delta_{\\text{high}} = \\delta_{\\text{mid}}$；否则，我们设置 $\\delta_{\\text{low}} = \\delta_{\\text{mid}}$。这个过程会持续固定次数的迭代（$100$ 次），以收敛到一个非常接近真实阈值的值。最终的 $\\delta_{\\text{emp}}$ 是找到的能使测试通过的最小值，即最终的 $\\delta_{\\text{high}}$。\n\n这种指数搜索后跟二分法的组合既是确定性的也是高效的。所有的 Cholesky 分解尝试都被包裹在一个 try-except 块中，以捕获表示失败的 `numpy.linalg.LinAlgError`。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta_th(A, epsilon):\n    \"\"\"\n    Computes the theoretical threshold delta_th based on the derived formula.\n    \"\"\"\n    n = 3\n    c_chol = 5\n    \n    # For a symmetric matrix, eigenvalues are real. np.linalg.eigvalsh is efficient and stable.\n    eigvals = np.linalg.eigvalsh(A)\n    lambda_min = np.min(eigvals)\n    # The spectral norm of a symmetric matrix is the maximum absolute eigenvalue.\n    norm_A = np.max(np.abs(eigvals))\n    \n    cne = c_chol * n * epsilon\n    \n    # Formula derived in the solution part:\n    # delta > (c_chol * n * epsilon * ||A||_2 - lambda_min(A)) / (1 - c_chol * n * epsilon)\n    numerator = cne * norm_A - lambda_min\n    \n    # If numerator is non-positive, the original matrix is already \"sufficiently\" positive definite.\n    if numerator = 0:\n        return 0.0\n    \n    denominator = 1 - cne\n    \n    return numerator / denominator\n\ndef compute_delta_emp(A):\n    \"\"\"\n    Computes the empirical threshold delta_emp using a deterministic search.\n    \"\"\"\n    def check_cholesky(delta):\n        \"\"\"Helper function to test Cholesky factorization for A + delta*I.\"\"\"\n        try:\n            # Use a copy of A to avoid modifying the original test case matrix\n            A_pert = A + delta * np.identity(A.shape[0])\n            np.linalg.cholesky(A_pert)\n            return True\n        except np.linalg.LinAlgError:\n            return False\n\n    # 1. Check if delta = 0 works.\n    if check_cholesky(0.0):\n        return 0.0\n\n    # 2. Find an upper bound for delta where Cholesky succeeds.\n    # Start with a small guess related to machine epsilon and the matrix norm.\n    norm_A = np.linalg.norm(A, 2)\n    delta_high = np.finfo(float).eps * max(1.0, norm_A)\n    if delta_high == 0: # Case where A is the zero matrix\n        delta_high = np.finfo(float).eps\n\n    # Exponentially increase delta until we find a working value.\n    initial_guess = delta_high\n    while not check_cholesky(delta_high):\n        delta_high *= 2.0\n\n    # 3. Bisection search to refine the threshold.\n    # The lower bound is a value we know fails.\n    if delta_high == initial_guess:\n        delta_low = 0.0\n    else:\n        delta_low = delta_high / 2.0\n\n    # 100 iterations are more than sufficient for double precision convergence.\n    for _ in range(100):\n        delta_mid = delta_low + (delta_high - delta_low) / 2.0\n        # If we reach the limit of floating point precision, stop.\n        if delta_mid == delta_low or delta_mid == delta_high:\n            break\n        \n        if check_cholesky(delta_mid):\n            delta_high = delta_mid  # Midpoint works, try smaller values.\n        else:\n            delta_low = delta_mid   # Midpoint fails, need larger values.\n            \n    # Return the smallest value found that allows Cholesky to succeed.\n    return delta_high\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    # Get machine epsilon for double precision from the execution environment.\n    epsilon = np.finfo(float).eps\n    \n    # Define the test cases from the problem statement.\n    a12 = 0.999999999999\n    \n    test_cases = [\n        np.array([\n            [1.0, a12, 0.0],\n            [a12, 1.0, 0.0],\n            [0.0, 0.0, 1.0e-12]\n        ]),\n        np.array([\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0]\n        ]),\n        np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0e-8, 0.0],\n            [0.0, 0.0, -1.0e-14]\n        ]),\n        np.array([\n            [1.0e-16, 0.0, 0.0],\n            [0.0, 2.0e-16, 0.0],\n            [0.0, 0.0, 3.0e-16]\n        ]),\n    ]\n\n    results = []\n    for A in test_cases:\n        delta_th = compute_delta_th(A, epsilon)\n        delta_emp = compute_delta_emp(A)\n        results.extend([delta_th, delta_emp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
                "id": "3568148"
            },
            {
                "introduction": "在解决了基本的稳健性问题后，我们进一步探讨如何利用矩阵的特殊结构来优化算法。本练习将对比一个通用的密集Cholesky算法和一个专为带状矩阵设计的算法。通过理论推导和编码实现，您将验证带状结构在分解过程中得以保持，并观察到利用该结构不仅能大幅提升计算效率，还能通过避免带外噪声的传播来增强数值稳定性。[@problem_id:3568119]",
                "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 为一个对称正定 (SPD) 矩阵，其半带宽为 $k$，即当 $\\lvert i - j \\rvert  k$ 时 $a_{ij} = 0$。Cholesky 分解旨在寻找一个具有正对角元的下三角矩阵 $L$，使得 $A = L L^{\\mathsf{T}}$。考虑两种算法变体：\n- 一种考虑带宽的 Cholesky 算法，它将所有内积和更新限制在符合带状约束 $\\lvert i - j \\rvert \\le k$ 的索引范围内。\n- 一种稠密 Cholesky 算法，它执行经典的下三角分解，除了三角性之外，对索引范围没有任何限制。\n\n从以下基本基础出发：\n- 对称正定矩阵的定义：对于所有非零 $x \\in \\mathbb{R}^n$，$x^{\\mathsf{T}} A x  0$。\n- Cholesky 分解的定义：如果 $A$ 是对称正定矩阵，则存在一个唯一的具有正对角元的下三角矩阵 $L$，使得 $A = L L^{\\mathsf{T}}$。\n- 带状结构的定义：如果对于 $\\lvert i - j \\rvert  k$ 都有 $a_{ij} = 0$，则 $A$ 的半带宽为 $k$。\n- 浮点算术模型采用向最近舍入，单位舍入误差为 $u$，其中零可以被精确表示，且对于所有有限的 $x,y$，有 $0 \\cdot y = 0$ 和 $x + 0 = x$。\n\n推导在有限精度算术下，考虑带宽的算法能精确保持 $L$ 的带状结构的代数条件。推导过程必须解释为什么对于一个半带宽为 $k$ 的对称正定矩阵，其因子 $L$ 在精确算术中也具有半带宽 $k$，然后必须利用零的 IEEE 属性和向最近舍入的原则，得出结论：只要算法从不构建包含带外索引对的内积，那么在有限精度下，带外部分的零值就能被精确保持。然后，量化当输入矩阵在浮点噪声水平上存在轻微带外污染（即，对于 $\\lvert i - j \\rvert  k$ 有微小但非零的元素）时，在实践中产生的稳定性优势：解释为什么稠密算法会将此类污染纳入分解中，并可能在 $L$ 中产生带外元素，而一个强制执行结构性零的考虑带宽的算法可以避免传播这种污染，从而通过限制有效内积长度和消除受污染元素间的相消来减少带内的后向误差。最后，设计明确的对称正定带状矩阵例子，其 $L$ 和 $A = L L^{\\mathsf{T}}$ 在带内内积中产生接近最大的相消，该相消程度由以下比率衡量\n$$\n\\rho_{ij} \\;=\\; \\frac{\\left\\lvert \\sum_{p=0}^{j-1} \\ell_{i p} \\,\\ell_{j p} \\right\\rvert}{\\lvert a_{ij} \\rvert}, \\quad \\text{for } 1 \\le j \\le i,\\ \\lvert i-j \\rvert \\le k,\n$$\n其中 $\\ell_{ij}$ 表示用于构造 $A$ 的基准带状矩阵 $L$ 的元素。\n\n你的任务是实现这两种算法，并在一组指定的测试集上评估以下指标：\n- 对于每种情况，计算稠密算法计算出的 $L$ 的带外元素的最大绝对值，\n$$\nM_{\\text{off}}^{\\text{dense}} \\;=\\; \\max_{\\substack{ij \\\\ i-jk}} \\lvert \\hat{\\ell}^{\\text{dense}}_{ij} \\rvert,\n$$\n以及考虑带宽的算法计算出的 $L$ 的带外元素的最大绝对值，\n$$\nM_{\\text{off}}^{\\text{band}} \\;=\\; \\max_{\\substack{ij \\\\ i-jk}} \\lvert \\hat{\\ell}^{\\text{band}}_{ij} \\rvert.\n$$\n- 对于每种情况，计算相对 Frobenius 后向误差，\n$$\n\\eta^{\\text{dense}} \\;=\\; \\frac{\\lVert A - \\hat{L}^{\\text{dense}} (\\hat{L}^{\\text{dense}})^{\\mathsf{T}} \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}, \\qquad \n\\eta^{\\text{band}} \\;=\\; \\frac{\\lVert A - \\hat{L}^{\\text{band}} (\\hat{L}^{\\text{band}})^{\\mathsf{T}} \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}},\n$$\n其中 $\\hat{L}^{\\text{dense}}$ 和 $\\hat{L}^{\\text{band}}$ 表示计算出的因子。\n- 对于每种情况，给定用于合成 $A$ 的基准带状矩阵 $L$，计算带内的最大相消比，\n$$\n\\rho_{\\max} \\;=\\; \\max_{\\substack{1 \\le j \\le i \\\\ i-j \\le k}} \\rho_{ij}.\n$$\n\n设计并使用以下明确的测试集，涵盖一般情况、边界情况、重要的边缘情况和带外污染情况：\n\n- 情况1（一般理想路径）：$n=32$, $k=2$，基准矩阵 $L$ 的对角元 $\\ell_{ii}=2.0$，第一条次对角线 $\\ell_{i,i-1}=0.2$ ($i \\ge 2$)，第二条次对角线 $\\ell_{i,i-2}=-0.1$ ($i \\ge 3$)。令 $A = L L^{\\mathsf{T}}$。\n- 情况2（边界，对角对称正定）：$n=20$, $k=0$，基准矩阵 $L$ 为对角矩阵，其对角元为 $\\ell_{ii}=1 + 0.1(i-1)$，无次对角线元素。令 $A = L L^{\\mathsf{T}}$。\n- 情况3（带内最大相消）：$n=30$, $k=2$，基准矩阵 $L$ 的对角元 $\\ell_{ii}=1.0$，第一条次对角线 $\\ell_{i,i-1}=10^{-12}$ ($i \\ge 2$)，第二条次对角线 $\\ell_{i,i-2}=0.5$ ($i \\ge 3$)。令 $A = L L^{\\mathsf{T}}$。\n- 情况4（病态对称正定带状矩阵）：$n=40$, $k=2$，基准矩阵 $L$ 的对角元按几何级数缩放 $\\ell_{ii} = 10^{-8 + 16\\frac{i-1}{n-1}}$，第一条次对角线 $\\ell_{i,i-1}=10^{-4}$ ($i \\ge 2$)，第二条次对角线 $\\ell_{i,i-2}=-10^{-4}$ ($i \\ge 3$)。令 $A = L L^{\\mathsf{T}}$。\n- 情况5（带外污染）：与情况1相同以形成 $A_{\\text{true}} = L L^{\\mathsf{T}}$，然后施加对称的带外噪声 $A = A_{\\text{true}} + E$，其中对于所有 $ij$ 且 $i-jk$ 的情况，$e_{ij} = 10^{-15}$ 且 $e_{ji} = e_{ij}$；其他情况下 $e_{ij}=0$。\n\n你的程序必须：\n- 实现稠密和考虑带宽的下三角形式 Cholesky 分解。\n- 对于每种情况，以浮点数形式生成五个指标 $M_{\\text{off}}^{\\text{dense}}$、$M_{\\text{off}}^{\\text{band}}$、$\\eta^{\\text{dense}}$、$\\eta^{\\text{band}}$ 和 $\\rho_{\\max}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n[情况1的指标 $M_{\\text{off}}^{\\text{dense}},M_{\\text{off}}^{\\text{band}},\\eta^{\\text{dense}},\\eta^{\\text{band}},\\rho_{\\max}$，然后是情况2的相同五个指标，以此类推]。\n所有数字必须以十进制浮点值打印。不需要用户输入，也不允许使用外部文件。不涉及物理单位或角度单位。",
                "solution": "该问题的分析和解决分为两个阶段。首先，对带状 Cholesky 分解的性质进行理论推导。其次，基于 Python 实现，对指定的测试集进行实证评估。\n\n### 理论推导与分析\n\n对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的 Cholesky 分解由 $A = L L^{\\mathsf{T}}$ 给出，其中 $L$ 是一个唯一的具有正对角元的下三角矩阵。我们分析当 $A$ 是一个带状矩阵时该分解的性质。\n\n#### 1. 精确算术中带状结构的保持\n\n我们通过归纳法证明，如果 $A$ 的半带宽为 $k$（即，对于 $|i-j|k$ 有 $a_{ij}=0$），那么在精确算术中，其 Cholesky 因子 $L$ 的半带宽也为 $k$（即，对于 $i-jk$ 有 $\\ell_{ij}=0$）。为清晰起见，我们使用基于 0 的索引（$i, j \\in \\{0, \\dots, n-1\\}$）。列向 Cholesky 算法定义如下：\n$$L_{jj} = \\sqrt{A_{jj} - \\sum_{p=0}^{j-1} L_{jp}^2}$$\n$$L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{p=0}^{j-1} L_{ip}L_{jp} \\right) \\quad \\text{for } i  j$$\n\n**基本情况（第 $j=0$ 列）：**\n$L_{00} = \\sqrt{A_{00}}$。对于 $i0$，$L_{i0} = A_{i0}/L_{00}$。由于 $A$ 是半带宽为 $k$ 的带状矩阵，对于 $i-0  k$ 有 $A_{i0}=0$。因此，对于 $ik$ 有 $L_{i0}=0$。所以，$L$ 的第一列具有所需的带状结构。\n\n**归纳步骤：**\n假设对于所有列 $p  j$，带状结构都成立，即如果 $q-p  k$，则 $L_{qp}=0$。我们必须证明第 $j$ 列也满足此性质，即对于所有满足 $i-jk$ 的 $i$，都有 $L_{ij}=0$。\n\n考虑 $i-j  k$ 时 $L_{ij}$ 的公式。\n1.  根据 $A$ 的带状结构，由于 $i-j  k$，元素 $A_{ij}=0$。\n2.  考虑求和项 $S_{ij} = \\sum_{p=0}^{j-1} L_{ip}L_{jp}$。要使任何一项 $L_{ip}L_{jp}$ 非零，$L_{ip}$ 和 $L_{jp}$ 都必须非零。根据归纳假设，这要求：\n    - $L_{ip} \\neq 0 \\implies i-p \\le k \\implies p \\ge i-k$。\n    - $L_{jp} \\neq 0 \\implies j-p \\le k \\implies p \\ge j-k$。\n    由于 $ij$，我们有 $i-k  j-k$。因此，对于一个非零的乘积，我们需要 $p \\ge i-k$。\n3.  求和索引 $p$ 的范围是从 $0$ 到 $j-1$。然而，条件 $i-jk$ 意味着 $i-k  j$。因此，非零项的条件（$p \\ge i-k$）与求和范围（$p \\le j-1$）相结合，得出 $j-1 \\ge p \\ge i-k  j$。这是一个矛盾。不存在同时满足这些条件的索引 $p$。\n4.  因此，和 $S_{ij}$ 中的每一项都为零，使得 $S_{ij} = 0$。\n\n将这些结果代入 $L_{ij}$ 的公式中：\n$$L_{ij} = \\frac{1}{L_{jj}} (0 - 0) = 0$$\n这就完成了归纳证明。一个带状对称正定矩阵 $A$ 的 Cholesky 因子 $L$ 也是一个具有相同半带宽的带状矩阵。\n\n#### 2. 有限精度下零值的保持\n\n一个**考虑带宽的** Cholesky 算法利用了已证明的带状结构。它只计算满足 $i-j \\le k$ 的元素 $L_{ij}$。对于所有满足 $i-jk$ 的元素，它不执行计算，而是强制 $L_{ij}=0$。用于计算内积的循环也受到限制。例如，在计算 $i-j \\le k$ 的 $L_{ij}$ 时，求和 $\\sum L_{ip}L_{jp}$ 的范围是 $p$ 从 $\\max(0, i-k, j-k)$ 到 $j-1$。\n\n在遵循指定模型（$x+0=x, 0 \\cdot y=0$）的有限精度算术中，这种结构性强制措施保证了计算出的因子 $\\hat{L}^{\\text{band}}$ 是严格带状的。该算法从不执行可能在带外引入非零值（填充）的操作。这确保了 $M_{\\text{off}}^{\\text{band}} = \\max_{i-jk} |\\hat{\\ell}^{\\text{band}}_{ij}| = 0$。\n\n#### 3. 存在带外污染时的稳定性优势\n\n考虑一个矩阵 $A = A_{\\text{true}} + E$，其中 $A_{\\text{true}}$ 是完美带状的，而 $E$ 是一个量级很小的带外噪声矩阵（仅当 $|i-j|k$ 时 $E_{ij} \\neq 0$）。\n\n-   一个**稠密 Cholesky 算法**处理整个矩阵 $A$，包括噪声 $E$。当计算带外元素 $\\hat{L}_{ij}$（其中 $i-j  k$）时，公式变为 $\\hat{L}_{ij} \\approx \\frac{1}{\\hat{L}_{jj}}(E_{ij} - \\sum_{p=0}^{j-1} \\hat{L}_{ip}\\hat{L}_{jp})$。即使 $E_{ij}$ 很小，先前计算出的 $\\hat{L}$ 中的带外填充也会对求和项产生贡献，从而在整个 $\\hat{L}$ 中传播并可能放大噪声。这导致一个非零的 $M_{\\text{off}}^{\\text{dense}}$。更长的内积（长度可达 $n-1$）也会导致更大的舍入误差累积，从而增加后向误差 $\\eta^{\\text{dense}}$。\n\n-   **考虑带宽的算法**会忽略 $A$ 在带外的所有元素。它实际上计算的是 $A$ 的带状部分的 Cholesky 因子。通过这样做，它不会将带外噪声 $E$ 传播到因子 $\\hat{L}^{\\text{band}}$ 中。这会产生一个更“干净”的因子，它代表了底层的结构化矩阵 $A_{\\text{true}}$。对于带状算法，后向误差 $\\eta^{\\text{band}} = \\lVert A - \\hat{L}^{\\text{band}}(\\hat{L}^{\\text{band}})^{\\mathsf{T}} \\rVert_{\\mathrm{F}} / \\lVert A \\rVert_{\\mathrm{F}}$ 将主要由被忽略的噪声的范数决定，因为 $\\hat{L}^{\\text{band}}(\\hat{L}^{\\text{band}})^{\\mathsf{T}}$ 是严格带状的。通过避免长内积和污染，带内部分的分解通常更准确。\n\n#### 4. 相消比 $\\rho_{ij}$\n\n比率 $\\rho_{ij} = |\\sum_{p=0}^{j-1} \\ell_{ip} \\ell_{jp}| / |a_{ij}|$ 衡量了由 $L$ 的前 $j-1$ 列形成的项与最终项 $a_{ij}$ 之间的关系。从恒等式 $a_{ij} = \\sum_{p=0}^{j-1} \\ell_{ip} \\ell_{jp} + \\ell_{ij} \\ell_{jj}$ 中，我们可以看到 $\\rho_{ij} = |\\sum_{p=0}^{j-1} \\ell_{ip} \\ell_{jp}| / |\\sum_{p=0}^{j-1} \\ell_{ip} \\ell_{jp} + \\ell_{ij} \\ell_{jj}|$。一个大的比率 $\\rho_{ij}  1$ 意味着在计算 $a_{ij}$ 时发生了显著的相消，这在分解的逆过程中，对应于从 $a_{ij}$ 计算 $\\ell_{ij}$ 时的灾难性相消。情况3旨在探讨这一点。对于该情况，我们有 $\\ell_{ii}=1.0$, $\\ell_{i,i-1}=10^{-12}$ 和 $\\ell_{i,i-2}=0.5$。我们来计算 $j=i-1$ 时的 $\\rho_{i,i-1}$。首先，分母 $a_{i,i-1}$ 是由 $A=LL^T$ 定义的。对于 $j=i-1$，我们有 $a_{i,i-1} = \\sum_{p=0}^{i-1} \\ell_{ip}\\ell_{i-1,p}$。由于 $L$ 的半带宽为2，乘积 $\\ell_{ip}\\ell_{i-1,p}$ 仅在 $p=i-2$ 和 $p=i-1$ 时可能非零。展开求和得到：$a_{i,i-1} = \\ell_{i,i-2}\\ell_{i-1,i-2} + \\ell_{i,i-1}\\ell_{i-1,i-1} = (0.5)(10^{-12}) + (10^{-12})(1.0) = 1.5 \\times 10^{-12}$。$\\rho_{i,i-1}$ 的分子是 $|\\sum_{p=0}^{i-2} \\ell_{ip}\\ell_{i-1,p}| = |\\ell_{i,i-2}\\ell_{i-1,i-2}| = |(0.5)(10^{-12})| = 0.5 \\times 10^{-12}$。因此，$\\rho_{i,i-1} = \\frac{0.5 \\times 10^{-12}}{1.5 \\times 10^{-12}} = \\frac{1}{3}$。该案例的最大相消比 $\\rho_{\\max}$ 接近这个值。",
                "answer": "```python\nimport numpy as np\nimport math\n\ndef cholesky_dense(A: np.ndarray) - np.ndarray:\n    \"\"\"\n    Performs a dense Cholesky factorization of a symmetric positive definite matrix A.\n    A = L @ L.T\n    \"\"\"\n    n = A.shape[0]\n    L = np.zeros_like(A, dtype=float)\n    for j in range(n):\n        # Diagonal element L[j, j]\n        s = A[j, j] - np.dot(L[j, :j], L[j, :j])\n        if s = 0:\n            # Handle potential floating point inaccuracies for near-zero positive numbers\n            s = 1e-30\n        L[j, j] = math.sqrt(s)\n        \n        # Off-diagonal elements in column j\n        for i in range(j + 1, n):\n            s_ij = A[i, j] - np.dot(L[i, :j], L[j, :j])\n            L[i, j] = s_ij / L[j, j]\n    return L\n\ndef cholesky_band(A: np.ndarray, k: int) - np.ndarray:\n    \"\"\"\n    Performs a band-aware Cholesky factorization of a symmetric positive definite matrix A.\n    A = L @ L.T where L is a banded lower triangular matrix.\n    \"\"\"\n    n = A.shape[0]\n    L = np.zeros_like(A, dtype=float)\n    for j in range(n):\n        # Diagonal element L[j, j]\n        # Summation range is restricted by the band\n        p_start_diag = max(0, j - k)\n        s = A[j, j] - np.dot(L[j, p_start_diag:j], L[j, p_start_diag:j])\n        if s = 0:\n            s = 1e-30\n        L[j, j] = math.sqrt(s)\n        \n        # Off-diagonal elements in column j, within the band\n        i_end = min(n, j + k + 1)\n        for i in range(j + 1, i_end):\n            p_start_offdiag = max(0, i - k) # Products L[i,p]L[j,p] are 0 for p  i-k\n            s_ij = A[i, j] - np.dot(L[i, p_start_offdiag:j], L[j, p_start_offdiag:j])\n            L[i, j] = s_ij / L[j, j]\n    return L\n\ndef get_case1_L():\n    n, k = 32, 2\n    L_true = np.zeros((n, n))\n    for i in range(n):\n        L_true[i, i] = 2.0\n        if i = 1: L_true[i, i-1] = 0.2\n        if i = 2: L_true[i, i-2] = -0.1\n    return n, k, L_true\n\ndef get_case2_L():\n    n, k = 20, 0\n    L_true = np.zeros((n, n))\n    for i in range(n):\n        L_true[i, i] = 1.0 + 0.1 * i\n    return n, k, L_true\n\ndef get_case3_L():\n    n, k = 30, 2\n    L_true = np.zeros((n, n))\n    for i in range(n):\n        L_true[i, i] = 1.0\n        if i = 1: L_true[i, i-1] = 1e-12\n        if i = 2: L_true[i, i-2] = 0.5\n    return n, k, L_true\n\ndef get_case4_L():\n    n, k = 40, 2\n    L_true = np.zeros((n, n))\n    for i in range(n):\n        L_true[i, i] = 10**(-8.0 + 16.0 * i / (n - 1))\n        if i = 1: L_true[i, i-1] = 1e-4\n        if i = 2: L_true[i, i-2] = -1e-4\n    return n, k, L_true\n\ndef process_case(n, k, L_true, A_orig, A_factor):\n    \"\"\"\n    Runs both algorithms on the given matrix A_factor and computes all metrics.\n    A_orig and L_true are used for rho_max calculation.\n    \"\"\"\n    # Factorize using both algorithms\n    L_dense = cholesky_dense(A_factor)\n    L_band = cholesky_band(A_factor, k)\n\n    # Metric 1  2: Maximum absolute off-band entry\n    i_indices, j_indices = np.indices((n, n))\n    off_band_mask = (i_indices - j_indices)  k\n    \n    if np.any(off_band_mask):\n        M_off_dense = np.max(np.abs(L_dense[off_band_mask]))\n        M_off_band = np.max(np.abs(L_band[off_band_mask]))\n    else:\n        M_off_dense = 0.0\n        M_off_band = 0.0\n\n    # Metric 3  4: Relative Frobenius backward error\n    A_recon_dense = L_dense @ L_dense.T\n    norm_A_factor = np.linalg.norm(A_factor, 'fro')\n    eta_dense = np.linalg.norm(A_factor - A_recon_dense, 'fro') / norm_A_factor\n\n    A_recon_band = L_band @ L_band.T\n    eta_band = np.linalg.norm(A_factor - A_recon_band, 'fro') / norm_A_factor\n\n    # Metric 5: Maximal cancellation ratio\n    max_rho = 0.0\n    for i in range(n):\n        for j in range(max(0, i - k), i + 1):\n            if abs(A_orig[i, j])  1e-30:  # Avoid division by zero\n                continue\n            \n            # Summation for rho_ij numerator is over p from 0 to j-1\n            p_end = j\n            if p_end == 0:\n                s_ij = 0.0\n            else:\n                s_ij = np.dot(L_true[i, :p_end], L_true[j, :p_end])\n            \n            rho = abs(s_ij) / abs(A_orig[i, j])\n            if rho  max_rho:\n                max_rho = rho\n    \n    return [M_off_dense, M_off_band, eta_dense, eta_band, max_rho]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    all_results = []\n\n    # Case 1\n    n, k, L_true = get_case1_L()\n    A = L_true @ L_true.T\n    all_results.extend(process_case(n, k, L_true, A, A))\n\n    # Case 2\n    n, k, L_true = get_case2_L()\n    A = L_true @ L_true.T\n    all_results.extend(process_case(n, k, L_true, A, A))\n\n    # Case 3\n    n, k, L_true = get_case3_L()\n    A = L_true @ L_true.T\n    all_results.extend(process_case(n, k, L_true, A, A))\n\n    # Case 4\n    n, k, L_true = get_case4_L()\n    A = L_true @ L_true.T\n    all_results.extend(process_case(n, k, L_true, A, A))\n    \n    # Case 5\n    n, k, L_true1 = get_case1_L()\n    A_true = L_true1 @ L_true1.T\n    A_contaminated = A_true.copy()\n    noise = 1e-15\n    for i in range(n):\n        for j in range(i):\n            if i - j  k:\n                A_contaminated[i, j] += noise\n                A_contaminated[j, i] += noise\n    # For rho_max, we use the original unperturbed A, as per problem clarification.\n    all_results.extend(process_case(n, k, L_true1, A_true, A_contaminated))\n\n    print(f\"[{','.join(f'{x:.8e}' for x in all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```",
                "id": "3568119"
            }
        ]
    }