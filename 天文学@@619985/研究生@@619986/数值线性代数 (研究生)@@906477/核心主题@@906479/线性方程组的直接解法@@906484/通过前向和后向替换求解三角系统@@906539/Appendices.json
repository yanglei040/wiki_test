{
        "hands_on_practices": [
            {
                "introduction": "理论上完美的算法在实际计算机上执行时，必须面对有限精度浮点运算的挑战。本练习将通过一个精心设计的例子，揭示看似微小的实现细节——例如运算顺序或矩阵结构——如何导致计算结果的巨大精度差异。通过这个实践，你将亲身体验灾难性抵消这一数值分析中的关键概念，并理解数值稳定性的重要性。[@problem_id:3579228]",
                "problem": "考虑一个下单位三角矩阵 $L \\in \\mathbb{R}^{4 \\times 4}$ 和精确解向量 $x^{\\star} \\in \\mathbb{R}^{4}$，它们由下式给出\n$$\nL \\;=\\;\n\\begin{pmatrix}\n1  & 0  & 0  & 0 \\\\\n10^{16}  & 1  & 0  & 0 \\\\\n-10^{16}  & 10^{-16}  & 1  & 0 \\\\\n0  & -10^{-16}  & 10^{-16}  & 1\n\\end{pmatrix},\n\\qquad\nx^{\\star} \\;=\\;\n\\begin{pmatrix}\n1 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{pmatrix}.\n$$\n定义右端项 $b \\in \\mathbb{R}^{4}$ 和 $c \\in \\mathbb{R}^{4}$ 为\n$$\nb \\;=\\; L^{\\top} x^{\\star}, \\qquad c \\;=\\; L x^{\\star}.\n$$\n在电气和电子工程师协会（IEEE）754双精度（binary64）浮点算术模型下工作，采用就近舍入，偶数优先原则。设单位舍入误差为 $u = 2^{-53}$，并假设每个基本运算都遵循标准模型，\n$$\n\\operatorname{fl}(a \\circ b) \\;=\\; (a \\circ b)\\,(1 + \\delta), \\qquad |\\delta| \\leq u,\n$$\n对于 $\\circ \\in \\{+, -, \\times, \\div\\}$，不使用积和熔加运算，点积按循环顺序通过朴素的从左到右求和方式累加。假设 $L$ 以列主序布局存储。考虑两种计算路径：\n\n1. 路径 A：通过向后代入法求解 $L^{\\top} x = b$。对于索引 $i$ 从 4 降序到 1，计算\n$$\nx_i \\;=\\; \\frac{b_i - \\sum_{j=i+1}^{4} L_{j,i} \\, x_j}{L_{i,i}},\n$$\n内积对 $j = i+1, i+2, \\dots, 4$ 求和。\n\n2. 路径 B：通过向前代入法求解 $L x = c$。对于索引 $i$ 从 1 升序到 4，计算\n$$\nx_i \\;=\\; \\frac{c_i - \\sum_{j=1}^{i-1} L_{i,j} \\, x_j}{L_{i,i}},\n$$\n内积对 $j = 1, 2, \\dots, i-1$ 求和。\n\n使用指定的算术模型、内存布局和求和顺序，分析浮点舍入效应，解释为什么对于此数据，路径 A 在数值上优于路径 B。特别地，确定由路径 B 产生的计算值 $\\hat{x}^{(B)}_2$，然后计算绝对前向误差 $|\\hat{x}^{(B)}_2 - x^{\\star}_2|$。将你的最终答案表示为单个实数值。无需舍入。",
                "solution": "问题陈述的有效性得到确认。这是一个数值线性代数中的良定问题，基于标准的浮点算术模型。所有必要的数据和定义均已提供，不存在内部矛盾或科学不准确之处。\n\n该问题要求分析求解涉及矩阵 $L$ 及其转置 $L^{\\top}$ 的三角系统的两种计算路径。一条路径优于另一条路径取决于其在面对浮点舍入误差时的数值稳定性。我们将首先为这种不同的稳定性提供一个总体解释，然后对路径 B 进行详细的浮点分析以计算所需的误差。\n\n矩阵 $L$ 和精确解 $x^{\\star}$ 如下所示：\n$$\nL \\;=\\;\n\\begin{pmatrix}\n1  & 0  & 0  & 0 \\\\\n10^{16}  & 1  & 0  & 0 \\\\\n-10^{16}  & 10^{-16}  & 1  & 0 \\\\\n0  & -10^{-16}  & 10^{-16}  & 1\n\\end{pmatrix},\n\\qquad\nx^{\\star} \\;=\\;\n\\begin{pmatrix}\n1 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{pmatrix}.\n$$\n右端向量 $b$ 和 $c$ 由 $b = L^{\\top} x^{\\star}$ 和 $c = L x^{\\star}$ 定义。它们的精确值为：\n$$\nc \\;=\\; L x^{\\star} \\;=\\; \\begin{pmatrix} 1 \\\\ 10^{16} + 1 \\\\ -10^{16} + 10^{-16} + 1 \\\\ 1 \\end{pmatrix}\n$$\n$$\nb \\;=\\; L^{\\top} x^{\\star} \\;=\\; \\begin{pmatrix} 1 + 10^{16} - 10^{16} \\\\ 1 + 10^{-16} - 10^{-16} \\\\ 1 + 10^{-16} \\\\ 1 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 + 10^{-16} \\\\ 1 \\end{pmatrix}\n$$\n分析的核心在于用 IEEE 754 双精度算术表示这些向量并进行计算。单位舍入误差为 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n首先，我们来分析为什么路径 A 在数值上更优越。路径 A 的算法使用向后代入法求解 $L^{\\top} x = b$。计算机实现的第一步是以浮点格式存储向量 $b$，我们将其表示为 $\\hat{b}$。\n- $\\hat{b}_1 = \\operatorname{fl}(1) = 1$。\n- $\\hat{b}_2 = \\operatorname{fl}(1) = 1$。\n- $\\hat{b}_3 = \\operatorname{fl}(1 + 10^{-16})$。对于数字 $1$，其末位单位（unit in the last place）为 $\\operatorname{ulp}(1) = 2^{-52}$。如果一个增量的绝对值小于 ulp 的一半，即 $2^{-52}/2 = 2^{-53} = u$，则该增量将被舍去。我们必须将 $10^{-16}$与 $u$ 进行比较。由于 $\\log_{10}(u) \\approx -15.95$，我们有 $u \\approx 1.12 \\times 10^{-16}$。因此，$10^{-16}  u$，将 $10^{-16}$加到 $1$ 上的操作会在舍入中丢失。所以，$\\hat{b}_3 = 1$。\n- $\\hat{b}_4 = \\operatorname{fl}(1) = 1$。\n存储的右端项为 $\\hat{b} = (1, 1, 1, 1)^{\\top}$。然后，向后代入算法计算 $L^{\\top} \\hat{x}^{(A)} = \\hat{b}$ 的解 $\\hat{x}^{(A)}$。这个计算过程没有出现显著的舍入误差；例如，$\\hat{x}^{(A)}_1$ 的计算涉及项 $\\operatorname{fl}(10^{16} \\times \\hat{x}^{(A)}_2 - 10^{16} \\times \\hat{x}^{(A)}_3)$。当 $\\hat{x}^{(A)}_2=1$ 和 $\\hat{x}^{(A)}_3=1$ 时，此项计算结果为 $\\operatorname{fl}(10^{16} - 10^{16}) = 0$。最终计算出的解是 $\\hat{x}^{(A)} = (1, 1, 1, 1)^{\\top} = x^{\\star}$。路径 A 非常稳定，产生零前向误差。\n\n现在，我们分析路径 B，它使用向前代入法求解 $L x = c$。我们必须首先以浮点格式存储向量 $c$，得到 $\\hat{c}$。\n- $\\hat{c}_1 = \\operatorname{fl}(1) = 1$。\n- $\\hat{c}_2 = \\operatorname{fl}(10^{16} + 1)$。为确定此值，我们分析 $10^{16}$ 附近的数的表示。可以证明数字 $10^{16} = 2^{16} \\times 5^{16}$ 在双精度中是精确可表示的。$10^{16}$ 的二进制指数 $E$ 是 $53$，所以 $\\operatorname{ulp}(10^{16}) = 2^{E-52} = 2^{53-52} = 2$。因此，$10^{16}$ 附近的可表示数是偶数，例如 $10^{16}$ 和 $10^{16}+2$。值 $10^{16}+1$ 正好位于这两个可表示数的中间。根据指定的“偶数优先”规则，我们必须选择整数有效位为偶数的可表示数。一个数的值为 $M \\times 2^k$。对于 $10^{16}$，其有效位整数为 $M_1 = 10^{16} \\times 2^{-1} = 5 \\times 10^{15}$，这是一个奇数。对于 $10^{16}+2$，其有效位整数为 $M_2 = (10^{16}+2) \\times 2^{-1} = 5 \\times 10^{15}+1$，这是一个偶数。因此，通过向上舍入到 $10^{16}+2$ 来打破平局。所以，$\\hat{c}_2 = 10^{16}+2$。这种表示引入了初始绝对误差 $|\\hat{c}_2 - c_2| = |(10^{16}+2) - (10^{16}+1)| = 1$。\n- 为完整起见，$\\hat{c}_3 = \\operatorname{fl}(1+10^{-16}-10^{16}) = \\operatorname{fl}(\\operatorname{fl}(1+10^{-16}) - 10^{16}) = \\operatorname{fl}(1-10^{16})$。这也是一个平局情况，舍入到 $-10^{16}+2$。\n- $\\hat{c}_4 = \\operatorname{fl}(1) = 1$。\n存储的右端项是 $\\hat{c} = (1, 10^{16}+2, -10^{16}+2, 1)^{\\top}$。\n\n向前代入算法按以下步骤计算 $\\hat{x}^{(B)}$：\n当 $i=1$ 时：\n$$ \\hat{x}^{(B)}_1 = \\frac{\\hat{c}_1}{L_{1,1}} = \\frac{1}{1} = 1. $$\n当 $i=2$ 时：\n$$ \\hat{x}^{(B)}_2 = \\frac{\\hat{c}_2 - L_{2,1} \\hat{x}^{(B)}_1}{L_{2,2}} $$\n该计算在浮点算术中执行：\n$$ \\hat{x}^{(B)}_2 = \\operatorname{fl}\\left(\\frac{\\operatorname{fl}(\\hat{c}_2 - \\operatorname{fl}(L_{2,1} \\times \\hat{x}^{(B)}_1))}{\\operatorname{fl}(L_{2,2})}\\right) $$\n使用值 $L_{2,1} = 10^{16}$, $L_{2,2} = 1$, $\\hat{x}^{(B)}_1 = 1$ 和 $\\hat{c}_2 = 10^{16}+2$：\n$$ \\operatorname{fl}(L_{2,1} \\times \\hat{x}^{(B)}_1) = \\operatorname{fl}(10^{16} \\times 1) = 10^{16}. $$\n分子变为：\n$$ \\operatorname{fl}(\\hat{c}_2 - 10^{16}) = \\operatorname{fl}((10^{16}+2) - 10^{16}) = \\operatorname{fl}(2) = 2. $$\n分母是 $1$。因此，计算值为：\n$$ \\hat{x}^{(B)}_2 = 2. $$\n这与精确解分量 $x^{\\star}_2 = 1$ 有显著差异。在存储 $c_2$ 时引入的巨大初始误差，通过两个大而几乎相等的数相减被揭示出来，这个过程被称为灾难性抵消。这种不稳定性使得路径 B 对此问题远不如路径 A。\n\n路径 B 中解向量第二个分量的绝对前向误差为：\n$$ |\\hat{x}^{(B)}_2 - x^{\\star}_2| = |2 - 1| = 1. $$\n此误差源于将 $c_2 = 10^{16}+1$ 舍入为 $\\hat{c}_2 = 10^{16}+2$，这展示了当矩阵 $L$ 包含大元素时，向前代入算法对右端项的微小相对扰动的敏感性。",
                "answer": "$$\n\\boxed{1}\n$$",
                "id": "3579228"
            },
            {
                "introduction": "在保证了数值稳定性的前提下，算法性能是下一个核心挑战。本练习将探讨如何针对现代计算机体系结构，通过分析内存访问来优化三角系统求解。通过对比逐列求解与分块策略，你将推导和理解算术强度这一概念，并量化地看到分块计算如何显著提升性能。[@problem_id:3579175]",
                "problem": "考虑通过前向代换求解下三角系统 $L X = B$，其中 $L \\in \\mathbb{R}^{m \\times m}$ 是对角线元素非零的下三角矩阵，$X \\in \\mathbb{R}^{m \\times n}$ 是解，$B \\in \\mathbb{R}^{m \\times n}$ 是右端项。有两种实现策略可供选择：(i) 对 $k = 1, 2, \\dots, n$ 的每一列 $L x^{(k)} = b^{(k)}$ 独立地通过前向代换求解；(ii) 以 $b$ 个右端项为一块求解 $L X_j = B_j$，其中 $B$ 被分块为 $B = [B_1 \\, | \\, B_2 \\, | \\, \\dots \\, | \\, B_{n/b}]$，且 $B_j \\in \\mathbb{R}^{m \\times b}$，$n$ 是 $b$ 的整数倍。假设一个两级内存模型：一个快速内存，在块计算期间可以保留 $B$ 的 $b$ 列以及对应的 $X$ 的 $b$ 列（即当前块 $B_j$ 和 $X_j$），但在当前流式传输过程之后不能保留 $L$；以及一个慢速内存（主存），数据从这里加载并存储到这里。设每次浮点元素传输（加载或存储）移动 $w$ 字节。采用以下科学上符合实际的假设：\n- $B$ 的每个元素从慢速内存中精确读取一次，$X$ 的每个元素向慢速内存中精确写入一次（允许原地更新）。\n- 在按列策略中，对于每一列的求解，$L$ 的整个下三角部分从慢速内存中流式传输一次。\n- 在分块策略中，对于 $b$ 列的每一个块，$L$ 的整个下三角部分从慢速内存中流式传输一次。\n将运算强度 $\\mathcal{I}$ 定义为浮点运算次数与慢速内存和快速内存之间移动的总字节数之比。从单列的基本前向代换递推公式出发，不借助任何现成的性能公式，推导出两种策略的总浮点运算次数和总数据移动量的表达式，然后求出分块策略与按列策略的运算强度之比。最终结果需以仅包含 $m$ 和 $b$ 的单个闭式表达式给出。无需进行四舍五入，也无需报告物理单位。您的推导必须从前向代换的定义和上述数据移动假设开始，并根据第一性原理推导出最终表达式。假设 $n$ 是 $b$ 的正整数倍，且 $L$ 是满秩的，因此前向代换是良定义的。",
                "solution": "目标是推导分块前向代换算法与按列算法的运算强度之比，即 $\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}}$。运算强度 $\\mathcal{I}$ 定义为总浮点运算次数（flops）与慢速内存和快速内存之间移动的总数据字节数之比。我们将按照要求从第一性原理出发推导这个比值。\n\n首先，我们确定求解系统 $L X = B$ 所需的总浮点运算次数，其中 $L \\in \\mathbb{R}^{m \\times m}$，$X \\in \\mathbb{R}^{m \\times n}$，$B \\in \\mathbb{R}^{m \\times n}$。这个解与实现策略（按列或分块）无关。我们从分析单个列向量 $L x = b$ 的求解开始，其中 $x, b \\in \\mathbb{R}^m$。解向量 $x$ 的第 $i$ 个分量 $x_i$ 的前向代换递推关系为：\n$$x_i = \\frac{1}{l_{ii}} \\left( b_i - \\sum_{j=1}^{i-1} l_{ij} x_j \\right) \\quad \\text{for } i = 1, 2, \\dots, m$$\n对于每个 $i$，计算总和 $\\sum_{j=1}^{i-1} l_{ij} x_j$ 需要 $i-1$ 次乘法和 $i-2$ 次加法（对于 $i1$）。之后，需要一次从 $b_i$ 的减法和一次除以 $l_{ii}$ 的除法。一个标准的约定是将一个乘加对计为 $2$ 次浮点运算。或者，我们分别计算加/减法和乘/除法。该求和需要 $i-1$ 次乘法。括号内的项总共需要 $i-1$ 次减法（或1次减法和 $i-2$ 次加法）。最后，执行一次除法。计算 $x_i$ 的总浮点运算次数为 $(i-1)$ 次乘法、$(i-1)$ 次加/减法和 $1$ 次除法，总计为 $(i-1) + (i-1) + 1 = 2i - 1$ 次浮点运算。对于 $i=1$，这得到 $2(1)-1=1$ 次浮点运算（一次除法），这是正确的。\n\n求解一列所需的总浮点运算次数 $\\text{flops}_{\\text{col}}$ 是对所有分量 $i=1, \\dots, m$ 的求和：\n$$\\text{flops}_{\\text{col}} = \\sum_{i=1}^{m} (2i-1) = 2\\sum_{i=1}^{m} i - \\sum_{i=1}^{m} 1 = 2 \\frac{m(m+1)}{2} - m = m(m+1) - m = m^2$$\n由于完整系统 $L X = B$ 由 $n$ 个这样的独立列求解组成，总浮点运算次数为：\n$$\\text{Flops}_{\\text{total}} = n \\cdot \\text{flops}_{\\text{col}} = n m^2$$\n\n接下来，我们分析每种策略的数据移动量。设 $w$ 为每个浮点元素的字节数。矩阵 $B$ 和 $X$ 的移动对于两种策略是共同的。根据问题陈述，$B$ 的每个元素从慢速内存中读取一次，$X$ 的每个元素向慢速内存中写入一次。\n读取 $B$ 的数据量：$m \\times n$ 个元素 $\\times w$ 字节/元素 $= mnw$ 字节。\n写入 $X$ 的数据量：$m \\times n$ 个元素 $\\times w$ 字节/元素 $= mnw$ 字节。\n$B$ 和 $X$ 的总数据移动量为 $2mnw$ 字节。\n\n策略 (i)：按列求解。\n在这种策略中，我们对每一列 $k=1, \\dots, n$ 求解 $L x^{(k)} = b^{(k)}$。问题陈述指出，对于每一次列求解，$L$ 的整个下三角部分从慢速内存流式传输一次。$L$ 的下三角部分中的非零元素数量为 $\\sum_{i=1}^{m} i = \\frac{m(m+1)}{2}$。\n读取 $L$ 的数据量：$n$ 列 $\\times \\frac{m(m+1)}{2}$ 元素/列 $\\times w$ 字节/元素 $= n \\frac{m(m+1)}{2} w$ 字节。\n按列策略的总数据移动量 $M_{\\text{col-wise}}$ 是 $B$、$X$ 和 $L$ 的移动量之和：\n$$M_{\\text{col-wise}} = 2mnw + n \\frac{m(m+1)}{2} w = nw \\left( 2m + \\frac{m(m+1)}{2} \\right) = nw \\left( \\frac{4m + m^2 + m}{2} \\right) = nw \\frac{m(m+5)}{2}$$\n按列策略的运算强度为：\n$$\\mathcal{I}_{\\text{col-wise}} = \\frac{\\text{Flops}_{\\text{total}}}{M_{\\text{col-wise}}} = \\frac{n m^2}{nw \\frac{m(m+5)}{2}} = \\frac{2m^2}{w m(m+5)} = \\frac{2m}{w(m+5)}$$\n\n策略 (ii)：分块求解。\n在这种策略中，系统以 $b$ 列为块进行求解。总列数为 $n$，因此有 $n/b$ 个块。问题陈述指出，$L$ 的下三角部分每个块从慢速内存流式传输一次。\n读取 $L$ 的数据量：$\\frac{n}{b}$ 个块 $\\times \\frac{m(m+1)}{2}$ 元素/块 $\\times w$ 字节/元素 $= \\frac{n}{b} \\frac{m(m+1)}{2} w$ 字节。\n分块策略的总数据移动量 $M_{\\text{blocked}}$ 是 $B$、$X$ 和 $L$ 的移动量之和：\n$$M_{\\text{blocked}} = 2mnw + \\frac{n}{b} \\frac{m(m+1)}{2} w = nw \\left( 2m + \\frac{m(m+1)}{2b} \\right) = nw \\left( \\frac{4mb + m^2 + m}{2b} \\right) = nw \\frac{m(m+4b+1)}{2b}$$\n分块策略的运算强度为：\n$$\\mathcal{I}_{\\text{blocked}} = \\frac{\\text{Flops}_{\\text{total}}}{M_{\\text{blocked}}} = \\frac{n m^2}{nw \\frac{m(m+4b+1)}{2b}} = \\frac{2b m^2}{w m(m+4b+1)} = \\frac{2bm}{w(m+4b+1)}$$\n\n最后，我们计算运算强度的比值。\n$$\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}} = \\frac{\\frac{2bm}{w(m+4b+1)}}{\\frac{2m}{w(m+5)}}$$\n我们可以消去分子和分母中的公因子 $2m$ 和 $w$：\n$$\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}} = \\frac{b}{m+4b+1} \\cdot (m+5) = \\frac{b(m+5)}{m+4b+1}$$\n该表达式仅用矩阵维度 $m$ 和块大小 $b$ 表示了运算强度的比值，符合要求。",
                "answer": "$$\\boxed{\\frac{b(m+5)}{m+4b+1}}$$",
                "id": "3579175"
            },
            {
                "introduction": "许多科学与工程问题涉及的是大型稀疏矩阵，其中绝大多数元素为零。本练习将我们的关注点从稠密矩阵转向稀疏矩阵，这需要采用不同的数据存储和算法实现方法。你将使用压缩稀疏行（CSR）格式，深入理解数据结构如何影响稀疏三角求解中的内存访问模式和算法效率。[@problem_id:3579221]",
                "problem": "考虑在压缩稀疏行（CSR）格式下，通过前向替换法求解一个下三角线性系统。设该系统由一个方形、结构下三角矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个右端项 $b \\in \\mathbb{R}^n$ 给出。目标是设计一个专为前向替换定制的、基于CSR的数据结构，形式化地推导该算法在这种数据表示下的访问模式，并根据非零元的数量来约束每行的间接内存访问次数。在整个过程中，将间接内存访问解释为对解向量 $x$ 中某个条目 $x_j$ 的任何访问，其中索引 $j$ 是从列索引数组中获取的，而不是词法上已知的。\n\n基本基础：\n- 使用三角系统 $A x = b$ 的基本定义，其中 $A$ 是下三角矩阵，以及由三角结构产生的前向替换递推式。\n- 使用压缩稀疏行（CSR）格式的规范定义：数组 $\\text{row\\_ptr} \\in \\mathbb{Z}^{n+1}$，$\\text{col\\_ind} \\in \\mathbb{Z}^{\\text{nnz}}$，以及 $\\text{val} \\in \\mathbb{R}^{\\text{nnz}}$，其中 $\\text{nnz}$ 表示存储的非零元总数。行是连续存储的，因此第 $i$ 行占据索引 $k \\in [\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1])$。\n- 您可以假设在每个CSR行内，列索引是严格递增的。\n\n问题任务：\n1. 为下三角系统提出一个基于CSR的稀疏三角求解数据结构。该结构除了 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$ 外，还应包含以下两者之一：\n   - 一个整数数组 $\\text{diag\\_ind} \\in \\mathbb{Z}^n$，对于每一行 $i$，满足 $\\text{col\\_ind}[\\text{diag\\_ind}[i]] = i$ 且 $\\text{diag\\_ind}[i] \\in [\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1])$，或者\n   - 对角线为单位对角线（不存储）的约定，该约定必须明确说明。\n   阐明一行中的哪些条目是“严格下三角”条目，哪些是“对角线”条目，以及如何在不扫描整行的情况下识别它们。\n2. 仅从三角系统和CSR的定义出发，推导在这种表示下的前向替换访问模式。准确识别对解向量 $x$ 的哪些内存引用是间接的，并根据该行中的非零元数量（表示为 $\\text{nnz}_i$）来约束每行 $i$ 的此类间接访问次数。您的界限必须区分两种情况：\n   - 存储通用对角线（非单位对角线），\n   - 单位对角线（对角线元素不存储，等于 $1$）。\n   提供一个对所有行都有效的界限，并论证在所述假设下为何该界限是紧的。\n3. 实现一个算法，在给定CSR数据（带有由 $\\text{diag\\_ind}$ 定位的已存储对角线或单位对角线）和 $b$ 的情况下，执行前向替换以计算 $x$，并对每一行 $i$，计算生成 $x_i$ 所需的对 $x$ 的间接内存访问次数。将每行的计数值与解一同返回。通过对每个测试用例进行数值检查 $A x = b$ 来验证正确性。\n4. 对于测试套件中的每个测试用例，计算：\n   - 测量的每行间接访问计数的列表，\n   - 根据 $\\text{nnz}_i$ 和对角线约定，从任务2中推导出的每行界限的列表。\n   将所有测试用例的结果汇总到下面指定的最终输出格式中。\n\n使用的定义和约定：\n- 在非单位对角线的情况下，对于每一行 $i$，严格下三角条目是那些 $k \\in [\\text{row\\_ptr}[i], \\text{diag\\_ind}[i])$, 而对角线条目位于 $k = \\text{diag\\_ind}[i]$。\n- 在单位对角线的情况下，对于每一行 $i$，该行中所有存储的条目都是严格下三角的，并且对角线被隐式地视为等于$1$且不存储。\n\n测试套件：\n- 测试用例1（非单位对角线, $n = 5$）：\n  - $\\text{row\\_ptr} = [0, 1, 3, 6, 9, 12]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 0, 1, 2, 0, 2, 3, 1, 3, 4]$,\n  - $\\text{val} = [2.0, 1.0, 3.0, -1.0, 2.0, 4.0, 0.5, -1.0, 2.0, -2.0, 1.5, 5.0]$,\n  - $\\text{diag\\_ind} = [0, 2, 5, 8, 11]$,\n  - $x^{\\star} = [1.0, 2.0, 3.0, 4.0, 5.0]$,\n  - $b = A x^{\\star}$ 使用给定的CSR数据计算。\n- 测试用例2（单位对角线, $n = 5$；对角线隐式等于$1$且不存储）：\n  - $\\text{row\\_ptr} = [0, 0, 1, 3, 4, 6]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 2, 0, 3]$,\n  - $\\text{val} = [0.25, -1.0, 0.5, 2.0, 1.0, -0.5]$,\n  - $x^{\\star} = [1.0, -1.0, 2.0, 0.0, 3.0]$,\n  - $b = A x^{\\star}$ 使用给定的CSR数据和隐式单位对角线计算。\n- 测试用例3（非单位对角线, $n = 6$）：\n  - $\\text{row\\_ptr} = [0, 1, 3, 6, 10, 11, 14]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 2, 4, 5]$,\n  - $\\text{val} = [10.0, -3.0, -2.0, 7.0, 5.0, 1.0, -1.0, -1.0, -1.0, 8.0, 2.0, 2.0, -8.0, 4.0]$,\n  - $\\text{diag\\_ind} = [0, 2, 5, 9, 10, 13]$,\n  - $x^{\\star} = [1.0, 2.0, -1.0, 0.0, 3.0, -2.0]$,\n  - $b = A x^{\\star}$ 使用给定的CSR数据计算。\n\n答案规范和要求的输出格式：\n- 对于每个测试用例 $t$，令 $m^{(t)}$ 为测量的每行间接访问计数的列表，令 $u^{(t)}$ 为从您在任务2中的推导获得的每行界限的列表。\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，用方括号括起，结构为 $[[m^{(1)}, u^{(1)}], [m^{(2)}, u^{(2)}], [m^{(3)}, u^{(3)}]]$。每个 $m^{(t)}$ 和 $u^{(t)}$ 都必须是该测试用例长度为 $n$ 的整数列表。",
                "solution": "问题陈述已经过验证，被认为是合理的。它在数值线性代数方面有科学依据，问题设定良好，目标明确，数据充分，并且没有矛盾或歧义。因此，我们可以继续提供一个完整的解决方案。\n\n任务是分析并实现一个用于稀疏下三角系统 $A x = b$ 的前向替换算法，其中矩阵 $A$ 以压缩稀疏行（CSR）格式存储。分析的重点是数据访问模式，特别是对解向量 $x$ 的间接内存访问次数。\n\n### 任务1：用于三角求解的基于CSR的数据结构\n\n标准的CSR格式由数组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$ 组成，对于一般的稀疏矩阵向量乘法是高效的，但对于三角求解则需要修改，因为在三角求解中，对角元素必须与严格下三角元素分开处理。我们形式化这两种提出的结构。\n\n**情况A：存储的非单位对角线**\n数据结构是元组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val}, \\text{diag\\_ind})$。\n- 数组 $\\text{row\\_ptr} \\in \\mathbb{Z}^{n+1}$，$\\text{col\\_ind} \\in \\mathbb{Z}^{\\text{nnz}}$，和 $\\text{val} \\in \\mathbb{R}^{\\text{nnz}}$ 以标准CSR格式表示矩阵 $A$，存储所有非零条目。这里，$\\text{nnz}$ 是存储的非零元总数。\n- 辅助数组 $\\text{diag\\_ind} \\in \\mathbb{Z}^{n}$ 提供了对每行对角元素的直接访问。对于行 $i$，$\\text{diag\\_ind}[i]$ 是 `val` 和 `col_ind` 中对应于对角线条目 $A_{ii}$ 的索引。可以保证 $\\text{col\\_ind}[\\text{diag\\_ind}[i]] = i$。\n- 假设每行内的列索引是排序的，行 $i$ 的条目划分如下：\n  - **严格下三角条目**：这些是索引 $k$ 在范围 $[\\text{row\\_ptr}[i], \\text{diag\\_ind}[i] - 1]$ 内的元素。\n  - **对角线条目**：这是索引为 $k = \\text{diag\\_ind}[i]$ 的元素。\n  - 由于矩阵是下三角矩阵，因此没有列索引 $j  i$ 的非零条目。\n\n**情况B：隐式单位对角线**\n数据结构是元组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$。\n- CSR数组仅存储 $A$ 的**严格**下三角部分的非零条目。\n- 对角线条目 $A_{ii}$ 都隐式地等于 $1$，并且不存储在 `val` 数组中。\n- 对于行 $i$，所有索引 $k$ 在范围 $[\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1] - 1]$ 内的存储条目都对应于 $j   i$ 的严格下三角元素 $A_{ij}$。\n\n### 任务2：前向替换访问模式的推导与间接访问的界定\n\n求解下三角系统 $A x = b$ 的前向替换基本方程是通过求解第 $i$ 个方程得到 $x_i$：\n$$ \\sum_{j=0}^{n-1} A_{ij} x_j = b_i \\implies A_{ii} x_i + \\sum_{j=0}^{i-1} A_{ij} x_j = b_i $$\n假设 $A_{ii} \\neq 0$，这会产生 $x_i$ 的递推式：\n$$ x_i = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j=0}^{i-1} A_{ij} x_j \\right) $$\n“间接内存访问”定义为对解向量中元素 $x_j$ 的访问，其中索引 $j$ 是从 `col_ind` 数组中检索的。\n\n**情况A的分析（存储的非单位对角线）**\n我们将递推式转换为指定的CSR数据结构。对行 $i$ 的严格下三角部分的求和对应于从行的开始到对角元素（但不包括对角元素）遍历 `val` 和 `col_ind` 数组。对角线的位置由 `diag_ind[i]` 给出。\n总和为 $\\sum_{j=0}^{i-1} A_{ij} x_j = \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{diag\\_ind}[i]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]}$。\n对角线元素是 $A_{ii} = \\text{val}[\\text{diag\\_ind}[i]]$。\n因此，$x_i$ 的计算公式为：\n$$ x_i = \\frac{1}{\\text{val}[\\text{diag\\_ind}[i]]} \\left( b_i - \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{diag\\_ind}[i]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]} \\right) $$\n间接访问是求和式内部的项 $x_{\\text{col\\_ind}[k]}$。这类项的数量等于行 $i$ 的严格下三角部分的非零条目数。\n令 $\\text{nnz}_i = \\text{row\\_ptr}[i+1] - \\text{row\\_ptr}[i]$ 为行 $i$ 中存储的非零元总数。由于其中一个是对角线条目，因此有 $\\text{nnz}_i - 1$ 个严格下三角条目。每个条目都需要一次间接内存访问。\n因此，行 $i$ 的间接访问次数恰好是 $\\text{nnz}_i - 1$。根据问题的定义，这不仅仅是一个界限，而是一个精确的计数。因此，该界限是紧的。\n\n**情况A的界限：** 每行 $i$ 的间接访问次数为 $\\text{nnz}_i - 1$。\n\n**情况B的分析（隐式单位对角线）**\n在这种情况下，$A_{ii} = 1$ 是隐式的，只存储严格下三角的非零元。求和 $\\sum_{j=0}^{i-1} A_{ij} x_j$ 现在涉及行 $i$ 的所有存储条目。\n总和为 $\\sum_{j=0}^{i-1} A_{ij} x_j = \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{row\\_ptr}[i+1]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]}$。\n$x_i$ 的计算简化为：\n$$ x_i = b_i - \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{row\\_ptr}[i+1]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]} $$\n间接访问仍然是项 $x_{\\text{col\\_ind}[k]}$。求和遍及行 $i$ 的所有存储元素。\n令 $\\text{nnz}_i = \\text{row\\_ptr}[i+1] - \\text{row\\_ptr}[i]$ 为行 $i$ 中存储的非零元数量。由于所有存储的元素都在严格下三角部分，因此每个元素都会导致一次间接内存访问。\n因此，行 $i$ 的间接访问次数恰好是 $\\text{nnz}_i$。和之前一样，这是一个精确的计数，并且界限是紧的。\n\n**情况B的界限：** 每行 $i$ 的间接访问次数为 $\\text{nnz}_i$。\n\n### 任务3和4：实现与验证\n\n实现将包含一个主函数，该函数遍历定义的测试用例。对于每个用例，它首先通过执行稀疏矩阵向量乘积 $A x^{\\star}$ 来构造右端项向量 $b$。然后，它调用一个专门的前向替换求解器。该求解器实现上面推导的递推式，从 $i = 0$ 到 $n-1$ 逐行处理。在计算每个 $x_i$ 的过程中，它将统计使用 `col_ind` 数组中索引对解向量 $x$ 进行查找的次数，从而测量每行的间接访问计数 $m^{(t)}$。同时，根据对角线类型，使用公式 $\\text{nnz}_i - 1$ 或 $\\text{nnz}_i$ 计算每行的理论界限 $u^{(t)}$。最终输出将按规定汇总所有测试用例的测量计数和理论界限。计算出的解 $x$ 的正确性可以通过检查 $A x$ 是否在数值上接近原始的 $b$ 来验证。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and analyze the test cases.\n    \"\"\"\n\n    # Test Case 1: Non-unit diagonal, n = 5\n    case1 = {\n        \"n\": 5,\n        \"row_ptr\": np.array([0, 1, 3, 6, 9, 12]),\n        \"col_ind\": np.array([0, 0, 1, 0, 1, 2, 0, 2, 3, 1, 3, 4]),\n        \"val\": np.array([2.0, 1.0, 3.0, -1.0, 2.0, 4.0, 0.5, -1.0, 2.0, -2.0, 1.5, 5.0]),\n        \"diag_ind\": np.array([0, 2, 5, 8, 11]),\n        \"x_star\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n        \"is_unit_diag\": False\n    }\n\n    # Test Case 2: Unit diagonal, n = 5\n    case2 = {\n        \"n\": 5,\n        \"row_ptr\": np.array([0, 0, 1, 3, 4, 6]),\n        \"col_ind\": np.array([0, 0, 1, 2, 0, 3]),\n        \"val\": np.array([0.25, -1.0, 0.5, 2.0, 1.0, -0.5]),\n        \"diag_ind\": None,\n        \"x_star\": np.array([1.0, -1.0, 2.0, 0.0, 3.0]),\n        \"is_unit_diag\": True\n    }\n\n    # Test Case 3: Non-unit diagonal, n = 6\n    case3 = {\n        \"n\": 6,\n        \"row_ptr\": np.array([0, 1, 3, 6, 10, 11, 14]),\n        \"col_ind\": np.array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 2, 4, 5]),\n        \"val\": np.array([10.0, -3.0, -2.0, 7.0, 5.0, 1.0, -1.0, -1.0, -1.0, 8.0, 2.0, 2.0, -8.0, 4.0]),\n        \"diag_ind\": np.array([0, 2, 5, 9, 10, 13]),\n        \"x_star\": np.array([1.0, 2.0, -1.0, 0.0, 3.0, -2.0]),\n        \"is_unit_diag\": False\n    }\n    \n    test_cases = [case1, case2, case3]\n    \n    final_results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        row_ptr = case[\"row_ptr\"]\n        col_ind = case[\"col_ind\"]\n        val = case[\"val\"]\n        x_star = case[\"x_star\"]\n        is_unit_diag = case[\"is_unit_diag\"]\n        diag_ind = case[\"diag_ind\"]\n        \n        # Helper to compute b = A * x_star for verification\n        def compute_b(n, row_ptr, col_ind, val, x_star, is_unit_diag):\n            b = np.zeros(n)\n            # Matrix-vector product part from CSR data\n            for i in range(n):\n                for k in range(row_ptr[i], row_ptr[i+1]):\n                    j = col_ind[k]\n                    b[i] += val[k] * x_star[j]\n            \n            # Add diagonal contribution if unit diagonal\n            if is_unit_diag:\n                b += x_star # A_ii = 1\n            \n            return b\n\n        b = compute_b(n, row_ptr, col_ind, val, x_star, is_unit_diag)\n\n        # Implementation of forward substitution with indirect access counting\n        def forward_sub_csr(n, row_ptr, col_ind, val, b, diag_ind, is_unit_diag):\n            x = np.zeros(n)\n            measured_access_counts = []\n\n            for i in range(n):\n                # Compute sum over strictly lower triangular part\n                s = 0.0\n                indirect_accesses = 0\n                \n                if is_unit_diag:\n                    # Unit diagonal case: All stored elements are strictly lower\n                    start_k, end_k = row_ptr[i], row_ptr[i+1]\n                    for k in range(start_k, end_k):\n                        j = col_ind[k]\n                        s += val[k] * x[j]\n                        indirect_accesses += 1\n                    \n                    x[i] = b[i] - s\n                else: \n                    # Non-unit diagonal case: Strictly lower part from row_ptr[i] to diag_ind[i]-1\n                    d_idx = diag_ind[i]\n                    start_k, end_k = row_ptr[i], d_idx\n                    for k in range(start_k, end_k):\n                        j = col_ind[k]\n                        s += val[k] * x[j]\n                        indirect_accesses += 1\n                        \n                    x[i] = (b[i] - s) / val[d_idx]\n                \n                measured_access_counts.append(indirect_accesses)\n            \n            return x, measured_access_counts\n\n        x_computed, m_t = forward_sub_csr(n, row_ptr, col_ind, val, b, diag_ind, is_unit_diag)\n        \n        # Verify the solution\n        b_check = compute_b(n, row_ptr, col_ind, val, x_computed, is_unit_diag)\n        if not np.allclose(b, b_check):\n            raise ValueError(f\"Solution verification failed for a test case.\")\n\n        # Compute the theoretical upper bounds for indirect accesses\n        u_t = []\n        for i in range(n):\n            nnz_i = row_ptr[i+1] - row_ptr[i]\n            if is_unit_diag:\n                bound = nnz_i\n            else:\n                bound = nnz_i - 1\n            u_t.append(bound)\n\n        final_results.append([m_t, u_t])\n\n    # Format the final output string exactly as specified.\n    # The `str` function on a list automatically adds brackets and commas.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```",
                "id": "3579221"
            }
        ]
    }