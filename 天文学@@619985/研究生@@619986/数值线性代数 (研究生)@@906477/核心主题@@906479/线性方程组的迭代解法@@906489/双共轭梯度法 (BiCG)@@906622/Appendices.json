{
        "hands_on_practices": [
            {
                "introduction": "掌握双共轭梯度法（Biconjugate Gradient method, BiCG）需要从坚实地把握其迭代机制开始。练习 [@problem_id:3585465] 将引导您对一个小型非对称系统完整执行两轮 BiCG 迭代。通过亲手计算每一步的中间向量和标量，您将具体地理解耦合的短递推关系是如何维持双正交性，并逐步精确化求解过程的。",
                "problem": "考虑在精确算术下，通过执行双共轭梯度（BiCG）法（无预条件）恰好两次迭代来求解非对称线性系统 $A x = b$ 的任务，其中从 $x_{0} = 0$ 开始，并取初始影子残差 $\\hat{r}_0 = r_0$。系统数据如下\n$$\nA \\;=\\; \\begin{pmatrix}\n2  & 1 & 0 \\\\\n0  & 3 & 1 \\\\\n1  & 0 & 2\n\\end{pmatrix},\n\\qquad\nb \\;=\\; \\begin{pmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{pmatrix}.\n$$\n令初始残差为 $r_{0} = b - A x_{0}$。使用标准的实数算术双共轭梯度（BiCG）法（其定义为通过残差序列 $\\{r_k\\}$ 和影子残差序列 $\\{\\hat{r}_k\\}$ 之间的双正交性，以及由三项递推关系驱动的搜索方向 $\\{p_k\\}$ 和 $\\{\\hat{p}_k\\}$ 的耦合短递推）来：\n- 构造并报告在前两次迭代中生成的所有中间标量和向量，包括 $r_{k}$、$\\hat{r}_{k}$、$p_{k}$、$\\hat{p}_{k}$、$v_{k} = A p_{k}$、$\\hat{v}_{k} = A^\\top \\hat{p}_{k}$，以及标量 $\\rho_{k}$、$\\alpha_{k}$、$\\beta_{k}$，连同 $x_{1}$ 和 $x_{2}$。\n- 在每一步验证不发生算法中断，方法是确认所有用作分母的必需内积均为非零。\n\n最后，以简化的解析表达式形式，给出欧几里得范数 $\\|r_{2}\\|_{2}$ 的精确值。不要四舍五入；报告精确值。",
                "solution": "该问题是有效的，因为它是一个定义明确的数值线性代数练习，基于标准的双共轭梯度（BiCG）法，提供了所有必要的数据，且没有内部矛盾或科学缺陷。我们开始解答。\n\n双共轭梯度（BiCG）法是一种用于求解非对称线性系统 $A x = b$ 的迭代算法。该算法生成残差序列 $r_k$ 和影子残差序列 $\\hat{r}_k$，以及相应的搜索方向 $p_k$ 和 $\\hat{p}_k$。其定义属性是残差的双正交性，即对于 $j \\neq k$，有 $\\hat{r}_j^\\top r_k = 0$，以及搜索方向的A-双正交性（或双共轭性），即对于 $j \\neq k$，有 $\\hat{p}_j^\\top A p_k = 0$。\n\n该算法从一个初始猜测 $x_0$ 开始，按以下步骤进行：\n1.  初始化：\n    $r_0 = b - A x_0$\n    选择 $\\hat{r}_0$ (此处, $\\hat{r}_0 = r_0$)\n    $p_0 = r_0$, $\\hat{p}_0 = \\hat{r}_0$\n2.  对于 $k = 0, 1, 2, \\dots$：\n    $\\rho_k = \\hat{r}_k^\\top r_k$\n    $v_k = A p_k$\n    $\\alpha_k = \\rho_k / (\\hat{p}_k^\\top v_k)$\n    $x_{k+1} = x_k + \\alpha_k p_k$\n    $r_{k+1} = r_k - \\alpha_k v_k$\n    $\\hat{r}_{k+1} = \\hat{r}_k - \\alpha_k A^\\top \\hat{p}_k$\n    $\\rho_{k+1} = \\hat{r}_{k+1}^\\top r_{k+1}$\n    $\\beta_k = \\rho_{k+1} / \\rho_k$\n    $p_{k+1} = r_{k+1} + \\beta_k p_k$\n    $\\hat{p}_{k+1} = \\hat{r}_{k+1} + \\beta_k \\hat{p}_k$\n\n我们给定的系统数据为：\n$$A = \\begin{pmatrix} 2  & 1 & 0 \\\\ 0  & 3 & 1 \\\\ 1  & 0 & 2 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n$A$ 的转置是：\n$$A^\\top = \\begin{pmatrix} 2  & 0 & 1 \\\\ 1  & 3 & 0 \\\\ 0  & 1 & 2 \\end{pmatrix}$$\n\n**初始化 ($k=0$)**\n初始猜测为 $x_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n初始残差为 $r_0 = b - A x_0 = b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n初始影子残差取为 $\\hat{r}_0 = r_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n初始搜索方向为 $p_0 = r_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$ 和 $\\hat{p}_0 = \\hat{r}_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n\n**第一次迭代 ($k=0$)**\n我们计算标量 $\\rho_0$：\n$$\\rho_0 = \\hat{r}_0^\\top r_0 = \\begin{pmatrix} 1 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 = 2$$\n向量 $v_0 = A p_0$ 为：\n$$v_0 = A p_0 = \\begin{pmatrix} 2  & 1 & 0 \\\\ 0  & 3 & 1 \\\\ 1  & 0 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 3 \\\\ 1 \\end{pmatrix}$$\n向量 $\\hat{v}_0 = A^\\top \\hat{p}_0$ 为：\n$$\\hat{v}_0 = A^\\top \\hat{p}_0 = \\begin{pmatrix} 2  & 0 & 1 \\\\ 1  & 3 & 0 \\\\ 0  & 1 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 4 \\\\ 1 \\end{pmatrix}$$\n$\\alpha_0$ 的分母为 $\\hat{p}_0^\\top v_0 = \\begin{pmatrix} 1 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 3 \\\\ 1 \\end{pmatrix} = 3+3 = 6$。\n*不中断检查：* $\\rho_0 = 2 \\neq 0$ 和 $\\hat{p}_0^\\top A p_0 = 6 \\neq 0$ 均成立，因此方法可以继续。\n步长 $\\alpha_0$ 为：\n$$\\alpha_0 = \\frac{\\rho_0}{\\hat{p}_0^\\top v_0} = \\frac{2}{6} = \\frac{1}{3}$$\n我们更新解向量以获得 $x_1$：\n$$x_1 = x_0 + \\alpha_0 p_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 1/3 \\\\ 0 \\end{pmatrix}$$\n新的残差 $r_1$ 为：\n$$r_1 = r_0 - \\alpha_0 v_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 3 \\\\ 3 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1-1 \\\\ 1-1 \\\\ 0-1/3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1/3 \\end{pmatrix}$$\n新的影子残差 $\\hat{r}_1$ 为：\n$$\\hat{r}_1 = \\hat{r}_0 - \\alpha_0 \\hat{v}_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 2 \\\\ 4 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1-2/3 \\\\ 1-4/3 \\\\ 0-1/3 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ -1/3 \\end{pmatrix}$$\n我们为下一步计算 $\\rho_1$：\n$$\\rho_1 = \\hat{r}_1^\\top r_1 = \\begin{pmatrix} 1/3 & -1/3 & -1/3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ -1/3 \\end{pmatrix} = 0 + 0 + \\frac{1}{9} = \\frac{1}{9}$$\n标量 $\\beta_0$ 为：\n$$\\beta_0 = \\frac{\\rho_1}{\\rho_0} = \\frac{1/9}{2} = \\frac{1}{18}$$\n新的搜索方向 $p_1$ 和 $\\hat{p}_1$ 为：\n$$p_1 = r_1 + \\beta_0 p_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1/3 \\end{pmatrix} + \\frac{1}{18} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1/18 \\\\ 1/18 \\\\ -6/18 \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 1 \\\\ 1 \\\\ -6 \\end{pmatrix}$$\n$$\\hat{p}_1 = \\hat{r}_1 + \\beta_0 \\hat{p}_0 = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ -1/3 \\end{pmatrix} + \\frac{1}{18} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 6/18 + 1/18 \\\\ -6/18 + 1/18 \\\\ -6/18 \\end{pmatrix} = \\begin{pmatrix} 7/18 \\\\ -5/18 \\\\ -6/18 \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 7 \\\\ -5 \\\\ -6 \\end{pmatrix}$$\n\n**第二次迭代 ($k=1$)**\n我们从 $\\rho_1 = 1/9$ 开始。\n向量 $v_1 = A p_1$ 为：\n$$v_1 = A p_1 = \\begin{pmatrix} 2  & 1 & 0 \\\\ 0  & 3 & 1 \\\\ 1  & 0 & 2 \\end{pmatrix} \\frac{1}{18} \\begin{pmatrix} 1 \\\\ 1 \\\\ -6 \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 2(1)+1(1) \\\\ 3(1)+1(-6) \\\\ 1(1)+2(-6) \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 3 \\\\ -3 \\\\ -11 \\end{pmatrix}$$\n向量 $\\hat{v}_1 = A^\\top \\hat{p}_1$ 为：\n$$\\hat{v}_1 = A^\\top \\hat{p}_1 = \\begin{pmatrix} 2  & 0 & 1 \\\\ 1  & 3 & 0 \\\\ 0  & 1 & 2 \\end{pmatrix} \\frac{1}{18} \\begin{pmatrix} 7 \\\\ -5 \\\\ -6 \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 2(7)+1(-6) \\\\ 1(7)+3(-5) \\\\ 1(-5)+2(-6) \\end{pmatrix} = \\frac{1}{18} \\begin{pmatrix} 8 \\\\ -8 \\\\ -17 \\end{pmatrix}$$\n$\\alpha_1$ 的分母为 $\\hat{p}_1^\\top v_1 = \\left( \\frac{1}{18} \\begin{pmatrix} 7 & -5 & -6 \\end{pmatrix} \\right) \\left( \\frac{1}{18} \\begin{pmatrix} 3 \\\\ -3 \\\\ -11 \\end{pmatrix} \\right) = \\frac{1}{324} (21+15+66) = \\frac{102}{324} = \\frac{17}{54}$。\n*不中断检查：* 我们有 $\\rho_1 = 1/9 \\neq 0$ 和 $\\hat{p}_1^\\top A p_1 = 17/54 \\neq 0$。该方法无中断地继续进行。\n步长 $\\alpha_1$ 为：\n$$\\alpha_1 = \\frac{\\rho_1}{\\hat{p}_1^\\top v_1} = \\frac{1/9}{17/54} = \\frac{1}{9} \\cdot \\frac{54}{17} = \\frac{6}{17}$$\n我们更新解向量以获得 $x_2$：\n$$x_2 = x_1 + \\alpha_1 p_1 = \\begin{pmatrix} 1/3 \\\\ 1/3 \\\\ 0 \\end{pmatrix} + \\frac{6}{17} \\left(\\frac{1}{18} \\begin{pmatrix} 1 \\\\ 1 \\\\ -6 \\end{pmatrix}\\right) = \\begin{pmatrix} 1/3 \\\\ 1/3 \\\\ 0 \\end{pmatrix} + \\frac{1}{51} \\begin{pmatrix} 1 \\\\ 1 \\\\ -6 \\end{pmatrix} = \\begin{pmatrix} 17/51+1/51 \\\\ 17/51+1/51 \\\\ -6/51 \\end{pmatrix} = \\begin{pmatrix} 18/51 \\\\ 18/51 \\\\ -6/51 \\end{pmatrix} = \\frac{1}{17} \\begin{pmatrix} 6 \\\\ 6 \\\\ -2 \\end{pmatrix}$$\n新的残差 $r_2$ 为：\n$$r_2 = r_1 - \\alpha_1 v_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1/3 \\end{pmatrix} - \\frac{6}{17} \\left(\\frac{1}{18} \\begin{pmatrix} 3 \\\\ -3 \\\\ -11 \\end{pmatrix}\\right) = \\begin{pmatrix} 0 \\\\ 0 \\\\ -1/3 \\end{pmatrix} - \\frac{1}{51} \\begin{pmatrix} 3 \\\\ -3 \\\\ -11 \\end{pmatrix} = \\begin{pmatrix} -3/51 \\\\ 3/51 \\\\ -17/51+11/51 \\end{pmatrix} = \\begin{pmatrix} -3/51 \\\\ 3/51 \\\\ -6/51 \\end{pmatrix} = \\frac{1}{17} \\begin{pmatrix} -1 \\\\ 1 \\\\ -2 \\end{pmatrix}$$\n我们按要求报告在这次迭代中生成的其他量。新的影子残差 $\\hat{r}_2$ 为：\n$$\\hat{r}_2 = \\hat{r}_1 - \\alpha_1 \\hat{v}_1 = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ -1/3 \\end{pmatrix} - \\frac{6}{17} \\left(\\frac{1}{18} \\begin{pmatrix} 8 \\\\ -8 \\\\ -17 \\end{pmatrix}\\right) = \\begin{pmatrix} 1/3 \\\\ -1/3 \\\\ -1/3 \\end{pmatrix} - \\frac{1}{51} \\begin{pmatrix} 8 \\\\ -8 \\\\ -17 \\end{pmatrix} = \\begin{pmatrix} 17/51-8/51 \\\\ -17/51+8/51 \\\\ -17/51+17/51 \\end{pmatrix} = \\begin{pmatrix} 9/51 \\\\ -9/51 \\\\ 0 \\end{pmatrix} = \\frac{1}{17} \\begin{pmatrix} 3 \\\\ -3 \\\\ 0 \\end{pmatrix}$$\n最后，我们计算 $\\rho_2$ 和 $\\beta_1$：\n$$\\rho_2 = \\hat{r}_2^\\top r_2 = \\left( \\frac{1}{17} \\begin{pmatrix} 3 & -3 & 0 \\end{pmatrix} \\right) \\left( \\frac{1}{17} \\begin{pmatrix} -1 \\\\ 1 \\\\ -2 \\end{pmatrix} \\right) = \\frac{1}{289}(-3-3+0) = -\\frac{6}{289}$$\n$$\\beta_1 = \\frac{\\rho_2}{\\rho_1} = \\frac{-6/289}{1/9} = -\\frac{54}{289}$$\n\n题目要求 $r_2$ 的欧几里得范数的精确值。\n$$\\|r_2\\|_2 = \\left\\| \\frac{1}{17} \\begin{pmatrix} -1 \\\\ 1 \\\\ -2 \\end{pmatrix} \\right\\|_2 = \\frac{1}{17} \\left\\| \\begin{pmatrix} -1 \\\\ 1 \\\\ -2 \\end{pmatrix} \\right\\|_2 = \\frac{1}{17} \\sqrt{(-1)^2 + 1^2 + (-2)^2} = \\frac{1}{17} \\sqrt{1+1+4} = \\frac{\\sqrt{6}}{17}$$",
                "answer": "$$\n\\boxed{\\frac{\\sqrt{6}}{17}}\n$$",
                "id": "3585465"
            },
            {
                "introduction": "BiCG 方法的一个关键挑战是可能出现的“真性崩溃”（true breakdown），即算法因双正交性乘积 $\\rho_k$ 为零而终止。这个思想实验 [@problem_id:3585500] 旨在模拟这样一种情况，展示崩溃是如何发生的，并引入“前瞻”策略（look-ahead strategy）作为一种补救措施。解决这个问题有助于揭示算法的局限性以及为确保其稳健性而发展的复杂技巧。",
                "problem": "考虑线性系统 $A x = b$，其中\n$$\nA \\;=\\; \\begin{pmatrix}\n0  & 1 & 0 \\\\\n0  & 0 & 1 \\\\\n1  & 0 & 0\n\\end{pmatrix}, \n\\quad\nb \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix},\n\\quad\nx_0 \\;=\\; \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix},\n\\quad\n\\hat{r}_0 \\;=\\; \\begin{pmatrix} 1 \\\\ 4 \\\\ 2 \\end{pmatrix}.\n$$\n我们使用双共轭梯度法 (BiCG)，其标准定义如下：\n- 残差 $r_k = b - A x_k$ 和影子残差 $\\hat{r}_k$。\n- 双正交乘积 $\\rho_k = \\hat{r}_k^\\top r_k$。\n- 步长 $\\alpha_k = \\rho_k / \\left(\\hat{p}_k^\\top A p_k\\right)$，其中 $p_k$ 和 $\\hat{p}_k$ 是由两项 BiCG 递推定义的右和左搜索方向。\n\n对于这个示例问题，设 $p_0 = r_0$ 和 $\\hat{p}_0 = \\hat{r}_0$，并执行第一次 BiCG 更新以得到 $x_1 = x_0 + \\alpha_0 p_0$、$r_1 = r_0 - \\alpha_0 A p_0$ 和 $\\hat{r}_1 = \\hat{r}_0 - \\alpha_0 A^\\top \\hat{p}_0$。你会发现迭代遇到了崩溃，即 $\\rho_1 = \\hat{r}_1^\\top r_1 = 0$，而 $r_1$ 和 $\\hat{r}_1$ 都非零。\n\n为了继续，在迭代 $k=0$ 时通过更新执行一个二阶前瞻步\n$$\nx_1^{\\mathrm{LA}} \\;=\\; x_0 \\;+\\; \\tau_1\\, p_0 \\;+\\; \\tau_2\\, A p_0,\n$$\n使得相应的残差变为\n$$\nr_1^{\\mathrm{LA}} \\;=\\; r_0 \\;-\\; \\tau_1\\, A p_0 \\;-\\; \\tau_2\\, A^2 p_0.\n$$\n对 $k=0$ 时的前两个左克雷洛夫基向量施加两个双正交条件，\n$$\n\\hat{r}_0^\\top r_1^{\\mathrm{LA}} \\;=\\; 0,\n\\qquad\n\\left(A^\\top \\hat{r}_0\\right)^\\top r_1^{\\mathrm{LA}} \\;=\\; 1,\n$$\n这强制要求前瞻残差与 $\\hat{r}_0$ 正交，并被归一化以使其与 $A^\\top\\hat{r}_0$ 的耦合非零。\n\n根据基本原理和给定数据，推导出关于 $\\tau_1$ 和 $\\tau_2$ 的结果线性系统，解析地求解它，并将标量 $\\tau_2$ 报告为一个精确数（不要四舍五入）。",
                "solution": "我们首先回顾双共轭梯度法 (BiCG) 的基本定义。给定一个非对称矩阵 $A$，BiCG 维持两个耦合序列：\n- 右残差 $r_k = b - A x_k$ 和右搜索方向 $p_k$，\n- 左残差（影子残差）$\\hat{r}_k$ 和左搜索方向 $\\hat{p}_k$，\n其双正交条件由 $\\rho_k = \\hat{r}_k^\\top r_k$ 和标量更新\n$$\n\\alpha_k \\;=\\; \\frac{\\rho_k}{\\hat{p}_k^\\top A p_k}.\n$$\n在第一步，我们取 $p_0 = r_0$ 和 $\\hat{p}_0 = \\hat{r}_0$，这在初始化时是有效的。更新公式则为：\n$$\nx_1 \\;=\\; x_0 + \\alpha_0 p_0, \n\\qquad\nr_1 \\;=\\; r_0 - \\alpha_0 A p_0,\n\\qquad\n\\hat{r}_1 \\;=\\; \\hat{r}_0 - \\alpha_0 A^\\top \\hat{p}_0.\n$$\n\n我们现在根据数据计算具体量。首先，$x_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$ 意味着 $r_0 = b - A x_0 = b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。由于 $p_0 = r_0$，我们有 $A p_0 = A r_0 = A \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$，这正是 $A$ 的第一列：\n$$\nA r_0 \\;=\\; \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}.\n$$\n接下来，我们计算初始双正交乘积及其分母：\n$$\n\\rho_0 \\;=\\; \\hat{r}_0^\\top r_0 \\;=\\; \\begin{pmatrix} 1 & 4 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\;=\\; 1,\n$$\n$$\n\\hat{p}_0^\\top A p_0 \\;=\\; \\hat{r}_0^\\top A r_0 \\;=\\; \\begin{pmatrix} 1 & 4 & 2 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\;=\\; 2.\n$$\n因此，第一步的步长是\n$$\n\\alpha_0 \\;=\\; \\frac{\\rho_0}{\\hat{p}_0^\\top A p_0} \\;=\\; \\frac{1}{2}.\n$$\n因此\n$$\nx_1 \\;=\\; x_0 + \\alpha_0 p_0 \\;=\\; \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} \\frac{1}{2} \\\\ 0 \\\\ 0 \\end{pmatrix},\n$$\n$$\nr_1 \\;=\\; r_0 - \\alpha_0 A p_0 \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ -\\frac{1}{2} \\end{pmatrix}.\n$$\n对于影子残差，我们计算 $A^\\top \\hat{p}_0 = A^\\top \\hat{r}_0$。由于\n$$\nA^\\top \\;=\\; \\begin{pmatrix}\n0 & 0 & 1 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0\n\\end{pmatrix},\n$$\n我们得到\n$$\nA^\\top \\hat{r}_0 \\;=\\; \n\\begin{pmatrix}\n0 & 0 & 1 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 4 \\\\ 2 \\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix} 2 \\\\ 1 \\\\ 4 \\end{pmatrix}.\n$$\n因此\n$$\n\\hat{r}_1 \\;=\\; \\hat{r}_0 - \\alpha_0 A^\\top \\hat{p}_0 \\;=\\; \\begin{pmatrix} 1 \\\\ 4 \\\\ 2 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 2 \\\\ 1 \\\\ 4 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 0 \\\\ \\frac{7}{2} \\\\ 0 \\end{pmatrix}.\n$$\n下一个双正交乘积是\n$$\n\\rho_1 \\;=\\; \\hat{r}_1^\\top r_1 \\;=\\; \\begin{pmatrix} 0 & \\frac{7}{2} & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -\\frac{1}{2} \\end{pmatrix} \\;=\\; 0,\n$$\n这是一个崩溃（标量积为零），尽管 $r_1$ 和 $\\hat{r}_1$ 都不是零向量。\n\n为了继续这个过程，我们在迭代 $k=0$ 时调用一个二阶前瞻步。定义\n$$\nx_1^{\\mathrm{LA}} \\;=\\; x_0 + \\tau_1 p_0 + \\tau_2 A p_0,\n$$\n因此相应的残差变为\n$$\nr_1^{\\mathrm{LA}} \\;=\\; b - A x_1^{\\mathrm{LA}} \\;=\\; r_0 - \\tau_1 A p_0 - \\tau_2 A^2 p_0.\n$$\n我们可以显式地计算 $A^2 p_0$。我们已有 $A p_0 = A r_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。因此\n$$\nA^2 p_0 \\;=\\; A \\left(A r_0\\right) \\;=\\; A \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}.\n$$\n结果是，\n$$\nr_1^{\\mathrm{LA}} \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\tau_1 \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\tau_2 \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 1 \\\\ -\\tau_2 \\\\ -\\tau_1 \\end{pmatrix}.\n$$\n我们施加两个双正交条件\n$$\n\\hat{r}_0^\\top r_1^{\\mathrm{LA}} \\;=\\; 0,\n\\qquad\n\\left(A^\\top \\hat{r}_0\\right)^\\top r_1^{\\mathrm{LA}} \\;=\\; 1.\n$$\n使用 $\\hat{r}_0 = \\begin{pmatrix} 1 \\\\ 4 \\\\ 2 \\end{pmatrix}$ 和 $A^\\top \\hat{r}_0 = \\begin{pmatrix} 2 \\\\ 1 \\\\ 4 \\end{pmatrix}$，这些内积变为\n$$\n\\hat{r}_0^\\top r_1^{\\mathrm{LA}} \\;=\\; 1 \\cdot 1 \\;+\\; 4 \\cdot (-\\tau_2) \\;+\\; 2 \\cdot (-\\tau_1) \\;=\\; 1 - 4 \\tau_2 - 2 \\tau_1,\n$$\n$$\n\\left(A^\\top \\hat{r}_0\\right)^\\top r_1^{\\mathrm{LA}} \\;=\\; 2 \\cdot 1 \\;+\\; 1 \\cdot (-\\tau_2) \\;+\\; 4 \\cdot (-\\tau_1) \\;=\\; 2 - \\tau_2 - 4 \\tau_1.\n$$\n因此这些条件构成了线性系统\n$$\n1 - 4 \\tau_2 - 2 \\tau_1 \\;=\\; 0,\n\\qquad\n2 - \\tau_2 - 4 \\tau_1 \\;=\\; 1.\n$$\n等价地，\n$$\n2 \\tau_1 + 4 \\tau_2 \\;=\\; 1,\n\\qquad\n4 \\tau_1 + \\tau_2 \\;=\\; 1.\n$$\n求解时，将第一个方程乘以 $2$ 得到 $4 \\tau_1 + 8 \\tau_2 = 2$。减去第二个方程以消去 $\\tau_1$：\n$$\n(4 \\tau_1 + 8 \\tau_2) - (4 \\tau_1 + \\tau_2) \\;=\\; 2 - 1 \n\\;\\;\\Longrightarrow\\;\\;\n7 \\tau_2 \\;=\\; 1 \n\\;\\;\\Longrightarrow\\;\\;\n\\tau_2 \\;=\\; \\frac{1}{7}.\n$$\n回代到 $4 \\tau_1 + \\tau_2 = 1$ 中得到 $4 \\tau_1 + \\frac{1}{7} = 1$，因此 $4 \\tau_1 = \\frac{6}{7}$ 且 $\\tau_1 = \\frac{3}{14}$。因此，前瞻残差为\n$$\nr_1^{\\mathrm{LA}} \\;=\\; \\begin{pmatrix} 1 \\\\ -\\frac{1}{7} \\\\ -\\frac{3}{14} \\end{pmatrix},\n$$\n并且强制的耦合满足\n$$\n\\left(A^\\top \\hat{r}_0\\right)^\\top r_1^{\\mathrm{LA}} \\;=\\; 1.\n$$\n这在 $\\rho_1 = 0$ 处的崩溃之后提供了一个可行的延续方案。\n\n所求的标量是 $\\tau_2 = \\frac{1}{7}$。",
                "answer": "$$\\boxed{\\frac{1}{7}}$$",
                "id": "3585500"
            },
            {
                "introduction": "除了纸笔计算，理解 BiCG 方法还需要在计算环境中探索其动态行为。这个编程练习 [@problem_id:3585435] 通过考察残差与矩阵特征系统之间的对齐关系，深入研究了该方法对初始条件的敏感性。通过实现并运行这个受控的数值实验，您将观察到这种对齐关系对收敛速度和稳定性的巨大影响，从而在代数理论与实际性能之间架起一座桥梁。",
                "problem": "考虑使用双共轭梯度法（Biconjugate Gradient method, BiCG）求解线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实数非对称方阵，$b \\in \\mathbb{R}^n$ 是一个向量。BiCG 方法是一种克雷洛夫子空间法，其特征在于一个 Petrov-Galerkin 条件：残差关于由 $A$ 生成的右克雷洛夫子空间与由 $A^\\top$ 生成的左克雷洛夫子空间之间的双线性形式是正交的。该方法在迭代中演化 $(x_k, r_k, \\hat{r}_k)$，其中 $r_k = b - A x_k$ 是残差，$\\hat{r}_k$ 是影子残差，并利用从涉及 $A$ 和 $A^\\top$ 的内积中获得的标量。如果某些内积消失（精确为零或由于有限精度而实际上为零），该方法可能会崩溃，导致未定义的步骤。您的任务是实现一个受控数值实验，以说明 BiCG 收敛性对残差和影子残差与 $A$ 的左右特征向量的初始对齐方式的敏感依赖性。\n\n您必须通过 $A = S \\Lambda S^{-1}$ 构建一个可对角化的非正规矩阵 $A$，其谱为实数。其中 $S \\in \\mathbb{R}^{n \\times n}$ 是可逆矩阵，$\\Lambda \\in \\mathbb{R}^{n \\times n}$ 是对角矩阵，其对角线上的元素是互不相同的正数。设 $n = 10$，并令 $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_n)$，其中 $\\lambda_i$ 是互不相同的严格正数。使用固定的随机种子生成 $S$，以使实验完全可复现。\n\n定义与 $\\lambda_i$ 相关的右特征向量 $v_i = S e_i$ 和左特征向量 $w_i$（即 $S^{-\\top}$ 的第 $i$ 列），即 $w_i = S^{-\\top} e_i$，其中 $e_i$ 是 $\\mathbb{R}^n$ 中的第 $i$ 个标准基向量。选择索引 $i^\\star = 3$，并设置 $b = v_{i^\\star}$，$x_0 = 0$，$r_0 = b$。考虑以下实验设计：\n\n- 完美对齐情况：设置初始影子残差 $\\hat{r}_0 = w_{i^\\star}$，并运行 BiCG，直到相对残差 $\\|r_k\\|_2 / \\|b\\|_2$ 至多为 $\\tau = 10^{-12}$ 或达到最大迭代次数 $m = 2 n$。对于 BiCG 产生的任何必须求逆的标量分母，使用崩溃检测阈值 $\\delta = 10^{-15}$。记录收敛时的迭代次数以及是否发生崩溃。\n\n- 扰动情况：对于 $\\varepsilon \\in \\{10^{-12}, 10^{-6}, 10^{-2}\\}$，每个 $\\varepsilon$ 执行 $T = 20$ 次独立试验，每次试验取 $\\hat{r}_0 = w_{i^\\star} + \\varepsilon \\xi$，其中 $\\xi \\in \\mathbb{R}^n$ 是一个具有独立标准正态分布项的向量，在相同的固定随机种子下生成。\n    - 对于每次试验，使用相同的停止容差 $\\tau$、迭代上限 $m$ 和崩溃阈值 $\\delta$ 运行 BiCG。\n    - 对于每个 $\\varepsilon$，计算成功运行（即在没有崩溃的情况下达到容差）的平均迭代次数；如果给定 $\\varepsilon$ 的所有试验都崩溃，则将平均值定义为 $-1.0$。同时记录 $T$ 次试验中的总崩溃次数。\n\n- 真实崩溃边缘情况：设置 $\\hat{r}_0 = w_j$，其中 $j \\neq i^\\star$（选择 $j = (i^\\star \\bmod n) + 1$ 以确保 $j \\neq i^\\star$），并运行 BiCG 一次。在这种情况下，$\\hat{r}_0^\\top r_0 = 0$，方法在第一次迭代时会遇到真实崩溃。记录是否检测到崩溃的布尔值。\n\n您的程序必须直接根据与 $A$ 和 $A^\\top$ 的矩阵向量乘积来实现 BiCG 方法，并且必须包含对任何所需标量分母的绝对值低于 $\\delta$ 时的显式崩溃检测。\n\n测试套件规范：\n- 矩阵大小：$n = 10$。\n- 特征值：$\\lambda_i$ 是互不相同的严格正数，确定性地选择。\n- 随机种子：固定，并用于构建 $S$ 及所有扰动。\n- 容差：相对残差容差 $\\tau = 10^{-12}$，最大迭代次数 $m = 2 n$，崩溃阈值 $\\delta = 10^{-15}$。\n- 情况：\n    1. 完美对齐：$\\hat{r}_0 = w_{i^\\star}$。\n    2. 扰动：$\\varepsilon \\in \\{10^{-12}, 10^{-6}, 10^{-2}\\}$，每个 $T=20$ 次试验。\n    3. 真实崩溃：$\\hat{r}_0 = w_j$，其中 $j \\neq i^\\star$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表。该列表必须按顺序包含：\n    1. 完美对齐情况下的整数迭代次数。\n    2. 完美对齐情况下的布尔崩溃标志。\n    3. $\\varepsilon = 10^{-12}$ 时成功运行的浮点平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    4. $\\varepsilon = 10^{-12}$ 时 $T$ 次试验中的整数崩溃次数。\n    5. $\\varepsilon = 10^{-6}$ 时成功运行的浮点平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    6. $\\varepsilon = 10^{-6}$ 时 $T$ 次试验中的整数崩溃次数。\n    7. $\\varepsilon = 10^{-2}$ 时成功运行的浮点平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    8. $\\varepsilon = 10^{-2}$ 时 $T$ 次试验中的整数崩溃次数。\n    9. 真实崩溃边缘情况下的布尔崩溃标志。\n\n输出列表中的所有条目必须是基本类型：整数、浮点数和布尔值。此问题不涉及物理单位。也不涉及角度。",
                "solution": "该问题要求实现一个数值实验，以展示双共轭梯度（BiCG）方法收敛性对初始残差向量和影子残差向量对齐方式的敏感性。这涉及构建一个具有已知特征系统的非正规矩阵，并使用旨在探究其稳定性和崩溃条件的特定初始向量来运行 BiCG。\n\nBiCG 方法是求解大型、稀疏、非对称线性方程组 $A x = b$ 的一种迭代算法。它是一种克雷洛夫子空间法，生成一系列近似解 $x_k$，使得残差 $r_k = b - A x_k$ 满足 Petrov-Galerkin 条件。此条件要求残差 $r_k$ 与由矩阵转置 $A^\\top$ 生成的克雷洛夫子空间正交。具体来说，$r_k \\perp \\mathcal{K}_k(A^\\top, \\hat{r}_0)$，其中 $\\mathcal{K}_k(A^\\top, \\hat{r}_0) = \\mathrm{span}\\{\\hat{r}_0, A^\\top \\hat{r}_0, \\dots, (A^\\top)^{k-1} \\hat{r}_0\\}$ 是“左”或“影子”克雷洛夫子空间，而 $\\hat{r}_0$ 是一个选定的初始影子残差。迭代解 $x_k$ 从仿射克雷洛夫子空间 $x_0 + \\mathcal{K}_k(A, r_0)$ 中选取。\n\n标准的 BiCG 算法可概括如下。给定初始猜测 $x_0$ 和初始影子残差 $\\hat{r}_0$：\n\n1.  初始化：\n    $r_0 = b - A x_0$\n    $p_0 = r_0$\n    $\\hat{p}_0 = \\hat{r}_0$\n    $\\rho_0 = \\hat{r}_0^\\top r_0$\n\n2.  对 $k = 0, 1, 2, \\ldots$ 进行迭代：\n    a.  $v_k = A p_k$\n    b.  $\\alpha_k = \\frac{\\rho_k}{\\hat{p}_k^\\top v_k}$\n    c.  $x_{k+1} = x_k + \\alpha_k p_k$\n    d.  $r_{k+1} = r_k - \\alpha_k v_k$\n    e.  $\\hat{r}_{k+1} = \\hat{r}_k - \\alpha_k A^\\top\\hat{p}_k$\n    f.  $\\rho_{k+1} = \\hat{r}_{k+1}^\\top r_{k+1}$\n    g.  $\\beta_k = \\frac{\\rho_{k+1}}{\\rho_k}$\n    h.  $p_{k+1} = r_{k+1} + \\beta_k p_k$\n    i.  $\\hat{p}_{k+1} = \\hat{r}_{k+1} + \\beta_k \\hat{p}_k$\n\n该算法在每次迭代中需要对两个标量进行求逆：$\\rho_k = \\hat{r}_k^\\top r_k$ 和 $\\hat{p}_k^\\top A p_k$。如果这两个量中的任何一个为零（或在数值上接近零），算法就会崩溃。\n-   当 $\\rho_k \\approx 0$ 时发生的崩溃通常被称为“真实”崩溃。它意味着新的残差 $r_k$ 与影子残差 $\\hat{r}_k$ 近似正交。\n-   当 $\\hat{p}_k^\\top A p_k \\approx 0$ 时发生的崩溃是一种“Lanczos型”崩溃。\n\n该实验旨在通过仔细选择矩阵 $A$ 和初始向量来研究这些崩溃条件。矩阵 $A$ 被构建为 $A = S \\Lambda S^{-1}$，其中 $\\Lambda$ 是由特征值 $\\lambda_i$ 构成的对角矩阵。$S$ 的列，记为 $v_i$，是 $A$ 的右特征向量；$S^{-\\top}$ 的列，记为 $w_i$，是 $A$ 的左特征向量。它们满足 $A v_i = \\lambda_i v_i$ 和 $A^\\top w_i = \\lambda_i w_i$。这些向量的一个关键性质是它们的双正交性：$w_j^\\top v_i = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克δ函数。\n\n实验设置初始残差 $r_0 = b = v_{i^\\star}$，其中 $i^\\star$ 是一个选定的索引。然后改变初始影子残差 $\\hat{r}_0$。\n\n**完美对齐情况：** 我们设置 $\\hat{r}_0 = w_{i^\\star}$。初始内积为 $\\rho_0 = \\hat{r}_0^\\top r_0 = w_{i^\\star}^\\top v_{i^\\star} = 1$。由于 $r_0$ 是一个特征向量，对于任何 $k \\geq 1$，克雷洛夫子空间 $\\mathcal{K}_k(A, r_0)$ 都是一维的。精确解是 $x = (1/\\lambda_{i^\\star}) v_{i^\\star}$，BiCG 应该在单次迭代中找到一个与 $v_{i^\\star}$ 成比例的解。残差 $r_1$ 应该变为零（或在数值上可忽略不计），从而在一步内收敛。\n\n**真实崩溃边缘情况：** 我们设置 $\\hat{r}_0 = w_j$，其中 $j \\neq i^\\star$。由于双正交性，初始内积为 $\\rho_0 = \\hat{r}_0^\\top r_0 = w_j^\\top v_{i^\\star} = 0$。这在计算 $\\beta_{-1}$（名义上）或在某些实现中尝试计算 $\\alpha_0$ 时，会在第0次迭代时强制立即崩溃。在我们选择的算法中，由于 $\\rho_0$ 为零，这会导致初始崩溃。\n\n**扰动情况：** 我们设置 $\\hat{r}_0 = w_{i^\\star} + \\varepsilon \\xi$，其中 $\\xi$ 是一个随机向量。对于非常小的 $\\varepsilon$，$\\hat{r}_0$ 与 $w_{i^\\star}$ 近似对齐，但包含了其他左特征向量的微小分量。\n$\\rho_0 = (w_{i^\\star} + \\varepsilon \\xi)^\\top v_{i^\\star} = w_{i^\\star}^\\top v_{i^\\star} + \\varepsilon \\xi^\\top v_{i^\\star} = 1 + \\varepsilon (\\xi^\\top v_{i^\\star})$。\n虽然 $\\rho_0$ 不为零，但后续的迭代量 $\\rho_k$ 可能会变得非常小，导致接近崩溃的条件。这可能引起数值不稳定性，表现为不稳定的收敛或在几次迭代后崩溃。随着 $\\varepsilon$ 的增加，$\\hat{r}_0$ 变得更像一个“通用”向量，BiCG 的性能预计会变得更典型，在一定的迭代次数后收敛，该迭代次数与 $A$ 的条件数及其特征值的分布有关，对于 $n=10$ 来说，这个次数应该很小。该实验通过测量不同扰动幅度 $\\varepsilon$ 下的平均迭代次数和崩溃频率来量化此行为。\n\n该实现将构建指定的矩阵 $A \\in \\mathbb{R}^{10 \\times 10}$，执行 BiCG 算法，同时仔细监控分母 $\\rho_k$ 和 $\\hat{p}_k^\\top A p_k$，并记录每种实验情况的结果。这将为 BiCG 方法的理论性质和失效模式提供定量的证明。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef run_bicg(A, b, x0, r0_hat, tol, max_iter, breakdown_thresh):\n    \"\"\"\n    Implements the Biconjugate Gradient (BiCG) method.\n    \n    Returns:\n        (int, bool): A tuple containing the number of iterations and a boolean breakdown flag.\n    \"\"\"\n    x = x0.copy()\n    r = b - A @ x\n    r_hat = r0_hat.copy()\n\n    norm_b = np.linalg.norm(b)\n    if norm_b == 0.0:\n        return 0, False\n\n    rho = np.dot(r_hat, r)\n    if abs(rho)  breakdown_thresh:\n        return 0, True  # Initial breakdown\n\n    p = r.copy()\n    p_hat = r_hat.copy()\n    A_T = A.T\n\n    for k in range(max_iter):\n        v = A @ p\n        denom_alpha = np.dot(p_hat, v)\n\n        if abs(denom_alpha)  breakdown_thresh:\n            return k, True\n\n        alpha = rho / denom_alpha\n        x += alpha * p\n        r -= alpha * v\n        \n        if np.linalg.norm(r) / norm_b = tol:\n            return k + 1, False\n\n        r_hat -= alpha * (A_T @ p_hat)\n\n        rho_next = np.dot(r_hat, r)\n        \n        if abs(rho_next)  breakdown_thresh:\n            # Breakdown detected after a successful step\n            return k + 1, True\n\n        beta = rho_next / rho\n        p = r + beta * p\n        p_hat = r_hat + beta * p_hat\n        rho = rho_next\n\n    return max_iter, False # Failed to converge within max_iter\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print results.\n    \"\"\"\n    # Test suite specification\n    n = 10\n    i_star = 3\n    i_star_idx = i_star - 1\n    tau = 1e-12\n    m = 2 * n\n    delta = 1e-15\n    epsilons = [1e-12, 1e-6, 1e-2]\n    T = 20\n    seed = 42\n    \n    rng = np.random.default_rng(seed)\n\n    # Construct the matrix A\n    Lambda_diag = np.arange(1.0, n + 1.0)\n    Lambda = np.diag(Lambda_diag)\n    S = rng.random((n, n))\n    S_inv = np.linalg.inv(S)\n    A = S @ Lambda @ S_inv\n    \n    # Get right and left eigenvectors\n    S_inv_T = S_inv.T\n    v_istar = S[:, i_star_idx]\n    w_istar = S_inv_T[:, i_star_idx]\n    \n    # Common setup\n    b = v_istar.copy()\n    x0 = np.zeros(n)\n    \n    results = []\n\n    # Case 1: Perfect alignment\n    r0_hat_perfect = w_istar.copy()\n    iters_perfect, breakdown_perfect = run_bicg(A, b, x0, r0_hat_perfect, tau, m, delta)\n    results.extend([iters_perfect, breakdown_perfect])\n\n    # Case 2: Perturbation cases\n    for eps in epsilons:\n        total_iterations = 0\n        successful_runs = 0\n        breakdown_count = 0\n        \n        for _ in range(T):\n            xi = rng.standard_normal(n)\n            r0_hat_pert = w_istar + eps * xi\n            iters, breakdown = run_bicg(A, b, x0, r0_hat_pert, tau, m, delta)\n            \n            if breakdown:\n                breakdown_count += 1\n            else:\n                successful_runs += 1\n                total_iterations += iters\n        \n        if successful_runs > 0:\n            avg_iters = float(total_iterations) / successful_runs\n        else:\n            avg_iters = -1.0\n            \n        results.extend([avg_iters, breakdown_count])\n\n    # Case 3: True breakdown edge case\n    j = (i_star % n) + 1\n    j_idx = j - 1\n    w_j = S_inv_T[:, j_idx]\n    \n    r0_hat_breakdown = w_j.copy()\n    _, breakdown_true = run_bicg(A, b, x0, r0_hat_breakdown, tau, m, delta)\n    results.append(breakdown_true)\n\n    # Format and print the final output\n    print(f\"[{results[0]},{str(results[1]).lower()},{results[2]},{results[3]},{results[4]},{results[5]},{results[6]},{results[7]},{str(results[8]).lower()}]\")\n\nsolve()\n\n```",
                "id": "3585435"
            }
        ]
    }