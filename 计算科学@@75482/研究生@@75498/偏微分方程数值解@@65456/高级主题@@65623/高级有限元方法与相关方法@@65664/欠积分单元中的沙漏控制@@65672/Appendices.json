{"hands_on_practices": [{"introduction": "任何有效的沙漏控制方案的一个基本要求是它不能错误地惩罚刚体运动。此练习通过数值方法验证了沙漏模式的一个核心代数属性：它们与构成刚体平移和旋转的线性位移场正交[@problem_id:3555163]。掌握此验证是有限元程序开发中一项至关重要的质量保证步骤。", "problem": "本题要求您从第一性原理出发，实现一个验证过程，证明为二维四节点双线性四边形有限元（采用单点（减缩）积分）构建的沙漏控制力在刚体运动下不会被伪激活。请在有限元法 (FEM) 的框架下进行，并考虑适用于小应变和小转动的线性化运动学。需要评估的核心量是一个沙漏广义坐标向量 $\\mathbf{q}_{\\alpha}$，该向量对于任何刚体平移和任何刚体转动都必须为零。您的任务是定义一个单元级沙漏向量 $\\mathbf{g}$，该向量能够消除所有在物理坐标中呈线性的离散场，然后根据给定的节点位移构建 $\\mathbf{q}_{\\alpha}$，并验证对于刚体运动，$\\lVert \\mathbf{q}_{\\alpha} \\rVert_{2}$ 的值为零（在数值精度范围内）。\n\n从以下基本原理出发：\n- 有限元法 (FEM) 在物理空间中的插值完备性：任何在物理坐标 $x$ 和 $y$ 中呈线性的场，都可以在单元级别表示为 $u(x,y)=a_{0}+a_{1}x+a_{2}y$。\n- 双线性形函数的单位分解性和线性场再生能力确保了刚体平移和刚体转动（在小转动意义下）是线性场。绕点 $(x_{0},y_{0})$ 的微小刚体转动（角度 $\\theta$ 为弧度）会产生位移场 $\\mathbf{u}(x,y)=\\theta[-(y-y_{0}),\\,(x-x_{0})]$。\n- 在单个积分点上进行减缩积分会导致伪单元级零能（沙漏）模式的出现，其代数特征可通过强制与在单元节点上求值的多项式空间 $\\operatorname{span}\\{1,x,y\\}$ 正交来构建。\n\n定义与构造：\n1. 考虑一个二维四节点双线性四边形，节点索引为 $i\\in\\{1,2,3,4\\}$，物理坐标为 $(x_{i},y_{i})$。定义 $4\\times 3$ 矩阵\n   $$\\mathbf{P}=\\begin{bmatrix}\n   1  x_{1}  y_{1}\\\\\n   1  x_{2}  y_{2}\\\\\n   1  x_{3}  y_{3}\\\\\n   1  x_{4}  y_{4}\n   \\end{bmatrix}.$$\n   令 $\\mathbf{g}\\in\\mathbb{R}^{4}$ 为满足\n   $$\\mathbf{P}^{\\top}\\mathbf{g}=\\mathbf{0},$$\n   的任意非零向量，然后将其归一化为单位欧几里得范数，使得 $\\lVert \\mathbf{g}\\rVert_{2}=1$。无论单元如何扭曲，此选择都强制了与所有关于 $x$ 和 $y$ 的线性场以及常数场的离散正交性。您可以通过计算 $\\mathbf{P}$ 的左零空间来求得 $\\mathbf{g}$，例如通过奇异值分解。\n2. 对于节点位移 $\\{\\mathbf{u}_{i}\\}_{i=1}^{4}$，其分量为 $\\mathbf{u}_{i}=[u_{i}^{x},u_{i}^{y}]^{\\top}$，定义沙漏广义坐标\n   $$q_{x}=\\sum_{i=1}^{4}g_{i}\\,u_{i}^{x},\\qquad q_{y}=\\sum_{i=1}^{4}g_{i}\\,u_{i}^{y},\\qquad \\mathbf{q}_{\\alpha}=\\begin{bmatrix}q_{x}\\\\ q_{y}\\end{bmatrix}.$$\n   在许多方案中，沙漏控制力与 $\\mathbf{q}_{\\alpha}$ 成正比，因此验证在刚体运动下 $\\mathbf{q}_{\\alpha}=\\mathbf{0}$ 可确保此类运动不会产生伪控制力。\n3. 验证目标：数值上证明对于刚体平移和转动，$\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}=0$（在浮点误差容限内），而对于一个非刚体的类沙漏模式，$\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}\\neq 0$。\n\n您的程序必须实现的算法指令：\n- 给定节点坐标 $\\{(x_{i},y_{i})\\}_{i=1}^{4}$，构造 $\\mathbf{P}$，计算 $\\mathbf{P}$ 左零空间（等效于 $\\mathbf{P}^{\\top}$ 的零空间）中的单位范数向量 $\\mathbf{g}$，然后为每个指定的位移模式计算 $\\mathbf{q}_{\\alpha}$。\n- 由向量 $\\mathbf{t}=[t_{x},t_{y}]^{\\top}$ 定义的刚体平移，为所有节点 $i$ 赋予位移 $u_{i}^{x}=t_{x}$ 和 $u_{i}^{y}=t_{y}$。\n- 绕选定中心 $(x_{0},y_{0})$、转动角度为 $\\theta$（以弧度为单位）的微小刚体转动赋予位移\n  $$u_{i}^{x}=\\theta\\left(-(y_{i}-y_{0})\\right),\\qquad u_{i}^{y}=\\theta\\left(x_{i}-x_{0}\\right)。$$\n- 特定单元的非刚体类沙漏位移使用计算出的 $\\mathbf{g}$ 本身：为所有节点 $i$ 赋予位移 $u_{i}^{x}=g_{i}$ 和 $u_{i}^{y}=-2g_{i}$。\n\n测试套件：\n- 测试用例 1（在一般凸四边形上的平移）：\n  - 节点：$\\{(0.0,0.0),(3.0,0.2),(2.7,1.8),(-0.1,1.5)\\}$。\n  - 位移：平移 $\\mathbf{t}=[0.7,-1.1]$。\n  - 输出：标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$。\n- 测试用例 2（在同一四边形上绕形心转动）：\n  - 节点：同测试用例 1。\n  - 转动中心：形心 $(x_{0},y_{0})$，等于节点坐标的算术平均值。\n  - 角度：$\\theta=0.1$ 弧度。\n  - 输出：标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$。\n- 测试用例 3（在扭曲四边形上绕外部点转动）：\n  - 节点：$\\{(0.0,0.0),(2.0,0.1),(2.2,0.5),(0.1,1.2)\\}$。\n  - 转动中心：$(x_{0},y_{0})=(0.0,0.0)$。\n  - 角度：$\\theta=-0.35$ 弧度。\n  - 输出：标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$。\n- 测试用例 4（在细长类平行四边形上的转动）：\n  - 节点：$\\{(0.0,0.0),(10.0,0.02),(10.5,0.05),(0.5,0.03)\\}$。\n  - 转动中心：形心 $(x_{0},y_{0})$，等于节点坐标的算术平均值。\n  - 角度：$\\theta=0.2$ 弧度。\n  - 输出：标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$。\n- 测试用例 5（在第一个四边形上的非刚体类沙漏位移）：\n  - 节点：同测试用例 1。\n  - 位移：$u_{i}^{x}=g_{i}$ 和 $u_{i}^{y}=-2g_{i}$，其中 $\\mathbf{g}$ 是为这些节点计算的归一化左零空间向量。\n  - 输出：标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$，如果 $\\lVert \\mathbf{g}\\rVert_{2}=1$，该值应等于 $\\sqrt{5}$（在浮点舍入误差范围内）。\n\n角度单位说明：所有角度 $\\theta$ 必须以弧度为单位。坐标或位移不需要物理单位；将它们视为无量纲量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即 $[\\text{r}_{1},\\text{r}_{2},\\text{r}_{3},\\text{r}_{4},\\text{r}_{5}]$，其中 $\\text{r}_{k}$ 是测试用例 $k$ 的标量 $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$。\n- 每个标量必须格式化为科学记数法，小数点后恰好有 $12$ 位数字（例如，$1.234000000000e-03$）。根据构造，角度单位为弧度。\n\n您的实现必须是一个完整、可运行的程序，通过线性代数构造 $\\mathbf{g}$，并为上述测试套件评估结果，将它们聚合为所描述的精确输出格式。", "solution": "该问题的核心是验证减缩积分有限元沙漏控制方案的一个基本属性：它们在刚体运动下不得产生伪恢复力。对于使用单个积分点（减缩积分）的二维四节点四边形单元，其刚度矩阵会变得秩亏，从而允许出现非物理的、称为沙漏模式的零能变形模式。沙漏控制方案通过向单元能量中添加一个稳定项来抑制这些模式。这种稳定化通常与一组沙漏广义应变或坐标成正比，此处表示为 $\\mathbf{q}_{\\alpha}$。一个关键要求是，对于任何刚体运动，这些广义坐标都必须为零。这确保了控制机制仅作用于伪模式，而不会错误地抵抗刚体平移或转动。该验证依赖于沙漏模式的代数构造。\n\n在有限元法 (FEM) 的背景下，双线性四边形单元的形函数可以精确表示任何作为空间坐标线性函数的位移场，即形式为 $\\mathbf{u}(x,y) = \\mathbf{a}_{0} + \\mathbf{a}_{1}x + \\mathbf{a}_{2}y$ 的位移场。这个线性场空间包含恒定场（刚体平移），以及在小变形情况下，对应于刚体转动的线性场。根据定义，沙漏模式是与该线性场空间正交的节点位移模式。\n\n解析和数值验证过程如下：\n\n首先，我们建立在单元节点上求值的线性场的基。对于一个具有物理坐标 $(x_{i}, y_{i})$（$i \\in \\{1, 2, 3, 4\\}$）的四节点单元，任何线性场都可以由其在节点上的值来描述。构造矩阵 $\\mathbf{P}$ 来表示在 4 个节点上求值的基函数 $\\{1, x, y\\}$：\n$$\n\\mathbf{P} = \\begin{bmatrix}\n1  x_{1}  y_{1} \\\\\n1  x_{2}  y_{2} \\\\\n1  x_{3}  y_{3} \\\\\n1  x_{4}  y_{4}\n\\end{bmatrix}\n$$\n这个 $4 \\times 3$ 矩阵 $\\mathbf{P}$ 的列分别代表与恒定场、关于 $x$ 的线性场以及关于 $y$ 的线性场相对应的节点向量。对于任何非退化四边形，这三个向量都是线性无关的，因此 $\\mathbf{P}$ 的秩为 3。\n\n沙漏向量 $\\mathbf{g} \\in \\mathbb{R}^{4}$ 被定义为一个与所有线性场离散正交的向量。这在代数上表示为 $\\mathbf{g}$ 必须与 $\\mathbf{P}$ 的每一列都正交的条件：\n$$\n\\mathbf{P}^{\\top}\\mathbf{g} = \\mathbf{0}\n$$\n这意味着 $\\mathbf{g}$ 属于 $\\mathbf{P}^{\\top}$ 的零空间。由于 $\\mathbf{P}^{\\top}$ 是一个秩为 3 的 $3 \\times 4$ 矩阵，其零空间的维数为 $4 - 3 = 1$。这保证了沙漏模式的形状在相差一个标量倍数的情况下是唯一的。我们计算这个向量 $\\mathbf{g}$（例如，通过对 $\\mathbf{P}^{\\top}$ 进行奇异值分解），并将其归一化，使其具有单位欧几里得范数，即 $\\lVert\\mathbf{g}\\rVert_{2}=1$。\n\n接下来，我们定义沙漏广义坐标。给定一组在 $x$ 和 $y$ 方向上的节点位移，收集成向量 $\\mathbf{u}^{x} = [u_{1}^{x}, u_{2}^{x}, u_{3}^{x}, u_{4}^{x}]^{\\top}$ 和 $\\mathbf{u}^{y} = [u_{1}^{y}, u_{2}^{y}, u_{3}^{y}, u_{4}^{y}]^{\\top}$，广义坐标 $q_{x}$ 和 $q_{y}$ 是这些位移向量在沙漏向量 $\\mathbf{g}$ 上的投影：\n$$\nq_{x} = \\sum_{i=1}^{4} g_{i}u_{i}^{x} = \\mathbf{g}^{\\top}\\mathbf{u}^{x}\n$$\n$$\nq_{y} = \\sum_{i=1}^{4} g_{i}u_{i}^{y} = \\mathbf{g}^{\\top}\\mathbf{u}^{y}\n$$\n它们被组装成向量 $\\mathbf{q}_{\\alpha} = [q_{x}, q_{y}]^{\\top}$。需要计算的量是它的 $L_2$ 范数，$\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}$。\n\n我们现在对指定的位移模式的结果进行解析验证。\n\n1.  **刚体平移**：位移在所有节点上是恒定的：$\\mathbf{u}_{i} = \\mathbf{t} = [t_{x}, t_{y}]^{\\top}$。节点位移向量为 $\\mathbf{u}^{x} = t_{x}[1, 1, 1, 1]^{\\top}$ 和 $\\mathbf{u}^{y} = t_{y}[1, 1, 1, 1]^{\\top}$。向量 $[1, 1, 1, 1]^{\\top}$ 正是 $\\mathbf{P}$ 的第一列。我们将 $\\mathbf{P}$ 的列表示为 $\\mathbf{p}_{1}$, $\\mathbf{p}_{2}$, $\\mathbf{p}_{3}$。条件 $\\mathbf{P}^{\\top}\\mathbf{g}=\\mathbf{0}$ 意味着对于 $j=1,2,3$，有 $\\mathbf{p}_{j}^{\\top}\\mathbf{g}=0$。\n    $$\n    q_{x} = \\mathbf{g}^{\\top}(t_{x}\\mathbf{p}_{1}) = t_{x}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = t_{x}(0) = 0\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}(t_{y}\\mathbf{p}_{1}) = t_{y}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = t_{y}(0) = 0\n    $$\n    因此，$\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}=0$。\n\n2.  **刚体转动（小角度）**：绕中心 $(x_{0}, y_{0})$ 转动一个小角度 $\\theta$ 会引起位移 $u_{i}^{x} = \\theta(-(y_{i}-y_{0}))$ 和 $u_{i}^{y} = \\theta(x_{i}-x_{0})$。节点位移向量可以写成 $\\mathbf{P}$ 各列的线性组合：\n    $$\n    \\mathbf{u}^{x} = \\theta(\\mathbf{p}_{1}y_{0} - \\mathbf{p}_{3})\n    $$\n    $$\n    \\mathbf{u}^{y} = \\theta(\\mathbf{p}_{2} - \\mathbf{p}_{1}x_{0})\n    $$\n    将这些投影到 $\\mathbf{g}$ 上：\n    $$\n    q_{x} = \\mathbf{g}^{\\top}(\\theta y_{0}\\mathbf{p}_{1} - \\theta\\mathbf{p}_{3}) = \\theta y_{0}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) - \\theta(\\mathbf{g}^{\\top}\\mathbf{p}_{3}) = 0 - 0 = 0\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}(\\theta\\mathbf{p}_{2} - \\theta x_{0}\\mathbf{p}_{1}) = \\theta(\\mathbf{g}^{\\top}\\mathbf{p}_{2}) - \\theta x_{0}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = 0 - 0 = 0\n    $$\n    同样地，$\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}=0$。测试用例 1、2、3、4 的数值结果应在浮点精度范围内为零。\n\n3.  **非刚体沙漏位移**：指定的位移具有沙漏模式本身的形式：$u_{i}^{x}=g_{i}$ 和 $u_{i}^{y}=-2g_{i}$。这意味着 $\\mathbf{u}^{x} = \\mathbf{g}$ 和 $\\mathbf{u}^{y} = -2\\mathbf{g}$。\n    $$\n    q_{x} = \\mathbf{g}^{\\top}\\mathbf{u}^{x} = \\mathbf{g}^{\\top}\\mathbf{g} = \\lVert\\mathbf{g}\\rVert_{2}^{2} = 1\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}\\mathbf{u}^{y} = \\mathbf{g}^{\\top}(-2\\mathbf{g}) = -2(\\mathbf{g}^{\\top}\\mathbf{g}) = -2\\lVert\\mathbf{g}\\rVert_{2}^{2} = -2\n    $$\n    因此，范数为：\n    $$\n    \\lVert\\mathbf{q}_{\\alpha}\\rVert_{2} = \\sqrt{q_{x}^{2} + q_{y}^{2}} = \\sqrt{1^{2} + (-2)^{2}} = \\sqrt{1+4} = \\sqrt{5}\n    $$\n    这表明对于匹配沙漏模式的位移模式，沙漏广义坐标是非零的，从而证实了控制机制会被激活。\n\n代码中实现的算法对每个测试用例都遵循以下步骤：构造 $\\mathbf{P}$，通过 $\\mathbf{P}^{\\top}$ 的零空间计算 $\\mathbf{g}$，为给定的运动定义节点位移向量 $\\mathbf{u}^{x}$ 和 $\\mathbf{u}^{y}$，计算 $\\mathbf{q}_{\\alpha}$，最后计算其范数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements the verification of hourglass control properties for a 4-node\n    quadrilateral element under various displacement patterns.\n    \"\"\"\n\n    def calculate_q_norm(nodes, motion_type, params):\n        \"\"\"\n        Calculates the L2-norm of the hourglass generalized coordinate vector q_alpha.\n\n        Args:\n            nodes (np.ndarray): A 4x2 array of nodal coordinates (x, y).\n            motion_type (str): Type of motion ('translation', 'rotation', 'hourglass').\n            params (dict): Dictionary of parameters for the motion.\n\n        Returns:\n            float: The L2-norm of q_alpha.\n        \"\"\"\n        # 1. Construct the matrix P\n        P = np.hstack([np.ones((4, 1)), nodes])\n\n        # 2. Compute the unit-norm hourglass vector g\n        # g is the basis for the left nullspace of P, i.e., nullspace of P.T\n        g_vec = null_space(P.T)\n        if g_vec.shape[1] == 0:\n            # This case should not happen for non-degenerate quads\n            raise ValueError(\"Could not find a nullspace vector. The element may be degenerate.\")\n        g = g_vec[:, 0]  # null_space returns an orthonormal basis as columns\n\n        # Ensure g is a consistent choice (e.g., g[0] is positive) to avoid sign flips\n        # that don't affect the norm but could affect intermediate values.\n        if g[0] < 0:\n            g = -g\n\n        # 3. Define nodal displacement vectors u_x and u_y\n        x_coords = nodes[:, 0]\n        y_coords = nodes[:, 1]\n        u_x = np.zeros(4)\n        u_y = np.zeros(4)\n\n        if motion_type == 'translation':\n            t = params['t']\n            u_x.fill(t[0])\n            u_y.fill(t[1])\n        elif motion_type == 'rotation':\n            theta = params['theta']\n            center = params['center']\n            if isinstance(center, str) and center == 'centroid':\n                x0, y0 = np.mean(nodes, axis=0)\n            else:\n                x0, y0 = center\n            u_x = theta * -(y_coords - y0)\n            u_y = theta * (x_coords - x0)\n        elif motion_type == 'hourglass':\n            u_x = g\n            u_y = -2 * g\n        else:\n            raise ValueError(f\"Unknown motion type: {motion_type}\")\n\n        # 4. Calculate hourglass generalized coordinates q_x and q_y\n        q_x = np.dot(g, u_x)\n        q_y = np.dot(g, u_y)\n\n        # 5. Calculate and return the L2-norm of q_alpha\n        return np.linalg.norm([q_x, q_y])\n\n    # Define the test cases from the problem statement.\n    nodes1 = np.array([[0.0, 0.0], [3.0, 0.2], [2.7, 1.8], [-0.1, 1.5]])\n    nodes2 = np.array([[0.0, 0.0], [2.0, 0.1], [2.2, 0.5], [0.1, 1.2]])\n    nodes3 = np.array([[0.0, 0.0], [10.0, 0.02], [10.5, 0.05], [0.5, 0.03]])\n\n    test_cases = [\n        # Test case 1 (translation)\n        {'nodes': nodes1, 'motion_type': 'translation', 'params': {'t': [0.7, -1.1]}},\n        # Test case 2 (rotation about centroid)\n        {'nodes': nodes1, 'motion_type': 'rotation', 'params': {'theta': 0.1, 'center': 'centroid'}},\n        # Test case 3 (rotation about external point)\n        {'nodes': nodes2, 'motion_type': 'rotation', 'params': {'theta': -0.35, 'center': (0.0, 0.0)}},\n        # Test case 4 (rotation about centroid on slender element)\n        {'nodes': nodes3, 'motion_type': 'rotation', 'params': {'theta': 0.2, 'center': 'centroid'}},\n        # Test case 5 (non-rigid hourglass pattern)\n        {'nodes': nodes1, 'motion_type': 'hourglass', 'params': {}}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_q_norm(case['nodes'], case['motion_type'], case['params'])\n        results.append(result)\n\n    # Format results to scientific notation with 12 decimal places\n    formatted_results = [f\"{r:.12e}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3555163"}, {"introduction": "在定义了沙漏模式之后，理解它们为何成为问题至关重要，尤其是在显式动力学模拟中。此练习使用一个简化的代理模型来生动地展示这些零能模式如何导致解出现灾难性的、非物理的增长[@problem_id:3404226]。通过对比有无稳定控制的结果，你将直观地感受到沙漏控制的必要性和有效性。", "problem": "考虑一根长度为 $L$ 的杆上的一维线性弹性动力学问题，其位移场 $u(x,t)$ 由以下偏微分方程控制\n$$\\rho A \\,\\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial x}\\left(E A \\,\\frac{\\partial u}{\\partial x}\\right),$$\n其中 $\\rho$ 是质量密度，$A$ 是横截面积，$E$ 是杨氏模量。施加齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。\n\n为了在一个易于处理的一维代理模型中模拟减缩积分双线性四节点四边形单元 (Q4) 的沙漏行为，将区域离散为 $N$ 个等间距节点，间距为 $h = L/(N-1)$，并为 $i=0,1,\\dots,N-4$ 定义重叠的四节点宏单元 $\\{i,i+1,i+2,i+3\\}$。对于每个宏单元，通过以下公式在单元中心定义一个减缩积分应变代理：\n$$\\varepsilon_e = g^\\top u_e,\\quad g = \\frac{1}{2h}[-1,-1,1,1]^\\top,$$\n其中 $u_e \\in \\mathbb{R}^4$ 汇集了宏单元的节点位移。相关的减缩积分单元刚度为\n$$K_e^{\\text{RI}} = E A (2h)\\, g g^\\top,$$\n当在所有宏单元上进行组装时，会产生一个秩亏的全局刚度矩阵。其零空间对应于满足 $g^\\top u_e = 0$ 的沙漏模式 $u_e$，即每个宏单元内部不对中心应变产生贡献的振荡模式。每个宏单元的一组方便的沙漏基向量是\n$$h_1 = [1,-1,0,0]^\\top,\\quad h_2=[0,0,1,-1]^\\top,\\quad h_3=[1,-1,-1,1]^\\top.$$\n通过为每个单元添加以下刚度来引入沙漏控制稳定化：\n$$K_e^{\\text{HG}} = s \\sum_{j=1}^3 h_j h_j^\\top,\\quad s = \\beta\\,\\frac{E A}{h},$$\n其中 $\\beta \\ge 0$ 是一个无量纲稳定化系数。总全局刚度是所有单元 $K_e^{\\text{RI}}$ 的组装，如果 $\\beta>0$，则可选择性地增加 $K_e^{\\text{HG}}$。\n\n使用显式中心差分时间步进法，其中包含集中质量矩阵 $M=\\operatorname{diag}(m_i)$（对于内部节点，$m_i=\\rho A h$），零外部牵引力，以及初始条件 $u(x,0)=0$ 和与交替节点模式成比例的沙漏主导初始速度 $v(x,0)$。对于自由（内部）自由度，更新公式为\n$$u^{n+1} = 2u^n - u^{n-1} + \\Delta t^2 M^{-1}\\left(-K\\,u^n\\right),$$\n第一步的公式为\n$$u^1 = u^0 + \\Delta t\\,v^0 + \\frac{1}{2}\\Delta t^2 M^{-1}\\left(-K\\,u^0\\right).$$\n在每次更新后通过直接施加的方式，将边界节点在所有时间固定为零。通过以下公式选择一个稳定的时间步：\n$$\\Delta t = \\alpha\\,\\frac{2}{\\sqrt{\\lambda_{\\max}(M^{-1/2} K M^{-1/2})}},$$\n其中 $\\lambda_{\\max}(\\cdot)$ 表示最大特征值，$0<\\alpha<1$ 是一个安全因子。\n\n定义全局沙漏模式向量 $\\phi \\in \\mathbb{R}^N$，对于内部节点 $\\phi_i = (-1)^i$，在边界节点处 $\\phi$ 等于零。通过在质量内积中的标量投影来量化在时间 $t$ 的沙漏振幅：\n$$a(t) = \\left|\\frac{\\phi^\\top M u(t)}{\\phi^\\top M \\phi}\\right|,$$\n其单位为米。\n\n你的任务是编写一个完整、可运行的程序，该程序能够：\n- 使用减缩积分代理和可选的沙漏控制来组装 $K$。\n- 从 $u(0)=0$ 和等于具有预设振幅的交替沙漏模式的 $v(0)$ 开始，计算到时间 $T$ 的显式中心差分时间积分。\n- 为每个测试案例输出最终的沙漏振幅 $a(T)$（单位：米）。\n\n所有物理量必须以国际单位制基本单位处理：米 (m)、秒 (s)、千克 (kg)、帕斯卡 (Pa) 和牛顿 (N)。不涉及角度。输出是代表 $a(T)$（单位：米）的浮点数。\n\n实现以下测试套件。每个测试案例是一个元组 $(N, L, E, \\rho, A, V_0, T, \\beta, \\alpha)$，其中：\n- $N$：节点数，\n- $L$：杆长（单位：米），\n- $E$：杨氏模量（单位：帕斯卡），\n- $\\rho$：密度（单位：千克/立方米），\n- $A$：面积（单位：平方米），\n- $V_0$：初始沙漏速度振幅（单位：米/秒），\n- $T$：最终时间（单位：秒），\n- $\\beta$：稳定化系数（无量纲），\n- $\\alpha$：时间步长的安全因子（无量纲）。\n\n使用以下参数值：\n- 案例 1（无稳定化，观察增长）：$(N,L,E,\\rho,A,V_0,T,\\beta,\\alpha) = (\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.0,\\,0.80\\,)$。\n- 案例 2（中等稳定化）：$(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.80\\,)$。\n- 案例 3（强稳定化）：$(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,2.0,\\,0.80\\,)$。\n- 案例 4（小网格，中等稳定化）：$(\\,7,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.80\\,)$。\n- 案例 5（接近临界时间步，中等稳定化）：$(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.98\\,)$。\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。每个结果必须是对应测试案例的最终沙漏振幅 $a(T)$（单位：米），并按上述顺序排列。", "solution": "用户提供的问题被评估为 **有效**。这是一个在计算固体力学领域内的适定且有科学依据的练习，提供了所有必要的数据和定义，以形成一个唯一且可验证的解。\n\n该问题要求使用显式有限差分格式来模拟一维弹性动力学。其空间离散化是专门设计来模拟沙漏不稳定性的，这是减缩积分有限元方法中常见的现象。解决方案涉及几个步骤：系统离散化，构建质量和刚度矩阵，确定稳定时间步，对运动方程进行时间积分，以及计算沙漏振幅的最终度量。所有计算均以国际单位制基本单位进行。\n\n### 1. 离散化和系统矩阵\n\n长度为 $L$ 的连续杆被离散为 $N$ 个节点，均匀间距为 $h = L/(N-1)$。第 $i$ 个节点在时间 $t$ 的位移表示为 $u_i(t)$。方程组由矩阵方程 $M \\ddot{u} + K u = F_{ext}$ 控制，其中 $u$ 是节点位移向量，$M$ 是质量矩阵，$K$ 是刚度矩阵，$F_{ext}$ 是外部节点力向量，在本问题中为零。\n\n**质量矩阵 ($M$)**\n使用集中质量矩阵，它是对角矩阵，因此对于显式动力学计算而言效率很高。对于 $N-2$ 个内部节点（从 $i=1$ 到 $N-2$），质量为 $m_i = \\rho A h$。对于边界节点（$i=0$ 和 $i=N-1$），位移被固定为零，因此它们的质量值不影响内部节点的动力学。为实现方便，我们可以为它们赋任何非零值以防止除以零；使用内部节点的质量值 $m_{0}=m_{N-1}=\\rho A h$ 是很方便的。因此，$M = \\operatorname{diag}(m_i)$ 是一个 $N \\times N$ 矩阵。\n\n**刚度矩阵 ($K$)**\n全局刚度矩阵 $K$ 是一个 $N \\times N$ 矩阵，由单元刚度矩阵 $K_e$ 组装而成。该问题定义了重叠的4节点宏单元。对于跨越节点 $\\{i, i+1, i+2, i+3\\}$ 的每个单元 $e$，其单元刚度 $K_e$ 是减缩积分部分 $K_e^{\\text{RI}}$ 和稳定化部分 $K_e^{\\text{HG}}$ 的和。\n\n减缩积分刚度由下式给出：\n$$K_e^{\\text{RI}} = EA(2h) g g^\\top$$\n其中 $g = \\frac{1}{2h}[-1, -1, 1, 1]^\\top$ 是单元中心应变代理的梯度向量。该矩阵是秩为一的，并有一个对应于零能“沙漏”模式的零空间。\n\n为控制这些非物理模式，添加了一个稳定化刚度：\n$$K_e^{\\text{HG}} = s \\sum_{j=1}^3 h_j h_j^\\top$$\n其中 $s = \\beta \\frac{EA}{h}$ 是由无量纲系数 $\\beta$ 控制的稳定化参数大小，$\\{h_j\\}$ 是所提供的沙漏基向量：\n$$h_1 = [1, -1, 0, 0]^\\top, \\quad h_2 = [0, 0, 1, -1]^\\top, \\quad h_3 = [1, -1, -1, 1]^\\top$$\n总单元刚度为 $K_e = K_e^{\\text{RI}} + K_e^{\\text{HG}}$。全局刚度矩阵 $K$ 是通过遍历所有 $N-3$ 个宏单元，并将每个 $4 \\times 4$ 的单元矩阵 $K_e$ 添加到 $K$ 的相应行和列中形成的。\n\n### 2. 时间积分\n\n使用显式中心差分格式对半离散化的运动方程 $M \\ddot{u} = -K u$ 进行积分。\n\n**时间步确定**\n显式格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件决定。稳定时间步 $\\Delta t$ 是基于系统的最大固有频率计算的，该频率与动力学缩放的刚度矩阵 $D = M^{-1/2} K M^{-1/2}$ 的最大特征值 $\\lambda_{\\max}$ 相关。由于边界节点是固定的，我们只考虑自由内部自由度的子系统。公式为：\n$$\\Delta t = \\alpha \\frac{2}{\\sqrt{\\lambda_{\\max}(D_{free})}}$$\n其中 $D_{free}$ 是对应于自由节点的矩阵 $D$，$\\alpha$ 是一个安全因子 ($0 < \\alpha < 1$)。$D_{free}$ 的特征值通过数值方法计算。\n\n**更新格式**\n时间步 $n$ 的位移向量 $u^n$ 使用中心差分公式更新为 $u^{n+1}$：\n$$u^{n+1} = 2u^n - u^{n-1} + \\Delta t^2 M^{-1}(-K u^n)$$\n其中 $u^{n-1}$ 和 $u^n$ 是前两个时间步的位移。由于 $M$ 是对角矩阵，$M^{-1}$ 就是节点质量的逐元素倒数。\n\n**初始条件和第一步**\n系统从静止开始，$u(x,0)=0$，所以 $u^0=0$。初始速度对于内部节点是一个交替模式，$v^0_i = V_0 (-1)^i$ for $i=1, ..., N-2$，在边界处为零。第一个时间步需要特殊处理：\n$$u^1 = u^0 + \\Delta t v^0 + \\frac{1}{2}\\Delta t^2 M^{-1}(-K u^0)$$\n鉴于 $u^0 = 0$，这简化为 $u^1 = \\Delta t v^0$。\n\n**边界条件**\n齐次狄利克雷边界条件 $u(0, t) = 0$ 和 $u(L, t) = 0$ 在每个时间步通过在每次更新计算后将位移向量的第一个和最后一个分量设置为零来直接施加，即 $u^{n+1}_0 = 0$ 和 $u^{n+1}_{N-1} = 0$。\n\n### 3. 沙漏振幅计算\n\n模拟运行总时间 $T$。最终状态是最后一个完整时间步结束时的位移向量 $u(T)$。此时的沙漏模式振幅通过将位移解投影到全局沙漏模式向量 $\\phi$ 上来量化，其中对于内部节点 $\\phi_i = (-1)^i$，在边界处为零。该投影在由质量矩阵定义的能量内积中执行：\n$$a(T) = \\left|\\frac{\\phi^\\top M u(T)}{\\phi^\\top M \\phi}\\right| = \\left| \\frac{\\sum_{i=1}^{N-2} \\phi_i m_i u_i(T)}{\\sum_{i=1}^{N-2} \\phi_i m_i \\phi_i} \\right|$$\n这个标量值 $a(T)$（单位：米）是每个测试案例所要求的输出。对于无稳定化的情况（$\\beta=0$），初始速度分布是一个零能模式，导致位移的理论线性增长，$a(t)=V_0 t$。有稳定化时（$\\beta > 0$），该模式获得非零刚度，导致振幅受抑制的振荡行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: No stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.0, 0.80),\n        # Case 2: Moderate stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.80),\n        # Case 3: Strong stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 2.0, 0.80),\n        # Case 4: Small mesh, moderate stabilization\n        (7, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.80),\n        # Case 5: Near-critical time step\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.98),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(N, L, E, rho, A, V0, T, beta, alpha):\n    \"\"\"\n    Solves a single instance of the 1D elastodynamics problem with hourglass control.\n\n    Args:\n        N (int): Number of nodes.\n        L (float): Bar length in meters.\n        E (float): Young's modulus in Pascals.\n        rho (float): Density in kg/m^3.\n        A (float): Cross-sectional area in m^2.\n        V0 (float): Initial hourglass velocity amplitude in m/s.\n        T (float): Final time in seconds.\n        beta (float): Dimensionless stabilization coefficient.\n        alpha (float): Safety factor for the time step.\n\n    Returns:\n        float: The final hourglass amplitude a(T) in meters.\n    \"\"\"\n    # 1. Discretization\n    h = L / (N - 1)\n\n    # 2. System Matrices (Mass M, Stiffness K)\n    # Lumped mass vector (m_i)\n    m = np.full(N, rho * A * h)\n    \n    # Global stiffness matrix\n    K = np.zeros((N, N))\n    \n    # Elemental stiffness matrix calculation\n    g = (1.0 / (2.0 * h)) * np.array([-1.0, -1.0, 1.0, 1.0])\n    Ke_RI = E * A * (2.0 * h) * np.outer(g, g)\n    \n    if beta > 1e-12:  # Treat sufficiently small beta as zero\n        s = beta * E * A / h\n        h1 = np.array([1.0, -1.0, 0.0, 0.0])\n        h2 = np.array([0.0, 0.0, 1.0, -1.0])\n        h3 = np.array([1.0, -1.0, -1.0, 1.0])\n        Ke_HG = s * (np.outer(h1, h1) + np.outer(h2, h2) + np.outer(h3, h3))\n    else:\n        Ke_HG = np.zeros((4, 4))\n        \n    Ke = Ke_RI + Ke_HG\n    \n    # Assembly of the global stiffness matrix\n    num_elements = N - 3\n    for i in range(num_elements):\n        nodes = np.arange(i, i + 4)\n        K[np.ix_(nodes, nodes)] += Ke\n        \n    # 3. Time Step Calculation based on CFL condition\n    free_dofs = slice(1, N - 1)\n    K_free = K[free_dofs, free_dofs]\n    m_free_val = rho * A * h\n    \n    D_matrix = (1.0 / m_free_val) * K_free\n    \n    eigenvalues = eigh(D_matrix, eigvals_only=True)\n    lambda_max = eigenvalues[-1]\n\n    if lambda_max <= 0:\n        if beta < 1e-12 and np.allclose(K_free, 0): # Unstabilized, K can be zero matrix\n            dt = T / 100.0 # Just use a reasonable number of steps\n        else:\n            raise ValueError(\"Maximum eigenvalue is non-positive, cannot determine stable time step.\")\n    else:\n        dt = alpha * 2.0 / np.sqrt(lambda_max)\n\n    # 4. Explicit Time Integration (Central Difference)\n    num_steps = int(np.ceil(T / dt))\n    \n    u_prev = np.zeros(N)\n    u_curr = np.zeros(N)\n    \n    v0_vec = np.zeros(N)\n    for i in range(1, N - 1):\n        v0_vec[i] = V0 * ((-1.0)**i)\n        \n    # First time step\n    u_curr = u_prev + dt * v0_vec\n    u_curr[0] = u_curr[-1] = 0.0\n    \n    # Time stepping loop\n    for _ in range(1, num_steps):\n        F_int = -K @ u_curr\n        accel = F_int / m\n        u_new = 2.0 * u_curr - u_prev + (dt**2) * accel\n        u_new[0] = u_new[-1] = 0.0\n        u_prev, u_curr = u_curr, u_new\n        \n    u_final = u_curr\n    \n    # 5. Final Amplitude Calculation\n    phi = np.zeros(N)\n    for i in range(1, N - 1):\n        phi[i] = (-1.0)**i\n        \n    numerator = np.dot(phi, m * u_final)\n    mass_norm_phi_sq = np.dot(phi, m * phi)\n    \n    if abs(mass_norm_phi_sq) < 1e-15:\n        return 0.0\n            \n    amplitude = np.abs(numerator / mass_norm_phi_sq)\n    return amplitude\n\nsolve()\n```", "id": "3404226"}, {"introduction": "理解了沙漏的定义和其动态后果后，最后一步是实现一个实际的解决方案。此练习提供了一个分步指南，用于构建和组装一个基于子单元应变波动的沙漏刚度矩阵[@problem_id:3404232]。这是一种在现代有限元程序中广泛应用的稳定、有效的技术。", "problem": "要求您设计并实现一个程序，在有限元法 (FEM) 中，为一个减缩积分四边形单元添加一个沙漏控制刚度矩阵，用于求解偏微分方程 (PDEs) 的数值解。重点是平面应变条件下的小应变线弹性四节点双线性等参四边形单元，以及控制单点积分时出现的零能沙漏模式。\n\n从基础的小应变线弹性弱形式、应变-位移关系和本构法则开始：\n- 位移场表示为 $\\mathbf{u}(\\mathbf{x}) = [u_x(\\mathbf{x}), u_y(\\mathbf{x})]^T$。\n- 小应变张量定义为 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T\\right)$，其向量形式为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$。\n- 应力为 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中平面应变本构矩阵 $\\mathbf{D}$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 通过 Lamé 参数 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\frac{E}{2(1+\\nu)}$ 构建，得到\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n\n对于双线性四边形单元，使用从参考正方形 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 出发的标准等参映射：\n- 形函数为 $\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$\n- 到物理坐标的等参映射为 $\n\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{x}_i,\n$ 其中 $\\mathbf{x}_i = [x_i,y_i]^T$ 是节点坐标。\n- 应变-位移矩阵 $\\mathbf{B}(\\xi,\\eta)$ 通过 $\\mathbf{B} = \\mathbf{L}\\,\\mathbf{S}$ 获得，其中 $\\mathbf{S}$ 堆叠了 $i=1,\\dots,4$ 的 $\\frac{\\partial N_i}{\\partial x}$ 和 $\\frac{\\partial N_i}{\\partial y}$，而 $\\mathbf{L}$ 通过 $\n\\mathbf{L} =\n\\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n\\end{bmatrix}\n$ 适当地作用于位移梯度，将梯度映射到应变向量，从而形成 $\n\\mathbf{B} =\n\\begin{bmatrix}\n\\frac{\\partial N_1}{\\partial x}  0  \\frac{\\partial N_2}{\\partial x}  0  \\frac{\\partial N_3}{\\partial x}  0  \\frac{\\partial N_4}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_1}{\\partial y}  0  \\frac{\\partial N_2}{\\partial y}  0  \\frac{\\partial N_3}{\\partial y}  0  \\frac{\\partial N_4}{\\partial y} \\\\\n\\frac{\\partial N_1}{\\partial y}  \\frac{\\partial N_1}{\\partial x}  \\frac{\\partial N_2}{\\partial y}  \\frac{\\partial N_2}{\\partial x}  \\frac{\\partial N_3}{\\partial y}  \\frac{\\partial N_3}{\\partial x}  \\frac{\\partial N_4}{\\partial y}  \\frac{\\partial N_4}{\\partial x}\n\\end{bmatrix}.\n$\n\n在减缩（单点）积分下，由于应变场采样不足，可能会出现伪零能沙漏模式。可以向全局刚度中添加一个稳健的沙漏控制矩阵 $K_{hg}$，以惩罚那些未被形心应变捕捉到的子单元应变波动。您的任务是实现一个分步算法，该算法：\n- 在每个单元内的一小组点上计算子单元应变。\n- 基于子单元应变与形心应变的偏差构建一个稳定化方法。\n- 将由此产生的沙漏刚度贡献组装到全局系统中。\n- 基于具有物理意义的量选择一个稳定化参数。\n\n算法和实现需遵循以下要求：\n1.  在 $(\\xi,\\eta) = (0,0)$ 处计算形心应变-位移矩阵 $\\mathbf{B}_{\\text{cent}}$。\n2.  选择一组子单元点 $(\\xi_m,\\eta_m)$（$m$ 为子单元索引）来对应变波动进行采样。使用位于两点高斯横坐标 $ \\xi_m,\\eta_m \\in \\{-1/\\sqrt{3}, +1/\\sqrt{3}\\}$ 处的四个点，权重为单位权重；将每个点处的雅可比行列式表示为 $J_m$。\n3.  对于每个子单元 $m$，定义偏差矩阵 $\\mathbf{H}_m = \\mathbf{B}(\\xi_m,\\eta_m) - \\mathbf{B}_{\\text{cent}}$，并基于 $\\mathbf{H}_m$ 和本构矩阵 $\\mathbf{D}$ 构建稳定化能量密度。\n4.  组装一个单元沙漏刚度，该刚度通过一个标量稳定化系数 $\\alpha$ 来惩罚这些偏差，该系数从剪切模量 $\\mu$ 中选择，即 $\\alpha = c_{\\alpha}\\,\\mu$，其中 $c_{\\alpha}$ 是一个待选的无量纲参数。\n5.  根据标准的 FEM 组装规则，通过对单元贡献求和来组装全局沙漏刚度矩阵。\n\n您必须为一个包含两个四边形单元的小网格实现上述算法，并对几个测试用例评估最终的全局沙漏刚度矩阵 $K_{hg}^{\\text{global}}$。对于每个测试用例，计算 $K_{hg}^{\\text{global}}$ 的最小严格正特征值；如果没有严格正特征值（例如，如果 $c_{\\alpha} = 0$ 导致一个零矩阵），则返回 $0.0$。\n\n本任务不需要物理单位，所有量均可视为无量纲。此问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n- 测试 $1$（正常情况）：两个单元形成一个单位矩形，在 $x = 0.5$ 处分割。节点坐标为 $[ (0,0), (0.5,0), (1,0), (0,1), (0.5,1), (1,1) ]$，单元为 $[ (0,1,4,3), (1,2,5,4) ]$，$E = 1000$，$\\nu = 0.3$，$c_{\\alpha} = 0.1$。\n- 测试 $2$（扭曲）：与测试 $1$ 相同的连接关系，但节点坐标为 $[ (0,0), (0.5,-0.2), (1,0), (0,1), (0.5,1.3), (1,1) ]$，$E = 1000$，$\\nu = 0.3$，$c_{\\alpha} = 0.1$。\n- 测试 $3$（边界条件 $c_{\\alpha} = 0$）：与测试 $1$ 相同的几何形状，$E = 1000$，$\\nu = 0.3$，$c_{\\alpha} = 0.0$。\n- 测试 $4$（强稳定化）：与测试 $2$ 相同的几何形状，$E = 1000$，$\\nu = 0.3$，$c_{\\alpha} = 1.0$。\n\n您的程序应生成单行输出，包含一个逗号分隔的列表形式的结果，并用方括号括起来（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试 $i$ 的 $K_{hg}^{\\text{global}}$ 的最小严格正特征值（如果没有则为 $0.0$）。所有数值必须以浮点数形式报告。", "solution": "该问题要求为用于线弹性平面应变条件下有限元分析的四节点双线性等参四边形单元设计并实现一种沙漏控制稳定化方法。当使用减缩单点（1x1）高斯积分来计算单元刚度矩阵时，会出现称为沙漏模式的伪零能模式，因此这种稳定化是必要的。\n\n该稳定化方法的基本原理是在系统的势能中增加一个罚能量。这个罚能量被设计为对刚体运动和常应变状态为零，但对非物理的沙漏变形模式为正。单元刚度矩阵由势能的二阶变分导出。因此，沙漏稳定化为标准单元刚度矩阵贡献了一个额外的刚度矩阵，记为 $K_{hg}^{(e)}$。总单元刚度为 $K^{(e)}_{\\text{total}} = K^{(e)}_{\\text{std}} + K^{(e)}_{hg}$。本问题仅关注沙漏贡献的计算。\n\n单元 $(e)$ 的沙漏稳定化能 $W_{hg}^{(e)}$ 是根据单元内的应变场 $\\boldsymbol{\\varepsilon}$ 与在单元形心处计算的应变 $\\boldsymbol{\\varepsilon}_{\\text{cent}}$ 之间的偏差来构建的。这些应变通过应变-位移矩阵 $\\mathbf{B}(\\xi, \\eta)$与单元的节点位移向量 $\\mathbf{d}$ 相关联，其中 $(\\xi, \\eta)$ 是参考单元域 $[-1,1] \\times [-1,1]$ 中的坐标。具体来说，$\\boldsymbol{\\varepsilon}(\\xi, \\eta) = \\mathbf{B}(\\xi, \\eta)\\mathbf{d}$ 且 $\\boldsymbol{\\varepsilon}_{\\text{cent}} = \\mathbf{B}(0,0)\\mathbf{d} = \\mathbf{B}_{\\text{cent}}\\mathbf{d}$。\n\n稳定化能量密度的构建使其与该应变偏差的范数平方成正比，并由材料的本构矩阵 $\\mathbf{D}$ 和稳定化参数 $\\alpha$ 加权。单元的总稳定化能是此密度在单元体积 $V_e$ 上的积分：\n$$\nW_{hg}^{(e)} = \\frac{1}{2} \\int_{V_e} (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}_{\\text{cent}})^T (\\alpha\\mathbf{D}) (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}_{\\text{cent}}) \\,dV\n$$\n代入应变与节点位移之间的关系，我们得到：\n$$\nW_{hg}^{(e)} = \\frac{1}{2} \\mathbf{d}^T \\left( \\alpha \\int_{V_e} (\\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}})^T \\mathbf{D} (\\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}}) \\,dV \\right) \\mathbf{d}\n$$\n括号中的项是单元沙漏刚度矩阵 $K_{hg}^{(e)}$：\n$$\nK_{hg}^{(e)} = \\alpha \\int_{V_e} \\mathbf{H}(\\xi,\\eta)^T \\mathbf{D} \\mathbf{H}(\\xi,\\eta) \\,dV\n$$\n其中 $\\mathbf{H}(\\xi,\\eta) = \\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}}$ 是偏差矩阵。\n\n物理体积 $V_e$ 上的积分通过等参映射转换为参考正方形域上的积分，对于单位厚度的平面应变单元，$dV = J(\\xi,\\eta) \\,d\\xi d\\eta$，其中 $J(\\xi,\\eta)$ 是坐标映射的雅可比矩阵的行列式。\n$$\nK_{hg}^{(e)} = \\alpha \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{H}(\\xi,\\eta)^T \\mathbf{D} \\mathbf{H}(\\xi,\\eta) J(\\xi,\\eta) \\,d\\xi d\\eta\n$$\n然后，使用求积法则对该积分进行数值近似。问题指定了一个特殊的求积法则，使用四个采样点 $(\\xi_m, \\eta_m)$，位于 $2\\times2$ 高斯求积横坐标处，即 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，但使用单位权重 ($w_m=1$)。因此，单元沙漏刚度矩阵近似为一个和：\n$$\nK_{hg}^{(e)} \\approx \\alpha \\sum_{m=1}^{4} \\mathbf{H}(\\xi_m, \\eta_m)^T \\mathbf{D} \\mathbf{H}(\\xi_m, \\eta_m) J(\\xi_m, \\eta_m) w_m = \\alpha \\sum_{m=1}^{4} \\mathbf{H}_m^T \\mathbf{D} \\mathbf{H}_m J_m\n$$\n稳定化参数 $\\alpha$ 被选择为与材料的剪切模量 $\\mu$ 成正比，因为沙漏模式通常以剪切变形为主。关系式为 $\\alpha = c_{\\alpha}\\mu$，其中 $c_{\\alpha}$ 是一个无量纲系数。材料属性由杨氏模量 $E$ 和泊松比 $\\nu$ 定义，从中可以导出 Lamé 参数 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\frac{E}{2(1+\\nu)}$。平面应变本构矩阵 $\\mathbf{D}$ 由下式给出：\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\n计算全局沙漏刚度矩阵 $K_{hg}^{\\text{global}}$ 的算法流程如下：\n1.  对于每个测试用例，初始化一个大小为 $(2 \\times N_{\\text{nodes}}) \\times (2 \\times N_{\\text{nodes}})$ 的零矩阵 $K_{hg}^{\\text{global}}$，其中 $N_{\\text{nodes}}$ 是网格中的总节点数。\n2.  计算材料属性 $\\lambda$、$\\mu$、本构矩阵 $\\mathbf{D}$ 和稳定化参数 $\\alpha$。如果 $\\alpha=0$，则沙漏刚度为零。\n3.  遍历网格中的每个单元：\n    a. 对于一个具有节点坐标 $\\mathbf{x}_i$ 的单元，首先计算其形心处的应变-位移矩阵 $\\mathbf{B}_{\\text{cent}} = \\mathbf{B}(0,0)$。这涉及到在 $(\\xi, \\eta)=(0,0)$ 处计算形函数导数、雅可比矩阵 $\\mathbf{J}$ 及其逆。\n    b. 初始化一个 $8 \\times 8$ 的单元沙漏刚度矩阵 $K_{hg}^{(e)}$ 为零。\n    c. 遍历四个指定的子单元点 $(\\xi_m, \\eta_m) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$：\n        i.  在每个点处，计算应变-位移矩阵 $\\mathbf{B}_m = \\mathbf{B}(\\xi_m, \\eta_m)$ 和雅可比行列式 $J_m = J(\\xi_m, \\eta_m)$。\n        ii. 形成偏差矩阵 $\\mathbf{H}_m = \\mathbf{B}_m - \\mathbf{B}_{\\text{cent}}$。\n        iii. 计算对单元刚度的贡献 $\\alpha \\mathbf{H}_m^T \\mathbf{D} \\mathbf{H}_m J_m$，并将其加到 $K_{hg}^{(e)}$ 上。\n    d. 使用单元的节点连接关系将计算出的 $K_{hg}^{(e)}$ 组装到全局矩阵 $K_{hg}^{\\text{global}}$ 中，即将局部自由度映射到全局自由度。\n4.  组装完所有单元的贡献后，计算对称、半正定的全局矩阵 $K_{hg}^{\\text{global}}$ 的特征值。\n5.  找出严格大于一个小的数值容差（例如 $10^{-9}$）的最小特征值。如果不存在这样的特征值，则结果为 $0.0$。为每个测试用例报告此值。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef compute_b_matrix_and_jacobian_det(xi, eta, node_coords):\n    \"\"\"\n    Computes the strain-displacement matrix B and Jacobian determinant J for a 4-node quad.\n\n    Args:\n        xi (float): xi-coordinate in the reference element [-1, 1].\n        eta (float): eta-coordinate in the reference element [-1, 1].\n        node_coords (np.ndarray): A 4x2 array of the element's nodal coordinates.\n\n    Returns:\n        tuple[np.ndarray, float]: A tuple containing the B matrix (3x8) and the Jacobian determinant.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n    # N1 = 0.25 * (1-xi) * (1-eta)\n    # N2 = 0.25 * (1+xi) * (1-eta)\n    # N3 = 0.25 * (1+xi) * (1+eta)\n    # N4 = 0.25 * (1-xi) * (1+eta)\n    dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n\n    # grad_N_ref is a 4x2 matrix of shape function derivatives w.r.t (xi, eta)\n    grad_N_ref = np.vstack((dNdxi, dNdeta)).T\n\n    # Jacobian matrix J of the isoparametric map: J_ij = d(x_i)/d(xi_j)\n    # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n    # (dx/dxi) = sum(dNi/dxi * xi), (dy/dxi) = sum(dNi/dxi * yi), etc.\n    # This can be computed as: J = node_coords.T @ grad_N_ref\n    jacobian = grad_N_ref.T @ node_coords\n    \n    det_J = np.linalg.det(jacobian)\n    if det_J <= 0:\n        raise ValueError(\"Jacobian determinant is non-positive, check element geometry.\")\n\n    inv_J = np.linalg.inv(jacobian)\n    \n    # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n    # [dNi/dx, dNi/dy] = [dNi/dxi, dNi/deta] @ inv(J)\n    grad_N_phys = grad_N_ref @ inv_J\n\n    B = np.zeros((3, 8))\n    for i in range(4):\n        dNi_dx = grad_N_phys[i, 0]\n        dNi_dy = grad_N_phys[i, 1]\n        B[0, 2 * i] = dNi_dx\n        B[1, 2 * i + 1] = dNi_dy\n        B[2, 2 * i] = dNi_dy\n        B[2, 2 * i + 1] = dNi_dx\n    \n    return B, det_J\n\ndef calculate_elem_hg_stiffness(node_coords, D_matrix, alpha):\n    \"\"\"\n    Calculates the element hourglass stiffness matrix.\n    \"\"\"\n    if alpha == 0.0:\n        return np.zeros((8, 8))\n\n    B_cent, _ = compute_b_matrix_and_jacobian_det(0.0, 0.0, node_coords)\n    \n    K_hg_elem = np.zeros((8, 8))\n    \n    g = 1.0 / np.sqrt(3.0)\n    subcell_points = [(-g, -g), (g, -g), (g, g), (-g, g)]\n\n    for xi_m, eta_m in subcell_points:\n        B_m, J_m = compute_b_matrix_and_jacobian_det(xi_m, eta_m, node_coords)\n        H_m = B_m - B_cent\n        # The problem specifies unit weights (w_m=1) for the quadrature.\n        K_hg_elem += alpha * (H_m.T @ D_matrix @ H_m) * J_m\n\n    return K_hg_elem\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute the smallest positive eigenvalue\n    of the global hourglass stiffness matrix.\n    \"\"\"\n    test_cases = [\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, 0.0), (1.0, 0.0), (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.1},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, -0.2), (1.0, 0.0), (0.0, 1.0), (0.5, 1.3), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.1},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, 0.0), (1.0, 0.0), (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.0},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, -0.2), (1.0, 0.0), (0.0, 1.0), (0.5, 1.3), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        E = case[\"E\"]\n        nu = case[\"nu\"]\n        c_alpha = case[\"c_alpha\"]\n\n        num_nodes = len(nodes)\n        K_global_hg = np.zeros((2 * num_nodes, 2 * num_nodes))\n\n        lame_lambda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        lame_mu = E / (2.0 * (1.0 + nu))\n        \n        D_matrix = np.array([\n            [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n            [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n            [0, 0, lame_mu]\n        ])\n        \n        alpha = c_alpha * lame_mu\n\n        if alpha == 0.0:\n            results.append(0.0)\n            continue\n            \n        for elem_node_indices in elements:\n            node_coords = nodes[elem_node_indices]\n            K_elem_hg = calculate_elem_hg_stiffness(node_coords, D_matrix, alpha)\n            \n            # Assembly\n            dof_map = np.array([[2 * n, 2 * n + 1] for n in elem_node_indices]).flatten()\n            K_global_hg[np.ix_(dof_map, dof_map)] += K_elem_hg\n\n        eigenvalues = eigvalsh(K_global_hg)\n        \n        # Find smallest strictly positive eigenvalue, using tolerance for numerical zero\n        positive_eigs = eigenvalues[eigenvalues > 1e-9]\n        \n        result = np.min(positive_eigs) if len(positive_eigs) > 0 else 0.0\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3404232"}]}