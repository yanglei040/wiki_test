{"hands_on_practices": [{"introduction": "在我们深入研究代数多重网格（AMG）的复杂实现之前，首先必须对支撑其效率的核心原理有扎实的理解。本练习 [@problem_id:3362553] 作为一个概念性的验证工具，它通过一系列基于模型问题的思想实验，挑战您应用关于平滑和粗网格校正的理论知识。通过分析不同组件（如插值算子）对收敛性的影响，您将学会如何预测一个多重网格方法的性能，而无需编写任何代码。", "problem": "考虑在线性系统的模型问题上验证代数多重网格的各个组成部分，这些线性系统来自于偏微分方程的数值解。设细网格线性系统为 $A u = f$，其中 $A$ 是对称正定的，并且来自均匀网格上的二阶有限差分。一个基本的双重网格方法由一个粗糙空间（通过延长算子 $P$ 定义）、一个限制算子 $R$、Galerkin 粗糙算子 $A_c = R A P$ 和一个光滑迭代矩阵 $S = I - M^{-1} A$ 定义，其中 $M$ 是一个选定的松弛预处理器。带有一次前光滑和一次后光滑扫描的双重网格误差传播的一步可以写为 $E = S_{\\mathrm{post}} \\left(I - P A_c^{-1} R A\\right) S_{\\mathrm{pre}}$。在模型问题上进行验证的目标是确认光滑和粗糙网格校正的原理：光滑器衰减高频误差，而粗糙网格校正消除可在粗糙网格上表示的分量。\n\n你需要根据这些原理在标准模型问题上进行推理，以评估以下陈述的有效性。选择所有正确的陈述。\n\nA. 考虑一维 Poisson 问题 $-u'' = f$ on $(0,1)$，带有齐次 Dirichlet 边界条件，在间距为 $h$ 的均匀网格上使用标准二阶中心有限差分进行离散化。使用一个双重网格方法，该方法采用系数为 $2$ 的经典粗化、全加权限制、线性插值，以及一次前光滑和一次后光滑的加权 Jacobi 扫描，其中权重 $\\omega \\in (0,2)$。存在一个 $\\omega \\in (0,2)$ 的选择，使得双重网格谱半径 $\\rho(E)$ 有一个严格小于 $1$ 的上界，且该上界与 $h$ 无关。\n\nB. 在与选项 A 相同的一维设置中，如果将线性插值替换为注入（从粗糙网格到细网格的分片常数插值），双重网格谱半径在 $h$ 上保持一致有界，因为光滑器会移除低频误差分量。\n\nC. 考虑单位正方形上的二维各向异性扩散算子 $-\\partial_{xx} - \\epsilon \\partial_{yy}$，使用均匀网格且 $0\\epsilon \\ll 1$。在经典代数多重网格中，对于一个连接强度阈值 $\\theta \\in (0,1)$，如果 $|a_{ji}| \\ge \\theta \\max_{k \\ne j} |a_{jk}|$，通常会将细网格点 $j$ 声明为与邻居 $i$ 强连接。如果选择的 $\\theta$ 过大，以至于许多物理上相关的耦合被当作弱连接而舍弃，那么使用与剩余强连接对齐的标准插值，当 $\\epsilon \\to 0$ 时，双重网格的收敛性可能会失去网格无关性，这种性能下降将通过在此模型问题上的验证揭示出来。\n\nD. 对于具有周期性边界条件、均匀网格间距 $h$、全加权限制和线性插值的一维 Poisson 问题，任何常数细网格误差分量都会被粗糙网格校正完全消除（假设精确求解粗糙网格问题），无论 $h$ 为何值。\n\n选择所有适用的选项。", "solution": "我们从基本定义开始。带有一次前光滑和一次后光滑扫描的双重网格误差传播是 $E = S_{\\mathrm{post}} \\left(I - P A_c^{-1} R A\\right) S_{\\mathrm{pre}}$，其中 $A_c = R A P$ 是 Galerkin 粗糙算子。项 $S = I - M^{-1} A$ 描述了一次松弛扫描，它应该衰减相对于细网格的高频分量。粗糙网格校正 $I - P A_c^{-1} R A$ 是一个到 $P$ 值域的 $A$-正交补空间上的 $A$-正交投影算子，因此它消除了位于 $P$ 值域内的误差分量。\n\n选项 A。一维 Poisson 问题，Dirichlet 边界条件，全加权，线性插值，加权 Jacobi 光滑，存在 $\\omega$ 使得双重网格收缩与 $h$ 无关。\n\n对一维 Poisson 模型进行验证的基本事实：\n\n- 在间距为 $h$ 的均匀网格上，离散算子 $A$ 的模板为 $\\left(-\\frac{1}{h^2}, \\frac{2}{h^2}, -\\frac{1}{h^2}\\right)$。加权 Jacobi 松弛的迭代矩阵为 $S = I - \\omega D^{-1} A$，其中 $D = \\frac{2}{h^2} I$ 且 $\\omega \\in (0,2)$。\n\n- 为了精确研究光滑过程，局部傅里叶分析 (Local Fourier Analysis, LFA) 将无限网格上的周期性边界条件视为一种理想化情况。一个 Fourier 模式 $\\varphi_\\theta(j) = e^{\\mathrm{i}\\theta j}$ 是 $S$ 符号的特征向量，其特征值为 $\\tilde{S}(\\theta) = 1 - \\omega \\tilde{D}^{-1}(\\theta)\\tilde{A}(\\theta)$。对于此模型，$\\tilde{D}^{-1}(\\theta) \\tilde{A}(\\theta) = 1 - \\cos \\theta$。因此，一次加权 Jacobi 扫描会将模式 $\\theta$ 的振幅乘以 $1 - \\omega (1 - \\cos \\theta)$。\n\n- 相对于细网格的高频模式是那些 $\\theta$ 接近 $\\pi$ 的模式，此时 $1 - \\cos \\theta$ 接近 $2$。使用经典选择 $\\omega = \\frac{2}{3}$，在 $\\theta = \\pi$ 处可得到高频阻尼因子等于 $|1 - 2 \\omega| = \\left|1 - \\frac{4}{3}\\right| = \\frac{1}{3}$。更一般地，对于任何固定的 $\\omega \\in (0,2)$，对于所有 $\\theta \\in (0,\\pi)$，量级 $|\\tilde{S}(\\theta)|$ 都严格小于 $1$，并且对于一个合适的 $\\omega$（例如，$\\omega$ 接近 $\\frac{2}{3}$），高频集合上的光滑因子的上界严格小于 $1$。\n\n- 由系数为 $2$ 的经典粗化和线性插值给出的粗糙空间能够表示误差的低频分量。在 LFA 框架中，粗糙网格校正消除了（在混叠效应容许范围内）位于 $P$ 值域内的低频谱分量。对于全加权限制、线性插值、精确粗糙网格求解以及一次前光滑和一次后光滑扫描，标准 LFA 表明，对于一个合适的 $\\omega$（例如 $\\omega = \\frac{2}{3}$），双重网格收敛因子有一个严格小于 $1$ 的上界，且该上界与 $h$ 无关。\n\n- 推理过程不依赖于任何与 $h$ 相关的性质，因为 Fourier 符号以及细网格和粗糙网格之间的混叠效应是在 $\\theta \\in [-\\pi,\\pi]$上定义的，与 $h$ 无关。因此，存在 $\\omega \\in (0,2)$ 使得 $\\rho(E) \\le \\eta  1$，其中 $\\eta$ 与 $h$ 无关。A 的结论：正确。\n\n选项 B。用注入代替线性插值，并声称因为光滑器移除了低频分量而具有一致收敛性。\n\n从相同的双重网格结构开始，但将 $P$ 设置为从粗糙点到细节点的注入（分片常数）。有效的粗糙网格校正所需的逼近性质是，细网格上的任何足够光滑（低频）的误差 $e$ 都可以被粗糙空间 $\\mathrm{range}(P)$ 中的向量很好地逼近。对于一维 Poisson 模型，注入不满足此性质：\n\n- 考虑一个在网格上缓慢变化的细网格误差，例如波数很小（$\\theta \\approx 0$）的离散余弦模式，或者更具体地说 $e_j = \\cos(\\theta j)$ 且 $\\theta = O(h)$。这是相对于细网格的低频误差分量，而这正是松弛方法不能显著减小的分量，因为对于 $\\theta \\approx 0$，Jacobi 光滑因子为 $|1 - \\omega(1 - \\cos \\theta)| \\approx |1 - \\omega \\cdot \\tfrac{\\theta^2}{2}| \\approx 1 - O(\\theta^2)$，即接近于 $1$。\n\n- 使用注入时，粗糙空间由在粗糙点之间分段为常数的向量组成。此类函数无法以 $O(1)$ 的精度在 $h$ 上一致地逼近一个光滑、缓慢变化的细网格误差；用分片常数对光滑模式的最佳逼近误差仅随着粗糙网格对变化的解析而衰减，当 $h$ 减小而粗化因子固定时，粗糙校正将留下光滑误差的一个显著分量。\n\n- 形式上，如果 $e \\notin \\mathrm{range}(P)$（当 $P$ 是注入时，低频光滑函数就是这种情况），那么 $e - P A_c^{-1} R A e$通常会保留一个沿着低频模式的分量，因为 $R A e$ 很小而 $A_c^{-1}$ 会将其放大，但投影算子 $I - P A_c^{-1} R A$ 仅在 $\\mathrm{range}(P)$ 上是精确的。\n\n因此，B 中的关键前提，即光滑器移除低频分量，是错误的：加权 Jacobi 移除高频分量；它不能有效地移除低频分量。如果没有一个能够逼近低频误差的粗糙空间，就会失去一致的双重网格收敛性。B 的结论：不正确。\n\n选项 C。各向异性，连接强度阈值过大，当 $\\epsilon \\to 0$ 时失去网格无关性。\n\n考虑在均匀网格上离散化的算子 $-\\partial_{xx} - \\epsilon \\partial_{yy}$，其中 $0\\epsilon \\ll 1$。得到的矩阵 $A$ 具有非对角线上的耦合项，对应于 $x$ 方向的耦合大小约为 $\\frac{1}{h_x^2}$，对应于 $y$ 方向的耦合大小约为 $\\frac{\\epsilon}{h_y^2}$。连接强度 (SoC) 测试在 $|a_{ji}| \\ge \\theta \\max_{k \\ne j} |a_{jk}|$ 时（对于 $\\theta \\in (0,1)$）声明点 $j$ 与点 $i$ 是强连接的。如果选择的 $\\theta$ 接近 $1$，那么只有量级与行最大值相当的邻居才被保留为强连接；在各向异性情况下，当 $\\epsilon \\ll 1$ 时，弱方向 $y$ 上的耦合量级为 $O(\\epsilon)$，因此当 $\\theta$ 很大时会被舍弃。\n\n经典的代数多重网格方法中，插值算子与强连接对齐，它构建的 $P$ 使得一个细网格点主要从其强连接邻居进行插值。当 $\\theta$ 过大时，强耦合图可能会变得实际上是一维的，甚至是断开的，从而无法忠实地捕捉连续的各向异性。这样，$P$ 的值域就无法逼近 $A$ 的近似零空间（沿弱方向缓慢变化的误差），从而违反了逼近性质。随着 $\\epsilon \\to 0$，算子变得越来越各向异性，$P$ 的不足之处也变得更加严重，这在此模型问题上的验证中表现为双重网格收敛因子随着网格加密和 $\\epsilon$ 减小而恶化。这一现象及其通过模型问题验证的检测方法在代数多重网格实践中是公认的。C 的结论：正确。\n\n选项 D。周期性一维问题，常数误差被全加权和线性插值的粗糙网格校正完全消除。\n\n假设一维问题具有周期性边界条件，因此常数向量是容许的误差模式。设 $P$ 是从粗糙网格进行的线性插值，$R$ 是全加权。考虑一个常数误差 $e \\in \\mathbb{R}^n$，定义为对于所有细网格索引 $j$，都有 $e_j = c$，其中 $c \\in \\mathbb{R}$ 是一个固定的常数。在均匀网格上，定义为对每个粗糙索引 $J$ 都有 $(e_c)_J = c$ 的粗糙网格常数向量 $e_c$ 满足 $P e_c = e$。因此，$e \\in \\mathrm{range}(P)$。对于 Galerkin 粗化，$A_c = R A P$，粗糙网格校正算子是到 $\\mathrm{range}(P)$ 的 $A$-正交补空间上的 $A$-正交投影算子，对于任何 $e \\in \\mathrm{range}(P)$，我们有\n$$\n\\left(I - P A_c^{-1} R A\\right) e\n= \\left(I - P A_c^{-1} R A\\right) P e_c\n= P e_c - P A_c^{-1} (R A P) e_c\n= P e_c - P A_c^{-1} A_c e_c\n= 0.\n$$\n因此，只要粗糙网格问题被精确求解，任何常数误差分量都会被粗糙网格校正完全消除，且与 $h$ 无关。D 的结论：正确。\n\n逐项分析总结：\n- A：正确，根据局部傅里叶分析，存在 $\\omega \\in (0,2)$，例如 $\\omega = \\frac{2}{3}$，使得双重网格收缩因子有一个严格小于 $1$ 的上界，且该上界与 $h$ 无关。\n- B：不正确，因为注入法不提供能够逼近低频误差的粗糙空间，且松弛法不移除低频分量。\n- C：正确，过大的连接强度阈值会在强各向异性下破坏逼近性质，而在模型问题上的验证可以检测到当 $\\epsilon \\to 0$ 时网格无关性的丧失。\n- D：正确，常数向量位于 $P$ 的值域内，并在周期性网格上被 Galerkin 粗糙网格校正完全移除。", "answer": "$$\\boxed{ACD}$$", "id": "3362553"}, {"introduction": "将理论付诸实践是掌握任何数值方法的关键一步。在上一个练习中我们已经验证了多重网格的核心思想，现在我们将通过具体编码来实现一个双网格求解器 [@problem_id:3362508]。本练习要求您为一维泊松问题构建并比较两种截然不同的粗化策略——经典的几何风格粗化与更现代的聚合粗化，并计算它们的收敛因子，从而直观地理解代数选择如何直接影响求解器的效率。", "problem": "考虑一个对称正定线性系统，该系统由一维泊松方程在单位区间上采用齐次狄利克雷边界条件，并经过标准中心差分格式离散化后得到。其离散算子是一个三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其对角线元素为 $2$，次对角线和超对角线元素为 $-1$，作用于 $n$ 个内部自由度。\n\n代数多重网格（AMG）中的双网格法由两个基本组成部分构建：一个光顺子和一个粗网格校正。对于权重 $\\omega \\in (0,1)$，加权雅可比光顺子的迭代矩阵定义为\n$$\nS(\\omega) = I - \\omega D^{-1} A,\n$$\n其中 $D$ 是 $A$ 的对角部分，$I$ 是大小为 $n$ 的单位矩阵。使用 $\\nu_1 \\in \\mathbb{N}_0$ 步前光顺和 $\\nu_2 \\in \\mathbb{N}_0$ 步后光顺，总的光顺算子分别为 $S(\\omega)^{\\nu_1}$ 和 $S(\\omega)^{\\nu_2}$。粗网格校正由延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$、限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$ 和伽辽金粗网格算子\n$$\nA_c = R A P \\in \\mathbb{R}^{n_c \\times n_c}\n$$\n定义。双网格误差传播算子为\n$$\nE_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} \\left( I - P A_c^{-1} R A \\right) S(\\omega)^{\\nu_1}.\n$$\n我们关心的量是谱半径\n$$\n\\rho\\left(E_{\\mathrm{TG}}\\right) = \\max\\{ |\\lambda| : \\lambda \\text{ is an eigenvalue of } E_{\\mathrm{TG}} \\},\n$$\n它预测了在 $\\ell_2$ 范数下，每个双网格循环的线性收敛因子。粗空间维数 $n_c$ 是粗网格自由度的数量，等于 $P$ 的列数。\n\n实现并比较两种代数粗化策略：\n\n- 策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$（比例-2粗化，线性插值，全加权）：\n  - 选择每隔一个细网格索引作为粗网格索引（在基于1的索引中，索引为 $2,4,6,\\dots$ 直到 $n$）。\n  - 通过分段线性插值定义 $P$：粗网格点以权重 $1$ 注入，位于两个相邻粗网格点之间的细网格点以权重和为 $1$ 进行线性插值；对于只有一个相邻粗网格点的边界附近细网格点，使用权重 $1$ 插值到该邻点。\n  - 通过全加权定义 $R$：对于与细网格索引 $i$ 相关联的粗网格索引，在细网格索引 $i-1$ 和 $i+1$（如果存在）上设置权重 $\\tfrac{1}{2}$，在细网格索引 $i$ 上设置权重 $1$。\n- 策略 $\\mathrm{A3\\text{-}PC}$（按大小为3的连续块进行聚合，分段常数）：\n  - 将细网格索引的有序集合划分为大小为 $3$ 的连续聚合（最后一个聚合可能更小）；因此，在基于1的索引中，对于所有有效的 $k$，第 $k$ 个聚合是集合 $\\{3k+1,3k+2,3k+3\\}$。\n  - 定义 $P$ 在聚合上是分段常数：如果细网格索引 $i$ 在聚合 $j$ 中，则 $P_{ij} = 1$，否则 $P_{ij} = 0$。\n  - 定义 $R = P^\\top$。\n\n您必须为下面的每个测试用例计算粗空间维数 $n_c$ 和上面定义的谱半径 $\\rho(E_{\\mathrm{TG}})$。使用所描述的精确 $A$、给定的精确 $S(\\omega)$ 和 $E_{\\mathrm{TG}}$，以及精确的 $A_c = R A P$ 而不进行近似。\n\n测试套件：\n- 用例 1：$n = 63$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 2：$n = 63$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 3：$n = 31$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = 0.8$，$\\nu_1 = 2$，$\\nu_2 = 0$。\n- 用例 4：$n = 5$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = 0.5$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- 用例 5：$n = 3$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n\n您的程序必须：\n- 根据指定的第一性原理构造 $A$、$P$ 和 $R$。\n- 构建 $S(\\omega)$、$A_c$、$E_{\\mathrm{TG}}$，并为每个用例计算 $n_c$ 和 $\\rho\\left(E_{\\mathrm{TG}}\\right)$。\n- 将每个 $\\rho\\left(E_{\\mathrm{TG}}\\right)$ 四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素都是一个双元素列表 $[n_c,\\rho]$，顺序与测试套件相同。例如，一个包含三个用例的输出应类似于 $[[n_{c,1},\\rho_1],[n_{c,2},\\rho_2],[n_{c,3},\\rho_3]]$，其中每个 $\\rho_j$ 打印出恰好 $6$ 位小数，且没有多余的空格。不应打印任何其他文本。", "solution": "首先验证问题，以确保其具有科学依据、是适定且客观的。\n\n### 步骤 1：提取给定条件\n- **系统矩阵**：矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是用于一维泊松方程的三对角矩阵，对角线元素为 $2$，次对角线/超对角线元素为 $-1$。\n- **加权雅可比光顺子迭代矩阵**：$S(\\omega) = I - \\omega D^{-1} A$，其中 $D$ 是 $A$ 的对角部分，$I$ 是单位矩阵，$\\omega \\in (0,1)$ 是一个权重。\n- **光顺步骤**：$\\nu_1 \\in \\mathbb{N}_0$ 步前光顺和 $\\nu_2 \\in \\mathbb{N}_0$ 步后光顺。\n- **粗网格分量**：延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$、限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$ 和伽辽金粗网格算子 $A_c = R A P \\in \\mathbb{R}^{n_c \\times n_c}$。\n- **双网格误差传播算子**：$E_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} \\left( I - P A_c^{-1} R A \\right) S(\\omega)^{\\nu_1}$。\n- **关心的量**：谱半径 $\\rho\\left(E_{\\mathrm{TG}}\\right)$，即 $E_{\\mathrm{TG}}$ 的特征值的最大绝对值。\n- **策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$**：\n    - **粗化**：粗网格索引为每隔一个的细网格索引，例如 $2, 4, 6, \\dots$（基于1的索引）。\n    - **延长算子 $P$**：分段线性插值。粗网格点注入（权重 $1$）。两个粗网格点之间的细网格点进行线性插值。只有一个粗网格邻点的边界附近细网格点使用权重 $1$ 插值到该邻点。\n    - **限制算子 $R$**：全加权。对于位于细网格位置 $i$ 的粗网格索引，在 $i-1$ 上的权重为 $\\tfrac{1}{2}$，在 $i$ 上的权重为 $1$，在 $i+1$ 上的权重为 $\\tfrac{1}{2}$。\n- **策略 $\\mathrm{A3\\text{-}PC}$**：\n    - **粗化**：将细网格索引划分为大小为 $3$ 的连续聚合（最后一个可能更小）。\n    - **延长算子 $P$**：分段常数。如果细网格索引 $i$ 在聚合 $j$ 中，则 $P_{ij} = 1$，否则为 $0$。\n    - **限制算子 $R$**：$R = P^\\top$。\n- **测试用例**：\n    1. $n = 63$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    2. $n = 63$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    3. $n = 31$，策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$，$\\omega = 0.8$，$\\nu_1 = 2$，$\\nu_2 = 0$。\n    4. $n = 5$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = 0.5$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n    5. $n = 3$，策略 $\\mathrm{A3\\text{-}PC}$，$\\omega = \\tfrac{2}{3}$，$\\nu_1 = 1$，$\\nu_2 = 1$。\n- **输出要求**：对每个用例，计算粗空间维数 $n_c$ 和 $\\rho(E_{\\mathrm{TG}})$，其中 $\\rho$ 四舍五入到 $6$ 位小数。\n\n### 步骤 2：使用提取的给定条件进行验证\n问题定义明确且科学上合理。它属于数值线性代数领域，特别是研究用于求解偏微分方程的多重网格方法。所有分量（$A$, $S(\\omega)$, $P$, $R$, $A_c$, $E_{\\mathrm{TG}}$）都是双网格分析的标准元素。粗化策略，尽管是特定的（R2-LI-FW有一个非标准的边界插值规则），但其描述足够精确，可以无歧义地实现。所有测试用例的参数都是完整和一致的。问题是自洽的，没有违反任何数学或科学原理。未发现任何缺陷。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n目标是为几个测试用例计算双网格误差传播算子 $E_{\\mathrm{TG}}$ 的粗空间维数 $n_c$ 和谱半径 $\\rho(E_{\\mathrm{TG}})$。这需要根据提供的规范构造所有组成矩阵（$A$, $S(\\omega)$, $P$, $R$, $A_c$）。我们对所有与矩阵和向量相关的计算采用基于零的索引。\n\n首先，我们构造系统矩阵 $A \\in \\mathbb{R}^{n \\times n}$。它是一个对称三对角矩阵，主对角线上为 $2$，第一亚对角线和超对角线上为 $-1$。\n$A_{ij} = \\begin{cases} 2  i=j \\\\ -1  |i-j|=1 \\\\ 0  \\text{否则} \\end{cases}$\n\n接下来，我们定义加权雅可比光顺子 $S(\\omega) = I - \\omega D^{-1} A$。矩阵 $A$ 的对角线元素恒为 $2$，因此其对角部分为 $D=2I$。于是，$D^{-1} = \\frac{1}{2}I$，光顺子简化为 $S(\\omega) = I - \\frac{\\omega}{2} A$。前光顺和后光顺算子分别为 $S(\\omega)^{\\nu_1}$ 和 $S(\\omega)^{\\nu_2}$，通过矩阵幂运算计算。\n\n任务的核心是为两种策略中的每一种构造延长算子 $P$ 和限制算子 $R$。\n\n#### 策略 $\\mathrm{R2\\text{-}LI\\text{-}FW}$（比例-2粗化，线性插值，全加权）\n1.  **粗化**：粗网格点被选为每隔一个的细网格点。在基于1的索引中，它们是 $\\{2, 4, 6, \\dots\\}$。在基于零的索引中，粗网格点索引为 $C = \\{1, 3, 5, \\dots, 2k+1, \\dots\\}$，对于所有满足 $2k+1  n$ 的 $k$。粗网格点的数量是 $n_c = \\lfloor n/2 \\rfloor$。仅为细网格的点是剩余的索引 $F = \\{0, 1, \\dots, n-1\\} \\setminus C$。\n\n2.  **延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$**：该矩阵将粗网格向量映射到细网格向量。其列构成了粗空间的一组基。\n    - 对于位于细网格索引 $i=2k+1$ 的粗网格点（对应于第 $k$ 个粗变量），其值被注入：$P$ 中对应于一个粗网格点的行，在该粗网格变量对应的列中有一个单独的 $1$。即 $P_{2k+1, k} = 1$。\n    - 对于内部的纯细网格点 $i=2k$ ($k0$)，它位于 $i-1=2k-1$ 和 $i+1=2k+1$ 的粗网格点之间。它以 $\\frac{1}{2}$ 的权重插值它们的值。这意味着 $P_{2k, k-1} = 0.5$ 和 $P_{2k, k} = 0.5$。\n    - 对于边界附近的细网格点，应用特殊规则。对于细网格点 $i=0$，它唯一的粗网格邻点在 $i=1$（第 $0$ 个粗变量）。规则指定权重为 $1$，所以 $P_{0,0}=1$。类似地，如果 $n$ 是奇数，细网格点 $i=n-1$ 与粗网格点 $i=n-2$（第 $(n_c-1)$ 个粗变量）相邻。其权重为 $1$，所以 $P_{n-1, n_c-1}=1$。\n\n3.  **限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$**：该矩阵将细网格向量映射到粗网格向量。\n    - 对于第 $k$ 个粗变量（与细网格索引 $i_c=2k+1$ 相关联），限制是 $i_c-1$、$i_c$ 和 $i_c+1$ 处值的加权平均。指定的模板是 $[\\frac{1}{2}, 1, \\frac{1}{2}]$。\n    - 因此，$R$ 的第 $k$ 行有非零项：$R_{k, i_c-1} = 0.5$，$R_{k, i_c} = 1$，$R_{k, i_c+1} = 0.5$，前提是这些索引在网格边界内，即在 $\\{0, \\dots, n-1\\}$ 中。\n\n#### 策略 $\\mathrm{A3\\text{-}PC}$（按大小为3的连续块进行聚合，分段常数）\n1.  **粗化**：细网格索引 $\\{0, 1, \\dots, n-1\\}$ 被划分为大小为 $3$ 的连续聚合。第 $k$ 个聚合是 $\\{3k, 3k+1, 3k+2\\}$。如果 $n$ 不是 $3$ 的倍数，最后一个聚合可能会更小。每个聚合定义一个粗网格变量。粗网格点的数量是 $n_c = \\lceil n/3 \\rceil$。\n\n2.  **延长算子 $P \\in \\mathbb{R}^{n \\times n_c}$**：插值在聚合上是分段常数。\n    - $P$ 的第 $k$ 列对应于第 $k$ 个聚合。对于属于聚合 $k$ 的所有行（细网格索引），其条目为 $1$，否则为 $0$。\n\n3.  **限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$**：限制算子定义为延长算子的转置，即 $R = P^\\top$。\n\n构造好 $A$, $S(\\omega)$, $P$ 和 $R$ 后，我们构建伽辽金粗网格算子 $A_c = RAP$。然后我们计算其逆矩阵 $A_c^{-1}$。双网格误差传播算子被组装为 $E_{\\mathrm{TG}} = S(\\omega)^{\\nu_2} (I - P A_c^{-1} R A) S(\\omega)^{\\nu_1}$。最后，我们计算 $E_{\\mathrm{TG}}$ 的特征值，并通过取其绝对值的最大值来找到谱半径 $\\rho(E_{\\mathrm{TG}})$。该值四舍五入到 $6$ 位小数。\n\n通过系统地应用此过程来计算每个测试用例的结果。", "answer": "```python\nimport numpy as np\n\ndef _construct_A(n):\n    \"\"\"Constructs the n x n discrete 1D Poisson matrix A.\"\"\"\n    if n == 0:\n        return np.array([])\n    # Start with a matrix of zeros\n    A = np.zeros((n, n))\n    # Fill diagonal with 2 and off-diagonals with -1\n    np.fill_diagonal(A, 2)\n    if n > 1:\n        np.fill_diagonal(A[1:], -1)\n        np.fill_diagonal(A[:, 1:], -1)\n    return A\n\ndef _construct_R2_LI_FW_operators(n):\n    \"\"\"Constructs P, n_c, and R for the R2-LI-FW strategy.\"\"\"\n    if n  2:\n        return np.zeros((n, 0)), 0, np.zeros((0, n))\n\n    n_c = n // 2\n    P = np.zeros((n, n_c))\n    \n    # Map from fine-grid coarse index to coarse-grid index (0-based)\n    coarse_map = {2 * k + 1: k for k in range(n_c)}\n\n    for i in range(n):\n        if i in coarse_map:  # Coarse point\n            P[i, coarse_map[i]] = 1.0\n        else:  # Fine-only point\n            if i == 0:\n                # Boundary-adjacent fine point with one coarse neighbor at index 1\n                # Coarse neighbor's coarse index is 0\n                P[i, 0] = 1.0\n            elif n % 2 != 0 and i == n - 1:\n                # Boundary-adjacent fine point (only if n is odd)\n                # Coarse neighbor is at n-2, whose coarse index is n_c-1\n                P[i, n_c - 1] = 1.0\n            else:\n                # Interior fine point, interpolate between two coarse neighbors\n                # Fine point i is even. Neighbors are i-1 and i+1.\n                coarse_neighbor1_fine_idx = i - 1\n                coarse_neighbor2_fine_idx = i + 1\n                coarse_neighbor1_coarse_idx = coarse_map[coarse_neighbor1_fine_idx]\n                coarse_neighbor2_coarse_idx = coarse_map[coarse_neighbor2_fine_idx]\n                P[i, coarse_neighbor1_coarse_idx] = 0.5\n                P[i, coarse_neighbor2_coarse_idx] = 0.5\n\n    R = np.zeros((n_c, n))\n    for j in range(n_c):\n        coarse_fine_idx = 2 * j + 1\n        if coarse_fine_idx > 0:\n            R[j, coarse_fine_idx - 1] = 0.5\n        R[j, coarse_fine_idx] = 1.0\n        if coarse_fine_idx  n - 1:\n            R[j, coarse_fine_idx + 1] = 0.5\n            \n    return P, n_c, R\n\ndef _construct_A3_PC_operators(n):\n    \"\"\"Constructs P, n_c, and R for the A3-PC strategy.\"\"\"\n    if n == 0:\n        return np.zeros((0, 0)), 0, np.zeros((0, 0))\n    \n    n_c = (n + 2) // 3  # Integer ceiling division\n    P = np.zeros((n, n_c))\n    \n    for j in range(n_c):\n        start_idx = 3 * j\n        end_idx = min(start_idx + 3, n)\n        P[start_idx:end_idx, j] = 1.0\n        \n    R = P.T\n    return P, n_c, R\n\ndef compute_spectral_radius(n, strategy, omega, nu1, nu2):\n    \"\"\"Computes n_c and rho(E_TG) for a given case.\"\"\"\n    A = _construct_A(n)\n    \n    if strategy == \"R2-LI-FW\":\n        P, n_c, R = _construct_R2_LI_FW_operators(n)\n    elif strategy == \"A3-PC\":\n        P, n_c, R = _construct_A3_PC_operators(n)\n    else:\n        raise ValueError(\"Unknown strategy\")\n\n    if n_c == 0:\n        return 0, 0.0\n\n    # Smoother\n    S_omega = np.identity(n) - (omega / 2.0) * A\n    \n    S1 = np.linalg.matrix_power(S_omega, nu1)\n    S2 = np.linalg.matrix_power(S_omega, nu2)\n    \n    # Coarse grid operator\n    A_c = R @ A @ P\n    \n    # Coarse grid correction operator\n    # For very small n_c, direct inversion is stable and efficient\n    A_c_inv = np.linalg.inv(A_c)\n    CGC = np.identity(n) - P @ A_c_inv @ R @ A\n    \n    # Two-grid error propagation operator\n    E_TG = S2 @ CGC @ S1\n    \n    # Spectral radius\n    eigenvalues = np.linalg.eigvals(E_TG)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return n_c, spectral_radius\n\ndef solve():\n    test_cases = [\n        {'n': 63, 'strategy': \"R2-LI-FW\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n        {'n': 63, 'strategy': \"A3-PC\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n        {'n': 31, 'strategy': \"R2-LI-FW\", 'omega': 0.8, 'nu1': 2, 'nu2': 0},\n        {'n': 5, 'strategy': \"A3-PC\", 'omega': 0.5, 'nu1': 1, 'nu2': 1},\n        {'n': 3, 'strategy': \"A3-PC\", 'omega': 2/3, 'nu1': 1, 'nu2': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        n_c, rho = compute_spectral_radius(\n            case['n'], case['strategy'], case['omega'], case['nu1'], case['nu2']\n        )\n        results.append(f\"[{n_c},{rho:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3362508"}, {"introduction": "一个高效的代数多重网格（AMG）求解器不仅仅是快速收敛，更重要的是我们能理解其性能背后的原因，并有能力对其进行优化。本项高级练习 [@problem_id:3362523] 介绍了一种强大的诊断技术，即利用特征值分析来定量评估您所选择的插值算子 $P$ 捕捉“最光滑”误差分量的能力。通过此练习，您不仅将学会如何诊断一个AMG方法的关键组件，还将探索如何系统性地改进这些组件，这是设计高性能AMG算法的核心技能。", "problem": "您的任务是构建一个基于特征值的诊断工具，用以评估代数多重网格的粗化和延拓如何影响由二维泊松方程（带有齐次狄利克雷边界条件）的标准五点离散所产生的对称正定矩阵对光滑误差模式的表示。此任务的基本依据如下：\n\n- 在 $n \\times n$ 内部网格上的离散算子是一个对称正定矩阵 $A \\in \\mathbb{R}^{N \\times N}$，其中 $N = n^2$。该矩阵由一维二阶差分算子的克罗内克和构成。一维算子是三对角矩阵 $T_n = \\operatorname{tridiag}(-1,2,-1)$。\n- $A$ 的特征对 $(\\lambda_i, v_i)$ 满足 $A v_i = \\lambda_i v_i$，其中 $0  \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_N$。对于泊松算子，最小的特征模态对应于最光滑的误差分量。\n- 粗空间由一个延拓算子 $P \\in \\mathbb{R}^{N \\times N_c}$ 定义。伽辽金粗化算子为 $A_c = P^{\\top} A P \\in \\mathbb{R}^{N_c \\times N_c}$。\n- 到 $\\operatorname{range}(P)$ 上的 $A$-正交投影算子是 $\\Pi_P = P \\left(P^{\\top} A P\\right)^{-1} P^{\\top} A$。对于任意向量 $x \\in \\mathbb{R}^N$，其 $A$-范数为 $\\lVert x \\rVert_A = \\sqrt{x^{\\top} A x}$。\n- 非零向量 $x$ 关于 $A$ 的瑞利商是 $\\mathcal{R}_A(x) = \\dfrac{x^{\\top} A x}{x^{\\top} x}$。如果 $y$ 是 $A_c$ 的一个特征向量，那么细网格向量 $x = P y$ 的瑞利商可作为一个里兹值，用于在粗空间上近似 $A$ 的一个特征值。\n\n您的程序必须为每个测试用例实现以下诊断功能：\n\n1) 为 $n \\times n$ 网格构建矩阵 $A$。计算 $A$ 的 $k$ 个最小特征对 $(\\lambda_i, v_i)$。\n\n2) 根据指定的粗化策略，在每个空间维度上粗化因子为 $2$ 的规则网格上构建延拓算子 $P$：\n   - 对于标记为“pc”（分片常数）的类型，在一维中使用最近邻注入，并通过克罗内克积得到二维的 $P$。\n   - 对于标记为“linear”（线性）的类型，在一维中使用标准线性插值（对于齐次狄利克雷边界，这是几何粗化因子为 $2$ 的精确限制/延拓），并通过克罗内克积得到二维的 $P$。\n\n3) 形成 $A_c = P^{\\top} A P$。对于 $A$ 的 $k$ 个最小特征向量 $v_i$ 中的每一个，计算 $A$-正交投影误差\n$$\ne_i = v_i - \\Pi_P v_i = v_i - P\\left(P^{\\top} A P\\right)^{-1} P^{\\top} A v_i,\n$$\n以及相对 $A$-范数覆盖度量\n$$\nc_i = \\frac{\\lVert e_i \\rVert_A}{\\lVert v_i \\rVert_A}。\n$$\n报告平均覆盖率 $\\overline{c} = \\dfrac{1}{k} \\sum_{i=1}^k c_i$ 和最大覆盖率 $\\max_i c_i$。\n\n4) 计算 $A_c$ 的 $k_c$ 个最小特征对 $(\\mu_j, y_j)$，其中 $k_c = \\min\\{k, N_c - 1\\}$ 以满足 $k_c  N_c$。通过 $x_j = P y_j$ 将每个粗网格特征向量映射到细网格，计算其瑞利商 $\\theta_j = \\mathcal{R}_A(x_j)$，并报告最小粗网格里兹值相对于最小真实细网格特征值的相对误差：\n$$\n\\delta = \\frac{\\min_j \\theta_j - \\lambda_1}{\\lambda_1}。\n$$\n\n5) 构建单步光滑延拓 $P_s = \\left(I - \\omega D^{-1} A\\right) P$，其中 $D = \\operatorname{diag}(A)$，$\\omega$ 是一个固定的光滑参数。使用 $P_s$ 重新计算 $\\overline{c}_s$，并报告一个改进指标\n$$\n\\text{improved} =\n\\begin{cases}\n1,   \\text{if } \\overline{c}_s  \\overline{c} - \\varepsilon,\\\\\n0,   \\text{otherwise,}\n\\end{cases}\n$$\n其中容差为 $\\varepsilon = 10^{-12}$。\n\n实现细节与约束：\n\n- 使用上述有限差分离散方法将 $A$ 组装成一个稀疏矩阵。假设为齐次狄利克雷边界条件。\n- 对于“pc”，构建一维最近邻注入延拓 $P_1 \\in \\mathbb{R}^{n \\times m}$，其中 $m = \\lfloor n/2 \\rfloor$，并设置 $P = P_2 \\otimes P_1$，这里 $P_2 = P_1$ 且 $\\otimes$ 表示克罗内克积。具体而言，对于行索引 $j \\in \\{1,\\dots,n\\}$，以单位权重映射到粗网格列 $i = \\left\\lfloor \\dfrac{j+1}{2} \\right\\rfloor$，并将其限制在 $\\{1,\\dots,m\\}$ 范围内。\n- 对于“linear”，按如下方式构建一维线性插值 $P_1 \\in \\mathbb{R}^{n \\times m}$：对于偶数 $j = 2 i$，设置 $(P_1)_{j,i} = 1$；对于奇数 $j = 2 i - 1$，对 $(P_1)_{j,i}$ 加上 $\\tfrac{1}{2}$，并且如果 $i > 1$，则还对 $(P_1)_{j,i-1}$ 加上 $\\tfrac{1}{2}$。然后设置 $P = P_2 \\otimes P_1$，其中 $P_2 = P_1$。\n- 使用 $k = 6$ 和光滑参数 $\\omega = 0.67$。\n- 所有线性代数运算必须使用浮点类型进行精确算术；除指定方法外，不要引入其他启发式方法。\n\n测试套件：\n\n- 用例 1：$n = 16$，延拓类型“pc”。\n- 用例 2：$n = 16$，延拓类型“linear”。\n- 用例 3：$n = 20$，延拓类型“pc”。\n\n对于每个用例，您的程序必须计算并返回列表 $[\\overline{c}, \\max_i c_i, \\delta, \\text{improved}]$，其中 $\\overline{c}$、$\\max_i c_i$ 和 $\\delta$ 是实数，$\\text{improved}$ 是 $\\{0,1\\}$ 中的整数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由逗号分隔的列表组成的列表，并用方括号括起来（例如，“[[a,b,c,d],[e,f,g,h],[i,j,k,l]]”）。输出中不允许有多余的空格或文本。", "solution": "用户希望实现一套诊断工具，用于分析二维泊松方程的代数多重网格（AMG）组件。该分析涉及评估不同的延拓算子在表示细网格系统矩阵的最光滑特征向量方面的性能。这是多重网格方法开发和分析中的一个标准流程。该问题具有充分的科学依据，算法上具体明确，且计算上可行。\n\n该分析可分解为以下系统性步骤：\n\n1.  **系统矩阵组装**：系统矩阵 $A$ 对应于带有齐次狄利克雷边界条件的 $n \\times n$ 网格上负拉普拉斯算子的五点有限差分离散。总自由度为 $N = n^2$。该矩阵可以由两个一维二阶差分算子的克罗内克和构成，$A = I_n \\otimes T_n + T_n \\otimes I_n$，其中 $T_n$ 是 $n \\times n$ 的三对角矩阵 $T_n = \\operatorname{tridiag}(-1, 2, -1)$。所得矩阵 $A$ 是对称正定（SPD）的。其对角线元素均为 4，因此其对角阵为 $D = 4I$。\n\n2.  **细网格特征分析**：$A$ 的最小特征值对应的特征向量是网格上最光滑的模式。这些是松弛法（如 Jacobi 或 Gauss-Seidel）收敛缓慢的模式。一个有效的多重网格方法必须能够在粗网格上很好地表示这些光滑模式。我们计算 $A$ 的 $k=6$ 个最小特征值 $\\lambda_i$ 及其对应的特征向量 $v_i$。这可以通过适用于大型稀疏对称矩阵的迭代特征求解器来实现。特征向量 $v_i$ 是归一化的，即 $\\lVert v_i \\rVert_2 = 1$。\n\n3.  **延拓算子构建**：延拓（或插值）算子 $P$ 将向量从粗网格映射到细网格。我们考虑一种标准的粗化策略，即每个维度上的网格点数减半，从 $n$ 减至 $m = \\lfloor n/2 \\rfloor$。粗网格点总数为 $N_c = m^2$。二维延拓算子 $P \\in \\mathbb{R}^{N \\times N_c}$ 由克罗内克积 $P = P_1 \\otimes P_1$ 形成，其中 $P_1 \\in \\mathbb{R}^{n \\times m}$ 是一维延拓算子。\n    *   对于**分片常数**插值（“pc”），一个粗网格值被复制到一组相邻的细网格点上。根据所给公式 $i = \\lfloor(j+1)/2\\rfloor$（使用 1-based 索引），来自粗网格点 $i$ 的值被赋给细网格点 $2i-1$ 和 $2i$。\n    *   对于**线性**插值（“linear”），细网格点上的值由最近的粗网格点插值得到。在齐次狄利克雷边界条件下，这涉及到权重 $\\frac{1}{2}$ 和 $1$。所提供的具体规则正确地构建了标准的一维线性延拓矩阵。\n\n4.  **粗网格算子**：粗网格算子 $A_c$ 使用伽辽金投影形成：$A_c = P^\\top A P$。由于 $A$ 是对称正定（SPD）且 $P$ 是列满秩的，因此 $A_c$ 也是对称正定的。\n\n5.  **投影误差和覆盖度量**：延拓算子 $P$ 的质量通过它表示光滑特征向量 $v_i$ 的优劣来衡量。在 $P$ 的值域（表示为 $\\operatorname{range}(P)$）中对 $v_i$ 的最佳逼近是其 $A$-正交投影 $\\Pi_P v_i$。该投影算子由 $\\Pi_P = P(P^\\top A P)^{-1} P^\\top A$ 给出。逼近误差为 $e_i = v_i - \\Pi_P v_i$。一个关键的诊断指标是 $A$-范数下的相对误差 $c_i = \\frac{\\lVert e_i \\rVert_A}{\\lVert v_i \\rVert_A}$。\n    利用 $A$-正交投影的性质，对任意向量 $x$，有 $\\lVert x \\rVert_A^2 = \\lVert \\Pi_P x \\rVert_A^2 + \\lVert (I - \\Pi_P) x \\rVert_A^2$。因此，$\\lVert e_i \\rVert_A^2 = \\lVert v_i \\rVert_A^2 - \\lVert \\Pi_P v_i \\rVert_A^2$。\n    由于 $v_i$ 是 $A$ 的特征值为 $\\lambda_i$ 的特征向量，并且是 $L_2$ 范数归一化的，我们有 $\\lVert v_i \\rVert_A^2 = v_i^\\top A v_i = \\lambda_i v_i^\\top v_i = \\lambda_i$。\n    投影向量的范数为 $\\lVert \\Pi_P v_i \\rVert_A^2 = (\\Pi_P v_i)^\\top A (\\Pi_P v_i) = (P y_i)^\\top A (P y_i) = y_i^\\top (P^\\top A P) y_i = y_i^\\top A_c y_i$，其中 $y_i = (P^\\top A P)^{-1} P^\\top A v_i = A_c^{-1} (P^\\top A v_i)$。代入 $y_i$ 可得 $\\lVert \\Pi_P v_i \\rVert_A^2 = (P^\\top A v_i)^\\top A_c^{-1} (P^\\top A v_i) = (P^\\top A v_i)^\\top y_i$。\n    这导出了覆盖度量平方的计算高效公式：\n    $$ c_i^2 = 1 - \\frac{\\lVert \\Pi_P v_i \\rVert_A^2}{\\lVert v_i \\rVert_A^2} = 1 - \\frac{(P^\\top A v_i)^\\top y_i}{\\lambda_i} $$\n    我们计算前 $k$ 个特征向量的这些值的平均值 $\\overline{c}$ 和最大值 $\\max_i c_i$。\n\n6.  **粗网格特征值分析**：另一种质量度量是考察粗网格问题 $A_c y = \\mu y$ 对细网格特征问题的逼近程度。$A_c$ 的特征对 $(\\mu_j, y_j)$ 为 $A$ 生成里兹对 $(\\theta_j, x_j)$，其中 $x_j = P y_j$，$\\theta_j$ 是瑞利商 $\\mathcal{R}_A(x_j) = \\frac{x_j^\\top A x_j}{x_j^\\top x_j}$。最小的里兹值 $\\min_j \\theta_j$ 应当近似于最小的细网格特征值 $\\lambda_1$。我们计算相对误差 $\\delta = (\\min_j \\theta_j - \\lambda_1) / \\lambda_1$。为此，我们计算 $A_c$ 的 $k_c = \\min\\{k, N_c - 1\\}$ 个最小特征对。\n\n7.  **光滑延拓**：$P$ 的表示质量通常可以通过应用几步松弛法（光滑）来改善。我们对 $P$ 应用一步阻尼雅可比光滑。光滑后的延拓算子为 $P_s = (I - \\omega D^{-1} A) P$，阻尼因子 $\\omega=0.67$，且 $D=\\operatorname{diag}(A)=4I$。然后我们使用 $P_s$ 重新评估平均覆盖率 $\\overline{c}_s$，并判断是否有显著改进，即如果 $\\overline{c}_s  \\overline{c} - \\varepsilon$（对于一个小的容差 $\\varepsilon=10^{-12}$），则改进指标 $\\text{improved} = 1$。这个过程模拟了 AMG 中更高级延拓算子的构建方法。\n\n该实现将依赖于 `scipy.sparse` 的稀疏矩阵表示来有效管理内存和计算成本。特征值问题将使用 `scipy.sparse.linalg.eigsh` 求解，而小型的稠密线性系统将由 `scipy.sparse.linalg.spsolve` 处理。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\n\ndef build_poisson_matrix(n):\n    \"\"\"Constructs the 2D Poisson matrix A on an n x n grid.\"\"\"\n    N = n * n\n    T_n = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(n, n), format='csc')\n    I_n = sparse.identity(n, format='csc')\n    A = sparse.kronsum(T_n, T_n)\n    return A.asformat('csc')\n\ndef build_1d_prolongation(n, p_type):\n    \"\"\"Constructs the 1D prolongation operator P1.\"\"\"\n    if n % 2 != 0:\n        # The problem spec only considers even n, but for robustness\n        # one might need a specification for odd n. We adhere to problem constraints.\n        pass\n    m = n // 2\n    \n    rows, cols, data = [], [], []\n    \n    if p_type == \"pc\":\n        # Piecewise constant interpolation\n        # Based on j_fine_idx maps to i_coarse_idx = floor((j_fine_idx+2)/2) - 1\n        # This simplifies to i_coarse_idx = j_fine_idx // 2\n        for j in range(n):\n            i = j // 2\n            if i  m:\n                rows.append(j)\n                cols.append(i)\n                data.append(1.0)\n    elif p_type == \"linear\":\n        # Linear interpolation\n        # Coarse node i is at fine position 2i+1. Fine node 2i is between i-1 and i.\n        # This corresponds to the rules after 0-based index conversion.\n        for i in range(m):\n            # Coarse node i maps to fine node 2*i+1\n            rows.append(2 * i + 1)\n            cols.append(i)\n            data.append(1.0)\n            \n            # Fine node 2*i is between coarse nodes i-1 and i\n            j_odd = 2 * i\n            if j_odd  n:\n                if i > 0:\n                    rows.append(j_odd)\n                    cols.append(i - 1)\n                    data.append(0.5)\n                rows.append(j_odd)\n                cols.append(i)\n                data.append(0.5)\n\n    return sparse.coo_matrix((data, (rows, cols)), shape=(n, m)).asformat('csc')\n\ndef compute_coverage_metrics(A, P, k, lambdas, vecs):\n    \"\"\"Computes mean and max coverage for a given prolongation P.\"\"\"\n    A_c = P.T @ A @ P\n    \n    # Use a sparse solver. For small Nc, can convert to dense and use np.linalg.solve\n    # A_c_dense = A_c.toarray()\n    \n    coverages = np.zeros(k)\n    for i in range(k):\n        v = vecs[:, i]\n        lambda_i = lambdas[i]\n        \n        b_i = P.T @ (A @ v)\n        \n        # Solve Ac y = b. Use spsolve for sparse systems.\n        y_i = sla.spsolve(A_c, b_i)\n\n        # Numerator is y_i.T @ A_c @ y_i = y_i.T @ b_i\n        # Denominator is v.T @ A @ v = lambda_i * v.T @ v = lambda_i\n        # Using the formulation c_i^2 = 1 - (b_i.T @ y_i) / lambda_i\n        # This is more stable than forming the error vector e_i\n        inner_prod = b_i.T @ y_i\n        \n        if lambda_i  1e-15: # Avoid division by zero, though not expected here\n            c_i_sq = 1.0\n        else:\n            c_i_sq = 1.0 - inner_prod / lambda_i\n        \n        # Clamp to avoid small negative values from floating point errors\n        coverages[i] = np.sqrt(max(0, c_i_sq))\n        \n    mean_c = np.mean(coverages)\n    max_c = np.max(coverages)\n    \n    return mean_c, max_c\n\ndef run_case(n, p_type, k, omega, epsilon):\n    \"\"\"Runs a single test case for the AMG diagnostic problem.\"\"\"\n    # 1. Construct A and get its smallest eigenpairs\n    A = build_poisson_matrix(n)\n    N = n * n\n    # For SPD matrices, 'SM' (smallest magnitude) is equivalent to 'SA' (smallest algebraic)\n    lambdas, vecs = sla.eigsh(A, k=k, which='SM')\n\n    # 2. Construct prolongation operator P\n    m = n // 2\n    Nc = m * m\n    P1d = build_1d_prolongation(n, p_type)\n    P = sparse.kron(P1d, P1d, format='csc')\n\n    # 3. Compute coverage metrics for P\n    c_bar, c_max = compute_coverage_metrics(A, P, k, lambdas, vecs)\n    \n    # 4. Compute coarse Ritz value error\n    A_c = P.T @ A @ P\n    kc = min(k, Nc - 1)\n    \n    # For small A_c, using dense eigh is efficient and robust\n    mu, Y = np.linalg.eigh(A_c.toarray())\n    mu_smallest = mu[:kc]\n    Y_smallest = Y[:, :kc]\n    \n    thetas = np.zeros(kc)\n    for j in range(kc):\n        y_j = Y_smallest[:, j]\n        x_j = P @ y_j\n        \n        numerator = x_j.T @ A @ x_j\n        denominator = x_j.T @ x_j\n        thetas[j] = numerator / denominator\n    \n    min_theta = np.min(thetas)\n    lambda_1 = lambdas[0]\n    delta = (min_theta - lambda_1) / lambda_1\n\n    # 5. Compute smoothed prolongation and its coverage\n    D_diag = A.diagonal()\n    if np.all(D_diag == D_diag[0]):\n        # Optimized path for constant diagonal\n        d_inv = 1.0 / D_diag[0]\n        Ps = P - (omega * d_inv) * (A @ P)\n    else:\n        # General case (not needed for this problem)\n        D_inv = sparse.diags(1.0 / D_diag, format='csc')\n        Ps = P - omega * (D_inv @ A @ P)\n\n    # Recompute coverage with Ps\n    cs_bar, _ = compute_coverage_metrics(A, Ps, k, lambdas, vecs)\n    \n    improved = 1 if cs_bar  c_bar - epsilon else 0\n    \n    return [c_bar, c_max, delta, improved]\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, \"pc\"),\n        (16, \"linear\"),\n        (20, \"pc\"),\n    ]\n    \n    k = 6\n    omega = 0.67\n    epsilon = 1e-12\n    \n    results = []\n    for n, p_type in test_cases:\n        case_result = run_case(n, p_type, k, omega, epsilon)\n        results.append(f\"[{','.join(f'{x:.6g}' for x in case_result)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3362523"}]}