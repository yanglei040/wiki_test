{"hands_on_practices": [{"introduction": "在移动网格上开发任何数值方法时，一个基本要求是该方法必须能精确地表示单元体积的变化。这个原则被称为几何守恒律（GCL）。本节的第一个练习是一个基础的“纸笔”推导问题[@problem_id:3423641]，它将引导您探究几何守恒律如何对有限体积法的时间积分部分施加一个特定约束，以保证格式达到二阶精度。", "problem": "考虑移动区间 $K(t) = [x_{L}(t), x_{R}(t)]$ 上的一维守恒律 $\\partial_{t} u + \\partial_{x} f(u) = 0$。设任意拉格朗日-欧拉(ALE)映射在参考坐标 $\\xi \\in [0,1]$ 中是线性的，由 $x(\\xi,t) = x_{L}(t) + \\big(x_{R}(t) - x_{L}(t)\\big)\\,\\xi$ 给出。定义面速度为 $w_{L}(t) = \\partial_{t} x_{L}(t)$ 和 $w_{R}(t) = \\partial_{t} x_{R}(t)$，并设单元体积为 $V(t) = x_{R}(t) - x_{L}(t)$。考虑从 $t^{n}$到 $t^{n+1}$ 的一个时间步，其中 $\\Delta t = t^{n+1} - t^{n}$。\n\n一个二阶有限体积格式是基于 $[t^{n}, t^{n+1}]$ 上的时空控制体构建的，并通过以下形式的两点时间近似来逼近穿过每个空间面的网格平流的时空通量：\n$$\nw_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n},\n$$\n其中 $\\star \\in \\{L, R\\}$ 表示左侧或右侧面，且 $w_{\\star}^{n} = w_{\\star}(t^{n})$，$w_{\\star}^{n+1} = w_{\\star}(t^{n+1})$。两个面使用相同的时间离散化，具有相同的未知权重 $\\theta \\in \\mathbb{R}$。\n\n几何守恒律(GCL)要求空间均匀解 $u(x,t) \\equiv u_{0}$ 被全离散格式精确保持。假设在该时间步内，每个面的轨迹在时间上是线性的，即在 $[t^{n}, t^{n+1}]$ 上 $x_{\\star}(t)$ 是 $t$ 的仿射函数。在这些假设下，对上述时空有限体积公式强制执行离散GCL，并确定权重 $\\theta$ 的唯一值，该值能保证对于任意的 $u_{0}$ 和在该时间步内任意的线性面运动，解 $u(x,t) \\equiv u_{0}$ 都被精确保持。\n\n你的最终答案必须是 $\\theta$ 的值，以单个数字表示。不需要单位，也无需四舍五入。", "solution": "该问题要求在一个半离散有限体积格式中找到权重 $\\theta$ 的唯一值，以保证几何守恒律(GCL)得到满足。GCL确保在移动网格上，数值格式能精确保持均匀状态 $u(x,t) = u_0$。\n\n一维守恒律由下式给出\n$$\n\\partial_{t} u + \\partial_{x} f(u) = 0\n$$\n作用于移动单元 $K(t) = [x_L(t), x_R(t)]$ 上。\n\n让我们首先推导守恒律在由单元 $K(t)$ 从时间 $t^n$ 移动到 $t^{n+1}$ 所定义的时空控制体上的精确积分形式。使用莱布尼茨积分法则（或一维的雷诺输运定理），$u$ 在 $K(t)$ 上的积分随时间的演化为：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u(x,t) \\,dx = \\int_{x_L(t)}^{x_R(t)} \\partial_t u \\,dx + u(x_R(t), t) \\frac{dx_R}{dt} - u(x_L(t), t) \\frac{dx_L}{dt}\n$$\n代入 $\\partial_t u = -\\partial_x f(u)$ 以及面速度的定义 $w_L(t) = \\partial_t x_L(t)$ 和 $w_R(t) = \\partial_t x_R(t)$：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = \\int_{x_L(t)}^{x_R(t)} (-\\partial_x f(u)) \\,dx + u_R w_R - u_L w_L\n$$\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u \\,dx = -[f(u_R) - f(u_L)] + u_R w_R - u_L w_L\n$$\n其中 $u_L = u(x_L(t), t)$ 和 $u_R = u(x_R(t), t)$。这就是守恒律的任意拉格朗日-欧拉(ALE)形式。\n\nGCL 是对数值格式处理几何方式的一个条件。它通过考虑均匀流 $u(x,t) = u_0$（其中 $u_0$ 是常数）的情况导出。在这种情况下，$f(u) = f(u_0)$ 也是常数，物理通量项 $\\partial_x f(u)$ 为零。守恒律简化为 $\\partial_t u = 0$。ALE形式变为：\n$$\n\\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} u_0 \\,dx = u_0 w_R - u_0 w_L\n$$\n由于 $u_0$ 是常数，我们可以将其提出：\n$$\nu_0 \\frac{d}{dt} \\int_{x_L(t)}^{x_R(t)} 1 \\,dx = u_0 (w_R - w_L)\n$$\n该积分是单元的体积（长度），$V(t) = x_R(t) - x_L(t)$。因此，我们有：\n$$\nu_0 \\frac{dV(t)}{dt} = u_0 (w_R - w_L)\n$$\n由于 $\\frac{dV}{dt} = \\frac{d}{dt}(x_R - x_L) = w_R - w_L$，这个方程是一个恒等式。现在，我们将此恒等式在时间步 $[t^n, t^{n+1}]$ 上积分：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dV(t)}{dt} \\,dt = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n$$\nV(t^{n+1}) - V(t^n) = \\int_{t^n}^{t^{n+1}} w_R(t) \\,dt - \\int_{t^n}^{t^{n+1}} w_L(t) \\,dt\n$$\n令 $V^n = V(t^n)$，这就是GCL的精确积分形式：\n$$\nV^{n+1} - V^{n} = \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n离散格式必须精确地满足这个几何关系。\n\n有限体积格式将单元平均值 $\\bar{u}$ 从时间 $t^n$ 更新到 $t^{n+1}$。更新的通用形式为：\n$$\nV^{n+1}\\bar{u}^{n+1} - V^n \\bar{u}^n + \\Delta t (\\hat{F}_R - \\hat{F}_L) = 0\n$$\n其中 $\\hat{F}_\\star$ 是在面 $\\star \\in \\{L, R\\}$ 上的数值通量。数值通量包括物理部分和网格运动部分。对于 $u=u_0$ 的GCL测试，物理通量相互抵消，更新方程得以简化。条件 $\\bar{u}^{n+1} = \\bar{u}^n = u_0$ 导出了离散GCL。\n问题指定通量的几何部分使用离散网格速度 $w_\\star^{\\text{disc}}$ 来近似。从格式中导出的离散GCL是：\n$$\n\\frac{V^{n+1} - V^n}{\\Delta t} = w_R^{\\text{disc}} - w_L^{\\text{disc}}\n$$\n其中 $w_{\\star}^{\\text{disc}} = \\theta\\, w_{\\star}^{n+1} + (1 - \\theta)\\, w_{\\star}^{n}$。\n\n为了使离散格式满足GCL，其对体积变化的表示必须与精确积分形式相匹配。通过令精确和离散的GCL表达式相等，我们得到关于 $\\theta$ 的条件：\n$$\nw_R^{\\text{disc}} - w_L^{\\text{disc}} = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n代入 $w^{\\text{disc}}$ 的定义：\n$$\n\\theta(w_R^{n+1} - w_L^{n+1}) + (1-\\theta)(w_R^n - w_L^n) = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} (w_R(t) - w_L(t)) \\,dt\n$$\n问题陈述要求对“任意的在时间上呈线性的面运动”强制执行此条件，即 $x_\\star(t)$ 是仿射函数。如果 $x_\\star(t)$ 在时间上是线性的，$x_\\star(t) = a_\\star t + b_\\star$，那么速度 $w_\\star(t) = \\partial_t x_\\star(t) = a_\\star$ 在该区间内是常数。因此，$w_\\star^n = w_\\star(t^n)$ 等于 $w_\\star^{n+1} = w_\\star(t^{n+1})$，并且积分 $\\int_{t^n}^{t^{n+1}} w_\\star(t)\\,dt$ 就是 $w_\\star \\Delta t$。对于恒定速度，该方程变为一个恒等式 $(w_R - w_L) = (w_R - w_L)$，这对任何 $\\theta$ 值都成立。这与问题要求找到一个*唯一* $\\theta$ 值的要求相矛盾。\n\n这个矛盾源于一个不精确的问题陈述。“一个二阶有限体积格式”这个短语是关键。一个数值格式的时间精度阶是由其时间积分的精度决定的。表达式 $\\theta G^{n+1} + (1-\\theta)G^n$ 是函数 $G(t)$ 在一个时间步开始和结束时值的加权平均，用于近似时间平均值 $\\frac{1}{\\Delta t}\\int_{t^n}^{t^{n+1}} G(t) \\,dt$。这个求积法则仅在特定选择的 $\\theta$ 下才是二阶精度的（即，误差为 $O(\\Delta t^2)$）。一个二阶精度的格式至少必须对时间上呈线性的被积函数是精确的。因此，确定二阶格式的 $\\theta$ 的正确方法是要求GCL在面速度 $w_\\star(t)$ 是时间的线性函数（这对应于二次轨迹 $x_\\star(t)$）的运动中精确成立。\n\n让我们采纳这种物理上和数值上都合理的解释来继续。我们对每个面的任意线性速度剖面测试GCL条件。设 $g_\\star(t) = w_\\star(t)$ 是线性函数。那么它们的差 $g(t) = w_R(t) - w_L(t)$ 也是时间的线性函数。\n\n对于任何时间上呈线性的函数 $g(t)$，其在 $[t^n, t^{n+1}]$ 上的积分精确值由梯形法则给出：\n$$\n\\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2} \\Delta t\n$$\n因此，时间平均值为：\n$$\n\\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} g(t) \\,dt = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\n让我们将此代入我们的GCL相容性条件，其中 $g(t) = w_R(t) - w_L(t)$：\n$$\n\\theta g(t^{n+1}) + (1-\\theta)g(t^n) = \\frac{g(t^n) + g(t^{n+1})}{2}\n$$\n这个方程必须对任意线性函数 $g(t)$ 都成立，这意味着它必须对任意选择的初始值 $g(t^n)$ 和最终值 $g(t^{n+1})$ 都成立。\n让我们根据 $g(t^n)$ 和 $g(t^{n+1})$ 来合并项：\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(1 - \\theta - \\frac{1}{2}\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) g(t^{n+1}) + \\left(\\frac{1}{2} - \\theta\\right) g(t^n) = 0\n$$\n$$\n\\left(\\theta - \\frac{1}{2}\\right) (g(t^{n+1}) - g(t^n)) = 0\n$$\n由于这个关系式必须对*任意*线性速度剖面都满足，我们可以选择一个运动，使得 $g(t^{n+1}) \\neq g(t^n)$（例如，一个正在加速扩张的单元）。为了使方程在这种一般情况下成立，系数必须为零：\n$$\n\\theta - \\frac{1}{2} = 0\n$$\n这就确定了权重的唯一值：\n$$\n\\theta = \\frac{1}{2}\n$$\n这个值对应于Crank-Nicolson方法（或梯形法则），这与构建二阶格式的要求是一致的。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3423641"}, {"introduction": "在理解了GCL的基本原理之后，我们现在来审视一个高阶数值格式中的不完美之处会如何影响其精度。这个练习[@problem_id:3423615]提供了一套分析工具，用以量化在间断伽辽金（DG）任意拉格朗日-欧拉（ALE）格式中，由于常见的实现“捷径”（例如，使用不足的求积点或在时间上滞后处理网格几何项）所导致的精度损失。通过完成这些计算，您将对高阶ALE方法的敏感性建立起定量的直观认识。", "problem": "考虑通过间断伽辽金 (DG) 方法离散化的线性标量守恒律的一维任意拉格朗日-欧拉 (ALE) 格式。令参考坐标为 $X$，物理坐标为 $x(X,t)$。定义映射的雅可比为 $J(X,t) = \\partial x / \\partial X$，网格速度为 $w(X,t) = \\partial x / \\partial t$。该偏微分方程的守恒型 ALE 形式为\n$$\n\\partial_t \\big(J\\,u\\big) + \\partial_X \\big(F(u) - u\\,w\\big) = 0,\n$$\n其中 $u(X,t)$ 是参考空间解，$F(u)$ 是物理通量。假设通量为线性通量 $F(u) = c\\,u$，其中速度 $c \\in \\mathbb{R}$ 为常数，当 $c$ 非零时，这在分析中不影响多项式次数。DG 离散化对试探函数和检验函数使用次数为 $p$ 的单元多项式，体积分和面积分分别使用 $N_v$ 个点和 $N_s$ 个点的 Gauss-Legendre 求积法进行计算。\n\n假设在每个单元上，雅可比 $J(X,t)$ 是关于 $X$ 的次数为 $q_J$ 的多项式，网格速度 $w(X,t)$ 是关于 $X$ 的次数为 $q_w$ 的多项式。考虑一个 $r$ 阶精度的显式 Runge-Kutta 时间积分器。网格是平滑变形的，意味着 $J$ 和 $w$ 在时间和空间上是充分可微的。\n\n从第一性原理出发，DG 弱形式包含以下被积函数：\n- 体积分项包含 $J\\,u\\,v$ 形式的乘积，其中 $u$ 和 $v$ 是次数为 $p$ 的多项式。体积分被积函数的多项式次数为 $D_v = 2p + q_J$。\n- 面积分项包含 $F(u) - u\\,w$，在单元边界处乘以检验函数的迹；对于一维情况下边界上的被积函数，当 $F$ 是线性的时，其多项式次数的界可以由 $D_s = p + q_w$ 给出。\n\n具有 $N$ 个点的 Gauss-Legendre 求积法可以精确积分最高为 $2N - 1$ 次的多项式。为保持 $p$ 阶空间精度，需要对弱形式中的多项式进行精确积分。因此，保证精确积分的最小求积点数为\n$$\nN_v^{\\min} = \\left\\lceil \\frac{D_v + 1}{2} \\right\\rceil = \\left\\lceil \\frac{2p + q_J + 1}{2} \\right\\rceil,\\quad\nN_s^{\\min} = \\left\\lceil \\frac{D_s + 1}{2} \\right\\rceil = \\left\\lceil \\frac{p + q_w + 1}{2} \\right\\rceil.\n$$\n\n当所选的求积点数 $N_v$ 和 $N_s$ 低于精确积分所需的最小值时，能保证的空间精度受限于积分的精确次数：\n- 对于体积分项，积分精确到 $2N_v - 1$ 次意味着最大试探多项式次数 $p_v^{\\mathrm{eff}}$ 满足 $2p_v^{\\mathrm{eff}} + q_J \\le 2N_v - 1$，从而得到\n$$\np_v^{\\mathrm{eff}} = \\min\\!\\left(p,\\, \\left\\lfloor \\frac{2N_v - 1 - q_J}{2} \\right\\rfloor \\right),\n$$\n约定负值被截断为 $0$。\n- 对于面积分项，积分精确到 $2N_s - 1$ 次意味着最大试探多项式次数 $p_s^{\\mathrm{eff}}$ 满足 $p_s^{\\mathrm{eff}} + q_w \\le 2N_s - 1$，从而得到\n$$\np_s^{\\mathrm{eff}} = \\min\\!\\left(p,\\, 2N_s - 1 - q_w \\right),\n$$\n约定负值被截断为 $0$。\n\n因此，（在光滑区域相对于网格尺寸的）保证的空间收敛阶为\n$$\nP_{\\mathrm{space}} = \\min\\!\\big(p_v^{\\mathrm{eff}} + 1,\\; p_s^{\\mathrm{eff}} + 1\\big).\n$$\n\n对于时间精度，几何守恒律 (GCL) 要求\n$$\n\\partial_t J = \\partial_X (J\\,w),\n$$\n在离散意义上成立，以保持常数解。如果度量项（$J$ 和 $w$）在时间上是滞后的，即使用前一时间步的值而不是当前 Runge-Kutta 分步的值进行计算，那么时间上的函数求值会因缺失更新而引入一个 $\\mathcal{O}(\\Delta t)$ 的误差，对于非平凡的网格运动，这会将有效时间阶降至一阶。具体来说，定义一个网格运动幅值参数 $A_w \\ge 0$，当且仅当网格静止时，该参数为零。在度量项完全滞后的情况下：\n- 如果 $A_w = 0$，则 $r_{\\mathrm{eff}} = r$。\n- 如果 $A_w > 0$，则 $r_{\\mathrm{eff}} = 1$。\n\n格式的总阶数受空间阶和时间阶的最小值限制：\n$$\nP_{\\mathrm{total}} = \\min\\!\\big(P_{\\mathrm{space}},\\, r_{\\mathrm{eff}}\\big).\n$$\n由滞后引起的时间阶损失量化为\n$$\nL_{\\mathrm{time}} = r - r_{\\mathrm{eff}}.\n$$\n\n实现一个程序，为每个测试用例计算以下整数输出：\n- $N_v^{\\min}$，\n- $N_s^{\\min}$，\n- $P_{\\mathrm{space}}$，\n- $r_{\\mathrm{eff}}$，\n- $P_{\\mathrm{total}}$，\n- $L_{\\mathrm{time}}$。\n\n使用上述公式。对于中间计算出的负值 $p_v^{\\mathrm{eff}}$ 或 $p_s^{\\mathrm{eff}}$，在计算 $P_{\\mathrm{space}}$ 时加 1 之前，将其截断为 0。最终输出应将所有测试用例的结果汇总到一行，形式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果是按上述顺序排列的列表。\n\n测试组（每个元组为 $(p, q_J, q_w, r, N_v, N_s, A_w)$）：\n- 用例 $1$（体积分普遍积分不足，面积分足够）：$(3, 2, 2, 3, 4, 3, 0.1)$。\n- 用例 $2$（静止网格，求积足够）：$(1, 1, 1, 2, 2, 2, 0.0)$。\n- 用例 $3$（分段常数与高次几何，面积分积分不足）：$(0, 3, 3, 1, 2, 1, 0.5)$。\n- 用例 $4$（静止网格下更高的 $p$，两项均积分不足）：$(4, 1, 0, 4, 4, 2, 0.0)$。\n- 用例 $5$（体积分足够，运动网格下面积分积分不足）：$(2, 0, 2, 3, 3, 2, 0.2)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如 $[result_1,result_2,\\dots]$），其中每个 $result_i$ 是第 $i$ 个测试用例的列表 $[N_v^{\\min},N_s^{\\min},P_{\\mathrm{space}},r_{\\mathrm{eff}},P_{\\mathrm{total}},L_{\\mathrm{time}}]$。不需要物理单位，也不涉及角度；所有输出都是纯整数。", "solution": "问题陈述已经过评估并被确定为有效。它在偏微分方程数值分析领域具有科学依据，特别涉及用于任意拉格朗日-欧拉 (ALE) 格式的间断伽辽金 (DG) 方法。该问题是适定的，提供了一套完整且一致的定义、公式和数据，可以直接计算出一组唯一的指定输出指标。语言客观、正式，问题结构合理。因此，我们可以着手求解。\n\n目标是为不同参数配置下的 DG-ALE 数值格式计算一组六个性能和精度指标。这些指标是：体积分 ($N_v^{\\min}$) 和面积分 ($N_s^{\\min}$) 所需的最小求积点数、有效空间收敛阶 ($P_{\\mathrm{space}}$)、有效时间收敛阶 ($r_{\\mathrm{eff}}$)、格式的总阶数 ($P_{\\mathrm{total}}$) 以及由滞后引起的时间阶损失 ($L_{\\mathrm{time}}$)。\n\n计算过程通过对每个测试用例应用所提供的公式来进行。让我们用第一个测试用例来演示该过程，其参数为 $(p, q_J, q_w, r, N_v, N_s, A_w) = (3, 2, 2, 3, 4, 3, 0.1)$。\n\n1.  **最小体积分求积点数, $N_v^{\\min}$**：\n    体积分被积函数的多项式次数为 $D_v = 2p + q_J$。为使用 Gauss-Legendre 求积法实现精确积分，点数 $N_v$ 必须满足 $2N_v - 1 \\ge D_v$。因此，最小点数为 $N_v^{\\min} = \\lceil (D_v + 1)/2 \\rceil$。\n    $$D_v = 2(3) + 2 = 8$$\n    $$N_v^{\\min} = \\left\\lceil \\frac{8 + 1}{2} \\right\\rceil = \\lceil 4.5 \\rceil = 5$$\n\n2.  **最小面积分求积点数, $N_s^{\\min}$**：\n    类似地，面积分被积函数的多项式次数由 $D_s = p + q_w$ 界定。最小点数为 $N_s^{\\min} = \\lceil (D_s + 1)/2 \\rceil$。\n    $$D_s = 3 + 2 = 5$$\n    $$N_s^{\\min} = \\left\\lceil \\frac{5 + 1}{2} \\right\\rceil = \\lceil 3 \\rceil = 3$$\n\n3.  **有效空间阶, $P_{\\mathrm{space}}$**：\n    当求积不精确时，精度阶数会受限。我们首先计算所选求积规则（$N_v=4$ 和 $N_s=3$）所支持的有效多项式次数。\n    *   对于体积分项，有效多项式次数 $p_v^{\\mathrm{eff}}$ 由条件 $2p_v^{\\mathrm{eff}} + q_J \\le 2N_v - 1$ 确定。\n    $$p_v^{\\mathrm{eff, raw}} = \\min\\!\\left(p,\\, \\left\\lfloor \\frac{2N_v - 1 - q_J}{2} \\right\\rfloor \\right) = \\min\\!\\left(3,\\, \\left\\lfloor \\frac{2(4) - 1 - 2}{2} \\right\\rfloor \\right) = \\min\\!\\left(3,\\, \\left\\lfloor \\frac{5}{2} \\right\\rfloor \\right) = \\min(3, 2) = 2$$\n    该值为非负数，因此 $p_v^{\\mathrm{eff}} = 2$。\n    *   对于面积分项，有效多项式次数 $p_s^{\\mathrm{eff}}$ 由条件 $p_s^{\\mathrm{eff}} + q_w \\le 2N_s - 1$ 确定。\n    $$p_s^{\\mathrm{eff, raw}} = \\min\\!\\left(p,\\, 2N_s - 1 - q_w \\right) = \\min(3,\\, 2(3) - 1 - 2) = \\min(3,\\, 3) = 3$$\n    该值为非负数，因此 $p_s^{\\mathrm{eff}} = 3$。\n    对于使用次数为 $p$ 的多项式的 DG 方法，如果所有积分都精确，则保证的空间收敛阶为 $P_{\\mathrm{space}} = p+1$。在积分不足的情况下，该值降为 $P_{\\mathrm{space}} = \\min(p_v^{\\mathrm{eff}} + 1, p_s^{\\mathrm{eff}} + 1)$。\n    $$P_{\\mathrm{space}} = \\min(2 + 1,\\, 3 + 1) = \\min(3, 4) = 3$$\n\n4.  **有效时间阶, $r_{\\mathrm{eff}}$**：\n    问题陈述指出，对于运动网格，在时间上滞后度量项（$J$ 和 $w$）会将时间阶降至一阶。网格运动由幅值 $A_w$ 决定。由于 $A_w = 0.1 > 0$，网格在运动。\n    $$r_{\\mathrm{eff}} = 1$$\n\n5.  **格式总阶数, $P_{\\mathrm{total}}$**：\n    数值格式的总阶数是空间阶和时间阶的最小值。\n    $$P_{\\mathrm{total}} = \\min(P_{\\mathrm{space}},\\, r_{\\mathrm{eff}}) = \\min(3, 1) = 1$$\n\n6.  **时间阶损失, $L_{\\mathrm{time}}$**：\n    时间阶的损失是 Runge-Kutta 积分器的原始阶数 $r=3$ 与有效阶数之差。\n    $$L_{\\mathrm{time}} = r - r_{\\mathrm{eff}} = 3 - 1 = 2$$\n\n因此，用例 1 的结果为 $[5, 3, 3, 1, 1, 2]$。将此系统性过程应用于其余四个测试用例。汇总结果如下：\n\n-   **用例 1**：$(p, q_J, q_w, r, N_v, N_s, A_w) = (3, 2, 2, 3, 4, 3, 0.1) \\rightarrow [5, 3, 3, 1, 1, 2]$\n-   **用例 2**：$(p, q_J, q_w, r, N_v, N_s, A_w) = (1, 1, 1, 2, 2, 2, 0.0) \\rightarrow [2, 2, 2, 2, 2, 0]$\n-   **用例 3**：$(p, q_J, q_w, r, N_v, N_s, A_w) = (0, 3, 3, 1, 2, 1, 0.5) \\rightarrow [2, 2, 1, 1, 1, 0]$\n-   **用例 4**：$(p, q_J, q_w, r, N_v, N_s, A_w) = (4, 1, 0, 4, 4, 2, 0.0) \\rightarrow [5, 3, 4, 4, 4, 0]$\n-   **用例 5**：$(p, q_J, q_w, r, N_v, N_s, A_w) = (2, 0, 2, 3, 3, 2, 0.2) \\rightarrow [3, 3, 2, 1, 1, 2]$\n\n最终的实现将以编程方式对整个测试组执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes accuracy and quadrature metrics for a DG-ALE scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (p, q_J, q_w, r, N_v, N_s, A_w)\n    test_cases = [\n        (3, 2, 2, 3, 4, 3, 0.1),  # Case 1\n        (1, 1, 1, 2, 2, 2, 0.0),  # Case 2\n        (0, 3, 3, 1, 2, 1, 0.5),  # Case 3\n        (4, 1, 0, 4, 4, 2, 0.0),  # Case 4\n        (2, 0, 2, 3, 3, 2, 0.2),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p, q_J, q_w, r, N_v, N_s, A_w = case\n\n        # 1. Minimum Volume Quadrature Points, N_v_min\n        D_v = 2 * p + q_J\n        N_v_min = int(np.ceil((D_v + 1) / 2))\n\n        # 2. Minimum Surface Quadrature Points, N_s_min\n        D_s = p + q_w\n        N_s_min = int(np.ceil((D_s + 1) / 2))\n\n        # 3. Effective Spatial Order, P_space\n        # Calculate effective polynomial degree for volume integrals\n        p_v_eff_raw = min(p, np.floor((2 * N_v - 1 - q_J) / 2))\n        # Clamp to 0 if negative\n        p_v_eff = max(0, int(p_v_eff_raw))\n\n        # Calculate effective polynomial degree for surface integrals\n        p_s_eff_raw = min(p, 2 * N_s - 1 - q_w)\n        # Clamp to 0 if negative\n        p_s_eff = max(0, int(p_s_eff_raw))\n\n        # Calculate guaranteed spatial convergence order\n        P_space = min(p_v_eff + 1, p_s_eff + 1)\n\n        # 4. Effective Temporal Order, r_eff\n        # Order drops to 1 if mesh is moving (A_w > 0) and metrics are lagged\n        r_eff = 1 if A_w > 0 else r\n\n        # 5. Total Scheme Order, P_total\n        # Overall order is the minimum of spatial and temporal orders\n        P_total = min(P_space, r_eff)\n\n        # 6. Temporal Order Loss, L_time\n        # Loss due to lagging\n        L_time = r - r_eff\n\n        results.append([N_v_min, N_s_min, P_space, r_eff, P_total, L_time])\n\n    # Format the final output string to exactly match the required format.\n    # The format is a list of lists, represented as a string without spaces.\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3423615"}, {"introduction": "最后的这个练习将理论与分析融入一个完整的实现过程。您将构建一个高阶DG-ALE求解器，亲眼观察违反离散GCL所带来的后果，然后通过实施标准的修正方法来解决这个问题。这个练习[@problem_id:3423630]将展示，对GCL项不一致的数值处理，即使在最简单的均匀流场情况下也会导致伪误差，以及如何通过强制实施一致性来恢复格式的精确性——这是任何可靠的移动网格模拟都必须迈出的关键一步。", "problem": "考虑一个一维标量守恒律，其守恒形式具有恒定的平流速度 $a$，\n$$\n\\partial_t u + \\partial_x \\left(a u\\right) = 0,\n$$\n该方程定义在一个被划分为有限数量曲线单元的空间域上。令 $x = x(\\xi,t)$ 表示一个等参映射，对于每个单元，它将参考坐标 $\\xi \\in [-1,1]$ 映射到物理坐标 $x$，其中 $t$ 表示时间。定义雅可比 $J(\\xi,t) := \\partial_\\xi x(\\xi,t)$ 和网格速度 $v(\\xi,t) := \\partial_t x(\\xi,t)$。\n\n标量守恒律的任意拉格朗日-欧拉 (ALE) 守恒形式为\n$$\n\\partial_t \\left(J u \\right) + \\partial_\\xi \\left( a u - v u \\right) = 0.\n$$\n对于常数解 $u \\equiv c$（自由流）的特殊情况，连续几何守恒律 (GCL) 表明\n$$\n\\partial_t J - \\partial_\\xi v = 0,\n$$\n这意味着连续 ALE 格式可以精确保持自由流：如果 GCL 成立，则 $\\partial_t(J c) + \\partial_\\xi(a c - v c) = c(\\partial_t J - \\partial_\\xi v) = 0$。\n\n在曲线单元上的高阶间断伽辽金 (DG) 离散化中，我们在每个单元上用参考坐标系中的多项式进行近似，并通过用一组基函数对 ALE 方程进行测试来构造一个半离散系统。对于一个节点 DG 格式，令 $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ 表示与 $N$ 个不同的参考节点 $\\{\\xi_i\\}_{i=1}^N \\subset [-1,1]$ 相关联的拉格朗日多项式基。代表节点基中 $u(\\xi,t)$ 展开系数的自由度 $\\mathbf{U}(t) \\in \\mathbb{R}^N$ 的半离散方程具有以下通用形式\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M}_J(t)$ 是随时间变化的质量矩阵，其元素为\n$$\n\\left(\\mathbf{M}_J(t)\\right)_{ij} = \\int_{-1}^{1} J(\\xi,t)\\, \\ell_i(\\xi)\\, \\ell_j(\\xi)\\, d\\xi,\n$$\n而 $\\mathbf{R}(t)$ 是组合了通量项和度量项的残差向量。对于自由流情况 $u \\equiv c$，对 $\\mathbf{R}(t)$ 的唯一非平凡贡献来自于两个度量项之间的不匹配，\n$$\n\\mathbf{R}_i(t) = c\\left[ \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi - \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\right].\n$$\n如果离散几何守恒律成立，即\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\quad \\text{对所有 } i,\n$$\n则 $\\mathbf{R}(t) = \\mathbf{0}$，并且自由流 $u \\equiv c$ 被该半离散格式精确保持。\n\n然而，当 $\\partial_t J$ 的积分使用不一致或积分不足的求积法则（或在时间上使用不一致的近似）进行计算时，与 $\\partial_\\xi v$ 项的抵消就会失败，自由流将无法被保持。本问题要求您构建一个在曲线单元上的高阶节点 DG-ALE 离散化，展示由于 $\\partial_t J$ 中的求积/时间近似误差导致的自由流保持能力的退化，并实现一种通过强制执行离散几何守恒律来恢复精确自由流保持的校正方法。\n\n您必须：\n- 从第一性原理推导自由流情况下的离散残差，并解释几何守恒律在确保精确性中的作用。\n- 实现一个程序，该程序：\n  1. 在多个曲线单元上构建一个一维节点 DG 离散化，其等参映射形式为\n     $$\n     x(\\xi,t) = A(t) + B(t)\\,\\xi + C(t)\\,\\xi^2 + D(t)\\,\\xi^3\n     $$\n     对于每个单元，其中 $A(t)$、$B(t)$、$C(t)$ 和 $D(t)$ 是光滑的、随时间变化的系数，并由此导出 $J(\\xi,t) = B(t) + 2C(t)\\xi + 3D(t)\\xi^2$ 和 $v(\\xi,t) = \\partial_t x(\\xi,t)$。\n  2. 使用指定数量求积点的高斯-勒让德求积法组装随时间变化的质量矩阵 $\\mathbf{M}_J(t)$。\n  3. 用两种方式计算 $u \\equiv c$ 时的残差向量 $\\mathbf{R}(t)$：\n     - 一种未校正的残差，它使用积分不足的求积法对 $\\partial_t J$ 进行积分，并用向前有限差分在时间上近似 $\\partial_t J$，同时使用更高阶的求积法和精确的时间导数来精确地积分 $\\partial_\\xi v$。这模拟了破坏自由流保持的求积/时间近似误差。\n     - 一种校正后的残差，它通过用与 $\\partial_\\xi v$ 积分相同的基于求积的投影来替换 $\\partial_t J$ 的积分，从而强制执行离散几何守恒律，确保\n       $$\n       \\int_{-1}^{1} \\partial_t J(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi \\equiv \\int_{-1}^{1} \\partial_\\xi v(\\xi,t) \\, \\ell_i(\\xi)\\, d\\xi\n       $$\n       在离散意义上对每个测试函数 $\\ell_i$ 成立。\n  4. 使用向前欧拉时间步进法，对自由流情况下的半离散系统进行时间推进，\n     $$\n     \\mathbf{M}_J(t^n)\\, \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = - \\mathbf{R}(t^n),\n     $$\n     其中 $\\mathbf{U}^0$ 在所有节点处初始化为常数 $c$。\n  5. 在最终时间 $T$ 计算 $u(\\xi,t)$ 相对于常数 $c$ 的最终均方根误差，该误差在由最终雅可比加权的 $L^2$ 范数下测量：\n     $$\n     \\mathrm{Err} = \\left( \\frac{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, \\left(u_e(\\xi,T) - c\\right)^2\\, d\\xi}{\\sum_{e} \\int_{-1}^{1} J_e(\\xi, T)\\, d\\xi} \\right)^{1/2},\n     $$\n     其中积分使用高阶高斯-勒让德求积法计算。\n\n设计您的实现以运行三个能共同检验该格式的测试用例：\n- 测试用例 1（通用曲线移动网格，正常情况）：两个单元，多项式次数 $p=4$（因此每个单元 $N=p+1=5$ 个节点），最终时间 $T=1.0$，时间步长 $\\Delta t=10^{-2}$，常数解 $c=2.0$。令\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.5 t),  B_1(t) = 1 + 0.2\\sin(2 t),  C_1(t) = 0.1\\cos(t),  D_1(t) = 0.05\\sin(3 t), \\\\\n  A_2(t) = 0.25\\sin(1.3 t),  B_2(t) = 1 + 0.15\\sin(1.7 t),  C_2(t) = 0.08\\cos(0.9 t),  D_2(t) = 0.04\\sin(2.5 t).\n  \\end{aligned}\n  $$\n  对质量矩阵和校正后残差积分使用 $6$ 点高斯-勒让德求积，对未校正的 $\\partial_t J$ 积分使用 $3$ 点高斯-勒让德求积，对最终误差评估和精确的 $\\partial_\\xi v$ 积分使用 $10$ 点高斯-勒让德求积。报告两个浮点数：未校正误差和校正后误差。\n- 测试用例 2（静态网格情况）：两个单元，相同的多项式次数和常数 $c=2.0$，$T=1.0$，$\\Delta t=10^{-2}$，但使用静态映射\n  $$\n  A_e(t) \\equiv 0, \\quad B_e(t) \\equiv 1, \\quad C_e(t) \\equiv 0, \\quad D_e(t) \\equiv 0,\n  $$\n  对于两个单元 $e=1,2$。使用与测试用例 1 相同的求积阶数。报告两个浮点数：未校正误差和校正后误差。\n- 测试用例 3（剧烈曲线运动，边缘情况）：两个单元，$p=4$，$c=2.0$，$T=1.0$，$\\Delta t=5\\times 10^{-2}$。令\n  $$\n  \\begin{aligned}\n  A_1(t) = 0.3\\sin(1.8 t),  B_1(t) = 1 + 0.25\\sin(2.2 t),  C_1(t) = 0.3\\cos(1.1 t),  D_1(t) = 0.2\\sin(3.1 t), \\\\\n  A_2(t) = 0.28\\sin(1.4 t),  B_2(t) = 1 + 0.22\\sin(1.9 t),  C_2(t) = 0.27\\cos(0.95 t),  D_2(t) = 0.18\\sin(2.7 t).\n  \\end{aligned}\n  $$\n  对质量矩阵和校正后残差积分使用 $6$ 点高斯-勒让德求积，对未校正的 $\\partial_t J$ 积分使用 $2$ 点高斯-勒让德求积，对最终误差评估和精确的 $\\partial_\\xi v$ 积分使用 $16$ 点高斯-勒让德求积。报告两个浮点数：未校正误差和校正后误差。\n\n不需要物理单位；三角函数中的角度应解释为弧度。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个包含六个浮点数的逗号分隔列表，并用方括号括起来，顺序如下：\n$$\n[\\text{uncorrected}_1, \\text{corrected}_1, \\text{uncorrected}_2, \\text{corrected}_2, \\text{uncorrected}_3, \\text{corrected}_3].\n$$", "solution": "该问题要求分析并实现一个用于移动曲线网格上标量平流方程的高阶间断伽辽金 (DG) 格式，重点关注几何守恒律 (GCL) 在保持恒定流解（自由流）中的作用。\n\n### 基于原理的推导\n\n我们从具有恒定平流速度 $a$ 的一维标量守恒律开始：\n$$\n\\partial_t u + \\partial_x (a u) = 0\n$$\n该问题设定在一个具有随时间变化的曲线单元的域上。我们对每个单元使用一个等参映射 $x = x(\\xi, t)$，将一个坐标为 $\\xi \\in [-1, 1]$ 的固定参考单元变换到物理单元。关键的几何量是此变换的雅可比行列式 $J(\\xi, t) = \\partial_\\xi x(\\xi, t)$ 和网格速度 $v(\\xi, t) = \\partial_t x(\\xi, t)$。\n\n使用链式法则，我们可以将守恒律变换到参考单元上的任意拉格朗日-欧拉 (ALE) 框架中。得到的守恒型 ALE 格式为：\n$$\n\\partial_t (J u) + \\partial_\\xi (a u - v u) = 0\n$$\n\n任何有效数值格式的一个基本要求是其能够保持恒定解，这通常被称为“自由流”或“均匀流”。让我们用一个常数解 $u(\\xi, t) \\equiv c$ 来测试连续 ALE 方程。将 $u=c$ 代入 ALE 方程，得到：\n$$\n\\partial_t (J c) + \\partial_\\xi (a c - v c) = c\\, \\partial_t J + c\\, \\partial_\\xi a - c\\, \\partial_\\xi v\n$$\n由于平流速度 $a$ 是常数，$\\partial_\\xi a = 0$。方程简化为：\n$$\nc \\left( \\partial_t J - \\partial_\\xi v \\right) = 0\n$$\n这意味着，要保持自由流解，几何量必须满足**连续几何守恒律 (GCL)**：\n$$\n\\partial_t J - \\partial_\\xi v = 0\n$$\n通过注意到对于一个光滑映射 $x(\\xi, t)$，混合偏导数是相等的：$\\partial_t \\partial_\\xi x = \\partial_\\xi \\partial_t x$，这恰好是 $\\partial_t J = \\partial_\\xi v$，可以证实这个恒等式。因此，连续 ALE 格式精确地保持了自由流。\n\n挑战出现在离散化过程中。对于一个高阶节点 DG 格式，我们使用与 $N$ 个解节点 $\\{\\xi_i\\}_{i=1}^N$ 相关联的拉格朗日多项式基 $\\{ \\ell_i(\\xi) \\}_{i=1}^{N}$ 来近似每个单元内的解 $u$。通过将 ALE 方程乘以一个测试函数 $\\ell_i(\\xi)$ 并在参考单元上积分，可以得到半离散形式：\n$$\n\\int_{-1}^{1} \\left( \\partial_t (J u) + \\partial_\\xi ((a-v)u) \\right) \\ell_i(\\xi)\\,d\\xi = 0\n$$\n展开时间导数项 $\\partial_t(Ju) = (\\partial_t J)u + J(\\partial_t u)$ 并分离出涉及解系数 $\\mathbf{U}(t)$ 时间导数的项，得到矩阵系统：\n$$\n\\mathbf{M}_J(t) \\frac{d\\mathbf{U}}{dt} + \\mathbf{R}(t) = \\mathbf{0}\n$$\n其中 $\\mathbf{M}_J(t)$ 是质量矩阵，$\\mathbf{R}(t)$ 是残差向量。对于自由流情况 $u=c$，解系数是常数，$\\mathbf{U}(t) = c \\cdot \\mathbf{1}$，因此其时间导数为零：$d\\mathbf{U}/dt = \\mathbf{0}$。为了使半离散格式能保持这个解，当 $u=c$ 时，残差向量 $\\mathbf{R}(t)$ 必须恒等于零。\n\n$u=c$ 时残差的第 $i$ 个分量为：\n$$\nR_i(t) = \\int_{-1}^{1} \\left( (\\partial_t J)c + \\partial_\\xi ((a-v)c) \\right) \\ell_i(\\xi)\\,d\\xi = c \\left[ \\int_{-1}^{1} \\partial_t J\\, \\ell_i\\,d\\xi - \\int_{-1}^{1} \\partial_\\xi v\\, \\ell_i\\,d\\xi \\right]\n$$\n（在分部积分后，并假设对于常数状态存在周期性或一致的单元间通量，来自常数 $a$ 项的贡献会消失）。为保持自由流，我们必须有 $R_i(t) = 0$ 对所有 $i$ 成立，这导出了**离散几何守恒律 (GCL)**：\n$$\n\\int_{-1}^{1} \\partial_t J(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi = \\int_{-1}^{1} \\partial_\\xi v(\\xi,t)\\,\\ell_i(\\xi)\\,d\\xi \\quad \\forall i\n$$\n\n问题的核心在于这两个积分的数值计算。\n1.  **未校正格式**：项 $\\partial_t J$ 来自时间导数算子。在时间步进格式中，很自然地会用有限差分来近似它，例如 $\\partial_t J(\\xi, t^n) \\approx (J(\\xi, t^{n+1}) - J(\\xi, t^n))/\\Delta t$。然而，网格速度 $v$ 是通量函数的显式部分，通常在时间 $t^n$ 进行计算。因此，离散 GCL 中的两个积分以根本不同的方式计算：一个使用数值时间导数，并且为了效率通常使用低阶求积法则（积分不足）；另一个使用解析空间导数和高阶求积法则以保证精度。这种不匹配导致非零残差 $\\mathbf{R}(t) \\neq \\mathbf{0}$，从而引入误差，导致数值格式无法保持自由流。\n\n2.  **校正格式**：为了恢复自由流保持特性，必须严格执行离散 GCL。这可以通过确保两个积分的数值计算产生相同的结果来实现。标准的校正方法是使用*相同的过程*来计算这两个积分。由于解析上 $\\partial_t J = \\partial_\\xi v$，我们可以使用两个被积函数的解析表达式，并使用相同的求积法则（例如，用于质量矩阵的求积法则）来计算这两个积分。这种一致性保证了两个离散项能够相互抵消至机器精度，使得自由流情况下的残差 $\\mathbf{R}(t)$ 成为零向量。因此，$d\\mathbf{U}/dt = \\mathbf{0}$，半离散格式便能精确保持自由流。\n\n下面的实现将通过模拟常数解在未校正和校正格式下的演化，并测量产生的误差，来展示这一原理。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_gauss_lobatto_nodes(N):\n    \"\"\"Computes the N-point Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n    if N == 1:\n        return np.array([0.0])\n    if N == 2:\n        return np.array([-1.0, 1.0])\n    # Interior nodes are roots of P'_{N-1}(x), which are roots of Jacobi polynomial P_{N-2}^{(1,1)}(x)\n    interior_nodes = roots_jacobi(N - 2, 1, 1)[0]\n    return np.r_[-1.0, interior_nodes, 1.0]\n\ndef lagrange_basis(solution_nodes, evaluation_points):\n    \"\"\"\n    Computes the values of the Lagrange basis polynomials.\n    Rows correspond to basis functions, columns to evaluation points.\n    \"\"\"\n    N = len(solution_nodes)\n    M = len(evaluation_points)\n    L = np.ones((N, M))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                L[i, :] *= (evaluation_points - solution_nodes[j]) / (solution_nodes[i] - solution_nodes[j])\n    return L\n\nclass Element:\n    \"\"\"Represents a single DG element with moving geometry.\"\"\"\n    def __init__(self, p, c, dt, mapping_coeffs, quad_orders):\n        self.p = p\n        self.N = p + 1\n        self.c = c\n        self.dt = dt\n        self.coeffs = mapping_coeffs\n        \n        nq_mass, nq_uncorr, nq_high, nq_error = quad_orders\n        \n        # Solution nodes (Gauss-Lobatto) and quadrature rules\n        self.sol_nodes = get_gauss_lobatto_nodes(self.N)\n        self.q_mass_nodes, self.q_mass_weights = leggauss(nq_mass)\n        self.q_uncorr_nodes, self.q_uncorr_weights = leggauss(nq_uncorr)\n        self.q_high_nodes, self.q_high_weights = leggauss(nq_high)\n        self.q_error_nodes, self.q_error_weights = leggauss(nq_error)\n        \n        # Pre-compute basis functions at quadrature nodes\n        self.L_mass = lagrange_basis(self.sol_nodes, self.q_mass_nodes)\n        self.L_uncorr = lagrange_basis(self.sol_nodes, self.q_uncorr_nodes)\n        self.L_high = lagrange_basis(self.sol_nodes, self.q_high_nodes)\n        self.L_error = lagrange_basis(self.sol_nodes, self.q_error_nodes)\n\n    def get_geometry(self, t, xi, derivatives=True):\n        \"\"\"Computes geometric quantities J, v, and their derivatives.\"\"\"\n        A, B, C, D = self.coeffs['A'](t), self.coeffs['B'](t), self.coeffs['C'](t), self.coeffs['D'](t)\n        J = B + 2 * C * xi + 3 * D * xi**2\n        if not derivatives:\n            return J, None, None, None\n            \n        Ad, Bd, Cd, Dd = self.coeffs['Ad'](t), self.coeffs['Bd'](t), self.coeffs['Cd'](t), self.coeffs['Dd'](t)\n        v = Ad + Bd * xi + Cd * xi**2 + Dd * xi**3\n        dJdt_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        dvdxi_exact = Bd + 2 * Cd * xi + 3 * Dd * xi**2\n        \n        return J, v, dJdt_exact, dvdxi_exact\n\n    def get_mass_matrix(self, t):\n        \"\"\"Assembles the time-dependent mass matrix M_J.\"\"\"\n        J_at_mass_nodes, _, _, _ = self.get_geometry(t, self.q_mass_nodes, derivatives=False)\n        # M_ij = integral(J * l_i * l_j dxi)\n        M_J = self.L_mass @ (np.diag(self.q_mass_weights * J_at_mass_nodes)) @ self.L_mass.T\n        return M_J\n\n    def get_residuals(self, t):\n        \"\"\"Computes both uncorrected and corrected residuals for the free-stream case.\"\"\"\n        # Uncorrected Residual\n        J_t, _, _, _ = self.get_geometry(t, self.q_uncorr_nodes, derivatives=False)\n        J_t_plus_dt, _, _, _ = self.get_geometry(t + self.dt, self.q_uncorr_nodes, derivatives=False)\n        dJdt_approx = (J_t_plus_dt - J_t) / self.dt\n        \n        _, _, _, dvdxi_exact_high = self.get_geometry(t, self.q_high_nodes)\n        \n        term1_uncorr = self.L_uncorr @ (self.q_uncorr_weights * dJdt_approx)\n        term2_uncorr = self.L_high @ (self.q_high_weights * dvdxi_exact_high)\n        R_uncorr = self.c * (term1_uncorr - term2_uncorr)\n\n        # Corrected Residual (should be zero to machine precision)\n        _, _, dJdt_exact_mass, dvdxi_exact_mass = self.get_geometry(t, self.q_mass_nodes)\n        term1_corr = self.L_mass @ (self.q_mass_weights * dJdt_exact_mass)\n        term2_corr = self.L_mass @ (self.q_mass_weights * dvdxi_exact_mass)\n        R_corr = self.c * (term1_corr - term2_corr)\n            \n        return R_uncorr, R_corr\n\n    def compute_element_error(self, U, t_final):\n        \"\"\"Computes the L2 error contribution from this element.\"\"\"\n        u_at_error_nodes = self.L_error.T @ U\n        J_final, _, _, _ = self.get_geometry(t_final, self.q_error_nodes, derivatives=False)\n        \n        sq_err_integrand = J_final * (u_at_error_nodes - self.c)**2\n        element_sq_err = np.sum(self.q_error_weights * sq_err_integrand)\n        element_vol = np.sum(self.q_error_weights * J_final)\n\n        return element_sq_err, element_vol\n\nclass DGSolver:\n    \"\"\"Manages the DG-ALE simulation over multiple elements.\"\"\"\n    def __init__(self, p, num_elements, T, dt, c, all_mappings_coeffs, quad_orders):\n        self.T = T\n        self.dt = dt\n        self.num_elements = num_elements\n        self.N = p + 1\n        \n        self.elements = [Element(p, c, dt, all_mappings_coeffs[e], quad_orders) for e in range(num_elements)]\n        \n        self.U_uncorr = np.full((num_elements, self.N), c)\n        self.U_corr = np.full((num_elements, self.N), c)\n\n    def run_simulation(self):\n        \"\"\"Executes the time-stepping loop and returns final errors.\"\"\"\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t = n * self.dt\n            for e in range(self.num_elements):\n                elem = self.elements[e]\n                M_J = elem.get_mass_matrix(t)\n                R_uncorr, R_corr = elem.get_residuals(t)\n                M_J_inv = np.linalg.inv(M_J)\n                \n                # Forward Euler Step\n                self.U_uncorr[e, :] -= self.dt * (M_J_inv @ R_uncorr)\n                self.U_corr[e, :] -= self.dt * (M_J_inv @ R_corr)\n        \n        t_final = num_steps * self.dt\n        err_uncorr = self._calculate_final_error(self.U_uncorr, t_final)\n        err_corr = self._calculate_final_error(self.U_corr, t_final)\n        \n        return err_uncorr, err_corr\n\n    def _calculate_final_error(self, U_final, t_final):\n        \"\"\"Calculates the root-mean-square error over all elements.\"\"\"\n        total_sq_err, total_volume = 0.0, 0.0\n        for e in range(self.num_elements):\n            sq_err, vol = self.elements[e].compute_element_error(U_final[e, :], t_final)\n            total_sq_err += sq_err\n            total_volume += vol\n        return np.sqrt(total_sq_err / total_volume) if total_volume > 0 else 0.0\n\ndef solve():\n    \"\"\"Sets up and runs the test cases.\"\"\"\n    test_cases = [\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.5*t), 'Ad': lambda t: 0.3*1.5*np.cos(1.5*t),\n                    'B': lambda t: 1 + 0.2*np.sin(2*t), 'Bd': lambda t: 0.2*2*np.cos(2*t),\n                    'C': lambda t: 0.1*np.cos(t), 'Cd': lambda t: -0.1*np.sin(t),\n                    'D': lambda t: 0.05*np.sin(3*t), 'Dd': lambda t: 0.05*3*np.cos(3*t),\n                },\n                {\n                    'A': lambda t: 0.25*np.sin(1.3*t), 'Ad': lambda t: 0.25*1.3*np.cos(1.3*t),\n                    'B': lambda t: 1 + 0.15*np.sin(1.7*t), 'Bd': lambda t: 0.15*1.7*np.cos(1.7*t),\n                    'C': lambda t: 0.08*np.cos(0.9*t), 'Cd': lambda t: -0.08*0.9*np.sin(0.9*t),\n                    'D': lambda t: 0.04*np.sin(2.5*t), 'Dd': lambda t: 0.04*2.5*np.cos(2.5*t),\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 1e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 3, 10, 10),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                },\n                {\n                    'A': lambda t: 0.0, 'Ad': lambda t: 0.0, 'B': lambda t: 1.0, 'Bd': lambda t: 0.0,\n                    'C': lambda t: 0.0, 'Cd': lambda t: 0.0, 'D': lambda t: 0.0, 'Dd': lambda t: 0.0,\n                }\n            ]\n        },\n        {\n            \"p\": 4, \"T\": 1.0, \"dt\": 5e-2, \"c\": 2.0, \"num_elements\": 2,\n            \"quad_orders\": (6, 2, 16, 16),\n            \"mappings\": [\n                {\n                    'A': lambda t: 0.3*np.sin(1.8*t), 'Ad': lambda t: 0.3*1.8*np.cos(1.8*t),\n                    'B': lambda t: 1 + 0.25*np.sin(2.2*t), 'Bd': lambda t: 0.25*2.2*np.cos(2.2*t),\n                    'C': lambda t: 0.3*np.cos(1.1*t), 'Cd': lambda t: -0.3*1.1*np.sin(1.1*t),\n                    'D': lambda t: 0.2*np.sin(3.1*t), 'Dd': lambda t: 0.2*3.1*np.cos(3.1*t),\n                },\n                {\n                    'A': lambda t: 0.28*np.sin(1.4*t), 'Ad': lambda t: 0.28*1.4*np.cos(1.4*t),\n                    'B': lambda t: 1 + 0.22*np.sin(1.9*t), 'Bd': lambda t: 0.22*1.9*np.cos(1.9*t),\n                    'C': lambda t: 0.27*np.cos(0.95*t), 'Cd': lambda t: -0.27*0.95*np.sin(0.95*t),\n                    'D': lambda t: 0.18*np.sin(2.7*t), 'Dd': lambda t: 0.18*2.7*np.cos(2.7*t),\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(\n            p=case[\"p\"], num_elements=case[\"num_elements\"], T=case[\"T\"],\n            dt=case[\"dt\"], c=case[\"c\"], all_mappings_coeffs=case[\"mappings\"],\n            quad_orders=case[\"quad_orders\"]\n        )\n        err_uncorr, err_corr = solver.run_simulation()\n        results.extend([err_uncorr, err_corr])\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3423630"}]}