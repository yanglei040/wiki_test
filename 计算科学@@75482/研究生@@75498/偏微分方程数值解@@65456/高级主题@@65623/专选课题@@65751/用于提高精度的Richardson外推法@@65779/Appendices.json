{"hands_on_practices": [{"introduction": "掌握理查森外推的第一步是理解其代数基础。这个练习将引导您从一个一阶方法的渐近误差展开式出发，推导出经典的外推公式。更重要的是，它将促使您检验精度的提升是否会牺牲原始方法的稳定性，这是数值方法中一个至关重要的权衡。[@problem_id:3440894]", "problem": "考虑一个由线性抛物型偏微分方程（PDE）应用直线法得到的线性、耗散的半离散演化系统，写作 $U^{\\prime}(t)=A\\,U(t)+G(t)$，其中 $A$ 是一个谱包含在闭合左半平面的时不变矩阵，$G(t)$ 是一个足够光滑的强迫项。令 $u(t)$ 表示此常微分方程（ODE）初值问题在时间 $t$ 的精确解，而 $U_{\\Delta t}(t^{n+1})$ 表示从时间 $t^{n}$ 到 $t^{n+1}=t^{n}+\\Delta t$、通过步长为 $\\Delta t$ 的单步后向欧拉法产生的全离散近似解。同样地，令 $U_{\\Delta t/2}(t^{n+1})$ 表示从 $t^{n}$ 推进到 $t^{n+1}$、通过步长为 $\\Delta t/2$ 的连续两步后向欧拉法得到的结果。假设后向欧拉法在时间 $t^{n+1}$ 的全局误差模型具有渐近展开式 $U_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+O\\!\\left((\\Delta t)^{2}\\right)$，其中系数 $C(t)$ 有界且与 $\\Delta t$ 无关。\n\n仅使用上述信息，构造一个在时间 $t^{n+1}$ 的外推估计，其形式为线性组合 $\\widehat{U}(t^{n+1})=a\\,U_{\\Delta t/2}(t^{n+1})+b\\,U_{\\Delta t}(t^{n+1})$，使其时间上的截断误差为 $O\\!\\left((\\Delta t)^{2}\\right)$。你的构造必须从给定的误差模型出发，在消除 $O(\\Delta t)$ 项的同时，保证与 $u(t^{n+1})$ 的相容性。然后，从第一性原理出发，论证为何此外推估计保留了后向欧拉法的无条件稳定性特征，即：对于某个范数 $|\\!|\\cdot|\\!|$，如果后向欧拉法对于此耗散线性系统是无条件稳定的，那么经过后处理的估计满足形式为 $|\\!|\\,\\widehat{U}(t^{n+1})\\,|\\!|\\leq K\\,|\\!|\\,U^{n}\\,|\\!|$ 的界，其中 $K$ 是一个与 $\\Delta t$ 和 $A$ 的谱无关的常数。\n\n作为最终答案，请提供 $\\widehat{U}(t^{n+1})$ 关于 $U_{\\Delta t/2}(t^{n+1})$ 和 $U_{\\Delta t}(t^{n+1})$ 的显式代数表达式。最终答案中不应包含任何不等式或界。你的最终答案必须是单一的封闭形式解析表达式。无需四舍五入。", "solution": "我们从已知的后向欧拉法在时间 $t^{n+1}$ 的全局误差模型开始：\n$$\nU_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+O\\!\\left((\\Delta t)^{2}\\right),\n$$\n其中 $C(t)$ 有界且与 $\\Delta t$ 无关。将相同的模型应用于步长 $\\Delta t/2$，并考虑到从 $t^{n}$ 到 $t^{n+1}$ 推进需要两个步长为 $\\Delta t/2$ 的步骤，我们得到\n$$\nU_{\\Delta t/2}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\frac{\\Delta t}{2}+O\\!\\left((\\Delta t)^{2}\\right).\n$$\n更精确地说，假设解足够光滑以至于全局误差允许渐近级数展开，我们可以写作\n$$\nU_{\\Delta t}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\Delta t+D(t^{n+1})\\,(\\Delta t)^{2}+O\\!\\left((\\Delta t)^{3}\\right),\n$$\n$$\nU_{\\Delta t/2}(t^{n+1})=u(t^{n+1})+C(t^{n+1})\\,\\frac{\\Delta t}{2}+D(t^{n+1})\\,\\frac{(\\Delta t)^{2}}{4}+O\\!\\left((\\Delta t)^{3}\\right),\n$$\n其中系数 $C(t)$ 和 $D(t)$ 有界且与 $\\Delta t$ 无关，仅依赖于解及其在 $t^{n+1}$ 的导数。\n\n我们寻求一个线性组合\n$$\n\\widehat{U}(t^{n+1})=a\\,U_{\\Delta t/2}(t^{n+1})+b\\,U_{\\Delta t}(t^{n+1})\n$$\n使其是相容的并能消除 $O(\\Delta t)$ 项。代入展开式可得\n\\begin{align*}\n\\widehat{U}(t^{n+1})=a\\left(u(t^{n+1})+C\\,\\frac{\\Delta t}{2}+D\\,\\frac{(\\Delta t)^{2}}{4}+O\\!\\left((\\Delta t)^{3}\\right)\\right)+b\\left(u(t^{n+1})+C\\,\\Delta t+D\\,(\\Delta t)^{2}+O\\!\\left((\\Delta t)^{3}\\right)\\right)\\\\\n=(a+b)\\,u(t^{n+1})+C\\,\\Delta t\\left(\\frac{a}{2}+b\\right)+D\\,(\\Delta t)^{2}\\left(\\frac{a}{4}+b\\right)+O\\!\\left((\\Delta t)^{3}\\right).\n\\end{align*}\n为了与 $u(t^{n+1})$ 保持相容性，我们需要\n$$\na+b=1.\n$$\n为了消除一阶项，我们需要\n$$\n\\frac{a}{2}+b=0.\n$$\n求解这个线性方程组，第二个方程给出 $a=-2b$，代入第一个方程得到 $-2b+b=1$，因此 $b=-1$ 且 $a=2$。所以，\n$$\n\\widehat{U}(t^{n+1})=2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1}).\n$$\n将 $a=2$ 和 $b=-1$ 代入 $(\\Delta t)^{2}$ 的系数，得到剩余的截断误差：\n$$\nD\\,(\\Delta t)^{2}\\left(\\frac{a}{4}+b\\right)=D\\,(\\Delta t)^{2}\\left(\\frac{2}{4}-1\\right)=-\\frac{1}{2}\\,D\\,(\\Delta t)^{2},\n$$\n因此外推估计的误差为 $O\\!\\left((\\Delta t)^{2}\\right)$，符合要求。\n\n现在我们来论证这种后处理方法保留了后向欧拉基方法的无条件稳定性。对于线性测试方程 $y^{\\prime}=\\lambda\\,y$（其中 $\\operatorname{Re}(\\lambda)\\leq 0$），后向欧拉法的放大因子为\n$$\ng(z)=\\frac{1}{1-z},\\quad z=\\lambda\\,\\Delta t,\n$$\n对于所有满足 $\\operatorname{Re}(z)\\leq 0$ 的 $z$，该因子满足 $|g(z)|\\leq 1$，因为 $|1-z|=\\sqrt{(1-\\operatorname{Re}(z))^{2}+(\\operatorname{Im}(z))^{2}}\\geq |1-\\operatorname{Re}(z)|\\geq 1$。这是该标量模型的代数稳定性的定义属性，代表了无条件稳定性。\n\n对于线性系统 $U^{\\prime}=A\\,U+G(t)$，其中 $A$ 在某个适当的能量范数 $|\\!|\\cdot|\\!|$ 下生成一个收缩半群，后向欧拉更新 $(I-\\Delta t\\,A)U^{n+1}=U^{n}+\\Delta t\\,G^{n+1}$ 是无条件稳定的：存在一个与 $\\Delta t$ 和 $A$ 的谱无关的常数 $M$，使得\n$$\n|\\!|\\,U_{\\Delta t}(t^{n+1})\\,|\\!|\\leq M\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right),\n$$\n并且同样的界对于产生 $U_{\\Delta t/2}(t^{n+1})$ 的两个半步也成立。外推估计是这两个稳定近似的线性后处理。根据三角不等式，\n\\begin{align*}\n|\\!|\\,\\widehat{U}(t^{n+1})\\,|\\!|=|\\!|\\,2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1})\\,|\\!|\\\\\n\\leq 2\\,|\\!|\\,U_{\\Delta t/2}(t^{n+1})\\,|\\!|+|\\!|\\,U_{\\Delta t}(t^{n+1})\\,|\\!|\\\\\n\\leq (2\\,M+M)\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right)\\\\\n=3\\,M\\left(|\\!|\\,U^{n}\\,|\\!|+\\int_{t^{n}}^{t^{n+1}}|\\!|\\,G(s)\\,|\\!|\\,\\mathrm{d}s\\right).\n\\end{align*}\n因此，外推估计继承了一个无条件稳定性界，其常数因子 $K=3\\,M$ 与 $\\Delta t$ 和 $A$ 的谱无关。这表明通过理查森外推法（Richardson extrapolation）提高精度，并未牺牲后向欧拉基积分器的无条件稳定性特征，因为后处理本身不改变演化步骤，且产生了一个一致有界的估计。\n\n因此，所求的在时间 $t^{n+1}$ 的二阶保稳定性的外推估计为\n$$\n\\widehat{U}(t^{n+1})=2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1}).\n$$", "answer": "$$\\boxed{2\\,U_{\\Delta t/2}(t^{n+1})-U_{\\Delta t}(t^{n+1})}$$", "id": "3440894"}, {"introduction": "标准的理查森外推依赖于一个关键假设：数值误差可以表示为网格尺寸 $h$ 的多项式级数。本练习将探讨一个更复杂但更现实的情景，其中边界层的存在引入了非多项式的误差行为。您需要推导出一个修正的缩放律，以取代传统公式中的 $2^{p}$ 因子，这突显了在应用外推前理解误差来源的重要性。[@problem_id:3440892]", "problem": "考虑一个稳态一维对流-扩散边值问题，其精确解在入流边界处呈现一个边界层。在内层中，解可以由边界层剖面 $u(x)=1-\\exp(-x/\\epsilon)$ 很好地近似，其中 $\\epsilon>0$ 是控制层厚的扩散强度参数。在偏微分方程的数值求解中，一种常见的做法是采用两层Richardson外推法，该方法假设关注量 $Q$ 的主阶误差模型形式为 $Q(h)=Q+C h^{p}$，其中 $h$ 是网格间距，$C$ 是常数，$p$ 是方法阶数。\n\n在存在边界层的情况下，当 $h$ 不远小于 $\\epsilon$ 时，关于主导误差是 $h$ 的幂级数的假设可能不成立。具体来说，在单个网格区间 $[0,h]$ 上对边界层的分辨不足会引入一个主导误差贡献，该贡献与第一个单元格内未捕捉到的层振幅成正比。对于剖面 $u(x)=1-\\exp(-x/\\epsilon)$，这个在单个网格步长上的振幅是差值 $u(h)-u(0)$。\n\n假设对于在 $x=0$ 处具有Dirichlet边界的对流-扩散算子的一致空间离散，在网格尺寸为 $h$ 时，由边界层主导的关注量 $Q$ 中的主要离散误差与 $u(h)-u(0)$ 成正比，并且同样的比例关系也适用于网格尺寸 $h/2$。在此模型下，两层Richardson外推法应将缩放因子 $2^{p}$ 替换为一个由 $h$ 和 $h/2$ 处主导误差之比决定的因子。\n\n当主导误差由一个网格步长上未分辨的边界层振幅决定时，请以闭合形式推导修正的缩放律 $r(h,\\epsilon)$，该缩放律应替换两层Richardson外推公式中的 $2^{p}$。你的最终答案必须是 $r(h,\\epsilon)$ 的单一解析表达式，且不带单位。", "solution": "该问题要求推导一种用于两层Richardson外推法的修正缩放律，该缩放律适用于其主导误差由指数型边界层分辨不足所控制的数值方法。\n\n标准的两层Richardson外推法基于对一个关注量 $Q$ 的假定渐近误差展开，该关注量由一个网格间距为 $h$ 的数值方法近似。设 $Q(h)$ 为数值近似值。误差模型通常是 $h$ 的幂级数：\n$$Q(h) = Q + C h^{p} + O(h^q)$$\n其中 $Q$ 是精确值，$C$ 是一个与 $h$ 无关的常数，$p$ 是方法的阶数，且 $q > p$。\n\n对于两个网格层级，其间距分别为 $h$ 和 $h/2$，我们有以下近似式：\n$$Q(h) \\approx Q + C h^{p}$$\n$$Q(h/2) \\approx Q + C \\left(\\frac{h}{2}\\right)^{p} = Q + C \\frac{h^{p}}{2^{p}}$$\n\n主阶误差为 $E(h) = Q(h) - Q \\approx C h^{p}$ 和 $E(h/2) = Q(h/2) - Q \\approx C h^{p}/2^{p}$。这些误差的比值定义了外推中使用的缩放因子：\n$$\\frac{E(h)}{E(h/2)} \\approx \\frac{C h^{p}}{C h^{p} / 2^{p}} = 2^{p}$$\n消除了主导误差项的外推解由下式给出：\n$$Q_{extrap} = \\frac{2^{p} Q(h/2) - Q(h)}{2^{p} - 1}$$\n\n问题陈述，由于边界层的分辨不足，这种标准误差模型是无效的。相反，主导误差与第一个网格单元上未分辨的边界层剖面振幅成正比。设 $K$ 为比例常数。在网格间距为 $h$ 和 $h/2$ 时的误差由下式给出：\n$$E(h) = K [u(h) - u(0)]$$\n$$E(h/2) = K [u(h/2) - u(0)]$$\n其中边界层剖面被指定为 $u(x) = 1 - \\exp(-x/\\epsilon)$。\n\n我们记为 $r(h,\\epsilon)$ 的修正缩放律替换了因子 $2^{p}$。它由实际主导误差的比值决定：\n$$r(h, \\epsilon) = \\frac{E(h)}{E(h/2)} = \\frac{K [u(h) - u(0)]}{K [u(h/2) - u(0)]}$$\n比例常数 $K$ 被消去，得到：\n$$r(h, \\epsilon) = \\frac{u(h) - u(0)}{u(h/2) - u(0)}$$\n\n现在我们将给定的 $u(x)$ 函数形式代入此表达式。首先，我们在所需点上计算函数值：\n在 $x=0$ 处：\n$$u(0) = 1 - \\exp(-0/\\epsilon) = 1 - \\exp(0) = 1 - 1 = 0$$\n在 $x=h$ 处：\n$$u(h) = 1 - \\exp(-h/\\epsilon)$$\n在 $x=h/2$ 处：\n$$u(h/2) = 1 - \\exp\\left(-\\frac{h/2}{\\epsilon}\\right) = 1 - \\exp\\left(-\\frac{h}{2\\epsilon}\\right)$$\n\n将这些值代入 $r(h, \\epsilon)$ 的表达式中：\n$$r(h, \\epsilon) = \\frac{(1 - \\exp(-h/\\epsilon)) - 0}{(1 - \\exp(-h/(2\\epsilon))) - 0} = \\frac{1 - \\exp(-h/\\epsilon)}{1 - \\exp(-h/(2\\epsilon))}$$\n\n为了化简这个表达式，我们注意到分子是一个平方差。令 $y = \\exp(-h/(2\\epsilon))$。那么 $y^2 = (\\exp(-h/(2\\epsilon)))^2 = \\exp(-h/\\epsilon)$。表达式变为：\n$$r(h, \\epsilon) = \\frac{1 - y^2}{1 - y}$$\n对分子进行因式分解，$1 - y^2 = (1 - y)(1 + y)$，我们得到：\n$$r(h, \\epsilon) = \\frac{(1 - y)(1 + y)}{1 - y}$$\n对于 $h \\neq 0$，$y = \\exp(-h/(2\\epsilon)) \\neq 1$，所以项 $(1 - y)$ 非零，可以从分子和分母中约去。\n$$r(h, \\epsilon) = 1 + y$$\n\n将 $y$ 的表达式代回，我们得到修正缩放律的最终闭合形式表达式：\n$$r(h, \\epsilon) = 1 + \\exp\\left(-\\frac{h}{2\\epsilon}\\right)$$\n这就是在指定的误差模型下，必须替换Richardson外推公式中 $2^{p}$ 的因子。", "answer": "$$ \\boxed{1 + \\exp\\left(-\\frac{h}{2\\epsilon}\\right)} $$", "id": "3440892"}, {"introduction": "将理查森外推应用于包含激波或间断的双曲问题是一项挑战，因为解的光滑性在空间上剧烈变化。这个动手编程练习要求您实现一种“自适应”外推方案，它能根据解的局部光滑度自动调整外推阶数。这个实践将展示如何将高阶精度技术与如总变差递减（TVD）格式这类稳健的无振荡方法相结合。[@problem_id:3440947]", "problem": "考虑标量线性平流偏微分方程 $u_t + a\\,u_x = 0$，该方程建立在周期性域 $x \\in [0,1]$ 上，具有无量纲参数和周期性边界条件。设 $a = 1$。有限差分和有限体积近似中单调性控制的一个基本原则是总变差递减 (TVD) 特性，该特性指出，对于节点值的半离散序列 $u_i(t)$，离散总变差 $TV(u) = \\sum_i \\lvert u_{i+1} - u_i \\rvert$ 不随时间增加：对于所有 $t \\geq 0$，有 $TV(u(\\cdot,t)) \\leq TV(u(\\cdot,0))$。TVD 方法在高分辨率格式中通过通量限制器广泛应用于求解双曲守恒律，以避免产生伪振荡，尤其是在间断附近。\n\nRichardson 外推是一种通过组合在多个空间步长下计算的近似解来提高数值解精度阶的技术。如果一系列数值解 $U_h$ 以截断误差 $U_h = u + C h^p + \\mathcal{O}(h^{p+1})$ 来近似 $u$，那么在光滑性和正则性假设下，经典做法是使用两个解 $U_h$ 和 $U_{h/2}$，通过 $U^{\\star} = U_{h/2} + \\dfrac{U_{h/2} - U_h}{2^p - 1}$，在重合的网格节点上形成一个外推近似解 $U^{\\star}$。在带有通量限制器的总变差递减 (TVD) 格式中，有效阶数 $p$ 在限制器起作用的间断或极值点附近可能降至 $p=1$，而在足够光滑的区域通常保持 $p=2$。\n\n您的任务是分析在空间步长 $h$ 上的外推是否保持 TVD 特性，并确定在何种光滑性假设下，外推解 $U^{\\star}$ 可以避免引入新的极值点。为此：\n\n1.  使用由一阶迎风格式和通量限制的反扩散修正构成的二阶 TVD 高分辨率方法，为标量线性平流方程实现一个无量纲的周期性求解器。使用 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = a \\Delta t / h \\in (0,1)$ 和应用于根据离散梯度计算的标准光滑度比 $r$ 的 minmod 通量限制器 $\\phi(r) = \\max\\{0, \\min\\{1, r\\}\\}$。节点值 $u_i^n$ 的单步显式更新必须是\n    $$\n    u_i^{n+1} = u_i^n - \\lambda\\,(u_i^n - u_{i-1}^n) + \\frac{\\lambda\\,(1-\\lambda)}{2}\\,\\Big(\\phi(r_{i-1/2})\\,(u_i^n - u_{i-1}^n) - \\phi(r_{i+1/2})\\,(u_{i+1}^n - u_i^n)\\Big),\n    $$\n    其中索引是周期性的，$r_{i+1/2} = \\dfrac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n}$ 的解释需要加入一个小的正则化以避免除以零，以及 $r_{i-1/2} = \\dfrac{u_{i-1}^n - u_{i-2}^n}{u_i^n - u_{i-1}^n}$。\n\n2.  对于下面描述的每个测试用例，在两个均匀网格上计算时间 $T$ 时的数值解：\n    -   一个具有 $N$ 个节点和间距 $h = 1/N$ 的粗网格，\n    -   一个具有 $2N$ 个节点和间距 $h/2 = 1/(2N)$ 的细网格。\n    在两个网格上使用相同的数值方法，具有相同的 $a$、CFL 和周期性边界条件，并确保初始条件在节点 $x_i = i h$（角度以弧度为单位）处进行采样。\n\n3.  在与细网格节点重合的粗网格节点上定义外推解 $U^{\\star}$。令 $U_h$ 表示时间 $T$ 时的粗网格解，令 $U_{h/2}$ 表示时间 $T$ 时限制在粗网格节点上的细网格解。使用逐元 Richardson 外推构建 $U^{\\star}$，其局部选定的阶数 $p_i$ 由每个粗节点邻域内的离散光滑度指示器确定：\n    -   在 $U_{h/2}$ 的粗节点限制上，计算指示器\n        $$\n        S_i = \\frac{\\lvert U_{i+1} - 2 U_i + U_{i-1} \\rvert}{\\lvert U_{i+1} - U_i \\rvert + \\lvert U_i - U_{i-1} \\rvert + \\varepsilon},\n        $$\n        其中 $\\varepsilon > 0$ 是一个小数。\n    -   如果 $S_i  \\tau$（光滑区域），则设 $p_i = 2$；否则设 $p_i = 1$。\n    -   构造\n        $$\n        U_i^{\\star} = U_{h/2,i} + \\frac{U_{h/2,i} - U_{h,i}}{2^{p_i} - 1}.\n        $$\n\n4.  对于每个测试用例，评估两个属性：\n    -   外推的 TVD 保持性：在粗节点上计算时间 $T$ 时的 $TV(U^{\\star})$，并将其与初始粗网格总变差 $TV(U(\\cdot,0))$ 进行比较。返回一个布尔值，指示是否 $TV(U^{\\star}) \\leq TV(U(\\cdot,0))$。\n    -   不引入新极值点：在粗节点上，使用周期性索引计算 $U^{\\star}$ 和受限细网格解 $U_{h/2}$ 中的离散局部极值点数量。索引 $i$ 处的离散局部极值点通过单调性变化来检测，即 $(U_{i} - U_{i-1})\\,(U_{i+1} - U_i)  0$，且两个相邻差分都超过一个小的阈值。返回一个布尔值，指示与 $U_{h/2}$ 相比，$U^{\\star}$ 是否不增加局部极值点的数量，并且在粗节点上不产生超出 $U_{h/2}$ 最小值和最大值的过冲或下冲。\n\n5.  使用以下测试套件，均在周期性域 $[0,1]$ 上，角度以弧度指定：\n    -   测试 1（边界情况，平凡光滑）：$u(x,0) = 0.7$。\n    -   测试 2（光滑正弦波）：$u(x,0) = \\sin(2\\pi x)$。\n    -   测试 3（光滑陡峭高斯函数）：$u(x,0) = \\exp\\big(-100\\,(x-0.5)^2\\big)$。\n    -   测试 4（不连续方波）：$u(x,0) = \\begin{cases}1, x \\in [0.25,0.75],\\\\ 0, \\text{否则。}\\end{cases}$。\n    使用参数 $N = 128$，$a = 1$，CFL 数 $\\lambda = 0.5$ 和目标时间 $T = 0.25$。\n\n您的程序必须：\n- 实现上述的 TVD 求解器。\n- 使用通过光滑度指示器阈值 $\\tau = 0.2$ 和正则化 $\\varepsilon = 10^{-12}$ 选择的局部阶数 $p_i$ 执行 Richardson 外推。\n- 对每个测试，计算第 4 项中描述的两个布尔值并汇总结果。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表 $[b_1,b_2]$，分别表示 TVD 保持性和不引入新极值点的布尔值。例如：“[[True,False],[True,True],[...],...]”。", "solution": "该问题要求分析 Richardson 外推与用于线性平流方程的高分辨率数值格式的总变差递减 (TVD) 和保单调性的兼容性。我们将首先描述数值方法和外推过程，然后详细说明评估指标，最后展示数值实验的结果。\n\n控制偏微分方程 (PDE) 是标量线性平流方程：\n$$\nu_t + a\\,u_x = 0\n$$\n该方程定义在周期性域 $x \\in [0,1]$ 上，平流速度设为 $a=1$。此方程的解是初始剖面的简单平移，$u(x,t) = u(x-at, 0)$。\n\n对于求解双曲守恒律（尤其是有间断解的）的数值方法，一个基石特性是 TVD 特性。对于离散解 $U = \\{u_i\\}$，总变差定义为 $TV(U) = \\sum_i \\lvert u_{i+1} - u_i \\rvert$。如果对于所有时间步 $n$ 都有 $TV(U^{n+1}) \\leq TV(U^n)$，则该格式是 TVD 的。此特性可防止伪振荡的增长。\n\n问题指定了一个二阶 TVD 高分辨率格式，通过对时间 $t^n = n\\,\\Delta t$ 时的节点值 $u_i^n$ 的显式单步更新公式实现：\n$$\nu_i^{n+1} = u_i^n - \\lambda\\,(u_i^n - u_{i-1}^n) + \\frac{\\lambda\\,(1-\\lambda)}{2}\\,\\Big(\\phi(r_{i-1/2})\\,(u_i^n - u_{i-1}^n) - \\phi(r_{i+1/2})\\,(u_{i+1}^n - u_i^n)\\Big)\n$$\n这里，$\\lambda = a \\Delta t / h$ 是 Courant–Friedrichs–Lewy (CFL) 数，其中 $h$ 是空间步长，$\\Delta t$ 是时间步长。第一项 $-\\lambda(u_i^n - u_{i-1}^n)$ 代表一阶迎风格式，对于 $\\lambda \\in (0,1]$ 是稳定的，但具有高度耗散性。第二项是反扩散通量修正，由函数 $\\phi(r)$ 限制以确保 TVD 特性。指定的限制器是 minmod 限制器，$\\phi(r) = \\max\\{0, \\min\\{1, r\\}\\}$。参数 $r$ 是连续梯度的光滑度比，定义在单元交界面上：\n$$\nr_{i+1/2} = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n} \\quad \\text{和} \\quad r_{i-1/2} = \\frac{u_{i-1}^n - u_{i-2}^n}{u_i^n - u_{i-1}^n}\n$$\n在解光滑的区域，$r \\approx 1$，限制器 $\\phi(r) \\approx 1$，格式接近二阶精度（恢复为 Lax-Wendroff 型方法）。在极值点或间断附近，$r$ 可能很小或为负，导致限制器激活 ($\\phi(r) \\to 0$)，从而将格式降为鲁棒的一阶迎风方法，以局部精度的代价防止了振荡。一个小的正则化参数 $\\varepsilon > 0$ 被加到 $r$ 的分母中，以处理梯度为零的均匀流情况。\n\n研究的核心是 Richardson 外推，这是一种通过组合来自两种不同网格分辨率的结果来构造更精确解的技术。给定一个粗网格解 $U_h$ 和一个细网格解 $U_{h/2}$（在步长减半的网格上计算），在粗网格节点上形成一个外推解 $U^\\star$：\n$$\nU^{\\star} = U_{h/2} + \\frac{U_{h/2} - U_h}{2^p - 1}\n$$\n其中 $p$ 是基础方法的精度阶。指定任务的一个关键特征是阶数 $p$ 不是常数。TVD 格式在光滑区域表现出 $p=2$ 的局部阶数，而在通量限制器激活处则为 $p=1$。因此，为每个粗网格节点 $i$ 确定一个局部的或自适应的外推阶数 $p_i$。这是通过使用离散光滑度指示器 $S_i$ 实现的，该指示器从细网格解 $U_{h/2}$（限制到粗节点）计算得出：\n$$\nS_i = \\frac{\\lvert U_{h/2, i+1} - 2 U_{h/2, i} + U_{h/2, i-1} \\rvert}{\\lvert U_{h/2, i+1} - U_{h/2, i} \\rvert + \\lvert U_{h/2, i} - U_{h/2, i-1} \\rvert + \\varepsilon}\n$$\n该指示器 $S_i$ 是一个归一化的离散二阶导数。对于光滑区域，$S_i$ 很小，而对于非光滑区域（高曲率或间断），它较大。基于一个阈值 $\\tau$，局部阶数被选为 $p_i = 2$ 如果 $S_i  \\tau$（光滑），否则为 $p_i = 1$（非光滑）。然后逐元应用外推：\n$$\nU_i^{\\star} = U_{h/2,i} + \\frac{U_{h/2,i} - U_{h,i}}{2^{p_i} - 1}\n$$\n\n为了评估外推解 $U^{\\star}$ 的质量，使用了两个指标：\n1.  **TVD 保持性**：我们检查外推解的总变差是否不超过初始条件的总变差，即 $TV(U^{\\star}) \\leq TV(U(\\cdot,0))$。由于 Richardson 外推是两个解（$U_h$ 和 $U_{h/2}$）的线性组合，而这两个解本身是符合 TVD 的，理论上并不能保证它们的线性组合也是 TVD 的。\n2.  **不引入新极值点**：该指标结合了两个条件。首先，$U^{\\star}$ 中的离散局部极值点数量不得超过基准细网格解 $U_{h/2}$ 中的数量。节点 $i$ 处的离散局部极值点通过局部梯度符号的变化来识别，即 $(U_i - U_{i-1})(U_{i+1} - U_i)  0$，且两个梯度的大小都超过一个小的阈值。其次，外推解不得创建新的全局最大值或最小值；它必须保持在细网格解的界限内，即 $\\min(U_{h/2}) \\le \\min(U^\\star)$ 和 $\\max(U^\\star) \\le \\max(U_{h/2})$。\n\n分析针对四个测试用例进行，参数为 $N=128$，$\\lambda=0.5$，$T=0.25$，$\\tau=0.2$ 和 $\\varepsilon=10^{-12}$。这些案例探讨了该方法在常数状态、光滑正弦波、陡峭但光滑的高斯函数和不连续方波下的行为。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiments and print the results.\n    \"\"\"\n\n    def run_solver(u_initial, N, lambda_cfl, T, a, epsilon):\n        \"\"\"\n        Solves the linear advection equation using the specified TVD scheme.\n        \n        Args:\n            u_initial (np.ndarray): The initial condition vector.\n            N (int): Number of grid points.\n            lambda_cfl (float): The CFL number.\n            T (float): The final time.\n            a (float): The advection speed.\n            epsilon (float): Small regularization constant.\n\n        Returns:\n            np.ndarray: The solution at the final time T.\n        \"\"\"\n        h = 1.0 / N\n        dt = lambda_cfl * h / a\n        num_steps = int(round(T / dt))\n        actual_T = num_steps * dt\n\n        if not np.isclose(T, actual_T):\n            # This check is important for consistency, especially between grids.\n            # Using round() helps ensure that fine and coarse grids take\n            # an integer multiple of steps relative to each other.\n            pass\n\n        u = u_initial.copy()\n\n        for _ in range(num_steps):\n            u_minus_1 = np.roll(u, 1)\n            u_minus_2 = np.roll(u, 2)\n            u_plus_1 = np.roll(u, -1)\n\n            # Differences\n            diff_i = u - u_minus_1        # u_i - u_{i-1}\n            diff_i_plus_1 = u_plus_1 - u  # u_{i+1} - u_i\n            diff_i_minus_1 = u_minus_1 - u_minus_2 # u_{i-1} - u_{i-2}\n\n            # Smoothness ratios with regularization\n            # Suppress RuntimeWarning for division by zero, which is handled by epsilon\n            with np.errstate(divide='ignore', invalid='ignore'):\n                r_i_plus_half = diff_i / (diff_i_plus_1)\n                r_i_plus_half[np.abs(diff_i_plus_1)  epsilon] = 0\n\n                r_i_minus_half = diff_i_minus_1 / (diff_i)\n                r_i_minus_half[np.abs(diff_i)  epsilon] = 0\n\n            # Minmod flux limiter\n            phi_i_plus_half = np.maximum(0, np.minimum(1, r_i_plus_half))\n            phi_i_minus_half = np.maximum(0, np.minimum(1, r_i_minus_half))\n\n            # Update formula\n            upwind_term = lambda_cfl * diff_i\n            correction = (lambda_cfl * (1 - lambda_cfl) / 2.0) * \\\n                         (phi_i_minus_half * diff_i - phi_i_plus_half * diff_i_plus_1)\n            \n            u = u - upwind_term + correction\n\n        return u\n\n    def calculate_tv(u):\n        \"\"\"Computes the total variation of a periodic 1D array.\"\"\"\n        return np.sum(np.abs(u - np.roll(u, 1)))\n\n    def count_extrema(u, threshold):\n        \"\"\"Counts discrete local extrema in a periodic 1D array.\"\"\"\n        diff_prev = u - np.roll(u, 1)\n        diff_next = np.roll(u, -1) - u\n        extrema_mask = (diff_prev * diff_next  0)  \\\n                       (np.abs(diff_prev) > threshold)  \\\n                       (np.abs(diff_next) > threshold)\n        return np.sum(extrema_mask)\n\n    # Parameters\n    N_coarse = 128\n    a = 1.0\n    lambda_cfl = 0.5\n    T = 0.25\n    tau = 0.2\n    epsilon = 1e-12\n\n    N_fine = 2 * N_coarse\n    h_coarse = 1.0 / N_coarse\n    h_fine = 1.0 / N_fine\n    \n    x_coarse = np.linspace(0, 1, N_coarse, endpoint=False)\n    x_fine = np.linspace(0, 1, N_fine, endpoint=False)\n\n    # Test cases initial condition functions\n    def ic1(x): return np.full_like(x, 0.7)\n    def ic2(x): return np.sin(2 * np.pi * x)\n    def ic3(x): return np.exp(-100 * (x - 0.5)**2)\n    def ic4(x):\n        u = np.zeros_like(x)\n        u[(x >= 0.25)  (x  0.75)] = 1.0\n        return u\n\n    test_cases = [ic1, ic2, ic3, ic4]\n    results = []\n\n    for ic_func in test_cases:\n        # 1. Generate initial conditions\n        u0_coarse = ic_func(x_coarse)\n        u0_fine = ic_func(x_fine)\n\n        # 2. Run solver for both grids\n        u_T_coarse = run_solver(u0_coarse, N_coarse, lambda_cfl, T, a, epsilon)\n        u_T_fine = run_solver(u0_fine, N_fine, lambda_cfl, T, a, epsilon)\n\n        # 3. Perform Richardson Extrapolation\n        u_T_fine_restricted = u_T_fine[::2]\n\n        # Smoothness indicator\n        U = u_T_fine_restricted\n        U_plus_1 = np.roll(U, -1)\n        U_minus_1 = np.roll(U, 1)\n        \n        num = np.abs(U_plus_1 - 2 * U + U_minus_1)\n        den = np.abs(U_plus_1 - U) + np.abs(U - U_minus_1) + epsilon\n        S = num / den\n        \n        # Local order p_i\n        p = np.where(S  tau, 2.0, 1.0)\n        \n        # Extrapolated solution\n        u_star = u_T_fine_restricted + (u_T_fine_restricted - u_T_coarse) / (np.power(2, p) - 1)\n\n        # 4. Evaluate properties\n        # TVD preservation\n        tv_initial = calculate_tv(u0_coarse)\n        tv_star = calculate_tv(u_star)\n        tvd_preserved = tv_star = tv_initial + epsilon # Add tolerance for FP arithmetic\n\n        # Absence of new extrema\n        extrema_h_half = count_extrema(u_T_fine_restricted, epsilon)\n        extrema_star = count_extrema(u_star, epsilon)\n        no_new_extrema_count = extrema_star = extrema_h_half\n        \n        min_h_half = np.min(u_T_fine_restricted)\n        max_h_half = np.max(u_T_fine_restricted)\n        min_star = np.min(u_star)\n        max_star = np.max(u_star)\n        \n        # Adding a small tolerance for floating point comparisons\n        no_overshoot = (min_star >= min_h_half - epsilon) and \\\n                       (max_star = max_h_half + epsilon)\n        \n        no_new_extrema = no_new_extrema_count and no_overshoot\n\n        results.append([tvd_preserved, no_new_extrema])\n\n    # Final print statement\n    result_str = ','.join([f\"[{b1},{b2}]\" for b1, b2 in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3440947"}]}