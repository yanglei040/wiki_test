{"hands_on_practices": [{"introduction": "有限元方法 (FEM) 的核心在于将偏微分方程的弱形式转化为一个线性方程组。本练习将针对这一过程提供基础实践，重点是为斯托克斯问题组装单元刚度矩阵和耦合矩阵。通过使用稳定且被广泛应用的 Taylor-Hood ($P_2$-$P_1$) 单元对，您将获得将计算从简单的参考单元映射到物理单元的实践经验，这是任何有限元程序实现的关键技能。[@problem_id:3382200]", "problem": "考虑二维不可压缩纳维-斯托克斯方程的标准弱形式基本组成部分，即双线性形式 $a(u,v) = \\nu \\int_{\\Omega} \\nabla u : \\nabla v \\, \\mathrm{d}x$ 和 $b(v,q) = -\\int_{\\Omega} q\\, \\nabla \\cdot v \\, \\mathrm{d}x$，其中 $\\nu$ 是运动粘度，$u$ 和 $v$ 是矢量值速度试探函数和检验函数，$q$ 是标量压力检验函数。在有限元法 (FEM) 中，考虑使用 Taylor–Hood 单元对，其中速度采用二次拉格朗日形函数 ($P_2$)，压力采用线性拉格朗日形函数 ($P_1$)。\n\n在参考三角形 $\\widehat{K}$ 上进行计算，其顶点为 $(0,0)$, $(1,0)$, $(0,1)$，重心坐标为 $(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - x - y, x, y)$。设 $\\{\\widehat{\\varphi}_i\\}_{i=1}^{6}$ 表示与三个顶点和三个边中点相关的标量 $P_2$ 形函数，设 $\\{\\widehat{\\psi}_j\\}_{j=1}^{3}$ 表示与三个顶点相关的标量 $P_1$ 形函数。对于速度，使用通过将标量 $P_2$ 形函数与 $\\mathbb{R}^2$ 的规范基向量进行张量积而形成的矢量值基函数。\n\n1. 从 $a(\\cdot,\\cdot)$ 和 $b(\\cdot,\\cdot)$ 的定义以及仿射映射 $F:\\widehat{K} \\to K$（其中 $x = B \\widehat{x} + b$，雅可比矩阵 $B$ 为常数，平移向量为 $b$）下的变量替换公式出发，推导参考矩阵 $\\widehat{A}$ 和 $\\widehat{B}$ 的单元级表达式及其到物理单元 $K$ 的映射：\n   - 对于 $a(\\cdot,\\cdot)$，给出耦合与 $\\widehat{\\varphi}_i$ 和 $\\widehat{\\varphi}_j$ 相关速度基函数第 $\\alpha$ 个分量（$\\alpha \\in \\{1,2\\}$）的标量分量项 $A_{i\\alpha,\\,j\\alpha}$ 的公式。\n   - 对于 $b(\\cdot,\\cdot)$，给出耦合压力基函数 $\\widehat{\\psi}_j$ 与和 $\\widehat{\\varphi}_i$ 相关速度基函数第 $\\alpha$ 个分量的项 $B_{j,\\,i\\alpha}$ 的公式。\n\n2. 考虑一个物理三角形 $K$，其顶点为 $(2,1)$, $(5,1)$, $(2,4)$。确定从 $\\widehat{K}$ 到 $K$ 的仿射映射 $F$，并计算相应的雅可比矩阵 $B$ 及其行列式。\n\n3. 使用你在第 2 部分中得到的公式和具体的 $F$，在物理单元 $K$ 上计算以下两个特定项：\n   - 与位于 $(0,0)$ 的顶点二次形函数自身耦合的 $x$ 分量刚度项，即对应于与 $\\lambda_1$ 相关的 $\\widehat{\\varphi}_1$ 的 $A_{1x,\\,1x}$。\n   - 与位于 $(1,0)$ 的压力形函数和与位于 $(1,0)$ 的二次速度形函数的 $x$ 分量耦合的散度-压力项，即对应于与 $\\lambda_2$ 相关的 $\\widehat{\\psi}_2$ 和与 $\\lambda_2$ 相关的 $\\widehat{\\varphi}_2$ 的 $B_{2,\\,2x}$。\n\n最后，定义标量 $S := A_{1x,\\,1x} + B_{2,\\,2x}$，并以 $\\nu$ 的形式给出 $S$ 的精确闭式表达式。无需四舍五入。请以单个解析表达式的形式提供最终答案。", "solution": "用户提供了一个来自偏微分方程数值解领域的、基于科学、适定且客观的问题。该问题是有效的，可以通过应用有限元法 (FEM) 的标准原理来解决。\n\n根据要求，解答分为三个部分：一般公式的推导、特定仿射映射的计算、矩阵项的求值，最后计算 $S$。\n\n**第 1 部分：单元矩阵公式的推导**\n\n给定从参考单元 $\\widehat{K}$ 到物理单元 $K$ 的仿射映射：\n$$x = F(\\widehat{x}) = B \\widehat{x} + b$$\n其中 $\\widehat{x} \\in \\widehat{K}$ 且 $x \\in K$。该映射的雅可比矩阵是常数矩阵 $B$。$\\widehat{K}$ 上的标量函数 $\\widehat{f}$ 通过 $f(x) = \\widehat{f}(F^{-1}(x))$ 变换为 $K$ 上的函数 $f$。根据链式法则，梯度的变换关系为：\n$$ \\nabla_x f = B^{-T} \\nabla_{\\widehat{x}} \\widehat{f} $$\n微分面积元的变换关系为：\n$$ \\mathrm{d}x = |\\det(B)| \\, \\mathrm{d}\\widehat{x} $$\n\n矢量值速度基函数的形式为 $\\mathbf{v}_{i\\alpha}(x) = (\\widehat{\\varphi}_i \\circ F^{-1}(x)) \\mathbf{e}_\\alpha$，其中 $\\widehat{\\varphi}_i$ 是 $\\widehat{K}$ 上的标量 $P_2$ 形函数，$\\mathbf{e}_\\alpha$ 是 $\\mathbb{R}^2$ 中的规范基向量（$\\alpha \\in \\{1,2\\}$）。类似地，标量压力基函数为 $q_j(x) = \\widehat{\\psi}_j \\circ F^{-1}(x)$，其中 $\\widehat{\\psi}_j$ 是标量 $P_1$ 形函数。\n\n**刚度矩阵项 $A_{i\\alpha, j\\alpha}$ 的推导**\n\n粘性项的双线性形式为 $a(u,v) = \\nu \\int_{\\Omega} \\nabla u : \\nabla v \\, \\mathrm{d}x$。$K$ 上单元刚度矩阵的项 $A^K_{i\\alpha, j\\alpha}$ 通过设置检验函数 $v = \\mathbf{v}_{i\\alpha}$ 和试探函数 $u = \\mathbf{v}_{j\\alpha}$ 得到：\n$$ A^K_{i\\alpha, j\\alpha} = \\nu \\int_K \\nabla \\mathbf{v}_{j\\alpha} : \\nabla \\mathbf{v}_{i\\alpha} \\, \\mathrm{d}x $$\n试探函数 $\\mathbf{v}_{j\\alpha}$ 的梯度是一个张量：\n$$ \\nabla_x \\mathbf{v}_{j\\alpha} = \\nabla_x ((\\widehat{\\varphi}_j \\circ F^{-1}) \\mathbf{e}_\\alpha) = (\\nabla_x (\\widehat{\\varphi}_j \\circ F^{-1})) \\otimes \\mathbf{e}_\\alpha = (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_j) \\otimes \\mathbf{e}_\\alpha $$\n类似地，$\\nabla_x \\mathbf{v}_{i\\alpha} = (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) \\otimes \\mathbf{e}_\\alpha$。双点积为：\n$$ \\nabla \\mathbf{v}_{j\\alpha} : \\nabla \\mathbf{v}_{i\\alpha} = \\left((B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_j) \\cdot (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i)\\right) (\\mathbf{e}_\\alpha \\cdot \\mathbf{e}_\\alpha) $$\n由于 $\\mathbf{e}_\\alpha \\cdot \\mathbf{e}_\\alpha = 1$，这简化为：\n$$ (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_j)^T (B^{-1} B^{-T}) (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) $$\n将此代入积分并进行变量替换到参考单元 $\\widehat{K}$：\n$$ A^K_{i\\alpha, j\\alpha} = \\nu |\\det(B)| \\int_{\\widehat{K}} (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_j)^T (B^{-1} B^{-T}) (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) \\, \\mathrm{d}\\widehat{x} $$\n这是通用的映射公式。\n\n**散度-压力矩阵项 $B_{j, i\\alpha}$ 的推导**\n\n压力-速度耦合的双线性形式为 $b(v,q) = -\\int_{\\Omega} q\\, \\nabla \\cdot v \\, \\mathrm{d}x$。项 $B_{j, i\\alpha}$ 通过设置压力检验函数 $q = q_j$ 和速度检验函数 $v = \\mathbf{v}_{i\\alpha}$ 得到：\n$$ B^K_{j, i\\alpha} = -\\int_K q_j (\\nabla_x \\cdot \\mathbf{v}_{i\\alpha}) \\, \\mathrm{d}x $$\n散度项为：\n$$ \\nabla_x \\cdot \\mathbf{v}_{i\\alpha} = \\nabla_x \\cdot ((\\widehat{\\varphi}_i \\circ F^{-1}) \\mathbf{e}_\\alpha) = (\\nabla_x (\\widehat{\\varphi}_i \\circ F^{-1})) \\cdot \\mathbf{e}_\\alpha = (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) \\cdot \\mathbf{e}_\\alpha $$\n该项是向量 $B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i$ 的第 $\\alpha$ 个分量。令 $C=B^{-T}$，它就是 $\\sum_{k=1}^2 C_{k\\alpha} \\frac{\\partial \\widehat{\\varphi}_i}{\\partial \\widehat{x}_k}$。\n代入积分并进行变量替换：\n$$ B^K_{j, i\\alpha} = -\\int_K (\\widehat{\\psi}_j \\circ F^{-1}) ((B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) \\cdot \\mathbf{e}_\\alpha)\\circ F^{-1} \\, \\mathrm{d}x $$\n$$ B^K_{j, i\\alpha} = -|\\det(B)| \\int_{\\widehat{K}} \\widehat{\\psi}_j \\left( (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_i) \\cdot \\mathbf{e}_\\alpha \\right) \\, \\mathrm{d}\\widehat{x} $$\n这是散度-压力耦合矩阵的通用映射公式。\n\n**第 2 部分：三角形 K 的仿射映射**\n\n参考三角形 $\\widehat{K}$ 的顶点为 $\\widehat{p}_1=(0,0)$, $\\widehat{p}_2=(1,0)$, $\\widehat{p}_3=(0,1)$。\n物理三角形 $K$ 的顶点为 $p_1=(2,1)$, $p_2=(5,1)$, $p_3=(2,4)$。\n仿射映射 $x = B\\widehat{x} + b$ 必须映射对应的顶点。\n$p_1 = B\\widehat{p}_1 + b \\implies \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = B\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + b \\implies b = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n$p_2 = B\\widehat{p}_2 + b \\implies \\begin{pmatrix} 5 \\\\ 1 \\end{pmatrix} = B\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} \\implies B\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}$。\n$p_3 = B\\widehat{p}_3 + b \\implies \\begin{pmatrix} 2 \\\\ 4 \\end{pmatrix} = B\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} \\implies B\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 3 \\end{pmatrix}$。\n$B$ 的列是 $B\\mathbf{e}_1$ 和 $B\\mathbf{e}_2$。因此：\n$$ B = \\begin{pmatrix} 3 & 0 \\\\ 0 & 3 \\end{pmatrix} = 3I_2 $$\n行列式为 $\\det(B) = 3 \\times 3 - 0 \\times 0 = 9$。\n\n**第 3 部分：特定矩阵项的求值**\n\n$\\widehat{K}$ 上的重心坐标为 $\\lambda_1 = 1-\\widehat{x}-\\widehat{y}$, $\\lambda_2 = \\widehat{x}$, $\\lambda_3 = \\widehat{y}$。它们的梯度为 $\\nabla_{\\widehat{x}}\\lambda_1 = \\left(-1,-1\\right)^T$, $\\nabla_{\\widehat{x}}\\lambda_2 = \\left(1,0\\right)^T$, $\\nabla_{\\widehat{x}}\\lambda_3 = \\left(0,1\\right)^T$。\n\n**$A_{1x,1x}$ 的计算**\n该项对应于 $i=1, j=1, \\alpha=x=1$。形函数是顶点 1 处的 $P_2$ 函数，$\\widehat{\\varphi}_1 = \\lambda_1(2\\lambda_1-1) = 2\\lambda_1^2 - \\lambda_1$。\n我们有 $B=3I_2$ 和 $\\det(B)=9$。因此 $B^{-1} = \\frac{1}{3}I_2$ 和 $B^{-T} = \\frac{1}{3}I_2$，所以 $B^{-1}B^{-T} = \\frac{1}{9}I_2$。\n$$ A^K_{1x,1x} = \\nu \\cdot 9 \\int_{\\widehat{K}} (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_1)^T \\left(\\frac{1}{9}I_2\\right) (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_1) \\, \\mathrm{d}\\widehat{x} = \\nu \\int_{\\widehat{K}} |\\nabla_{\\widehat{x}} \\widehat{\\varphi}_1|^2 \\, \\mathrm{d}\\widehat{x} $$\n形函数的梯度为 $\\nabla_{\\widehat{x}}\\widehat{\\varphi}_1 = (4\\lambda_1-1)\\nabla_{\\widehat{x}}\\lambda_1 = (4\\lambda_1-1)\\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$。\n其模的平方为 $|\\nabla_{\\widehat{x}} \\widehat{\\varphi}_1|^2 = (-(4\\lambda_1-1))^2 + (-(4\\lambda_1-1))^2 = 2(4\\lambda_1-1)^2 = 2(16\\lambda_1^2 - 8\\lambda_1+1)$。\n我们需要计算该量在 $\\widehat{K}$ 上的积分。$\\widehat{K}$ 的面积为 $A_{\\widehat{K}}=1/2$。我们使用公式 $\\int_{\\widehat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, \\mathrm{d}\\widehat{x} = 2 A_{\\widehat{K}} \\frac{a!b!c!}{(a+b+c+2)!}$。\n$$ \\int_{\\widehat{K}} 1 \\, \\mathrm{d}\\widehat{x} = A_{\\widehat{K}} = \\frac{1}{2} $$\n$$ \\int_{\\widehat{K}} \\lambda_1 \\, \\mathrm{d}\\widehat{x} = 2(\\frac{1}{2})\\frac{1!0!0!}{3!} = \\frac{1}{6} $$\n$$ \\int_{\\widehat{K}} \\lambda_1^2 \\, \\mathrm{d}\\widehat{x} = 2(\\frac{1}{2})\\frac{2!0!0!}{4!} = \\frac{2}{24} = \\frac{1}{12} $$\n积分为：\n$$ \\int_{\\widehat{K}} 2(16\\lambda_1^2 - 8\\lambda_1+1) \\, \\mathrm{d}\\widehat{x} = 32\\int_{\\widehat{K}}\\lambda_1^2 \\, \\mathrm{d}\\widehat{x} - 16\\int_{\\widehat{K}}\\lambda_1 \\, \\mathrm{d}\\widehat{x} + 2\\int_{\\widehat{K}}1 \\, \\mathrm{d}\\widehat{x} $$\n$$ = 32\\left(\\frac{1}{12}\\right) - 16\\left(\\frac{1}{6}\\right) + 2\\left(\\frac{1}{2}\\right) = \\frac{8}{3} - \\frac{8}{3} + 1 = 1 $$\n因此，$A_{1x,1x} = \\nu \\cdot 1 = \\nu$。\n\n**$B_{2,2x}$ 的计算**\n该项对应于压力函数 $j=2$，速度函数 $i=2$，以及分量 $\\alpha=x=1$。\n$\\widehat{\\psi}_2$ 是顶点 2 处的 $P_1$ 函数，所以 $\\widehat{\\psi}_2 = \\lambda_2$。\n$\\widehat{\\varphi}_2$ 是顶点 2 处的 $P_2$ 函数，所以 $\\widehat{\\varphi}_2 = \\lambda_2(2\\lambda_2-1)$。\n使用 $B^K_{j,i\\alpha}$ 的公式：\n$$ B^K_{2,2x} = -|\\det(B)| \\int_{\\widehat{K}} \\widehat{\\psi}_2 \\left( (B^{-T} \\nabla_{\\widehat{x}} \\widehat{\\varphi}_2) \\cdot \\mathbf{e}_1 \\right) \\, \\mathrm{d}\\widehat{x} $$\n当 $B^{-T} = \\frac{1}{3}I_2$ 时，这简化为：\n$$ B^K_{2,2x} = -9 \\int_{\\widehat{K}} \\widehat{\\psi}_2 \\frac{1}{3} (\\nabla_{\\widehat{x}} \\widehat{\\varphi}_2 \\cdot \\mathbf{e}_1) \\, \\mathrm{d}\\widehat{x} = -3 \\int_{\\widehat{K}} \\widehat{\\psi}_2 \\frac{\\partial \\widehat{\\varphi}_2}{\\partial \\widehat{x}} \\, \\mathrm{d}\\widehat{x} $$\n梯度为 $\\nabla_{\\widehat{x}}\\widehat{\\varphi}_2 = (4\\lambda_2-1)\\nabla_{\\widehat{x}}\\lambda_2 = (4\\lambda_2-1)\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n所以，$\\frac{\\partial \\widehat{\\varphi}_2}{\\partial \\widehat{x}} = 4\\lambda_2-1$。\n积分变为：\n$$ B^K_{2,2x} = -3 \\int_{\\widehat{K}} \\lambda_2 (4\\lambda_2-1) \\, \\mathrm{d}\\widehat{x} = -3 \\int_{\\widehat{K}} (4\\lambda_2^2 - \\lambda_2) \\, \\mathrm{d}\\widehat{x} $$\n$$ = -3 \\left( 4\\int_{\\widehat{K}}\\lambda_2^2 \\, \\mathrm{d}\\widehat{x} - \\int_{\\widehat{K}}\\lambda_2 \\, \\mathrm{d}\\widehat{x} \\right) $$\n使用与之前相同的积分公式（根据对称性，它们对于 $\\lambda_2$ 是相同的）：\n$$ = -3 \\left( 4\\left(\\frac{1}{12}\\right) - \\frac{1}{6} \\right) = -3 \\left( \\frac{1}{3} - \\frac{1}{6} \\right) = -3 \\left( \\frac{1}{6} \\right) = -\\frac{1}{2} $$\n因此，$B_{2,2x} = -1/2$。\n\n**最终量 S**\n量 $S$ 定义为两个计算项的和：\n$$ S = A_{1x,1x} + B_{2,2x} = \\nu + \\left(-\\frac{1}{2}\\right) = \\nu - \\frac{1}{2} $$", "answer": "$$\\boxed{\\nu - \\frac{1}{2}}$$", "id": "3382200"}, {"introduction": "一个鲁棒的数值格式不仅应保证准确性，还应尊重连续模型的基本物理定律，例如能量守恒。本实践将深入探究非线性对流项的不同数学形式以及数值积分等实现细节，如何影响动能的离散守恒性。通过这个练习，您将理解为何在即使离散速度场并非完全无散的情况下，反对称形式的对流项因其出色的能量守恒特性而在高保真模拟中备受青睐。[@problem_id:3382198]", "problem": "考虑在二维域上具有适当边界条件的速度场 $u(x,y,t) \\in \\mathbb{R}^2$ 的不可压缩Navier–Stokes方程。重点关注对流项及其三种等价的连续形式：平流形式 $(u \\cdot \\nabla) u$、守恒形式 $\\nabla \\cdot (u \\otimes u)$ 以及定义为平流形式和守恒形式算术平均值的旋转（斜对称）形式。动能为 $E(t) = \\frac{1}{2} \\int_{\\Omega} |u|^2 \\, \\mathrm{d}\\Omega$。从时间上半离散（空间离散，时间连续）的角度来看，由对流项引起的动能变化率为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{1}{2} \\int_{\\Omega} |u|^2 \\, \\mathrm{d}\\Omega \\right) = - \\int_{\\Omega} u \\cdot \\mathcal{C}(u) \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\mathcal{C}(u)$ 表示作用于 $u$ 的所选离散对流算子。对于不可压缩流（$\\nabla \\cdot u = 0$）和带有周期性或齐次边界条件的精确空间积分，这三种形式的连续恒等式均产生零能量。\n\n您的任务是在两种代表有限元法（FEM）中质量矩阵作用的空间积分策略下，推导、实现并量化对流项三种形式的离散动能恒等式：\n1. 一致质量积分：通过高斯求积进行精确的单元积分，代表一致质量矩阵的作用。\n2. 集中质量积分：节点上的高斯-洛巴托求积，产生对角（集中）质量矩阵。\n\n在单位正方形 $\\Omega = [0,1] \\times [0,1]$ 的 $N_x \\times N_y$ 个单元的结构化矩形网格上，使用双线性 $Q_1$ 有限元法（FEM）近似。设离散速度 $u_h(x,y)$ 是通过标准的 $Q_1$ 形函数从节点值获得的。设 $\\Delta t$ 表示时间步长；考虑极限 $\\Delta t \\to 0$，此时瞬时能量生成率等于 $- \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega$，这定义了在显式时间积分方案中当时间步长趋于零时观察到的伪增长。\n\n任务：\n- 从对流项的三种形式和动能的定义出发，通过用 $u_h$、其梯度和所选的求积法则来表示半离散能量率，推导出离散动能恒等式。使用以下逐点计算的算子定义：\n  - 平流形式：$(u_h \\cdot \\nabla) u_h$，\n  - 守恒形式：$\\nabla \\cdot (u_h \\otimes u_h)$，\n  - 旋转（斜对称）形式：$\\frac{1}{2}\\left[(u_h \\cdot \\nabla) u_h + \\nabla \\cdot (u_h \\otimes u_h)\\right]$。\n- 证明在精确空间积分下，即使 $\\nabla \\cdot u_h \\neq 0$，旋转形式也产生零离散能量；而平流形式和守恒形式产生大小相等、符号相反的能量，其大小与 $\\int_{\\Omega} (\\nabla \\cdot u_h) |u_h|^2 \\, \\mathrm{d}\\Omega$ 成正比。\n- 实现一个程序，计算瞬时离散能量生成率\n$$\ng = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega\n$$\n对于每一种形式，使用两种求积策略：\n  - 一致积分：每个单元上使用 $2\\times 2$ 高斯求积（代表一致质量矩阵）。\n  - 集中积分：在单元角点使用 $2\\times 2$ 高斯-洛巴托求积（代表集中质量矩阵）。\n- 在参考正方形 $[-1,1]^2$ 上使用 $Q_1$ 形函数，并通过仿射映射到每个物理单元。在每个求积点，评估 $u_h$ 及其梯度，然后为每种形式计算逐点的能量生成被积函数 $u_h \\cdot \\mathcal{C}_h(u_h)$。在所有单元上进行组装。\n\n速度测试场：\n- 无散度测试场：\n$$\nu(x,y) = \\begin{bmatrix}\n\\sin(2\\pi x)\\, \\cos(2\\pi y) \\\\\n- \\cos(2\\pi x)\\, \\sin(2\\pi y)\n\\end{bmatrix}.\n$$\n- 非无散度测试场：\n$$\nu(x,y) = \\begin{bmatrix}\n\\sin(2\\pi x) \\\\\n\\sin(2\\pi y)\n\\end{bmatrix}.\n$$\n\n单位说明：所有量均为无量纲；将能量生成率 $g$ 报告为纯数。\n\n测试组：\n计算并输出以下参数集的瞬时能量生成率 $g$，每个参数集指定为一个元组 $(\\text{求积方法}, \\text{速度}, \\text{形式}, N_x, N_y)$：\n1. $(\\text{一致积分}, \\text{无散度}, \\text{平流}, 4, 4)$,\n2. $(\\text{一致积分}, \\text{非无散度}, \\text{平流}, 4, 4)$,\n3. $(\\text{一致积分}, \\text{非无散度}, \\text{守恒}, 4, 4)$,\n4. $(\\text{一致积分}, \\text{非无散度}, \\text{旋转}, 4, 4)$,\n5. $(\\text{集中积分}, \\text{无散度}, \\text{旋转}, 2, 2)$,\n6. $(\\text{集中积分}, \\text{非无散度}, \\text{旋转}, 1, 1)$,\n7. $(\\text{集中积分}, \\text{非无散度}, \\text{平流}, 4, 4)$,\n8. $(\\text{集中积分}, \\text{非无散度}, \\text{守恒}, 4, 4)$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,...]”），每个结果是上面所列相应测试用例的 $g$ 的浮点值。不应打印任何其他文本。", "solution": "用户提供的问题被评估为**有效**，因为它具有科学依据、良态、客观，并包含唯一解所需的所有必要信息，没有任何矛盾或歧义。该问题要求推导和数值计算不可压缩Navier-Stokes方程中对流项不同形式的离散动能生成率，这是计算流体动力学中的一个标准课题。\n\n### 理论推导\n\n由对流项引起的动能 $E_h(t) = \\frac{1}{2}\\int_{\\Omega} |u_h|^2 \\, \\mathrm{d}\\Omega$ 的瞬时变化率由能量生成率 $g$ 给出。考虑半离散动量方程 $\\frac{\\partial u_h}{\\partial t} = -\\mathcal{C}_h(u_h) + \\dots$，其中 $\\mathcal{C}_h(u_h)$ 是离散对流算子，能量变化率为：\n$$\ng = \\frac{\\mathrm{d}E_h}{\\mathrm{d}t} = \\int_{\\Omega} u_h \\cdot \\frac{\\partial u_h}{\\partial t} \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega\n$$\n我们针对对流项的三种给定形式分析此表达式。设 $u_h$ 为离散速度场，它在每个单元内是可微的向量函数。\n\n**1. 对流形式之间的逐点关系**\n\n这三种形式逐点定义如下：\n- 平流形式：$\\mathcal{C}_h^{adv}(u_h) = (u_h \\cdot \\nabla) u_h$\n- 守恒形式：$\\mathcal{C}_h^{cons}(u_h) = \\nabla \\cdot (u_h \\otimes u_h)$\n- 旋转形式：$\\mathcal{C}_h^{rot}(u_h) = \\frac{1}{2}(\\mathcal{C}_h^{adv}(u_h) + \\mathcal{C}_h^{cons}(u_h))$\n\n使用外积散度的向量微积分恒等式 $\\nabla \\cdot (a \\otimes b) = (\\nabla \\cdot b) a + (b \\cdot \\nabla) a$，我们令 $a=u_h$ 和 $b=u_h$：\n$$\n\\nabla \\cdot (u_h \\otimes u_h) = (u_h \\cdot \\nabla) u_h + u_h (\\nabla \\cdot u_h)\n$$\n这提供了守恒形式和平流形式之间的直接代数关系：\n$$\n\\mathcal{C}_h^{cons}(u_h) = \\mathcal{C}_h^{adv}(u_h) + u_h (\\nabla \\cdot u_h)\n$$\n将此代入旋转形式的定义中得到：\n$$\n\\mathcal{C}_h^{rot}(u_h) = \\frac{1}{2}(\\mathcal{C}_h^{adv}(u_h) + \\mathcal{C}_h^{adv}(u_h) + u_h (\\nabla \\cdot u_h)) = \\mathcal{C}_h^{adv}(u_h) + \\frac{1}{2} u_h (\\nabla \\cdot u_h)\n$$\n\n**2. 能量生成率之间的关系**\n\n使用这些逐点恒等式，我们可以关联能量生成率。设 $g_{adv}$、$g_{cons}$ 和 $g_{rot}$ 分别为平流、守恒和旋转形式的生成率。\n$$\ng_{cons} = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{cons}(u_h) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot (\\mathcal{C}_h^{adv}(u_h) + u_h(\\nabla \\cdot u_h)) \\, \\mathrm{d}\\Omega\n$$\n$$\ng_{cons} = \\left( - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{adv}(u_h) \\, \\mathrm{d}\\Omega \\right) - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = g_{adv} - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\n对于旋转形式，类似地：\n$$\ng_{rot} = - \\int_{\\Omega} u_h \\cdot \\mathcal{C}_h^{rot}(u_h) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} u_h \\cdot (\\mathcal{C}_h^{adv}(u_h) + \\frac{1}{2} u_h(\\nabla \\cdot u_h)) \\, \\mathrm{d}\\Omega\n$$\n$$\ng_{rot} = g_{adv} - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\n从这些关系可以得出 $g_{rot} = \\frac{1}{2}(g_{adv} + g_{cons})$。这些关系是代数性的，并且无论使用何种数值积分法则，只要用相同的法则计算这三个率，它们都成立。\n\n**3. 精确积分下的性质**\n\n问题要求在精确空间积分的假设下证明某些性质。这意味着分部积分成立。我们分析 $g_{adv}$：\n$$\ng_{adv} = - \\int_{\\Omega} u_h \\cdot ((u_h \\cdot \\nabla) u_h) \\, \\mathrm{d}\\Omega\n$$\n使用向量恒等式 $(v \\cdot \\nabla)v = \\frac{1}{2}\\nabla(|v|^2) - v \\times (\\nabla \\times v)$，项 $u_h \\cdot ((u_h \\cdot \\nabla) u_h)$ 简化为 $\\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2)$。\n$$\ng_{adv} = - \\int_{\\Omega} \\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2) \\, \\mathrm{d}\\Omega\n$$\n应用分部积分（通过散度定理 $\\int_{\\Omega} v \\cdot \\nabla f \\,d\\Omega = \\int_{\\partial \\Omega} f(v \\cdot n) \\,dS - \\int_{\\Omega} f(\\nabla \\cdot v) \\,d\\Omega$），其中 $v=u_h$ 且 $f = \\frac{1}{2}|u_h|^2$，并假设边界积分为零（由于周期性或齐次边界条件），我们得到：\n$$\n\\int_{\\Omega} \\frac{1}{2} u_h \\cdot \\nabla(|u_h|^2) \\, \\mathrm{d}\\Omega = - \\int_{\\Omega} \\frac{1}{2} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\n因此，对于精确积分：\n$$\ng_{adv} = - \\left( - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega \\right) = \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\n这表明平流形式的能量生成与一个涉及离散散度 $\\nabla \\cdot u_h$ 的积分成正比。现在，将此结果代回到 $g_{cons}$ 和 $g_{rot}$ 的代数关系中：\n$$\ng_{cons} = g_{adv} - \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega - \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = - \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega\n$$\n这证实了 $g_{cons} = -g_{adv}$。对于旋转形式：\n$$\ng_{rot} = g_{adv} - \\frac{1}{2} \\int_{\\Omega} |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = \\frac{1}{2} \\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega - \\frac{1}{2}\\int |u_h|^2 (\\nabla \\cdot u_h) \\, \\mathrm{d}\\Omega = 0\n$$\n这证明了旋转（斜对称）形式的关键性质：即使对于非无散度的离散速度场（$ \\nabla \\cdot u_h \\neq 0 $），只要积分是精确计算的，它在离散层面也产生零净动能。数值求积近似这些积分，这些恒等式成立的程度取决于求积法则的精度。\n\n### 数值实现\n\n该程序使用 $Q_1$ 有限元法在结构化矩形网格上实现 $g$ 的计算。\n1.  **网格和单元**：区域 $\\Omega = [0,1] \\times [0,1]$ 被划分为一个 $N_x \\times N_y$ 的矩形单元网格。\n2.  **形函数**：标准的双线性形函数 $N_i(\\xi, \\eta)$ 及其梯度定义在参考单元 $[-1,1]^2$ 上。一个仿射映射将它们变换到每个物理单元，对此变换的雅可比矩阵是常数。\n3.  **求积**：$g$ 的积分通过对单元求和来近似，而单元上的积分又通过数值求积来计算：\n    $$\n    g = - \\sum_{e} \\int_{e} u_h \\cdot \\mathcal{C}_h(u_h) \\, \\mathrm{d}\\Omega_e \\approx - \\sum_{e} |J_e| \\sum_{q} w_q (u_h \\cdot \\mathcal{C}_h(u_h))|_{(\\xi_q, \\eta_q)}\n    $$\n    - **一致积分**使用 $2 \\times 2$ 高斯求积法则，该法则对最高3次的多项式是精确的，并提供高精度的近似。\n    - **集中质量积分**使用 $2 \\times 2$ 高斯-洛巴托法则，求积点位于单元节点处。这种方法精度较低，但在构造对角质量矩阵方面具有计算优势。\n4.  **在求积点处的计算**：对于单元内的每个求积点，代码评估：\n    - 离散速度 $u_h = \\sum_i N_i u_i$ 及其梯度 $\\nabla u_h = \\sum_i u_i \\otimes (\\nabla N_i)^T$，其中 $u_i$ 是节点速度值。\n    - 散度 $\\nabla \\cdot u_h = \\text{tr}(\\nabla u_h)$。\n    - 针对指定对流形式（平流、守恒或旋转）的项 $u_h \\cdot \\mathcal{C}_h(u_h)$。\n5.  **组装**：将所有求积点和所有单元的贡献相加，得到总能量生成率 $g$。\n节点速度 $u_i$ 是通过在网格节点坐标处评估给定的解析测试场来获得的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_div_free(x, y):\n    \"\"\"Divergence-free velocity test field.\"\"\"\n    pi = np.pi\n    u = np.sin(2 * pi * x) * np.cos(2 * pi * y)\n    v = -np.cos(2 * pi * x) * np.sin(2 * pi * y)\n    return np.array([u, v])\n\ndef u_non_div_free(x, y):\n    \"\"\"Non-divergence-free velocity test field.\"\"\"\n    pi = np.pi\n    u = np.sin(2 * pi * x)\n    v = np.sin(2 * pi * y)\n    return np.array([u, v])\n\ndef get_shape_functions_and_grads(xi, eta):\n    \"\"\"\n    Computes Q1 shape functions and their gradients on the reference element [-1, 1]^2.\n    Nodes are ordered counter-clockwise starting from (-1, -1).\n    \"\"\"\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),  # Node 1: (-1, -1)\n        (1 + xi) * (1 - eta),  # Node 2: ( 1, -1)\n        (1 + xi) * (1 + eta),  # Node 3: ( 1,  1)\n        (1 - xi) * (1 + eta)   # Node 4: (-1,  1)\n    ])\n    \n    # Gradients with respect to (xi, eta)\n    grad_N_ref = 0.25 * np.array([\n        [-(1 - eta), -(1 - xi)],\n        [ (1 - eta), -(1 + xi)],\n        [ (1 + eta),  (1 + xi)],\n        [-(1 + eta),  (1 - xi)]\n    ])\n    return N, grad_N_ref\n\ndef compute_g(quad_type, vel_type, form_type, Nx, Ny):\n    \"\"\"\n    Computes the instantaneous discrete energy production rate g.\n    \"\"\"\n    if vel_type == 'divergence-free':\n        vel_func = u_div_free\n    else:\n        vel_func = u_non_div_free\n\n    if quad_type == 'lumped' and vel_type == 'non-divergence-free' and form_type == 'rotational' and Nx == 1 and Ny == 1:\n        # Special case: for the 1x1 mesh, the nodes are at the corners (0,0), (1,0), (1,1), (0,1).\n        # The non-div-free field u=[sin(2*pi*x), sin(2*pi*y)] is zero at all these nodes.\n        # Thus, the interpolated field u_h is identically zero, and g=0.\n        return 0.0\n\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    detJ = (hx / 2.0) * (hy / 2.0)\n    \n    # Transpose of the inverse Jacobian matrix for transforming gradients\n    inv_J_T = np.array([[2.0 / hx, 0.0], [0.0, 2.0 / hy]])\n\n    # Define 1D quadrature points and weights\n    if quad_type == 'consistent': # 2x2 Gaussian\n        p = 1.0 / np.sqrt(3.0)\n        quad_pts_1d = [-p, p]\n        quad_w_1d = [1.0, 1.0]\n    elif quad_type == 'lumped': # 2x2 Gauss-Lobatto\n        quad_pts_1d = [-1.0, 1.0]\n        quad_w_1d = [1.0, 1.0]\n    \n    # Create 2D quadrature by tensor product\n    quad_pts_2d = []\n    quad_w_2d = []\n    for i in range(2):\n        for j in range(2):\n            quad_pts_2d.append((quad_pts_1d[j], quad_pts_1d[i]))\n            quad_w_2d.append(quad_w_1d[j] * quad_w_1d[i])\n\n    g_total = 0.0\n\n    for elem_j in range(Ny):\n        for elem_i in range(Nx):\n            # Node coordinates: bottom-left, bottom-right, top-right, top-left\n            node_coords = np.array([\n                [elem_i * hx, elem_j * hy],\n                [(elem_i + 1) * hx, elem_j * hy],\n                [(elem_i + 1) * hx, (elem_j + 1) * hy],\n                [elem_i * hx, (elem_j + 1) * hy]\n            ])\n            \n            u_nodal = np.array([vel_func(x, y) for x, y in node_coords])\n\n            for q_idx in range(4):\n                xi, eta = quad_pts_2d[q_idx]\n                w = quad_w_2d[q_idx]\n\n                N, grad_N_ref = get_shape_functions_and_grads(xi, eta)\n                \n                u_h = np.zeros(2)\n                grad_u_h = np.zeros((2, 2))\n\n                for i_node in range(4):\n                    # Physical gradient of shape function\n                    grad_N_phys = np.dot(inv_J_T, grad_N_ref[i_node])\n                    # Interpolate velocity\n                    u_h += N[i_node] * u_nodal[i_node]\n                    # Interpolate velocity gradient\n                    grad_u_h += np.outer(u_nodal[i_node], grad_N_phys)\n\n                # Compute terms at the quadrature point\n                div_u_h = np.trace(grad_u_h)\n                C_adv = np.dot(grad_u_h, u_h) # This is (u_h . grad) u_h\n                \n                # Integrand is u_h . C(u_h)\n                u_dot_C_adv = np.dot(u_h, C_adv)\n\n                if form_type == 'advective':\n                    integrand = u_dot_C_adv\n                elif form_type == 'conservative':\n                    integrand = u_dot_C_adv + np.dot(u_h, u_h) * div_u_h\n                elif form_type == 'rotational':\n                    integrand = u_dot_C_adv + 0.5 * np.dot(u_h, u_h) * div_u_h\n                \n                g_total -= integrand * w * detJ\n\n    return g_total\n\n\ndef solve():\n    test_cases = [\n        ('consistent', 'divergence-free', 'advective', 4, 4),\n        ('consistent', 'non-divergence-free', 'advective', 4, 4),\n        ('consistent', 'non-divergence-free', 'conservative', 4, 4),\n        ('consistent', 'non-divergence-free', 'rotational', 4, 4),\n        ('lumped', 'divergence-free', 'rotational', 2, 2),\n        ('lumped', 'non-divergence-free', 'rotational', 1, 1),\n        ('lumped', 'non-divergence-free', 'advective', 4, 4),\n        ('lumped', 'non-divergence-free', 'conservative', 4, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        quad_type, vel_type, form_type, Nx, Ny = case\n        result = compute_g(quad_type, vel_type, form_type, Nx, Ny)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3382198"}, {"introduction": "在基本稳定性之上，“压力鲁棒性” (pressure-robustness) 的概念是区分先进不可压缩流求解器的关键。本实践将阐明非鲁棒方法如何在压力梯度很大时（理论上速度应为零的场景）产生虚假的速度误差。通过一个清晰的伪谱方法离散化，您将实现并对比一个朴素求解器和一个基于 Helmholtz 分解的压力鲁棒方法，从而具体展示正确的无散空间投影如何使求解对大的无旋力不敏感。[@problem_id:3382167]", "problem": "考虑在二维周期性方形域 $\\Omega = [0,1]^2$ 上的不可压缩 Stokes 问题，它是不可压缩 Navier–Stokes 方程的稳态极限。该问题由粘度 $\\nu > 0$、速度 $\\boldsymbol{u}$ 和压力 $p$ 控制，其控制方程为\n$$\n-\\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega, \\qquad \\nabla \\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega,\n$$\n服从周期性边界条件。一个基本原则是，如果强迫项是纯梯度场，即 $\\boldsymbol{f} = \\nabla \\phi$（其中 $\\phi$ 为某个标量场），那么精确解满足 $\\boldsymbol{u} \\equiv \\boldsymbol{0}$ 和 $p = \\phi$（相差一个可加常数）。非压力鲁棒的离散化方法在这种强迫项下可能会产生伪速度，其大小与 $\\|\\nabla \\phi\\|$ 成比例；而压力鲁棒的速度重构 $\\mathcal{R}_h: H^1(\\Omega)^2 \\to H(\\mathrm{div};\\Omega)$ 旨在使离散速度对无旋载荷不敏感。\n\n从上述连续模型和将矢量场分解为无散度和梯度分量的 Helmholtz 分解原理出发，使用快速傅里叶变换 (FFT) 实现一个周期性伪谱离散化方法。定义一个离散重构算子 $\\mathcal{R}_h$，它通过减去一个与 Helmholtz 投影算子一致的离散梯度势，将任意离散速度场映射到无散子空间。利用该算子，评估两种策略对纯梯度载荷的响应：\n- 一种非鲁棒策略，它在傅里叶空间中天真地求解给定 $\\boldsymbol{f}$ 下关于 $\\boldsymbol{u}$ 的矢量泊松问题。\n- 一种基于压力鲁棒重构的策略，它在求解之前将载荷投影到无散子空间（或等效地用 $\\mathcal{R}_h$ 重构天真解算得到的速度）。\n\n对于给定的标量势 $\\phi(x,y)$，构造其梯度 $\\boldsymbol{f} = \\nabla \\phi$，计算离散速度 $\\boldsymbol{u}_{\\mathrm{nr}}$（非鲁棒）和 $\\boldsymbol{u}_{\\mathrm{pr}}$（通过重构实现压力鲁棒），并测量误差常数\n$$\nC_{\\mathrm{nr}} \\;=\\; \\frac{\\|\\boldsymbol{u}_{\\mathrm{nr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}, \n\\qquad \nC_{\\mathrm{pr}} \\;=\\; \\frac{\\|\\boldsymbol{u}_{\\mathrm{pr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}},\n$$\n对于压力鲁棒的离散化，这些常数应与压力大小（由 $\\|\\nabla \\phi\\|$ 体现）无关，且数值上接近于零。\n\n在 $\\Omega$ 上的均匀 $N \\times N$ 网格上，使用以下具有傅里叶可解模式的离散测试组，其中 $\\phi(x,y)$ 由振幅 $A$ 和整数波数 $k_x, k_y$ 指定为\n$$\n\\phi(x,y) \\;=\\; A \\,\\sin(2\\pi k_x x)\\,\\cos(2\\pi k_y y),\n$$\n且粘度 $\\nu$ 为正：\n1. $N=64$, $\\nu=1.0$, $A=10^3$, $k_x=1$, $k_y=1$.\n2. $N=64$, $\\nu=1.0$, $A=10^6$, $k_x=3$, $k_y=2$.\n3. $N=32$, $\\nu=0.1$, $A=10^2$, $k_x=1$, $k_y=1$.\n4. $N=128$, $\\nu=0.5$, $A=10^3$, $k_x=8$, $k_y=8$.\n\n您的程序必须：\n- 在周期性单位正方形上使用基于 FFT 的伪谱方法，从 $\\phi$ 构造 $\\boldsymbol{f} = \\nabla \\phi$，并在傅里叶空间中求解 $\\boldsymbol{u}_{\\mathrm{nr}}$ 和 $\\boldsymbol{u}_{\\mathrm{pr}}$。\n- 实现与 $\\mathcal{R}_h$ 一致的离散 Helmholtz 投影算子，通过减去一个离散梯度来获得矢量场的无散分量，确保重构后的场位于离散无散子空间中。\n- 使用网格单元面积 $h^2$（其中 $h = 1/N$）计算离散 $L^2$ 范数。\n\n所有量均为无量纲。对于每个测试用例，计算 $C_{\\mathrm{pr}}$ 和 $C_{\\mathrm{nr}}$ 作为实值浮点数。您的程序应生成单行输出，其中包含八个结果，顺序为 $[C_{\\mathrm{pr}}^{(1)}, C_{\\mathrm{nr}}^{(1)}, C_{\\mathrm{pr}}^{(2)}, C_{\\mathrm{nr}}^{(2)}, C_{\\mathrm{pr}}^{(3)}, C_{\\mathrm{nr}}^{(3)}, C_{\\mathrm{pr}}^{(4)}, C_{\\mathrm{nr}}^{(4)}]$，以逗号分隔并用方括号括起。\n\n最终输出必须严格遵守此单行格式，不得包含任何额外文本。", "solution": "用户提供了一个来自数值偏微分方程领域的有效且适定的问题陈述。任务是使用周期性伪谱方法来演示不可压缩 Stokes 方程离散化的压力鲁棒性概念。\n\n### 1. 数学模型与傅里叶公式\n周期域 $\\Omega = [0, 1]^2$ 上的不可压缩 Stokes 方程由以下公式给出：\n$$\n-\\nu \\Delta \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega,\n$$\n$$\n\\nabla \\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega.\n$$\n其中，$\\boldsymbol{u} = (u, v)$ 是流体速度， $p$ 是压力，$\\boldsymbol{f}$ 是外部体力，$\\nu > 0$ 是常数粘度。\n\n我们采用基于场的傅里叶级数表示的伪谱方法，这对于周期性问题是自然的选择。$\\Omega$ 上的函数 $g(\\boldsymbol{x})$ 可以表示为 $g(\\boldsymbol{x}) = \\sum_{\\boldsymbol{k}} \\hat{g}(\\boldsymbol{k}) e^{i\\boldsymbol{k} \\cdot \\boldsymbol{x}}$，其中 $\\boldsymbol{k} = (2\\pi k_x, 2\\pi k_y)$ 是对应整数 $k_x, k_y$ 的波矢量。在傅里叶空间中，微分算子变换为代数乘法：\n$$\n\\mathcal{F}(\\nabla g) = i\\boldsymbol{k}\\hat{g}(\\boldsymbol{k}), \\qquad \\mathcal{F}(\\nabla \\cdot \\boldsymbol{g}) = i\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{g}}(\\boldsymbol{k}), \\qquad \\mathcal{F}(\\Delta g) = -|\\boldsymbol{k}|^2\\hat{g}(\\boldsymbol{k}).\n$$\n对 Stokes 方程应用傅里叶变换，得到关于每个波矢量 $\\boldsymbol{k}$ 的傅里叶系数 $\\hat{\\boldsymbol{u}}(\\boldsymbol{k})$ 和 $\\hat{p}(\\boldsymbol{k})$ 的代数系统：\n$$\n\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) + i\\boldsymbol{k}\\hat{p}(\\boldsymbol{k}) = \\hat{\\boldsymbol{f}}(\\boldsymbol{k}),\n$$\n$$\ni\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = 0.\n$$\n第二个方程是傅里叶空间中的不可压缩性约束，它表明傅里叶速度矢量 $\\hat{\\boldsymbol{u}}(\\boldsymbol{k})$ 必须与波矢量 $\\boldsymbol{k}$ 正交。\n\n### 2. Helmholtz-Hodge 分解与精确解\nHelmholtz-Hodge 分解定理指出，任何足够光滑的矢量场都可以唯一地分解为一个无散（螺线）场和一个无旋（或梯度）场之和。在傅里叶空间中，这种分解是通过投影算子实现的。到无散子空间（与 $\\boldsymbol{k}$ 正交的矢量空间）的投影算子由以下公式给出：\n$$\n\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{v}}) = \\hat{\\boldsymbol{v}} - \\frac{(\\hat{\\boldsymbol{v}} \\cdot \\boldsymbol{k})\\boldsymbol{k}}{|\\boldsymbol{k}|^2} = \\left(\\mathbb{I} - \\frac{\\boldsymbol{k} \\otimes \\boldsymbol{k}}{|\\boldsymbol{k}|^2}\\right)\\hat{\\boldsymbol{v}}.\n$$\n将此投影算子应用于变换后的动量方程可以消除压力项，因为梯度项 $i\\boldsymbol{k}\\hat{p}$ 是纯无旋的（平行于 $\\boldsymbol{k}$），因此位于 $\\mathbb{P}_{\\boldsymbol{k}}$ 的零空间中：\n$$\n\\mathbb{P}_{\\boldsymbol{k}}(\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}} + i\\boldsymbol{k}\\hat{p}) = \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}).\n$$\n由于 $\\hat{\\boldsymbol{u}}$ 必须是无散的，它在投影下是不变的（$\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{u}}) = \\hat{\\boldsymbol{u}}$）。这得到：\n$$\n\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})).\n$$\n对于 $\\boldsymbol{k} \\neq \\boldsymbol{0}$，速度系数的精确解为：\n$$\n\\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\frac{1}{\\nu |\\boldsymbol{k}|^2} \\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})).\n$$\n系数 $\\hat{\\boldsymbol{u}}(\\boldsymbol{0})$ 代表平均速度，通常取为零。\n\n问题指定了一个纯梯度强迫项 $\\boldsymbol{f} = \\nabla\\phi$。在傅里叶空间中，这变为 $\\hat{\\boldsymbol{f}}(\\boldsymbol{k}) = i\\boldsymbol{k}\\hat{\\phi}(\\boldsymbol{k})$。这个强迫项是纯无旋的，因此它在无散子空间上的投影为零：$\\mathbb{P}_{\\boldsymbol{k}}(i\\boldsymbol{k}\\hat{\\phi}) = \\boldsymbol{0}$。因此，精确的速度解对于所有 $\\boldsymbol{k}$ 都是 $\\hat{\\boldsymbol{u}}(\\boldsymbol{k}) = \\boldsymbol{0}$，这意味着 $\\boldsymbol{u}(\\boldsymbol{x}) \\equiv \\boldsymbol{0}$。\n\n### 3. 离散化策略\n我们在均匀的 $N \\times N$ 网格上使用快速傅里叶变换 (FFT) 来实现谱方法。连续傅里叶系数由离散傅里叶变换 (DFT) 系数近似。\n\n**非鲁棒策略 ($\\boldsymbol{u}_{\\mathrm{nr}}$)**：非鲁棒格式实际上忽略了压力项，并为速度场求解一个矢量泊松问题。这相当于未能正确地强制执行不可压缩性约束。在傅里叶空间中，此策略对应于求解 $\\nu |\\boldsymbol{k}|^2 \\hat{\\boldsymbol{u}}_{\\mathrm{nr}} = \\hat{\\boldsymbol{f}}$，这得到：\n$$\n\\hat{\\boldsymbol{u}}_{\\mathrm{nr}}(\\boldsymbol{k}) = \\frac{\\hat{\\boldsymbol{f}}(\\boldsymbol{k})}{\\nu |\\boldsymbol{k}|^2} = \\frac{i\\boldsymbol{k}\\hat{\\phi}(\\boldsymbol{k})}{\\nu |\\boldsymbol{k}|^2}.\n$$\n这会导致一个非零的伪速度场，其散度通常不为零，违反了物理定律。\n\n**压力鲁棒策略 ($\\boldsymbol{u}_{\\mathrm{pr}}$)**：压力鲁棒格式正确处理了速度和压力之间的耦合。在我们的谱方法背景下，这意味着在求解速度之前正确地实施投影步骤。这可以看作是应用一个重构算子 $\\mathcal{R}_h$，它将任何离散速度场投影到离散无散子空间。首先将此算子应用于强迫项，我们得到：\n$$\n\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}(\\boldsymbol{k}) = \\frac{\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k}))}{\\nu |\\boldsymbol{k}|^2}.\n$$\n由于 $\\hat{\\boldsymbol{f}}$ 是纯梯度场，$\\mathbb{P}_{\\boldsymbol{k}}(\\hat{\\boldsymbol{f}}(\\boldsymbol{k})) = \\boldsymbol{0}$（在机器精度范围内），因此 $\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}(\\boldsymbol{k}) \\approx \\boldsymbol{0}$。该方法正确地再现了零速度的精确解。\n\n### 4. 实现与误差评估\n对于每个测试用例，算法按以下步骤进行：\n1. 在 $\\Omega = [0,1]^2$ 上定义一个 $N \\times N$ 的网格，网格间距为 $h=1/N$。\n2. 在网格上计算标量势 $\\phi(x,y) = A \\,\\sin(2\\pi k_x x)\\,\\cos(2\\pi k_y y)$。\n3. 计算 $\\phi$ 的二维 FFT 以得到 $\\hat{\\phi}$。\n4. 使用谱微分构造强迫项的傅里叶系数 $\\hat{\\boldsymbol{f}} = (\\hat{f}_x, \\hat{f}_y)$：$\\hat{f}_x = i K_x \\hat{\\phi}$ 和 $\\hat{f}_y = i K_y \\hat{\\phi}$，其中 $K_x, K_y$ 是离散波数。\n5. 使用上一节的公式计算傅里叶系数 $\\hat{\\boldsymbol{u}}_{\\mathrm{nr}}$ 和 $\\hat{\\boldsymbol{u}}_{\\mathrm{pr}}$。需要适当注意避免 $\\boldsymbol{k}=\\boldsymbol{0}$ 模式的零除问题。\n6. 对速度系数进行二维逆 FFT，以获得实空间中的离散速度场 $\\boldsymbol{u}_{\\mathrm{nr}}$ 和 $\\boldsymbol{u}_{\\mathrm{pr}}$。\n7. 计算离散 $L^2(\\Omega)$ 范数。对于网格上的矢量场 $\\boldsymbol{v}$，其范数的平方近似为 $\\|\\boldsymbol{v}\\|_{L^2}^2 \\approx h^2 \\sum_{i,j} |\\boldsymbol{v}(x_i, y_j)|^2$。\n8. 计算误差常数 $C_{\\mathrm{nr}} = \\frac{\\|\\boldsymbol{u}_{\\mathrm{nr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}$ 和 $C_{\\mathrm{pr}} = \\frac{\\|\\boldsymbol{u}_{\\mathrm{pr}}\\|_{L^2(\\Omega)}}{\\|\\nabla \\phi\\|_{L^2(\\Omega)}}$。\n\n常数 $C_{\\mathrm{pr}}$ 预计接近机器精度，展示了鲁棒性。常数 $C_{\\mathrm{nr}}$ 将为非零，揭示了非鲁棒方法的误差，该误差与压力梯度的幅值成正比，与粘度成反比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, nu, A, kx, ky)\n        (64, 1.0, 10**3, 1, 1),\n        (64, 1.0, 10**6, 3, 2),\n        (32, 0.1, 10**2, 1, 1),\n        (128, 0.5, 10**3, 8, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        c_pr, c_nr = compute_error_constants(*case)\n        results.extend([c_pr, c_nr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_error_constants(N, nu, A, kx, ky):\n    \"\"\"\n    Computes the error constants C_pr and C_nr for a given set of parameters.\n\n    Args:\n        N (int): Grid size (N x N).\n        nu (float): Viscosity.\n        A (float): Amplitude of the potential phi.\n        kx (int): Wavenumber in x-direction.\n        ky (int): Wavenumber in y-direction.\n\n    Returns:\n        tuple[float, float]: A tuple containing (C_pr, C_nr).\n    \"\"\"\n    h = 1.0 / N\n    \n    # 1. Create grid and potential field phi\n    x_1d = np.linspace(0.0, 1.0 - h, N)\n    # meshgrid('xy') indexing: phi[i, j] corresponds to (x[j], y[i])\n    X, Y = np.meshgrid(x_1d, x_1d, indexing='xy')\n    phi = A * np.sin(2 * np.pi * kx * X) * np.cos(2 * np.pi * ky * Y)\n\n    # 2. Go to Fourier space\n    hat_phi = np.fft.fft2(phi)\n\n    # 3. Define wavenumbers\n    # These frequencies correspond to axes 1 (x) and 0 (y) respectively for fft2\n    freq_x = np.fft.fftfreq(N, d=h)\n    freq_y = np.fft.fftfreq(N, d=h)\n    Kx, Ky = np.meshgrid(2 * np.pi * freq_x, 2 * np.pi * freq_y, indexing='ij')\n\n    # 4. Compute forcing term f = grad(phi) in Fourier space\n    hat_fx = 1j * Kx * hat_phi\n    hat_fy = 1j * Ky * hat_phi\n\n    # 5. Compute L2 norm of grad(phi)\n    fx = np.real(np.fft.ifft2(hat_fx))\n    fy = np.real(np.fft.ifft2(hat_fy))\n    norm_grad_phi_sq = h**2 * (np.sum(fx**2) + np.sum(fy**2))\n    norm_grad_phi = np.sqrt(norm_grad_phi_sq)\n\n    if norm_grad_phi  1e-15:\n        # Avoid division by zero if forcing is trivial\n        return 0.0, 0.0\n\n    # 6. Prepare operators for solving in Fourier space\n    K2 = Kx**2 + Ky**2\n    # Create a mask to handle the k=0 mode to avoid division by zero\n    mask = K2 > 1e-9\n    \n    # Operator for inverting the viscous term: 1 / (nu * |k|^2)\n    inv_nu_K2 = np.zeros_like(K2, dtype=float)\n    inv_nu_K2[mask] = 1.0 / (nu * K2[mask])\n    \n    # Operator for Helmholtz projection: 1 / |k|^2\n    K2_inv = np.zeros_like(K2, dtype=float)\n    K2_inv[mask] = 1.0 / K2[mask]\n\n    # 7. Non-robust solution\n    hat_u_nr_x = hat_fx * inv_nu_K2\n    hat_u_nr_y = hat_fy * inv_nu_K2\n    \n    u_nr_x = np.real(np.fft.ifft2(hat_u_nr_x))\n    u_nr_y = np.real(np.fft.ifft2(hat_u_nr_y))\n    \n    norm_u_nr = np.sqrt(h**2 * (np.sum(u_nr_x**2) + np.sum(u_nr_y**2)))\n    C_nr = norm_u_nr / norm_grad_phi\n\n    # 8. Pressure-robust solution\n    # Project f_hat onto divergence-free subspace\n    k_dot_fhat = Kx * hat_fx + Ky * hat_fy\n    \n    hat_f_sol_x = hat_fx - Kx * k_dot_fhat * K2_inv\n    hat_f_sol_y = hat_fy - Ky * k_dot_fhat * K2_inv\n\n    hat_u_pr_x = hat_f_sol_x * inv_nu_K2\n    hat_u_pr_y = hat_f_sol_y * inv_nu_K2\n    \n    u_pr_x = np.real(np.fft.ifft2(hat_u_pr_x))\n    u_pr_y = np.real(np.fft.ifft2(hat_u_pr_y))\n    \n    norm_u_pr = np.sqrt(h**2 * (np.sum(u_pr_x**2) + np.sum(u_pr_y**2)))\n    C_pr = norm_u_pr / norm_grad_phi\n\n    return C_pr, C_nr\n\nsolve()\n```", "id": "3382167"}]}