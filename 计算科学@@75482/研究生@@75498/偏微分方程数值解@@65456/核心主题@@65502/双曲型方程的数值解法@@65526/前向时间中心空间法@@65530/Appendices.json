{"hands_on_practices": [{"introduction": "在我们深入编写复杂代码之前，理解数值方法的内在限制至关重要。本练习将通过一个具体的反例，清晰地展示当向前时间中心空间（FTCS）方法的稳定性条件被违反时会发生什么。通过简单的计算，你将亲眼看到一个完全非负的初始状态如何演化出物理上不可能出现的负值，从而深刻体会到数值稳定性的重要性。[@problem_id:3395792]", "problem": "考虑一维热方程（也称扩散方程），它定义在一个足够大的区域上，以至于在一个时间步长内边界效应可以忽略不计。该方程由以下偏微分方程给出：\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t),\n$$\n其中 $\\kappa0$ 是一个常数扩散系数。前向时间中心空间（Forward-Time Central-Space, FTCS）方法在均匀网格上定义了一个有限差分格式，该网格的空间步长为 $h0$，时间步长为 $k0$，并在时间上使用前向差分，在空间上使用中心差分。在这种情况下，对显式格式的经典单调性要求是，离散更新映射必须是相邻值的凸组合。在实践中，这施加了一个涉及无量纲比率 $r=\\kappa k/h^{2}$ 的条件。\n\n构造一个反例，证明当 FTCS 更新违反单调性约束时，它可以在一个时间步内从非负初始数据产生虚假的负值。为此，取 $\\kappa=1$、$h=1$ 和 $k=1$，并考虑一个在网格上非负且紧支的初始条件，具体为\n$$\nu_{i}^{0} \\;=\\;\n\\begin{cases}\n1,  i=1,\\\\\n0,  i\\neq 1,\n\\end{cases}\n$$\n其中 $i\\in\\mathbb{Z}$ 是空间网格点的索引，$u_{i}^{n}$ 表示在空间索引 $i$ 和时间层 $n$ 处对 $u$ 的数值近似。在中心索引 $i=1$ 处应用一次 FTCS 更新，以获得 $u_{1}^{1}$。\n\n计算 $u_{1}^{1}$ 的值。你的最终答案必须是一个实数。无需四舍五入，也无需报告物理单位。从有限差分近似热方程的基本原理和核心定义出发解释你的推理过程，并阐明为什么当约束被违反时，这个显式计算构成了一个关于单调性的反例。", "solution": "问题要求我们使用前向时间中心空间（FTCS）方法，计算一维热方程数值解在一个时间步之后的值，其中所选参数特意违反了该格式的单调性条件。然后我们必须阐明为什么这个结果构成了一个反例。\n\n控制偏微分方程（PDE）是热方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n其中 $u(x,t)$ 代表在空间位置 $x$ 和时间 $t$ 的某个量（例如温度），$\\kappa  0$ 是常数扩散系数。\n\nFTCS 方法在一个均匀网格上离散化此 PDE，其中 $x_i = i h$，$t_n = n k$，$h$ 是空间步长，$k$ 是时间步長。对 $u(x_i, t_n)$ 的数值近似记为 $u_i^n$。\n\n为了构造 FTCS 格式，我们使用有限差分来近似导数：\n1. 在 $(x_i, t_n)$ 处的时间导数 $\\frac{\\partial u}{\\partial t}$ 用一阶前向差分来近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_i^{n+1} - u_i^n}{k}\n$$\n2. 在 $(x_i, t_n)$ 处的空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 用二阶中心差分来近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n将这些近似代入热方程，得到 FTCS 有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{k} = \\kappa \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n这是一个显式格式，因为我们可以根据当前时间层 $n$ 的已知值来求解下一个时间层的未知值 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\kappa k}{h^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n我们定义无量纲扩散数，或称网格比，为 $r = \\frac{\\kappa k}{h^2}$。更新规则可以重写为：\n$$\nu_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n通过组合时间层 $n$ 上对应空间网格点的项，我们得到：\n$$\nu_i^{n+1} = r u_{i-1}^n + (1 - 2r) u_i^n + r u_{i+1}^n\n$$\n物理上的热方程遵循极值原理，这意味着对于非负的初始数据，解在所有未来时间都保持非负。如果一个数值格式保留了这一性质，则称其为单调的。对于 FTCS 格式，如果更新规则中 $u_i^{n+1}$ 的所有系数都是非负的，则其单调性得到保证。由于 $\\kappa, k, h$ 都是正数，所以 $r  0$。因此，单调性条件简化为要求 $u_i^n$ 的系数为非负：\n$$\n1 - 2r \\ge 0 \\implies 2r \\le 1 \\implies r \\le \\frac{1}{2}\n$$\n因此，FTCS 格式的单调性（以及 von Neumann 稳定性）条件是 $r = \\frac{\\kappa k}{h^2} \\le \\frac{1}{2}$。\n\n问题指定的参数值意在违反此条件。给定的值为：\n- 扩散系数：$\\kappa = 1$\n- 空间步长：$h = 1$\n- 时间步长：$k = 1$\n\n使用这些值，网格比 $r$ 为：\n$$\nr = \\frac{\\kappa k}{h^2} = \\frac{1 \\cdot 1}{1^2} = 1\n$$\n由于 $r=1$，条件 $r \\le \\frac{1}{2}$ 被违反。我们预期该格式会表现出非物理行为。对于这一特定的参数选择，更新规则变为：\n$$\nu_i^{n+1} = (1) u_{i-1}^n + (1 - 2(1)) u_i^n + (1) u_{i+1}^n = u_{i-1}^n - u_i^n + u_{i+1}^n\n$$\n问题要求我们计算 $u_1^1$，即在一个时间步（$n=0 \\to n=1$）后，空间索引 $i=1$ 处的值。使用 $i=1$ 和 $n=0$ 的推导出的更新规则：\n$$\nu_1^1 = u_{1-1}^0 - u_1^0 + u_{1+1}^0 = u_0^0 - u_1^0 + u_2^0\n$$\n初始条件以离散狄拉克函数的形式给出：\n$$\nu_i^0 =\n\\begin{cases}\n1,  i=1, \\\\\n0,  i\\neq 1.\n\\end{cases}\n$$\n根据此初始条件，我们有：\n- $u_1^0 = 1$\n- $u_0^0 = 0$（因为 $0 \\neq 1$）\n- $u_2^0 = 0$（因为 $2 \\neq 1$）\n\n将这些值代入 $u_1^1$ 的表达式中：\n$$\nu_1^1 = 0 - 1 + 0 = -1\n$$\n这个结果构成了一个明确的反例。初始数据 $u_i^0$ 在网格上处处非负。然而，经过一个时间步后，网格点 $i=1$ 处的数值解变为 $u_1^1 = -1$，这是一个负值。对于一个扩散过程来说，这是一个物理上不可能的结果，因为它只应平滑初始分布，而不能创造新的极小值或极大值。从非负初始数据生成负值是违反单调性条件 $r \\le 1/2$ 的直接后果。当 $r  1/2$ 时，更新模板中 $u_i^n$ 的负系数导致了这种非物理行为。", "answer": "$$\n\\boxed{-1}\n$$", "id": "3395792"}, {"introduction": "在理解了稳定性的重要性之后，现在是时候将理论付诸实践了。本练习将指导你从零开始构建一个完整且稳健的 FTCS 求解器，用于求解一维热传导方程。你将实践从离散化、实现关键的稳定性检查，到最终与解析解进行比较以验证代码正确性的全过程，这些都是计算科学家的核心技能。[@problem_id:3395765]", "problem": "考虑定义在有限区间上的具有固定狄利克雷边界条件的一维扩散（热）方程，其偏微分方程为 $u_t = \\alpha\\,u_{xx}$，其中 $x \\in [0,L]$ 且 $t \\ge 0$，边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$。需要从第一性原理出发，推导并实现前向时间中心空间（FTCS）方法。您必须设计一个算法，该算法对空间网格（包括边界节点）使用连续的一维内存布局，对内部网格点的空间更新进行矢量化，并选择一个时间步长以强制满足可证明的扩散问题FTCS稳定性要求。该算法必须通过将数值解与一族初始数据的已知解析解进行比较来验证其正确性，这些初始数据是带有狄利克雷边界条件的拉普拉斯算子的特征函数。您的推导必须从控制方程 $u_t = \\alpha\\,u_{xx}$ 和均匀空间网格的定义开始，并且不得依赖任何快捷公式。您必须解释为什么会出现稳定性限制，以及如何在算法上强制执行它。不需要物理单位；将所有量视为无量纲量。\n\n您需要实现一个完整的程序，该程序：\n- 在 $[0,L]$ 上构建一个包含 $N_x$ 个点的均匀网格，网格间距为 $\\Delta x = L/(N_x - 1)$。\n- 使用一个连续的一维数组来存储所有网格点（包括索引为 $i = 0$ 和 $i = N_x - 1$ 的边界点）上的 $u(x_i,t_n)$。\n- 在每个时间步，通过对索引切片 $i = 1,2,\\dots,N_x-2$ 进行矢量化的内部更新来应用FTCS格式。\n- 选择时间步长 $\\Delta t$ 以确保无量纲FTCS比率 $r$ 遵守扩散FTCS稳定性判据 $r \\le 1/2$。\n- 通过迭代时间步进更新，将解从 $t=0$ 演化到指定的最终时间 $T$。\n- 使用初始条件 $u(x,0) = \\sin(n\\pi x)$（其中 $n=1$ 或 $n=2$），在齐次狄利克雷边界条件下，该初始条件对应的解析解为 $u(x,t) = e^{-\\alpha (n\\pi)^2 t}\\,\\sin(n\\pi x)$。\n- 在最终时间，通过将数值解与解析解在内部网格点上进行比较，计算离散 $L^2$ 误差，公式为 $\\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N}-u(x_i,T)\\right)^2}$，其中 $u_i^{N}$ 是在网格索引 $i$ 上的最终时间数值近似解。\n\n您的程序必须实现以下测试套件，参数以元组 $(\\alpha, L, N_x, T, \\Delta t_{\\text{nom}}, n)$ 的形式给出：\n- 案例1（理想路径）：$(0.1,\\,1,\\,101,\\,0.05,\\,0.0002,\\,1)$\n- 案例2（通过选择达到稳定性边界 r=1/2）：$(0.1,\\,1,\\,51,\\,0.05,\\,1.0,\\,2)$\n- 案例3（名义$\\Delta t$违反稳定性，强制选择）：$(1.0,\\,1,\\,21,\\,0.02,\\,0.01,\\,1)$\n- 案例4（最少内部点的边缘案例， $N_x=3$）：$(0.5,\\,1,\\,3,\\,0.5,\\,1.0,\\,1)$\n\n对于每个案例，您的程序必须：\n- 选择 $\\Delta t$ 以强制执行 FTCS 稳定性条件 $r \\le 1/2$，\n- 使用带有矢量化内部更新的 FTCS 方法将解从 $t=0$ 演化到 $t=T$，\n- 使用具有相同参数 $n$ 的解析解计算在时间 $T$ 时的离散 $L^2$ 误差，\n- 报告最终的离散 $L^2$ 误差和实际使用的 $r$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{error}_1, r_1, \\text{error}_2, r_2, \\text{error}_3, r_3, \\text{error}_4, r_4]$，其中每个 $\\text{error}_k$ 是一个浮点数，每个 $r_k$ 是案例 $k$ 中使用的无量纲FTCS比率的浮点值。\n\n所有结果均不带任何物理单位。不涉及角度。所有值都以普通十进制数表示（不使用百分比）。", "solution": "本问题要求推导并实现前向时间中心空间（FTCS）数值方法，以求解一维扩散方程（也称为热方程）。解必须通过与已知解析解的对比进行验证，并且该格式的数值稳定性必须在算法上得到强制执行。\n\n### 步骤1：FTCS格式的推导\n\n一维扩散的控制偏微分方程（PDE）是：\n$$\nu_t = \\alpha \\, u_{xx}\n$$\n其中 $u(x,t)$ 是作为空间位置 $x$ 和时间 $t$ 函数的我们关心的量（例如温度），而 $\\alpha$ 是常数热扩散系数。问题定义在有限空间域 $x \\in [0, L]$上，具有齐次狄利克雷边界条件：\n$$\nu(0, t) = 0 \\quad \\text{和} \\quad u(L, t) = 0 \\quad \\text{对所有 } t \\ge 0\n$$\n\n为了数值求解此PDE，我们将连续域 $(x, t)$ 离散化为一个离散网格。我们定义一个包含 $N_x$ 个点的均匀空间网格，网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N_x-1$。空间步长为 $\\Delta x = L / (N_x - 1)$。时间也被离散化为步长 $t_n = n \\Delta t$，其中 $n = 0, 1, 2, \\dots$，时间步长 $\\Delta t$ 为常数。我们将网格点上解的数值近似表示为 $u_i^n \\approx u(x_i, t_n)$。\n\nFTCS方法使用有限差分来近似时间和空间导数。\n- 在 $(x_i, t_n)$ 处的时间导数 $u_t$ 使用时间上的一阶精度**前向差分**进行近似：\n$$\nu_t \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_i, t_{n+1}) - u(x_i, t_n)}{\\Delta t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- 在 $(x_i, t_n)$ 处的空间二阶导数 $u_{xx}$ 使用空间上的二阶精度**中心差分**进行近似：\n$$\nu_{xx} \\bigg|_{(x_i, t_n)} \\approx \\frac{u(x_{i+1}, t_n) - 2u(x_i, t_n) + u(x_{i-1}, t_n)}{(\\Delta x)^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n\n将这些近似代入控制PDE，我们得到FTCS有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\n这个方程是一个显式格式，因为新时间步的未知值 $u_i^{n+1}$ 可以直接从当前时间步 $n$ 的已知值计算出来。为了使更新规则更清晰，我们求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\n习惯上定义无量纲参数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$，通常称为FTCS比率或扩散问题的库朗数。更新规则简化为：\n$$\nu_i^{n+1} = u_i^n + r \\left( u_{i+1}^n - 2u_i^n + u_{i-1}^n \\right)\n$$\n此更新应用于所有内部网格点，即 $i = 1, 2, \\dots, N_x-2$。边界点 $u_0^{n+1}$ 和 $u_{N_x-1}^{n+1}$ 由狄利克雷边界条件固定为 $0$。\n\n### 步骤2：数值稳定性\n\n用于扩散方程的FTCS格式只是条件稳定的。不稳定性会导致小的初始误差（如舍入误差）指数级增长，从而使数值解变得毫无意义。A von Neumann 稳定性分析揭示了稳定性约束。我们寻求形如 $u_i^n = G^n e^{j k x_i}$ 的解，其中 $G$ 是波数为 $k$ 的傅里叶模态在每个时间步的放大因子，且 $j = \\sqrt{-1}$。对于一个稳定的格式，对所有可能的波数，放大因子的幅值都不能超过1，即 $|G| \\le 1$。\n\n将这种形式代入FTCS更新规则，得到：\n$$\nG = 1 + r (e^{j k \\Delta x} - 2 + e^{-j k \\Delta x})\n$$\n使用 Euler 恒等式 $e^{j\\theta} + e^{-j\\theta} = 2\\cos(\\theta)$，上式变为：\n$$\nG = 1 + 2r(\\cos(k \\Delta x) - 1)\n$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到：\n$$\nG = 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n稳定性条件 $|G| \\le 1$ 转换为 $-1 \\le 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$。\n- 右侧不等式，$1 - 4r \\sin^2(\\dots) \\le 1$，意味着 $-4r \\sin^2(\\dots) \\le 0$，因为 $r \\ge 0$ 且 $\\sin^2(\\dots) \\ge 0$，所以这个不等式总是成立的。\n- 左侧不等式，$-1 \\le 1 - 4r \\sin^2(\\dots)$，是关键的约束条件。它要求 $4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 2$，即 $r \\le \\frac{1}{2 \\sin^2(k \\Delta x/2)}$。\n这个条件必须对所有波数 $k$ 都成立。最严格的（最坏情况）场景发生在 $\\sin^2(k \\Delta x/2)$ 取其最大值1时。这导出了稳定性判据：\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2}\n$$\n\n### 步骤3：算法实现\n\n该算法旨在强制执行此稳定性条件并执行FTCS格式。\n\n1.  **网格与参数设置：** 对于给定的 $\\alpha$、 $L$ 和 $N_x$，计算空间步长 $\\Delta x = L/(N_x - 1)$。\n2.  **时间步长选择：** 为保证稳定性，时间步长 $\\Delta t$ 的选择必须满足 $r \\le 1/2$。允许的最大时间步长为 $\\Delta t_{\\text{max}} = \\frac{1}{2}\\frac{(\\Delta x)^2}{\\alpha}$。问题提供了一个名义时间步长 $\\Delta t_{\\text{nom}}$。算法必须选择一个候选时间步长 $\\Delta t_{\\text{cand}} = \\min(\\Delta t_{\\text{nom}}, \\Delta t_{\\text{max}})$，以同时满足用户的偏好（如果稳定）和稳定性要求。总仿真时间为 $T$。为确保仿真在时间 $T$ 准时结束，步数计算为 $N_t = \\lceil T / \\Delta t_{\\text{cand}} \\rceil$，实际使用的时间步长设置为 $\\Delta t = T / N_t$。此过程保证了 $\\Delta t \\le \\Delta t_{\\text{cand}} \\le \\Delta t_{\\text{max}}$，从而满足稳定性。\n3.  **初始化：** 创建一个大小为 $N_x$ 的一维数组 `u`。用初始条件 $u(x,0) = \\sin(n\\pi x/L)$ 对其进行初始化。网格坐标 $x_i$ 可以使用 `np.linspace(0, L, Nx)` 生成。由于这个初始条件的特殊选择，边界值 $u[0]$ 和 $u[N_x-1]$ 将为零，并将在计算中保持为零。\n4.  **时间演化：** 迭代 $N_t$ 次。在每一步中，根据 $t_n$ 时刻的解计算 $t_{n+1}$ 时刻的解。这是通过对内部点进行矢量化更新来完成的。对于代表 $t_n$ 时刻解的数组 `u`， $t_{n+1}$ 时刻解的内部点计算如下：\n    `u[1:-1] = u[1:-1] + r * (u[2:] - 2*u[1:-1] + u[:-2])`。\n    NumPy会先计算整个右侧表达式，基于旧的 `u` 值创建一个临时数组，然后将结果赋给切片 `u[1:-1]`。这正确地实现了显式更新，避免了数据竞争。边界值 `u[0]` 和 `u[-1]` 保持为 $0$。\n5.  **解析解与误差：** 给定的初始条件 $u(x,0) = \\sin(n\\pi x/L)$ 是扩散算子 $\\alpha \\frac{\\partial^2}{\\partial x^2}$ 在区间 $[0, L]$ 上带有齐次狄利克雷边界条件的特征函数。对应的特征值为 $\\lambda_n = \\alpha (n\\pi/L)^2$。因此，解析解为：\n    $$\n    u(x,t) = e^{-\\lambda_n t} u(x,0) = e^{-\\alpha (n\\pi/L)^2 t} \\sin(n\\pi x/L)\n    $$\n    对于 $L=1$ 的测试案例，这简化为 $u(x,t) = e^{-\\alpha (n\\pi)^2 t} \\sin(n\\pi x)$。在最终时间 $T$，我们在网格上计算这个解析解。\n6.  **误差计算：** 最终数值解 $u_i^{N_t}$ 和解析解 $u(x_i, T)$ 之间的离散 $L^2$ 误差是根据内部点（$i=1, \\dots, N_x-2$）使用所提供的公式计算的：\n    $$\n    \\|e\\|_2 \\approx \\sqrt{\\Delta x \\sum_{i=1}^{N_x-2} \\left(u_i^{N_t} - u(x_i, T)\\right)^2}\n    $$\n这个过程按照要求系统地推导、实现并验证了FTCS方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward-Time Central-Space (FTCS) method for the 1D diffusion\n    equation and computes the L2 error against an analytical solution for a\n    suite of test cases.\n    \"\"\"\n    # Test cases defined as tuples: (alpha, L, Nx, T, dt_nom, n)\n    test_cases = [\n        (0.1, 1.0, 101, 0.05, 0.0002, 1),\n        (0.1, 1.0, 51, 0.05, 1.0, 2),\n        (1.0, 1.0, 21, 0.02, 0.01, 1),\n        (0.5, 1.0, 3, 0.5, 1.0, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha, L, Nx, T, dt_nom, n = case\n\n        # Step 1: Grid and Parameter Setup\n        dx = L / (Nx - 1)\n        x = np.linspace(0, L, Nx)\n\n        # Step 2: Time Step Selection to enforce stability\n        # Calculate the maximum time step allowed by the stability criterion r = 0.5\n        # r = alpha * dt / dx**2  =>  dt = 0.5 * dx**2 / alpha\n        dt_stable_max = 0.5 * dx**2 / alpha\n\n        # Choose a candidate dt that respects both the nominal value and stability\n        # If dt_nom is already stable, use it. Otherwise, use the max stable dt.\n        dt_candidate = min(dt_nom, dt_stable_max)\n        \n        # Calculate the number of steps to reach final time T.\n        # np.ceil ensures we simulate for at least time T.\n        # The number of steps must be at least 1 if T > 0.\n        if T > 0:\n            num_steps = int(np.ceil(T / dt_candidate))\n        else:\n            num_steps = 0\n            \n        # Recalculate the actual dt to land exactly on T\n        dt = T / num_steps if num_steps > 0 else 0\n        \n        # Calculate the final stability ratio 'r' used in the simulation\n        r = alpha * dt / dx**2\n\n        # Step 3: Initialization\n        # Set the initial condition u(x,0) = sin(n*pi*x/L)\n        u = np.sin(n * np.pi * x / L)\n        # The homogeneous Dirichlet boundary conditions u[0]=0 and u[-1]=0 are\n        # automatically satisfied by the initial condition at x=0 and x=L.\n        # They will be maintained throughout the simulation.\n\n        # Step 4: Time Evolution using vectorized FTCS update\n        for _ in range(num_steps):\n            # The FTCS update rule for interior points is:\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - 2*u_i^n + u_{i-1}^n)\n            # This is vectorized using NumPy slices. NumPy evaluates the entire\n            # RHS first based on the old state of `u`, creating a temporary\n            # array, which is then assigned to the LHS slice. This correctly\n            # implements the explicit scheme.\n            u[1:-1] = u[1:-1] + r * (u[2:] - 2 * u[1:-1] + u[0:-2])\n            # Boundary conditions u[0]=0 and u[-1]=0 are preserved.\n\n        # At this point, `u` contains the final numerical solution.\n\n        # Step 5: Analytical Solution\n        # For the IC u(x,0) = sin(n*pi*x/L), the analytical solution is\n        # u(x,t) = exp(-alpha * (n*pi/L)^2 * t) * sin(n*pi*x/L)\n        eigenvalue = alpha * (n * np.pi / L)**2\n        u_analytical = np.exp(-eigenvalue * T) * np.sin(n * np.pi * x / L)\n\n        # Step 6: Error Calculation\n        # The discrete L2 error is computed over interior points only.\n        u_numerical_interior = u[1:-1]\n        u_analytical_interior = u_analytical[1:-1]\n        \n        squared_errors = (u_numerical_interior - u_analytical_interior)**2\n        l2_error = np.sqrt(dx * np.sum(squared_errors))\n        \n        results.append(l2_error)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3395765"}, {"introduction": "编写一个能够运行的程序仅仅是第一步；分析其解的精度同样至关重要。本练习将引入理查森外推法（Richardson extrapolation），这是一种强大的数值分析技术，用于凭经验验证数值格式的收敛阶。通过将该方法应用于你构建的 FTCS 求解器，你将能够确认该方法在理论上具有的时间一阶和空间二阶精度，并学习如何量化和提升数值解的准确性。[@problem_id:3395832]", "problem": "考虑单位区间上具有齐次狄利克雷边界条件的一维热传导方程（也称为扩散方程），\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t),\\quad x\\in(0,1),\\ t\\in(0,T],\n$$\n数据为\n$$\nu(0,t)=0,\\quad u(1,t)=0,\\quad u(x,0)=\\sin(\\pi x),\\quad \\alpha=1.\n$$\n对于此问题，通过分离变量法可知其精确解为：\n$$\nu(x,t) = e^{-\\pi^2 t}\\,\\sin(\\pi x).\n$$\n任务是使用前向时间中心空间 (FTCS) 方法对该初边值问题进行离散化。根据定义，该方法在均匀网格上对 $u_t$ 使用时间前向有限差分，对 $u_{xx}$ 使用空间中心有限差分。您必须在适用于热传导方程的 FTCS 方法的柯朗-弗里德里希-列维 (CFL) 稳定性约束下，实现该显式格式。在所有时间步，直接在端点使用狄利克雷边界值。请勿使用任何隐式时间步进方法。\n\n您将对一组精心选择的网格应用 Richardson 外推法，以完成以下任务：\n- 估计在指定点上的精确解误差，\n- 验证 FTCS 方法在时间上的一阶精度和在空间上的二阶精度。\n\n所有计算必须以最终时间 $T = 0.01$（即 $T = 0.01$ 秒）为目标。空间和时间网格必须是均匀的，并且每次运行的时间推进必须在 $t=T$ 时刻以恒定的时间步长精确结束。\n\n使用的定义：\n- 前向时间中心空间 (FTCS) 方法在均匀网格上采用时间前向差分和空间中心差分。\n- 一维热传导方程的柯朗-弗里德里希-列维 (CFL) 数为 $\\lambda = \\alpha\\,\\Delta t/\\Delta x^2$。\n\n您必须实现以下测试套件。对于每个测试，使用上述精确解在指定位置评估参考值。\n\n测试 1（在固定的精细空间网格上通过 Richardson 方法确定时间阶）：\n- 域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 空间网格：选择 $N_x = 400$ 个均匀子区间，因此 $\\Delta x = 1/N_x$。\n- 选择目标 CFL 数 $\\lambda_0 = 0.4$ 并设置粗略时间步长 $\\Delta t_0 = \\lambda_0 \\Delta x^2$。\n- 以比率 $r_t=2$ 构建两个时间上的细化：$\\Delta t_1 = \\Delta t_0/2$，$\\Delta t_2 = \\Delta t_1/2$，确保对于 $i\\in\\{0,1,2\\}$，$T/\\Delta t_i$ 是一个整数。\n- 对三个时间步长中的每一个，使用相同的空间网格将 FTCS 格式演化至 $t=T$，并记录在空间位置 $x^\\star=0.5$ 处的数值解 $U_{\\Delta t_0}$、$U_{\\Delta t_1}$、$U_{\\Delta t_2}$。\n- 使用细化因子 $r_t=2$ 的 Richardson 外推法，从这三个近似值中估计观测到的时间阶 $p_t$。报告标量值 $p_t$ 并报告一个布尔值，断言 $|p_t-1|\\le 0.05$ 是否成立。\n\n测试 2（在 CFL 数接近常数的情况下通过 Richardson 方法确定空间阶）：\n- 域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 使用三个嵌套的空间网格，其中 $N_x\\in\\{50,100,200\\}$，因此 $\\Delta x_h=1/N_x$，$\\Delta x_{h/2} = \\Delta x_h/2$，$\\Delta x_{h/4}=\\Delta x_h/4$。\n- 对于每个空间网格，选择时间步数 $N_t$ 为 $N_t = \\left\\lceil T/(0.49\\,\\Delta x^2)\\right\\rceil$ 并取 $\\Delta t = T/N_t$，以使得到的 CFL 数满足 $\\lambda\\le 0.49$。\n- 在每个网格上将 FTCS 格式演化至 $t=T$，并记录在共同空间位置 $x^\\star=0.3$ 处的数值 $U_h$、$U_{h/2}$、$U_{h/4}$。\n- 使用细化因子 $r_x=2$ 的 Richardson 外推法，从这三个近似值中估计观测到的空间阶 $p_x$。报告标量值 $p_x$ 并报告一个布尔值，断言 $|p_x-2|\\le 0.1$ 是否成立。\n\n测试 3（使用两阶段 Richardson 外推法估计某点上的精确解）：\n- 域长度 $L=1$。\n- 最终时间 $T=0.01$。\n- 扩散系数 $\\alpha=1$。\n- 空间网格：粗网格 $N_x^{(c)}=50$ 和细网格 $N_x^{(f)}=100$。\n- 对于每个空间网格，独立地选择一个基准时间步数\n$$\nN_t^{(c)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(c)})^2}\\right\\rceil,\\quad N_t^{(f)}=\\left\\lceil \\frac{T}{0.4\\,(\\Delta x^{(f)})^2}\\right\\rceil,\n$$\n并定义细化后的步数 $2N_t^{(c)}$ 和 $2N_t^{(f)}$，以在固定的空间网格上生成减半的时间步长。\n- 对于每个空间网格，计算在 $t=T$ 时刻，时间步长分别为 $\\Delta t$ 和 $\\Delta t/2$ 的两个 FTCS 解，并使用细化因子 2 进行时间上的 Richardson 外推，以形成在粗、细空间网格上的时间外推近似值。然后，在空间上以细化因子 2 进行第二次 Richardson 外推（即，在时间外推的粗、细解之间进行），以获得在 $x^\\star=0.3$ 处 $u(x^\\star,T)$ 的两阶段外推估计值。\n- 计算该两阶段外推估计值相对于在 $(x^\\star,T)$ 处的精确解的绝对误差，并报告此标量误差。\n\n您的程序必须按以下顺序计算上述五个输出：\n1. 来自测试 1 的估计时间阶 $p_t$。\n2. 一个布尔值，说明 $|p_t-1|\\le 0.05$ 是否成立。\n3. 来自测试 2 的估计空间阶 $p_x$。\n4. 一个布尔值，说明 $|p_x-2|\\le 0.1$ 是否成立。\n5. 来自测试 3 的绝对误差。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$）。第一、三、五个条目必须是实数（浮点数），第二和第四个条目必须是布尔值。不应打印任何其他文本。", "solution": "该问题是有效的。这是一个适定的、科学上合理的数值分析练习，涉及将前向时间中心空间 (FTCS) 方法应用于一维热传导方程。所有参数和程序都定义清晰且一致。\n\n求解过程分三个阶段进行：首先，推导数值格式；其次，构建用于分析该格式精度的 Richardson 外推法；第三，逐步执行问题陈述中指定的三个计算测试。\n\n### 1. FTCS 离散化\n\n控制偏微分方程 (PDE) 是一维热传导方程：\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad x \\in (0, 1), \\ t \\in (0, T]\n$$\n其中扩散系数 $\\alpha=1$，最终时间 $T=0.01$，齐次狄利克雷边界条件 $u(0,t)=u(1,t)=0$，以及初始条件 $u(x,0)=\\sin(\\pi x)$。\n\n为了离散化该方程，我们在空间和时间上定义一个均匀网格。空间域 $[0,1]$ 被划分为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的子区间，得到网格点 $x_j = j \\Delta x$，其中 $j=0, 1, \\dots, N_x$。时间区间 $[0,T]$ 被划分为 $N_t$ 个时长为 $\\Delta t = T/N_t$ 的步，得到时间层 $t_n = n \\Delta t$，其中 $n=0, 1, \\dots, N_t$。设 $U_j^n$ 为精确解 $u(x_j, t_n)$ 的数值近似。\n\nFTCS 方法对时间导数使用前向差分，对空间导数使用二阶中心差分：\n$$\n\\frac{u(x_j, t_{n+1}) - u(x_j, t_n)}{\\Delta t} \\approx u_t(x_j, t_n)\n$$\n$$\n\\frac{u(x_{j-1}, t_n) - 2u(x_j, t_n) + u(x_{j+1}, t_n)}{\\Delta x^2} \\approx u_{xx}(x_j, t_n)\n$$\n将这些近似式代入偏微分方程，得到 FTCS 有限差分方程：\n$$\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} = \\alpha \\frac{U_{j+1}^n - 2U_j^n + U_{j-1}^n}{\\Delta x^2}\n$$\n重新整理以求解下一时间步的解 $U_j^{n+1}$，得到显式更新公式：\n$$\nU_j^{n+1} = U_j^n + \\alpha \\frac{\\Delta t}{\\Delta x^2} (U_{j+1}^n - 2U_j^n + U_{j-1}^n)\n$$\n将热传导方程的柯朗-弗里德里希-列维 (CFL) 数定义为 $\\lambda = \\alpha \\Delta t / \\Delta x^2$，该公式可以更紧凑地写为：\n$$\nU_j^{n+1} = \\lambda U_{j-1}^n + (1 - 2\\lambda)U_j^n + \\lambda U_{j+1}^n\n$$\n此更新规则应用于所有内部网格点 $j=1, 2, \\dots, N_x-1$。已知该格式仅在满足 CFL 条件 $\\lambda \\le 1/2$ 时才稳定。问题指定的 CFL 数为 $\\lambda=0.4$ 和 $\\lambda\\le0.49$，均在此稳定区域内。\n\n边界值在所有时间上都是固定的：对于所有 $n$，$U_0^n = 0$ 且 $U_{N_x}^n = 0$。数值解的初始状态由初始条件设定：对于 $j=0, 1, \\dots, N_x$，$U_j^0 = \\sin(\\pi x_j)$。\n\n### 2. Richardson 外推法\n\nRichardson 外推法是一种用于估计数值方法误差并获得更精确近似的技术。如果一个数值方法产生一个依赖于步长 $h$ 的近似值 A(h)，并且其误差展开式形式为 $A(h) = A_{\\text{exact}} + C h^p + O(h^{p+k})$（对于某个 $k0$），我们可以使用多次计算来分析此误差。\n\n**阶的估计：** 使用步长为 $h$、$h/r$ 和 $h/r^2$（其中 $r$ 是细化因子）计算出的三个近似值，观测到的收敛阶 $p$ 可以估计为：\n$$\np \\approx \\log_r \\left( \\frac{A(h) - A(h/r)}{A(h/r) - A(h/r^2)} \\right)\n$$\n**误差消除：** 使用两个近似值 $A(h)$ 和 $A(h/r)$，可以通过消除主导误差项来导出一个更精确的估计值 $A_{\\text{extra}}$：\n$$\nA_{\\text{extra}} = \\frac{r^p A(h/r) - A(h)}{r^p - 1}\n$$\n\n### 3. 执行测试套件\n\n基于推导出的更新规则实现一个 FTCS 求解器。然后使用该求解器执行三个测试。\n\n**测试 1：时间精度阶**\n目标是验证 FTCS 方法在时间上的一阶精度，即 $p_t=1$。空间网格固定为 $N_x=400$ 个子区间（$\\Delta x = 1/400$），这使得空间离散误差为常数且很小。使用连续细化的时间步长运行三次模拟直到时间 $T=0.01$。\n- 网格参数：$N_x = 400$。关注点为 $x^\\star=0.5$，对应于网格索引 $j=200$。\n- 时间步长：使用基础 CFL 数 $\\lambda_0 = 0.4$ 来定义一个粗略时间步长 $\\Delta t_0 = \\lambda_0 \\Delta x^2 = 0.4 \\times (1/400)^2$。这得到 $N_{t,0} = T/\\Delta t_0 = 4000$ 个时间步。再运行两次细化模拟，步数分别为 $N_{t,1} = 2N_{t,0} = 8000$ 和 $N_{t,2} = 4N_{t,0} = 16000$。细化因子为 $r_t=2$。\n- 设 $U_{\\Delta t_0}$、$U_{\\Delta t_1}$、$U_{\\Delta t_2}$ 分别为三种时间步长下在 $x^\\star=0.5$ 处的数值解。使用 $r=2$ 的阶估计公式计算观测到的时间阶 $p_t$：\n$$\np_t = \\log_2 \\left( \\frac{U_{\\Delta t_0} - U_{\\Delta t_1}}{U_{\\Delta t_1} - U_{\\Delta t_2}} \\right)\n$$\n$p_t$ 的值预期接近 $1$。检查条件 $|p_t-1|\\le 0.05$ 是否满足。\n\n**测试 2：空间精度阶**\n目标是验证空间上的二阶精度，即 $p_x=2$。在 $N_x \\in \\{50, 100, 200\\}$ 的嵌套空间网格上运行三次模拟，因此细化因子为 $r_x=2$。关注点为 $x^\\star=0.3$，在各个网格上分别对应于索引 $j \\in \\{15, 30, 60\\}$。\n- 为分离空间误差，通过选择足够小的 $\\Delta t$ 使其与 $\\Delta x^2$ 成正比，从而抑制时间误差的贡献。对于每个网格，时间步数设置为 $N_t = \\lceil T/(0.49 \\Delta x^2) \\rceil$，保持 $\\lambda \\le 0.49$。对于粗、中、细网格，这分别得到 $N_t$ 值为 52、205 和 817。\n- 设 $U_h$、$U_{h/2}$、$U_{h/4}$ 为在 $x^\\star=0.3$ 处的数值解。计算观测到的空间阶 $p_x$：\n$$\np_x = \\log_2 \\left( \\frac{U_h - U_{h/2}}{U_{h/2} - U_{h/4}} \\right)\n$$\n$p_x$ 的值预期接近 $2$。检查条件 $|p_x-2|\\le 0.1$ 是否满足。\n\n**测试 3：两阶段 Richardson 外推法**\n此测试演示了通过依次在时间和空间上进行外推来提高解的精度。\n- **阶段 1（时间外推）：**\n    - 在粗空间网格（$N_x^{(c)}=50$）上，分别使用 $N_t = 63$ 和 $N_t = 126$ 个时间步，计算在 $x^\\star=0.3$ 处的两个解 $A_{c,1}$ 和 $A_{c,2}$。使用 $p=1$ 和 $r=2$ 计算时间外推值 $A_c^{\\text{extra}}$：$A_c^{\\text{extra}} = 2A_{c,2} - A_{c,1}$。\n    - 在细空间网格（$N_x^{(f)}=100$）上，使用 $N_t = 250$ 和 $N_t = 500$ 个时间步计算在 $x^\\star=0.3$ 处的两个解 $A_{f,1}$ 和 $A_{f,2}$。计算时间外推值 $A_f^{\\text{extra}}$：$A_f^{\\text{extra}} = 2A_{f,2} - A_{f,1}$。\n- **阶段 2（空间外推）：**\n    - 两个时间外推解 $A_c^{\\text{extra}}$（在步长为 $\\Delta x^{(c)}$ 的网格上）和 $A_f^{\\text{extra}}$（在步长为 $\\Delta x^{(f)} = \\Delta x^{(c)}/2$ 的网格上），它们本身被视为其主导误差为空间误差且阶为 $p=2$ 的近似值。使用 $p=2$ 和 $r=2$ 的空间 Richardson 外推法计算最终的更高精度估计值 $A^{\\text{final}}$：\n    $$\n    A^{\\text{final}} = \\frac{2^2 A_f^{\\text{extra}} - A_c^{\\text{extra}}}{2^2 - 1} = \\frac{4A_f^{\\text{extra}} - A_c^{\\text{extra}}}{3}\n    $$\n- **误差计算：** 计算此两阶段外推值相对于在 $x^\\star=0.3$ 和 $T=0.01$ 处的精确解 $u(x^\\star, T) = e^{-\\pi^2 T} \\sin(\\pi x^\\star)$ 的绝对误差。此误差是该测试的最终报告值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ftcs_solver(L, T, alpha, Nx, Nt):\n    \"\"\"\n    Solves the 1D heat equation u_t = alpha * u_xx with homogeneous Dirichlet BCs\n    using the Forward-Time Central-Space (FTCS) method.\n\n    Args:\n        L (float): Domain length.\n        T (float): Final time.\n        alpha (float): Diffusion coefficient.\n        Nx (int): Number of spatial subintervals.\n        Nt (int): Number of time steps.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The spatial grid points.\n            - np.ndarray: The numerical solution U at the final time T.\n    \"\"\"\n    dx = L / Nx\n    dt = T / Nt\n    lam = alpha * dt / dx**2\n\n    # As per the problem, all lambda values are within the stability limit.\n    # if lam > 0.5:\n    #     raise ValueError(\"Stability condition violated: lambda > 0.5\")\n\n    x = np.linspace(0, L, Nx + 1)\n    \n    # Initial condition\n    U = np.sin(np.pi * x / L)\n\n    # Time-marching loop\n    for _ in range(Nt):\n        U_old = U.copy()\n        # Vectorized update for interior points\n        U[1:-1] = U_old[1:-1] + lam * (U_old[0:-2] - 2 * U_old[1:-1] + U_old[2:])\n        # BCs u(0,t)=0 and u(L,t)=0 are maintained as U[0] and U[Nx] are not updated.\n    \n    return x, U\n\ndef solve():\n    \"\"\"\n    Executes the three tests described in the problem statement and prints the results.\n    \"\"\"\n    # Common parameters\n    L = 1.0\n    T = 0.01\n    alpha = 1.0\n\n    # --- Test 1: Temporal Order of Accuracy ---\n    Nx_t = 400\n    x_star_t = 0.5\n    idx_t = int(x_star_t * Nx_t / L)\n    \n    dx_t = L / Nx_t\n    lam0_t = 0.4\n    dt0_t = lam0_t * dx_t**2\n    \n    Nt0_t = int(round(T / dt0_t))\n    Nt1_t = 2 * Nt0_t\n    Nt2_t = 4 * Nt0_t\n    \n    _, U0_t = ftcs_solver(L, T, alpha, Nx_t, Nt0_t)\n    _, U1_t = ftcs_solver(L, T, alpha, Nx_t, Nt1_t)\n    _, U2_t = ftcs_solver(L, T, alpha, Nx_t, Nt2_t)\n    \n    sol_0 = U0_t[idx_t]\n    sol_1 = U1_t[idx_t]\n    sol_2 = U2_t[idx_t]\n    \n    # Richardson extrapolation for order p\n    ratio_t = (sol_0 - sol_1) / (sol_1 - sol_2)\n    p_t = np.log2(ratio_t)\n    is_pt_valid = abs(p_t - 1.0) = 0.05\n\n    # --- Test 2: Spatial Order of Accuracy ---\n    x_star_x = 0.3\n    Nx_vals_x = [50, 100, 200]\n    sols_x = []\n\n    for Nx in Nx_vals_x:\n        dx = L / Nx\n        # Calculate Nt to keep lambda = 0.49\n        Nt = int(np.ceil(T / (0.49 * dx**2)))\n        idx = int(x_star_x * Nx / L)\n        \n        _, U = ftcs_solver(L, T, alpha, Nx, Nt)\n        sols_x.append(U[idx])\n\n    ratio_x = (sols_x[0] - sols_x[1]) / (sols_x[1] - sols_x[2])\n    p_x = np.log2(ratio_x)\n    is_px_valid = abs(p_x - 2.0) = 0.1\n\n    # --- Test 3: Two-Stage Richardson Extrapolation ---\n    x_star_e = 0.3\n\n    # Coarse spatial grid calculations\n    Nx_c = 50\n    dx_c = L / Nx_c\n    idx_c = int(x_star_e * Nx_c / L)\n    Nt_c1 = int(np.ceil(T / (0.4 * dx_c**2)))\n    Nt_c2 = 2 * Nt_c1\n    _, U_c1 = ftcs_solver(L, T, alpha, Nx_c, Nt_c1)\n    _, U_c2 = ftcs_solver(L, T, alpha, Nx_c, Nt_c2)\n    sol_c1 = U_c1[idx_c]\n    sol_c2 = U_c2[idx_c]\n    # Time extrapolation (p=1, r=2)\n    sol_c_extra = (2.0 * sol_c2 - sol_c1)\n\n    # Fine spatial grid calculations\n    Nx_f = 100\n    dx_f = L / Nx_f\n    idx_f = int(x_star_e * Nx_f / L)\n    Nt_f1 = int(np.ceil(T / (0.4 * dx_f**2)))\n    Nt_f2 = 2 * Nt_f1\n    _, U_f1 = ftcs_solver(L, T, alpha, Nx_f, Nt_f1)\n    _, U_f2 = ftcs_solver(L, T, alpha, Nx_f, Nt_f2)\n    sol_f1 = U_f1[idx_f]\n    sol_f2 = U_f2[idx_f]\n    # Time extrapolation (p=1, r=2)\n    sol_f_extra = (2.0 * sol_f2 - sol_f1)\n\n    # Space extrapolation (p=2, r=2)\n    sol_final = (4.0 * sol_f_extra - sol_c_extra) / 3.0\n\n    # Exact solution\n    u_exact = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x_star_e / L)\n\n    # Absolute error of the two-stage extrapolated estimate\n    error_e = abs(sol_final - u_exact)\n\n    # Final results assembly\n    results = [p_t, is_pt_valid, p_x, is_px_valid, error_e]\n\n    # Print in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3395832"}]}