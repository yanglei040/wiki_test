{"hands_on_practices": [{"introduction": "在将数值方法应用于复杂系统之前，我们必须确保其实现是正确的。标量测试问题 $y' = \\lambda y$ 是验证时间积分器两个最重要特性——准确性和稳定性的基本基准。本练习 [@problem_id:3455040] 提供了一个系统性的框架，用于执行这一至关重要的验证过程，从推导核心属性到凭经验测量其性能。", "problem": "设计并实现一个验证程序，用于验证应用于标量线性测试问题 $y' = \\lambda y$ 的通用 $\\theta$ 方法。目的是确认给定实现的观测精度阶和线性稳定性行为。验证必须基于第一性原理，并且除了下面给出的核心定义外，不得依赖任何预先给定的专门公式。\n\n从以下基本基础开始：\n- 常微分方程初值问题的定义：给定 $y' = f(t,y)$ 和 $y(0) = y_0$，在时间 $t$ 的精确解表示为 $y(t)$。\n- 用于时间积分的通用单步 $\\theta$ 方法通过使用参数 $\\theta \\in [0,1]$，对步长开始和结束时的右侧项进行凸组合，从时间 $t_n$推进到 $t_{n+1} = t_n + h$。\n- 标量线性测试问题 $y' = \\lambda y$（其中常数 $\\lambda \\in \\mathbb{C}$）的精确解为 $y(t) = y_0 \\exp(\\lambda t)$。\n\n你的任务：\n1) 从 $\\theta$ 方法的定义出发，推导其应用于标量线性测试问题 $y'=\\lambda y$ 时的更新规则，并求解出用 $y_n$、时间步长 $h$ 和 $\\theta$ 表示的 $y_{n+1}$。根据该推导，确定作为 $z = h \\lambda$ 的函数的单步放大因子。\n2) 使用泰勒级数和局部截断误差的定义，确定 $\\theta$ 方法作为 $\\theta$ 的函数的形式精度阶。解释为什么对于足够光滑的解，并且在线性稳定性区域内，当 $\\theta \\neq \\tfrac{1}{2}$ 时预期为一阶方法，而当 $\\theta = \\tfrac{1}{2}$ 时预期为二阶方法。\n3) 如下定义并根据数值实验计算经验观测精度阶。对于固定的最终时间 $T$、初始条件 $y_0$ 和参数集 $(\\theta,\\lambda)$，令 $N = T/h$ 为一个整数，并令 $N$ 步后的数值解为 $y_N$。定义全局误差 $E(h) = |y_N - y(T)|$。给定三个步长 $h_1 > h_2 > h_3$，定义成对观测阶\n$$\np_{12} = \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)}, \\quad p_{23} = \\frac{\\log(E(h_2)/E(h_3))}{\\log(h_2/h_3)},\n$$\n并将平均值 $\\tfrac{1}{2}(p_{12}+p_{23})$ 作为该参数集的观测阶报告。所有对数均为自然对数。\n4) 对于给定的 $(\\theta,\\lambda,h)$，通过单步放大因子的模小于或等于 $1$ 的准则来定义和计算线性稳定性。\n5) 精确地（无迭代地）实现用于标量线性问题的 $\\theta$ 方法，并使用精确解 $y(t) = y_0 \\exp(\\lambda t)$，在以下测试套件上验证观测阶和稳定性准则。对于所有测试，取 $y_0 = 1$。\n\n观测阶测试（使用 $T = 1$ 和三个步长 $h_1 = 1/20$、$h_2 = 1/40$、$h_3 = 1/80$；报告每个观测阶，四舍五入到三位小数）：\n- 测试 $\\mathbf{A_1}$：$\\theta = 0$，$\\lambda = -1$。\n- 测试 $\\mathbf{A_2}$：$\\theta = 1/2$，$\\lambda = -1$。\n- 测试 $\\mathbf{A_3}$：$\\theta = 1$，$\\lambda = -1$。\n\n稳定性测试（使用线性放大因子准则 $|R(z)| \\le 1$（其中 $z = h \\lambda$）报告一个布尔值）：\n- 测试 $\\mathbf{S_1}$：$\\theta = 0$，$\\lambda = -1$，$h = 1$。\n- 测试 $\\mathbf{S_2}$：$\\theta = 0$，$\\lambda = -1$，$h = 3$。\n- 测试 $\\mathbf{S_3}$：$\\theta = 1/2$，$\\lambda = -1$，$h = 100$。\n- 测试 $\\mathbf{S_4}$：$\\theta = 1$，$\\lambda = -1$，$h = 100$。\n- 测试 $\\mathbf{S_5}$：$\\theta = 1/2$，$\\lambda = \\mathrm{i}\\,10$，$h = 0.1$，其中 $\\mathrm{i}^2 = -1$。\n- 测试 $\\mathbf{S_6}$：$\\theta = 0$，$\\lambda = \\mathrm{i}\\,10$，$h = 0.1$。\n\n你的程序必须：\n- 精确实现标量问题的 $\\theta$ 方法更新。\n- 使用指定的步长计算三个观测阶测试的观测阶，并将每个结果四舍五入到三位小数。\n- 使用放大因子模准则计算六个稳定性布尔值。\n- 生成单行输出，其中包含一个逗号分隔的 Python 列表形式的结果，顺序如下：\n  $[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{S}_5,\\text{S}_6]$，\n  其中 $\\text{A}_k$ 是四舍五入到三位小数的浮点数（观测阶），而 $\\text{S}_k$ 是布尔值。\n\n此问题不涉及物理单位。当通过复数出现角度时，它们作为复指数的一部分，隐式地以弧度为单位。输出必须是所描述的精确格式的单行文本，不含任何额外文字。", "solution": "该问题要求对应用于标量线性测试问题 $y' = \\lambda y$ 的通用 $\\theta$ 方法进行推导、分析并实现一个验证套件。解决方案分步呈现，首先是必要的理论推导，然后是指定的计算验证。\n\n### 1. 更新规则和放大因子的推导\n\n通用单步 $\\theta$ 方法是为常微分方程 $y' = f(t,y)$ 定义的，它使用参数 $\\theta \\in [0,1]$ 从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$。其更新规则由在时间步长开始和结束时计算的函数 $f$ 的凸组合给出：\n$$\ny_{n+1} = y_n + h \\left[ (1-\\theta) f(t_n, y_n) + \\theta f(t_{n+1}, y_{n+1}) \\right]\n$$\n将其特化于标量线性测试问题 $f(t,y) = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$ 是一个常数），我们代入 $f(t_n, y_n) = \\lambda y_n$ 和 $f(t_{n+1}, y_{n+1}) = \\lambda y_{n+1}$：\n$$\ny_{n+1} = y_n + h \\left[ (1-\\theta) \\lambda y_n + \\theta \\lambda y_{n+1} \\right]\n$$\n如果 $\\theta \\neq 0$，这个方程对于 $y_{n+1}$ 是隐式的。我们必须用 $y_n$ 来求解 $y_{n+1}$。重新排列各项，将所有 $y_{n+1}$ 项组合到左侧，所有 $y_n$ 项组合到右侧，得到：\n$$\ny_{n+1} - h \\theta \\lambda y_{n+1} = y_n + h (1-\\theta) \\lambda y_n\n$$\n在左侧提出 $y_{n+1}$，在右侧提出 $y_n$，得到：\n$$\ny_{n+1} (1 - \\theta h \\lambda) = y_n (1 + (1-\\theta) h \\lambda)\n$$\n假设 $1 - \\theta h \\lambda \\neq 0$，我们可以分离出 $y_{n+1}$：\n$$\ny_{n+1} = \\left( \\frac{1 + (1-\\theta) h \\lambda}{1 - \\theta h \\lambda} \\right) y_n\n$$\n单步放大因子，记为 $R(z)$，是数值解在每一步中乘以的因子。它是 $z = h \\lambda$ 的函数。从上面的方程，我们可以确定 $R(z)$ 为：\n$$\nR(z) = \\frac{y_{n+1}}{y_n} = \\frac{1 + (1-\\theta) z}{1 - \\theta z}\n$$\n这就是所需的更新规则和放大因子。$N$ 步后的数值解为 $y_N = (R(h\\lambda))^N y_0$。\n\n### 2. 形式精度阶\n\n一个数值方法的形式精度阶由其局部截断误差（LTE）决定。对于测试问题 $y' = \\lambda y$，精确解从 $t$ 到 $t+h$ 的演化为 $y(t+h) = y(t) e^{\\lambda h}$。从精确解 $y(t)$ 开始，数值方法的一步产生 $y_{t+h} = R(h\\lambda) y(t)$。一步的局部误差是差值 $T_{h} = y(t+h) - y_{t+h} = y(t) (e^{h\\lambda} - R(h\\lambda))$。\n如果一个方法的局部误差 $T_h$ 是 $O(h^{p+1})$，则该方法是 $p$ 阶的。我们通过比较精确放大因子 $e^z$ 的泰勒级数展开与数值放大因子 $R(z)$ 的泰勒级数展开来分析这一点，其中 $z = h\\lambda$。\n\n$e^z$ 在 $z=0$ 附近的泰勒级数为：\n$$\ne^z = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + O(z^4) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + O(z^4)\n$$\n$R(z)$ 的泰勒级数可以通过展开几何级数 $(1-\\theta z)^{-1} = 1 + \\theta z + (\\theta z)^2 + (\\theta z)^3 + \\dots$ 来找到：\n$$\n\\begin{align*}\nR(z) = (1 + (1-\\theta)z) (1 + \\theta z + \\theta^2 z^2 + \\dots) \\\\\n= 1 + \\theta z + \\theta^2 z^2 + \\dots + (1-\\theta)z + \\theta(1-\\theta)z^2 + \\dots \\\\\n= 1 + (\\theta + 1 - \\theta)z + (\\theta^2 + \\theta(1-\\theta))z^2 + O(z^3) \\\\\n= 1 + z + \\theta z^2 + O(z^3)\n\\end{align*}\n$$\n精确放大因子和数值放大因子之间的差是：\n$$\ne^z - R(z) = \\left(1 + z + \\frac{1}{2}z^2 + O(z^3)\\right) - \\left(1 + z + \\theta z^2 + O(z^3)\\right) = \\left(\\frac{1}{2} - \\theta\\right)z^2 + O(z^3)\n$$\n因此，局部误差为 $T_h = y(t) (e^z - R(z)) = y(t)\\left[\\left(\\frac{1}{2} - \\theta\\right)(h\\lambda)^2 + O(h^3)\\right]$。\n\n情况1：$\\theta \\neq \\frac{1}{2}$\n局部误差的首项与 $h^2$ 成正比。因此，$T_h = O(h^2)$。$O(h^{p+1})$ 的局部误差对应于 $O(h^p)$ 的全局误差。因此，当 $p+1=2$ 时，该方法是一阶精确的（$p=1$）。\n\n情况2：$\\theta = \\frac{1}{2}$ (Crank-Nicolson 方法)\n$z^2$ 项的系数 $(\\frac{1}{2} - \\theta)$ 变为零。我们必须检查级数展开中的下一项。\n$$\ne^z = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + O(z^4)\n$$\n$$\nR(z)|_{\\theta=1/2} = \\frac{1+z/2}{1-z/2} = (1+z/2)(1+z/2+(z/2)^2+(z/2)^3+\\dots) = 1+z+\\frac{1}{2}z^2+\\frac{1}{4}z^3+O(z^4)\n$$\n现在的差值为：\n$$\ne^z - R(z) = \\left(1+z+\\frac{1}{2}z^2+\\frac{1}{6}z^3+\\dots\\right) - \\left(1+z+\\frac{1}{2}z^2+\\frac{1}{4}z^3+\\dots\\right) = \\left(\\frac{1}{6}-\\frac{1}{4}\\right)z^3 + O(z^4) = -\\frac{1}{12}z^3 + O(z^4)\n$$\n局部误差为 $T_h = y(t)\\left[-\\frac{1}{12}(h\\lambda)^3 + O(h^4)\\right] = O(h^3)$。当 $p+1=3$ 时，该方法是二阶精确的（$p=2$）。\n\n### 3. 经验观测精度阶\n\n给定一个固定的最终时间 $T$，全局误差 $E(h)$ 是在 $N=T/h$ 步后数值解 $y_N$ 和精确解 $y(T)$ 之间的绝对差：\n$$\nE(h) = |y_N - y(T)|\n$$\n对于一个 $p$ 阶方法，对于某个常数 $C$ 和足够小的 $h$，全局误差表现为 $E(h) \\approx C h^p$。使用两个不同的步长 $h_1$ 和 $h_2$，我们有 $E(h_1) \\approx C h_1^p$ 和 $E(h_2) \\approx C h_2^p$。取其比值然后取对数，得到：\n$$\n\\frac{E(h_1)}{E(h_2)} \\approx \\left(\\frac{h_1}{h_2}\\right)^p \\implies \\log\\left(\\frac{E(h_1)}{E(h_2)}\\right) \\approx p \\log\\left(\\frac{h_1}{h_2}\\right)\n$$\n求解 $p$ 即可得到观测阶的公式：\n$$\np \\approx \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)}\n$$\n问题指定使用三个步长 $h_1 > h_2 > h_3$ 来计算两个成对阶 $p_{12}$ 和 $p_{23}$，并报告它们的平均值 $\\frac{1}{2}(p_{12}+p_{23})$。\n\n### 4. 线性稳定性\n\n对于给定的参数集 $(\\theta, \\lambda, h)$，如果当精确解不无界增长时，数值解的模也不无界增长，则称该数值方法是线性稳定的。对于标量测试问题，这对应于要求放大因子的模不大于一：\n$$\n|R(z)| \\le 1\n$$\n其中 $z=h\\lambda$。在复平面上，对于给定的 $\\theta$，满足此条件的区域是该方法的绝对稳定区。验证测试只是检查对于特定的 $z$ 值是否满足此条件。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform verification of the theta-method.\n    It runs accuracy and stability tests as specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n\n    y0 = 1.0\n\n    # ----- Task 1  4 (Core Functions) -----\n    \n    def compute_R(z, theta):\n        \"\"\"\n        Computes the amplification factor R(z) for the theta-method.\n        z = h * lambda.\n        \"\"\"\n        # To avoid division by zero if 1 - theta*z is exactly 0.\n        # This is unlikely with typical floating-point numbers but is good practice.\n        denominator = 1.0 - theta * z\n        if denominator == 0:\n            return np.inf\n        return (1.0 + (1.0 - theta) * z) / denominator\n\n    # ----- Task 5: Implementation and Verification -----\n\n    def run_accuracy_test(theta, lambda_val, T, y0, h_vals):\n        \"\"\"\n        Computes the empirical order of accuracy for a given set of parameters.\n        \"\"\"\n        errors = []\n        exact_solution_at_T = y0 * np.exp(lambda_val * T)\n\n        for h in h_vals:\n            N = int(round(T / h)) # Number of steps\n            z = h * lambda_val\n            \n            # Amplification factor\n            R_z = compute_R(z, theta)\n            \n            # Numerical solution at T\n            # y_N = y_0 * (R_z)^N\n            y_N = y0 * (R_z ** N)\n            \n            # Global error\n            error = np.abs(y_N - exact_solution_at_T)\n            errors.append(error)\n\n        E1, E2, E3 = errors\n        h1, h2, h3 = h_vals\n        \n        # Pairwise observed orders\n        p12 = np.log(E1 / E2) / np.log(h1 / h2)\n        p23 = np.log(E2 / E3) / np.log(h2 / h3)\n        \n        # Average observed order\n        avg_p = 0.5 * (p12 + p23)\n        return avg_p\n\n    def run_stability_test(theta, lambda_val, h):\n        \"\"\"\n        Checks the linear stability condition |R(z)| = 1.\n        \"\"\"\n        z = h * lambda_val\n        R_z = compute_R(z, theta)\n        is_stable = np.abs(R_z) = 1.0\n        return is_stable\n\n    # --- Test Suite Execution ---\n    \n    results = []\n\n    # Observed order tests\n    T_acc = 1.0\n    h_vals_acc = [1/20, 1/40, 1/80]\n    \n    # Test A1\n    theta_A1, lambda_A1 = 0, -1.0\n    order_A1 = run_accuracy_test(theta_A1, lambda_A1, T_acc, y0, h_vals_acc)\n    results.append(round(order_A1, 3))\n\n    # Test A2\n    theta_A2, lambda_A2 = 0.5, -1.0\n    order_A2 = run_accuracy_test(theta_A2, lambda_A2, T_acc, y0, h_vals_acc)\n    results.append(round(order_A2, 3))\n    \n    # Test A3\n    theta_A3, lambda_A3 = 1.0, -1.0\n    order_A3 = run_accuracy_test(theta_A3, lambda_A3, T_acc, y0, h_vals_acc)\n    results.append(round(order_A3, 3))\n\n    # Stability tests\n    # Test S1\n    stable_S1 = run_stability_test(theta=0, lambda_val=-1.0, h=1.0)\n    results.append(stable_S1)\n    \n    # Test S2\n    stable_S2 = run_stability_test(theta=0, lambda_val=-1.0, h=3.0)\n    results.append(stable_S2)\n\n    # Test S3\n    stable_S3 = run_stability_test(theta=0.5, lambda_val=-1.0, h=100.0)\n    results.append(stable_S3)\n    \n    # Test S4\n    stable_S4 = run_stability_test(theta=1.0, lambda_val=-1.0, h=100.0)\n    results.append(stable_S4)\n\n    # Test S5\n    stable_S5 = run_stability_test(theta=0.5, lambda_val=1j * 10, h=0.1)\n    results.append(stable_S5)\n\n    # Test S6\n    stable_S6 = run_stability_test(theta=0, lambda_val=1j * 10, h=0.1)\n    results.append(stable_S6)\n\n    # Final output formatting\n    # The map(str, ...) correctly converts rounded floats and booleans to their string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```", "id": "3455040"}, {"introduction": "从标量问题过渡到偏微分方程系统，一个关键的步骤是将空间离散化，从而得到一个大型常微分方程组。然而，对于大多数偏微分方程，我们并不知道其精确解，这给代码验证带来了挑战。本练习 [@problem_id:3455115] 引入了强大的制造解方法 (Method of Manufactured Solutions) 来创建具有已知精确解的测试用例，使我们能够在更真实的环境中严格检验 $\\theta$-方法实现的准确性。", "problem": "您需要实现并使用通用的$\\theta$方法进行时间积分，以验证其在一个人为构造的半离散偏微分方程（PDE）系统上的观测精度阶数。此验证必须通过在半离散层面设计一个人为解来执行，以确保唯一的数值误差来源于时间离散化。您的实现必须是一个完整的、可运行的程序，能够为指定的测试套件生成所要求的输出。\n\n从以下数学基础开始。\n\n- 考虑一个长度为$L=2\\pi$的一维周期性域，用一个包含$N=64$个点的均匀网格进行离散化，网格间距为$h=L/N$。令$\\mathbf{y}(t)\\in\\mathbb{R}^N$表示在时间$t$逼近人为解的节点值向量。\n- 令$\\mathbf{A}\\in\\mathbb{R}^{N\\times N}$为周期性二阶中心差分拉普拉斯算子，其元素为\n  $$\n  A_{jj}=-\\frac{2}{h^2},\\quad A_{j,j+1}=\\frac{1}{h^2},\\quad A_{j,j-1}=\\frac{1}{h^2},\n  $$\n  并带有环绕的周期性连接$A_{1,N}=\\frac{1}{h^2}$和$A_{N,1}=\\frac{1}{h^2}$。\n- 令$\\mathbf{q}\\in\\mathbb{R}^N$为离散正弦模$\\mathbf{q}_j=\\sin\\!\\big(m x_j\\big)$，其中$x_j=jh$，$j=0,1,\\dots,N-1$，$m=3$。对于此网格和算子，$\\mathbf{q}$是$\\mathbf{A}$的一个特征向量，其特征值为\n  $$\n  \\mu=\\frac{2\\cos\\!\\big(2\\pi m/N\\big)-2}{h^2}=-\\frac{4\\sin^2\\!\\big(\\pi m/N\\big)}{h^2}.\n  $$\n- 将精确的半离散解构造为$\\mathbf{y}^\\star(t)=\\phi(t)\\,\\mathbf{q}$，其中$\\phi(t)=\\mathrm{e}^{\\gamma t}$，$\\gamma=1$。定义强迫项$\\mathbf{r}(t)$，使得半离散系统\n  $$\n  \\mathbf{y}'(t)=\\mathbf{A}\\,\\mathbf{y}(t)+\\mathbf{r}(t)\n  $$\n  能被$\\mathbf{y}^\\star(t)$精确满足。您必须根据此要求推导出$\\mathbf{r}(t)$并实现它。\n\n时间积分任务。\n\n- 通过对积分形式\n  $$\n  \\mathbf{y}(t_{n+1})=\\mathbf{y}(t_n)+\\int_{t_n}^{t_{n+1}}\\big(\\mathbf{A}\\,\\mathbf{y}(s)+\\mathbf{r}(s)\\big)\\,\\mathrm{d}s,\n  $$\n  应用参数为$\\theta\\in[0,1]$的凸组合求积，推导从$t_n$到$t_{n+1}=t_n+\\Delta t$的单步时间推进的$\\theta$方法，然后形成一个关于$\\mathbf{y}_n$、$\\mathbf{A}$和$\\mathbf{r}(\\cdot)$的可解的$\\mathbf{y}_{n+1}$更新式。除了线性性之外，不要假设任何特殊结构；您的更新必须能处理$\\theta=0$、$\\theta=\\tfrac{1}{2}$和$\\theta=1$的情况。\n- 将初始条件设置为$\\mathbf{y}(0)=\\mathbf{y}^\\star(0)$。\n\n误差测量与观测阶数。\n\n- 对于一个固定的最终时间$T=0.1$，将给定时间步长$\\Delta t$的离散误差定义为\n  $$\n  E(\\Delta t)=\\frac{\\|\\mathbf{y}^{\\Delta t}(T)-\\mathbf{y}^\\star(T)\\|_2}{\\sqrt{N}},\n  $$\n  其中$\\|\\cdot\\|_2$是欧几里得范数，$\\mathbf{y}^{\\Delta t}(T)$是使用时间步长$\\Delta t$计算出的在时间$T$的数值解。\n- 对于下面测试套件中的每个$\\theta$，计算观测阶数\n  $$\n  p=\\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n  $$\n\n测试套件。\n\n使用以下测试用例集，每个用例指定为一个序对$(\\theta,\\Delta t_0)$：\n- $(0,\\;0.001)$，\n- $(0.5,\\;0.01)$，\n- $(1,\\;0.01)$，\n- $(0.75,\\;0.01)$。\n\n对于每种情况，使用$\\Delta t=\\Delta t_0$和$\\Delta t=\\Delta t_0/2$计算$p$，空间离散化参数$L=2\\pi$、$N=64$、$m=3$和$\\gamma=1$保持不变。显式情况$\\theta=0$必须遵守由$\\mathbf{A}$的特征值所隐含的稳定性约束。\n\n输出规范。\n\n- 您的程序必须生成单行输出，其中包含四个案例的观测阶数，顺序与上文列表相同，用逗号分隔，四舍五入到三位小数，并用方括号括起来。例如，格式必须类似于$\\big[$$p_1$,$p_2$,$p_3$,$p_4$$\\big]$。\n- 本问题不涉及物理单位；仅报告纯数值。", "solution": "所提出的问题已经过验证，并被确定为有效。这是一个定义明确的数值分析任务，它在科学上是合理的、自洽的，并且没有矛盾或含糊之处。该问题要求使用人为解方法（一种用于代码验证的标准程序）来实现和验证$\\theta$方法，这是一种求解常微分方程的标准数值技术。所有必需的参数和定义都已提供。因此，我们可以着手提供一个完整的解决方案。\n\n### 1. 人为强迫项的推导\n\n问题为半离散系统$\\mathbf{y}'(t) = \\mathbf{A}\\mathbf{y}(t) + \\mathbf{r}(t)$定义了一个人为解$\\mathbf{y}^\\star(t) \\in \\mathbb{R}^N$。目标是推导强迫项$\\mathbf{r}(t)$，使得$\\mathbf{y}^\\star(t)$是该系统的精确解。\n\n人为解由$\\mathbf{y}^\\star(t) = \\phi(t)\\mathbf{q}$给出，其中$\\phi(t) = e^{\\gamma t}$，$\\gamma=1$。向量$\\mathbf{q} \\in \\mathbb{R}^N$定义为$\\mathbf{q}_j = \\sin(m x_j)$，并且是离散拉普拉斯矩阵$\\mathbf{A}$的特征向量，对应特征值为$\\mu$。\n\n首先，我们计算$\\mathbf{y}^\\star(t)$的时间导数：\n$$\n(\\mathbf{y}^\\star(t))' = \\frac{d}{dt} \\left( e^{\\gamma t} \\mathbf{q} \\right) = \\left( \\frac{d}{dt} e^{\\gamma t} \\right) \\mathbf{q} = \\gamma e^{\\gamma t} \\mathbf{q} = \\gamma \\phi(t) \\mathbf{q}.\n$$\n接下来，我们将矩阵$\\mathbf{A}$应用于$\\mathbf{y}^\\star(t)$：\n$$\n\\mathbf{A}\\mathbf{y}^\\star(t) = \\mathbf{A} \\left( \\phi(t) \\mathbf{q} \\right) = \\phi(t) (\\mathbf{A}\\mathbf{q}).\n$$\n由于$\\mathbf{q}$是$\\mathbf{A}$的特征值为$\\mu$的特征向量，我们有$\\mathbf{A}\\mathbf{q} = \\mu \\mathbf{q}$。代入此式得到：\n$$\n\\mathbf{A}\\mathbf{y}^\\star(t) = \\phi(t) (\\mu \\mathbf{q}) = \\mu \\phi(t) \\mathbf{q}.\n$$\n将这些表达式代回半离散系统方程，得到：\n$$\n\\gamma \\phi(t) \\mathbf{q} = \\mu \\phi(t) \\mathbf{q} + \\mathbf{r}(t).\n$$\n求解强迫项$\\mathbf{r}(t)$，我们得到：\n$$\n\\mathbf{r}(t) = \\gamma \\phi(t) \\mathbf{q} - \\mu \\phi(t) \\mathbf{q} = (\\gamma - \\mu) \\phi(t) \\mathbf{q} = (\\gamma - \\mu) e^{\\gamma t} \\mathbf{q}.\n$$\n这个表达式定义了必要的强迫项，以确保$\\mathbf{y}^\\star(t)$是半离散常微分方程系统的精确解。\n\n### 2. 通用$\\theta$方法更新规则的推导\n\n$\\theta$方法是通过对常微分方程（ODE）系统的积分形式应用特定的求积规则来推导的。从$\\mathbf{y}'(t) = \\mathbf{F}(t, \\mathbf{y}(t))$开始，其中$\\mathbf{F}(t, \\mathbf{y}) = \\mathbf{A}\\mathbf{y} + \\mathbf{r}(t)$，解可以精确地写为：\n$$\n\\mathbf{y}(t_{n+1}) = \\mathbf{y}(t_n) + \\int_{t_n}^{t_{n+1}} \\mathbf{F}(s, \\mathbf{y}(s)) ds.\n$$\n$\\theta$方法使用在时间步端点$t_n$和$t_{n+1}=t_n+\\Delta t$处计算的被积函数的凸组合来近似该积分：\n$$\n\\int_{t_n}^{t_{n+1}} \\mathbf{F}(s, \\mathbf{y}(s)) ds \\approx \\Delta t \\left[ (1-\\theta) \\mathbf{F}(t_n, \\mathbf{y}(t_n)) + \\theta \\mathbf{F}(t_{n+1}, \\mathbf{y}(t_{n+1})) \\right].\n$$\n令$\\mathbf{y}_n \\approx \\mathbf{y}(t_n)$，数值格式变为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\left[ (1-\\theta) \\mathbf{F}(t_n, \\mathbf{y}_n) + \\theta \\mathbf{F}(t_{n+1}, \\mathbf{y}_{n+1}) \\right].\n$$\n代入$\\mathbf{F}(t, \\mathbf{y}) = \\mathbf{A}\\mathbf{y} + \\mathbf{r}(t)$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\left[ (1-\\theta)(\\mathbf{A}\\mathbf{y}_n + \\mathbf{r}(t_n)) + \\theta(\\mathbf{A}\\mathbf{y}_{n+1} + \\mathbf{r}(t_{n+1})) \\right].\n$$\n当$\\theta > 0$时，该方程对于$\\mathbf{y}_{n+1}$是隐式的。我们重新整理各项，将$\\mathbf{y}_{n+1}$分离到等式左侧：\n$$\n\\mathbf{y}_{n+1} - \\Delta t \\theta \\mathbf{A}\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t (1-\\theta) \\mathbf{A}\\mathbf{y}_n + \\Delta t (1-\\theta)\\mathbf{r}(t_n) + \\Delta t \\theta \\mathbf{r}(t_{n+1}).\n$$\n在左侧提出$\\mathbf{y}_{n+1}$，在右侧提出$\\mathbf{y}_n$，我们得到一个关于$\\mathbf{y}_{n+1}$的线性系统：\n$$\n(\\mathbf{I} - \\Delta t \\theta \\mathbf{A})\\mathbf{y}_{n+1} = (\\mathbf{I} + \\Delta t (1-\\theta) \\mathbf{A})\\mathbf{y}_n + \\Delta t \\left[ (1-\\theta)\\mathbf{r}(t_n) + \\theta \\mathbf{r}(t_{n+1}) \\right],\n$$\n其中$\\mathbf{I}$是单位矩阵。在每个时间步都必须求解这个系统，以将解从$\\mathbf{y}_n$推进到$\\mathbf{y}_{n+1}$。\n对于$\\theta=0$（前向欧拉法，Forward Euler），左侧矩阵为$\\mathbf{I}$，从而得到一个显式更新。对于$\\theta \\in (0, 1]$，该方法是隐式的，需要求解一个线性系统。\n\n### 3. 数值实现与验证\n\n验证过程包括以下步骤：\n1.  **系统设置**：设置物理和数值参数：$L=2\\pi$, $N=64$, $m=3$, $\\gamma=1$, 以及$T=0.1$。计算网格间距$h=L/N$并构造网格点$x_j=jh$，$j=0, \\dots, N-1$。\n2.  **矩阵和向量的构造**：\n    - 构造$N \\times N$的周期性二阶有限差分矩阵$\\mathbf{A}$。\n    - 构造离散特征向量$\\mathbf{q}_j = \\sin(m x_j)$。\n    - 计算相应的特征值$\\mu = \\frac{2\\cos(2\\pi m/N)-2}{h^2}$。\n3.  **定义解函数和强迫函数**：实现精确半离散解$\\mathbf{y}^\\star(t) = e^{\\gamma t}\\mathbf{q}$和推导出的强迫项$\\mathbf{r}(t) = (\\gamma - \\mu) e^{\\gamma t} \\mathbf{q}$的函数。\n4.  **时间积分**：对于每个测试用例$(\\theta, \\Delta t_0)$：\n    - 定义一个函数，用给定的时间步长$\\Delta t$执行从$t=0$到$t=T$的时间积分。\n    - 设置初始条件$\\mathbf{y}_0 = \\mathbf{y}^\\star(0)$。\n    - 循环执行所需的步数（$T/\\Delta t$）。在每一步中，构建线性系统$(\\mathbf{I} - \\Delta t \\theta \\mathbf{A})\\mathbf{y}_{n+1} = \\mathbf{b}$并求解$\\mathbf{y}_{n+1}$。\n5.  **误差和阶数计算**：\n    - 对每个测试用例，运行模拟两次：一次使用$\\Delta t = \\Delta t_0$，一次使用$\\Delta t = \\Delta t_0/2$。\n    - 计算最终时间的精确解$\\mathbf{y}^\\star(T)$。\n    - 计算每次运行的离散误差：$E(\\Delta t) = \\frac{\\|\\mathbf{y}^{\\Delta t}(T)-\\mathbf{y}^\\star(T)\\|_2}{\\sqrt{N}}$。\n    - 使用两个误差计算观测精度阶数：$p = \\frac{\\log(E(\\Delta t_0)/E(\\Delta t_0/2))}{\\log(2)}$。\n\n### 4. 稳定性考虑\n对于显式前向欧拉法（Forward Euler method，$\\theta=0$），稳定性要求时间步长$\\Delta t$满足$\\Delta t \\le 2/\\rho(\\mathbf{A})$，其中$\\rho(\\mathbf{A})$是$\\mathbf{A}$的谱半径。$\\mathbf{A}$的特征值为$\\lambda_k = \\frac{2}{h^2}(\\cos(2\\pi k/N) - 1)$。最负的特征值约为$\\lambda_{N/2} = -4/h^2$（对于偶数$N$）。因此，$\\rho(\\mathbf{A}) \\approx 4/h^2$。当$h=\\pi/32$时，稳定性极限为$\\Delta t \\le h^2/2 \\approx (\\pi/32)^2/2 \\approx 0.0048$。为$\\theta=0$情况提供的时步$\\Delta t_0=0.001$满足此条件。对于$\\theta \\ge 0.5$的方法是A-稳定的，对于本问题没有时间步长$\\Delta t$的稳定性限制。\n\n### 5. 预期结果\n$\\theta$方法的理论精度阶数为：\n- 对于$\\theta=0.5$（Crank-Nicolson法），$p=2$。\n- 对于所有其他$\\theta$值，包括$\\theta=0, 0.75, 1$，$p=1$。\n数值实验应该产生接近这些理论值的观测阶数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the theta-method for a manufactured semi-discrete PDE system.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    L = 2 * np.pi\n    N = 64\n    m = 3\n    gamma = 1.0\n    T = 0.1\n\n    # --- Discretization ---\n    h = L / N\n    x = np.arange(N) * h\n\n    # --- Matrix A (Periodic 2nd-order Central Difference Laplacian) ---\n    A = np.zeros((N, N))\n    h2_inv = 1.0 / (h * h)\n    for i in range(N):\n        A[i, i] = -2.0 * h2_inv\n        A[i, (i + 1) % N] = 1.0 * h2_inv\n        A[i, (i - 1 + N) % N] = 1.0 * h2_inv\n\n    # --- Eigenvector and Eigenvalue ---\n    q = np.sin(m * x)\n    # The given formula for mu is the exact eigenvalue for the discrete operator\n    mu = (2.0 * np.cos(2.0 * np.pi * m / N) - 2.0) / (h * h)\n    \n    # --- Manufactured Solution and Forcing Term ---\n    def y_exact(t):\n        return np.exp(gamma * t) * q\n\n    def r_forcing(t):\n        return (gamma - mu) * np.exp(gamma * t) * q\n\n    def time_stepper(theta, dt):\n        \"\"\"\n        Solves the ODE system y' = Ay + r(t) from t=0 to T using the theta-method.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        y = y_exact(0.0)\n        t = 0.0\n\n        # Pre-compute matrices for the linear system\n        LHS_matrix = np.eye(N) - dt * theta * A\n        RHS_matrix_op = np.eye(N) + dt * (1 - theta) * A\n\n        for n in range(num_steps):\n            t_next = (n + 1) * dt\n            \n            # Form the right-hand side vector\n            rhs_y_part = RHS_matrix_op @ y\n            rhs_r_part = dt * ((1 - theta) * r_forcing(t) + theta * r_forcing(t_next))\n            rhs_vector = rhs_y_part + rhs_r_part\n            \n            # Solve the linear system for the next time step\n            if theta == 0:  # Explicit Euler\n                y_next = rhs_vector\n            else:  # Implicit methods\n                y_next = np.linalg.solve(LHS_matrix, rhs_vector)\n            \n            y = y_next\n            t = t_next\n            \n        return y\n\n    def compute_order(theta, dt0):\n        \"\"\"\n        Computes the observed order of accuracy for a given theta and base time step dt0.\n        \"\"\"\n        # Get numerical solutions at T for dt0 and dt0/2\n        y_final_dt0 = time_stepper(theta, dt0)\n        y_final_dt0_2 = time_stepper(theta, dt0 / 2)\n\n        # Get exact solution at T\n        y_star_T = y_exact(T)\n\n        # Compute errors\n        err_dt0 = np.linalg.norm(y_final_dt0 - y_star_T) / np.sqrt(N)\n        err_dt0_2 = np.linalg.norm(y_final_dt0_2 - y_star_T) / np.sqrt(N)\n        \n        # Compute observed order of accuracy\n        if err_dt0_2 == 0:\n             # If error is zero, order calculation is not meaningful.\n             # This might happen with machine precision, return a high number.\n             return np.inf\n        \n        p = np.log(err_dt0 / err_dt0_2) / np.log(2)\n        return p\n\n    # --- Test Suite ---\n    test_cases = [\n        (0.0, 0.001),   # Forward Euler\n        (0.5, 0.01),    # Crank-Nicolson\n        (1.0, 0.01),    # Backward Euler\n        (0.75, 0.01),   # General implicit\n    ]\n\n    results = []\n    for theta_val, dt0_val in test_cases:\n        p = compute_order(theta_val, dt0_val)\n        results.append(np.round(p, 3))\n\n    # --- Output ---\n    # Format the results as [p1,p2,p3,p4] rounded to three decimals\n    print(f\"[{','.join(f'{res:.3f}' for res in results)}]\")\n\nsolve()\n```", "id": "3455115"}, {"introduction": "理论的优雅往往在实践的细节中受到考验，对于常数源项的处理就是一个典型例子。在为包含非齐次项（如恒定热源）的方程实施时间积分格式时，一个看似微小的错误可能会导致数值解的稳态行为发生偏差，从而严重影响长期模拟的准确性。本练习 [@problem_id:3455102] 剖析了在 Crank-Nicolson 方法中处理常数源项时的一个常见陷阱，并要求从第一性原理出发推导正确的格式，从而加深对数值格式保结构性质的理解。", "problem": "考虑一维热方程，其在单位区间上有一个空间均匀、不随时间变化的体积源，并带有齐次狄利克雷边界条件，\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t) \\;+\\; 1,\\quad x\\in(0,1),\\; t>0,\\qquad u(0,t)=u(1,t)=0,\\qquad u(x,0)=0,\n$$\n其中 $\\,\\kappa0\\,$ 是常数。在包含 $\\,m\\,$ 个内部点的均匀网格上，使用标准的二阶空间中心有限差分，可得到以下半离散系统\n$$\n\\mathbf{U}'(t) \\;=\\; \\mathbf{A}\\,\\mathbf{U}(t) \\;+\\; \\mathbf{s},\\qquad \\mathbf{U}(0)=\\mathbf{0},\n$$\n其中 $\\,\\mathbf{A}\\in\\mathbb{R}^{m\\times m}\\,$ 是由 $\\kappa$ 缩放的离散拉普拉斯算子的对称负定刚度矩阵，而 $\\,\\mathbf{s}\\in\\mathbb{R}^{m}\\,$ 是对应于源 $\\,1\\,$ 的常数载荷向量。该半离散系统的连续稳态 $\\,\\mathbf{U}_{\\infty}\\,$ 定义为\n$$\n\\mathbf{A}\\,\\mathbf{U}_{\\infty} \\;+\\; \\mathbf{s} \\;=\\; \\mathbf{0}.\n$$\n对于这个非齐次系统，一种常见但不恰当的通用 theta 方法在 $\\,\\theta=\\tfrac{1}{2}\\,$ (Crank–Nicolson) 时的实现方式是\n$$\n\\bigl(\\mathbf{I} - \\tfrac{\\Delta t}{2}\\,\\mathbf{A}\\bigr)\\,\\mathbf{U}^{n+1}\n\\;=\\;\n\\bigl(\\mathbf{I} + \\tfrac{\\Delta t}{2}\\,\\mathbf{A}\\bigr)\\,\\mathbf{U}^{n}\n\\;+\\;\n\\tfrac{\\Delta t}{2}\\,\\mathbf{s},\n$$\n也就是说，源项在一个步长内被错误地加权了一半。这导致了有偏差的离散稳态，并降低了精度，特别是对于刚性算子 $\\,\\mathbf{A}\\,$。\n\n从时间上的梯形法则的第一性原理以及上述稳态的定义出发，推导一个修正的单步 Crank–Nicolson 更新格式，该格式既 (i) 对任意 $\\,\\Delta t>0\\,$ 精确地保持稳态 $\\,\\mathbf{U}_{\\infty}\\,$，又 (ii) 对于光滑数据在时间上是全局二阶精确的。请将您的最终答案表示为关于 $\\,\\mathbf{U}^{n+1}\\,$ 的单一闭式解析表达式，用 $\\,\\mathbf{A},\\,\\Delta t,\\,\\mathbf{U}^{n},\\,$ 和 $\\,\\mathbf{s}\\,$ 表示，不引入任何辅助变量。您的最终答案必须是单一的闭式表达式。不需要进行数值评估。", "solution": "该问题要求为由下式给出的常微分方程(ODE)半离散系统推导一个修正的单步 Crank-Nicolson 更新格式\n$$\n\\mathbf{U}'(t) \\;=\\; \\mathbf{A}\\,\\mathbf{U}(t) \\;+\\; \\mathbf{s}\n$$\n并满足初始条件 $\\mathbf{U}(0)=\\mathbf{0}$。矩阵 $\\mathbf{A}$ 是对称负定的，向量 $\\mathbf{s}$ 是常数。推导必须从梯形法则的第一性原理出发，并得到一个格式，该格式 (i) 精确地保持由 $\\mathbf{A}\\,\\mathbf{U}_{\\infty} + \\mathbf{s} = \\mathbf{0}$ 定义的稳态 $\\mathbf{U}_{\\infty}$，且 (ii) 在时间上是全局二阶精确的。\n\nCrank-Nicolson 方法是 theta 方法在 $\\theta = \\frac{1}{2}$ 时的特例，它等价于应用梯形法则进行数值积分。推导时间步进格式的第一性原理是将 ODE 系统在一个时间区间，即从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 上积分。\n$$\n\\int_{t_n}^{t_{n+1}} \\mathbf{U}'(\\tau) \\,d\\tau \\;=\\; \\int_{t_n}^{t_{n+1}} \\bigl(\\mathbf{A}\\,\\mathbf{U}(\\tau) \\;+\\; \\mathbf{s}\\bigr) \\,d\\tau\n$$\n左边恰好是 $\\mathbf{U}(t_{n+1}) - \\mathbf{U}(t_n)$。我们将精确解 $\\mathbf{U}(t_k)$ 在时间 $t_k$ 的数值近似记为 $\\mathbf{U}^k$。\n$$\n\\mathbf{U}^{n+1} - \\mathbf{U}^n \\;=\\; \\int_{t_n}^{t_{n+1}} \\bigl(\\mathbf{A}\\,\\mathbf{U}(\\tau) \\;+\\; \\mathbf{s}\\bigr) \\,d\\tau\n$$\n梯形法则将函数 $g(\\tau)$ 在 $[t_n, t_{n+1}]$ 上的积分近似为 $\\frac{\\Delta t}{2} \\bigl(g(t_n) + g(t_{n+1})\\bigr)$。将此应用于我们积分后的 ODE 的右侧，其中被积函数是 $g(\\tau) = \\mathbf{A}\\,\\mathbf{U}(\\tau) + \\mathbf{s}$：\n$$\n\\int_{t_n}^{t_{n+1}} \\bigl(\\mathbf{A}\\,\\mathbf{U}(\\tau) \\;+\\; \\mathbf{s}\\bigr) \\,d\\tau \\;\\approx\\; \\frac{\\Delta t}{2} \\left[ \\bigl(\\mathbf{A}\\,\\mathbf{U}^n + \\mathbf{s}\\bigr) + \\bigl(\\mathbf{A}\\,\\mathbf{U}^{n+1} + \\mathbf{s}\\bigr) \\right]\n$$\n注意，源项 $\\mathbf{s}$ 不随时间变化，因此它出现在区间的两端。合并各项得到：\n$$\n\\frac{\\Delta t}{2} \\left[ \\mathbf{A}\\,\\mathbf{U}^n + \\mathbf{A}\\,\\mathbf{U}^{n+1} + 2\\mathbf{s} \\right] \\;=\\; \\frac{\\Delta t}{2}\\mathbf{A}\\left(\\mathbf{U}^n + \\mathbf{U}^{n+1}\\right) + \\Delta t\\,\\mathbf{s}\n$$\n得到的格式是：\n$$\n\\mathbf{U}^{n+1} - \\mathbf{U}^n \\;=\\; \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}^n + \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}^{n+1} + \\Delta t\\,\\mathbf{s}\n$$\n该格式通过将常数源项 $\\mathbf{s}$ 在区间 $[t_n, t_{n+1}]$ 上精确积分，正确地处理了该项，从而得到 $\\Delta t\\,\\mathbf{s}$ 项。问题描述中提到的有缺陷的格式使用了 $\\frac{\\Delta t}{2}\\,\\mathbf{s}$，这对应于不正确的平均。\n\n为了得到最终表达式，我们重新整理方程，将包含 $\\mathbf{U}^{n+1}$ 的项归到左边，将包含 $\\mathbf{U}^n$ 的项归到右边：\n$$\n\\mathbf{U}^{n+1} - \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}^{n+1} \\;=\\; \\mathbf{U}^n + \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}^n + \\Delta t\\,\\mathbf{s}\n$$\n使用单位矩阵 $\\mathbf{I}$ 提取公因式 $\\mathbf{U}^{n+1}$ 和 $\\mathbf{U}^n$：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^{n+1} \\;=\\; \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^n + \\Delta t\\,\\mathbf{s}\n$$\n这是隐式单步更新规则。我们现在验证其性质。\n\n(i) **稳态保持性**：\n如果设置 $\\mathbf{U}^n = \\mathbf{U}_{\\infty}$ 后，可以推导出 $\\mathbf{U}^{n+1} = \\mathbf{U}_{\\infty}$，那么该格式就能保持稳态。稳态 $\\mathbf{U}_{\\infty}$ 由 $\\mathbf{A}\\,\\mathbf{U}_{\\infty} + \\mathbf{s} = \\mathbf{0}$ 定义，这意味着 $\\mathbf{s} = -\\mathbf{A}\\,\\mathbf{U}_{\\infty}$。将 $\\mathbf{U}^n = \\mathbf{U}_{\\infty}$ 和 $\\mathbf{s} = -\\mathbf{A}\\,\\mathbf{U}_{\\infty}$ 代入该格式：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^{n+1} \\;=\\; \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}_{\\infty} + \\Delta t(-\\mathbf{A}\\,\\mathbf{U}_{\\infty})\n$$\n展开右侧：\n$$\n\\text{右侧} \\;=\\; \\mathbf{I}\\,\\mathbf{U}_{\\infty} + \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}_{\\infty} - \\Delta t\\,\\mathbf{A}\\,\\mathbf{U}_{\\infty} \\;=\\; \\mathbf{U}_{\\infty} - \\frac{\\Delta t}{2}\\mathbf{A}\\,\\mathbf{U}_{\\infty} \\;=\\; \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}_{\\infty}\n$$\n因此，我们得到等式：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^{n+1} \\;=\\; \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}_{\\infty}\n$$\n由于 $\\mathbf{A}$ 是负定的，其特征值 $\\lambda_i$ 均为负数。矩阵 $\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}$ 的特征值是 $1 - \\frac{\\Delta t}{2}\\lambda_i$。因为 $\\Delta t > 0$ 且 $\\lambda_i  0$，所有特征值都严格大于 $1$，这意味着该矩阵是非奇异的，因此是可逆的。我们可以用它的逆矩阵乘以等式两边，得出结论：\n$$\n\\mathbf{U}^{n+1} \\;=\\; \\mathbf{U}_{\\infty}\n$$\n该格式对于任何 $\\Delta t > 0$ 都能精确保持稳态。\n\n(ii) **二阶精度**：\n该格式是通过将梯形法则应用于 ODE 系统推导出来的。梯形法则是经典的 $2$ 阶 Runge-Kutta 方法。众所周知，其局部截断误差为 $O(\\Delta t^3)$ 阶。对于一个相容且稳定的方法，阶为 $O(\\Delta t^{p+1})$ 的局部截断误差意味着阶为 $O(\\Delta t^p)$ 的全局误差。Crank-Nicolson 方法是 A-稳定的，这保证了它对于此问题的稳定性。因此，对于足够光滑的解，该方法的全局精度在时间上是二阶的，即 $O(\\Delta t^2)$。\n\n最后，为了将 $\\mathbf{U}^{n+1}$ 表示为单一的闭式解析表达式，我们通过乘以左侧矩阵的逆，形式上求解关于 $\\mathbf{U}^{n+1}$ 的隐式更新规则：\n$$\n\\mathbf{U}^{n+1} \\;=\\; \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)^{-1} \\left[ \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^n + \\Delta t\\,\\mathbf{s} \\right]\n$$\n这个表达式提供了满足所有规定要求的修正的单步 Crank-Nicolson 更新格式。", "answer": "$$\n\\boxed{\\mathbf{U}^{n+1} = \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)^{-1} \\left[ \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{U}^{n} + \\Delta t\\,\\mathbf{s} \\right]}\n$$", "id": "3455102"}]}