{"hands_on_practices": [{"introduction": "理论学习之后，通过动手实践来巩固理解至关重要。本练习将指导您为经典的二维热方程实现Peaceman-Rachford ADI格式[@problem_id:2446320]。通过完成这个任务，您将熟悉ADI算法的核心机制，包括两阶段更新过程以及如何高效求解一系列独立的三对角线性系统，这是将理论知识转化为计算能力的关键一步。", "problem": "考虑单位正方形上的二维热传导方程，该方程具有齐次狄利克雷边界条件和可分离的解析解。令 $u(x,y,t)$ 满足\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + \\frac{\\partial^2 u}{\\partial y^2}(x,y,t) \\right), \\quad (x,y)\\in (0,1)\\times(0,1), \\; t\\in (0,T],\n$$\n其中对于边界 $\\partial([0,1]\\times[0,1])$ 上的 $(x,y)$ 和 $t\\ge 0$，$u(x,y,t) = 0$。初始条件为\n$$\nu(x,y,0) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y),\n$$\n由此可得精确解\n$$\nu(x,y,t) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y)\\,\\exp\\!\\left( -\\,\\kappa \\pi^2 (m^2+n^2)\\, t \\right).\n$$\n用 $x$ 和 $y$ 方向上分别为 $N_x$ 和 $N_y$ 个内部点来离散化空间域。令 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$，内部网格点为 $(x_i,y_j) = (i\\,h_x, j\\,h_y)$，其中 $i\\in\\{1,\\dots,N_x\\}$，$j\\in\\{1,\\dots,N_y\\}$。用时间步长 $\\Delta t$ 离散化时间，使得 $N_t = T/\\Delta t$ 为整数，且对于 $n\\in\\{0,1,\\dots,N_t\\}$，$t^n = n\\,\\Delta t$。\n\n使用Peaceman–Rachford交替方向隐式(ADI)格式，通过每个时间步的两步更新，将解从 $t^n$推进到 $t^{n+1}$。定义内部网格函数 $U^n_{i,j} \\approx u(x_i,y_j,t^n)$。设 $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ 和 $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$，两个半步为：\n$$\n\\text{阶段 1:}\\quad\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n,\n$$\n$$\n\\text{阶段 2:}\\quad\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star},\n$$\n其中 $A_x$ 和 $A_y$ 是作用于内部点、在内部之外使用齐次狄利克雷边界值的沿 $x$ 和 $y$ 方向的标准二阶差分算子。具体来说，对于内部索引，\n$$\n(A_x U)_{i,j} \\;=\\; U_{i-1,j} - 2U_{i,j} + U_{i+1,j},\n$$\n$$\n(A_y U)_{i,j} \\;=\\; U_{i,j-1} - 2U_{i,j} + U_{i,j+1},\n$$\n并约定任何索引在内部之外的 $U$ 值均使用边界值 $0$。\n\n在内部网格上实现该格式，并精确推进 $N_t$ 个完整步长至时间 $T$。对于下方的每个测试用例，计算在时间 $T$ 的相对离散 $L^2$ 误差，\n$$\n\\varepsilon \\;=\\; \\frac{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(U^{N_t}_{i,j} - u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}},\n$$\n该误差是无量纲的。\n\n测试套件：\n- 情况 $1$ (一般情况): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 20$, $N_y = 20$, $\\Delta t = 10^{-4}$, $T = 10^{-2}$。\n- 情况 $2$ (各向异性空间频率和网格): $\\kappa = 1$, $m = 2$, $n = 1$, $N_x = 12$, $N_y = 8$, $\\Delta t = 5\\times 10^{-4}$, $T = 2\\times 10^{-2}$。\n- 情况 $3$ (粗网格和大时间步长): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 2$, $N_y = 2$, $\\Delta t = 10^{-1}$, $T = 10^{-1}$。\n- 情况 $4$ (细网格和小时间步长): $\\kappa = 1$, $m = 3$, $n = 2$, $N_x = 50$, $N_y = 50$, $\\Delta t = 5\\times 10^{-5}$, $T = 5\\times 10^{-3}$。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是按上述顺序列出的对应测试用例计算出的相对离散 $L^2$ 误差 $\\varepsilon$。程序必须是完全自包含的，并且无需任何用户输入或外部文件即可生成这四个数字。", "solution": "该问题陈述经过验证，被认为是有效的。它在科学上是成立的、适定的、客观的且内部一致。它提出了一个计算科学中的标准问题：使用Peaceman-Rachford交替方向隐式(ADI)格式对二维热传导方程进行数值求解。为获得唯一的数值解所需的所有参数和定义都已提供，任务是直接应用已建立的数值方法。\n\n目标是求解二维热传导方程\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\n在一个单位正方形域 $(x,y)\\in (0,1)\\times(0,1)$上，并带有齐次狄利克雷边界条件。给定的初始条件 $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ 对应一个已知的解析解，该解析解可作为验证数值实现准确性的基准。\n\nPeaceman-Rachford ADI方法是一种在空间和时间上均为二阶精度的有限差分格式，并且对于热传导方程是无条件稳定的。其主要优点在于计算效率。一个全隐式的二维格式需要求解一个具有块三对角结构的大型稀疏线性系统。ADI方法通过将时间步长 $\\Delta t$ 分成两个半步来规避此问题。每个半步仅在一个空间方向上是隐式的，这导致方程组仅为三对角系统。\n\n该方法通过一个中间步骤 $U^{\\star}$，将离散解 $U^n$（网格上 $u(x,y,t^n)$ 的近似）推进到 $U^{n+1}$。网格由 $N_x \\times N_y$ 个内部点定义，间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。\n\nADI格式的两个阶段是：\n\n阶段 1：$x$ 方向隐式。\n$$\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n\n$$\n这里，$\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ 且 $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$。算子 $A_x$ 是 $x$ 方向的一维二阶差分算子，$A_y$ 是 $y$ 方向对应的算子。对于由 $j \\in \\{1, \\dots, N_y\\}$ 索引的每个网格行，该方程构成一个由 $N_x$ 个线性方程组成的独立三对角系统，求解未知数 $U^{\\star}_{1,j}, \\dots, U^{\\star}_{N_x,j}$。对于给定的行 $j$，系统为：\n$$\n-\\lambda_x U^{\\star}_{i-1,j} + (1 + 2\\lambda_x) U^{\\star}_{i,j} - \\lambda_x U^{\\star}_{i+1,j} \\;=\\; d_{i,j}, \\quad i \\in \\{1, \\dots, N_x\\}\n$$\n其中 $d = (I + \\lambda_y A_y)U^n$ 是右端项，由时间 $t^n$ 的解可知。边界条件意味着 $U^{\\star}_{0,j} = U^{\\star}_{N_x+1,j} = 0$。\n\n阶段 2：$y$ 方向隐式。\n$$\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star}\n$$\n在第一阶段之后，求解此方程以获得 $U^{n+1}$。对于由 $i \\in \\{1, \\dots, N_x\\}$ 索引的每个网格列，这构成一个由 $N_y$ 个线性方程组成的独立三对角系统，求解未知数 $U^{n+1}_{i,1}, \\dots, U^{n+1}_{i,N_y}$。对于给定的列 $i$，系统为：\n$$\n-\\lambda_y U^{n+1}_{i,j-1} + (1 + 2\\lambda_y) U^{n+1}_{i,j} - \\lambda_y U^{n+1}_{i,j+1} \\;=\\; e_{i,j}, \\quad j \\in \\{1, \\dots, N_y\\}\n$$\n其中 $e = (I + \\lambda_x A_x)U^{\\star}$ 是右端项，由中间解 $U^{\\star}$ 可知。边界条件意味着 $U^{n+1}_{i,0} = U^{n+1}_{i,N_y+1} = 0$。\n\n实现策略如下：\n1. 初始化解。一个大小为 $N_y \\times N_x$ 的二维数组 $U$ 用初始条件 $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ 在内部网格点 $(x_i, y_j)$ 上的值进行初始化。\n2. 构造三对角系统矩阵。更准确地说，我们构造数值求解器所需的矩阵 $(I-\\lambda_x A_x)$ 和 $(I-\\lambda_y A_y)$ 的带状表示。\n3. 对 $N_t = T/\\Delta t$ 个时间步进行迭代。在每一步中：\n    a. 计算阶段1的右端项，$RHS_1 = (I + \\lambda_y A_y)U^n$。这通过对 $U^n$ 进行向量化数组操作来实现，同时考虑零狄利克雷边界条件。\n    b. 求解 $N_y$ 个三对角系统，以获得 $U^{\\star}$ 的行。这可以通过转置 $RHS_1$ 矩阵，并对带状线性系统求解器（如 `scipy.linalg.solve_banded`）进行向量化调用来高效完成。\n    c. 计算阶段2的右端项，$RHS_2 = (I + \\lambda_x A_x)U^{\\star}$，同样使用对中间解 $U^{\\star}$ 的向量化操作。\n    d. 求解 $N_x$ 个三对角系统，以获得 $U^{n+1}$ 的列。这是将带状求解器直接应用于 $RHS_2$ 的列。\n    e. 更新解：$U \\leftarrow U^{n+1}$。\n4. 在最后一个时间步之后，在相同的网格上计算精确解 $u(x,y,T)$。\n5. 计算相对离散 $L^2$ 误差 $\\varepsilon$。提供的公式等价于误差矩阵和精确解矩阵的弗罗贝尼乌斯范数之比：\n    $$\n    \\varepsilon = \\frac{|| U^{N_t} - u(\\cdot, \\cdot, T) ||_F}{|| u(\\cdot, \\cdot, T) ||_F}\n    $$\n    其中 $||A||_F = \\left(\\sum_{i,j} |A_{ij}|^2\\right)^{1/2}$。这在计算上是直接的。\n\n此过程系统地应用于问题陈述中指定的四个测试用例。最终输出由每个用例计算出的误差 $\\varepsilon$ 组成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D heat equation for all test cases\n    using the Peaceman-Rachford ADI method and compute the errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, m, n, Nx, Ny, dt, T)\n        (1.0, 1, 1, 20, 20, 1e-4, 1e-2),\n        (1.0, 2, 1, 12, 8, 5e-4, 2e-2),\n        (1.0, 1, 1, 2, 2, 1e-1, 1e-1),\n        (1.0, 3, 2, 50, 50, 5e-5, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_one_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single set of parameters.\n    \"\"\"\n    kappa, m, n, Nx, Ny, dt, T = params\n\n    # 1. Calculate derived parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    Nt = round(T / dt)  # Problem guarantees this is integer\n\n    lx = kappa * dt / (2.0 * hx**2)\n    ly = kappa * dt / (2.0 * hy**2)\n\n    # 2. Create spatial grid\n    x = np.linspace(hx, 1.0 - hx, Nx)\n    y = np.linspace(hy, 1.0 - hy, Ny)\n    X, Y = np.meshgrid(x, y) # X has shape (Ny, Nx), Y has shape (Ny, Nx)\n\n    # 3. Set initial condition\n    U = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y)\n\n    # 4. Construct banded matrices for the tridiagonal solvers\n    # Stage 1: systems in x-direction (size Nx)\n    ab_x = np.zeros((3, Nx))\n    ab_x[0, 1:] = -lx\n    ab_x[1, :] = 1.0 + 2.0 * lx\n    ab_x[2, :-1] = -lx\n\n    # Stage 2: systems in y-direction (size Ny)\n    ab_y = np.zeros((3, Ny))\n    ab_y[0, 1:] = -ly\n    ab_y[1, :] = 1.0 + 2.0 * ly\n    ab_y[2, :-1] = -ly\n\n    # 5. Time-stepping loop\n    for _ in range(Nt):\n        # --- Stage 1: (I - lx*Ax) U_star = (I + ly*Ay) U ---\n\n        # Calculate RHS_1 = (I + ly*Ay) * U\n        # Ay applied to columns of U, with homogeneous Dirichlet BCs\n        RHS1 = np.zeros_like(U)\n        if Ny > 1:\n            RHS1[1:-1, :] = U[1:-1, :] + ly * (U[0:-2, :] - 2.0 * U[1:-1, :] + U[2:, :])\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :] + U[1, :])      # j=0\n            RHS1[-1, :] = U[-1, :] + ly * (U[-2, :] - 2.0 * U[-1, :])  # j=Ny-1\n        else: # Ny == 1\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :])\n\n        # Solve for U_star (systems are along rows)\n        # We transpose RHS1 to feed rows as columns to solve_banded\n        U_star_T = solve_banded((1, 1), ab_x, RHS1.T, overwrite_ab=False, overwrite_b=False)\n        U_star = U_star_T.T\n\n        # --- Stage 2: (I - ly*Ay) U_np1 = (I + lx*Ax) U_star ---\n        \n        # Calculate RHS_2 = (I + lx*Ax) * U_star\n        # Ax applied to rows of U_star, with homogeneous Dirichlet BCs\n        RHS2 = np.zeros_like(U_star)\n        if Nx > 1:\n            RHS2[:, 1:-1] = U_star[:, 1:-1] + lx * (U_star[:, 0:-2] - 2.0 * U_star[:, 1:-1] + U_star[:, 2:])\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0] + U_star[:, 1])    # i=0\n            RHS2[:, -1] = U_star[:, -1] + lx * (U_star[:, -2] - 2.0 * U_star[:, -1])  # i=Nx-1\n        else: # Nx == 1\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0])\n\n        # Solve for U_np1 (systems are along columns)\n        U_np1 = solve_banded((1, 1), ab_y, RHS2, overwrite_ab=False, overwrite_b=False)\n        \n        # Update solution for next time step\n        U = U_np1\n\n    # 6. Compute exact solution at final time T\n    U_exact = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y) * np.exp(-kappa * np.pi**2 * (m**2 + n**2) * T)\n\n    # 7. Compute relative discrete L2 error\n    # The term sqrt(hx*hy) cancels in numerator and denominator.\n    # So error is ratio of Frobenius norms.\n    norm_diff = np.linalg.norm(U - U_exact)\n    norm_exact = np.linalg.norm(U_exact)\n\n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n\n    return norm_diff / norm_exact\n\nsolve()\n```", "id": "2446320"}, {"introduction": "在掌握了ADI方法的基本实现后，我们深入探讨其背后的理论基础，即“为什么”它既高效又准确。这个理论练习旨在分析算子分裂的核心概念，这是ADI方法的基石[@problem_id:3128240]。通过推导局部截断误差，您将深刻理解该方法为何能在算子可交换的理想情况下达到二阶时间精度，以及它与未分裂的Crank-Nicolson格式之间的精确关系。", "problem": "考虑方形区域上具有周期性边界条件的二维扩散方程 $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$，其中 $\\kappa>0$ 是常数。使用间距为 $h$ 的均匀网格，通过二阶中心差分对空间进行离散化，得到一个常微分方程线性组 $\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$。其中，$A_{h}$ 和 $B_{h}$ 分别是沿 $x$ 和 $y$ 方向作用的标准离散一维二阶导数算子（按 $\\kappa$ 缩放），并通过张量积扩展到二维。在此具有周期性边界的网格上，假设 $A_{h}$ 和 $B_{h}$ 对易。\n\n将时间步长为 $\\Delta t>0$ 的 Peaceman–Rachford 交替方向隐式 (ADI) 方法的一个步骤定义为以下线性求解对\n$$\n(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n},\\qquad (I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}},\n$$\n并令其单步传播算子为满足 $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$ 的线性算子 $S(\\Delta t)$。令未分裂的 Crank–Nicolson 传播算子为\n$$\nR_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}。\n$$\n\n将每个时间步的局部格式分裂误差算子定义为 $E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$。从矩阵有理函数的基本级数展开出发，并且仅使用上述定义（不使用未经证明的快捷公式），在 $A_{h}$ 和 $B_{h}$ 对易的假设下，确定当 $\\Delta t\\to 0$ 时，使得 $E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$ 成立的最小整数 $p$。\n\n最终答案仅报告整数 $p$。无需单位。", "solution": "用户希望确定 Peaceman-Rachford ADI 方法的局部格式分裂误差的阶数。\n\n### 步骤 1：问题验证\n\n**1. 提取已知条件：**\n- 偏微分方程 (PDE)：方形区域上的 $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$，具有周期性边界条件，$\\kappa>0$。\n- 离散化：使用间距为 $h$ 的均匀网格，通过二阶中心差分对空间进行离散化。\n- 半离散系统：$\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$。\n- 算子：$A_{h}$ 和 $B_{h}$ 是分别用于 $x$ 和 $y$ 方向的离散一维二阶导数算子（按 $\\kappa$ 缩放）。\n- 假设：$A_{h}$ 和 $B_{h}$ 对易，即 $A_{h}B_{h} = B_{h}A_{h}$。\n- Peaceman-Rachford ADI 方法：\n  - $(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n}$\n  - $(I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}$\n- ADI 传播算子：$S(\\Delta t)$ 使得 $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$。\n- Crank-Nicolson 传播算子：$R_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}$。\n- 局部格式分裂误差算子：$E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$。\n- 目标：找到最小的整数 $p$，使得当 $\\Delta t\\to 0$ 时 $E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$。\n- 约束：使用基本级数展开和对易性假设。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学依据：**该问题是对一个基本偏微分方程（扩散方程）的著名数值方法（ADI）的标准分析。所有概念在数值分析领域都是成熟的。\n- **适定性：**该问题在数学上是适定的。它提供了所有必要的定义和关键的算子对易性假设，从而可以推导出唯一的解。\n- **客观性：**语言形式化且精确，没有主观或含糊的陈述。\n- 该问题通过了所有有效性检查。它不是不合理的、不完整的、不一致的或不适定的。\n\n**3. 结论与行动：**\n- 该问题有效。将提供详细的解答。\n\n### 步骤 2：求解推导\n\n目标是找到最小的整数 $p$，使得局部格式分裂误差 $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$ 的阶为 $\\mathcal{O}(\\Delta t^p)$。\n\n首先，我们求出 ADI 传播算子 $S(\\Delta t)$ 的显式表达式。根据该方法的定义：\n$$ \\mathbf{u}^{n+\\frac{1}{2}} = \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\mathbf{u}^{n} $$\n$$ \\mathbf{u}^{n+1} = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\mathbf{u}^{n+\\frac{1}{2}} $$\n将 $\\mathbf{u}^{n+\\frac{1}{2}}$ 的表达式代入第二个方程，得到 $\\mathbf{u}^{n+1} = S(\\Delta t) \\mathbf{u}^n$，其中传播算子 $S(\\Delta t)$ 为：\n$$ S(\\Delta t) = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) $$\n题目说明 $A_h$ 和 $B_h$ 对易。这意味着任何 $A_h$ 的良态函数都与任何 $B_h$ 的良态函数对易。因此，我们可以重新排列 $S(\\Delta t)$ 表达式中的算子：\n$$ S(\\Delta t) = \\left[ \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\right] \\left[ \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\right] $$\n题目要求我们从基本级数展开开始。对于一个通用算子 $Z$，我们定义有理算子函数 $F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left(I-\\frac{\\Delta t}{2}Z\\right)^{-1}$。我们可以使用矩阵的几何级数 $(I-M)^{-1} = \\sum_{k=0}^{\\infty} M^k$ 来展开它，该级数在 $\\Delta t$ 很小以至于 $\\frac{\\Delta t}{2}Z$ 的谱半径小于 1 时有效。\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\sum_{k=0}^{\\infty} \\left(\\frac{\\Delta t}{2}Z\\right)^k $$\n展开该和式：\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left( I + \\frac{\\Delta t}{2}Z + \\left(\\frac{\\Delta t}{2}\\right)^2 Z^2 + \\left(\\frac{\\Delta t}{2}\\right)^3 Z^3 + \\mathcal{O}(\\Delta t^4) \\right) $$\n将各项相乘：\n$$ F(Z, \\Delta t) = \\left( I + \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\left( \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ F(Z, \\Delta t) = I + \\Delta t Z + \\frac{\\Delta t^2}{2}Z^2 + \\frac{\\Delta t^3}{4}Z^3 + \\mathcal{O}(\\Delta t^4) $$\n使用此展开式，ADI 传播算子 $S(\\Delta t)$ 可以写成两个此类级数的乘积，$S(\\Delta t) = F(A_h, \\Delta t) F(B_h, \\Delta t)$：\n$$ S(\\Delta t) = \\left( I + \\Delta t A_h + \\frac{\\Delta t^2}{2}A_h^2 + \\frac{\\Delta t^3}{4}A_h^3 + \\dots \\right) \\left( I + \\Delta t B_h + \\frac{\\Delta t^2}{2}B_h^2 + \\frac{\\Delta t^3}{4}B_h^3 + \\dots \\right) $$\n由于 $A_h$ 和 $B_h$ 对易，我们可以将这些级数相乘，并按 $\\Delta t$ 的幂次收集各项：\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\left( \\frac{\\Delta t^2}{2}A_h^2 + \\Delta t^2 A_h B_h + \\frac{\\Delta t^2}{2}B_h^2 \\right) + \\left( \\frac{\\Delta t^3}{4}A_h^3 + \\frac{\\Delta t^3}{2}A_h B_h^2 + \\frac{\\Delta t^3}{2}A_h^2 B_h + \\frac{\\Delta t^3}{4}B_h^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\n接下来，我们展开未分裂的 Crank-Nicolson 传播算子 $R_{\\mathrm{CN}}(\\Delta t)$。它具有与 $F(Z, \\Delta t)$ 相同的函数形式，但算子为 $Z = A_h+B_h$：\n$$ R_{\\mathrm{CN}}(\\Delta t) = F(A_h+B_h, \\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h+B_h)^3 + \\mathcal{O}(\\Delta t^4) $$\n利用 $A_h$ 和 $B_h$ 的对易性，我们可以展开三次项：\n$$ (A_h+B_h)^3 = A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3 $$\n因此 $R_{\\mathrm{CN}}(\\Delta t)$ 的展开式为：\n$$ R_{\\mathrm{CN}}(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\n最后，我们计算局部格式分裂误差 $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$。我们将两个级数展开式相减。阶数为 $\\Delta t^0$、$\\Delta t^1$ 和 $\\Delta t^2$ 的项是相同的，因此相互抵消。首项误差来自于 $\\mathcal{O}(\\Delta t^3)$ 项的差：\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) - (A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (2-3)A_h^2 B_h + (2-3)A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ -A_h^2 B_h - A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = -\\frac{\\Delta t^3}{4} A_h B_h (A_h+B_h) + \\mathcal{O}(\\Delta t^4) $$\n由于 $A_h$ 和 $B_h$ 通常是非零算子（表示二阶导数），$\\Delta t^3$ 的系数不为零。因此，格式分裂误差中的首项是关于 $\\Delta t$ 的三阶项。\n因此，使得 $E_{\\mathrm{spl}}(\\Delta t) = \\mathcal{O}(\\Delta t^p)$ 成立的最小整数 $p$ 是 $p=3$。", "answer": "$$\\boxed{3}$$", "id": "3128240"}, {"introduction": "现在，我们将前一个练习中关于分裂误差的理论洞察力应用于一个强大的实际问题：自适应时间步进。这个高级练习要求您实现一个自适应时间步长控制器[@problem_id:3363234]。其核心思想是利用分裂效应（splitting defect）$d^{n+1}(\\Delta t; u^n) = \\Delta t^2 A_x A_y u^n$作为分裂误差的可计算度量，从而自动调整时间步长$\\Delta t$，这不仅显著提升了模拟的效率，也增强了数值解的可靠性。", "problem": "你需要为一种扩散型偏微分方程设计并实现一个用于线性交替方向隐式 (ADI) 方法的自适应时间步长控制器。出发点是单位正方形上的二维扩散方程，带有齐次狄利克雷边界条件，\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}, \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\n其中\n$$\nu(0,x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad u(t,0,y)=u(t,1,y)=u(t,x,0)=u(t,x,1)=0.\n$$\n使用一个在 $x$ 方向有 $N_x$ 个内部点、在 $y$ 方向有 $N_y$ 个内部点的均匀网格来离散化空间域，其间距分别为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。令 $u^n \\in \\mathbb{R}^{N_y \\times N_x}$表示在时间层 $t^n$ 的网格函数，代表内部网格点上的值。定义沿每个轴作用的一维中心二阶差分算子，并采用齐次狄利克雷边界处理，从而得到作用于 $u^n$ 的线性算子 $A_x$ 和 $A_y$，其定义如下\n$$\nA_x u[i,j] = k_x \\frac{u[i,j-1] - 2u[i,j] + u[i,j+1]}{h_x^2}, \\quad A_y u[i,j] = k_y \\frac{u[i-1,j] - 2u[i,j] + u[i+1,j]}{h_y^2},\n$$\n其中超出范围的索引对应于等于$0$的边界值。考虑分解的隐式欧拉 ADI 更新，\n$$\n(I - \\Delta t A_y) v = u^n, \\quad (I - \\Delta t A_x) u^{n+1} = v,\n$$\n这在代数上等价于 $(I - \\Delta t A_x)(I - \\Delta t A_y)u^{n+1} = u^n$。\n\n在每一步开始时，使用线性化缺陷公式来估计分裂缺陷\n$$\nd^{n+1}(\\Delta t; u^n) = \\Big(I - \\Delta t A_x\\Big)\\Big(I - \\Delta t A_y\\Big) u^n - \\Big(I - \\Delta t (A_x + A_y)\\Big) u^n,\n$$\n它可以精确地简化为\n$$\nd^{n+1}(\\Delta t; u^n) = \\Delta t^2 A_x A_y u^n,\n$$\n并使用其无穷范数 $\\|d^{n+1}\\|_\\infty$ 来自适应地控制 $\\Delta t$，以使这个分裂误差的替代指标保持在目标容差之内。对于每一步，定义一个局部容差\n$$\n\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty.\n$$\n如果 $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$，则接受该步；否则，拒绝它。在两种情况下，都使用一个比例控制器来更新下一个时间步长，该控制器基于缺陷随时间步长变化的预期二次标度关系，\n$$\n\\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2},\n$$\n并受到用户选择的乘性限制 $g_{\\min} \\le \\Delta t_{\\text{new}}/\\Delta t \\le g_{\\max}$ 和绝对最大值 $\\Delta t \\le \\Delta t_{\\max}$ 的约束。这里的 $\\varepsilon$ 是一个微小的正数，以避免除以零。在拒绝时，强制 $\\Delta t_{\\text{new}} \\le \\Delta t$；在接受时，允许 $\\Delta t_{\\text{new}} \\ge \\Delta t$ 在所选边界内。通过根据需要将 $\\Delta t$ 裁剪到剩余时间，确保时间积分精确地落在最终时间点上。\n\n按照以下要求实现上述过程：\n- 对每个接受的步，使用 ADI 分解，并在每个方向上通过三对角求解来处理两个线性系统。\n- 对 $\\|u^n\\|_\\infty$ 和 $\\|d^{n+1}\\|_\\infty$ 均使用无穷范数。\n- 使用在内部网格点 $x_j = (j+1)h_x$，$y_i = (i+1)h_y$ 上采样的初始条件 $u(0,x,y)=\\sin(\\pi x)\\sin(\\pi y)$。\n\n测试套件。在下面三个参数集上运行你的实现。对于每种情况，返回整个积分过程中控制器产生的被拒绝步数（一个整数）。这三种情况是：\n- 案例1 (均衡扩散): $k_x = 1.0$, $k_y = 1.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, 初始 $\\Delta t_0 = 10^{-4}$, $\\Delta t_{\\max} = 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$。\n- 案例2 (各向异性扩散): $k_x = 1.0$, $k_y = 10.0$, $N_x = 32$, $N_y = 32$, $T = 0.05$, 初始 $\\Delta t_0 = 5 \\cdot 10^{-5}$, $\\Delta t_{\\max} = 5 \\cdot 10^{-3}$, $\\mathrm{rtol} = 5 \\cdot 10^{-4}$, $\\mathrm{atol} = 10^{-8}$。\n- 案例3 (在y方向上退化): $k_x = 1.0$, $k_y = 0.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, 初始 $\\Delta t_0 = 10^{-3}$, $\\Delta t_{\\max} = 2 \\cdot 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$。\n\n所有案例使用的控制器常数：$\\mathrm{safety} = 0.9$，$g_{\\min} = 0.2$，$g_{\\max} = 2.5$，以及 $\\varepsilon = 10^{-300}$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含按测试案例顺序排列的三个整数的逗号分隔列表，并用方括号括起来，例如，\n\"[r1,r2,r3]\"。", "solution": "用户要求实现一个自适应时间步长控制器，用于求解单位正方形 $[0,1] \\times [0,1]$ 上的二维扩散方程的交替方向隐式 (ADI) 方法：\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\n该方程具有齐次狄利克雷边界条件和给定的初始条件 $u(0,x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n\n求解过程首先是离散化问题，然后实现 ADI 时间步进格式，最后集成自适应控制器逻辑。\n\n### 1. 空间离散化\n连续域被离散化为一个包含 $N_y \\times N_x$ 个内部点的网格。在时间 $t^n$ 的解 $u(t,x,y)$ 由一个矩阵 $u^n \\in \\mathbb{R}^{N_y \\times N_x}$ 表示，其中 $u^n_{i,j}$ 近似于点 $(x_j, y_i) = ((j+1)h_x, (i+1)h_y)$ 处的解。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。\n\n二阶偏导数使用中心有限差分进行近似。这产生了两个线性算子 $A_x$ 和 $A_y$，它们作用于网格函数 $u^n$：\n- $A_x$ 将按 $k_x/h_x^2$ 缩放的一维二阶差分模板应用于矩阵 $u^n$ 的每一行。\n- $A_y$ 将按 $k_y/h_y^2$ 缩放的一维二阶差分模板应用于矩阵 $u^n$ 的每一列。\n齐次狄利克雷边界条件通过假设内部域外的任何网格函数值为零来处理。在实现中，这是通过在应用有限差分模板之前用零填充网格函数矩阵来实现的。\n\n### 2. ADI 方法\n时间演化由半离散方程 $\\frac{du}{dt} = (A_x + A_y)u$ 控制。ADI 方法，特别是指定的分解隐式欧拉变体，将时间步长 $\\Delta t$ 分成两个子步骤。这种方法将一个大的二维问题转化为一系列更小的、独立的一维问题，这些问题在计算上求解效率很高。\n\n从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的更新分两个阶段进行：\n1.  **Y方向隐式步**：求解中间状态 $v$：\n    $$ (I - \\Delta t A_y) v = u^n $$\n    该方程代表了一组 $N_x$ 个独立的三对角线性系统，每个系统对应网格函数 $v$ 的一列。\n2.  **X方向隐式步**：求解新状态 $u^{n+1}$：\n    $$ (I - \\Delta t A_x) u^{n+1} = v $$\n    该方程代表了一组 $N_y$ 个独立的三对角线性系统，每个系统对应网格函数 $u^{n+1}$ 的一行。\n\n每组三对角系统都通过单次调用 `scipy.linalg.solve_banded` 高效求解，该函数为此任务进行了优化。对于作用于行的 X 方向步骤，中间矩阵 $v$ 被转置，然后调用求解器，最后将结果转置回来。\n\n### 3. 自适应时间步长控制\n自适应控制器调整时间步长 $\\Delta t$，以将局部误差的度量维持在指定容差以下。这通过在解平滑时允许更大的步长、在解快速变化时允许更小的步长来提高效率。\n\n-   **误差估计**：用于控制的误差是基于 ADI 分裂缺陷的替代指标，由 $d^{n+1} = \\Delta t^2 A_x A_y u^n$ 给出。其无穷范数 $\\|d^{n+1}\\|_\\infty$ 被用作当前步骤的误差度量。该量是通过将实现的离散算子 $A_y$ 然后是 $A_x$ 顺序应用于当前解 $u^n$ 来计算的。\n\n-   **容差**：在每一步，局部容差计算为 $\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty$，其中 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 分别是绝对和相对容差参数。\n\n-   **接受/拒绝机制**：尝试大小为 $\\Delta t$ 的一步。\n    - 如果 $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$，则该步被**接受**。解和时间被更新：计算 $u^{n+1}$ 并使其成为新的 $u^n$，时间 $t$ 前进 $\\Delta t$。\n    - 如果 $\\|d^{n+1}\\|_\\infty > \\mathrm{tol}_n$，则该步被**拒绝**。解和时间不改变，被拒绝的步数加一。\n\n-   **步长更新**：在两种情况（接受或拒绝）下，都使用比例-积分（PI）型控制律计算新的预期时间步长 $\\Delta t_{\\text{new}}$。问题指定了一个比例控制器：\n    $$ \\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2} $$\n    微小值 $\\varepsilon$ 防止了除以零。所得的步长变化率 $\\Delta t_{\\text{new}}/\\Delta t$ 被限制在 $[g_{\\min}, g_{\\max}]$ 内，并且新步长由绝对最大值 $\\Delta t_{\\max}$ 封顶。如果一个步骤被拒绝，则使用新计算的 $\\Delta t_{\\text{new}}$（它会更小）来重试该步骤。如果被接受，$\\Delta t_{\\text{new}}$ 将用于后续的时间步。\n\n### 4. 实现逻辑\n整个过程被封装在一个函数中，该函数针对给定的参数集运行仿真。\n1.  初始化网格，通过采样 $\\sin(\\pi x)\\sin(\\pi y)$ 初始化初始条件 $u^0$，当前时间 $t=0$，初始步长 $\\Delta t = \\Delta t_0$，以及一个用于被拒绝步数的计数器。\n2.  一个 `while` 循环在 $t  T$ 的条件下运行。\n3.  在循环内部，首先裁剪当前 $\\Delta t$ 以确保不超过 $\\Delta t_{\\max}$，并确保最后一步正好落在 $t=T$ 上。\n4.  基于当前 $u^n$ 和尝试的 $\\Delta t$ 计算后验误差 $\\|d^{n+1}\\|_\\infty$。\n5.  做出接受或拒绝的决定。\n6.  使用控制公式和相关边界计算新的步长。\n7.  如果步长被接受，则推进时间和解。下一次迭代的 `dt` 设置为新计算的步长。\n8.  如果步长被拒绝，则计数器加一，下一次迭代（即重试当前步）的 `dt` 设置为新计算的（更小的）步长。\n9.  此过程重复进行，直到达到最终时间 $T$。返回被拒绝的总步数。此逻辑应用于指定的三个测试案例中的每一个。\n\n当 $k_y = 0$ 时（如案例3），会出现一种特殊情况。此时 $A_y=0$，使得分裂缺陷 $d^{n+1}$恒等于零。实现正确地处理了这种情况：误差范数始终为零，因此每一步都被接受，步长控制器将以最大允许速率 $g_{\\max}$ 增加 $\\Delta t$，直到受到 $\\Delta t_{\\max}$ 的限制。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(kx, ky, Nx, Ny, T, dt0, dt_max, rtol, atol, safety, g_min, g_max, eps):\n    \"\"\"\n    Runs the adaptive ADI simulation for one parameter set.\n    \"\"\"\n    # 1. Grid and Initial Condition Setup\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    \n    x = (np.arange(Nx) + 1) * hx\n    y = (np.arange(Ny) + 1) * hy\n    X, Y = np.meshgrid(x, y)\n    \n    u = np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    t = 0.0\n    dt = dt0\n    rejected_steps = 0\n\n    # Helper functions for applying discrete operators\n    def apply_Ax(u_mat, k, h):\n        padded = np.pad(u_mat, ((0, 0), (1, 1)), 'constant')\n        diff = padded[:, :-2] - 2 * padded[:, 1:-1] + padded[:, 2:]\n        return (k / h**2) * diff\n\n    def apply_Ay(u_mat, k, h):\n        padded = np.pad(u_mat, ((1, 1), (0, 0)), 'constant')\n        diff = padded[:-2, :] - 2 * padded[1:-1, :] + padded[2:, :]\n        return (k / h**2) * diff\n\n    # 2. Main Time-Stepping Loop\n    while t  T:\n        # Clip dt by global max and to land on T\n        dt_attempt = min(dt, dt_max)\n        if t + dt_attempt > T:\n            dt_attempt = T - t\n        \n        # 3. Defect and Tolerance Calculation\n        u_norm = np.max(np.abs(u))\n        tol = atol + rtol * u_norm\n\n        if ky == 0.0 or kx == 0.0:\n            err_norm = 0.0\n        else:\n            d = (dt_attempt**2) * apply_Ax(apply_Ay(u, ky, hy), kx, hx)\n            err_norm = np.max(np.abs(d))\n\n        # 4. Accept/Reject Step\n        accepted = err_norm = tol\n\n        # 5. Calculate new step size\n        if err_norm  eps: # To handle err_norm == 0 or very small\n             factor = g_max\n        else:\n            factor_raw = safety * (tol / err_norm)**0.5\n            factor = max(g_min, min(g_max, factor_raw))\n        \n        dt_new = dt_attempt * factor\n\n        if accepted:\n            # Perform ADI step\n            # Y-sweep: (I - dt*Ay) v = u\n            if ky != 0.0:\n                cy = -dt_attempt * ky / hy**2\n                diag_y = 1.0 - 2.0 * cy\n                ab_y = np.zeros((3, Ny))\n                ab_y[0, 1:] = cy\n                ab_y[1, :] = diag_y\n                ab_y[2, :-1] = cy\n                v = solve_banded((1, 1), ab_y, u, overwrite_ab=True, overwrite_b=False)\n            else:\n                v = u\n\n            # X-sweep: (I - dt*Ax) u_new = v\n            if kx != 0.0:\n                cx = -dt_attempt * kx / hx**2\n                diag_x = 1.0 - 2.0 * cx\n                ab_x = np.zeros((3, Nx))\n                ab_x[0, 1:] = cx\n                ab_x[1, :] = diag_x\n                ab_x[2, :-1] = cx\n                u_new_T = solve_banded((1, 1), ab_x, v.T, overwrite_ab=True, overwrite_b=False)\n                u = u_new_T.T\n            else:\n                u = v\n            \n            t += dt_attempt\n            dt = dt_new\n        else:\n            rejected_steps += 1\n            # Retry with smaller step size\n            dt = dt_new\n            \n    return rejected_steps\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Controller constants\n    safety = 0.9\n    g_min = 0.2\n    g_max = 2.5\n    eps = 1e-300\n\n    test_cases = [\n        # Case 1: balanced diffusion\n        {\"kx\": 1.0, \"ky\": 1.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1, \n         \"dt0\": 1e-4, \"dt_max\": 1e-2, \"rtol\": 1e-3, \"atol\": 1e-8},\n        # Case 2: anisotropic diffusion\n        {\"kx\": 1.0, \"ky\": 10.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.05,\n         \"dt0\": 5e-5, \"dt_max\": 5e-3, \"rtol\": 5e-4, \"atol\": 1e-8},\n        # Case 3: degenerate in y\n        {\"kx\": 1.0, \"ky\": 0.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1,\n         \"dt0\": 1e-3, \"dt_max\": 2e-2, \"rtol\": 1e-3, \"atol\": 1e-8}\n    ]\n\n    results = []\n    for params in test_cases:\n        rejections = run_simulation(\n            kx=params[\"kx\"], ky=params[\"ky\"],\n            Nx=params[\"Nx\"], Ny=params[\"Ny\"],\n            T=params[\"T\"], dt0=params[\"dt0\"], dt_max=params[\"dt_max\"],\n            rtol=params[\"rtol\"], atol=params[\"atol\"],\n            safety=safety, g_min=g_min, g_max=g_max, eps=eps\n        )\n        results.append(rejections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3363234"}]}