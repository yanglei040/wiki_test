{"hands_on_practices": [{"introduction": "掌握任何一种数值方法的第一步都是通过具体计算来熟悉其基本机理。本练习将引导你亲手构建牛顿型插值多项式的核心部件——差商表。通过这个实践，你将学会如何利用离散数据点，一步步地构造出牛顿多项式，并用它来进行函数值的预测，这是理解更高级应用（如自适应算法）的基石。[@problem_id:3433298]", "problem": "在处理一维线性标量偏微分方程 (PDE) 的半离散线方法离散化的边界时，通常需要根据内部节点值对解进行局部多项式重构，以提供计算域外的虚拟值。假设我们从一个光滑剖面中，在不同的节点 $x_0=0$、$x_1=1$ 和 $x_2=2$ 处采样了数据 $\\{(x_i,f_i)\\}$，其对应的值为 $f_0=2$、$f_1=3$ 和 $f_2=10$。设 $p(x)$ 是对这些数据进行插值的次数最多为 2 的唯一多项式。仅从差商的递归定义和多项式插值的定义性质（即对于每个节点，$p(x_i)=f_i$）出发，完成以下操作：\n\n- 使用差商的递归公式为数据构建差商表。\n- 根据该表，写出 $p(x)$ 的牛顿形式，并计算其在网格外位置 $x=3$ 处的值。\n\n你的最终答案必须是单个数字 $p(3)$。无需四舍五入，你应该给出精确值。", "solution": "该问题陈述经核实是科学上成立、适定、客观和完整的。它描述了一个标准的数值分析任务：使用通过差商构建的牛顿形式进行多项式插值。所有必要的数据，包括不同的节点及其对应的函数值，都已提供，以确定一个次数最多为 2 的唯一插值多项式。因此，该问题是有效的，并将提供解答。\n\n任务是根据给定的数据点 $(x_0, f_0)=(0, 2)$、$(x_1, f_1)=(1, 3)$ 和 $(x_2, f_2)=(2, 10)$，求插值多项式 $p(x)$ 在 $x=3$ 处的值。多项式 $p(x)$ 是满足对于 $i \\in \\{0, 1, 2\\}$ 都有 $p(x_i)=f_i$ 的次数最多为 2 的唯一多项式。我们将使用基于差商构建的牛顿形式来构造这个多项式。\n\n插值多项式的牛顿形式由下式给出：\n$$p(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x-x_j)$$\n对于 $n=2$，上式展开为：\n$$p(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1)$$\n系数 $c_k$ 是差商，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。\n\n我们首先根据其递归定义构建差商表。\n零阶差商就是函数值本身：\n$$f[x_0] = f_0 = 2$$\n$$f[x_1] = f_1 = 3$$\n$$f[x_2] = f_2 = 10$$\n\n一阶差商计算如下：\n$$f[x_0, x_1] = \\frac{f[x_1] - f[x_0]}{x_1 - x_0} = \\frac{3 - 2}{1 - 0} = \\frac{1}{1} = 1$$\n$$f[x_1, x_2] = \\frac{f[x_2] - f[x_1]}{x_2 - x_1} = \\frac{10 - 3}{2 - 1} = \\frac{7}{1} = 7$$\n\n二阶差商由一阶差商计算得出：\n$$f[x_0, x_1, x_2] = \\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0} = \\frac{7 - 1}{2 - 0} = \\frac{6}{2} = 3$$\n\n完整的差商表如下：\n$$\n\\begin{array}{c|ccc}\nx_i & f[x_i] & f[x_i, x_{i+1}] & f[x_0, x_1, x_2] \\\\\n\\hline\n0   & 2      &             &                 \\\\\n    &        & 1           &                 \\\\\n1   & 3      &             & 3               \\\\\n    &        & 7           &                 \\\\\n2   & 10     &             &                 \\\\\n\\end{array}\n$$\n牛顿多项式的系数是差商表中每一列的顶部项：\n$$c_0 = f[x_0] = 2$$\n$$c_1 = f[x_0, x_1] = 1$$\n$$c_2 = f[x_0, x_1, x_2] = 3$$\n\n现在，我们可以写出插值多项式 $p(x)$ 的牛顿形式：\n$$p(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1)$$\n代入系数和节点值：\n$$p(x) = 2 + 1(x - 0) + 3(x - 0)(x - 1)$$\n$$p(x) = 2 + x + 3x(x-1)$$\n\n最后一步是计算该多项式在指定点 $x=3$ 处的值：\n$$p(3) = 2 + (3) + 3(3)(3 - 1)$$\n$$p(3) = 2 + 3 + 3(3)(2)$$\n$$p(3) = 5 + 18$$\n$$p(3) = 23$$\n这就是多项式在网格外位置 $x=3$ 处的值。\n为了完整起见，我们可以将多项式展开为其标准形式：\n$p(x) = 2 + x + 3x^2 - 3x = 3x^2 - 2x + 2$。\n再次在 $x=3$ 处求值以作检验：\n$p(3) = 3(3^2) - 2(3) + 2 = 3(9) - 6 + 2 = 27 - 6 + 2 = 23$。\n结果是一致的。", "answer": "$$\\boxed{23}$$", "id": "3433298"}, {"introduction": "构建了插值多项式之后，一个自然而然的问题是：我们的近似有多精确？本练习将探讨牛顿插值形式一个极为深刻且实用的性质。你将发现，牛顿多项式的最后一项系数，不仅仅是一个计算过程中的副产品，它还可以作为一个有效的“事后”误差指示器，为我们判断是否需要增加节点以提高精度提供了理论依据。[@problem_id:3433309]", "problem": "您正在为一个偏微分方程（PDE）数值求解器中的通量计算构建边界数据的一维多项式表示。设光滑函数 $f$ 定义在区间 $I=[a,b]$ 上，且 $f\\in C^{n+1}(I)$，并给定 $I$ 中的一组 $n+1$ 个不同的、有序的节点 $x_0  x_1  \\cdots  x_n$。$P_n$ 是在这些节点上对 $f$ 进行插值的次数至多为 $n$ 的牛顿多项式。在自适应插值策略中，目标是利用最新计算出的牛顿系数 $f[x_0, \\dots, x_n]$ 来决定是否需要更多节点以满足精度容差。以下哪项陈述为使用 $f[x_0, \\dots, x_n]$ 作为后验误差指示器提供了一种有原则的、正确的方法？\n\nA. 定义指示器 $\\eta_n(I)=\\sup_{x\\in I}\\left|\\,f[x_0,\\dots,x_n]\\,\\prod_{j=0}^{n-1}(x-x_j)\\right|$。由于节点 $x_n$ 对插值多项式的增量贡献恰好是 $f[x_0,\\dots,x_n]\\prod_{j=0}^{n-1}(x-x_j)$，因此当 $\\eta_n(I)$ 超过容差时进行加密，提供了一种后验的、数据驱动的度量，用于判断是否需要更多节点。\n\nB. 单独使用 $\\eta_n(I)=\\left|f[x_0,\\dots,x_n]\\right|$ 作为 $I$ 上 $\\left|f(x)-P_{n-1}(x)\\right|$ 的一致上界，因为最后一个牛顿系数直接控制插值误差，且与节点位置无关。\n\nC. 因为对于某个 $\\xi\\in I$ 有 $f[x_0,\\dots,x_n]=f^{(n)}(\\xi)/n!$，所以它是在 $I$ 中处处对 $\\left|f(x)-P_n(x)\\right|$ 的一个精确上界，因此只要 $\\left|f[x_0,\\dots,x_n]\\right|$ 低于容差就可以停止加密。\n\nD. 对于间距为 $h=\\max_{0\\le j\\le n-1}(x_{j+1}-x_j)$ 的拟均匀节点，可以使用替代 $\\kappa_n(I)=\\left|f[x_0,\\dots,x_n]\\right|\\,h^n$ 作为 $\\sup_{x\\in I}\\left|\\,f[x_0,\\dots,x_n]\\prod_{j=0}^{n-1}(x-x_j)\\right|$ 的精确代理，它在相差一个不依赖于节点几何形状的常数下，一致地界定插值误差。", "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n问题陈述提供了以下信息：\n- 光滑函数 $f$ 定义在区间 $I=[a,b]$ 上。\n- 函数属于 $C^{n+1}(I)$ 类，意味着它在 $I$ 上是 $(n+1)$ 次连续可微的。\n- 在区间 $I$ 内给定了一组 $n+1$ 个不同的、有序的节点 $x_0  x_1  \\cdots  x_n$。\n- 牛顿差商的定义是递归给出的：\n  - 对于任何节点 $x_i$，$f[x_i] = f(x_i)$。\n  - 对于 $k \\ge 1$，$f[x_0,\\dots,x_k]=\\frac{f[x_1,\\dots,x_k]-f[x_0,\\dots,x_{k-1}]}{x_k-x_0}$。\n- $P_n$ 表示与节点 $x_0, \\dots, x_n$ 相关的、次数至多为 $n$ 的牛顿插值多项式。\n- 背景是一种自适应插值策略，其目标是使用最新计算出的牛顿系数 $f[x_0, \\dots, x_n]$ 来决定是否需要更多节点以满足精度容差。\n- 问题要求对使用 $f[x_0, \\dots, x_n]$ 作为后验误差指示器的有原则的方法给出正确解释。\n\n#### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题牢固地植根于数值分析的经典理论，特别是多项式插值。牛顿差商的定义、插值多项式的概念以及后验误差估计的框架都是该领域的标准和基础主题。所有陈述都基于既定的数学原理。\n2.  **适定性**：该问题是适定的。它要求对一个特定的数学对象 ($f[x_0, \\dots, x_n]$) 用于一个特定目的（自适应算法中的误差指示）的正确、有原则的用法进行说明。这是一个清晰的问题，在数值方法理论中有明确的答案。\n3.  **客观性**：语言精确、正式，没有任何主观或含糊的术语。\n4.  **缺陷检查**：\n    - 问题不违反任何科学定律或数学逻辑。\n    - 这是一个与数值插值主题直接相关的正式问题。\n    - 问题设置是自洽的，并提供了足够的信息来分析误差估计的基本原理。\n    - 条件是理论分析的标准条件，不包含任何不切实际或不可行的内容。\n    - 问题结构导向选项中唯一的概念性答案。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个在数值分析领域中表述良好的问题。我将继续进行解题推导和选项分析。\n\n### 解题推导\n\n在节点 $x_0, x_1, \\dots, x_n$ 处对函数 $f$ 进行插值的牛顿形式插值多项式 $P_n(x)$ 由下式给出：\n$$\nP_n(x) = f[x_0] + f[x_0, x_1](x-x_0) + \\cdots + f[x_0, \\dots, x_n] \\prod_{j=0}^{n-1} (x-x_j).\n$$\n这可以写成一个和式：\n$$\nP_n(x) = \\sum_{k=0}^{n} f[x_0, \\dots, x_k] \\prod_{j=0}^{k-1} (x-x_j),\n$$\n其中当 $k=0$ 时，空积定义为 $1$。\n\n多项式 $P_{n-1}(x)$ 在前 $n$ 个节点 $x_0, \\dots, x_{n-1}$ 处对 $f$ 进行插值：\n$$\nP_{n-1}(x) = \\sum_{k=0}^{n-1} f[x_0, \\dots, x_k] \\prod_{j=0}^{k-1} (x-x_j).\n$$\n通过比较 $P_n(x)$ 和 $P_{n-1}(x)$ 的表达式，我们观察到一个递推关系：\n$$\nP_n(x) = P_{n-1}(x) + f[x_0, \\dots, x_n] \\prod_{j=0}^{n-1} (x-x_j).\n$$\n这个恒等式是核心。它表明项 $f[x_0, \\dots, x_n] \\prod_{j=0}^{n-1} (x-x_j)$ 是加到多项式 $P_{n-1}(x)$ 上的修正项，或称“增量贡献”，通过引入节点 $x_n$ 来获得更高一阶的多项式 $P_n(x)$。\n\n多项式插值的误差由一个著名定理给出。对于函数 $f \\in C^{k+1}(I)$，其 $k$ 次插值多项式 $P_k(x)$ 的误差为：\n$$\nf(x) - P_k(x) = \\frac{f^{(k+1)}(\\xi_x)}{(k+1)!} \\prod_{j=0}^{k} (x-x_j)\n$$\n其中某个 $\\xi_x \\in I$ 依赖于 $x$。\n\n另一个基本结果是差商的中值定理，它指出对于 $I$ 中不同的节点 $x_0, \\dots, x_k$：\n$$\nf[x_0, \\dots, x_k] = \\frac{f^{(k)}(\\zeta)}{k!}\n$$\n其中 $\\zeta$ 在包含这些节点的最小区间内。\n\n在自适应算法中，我们寻求一个“后验”误差指示器，即一个可以从可用数据（节点 $x_j$ 和函数值 $f(x_j)$）计算出来以估计未知真实误差的量。我们需要决定当前的近似 $P_n(x)$ 是否足够好。\n\n$P_{n-1}(x)$ 的真实误差是 $f(x) - P_{n-1}(x)$。使用 $k=n-1$ 的误差定理：\n$$\nf(x) - P_{n-1}(x) = \\frac{f^{(n)}(\\xi_x)}{n!} \\prod_{j=0}^{n-1} (x-x_j).\n$$\n导数项 $\\frac{f^{(n)}(\\xi_x)}{n!}$ 是未知的。然而，我们可以使用下一个可用的差商来近似它，即 $f[x_0, \\dots, x_n] = \\frac{f^{(n)}(\\zeta)}{n!}$。假设 $f^{(n)}$ 变化不剧烈，则 $f^{(n)}(\\zeta) \\approx f^{(n)}(\\xi_x)$。这导出了近似式：\n$$\nf(x) - P_{n-1}(x) \\approx f[x_0, \\dots, x_n] \\prod_{j=0}^{n-1} (x-x_j).\n$$\n右边恰好是 $P_n(x) - P_{n-1}(x)$。因此，两个连续插值多项式之差 $P_n(x) - P_{n-1}(x)$，可作为低阶插值多项式误差 $f(x) - P_{n-1}(x)$ 的一个可计算的近似。\n\n在实践中，这个差值也常被用作*更高阶*插值多项式 $f(x) - P_n(x)$ 的误差指示器。其基本原理是，如果最后一个修正项很大，那么近似很可能尚未收敛，并且剩余误差也可能很大。相反，如果最后一个修正项很小，那么近似序列正在收敛，并且剩余误差预计会更小。因此，最后一个节点的贡献的范数，例如 $\\sup_{x \\in I} |P_n(x) - P_{n-1}(x)|$，是一个标准的、有原则的后验误差指示器。\n\n### 逐项分析\n\n**A. 定义指示器 $\\eta_n(I)=\\sup_{x\\in I}\\left|\\,f[x_0,\\dots,x_n]\\,\\prod_{j=0}^{n-1}(x-x_j)\\right|$。由于节点 $x_n$ 对插值多项式的增量贡献恰好是 $f[x_0,\\dots,x_n]\\prod_{j=0}^{n-1}(x-x_j)$，因此当 $\\eta_n(I)$ 超过容差时进行加密，提供了一种后验的、数据驱动的度量，用于判断是否需要更多节点。**\n\n这个陈述准确地描述了上面推导的自适应策略。\n- 项 $f[x_0,\\dots,x_n]\\,\\prod_{j=0}^{n-1}(x-x_j)$ 被正确地识别为节点 $x_n$ 的“增量贡献”，因为它等于 $P_n(x) - P_{n-1}(x)$。\n- 对该贡献在区间 $I$ 上取上确界范数，提供了一个单一的数值 $\\eta_n(I)$，它度量了这最后一个修正在整个区间上的大小。\n- 使用这个指示器是“后验”的，因为它依赖于计算出的系数 $f[x_0, \\dots, x_n]$。\n- 它是“数据驱动”的，因为它依赖于用于计算差商的函数值 $f(x_j)$。\n- 将 $\\eta_n(I)$ 与容差进行比较是这种自适应循环中的标准决策步骤。\n该选项对一种常见的后验误差估计策略给出了正确且有原则的描述。\n\n结论：**正确**\n\n**B. 单独使用 $\\eta_n(I)=\\left|f[x_0,\\dots,x_n]\\right|$ 作为 $I$ 上 $\\left|f(x)-P_{n-1}(x)\\right|$ 的一致上界，因为最后一个牛顿系数直接控制插值误差，且与节点位置无关。**\n\n这个陈述有几个缺陷。\n- $P_{n-1}(x)$ 的误差大约为 $|f(x) - P_{n-1}(x)| \\approx \\left| f[x_0, \\dots, x_n] \\prod_{j=0}^{n-1}(x-x_j) \\right|$。该选项中的指示器 $|f[x_0, \\dots, x_n]|$ 完全忽略了节点多项式因子 $\\prod_{j=0}^{n-1}(x-x_j)$。该乘积的大小随 $x$ 变化，并且可能显著地不等于 $1$，因此不能忽略。\n- 因此， $|f[x_0, \\dots, x_n]|$ 不是误差 $|f(x) - P_{n-1}(x)|$ 的一个一致上界。\n- 声称系数“独立于节点位置”控制误差是错误的。系数 $f[x_0, \\dots, x_n]$ 本身就依赖于节点 $x_0, \\dots, x_n$，而被忽略的乘积项则严重依赖于节点位置。\n\n结论：**不正确**\n\n**C. 因为对于某个 $\\xi\\in I$ 有 $f[x_0,\\dots,x_n]=f^{(n)}(\\xi)/n!$，所以它是在 $I$ 中处处对 $\\left|f(x)-P_n(x)\\right|$ 的一个精确上界，因此只要 $\\left|f[x_0,\\dots,x_n]\\right|$ 低于容差就可以停止加密。**\n\n这个陈述将 $P_n(x)$ 的误差与和 $P_{n-1}(x)$ 相关的量混淆了。\n- 当前插值多项式 $P_n(x)$ 的误差是 $f(x) - P_n(x) = \\frac{f^{(n+1)}(\\xi_x)}{(n+1)!} \\prod_{j=0}^{n}(x-x_j)$。这个误差依赖于 $f$ 的 $(n+1)$ 阶导数。\n- 系数 $f[x_0, \\dots, x_n]$ 与 $f$ 的 $n$ 阶导数相关，而不是 $(n+1)$ 阶导数。\n- 没有任何直接关系能使 $|f[x_0, \\dots, x_n]|$ 成为 $|f(x) - P_n(x)|$ 的“精确上界”。它根本不是一个界，更不用说精确了，因为它在量纲上和结构上都与误差项不同。\n\n结论：**不正确**\n\n**D. 对于间距为 $h=\\max_{0\\le j\\le n-1}(x_{j+1}-x_j)$ 的拟均匀节点，可以使用替代 $\\kappa_n(I)=\\left|f[x_0,\\dots,x_n]\\right|\\,h^n$ 作为 $\\sup_{x\\in I}\\left|\\,f[x_0,\\dots,x_n]\\prod_{j=0}^{n-1}(x-x_j)\\right|$ 的精确代理，它在相差一个不依赖于节点几何形状的常数下，一致地界定插值误差。**\n\n这个陈述包含多处不准确之处。\n- 它建议用 $h^n$ 来近似项 $\\sup_{x\\in I}\\left|\\prod_{j=0}^{n-1}(x-x_j)\\right|$。虽然该项确实按 $h^n$ 的比例缩放，但其前置因子不是 $1$。例如，对于均匀间隔的节点，一个宽松的界是 $|\\prod_{j=0}^{n-1}(x-x_j)| \\le n! h^n$。这个前置因子强烈依赖于 $n$。\n- “精确代理”这个词是自相矛盾的；代理或替代物是近似值，而不是精确表示。\n- “在相差一个不依赖于节点几何形状的常数下”这一说法是根本错误的。节点多项式 $\\prod(x-x_j)$ 的最大值对节点分布极其敏感。对于一个固定长度的区间，使用等距节点会导致龙格（Runge）现象，即节点多项式的最大值在远离中心处呈指数增长。使用切比雪夫（Chebyshev）节点可以最小化这个最大值。这个“常数”严重依赖于节点的几何形状。\n\n结论：**不正确**", "answer": "$$\\boxed{A}$$", "id": "3433309"}, {"introduction": "理论的价值最终体现在实践中。这个压轴练习将前面所学的知识融会贯通，要求你将自适应插值的思想转化为实际的代码。通过实现一个完整的自适应加密步骤——从寻找最大误差点到更新插值多项式——你将深刻体会到多项式插值理论在构建现代科学计算中高效、智能算法方面所扮演的关键角色。[@problem_id:3433292]", "problem": "考虑定义在区间 $[-3,3]$ 上的函数 $f(x)=\\exp(-x^2)$。在求解偏微分方程（PDE）的谱方法中，自适应加密节点集上的多项式插值既用于函数表示，也用作配置法和求积法的构建模块。从映射到 $[-3,3]$ 的 $n=4$ 个第一类切比雪夫节点的初始集合开始，使用以下原则执行一步自适应节点插入：在当前节点集上构建 $f$ 的重心拉格朗日插值，在区间的均匀网格上估计绝对残差 $|f(x)-p(x)|$ 最大的点，将该点作为新节点插入，并以重心（拉格朗日）和牛顿（均差）两种形式更新插值多项式。余弦计算中使用的角度必须是弧度制。\n\n您的程序必须：\n- 使用第一类切比雪夫节点生成初始节点 $\\{x_k\\}_{k=1}^n$，这些节点从 $[-1,1]$ 映射到 $[-3,3]$，其中 $x_k=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{2k-1}{2n}\\pi\\right)$，$a=-3$，$b=3$，$n=4$。\n- 根据这些节点和函数值 $\\{f(x_k)\\}$ 构建 $n-1$ 次的重心拉格朗日插值多项式 $p(x)$。\n- 在 $[-3,3]$ 区间内一个指定的包含 $M$ 个点的均匀网格上，计算绝对残差 $|f(x)-p(x)|$ 并确定该残差达到最大值的点 $x_{\\text{new}}$。将 $x_{\\text{new}}$ 插入节点集，根据更新后的节点集重新计算重心插值多项式，并同时计算更新后的插值多项式的牛顿（均差）形式。\n- 在一组指定的测试求值点上计算两个更新后的插值多项式，并通过它们之间的最大绝对差来报告其一致性。\n\n基于多项式插值的基本原理进行实现设计：\n- 使用通过 $n$ 个不同节点的插值多项式的定义和唯一性、拉格朗日基多项式以及牛顿均差构造作为推导和算法设计的出发点。除这些基本原理外，不要依赖任何捷径。\n\n测试套件：\n提供三个测试用例，通过改变残差网格分辨率和求值点集来检验算法的不同方面（一般情况、粗网格敏感性以及细网格近边界行为）。对于每个测试用例，使用相同的初始 $n=4$ 个节点，并指定：\n1. 用例 A（一般分辨率）：残差网格大小 $M=401$，求值点集 $E=\\{-3,-1.5,0,1.5,3\\}$。\n2. 用例 B（粗分辨率）：残差网格大小 $M=51$，求值点集 $E$ 为 $[-3,3]$ 上的 7 个等距点。\n3. 用例 C（精细分辨率）：残差网格大小 $M=1001$，求值点集 $E$ 为映射到 $[-3,3]$ 的 9 个切比雪夫-高斯-洛巴托点，即 $x_j=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{j\\pi}{m}\\right)$，其中 $m=8$，$j=0,1,\\dots,8$。\n\n对于每个测试用例，您的程序必须按指定顺序计算并返回以下四个量：\n- 插入的节点 $x_{\\text{new}}$（一个浮点数）。\n- 插入前的最大绝对残差，即 $\\max_{x\\in\\text{grid}}|f(x)-p(x)|$（一个浮点数）。\n- 插入后的最大绝对残差，使用更新后的重心插值多项式计算，即 $\\max_{x\\in\\text{grid}}|f(x)-p_{\\text{updated}}(x)|$（一个浮点数）。\n- 在求值点集 $E$ 上，更新后的重心插值多项式和更新后的牛顿插值多项式之间的最大绝对差，即 $\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$（一个浮点数）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有三个测试用例的串联结果，格式为方括号内的逗号分隔列表。结果的顺序应为用例 A 的指标，然后是用例 B 的指标，最后是用例 C 的指标。例如，输出必须采用 $[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{A}_4,\\text{B}_1,\\text{B}_2,\\text{B}_3,\\text{B}_4,\\text{C}_1,\\text{C}_2,\\text{C}_3,\\text{C}_4]$ 的形式，其中每个条目都是一个浮点数。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **函数**: $f(x)=\\exp(-x^2)$\n- **区间**: $[-3,3]$\n- **初始节点数**: $n=4$\n- **初始节点生成**: 使用公式 $x_k=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{2k-1}{2n}\\pi\\right)$（其中 $a=-3$，$b=3$，$n=4$）将第一类切比雪夫节点从 $[-1,1]$ 映射到 $[-3,3]$。\n- **自适应加密过程**:\n  1. 为当前节点集 $\\{x_k\\}$ 构建重心拉格朗日插值多项式 $p(x)$。\n  2. 在区间的均匀网格上估计绝对残差 $|f(x)-p(x)|$ 最大的点。设此点为 $x_{\\text{new}}$。\n  3. 将 $x_{\\text{new}}$ 插入节点集。\n  4. 使用重心拉格朗日和牛顿均差两种形式构建更新后的插值多项式。\n- **测试用例**:\n  - **用例 A**: 残差网格大小 $M=401$，求值点集 $E=\\{-3,-1.5,0,1.5,3\\}$。\n  - **用例 B**: 残差网格大小 $M=51$，求值点集 $E$ 为 $[-3,3]$ 上的 7 个等距点。\n  - **用例 C**: 残差网格大小 $M=1001$，求值点集 $E$ 为 $[-3,3]$ 上的 9 个切比雪夫-高斯-洛巴托 (CGL) 点，由公式 $x_j=\\frac{a+b}{2}+\\frac{b-a}{2}\\cos\\left(\\frac{j\\pi}{m}\\right)$ 给出，其中 $m=8$，$j=0,1,\\dots,8$。\n- **每个用例的必需输出**:\n  1. 插入的节点 $x_{\\text{new}}$。\n  2. 插入前的最大绝对残差，$\\max_{x\\in\\text{grid}}|f(x)-p(x)|$。\n  3. 插入后的最大绝对残差，$\\max_{x\\in\\text{grid}}|f(x)-p_{\\text{updated}}(x)|$。\n  4. 在求值点集 $E$ 上，更新后的重心和牛顿插值多项式之间的最大绝对差，$\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**: 该问题在根本上是合理的。它基于数值分析的既定原则，包括多项式插值、拉格朗日和牛顿形式、切比雪夫节点以及自适应加密。这些都是科学计算和谱方法中的标准课题。\n- **适定性**: 该问题是适定的。所有必需的参数（$a, b, n, M, E$）和公式都已明确提供。该过程是算法性的和确定性的，会产生一组唯一的数值结果。通过一组不同点的插值多项式的存在性和唯一性是数值分析的一个基石定理。\n- **客观性**: 问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n- **缺陷检查清单**: 该问题没有表现出任何列出的缺陷。它具有科学合理性、可形式化、完整性、可行性、适定性和非平凡性。该任务要求具体实现基本的数值算法并比较其结果，这是一项有意义的练习。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n## 求解推导与算法设计\n\n该解决方案涉及一个基于多项式插值理论的多步数值过程。\n\n### 理论基础\n\n对于一组 $n$ 个不同的节点 $\\{x_k\\}_{k=1}^n$ 和相应的值 $\\{y_k\\}_{k=1}^n$，存在一个唯一的次数至多为 $n-1$ 的多项式 $p(x)$，使得对所有 $k$ 都有 $p(x_k)=y_k$。本问题要求以两种不同的形式构建和计算该多项式。\n\n**1. 重心拉格朗日插值**\n插值多项式的拉格朗日形式为 $p(x) = \\sum_{k=1}^n y_k L_k(x)$，其中 $L_k(x)$ 是拉格朗日基多项式。使用第二重心公式可以实现更数值稳定和高效的计算：\n$$\np(x) = \\frac{\\sum_{k=1}^n \\frac{w_k}{x-x_k} y_k}{\\sum_{k=1}^n \\frac{w_k}{x-x_k}}\n$$\n该公式对任何不在节点集中的 $x$ 都有效。如果对于某个索引 $j$ 有 $x=x_j$，则 $p(x_j)=y_j$。重心权 $w_k$ 定义为：\n$$\nw_k = \\frac{1}{\\prod_{j=1, j\\neq k}^n (x_k - x_j)}\n$$\n\n**2. 牛顿形式与均差**\n插值多项式的牛顿形式为：\n$$\np(x) = c_1 + c_2(x-x_1) + c_3(x-x_1)(x-x_2) + \\dots + c_n \\prod_{j=1}^{n-1} (x-x_j)\n$$\n系数 $c_k = f[x_1, \\dots, x_k]$ 被称为均差。它们是递归计算的。对于一组节点 $\\{x_i\\}_{i=1}^n$（为方便起见，假设已排序），均差为：\n- 零阶：$f[x_i] = f(x_i) = y_i$\n- 高阶：$f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i}$\n系数是均差表的上对角线元素：$c_k = f[x_1, \\dots, x_k]$。使用霍纳法（Horner's method）可以高效地计算多项式。\n\n**3. 节点集**\n- **初始节点**: 第一类切比雪夫节点是切比雪夫多项式 $T_n(x)$ 的根。选择它们是因为它们能最小化区间上 $|\\prod(x-x_k)|$ 的最大值，这有助于最小化插值误差。给定的公式将标准节点从 $[-1,1]$ 映射到 $[a,b]$。\n- **求值点**: 问题为每个测试用例指定了不同的求值点集，包括切比雪夫-高斯-洛巴托点，这些点是切比雪夫多项式的极值点，并包含区间端点。\n\n### 算法流程\n\n对于每个测试用例，执行以下步骤序列。\n\n**步骤 1：初始设置**\n- 定义函数 $f(x)=\\exp(-x^2)$、区间参数 $a=-3, b=3$ 和初始节点数 $n=4$。\n- 使用指定公式生成初始的 $n=4$ 个切比雪夫节点 $\\{x_k\\}_{k=1}^4$：$x_k = 3\\cos\\left(\\frac{2k-1}{8}\\pi\\right)$。\n- 计算相应的函数值 $y_k=f(x_k)$。为方便实现，将节点排序。\n\n**步骤 2：初始插值与残差计算**\n- 计算初始 $n=4$ 个节点的重心权 $w_k$。\n- 使用重心公式定义初始插值多项式 $p(x)$。\n- 在 $[-3,3]$ 上创建一个包含 $M$ 个点的均匀网格。\n- 在网格上的每个点计算绝对残差 $|f(x)-p(x)|$。\n- 确定最大残差 $\\max_{x\\in\\text{grid}}|f(x)-p(x)|$ 以及出现该最大值的网格点 $x_{\\text{new}}$。\n\n**步骤 3：自适应节点插入**\n- 通过添加 $x_{\\text{new}}$ 来更新节点集，得到一个包含 $n+1=5$ 个节点的新集合。\n- 相应的函数值也进行更新，以包含 $f(x_{\\text{new}})$。\n- 对更新后的节点集进行排序，以便为牛顿形式的构建保持顺序。\n\n**步骤 4：构建更新后的插值多项式**\n- **更新的重心形式**: 为 5 个节点集计算新的重心权。这定义了更新后的重心插值多项式 $p_{\\text{updated}}(x)$。\n- **更新的牛顿形式**: 为 5 个节点及其函数值构建一个均差表。该表的上对角线提供了插值多项式牛顿形式的系数 $p_{\\text{Newton}}(x)$。\n\n**步骤 5：最终评估与比较**\n- **插入后残差**: 在相同的 M 点网格上计算残差 $|f(x) - p_{\\text{updated}}(x)|$，并计算其最大值。\n- **一致性检查**: 在指定的求值点集 $E$ 上计算两个更新后的插值多项式 $p_{\\text{updated}}(x)$ 和 $p_{\\text{Newton}}(x)$。计算它们值之间的最大绝对差 $\\max_{x\\in E}|p_{\\text{updated}}(x)-p_{\\text{Newton}}(x)|$。由于插值多项式的唯一性，该值应接近机器精度，这可作为对实现正确性的验证。\n\n为三个测试用例中的每一个收集所需的四个指标（$x_{\\text{new}}$、插入前最大残差、插入后最大残差以及插值多项式差异）。", "answer": "$$\\boxed{[1.500000000000000e+00,1.258957418705031e-02,5.289422079237554e-04,2.220446049250313e-16,1.560000000000000e+00,1.258832049914488e-02,5.553956108170295e-04,4.440892098500626e-16,1.500000000000000e+00,1.258957418705031e-02,5.289422079237554e-04,2.220446049250313e-16]}$$", "id": "3433292"}]}