{"hands_on_practices": [{"introduction": "在多项式逼近理论中，一个核心概念是找到在某种范数下“最佳”的近似。$L^2$ 投影提供了在均方意义下的最佳逼近，这是谱方法和间断Galerkin方法中能量守恒分析的基石。本练习通过一个具体的例子，计算函数 $f(x)=x^2$ 在一次多项式空间 $\\mathbb{P}_1$ 上的 $L^2$ 投影，并利用勒让德多项式的正交性来验证其最优性。这项实践有助于巩固抽象的希尔伯特空间理论与实际多项式逼近之间的联系。[@problem_id:3408976]", "problem": "考虑用于守恒律的高阶谱方法和间断伽辽金方法中的一维参考单元 $[-1,1]$。设 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 表示在 $[-1,1]$ 上，权函数为 $w(x)=1$ 的勒让德多项式，其特征为 $P_0(x)=1$，$P_1(x)=x$ 以及正交性 $\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}$。设内积和诱导范数分别为 $\\langle u,v\\rangle := \\int_{-1}^{1} u(x)v(x)\\,dx$ 和 $\\|u\\|_{L^2(-1,1)} := \\sqrt{\\langle u,u\\rangle}$。定义 $f(x)=x^2$。\n\n仅使用勒让德基的正交性以及到 $\\mathbb{P}_1 := \\operatorname{span}\\{1,x\\}$ 上的 $L^2$ 投影的变分特征（即投影 $p_1 \\in \\mathbb{P}_1$ 对所有 $q \\in \\mathbb{P}_1$ 满足 $\\langle f-p_1, q\\rangle = 0$），执行以下操作：\n\n1) 计算 $f$ 在基 $\\{P_n\\}$ 中的勒让德模态系数。\n\n2) 使用这些系数构造 $f$ 到 $\\mathbb{P}_1$ 上的 $L^2$ 投影 $p_1$。\n\n3) 通过检验正交条件以及借助由勒让德基的正交性所诱导的勾股分解，来验证 $p_1$ 是 $f$ 的唯一最佳 $L^2$ 逼近。\n\n将您的最终答案写为 $p_1(x)$ 的精确解析表达式。不需要四舍五入，也不涉及单位。您最终方框内的答案必须只包含 $p_1(x)$ 的表达式。", "solution": "该问题是适定的、有科学依据的，并且包含获得唯一解所需的所有信息。这是多项式逼近理论中的一个标准练习。我们将按照指定的三个步骤进行求解。\n\n需要逼近的函数是区间 $[-1,1]$ 上的 $f(x)=x^2$。逼近空间为 $\\mathbb{P}_1$，即次数至多为 1 的多项式空间，它由前两个勒让德多项式 $\\{P_0(x), P_1(x)\\}$ 张成。勒让德多项式 $\\{P_n(x)\\}$ 构成了平方可积函数空间 $L^2(-1,1)$ 关于内积 $\\langle u,v\\rangle = \\int_{-1}^{1} u(x)v(x)\\,dx$ 的一个正交基。其正交性由 $\\langle P_n, P_m \\rangle = \\frac{2}{2n+1}\\delta_{nm}$ 给出。\n\n**1) 勒让德模态系数的计算**\n\n任何函数 $f \\in L^2(-1,1)$ 都可以用其勒让德级数展开表示：\n$$f(x) = \\sum_{n=0}^{\\infty} \\hat{f}_n P_n(x)$$\n其中模态系数 $\\hat{f}_n$ 通过将 $f$ 投影到每个基函数 $P_n$ 上得到：\n$$\\hat{f}_n = \\frac{\\langle f, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{\\langle f, P_n \\rangle}{\\|P_n\\|^2}$$\n使用给定的归一化 $\\|P_n\\|^2 = \\frac{2}{2n+1}$，系数的公式变为：\n$$\\hat{f}_n = \\frac{2n+1}{2} \\int_{-1}^{1} f(x) P_n(x) \\,dx$$\n在本问题中，$f(x)=x^2$。由于 $f(x)$ 是一个 2 次多项式，其勒让德级数将是有限的，在 $n=2$ 处终止。我们可以通过直接的代数运算来找到系数。给定 $P_0(x)=1$ 和 $P_1(x)=x$。第三个勒让德多项式是 $P_2(x) = \\frac{1}{2}(3x^2-1)$。我们可以用 $P_0(x)$ 和 $P_2(x)$ 来表示 $x^2$：\n$$P_2(x) = \\frac{3}{2}x^2 - \\frac{1}{2}P_0(x) \\implies \\frac{3}{2}x^2 = P_2(x) + \\frac{1}{2}P_0(x)$$\n$$x^2 = \\frac{2}{3}P_2(x) + \\frac{1}{3}P_0(x)$$\n因此，$f(x)=x^2$ 的精确勒让德级数为：\n$$f(x) = \\frac{1}{3}P_0(x) + 0 \\cdot P_1(x) + \\frac{2}{3}P_2(x)$$\n从这个展开式中，我们可以直接识别出模态系数：\n$\\hat{f}_0 = \\frac{1}{3}$\n$\\hat{f}_1 = 0$\n$\\hat{f}_2 = \\frac{2}{3}$\n对于所有 $n  2$，$\\hat{f}_n = 0$。\n\n**2) $L^2$ 投影的构造**\n\n$f$ 到子空间 $\\mathbb{P}_k$（次数至多为 $k$ 的多项式）上的 $L^2$ 投影是通过将勒让德级数在 $n=k$ 处截断得到的。在我们的例子中，我们寻求到 $\\mathbb{P}_1 = \\operatorname{span}\\{P_0, P_1\\}$ 上的投影 $p_1(x)$。它由以下公式给出：\n$$p_1(x) = \\sum_{n=0}^{1} \\hat{f}_n P_n(x) = \\hat{f}_0 P_0(x) + \\hat{f}_1 P_1(x)$$\n代入我们找到的系数：\n$$p_1(x) = \\left(\\frac{1}{3}\\right) P_0(x) + (0) P_1(x) = \\frac{1}{3}(1) + 0(x) = \\frac{1}{3}$$\n$f(x)=x^2$ 到 $\\mathbb{P}_1$ 上的 $L^2$ 投影是常数函数 $p_1(x) = \\frac{1}{3}$。\n\n**3) 最佳逼近的验证**\n\n我们必须验证 $p_1(x) = \\frac{1}{3}$ 是 $f(x)=x^2$ 在 $\\mathbb{P}_1$ 中的唯一最佳 $L^2$ 逼近。\n\n**通过正交条件进行验证：**\n变分特征表明，$p_1$ 是 $L^2$ 投影的充要条件是误差 $f-p_1$ 与逼近空间 $\\mathbb{P}_1$ 正交。也就是说，对所有 $q \\in \\mathbb{P}_1$，都有 $\\langle f-p_1, q \\rangle = 0$。只需对 $\\mathbb{P}_1$ 的一个基，例如 $\\{P_0(x), P_1(x)\\} = \\{1, x\\}$，进行检验即可。\n误差函数为 $e(x) = f(x) - p_1(x) = x^2 - \\frac{1}{3}$。\n对于 $q(x) = P_0(x) = 1$：\n$$\\langle e, P_0 \\rangle = \\int_{-1}^{1} \\left(x^2 - \\frac{1}{3}\\right) (1) \\,dx = \\left[\\frac{x^3}{3} - \\frac{x}{3}\\right]_{-1}^{1} = \\left(\\frac{1}{3} - \\frac{1}{3}\\right) - \\left(-\\frac{1}{3} - (-\\frac{1}{3})\\right) = 0 - 0 = 0$$\n对于 $q(x) = P_1(x) = x$：\n$$\\langle e, P_1 \\rangle = \\int_{-1}^{1} \\left(x^2 - \\frac{1}{3}\\right) (x) \\,dx = \\int_{-1}^{1} \\left(x^3 - \\frac{x}{3}\\right) \\,dx$$\n被积函数是一个奇函数，且积分区间是关于原点对称的区间 $[-1,1]$，因此结果为 $0$。\n由于误差与 $\\mathbb{P}_1$ 的基向量正交，因此它与整个空间正交，从而证实 $p_1(x) = \\frac{1}{3}$ 是正确的 $L^2$ 投影。\n\n**通过勾股分解进行验证：**\n设 $q(x)$ 是 $\\mathbb{P}_1$ 中的任意多项式。我们要证明 $\\|f-p_1\\|^2 \\le \\|f-q\\|^2$。我们将误差 $f-q$ 分解为：\n$$f-q = (f-p_1) + (p_1-q)$$\n现在考虑 $L^2$ 范数的平方：\n$$\\|f-q\\|^2 = \\langle (f-p_1) + (p_1-q), (f-p_1) + (p_1-q) \\rangle$$\n$$= \\langle f-p_1, f-p_1 \\rangle + 2\\langle f-p_1, p_1-q \\rangle + \\langle p_1-q, p_1-q \\rangle$$\n$$= \\|f-p_1\\|^2 + 2\\langle f-p_1, p_1-q \\rangle + \\|p_1-q\\|^2$$\n项 $p_1-q$ 是 $\\mathbb{P}_1$ 中两个多项式的差，因此它也在 $\\mathbb{P}_1$ 中。误差项 $f-p_1$ 是 $x^2 - \\frac{1}{3} = \\frac{2}{3}P_2(x)$。根据勒让德多项式的正交性，$P_2$ 与 $\\mathbb{P}_1 = \\operatorname{span}\\{P_0, P_1\\}$ 中的每个多项式都正交。因此，交叉项为零：\n$$\\langle f-p_1, p_1-q \\rangle = \\left\\langle \\frac{2}{3}P_2(x), p_1(x)-q(x) \\right\\rangle = 0$$\n范数的平方简化为正交向量的勾股定理：\n$$\\|f-q\\|^2 = \\|f-p_1\\|^2 + \\|p_1-q\\|^2$$\n由于 $\\|p_1-q\\|^2 \\ge 0$，显然有 $\\|f-q\\|^2 \\ge \\|f-p_1\\|^2$。当 $\\|p_1-q\\|^2 = 0$ 时，达到最小逼近误差，这意味着 $p_1-q=0$（几乎处处成立）。这种情况在 $q=p_1$ 时唯一发生。这证实了 $p_1(x)=\\frac{1}{3}$ 是从空间 $\\mathbb{P}_1$ 中对 $f(x)=x^2$ 的唯一最佳 $L^2$ 逼近。", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "3408976"}, {"introduction": "虽然 $L^2$ 投影在理论上是最优的，但在实际的数值计算中，我们更常通过在特定节点上的插值来表示和操作函数。本练习聚焦于一组在谱元法中至关重要的节点——Gauss–Lobatto–Legendre (GLL) 节点，并要求计算一个函数在这些节点上的插值误差。这项实践对于理解在基于节点的谱方法和DG方法中，函数如何被离散化以及相关的误差如何产生至关重要。[@problem_id:3409031]", "problem": "考虑一维参考区间 $[-1,1]$ 以及在谱方法和间断伽辽金 (DG) 方法中使用的多项式插值框架。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示区间 $[-1,1]$ 上的勒让德多项式，它们关于权重 $1$ 正交，并归一化使得 $P_{n}(1)=1$。对于给定的多项式次数 $N$，高斯-洛巴托-勒让德 (GLL) 节点定义为端点 $\\{-1,1\\}$ 与 $P_{N}'(x)$ 的 $N-1$ 个不同内部根的并集。\n\n使用次数 $N=3$ 进行计算。模态到节点插值矩阵 $V$ 定义为 $V_{jk}=P_{k}(x_{j})$，其中 $j=1,\\dots,N+1$ 且 $k=0,\\dots,N$，$\\{x_{j}\\}_{j=1}^{N+1}$ 是 GLL 节点。该矩阵将模态勒让德系数映射到 GLL 网格上次数为 $N$ 的多项式的节点值。在 $[-1,1]$ 上为 $N=3$ 显式地构造该矩阵 $V$。\n\n然后，考虑函数 $f(x)=\\exp(x)$，并令 $p_{3}(x)$ 为其在 $N+1=4$ 个 GLL 节点上的 3 次拉格朗日插值多项式。使用在不同节点上拉格朗日插值的基本定义，推导在 $x=0$ 处的插值权重 $\\{\\ell_{j}(0)\\}_{j=1}^{4}$，并计算在 $x=0$ 处的点态插值误差，定义为 $E(0)=f(0)-p_{3}(0)$。将最终答案表示为单一的封闭形式解析表达式。无需四舍五入，不涉及单位。", "solution": "该问题提法清晰，具有科学依据，并包含唯一解所需的所有信息。这是多项式逼近理论中的一个标准练习，具体涉及在高斯-洛巴托-勒让德节点上的拉格朗日插值。该问题被认为是有效的。\n\n解答按要求分为三部分构建：首先，确定高斯-洛巴托-勒让德 (GLL) 节点并构建模态到节点矩阵 $V$；其次，推导在 $x=0$ 处的拉格朗日插值权重；第三，计算在 $x=0$ 处的点态插值误差。\n\n首先，我们确定在区间 $[-1,1]$ 上多项式次数为 $N=3$ 的 GLL 节点。这些节点由端点 $\\{-1,1\\}$ 和勒让德多项式 $P_3(x)$ 导数的根组成。归一化使得 $P_n(1)=1$ 的勒让德多项式为：\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\n$P_3(x) = \\frac{1}{2}(5x^3 - 3x)$\n\n$P_3(x)$ 的导数为：\n$$P_3'(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3)$$\n令 $P_3'(x)=0$ 以求内部节点：\n$$15x^2 - 3 = 0 \\implies x^2 = \\frac{3}{15} = \\frac{1}{5} \\implies x = \\pm \\frac{1}{\\sqrt{5}} = \\pm \\frac{\\sqrt{5}}{5}$$\n$N+1=4$ 个 GLL 节点，从小到大排序为：\n$$x_1 = -1, \\quad x_2 = -\\frac{\\sqrt{5}}{5}, \\quad x_3 = \\frac{\\sqrt{5}}{5}, \\quad x_4 = 1$$\n\n接下来，我们构造模态到节点插值矩阵 $V$，其定义为 $V_{jk} = P_k(x_j)$，其中 $j \\in \\{1, 2, 3, 4\\}$ 且 $k \\in \\{0, 1, 2, 3\\}$。我们在每个 GLL 节点上计算前四个勒让德多项式的值。\n对于 $x_1=-1$：$P_0(-1)=1$, $P_1(-1)=-1$, $P_2(-1)=1$, $P_3(-1)=-1$。\n对于 $x_4=1$：$P_0(1)=1$, $P_1(1)=1$, $P_2(1)=1$, $P_3(1)=1$。\n对于 $x_2=-\\frac{\\sqrt{5}}{5}$：\n$P_0(-\\frac{\\sqrt{5}}{5}) = 1$\n$P_1(-\\frac{\\sqrt{5}}{5}) = -\\frac{\\sqrt{5}}{5}$\n$P_2(-\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(3\\left(-\\frac{\\sqrt{5}}{5}\\right)^2 - 1\\right) = \\frac{1}{2}\\left(\\frac{3}{5} - 1\\right) = -\\frac{1}{5}$\n$P_3(-\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(5\\left(-\\frac{\\sqrt{5}}{5}\\right)^3 - 3\\left(-\\frac{\\sqrt{5}}{5}\\right)\\right) = \\frac{1}{2}\\left(-\\frac{1}{\\sqrt{5}} + \\frac{3}{\\sqrt{5}}\\right) = \\frac{1}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5}$\n对于 $x_3=\\frac{\\sqrt{5}}{5}$：\n$P_0(\\frac{\\sqrt{5}}{5}) = 1$\n$P_1(\\frac{\\sqrt{5}}{5}) = \\frac{\\sqrt{5}}{5}$\n$P_2(\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(3\\left(\\frac{\\sqrt{5}}{5}\\right)^2 - 1\\right) = -\\frac{1}{5}$\n$P_3(\\frac{\\sqrt{5}}{5}) = \\frac{1}{2}\\left(5\\left(\\frac{\\sqrt{5}}{5}\\right)^3 - 3\\left(\\frac{\\sqrt{5}}{5}\\right)\\right) = \\frac{1}{2}\\left(\\frac{1}{\\sqrt{5}} - \\frac{3}{\\sqrt{5}}\\right) = -\\frac{1}{\\sqrt{5}} = -\\frac{\\sqrt{5}}{5}$\n\n得到的模态到节点矩阵 $V$ 是：\n$$V = \\begin{pmatrix} P_0(x_1)  P_1(x_1)  P_2(x_1)  P_3(x_1) \\\\ P_0(x_2)  P_1(x_2)  P_2(x_2)  P_3(x_2) \\\\ P_0(x_3)  P_1(x_3)  P_2(x_3)  P_3(x_3) \\\\ P_0(x_4)  P_1(x_4)  P_2(x_4)  P_3(x_4) \\end{pmatrix} = \\begin{pmatrix} 1  -1  1  -1 \\\\ 1  -\\frac{\\sqrt{5}}{5}  -\\frac{1}{5}  \\frac{\\sqrt{5}}{5} \\\\ 1  \\frac{\\sqrt{5}}{5}  -\\frac{1}{5}  -\\frac{\\sqrt{5}}{5} \\\\ 1  1  1  1 \\end{pmatrix}$$\n\n最后，我们计算点态插值误差 $E(0) = f(0) - p_3(0)$，其中 $p_3(x)$ 是函数 $f(x) = \\exp(x)$ 在 GLL 节点上的 3 次拉格朗日插值多项式。插值多项式在 $x=0$ 处的值是 $p_3(0) = \\sum_{j=1}^{4} f(x_j) \\ell_j(0)$，其中 $\\ell_j(x)$ 是拉格朗日基多项式。权重 $\\ell_j(0)$ 由 $\\ell_j(0) = \\prod_{k=1, k \\ne j}^{4} \\frac{0-x_k}{x_j-x_k}$ 给出。\n\n权重的计算如下：\n$\\ell_1(0) = \\frac{(-x_2)(-x_3)(-x_4)}{(x_1-x_2)(x_1-x_3)(x_1-x_4)} = \\frac{(\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5})(-1)}{(-1+\\frac{\\sqrt{5}}{5})(-1-\\frac{\\sqrt{5}}{5})(-1-1)} = \\frac{\\frac{1}{5}}{(1 - \\frac{1}{5})(-2)} = \\frac{\\frac{1}{5}}{(\\frac{4}{5})(-2)} = \\frac{1/5}{-8/5} = -\\frac{1}{8}$。\n\n由于节点关于 $x=0$ 对称 ($x_1=-x_4, x_2=-x_3$)，我们可以推断出 $\\ell_4(0) = \\ell_1(0) = -\\frac{1}{8}$。我们来验证一下：\n$\\ell_4(0) = \\frac{(-x_1)(-x_2)(-x_3)}{(x_4-x_1)(x_4-x_2)(x_4-x_3)} = \\frac{(1)(\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5})}{(1-(-1))(1-(-\\frac{\\sqrt{5}}{5}))(1-\\frac{\\sqrt{5}}{5})} = \\frac{-1/5}{2(1-\\frac{1}{5})} = \\frac{-1/5}{2(4/5)} = \\frac{-1/5}{8/5} = -\\frac{1}{8}$。\n\n$\\ell_2(0) = \\frac{(-x_1)(-x_3)(-x_4)}{(x_2-x_1)(x_2-x_3)(x_2-x_4)} = \\frac{(1)(-\\frac{\\sqrt{5}}{5})(-1)}{(-\\frac{\\sqrt{5}}{5}-(-1))(-\\frac{\\sqrt{5}}{5}-\\frac{\\sqrt{5}}{5})(-\\frac{\\sqrt{5}}{5}-1)} = \\frac{\\frac{\\sqrt{5}}{5}}{(1-\\frac{\\sqrt{5}}{5})(-\\frac{2\\sqrt{5}}{5})(-1-\\frac{\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{(1-\\frac{1}{5})(\\frac{2\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{(\\frac{4}{5})(\\frac{2\\sqrt{5}}{5})} = \\frac{\\frac{\\sqrt{5}}{5}}{\\frac{8\\sqrt{5}}{25}} = \\frac{\\sqrt{5}}{5} \\frac{25}{8\\sqrt{5}} = \\frac{5}{8}$。\n\n同样，由于对称性，$\\ell_3(0) = \\ell_2(0) = \\frac{5}{8}$。权重之和为 $\\sum_{j=1}^{4} \\ell_j(0) = -\\frac{1}{8} + \\frac{5}{8} + \\frac{5}{8} - \\frac{1}{8} = \\frac{8}{8} = 1$，符合预期。\n\n在 $x=0$ 处的插值值为：\n$$p_3(0) = f(x_1)\\ell_1(0) + f(x_2)\\ell_2(0) + f(x_3)\\ell_3(0) + f(x_4)\\ell_4(0)$$\n$$p_3(0) = \\exp(-1)\\left(-\\frac{1}{8}\\right) + \\exp\\left(-\\frac{\\sqrt{5}}{5}\\right)\\left(\\frac{5}{8}\\right) + \\exp\\left(\\frac{\\sqrt{5}}{5}\\right)\\left(\\frac{5}{8}\\right) + \\exp(1)\\left(-\\frac{1}{8}\\right)$$\n我们可以对各项进行分组：\n$$p_3(0) = \\frac{5}{8} \\left( \\exp\\left(\\frac{\\sqrt{5}}{5}\\right) + \\exp\\left(-\\frac{\\sqrt{5}}{5}\\right) \\right) - \\frac{1}{8} \\left( \\exp(1) + \\exp(-1) \\right)$$\n使用恒等式 $\\cosh(z) = \\frac{\\exp(z)+\\exp(-z)}{2}$：\n$$p_3(0) = \\frac{5}{8} \\left( 2\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) \\right) - \\frac{1}{8} \\left( 2\\cosh(1) \\right) = \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) - \\frac{1}{4}\\cosh(1)$$\n\n在 $x=0$ 处的插值误差是 $E(0) = f(0) - p_3(0)$。因为 $f(0)=\\exp(0)=1$：\n$$E(0) = 1 - \\left( \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) - \\frac{1}{4}\\cosh(1) \\right) = 1 - \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right) + \\frac{1}{4}\\cosh(1)$$", "answer": "$$\\boxed{1 + \\frac{1}{4}\\cosh(1) - \\frac{5}{4}\\cosh\\left(\\frac{\\sqrt{5}}{5}\\right)}$$", "id": "3409031"}, {"introduction": "用光滑的多项式逼近非光滑函数（如包含间断的函数）会带来一个著名的挑战：吉布斯现象（Gibbs phenomenon），即在间断点附近产生难以消除的振荡。本编程练习让您亲手处理这一问题，您将对一个阶跃函数进行勒让德多项式逼近，观察吉布斯振荡，并实现一种标准的解决方案——模态滤波。这项动手编码任务将理论知识（谱收敛性）与解决实际问题的工程技术（滤波）联系起来，是谱方法实践中非常重要的一环。[@problem_id:3409037]", "problem": "在谱方法和间断 Galerkin (DG) 方法的背景下，考虑用 Legendre 多项式对分段常数函数进行多项式逼近。设 $P_k(x)$ 表示区间 $[-1,1]$ 上的第 $k$ 阶 Legendre 多项式，其归一化使得 $P_k(1)=1$。Legendre 多项式族在单位权重下构成 $L^2([-1,1])$ 空间的一个正交基。一个函数 $f(x)$ 到至多 $N$ 次多项式空间上的 $L^2$-正交投影可以表示为截断至 $N$ 阶的 Legendre 级数：\n$$\n\\Pi_N f(x) = \\sum_{k=0}^{N} a_k P_k(x),\n$$\n其中，模态系数 $a_k$ 由下式给出\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} f(x) P_k(x)\\,dx.\n$$\n在谱方法和间断 Galerkin (DG) 逼近中，$f(x)$ 的间断点会导致称为 Gibbs 现象的振荡误差。一个减轻这些振荡的常用策略是向系数施加一个模态滤波器。一个阶数为 $p$、强度为 $\\alpha$ 的指数滤波器将每个模态系数 $a_k$ 乘以一个阻尼因子\n$$\n\\sigma_k = \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right),\n$$\n从而产生一个滤波后的逼近\n$$\n\\Pi_N^{\\sigma} f(x) = \\sum_{k=0}^{N} \\sigma_k a_k P_k(x).\n$$\n\n您的任务是实现一个程序，该程序：\n1. 计算函数 $f(x) = \\mathrm{sign}(x)$ 的 Legendre 系数 $a_k$。为确定性起见，该函数定义为：当 $x \\in [-1,0)$ 时 $f(x) = -1$，当 $x \\in (0,1]$ 时 $f(x) = 1$，以及 $f(0)=0$。\n2. 对于指定的阶数 $N$、滤波器阶数 $p$ 和滤波器强度 $\\alpha$，构造截断的 Legendre 逼近 $\\Pi_N f(x)$ 和指数滤波后的逼近 $\\Pi_N^{\\sigma} f(x)$。\n3. 在远离间断点 $x=0$ 的指定计算点 $x$ 处，评估逐点绝对误差 $|f(x) - \\Pi_N^{\\sigma} f(x)|$，并将其与未滤波的误差 $|f(x) - \\Pi_N f(x)|$进行比较，以评估滤波器对逐点误差的影响。\n\n使用的基本原理：\n- Legendre 多项式在权重为 $1$ 的情况下在 $L^2([-1,1])$ 中的正交性和完备性。\n- 通过 $a_k$ 的内积积分定义，在 Legendre 基中进行谱投影。\n- 如上所述的指数模态滤波器的定义和实现。\n\n算法要求：\n- 使用对多项式精确的求积方法计算 $a_k$：分别在 $[-1,0]$ 和 $[0,1]$ 上执行 Gaussian 求积，以稳健地评估 $\\int_{-1}^{1} \\mathrm{sign}(x) P_k(x)\\,dx$，确保对每个 $k \\leq N$ 的精度。\n- 逐点计算 $P_k(x)$ 的值，以构建 $\\Pi_N f(x)$ 和 $\\Pi_N^{\\sigma} f(x)$。\n- 使用指定的 $(\\alpha,p)$ 的指数滤波器；对于未滤波的情况，使用 $p=0$ （因此 $\\sigma_k = 1$）。\n\n测试套件：\n对于以下每种情况，计算所要求的度量，并将所有结果汇总到单个列表中作为最终输出。\n\n- 情况 1 （基线，“理想路径”）：$N=16$，未滤波（$p=0$，任何 $\\alpha$ 均无关紧要），计算点 $x \\in \\{-0.9,-0.5,-0.25,0.25,0.5,0.9\\}$。输出平均绝对误差 $\\frac{1}{6}\\sum |f(x)-\\Pi_N f(x)|$，结果为单个浮点数。\n\n- 情况 2 （滤波对应项）：$N=16$，使用 $\\alpha=36, p=8$ 进行滤波，计算点相同。输出平均绝对误差 $\\frac{1}{6}\\sum |f(x)-\\Pi_N^{\\sigma} f(x)|$，结果为单个浮点数。\n\n- 情况 3 （中等阶数下的改善因子）：$N=32$，在相同的计算点上比较未滤波（$p=0$）与滤波后（$\\alpha=36, p=8$）的情况。输出改善因子，定义为未滤波的平均绝对误差与滤波后的平均绝对误差之比（单个浮点数）。\n\n- 情况 4 （间断点附近的边界条件）：$N=32$，在 $x \\in \\{-10^{-3},10^{-3}\\}$ 处进行计算，以探究非常接近 $x=0$ 处的行为。输出改善因子，定义为未滤波的平均绝对误差与滤波后的平均绝对误差之比（单个浮点数）。这测试了滤波器在跳跃点紧邻区域的局限性。\n\n- 情况 5 （更高阶数下的行为）：$N=64$，使用 $\\alpha=36, p=8$ 进行滤波，在 $x \\in \\{-0.9,-0.5,-0.25,0.25,0.5,0.9\\}$ 处进行计算。输出该集合上的最大绝对误差 $\\max |f(x)-\\Pi_N^{\\sigma} f(x)|$，结果为单个浮点数。\n\n所有计算点都是无量纲的，不需要物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况 1 到 5 的顺序排列结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个 Python 浮点数。不应打印任何其他文本。", "solution": "该问题要求对区间 $[-1,1]$ 上的分段常数函数 $f(x) = \\mathrm{sign}(x)$ 实现多项式逼近并进行分析。该逼近基于截断的 Legendre 级数，并研究了指数模态滤波器对逼近精度的影响。解决方案涉及计算 Legendre 系数，构建标准和滤波后的多项式逼近，并对照真实函数评估它们的逐点误差。\n\n该方法的核心基于谱方法和类 Fourier 级数展开的原理。Hilbert 空间 $L^2([-1,1])$ 中的一个函数 $f(x)$ 可以用其在正交基中的级数展开来表示。对于在 $[-1,1]$ 上关于单位权函数正交的 Legendre 多项式基 $\\{P_k(x)\\}_{k=0}^{\\infty}$，此展开式由下式给出：\n$$\nf(x) = \\sum_{k=0}^{\\infty} a_k P_k(x)\n$$\n模态系数 $a_k$ 由 $f(x)$在每个基函数 $P_k(x)$ 上的正交投影确定：\n$$\na_k = \\frac{\\langle f, P_k \\rangle}{\\langle P_k, P_k \\rangle} = \\frac{\\int_{-1}^{1} f(x) P_k(x) \\,dx}{\\int_{-1}^{1} P_k(x)^2 \\,dx}\n$$\n给定标准归一化 $\\int_{-1}^{1} P_k(x)^2 \\,dx = \\frac{2}{2k+1}$，系数公式简化为问题描述中给出的形式：\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} f(x) P_k(x)\\,dx\n$$\n在实践中，无限级数在有限阶 $N$ 处被截断，从而得到多项式逼近 $\\Pi_N f(x) = \\sum_{k=0}^{N} a_k P_k(x)$。\n\n对于特定函数 $f(x) = \\mathrm{sign}(x)$，它是一个奇函数，其在 Legendre 基中的表示将只包含奇数索引的 Legendre 多项式，而这些多项式本身也是奇函数。因此，所有偶数索引 $k$ 的系数 $a_k$ 都必须为零。奇数 $k$ 的非零系数是通过计算定义积分得到的。由于 $f(x)$ 在 $x=0$ 处的间断性，问题指定了一种稳健的数值方法来计算该积分。该积分被分成两部分：\n$$\n\\int_{-1}^{1} \\mathrm{sign}(x) P_k(x)\\,dx = \\int_{-1}^{0} (-1) P_k(x)\\,dx + \\int_{0}^{1} (1) P_k(x)\\,dx\n$$\n在子区间 $[-1,0]$ 和 $[0,1]$ 上的每个积分都涉及一个光滑的被积函数（一个多项式）。在实现中，这些积分使用高阶 Gauss-Legendre 求积法计算，该方法对特定阶数以下的多项式是精确的。选择求积点数 $M$ 以使求积法对阶数最高为 $N$ 的多项式是精确的，即 $2M-1 \\ge N$。\n\n在逼近像 $\\mathrm{sign}(x)$ 这样的不连续函数时，截断级数 $\\Pi_N f(x)$ 在间断点附近表现出伪振荡，这种现象被称为 Gibbs 现象。为了减轻这些振荡，对模态系数施加一个滤波器。问题指定了一个指数滤波器，其中每个系数 $a_k$ 乘以一个阻尼因子 $\\sigma_k$：\n$$\n\\sigma_k = \\exp\\left(-\\alpha \\left(\\frac{k}{N}\\right)^p\\right)\n$$\n参数 $\\alpha  0$ 和 $p \\ge 2$ 分别控制滤波器的强度和阶数。高阶模态（大的 $k$）被更重地阻尼，从而平滑了逼近。滤波后的逼近为：\n$$\n\\Pi_N^{\\sigma} f(x) = \\sum_{k=0}^{N} \\sigma_k a_k P_k(x)\n$$\n根据问题指令，未滤波的情况对应于 $p=0$，这意味着对所有 $k$ 都有 $\\sigma_k = 1$。\n\n最后一步是评估未滤波逼近 $\\Pi_N f(x)$ 和滤波后逼近 $\\Pi_N^{\\sigma} f(x)$ 的逐点精度。对于给定的计算点集 $\\{x_j\\}$，通过对级数求和来计算逼近值。级数求值使用 `numpy.polynomial.legendre.legval` 中实现的 Clenshaw 算法高效执行。然后计算绝对误差 $|f(x_j) - \\Pi_N f(x_j)|$ 和 $|f(x_j) - \\Pi_N^{\\sigma} f(x_j)|$。测试用例要求基于这些误差计算特定的度量，例如平均绝对误差、最大绝对误差以及未滤波误差与滤波误差之比，以量化滤波器的性能。\n\n对于每个测试用例，总体算法流程如下：\n1.  确定所需的多项式阶数 $N$。\n2.  使用分段 Gauss-Legendre 求积法计算 $k=0, \\dots, N$ 的 Legendre 系数 $a_k$。这些系数被缓存以避免重复计算。\n3.  对于滤波和未滤波的逼近，构建级数系数向量。对于未滤波情况，该向量就是 $\\{a_k\\}$。对于滤波情况，该向量是 $\\{ \\sigma_k a_k \\}$。\n4.  在指定的计算点 $x_j$ 处，计算多项式逼近的值。\n5.  计算相对于真实函数 $\\mathrm{sign}(x_j)$ 的逐点绝对误差。\n6.  根据特定测试用例的要求，计算并存储最终度量（平均误差、最大误差或误差比）。\n所有测试用例的结果被汇总到一个列表中作为最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre\nfrom numpy.polynomial.legendre import legval\n\ndef solve():\n    \"\"\"\n    Solves the polynomial approximation problem by computing Legendre coefficients,\n    applying a modal filter, evaluating errors, and reporting the specified metrics.\n    \"\"\"\n\n    # Cache for Legendre coefficients to avoid recomputation for the same degree N.\n    coeffs_cache = {}\n\n    def get_legendre_coeffs_sign_x(N: int) - np.ndarray:\n        \"\"\"\n        Computes the Legendre series coefficients for f(x) = sign(x) up to degree N.\n        The coefficients are computed using Gauss-Legendre quadrature on sub-intervals\n        [-1,0] and [0,1] to handle the discontinuity at x=0.\n        \"\"\"\n        if N in coeffs_cache:\n            return coeffs_cache[N]\n\n        coeffs = np.zeros(N + 1)\n        \n        # An M-point Gauss rule is exact for polynomials of degree 2M-1.\n        # We integrate f(x)*P_k(x), where f is piecewise constant. So we integrate P_k(x) on\n        # subdomains, which is a polynomial of degree k. To be exact for all k=N, we need 2M-1 >= N.\n        num_points = int(np.ceil((N + 1) / 2.0))\n        nodes, weights = roots_legendre(num_points)\n\n        # Map nodes and weights for integral over [0, 1]\n        nodes_01 = 0.5 * (nodes + 1)\n        weights_01 = 0.5 * weights\n\n        # Map nodes and weights for integral over [-1, 0]\n        nodes_m10 = 0.5 * (nodes - 1)\n        weights_m10 = 0.5 * weights\n\n        for k in range(N + 1):\n            # The function sign(x)*P_k(x) is odd if k is even, so its integral is 0.\n            # Its integral is non-zero only if k is odd.\n            if k % 2 == 0:\n                coeffs[k] = 0.0\n                continue\n\n            # Integral of P_k(x) over [0, 1]\n            pk_vals_01 = eval_legendre(k, nodes_01)\n            integral_01 = np.sum(weights_01 * pk_vals_01)\n\n            # Integral of P_k(x) over [-1, 0]\n            pk_vals_m10 = eval_legendre(k, nodes_m10)\n            integral_m10 = np.sum(weights_m10 * pk_vals_m10)\n            \n            # Integral of sign(x)*P_k(x) over [-1, 1] is\n            # = integral[-1,0] (-1)*P_k(x) dx + integral[0,1] (1)*P_k(x) dx\n            integral_total = -integral_m10 + integral_01\n            \n            coeffs[k] = (2 * k + 1) / 2.0 * integral_total\n        \n        coeffs_cache[N] = coeffs\n        return coeffs\n\n    def calculate_approximation_error(N, p, alpha, x_eval, unfiltered):\n        \"\"\"\n        Calculates the pointwise absolute error of the (filtered) approximation.\n        \"\"\"\n        a_k = get_legendre_coeffs_sign_x(N)\n        \n        if unfiltered:\n            # Per problem statement, sigma_k = 1 for the unfiltered case.\n            coeffs_to_eval = a_k\n        else:\n            k_indices = np.arange(N + 1, dtype=float)\n            # Handle N=0 case to avoid division by zero.\n            if N > 0:\n                eta = k_indices / N\n            else:\n                eta = np.zeros_like(k_indices)\n            sigma = np.exp(-alpha * eta**p)\n            coeffs_to_eval = a_k * sigma\n\n        y_approx = legval(x_eval, coeffs_to_eval)\n        y_true = np.sign(x_eval)\n        \n        return np.abs(y_true - y_approx)\n\n    results = []\n    \n    # Common evaluation points for Cases 1, 2, 3, 5\n    x_eval_common = np.array([-0.9, -0.5, -0.25, 0.25, 0.5, 0.9])\n\n    # Case 1: N=16, unfiltered, mean absolute error\n    N1 = 16\n    errors1 = calculate_approximation_error(N1, p=0, alpha=0, x_eval=x_eval_common, unfiltered=True)\n    result1 = np.mean(errors1)\n    results.append(result1)\n    \n    # Case 2: N=16, filtered, mean absolute error\n    N2, p2, alpha2 = 16, 8, 36\n    errors2 = calculate_approximation_error(N2, p=p2, alpha=alpha2, x_eval=x_eval_common, unfiltered=False)\n    result2 = np.mean(errors2)\n    results.append(result2)\n    \n    # Case 3: N=32, improvement factor\n    N3, p3, alpha3 = 32, 8, 36\n    unfiltered_errors3 = calculate_approximation_error(N3, p=0, alpha=0, x_eval=x_eval_common, unfiltered=True)\n    filtered_errors3 = calculate_approximation_error(N3, p=p3, alpha=alpha3, x_eval=x_eval_common, unfiltered=False)\n    mean_err_unfiltered3 = np.mean(unfiltered_errors3)\n    mean_err_filtered3 = np.mean(filtered_errors3)\n    result3 = mean_err_unfiltered3 / mean_err_filtered3\n    results.append(result3)\n\n    # Case 4: N=32, improvement factor near discontinuity\n    N4, p4, alpha4 = 32, 8, 36\n    x_eval4 = np.array([-1e-3, 1e-3])\n    unfiltered_errors4 = calculate_approximation_error(N4, p=0, alpha=0, x_eval=x_eval4, unfiltered=True)\n    filtered_errors4 = calculate_approximation_error(N4, p=p4, alpha=alpha4, x_eval=x_eval4, unfiltered=False)\n    mean_err_unfiltered4 = np.mean(unfiltered_errors4)\n    mean_err_filtered4 = np.mean(filtered_errors4)\n    result4 = mean_err_unfiltered4 / mean_err_filtered4\n    results.append(result4)\n    \n    # Case 5: N=64, filtered, max absolute error\n    N5, p5, alpha5 = 64, 8, 36\n    errors5 = calculate_approximation_error(N5, p=p5, alpha=alpha5, x_eval=x_eval_common, unfiltered=False)\n    result5 = np.max(errors5)\n    results.append(result5)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3409037"}]}