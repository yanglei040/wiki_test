{"hands_on_practices": [{"introduction": "本练习将演示傅里叶伪谱方法在计算非线性项时混叠效应的基本机理。您将对一个简单的二次乘积项应用广泛使用的“三分之二补零”规则 (three-halves padding rule)，通过解析推导得到去混叠后的结果，从而理解该技术如何有效滤除虚假频率。[@problem_id:3363423]", "problem": "考虑一个定义在 $[0,2\\pi]$ 上的周期函数 $u(x)$，并在 $N=16$ 个等距点上进行采样，其中 $x_{j} = \\frac{2\\pi j}{N}$，$j=0,1,\\dots, N-1$。在伪谱方法中，非线性乘积的计算方式是：变换到物理空间，进行逐点相乘，然后再变换回傅里叶空间。由于傅里叶模态的离散卷积会将高频内容折叠回可分辨频带，从而产生混叠现象。对于二次非线性，避免混叠的一种标准方法是“三分之二补零”法：将谱表示补零至 $M = \\frac{3}{2}N$ 个模态，变换到 $M$ 个物理点，进行逐点相乘，变换回谱空间，然后通过舍弃原始可分辨频带之外的模态，投影到原始的 $N$ 模态子空间上。\n\n设 $u(x) = \\sin(3x) + \\sin(5x)$。使用带有三分之二补零的去混叠伪谱计算方法，计算去混叠乘积 $u^{2}(x)$ 在投影回原始 $N=16$ 模态子空间后的解析表达式。将您的最终结果表示为关于 $x$ 的单一简化三角函数表达式。不需要进行数值舍入。", "solution": "该问题是有效的，因为它在科学上基于谱方法的原理，是适定且客观的。不存在矛盾或信息缺失。所描述的程序，即用于二次非线性去混叠的三分之二补零法，是计算物理和工程中的一项标准技术。因此，我们可以着手求解。\n\n问题要求使用伪谱方法，在 $N=16$ 个点的网格上采用三分之二补零法，求出乘积 $u^2(x)$ 的去混叠表达式，其中 $u(x) = \\sin(3x) + \\sin(5x)$。\n\n首先，我们确定乘积 $u^2(x)$ 的精确解析表达式。这代表了在考虑任何截断或混叠效应之前，物理空间乘法步骤的结果。\n$$u^2(x) = (\\sin(3x) + \\sin(5x))^2$$\n$$u^2(x) = \\sin^2(3x) + \\sin^2(5x) + 2\\sin(3x)\\sin(5x)$$\n我们使用以下三角恒等式来简化此表达式：\n1. 降幂公式：$\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$\n2. 积化和差公式：$2\\sin(A)\\sin(B) = \\cos(A-B) - \\cos(A+B)$\n\n应用这些恒等式，我们得到：\n$$\\sin^2(3x) = \\frac{1 - \\cos(2 \\cdot 3x)}{2} = \\frac{1}{2} - \\frac{1}{2}\\cos(6x)$$\n$$\\sin^2(5x) = \\frac{1 - \\cos(2 \\cdot 5x)}{2} = \\frac{1}{2} - \\frac{1}{2}\\cos(10x)$$\n$$2\\sin(3x)\\sin(5x) = \\cos(5x - 3x) - \\cos(5x + 3x) = \\cos(2x) - \\cos(8x)$$\n\n将这些代回 $u^2(x)$ 的表达式中：\n$$u^2(x) = \\left(\\frac{1}{2} - \\frac{1}{2}\\cos(6x)\\right) + \\left(\\frac{1}{2} - \\frac{1}{2}\\cos(10x)\\right) + (\\cos(2x) - \\cos(8x))$$\n合并各项，精确的乘积为：\n$$u^2(x) = 1 + \\cos(2x) - \\frac{1}{2}\\cos(6x) - \\cos(8x) - \\frac{1}{2}\\cos(10x)$$\n此表达式表明，真实的乘积包含对应于波数 $k \\in \\{0, 2, 6, 8, 10\\}$ 的傅里叶模态。\n\n接下来，我们分析去混叠过程。计算是在一个 $N=16$ 个点的离散网格上进行的。初始函数 $u(x)$ 包含波数为 $k=3$ 和 $k=5$ 的模态。原始网格的奈奎斯特波数为 $k_{Ny,N} = N/2 = 16/2 = 8$。由于 $u(x)$ 中的波数小于 $k_{Ny,N}$，该函数在初始网格上得到了良好解析。\n\n去混叠过程涉及将谱表示补零至 $M = \\frac{3}{2}N = \\frac{3}{2}(16) = 24$ 个模态。然后在一个更精细的 $M=24$ 个点的网格上的物理空间中计算非线性乘积。这个补零网格的奈奎斯特波数为 $k_{Ny,M} = M/2 = 24/2 = 12$。\n\n为了在这个补零网格上无混叠地计算二次乘积，精确乘积中存在的最高波数必须小于补零网格的奈奎斯特波数 $k_{Ny,M}$。我们的精确乘积 $u^2(x)$ 中的最高波数是 $k_{max}=10$。\n由于 $k_{max} = 10  k_{Ny,M} = 12$，在 $M=24$ 点网格上的逐点乘积不会遭受混叠。将此乘积变换回补零后的谱空间，将得到真实乘积 $u^2(x)$ 的精确傅里叶系数。\n\n最后一步是将结果投影到原始的 $N=16$ 模态子空间上。这意味着我们必须舍弃所有在原始网格上无法表示的模态。对于一个在 $N=16$ 个点上的实值函数，离散傅里叶表示的基函数通常选择为 $\\{\\cos(kx) \\mid k=0, 1, \\dots, N/2\\}$ 和 $\\{\\sin(kx) \\mid k=1, 2, \\dots, N/2-1\\}$。\n对于 $N=16$，可分辨的余弦波数为 $k \\in \\{0, 1, 2, 3, 4, 5, 6, 7, 8\\}$。乘积 $u^2(x)$ 只包含余弦项。\n\n我们检查精确乘积中各项的波数：\n$u^2(x) = 1\\cdot\\cos(0x) + \\cos(2x) - \\frac{1}{2}\\cos(6x) - \\cos(8x) - \\frac{1}{2}\\cos(10x)$\n- 常数项 $1$ 对应于 $k=0$。这在可分辨频带内 ($0 \\le 8$)。\n- 项 $\\cos(2x)$ 的波数为 $k=2$。这在可分辨频带内 ($2 \\le 8$)。\n- 项 $-\\frac{1}{2}\\cos(6x)$ 的波数为 $k=6$。这在可分辨频带内 ($6 \\le 8$)。\n- 项 $-\\cos(8x)$ 的波数为 $k=8$。这是原始网格的奈奎斯特波数，包含在余弦基中。它在可分辨频带内 ($8 \\le 8$)。\n- 项 $-\\frac{1}{2}\\cos(10x)$ 的波数为 $k=10$。这个波数在可分辨频带之外 ($10 > 8$)。\n\n投影操作会舍弃波数为 $k=10$ 的模态。因此，去混叠乘积在投影回原始 $N=16$ 模态子空间后，由具有可分辨波数的项之和给出。\n\n结果表达式为：\n$$u^2_{\\text{de-aliased}}(x) = 1 + \\cos(2x) - \\frac{1}{2}\\cos(6x) - \\cos(8x)$$\n这是去混叠乘积的最终解析表达式。", "answer": "$$\\boxed{1 + \\cos(2x) - \\frac{1}{2}\\cos(6x) - \\cos(8x)}$$", "id": "3363423"}, {"introduction": "从傅里叶级数转向多项式基，这是谱元法和间断Galerkin方法的核心。本练习将在一个具体情境下量化混叠误差。通过将真实的 $L^2$ 投影与基于高斯-洛巴托 (Gauss-Lobatto) 点上的节点插值（配置）的近似进行比较，您将直接计算混叠误差的平方 $L^2$ 范数，从而精确理解配置法引入的差异。[@problem_id:3363449]", "problem": "考虑一个坐标为 $x \\in [-1,1]$ 的一维参考单元，以及在模态 Legendre 基 $\\{P_n(x)\\}_{n=0}^{p}$ 中表示的阶数至多为 $p$ 的多项式空间 $\\mathbb{P}_p$，其中 $P_n(x)$ 表示 $n$ 阶 Legendre 多项式。Legendre 多项式在 $[-1,1]$ 上关于权重 $1$ 是正交的，对于非负整数 $m$ 和 $n$ 满足 $\\int_{-1}^{1} P_m(x) P_n(x) \\,\\mathrm{d}x = \\frac{2}{2n+1} \\delta_{mn}$。在谱方法或间断 Galerkin (DG) 离散化中，诸如 $u^2$ 之类的非线性项可以通过到 $\\mathbb{P}_p$ 中的精确 $L^2$ 投影来表示，或者通过基于配置的节点积，然后从节点值插值回 $\\mathbb{P}_p$ 中来表示。当非线性积使多项式阶数超过 $p$ 时，后者会引入混叠。使用以下特定设置来分析和量化混叠误差：\n\n- 取多项式阶数 $p=2$ 和模态 Legendre 基 $\\{P_0(x),P_1(x),P_2(x)\\}$，其中 $P_0(x)=1$，$P_1(x)=x$，且 $P_2(x)=\\frac{3x^2-1}{2}$。\n- 令 $u(x) = P_0(x) + P_1(x) + P_2(x)$。\n- 将精确 $L^2$ 投影 $\\Pi_{\\mathbb{P}_2}(u^2)$ 定义为 $\\mathbb{P}_2$ 中的唯一多项式，其模态系数 $\\{c_n\\}_{n=0}^{2}$ 满足 $c_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x)^2 P_n(x) \\,\\mathrm{d}x$。\n- 在 $p=2$ 的 Legendre-Gauss-Lobatto (LGL) 节点 $x \\in \\{-1,0,1\\}$ 上定义基于配置的积。对于 $x_i \\in \\{-1,0,1\\}$，计算节点值 $v_i = u(x_i)^2$，并令 $w(x) \\in \\mathbb{P}_2$ 为满足 $w(x_i) = v_i$（对于 $x_i \\in \\{-1,0,1\\}$）的唯一的 2 阶插值多项式。\n- 将混叠误差量化为精确投影与基于配置的多项式之差的 $L^2$ 范数的平方，定义为\n$$E = \\int_{-1}^{1} \\big(\\Pi_{\\mathbb{P}_2}(u^2)(x) - w(x)\\big)^2 \\,\\mathrm{d}x.$$\n\n从上述基本定义中推导所有需要的中间表达式。将您对 $E$ 的最终答案表示为精确分数。不要四舍五入。", "solution": "所述问题具有科学依据、是适定的、客观且自洽的。它是在数值分析中量化谱方法中混叠误差的一个标准练习。所有定义和数据都已提供，并与既有理论一致。因此，该问题是有效的，并将推导求解。\n\n求解过程分为四个步骤：\n1.  首先，我们确定 $u(x)$ 和 $u(x)^2$ 的显式多项式形式。\n2.  其次，我们计算 $u(x)^2$ 到多项式空间 $\\mathbb{P}_2$ 上的精确 $L^2$ 投影，我们将其记为 $\\Pi_{\\mathbb{P}_2}(u^2)(x)$。\n3.  第三，我们计算插值多项式 $w(x) \\in \\mathbb{P}_2$，它在指定的 Legendre-Gauss-Lobatto (LGL) 节点上与 $u(x)^2$ 配置。\n4.  最后，我们计算这两个多项式之差的 $L^2$ 范数的平方，以求出混叠误差 $E$。\n\n步骤 1：表示 $u(x)$ 和 $u(x)^2$。\n函数 $u(x)$ 在 Legendre 基中给出为 $u(x) = P_0(x) + P_1(x) + P_2(x)$。代入定义 $P_0(x)=1$，$P_1(x)=x$ 和 $P_2(x) = \\frac{3x^2-1}{2}$，我们得到：\n$$u(x) = 1 + x + \\frac{3x^2-1}{2} = \\frac{3}{2}x^2 + x + \\frac{1}{2}$$\n对该表达式平方得到非线性项 $u(x)^2$：\n$$u(x)^2 = \\left(\\frac{3}{2}x^2 + x + \\frac{1}{2}\\right)^2 = \\frac{9}{4}x^4 + x^2 + \\frac{1}{4} + 2\\left(\\frac{3}{2}x^3\\right) + 2\\left(\\frac{3}{4}x^2\\right) + 2\\left(\\frac{1}{2}x\\right)$$\n$$u(x)^2 = \\frac{9}{4}x^4 + 3x^3 + \\left(1 + \\frac{3}{2}\\right)x^2 + x + \\frac{1}{4} = \\frac{9}{4}x^4 + 3x^3 + \\frac{5}{2}x^2 + x + \\frac{1}{4}$$\n这是一个 4 阶多项式。\n\n步骤 2：计算精确 $L^2$ 投影 $\\Pi_{\\mathbb{P}_2}(u^2)$。\n精确投影 $\\Pi_{\\mathbb{P}_2}(u^2)$ 是 $u(x)^2$ 在由 $\\{P_0(x), P_1(x), P_2(x)\\}$ 张成的空间 $\\mathbb{P}_2$ 中的分量。我们可以通过将 $u(x)^2$ 在 Legendre 基中表示并截断高于 2 阶的项来找到它。我们使用标准恒等式：$1=P_0(x)$，$x=P_1(x)$，$x^2 = \\frac{1}{3}P_0(x) + \\frac{2}{3}P_2(x)$，$x^3 = \\frac{3}{5}P_1(x) + \\frac{2}{5}P_3(x)$，以及 $x^4 = \\frac{1}{5}P_0(x) + \\frac{4}{7}P_2(x) + \\frac{8}{35}P_4(x)$。\n将这些代入 $u(x)^2$ 的表达式中：\n$$u(x)^2 = \\frac{9}{4}\\left(\\frac{1}{5}P_0 + \\frac{4}{7}P_2 + \\frac{8}{35}P_4\\right) + 3\\left(\\frac{3}{5}P_1 + \\frac{2}{5}P_3\\right) + \\frac{5}{2}\\left(\\frac{1}{3}P_0 + \\frac{2}{3}P_2\\right) + P_1 + \\frac{1}{4}P_0$$\n收集每个 Legendre 多项式的系数：\n- $P_0$ 项：$(\\frac{9}{20} + \\frac{5}{6} + \\frac{1}{4})P_0 = (\\frac{27+50+15}{60})P_0 = \\frac{92}{60}P_0 = \\frac{23}{15}P_0$\n- $P_1$ 项：$(\\frac{9}{5} + 1)P_1 = \\frac{14}{5}P_1$\n- $P_2$ 项：$(\\frac{9}{7} + \\frac{5}{3})P_2 = (\\frac{27+35}{21})P_2 = \\frac{62}{21}P_2$\n- $P_3$ 项：$\\frac{6}{5}P_3$\n- $P_4$ 项：$\\frac{18}{35}P_4$\n精确 $L^2$ 投影通过只保留 $\\mathbb{P}_2$ 中的项得到：\n$$\\Pi_{\\mathbb{P}_2}(u^2)(x) = \\frac{23}{15}P_0(x) + \\frac{14}{5}P_1(x) + \\frac{62}{21}P_2(x)$$\n\n步骤 3：计算基于配置的多项式 $w(x)$。\n$p=2$ 的 LGL 节点是 $x_0=-1$，$x_1=0$ 和 $x_2=1$。我们首先在这些节点上计算 $u(x)$：\n- $u(x_0) = u(-1) = \\frac{3}{2}(-1)^2 + (-1) + \\frac{1}{2} = \\frac{3}{2} - 1 + \\frac{1}{2} = 1$\n- $u(x_1) = u(0) = \\frac{3}{2}(0)^2 + (0) + \\frac{1}{2} = \\frac{1}{2}$\n- $u(x_2) = u(1) = \\frac{3}{2}(1)^2 + (1) + \\frac{1}{2} = \\frac{3}{2} + 1 + \\frac{1}{2} = 3$\n用于配置的节点值为 $v_i = u(x_i)^2$：\n- $v_0 = u(-1)^2 = 1^2 = 1$\n- $v_1 = u(0)^2 = (\\frac{1}{2})^2 = \\frac{1}{4}$\n- $v_2 = u(1)^2 = 3^2 = 9$\n我们寻找唯一的插值这些值的多项式 $w(x) = ax^2 + bx + c$：\n- $w(0) = c = \\frac{1}{4}$\n- $w(1) = a + b + c = 9 \\implies a+b = 9 - \\frac{1}{4} = \\frac{35}{4}$\n- $w(-1) = a - b + c = 1 \\implies a-b = 1 - \\frac{1}{4} = \\frac{3}{4}$\n将最后两个方程相加得到 $2a = \\frac{35}{4} + \\frac{3}{4} = \\frac{38}{4} = \\frac{19}{2}$，所以 $a = \\frac{19}{4}$。\n用第二个方程减去第三个方程得到 $2b = \\frac{35}{4} - \\frac{3}{4} = \\frac{32}{4} = 8$，所以 $b=4$。\n因此，插值多项式为 $w(x) = \\frac{19}{4}x^2 + 4x + \\frac{1}{4}$。\n为了便于比较，我们将 $w(x)$ 在 Legendre 基中表示：\n$$w(x) = \\frac{19}{4}\\left(\\frac{1}{3}P_0 + \\frac{2}{3}P_2\\right) + 4P_1 + \\frac{1}{4}P_0 = \\left(\\frac{19}{12} + \\frac{1}{4}\\right)P_0 + 4P_1 + \\frac{19}{6}P_2$$\n$$w(x) = \\left(\\frac{19+3}{12}\\right)P_0 + 4P_1 + \\frac{19}{6}P_2 = \\frac{22}{12}P_0 + 4P_1 + \\frac{19}{6}P_2 = \\frac{11}{6}P_0(x) + 4P_1(x) + \\frac{19}{6}P_2(x)$$\n\n步骤 4：计算混叠误差 $E$。\n混叠误差是差值多项式 $\\Delta(x) = \\Pi_{\\mathbb{P}_2}(u^2)(x) - w(x)$ 的 $L^2$ 范数的平方。\n$$\\Delta(x) = \\left(\\frac{23}{15} - \\frac{11}{6}\\right)P_0(x) + \\left(\\frac{14}{5} - 4\\right)P_1(x) + \\left(\\frac{62}{21} - \\frac{19}{6}\\right)P_2(x)$$\n差值的系数是：\n- $P_0$ 系数：$\\frac{23 \\cdot 2 - 11 \\cdot 5}{30} = \\frac{46-55}{30} = -\\frac{9}{30} = -\\frac{3}{10}$\n- $P_1$ 系数：$\\frac{14 - 20}{5} = -\\frac{6}{5}$\n- $P_2$ 系数：$\\frac{62 \\cdot 2 - 19 \\cdot 7}{42} = \\frac{124 - 133}{42} = -\\frac{9}{42} = -\\frac{3}{14}$\n所以，差值多项式是 $\\Delta(x) = -\\frac{3}{10}P_0(x) - \\frac{6}{5}P_1(x) - \\frac{3}{14}P_2(x)$。\n误差 $E$ 是 $\\Delta(x)^2$ 的积分。由于 Legendre 多项式的正交性，对于 $m \\neq n$，有 $\\int_{-1}^{1} P_m(x) P_n(x) \\,\\mathrm{d}x = 0$。\n$$E = \\int_{-1}^{1} \\left( -\\frac{3}{10}P_0(x) - \\frac{6}{5}P_1(x) - \\frac{3}{14}P_2(x) \\right)^2 \\,\\mathrm{d}x$$\n$$E = \\left(-\\frac{3}{10}\\right)^2 \\int_{-1}^{1} P_0(x)^2 \\,\\mathrm{d}x + \\left(-\\frac{6}{5}\\right)^2 \\int_{-1}^{1} P_1(x)^2 \\,\\mathrm{d}x + \\left(-\\frac{3}{14}\\right)^2 \\int_{-1}^{1} P_2(x)^2 \\,\\mathrm{d}x$$\n使用正交关系 $\\int_{-1}^{1} P_n(x)^2 \\,\\mathrm{d}x = \\frac{2}{2n+1}$：\n- $\\int_{-1}^{1} P_0(x)^2 \\,\\mathrm{d}x = \\frac{2}{1} = 2$\n- $\\int_{-1}^{1} P_1(x)^2 \\,\\mathrm{d}x = \\frac{2}{3}$\n- $\\int_{-1}^{1} P_2(x)^2 \\,\\mathrm{d}x = \\frac{2}{5}$\n将这些值代入 $E$ 的表达式中：\n$$E = \\frac{9}{100}(2) + \\frac{36}{25}\\left(\\frac{2}{3}\\right) + \\frac{9}{196}\\left(\\frac{2}{5}\\right)$$\n$$E = \\frac{18}{100} + \\frac{24}{25} + \\frac{18}{980} = \\frac{9}{50} + \\frac{24}{25} + \\frac{9}{490}$$\n为了对这些分数求和，我们找到一个公分母。\n$$E = \\frac{9}{50} + \\frac{48}{50} + \\frac{9}{490} = \\frac{57}{50} + \\frac{9}{490}$$\n$50 = 2 \\cdot 5^2$ 和 $490 = 2 \\cdot 5 \\cdot 7^2$ 的最小公倍数是 $2 \\cdot 5^2 \\cdot 7^2 = 2450$。\n$$E = \\frac{57 \\cdot 49}{2450} + \\frac{9 \\cdot 5}{2450} = \\frac{2793}{2450} + \\frac{45}{2450} = \\frac{2793+45}{2450} = \\frac{2838}{2450}$$\n通过将分子和分母除以它们的最大公约数 $2$ 来化简分数：\n$$E = \\frac{1419}{1225}$$\n分子 $1419 = 3 \\cdot 473$ 且分母 $1225=5^2 \\cdot 7^2$。它们没有公因子，所以该分数为最简形式。", "answer": "$$\\boxed{\\frac{1419}{1225}}$$", "id": "3363449"}, {"introduction": "最后一个练习将从一个实用的计算角度，比较处理非线性项的两种常见策略：节点（伪谱）路径和模态卷积路径。通过编程实现，您将亲眼观察到依赖于欠积分求积的节点方法会产生混叠误差，而使用足够高精度计算的模态路径则不会。这个练习突显了在非线性谱计算中，具体实现选择对计算精度的关键影响。[@problem_id:3363437]", "problem": "考虑在定义域为 $[-1,1]$ 的一维参考单元上的谱元法 (SEM)。令 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 表示 $[-1,1]$ 上带有标准 $L^2$ 内积的勒让德多项式基。对于给定的多项式阶数 $N \\in \\mathbb{N}$，定义一个模态函数\n$$\nu(x) = \\sum_{n=0}^{N} a_n P_n(x), \\quad \\text{其中} \\quad a_n = \\frac{1}{n+1}.\n$$\n我们感兴趣的非线性量是平方 $u^2(x)$。我们比较了在勒让德模态空间中获得 $u^2(x)$ 的 $N$ 阶近似的两种计算路径：\n- 节点路径：在 $N$ 阶 Gauss-Lobatto-Legendre (GLL) 节点（即包含端点的 $N+1$ 个节点）上计算逐点乘积 $u^2(x)$，然后使用 GLL 求积权重投影到模态空间 $\\text{span}\\{P_0,\\dots,P_N\\}$。\n- 模态卷积截断路径：通过在勒让德基中计算精确内积（等效于通过 Gaunt 三重积系数 $\\int_{-1}^{1} P_n(x) P_m(x) P_k(x)\\,\\mathrm{d}x$）来计算 $u^2(x)$ 的模态系数，然后截断以保留模式 $k \\le N$。\n\n您必须使用的基本依据是：\n- 勒让德多项式的正交性，\n$$\n\\int_{-1}^{1} P_k(x) P_\\ell(x)\\,\\mathrm{d}x = \\begin{cases}\n\\frac{2}{2k+1},  k=\\ell,\\\\\n0,  k\\ne \\ell,\n\\end{cases}\n$$\n- 具有 $N+1$ 个节点的 Gauss-Lobatto-Legendre (GLL) 求积对于最高 $2N-1$ 阶多项式的精确度，以及具有 $M$ 个节点的 Gauss-Legendre (GL) 求积对于最高 $2M-1$ 阶多项式的精确度。\n\n定义 $u^2$ 到 $P_k$ 上的 $L^2$ 模态投影系数为\n$$\nc_k^{\\star} = \\frac{\\int_{-1}^{1} u^2(x) P_k(x)\\,\\mathrm{d}x}{\\int_{-1}^{1} P_k^2(x)\\,\\mathrm{d}x} = \\frac{2k+1}{2}\\int_{-1}^{1} u^2(x) P_k(x)\\,\\mathrm{d}x, \\quad 0\\le k\\le N,\n$$\n这表示 $u^2(x)$ 的精确 $N$ 阶 $L^2$ 投影系数。\n\n这些系数的节点路径近似值 $c_k^{\\text{nod}}$ 通过以下方式获得：\n1. 在 $N+1$ 个 GLL 节点 $\\{x_q\\}_{q=0}^{N}$ 和权重 $\\{w_q\\}_{q=0}^{N}$ 处计算 $u(x)$ 的值，\n2. 形成逐点平方 $u^2(x_q)$，\n3. 计算\n$$\nc_k^{\\text{nod}} = \\frac{\\sum_{q=0}^{N} w_q\\,u^2(x_q)\\,P_k(x_q)}{\\int_{-1}^{1} P_k^2(x)\\,\\mathrm{d}x} = \\frac{2k+1}{2}\\sum_{q=0}^{N} w_q\\,u^2(x_q)\\,P_k(x_q).\n$$\n\n模态卷积截断近似值 $c_k^{\\text{conv}}$ 通过计算内积得到\n$$\nc_k^{\\text{conv}} = \\frac{\\int_{-1}^{1} u^2(x) P_k(x)\\,\\mathrm{d}x}{\\int_{-1}^{1} P_k^2(x)\\,\\mathrm{d}x},\n$$\n使用具有 $M$ 个节点的足够高阶的 Gauss-Legendre 求积，选择的 $M$ 使其对于高达 $3N$ 阶的多项式积分是精确的。然后将所得系数截断至模式 $k \\le N$。\n\n将混叠误差定义为计算出的低阶模态表示与精确低阶模态表示之差的 $L^2$ 范数。由于勒让德多项式是正交的，该误差简化为系数差异的加权欧几里得范数：\n$$\nE_{\\text{nodal}}(N) = \\left( \\sum_{k=0}^{N} \\left(c_k^{\\text{nod}} - c_k^{\\star}\\right)^2 \\int_{-1}^{1} P_k^2(x)\\,\\mathrm{d}x \\right)^{1/2} = \\left( \\sum_{k=0}^{N} \\left(c_k^{\\text{nod}} - c_k^{\\star}\\right)^2 \\frac{2}{2k+1} \\right)^{1/2},\n$$\n$$\nE_{\\text{conv}}(N) = \\left( \\sum_{k=0}^{N} \\left(c_k^{\\text{conv}} - c_k^{\\star}\\right)^2 \\frac{2}{2k+1} \\right)^{1/2}.\n$$\n\n任务：\n1. 实现上述两种路径。对于节点路径，使用 Gauss-Lobatto-Legendre 节点和权重。对于模态卷积截断路径和计算 $c_k^{\\star}$，使用具有 $M = 3N+3$ 个节点的 Gauss-Legendre 求积，以确保对高达 $6N+5$ 阶的多项式是精确的。\n2. 对于测试套件中的每个多项式阶数，计算 $E_{\\text{nodal}}(N)$ 和 $E_{\\text{conv}}(N)$，并确定哪种路径在实践中产生更小的混叠。输出一个布尔值，指示是否 $E_{\\text{conv}}(N)  E_{\\text{nodal}}(N)$。\n3. 测试套件：\n   - 案例 1: $N=1$\n   - 案例 2: $N=3$\n   - 案例 3: $N=8$\n   - 案例 4: $N=16$\n4. 输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[N, E_{\\text{nodal}}(N), E_{\\text{conv}}(N), \\text{is\\_conv\\_better}]$ 的列表形式，其中 $N$ 是整数，$E_{\\text{nodal}}(N)$ 和 $E_{\\text{conv}}(N)$ 是浮点数，$\\text{is\\_conv\\_better}$ 是布尔值。例如：$[[1,0.0,0.0,True],[3,0.1,0.0,True]]$。\n\n该问题纯属数学问题，不涉及任何物理单位。不出现角度。不需要百分比。该设计旨在探究非线性谱计算中因积分不足而产生的混叠问题，并要求您确定哪种计算路径产生更小的混叠，以及结果如何依赖于多项式阶数 $N$。", "solution": "该问题要求在谱元法的框架内，比较两种用于确定平方多项式 $u^2(x)$ 的低阶模态系数的计算路径。该函数在 $N$ 阶勒让德多项式基中定义为 $u(x) = \\sum_{n=0}^{N} a_n P_n(x)$，系数为 $a_n = \\frac{1}{n+1}$。这两种路径分别是节点乘积后投影，以及直接模态卷积后截断。问题的核心是量化节点路径引入的混叠误差。\n\n分析的关键在于所用求积法则的性质。一个具有 $K$ 个点的高斯型求积可精确积分最高 $2K-1$ 阶的多项式。具有 $N+1$ 个点的 Gauss-Lobatto-Legendre (GLL) 求积是一个显著的例外，它对最高 $2N-1$ 阶的多项式是精确的。\n\n首先，我们分析 **模态卷积截断路径**。系数 $c_k^{\\text{conv}}$ 是通过计算 $L^2$ 投影定义中的积分来得到的：\n$$\nc_k^{\\text{conv}} = \\frac{2k+1}{2}\\int_{-1}^{1} u^2(x) P_k(x)\\,\\mathrm{d}x, \\quad 0 \\le k \\le N.\n$$\n函数 $u(x)$ 是一个 $N$ 阶多项式，因此它的平方 $u^2(x)$ 是一个 $2N$ 阶多项式。被积函数 $u^2(x) P_k(x)$ 因此是一个 $2N+k$ 阶的多项式。对于所考虑的模式范围 $0 \\le k \\le N$，被积函数的最高阶数为 $2N+N=3N$。问题指定使用具有 $M=3N+3$ 个节点的 Gauss-Legendre (GL) 求积来计算该积分。此 GL 求积对于最高 $2M-1 = 2(3N+3)-1 = 6N+5$ 阶的多项式是精确的。由于对于所有 $N \\ge 0$ 都有 $6N+5 \\ge 3N$，因此该求积法则可以精确地（达到机器精度）计算积分。\n\n“精确”的 $N$ 阶投影系数 $c_k^{\\star}$ 由相同的积分定义。由于对于 $k \\le N$ 的 $c_k^{\\text{conv}}$ 和 $c_k^{\\star}$ 都是使用对基础积分精确的方法计算的，它们必定相同：$c_k^{\\text{conv}} = c_k^{\\star}$。因此，模态卷积路径的混叠误差恒为零：\n$$\nE_{\\text{conv}}(N) = \\left( \\sum_{k=0}^{N} (c_k^{\\text{conv}} - c_k^{\\star})^2 \\frac{2}{2k+1} \\right)^{1/2} = 0.\n$$\n\n接下来，我们分析 **节点路径**。系数 $c_k^{\\text{nod}}$ 是通过用 $N+1$ 个节点 $\\{x_q\\}_{q=0}^N$ 上的 GLL 求积和来代替积分计算的：\n$$\nc_k^{\\text{nod}} = \\frac{2k+1}{2}\\sum_{q=0}^{N} w_q\\,u^2(x_q)\\,P_k(x_q).\n$$\n这对应于使用一个仅对最高 $2N-1$ 阶多项式精确的求积法则来近似积分 $\\int_{-1}^{1} u^2(x) P_k(x)\\,\\mathrm{d}x$。如前所述，被积函数 $u^2(x) P_k(x)$ 是一个 $2N+k$ 阶的多项式。对于任何 $N \\ge 1$ 和 $k \\ge 0$，阶数 $2N+k$ 严格大于 $2N-1$。由于求积法则对被积函数不是精确的，计算出的和将不等于真实的积分值。这种差异被称为混叠，其产生的原因是，被积函数的高频内容（阶数大于 $2N-1$ 的模式）被求积和错误地表示（或“混叠”）为低频内容。这导致了不精确的系数 $c_k^{\\text{nod}} \\ne c_k^{\\star}$，从而产生了非零的混叠误差：\n$$\nE_{\\text{nodal}}(N) = \\left( \\sum_{k=0}^{N} (c_k^{\\text{nod}} - c_k^{\\star})^2 \\frac{2}{2k+1} \\right)^{1/2}  0.\n$$\n\n从这个分析可以清楚地看出，对于所有 $N \\ge 1$ 的测试用例，模态卷积路径是完全精确的，而节点路径会引入混叠误差。因此，我们可以预测 $E_{\\text{conv}}(N)  E_{\\text{nodal}}(N)$ 对所有指定的 $N$ 值都成立。\n\n实现将按以下步骤进行：\n1.  对于测试套件中的每个 $N$，我们定义 $u(x)$ 模态展开的系数 $a_n = 1/(n+1)$。\n2.  我们通过使用高阶（$M=3N+3$ 点）Gauss-Legendre 求积对定义积分进行数值计算，来计算“精确”系数 $c_k^{\\star}$（其等于 $c_k^{\\text{conv}}$），这保证了结果达到机器精度。\n3.  我们首先生成 $N+1$ 个 Gauss-Lobatto-Legendre 节点和权重，来计算节点系数 $c_k^{\\text{nod}}$。节点包括端点 $\\{-1, 1\\}$ 和勒让德多项式 $P_N'(x)$ 导数的根。权重根据标准公式 $w_q = 2 / (N(N+1) [P_N(x_q)]^2)$ 计算。然后，我们在这些节点上计算 $u(x)$ 的值，计算逐点平方 $u^2(x_q)$，并执行加权和来求得系数。\n4.  然后使用各自的定义计算误差 $E_{\\text{nodal}}(N)$ 和 $E_{\\text{conv}}(N)$。根据构造，$E_{\\text{conv}}(N)$ 将为零。\n5.  最后，我们比较两个误差并确定 $E_{\\text{conv}}(N)  E_{\\text{nodal}}(N)$ 的布尔值。收集所有测试用例的结果并按指定格式进行格式化。\n\n所需的 `scipy` 和 `numpy` 库提供了用于 Gauss-Legendre 求积 (`scipy.special.roots_legendre`) 和计算勒让德多项式 (`scipy.special.eval_legendre`) 的函数。GLL 求积点和权重将基于 `numpy.polynomial.legendre` 中可用的勒让德多项式的性质来实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_legendre\nfrom numpy.polynomial.legendre import Legendre\n\ndef get_gll_quadrature(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes and weights for a given polynomial degree N.\n    \"\"\"\n    if N == 0:\n        # Not required by problem but included for completeness\n        return np.array([0.0]), np.array([2.0])\n    if N == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are the roots of the derivative of P_N(x)\n    p_N_poly = Legendre.basis(N)\n    p_N_prime = p_N_poly.deriv(1)\n    interior_nodes = p_N_prime.roots()\n    \n    # Full set of nodes includes endpoints\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n    \n    # Weights using the formula w_j = 2 / (N(N+1) * P_N(x_j)^2)\n    weights = 2.0 / (N * (N + 1) * (p_N_poly(nodes)**2))\n    \n    return nodes, weights\n\ndef solve():\n    \"\"\"\n    Computes and compares aliasing error from nodal and modal convolution pathways for a squared polynomial.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 3, 8, 16]\n\n    results = []\n    for N in test_cases:\n        # Define the modal function u(x) with coefficients a_n = 1/(n+1)\n        n_vals = np.arange(N + 1, dtype=int)\n        a_coeffs = 1.0 / (n_vals + 1.0)\n        \n        # --- Compute exact coefficients c_k_star (and c_k_conv) ---\n        # Use high-order Gauss-Legendre quadrature with M = 3N+3 points\n        M = 3 * N + 3\n        nodes_gl, weights_gl = roots_legendre(M)\n        \n        # Evaluate u(x) at GL nodes: u(y_j) = sum_{n=0..N} a_n * P_n(y_j)\n        # Using a matrix representation for efficiency: P_matrix_gl[j, n] = P_n(nodes_gl[j])\n        P_matrix_gl = np.array([eval_legendre(n, nodes_gl) for n in n_vals]).T\n        u_at_gl = P_matrix_gl @ a_coeffs\n        \n        # Compute c_k_star for k=0,...,N\n        k_vals = np.arange(N + 1, dtype=int)\n        c_k_star = np.zeros(N + 1)\n        for k in k_vals:\n            Pk_at_gl = eval_legendre(k, nodes_gl)\n            integrand_at_gl = u_at_gl**2 * Pk_at_gl\n            integral = np.sum(weights_gl * integrand_at_gl)\n            c_k_star[k] = (2.0 * k + 1.0) / 2.0 * integral\n            \n        c_k_conv = c_k_star.copy()\n\n        # --- Compute nodal coefficients c_k_nod ---\n        # Use N+1 point Gauss-Lobatto-Legendre quadrature\n        nodes_gll, weights_gll = get_gll_quadrature(N)\n\n        # Evaluate u(x) at GLL nodes: u(x_q) = sum_{n=0..N} a_n * P_n(x_q)\n        P_matrix_gll = np.array([eval_legendre(n, nodes_gll) for n in n_vals]).T\n        u_at_gll = P_matrix_gll @ a_coeffs\n\n        # Compute c_k_nod for k=0,...,N\n        c_k_nod = np.zeros(N + 1)\n        for k in k_vals:\n            Pk_at_gll = P_matrix_gll[:, k]  # P_k(nodes_gll)\n            integrand_at_gll = u_at_gll**2 * Pk_at_gll\n            integral_approx = np.sum(weights_gll * integrand_at_gll)\n            c_k_nod[k] = (2.0 * k + 1.0) / 2.0 * integral_approx\n            \n        # --- Compute errors ---\n        # L2 norm weights for the coefficient vectors\n        weights_L2 = 2.0 / (2.0 * k_vals + 1.0)\n\n        # Nodal error calculation\n        error_coeffs_nodal = c_k_nod - c_k_star\n        E_nodal = np.sqrt(np.sum(error_coeffs_nodal**2 * weights_L2))\n        \n        # Convolution error calculation\n        # By definition and construction, E_conv must be zero (to machine precision)\n        error_coeffs_conv = c_k_conv - c_k_star\n        E_conv = np.sqrt(np.sum(error_coeffs_conv**2 * weights_L2))\n        \n        # Compare errors and store the result for this test case\n        is_conv_better = bool(E_conv  E_nodal)\n        results.append([N, E_nodal, E_conv, is_conv_better])\n    \n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in results:\n        # Note: str(bool) in Python produces \"True\" or \"False\", which matches the example's capitalization.\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]},{str(res[3])}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3363437"}]}