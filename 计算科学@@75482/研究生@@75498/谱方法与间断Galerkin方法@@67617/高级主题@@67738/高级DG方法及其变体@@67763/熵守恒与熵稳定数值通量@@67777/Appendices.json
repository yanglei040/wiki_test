{"hands_on_practices": [{"introduction": "从基本原理出发推导一个熵守恒通量是理解该领域的第一步。本练习将引导您针对经典的 Burgers 方程，利用 Tadmor 的熵守恒条件，亲手构造一个两点熵守恒数值通量[@problem_id:3384448]。这个过程将加深您对熵对、熵势以及作为熵守恒基础的离散链式法则等核心理论定义的理解。", "problem": "考虑无粘流的标量守恒律，即Burgers方程 $u_{t} + \\left(f(u)\\right)_{x} = 0$，其中 $f(u) = \\frac{u^{2}}{2}$，并使用间断Galerkin (DG) 方法进行离散化。设熵对 $(U(u),q(u))$ 由严格凸熵 $U(u)$ 和满足相容性条件 $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$ 的相应熵通量 $q(u)$ 定义，其中熵变量为 $v(u) = U^{\\prime}(u)$。Tadmor对两点数值通量 $f^{ec}(u_{L},u_{R})$ 的熵守恒条件是，界面贡献使用通量势 $\\psi(u)$ 满足一个离散链式法则，即 $\\left(v_{R} - v_{L}\\right)\\,f^{ec}(u_{L},u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$，其中 $\\psi(u)$ 根据熵对和物理通量定义。\n\n仅使用熵对的定义和上述离散熵守恒条件，特化为二次熵 $U(u) = \\frac{u^{2}}{2}$，并执行以下步骤：\n- 根据相容性条件 $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$ 推导熵通量 $q(u)$。\n- 使用恒等式 $\\psi(u) = v(u)\\,f(u) - q(u)$，从熵对和物理通量中定义通量势 $\\psi(u)$。\n- 使用Tadmor条件构建两点熵守恒通量 $f^{ec}(u_{L},u_{R})$ 的闭式表达式，该表达式在极限 $u_{L} \\to u_{R}$ 下是对称、相容且连续的。\n\n将你的最终答案表述为 $f^{ec}(u_{L},u_{R})$ 的单个闭式解析表达式。无需进行数值计算或四舍五入。", "solution": "该问题陈述被评估为有效，因为它具有科学依据、适定且客观。它展示了双曲守恒律数值方法领域的一个标准推导，特别是熵守恒通量的构造。所提供的所有定义和条件在文献中都是标准的（例如，Tadmor, 1987）。\n\n我们按要求进行推导。问题指定了Burgers方程，其物理通量为 $f(u) = \\frac{u^{2}}{2}$。我们将使用特定的二次熵函数 $U(u) = \\frac{u^{2}}{2}$。\n\n首先，我们推导相应的熵变量 $v(u)$ 和熵通量 $q(u)$。\n熵变量 $v(u)$ 定义为熵函数 $U(u)$ 关于守恒变量 $u$ 的导数：\n$$v(u) = U^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\n熵通量 $q(u)$ 由相容性条件 $q^{\\prime}(u) = v(u)f^{\\prime}(u)$ 确定。首先，我们求物理通量 $f(u)$ 的导数：\n$$f^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\n现在我们将 $v(u)$ 和 $f^{\\prime}(u)$ 代入相容性条件：\n$$q^{\\prime}(u) = (u)(u) = u^{2}$$\n为了求得 $q(u)$，我们对 $q^{\\prime}(u)$ 关于 $u$ 进行积分。我们可以将积分常数设为零，因为熵通量的定义可以相差一个可加常数，这个常数在取差分时会被消除：\n$$q(u) = \\int u^{2} \\, du = \\frac{u^{3}}{3}$$\n\n接下来，我们使用所提供的恒等式 $\\psi(u) = v(u)f(u) - q(u)$ 来定义通量势 $\\psi(u)$。我们代入 $v(u)$、$f(u)$ 和 $q(u)$ 的表达式：\n$$\\psi(u) = (u)\\left(\\frac{u^{2}}{2}\\right) - \\frac{u^{3}}{3} = \\frac{u^{3}}{2} - \\frac{u^{3}}{3}$$\n合并各项，得到通量势的表达式：\n$$\\psi(u) = \\frac{3u^{3} - 2u^{3}}{6} = \\frac{u^{3}}{6}$$\n\n最后，我们使用Tadmor熵守恒条件来构造两点熵守恒通量 $f^{ec}(u_{L}, u_{R})$：\n$$\\left(v(u_{R}) - v(u_{L})\\right)f^{ec}(u_{L}, u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$$\n代入我们求得的 $v(u)$ 和 $\\psi(u)$ 的表达式，我们有 $v(u_{L}) = u_{L}$、$v(u_{R}) = u_{R}$、$\\psi(u_{L}) = \\frac{u_{L}^{3}}{6}$ 和 $\\psi(u_{R}) = \\frac{u_{R}^{3}}{6}$。该条件变为：\n$$\\left(u_{R} - u_{L}\\right)f^{ec}(u_{L}, u_{R}) = \\frac{u_{R}^{3}}{6} - \\frac{u_{L}^{3}}{6}$$\n为了求得通量，我们通过除以 $(u_{R} - u_{L})$ 来解出 $f^{ec}(u_{L}, u_{R})$，假设 $u_{R} \\neq u_{L}$：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{1}{u_{R} - u_{L}}\\left(\\frac{u_{R}^{3} - u_{L}^{3}}{6}\\right) = \\frac{u_{R}^{3} - u_{L}^{3}}{6(u_{R} - u_{L})}$$\n为了获得一个即使在 $u_{L} = u_{R}$ 时也连续且有明确定义的闭式表达式，我们使用立方差的代数恒等式 $a^{3} - b^{3} = (a-b)(a^{2} + ab + b^{2})$：\n$$u_{R}^{3} - u_{L}^{3} = (u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})$$\n将此因式分解形式代入通量的表达式中：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{(u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})}{6(u_{R} - u_{L})}$$\n消去 $(u_{R} - u_{L})$ 项，我们得到熵守恒通量的最终表达式：\n$$f^{ec}(u_{L}, u_{R}) = \\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}$$\n这个表达式是对称的，因为交换 $u_{L}$ 和 $u_{R}$ 不会改变表达式。它也是相容的，因为在极限 $u_{L} \\to u_{R} = u$ 的情况下，我们有：\n$$f^{ec}(u, u) = \\frac{u^{2} + u \\cdot u + u^{2}}{6} = \\frac{3u^{2}}{6} = \\frac{u^{2}}{2} = f(u)$$\n这满足了问题的所有要求。", "answer": "$$\\boxed{\\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}}$$", "id": "3384448"}, {"introduction": "一个熵守恒格式的构建不仅在于通量函数本身，离散化过程中的其他环节同样至关重要，例如体积积分的计算方式。本练习将深入探讨体积积分求积法则在维持离散熵平衡中的关键作用[@problem_id:3384466]。通过分析熵产生项的多项式阶数，您将推导出所需的最小求积精度，并用数值实验量化积分精度不足所导致的伪熵产生。", "problem": "您将研究在节点谱方法和间断 Galerkin 离散化中，体积欠积分如何影响一维标量守恒律的离散熵平衡。考虑参考区间 $[-1,1]$ 上的标量守恒律 $u_t + f(u)_x = 0$。令 $U(u)$ 表示一个严格凸的数学熵，令 $F(u)$ 表示满足 $F'(u) = U'(u) f'(u)$ 的相关熵通量。对于足够光滑的 $u$，连续熵恒等式为 $U(u)_t + F(u)_x = 0$，在 $[-1,1]$ 上积分后，可得 $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$。在节点谱方法或间断 Galerkin 离散化中，半离散熵平衡取决于体积项 $\\int_{-1}^{1} U'(u) \\, f(u)_x \\, dx$ 的近似方式。当使用欠积分求积法计算体积积分时，可能会产生伪熵。\n\n您的任务是：\n- 当 $u$ 用 $p$ 阶多项式逼近，非线性通量为 Burgers 通量 $f(u) = \\frac{1}{2} u^2$ 且熵为二次熵 $U(u) = \\frac{1}{2} u^2$ 时，根据标量守恒律的基本性质和链式法则，推导熵平衡中离散体积项被积函数的多项式阶数界限。据此推断出足以避免体积项产生伪熵的最小求积精度要求（用 $p$ 表示）。\n- 使用两类单元体积求积法则来量化欠积分效应：\n  1. 在 $[-1,1]$ 上使用 $N$ 个点的高斯-勒让德求积，其对最高为 $2N - 1$ 阶的多项式是精确的。\n  2. 在 $[-1,1]$ 上使用 $N$ 个点的高斯-洛巴托-勒让德求积，其对最高为 $2N - 3$ 阶的多项式是精确的。\n- 实现一个程序，对于给定的多项式阶数 $p$，构造一个代表性的 $p$ 阶多项式逼近 $u_p(x)$，并计算离散熵残差\n  $$ R_N = \\sum_{i=1}^{N} w_i \\, U'(u_p(x_i)) \\, \\frac{d}{dx} f(u_p(x_i)) \\;-\\; \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1}, $$\n  其中 $\\{x_i,w_i\\}_{i=1}^{N}$ 是高斯-勒让德求积或高斯-洛巴托-勒让德求积的求积节点和权重。此处，$U(u) = \\frac{1}{2} u^2$，$U'(u) = u$，$f(u) = \\frac{1}{2} u^2$，$F(u) = \\frac{1}{3} u^3$。选择\n  $$ u_p(x) = \\sum_{k=0}^{p} \\frac{1}{k+1} P_k(x), $$\n  其中 $P_k(x)$ 表示 $[-1,1]$ 上的 $k$ 阶勒让德多项式，从而使 $u_p$ 包含直至 $p$ 阶的所有阶次的非平凡贡献。通过对 $u_p$ 进行解析微分，精确计算 $\\frac{d}{dx} f(u_p(x))$。\n- 对于 $10^{-12}$ 的容差，找出对于两种求积族和每个多项式阶数 $p$，使得 $|R_N| \\le 10^{-12}$ 的最小 $N$。此外，通过报告两种求积（高斯-勒让德和高斯-洛巴托-勒让德）在使用 $N = p+1$ 个体积点时的 $|R_{p+1}|$ 值，来量化伪熵产生的大小。\n\n对 $p$ 使用以下测试组：\n- $p = 1$ （边界情况，低阶交互作用可能被点数不多的求积精确积分），\n- $p = 2$ （中等阶数），\n- $p = 3$ （典型的非平凡情况），\n- $p = 4$ （更高阶数以揭示尺度关系）。\n\n您的程序必须：\n- 对于测试组中的每个 $p$，计算并返回包含四个值的列表：\n  1. 对于高斯-勒让德求积，使得 $|R_N| \\le 10^{-12}$ 的最小 $N$ 值，\n  2. 对于高斯-洛巴托-勒让德求积，使得 $|R_N| \\le 10^{-12}$ 的最小 $N$ 值，\n  3. 使用 $N = p+1$ 的高斯-勒让德求积得到的 $|R_{p+1}|$ 值，\n  4. 使用 $N = p+1$ 的高斯-洛巴托-勒让德求积得到的 $|R_{p+1}|$ 值。\n- 将测试组的结果汇总到单行输出中，格式为包含在方括号内的、由逗号分隔的列表组成的列表（例如，$[ [a_1,a_2,a_3,a_4], [b_1,b_2,b_3,b_4], \\dots ]$）。\n\n注意事项和约束：\n- 分析和程序必须基于 $U'(u) f'(u) u_x$ 的链式法则恒等式以及 $F(u)$ 的精确端点求值。不得包含任何额外的稳定化项或界面项，且本问题不涉及物理单位。\n- 本问题不使用角度。\n- 所有输出必须是纯数字；不要使用百分号或任何单位。\n\n您的程序应生成单行输出，其中包含结果，格式为一个由逗号分隔的列表，并用方括号括起来（例如，$[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}],[r_{41},r_{42},r_{43},r_{44}]]$），其中每个 $r_{ij}$ 都是如上所述的数字。", "solution": "该问题要求分析标量守恒律的节点谱方法或间断 Galerkin 方法中，由体积欠积分引起的伪熵产生。我们必须首先建立离散熵平衡的公式，然后确定体积积分项能够被精确计算的条件。\n\n守恒律的半离散形式，在乘以测试函数 $\\phi$ 并在参考单元 $I = [-1, 1]$ 上积分后，为\n$$ \\frac{d}{dt} \\int_{-1}^{1} u_p \\phi \\, dx - \\int_{-1}^{1} f(u_p) \\phi_x \\, dx + \\left[ f(u_p) \\phi \\right]_{x=-1}^{x=1} = 0 $$\n其中 $u_p$ 是解 $u$ 的一个 $p$ 阶多项式逼近。为分析熵稳定性，通常选择测试函数 $\\phi$ 与熵变量 $v = U'(u)$ 相关。在节点 DG 设置中，我们可以取 $\\phi = v(u_p) = U'(u_p)$。时间导数项变为 $\\int_{-1}^{1} U'(u_p) \\frac{\\partial u_p}{\\partial t} \\, dx = \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx$。因此，单元的半离散熵平衡为\n$$ \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx + \\int_{-1}^{1} U'(u_p) f(u_p)_x \\, dx = \\text{边界和界面项} $$\n连续熵恒等式表明 $U(u)_t + F(u)_x = 0$。在单元上积分得到 $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$。离散格式应模仿这一点。本问题的重点是体积积分 $\\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx$。\n\n在数值实现中，该积分被求积和所取代：\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx \\approx \\sum_{i=1}^{N} w_i U'(u_p(x_i)) f(u_p(x_i))_x $$\n其中 $\\{x_i, w_i\\}_{i=1}^{N}$ 是求积节点和权重。\n\n分析的核心在于将被积函数与熵通量 $F(u)$ 联系起来的恒等式。根据链式法则，$f(u_p(x))_x = f'(u_p(x)) u_p'(x)$。因此被积函数为：\n$$ I(x) = U'(u_p(x)) f'(u_p(x)) u_p'(x) $$\n熵通量 $F(u)$ 的定义满足 $F'(u) = U'(u) f'(u)$。将此代入被积函数可得：\n$$ I(x) = F'(u_p(x)) u_p'(x) $$\n再次应用链式法则，这恰好是复合函数 $F(u_p(x))$ 的导数：\n$$ I(x) = \\frac{d}{dx} F(u_p(x)) $$\n因此，可以使用微积分基本定理求得体积积分的精确值：\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx = \\int_{-1}^{1} \\frac{d}{dx} F(u_p(x)) \\, dx = \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1} $$\n问题中定义的离散熵残差 $R_N$ 度量了该积分的求积法则误差：\n$$ R_N = \\left( \\sum_{i=1}^{N} w_i I(x_i) \\right) - \\int_{-1}^{1} I(x) \\, dx $$\n残差 $R_N$ 为零当且仅当求积法则对被积函数 $I(x)$ 是精确的。为确定所需的精度，我们必须求出 $I(x)$ 的多项式阶数。\n\n问题指定了 Burgers 通量 $f(u) = \\frac{1}{2} u^2$ 和二次熵 $U(u) = \\frac{1}{2} u^2$。由此可得熵变量 $U'(u) = u$ 和熵通量 $F(u) = \\frac{1}{3} u^3$。解的逼近 $u_p(x)$ 是一个 $p$ 阶多项式。复合函数 $F(u_p(x)) = \\frac{1}{3} (u_p(x))^3$ 是一个 $3p$ 阶多项式。因此，被积函数 $I(x) = \\frac{d}{dx} F(u_p(x))$ 是一个 $3p-1$ 阶的多项式。\n\n为使残差 $R_N$ 为零（在机器精度范围内），求积法则必须对所有阶数最高为 $3p-1$ 的多项式都是精确的。\n\n现在我们将此要求应用于指定的两个求积族：\n1. **高斯-勒让德求积**：一个含 $N$ 个点的法则对最高为 $2N-1$ 阶的多项式是精确的。为避免体积项产生伪熵，我们需要：\n    $$ 2N - 1 \\ge 3p - 1 \\implies 2N \\ge 3p \\implies N \\ge \\frac{3p}{2} $$\n    由于 $N$ 必须是整数，高斯-勒让德求积点的最小数量是 $N_{GL} = \\lceil \\frac{3p}{2} \\rceil$。\n\n2. **高斯-洛巴托-勒让德求积**：一个含 $N$ 个点的法则对最高为 $2N-3$ 阶的多项式是精确的。要求是：\n    $$ 2N - 3 \\ge 3p - 1 \\implies 2N \\ge 3p + 2 \\implies N \\ge \\frac{3p}{2} + 1 $$\n    高斯-洛巴托-勒让德求积点的最小数量是 $N_{GLL} = \\lceil \\frac{3p}{2} + 1 \\rceil$。\n\n这些结果提供了确保离散体积积分与边界处熵通量变化相匹配所需的理论最小求积点数，从而为光滑解保持局部单元熵平衡。所提供的实现将验证这些理论预测，并量化在使用不足的点数（$N=p+1$）时的误差，这是欠积分或配点间断 Galerkin 方法中的常见情况。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of volume underintegration on the discrete entropy balance\n    for a nodal DG discretization of a scalar conservation law.\n    \"\"\"\n    TOL = 1e-12\n    test_ps = [1, 2, 3, 4]\n    all_results = []\n\n    def get_up_and_dup_poly1d(p):\n        \"\"\"Constructs polynomial objects for u_p(x) and its derivative u_p'(x).\"\"\"\n        u_p_poly = np.poly1d([0.0])\n        for k in range(p + 1):\n            coeff = 1.0 / (k + 1)\n            P_k = legendre(k)\n            u_p_poly += coeff * P_k\n        \n        du_p_poly = u_p_poly.deriv(1)\n        return u_p_poly, du_p_poly\n\n    def get_gll_quadrature(N):\n        \"\"\"\n        Computes Gauss-Lobatto-Legendre quadrature nodes and weights for [-1, 1].\n        This implementation is for SciPy versions  1.12.0 where roots_lobatto is not available.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Gauss-Lobatto-Legendre quadrature requires N >= 2 points.\")\n\n        # Nodes are {-1, 1} and the roots of P'_{N-1}(x)\n        p_N_minus_1_deriv = legendre(N - 1).deriv(1)\n        interior_nodes = p_N_minus_1_deriv.roots\n        nodes = np.zeros(N)\n        nodes[0] = -1.0\n        nodes[N - 1] = 1.0\n        nodes[1:-1] = np.sort(np.real_if_close(interior_nodes))\n\n        # Weights w_i = 2 / (N(N-1) * [P_{N-1}(x_i)]^2)\n        weights = np.zeros(N)\n        p_N_minus_1 = legendre(N - 1)\n        weights = 2.0 / (N * (N - 1) * p_N_minus_1(nodes)**2)\n        \n        return nodes, weights\n\n    def calculate_residual(p, N, quad_type):\n        \"\"\"Calculates the discrete entropy residual R_N.\"\"\"\n        u_p, du_p = get_up_and_dup_poly1d(p)\n\n        if quad_type == 'gauss-legendre':\n            if N == 0: return np.inf # Not meaningful\n            nodes, weights = roots_legendre(N)\n        elif quad_type == 'gauss-lobatto':\n            if N  2: return np.inf # Not meaningful\n            nodes, weights = get_gll_quadrature(N)\n        else:\n            raise ValueError(\"Unknown quadrature type\")\n\n        # Integrand I(x) = U'(u_p) * (d/dx f(u_p)) = u_p * (u_p * u_p') = u_p^2 * u_p'\n        u_p_vals = u_p(nodes)\n        du_p_vals = du_p(nodes)\n        integrand_vals = u_p_vals**2 * du_p_vals\n\n        # discrete volume integral\n        quad_sum = np.sum(weights * integrand_vals)\n\n        # Exact boundary term: [F(u_p(x))]_{-1}^1\n        # F(u) = 1/3 * u^3\n        u_p_at_1 = u_p(1.0)\n        u_p_at_minus_1 = u_p(-1.0)\n        boundary_term = (1.0 / 3.0) * (u_p_at_1**3 - u_p_at_minus_1**3)\n\n        residual = quad_sum - boundary_term\n        return residual\n\n    for p in test_ps:\n        p_results = []\n\n        # 1. Smallest N for Gauss-Legendre\n        N = 1\n        while True:\n            residual = calculate_residual(p, N, 'gauss-legendre')\n            if abs(residual) = TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 2. Smallest N for Gauss-Lobatto-Legendre\n        N = 2\n        while True:\n            residual = calculate_residual(p, N, 'gauss-lobatto')\n            if abs(residual) = TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 3. |R_{p+1}| for Gauss-Legendre\n        N_gl = p + 1\n        residual_gl = calculate_residual(p, N_gl, 'gauss-legendre')\n        p_results.append(abs(residual_gl))\n\n        # 4. |R_{p+1}| for Gauss-Lobatto-Legendre\n        N_gll = p + 1\n        residual_gll = calculate_residual(p, N_gll, 'gauss-lobatto')\n        p_results.append(abs(residual_gll))\n        \n        all_results.append(p_results)\n    \n    # Format output as a single string, a list of lists with no spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3384466"}, {"introduction": "掌握了标量方程的各个要素后，是时候将这些原理应用于更复杂、更具物理意义的可压缩欧拉方程组了。这项综合性练习要求您在一个完整的不连续伽辽金谱元法 (DGSEM) 框架内，实现一个前沿的熵守恒通量（Chandrashekar 通量）[@problem_id:3384472]。通过在一个周期性区域上验证数值总熵的守恒性，您将最终确认自己已经掌握了为守恒律方程组构建鲁棒、熵稳定格式的核心技能。", "problem": "考虑比热比为 $\\gamma \\in (1,2)$ 的理想气体的一维可压缩欧拉方程，其守恒形式对守恒变量向量 $u = [\\rho, \\rho u, \\rho E]^T$ 可写作：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0,\n$$\n其中物理通量 $f(u)$ 为\n$$\nf(u) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (\\rho E + p)\n\\end{bmatrix},\n$$\n且压力 $p$ 满足理想气体状态方程\n$$\np = (\\gamma - 1)\\left(\\rho E - \\tfrac{1}{2}\\rho u^2\\right).\n$$\n设数学熵为凸标量 $\\eta(u)$，定义为\n$$\n\\eta(u) = -\\frac{\\rho}{\\gamma - 1}\\left(\\ln p - \\gamma \\ln \\rho\\right),\n$$\n其相关的熵变量为 $v(u) = \\nabla_u \\eta(u)$，熵通量为 $\\phi(u)$，满足\n$$\n\\nabla_u \\eta(u)^T \\nabla_u f(u) = \\nabla_u \\phi(u).\n$$\n如果一个两点数值通量 $h_{EC}(u_L,u_R)$ 满足 Tadmor 恒等式，则称其为熵守恒的\n$$\n\\left(v(u_R) - v(u_L)\\right)^T h_{EC}(u_L,u_R) = \\psi(u_R) - \\psi(u_L),\n$$\n其中 $\\psi(u) = v(u)^T f(u) - \\phi(u)$ 是熵势。\n\n在一个将计算域 $[0,1]$ 划分为 $K_{\\text{el}}$ 个等长段的周期性网格上，对每个单元 $K$，考虑一个多项式次数为 $N$ 的间断 Galerkin 谱元法 (DGSEM)，该方法在参考区间 $[-1,1]$上使用 Legendre–Gauss–Lobatto 求积点 $\\{x_i\\}_{i=0}^N$ 和权重 $\\{w_i\\}_{i=0}^N$。设 $D$ 为在 Legendre–Gauss–Lobatto 节点上 Lagrange 基的节点微分矩阵，并设 $B = \\text{diag}(-1,0,\\dots,0,1)$。对于单元 $K$ 中的每个节点 $i$，分裂形式通量差分的 DGSEM 半离散强形式可以写作\n$$\n\\frac{\\partial u_i}{\\partial t} = -\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j) + \\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right),\n$$\n其中 $J_K$ 是从 $[-1,1]$ 到物理单元 $K$ 的仿射映射的雅可比行列式，$f^\\ast_{\\partial K}$ 是单元 $K$ 左/右面上的界面数值通量，其构造方法是在每个面上对左右两边的迹应用相同的两点熵守恒通量 $h_{EC}$。\n\n您必须：\n\n1. 使用上面定义的 Chandrashekar 熵守恒两点通量 $h_{EC}(u_L,u_R)$ 和理想气体熵 $\\eta(u)$，为一维可压缩欧拉方程构建分裂形式通量差分的 DGSEM。使用 $N \\ge 2$ 和 $K_{\\text{el}} \\ge 2$。\n\n2. 在周期性网格上，实现半离散 DGSEM 并计算离散总熵率\n$$\n\\frac{d}{dt}\\sum_{K}\\int_{K}\\eta(u)\\,dx \\approx \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t},\n$$\n并数值验证它等于所有单元边界上熵通量贡献的负和，\n$$\n-\\sum_{\\partial K}\\widehat{\\Phi}_\\eta,\n$$\n其中边界熵通量 $\\widehat{\\Phi}_\\eta$ 由相同的熵守恒界面通量导出，并且在周期性网格上必须为零。因此，在周期性网格上，对于物理上允许的状态，离散总熵率必须近似为零。\n\n您的推导和构建必须基于以下基本原理，不得使用问题陈述中提供的捷径公式：\n- 可压缩欧拉方程的守恒形式、理想气体定律，以及带有相关熵变量和熵通量的凸熵。\n- 在 $[-1,1]$ 上，使用 Lagrange 基的 Legendre–Gauss–Lobatto 求积及其微分矩阵的分部求和 (SBP) 性质。\n- Tadmor 针对两点通量和通量差分的熵守恒框架。\n\n实现一个完整的程序，该程序：\n- 为指定的多项式次数 $N$ 计算 Legendre–Gauss–Lobatto 节点和权重，构建节点微分矩阵 $D$，并内部验证 SBP 恒等式 $M D + D^T M = B$，其中 $M = \\text{diag}(w_0,\\dots,w_N)$。\n- 使用对数平均和适当的平均值，为一维欧拉方程实现 Chandrashekar 的熵守恒两点通量 $h_{EC}(u_L,u_R)$。\n- 为具有 $K_{\\text{el}}$ 个单元的周期性网格组装 DGSEM 残差，并使用熵变量计算离散总熵率。\n- 对于一系列光滑且物理上允许的测试状态，数值验证周期性网格上的离散总熵率近似为零。\n\n在 $[0,1]$ 上使用以下参数值和初始状态的测试套件：\n- 测试用例 1 (常数状态，理想路径)：$\\gamma=1.4$, $N=4$, $K_{\\text{el}}=4$, $\\rho(x)=1$, $u(x)=0.3$, $p(x)=1$。\n- 测试用例 2 (光滑扰动)：$\\gamma=1.4$, $N=5$, $K_{\\text{el}}=3$, $\\rho(x)=1+0.01\\cos(2\\pi x)$, $u(x)=0.5+0.05\\sin(2\\pi x)$, $p(x)=1+0.02\\cos(2\\pi x+0.3)$。\n- 测试用例 3 (围绕常数状态的小随机扰动)：$\\gamma=1.4$, $N=3$, $K_{\\text{el}}=5$, $\\rho(x)=1+10^{-3}\\,\\xi_1(x)$, $u(x)=0.2+10^{-3}\\,\\xi_2(x)$, $p(x)=1+10^{-3}\\,\\xi_3(x)$，其中 $\\xi_k(x)$ 是通过对每个单元采样独立的均匀随机值，并使用 $N$ 次 Lagrange 插值器插值到节点而生成的独立光滑随机场；如有必要，通过平移确保各处的 $p(x)  0.5$。\n- 测试用例 4 (边界分辨率边缘情况)：$\\gamma=1.4$, $N=2$, $K_{\\text{el}}=2$, $\\rho(x)=1+0.005\\sin(4\\pi x)$, $u(x)=0.1+0.005\\cos(4\\pi x)$, $p(x)=1+0.005\\sin(4\\pi x)$，如有需要进行调整以保持正性。\n\n对于每个测试用例，您的程序必须使用 DGSEM 残差计算周期性网格上的离散总熵率，并判断其幅值是否小于容差 $\\tau = 10^{-10}$，为每个用例返回一个布尔值结果。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），每个结果都是一个布尔值，指示相应测试用例的离散总熵率是否近似为零。", "solution": "用户旨在验证用于一维可压缩欧拉方程的间断 Galerkin 谱元法 (DGSEM) 的熵守恒性质。该方法基于一种分裂形式的通量差分方法，使用 Legendre-Gauss-Lobatto (LGL) 节点和 Chandrashekar 的熵守恒两点通量。问题要求进行数值验证，对于周期性域上的光滑、物理上允许的初始状态，离散总熵产率近似为零，这与熵守恒格式的理论要求一致。\n\n解决方案的结构如下：\n1.  **数学和数值预备知识**：建立函数来处理 DGSEM 框架的必要组件。这包括：\n    *   为给定的多项式次数 $N$ 生成 Legendre-Gauss-Lobatto (LGL) 节点和求积权重。这些节点是 $(1-x^2)P_N'(x)$ 的根，其中 $P_N(x)$ 是 $N$ 次 Legendre 多项式。\n    *   为定义在 LGL 节点上的 Lagrange 基构建节点微分矩阵 $D$。非对角线项使用 Legendre 多项式的性质计算，而对角线项则由常数导数必须为零的条件（$\\sum_j D_{ij} = 0$）确定。\n    *   对分部求和 (SBP) 性质 $M D + D^T M = B$ 进行内部验证，其中 $M$ 是求积权重的对角质量矩阵，$B$ 是边界算子 $\\text{diag}(-1, 0, \\dots, 0, 1)$。这确认了离散算子的正确性。\n\n2.  **物理建模**：实现函数以根据一维可压缩欧拉方程描述理想气体的物理特性。\n    *   守恒变量 $u=[\\rho, \\rho u, \\rho E]^T$ 和原始变量 $[\\rho, u, p]$ 之间的转换。\n    *   物理通量 $f(u) = [\\rho u, \\rho u^2 + p, u (\\rho E + p)]^T$。\n    *   从守恒状态 $u$ 计算熵变量 $v(u) = \\nabla_u \\eta(u)$。熵变量从指定的凸熵函数 $\\eta(u)$ 推导得出，其结果为 $v = [(\\gamma-s)/(\\gamma-1) - \\rho u^2/(2p), \\rho u/p, -\\rho/p]^T$，其中 $s = \\ln(p/\\rho^\\gamma)$。\n\n3.  **熵守恒通量**：实现了 Chandrashekar 的熵守恒两点通量 $h_{EC}(u_L, u_R)$。该通量对格式的稳定性至关重要。其公式依赖于左右 ($L$ 和 $R$) 状态的流体性质的特定平均值。具体来说，我们使用算术平均 $\\overline{(\\cdot)}$、对数平均 $\\overline{(\\cdot)}^{\\ln}$ 和一个特殊的压力平均 $\\overline{p} = (\\rho_L+\\rho_R) / (\\rho_L/p_L + \\rho_R/p_R)$。通量分量为：\n    $$ f_1^* = \\overline{\\rho}^{\\ln} \\overline{u} $$\n    $$ f_2^* = \\overline{p} + \\overline{u} f_1^* $$\n    $$ f_3^* = \\overline{u}\\left( \\frac{\\gamma\\overline{p}}{\\gamma-1} + \\frac{1}{2}\\overline{\\rho}^{\\ln}\\overline{u^2} \\right) $$\n\n4.  **DGSEM 残差组装**：组装 DGSEM 的半离散形式以计算每个节点 $i$ 处解的时间导数 $\\partial u_i / \\partial t$。对每个单元，这涉及两个主要部分：\n    *   **体积分**：一个通量差分项，$-\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j)$，它近似了单元内部通量的散度。\n    *   **面积分**：一个用于耦合相邻单元的项，$\\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right)$，它惩罚了单元边界处界面通量 $f^\\ast$ 和物理通量 $f(u_i)$ 之间的差异。对于周期性边界条件，单元边界处的界面通量是通过将 Chandrashekar 通量 $h_{EC}$ 应用于内部状态和来自相应周期性邻居的状态来构造的。\n\n5.  **熵守恒验证**：核心任务是计算离散总熵产率并验证其值可忽略不计。该率由应用于总离散熵的链式法则给出：\n    $$ \\frac{d\\mathcal{E}}{dt} = \\frac{d}{dt}\\sum_{K} J_K \\sum_{i=0}^N w_i \\eta(u_{K,i}) = \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t} $$\n    项 $\\partial u_{K,i} / \\partial t$ 是上一步计算的 DGSEM 残差。对于周期性域上的熵守恒格式，此量理论上为零。该实现计算此总和，并检查其幅值是否低于数值容差 $\\tau=10^{-10}$。\n\n6.  **测试执行**：将该程序应用于问题陈述中指定的四个测试用例，涵盖常数状态、光滑扰动和随机扰动。对于每个用例，设置初始条件，计算 DGSEM 残差，计算熵率，并将结果与容差进行比较。然后生成一个布尔值结果列表。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef solve():\n    \"\"\"\n    Main function to run the DGSEM entropy conservation verification.\n    \"\"\"\n    \n    # Test suite from problem statement\n    TEST_SUITE = [\n        {'gamma': 1.4, 'N': 4, 'K_el': 4, 'case': 'constant'},\n        {'gamma': 1.4, 'N': 5, 'K_el': 3, 'case': 'smooth_pert'},\n        {'gamma': 1.4, 'N': 3, 'K_el': 5, 'case': 'random_pert'},\n        {'gamma': 1.4, 'N': 2, 'K_el': 2, 'case': 'bdy_res'}\n    ]\n    TOLERANCE = 1e-10\n    LOGMEAN_EPS = 1e-5\n\n    # --- Start of Helper Functions ---\n    \n    def legendre_gauss_lobatto(N):\n        \"\"\"\n        Computes Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([2.0])\n        if N == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n\n        interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n        nodes = np.sort(np.concatenate(([-1.0], interior_nodes, [1.0])))\n        \n        Pn = legendre(N)\n        weights = 2 / (N * (N + 1) * Pn(nodes)**2)\n        return nodes, weights\n\n    def differentiation_matrix(N, nodes):\n        \"\"\"\n        Computes the differentiation matrix for Lagrange basis on LGL nodes.\n        \"\"\"\n        D = np.zeros((N + 1, N + 1))\n        Pn = legendre(N)\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i != j:\n                    D[i, j] = Pn(nodes[i]) / (Pn(nodes[j]) * (nodes[i] - nodes[j]))\n        \n        for i in range(N + 1):\n            D[i, i] = -np.sum(D[i, :])\n        return D\n\n    def sbp_check(N, D, M, B):\n        \"\"\"\n        Verifies the SBP property: M D + D^T M = B.\n        \"\"\"\n        err = np.linalg.norm(M @ D + D.T @ M - B)\n        if err > 1e-12:\n            raise RuntimeError(f\"SBP property check failed for N={N}. Error: {err}\")\n\n    def prim_to_cons(rho, u, p, gamma):\n        rho_u = rho * u\n        rho_E = p / (gamma - 1) + 0.5 * rho * u**2\n        return np.stack([rho, rho_u, rho_E], axis=-1)\n\n    def cons_to_prim(U, gamma):\n        rho = U[..., 0]\n        rho_u = U[..., 1]\n        rho_E = U[..., 2]\n        \n        # Add a small stabilization for division by zero\n        rho_stable = rho + 1e-40\n\n        u = rho_u / rho_stable\n        p = (gamma - 1) * (rho_E - 0.5 * rho * u**2)\n        return rho, u, p\n\n    def cons_to_entropy_vars(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        s = np.log(p) - gamma * np.log(rho)\n        v1 = (gamma - s) / (gamma - 1) - 0.5 * rho * u**2 / p\n        v2 = rho * u / p\n        v3 = -rho / p\n        return np.stack([v1, v2, v3], axis=-1)\n\n    def physical_flux(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        rho_E = U[..., 2]\n        \n        f1 = rho * u\n        f2 = rho * u**2 + p\n        f3 = (rho_E + p) * u\n        return np.stack([f1, f2, f3], axis=-1)\n\n    def logmean(a, b, epsilon=LOGMEAN_EPS):\n        a_ = np.asarray(a)\n        b_ = np.asarray(b)\n        out = np.zeros_like(a_, dtype=np.promote_types(a_.dtype, b_.dtype))\n\n        ratio = np.divide(b_, a_, where=a_!=0)\n        idx_close = np.abs(ratio - 1.0)  epsilon\n\n        # Non-broadcasted part\n        if a_.ndim == 0:\n            if idx_close: return (a_ + b_) / 2.0\n            return (a_ - b_) / (np.log(a_) - np.log(b_))\n        \n        out[idx_close] = (a_[idx_close] + b_[idx_close]) / 2.0\n        \n        idx_not_close = ~idx_close\n        a_nc, b_nc = a_[idx_not_close], b_[idx_not_close]\n        \n        # Handle cases where a_nc or b_nc could be zero\n        log_a = np.log(a_nc, where=a_nc>0)\n        log_b = np.log(b_nc, where=b_nc>0)\n\n        out[idx_not_close] = (a_nc - b_nc) / (log_a - log_b)\n        \n        return out\n\n    def chandrashekar_ec_flux(u_L, u_R, gamma):\n        rho_L, u_L, p_L = cons_to_prim(u_L, gamma)\n        rho_R, u_R, p_R = cons_to_prim(u_R, gamma)\n\n        rho_ln = logmean(rho_L, rho_R)\n        u_mean = 0.5 * (u_L + u_R)\n        u_sq_mean = 0.5 * (u_L**2 + u_R**2)\n\n        # Harmonic mean of pressure weighted by density\n        p_mean = (rho_L + rho_R) / (rho_L / p_L + rho_R / p_R)\n        \n        f1 = rho_ln * u_mean\n        f2 = p_mean + u_mean * f1\n        f3 = u_mean * (gamma * p_mean / (gamma - 1) + 0.5 * rho_ln * u_sq_mean)\n        \n        return np.stack([f1, f2, f3], axis=-1)\n\n    def dgsem_residual(u_all, K_el, N, D, gamma, Jk):\n        residual = np.zeros_like(u_all)\n        \n        for k in range(K_el):\n            u_k = u_all[k, :, :]\n            h_matrix = np.array([[chandrashekar_ec_flux(u_k[i], u_k[j], gamma) for j in range(N + 1)] for i in range(N + 1)])\n            vol_term = -2.0 / Jk * np.einsum('ij,ijk->ik', D, h_matrix)\n            residual[k, :, :] += vol_term\n\n        for k in range(K_el):\n            k_neighbor_L = (k - 1 + K_el) % K_el\n            u_inner_L = u_all[k, 0, :]\n            u_outer_L = u_all[k_neighbor_L, N, :]\n            f_star_L = chandrashekar_ec_flux(u_outer_L, u_inner_L, gamma)\n            f_inner_L = physical_flux(u_inner_L, gamma)\n            residual[k, 0, :] += (1.0 / Jk) * (-1.0) * (f_star_L - f_inner_L)\n\n            k_neighbor_R = (k + 1) % K_el\n            u_inner_R = u_all[k, N, :]\n            u_outer_R = u_all[k_neighbor_R, 0, :]\n            f_star_R = chandrashekar_ec_flux(u_inner_R, u_outer_R, gamma)\n            f_inner_R = physical_flux(u_inner_R, gamma)\n            residual[k, N, :] += (1.0 / Jk) * (1.0) * (f_star_R - f_inner_R)\n            \n        return residual\n\n    def compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma):\n        v_all = cons_to_entropy_vars(u_all, gamma)\n        integrand = np.einsum('kni,kni->kn', v_all, dudt)\n        elementwise_sum = np.sum(integrand * weights, axis=1)\n        total_rate = Jk * np.sum(elementwise_sum)\n        return total_rate\n\n    def run_test_case(params, test_seed):\n        gamma, N, K_el, case = params['gamma'], params['N'], params['K_el'], params['case']\n        \n        nodes_ref, weights = legendre_gauss_lobatto(N)\n        D = differentiation_matrix(N, nodes_ref)\n        \n        M = np.diag(weights)\n        B = np.diag([-1.] + [0.]*(N-1) + [1.]) if N > 0 else np.diag([-1.0])\n        sbp_check(N, D, M, B)\n        \n        dx = 1.0 / K_el\n        Jk = dx / 2.0\n        x_nodes = np.array([k * dx + dx * (nodes_ref + 1) / 2.0 for k in range(K_el)])\n\n        u_all = np.zeros((K_el, N + 1, 3))\n        \n        rho_vals, u_vals, p_vals = None, None, None\n\n        if case == 'constant':\n            rho_vals = np.full_like(x_nodes, 1.0)\n            u_vals = np.full_like(x_nodes, 0.3)\n            p_vals = np.full_like(x_nodes, 1.0)\n        elif case == 'smooth_pert':\n            rho_vals = 1.0 + 0.01 * np.cos(2 * np.pi * x_nodes)\n            u_vals = 0.5 + 0.05 * np.sin(2 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.02 * np.cos(2 * np.pi * x_nodes + 0.3)\n        elif case == 'random_pert':\n            rng = np.random.default_rng(test_seed)\n            rho_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            u_vals = 0.2 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            p_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n        elif case == 'bdy_res':\n            rho_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n            u_vals = 0.1 + 0.005 * np.cos(4 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n\n        # Ensure positivity of pressure (and density)\n        min_p = np.min(p_vals)\n        if min_p  0.5:\n            p_vals += (0.5 - min_p)\n        min_rho = np.min(rho_vals)\n        if min_rho = 0:\n            rho_vals += (-min_rho + 1e-6)\n\n        u_all = prim_to_cons(rho_vals, u_vals, p_vals, gamma)\n\n        dudt = dgsem_residual(u_all, K_el, N, D, gamma, Jk)\n        rate = compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma)\n        \n        return abs(rate)  TOLERANCE\n\n    # --- End of Helper Functions ---\n\n    results = []\n    # Use a fixed seed for the random test case to ensure reproducibility\n    random_test_seed = 42\n    for params in TEST_SUITE:\n        result = run_test_case(params, random_test_seed)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3384472"}]}