{"hands_on_practices": [{"introduction": "在构建手征有效场论的核力时，第一步是写下所有符合对称性要求的可能相互作用项。这些项的强度由所谓的低能常数（LECs）决定，而这些常数编码了被积分掉的高能自由度的信息。本练习将引导你使用朴素量纲分析（NDA）这一强大的工具来估算这些LECs的“自然”大小，这是理解手征展开中各项相对重要性的关键一步[@problem_id:3555484]。", "problem": "考虑包含显式π介子和非相对论性核子的手征有效场论（EFT）的双核子部分，并假设存在一个破缺标度$\\Lambda_{b}$，它表征了非微扰短程物理的出现。使用朴素量纲分析（NDA）来估计一个低能常数（LEC）的量级。该常数乘以一个宇称守恒、同位旋标量、含两个导数的四核子接触算符，此算符在双核子力的手征展开中对次领头阶（NLO）有贡献。您的推导必须基于以下基本前提：\n\n- 在四维时空中，拉格朗日量密度的质量量纲为$4$，非相对论性核子场的质量量纲为$3/2$，每个空间导数的质量量纲为$1$。\n- 在NDA中，短程强相互作用的圈图因子由一个因子$4\\pi$来体现。\n\n假设该算符包含两个核子双线性项和两个空间导数，其系数为低能常数$C_{2}$。推导$C_{2}$关于$\\Lambda_{b}$和基本常数的NDA标度关系式，然后使用$\\Lambda_{b} = 1.0~\\text{GeV}$计算其数值估计。将您的数值答案四舍五入至四位有效数字。以$\\text{GeV}^{-4}$为单位表示最终的LEC。在您的解答中，根据预期的自然性解释您的结果，并明确指出如果该LEC是自然的，哪个相关的无量纲组合应该为1的量级。", "solution": "该问题有效。这是一个理论核物理领域中定义明确的问题，依赖于手征有效场论（chiral EFT）和朴素量纲分析（NDA）等标准概念。所有必要信息均已提供，且前提在科学上是合理的。我们开始求解。\n\n目标是推导朴素量纲分析（NDA）对低能常数（LEC）$C_{2}$的估计。该常数$C_{2}$乘以手征有效场论中一个特定的双核子接触算符。\n\n首先，我们确定低能常数$C_{2}$的质量量纲。在自然单位制（$\\hbar=c=1$）中，作用量$S = \\int d^4x \\mathcal{L}$必须是无量纲的。这意味着拉格朗日量密度$\\mathcal{L}$的质量量纲为$[\\mathcal{L}] = 4$。我们所讨论的算符，记为$\\mathcal{O}_{2}$，是拉格朗日量密度中一项的一部分：$\\mathcal{L}_{2} = C_{2} \\mathcal{O}_{2}$。为了使这一项具有正确的量纲，必须满足$[C_{2}] + [\\mathcal{O}_{2}] = [\\mathcal{L}] = 4$。\n\n我们已知以下质量量纲：\n- 非相对论性核子场$N$：$[N] = 3/2$。\n- 空间导数$\\nabla$：$[\\nabla] = 1$。\n\n算符$\\mathcal{O}_{2}$是一个包含两个空间导数的四核子接触算符。无论导数如何分布在四个核子场上，该算符的总质量量纲是其各组成部分量纲之和：\n$$\n[\\mathcal{O}_{2}] = 4 \\times [N] + 2 \\times [\\nabla] = 4 \\times \\frac{3}{2} + 2 \\times 1 = 6 + 2 = 8\n$$\n现在我们可以确定低能常数$C_{2}$的质量量纲：\n$$\n[C_{2}] = 4 - [\\mathcal{O}_{2}] = 4 - 8 = -4\n$$\n这证实了$C_{2}$的单位是质量的负四次方，与要求以$\\text{GeV}^{-4}$为单位给出答案一致。\n\n接下来，我们应用朴素量纲分析（NDA）来估计$C_{2}$的量级。NDA的核心思想是，一旦从一个低能常数中将所有显式标度因子提出后，剩余的无量纲数应该为1的量级，即$\\mathcal{O}(1)$。对于被积分掉的短程物理，相关的物理标度是破缺标度$\\Lambda_{b}$。\n\n为了从$C_{2}$构造一个无量纲量，我们必须将其乘以$\\Lambda_{b}$的某个幂次，以抵消$C_{2}$的质量量纲。设这个无量纲的LEC为$\\tilde{C}_{2}$：\n$$\n\\tilde{C}_{2} = C_{2} \\Lambda_{b}^{-[C_{2}]} = C_{2} \\Lambda_{b}^{4}\n$$\n标准的NDA假设是$|\\tilde{C}_{2}| \\sim 1$。然而，问题为强相互作用提供了一个特定规则：“在NDA中，短程强相互作用的圈图因子由一个因子$4\\pi$来体现”。这修正了对无量纲系数自然大小的预期。对此因子的一个常见物理解释源于将接触算符视为积分掉重介子的结果。如果该算符是在树图级别通过交换一个具有强耦合$g$的重粒子而产生的，那么得到的LEC的标度行为为$C_2 \\sim g^2/\\Lambda_b^k$。对于强相互作用，耦合$g$通常被估计为满足$g^2/(4\\pi) \\sim 1$，这意味着$g^2 \\sim 4\\pi$。在我们的例子中，量纲分析表明LEC的标度行为为$C_2 \\sim g^2/\\Lambda_b^4$。这启发我们将无量纲系数的“自然”大小确定为$4\\pi$，而不是$1$。\n\n因此，我们采用修正后的NDA方案：\n$$\n|\\tilde{C}_{2}| = |C_{2} \\Lambda_{b}^{4}| \\approx 4\\pi\n$$\n由此，我们推导出$C_{2}$的标度关系式：\n$$\nC_{2} \\approx \\frac{4\\pi}{\\Lambda_{b}^{4}}\n$$\n这就是所求的NDA标度关系式。\n\n关于自然性的解释，无量纲量$\\tilde{C}_{2} = C_{2} \\Lambda_{b}^{4}$是关键。如果根据问题中强耦合规定所修正的NDA原则，这个LEC是“自然的”，那么$\\tilde{C}_{2}$的值应该约等于$4\\pi$。因此，组合$\\frac{C_{2} \\Lambda_{b}^{4}}{4\\pi}$是那个预期为1的量级的特定无量纲比率。\n\n最后，我们使用给定值$\\Lambda_{b} = 1.0~\\text{GeV}$计算$C_{2}$的数值估计：\n$$\nC_{2} \\approx \\frac{4\\pi}{(1.0~\\text{GeV})^{4}} = 4\\pi~\\text{GeV}^{-4}\n$$\n使用$\\pi \\approx 3.14159265...$的值，我们有：\n$$\nC_{2} \\approx 4 \\times 3.14159265...~\\text{GeV}^{-4} \\approx 12.5663706...~\\text{GeV}^{-4}\n$$\n按照要求将此结果四舍五入至四位有效数字，我们得到：\n$$\nC_{2} \\approx 12.57~\\text{GeV}^{-4}\n$$", "answer": "$$\n\\boxed{12.57}\n$$", "id": "3555484"}, {"introduction": "理论上，手征有效场论是一个在动量趋于无穷时发散的展开。为了在计算中实际使用它，我们必须引入一个“截断”或“调节子”函数来抑制高动量部分的贡献。然而，调节子的引入并非没有代价，一个不精心选择的调节子可能会破坏相互作用的基本对称性，如幺正性所要求的厄米性。本练习将通过一个数值实验，让你亲手检验不同调节子形式如何影响厄米性，并学习如何通过对称化方案来修正这个问题[@problem_id:3555456]。", "problem": "您的任务是设计并执行一个数值实验，以检验用于双核子相互作用的手征有效场论中的动量空间调节子是否保持厄米性（Hermiticity）和时间反演不变性。在此背景下，对于实相互作用核，厄米性要求对所有离壳动量 $p$ 和 $p'$ 满足条件 $V_{2N}(p,p') = V_{2N}(p',p)$。\n\n从以下基本基础出发：\n- 手征有效场论（EFT）双核子势由接触相互作用和介子交换贡献的总和构成。对于最低阶分析，仅考虑中心接触相互作用和单π介子交换的中心部分。\n- 动量空间中的裸（未调节的）双核子势取为对称函数\n$$\nV_{\\text{bare}}(p,p') = C_0 + C_2\\,(p^2 + p'^2) - \\frac{C_{\\pi}}{q^2 + m_\\pi^2},\n$$\n其中 $q = |p - p'|$，$C_0$ 和 $C_2$ 是代表接触项的低能常数，$C_{\\pi}$ 是中心单π介子交换（OPE）贡献的有效强度，$m_\\pi$ 是π介子质量。所有量均为实数。在没有调节子的情况下，这种构造与时间反演不变性和厄米性是一致的。\n\n引入调节子以抑制高动量分量。您将分析以下几种调节子选择：\n- 非定域对称高斯调节子：\n$$\nf_{\\Lambda}^{\\text{nl}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right],\n$$\n其中整数 $n \\geq 1$。\n- 半定域动量转移调节子：\n$$\nf_{\\Lambda}^{q}(p,p') = \\exp\\!\\left[-\\left(\\frac{q}{\\Lambda}\\right)^{2n}\\right],\\quad q=|p-p'|.\n$$\n- 非对称单边调节子：\n$$\nf_{\\Lambda}^{\\text{left}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right],\n$$\n它只抑制入射动量腿。\n- 非对称混合指数调节子：\n$$\nf_{\\Lambda}^{\\text{asym}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{4}\\right].\n$$\n\n将调节后的相互作用定义为\n$$\nV_{\\text{reg}}(p,p') = f_{\\Lambda}(p,p')\\,V_{\\text{bare}}(p,p').\n$$\n\n您必须实现并比较两种对称化方案，以修正由 $f_{\\Lambda}$ 引入的潜在的厄米性破缺：\n- 算术对称化：\n$$\nV_{\\text{sym,arith}}(p,p') = \\frac{1}{2}\\left[V_{\\text{reg}}(p,p') + V_{\\text{reg}}(p',p)\\right].\n$$\n- 几何平均（平方根）调节子对称化：\n$$\nf_{\\Lambda}^{\\text{geom}}(p,p') = \\sqrt{f_{\\Lambda}(p,p')\\,f_{\\Lambda}(p',p)},\\qquad V_{\\text{sym,geom}}(p,p') = f_{\\Lambda}^{\\text{geom}}(p,p')\\,V_{\\text{bare}}(p,p').\n$$\n\n执行以下任务：\n1. 使用固定常数 $C_0=-0.5$、$C_2=0.2$、$C_{\\pi}=0.8$ 和 $m_\\pi=0.7$ 构造 $V_{\\text{bare}}(p,p')$，所有动量的单位为反费米 $\\text{fm}^{-1}$。\n2. 对于上述每种调节子选择 $f_{\\Lambda}$，以及截断值 $\\Lambda \\in \\{1.0,\\,2.0,\\,3.0\\}$ $\\text{fm}^{-1}$ 和 $n=2$ 的情况，评估厄米性破缺度量\n$$\n\\Delta(p,p') = \\left|V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)\\right|\n$$\n在以下动量对测试集（单位为 $\\text{fm}^{-1}$）上进行：\n$$\n(p,p') \\in \\{(0.0,0.0),\\,(0.1,2.5),\\,(1.0,1.0),\\,(0.5,1.5),\\,(2.0,2.6)\\}.\n$$\n3. 对于每种调节子和截断值，计算对称化前的最大厄米性破缺，\n$$\n\\Delta_{\\max}^{\\text{pre}} = \\max_{(p,p')}\\Delta(p,p'),\n$$\n以及应用每种对称化方案后的最大厄米性破缺，\n$$\n\\Delta_{\\max}^{\\text{arith}} = \\max_{(p,p')}\\left|V_{\\text{sym,arith}}(p,p') - V_{\\text{sym,arith}}(p',p)\\right|,\n$$\n$$\n\\Delta_{\\max}^{\\text{geom}} = \\max_{(p,p')}\\left|V_{\\text{sym,geom}}(p,p') - V_{\\text{sym,geom}}(p',p)\\right|.\n$$\n\n您的程序必须按照此精确的调节子类型顺序计算，\n$$\n\\text{types} = [\\text{nl\\_sym},\\;\\text{left\\_only},\\;\\text{q\\_semi},\\;\\text{asym\\_exp}],\n$$\n对于每个 $\\Lambda \\in [1.0,\\,2.0,\\,3.0]$，计算三元浮点数值\n$$\n\\left[\\Delta_{\\max}^{\\text{pre}},\\;\\Delta_{\\max}^{\\text{arith}},\\;\\Delta_{\\max}^{\\text{geom}}\\right].\n$$\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述调节子类型和递增的 $\\Lambda$ 排序。对于每个调节子-截断值组合，按顺序附加三个数 $\\Delta_{\\max}^{\\text{pre}}$、$\\Delta_{\\max}^{\\text{arith}}$ 和 $\\Delta_{\\max}^{\\text{geom}}$。例如，输出必须如下所示\n$$\n[\\Delta_{\\max}^{\\text{pre}},\\Delta_{\\max}^{\\text{arith}},\\Delta_{\\max}^{\\text{geom}},\\ldots],\n$$\n总共有 $4 \\times 3 \\times 3 = 36$ 个浮点数条目。所有动量的单位均为 $\\text{fm}^{-1}$，输出的差值为无量纲浮点数。", "solution": "所述问题是有效的。它在核力的手征有效场论（EFT）标准框架内具有科学依据，提供了一个适定且客观的数值任务。唯一解所需的所有常数、函数和参数均已提供。因此，我们可以着手进行推导和计算实现。\n\n问题的核心是研究动量空间中双核子势$V_{2N}$的厄米性。对于如此处的实势核，厄米性的条件简化为在交换初始和末态动量下的对称性：$V_{2N}(p, p') = V_{2N}(p', p)$。此性质至关重要，因为它确保了哈密顿量是自伴的，从而产生实的能量本征值和幺正的时间演化。我们将分析EFT中常用的各种调节函数如何影响此性质。\n\n首先，我们定义裸势，它作为我们分析的基础。它由接触相互作用和单π介子交换（OPE）项组成。\n$$\nV_{\\text{bare}}(p,p') = C_0 + C_2\\,(p^2 + p'^2) - \\frac{C_{\\pi}}{q^2 + m_\\pi^2}\n$$\n这里，$p$和$p'$分别代表入射和出射动量的大小。参数$C_0$和$C_2$是S波（$l=0$）接触项的低能常数（LEC），最后一项代表OPE势的中心部分，其中$C_{\\pi}$是其有效强度，$m_{\\pi}$是π介子质量。动量转移定义为$q = |p - p'|$。\n\n我们必须首先验证这个裸势是厄米性的。我们通过交换$p$和$p'$来检查对称性：\n$$\nV_{\\text{bare}}(p',p) = C_0 + C_2\\,(p'^2 + p^2) - \\frac{C_{\\pi}}{(|p'-p|)^2 + m_\\pi^2}\n$$\n由于加法和乘法是可交换的，$(p'^2 + p^2) = (p^2 + p'^2)$。此外，绝对值函数具有性质$|p'-p| = |-(p-p')| = |p-p'|$。因此，$V_{\\text{bare}}(p',p)$的表达式与$V_{\\text{bare}}(p,p')$的表达式相同。裸势是内禀对称的，因此是厄米性的。\n\n接下来，我们引入一个调节函数$f_{\\Lambda}(p,p')$，以抑制EFT预期会失效的高动量贡献。调节后的势定义为调节子与裸势的乘积：\n$$\nV_{\\text{reg}}(p,p') = f_{\\Lambda}(p,p')\\,V_{\\text{bare}}(p,p')\n$$\n$V_{\\text{reg}}$的厄米性现在取决于调节函数$f_{\\Lambda}(p,p')$的对称性，因为$V_{\\text{bare}}$已经是对称的。如果$f_{\\Lambda}(p,p') = f_{\\Lambda}(p',p)$，那么$V_{\\text{reg}}$将是厄米性的。如果$f_{\\Lambda}(p,p') \\neq f_{\\Lambda}(p',p)$，厄米性就会被破坏。我们检查每个指定的调节子：\n\n1.  **非定域对称高斯调节子**，$f_{\\Lambda}^{\\text{nl}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right]$：交换$p$和$p'$会得到相同的表达式。这个调节子是对称的，并保持厄米性。\n2.  **半定域动量转移调节子**，$f_{\\Lambda}^{q}(p,p') = \\exp\\!\\left[-\\left(\\frac{q}{\\Lambda}\\right)^{2n}\\right]$：由于$q=|p-p'|$在交换$p \\leftrightarrow p'$下是对称的，因此这个调节子也是对称的，并保持厄米性。\n3.  **非对称单边调节子**，$f_{\\Lambda}^{\\text{left}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2n}\\right]$：这里，$f_{\\Lambda}^{\\text{left}}(p',p) = \\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2n}\\right]$，除非$p=p'$，否则它不等于$f_{\\Lambda}^{\\text{left}}(p,p')$。这个调节子明确地破坏了厄米性。\n4.  **非对称混合指数调节子**，$f_{\\Lambda}^{\\text{asym}}(p,p') = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{4}\\right]$：交换动量得到$f_{\\Lambda}^{\\text{asym}}(p',p) = \\exp\\!\\left[-\\left(\\frac{p'}{\\Lambda}\\right)^{2}\\right]\\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right]$，这与原始表达式不同。这个调节子也破坏了厄米性。\n\n对于非厄米调节子，势必须被显式地对称化。提出了两种方案：\n\n1.  **算术对称化**：\n    $$\n    V_{\\text{sym,arith}}(p,p') = \\frac{1}{2}\\left[V_{\\text{reg}}(p,p') + V_{\\text{reg}}(p',p)\\right]\n    $$\n    这种形式通过构造就是对称的：交换$p$和$p'$只是交换了和中的两项，结果保持不变。它恢复了厄米性。\n\n2.  **几何平均（平方根）对称化**：此方案作用于调节函数本身。\n    $$\n    f_{\\Lambda}^{\\text{geom}}(p,p') = \\sqrt{f_{\\Lambda}(p,p')\\,f_{\\Lambda}(p',p)}\n    $$\n    所得的势是$V_{\\text{sym,geom}}(p,p') = f_{\\Lambda}^{\\text{geom}}(p,p')\\,V_{\\text{bare}}(p,p')$。对称化的调节子$f_{\\Lambda}^{\\text{geom}}(p,p')$通过构造就是对称的，因为平方根内的乘积是可交换的。由于$V_{\\text{bare}}$是对称的，最终的势$V_{\\text{sym,geom}}$也保证是对称的。\n\n数值实验将量化厄米性破缺的程度，并验证这些对称化方案的有效性。对于每种调节子类型和截断值$\\Lambda$，我们在一个动量对$(p,p')$测试集上计算三个度量。这些度量是势与其转置之间的最大绝对差：\n-   $\\Delta_{\\max}^{\\text{pre}} = \\max_{(p,p')}\\left|V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)\\right|$\n-   $\\Delta_{\\max}^{\\text{arith}} = \\max_{(p,p')}\\left|V_{\\text{sym,arith}}(p,p') - V_{\\text{sym,arith}}(p',p)\\right|$\n-   $\\Delta_{\\max}^{\\text{geom}} = \\max_{(p,p')}\\left|V_{\\text{sym,geom}}(p,p') - V_{\\text{sym,geom}}(p',p)\\right|$\n\n理论上，对于对称调节子（$f_{\\Lambda}^{\\text{nl}}$和$f_{\\Lambda}^{q}$），$\\Delta_{\\max}^{\\text{pre}}$应该为零。对于非对称调节子（$f_{\\Lambda}^{\\text{left}}$和$f_{\\Lambda}^{\\text{asym}}$），它将不为零。对于所有调节子，$\\Delta_{\\max}^{\\text{arith}}$和$\\Delta_{\\max}^{\\text{geom}}$都应该为零，因为两种方案根据定义都恢复了对称性。在数值实现中，这些值将在机器浮点精度范围内为零。计算将使用提供的常数：$C_0=-0.5$、$C_2=0.2$、$C_{\\pi}=0.8$、$m_\\pi=0.7$，以及适用的指数修饰符$n=2$（得到$2n=4$的幂）。\n\n算法流程如下：\n1.  为$V_{\\text{bare}}(p,p')$和四种调节子类型分别实现函数。\n2.  按照[`nl_sym`, `left_only`, `q_semi`, `asym_exp`]的顺序遍历指定的调节子类型。\n3.  在此循环内，遍历截断值$\\Lambda \\in \\{1.0, 2.0, 3.0\\}$。\n4.  对于每个（调节子，$\\Lambda$）组合，初始化列表以存储每个动量对的破缺度量。\n5.  遍历测试动量对$(p,p')$。在这个最内层循环中：\n    a. 计算$V_{\\text{bare}}(p,p')$。注意$V_{\\text{bare}}(p',p)=V_{\\text{bare}}(p,p')$。\n    b. 计算调节后的势$V_{\\text{reg}}(p,p')=f_{\\Lambda}(p,p')V_{\\text{bare}}(p,p')$及其转置对应项$V_{\\text{reg}}(p',p)=f_{\\Lambda}(p',p)V_{\\text{bare}}(p',p)$。\n    c. 计算并存储对称化前的破缺$\\Delta(p,p') = |V_{\\text{reg}}(p,p') - V_{\\text{reg}}(p',p)|$。\n    d. 计算算术对称化的势$V_{\\text{sym,arith}}(p,p')$及其转置，并存储它们的绝对差（预期接近于零）。\n    e. 计算几何对称化的势$V_{\\text{sym,geom}}(p,p')$及其转置，并存储它们的绝对差（预期接近于零）。\n6.  遍历所有动量对后，从三个破缺列表中分别找出最大值：$\\Delta_{\\max}^{\\text{pre}}$、$\\Delta_{\\max}^{\\text{arith}}$和$\\Delta_{\\max}^{\\text{geom}}$。\n7.  将这三个最大值附加到主结果列表中。\n8.  最后，将主列表格式化为指定的、用方括号括起来的逗号分隔字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Hermiticity violation for different regulators in chiral EFT.\n    \"\"\"\n    # Define the constants from the problem statement.\n    C0 = -0.5\n    C2 = 0.2\n    Cpi = 0.8\n    mpi = 0.7\n    n = 2  # Regulator exponent parameter\n\n    # Define the test cases from the problem statement.\n    cutoffs = [1.0, 2.0, 3.0]\n    momenta_pairs = [\n        (0.0, 0.0),\n        (0.1, 2.5),\n        (1.0, 1.0),\n        (0.5, 1.5),\n        (2.0, 2.6)\n    ]\n\n    # --- Define Potential and Regulator Functions ---\n\n    def v_bare(p, p_prime):\n        \"\"\"Calculates the bare two-nucleon potential.\"\"\"\n        q = np.abs(p - p_prime)\n        contact_term = C0 + C2 * (p**2 + p_prime**2)\n        pion_exchange = -Cpi / (q**2 + mpi**2)\n        return contact_term + pion_exchange\n\n    def f_nl_sym(p, p_prime, Lambda):\n        \"\"\"Nonlocal symmetric Gaussian regulator.\"\"\"\n        return np.exp(-(p / Lambda)**(2 * n)) * np.exp(-(p_prime / Lambda)**(2 * n))\n\n    def f_q_semi(p, p_prime, Lambda):\n        \"\"\"Semi-local momentum-transfer regulator.\"\"\"\n        q = np.abs(p - p_prime)\n        return np.exp(-(q / Lambda)**(2 * n))\n\n    def f_left_only(p, p_prime, Lambda):\n        \"\"\"Asymmetric one-sided regulator.\"\"\"\n        return np.exp(-(p / Lambda)**(2 * n))\n\n    def f_asym_exp(p, p_prime, Lambda):\n        \"\"\"Asymmetric mixed-exponent regulator.\"\"\"\n        return np.exp(-(p / Lambda)**2) * np.exp(-(p_prime / Lambda)**4)\n\n    # Map names to functions according to the specified order.\n    regulator_funcs = {\n        \"nl_sym\": f_nl_sym,\n        \"left_only\": f_left_only,\n        \"q_semi\": f_q_semi,\n        \"asym_exp\": f_asym_exp\n    }\n    regulator_order = [\"nl_sym\", \"left_only\", \"q_semi\", \"asym_exp\"]\n\n    # --- Main Calculation Loop ---\n    \n    all_results = []\n    \n    for reg_name in regulator_order:\n        reg_func = regulator_funcs[reg_name]\n        \n        for Lambda in cutoffs:\n            \n            delta_pre_list = []\n            delta_arith_list = []\n            delta_geom_list = []\n\n            for p, p_prime in momenta_pairs:\n                # --- Pre-symmetrization ---\n                # Calculate V_bare(p, p') and V_bare(p', p), which are identical\n                v_bare_pp = v_bare(p, p_prime)\n                \n                # Calculate regulated potential V_reg(p, p')\n                f_pp = reg_func(p, p_prime, Lambda)\n                v_reg_pp = f_pp * v_bare_pp\n                \n                # Calculate transposed regulated potential V_reg(p', p)\n                f_p_p = reg_func(p_prime, p, Lambda)\n                v_reg_p_p = f_p_p * v_bare(p_prime, p) # v_bare(p',p) = v_bare_pp\n\n                # Calculate violation metric delta_pre\n                delta_pre_list.append(np.abs(v_reg_pp - v_reg_p_p))\n                \n                # --- Arithmetic Symmetrization ---\n                v_sym_arith_pp = 0.5 * (v_reg_pp + v_reg_p_p)\n                v_sym_arith_p_p = 0.5 * (v_reg_p_p + v_reg_pp)\n                delta_arith_list.append(np.abs(v_sym_arith_pp - v_sym_arith_p_p))\n                \n                # --- Geometric Symmetrization ---\n                # Symmetrize the regulator first\n                f_geom_pp = np.sqrt(f_pp * f_p_p)\n                \n                # Calculate potential with symmetrized regulator\n                v_sym_geom_pp = f_geom_pp * v_bare_pp\n                \n                # Transposed version is identical by construction\n                f_geom_p_p = np.sqrt(f_p_p * f_pp)\n                v_sym_geom_p_p = f_geom_p_p * v_bare(p_prime, p)\n                delta_geom_list.append(np.abs(v_sym_geom_pp - v_sym_geom_p_p))\n\n            # Find the maximum violation for the current (regulator, Lambda) pair\n            delta_max_pre = np.max(delta_pre_list)\n            delta_max_arith = np.max(delta_arith_list)\n            delta_max_geom = np.max(delta_geom_list)\n            \n            all_results.extend([delta_max_pre, delta_max_arith, delta_max_geom])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3555456"}, {"introduction": "核力具有复杂的自旋和同位旋结构。为了在核结构或散射计算中使用它，我们必须将总的相互作用势分解到具有确定总自旋（$S$）和总同位旋（$T$）的物理“分波”或“道”中。本练习将指导你构建必要的投影算符，从一个一般形式的核势中提取特定 $(S,T)$ 道的分量。此外，本练习还将揭示一个微妙但重要的问题：调节子的选择不仅会影响厄米性，还可能导致不同道之间的非物理性混合，我们将学习如何量化这种“泄漏”效应[@problem_id:3555487]。", "problem": "给定在手征有效场论（EFT）框架下的一个双核子势算符 $V_{2N}$，考虑一个分解为自旋和同位旋子空间的双粒子希尔伯特空间。令自旋子空间为两个自旋-$\\tfrac{1}{2}$ 空间的张量积（维度为 $4$），同位旋子空间为两个同位旋-$\\tfrac{1}{2}$ 空间的张量积（维度为 $4$）。总空间维度为 $16$，是自旋与同位旋空间的张量积。使用泡利矩阵 $\\sigma_x$、$\\sigma_y$、$\\sigma_z$ 表示自旋，$\\tau_x$、$\\tau_y$、$\\tau_z$ 表示同位旋，它们满足标准关系式 $\\sigma_i \\sigma_j = \\delta_{ij} I_2 + i \\epsilon_{ijk} \\sigma_k$ 和 $\\tau_i \\tau_j = \\delta_{ij} I_2 + i \\epsilon_{ijk} \\tau_k$，以及 $\\mathrm{Tr}(\\sigma_i) = 0$，$\\mathrm{Tr}(\\sigma_i \\sigma_j) = 2 \\delta_{ij}$（$\\tau_i$ 具有相同的关系式）。定义作用于自旋子空间的双粒子算符 $\\sigma_1^i = \\sigma_i \\otimes I_2$、$\\sigma_2^i = I_2 \\otimes \\sigma_i$，以及类似地作用于同位旋子空间的 $\\tau_1^i = \\tau_i \\otimes I_2$、$\\tau_2^i = I_2 \\otimes \\tau_i$。定义 $\\sigma_1 \\cdot \\sigma_2 = \\sigma_1^x \\sigma_2^x + \\sigma_1^y \\sigma_2^y + \\sigma_1^z \\sigma_2^z$ 和 $\\tau_1 \\cdot \\tau_2 = \\tau_1^x \\tau_2^x + \\tau_1^y \\tau_2^y + \\tau_1^z \\tau_2^z$。\n\n使用到总自旋 $S$ 和总同位旋 $T$ 通道的投影算符定义：\n$$\nP_{S=0} = \\frac{I_4 - \\sigma_1 \\cdot \\sigma_2}{4}, \\quad\nP_{S=1} = \\frac{3 I_4 + \\sigma_1 \\cdot \\sigma_2}{4},\n$$\n$$\nP_{T=0} = \\frac{I_4 - \\tau_1 \\cdot \\tau_2}{4}, \\quad\nP_{T=1} = \\frac{3 I_4 + \\tau_1 \\cdot \\tau_2}{4}.\n$$\n到组合的自旋-同位旋通道上的总投影算符为 $P_{ST} = P_S \\otimes P_T$，其中 $(S,T) \\in \\{(0,0),(0,1),(1,0),(1,1)\\}$。矩阵 $A$ 的弗罗贝尼乌斯范数定义为 $\\|A\\|_F = \\sqrt{\\mathrm{Tr}(A^\\dagger A)}$。\n\n假设一个通用的、动量依赖的手征EFT双核子势算符具有以下形式\n$$\nV_{2N}(p, p', \\Lambda) =\na_I(p,p',\\Lambda) \\, I_4 \\otimes I_4\n+ a_S(p,p',\\Lambda) \\, (\\sigma_1 \\cdot \\sigma_2) \\otimes I_4\n+ a_T(p,p',\\Lambda) \\, I_4 \\otimes (\\tau_1 \\cdot \\tau_2)\n+ a_{ST}(p,p',\\Lambda) \\, (\\sigma_1 \\cdot \\sigma_2) \\otimes (\\tau_1 \\cdot \\tau_2),\n$$\n其标量系数函数为\n$$\nf_0(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{p^2 + p'^2}{\\Lambda^2}\\right), \\quad\ng_1(p,p',\\Lambda) = \\frac{p^2 + p'^2}{\\Lambda^2},\n\\quad\ng_2(p,p',\\Lambda) = \\frac{p\\, p'}{\\Lambda^2},\n$$\n$$\na_I = c_I \\, f_0, \\quad\na_S = c_S \\, g_1 \\, f_0, \\quad\na_T = c_T \\, f_0, \\quad\na_{ST} = c_{ST} \\, g_2 \\, f_0,\n$$\n其中常数 $c_I$、$c_S$、$c_T$、$c_{ST}$ 与 $(p,p',\\Lambda)$ 无关。\n\n考虑一个正则化算符，当它与投影算符不对易时，可能会在 $(S,T)$ 通道之间引起混合：\n$$\nR(p,p',\\Lambda) = r_0(p,p',\\Lambda) \\left[\n\\left(I_4 + \\epsilon_s \\, h(p,p',\\Lambda) \\, (\\sigma_z \\otimes I_2)\\right) \\otimes\n\\left(I_4 + \\epsilon_t \\, h(p,p',\\Lambda) \\, (\\tau_z \\otimes I_2)\\right)\n\\right],\n$$\n其中\n$$\nr_0(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{p^2 + p'^2}{\\Lambda^2}\\right), \\quad\nh(p,p',\\Lambda) = \\exp\\!\\left(-\\frac{(p - p')^2}{\\Lambda^2}\\right),\n$$\n且 $\\epsilon_s$ 和 $\\epsilon_t$ 是小的无量纲正则化参数。正则化后的势为\n$$\nV_{\\mathrm{reg}} = R \\, V_{2N} \\, R.\n$$\n\n任务：\n1. 构建自旋和同位旋泡利算符以及复合算符 $\\sigma_1 \\cdot \\sigma_2$ 和 $\\tau_1 \\cdot \\tau_2$，作为作用于相应子空间的矩阵，然后构建完整 $16$ 维空间中的投影算符 $P_{ST}$。\n2. 通过计算所有 $(S,T)$ 和 $(S',T')$ 对的 $\\| P_{ST} P_{S'T'} - \\delta_{SS'} \\delta_{TT'} P_{ST} \\|_F$，数值上验证 $(S,T)$ 通道的正交性，并报告所有这些范数是否都低于容差 $\\delta = 10^{-12}$。\n3. 通过以下公式提取 $V_{2N}$ 在每个 $(S,T)$ 通道中的分量强度：\n$$\nv_{ST} = \\frac{\\mathrm{Tr}\\left(P_{ST} V_{2N}\\right)}{\\mathrm{Tr}\\left(P_{ST}\\right)},\n$$\n注意在 $16$ 维空间中 $\\mathrm{Tr}(P_{ST}) = (2S+1)(2T+1)$。\n4. 通过为每个 $(S,T)$ 通道计算泄漏度量，诊断正则化引起的污染：\n$$\nL_{ST} = \\frac{\\left\\| P_{ST} \\, V_{\\mathrm{reg}} \\, (I_{16} - P_{ST}) \\right\\|_F}{\\left\\| P_{ST} \\, V_{\\mathrm{reg}} \\right\\|_F},\n$$\n约定如果分母为零，则 $L_{ST}$ 定义为 $0$。报告每个测试用例中所有通道的最大泄漏值。\n\n动量和正则化标度使用兆电子伏特（MeV）作为单位。输出是无量纲的浮点数和布尔值；最终输出值中不需要物理单位。本问题不使用角度。百分比（若有）必须表示为小数，但算法将直接输出无量纲浮点数。\n\n使用的常数：\n- $c_I = 1.0$，$c_S = -0.5$，$c_T = 0.8$，$c_{ST} = -0.3$。\n\n测试套件：\n- 情况 A（基线，无混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (100, 150, 600, 0.0, 0.0)$，\n- 情况 B（自旋偏置正则化算符，轻度混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (100, 150, 600, 10^{-3}, 0.0)$，\n- 情况 C（同位旋偏置正则化算符，轻度混合）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (50, 50, 600, 0.0, 5 \\times 10^{-3})$，\n- 情况 D（强混合，低动量边界检查）：$(p, p', \\Lambda, \\epsilon_s, \\epsilon_t) = (0, 0, 600, 0.1, 0.1)$。\n\n您的程序应生成单行输出，按顺序包含每个测试用例的列表，格式为 $[\\mathrm{leak\\_max}, [L_{00}, L_{01}, L_{10}, L_{11}], \\mathrm{ortho}]$，其中 $\\mathrm{leak\\_max}$ 是四个泄漏值的最大值，$L_{ST}$ 是指定通道顺序的泄漏值，$\\mathrm{ortho}$ 是一个布尔值，说明所有投影算符正交性范数是否都低于 $\\delta$。将四个测试用例的列表聚合到一个列表中，并以方括号括起来的逗号分隔列表形式打印，例如：\n$[[\\mathrm{leak\\_max}_A,[L_{00}^A,L_{01}^A,L_{10}^A,L_{11}^A],\\mathrm{ortho}_A],[\\mathrm{leak\\_max}_B,[\\cdots],\\mathrm{ortho}_B],[\\mathrm{leak\\_max}_C,[\\cdots],\\mathrm{ortho}_C],[\\mathrm{leak\\_max}_D,[\\cdots],\\mathrm{ortho}_D]]$。", "solution": "用户提供的问题已经过验证，并被确定为计算核物理领域中一个定义明确、具有科学依据的问题。该问题是自洽的、客观的，并为得出唯一解提供了所有必要的参数和定义。解决该问题的步骤如下。\n\n### 1. 算符的矩阵表示\n基础步骤是在指定的希尔伯特空间中构建所有量子力学算符的矩阵表示。总希尔伯特空间是一个4维双核子自旋空间和一个4维双核子同位旋空间的张量积，形成一个16维空间。\n\n首先，将基本的 $2 \\times 2$ 单位矩阵 $I_2$ 和泡利矩阵 $\\sigma_i$（同样地，$\\tau_i$）定义为复数矩阵。\n$$\nI_2 = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \\quad \\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}\n$$\n作用于4维自旋或同位旋子空间的双粒子算符是使用克罗内克（张量）积（表示为 $\\otimes$）构建的。例如，粒子1和粒子2的自旋算符是 $\\sigma_1^i = \\sigma_i \\otimes I_2$ 和 $\\sigma_2^i = I_2 \\otimes \\sigma_i$。由此，计算点积算符 $\\sigma_1 \\cdot \\sigma_2 = \\sum_{i=x,y,z} (\\sigma_i \\otimes I_2)(I_2 \\otimes \\sigma_i)$ 和 $\\tau_1 \\cdot \\tau_2$。这些是 $4 \\times 4$ 矩阵。\n\n### 2. 投影算符的构建与验证\n到确定总自旋（$S$）和同位旋（$T$）的投影算符是根据点积算符构建的。对于自旋子空间：\n$$\nP_{S=0} = \\frac{I_4 - \\sigma_1 \\cdot \\sigma_2}{4}, \\quad P_{S=1} = \\frac{3 I_4 + \\sigma_1 \\cdot \\sigma_2}{4}\n$$\n类似的表达式定义了同位旋投影算符 $P_{T=0}$ 和 $P_{T=1}$。到四个组合的自旋-同位旋通道 $(S,T)$ 上的投影算符是由张量积 $P_{ST} = P_S \\otimes P_T$ 构成的 $16 \\times 16$ 矩阵。\n\n执行一次性关键验证，以确保这些构建的投影算符是正交归一的，这是它们必须满足的性质。这是通过对所有16对通道数值计算弗罗贝尼乌斯范数 $\\| P_{ST} P_{S'T'} - \\delta_{SS'}\\delta_{TT'} P_{ST} \\|_F$ 并确认其低于数值容差 $\\delta = 10^{-12}$ 来完成的。此检查的布尔结果将为所有测试用例报告。\n\n### 3. 势和正则化算符的构建\n对于每个由一组参数 $(p, p', \\Lambda, \\epsilon_s, \\epsilon_t)$ 定义的测试用例，构建势矩阵和正则化算符矩阵。\n\n未正则化的势 $V_{2N}$ 具有以下形式：\n$$\nV_{2N} = a_I I_{16} + a_S (\\sigma_1 \\cdot \\sigma_2 \\otimes I_4) + a_T (I_4 \\otimes \\tau_1 \\cdot \\tau_2) + a_{ST} (\\sigma_1 \\cdot \\sigma_2 \\otimes \\tau_1 \\cdot \\tau_2)\n$$\n其中算符部分是恒定的 $16 \\times 16$ 矩阵，而系数 $a_I, a_S, a_T, a_{ST}$ 是 $(p, p', \\Lambda)$ 的标量函数。为每个测试用例计算这些标量。\n\n正则化算符 $R$ 引入了通道混合。其形式为：\n$$\nR = r_0(p,p',\\Lambda) \\left[ \\left(I_4 + \\epsilon_s h(p,p',\\Lambda) \\sigma_1^z\\right) \\otimes \\left(I_4 + \\epsilon_t h(p,p',\\Lambda) \\tau_1^z\\right) \\right]\n$$\n这里，$\\sigma_1^z \\equiv \\sigma_z \\otimes I_2$ 和 $\\tau_1^z \\equiv \\tau_z \\otimes I_2$ 是 $4 \\times 4$ 算符。完整的算符 $R$ 是一个 $16 \\times 16$ 矩阵。为每个案例计算标量函数 $r_0$ 和 $h$。然后正则化后的势为 $V_{\\mathrm{reg}} = R V_{2N} R$。\n\n### 4. 泄漏计算\n核心任务是量化由正则化算符引起的通道混合。通道 $(S,T)$ 的泄漏 $L_{ST}$ 定义为正则化势相对于该通道投影算符的非对角部分与对角部分范数的比值：\n$$\nL_{ST} = \\frac{\\left\\| P_{ST} V_{\\mathrm{reg}} (I_{16} - P_{ST}) \\right\\|_F}{\\left\\| P_{ST} V_{\\mathrm{reg}} \\right\\|_F}\n$$\n分子表示势将态从通道 $(S,T)$ 散射到任何其他通道的部分。分母表示从通道 $(S,T)$ 开始的势的总作用。它们的比值是衡量混合相对重要性的一个指标。为每个测试用例的四个 $(S,T)$ 通道中的每一个都执行此计算。同时确定这四个泄漏值的最大值。如果分母范数为零，则 $L_{ST}=0$ 的约定通过数值容差检查来处理。\n\n最后，每个测试用例的结果，包括最大泄漏值、四个独立泄漏值的列表以及正交性检查的布尔值，被聚合并按要求格式化为单个字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem by constructing operators,\n    verifying projector orthogonality, and calculating regulator-induced channel leakage.\n    \"\"\"\n    # Define physical and numerical constants\n    c_I, c_S, c_T, c_ST = 1.0, -0.5, 0.8, -0.3\n    delta_ortho = 1e-12\n\n    # Define test suite parameters\n    test_cases = [\n        (100.0, 150.0, 600.0, 0.0, 0.0),        # Case A\n        (100.0, 150.0, 600.0, 1e-3, 0.0),       # Case B\n        (50.0, 50.0, 600.0, 0.0, 5e-3),        # Case C\n        (0.0, 0.0, 600.0, 0.1, 0.1),            # Case D\n    ]\n\n    # --- Task 1: Construct constant operators and projectors ---\n    I2 = np.eye(2, dtype=np.complex128)\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    pauli_matrices = [sigma_x, sigma_y, sigma_z]\n    \n    # 4x4 operators\n    I4 = np.kron(I2, I2)\n    sig1_ops = [np.kron(s, I2) for s in pauli_matrices]\n    sig2_ops = [np.kron(I2, s) for s in pauli_matrices]\n    tau1_ops = sig1_ops\n    tau2_ops = sig2_ops\n\n    sig1_dot_sig2 = sum(s1 @ s2 for s1, s2 in zip(sig1_ops, sig2_ops))\n    tau1_dot_tau2 = sum(t1 @ t2 for t1, t2 in zip(tau1_ops, tau2_ops))\n\n    # 4x4 projectors\n    P_S0 = (I4 - sig1_dot_sig2) / 4.0\n    P_S1 = (3 * I4 + sig1_dot_sig2) / 4.0\n    P_T0 = (I4 - tau1_dot_tau2) / 4.0\n    P_T1 = (3 * I4 + tau1_dot_tau2) / 4.0\n    \n    Ps = {0: P_S0, 1: P_S1}\n    Pt = {0: P_T0, 1: P_T1}\n\n    # 16x16 projectors\n    I16 = np.kron(I4, I4)\n    P_ST_map = {}\n    st_channels = [(S, T) for S in [0, 1] for T in [0, 1]]\n    for S, T in st_channels:\n        P_ST_map[(S, T)] = np.kron(Ps[S], Pt[T])\n\n    # --- Task 2: Verify projector orthogonality (one-time check) ---\n    ortho_check_passed = True\n    for S1, T1 in st_channels:\n        for S2, T2 in st_channels:\n            P1 = P_ST_map[(S1, T1)]\n            P2 = P_ST_map[(S2, T2)]\n            \n            is_same_channel = (S1 == S2) and (T1 == T2)\n            target = P1 if is_same_channel else np.zeros_like(P1)\n            \n            # Use explicit formula from problem statement\n            # P_ST P_S'T' - delta_SS' delta_TT' P_ST\n            P_ST = P_ST_map[(S1,T1)]\n            P_SprimeTprime = P_ST_map[(S2, T2)]\n            kronecker_delta = 1.0 if is_same_channel else 0.0\n            matrix_to_norm = P_ST @ P_SprimeTprime - kronecker_delta * P_ST\n\n            norm = np.linalg.norm(matrix_to_norm, 'fro')\n            \n            if norm > delta_ortho:\n                ortho_check_passed = False\n                break\n        if not ortho_check_passed:\n            break\n            \n    # Pre-build constant 16x16 operator matrices for V_2N and R\n    sig1_dot_sig2_16 = np.kron(sig1_dot_sig2, I4)\n    tau1_dot_tau2_16 = np.kron(I4, tau1_dot_tau2)\n    sig_tau_dot_16 = np.kron(sig1_dot_sig2, tau1_dot_tau2)\n    sig1z_4 = sig1_ops[2]\n    tau1z_4 = tau1_ops[2]\n\n    all_results = []\n    # --- Loop over test cases to perform Tasks 3  4 ---\n    for case in test_cases:\n        p, pp, Lambda, eps_s, eps_t = case\n        \n        # Calculate scalar coefficients for V_2N\n        p2_pp2 = p**2 + pp**2\n        Lambda2 = Lambda**2\n        \n        f0 = np.exp(-p2_pp2 / Lambda2)\n        g1 = p2_pp2 / Lambda2\n        g2 = (p * pp) / Lambda2\n        \n        aI = c_I * f0\n        aS = c_S * g1 * f0\n        aT = c_T * f0\n        aST = c_ST * g2 * f0\n        \n        # Construct V_2N matrix\n        V_2N = (aI * I16 +\n                aS * sig1_dot_sig2_16 +\n                aT * tau1_dot_tau2_16 +\n                aST * sig_tau_dot_16)\n        \n        # Calculate scalar coefficients for regulator R\n        r0 = np.exp(-p2_pp2 / Lambda2)\n        h = np.exp(-((p - pp)**2) / Lambda2)\n        \n        # Construct R matrix\n        R_s_part = I4 + eps_s * h * sig1z_4\n        R_t_part = I4 + eps_t * h * tau1z_4\n        R_bracket = np.kron(R_s_part, R_t_part)\n        R = r0 * R_bracket\n        \n        # Construct regulated potential V_reg\n        V_reg = R @ V_2N @ R\n        \n        # --- Task 4: Calculate leakages ---\n        leakages = {}\n        for S, T in st_channels:\n            PST = P_ST_map[(S, T)]\n            \n            off_diagonal_part = PST @ V_reg @ (I16 - PST)\n            numer_norm = np.linalg.norm(off_diagonal_part, 'fro')\n            \n            diagonal_part = PST @ V_reg\n            denom_norm = np.linalg.norm(diagonal_part, 'fro')\n            \n            if denom_norm  1e-15:  # Handle division by zero\n                leakages[(S, T)] = 0.0\n            else:\n                leakages[(S, T)] = numer_norm / denom_norm\n        \n        # Order results as specified: (0,0), (0,1), (1,0), (1,1)\n        leakages_list = [leakages[(0,0)], leakages[(0,1)], leakages[(1,0)], leakages[(1,1)]]\n        max_leakage = max(leakages_list) if leakages_list else 0.0\n        \n        all_results.append([max_leakage, leakages_list, ortho_check_passed])\n\n    # Format the final output string exactly as required (no spaces)\n    output_parts = []\n    for res in all_results:\n        leak_max, l_list, ortho = res\n        l_list_str = '[' + ','.join(f'{x:.17g}' for x in l_list) + ']'\n        ortho_str = 'True' if ortho else 'False'\n        res_str = f'[{f\"{leak_max:.17g}\"},{l_list_str},{ortho_str}]'\n        output_parts.append(res_str)\n        \n    final_output = '[' + ','.join(output_parts) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3555487"}]}