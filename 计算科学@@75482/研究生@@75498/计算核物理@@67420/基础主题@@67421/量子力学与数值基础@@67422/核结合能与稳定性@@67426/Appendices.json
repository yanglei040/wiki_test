{"hands_on_practices": [{"introduction": "这项练习提供了计算核物理的一项基础实践：从实验数据出发构建物理模型。你将实现一个完整的流程来拟合半经验质量公式的系数，从而学习如何通过线性回归来量化诸如体积能、表面能和库仑能等宏观核性质。这项实践将理论上的液滴模型与可触及的原子质量测量世界直接联系起来。[@problem_id:3573765]", "problem": "本题要求您为高等研究生水平设计并实现一个完整的数值计算流程，用以从原子质量数据中估算核结合能模型的系数。该过程需基于物理原理进行推导，并采用可复现的线性回归方法。待定系数包括体积项系数 $a_v$、表面项系数 $a_s$、库仑项系数 $a_c$、不对称项系数 $a_a$ 以及在选定对能方案下的对能振幅 $a_p$。推导必须从适用于液滴模型的基本原理和标度律出发，并且必须明确地构建一个线性模型，其参数通过普通最小二乘法进行拟合。\n\n您必须使用的基本依据包括：\n- 质能等效关系 $E = m c^2$。\n- 对于一个质子数为 $Z$、中子数为 $N$ 的原子核，其核结合能 $B$ 的定义为：$B = Z m_p c^2 + N m_n c^2 - M_{\\text{nuc}} c^2$，其中 $m_p$ 和 $m_n$ 分别是自由质子和中子的质量，$M_{\\text{nuc}}$ 是原子核的质量。\n- 从原子质量 $M_{\\text{atom}}$（包含 $Z$ 个束缚电子的中性原子）到原子核质量 $M_{\\text{nuc}}$ 的转换，通过减去 $Z$ 个电子的静止质量并加上总电子结合能 $E_e(Z)$ 来实现：$M_{\\text{nuc}} = M_{\\text{atom}} - Z m_e + E_e(Z)/c^2$，其中 $m_e$ 是电子质量。请对中性原子使用一个一致且平滑的电子结合能修正模型 $E_e(Z)$，其大小随 $Z$ 的变化应具有合理的标度关系；采用 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha$ 的值在下文指定。\n\n您必须根据有物理动机的标度律，构建一个关于 $B$ 的线性回归模型。特征应从以下考虑因素中导出，而非使用题目陈述中提供的简化公式：\n- 一个与 $A = Z + N$ 成比例的类体积项贡献。\n- 一个与近似不可压缩液滴的表面积成比例的类表面项贡献，因此与 $A$ 的某个幂成正比。\n- 一个有限尺寸电荷分布的库仑自能贡献，其依赖于 $Z$ 和原子核半径的标度关系。\n- 一个与中子-质子数不平衡及费米统计相关的非对称项贡献。\n- 一个依赖于 $Z$ 和 $N$ 的奇偶性、具有选定的关于 $A$ 的大小标度函数以及针对偶偶核、奇奇核和奇A核的符号约定的对能项贡献。\n\n您必须实现以下对能方案：定义带符号的对能项特征 $g(A,Z,N) = s(A,Z,N) A^{-1/2}$，其中对于偶偶核（$Z$ 和 $N$ 均为偶数），$s(A,Z,N) = +1$；对于奇奇核（$Z$ 和 $N$ 均为奇数），$s(A,Z,N) = -1$；对于奇A核（$A$ 为奇数），$s(A,Z,N) = 0$。未知系数 $a_p$ 乘以 $g(A,Z,N)$。\n\n单位和常数：\n- 所有能量均以兆电子伏特 (MeV) 表示。\n- 使用原子质量单位到能量的转换关系，$u c^2$ 等于每个原子质量单位 $u$ 对应 $931.49410242$ MeV。\n- 使用 $m_p = 1.007276466621$ $u$，$m_n = 1.00866491588$ $u$，$m_e = 0.000548579909065$ $u$。\n- 使用电子结合能修正模型 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha = 14.4381$ 电子伏特。使用 $1$ 电子伏特 $= 10^{-6}$ MeV 将 $E_e(Z)$ 转换为 MeV。因此，$E_e(Z) = (1.44381 \\times 10^{-5}) Z^2$ MeV。\n\n数据：\n使用以下中性原子质量 $M_{\\text{atom}}$ 的数据集，单位为原子质量单位 $u$。数据针对具有 $(Z,N,A)$（其中 $A = Z + N$）的同位素，并给出了相应的原子质量。以下每个数字都是以 $u$ 为单位的十进制数。\n- 氘：$(Z,N,A) = (1,1,2)$，$M_{\\text{atom}} = 2.01410177812$。\n- 氦-3：$(Z,N,A) = (2,1,3)$，$M_{\\text{atom}} = 3.01602932265$。\n- 氦-4：$(Z,N,A) = (2,2,4)$，$M_{\\text{atom}} = 4.00260325413$。\n- 碳-12：$(Z,N,A) = (6,6,12)$，$M_{\\text{atom}} = 12.0$。\n- 氮-14：$(Z,N,A) = (7,7,14)$，$M_{\\text{atom}} = 14.00307400443$。\n- 氧-16：$(Z,N,A) = (8,8,16)$，$M_{\\text{atom}} = 15.99491461957$。\n- 钙-40：$(Z,N,A) = (20,20,40)$，$M_{\\text{atom}} = 39.96259098$。\n- 钙-48：$(Z,N,A) = (20,28,48)$，$M_{\\text{atom}} = 47.95252276$。\n- 铁-56：$(Z,N,A) = (26,30,56)$，$M_{\\text{atom}} = 55.93493633$。\n- 镍-58：$(Z,N,A) = (28,30,58)$，$M_{\\text{atom}} = 57.9353429$。\n- 锆-90：$(Z,N,A) = (40,50,90)$，$M_{\\text{atom}} = 89.9047037$。\n- 铅-208：$(Z,N,A) = (82,126,208)$，$M_{\\text{atom}} = 207.9766521$。\n\n任务：\n1. 从所述的基本依据出发，推导出一个关于 $B$ 的线性模型。该模型用一个特征向量表示，该向量能够生成一个适用于普通最小二乘法的设计矩阵，其未知参数 $(a_v,a_s,a_c,a_a,a_p)$ 均以 MeV 为单位表示。\n2. 使用电子结合能修正 $E_e(Z)$ 将每个 $M_{\\text{atom}}$ 转换为 $M_{\\text{nuc}}$，并计算所有同位素的实验结合能 $B$（单位为 MeV）。\n3. 实现普通最小二乘法来拟合 $(a_v,a_s,a_c,a_a,a_p)$。\n\n测试套件：\n在三种配置下运行拟合，以测试您的计算流程：\n- 情况1：使用上面列出的完整数据集，并包含电子结合能修正 $E_e(Z)$。\n- 情况2：仅使用数据集中的偶偶核子集（即 $Z$ 和 $N$ 均为偶数的核素），并包含电子结合能修正 $E_e(Z)$。\n- 情况3：使用完整数据集，但省略电子结合能修正（等效于设置 $E_e(Z) = 0$），但在将 $M_{\\text{atom}}$ 转换为 $M_{\\text{nuc}}$ 时仍减去 $Z m_e$。\n\n对于每种情况，返回拟合出的系数 $(a_v,a_s,a_c,a_a,a_p)$（以 MeV 为单位的浮点数值）以及残差的均方根误差 (RMSE)（以 MeV 为单位）。RMSE 的计算公式为 $\\sqrt{\\frac{1}{n}\\sum_i (B_i - \\hat{B}_i)^2}$，其中 $n$ 是该情况下的同位素数量，$B_i$ 是实验结合能，$\\hat{B}_i$ 是模型预测值。RMSE 必须以 MeV 为单位表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔的嵌套列表。每个内部列表对应一种情况（按情况1、情况2、情况3的顺序）。每个内部列表必须包含六个以 MeV 为单位、小数点后保留六位的浮点数结果，顺序为 $[a_v,a_s,a_c,a_a,a_p,\\text{RMSE}]$。例如，打印的结构必须是如下形式\n$[[a_v^{(1)},a_s^{(1)},a_c^{(1)},a_a^{(1)},a_p^{(1)},\\text{RMSE}^{(1)}],[a_v^{(2)},a_s^{(2)},a_c^{(2)},a_a^{(2)},a_p^{(2)},\\text{RMSE}^{(2)}],[a_v^{(3)},a_s^{(3)},a_c^{(3)},a_a^{(3)},a_p^{(3)},\\text{RMSE}^{(3)}]]$。", "solution": "该问题要求设计并实现一个数值计算流程，用以从给定的原子质量数据集中确定半经验质量公式（SEMF）的系数。该过程包括三个主要阶段：基于液滴模型对核结合能进行线性模型的理论推导，处理原始原子质量数据以计算实验结合能，以及应用普通最小二乘法（OLS）回归来拟合模型系数。\n\n首先，我们为线性模型建立理论基础。一个质量数为 $A$、质子数为 $Z$、中子数为 $N = A - Z$ 的原子核，其结合能 $B$ 定义为将其分解为其自由的组成核子所需的能量。根据质能等效原理 $E=mc^2$，该能量由下式给出：\n$$B = Z m_p c^2 + N m_n c^2 - M_{\\text{nuc}} c^2$$\n其中 $m_p$ 是质子静止质量，$m_n$ 是中子静止质量，$M_{\\text{nuc}}$ 是原子核的质量。所提供的数据是包含 $Z$ 个电子的中性原子质量 $M_{\\text{atom}}$。原子核质量 $M_{\\text{nuc}}$ 是通过减去这 $Z$ 个电子的质量并加回它们的总结合能 $E_e(Z)$ 得到的：\n$$M_{\\text{nuc}} = M_{\\text{atom}} - Z m_e + \\frac{E_e(Z)}{c^2}$$\n此处，$m_e$ 是电子静止质量。题目指定了总电子结合能的模型为 $E_e(Z) = \\alpha Z^2$，其中 $\\alpha = 1.44381 \\times 10^{-5}$ MeV。综合这些公式，实验结合能（单位为 MeV）的计算方式如下：\n$$B_{exp} = \\left( Z m_p + N m_n - \\left( M_{\\text{atom}} - Z m_e + \\frac{E_e(Z)}{u c^2} \\right) \\right) u c^2$$\n其中所有质量都以原子质量单位（$u$）表示，而 $u c^2 = 931.49410242$ MeV 是一个原子质量单位的能量当量。\n\n由原子核的液滴模型推导出的半经验质量公式，将结合能 $B$ 表示为五个项的总和，其系数 $(a_v, a_s, a_c, a_a, a_p)$ 是我们旨在确定的：\n$$B(A, Z) = a_v f_v - a_s f_s - a_c f_c - a_a f_a + a_p f_p$$\n这些特征（$f_v, f_s, f_c, f_a, f_p$）的函数形式由物理论证推导得出：\n1.  体积项 ($f_v$)：强核力是短程且饱和的。因此，每个核子主要与其最近邻的核子相互作用。总结合能因此近似正比于核子总数 $A$。该项代表了核“液体”的体结合能。\n    $$f_v(A, Z) = A$$\n2.  表面项 ($f_s$)：位于原子核表面的核子比内部的核子邻居少，这降低了总结合能。该效应与原子核的表面积成正比。假设原子核为密度恒定的球体，则体积 $V \\propto A$。由于 $V \\propto R^3$，半径 $R \\propto A^{1/3}$。表面积与 $R^2$ 成正比。\n    $$f_s(A, Z) = A^{2/3}$$\n3.  库仑项 ($f_c$)：质子间的静电排斥作用也会降低结合能。一个半径为 $R$ 的球体内分布的 $Z$ 个质子的势能，与质子对的数量 $Z(Z-1)/2$ 成正比，与半径 $R$ 成反比。对于较小的 $Z$，使用 $Z(Z-1)$ 比近似为 $Z^2$ 更精确。\n    $$f_c(A, Z) = \\frac{Z(Z-1)}{A^{1/3}}$$\n4.  不对称项 ($f_a$)：泡利不相容原理倾向于形成 $N=Z$ 的对称原子核。对于固定的质量数 $A$，偏离这种对称性（即存在中子盈余 $N-Z \\neq 0$）需要将核子置于更高的能级，这会消耗能量并降低结合能。这种能量惩罚与中子-质子不平衡度的平方成正比，与总体积成反比。\n    $$f_a(A, Z) = \\frac{(N-Z)^2}{A} = \\frac{(A-2Z)^2}{A}$$\n5.  对能项 ($f_p$)：核子表现出形成自旋相反的相同粒子对的趋势，这会增加结合能。这导致了一个修正项，其取决于 $Z$ 和 $N$ 的奇偶性。题目指定了该特征的函数形式：\n    $$f_p(A, Z, N) = s(A,Z,N) A^{-1/2}$$\n    其中对于偶偶核，$s(A,Z,N) = +1$；对于奇奇核，$s(A,Z,N) = -1$；对于奇A核，$s(A,Z,N) = 0$。\n\n该模型在系数 $(a_v, a_s, a_c, a_a, a_p)$ 上是线性的。对于一组 $n$ 个原子核，我们可以将方程组写成矩阵形式 $\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n-   $\\boldsymbol{Y}$ 是实验结合能 $B_{exp,i}$ 组成的 $n \\times 1$ 列向量。\n-   $\\boldsymbol{\\beta}$ 是待拟合的未知系数组成的 $5 \\times 1$ 列向量：$[a_v, a_s, a_c, a_a, a_p]^T$。\n-   $\\mathbf{X}$ 是 $n \\times 5$ 的设计矩阵，其中第 $i$ 行对应第 $i$ 个原子核，由吸收了常规符号的模型项构成：\n    $$\\mathbf{X}_i = \\left[ A_i, \\quad -A_i^{2/3}, \\quad -\\frac{Z_i(Z_i-1)}{A_i^{1/3}}, \\quad -\\frac{(A_i-2Z_i)^2}{A_i}, \\quad s(A_i,Z_i,N_i)A_i^{-1/2} \\right]$$\n系数的普通最小二乘法（OLS）估计值 $\\hat{\\boldsymbol{\\beta}}$ 是使残差平方和最小化的值，由正规方程的解给出：\n$$\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\boldsymbol{Y}$$\n该解将使用一个稳定的线性最小二乘求解器进行数值计算。\n\n对于三种测试情况中的每一种，计算流程如下：\n1.  选择合适的同位素数据子集。\n2.  对每个同位素，计算实验结合能 $B_{exp}$ 以构成向量 $\\boldsymbol{Y}$。这涉及应用电子质量修正，并在指定情况下应用电子结合能修正。\n3.  对每个同位素，计算五个特征值以构成设计矩阵 $\\mathbf{X}$。\n4.  使用 OLS 求解线性系统 $\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta}$ 以得到 $\\boldsymbol{\\beta}$。\n5.  使用拟合出的系数 $\\hat{\\boldsymbol{\\beta}}$，计算预测的结合能 $\\hat{\\boldsymbol{Y}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$。\n6.  计算拟合的均方根误差 (RMSE)，定义为 $\\text{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} (Y_i - \\hat{Y}_i)^2}$。\n最终得到的系数 $(a_v,a_s,a_c,a_a,a_p)$ 和 RMSE，均以 MeV 为单位，构成了每种情况的最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants are defined at the module level for clarity and reuse.\nUC2_MEV = 931.49410242\nM_P_U = 1.007276466621\nM_N_U = 1.00866491588\nM_E_U = 0.000548579909065\nALPHA_MEV = 1.44381e-5\n\ndef get_pairing_s(Z, N):\n    \"\"\"\n    Determines the sign coefficient for the pairing term based on proton and neutron numbers.\n    s = +1 for even-even, -1 for odd-odd, 0 for odd-A nuclei.\n    \"\"\"\n    if Z % 2 == 0 and N % 2 == 0:\n        return 1.0\n    elif Z % 2 != 0 and N % 2 != 0:\n        return -1.0\n    else:  # Odd-A nuclei\n        return 0.0\n\ndef run_semf_fit(dataset, use_electron_binding):\n    \"\"\"\n    Constructs the design matrix and target vector, then performs OLS regression.\n\n    Args:\n        dataset (list): A list of tuples, where each tuple contains\n                        (Z, N, A, M_atom_u) for a nucleus.\n        use_electron_binding (bool): Flag to include electron binding\n                                     energy correction.\n\n    Returns:\n        list: A list containing the fitted coefficients [a_v, a_s, a_c, a_a, a_p]\n              and the RMSE of the fit, all in MeV.\n    \"\"\"\n    num_isotopes = len(dataset)\n    # Design matrix X (n_samples, n_features) and target vector Y (n_samples,)\n    X = np.zeros((num_isotopes, 5))\n    Y = np.zeros(num_isotopes)\n\n    for i, datum in enumerate(dataset):\n        Z_f, N_f, A_f, M_atom_u = datum\n        Z, N, A = int(Z_f), int(N_f), int(A_f)\n\n        # 1. Calculate experimental binding energy (target vector Y)\n        E_e_mev = ALPHA_MEV * Z**2 if use_electron_binding else 0.0\n        M_nuc_u = M_atom_u - Z * M_E_U + E_e_mev / UC2_MEV\n        B_mev = (Z * M_P_U + N * M_N_U - M_nuc_u) * UC2_MEV\n        Y[i] = B_mev\n        \n        # 2. Construct features for the design matrix X\n        # The model is B = a_v*f_v + a_s*(-f_s) + a_c*(-f_c) + a_a*(-f_a) + a_p*f_p\n        # where f_v=A, f_s=A^(2/3), etc.\n        # We absorb the signs into the design matrix.\n        f_v = float(A)\n        f_s = -A**(2/3)\n        # Use Z*(Z-1) for Coulomb term, more accurate for small Z\n        f_c = -Z * (Z - 1) / A**(1/3) if A > 0 else 0.0\n        # Asymmetry term (N-Z)^2/A = (A-2Z)^2/A\n        f_a = -(A - 2*Z)**2 / A if A > 0 else 0.0\n        \n        s = get_pairing_s(Z, N)\n        f_p = s * A**(-1/2) if A > 0 else 0.0\n        \n        X[i, :] = [f_v, f_s, f_c, f_a, f_p]\n\n    # 3. Perform Ordinary Least Squares (OLS) regression\n    # np.linalg.lstsq solves Y = X*beta for beta\n    coeffs, residuals, _, _ = np.linalg.lstsq(X, Y, rcond=None)\n    \n    # 4. Calculate Root-Mean-Square Error (RMSE)\n    if residuals.size == 0:\n        # If n_samples = n_features, lstsq may return empty residuals.\n        # In this case, residuals must be computed manually.\n        Y_pred = X @ coeffs\n        res_sum_sq = np.sum((Y - Y_pred)**2)\n        rmse = np.sqrt(res_sum_sq / num_isotopes) if num_isotopes > 0 else 0.0\n    else:\n        # residuals[0] contains the sum of squared residuals\n        rmse = np.sqrt(residuals[0] / num_isotopes) if num_isotopes > 0 else 0.0\n        \n    return list(coeffs) + [rmse]\n\n\ndef solve():\n    \"\"\"\n    Main orchestrator for the problem. Defines data and test cases,\n    runs the analysis, and prints the final formatted output.\n    \"\"\"\n    # Dataset: (Z, N, A, M_atom_u)\n    # Z, N, A are integers; M_atom_u is float.\n    DATA = [\n        (1, 1, 2, 2.01410177812),   # Deuterium\n        (2, 1, 3, 3.01602932265),   # Helium-3\n        (2, 2, 4, 4.00260325413),   # Helium-4\n        (6, 6, 12, 12.0),           # Carbon-12\n        (7, 7, 14, 14.00307400443), # Nitrogen-14\n        (8, 8, 16, 15.99491461957), # Oxygen-16\n        (20, 20, 40, 39.96259098),  # Calcium-40\n        (20, 28, 48, 47.95252276),  # Calcium-48\n        (26, 30, 56, 55.93493633),  # Iron-56\n        (28, 30, 58, 57.9353429),   # Nickel-58\n        (40, 50, 90, 89.9047037),   # Zirconium-90\n        (82, 126, 208, 207.9766521) # Lead-208\n    ]\n\n    all_results = []\n\n    # Case 1: Full dataset, with electron binding energy correction\n    results_1 = run_semf_fit(DATA, use_electron_binding=True)\n    all_results.append(results_1)\n    \n    # Case 2: Even-even subset, with electron binding energy correction\n    even_even_data = [d for d in DATA if d[0] % 2 == 0 and d[1] % 2 == 0]\n    results_2 = run_semf_fit(even_even_data, use_electron_binding=True)\n    all_results.append(results_2)\n    \n    # Case 3: Full dataset, without electron binding energy correction\n    results_3 = run_semf_fit(DATA, use_electron_binding=False)\n    all_results.append(results_3)\n    \n    # Format the final output string exactly as required.\n    output_parts = []\n    for res_list in all_results:\n        formatted_list = [f\"{val:.6f}\" for val in res_list]\n        output_parts.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output_str = f\"[{','.join(output_parts)}]\"\n    print(final_output_str)\n\nsolve()\n\n```", "id": "3573765"}, {"introduction": "单粒子能是平均场理论的核心概念，但它们与可观测的分离能有何关联？本数值实验将让你在一个简化的核密度泛函框架内，探索类 Koopmans 近似的有效性与局限性。通过比较“冻结场”近似值与完全自洽的计算结果，你将对平均场重排效应和关联效应有更深刻的理解，而这些效应对精确的核结构模型至关重要。[@problem_id:3573744]", "problem": "要求你设计并实现一个数值实验，使用简化的密度泛函理论 (DFT) 类似物，以检验一个用于核子分离能的 Koopmans 型估计量，并与完全自洽的有限差分结果进行对比。你的任务是从基本原理和经过广泛检验的结果出发，构建这个问题，然后实现一个程序，为一小组测试原子核计算并比较中子和质子的分离能。\n\n从以下基本依据开始：\n\n- 零温度下的非相对论性简并费米气体：对于一种均匀的费米子，其数密度为 $\\rho_q$，费米动量为 $k_{F,q} = \\left(3\\pi^2 \\rho_q\\right)^{1/3}$，费米动能为 $T_{F,q} = \\frac{\\hbar^2 k_{F,q}^2}{2m}$，每个粒子的动能等于 $\\frac{3}{5} T_{F,q}$。\n\n- 带双重计数修正的 Hartree 平均场：在具有单体平均场 $U_q$ 的 Hartree 描述中，当在自洽条件下计算时，总势能为 $\\frac{1}{2} \\sum_q N_q U_q$。\n\n- 冻结平均场中的 Koopmans 型移出能估计量：在独立粒子图像中，当忽略平均场的重排和导数不连续性时，移出最后被占据的 $q$ 类粒子的能量可以近似为费米面上单粒子能量的负值，即 $-\\varepsilon_{F,q}$。\n\n计算中要使用的模型假设：\n\n- 考虑一个处于饱和密度的均匀有限原子核，包含两种费米子 $q \\in \\{n,p\\}$（中子 $n$ 和质子 $p$）。设总核子数为 $A = N + Z$，组分分数为 $x_n = N/A$ 和 $x_p = Z/A$。假设饱和密度为常数 $\\rho_0 = 0.16\\,\\text{fm}^{-3}$，因此各组分密度为 $\\rho_n = x_n \\rho_0$ 和 $\\rho_p = x_p \\rho_0$。\n\n- 使用非相对论性核子，其中 $\\hbar^2/(2m) = 20.735\\,\\text{MeV}\\,\\text{fm}^2$。则费米动能为 $T_{F,q} = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 \\rho_q\\right)^{2/3}$。\n\n- 采用一种依赖于粒子种类的局域平均场势，形式如下\n  $$\n  U_n(N,Z) = u_0 + u_{\\text{sym}} \\,\\delta, \\quad U_p(N,Z) = u_0 - u_{\\text{sym}} \\,\\delta + u_c \\frac{Z}{A^{1/3}},\n  $$\n  其中 $\\delta = \\frac{N-Z}{A}$ 是不对称参数。使用参数 $u_0 = -60\\,\\text{MeV}$，$u_{\\text{sym}} = 50\\,\\text{MeV}$ 和 $u_c = 1.44\\,\\text{MeV}$。\n\n- 包含一个示意性的对关联能\n  $$\n  E_{\\text{pair}}(N,Z) = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right),\n  $$\n  其中 $p_0 = 12\\,\\text{MeV}$，如果 $N$ 是偶数，则 $\\delta_{N \\text{ even}}$ 等于 $1$，否则为 $0$（$\\delta_{Z \\text{ even}}$ 同理）。\n\n基于以上依据，推导出以下量的算法表达式：\n\n1) 在此均匀 Thomas-Fermi Hartree 模型中，对于给定的 $(N,Z)$ 的总基态能量，\n   $$\n   E(N,Z) = \\sum_{q \\in \\{n,p\\}} \\frac{3}{5} N_q T_{F,q} + \\frac{1}{2}\\left(N U_n + Z U_p\\right) + E_{\\text{pair}}(N,Z),\n   $$\n   以及相应的结合能 $B(N,Z) = -E(N,Z)$，单位为 $\\text{MeV}$。\n\n2) 完全自洽的单核子分离能，通过结合能的离散差分计算，\n   $$\n   S_n(N,Z) = B(N,Z) - B(N-1,Z), \\quad S_p(N,Z) = B(N,Z) - B(N,Z-1),\n   $$\n   单位为 $\\text{MeV}$，其中 $N \\ge 1$ 且 $Z \\ge 1$。\n\n3) 通过将平均场冻结在 $(N,Z)$ 并计算费米单粒子能量得到的 Koopmans 型估计值，\n   $$\n   \\varepsilon_{F,q}(N,Z) = T_{F,q}(N,Z) + U_q(N,Z), \\quad S_n^{K}(N,Z) \\approx -\\varepsilon_{F,n}(N,Z), \\quad S_p^{K}(N,Z) \\approx -\\varepsilon_{F,p}(N,Z),\n   $$\n   单位为 $\\text{MeV}$。\n\n你必须实现一个程序，对于以下原子核 $(N,Z)$ 的测试套件，计算 $S_n$、$S_n^{K}$、$S_p$ 和 $S_p^{K}$：\n\n- $(8,8)$, $(20,20)$, $(28,20)$, $(28,28)$, $(82,50)$, $(126,82)$, $(21,20)$, $(83,50)$, $(20,21)$。\n\n然后，对此套件，还要计算以下诊断指标，以量化和解释由关联和重排效应引起的偏差：\n\n- 中子和质子的 Koopmans 误差的均方根偏差，\n  $$\n  \\text{RMS}_n = \\sqrt{\\langle \\left(S_n^{K} - S_n\\right)^2 \\rangle}, \\quad \\text{RMS}_p = \\sqrt{\\langle \\left(S_p^{K} - S_p\\right)^2 \\rangle},\n  $$\n  单位为 $\\text{MeV}$，其中 $\\langle \\cdot \\rangle$ 表示在测试套件上的平均值。\n\n- 一个用于中子和质子的奇偶交错诊断量，定义为偶数和奇数粒子数的平均 Koopmans 误差之差，\n  $$\n  \\text{OES}_n = \\langle S_n^{K} - S_n \\rangle_{N \\text{ even}} - \\langle S_n^{K} - S_n \\rangle_{N \\text{ odd}},\n  $$\n  $$\n  \\text{OES}_p = \\langle S_p^{K} - S_p \\rangle_{Z \\text{ even}} - \\langle S_p^{K} - S_p \\rangle_{Z \\text{ odd}},\n  $$\n  单位为 $\\text{MeV}$。\n\n所有能量必须以 $\\text{MeV}$ 为单位表示，并四舍五入到三位小数。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。条目必须按以下顺序出现：\n\n- 对于上面列出的每个测试用例，按顺序输出四个数：$S_n$、$S_n^{K}$、$S_p$、$S_p^{K}$（每个数都四舍五入到三位小数，单位为 $\\text{MeV}$）。\n- 在所有用例之后，附加 $\\text{RMS}_n$、$\\text{RMS}_p$、$\\text{OES}_n$、$\\text{OES}_p$（每个数都四舍五入到三位小数，单位为 $\\text{MeV}$）。\n\n因此，最终输出格式是一个扁平的浮点数列表：\n$[S_{n,1},S_{n,1}^{K},S_{p,1},S_{p,1}^{K},\\dots,S_{n,9},S_{n,9}^{K},S_{p,9},S_{p,9}^{K},\\text{RMS}_n,\\text{RMS}_p,\\text{OES}_n,\\text{OES}_p]$。", "solution": "我们从非相对论性简并费米气体和 Hartree 平均场描述的公认原理出发。对于每种粒子 $q \\in \\{n,p\\}$，其数量为 $N_q$，数密度为 $\\rho_q$，费米动量为 $k_{F,q} = \\left(3\\pi^2 \\rho_q\\right)^{1/3}$，费米动能为 $T_{F,q} = \\frac{\\hbar^2 k_{F,q}^2}{2m}$。每个粒子的动能等于 $\\frac{3}{5} T_{F,q}$；因此，$q$ 类粒子的总动能为 $E_{\\text{kin},q} = \\frac{3}{5} N_q T_{F,q}$。对所有种类求和可得\n$$\nE_{\\text{kin}}(N,Z) = \\frac{3}{5} \\left(N T_{F,n} + Z T_{F,p}\\right),\n$$\n其中 $T_{F,q}$ 依赖于 $\\rho_q$。\n\n我们假设一个处于饱和密度 $\\rho_0 = 0.16\\,\\text{fm}^{-3}$ 的均匀有限原子核，总核子数为 $A = N+Z$，组分分数为 $x_n = \\frac{N}{A}$ 和 $x_p = \\frac{Z}{A}$。对于每种粒子，$\\rho_q = x_q \\rho_0$。则费米动能为\n$$\nT_{F,q}(N,Z) = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 x_q \\rho_0\\right)^{2/3}, \\quad \\frac{\\hbar^2}{2m} = 20.735\\,\\text{MeV}\\,\\text{fm}^2.\n$$\n\n在 Hartree 平均场模型中，总势能由占据粒子上在自洽密度下计算的平均场的一半总和给出，\n$$\nE_{\\text{mf}}(N,Z) = \\frac{1}{2}\\left(N U_n(N,Z) + Z U_p(N,Z)\\right).\n$$\n我们假设一个平均场，它由一个同位旋标量深度 $u_0$、一个与不对称参数 $\\delta = \\frac{N-Z}{A}$ 成正比且强度为 $u_{\\text{sym}}$ 的同位旋矢量项，以及一个与 $Z/A^{1/3}$ 成比例且强度为 $u_c$ 的质子库仑项组成：\n$$\nU_n(N,Z) = u_0 + u_{\\text{sym}} \\,\\delta, \\quad U_p(N,Z) = u_0 - u_{\\text{sym}} \\,\\delta + u_c \\frac{Z}{A^{1/3}}.\n$$\n我们设定 $u_0 = -60\\,\\text{MeV}$，$u_{\\text{sym}} = 50\\,\\text{MeV}$ 和 $u_c = 1.44\\,\\text{MeV}$。\n\n为了在一个示意性层面上包含对关联，我们添加一个唯象项\n$$\nE_{\\text{pair}}(N,Z) = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right),\n$$\n其中 $p_0 = 12\\,\\text{MeV}$，如果 $N$ 是偶数，$\\delta_{N \\text{ even}}$ 等于 $1$，否则为 $0$（$\\delta_{Z \\text{ even}}$ 同理）。该项为偶数粒子数提供了额外的结合能，而对于奇数粒子数则为零，从而模仿了奇偶交错现象。\n\n于是，总能量和结合能如下\n$$\nE(N,Z) = E_{\\text{kin}}(N,Z) + E_{\\text{mf}}(N,Z) + E_{\\text{pair}}(N,Z), \\quad B(N,Z) = -E(N,Z),\n$$\n单位为 $\\text{MeV}$。\n\n完全自洽的分离能通过结合能的有限差分计算：\n$$\nS_n(N,Z) = B(N,Z) - B(N-1,Z), \\quad S_p(N,Z) = B(N,Z) - B(N,Z-1),\n$$\n单位为 $\\text{MeV}$，其中 $N \\ge 1$ 且 $Z \\ge 1$。该过程对应于为 $(N-1,Z)$ 和 $(N,Z-1)$ 系统重新计算密度、费米动能和平均场，从而包含了由于 $A$ 的变化、不对称参数 $\\delta$ 的变化以及库仑项的贡献所引起的重排效应。\n\nKoopmans 型估计量基于冻结平均场近似：移出一个粒子，但不允许平均场弛豫。在这种情况下，移出能近似为费米面上单粒子能量的负值。类 Kohn-Sham 的费米面单粒子能量等于该粒子种类的费米动能和平均场势之和，\n$$\n\\varepsilon_{F,q}(N,Z) = T_{F,q}(N,Z) + U_q(N,Z).\n$$\n因此，\n$$\nS_n^{K}(N,Z) \\approx -\\varepsilon_{F,n}(N,Z) = -\\left[T_{F,n}(N,Z) + U_n(N,Z)\\right], \\quad\nS_p^{K}(N,Z) \\approx -\\varepsilon_{F,p}(N,Z) = -\\left[T_{F,p}(N,Z) + U_p(N,Z)\\right].\n$$\n该估计量忽略了两个物理上重要的偏差来源：(i) 平均场重排（在 $(N,Z)$ 和 $(N-1,Z)$ 或 $(N,Z-1)$ 之间密度和场的改变）和 (ii) 显式的关联能，如对关联能 $E_{\\text{pair}}$，这些能量并未在单粒子本征值中体现。\n\n为了量化该估计量在一组原子核上的表现，我们为每个案例计算 Koopmans 误差 $S_n^{K} - S_n$ 和 $S_p^{K} - S_p$，然后报告\n$$\n\\text{RMS}_n = \\sqrt{\\left\\langle \\left(S_n^{K} - S_n\\right)^2 \\right\\rangle}, \\quad\n\\text{RMS}_p = \\sqrt{\\left\\langle \\left(S_p^{K} - S_p\\right)^2 \\right\\rangle},\n$$\n作为均方根偏差，单位均为 $\\text{MeV}$。为了诊断由对关联驱动的奇偶效应，我们还计算\n$$\n\\text{OES}_n = \\langle S_n^{K} - S_n \\rangle_{N \\text{ even}} - \\langle S_n^{K} - S_n \\rangle_{N \\text{ odd}}, \\quad\n\\text{OES}_p = \\langle S_p^{K} - S_p \\rangle_{Z \\text{ even}} - \\langle S_p^{K} - S_p \\rangle_{Z \\text{ odd}},\n$$\n如果 Koopmans 估计量对于偶数系统更倾向于高估分离能（因为 $E_{\\text{pair}}$ 贡献了冻结场估计量所遗漏的额外结合能），那么该值应为正。\n\n算法实现细节：\n\n- 计算 $x_n = N/A$, $x_p = Z/A$，然后 $\\rho_n = x_n \\rho_0$ 和 $\\rho_p = x_p \\rho_0$。\n- 计算 $T_{F,q} = \\frac{\\hbar^2}{2m} \\left(3\\pi^2 \\rho_q\\right)^{2/3}$ 对于 $q \\in \\{n,p\\}$。\n- 计算 $\\delta = \\frac{N-Z}{A}$ 然后计算 $U_n$ 和 $U_p$。\n- 计算 $E_{\\text{kin}} = \\frac{3}{5} \\left(N T_{F,n} + Z T_{F,p}\\right)$。\n- 计算 $E_{\\text{mf}} = \\frac{1}{2} \\left(N U_n + Z U_p\\right)$。\n- 计算 $E_{\\text{pair}} = -\\frac{p_0}{\\sqrt{A}} \\left(\\delta_{N \\text{ even}} + \\delta_{Z \\text{ even}}\\right)$。\n- 计算 $E(N,Z)$ 和 $B(N,Z) = -E(N,Z)$。\n- 通过 $B$ 的有限差分计算 $S_n$ 和 $S_p$。\n- 从 $(N,Z)$ 处的费米单粒子能量的负值计算 $S_n^{K}$ 和 $S_p^{K}$。\n- 对于测试套件 $(N,Z) = (8,8), (20,20), (28,20), (28,28), (82,50), (126,82), (21,20), (83,50), (20,21)$，为每个案例计算并收集 $S_n$、$S_n^{K}$、$S_p$、$S_p^{K}$。\n- 在整个套件上计算 $\\text{RMS}_n$、$\\text{RMS}_p$、$\\text{OES}_n$ 和 $\\text{OES}_p$。\n- 所有能量以 $\\text{MeV}$ 表示，四舍五入到三位小数，并以指定的扁平列表格式打印单行输出。\n\n这种构造在物理上和数值上是自洽的：在这个均匀的 Thomas-Fermi 图像中，动能与 $A$ 成正比，平均场部分提供了一个带有同位旋矢量对称性和库仑贡献的同位旋标量结合深度，而对关联则引入了 Koopmans 估计量无法捕捉的奇偶交错。因此，偏差可以诊断出平均场重排和关联效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants and model parameters\nHBAR2_OVER_2M = 20.735  # MeV fm^2\nRHO0 = 0.16             # fm^-3\nU0 = -60.0              # MeV (isoscalar mean-field depth)\nU_SYM = 50.0            # MeV (isovector strength)\nU_C = 1.44              # MeV (Coulomb strength)\nP0 = 12.0               # MeV (pairing parameter)\n\ndef fermi_kinetic_energy(x_fraction: float) -> float:\n    \"\"\"\n    Compute the Fermi kinetic energy T_F for a species with fraction x = N_q / A\n    in a uniform system at saturation density RHO0.\n    T_F = (hbar^2 / 2m) * (3*pi^2 * rho_q)^(2/3), rho_q = x * RHO0\n    \"\"\"\n    rho_q = x_fraction * RHO0\n    # Guard against numerical issues for x=0 (though not relevant for provided test cases)\n    if rho_q == 0.0:\n        return 0.0\n    return HBAR2_OVER_2M * (3.0 * np.pi**2 * rho_q) ** (2.0 / 3.0)\n\ndef mean_fields(N: int, Z: int) -> tuple[float, float]:\n    \"\"\"\n    Compute neutron and proton mean fields U_n and U_p at (N,Z):\n      U_n = U0 + U_SYM * delta\n      U_p = U0 - U_SYM * delta + U_C * Z / A^(1/3)\n    where delta = (N - Z) / A\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0, 0.0\n    delta = (N - Z) / A\n    Un = U0 + U_SYM * delta\n    Up = U0 - U_SYM * delta + U_C * Z / (A ** (1.0 / 3.0))\n    return Un, Up\n\ndef pairing_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Schematic pairing correlation energy:\n      E_pair = - P0 / sqrt(A) * (delta_N_even + delta_Z_even)\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0\n    delta_N_even = 1 if (N % 2 == 0) else 0\n    delta_Z_even = 1 if (Z % 2 == 0) else 0\n    return -P0 / np.sqrt(A) * (delta_N_even + delta_Z_even)\n\ndef total_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Total energy E(N,Z) = E_kin + E_mf + E_pair.\n    \"\"\"\n    A = N + Z\n    if A == 0:\n        return 0.0\n    xn = N / A\n    xp = Z / A\n    TFn = fermi_kinetic_energy(xn)\n    TFp = fermi_kinetic_energy(xp)\n    Un, Up = mean_fields(N, Z)\n    Ekin = (3.0 / 5.0) * (N * TFn + Z * TFp)\n    Emf = 0.5 * (N * Un + Z * Up)\n    Epair = pairing_energy(N, Z)\n    return Ekin + Emf + Epair\n\ndef binding_energy(N: int, Z: int) -> float:\n    \"\"\"\n    Binding energy B = -E.\n    \"\"\"\n    return -total_energy(N, Z)\n\ndef separation_neutron(N: int, Z: int) -> float:\n    \"\"\"\n    Neutron separation energy S_n = B(N,Z) - B(N-1,Z), for N >= 1.\n    \"\"\"\n    if N == 0:\n        raise ValueError(\"N must be >= 1 for neutron separation energy.\")\n    return binding_energy(N, Z) - binding_energy(N - 1, Z)\n\ndef separation_proton(N: int, Z: int) -> float:\n    \"\"\"\n    Proton separation energy S_p = B(N,Z) - B(N,Z-1), for Z >= 1.\n    \"\"\"\n    if Z == 0:\n        raise ValueError(\"Z must be >= 1 for proton separation energy.\")\n    return binding_energy(N, Z) - binding_energy(N, Z - 1)\n\ndef koopmans_estimates(N: int, Z: int) -> tuple[float, float]:\n    \"\"\"\n    Koopmans-style estimates:\n      S_n^K = -[ T_Fn(N,Z) + U_n(N,Z) ]\n      S_p^K = -[ T_Fp(N,Z) + U_p(N,Z) ]\n    \"\"\"\n    A = N + Z\n    xn = N / A\n    xp = Z / A\n    TFn = fermi_kinetic_energy(xn)\n    TFp = fermi_kinetic_energy(xp)\n    Un, Up = mean_fields(N, Z)\n    SnK = -(TFn + Un)\n    SpK = -(TFp + Up)\n    return SnK, SpK\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 8),\n        (20, 20),\n        (28, 20),\n        (28, 28),\n        (82, 50),\n        (126, 82),\n        (21, 20),\n        (83, 50),\n        (20, 21),\n    ]\n\n    results = []\n    errors_n = []\n    errors_p = []\n    parity_n_even = []\n    parity_z_even = []\n\n    for (N, Z) in test_cases:\n        # Compute fully self-consistent separation energies\n        Sn = separation_neutron(N, Z)\n        Sp = separation_proton(N, Z)\n        # Koopmans estimates\n        SnK, SpK = koopmans_estimates(N, Z)\n\n        # Round to three decimals for output\n        results.extend([round(Sn, 3), round(SnK, 3), round(Sp, 3), round(SpK, 3)])\n\n        # Accumulate errors for diagnostics (use unrounded values)\n        err_n = SnK - Sn\n        err_p = SpK - Sp\n        errors_n.append(err_n)\n        errors_p.append(err_p)\n        parity_n_even.append(1 if (N % 2 == 0) else 0)\n        parity_z_even.append(1 if (Z % 2 == 0) else 0)\n\n    # Diagnostics: RMS errors\n    errors_n_arr = np.array(errors_n, dtype=float)\n    errors_p_arr = np.array(errors_p, dtype=float)\n    rms_n = float(np.sqrt(np.mean(errors_n_arr ** 2)))\n    rms_p = float(np.sqrt(np.mean(errors_p_arr ** 2)))\n\n    # Odd-even staggering diagnostics: difference between mean error for even and odd\n    parity_n_even_arr = np.array(parity_n_even, dtype=int)\n    parity_z_even_arr = np.array(parity_z_even, dtype=int)\n\n    # For neutrons\n    even_idx_n = parity_n_even_arr == 1\n    odd_idx_n = parity_n_even_arr == 0\n    mean_err_n_even = float(np.mean(errors_n_arr[even_idx_n])) if np.any(even_idx_n) else 0.0\n    mean_err_n_odd = float(np.mean(errors_n_arr[odd_idx_n])) if np.any(odd_idx_n) else 0.0\n    oes_n = mean_err_n_even - mean_err_n_odd\n\n    # For protons\n    even_idx_p = parity_z_even_arr == 1\n    odd_idx_p = parity_z_even_arr == 0\n    mean_err_p_even = float(np.mean(errors_p_arr[even_idx_p])) if np.any(even_idx_p) else 0.0\n    mean_err_p_odd = float(np.mean(errors_p_arr[odd_idx_p])) if np.any(odd_idx_p) else 0.0\n    oes_p = mean_err_p_even - mean_err_p_odd\n\n    # Append diagnostics to results, rounded to three decimals\n    results.extend([round(rms_n, 3), round(rms_p, 3), round(oes_n, 3), round(oes_p, 3)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3573744"}, {"introduction": "现代核物理学依赖于多种相互竞争的模型，每种模型各有优劣，这导致对奇特核的预言存在不确定性。本练习将向你介绍贝叶斯模型平均（Bayesian Model Averaging），这是一种强大的统计技术，用于量化这种“认知”不确定性。你将学习如何融合不同模型的预言，从而为分离能和中子滴线位置等关键可观测量，生成更稳健的估计值和不确定性区间。[@problem_id:3573721]", "problem": "您的任务是实现一个完全指定且可复现的贝叶斯模型平均程序，该程序跨越一组离散的核能量密度泛函（EDF）族，以量化中子分离能中的认知不确定性，并推断中子滴线的位置。您的实现必须从第一性原理出发，并仅使用下文指定的定义和定律。所有物理能量必须以兆电子伏特（MeV）为单位报告。所有角度（如有）必须以弧度为单位。所有最终数值输出必须按规定进行四舍五入。\n\n基本物理量定义如下。\n\n- 核结合能模型由半经验质量公式（Bethe–Weizsäcker形式）给出：\n$$\nB(Z,N; \\boldsymbol{\\theta}) \\equiv a_v A - a_s A^{2/3} - a_c \\frac{Z(Z-1)}{A^{1/3}} - a_a \\frac{(N-Z)^2}{A} + \\delta(Z,N),\n$$\n其中 $A \\equiv Z+N$，$Z$ 是质子数，$N$ 是中子数，$\\boldsymbol{\\theta} \\equiv (a_v,a_s,a_c,a_a,a_p)$ 是模型参数，对偶项为\n$$\n\\delta(Z,N) \\equiv \n\\begin{cases}\n+ a_p A^{-1/2},  \\text{若 $Z$ 和 $N$ 均为偶数},\\\\\n0,  \\text{若 $A$ 为奇数},\\\\\n- a_p A^{-1/2},  \\text{若 $Z$ 和 $N$ 均为奇数}。\n\\end{cases}\n$$\n\n- 单中子分离能为\n$$\nS_n(Z,N) \\equiv B(Z,N) - B(Z,N-1),\n$$\n仅在 $N \\ge 1$ 时有定义。\n\n- 双中子分离能为\n$$\nS_{2n}(Z,N) \\equiv B(Z,N) - B(Z,N-2),\n$$\n仅在 $N \\ge 2$ 时有定义。\n\n- 对于固定的质子数 $Z$，双中子滴线在此定义为搜索区间内满足 $S_{2n}(Z,N)  0$ 且 $S_{2n}(Z,N+2) \\le 0$ 的最大偶数中子数 $N_{\\text{drip},2n}(Z)$。如果在指定的搜索区间内没有发生这样的穿越，则滴线定义为该区间内具有严格正值 $S_{2n}(Z,N)$ 的最大偶数 $N$；如果区间内没有偶数 $N$ 具有严格正值的 $S_{2n}$，则将 $N_{\\text{drip},2n}(Z)$ 定义为搜索区间内最小的偶数 $N$。\n\n您将考虑一个由三个EDF族组成的离散模型空间，以 $m \\in \\{\\text{Skyrme}, \\text{Gogny}, \\text{Covariant}\\}$ 为索引，每个族由上述结合能公式中的一个固定参数矢量 $\\boldsymbol{\\theta}_m$ 表示：\n- Skyrme: $\\boldsymbol{\\theta}_{\\text{Skyrme}} = (a_v,a_s,a_c,a_a,a_p) = (15.8, 18.3, 0.70, 22.5, 11.0)$。\n- Gogny: $\\boldsymbol{\\theta}_{\\text{Gogny}} = (15.9, 17.5, 0.72, 24.0, 12.0)$。\n- Covariant: $\\boldsymbol{\\theta}_{\\text{Covariant}} = (16.2, 18.0, 0.68, 22.0, 10.5)$。\n\n为了校准模型权重，您将得到一个由单独的参数矢量定义的合成“基准真相”生成器：\n- 基准真相: $\\boldsymbol{\\theta}_{\\star} = (15.75, 17.8, 0.711, 23.7, 11.2)$。\n\n您必须根据此基准真相生成一个校准数据集，该数据集包含以下原子核的单中子和双中子分离能的测量值（为确保确定性而无噪声）：\n$$\n\\mathcal{D} \\equiv \\{(Z,N)\\} = \\{(8,8),(20,20),(28,30),(50,64),(82,126),(26,30),(28,50),(92,146)\\}.\n$$\n对于 $\\mathcal{D}$ 中的每个 $(Z,N)$，定义观测值 $y^{\\text{obs}}_{n}(Z,N) \\equiv S_n(Z,N;\\boldsymbol{\\theta}_{\\star})$ 和 $y^{\\text{obs}}_{2n}(Z,N) \\equiv S_{2n}(Z,N;\\boldsymbol{\\theta}_{\\star})$。假设每个观测数据都具有独立的髙斯似然，并使用固定的校准尺度 $\\sigma_{\\text{cal}} = 1.0$（单位为MeV）。您必须对所有EDF族赋予相等的先验概率，即 $p(M_m) = 1/3$。\n\n您的第一个任务是，使用 $\\mathcal{D}$ 中所有观测到的 $S_n$ 和 $S_{2n}$ 值的髙斯似然乘积，计算三个EDF族的贝叶斯模型后验概率 $p(M_m \\mid \\mathcal{D})$，给定每个模型 $M_m$ 的确定性预测值 $y_m$：\n$$\n\\log p(\\mathcal{D} \\mid M_m) = -\\frac{1}{2}\\sum_{i=1}^{N_{\\text{obs}}}\\left( \\frac{(y^{\\text{obs}}_i - y_{m,i})^2}{\\sigma_{\\text{cal}}^2} + \\log(2\\pi \\sigma_{\\text{cal}}^2) \\right),\n$$\n其中 $N_{\\text{obs}}$ 是将 $\\mathcal{D}$ 中的 $S_n$ 和 $S_{2n}$ 叠加后得到的观测标量总数。使用这些来计算后验模型权重\n$$\nw_m \\equiv p(M_m \\mid \\mathcal{D}) \\propto p(M_m)\\, p(\\mathcal{D} \\mid M_m),\n$$\n并进行归一化，使得 $\\sum_m w_m = 1$。您必须使用数值稳定的归一化方法（例如，log-sum-exp）。\n\n您的第二个任务是，使用后验模型权重，为任意 $(Z,N)$ 处的 $S_n$ 和 $S_{2n}$ 构建贝叶斯模型平均的预测分布。对于固定 $(Z,N)$ 处的标量可观测量 $Y \\in \\{S_n,S_{2n}\\}$，为每个 $m$ 定义模型预测值 $Y_m$，并计算贝叶斯模型平均的均值和方差：\n$$\n\\mu_Y \\equiv \\sum_m w_m\\, Y_m,\\quad \n\\sigma_Y^2 \\equiv \\sum_m w_m\\, \\big(Y_m - \\mu_Y\\big)^2.\n$$\n将 $\\sigma_Y$ 解释为源于模型类别差异的认知不确定性。不要将校准尺度 $\\sigma_{\\text{cal}}$ 添加到预测方差中；您只需报告认知不确定性。\n\n您的第三个任务是，使用贝叶斯模型平均的均值，计算选定同位素链的双中子滴线位置。对于每个指定的 $Z$，在从 $N_{\\min}(Z)$ 到 $N_{\\max}(Z)$（包含两端）的范围内扫描偶数 $N$，其中\n$$\nN_{\\min}(Z) \\equiv \\max(2,Z),\\quad N_{\\max}(Z) \\equiv Z + 80.\n$$\n如上述定义所述，使用 $\\mu_{S_{2n}}(Z,N)$ 在偶数 $N$ 上的符号变化来定义 $N_{\\text{drip},2n}(Z)$。\n\n您的第四个任务是识别模型差异最大的原子核。对于每个质子数 $Z$ 指定的网格 $\\mathcal{G}(Z)$，计算网格中每个 $(Z,N)$ 的跨模型范围\n$$\n\\Delta_Y(Z,N) \\equiv \\max_m Y_m(Z,N) - \\min_m Y_m(Z,N),\n$$\n对于 $Y \\in \\{S_n,S_{2n}\\}$。报告在这些网格的并集上使 $\\Delta_Y(Z,N)$ 最大化的 $(Z,N)$ 对，并报告相应的最大范围值。\n\n实现与测试套件。\n\n- 使用上面给出的三个模型和基准真相的EDF参数矢量。\n- 使用上面列出的校准集 $\\mathcal{D}$ 和 $\\sigma_{\\text{cal}} = 1.0$。\n- 用于认知不确定性估计的目标原子核（仅报告认知标准差 $\\sigma_{S_n}$ 和 $\\sigma_{S_{2n}}$）：\n  - $(Z,N) = (20,20)$,\n  - $(Z,N) = (28,50)$,\n  - $(Z,N) = (8,20)$。\n- 双中子滴线质子数（报告 $N_{\\text{drip},2n}(Z)$）：\n  - $Z \\in \\{8,20,28\\}$。\n- 差异网格：\n  - 对于 $Z \\in \\{8,20,28\\}$，从 $N_{\\min}(Z)$ 到 $N_{\\max}^{\\text{grid}}(Z)$（包含两端）扫描 $N$，其中 $N_{\\max}^{\\text{grid}}(Z) \\equiv Z + 60$。\n  - 对于这些网格中的每个 $(Z,N)$，计算 $\\Delta_{S_{2n}}(Z,N)$ 和 $\\Delta_{S_n}(Z,N)$，并为每个可观测量识别出具有最大值的唯一 $(Z,N)$。如果出现平局，选择最小的 $Z$，然后选择最小的 $N$。\n\n数值与报告要求。\n\n- 所有分离能必须以MeV为单位计算和解释。\n- 所有输出必须按如下方式四舍五入：\n  - 对于认知标准差 $\\sigma_{S_n}$ 和 $\\sigma_{S_{2n}}$，四舍五入到三位小数。\n  - 对于滴线中子数 $N_{\\text{drip},2n}(Z)$，报告为整数。\n  - 对于最大差异值 $\\Delta_{S_{2n}}$ 和 $\\Delta_{S_n}$，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序如下：\n  - $(20,20)$ 的 $\\sigma_{S_n}$，\n  - $(20,20)$ 的 $\\sigma_{S_{2n}}$，\n  - $(28,50)$ 的 $\\sigma_{S_n}$，\n  - $(28,50)$ 的 $\\sigma_{S_{2n}}$，\n  - $(8,20)$ 的 $\\sigma_{S_n}$，\n  - $(8,20)$ 的 $\\sigma_{S_{2n}}$，\n  - $N_{\\text{drip},2n}(8)$，\n  - $N_{\\text{drip},2n}(20)$，\n  - $N_{\\text{drip},2n}(28)$，\n  - 最大 $\\Delta_{S_{2n}}$ 对应的 $Z$，\n  - 最大 $\\Delta_{S_{2n}}$ 对应的 $N$，\n  - 最大 $\\Delta_{S_{2n}}$ 的值，\n  - 最大 $\\Delta_{S_n}$ 对应的 $Z$，\n  - 最大 $\\Delta_{S_n}$ 对应的 $N$，\n  - 最大 $\\Delta_{S_n}$ 的值。\n- 因此，输出必须恰好包含 $15$ 个条目。例如，输出格式必须如下所示：\n$$\n[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{int},\\text{int},\\text{int},\\text{int},\\text{int},\\text{float},\\text{int},\\text{int},\\text{float}],\n$$\n其中浮点数按规定四舍五入，除了分隔各项所必需的逗号外，没有额外的空格。\n\n算法约束与指南。\n\n- 仅使用上述定义以及在具有均匀先验和髙斯校准似然的离散模型集上进行贝叶斯模型平均的原理。\n- 通过log-sum-exp归一化，确保模型后验权重 $w_m$ 的计算在数值上是稳定的。\n- 所有扫描必须遵守指定的边界 $N_{\\min}(Z)$、$N_{\\max}(Z)$ 和 $N_{\\max}^{\\text{grid}}(Z)$。\n- 程序必须是确定性的，不得依赖随机抽样。\n\n您的程序必须是一个完整、可运行的实现，能产生恰好一行符合要求格式和顺序的输出。", "solution": "用户提供了一个计算核物理问题，要求实现一个贝叶斯模型平均（BMA）程序，以量化源自半经验质量公式（SEMF）的核性质的不确定性。该问题是自洽的，具有坚实的科学基础（尽管模型是简化的）和统计方法，并且是适定的，所有必需的参数、定义和程序都已明确说明。因此，该问题被判定为**有效**。\n\n解决方案通过分步实现指定的模型和算法来进行。\n\n**1. 核结合能模型的实现**\n\n问题的核心是用于计算具有 $Z$ 个质子和 $N$ 个中子的原子核结合能 $B(Z,N)$ 的Bethe–Weizsäcker半经验质量公式。\n$$\nB(Z,N; \\boldsymbol{\\theta}) = a_v A - a_s A^{2/3} - a_c \\frac{Z(Z-1)}{A^{1/3}} - a_a \\frac{(N-Z)^2}{A} + \\delta(Z,N)\n$$\n这里，$A = Z+N$ 是质量数，$\\boldsymbol{\\theta} = (a_v, a_s, a_c, a_a, a_p)$ 是模型参数的矢量。对偶项 $\\delta(Z,N)$ 取决于 $Z$ 和 $N$ 的宇称：\n$$\n\\delta(Z,N) = \n\\begin{cases}\n+ a_p A^{-1/2},  \\text{如果 $Z$ 和 $N$ 是偶数（偶偶核）},\\\\\n0,  \\text{如果 $A$ 是奇数（奇A核）},\\\\\n- a_p A^{-1/2},  \\text{如果 $Z$ 和 $N$ 是奇数（奇奇核）}。\n\\end{cases}\n$$\n实现此函数，使其接受 $Z$、$N$ 和参数矢量 $\\boldsymbol{\\theta}$ 作为输入，并返回以兆电子伏特（MeV）为单位的结合能。\n\n**2. 分离能的实现**\n\n根据结合能，我们定义并实现单中子分离能 $S_n$ 和双中子分离能 $S_{2n}$：\n$$\nS_n(Z,N) \\equiv B(Z,N) - B(Z,N-1), \\quad \\text{对于 } N \\ge 1\n$$\n$$\nS_{2n}(Z,N) \\equiv B(Z,N) - B(Z,N-2), \\quad \\text{对于 } N \\ge 2\n$$\n通过使用适当的参数调用`binding_energy`函数来实现这些函数。\n\n**3. 贝叶斯模型平均：后验权重计算**\n\n问题定义了一个由三个能量密度泛函（EDF）族组成的模型空间，每个族由一组特定的参数集 $\\boldsymbol{\\theta}_m$ 代表：$\\boldsymbol{\\theta}_{\\text{Skyrme}}$、$\\boldsymbol{\\theta}_{\\text{Gogny}}$ 和 $\\boldsymbol{\\theta}_{\\text{Covariant}}$。我们必须给定一个观测数据集 $\\mathcal{D}$，确定每个模型 $M_m$ 的后验概率 $p(M_m \\mid \\mathcal{D})$。\n\n首先，使用一个具有参数 $\\boldsymbol{\\theta}_{\\star}$ 的“基准真相”模型生成数据集 $\\mathcal{D}$。对于指定校准集中的8个原子核 $(Z,N)$ 中的每一个，我们计算真值 $y^{\\text{obs}}_{n}(Z,N) = S_n(Z,N;\\boldsymbol{\\theta}_{\\star})$ 和 $y^{\\text{obs}}_{2n}(Z,N) = S_{2n}(Z,N;\\boldsymbol{\\theta}_{\\star})$。这会产生 $N_{\\text{obs}} = 16$ 个数据点。\n\n后验概率由贝叶斯定理给出：$p(M_m \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid M_m) p(M_m)$。问题指定了均匀模型先验，$p(M_m) = 1/3$。似然 $p(\\mathcal{D} \\mid M_m)$ 是独立高斯分布的乘积，每个观测一个。对数似然为：\n$$\n\\log p(\\mathcal{D} \\mid M_m) = -\\frac{1}{2}\\sum_{i=1}^{N_{\\text{obs}}}\\left( \\frac{(y^{\\text{obs}}_i - y_{m,i})^2}{\\sigma_{\\text{cal}}^2} + \\log(2\\pi \\sigma_{\\text{cal}}^2) \\right)\n$$\n其中 $y_{m,i}$ 是模型 $M_m$ 的预测值，$\\sigma_{\\text{cal}} = 1.0$ MeV是固定的校准尺度。\n对于每个模型 $m$，我们计算其预测矢量 $\\{y_{m,i}\\}$，然后计算其对数似然。\n后验权重 $w_m \\equiv p(M_m \\mid \\mathcal{D})$ 通过对后验进行归一化来计算。为了在数值上稳定地执行此操作，我们在对数域中工作。模型 $m$ 的未归一化对数后验是 $\\log p(M_m) + \\log p(\\mathcal{D} \\mid M_m)$。由于先验是均匀的，这与对数似然成正比（相差一个加法常数）。我们计算每个模型的对数似然，然后使用log-sum-exp变换来找到归一化的权重 $w_m$：\n$$\n\\log w_m = \\log p(\\mathcal{D} \\mid M_m) - \\text{logsumexp}_k(\\log p(\\mathcal{D} \\mid M_k))\n$$\n$$\nw_m = \\exp(\\log w_m)\n$$\n\n**4. 预测不确定性量化**\n\n有了后验权重 $w_m$，我们可以为任何可观测量 $Y$ 形成BMA预测。对于给定的原子核 $(Z,N)$，每个模型 $m$ 提供一个预测 $Y_m = Y(Z,N;\\boldsymbol{\\theta}_m)$。BMA均值 $\\mu_Y$ 和认知方差 $\\sigma_Y^2$ 为：\n$$\n\\mu_Y = \\sum_m w_m Y_m\n$$\n$$\n\\sigma_Y^2 = \\sum_m w_m (Y_m - \\mu_Y)^2 = \\left(\\sum_m w_m Y_m^2\\right) - \\mu_Y^2\n$$\n问题要求提供特定目标原子核的 $S_n$ 和 $S_{2n}$ 的认知标准差 $\\sigma_Y = \\sqrt{\\sigma_Y^2}$。\n\n**5. 双中子滴线计算**\n\n对于给定的 $Z$，双中子滴线是通过在BMA平均的双中子分离能 $\\mu_{S_{2n}}(Z,N)$ 中寻找符号变化来找到的。搜索在区间 $[N_{\\min}(Z), N_{\\max}(Z)]$ 内对偶数 $N$ 进行，其中 $N_{\\min}(Z) = \\max(2,Z)$ 和 $N_{\\max}(Z) = Z+80$。滴线 $N_{\\text{drip},2n}(Z)$ 定义为该区间内满足 $\\mu_{S_{2n}}(Z,N)  0$ 且 $\\mu_{S_{2n}}(Z,N+2) \\le 0$ 的最大偶数 $N$。该定义包括了当没有发生此类穿越或链中没有原子核对双中子发射稳定时的回退情况。算法必须仔细实现这个由三部分组成的定义。\n\n**6. 最大模型差异的识别**\n\n为了找出模型差异最大的地方，我们在指定的网格中为每个原子核 $(Z,N)$ 计算 $S_n$ 和 $S_{2n}$ 的预测范围。范围定义为：\n$$\n\\Delta_Y(Z,N) = \\max_m Y_m(Z,N) - \\min_m Y_m(Z,N)\n$$\n我们遍历为 $Z \\in \\{8, 20, 28\\}$ 定义的网格，其中 $N$ 从 $N_{\\min}(Z)$ 到 $Z+60$。我们跟踪为 $Y=S_n$ 和 $Y=S_{2n}$ 找到的最大 $\\Delta_Y$ 值，以及相应的 $(Z,N)$ 坐标。指定的平局决胜规则（最小的 $Z$，然后是最小的 $N$）通过搜索循环的顺序自然处理。\n\n**7. 最终结果组装**\n\n最后一步是按指定顺序收集所有计算出的量：六个认知标准差，三个滴线中子数，以及两组用于最大差异的 $(Z,N,\\Delta)$。这15个值根据给定的精度要求进行四舍五入，并格式化为单行逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Implements the full Bayesian model averaging procedure as specified.\n    \"\"\"\n    \n    # 1. Define constants, parameters, and datasets\n    \n    # Model parameters: (a_v, a_s, a_c, a_a, a_p) in MeV\n    params = {\n        'Skyrme': np.array([15.8, 18.3, 0.70, 22.5, 11.0]),\n        'Gogny': np.array([15.9, 17.5, 0.72, 24.0, 12.0]),\n        'Covariant': np.array([16.2, 18.0, 0.68, 22.0, 10.5]),\n    }\n    model_names = list(params.keys())\n    \n    # Ground-truth parameters\n    params_gt = np.array([15.75, 17.8, 0.711, 23.7, 11.2])\n    \n    # Calibration dataset D\n    calibration_nuclei = [\n        (8, 8), (20, 20), (28, 30), (50, 64), (82, 126),\n        (26, 30), (28, 50), (92, 146)\n    ]\n    \n    # Calibration scale\n    sigma_cal = 1.0\n    \n    # 2. Implement core physics functions\n\n    # Memoization cache for binding energy to speed up repeated calculations\n    be_cache = {}\n\n    def binding_energy(Z, N, p):\n        \"\"\"Calculates binding energy using the semi-empirical mass formula.\"\"\"\n        Z, N = int(Z), int(N)\n        p_tuple = tuple(p)\n        if (Z, N, p_tuple) in be_cache:\n            return be_cache[(Z, N, p_tuple)]\n            \n        if Z  0 or N  0 or Z + N == 0:\n            return 0.0\n\n        A = Z + N\n        a_v, a_s, a_c, a_a, a_p = p\n        \n        vol_term = a_v * A\n        surf_term = -a_s * A**(2/3)\n        coulomb_term = -a_c * Z * (Z - 1) / A**(1/3) if A > 0 else 0\n        asym_term = -a_a * (N - Z)**2 / A if A > 0 else 0\n        \n        pairing_term = 0.0\n        if Z % 2 == 0 and N % 2 == 0: # a.k.a. A even\n            pairing_term = a_p * A**(-0.5)\n        elif Z % 2 != 0 and N % 2 != 0: # a.k.a. A even\n            pairing_term = -a_p * A**(-0.5)\n        # else A is odd, pairing_term is 0\n\n        B = vol_term + surf_term + coulomb_term + asym_term + pairing_term\n        be_cache[(Z, N, p_tuple)] = B\n        return B\n\n    def s_n(Z, N, p):\n        \"\"\"Calculates one-neutron separation energy.\"\"\"\n        if N  1: return np.nan\n        return binding_energy(Z, N, p) - binding_energy(Z, N - 1, p)\n\n    def s_2n(Z, N, p):\n        \"\"\"Calculates two-neutron separation energy.\"\"\"\n        if N  2: return np.nan\n        return binding_energy(Z, N, p) - binding_energy(Z, N - 2, p)\n\n    # 3. Generate calibration data\n    \n    y_obs = []\n    for Z, N in calibration_nuclei:\n        y_obs.append(s_n(Z, N, params_gt))\n        y_obs.append(s_2n(Z, N, params_gt))\n    y_obs = np.array(y_obs)\n\n    # 4. Calculate posterior model weights\n    \n    log_likelihoods = []\n    for name in model_names:\n        p_model = params[name]\n        y_model = []\n        for Z, N in calibration_nuclei:\n            y_model.append(s_n(Z, N, p_model))\n            y_model.append(s_2n(Z, N, p_model))\n        y_model = np.array(y_model)\n\n        # Sum of squared errors\n        sse = np.sum((y_obs - y_model)**2)\n        # Log-likelihood, ignoring constant terms that cancel in normalization\n        log_L = -0.5 * sse / (sigma_cal**2)\n        log_likelihoods.append(log_L)\n    \n    # Normalize log-likelihoods to get log-weights (uniform prior)\n    log_weights = np.array(log_likelihoods) - logsumexp(log_likelihoods)\n    weights = np.exp(log_weights)\n\n    # 5. BMA prediction helper function\n    \n    def predict_bma(Z, N, sep_energy_func):\n        \"\"\"Calculates BMA mean, epistemic std dev, and individual predictions.\"\"\"\n        predictions = np.array([sep_energy_func(Z, N, params[name]) for name in model_names])\n        mean = np.sum(weights * predictions)\n        variance = np.sum(weights * predictions**2) - mean**2\n        std_dev = np.sqrt(variance) if variance > 0 else 0.0\n        return mean, std_dev, predictions\n\n    # 6. Perform the required calculations\n\n    # Task 1: Epistemic uncertainties for target nuclei\n    targets_std = [(20, 20), (28, 50), (8, 20)]\n    std_dev_results = []\n    for Z, N in targets_std:\n        _, std_sn, _ = predict_bma(Z, N, s_n)\n        _, std_s2n, _ = predict_bma(Z, N, s_2n)\n        std_dev_results.extend([std_sn, std_s2n])\n\n    # Task 2: Two-neutron drip-line positions\n    drip_line_Zs = [8, 20, 28]\n    drip_line_results = []\n    for Z in drip_line_Zs:\n        N_min = max(2, Z)\n        # The scan must be over even N\n        if N_min % 2 != 0: N_min += 1\n        N_max = Z + 80\n\n        s2n_means = {N: predict_bma(Z, N, s_2n)[0] for N in range(N_min, N_max + 3, 2)}\n        \n        drip_crossings = []\n        positive_s2n_Ns = []\n        \n        for N in range(N_min, N_max + 1, 2):\n            s2n_current = s2n_means[N]\n            if s2n_current > 0:\n                positive_s2n_Ns.append(N)\n                s2n_next = s2n_means[N+2]\n                if s2n_next = 0:\n                    drip_crossings.append(N)\n        \n        if drip_crossings:\n            drip_line_results.append(max(drip_crossings))\n        elif positive_s2n_Ns:\n            drip_line_results.append(max(positive_s2n_Ns))\n        else:\n            drip_line_results.append(N_min)\n\n    # Task 3: Maximal model disagreement\n    disagreement_Zs = [8, 20, 28]\n    max_delta_sn = -1.0\n    zn_max_delta_sn = (-1, -1)\n    max_delta_s2n = -1.0\n    zn_max_delta_s2n = (-1, -1)\n\n    for Z in disagreement_Zs:\n        N_min_grid = max(2, Z)\n        N_max_grid = Z + 60\n        for N in range(N_min_grid, N_max_grid + 1):\n            # S_n\n            if N >= 1:\n                _, _, preds_sn = predict_bma(Z, N, s_n)\n                delta_sn = np.max(preds_sn) - np.min(preds_sn)\n                if delta_sn > max_delta_sn:\n                    max_delta_sn = delta_sn\n                    zn_max_delta_sn = (Z, N)\n            \n            # S_2n\n            if N >= 2:\n                _, _, preds_s2n = predict_bma(Z, N, s_2n)\n                delta_s2n = np.max(preds_s2n) - np.min(preds_s2n)\n                if delta_s2n > max_delta_s2n:\n                    max_delta_s2n = delta_s2n\n                    zn_max_delta_s2n = (Z, N)\n    \n    disagreement_results_s2n = [zn_max_delta_s2n[0], zn_max_delta_s2n[1], max_delta_s2n]\n    disagreement_results_sn = [zn_max_delta_sn[0], zn_max_delta_sn[1], max_delta_sn]\n\n    # 7. Assemble final output\n    \n    results = [\n        round(std_dev_results[0], 3), round(std_dev_results[1], 3),\n        round(std_dev_results[2], 3), round(std_dev_results[3], 3),\n        round(std_dev_results[4], 3), round(std_dev_results[5], 3),\n        drip_line_results[0], drip_line_results[1], drip_line_results[2],\n        disagreement_results_s2n[0], disagreement_results_s2n[1], round(disagreement_results_s2n[2], 3),\n        disagreement_results_sn[0], disagreement_results_sn[1], round(disagreement_results_sn[2], 3),\n    ]\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573721"}]}