{"hands_on_practices": [{"introduction": "选择合适的有限差分格式不仅仅是为了数学上的优美，更关乎实际计算中的稳定性和准确性。此练习旨在揭示数值微分中两种相互竞争的误差来源：截断误差（源于近似本身）和舍入误差（源于有限精度计算）。通过动手实践 [@problem_id:3576284]，你将深入理解为何中心差分格式（其截断误差为 $O(h^2)$）通常优于前向差分格式（其截断误差为 $O(h)$），尤其是在平衡两种误差以获得最佳步长 $h$ 时。", "problem": "考虑在双精度浮点运算下，通过有限差分对一个光滑标量函数 $f$ 在点 $x$ 处的一阶导数进行数值近似。从导数的极限数学定义以及 $f$ 在 $x$ 点的泰勒展开出发。在你的推理中，使用以下经过充分检验的事实作为基础：导数由 $f^{\\prime}(x)=\\lim_{h\\to 0}\\frac{f(x+h)-f(x)}{h}$ 定义，光滑函数允许带有余项的泰勒展开，以及带有单位舍入误差（机器 epsilon）$\\varepsilon_{\\text{mach}}$ 的浮点运算会在基本操作中引入量级为 $\\varepsilon_{\\text{mach}}$ 的相对误差。除了从这些基础推导出的结论外，不要假设或使用任何预先推导的有限差分误差公式。\n\n你的任务是，从泰勒展开的截断误差和浮点运算的舍入误差角度解释，为什么对于光滑函数 $f$，相减抵消（subtractive cancellation）对单边前向差分近似的影响比对双边中心差分近似的影响更严重。解释应基于相互竞争的截断误差和舍入误差如何随步长 $h$ 变化，以及较小的 $h$ 会加剧两个几乎相等的数相减的问题。\n\n然后，使用双精度算术，对 $f(x)=\\exp(x)$ 在 $x=0$ 的情况进行计算演示。实现两个直接从导数的极限定义推导出的离散差商，即用有限增量代替极限：\n- 使用 $h$ 的前向差分：$\\frac{f(x+h)-f(x)}{h}$，\n- 使用 $h$ 的中心差分：$\\frac{f(x+h)-f(x-h)}{2h}$。\n\n使用真实的导数值 $f^{\\prime}(0)=1$ 进行误差评估，该值可从指数函数的基本性质得出。不涉及物理单位。\n\n测试组：\n计算在 $x=0$ 处，对于以下步长 $h$ 的近似值和误差：\n- $h=10^{-2}$（一个一般情况，两种格式的截断误差都大于舍入误差），\n- $h=10^{-8}$（指定情况，用于展示相减抵消效应），\n- $h=10^{-16}$（一个接近机器 epsilon 量级的边界情况）。\n\n对于测试组中的每个 $h$，生成以下输出：\n- 前向差分近似值，\n- 中心差分近似值，\n- 前向差分相对于 $1$ 的绝对误差，\n- 中心差分相对于 $1$ 的绝对误差，\n- 一个布尔值，指示中心差分的绝对误差是否严格小于前向差分的绝对误差。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。每个项目对应于上面列出的一个 $h$，并且本身也是一个由方括号括起来的逗号分隔列表：$[h,\\ \\text{forward\\_approx},\\ \\text{central\\_approx},\\ \\text{abs\\_error\\_forward},\\ \\text{abs\\_error\\_central},\\ \\text{central\\_better}]$。例如，一个语法上有效的形状是 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$。打印的行中不要包含任何空格。", "solution": "问题要求解释截断误差和舍入误差如何影响一阶导数的前向差分和中心差分近似，然后进行计算演示。\n\n数值近似的总误差是截断误差和舍入误差之和。截断误差 $E_T$ 是由于用有限过程（使用小步长 $h$）近似无限过程（导数的极限定义）而产生的。舍入误差 $E_R$ 是由于浮点运算的有限精度而产生的。\n\n设被微分的函数为 $f(x)$，并假设其是光滑的。为了进行分析，我们将使用泰勒定理在点 $x$ 附近展开 $f$。浮点运算的特点是机器 epsilon $\\varepsilon_{\\text{mach}}$，它是满足 $\\text{fl}(1 + \\varepsilon_{\\text{mach}}) > 1$ 的最小数，其中 $\\text{fl}(\\cdot)$ 表示浮点表示。对一个值 $y$ 进行浮点运算会引入一个相对误差，使得计算值为 $\\text{fl}(y) = y(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon_{\\text{mach}}$。\n\n**1. 前向差分近似**\n\n单边前向差分公式为：\n$$\nD_f(h) = \\frac{f(x+h) - f(x)}{h}\n$$\n\n**截断误差 ($E_{T,f}$):**\n我们使用 $f(x+h)$ 在 $x$ 点的泰勒展开：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(\\xi)\n$$\n其中某个 $\\xi \\in (x, x+h)$。将此代入 $D_f(h)$ 的公式中：\n$$\nD_f(h) = \\frac{\\left(f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + O(h^3)\\right) - f(x)}{h} = f'(x) + \\frac{h}{2}f''(x) + O(h^2)\n$$\n截断误差是近似值与真实值之间的差：\n$$\nE_{T,f} = D_f(h) - f'(x) = \\frac{h}{2}f''(x) + O(h^2)\n$$\n截断误差的量级为 $O(h)$。随着步长 $h$ 减小，该误差线性减小。\n\n**舍入误差 ($E_{R,f}$):**\n在浮点运算中，我们计算 $\\hat{D}_f(h) = \\frac{\\text{fl}(f(x+h)) - \\text{fl}(f(x))}{h}$。令 $\\hat{f}(y) = \\text{fl}(f(y))$。则 $\\hat{f}(x+h) = f(x+h)(1+\\delta_1)$ 且 $\\hat{f}(x) = f(x)(1+\\delta_2)$，其中 $|\\delta_1|, |\\delta_2| \\leq \\varepsilon_{\\text{mach}}$。\n计算出的分子是 $\\hat{N}_f = \\text{fl}(\\hat{f}(x+h) - \\hat{f}(x))$。对于小的 $h$，$f(x+h) \\approx f(x)$，这是**相减抵消**的典型情况。两个几乎相等的数相减会导致相对精度的损失。分子中的绝对误差约为 $|f(x+h)\\delta_1 - f(x)\\delta_2| \\approx |f(x)(\\delta_1 - \\delta_2)|$，其上界为 $2|f(x)|\\varepsilon_{\\text{mach}}$。\n最终结果中的舍入误差是这个分子误差除以 $h$：\n$$\n|E_{R,f}| \\approx \\frac{2|f(x)|\\varepsilon_{\\text{mach}}}{h}\n$$\n舍入误差的量级为 $O(\\varepsilon_{\\text{mach}}/h)$。随着 $h$ 减小，该误差分量会增大。\n\n**总误差：** 前向差分的总绝对误差约为 $|E_{\\text{total},f}| \\approx |E_{T,f}| + |E_{R,f}| \\approx C_1 h + C_2 \\frac{\\varepsilon_{\\text{mach}}}{h}$，其中 $C_1 = |\\frac{1}{2}f''(x)|$，$C_2 = 2|f(x)|$。\n\n**2. 中心差分近似**\n\n双边中心差分公式为：\n$$\nD_c(h) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n\n**截断误差 ($E_{T,c}$):**\n我们对 $f(x+h)$ 和 $f(x-h)$ 使用泰勒展开：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(x) + \\frac{h^4}{24}f^{(4)}(x) + O(h^5)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f'''(x) + \\frac{h^4}{24}f^{(4)}(x) - O(h^5)\n$$\n从第一个展开式中减去第二个展开式会消掉偶数次幂项：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f'''(x) + O(h^5)\n$$\n将此代入 $D_c(h)$ 的公式中：\n$$\nD_c(h) = \\frac{2hf'(x) + \\frac{h^3}{3}f'''(x) + O(h^5)}{2h} = f'(x) + \\frac{h^2}{6}f'''(x) + O(h^4)\n$$\n因此，截断误差为：\n$$\nE_{T,c} = D_c(h) - f'(x) = \\frac{h^2}{6}f'''(x) + O(h^4)\n$$\n截断误差的量级为 $O(h^2)$，它随 $h$ 呈二次方减小，因此优于前向差分的 $O(h)$ 误差。\n\n**舍入误差 ($E_{R,c}$):**\n分析与前向差分的情况类似。分子涉及减法 $f(x+h) - f(x-h)$，对于小 $h$ 同样会发生相减抵消。计算出的分子中的绝对误差近似上界为 $2|f(x)|\\varepsilon_{\\text{mach}}$。\n最终结果中的舍入误差是这个误差除以 $2h$：\n$$\n|E_{R,c}| \\approx \\frac{2|f(x)|\\varepsilon_{\\text{mach}}}{2h} = \\frac{|f(x)|\\varepsilon_{\\text{mach}}}{h}\n$$\n舍入误差的量级同样为 $O(\\varepsilon_{\\text{mach}}/h)$，与前向差分相同（仅相差大约一个因子 $2$）。\n\n**3. 比较与结论**\n\n中心差分的总绝对误差约为 $|E_{\\text{total},c}| \\approx |E_{T,c}| + |E_{R,c}| \\approx K_1 h^2 + K_2 \\frac{\\varepsilon_{\\text{mach}}}{h}$，其中 $K_1 = |\\frac{1}{6}f'''(x)|$，$K_2 = |f(x)|$。\n\n相减抵消之所以看起来对前向差分方法影响更严重，原因在于其 $O(h)$ 截断误差与 $O(\\varepsilon_{\\text{mach}}/h)$ 舍入误差之间的相互作用。\n- 对于一个中等小的 $h$，中心差分公式的 $O(h^2)$ 截断误差远小于前向差分公式的 $O(h)$ 误差。因此，总误差由这个小得多的截断误差主导，使得中心差分方法天生就更精确。\n- 两种方法都因相减抵消而产生与 $1/h$ 成正比的舍入误差。然而，由于中心差分方法的初始截断误差小得多，它可以在不断增长的舍入误差压倒结果之前，容忍更小的 $h$ 值。\n- 使总误差最小的最优步长 $h^*$ 是通过平衡两个误差项找到的。对于前向差分，这发生在 $C_1 h \\approx C_2 \\varepsilon_{\\text{mach}}/h$ 时，得到 $h_{opt,f} \\propto \\sqrt{\\varepsilon_{\\text{mach}}}$。可达到的最小误差为 $O(\\sqrt{\\varepsilon_{\\text{mach}}})$。对于中心差分，这发生在 $K_1 h^2 \\approx K_2 \\varepsilon_{\\text{mach}}/h$ 时，得到 $h_{opt,c} \\propto \\sqrt[3]{\\varepsilon_{\\text{mach}}}$。可达到的最小误差为 $O(\\varepsilon_{\\text{mach}}^{2/3})$。\n- 由于对于 $\\varepsilon_{\\text{mach}} \\ll 1$，有 $\\varepsilon_{\\text{mach}}^{2/3} \\ll \\varepsilon_{\\text{mach}}^{1/2}$，因此中心差分方法可以达到更高的最终精度。\n\n总而言之，虽然相减抵消机制在两种方法中都导致了量级为 $O(\\varepsilon_{\\text{mach}}/h)$ 的舍入误差，但中心差分方法受到的影响“不那么严重”，因为其远为优越的截断误差（$O(h^2)$ 对比 $O(h)$）意味着在更广泛且更实用的步长 $h$ 范围内，其总误差保持更小。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes forward and central difference approximations for the derivative of exp(x) at x=0\n    and analyzes their errors for different step sizes.\n    \"\"\"\n    x = 0.0\n    true_deriv = np.exp(x)  # which is 1.0\n\n    test_cases = [1e-2, 1e-8, 1e-16]\n    \n    results = []\n\n    for h in test_cases:\n        # np.float64 is used to ensure double-precision as specified.\n        h_val = np.float64(h)\n        x_val = np.float64(x)\n        \n        # Function evaluations\n        f_x = np.exp(x_val)\n        f_x_plus_h = np.exp(x_val + h_val)\n        f_x_minus_h = np.exp(x_val - h_val)\n        \n        # Forward difference approximation\n        # (f(x+h) - f(x)) / h\n        forward_approx = (f_x_plus_h - f_x) / h_val\n        \n        # Central difference approximation\n        # (f(x+h) - f(x-h)) / (2*h)\n        central_approx = (f_x_plus_h - f_x_minus_h) / (2.0 * h_val)\n        \n        # Absolute errors relative to the true value\n        abs_error_forward = np.abs(forward_approx - true_deriv)\n        abs_error_central = np.abs(central_approx - true_deriv)\n        \n        # Boolean check: is central difference more accurate?\n        central_better = bool(abs_error_central  abs_error_forward)\n        \n        # Collect results for this case\n        case_result = [\n            h_val,\n            forward_approx,\n            central_approx,\n            abs_error_forward,\n            abs_error_central,\n            central_better\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as specified\n    output_parts = []\n    for r in results:\n        # Format: [h,forward_approx,central_approx,abs_error_forward,abs_error_central,central_better]\n        # str() on a boolean produces 'True' or 'False'\n        part = f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]},{str(r[5]).lower()}]\"\n        output_parts.append(part)\n        \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "3576284"}, {"introduction": "在确定中心差分的优越性之后，一个实际问题随之而来：如何在计算网格的边界上应用它？此练习介绍了一种优雅的技术——“幽灵单元法”（ghost-cell method），用于处理诸如诺伊曼（Neumann）边界条件（$f'(x)=0$）等在具有反射对称性的物理问题中常见的情况。通过这个实践 [@problem_id:3576260]，你将推导并实现一种幽灵单元外推方案，从而能够在整个计算域上一致地应用高阶数值格式，这是构建稳健的偏微分方程求解器的关键技能。", "problem": "考虑一个一维均匀网格，该网格在区间 $[0,1]$ 上定义为 $x_i = i h$，其中 $i$ 为整数，网格间距为 $h = 1/N$。设 $f(x)$ 表示一个足够光滑的标量场，在计算核物理中，它可以表示在 $x=0$ 处具有反射边界的平板中的一维中子标量通量。反射边界通过诺伊曼(Neumann)边界条件 $f'(0)=0$ 来建模。为了在边界附近统一应用标准的二阶中心差分，引入一个位于 $x_{-1} = -h$ 的虚拟单元(ghost cell)，其值 $f_{-1}$ 将通过外插法确定，以使离散格式与 $f'(0)=0$ 一致。\n\n从导数的基本定义 $f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}$ 出发，并使用 $f(h)$ 和 $f(-h)$ 在 $x=0$ 附近的泰勒(Taylor)级数展开（展开到足以评估截断误差的阶数），推导出一个外插公式。该公式用网格点上的值表示虚拟单元的值 $f_{-1}$，并以二阶精度强制满足诺伊曼(Neumann)边界条件 $f'(0)=0$。简要论证你所推导的外插法的精度阶数。\n\n推导出公式后，编写一个完整的程序，该程序：\n- 对于指定的整数 $N$，构造网格 $x_i = i h$（其中 $h = 1/N$），对一组测试函数 $f$ 计算 $f(x_i)$ 的值，并通过你推导的外插法计算虚拟单元的值 $f_{-1}$。\n- 使用标准的二阶中心差分公式来近似计算第一个内部点 $x=h$ 处的 $f'(x)$，即\n$$\n\\left.\\frac{df}{dx}\\right|_{x=h} \\approx \\frac{f(2h) - f(0)}{2h},\n$$\n并计算每个测试用例中相对于精确导数 $f'(h)$ 的绝对误差。\n- 使用虚拟单元的值，通过引用虚拟单元的中心差分公式来近似计算边界 $x=0$ 处的导数，\n$$\n\\left.\\frac{df}{dx}\\right|_{x=0} \\approx \\frac{f(h) - f(-h)}{2h},\n$$\n并检查此近似值是否在 $10^{-12}$ 的容差范围内满足诺伊曼(Neumann)边界条件 $f'(0)=0$。\n\n使用以下测试套件，其中三角函数的参数以弧度为单位：\n1. $f(x) = \\cos(\\pi x)$，其中 $N = 10$。\n2. $f(x) = e^{-x^2}$，其中 $N = 100$。\n3. $f(x) = 1 + x^4$，其中 $N = 2$。\n4. 边界情况：$f(x) = x$，其中 $N = 10$（此函数不满足 $f'(0)=0$；包含它是为了探究虚拟单元强制执行的行为）。\n\n对于每个测试用例，你的程序必须按以下顺序输出三个值：\n- $f'(h)$ 的中心差分近似值，作为浮点数。\n- 绝对误差 $\\left|\\text{approx} - f'(h)\\right|$，作为浮点数。\n- 一个布尔值，表示使用虚拟单元计算的 $x=0$ 处的边界导数近似值是否满足 $\\left|\\left.\\frac{df}{dx}\\right|_{x=0}\\right| \\le 10^{-12}$。\n\n最终输出格式：你的程序应生成单行输出，其中包含四个测试用例的所有结果，连接成一个用方括号括起来的逗号分隔列表。例如，输出应具有以下形式\n$[r_1,e_1,b_1,r_2,e_2,b_2,r_3,e_3,b_3,r_4,e_4,b_4]$,\n其中 $r_k$ 是浮点数，$e_k$ 是浮点数，$b_k$ 是对应于第 $k$ 个测试用例的布尔值。", "solution": "该问题是有效的。这是一个在数值分析领域中提法恰当、具有科学依据的问题，具体涉及使用虚拟单元技术为有限差分法实现诺伊曼(Neumann)边界条件。所有必要信息均已提供，任务是可形式化的，并且这是计算科学中的一个标准练习。\n\n### 第1部分：虚拟单元外插公式的推导\n\n核心任务是找到函数 $f(x)$ 在虚拟单元点 $x_{-1} = -h$（记为 $f_{-1}$）处的值的外插公式，以使诺伊曼(Neumann)边界条件 $f'(0)=0$ 达到二阶精度。我们使用标准二阶中心差分公式计算在边界 $x=0$ 处的一阶导数。\n\n对于一个足够光滑的函数 $f(x)$，其在点 $x=0$ 附近的泰勒(Taylor)级数展开为：\n$$\nf(x) = f(0) + x f'(0) + \\frac{x^2}{2!} f''(0) + \\frac{x^3}{3!} f'''(0) + \\dots\n$$\n在网格点 $x_1 = h$ 和 $x_{-1} = -h$ 处计算此展开式：\n$$\nf(h) = f(0) + h f'(0) + \\frac{h^2}{2} f''(0) + \\frac{h^3}{6} f'''(0) + O(h^4)\n$$\n$$\nf(-h) = f(0) - h f'(0) + \\frac{h^2}{2} f''(0) - \\frac{h^3}{6} f'''(0) + O(h^4)\n$$\n用第一个表达式减去第二个表达式，得到：\n$$\nf(h) - f(-h) = 2h f'(0) + \\frac{h^3}{3} f'''(0) + O(h^5)\n$$\n整理上式以形成 $f'(0)$ 的近似，得到对称中心差分公式：\n$$\n\\frac{f(h) - f(-h)}{2h} = f'(0) + \\frac{h^2}{6} f'''(0) + O(h^4)\n$$\n该公式以 $O(h^2)$ 的截断误差近似 $f'(0)$，使其成为一个二阶精度的格式。\n\n问题要求我们强制执行诺伊曼(Neumann)边界条件 $f'(0)=0$。使用虚拟单元实现此条件的标准方法是要求边界上导数的离散近似满足该条件。因此，我们将我们的离散算子设为零，该算子使用网格值 $f_1 = f(h)$ 和虚拟单元值 $f_{-1} = f(-h)$：\n$$\n\\frac{f_1 - f_{-1}}{2h} = 0\n$$\n求解虚拟单元值 $f_{-1}$，得到所需的外插公式：\n$$\nf_{-1} = f_1\n$$\n\n### 第2部分：精度论证\n\n问题要求论证此外插法以二阶精度强制执行该条件。其理由在于底层有限差分算子的精度。如上所述，中心差分算子 $\\frac{f(h) - f(-h)}{2h}$ 是真实导数 $f'(0)$ 的一个二阶精度近似。通过定义虚拟单元值 $f_{-1}$ 使该离散算子的计算结果恰好为零，我们实际上是用一种形式上为二阶精度的方法来强制执行条件 $f'(0)=0$。也就是说，如果我们不强制它为零，该方法将以 $O(h^2)$ 的速率收敛到真实导数。对于一个真正满足 $f'(0)=0$ 的函数，离散算子*应该*得到的值不是零，而是 $\\frac{h^2}{6}f'''(0)$。通过选择 $f_{-1}=f_1$ 将算子设置为零，我们在边界条件的表示中引入了一个与 $h^2$ 成正比的误差，这与二阶精度格式是一致的。\n\n### 第3部分：算法实现\n\n对于每个测试用例 $(f, f', N)$，程序将按以下步骤进行：\n1. 定义网格间距 $h = 1/N$。\n2. 计算所需网格点上的函数值：$f_0 = f(0)$、$f_1 = f(h)$ 和 $f_2 = f(2h)$。\n3. 应用推导出的外插公式求得虚拟单元值：$f_{-1} = f_1$。\n4. 使用指定的中心差分公式计算第一个内部点 $x=h$ 处的导数近似值：\n    $$\n    f'(h)_{\\text{approx}} = \\frac{f_2 - f_0}{2h}\n    $$\n5. 计算此近似值相对于精确导数 $f'(h)$ 的绝对误差。\n    $$\n    \\text{Error}_h = |f'(h)_{\\text{approx}} - f'(h)|\n    $$\n6. 使用包含虚拟单元的中心差分公式计算边界 $x=0$ 处的导数近似值：\n    $$\n    f'(0)_{\\text{approx}} = \\frac{f_1 - f_{-1}}{2h}\n    $$\n    使用我们的外插法，该值将精确为零。\n7. 验证此边界导数近似值的绝对值是否在指定的 $10^{-12}$ 容差范围内。\n    $$\n    |f'(0)_{\\text{approx}}| \\le 10^{-12}\n    $$\n每个测试用例的结果——在 $h$ 处的导数近似值、其误差以及在边界处的布尔值验证——被收集并格式化为单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of deriving and applying a ghost-cell extrapolation for a\n    Neumann boundary condition.\n    \"\"\"\n\n    # Define the test suite: a list of tuples, each containing:\n    # 1. The function f(x)\n    # 2. The exact derivative f'(x)\n    # 3. The number of grid intervals N\n    test_cases = [\n        (lambda x: np.cos(np.pi * x), lambda x: -np.pi * np.sin(np.pi * x), 10),\n        (lambda x: np.exp(-x**2), lambda x: -2 * x * np.exp(-x**2), 100),\n        (lambda x: 1.0 + x**4, lambda x: 4 * x**3, 2),\n        (lambda x: x, lambda x: 1.0, 10),\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-12\n\n    for f, f_prime, N in test_cases:\n        # 1. Construct grid and evaluate function at required points\n        h = 1.0 / N\n        x0, x1, x2 = 0.0, h, 2 * h\n        \n        f0 = f(x0)\n        f1 = f(x1)\n        f2 = f(x2)\n\n        # 2. Derive ghost-cell value using f_{-1} = f_1\n        # This formula enforces the discrete derivative (f_1 - f_{-1})/(2h) = 0\n        fm1 = f1\n\n        # 3. Compute the central-difference approximation of f'(h)\n        # Formula: (f(x+h) - f(x-h)) / (2h) evaluated at x=h.\n        # This is (f(2h) - f(0)) / (2h)\n        dfdx_h_approx = (f2 - f0) / (2 * h)\n\n        # 4. Compute the absolute error of the f'(h) approximation\n        dfdx_h_exact = f_prime(x1)\n        abs_error_h = np.abs(dfdx_h_approx - dfdx_h_exact)\n\n        # 5. Compute the boundary derivative at x=0 using the ghost cell\n        # Formula: (f(h) - f(-h)) / (2h)\n        # Using the ghost cell value, this is (f1 - fm1) / (2h)\n        dfdx_0_approx = (f1 - fm1) / (2 * h)\n\n        # 6. Check if the boundary condition is satisfied to within tolerance\n        boundary_check = np.abs(dfdx_0_approx) = TOLERANCE\n        \n        # Append the three required results for this test case\n        all_results.append(dfdx_h_approx)\n        all_results.append(abs_error_h)\n        all_results.append(boundary_check)\n\n    # Final print statement in the exact required format.\n    # The output format is a single line with a flat list of results.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3576260"}, {"introduction": "从薛定谔方程到扩散问题，核物理中的许多核心问题都涉及拉普拉斯算符 $\\nabla^2$，而非简单的一阶导数。此练习将一维中心差分公式推广至三维，构建用于求解拉普拉斯算符的七点模板。然后，通过测量数值解与已知解析解之间的误差收敛率，来验证该离散格式的准确性。这项练习 [@problem_id:3576233] 是一个综合性实践，引导你从一维概念过渡到多维微分算符的构建与验证，这是计算物理模拟中的一个基本构成模块。", "problem": "您需要推导、实现并验证三维拉普拉斯算子的二阶精度有限差分离散格式，该格式使用七点格式。然后，您需要测量离散误差，并在网格加密的情况下验证其二阶收敛性。本练习的动机源于计算核物理中偏微分方程的计算处理，例如中子扩散或平均场方程，其中对拉普拉斯算子的精确且高效的近似至关重要。\n\n首先，从基本定义出发：一个足够光滑的标量场 $f(x,y,z)$ 的拉普拉斯算子是其非混合二阶偏导数之和，即 $\\nabla^{2} f = \\frac{\\partial^{2} f}{\\partial x^{2}} + \\frac{\\partial^{2} f}{\\partial y^{2}} + \\frac{\\partial^{2} f}{\\partial z^{2}}$。在一个结构化的笛卡尔网格上，沿 $x$、$y$ 和 $z$ 方向的均匀间距分别为 $h_{x}$、$h_{y}$ 和 $h_{z}$。七点格式近似仅使用坐标轴方向上最近邻的采样点。请使用 Taylor 级数展开为每个二阶导数推导出一个相容的、二阶精度的中心差分离散格式，然后将它们组合起来，形成一个作用于内部网格点的离散拉普拉斯算子。对于边界处理，通过在区域边界上对精确解析函数进行采样来施加狄利克雷边界条件。\n\n考虑光滑测试函数 $f(x,y,z) = \\sin x \\,\\cos y \\,\\exp z$，该函数代表了在核系统简化模型中遇到的可分离的角度和径向依赖关系。角度必须以弧度为单位。请解析地推导该函数 $f$ 的精确拉普拉斯算子 $\\nabla^{2} f$，并将其用作评估离散误差的参考。\n\n在内部网格上定义离散 $L^{2}$ 误差范数如下。设域为一个矩形盒子 $[0,L_{x}]\\times[0,L_{y}]\\times[0,L_{z}]$，在每个方向上由 $N_{x}$、$N_{y}$、$N_{z}$ 个网格点（包括边界）划分，其中 $h_{x} = L_{x}/(N_{x}-1)$，$h_{y} = L_{y}/(N_{y}-1)$，$h_{z} = L_{z}/(N_{z}-1)$。令 $\\mathcal{I}$ 表示内部索引 $(i,j,k)$ 的集合，其中 $1 \\le i \\le N_{x}-2$，$1 \\le j \\le N_{y}-2$，$1 \\le k \\le N_{z}-2$。如果 $\\mathcal{L}_{h} f$ 表示应用于 $f$ 的网格采样的离散拉普拉斯算子，而 $(\\nabla^{2}f)_{\\text{exact}}$ 表示在网格节点上计算的精确解析拉普拉斯算子，则定义\n$$\nE_{2}(h_{x},h_{y},h_{z}) \\equiv \\left( \\sum_{(i,j,k)\\in \\mathcal{I}} \\left[ \\mathcal{L}_{h} f - (\\nabla^{2}f)_{\\text{exact}} \\right]^{2} \\, h_{x} h_{y} h_{z} \\right)^{1/2}.\n$$\n通过将每个坐标方向上的网格加密两倍（即每个间距减半）来验证二阶收敛性。给定一个基础网格 $(N_{x},N_{y},N_{z})$，定义加密后的网格为 $(N'_{x},N'_{y},N'_{z})$，其中\n$$\nN'_{x} = 2\\,(N_{x}-1) + 1,\\quad N'_{y} = 2\\,(N_{y}-1) + 1,\\quad N'_{z} = 2\\,(N_{z}-1) + 1,\n$$\n使得 $h'_{x} = h_{x}/2$，$h'_{y} = h_{y}/2$，$h'_{z} = h_{z}/2$。对于每个测试用例，计算观测到的收敛阶\n$$\np \\equiv \\log_{2} \\left( \\frac{E_{2}(h_{x},h_{y},h_{z})}{E_{2}(h'_{x},h'_{y},h'_{z})} \\right).\n$$\n\n实现一个完整、可运行的程序，该程序能够：\n- 构建网格，并在所有节点上计算 $f$ 和 $(\\nabla^{2}f)_{\\text{exact}}$。\n- 通过将 $f$ 的边界值设置为精确的 $f$ 值来施加狄利克雷边界条件。\n- 仅对内部节点应用您的七点离散拉普拉斯算子 $\\mathcal{L}_{h}$。\n- 为每个测试用例计算 $E_{2}(h_{x},h_{y},h_{z})$ 和 $E_{2}(h'_{x},h'_{y},h'_{z})$。\n- 报告每个测试用例的观测收敛阶 $p$。\n\n角度必须以弧度为单位。除了声明角度以弧度为单位外，不需要进行任何物理单位转换。\n\n使用以下测试套件来检验一般情况和边界情况的行为：\n- 测试用例 A (理想情况，类立方体网格): $L_{x}=\\pi$, $L_{y}=\\pi/2$, $L_{z}=1$，基础网格为 $(N_{x},N_{y},N_{z})=(17,17,17)$，加密后为 $(33,33,33)$。\n- 测试用例 B (各向异性间距和非立方体网格点数): $L_{x}=\\pi$, $L_{y}=\\pi$, $L_{z}=1/2$，基础网格为 $(N_{x},N_{y},N_{z})=(18,14,10)$，加密后为 $(35,27,19)$。\n- 测试用例 C (中等尺寸、强各向异性区域范围): $L_{x}=2$, $L_{y}=1$, $L_{z}=1/4$，基础网格为 $(N_{x},N_{y},N_{z})=(5,7,9)$，加密后为 $(9,13,17)$。\n\n您的程序必须生成单行输出，其中包含三个测试用例（按 A, B, C 顺序）的观测收敛阶 $p$，形式为方括号内以逗号分隔的列表。为了可复现性和比较，请将报告的每个 $p$ 值四舍五入到 $6$ 位小数。例如，输出格式必须是\n$$\n[\\text{p\\_A},\\text{p\\_B},\\text{p\\_C}]\n$$\n的形式，其中每个条目都是小数点后有 $6$ 位数字的浮点数。", "solution": "该问题要求对三维拉普拉斯算子 $\\nabla^2$ 推导、实现并验证一个二阶精度的有限差分格式。验证将通过测量一个已知光滑函数的离散误差的收敛率来执行。\n\n### 1. 七点有限差分格式的推导\n\n标量场 $f(x,y,z)$ 的拉普拉斯算子定义为 $\\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}$。我们寻求在笛卡尔网格上对该算子进行离散近似，网格点为 $(x_i, y_j, z_k)$，其中对于均匀网格间距 $h_x, h_y, h_z$，有 $x_i = i h_x$，$y_j = j h_y$，$z_k = k h_z$。\n\n该方法的核心是二阶导数的中心差分近似。考虑一维函数 $u(x)$。其在点 $x$ 附近的 Taylor 级数展开为：\n$$ u(x+h) = u(x) + h u'(x) + \\frac{h^2}{2!} u''(x) + \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) + O(h^5) $$\n$$ u(x-h) = u(x) - h u'(x) + \\frac{h^2}{2!} u''(x) - \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) - O(h^5) $$\n将这两个表达式相加可以消除奇数次幂的导数项：\n$$ u(x+h) + u(x-h) = 2u(x) + h^2 u''(x) + \\frac{h^4}{12} u^{(4)}(x) + O(h^6) $$\n求解 $u''(x)$ 可得：\n$$ u''(x) = \\frac{u(x+h) - 2u(x) + u(x-h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x) + O(h^4) $$\n有限差分近似是右侧的第一项。截断误差为 $-\\frac{h^2}{12}u^{(4)}(x) + O(h^4)$，其阶数为 $O(h^2)$。因此，该近似是二阶精度的。\n\n为了离散化三维拉普拉斯算子，我们将此公式应用于每个二阶偏导数。令 $f_{i,j,k} = f(x_i, y_j, z_k)$。\n$$ \\left.\\frac{\\partial^2 f}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k}}{h_x^2} $$\n$$ \\left.\\frac{\\partial^2 f}{\\partial y^2}\\right|_{i,j,k} \\approx \\frac{f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k}}{h_y^2} $$\n$$ \\left.\\frac{\\partial^2 f}{\\partial z^2}\\right|_{i,j,k} \\approx \\frac{f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1}}{h_z^2} $$\n在网格点 $(i,j,k)$ 处的离散拉普拉斯算子，记为 $\\mathcal{L}_h f$，是这些近似值的总和：\n$$ (\\mathcal{L}_h f)_{i,j,k} = \\frac{f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k}}{h_x^2} + \\frac{f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k}}{h_y^2} + \\frac{f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1}}{h_z^2} $$\n该公式被称为七点格式，因为它涉及中心点及其沿坐标轴的六个最近邻点的值。总截斷误差的阶数为 $O(h_x^2, h_y^2, h_z^2)$，这证实了该格式是二阶精度的。\n\n### 2. 测试函数的解析拉普拉斯算子\n\n为了评估我们的离散算子的准确性，我们需要一个已知其精确拉普拉斯算子的测试函数。问题指定了函数 $f(x,y,z) = \\sin x \\, \\cos y \\, e^z$。我们解析地计算其二阶偏导数：\n$$ \\frac{\\partial f}{\\partial x} = \\cos x \\, \\cos y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial x^2} = -\\sin x \\, \\cos y \\, e^z = -f(x,y,z) $$\n$$ \\frac{\\partial f}{\\partial y} = -\\sin x \\, \\sin y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial y^2} = -\\sin x \\, \\cos y \\, e^z = -f(x,y,z) $$\n$$ \\frac{\\partial f}{\\partial z} = \\sin x \\, \\cos y \\, e^z \\quad \\implies \\quad \\frac{\\partial^2 f}{\\partial z^2} = \\sin x \\, \\cos y \\, e^z = f(x,y,z) $$\n将这些项相加，得到精确的解析拉普拉斯算子：\n$$ (\\nabla^2 f)_{\\text{exact}} = (-f) + (-f) + (f) = -f(x,y,z) = -\\sin x \\, \\cos y \\, e^z $$\n这个解析结果作为衡量我们数值近似误差的基准（ground truth）。\n\n### 3. 误差测量与收敛阶\n\n近似的质量通过离散 $L^2$ 误差范数来量化，该范数是在内部网格点集合 $\\mathcal{I}$ 上计算的。误差定义为：\n$$ E_{2}(h_{x},h_{y},h_{z}) = \\left( \\sum_{(i,j,k)\\in \\mathcal{I}} \\left[ (\\mathcal{L}_{h} f)_{i,j,k} - (\\nabla^{2}f)_{\\text{exact},i,j,k} \\right]^{2} \\, h_{x} h_{y} h_{z} \\right)^{1/2} $$\n对于一个二阶精度的格式，误差 $E_2$ 预期与网格间距的平方成正比。即，对于某个常数 $C$ 和特征网格间距 $h$，有 $E_2(h) \\approx C h^2$。如果我们通过将间距减半（$h' = h/2$）来加密网格，新的误差应为 $E_2(h') \\approx C (h/2)^2 = E_2(h)/4$。因此，误差之比将为 $E_2(h)/E_2(h') \\approx 4$。\n\n观测到的收敛阶 $p$ 由此比率计算得出：\n$$ p = \\log_{2} \\left( \\frac{E_{2}(h)}{E_{2}(h')} \\right) $$\n对于二阶格式，我们预期 $p \\approx \\log_2(4) = 2$。数值实验将针对几种网格配置计算 $p$ 值，以验证这一理论预测。\n\n### 4. 实现设计\n\n实现过程将对每个测试用例遵循一个系统化的步骤。一个单独的计算例程将负责为给定的域、网格尺寸和测试函数计算 $L^2$ 误差。\n1.  **网格生成**：对于尺寸为 $[0,L_x] \\times [0,L_y] \\times [0,L_z]$ 的域和网格点数 $(N_x, N_y, N_z)$，网格间距为 $h_x = L_x/(N_x-1)$，$h_y = L_y/(N_y-1)$，$h_z = L_z/(N_z-1)$。使用 `numpy.meshgrid` 并设置 `indexing='ij'` 来生成三维坐标数组 `X`、`Y`、`Z`，以与 $(i,j,k)$ 索引约定保持一致。\n2.  **函数求值**：在网格上的每个点计算解析测试函数 $f(x,y,z)$ 及其精确拉普拉斯算子 $(\\nabla^2 f)_{\\text{exact}} = -f(x,y,z)$，从而得到数组 `F` 和 `Lap_F_exact`。用精确值填充 `F` 数组隱式地施加了所要求的狄利克雷边界条件。\n3.  **离散拉普拉斯算子计算**：将七点格式应用于 `F` 数组的内部点。这可以通过使用向量化的 `numpy` 数组切片来高效执行。例如，对所有内部点同时计算 $(f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/h_x^2$ 这一项。三个方向导数近似值的总和即为离散拉普拉斯算子数组 `Lap_F_discrete`。\n4.  **误差计算**：通过计算 `Lap_F_discrete` 与 `Lap_F_exact` 相应内部点之间的逐元素差值，将结果平方，对所有内部点求和，乘以体积元 $h_x h_y h_z$，然后取平方根，来计算 $L^2$ 误差范数。\n\n首先对基础网格 $(N_x, N_y, N_z)$ 执行整个过程以求得 $E_2(h)$，然后对加密后的网格 $(N'_x, N'_y, N'_z)$ 再次执行该过程以求得 $E_2(h')$。最后，根据这两个误差值计算观测到的收敛阶 $p$。对每个指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and verifies a second-order accurate finite-difference \n    discretization of the 3D Laplacian, measuring convergence order.\n    \"\"\"\n    \n    test_cases = [\n        # Test case A: Happy path, cubic-ish grid\n        {\n            \"name\": \"A\",\n            \"L_xyz\": (np.pi, np.pi / 2.0, 1.0),\n            \"N_base\": (17, 17, 17)\n        },\n        # Test case B: Anisotropic spacings and non-cubic counts\n        {\n            \"name\": \"B\",\n            \"L_xyz\": (np.pi, np.pi, 0.5),\n            \"N_base\": (18, 14, 10)\n        },\n        # Test case C: Moderate, strongly anisotropic domain extents\n        {\n            \"name\": \"C\",\n            \"L_xyz\": (2.0, 1.0, 0.25),\n            \"N_base\": (5, 7, 9)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L_xyz = case[\"L_xyz\"]\n        N_base = case[\"N_base\"]\n\n        def compute_l2_error(domain_lengths, grid_points):\n            \"\"\"\n            Computes the discrete L2 error of the 7-point Laplacian stencil.\n\n            Args:\n                domain_lengths (tuple): (Lx, Ly, Lz) of the domain.\n                grid_points (tuple): (Nx, Ny, Nz) number of points in each dimension.\n\n            Returns:\n                float: The computed L2 error norm.\n            \"\"\"\n            Lx, Ly, Lz = domain_lengths\n            Nx, Ny, Nz = grid_points\n\n            # Ensure grid points allow for interior points\n            if any(n  3 for n in grid_points):\n                raise ValueError(\"Grid must have at least 3 points in each dimension for an interior.\")\n\n            # Calculate grid spacings\n            hx = Lx / (Nx - 1)\n            hy = Ly / (Ny - 1)\n            hz = Lz / (Nz - 1)\n            \n            # Create grid coordinates\n            x_vec = np.linspace(0.0, Lx, Nx)\n            y_vec = np.linspace(0.0, Ly, Ny)\n            z_vec = np.linspace(0.0, Lz, Nz)\n            X, Y, Z = np.meshgrid(x_vec, y_vec, z_vec, indexing='ij')\n\n            # Evaluate the test function and its exact Laplacian on the grid\n            # f(x,y,z) = sin(x) * cos(y) * exp(z)\n            # ∇²f = -f(x,y,z)\n            F = np.sin(X) * np.cos(Y) * np.exp(Z)\n            lap_F_exact = -F\n\n            # Apply the 7-point stencil to compute the discrete Laplacian on interior points\n            # F[i, j, k] corresponds to (x_i, y_j, z_k)\n            F_ijk  = F[1:-1, 1:-1, 1:-1]\n            \n            term_x = (F[2:, 1:-1, 1:-1] - 2 * F_ijk + F[:-2, 1:-1, 1:-1]) / hx**2\n            term_y = (F[1:-1, 2:, 1:-1] - 2 * F_ijk + F[1:-1, :-2, 1:-1]) / hy**2\n            term_z = (F[1:-1, 1:-1, 2:] - 2 * F_ijk + F[1:-1, 1:-1, :-2]) / hz**2\n            \n            lap_F_discrete = term_x + term_y + term_z\n\n            # Isolate the exact Laplacian on the same interior grid\n            lap_F_exact_interior = lap_F_exact[1:-1, 1:-1, 1:-1]\n\n            # Calculate the L2 error norm on the interior\n            diff_sq = (lap_F_discrete - lap_F_exact_interior)**2\n            volume_element = hx * hy * hz\n            error_norm = np.sqrt(np.sum(diff_sq) * volume_element)\n            \n            return error_norm\n\n        # Compute error for the base grid\n        E_base = compute_l2_error(L_xyz, N_base)\n\n        # Define and compute error for the refined grid\n        Nx, Ny, Nz = N_base\n        N_refined = (2 * (Nx - 1) + 1, 2 * (Ny - 1) + 1, 2 * (Nz - 1) + 1)\n        E_refined = compute_l2_error(L_xyz, N_refined)\n        \n        # Calculate the observed order of convergence\n        # Handle the case where error is zero to avoid division by zero\n        if E_refined == 0.0:\n            p = np.inf if E_base > 0.0 else 2.0 # Or some other sensible value\n        else:\n            p = np.log2(E_base / E_refined)\n        results.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3576233"}]}