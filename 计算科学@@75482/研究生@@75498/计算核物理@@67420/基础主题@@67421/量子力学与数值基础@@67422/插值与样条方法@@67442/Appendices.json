{"hands_on_practices": [{"introduction": "在计算核物理中，许多物理量（如核密度和平均场势）在球坐标系中表示为径向函数。物理上的正则性要求这些函数在原点 $r=0$ 处是光滑且表现为 $r$ 的偶函数，这意味着它们的一阶导数在原点为零。本练习将指导您如何将这一基本的物理约束转化为三次样条插值的具体边界条件，这是确保数值解保持物理真实性的关键一步。[@problem_id:3566068]", "problem": "在计算核物理的球形平均场计算中，许多径向可观测量（例如，核子密度的$s$波分量或中心平均场势）在原点处是正则的。对于一个径向函数$f(r)$，物理正则性要求$f(r)$在$r=0$处是有限且光滑的，并且其在原点附近的领头阶行为是关于$r$的偶函数。一个被广泛观察到且经过充分检验的事实是，这类正则径向函数在小的$r$值下允许形式为$f(r)=f_{0}+a_{2}r^{2}+a_{4}r^{4}+\\cdots$的泰勒展开，其中$f_{0}$以及系数$a_{2},a_{4},\\dots$是有限的。\n\n假设$f(r)$在一个均匀的径向网格$r_{0}=0$, $r_{1}=h$, $r_{2}=2h$, $\\dots$（其中$h>0$）上被制成表格，并令$f_{i}=f(r_{i})$。您希望在$[0,R]$上构造一个二次连续可微的三次样条插值函数$s(r)$，该函数穿过表格中的数值点，并在原点处强制施加物理正则性约束。令$M_{i}=s''(r_{i})$表示样条函数在节点处的（未知）二阶导数。\n\n在第一个区间$[r_{0},r_{1}]$上，通过标准三次样条构造定义三次多项式段$s_{0}(r)$：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0}) .\n$$\n\n从物理正则性基础$f(r)=f_{0}+O(r^{2})$和上述三次样条的定义出发，推导在$r=0$处强制插值函数满足正则性的夹持边界条件，并将其简化为$M_{0}$关于$h$, $f_{0}$, $f_{1}$, 和$M_{1}$的单个解析表达式。\n\n答案规格：\n- 以$M_{0}$关于$h$、$f_{0}$、$f_{1}$和$M_{1}$的单个闭式解析表达式的形式提供您的最终答案。\n- 最终表达式中不包含单位。\n- 无需进行数值四舍五入。", "solution": "该问题要求推导三次样条插值函数在原点$r=0$处强制施加物理正则性的边界条件。\n\n首先，我将形式化物理正则性条件。问题陈述了一个正则径向函数$f(r)$在原点附近允许形式为$f(r) = f_0 + a_2 r^2 + a_4 r^4 + \\cdots$的泰勒展开。这意味着该函数在原点附近是关于$r$的偶函数。这种偶性的一个直接推论是$f(r)$在$r=0$处的所有奇数阶导数都必须为零。最低阶的条件是关于一阶导数的。对级数逐项求导得到$f'(r) = 2a_2 r + 4a_4 r^3 + \\cdots$。在$r=0$处求值得到$f'(0) = 0$。\n\n任务指定从基础条件$f(r) = f_0 + O(r^2)$开始。这等价于陈述$\\lim_{r\\to 0} \\frac{f(r)-f_0}{r} = 0$，这正是$f'(0)=0$的定义，前提是假设$f(0)=f_0$。\n\n三次样条插值函数$s(r)$旨在近似$f(r)$的同时，尊重其基本性质。因此，为了强制施加正则性，样条函数必须在原点处满足其一阶导数的相同条件。这给出了夹持边界条件：\n$$\ns'(0) = 0\n$$\n由于样条函数至少是$C^1$的，其在节点$r_0=0$处的导数由第一个样条段$s_0(r)$的导数给出。因此，我们必须强制$s_0'(0)=0$。\n\n问题提供了在区间$[r_0, r_1]$（其中$r_0=0$且$r_1=h$）上的样条段$s_0(r)$的公式：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(r_{1}-r)^{3}+\\frac{M_{1}}{6h}(r-r_{0})^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(r_{1}-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(r-r_{0})\n$$\n代入$r_0=0$和$r_1=h$：\n$$\ns_{0}(r)=\\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r\n$$\n为了应用边界条件，我们首先计算$s_0(r)$关于$r$的导数：\n$$\ns_{0}'(r) = \\frac{d}{dr} \\left[ \\frac{M_{0}}{6h}(h-r)^{3}+\\frac{M_{1}}{6h}r^{3}+\\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(h-r)+\\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)r \\right]\n$$\n使用幂法则和链式法则进行微分：\n$$\ns_{0}'(r) = \\frac{M_{0}}{6h} \\cdot 3(h-r)^{2}(-1) + \\frac{M_{1}}{6h} \\cdot 3r^{2}(1) + \\left(\\frac{f_{0}}{h}-\\frac{M_{0}h}{6}\\right)(-1) + \\left(\\frac{f_{1}}{h}-\\frac{M_{1}h}{6}\\right)(1)\n$$\n简化表达式：\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} - \\frac{f_{0}}{h} + \\frac{M_{0}h}{6} + \\frac{f_{1}}{h} - \\frac{M_{1}h}{6}\n$$\n这可以重排为：\n$$\ns_{0}'(r) = -\\frac{M_{0}}{2h}(h-r)^{2} + \\frac{M_{1}}{2h}r^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\n现在，我们在原点$r=0$处计算该导数的值：\n$$\ns_{0}'(0) = -\\frac{M_{0}}{2h}(h-0)^{2} + \\frac{M_{1}}{2h}(0)^{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{h}{6}(M_{0}-M_{1})\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h^2}{2h} + 0 + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -\\frac{M_{0}h}{2} + \\frac{f_{1}-f_{0}}{h} + \\frac{M_{0}h}{6} - \\frac{M_{1}h}{6}\n$$\n合并含有$M_0$的项：\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h}{6} - \\frac{h}{2}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = M_{0}\\left(\\frac{h-3h}{6}\\right) + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{2h}{6} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n$$\ns_{0}'(0) = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n应用正则性条件$s'(0) = s_0'(0) = 0$：\n$$\n0 = -M_{0}\\frac{h}{3} + \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n最后一步是解这个关于$M_0$的方程，以获得所需的解析表达式。\n$$\nM_{0}\\frac{h}{3} = \\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\n$$\n两边同乘以$\\frac{3}{h}$：\n$$\nM_{0} = \\frac{3}{h}\\left(\\frac{f_{1}-f_{0}}{h} - \\frac{M_{1}h}{6}\\right)\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{3M_{1}h}{6h}\n$$\n$$\nM_{0} = \\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}\n$$\n这就是样条函数在原点处的二阶导数$M_0$的解析表达式，用网格间距$h$、函数值$f_0$和$f_1$以及下一个网格点处的二阶导数$M_1$表示。该关系式作为在$r=0$处的夹持边界条件，用以强制施加物理正则性。", "answer": "$$\\boxed{\\frac{3(f_{1}-f_{0})}{h^{2}} - \\frac{M_{1}}{2}}$$", "id": "3566068"}, {"introduction": "核物理中的相互作用势通常包含不同长度尺度的物理过程，例如短程的核力与长程的库仑力。在有限的数据点上精确地插值这类函数是一个常见的挑战。本练习通过一个实际的编码任务，让您量化比较均匀网格和对数网格这两种不同采样策略下三次样条插值的精度，从而深刻理解为多尺度问题选择合适坐标系的重要性。[@problem_id:3566085]", "problem": "您需要量化对数坐标映射如何影响三次样条插值的误差，该插值针对的是一个模拟了库仑修正核势中典型的近原点曲率的球对称势。考虑一个径向对称函数 $f(r)$，其中 $r$ 的单位为飞米（femtometer），该函数定义为一个有限尺寸电荷的库仑势和一个伍兹-撒克逊 (Woods–Saxon, WS) 核势之和。库仑分量由一个半径为 $R_C$ 的均匀带电球体建模，因此 $V_C(r)$ 由下式给出\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right),  r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r},  r > R_C,\n\\end{cases}\n$$\n其中 $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$，$Z$ 等于入射粒子和靶核电荷的乘积 $Z_1 Z_2$，且 $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964$ $\\mathrm{MeV \\cdot fm}$。伍兹-撒克逊核势定义为\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)},\n$$\n其中深度 $V_0$ 的单位为兆电子伏（mega-electron-volt），核半径 $R_N$ 的单位为飞米，弥散度 $a$ 的单位为飞米。总势为 $f(r) = V_C(r) + V_N(r)$，以兆电子伏表示。\n\n必须构建两种插值方案：\n- 方案 $\\mathrm{A}$：使用在 $r \\in [0, r_{\\max}]$ 的均匀网格上采样的 $N$ 个样本进行三次样条插值。\n- 方案 $\\mathrm{B}$：使用在对数坐标 $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$ 上，于区间 $x \\in \\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$ 内均匀采样的 $N$ 个样本进行三次样条插值，并通过 $r = r_0\\left(e^x - 1\\right)$ 映射回 $r$ 坐标。\n\n对于这两种方案，样条函数都是在物理坐标 $r$ 中构建的，并在 $r \\in [0, r_{\\max}]$ 区间内一个包含 $M$ 个点的稠密均匀网格上进行评估（$M$ 的选择需足够大以具有代表性）。方案 $\\mathrm{A}$ 的插值误差为\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|,\n$$\n方案 $\\mathrm{B}$ 的插值误差为\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|,\n$$\n其中 $S_A$ 和 $S_B$ 分别是对应的三次样条插值函数，$\\{r_i\\}$ 是评估点。对数映射的效果通过误差减小因子来量化\n$$\nR = \\frac{E_A}{E_B}.\n$$\n\n您必须实现一个完整的、可运行的程序，为下面这套参数集计算 $E_A$、$E_B$ 和 $R$。所有能量和误差必须以兆电子伏（MeV）计算和报告。半径和长度的单位为飞米（fm）。评估网格大小为 $M = 1000$：\n- 测试 $1$（一般情况）：$Z = 20$, $R_C = 4.1$ $\\mathrm{fm}$, $R_N = 4.5$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 50$, $r_{\\max} = 20.0$ $\\mathrm{fm}$。\n- 测试 $2$（强库仑作用，较少样本）：$Z = 82$, $R_C = 7.1$ $\\mathrm{fm}$, $R_N = 7.0$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 0.5$ $\\mathrm{fm}$, $N = 30$, $r_{\\max} = 25.0$ $\\mathrm{fm}$。\n- 测试 $3$（弱库仑作用，核力主导）：$Z = 1$, $R_C = 1.0$ $\\mathrm{fm}$, $R_N = 1.2$ $\\mathrm{fm}$, $a = 0.5$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 1.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 15.0$ $\\mathrm{fm}$。\n- 测试 $4$（大映射尺度，近均匀采样）：$Z = 50$, $R_C = 5.6$ $\\mathrm{fm}$, $R_N = 5.6$ $\\mathrm{fm}$, $a = 0.6$ $\\mathrm{fm}$, $V_0 = 50$ $\\mathrm{MeV}$, $r_0 = 10.0$ $\\mathrm{fm}$, $N = 60$, $r_{\\max} = 20.0$ $\\mathrm{fm}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个三元组 $[E_A,E_B,R]$（单位为兆电子伏），最终输出是这些三元组按顺序组成的列表。例如，输出格式必须精确地像 $[[E_{A,1},E_{B,1},R_1],[E_{A,2},E_{B,2},R_2],[E_{A,3},E_{B,3},R_3],[E_{A,4},E_{B,4},R_4]]$。", "solution": "该问题要求对两种用于球对称核势的三次样条插值方案进行定量比较。总势 $f(r)$ 是一个来自有限尺寸电荷分布的库仑势 $V_C(r)$ 和一个伍兹-撒克逊核势 $V_N(r)$ 的和。目标是计算均匀径向网格（方案 A）和对数间隔径向网格（方案 B）的插值误差，并通过它们的比率来量化改进效果。\n\n首先，我们定义势函数 $f(r) = V_C(r) + V_N(r)$。所有能量单位为兆电子伏（$\\mathrm{MeV}$），距离单位为飞米（$\\mathrm{fm}$）。库仑分量 $V_C(r)$ 模拟了一个半径为 $R_C$ 的均匀带电球体。其函数形式是分段的：\n$$\nV_C(r) = \n\\begin{cases}\n\\displaystyle \\frac{k}{2 R_C}\\left(3 - \\frac{r^2}{R_C^2}\\right),  r \\le R_C, \\\\\n\\displaystyle \\frac{k}{r},  r > R_C,\n\\end{cases}\n$$\n参数 $k$ 由 $k = \\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) Z$ 给出，其中物理常数 $\\left(\\frac{e^2}{4\\pi \\varepsilon_0}\\right) \\approx 1.439964 \\, \\mathrm{MeV \\cdot fm}$。该势在边界 $r=R_C$ 处是连续的，并且其关于 $r$ 的一阶导数也是连续的。然而，其二阶导数 $\\frac{d^2V_C}{dr^2}$ 在 $r=R_C$ 处不连续。具体来说，对于 $r \\le R_C$，$\\frac{d^2V_C}{dr^2} = -\\frac{k}{R_C^3}$；对于 $r > R_C$，$\\frac{d^2V_C}{dr^2} = \\frac{2k}{r^3}$。在 $r=R_C$ 处的这种不连续性对高阶多项式插值方法（如三次样条插值）构成了挑战，因为这些方法通常假定函数具有更高的光滑度。\n\n核势 $V_N(r)$ 由标准的伍兹-撒克逊形式给出：\n$$\nV_N(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R_N}{a}\\right)}\n$$\n对于所有 $r>0$，该函数是无限次可微的（$C^\\infty$）。因此，总势 $f(r)$ 继承了其库仑分量的 $C^1$ 连续性和二阶导数的不连续性。\n\n接下来，我们建立两种插值方案。两种方案都使用 $N$ 个采样点来构建 $f(r)$ 在区间 $[0, r_{\\max}]$ 上的三次样条插值函数。\n\n方案 A 涉及在径向网格 $r \\in [0, r_{\\max}]$ 上均匀分布的 $N$ 个点上对势 $f(r)$ 进行采样。采样点为 $r_j = j \\cdot \\frac{r_{\\max}}{N-1}$，其中 $j=0, 1, \\dots, N-1$。使用数据对 $(r_j, f(r_j))$ 构建一个三次样条函数 $S_A(r)$。\n\n方案 B 使用一个在对数坐标 $x$ 中均匀的采样网格，该坐标由变换 $x = \\ln\\left(1 + \\frac{r}{r_0}\\right)$ 定义。这 $N$ 个采样点在区间 $\\left[0, \\ln\\left(1 + \\frac{r_{\\max}}{r_0}\\right)\\right]$ 内均匀选择。然后，通过逆变换 $r = r_0(e^x - 1)$ 将这些点映射回径向坐标。这产生了一组径向采样点 $\\{r_j'\\}$，这些点在原点（$r=0$）附近更密集，在 $r$ 较大处更稀疏。点的密度 $dN/dr$ 与 $(r_0+r)^{-1}$ 成正比。然后，使用数据对 $(r_j', f(r_j'))$ 构建一个三次样条函数 $S_B(r)$。这种非均匀分布旨在更好地捕捉势在原点附近的快速变化。\n\n为了评估每种方案的准确性，我们在区间 $[0, r_{\\max}]$ 内的一个包含 $M=1000$ 个点的稠密、均匀的评估网格 $\\{r_i\\}$ 上计算最大绝对误差。误差定义为：\n$$\nE_A = \\max_{i=1,\\dots,M} \\left| S_A(r_i) - f(r_i) \\right|\n$$\n$$\nE_B = \\max_{i=1,\\dots,M} \\left| S_B(r_i) - f(r_i) \\right|\n$$\n然后，通过误差减小因子 $R = E_A / E_B$ 来量化对数映射的效果。若 $R > 1$，则表明对于相同数量的采样点，对数采样网格比均匀网格提供了更精确的插值。\n\n实现将首先根据其参数定义一个用于计算势 $f(r)$ 的 Python 函数。对于每个测试用例，我们将为方案 A 和方案 B 生成两组采样点。使用 `scipy.interpolate.CubicSpline` 类，我们将构建插值函数 $S_A(r)$ 和 $S_B(r)$。最后，我们将在稠密网格上评估这些样条函数和精确函数，计算最大误差 $E_A$ 和 $E_B$，并计算它们的比率 $R$。对测试套件中提供的每个参数集重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'Z': 20, 'Rc': 4.1, 'Rn': 4.5, 'a': 0.6, 'V0': 50, 'r0': 1.0, 'N': 50, 'rmax': 20.0},\n        # Test 2 (strong Coulomb, fewer samples)\n        {'Z': 82, 'Rc': 7.1, 'Rn': 7.0, 'a': 0.5, 'V0': 50, 'r0': 0.5, 'N': 30, 'rmax': 25.0},\n        # Test 3 (weak Coulomb, nuclear-dominated)\n        {'Z': 1, 'Rc': 1.0, 'Rn': 1.2, 'a': 0.5, 'V0': 50, 'r0': 1.0, 'N': 60, 'rmax': 15.0},\n        # Test 4 (large mapping scale, near-uniform sampling)\n        {'Z': 50, 'Rc': 5.6, 'Rn': 5.6, 'a': 0.6, 'V0': 50, 'r0': 10.0, 'N': 60, 'rmax': 20.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(case)\n        results.append(result)\n\n    # Format the final output string as per the problem specification.\n    # [[E_A1,E_B1,R1],[E_A2,E_B2,R2],...]\n    output_str_parts = []\n    for res in results:\n        # Format each number to avoid excessively long floating point representations\n        e_a_str = f\"{res[0]:.10g}\"\n        e_b_str = f\"{res[1]:.10g}\"\n        r_str = f\"{res[2]:.10g}\"\n        output_str_parts.append(f\"[{e_a_str},{e_b_str},{r_str}]\")\n    \n    final_output = f\"[{','.join(output_str_parts)}]\"\n    print(final_output)\n\ndef _potential_function(r, func_params):\n    \"\"\"\n    Calculates the total potential f(r) = V_C(r) + V_N(r).\n    \n    Args:\n        r (np.ndarray or float): Radial coordinate(s) in fm.\n        func_params (dict): Dictionary of potential parameters.\n    \n    Returns:\n        np.ndarray or float: Total potential in MeV.\n    \"\"\"\n    k_const = 1.439964  # MeV * fm\n    Z, Rc, Rn, a, V0 = func_params['Z'], func_params['Rc'], func_params['Rn'], func_params['a'], func_params['V0']\n    \n    k = k_const * Z\n    \n    r_arr = np.atleast_1d(r)\n    \n    # Coulomb potential V_C(r) for a uniformly charged sphere\n    # Using np.where for vectorized piecewise calculation.\n    # This is safe as r > Rc ensures r is not zero for the second part.\n    vc_inside = (k / (2.0 * Rc)) * (3.0 - (r_arr**2 / Rc**2))\n    # Add a small epsilon to avoid division by zero at r=0 if it ever gets into this branch, which it shouldn't for r > Rc.\n    vc_outside = k / (r_arr + 1e-15)\n    Vc = np.where(r_arr = Rc, vc_inside, vc_outside)\n    \n    # Woods-Saxon nuclear potential V_N(r)\n    Vn = -V0 / (1.0 + np.exp((r_arr - Rn) / a))\n    \n    f_r = Vc + Vn\n    \n    return f_r[0] if isinstance(r, (int, float)) else f_r\n\ndef _solve_one_case(case_params):\n    \"\"\"\n    Performs the interpolation and error analysis for a single test case.\n    \"\"\"\n    N = case_params['N']\n    rmax = case_params['rmax']\n    r0 = case_params['r0']\n    M = 1000\n\n    func_params = {k: case_params[k] for k in ('Z', 'Rc', 'Rn', 'a', 'V0')}\n\n    # Dense evaluation grid for accurate error measurement\n    r_eval = np.linspace(0, rmax, M)\n    f_exact = _potential_function(r_eval, func_params)\n\n    # Scheme A: Cubic spline with uniform grid in r\n    r_samples_A = np.linspace(0, rmax, N)\n    y_samples_A = _potential_function(r_samples_A, func_params)\n    spline_A = CubicSpline(r_samples_A, y_samples_A)\n    f_spline_A = spline_A(r_eval)\n    E_A = np.max(np.abs(f_spline_A - f_exact))\n\n    # Scheme B: Cubic spline with logarithmic grid\n    x_max = np.log(1 + rmax / r0)\n    x_samples_B = np.linspace(0, x_max, N)\n    r_samples_B = r0 * (np.exp(x_samples_B) - 1)\n    \n    # CubicSpline needs strictly increasing points. Floating point arithmetic can\n    # occasionally create tiny non-monotonicities or duplicates, especially at r=0.\n    # A simple check and fix ensures robustness.\n    if len(r_samples_B) > 1 and r_samples_B[1] == r_samples_B[0]:\n        r_samples_B[1] = r_samples_B[0] + np.finfo(float).eps\n    \n    y_samples_B = _potential_function(r_samples_B, func_params)\n    spline_B = CubicSpline(r_samples_B, y_samples_B)\n    f_spline_B = spline_B(r_eval)\n    E_B = np.max(np.abs(f_spline_B - f_exact))\n\n    # Error reduction factor\n    R = E_A / E_B if E_B != 0 else np.inf\n\n    return [E_A, E_B, R]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3566085"}, {"introduction": "根据Wigner阈值定律，核反应截面或衰变宽度在反应阈能附近表现出非解析行为，这给多项式插值带来了巨大挑战。直接对这些量进行样条插值会导致较大误差。本练习将向您介绍一种先进且实用的技术：将已知的非解析物理行为（由穿透因子描述）从函数中分离出来，仅对剩余的光滑部分进行插值，这是一种将物理洞察力融入数值方案以实现高精度的有效方法。[@problem_id:3566057]", "problem": "你的任务是为一个核反应模型设计并实现一个基于三次样条的插值函数，用于描述随能量变化的偏衰变宽度，该插值函数需遵循维格纳阈值定律所规定的阈值行为。考虑一组以 $c$ 为索引的衰变道，每个衰变道都由一个轨道角动量量子数 $\\ell_c$ 和一个道阈值能量 $E_{\\mathrm{th},c}$ 来表征。对于中性出射粒子和短程相互作用，维格纳阈值定律断言，在阈值附近，衰变宽度 $\\Gamma_c(E)$ 与穿透率 $P_{\\ell_c}(E)$ 成正比，其中 $P_{\\ell}(E) \\propto k^{2\\ell+1}$，$k$ 是波数。在 $2\\mu/\\hbar^2 = 1$ 的单位制下，对于 $E \\ge E_{\\mathrm{th},c}$，有 $k = \\sqrt{E - E_{\\mathrm{th},c}}$，因此 $P_{\\ell}(E) \\propto (E - E_{\\mathrm{th},c})^{\\ell + 1/2}$。在本问题中，采用以下具体的中性粒子穿透率模型\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}},\n$$\n其中所有能量单位均为 $\\mathrm{MeV}$，且比例常数设为 $1$。\n\n你的目标是为每个道 $c$ 构建 $\\Gamma_c(E)$ 的三次样条插值函数 $S_c(E)$，该函数按以下方式强制实现正确的低能标度行为：\n- 对于 $E \\le E_{\\mathrm{th},c}$，设置 $S_c(E) = 0$（关闭道）。\n- 对于 $E  E_{\\mathrm{th},c}$，要求比值 $W_c(E) \\equiv S_c(E)/P_{\\ell_c}(E;E_{\\mathrm{th},c})$ 是在区间 $[E_{\\mathrm{th},c}+\\Delta,\\,E_{\\max,c}]$ 上关于 $E$ 的自然三次样条，其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$，并对训练数据进行拟合。等价地，通过给定节点 $\\{E_i\\}$ 处的训练数据纵坐标 $W_c(E_i) = \\Gamma_c(E_i)/P_{\\ell_c}(E_i;E_{\\mathrm{th},c})$ 为约化宽度函数 $W_c(E)$ 构建一个自然三次样条，然后对于 $E  E_{\\mathrm{th},c}$ 定义 $S_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E)$。\n\n为了使任务完全指定且可测试，请对每个道 $c$ 使用以下人工合成但物理上合理的基准真相模型：\n- 设真实的约化宽度函数为\n$$\nH_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big),\n$$\n并将真实的偏衰变宽度定义为\n$$\n\\Gamma_c^{\\mathrm{true}}(E) = \n\\begin{cases}\n0,  E \\le E_{\\mathrm{th},c},\\\\\nP_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E),  E  E_{\\mathrm{th},c}.\n\\end{cases}\n$$\n\n使用以下道的定义和参数（所有能量单位为 $\\mathrm{MeV}$，角度无量纲，且 $E_{\\max,c}$ 指定了训练和评估区间的上界）：\n- 道 $c=1$：$\\ell_1 = 0$，$E_{\\mathrm{th},1} = 0.1\\,\\mathrm{MeV}$，$E_{\\max,1} = 3.0\\,\\mathrm{MeV}$，$a_1 = 0.3$，$b_1 = 0.2$，$c_1 = 0.05$，$d_1 = 3.0$。\n- 道 $c=2$：$\\ell_2 = 1$，$E_{\\mathrm{th},2} = 1.0\\,\\mathrm{MeV}$，$E_{\\max,2} = 5.0\\,\\mathrm{MeV}$，$a_2 = 0.1$，$b_2 = 0.05$，$c_2 = 0.02$，$d_2 = 5.0$。\n- 道 $c=3$：$\\ell_3 = 2$，$E_{\\mathrm{th},3} = 0.0\\,\\mathrm{MeV}$，$E_{\\max,3} = 4.0\\,\\mathrm{MeV}$，$a_3 = 0.5$，$b_3 = 0.0$，$c_3 = 0.1$，$d_3 = 2.0$。\n\n所有道的训练数据规范：\n- 使用 $N_c = 8$ 个训练节点，这些节点在能量区间 $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$ 上均匀分布，其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$。将这些节点记为 $\\{E_{i,c}\\}_{i=1}^{N_c}$。\n- 训练数据纵坐标是这些节点上的 $\\Gamma_c^{\\mathrm{true}}(E_{i,c})$。\n\n程序要求：\n1. 对每个道 $c$，通过对训练数据点 $\\{(E_{i,c},\\,\\Gamma_c^{\\mathrm{true}}(E_{i,c})/P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}))\\}$ 上的 $W_c(E)$ 进行自然三次样条拟合，构建如上所述的样条约束插值函数 $S_c(E)$。\n2. 对每个道 $c$，在一个包含 $N_{\\mathrm{test}} = 200$ 个点的密集测试网格上评估插值函数和基准真相，该网格上的点在 $[E_{\\mathrm{th},c} + \\Delta,\\,E_{\\max,c}]$ 区间内均匀分布。定义最大相对误差\n$$\n\\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)},\n$$\n其中 $\\epsilon = 10^{-14}$ 用于在 $E \\downarrow E_{\\mathrm{th},c}$ 附近进行正则化。\n3. 对每个道 $c$，还需评估阈下值 $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$，其中 $\\delta = 10^{-6}\\,\\mathrm{MeV}$，根据构造，该值应恰好为 $0$。\n4. 你的程序必须按照下述确切格式，将六个数字 $[\\varepsilon_1,\\,\\varepsilon_2,\\,\\varepsilon_3,\\,B_1,\\,B_2,\\,B_3]$ 作为单行输出。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$。\n- 每个数值条目必须打印为四舍五入到8位小数的浮点值。\n- 在适用的情况下，能量单位必须是 $\\mathrm{MeV}$，但打印输出的 $\\varepsilon_c$ 是无量纲的，而 $B_c$ 的单位是 $\\mathrm{MeV}$（根据构造，后者预计为 $0.00000000$）。\n\n解决方案必须是一个无需读取任何输入的完整、可运行的程序，并且必须精确地实现上述构造。基准真相函数 $H_c(E)$ 和 $\\Gamma_c^{\\mathrm{true}}(E)$ 的内部定义必须与此处给出的规范相匹配。最终输出必须严格遵守所要求的单行格式。", "solution": "该问题要求构建并验证一个用于核偏衰变宽度 $\\Gamma_c(E)$ 的三次样条插值函数，该函数能正确地融合维格纳阈值定律所决定的道能量阈值 $E_{\\mathrm{th},c}$ 附近的物理行为。\n\n所述方法的核心原理是将待插值的函数 $\\Gamma_c(E)$ 分解为两个因子：一个是在阈值附近具有已知的非解析行为的部分，另一个是预期光滑且表现良好的剩余部分。对于具有轨道角动量 $\\ell_c$ 的中性出射粒子，维格纳阈值定律指出衰变宽度与穿透率因子成正比，即 $\\Gamma_c(E) \\propto P_{\\ell_c}(E)$。对于给定的 $2\\mu/\\hbar^2=1$ 模型，当 $E  E_{\\mathrm{th},c}$ 时，该穿透率为 $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = (E - E_{\\mathrm{th},c})^{\\ell_c + 1/2}$。问题为此因子定义了一个完整的模型：\n$$\nP_{\\ell}(E;E_{\\mathrm{th}}) = \\left[\\max\\left(E - E_{\\mathrm{th}},\\,0\\right)\\right]^{\\ell + \\tfrac{1}{2}}\n$$\n该函数捕捉了在 $E=E_{\\mathrm{th},c}$ 处的急剧开启行为，并且对于 $\\ell=0$ 的情况，其导数在阈值处是奇异的。由于这种非解析行为，直接对 $\\Gamma_c(E)$ 进行样条插值将是不准确的。\n\n策略是转而对由以下比值定义的“约化宽度”函数 $W_c(E)$ 进行插值：\n$$\nW_c(E) \\equiv \\frac{\\Gamma_c(E)}{P_{\\ell_c}(E;E_{\\mathrm{th},c})}\n$$\n预期函数 $W_c(E)$ 会比 $\\Gamma_c(E)$ 光滑得多，因此更适用于像三次样条这样基于多项式的插值方法。我们通过一组训练点为 $W_c(E)$ 构建一个自然三次样条，并将其表示为 $W_c(E)$ 的插值函数。然后，通过将约化宽度的样条插值函数与已知的穿透率因子相乘，来重构完整衰变宽度的最终插值函数 $S_c(E)$：\n$$\nS_c(E) = P_{\\ell_c}(E;E_{\\mathrm{th},c}) W_c(E) \\quad \\text{for } E  E_{\\mathrm{th},c}\n$$\n根据构造，对于 $E \\le E_{\\mathrm{th},c}$，我们有 $P_{\\ell_c}(E;E_{\\mathrm{th},c}) = 0$，因此我们定义 $S_c(E) = 0$，这正确地强制了阈值以下的道关闭。\n\n每个道 $c$ 的完整流程如下：\n\n1.  定义基准真相函数：问题提供了一个用于衰变宽度的人工合成“真实”模型，该模型用于生成训练数据并评估我们插值函数的准确性。真实的约化宽度函数由下式给出：\n    $$\n    H_c(E) = a_c + b_c\\,(E - E_{\\mathrm{th},c}) + c_c \\cos\\!\\big(d_c\\,(E - E_{\\mathrm{th},c})\\big)\n    $$\n    真实的偏衰变宽度则为：\n    $$\n    \\Gamma_c^{\\mathrm{true}}(E) = \n    \\begin{cases}\n    0,  E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,H_c(E),  E  E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    为三个不同的道提供了参数 $\\{a_c, b_c, c_c, d_c, \\ell_c, E_{\\mathrm{th},c}, E_{\\max,c}\\}$。\n\n2.  生成训练数据：对每个道 $c$，我们在能量区间 $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$ 上生成 $N_c = 8$ 个均匀分布的训练节点 $\\{E_{i,c}\\}_{i=1}^{N_c}$，其中 $\\Delta = 10^{-4}\\,\\mathrm{MeV}$。微小的偏移量 $\\Delta$ 对于避开 $P_{\\ell=0}(E)$ 导数为无穷大的点 $E=E_{\\mathrm{th},c}$ 至关重要。约化宽度样条对应的纵坐标为：\n    $$\n    y_{i,c} = \\frac{\\Gamma_c^{\\mathrm{true}}(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = \\frac{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c}) H_c(E_{i,c})}{P_{\\ell_c}(E_{i,c};E_{\\mathrm{th},c})} = H_c(E_{i,c})\n    $$\n    因此，我们对点集 $\\{(E_{i,c}, H_c(E_{i,c}))\\}$ 进行样条拟合。\n\n3.  构建自然三次样条：使用上一步的训练点，我们为 $W_c(E)$ 构建一个自然三次样条插值函数。自然样条有一个附加约束，即其二阶导数在区间端点处为零，当没有关于函数在边界处行为的其它信息时，这是一种常见的选择。\n\n4.  定义完整插值函数 $S_c(E)$：衰变宽度的最终插值函数由下式给出：\n    $$\n    S_c(E) = \n    \\begin{cases}\n    0,  E \\le E_{\\mathrm{th},c}\\\\\n    P_{\\ell_c}(E;E_{\\mathrm{th},c})\\,W_c(E),  E  E_{\\mathrm{th},c}\n    \\end{cases}\n    $$\n    其中 $W_c(E)$ 是在能量 $E$ 处求值的自然三次样条的值。\n\n5.  评估性能：\n    - 最大相对误差 $\\varepsilon_c$ 是在一个包含 $N_{\\mathrm{test}}=200$ 个点的密集网格 $[E_{\\mathrm{th},c} + \\Delta, E_{\\max,c}]$ 上计算的。误差定义为：\n      $$\n      \\varepsilon_c = \\max_{E \\in \\mathrm{grid}} \\frac{\\left|S_c(E) - \\Gamma_c^{\\mathrm{true}}(E)\\right|}{\\max\\!\\left(\\Gamma_c^{\\mathrm{true}}(E),\\,\\epsilon\\right)}\n      $$\n      其中 $\\epsilon = 10^{-14}$ 是一个正则化常数，用于防止在 $\\Gamma_c^{\\mathrm{true}}(E)$ 非常小的区域出现除以零的情况。\n    - 评估阈下值 $B_c = S_c(E_{\\mathrm{th},c} - \\delta)$（其中 $\\delta = 10^{-6}\\,\\mathrm{MeV}$）以确认插值方案能正确地将已关闭道的宽度设置为零。根据我们对 $S_c(E)$ 的构造，该值必须恰好为 $0$。\n\n实现将对三个指定的道分别执行这些步骤，并报告所得的六个值 $[\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, B_1, B_2, B_3]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating a cubic-spline-based\n    interpolant for nuclear decay widths that respects Wigner threshold laws.\n    \"\"\"\n    \n    # Define the problem parameters for each channel\n    channels = {\n        1: {'ell': 0, 'E_th': 0.1, 'E_max': 3.0, 'a': 0.3, 'b': 0.2, 'c': 0.05, 'd': 3.0},\n        2: {'ell': 1, 'E_th': 1.0, 'E_max': 5.0, 'a': 0.1, 'b': 0.05, 'c': 0.02, 'd': 5.0},\n        3: {'ell': 2, 'E_th': 0.0, 'E_max': 4.0, 'a': 0.5, 'b': 0.0, 'c': 0.1, 'd': 2.0}\n    }\n    \n    # Global constants from the problem statement\n    DELTA = 1e-4      # MeV, offset for training and evaluation domain\n    EPSILON = 1e-14   # Regularization for relative error\n    DELTA_B = 1e-6    # MeV, offset for below-threshold evaluation\n    N_TRAIN = 8       # Number of training knots\n    N_TEST = 200      # Number of test grid points\n\n    epsilon_results = []\n    b_results = []\n\n    for c in sorted(channels.keys()):\n        p = channels[c]\n        ell, E_th, E_max = p['ell'], p['E_th'], p['E_max']\n        a, b, c_param, d = p['a'], p['b'], p['c'], p['d']\n\n        # 1. Define the model functions\n        def P_ell(E, ell_val, E_th_val):\n            E_diff = np.maximum(E - E_th_val, 0)\n            return E_diff**(ell_val + 0.5)\n\n        def H_c(E, E_th_val, a_val, b_val, c_val, d_val):\n            return a_val + b_val * (E - E_th_val) + c_val * np.cos(d_val * (E - E_th_val))\n\n        def Gamma_true(E, ell_val, E_th_val, a_val, b_val, c_val, d_val):\n            E_arr = np.atleast_1d(E)\n            width = np.zeros_like(E_arr, dtype=float)\n            E_above_thresh = E_arr > E_th_val\n            \n            if np.any(E_above_thresh):\n                P_vals = P_ell(E_arr[E_above_thresh], ell_val, E_th_val)\n                H_vals = H_c(E_arr[E_above_thresh], E_th_val, a_val, b_val, c_val, d_val)\n                width[E_above_thresh] = P_vals * H_vals\n            return width\n\n        # 2. Generate Training Data\n        train_knots = np.linspace(E_th + DELTA, E_max, N_TRAIN)\n        train_ordinates_W = H_c(train_knots, E_th, a, b, c_param, d)\n\n        # 3. Construct Natural Cubic Spline for W_c(E)\n        W_c_spline = CubicSpline(train_knots, train_ordinates_W, bc_type='natural')\n        \n        # 4. Define the Full Interpolant S_c(E) for this channel\n        def S_c(E):\n            E_arr = np.atleast_1d(E)\n            y = np.zeros_like(E_arr, dtype=float)\n            mask_above = E_arr > E_th\n            \n            if np.any(mask_above):\n                E_above = E_arr[mask_above]\n                W_vals = W_c_spline(E_above)\n                P_vals = P_ell(E_above, ell, E_th)\n                y[mask_above] = P_vals * W_vals\n            return y\n\n        # 5. Evaluate Performance\n        \n        # a. Calculate maximum relative error epsilon_c\n        test_grid = np.linspace(E_th + DELTA, E_max, N_TEST)\n        S_c_on_grid = S_c(test_grid)\n        Gamma_true_on_grid = Gamma_true(test_grid, ell, E_th, a, b, c_param, d)\n        \n        denominator = np.maximum(Gamma_true_on_grid, EPSILON)\n        relative_errors = np.abs(S_c_on_grid - Gamma_true_on_grid) / denominator\n        epsilon_c = np.max(relative_errors)\n        epsilon_results.append(epsilon_c)\n        \n        # b. Calculate below-threshold value B_c\n        B_c = S_c(np.array([E_th - DELTA_B]))[0]\n        b_results.append(B_c)\n        \n    final_results = epsilon_results + b_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{x:.8f}' for x in final_results])}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3566057"}]}