{"hands_on_practices": [{"introduction": "在着手进行任何实际的相互作用玻色子模型（IBM）计算之前，首要任务是构建正确的量子多体希尔伯特空间。本练习将指导您完成这一基本步骤，重点关注由 $d$ 玻色子构成的系统。您将学习如何以数值方式构建完全对称的多玻色子基，即所谓的 $m$-方案，并在此基础上构造总角动量算符。通过构建并对角化总角动量平方算符 $J^2$ 的矩阵表示，您可以确定 $N$ 玻色子系统的角动量谱，这是理解原子核结构对称性的关键一步。[@problem_id:3576636]", "problem": "您正在为一个仅由 $d$-玻色子张成的子空间中的相互作用玻色子模型 (IBM) 哈密顿量实现一个数值程序。每个 $d$-玻色子携带单玻色子角动量 $l=2$，其磁亚态为 $m \\in \\{-2,-1,0,1,2\\}$。对于固定的玻色子数 $N$，多玻色子希尔伯特空间是单玻色子空间的 $N$ 次张量积的完全对称子空间。您的任务是通过在二次量子化中构建总角动量算符来构造该空间的 $J$-耦合内容，并计算对于选定的 $N$ 值，总角动量 $J=0$ 的简并度（线性无关态的数量）。\n\n从以下基础开始：\n- 玻色子产生和湮灭算符 $b^\\dagger_m$ 和 $b_m$ 满足正则对易关系 $[b_m, b^\\dagger_{m'}] = \\delta_{m m'}$ 和 $[b_m, b_{m'}] = [b^\\dagger_m, b^\\dagger_{m'}] = 0$。\n- 对于 $l=2$，$m$ 基矢上的单粒子角动量算符表示为\n  $J_z \\ket{m} = m \\ket{m}$，$J_+ \\ket{m} = \\sqrt{l(l+1) - m(m+1)} \\ket{m+1}$，以及 $J_- \\ket{m} = \\sqrt{l(l+1) - m(m-1)} \\ket{m-1}$，其中 $l=2$ 且 $m \\in \\{-2,-1,0,1,2\\}$。\n- 在二次量子化中，多体总角动量生成元为\n  $$J_z = \\sum_{m=-2}^{2} m \\, b^\\dagger_m b_m, \\quad J_+ = \\sum_{m=-2}^{1} \\sqrt{l(l+1) - m(m+1)} \\, b^\\dagger_{m+1} b_m, \\quad J_- = J_+^\\dagger.$$\n- Casimir 算符可以构造为\n  $$J^2 = J_- J_+ + J_z(J_z + \\mathbb{1}).$$\n  其本征值为 $J(J+1)$，其中 $J \\ge 0$ 为整数，且 $J=0$ 的简并度等于零本征值的数量。\n\n实现以下内容：\n1. 在 $m$ 表象中，将固定 $N$ 值的玻色子 Fock 基构造为整数占据数元组 $(n_{-2}, n_{-1}, n_{0}, n_{1}, n_{2})$，其中 $\\sum_m n_m = N$。这自动满足了完全的玻色子对称化要求。\n2. 使用玻色子作用 $b^\\dagger_p b_q \\ket{\\{n_m\\}} = \\sqrt{n_q} \\sqrt{n_p + 1} \\ket{\\{n_m + \\delta_{m p} - \\delta_{m q}\\}}$ 以及上述为 $l=2$ 指定的系数，在此基上构建 $J_z$、$J_+$ 和 $J_-$ 的稠密矩阵表示。\n3. 构建 $J^2$ 并将其对角化，以获得固定 $N$ 希尔伯特空间上的所有本征值。根据这些本征值，计算 $J=0$ 态的数量，即在指定的数值容差 $\\varepsilon$ 内等于 $0$ 的本征值的计数。\n4. 使用严格的容差 $\\varepsilon = 10^{-8}$ 来判断一个本征值是否对应于 $J=0$；即，计算那些满足 $|\\lambda|  \\varepsilon$ 的 $\\lambda$ 的数量。\n\n您必须生成一个单一的程序，对于下面每个测试值 $N$，计算完全对称的 $N$ 个 $d$-玻色子希尔伯特空间中 $J=0$ 的整数简并度。\n\n测试集（涵盖边界、典型和边缘情况）：\n- $N = 0$ (边界情况，真空)\n- $N = 1$ (单 $d$-玻色子)\n- $N = 2$ (对耦合)\n- $N = 3$ ($d$-玻色子数量为奇数)\n- $N = 4$ (此任务的主要目标)\n- $N = 5$ (数量为奇数，更大的空间)\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试集相同。例如，打印一行形式为 $[r_0,r_1,r_2,r_3,r_4,r_5]$ 的内容，其中每个 $r_i$ 是对应 $N$ 的整数计数。\n- 本问题不涉及单位。\n- 任何角度（如果存在）都隐含在表示论中，不需要明确的单位。\n\n重要约束：\n- 实现必须是自包含的，无需用户输入，并且在判断 $J=0$ 简并度时必须遵守指定的数值容差 $\\varepsilon = 10^{-8}$。\n- 程序必须为每个指定的 $N$ 构建并对角化 $J^2$，并将结果汇总为指定的单行输出。", "solution": "该问题要求计算一个由 $N$ 个相互作用的 $d$-玻色子组成的系统中，总角动量 $J=0$ 态的简并度。每个 $d$-玻色子具有内禀角动量 $l=2$。计算针对指定的 $N$ 值进行。该方法涉及在固定的 $N$-玻色子希尔伯特空间内，构建并对角化总角动量平方算符 $J^2$ 的矩阵表示。\n\n**1. 希尔伯特空间构造**\n该系统由 $N$ 个全同玻色子组成，每个玻色子可以占据由 $m \\in \\{-2, -1, 0, 1, 2\\}$ 标记的 $2l+1 = 5$ 个磁亚态之一。对于固定的玻色子数 $N$，多体希尔伯特空间由一组 Fock 态张成，这组态也称为 $m$ 表象基。这些态用占据数矢量 $\\ket{\\psi_i} = \\ket{n_{-2}, n_{-1}, n_0, n_1, n_2}$ 表示，其中 $n_m$ 是在 $m$ 亚态上的玻色子整数数量。这种表示方法内在地满足了玻色子所要求的完全对称性。占据数必须满足约束条件 $\\sum_{m=-2}^{2} n_m = N$。\n\n该希尔伯特空间的维度由将 $N$ 个相同的物品分配到 5 个可区分的盒子中的方式数给出，即 $\\dim(N) = \\binom{N+5-1}{5-1} = \\binom{N+4}{4}$。对于测试集中的每个 $N$ 值，我们首先生成所有可能的唯一占据数元组。这些基矢态被存储起来，并创建一个从每个元组到唯一整数索引 $i \\in \\{0, 1, \\dots, \\dim(N)-1\\}$ 的映射，以便高效地构造矩阵。\n\n**2. 角动量算符矩阵**\n我们根据生成的基矢构建总角动量算符的矩阵表示。这些算符以二次量子化形式表示。\n\n**2.1. $J_z$ 算符**\n总角动量的 $z$ 分量由 $J_z = \\sum_{m=-2}^{2} m \\, b^\\dagger_m b_m$ 给出，其中 $b^\\dagger_m b_m = \\hat{n}_m$ 是 $m$ 亚态的粒子数算符。作用于一个基矢态 $\\ket{\\{n_k\\}}$，我们有：\n$$J_z \\ket{\\{n_k\\}} = \\left( \\sum_{m=-2}^{2} m n_m \\right) \\ket{\\{n_k\\}}$$\n这表明 $J_z$ 在 $m$ 表象基中是对角的。其矩阵表示 $\\mathbf{J}_z$ 是一个对角矩阵，其中元素 $(\\mathbf{J}_z)_{ii}$ 是对应于第 $i$ 个基矢态 $\\ket{\\psi_i} = \\ket{\\{n_m^{(i)}\\}}$ 的本征值 $\\sum_m m n_m^{(i)}$。\n\n**2.2. $J_+$ 和 $J_-$ 算符**\n升算符 $J_+$ 定义为 $J_+ = \\sum_{m=-2}^{1} \\sqrt{l(l+1) - m(m+1)} \\, b^\\dagger_{m+1} b_m$。当 $l=2$ 时，这变为：\n$$J_+ = \\sum_{m=-2}^{1} \\sqrt{6 - m(m+1)} \\, b^\\dagger_{m+1} b_m$$\n算符 $b^\\dagger_{m+1} b_m$ 在 $m$ 态湮灭一个玻色子，并在 $m+1$ 态产生一个玻色子。它作用于一个基矢态 $\\ket{\\{n_k\\}}$ 的结果如下：\n$$b^\\dagger_{m+1} b_m \\ket{\\{n_k\\}} = \\sqrt{n_m} \\sqrt{n_{m+1}+1} \\ket{\\{n_k' \\}}$$\n其中 $\\ket{\\{n_k'\\}}$ 是将一个玻色子从 $m$ 亚态移动到 $m+1$ 亚态后的态。矩阵元 $(\\mathbf{J}_+)_{ij}$ 仅在态 $\\ket{\\psi_i}$ 可以通过 $J_+$ 求和中的某一项作用于态 $\\ket{\\psi_j}$ 得到时才非零。具体来说，如果 $\\ket{\\psi_i}$ 是通过将 $\\ket{\\psi_j}$ 中的一个玻色子从 $m$ 亚态移动到 $m+1$ 亚态而获得的态，则矩阵元为：\n$$(\\mathbf{J}_+)_{ij} = \\sqrt{6-m(m+1)} \\sqrt{n_m^{(j)}} \\sqrt{n_{m+1}^{(j)}+1}$$\n降算符是其厄米共轭，$J_- = J_+^\\dagger$。因此，它的矩阵表示是 $\\mathbf{J}_+$ 的共轭转置。由于所有系数都是实数，所以 $\\mathbf{J}_- = \\mathbf{J}_+^T$。\n\n**3. Casimir 算符与对角化**\n总角动量平方算符 $J^2$ 通过关系式 $J^2 = J_- J_+ + J_z(J_z + \\mathbb{1})$ 构建。在矩阵形式中，这转化为：\n$$\\mathbf{J}^2 = \\mathbf{J}_- \\mathbf{J}_+ + \\mathbf{J}_z (\\mathbf{J}_z + \\mathbf{I})$$\n其中 $\\mathbf{I}$ 是单位矩阵。得到的矩阵 $\\mathbf{J}^2$ 是实对称的，因而是厄米的。我们通过数值对角化计算其本征值 $\\{\\lambda_k\\}$。算符 $J^2$ 的本征值形式为 $J(J+1)$，其中 $J$ 是一个非负整数，代表总角动量量子数。\n\n**4. $J=0$ 的简并度**\n总角动量为 $J=0$ 的态是 $J^2$ 算符的本征态，其本征值为 $0(0+1)=0$。因此，为了找到线性无关的 $J=0$ 态的数量，我们需要计算 $\\mathbf{J}^2$ 矩阵的零本征值的简并度。由于浮点运算的限制，如果一个计算出的本征值 $\\lambda_k$ 落在指定的数值容差 $\\varepsilon$ 内，则认为它为零。根据问题陈述，我们计算满足 $|\\lambda_k|  \\varepsilon$ 的本征值的数量，其中 $\\varepsilon = 10^{-8}$。\n\n**5. 算法总结**\n对每个测试值 $N \\in \\{0, 1, 2, 3, 4, 5\\}$ 执行完整的流程：\n1. 生成 $N$-玻色子态的基矢以及态到索引的映射。\n2. 将大小为 $\\dim(N) \\times \\dim(N)$ 的矩阵 $\\mathbf{J}_z$、$\\mathbf{J}_+$ 和 $\\mathbf{J}_-$ 初始化为零。\n3. 通过遍历每个基矢态并应用算符定义来填充矩阵 $\\mathbf{J}_z$ 和 $\\mathbf{J}_+$。\n4. 构造 $\\mathbf{J}_- = \\mathbf{J}_+^T$。\n5. 构建 Casimir 矩阵 $\\mathbf{J}^2 = \\mathbf{J}_- \\mathbf{J}_+ + \\mathbf{J}_z^2 + \\mathbf{J}_z$。\n6. 对角化 $\\mathbf{J}^2$ 以求其本征值。\n7. 计算绝对值小于 $10^{-8}$ 的本征值数量。\n收集最终计数并以指定的列表格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    It computes the multiplicity of J=0 states for N d-bosons and prints the result.\n    \"\"\"\n    test_cases_N = [0, 1, 2, 3, 4, 5]\n    tolerance = 1e-8\n    results = []\n    \n    for n_bosons in test_cases_N:\n        multiplicity = calculate_j0_multiplicity(n_bosons, tolerance)\n        results.append(multiplicity)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_basis(n_bosons, num_levels):\n    \"\"\"\n    Recursively generates the basis of occupation number states.\n    A state is a tuple (n_0, n_1, ..., n_{k-1}) where sum(n_i) = n_bosons.\n    \"\"\"\n    if num_levels == 1:\n        return [(n_bosons,)]\n    \n    basis = []\n    for n_k in range(n_bosons + 1):\n        sub_basis = generate_basis(n_bosons - n_k, num_levels - 1)\n        for sub_state in sub_basis:\n            basis.append((n_k,) + sub_state)\n            \n    return basis\n\ndef calculate_j0_multiplicity(n_bosons, tolerance):\n    \"\"\"\n    Calculates the multiplicity of J=0 states for a system of N d-bosons.\n    \n    Args:\n        n_bosons (int): The number of bosons, N.\n        tolerance (float): The numerical tolerance to identify zero eigenvalues.\n        \n    Returns:\n        int: The number of J=0 states.\n    \"\"\"\n    # For d-bosons, l=2, so there are 2l+1=5 magnetic substates.\n    l_boson = 2\n    num_m_levels = 2 * l_boson + 1\n    m_values = np.arange(-l_boson, l_boson + 1)\n    \n    if n_bosons == 0:\n        # The vacuum state is a single J=0 state.\n        return 1\n        \n    basis = generate_basis(n_bosons, num_m_levels)\n    dim = len(basis)\n    state_to_index = {state: i for i, state in enumerate(basis)}\n    \n    j_z = np.zeros((dim, dim))\n    j_plus = np.zeros((dim, dim))\n    \n    # Coefficients for J_+, sqrt(l(l+1) - m(m+1)) for m = -2, -1, 0, 1\n    j_plus_coeffs = [np.sqrt(l_boson*(l_boson+1) - m*(m+1)) for m in m_values[:-1]]\n    \n    for j, source_state_tuple in enumerate(basis):\n        source_state_occs = np.array(source_state_tuple)\n        \n        # 1. Construct J_z (diagonal)\n        mz = np.sum(m_values * source_state_occs)\n        j_z[j, j] = mz\n        \n        # 2. Construct J_+ (off-diagonal)\n        # J_+ = sum_{m=-2..1} c_m b_{m+1}^+ b_m\n        for m_idx, m in enumerate(m_values[:-1]):\n            # State m is at index m_idx. State m+1 is at m_idx+1.\n            n_m = source_state_occs[m_idx]\n            if n_m == 0:\n                continue\n            \n            n_mp1 = source_state_occs[m_idx + 1]\n            \n            # Action of creation/annihilation operators\n            op_coeff = np.sqrt(n_m) * np.sqrt(n_mp1 + 1)\n            \n            # Full coefficient for the m-th term in J_+\n            total_coeff = j_plus_coeffs[m_idx] * op_coeff\n            \n            # Determine the target state\n            target_state_occs = list(source_state_occs)\n            target_state_occs[m_idx] -= 1\n            target_state_occs[m_idx + 1] += 1\n            target_state_tuple = tuple(target_state_occs)\n            \n            i = state_to_index[target_state_tuple]\n            j_plus[i, j] += total_coeff\n            \n    # 3. Construct J_- and J^2\n    j_minus = j_plus.T\n    j2 = j_minus @ j_plus + j_z @ (j_z + np.identity(dim))\n    \n    # 4. Diagonalize J^2 and get eigenvalues\n    eigenvalues = eigvalsh(j2)\n    \n    # 5. Count eigenvalues close to zero\n    j0_multiplicity = np.sum(np.isclose(eigenvalues, 0.0, atol=tolerance))\n    \n    return int(j0_multiplicity)\n\nsolve()\n```", "id": "3576636"}, {"introduction": "在构建了基本算符之后，下一步是组装完整的哈密顿量矩阵，这可能是一个复杂且容易出错的过程。本练习介绍了一种强大的代码验证技术：将矩阵的数值迹与解析推导的迹公式进行比较。由于算符的迹在基变换下是不变的，并且通常可以通过组合学方法解析计算，因此该方法为验证所有对角矩阵元的正确性提供了一个简洁而可靠的检验。掌握这种交叉检验方法对于在开发复杂的计算物理代码时确保其准确性至关重要。[@problem_id:3576640]", "problem": "考虑最简单的 $sd$-玻色子空间中的相互作用玻色子模型 (IBM)，该空间包含一个角动量 $L=0$ 的标量玻色子模式 $s$ 和五个四极玻色子模式 $d_{m}$（其中 $m \\in \\{-2,-1,0,1,2\\}$）。设玻色子总数固定为 $N \\in \\mathbb{Z}_{\\ge 0}$。在粒子数守恒的 $m$-表象占据数基矢下进行计算，其维度为 $D = \\binom{N+K-1}{K-1}$，其中 $K=6$ 是单玻色子模式的数量。一个基矢态由非负占据数矢量 $\\mathbf{n}=(n_s,n_{-2},n_{-1},n_0,n_{1},n_2)$ 指定，满足 $\\sum_{\\mu} n_{\\mu} = N$，并对应于右矢 $\\lvert \\mathbf{n} \\rangle = \\lvert n_s; n_{-2},n_{-1},n_0,n_1,n_2\\rangle$。\n\n玻色子产生和湮灭算符对不同模式 $\\mu,\\nu \\in \\{s,-2,-1,0,1,2\\}$ 满足正则对易关系：\n- $[b_{\\mu},b_{\\nu}^{\\dagger}] = \\delta_{\\mu\\nu}$ 且 $[b_{\\mu},b_{\\nu}]=[b_{\\mu}^{\\dagger},b_{\\nu}^{\\dagger}]=0$，\n- 粒子数算符 $n_{\\mu} = b_{\\mu}^{\\dagger} b_{\\mu}$ 的作用为 $n_{\\mu} \\lvert \\dots, n_{\\mu},\\dots \\rangle = n_{\\mu} \\lvert \\dots, n_{\\mu},\\dots \\rangle$，\n- 升降作用为 $b_{\\mu} \\lvert \\dots,n_{\\mu},\\dots \\rangle = \\sqrt{n_{\\mu}} \\lvert \\dots,n_{\\mu}-1,\\dots \\rangle$ 和 $b_{\\mu}^{\\dagger} \\lvert \\dots,n_{\\mu},\\dots \\rangle = \\sqrt{n_{\\mu}+1} \\lvert \\dots,n_{\\mu}+1,\\dots \\rangle$。\n\n将哈密顿量 $H$ 定义为单体项、对角的两体密度-密度项，以及 $s$ 和 $d_0$ 模式之间的非对角对转换项之和：\n$$\nH = e_s\\, n_s + e_d \\sum_{m=-2}^{2} n_{d_m}\n+ \\frac{1}{2} V_{ss}\\, n_s(n_s-1)\n+ \\frac{1}{2} V_{dd} \\sum_{m=-2}^{2} n_{d_m}(n_{d_m}-1)\n+ V_{sd}\\, n_s \\left(\\sum_{m=-2}^{2} n_{d_m}\\right)\n+ w \\left( s^{\\dagger} s^{\\dagger} d_0 d_0 + d_0^{\\dagger} d_0^{\\dagger} s s \\right).\n$$\n\n此处 $e_s,e_d,V_{ss},V_{dd},V_{sd},w \\in \\mathbb{R}$。最后一项是粒子数守恒的，并且在占据数基矢下是非对角的，其非零矩阵元源于在 $d_0$ 和 $s$ 模式之间移动两个玻色子，其振幅由玻色子升降因子确定。\n\n你的任务：\n\n1. 在固定的 $N$ 占据数基矢下，应用玻色子算符代数计算所有非零矩阵元，以构建 $H$ 的矩阵表示。确保双玻色子转移项 $s^{\\dagger} s^{\\dagger} d_0 d_0$ 和 $d_0^{\\dagger} d_0^{\\dagger} s s$ 使用由升降算符决定的正确振幅进行处理。\n\n2. 仅使用基本定义和经过充分检验的组合学事实，推导 $H$ 在固定 $N$ 的希尔伯特空间上的解析迹的闭合形式表达式。从迹恒等式\n$$\n\\mathrm{Tr}(H) = \\sum_{i=1}^{D} \\langle i \\lvert H \\rvert i \\rangle\n$$\n和“非对角算符在占据数基矢下的对角期望值为零”这一观察出发。将解析迹简化为对基矢求和的组合，其形式为 $\\sum_{\\mathbf{n}} n_s$，$\\sum_{\\mathbf{n}} \\sum_{m} n_{d_m}$，$\\sum_{\\mathbf{n}} n_s(n_s-1)$，$\\sum_{\\mathbf{n}} \\sum_m n_{d_m}(n_{d_m}-1)$，以及 $\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m}$，其中和是针对所有满足 $\\sum_{\\mu} n_{\\mu} = N$ 的占据数矢量 $\\mathbf{n}$。利用对称性和关于将 $N$ 个不可区分的玻色子分配到 $K$ 个可区分模式中的计数论证，从第一性原理出发，为普适的 $N$ 和 $K=6$ 推导这些和。\n\n3. 实现一个程序，该程序构建 $H$，直接从组装好的矩阵计算其数值迹，根据推导出的公式计算您的解析迹，并使用指定的数值容差比较两者。不允许外部输入；请使用下面的测试套件。\n\n所有能量都可以用一致的任意能量单位处理；无需进行单位转换。角度不会出现。将布尔比较报告为无量纲的真值。\n\n覆盖正常路径和边界情况的测试套件参数：\n\n- 情况 1：$N=0$，$e_s=1.2$，$e_d=-0.7$，$V_{ss}=0.5$，$V_{dd}=1.3$，$V_{sd}=-0.9$，$w=2.4$。\n- 情况 2：$N=1$，$e_s=0.0$，$e_d=1.0$，$V_{ss}=3.0$，$V_{dd}=-2.0$，$V_{sd}=0.5$，$w=7.5$。\n- 情况 3：$N=3$，$e_s=-0.2$，$e_d=0.8$，$V_{ss}=0.6$，$V_{dd}=-0.4$，$V_{sd}=1.1$，$w=0.7$。\n- 情况 4：$N=4$，$e_s=1.0$，$e_d=-0.3$，$V_{ss}=-0.5$，$V_{dd}=0.9$，$V_{sd}=-1.2$，$w=5.0$。\n- 情况 5：$N=2$，$e_s=0.3$，$e_d=0.4$，$V_{ss}=1.7$，$V_{dd}=-0.2$，$V_{sd}=0.0$，$w=10.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的布尔值列表，顺序与上述情况一致。当且仅当数值迹与您的解析迹之间的绝对差小于 $10^{-9}$ 时，每个布尔值为真。例如：“[True,True,True,True,True]”。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于量子多体物理学的原理，特别是相互作用玻色子模型 (IBM)，并且在数学上是适定和自洽的。所有定义、参数和约束都已明确无误地给出，从而允许直接且可验证的求解。\n\n该任务要求将哈密顿量矩阵的数值计算迹与同一量的解析推导公式进行比较。我们将首先概述哈密顿量矩阵的构建过程，然后推导其迹的闭合形式表达式。\n\n### 哈密顿量的数值构建和迹\n\n对于固定的玻色子总数 $N$，希尔伯特空间由占据数基矢态 $\\lvert \\mathbf{n} \\rangle = \\lvert n_s, n_{d_{-2}}, n_{d_{-1}}, n_{d_0}, n_{d_1}, n_{d_2} \\rangle$ 张成，其中非负整数 $n_{\\mu}$ 满足 $\\sum n_{\\mu} = N$。模式数为 $K=6$。该空间的维度为 $D = \\binom{N+K-1}{K-1} = \\binom{N+5}{5}$。\n\n构建哈密顿量矩阵 $H$ 的步骤如下：\n1.  生成所有唯一的基矢态矢量 $\\mathbf{n}$。这些矢量对应于矩阵的行和列。\n2.  为每个状态矢量 $\\mathbf{n}$ 创建一个到索引 $i \\in \\{0, 1, \\dots, D-1\\}$ 的映射。\n3.  初始化一个 $D \\times D$ 的零矩阵。\n4.  对于每个基矢态 $\\lvert \\mathbf{n}_i \\rangle$，计算矩阵元 $H_{ji} = \\langle \\mathbf{n}_j \\lvert H \\rvert \\mathbf{n}_i \\rangle$。\n\n哈密顿量由下式给出：\n$$\nH = e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right) + w \\left( s^{\\dagger} s^{\\dagger} d_0 d_0 + d_0^{\\dagger} d_0^{\\dagger} s s \\right)\n$$\n\n**对角矩阵元：** H 的前五项在占据数基矢下是对角的。对于一个态 $\\lvert \\mathbf{n} \\rangle$，粒子数算符 $n_\\mu$ 的本征值为 $n_\\mu$。因此，对角矩阵元为：\n$$\n\\langle \\mathbf{n} \\lvert H \\rvert \\mathbf{n} \\rangle = e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right)\n$$\n\n**非对角矩阵元：** 与 $w$ 成正比的项是非对角的。它连接了因两个玻色子在 $s$ 和 $d_0$ 模式之间移动而不同的态。使用产生和湮灭算符代数：\n-   $s^{\\dagger} s^{\\dagger} d_0 d_0 \\lvert n_s, \\dots, n_{d_0}, \\dots \\rangle = \\sqrt{n_{d_0}(n_{d_0}-1)} \\sqrt{(n_s+1)(n_s+2)} \\lvert n_s+2, \\dots, n_{d_0}-2, \\dots \\rangle$。仅当 $n_{d_0} \\ge 2$ 时，此作用非零。\n-   $d_0^{\\dagger} d_0^{\\dagger} s s \\lvert n_s, \\dots, n_{d_0}, \\dots \\rangle = \\sqrt{n_s(n_s-1)} \\sqrt{(n_{d_0}+1)(n_{d_0}+2)} \\lvert n_s-2, \\dots, n_{d_0}+2, \\dots \\rangle$。仅当 $n_s \\ge 2$ 时，此作用非零。\n\n这些作用定义了非零的非对角矩阵元。例如，如果 $\\lvert \\mathbf{n}' \\rangle$ 是满足 $n'_s = n_s+2$ 和 $n'_{d_0} = n_{d_0}-2$ 的态，则 $\\langle \\mathbf{n}' \\lvert H \\rvert \\mathbf{n} \\rangle = w \\sqrt{n_{d_0}(n_{d_0}-1)(n_s+1)(n_s+2)}$。\n\n数值迹 $\\mathrm{Tr}(H)_{\\text{num}}$ 是完全构建的矩阵 $H$ 的对角元之和。\n\n### 迹的解析推导\n\n算符的迹是其在完备基上的对角矩阵元之和。对于占据数基矢 $\\{\\lvert \\mathbf{n} \\rangle\\}$ 中的哈密顿量 $H$，我们有：\n$$\n\\mathrm{Tr}(H) = \\sum_{\\mathbf{n}} \\langle \\mathbf{n} \\lvert H \\rvert \\mathbf{n} \\rangle\n$$\n其中求和遍及所有 $D$ 个基矢态。$H$ 的非对角部分（系数为 $w$ 的项）对迹没有贡献。因此，我们只需对整个基矢的对角矩阵元求和：\n$$\n\\mathrm{Tr}(H) = \\sum_{\\mathbf{n}} \\left[ e_s n_s + e_d \\sum_m n_{d_m} + \\frac{1}{2} V_{ss} n_s(n_s-1) + \\frac{1}{2} V_{dd} \\sum_m n_{d_m}(n_{d_m}-1) + V_{sd} n_s \\left(\\sum_m n_{d_m}\\right) \\right]\n$$\n根据线性性，我们可以将其重排为一系列项的和，每一项都涉及占据数在基矢上的统计矩：\n$$\n\\mathrm{Tr}(H) = e_s\\left(\\sum_{\\mathbf{n}} n_s\\right) + e_d\\left(\\sum_{\\mathbf{n}}\\sum_m n_{d_m}\\right) + \\frac{V_{ss}}{2}\\left(\\sum_{\\mathbf{n}} n_s(n_s-1)\\right) + \\frac{V_{dd}}{2}\\left(\\sum_{\\mathbf{n}}\\sum_m n_{d_m}(n_{d_m}-1)\\right) + V_{sd}\\left(\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m}\\right)\n$$\n这些和的计算是一个组合问题，即把 $N$ 个不可区分的玻色子分配到 $K=6$ 个可区分的模式中。关键结果可以从组合分析的第一性原理（例如，使用生成函数或基于隔板法的直接计数论证）推导得出，如下所示：\n-   $\\sum_{\\mathbf{n}} \\binom{n_{\\mu_1}}{k_1} \\dots \\binom{n_{\\mu_m}}{k_m} = \\binom{N+K-1}{K-1+p}$ 其中 $\\mu_i$ 是不同的模式，且 $p = \\sum_i k_i$。\n\n应用此主公式：\n1.  单一占据数的和：对任意模式 $\\mu$，设 $p=1$ ($k_1=1$)。\n    $\\sum_{\\mathbf{n}} n_\\mu = \\sum_{\\mathbf{n}} \\binom{n_\\mu}{1} = \\binom{N+6-1}{6-1+1} = \\binom{N+5}{6}$。\n2.  成对占据数的和（相同模式）：对任意模式 $\\mu$，设 $p=2$ ($k_1=2$)。\n    $\\sum_{\\mathbf{n}} \\binom{n_\\mu}{2} = \\binom{N+6-1}{6-1+2} = \\binom{N+5}{7}$。\n    这给出 $\\sum_{\\mathbf{n}} n_\\mu(n_\\mu-1) = 2\\sum_{\\mathbf{n}} \\binom{n_\\mu}{2} = 2\\binom{N+5}{7}$。\n3.  成对占据数的和（不同模式）：对模式 $\\mu \\neq \\nu$，设 $p=2$ ($k_1=1, k_2=1$)。\n    $\\sum_{\\mathbf{n}} n_\\mu n_\\nu = \\sum_{\\mathbf{n}} \\binom{n_\\mu}{1}\\binom{n_\\nu}{1} = \\binom{N+6-1}{6-1+2} = \\binom{N+5}{7}$。\n\n使用这些恒等式，我们计算所需的和：\n-   $\\sum_{\\mathbf{n}} n_s = \\binom{N+5}{6}$\n-   $\\sum_{\\mathbf{n}} \\sum_m n_{d_m} = \\sum_m \\left(\\sum_{\\mathbf{n}} n_{d_m}\\right) = 5 \\binom{N+5}{6}$\n-   $\\sum_{\\mathbf{n}} n_s(n_s-1) = 2\\binom{N+5}{7}$\n-   $\\sum_{\\mathbf{n}} \\sum_m n_{d_m}(n_{d_m}-1) = \\sum_m \\left(\\sum_{\\mathbf{n}} n_{d_m}(n_{d_m}-1)\\right) = 5 \\times 2\\binom{N+5}{7} = 10\\binom{N+5}{7}$\n-   $\\sum_{\\mathbf{n}} n_s \\sum_m n_{d_m} = \\sum_m \\left(\\sum_{\\mathbf{n}} n_s n_{d_m}\\right) = 5\\binom{N+5}{7}$\n\n将这些结果代回到迹的表达式中：\n$$\n\\mathrm{Tr}(H) = e_s \\binom{N+5}{6} + e_d \\left(5\\binom{N+5}{6}\\right) + \\frac{V_{ss}}{2} \\left(2\\binom{N+5}{7}\\right) + \\frac{V_{dd}}{2} \\left(10\\binom{N+5}{7}\\right) + V_{sd} \\left(5\\binom{N+5}{7}\\right)\n$$\n合并各项，得到迹的最终解析公式为：\n$$\n\\mathrm{Tr}(H)_{\\text{analytic}} = (e_s + 5e_d) \\binom{N+5}{6} + (V_{ss} + 5V_{dd} + 5V_{sd}) \\binom{N+5}{7}\n$$\n注意，如果 $k > n$，组合项 $\\binom{n}{k}$ 为零。\n\n实现部分将通过矩阵构建计算数值迹，并根据此最终公式计算解析迹，然后对给定的测试用例进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nfrom math import sqrt\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It calculates the numerical and analytical traces of the IBM Hamiltonian\n    and compares them for a series of parameter sets.\n    \"\"\"\n    test_cases = [\n        # (N, es, ed, Vss, Vdd, Vsd, w)\n        (0, 1.2, -0.7, 0.5, 1.3, -0.9, 2.4),\n        (1, 0.0, 1.0, 3.0, -2.0, 0.5, 7.5),\n        (3, -0.2, 0.8, 0.6, -0.4, 1.1, 0.7),\n        (4, 1.0, -0.3, -0.5, 0.9, -1.2, 5.0),\n        (2, 0.3, 0.4, 1.7, -0.2, 0.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        comparison_result = run_case(*case)\n        results.append(comparison_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(N, es, ed, Vss, Vdd, Vsd, w):\n    \"\"\"\n    Computes numerical and analytical traces for a single test case.\n    \n    Returns:\n        bool: True if the absolute difference between traces is within tolerance.\n    \"\"\"\n    \n    # 1. Numerical Trace Calculation\n    \n    if N == 0:\n        # The only state is |0,0,0,0,0,0>, H is a 1x1 zero matrix.\n        tr_num = 0.0\n    else:\n        # Generate basis states: occupancy vectors (ns, n_d-2, ..., n_d+2)\n        # K=6 modes.\n        basis_states = list(_generate_states(N, 6))\n        D = len(basis_states)\n        state_to_idx = {state: i for i, state in enumerate(basis_states)}\n\n        H = np.zeros((D, D), dtype=float)\n\n        for i, state in enumerate(basis_states):\n            # Unpack state occupancies\n            ns, ndm2, ndm1, nd0, nd1, nd2 = state\n            \n            # --- Diagonal elements ---\n            nd_tot = N - ns\n            \n            # Sum of n_dm * (n_dm - 1) for the V_dd term\n            sum_nd_ndm1 = ndm2 * (ndm2 - 1) + \\\n                          ndm1 * (ndm1 - 1) + \\\n                          nd0 * (nd0 - 1) + \\\n                          nd1 * (nd1 - 1) + \\\n                          nd2 * (nd2 - 1)\n            \n            H[i, i] = es * ns + ed * nd_tot + \\\n                      0.5 * Vss * ns * (ns - 1) + \\\n                      0.5 * Vdd * sum_nd_ndm1 + \\\n                      Vsd * ns * nd_tot\n            \n            # --- Off-diagonal elements from pairing term ---\n            # Term w * (s's'd0d0 + d0'd0'ss)\n            # s-mode is index 0, d0-mode is index 3\n            \n            # Action of s's'd0d0 (connects state i to state j)\n            if nd0 >= 2:\n                # Target state has ns+2, nd0-2\n                new_state = (ns + 2, ndm2, ndm1, nd0 - 2, nd1, nd2)\n                j = state_to_idx[new_state]\n                amp = w * sqrt(nd0 * (nd0 - 1) * (ns + 1) * (ns + 2))\n                H[j, i] += amp\n\n            # Action of d0'd0'ss (connects state i to state k)\n            if ns >= 2:\n                # Target state has ns-2, nd0+2\n                new_state = (ns - 2, ndm2, ndm1, nd0 + 2, nd1, nd2)\n                k = state_to_idx[new_state]\n                amp = w * sqrt(ns * (ns - 1) * (nd0 + 1) * (nd0 + 2))\n                H[k, i] += amp\n        \n        tr_num = np.trace(H)\n\n    # 2. Analytic Trace Calculation\n    \n    # Use scipy.special.comb, which returns 0.0 for k > n\n    # K=6 for the sd model.\n    comb_N_6 = comb(N + 5, 6, exact=False)\n    comb_N_7 = comb(N + 5, 7, exact=False)\n    \n    tr_an = (es + 5 * ed) * comb_N_6 + \\\n            (Vss + 5 * Vdd + 5 * Vsd) * comb_N_7\n            \n    # 3. Comparison\n    return abs(tr_num - tr_an)  1e-9\n\ndef _generate_states(n_bosons, n_modes):\n    \"\"\"\n    Recursively generates all partitions of n_bosons into n_modes.\n    This corresponds to the m-scheme basis states.\n    \"\"\"\n    if n_modes == 1:\n        yield (n_bosons,)\n        return\n    for i in range(n_bosons + 1):\n        for rest in _generate_states(n_bosons - i, n_modes - 1):\n            # States are ordered (ns, n_d-2, n_d-1, n_d0, n_d1, n_d2)\n            yield (i,) + rest\n\nsolve()\n```", "id": "3576640"}, {"introduction": "计算物理学的一个核心任务不仅是求解模型的谱，还要理解模型的预测如何随其参数变化。本项高级实践探讨了哈密顿量对参数的敏感性，并引入了赫尔曼-费曼（Hellmann-Feynman）定理，它为计算特征值对模型参数的导数提供了一种优雅的解析方法。通过将该定理的精确结果与数值有限差分近似进行比较，您不仅能验证该定理，还能对数值微分中截断误差和舍入误差之间的权衡获得宝贵的实践洞察。[@problem_id:3576651]", "problem": "您需要实现、验证和分析相互作用玻色子模型 (Interacting Boson Model, IBM) 哈密顿量中本征值相对于耦合参数的数值导数，并将其与 Hellmann–Feynman 定理进行比较。请在相互作用玻色子模型 (IBM) 最简单的、对称性无限制的二次量子化实现中进行操作，该模型包含一个标量玻色子模和五个四极玻色子模，并在总玻色子数固定的情况下，使用粒子数（m-方案）基。\n\n基本定义与约束：\n- 相互作用玻色子模型 (IBM) 使用一个标量玻色子模（由产生算符 $s^{\\dagger}$ 和湮灭算符 $s$ 表示）以及五个四极玻色子模 $d_{m}^{\\dagger}$ 和 $d_{m}$（磁投影 $m \\in \\{-2,-1,0,1,2\\}$）。这些是理想玻色子，满足正则对易关系 $[a_{i},a_{j}^{\\dagger}] = \\delta_{ij}$，所有其他对易子为零。\n- 希尔伯特空间是全对称玻色子福克空间 (Fock space)，具有固定的总玻色子数 $N$，即总粒子数算符 $n_{s} + \\sum_{m} n_{d_{m}}$ 在所有基矢态上的本征值为 $N$。此处，粒子数算符为 $n_{s} = s^{\\dagger} s$ 和 $n_{d_{m}} = d_{m}^{\\dagger} d_{m}$。\n- 考虑哈密顿量\n$$\nH(\\kappa) \\;=\\; \\epsilon_{s}\\, n_{s} \\;+\\; \\epsilon_{d}\\,\\sum_{m=-2}^{2} n_{d_{m}} \\;+\\; \\kappa \\sum_{m=-2}^{2}\\Big(s^{\\dagger} d_{m} + d_{m}^{\\dagger} s\\Big),\n$$\n其中 $\\epsilon_{s}$ 和 $\\epsilon_{d}$ 是常数，$\\kappa$ 是一个实数耦合参数。所有能量和耦合都应被视为无量纲数。\n\n计算表示：\n- 使用粒子数基，基矢态由 $s$ 玻色子和五个 $d$ 玻色子模的粒子数 $(n_{s}, n_{-2}, n_{-1}, n_{0}, n_{1}, n_{2})$ 标记，并满足约束 $n_{s} + \\sum_{m} n_{m} = N$。产生和湮灭算符对相应模的作用为 $a^{\\dagger} \\lvert n \\rangle = \\sqrt{n+1}\\, \\lvert n+1 \\rangle$ 和 $a \\lvert n \\rangle = \\sqrt{n}\\, \\lvert n-1 \\rangle$。\n- 在此基中，对角的单体部分是 $H_{0} = \\epsilon_{s} n_{s} + \\epsilon_{d} \\sum_{m} n_{d_{m}}$。非对角的耦合项是 $V = \\sum_{m}(s^{\\dagger} d_{m} + d_{m}^{\\dagger} s)$；$V$ 在两个通过在 $s$ 模和一个 $d_{m}$ 模之间移动一个玻色子而连接的基矢态之间的矩阵元可由玻色子阶梯代数得出。\n\n将使用的基本定理：\n- 对于一个归一化的 $H(\\kappa)$ 的本征态 $\\lvert \\psi_{k}(\\kappa) \\rangle$（其本征值为 $E_{k}(\\kappa)$），Hellmann–Feynman 定理指出\n$$\n\\frac{dE_{k}}{d\\kappa} \\;=\\; \\left\\langle \\psi_{k}(\\kappa) \\,\\middle\\lvert\\, \\frac{\\partial H(\\kappa)}{\\partial \\kappa} \\,\\middle\\rvert\\, \\psi_{k}(\\kappa)\\right\\rangle \\;=\\; \\langle \\psi_{k}(\\kappa) \\lvert V \\rvert \\psi_{k}(\\kappa) \\rangle.\n$$\n\n任务：\n1. 对于固定的 $N$，使用上述代数，在粒子数基中构建有限维哈密顿矩阵 $H(\\kappa)$。取 $N = 3$，$\\epsilon_{s} = 0$ 和 $\\epsilon_{d} = 1$。使用实对称矩阵，并确保所有矩阵元的正确归一化。\n2. 对于每个指定的 $(\\kappa, h)$ 对，以基态（$k=0$）为目标：\n   - 通过对 $H(\\kappa)$ 进行精确对角化，计算基态本征值 $E_{0}(\\kappa)$ 和一个相应的归一化本征矢量 $\\lvert \\psi_{0}(\\kappa)\\rangle$。\n   - 计算 Hellmann–Feynman 导数 $D_{\\mathrm{HF}}(\\kappa) = \\langle \\psi_{0}(\\kappa) \\lvert V \\rvert \\psi_{0}(\\kappa)\\rangle$。\n   - 计算中心有限差分导数\n     $$\n     D_{\\mathrm{FD}}(\\kappa,h) \\;=\\; \\frac{E_{0}(\\kappa+h) - E_{0}(\\kappa-h)}{2h}.\n     $$\n     为避免由于可能的能级交叉/避免交叉导致的本征值误标，在计算 $E_{0}(\\kappa \\pm h)$ 时，应选择在 $\\kappa \\pm h$ 处的那个本征值，其对应的本征矢量与 $\\lvert \\psi_{0}(\\kappa) \\rangle$ 的交叠（overlap）绝对值最大。\n   - 返回绝对误差 $|D_{\\mathrm{FD}}(\\kappa,h) - D_{\\mathrm{HF}}(\\kappa)|$（作为一个浮点数）。\n3. 在您的解决方案中讨论，当 $h$ 变化时，截断误差和舍入误差如何相互竞争，以及这在测试输出中是如何体现的。\n\n测试套件：\n- 使用以下参数集 $(\\kappa, h)$，并固定 $N = 3$，$\\epsilon_{s} = 0$，$\\epsilon_{d} = 1$：\n  - 情况 1：$(\\kappa, h) = (0.2, 10^{-3})$。\n  - 情况 2：$(\\kappa, h) = (0.2, 10^{-6})$。\n  - 情况 3：$(\\kappa, h) = (0.2, 10^{-1})$。\n  - 情况 4：$(\\kappa, h) = (0.0, 10^{-3})$。\n  - 情况 5：$(\\kappa, h) = (0.5, 10^{-3})$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含按上述顺序列出的各种情况的绝对误差，格式为一个逗号分隔的列表，并用方括号括起来（例如 `[x_{1},x_{2},x_{3},x_{4},x_{5}]`）。每个 $x_{i}$ 必须是一个浮点数。所有量都是无量纲的。不应打印任何其他文本。", "solution": "用户提供了一个来自计算核物理领域的有效问题陈述。任务是为一个简化的相互作用玻色子模型 (IBM) 哈密顿量数值验证 Hellmann-Feynman 定理。这涉及到在有限维的粒子数基中构建哈密顿矩阵，通过两种不同的方法——Hellmann-Feynman (HF) 公式和有限差分 (FD) 近似——计算本征值导数，并分析它们之间的误差。\n\n该问题在科学上是合理的，使用了量子力学和数值分析的标准原理。参数和约束条件定义明确，使得问题形式良好且计算上可行。\n\n### 基于原理的解决方案设计\n\n问题的核心是将量子力学哈密顿量 $H(\\kappa)$ 表示为一个数值矩阵并对其进行对角化。解决方案分为几个逻辑上不同的步骤：基矢生成、哈密顿量构建以及导数的比较计算。\n\n#### 1. 希尔伯特空间与基矢构建\n\n该模型涉及 $d=6$ 种玻色子：一个标量 ($s$) 和五个四极 ($d_{m}$，其中 $m \\in \\{-2, \\ldots, 2\\}$)。希尔伯特空间被限制在总玻色子数固定的态上，即 $N=3$。用于数值计算的合适基矢是粒子数（或福克态）基。一个基矢态由一个粒子数元组 $\\lvert n_s, n_{-2}, n_{-1}, n_0, n_1, n_2 \\rangle$ 唯一确定，使得这些粒子数是非负整数且其和为 $N$：\n$$\nn_s + \\sum_{m=-2}^{2} n_{d,m} = N\n$$\n对于 $N=3$ 个玻色子和 $d=6$ 个模，此空间的维度由多重组合的隔板法公式给出：$\\binom{N+d-1}{d-1} = \\binom{3+6-1}{6-1} = \\binom{8}{5} = 56$。\n\n建立一个计算映射，为 $56$ 个唯一的粒子数元组中的每一个分配一个唯一的整数索引 $i \\in \\{0, 1, \\dots, 55\\}$。这使我们能够将量子态表示为矢量，将算符表示为矩阵。\n\n#### 2. 哈密顿矩阵构建\n\n哈密顿量 $H(\\kappa) = H_0 + \\kappa V$ 被构建为一个 $56 \\times 56$ 的实对称矩阵。\n\n第一部分，$H_0 = \\epsilon_s n_s + \\epsilon_d \\sum_m n_{d_m}$，在所选基中是对角的。对应于基矢态 $\\lvert i \\rangle \\equiv \\lvert n_s, \\{n_{d,m}\\} \\rangle$ 的对角矩阵元为：\n$$\n\\langle i \\rvert H_0 \\lvert i \\rangle = \\epsilon_s n_s + \\epsilon_d \\sum_m n_{d,m}\n$$\n使用约束 $\\sum_m n_{d,m} = N - n_s$ 和给定参数 $N=3$，$\\epsilon_s=0$，$\\epsilon_d=1$，这可以简化为：\n$$\n\\langle i \\rvert H_0 \\lvert i \\rangle = 0 \\cdot n_s + 1 \\cdot (3 - n_s) = 3 - n_s\n$$\n\n第二部分，$V = \\sum_{m=-2}^{2} (s^\\dagger d_m + d_m^\\dagger s)$，是相互作用项。它是非对角的，连接的基矢态之间相差一个在 $s$ 模和一个 $d_m$ 模之间转移的玻色子。设 $\\lvert i \\rangle = \\lvert n_s, \\dots, n_m, \\dots \\rangle$ 和 $\\lvert j \\rangle = \\lvert n_s+1, \\dots, n_m-1, \\dots \\rangle$。$V$ 的相应非对角矩阵元为：\n$$\n\\langle j \\rvert V \\lvert i \\rangle = \\left\\langle j \\middle\\rvert \\sum_{m'} (s^\\dagger d_{m'} + d_{m'}^\\dagger s) \\middle\\lvert i \\right\\rangle\n$$\n只有 $s^\\dagger d_m$ 项对该矩阵元有贡献。使用玻色子产生和湮灭算符的规则，$a^\\dagger \\lvert n \\rangle = \\sqrt{n+1} \\lvert n+1 \\rangle$ 和 $a \\lvert n \\rangle = \\sqrt{n} \\lvert n-1 \\rangle$：\n$$\n\\langle j \\rvert s^\\dagger d_m \\lvert i \\rangle = \\langle n_s+1, \\dots, n_m-1, \\dots \\rvert s^\\dagger d_m \\lvert n_s, \\dots, n_m, \\dots \\rangle = \\sqrt{n_m} \\sqrt{n_s+1}\n$$\n由于 $V$ 是厄米且实的，我们有 $\\langle i \\rvert V \\lvert j \\rangle = \\langle j \\rvert V \\lvert i \\rangle$。\n完整的哈密顿矩阵则为 $H_{ij}(\\kappa) = (H_0)_{ij} + \\kappa V_{ij}$。该矩阵为后续步骤进行数值构建。\n\n#### 3. 导数计算与比较\n\n对于每个给定的 $(\\kappa, h)$ 对，我们以基态（标记为 $k=0$）为目标。\n\n1.  **精确对角化**：使用标准的厄米矩阵数值算法对矩阵 $H(\\kappa)$ 进行对角化。这将产生一组本征值 $\\{E_k(\\kappa)\\}$ 及其对应的本征矢量 $\\{ \\lvert \\psi_k(\\kappa) \\rangle \\}$。基态能量 $E_0(\\kappa)$ 是最低的本征值，而 $\\lvert \\psi_0(\\kappa) \\rangle$ 是其关联的本征矢量。\n\n2.  **Hellmann-Feynman 导数 ($D_{\\mathrm{HF}}$)**：该定理指出 $\\frac{dE_k}{d\\kappa} = \\langle \\psi_k \\rvert \\frac{\\partial H}{\\partial \\kappa} \\rvert \\psi_k \\rangle$。对于给定的哈密顿量，$\\frac{\\partial H}{\\partial \\kappa} = V$。因此，基态的导数计算为相互作用算符 $V$ 在基态中的期望值：\n    $$\n    D_{\\mathrm{HF}}(\\kappa) = \\langle \\psi_0(\\kappa) \\rvert V \\rvert \\psi_0(\\kappa) \\rangle\n    $$\n    在计算上，这是二次型 $\\mathbf{v}_0^T \\mathbf{V} \\mathbf{v}_0$，其中 $\\mathbf{V}$ 是算符 $V$ 的矩阵，$\\mathbf{v}_0$ 是基态本征矢量。\n\n3.  **有限差分导数 ($D_{\\mathrm{FD}}$)**：导数也使用二阶中心有限差分公式进行近似：\n    $$\n    D_{\\mathrm{FD}}(\\kappa, h) = \\frac{E_0(\\kappa+h) - E_0(\\kappa-h)}{2h}\n    $$\n    为了计算 $E_0(\\kappa \\pm h)$，需要构建并对角化哈密顿量 $H(\\kappa+h)$ 和 $H(\\kappa-h)$。一个关键步骤是正确识别在 $\\kappa$ 的微扰值处基态 $E_0$ 的延续。由于能级会随着 $\\kappa$ 的变化而发生交叉或避免交叉，仅仅选择 $\\kappa \\pm h$ 处的最低本征值可能是错误的。问题指定了一种稳健的追踪方法：正确的本征值 $E_0(\\kappa \\pm h)$ 是其对应本征矢量与原始基态本征矢量 $\\lvert \\psi_0(\\kappa) \\rangle$ 具有最大绝对交叠（内积）的那个。\n\n最后，计算绝对误差 $|D_{\\mathrm{FD}}(\\kappa,h) - D_{\\mathrm{HF}}(\\kappa)|$ 以量化有限差分近似的准确性。\n\n#### 4. 数值误差分析\n\n有限差分近似的误差主要来自两个来源：\n\n-   **截断误差**：这是近似方法固有的误差，源于截断函数的泰勒级数展开。对于中心差分公式，主要误差项为 $O(h^2)$ 阶：\n    $$\n    D_{\\mathrm{FD}}(\\kappa, h) = \\frac{dE_0}{d\\kappa} + \\frac{h^2}{6}\\frac{d^3 E_0}{d\\kappa^3} + O(h^4)\n    $$\n    当步长 $h$ 减小时，此误差迅速（二次方）减小。\n\n-   **舍入误差**：此误差源于浮点运算的有限精度。当计算一个非常小的 $h$ 的差值 $E_0(\\kappa+h) - E_0(\\kappa-h)$ 时，这两项几乎相同。它们的相减会导致有效数字的损失，这被称为灾难性抵消。此误差与 $h$ 成反比，其尺度为 $O(\\epsilon/h)$，其中 $\\epsilon$ 是机器精度。\n\n总误差是这两个贡献之和，$Error(h) \\approx C_1 h^2 + C_2/h$。这意味着存在一个最优步长 $h_{opt}$，可以最小化总误差。提供的测试用例探讨了这种行为：\n-   情况 3 ($h=10^{-1}$): $h$ 很大，因此预计 $O(h^2)$ 的截断误差将占主导地位且较大。\n-   情况 1 ($h=10^{-3}$): $h$ 较小，因此截断误差应显著减小（比情况 3 小 $10^4$ 倍）。\n-   情况 2 ($h=10^{-6}$): $h$ 非常小，接近双精度算术的最优值。此时，误差预计是三者中最小的，因为截断误差变得可以忽略不计，而舍入误差尚未占主导地位。\n-   情况 4 ($\\kappa=0$): 在 $\\kappa=0$ 时，哈密顿量是对角的，基态是非简并的。微扰理论表明，$E_0(\\kappa)$ 在 $\\kappa=0$ 附近是 $\\kappa$ 的偶函数（即，$E_0(\\kappa) \\approx E_0(0) + C\\kappa^2$）。因此，其在 $\\kappa=0$ 处的导数精确为零。$D_{\\mathrm{HF}}(0)$ 和 $D_{\\mathrm{FD}}(0, h)$ 的计算结果都应接近于零，导致误差接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef generate_basis(N, num_modes):\n    \"\"\"\n    Generates all occupation-number basis states for N bosons in num_modes.\n    An occupation state is a tuple (n_1, n_2, ..., n_num_modes) such that sum(n_i) = N.\n    \"\"\"\n    if num_modes == 1:\n        if N >= 0:\n            yield (N,)\n        return\n\n    for n in range(N + 1):\n        for rest in generate_basis(N - n, num_modes - 1):\n            yield (n,) + rest\n\ndef calculate_error(N, eps_s, eps_d, kappa, h):\n    \"\"\"\n    Performs the main calculation for a given set of parameters.\n    \"\"\"\n    num_d_modes = 5\n    num_total_modes = 1 + num_d_modes\n    \n    basis = list(generate_basis(N, num_total_modes))\n    state_to_idx = {state: i for i, state in enumerate(basis)}\n    dim = len(basis)\n\n    # Construct H0 and V matrices once\n    h0_diag = np.zeros(dim)\n    v_mat = np.zeros((dim, dim))\n\n    for i, state_i in enumerate(basis):\n        n_s_i = state_i[0]\n        n_d_total_i = N - n_s_i\n        h0_diag[i] = eps_s * n_s_i + eps_d * n_d_total_i\n        \n        # Interaction V = sum(s^+ d_m + d_m^+ s)\n        # Action of d_m^+ s (connects |i> to |j> where n_s is smaller)\n        if n_s_i > 0:\n            for m_idx in range(num_d_modes):\n                n_dm_i = state_i[m_idx + 1]\n                \n                new_state_list = list(state_i)\n                new_state_list[0] -= 1\n                new_state_list[m_idx + 1] += 1\n                state_j = tuple(new_state_list)\n                \n                if state_j in state_to_idx:\n                    j = state_to_idx[state_j]\n                    amp = np.sqrt(n_s_i) * np.sqrt(n_dm_i + 1)\n                    v_mat[j, i] += amp\n                    v_mat[i, j] += amp # V is symmetric\n\n    h0_mat = np.diag(h0_diag)\n\n    # --- Calculations for D_HF ---\n    H_kappa = h0_mat + kappa * v_mat\n    eigvals, eigvecs = eigh(H_kappa)\n    # Ground state is the one with the lowest eigenvalue\n    gs_idx = np.argmin(eigvals)\n    E0_kappa = eigvals[gs_idx]\n    psi0_kappa = eigvecs[:, gs_idx]\n    \n    D_HF = psi0_kappa.T @ v_mat @ psi0_kappa\n\n    # --- Calculations for D_FD ---\n    # At kappa + h\n    H_k_plus_h = h0_mat + (kappa + h) * v_mat\n    eigvals_p, eigvecs_p = eigh(H_k_plus_h)\n    \n    # At kappa - h\n    H_k_minus_h = h0_mat + (kappa - h) * v_mat\n    eigvals_m, eigvecs_m = eigh(H_k_minus_h)\n    \n    # Find correct ground states by overlap with the original psi0_kappa\n    overlaps_p = np.abs(psi0_kappa.T @ eigvecs_p)\n    idx_p = np.argmax(overlaps_p)\n    E0_k_plus_h = eigvals_p[idx_p]\n    \n    overlaps_m = np.abs(psi0_kappa.T @ eigvecs_m)\n    idx_m = np.argmax(overlaps_m)\n    E0_k_minus_h = eigvals_m[idx_m]\n    \n    D_FD = (E0_k_plus_h - E0_k_minus_h) / (2 * h)\n\n    return abs(D_FD - D_HF)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (0.2, 1e-3),\n        (0.2, 1e-6),\n        (0.2, 1e-1),\n        (0.0, 1e-3),\n        (0.5, 1e-3),\n    ]\n    N = 3\n    eps_s = 0.0\n    eps_d = 1.0\n\n    errors = []\n    for kappa, h in test_cases:\n        error = calculate_error(N, eps_s, eps_d, kappa, h)\n        errors.append(error)\n\n    print(f\"[{','.join(f'{e:.15e}' for e in errors)}]\")\n\nsolve()\n```", "id": "3576651"}]}