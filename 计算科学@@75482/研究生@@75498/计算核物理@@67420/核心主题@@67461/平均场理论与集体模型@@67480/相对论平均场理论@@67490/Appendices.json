{"hands_on_practices": [{"introduction": "相对论平均场（RMF）理论的基石是描述核子与介子场相互作用的相对论性拉格朗日量。为了将该理论应用于真实的原子核，我们必须引入电磁相互作用。本练习 ([@problem_id:3587761]) 将引导您通过局域规范不变性这一基本原理，将电磁场耦合到系统中，并利用诺特定理推导出守恒的质子电磁流。这是理解RMF理论如何与现代场论的基本原则相结合的关键一步。", "problem": "考虑一个核子同位旋二重态的 Dirac 场 $\\psi(x) = \\begin{pmatrix} \\psi_{p}(x) \\\\ \\psi_{n}(x) \\end{pmatrix}$，其中 $\\psi_{p}$ 和 $\\psi_{n}$ 分别是质子和中子分量。在相对论平均场 (RMF) 理论中，核子与经典介子平均场相互作用。忽略同位旋矢量介子，只包括一个同位旋标量场 $\\sigma(x)$ 和一个同位旋标量矢量场 $\\omega_{\\mu}(x)$，在没有电磁场的情况下，拉格朗日密度中的核子部分为\n$$\n\\mathcal{L}_{\\text{N}} = \\bar{\\psi}\\left(i\\gamma^{\\mu}\\partial_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi,\n$$\n其中 $\\gamma^{\\mu}$ 是 Dirac γ 矩阵， $M$ 是裸核子质量， $g_{\\sigma}$ 和 $g_{\\omega}$ 是介子-核子耦合常数。同位旋算符 $\\tau_{3}$ 作用于二重态分量，对质子的本征值为 $+1$，对中子的本征值为 $-1$。\n\n使用电磁 $U(1)$ 群下的局域规范不变性原理以及在 Dirac 拉格朗日量层面上的最小替换规则，引入仅与质子分量耦合的电磁四维势 $A_{\\mu}(x)$，其耦合常数为 $e$。在本问题中，约定作用于核子二重态的电荷算符为 $Q = \\frac{1+\\tau_{3}}{2}$。从局域规范不变性、协变导数和连续对称性的 Noether 定理等基本定义出发，并且不引用任何预先推导好的目标表达式，完成以下任务：\n\n1. 将由 $Q$ 生成的全局电磁相移对称性提升为局域对称性 $\\psi(x) \\to \\exp\\!\\left(i e \\alpha(x) Q\\right)\\psi(x)$，并通过在核子动能项中进行最小替换来引入电磁场。写出规范不变的核子-电磁拉格朗日密度，保持介子平均场不变，并添加电磁场强度 $F_{\\mu\\nu} = \\partial_{\\mu}A_{\\nu} - \\partial_{\\nu}A_{\\mu}$ 的标准动能项。\n\n2. 通过将 Noether 定理应用于电磁对称性的全局版本，从第一性原理推导与质子分量相关的守恒电磁流，并明确地简化结果，使其仅用质子 Dirac 场和 γ 矩阵表示。你可以使用由你的规范不变拉格朗日量所蕴含的核子运动方程来验证流守恒，但你最终的流表达式必须直接从对称性考虑中获得，而不是通过反向工程运动方程得到。\n\n将守恒的质子电磁四维流密度以单一的封闭形式解析表达式给出。不需要进行数值计算。答案必须是单一表达式，并且在最终答案框内不得包含任何单位。", "solution": "我们从包含同位旋标量平均场的核子拉格朗日量开始，\n$$\n\\mathcal{L}_{\\text{N}} = \\bar{\\psi}\\left(i\\gamma^{\\mu}\\partial_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi,\n$$\n其中 $\\psi$ 是同位旋二重态，与 $\\sigma$ 和 $\\omega_{\\mu}$ 的相互作用是同位旋标量的，即在同位旋空间中与单位矩阵成正比。引入电磁学的基本依据是在电磁 $U(1)$ 下的局域不变性要求，该变换作用于核子二重态，其生成元为\n$$\nQ = \\frac{1+\\tau_{3}}{2}.\n$$\n该算符投影到质子分量上：$Q\\psi = \\begin{pmatrix} \\psi_{p} \\\\ 0 \\end{pmatrix}$，因为 $\\tau_{3}\\psi_{p} = +\\psi_{p}$ 且 $\\tau_{3}\\psi_{n} = -\\psi_{n}$。\n\n对称性原理指出，在参数为 $\\alpha(x)$ 的局域 $U(1)$ 电磁变换下，核子场的变换为\n$$\n\\psi(x) \\to \\psi'(x) = \\exp\\!\\left(i e \\alpha(x) Q\\right)\\psi(x),\n\\quad\n\\bar{\\psi}(x) \\to \\bar{\\psi}'(x) = \\bar{\\psi}(x)\\exp\\!\\left(-i e \\alpha(x) Q\\right),\n$$\n其中 $e$ 是基本电荷。为了在该局域变换下保持动能项的不变性，我们通过引入协变导数来实现最小替换\n$$\nD_{\\mu} = \\partial_{\\mu} + i e A_{\\mu}(x) Q,\n$$\n并在核子动能项中用 $D_{\\mu}$ 替换 $\\partial_{\\mu}$。规范场的变换为\n$$\nA_{\\mu}(x) \\to A'_{\\mu}(x) = A_{\\mu}(x) - \\partial_{\\mu}\\alpha(x),\n$$\n从而确保 $D_{\\mu}\\psi$ 协变地变换：$D_{\\mu}\\psi \\to \\exp\\!\\left(i e \\alpha Q\\right)D_{\\mu}\\psi$。\n\n因此，规范不变的核子-电磁拉格朗日密度，辅以电磁场强度的标准 Maxwell 项，为\n$$\n\\mathcal{L} = \\bar{\\psi}\\left(i\\gamma^{\\mu}D_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - \\left(M - g_{\\sigma}\\sigma\\right)\\right)\\psi \\;-\\; \\frac{1}{4}F_{\\mu\\nu}F^{\\mu\\nu},\n$$\n其中\n$$\nD_{\\mu} = \\partial_{\\mu} + i e A_{\\mu} Q, \\quad Q = \\frac{1+\\tau_{3}}{2}.\n$$\n展开协变导数项，我们得到\n$$\n\\bar{\\psi}\\, i\\gamma^{\\mu}D_{\\mu}\\psi\n= \\bar{\\psi}\\, i\\gamma^{\\mu}\\partial_{\\mu}\\psi - e\\,\\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi\\, A_{\\mu}.\n$$\n核子与电磁场之间的相互作用部分则为\n$$\n\\mathcal{L}_{\\text{int, em}} = - e\\,\\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi\\, A_{\\mu}.\n$$\n\n为了从第一性原理推导守恒流，我们使用 Noether 定理处理电磁对称性的全局版本。考虑一个具有常数参数 $\\epsilon$ 的全局变换，即，\n$$\n\\delta\\psi = i e \\epsilon\\, Q\\,\\psi, \\qquad \\delta\\bar{\\psi} = - i e \\epsilon\\, \\bar{\\psi}\\, Q,\n$$\n并且 $A_{\\mu}$ 固定（对于全局对称性没有变换）。与该内部对称性相关的 Noether 流由下式给出\n$$\nj^{\\mu} = \\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\psi\\right)}\\,\\delta\\psi + \\delta\\bar{\\psi}\\,\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\bar{\\psi}\\right)}.\n$$\n在 Dirac 型拉格朗日量中，$\\mathcal{L}$ 依赖于 $\\partial_{\\mu}\\psi$ 但不依赖于 $\\partial_{\\mu}\\bar{\\psi}$，所以 $\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\bar{\\psi}\\right)}=0$。使用\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial\\left(\\partial_{\\mu}\\psi\\right)} = i\\,\\bar{\\psi}\\,\\gamma^{\\mu},\n$$\n我们发现\n$$\nj^{\\mu} = i\\,\\bar{\\psi}\\,\\gamma^{\\mu}\\,(i e \\epsilon\\, Q)\\,\\psi = e \\epsilon\\, \\bar{\\psi}\\,\\gamma^{\\mu} Q\\,\\psi.\n$$\n去掉任意常数 $\\epsilon$（Noether 流的定义可以相差一个由对称性参数固定的整体因子），与核子二重态相关的电磁流密度为\n$$\nj_{\\text{em}}^{\\mu}(x) = e\\,\\bar{\\psi}(x)\\,\\gamma^{\\mu}\\,Q\\,\\psi(x).\n$$\n由于 $Q$ 投影到质子分量上，该表达式简化为质子流。明确写出质子场，$Q\\psi = \\begin{pmatrix}\\psi_{p}\\\\0\\end{pmatrix}$ 和 $\\bar{\\psi}Q = \\begin{pmatrix}\\bar{\\psi}_{p}  0\\end{pmatrix}$，我们得到\n$$\nj_{p}^{\\mu}(x) = e\\,\\bar{\\psi}_{p}(x)\\,\\gamma^{\\mu}\\,\\psi_{p}(x).\n$$\n\n使用运动方程来验证守恒性是很有启发性的。从 $\\mathcal{L}$ 推导出的质子分量的 Euler–Lagrange 方程为\n$$\n\\left(i\\gamma^{\\mu}D_{\\mu} - g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} - M^{\\ast}\\right)\\psi_{p} = 0, \\qquad M^{\\ast} \\equiv M - g_{\\sigma}\\sigma,\n$$\n其中 $D_{\\mu} = \\partial_{\\mu} + i e A_{\\mu}$ 作用于质子。其共轭方程为\n$$\n\\bar{\\psi}_{p}\\left(i\\overleftarrow{D}_{\\mu}\\gamma^{\\mu} + g_{\\omega}\\gamma^{\\mu}\\omega_{\\mu} + M^{\\ast}\\right) = 0,\n$$\n其中 $\\overleftarrow{D}_{\\mu} = \\overleftarrow{\\partial}_{\\mu} - i e A_{\\mu}$。取流的散度，\n$$\n\\partial_{\\mu} j_{p}^{\\mu} = e\\left[(\\partial_{\\mu}\\bar{\\psi}_{p})\\gamma^{\\mu}\\psi_{p} + \\bar{\\psi}_{p}\\gamma^{\\mu}(\\partial_{\\mu}\\psi_{p})\\right],\n$$\n并从运动方程中代入 $\\partial_{\\mu}\\psi_{p}$ 和 $\\partial_{\\mu}\\bar{\\psi}_{p}$（分离出协变部分，并使用 $\\gamma^{\\mu}$ 与数的反对易性质以及同位旋标量耦合的厄米性），各项成对抵消，得到\n$$\n\\partial_{\\mu} j_{p}^{\\mu} = 0.\n$$\n因此，从 Noether 定理得到的质子电磁流是守恒的，正如规范不变性所要求的那样。\n\n因此，在 RMF 框架下，通过最小电磁耦合得到的守恒质子电磁四维流密度为\n$$\nj_{p}^{\\mu}(x) = e\\,\\bar{\\psi}_{p}(x)\\,\\gamma^{\\mu}\\,\\psi_{p}(x).\n$$\n这是一个用质子 Dirac 场和 γ 矩阵表示的封闭形式解析表达式，它是从局域 $U(1)$ 规范不变性和 Noether 定理的基本对称性原理推导出来的。", "answer": "$$\\boxed{e\\,\\bar{\\psi}_{p}\\,\\gamma^{\\mu}\\,\\psi_{p}}$$", "id": "3587761"}, {"introduction": "RMF理论的一个核心优势在于它能够连接核子相互作用的微观世界与核物质的宏观可观测量。本练习 ([@problem_id:3587624]) 将通过计算朗道有效质量 $m_{L}^{\\ast}$ 来探索这一联系。您将看到这个源于单粒子能谱的物理量，如何直接决定费米面上的单粒子能级密度，并最终决定系统在低温下的比热容，从而揭示了微观动力学与宏观热力学性质之间的深刻关系。", "problem": "考虑由相对论平均场（RMF）理论描述的，在有限但低温下的均匀、同位旋对称的核物质，其中的核子准粒子在空间均匀的标量和矢量平均场中运动。在自然单位制（$\\hbar=c=k_B=1$）下，单粒子色散关系为\n$$\nE(p)=\\Sigma^{0}+\\sqrt{p^{2}+\\left(M+\\Sigma_{S}\\right)^{2}},\n$$\n其中 $M$ 是自由核子质量，$\\Sigma_{S}=-g_{\\sigma}\\,\\sigma_{0}$ 是标量自能，$\\Sigma^{0}=g_{\\omega}\\,\\omega_{0}$ 是矢量自能的时间分量。定义狄拉克有效质量为 $M^{\\ast}\\equiv M+\\Sigma_{S}=M-g_{\\sigma}\\,\\sigma_{0}$。设系统具有自旋-同位旋简并度 $\\gamma=4$，重子数密度为 $n=\\gamma\\,k_{F}^{3}/(6\\pi^{2})$，该式定义了零温下的费米动量 $k_{F}$。\n\n仅使用费米液体理论和RMF的核心定义和经过充分检验的事实，完成以下任务：\n\n1) 将费米面上的朗道有效质量定义为 $m_{L}^{\\ast}\\equiv p_{F}/v_{F}$，其中 $v_{F}=(\\partial E/\\partial p)|_{p=k_{F}}$ 是费米面上的群速度。计算 $m_{L}^{\\ast}$ 的闭合形式表达式，用 $k_{F}$ 和 $M^{\\ast}$ 表示。\n\n2) 使用单位体积内费米面上的单粒子能级密度定义，\n$$\ng(E_{F})=\\gamma\\int\\frac{d^{3}p}{(2\\pi)^{3}}\\,\\delta\\!\\left(E_{F}-E(p)\\right),\n$$\n将 $g(E_{F})$ 用 $k_{F}$ 和 $m_{L}^{\\ast}$ 表示。\n\n3) 在 $T\\ll E_{F}^{\\ast}$ 的低温区，其中 $E_{F}^{\\ast}$ 是相对于矢量平均场测量的费米能，使用标准的费米液体低温结果，将单位体积的定容比热 $C_{V}/V$ 与 $g(E_{F})$ 和 $T$ 联系起来，然后将每个重子的比热 $c_{V}/n$ 用 $k_{F}$ 和 $m_{L}^{\\ast}$ 表示。\n\n将你的最终答案写成 $m_{L}^{\\ast}$ 关于 $k_{F}$、$M$、$g_{\\sigma}$ 和 $\\sigma_{0}$ 的解析表达式。在整个过程中使用自然单位制（$\\hbar=c=k_{B}=1$）。", "solution": "我们按顺序完成问题要求的三个任务，并构建最终答案。\n\n**1) 朗道有效质量 $m_{L}^{\\ast}$ 的计算**\n\n费米面上的朗道有效质量定义为 $m_{L}^{\\ast} \\equiv p_{F}/v_{F}$。按照标准做法，我们将费米动量 $p_F$ 等同于零温费米动量 $k_F$。因此，$m_{L}^{\\ast} = k_{F}/v_{F}$。\n\n费米速度 $v_{F}$ 是在费米动量处计算的群速度，$v_{F} = (\\partial E/\\partial p)|_{p=k_{F}}$。单粒子能量由下式给出：\n$$\nE(p)=\\Sigma^{0}+\\sqrt{p^{2}+\\left(M+\\Sigma_{S}\\right)^{2}}\n$$\n使用狄拉克有效质量的定义，$M^{\\ast} = M + \\Sigma_{S}$，上式变为：\n$$\nE(p)=\\Sigma^{0}+\\sqrt{p^{2}+M^{\\ast 2}}\n$$\n我们计算 $E(p)$ 对动量大小 $p$ 的导数：\n$$\n\\frac{\\partial E}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\Sigma^{0}+\\sqrt{p^{2}+M^{\\ast 2}} \\right) = \\frac{1}{2\\sqrt{p^{2}+M^{\\ast 2}}} \\cdot (2p) = \\frac{p}{\\sqrt{p^{2}+M^{\\ast 2}}}\n$$\n矢量自能 $\\Sigma^0$ 和狄拉克质量 $M^*$ 与动量 $p$ 无关。\n在费米动量 $p=k_F$ 处计算该导数，得到费米速度：\n$$\nv_{F} = \\left.\\frac{\\partial E}{\\partial p}\\right|_{p=k_{F}} = \\frac{k_{F}}{\\sqrt{k_{F}^{2}+M^{\\ast 2}}}\n$$\n现在，我们将 $v_F$ 的这个表达式代入朗道有效质量的定义中：\n$$\nm_{L}^{\\ast} = \\frac{k_{F}}{v_{F}} = \\frac{k_{F}}{k_{F}/\\sqrt{k_{F}^{2}+M^{\\ast 2}}} = \\sqrt{k_{F}^{2}+M^{\\ast 2}}\n$$\n这就是用 $k_F$ 和 $M^{\\ast}$ 表示的朗道有效质量的表达式。\n\n**2) 费米面上的能级密度 $g(E_{F})$**\n\n单位体积内，在费米能量 $E_F = E(k_F)$ 处的单粒子能级密度（或态密度）由下式给出：\n$$\ng(E_{F})=\\gamma\\int\\frac{d^{3}p}{(2\\pi)^{3}}\\,\\delta\\!\\left(E_{F}-E(p)\\right)\n$$\n为了计算这个积分，我们在动量空间中切换到球坐标，其中 $d^3p = 4\\pi p^2 dp$。\n$$\ng(E_{F}) = \\gamma \\int_{0}^{\\infty} \\frac{4\\pi p^2 dp}{(2\\pi)^3} \\delta(E(p) - E_F) = \\frac{\\gamma}{2\\pi^2} \\int_{0}^{\\infty} p^2 \\delta(E(p) - E_F) dp\n$$\n使用狄拉克 $\\delta$ 函数的性质 $\\int f(x)\\delta(h(x))dx = \\sum_i \\frac{f(x_i)}{|h'(x_i)|}$，其中 $h(x_i)=0$，我们将 $p$ 确定为积分变量，$h(p) = E(p) - E_F$，$f(p)=p^2$。根是 $p=k_F$ 因为 $E(k_F)=E_F$。导数是 $h'(p) = dE/dp$。\n$$\ng(E_{F}) = \\frac{\\gamma}{2\\pi^2} \\left[ \\frac{p^2}{|dE/dp|} \\right]_{p=k_{F}}\n$$\n在费米面上，$p=k_F$ 且 $|dE/dp|_{p=k_F} = v_F$。\n$$\ng(E_{F}) = \\frac{\\gamma k_{F}^2}{2\\pi^2 v_{F}}\n$$\n题目要求用 $k_F$ 和 $m_L^{\\ast}$ 表示此式。使用关系式 $m_{L}^{\\ast} = k_F / v_F$，我们有 $1/v_F = m_L^{\\ast} / k_F$。将其代入 $g(E_F)$ 的表达式中：\n$$\ng(E_{F}) = \\frac{\\gamma k_{F}^2}{2\\pi^2} \\left(\\frac{m_{L}^{\\ast}}{k_{F}}\\right) = \\frac{\\gamma k_{F} m_{L}^{\\ast}}{2\\pi^2}\n$$\n\n**3) 每个重子的比热 $c_{V}/n$**\n\n在低温极限下（$T \\ll E_F^{\\ast}$），费米液体的单位体积定容比热 $C_V/V$ 由著名的索末菲展开结果给出：\n$$\n\\frac{C_{V}}{V} = \\frac{\\pi^2}{3} g(E_{F}) T\n$$\n每个重子的比热 $c_V/n$ 通过将此量除以重子数密度 $n$ 得到：\n$$\n\\frac{c_V}{n} = \\frac{C_V/V}{n} = \\frac{1}{n} \\frac{\\pi^2}{3} g(E_{F}) T\n$$\n我们现在代入第2部分的 $g(E_F)$ 表达式和给定的 $n$ 表达式：\n$$\ng(E_F) = \\frac{\\gamma k_{F} m_{L}^{\\ast}}{2\\pi^2} \\quad \\text{和} \\quad n = \\frac{\\gamma k_{F}^3}{6\\pi^2}\n$$\n$$\n\\frac{c_V}{n} = \\left(\\frac{6\\pi^2}{\\gamma k_{F}^3}\\right) \\frac{\\pi^2}{3} \\left(\\frac{\\gamma k_{F} m_{L}^{\\ast}}{2\\pi^2}\\right) T\n$$\n我们通过约去公共项来简化上式：\n$$\n\\frac{c_V}{n} = \\frac{\\pi^2 m_{L}^{\\ast}}{k_{F}^2} T\n$$\n这样就完成了所要求的推导。\n\n**最终答案的构建**\n问题要求最终答案是 $m_L^{\\ast}$ 关于 $k_F$、$M$、$g_{\\sigma}$ 和 $\\sigma_0$ 的解析表达式。\n从第1部分，我们有：\n$$\nm_{L}^{\\ast} = \\sqrt{k_{F}^{2}+M^{\\ast 2}}\n$$\n使用给定的定义 $M^{\\ast} = M - g_{\\sigma}\\sigma_0$，我们将其代入 $m_L^{\\ast}$ 的表达式中：\n$$\nm_{L}^{\\ast} = \\sqrt{k_{F}^{2} + (M - g_{\\sigma}\\sigma_{0})^{2}}\n$$\n这就是需要报告的最终表达式。", "answer": "$$\n\\boxed{\\sqrt{k_{F}^{2} + (M - g_{\\sigma}\\sigma_{0})^{2}}}\n$$", "id": "3587624"}, {"introduction": "现代核物理学越来越依赖于复杂的统计方法，利用实验数据来约束理论模型的参数，例如耦合常数 $g_{\\sigma}$ 和 $g_{\\omega}$。然而，RMF模型的计算成本可能非常高昂，这给贝叶斯推断等大规模统计分析带来了挑战。这项高级练习 ([@problem_id:3587641]) 将向您介绍一种前沿的计算技术：构建高斯过程（GP）模拟器。您将学习如何创建一个快速且精确的RMF代理模型，并利用它来显著加速贝叶斯参数推断过程，从而有效地连接理论模型与实验观测。", "problem": "您需要为计算核物理中的相对论平均场（RMF）理论实现一个端到端的、基于模拟器的贝叶斯推断工作流。该模拟器必须是一个高斯过程（GP），它能将RMF可观测量预测为耦合参数向量的函数，并量化预测不确定性。然后，使用该模拟器通过在似然函数中用包含模拟器不确定性的GP预测分布替换昂贵的前向模型，从而加速贝叶斯推断。\n\n仅从以下基本概念出发：多元正态分布的定义、贝叶斯法则以及协方差核的定义。除了贝叶斯法则，不要假设任何预先推导的高斯过程回归方程或预先推导的贝叶斯公式。您在解决方案中使用的任何推导都必须源于这些基本概念。\n\n考虑一个双参数RMF模型，其参数向量为 $\\boldsymbol{\\theta} = (g_{\\sigma}, g_{\\omega})$，其中 $g_{\\sigma}$ 和 $g_{\\omega}$ 是无量纲耦合。定义一个计算成本低但有物理动机的RMF代理前向模型，该模型将 $\\boldsymbol{\\theta}$ 映射到两个可观测量：接近饱和的对称核物质的每核子结合能 $E$（单位为 $\\mathrm{MeV}$）和一个重核的电荷半径 $R$（单位为 $\\mathrm{fm}$）。该代理前向模型为\n$$\n\\begin{aligned}\nd(\\boldsymbol{\\theta}) = g_{\\sigma} - 0.85\\, g_{\\omega},\\\\\nE(\\boldsymbol{\\theta}) = -16.0 + 3.5\\,(d(\\boldsymbol{\\theta}) - 0.5) + 1.2\\,(d(\\boldsymbol{\\theta}) - 0.5)^2 - 0.15\\,(g_{\\sigma} - 10.0)\\,(g_{\\omega} - 11.0) \\\\\n\\quad + 0.02\\,(g_{\\sigma} - 10.0)^3 - 0.015\\,(g_{\\omega} - 11.0)^3,\\\\\nR(\\boldsymbol{\\theta}) = 5.5 + 0.03\\,(g_{\\omega} - 11.0) - 0.025\\,(g_{\\sigma} - 10.0) + 0.005\\,(g_{\\sigma} - 10.0)^2 + 0.004\\,(g_{\\omega} - 11.0)^2 \\\\\n\\quad - 0.006\\,(g_{\\sigma} - 10.0)\\,(g_{\\omega} - 11.0) + 0.0008\\,(g_{\\sigma} - 10.0)^3.\n\\end{aligned}\n$$\n您的GP模拟器必须对映射 $\\boldsymbol{\\theta} \\mapsto (E(\\boldsymbol{\\theta}), R(\\boldsymbol{\\theta}))$ 进行建模，并为任何查询 $\\boldsymbol{\\theta}$ 提供每个可观测量的预测均值和预测方差。使用一个零均值GP，其核函数为具有各向同性长度标度的平方指数（径向基函数）核。通过其预测方差来量化模拟器不确定性。为保证数值稳定性，在训练协方差矩阵的对角线上加入一个小的nugget（抖动）。\n\n训练数据：\n- 使用种子为 $13$ 的伪随机数生成器，从超矩形 $[8,12]\\times[8,12]$ 中均匀独立地抽取 $N = 80$ 个训练输入 $\\{\\boldsymbol{\\theta}_i\\}_{i=1}^{N}$。\n- 对于每个 $\\boldsymbol{\\theta}_i$，计算无噪声的训练目标 $\\mathbf{y}_i = (E(\\boldsymbol{\\theta}_i), R(\\boldsymbol{\\theta}_i))$，单位分别为 $\\mathrm{MeV}$ 和 $\\mathrm{fm}$。\n\n模拟器规范和预处理：\n- 在拟合GP之前，对训练集中的每个可观测量进行标准化，使其均值为零，方差为一。在进行似然评估时，将预测结果反标准化回物理单位。\n- 在标准化输出空间中使用平方指数核 $k(\\mathbf{x},\\mathbf{x}') = \\sigma_f^2 \\exp\\!\\big(-\\tfrac{1}{2}\\|\\mathbf{x}-\\mathbf{x}'\\|^2/\\ell^2\\big)$，其信号方差 $\\sigma_f^2 = 1$，各向同性长度标度 $\\ell = 1$。使用抖动 $\\sigma_n^2 = 10^{-6}$。\n- 为每个可观测量训练一个独立的GP。\n\n使用模拟器进行贝叶斯推断：\n- 对 $\\boldsymbol{\\theta}$ 使用高斯先验，其分量相互独立：$g_{\\sigma} \\sim \\mathcal{N}(10.0, 0.8^2)$ 和 $g_{\\omega} \\sim \\mathcal{N}(11.0, 0.8^2)$。\n- 对于一个观测值 $\\mathbf{y}^{\\mathrm{obs}} = (E^{\\mathrm{obs}}, R^{\\mathrm{obs}})$，其已知实验标准差为 $\\boldsymbol{\\sigma}^{\\mathrm{exp}} = (\\sigma_E, \\sigma_R)$，将在 $\\boldsymbol{\\theta}$ 处的似然近似为两个独立正态密度的乘积，一个用于 $E$，一个用于 $R$，每个的方差等于实验方差与在 $\\boldsymbol{\\theta}$ 处的模拟器预测方差之和，即 $\\sigma_{\\mathrm{tot},j}^2(\\boldsymbol{\\theta}) = \\big(\\sigma^{\\mathrm{exp}}_j\\big)^2 + \\sigma^{2,\\mathrm{emu}}_j(\\boldsymbol{\\theta})$，其中 $j \\in \\{E,R\\}$。\n\n加速推断的测试套件：\n在均匀的参数网格上评估后验期望，以近似三个不同观测数据集的后验分布。使用 $[8,12]\\times[8,12]$（含端点）上的 $81\\times 81$ 网格进行数值积分。这三个观测数据集通过选择三个参数点并从前向模型生成合成数据（无附加噪声）以及指定的实验不确定性来定义：\n- 数据集 A（理想情况）：$\\boldsymbol{\\theta}_A = (10.2, 10.8)$，$\\mathbf{y}^{\\mathrm{obs}}_A = \\big(E(\\boldsymbol{\\theta}_A), R(\\boldsymbol{\\theta}_A)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_A = (0.4\\,\\mathrm{MeV}, 0.015\\,\\mathrm{fm})$。\n- 数据集 B（严苛数据）：$\\boldsymbol{\\theta}_B = (9.0, 11.8)$，$\\mathbf{y}^{\\mathrm{obs}}_B = \\big(E(\\boldsymbol{\\theta}_B), R(\\boldsymbol{\\theta}_B)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_B = (0.05\\,\\mathrm{MeV}, 0.003\\,\\mathrm{fm})$。\n- 数据集 C（边界情况）：$\\boldsymbol{\\theta}_C = (8.1, 12.0)$，$\\mathbf{y}^{\\mathrm{obs}}_C = \\big(E(\\boldsymbol{\\theta}_C), R(\\boldsymbol{\\theta}_C)\\big)$，$\\boldsymbol{\\sigma}^{\\mathrm{exp}}_C = (0.4\\,\\mathrm{MeV}, 0.020\\,\\mathrm{fm})$。\n\n对于每个数据集，在网格上使用先验和基于模拟器的似然来近似 $\\boldsymbol{\\theta}$ 的后验分布，并计算 $g_{\\sigma}$ 的后验均值：\n$$\n\\mathbb{E}[g_{\\sigma} \\mid \\mathbf{y}^{\\mathrm{obs}}] \\approx \\frac{\\sum_{k} g_{\\sigma}^{(k)} \\, w^{(k)}}{\\sum_{k} w^{(k)}},\n$$\n其中 $w^{(k)}$ 是在网格点 $\\boldsymbol{\\theta}^{(k)}$ 处的未归一化后验权重，求和遍及整个网格。\n\n要求的最终输出格式：\n- 您的程序必须生成单行文本，包含一个Python风格的列表，内含三个浮点数，对应于后验均值 $\\big[\\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_A], \\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_B], \\mathbb{E}[g_{\\sigma}\\mid \\mathbf{y}^{\\mathrm{obs}}_C]\\big]$，每个数四舍五入到 $6$ 位小数。由于 $g_{\\sigma}$ 是无量纲的，输出中不需要单位。\n- 格式示例：$\\big[\\text{float}_1,\\text{float}_2,\\text{float}_3\\big]$。\n\n角度单位不适用。问题中指定了物理单位并在内部使用：$E$ 的单位是 $\\mathrm{MeV}$，$R$ 的单位是 $\\mathrm{fm}$。\n\n您的实现必须是自包含的，并且必须严格按照所述的训练协议、模拟器规范和测试套件进行。代码不得要求任何外部输入。", "solution": "任务是为双参数相对论平均场（RMF）模型构建并使用一个高斯过程（GP）模拟器，以加速贝叶斯推断。该解决方案按要求从第一性原理出发进行开发：多元正态分布的定义、贝叶斯法则以及协方差核的定义。\n\n首先，我们为GP模拟器建立理论基础。高斯过程定义了函数上的一个分布，由一个均值函数 $m(\\boldsymbol{\\theta})$ 和一个协方差函数（或称核函数）$k(\\boldsymbol{\\theta}, \\boldsymbol{\\theta}')$ 指定。根据定义，任何有限的函数值集合都服从一个联合多元正态分布。对于本问题，我们使用零均值GP，因此 $m(\\boldsymbol{\\theta}) = 0$。核函数是平方指数函数 $k(\\boldsymbol{\\theta}, \\boldsymbol{\\theta}') = \\sigma_f^2 \\exp(-\\frac{1}{2}\\|\\boldsymbol{\\theta}-\\boldsymbol{\\theta}'\\|^2/\\ell^2)$，其超参数指定为 $\\sigma_f^2=1$ 和 $\\ell=1$。\n\n设训练数据由 $N$ 个输入-输出对组成，$\\mathcal{D} = \\{(\\boldsymbol{\\theta}_i, y_i)\\}_{i=1}^N$，其中 $\\boldsymbol{\\Theta} = \\{\\boldsymbol{\\theta}_i\\}_{i=1}^N$ 是训练输入的集合，$\\mathbf{y}$ 是相应输出的向量。我们希望预测在一个新的测试点 $\\boldsymbol{\\theta}_*$ 处的函数值 $y_*$。GP回归的核心思想是利用训练输出 $\\mathbf{y}$ 和测试输出 $y_*$ 的联合多元正态分布。为了保证数值稳定性，在训练协方差矩阵的对角线上添加一个小的抖动项 $\\sigma_n^2$。这可以解释为假设训练观测值上存在少量独立同分布的高斯噪声，使得 $\\mathbf{y} \\sim \\mathcal{N}(\\mathbf{f}, \\sigma_n^2 I)$，其中 $\\mathbf{f}$ 是真实的函数值。观测到的训练输出 $\\mathbf{y}$ 和在 $\\boldsymbol{\\theta}_*$ 处的潜在函数值 $f_*$ 的联合分布是：\n$$\n\\begin{pmatrix} \\mathbf{y} \\\\ f_* \\end{pmatrix} \\sim \\mathcal{N}\\left(\n\\mathbf{0},\n\\begin{pmatrix}\nK(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I  & K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*) \\\\\nK(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta}) & k(\\boldsymbol{\\theta}_*, \\boldsymbol{\\theta}_*)\n\\end{pmatrix}\n\\right)\n$$\n其中 $[K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta})]_{ij} = k(\\boldsymbol{\\theta}_i, \\boldsymbol{\\theta}_j)$，而 $K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*)$ 是一个列向量，其元素为 $k(\\boldsymbol{\\theta}_i, \\boldsymbol{\\theta}_*)$。\n\n预测分布 $p(f_*|\\mathcal{D}, \\boldsymbol{\\theta}_*)$ 是给定 $\\mathbf{y}$ 时 $f_*$ 的条件分布。使用多元正态分布的条件化公式，其中 $\\begin{pmatrix} \\mathbf{x}_1 \\\\ \\mathbf{x}_2 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} \\boldsymbol{\\mu}_1 \\\\ \\boldsymbol{\\mu}_2 \\end{pmatrix}, \\begin{pmatrix} \\Sigma_{11} & \\Sigma_{12} \\\\ \\Sigma_{21} & \\Sigma_{22} \\end{pmatrix} \\right)$ 会导出 $\\mathbf{x}_1 | \\mathbf{x}_2 \\sim \\mathcal{N}(\\boldsymbol{\\mu}_1 + \\Sigma_{12}\\Sigma_{22}^{-1}(\\mathbf{x}_2 - \\boldsymbol{\\mu}_2), \\Sigma_{11} - \\Sigma_{12}\\Sigma_{22}^{-1}\\Sigma_{21})$，我们识别出 $\\mathbf{x}_1 \\to f_*$，$\\mathbf{x}_2 \\to \\mathbf{y}$，以及各自的均值和协方差块。由于先验均值为零， $f_*$ 的预测均值 $\\mu_*$ 和预测方差 $\\sigma_*^2$ 为：\n$$\n\\mu_*(\\boldsymbol{\\theta}_*) = K(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta}) [K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} \\mathbf{y}\n$$\n$$\n\\sigma_*^2(\\boldsymbol{\\theta}_*) = k(\\boldsymbol{\\theta}_*, \\boldsymbol{\\theta}_*) - K(\\boldsymbol{\\theta}_*, \\boldsymbol{\\Theta}) [K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} K(\\boldsymbol{\\Theta}, \\boldsymbol{\\theta}_*)\n$$\n这个 $\\sigma_*^2(\\boldsymbol{\\theta}_*)$ 就是模拟器的预测方差 $\\sigma^{2,\\text{emu}}(\\boldsymbol{\\theta}_*)$，它量化了模拟器的不确定性。\n\n问题要求为两个可观测量 $E$ 和 $R$ 训练独立的GP。在拟合之前，每个可观测量的训练数据都被标准化为零均值和单位标准差。设原始训练输出为 $\\{y_i\\}$，其样本均值为 $\\mu_y$，样本标准差为 $\\sigma_y$。标准化后的输出为 $y_i^{\\text{std}} = (y_i - \\mu_y) / \\sigma_y$。GP在这些标准化值上进行训练。在 $\\boldsymbol{\\theta}_*$ 处的预测会产生一个标准化的均值 $\\mu_*^{\\text{std}}$ 和方差 $(\\sigma_*^{\\text{std}})^2$。这些值需要被反标准化回物理单位：\n$$\n\\mu_*^{\\text{phys}}(\\boldsymbol{\\theta}_*) = \\mu_*^{\\text{std}}(\\boldsymbol{\\theta}_*) \\cdot \\sigma_y + \\mu_y\n$$\n$$\n\\sigma^{2,\\text{emu}}(\\boldsymbol{\\theta}_*) = (\\sigma_*^{\\text{std}}(\\boldsymbol{\\theta}_*))^2 \\cdot \\sigma_y^2\n$$\n\n接下来，我们构建贝叶斯推断。目标是估计在给定观测值 $\\mathbf{y}^{\\mathrm{obs}} = (E^{\\mathrm{obs}}, R^{\\mathrm{obs}})$ 的情况下参数 $\\boldsymbol{\\theta}$ 的后验分布。根据贝叶斯法则：\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}^{\\mathrm{obs}}) \\propto p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\n$$\n先验 $p(\\boldsymbol{\\theta})$ 被给定为 $g_{\\sigma}$ 和 $g_{\\omega}$ 的独立正态分布的乘积。似然 $p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta})$ 是使用GP模拟器的地方。模拟器为在参数点 $\\boldsymbol{\\theta}$ 处的可观测量 $y_j$ 的真实值提供了一个预测分布，即 $\\mathcal{N}(y_j | \\mu_{j,*}^{\\text{phys}}(\\boldsymbol{\\theta}), \\sigma_{j,\\text{emu}}^{2}(\\boldsymbol{\\theta}))$。观测值 $y_j^{\\mathrm{obs}}$ 具有实验不确定性，建模为 $y_j^{\\mathrm{obs}} \\sim \\mathcal{N}(y_j, (\\sigma_j^{\\text{exp}})^2)$。在 $\\boldsymbol{\\theta}$ 处观测值 $y_j^{\\mathrm{obs}}$ 的边缘似然是这两个高斯分布的卷积，结果是另一个高斯分布，其均值和方差相加：\n$$\np(y_j^{\\mathrm{obs}} | \\boldsymbol{\\theta}) = \\mathcal{N}\\left( y_j^{\\mathrm{obs}} \\mid \\mu_{j,*}^{\\text{phys}}(\\boldsymbol{\\theta}), \\left( \\sigma_j^{\\mathrm{exp}} \\right)^2 + \\sigma_{j,\\text{emu}}^{2}(\\boldsymbol{\\theta}) \\right)\n$$\n假设可观测量 $E$ 和 $R$ 是独立的，总似然是它们的乘积：\n$$\np(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}) = p(E^{\\mathrm{obs}} | \\boldsymbol{\\theta}) \\cdot p(R^{\\mathrm{obs}} | \\boldsymbol{\\theta})\n$$\n后验分布在一个离散的 $\\boldsymbol{\\theta}^{(k)}$ 点网格上进行近似。在每个点上，我们计算未归一化的后验权重 $w^{(k)} = p(\\mathbf{y}^{\\mathrm{obs}} | \\boldsymbol{\\theta}^{(k)}) p(\\boldsymbol{\\theta}^{(k)})$。然后，$g_{\\sigma}$ 的后验期望通过网格上的加权和来近似：\n$$\n\\mathbb{E}[g_{\\sigma} \\mid \\mathbf{y}^{\\mathrm{obs}}] \\approx \\frac{\\sum_{k} g_{\\sigma}^{(k)} \\, w^{(k)}}{\\sum_{k} w^{(k)}}\n$$\n\n实现步骤如下：\n1. 定义用于 $E(\\boldsymbol{\\theta})$ 和 $R(\\boldsymbol{\\theta})$ 的RMF代理前向模型函数。\n2. 使用指定的随机种子，从 $[8, 12] \\times [8, 12]$ 上的均匀分布中生成 $N=80$ 个训练点 $\\{\\boldsymbol{\\theta}_i\\}$。\n3. 计算相应的训练输出 $\\mathbf{y}_i = (E(\\boldsymbol{\\theta}_i), R(\\boldsymbol{\\theta}_i))$。\n4. 对每个可观测量（$E$ 和 $R$）：\n   a. 标准化训练输出。\n   b. 构建GP核矩阵 $K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta})$ 并添加抖动 $\\sigma_n^2 I$。\n   c. 预计算矩阵向量积 $[K(\\boldsymbol{\\Theta}, \\boldsymbol{\\Theta}) + \\sigma_n^2 I]^{-1} \\mathbf{y}^{\\text{std}}$ 以实现高效的均值预测。\n5. 定义测试用例（数据集 A, B, C），并生成合成观测值 $\\mathbf{y}^{\\mathrm{obs}}$ 及其相关的实验不确定性 $\\boldsymbol{\\sigma}^{\\text{exp}}$。\n6. 创建一个在 $[8,12]\\times[8,12]$ 上的 $81 \\times 81$ 的 $\\boldsymbol{\\theta}$ 值网格。\n7. 对于每个数据集：\n   a. 在每个网格点上评估先验概率密度。\n   b. 对每个网格点，使用训练好的GP来预测 $E$ 和 $R$ 的均值和方差。对这些预测进行反标准化。\n   c. 使用实验方差和模拟器方差之和，在每个网格点上计算基于模拟器的似然。\n   d. 将先验和似然相乘以获得未归一化的后验权重。\n   e. 使用加权和公式计算 $g_{\\sigma}$ 的后验均值。\n8. 收集并格式化三个数据集的结果。\n\n这个分步过程提供了一个完整、合理且数值稳定的算法来解决所述问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.spatial.distance import cdist\n\n# --- 1. Problem Definition ---\n\ndef rmf_proxy_model(theta):\n    \"\"\"\n    Computes the RMF proxy model observables E and R.\n    \n    Args:\n        theta (np.ndarray): Array of shape (n, 2) or (2,) with parameters (g_sigma, g_omega).\n        \n    Returns:\n        np.ndarray: Array of shape (n, 2) or (2,) with observables (E, R).\n    \"\"\"\n    if theta.ndim == 1:\n        theta = theta.reshape(1, -1)\n    \n    g_sigma = theta[:, 0]\n    g_omega = theta[:, 1]\n    \n    d = g_sigma - 0.85 * g_omega\n    \n    E = -16.0 + 3.5 * (d - 0.5) + 1.2 * (d - 0.5)**2 \\\n        - 0.15 * (g_sigma - 10.0) * (g_omega - 11.0) \\\n        + 0.02 * (g_sigma - 10.0)**3 - 0.015 * (g_omega - 11.0)**3\n        \n    R = 5.5 + 0.03 * (g_omega - 11.0) - 0.025 * (g_sigma - 10.0) \\\n        + 0.005 * (g_sigma - 10.0)**2 + 0.004 * (g_omega - 11.0)**2 \\\n        - 0.006 * (g_sigma - 10.0) * (g_omega - 11.0) \\\n        + 0.0008 * (g_sigma - 10.0)**3\n        \n    return np.vstack((E, R)).T.squeeze()\n\n# --- 2. Gaussian Process Emulator ---\n\ndef squared_exponential_kernel(x1, x2, length_scale, signal_var):\n    \"\"\"Squared-exponential kernel.\"\"\"\n    sqdist = cdist(x1, x2, 'sqeuclidean')\n    return signal_var * np.exp(-0.5 * sqdist / length_scale**2)\n\nclass GPEmulator:\n    \"\"\"\n    A Gaussian Process emulator with a squared-exponential kernel.\n    Follows the derivation from first principles.\n    \"\"\"\n    def __init__(self, length_scale, signal_var, noise_var):\n        self.ell = length_scale\n        self.sigma_f2 = signal_var\n        self.sigma_n2 = noise_var\n        self.X_train = None\n        self.y_train_std = None\n        self.y_mean = 0.0\n        self.y_std = 1.0\n        self.alpha = None\n        self.K_inv = None\n\n    def fit(self, X_train, y_train):\n        \"\"\"\n        Trains the GP emulator.\n        \n        Args:\n            X_train (np.ndarray): Training inputs of shape (N, D).\n            y_train (np.ndarray): Training outputs of shape (N,).\n        \"\"\"\n        self.X_train = X_train\n        \n        # Standardize training data\n        self.y_mean = np.mean(y_train)\n        self.y_std = np.std(y_train)\n        if self.y_std == 0: self.y_std = 1.0 # Avoid division by zero\n        self.y_train_std = (y_train - self.y_mean) / self.y_std\n        \n        # Pre-compute matrices for prediction\n        K = squared_exponential_kernel(self.X_train, self.X_train, self.ell, self.sigma_f2)\n        K_nn = K + self.sigma_n2 * np.eye(len(self.X_train))\n        \n        # Solve (K + sigma_n^2*I) * alpha = y_train_std\n        # This is more numerically stable than inverting K_nn directly.\n        self.alpha = np.linalg.solve(K_nn, self.y_train_std)\n        self.K_inv = np.linalg.inv(K_nn) # Needed for variance calculation\n\n    def predict(self, X_test):\n        \"\"\"\n        Makes predictions at test points.\n        \n        Args:\n            X_test (np.ndarray): Test inputs of shape (M, D).\n            \n        Returns:\n            tuple: (mean, variance) of predictions, in physical units.\n        \"\"\"\n        if self.X_train is None:\n            raise RuntimeError(\"GP must be fitted before prediction.\")\n\n        k_star = squared_exponential_kernel(X_test, self.X_train, self.ell, self.sigma_f2)\n        \n        # Predictive mean (standardized)\n        mu_star_std = k_star @ self.alpha\n        \n        # Predictive variance (standardized)\n        k_star_star = self.sigma_f2 # Diagonal of k(X_test, X_test) is sigma_f^2 = 1\n        # The equation is k_** - k_*^T K_inv k_*. We compute (k_*^T @ K_inv) first.\n        v = np.linalg.solve(self.K_inv.T, k_star.T).T # More stable than using inv directly on K_inv\n        var_star_std = k_star_star - np.einsum('ij,ij->i', k_star, v)\n        \n        # De-standardize\n        mu_star_phys = mu_star_std * self.y_std + self.y_mean\n        var_star_phys = var_star_std * self.y_std**2\n        \n        return mu_star_phys, var_star_phys\n\n# --- 3. Main Bayesian Inference Workflow ---\n\ndef solve():\n    \"\"\"\n    Main function to run the entire emulator-based Bayesian inference.\n    \"\"\"\n    # --- Configuration ---\n    N_TRAIN = 80\n    RANDOM_SEED = 13\n    GRID_SIZE = 81\n    \n    # GP Hyperparameters\n    L_SCALE = 1.0\n    SIG_VAR = 1.0\n    NOISE_VAR = 1e-6\n    \n    # Prior definition\n    PRIOR_MEAN = np.array([10.0, 11.0])\n    PRIOR_STD = np.array([0.8, 0.8])\n    \n    # Inference grid\n    param_range = [8.0, 12.0]\n    g_sigma_grid = np.linspace(param_range[0], param_range[1], GRID_SIZE)\n    g_omega_grid = np.linspace(param_range[0], param_range[1], GRID_SIZE)\n    theta_grid_mesh = np.meshgrid(g_sigma_grid, g_omega_grid)\n    theta_grid = np.vstack([theta_grid_mesh[0].ravel(), theta_grid_mesh[1].ravel()]).T\n\n    # --- Training Data Generation ---\n    rng = np.random.default_rng(RANDOM_SEED)\n    theta_train = rng.uniform(param_range[0], param_range[1], size=(N_TRAIN, 2))\n    y_train_raw = rmf_proxy_model(theta_train)\n    \n    # --- Emulator Training ---\n    # Train separate GPs for E and R\n    gp_E = GPEmulator(length_scale=L_SCALE, signal_var=SIG_VAR, noise_var=NOISE_VAR)\n    gp_E.fit(theta_train, y_train_raw[:, 0])\n\n    gp_R = GPEmulator(length_scale=L_SCALE, signal_var=SIG_VAR, noise_var=NOISE_VAR)\n    gp_R.fit(theta_train, y_train_raw[:, 1])\n\n    # --- Test Cases and Inference ---\n    test_cases = [\n        # Dataset A\n        {'theta_obs': np.array([10.2, 10.8]), 'sigma_exp': np.array([0.4, 0.015])},\n        # Dataset B\n        {'theta_obs': np.array([9.0, 11.8]), 'sigma_exp': np.array([0.05, 0.003])},\n        # Dataset C\n        {'theta_obs': np.array([8.1, 12.0]), 'sigma_exp': np.array([0.4, 0.020])},\n    ]\n\n    results = []\n\n    # --- Calculations on the Grid (do once) ---\n    # Emulator predictions\n    mu_E_grid, var_E_emu_grid = gp_E.predict(theta_grid)\n    mu_R_grid, var_R_emu_grid = gp_R.predict(theta_grid)\n    # Prior\n    prior_vals = norm.pdf(theta_grid[:, 0], loc=PRIOR_MEAN[0], scale=PRIOR_STD[0]) * \\\n                 norm.pdf(theta_grid[:, 1], loc=PRIOR_MEAN[1], scale=PRIOR_STD[1])\n\n    for case in test_cases:\n        y_obs = rmf_proxy_model(case['theta_obs'])\n        sigma_exp = case['sigma_exp']\n\n        # Likelihood calculation on the grid\n        total_var_E = sigma_exp[0]**2 + var_E_emu_grid\n        total_var_R = sigma_exp[1]**2 + var_R_emu_grid\n\n        # Ensure variances are non-negative\n        total_var_E[total_var_E  0] = 1e-12\n        total_var_R[total_var_R  0] = 1e-12\n\n        like_E = norm.pdf(y_obs[0], loc=mu_E_grid, scale=np.sqrt(total_var_E))\n        like_R = norm.pdf(y_obs[1], loc=mu_R_grid, scale=np.sqrt(total_var_R))\n        likelihood_vals = like_E * like_R\n\n        # Posterior calculation\n        posterior_weights = likelihood_vals * prior_vals\n        \n        # Numerical integration for expectation\n        # Grid spacing is constant, so it cancels in the ratio\n        numerator = np.sum(theta_grid[:, 0] * posterior_weights)\n        denominator = np.sum(posterior_weights)\n        \n        if denominator == 0:\n            # This can happen if likelihood or prior is zero everywhere on the grid\n            post_mean_g_sigma = np.nan\n        else:\n            post_mean_g_sigma = numerator / denominator\n        \n        results.append(post_mean_g_sigma)\n\n    # --- Final Output Formatting ---\n    print(f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\")\n\nsolve()\n```", "id": "3587641"}]}