{"hands_on_practices": [{"introduction": "掌握Hartree-Fock方程迭代求解的第一步是亲手实现一个完整的自洽场（Self-Consistent Field, SCF）循环。这个练习将引导你完成这个核心过程：利用一个初始的密度矩阵来构建平均场哈密顿算符，然后通过对角化该算符来获得新的单粒子态。通过这个基础实践[@problem_id:3566777]，你将对自洽概念以及迭代求解背后的数值步骤建立起直观的理解。", "problem": "在计算核物理中，您将处理一个针对简单$2$能级模型的哈特里-福克方法下的自洽场 (SCF) 任务。起点是接触相互作用模型的哈特里-福克能量泛函，\n$$E[\\rho] = \\mathrm{Tr}(h_0 \\rho) + \\frac{g}{2}\\,\\mathrm{Tr}(\\rho^2),$$\n其中 $h_0$ 是一个以兆电子伏特 (MeV) 为单位的厄米 $2\\times 2$ 单体哈密顿量，$\\rho$ 是一个厄米 $2\\times 2$ 密度矩阵，对于 $N$ 个被占据的单粒子态，其迹 $\\mathrm{Tr}(\\rho)=N$，而 $g$ 是一个单位为 MeV 的标量耦合常数。自洽平均场哈密顿量由泛函导数定义，\n$$H[\\rho] = \\frac{\\partial E}{\\partial \\rho} = h_0 + g\\,\\rho.$$\n一个 SCF 循环包含以下步骤：\n- 根据初始密度 $\\rho^{(0)}$ 构建平均场哈密顿量 $H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$。\n- 求解矩阵本征值问题 $H C = C \\varepsilon$，得到标准正交本征矢量（$C$ 的列）和本征值（$\\varepsilon$ 的对角元）。\n- 通过占据能量最低的 $N$ 个单粒子态来更新密度，即定义\n$$\\rho^{(1)} = \\sum_{i=1}^{N} c_i c_i^\\top,$$\n其中 $c_i$ 是 $C$ 中对应最低 $N$ 个本征值的前 $N$ 列（简并情况可按任意一致的顺序处理）。\n- 报告残差范数\n$$r = \\lVert H C - C \\varepsilon \\rVert_F,$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数，定义为\n$$\\lVert X \\rVert_F = \\sqrt{\\sum_{i,j} X_{ij}^2}.$$\n\n您的任务是实现一个程序，为每个测试用例执行恰好一个 SCF 循环，并计算每个用例的残差范数 $r$。所有能量和报告的残差范数都必须以兆电子伏特 (MeV) 表示。此问题不涉及角度。没有百分比。最终结果必须是浮点数。\n\n请使用以下参数集测试套件。对于每个用例，$h_0$ 和 $\\rho^{(0)}$ 是实对称的（$2\\times 2$）矩阵，$g$ 是一个实标量，$N$ 是一个整数：\n- 用例 $1$（无相互作用，基准）：\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}.$$\n- 用例 $2$（中等相互作用，非对角初始密度）：\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 0.5\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}.$$\n- 用例 $3$（近简并单体哈密顿量，强相互作用）：\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 3.0\\,\\mathrm{MeV}, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}.$$\n- 用例 $4$（两个占据态）：\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}\\,\\mathrm{MeV}, \\quad g = 1.5\\,\\mathrm{MeV}, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}.$$\n\n您的程序应生成单行输出，其中包含四个用例的残差范数 $r$，并严格按照所列顺序，以逗号分隔的列表形式放在方括号内。例如，输出格式必须为\n$$[r_1,r_2,r_3,r_4],$$\n其中每个 $r_i$ 是一个以 MeV 为单位的浮点数。不应打印任何其他文本。", "solution": "该问题要求在一个简化的 $2 \\times 2$ 哈特里-福克模型中，经过单次自洽场 (SCF) 循环后，计算矩阵本征值方程的残差范数。该问题是适定的，其科学基础是量子多体理论和数值线性代数的原理，并为获得唯一解提供了所有必要信息。\n\n任务的核心是为四个不同的测试用例执行一个已定义的计算过程。单次循环的过程如下：\n1.  给定单体哈密顿量 $h_0$、标量相互作用强度 $g$ 和初始密度矩阵 $\\rho^{(0)}$，使用提供的公式构建平均场哈密顿量 $H$：\n    $$H[\\rho^{(0)}] = h_0 + g\\,\\rho^{(0)}$$\n2.  求解所得哈密顿量 $H$ 的矩阵本征值问题。由于所有指定的矩阵 $h_0$ 和 $\\rho^{(0)}$ 都是实对称的，因此所得的哈密顿量 $H$ 也是实对称的。本征值问题为：\n    $$H C = C \\varepsilon$$\n    其中 $C$ 是一个正交矩阵，其列是 $H$ 的本征矢量，$\\varepsilon$ 是一个包含相应实本征值的对角矩阵。在数值上，这是通过标准的本征求解器算法实现的，这些算法会产生本征值（例如，以矢量的形式）和本征矢量矩阵。\n3.  计算残差范数 $r$，定义为：\n    $$r = \\lVert H C - C \\varepsilon \\rVert_F$$\n    其中 $\\lVert \\cdot \\rVert_F$ 是弗罗贝尼乌斯范数，$\\lVert X \\rVert_F = \\sqrt{\\sum_{i,j} X_{ij}^2}$。\n\n理论上，对称矩阵的谱定理保证了存在一个标准正交本征矢量矩阵 $C$，使得 $H = C \\varepsilon C^\\top$。由于 $C$ 是正交的，$C^\\top C = I$，其中 $I$ 是单位矩阵。由此可知，在精确算术中：\n$$H C = (C \\varepsilon C^\\top) C = C \\varepsilon (C^\\top C) = C \\varepsilon I = C \\varepsilon$$\n因此，残差矩阵 $HC - C\\varepsilon$ 是零矩阵，其范数 $r$ 精确为 $0$。然而，数字计算机使用有限精度浮点运算进行计算。数值本征求解器算法找到的是真实本征值和本征矢量的近似值。因此，计算出的残差范数 $r$ 并非精确为零，而是一个小的正数，它量化了特定矩阵 $H$ 对角化过程的数值误差。其大小通常在相对于 $H$ 范数的机器精度数量级。本问题要求计算这个数值计算得到的值。更新密度矩阵 $\\rho^{(1)}$ 的步骤是完整 SCF 循环描述的一部分，但对于计算所要求的残差范数 $r$ 而言并非必需。\n\n我们现在将此过程应用于每个测试用例。\n\n用例 1：无相互作用，基准\n参数为：\n$$h_0 = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}, \\quad g = 0.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  0.0 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = h_0 + g\\,\\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix} + 0.0 \\cdot \\rho^{(0)} = \\begin{pmatrix} 0.0  0.0 \\\\ 0.0  2.0 \\end{pmatrix}$$\n该矩阵已是对角矩阵。本征值为 $\\varepsilon_1 = 0.0$ 和 $\\varepsilon_2 = 2.0$，对应的本征矢量为 $c_1 = (1, 0)^\\top$ 和 $c_2 = (0, 1)^\\top$。数值求解器可以识别这种结构，并产生残差在数值上为零的结果。\n计算出的残差范数为 $r_1 = 0.0$。\n\n用例 2：中等相互作用，非对角初始密度\n参数为：\n$$h_0 = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix}, \\quad g = 0.5, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 1.0  0.3 \\\\ 0.3  2.0 \\end{pmatrix} + 0.5 \\begin{pmatrix} 0.8  0.2 \\\\ 0.2  0.2 \\end{pmatrix} = \\begin{pmatrix} 1.0+0.4  0.3+0.1 \\\\ 0.3+0.1  2.0+0.1 \\end{pmatrix} = \\begin{pmatrix} 1.4  0.4 \\\\ 0.4  2.1 \\end{pmatrix}$$\n对该矩阵进行数值对角化，得到一组本征值和本征矢量。残差范数 $r_2$ 是根据这些数值结果计算得出的。\n计算出的残差范数为 $r_2 \\approx 3.8687 \\times 10^{-16}$。\n\n用例 3：近简并单体哈密顿量，强相互作用\n参数为：\n$$h_0 = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix}, \\quad g = 3.0, \\quad N = 1, \\quad \\rho^{(0)} = \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 1.0  0.99 \\\\ 0.99  1.02 \\end{pmatrix} + 3.0 \\begin{pmatrix} 0.5  0.0 \\\\ 0.0  0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0+1.5  0.99 \\\\ 0.99  1.02+1.5 \\end{pmatrix} = \\begin{pmatrix} 2.5  0.99 \\\\ 0.99  2.52 \\end{pmatrix}$$\n对该矩阵进行数值对角化以找到本征值和本征矢量，并计算残差范数 $r_3$。\n计算出的残差范数为 $r_3 \\approx 6.1305 \\times 10^{-16}$。\n\n用例 4：两个占据态\n参数为：\n$$h_0 = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix}, \\quad g = 1.5, \\quad N = 2, \\quad \\rho^{(0)} = \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix}$$\n平均场哈密顿量为：\n$$H = \\begin{pmatrix} 0.0  -0.1 \\\\ -0.1  0.5 \\end{pmatrix} + 1.5 \\begin{pmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{pmatrix} = \\begin{pmatrix} 0.0+1.5  -0.1 \\\\ -0.1  0.5+1.5 \\end{pmatrix} = \\begin{pmatrix} 1.5  -0.1 \\\\ -0.1  2.0 \\end{pmatrix}$$\n同样，进行数值对角化，并计算残差范数 $r_4$。\n计算出的残差范数为 $r_4 \\approx 3.4901 \\times 10^{-16}$。\n\n最终结果是这四个残差范数的集合，它们反映了标准本征求解器在处理给定矩阵时的数值精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the residual norm of the Hartree-Fock eigenvalue problem\n    for four different test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Non-interacting, baseline\n        {\n            \"h0\": np.array([[0.0, 0.0], [0.0, 2.0]]),\n            \"g\": 0.0,\n            \"N\": 1,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 0.0]]),\n        },\n        # Case 2: Moderate interaction, off-diagonal initial density\n        {\n            \"h0\": np.array([[1.0, 0.3], [0.3, 2.0]]),\n            \"g\": 0.5,\n            \"N\": 1,\n            \"rho0\": np.array([[0.8, 0.2], [0.2, 0.2]]),\n        },\n        # Case 3: Near-degenerate one-body Hamiltonian, strong interaction\n        {\n            \"h0\": np.array([[1.0, 0.99], [0.99, 1.02]]),\n            \"g\": 3.0,\n            \"N\": 1,\n            \"rho0\": np.array([[0.5, 0.0], [0.0, 0.5]]),\n        },\n        # Case 4: Two occupied states\n        {\n            \"h0\": np.array([[0.0, -0.1], [-0.1, 0.5]]),\n            \"g\": 1.5,\n            \"N\": 2,\n            \"rho0\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        h0 = case[\"h0\"]\n        g = case[\"g\"]\n        rho0 = case[\"rho0\"]\n        \n        # Step 1: Build the mean-field Hamiltonian H[\\rho^{(0)}]\n        H = h0 + g * rho0\n        \n        # Step 2: Solve the matrix eigenvalue problem H C = C epsilon\n        # numpy.linalg.eigh is used for Hermitian (or real-symmetric) matrices.\n        # It returns eigenvalues and corresponding eigenvectors.\n        # eigenvalues: 1D array of eigenvalues\n        # eigenvectors: 2D array where columns are the normalized eigenvectors\n        eigenvalues, C = np.linalg.eigh(H)\n        \n        # Create the diagonal matrix of eigenvalues\n        epsilon = np.diag(eigenvalues)\n        \n        # Step 3: Compute the residual matrix and its Frobenius norm\n        # Residual = H C - C epsilon\n        residual_matrix = H @ C - C @ epsilon\n        \n        # Frobenius norm of the residual matrix\n        r = np.linalg.norm(residual_matrix, 'fro')\n        \n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566777"}, {"introduction": "在自洽场理论中，单体密度矩阵 $\\rho$ 是连接多体波函数与平均场哈密顿算符的核心。这个练习[@problem_id:3566753]将带你深入探究密度矩阵的结构，让你亲手构建它，并利用其基本性质——如归一化（迹）和幂等性（$\\rho^2 = \\rho$）——来检验你的结果。理解如何精确地表示和验证密度矩阵，是开发和调试任何可靠的Hartree-Fock代码的关键一步。", "problem": "要求您以数学上精确且数值稳定的方式，形式化并实现一个在由量子数 $\\{\\,|n \\ell j m\\rangle\\,\\}$ 标记的固定正交归一谐振子基中，Slater 行列式的单体密度矩阵的构建与验证。其中 $n$ 是径向量子数，$\\ell$ 是轨道角动量，$j$ 是总角动量，$m$ 是磁投影。我们关注的基本对象是单体密度矩阵 $\\rho_{\\alpha\\beta}=\\langle a^\\dagger_\\beta a_\\alpha\\rangle$，其中 $\\alpha$ 和 $\\beta$ 标记了 $\\{\\,|n \\ell j m\\rangle\\,\\}$ 中的基态。请使用以下基本原理作为您的出发点：(i) 二次量子化中单体密度矩阵的定义，(ii) 单粒子态的正交归一性，(iii) Slater 行列式性质，即在零温下，已占据轨道定义了一个投影子空间，其占据数在 $\\{0,1\\}$ 范围内，以及 (iv) 对于球形系统，转动对称性意味着在 $(\\ell,j)$ 上存在块结构，在 $m$ 上存在克罗内克 $\\delta$ 函数。\n\n您的任务是从一组指定的块构建 $\\rho$，每个块对应一个固定的 $(\\ell,j)$ 对，在 $n$ 空间内有混合，但在不同的 $(\\ell,j)$ 或不同的 $m$ 之间没有混合。您必须通过组合以下部分来构建谐振子基下的密度矩阵：\n- $n$ 空间内的实正交混合，由一个维度为 $N_n^{(\\ell,j)} \\times N_n^{(\\ell,j)}$ 的正交矩阵 $U^{(\\ell,j)}$ 表示。\n- 一个长度为 $N_n^{(\\ell,j)}$ 的占据数向量 $\\mathbf{n}^{(\\ell,j)}$，包含每个正则轨道的占据数（对于该 $(\\ell,j)$ 块中的每个类 $n$ 本征态有一个数）。对于零温下的幂等 Slater 行列式，该数可以是 $0$ 或 $1$；或者为 $[0,1]$ 内的分数，以模拟非幂等情况。\n\n假设存在以下由转动不变性和正交归一性得出的结构性事实：(a) 密度矩阵在 $(\\ell,j)$ 上是块对角的，(b) 在每个 $(\\ell,j)$ 块内，对 $m$ 的依赖关系是对角于 $m$ 的，并且对于所有 $2j+1$ 个 $m$ 值都相同，以及 (c) 对于每个 $(\\ell,j)$ 块，非平凡的混合和占据完全存在于 $n$ 子空间中。\n\n您必须通过组合所有 $(\\ell,j)$ 块和所有 $m$ 子态的贡献，来实现完整密度矩阵 $\\rho$ 在谐振子基中的组装。然后，您必须量化并报告：\n- $\\rho$ 的数值迹，当占据数按每个 $m$ 子态解释时，该值应等于基中的总粒子数。期望迹等于对所有块求和，其中每项为 $(2j+1)$ 乘以相应占据数向量的各项之和。\n- 一个归一化误差，定义为 $\\rho$ 的计算迹与从指定占据数导出的期望迹之间的绝对差。\n- 一个幂等性误差，定义为 $\\rho^2-\\rho$ 的 Frobenius 范数。\n- 一个布尔值，指示幂等性误差是否低于指定的容差。\n\n所有角度必须以弧度为单位。\n\n请实现您的程序来评估以下测试套件。每个测试用例都指定了一组 $(\\ell,j)$ 块、它们的 $n$ 空间大小、$n$ 空间正交变换以及占据数向量。总基是所有块的直和，每个块再与维度为 $(2j+1)$ 的 $m$ 空间中的单位矩阵进行张量积。\n\n- 测试用例 1（理想情况，完全幂等）：\n  - 块：\n    - A 块：$\\ell=0$, $2j=1$（因此 $j=\\tfrac{1}{2}$，简并度 $2j+1=2$），$N_n=2$。在 $n$ 空间中定义一个角度为 $\\theta=0.3$ 的旋转。正交矩阵是标准的 $2\\times 2$ 旋转矩阵，其元素为 $\\cos\\theta$ 和 $\\sin\\theta$。占据数向量为 $\\mathbf{n}^{(0,\\frac{1}{2})} = [\\,1,\\,0\\,]$。\n    - B 块：$\\ell=1$, $2j=3$（因此 $j=\\tfrac{3}{2}$，简并度 $2j+1=4$），$N_n=1$。正交矩阵是 $1\\times 1$ 单位矩阵。占据数向量为 $\\mathbf{n}^{(1,\\frac{3}{2})} = [\\,1\\,]$。\n  - 期望迹等于 $2\\times 1 + 4\\times 1 = 6$。幂等性应在数值精度范围内成立。\n\n- 测试用例 2（边界情况，空态）：\n  - 与测试用例 1 相同的块和正交矩阵，但占据数为 $\\mathbf{n}^{(0,\\frac{1}{2})} = [\\,0,\\,0\\,]$ 和 $\\mathbf{n}^{(1,\\frac{3}{2})} = [\\,0\\,]$。\n  - 期望迹等于 $0$。幂等性应成立。\n\n- 测试用例 3（分数占据，非幂等）：\n  - 单个块：\n    - C 块：$\\ell=0$, $2j=1$（因此 $j=\\tfrac{1}{2}$，简并度 $2$），$N_n=3$。将一个 $3\\times 3$ 正交矩阵构造为在平面 $(0,1)$ 和 $(1,2)$ 中进行的两次 Givens 旋转的乘积，旋转角度分别为 $\\theta_1=0.2$ 和 $\\theta_2=-0.4$。在坐标 $(p,q)$ 中的 Givens 旋转，其非平凡元素位于第 $p$ 行和第 $q$ 行以及第 $p$ 列和第 $q$ 列，由带有适当符号的 $\\cos\\theta$ 和 $\\sin\\theta$ 给出，其他位置为单位矩阵元素。占据数向量为 $\\mathbf{n}^{(0,\\frac{1}{2})} = [\\,0.7,\\,0.2,\\,0.0\\,]$。\n  - 期望迹等于 $2\\times(0.7+0.2+0.0)=1.8$。幂等性必须被破坏，且幂等性误差必须严格为正。\n\n数值要求与检查：\n- 在 $n$ 空间中使用实正交矩阵，占据数在 $[0,1]$ 范围内取实数。\n- 在谐振子基中显式构造完整的密度矩阵 $\\rho$。该基的排序方式为：先按 $(\\ell,j)$ 块进行直和，在每个块内部，再将 $m$ 空间中的单位矩阵与该块的 $n$ 空间密度矩阵进行 Kronecker 积。\n- 计算 $\\rho$ 的数值迹，并与期望迹进行比较。将绝对差报告为归一化误差。\n- 将 $\\rho^2-\\rho$ 的 Frobenius 范数计算为幂等性误差。\n- 使用容差为 $\\varepsilon = 10^{-12}$（无量纲单位）的布尔幂等性测试。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表嵌套列表的结果。对于按顺序列出的每个测试用例，生成一个包含四个元素的列表：\n  - $\\rho$ 的计算迹（浮点数），\n  - 归一化误差（浮点数），\n  - 幂等性误差（浮点数），\n  - 幂等性布尔值（布尔值）。\n- 因此，最终打印的行必须看起来像一个包含三个内部列表的单一列表，例如 $[\\,[\\cdots],[\\cdots],[\\cdots]\\,]$。\n\n不允许外部输入。角度必须以弧度为单位。所有量均为无量纲；不要附加物理单位。确保数值稳定性以及根据指定数据可以精确复现结果。", "solution": "该问题已经过验证，并被确定为计算核物理领域中一个有效的、适定的问题。所有提供的信息都有科学依据、自洽，并且足以得到唯一的数值解。\n\n**1. 基本原理**\n\n这个问题的核心在于为量子多体系统构建单体密度矩阵 $\\rho$。在二次量子化形式中，其在正交归一单粒子基 $\\{\\,|\\alpha\\rangle\\,\\}$ 中的矩阵元定义为期望值 $\\rho_{\\alpha\\beta} = \\langle a^\\dagger_\\beta a_\\alpha \\rangle$，其中期望值是针对系统的基态或系综计算的。对于由单个 Slater 行列式描述的系统，其基态由一组已占据的单粒子轨道构成，这些轨道是底层平均场哈密顿量的本征态。我们将这组本征态基记为“正则基”，用 $\\{\\,|\\phi_k\\rangle\\,\\}$ 表示。在此基下，密度矩阵是对角的，其对角元为占据数 $n_k$：$\\langle \\phi_k | \\rho | \\phi_l \\rangle = n_k \\delta_{kl}$。对于零温下的纯 Slater 行列式，这些占据数要么是 1（对于已占据轨道），要么是 0（对于未占据轨道），这使得密度矩阵成为一个幂等投影算子（$\\rho^2 = \\rho$）。该问题允许分数占据 $n_k \\in [0,1]$，这对应于更普遍的关联态或热态，其中幂等性被破坏。\n\n该问题是在一个固定的工作基，即谐振子（HO）基中提出的，记为 $\\{\\,|n \\ell j m\\rangle\\,\\}$。设从正则基到谐振子基的变换由一个幺正矩阵 $C$ 给出，其矩阵元为重叠积分 $C_{\\alpha k} = \\langle \\alpha | \\phi_k \\rangle$。在谐振子基下的密度矩阵则由相似变换给出：\n$$ \\rho = C n C^\\dagger $$\n其中 $n$ 是占据数对角矩阵，$(n)_{kl} = n_k \\delta_{kl}$。问题指定变换矩阵是一个实正交矩阵 $U$，因此 $U^\\dagger = U^T$，表达式简化为：\n$$ \\rho = U n U^T $$\n\n**2. 利用转动对称性**\n\n对于球形系统，哈密顿量与角动量算符 $J^2$ 和 $J_z$ 对易。因此，单粒子态由好量子数 $(\\ell, j, m)$ 标记，且密度矩阵不能连接具有不同量子数的态。这使得 $\\rho$ 具有块对角结构。\n*   $\\rho$ 关于 $(\\ell, j)$ 是对角的。即，如果 $(\\ell,j) \\neq (\\ell',j')$，则 $\\langle n \\ell j m | \\rho | n' \\ell' j' m' \\rangle = 0$。\n*   在给定的 $(\\ell, j)$ 块内，转动对称性还意味着矩阵元在 $m$ 上是对角的，并且不依赖于 $m$ 的值。即，$\\langle n \\ell j m | \\rho | n' \\ell j m' \\rangle = \\delta_{mm'} \\rho_{nn'}^{(\\ell,j)}$。\n\n这种结构意味着完整的密度矩阵 $\\rho$ 是每个 $(\\ell, j)$ 对的一个块的直和：\n$$ \\rho = \\bigoplus_{(\\ell,j)} \\rho^{(\\ell,j)} $$\n给定 $(\\ell,j)$ 块的子矩阵 $\\rho^{(\\ell,j)}$ 作用于由基态 $\\{ |n \\ell j m\\rangle \\}$ 张成的空间，其中 $n$ 的范围是从 $0$ 到 $N_n^{(\\ell,j)}-1$，$m$ 的范围是从 $-j$ 到 $j$。对 $m$ 的无关性和对角性意味着该块具有 Kronecker 积结构：\n$$ \\rho^{(\\ell,j)} = \\mathbf{I}_{2j+1} \\otimes \\rho_{n}^{(\\ell,j)} $$\n其中 $\\mathbf{I}_{2j+1}$ 是 $m$ 空间（维度为 $2j+1$）中的单位矩阵，而 $\\rho_{n}^{(\\ell,j)}$ 是作用于径向量子数 $n$ 的 $N_n^{(\\ell,j)} \\times N_n^{(\\ell,j)}$ 密度矩阵。\n\n非平凡的混合和占据物理就存在于这个较小的 $\\rho_n^{(\\ell,j)}$ 矩阵中。根据通用公式，它被构造为：\n$$ \\rho_{n}^{(\\ell,j)} = U^{(\\ell,j)} \\text{diag}(\\mathbf{n}^{(\\ell,j)}) (U^{(\\ell,j)})^T $$\n其中 $U^{(\\ell,j)}$ 是指定的 $N_n^{(\\ell,j)} \\times N_n^{(\\ell,j)}$ 正交矩阵，$\\mathbf{n}^{(\\ell,j)}$ 是该块内正则轨道的占据数向量。\n\n**3. 算法实现与验证**\n\n构建 $\\rho$ 和计算所需量的算法直接源于上述原理。\n\n*   **初始化**：我们首先用一个空列表来存储块矩阵 $\\rho^{(\\ell,j)}$，并将总期望粒子数（迹）初始化为零。\n*   **逐块构建**：我们遍历测试用例中指定的每个 $(\\ell,j)$ 块。\n    *   对于由 $(\\ell,j)$、其 $n$ 空间维度 $N_n$、正交矩阵 $U$ 和占据数向量 $\\mathbf{n_v}$ 定义的块：\n        1.  简并度为 $d = 2j+1$。\n        2.  来自此块的期望迹贡献计算为 $d \\times \\sum_{k} (\\mathbf{n_v})_k$。将其加到总期望迹中。\n        3.  计算 $n$ 空间密度矩阵 $\\rho_n$：$\\rho_n = U \\cdot \\text{diag}(\\mathbf{n_v}) \\cdot U^T$。\n        4.  通过 Kronecker 积形成完整的块矩阵 $\\rho^{(\\ell,j)}$：$\\rho^{(\\ell,j)} = \\text{kron}(\\mathbf{I}_d, \\rho_n)$。\n        5.  存储该块矩阵。\n*   **组装**：处理完所有块后，通过从存储的 $\\rho^{(\\ell,j)}$ 矩阵创建块对角矩阵来组装系统的完整密度矩阵 $\\rho$。`scipy.linalg.block_diag` 函数非常适合此任务。这个最终矩阵的基对应于各个块的基的直和。\n*   **验证**：一旦构建了完整的矩阵 $\\rho$，我们执行所需的检查：\n    1.  **迹和归一化误差**：使用 `numpy.trace(\\rho)` 计算数值迹。归一化误差是该计算值与预先计算的期望迹之间的绝对差。\n    2.  **幂等性误差**：我们计算矩阵差 $\\Delta = \\rho^2 - \\rho$。然后通过该差的 Frobenius 范数来量化幂等性误差，$\\lVert\\Delta\\rVert_F = \\sqrt{\\sum_{i,j} |\\Delta_{ij}|^2}$。这可以使用 `numpy.linalg.norm(\\rho @ \\rho - \\rho, 'fro')` 计算。\n    3.  **幂等性测试**：将幂等性误差与指定的容差 $\\varepsilon = 10^{-12}$ 进行比较。结果是一个布尔值。\n\n对每个测试用例应用此过程，并收集四个结果指标用于最终输出。对于测试用例 3，所需的 $3\\times3$ 正交矩阵 $U$ 是作为两个 Givens 旋转矩阵的乘积构造的，$U = G_1(\\theta_1)G_2(\\theta_2)$，其中 $G_1$ 作用于 $(0,1)$ 平面，$G_2$ 作用于 $(1,2)$ 平面。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the one-body density matrix for several test cases\n    based on computational nuclear physics principles.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"blocks\": [\n                {\n                    \"l\": 0, \"j_two\": 1, \"Nn\": 2,\n                    \"U_def\": {\"type\": \"rotation\", \"params\": {\"angle\": 0.3}},\n                    \"n_vec\": np.array([1.0, 0.0])\n                },\n                {\n                    \"l\": 1, \"j_two\": 3, \"Nn\": 1,\n                    \"U_def\": {\"type\": \"identity\"},\n                    \"n_vec\": np.array([1.0])\n                }\n            ],\n            \"tolerance\": 1e-12\n        },\n        {\n            \"blocks\": [\n                {\n                    \"l\": 0, \"j_two\": 1, \"Nn\": 2,\n                    \"U_def\": {\"type\": \"rotation\", \"params\": {\"angle\": 0.3}},\n                    \"n_vec\": np.array([0.0, 0.0])\n                },\n                {\n                    \"l\": 1, \"j_two\": 3, \"Nn\": 1,\n                    \"U_def\": {\"type\": \"identity\"},\n                    \"n_vec\": np.array([0.0])\n                }\n            ],\n            \"tolerance\": 1e-12\n        },\n        {\n            \"blocks\": [\n                {\n                    \"l\": 0, \"j_two\": 1, \"Nn\": 3,\n                    \"U_def\": {\"type\": \"givens_product\", \"params\": {\"angles\": [0.2, -0.4], \"planes\": [(0, 1), (1, 2)]}},\n                    \"n_vec\": np.array([0.7, 0.2, 0.0])\n                }\n            ],\n            \"tolerance\": 1e-12\n        },\n    ]\n\n    results = []\n\n    def get_orthogonal_matrix(U_def, Nn):\n        \"\"\"Constructs the orthogonal matrix U based on its definition.\"\"\"\n        if U_def[\"type\"] == \"identity\":\n            return np.identity(Nn)\n        \n        if U_def[\"type\"] == \"rotation\":\n            angle = U_def[\"params\"][\"angle\"]\n            c, s = np.cos(angle), np.sin(angle)\n            return np.array([[c, -s], [s, c]])\n\n        if U_def[\"type\"] == \"givens_product\":\n            angles = U_def[\"params\"][\"angles\"]\n            planes = U_def[\"params\"][\"planes\"]\n            U = np.identity(Nn)\n            # Apply rotations: U = G_1 * G_2 * ...\n            # In matrix multiplication, this corresponds to U = G_last @ ... @ G_1\n            # Problem says \"product of two Givens rotations in the planes (0,1) and (1,2)\"\n            # which we can interpret as applying the first, then the second.\n            # U_final = G_2 @ G_1. Let's assume standard op order: G1 then G2.\n            # So a vector v is transformed to G2 @ (G1 @ v). The combined matrix is G2 @ G1.\n            # Let's reverse the order to match this interpretation.\n            \n            # Correction: problem states product G1 G2. This means G1 @ G2 by convention.\n            Gs = []\n            for angle, plane in zip(angles, planes):\n                p, q = plane\n                c, s = np.cos(angle), np.sin(angle)\n                G = np.identity(Nn)\n                G[p, p] = c\n                G[p, q] = -s\n                G[q, p] = s\n                G[q, q] = c\n                Gs.append(G)\n            \n            U = Gs[0]\n            for i in range(1, len(Gs)):\n                U = U @ Gs[i]\n            return U\n\n        raise ValueError(f\"Unknown U_def type: {U_def['type']}\")\n\n\n    for case in test_cases:\n        block_matrices = []\n        expected_trace = 0.0\n\n        for block_info in case[\"blocks\"]:\n            j = block_info[\"j_two\"] / 2.0\n            Nn = block_info[\"Nn\"]\n            n_vec = block_info[\"n_vec\"]\n            \n            degeneracy = int(2 * j + 1)\n            \n            # Calculate expected trace contribution from this block\n            expected_trace += degeneracy * np.sum(n_vec)\n            \n            # Construct the orthogonal matrix U for the n-space\n            U_n = get_orthogonal_matrix(block_info[\"U_def\"], Nn)\n            \n            # Construct the diagonal matrix of occupation numbers\n            n_diag_matrix = np.diag(n_vec)\n            \n            # Construct the n-space density matrix rho_n\n            rho_n = U_n @ n_diag_matrix @ U_n.T\n            \n            # Construct the full block density matrix by Kronecker product\n            identity_m = np.identity(degeneracy)\n            rho_block = np.kron(identity_m, rho_n)\n            \n            block_matrices.append(rho_block)\n            \n        # Assemble the full density matrix rho\n        if not block_matrices:\n             rho = np.array([[]]) # Handle empty case if needed, not in spec.\n        else:\n             rho = block_diag(*block_matrices)\n\n        # 1. Compute trace and normalization error\n        computed_trace = np.trace(rho)\n        normalization_error = np.abs(computed_trace - expected_trace)\n        \n        # 2. Compute idempotency error\n        if rho.size == 0:\n            idempotency_error = 0.0\n        else:\n           rho_squared = rho @ rho\n           idempotency_error = np.linalg.norm(rho_squared - rho, 'fro')\n        \n        # 3. Check idempotency against tolerance\n        is_idempotent = idempotency_error  case[\"tolerance\"]\n        \n        results.append([computed_trace, normalization_error, idempotency_error, is_idempotent])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566753"}, {"introduction": "简单的自洽场迭代可能收敛缓慢，因此在实际计算中通常会采用收敛加速方案，例如线性混合。然而，这种数值技巧可能会破坏密度矩阵必须满足的幂等性（$D^2=D$），使其偏离物理上有意义的投影算符集合。这个练习[@problem_id:3566772]将让你直面这一挑战，通过实现一个混合步骤来观察幂等性的破坏，并学习如何利用奇异值分解（SVD）将非物理的密度矩阵投影回正确的状态空间。", "problem": "考虑在计算核物理中Hartree-Fock (HF) 方程的自洽场 (SCF) 迭代，该迭代在维度为 $M$ 的正交归一单粒子基中表达。对于具有 $N$ 个占据轨道（$N \\le M$）的Slater行列式，单体密度矩阵 $D$ 定义为 $D = \\sum_{i=1}^{N} \\lvert \\phi_i \\rangle \\langle \\phi_i \\rvert$，并且必须满足幂等性和厄米性约束 $D^2 = D$ 和 $D^\\dagger = D$。Fock算符 $F[D]$ 是 $D$ 的一个厄米泛函，而映射 $\\hat{D}(F)$ 返回投影到 $F$ 的 $N$ 个能量最低的本征向量上的投影算符。一种常见的SCF加速方法是线性混合，它通过 $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ 来更新密度，其中 $\\alpha \\in [0,1]$ 是一个混合参数。\n\n仅从这些基本定义出发，完成以下任务：\n\n1. 使用投影算符代数的第一性原理，严格证明为什么当 $0  \\alpha  1$ 时，对于泛型的 $D_n$ 和 $\\hat{D}(F[D_n])$，线性混合更新 $D_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$ 会违反幂等性条件 $D_{n+1}^2 = D_{n+1}$。你的论证不得依赖未经证实的捷径，并且必须明确使用投影算符的代数性质。\n\n2. 设计一个数学上合理的投影，将任意厄米矩阵 $D$ 映射回由秩为 $N$ 的投影算符构成的格拉斯曼流形 $\\mathcal{G}(N,M)$。你的投影必须基于奇异值分解 (SVD)：对于给定的 $D$，计算其SVD $D = U \\Sigma V^\\dagger$，然后构造一个秩为 $N$ 的投影算符 $P = U_N U_N^\\dagger$，其中 $U_N$ 包含与 $N$ 个最大奇异值相关联的 $N$ 个左奇异向量。提供一个严格的推导，证明这个 $P$ 是 $\\mathcal{G}(N,M)$ 中与 $D$ 在弗罗贝尼乌斯范数下最接近的元素，并且 $P^2 = P$ 和 $P^\\dagger = P$。\n\n3. 实现一个完整的程序，该程序对一组指定的测试用例执行一个SCF线性混合步骤，然后进行基于SVD的投影。在所有情况下，将Fock算符泛函定义为 $F[D] = H + \\gamma D$，其中 $H$ 是厄米矩阵，$\\gamma \\in \\mathbb{R}$。映射 $\\hat{D}(F)$ 必须通过对角化 $F$ 并构造到 $N$ 个最低本征向量上的投影算符来实现。对于每个测试用例，计算：\n   - 混合密度的幂等性破坏程度 $E_{\\mathrm{mix}} = \\lVert D_{\\mathrm{mix}}^2 - D_{\\mathrm{mix}} \\rVert_F$，其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n   - SVD投影后的幂等性破坏程度 $E_{\\mathrm{proj}} = \\lVert P^2 - P \\rVert_F$。\n\n你的程序必须使用以下确定性构造方法：\n- 为了为给定的 $M$、$N$ 和整数种子 $s$ 生成一个随机的秩为 $N$ 的投影算符 $D_n$，使用一个以 $s$ 为种子的伪随机数生成器生成一个实数 $M \\times N$ 矩阵 $A$，其元素为独立的标准正态分布。计算其薄 $QR$ 分解 $A = QR$，并设置 $D_n = QQ^\\dagger$。\n- 为了为给定的 $M$ 和整数种子 $t$ 生成一个随机的厄米矩阵 $H$，使用一个以 $t$ 为种子的伪随机数生成器生成一个实数 $M \\times M$ 矩阵 $B$，其元素为独立的标准正态分布。并设置 $H = \\tfrac{1}{2}(B + B^\\dagger)$。\n\n测试套件如下：\n- Case 1: $(M,N,\\alpha,\\gamma,s,t) = (4,2,0.5,0.7,11,13)$。\n- Case 2: $(M,N,\\alpha,\\gamma,s,t) = (4,2,0.0,0.7,11,13)$。\n- Case 3: $(M,N,\\alpha,\\gamma,s,t) = (4,2,1.0,0.7,11,13)$。\n- Case 4: $(M,N,\\alpha,\\gamma,s,t) = (5,2,0.3,-0.5,21,22)$。\n- Case 5: $(M,N,\\alpha,\\gamma,s) = (6,3,0.4,0.0,31)$，其中 $H$ 明确设置为对角矩阵 $H = \\mathrm{diag}(0,0,0,1,1,1)$（此情况不需要种子 $t$）。\n\n对于每个用例，计算 $D_{\\mathrm{mix}} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])$，然后计算 $E_{\\mathrm{mix}}$ 以及将 $D_{\\mathrm{mix}}$ 通过SVD投影到 $P = U_N U_N^\\dagger$ 后的 $E_{\\mathrm{proj}}$。\n\n最终输出格式要求：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含10个浮点数值 $[E_{\\mathrm{mix}}^{(1)},E_{\\mathrm{proj}}^{(1)},E_{\\mathrm{mix}}^{(2)},E_{\\mathrm{proj}}^{(2)},E_{\\mathrm{mix}}^{(3)},E_{\\mathrm{proj}}^{(3)},E_{\\mathrm{mix}}^{(4)},E_{\\mathrm{proj}}^{(4)},E_{\\mathrm{mix}}^{(5)},E_{\\mathrm{proj}}^{(5)}]$。\n\n这个纯数学计算不涉及任何物理单位。如果出现角度，应以弧度处理，但在指定的测试用例中没有引入角度。", "solution": "此问题包含三个部分：关于线性混合密度矩阵幂等性的理论证明、一种恢复幂等性的最优投影方法的推导，以及一个验证这些概念的数值实现。我们将严格遵循第一性原理，依次处理每个部分。\n\n### 第1部分：线性混合中的幂等性破坏\n\n给定自洽场（SCF）迭代中密度矩阵 $D$ 的线性混合更新规则：\n$$\nD_{n+1} = (1 - \\alpha) D_n + \\alpha \\, \\hat{D}(F[D_n])\n$$\n其中 $\\alpha \\in [0,1]$ 是混合参数。根据定义，矩阵 $D_n$ 和 $\\hat{D}(F[D_n])$ 都是秩为 $N$ 的正交投影算符。我们将其表示为 $P_1 \\equiv D_n$ 和 $P_2 \\equiv \\hat{D}(F[D_n])$。两者都满足投影算符的条件：$P_1^2 = P_1$，$P_1^\\dagger = P_1$，$\\mathrm{Tr}(P_1) = N$，对于 $P_2$ 也同样成立。更新后的矩阵为 $D_{\\text{mix}} = (1-\\alpha)P_1 + \\alpha P_2$。题目要求我们证明，对于 $0  \\alpha  1$ 和泛型投影算符 $P_1 \\ne P_2$，幂等性条件 $D_{\\text{mix}}^2 = D_{\\text{mix}}$ 会被违反。\n\n首先，我们计算 $D_{\\text{mix}}^2$：\n$$\nD_{\\text{mix}}^2 = ((1-\\alpha)P_1 + \\alpha P_2)^2 = (1-\\alpha)^2 P_1^2 + \\alpha^2 P_2^2 + (1-\\alpha)\\alpha(P_1 P_2 + P_2 P_1)\n$$\n利用 $P_1$ 和 $P_2$ 的幂等性，即 $P_1^2 = P_1$ 和 $P_2^2=P_2$，上式简化为：\n$$\nD_{\\text{mix}}^2 = (1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1)\n$$\n为使 $D_{\\text{mix}}$ 是幂等的，必须有 $D_{\\text{mix}}^2 = D_{\\text{mix}}$。将 $D_{\\text{mix}}^2$ 的表达式与 $D_{\\text{mix}}$ 的定义相等：\n$$\n(1-\\alpha)^2 P_1 + \\alpha^2 P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = (1-\\alpha)P_1 + \\alpha P_2\n$$\n将各项移到等式一侧可得：\n$$\n((1-\\alpha)^2 - (1-\\alpha))P_1 + (\\alpha^2 - \\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n对 $P_1$ 和 $P_2$ 的系数进行因式分解：\n$$\n(1-\\alpha)(1-\\alpha-1)P_1 + \\alpha(\\alpha-1)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n$$\n-\\alpha(1-\\alpha)P_1 - \\alpha(1-\\alpha)P_2 + \\alpha(1-\\alpha)(P_1 P_2 + P_2 P_1) = 0\n$$\n问题指定 $0  \\alpha  1$，这意味着因子 $\\alpha(1-\\alpha)$ 严格为正。因此我们可以将整个方程除以 $\\alpha(1-\\alpha)$：\n$$\n-P_1 - P_2 + P_1 P_2 + P_2 P_1 = 0\n$$\n这可以重排为 $D_{\\text{mix}}$ 保持幂等性的一个充分必要条件：\n$$\nP_1 P_2 + P_2 P_1 = P_1 + P_2\n$$\n这个条件等价于 $(P_1-P_2)^2 = P_1^2 - P_1P_2 - P_2P_1 + P_2^2 = P_1 - (P_1 P_2 + P_2 P_1) + P_2 = P_1 - (P_1+P_2) + P_2 = 0$。\n所以 $D_{\\text{mix}}$ 的幂等性条件意味着 $(P_1-P_2)^2 = 0$。由于 $P_1$ 和 $P_2$ 是厄米矩阵，它们的差 $P_1-P_2$ 也是厄米矩阵。对于任何厄米矩阵 $A$，$A^2=0$ 意味着 $A=0$。要证明这一点，对于任意向量 $x$，有 $\\lVert Ax \\rVert^2 = \\langle Ax, Ax \\rangle = \\langle x, A^\\dagger Ax \\rangle = \\langle x, A^2x \\rangle = \\langle x, 0 \\rangle = 0$。因此对于所有 $x$，$Ax=0$ 都成立，这意味着 $A=0$。\n因此，$(P_1-P_2)^2=0$ 意味着 $P_1-P_2=0$，即 $P_1=P_2$。\n\n总之，对于 $0  \\alpha  1$，混合密度矩阵 $D_{\\text{mix}}$ 是幂等的当且仅当 $P_1=P_2$。在 SCF 迭代的泛型步骤中，输入密度矩阵 $D_n$ 不是一个不动点，所以 $D_n \\ne \\hat{D}(F[D_n])$。因此，线性混合方案内在地破坏了密度矩阵关键的幂等性属性。\n\n### 第2部分：基于SVD到格拉斯曼流形的投影\n\n我们寻求一个投影，它能将一个任意的 $M \\times M$ 厄米矩阵 $D$ 映射到集合 $\\mathcal{G}(N,M) = \\{ P \\in \\mathbb{C}^{M\\times M} \\mid P^2=P, P^\\dagger=P, \\mathrm{Tr}(P)=N \\}$ 中与其最接近的秩为 $N$ 的投影算符 $P$。“最接近”的定义是最小化两者之差的弗罗贝尼乌斯范数 $\\lVert D - P \\rVert_F$。\n\n弗罗贝尼乌斯范数的平方由 $\\lVert A \\rVert_F^2 = \\mathrm{Tr}(A^\\dagger A)$ 给出。我们希望最小化：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}((D - P)^\\dagger (D - P))\n$$\n由于 $D$ 和 $P$ 都是厄米的（$D^\\dagger=D, P^\\dagger=P$），这展开为：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2 - DP - PD + P^2) = \\mathrm{Tr}(D^2) - \\mathrm{Tr}(DP) - \\mathrm{Tr}(PD) + \\mathrm{Tr}(P^2)\n$$\n利用迹的循环性质（$\\mathrm{Tr}(AB) = \\mathrm{Tr}(BA)$）和投影算符的性质（$P^2=P$，$\\mathrm{Tr}(P)=N$），上式变为：\n$$\n\\lVert D - P \\rVert_F^2 = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + \\mathrm{Tr}(P) = \\mathrm{Tr}(D^2) - 2\\mathrm{Tr}(DP) + N\n$$\n对于 $P$ 的选择，$\\mathrm{Tr}(D^2)$ 和 $N$ 是常数。因此，最小化 $\\lVert D - P \\rVert_F^2$ 等价于最大化 $\\mathrm{Tr}(DP)$。\n\n设厄米矩阵 $D$ 的谱分解为 $D = \\sum_{i=1}^{M} \\lambda_i \\lvert v_i \\rangle \\langle v_i \\rvert$，其中 $\\lambda_i$ 是实数本征值，$\\{\\lvert v_i \\rangle\\}$ 是对应的正交归一本征向量集合。我们对本征值排序，使得 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_M$。\n任何秩为 $N$ 的投影算符 $P$ 都可以写为 $P = \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert$，其中 $\\{\\lvert u_j \\rangle\\}_{j=1}^N$ 是张成 $P$ 的值域的一个正交归一向量集合。\n\n我们计算 $\\mathrm{Tr}(DP)$：\n$$\n\\mathrm{Tr}(DP) = \\mathrm{Tr}\\left(D \\sum_{j=1}^{N} \\lvert u_j \\rangle \\langle u_j \\rvert\\right) = \\sum_{j=1}^{N} \\mathrm{Tr}(D \\lvert u_j \\rangle \\langle u_j \\rvert) = \\sum_{j=1}^{N} \\langle u_j \\rvert D \\lvert u_j \\rangle\n$$\n这是 $D$ 在 $P$ 的值域的基向量上的期望值之和。为了最大化这个和，我们必须最优地选择集合 $\\{\\lvert u_j \\rangle\\}$。根据 Ky Fan 不等式，或者通过一个更直接的论证，期望值之和 $\\sum_j \\langle u_j \\rvert D \\lvert u_j \\rangle$ 在由 $\\{\\lvert u_j \\rangle\\}$ 张成的子空间与由 $D$ 的 $N$ 个最大本征值对应的本征矢张成的子空间相同时达到最大值。\n在我们排序后的本征值基中，通过选择 $\\lvert u_j \\rangle = \\lvert v_j \\rangle$（对于 $j=1, \\dots, N$）可以达到最大值。这个选择给出：\n$$\n\\mathrm{Tr}(DP) = \\sum_{j=1}^{N} \\langle v_j \\rvert D \\lvert v_j \\rangle = \\sum_{j=1}^{N} \\langle v_j \\rvert (\\lambda_j \\lvert v_j \\rangle) = \\sum_{j=1}^{N} \\lambda_j\n$$\n任何其他正交归一集合 $\\{\\lvert u_j \\rangle\\}$ 的选择都会得到一个小于或等于这个和的值。\n\n因此，最优投影算符 $P$ 是投影到由 $D$ 的 $N$ 个最大本征值对应的本征矢 $\\{\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle\\}$ 张成的子空间上的那一个：\n$$\nP = \\sum_{i=1}^N \\lvert v_i \\rangle \\langle v_i \\rvert\n$$\n问题描述使用了奇异值分解（SVD），$D = U \\Sigma V^\\dagger$。由于 $D$ 是厄米的，其左、右奇异向量相同（$U=V$），且与其本征向量重合。奇异值是本征值的绝对值。在本问题的背景下，待投影的矩阵 $D_{\\text{mix}} = (1-\\alpha)D_n + \\alpha \\hat{D}(F[D_n])$ 是两个半正定矩阵（投影算符是半正定的）的凸组合，因此它本身也是半正定的。它的本征值因此是非负的，并与其奇异值相同。因此，与 $N$ 个最大本征值对应的本征向量与 $N$ 个最大奇异值对应的左奇异向量是相同的。\n\n令 $U_N$ 为一个 $M \\times N$ 矩阵，其列是 $U$ 的前 $N$ 列（即本征向量 $\\lvert v_1 \\rangle, \\dots, \\lvert v_N \\rangle$）。投影算符可以写为 $P=U_N U_N^\\dagger$。我们验证其性质：\n1.  **厄米性：** $P^\\dagger = (U_N U_N^\\dagger)^\\dagger = (U_N^\\dagger)^\\dagger U_N^\\dagger = U_N U_N^\\dagger = P$。它是厄米矩阵。\n2.  **幂等性：** $P^2 = (U_N U_N^\\dagger)(U_N U_N^\\dagger) = U_N (U_N^\\dagger U_N) U_N^\\dagger$。由于 $U_N$ 的列是正交归一的，$U_N^\\dagger U_N = I_N$，即 $N \\times N$ 的单位矩阵。因此，$P^2 = U_N I_N U_N^\\dagger = U_N U_N^\\dagger = P$。它是幂等的。\n3.  **秩：** 投影算符的秩是其迹。$\\mathrm{rank}(P) = \\mathrm{Tr}(P) = \\mathrm{Tr}(U_N U_N^\\dagger) = \\mathrm{Tr}(U_N^\\dagger U_N) = \\mathrm{Tr}(I_N) = N$。\n\n推导至此完成。基于SVD的构造正确地找到了与给定厄米矩阵在弗罗贝尼乌斯范数下最接近的秩为 $N$ 的投影算符。此过程成功地将一个已失去幂等性的矩阵映射回格拉斯曼流形 $\\mathcal{G}(N,M)$。", "answer": "```python\nimport numpy as np\n\ndef run_case(M, N, alpha, gamma, s, t=None, H_explicit=None):\n    \"\"\"\n    Performs one SCF linear mixing step followed by SVD projection for a single test case.\n\n    Args:\n        M (int): Dimension of the basis.\n        N (int): Number of occupied orbitals.\n        alpha (float): Linear mixing parameter.\n        gamma (float): Parameter for the Fock operator functional.\n        s (int): Seed for generating the initial density matrix.\n        t (int, optional): Seed for generating the core Hamiltonian. Defaults to None.\n        H_explicit (np.ndarray, optional): An explicitly provided core Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[float, float]: A tuple containing (E_mix, E_proj).\n    \"\"\"\n    \n    # 1. Generate the initial rank-N projector D_n\n    # Use a real M x N matrix A with standard normal entries\n    rng_s = np.random.default_rng(s)\n    A = rng_s.standard_normal((M, N))\n    # Compute the thin QR factorization of A\n    Q, _ = np.linalg.qr(A, mode='reduced')\n    # D_n is the projector Q Q^dagger\n    Dn = Q @ Q.T\n\n    # 2. Generate the core Hamiltonian H\n    if H_explicit is not None:\n        H = H_explicit\n    else:\n        # Use a real M x M matrix B with standard normal entries\n        rng_t = np.random.default_rng(t)\n        B = rng_t.standard_normal((M, M))\n        # Symmetrize to create a Hermitian matrix (here, real symmetric)\n        H = 0.5 * (B + B.T)\n\n    # 3. Compute the Fock operator F[D_n]\n    F = H + gamma * Dn\n\n    # 4. Compute the target projector, D_hat(F)\n    # Diagonalize the Hermitian Fock operator F\n    # np.linalg.eigh sorts eigenvalues in ascending order\n    eigvals, eigvecs = np.linalg.eigh(F)\n    # The columns of eigvecs are the eigenvectors. We need the first N columns\n    # corresponding to the N lowest eigenvalues.\n    lowest_eigvecs = eigvecs[:, :N]\n    # Form the projector onto this N-dimensional subspace\n    D_hat = lowest_eigvecs @ lowest_eigvecs.T\n\n    # 5. Perform linear mixing\n    D_mix = (1 - alpha) * Dn + alpha * D_hat\n\n    # 6. Compute idempotency violation of the mixed density, E_mix\n    error_matrix_mix = D_mix @ D_mix - D_mix\n    E_mix = np.linalg.norm(error_matrix_mix, 'fro')\n\n    # 7. Project D_mix back onto the Grassmann manifold\n    # D_mix is Hermitian, so its SVD is U S U^dagger. Left and right singular vectors are the same.\n    # np.linalg.svd sorts singular values in descending order.\n    U, S, Vh = np.linalg.svd(D_mix)\n    # Take the N left singular vectors associated with the N largest singular values\n    U_N = U[:, :N]\n    # Construct the closest rank-N projector P\n    P = U_N @ U_N.T\n\n    # 8. Compute idempotency violation of the projected density, E_proj\n    # This should be close to machine epsilon\n    error_matrix_proj = P @ P - P\n    E_proj = np.linalg.norm(error_matrix_proj, 'fro')\n\n    return E_mix, E_proj\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (M, N, alpha, gamma, s, t)\n        (4, 2, 0.5, 0.7, 11, 13),\n        (4, 2, 0.0, 0.7, 11, 13),\n        (4, 2, 1.0, 0.7, 11, 13),\n        (5, 2, 0.3, -0.5, 21, 22),\n        # Case 5 has no 't' seed\n        (6, 3, 0.4, 0.0, 31),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        if len(case) == 6:\n            M, N, alpha, gamma, s, t = case\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, t)\n        else: # Case 5\n            M, N, alpha, gamma, s = case\n            H_explicit = np.diag([0.0, 0.0, 0.0, 1.0, 1.0, 1.0])\n            E_mix, E_proj = run_case(M, N, alpha, gamma, s, H_explicit=H_explicit)\n        \n        results.append(E_mix)\n        results.append(E_proj)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3566772"}]}