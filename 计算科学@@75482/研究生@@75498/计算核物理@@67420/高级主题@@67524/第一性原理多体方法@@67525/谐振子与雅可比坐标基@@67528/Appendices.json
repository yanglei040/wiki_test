{"hands_on_practices": [{"introduction": "在处理像核子这样的全同费米子构成的多体系统时，泡利不相容原理是其遵循的基本准则。本练习将引导你为三体系统构建反对称化算符，这是将泡利原理应用于计算的关键一步。通过在单粒子坐标基和雅可比坐标基中数值验证其幂等性（$A^2=A$），你将深入理解对称性算符在不同表象下的矩阵表示及其变换关系。[@problem_id:3563419]", "problem": "实现对一维谐振子 (HO) 基和 Jacobi 坐标 HO 基中，全同无自旋费米子的三体反对称化子的数值验证。考虑三个等质量的粒子。使用三个对象上的置换群（对称群 $S_3$）和相应的投影算符来定义反对称化子。反对称化子定义为\n$$\nA \\equiv \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi,\n$$\n其中 $P_\\pi$ 是根据置换 $\\pi$ 重排粒子标签的置换算符，$\\mathrm{sgn}(\\pi)$ 对偶置换为 $+1$，对奇置换为 $-1$。投影算符的定义属性是幂等性，即\n$$\nA^2 = A.\n$$\n你将在由单粒子谐振子数本征态构成的截断谐振子基中进行计算。构建一个总量子数固定的三体基\n$$\n\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}}) = \\{\\,|n_1,n_2,n_3\\rangle \\,:\\, n_i \\in \\mathbb{N}_0,\\; n_1+n_2+n_3 = N_{\\mathrm{tot}}\\,\\}.\n$$\n置换算符 $P_\\pi$ 对基右矢的作用通过重新标记粒子坐标来定义，等效于对元组的映射\n$$\nP_\\pi\\,|n_1,n_2,n_3\\rangle \\;=\\; |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle.\n$$\n第一部分（粒子排序基）：为所有六个 $\\pi \\in S_3$ 构建 $|\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,| \\times |\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,|$ 维矩阵 $P_\\pi$，组装 $A$，并通过计算弗罗贝尼乌斯范数来数值验证其投影算符性质\n$$\n\\|A^2 - A\\|_F \\equiv \\sqrt{\\mathrm{Tr}\\big((A^2-A)^\\top (A^2-A)\\big)}.\n$$\n第二部分（质心解耦的 Jacobi 坐标基）：通过将粒子坐标映射到 Jacobi 坐标的正交变换来定义 Jacobi 模式。在谐振子阶梯算符的层面上，这是一个实正交的模式混合\n$$\n\\begin{pmatrix}\nb_\\rho \\\\\nb_\\lambda \\\\\nb_{\\mathrm{CM}}\n\\end{pmatrix}\n=\nO\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix},\n\\quad\nO \\equiv\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}}  -\\frac{1}{\\sqrt{2}}  0 \\\\\n\\frac{1}{\\sqrt{6}}  \\frac{1}{\\sqrt{6}}  -\\frac{2}{\\sqrt{6}} \\\\\n\\frac{1}{\\sqrt{3}}  \\frac{1}{\\sqrt{3}}  \\frac{1}{\\sqrt{3}}\n\\end{pmatrix}.\n$$\n这里 $a_i$ 是粒子模式的湮灭算符，而 $(b_\\rho,b_\\lambda,b_{\\mathrm{CM}})$ 是与相对坐标 $(\\rho,\\lambda)$ 和质心 (CM) 相关联的 Jacobi 湮灭算符。使用这个正交变换，构建从总量子数 $N_{\\mathrm{tot}}$ 固定的粒子 Fock 基 $\\{|n_1,n_2,n_3\\rangle\\}$ 到总量子数 $n_\\rho+n_\\lambda+N_{\\mathrm{CM}}=N_{\\mathrm{tot}}$ 的 Jacobi Fock 基 $\\{|n_\\rho,n_\\lambda,N_{\\mathrm{CM}}\\rangle\\}$ 的幺正基变换矩阵 $U$。然后通过以下方式变换反对称化子\n$$\nA_{\\mathrm{Jac}} \\;=\\; U\\, A\\, U^\\top,\n$$\n并通过选择 $N_{\\mathrm{CM}}=0$ 的行和列，将其限制在质心基态子空间 $N_{\\mathrm{CM}}=0$ 上。通过计算以下范数来验证在此子空间中的幂等性\n$$\n\\big\\|A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)\\,2} - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}\\big\\|_F.\n$$\n你可以无需进一步论证而使用的基本依据：(i) 置换算符的定义及其复合，(ii) 群性质 $\\mathrm{sgn}(\\pi)\\mathrm{sgn}(\\sigma)=\\mathrm{sgn}(\\pi\\sigma)$，(iii) 上文定义的三体反对称化子，(iv) 对于等质量和等谐振子频率情况下的 Jacobi 变换 $O$ 的正交性，以及 (v) 谐振子模式的阶梯算符代数。\n\n算法实现要求：\n- 构建固定 $N_{\\mathrm{tot}}$ 的粒子排序基。\n- 根据 $\\pi^{-1}$ 置换基元组来构造所有 $P_\\pi$。\n- 组装 $A$ 并通过弗罗贝尼乌斯范数数值验证幂等性。\n- 通过将表示为 Jacobi 模式产生算符线性组合的粒子模式产生算符作用于真空态，从而精确地构建幺正基变换矩阵 $U$。在此过程中，使用阶梯算符作用 $b_k^\\dagger|m_k\\rangle=\\sqrt{m_k+1}\\,|m_k+1\\rangle$ 和构建归一化数态所需的序贯归一化因子来跟踪归一化。\n- 将 $A$ 变换到 Jacobi 基，并限制在 $N_{\\mathrm{CM}}=0$ 的子空间上验证其幂等性。\n\n数值测试套件和要求的输出：\n- 使用以下五个测试用例，由总谐振子量子数 $N_{\\mathrm{tot}}$ 和用于检查幂等性的表示指定：\n    1. $(N_{\\mathrm{tot}}=0,\\ \\mathrm{粒子表示})$\n    2. $(N_{\\mathrm{tot}}=1,\\ \\mathrm{粒子表示})$\n    3. $(N_{\\mathrm{tot}}=2,\\ \\mathrm{粒子表示})$\n    4. $(N_{\\mathrm{tot}}=3,\\ \\mathrm{Jacobi 表示，其中\\ }N_{\\mathrm{CM}}=0)$\n    5. $(N_{\\mathrm{tot}}=4,\\ \\mathrm{Jacobi 表示，其中\\ }N_{\\mathrm{CM}}=0)$\n- 对于每种情况，计算一个实数，其值等于在指定表示中幂等性缺陷的弗罗贝尼乌斯范数。不要使用任何物理单位。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用逗号分隔的浮点数列表作为结果，四舍五入到十二位小数，并用方括号括起来（例如，\"[0.0,0.0,0.0,0.0,0.0]\"）。\n\n你提交的内容必须是一个完整的、可运行的程序，该程序执行上述所有步骤，并以上述五个测试用例所要求的确切格式打印结果。", "solution": "用户提供的问题是计算量子力学中一个定义明确且科学合理​​的练习，具体涉及对称性算符在不同基组中的表示。该问题是有效的，并提供了解决方案所需的所有必要组件。我们将按照指定的算法步骤来构建解决方案。\n\n问题的核心是数值验证三体反对称化投影算符 $A$ 的幂等性属性 $A^2 = A$。这一验证是在两个不同但幺正相关的基组中进行的，该系统由三个处于一维谐振子势中的全同无自旋费米子组成。\n\n### 第一部分：在粒子排序基中的验证\n\n首先，我们在单粒子乘积基中解决这个问题。\n\n**1. 基的构建**\n对于固定的谐振子总量子数 $N_{\\mathrm{tot}}$，基由右矢 $|n_1, n_2, n_3\\rangle$ 组成，其中 $n_i \\in \\mathbb{N}_0$ 分别是粒子 1、2、3 的量子数，并且它们满足约束条件 $n_1 + n_2 + n_3 = N_{\\mathrm{tot}}$。\n我们生成这些状态元组 $(n_1, n_2, n_3)$ 的一个规范的、按字典序排序的列表，记为 $\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})$。这个基的维度是 $d = \\binom{N_{\\mathrm{tot}}+3-1}{3-1} = \\binom{N_{\\mathrm{tot}}+2}{2}$。列表中的每个状态都被分配一个唯一的索引，从而创建了从状态元组到其矩阵索引的映射。\n\n**2. 置换算符**\n反对称化子 $A$ 是对称群 $S_3$ 中六个置换 $\\pi$ 的置换算符 $P_\\pi$ 的线性组合。\n$$\nA = \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi\n$$\n$P_\\pi$ 对基右矢的作用由 $P_\\pi\\,|n_1,n_2,n_3\\rangle = |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle$ 给出。这意味着量子数根据逆置换 $\\pi^{-1}$ 进行重排。\n为了构造 $P_\\pi$ 的 $d \\times d$ 矩阵表示，我们考虑其矩阵元 $(P_\\pi)_{ij} = \\langle i | P_\\pi | j \\rangle$，其中 $|i\\rangle$ 和 $|j\\rangle$ 是基右矢。对于每个基右矢 $|j\\rangle = |n_{j1}, n_{j2}, n_{j3}\\rangle$，我们计算置换后的右矢 $|k\\rangle = P_\\pi |j\\rangle$。然后我们找到索引 $i$ 使得 $|i\\rangle = |k\\rangle$。此时矩阵元 $(P_\\pi)_{ij}$ 为 $1$，而第 $j$ 列的其他所有元素都为 $0$。我们对所有 $\\pi \\in S_3$ 重复此过程。符号 $\\mathrm{sgn}(\\pi)$ 对于偶置换（单位元，3-循环）为 $+1$，对于奇置换（对换）为 $-1$。\n\n**3. 幂等性验证**\n在构造完所有六个 $P_\\pi$ 的矩阵表示后，我们通过它们的带符号和并除以 6 来组装矩阵 $A$。最后一步是计算幂等性缺陷矩阵 $A^2 - A$，并计算其弗罗贝尼乌斯范数 $\\|A^2 - A\\|_F$。对于一个精确的投影算符，这个范数必须为零。对于无自旋费米子，任何有两个或更多粒子具有相同量子数的状态（例如 $|1,1,0\\rangle$ 或 $|2,0,0\\rangle$）都必须被反对称化子湮灭。对于 $N_{\\mathrm{tot}}  3$，任何状态 $|n_1,n_2,n_3\\rangle$ 都必须至少有两个相同的量子数。因此，对于 $N_{\\mathrm{tot}}=0, 1, 2$，算符 $A$ 将每个基态投影到零，使得 $A$ 成为零矩阵。因此，$A^2-A=0$ 且其范数恰好为 $0$。\n\n### 第二部分：在 Jacobi 坐标基中的验证\n\n接下来，我们变换到一个能将质心 (CM) 运动与内部相对运动解耦的基。\n\n**1. 基变换**\n从粒子模式阶梯算符 $(a_1, a_2, a_3)$ 到 Jacobi 模式算符 $(b_\\rho, b_\\lambda, b_{\\mathrm{CM}})$ 的变换由正交矩阵 $O$ 给出。相应的产生算符变换为 $a_i^\\dagger = \\sum_k (O^\\top)_{ik} b_k^\\dagger$。粒子基右矢 $|n_1, n_2, n_3\\rangle$ 可以通过将粒子产生算符作用于真空态来构造：\n$$\n|n_1, n_2, n_3\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} \\frac{(a_3^\\dagger)^{n_3}}{\\sqrt{n_3!}} |0\\rangle\n$$\n通过将 $a_i^\\dagger$ 用 $b_k^\\dagger$ 的表达式代入，我们可以将任何粒子右矢表示为 Jacobi 右矢 $|n_\\rho, n_\\lambda, N_{\\mathrm{CM}}\\rangle$ 的线性组合。这个展开式的系数就是基变换矩阵 $U$ 的矩阵元。这些系数被称为 Talmi-Moshinsky 括号，可以通过带记忆化的递归算法系统地计算。递归过程通过将 $|n_1, ..., n_i, ...\\rangle$ 用 $a_i^\\dagger |n_1, ..., n_i-1, ...\\rangle$ 表示，并利用后者的已知展开式来进行。\n\n**2. 变换后的反对称化子**\n构造出幺正矩阵 $U$ 后，Jacobi 基中的反对称化子通过相似变换得到：$A_{\\mathrm{Jac}} = U A U^\\top$。由于 $U$ 是实矩阵，因此 $U^\\dagger = U^\\top$。\n\n**3. 子空间限制与验证**\n我们感兴趣的是内部子系统的物理，这对应于质心处于其基态的子空间，即 $N_{\\mathrm{CM}}=0$。我们识别出 $A_{\\mathrm{Jac}}$ 中对应于基态 $|n_\\rho, n_\\lambda, 0\\rangle$（其中 $n_\\rho+n_\\lambda=N_{\\mathrm{tot}}$）的行和列。这将产生一个更小的矩阵 $A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}$。然后我们通过计算其缺陷矩阵的弗罗贝尼乌斯范数 $\\| (A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)})^2 - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)} \\|_F$ 来验证在这个子空间中的幂等性。由于所实现的变换是精确的，这个范数在数值上应该为零（即，在机器浮点精度的数量级上）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt\nfrom itertools import permutations\nfrom collections import defaultdict\n\n# Memoization cache for the recursive Jacobi expansion function.\n# A global variable is used for simplicity across calls for a single test case.\n_memo_U_calc = {}\n\n# Pre-calculate permutation information for the symmetric group S3.\n# The permutation action on a state |n1,n2,n3> is defined by reordering\n# the quantum numbers according to pi^{-1}. We compute the inverse for each\n# permutation pi in S3 and its sign.\n_S3_PERMS = []\nfor p in permutations(range(3)):\n    # Create the permutation matrix for 'p' to compute its sign (determinant).\n    mat = np.zeros((3, 3))\n    for i, j in enumerate(p):\n        mat[i, j] = 1\n    sign = int(round(np.linalg.det(mat)))\n    \n    # The permutation 'p' maps index i to p[i]. Its inverse maps p[i] back to i.\n    p_inv = [0, 0, 0]\n    for i, j in enumerate(p):\n        p_inv[j] = i\n    _S3_PERMS.append({'pi_inv': tuple(p_inv), 'sign': sign})\n\n# The problem defines the transformation from particle to Jacobi annihilation\n# operators via an orthogonal matrix O. For creation operators, the transformation\n# involves O transpose. This matrix stores the coefficients for expressing particle\n# creation operators (a_i^\\dagger) as linear combinations of Jacobi creation\n# operators (b_k^\\dagger).\n_O_T = np.array([\n    [1 / sqrt(2),  1 / sqrt(6), 1 / sqrt(3)],\n    [-1 / sqrt(2), 1 / sqrt(6), 1 / sqrt(3)],\n    [0,           -2 / sqrt(6), 1 / sqrt(3)]\n])\n\ndef _generate_basis(n_tot, num_particles):\n    \"\"\"\n    Generates all state tuples (n1, n2, ...) for a given total number of quanta\n    n_tot and number of particles. This is a recursive generator for integer partitions.\n    \"\"\"\n    if num_particles == 1:\n        yield (n_tot,)\n        return\n    for i in range(n_tot + 1):\n        for p in _generate_basis(n_tot - i, num_particles - 1):\n            yield (i,) + p\n\ndef _get_jacobi_expansion(n_tuple):\n    \"\"\"\n    Recursively computes the expansion of a particle state in the Jacobi basis\n    using memoization to store results of subproblems.\n    \"\"\"\n    if n_tuple in _memo_U_calc:\n        return _memo_U_calc[n_tuple]\n    \n    if sum(n_tuple) == 0:\n        # The vacuum state is the same in both bases.\n        return {(0, 0, 0): 1.0}\n\n    # For a canonical recursion path, always decrement the last non-zero quantum number.\n    idx_to_decr = -1\n    for i in range(len(n_tuple) - 1, -1, -1):\n        if n_tuple[i] > 0:\n            idx_to_decr = i\n            break\n    \n    prev_n_list = list(n_tuple)\n    prev_n_list[idx_to_decr] -= 1\n    prev_n_tuple = tuple(prev_n_list)\n\n    prev_coeffs = _get_jacobi_expansion(prev_n_tuple)\n    \n    new_coeffs = defaultdict(float)\n    \n    # Coefficients for a_i^\\dagger = sum_k (O^T)_ik b_k^\\dagger\n    a_op_coeffs = _O_T[idx_to_decr]\n\n    for jacobi_state, old_coeff in prev_coeffs.items():\n        # Action of b_rho^dagger\n        state_rho = (jacobi_state[0] + 1, jacobi_state[1], jacobi_state[2])\n        new_coeffs[state_rho] += old_coeff * a_op_coeffs[0] * sqrt(jacobi_state[0] + 1)\n        \n        # Action of b_lambda^dagger\n        state_lambda = (jacobi_state[0], jacobi_state[1] + 1, jacobi_state[2])\n        new_coeffs[state_lambda] += old_coeff * a_op_coeffs[1] * sqrt(jacobi_state[1] + 1)\n\n        # Action of b_cm^dagger\n        state_cm = (jacobi_state[0], jacobi_state[1], jacobi_state[2] + 1)\n        new_coeffs[state_cm] += old_coeff * a_op_coeffs[2] * sqrt(jacobi_state[2] + 1)\n        \n    # Final normalization factor sqrt(n_i) from a_i^dagger |...n_i-1...>\n    norm_factor = sqrt(n_tuple[idx_to_decr])\n    final_coeffs = {state: val / norm_factor for state, val in new_coeffs.items()}\n        \n    _memo_U_calc[n_tuple] = final_coeffs\n    return final_coeffs\n\ndef solve():\n    \"\"\"\n    Main function to execute the verification for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (0, 'particle'),\n        (1, 'particle'),\n        (2, 'particle'),\n        (3, 'Jacobi'),\n        (4, 'Jacobi')\n    ]\n\n    results = []\n\n    for N_tot, basis_type in test_cases:\n        # Generate and order the basis states for a fixed N_tot. This structure\n        # is used for both the particle and Jacobi bases.\n        temp_basis = _generate_basis(N_tot, 3)\n        # The generator produces tuples in (n3,n2,n1) order; reverse and sort for canonical order.\n        basis = sorted([s[::-1] for s in temp_basis])\n        dim = len(basis)\n        state_map = {state: i for i, state in enumerate(basis)}\n\n        # Construct the antisymmetrizer matrix A in the particle basis.\n        A = np.zeros((dim, dim), dtype=np.float64)\n        for perm_info in _S3_PERMS:\n            pi_inv = perm_info['pi_inv']\n            sign = perm_info['sign']\n            P = np.zeros((dim, dim), dtype=np.float64)\n            for j, state_j in enumerate(basis):\n                permuted_state = (state_j[pi_inv[0]], state_j[pi_inv[1]], state_j[pi_inv[2]])\n                i = state_map[permuted_state]\n                P[i, j] = 1.0\n            A += sign * P\n        A /= 6.0\n\n        if basis_type == 'particle':\n            # Verify idempotency directly in the particle basis.\n            defect = A @ A - A\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n        else: # basis_type == 'Jacobi'\n            global _memo_U_calc\n            _memo_U_calc.clear() # Reset memoization for each new N_tot.\n\n            # Construct the unitary change-of-basis matrix U.\n            U = np.zeros((dim, dim), dtype=np.float64)\n            for j, sp_state in enumerate(basis):\n                expansion = _get_jacobi_expansion(sp_state)\n                for jac_state, coeff in expansion.items():\n                    if jac_state in state_map:\n                        i = state_map[jac_state]\n                        U[i, j] = coeff\n\n            # Transform A to the Jacobi basis.\n            A_jac = U @ A @ U.T\n\n            # Restrict to the N_CM = 0 subspace.\n            ncm0_indices = [i for i, state in enumerate(basis) if state[2] == 0]\n            A_jac_ncm0 = A_jac[np.ix_(ncm0_indices, ncm0_indices)]\n\n            # Verify idempotency in the restricted subspace.\n            defect = A_jac_ncm0 @ A_jac_ncm0 - A_jac_ncm0\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n            \n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "3563419"}, {"introduction": "谐振子基虽然在核物理计算中被广泛使用，但它无法自然地分离系统的质心运动与内禀运动，导致计算结果中出现虚假的质心激发态。本练习将介绍并让你实践劳森方法（Lawson method），这是一种通过引入能量惩罚项来有效抑制这些虚假态的常用技术。通过这个实践，你将学会在有限的模型空间中获得纯净的内禀可观测量，这是确保理论计算物理意义正确的关键一步。[@problem_id:3563429]", "problem": "考虑一个由两个可区分的、等质量的粒子组成的系统，该系统被限制在一个空间维度中，并在谐振子（HO）势中运动。在谐振子单位制下进行计算，其中 $\\hbar = 1$、 $m = 1$ 且 $\\omega = 1$，因此所有能量和长度都是无量纲的。总的双体实验室坐标系哈密顿量为\n$$\nH_{\\text{tot}} = \\sum_{i=1}^{2} \\left( \\frac{p_i^2}{2} + \\frac{x_i^2}{2} \\right),\n$$\n质心哈密顿量为\n$$\nH_{\\text{cm}} = \\frac{(p_1 + p_2)^2}{4} + \\frac{(x_1 + x_2)^2}{4}.\n$$\n将内禀哈密顿量定义为\n$$\nH_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}.\n$$\n通过一个由非负标量 $\\beta$ 参数化的 Lawson 项引入\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - \\frac{1}{2} \\right),\n$$\n该项会移动具有非零质心激发的态，而保持 $0\\hbar\\omega$ 质心扇区不发生移动。\n\n您将使用大小为 $N_{\\text{sp}} + 1$ 的截断单粒子谐振子基（单粒子量子数为 $n = 0, 1, \\dots, N_{\\text{sp}}$）来表示算符，并将双体乘积基限制在总量子数 $n_1 + n_2 \\le N_{\\text{cut}}$ 的子空间内。使用标准的谐振子升降算符 $a$ 和 $a^\\dagger$ 来构建单粒子位置和动量矩阵，\n$$\nx = \\frac{1}{\\sqrt{2}} \\left( a + a^\\dagger \\right), \\quad p = \\frac{i}{\\sqrt{2}} \\left( a^\\dagger - a \\right),\n$$\n然后通过克罗内克和与积来构建双体算符。定义内禀可观测量\n$$\nO_{\\text{rel}} = (x_1 - x_2)^2,\n$$\n它仅依赖于相对坐标，因此是一个内禀算符。\n\n使用的基本出发点：\n- 谐振子的正则升降算符关系，$x$ 和 $p$ 用 $a$ 和 $a^\\dagger$ 表示的定义，以及谐振子单粒子哈密顿量 $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$。\n- 质心坐标 $X_{\\text{cm}} = (x_1 + x_2)/2$ 和动量 $P_{\\text{cm}} = p_1 + p_2$ 的定义，得到 $H_{\\text{cm}} = \\frac{P_{\\text{cm}}^2}{2M} + \\frac{1}{2} M \\omega^2 X_{\\text{cm}}^2$，其中 $M = 2$ 且 $\\omega = 1$，该表达式可简化为给定的 $H_{\\text{cm}}$ 表达式。\n- 在完整的无限希尔伯特空间中，内禀可观测量与质心算符对易，这意味着一旦移除了伪质心激发，内禀可观测量应不受 Lawson 参数 $\\beta$ 的影响。\n\n任务：\n- 对于下面测试套件中的每个参数集，以及该集中指定的每个 $\\beta$ 值，在截断的双体空间中对角化 $H(\\beta)$。在所有本征向量中，找出其 $H_{\\text{cm}}$ 期望值最接近 $1/2$ 的态，该态在截断空间中作为 $0\\hbar\\omega$ 质心扇区的数值代理。对于所选的这个态，计算内禀能量 $E_{\\text{intr}} = \\langle H_{\\text{intr}} \\rangle$ 和内禀可观测量的值 $\\langle O_{\\text{rel}} \\rangle$。\n- 对于每个参数集，将 $\\beta = 0$ 时的结果作为基准，并计算该集中其他 $\\beta$ 值下 $E_{\\text{intr}}$ 和 $\\langle O_{\\text{rel}} \\rangle$ 的最大绝对偏差。如果两个最大值都小于或等于容差 $\\varepsilon = 10^{-6}$，则为该参数集返回布尔值 $\\text{True}$；否则，返回 $\\text{False}$。\n\n所有量在谐振子单位制下都是无量纲的。不涉及角度或百分比。\n\n测试套件：\n- 情况 1：$N_{\\text{sp}} = 6$, $N_{\\text{cut}} = 6$, $\\beta \\in \\{ 0.0, 1.0, 10.0, 50.0 \\}$。\n- 情况 2：$N_{\\text{sp}} = 2$, $N_{\\text{cut}} = 2$, $\\beta \\in \\{ 0.0, 2.0, 20.0 \\}$。\n- 情况 3：$N_{\\text{sp}} = 5$, $N_{\\text{cut}} = 3$, $\\beta \\in \\{ 0.0, 100.0 \\}$。\n- 情况 4（仅边界空间）：$N_{\\text{sp}} = 4$, $N_{\\text{cut}} = 0$, $\\beta \\in \\{ 0.0, 20.0, 200.0 \\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含每个情况的结果，形式为方括号内以逗号分隔的布尔值列表（例如，$[True,False,True,True]$）。", "solution": "该问题是有效的。它提出了一个定义明确、有科学依据的计算量子力学练习，具体涉及在截断基中分离多体系统中的质心运动和内禀运动。这是核结构理论中的一个典型问题。其过程是构建一个特定哈密顿量的矩阵表示，将其对角化，并分析所得基态的性质，以验证所谓的 Lawson 方法的有效性。\n\n理论框架是双粒子一维谐振子（HO）。我们在无量纲的谐振子单位制下工作，其中 $\\hbar = m = \\omega = 1$。\n\n**1. 单粒子基与算符**\n\n计算的基础是单粒子谐振子基，它由单粒子哈密顿量 $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$ 的本征态 $|n\\rangle$ 组成。相应的本征值为 $E_n = n + \\frac{1}{2}$，其中 $n = 0, 1, 2, \\dots$。为了计算上的可行性，该基被截断到有限维度 $N_{\\text{sp}} + 1$，包括 $n=0, 1, \\dots, N_{\\text{sp}}$ 的态 $|n\\rangle$。\n\n在该基中，基本算符是产生算符（$a^\\dagger$）和湮灭算符（$a$），其矩阵元由以下公式给出：\n$$\n\\langle n' | a | n \\rangle = \\sqrt{n} \\, \\delta_{n', n-1}\n$$\n$$\n\\langle n' | a^\\dagger | n \\rangle = \\sqrt{n+1} \\, \\delta_{n', n+1}\n$$\n然后，根据指定的方式从这些升降算符构建位置（$x$）和动量（$p$）算符：\n$$\nx = \\frac{1}{\\sqrt{2}} (a + a^\\dagger)\n$$\n$$\np = \\frac{i}{\\sqrt{2}} (a^\\dagger - a)\n$$\n这些定义得出了 $x$ 和 $p$ 的 $(N_{\\text{sp}}+1) \\times (N_{\\text{sp}}+1)$ 矩阵，它们是所有后续双体算符的构建块。\n\n**2. 双体基与算符**\n\n对于一个由两个可区分粒子组成的系统，其基是单粒子空间的张量积。一个基矢表示为 $|n_1\\rangle \\otimes |n_2\\rangle$ 或简写为 $|n_1, n_2\\rangle$。一个仅作用于粒子 $i$ 的算符 $O$ 在双体空间中表示为 $O_1 = O \\otimes I$ 和 $O_2 = I \\otimes O$，其中 $I$ 是单粒子空间中的单位矩阵。\n\n该问题对双体模型空间施加了一个关键的截断：只保留总量子数 $n_1 + n_2 \\le N_{\\text{cut}}$ 的态 $|n_1, n_2\\rangle$。这定义了进行所有计算的有限维希尔伯特空间。算符必须投影到这个截断的子空间上。实现方法是首先在完整的乘积空间（维度为 $(N_{\\text{sp}}+1)^2$）中构建算符，然后选择与满足 $N_{\\text{cut}}$ 条件的基态相对应的子矩阵。\n\n使用此方法，我们构建所需双体算符的矩阵表示：\n- **总哈密顿量**：$H_{\\text{tot}} = h_{\\text{sp},1} + h_{\\text{sp},2} = (h_{\\text{sp}} \\otimes I) + (I \\otimes h_{\\text{sp}})$。由于 $h_{\\text{sp}}$ 在 $|n\\rangle$ 基中是对角的，因此 $H_{\\text{tot}}$ 在 $|n_1, n_2\\rangle$ 乘积基中也是对角的，其本征值为 $(n_1 + \\frac{1}{2}) + (n_2 + \\frac{1}{2}) = n_1 + n_2 + 1$。\n- **质心哈密顿量**：$H_{\\text{cm}} = \\frac{1}{4}(p_1 + p_2)^2 + \\frac{1}{4}(x_1 + x_2)^2$。这是通过先用克罗内克积构建 $x_1, x_2, p_1, p_2$，然后按规定组合它们而成的。\n- **内禀哈密顿量**：$H_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}$。这代表了相对坐标中的动力学。\n- **相对可观测量**：$O_{\\text{rel}} = (x_1 - x_2)^2$。\n\n**3. Lawson 方法与态的识别**\n\n在无限希尔伯特空间中，总哈密顿量可以完美地分离，$H_{\\text{tot}} = H_{\\text{cm}} + H_{\\text{intr}}$，其本征态是内禀本征态和质心本征态的简单乘积。因此，与 $H_{\\text{cm}}$ 对易的内禀可观测量（如 $O_{\\text{rel}}$）的期望值独立于质心状态。\n\n然而，将基截断到 $n_1+n_2 \\le N_{\\text{cut}}$ 会破坏这种可分离性。在截断空间中，$H_{\\text{tot}}$（或 $H_{\\text{intr}}$）的本征态变成了不同质心激发的混合态。这是一个普遍存在的问题，称为“质心污染”。\n\nLawson 方法旨在缓解此问题。我们引入修正后的哈密顿量：\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - E_{\\text{cm},0} \\right)\n$$\n这里，$E_{\\text{cm},0} = \\frac{1}{2}$ 是质心基态的能量（一个质量 $M=2$、频率 $\\omega=1$ 的谐振子）。对于一个大的正参数 $\\beta$，该项会对任何不处于质心基态的态施加一个大的能量惩罚。因此，对角化 $H(\\beta)$ 会得到一个低能本征态，该态主要由真实的内禀基态构成，而伪质心激发则被抑制。\n\n计算任务是针对不同的 $\\beta$ 值对角化 $H(\\beta)$ 的矩阵。所期望的“物理”态被识别为这样的本征向量 $|\\psi\\rangle$，其期望值 $\\langle\\psi|H_{\\text{cm}}|\\psi\\rangle$ 最接近目标质心基态能量 $\\frac{1}{2}$。\n\n**4. 计算与验证**\n\n对于已识别的态 $|\\psi\\rangle$，我们计算内禀能量的期望值 $E_{\\text{intr}} = \\langle\\psi|H_{\\text{intr}}|\\psi\\rangle$ 和内禀可观测量的期望值 $\\langle O_{\\text{rel}} \\rangle = \\langle\\psi|O_{\\text{rel}}|\\psi\\rangle$。\n\n中心假设是，随着 $\\beta$ 的增加，这些内禀量应收敛到其真实的、未受污染的值。$\\beta=0$ 的情况代表未经校正的结果。任务要求计算当 $\\beta  0$ 时，$E_{\\text{intr}}$ 和 $\\langle O_{\\text{rel}} \\rangle$ 相对于 $\\beta=0$ 基准的最大绝对偏差。如果这些偏差低于指定的容差 $\\varepsilon = 10^{-6}$，则证实 Lawson 方法对于给定的截断是有效的，并且计算出的内禀性质对投影参数是稳定的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'N_sp': 6, 'N_cut': 6, 'betas': [0.0, 1.0, 10.0, 50.0]},\n        # Case 2\n        {'N_sp': 2, 'N_cut': 2, 'betas': [0.0, 2.0, 20.0]},\n        # Case 3\n        {'N_sp': 5, 'N_cut': 3, 'betas': [0.0, 100.0]},\n        # Case 4\n        {'N_sp': 4, 'N_cut': 0, 'betas': [0.0, 20.0, 200.0]}\n    ]\n    tolerance = 1e-6\n    final_results = []\n\n    for case_params in test_cases:\n        obs_results = []\n        for beta in case_params['betas']:\n            E_intr, O_rel_val = calculate_observables(case_params['N_sp'], case_params['N_cut'], beta)\n            obs_results.append((E_intr, O_rel_val))\n            \n        baseline_E_intr, baseline_O_rel = obs_results[0]\n        \n        max_dev_E = 0.0\n        max_dev_O = 0.0\n        \n        if len(obs_results) > 1:\n            for E, O in obs_results[1:]:\n                max_dev_E = max(max_dev_E, abs(E - baseline_E_intr))\n                max_dev_O = max(max_dev_O, abs(O - baseline_O_rel))\n        \n        is_stable = (max_dev_E = tolerance) and (max_dev_O = tolerance)\n        final_results.append(is_stable)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef calculate_observables(N_sp, N_cut, beta):\n    \"\"\"\n    Constructs and solves the quantum system for a given set of parameters.\n    \"\"\"\n    sp_dim = N_sp + 1\n\n    # 1. Construct single-particle operators.\n    n_range = np.arange(sp_dim)\n    a = np.diag(np.sqrt(n_range[1:]), k=1)\n    a_dag = a.T\n    x = (a + a_dag) / np.sqrt(2)\n    p = 1j * (a_dag - a) / np.sqrt(2)\n    I_sp = np.identity(sp_dim)\n\n    # 2. Identify the basis states for the truncated space.\n    basis_indices = []\n    for n1 in range(sp_dim):\n        for n2 in range(sp_dim):\n            if n1 + n2 = N_cut:\n                basis_indices.append(n1 * sp_dim + n2)\n    \n    basis_dim = len(basis_indices)\n    if basis_dim == 0:\n        return np.nan, np.nan\n\n    # 3. Construct full two-body operators and project them.\n    x1_full = np.kron(x, I_sp)\n    x2_full = np.kron(I_sp, x)\n    p1_full = np.kron(p, I_sp)\n    p2_full = np.kron(I_sp, p)\n    \n    H_tot_full = np.kron(np.diag(np.arange(sp_dim) + 0.5), I_sp) + np.kron(I_sp, np.diag(np.arange(sp_dim) + 0.5))\n    H_cm_full = 0.25 * ((p1_full + p2_full) @ (p1_full + p2_full)) + 0.25 * ((x1_full + x2_full) @ (x1_full + x2_full))\n    H_intr_full = H_tot_full - H_cm_full\n    O_rel_full = (x1_full - x2_full) @ (x1_full - x2_full)\n    \n    H_intr = H_intr_full[np.ix_(basis_indices, basis_indices)].real\n    H_cm = H_cm_full[np.ix_(basis_indices, basis_indices)].real\n    O_rel = O_rel_full[np.ix_(basis_indices, basis_indices)].real\n    \n    # 4. Lawson Hamiltonian and diagonalization.\n    H_beta = H_intr + beta * (H_cm - 0.5 * np.identity(basis_dim))\n    \n    eigvals, eigvecs = np.linalg.eigh(H_beta)\n    \n    # 5. Find the physical state and calculate observables.\n    hcm_exp_vals = np.einsum('ji,jk,ki->i', eigvecs.conj(), H_cm, eigvecs)\n    \n    physical_state_idx = np.argmin(np.abs(hcm_exp_vals - 0.5))\n    physical_vec = eigvecs[:, physical_state_idx]\n\n    E_intr_val = (physical_vec.conj().T @ H_intr @ physical_vec).real\n    O_rel_val = (physical_vec.conj().T @ O_rel @ physical_vec).real\n    \n    return E_intr_val, O_rel_val\n\nsolve()\n```", "id": "3563429"}, {"introduction": "一个好的基底选择对于高效的核多体计算至关重要，而谐振子基虽然方便，但未必是最高效的。本练习将引导你实现一种重要的基矢优化技术：通过对角化单体密度矩阵（OBDM），将系统从雅可比谐振子基变换到自然轨道（NO）基。你将通过量化基矢的压缩率和哈密顿量非对角成分的变化，亲身体验自然轨道基是如何以最少的自由度抓住系统主要物理的，这是处理大规模模型空间计算的核心策略之一。[@problem_id:3563403]", "problem": "考虑一个维度为 $N$ 的有限正交归一的雅可比坐标谐振子（HO）单粒子态基，以及一个 $A$ 体态，其单体密度矩阵（OBDM）$\\rho$ 在该基下给出。在无量纲谐振子单位制下进行计算，其中约化普朗克常数和振子频率被缩放为1，因此无需物理单位。角度必须以弧度表示。从线性代数和量子力学的第一性原理出发，对测试套件中的每一组参数执行以下任务。\n\n基本根据和定义：\n- 单体密度矩阵（OBDM）$\\rho$ 定义为 $\\rho_{ij} = \\langle a_j^\\dagger a_i \\rangle$，其中 $a_i$ 和 $a_j^\\dagger$ 是单粒子基态的湮灭和产生算符。矩阵 $\\rho$ 是厄米（Hermitian）且半正定的。\n- 自然轨道（NO）通过对角化 $\\rho$ 获得。如果 $U$ 是一个幺正矩阵，其列是 $\\rho$ 的特征向量，且 $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_N)$ 是特征值的对角矩阵，则 $U^\\dagger \\rho U = \\Lambda$。将特征值按降序排列，即可定义自然轨道基。\n- 基压缩定义为保留最小的整数 $K$，使得累积占据分数满足 $\\sum_{i=1}^K \\lambda_i \\big/ \\sum_{i=1}^N \\lambda_i \\ge \\tau$，其中 $0  \\tau \\le 1$ 是一个阈值。\n- 给定原始雅可比坐标谐振子基下的一个厄米哈密顿矩阵 $H$，其在自然轨道基下的矩阵为 $H' = U^\\dagger H U$。压缩后的哈密顿量是左上角的 $K \\times K$ 主子矩阵 $H'_K$。\n- 矩阵 $M$ 的非对角分数定义为\n$$\nf_{\\mathrm{off}}(M) = \\frac{\\left\\| M - \\mathrm{diag}(\\mathrm{diag}(M)) \\right\\|_F}{\\| M \\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数，$\\mathrm{diag}(\\mathrm{diag}(M))$ 表示由 $M$ 的对角线元素构成的对角矩阵。\n\n测试实例的构建规则：\n1. 构建一个正交矩阵 $Q$，该矩阵是在指数平面 $(p,q)$ 上以角度 $\\theta$ 作用的一系列吉文斯旋转的有序左乘积。一个吉文斯旋转 $G^{(p,q)}(\\theta)$ 在除 $(p,q)$ 平面外的所有坐标上都是单位矩阵，而在 $(p,q)$ 平面上具有 $2 \\times 2$ 的块\n$$\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta \\\\\n-\\sin\\theta  \\cos\\theta\n\\end{pmatrix}.\n$$\n给定一个有序列表 $\\{(p_1,q_1,\\theta_1), \\dots, (p_m,q_m,\\theta_m)\\}$，定义\n$$\nQ = G^{(p_m,q_m)}(\\theta_m)\\cdots G^{(p_2,q_2)}(\\theta_2) G^{(p_1,q_1)}(\\theta_1).\n$$\n在下文的规范中，索引 $p_\\ell,q_\\ell$ 是从1开始的。\n2. 给定一个由预设非负特征值构成的对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_N)$，通过以下方式定义OBDM\n$$\n\\rho = Q \\Lambda Q^\\top.\n$$\n3. 通过以下方式定义一个实对称的有效单体哈密顿量 $H$\n$$\nH_{ii} = b + a\\,(i-1), \\quad i=1,\\dots,N,\n$$\n$$\nH_{ij} =\n\\begin{cases}\nt_1,  |i-j|=1, \\\\\nt_2,  |i-j|=2, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n并设置 $H_{ji}=H_{ij}$ 以强制其厄米性。\n\n每个测试用例的计算任务：\n- 对角化 $\\rho$ 以获得自然轨道基 $U$ 和按降序排列的特征值 $\\{\\lambda_i\\}$。\n- 确定最小的 $K$ 使得 $\\sum_{i=1}^K \\lambda_i \\big/ \\sum_{i=1}^N \\lambda_i \\ge \\tau$。\n- 计算压缩比 $K/N$。\n- 计算变换前的非对角分数 $f_{\\mathrm{off}}(H)$ 和变换并截断后的非对角分数 $f_{\\mathrm{off}}(H'_K)$，其中 $H' = U^\\dagger H U$ 且 $H'_K$ 是其左上角的 $K\\times K$ 主子矩阵。\n- 计算非对角分数的变化量 $\\Delta = f_{\\mathrm{off}}(H'_K) - f_{\\mathrm{off}}(H)$。\n\n测试套件：\n为以下参数集提供结果。所有角度均以弧度为单位。所有量均为无量纲。\n\n- 测试用例1：\n  - $N = 4$\n  - 特征值：$\\{\\lambda_i\\} = [1.5, 0.8, 0.4, 0.3]$\n  - 吉文斯旋转（有序左乘积）：$\\{(1,2, 0.3), (3,4, -0.5), (1,3, 0.25), (2,4, -0.35)\\}$\n  - 哈密顿量参数：$a = 0.7$, $b = 0.5$, $t_1 = 0.25$, $t_2 = 0.08$\n  - 阈值：$\\tau = 0.9$\n- 测试用例2：\n  - $N = 4$\n  - 特征值：$\\{\\lambda_i\\} = [2.0, 2.0, 0.5, 0.5]$\n  - 吉文斯旋转（有序左乘积）：$\\{(1,4, 0.4), (2,3, -0.6), (1,2, 0.2)\\}$\n  - 哈密顿量参数：$a = 0.5$, $b = 1.0$, $t_1 = 0.3$, $t_2 = 0.0$\n  - 阈值：$\\tau = 1.0$\n- 测试用例3：\n  - $N = 5$\n  - 特征值：$\\{\\lambda_i\\} = [1.2, 0.9, 0.6, 0.2, 0.1]$\n  - 吉文斯旋转（有序左乘积）：$\\{(1,2, -0.2), (3,4, 0.5), (4,5, -0.3), (2,5, 0.4)\\}$\n  - 哈密顿量参数：$a = 0.4$, $b = 0.7$, $t_1 = 0.2$, $t_2 = 0.05$\n  - 阈值：$\\tau = 0.5$\n\n要求的输出：\n- 对于每个测试用例，输出一个包含四个浮点数的列表 $[K/N, f_{\\mathrm{off}}(H), f_{\\mathrm{off}}(H'_K), \\Delta]$。\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来。每个用例的列表也用其自己的方括号括起来，例如：“[[x11,x12,x13,x14],[x21,x22,x23,x24],[x31,x32,x33,x34]]”。最终输出行中不得有多余的空格。", "solution": "用户提供了一个位于核多体理论领域的计算问题，具体涉及基变换和截断。该问题是自洽的、科学上有效的，并且算法上是明确定义的。我将按照要求，从基本原理开始，提供详细的解决方案。\n\n核心任务是在改变基之前和之后，分析一个模型单体哈密顿量 $H$ 的性质。初始基是一组通用的、正交归一的谐振子态。最终基是“自然轨道”（NO）基，其定义为单体密度矩阵（OBDM）$\\rho$ 的本征基。这个过程在多体计算中是基础性的，因为自然轨道基为截断庞大的单粒子希尔伯特空间提供了一个最优的表示，同时保留了OBDM中包含的最重要的物理信息。\n\n对于每个测试用例，解决方案系统地按以下步骤进行：\n1.  在谐振子（HO）基中构建初始哈密顿矩阵 $H$。\n2.  在相同的HO基中构建单体密度矩阵 $\\rho$。\n3.  对角化 $\\rho$ 以找到自然轨道（特征向量矩阵 $U$）和相应的占据数（特征值 $\\{\\lambda_i\\}$）。\n4.  基于累积占据阈值 $\\tau$ 确定截断后的基维度 $K$。\n5.  将哈密顿量变换到自然轨道基（$H' = U^\\dagger H U$），然后截断到维度 $K$（得到 $H'_K$）。\n6.  计算并比较初始哈密顿量 $H$ 和截断后的变换哈密顿量 $H'_K$ 的“非对角分数”。\n\n### 步骤1：构建哈密顿量\n问题定义了一个实对称的单体哈密顿量 $H$，其处于一个 $N$ 维基中。矩阵元素由以下公式给出：\n$$\nH_{ij} =\n\\begin{cases}\nb + a(i-1)  \\text{if } i=j \\\\\nt_1  \\text{if } |i-j|=1 \\\\\nt_2  \\text{if } |i-j|=2 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n其中索引 $i, j$ 从 $1$ 到 $N$。每个测试用例都提供了参数 $a$、 $b$、 $t_1$ 和 $t_2$。这个结构代表了一个简单的模型，其中单粒子能量随指数（例如，壳层数）线性增加，并且态之间存在短程相互作用或跃迁项。\n\n### 步骤2：构建单体密度矩阵\nOBDM $\\rho$ 由其谱分解指定。根据谱定理，任何厄米矩阵（如 $\\rho$）都可以写成 $\\rho = Q \\Lambda Q^\\dagger$，其中 $\\Lambda$ 是其真实特征值的对角矩阵，而 $Q$ 是一个幺正矩阵，其列是相应的特征向量。\n问题提供了 $\\rho$ 的特征值（占据数），形式为对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_1, \\dots, \\lambda_N)$，并将矩阵 $Q$ 定义为一个由一系列吉文斯旋转构成的正交矩阵。\n吉文斯旋转 $G^{(p,q)}(\\theta)$ 是一个正交矩阵，除了在 $(p,q)$ 平面上的一个 $2 \\times 2$ 旋转外，它等于单位矩阵：\n$$\n\\begin{blockarray}{ccccccc}\n p   q  \\\\\n\\begin{block}{c(cc|ccc)}\np  \\cos\\theta  \\cdots  \\sin\\theta  \\cdots \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\\\\nq  -\\sin\\theta  \\cdots  \\cos\\theta  \\cdots \\\\\n\\vdots  \\vdots   \\vdots  \\ddots \\\\\n\\end{block}\n\\end{blockarray}\n$$\n给定一个旋转的有序列表 $\\{(p_1,q_1,\\theta_1), \\dots, (p_m,q_m,\\theta_m)\\}$，正交矩阵 $Q$ 通过有序左乘积构建：\n$$\nQ = G^{(p_m,q_m)}(\\theta_m) \\cdots G^{(p_2,q_2)}(\\theta_2) G^{(p_1,q_1)}(\\theta_1)\n$$\nOBDM 于是定义为 $\\rho = Q \\Lambda Q^\\top$。由于 $Q$ 是实正交矩阵（$Q^\\top = Q^{-1} = Q^\\dagger$）且 $\\Lambda$ 是实数矩阵，所以 $\\rho$ 是实对称的。由于给定的特征值 $\\lambda_i$ 是非负的，$\\rho$ 是半正定的，满足了密度矩阵的物理要求。\n\n### 步骤3：寻找自然轨道基\n根据定义，自然轨道基是使OBDM对角化的基。变换矩阵 $U$ 的列是自然轨道，对角元素是占据数。为了找到这个基，我们必须求解所构建矩阵 $\\rho$ 的特征值问题：\n$$\n\\rho \\mathbf{v}_i = \\lambda'_i \\mathbf{v}_i\n$$\n特征向量 $\\mathbf{v}_i$ 构成了幺正矩阵 $U = [\\mathbf{v}_1, \\mathbf{v}_2, \\dots, \\mathbf{v}_N]$ 的列。特征值 $\\lambda'_i$ 是占据数。关键在于，为了对用于截断的自然轨道基有一个一致的定义，占据数必须按降序排序，$\\lambda'_1 \\ge \\lambda'_2 \\ge \\dots \\ge \\lambda'_N$，并且 $U$ 的列（自然轨道）必须相应地排序。所构建矩阵 $\\rho$ 的特征值 $\\{\\lambda'_i\\}$ 将与用于构成 $\\Lambda$ 的初始 $\\{\\lambda_i\\}$ 相同，但它们与基态的关联现在由对角化确定。\n\n### 步骤4：基压缩\n自然轨道基的效用在于其近似计算的效率。占据数 $\\lambda'_i$ 代表了每个自然轨道在多体态中的重要性。占据数大的轨道在计算中应优先保留。我们通过仅保留 $K$ 个最重要的轨道来压缩基空间。维度 $K$ 是通过找到满足指定阈值 $\\tau \\in (0, 1]$ 的累积占据分数的最小整数来确定的：\n$$\n\\frac{\\sum_{i=1}^K \\lambda'_i}{\\sum_{i=1}^N \\lambda'_i} \\ge \\tau\n$$\n如果基态如此归一化，则总占据数 $\\sum_{i=1}^N \\lambda'_i = \\mathrm{Tr}(\\rho)$ 是系统中的粒子数。压缩比就是 $K/N$。\n\n### 步骤5：哈密顿量变换和截断\n最初在谐振子基中表示的哈密顿量 $H$，通过幺正相似变换转换为自然轨道基：\n$$\nH' = U^\\dagger H U\n$$\n由于我们的 $U$ 是实正交的，这等于 $H' = U^\\top H U$。这个变换保留了哈密顿量的所有性质，例如其特征值。矩阵 $H'$ 代表与 $H$ 相同的算符，只是写在了新的基中。\n最后一步是将基压缩应用于哈密顿量。这是通过取 $H'$ 的左上角 $K \\times K$ 主子矩阵来完成的，记为 $H'_K$。此操作对应于将哈密顿量投影到由 $K$ 个最重要的自然轨道张成的子空间上。\n\n### 步骤6：量化非对角性\n这种变换的一个关键目标通常是使哈密顿量“更对角化”，这简化了后续的计算。我们使用非对角分数 $f_{\\mathrm{off}}(M)$ 来量化任何矩阵 $M$ 的对角性，该分数使用弗罗贝尼乌斯范数定义，$\\|M\\|_F = \\sqrt{\\sum_{i,j} |M_{ij}|^2}$：\n$$\nf_{\\mathrm{off}}(M) = \\frac{\\left\\| M - \\mathrm{diag}(\\mathrm{diag}(M)) \\right\\|_F}{\\| M \\|_F}\n$$\n分子是矩阵将其对角元素置零后的弗罗贝尼乌斯范数。这可以更高效地计算为 $\\sqrt{\\|M\\|_F^2 - \\|\\mathrm{diag}(M)\\|_F^2}$。$f_{\\mathrm{off}}(M)=0$ 的值意味着 $M$ 是对角矩阵，而接近1的值意味着矩阵元素集中在非对角线上。我们为初始哈密顿量 $H$ 和最终截断的哈密顿量 $H'_K$ 计算这个量，以评估自然轨道变换和截断的效果。变化由 $\\Delta = f_{\\mathrm{off}}(H'_K) - f_{\\mathrm{off}}(H)$ 来衡量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 4,\n            \"lambdas\": [1.5, 0.8, 0.4, 0.3],\n            \"givens\": [(1, 2, 0.3), (3, 4, -0.5), (1, 3, 0.25), (2, 4, -0.35)],\n            \"ham_params\": {\"a\": 0.7, \"b\": 0.5, \"t1\": 0.25, \"t2\": 0.08},\n            \"tau\": 0.9,\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"lambdas\": [2.0, 2.0, 0.5, 0.5],\n            \"givens\": [(1, 4, 0.4), (2, 3, -0.6), (1, 2, 0.2)],\n            \"ham_params\": {\"a\": 0.5, \"b\": 1.0, \"t1\": 0.3, \"t2\": 0.0},\n            \"tau\": 1.0,\n        },\n        # Test case 3\n        {\n            \"N\": 5,\n            \"lambdas\": [1.2, 0.9, 0.6, 0.2, 0.1],\n            \"givens\": [(1, 2, -0.2), (3, 4, 0.5), (4, 5, -0.3), (2, 5, 0.4)],\n            \"ham_params\": {\"a\": 0.4, \"b\": 0.7, \"t1\": 0.2, \"t2\": 0.05},\n            \"tau\": 0.5,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = _solve_case(\n            case[\"N\"],\n            case[\"lambdas\"],\n            case[\"givens\"],\n            case[\"ham_params\"],\n            case[\"tau\"],\n        )\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str_list = []\n    for res in all_results:\n        # Format each list of floats into a string \"[f1,f2,f3,f4]\"\n        # Using a sufficient number of decimal places for precision.\n        formatted_res = \",\".join([f\"{val:.12f}\" for val in res])\n        results_str_list.append(f\"[{formatted_res}]\")\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\ndef _calc_off_diagonal_fraction(M):\n    \"\"\"\n    Computes the off-diagonal fraction of a matrix M.\n    f_off(M) = ||M - diag(diag(M))||_F / ||M||_F\n    \"\"\"\n    if M.size == 0:\n        return 0.0\n    \n    norm_M_sq = np.sum(M**2)\n    if norm_M_sq == 0:\n        return 0.0\n\n    diag_M = np.diag(M)\n    norm_diag_M_sq = np.sum(diag_M**2)\n    \n    norm_offdiag_M = np.sqrt(max(0, norm_M_sq - norm_diag_M_sq))\n    \n    return norm_offdiag_M / np.sqrt(norm_M_sq)\n\ndef _solve_case(N, lambdas_diag, givens_rotations, ham_params, tau):\n    \"\"\"\n    Performs all computational tasks for a single test case.\n    \"\"\"\n    # Step 1: Construct the Hamiltonian H\n    a, b, t1, t2 = ham_params[\"a\"], ham_params[\"b\"], ham_params[\"t1\"], ham_params[\"t2\"]\n    H = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                H[i, j] = b + a * i\n            elif abs(i - j) == 1:\n                H[i, j] = t1\n            elif abs(i - j) == 2:\n                H[i, j] = t2\n    \n    # Step 2: Construct the orthogonal matrix Q from Givens rotations\n    Q = np.identity(N)\n    for p, q, theta in givens_rotations:\n        p_idx, q_idx = p - 1, q - 1 # Convert 1-based to 0-based index\n        G = np.identity(N)\n        c, s = np.cos(theta), np.sin(theta)\n        G[p_idx, p_idx] = c\n        G[p_idx, q_idx] = s\n        G[q_idx, p_idx] = -s\n        G[q_idx, q_idx] = c\n        Q = G @ Q\n\n    # Step 3: Construct the one-body density matrix rho\n    Lambda = np.diag(lambdas_diag)\n    rho = Q @ Lambda @ Q.T\n\n    # Step 4: Diagonalize rho to get the natural orbital basis U\n    # np.linalg.eigh returns eigenvalues in ascending order.\n    evals, evecs = np.linalg.eigh(rho)\n    # Sort eigenvalues in descending order and reorder eigenvectors accordingly\n    sort_indices = np.argsort(evals)[::-1]\n    sorted_evals = evals[sort_indices]\n    U = evecs[:, sort_indices]\n\n    # Step 5: Determine the minimal truncation dimension K\n    total_occupation = np.sum(sorted_evals)\n    threshold_sum = tau * total_occupation\n    \n    # Handle the edge case of total_occupation being zero\n    if total_occupation == 0:\n        K = N\n    # Handle threshold tau requiring all states.\n    # Floating point comparison needs a tolerance.\n    elif np.isclose(tau, 1.0):\n        K = N\n    else:\n        cumulative_occupation = 0.0\n        K = 0\n        for i in range(N):\n            cumulative_occupation += sorted_evals[i]\n            if cumulative_occupation >= threshold_sum - 1e-12: # Add tolerance for float comparison\n                K = i + 1\n                break\n        if K == 0 and N > 0: # Failsafe if tau > 0 and all occupations are 0\n             K=N\n\n    # Step 6: Compute compression ratio\n    compression_ratio = K / N\n\n    # Step 7: Compute off-diagonal fractions\n    f_off_H = _calc_off_diagonal_fraction(H)\n\n    # Transform Hamiltonian to NO basis\n    H_prime = U.T @ H @ U\n    \n    # Truncate to KxK\n    H_prime_K = H_prime[:K, :K]\n\n    f_off_H_prime_K = _calc_off_diagonal_fraction(H_prime_K)\n    \n    # Step 8: Compute change in off-diagonal fraction\n    delta = f_off_H_prime_K - f_off_H\n    \n    return [compression_ratio, f_off_H, f_off_H_prime_K, delta]\n\nsolve()\n```", "id": "3563403"}]}