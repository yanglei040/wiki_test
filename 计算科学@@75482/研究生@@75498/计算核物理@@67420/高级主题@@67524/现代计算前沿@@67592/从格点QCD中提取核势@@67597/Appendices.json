{"hands_on_practices": [{"introduction": "在HAL QCD方法中，从非定域的相互作用核中提取定域核势依赖于一个关键的导数展开。这个实践练习旨在通过比较动量空间中的精确核与其泰勒级数近似，来量化这种展开的截断误差。通过这个练习，你将亲手验证这种近似的有效性范围，并理解其收敛性如何依赖于相互作用的非定域标度和相关的动量大小 [@problem_id:3558782]。", "problem": "在计算核物理中，一种从格点量子色动力学（LQCD）关联函数中提取核子-核子相互作用的方法，是用局域算符级数（微分展开）来替代精确的非局域核。为了评估这种展开的有效性，我们考虑一个简化的、但在科学上一致的、具有显式自旋结构的三维平移不变双体核。令非局域势算符定义为\n$$(U\\psi)(\\mathbf{r}) \\equiv \\int d^3\\mathbf{r}' \\; U(\\mathbf{r},\\mathbf{r}') \\, \\psi(\\mathbf{r}') \\, ,$$\n其中\n$$U(\\mathbf{r},\\mathbf{r}') = \\left[C + D\\,\\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2\\right] \\, g(|\\mathbf{r}-\\mathbf{r}'|) \\, ,$$\n其中 $C$ 和 $D$ 是实常数，$\\boldsymbol{\\sigma}_1$ 和 $\\boldsymbol{\\sigma}_2$ 是作用于核子1和2的泡利自旋算符，而 $g(|\\mathbf{s}|)$ 是一个球对称、归一化的高斯函数，\n$$g(|\\mathbf{s}|) = \\frac{\\alpha^3}{\\pi^{3/2}} \\, \\exp\\!\\left(-\\alpha^2 |\\mathbf{s}|^2\\right), \\quad \\mathbf{s} \\equiv \\mathbf{r}-\\mathbf{r}' \\, ,$$\n其中 $\\alpha>0$ 是一个实的非局域性尺度。在总自旋基中，对于自旋单态道（$S=0$），我们有精确期望值 $\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle = -3$；对于自旋三重态道（$S=1$），我们有精确期望值 $\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle = +1$。因为该核是平移不变的，所以它在动量空间中的作用是乘性的。用 $G(|\\mathbf{k}|)$ 表示 $g(|\\mathbf{s}|)$ 的三维傅里叶变换，用 $A_S(|\\mathbf{k}|)$ 表示在自旋道 $S \\in \\{0,1\\}$ 中相应的精确动量空间振幅：\n$$A_S(|\\mathbf{k}|) = \\left[C + D\\,\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S \\right] \\, G(|\\mathbf{k}|) \\, .$$\n$2M$ 阶的微分展开截断用一个局域微分算符取代了非局域算符，该局域微分算符在动量空间中的作用等于 $G(|\\mathbf{k}|)$ 在 $|\\mathbf{k}|=0$ 附近到 $2M$ 阶的泰勒多项式。将此多项式记为 $P_{2M}(|\\mathbf{k}|)$，相应的截断振幅记为\n$$A^{(2M)}_S(|\\mathbf{k}|) = \\left[C + D\\,\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S \\right] \\, P_{2M}(|\\mathbf{k}|) \\, .$$\n\n您的任务是编写一个完整的程序，针对一组测试用例，计算微分展开在离散动量格点上的最大相对误差。\n$$\\mathcal{K} = \\{\\, |\\mathbf{k}| = 0, \\Delta k, 2\\Delta k, \\dots, k_{\\max} \\,\\} \\, ,$$\n该格点由指定的 $k_{\\max}$ 和步长 $\\Delta k$ 定义，使得 $k_{\\max}/\\Delta k$ 为整数。对于一个给定的测试用例，最大相对误差为\n$$\\varepsilon_{\\max} = \\max_{|\\mathbf{k}|\\in\\mathcal{K}} \\frac{\\left|\\, A_S(|\\mathbf{k}|) - A^{(2M)}_S(|\\mathbf{k}|) \\,\\right|}{\\left|\\, A_S(|\\mathbf{k}|) \\,\\right|} \\, .$$\n\n您可以假定的基本依据：\n- 傅里叶变换的线性性质和三维卷积定理。\n- 解析函数在一点附近的泰勒多项式定义。\n- 已知的自旋期望值 $\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S \\in \\{-3,+1\\}$（对于 $S\\in\\{0,1\\}$）。\n\n实现以下测试套件。每个测试用例提供 $(\\alpha, C, D, S, M, k_{\\max}, \\Delta k)$，其中 $S$ 是自旋道（$S=0$ 表示单态，$S=1$ 表示三重态），$2M$ 是截断中保留的最高微分阶数：\n- 测试 1: $\\alpha = 1.0$, $C = 50.0$, $D = -10.0$, $S = 0$, $M = 0$, $k_{\\max} = 1.0$, $\\Delta k = 0.05$。\n- 测试 2: $\\alpha = 1.0$, $C = 50.0$, $D = -10.0$, $S = 0$, $M = 1$, $k_{\\max} = 1.0$, $\\Delta k = 0.05$。\n- 测试 3: $\\alpha = 1.0$, $C = 50.0$, $D = -10.0$, $S = 0$, $M = 2$, $k_{\\max} = 1.0$, $\\Delta k = 0.05$。\n- 测试 4: $\\alpha = 0.7$, $C = 50.0$, $D = -10.0$, $S = 1$, $M = 0$, $k_{\\max} = 2.0$, $\\Delta k = 0.10$。\n- 测试 5: $\\alpha = 0.7$, $C = 50.0$, $D = -10.0$, $S = 1$, $M = 1$, $k_{\\max} = 2.0$, $\\Delta k = 0.10$。\n- 测试 6: $\\alpha = 0.7$, $C = 50.0$, $D = -10.0$, $S = 1$, $M = 2$, $k_{\\max} = 2.0$, $\\Delta k = 0.10$。\n- 测试 7: $\\alpha = 0.4$, $C = 50.0$, $D = -10.0$, $S = 1$, $M = 2$, $k_{\\max} = 2.5$, $\\Delta k = 0.10$。\n- 测试 8: $\\alpha = 2.0$, $C = 50.0$, $D = -10.0$, $S = 0$, $M = 0$, $k_{\\max} = 2.5$, $\\Delta k = 0.10$。\n\n科学约束和说明：\n- 使用由指定的 $g(|\\mathbf{s}|)$ 和基本高斯积分所隐含的精确三维傅里叶变换 $G(|\\mathbf{k}|)$。然后将 $P_{2M}(|\\mathbf{k}|)$ 构建为关于 $|\\mathbf{k}|=0$ 的 $2M$ 阶泰勒多项式。\n- 使用上面定义的格点 $\\mathcal{K}$ 为每个测试计算 $\\varepsilon_{\\max}$。\n- 所有计算出的误差都是无量纲的。将每个 $\\varepsilon_{\\max}$ 报告为小数点后保留六位的小数。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含结果，结果为逗号分隔的列表，用方括号括起来，顺序与上面列出的测试相同。例如，输出必须类似于 $[x_1,x_2,\\dots,x_8]$，其中每个 $x_i$ 是一个四舍五入到六位小数的十进制数，并且没有附加文本。", "solution": "该问题要求计算用局域微分展开近似非局域核子-核子势时引入的最大相对误差。以下步骤详述的验证过程确认了该问题在科学上是合理的、适定的和客观的。\n\n### 步骤1：问题分析与简化\n主要任务是计算在离散动量格点 $\\mathcal{K}$ 上的最大相对误差 $\\varepsilon_{\\max}$。误差定义为：\n$$ \\varepsilon_{\\max} = \\max_{|\\mathbf{k}|\\in\\mathcal{K}} \\frac{\\left|\\, A_S(|\\mathbf{k}|) - A^{(2M)}_S(|\\mathbf{k}|) \\,\\right|}{\\left|\\, A_S(|\\mathbf{k}|) \\,\\right|} $$\n精确和近似的动量空间振幅 $A_S(|\\mathbf{k}|)$ 和 $A^{(2M)}_S(|\\mathbf{k}|)$ 由以下公式给出：\n$$ A_S(|\\mathbf{k}|) = \\left[C + D\\,\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S \\right] \\, G(|\\mathbf{k}|) $$\n$$ A^{(2M)}_S(|\\mathbf{k}|) = \\left[C + D\\,\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S \\right] \\, P_{2M}(|\\mathbf{k}|) $$\n对于给定的自旋道 $S$，$V_S \\equiv C + D\\,\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_S$ 项是一个恒定的前置因子。对于这些测试用例，$C=50.0$ 且 $D=-10.0$。对于自旋单态道（$S=0$），$\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_0 = -3$，得到 $V_0 = 50.0 + (-10.0)(-3) = 80.0$。对于自旋三重态道（$S=1$），$\\langle \\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 \\rangle_1 = +1$，得到 $V_1 = 50.0 + (-10.0)(1) = 40.0$。由于在所有测试用例中 $V_S$ 都不为零，因此可以从相对误差表达式的分子和分母中提取出来并约掉：\n$$ \\varepsilon_{\\max} = \\max_{|\\mathbf{k}|\\in\\mathcal{K}} \\frac{\\left|\\, V_S \\left( G(|\\mathbf{k}|) - P_{2M}(|\\mathbf{k}|) \\right) \\,\\right|}{\\left|\\, V_S G(|\\mathbf{k}|) \\,\\right|} = \\max_{|\\mathbf{k}|\\in\\mathcal{K}} \\frac{\\left|\\, G(|\\mathbf{k}|) - P_{2M}(|\\mathbf{k}|) \\,\\right|}{\\left|\\, G(|\\mathbf{k}|) \\,\\right|} $$\n这个关键的简化表明，相对误差仅取决于非局域性参数 $\\alpha$、展开阶数 $2M$ 和动量格点，而与势强度参数 $C$、$D$以及自旋道 $S$无关。\n\n### 步骤2：核的傅里叶变换\n下一步是确定 $G(|\\mathbf{k}|)$，即归一化高斯函数 $g(|\\mathbf{s}|)$ 的三维傅里叶变换。\n$$ g(|\\mathbf{s}|) = \\frac{\\alpha^3}{\\pi^{3/2}} \\, \\exp\\!\\left(-\\alpha^2 |\\mathbf{s}|^2\\right) $$\n傅里叶变换定义为 $G(\\mathbf{k}) = \\int d^3\\mathbf{s} \\, e^{-i\\mathbf{k}\\cdot\\mathbf{s}} \\, g(\\mathbf{s})$。该积分在笛卡尔坐标系中是可分離的。使用一维高斯函数傅里叶变换的标准结果 $\\int_{-\\infty}^{\\infty} dx \\, e^{-ikx} e^{-ax^2} = \\sqrt{\\pi/a} \\, e^{-k^2/(4a)}$，其中 $a=\\alpha^2$，我们对每个维度可以得到：\n$$ \\int_{-\\infty}^{\\infty} ds_j \\, e^{-ik_j s_j} e^{-\\alpha^2 s_j^2} = \\frac{\\sqrt{\\pi}}{\\alpha} e^{-k_j^2/(4\\alpha^2)} $$\n将三个维度的结果相乘，并包含 $g(|\\mathbf{s}|)$ 的歸一化常数，可得：\n$$ G(\\mathbf{k}) = \\frac{\\alpha^3}{\\pi^{3/2}} \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\right)^3 \\exp\\left(-\\frac{k_x^2+k_y^2+k_z^2}{4\\alpha^2}\\right) = \\exp\\left(-\\frac{|\\mathbf{k}|^2}{4\\alpha^2}\\right) $$\n因此，精确的动量空间函数是 $G(|\\mathbf{k}|) = \\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))$。\n\n### 步骤3：作为泰勒多项式的微分展开\n$2M$ 阶的微分展开对应于 $G(|\\mathbf{k}|)$ 在 $|\\mathbf{k}|=0$ 附近的泰勒多项式，记为 $P_{2M}(|\\mathbf{k}|)$。令 $x = |\\mathbf{k}|^2/(4\\alpha^2)$。那么 $G(|\\mathbf{k}|)$ 变为 $G(x) = e^{-x}$。$e^{-x}$ 在 $x=0$ 附近的泰勒级数是 $\\sum_{n=0}^{\\infty} \\frac{(-x)^n}{n!}$。多项式 $P_{2M}(|\\mathbf{k}|)$ 是通过将此级数在变量 $x$ 的 $M$ 阶处截断得到的，这对应于在 $|\\mathbf{k}|$ 的 $2M$ 阶截断。\n$$ P_{2M}(|\\mathbf{k}|) = \\sum_{n=0}^{M} \\frac{1}{n!} \\left(-\\frac{|\\mathbf{k}|^2}{4\\alpha^2}\\right)^n = \\sum_{n=0}^{M} \\frac{(-1)^n}{n! (4\\alpha^2)^n} |\\mathbf{k}|^{2n} $$\n\n### 步骤4：计算算法\n最大相对误差 $\\varepsilon_{\\max}$ 是通过在离散动量格点 $\\mathcal{K} = \\{ k_i = i \\cdot \\Delta k \\mid i = 0, 1, \\dots, k_{\\max}/\\Delta k \\}$ 的每个点上计算简化的误差表达式的值并找到最大值来得到的。对于每个 $k \\in \\mathcal{K}$：\n1. 如果 $k=0$，相对误差为 $0$，因为 $G(0)=1$ 且 $P_{2M}(0)=1$。\n2. 如果 $k>0$，计算 $G(k) = \\exp(-k^2 / (4\\alpha^2))$。\n3. 计算 $P_{2M}(k) = \\sum_{n=0}^{M} \\frac{(-1)^n}{n!} \\left(\\frac{k^2}{4\\alpha^2}\\right)^n$。\n4. 计算该动量值下的相对误差：$\\varepsilon(k) = |G(k) - P_{2M}(k)| / |G(k)| = |1 - P_{2M}(k)/G(k)|$。\n5. 最终结果 $\\varepsilon_{\\max}$ 是所有计算出的 $\\varepsilon(k)$ 值中的最大值。\n\n对误差函数 $\\varepsilon(k)$ 的分析表明，对于给定的测试用例，它是 $k$ 的单调递增函数。这意味着最大误差将总是出现在 $k=k_{\\max}$处。然而，严格遵守问题陈述要求在整个离散格点 $\\mathcal{K}$ 上进行搜索，实现过程将遵循这一程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import factorial\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results in the required format.\n    \"\"\"\n    # Each test case is a tuple: (alpha, C, D, S, M, k_max, delta_k)\n    test_cases = [\n        # Test 1\n        (1.0, 50.0, -10.0, 0, 0, 1.0, 0.05),\n        # Test 2\n        (1.0, 50.0, -10.0, 0, 1, 1.0, 0.05),\n        # Test 3\n        (1.0, 50.0, -10.0, 0, 2, 1.0, 0.05),\n        # Test 4\n        (0.7, 50.0, -10.0, 1, 0, 2.0, 0.10),\n        # Test 5\n        (0.7, 50.0, -10.0, 1, 1, 2.0, 0.10),\n        # Test 6\n        (0.7, 50.0, -10.0, 1, 2, 2.0, 0.10),\n        # Test 7\n        (0.4, 50.0, -10.0, 1, 2, 2.5, 0.10),\n        # Test 8\n        (2.0, 50.0, -10.0, 0, 0, 2.5, 0.10),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, _, _, _, M, k_max, delta_k = case\n        max_error = calculate_max_error(alpha, M, k_max, delta_k)\n        results.append(max_error)\n\n    # Format the final output as a comma-separated list of strings,\n    # each rounded to six decimal places, enclosed in brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_max_error(alpha, M, k_max, delta_k):\n    \"\"\"\n    Calculates the maximum relative error for a single test case.\n\n    As shown in the solution, the parameters C, D, and S cancel out from the\n    relative error expression and are therefore not needed in this function.\n    \n    Args:\n        alpha (float): The nonlocality scale.\n        M (int): The derivative expansion is truncated at order 2M.\n        k_max (float): The maximum momentum for the grid.\n        delta_k (float): The step size for the momentum grid.\n\n    Returns:\n        float: The maximum relative error over the grid.\n    \"\"\"\n    # The number of points on the grid is k_max/delta_k + 1.\n    # np.linspace is used for robust handling of floating point endpoints.\n    num_points = int(round(k_max / delta_k)) + 1\n    k_grid = np.linspace(0.0, k_max, num_points)\n\n    max_rel_error = 0.0\n\n    for k in k_grid:\n        # At k=0, G(0)=1 and P_{2M}(0)=1, so the error is exactly 0.\n        # This also prevents potential numerical instability if k is very small.\n        if k == 0.0:\n            rel_error = 0.0\n        else:\n            k_sq = k * k\n            four_alpha_sq = 4.0 * alpha * alpha\n\n            # Calculate the exact function G(k) = exp(-k^2 / (4*alpha^2))\n            g_k = np.exp(-k_sq / four_alpha_sq)\n\n            # Calculate the Taylor polynomial approximation P_{2M}(k)\n            # P_{2M}(k) = sum_{n=0 to M} [(-1)^n / n!] * (k^2 / (4*alpha^2))^n\n            p_2m_k = 0.0\n            x = k_sq / four_alpha_sq\n            for n in range(M + 1):\n                p_2m_k += ((-1)**n * x**n) / factorial(n)\n\n            # Calculate the relative error, defined as |A - A'|/|A|, which\n            # simplifies to |G - P|/|G| = |1 - P/G|.\n            rel_error = abs(1.0 - p_2m_k / g_k)\n\n        if rel_error > max_rel_error:\n            max_rel_error = rel_error\n            \n    return max_rel_error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3558782"}, {"introduction": "从薛定谔方程中求解核势需要计算波函数的拉普拉斯算符 $\\nabla^2$。在离散的格子上，这个微分算符必须用有限差分格式来近似。这个练习将指导你比较两种不同的拉普拉斯算符离散格式——标准的7点格式和改进的27点格式——并评估它们在短距离处对提取出的核势造成的影响 [@problem_id:3558798]。", "problem": "设计并实现一个完整的程序，用于量化在格点量子色动力学从强子到原子核 (HAL QCD) 方法中提取局域核势时的离散化效应。使用以下基础：在局域中心势作用下，关于相对坐标波函数的等时双体薛定谔方程，以物理单位表示，并明确包含普朗克常数和光速因子以确保单位一致性。基础方程为\n$$\n-\\frac{\\hbar^2}{2\\mu}\\nabla^2 \\psi(\\mathbf{r}) + V(r)\\,\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r}),\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$，$\\psi(\\mathbf{r})$ 是等时 Nambu–Bethe–Salpeter (NBS) 波函数，$V(r)$ 是待提取的局域势，$\\mu$ 是折合质量，$E$ 是弹性双体态的能量。您将比较在间距为 $a$ 的立方格点上对拉普拉斯算子的两种离散近似：标准的 7 点模板和改进的 27 点各向同性模板。\n\n您的程序必须：\n\n1. 构建一个边长为 $2R_{\\max}$、格点间距为 $a$ (单位为 $\\mathrm{fm}$) 的三维立方格点，该格点以原点为中心，因此格点坐标为 $(x_i,y_j,z_k)$，其中 $x_i,y_j,z_k \\in [-R_{\\max},R_{\\max}]$ 且沿各轴的间距均为 $a$。仅使用那些对于您所实现的模板而言所有必需邻点都存在的点。\n\n2. 定义一个球对称的模拟等时 Nambu–Bethe–Salpeter (NBS) 波函数，该波函数具有平滑的短程行为，\n$$\n\\psi(r) = \\exp\\!\\big(-\\alpha\\, r^2\\big),\n$$\n其中 $\\alpha$ 的单位为 $\\mathrm{fm}^{-2}$。这一选择避免了节点，并确保比值 $\\nabla^2 \\psi(\\mathbf{r})/\\psi(\\mathbf{r})$ 在整个感兴趣的区域内都是良定义的。\n\n3. 使用以下方法在格点位置上离散化拉普拉斯算子 $\\nabla^2 \\psi$：\n   - 三维空间中的 7 点模板：\n     $$\n     \\nabla^2_{7}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(\\psi_{i+1,j,k}+\\psi_{i-1,j,k}+\\psi_{i,j+1,k}+\\psi_{i,j-1,k}+\\psi_{i,j,k+1}+\\psi_{i,j,k-1}-6\\psi_{i,j,k}\\Big).\n     $$\n   - 改进的各向同性 27 点模板（有时被称为布里渊型拉普拉斯算子），它结合了面、棱、角上的邻点，其权重经过选择以最小化旋转各向异性，同时保持二阶一致性：\n     $$\n     \\nabla^2_{27}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(w_0\\,\\psi_{i,j,k} + w_1 \\sum_{\\text{faces}} \\psi + w_2 \\sum_{\\text{edges}} \\psi + w_3 \\sum_{\\text{corners}} \\psi \\Big),\n     $$\n     其中邻点集合为：\n     - 面：偏移量为 $(\\pm1,0,0)$, $(0,\\pm1,0)$, $(0,0,\\pm1)$，共六个，\n     - 棱：偏移量为 $(\\pm1,\\pm1,0)$, $(\\pm1,0,\\pm1)$, $(0,\\pm1,\\pm1)$，共十二个，\n     - 角：偏移量为 $(\\pm1,\\pm1,\\pm1)$，共八个，\n     且权重为\n     $$\n     w_0 = -\\frac{64}{15},\\quad w_1 = \\frac{7}{15},\\quad w_2 = \\frac{1}{10},\\quad w_3 = \\frac{1}{30}.\n     $$\n     该模板经过归一化，使得 $\\nabla^2_{27}$ 能零化常数场，并提供了比标准 7 点模板更好的旋转不变性。\n\n4. 使用上述薛定谔方程作为 HAL QCD 局域势的原理性定义，通过在格点位置上的比值 $\\nabla^2 \\psi(\\mathbf{r})/\\psi(\\mathbf{r})$，计算用每种拉普拉斯模板提取出的局域势 $V_{7}(r)$ 和 $V_{27}(r)$。通过使用 $(\\hbar c)^2$（其中 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$）、折合质量 $\\mu$ (单位 MeV)、能量 $E$ (单位 MeV) 以及长度 (单位 fm) 来确保单位一致性。势必须以 MeV 表示。\n\n5. 通过计算最大绝对差\n$$\n\\Delta V_{\\max} = \\max_{r \\le 0.5\\,\\mathrm{fm}} \\big|V_{27}(r)-V_{7}(r)\\big|\n$$\n来评估在短距离处提取出的势的变化。该计算覆盖所有满足 $r \\le 0.5\\,\\mathrm{fm}$ 且所有必需邻点都存在的格点。报告每个测试用例的 $\\Delta V_{\\max}$ (单位 MeV)。\n\n6. 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如 $[x_1,x_2,x_3]$)，每个 $x_n$ 对应于相应测试用例的 $\\Delta V_{\\max}$ (单位 MeV)。\n\n物理单位：所有距离以 $\\mathrm{fm}$ 表示，能量以 $\\mathrm{MeV}$ 表示，不使用角度。输出值必须是浮点数，单位为 $\\mathrm{MeV}$。\n\n为以下测试套件实现程序，每个元组提供 $(a,\\mu,E,\\alpha,R_{\\max})$，单位为 $(\\mathrm{fm},\\mathrm{MeV},\\mathrm{MeV},\\mathrm{fm}^{-2},\\mathrm{fm})$：\n\n- 测试用例 1：$(0.08, 469.5, 10.0, 2.0, 3.20)$，一个代表了核子折合质量和适中结合能的精细格点。\n- 测试用例 2：$(0.20, 469.5, 10.0, 2.0, 4.00)$，一个用于探测短距离处强离散化效应的粗糙格点。\n- 测试用例 3：$(0.08, 469.5, 10.0, 8.0, 3.20)$，一个急剧变化的波函数，用以放大对模板选择的敏感度。\n- 测试用例 4：$(0.12, 469.5, 0.0, 2.0, 3.60)$，零能量，用以分离出由拉普拉斯算子驱动的对势的贡献。\n\n您的程序应生成单行输出，其中包含这四个测试用例的 $\\Delta V_{\\max}$ 值，形式为方括号括起来的逗号分隔列表，单位为 $\\mathrm{MeV}$。", "solution": "该问题已经过验证，并被认为是合理的。它在科学上基于量子力学和数值分析的原理，问题是适定的，具有唯一且可计算的解，并且其表述是客观的。所有必需的参数和定义均已提供。因此，我们可以着手求解。\n\n中心任务是在 HAL QCD 方法的背景下，量化使用拉普拉斯算子 $\\nabla^2$ 的两种不同数值近似从模拟波函数中提取局域势时产生的差异。离散拉普拉斯算子的选择会引入一种称为离散化误差的系统误差，该误差取决于格点间距 $a$ 和底层波函数的性质。本练习比较了标准的 7 点模板和改进的 27 点模板，以评估在短距离处此误差的大小。\n\n该方法的基础是用于双体系统相对坐标波函数 $\\psi(\\mathbf{r})$ 的不含时薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2\\mu}\\nabla^2 \\psi(\\mathbf{r}) + V(r)\\,\\psi(\\mathbf{r}) = E\\,\\psi(\\mathbf{r})\n$$\n此处，$\\mu$ 是折合质量，$E$ 是系统能量，$V(r)$ 是我们希望确定的局域中心势，其中 $r = \\lVert \\mathbf{r} \\rVert$。在 HAL QCD 方法中，$\\psi(\\mathbf{r})$ 对应于等时 Nambu–Bethe–Salpeter (NBS) 波函数，该波函数通过格点 QCD 模拟计算得出。通过重新整理薛定谔方程，我们可以将势 $V(r)$ 表示为：\n$$\nV(r) = E - \\frac{\\hbar^2}{2\\mu} \\frac{\\nabla^2 \\psi(\\mathbf{r})}{\\psi(\\mathbf{r})}\n$$\n为了使单位明确并为计算做好准备，我们使用以 $\\mathrm{MeV}\\cdot\\mathrm{fm}$ 为单位的 $\\hbar c$ 值。势则由下式给出：\n$$\nV(r) = E + \\frac{(\\hbar c)^2}{2\\mu} \\frac{\\nabla^2 \\psi(\\mathbf{r})}{\\psi(\\mathbf{r})}\n$$\n其中 $E$ 和 $\\mu$ 的单位为 $\\mathrm{MeV}$，长度单位为 $\\mathrm{fm}$。\n\n为此分析，提供了一个模拟 NBS 波函数：\n$$\n\\psi(r) = \\exp(-\\alpha r^2)\n$$\n这种高斯形式是解析可解且行为良好的，缺少会导致比值 $\\nabla^2\\psi/\\psi$ 发散的节点。该函数的解析拉普拉斯算子为 $\\nabla^2\\psi(r) = (4\\alpha^2 r^2 - 6\\alpha) \\exp(-\\alpha r^2)$。因此，与该波函数对应的精确连续谱势为 $V_{\\text{true}}(r) = E + \\frac{(\\hbar c)^2}{2\\mu}(4\\alpha^2 r^2 - 6\\alpha)$，它是 $r^2$ 的一个简单二次函数。\n\n问题的核心在于，在间距为 $a$ 的三维立方格点上，将连续算子 $\\nabla^2$ 替换为离散近似。我们将实现并比较两种这样的近似。\n\n1.  **7 点模板**：这是三维拉普拉斯算子的标准二阶中心差分近似。在索引为 $(i,j,k)$ 的格点位置上，它定义为：\n    $$\n    \\nabla^2_{7}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(\\psi_{i+1,j,k}+\\psi_{i-1,j,k}+\\psi_{i,j+1,k}+\\psi_{i,j-1,k}+\\psi_{i,j,k+1}+\\psi_{i,j,k-1}-6\\psi_{i,j,k}\\Big)\n    $$\n    该模板使用沿笛卡尔坐标轴的最近邻点。\n\n2.  **改进的 27 点模板**：该模板包含了围绕中心点 $(i,j,k)$ 的立方体在面、棱、角上的邻点，以构建具有更好旋转对称性的近似。其定义为：\n    $$\n    \\nabla^2_{27}\\psi(i,j,k) = \\frac{1}{a^2}\\Big(w_0\\,\\psi_{i,j,k} + w_1 \\sum_{\\text{faces}} \\psi + w_2 \\sum_{\\text{edges}} \\psi + w_3 \\sum_{\\text{corners}} \\psi \\Big)\n    $$\n    权重为 $w_0 = -64/15$，$w_1 = 7/15$，$w_2 = 1/10$ 和 $w_3 = 1/30$。求和分别是对 6 个面邻点、12 个棱邻点和 8 个角邻点进行的。选择这些权重是为了抵消模板泰勒展开式中的领头阶旋转各向异性项。\n\n解决每个测试用例的算法流程如下：\n\n-   **步骤 1：格点构建**。定义一个覆盖立方体 $[-R_{\\max}, R_{\\max}]^3$ 的三维格点，其均匀间距为 $a$。这通过创建一维坐标数组并使用 meshgrid 函数生成三维坐标数组 $X, Y, Z$ 来实现。\n\n-   **步骤 2：波函数求值**。在格点上的每个点对模拟波函数 $\\psi(r) = \\exp(-\\alpha r^2)$ 进行求值，其中 $r = \\sqrt{X^2+Y^2+Z^2}$。\n\n-   **步骤 3：拉普拉斯算子计算**。计算离散拉普拉斯算子 $\\nabla^2_{7}\\psi$ 和 $\\nabla^2_{27}\\psi$。此计算仅限于格点的内部点，对于这些点，所有必需的邻点（对于 27 点模板，直至角邻点）都存在于定义的网格内。这可以通过使用 `numpy` 中的数组切片来高效实现。\n\n-   **步骤 4：势的提取**。使用步骤 3 的结果，在每个内部格点上使用公式 $V_i(r) = E + \\frac{(\\hbar c)^2}{2\\mu} (\\nabla^2_i \\psi / \\psi)$ 计算两种版本的势 $V_7(r)$ 和 $V_{27}(r)$。\n\n-   **步骤 5：差异量化**。计算绝对差 $|V_{27}(r) - V_{7}(r)|$。创建一个布尔掩码，以仅选择那些既位于内部计算体积内又满足距离约束 $r \\le 0.5\\,\\mathrm{fm}$ 的点。该测试用例的最终结果 $\\Delta V_{\\max}$ 是在所选点上此差异的最大值。\n\n对所提供的四个测试用例中的每一个重复此过程，并收集所得的 $\\Delta V_{\\max}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Test cases: (a, mu, E, alpha, R_max)\n    # Units: (fm, MeV, MeV, fm^-2, fm)\n    test_cases = [\n        (0.08, 469.5, 10.0, 2.0, 3.20),\n        (0.20, 469.5, 10.0, 2.0, 4.00),\n        (0.08, 469.5, 10.0, 8.0, 3.20),\n        (0.12, 469.5, 0.0, 2.0, 3.60),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_v_max = calculate_delta_v_max(*case)\n        results.append(delta_v_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef calculate_delta_v_max(a: float, mu: float, E: float, alpha: float, R_max: float) -> float:\n    \"\"\"\n    Calculates the maximum absolute difference between potentials extracted\n    using 7-point and 27-point Laplacian stencils.\n\n    Args:\n        a (float): Lattice spacing in fm.\n        mu (float): Reduced mass in MeV.\n        E (float): Energy in MeV.\n        alpha (float): Wavefunction parameter in fm^-2.\n        R_max (float): Half-side length of the cubic lattice in fm.\n\n    Returns:\n        float: The maximum absolute potential difference Delta V_max in MeV.\n    \"\"\"\n    # Physical and conversion constants\n    hbar_c = 197.3269804  # MeV*fm\n    v_factor = hbar_c**2 / (2 * mu)\n    r_cutoff_sq = 0.5**2 # fm^2\n\n    # 1. Construct the lattice\n    # Determine the number of points from the origin to the edge\n    N_half = int(np.round(R_max / a))\n    # Create a 1D coordinate array centered at the origin\n    coords_1d = np.linspace(-N_half * a, N_half * a, 2 * N_half + 1)\n    # Generate 3D coordinate grids\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # 2. Evaluate the mock wavefunction\n    R_sq = X**2 + Y**2 + Z**2\n    psi = np.exp(-alpha * R_sq)\n\n    # 3. Calculate discrete Laplacians on the interior of the grid\n    # The stencils require a 1-point border, so we compute on `psi[1:-1, 1:-1, 1:-1]`.\n    # Slicing the `psi` array allows efficient access to neighbor points.\n    \n    # The core region of psi where the Laplacians will be evaluated\n    interior_psi = psi[1:-1, 1:-1, 1:-1]\n\n    # 7-point stencil calculation\n    # Sum over the 6 face neighbors relative to the interior grid\n    sum_faces = (psi[2:, 1:-1, 1:-1] + psi[:-2, 1:-1, 1:-1] +\n                 psi[1:-1, 2:, 1:-1] + psi[1:-1, :-2, 1:-1] +\n                 psi[1:-1, 1:-1, 2:] + psi[1:-1, 1:-1, :-2])\n    \n    lap_7 = (sum_faces - 6 * interior_psi) / a**2\n\n    # 27-point stencil calculation\n    w0, w1, w2, w3 = -64/15., 7/15., 1/10., 1/30.\n    \n    # Term 0: Central point\n    term0 = w0 * interior_psi\n\n    # Term 1: Face neighbors (same sum as for the 7-point stencil)\n    term1 = w1 * sum_faces\n    \n    # Term 2: Edge neighbors (12 points)\n    sum_edges = (psi[:-2, :-2, 1:-1] + psi[:-2, 2:, 1:-1] +\n                 psi[2:, :-2, 1:-1] + psi[2:, 2:, 1:-1] +\n                 psi[:-2, 1:-1, :-2] + psi[:-2, 1:-1, 2:] +\n                 psi[2:, 1:-1, :-2] + psi[2:, 1:-1, 2:] +\n                 psi[1:-1, :-2, :-2] + psi[1:-1, :-2, 2:] +\n                 psi[1:-1, 2:, :-2] + psi[1:-1, 2:, 2:])\n    term2 = w2 * sum_edges\n    \n    # Term 3: Corner neighbors (8 points)\n    sum_corners = (psi[:-2, :-2, :-2] + psi[:-2, :-2, 2:] +\n                   psi[:-2, 2:, :-2] + psi[:-2, 2:, 2:] +\n                   psi[2:, :-2, :-2] + psi[2:, :-2, 2:] +\n                   psi[2:, 2:, :-2] + psi[2:, 2:, 2:])\n    term3 = w3 * sum_corners\n\n    lap_27 = (term0 + term1 + term2 + term3) / a**2\n    \n    # 4. Compute potentials V7 and V27\n    # The division by `interior_psi` is safe as the Gaussian is never zero.\n    V7 = E + v_factor * (lap_7 / interior_psi)\n    V27 = E + v_factor * (lap_27 / interior_psi)\n\n    # 5. Compute the absolute difference\n    delta_V = np.abs(V27 - V7)\n\n    # 6. Apply mask for r = 0.5 fm and find the maximum difference\n    # We must use the coordinates corresponding to the interior grid\n    interior_R_sq = R_sq[1:-1, 1:-1, 1:-1]\n    mask = interior_R_sq = r_cutoff_sq\n\n    # Ensure there are points within the cutoff radius before taking a max\n    if not np.any(mask):\n        return 0.0\n\n    delta_V_max = np.max(delta_V[mask])\n    \n    return delta_V_max\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3558798"}, {"introduction": "任何格点QCD计算都在有限的格距 $a$ 上进行，为了得到物理结果，必须将计算外推到连续极限 $a \\to 0$。这是一个消除晶格系统误差的关键步骤。在此练习中，你将对来自不同格距的模拟数据进行加权线性回归，以提取连续极限下的核势，并评估拟合的优度，从而掌握处理格点计算中主要系统误差的实用技能 [@problem_id:3558801]。", "problem": "考虑一个固定的重子间距 $r^{\\star}$，在该间距下，一个中心二重子势 $V_{C}(r^{\\star})$ 已从在相同物理体积中、于三个格点间距 $a_{1},a_{2},a_{3}$ 下执行的格点量子色动力学（LQCD, Lattice Quantum Chromodynamics）计算中提取。根据 Symanzik 有效理论，对于一个适当改进的作用量，其领头离散化效应表现为格点间距的偶次幂。因此，在固定的 $r^{\\star}$ 下，很自然地可以用一个与 $a^{2}$ 呈线性关系的拟设来模拟其对格点间距的依赖性：\n$$\nV_{C}(a;r^{\\star}) \\;=\\; V_{0} \\;+\\; c\\,a^{2} \\;+\\; \\varepsilon,\n$$\n其中 $V_{0}$ 是 $a\\to 0$ 时的连续极限值，$c$ 是描述领头离散化赝象的斜率，$\\varepsilon$ 表示统计涨落。假设在格点间距 $a_{i}$ 处的每次测量 $V_{i}$ 都有一个独立的、标准差 $\\sigma_{i}$ 已知的高斯不确定度。在这些假设下，最大似然估计等价于对变量 $x_{i}=a_{i}^{2}$ 进行加权最小二乘线性拟合，权重为 $w_{i}=1/\\sigma_{i}^{2}$。从拟合中提取：\n- 连续极限估计值 $V_{0}$，单位为兆电子伏特 (MeV)，\n- 斜率 $c$，单位为兆电子伏特每平方飞米 (MeV/fm$^{2}$)，\n- 单西格玛不确定度 $\\sigma_{V_{0}}$ 和 $\\sigma_{c}$，\n- 由单位自由度的卡方值 $\\chi^{2}/\\nu$ 量化的拟合优度，其中自由度 $\\nu = N-2$，$N$ 是数据点数，\n- 来自卡方分布的 $p$ 值，\n并且通过声明数据集在且仅在 $p \\geq 0.05$ 时为“一致的”，来评估这三个输入在所选的 $r^{\\star}$ 处是否与假定的 $a^{2}$ 标度行为在统计上一致。\n\n所有输入均使用物理标准单位。格点间距 $a_{i}$ 的单位是飞米 (fm)，势 $V_{i}$ 的单位是兆电子伏特 (MeV)，其单西格玛不确定度 $\\sigma_{i}$ 的单位也是兆电子伏特 (MeV)。您必须：\n- 对 $V_{i}$ 与 $x_{i}=a_{i}^{2}$ 进行加权线性回归，\n- 计算 $V_{0}$、$c$、$\\sigma_{V_{0}}$、$\\sigma_{c}$、$\\chi^{2}/\\nu$ 和 $p$ 值，\n- 根据上述规定确定一致性的布尔值。\n\n测试套件。将您的程序应用于以下四个数据集，每个数据集都处于相同的固定 $r^{\\star}$，但测量质量不同。对于每个数据集，元组分别列出了单位为 fm 的 $(a_{1},a_{2},a_{3})$、单位为 MeV 的 $(V_{1},V_{2},V_{3})$ 和单位为 MeV 的 $(\\sigma_{1},\\sigma_{2},\\sigma_{3})$：\n- 数据集 A（典型的一致情况）：$(a_{1},a_{2},a_{3}) = (0.12, 0.09, 0.06)$, $(V_{1},V_{2},V_{3}) = (-7.10, -8.40, -9.30)$, $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (0.15, 0.15, 0.15)$.\n- 数据集 B（因离群值而不一致）：$(a_{1},a_{2},a_{3}) = (0.12, 0.09, 0.06)$, $(V_{1},V_{2},V_{3}) = (-7.10, -9.10, -9.30)$, $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (0.15, 0.15, 0.15)$.\n- 数据集 C（不确定度大，大致一致）：$(a_{1},a_{2},a_{3}) = (0.12, 0.09, 0.06)$, $(V_{1},V_{2},V_{3}) = (-7.20, -8.30, -9.50)$, $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (1.00, 1.00, 1.00)$.\n- 数据集 D（斜率接近零，精确且一致）：$(a_{1},a_{2},a_{3}) = (0.12, 0.09, 0.06)$, $(V_{1},V_{2},V_{3}) = (-5.02, -4.98, -5.01)$, $(\\sigma_{1},\\sigma_{2},\\sigma_{3}) = (0.05, 0.05, 0.05)$.\n\n输出规范。对于每个数据集，输出一个包含7个条目的列表，顺序完全如下：\n$[V_{0}\\text{ (MeV)},\\,\\sigma_{V_{0}}\\text{ (MeV)},\\,c\\text{ (MeV/fm}^{2}\\text{)},\\,\\sigma_{c}\\text{ (MeV/fm}^{2}\\text{)},\\,\\chi^{2}/\\nu,\\,p\\text{-value},\\,\\text{consistent}]$,\n其中所有浮点数必须四舍五入到三位小数，并且一致性是使用规则 $p \\geq 0.05$ 的布尔值。您的程序应生成单行输出，其中包含四个数据集的结果，形式为由方括号括起来的、包含四个数据集各自列表的逗号分隔列表（例如，$[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$）。所有 $V_{0}$ 和 $\\sigma_{V_{0}}$ 值必须解释为 MeV，所有 $c$ 和 $\\sigma_{c}$ 值必须解释为 MeV/fm$^{2}$，而 $\\chi^{2}/\\nu$ 和 $p$ 值是无量纲的。不要在打印输出中包含任何单位。在适用情况下，所有计算都必须以弧度为单位进行；本任务中不涉及角度。", "solution": "用户提供了一个来自计算核物理领域的问题，该问题要求执行加权线性回归，以从模拟的格点 QCD 数据中提取物理参数。在尝试给出解决方案之前，需要对该问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **模型**：在固定间距 $r^{\\star}$ 下，中心势 $V_C$ 对格点间距的依赖性被建模为与 $a^2$ 呈线性关系：$V_{C}(a;r^{\\star}) = V_{0} + c\\,a^{2} + \\varepsilon$。\n- **变量与参数**：\n    - $V_0$：$a \\to 0$ 时的连续极限势。\n    - $c$：描述领头离散化赝象的斜率。\n    - $a$：格点间距。\n    - $\\varepsilon$：统计涨落，假设为独立高斯分布。\n- **每次测量的数据**：对于每次测量 $i=1, 2, 3$：\n    - 格点间距 $a_i$（单位 fm）。\n    - 测量的势 $V_i$（单位 MeV）。\n    - 势的标准差 $\\sigma_i$（单位 MeV）。\n- **方法**：最大似然估计，等价于对 $V_i$ 与 $x_i = a_i^2$ 进行加权最小二乘线性拟合，权重为 $w_i = 1/\\sigma_i^2$。\n- **待提取的量**：\n    1.  连续极限估计值 $V_{0}$（单位 MeV）。\n    2.  斜率 $c$（单位 MeV/fm$^2$）。\n    3.  单西格玛不确定度 $\\sigma_{V_{0}}$（单位 MeV）。\n    4.  单西格玛不确定度 $\\sigma_{c}$（单位 MeV/fm$^2$）。\n    5.  单位自由度的卡方值 $\\chi^{2}/\\nu$，其中自由度 $\\nu = N-2$ 且数据点数 $N=3$。\n    6.  来自卡方分布的 $p$ 值。\n    7.  对统计一致性的布尔评估：“一致的”当且仅当 $p \\geq 0.05$。\n- **测试数据集**：提供了四个数据集（A、B、C、D），每个数据集都包含 $(a_{1},a_{2},a_{3})$、$(V_{1},V_{2},V_{3})$ 和 $(\\sigma_{1},\\sigma_{2},\\sigma_{3})$ 的元组。\n- **输出格式**：单行输出，包含一个列表的列表，每个子列表对应一个数据集。每个内部列表必须包含7个提取的量，所有浮点数四舍五入到三位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在格点场论的方法论中有充分的依据。使用 Symanzik 有效理论来表征离散化误差、改进作用量的领头 $a^2$ 依赖性，以及通过加权线性拟合进行连续极限外推，都是该领域的标准和基本技术。\n- **适定性**：该问题是适定的。它提供了清晰的数学模型和所有必要的输入数据 ($a_i, V_i, \\sigma_i$)。加权线性回归的过程是一个确定性算法，给定输入即可为拟合参数及其不确定度产生唯一解。数据点数 ($N=3$) 超过了模型参数个数 ($k=2$)，这允许使用 $\\nu = N-2 = 1$ 个自由度进行明确定义的拟合优度检验。\n- **客观性**：问题的陈述语言客观而精确。所有量都有明确定义，一致性的标准 ($p \\ge 0.05$) 也是明确无误的。\n\n该问题没有表现出说明中列出的任何缺陷（例如，科学上不健全、不完整、含糊不清）。所有数据和单位在物理上都是一致的，并且在特定情境下是现实的。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供解决方案。\n\n### 解题推导\n\n任务是为模型 $y(x) = b + mx$ 执行加权线性回归。在此问题的背景下，我们将变量确定如下：\n- 因变量是势，$y_i = V_i$。\n- 自变量是格点间距的平方，$x_i = a_i^2$。\n- 截距是连续极限势，$b = V_0$。\n- 斜率是离散化系数，$m = c$。\n\n因此模型为 $V_i = V_0 + c a_i^2$。鉴于每次测量 $V_i$ 都具有高斯不确定度 $\\sigma_i$，最优参数 $V_0$ 和 $c$ 是通过最小化卡方函数 $\\chi^2$ 来找到的：\n$$\n\\chi^2(V_0, c) = \\sum_{i=1}^{N} \\left( \\frac{V_i - (V_0 + c x_i)}{\\sigma_i} \\right)^2 = \\sum_{i=1}^{N} w_i (V_i - V_0 - c x_i)^2\n$$\n其中 $N=3$ 是数据点的数量，$w_i = 1/\\sigma_i^2$ 是权重。\n\n为了找到最小值，我们将 $\\chi^2$ 对 $V_0$ 和 $c$ 的偏导数设为零：\n$$\n\\frac{\\partial \\chi^2}{\\partial V_0} = -2 \\sum_{i=1}^{N} w_i (V_i - V_0 - c x_i) = 0\n$$\n$$\n\\frac{\\partial \\chi^2}{\\partial c} = -2 \\sum_{i=1}^{N} w_i x_i (V_i - V_0 - c x_i) = 0\n$$\n这导出了一个关于两个未知数 $V_0$ 和 $c$ 的二元线性方程组，称为正规方程组：\n$$\n\\begin{pmatrix}\n\\sum w_i  \\sum w_i x_i \\\\\n\\sum w_i x_i  \\sum w_i x_i^2\n\\end{pmatrix}\n\\begin{pmatrix}\nV_0 \\\\\nc\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sum w_i V_i \\\\\n\\sum w_i x_i V_i\n\\end{pmatrix}\n$$\n为简化起见，我们定义以下加权和：\n- $S_w = \\sum w_i$\n- $S_{wx} = \\sum w_i x_i$\n- $S_{wy} = \\sum w_i V_i$\n- $S_{wxx} = \\sum w_i x_i^2$\n- $S_{wxy} = \\sum w_i x_i V_i$\n\n然后通过对这个 $2 \\times 2$ 矩阵求逆来解此线性系统。该矩阵的行列式为 $\\Delta = S_w S_{wxx} - (S_{wx})^2$。$V_0$ 和 $c$ 的解为：\n$$\nV_0 = \\frac{S_{wxx} S_{wy} - S_{wx} S_{wxy}}{\\Delta}\n$$\n$$\nc = \\frac{S_w S_{wxy} - S_{wx} S_{wy}}{\\Delta}\n$$\n\n拟合参数的不确定度 $\\sigma_{V_0}$ 和 $\\sigma_c$ 是从参数的协方差矩阵导出的。协方差矩阵是 $\\frac{1}{2}\\chi^2$ 的 Hessian 矩阵的逆矩阵，而这个 Hessian 矩阵正是正规方程中的那个 $2 \\times 2$ 矩阵。\n$$\n\\text{Cov}(V_0, c) = \\begin{pmatrix} \\sigma_{V_0}^2  \\text{cov}(V_0, c) \\\\ \\text{cov}(V_0, c)  \\sigma_c^2 \\end{pmatrix} = \\begin{pmatrix} S_w  S_{wx} \\\\ S_{wx}  S_{wxx} \\end{pmatrix}^{-1} = \\frac{1}{\\Delta} \\begin{pmatrix} S_{wxx}  -S_{wx} \\\\ -S_{wx}  S_w \\end{pmatrix}\n$$\n方差是该矩阵的对角元素：\n$$\n\\sigma_{V_0}^2 = \\frac{S_{wxx}}{\\Delta} \\quad \\implies \\quad \\sigma_{V_0} = \\sqrt{\\frac{S_{wxx}}{\\Delta}}\n$$\n$$\n\\sigma_c^2 = \\frac{S_w}{\\Delta} \\quad \\implies \\quad \\sigma_c = \\sqrt{\\frac{S_w}{\\Delta}}\n$$\n\n最后，我们评估拟合优度。$\\chi^2$ 的值是使用最佳拟合参数 $V_0$ 和 $c$ 计算的：\n$$\n\\chi^2_{\\text{fit}} = \\sum_{i=1}^{N} w_i (V_i - (V_0 + c x_i))^2\n$$\n自由度数为 $\\nu = N - k$，其中 $N=3$ 是数据点数，$k=2$ 是拟合参数个数。因此，$\\nu = 3-2=1$。单位自由度的卡方值为 $\\chi^2/\\nu = \\chi^2_{\\text{fit}}/1$。\n\n$p$ 值表示在假设模型正确的情况下，获得大于或等于观测到的 $\\chi^2_{\\text{fit}}$ 值的概率。它是根据具有 $\\nu$ 个自由度的 $\\chi^2$ 分布的生存函数计算的：\n$$\np = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{fit}})\n$$\n较大的 $p$ 值（通常 $p \\ge 0.05$）表明，数据点围绕拟合线的散布情况与其不确定度在统计上是一致的，这意味着模型拟合得很好。该问题将“一致的”情况定义为 $p \\ge 0.05$。\n\n该实现将把这些公式应用于所提供的四个数据集中的每一个。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It processes each dataset, performs a weighted linear regression,\n    and formats the results according to the specification.\n    \"\"\"\n    test_cases = [\n        # Dataset A (typical consistent case)\n        ((0.12, 0.09, 0.06), (-7.10, -8.40, -9.30), (0.15, 0.15, 0.15)),\n        # Dataset B (inconsistent due to an outlier)\n        ((0.12, 0.09, 0.06), (-7.10, -9.10, -9.30), (0.15, 0.15, 0.15)),\n        # Dataset C (large uncertainties, broadly consistent)\n        ((0.12, 0.09, 0.06), (-7.20, -8.30, -9.50), (1.00, 1.00, 1.00)),\n        # Dataset D (near-zero slope, precise and consistent)\n        ((0.12, 0.09, 0.06), (-5.02, -4.98, -5.01), (0.05, 0.05, 0.05)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_dataset(case)\n        all_results.append(result)\n\n    # Format the final output line as a list of lists.\n    # The str() on a list gives the desired '[...]' format.\n    results_as_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef process_dataset(dataset):\n    \"\"\"\n    Performs weighted linear regression for a single dataset.\n\n    Args:\n        dataset (tuple): A tuple containing three tuples/lists for\n                         (a_i, V_i, sigma_i).\n\n    Returns:\n        list: A list of 7 results: [V0, sigma_V0, c, sigma_c, chi2/nu, p_value, consistent].\n              Floats are rounded to three decimal places.\n    \"\"\"\n    a_vals, v_vals, sigma_vals = dataset\n    \n    # Convert inputs to numpy arrays for vectorized calculations\n    a = np.array(a_vals, dtype=np.float64)\n    V = np.array(v_vals, dtype=np.float64)\n    sigma = np.array(sigma_vals, dtype=np.float64)\n\n    # Independent variable x = a^2 and weights w = 1/sigma^2\n    x = a**2\n    w = 1.0 / sigma**2\n    N = len(a)\n\n    # Calculate the weighted sums required for the fit\n    S_w = np.sum(w)\n    S_wx = np.sum(w * x)\n    S_wy = np.sum(w * V)\n    S_wxx = np.sum(w * x**2)\n    S_wxy = np.sum(w * x * V)\n\n    # Calculate the determinant of the design matrix\n    delta = S_w * S_wxx - S_wx**2\n\n    # Calculate the best-fit parameters (V0: intercept, c: slope)\n    V0 = (S_wxx * S_wy - S_wx * S_wxy) / delta\n    c = (S_w * S_wxy - S_wx * S_wy) / delta\n\n    # Calculate the variances and uncertainties of the parameters\n    var_V0 = S_wxx / delta\n    var_c = S_w / delta\n    sigma_V0 = np.sqrt(var_V0)\n    sigma_c = np.sqrt(var_c)\n\n    # Calculate the goodness of fit\n    V_fit = V0 + c * x\n    chi_squared = np.sum(w * (V - V_fit)**2)\n    nu = N - 2  # Degrees of freedom (N=3 data points, 2 parameters)\n    \n    # Handle the case where nu=0, although not expected for N=3\n    if nu > 0:\n        chi_squared_per_dof = chi_squared / nu\n        p_value = chi2.sf(chi_squared, df=nu)\n    else: \n        # This branch is not hit for the given problem (N=3)\n        chi_squared_per_dof = np.inf if chi_squared > 0 else 0.0\n        p_value = 0.0 if chi_squared > 0 else 1.0\n\n\n    # Determine consistency based on the p-value\n    is_consistent = p_value >= 0.05\n\n    # Format the results into a list, rounding floats to 3 decimal places\n    result_list = [\n        round(V0, 3),\n        round(sigma_V0, 3),\n        round(c, 3),\n        round(sigma_c, 3),\n        round(chi_squared_per_dof, 3),\n        round(p_value, 3),\n        is_consistent\n    ]\n    \n    return result_list\n\n# Execute the main function\nsolve()\n```", "id": "3558801"}]}