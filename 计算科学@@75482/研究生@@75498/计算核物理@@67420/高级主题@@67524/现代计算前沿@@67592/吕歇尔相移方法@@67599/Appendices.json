{"hands_on_practices": [{"introduction": "吕舍尔方法将有限体积中离散的能级（可在模拟中获得）与无限体积中的散射相移联系起来。此过程中的第一个关键步骤是将计算出的能量本征值 $E^{\\ast}$ 转换为相应的质心动量 $p^{\\ast}$，因为相移天然是动量的函数。这个基础练习 ([@problem_id:3603739]) 将引导您完成建立这一基本映射的相对论运动学推导。", "problem": "考虑两个静止质量为 $m_1$ 和 $m_2$ 的可分辨无自旋粒子，在一个周期性立方体积中进行弹性散射，这在计算核物理中使用的有限体积谱学中会遇到。设总四动量为 $P^{\\mu}$，并定义洛伦兹不变能量平方 $s \\equiv P^{\\mu}P_{\\mu}$。在质心 (CM) 系中，总能量为 $E^{\\ast}$，因此 $s = E^{\\ast 2}$，且两个粒子的三维动量大小相等、方向相反，其值为 $p^{\\ast}$。单个粒子的在壳质心能量满足 $E_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}$ 和 $E_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}$，且 $E^{\\ast} = E_1^{\\ast} + E_2^{\\ast}$。从四动量守恒、洛伦兹不变性和相对论在壳条件出发，推导出一个仅用 $E^{\\ast}$、$m_1$ 和 $m_2$ 表示的 $p^{\\ast 2}$ 的闭合形式表达式。你可以用 Källén 函数 $\\lambda(x,y,z)$ 来表示最终结果，其定义为 $\\lambda(x,y,z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$。然后，简要解释为什么在吕舍尔方法中，这个从 $E^{\\ast}$ 到 $p^{\\ast}$ 的映射对于将离散的有限体积能量与无限体积的弹性散射相移联系起来至关重要，以及它如何与有限体积量子化条件中使用的无量纲动量变量相衔接。\n\n仅提供 $p^{\\ast 2}$ 的单个闭合形式解析表达式作为最终答案。不需要进行数值计算，也不需要单位。如果提到角度，应以弧度为单位，但最终答案不包含角度。", "solution": "该问题被验证为科学上可靠、提法恰当、客观且完整。它展示了相对论运动学中的一个标准而基本的推导，这是计算核物理中吕舍尔形式体系的一个关键组成部分。所有前提在事实上都是可靠的，并与狭义相对论的原理一致。因此，我们可以着手求解。\n\n该问题要求推导双粒子系统的质心 (CM) 动量平方 $p^{\\ast 2}$ 的表达式，用总质心能量 $E^{\\ast}$ 和粒子静止质量 $m_1$、$m_2$ 来表示。推导从质心系中的能量基本关系开始。总能量 $E^{\\ast}$ 是两个粒子各自在壳能量的总和：\n$$\nE^{\\ast} = E_1^{\\ast} + E_2^{\\ast}\n$$\n其中，单个粒子的能量由相对论的能量-动量关系给出：\n$$\nE_1^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n$$\nE_2^{\\ast} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n将这些代入总能量的表达式中，得到：\n$$\nE^{\\ast} = \\sqrt{m_1^2 + p^{\\ast 2}} + \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n为了求解 $p^{\\ast 2}$，我们必须通过代数操作将其分离出来。首先，我们分离其中一个平方根项：\n$$\nE^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} = \\sqrt{m_2^2 + p^{\\ast 2}}\n$$\n接下来，我们将方程两边平方，以消去右侧的平方根：\n$$\n\\left( E^{\\ast} - \\sqrt{m_1^2 + p^{\\ast 2}} \\right)^2 = \\left( \\sqrt{m_2^2 + p^{\\ast 2}} \\right)^2\n$$\n$$\nE^{\\ast 2} - 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}} + (m_1^2 + p^{\\ast 2}) = m_2^2 + p^{\\ast 2}\n$$\n$p^{\\ast 2}$ 项出现在等式两边，可以消掉。然后我们可以重新整理方程，分离出剩下的平方根项：\n$$\nE^{\\ast 2} + m_1^2 - m_2^2 = 2E^{\\ast}\\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n两边除以 $2E^{\\ast}$ 得到：\n$$\n\\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} = \\sqrt{m_1^2 + p^{\\ast 2}}\n$$\n再次将两边平方以消去最后的平方根：\n$$\n\\left( \\frac{E^{\\ast 2} + m_1^2 - m_2^2}{2E^{\\ast}} \\right)^2 = m_1^2 + p^{\\ast 2}\n$$\n现在我们可以求解 $p^{\\ast 2}$：\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2}{4E^{\\ast 2}} - m_1^2\n$$\n为了简化此表达式并将其与 Källén 函数关联起来，我们将各项通分：\n$$\np^{\\ast 2} = \\frac{(E^{\\ast 2} + m_1^2 - m_2^2)^2 - 4E^{\\ast 2}m_1^2}{4E^{\\ast 2}}\n$$\n让我们展开分子。项 $(E^{\\ast 2} + m_1^2 - m_2^2)^2$ 展开为 $E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2$。将其代入分子中，得到：\n$$\n\\text{Numerator} = (E^{\\ast 4} + m_1^4 + m_2^4 + 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2) - 4E^{\\ast 2}m_1^2\n$$\n$$\n\\text{Numerator} = E^{\\ast 4} + m_1^4 + m_2^4 - 2E^{\\ast 2}m_1^2 - 2E^{\\ast 2}m_2^2 - 2m_1^2m_2^2\n$$\n这个表达式正是 Källén 三角函数 $\\lambda(x, y, z) = x^2 + y^2 + z^2 - 2xy - 2xz - 2yz$ 的定义，其参数为 $x = E^{\\ast 2}$，$y = m_1^2$ 和 $z = m_2^2$。因此，我们可以将分子写成 $\\lambda(E^{\\ast 2}, m_1^2, m_2^2)$。$p^{\\ast 2}$ 的最终表达式是：\n$$\np^{\\ast 2} = \\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}\n$$\n这个推导给出了所需的闭合形式表达式。\n\n下面解释了在吕舍尔方法的背景下，此映射的重要性。\n吕舍尔方法在被限制在有限体积中的双粒子系统的离散能量本征值（在格点QCD等数值模拟中可获取的量）与表征无限体积中粒子相互作用的连续散射相移（所期望的物理可观测量）之间架起了一座桥梁。该方法的核心是一个量子化条件，这是一个关联这两组量的方程。\n\n从质心能量 $E^{\\ast}$ 到质心动量 $p^{\\ast}$ 的映射之所以至关重要，主要有两个原因。首先，在有限体积模拟中直接计算的量是边长为 $L$ 的盒子中相互作用系统的离散能级 $E_n(L)$。这些能级对应于质心系中的总能量 $E^{\\ast}$。然而，渐近散射数据，如相移 $\\delta_l$，天然是散射动量的函数，即 $\\delta_l(p^{\\ast})$。推导出的运动学关系 $p^{\\ast 2} = f(E^{\\ast}, m_1, m_2)$ 提供了从计算出的可观测量（$E^{\\ast}$）到相移所依赖的运动学变量（$p^{\\ast}$）的关键、明确的一一映射。没有这个关系，就不可能确定给定的能级是在哪个动量下探测散射相互作用的。\n\n其次，吕舍尔量子化条件通常使用一个无量纲动量变量来表述，通常记为 $q$，定义为 $q = \\frac{p^{\\ast}L}{2\\pi}$。例如，s波 ($l=0$) 量子化条件通过形式为 $p^{\\ast} \\cot\\delta_0(p^{\\ast}) = \\frac{2}{L\\sqrt{\\pi}} \\mathcal{Z}_{00}(1; q^2)$ 的方程，将相移 $\\delta_0$ 与一个广义 zeta 函数 $\\mathcal{Z}_{00}(1; q^2)$ 联系起来。整个工作流程如下：\n$1$. 数值模拟产生一个离散的能量本征值 $E_n(L)$。这被视为 $E^{\\ast}$。\n$2$. 使用推导出的表达式计算相应的动量平方，$p^{\\ast 2} = \\lambda(E^{\\ast 2}, m_1^2, m_2^2)/(4E^{\\ast 2})$。\n$3$. 使用这个 $p^{\\ast 2}$ 的值来计算无量纲动量平方，$q^2 = (\\frac{L}{2\\pi})^2 p^{\\ast 2}$。\n$4$. 然后将 $q^2$ 的值作为输入代入量子化条件中已知的 zeta 函数，从而可以在该特定动量 $p^{\\ast}$ 下求解未知的相移 $\\cot\\delta_0(p^{\\ast})$。\n因此，$E^{\\ast} \\to p^{\\ast}$ 映射是将模拟的原始输出转换为吕舍尔公式本身所需的正确运动学变量的必不可少的第一步。", "answer": "$$\n\\boxed{\\frac{\\lambda(E^{\\ast 2}, m_1^2, m_2^2)}{4E^{\\ast 2}}}\n$$", "id": "3603739"}, {"introduction": "理解了能量-动量关系之后，我们就可以模拟一个完整的分析流程来提取物理可观测量。这个动手编程练习 ([@problem_id:3603695]) 将引导您完成一个完整的工作流程：生成合成的有限体积能谱，拟合有效力程展开，并利用解析延拓来定位一个虚态极点。这个实践展示了吕舍尔形式体系在实践中如何被用来揭示散射系统的性质。", "problem": "考虑在 $\\hbar = c = 1$ 的单位制下，两个相同的无自旋粒子在边长为 $L$ 的立方周期性盒子内进行 s-波相互作用。在阈值附近，s-波相移 $\\delta_0(k)$ 满足有效力程展开 $k \\cot \\delta_0(k) = -\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$，其中 $a_0$ 是散射长度，$r_0$ 是有效力程。在有限体积中，对于零总动量和立方周期性边界条件，吕舍尔方法通过 $k \\cot \\delta_0(k) = \\dfrac{1}{\\pi L} \\mathcal{S}(q^2)$（其中 $q^2 = \\left(\\dfrac{k L}{2 \\pi}\\right)^2$）将无限体积量 $k \\cot \\delta_0(k)$ 与一个实的、有限体积的几何函数联系起来，其中 $\\mathcal{S}$ 编码了三维周期性，并且与相互作用的细节无关。在无限体积中，s-波散射振幅为 $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - i k}$，$f_0(k)$ 在虚 $k$ 轴上的极点通过解析延拓编码了近阈值态。一个虚态极点对应于分母在负虚轴上的一个零点，即在 $k = - i \\kappa$ 处，其中 $\\kappa > 0$。\n\n你的任务是实现一个测试框架，该框架能生成阈值正上方的合成有限体积谱，使用吕舍尔关系从这些谱中重构 $k \\cot \\delta_0(k)$，拟合有效力程展开系数，然后执行解析延拓以定位负虚轴上的虚态极点。程序必须基于以下基本原理：近阈值的有效力程展开、将 $k \\cot \\delta_0(k)$ 映射到一个由 $1/(\\pi L)$ 缩放的纯几何函数的有限体积关系，以及 s-波散射振幅的解析结构。除了作为测试参数明确提供的数据外，不要使用任何专门的预计算数据；相反，应针对近阈值动量，从有效力程展开本身一致地生成合成谱，以确保正向和反向映射是自洽的。\n\n实现细节和要求：\n- 在无量纲的自然单位制中工作。所有输入和输出都是不带物理单位的纯数。所有角度均以弧度为单位。\n- 对于每个测试用例，你必须：\n  1. 对于每对 $(L_i, k_i)$，通过 $\\mathcal{S}(q_i^2) \\equiv \\pi L_i \\left(-\\dfrac{1}{a_0} + \\dfrac{1}{2} r_0 k_i^2\\right)$（其中 $q_i^2 = \\left(\\dfrac{k_i L_i}{2 \\pi}\\right)^2$）定义一个合成几何函数值 $\\mathcal{S}(q_i^2)$，从而使用给定的参数 $(a_0, r_0)$ 以及提供的盒尺寸列表 $\\{L_i\\}$ 和小的、正的质心动量 $\\{k_i\\}$ 来生成与近阈值有效力程展开一致的合成有限体积数据。这一步模拟了有限体积几何关系的输出，同时保持在有效力程展开有效的近阈值范围内。\n  2. 使用 $k \\cot \\delta_0(k_i) = \\dfrac{1}{\\pi L_i} \\mathcal{S}(q_i^2)$ 从合成有限体积数据中重构“测量”的 $k \\cot \\delta_0(k_i)$。\n  3. 将重构的数据 $\\{(k_i^2, k \\cot \\delta_0(k_i))\\}$ 拟合到线性模型 $y = c_0 + c_1 x$（其中 $y = k \\cot \\delta_0(k)$ 且 $x = k^2$）以提取 $c_0$ 和 $c_1$。从这些值中，通过 $c_0 = -\\dfrac{1}{a_0}$ 和 $c_1 = \\dfrac{1}{2} r_0$ 推断有效力程展开参数 $a_0$ 和 $r_0$。\n  4. 将拟合的 $k \\cot \\delta_0(k)$ 解析延拓到 $k = - i \\kappa$（其中 $\\kappa > 0$），并通过求解 s-波散射振幅分母在负虚轴上为零的条件来确定虚态极点。将得到的 $\\kappa$ 表示为一个正浮点数。\n- 设计你的代码以处理一般情况以及 $r_0$ 在数值精度上有效为零的特殊边界情况。\n\n测试套件：\n提供代码，为以下四个测试用例计算并输出估计的虚态极点位置 $\\kappa$。在每个用例中，精确使用所列出的 $(a_0, r_0)$ 对，以及指定的集合 $\\{L_i\\}$ 和 $\\{k_i\\}$：\n\n- 用例 1（中等负散射长度，中等有效力程）：\n  - $(a_0, r_0) = (-1.5, 1.2)$\n  - $\\{L_i\\} = \\{20, 24, 28, 32\\}$\n  - $\\{k_i\\} = \\{0.06, 0.08, 0.10, 0.12\\}$\n\n- 用例 2（小量级负散射长度，小正有效力程）：\n  - $(a_0, r_0) = (-0.3, 0.5)$\n  - $\\{L_i\\} = \\{18, 20, 22, 24\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.13, 0.17\\}$\n\n- 用例 3（大量级负散射长度，较大有效力程）：\n  - $(a_0, r_0) = (-5.0, 1.8)$\n  - $\\{L_i\\} = \\{22, 26, 30, 34\\}$\n  - $\\{k_i\\} = \\{0.04, 0.07, 0.10, 0.13\\}$\n\n- 用例 4（有效力程为零的边界情况）：\n  - $(a_0, r_0) = (-1.25, 0.0)$\n  - $\\{L_i\\} = \\{16, 20, 24, 28\\}$\n  - $\\{k_i\\} = \\{0.05, 0.09, 0.12, 0.15\\}$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按上述用例顺序列出的四个推断出的 $\\kappa$ 值，每个值四舍五入到六位小数，并作为用方括号括起来的逗号分隔列表（例如，$[0.123456,0.234567,0.345678,0.456789]$）。", "solution": "用户提供了一个计算核物理领域的适定问题。任务是创建一个计算测试框架，以验证一个从模拟的有限体积数据中提取物理参数的程序。该程序涉及吕舍尔方法，此方法将有限体积能谱与无限体积散射相移联系起来。\n\n基于以下评估，该问题是有效的：\n- **科学依据**：该问题建立在量子散射理论的基本且公认的原理之上，包括有效力程展开 (ERE)、s-波散射振幅和吕舍尔形式体系。在此背景下，所有提供的方程都是标准且正确的。虚态作为散射振幅在负虚动量轴上的极点的概念是散射理论的一个标准特征。\n- **适定性**：该问题提供了一套完整的指令、数据和边界条件。它概述了一个清晰的、分步的程序：(1) 从已知模型生成合成数据，(2) 使用拟合程序重构模型参数，以及 (3) 使用拟合模型计算一个导出的物理量（虚态极点位置）。这种“往返”设计确保了存在一个唯一且可验证的解。极点位置的数学推导证实了可以确定一个唯一的、物理上合理的解 $\\kappa > 0$。\n- **客观性**：该问题使用精确、无歧义的科学语言陈述。该任务是计算性的，不含主观因素。\n\n该问题未违反任何无效标准。它在科学上是合理的，可形式化，完整且计算上可行。因此，将提供一个解决方案。\n\n解决方案的步骤如下：\n\n首先，我们为每个步骤建立理论基础。\n1.  **有效力程展开 (ERE)**：对于低能 s-波散射，相移 $\\delta_0(k)$ 通过以下展开式与质心动量 $k$ 相关：\n    $$k \\cot \\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k^2 + \\mathcal{O}(k^4)$$\n    其中 $a_0$ 是散射长度，$r_0$ 是有效力程。在阈值 ($k \\approx 0$) 附近，该关系在 $k^2$ 上近似是线性的。\n\n2.  **合成数据生成**：问题要求生成模拟有限体积计算结果的合成数据点。根据吕舍尔方法，对于给定的盒尺寸 $L$，一个能级对应一个动量 $k$，这些量通过 $k \\cot \\delta_0(k) = \\frac{1}{\\pi L} \\mathcal{S}(q^2)$ 与无限体积相移相关，其中 $q^2 = (\\frac{kL}{2\\pi})^2$ 且 $\\mathcal{S}$ 是一个已知的几何函数。为创建与 ERE 一致的合成数据，我们使用给定的参数 ($a_0$, $r_0$) 以及一组动量 $\\{k_i\\}$ 和盒尺寸 $\\{L_i\\}$ 来为每个数据点定义量 $k_i \\cot \\delta_0(k_i)$：\n    $$y_i = k_i \\cot \\delta_0(k_i) = -\\frac{1}{a_0} + \\frac{1}{2} r_0 k_i^2$$\n    这个过程模拟了在不同动量下对 $k \\cot \\delta_0$ 的完美、无噪声的“测量”。\n\n3.  **参数拟合**：合成数据点的形式为 $(x_i, y_i) = (k_i^2, k_i \\cot \\delta_0(k_i))$。我们将这些点拟合到线性模型 $y = c_0 + c_1 x$。通过将其与 ERE 比较，我们可以确定拟合参数：\n    - 截距 $c_0$ 对应于 $-\\dfrac{1}{a_0}$。\n    - 斜率 $c_1$ 对应于 $\\dfrac{1}{2} r_0$。\n    由于数据是从精确的 ERE 形式生成的，线性最小二乘拟合应能高精度地恢复参数 $c_0$ 和 $c_1$，使得 $c_0 \\approx -1/a_0$ 且 $c_1 \\approx r_0/2$。\n\n4.  **定位虚态极点**：虚态是 s-波散射振幅 $f_0(k) = \\dfrac{1}{k \\cot \\delta_0(k) - ik}$ 在负虚轴上的一个极点。我们在 $k = -i\\kappa$ 处寻找一个极点，其中 $\\kappa$ 是一个实正数。极点条件是分母为零：\n    $$k \\cot \\delta_0(k) - ik = 0$$\n    我们将此方程解析延拓到复平面。使用拟合的 ERE，$k \\cot \\delta_0(k) \\approx c_0 + c_1 k^2$，该条件变为：\n    $$(c_0 + c_1 k^2) - ik = 0$$\n    代入 $k = -i\\kappa$：\n    $$c_0 + c_1 (-i\\kappa)^2 - i(-i\\kappa) = 0$$\n    $$c_0 + c_1(-\\kappa^2) - \\kappa = 0$$\n    $$c_0 - c_1 \\kappa^2 - \\kappa = 0$$\n    重新整理后得到一个关于 $\\kappa$ 的二次方程：\n    $$c_1 \\kappa^2 + \\kappa - c_0 = 0$$\n    解此方程即可求得 $\\kappa$。\n\n5.  **求解 $\\kappa$**：\n    - 如果 $c_1 \\neq 0$（即 $r_0 \\neq 0$），二次公式会产生两个关于 $\\kappa$ 的解：\n      $$\\kappa = \\frac{-1 \\pm \\sqrt{1 - 4(c_1)(-c_0)}}{2c_1} = \\frac{-1 \\pm \\sqrt{1 + 4c_1c_0}}{2c_1}$$\n      对于指定的测试用例，$a_0 < 0$ 且 $r_0 \\ge 0$。这意味着 $c_0 = -1/a_0 > 0$ 且 $c_1 = r_0/2 \\ge 0$。因此判别式 $1+4c_1c_0$ 大于或等于 $1$。物理上有意义的解必须满足 $\\kappa > 0$。分子 $-1 + \\sqrt{1+4c_1c_0}$ 是非负的，且对于 $c_1>0$ 分母是正的，所以我们选择‘+’号。另一个根是负的。\n    - 如果 $c_1 = 0$（即 $r_0 = 0$），方程变为线性的：\n      $$\\kappa - c_0 = 0 \\implies \\kappa = c_0$$\n      这种情况需要单独处理以避免除以零。\n\n该实现将遍历每个测试用例，执行这些步骤，并存储得到的 $\\kappa$ 值。最终输出是这些值的格式化列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the data generation, fitting, and calculation of the\n    virtual-state pole for each scenario.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (-1.5, 1.2),\n            \"L_vals\": [20, 24, 28, 32],\n            \"k_vals\": [0.06, 0.08, 0.10, 0.12]\n        },\n        {\n            \"params\": (-0.3, 0.5),\n            \"L_vals\": [18, 20, 22, 24],\n            \"k_vals\": [0.05, 0.09, 0.13, 0.17]\n        },\n        {\n            \"params\": (-5.0, 1.8),\n            \"L_vals\": [22, 26, 30, 34],\n            \"k_vals\": [0.04, 0.07, 0.10, 0.13]\n        },\n        {\n            \"params\": (-1.25, 0.0),\n            \"L_vals\": [16, 20, 24, 28],\n            \"k_vals\": [0.05, 0.09, 0.12, 0.15]\n        }\n    ]\n\n    def process_case(a0, r0, L_vals, k_vals):\n        \"\"\"\n        Processes a single test case to find the virtual-state pole kappa.\n        \n        Args:\n            a0 (float): The s-wave scattering length.\n            r0 (float): The s-wave effective range.\n            L_vals (list): A list of box side lengths.\n            k_vals (list): A list of corresponding momenta.\n\n        Returns:\n            float: The calculated virtual-state pole location kappa.\n        \"\"\"\n        # Step 1 & 2: Generate synthetic data and reconstruct k*cot(delta0).\n        # The problem requires a round trip: generate synthetic S(q^2)\n        # and then \"reconstruct\" k*cot(delta0). Since this is an exact mapping,\n        # we can directly compute k*cot(delta0) from the true ERE parameters.\n        # x_data will be k^2, and y_data will be k*cot(delta0).\n        \n        k_squared_vals = [k**2 for k in k_vals]\n        k_cot_delta_vals = [-1.0/a0 + 0.5 * r0 * k2 for k2 in k_squared_vals]\n\n        x_data = np.array(k_squared_vals)\n        y_data = np.array(k_cot_delta_vals)\n\n        # Step 3: Fit the reconstructed data to the linear model y = c0 + c1*x.\n        # np.polyfit with deg=1 returns [c1, c0] corresponding to [slope, intercept].\n        coeffs = np.polyfit(x_data, y_data, 1)\n        c1_fit = coeffs[0]  # slope, theoretically equals 0.5 * r0\n        c0_fit = coeffs[1]  # intercept, theoretically equals -1.0 / a0\n\n        # Step 4: Find the virtual-state pole kappa by solving for the pole of\n        # the scattering amplitude using the fitted ERE.\n        # The condition k*cot(delta0) - i*k = 0 becomes the quadratic equation:\n        # c1_fit * kappa^2 + kappa - c0_fit = 0\n        \n        # We must handle the special case where r0 = 0, which implies c1_fit is zero.\n        # A small tolerance is used for floating-point comparison.\n        if abs(c1_fit) < 1e-12:\n            # The equation simplifies to a linear one: kappa - c0_fit = 0\n            kappa = c0_fit\n        else:\n            # Solve the quadratic equation A*x^2 + B*x + C = 0 for kappa,\n            # where A = c1_fit, B = 1, C = -c0_fit.\n            A = c1_fit\n            B = 1.0\n            C = -c0_fit\n            \n            # The discriminant is B^2 - 4AC. We expect it to be non-negative.\n            discriminant = B**2 - 4 * A * C\n            \n            # For a virtual state, kappa must be positive.\n            # The test case parameters ensure c1_fit >= 0 and c0_fit > 0.\n            # The discriminant is >= 1. The physically meaningful solution\n            # requires taking the positive root in the numerator.\n            kappa = (-B + np.sqrt(discriminant)) / (2 * A)\n            \n        return kappa\n\n    results = []\n    for case in test_cases:\n        a0, r0 = case[\"params\"]\n        L_vals = case[\"L_vals\"]\n        k_vals = case[\"k_vals\"]\n        \n        kappa_result = process_case(a0, r0, L_vals, k_vals)\n        results.append(kappa_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of kappa values, each rounded to\n    # six decimal places, enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3603695"}, {"introduction": "在从格点QCD模拟中提取的有限体积能谱中，能量值总是带有统计不确定性。这个高级练习 ([@problem_id:3603770]) 将引导您完成将这些不确定性从能量精确传播到最终物理观测量（散射相移）的过程。您将推导相关的雅可比矩阵，实现不确定性传播，并分析能量接近阈值时误差如何被放大，这是吕舍尔方法实际应用中的一个关键考虑因素。", "problem": "给定一个周期性立方盒子中的有限体积两体系统，以及一组通过拟合得到的关联双粒子能级。在总动量为零的 s-波情况下，量化条件将无限体积相移与一个有限体积运动学函数联系起来。考虑以下用于不确定性传播的框架。\n\n基本定义：\n- 对于两个质量为 $m$ 的相同粒子，质心色散关系为 $E = 2 \\sqrt{m^2 + k^2}$，其中 $E$ 是总能量，$k$ 是相对动量的大小。\n- 对于空间尺度 $L$，无量纲动量为 $q = k L / (2 \\pi)$。\n- 量化条件可以表示为 $F(E) \\equiv \\delta_\\ell(k) + \\phi(q) - n \\pi = 0$，其中 $\\delta_\\ell(k)$ 是角动量为 $\\ell$ 的散射相移，$\\phi(q)$ 是一个已知的有限体积赝相移，$n$ 是标记解分支的整数。在弱相互作用的近阈值基态中，取 $n = 0$，因此有 $\\delta_\\ell(k) = -\\phi(q)$。\n- 对于小扰动，具有协方差矩阵 $\\Sigma_x$ 的向量值函数 $y(x)$ 的线性不确定性传播使用雅可比矩阵 $J = \\partial y / \\partial x$ 来获得 $\\Sigma_y = J \\, \\Sigma_x \\, J^\\top$。\n- 您必须从上述基本定义出发，使用链式法则计算导数，不得假定任何专门的快捷方式。\n\n为了本问题中的数值具体性，使用一个平滑模型来描述有限体积赝相移，该模型能捕捉其在阈值附近的单调行为：\n- 定义 $\\phi(q) = - \\arctan\\!\\big(a_0 \\, q + a_1 \\, q^3\\big)$，其中 $a_0 = 1.0$ 且 $a_1 = 0.1$。\n- 当将不确定性从能量传播到相移时，在 $n=0$ 分支上取相移为 $\\delta_\\ell(k) = -\\phi(q)$，所有角度均以弧度为单位。\n\n您的任务：\n1) 通过链式法则和应用于 $F(E)$ 的隐函数定理，推导在测量能量 $E_i$ 处雅可比矩阵元素 $J_{ij} = \\partial \\delta_i / \\partial E_j$ 的显式表达式。用 $\\partial \\phi/\\partial q$、$\\partial q/\\partial k$ 和 $\\partial k/\\partial E$ 表示 $J_{ij}$。使用上述基本关系证明每一步。您的推导应指出在何处，$\\left|\\partial \\delta_\\ell/\\partial E\\right|$ 的大值（即相移对能量的敏感度）会放大了传播的不确定性。\n2) 实现一个从关联能量拟合结果到相移估计的稳健不确定性传播。给定能量向量 $E$ 及其协方差矩阵 $\\Sigma_E$，计算相移 $\\delta_\\ell(k_i)$ 及其协方差矩阵 $\\Sigma_\\delta = J \\, \\Sigma_E \\, J^\\top$。从 $\\Sigma_\\delta$ 中，提取标准差 $\\sigma_{\\delta_i} = \\sqrt{(\\Sigma_\\delta)_{ii}}$ 和相关系数 $\\rho_{\\delta,ij} = (\\Sigma_\\delta)_{ij} / (\\sigma_{\\delta_i} \\sigma_{\\delta_j})$（对于 $i \\neq j$）。\n3) 识别并报告每个能级 $i$ 处的放大因子 $A_i = \\left|\\partial \\delta_i / \\partial E_i\\right|$ 以及最大值 $A_{\\max} = \\max_i A_i$。解释因子 $A_i$ 如何与相移对相应能量的敏感度相关联，以及在何种物理条件下 $A_i$ 会变大。\n4) 数值实现整个流程，并将其应用于以下测试套件。使用自然单位制，其中 $\\hbar c = 197.3269804 \\, \\mathrm{MeV \\cdot fm}$，将 $L$ 从 $\\mathrm{fm}$ 转换为 $\\mathrm{MeV}^{-1}$。在所有情况下，角度均以弧度处理。按规定格式返回所要求的输出。\n\n测试套件（每个测试用例 $t$ 提供质量 $m$、长度 $L$、能量向量 $E^{(t)}$ 以及完整的协方差矩阵 $\\Sigma_E^{(t)}$；所有能量和质量的单位为 $\\mathrm{MeV}$，长度单位为 $\\mathrm{fm}$）：\n- 案例 1 (正常路径)：$m = 939.0$，$L = 8.0$，\n  $E^{(1)} = [1910.0, 1960.0, 2050.0]$，\n  标准差为 $[\\sigma_{E,1}, \\sigma_{E,2}, \\sigma_{E,3}] = [1.0, 1.5, 2.0]$，且常数成对相关系数为 $r = 0.2$，因此当 $i \\neq j$ 时 $(\\Sigma_E^{(1)})_{ij} = r \\, \\sigma_{E,i} \\sigma_{E,j}$，当 $i=j$ 时 $(\\Sigma_E^{(1)})_{ii} = \\sigma_{E,i}^2$。\n- 案例 2 (近阈值放大)：$m = 939.0$，$L = 8.0$，\n  $E^{(2)} = [1879.0, 1882.0, 1890.0]$，\n  标准差为 $[0.2, 0.3, 0.5]$，且常数成对相关系数为 $r = 0.5$。\n- 案例 3 (较长盒子与弱相关)：$m = 939.0$，$L = 12.0$，\n  $E^{(3)} = [1910.0, 1960.0, 2050.0]$，\n  标准差为 $[0.5, 0.5, 0.5]$，且常数成对相关系数为 $r = 0.1$。\n\n实现细节与要求：\n- 对于每个案例，计算以弧度为单位的相移 $\\delta_\\ell(k_i)$、以弧度为单位的标准差 $\\sigma_{\\delta_i}$、相关系数 $\\rho_{\\delta,12}$、$\\rho_{\\delta,13}$、$\\rho_{\\delta,23}$，以及以 $\\mathrm{MeV}^{-1}$ 为单位的最大放大因子 $A_{\\max}$。\n- 角度单位：弧度。能量单位：$\\mathrm{MeV}$。长度单位：$\\mathrm{fm}$，使用 $\\hbar c = 197.3269804 \\, \\mathrm{MeV \\cdot fm}$ 转换为 $\\mathrm{MeV}^{-1}$。\n- 如果任何输入能量 $E_i$ 低于阈值 $2 m$，则在此模型中相应的动量 $k_i$ 未定义。在给定的测试套件中，所有 $E_i$ 都满足 $E_i > 2 m$；您的程序应通过断言或安全处理非物理输入，在遇到此类条目时返回非数字（not-a-number）。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果。每个测试用例的结果必须是包含七个浮点数的列表，顺序为 $[\\sigma_{\\delta_1}, \\sigma_{\\delta_2}, \\sigma_{\\delta_3}, \\rho_{\\delta,12}, \\rho_{\\delta,13}, \\rho_{\\delta,23}, A_{\\max}]$。完整的输出必须是单行，其中三个列表包含在一个顶级列表中，例如 $[[x_{11},\\dots,x_{17}],[x_{21},\\dots,x_{27}],[x_{31},\\dots,x_{37}]]$。为便于阅读，可以将每个浮点数四舍五入到固定的小数位数；请确保数值与您的推导和给定的模型定义一致。", "solution": "该问题要求在一个有限体积系统的吕舍尔方法框架内，将一组关联的双粒子能级的不确定性传播到相应的 s-波散射相移。这涉及变换的雅可比矩阵的推导、不确定性放大分析以及针对特定测试用例的数值实现。\n\n首先，我们处理雅可比矩阵 $J$ 的解析推导，这对于线性不确定性传播至关重要。可观测量向量，即相移向量 $\\vec{\\delta} = (\\delta_1, \\delta_2, \\dots, \\delta_N)^\\top$，是测量数据向量，即能量向量 $\\vec{E} = (E_1, E_2, \\dots, E_N)^\\top$ 的函数。雅可比矩阵元素定义为 $J_{ij} = \\partial \\delta_i / \\partial E_j$。\n\n问题指明了几个基本关系：\n1.  色散关系：$E = 2\\sqrt{m^2 + k^2}$，它将两个质量为 $m$ 的粒子的总质心能量 $E$ 与相对动量大小 $k$ 联系起来。\n2.  无量纲动量：$q = kL/(2\\pi)$，其中 $L$ 是立方盒子的尺寸。\n3.  s-波（$\\ell=0$）的量化条件为 $\\delta_0(k) + \\phi(q) - n\\pi = 0$。对于指定的近阈值基态（$n=0$）情况，这简化为相移 $\\delta_0$ 和赝相移 $\\phi$ 之间的显式关系：$\\delta_0(k) = -\\phi(q)$。\n\n相移向量 $\\vec{\\delta}$ 是从能量向量 $\\vec{E}$ 逐点计算的。也就是说，每个相移 $\\delta_i$ 仅由相应的能量 $E_i$ 通过关系链 $E_i \\to k_i \\to q_i \\to \\delta_i$ 确定。\n$$\n\\delta_i = \\delta_0(k(E_i)) = -\\phi(q(k(E_i)))\n$$\n这种函数依赖性意味着相移 $\\delta_i$ 仅是 $E_i$ 的函数，而不是 $E_j$（当 $j \\neq i$ 时）的函数。因此，雅可比矩阵 $J$ 是对角矩阵：\n$$\nJ_{ij} = \\frac{\\partial \\delta_i}{\\partial E_j} = \\frac{\\partial}{\\partial E_j} [-\\phi(q(k(E_i)))] = \\delta_{ij} \\frac{d}{dE_i} [-\\phi(q(k(E_i)))]\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。\n\n为了计算对角元素 $J_{ii} = d\\delta_i/dE_i$，我们按照指示应用链式法则：\n$$\nJ_{ii} = \\frac{d \\delta_i}{d E_i} = \\frac{d \\delta_i}{d q_i} \\frac{d q_i}{d k_i} \\frac{d k_i}{d E_i}\n$$\n我们分别推导这个乘积中的每一项。\n\n1.  导数 $\\frac{d k_i}{d E_i}$：我们从色散关系 $E_i = 2\\sqrt{m^2 + k_i^2}$ 开始。为了求导数，我们可以对 $E_i$ 使用隐式微分：\n    $$\n    \\frac{d}{dE_i}(E_i) = \\frac{d}{dE_i}\\left(2\\sqrt{m^2 + k_i^2}\\right) \\implies 1 = 2 \\cdot \\frac{1}{2\\sqrt{m^2 + k_i^2}} \\cdot (2k_i) \\frac{dk_i}{dE_i} = \\frac{2k_i}{E_i/2} \\frac{dk_i}{dE_i} = \\frac{4k_i}{E_i}\\frac{dk_i}{dE_i}\n    $$\n    求解该导数可得：\n    $$\n    \\frac{d k_i}{d E_i} = \\frac{E_i}{4k_i}\n    $$\n    请注意，$k_i = \\sqrt{(E_i/2)^2 - m^2}$，因此对于 $E_i > 2m$，该导数是良定义的。\n\n2.  导数 $\\frac{d q_i}{d k_i}$：根据定义 $q_i = k_i L / (2\\pi)$，对于固定的盒子尺寸 $L$，该导数是一个常数：\n    $$\n    \\frac{d q_i}{d k_i} = \\frac{L}{2\\pi}\n    $$\n\n3.  导数 $\\frac{d \\delta_i}{d q_i}$：问题陈述了 $\\delta_0(k) = -\\phi(q)$。赝相移的模型是 $\\phi(q) = -\\arctan(a_0 q + a_1 q^3)$。因此，$\\delta_0(q) = \\arctan(a_0 q + a_1 q^3)$。令 $u(q_i) = a_0 q_i + a_1 q_i^3$。则 $\\delta_i = \\arctan(u(q_i))$。其导数为：\n    $$\n    \\frac{d \\delta_i}{d q_i} = \\frac{d}{dq_i} (\\arctan(u(q_i))) = \\frac{1}{1 + u(q_i)^2} \\frac{du}{dq_i} = \\frac{a_0 + 3a_1 q_i^2}{1 + (a_0 q_i + a_1 q_i^3)^2}\n    $$\n    或者，使用 $\\delta_0 = -\\phi$，我们可以计算 $\\frac{d\\phi}{dq_i}$ 并取其负值。对于 $\\phi(q) = -\\arctan(u(q))$，有 $\\frac{d\\phi}{dq_i} = -\\frac{a_0+3a_1q_i^2}{1+(a_0q_i+a_1q_i^3)^2}$。这导致 $\\frac{d\\delta_i}{dq_i} = -\\frac{d\\phi}{dq_i}$，从而得到相同的结果。如提示中所建议，对函数 $F(E, \\delta) = \\delta + \\phi(q(k(E))) = 0$ 使用隐函数定理，可得 $\\frac{d\\delta}{dE} = - \\frac{\\partial F/\\partial E}{\\partial F/\\partial\\delta} = -(\\frac{d\\phi}{dE}) / 1 = -\\frac{d\\phi}{dE}$，这与直接对 $\\delta = -\\phi(E)$ 求导是一致的。\n\n将这些部分组合起来，雅可比矩阵的对角元素为：\n$$\nJ_{ii} = \\frac{d \\delta_i}{d E_i} = \\left( \\frac{a_0 + 3a_1 q_i^2}{1 + (a_0 q_i + a_1 q_i^3)^2} \\right) \\left( \\frac{L}{2\\pi} \\right) \\left( \\frac{E_i}{4k_i} \\right)\n$$\n这是非零雅可比元素的显式表达式。\n\n放大因子定义为 $A_i = |\\partial \\delta_i / \\partial E_i| = |J_{ii}|$。鉴于参数 $a_0, a_1$ 为正，且对于物理态，输入 $L, E_i, k_i$ 也为正，因此 $J_{ii}$ 乘积中的所有项均为正。因此，$A_i = J_{ii}$。该因子量化了输出相移对输入能量的敏感度。大的放大因子意味着 $E_i$ 中的小不确定性会映射为 $\\delta_i$ 中的大不确定性。\n放大的主要来源是运动学项 $\\frac{dk_i}{dE_i} = \\frac{E_i}{4k_i}$。当能量 $E_i$ 接近双粒子阈值 $2m$ 时，动量 $k_i = \\sqrt{(E_i/2)^2 - m^2}$ 趋近于零。导数 $dk_i/dE_i$ 的行为类似于 $1/k_i \\propto 1/\\sqrt{E_i-2m}$，在阈值处发散。这是一个众所周知的特性：非常接近阈值能量的态对系统参数的微小变化极其敏感，这使得从中提取散射性质成为一个精细的过程，但如果能量被精确确定，也可能是一个非常精确的过程。\n\n在确定雅可比矩阵 $J$ 后，相移的协方差矩阵 $\\Sigma_\\delta$ 通过线性误差传播计算得出：\n$$\n\\Sigma_\\delta = J \\, \\Sigma_E \\, J^\\top\n$$\n由于 $J$ 是一个对角矩阵，其元素为 $J_{ii}$，因此 $\\Sigma_\\delta$ 的元素由下式给出：\n$$\n(\\Sigma_\\delta)_{ij} = \\sum_{k,l} J_{ik} (\\Sigma_E)_{kl} J_{jl} = J_{ii} (\\Sigma_E)_{ij} J_{jj}\n$$\n从得到的协方差矩阵 $\\Sigma_\\delta$ 中，我们提取标准差和相关系数：\n- 标准差：$\\sigma_{\\delta_i} = \\sqrt{(\\Sigma_\\delta)_{ii}} = \\sqrt{J_{ii}^2 (\\Sigma_E)_{ii}} = |J_{ii}| \\sigma_{E,i} = A_i \\sigma_{E,i}$。\n- 相关系数：$\\rho_{\\delta,ij} = \\frac{(\\Sigma_\\delta)_{ij}}{\\sigma_{\\delta_i} \\sigma_{\\delta_j}} = \\frac{J_{ii} J_{jj} (\\Sigma_E)_{ij}}{|J_{ii}|\\sigma_{E,i} |J_{jj}|\\sigma_{E,j}} = \\frac{J_{ii} J_{jj}}{|J_{ii} J_{jj}|} \\rho_{E,ij}$。\n由于所有 $J_{ii}>0$，这简化为 $\\rho_{\\delta,ij} = \\rho_{E,ij}$，意味着相关性结构在这种单调变换下得以保留。\n\n数值实现将首先设置测试用例数据，然后对每个能级计算 $k_i$、$q_i$，最后计算相应的雅可比元素 $J_{ii}$。构建完整的雅可比矩阵 $J$，并通过矩阵乘法计算协方差矩阵 $\\Sigma_\\delta$。然后从 $\\Sigma_\\delta$ 中提取所需的统计量。最大放大因子 $A_{\\max}$ 是计算出的对角元素 $|J_{ii}|$ 的最大值。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty propagation problem for the given test cases.\n    \"\"\"\n    \n    # Fundamental constants and model parameters\n    HBARC_MEV_FM = 197.3269804  # MeV fm\n    A0 = 1.0  # dimensionless\n    A1 = 0.1  # dimensionless\n    \n    # Test cases as provided in the problem description\n    test_cases = [\n        {\n            \"m\": 939.0, \"L_fm\": 8.0,\n            \"E\": np.array([1910.0, 1960.0, 2050.0]),\n            \"sigma_E\": np.array([1.0, 1.5, 2.0]),\n            \"corr_r\": 0.2\n        },\n        {\n            \"m\": 939.0, \"L_fm\": 8.0,\n            \"E\": np.array([1879.0, 1882.0, 1890.0]),\n            \"sigma_E\": np.array([0.2, 0.3, 0.5]),\n            \"corr_r\": 0.5\n        },\n        {\n            \"m\": 939.0, \"L_fm\": 12.0,\n            \"E\": np.array([1910.0, 1960.0, 2050.0]),\n            \"sigma_E\": np.array([0.5, 0.5, 0.5]),\n            \"corr_r\": 0.1\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m = case[\"m\"]\n        L_fm = case[\"L_fm\"]\n        E_vec = case[\"E\"]\n        sigma_E_vec = case[\"sigma_E\"]\n        r = case[\"corr_r\"]\n        \n        # Convert L from fm to MeV^-1\n        L_mev_inv = L_fm / HBARC_MEV_FM\n        \n        num_levels = len(E_vec)\n        J_diag = np.zeros(num_levels)\n        delta_vec = np.zeros(num_levels)\n        \n        for i in range(num_levels):\n            E = E_vec[i]\n            \n            # Check for non-physical energy input\n            threshold = 2.0 * m\n            if E <= threshold:\n                J_diag[i] = np.nan\n                delta_vec[i] = np.nan\n                continue\n            \n            # Calculate k from E: E = 2*sqrt(m^2 + k^2) -> k = sqrt((E/2)^2 - m^2)\n            k = math.sqrt((E / 2.0)**2 - m**2)\n            \n            # Calculate dimensionless momentum q\n            q = k * L_mev_inv / (2.0 * math.pi)\n            \n            # Calculate phase shift delta_i = arctan(a0*q + a1*q^3)\n            u = A0 * q + A1 * q**3\n            delta_vec[i] = math.atan(u)\n            \n            # Calculate the diagonal Jacobian element J_ii = d(delta_i)/d(E_i)\n            # J_ii = (d(delta)/dq) * (dq/dk) * (dk/dE)\n            \n            # 1. d(delta)/dq = (a0 + 3*a1*q^2) / (1 + (a0*q + a1*q^3)^2)\n            d_delta_dq = (A0 + 3.0 * A1 * q**2) / (1.0 + u**2)\n            \n            # 2. dq/dk = L / (2*pi)\n            dq_dk = L_mev_inv / (2.0 * math.pi)\n            \n            # 3. dk/dE = E / (4*k)\n            dk_dE = E / (4.0 * k)\n            \n            J_diag[i] = d_delta_dq * dq_dk * dk_dE\n\n        # Construct the diagonal Jacobian matrix\n        J = np.diag(J_diag)\n        \n        # Construct the energy covariance matrix Sigma_E\n        Sigma_E = np.zeros((num_levels, num_levels))\n        for i in range(num_levels):\n            for j in range(num_levels):\n                if i == j:\n                    Sigma_E[i, j] = sigma_E_vec[i]**2\n                else:\n                    Sigma_E[i, j] = r * sigma_E_vec[i] * sigma_E_vec[j]\n        \n        # Propagate uncertainty: Sigma_delta = J * Sigma_E * J^T\n        Sigma_delta = J @ Sigma_E @ J.T\n        \n        # Extract standard deviations for delta\n        sigma_delta_vec = np.sqrt(np.diag(Sigma_delta))\n        \n        # Extract correlation coefficients for delta\n        rho_delta = np.zeros((num_levels, num_levels))\n        for i in range(num_levels):\n            for j in range(num_levels):\n                if i == j:\n                    rho_delta[i,j] = 1.0\n                else:\n                    rho_delta[i,j] = Sigma_delta[i,j] / (sigma_delta_vec[i] * sigma_delta_vec[j])\n\n        # Requested correlation coefficients\n        rho_12 = rho_delta[0, 1]\n        rho_13 = rho_delta[0, 2]\n        rho_23 = rho_delta[1, 2]\n        \n        # Amplification factors A_i = |J_ii| (since J_ii > 0)\n        A_vec = np.abs(J_diag)\n        A_max = np.max(A_vec)\n        \n        # Store results for this case in the required order\n        case_results = [\n            sigma_delta_vec[0], sigma_delta_vec[1], sigma_delta_vec[2],\n            rho_12, rho_13, rho_23,\n            A_max\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    # Using a fixed precision for clean output.\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        res_str = f\"[{','.join([f'{x:.6f}' for x in res])}]\"\n        output_str += res_str\n        if i < len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3603770"}]}