{"hands_on_practices": [{"introduction": "一个稳健的核反应网络求解器是模拟恒星燃烧的基石。第一个实践将聚焦于实现单个隐式时间步这一基本任务，这对于处理反应动力学的刚性至关重要。通过验证重子数和电荷守恒——该系统的两个线性不变量——你将在最基础的层面上确认求解器的物理保真度，并理解数值方法如何在机器精度内保持解析性质。[@problem_id:3590327]", "problem": "您需要为一个简化的流体静力学碳燃烧网络实现一个单隐式步，然后量化该步在多大程度上保持了重子数和电荷的线性守恒约束。使用数丰度形式，其中核素 $i$ 的丰度为 $Y_i \\equiv n_i/(\\rho N_A)$，其中 $n_i$ 是数密度，$\\rho$ 是质量密度，$N_A$ 是阿伏伽德罗常数。在此形式下，重子数守恒要求 $\\sum_i A_i Y_i = 1$，而在没有弱相互作用的情况下，电荷守恒要求 $\\sum_i Z_i Y_i = Y_e$，其中 $A_i$ 和 $Z_i$ 分别是质量数和质子数，$Y_e$ 是电子分数。\n\n考虑单一入射道 $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$，它有三个出射分支：\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{20}\\mathrm{Ne}+\\alpha$，分支比为 $b_\\alpha$，\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{23}\\mathrm{Na}+\\mathrm{p}$，分支比为 $b_p$，\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{24}\\mathrm{Mg}+\\gamma$，分支比为 $b_\\gamma$，\n且 $b_\\alpha+b_p+b_\\gamma=1$。设物种集合为 $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$，其对应的 $(A,Z)$ 值分别为 $(12,6)$、$(20,10)$、$(23,11)$、$(24,12)$、$(4,2)$ 和 $(1,1)$。\n\n假设在流体静力学条件下，密度 $\\rho$ 和温度 $T$ 恒定。在 $Y$ 形式下，相同反应物的速率定律给出了以下常微分方程组 (ODE)：\n- $\\dfrac{dY_{^{12}\\mathrm{C}}}{dt} = - k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{20}\\mathrm{Ne}}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\alpha}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{23}\\mathrm{Na}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\mathrm{p}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{24}\\mathrm{Mg}}}{dt} = \\dfrac{1}{2} b_\\gamma\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n其中，特定速率 $k(T,\\rho)$ 是 $k(T,\\rho)=\\rho\\, \\mathcal{R}(T_9)$ 的组合，其中 $T_9 \\equiv T/(10^9\\,\\mathrm{K})$，而 $\\mathcal{R}(T_9)$ 是通常列表记录的摩尔速率系数 $N_A\\langle \\sigma v \\rangle$，单位为 $\\mathrm{cm^3\\,mol^{-1}\\,s^{-1}}$。对于此问题，采用经过充分检验的 Caughlan and Fowler 1988 (CF88) 风格的拟合：\n$$\n\\mathcal{R}(T_9)= 4.27\\times 10^{26}\\, T_9^{-2/3}\\, \\exp\\!\\left(-\\dfrac{84.165}{T_9^{1/3}} - 2.12\\times 10^{-3}\\, T_9^2\\right)\\,\n\\left[1 + 0.0489\\,T_9^{1/3} + 0.265\\,T_9^{2/3} + 0.270\\,T_9 + 0.017\\,T_9^{4/3} + 0.330\\,T_9^{5/3}\\right].\n$$\n\n使用大小为 $\\Delta t$ 的单个后向欧拉步来推进该系统：\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}},\n$$\n从质量分数 $X_{^{12}\\mathrm{C}}^0=1$ 且所有其他物种为零的初始状态开始。回顾关系式 $X_i = A_i Y_i$，因此 $Y_{^{12}\\mathrm{C}}^0=1/12$ 且 $Y_e^0=\\sum_i Z_i Y_i^0 = 1/2$。您可以使用任何正确的方法求解关于 $Y_{^{12}\\mathrm{C}}^{n+1}$ 的标量隐式方程；使用在 $Y_{^{12}\\mathrm{C}}^{n+1}$ 处求值的后向欧拉法右侧来计算产物。\n\n在隐式步之后，计算绝对守恒残差\n$$\nr_A = \\left|\\sum_i A_i Y_i^{n+1} - 1\\right|,\\qquad\nr_Z = \\left|\\sum_i Z_i Y_i^{n+1} - Y_e^0\\right|.\n$$\n基于浮点舍入分析和尺度考量，提出绝对容差 $\\tau_A$ 和 $\\tau_Z$，这些容差应足以确保此步骤中守恒的物理保真度。您的提议应结合机器精度的倍数和一个最小工程下限以容纳求和误差，并且可以是贯穿整个测试套件的固定值。\n\n实现一个程序，对于下方的每个测试用例，执行一个后向欧拉步，并按顺序输出四元组 $(r_A,r_Z,\\tau_A,\\tau_Z)$ 作为浮点数。将所有案例的结果聚合到所需输出格式的单个扁平列表中。\n\n单位和常数：\n- 使用 $\\rho$ 的单位为 $\\mathrm{g\\,cm^{-3}}$，$T_9$ 无量纲，$\\Delta t$ 的单位为 $\\mathrm{s}$。\n- 丰度 $Y_i$、电子分数 $Y_e$ 以及残差 $r_A$、$r_Z$ 均为无量纲。\n\n测试套件（每个案例指定 $(T_9,\\rho,\\Delta t)$ 和一个共同的分支比 $(b_\\alpha,b_p,b_\\gamma)$）：\n- 案例 1: $(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^{-4}\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 案例 2: $(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;0\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 案例 3: $(T_9=\\;1.0,\\;\\rho=\\;2\\times 10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;1\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 案例 4: $(T_9=\\;0.5,\\;\\rho=\\;10^8\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^3\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$[r_A^{(1)},r_Z^{(1)},\\tau_A^{(1)},\\tau_Z^{(1)},r_A^{(2)},r_Z^{(2)},\\tau_A^{(2)},r_Z^{(2)},r_A^{(3)},r_Z^{(3)},\\tau_A^{(3)},r_Z^{(3)},r_A^{(4)},r_Z^{(4)},\\tau_A^{(4)},r_Z^{(4)}]$。\n所有数字都应以普通浮点数（十进制或科学记数法）打印。残差 $r_A$ 和 $r_Z$ 是无量纲的，容差 $\\tau_A$ 和 $\\tau_Z$ 是无量纲的绝对容差。", "solution": "问题陈述被评估为 **有效**。它以核天体物理学和反应网络理论的既定原理为科学基础。该问题是适定的，提供了一套完整且自洽的定义、物理常数、初始条件和控制方程，足以确定唯一解。流体静力学条件下的碳燃烧情景是计算天体物理学中一个标准且物理上真实的问题。这个数值任务涉及对一个刚性系统进行后向欧拉积分步，并随后验证守恒定律，是科学计算中一个相关且重要的练习。\n\n这个问题的核心是为流体静力学碳燃烧建立一个简化的反应网络模型。所涉及的物种为 $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$。该过程由 $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$ 聚变反应引发，该反应分叉为三个不同的通道。物种丰度 $Y_i$ 的演化由一个耦合常微分方程组 (ODE) 描述。对于一个通用物种 $j$，其变化率由下式给出：\n$$\n\\frac{dY_j}{dt} = f_j(Y_{^{12}\\mathrm{C}}) = c_j \\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2\n$$\n其中 $k(T,\\rho)$ 是反应速率系数，$c_j$ 是化学计量系数。具体来说，$c_{^{12}\\mathrm{C}} = -1$，$c_{^{20}\\mathrm{Ne}} = c_{\\alpha} = \\frac{1}{2}b_\\alpha$，$c_{^{23}\\mathrm{Na}} = c_{\\mathrm{p}} = \\frac{1}{2}b_p$，以及 $c_{^{24}\\mathrm{Mg}} = \\frac{1}{2}b_\\gamma$。产物形成中的因子 $\\frac{1}{2}$ 源于相同反应物的反应速率定义。\n\n两个基本物理定律必须守恒：重子数和电荷。在数丰度形式中，它们表示为对丰度的线性约束：\n$$\n\\sum_i A_i Y_i = 1 \\quad (\\text{重子数守恒})\n$$\n$$\n\\sum_i Z_i Y_i = Y_e \\quad (\\text{电荷守恒})\n$$\n其中 $A_i$ 和 $Z_i$ 分别是核素 $i$ 的质量数和质子数，$Y_e$ 是电子分数。给定核反应的化学计量相对于 $A_i$ 和 $Z_i$ 都是平衡的。例如，对于 $\\alpha$ 通道，$2 A_{^{12}\\mathrm{C}} = A_{^{20}\\mathrm{Ne}} + A_{\\alpha}$ 且 $2 Z_{^{12}\\mathrm{C}} = Z_{^{20}\\mathrm{Ne}} + Z_{\\alpha}$。一个关键推论是该 ODE 系统拥有线性不变量。对守恒和进行时间微分，可得：\n$$\n\\frac{d}{dt} \\sum_i A_i Y_i = \\sum_i A_i \\frac{dY_i}{dt} = k Y_{^{12}\\mathrm{C}}^2 \\sum_i A_i c_i = k Y_{^{12}\\mathrm{C}}^2 \\left( -A_{^{12}\\mathrm{C}} + \\sum_{\\text{products } j} A_j c_j \\right)\n$$\n使用化学计量关系以及 $b_\\alpha+b_p+b_\\gamma=1$ 这一事实，括号中的项计算结果为零。因此，$\\frac{d}{dt}\\sum_i A_i Y_i = 0$。一个相同的论证表明 $\\frac{d}{dt}\\sum_i Z_i Y_i = 0$。因此，ODE 系统的精确解完美地守恒重子数和电荷。\n\n该问题要求使用隐式后向欧拉法，在一个时间步长 $\\Delta t$ 内将系统从初始状态 $Y^n$ 推进到新状态 $Y^{n+1}$：\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}} = Y_i^{n} + \\Delta t\\, c_i\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\n对于 $^{12}\\mathrm{C}$ ($c_{^{12}\\mathrm{C}}=-1$)，这变成了一个关于 $Y_{^{12}\\mathrm{C}}^{n+1}$ 的非线性代数方程：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\Delta t\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\n重新整理得到一个关于 $y \\equiv Y_{^{12}\\mathrm{C}}^{n+1}$ 的标准二次方程：\n$$\n(\\Delta t\\,k) y^2 + y - Y_{^{12}\\mathrm{C}}^{n} = 0\n$$\n物理上有意义的解必须是正数，这对应于以下根：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{-1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}{2\\,\\Delta t\\,k}\n$$\n对于无量纲参数 $\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}$ 的小值，此公式容易发生灾难性抵消。一个通过分子有理化推导出的数值上更稳定的替代形式被用于实现：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{2\\,Y_{^{12}\\mathrm{C}}^{n}}{1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}\n$$\n一旦找到 $Y_{^{12}\\mathrm{C}}^{n+1}$，所有产物物种的丰度都可以显式计算出来。\n\n后向欧拉法的一个关键特性是它能精确地保持 ODE 系统的线性不变量。为了证明这一点，设 $\\delta_Y \\equiv \\Delta t\\,k\\,(Y_{^{12}\\mathrm{C}}^{n+1})^2$。更新方程为 $Y_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y$ 以及对于产物 $j$，$Y_{j}^{n+1} = Y_{j}^{n} + c_j \\delta_Y$。对步骤 $n+1$ 的所有物种求和重子数守恒定律：\n$$\n\\sum_i A_i Y_i^{n+1} = A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n+1} + \\sum_{\\text{products } j} A_j Y_j^{n+1}\n= A_{^{12}\\mathrm{C}}(Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y) + \\sum_{j} A_j(Y_j^n + c_j \\delta_Y)\n$$\n$$\n= \\left(A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n} + \\sum_{j} A_j Y_j^n\\right) - \\delta_Y \\left( A_{^{12}\\mathrm{C}} - \\sum_{j} A_j c_j \\right) = \\sum_i A_i Y_i^n\n$$\n乘以 $\\delta_Y$ 的项由于与连续情况下证明的相同的化学计量平衡而为零。因此，$\\sum_i A_i Y_i^{n+1} = \\sum_i A_i Y_i^n$。在开始时，$\\sum_i A_i Y_i^0 = A_{^{12}\\mathrm{C}} Y_{^{12}\\mathrm{C}}^0 = 12 \\times (1/12) = 1$。因此，该方法将此和精确地保持为 $1$。电荷守恒同样成立，其中 $\\sum_i Z_i Y_i^0 = Z_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^0 = 6 \\times (1/12) = 0.5$。\n\n守恒残差定义为 $r_A = |\\sum_i A_i Y_i^{n+1} - 1|$ 和 $r_Z = |\\sum_i Z_i Y_i^{n+1} - Y_e^0|$。基于上述分析，$r_A$ 和 $r_Z$ 的解析值完全为零。在数值实现中获得的任何非零值都仅源于计算丰度及其加权和期间的浮点舍入误差。\n\n绝对容差 $\\tau_A$ 和 $\\tau_Z$ 反映了最大可接受的数值误差。鉴于守恒量 $\\sum A_i Y_i$ 和 $\\sum Z_i Y_i$ 的数量级分别为 $1$ 和 $0.5$，舍入误差预计会与机器精度（对于 IEEE 754 双精度，$\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$）成比例。$N$ 个数量级为 $\\mathcal{O}(1)$ 的浮点数求和可以累积 $\\mathcal{O}(N \\times \\epsilon_{\\text{mach}})$ 的误差。对于我们有 $6$ 个物种的系统，一个保守但严格的容差是合适的。我们建议一个固定的绝对容差 $\\tau_A = \\tau_Z = 10^{-14}$。该值比机器精度大几个数量级，为考虑多个浮点运算中的误差累积提供了一个稳健的下限，同时它也足够小，可以确认守恒被高精度地保持。\n\n每个测试用例的算法流程如下：\n1.  使用提供的 $\\mathcal{R}(T_9)$ 公式计算速率系数 $k(T,\\rho)$。\n2.  设置初始丰度：$Y_{^{12}\\mathrm{C}}^0 = 1/12$ 且所有其他 $Y_i^0 = 0$。\n3.  如果 $\\Delta t = 0$，丰度不变，残差精确为 $0$。\n4.  如果 $\\Delta t > 0$，通过使用数值稳定形式求解二次方程来计算 $Y_{^{12}\\mathrm{C}}^{n+1}$。\n5.  使用以后向欧拉公式在 $Y_{^{12}\\mathrm{C}}^{n+1}$ 处的值计算新的产物丰度 $Y_{j}^{n+1}$。\n6.  计算和 $\\sum_i A_i Y_i^{n+1}$ 与 $\\sum_i Z_i Y_i^{n+1}$。\n7.  计算绝对残差 $r_A$ 和 $r_Z$ 并将其与建议的容差 $\\tau_A$ 和 $\\tau_Z$ 配对。", "answer": "```python\nimport numpy as np\n\ndef calculate_R(T9):\n    \"\"\"\n    Calculates the molar rate coefficient R(T9) using the CF88-style fit.\n    T9 is temperature in 10^9 K.\n    \"\"\"\n    if T9 == 0:\n        return 0.0\n\n    T9_1_3 = T9**(1.0/3.0)\n    T9_2_3 = T9_1_3**2\n    T9_4_3 = T9_1_3**4\n    T9_5_3 = T9_1_3**5\n\n    poly_term = (1.0 + 0.0489 * T9_1_3 + 0.265 * T9_2_3 + 0.270 * T9 +\n                 0.017 * T9_4_3 + 0.330 * T9_5_3)\n\n    exp_term_val = -84.165 / T9_1_3 - 2.12e-3 * T9**2\n    \n    # Handle potential underflow in exp\n    if exp_term_val  -700: # np.exp(-709) is ~1e-308, below that is 0\n        exp_term = 0.0\n    else:\n        exp_term = np.exp(exp_term_val)\n\n    R = (4.27e26 * T9**(-2.0/3.0) * exp_term * poly_term)\n    return R\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    \n    # Species in the network: C-12, Ne-20, Na-23, Mg-24, alpha, proton\n    A_vals = np.array([12, 20, 23, 24, 4, 1], dtype=np.float64)\n    Z_vals = np.array([6, 10, 11, 12, 2, 1], dtype=np.float64)\n\n    # Test cases: (T9, rho, dt, (b_alpha, b_p, b_gamma))\n    test_cases = [\n        (0.8, 1e9, 1e-4, (0.60, 0.39, 0.01)),\n        (0.8, 1e9, 0.0, (0.60, 0.39, 0.01)),\n        (1.0, 2e9, 1.0, (0.60, 0.39, 0.01)),\n        (0.5, 1e8, 1e3, (0.60, 0.39, 0.01)),\n    ]\n\n    results = []\n    \n    # Initial conditions from X_C12 = 1\n    Y0_C12 = 1.0 / A_vals[0]\n    Y0 = np.zeros(len(A_vals), dtype=np.float64)\n    Y0[0] = Y0_C12\n    Ye0 = np.sum(Z_vals * Y0) # = 0.5\n\n    # Proposed absolute tolerances for conservation checks\n    tau_A = 1.0e-14\n    tau_Z = 1.0e-14\n\n    for case in test_cases:\n        T9, rho, dt, (b_alpha, b_p, b_gamma) = case\n        \n        # If timestep is zero, no change occurs.\n        if dt == 0.0:\n            Y1 = Y0.copy()\n        else:\n            # Calculate the rate coefficient k = rho * R(T9)\n            R = calculate_R(T9)\n            k = rho * R\n            # The rate k has units of cm^3 / (g * s)\n\n            # Solve for Y_C12 at step n+1 using the backward Euler method.\n            # This yields a quadratic equation for Y1_C12. We use the\n            # numerically stable solution.\n            arg_sqrt = 1.0 + 4.0 * dt * k * Y0_C12\n            Y1_C12 = (2.0 * Y0_C12) / (1.0 + np.sqrt(arg_sqrt))\n\n            # Calculate the abundances of the products at step n+1\n            dt_k_Y1_C12_sq = dt * k * Y1_C12**2\n            \n            Y1_Ne20 = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_alpha = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_Na23 = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_p = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_Mg24 = 0.0 + 0.5 * b_gamma * dt_k_Y1_C12_sq\n\n            Y1 = np.array([Y1_C12, Y1_Ne20, Y1_Na23, Y1_Mg24, Y1_alpha, Y1_p], dtype=np.float64)\n\n        # Compute conservation sums at step n+1\n        sum_AY1 = np.sum(A_vals * Y1)\n        sum_ZY1 = np.sum(Z_vals * Y1)\n\n        # Compute absolute residuals\n        # Initial baryon number sum is 1.0\n        r_A = np.abs(sum_AY1 - 1.0)\n        # Initial electron fraction is Ye0\n        r_Z = np.abs(sum_ZY1 - Ye0)\n\n        results.extend([r_A, r_Z, tau_A, tau_Z])\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3590327"}, {"introduction": "在孤立的反应网络之外，本实践将核燃烧与恒星热力学相结合，以验证物理学的一个基石：热力学第一定律。你将模拟一个恒定压力下的氖燃烧区（这是恒星演化代码中的常见情景），并确认该区域内能的变化与核反应产生的净能量减去中微子损失完全匹配。此练习对于建立对完整恒星模拟中能量平衡组件的信心至关重要。[@problem_id:3590315]", "problem": "给定一个简化的、但在科学上一致的大质量恒星中单个拉格朗日质量区经历氖燃烧的静力学轨迹模型。目标是通过比较时间积分的比核加热减去中微子冷却与沿恒定压强路径的比内能变化，来验证等压燃烧算子下的全局能量守恒。此验证在静力学燃烧阶段的计算核物理背景下进行。\n\n基本基础包括以下几个支柱：\n- 拉格朗日流体元的热力学第一定律：$d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt - P\\,d(1/\\rho)$，其中 $u$ 是比内能，$\\dot{\\epsilon}_{\\mathrm{nuc}}$ 是单位质量单位时间的核加热率，$\\epsilon_{\\nu}$ 是单位时间的比中微子冷却率，$P$ 是压强，$\\rho$ 是密度。\n- 在静力学环境中，对短时间间隔应用等压燃烧算子时，力学弛豫是分开处理的。在燃烧子步中，热能更新时忽略了机械功项 $P\\,d(1/\\rho)$，并通过状态方程（EOS）强制执行约束 $P=\\mathrm{const}$。因此，热能更新简化为 $d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt$，而随着温度 $T$ 的演化，$\\rho$ 根据恒定 $P$ 下的状态方程得出。\n- 状态方程（EOS）适用于完全电离的理想气体加辐射，假设每粒子的平均分子量 $\\mu$（包括离子和电子）为常数，其表达式为 $P(\\rho,T) = \\rho \\,k_B T / (\\mu m_u) + (1/3)\\,a\\,T^4$，其中 $k_B$ 是玻尔兹曼常数，$m_u$ 是原子质量单位，$a$ 是辐射常数。比内能为 $u(\\rho,T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho$。\n- 压强约束 $P=\\mathrm{const}$ 通过状态方程隐式地给出 $\\rho(T)$：$\\rho(T) = \\alpha \\,[P - (a/3)\\,T^4]/T$，其中 $\\alpha \\equiv \\mu m_u/k_B$。\n- 核能的产生由一个具有强温度依赖性的单一有效通道表示：$\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho,X_{\\mathrm{Ne}}) = Q_{\\mathrm{mass}} \\,\\lambda_0\\,\\rho^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$，其中 $Q_{\\mathrm{mass}}$ 是每消耗单位质量的氖所释放的能量，$\\lambda_0$ 是一个反应速率系数，$\\alpha_\\rho$ 是密度指数，$T_9 \\equiv T/(10^9\\,\\mathrm{K})$，$n$ 是温度指数，$T^\\star$ 是一个特征温标，$X_{\\mathrm{Ne}}$ 是氖的质量分数。\n- 在这些温度下，中微子冷却主要由电子-正电子对过程主导，并近似为 $\\epsilon_{\\nu}(T) = C_\\nu\\,T_9^9$。\n\n你必须编写一个完整、可运行的程序，该程序：\n1. 通过从状态方程中表达 $\\rho(T)$ 来实现等压约束 $P=\\mathrm{const}$。\n2. 使用与简化的第一定律 $d u/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$ 一致的常微分方程（ODE）系统来演化温度 $T(t)$ 和氖质量分数 $X_{\\mathrm{Ne}}(t)$，其中 $u(\\rho(T),T)$ 如上定义。\n3. 对净加热 $H(t) \\equiv \\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_\\nu(t)$ 进行时间积分，以获得 $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$，并在 $X_{\\mathrm{Ne}}$ 下降到指定目标 $X_{\\mathrm{end}}$ 时停止积分。\n4. 计算比内能的变化 $\\Delta u = u(\\rho(T_{\\mathrm{end}}),T_{\\mathrm{end}}) - u(\\rho(T_0),T_0)$。\n5. 通过比较 $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$ 和 $\\Delta u$ 来验证能量守恒，并为每个测试用例返回一个布尔值，指示相对差异是否在规定的容差范围内。\n\n必须遵守所有物理和数值单位：\n- 压强 $P$ 的单位是 $\\mathrm{dyn}\\,\\mathrm{cm}^{-2}$。\n- 密度 $\\rho$ 的单位是 $\\mathrm{g}\\,\\mathrm{cm}^{-3}$。\n- 温度 $T$ 的单位是 $\\mathrm{K}$。\n- 时间 $t$ 的单位是 $\\mathrm{s}$。\n- 比能相关量 $u$、$\\dot{\\epsilon}_{\\mathrm{nuc}}$、$\\epsilon_\\nu$ 及其积分的单位是 $\\mathrm{erg}\\,\\mathrm{g}^{-1}$ 和 $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$。\n- 平均分子量 $\\mu$ 被视为常数且无量纲。\n- 输出的布尔值指示 $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta) \\leq \\tau$ 是否成立，其中 $\\delta$ 是一个小的下限值，$\\tau$ 是容差。\n\n从第一性原理推导沿等压路径的温度演化：\n- 在 $u(T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho(T)$ 和 $\\rho(T) = \\alpha\\, [P - (a/3)T^4]/T$ 的条件下，定义沿等压线的有效比热 $c_{\\mathrm{eff}}(T) \\equiv du/dT$。\n- 使用简化的第一定律写出 $dT/dt = [\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho(T),X_{\\mathrm{Ne}}) - \\epsilon_\\nu(T)]/c_{\\mathrm{eff}}(T)$ 和 $dX_{\\mathrm{Ne}}/dt = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$。\n- 引入一个辅助积分状态 $E(t)$，其满足 $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$，以累积时间积分。\n\n使用的常数：\n- 玻尔兹曼常数 $k_B = 1.380649 \\times 10^{-16}\\,\\mathrm{erg}\\,\\mathrm{K}^{-1}$。\n- 原子质量单位 $m_u = 1.66053906660 \\times 10^{-24}\\,\\mathrm{g}$。\n- 辐射常数 $a = 7.5657 \\times 10^{-15}\\,\\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{K}^{-4}$。\n- 平均分子量 $\\mu = 0.6$。\n- 密度指数 $\\alpha_\\rho = 1$。\n- 温度指数 $n = 10$。\n- 特征温度 $T^\\star = 1.0 \\times 10^9\\,\\mathrm{K}$。\n- 每消耗单位氖质量分数释放的比能 $Q_{\\mathrm{mass}} = 3.0 \\times 10^{17}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$。\n- 容差 $\\tau = 5.0 \\times 10^{-4}$ 和下限值 $\\delta = 1.0 \\times 10^{-12}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$。\n\n测试套件规范：\n提供以下测试用例，每个用例为一个元组 $(P, T_0, X_0, X_{\\mathrm{end}}, \\lambda_0, C_\\nu, t_{\\mathrm{max}})$：\n- 用例 A（正常路径，气体压强主导）：$(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.40, 1.0 \\times 10^{-9}, 8.0 \\times 10^{13}, 500.0)$。\n- 用例 B（中微子冷却主导）：$(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.45, 2.0 \\times 10^{-9}, 5.0 \\times 10^{14}, 2000.0)$。\n- 用例 C（接近辐射压边界）：$(1.50 \\times 10^{22}, 1.30 \\times 10^{9}, 0.40, 0.35, 1.0 \\times 10^{-8}, 5.0 \\times 10^{13}, 500.0)$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中每个 $r_i$ 是一个布尔值，指示相应测试用例的相对差异 $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta)$ 是否小于或等于容差 $\\tau$。", "solution": "问题陈述经过严格审查，被确定为**有效**。它在计算核天体物理学领域提出了一个自洽、科学上一致且适定的问题。该场景描述了算子分裂流体动力学代码的一个标准数值验证测试，其目标是确认在指定简化假设下，热能演化的数值积分与热力学第一定律是一致的。所有必需的方程、常数和初始条件都已提供，不存在矛盾或事实错误。\n\n该解决方案建立在流体元的热力学第一定律之上，在问题的等压（$P=\\mathrm{const}$）燃烧算子近似下，该定律简化为：\n$$\n\\frac{du}{dt} = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n$$\n其中 $u$ 是比内能，$\\dot{\\epsilon}_{\\mathrm{nuc}}$ 是比核加热率，$\\epsilon_{\\nu}$ 是比中微子冷却率。\n\n目标是数值验证比内能的总变化量 $\\Delta u = u_{\\mathrm{end}} - u_0$ 等于净比加热率的时间积分 $\\int_0^{t_{\\mathrm{end}}} (\\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_{\\nu}(t)) dt$。这需要随时间演化系统的热力学状态——特别是其温度 $T$ 和组分（氖质量分数 $X_{\\mathrm{Ne}}$）。这个演化由一个常微分方程（ODE）组控制。\n\n系统的状态可以用一个向量 $\\vec{y}(t) = [T(t), X_{\\mathrm{Ne}}(t), E(t)]^T$ 来描述，其中 $E(t)$ 是一个辅助状态变量，代表累积的净加热：\n$$\nE(t) = \\int_0^t (\\dot{\\epsilon}_{\\mathrm{nuc}}(t') - \\epsilon_{\\nu}(t')) dt'\n$$\n$E$ 对应的常微分方程就是 $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}$。\n\n为了推导温度的常微分方程，我们将链式法则应用于简化后的热力学第一定律的左侧：\n$$\n\\frac{du}{dt} = \\frac{du}{dT} \\bigg|_{P=\\mathrm{const}} \\frac{dT}{dt}\n$$\n我们定义沿等压线的有效比热容为 $c_{\\mathrm{eff}}(T) \\equiv \\frac{du}{dT}|_{P=\\mathrm{const}}$。这使我们能够将温度演化方程写为：\n$$\n\\frac{dT}{dt} = \\frac{\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}}{c_{\\mathrm{eff}}(T)}\n$$\n$c_{\\mathrm{eff}}(T)$ 的推导至关重要。在等压约束下，比内能 $u$ 和密度 $\\rho$ 都是温度 $T$ 的函数。给定的状态方程是 $P = \\rho k_B T / (\\mu m_u) + (1/3) a T^4$。定义常数 $\\alpha \\equiv \\mu m_u/k_B$，我们可以将密度表示为温度的函数：\n$$\n\\rho(T) = \\frac{\\alpha}{T} \\left(P - \\frac{1}{3} a T^4\\right)\n$$\n比内能由 $u(\\rho,T) = (3/2) k_B T/(\\mu m_u) + a T^4/\\rho$ 给出。代入 $\\rho(T)$，我们得到沿等压线 $u$ 仅作为 $T$ 的函数：\n$$\nu(T) = \\frac{3}{2\\alpha}T + \\frac{a T^4}{\\frac{\\alpha}{T}(P - \\frac{1}{3} a T^4)} = \\frac{3}{2\\alpha}T + \\frac{a T^5}{\\alpha(P - \\frac{1}{3} a T^4)}\n$$\n通过商法则对 $u(T)$ 关于 $T$ 求导，得到 $c_{\\mathrm{eff}}(T)$ 的表达式：\n$$\nc_{\\mathrm{eff}}(T) = \\frac{du}{dT} = \\frac{3P^2 + 8PaT^4 - \\frac{1}{3}a^2T^8}{2\\alpha \\left(P - \\frac{1}{3}aT^4\\right)^2}\n$$\n氖质量分数 $X_{\\mathrm{Ne}}$ 的演化由反应动力学给出。问题将破坏率定义为：\n$$\n\\frac{dX_{\\mathrm{Ne}}}{dt} = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}\n$$\n其中 $T_9 = T / (10^9\\,\\mathrm{K})$。根据给定的公式，这与核能产生率 $\\dot{\\epsilon}_{\\mathrm{nuc}} = -Q_{\\mathrm{mass}} (dX_{\\mathrm{Ne}}/dt)$ 是一致的。\n\n需要求解的完整常微分方程组是：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} T \\\\ X_{\\mathrm{Ne}} \\\\ E \\end{pmatrix}\n=\n\\begin{pmatrix}\n(\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}) / c_{\\mathrm{eff}}(T) \\\\\n-\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}} \\\\\n\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n\\end{pmatrix}\n$$\n这个初值问题使用数值常微分方程积分器（如 `scipy.integrate.solve_ivp`）来求解，从初始状态 $[T_0, X_0, 0]$ 开始。积分被配置为当 $X_{\\mathrm{Ne}}$ 达到指定的最终质量分数 $X_{\\mathrm{end}}$ 时终止，这通过求解器的事件检测功能实现。\n\n在时间 $t_{\\mathrm{end}}$ 终止时，求解器返回最终状态 $[T_{\\mathrm{end}}, X_{\\mathrm{end}}, E_{\\mathrm{integrated}}]$。项 $E_{\\mathrm{integrated}}$ 是 $\\int H dt$ 的数值计算结果。比内能的变化 $\\Delta u$ 使用初始和最终状态独立计算：\n$$\n\\Delta u = u(\\rho(T_{\\mathrm{end}}), T_{\\mathrm{end}}) - u(\\rho(T_0), T_0)\n$$\n最后，通过检查这两个量之间的相对差异是否在规定的容差 $\\tau$ 内来验证能量守恒：\n$$\n\\frac{|\\Delta u - E_{\\mathrm{integrated}}|}{\\max(|\\Delta u|, \\delta)} \\le \\tau\n$$\n提供的 Python 程序实现了这一逻辑，定义了用于 $\\rho(T)$、 $u(\\rho, T)$ 和 $c_{\\mathrm{eff}}(T)$ 的辅助函数，然后遍历每个测试用例以求解常微分方程并执行验证。采用具有严格容差的高精度求解器方法（`Radau`）来最小化数值积分误差，并确保该检查能正确验证模型实现的物理和数学一致性。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Physical and numerical constants\nk_B_val = 1.380649e-16  # erg K^-1\nm_u_val = 1.66053906660e-24  # g\na_val = 7.5657e-15  # erg cm^-3 K^-4\nmu_val = 0.6\nalpha_rho_val = 1.0\nn_val = 10.0\nT_star_val = 1.0e9  # K\nQ_mass_val = 3.0e17  # erg g^-1\ntau_val = 5.0e-4\ndelta_val = 1.0e-12  # erg g^-1\n\nalpha_val = mu_val * m_u_val / k_B_val  # g K erg^-1\n\ndef get_rho(T, P):\n    \"\"\"Calculates density on the isobar given T and P.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    if P = rad_pressure_part:\n        return np.nan\n    return alpha_val * (P - rad_pressure_part) / T\n\ndef get_u(T, rho):\n    \"\"\"Calculates specific internal energy given T and rho.\"\"\"\n    if rho = 0:\n        return np.nan\n    # u = (3/2) * k_B * T / (mu * m_u) + a * T**4 / rho\n    # (k_B / (mu * m_u)) is 1/alpha\n    return (3.0 / 2.0) * T / alpha_val + a_val * T**4 / rho\n\ndef get_c_eff(T, P):\n    \"\"\"Calculates effective specific heat capacity along the isobar.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    denom_factor = P - rad_pressure_part\n    if denom_factor = 0:\n        return np.nan\n\n    P_sq = P**2\n    a_sq = a_val**2\n    T_4 = T**4\n    T_8 = T_4**2\n    \n    numerator = 3.0 * P_sq + 8.0 * P * a_val * T_4 - (1.0 / 3.0) * a_sq * T_8\n    denominator = 2.0 * alpha_val * denom_factor**2\n    return numerator / denominator\n\ndef ode_rhs(t, y, P, lambda0, C_nu):\n    \"\"\"Right-hand side of the ODE system dy/dt = f(t, y).\"\"\"\n    T, X_Ne, _ = y\n    \n    if T = 0:\n        return [0.0, 0.0, 0.0]\n\n    T9 = T / 1.0e9\n    \n    rho = get_rho(T, P)\n    if np.isnan(rho) or rho = 0:\n        return [0.0, 0.0, 0.0]\n\n    # Reaction rate factor\n    rate_factor = lambda0 * rho**alpha_rho_val * T9**n_val * np.exp(-T_star_val / T)\n    \n    eps_nuc = Q_mass_val * rate_factor * X_Ne\n    eps_nu = C_nu * T9**9\n    net_heating = eps_nuc - eps_nu\n    \n    c_eff = get_c_eff(T, P)\n    if np.isnan(c_eff) or c_eff = 0:\n        return [0.0, 0.0, 0.0]\n\n    dT_dt = net_heating / c_eff\n    dX_Ne_dt = -rate_factor * X_Ne\n    dE_dt = net_heating\n    \n    return [dT_dt, dX_Ne_dt, dE_dt]\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # (P, T0, X0, X_end, lambda0, C_nu, t_max)\n        (1.0e23, 1.30e9, 0.50, 0.40, 1.0e-9, 8.0e13, 500.0),\n        (1.0e23, 1.30e9, 0.50, 0.45, 2.0e-9, 5.0e14, 2000.0),\n        (1.50e22, 1.30e9, 0.40, 0.35, 1.0e-8, 5.0e13, 500.0),\n    ]\n\n    results = []\n    for P, T0, X0, X_end, lambda0, C_nu, t_max in test_cases:\n        rho0 = get_rho(T0, P)\n        u0 = get_u(T0, rho0)\n        y0 = [T0, X0, 0.0]\n\n        def stop_event(t, y, P, lambda0, C_nu):\n            return y[1] - X_end\n        stop_event.terminal = True\n        \n        sol = solve_ivp(\n            fun=ode_rhs,\n            t_span=[0, t_max],\n            y0=y0,\n            args=(P, lambda0, C_nu),\n            events=stop_event,\n            dense_output=True,\n            method='Radau',\n            rtol=1e-9,\n            atol=1e-9\n        )\n\n        if not sol.t_events or not sol.t_events[0] or sol.status == -1:\n            results.append(False)\n            continue\n            \n        y_end = sol.y_events[0].flatten()\n        T_end, _, E_integrated = y_end\n        \n        rho_end = get_rho(T_end, P)\n        u_end = get_u(T_end, rho_end)\n        \n        Delta_u = u_end - u0\n        \n        discrepancy = abs(E_integrated - Delta_u)\n        denominator = max(abs(Delta_u), delta_val)\n        \n        if denominator == 0:\n             is_conserved = (discrepancy == 0)\n        else:\n            relative_discrepancy = discrepancy / denominator\n            is_conserved = relative_discrepancy = tau_val\n            \n        results.append(is_conserved)\n\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3590315"}, {"introduction": "恒星模型的预测从根本上受到核反应速率不确定性的限制。这个高级实践将介绍灵敏度分析，这是一种量化这些影响的强大技术。你将计算关键的 $^{12}\\mathrm{C}+^{12}\\mathrm{C}$ 反应速率的微小变化如何通过刚性求解器传播，从而影响最终的 $^{28}\\mathrm{Si}$ 丰度，为模型对这一关键核物理输入的灵敏度提供一阶估计。[@problem_id:3590317]", "problem": "您的任务是，在静态碳燃烧的单个刚性求解器步长中，量化硅-28 ($^{28}\\mathrm{Si}$) 的最终摩尔丰度对碳-碳反应速率分数微扰的一阶灵敏度。考虑一个包含物种 $^{12}\\mathrm{C}$、$^{20}\\mathrm{Ne}$、$^{24}\\mathrm{Mg}$、$^{28}\\mathrm{Si}$ 和 $^{4}\\mathrm{He}$ (alpha) 的简化且科学上合理的反应网络。在固定温度和密度的静水平衡条件下进行计算，并假设在求解器步长内，热平均反应速率保持不变。\n\n基本和核心定义：\n- 该系统根据一个常微分方程 (ODE) 演化：$\\frac{d\\boldsymbol{Y}}{dt} = \\boldsymbol{f}(\\boldsymbol{Y}; \\rho, R_1, R_2, R_3)$，其中 $\\boldsymbol{Y} = (Y_{\\mathrm{C}}, Y_{\\mathrm{Ne}}, Y_{\\mathrm{Mg}}, Y_{\\mathrm{Si}}, Y_{\\alpha})$ 是每重子的摩尔丰度，$\\rho$ 是质量密度， $R_i$ 表示反应速率 $R \\equiv N_A \\langle \\sigma v \\rangle$，单位为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}\\,\\mathrm{mol}^{-1}$，其中 $N_A$ 是阿伏伽德罗常数，$\\langle \\sigma v \\rangle$ 是热平均截面。\n- 对于双体反应，使用质量作用动力学。对于反应 $a+b \\rightarrow \\cdots$，每重子的反应速率为 $\\rho R Y_a Y_b$。对于相同的反应物 $a+a$，每重子的反应速率为 $\\frac{1}{2}\\rho R Y_a^2$，而 $a$ 的消耗速率是该速率的两倍。\n- 反应网络：\n  1. $^{12}\\mathrm{C} + ^{12}\\mathrm{C} \\rightarrow ^{20}\\mathrm{Ne} + \\alpha$，速率为 $R_1$。\n  2. $^{20}\\mathrm{Ne} + \\alpha \\rightarrow ^{24}\\mathrm{Mg} + \\gamma$，速率为 $R_2$。\n  3. $^{24}\\mathrm{Mg} + \\alpha \\rightarrow ^{28}\\mathrm{Si} + \\gamma$，速率为 $R_3$。\n- 在状态 $\\boldsymbol{Y}$ 下定义标量反应流：\n  $$r_1 = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,\\quad r_2 = \\rho R_2 Y_{\\mathrm{Ne}} Y_{\\alpha},\\quad r_3 = \\rho R_3 Y_{\\mathrm{Mg}} Y_{\\alpha}.$$\n- 那么，ODE 的分量为：\n  $$\\frac{dY_{\\mathrm{C}}}{dt} = -2 r_1,$$\n  $$\\frac{dY_{\\mathrm{Ne}}}{dt} = r_1 - r_2,$$\n  $$\\frac{dY_{\\mathrm{Mg}}}{dt} = r_2 - r_3,$$\n  $$\\frac{dY_{\\mathrm{Si}}}{dt} = r_3,$$\n  $$\\frac{dY_{\\alpha}}{dt} = r_1 - r_2 - r_3.$$\n\n刚性求解器步长：\n- 使用1阶后向差分公式（BDF1，也称为后向欧拉法）将 $\\boldsymbol{Y}$ 从时间 $t_n$推进到 $t_{n+1} = t_n + \\Delta t$：求解\n  $$\\boldsymbol{G}(\\boldsymbol{Y}_{n+1}) \\equiv \\boldsymbol{Y}_{n+1} - \\boldsymbol{Y}_n - \\Delta t\\,\\boldsymbol{f}(\\boldsymbol{Y}_{n+1}) = \\boldsymbol{0}.$$\n- 令 $R_1$ 受到分数微扰，$R_1 \\mapsto (1+\\epsilon)R_1$，其中 $\\epsilon$ 很小。通过对刚性步长进行隐式微分，计算由于此微扰引起的最终硅-28丰度 $Y_{\\mathrm{Si}, n+1}$ 的一阶变化：\n  $$\\left[\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})\\right]\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}),$$\n  其中 $\\boldsymbol{J}_f(\\boldsymbol{Y}) = \\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{Y}}$ 是 $\\boldsymbol{f}$ 的雅可比矩阵，$\\boldsymbol{s} = \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon}\\big|_{\\epsilon=0}$ 是灵敏度向量。所求量为一阶变化 $\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$。\n- 对于此网络，偏导数 $\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}$ 仅通过 $r_1$ 产生并满足\n  $$\\frac{\\partial r_1}{\\partial \\epsilon} = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,$$\n  因此\n  $$\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon} = \\left(-\\rho R_1 Y_{\\mathrm{C}}^2,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,\\; 0,\\; 0,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2\\right)^\\top,$$\n  在 $\\boldsymbol{Y}_{n+1}$ 处求值。\n\n物理和数值参数：\n- 使用质量密度 $\\rho = 10^6$ g/cm$^3$。\n- 使用反应速率 $R_1 = 10^{-7}$，$R_2 = 10^{-5}$，$R_3 = 5\\times 10^{-6}$，单位均为 $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}\\,\\mathrm{mol}^{-1}$。\n- 摩尔丰度为 $Y_i = X_i/A_i$，其中 $X_i$ 是质量分数，$A_i$ 是质量数。这些 $Y_i$ 是每重子的无量纲量。\n\n算法要求：\n- 通过使用解析推导的雅可比矩阵 $\\boldsymbol{J}_f(\\boldsymbol{Y})$ 和隐式雅可比矩阵 $\\boldsymbol{J}_{\\mathrm{imp}} = \\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})$ 求解 $\\boldsymbol{G}(\\boldsymbol{Y}_{n+1})=\\boldsymbol{0}$，为 BDF1 步长实现一个牛顿-拉弗森求解器。使用阻尼来维持丰度的非负性。\n- 在 $\\epsilon=0$ 时获得 $\\boldsymbol{Y}_{n+1}$ 后，建立并求解关于 $\\boldsymbol{s}$ 的线性系统：\n  $$\\boldsymbol{J}_{\\mathrm{imp}}\\,\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}).$$\n- 报告每个测试用例的一阶变化 $\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$。最终答案以摩尔丰度单位（无量纲）表示，为浮点数。\n\n测试套件：\n- 使用以下初始状态 $\\boldsymbol{Y}_n$、时间步长 $\\Delta t$ 和微扰 $\\epsilon$：\n  1. 情况 A (正常路径)：$Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, $Y_{\\mathrm{Ne}}=0$, $Y_{\\mathrm{Mg}}=0$, $Y_{\\mathrm{Si}}=0$, $\\Delta t = 1000$ s, $\\epsilon = 0.01$。\n  2. 情况 B (边界，零微扰)：与情况 A 相同的初始状态和 $\\Delta t$，但 $\\epsilon = 0$。\n  3. 情况 C (边缘，碳可忽略)：$Y_{\\mathrm{C}} = \\frac{10^{-6}}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, 其他物种为零, $\\Delta t = 1000$ s, $\\epsilon = 0.05$。\n  4. 情况 D (边缘，alpha极低)：$Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{10^{-6}}{4}$, 其他物种为零, $\\Delta t = 1000$ s, $\\epsilon = 0.2$。\n  5. 情况 E (刚性，大步长)：$Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, 其他物种为零, $\\Delta t = 10^5$ s, $\\epsilon = 0.01$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。该列表必须按顺序包含与上述五个情况对应的五个浮点数值 $\\delta Y_{\\mathrm{Si}}$。", "solution": "该问题被评估为**有效**。这是一个计算核天体物理学中适定、有科学依据的问题，其内部一致，并为唯一解提供了所有必要的数据。该任务要求将标准、稳健的数值方法（后向欧拉法、牛顿-拉弗森法）和灵敏度分析技术（隐式微分）应用于一个简化但物理上合理的恒星反应网络。\n\n求解过程分为两个主要阶段：首先，数值求解单个刚性时间步长内物种丰度的演化；其次，计算最终硅丰度对关键反应速率微扰的一阶灵敏度。\n\n### 1. 使用后向欧拉法 (BDF1) 的刚性时间步长\n\n摩尔丰度向量 $\\boldsymbol{Y} = (Y_{\\mathrm{C}}, Y_{\\mathrm{Ne}}, Y_{\\mathrm{Mg}}, Y_{\\mathrm{Si}}, Y_{\\alpha})^\\top$ 的演化由常微分方程 (ODE) 系统 $\\frac{d\\boldsymbol{Y}}{dt} = \\boldsymbol{f}(\\boldsymbol{Y})$ 控制。$\\boldsymbol{f}(\\boldsymbol{Y})$ 的分量由反应流 $r_1, r_2, r_3$ 定义：\n$$r_1 = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2$$\n$$r_2 = \\rho R_2 Y_{\\mathrm{Ne}} Y_{\\alpha}$$\n$$r_3 = \\rho R_3 Y_{\\mathrm{Mg}} Y_{\\alpha}$$\nODE 系统为：\n$$\\boldsymbol{f}(\\boldsymbol{Y}) = \\begin{pmatrix} -2 r_1 \\\\ r_1 - r_2 \\\\ r_2 - r_3 \\\\ r_3 \\\\ r_1 - r_2 - r_3 \\end{pmatrix}$$\n\n为将系统从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$，我们使用一阶后向差分公式 (BDF1)，也称为后向欧拉法。这种隐式方法适用于刚性系统。它需要为未知状态 $\\boldsymbol{Y}_{n+1}$ 求解以下非线性代数方程组：\n$$\\boldsymbol{G}(\\boldsymbol{Y}_{n+1}) \\equiv \\boldsymbol{Y}_{n+1} - \\boldsymbol{Y}_n - \\Delta t\\,\\boldsymbol{f}(\\boldsymbol{Y}_{n+1}) = \\boldsymbol{0}$$\n其中 $\\boldsymbol{Y}_n$ 是步长开始时的已知状态。\n\n该非线性系统使用牛顿-拉弗森法求解。从一个初始猜测（例如，$\\boldsymbol{Y}_{n+1}^{(0)} = \\boldsymbol{Y}_n$）开始，我们通过以下方式迭代地优化解：\n$$\\boldsymbol{Y}_{n+1}^{(k+1)} = \\boldsymbol{Y}_{n+1}^{(k)} - [\\boldsymbol{J}_G(\\boldsymbol{Y}_{n+1}^{(k)})]^{-1} \\boldsymbol{G}(\\boldsymbol{Y}_{n+1}^{(k)})$$\n其中 $\\boldsymbol{J}_G$ 是 $\\boldsymbol{G}$ 相对于 $\\boldsymbol{Y}_{n+1}$ 的雅可比矩阵。该隐式雅可比矩阵由下式给出：\n$$\\boldsymbol{J}_G(\\boldsymbol{Y}) = \\frac{\\partial \\boldsymbol{G}}{\\partial \\boldsymbol{Y}} = \\boldsymbol{I} - \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{Y}} = \\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y})$$\n这里，$\\boldsymbol{I}$ 是单位矩阵，$\\boldsymbol{J}_f(\\boldsymbol{Y})$ 是 ODE 函数 $\\boldsymbol{f}$ 的雅可比矩阵。解析雅可比矩阵 $\\boldsymbol{J}_f$ 计算如下：\n$$ \\boldsymbol{J}_f(\\boldsymbol{Y}) = \\rho \\begin{pmatrix}\n-2 R_1 Y_C  0  0  0  0 \\\\\nR_1 Y_C  -R_2 Y_\\alpha  0  0  -R_2 Y_{Ne} \\\\\n0  R_2 Y_\\alpha  -R_3 Y_\\alpha  0  R_2 Y_{Ne} - R_3 Y_{Mg} \\\\\n0  0  R_3 Y_\\alpha  0  R_3 Y_{Mg} \\\\\nR_1 Y_C  -R_2 Y_\\alpha  -R_3 Y_\\alpha  0  -R_2 Y_{Ne} - R_3 Y_{Mg}\n\\end{pmatrix} $$\n迭代过程包括求解线性系统 $\\boldsymbol{J}_G \\Delta \\boldsymbol{Y} = -\\boldsymbol{G}$ 以获得修正量 $\\Delta \\boldsymbol{Y}$。对更新步应用阻尼，以确保所有丰度保持非负，这是一个关键的物理约束。迭代持续进行，直到残差向量 $\\boldsymbol{G}$ 的范数低于指定的容差。\n\n### 2. 一阶灵敏度分析\n\n在获得收敛状态 $\\boldsymbol{Y}_{n+1}$ 后，我们计算该最终状态对速率 $R_1$ 的分数微扰的灵敏度，定义为 $R_1 \\mapsto R_1(1+\\epsilon)$。通过对 BDF1 方程关于 $\\epsilon$ 求导并在 $\\epsilon=0$ 处求值，可以找到灵敏度向量 $\\boldsymbol{s} = \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon}\\big|_{\\epsilon=0}$：\n$$\\frac{d\\boldsymbol{G}}{d\\epsilon} = \\frac{\\partial \\boldsymbol{G}}{\\partial \\boldsymbol{Y}_{n+1}} \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon} + \\frac{\\partial \\boldsymbol{G}}{\\partial \\epsilon} = \\boldsymbol{0}$$\n重新整理得到关于 $\\boldsymbol{s}$ 的线性系统：\n$$[\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})]\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1})$$\n左侧的矩阵正是在收敛解 $\\boldsymbol{Y}_{n+1}$ 处求值的隐式雅可比矩阵 $\\boldsymbol{J}_G$，它已在牛顿-拉弗森求解器的最后一步中计算出来。\n\n右侧向量取决于 $\\boldsymbol{f}$ 对 $\\epsilon$ 的偏导数。由于只有 $R_1$ 受到微扰，该导数仅源于流 $r_1$ 对 $\\epsilon$ 的依赖性：\n$$\\frac{\\partial r_1}{\\partial \\epsilon} = \\frac{\\partial}{\\partial \\epsilon}\\left(\\frac{1}{2}\\rho R_1(1+\\epsilon) Y_C^2\\right) = \\frac{1}{2}\\rho R_1 Y_C^2$$\n因此，灵敏度方程的源项为：\n$$\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}) = \\left(-\\rho R_1 Y_{\\mathrm{C}, n+1}^2,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}, n+1}^2,\\; 0,\\; 0,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}, n+1}^2\\right)^\\top$$\n通过求解线性系统 $\\boldsymbol{J}_G(\\boldsymbol{Y}_{n+1})\\,\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1})$ 得到 $\\boldsymbol{s}$，我们获得了所有物种的灵敏度。所求量是硅丰度的一阶变化，由下式给出：\n$$\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$$\n其中 $s_{\\mathrm{Si}}$ 是 $\\boldsymbol{s}$ 中对应于 $^{28}\\mathrm{Si}$ 的分量。对每个测试用例应用此过程以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the first-order sensitivity of the final 28Si abundance \n    to a perturbation in the 12C+12C reaction rate for five test cases.\n    \"\"\"\n    # Physical constants\n    RHO = 1e6  # g/cm^3\n    R1 = 1e-7  # cm^3 s^-1 mol^-1\n    R2 = 1e-5  # cm^3 s^-1 mol^-1\n    R3 = 5e-6  # cm^3 s^-1 mol^-1\n\n    # Indices for species in the abundance vector Y\n    C, NE, MG, SI, ALPHA = 0, 1, 2, 3, 4\n\n    def f_ode(Y):\n        \"\"\"Computes the RHS of the ODE system, dy/dt = f(Y).\"\"\"\n        YC, YNe, YMg, _, YAlpha = Y\n        \n        # Ensure non-negativity for physical rates\n        YC = max(0, YC)\n        YNe = max(0, YNe)\n        YMg = max(0, YMg)\n        YAlpha = max(0, YAlpha)\n        \n        r1 = 0.5 * RHO * R1 * YC**2\n        r2 = RHO * R2 * YNe * YAlpha\n        r3 = RHO * R3 * YMg * YAlpha\n        \n        dYdt = np.zeros(5)\n        dYdt[C] = -2 * r1\n        dYdt[NE] = r1 - r2\n        dYdt[MG] = r2 - r3\n        dYdt[SI] = r3\n        dYdt[ALPHA] = r1 - r2 - r3\n        \n        return dYdt\n\n    def jacobian_f(Y):\n        \"\"\"Computes the analytical Jacobian of the ODE function f(Y).\"\"\"\n        YC, YNe, YMg, _, YAlpha = Y\n\n        # Ensure non-negativity\n        YC = max(0, YC)\n        YNe = max(0, YNe)\n        YMg = max(0, YMg)\n        YAlpha = max(0, YAlpha)\n\n        J = np.zeros((5, 5))\n        \n        # Derivatives w.r.t Y_C (column 0)\n        J[C, C] = -2 * RHO * R1 * YC\n        J[NE, C] = RHO * R1 * YC\n        J[ALPHA, C] = RHO * R1 * YC\n        \n        # Derivatives w.r.t Y_Ne (column 1)\n        J[NE, NE] = -RHO * R2 * YAlpha\n        J[MG, NE] = RHO * R2 * YAlpha\n        J[ALPHA, NE] = -RHO * R2 * YAlpha\n        \n        # Derivatives w.r.t Y_Mg (column 2)\n        J[MG, MG] = -RHO * R3 * YAlpha\n        J[SI, MG] = RHO * R3 * YAlpha\n        J[ALPHA, MG] = -RHO * R3 * YAlpha\n        \n        # Derivatives w.r.t Y_Si (column 3) are all zero\n        \n        # Derivatives w.r.t Y_alpha (column 4)\n        J[NE, ALPHA] = -RHO * R2 * YNe\n        J[MG, ALPHA] = RHO * R2 * YNe - RHO * R3 * YMg\n        J[SI, ALPHA] = RHO * R3 * YMg\n        J[ALPHA, ALPHA] = -RHO * R2 * YNe - RHO * R3 * YMg\n        \n        return J\n\n    def run_case(Y_n, dt, epsilon):\n        \"\"\"Solves one BDF1 step and computes the required sensitivity.\"\"\"\n        \n        # --- Stage 1: Solve for Y_n+1 using Newton-Raphson ---\n        Y_np1 = np.copy(Y_n)\n        tol = 1e-12\n        max_iter = 50\n\n        for _ in range(max_iter):\n            G = Y_np1 - Y_n - dt * f_ode(Y_np1)\n            \n            if np.linalg.norm(G)  tol:\n                break\n            \n            J_imp = np.identity(5) - dt * jacobian_f(Y_np1)\n            \n            try:\n                dY = np.linalg.solve(J_imp, -G)\n            except np.linalg.LinAlgError:\n                # If Jacobian is singular, we cannot proceed.\n                # This may happen if the state is pathological.\n                # For this problem set, we assume it does not occur.\n                dY = np.zeros_like(Y_n)\n\n            # Damping to maintain non-negativity\n            lambda_ = 1.0\n            Y_trial = Y_np1 + lambda_ * dY\n            # Repeatedly halve lambda if any component becomes negative\n            while np.any(Y_trial  0):\n                lambda_ /= 2.0\n                Y_trial = Y_np1 + lambda_ * dY\n                if lambda_  1e-8: # Failsafe\n                    dY = np.zeros_like(Y_n)\n                    break\n            \n            Y_np1 += lambda_ * dY\n\n        # --- Stage 2: Sensitivity Analysis ---\n        if epsilon == 0:\n            return 0.0\n\n        # Right-hand side of sensitivity equation: b = dt * (df/d_epsilon)\n        df_deps = np.zeros(5)\n        # Term arising from d(r1)/d(epsilon)\n        r1_pert_term = 0.5 * RHO * R1 * max(0, Y_np1[C])**2\n        \n        df_deps[C] = -2 * r1_pert_term\n        df_deps[NE] = r1_pert_term\n        df_deps[ALPHA] = r1_pert_term\n        \n        b = dt * df_deps\n        \n        # Matrix is the implicit Jacobian from the final Newton step\n        J_imp_final = np.identity(5) - dt * jacobian_f(Y_np1)\n        \n        try:\n            s = np.linalg.solve(J_imp_final, b)\n        except np.linalg.LinAlgError:\n            s = np.zeros_like(Y_n)\n\n        # First-order change = s_Si * epsilon\n        delta_Y_Si = s[SI] * epsilon\n        \n        return delta_Y_Si\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (normal path)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.01),\n        # Case B (boundary, zero perturbation)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.0),\n        # Case C (edge, negligible carbon)\n        (np.array([1e-6/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.05),\n        # Case D (edge, very low alpha)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 1e-6/4]), 1000.0, 0.2),\n        # Case E (stiff, large step)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1e5, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        Yn_case, dt_case, epsilon_case = case\n        result = run_case(Yn_case, dt_case, epsilon_case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3590317"}]}