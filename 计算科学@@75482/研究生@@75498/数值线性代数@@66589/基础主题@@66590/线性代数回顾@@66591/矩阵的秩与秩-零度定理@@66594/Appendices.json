{"hands_on_practices": [{"introduction": "秩-零度定理在理论上保证了零空间的存在，但在实践中我们如何计算出它的一个基呢？本练习将指导你使用列主元QR分解这一强大的数值工具，通过分析上三角因子 $R$ 来估计矩阵的秩，进而求解零空间的基向量。这个过程不仅能让你亲手实现一个核心的数值线性代数算法，还能让你深刻体会到诸如主元选择等算法细节对数值结果稳定性的影响。[@problem_id:3558928]", "problem": "您需要实现一个完整的、可运行的程序，该程序针对给定的实数矩阵，仅使用通过列主元正交三角 (QR) 分解得到的上三角因子 $R$ 来估计零空间 $\\ker(A)$ 的一组基，然后分析该估计对列主元顺序的敏感性。研究必须基于秩、零空间和秩-零度定理的核心定义，并且必须从这些原理出发，而不依赖于问题陈述中的任何捷径公式。\n\n推导的基本依据：\n- 对于矩阵 $A \\in \\mathbb{R}^{m \\times n}$，秩-零度定理表明 $\\operatorname{rank}(A) + \\dim \\ker(A) = n$。\n- 零空间 $\\ker(A)$ 是所有满足 $A x = 0$ 的向量 $x \\in \\mathbb{R}^{n}$ 的集合。\n- 列主元正交三角 (QR) 分解产生列的一个置换和正交-三角因子，其中分解满足 $A P = Q R$，其中 $P$ 是一个置换矩阵，$Q$ 是正交矩阵，$R$ 是上三角（或上梯形）矩阵。\n\n需要执行的任务：\n1. 对每个测试矩阵 $A$，使用预设的列预置换计算 $A$ 的列主元QR分解。使用所得 $R$ 矩阵的对角线通过阈值规则估计数值秩 $\\hat{r}$：将幅值低于阈值的 $R_{ii}$ 值视为数值上为零。设阈值由一个无量纲参数 $\\tau$ 指定，该参数相对于 $R$ 的最大对角线幅值进行缩放。\n2. 仅使用 $R$ 和主元信息，构建一个维度为 $n - \\hat{r}$ 的 $\\ker(A)$ 的基的估计，并将其映射回原始的列顺序。在此构建过程中不要使用奇异值分解 (SVD)；仅使用 $R$ 和主元信息。\n3. 通过计算残差 $A N$ 的 Frobenius 范数来量化估计基的质量，其中 $N$ 是其列构成零空间估计基的矩阵。将此范数报告为一个浮点数。\n4. 为分析对主元顺序的敏感性，在 $A$ 的第二次列预置换下重复零空间基的构建过程。计算两个估计的零空间子空间之间的主角，并报告最大主角。角度单位必须是弧度。\n5. 此外，以布尔值的形式报告两次运行（使用不同的预置换）是否在估计的零度 $\\widehat{\\nu} = n - \\hat{r}$ 上达成一致。\n\n每个测试用例的输出规范：\n- 生成一个包含五个项目的列表：\n  - 估计的秩 $\\hat{r}$，为整数。\n  - 估计的零度 $\\widehat{\\nu} = n - \\hat{r}$，为整数。\n  - Frobenius 范数 $\\|A N\\|_F$，为浮点数。\n  - 两个估计的零空间之间的最大主角（单位为弧度），为浮点数。\n  - 一个布尔值，指示两次运行是否在 $\\widehat{\\nu}$ 上达成一致。\n- 将所有测试用例的结果汇总到一行输出中，该行包含一个由方括号括起来的逗号分隔列表，例如 $[\\text{case1},\\text{case2},\\ldots]$。\n\n测试套件：\n实现以下四个科学上合理且多样化的测试用例。所有随机抽取必须通过使用指定的种子来保证可复现性。\n\n- 测试用例 1（理想情况，行满秩，矩形矩阵）：\n  - $A \\in \\mathbb{R}^{4 \\times 7}$，其元素使用种子 $12345$ 从标准正态分布中独立抽取。\n  - 阈值参数 $\\tau = 10^{-12}$。\n  - 第一次预置换：恒等顺序 $\\{0,1,2,3,4,5,6\\}$。\n  - 第二次预置换：反向顺序 $\\{6,5,4,3,2,1,0\\}$。\n\n- 测试用例 2（接近秩亏，具有受控的奇异谱）：\n  - $A \\in \\mathbb{R}^{6 \\times 8}$，构建为 $A = U \\Sigma V^{\\top}$，其中 $U \\in \\mathbb{R}^{6 \\times 6}$ 和 $V \\in \\mathbb{R}^{8 \\times 8}$ 是通过对使用种子 $2024$ 生成的标准正态矩阵进行 QR 分解得到的正交矩阵，$\\Sigma \\in \\mathbb{R}^{6 \\times 8}$ 在其前 $6$ 个对角线元素上具有对角奇异值 $\\{1, 10^{-1}, 10^{-2}, 10^{-3}, 10^{-12}, 10^{-12}\\}$（其他位置为零）。\n  - 阈值参数 $\\tau = 10^{-8}$。\n  - 第一次预置换：恒等顺序 $\\{0,1,2,3,4,5,6,7\\}$。\n  - 第二次预置换：从种子 $4242$ 派生并应用于 $\\{0,\\ldots,7\\}$ 的随机置换。\n\n- 测试用例 3（等范数列以引发主元顺序敏感性）：\n  - $A \\in \\mathbb{R}^{5 \\times 9}$，其列被归一化为单位 $2$-范数。使用种子 $99$ 构建标准正态元素矩阵 $G \\in \\mathbb{R}^{5 \\times 9}$，并通过 $A[:,j] = G[:,j] / \\|G[:,j]\\|_2$ 定义 $A$ 的每个列索引 $j$。\n  - 阈值参数 $\\tau = 10^{-10}$。\n  - 第一次预置换：恒等顺序 $\\{0,1,2,3,4,5,6,7,8\\}$。\n  - 第二次预置换：反向顺序 $\\{8,7,6,5,4,3,2,1,0\\}$。\n\n- 测试用例 4（通过重复和相关列构造的结构性秩亏）：\n  - $A \\in \\mathbb{R}^{5 \\times 5}$ 构建如下：使用种子 $555$ 抽取标准正态元素矩阵 $B \\in \\mathbb{R}^{5 \\times 3}$，并设置 $A = [b_1, b_2, b_3, b_1 + b_2, b_2]$，其中 $b_1$, $b_2$, $b_3$ 是 $B$ 的列。\n  - 阈值参数 $\\tau = 10^{-12}$。\n  - 第一次预置换：恒等顺序 $\\{0,1,2,3,4\\}$。\n  - 第二次预置换：置换 $\\{2,1,0,4,3\\}$。\n\n角度单位要求：\n- 所有报告的角度必须以弧度表示。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含上述五个项目的列表，例如，$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$。", "solution": "该问题要求实现一种算法，利用实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的列主元 QR 分解来估计其零空间。同时，还必须分析此估计对列主元顺序的敏感性。整个过程需从第一性原理推导，即矩阵的秩、零空间、秩-零度定理和 QR 分解的定义。\n\n### 理论基础\n\n秩-零度定理指出，对于由矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 表示的任何线性映射，其定义域的维数（$n$）等于其秩与零空间（核）维数之和。形式上：\n$$ \\operatorname{rank}(A) + \\dim(\\ker(A)) = n $$\n零空间 $\\ker(A)$ 是所有被映射到零向量的向量 $x \\in \\mathbb{R}^{n}$ 的集合：$\\ker(A) = \\{x \\in \\mathbb{R}^{n} \\mid Ax = 0\\}$。我们的目标是找到这个向量子空间的一组基。\n\n一个矩阵 $A_{p} \\in \\mathbb{R}^{m \\times n}$ 的列主元 QR 分解提供了一个分解 $A_{p}P = QR$，其中 $P$ 是一个置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵（$Q^T Q = I$），$R \\in \\mathbb{R}^{m \\times n}$ 是一个上梯形矩阵。本问题涉及在进行此分解前对 $A$ 的列进行预设的预置换。设此预置换由置换矩阵 $P_{pre}$ 表示。我们首先构建矩阵 $A' = AP_{pre}$。然后，我们计算 $A'$ 的列主元 QR 分解，得到 $A'P_{qr} = QR$。将这些结合起来，我们得到：\n$$ (AP_{pre})P_{qr} = QR \\implies A(P_{pre}P_{qr}) = QR $$\n令 $P_{total} = P_{pre}P_{qr}$ 为总置换矩阵。寻找满足 $Ax=0$ 的 $x$ 的原始问题可以被变换。令 $x = P_{total}y$，其中 $y \\in \\mathbb{R}^n$ 是某个向量。将此代入零空间方程得到：\n$$ A(P_{total}y) = 0 \\implies (AP_{total})y = 0 \\implies QRy = 0 $$\n由于 $Q$ 是正交的，它是可逆的，我们可以从左侧乘以 $Q^T$：\n$$ Q^TQRy = Q^T0 \\implies Iy = 0 \\implies Ry = 0 $$\n因此，寻找 $A$ 的零空间等价于寻找 $R$ 的零空间，然后使用总置换 $P_{total}$ 将基向量映射回去。\n\n### 从 $R$ 构建零空间\n\n矩阵 $R$ 是上梯形的。由于列主元操作，对角元素 $|R_{ii}|$ 按非递增顺序排序，这有助于秩的估计。数值秩 $\\hat{r}$ 可以通过计算幅值大于某一阈值的对角元素的数量来估计。该阈值定义为 $\\delta = \\tau \\cdot \\max_i(|R_{ii}|)$，其中 $\\tau$ 是给定的容差参数。所有 $|R_{ii}| < \\delta$ 的元素被视为数值上为零。估计的秩 $\\hat{r}$ 是满足 $|R_{ii}| \\ge \\delta$ 的对角线条目的数量。因此，估计的零度为 $\\widehat{\\nu} = n - \\hat{r}$。\n\n为了找到 $\\ker(R)$ 的一组基，我们求解 $Ry=0$。我们根据估计的秩 $\\hat{r}$ 对矩阵 $R$ 和向量 $y$ 进行分块：\n$$ R = \\begin{pmatrix} R_{11}  R_{12} \\\\ 0  R_{22} \\end{pmatrix}, \\quad y = \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} $$\n这里，$R_{11} \\in \\mathbb{R}^{\\hat{r} \\times \\hat{r}}$ 是一个对角线元素非零的上三角矩阵（根据 $\\hat{r}$ 的定义），因此是可逆的。$R_{12} \\in \\mathbb{R}^{\\hat{r} \\times \\widehat{\\nu}}$，而 $R_{22} \\in \\mathbb{R}^{(m-\\hat{r}) \\times \\widehat{\\nu}}$ 是一个其所有元素在数值上都很小的矩阵。向量 $y$ 被分块为 $y_1 \\in \\mathbb{R}^{\\hat{r}}$ 和 $y_2 \\in \\mathbb{R}^{\\widehat{\\nu}}$。\n\n方程 $Ry=0$ 展开为：\n$$ R_{11}y_1 + R_{12}y_2 = 0 $$\n$$ R_{22}y_2 = 0 $$\n将 $R_{22}$ 近似为零矩阵，第二个方程对于 $y_2$ 的任何选择都成立。这证实了零空间的维数确实是 $\\widehat{\\nu}$。为了构建一组基，我们可以为 $y_2$ 选择 $\\widehat{\\nu}$ 个线性无关的向量。标准的选择是单位矩阵 $I_{\\widehat{\\nu}} \\in \\mathbb{R}^{\\widehat{\\nu} \\times \\widehat{\\nu}}$ 的列向量集合。\n\n对于为 $y_2$ 选择的每个基向量 $e_k$，我们从第一个方程中求解相应的 $y_1$：\n$$ R_{11}y_1 = -R_{12}y_2 $$\n由于 $R_{11}$ 是可逆的，我们对 $y_1$ 有唯一解：\n$$ y_1 = -R_{11}^{-1}R_{12}y_2 $$\n这个系统可以通过求解矩阵方程 $R_{11}X = -R_{12}$ 来一次性高效地为 $y_2$ 的所有 $\\widehat{\\nu}$ 个基向量求解，其中 $X \\in \\mathbb{R}^{\\hat{r} \\times \\widehat{\\nu}}$ 的列将对应于零空间基向量的 $y_1$ 部分。这是一个可以通过回代法求解的三角系统。\n\n$\\ker(R)$ 的结果基由矩阵 $Z \\in \\mathbb{R}^{n \\times \\widehat{\\nu}}$ 的列表示：\n$$ Z = \\begin{pmatrix} X \\\\ I_{\\widehat{\\nu}} \\end{pmatrix} = \\begin{pmatrix} -R_{11}^{-1} R_{12} \\\\ I_{\\widehat{\\nu}} \\end{pmatrix} $$\n$Z$ 的列是向量 $y^{(k)}$。为了获得 $\\ker(A)$ 的基，我们必须应用置换 $P_{total}$。$\\ker(A)$ 的基向量是 $N = P_{total}Z$ 的列。如果 $p_{total}$ 是代表置换 $P_{total}$ 的整数向量，这个操作会重新排列 $Z$ 的行：$N[p_{total}, :] = Z$。\n\n### 基的标准正交化与比较\n\n构建的基 $N$ 不保证是标准正交的。为了进行稳健的数值比较，最好将其转换为一个张成相同子空间的标准正交基。这可以通过对 $N$ 本身进行 QR 分解来实现，$N = \\tilde{N}R_N$。$\\tilde{N}$ 的列构成了所期望的标准正交基。\n\n为了分析对主元顺序的敏感性，我们使用两种不同的初始列预置换生成两个不同的零空间基 $\\tilde{N}_1$ 和 $\\tilde{N}_2$。我们通过以下方式比较它们：\n1.  **零度一致性**：一个布尔检查，判断估计的零度 $\\widehat{\\nu}_1$ 和 $\\widehat{\\nu}_2$ 是否相等。\n2.  **最大主角**：由 $\\tilde{N}_1$ 和 $\\tilde{N}_2$ 张成的子空间之间的主角 $\\{\\theta_k\\}$ 量化了它们的几何对齐程度。这些角度的余弦是矩阵 $\\tilde{N}_1^T \\tilde{N}_2$ 的奇异值。最大主角 $\\max_k \\theta_k$ 表示两个子空间之间的最大偏差。这可以使用 `scipy.linalg.subspace_angles` 高效计算。\n\n### 算法实现\n\n每个测试用例的总体算法如下：\n1.  对于两个预设的预置换中的每一个：\n    a. 置换输入矩阵 $A$ 的列。\n    b. 对置换后的矩阵执行列主元QR分解，以获得 $Q$、$R$ 和一个额外的的主元顺序。\n    c. 结合预置换和QR主元顺序以获得总置换。\n    d. 使用指定的容差 $\\tau$ 从 $R$ 的对角线估计秩 $\\hat{r}$ 和零度 $\\widehat{\\nu}$。\n    e. 如果 $\\widehat{\\nu} > 0$，则如上所述为 $A$ 的零空间构建基 $N$。这涉及用 $R_{11}$ 求解一个三角系统，并将基向量置换回原始顺序。\n    f. 将基 $N$ 标准正交化以得到 $\\tilde{N}$。\n2.  报告第一次运行的秩 $\\hat{r}_1$ 和零度 $\\widehat{\\nu}_1$。\n3.  计算残差的 Frobenius 范数 $\\|A\\tilde{N}_1\\|_F$，以评估第一个估计基的质量。\n4.  计算由 $\\tilde{N}_1$ 和 $\\tilde{N}_2$ 张成的子空间之间的最大主角。\n5.  报告一个布尔值，指示 $\\widehat{\\nu}_1 = \\widehat{\\nu}_2$ 是否成立。\n这些五个结果将按规定为每个测试用例收集。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def analyze_null_space(A, tau, pre_permutation):\n        \"\"\"\n        Analyzes a matrix A to find its null space basis using QR factorization.\n\n        Args:\n            A (np.ndarray): The input matrix.\n            tau (float): The threshold parameter for rank estimation.\n            pre_permutation (np.ndarray): The initial column permutation indices.\n\n        Returns:\n            tuple: A tuple containing:\n                - est_rank (int): Estimated numerical rank.\n                - est_nullity (int): Estimated numerical nullity.\n                - ortho_null_basis (np.ndarray): Orthonormal basis for the null space.\n                - total_perm_indices (np.ndarray): Total permutation indices.\n        \"\"\"\n        m, n = A.shape\n        if n == 0:\n            return 0, 0, np.empty((0, 0)), np.array([], dtype=int)\n\n        A_perm = A[:, pre_permutation]\n        Q, R, qr_pivot_indices = linalg.qr(A_perm, pivoting=True)\n\n        k = min(m, n)\n        diag_R = np.abs(np.diag(R[:k, :k]))\n        \n        # Handle case where diag_R is empty\n        if diag_R.size == 0:\n            max_r_diag = 0.0\n        else:\n            max_r_diag = np.max(diag_R)\n\n        # To avoid threshold being 0 if max_r_diag is 0\n        if max_r_diag > 0:\n            threshold = tau * max_r_diag\n        else:\n            threshold = tau\n            \n        est_rank = np.sum(diag_R > threshold)\n        est_nullity = n - est_rank\n\n        total_perm_indices = pre_permutation[qr_pivot_indices]\n\n        if est_nullity == 0:\n            return est_rank, est_nullity, np.empty((n, 0)), total_perm_indices\n\n        # Partition R\n        # R is (m,n), we need its upper-left (r x n) part for computation\n        R_rank_part = R[:est_rank, :]\n        R11 = R_rank_part[:, :est_rank]\n        R12 = R_rank_part[:, est_rank:]\n\n        # Solve R11 * X = -R12 using back-substitution\n        X = linalg.solve_triangular(R11, -R12, lower=False)\n\n        # Construct the basis for ker(R) in the permuted space\n        Z = np.vstack((X, np.eye(est_nullity)))\n        \n        # Apply inverse of total permutation to get basis for ker(A)\n        null_basis = np.zeros_like(Z)\n        null_basis[total_perm_indices] = Z\n        \n        # Orthonormalize the basis for stability in angle calculations\n        if null_basis.shape[1] > 0:\n            ortho_null_basis, _ = np.linalg.qr(null_basis)\n        else:\n            ortho_null_basis = np.empty((n, 0))\n\n\n        return est_rank, est_nullity, ortho_null_basis, total_perm_indices\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"name\": \"Full row rank, rectangular\",\n            \"seed\": 12345,\n            \"shape\": (4, 7),\n            \"tau\": 1e-12,\n            \"perm1\": np.arange(7),\n            \"perm2\": np.arange(7)[::-1],\n            \"builder\": lambda shape, seed: np.random.default_rng(seed).standard_normal(shape)\n        },\n        # Case 2: Near rank-deficient\n        {\n            \"name\": \"Near rank-deficient\",\n            \"seed\": 2024,\n            \"shape\": (6, 8),\n            \"tau\": 1e-8,\n            \"perm1\": np.arange(8),\n            \"perm2\": np.random.default_rng(4242).permutation(8),\n            \"builder\": lambda shape, seed: A_tc2 # This is precomputed below\n        },\n        # Case 3: Equal-norm columns\n        {\n            \"name\": \"Equal-norm columns\",\n            \"seed\": 99,\n            \"shape\": (5, 9),\n            \"tau\": 1e-10,\n            \"perm1\": np.arange(9),\n            \"perm2\": np.arange(9)[::-1],\n            \"builder\": lambda shape, seed: (\n                lambda G: G / np.linalg.norm(G, axis=0)\n            )(np.random.default_rng(seed).standard_normal(shape))\n        },\n        # Case 4: Structured deficiency\n        {\n            \"name\": \"Structured deficiency\",\n            \"seed\": 555,\n            \"shape\": (5, 5),\n            \"tau\": 1e-12,\n            \"perm1\": np.arange(5),\n            \"perm2\": np.array([2, 1, 0, 4, 3]),\n            \"builder\": lambda shape, seed: (\n                lambda B: np.column_stack((B[:, 0], B[:, 1], B[:, 2], B[:, 0] + B[:, 1], B[:, 1]))\n            )(np.random.default_rng(seed).standard_normal((5, 3)))\n        }\n    ]\n\n    # Special handling for test case 2 builder\n    rng_u_v = np.random.default_rng(2024)\n    U_tc2, _ = linalg.qr(rng_u_v.standard_normal((6, 6)))\n    V_tc2, _ = linalg.qr(rng_u_v.standard_normal((8, 8)))\n    S_tc2 = np.zeros((6, 8))\n    s_vals = [1, 1e-1, 1e-2, 1e-3, 1e-12, 1e-12]\n    np.fill_diagonal(S_tc2, s_vals)\n    A_tc2 = U_tc2 @ S_tc2 @ V_tc2.T\n\n\n    results = []\n    for case in test_cases:\n        A = case[\"builder\"](case[\"shape\"], case[\"seed\"])\n        tau = case[\"tau\"]\n        perm1 = case[\"perm1\"]\n        perm2 = case[\"perm2\"]\n        m, n = A.shape\n\n        r1, nu1, N1, _ = analyze_null_space(A, tau, perm1)\n        r2, nu2, N2, _ = analyze_null_space(A, tau, perm2)\n\n        # Calculate Frobenius norm of the residual\n        if nu1 > 0:\n            fro_norm = np.linalg.norm(A @ N1, 'fro')\n        else:\n            fro_norm = 0.0\n\n        # Calculate max principal angle\n        # Only meaningful if both subspaces are non-trivial\n        if nu1 > 0 and nu2 > 0:\n            # subspace_angles returns angles sorted, max is the last one.\n            angles = linalg.subspace_angles(N1, N2)\n            max_angle = angles[-1] if angles.size > 0 else 0.0\n        else:\n            max_angle = 0.0\n\n        # Check for nullity agreement\n        nullity_agrees = (nu1 == nu2)\n\n        results.append([r1, nu1, fro_norm, max_angle, nullity_agrees])\n    \n    # Custom formatting to match the sample output exactly.\n    final_output_str = \"[\"\n    for i, res_list in enumerate(results):\n        final_output_str += \"[\"\n        final_output_str += f\"{res_list[0]},\"\n        final_output_str += f\"{res_list[1]},\"\n        final_output_str += f\"{res_list[2]:.15e},\"\n        final_output_str += f\"{res_list[3]:.15e},\"\n        final_output_str += f\"{str(res_list[4]).lower()}\"\n        final_output_str += \"]\"\n        if i  len(results) - 1:\n            final_output_str += \",\"\n    final_output_str += \"]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3558928"}, {"introduction": "虽然矩阵的秩是一个确定的理论值，但在数值计算中对其进行估计却可能充满挑战，特别是对于结构特殊的矩阵。本练习首先要求你证明一个基本性质：用正交矩阵进行左乘不会改变原矩阵的秩。接着，你将通过一个计算实验来验证一个假设：这种正交变换通过“混合”矩阵的行信息，可以帮助一个简单的秩估计算法在原本会失败的情况下获得正确结果。[@problem_id:3558929] 这项实践将理论证明与实用的预处理技术联系起来，展示了理论如何指导我们设计更稳健的数值方法。", "problem": "考虑一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$，其中正交矩阵定义为 $Q^{\\top} Q = I_m$。零空间 $\\mathcal{N}(A)$ 定义为 $\\{ x \\in \\mathbb{R}^n : A x = 0 \\}$，矩阵 $A$ 的秩是 $A$ 的列空间的维度。秩-零度定理指出，对于任何由矩阵 $A$ 表示的线性映射 $T : \\mathbb{R}^n \\to \\mathbb{R}^m$，都有 $\\mathrm{rank}(A) + \\mathrm{nullity}(A) = n$。\n\n你的任务是：\n\n- 从第一性原理出发（仅使用核心定义和广为接受的事实）证明：对于任何正交矩阵 $Q$，零空间在被 $Q$ 左乘后保持不变，即 $\\mathcal{N}(A) = \\mathcal{N}(Q A)$。并由此推导出，$A$ 的零度和秩在被 $Q$ 左乘后保持不变。\n\n- 设计一个计算实验，以测试当使用一个特意设计的避免主元的算法时，随机正交前乘（用一个随机正交矩阵 $Q$ 左乘）是否能改善实际的数值秩检测效果。使用一种无主元高斯消去启发式算法来估计数值秩：在步骤 $k$（从 $k=0$ 开始），如果对角线元素 $A_{k,k}$ 满足 $|A_{k,k}|  \\tau$，则将其视为主元，并在该主元下方执行消去操作，不进行任何行或列主元交换；将接受的主元数量作为估计的秩。容差 $\\tau$ 是一个固定的正阈值。\n\n- 实现以下具有受控低秩结构和结构化行突发噪声的矩阵测试套件。对于每个测试用例，将 $A$ 构建为 $A_0 + E$ 的和，其中 $A_0$ 的精确秩为 $r$，其构造方式是在左下角 $r$ 行和 $r$ 列处放置一个单位块：\n  $$\n  (A_0)_{m-r+i,\\, i} = 1 \\quad \\text{for} \\quad i=0,1,\\dots,r-1,\n  $$\n  且其他位置为零。噪声 $E$ 仅添加到 $K$ 个随机选择的行上；在每个被选中的行上，为每个条目添加方差为 $\\sigma^2$ 的独立同分布高斯噪声。\n\n- 对于每个测试用例，生成一个随机正交矩阵 $Q$（例如，通过计算一个稠密高斯矩阵的 QR 分解中的正交因子）。使用指定的无主元消去法，对 $A$ 和 $Q A$ 估计秩，两者使用相同的容差 $\\tau$。将每个测试用例的改进度量定义为一个整数：\n  $$\n  \\mathrm{improve} =\n  \\begin{cases}\n    1  \\text{如果左乘后的估计值等于真实秩 } r \\text{ 而左乘前的估计值不等于, } \\\\\n    -1 \\text{如果左乘前的估计值等于 } r \\text{ 而左乘后的估计值不等于, } \\\\\n    0  \\text{其他情况。}\n  \\end{cases}\n  $$\n  真实零度为 $n - r$。测试套件如下：\n\n  - 测试用例 1：$m=50$, $n=40$, $r=30$, $K=3$, $\\sigma=10^{-6}$, $\\tau=10^{-3}$, 随机种子 $123$。\n  - 测试用例 2：$m=40$, $n=50$, $r=30$, $K=3$, $\\sigma=10^{-6}$, $\\tau=10^{-3}$, 随机种子 $234$。\n  - 测试用例 3：$m=60$, $n=60$, $r=60$, $K=4$, $\\sigma=10^{-6}$, $\\tau=10^{-3}$, 随机种子 $345$。\n  - 测试用例 4：$m=80$, $n=20$, $r=18$, $K=2$, $\\sigma=10^{-6}$, $\\tau=10^{-3}$, 随机种子 $456$。\n\n你的程序应生成单行输出，其中包含四个测试用例的改进值，格式为方括号内以逗号分隔的列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个如上定义的整数，取值于 $\\{-1,0,1\\}$。程序必须是自包含的，使用指定的库，并且不接受任何输入。", "solution": "该问题提出了一个理论证明，并附带一个关于矩阵的秩及其在正交变换下行为的计算实验。将按要求分两部分进行验证和求解。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$。\n- 一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$，定义为 $Q^{\\top} Q = I_m$。\n- 零空间定义：$\\mathcal{N}(A) = \\{ x \\in \\mathbb{R}^n : A x = 0 \\}$。\n- 秩的定义：$A$ 的列空间的维度。\n- 秩-零度定理：$\\mathrm{rank}(A) + \\mathrm{nullity}(A) = n$。\n- 理论任务：证明 $\\mathcal{N}(A) = \\mathcal{N}(Q A)$ 并推导出 $\\mathrm{nullity}(A) = \\mathrm{nullity}(QA)$ 和 $\\mathrm{rank}(A) = \\mathrm{rank}(QA)$。\n- 计算任务：设计并实现一个实验，以测试随机正交前乘对特定数值秩估计算法的影响。\n- 秩估计算法：一种无主元高斯消去启发式算法。如果在步骤 $k$ 的对角线元素满足 $|A_{k,k}|  \\tau$，则计为一个主元。在主元下方进行消去。估计的秩是此类主元的总数。不执行行或列交换。\n- 实验中的矩阵构造：$A = A_0 + E$。\n  - $A_0$ 是一个精确秩为 $r$ 的矩阵，其 $(A_0)_{m-r+i, i} = 1$ 对 $i=0, 1, \\dots, r-1$ 成立，其他位置为零。\n  - $E$ 是一个噪声矩阵，其中 $K$ 个随机选择的行包含均值为 $0$、方差为 $\\sigma^2$ 的独立同分布高斯噪声。\n- 改进度量：一个整数，如果对 $QA$ 的估计正确（等于 $r$）而对 $A$ 的估计不正确，则为 $1$；如果对 $A$ 的估计正确而对 $QA$ 的估计不正确，则为 $-1$；否则为 $0$。\n- 测试用例：\n  1. $m=50, n=40, r=30, K=3, \\sigma=10^{-6}, \\tau=10^{-3}$, 随机种子 $123$。\n  2. $m=40, n=50, r=30, K=3, \\sigma=10^{-6}, \\tau=10^{-3}$, 随机种子 $234$。\n  3. $m=60, n=60, r=60, K=4, \\sigma=10^{-6}, \\tau=10^{-3}$, 随机种子 $345$。\n  4. $m=80, n=20, r=18, K=2, \\sigma=10^{-6}, \\tau=10^{-3}$, 随机种子 $456$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题坚实地植根于线性代数（秩、零空间、正交矩阵）和数值线性代数（秩确定、数值稳定性、预处理）的基本原理中。所用概念均为标准且科学上合理的。\n- **良定性**：所要求的理论证明是一个标准结果。计算实验被精确定义，所有参数、矩阵结构、算法和评估指标都已明确指定。使用随机种子确保了计算实验具有唯一的、可复现的结果。\n- **客观性**：语言精确且数学化，没有任何主观或基于观点的断言。\n\n该问题没有表现出任何科学上不合理、模糊不清、信息缺失或矛盾等缺陷。测试矩阵 $A_0$ 的构造是一个经过深思熟虑的精巧选择，它创造了一个场景，使得朴素的秩估计算法注定会失败，从而使对改进效果的测试变得有意义。这是一个良定且内容充实的问题。\n\n**步骤 3：结论与行动**\n问题是有效的。将提供完整的解决方案。\n\n### 求解\n\n**第一部分：理论证明**\n\n我们的任务是证明对于一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$，其零空间在被 $Q$ 左乘后保持不变，即 $\\mathcal{N}(A) = \\mathcal{N}(Q A)$。我们将通过证明相互包含关系来完成此证明。\n\n1.  **证明 $\\mathcal{N}(A) \\subseteq \\mathcal{N}(Q A)$**：\n    令 $x$ 为 $A$ 的零空间中的任意向量，即 $x \\in \\mathcal{N}(A)$。根据定义，这意味着：\n    $$A x = 0$$\n    其中 $0$ 是 $\\mathbb{R}^m$ 中的零向量。用矩阵 $Q$ 左乘此方程，我们得到：\n    $$Q (A x) = Q 0$$\n    利用矩阵乘法的结合律，我们有：\n    $$(Q A) x = 0$$\n    此方程表明向量 $x$ 位于矩阵 $QA$ 的零空间中。因此，$x \\in \\mathcal{N}(Q A)$。由于 $x$ 是 $\\mathcal{N}(A)$ 的任意元素，我们得出结论 $\\mathcal{N}(A) \\subseteq \\mathcal{N}(Q A)$。\n\n2.  **证明 $\\mathcal{N}(Q A) \\subseteq \\mathcal{N}(A)$**：\n    令 $y$ 为 $QA$ 的零空间中的任意向量，即 $y \\in \\mathcal{N}(Q A)$。根据定义：\n    $$(Q A) y = 0$$\n    给定矩阵 $Q$ 是正交的，这意味着 $Q^{\\top} Q = I_m$，其中 $I_m$ 是 $m \\times m$ 的单位矩阵。此性质意味着 $Q$ 是可逆的，且其逆是其转置，即 $Q^{-1} = Q^{\\top}$。用 $Q^{\\top}$ 左乘该方程，我们得到：\n    $$Q^{\\top} (Q A) y = Q^{\\top} 0$$\n    再次利用矩阵乘法的结合律：\n    $$(Q^{\\top} Q) A y = 0$$\n    代入 $Q^{\\top} Q = I_m$：\n    $$I_m A y = 0$$\n    $$A y = 0$$\n    此方程表明向量 $y$ 位于矩阵 $A$ 的零空间中。因此，$y \\in \\mathcal{N}(A)$。由于 $y$ 是 $\\mathcal{N}(Q A)$ 的任意元素，我们得出结论 $\\mathcal{N}(Q A) \\subseteq \\mathcal{N}(A)$。\n\n结合两个包含关系，我们证明了这两个集合是相同的：\n$$\\mathcal{N}(A) = \\mathcal{N}(Q A)$$\n\n**对零度和秩的影响**\n\n-   **零度**：矩阵的零度定义为其零空间的维度，即 $\\mathrm{nullity}(M) = \\dim(\\mathcal{N}(M))$。既然我们已经证明 $\\mathcal{N}(A) = \\mathcal{N}(Q A)$，它们的维度必然相等。因此：\n    $$\\mathrm{nullity}(A) = \\dim(\\mathcal{N}(A)) = \\dim(\\mathcal{N}(Q A)) = \\mathrm{nullity}(Q A)$$\n    零度在被正交矩阵左乘后保持不变。\n\n-   **秩**：秩-零度定理指出，对于任何矩阵 $M \\in \\mathbb{R}^{m \\times n}$，其秩与零度之和等于列数 $n$：\n    $$\\mathrm{rank}(M) + \\mathrm{nullity}(M) = n$$\n    将此定理应用于矩阵 $A$：\n    $$\\mathrm{rank}(A) = n - \\mathrm{nullity}(A)$$\n    将其应用于矩阵 $QA$：\n    $$\\mathrm{rank}(Q A) = n - \\mathrm{nullity}(Q A)$$\n    由于我们刚刚证明了 $\\mathrm{nullity}(A) = \\mathrm{nullity}(Q A)$，可以直接得出：\n    $$\\mathrm{rank}(A) = \\mathrm{rank}(Q A)$$\n    秩在被正交矩阵左乘后也保持不变。这便完成了理论证明。\n\n**第二部分：计算实验设计与实现**\n\n该实验旨在展示这一理论结果的一个实际应用方面。虽然 $\\mathrm{rank}(A)$ 和 $\\mathrm{rank}(QA)$ 在理论上是相同的，但它们的数值估计可能会因算法和矩阵结构的不同而显著差异。\n\n所选择的秩估计算法——一种无主元高斯消去法——是故意设计得非常朴素的。其成功完全依赖于在主对角线上找到足够大的元素。矩阵 $A$ 被构造为 $A_0 + E$。基矩阵 $A_0$ 的唯一非零项（全部为1）位于左下角，具体在位置 $(m-r+i, i)$，其中 $i \\in \\{0, \\dots, r-1\\}$。这确保了 $A_0$ 的前 $\\min(m, n, r)$ 个对角线元素全为零。增加的噪声 $E$ 的量级很小（$\\sigma=10^{-6}$），因此它本身不太可能产生大于容差 $\\tau=10^{-3}$ 的对角线元素。因此，预期这个朴素算法在处理矩阵 $A$ 时会失败，估计出的秩会远低于真实秩 $r$。\n\n用一个随机正交矩阵 $Q$ 左乘 $A$，实际上是对 $A$ 的行进行了一次随机的旋转/反射。这种加扰操作混合了各行，将 $A_0$ 左下角的大数值分布到 $QA$ 的许多行中。这很可能会在 $QA$ 的对角线上产生大数值的元素，从而使朴素算法能够正确识别主元，并估计出秩为 $r$。\n\n实现将遵循这一逻辑，执行四个指定的测试用例，并为每个用例计算改进度量。如果随机前乘“修复”了秩估计，则度量为 $1$；如果它“破坏”了估计，则为 $-1$；否则为 $0$。鉴于此设置，我们预期在大多数（如果不是全部）初始结构导致算法失效的情况下，改进值将为 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Executes the computational experiment to test the effect of orthogonal\n    premultiplication on a naive rank estimation algorithm.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    # Format: (m, n, r, K, sigma, tau, random_seed)\n    test_cases = [\n        (50, 40, 30, 3, 1e-6, 1e-3, 123),\n        (40, 50, 30, 3, 1e-6, 1e-3, 234),\n        (60, 60, 60, 4, 1e-6, 1e-3, 345),\n        (80, 20, 18, 2, 1e-6, 1e-3, 456),\n    ]\n\n    results = []\n\n    def estimate_rank_naive(matrix, tolerance):\n        \"\"\"\n        Estimates the rank of a matrix using a pivot-free Gaussian elimination\n        heuristic. The rank is the number of diagonal pivots with magnitude\n        greater than the tolerance. No pivoting is performed.\n        \"\"\"\n        M = matrix.copy()\n        m, n = M.shape\n        num_pivots = 0\n        max_pivots = min(m, n)\n        \n        for k in range(max_pivots):\n            # Check if the diagonal element can be accepted as a pivot\n            if np.abs(M[k, k]) > tolerance:\n                num_pivots += 1\n                pivot_val = M[k, k]\n                # Perform elimination on the rows below the pivot\n                for i in range(k + 1, m):\n                    if pivot_val != 0:\n                        factor = M[i, k] / pivot_val\n                        M[i, k:] -= factor * M[k, k:]\n        return num_pivots\n\n    for m, n, r, K, sigma, tau, seed in test_cases:\n        # Initialize the random number generator for reproducibility of the case\n        rng = np.random.default_rng(seed)\n\n        # 1. Construct the matrix A = A0 + E\n        # A0 has rank r with an identity block in the bottom-left\n        A0 = np.zeros((m, n))\n        if r > 0 and r = m and r = n:\n            row_indices = np.arange(m - r, m)\n            col_indices = np.arange(r)\n            A0[row_indices, col_indices] = 1.0\n\n        # E is zero except for K randomly chosen rows with Gaussian noise\n        E = np.zeros((m, n))\n        if K > 0:\n            noise_row_indices = rng.choice(m, size=K, replace=False)\n            for row_idx in noise_row_indices:\n                E[row_idx, :] = rng.normal(loc=0.0, scale=sigma, size=n)\n\n        A = A0 + E\n\n        # 2. Generate a random orthogonal matrix Q of size m x m\n        # A standard method is to take the Q factor of a random Gaussian matrix's QR decomposition.\n        Z = rng.standard_normal((m, m))\n        Q, _ = qr(Z)\n\n        # 3. Estimate rank of A and QA\n        rank_A_est = estimate_rank_naive(A, tau)\n        \n        QA = Q @ A\n        rank_QA_est = estimate_rank_naive(QA, tau)\n\n        # 4. Calculate the improvement metric\n        est_A_correct = (rank_A_est == r)\n        est_QA_correct = (rank_QA_est == r)\n        \n        improvement = 0\n        if est_QA_correct and not est_A_correct:\n            improvement = 1\n        elif est_A_correct and not est_QA_correct:\n            improvement = -1\n        \n        results.append(improvement)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3558929"}, {"introduction": "在许多高级应用中，尤其是在迭代法领域，Krylov子空间扮演着核心角色，而其维度直接关联到对应Krylov矩阵的秩。然而，一个数值上秩亏的Krylov矩阵可能源于真实的线性相关性，也可能仅仅是因为矩阵接近亏损（defective）而导致的“缓慢增长”。本练习将引导你设计一个基于奇异值分解（SVD）的诊断工具，通过分析数值秩在微小扰动下的稳定性，来区分这两种情况。[@problem_id:3558881] 这个高级实践展示了如何运用秩的概念来诊断与矩阵幂相关的复杂问题，并理解其数值稳定性。", "problem": "令 $A \\in \\mathbb{R}^{n \\times n}$ 且 $b \\in \\mathbb{R}^n$。定义由 $A$ 和 $b$ 生成的 $k$ 步克雷洛夫子空间为 $\\mathcal{K}_k(A,b) = \\mathrm{span}\\{b, Ab, A^2 b, \\dots, A^{k-1} b\\}$。考虑通过将克雷洛夫向量作为列拼接而成的 $n \\times n$ 方阵克雷洛夫矩阵 $K_n(A,b) = [b, Ab, \\dots, A^{n-1} b]$。\n\n从核心定义和公认事实出发，推导克雷洛夫子空间的维度与克雷洛夫矩阵的秩之间的精确关系。然后，设计并实现一个数值诊断程序，该程序：(i) 通过奇异值分解（SVD; Singular Value Decomposition）计算 $K_n(A,b)$ 的数值秩来估计克雷洛夫子空间的维度，以及 (ii) 区分由克雷洛夫列之间的精确线性相关性导致的真实秩亏，与由亏损或接近亏损的矩阵 $A$ 引起的近似相关性导致的克雷洛夫增长缓慢。\n\n使用以下内容作为基本依据：\n- 矩阵的秩、零空间和列空间的定义。\n- 适用于线性映射 $T : \\mathbb{R}^n \\to \\mathbb{R}^n$ 的秩-零度定理，即 $\\mathrm{rank}(T) + \\mathrm{nullity}(T) = n$。\n- 奇异值分解（SVD），它通过最小奇异值来刻画欧几里得算子范数以及矩阵到秩亏矩阵集合的距离。\n\n您的程序必须：\n1. 构造 $K_n(A,b)$。\n2. 使用准则 $r = \\#\\{ \\sigma_i : \\sigma_i  \\tau \\}$ 估计 $K_n(A,b)$ 的数值秩 $r$，其中 $\\sigma_i$ 是 $K_n(A,b)$ 的奇异值，$\\tau = n \\cdot \\epsilon \\cdot \\|K_n(A,b)\\|_2$，$\\epsilon$ 是双精度浮点数的机器精度。\n3. 计算最小奇异值 $\\sigma_{\\min}(K_n(A,b))$。\n4. 实现一个基于稳定性的诊断程序，将观察到的低秩分类为真实亏秩或缓慢增长。该诊断程序必须执行以下操作：\n   - 使用阈值 $\\tau_0 = n \\cdot \\epsilon \\cdot \\|K_n(A,b)\\|_2$ 计算基准秩 $r_0$。\n   - 在集合 $\\{\\tau_0/10, \\tau_0, 10\\tau_0\\}$ 中改变阈值并重新计算秩。\n   - 对 $A$ 和 $b$ 分别施加大小为 $\\delta_A = 10^{-12} \\cdot \\max\\{1, \\|A\\|_2\\}$ 和 $\\delta_b = 10^{-12} \\cdot \\max\\{1, \\|b\\|_2\\}$ 的、经过范数缩放的小扰动，并对每个扰动情况 $(A,b)$、$(A,b+\\Delta b)$、$(A+\\Delta A, b)$ 和 $(A+\\Delta A, b+\\Delta b)$，在相同的三个阈值下重新计算秩。其中扰动 $\\Delta A$ 和 $\\Delta b$ 是使用固定的随机种子生成的，以保证可复现性。\n   - 将稳定性得分 $s$ 定义为所有重新计算的秩中等于 $r_0$ 的比例。如果 $r_0  n$ 且 $s \\geq 0.9$，则分类为“真实亏秩”，否则分类为“缓慢增长或无亏秩”。\n\n从定义和秩-零度定理出发，证明 $\\dim \\mathcal{K}_n(A,b)$ 与 $\\mathrm{rank}(K_n(A,b))$ 之间的关系，并基于 SVD 性质和扰动稳定性来论证数值诊断程序的设计。\n\n您必须将上述内容实现为一个完整的、可运行的程序。不允许用户输入。\n\n测试套件：\n- 案例 1（对角矩阵 $A$ 的结构性亏秩）：$n=6$, $A = \\mathrm{diag}(1,2,3,4,5,6)$, $b = [1, 1, 0, 0, 0, 0]^\\top$。\n- 案例 2（具有单个若尔当块的亏损矩阵 $A$，缓慢增长）：$n=6$, $A = J_6(1)$，其中 $J_6(1)$ 的主对角线和超对角线元素为1，其余为0；$b = e_6$。\n- 案例 3（接近亏损，谱集簇，满秩但病态）：$n=6$, $A = \\mathrm{diag}(1, 1+10^{-12}, 1+2\\cdot 10^{-12}, 1+3\\cdot 10^{-12}, 1+4\\cdot 10^{-12}, 1+5\\cdot 10^{-12}) + U$，其中 $U$ 是严格上双对角矩阵，其超对角线上元素为 $10^{-12}$；$b$ 是一个固定的随机向量，其分量从标准正态分布中抽取，然后使用固定种子缩放到单位范数。\n- 案例 4（边界情况）：$n=6$, $A = \\mathrm{diag}(1,2,3,4,5,6)$, $b = 0$。\n\n答案规格：\n- 对于每个案例，输出一个列表 $[r, \\sigma_{\\min}, f]$，其中 $r$ 是估计的数值秩（一个整数），$\\sigma_{\\min}$ 是 $K_n(A,b)$ 的最小奇异值（一个浮点数），$f$ 是分类标志（一个整数，1表示“真实亏秩”，0表示“缓慢增长或无亏秩”）。\n- 您的程序应生成单行输出，其中包含四个案例的结果，按顺序以逗号分隔的列表形式封装在方括号中。例如，格式必须是 $[[r_1,\\sigma_{\\min,1},f_1],[r_2,\\sigma_{\\min,2},f_2],[r_3,\\sigma_{\\min,3},f_3],[r_4,\\sigma_{\\min,4},f_4]]$。\n- 不涉及任何物理单位或角度；所有量均为纯数。", "solution": "该问题被评估为有效。它在数值线性代数方面有科学依据，问题陈述清晰，目标明确，过程确定，表达规范。它在克雷洛夫子空间的背景下，对区分真实秩亏和数值病态提出了一个不小的挑战。\n\n### 理论推导\n\n该问题要求基于基本定义，推导克雷洛夫子空间 $\\mathcal{K}_n(A,b)$ 的维度与克雷洛夫矩阵 $K_n(A,b)$ 的秩之间的精确关系。\n\n令 $A \\in \\mathbb{R}^{n \\times n}$ 且 $b \\in \\mathbb{R}^n$。\n克雷洛夫子空间定义为前 $n$ 个克雷洛夫向量的生成空间：\n$$\n\\mathcal{K}_n(A,b) = \\mathrm{span}\\{b, Ab, A^2 b, \\dots, A^{n-1} b\\}\n$$\n该子空间的维度 $\\dim(\\mathcal{K}_n(A,b))$ 是生成向量集合 $\\{b, Ab, \\dots, A^{n-1} b\\}$ 中最大线性无关子集的大小。\n\n克雷洛夫矩阵是通过将这些向量作为列拼接而成的：\n$$\nK_n(A,b) = [b | Ab | A^2 b | \\dots | A^{n-1} b]\n$$\n矩阵的列空间是由其列向量生成的子空间。根据定义，$K_n(A,b)$ 的列空间（记为 $\\mathrm{col}(K_n(A,b))$）是：\n$$\n\\mathrm{col}(K_n(A,b)) = \\mathrm{span}\\{b, Ab, A^2 b, \\dots, A^{n-1} b\\}\n$$\n通过直接比较它们的定义，克雷洛夫子空间和克雷洛夫矩阵的列空间是相同的：\n$$\n\\mathcal{K}_n(A,b) = \\mathrm{col}(K_n(A,b))\n$$\n矩阵的秩定义为其列空间的维度。即：\n$$\n\\mathrm{rank}(K_n(A,b)) = \\dim(\\mathrm{col}(K_n(A,b)))\n$$\n结合这两个等式，得到直接关系：\n$$\n\\dim(\\mathcal{K}_n(A,b)) = \\mathrm{rank}(K_n(A,b))\n$$\n这就确定了子空间的维度恰好是其列生成该子空间的矩阵的秩。秩-零度定理 $\\mathrm{rank}(T) + \\mathrm{nullity}(T) = n$ 适用于由矩阵 $K_n(A,b)$ 表示的线性映射 $T_K: \\mathbb{R}^n \\to \\mathbb{R}^n$。该映射的秩是其像（即列空间）的维度。零度是其核（或零空间）的维度，核由满足 $\\sum_{i=0}^{n-1} c_i A^i b = 0$ 的系数向量 $c$ 组成。因此，秩-零度定理将克雷洛夫子空间的维度与克雷洛夫向量之间线性相关性空间的维度联系起来。\n\n### 数值诊断程序的论证\n\n该诊断程序旨在区分两种可能导致克雷洛夫矩阵数值上低秩的情形。\n\n1.  **通过 SVD 计算数值秩**：在有限精度算术中，真实的数学秩会被舍入误差所掩盖。一个理论上秩亏的矩阵，其奇异值在计算上会很小但并非精确为零。奇异值分解（SVD），$K_n(A,b) = U\\Sigma V^\\top$，其中 $\\Sigma = \\mathrm{diag}(\\sigma_1, \\dots, \\sigma_n)$，是进行此类分析的理想工具。奇异值 $\\sigma_i$ 衡量了矩阵在不同正交方向上的“能量”。奇异值幅度的急剧下降表明接近秩亏。阈值 $\\tau = n \\cdot \\epsilon \\cdot \\|K_n(A,b)\\|_2$ 提供了一个标准的、动态缩放的截断值，用于将显著的奇异值与那些被认为是数值假象的奇异值分开。这里，$\\|K_n(A,b)\\|_2 = \\sigma_1$ 是最大奇异值，$\\epsilon$ 是机器精度。\n\n2.  **基于稳定性的分类**：该诊断程序的核心在于结构稳定性原理。\n    *   **真实秩亏**：这源于一个代数约束，例如，如果 $A$ 关于 $b$ 的最小多项式次数为 $d  n$。这意味着 $\\dim(\\mathcal{K}_n(A,b)) = d$。克雷洛夫矩阵 $K_n(A,b)$ 是精确秩亏的，拥有 $n-d$ 个在数学上为零的奇异值。这是一个结构稳定的性质。对 $A$ 和 $b$ 的小扰动只会导致这些零奇异值产生微小扰动。同样，秩确定阈值的适度变化（例如，从 $\\tau_0/10$ 到 $10\\tau_0$）也不太可能跨越小奇异值与大奇异值之间的显著差距。因此，计算出的秩 $r_0$ 在这些测试中应该高度一致。稳定性得分 $s$（定义为得出秩为 $r_0$ 的测试所占的比例）将接近于 1。准则 $s \\geq 0.9$ 将此预期形式化。\n    *   **缓慢增长（病態）**：这种情况发生在克雷洛夫向量 $A^k b$ 变得近似线性相关，但并非精确相关时。这对于亏损或接近亏损的矩阵（例如，那些具有簇状特征值的矩阵）是典型情况。克雷洛夫矩阵 $K_n(A,b)$ 理论上是满秩的，但却是严重病态的，意味着其条件数 $\\kappa_2(K_n) = \\sigma_1/\\sigma_n$ 非常大。奇异值逐渐衰减，没有明显的间隙。这样的矩阵接近于一个秩亏矩阵，正如 Eckart-Young-Mirsky 定理所量化的：$\\min_{\\mathrm{rank}(X)n} \\|K_n(A,b) - X\\|_2 = \\sigma_n$ 很小。然而，这种近奇异性不是结构性的。对 $A$ 或 $b$ 的微小扰动可能会显著改变病态的性质。同样，阈值的改变很可能导致计算出的秩发生变化，因为它可能会移动到奇异值逐渐衰减的谱的不同位置。因此，稳定性得分 $s$ 预计会远低于 1。该程序通过检查秩在扰动下的不稳定性来识别这种“缓慢增长”。\n\n该方法因此提供了一种原则性的方式来区分稳定的代数结构（真实亏秩）和不稳定的数值伪影（缓慢增长/病态）。", "answer": "```python\nimport numpy as np\n\ndef construct_krylov(A, b, n):\n    \"\"\"\n    Constructs the n x n Krylov matrix K_n(A,b).\n    \"\"\"\n    K = np.zeros((n, n), dtype=float)\n    if np.linalg.norm(b) == 0:\n        return K\n    \n    current_vec = b.copy()\n    K[:, 0] = current_vec\n    for i in range(1, n):\n        current_vec = A @ current_vec\n        K[:, i] = current_vec\n    return K\n\ndef run_diagnostic(A, b, n):\n    \"\"\"\n    Performs the numerical diagnostic on K_n(A,b).\n    Returns [rank, sigma_min, classification_flag].\n    \"\"\"\n    # 1. Construct the unperturbed Krylov matrix and compute its properties.\n    K = construct_krylov(A, b, n)\n    \n    s_vals = np.linalg.svd(K, compute_uv=False)\n    \n    # Handle the zero matrix case (e.g., b=0).\n    if s_vals.size > 0 and K.any():\n        norm_K = s_vals[0]\n        sigma_min = s_vals[-1]\n    else:\n        norm_K = 0.0\n        sigma_min = 0.0\n\n    eps = np.finfo(float).eps\n    tau_0 = n * eps * norm_K\n    \n    r_0 = np.sum(s_vals > tau_0)\n    \n    # 2. Perform stability analysis.\n    rng = np.random.default_rng(seed=42)\n    \n    # Define perturbation magnitudes.\n    norm_A = np.linalg.norm(A, 2)\n    norm_b = np.linalg.norm(b, 2)\n    delta_A_mag = 1e-12 * max(1.0, norm_A)\n    delta_b_mag = 1e-12 * max(1.0, norm_b)\n\n    # Generate and scale random perturbations.\n    dA_rand = rng.standard_normal(size=(n, n))\n    db_rand = rng.standard_normal(size=n)\n    \n    dA = delta_A_mag * dA_rand / np.linalg.norm(dA_rand, 2)\n    \n    norm_db_rand = np.linalg.norm(db_rand)\n    db = delta_b_mag * db_rand / norm_db_rand if norm_db_rand > 0 else np.zeros(n)\n    \n    # Define systems and thresholds to test.\n    perturbed_systems = [\n        (A, b),\n        (A, b + db),\n        (A + dA, b),\n        (A + dA, b + db)\n    ]\n    \n    thresholds = [tau_0 / 10.0, tau_0, tau_0 * 10.0] if tau_0 > 0 else [0.0, 0.0, 0.0]\n\n    all_ranks = []\n    \n    for A_p, b_p in perturbed_systems:\n        K_p = construct_krylov(A_p, b_p, n)\n        s_p = np.linalg.svd(K_p, compute_uv=False)\n        for tau in thresholds:\n            rank_p = np.sum(s_p > tau)\n            all_ranks.append(rank_p)\n            \n    # 3. Calculate stability score and classify.\n    stable_count = all_ranks.count(r_0)\n    stability_score = stable_count / len(all_ranks)\n\n    is_deficient = (r_0  n)\n    is_stable = (stability_score >= 0.9)\n\n    # Classification flag: 1 for true deficiency, 0 otherwise.\n    f = 1 if (is_deficient and is_stable) else 0\n\n    return [int(r_0), sigma_min, f]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the diagnostic for each.\n    \"\"\"\n    n = 6\n    \n    # Case 1: Structural deficiency in a diagonal matrix.\n    A1 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n    b1 = np.array([1.0, 1.0, 0.0, 0.0, 0.0, 0.0])\n    \n    # Case 2: Defective matrix (Jordan block), slow growth.\n    A2 = np.diag(np.ones(n)) + np.diag(np.ones(n - 1), k=1)\n    b2 = np.zeros(n)\n    b2[-1] = 1.0\n    \n    # Case 3: Nearly defective matrix, ill-conditioned.\n    eps_m = 1e-12\n    diag_vals = 1.0 + np.arange(n) * eps_m\n    A3 = np.diag(diag_vals) + np.diag(np.full(n - 1, eps_m), k=1)\n    rng_b = np.random.default_rng(seed=123) # Fixed seed for b reproducibility\n    b3_rand = rng_b.standard_normal(n)\n    b3 = b3_rand / np.linalg.norm(b3_rand)\n\n    # Case 4: Boundary case with zero vector.\n    A4 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n    b4 = np.zeros(n)\n    \n    test_cases = [\n        (A1, b1, n),\n        (A2, b2, n),\n        (A3, b3, n),\n        (A4, b4, n)\n    ]\n\n    results = []\n    for A, b, n_val in test_cases:\n        result = run_diagnostic(A, b, n_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3558881"}]}