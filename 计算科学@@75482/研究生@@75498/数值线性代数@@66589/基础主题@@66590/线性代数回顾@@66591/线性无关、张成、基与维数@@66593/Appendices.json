{"hands_on_practices": [{"introduction": "矩阵的四个基本子空间是线性代数的核心概念。虽然列空间（值域）的概念直观，但其正交补空间在理论上可能显得抽象。本练习旨在揭示数值线性代数中的一个优美联系：作为重要工具的QR分解，如何直接为列空间的正交补提供一组标准正交基，从而将抽象理论与具体计算紧密结合起来。[@problem_id:3555901]", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 是一个 $m \\gg n$ 的高瘦矩阵，并假设 $A$ 的列线性无关，因此 $\\operatorname{rank}(A) = n$。考虑 $A$ 的全正交三角（QR）分解，记为 $A = Q R$，其中 $Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 的主 $n \\times n$ 子块是上三角矩阵，其下方的 $(m-n) \\times n$ 子块为零。将 $Q$ 分块为 $Q = [\\,Q_{1}\\ \\ Q_{2}\\,]$，其中 $Q_{1} \\in \\mathbb{R}^{m \\times n}$ 且 $Q_{2} \\in \\mathbb{R}^{m \\times (m-n)}$。仅使用线性无关、生成空间、基、维数、正交矩阵和正交补的基本定义，推导 $A$ 的值域（列空间）的正交补的维数，记为 $\\dim \\mathcal{R}(A)^{\\perp}$，并解释 $A=QR$ 中的 $Q$ 如何为 $\\mathcal{R}(A)^{\\perp}$ 提供一个基。你最终报告的答案必须是关于 $\\dim \\mathcal{R}(A)^{\\perp}$ 的一个用 $m$ 和 $n$ 表示的闭式表达式。不需要进行数值舍入。", "solution": "此问题已经过验证。\n\n### 步骤 1：提取已知条件\n-   $A \\in \\mathbb{R}^{m \\times n}$ 是一个高瘦矩阵，意味着 $m \\gg n$。\n-   $A$ 的列是线性无关的。\n-   $\\operatorname{rank}(A) = n$。\n-   $A$ 的全正交三角（QR）分解为 $A = Q R$。\n-   $Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵。\n-   $R \\in \\mathbb{R}^{m \\times n}$ 的主 $n \\times n$ 子块为上三角矩阵，其下方的 $(m-n) \\times n$ 子块为零。\n-   $Q$ 被分块为 $Q = [\\,Q_{1}\\ \\ Q_{2}\\,]$，其中 $Q_{1} \\in \\mathbb{R}^{m \\times n}$ 且 $Q_{2} \\in \\mathbb{R}^{m \\times (m-n)}$。\n-   任务是仅使用基本定义推导 $\\dim \\mathcal{R}(A)^{\\perp}$，并解释 $Q$ 如何为 $\\mathcal{R}(A)^{\\perp}$ 提供一个基。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在线性代数的数学框架内是良定义的。所有术语，如值域（$\\mathcal{R}(A)$）、秩、QR分解、正交补（$\\perp$）、维数（$\\dim$）和线性无关，都是标准且精确定义的。给定的条件，包括 $A$ 是一个满秩的高瘦矩阵，是一致的，并构成了一个可解问题的完整基础。该问题不违反任何科学原理，不基于错误的前提，并且需要从第一性原理进行严格推导，使其成为一个有效且有实质内容的练习。\n\n### 步骤 3：结论与行动\n此问题有效。将提供完整解答。\n\n### 推导\n\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的值域（或列空间）记为 $\\mathcal{R}(A)$，定义为其列向量的生成空间。设 $A$ 的列为 $\\mathbf{a}_1, \\mathbf{a}_2, \\ldots, \\mathbf{a}_n$，其中每个 $\\mathbf{a}_j \\in \\mathbb{R}^m$。那么，\n$$\n\\mathcal{R}(A) = \\operatorname{span}\\{\\mathbf{a}_1, \\mathbf{a}_2, \\ldots, \\mathbf{a}_n\\}\n$$\n我们已知 $A$ 的列是线性无关的。根据定义，向量空间的基是一组生成该空间的线性无关向量。因此，列向量集合 $\\{\\mathbf{a}_1, \\mathbf{a}_2, \\ldots, \\mathbf{a}_n\\}$ 构成了 $\\mathcal{R}(A)$ 的一个基。\n\n向量空间的维数是其任何基中向量的数量。因为 $\\mathcal{R}(A)$ 的基包含 $n$ 个向量，所以其维数为 $n$。\n$$\n\\dim \\mathcal{R}(A) = n\n$$\n这与给定信息 $\\operatorname{rank}(A) = n$ 一致，因为矩阵的秩等于其列空间的维数。\n\n$\\mathbb{R}^m$ 的子空间 $W$ 的正交补，记为 $W^{\\perp}$，是 $\\mathbb{R}^m$ 中所有与 $W$ 中每个向量都正交的向量的集合。对于子空间 $\\mathcal{R}(A)$，我们有：\n$$\n\\mathcal{R}(A)^{\\perp} = \\{ \\mathbf{v} \\in \\mathbb{R}^m \\mid \\mathbf{v}^T \\mathbf{w} = 0 \\text{ for all } \\mathbf{w} \\in \\mathcal{R}(A) \\}\n$$\n线性代数的一个基本定理，通常称为正交分解定理，指出对于 $\\mathbb{R}^m$ 的任何子空间 $W$，整个空间可以表示为该子空间及其正交补的直和：$\\mathbb{R}^m = W \\oplus W^{\\perp}$。这意味着它们的维数之间存在一种关系：\n$$\n\\dim(\\mathbb{R}^m) = \\dim(W) + \\dim(W^{\\perp})\n$$\n将此应用于我们的子空间 $\\mathcal{R}(A)$，我们得到：\n$$\n\\dim(\\mathbb{R}^m) = \\dim(\\mathcal{R}(A)) + \\dim(\\mathcal{R}(A)^{\\perp})\n$$\n空间 $\\mathbb{R}^m$ 的维数是 $m$。代入已知的维数，我们得到：\n$$\nm = n + \\dim(\\mathcal{R}(A)^{\\perp})\n$$\n求解正交补的维数，得到：\n$$\n\\dim \\mathcal{R}(A)^{\\perp} = m - n\n$$\n这就是 $A$ 的值域的正交补的维数。\n\n接下来，我们必须解释全QR分解 $A = QR$ 如何为 $\\mathcal{R}(A)^{\\perp}$ 提供一个基。该分解由下式给出：\n$$\nA = Q R = [\\,Q_1\\ \\ Q_2\\,] \\begin{pmatrix} R_1 \\\\ 0 \\end{pmatrix}\n$$\n其中 $R_1$ 是一个 $n \\times n$ 的上三角矩阵，$0$ 是 $(m-n) \\times n$ 的零矩阵块。执行分块矩阵乘法得到：\n$$\nA = Q_1 R_1 + Q_2 \\cdot 0 = Q_1 R_1\n$$\n这个方程表明 $A$ 的每一列都是 $Q_1$ 的列的线性组合。因此，$A$ 的列空间是 $Q_1$ 的列空间的子空间，即 $\\mathcal{R}(A) \\subseteq \\mathcal{R}(Q_1)$。由于 $\\operatorname{rank}(A) = n$，矩阵 $R_1$ 是可逆的。这使我们可以写出 $Q_1 = A R_1^{-1}$，这表明 $Q_1$ 的每一列都是 $A$ 的列的线性组合，意味着 $\\mathcal{R}(Q_1) \\subseteq \\mathcal{R}(A)$。这两个包含关系共同证明了列空间是相同的：\n$$\n\\mathcal{R}(A) = \\mathcal{R}(Q_1)\n$$\n矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 是正交的。根据定义，它的列构成了 $\\mathbb{R}^m$ 的一个标准正交基。正交性条件是 $Q^T Q = I_m$，其中 $I_m$ 是 $m \\times m$ 的单位矩阵。使用 $Q$ 的分块形式：\n$$\nQ^T Q = \\begin{pmatrix} Q_1^T \\\\ Q_2^T \\end{pmatrix} [\\,Q_1\\ \\ Q_2\\,] = \\begin{pmatrix} Q_1^T Q_1  Q_1^T Q_2 \\\\ Q_2^T Q_1  Q_2^T Q_2 \\end{pmatrix} = \\begin{pmatrix} I_n  0 \\\\ 0  I_{m-n} \\end{pmatrix}\n$$\n从这个分块矩阵恒等式中，我们提取出子矩阵方程 $Q_2^T Q_1 = 0$。这个方程表明 $Q_2$ 的每一列都与 $Q_1$ 的每一列正交。\n\n设 $\\mathbf{v}$ 是 $Q_2$ 列生成空间中的任意向量，因此 $\\mathbf{v} \\in \\mathcal{R}(Q_2)$。设 $\\mathbf{w}$ 是 $Q_1$ 列生成空间中的任意向量，因此 $\\mathbf{w} \\in \\mathcal{R}(Q_1)$。那么 $\\mathbf{v}$ 可以写成 $\\mathbf{v} = Q_2 \\mathbf{c}$（对于某个系数向量 $\\mathbf{c} \\in \\mathbb{R}^{m-n}$），$\\mathbf{w}$ 可以写成 $\\mathbf{w} = Q_1 \\mathbf{d}$（对于某个 $\\mathbf{d} \\in \\mathbb{R}^n$）。它们的内积是：\n$$\n\\mathbf{v}^T \\mathbf{w} = (Q_2 \\mathbf{c})^T (Q_1 \\mathbf{d}) = \\mathbf{c}^T Q_2^T Q_1 \\mathbf{d} = \\mathbf{c}^T (0) \\mathbf{d} = 0\n$$\n这表明 $\\mathcal{R}(Q_2)$ 中的每个向量都与 $\\mathcal{R}(Q_1)$ 中的每个向量正交。由于我们已经确定 $\\mathcal{R}(A) = \\mathcal{R}(Q_1)$，因此 $\\mathcal{R}(Q_2)$ 中的每个向量都与 $\\mathcal{R}(A)$ 中的每个向量正交。根据正交补的定义，这意味着 $\\mathcal{R}(Q_2) \\subseteq \\mathcal{R}(A)^{\\perp}$。\n\n$Q_2$ 的列是正交矩阵 $Q$ 的列的一个子集。因此，$Q_2$ 的列本身是标准正交的，所以是线性无关的。$Q_2 \\in \\mathbb{R}^{m \\times (m-n)}$ 中的列数为 $m - n$。\n因此，我们找到了一个由 $m-n$ 个线性无关向量（即 $Q_2$ 的列）组成的集合，这些向量都属于子空间 $\\mathcal{R}(A)^{\\perp}$。由于我们之前推导出该子空间的维数是 $\\dim \\mathcal{R}(A)^{\\perp} = m - n$，这个向量集合不仅仅是子空间内的一个线性无关集，它必须构成该子空间的一个基。\n\n总之，$A$ 的全 QR 分解中的矩阵 $Q_2$ 的列构成了 $A$ 的值域的正交补 $\\mathcal{R}(A)^{\\perp}$ 的一个标准正交基。", "answer": "$$\n\\boxed{m-n}\n$$", "id": "3555901"}, {"introduction": "在纯数学中，方阵的行列式非零是其列向量线性无关的充要条件。然而，本练习将挑战你，让你发现为何这个简单的测试在数值计算中是极其不可靠的。通过构造特定的数值案例，你将亲眼见证矩阵列的缩放如何误导行列式测试，并理解为何必须依赖基于QR分解或SVD的稳健方法来正确判断一组向量的数值秩（有效维度）。[@problem_id:3555833]", "problem": "已知数值线性代数在有限精度浮点算术中执行，机器 epsilon 记为 $\\epsilon_{\\mathrm{mach}}$。需要使用的基本定义如下。如果 $A x = 0$ 的唯一解是 $x = 0$，则矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的一组列是线性无关的。$A$ 的列空间（张成空间）是其列的所有线性组合的集合。列空间的维数是 $A$ 的秩。方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的行列式等于其奇异值的乘积，并且随列缩放而乘法缩放。一种稳健的数值秩诊断方法使用正交分解或奇异值分解（SVD）。在列主元 QR 分解 $A P = Q R$ 中，其中 $P$ 是一个置换矩阵，$Q$ 是正交矩阵，$R$ 是上梯形矩阵，$R$ 的对角线元素通常会衰减并揭示秩。在奇异值分解 $A = U \\Sigma V^\\top$ 中，$\\Sigma$ 的对角线包含按非增序排列的奇异值 $\\sigma_i$。推荐的数值秩阈值为 $ \\tau_{\\mathrm{rel}} = \\max(m,n)\\,\\epsilon_{\\mathrm{mach}}\\,\\|A\\|_2$，其中 $\\|A\\|_2 = \\sigma_{\\max}(A)$ 是谱范数。此阈值比较的是相对于尺度的量级，而不像固定的绝对容差。\n\n实现一个程序，对给定的矩阵 $A$ 测试套件执行三种诊断：\n\n- 一种基于行列式的朴素独立性检验：\n  - 如果 $A$ 是方阵，计算 $d = \\det(A)$，如果 $|d| > \\theta$，则声明列是独立的，其中 $\\theta = 10^{-15}$ 是一个固定的绝对容差。\n  - 如果 $A$ 是 $m \\ge n$ 的矩形矩阵，计算 $g = \\det(A^\\top A)$，如果 $|g| > \\theta$，则声明列是独立的，使用相同的固定绝对容差 $\\theta = 10^{-15}$。\n- 通过列主元 QR 分解进行稳健的数值秩计算：计算列主元 QR 分解 $A P = Q R$。定义 $\\tau_{\\mathrm{QR}} = \\max(m,n)\\,\\epsilon_{\\mathrm{mach}}\\,|R_{11}|$。令 $r_{\\mathrm{QR}}$ 为严格大于 $\\tau_{\\mathrm{QR}}$ 的对角线元素 $|R_{ii}|$ 的数量。\n- 通过 SVD 进行稳健的数值秩计算：计算 $A$ 的奇异值 $\\{\\sigma_i\\}$。定义 $\\tau_{\\mathrm{SVD}} = \\max(m,n)\\,\\epsilon_{\\mathrm{mach}}\\,\\sigma_{\\max}$。令 $r_{\\mathrm{SVD}}$ 为严格大于 $\\tau_{\\mathrm{SVD}}$ 的奇异值 $\\sigma_i$ 的数量。\n\n目标是构建并评估这样一些场景：在这些场景中，由于浮点数缩放，基于行列式的朴素检验会产生误导，而基于主元 QR 和 SVD 的稳健诊断方法提供了尺度感知的数值独立性评估。\n\n测试套件。使用以下矩阵（所有条目均为以10为底的科学记数法）：\n\n- 案例 $A_1$（方阵，满代数秩但行列式极小）：\n  $$A_1 = \\begin{bmatrix}\n  1   1   1 \\\\\n  0   10^{-12}   0 \\\\\n  0   0   10^{-12}\n  \\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}.$$\n  代数秩为 $3$，且 $\\det(A_1) = 10^{-24}$。\n\n- 案例 $A_2$（方阵，极端列缩放，大的绝对值行列式，但在相对阈值下数值上秩亏）：\n  $$A_2 = \\mathrm{diag}\\!\\left(10^{16}, 1, 10^{-16}\\right) \\in \\mathbb{R}^{3 \\times 3}.$$\n  代数秩为 $3$，$\\det(A_2) = 1$，奇异值恰好为 $\\{10^{16}, 1, 10^{-16}\\}$。\n\n- 案例 $A_3$（矩形，对一个良态高矩阵进行均匀缩放；朴素的格拉姆行列式仅因绝对缩放而极小，但相对于尺度而言数值秩是满的）：\n  $$A_3 = 10^{-10} \\cdot \\begin{bmatrix}\n  1   0   1 \\\\\n  0   1   1 \\\\\n  0   0   1 \\\\\n  0   0   1 \\\\\n  0   0   1\n  \\end{bmatrix} \\in \\mathbb{R}^{5 \\times 3}.$$\n  代数秩为 $3$。注意 $A_3^\\top A_3$ 按 $10^{-20}$ 缩放，其行列式按 $10^{-60}$ 缩放。\n\n对于每种情况，您的程序应生成一个包含三个组件的列表：\n- 上述基于行列式的朴素独立性检验的布尔结果。\n- 使用阈值 $\\tau_{\\mathrm{QR}}$ 的列主元 QR 分解得到的整数数值秩 $r_{\\mathrm{QR}}$。\n- 使用阈值 $\\tau_{\\mathrm{SVD}}$ 的 SVD 分解得到的整数数值秩 $r_{\\mathrm{SVD}}$。\n\n最终输出格式。将所有测试用例的结果汇总到一个单行的 Python 风格列表的列表中，顺序为 $[A_1, A_2, A_3]$。每个内部列表必须是 $[\\text{naive}, r_{\\mathrm{QR}}, r_{\\mathrm{SVD}}]$ 的形式。您的程序应该生成一行包含此汇总列表的输出，例如，格式类似于 $[ [\\text{b}, k, \\ell], [\\text{b}, k, \\ell], [\\text{b}, k, \\ell] ]$，其中 $\\text{b}$ 是布尔值，$k, \\ell$ 是整数。此任务不需要物理单位，也没有角度或百分比。", "solution": "该问题是有效的，因为它科学地基于数值线性代数的原理，数学上是适定的，提供了所有必要的信息，并且陈述客观。我们开始解决问题。\n\n这个问题的核心是对比用于线性无关性检验的朴素、尺度依赖的方法与稳健、尺度感知的数值方法。我们被要求使用三种不同的诊断方法来评估三个矩阵：一种是使用固定绝对阈值的基于行列式的检验，一种是基于列主元 QR 分解的秩检验，还有一种是基于奇异值分解（SVD）的秩检验。标准双精度浮点运算的机器 epsilon，$\\epsilon_{\\mathrm{mach}}$，大约为 $2.22 \\times 10^{-16}$。\n\n**诊断方法**\n\n1.  **朴素行列式检验**：该检验利用了这样一个性质：$\\mathbb{R}^n$ 中的 $n$ 个向量线性无关当且仅当由这些向量构成的矩阵的行列式非零。对于一个 $m \\times n$ 的矩形矩阵 $A$（其中 $m \\ge n$），其列向量线性无关当且仅当格拉姆矩阵 $A^\\top A$ 非奇异，即 $\\det(A^\\top A) \\ne 0$。在有限精度下，我们检验 $|\\det| > \\theta$ 是否成立，其中 $\\theta = 10^{-15}$ 是一个固定的绝对容差。这种方法是出了名的不可靠，因为行列式对矩阵列的缩放非常敏感。对于矩阵 $A \\in \\mathbb{R}^{n \\times n}$，如果其中一列乘以因子 $c$，行列式也会乘以 $c$。对于格拉姆矩阵的行列式，如果 $A \\in \\mathbb{R}^{m \\times n}$ 被缩放为 $c A$，则 $\\det((cA)^\\top(cA)) = \\det(c^2 A^\\top A) = (c^2)^n \\det(A^\\top A) = c^{2n} \\det(A^\\top A)$。这种对缩放的极端敏感性可能导致即使对于良态矩阵，其行列式的值也会变得极小或极大，从而在与固定阈值比较时得出错误的结论。\n\n2.  **稳健的 QR 秩检验**：列主元 QR 分解 $AP = QR$ 将矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 分解为一个正交矩阵 $Q$、一个上梯形矩阵 $R$ 和一个对 $A$ 的列进行重排的置换矩阵 $P$。在分解的每一步，都选择剩余范数最大的列作为下一个主元。这种启发式方法确保了 $R$ 的对角线元素的量级是非递增的：$|R_{11}| \\ge |R_{22}| \\ge \\dots$。数值秩是通过计算相对于矩阵尺度而言显著大于零的对角线元素 $|R_{ii}|$ 的数量来估计的。指定的阈值为 $\\tau_{\\mathrm{QR}} = \\max(m,n)\\,\\epsilon_{\\mathrm{mach}}\\,|R_{11}|$。由于列主元使得 $|R_{11}|$成为 $A$ 的范数的一个良好估计，所以这个阈值能自适应矩阵的尺度。秩 $r_{\\mathrm{QR}}$ 是满足 $|R_{ii}| > \\tau_{\\mathrm{QR}}$ 的索引 $i$ 的数量。虽然这种方法很稳健，但可能会被特定的矩阵结构所误导。\n\n3.  **稳健的 SVD 秩检验**：奇异值分解（SVD）$A = U \\Sigma V^\\top$ 是确定数值秩最可靠的工具。它将矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 分解为正交矩阵 $U$ 和 $V$，以及一个对角矩阵 $\\Sigma$，其对角线元素 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{\\min(m,n)} \\ge 0$ 是 $A$ 的奇异值。奇异值是通过矩阵 $A$ 变换单位球面所得到的超椭球体的半轴长度。它们为矩阵在向量空间上的作用提供了一个稳定且基本的度量。数值秩是相对于最大奇异值 $\\sigma_{\\max} = \\|A\\|_2$ 而言显著的奇异值的数量。指定的阈值为 $\\tau_{\\mathrm{SVD}} = \\max(m,n)\\,\\epsilon_{\\mathrm{mach}}\\,\\sigma_{\\max}$。秩 $r_{\\mathrm{SVD}}$ 是满足 $\\sigma_i > \\tau_{\\mathrm{SVD}}$ 的奇异值 $\\sigma_i$ 的数量。\n\n现在我们将这三种诊断方法应用于每个测试用例。\n\n**案例 $A_1$**\n矩阵是 $A_1 = \\begin{bmatrix} 1  1  1 \\\\ 0  10^{-12}  0 \\\\ 0  0  10^{-12} \\end{bmatrix}$。这里，$m=3, n=3$。\n- **朴素检验**：$A_1$ 是方阵，所以我们计算它的行列式。$\\det(A_1) = 1 \\cdot (10^{-12} \\cdot 10^{-12} - 0) = 10^{-24}$。将此与固定阈值 $\\theta = 10^{-15}$ 比较，我们发现 $|\\det(A_1)| = 10^{-24} \\le 10^{-15}$。朴素检验错误地断定这些列是线性相关的。结果：`False`。\n- **QR 秩检验**：列主元 QR 分解产生一个上三角矩阵 $R$，其第一个对角线元素为 $|R_{11}| \\approx 1.732$。阈值为 $\\tau_{\\mathrm{QR}} = 3 \\cdot \\epsilon_{\\mathrm{mach}} \\cdot |R_{11}| \\approx 3 \\cdot (2.22 \\times 10^{-16}) \\cdot 1.732 \\approx 1.15 \\times 10^{-15}$。$R$ 的对角线元素的绝对值近似为 $\\{1.732, 10^{-12}, 10^{-12}\\}$。\n  - $|R_{11}| \\approx 1.732  1.15 \\times 10^{-15}$ (True)\n  - $|R_{22}| \\approx 10^{-12}  1.15 \\times 10^{-15}$ (True)\n  - $|R_{33}| \\approx 10^{-12}  1.15 \\times 10^{-15}$ (True)\n  所有三个对角线元素都超过了阈值。因此，$r_{\\mathrm{QR}} = 3$。在这种情况下，QR 检验与 SVD 一样，正确地识别了数值秩。\n- **SVD 秩检验**：$A_1$ 的奇异值约为 $\\sigma = \\{1.732, 10^{-12}, 10^{-12}\\}$。最大值为 $\\sigma_{\\max} \\approx 1.732$。阈值为 $\\tau_{\\mathrm{SVD}} = 3 \\cdot \\epsilon_{\\mathrm{mach}} \\cdot \\sigma_{\\max} \\approx 1.15 \\times 10^{-15}$。\n  - $\\sigma_1 \\approx 1.732  1.15 \\times 10^{-15}$ (True)\n  - $\\sigma_2 = 10^{-12}  1.15 \\times 10^{-15}$ (True)\n  - $\\sigma_3 = 10^{-12}  1.15 \\times 10^{-15}$ (True)\n  所有三个奇异值都高于阈值。SVD 正确地将数值秩确定为 $3$。因此，$r_{\\mathrm{SVD}} = 3$。\n- **$A_1$ 的结果**：`[False, 3, 3]`。\n\n**案例 $A_2$**\n矩阵是 $A_2 = \\mathrm{diag}(10^{16}, 1, 10^{-16})$。这里，$m=3, n=3$。\n- **朴素检验**：$A_2$ 是方阵。$\\det(A_2) = 10^{16} \\cdot 1 \\cdot 10^{-16} = 1$。因为 $|\\det(A_2)| = 1  10^{-15}$，朴素检验断定这些列是独立的。结果：`True`。这在代数上是正确的，但在数值上具有误导性。\n- **QR 秩检验**：由于 $A_2$ 是对角矩阵，其元素按量级排序，列主元 QR 分解得到 $P=I, Q=I, R=A_2$。$R$ 的对角线元素为 $\\{10^{16}, 1, 10^{-16}\\}$。最大的是 $|R_{11}| = 10^{16}$。阈值为 $\\tau_{\\mathrm{QR}} = 3 \\cdot \\epsilon_{\\mathrm{mach}} \\cdot |R_{11}| = 3 \\cdot (2.22 \\times 10^{-16}) \\cdot 10^{16} \\approx 6.66$。\n  - $|R_{11}| = 10^{16}  6.66$ (True)\n  - $|R_{22}| = 1  6.66$ (False)\n  - $|R_{33}| = 10^{-16}  6.66$ (False)\n  只有一个对角线元素超过相对阈值。因此，$r_{\\mathrm{QR}} = 1$。\n- **SVD 秩检验**：对于正对角矩阵，奇异值就是对角线上的元素。$\\sigma = \\{10^{16}, 1, 10^{-16}\\}$。最大值为 $\\sigma_{\\max} = 10^{16}$。阈值为 $\\tau_{\\mathrm{SVD}} = 3 \\cdot \\epsilon_{\\mathrm{mach}} \\cdot \\sigma_{\\max} \\approx 6.66$。\n  - $\\sigma_1 = 10^{16}  6.66$ (True)\n  - $\\sigma_2 = 1  6.66$ (False)\n  - $\\sigma_3 = 10^{-16}  6.66$ (False)\n  只有一个奇异值超过阈值。数值秩被正确地确定为 $1$。条件数 $\\sigma_{\\max}/\\sigma_{\\min}$ 是 $10^{32}$，表明极端病态。因此，$r_{\\mathrm{SVD}} = 1$。\n- **$A_2$ 的结果**：`[True, 1, 1]`。\n\n**案例 $A_3$**\n矩阵是 $A_3 = 10^{-10} \\cdot B$，其中 $B = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 0  0  1 \\\\ 0  0  1 \\\\ 0  0  1 \\end{bmatrix}$。这里，$m=5, n=3$。\n- **朴素检验**：$A_3$ 是矩形矩阵。我们计算 $g = \\det(A_3^\\top A_3)$。\n  $A_3^\\top A_3 = (10^{-10})^2 B^\\top B = 10^{-20} B^\\top B$。矩阵 $B^\\top B = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  5 \\end{bmatrix}$ 的行列式为 $\\det(B^\\top B) = 3$。\n  因此，$\\det(A_3^\\top A_3) = (10^{-20})^3 \\det(B^\\top B) = 3 \\times 10^{-60}$。\n  由于 $|g| = 3 \\times 10^{-60} \\le 10^{-15}$，朴素检验断定这些列是线性相关的。结果：`False`。这是不正确的，其原因是矩阵整体的微小尺度，而非任何线性相关性。\n- **QR 秩检验**：$A_3$ 的 QR 分解得到的 $R$ 矩阵的对角线元素将是 $B$ 的 QR 分解得到的对角线元素的 $10^{-10}$ 倍。对于 $B$，列主元分解得到的 $R$ 因子的对角线元素约为 $\\{-2.236, 1.183, 0.942\\}$。对于 $A_3$，其 $R$ 因子的对角线元素约为 $\\{ -2.236 \\times 10^{-10}, 1.183 \\times 10^{-10}, 0.942 \\times 10^{-10} \\}$。最大的是 $|R_{11}| \\approx 2.236 \\times 10^{-10}$。阈值为 $\\tau_{\\mathrm{QR}} = \\max(5,3) \\cdot \\epsilon_{\\mathrm{mach}} \\cdot |R_{11}| = 5 \\cdot (2.22 \\times 10^{-16}) \\cdot (2.236 \\times 10^{-10}) \\approx 2.48 \\times 10^{-25}$。\n  所有三个对角线元素的量级都在 $10^{-10}$ 左右，远大于 $\\tau_{\\mathrm{QR}}$。因此，$r_{\\mathrm{QR}} = 3$。\n- **SVD 秩检验**：奇异值线性缩放：$\\sigma_i(A_3) = 10^{-10} \\sigma_i(B)$。$B$ 的奇异值约为 $\\{2.418, 1.239, 0.811\\}$。所以，$A_3$ 的奇异值约为 $\\{2.418 \\times 10^{-10}, 1.239 \\times 10^{-10}, 0.811 \\times 10^{-10}\\}$。最大值为 $\\sigma_{\\max} \\approx 2.418 \\times 10^{-10}$。阈值为 $\\tau_{\\mathrm{SVD}} = \\max(5,3) \\cdot \\epsilon_{\\mathrm{mach}} \\cdot \\sigma_{\\max} = 5 \\cdot (2.22 \\times 10^{-16}) \\cdot (2.418 \\times 10^{-10}) \\approx 2.68 \\times 10^{-25}$。\n  $A_3$ 的所有三个奇异值的量级都在 $10^{-10}$ 左右，远高于阈值。因此，$r_{\\mathrm{SVD}} = 3$。\n- **$A_3$ 的结果**：`[False, 3, 3]`。\n\n最终的汇总结果表明，朴素的行列式检验是不可靠的，而 SVD 提供了最稳健的评估，列主元 QR 是一个强大但并非万无一失的替代方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Implements and compares three methods for diagnosing linear independence\n    and numerical rank for a suite of test matrices.\n    \"\"\"\n    \n    # Define machine epsilon for double precision floating point numbers.\n    epsilon_mach = np.finfo(float).eps\n    \n    # Define the fixed absolute tolerance for the naive determinant test.\n    theta = 1e-15\n\n    # Define the test suite of matrices.\n    A1 = np.array([\n        [1.0, 1.0, 1.0],\n        [0.0, 1e-12, 0.0],\n        [0.0, 0.0, 1e-12]\n    ])\n\n    A2 = np.diag([1e16, 1.0, 1e-16])\n\n    A3 = 1e-10 * np.array([\n        [1.0, 0.0, 1.0],\n        [0.0, 1.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ])\n\n    test_cases = [A1, A2, A3]\n    \n    results = []\n    \n    for A in test_cases:\n        m, n = A.shape\n        \n        # 1. Naive determinant-based independence test\n        naive_result = False\n        if m == n:\n            # Square matrix case\n            det_val = np.linalg.det(A)\n            if np.abs(det_val)  theta:\n                naive_result = True\n        elif m  n:\n            # Rectangular matrix case (tall)\n            gram_det = np.linalg.det(A.T @ A)\n            if np.abs(gram_det)  theta:\n                naive_result = True\n        \n        # 2. Robust numerical rank via column-pivoted QR\n        _, R, _ = qr(A, pivoting=True)\n        # The diagonal of R from scipy.linalg.qr (m,n) is the first min(m,n) elements\n        R_diag_abs = np.abs(np.diag(R))\n        tau_qr = max(m, n) * epsilon_mach * R_diag_abs[0]\n        # Count diagonal entries strictly greater than the threshold.\n        # Ensure we only check up to the number of columns.\n        r_qr = np.sum(R_diag_abs[:n]  tau_qr)\n        \n        # 3. Robust numerical rank via SVD\n        s = np.linalg.svd(A, compute_uv=False)\n        sigma_max = s[0] if s.size  0 else 0\n        tau_svd = max(m, n) * epsilon_mach * sigma_max\n        # Count singular values strictly greater than the threshold.\n        r_svd = np.sum(s  tau_svd)\n        \n        results.append([naive_result, r_qr, r_svd])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3555833"}, {"introduction": "Gram-Schmidt过程是将任意基转化为标准正交基的经典方法。本练习要求你实现数值上更稳定的“修正的Gram-Schmidt”（MGS）算法。更重要的是，你将探索正交化过程本身如何通过衡量计算出的基的“正交性损失”，成为诊断原始向量集数值线性无关性的强大工具。[@problem_id:3555869]", "problem": "给定一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其列向量可能近似线性相关。任务是实现一个基于改进的 Gram-Schmidt 算法的数值稳定的标准正交化过程，以构造一个矩阵 $Q \\in \\mathbb{R}^{m \\times n}$。$Q$ 的列向量张成与 $A$ 的列向量相同的子空间，并且在数值独立性允许的情况下是标准正交的。使用此构造通过估计谱范数 $\\|Q^\\top Q - I\\|_2$ 来诊断数值独立性，其中 $I \\in \\mathbb{R}^{n \\times n}$ 是单位矩阵。值 $\\|Q^\\top Q - I\\|_2$ 量化了与精确标准正交性的偏差，并作为一个诊断指标：小值表示 $A$ 的列向量数值上是独立的，而接近或大于1的值表示数值独立性的丧失（例如，精确相关或零列）。\n\n使用的基本概念和定义：\n- 线性独立性：如果方程 $\\sum_{j=1}^n \\alpha_j a_j = 0$ 的唯一解是所有 $j$ 都满足 $\\alpha_j = 0$，则 $A$ 的列向量 $\\{a_1,\\dots,a_n\\}$ 是线性独立的。\n- 张成空间：$A$ 的列向量的张成空间是 $A$ 的列向量的所有线性组合的集合。\n- 基：张成一个子空间的一组线性独立的向量是该子空间的一个基。\n- 维数：一个子空间的基中向量的数量是它的维数。\n- 内积：对于 $u,v \\in \\mathbb{R}^m$，$(u,v) = u^\\top v$。\n- 正交投影：给定一个标准正交集 $\\{q_1,\\dots,q_k\\}$，$v$ 在 $\\mathrm{span}\\{q_1,\\dots,q_k\\}$ 上的投影是 $\\sum_{i=1}^k (q_i^\\top v) q_i$。\n- 改进的 Gram–Schmidt (MGS) 算法：使用内积，将 $A$ 的每一列与先前形成的标准正交向量进行迭代正交化；当残差范数低于某个容差时，将该列视为数值相关，并将 $Q$ 的对应列设置为零向量。\n- 谱范数：对于任何矩阵 $M$，$\\|M\\|_2$ 等于其最大奇异值，这是数值线性代数中一个经过充分验证的事实。\n\n实现要求：\n1. 实现改进的 Gram–Schmidt 过程，从 $A$ 生成 $Q$ 和 $R$，遵循基于内积的迭代正交化和残差归一化。如果在对第 $j$ 列进行正交化后，残差范数 $r_{jj} = \\|v_j\\|_2$ 低于容差阈值，则声明该列为数值相关，并将 $Q$ 的相应列设置为零向量。否则，设置 $q_j = v_j / r_{jj}$。\n2. 容差可基于双精度机器ε和 $A$ 的尺度，例如，取决于 $m$、$n$ 和 $\\|A\\|_2$；确保数值鲁棒性，不要依赖任何未经检验的捷径。\n3. 计算诊断值 $\\|Q^\\top Q - I\\|_2$，其中 $I$ 是大小为 $n \\times n$ 的单位矩阵。使用一个稳定的方法；可以接受 $\\|M\\|_2$ 等于 $M$ 的最大奇异值这一事实，因为它是一个经过充分验证的事实。\n4. 对于每个测试用例，返回单个浮点数 $\\|Q^\\top Q - I\\|_2$。\n\n测试套件：\n在程序中明确编码以下矩阵 $A$：\n- 案例1（良态，数值独立）：$m = 5$, $n = 3$，其中\n  $$\n  A_1 = \\begin{bmatrix}\n  1   0   0 \\\\\n  0   1   0 \\\\\n  0   0   1 \\\\\n  1   1   0 \\\\\n  0   1   1\n  \\end{bmatrix}.\n  $$\n- 案例2（近似相关的列）：$m = 5$, $n = 3$，列向量为\n  $$\n  a_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\end{bmatrix},\\quad\n  a_2 = \\begin{bmatrix} 1.0000000001 \\\\ 2 \\\\ 2.9999999999 \\\\ 4 \\\\ 5.0000000001 \\end{bmatrix},\\quad\n  a_3 = \\begin{bmatrix} 5 \\\\ 4 \\\\ 3 \\\\ 2 \\\\ 1 \\end{bmatrix},\n  $$\n  且 $A_2 = [a_1\\ a_2\\ a_3]$。\n- 案例3（精确相关）：$m = 5$, $n = 3$，列向量为\n  $$\n  a_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\end{bmatrix},\\quad\n  a_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\end{bmatrix},\\quad\n  a_3 = \\begin{bmatrix} 2 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ 2 \\end{bmatrix},\n  $$\n  且 $A_3 = [a_1\\ a_2\\ a_3]$。\n- 案例4（病态但满秩）：$m = 4$, $n = 4$，希尔伯特矩阵 $H$，其元素为\n  $$\n  (A_4)_{ij} = \\frac{1}{i + j - 1},\\quad 1 \\le i \\le 4,\\ 1 \\le j \\le 4.\n  $$\n- 案例5（零列作为边缘情况）：$m = 4$, $n = 3$，其中\n  $$\n  A_5 = \\begin{bmatrix}\n  1   0   0 \\\\\n  0   1   0 \\\\\n  0   0   0 \\\\\n  0   0   0\n  \\end{bmatrix}.\n  $$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\|Q_1^\\top Q_1 - I\\|_2,\\ \\|Q_2^\\top Q_2 - I\\|_2,\\ \\|Q_3^\\top Q_3 - I\\|_2,\\ \\|Q_4^\\top Q_4 - I\\|_2,\\ \\|Q_5^\\top Q_5 - I\\|_2]$，其中 $Q_k$ 是通过您实现的改进 Gram–Schmidt 算法从 $A_k$ 计算出的矩阵。每个条目都必须是单个浮点数。本问题不涉及任何物理单位或角度单位。", "solution": "该问题要求实现改进的 Gram-Schmidt (MGS) 算法，为给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的列空间构造一个标准正交基。此过程将用于诊断 $A$ 的列向量的数值线性独立性。诊断指标是与标准正交性的偏差的谱范数，即 $\\|Q^\\top Q - I\\|_2$，其中 $Q$ 是计算得到的具有标准正交列的矩阵，$I$ 是 $n \\times n$ 的单位矩阵。\n\n解决方案的核心是 MGS 算法，选择该算法是因为其相对于经典版本具有更优越的数值稳定性。该算法迭代生成一组标准正交向量 $\\{q_1, q_2, \\dots, q_n\\}$，这些向量张成的空间与 $A$ 的列向量 $\\{a_1, a_2, \\dots, a_n\\}$ 所张成的空间相同。\n\n设 $A = [a_1 | a_2 | \\dots | a_n]$。我们初始化一个工作矩阵 $V = A$。MGS 算法按以下步骤进行（对于 $j = 1, \\dots, n$）：\n\n1.  **归一化**：对当前向量 $v_j$进行归一化，以生成下一个标准正交向量 $q_j$。首先，计算其欧几里得范数 $r_{jj} = \\|v_j\\|_2$。\n    -   如果 $r_{jj}$ 小于预定义的容差 $\\tau$，则认为向量 $a_j$ 与前面的向量 $\\{a_1, \\dots, a_{j-1}\\}$ 数值上线性相关。在这种情况下，相应的基向量被设为零，$q_j = 0$，表示该列不会增加张成空间的维数。\n    -   否则，对向量进行归一化：$q_j = v_j / r_{jj}$。\n\n2.  **正交化**：将工作集中的剩余向量 $\\{v_{j+1}, \\dots, v_n\\}$ 对新形成的向量 $q_j$ 进行正交化。对于每个 $k = j+1, \\dots, n$，我们通过减去 $v_k$ 在 $q_j$ 上的投影来更新 $v_k$：\n    $$\n    r_{jk} = q_j^\\top v_k\n    $$\n    $$\n    v_k \\leftarrow v_k - r_{jk} q_j\n    $$\n    这种对剩余向量的立即更新是与经典 Gram-Schmidt 算法的关键区别，也是 MGS 算法数值稳定性增强的根源。通过对 $q_j$ 进行正交化，我们确保了对向量 $v_k$ 的后续计算最小化了与 $q_j$ 平行的分量的影响。\n\n容差 $\\tau$ 的选择对于鲁棒地识别数值相关性至关重要。问题陈述指出，它应基于矩阵的维度 $m, n$、机器ε $\\varepsilon$ 以及矩阵的尺度，例如 $\\|A\\|_2$。在数值计算文献（例如，Golub  Van Loan 的《矩阵计算》）中，一个常见且合理的选择是使用与矩阵初始范数成比例的容差。我们将使用 Frobenius 范数 $\\|A\\|_F$ 作为谱范数 $\\|A\\|_2$ 的一个计算上高效的替代。因此，容差定义为：\n$$\n\\tau = \\sqrt{n} \\cdot \\varepsilon \\cdot \\|A\\|_F\n$$\n其中 $\\varepsilon$ 是双精度机器ε。此公式根据输入矩阵的大小和量级来调整容差，为确定残差范数是否在数值上为零提供了一个鲁棒的阈值。\n\n在计算出矩阵 $Q = [q_1 | q_2 | \\dots | q_n]$ 后，我们评估其与完美标准正交性的偏差。一个理想的标准正交矩阵 $Q$ 满足 $Q^\\top Q = I$。数值误差，特别是那些由 $A$ 中近似线性相关性放大的误差，会导致计算出的 $Q$ 偏离此属性。诊断指标 $\\|Q^\\top Q - I\\|_2$ 量化了这种偏差。矩阵 $M$ 的谱范数 $\\|M\\|_2$ 是其最大的奇异值。对于对称矩阵 $Q^\\top Q - I$，这等于其最大绝对特征值，即 $\\|Q^\\top Q - I\\|_2 = \\max_i |\\lambda_i(Q^\\top Q - I)|$。\n\n如果 $A$ 的列向量在数值上是独立的且良态的，MGS 算法会生成一个非常接近标准正交的矩阵 $Q$，因此 $\\|Q^\\top Q - I\\|_2$ 将是一个很小的值，量级约为 $\\varepsilon$。如果某一列 $a_j$ 被检测为数值相关，则对应的 $q_j$ 被设置为零向量。这会使 $Q^\\top Q$ 的第 $j$ 行和第 $j$ 列为零。因此，$Q^\\top Q - I$ 的第 $j$ 个对角元素为 $-1$，这意味着它的一个特征值为 $-1$。所以，谱范数 $\\|Q^\\top Q - I\\|_2$ 将至少为 $1$，从而正确地标记出数值秩的损失。对于未被容差过滤掉的近似相关列，MGS 仍然会生成一个正交性显著丧失的矩阵 $Q$，导致诊断范数值较大。\n\n实现将遵循以下步骤：\n1. 定义一个函数，以执行带有指定容差逻辑的改进 Gram-Schmidt 标准正交化。\n2. 对于每个测试用例矩阵 $A_k$，计算相应的 $Q_k$。\n3. 计算矩阵 $M_k = Q_k^\\top Q_k - I$。\n4. 使用标准的数值库函数计算谱范数 $\\|M_k\\|_2$，该函数可以找到最大奇异值。\n5. 收集所有测试用例的这些诊断值，并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the Modified Gram-Schmidt algorithm,\n    applying it to a suite of test cases, and computing a diagnostic\n    for numerical independence.\n    \"\"\"\n\n    def modified_gram_schmidt(A: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes an orthonormal basis Q for the column space of A using the\n        Modified Gram-Schmidt algorithm. Handles numerical dependence by\n        setting columns of Q to zero if the residual norm is below a tolerance.\n\n        Args:\n            A: The input matrix of shape (m, n).\n\n        Returns:\n            A matrix Q of shape (m, n) whose columns form an orthonormal basis\n            for the column space of A.\n        \"\"\"\n        m, n = A.shape\n        if n == 0:\n            return np.zeros((m, 0), dtype=float)\n\n        A_float = A.astype(float)\n        V = A_float.copy()\n        Q = np.zeros_like(A_float)\n\n        # Use the norm of the original matrix A_float for a stable tolerance.\n        norm_A_fro = np.linalg.norm(A_float, 'fro')\n        \n        # Tolerance based on numerical analysis literature (e.g., Golub  Van Loan).\n        # A small norm_A_fro should not lead to a zero tolerance.\n        # np.finfo(float).eps is approx 2.22e-16.\n        # Add a small value to norm_A_fro to handle the case of a zero matrix A.\n        tol = np.sqrt(n) * np.finfo(float).eps * (norm_A_fro + np.finfo(float).tiny)\n\n        for j in range(n):\n            v_j = V[:, j]\n            norm_v_j = np.linalg.norm(v_j)\n\n            if norm_v_j  tol:\n                # The column is numerically dependent on the previous columns.\n                # The corresponding column of Q remains the zero vector.\n                pass  # Q[:, j] is already zero\n            else:\n                q_j = v_j / norm_v_j\n                Q[:, j] = q_j\n                \n                # Orthogonalize the remaining vectors against the new q_j.\n                # This is the \"modified\" part of the algorithm.\n                for k in range(j + 1, n):\n                    # Compute projection coefficient\n                    r_jk = np.dot(q_j, V[:, k])\n                    # Subtract projection\n                    V[:, k] -= r_jk * q_j\n        return Q\n\n    def calculate_diagnostic(Q: np.ndarray) - float:\n        \"\"\"\n        Calculates the diagnostic value ||Q^T Q - I||_2.\n\n        Args:\n            Q: The matrix with orthonormalized columns.\n\n        Returns:\n            The spectral norm of (Q^T Q - I).\n        \"\"\"\n        m, n = Q.shape\n        if n == 0:\n            return 0.0\n\n        I = np.identity(n)\n        M = Q.T @ Q - I\n        \n        # The spectral norm (ord=2) is the largest singular value.\n        spectral_norm = np.linalg.norm(M, ord=2)\n        return float(spectral_norm)\n\n    # Test Case 1: Well-conditioned, numerically independent\n    A1 = np.array([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ], dtype=float)\n\n    # Test Case 2: Nearly dependent columns\n    a2_1 = np.array([1, 2, 3, 4, 5], dtype=float)\n    a2_2 = np.array([1.0000000001, 2, 2.9999999999, 4, 5.0000000001], dtype=float)\n    a2_3 = np.array([5, 4, 3, 2, 1], dtype=float)\n    A2 = np.stack([a2_1, a2_2, a2_3], axis=1)\n\n    # Test Case 3: Exact dependence\n    a3_1 = np.array([1, 2, 3, 4, 5], dtype=float)\n    a3_2 = np.array([1, 2, 3, 4, 5], dtype=float)\n    a3_3 = np.array([2, 1, 0, 1, 2], dtype=float)\n    A3 = np.stack([a3_1, a3_2, a3_3], axis=1)\n\n    # Test Case 4: Ill-conditioned but full rank (Hilbert matrix)\n    n_hilbert = 4\n    A4 = np.array([[1.0 / (i + j - 1) for j in range(1, n_hilbert + 1)] for i in range(1, n_hilbert + 1)], dtype=float)\n    \n    # Test Case 5: Zero column as an edge case\n    A5 = np.array([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ], dtype=float)\n    \n    test_cases = [A1, A2, A3, A4, A5]\n    results = []\n\n    for A in test_cases:\n        Q = modified_gram_schmidt(A)\n        diagnostic = calculate_diagnostic(Q)\n        results.append(diagnostic)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3555869"}]}