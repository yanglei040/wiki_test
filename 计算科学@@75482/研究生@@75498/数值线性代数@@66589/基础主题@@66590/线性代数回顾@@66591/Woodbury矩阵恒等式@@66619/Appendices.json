{"hands_on_practices": [{"introduction": "伍德伯里矩阵恒等式是一个强大的工具，但将其视为一个“黑盒”会限制我们对其的深刻理解。第一个练习旨在引导你从更基本的块矩阵求逆和舒尔补（Schur complement）概念出发，自行推导出该恒等式。通过编程实现推导出的低秩更新策略与直接计算方法，你不仅将从数值上验证恒等式的正确性，还将通过分析各自所需的浮点运算（FLOPs）次数，具体地体会到其计算效率的优势 [@problem_id:3599105]。这项练习将抽象的公式与其在实际性能上的优势联系起来，为你打下坚实的理论与实践基础。", "problem": "考虑方阵 $A \\in \\mathbb{R}^{n \\times n}$，$U \\in \\mathbb{R}^{n \\times k}$，$C \\in \\mathbb{R}^{k \\times k}$，$V \\in \\mathbb{R}^{k \\times n}$，以及一个向量 $b \\in \\mathbb{R}^{n}$。你的任务是，从第一性原理出发，设计一种算法来评估 $(A + U C V)^{-1} b$，该算法使用从分块矩阵恒等式和舒尔补导出的低秩更新策略，而不依赖任何预先给出的快捷公式。然后，实现一个直接计算（显式地构建 $(A + U C V)^{-1} b$）和一个低秩策略，验证两个结果在数值上是否一致，并在标准稠密操作成本模型下估算计算节省量。假定的成本模型基于经过充分测试的公式：使用常规的乘法-加法计数来构建稠密矩阵乘积和和，并通过单次下三角-上三角（LU）分解后跟三角求解来求解线性系统。具体来说，使用以下运算计数：\n- $n \\times n$ 稠密矩阵的 LU 分解：$\\frac{2}{3} n^3$ 次浮点运算（Floating Point Operations (FLOPs)）。\n- 对一个右侧向量进行两次三角求解（在 LU 分解后）：每个右侧向量 $2 n^2$ 次 FLOPs。\n- 稠密矩阵-矩阵乘法 $(p \\times q)$ 乘以 $(q \\times r)$：$2 p q r$ 次 FLOPs。\n- 稠密矩阵-向量乘法 $(p \\times q)$ 乘以 $(q \\times 1)$：$2 p q$ 次 FLOPs。\n- 稠密矩阵加法 $(p \\times q)$：$p q$ 次 FLOPs。\n- 通过 LU 分解和回代求一个 $m \\times m$ 矩阵的逆：$\\frac{8}{3} m^3$ 次 FLOPs。\n\n在你的实现中，忽略稀疏性和数据特定的零结构；在成本模型中将所有矩阵视为稠密矩阵。对于直接计算，显式地构建 $(A + U C V)$，计算其逆矩阵，然后乘以 $b$。对于低秩策略，从分块矩阵求逆和舒尔补导出一个方法，该方法仅需要：\n- 一次 $A$ 的 LU 分解，\n- 求解 $A y = b$，\n- 求解 $A Z = U$（有 $k$ 个右侧向量），\n- 构建一个 $k \\times k$ 的辅助矩阵，\n- 求解一个 $k \\times k$ 的系统，\n- 执行必要的稠密乘积和加法。\n\n你的程序必须使用指定的矩阵和向量，在 $n = 5$ 和 $k = 2$ 的条件下运行以下测试套件。每个测试都是独立的。\n\n测试用例 1（良态基线）：\n- $A_1 = \\begin{bmatrix} 4  -1  0  0  0 \\\\ -1  4  -1  0  0 \\\\ 0  -1  4  -1  0 \\\\ 0  0  -1  4  -1 \\\\ 0  0  0  -1  4 \\end{bmatrix}$，\n- $U_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  -1 \\\\ 2  1 \\\\ 0  1 \\end{bmatrix}$，\n- $V_1 = \\begin{bmatrix} 1  2  0  -1  0 \\\\ 0  1  1  0  -2 \\end{bmatrix}$，\n- $C_1 = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix}$，\n- $b_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 3 \\\\ -1 \\\\ 2 \\end{bmatrix}$。\n\n测试用例 2（在 $U$ 中有一个零列的有效秩-1 更新）：\n- $A_2 = \\begin{bmatrix} 3  -1  0  0  0 \\\\ -1  3  -1  0  0 \\\\ 0  -1  3  -1  0 \\\\ 0  0  -1  3  -1 \\\\ 0  0  0  -1  3 \\end{bmatrix}$，\n- $U_2 = \\begin{bmatrix} 1  0 \\\\ 0  0 \\\\ 1  0 \\\\ -1  0 \\\\ 2  0 \\end{bmatrix}$，\n- $V_2 = \\begin{bmatrix} 0  1  -1  0  2 \\\\ 0  0  0  0  0 \\end{bmatrix}$，\n- $C_2 = \\begin{bmatrix} 1  0.5 \\\\ 0.2  2 \\end{bmatrix}$，\n- $b_2 = \\begin{bmatrix} -1 \\\\ 2 \\\\ 0 \\\\ 3 \\\\ 1 \\end{bmatrix}$。\n\n测试用例 3（近奇异的 $A$ 对角线）：\n- $A_3 = \\operatorname{diag}\\left( 10^{-6}, 1, 2, 3, 4 \\right)$，\n- $U_3 = \\begin{bmatrix} 1  0 \\\\ 0.5  -0.2 \\\\ -0.3  0.1 \\\\ 0  0.4 \\\\ 0.2  -0.1 \\end{bmatrix}$，\n- $V_3 = \\begin{bmatrix} 0.1  0  0.3  -0.2  0 \\\\ 0  0.2  -0.1  0  0.4 \\end{bmatrix}$，\n- $C_3 = \\begin{bmatrix} 1.5  0.1 \\\\ 0  1.2 \\end{bmatrix}$，\n- $b_3 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\\\ 0.25 \\\\ 1 \\\\ -0.75 \\end{bmatrix}$。\n\n对于每个测试用例，实现并计算：\n- 直接结果 $x_{\\text{direct}} = (A + U C V)^{-1} b$，通过显式地对 $A + U C V$ 求逆并乘以 $b$ 得到。\n- 低秩结果 $x_{\\text{lowrank}}$，从分块矩阵求逆和舒尔补导出。\n- 最大绝对差 $\\max_{i} |(x_{\\text{direct}})_i - (x_{\\text{lowrank}})_i|$。\n- 一个布尔值验证，确认差值小于 $10^{-12}$ 的容差。\n- 在稠密成本模型下的 FLOP 计数，定义如下：\n  - 直接方法的总 FLOPs：\n    $$T_{\\text{direct}}(n,k) = 2 n k^2 + 2 n^2 k + n^2 + \\frac{8}{3} n^3 + 2 n^2.$$\n  - 低秩方法的总 FLOPs：\n    $$T_{\\text{lowrank}}(n,k) = \\frac{2}{3} n^3 + 2 n^2 + 2 n^2 k + 2 n k^2 + \\frac{8}{3} k^3 + k^2 + \\frac{2}{3} k^3 + 2 k^2 + 4 n k + n.$$\n- 节省比率 $R = \\frac{T_{\\text{direct}}(n,k)}{T_{\\text{lowrank}}(n,k)}$。\n\n你的程序应该生成一行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个条目本身是按以下顺序包含五个元素的列表：\n$[\\text{verified}, \\text{max\\_abs\\_diff}, T_{\\text{direct}}, T_{\\text{lowrank}}, R]$。\n例如，输出格式必须为 $[[\\text{boolean}, \\text{float}, \\text{float}, \\text{float}, \\text{float}], [\\dots], [\\dots]]$ 的形式。", "solution": "该问题要求设计并分析一种算法，通过利用更新项 $UCV$ 的低秩结构来高效计算向量 $x = (A + UCV)^{-1}b$。我们需要从第一性原理出发，使用分块矩阵恒等式来推导此算法，而不是直接陈述 Woodbury 矩阵恒等式。然后，将基于所提供的浮点运算（FLOP）计数模型，从数值精度和计算成本方面，将推导出的算法与直接计算方法进行比较。\n\n### 低秩更新算法的推导\n\n问题的核心是找到满足方程 $(A + UCV)x = b$ 的向量 $x$，假设矩阵 $(A + UCV)$ 是可逆的。我们可以将此问题表述为一个更大的、结构化的分块线性系统的解。考虑以下 $2 \\times 2$ 分块矩阵方程：\n$$\n\\begin{bmatrix} A  & U \\\\ V  & -C^{-1} \\end{bmatrix}\n\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\n=\n\\begin{bmatrix} b \\\\ 0 \\end{bmatrix}\n$$\n该系统有定义的前提是矩阵 $C \\in \\mathbb{R}^{k \\times k}$ 是可逆的。该分块方程展开为一个由两个线性方程组成的系统：\n1. $Ax' + Uy' = b$\n2. $Vx' - C^{-1}y' = 0$\n\n通过对第二个方程的直接操作，我们可以用 $x'$ 表示 $y'$：\n$$\nVx' = C^{-1}y' \\implies y' = CVx'\n$$\n将 $y'$ 的这个表达式代入第一个方程，得到：\n$$\nAx' + U(CVx') = b\n$$\n$$\n(A + UCV)x' = b\n$$\n这表明我们分块系统解中的向量 $x'$ 正是我们要计算的向量 $x = (A + UCV)^{-1}b$。\n\n现在我们使用分块代入法来求解 $x'$，这是舒尔补概念的一个应用。我们假设矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 也是可逆的。从第一个方程 $Ax' + Uy' = b$ 中，我们可以分離出 $x'$：\n$$\nAx' = b - Uy' \\implies x' = A^{-1}(b - Uy')\n$$\n接下来，我们将 $x'$ 的这个表达式代入第二个方程 $Vx' - C^{-1}y' = 0$：\n$$\nV(A^{-1}(b - Uy')) - C^{-1}y' = 0\n$$\n分配 $V$ 并重新整理各项以求解 $y'$：\n$$\nVA^{-1}b - VA^{-1}Uy' - C^{-1}y' = 0\n$$\n$$\nVA^{-1}b = VA^{-1}Uy' + C^{-1}y'\n$$\n$$\nVA^{-1}b = (C^{-1} + VA^{-1}U)y'\n$$\n矩阵 $S = C^{-1} + VA^{-1}U$ 是分块矩阵 $\\begin{bmatrix} A  & U \\\\ V  & -C^{-1} \\end{bmatrix}$ 关于分块 $A$ 的舒尔补的负数。它是一个 $k \\times k$ 的矩阵。假设 $S$ 是可逆的，我们可以求解 $y'$：\n$$\ny' = (C^{-1} + VA^{-1}U)^{-1} VA^{-1}b\n$$\n最后，我们将 $y'$ 的这个结果代回到我们关于 $x'$ 的表达式中：\n$$\nx' = A^{-1}(b - Uy') = A^{-1}b - A^{-1}Uy'\n$$\n$$\nx = x' = A^{-1}b - A^{-1}U (C^{-1} + VA^{-1}U)^{-1} VA^{-1}b\n$$\n这个最终表达式提供了一种计算 $x$ 的算法，它避免了显式构建和求逆 $n \\times n$ 矩阵 $(A + UCV)$。当 $k \\ll n$ 时，这尤其有利，因为主要的计算瓶颈从对 $n \\times n$ 矩阵的操作转移到了涉及 $A^{-1}$（可以预先分解）和对一个更小的 $k \\times k$ 矩阵求逆的操作。\n\n### 算法策略和成本分析\n\n推导出的公式导出了以下用于低秩更新方法的多步算法。我们将分析此算法与直接方法的计算成本，使用提供的 FLOP 计数。\n\n**直接方法成本 ($T_{\\text{direct}}$)：**\n1.  计算 $W = UC$：$U \\in \\mathbb{R}^{n \\times k}$，$C \\in \\mathbb{R}^{k \\times k}$。成本：$2nk^2$ FLOPs。\n2.  计算 $P = WV$：$W \\in \\mathbb{R}^{n \\times k}$，$V \\in \\mathbb{R}^{k \\times n}$。成本：$2nkn = 2n^2k$ FLOPs。\n3.  计算 $M = A + P$：两个 $n \\times n$ 矩阵相加。成本：$n^2$ FLOPs。\n4.  计算 $M^{-1}$：一个 $n \\times n$ 矩阵。成本：$\\frac{8}{3}n^3$ FLOPs。\n5.  计算 $x = M^{-1}b$：一个 $n \\times n$ 矩阵乘以一个 $n \\times 1$ 向量。成本：$2n^2$ FLOPs。\n\n总成本为 $T_{\\text{direct}}(n,k) = 2nk^2 + 2n^2k + n^2 + \\frac{8}{3}n^3 + 2n^2$，与问题中提供的公式相符。\n\n**低秩方法成本 ($T_{\\text{lowrank}}$)：**\n该方法的实现策略是：\n1.  对 $A$ 进行 LU 分解：$\\frac{2}{3}n^3$ FLOPs。\n2.  求解 $y_0 = A^{-1}b$：$2n^2$ FLOPs。\n3.  求解 $Z = A^{-1}U$：$k$ 次求解，成本为 $k \\times (2n^2) = 2n^2k$ FLOPs。\n4.  计算 $C^{-1}$：$\\frac{8}{3}k^3$ FLOPs。\n5.  计算 $VZ$ 乘积：$2nk^2$ FLOPs。\n6.  计算和 $S = C^{-1} + VZ$：$k^2$ FLOPs。\n7.  求解系统 $Sz=w$（其中 $w=Vy_0$）：\n    - 计算右侧项 $w=Vy_0$：$2nk$ FLOPs。\n    - 对 $S$ 进行 LU 分解：$\\frac{2}{3}k^3$ FLOPs。\n    - 求解 $z$：$2k^2$ FLOPs。\n8.  计算更新项 $Zz$：$2nk$ FLOPs。\n9.  最终减法 $x = y_0 - Zz$：$n$ FLOPs。\n\n将这些项相加，得到总成本：\n$T_{\\text{lowrank}}(n,k) = (\\frac{2}{3} n^3) + (2 n^2) + (2 n^2 k) + (\\frac{8}{3} k^3) + (2 n k^2) + (k^2) + (2nk) + (\\frac{2}{3} k^3 + 2 k^2) + (2nk) + n$。\n重新组合各项，我们得到问题中提供的公式：\n$T_{\\text{lowrank}}(n,k) = \\frac{2}{3} n^3 + 2 n^2 + 2 n^2 k + 2 n k^2 + \\frac{8}{3} k^3 + k^2 + \\frac{2}{3} k^3 + 2 k^2 + 4 n k + n$。\n对于大的 $n$ 和小的 $k$，该方法的成本主要由 $A$ 的初始 LU 分解（$\\frac{2}{3}n^3$ FLOPs）主导，而直接方法则由显式求逆（$\\frac{8}{3}n^3$ FLOPs）主导，这解释了低秩方法的计算优势。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, comparing a direct method\n    and a low-rank update method for evaluating (A + UCV)^-1 * b.\n    \"\"\"\n    n = 5\n    k = 2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (well-conditioned baseline)\n        {\n            \"A\": np.array([[4, -1, 0, 0, 0],\n                           [-1, 4, -1, 0, 0],\n                           [0, -1, 4, -1, 0],\n                           [0, 0, -1, 4, -1],\n                           [0, 0, 0, -1, 4]], dtype=float),\n            \"U\": np.array([[1, 0], [0, 1], [1, -1], [2, 1], [0, 1]], dtype=float),\n            \"V\": np.array([[1, 2, 0, -1, 0], [0, 1, 1, 0, -2]], dtype=float),\n            \"C\": np.array([[2, -1], [1, 3]], dtype=float),\n            \"b\": np.array([1, 0, 3, -1, 2], dtype=float)\n        },\n        # Test case 2 (effective rank-1 update)\n        {\n            \"A\": np.array([[3, -1, 0, 0, 0],\n                           [-1, 3, -1, 0, 0],\n                           [0, -1, 3, -1, 0],\n                           [0, 0, -1, 3, -1],\n                           [0, 0, 0, -1, 3]], dtype=float),\n            \"U\": np.array([[1, 0], [0, 0], [1, 0], [-1, 0], [2, 0]], dtype=float),\n            \"V\": np.array([[0, 1, -1, 0, 2], [0, 0, 0, 0, 0]], dtype=float),\n            \"C\": np.array([[1, 0.5], [0.2, 2]], dtype=float),\n            \"b\": np.array([-1, 2, 0, 3, 1], dtype=float)\n        },\n        # Test case 3 (near-singular A)\n        {\n            \"A\": np.diag([1e-6, 1, 2, 3, 4]),\n            \"U\": np.array([[1, 0], [0.5, -0.2], [-0.3, 0.1], [0, 0.4], [0.2, -0.1]], dtype=float),\n            \"V\": np.array([[0.1, 0, 0.3, -0.2, 0], [0, 0.2, -0.1, 0, 0.4]], dtype=float),\n            \"C\": np.array([[1.5, 0.1], [0, 1.2]], dtype=float),\n            \"b\": np.array([0.5, -0.5, 0.25, 1, -0.75], dtype=float)\n        }\n    ]\n\n    results = []\n    \n    # Calculate FLOP counts (these are constant for n=5, k=2)\n    # T_direct(n,k) = 2*n*k^2 + 2*n^2*k + n^2 + (8/3)*n^3 + 2*n^2\n    T_direct = (2*n*k**2 + 2*n**2*k + n**2 + (8/3)*n**3 + 2*n**2)\n    \n    # T_lowrank(n,k) as specified\n    T_lowrank = ((2/3)*n**3 + 2*n**2 + 2*n**2*k + 2*n*k**2 + \n                 (8/3)*k**3 + k**2 + (2/3)*k**3 + 2*k**2 + \n                 4*n*k + n)\n\n    R = T_direct / T_lowrank\n\n    for case in test_cases:\n        A, U, C, V, b = case[\"A\"], case[\"U\"], case[\"C\"], case[\"V\"], case[\"b\"]\n\n        # Direct method\n        M = A + U @ C @ V\n        try:\n            M_inv = np.linalg.inv(M)\n            x_direct = M_inv @ b\n        except np.linalg.LinAlgError:\n            # In case M is singular, handle gracefully although not expected\n            x_direct = np.full_like(b, np.nan)\n\n        # Low-rank update method (Sherman-Morrison-Woodbury)\n        try:\n            # Step 1  2: Solve A y = b and A Z = U\n            y0 = np.linalg.solve(A, b)\n            Z = np.linalg.solve(A, U)\n            \n            # Step 3: Compute C_inv\n            C_inv = np.linalg.inv(C)\n            \n            # Step 4: Form the k x k Schur complement matrix\n            S = C_inv + V @ Z\n            \n            # Step 5  6: Solve the small k x k system\n            w = V @ y0\n            z = np.linalg.solve(S, w)\n\n            # Step 7  8: Compute final solution\n            x_update = Z @ z\n            x_lowrank = y0 - x_update\n        except np.linalg.LinAlgError:\n            # In case A, C, or S is singular\n            x_lowrank = np.full_like(b, np.nan)\n\n        # Comparison\n        max_abs_diff = np.max(np.abs(x_direct - x_lowrank))\n        verified = max_abs_diff  1e-12\n\n        results.append([verified, max_abs_diff, T_direct, T_lowrank, R])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is desired, joined by commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3599105"}, {"introduction": "现实世界中的问题常常涉及到具有特殊结构的矩阵，我们可以利用这些结构来提升计算效率。本练习聚焦于一个尤其重要的情形：当矩阵 $A$ 是对称正定（Symmetric Positive Definite, SPD）矩阵时。在这种情况下，我们可以用更高效且数值性质更稳定的 Cholesky 分解 $A = LL^{\\top}$ 来替代通用的 LU 分解。这项练习要求你调整伍德伯里恒等式的计算框架，以充分利用 Cholesky 因子，通过高效的三角求解来处理涉及 $A^{-1}$ 的运算 [@problem_id:3599100]。它强调了根据特定矩阵性质来优化通用算法以获得最佳性能的重要性。", "problem": "给定一个可逆的对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 及其 Cholesky 分解 $A = L L^{\\top}$，其中 $L$ 是下三角矩阵。同时给定矩阵 $U \\in \\mathbb{R}^{n \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$ 以及一个可逆矩阵 $C \\in \\mathbb{R}^{k \\times k}$。考虑线性系统 $(A + U C V)\\,x = b$，其中右侧项 $b \\in \\mathbb{R}^{n}$ 已知。您的任务是：\n\n1. 仅使用矩阵逆的定义、三角系统的性质以及通过 Schur 补的分块矩阵求逆法则（作为推导的基础），推导出一个有理论依据的算法来构建矩阵\n   $$\n   S = C^{-1} + V\\,A^{-1}\\,U\n   $$\n   该算法对 $U$ 的每一列恰好使用两次相对于 Cholesky 因子 $L$ 的三角求解（即形式为 $L y = u$ 和 $L^{\\top} w = y$ 的求解），并避免显式构建 $A^{-1}$。请提供理由说明为何在给定假设下此构造是正确且稳定的。\n\n2. 基于您在第 1 部分的推导，再次依据第一性原理，概述计算系统 $(A + U C V)\\,x = b$ 的解 $x$ 的完整计算步骤，强调如何在此过程中使用 $S$，以及如何仅需使用 $L$ 和 $L^{\\top}$ 进行三角求解来获取 $A^{-1}$ 的作用。\n\n3. 在一个程序中实现此算法，该程序执行以下测试套件。对于每个测试用例，确定性地构造指定的矩阵和向量，使用您的算法计算解 $x$，并使用密集线性求解器直接求解 $(A + U C V)\\,x = b$ 来验证其正确性。为了验证，计算相对差异\n   $$\n   r = \\frac{\\lVert x_{\\text{woodbury}} - x_{\\text{direct}} \\rVert_2}{1 + \\lVert x_{\\text{direct}} \\rVert_2}\n   $$\n   并返回一个布尔值，如果 $r \\leq 10^{-10}$ 则为 $\\text{True}$，否则为 $\\text{False}$。此问题不涉及物理单位、角度或百分比。\n\n测试套件必须严格按照以下方式构建（所有随机数生成必须使用指定的独立种子和标准正态分布条目，且所有构造必须是确定性的）：\n\n- 情况 1 (一般正常路径):\n  - $n = 6$, $k = 2$。\n  - 构造 $A$ 为 $A = M^{\\top} M + n I$，其中 $M$ 的条目由种子为 $1$ 的标准正态分布生成，$I$ 是单位矩阵。\n  - 用种子为 $2$ 的标准正态分布条目构造 $U$。\n  - 用种子为 $3$ 的标准正态分布条目构造 $V$。\n  - 构造 $C$ 为 $C = R^{\\top} R + k I$，其中 $R$ 的条目由种子为 $4$ 的标准正态分布生成。\n  - 用种子为 $5$ 的标准正态分布条目构造 $b$。\n\n- 情况 2 (秩-1 更新):\n  - $n = 5$, $k = 1$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 为标准正态分布，种子为 $11$。\n  - 用种子为 $12$ 的标准正态分布条目构造 $U$。\n  - 用种子为 $13$ 的标准正态分布条目构造 $V$。\n  - 设置 $C = [2.5]$ (即 $C \\in \\mathbb{R}^{1 \\times 1}$ 等于标量 $2.5$)。\n  - 用种子为 $15$ 的标准正态分布条目构造 $b$。\n\n- 情况 3 (病态但可逆的 $C$):\n  - $n = 7$, $k = 2$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 为标准正态分布，种子为 $21$。\n  - 用种子为 $22$ 的标准正态分布条目构造 $U$。\n  - 用种子为 $23$ 的标准正态分布条目构造 $V$。\n  - 设置 $C = \\operatorname{diag}(10^{-8},\\,0.5)$。\n  - 用种子为 $25$ 的标准正态分布条目构造 $b$。\n\n- 情况 4 ($V = U^{\\top}$ 的类对称更新):\n  - $n = 5$, $k = 3$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 为标准正态分布，种子为 $31$。\n  - 用种子为 $32$ 的标准正态分布条目构造 $U$。\n  - 设置 $V = U^{\\top}$。\n  - 设置 $C = \\operatorname{diag}(1.0,\\,2.0,\\,3.0)$。\n  - 用种子为 $35$ 的标准正态分布条目构造 $b$。\n\n- 情况 5 (无更新：$U$ 为零):\n  - $n = 4$, $k = 2$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 为标准正态分布，种子为 $41$。\n  - 将 $U$ 设置为 $n \\times k$ 的零矩阵。\n  - 用种子为 $43$ 的标准正态分布条目构造 $V$。\n  - 设置 $C = \\operatorname{diag}(1.0,\\,1.5)$。\n  - 用种子为 $45$ 的标准正态分布条目构造 $b$。\n\n您的程序必须：\n- 使用 Cholesky 因子 $L$ 进行三角求解。\n- 对 $U$ 的每一列使用恰好两次三角求解来构建 $S = C^{-1} + V\\,A^{-1}\\,U$。\n- 使用您概述的步骤计算 $x$，这些步骤仅需要使用 $L$ 和 $L^{\\top}$ 进行三角求解以及一个涉及 $S$ 的小型密集求解。\n- 对照直接密集求解 $(A + U C V)\\,x = b$ 的结果来验证 $x$。\n- 其唯一输出必须是单行，包含一个长度为 $5$ 的 Python 布尔值列表，每个用例一个，按上述顺序排列，例如 $[ \\text{True}, \\text{False}, \\dots ]$，无额外空格要求。\n\n最终输出格式必须是单行，包含一个用方括号括起来的、以逗号分隔的结果列表，例如 $[True,True,True,True,True]$。", "solution": "该问题要求推导并实现一个算法来求解线性系统 $(A + U C V)\\,x = b$，其中 $A$ 是一个大型对称正定 (SPD) 矩阵，其 Cholesky 分解 $A=LL^\\top$ 已知，而 $U, C, V$ 代表一个低秩更新。更新的秩为 $k$，即 $U$ 的列数和 $V$ 的行数，通常远小于 $n$。所使用的方法基于 Woodbury 矩阵恒等式，该恒等式从分块矩阵求逆的原理推导而来。\n\n### 第 1 部分：矩阵 S 的原理推导与构建\n\nWoodbury 矩阵恒等式 $(A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}VA^{-1}$ 提供了一种计算修改后矩阵逆的方法。此恒等式的核心是矩阵 $S = C^{-1} + VA^{-1}U$。我们的推导将源于构建一个增广线性系统，该系统揭示了 $S$ 作为舒尔补的角色。\n\n考虑以下 $2 \\times 2$ 分块线性系统：\n$$\n\\begin{pmatrix} A   U \\\\ V   -C^{-1} \\end{pmatrix} \\begin{pmatrix} y \\\\ z \\end{pmatrix} = \\begin{pmatrix} b \\\\ 0 \\end{pmatrix}\n$$\n该系统等价于以下方程组：\n1.  $A y + U z = b$\n2.  $V y - C^{-1} z = 0$\n\n从方程 (2)，假设给定的 $C$ 是可逆的，我们有 $z = CVy$。将此代入方程 (1) 得到：\n$$\nA y + U(CVy) = b \\implies (A + UCV)y = b\n$$\n这表明增广系统解中的向量 $y$ 正是我们所寻找的解向量 $x$。\n\n为了开发一个计算算法，我们可以使用分块消元法求解该增广系统。从方程 (1)，我们可以用 $z$ 表示 $y$：\n$$\ny = A^{-1}(b - Uz)\n$$\n将这个 $y$ 的表达式代入方程 (2)：\n$$\nV \\left( A^{-1}(b - Uz) \\right) - C^{-1} z = 0\n$$\n展开 $V$ 并重新整理各项以求解 $z$：\n$$\nV A^{-1} b - V A^{-1} U z - C^{-1} z = 0\n$$\n$$\nV A^{-1} b = (C^{-1} + V A^{-1} U) z\n$$\n我们定义矩阵 $S = C^{-1} + V A^{-1} U$。关于 $z$ 的方程变成一个 $k \\times k$ 的线性系统，$S z = V A^{-1} b$。矩阵 $S$ 是增广系统矩阵中分块 $A$ 的舒尔补的负数。\n\n任务是高效且稳定地构建 $S$，而无需显式计算 $A^{-1}$。$S$ 的表达式为 $S = C^{-1} + V(A^{-1}U)$。关键的计算是矩阵乘积 $W = A^{-1}U$。这等价于求解矩阵方程 $AW = U$ 以得到未知矩阵 $W \\in \\mathbb{R}^{n \\times k}$。\n\n这个矩阵方程可以逐列求解。设 $u_j$ 是 $U$ 的第 $j$ 列，$w_j$ 是 $W$ 的第 $j$ 列。对于每个 $j \\in \\{1, \\dots, k\\}$，我们求解线性系统：\n$$\nA w_j = u_j\n$$\n我们已知 Cholesky 分解 $A = LL^\\top$，其中 $L$ 是一个下三角矩阵。代入此分解得：\n$$\nL L^\\top w_j = u_j\n$$\n该系统通过两次三角求解在两个步骤中解决，这在计算上是高效的 ($O(n^2)$)：\na. **前向代换**：求解 $L y_j = u_j$ 得到中间向量 $y_j$。\nb. **后向代换**：求解 $L^\\top w_j = y_j$ 得到所需列向量 $w_j$。\n\n对 $U$ 的 $k$ 列中的每一列重复此两步过程。这构成了对 $U$ 的每一列恰好进行两次三角求解。计算完所有列 $w_j$ 后，将它们组装成矩阵 $W = [w_1, w_2, \\dots, w_k]$。\n\n构建 $S$ 的最后步骤是：\n1. 直接计算 $C^{-1}$。由于 $C$ 是一个小的 $k \\times k$ 矩阵（$k \\ll n$），这是一个廉价的操作。\n2. 计算矩阵乘积 $VW$。\n3. 计算和 $S = C^{-1} + VW$。\n\n**正确性与稳定性**：从增广系统的推导保证了这种构造在数学上是正确的。该过程的数值稳定性依赖于 $A$ 的性质。由于 $A$ 是对称正定的，其 Cholesky 分解是数值稳定的。问题进一步指明 $A$ 被构造为 $M^\\top M + nI$，这使其成为良态的。使用良态的因子 $L$ 求解三角系统也是一个稳定的过程。因此，计算 $W=A^{-1}U$ 在数值上是稳定的，并且在给定假设下，$S$ 的整体构建是鲁棒的。\n\n### 第 2 部分：求解 (A+UCV)x = b 的完整算法\n\n基于上述推导，我们有了一个寻找解 $x$ 的完整步骤序列。策略是首先求解辅助向量 $z$，然后用它来找到 $x=y$。\n\n算法流程如下：\n1.  **为 $S$ 和 $x$ 计算预备量**：\n    a. 计算 $W = A^{-1}U$。如第 1 部分详述，这涉及对每一列 $j=1, \\dots, k$ 求解 $Aw_j = u_j$，使用 Cholesky 因子 $L$ 进行两次三角求解。\n    b. 计算 $z_b = A^{-1}b$。这是一个单一向量求解 $Az_b = b$，也通过两次三角求解完成：先解 $Ly_b=b$，再解 $L^\\top z_b = y_b$。\n\n2.  **构建并求解 $k \\times k$ 系统**：\n    a. 计算 $S = C^{-1} + V W$。这需要一次小型矩阵求逆和一次矩阵乘法。\n    b. $z$ 系统的右侧项是 $V A^{-1} b$，现在可以计算为 $t = V z_b$。\n    c. 求解稠密的 $k \\times k$ 线性系统 $S z = t$ 以得到向量 $z \\in \\mathbb{R}^k$。\n\n3.  **计算最终解 $x$**：\n    a. 从推导可知，$x = y = A^{-1}(b - Uz)$。\n    b. 我们可以将其重写为 $x = A^{-1}b - A^{-1}Uz$。\n    c. 代入预计算的量，我们得到 $x = z_b - Wz$。\n    d. 最终解通过一次矩阵-向量乘积 $Wz$ 和一次向量减法得到。\n\n该算法有效地利用了问题的结构。它不直接求解涉及稠密矩阵 $A+UCV$ 的一个大型 $n \\times n$ 系统，而是需要一系列涉及结构化矩阵 $A$（通过其因子 $L$）的操作和一个小型稠密 $k \\times k$ 系统。总成本主要由初始涉及 $A$ 的求解决定，大约是求解单个带 $A$ 系统的成本的 $k$ 倍。当 $k \\ll n$ 时，这非常有利。\n\n### 第 3 部分：实现与验证\n\n以下 Python 程序实现了所推导的算法。它按规定构造了五个测试用例，使用概述的步骤计算解 $x_{\\text{woodbury}}$，并与通过标准密集求解器求解 $(A+UCV)x=b$ 得到的直接解 $x_{\\text{direct}}$ 进行验证。计算相对差异，并为每个案例存储一个布尔结果。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_woodbury(A, U, C, V, b):\n    \"\"\"\n    Solves (A + UCV)x = b using the Woodbury matrix identity.\n    A is assumed to be SPD.\n    \"\"\"\n    n, k = U.shape\n    \n    # Step 1: Cholesky factorization of A\n    # A is guaranteed to be SPD by construction in the test cases.\n    try:\n        L = linalg.cholesky(A, lower=True)\n    except linalg.LinAlgError:\n        # Fallback for cases where A might not be perfectly SPD due to floating point.\n        # This should not happen with the problem's construction.\n        raise\n\n    # Step 2: Compute W = A^-1 * U\n    # Solve A*w_j = u_j for each column of U using the Cholesky factor\n    W = np.zeros_like(U)\n    if k > 0:\n      for j in range(k):\n          # Solve Ly = u_j\n          y_j = linalg.solve_triangular(L, U[:, j], lower=True)\n          # Solve L^T w_j = y_j\n          w_j = linalg.solve_triangular(L.T, y_j, lower=False)\n          W[:, j] = w_j\n\n    # Step 3: Compute C_inv and S = C_inv + V * A^-1 * U\n    if k > 0:\n        C_inv = linalg.inv(C)\n        S = C_inv + V @ W\n    \n    # Step 4: Solve for x using the Woodbury formula\n    # x = A_inv*b - A_inv*U*S_inv*V*A_inv*b\n    # Let z_b = A_inv*b\n    # x = z_b - W*S_inv*V*z_b\n\n    # Compute z_b = A^-1 * b\n    y_b = linalg.solve_triangular(L, b, lower=True)\n    z_b = linalg.solve_triangular(L.T, y_b, lower=False)\n\n    if k > 0:\n        # Compute t = V * z_b\n        t = V @ z_b\n        # Solve Sz = t for z (here z is the variable from derivation, not z_b)\n        aux_z = linalg.solve(S, t)\n        # Final solution x = z_b - W*z\n        x_woodbury = z_b - W @ aux_z\n    else: # If k=0, U is empty, so the update is zero. The system is Ax=b.\n        x_woodbury = z_b\n\n    return x_woodbury\n\ndef create_spd_matrix(n, seed):\n    \"\"\"Creates an n x n SPD matrix.\"\"\"\n    rng = np.random.default_rng(seed)\n    M = rng.standard_normal((n, n))\n    # A = M^T M ensures semi-definite. Adding n*I makes it well-conditioned and SPD.\n    return M.T @ M + n * np.eye(n)\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Woodbury identity solver.\n    \"\"\"\n    test_cases = [\n        {'n': 6, 'k': 2, 'seeds': {'A': 1, 'U': 2, 'V': 3, 'C': 4, 'b': 5}},\n        {'n': 5, 'k': 1, 'seeds': {'A': 11, 'U': 12, 'V': 13, 'C': None, 'b': 15}},\n        {'n': 7, 'k': 2, 'seeds': {'A': 21, 'U': 22, 'V': 23, 'C': None, 'b': 25}},\n        {'n': 5, 'k': 3, 'seeds': {'A': 31, 'U': 32, 'V': None, 'C': None, 'b': 35}},\n        {'n': 4, 'k': 2, 'seeds': {'A': 41, 'U': None, 'V': 43, 'C': None, 'b': 45}},\n    ]\n    \n    results = []\n    \n    # Tolerance for verification\n    TOL = 1e-10\n\n    # Case 1\n    case = test_cases[0]\n    n, k, seeds = case['n'], case['k'], case['seeds']\n    rng_u = np.random.default_rng(seeds['U'])\n    rng_v = np.random.default_rng(seeds['V'])\n    rng_c = np.random.default_rng(seeds['C'])\n    rng_b = np.random.default_rng(seeds['b'])\n    A = create_spd_matrix(n, seeds['A'])\n    U = rng_u.standard_normal((n, k))\n    V = rng_v.standard_normal((k, n))\n    R = rng_c.standard_normal((k, k))\n    C = R.T @ R + k * np.eye(k)\n    b = rng_b.standard_normal(n)\n\n    # Case 2\n    case2 = test_cases[1]\n    n2, k2, seeds2 = case2['n'], case2['k'], case2['seeds']\n    rng_u2 = np.random.default_rng(seeds2['U'])\n    rng_v2 = np.random.default_rng(seeds2['V'])\n    rng_b2 = np.random.default_rng(seeds2['b'])\n    A2 = create_spd_matrix(n2, seeds2['A'])\n    U2 = rng_u2.standard_normal((n2, k2))\n    V2 = rng_v2.standard_normal((k2, n2))\n    C2 = np.array([[2.5]])\n    b2 = rng_b2.standard_normal(n2)\n    \n    # Case 3\n    case3 = test_cases[2]\n    n3, k3, seeds3 = case3['n'], case3['k'], case3['seeds']\n    rng_u3 = np.random.default_rng(seeds3['U'])\n    rng_v3 = np.random.default_rng(seeds3['V'])\n    rng_b3 = np.random.default_rng(seeds3['b'])\n    A3 = create_spd_matrix(n3, seeds3['A'])\n    U3 = rng_u3.standard_normal((n3, k3))\n    V3 = rng_v3.standard_normal((k3, n3))\n    C3 = np.diag([1e-8, 0.5])\n    b3 = rng_b3.standard_normal(n3)\n\n    # Case 4\n    case4 = test_cases[3]\n    n4, k4, seeds4 = case4['n'], case4['k'], case4['seeds']\n    rng_u4 = np.random.default_rng(seeds4['U'])\n    rng_b4 = np.random.default_rng(seeds4['b'])\n    A4 = create_spd_matrix(n4, seeds4['A'])\n    U4 = rng_u4.standard_normal((n4, k4))\n    V4 = U4.T\n    C4 = np.diag([1.0, 2.0, 3.0])\n    b4 = rng_b4.standard_normal(n4)\n\n    # Case 5\n    case5 = test_cases[4]\n    n5, k5, seeds5 = case5['n'], case5['k'], case5['seeds']\n    rng_v5 = np.random.default_rng(seeds5['V'])\n    rng_b5 = np.random.default_rng(seeds5['b'])\n    A5 = create_spd_matrix(n5, seeds5['A'])\n    U5 = np.zeros((n5, k5))\n    V5 = rng_v5.standard_normal((k5, n5))\n    C5 = np.diag([1.0, 1.5])\n    b5 = rng_b5.standard_normal(n5)\n\n    all_params = [\n        (A, U, C, V, b),\n        (A2, U2, C2, V2, b2),\n        (A3, U3, C3, V3, b3),\n        (A4, U4, C4, V4, b4),\n        (A5, U5, C5, V5, b5)\n    ]\n    \n    for params in all_params:\n        A_p, U_p, C_p, V_p, b_p = params\n        \n        # Compute solution using Woodbury method\n        x_woodbury = solve_woodbury(A_p, U_p, C_p, V_p, b_p)\n        \n        # Compute direct solution for verification\n        M_full = A_p + U_p @ C_p @ V_p\n        x_direct = linalg.solve(M_full, b_p)\n        \n        # Compute relative discrepancy\n        discrepancy = linalg.norm(x_woodbury - x_direct) / (1 + linalg.norm(x_direct))\n        \n        results.append(discrepancy = TOL)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3599100"}, {"introduction": "当需要求解一系列具有相同低秩更新但右端项不同的线性方程组时，伍德伯里恒等式的真正计算优势才得以完全展现。这种情况在迭代法、信号处理和统计分析等领域中屡见不鲜。最后一项练习将引导你设计一个高效的算法，该算法将计算过程分解为一个一次性的“预计算”阶段和一个精简的、可重复的“求解”阶段 [@problem_id:3599117]。通过预先计算并复用关键组成部分，你可以大幅降低求解系列问题所需的总时间，从而展示如何通过分摊初始设置成本来实现显著的长期计算收益。", "problem": "要求您基于数值线性代数的基本原理，设计并实现一个算法，用于高效求解共享相同低秩更新的多个线性系统。目标是推导、证明并实现一种重用策略，用于重复求解形式为 $(A + U C V) x_i = b_i$ 的系统，其中涉及多个右端项 $b_i$。在此问题中，$A \\in \\mathbb{R}^{n \\times n}$ 是可逆矩阵，$U \\in \\mathbb{R}^{n \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$、$C \\in \\mathbb{R}^{k \\times k}$ 在所有求解过程中保持不变。您的最终程序必须实现一个直接方法和一个在所有右端项上重用预计算的加速方法，并且必须报告两者之间的量化一致性。\n\n请从数值线性代数的有效基础出发。您只能使用以下内容作为基础起点：\n- 逆矩阵的定义：对于一个可逆矩阵 $M$，$M^{-1}$ 满足 $M M^{-1} = I$。\n- 舒尔补 (Schur complement) 的定义：给定一个分块矩阵 $\\begin{bmatrix} A  B \\\\ C  D \\end{bmatrix}$，其中 $A$ 和 $D$ 为可逆方阵，$A$ 的舒尔补是 $D - C A^{-1} B$，$D$ 的舒尔补是 $A - B D^{-1} C$。\n- 从舒尔补推导出的分块矩阵求逆公式，将其视为一个经过充分检验的事实。\n\n您的任务如下：\n- 根据分块矩阵求逆公式和舒尔补定义，推导出一个关于 $A^{-1}$、$U$、$C$、$V$ 以及一个仅依赖于 $A$、$U$、$C$ 和 $V$ 的 $k \\times k$ 矩阵的逆的 $(A + U C V)^{-1}$ 的显式表达式。利用此推导解释如何通过预计算并重用 $A^{-1} U$、$V A^{-1}$ 以及一个小的 $k \\times k$ 矩阵（将此矩阵表示为 $S$）的稳定分解，来加速求解多个 $b_i$ 的方程组 $(A + U C V) x_i = b_i$。\n- 基于您的推导，设计一个算法，该算法：\n  1. 预计算并存储 $A$ 的分解，以便在后续所有求解中重用。\n  2. 在不显式构造 $A^{-1}$ 的情况下，预计算并存储 $A^{-1} U$ 和 $V A^{-1}$。\n  3. 构造您推导中得到的矩阵 $S$，并存储 $S$ 的一个稳定分解以供重用。\n  4. 对于每个右端项 $b_i$，仅使用以下操作来求解 $(A + U C V) x_i = b_i$：\n     - 使用存储的分解求解与 $A$ 和 $A^\\top$ 相关的线性系统。\n     - 使用存储的分解求解与小矩阵 $S$ 相关的线性系统。\n     - 涉及预计算的 $A^{-1} U$ 和 $V A^{-1}$ 以及固定矩阵 $C$ 的矩阵-矩阵和矩阵-向量乘法。\n- 通过对完整矩阵 $A + U C V$ 进行一次性分解来直接求解系统，并将所得解与您的加速方法产生的解进行比较，以此实现验证。\n\n您的程序必须实现这两种方法，并针对每个测试用例，报告在所有给定的右端项 $b_i$ 中，直接解和加速解之间最大的逐元素绝对差。最终输出必须是单行，包含一个浮点值列表，每个测试用例一个值，按下面列出的顺序排列。\n\n测试套件规范：\n- 测试用例 1 ($n = 5$, $k = 2$):\n  - $A \\in \\mathbb{R}^{5 \\times 5}$ 是一个三对角矩阵，主对角线元素为 $4$，第一副对角线和超对角线元素为 $-1$，即：\n    $$\n    A = \\begin{bmatrix}\n    4  -1  0  0  0 \\\\\n    -1  4  -1  0  0 \\\\\n    0  -1  4  -1  0 \\\\\n    0  0  -1  4  -1 \\\\\n    0  0  0  -1  4\n    \\end{bmatrix}.\n    $$\n  - $U \\in \\mathbb{R}^{5 \\times 2}$ 的列是 $e_1$ 和 $e_3$，即：\n    $$\n    U = \\begin{bmatrix}\n    1  0 \\\\\n    0  0 \\\\\n    0  1 \\\\\n    0  0 \\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{2 \\times 5}$ 是\n    $$\n    V = \\begin{bmatrix}\n    1  0  1  0  0 \\\\\n    0  1  0  1  0\n    \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{2 \\times 2}$ 是\n    $$\n    C = \\begin{bmatrix}\n    2  1 \\\\\n    -1  3\n    \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{5}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n    $$\n\n- 测试用例 2 ($n = 6$, $k = 1$):\n  - $A \\in \\mathbb{R}^{6 \\times 6}$ 是一个对角矩阵，对角线元素为 $1, 3, 5, 7, 9, 11$，即：\n    $$\n    A = \\operatorname{diag}(1, 3, 5, 7, 9, 11).\n    $$\n  - $U \\in \\mathbb{R}^{6 \\times 1}$ 是\n    $$\n    U = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{1 \\times 6}$ 是\n    $$\n    V = \\begin{bmatrix} 0  1  0  1  0  1 \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{1 \\times 1}$ 是标量矩阵\n    $$\n    C = \\begin{bmatrix} 10 \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{6}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 6 \\\\ 5 \\\\ 4 \\\\ 3 \\\\ 2 \\\\ 1 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n    $$\n\n- 测试用例 3 ($n = 4$, $k = 2$):\n  - $A \\in \\mathbb{R}^{4 \\times 4}$ 是一个对角矩阵，对角线元素为 $10^{-3}, 2, 3, 4$，即：\n    $$\n    A = \\operatorname{diag}(10^{-3}, 2, 3, 4).\n    $$\n  - $U \\in \\mathbb{R}^{4 \\times 2}$ 是\n    $$\n    U = \\begin{bmatrix}\n    1  0 \\\\\n    0  1 \\\\\n    1  1 \\\\\n    0  1\n    \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{2 \\times 4}$ 是\n    $$\n    V = \\begin{bmatrix}\n    1  -1  0  0 \\\\\n    0  1  1  0\n    \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{2 \\times 2}$ 是奇异矩阵，由下式给出\n    $$\n    C = \\begin{bmatrix}\n    0  1 \\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{4}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 1 \\\\ 0 \\\\ -1 \\\\ 0 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n    $$\n\n实现要求：\n- 您的程序必须为每个测试用例计算：\n  1. 直接解 $x_i^{\\mathrm{dir}}$，通过对 $A + U C V$ 执行一次性分解并求解所有给定的右端项 $b_i$ 得到。\n  2. 加速解 $x_i^{\\mathrm{acc}}$，仅使用：\n     - 对 $A$ 进行一次性分解，并重用于计算 $A^{-1} U$ 和 $A^{-1} b_i$。\n     - 一次性构造并分解一个源于您分析的 $k \\times k$ 矩阵 $S$，并为所有右端项重用。\n     - 涉及 $U$、$V$、$C$、$A^{-1} U$ 和 $V A^{-1}$ 的矩阵乘积，但绝不显式构造 $A^{-1}$。\n- 对于每个测试用例，计算在所有给定右端项 $b_i$ 上的最大逐元素绝对差 $\\max_{i} \\| x_i^{\\mathrm{dir}} - x_i^{\\mathrm{acc}} \\|_{\\infty}$。这些值必须以浮点数形式报告。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述测试用例的顺序排列。例如，如果有三个测试用例，输出必须类似于 $[r_1,r_2,r_3]$，其中每个 $r_j$ 是一个浮点数，代表测试用例 $j$ 的最大绝对差。", "solution": "### 加速公式的推导\n\n我们的目标是找到一种高效计算 $x = (A + UCV)^{-1}b$ 的方法，该方法能重用计算以处理多个右端项 $b_i$。我们将推导伍德伯里恒等式的一个变体，该变体即使在 $C$ 为奇异时也成立。\n\n考虑方程 $(A + UCV)x = b$。我们可以引入一个辅助变量 $y \\in \\mathbb{R}^k$ 并建立一个等价的方程组：\n1. $Ax + Uy = b$\n2. $-CVx + y = 0 \\implies y = CVx$\n\n将 (2) 代入 (1) 即可恢复原方程，证明了此系统的等价性。该系统可以用分块矩阵形式表示：\n$$\n\\begin{bmatrix} A   U \\\\ -CV   I_k \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} b \\\\ 0 \\end{bmatrix}\n$$\n其中 $I_k$ 是 $k \\times k$ 的单位矩阵。\n\n为了求解 $x$，我们需要计算该分块矩阵的逆。设分块矩阵为 $M$。根据分块矩阵求逆公式，我们可以得到 $M^{-1}$ 左上角的表达式，它对应于 $(A+UCV)^{-1}$。以 $A$ 为主元，其舒尔补为 $S = I_k - (-CV)A^{-1}U = I_k + CVA^{-1}U$。\n分块求逆公式的左上角块为 $A^{-1} + A^{-1}U S^{-1} (-CV) A^{-1}$。因此，\n$$\n(A+UCV)^{-1} = A^{-1} - A^{-1}U(I_k + CVA^{-1}U)^{-1}CVA^{-1}\n$$\n这个形式的伍德伯里恒等式即使在 $C$ 是奇异时也有效，只要矩阵 $S = I_k + CVA^{-1}U$ 是可逆的。\n\n要为多个右端项 $b_i$ 求解 $x_i = (A+UCV)^{-1}b_i$，我们可以应用此公式：\n$$\nx_i = \\left(A^{-1} - A^{-1}U S^{-1} CVA^{-1}\\right)b_i = A^{-1}b_i - A^{-1}U S^{-1} CV(A^{-1}b_i)\n$$\n这个表达式揭示了高效求解的策略：将计算分解为一次性的预计算阶段和针对每个 $b_i$ 的快速求解阶段。\n\n### 算法设计\n\n**直接方法算法：**\n1.  构造矩阵 $M = A + UCV$。\n2.  计算 $M$ 的 LU 分解。\n3.  对于每个右端项 $b_i$，使用 LU 分解求解 $Mx_i=b_i$。\n这种方法的主要成本在于一次性的 $O(n^3)$ 分解，后续每次求解成本为 $O(n^2)$。\n\n**加速方法算法：**\n该算法分为两个阶段：\n\n**预计算阶段（一次性）：**\n1.  **分解 A**：计算 $A$ 的 LU 分解。这将用于所有涉及 $A^{-1}$ 的操作。\n2.  **计算 $A^{-1}U$**：求解矩阵方程 $AZ = U$ 得到 $Z = A^{-1}U$。这需要使用已分解的 $A$ 进行 $k$ 次求解。存储 $Z$。\n3.  **构造并分解 S**：\n    a. 计算 $k \\times k$ 的矩阵乘积 $P = VZ = VA^{-1}U$。\n    b. 计算 $k \\times k$ 的矩阵 $S = I_k + CP$。\n    c. 计算 $S$ 的 LU 分解并存储。\n\n**求解阶段（对每个 $b_i$）：**\n对于每个 $b_i$，我们按以下步骤计算 $x_i = A^{-1}b_i - Z S^{-1} C V (A^{-1}b_i)$：\n1.  **计算 $y_i = A^{-1}b_i$**：使用 $A$ 的 LU 分解求解 $Ay_i=b_i$。\n2.  **计算 $w_i = CVy_i$**：\n    a. 计算向量 $v_i = Vy_i$。\n    b. 计算向量 $w_i = Cv_i$。\n3.  **计算 $z_i = S^{-1}w_i$**：使用 $S$ 的 LU 分解求解 $Sz_i=w_i$。\n4.  **计算修正项**：计算向量 $u_i = Zz_i$。\n5.  **计算最终解**：计算 $x_i = y_i - u_i$。\n\n这种策略的优势在于，昂贵的分解步骤（$A$ 和 $S$）只执行一次。每个新右端项的求解阶段仅涉及矩阵-向量乘法和利用已存分解的快速求解，其复杂度远低于从头开始解决整个系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef direct_solve(A, U, C, V, B):\n    \"\"\"\n    Solves (A + UCV)x_i = b_i for each column b_i in B using a direct method.\n    \"\"\"\n    n, _ = A.shape\n    num_rhs = B.shape[1]\n    \n    # 1. Form the matrix M = A + UCV\n    M = A + U @ C @ V\n    \n    # Handle singular M case that may arise in test cases.\n    if np.linalg.cond(M) > 1/np.finfo(M.dtype).eps:\n         X_dir = np.full((n, num_rhs), np.nan)\n         return X_dir\n    \n    # 2. Compute a stable factorization of M\n    try:\n        lu_M, piv_M = linalg.lu_factor(M)\n    except linalg.LinAlgError:\n        raise\n        \n    # 3. Solve for each right-hand side\n    X_dir = np.zeros((n, num_rhs))\n    for i in range(num_rhs):\n        b_i = B[:, i]\n        X_dir[:, i] = linalg.lu_solve((lu_M, piv_M), b_i)\n        \n    return X_dir\n\ndef accelerated_solve(A, U, C, V, B):\n    \"\"\"\n    Solves (A + UCV)x_i = b_i using the Woodbury matrix identity with precomputation.\n    \"\"\"\n    n, k = U.shape\n    num_rhs = B.shape[1]\n    I_k = np.eye(k)\n    X_acc = np.zeros((n, num_rhs))\n\n    # --- Precomputation Phase ---\n    try:\n        # 1. Compute a stable factorization of A\n        lu_A, piv_A = linalg.lu_factor(A)\n        \n        # 2. Compute A_inv_U = A^{-1}U\n        A_inv_U = linalg.lu_solve((lu_A, piv_A), U)\n        \n        # 3. Compute S = I_k + C * V * A^{-1} * U\n        S = I_k + C @ (V @ A_inv_U)\n\n        # 4. Compute a stable factorization of S\n        lu_S, piv_S = linalg.lu_factor(S)\n    except linalg.LinAlgError:\n        # If A or S is singular, the method fails.\n        X_acc.fill(np.nan)\n        return X_acc\n\n    # --- Per-Solve Phase ---\n    for i in range(num_rhs):\n        b_i = B[:, i]\n        \n        # 1. Compute y_i = A^{-1}b_i\n        y_i = linalg.lu_solve((lu_A, piv_A), b_i)\n        \n        # 2. Compute w_i = C * V * y_i\n        v_i = V @ y_i\n        w_i = C @ v_i\n        \n        # 3. Compute z_i = S^{-1} * w_i\n        z_i = linalg.lu_solve((lu_S, piv_S), w_i)\n        \n        # 4. Compute correction u_i = A^{-1}U * z_i\n        u_i = A_inv_U @ z_i\n        \n        # 5. Compute final solution x_i = y_i - u_i\n        X_acc[:, i] = y_i - u_i\n        \n    return X_acc\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run solvers, and print results.\n    \"\"\"\n    # Test case 1: n=5, k=2\n    A1 = np.diag([4.0]*5) + np.diag([-1.0]*4, k=1) + np.diag([-1.0]*4, k=-1)\n    U1 = np.zeros((5, 2))\n    U1[0, 0] = 1.0\n    U1[2, 1] = 1.0\n    V1 = np.array([\n        [1.0, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0, 1.0, 0.0]\n    ])\n    C1 = np.array([\n        [2.0, 1.0],\n        [-1.0, 3.0]\n    ])\n    B1 = np.array([\n        [1.0, 1.0, 1.0, 1.0, 1.0],\n        [1.0, 2.0, 3.0, 4.0, 5.0],\n        [0.0, 0.0, 0.0, 0.0, 1.0]\n    ]).T\n\n    # Test case 2: n=6, k=1\n    A2 = np.diag([1.0, 3.0, 5.0, 7.0, 9.0, 11.0])\n    U2 = np.array([[1.0, 0.0, 1.0, 0.0, 1.0, 0.0]]).T\n    V2 = np.array([[0.0, 1.0, 0.0, 1.0, 0.0, 1.0]])\n    C2 = np.array([[10.0]])\n    B2 = np.array([\n        [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n        [6.0, 5.0, 4.0, 3.0, 2.0, 1.0],\n        [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n    ]).T\n    \n    # Test case 3: n=4, k=2, C is singular\n    A3 = np.diag([1e-3, 2.0, 3.0, 4.0])\n    U3 = np.array([\n        [1.0, 0.0],\n        [0.0, 1.0],\n        [1.0, 1.0],\n        [0.0, 1.0]\n    ])\n    V3 = np.array([\n        [1.0, -1.0, 0.0, 0.0],\n        [0.0, 1.0, 1.0, 0.0]\n    ])\n    C3 = np.array([\n        [0.0, 1.0],\n        [0.0, 0.0]\n    ])\n    B3 = np.array([\n        [1.0, 1.0, 1.0, 1.0],\n        [1.0, 0.0, -1.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0]\n    ]).T\n\n    test_cases = [\n        (A1, U1, C1, V1, B1),\n        (A2, U2, C2, V2, B2),\n        (A3, U3, C3, V3, B3)\n    ]\n    \n    results = []\n    for case in test_cases:\n        A, U, C, V, B = case\n        \n        # 1. Compute direct solution\n        X_dir = direct_solve(A, U, C, V, B)\n        \n        # 2. Compute accelerated solution\n        X_acc = accelerated_solve(A, U, C, V, B)\n\n        # 3. Compute maximum absolute entrywise difference\n        # Handle NaN cases where matrices are singular\n        if np.isnan(X_dir).any() or np.isnan(X_acc).any():\n             # If both are NaN, they are consistent.\n             if np.isnan(X_dir).all() and np.isnan(X_acc).all():\n                 max_abs_diff = 0.0\n             else: # If one is NaN and the other is not, they differ.\n                 max_abs_diff = np.inf\n        else:\n            max_abs_diff = np.max(np.abs(X_dir - X_acc))\n\n        results.append(max_abs_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3599117"}]}