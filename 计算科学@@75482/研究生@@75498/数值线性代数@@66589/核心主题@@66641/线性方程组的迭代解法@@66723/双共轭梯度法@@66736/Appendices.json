{"hands_on_practices": [{"introduction": "双共轭梯度法 (BiCG) 的每一步都依赖于初始条件的正确设定。与仅需要初始猜测 $x_0$ 的方法不同，BiCG 需要一对初始残差——原始残差 $r_0$ 和影子残差 $s_0$。至关重要的是，这两个向量的双线性形式 $s_0^T r_0$ 必须非零，因为它构成了算法迭代的第一步的基础。这个练习将通过一个具体的计算，帮助你掌握如何设置这些初始量，并验证启动 BiCG 所需的关键非简并双正交性条件。[@problem_id:3585481]", "problem": "考虑一个非对称线性系统，其系数矩阵为 $A \\in \\mathbb{R}^{3 \\times 3}$，右端项为 $b \\in \\mathbb{R}^{3}$，初始猜测值为 $x_{0} \\in \\mathbb{R}^{3}$。用于非对称系统的双共轭梯度法 (BiCG) 耦合了两个 Krylov 过程，一个由 $A$ 定义，另一个由 $A^{\\top}$ 定义，并且需要两个初始残差 $r_{0}$ 和 $s_{0}$，使得耦合项 $s_{0}^{\\top} r_{0}$ 非零。从线性系统残差的基本定义出发，原始系统的初始残差定义为 $r_{0} = b - A x_{0}$。为初始化影子过程，考虑转置系统 $A^{\\top} y = \\tilde{b}$ 以及初始猜测值 $y_{0}$，并定义影子残差 $s_{0} = \\tilde{b} - A^{\\top} y_{0}$。您的任务是根据所提供的数据计算 $r_{0}$ 和 $s_{0}$，然后评估双线性形式 $s_{0}^{\\top} r_{0}$ 以验证 BiCG 所需的非退化双正交性条件。使用以下数据：\n$$\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n1  3  -2 \\\\\n0  -1  1\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix}\n1 \\\\ 0 \\\\ 2\n\\end{pmatrix}, \\quad\nx_{0} = \\begin{pmatrix}\n0 \\\\ 1 \\\\ -1\n\\end{pmatrix},\n$$\n对于影子系统，\n$$\n\\tilde{b} = \\begin{pmatrix}\n0 \\\\ 1 \\\\ 1\n\\end{pmatrix}, \\quad\ny_{0} = \\begin{pmatrix}\n1 \\\\ 0 \\\\ 0\n\\end{pmatrix}.\n$$\n从 $r_{0}$ 和 $s_{0}$ 的定义出发，精确计算 $r_{0}$ 和 $s_{0}$，然后评估 $s_{0}^{\\top} r_{0}$。请提供 $s_{0}^{\\top} r_{0}$ 的值作为最终答案。", "solution": "该问题在数值线性代数领域具有坚实的科学基础，数据完备，表述客观，因此是有效的。我们着手求解。\n\n任务是计算双线性形式 $s_{0}^{\\top} r_{0}$ 的值，这是启动双共轭梯度 (BiCG) 算法的一个关键量。这需要计算初始原始残差 $r_{0}$ 和初始影子残差 $s_{0}$。\n\n给定数据包括原始系统 $A x = b$ 的系数矩阵 $A$、右端向量 $b$ 和初始猜测值 $x_{0}$：\n$$\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n1  3  -2 \\\\\n0  -1  1\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix}\n1 \\\\ 0 \\\\ 2\n\\end{pmatrix}, \\quad\nx_{0} = \\begin{pmatrix}\n0 \\\\ 1 \\\\ -1\n\\end{pmatrix}\n$$\n对于辅助的影子系统，我们给定了右端向量 $\\tilde{b}$ 和初始猜测值 $y_{0}$：\n$$\n\\tilde{b} = \\begin{pmatrix}\n0 \\\\ 1 \\\\ 1\n\\end{pmatrix}, \\quad\ny_{0} = \\begin{pmatrix}\n1 \\\\ 0 \\\\ 0\n\\end{pmatrix}\n$$\n\n首先，我们使用其定义 $r_{0} = b - A x_{0}$ 计算原始系统的初始残差 $r_{0}$。\n我们首先计算乘积 $A x_{0}$：\n$$\nA x_{0} = \\begin{pmatrix}\n2  -1  0 \\\\\n1  3  -2 \\\\\n0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n-1\n\\end{pmatrix}\n= \\begin{pmatrix}\n(2)(0) + (-1)(1) + (0)(-1) \\\\\n(1)(0) + (3)(1) + (-2)(-1) \\\\\n(0)(0) + (-1)(1) + (1)(-1)\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 - 1 + 0 \\\\\n0 + 3 + 2 \\\\\n0 - 1 - 1\n\\end{pmatrix}\n= \\begin{pmatrix}\n-1 \\\\\n5 \\\\\n-2\n\\end{pmatrix}\n$$\n现在我们可以通过从 $b$ 中减去这个结果来找到 $r_0$：\n$$\nr_{0} = b - A x_{0} = \\begin{pmatrix}\n1 \\\\\n0 \\\\\n2\n\\end{pmatrix}\n-\n\\begin{pmatrix}\n-1 \\\\\n5 \\\\\n-2\n\\end{pmatrix}\n= \\begin{pmatrix}\n1 - (-1) \\\\\n0 - 5 \\\\\n2 - (-2)\n\\end{pmatrix}\n= \\begin{pmatrix}\n2 \\\\\n-5 \\\\\n4\n\\end{pmatrix}\n$$\n\n接下来，我们计算影子系统的初始残差 $s_{0}$。其定义为 $s_{0} = \\tilde{b} - A^{\\top} y_{0}$。\n首先，我们确定矩阵 $A$ 的转置，记为 $A^{\\top}$：\n$$\nA^{\\top} = \\begin{pmatrix}\n2  1  0 \\\\\n-1  3  -1 \\\\\n0  -2  1\n\\end{pmatrix}\n$$\n然后我们计算乘积 $A^{\\top} y_{0}$：\n$$\nA^{\\top} y_{0} = \\begin{pmatrix}\n2  1  0 \\\\\n-1  3  -1 \\\\\n0  -2  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n= \\begin{pmatrix}\n(2)(1) + (1)(0) + (0)(0) \\\\\n(-1)(1) + (3)(0) + (-1)(0) \\\\\n(0)(1) + (-2)(0) + (1)(0)\n\\end{pmatrix}\n= \\begin{pmatrix}\n2 \\\\\n-1 \\\\\n0\n\\end{pmatrix}\n$$\n现在我们可以通过从 $\\tilde{b}$ 中减去这个结果来找到 $s_0$：\n$$\ns_{0} = \\tilde{b} - A^{\\top} y_{0} = \\begin{pmatrix}\n0 \\\\\n1 \\\\\n1\n\\end{pmatrix}\n-\n\\begin{pmatrix}\n2 \\\\\n-1 \\\\\n0\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 - 2 \\\\\n1 - (-1) \\\\\n1 - 0\n\\end{pmatrix}\n= \\begin{pmatrix}\n-2 \\\\\n2 \\\\\n1\n\\end{pmatrix}\n$$\n\n最后，我们评估双线性形式 $s_{0}^{\\top} r_{0}$，也就是向量 $s_{0}$ 和 $r_{0}$ 的点积。\n$$\ns_{0}^{\\top} r_{0} = \\begin{pmatrix}\n-2  2  1\n\\end{pmatrix}\n\\begin{pmatrix}\n2 \\\\\n-5 \\\\\n4\n\\end{pmatrix}\n$$\n$$\ns_{0}^{\\top} r_{0} = (-2)(2) + (2)(-5) + (1)(4) = -4 - 10 + 4 = -10\n$$\n条件 $s_{0}^{\\top} r_{0} \\neq 0$ 得到满足，这确保了 BiCG 算法可以在第一步启动而不会崩溃。计算出的值为 $-10$。", "answer": "$$\\boxed{-10}$$", "id": "3585481"}, {"introduction": "在成功初始化 BiCG 过程之后，下一步是执行一次完整的迭代。这个核心循环涉及到计算步长 $\\alpha_0$，并用它来更新解向量、残差向量和影子残差向量。这个练习将引导你完成单次 BiCG 迭代的每一个力学步骤，展示双正交性原理如何被用来确定最优步长，以及短递推关系如何高效地更新迭代向量。[@problem_id:3585475]", "problem": "考虑线性系统 $A x = b$，其中\n$$\nA=\\begin{pmatrix}\n2  -1 \\\\\n1  3\n\\end{pmatrix}, \n\\quad \nb=\\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}.\n$$\n设初始猜测为 $x_0=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$，并定义初始残差 $r_0=b-A x_0$。设初始影子残差为 $s_0=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$，满足 $s_0^{\\top} r_0 \\neq 0$。仅使用双共轭梯度（BiCG）方法的定义性双正交原理和短递推更新结构，设 $p_0=r_0$ 和 $q_0=s_0$，并执行一次BiCG迭代以求得 $x_1$、$r_1$ 和 $s_1$。\n\n报告标量 $s_1^{\\top} r_1$ 的值。将您的最终答案精确地表示为一个有理数。只需提交 $s_1^{\\top} r_1$ 的值作为最终答案。", "solution": "该问题提法恰当、自成体系且科学上合理，因为它描述了数值线性代数中双共轭梯度（BiCG）方法的一个标准应用。所有必要的数据和初始条件均已提供。我们可以着手求解。\n\n问题要求对线性系统 $A x = b$ 执行一次双共轭梯度（BiCG）方法的迭代，其中\n$$\nA=\\begin{pmatrix}\n2  -1 \\\\\n1  3\n\\end{pmatrix}, \n\\quad \nb=\\begin{pmatrix}\n1 \\\\\n2\n\\end{pmatrix}.\n$$\n初始猜测为 $x_0=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$，给定的初始影子残差为 $s_0=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$。\n\nBiCG算法遵循一组短递推关系来更新解、残差和影子残差。我们将执行第一次迭代（$k=0$）的步骤。\n\n1.  **计算初始残差 $r_0$。**\n    残差定义为 $r_k = b - A x_k$。对于初始猜测 $x_0$，我们有：\n    $$\n    r_0 = b - A x_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 2  -1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}.\n    $$\n\n2.  **设置初始搜索方向 $p_0$ 和 $q_0$。**\n    根据问题中的规定，初始搜索方向分别设置为初始残差和初始影子残差：\n    $$\n    p_0 = r_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix},\n    $$\n    $$\n    q_0 = s_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n    $$\n    我们必须验证条件 $s_0^{\\top} r_0 \\neq 0$：\n    $$\n    s_0^{\\top} r_0 = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = (1)(1) + (1)(2) = 3 \\neq 0.\n    $$\n    条件成立。这个值 $\\rho_0 = s_0^{\\top} r_0 = 3$ 将用于下一步。\n\n3.  **计算步长 $\\alpha_0$。**\n    选择步长 $\\alpha_k$ 以强制残差的双正交性。公式为 $\\alpha_k = \\frac{s_k^{\\top} r_k}{q_k^{\\top} A p_k}$。对于 $k=0$，我们有：\n    $$\n    \\alpha_0 = \\frac{s_0^{\\top} r_0}{q_0^{\\top} A p_0}.\n    $$\n    分子为 $s_0^{\\top} r_0 = 3$。对于分母，我们首先计算矩阵向量积 $A p_0$：\n    $$\n    A p_0 = \\begin{pmatrix} 2  -1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} (2)(1) + (-1)(2) \\\\ (1)(1) + (3)(2) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 7 \\end{pmatrix}.\n    $$\n    现在我们计算分母：\n    $$\n    q_0^{\\top} A p_0 = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 7 \\end{pmatrix} = (1)(0) + (1)(7) = 7.\n    $$\n    因此步长为：\n    $$\n    \\alpha_0 = \\frac{3}{7}.\n    $$\n\n4.  **将解向量更新为 $x_1$。**\n    使用规则 $x_{k+1} = x_k + \\alpha_k p_k$ 更新解：\n    $$\n    x_1 = x_0 + \\alpha_0 p_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\frac{3}{7} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 3/7 \\\\ 6/7 \\end{pmatrix}.\n    $$\n\n5.  **将残差更新为 $r_1$，影子残差更新为 $s_1$。**\n    残差使用短递推关系进行更新。\n    对于残差 $r_1$：\n    $$\n    r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\frac{3}{7} \\begin{pmatrix} 0 \\\\ 7 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n    $$\n    对于影子残差 $s_1$，更新规则是 $s_{k+1} = s_k - \\alpha_k A^{\\top} q_k$。我们首先需要 $A^{\\top} q_0$：\n    $$\n    A^{\\top} = \\begin{pmatrix} 2  1 \\\\ -1  3 \\end{pmatrix},\n    $$\n    $$\n    A^{\\top} q_0 = \\begin{pmatrix} 2  1 \\\\ -1  3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} (2)(1) + (1)(1) \\\\ (-1)(1) + (3)(1) \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix}.\n    $$\n    现在，我们更新 $s_1$：\n    $$\n    s_1 = s_0 - \\alpha_0 A^{\\top} q_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - \\frac{3}{7} \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1 - 9/7 \\\\ 1 - 6/7 \\end{pmatrix} = \\begin{pmatrix} -2/7 \\\\ 1/7 \\end{pmatrix}.\n    $$\n\n6.  **计算最终的量 $s_1^{\\top} r_1$。**\n    问题要求计算新的影子残差 $s_1$ 和新的残差 $r_1$ 的内积的标量值。这个值将是下一次迭代中计算 $\\beta_0$ 的分子 $\\rho_1$。\n    $$\n    s_1^{\\top} r_1 = \\begin{pmatrix} -2/7  1/7 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} = \\left(-\\frac{2}{7}\\right)(1) + \\left(\\frac{1}{7}\\right)(-1) = -\\frac{2}{7} - \\frac{1}{7} = -\\frac{3}{7}.\n    $$", "answer": "$$\n\\boxed{-\\frac{3}{7}}\n$$", "id": "3585475"}, {"introduction": "从手动计算转向计算实验，使我们能够探索 BiCG 在更真实情境下的行为。众所周知，BiCG 的收敛性对其矩阵的性质和初始向量的选择极为敏感，有时会表现出不规则的收敛行为甚至崩溃。这项编程练习旨在通过一个受控实验，直观地展示理想初始条件与受扰动条件下的性能差异，从而让你对 BiCG 方法为何可能不稳定以及为何需要更稳健的变体有一个深刻的理解。[@problem_id:3585435]", "problem": "考虑使用双共轭梯度法 (BiCG) 求解线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实数方阵、非对称矩阵，$b \\in \\mathbb{R}^n$ 是一个向量。BiCG 方法是一种克雷洛夫子空间方法，其特征在于一个 Petrov–Galerkin 条件：残差相对于由 $A$ 生成的右克雷洛夫子空间和由 $A^\\top$ 生成的左克雷洛夫子空间之间的双线性形式是正交的。该方法通过迭代演化 $(x_k, r_k, \\hat{r}_k)$，其中 $r_k = b - A x_k$ 是残差，$\\hat{r}_k$ 是影子残差，并利用涉及 $A$ 和 $A^\\top$ 的内积得到的标量。如果某些内积消失（精确为零或因有限精度而有效为零），该方法可能会崩溃，导致未定义的步骤。您的任务是实现一个受控的数值实验，以说明 BiCG 收敛性对残差和影子残差与 $A$ 的左右特征向量的初始对齐的敏感依赖性。\n\n您必须通过 $A = S \\Lambda S^{-1}$ 构造一个可对角化的、具有实谱的非正规矩阵 $A$，其中 $S \\in \\mathbb{R}^{n \\times n}$ 是可逆矩阵，$\\Lambda \\in \\mathbb{R}^{n \\times n}$ 是对角矩阵，其对角线元素为互不相同的正数。设 $n = 10$，并设 $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_n)$，其中 $\\lambda_i$ 是互不相同的严格正数。使用一个固定的随机种子来生成 $S$，以使实验完全可复现。\n\n定义与 $\\lambda_i$ 相关的右特征向量 $v_i = S e_i$ 和左特征向量 $w_i$，其中 $w_i$ 是 $S^{-\\top}$ 的第 $i$ 列，即 $w_i = S^{-\\top} e_i$，$e_i$ 是 $\\mathbb{R}^n$ 中的第 $i$ 个标准基向量。选择索引 $i^\\star = 3$，并设置 $b = v_{i^\\star}$，$x_0 = 0$，$r_0 = b$。考虑以下实验设计：\n\n- 完全对齐情况：设置初始影子残差 $\\hat{r}_0 = w_{i^\\star}$，并运行 BiCG，直到相对残差 $\\|r_k\\|_2 / \\|b\\|_2$ 最多为 $\\tau = 10^{-12}$ 或达到最大迭代次数 $m = 2 n$。对于 BiCG 产生的任何必须求逆的标量分母，使用崩溃检测阈值 $\\delta = 10^{-15}$。记录收敛时的迭代次数以及是否发生崩溃。\n\n- 扰动情况：对于 $\\varepsilon \\in \\{10^{-12}, 10^{-6}, 10^{-2}\\}$，每个 $\\varepsilon$ 执行 $T = 20$ 次独立试验，每次试验取 $\\hat{r}_0 = w_{i^\\star} + \\varepsilon \\xi$，其中 $\\xi \\in \\mathbb{R}^n$ 是一个具有独立标准正态分布条目的向量，在相同的固定随机种子下生成。\n    - 对于每次试验，使用相同的停止容差 $\\tau$、迭代上限 $m$ 和崩溃阈值 $\\delta$ 运行 BiCG。\n    - 对于每个 $\\varepsilon$，计算成功运行（即在未发生崩溃的情况下达到容差的运行）的平均迭代次数；如果给定 $\\varepsilon$ 的所有试验都崩溃，则将平均值定义为 $-1.0$。同时记录 $T$ 次试验中的总崩溃次数。\n\n- 真实崩溃边界情况：设置 $\\hat{r}_0 = w_j$ 其中 $j \\neq i^\\star$（选择 $j = (i^\\star \\bmod n) + 1$ 以确保 $j \\neq i^\\star$）并运行 BiCG 一次。在这种情况下，$\\hat{r}_0^\\top r_0 = 0$，方法在第一次迭代时会遇到真正的崩溃。记录一个布尔值，指示是否检测到崩溃。\n\n您的程序必须直接根据与 $A$ 和 $A^\\top$ 的矩阵-向量乘积来实现 BiCG 方法，并且必须包含当任何必需的标量分母的绝对值低于 $\\delta$ 时对崩溃的显式检测。\n\n测试套件规范：\n- 矩阵大小：$n = 10$。\n- 特征值：$\\lambda_i$ 是严格正且互不相同的，确定性地选择。\n- 随机种子：固定，并用于构造 $S$ 和所有扰动。\n- 容差：相对残差容差 $\\tau = 10^{-12}$，最大迭代次数 $m = 2 n$，崩溃阈值 $\\delta = 10^{-15}$。\n- 情况：\n    1. 完全对齐：$\\hat{r}_0 = w_{i^\\star}$。\n    2. 扰动：$\\varepsilon \\in \\{10^{-12}, 10^{-6}, 10^{-2}\\}$，每个 $T=20$ 次试验。\n    3. 真实崩溃：$\\hat{r}_0 = w_j$ 且 $j \\neq i^\\star$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含：\n    1. 完全对齐情况下的整数迭代次数。\n    2. 完全对齐情况下的布尔类型崩溃标志。\n    3. 对于 $\\varepsilon = 10^{-12}$，成功运行的浮点型平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    4. 对于 $\\varepsilon = 10^{-12}$，$T$ 次试验中的整数崩溃次数。\n    5. 对于 $\\varepsilon = 10^{-6}$，成功运行的浮点型平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    6. 对于 $\\varepsilon = 10^{-6}$，$T$ 次试验中的整数崩溃次数。\n    7. 对于 $\\varepsilon = 10^{-2}$，成功运行的浮点型平均迭代次数（如果所有试验都崩溃，则为 $-1.0$）。\n    8. 对于 $\\varepsilon = 10^{-2}$，$T$ 次试验中的整数崩溃次数。\n    9. 真实崩溃边界情况下的布尔类型崩溃标志。\n\n输出列表中的所有条目都必须是基本类型：整数、浮点数和布尔值。此问题不涉及物理单位。也不涉及角度。[@problem_id:407]", "solution": "该问题要求实现一个数值实验，以展示双共轭梯度 (BiCG) 方法的收敛性对初始残差向量和影子残差向量对齐情况的敏感性。这涉及构造一个具有已知特征系统的非正规矩阵，并使用旨在探究其稳定性和崩溃条件的特定初始向量来运行 BiCG。\n\nBiCG 方法是一种用于求解大型稀疏非对称线性方程组 $A x = b$ 的迭代算法。它是一种克雷洛夫子空间方法，生成一系列近似解 $x_k$，使得残差 $r_k = b - A x_k$ 满足 Petrov-Galerkin 条件。此条件要求残差 $r_k$ 与由矩阵转置 $A^\\top$ 生成的克雷洛夫子空间正交。具体来说，$r_k \\perp \\mathcal{K}_k(A^\\top, \\hat{r}_0)$，其中 $\\mathcal{K}_k(A^\\top, \\hat{r}_0) = \\mathrm{span}\\{\\hat{r}_0, A^\\top \\hat{r}_0, \\dots, (A^\\top)^{k-1} \\hat{r}_0\\}$ 是“左”或“影子”克雷洛夫子空间，而 $\\hat{r}_0$ 是一个选定的初始影子残差。迭代解 $x_k$ 从仿射克雷洛夫子空间 $x_0 + \\mathcal{K}_k(A, r_0)$ 中选取。\n\n标准的 BiCG 算法可概括如下。给定一个初始猜测值 $x_0$ 和一个初始影子残差 $\\hat{r}_0$：\n\n1.  初始化：\n    $r_0 = b - A x_0$\n    $p_0 = r_0$\n    $\\hat{p}_0 = \\hat{r}_0$\n    $\\rho_0 = \\hat{r}_0^\\top r_0$\n\n2.  对 $k = 0, 1, 2, \\ldots$ 进行迭代：\n    a.  $v_k = A p_k$\n    b.  $\\alpha_k = \\frac{\\rho_k}{\\hat{p}_k^\\top v_k}$\n    c.  $x_{k+1} = x_k + \\alpha_k p_k$\n    d.  $r_{k+1} = r_k - \\alpha_k v_k$\n    e.  $\\hat{r}_{k+1} = \\hat{r}_k - \\alpha_k A^\\top\\hat{p}_k$\n    f.  $\\rho_{k+1} = \\hat{r}_{k+1}^\\top r_{k+1}$\n    g.  $\\beta_k = \\frac{\\rho_{k+1}}{\\rho_k}$\n    h.  $p_{k+1} = r_{k+1} + \\beta_k p_k$\n    i.  $\\hat{p}_{k+1} = \\hat{r}_{k+1} + \\beta_k \\hat{p}_k$\n\n该算法在每次迭代中需要对两个标量进行求逆：$\\rho_k = \\hat{r}_k^\\top r_k$ 和 $\\hat{p}_k^\\top A p_k$。如果这两个量中的任何一个为零（或在数值上接近于零），算法就会崩溃。\n-   当 $\\rho_k \\approx 0$ 时发生的崩溃通常被称为“真实”崩溃。它意味着新的残差 $r_k$ 与影子残差 $\\hat{r}_k$ 几乎正交。\n-   当 $\\hat{p}_k^\\top A p_k \\approx 0$ 时发生的崩溃是“Lanczos 型”崩溃。\n\n本实验旨在通过仔细选择矩阵 $A$ 和初始向量来研究这些崩溃条件。矩阵 $A$ 被构造为 $A = S \\Lambda S^{-1}$，其中 $\\Lambda$ 是特征值 $\\lambda_i$ 构成的对角矩阵。$S$ 的列（记为 $v_i$）是 $A$ 的右特征向量，$S^{-\\top}$ 的列（记为 $w_i$）是 $A$ 的左特征向量。它们满足 $A v_i = \\lambda_i v_i$ 和 $A^\\top w_i = \\lambda_i w_i$。这些向量的一个关键性质是它们的双正交性：$w_j^\\top v_i = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ 符号。\n\n实验将初始残差设为 $r_0 = b = v_{i^\\star}$，其中 $i^\\star$ 是一个选定的索引。然后改变初始影子残差 $\\hat{r}_0$。\n\n**完全对齐情况：** 我们设置 $\\hat{r}_0 = w_{i^\\star}$。初始内积为 $\\rho_0 = \\hat{r}_0^\\top r_0 = w_{i^\\star}^\\top v_{i^\\star} = 1$。由于 $r_0$ 是一个特征向量，对于任何 $k \\geq 1$，克雷洛夫子空间 $\\mathcal{K}_k(A, r_0)$ 都是一维的。精确解是 $x = (1/\\lambda_{i^\\star}) v_{i^\\star}$，BiCG 应该在一次迭代中找到一个与 $v_{i^\\star}$ 成比例的解。残差 $r_1$ 应变为零（或数值上可忽略不计），从而在一步内收敛。\n\n**真实崩溃边界情况：** 我们设置 $\\hat{r}_0 = w_j$ 其中 $j \\neq i^\\star$。由于双正交性，初始内积为 $\\rho_0 = \\hat{r}_0^\\top r_0 = w_j^\\top v_{i^\\star} = 0$。这在计算 $\\beta_{-1}$（概念上的）或在某些公式中尝试计算 $\\alpha_0$ 时，会在第 0 次迭代时强制立即崩溃。在我们选择的算法中，由于 $\\rho_0$ 为零，这将导致初始崩溃。\n\n**扰动情况：** 我们设置 $\\hat{r}_0 = w_{i^\\star} + \\varepsilon \\xi$，其中 $\\xi$ 是一个随机向量。对于非常小的 $\\varepsilon$，$\\hat{r}_0$ 与 $w_{i^\\star}$ 几乎对齐，但包含其他左特征向量的微小分量。\n$\\rho_0 = (w_{i^\\star} + \\varepsilon \\xi)^\\top v_{i^\\star} = w_{i^\\star}^\\top v_{i^\\star} + \\varepsilon \\xi^\\top v_{i^\\star} = 1 + \\varepsilon (\\xi^\\top v_{i^\\star})$。\n虽然 $\\rho_0$ 不为零，但随后的迭代值 $\\rho_k$ 可能会变得非常小，导致接近崩溃的条件。这可能引起数值不稳定性，表现为不稳定的收敛或在几次迭代后崩溃。随着 $\\varepsilon$ 的增加，$\\hat{r}_0$ 变得更像一个“通用”向量，BiCG 的性能预计会变得更典型，收敛的迭代次数与 $A$ 的条件数及其特征值的分布有关，对于 $n=10$ 来说，这个次数应该很小。该实验通过测量不同扰动幅度 $\\varepsilon$ 下的平均迭代次数和崩溃频率来量化这种行为。\n\n该实现将构造指定的矩阵 $A \\in \\mathbb{R}^{10 \\times 10}$，执行 BiCG 算法，同时仔细监控分母 $\\rho_k$ 和 $\\hat{p}_k^\\top A p_k$，并记录每种实验情况的结果。这将为 BiCG 方法的理论性质和失效模式提供定量的证明。", "answer": "```python\n# 完整且可运行的 Python 3 代码如下。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\n\n# from scipy import ...\n\ndef run_bicg(A, b, x0, r0_hat, tol, max_iter, breakdown_thresh):\n    \"\"\"\n    实现双共轭梯度 (BiCG) 方法。\n    \n    返回：\n        (int, bool)：一个元组，包含迭代次数和一个布尔类型的崩溃标志。\n    \"\"\"\n    x = x0.copy()\n    r = b - A @ x\n    r_hat = r0_hat.copy()\n\n    norm_b = np.linalg.norm(b)\n    if norm_b == 0.0:\n        return 0, False\n\n    rho = np.dot(r_hat, r)\n    if abs(rho)  breakdown_thresh:\n        return 0, True  # 初始崩溃\n\n    p = r.copy()\n    p_hat = r_hat.copy()\n    A_T = A.T\n\n    for k in range(max_iter):\n        v = A @ p\n        denom_alpha = np.dot(p_hat, v)\n\n        if abs(denom_alpha)  breakdown_thresh:\n            return k, True\n\n        alpha = rho / denom_alpha\n        x += alpha * p\n        r -= alpha * v\n        \n        if np.linalg.norm(r) / norm_b = tol:\n            return k + 1, False\n\n        r_hat -= alpha * (A_T @ p_hat)\n\n        rho_next = np.dot(r_hat, r)\n        \n        if abs(rho_next)  breakdown_thresh:\n            # 在成功一步后检测到崩溃\n            return k + 1, True\n\n        beta = rho_next / rho\n        p = r + beta * p\n        p_hat = r_hat + beta * p_hat\n        rho = rho_next\n\n    return max_iter, False # 未在最大迭代次数内收敛\n\ndef solve():\n    \"\"\"\n    主函数，用于运行数值实验并打印结果。\n    \"\"\"\n    # 测试套件规范\n    n = 10\n    i_star = 3\n    i_star_idx = i_star - 1\n    tau = 1e-12\n    m = 2 * n\n    delta = 1e-15\n    epsilons = [1e-12, 1e-6, 1e-2]\n    T = 20\n    seed = 42\n    \n    rng = np.random.default_rng(seed)\n\n    # 构造矩阵 A\n    Lambda_diag = np.arange(1.0, n + 1.0)\n    Lambda = np.diag(Lambda_diag)\n    S = rng.random((n, n))\n    S_inv = np.linalg.inv(S)\n    A = S @ Lambda @ S_inv\n    \n    # 获取左右特征向量\n    S_inv_T = S_inv.T\n    v_istar = S[:, i_star_idx]\n    w_istar = S_inv_T[:, i_star_idx]\n    \n    # 通用设置\n    b = v_istar.copy()\n    x0 = np.zeros(n)\n    \n    results = []\n\n    # 情况1：完全对齐\n    r0_hat_perfect = w_istar.copy()\n    iters_perfect, breakdown_perfect = run_bicg(A, b, x0, r0_hat_perfect, tau, m, delta)\n    results.extend([iters_perfect, breakdown_perfect])\n\n    # 情况2：扰动情况\n    for eps in epsilons:\n        total_iterations = 0\n        successful_runs = 0\n        breakdown_count = 0\n        \n        for _ in range(T):\n            xi = rng.standard_normal(n)\n            r0_hat_pert = w_istar + eps * xi\n            iters, breakdown = run_bicg(A, b, x0, r0_hat_pert, tau, m, delta)\n            \n            if breakdown:\n                breakdown_count += 1\n            else:\n                successful_runs += 1\n                total_iterations += iters\n        \n        if successful_runs > 0:\n            avg_iters = float(total_iterations) / successful_runs\n        else:\n            avg_iters = -1.0\n            \n        results.extend([avg_iters, breakdown_count])\n\n    # 情况3：真实崩溃边界情况\n    j = (i_star % n) + 1\n    j_idx = j - 1\n    w_j = S_inv_T[:, j_idx]\n    \n    r0_hat_breakdown = w_j.copy()\n    _, breakdown_true = run_bicg(A, b, x0, r0_hat_breakdown, tau, m, delta)\n    results.append(breakdown_true)\n\n    # 格式化并打印最终输出\n    print(f\"[{results[0]},{str(results[1]).lower()},{results[2]},{results[3]},{results[4]},{results[5]},{results[6]},{results[7]},{str(results[8]).lower()}]\")\n\nsolve()\n\n```", "id": "3585435"}]}