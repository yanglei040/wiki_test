{"hands_on_practices": [{"introduction": "隐式Q定理断言了在特定条件下Hessenberg分解的唯一性。本练习旨在通过一个具体的计算来直接验证这一定理的核心结论[@problem_id:3589427]。你将看到，两个满足定理条件的酉矩阵 $Q$ 和 $\\widehat{Q}$ 确实通过一个对角元素为 $\\pm 1$ 的对角矩阵 $D$ 相关联，从而加深对该定理本质的理解。", "problem": "设 $A \\in \\mathbb{R}^{5 \\times 5}$ 为上 Hessenberg 矩阵\n$$\nA=\\begin{pmatrix}\n2 & 3 & 0 & 0 & 0 \\\\\n4 & 1 & -1 & 0 & 0 \\\\\n0 & 2 & 0 & 5 & 0 \\\\\n0 & 0 & -3 & 4 & 6 \\\\\n0 & 0 & 0 & 1 & -2\n\\end{pmatrix},\n$$\n并设 $Q=\\mathrm{I}_{5}$ 和 $\\widehat{Q}=\\mathrm{diag}(1,-1,-1,1,-1) \\in \\mathbb{R}^{5 \\times 5}$。$Q$ 和 $\\widehat{Q}$ 都是实正交矩阵。定义 $H=Q^{\\top} A Q$ 和 $\\widehat{H}=\\widehat{Q}^{\\top} A \\widehat{Q}$。注意 $Q e_{1}=\\widehat{Q} e_{1}=e_{1}$，其中 $e_{1} \\in \\mathbb{R}^{5}$ 是第一个标准基向量。假设 $H$ 是未约化的（unreduced），意味着其所有次对角线元素都非零。\n\n仅使用关于正交相似和上 Hessenberg 矩阵结构定义的核心定义，首先推导为什么在 $H$ 和 $\\widehat{H}$ 都是上 Hessenberg 矩阵且 $Q e_{1}=\\widehat{Q} e_{1}$ 的条件下，矩阵 $D=Q^{\\top} \\widehat{Q}$ 必须是对角矩阵，且其元素属于 $\\{\\pm 1\\}$。\n\n然后，对于上面给出的具体 $A$、$Q$ 和 $\\widehat{Q}$，计算 $D$ 并数值验证它是一个对角元素为 $\\pm 1$ 的对角矩阵。最后，给出 $\\det(D)$ 的值。最终数值答案需表示为精确值，无需四舍五入。", "solution": "此问题经评估有效。它在数值线性代数领域有坚实的科学基础，是自洽且适定的。所有给定的数据和条件都是一致的，并且足以得到唯一解。\n\n该问题要求完成三件事：\n1.  一个理论推导，说明为什么在给定条件下，矩阵 $D = Q^{\\top} \\widehat{Q}$ 必须是一个对角元素属于 $\\{\\pm 1\\}$ 的对角矩阵。\n2.  对给定的具体矩阵进行数值计算和验证此性质。\n3.  计算 $\\det(D)$。\n\n我们将按顺序解决这些问题。\n\n### 1. 理论推导\n\n设 $A \\in \\mathbb{R}^{n \\times n}$。给定 $A$ 的两个将其转换为上 Hessenberg 形式 $H$ 和 $\\widehat{H}$ 的正交相似变换。\n$H = Q^{\\top} A Q$\n$\\widehat{H} = \\widehat{Q}^{\\top} A \\widehat{Q}$\n这里，$Q$ 和 $\\widehat{Q}$ 是 $n \\times n$ 的正交矩阵。矩阵 $H$ 和 $\\widehat{H}$ 是上 Hessenberg 矩阵，意味着当 $i > j+1$ 时，它们的元素 $h_{ij}$ 和 $\\widehat{h}_{ij}$ 为零。\n我们还被告知 $H$ 是未约化的，这意味着其所有第一条次对角线上的元素都非零：对于 $j=1, \\dots, n-1$，$h_{j+1, j} \\neq 0$。\n一个关键条件是 $Q$ 和 $\\widehat{Q}$ 的第一列相同。设 $e_1$ 是第一个标准基向量。$Q$ 的第一列是 $Qe_1$，$ \\widehat{Q}$ 的第一列是 $\\widehat{Q}e_1$。给定的条件是 $Qe_1 = \\widehat{Q}e_1$。在具体问题中，这个条件是 $Qe_1 = \\widehat{Q}e_1 = e_1$，但一般性证明对任何相同的第一列都成立。\n\n我们定义矩阵 $D = Q^{\\top} \\widehat{Q}$。由于 $Q$ 和 $\\widehat{Q}$ 是正交的，它们的乘积 $D$ 也是正交的：\n$D^{\\top} D = (\\widehat{Q}^{\\top} Q) (Q^{\\top} \\widehat{Q}) = \\widehat{Q}^{\\top} (Q Q^{\\top}) \\widehat{Q} = \\widehat{Q}^{\\top} I \\widehat{Q} = \\widehat{Q}^{\\top} \\widehat{Q} = I$。\n\n根据 $H$ 和 $\\widehat{H}$ 的定义，我们可以将 $A$ 表示为 $A = Q H Q^{\\top}$ 和 $A = \\widehat{Q} \\widehat{H} \\widehat{Q}^{\\top}$。\n令这两个关于 $A$ 的表达式相等：\n$Q H Q^{\\top} = \\widehat{Q} \\widehat{H} \\widehat{Q}^{\\top}$\n左乘 $Q^{\\top}$：\n$H Q^{\\top} = (Q^{\\top} \\widehat{Q}) \\widehat{H} \\widehat{Q}^{\\top}$\n右乘 $\\widehat{Q}$：\n$H (Q^{\\top} \\widehat{Q}) = (Q^{\\top} \\widehat{Q}) \\widehat{H} (\\widehat{Q}^{\\top} \\widehat{Q})$\n代入 $D = Q^{\\top} \\widehat{Q}$：\n$H D = D \\widehat{H}$。这被称为 Francis-Kublanovskaya 方程。\n\n现在，我们来分析 $D$ 的结构。\n条件 $Qe_1 = \\widehat{Q}e_1$ 可以通过左乘 $Q^{\\top}$ 来改写：\n$Q^{\\top} Q e_1 = Q^{\\top} \\widehat{Q} e_1$\n$I e_1 = D e_1$\n$e_1 = D e_1$\n这意味着矩阵 $D$ 的第一列是向量 $e_1 = (1, 0, \\dots, 0)^{\\top}$。\n\n我们对 $D$ 的列进行归纳。设 $D$ 的列为 $d_1, d_2, \\dots, d_n$。我们已经证明了 $d_1 = e_1$。\n方程 $HD = D\\widehat{H}$ 可以逐列写出。对于第 $j$ 列：\n$H d_j = (D\\widehat{H})_j = \\sum_{k=1}^{n} d_k \\widehat{h}_{kj}$\n由于 $\\widehat{H}$ 是上 Hessenberg 矩阵，当 $k > j+1$ 时 $\\widehat{h}_{kj} = 0$。因此，求和可以截断为：\n$H d_j = \\sum_{k=1}^{j+1} d_k \\widehat{h}_{kj} = d_1 \\widehat{h}_{1j} + \\dots + d_j \\widehat{h}_{jj} + d_{j+1} \\widehat{h}_{j+1,j}$\n\n我们将其应用于 $j=1$ 的情况：\n$H d_1 = d_1 \\widehat{h}_{11} + d_2 \\widehat{h}_{21}$\n由于 $d_1 = e_1$，这变为：\n$H e_1 = e_1 \\widehat{h}_{11} + d_2 \\widehat{h}_{21}$\n向量 $H e_1$ 是 $H$ 的第一列。由于 $H$ 是上 Hessenberg 矩阵，该列为 $(h_{11}, h_{21}, 0, \\dots, 0)^{\\top}$。\n所以，$\\begin{pmatrix} h_{11} \\\\ h_{21} \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{pmatrix} \\widehat{h}_{11} + d_2 \\widehat{h}_{21}$。\n这就给出了一个关于 $d_2$ 分量的方程组。设 $d_2 = (d_{12}, d_{22}, \\dots, d_{n2})^{\\top}$。\n$h_{11} = \\widehat{h}_{11} + d_{12} \\widehat{h}_{21}$\n$h_{21} = d_{22} \\widehat{h}_{21}$\n$0 = d_{i2} \\widehat{h}_{21}$ for $i > 2$。\n\n在求解 $d_2$ 之前，我们必须确定 $\\widehat{h}_{21} \\neq 0$。\n我们有 $HD = D\\widehat{H}$，所以 $H = D\\widehat{H}D^{\\top}$。\n$h_{j+1,j} = e_{j+1}^{\\top} H e_j = e_{j+1}^{\\top} (D \\widehat{H} D^{\\top}) e_j$。\n我们归纳假设对于 $k=1, \\dots, j$，$d_k = \\sigma_k e_k$，其中 $|\\sigma_k|=1$。我们已知 $d_1 = e_1$。\n则 $D^{\\top}e_j = (d_1, \\dots, d_j, \\dots, d_n)^{\\top} e_j = d_j^{\\top} = \\sigma_j e_j^{\\top}$。\n并且 $e_{j+1}^{\\top} D = (e_{j+1}^{\\top} d_1, \\dots, e_{j+1}^{\\top} d_n) = (0, \\dots, 0, e_{j+1}^{\\top} d_{j+1}, \\dots)$。\n我们继续从 $H d_j = \\dots$ 开始论证。\n归纳假设对于 $k \\le j$，$d_k = \\sigma_k e_k$，其中 $\\sigma_k \\in \\{\\pm 1\\}$ 且 $\\sigma_1 = 1$。\n这意味着 $D$ 的前 $j$ 列构成对角形式。\n我们来分析第 $j$ 列的关系：\n$\\widehat{h}_{j+1,j} d_{j+1} = H d_j - \\sum_{k=1}^{j} d_k \\widehat{h}_{kj} = H (\\sigma_j e_j) - \\sum_{k=1}^{j} (\\sigma_k e_k) \\widehat{h}_{kj}$\n$\\widehat{h}_{j+1,j} d_{j+1} = \\sigma_j \\sum_{i=1}^{j+1} h_{ij} e_i - \\sum_{k=1}^{j} \\sigma_k \\widehat{h}_{kj} e_k$\n$\\widehat{h}_{j+1,j} d_{j+1} = \\sum_{k=1}^{j} (\\sigma_j h_{kj} - \\sigma_k \\widehat{h}_{kj}) e_k + \\sigma_j h_{j+1,j} e_{j+1}$\n\n由于 $D$ 是正交矩阵，其列向量是标准正交的。因为对于 $k \\le j$，$d_k = \\sigma_k e_k$，$d_{j+1}$ 必须与 $e_1, \\dots, e_j$ 正交。这意味着 $d_{j+1}$ 的前 $j$ 个分量必须为零。\n看我们关于 $\\widehat{h}_{j+1,j} d_{j+1}$ 的表达式，其对于指标 $k \\le j$ 的分量必须为零。\n这意味着对于 $k \\le j$，$\\sigma_j h_{kj} - \\sigma_k \\widehat{h}_{kj} = 0$。\n因此，$d_{j+1}$ 的表达式简化为：\n$\\widehat{h}_{j+1,j} d_{j+1} = \\sigma_j h_{j+1,j} e_{j+1}$\n\n由于 $H$ 是未约化的，$h_{j+1,j} \\neq 0$。这意味着等式右边是一个非零向量。\n因此，我们必须有 $\\widehat{h}_{j+1,j} \\neq 0$（所以 $\\widehat{H}$ 也是未约化的），并且我们可以解出 $d_{j+1}$：\n$d_{j+1} = \\frac{\\sigma_j h_{j+1,j}}{\\widehat{h}_{j+1,j}} e_{j+1}$\n因为 $d_{j+1}$ 必须是单位向量（正交矩阵的一列），所以标量系数的绝对值必须为 1。\n所以，$d_{j+1} = \\sigma_{j+1} e_{j+1}$，其中 $\\sigma_{j+1} = \\pm 1$。\n归纳法对 $j=1, \\dots, n-1$ 成立。所以对于 $k=1, \\dots, n$，$d_k = \\sigma_k e_k$。\n这意味着 $D$ 是一个对角矩阵，其对角元素为 $d_{kk} = \\sigma_k \\in \\{\\pm 1\\}$。\n理论推导到此完成。这个结果是隐式Q定理（Implicit Q theorem）的关键部分，该定理确立了 Hessenberg 分解的本质唯一性。\n\n### 2. 数值验证\n\n给定具体矩阵：\n$Q = \\mathrm{I}_{5} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 1 \\end{pmatrix}$\n$\\widehat{Q} = \\mathrm{diag}(1,-1,-1,1,-1) = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 \\end{pmatrix}$\n\n我们需要计算 $D = Q^{\\top} \\widehat{Q}$。\n由于 $Q = I_5$，其转置也是单位矩阵，$Q^{\\top} = I_5$。\n因此，$D = I_5 \\widehat{Q} = \\widehat{Q}$。\n$D = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 \\end{pmatrix}$\n\n计算出的矩阵 $D$ 确实是一个对角矩阵，并且其所有对角元素均为 $1$ 或 $-1$。这在数值上验证了理论推导的结论。\n\n### 3. 计算 $\\det(D)$\n\n对角矩阵的行列式是其对角元素的乘积。\n$D$ 的对角元素是 $1, -1, -1, 1, -1$。\n$\\det(D) = (1) \\times (-1) \\times (-1) \\times (1) \\times (-1)$\n$\\det(D) = (1) \\times (1) \\times (-1)$\n$\\det(D) = -1$", "answer": "$$\\boxed{-1}$$", "id": "3589427"}, {"introduction": "任何一个严谨的数学定理都有其成立的边界，而这些边界正是由其假设条件所界定。隐式Q定理的一个关键假设是Hessenberg矩阵必须是“不可约”的。本练习将引导你探索当此关键条件不满足时会发生什么[@problem_id:3589422]。通过构造一个具体的反例，你将证明对于一个“可约”的Hessenberg矩阵，唯一性结论不再成立，从而深刻理解“不可约”假设的必要性。", "problem": "考虑以下定义：上Hessenberg矩阵是一个方阵，其第一条次对角线下方所有元素均为零；非约化的上Hessenberg矩阵是其次对角线上的每个元素都非零的矩阵；约化的上Hessenberg矩阵是其次对角线上至少有一个零元素的矩阵；酉矩阵是一个方阵 $\\mathcal{U}$，满足 $\\mathcal{U}^{*}\\mathcal{U}=I$，其中 $I$ 是单位矩阵，$\\mathcal{U}^{*}$ 表示共轭转置。隐式 $Q$ 定理断言了在适当条件下，保持非约化Hessenberg形式的酉相似变换具有唯一性，并且其非约化性假设是必要的。你的任务是当非约化性不成立时，明确构造一个唯一性的反例，并计算一个标量以验证该构造。\n\n令\n$$\nH=\\begin{pmatrix}\n0 & 1 & 4 & 0 \\\\\n2 & 0 & 5 & 6 \\\\\n0 & 0 & 2 & 1 \\\\\n0 & 0 & 1 & 3\n\\end{pmatrix},\n$$\n这是一个上Hessenberg矩阵，在位置 $(3,2)$ 处有一个零次对角线元素，因此是约化的。对于一个角度 $\\theta\\in\\mathbb{R}$，定义酉矩阵族\n$$\nU(\\theta)=\\operatorname{diag}\\!\\big(1,\\,1,\\,R(\\theta)\\big),\\quad R(\\theta)=\\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{pmatrix}.\n$$\n显然，对于所有 $\\theta$，都有 $U(\\theta)e_{1}=e_{1}$。你将证明对于所有 $\\theta$，$U(\\theta)^{*}HU(\\theta)$ 都是上Hessenberg矩阵，但对于非零的 $\\theta$ 值，$U(\\theta)$ 并非对角矩阵。\n\n从基本原理出发，推导保证上Hessenberg形式在此相似变换下得以保持的结构不变性，然后确定唯一的 $\\theta\\in(0,\\pi/2)$（以弧度为单位），使得 $U(\\theta)^{*}HU(\\theta)$ 的 $(4,3)$ 元素等于 $0$。以弧度为单位，用闭式解析表达式给出 $\\theta$ 的最终答案。无需四舍五入，最终的方框表达式内不应包含单位。构造和推导的细节必须根据所述定义以及酉相似和分块矩阵的基本性质加以证明。", "solution": "该问题要求当非约化Hessenberg假设不满足时，为隐式 $Q$ 定理的唯一性条款构造一个反例。给定一个约化的上Hessenberg矩阵 $H$ 和一个酉矩阵族 $U(\\theta)$，我们必须证明相似变换 $U(\\theta)^* H U(\\theta)$ 对所有 $\\theta$ 都保持上Hessenberg形式，从而证明唯一性的失效。最后，我们必须计算一个特定的 $\\theta$ 值，使得变换后矩阵的某个特定元素为零。\n\n首先，我们验证给定信息。矩阵 $H$ 由下式给出\n$$\nH=\\begin{pmatrix}\n0 & 1 & 4 & 0 \\\\\n2 & 0 & 5 & 6 \\\\\n0 & 0 & 2 & 1 \\\\\n0 & 0 & 1 & 3\n\\end{pmatrix}.\n$$\n这是一个上Hessenberg矩阵，因为所有满足 $i > j+1$ 的元素均为零。具体来说，元素 $h_{31}$、$h_{41}$ 和 $h_{42}$ 均为零。该矩阵是约化的，因为次对角线元素 $h_{32}$ 为 $0$。矩阵族 $U(\\theta)$ 由下式给出\n$$\nU(\\theta)=\\operatorname{diag}\\!\\big(1,\\,1,\\,R(\\theta)\\big) = \\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & \\cos\\theta & -\\sin\\theta \\\\\n0 & 0 & \\sin\\theta & \\cos\\theta\n\\end{pmatrix}.\n$$\n对于每个 $\\theta \\in \\mathbb{R}$，$U(\\theta)$ 都是一个实正交矩阵，因此是酉矩阵。它的共轭转置是它的转置，$U(\\theta)^* = U(\\theta)^T$。条件 $U(\\theta)e_1 = e_1$ 对所有 $\\theta$ 都满足，因为 $U(\\theta)$ 的第一列是 $(1,0,0,0)^T$。\n\n这个问题的关键结构特征源于零次对角线元素 $h_{32}=0$。这使得我们可以对矩阵 $H$ 和 $U(\\theta)$ 进行相容的分块。我们使用一个 $2 \\times 2$ 的分块结构，其中每个分块都是一个 $2 \\times 2$ 的矩阵。\n$$\nH = \\begin{pmatrix} H_{11} & H_{12} \\\\ H_{21} & H_{22} \\end{pmatrix}, \\quad U(\\theta) = \\begin{pmatrix} I_2 & 0 \\\\ 0 & R(\\theta) \\end{pmatrix},\n$$\n其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$0$ 是 $2 \\times 2$ 零矩阵。$H$ 的分块为：\n$$\nH_{11} = \\begin{pmatrix} 0 & 1 \\\\ 2 & 0 \\end{pmatrix}, \\quad H_{12} = \\begin{pmatrix} 4 & 0 \\\\ 5 & 6 \\end{pmatrix}, \\quad H_{21} = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}, \\quad H_{22} = \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix}.\n$$\n关键的观察是 $H_{21}$ 是零矩阵。这是元素 $h_{31}, h_{41}, h_{32}, h_{42}$ 均为零的直接结果。特别是，指定的 $h_{32}$ 处的零元素对于此分块结构至关重要。\n\n现在，我们来计算相似变换 $\\tilde{H}(\\theta) = U(\\theta)^*HU(\\theta)$。由于 $U(\\theta)$ 是实矩阵，所以 $U(\\theta)^* = U(\\theta)^T$。\n$$\n\\tilde{H}(\\theta) = \\begin{pmatrix} I_2 & 0 \\\\ 0 & R(\\theta)^T \\end{pmatrix} \\begin{pmatrix} H_{11} & H_{12} \\\\ H_{21} & H_{22} \\end{pmatrix} \\begin{pmatrix} I_2 & 0 \\\\ 0 & R(\\theta) \\end{pmatrix}.\n$$\n使用分块矩阵乘法法则：\n$$\n\\tilde{H}(\\theta) = \\begin{pmatrix} I_2 H_{11} I_2 & I_2 H_{12} R(\\theta) \\\\ R(\\theta)^T H_{21} I_2 & R(\\theta)^T H_{22} R(\\theta) \\end{pmatrix} = \\begin{pmatrix} H_{11} & H_{12} R(\\theta) \\\\ R(\\theta)^T H_{21} & R(\\theta)^T H_{22} R(\\theta) \\end{pmatrix}.\n$$\n由于 $H_{21}$ 是零矩阵，所以 $R(\\theta)^T H_{21}$ 也是零矩阵。因此，变换后的矩阵具有以下形式：\n$$\n\\tilde{H}(\\theta) = \\begin{pmatrix} H_{11} & H_{12} R(\\theta) \\\\ 0 & R(\\theta)^T H_{22} R(\\theta) \\end{pmatrix}.\n$$\n这是一个分块上三角矩阵。$(2,1)$ 分块位置的零矩阵意味着元素 $\\tilde{h}_{31}, \\tilde{h}_{41}, \\tilde{h}_{32}, \\tilde{h}_{42}$ 都为零。上Hessenberg矩阵的条件是当 $i > j+1$ 时元素 $\\tilde{h}_{ij}$ 为零。这个零分块确保了对于 $(i,j) \\in \\{(3,1), (4,1), (4,2)\\}$，该条件成立。因此，对于所有 $\\theta$ 值，$\\tilde{H}(\\theta)$ 都是一个上Hessenberg矩阵。这证明了结构不变性。对于任何 $\\theta \\in (0, \\pi)$，矩阵 $U(\\theta)$ 都不是对角矩阵，但 $U(\\theta)e_1=e_1$ 且 $U(\\theta)^*HU(\\theta)$ 是Hessenberg矩阵。这一族变换构成了对隐式Q定理唯一性部分的一个反例，如果 $H$ 是非约化的，该定理将强制 $U(\\theta)$ 为对角矩阵。\n\n下一个任务是找到唯一的 $\\theta \\in (0, \\pi/2)$，使得 $\\tilde{H}(\\theta)$ 的 $(4,3)$ 元素为零。完整矩阵 $\\tilde{H}(\\theta)$ 的 $(4,3)$ 元素是分块 $\\tilde{H}_{22}(\\theta) = R(\\theta)^T H_{22} R(\\theta)$ 的 $(2,1)$ 元素。我们必须计算该元素并将其设为零。\n令 $c = \\cos\\theta$，$s = \\sin\\theta$。我们有：\n$$\n\\tilde{H}_{22}(\\theta) = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix} \\begin{pmatrix} c & -s \\\\ s & c \\end{pmatrix}.\n$$\n我们先计算乘积 $H_{22}R(\\theta)$：\n$$\nH_{22}R(\\theta) = \\begin{pmatrix} 2 & 1 \\\\ 1 & 3 \\end{pmatrix}\\begin{pmatrix} c & -s \\\\ s & c \\end{pmatrix} = \\begin{pmatrix} 2c+s & -2s+c \\\\ c+3s & -s+3c \\end{pmatrix}.\n$$\n现在，我们左乘 $R(\\theta)^T$：\n$$\n\\tilde{H}_{22}(\\theta) = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} 2c+s & -2s+c \\\\ c+3s & -s+3c \\end{pmatrix}.\n$$\n此乘积的 $(2,1)$ 元素，对应于 $\\tilde{h}_{43}$ 元素，由第一个矩阵的第二行与第二个矩阵的第一列的点积给出：\n$$\n\\tilde{h}_{43}(\\theta) = (-s)(2c+s) + (c)(c+3s) = -2sc - s^2 + c^2 + 3sc = c^2 - s^2 + sc.\n$$\n使用倍角三角恒等式 $\\cos(2\\theta) = \\cos^2\\theta - \\sin^2\\theta$ 和 $\\sin(2\\theta) = 2\\sin\\theta\\cos\\theta$，我们可以将其改写为：\n$$\n\\tilde{h}_{43}(\\theta) = \\cos(2\\theta) + \\frac{1}{2}\\sin(2\\theta).\n$$\n我们需要找到 $\\theta \\in (0, \\pi/2)$ 使得 $\\tilde{h}_{43}(\\theta) = 0$。\n$$\n\\cos(2\\theta) + \\frac{1}{2}\\sin(2\\theta) = 0.\n$$\n这可以整理为 $\\frac{1}{2}\\sin(2\\theta) = -\\cos(2\\theta)$。对于 $\\theta \\in (0, \\pi/2)$，$2\\theta \\in (0, \\pi)$。在此区间内，$\\cos(2\\theta)$ 仅在 $2\\theta=\\pi/2$ 处为零，此时 $\\sin(2\\theta)=1$，方程不成立。因此我们可以安全地除以 $\\cos(2\\theta)$：\n$$\n\\frac{\\sin(2\\theta)}{\\cos(2\\theta)} = \\tan(2\\theta) = -2.\n$$\n我们在区间 $(0, \\pi/2)$ 中寻找 $\\theta$ 的解，这意味着 $2\\theta$ 在区间 $(0, \\pi)$ 中。正切函数在第二象限为负，所以 $2\\theta$ 必须在 $(\\pi/2, \\pi)$ 内。$\\tan(x) = y$ 的通解是 $x = \\arctan(y) + k\\pi$，其中 $k$ 为整数。\n$$\n2\\theta = \\arctan(-2) + k\\pi.\n$$\n由于 $\\arctan(-2)$ 位于 $(-\\pi/2, 0)$，我们必须选择 $k=1$ 以将 $2\\theta$ 置于所需区间 $(0, \\pi)$。\n$$\n2\\theta = \\arctan(-2) + \\pi.\n$$\n使用恒等式 $\\arctan(-x) = -\\arctan(x)$，我们有：\n$$\n2\\theta = \\pi - \\arctan(2).\n$$\n此值位于 $(\\pi/2, \\pi)$ 内，符合要求。最后，解出 $\\theta$：\n$$\n\\theta = \\frac{1}{2}\\left(\\pi - \\arctan(2)\\right).\n$$\n此值位于 $(\\pi/4, \\pi/2)$ 内，属于指定区间 $(0, \\pi/2)$。", "answer": "$$ \\boxed{\\frac{1}{2}\\left(\\pi - \\arctan(2)\\right)} $$", "id": "3589422"}, {"introduction": "隐式Q定理不仅是一个抽象的理论陈述，它更是保证QR算法稳定性和确定性的核心引擎。这个编程练习将理论与实践联系起来[@problem_id:3589450]。你将亲手实现隐式QR算法中的关键步骤——“凸起追逐”，并使用两种不同的Givens旋转符号约定。通过这个过程，你将验证尽管内部计算路径不同，最终得到的矩阵却完全相同，这正是隐式Q定理保证唯一性的直接体现。", "problem": "考虑将隐式QR（正交-三角）算法应用于实对称三对角矩阵。实对称三对角矩阵是一个 $n \\times n$ 矩阵 $T$，当 $|i - j| > 1$ 时，其元素 $T_{ij} = 0$，并且 $T_{ij} = T_{ji}$。上Hessenberg矩阵是一个 $n \\times n$ 矩阵 $H$，当 $i > j + 1$ 时，其元素 $H_{ij} = 0$。如果一个矩阵 $Q$ 满足 $Q^{\\top} Q = I$，则称其为正交矩阵。带位移的隐式QR步通过正交相似变换作用于一个未约化的上Hessenberg矩阵，生成另一个上Hessenberg矩阵，并且在对称三对角矩阵的情况下，它会保持其对称三对角结构。\n\n隐式Q定理（Hessenberg形式的唯一性）指出，对于一个未约化的上Hessenberg矩阵 $H$，如果 $Q$ 和 $\\widehat{Q}$ 是正交矩阵，使得 $Q^{\\top} H Q$ 和 $\\widehat{Q}^{\\top} H \\widehat{Q}$ 均为上Hessenberg矩阵，并且 $Q e_1 = \\widehat{Q} e_1$，那么存在一个对角元素为 $\\pm 1$ 的对角矩阵 $D$，使得 $Q = \\widehat{Q} D$，因此 $Q^{\\top} H Q = \\widehat{Q}^{\\top} H \\widehat{Q}$。这解释了在隐式步下Hessenberg形式的唯一性，除了正交变换内部存在的平凡符号不确定性之外。\n\n您的任务是，在实对称三对角测试矩阵上，实现并比较带有Wilkinson位移的单个隐式QR步的两个版本。两个版本都通过连续的Givens旋转执行凸起追逐，但在构造Givens旋转的内部符号策略上有所不同：\n\n- 变体 A：对于一个二维向量 $(x, z)$，通过 $r = \\sqrt{x^2 + z^2}$、$c = x / r$、$s = z / r$ 来计算Givens旋转参数（约定当 $r = 0$ 时，$c = 1$，$s = 0$）。\n- 变体 B：使用符号翻转的斜边 $r' = -\\sqrt{x^2 + z^2}$，并设置 $c = x / r'$、$s = z / r'$（约定当 $r' = 0$ 时，$c = 1$，$s = 0$）。\n\n在每一步中，使用作用于该凸起追逐位置索引对的行和列的 $2 \\times 2$ Givens旋转 $G = \\begin{bmatrix} c & s \\\\ -s & c \\end{bmatrix}$ 来应用相似变换 $T \\leftarrow G^{\\top} T G$。通过位移后的第一列 $(x, z) = (T_{11} - \\mu, T_{21})$ 来初始化凸起，其中Wilkinson位移 $\\mu$ 定义为 $T$ 的右下角 $2 \\times 2$ 子矩阵中更接近 $T_{nn}$ 的那个特征值，然后通过依次消去次次对角线上的元素来向下追逐凸起。\n\n在对同一个初始三对角矩阵分别执行一个变体A和一个变体B的隐式QR步之后，计算两个结果矩阵之间的按元素最大绝对差，即 $\\max_{i,j} |T^{(A)}_{ij} - T^{(B)}_{ij}|$。\n\n您必须用程序实现上述过程，并对以下对称三对角矩阵的测试套件运行它，每个矩阵由其主对角线 $d$ 和次对角线 $e$ 指定（根据对称性，上对角线等于 $e^{\\top}$）。对于每种情况，构造 $T$ 使得 $T_{ii} = d_i$ 和 $T_{i+1,i} = T_{i,i+1} = e_i$：\n\n- 情况1（一般良态）：$n = 6$，$d = [1.0, -2.0, 3.0, 0.5, -1.5, 2.5]$，$e = [0.9, -0.5, 0.7, -0.3, 0.4]$。\n- 情况2（重复的对角线元素）：$n = 4$，$d = [2.0, 2.0, 2.0, 2.0]$，$e = [0.5, -0.3, 0.4]$。\n- 情况3（次对角线量级接近收缩）：$n = 7$，$d = [1000.0, -999.0, 500.0, -250.0, 125.0, -60.0, 30.0]$，$e = [10^{-12}, -10^{-10}, 10^{-8}, -10^{-6}, 10^{-4}, -10^{-2}]$。\n- 情况4（交替符号和中等跨度）：$n = 5$，$d = [-5.0, -2.5, 0.0, 2.5, 5.0]$，$e = [-1.0, 1.0, -1.0, 1.0]$。\n- 情况5（混合大尺度）：$n = 8$，$d = [10.0, -20.0, 30.0, -40.0, 50.0, -60.0, 70.0, -80.0]$，$e = [5.0, -4.0, 3.0, -2.0, 1.0, -0.5, 0.25]$。\n\n对于每种情况，从相同的初始 $T$ 开始，为变体A和变体B各执行一次带Wilkinson位移的隐式QR步，并报告单个浮点数 $\\max_{i,j} |T^{(A)}_{ij} - T^{(B)}_{ij}|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个情况的结果，形式为方括号括起来的逗号分隔列表，例如“[r1,r2,r3,r4,r5]”。每个 $r_k$ 都必须是浮点数。\n\n不涉及物理单位或角度。所有数值输出都应表示为浮点数。确保您的程序是自包含的，并且不需要任何输入。", "solution": "已根据指定标准对用户提供的问题进行了分析和验证。\n\n### 第一步：提取要点\n- **矩阵类型**：大小为 $n \\times n$ 的实对称三对角矩阵 $T$。\n    - 当 $|i - j| > 1$ 时，$T_{ij} = 0$。\n    - $T_{ij} = T_{ji}$。\n- **算法**：一步带Wilkinson位移的隐式QR算法。\n- **Wilkinson位移 ($\\mu$)**：T的右下角 $2 \\times 2$ 子矩阵中更接近 $T_{nn}$ 的特征值。\n- **过程**：通过连续的Givens旋转进行凸起追逐。\n    1.  初始化凸起：使用向量 $(x, z) = (T_{11} - \\mu, T_{21})$ 创建第一个Givens旋转 $G_1$。\n    2.  追逐凸起：对于 $k=2, \\dots, n-1$，使用作用于行和列 $k, k+1$ 的Givens旋转 $G_k$，消去上一步在位置 $(k+1, k-1)$ 产生的次次对角线元素。\n- **Givens旋转矩阵形式**：$G = \\begin{bmatrix} c & s \\\\ -s & c \\end{bmatrix}$。\n- **Givens参数变体**：对于给定的向量 $(x, z)$：\n    - **变体 A**：$r = \\sqrt{x^2 + z^2}$, $c = x / r$, $s = z / r$。（若 $r=0$，则 $c=1, s=0$）。\n    - **变体 B**：$r' = -\\sqrt{x^2 + z^2}$, $c = x / r'$, $s = z / r'$。（若 $r'=0$，则 $c=1, s=0$）。\n- **变换**：相似变换 $T \\leftarrow G^{\\top} T G$。\n- **输出**：对于每个测试用例，计算 $\\max_{i,j} |T^{(A)}_{ij} - T^{(B)}_{ij}|$，其中 $T^{(A)}$ 和 $T^{(B)}$ 分别是由变体A和变体B产生的矩阵。\n- **测试用例**：\n    - 情况1：$n = 6$，$d = [1.0, -2.0, 3.0, 0.5, -1.5, 2.5]$，$e = [0.9, -0.5, 0.7, -0.3, 0.4]$。\n    - 情况2：$n = 4$，$d = [2.0, 2.0, 2.0, 2.0]$，$e = [0.5, -0.3, 0.4]$。\n    - 情况3：$n = 7$，$d = [1000.0, -999.0, 500.0, -250.0, 125.0, -60.0, 30.0]$，$e = [10^{-12}, -10^{-10}, 10^{-8}, -10^{-6}, 10^{-4}, -10^{-2}]$。\n    - 情况4：$n = 5$，$d = [-5.0, -2.5, 0.0, 2.5, 5.0]$，$e = [-1.0, 1.0, -1.0, 1.0]$。\n    - 情况5：$n = 8$，$d = [10.0, -20.0, 30.0, -40.0, 50.0, -60.0, 70.0, -80.0]$，$e = [5.0, -4.0, 3.0, -2.0, 1.0, -0.5, 0.25]$。\n\n### 第二步：使用提取的要点进行验证\n问题被评估为**有效**。\n- **有科学依据**：该问题基于成熟的对称矩阵隐式QR算法，这是数值线性代数的基石。算法的描述，包括Wilkinson位移和凸起追逐过程，与标准文献（例如 Golub 和 Van Loan 的《矩阵计算》）一致。隐式Q定理的背景虽然在推论上略有简化，但正确地阐明了推动本研究的唯一性性质。\n- **定义明确**：任务定义清晰，提供了所有必要的数据（矩阵、算法变体、特定位移）。每个测试用例都存在唯一的数值结果。\n- **客观性**：问题以精确的数学和算法术语陈述，没有主观性或歧义。\n\n### 第三步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是为对称三对角矩阵 $T$ 实现一个完整的、单步的隐式QR凸起追逐过程，并比较两种不同Givens旋转参数符号约定的结果。\n\n**1. 带凸起追逐的隐式QR步**\n\n一个隐式QR步将矩阵 $T$ 转换为一个正交相似矩阵 $T_{new} = Q^T T Q$，后者具有相同的特征值。对于对称三对角矩阵，该结构得以保持。正交矩阵 $Q$ 被构造为Givens旋转的乘积，$Q = G_1 G_2 \\dots G_{n-1}$，旨在隐式地应用一个位移 $\\mu$。\n\na. **Wilkinson位移**：Wilkinson位移 $\\mu$ 是一个加速收敛的有力选择。它被定义为 $T$ 的末尾 $2 \\times 2$ 子矩阵 $\\begin{pmatrix} T_{n-1, n-1} & T_{n-1, n} \\\\ T_{n, n-1} & T_{nn} \\end{pmatrix}$ 中更接近 $T_{nn}$ 的那个特征值。设该子矩阵为 $\\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}$，其中 $a=T_{n-1,n-1}, b=T_{n-1,n}, c=T_{nn}$。其特征值为 $\\lambda = \\frac{a+c \\pm \\sqrt{(a-c)^2 + 4b^2}}{2}$。位移 $\\mu$ 选择更接近 $c$ 的那个特征值。这可以稳健地写为 $\\mu = c + \\delta - \\operatorname{sgn}(\\delta)\\sqrt{\\delta^2 + b^2}$，其中 $\\delta = (a-c)/2$。如果 $\\delta=0$，我们可以取 $\\operatorname{sgn}(0)=1$。\n\nb. **凸起创建**：第一个Givens旋转 $G_1$ 被构造用来引入位移。它被设计为作用于前两行和前两列。此旋转由矩阵 $(T - \\mu I)$ 的第一列决定，具体是向量 $(x, z) = (T_{11}-\\mu, T_{21})$。参数 $(c_1, s_1)$ 根据指定的变体（A或B）从此向量计算得出。应用相似变换 $T_1 = G_1^T T G_1$。虽然 $G_1$ 是基于第一列设计的，但将其作为相似变换应用于三对角矩阵 $T$ 会引入一个“凸起”，即在位置 $(3,1)$（以及根据对称性在 $(1,3)$）处出现一个非零元素。\n\nc. **凸起追逐**：接着应用一系列Givens旋转 $G_2, G_3, \\dots, G_{n-1}$，以将此凸起沿次对角线“追逐”下去并移出矩阵。在第 $k$ 步（对于 $k=2, \\dots, n-1$），将Givens旋转 $G_k$ 应用于行和列 $k,k+1$。选择旋转参数 $(c_k, s_k)$ 以消去位置 $(k+1, k-1)$ 处的当前凸起。这需要对由位置 $(k, k-1)$ 和 $(k+1, k-1)$ 处的元素构成的向量进行旋转。具体来说，我们基于当前矩阵的 $(x, z) = (T_{k,k-1}, T_{k+1,k-1})$ 来选择 $(c_k, s_k)$。变换 $T_k = G_k^T T_{k-1} G_k$ 会消去目标凸起，但在位置 $(k+2, k)$ 处产生一个新的凸起，这将在下一步中处理。此过程一直持续到 $k=n-1$，此时最后的旋转将凸起推出矩阵，恢复三对角形式。\n\n**2. 变体A与变体B的分析**\n\n我们来分析两种变体之间的区别。\n- **变体 A**：对于向量 $(x,z)$，参数为 $c_A = x/r, s_A = z/r$，其中 $r = \\sqrt{x^2+z^2}$。\n- **变体 B**：对于同一向量 $(x,z)$，参数为 $c_B = x/r', s_B = z/r'$，其中 $r' = -\\sqrt{x^2+z^2}$。\n\n很明显，对于任何非零向量 $(x,z)$，我们有 $c_B = -c_A$ 和 $s_B = -s_A$。\n\n在任何步骤 $k$ 的Givens旋转矩阵是 $G_k = \\begin{bmatrix} c_k & s_k \\\\ -s_k & c_k \\end{bmatrix}$。因此，两个变体的矩阵关系如下：\n$G_k^{(B)} = \\begin{bmatrix} c_k^{(B)} & s_k^{(B)} \\\\ -s_k^{(B)} & c_k^{(B)} \\end{bmatrix} = \\begin{bmatrix} -c_k^{(A)} & -s_k^{(A)} \\\\ -(-s_k^{(A)}) & -c_k^{(A)} \\end{bmatrix} = \\begin{bmatrix} -c_k^{(A)} & -s_k^{(A)} \\\\ s_k^{(A)} & -c_k^{(A)} \\end{bmatrix}$。\n这不完全等于 $-G_k^{(A)}$，但我们重新审视相似变换：$T_{new} = G_k^T T_{old} G_k$。\n\n对于变体B，让我们将 $c_B = -c_A$ 和 $s_B = -s_A$直接代入相似变换的代数展开式中。一个更简单的方法是注意到 $G_k^{(B)} = -G_k^{(A)}$ 并不完全正确。一个更好的观察是：设 $G_k^{(A)}$ 是变体A的Givens矩阵。那么变体B的矩阵是 $G_k^{(B)} = \\begin{pmatrix} -c_k^{(A)} & -s_k^{(A)} \\\\ s_k^{(A)} & -c_k^{(A)} \\end{pmatrix}$。这也是一个正交矩阵。然而，让我们考虑用 $-G$ 替换 $G$ 的效果。设 $G=\\begin{pmatrix}c & s \\\\ -s & c\\end{pmatrix}$。那么 $-G=\\begin{pmatrix}-c & -s \\\\ s & -c\\end{pmatrix}$。如果我们认定 $c=c_A, s=s_A$，这恰好是 $G^{(A)}$ 和 $G^{(B)}$ 之间的关系。\n\n因此，在凸起追逐过程的每一步 $k$，$G_k^{(B)} = -G_k^{(A)}$。\n我们假设在步骤开始时矩阵相同，$T_{k-1}^{(A)} = T_{k-1}^{(B)}$。\n变体A的下一个矩阵是 $T_k^{(A)} = (G_k^{(A)})^T T_{k-1}^{(A)} G_k^{(A)}$。\n变体B的下一个矩阵是 $T_k^{(B)} = (G_k^{(B)})^T T_{k-1}^{(B)} G_k^{(B)}$。\n代入关系式：\n$T_k^{(B)} = (-G_k^{(A)})^T T_{k-1}^{(A)} (-G_k^{(A)}) = [-(G_k^{(A)})^T] T_{k-1}^{(A)} [-G_k^{(A)}] = (-1)(-1) (G_k^{(A)})^T T_{k-1}^{(A)} G_k^{(A)} = T_k^{(A)}$。\n\n通过归纳法，由于两个变体都从相同的初始矩阵 $T$ 开始，并且在 $n-1$ 个凸起追逐步骤中的每一步得到的结果矩阵都相同，因此最终的矩阵 $T^{(A)}$ 和 $T^{(B)}$ 必须相同。\n\n因此，在数学上，按元素最大绝对差 $\\max_{i,j} |T^{(A)}_{ij} - T^{(B)}_{ij}|$ 预期为 $0$。任何非零结果都将源于浮点运算效应，考虑到计算之间的直接关系，如果编译器/解释器对相同的代数表达式进行同等优化，这些效应预计是可忽略的（在机器精度量级上）或为零。\n\n**3. 实现计划**\n解决方案将使用Python的NumPy库进行矩阵运算来实现。\n1. 一个函数 `create_tridiagonal(d, e)` 将从其主对角线和次对角线向量构造完整的 $n \\times n$ 矩阵 $T$。\n2. 一个函数 `get_wilkinson_shift(T)` 将计算 $\\mu$。\n3. 一个函数 `implicit_qr_step(T, variant)` 将执行完整的凸起追逐过程。它将从 $k=0$ 到 $n-2$（使用0-based索引）进行循环。\n   - 在每次迭代 $k$ 中，它将为Givens旋转确定正确的向量 $(x,z)$。\n   - 它将调用一个辅助函数 `get_givens_params(x, z, variant)`，该函数使用 `math.hypot(x,z)` 来计算 $(c,s)$ 以保证数值稳定性。\n   - 它将应用相似变换 $T \\leftarrow G_k^T T G_k$。在凸起追逐的每一步，为了消去由上一步在位置 `(i+1, i-1)` 产生的非零元素（凸起），需要对索引 `i` 和 `i+1` 应用Givens旋转。例如，第一次旋转（作用于索引0, 1）会产生一个位于 `(2,0)` 的凸起。下一步，一个作用于索引1, 2的旋转将消除该凸起，同时在 `(3,1)` 处产生一个新的凸起。我之前推导的逻辑是成立的：要消去位置 $(k+1, k-1)$ 的凸起，需要对索引 $k, k+1$ 应用旋转。\n4. 主脚本将遍历所有测试用例。对于每个用例，它将对初始矩阵的副本为变体A和B运行 `implicit_qr_step`，并计算两个结果矩阵之间的最大绝对差。\n5. 最终的差异列表将以指定格式打印。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general well-conditioned)\n        (np.array([1.0, -2.0, 3.0, 0.5, -1.5, 2.5]), np.array([0.9, -0.5, 0.7, -0.3, 0.4])),\n        # Case 2 (repeated diagonal entries)\n        (np.array([2.0, 2.0, 2.0, 2.0]), np.array([0.5, -0.3, 0.4])),\n        # Case 3 (near-deflation subdiagonal magnitudes)\n        (np.array([1000.0, -999.0, 500.0, -250.0, 125.0, -60.0, 30.0]), np.array([1e-12, -1e-10, 1e-8, -1e-6, 1e-4, -1e-2])),\n        # Case 4 (alternating signs and moderate spread)\n        (np.array([-5.0, -2.5, 0.0, 2.5, 5.0]), np.array([-1.0, 1.0, -1.0, 1.0])),\n        # Case 5 (mixed large scales)\n        (np.array([10.0, -20.0, 30.0, -40.0, 50.0, -60.0, 70.0, -80.0]), np.array([5.0, -4.0, 3.0, -2.0, 1.0, -0.5, 0.25])),\n    ]\n\n    def create_tridiagonal(d, e):\n        \"\"\"Constructs a symmetric tridiagonal matrix T from diagonal d and subdiagonal e.\"\"\"\n        n = len(d)\n        T = np.zeros((n, n), dtype=np.float64)\n        np.fill_diagonal(T, d)\n        np.fill_diagonal(T[1:], e)\n        np.fill_diagonal(T[:, 1:], e)\n        return T\n\n    def get_wilkinson_shift(T):\n        \"\"\"Calculates the Wilkinson shift for the matrix T.\"\"\"\n        n = T.shape[0]\n        if n  2:\n            return T[0, 0]\n        # Bottom-right 2x2 submatrix\n        a = T[n - 2, n - 2]\n        b = T[n - 2, n - 1]\n        c = T[n - 1, n - 1]\n        \n        delta = (a - c) / 2.0\n        # math.copysign is used to handle sgn(0) case consistently.\n        # It's sgn(delta) * sqrt(delta^2 + b^2).\n        # We want the eigenvalue closer to c, which is c + delta - sgn(delta)*sqrt(...)\n        mu = c + delta - math.copysign(1.0, delta if delta != 0 else 1.0) * math.sqrt(delta**2 + b**2)\n        return mu\n\n    def get_givens_params(x, z, variant):\n        \"\"\"Computes Givens rotation parameters (c, s) for a vector (x, z).\"\"\"\n        if variant not in ['A', 'B']:\n            raise ValueError(\"Variant must be 'A' or 'B'\")\n        \n        r = math.hypot(x, z)\n        \n        if r == 0.0:\n            c, s = 1.0, 0.0\n        else:\n            if variant == 'B':\n                r = -r\n            c = x / r\n            s = z / r\n        \n        return c, s\n\n    def implicit_qr_step(T_orig, variant):\n        \"\"\"Performs one implicit QR step with Wilkinson shift on a tridiagonal matrix.\"\"\"\n        T = T_orig.copy()\n        n = T.shape[0]\n        if n  2:\n            return T\n\n        mu = get_wilkinson_shift(T)\n\n        # 1. Create the bulge\n        x = T[0, 0] - mu\n        z = T[1, 0]\n        c, s = get_givens_params(x, z, variant)\n        \n        # This rotation is on rows/cols 0 and 1\n        G = np.eye(n)\n        G[0,0], G[0,1], G[1,0], G[1,1] = c, s, -s, c\n        T = G.T @ T @ G\n        \n        # 2. Chase the bulge\n        # At step k (0-indexed), we chase the bulge at (k+2, k)\n        # using a rotation on (k+1, k+2)\n        for k in range(n - 2):\n            x = T[k + 1, k]\n            z = T[k + 2, k]\n            \n            c, s = get_givens_params(x, z, variant)\n            \n            G = np.eye(n)\n            G[k+1,k+1], G[k+1, k+2] = c, s\n            G[k+2,k+1], G[k+2, k+2] = -s, c\n\n            T = G.T @ T @ G\n            \n        return T\n\n    results = []\n    for d, e in test_cases:\n        T = create_tridiagonal(d, e)\n        \n        T_A = implicit_qr_step(T, 'A')\n        T_B = implicit_qr_step(T, 'B')\n        \n        max_diff = np.max(np.abs(T_A - T_B))\n        results.append(max_diff)\n\n    # This function is not called, but was part of the original XML. Included for completeness.\n    def apply_givens_similarity(T, k_idx, c, s):\n        \"\"\"Applies a Givens similarity transformation T -> G^T T G on rows/cols k_idx, k_idx+1.\"\"\"\n        n = T.shape[0]\n        i = k_idx\n        j = k_idx + 1\n\n        # Apply G^T to rows of T -> G^T T\n        # New row i = c * old row i - s * old row j\n        # New row j = s * old row i + c * old row j\n        for col in range(n):\n            ti, tj = T[i, col], T[j, col]\n            T[i, col] = c * ti - s * tj\n            T[j, col] = s * ti + c * tj\n\n        # Apply G to columns of (G^T T) -> (G^T T) G\n        # New col i = c * old col i - s * old col j\n        # New col j = s * old col i + c * old col j\n        # NOTE: Problem statement has G = [c, s; -s, c].\n        # G's effect on columns:\n        # new col i = c * old i + s * old j\n        # new col j = -s * old i + c * old j\n        for row in range(n):\n            ti, tj = T[row, i], T[row, j]\n            T[row, i] = c * ti + s * tj\n            T[row, j] = -s * ti + c * tj\n            \n    # The actual output is generated here for insertion into the answer tag.\n    # print(f\"[{','.join(map(str, results))}]\") # This would print [0.0,0.0,0.0,0.0,0.0]\n    \n# To be compliant, the answer tag needs the result, not the code.\n# The result of running the above code is a list of zeros.\n# This code is provided as part of the solution logic.\n```", "answer": "$$\\boxed{\\text{[0.0, 0.0, 0.0, 0.0, 0.0]}}$$", "id": "3589450"}]}