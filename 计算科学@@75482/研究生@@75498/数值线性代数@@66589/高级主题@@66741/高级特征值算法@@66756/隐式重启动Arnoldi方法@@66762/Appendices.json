{"hands_on_practices": [{"introduction": "隐式重启动Arnoldi方法 (IRAM) 的效率和效果在很大程度上取决于其参数的选择。其中一个基本的设计决策是Arnoldi子空间的维度 $m$、我们希望计算的本征对数量 $k$ 以及每次重启动时使用的移位数 $p$ 之间的关系。这个练习将引导你从第一性原理出发，阐明为何经典的 $m = k + p$ 规则是IRAM中多项式滤波机制的直接体现，从而加深对算法核心思想的理解。[@problem_id:3589878]", "problem": "考虑应用于矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的隐式重启 Arnoldi 方法 (Implicitly Restarted Arnoldi Method, IRAM)。设 Arnoldi 过程产生一个标准正交基 $V_{m}$ 和一个上 Hessenberg 矩阵 $H_{m}$，它们满足 Arnoldi 关系式\n$$\nA V_{m} \\;=\\; V_{m} H_{m} \\;+\\; h_{m+1,m}\\, v_{m+1} e_{m}^{\\top},\n$$\n其中 Ritz 对由 $H_{m}$ 的特征对给出。在 IRAM 中，执行一个隐式重启阶段，该阶段应用 $p$ 个隐式位移 $\\{\\sigma_{j}\\}_{j=1}^{p}$（通常选择在不想要的 Ritz 值附近）。已知这等效于在 Krylov 过程中应用一个 $p$ 次多项式滤波器 $\\phi_{p}(A) = \\prod_{j=1}^{p}(A - \\sigma_{j} I)$，从而衰减与不想要的不变子空间相关的分量。假设在固定的内存预算下，我们要寻求 $k$ 个特征对，并且必须选择 Arnoldi 子空间维度 $m$ 和每次重启的位移数 $p$。从 Krylov 子空间投影和多项式滤波的基本原理出发，哪个选项最好地解释了将子空间维度设为保留的 Ritz 向量数加上每次重启的位移数的这条连接 $m$、$k$ 和 $p$ 的经典法则？\n\nA. 隐式重启步骤是一个以所选位移为根的 $p$ 次多项式滤波器，它抑制与不想要的 Ritz 向量对齐的分量。为了在重启过程中保留对所需不变子空间的 $k$ 维近似，同时仍允许在残差子空间上进行 $p$ 次滤波作用，$m$ 需要同时容纳 $k$ 个保留方向和滤波所消耗的 $p$ 个自由度；满足此条件的最小选择是将子空间维度设置为保留维度与位移数之和。\n\nB. 无论位移如何，隐式 QR 步骤都会保留完整的 Krylov 子空间维度，因此为了保持稳定性，位移数必须等于所需特征对的数量；因此，唯一一致的选择是取子空间维度等于所需特征对数量的两倍。\n\nC. 因为 Arnoldi 递推是三项关系式更新，所以单个额外维度就足以表示任意数量位移的效果，因此位移数不影响子空间维度，并且总可以选择子空间维度仅比所需数量多一。\n\nD. 有效重启滤波器的次数随子空间维度增长而增长，且与位移数无关，因此任何正数位移都会产生相同的阻尼强度，因此为了最大化效率，子空间维度应等于所需数量。", "solution": "**问题验证**\n\n**步骤 1：提取已知条件**\n- 方法：隐式重启 Arnoldi 方法 (IRAM)。\n- 矩阵：$A \\in \\mathbb{C}^{n \\times n}$。\n- Arnoldi 关系式：$A V_{m} = V_{m} H_{m} + h_{m+1,m}\\, v_{m+1} e_{m}^{\\top}$。\n- $V_m$: 标准正交基。\n- $H_m$: 上 Hessenberg 矩阵。\n- Ritz 对：$H_m$ 的特征对。\n- 重启：应用 $p$ 个隐式位移 $\\{\\sigma_{j}\\}_{j=1}^{p}$。\n- 位移选择在不想要的 Ritz 值附近。\n- 重启等效于应用一个 $p$ 次多项式滤波器 $\\phi_{p}(A) = \\prod_{j=1}^{p}(A - \\sigma_{j} I)$。\n- 目标：寻求 $k$ 个特征对。\n- 待选参数：子空间维度 $m$，位移数 $p$。\n- 问题：解释连接 $m$、$k$ 和 $p$ 的经典法则，即子空间维度等于保留的 Ritz 向量数加上每次重启的位移数。\n\n**步骤 2：使用已知条件进行验证**\n问题陈述具有科学依据、提法恰当且客观。\n- **科学依据**：对 IRAM 的描述，包括 Arnoldi 关系式、Ritz 对的作用以及将隐式重启解释为多项式滤波器，是对这一数值线性代数基石算法的标准而准确的表述。所有技术术语都使用正确。\n- **提法恰当性**：该问题要求对 IRAM 中使用的常见启发式规则 ($m=k+p$) 给出概念上的解释。这需要基于该算法机理进行定性但严谨的解释。在 Krylov 子空间方法的理论中，存在着明确且有意义的解释。\n- **客观性**：问题以精确的数学语言陈述，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n问题陈述有效。将推导解答。\n\n**推导**\n\n隐式重启 Arnoldi 方法 (IRAM) 是一种迭代过程，用于寻找大型矩阵 $A$ 的少数（比如 $k$ 个）特征对。它包括两个主要阶段：扩展和重启。\n\n$1$. **扩展阶段**：从一个起始向量 $v_1$ 开始，运行一个 $m$ 步的 Arnoldi 过程，为 Krylov 子空间 $\\mathcal{K}_m(A, v_1) = \\text{span}\\{v_1, Av_1, \\dots, A^{m-1}v_1\\}$ 生成一个标准正交基 $V_m = [v_1, v_2, \\dots, v_m]$。该过程产生 Arnoldi 分解：\n$$\nA V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^\\top\n$$\n其中 $H_m = V_m^* A V_m$ 是一个 $m \\times m$ 的上 Hessenberg 矩阵。$H_m$ 的特征值，称为 Ritz 值，用于近似 $A$ 的特征值。对应的 Ritz 向量是 $V_m y_j$，其中 $y_j$ 是 $H_m$ 的一个特征向量。\n\n$2$. **重启阶段**：出于实际原因（内存和计算成本），维度 $m$ 不能无限增长。当 $m$ 达到一个选定的极限时，过程将重新启动。IRAM“隐式地”执行此重启，以保留子空间中累积的有价值的谱信息。过程如下：\n- 从 $m$ 个 Ritz 值中，我们选择 $k$ 个“想要的”Ritz 值（例如，那些收敛到谱的期望部分的 Ritz 值）和 $p$ 个我们希望清除的“不想要的”Ritz 值。Arnoldi 分解的总维度是 $m$，因此必然地，这些计数之间存在关系。如果我们决定保留 $k$ 个 Ritz 向量并丢弃其中的 $p$ 个，那么我们必须从至少有 $k+p$ 个 Ritz 向量可供选择开始。标准的选择是设置 $m = k+p$。\n- 这 $p$ 个不想要的 Ritz 值 $\\{\\sigma_j\\}_{j=1}^p$ 被用作一系列 $p$ 个隐式应用的 QR 步骤中的位移。\n- 隐式重启的核心在于，将这 $p$个带位移的 QR 步骤应用于 Hessenberg 矩阵 $H_m$，在数学上等效于用一个新的起始向量 $v_1^+$ 重启 Arnoldi 过程。新的起始向量通过一个多项式滤波器与旧的起始向量相关联：\n$$\nv_1^+ = c \\cdot \\phi_p(A) v_1, \\quad \\text{where} \\quad \\phi_p(z) = \\prod_{j=1}^p (z - \\sigma_j)\n$$\n其中 $c$ 是一个归一化常数。这个多项式滤波器 $\\phi_p(z)$ 在 $z$ 值接近位移 $\\sigma_j$（不想要的 Ritz 值）时很小，而在其他情况下相对较大。因此，将 $\\phi_p(A)$ 应用于 $v_1$ 会衰减起始向量中与不想要的特征向量对应的分量，从而加速向想要的特征向量收敛。\n\n- 在 $p$ 个隐式 QR 步骤之后，原始的 $m \\times m$ 分解被变换，然后截断为一个 $k \\times k$ 的分解。这个新的分解对应于一个 $k$ 维 Krylov 子空间 $\\mathcal{K}_k(A, v_1^+)$，它是原始 $\\mathcal{K}_m(A, v_1)$ 的一个子空间。这个 $k$ 维子空间然后在下一个循环中被扩展回维度 $m$，过程重复进行。\n\n**$m=k+p$ 规则的解释**：\n其逻辑将各个要素联系起来：我们从一个维度为 $m$ 的空间开始。我们希望保留一个对 $k$ 维不变子空间的改进近似。改进的机制是一个 $p$ 次多项式滤波器。应用这个 $p$ 次滤波器需要 $p$ 个位移，这些位移被选为要丢弃的 $p$ 个 Ritz 值。为了在保留 $k$ 个 Ritz 值的同时有 $p$ 个可供丢弃，初始子空间的维度必须至少为 $m=k+p$。这 $p$ 个超出所需 $k$ 维的“额外”维度，为滤波操作的进行提供了必要的自由度。隐式 QR 算法有效地“消耗”这 $p$ 个维度来执行滤波，从而得到一个精炼的 $k$ 维子空间。因此，选择 $m=k+p$ 代表了在应用 $p$ 次滤波器来改进近似的同时保留一个 $k$ 维近似所需的最小子空间大小。\n\n**逐项分析**\n\n**A. 隐式重启步骤是一个以所选位移为根的 $p$ 次多项式滤波器，它抑制与不想要的 Ritz 向量对齐的分量。为了在重启过程中保留对所需不变子空间的 $k$ 维近似，同时仍允许在残差子空间上进行 $p$ 次滤波作用，$m$ 需要同时容纳 $k$ 个保留方向和滤波所消耗的 $p$ 个自由度；满足此条件的最小选择是将子空间维度设置为保留维度与位移数之和。**\n该陈述精确且准确地描述了 IRAM 中 $m=k+p$ 规则背后的基本原理。它正确地将重启识别为一个 $p$ 次多项式滤波器，并正确解释了总维度 $m$ 必须同时考虑要保留的 $k$ 个维度和滤波过程所需的 $p$ 个维度。\n**结论：正确**\n\n**B. 无论位移如何，隐式 QR 步骤都会保留完整的 Krylov 子空间维度，因此为了保持稳定性，位移数必须等于所需特征对的数量；因此，唯一一致的选择是取子空间维度等于所需特征对数量的两倍。**\n该陈述包含几个谬误。虽然基变换 $V_m \\to V_m Q$ 保留了 $\\mathcal{K}_m(A, v_1)$ 的张成空间，但重启的全部意义在于将结果分解*截断*到维度 $k$。关于位移数 $p$ 必须等于所需特征对数 $k$ ($p=k$) 的断言并非普遍要求；这是一种可能的选择，但其他选择如 $p \\approx k/2$ 也很常见且有效。因此，$m=2k$ 是“唯一一致的选择”这一结论是毫无根据的。\n**结论：错误**\n\n**C. 因为 Arnoldi 递推是三项关系式更新，所以单个额外维度就足以表示任意数量位移的效果，因此位移数不影响子空间维度，并且总可以选择子空间维度仅比所需数量多一。**\n这个前提是错误的。一般的 Arnoldi 递推是长程递推，而不是三项关系式；后者是针对 Hermitian 矩阵的 Lanczos 算法特有的。即使在那种特殊情况下，单个额外维度 ($p=1$) 也只能实现一个 $1$ 次多项式滤波器。它不足以表示“任意数量位移”的效果。一个 $p$ 次滤波器需要 $p$ 个额外维度，因此是 $m=k+p$，而不是 $m=k+1$。\n**结论：错误**\n\n**D. 有效重启滤波器的次数随子空间维度增长而增长，且与位移数无关，因此任何正数位移都会产生相同的阻尼强度，因此为了最大化效率，子空间维度应等于所需数量。**\n该陈述从根本上是错误的。重启多项式滤波器 $\\phi_p(A)$ 的次数恰好是 $p$，即所应用的位移数。它并非与位移数无关。一个具有精心选择位移的更高次滤波器（更大的 $p$）通常能提供对不想要分量更强的阻尼效果。建议 $m=k$（即 $p=0$）意味着没有重启也没有滤波，这通常会导致收敛性差，违背了 IRAM 的初衷。\n**结论：错误**", "answer": "$$\n\\boxed{A}\n$$", "id": "3589878"}, {"introduction": "理论算法与实际计算实现之间往往存在鸿沟，而这个鸿沟主要由有限精度算术的效应所造成。在Arnoldi过程中，一个关键的实际挑战是计算出的基向量会逐渐失去其理论上的正交性。这个练习探讨了这一现象的深远后果，特别是“幽灵”本征值的出现——即真实本征值的虚假副本，这可能会误导收敛性判断。理解并诊断这个问题是构建可靠的现代本征值求解器的关键一步。[@problem_id:3589891]", "problem": "考虑一个大型稀疏非奇异矩阵 $A \\in \\mathbb{C}^{n \\times n}$，以及使用隐式重启 Arnoldi 方法 (IRAM) 计算 $A$ 的 $k$ 个模最大特征值的任务。在精确算术中，从一个单位向量 $v_1$ 开始的 Arnoldi 过程会产生一个标准正交基 $V_{m+1} = [v_1,\\dots,v_{m+1}] \\in \\mathbb{C}^{n \\times (m+1)}$ 和一个上 Hessenberg 矩阵 $H_{m+1,m} \\in \\mathbb{C}^{(m+1)\\times m}$，它们满足 Arnoldi 关系式\n$$\nA V_m \\;=\\; V_{m+1} H_{m+1,m},\n$$\n其中 $V_m = [v_1,\\dots,v_m] \\in \\mathbb{C}^{n \\times m}$ 且 $H_m \\in \\mathbb{C}^{m \\times m}$ 表示 $H_{m+1,m}$ 的前导主子块。Ritz 值是 $H_m$ 的特征值 $\\theta \\in \\mathbb{C}$，对应的 Ritz 向量形式为 $V_m y$，其中 $y \\in \\mathbb{C}^m$ 是 $H_m$ 的一个特征向量。Rayleigh–Ritz 条件指出，残差 $r = A (V_m y) - \\theta (V_m y)$ 与 $\\mathcal{K}_m(A, v_1) = \\mathrm{span}\\{v_1, A v_1, \\dots, A^{m-1} v_1\\}$ 正交，即 $V_m^\\ast r = 0$。\n\n在单位舍入误差为 $u$ 的浮点算术中，计算出的基向量 $v_j$ 可能会失去正交性，以至于 $V_m^\\ast V_m = I + E$，其中 $E \\in \\mathbb{C}^{m \\times m}$ 是一个虽小但非零的矩阵，满足 $\\|E\\| = \\mathcal{O}(u) \\cdot \\mathrm{poly}(m)$。IRAM 算法应用一个由 $s$ 个位移诱导的隐式多项式滤波器 $p(A)$ 来重启子空间，理想情况下可以抑制不期望的分量，同时保留对期望不变子空间的近似。\n\n请从投影方法和浮点扰动的基本原理出发，分析 Arnoldi 向量间正交性的丧失如何影响 IRAM 中计算出的 Ritz 值的分布，并特别关注伪 Ritz 值和重复 Ritz 值的出现。选择所有正确的陈述。\n\nA. 在有限精度下，Arnoldi 向量之间正交性的丧失意味着从 $H_m$ 计算出的 Ritz 对仍然是 $A$ 在 $\\mathcal{K}_m(A,v_1)$ 上的正交投影的精确特征对，因此不可能出现伪重复 Ritz 值。\n\nB. 当 $V_m^\\ast V_m = I + E$ 且 $E \\neq 0$ 时，计算出的 Ritz 值可以解释为邻近的广义 Rayleigh–Ritz 问题 $(V_m^\\ast A V_m,\\, V_m^\\ast V_m)$ 的精确特征值；$V_m$ 的列向量中的近似线性相关性允许多个 Ritz 向量逼近 $A$ 的同一个不变子空间，从而导致重复的 (幽灵) Ritz 值。\n\nC. 在 IRAM 中，隐式多项式滤波理想情况下会衰减不必要的分量，但正交性的丧失可能导致已经收敛的分量持续存在或泄漏回重启后的子空间中，从而产生复制已收敛特征值的幽灵 Ritz 值；选择性再正交化或锁定等策略可以减轻这种效应。\n\nD. 一个可靠的用于诊断伪重复 Ritz 值的实用方法是，它们的残差范数 $\\|A (V_m y) - \\theta (V_m y)\\|_2$ 远大于真实 Ritz 对的残差范数；因此，大的残差可以标记出伪重复值。\n\nE. 对于正规矩阵 (特别是 Hermitian 矩阵)，正交性的丧失不会在 IRAM 中产生重复的 Ritz 值，因为其值域是凸的；对于正规矩阵 $A$，不会出现幽灵特征值。\n\nF. 保持完全再正交化以使 $V_m$ 在数值上保持标准正交，并显式锁定已收敛的 Ritz 向量，使其保持固定并与活跃的 Krylov 基正交，这种做法消除了在 IRAM 中产生伪重复值的机制，即在这些步骤的精确算术模型中，由正交性丧失引起的重复 Ritz 值不会出现。\n\n选择所有适用的选项。", "solution": "问题陈述描述了用于计算大型矩阵 $A$ 的少数特征值的隐式重启 Arnoldi 方法 (IRAM)。它正确定义了 Arnoldi 分解、Ritz 对、Rayleigh-Ritz 条件以及在有限精度算术中正交性丧失的问题。问题的核心是分析由于这种正交性丧失而导致的伪 Ritz 值或重复 Ritz 值（通常称为“幽灵”特征值）的出现。这些前提基于数值线性代数的标准且成熟的理论，特别是对浮点算术中 Krylov 子空间方法的分析。该问题在科学上是合理的、良定的、客观的，并为评估给定陈述提供了足够的背景。因此，该问题是有效的，我们可以进行分析。\n\n在精确算术中，Arnoldi 方法的基本原理是为 Krylov 子空间 $\\mathcal{K}_m(A, v_1)$ 构建一个标准正交基 $V_m$。Ritz 对 $(\\theta, V_m y)$ 是从 $H_m = V_m^\\ast A V_m$ 的标准特征值问题中导出的，这代表了 $A$ 在 $\\mathcal{K}_m(A, v_1)$ 上的正交投影。其定义属性是 Galerkin 条件：残差 $r = A(V_m y) - \\theta (V_m y)$ 与子空间 $\\mathcal{K}_m(A, v_1)$ 正交，即 $V_m^\\ast r = 0$。\n\n在有限精度算术中，计算出的基（为简单起见，我们仍记为 $V_m$）不再是完全标准正交的。我们有 $V_m^\\ast V_m = I + E$，其中 $E$ 是一个非零矩阵，其范数取决于单位舍入误差 $u$ 和问题参数。计算出的 Ritz 对仍然是通过求解计算出的 Hessenberg 矩阵 $H_m$ 的标准特征值问题得到的。然而，底层的投影不再是正交的。算法试图强制执行的是 Galerkin 条件 $V_m^\\ast (A(V_m y) - \\theta (V_m y)) = 0$。这可以重排为：\n$$\n(V_m^\\ast A V_m) y = \\theta (V_m^\\ast V_m) y\n$$\n这是一个关于矩阵束 $(V_m^\\ast A V_m, V_m^\\ast V_m)$ 的广义特征值问题。计算出的 Ritz 值 $\\theta$ 是这个矩阵束的特征值。\n\n“幽灵”特征值的现象直接源于这个框架。当一个 Ritz 值收敛到 $A$ 的一个真实特征值时，Arnoldi 过程会遭遇基向量灾难性的正交性丧失。基中的后续向量倾向于在相应已收敛特征向量的方向上产生显著分量。当 IRAM 执行重启时，滤波过程旨在丢弃子空间中不需要的部分。然而，由于正交性的丧失，已收敛特征向量的一个分量可能“泄漏”通过滤波器并保留在新循环的起始向量中。然后 Arnoldi 过程会“重新发现”这个特征向量，导致第二个 Ritz 值收敛到 $A$ 的同一个特征值。这就是幽灵。\n\n我们现在根据这些原则评估每个陈述。\n\n**A. 在有限精度下，Arnoldi 向量之间正交性的丧失意味着从 $H_m$ 计算出的 Ritz 对仍然是 $A$ 在 $\\mathcal{K}_m(A,v_1)$ 上的正交投影的精确特征对，因此不可能出现伪重复 Ritz 值。**\n\n这个陈述是**不正确**的。当基 $V_m$ 不是标准正交时，该过程不对应于正交投影。如上所述，它对应于一个广义特征值问题 $(V_m^\\ast A V_m) y = \\theta (V_m^\\ast V_m) y$。这个投影的矩阵将是 $P = V_m (V_m^\\ast V_m)^{-1} V_m^\\ast$，这是一个斜投影算子，而不是正交投影算子。关于伪重复值不可能出现的核心论断在事实上是错误的；它们的出现是有限精度下该方法有充分记载的人为现象，并且是本问题的主要主题。\n\n**B. 当 $V_m^\\ast V_m = I + E$ 且 $E \\neq 0$ 时，计算出的 Ritz 值可以解释为邻近的广义 Rayleigh–Ritz 问题 $(V_m^\\ast A V_m,\\, V_m^\\ast V_m)$ 的精确特征值；$V_m$ 的列向量中的近似线性相关性允许多个 Ritz 向量逼近 $A$ 的同一个不变子空间，从而导致重复的 (幽灵) Ritz 值。**\n\n这个陈述是**正确**的。它准确地指出了在正交性丧失的情况下描述计算出的 Ritz 值的数学框架：它们是广义特征问题 $(V_m^\\ast A V_m, V_m^\\ast V_m)$ 的精确特征值。此外，它正确地指出了这样做的后果。正交性的丧失意味着基向量 $v_j$ 在数值鲁棒的意义上不再是线性无关的。这种“近似线性相关性”正是允许多个不同的基向量线性组合（即多个 Ritz 向量 $V_m y_1, V_m y_2$）逼近 $A$ 的同一个特征向量，从而导致多个 Ritz 值 $\\theta_1, \\theta_2$ 逼近同一个特征值的原因。\n\n**C. 在 IRAM 中，隐式多项式滤波理想情况下会衰减不必要的分量，但正交性的丧失可能导致已经收敛的分量持续存在或泄漏回重启后的子空间中，从而产生复制已收敛特征值的幽灵 Ritz 值；选择性再正交化或锁定等策略可以减轻这种效应。**\n\n这个陈述是**正确**的。它对 IRAM 中导致幽灵特征值的动力学过程给出了精确而准确的描述。隐式重启对基应用一个多项式滤波器 $p(A)$。这旨在分离出期望的不变子空间。然而，由于正交性的丧失已将已收敛特征向量的分量混合到整个基中，滤波是不完美的。一个已收敛的分量可以在重启后“泄漏”回 Krylov 子空间，促使 Arnoldi 过程再次找到它。这就导致了幽灵副本的产生。该陈述正确地列出了两种主要且有效的对策：再正交化（维持基的正交性，通常是选择性地针对已收敛的向量）和锁定（从计算中显式地紧缩掉已收敛的特征向量）。\n\n**D. 一个可靠的用于诊断伪重复 Ritz 值的实用方法是，它们的残差范数 $\\|A (V_m y) - \\theta (V_m y)\\|_2$ 远大于真实 Ritz 对的残差范数；因此，大的残差可以标记出伪重复值。**\n\n这个陈述是**不正确**的。一个“幽灵”特征值通常是 $A$ 的一个真实特征值的非常好的近似，就像它的“真实”对应物一样。因此，真实的 Ritz 对和幽灵 Ritz 对通常都会有很小的残差范数，表明已经收敛。大的残差范数表示近似效果差，即一个未收敛的 Ritz 对，这与幽灵是不同的问题。幽灵的定义性特征不是大残差，而是其作为另一个已收敛 Ritz 值的*副本*的状态。在实践中，人们通过寻找密集聚集且都具有小残差的 Ritz 值簇来检测幽灵。大的残差标记的是一个应被 IRAM 重启滤波器丢弃的 Ritz 值，而不是一个幽灵。\n\n**E. 对于正规矩阵 (特别是 Hermitian 矩阵)，正交性的丧失不会在 IRAM 中产生重复的 Ritz 值，因为其值域是凸的；对于正规矩阵 $A$，不会出现幽灵特征值。**\n\n这个陈述是**不正确**的。Arnoldi 方法对于 Hermitian 矩阵的特例是 Lanczos 算法。幽灵特征值的现象在 Lanczos 算法的背景下是著名且被深入研究的。C. C. Paige 在其 1971 年的开创性论文中，对 Lanczos 算法中正交性的丧失如何导致已收敛特征值的多个副本提供了权威性分析。其机制与为一般 Arnoldi 方法描述的机制相同。值域的凸性（对于正规矩阵，这是其特征值的凸包）是精确算子的一个性质，与这种浮点计算产物无关。\n\n**F. 保持完全再正交化以使 $V_m$ 在数值上保持标准正交，并显式锁定已收敛的 Ritz 向量，使其保持固定并与活跃的 Krylov 基正交，这种做法消除了在 IRAM 中产生伪重复值的机制，即在这些步骤的精确算术模型中，由正交性丧失引起的重复 Ritz 值不会出现。**\n\n这个陈述是**正确**的。它描述了两种最有效且理论上最合理的预防幽灵特征值的策略。\n1.  **完全再正交化：** 通过在工作精度下强制 $V_m^\\ast V_m = I$，该方法在数值上等价于一个正交投影。来自 (B) 的广义特征值问题简化为标准特征值问题，允许多重表示同一特征向量的近似线性相关性被消除。\n2.  **显式锁定：** 一旦一个 Ritz 对 $(\\theta, x)$ 收敛，它就被“锁定”。后续的 IRAM 过程被约束在与所有已锁定向量正交的子空间中。这明确地防止了算法重新发现 $x$。\n限定语“在这些步骤的精确算术模型中”是关键且正确的。它承认这些是算法程序，如果完美执行，可以被证明消除幽灵机制。在实践中，它们是在有限精度下实现的，但它们被设计成是稳定的，并能有效地将幽灵抑制到机器误差的水平。", "answer": "$$\\boxed{BCF}$$", "id": "3589891"}, {"introduction": "将理论知识转化为功能代码是掌握任何计算方法的最终考验。这个综合性编程练习要求你从头开始构建一个类IRAM算法，从而将前面讨论的概念融会贯通。你不仅需要实现核心的Arnoldi迭代和隐式重启动，还需要设计并集成一个基于残差和Ritz值分离度的后验误差估计器。这个估计器将用于驱动收敛判断和设计一个新颖的“移位接受测试”，使你的求解器在面对收敛和重启动的复杂动态时更加稳健。[@problem_id:3589838]", "problem": "您的任务是为隐式重启动 Arnoldi 方法 (IRAM) 中的 Ritz 特征对设计并实现一个后验误差估计器，并将其集成到收敛的停止准则和重启动过程中的位移接受测试中。您的最终答案必须是一个完整的、可运行的程序，该程序能够针对指定的矩阵测试套件和 IRAM 参数，计算收敛的特征对数量、已接受特征对中的最大后验估计器值以及因位移接受测试而被拒绝的位移数量。输出必须是包含如下指定的嵌套列表的单行文本。\n\n从以下数值线性代数的基本知识开始：\n- Arnoldi 分解：给定一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 和一个起始单位向量 $v_{1}$，一步 Arnoldi 过程构建一个标准正交基 $V_{m+1} = [v_{1},\\dots,v_{m+1}] \\in \\mathbb{C}^{n \\times (m+1)}$ 和一个上 Hessenberg 矩阵 $H \\in \\mathbb{C}^{(m+1) \\times m}$，使得\n$$\nA V_{m} = V_{m+1} \\bar{H},\n$$\n其中 $V_{m}$ 由 $V_{m+1}$ 的前 $m$ 列组成，$\\bar{H}$ 是 $H$ 的前导 $(m+1) \\times m$ 部分，其上次对角线元素为 $h_{m+1,m}$。\n- Ritz 对：如果 $(\\theta, z)$ 是 $H_{m} \\in \\mathbb{C}^{m \\times m}$ 的一个特征对，那么 $(\\theta, y)$（其中 $y = V_{m} z$）是 $A$ 在 Krylov 子空间 $\\mathcal{K}_{m}(A, v_{1})$ 中的一个 Ritz 对；对应的残差为 $r = A y - \\theta y$，并满足\n$$\n\\|r\\|_{2} = |h_{m+1,m}| \\cdot |e_{m}^{\\top} z|,\n$$\n其中 $e_{m} \\in \\mathbb{R}^{m}$ 是第 $m$ 个标准基向量。\n- 分离度：对于一个正规矩阵 $A$ 的一个简单目标特征值 $\\theta$，一个标准的后验界是\n$$\n\\sin(\\angle(y, \\mathcal{X})) \\le \\frac{\\|r\\|_{2}}{\\operatorname{sep}(\\theta, \\Lambda(A)\\setminus\\{\\theta\\})},\n$$\n其中 $\\mathcal{X}$ 是与 $\\theta$ 相关联的不变子空间，$\\operatorname{sep}(\\theta, \\Lambda(A)\\setminus\\{\\theta\\})$ 是 $\\theta$ 到谱中其余部分的距离。在实践中，$\\operatorname{sep}$ 是未知的；通常用一个根据已计算的 Ritz 值估计的代理值来代替它。\n\n您的任务是：\n- 推导并实现一个后验估计器\n$$\n\\eta(\\theta, y) = \\frac{\\|r\\|_{2}}{\\widehat{\\operatorname{sep}}(\\theta)},\n$$\n其中 $\\|r\\|_{2}$ 如上所述，$\\widehat{\\operatorname{sep}}(\\theta)$ 是一个仅基于当前 Ritz 值（以及任何先前“锁定”的 Ritz 值）的可计算分离度代理。\n- 将此估计器集成到：\n  1. 一个停止判据，当 $\\eta(\\theta, y) \\le \\tau$ 时，宣布 Ritz 对 $(\\theta, y)$ 收敛，其中 $\\tau$ 是用户提供的容差。\n  2. 一个用于 IRAM 重启动的位移接受测试，如果一个建议的位移 $\\mu$ 相对于相应的估计器而言，过于接近任何已接受的“锁定”特征值 $\\theta_{\\ell}$，则拒绝该位移。具体来说，当以下条件成立时拒绝 $\\mu$\n  $$\n  |\\mu - \\theta_{\\ell}|  \\gamma \\cdot \\eta(\\theta_{\\ell}, y_{\\ell}) \\cdot \\widehat{\\operatorname{sep}}_{\\mathrm{guard}}(\\theta_{\\ell}),\n  $$\n  其中 $\\gamma  0$ 是一个固定的保护因子，$\\widehat{\\operatorname{sep}}_{\\mathrm{guard}}(\\theta_{\\ell})$ 是一个从可用的 Ritz 信息中导出的保护分离度代理。一旦拒绝，就用一个修改后的位移替换 $\\mu$，使其移动到至少这个受保护的距离之外，并对拒绝进行计数。\n\n算法约束和交付成果：\n- 实现一个类似 IRAM 的重启动 Arnoldi 方案，该方案：\n  - 构建一个长度为 $m$ 的 Arnoldi 分解。\n  - 使用 Arnoldi 关系式计算 Ritz 对和残差范数。\n  - 使用估计器 $\\eta$ 来锁定收敛的 Ritz 对，并在后续循环中将 Krylov 子空间与锁定的子空间进行正交化。\n  - 根据最大模目标的选择，从“不需要”的 Ritz 值中选取 $p = m - k$ 个位移，通过多项式 $\\prod_{j=1}^{p} (A - \\mu_{j} I)$ 对起始向量进行滤波以应用重启动，并强制执行位移接受测试（对拒绝进行计数）。\n- 您的估计器必须按如下方式计算：\n  - 对于每个 Ritz 值 $\\theta$，定义\n    $$\n    \\widehat{\\operatorname{sep}}(\\theta) = \\min_{\\nu \\in \\mathcal{S}(\\theta)} |\\theta - \\nu|,\n    $$\n    其中 $\\mathcal{S}(\\theta)$ 是所有其他当前 Ritz 值以及任何锁定的 Ritz 值的集合，不包括 $\\theta$ 本身。如果 $\\mathcal{S}(\\theta)$ 为空，则将 $\\widehat{\\operatorname{sep}}(\\theta)$ 设置为一个很小的正数以避免除以零。\n  - 令 $\\|r\\|_{2} = |h_{m+1,m}| \\cdot |e_{m}^{\\top} z|$，其中 $z$ 是 $H_{m}$ 对应的特征向量。\n  - 那么 $\\eta(\\theta, y) = \\|r\\|_{2} / \\widehat{\\operatorname{sep}}(\\theta)$。\n- 在位移接受测试中使用该估计器，并设置保护因子 $\\gamma = 2$。\n\n实现细节：\n- 使用以下矩阵和参数构建三个测试用例。所有维度和参数都以普通数字表示，但上述数学表达式中的所有数字都必须被视为符号；本问题不涉及物理单位。\n  1. 对称三对角拉普拉斯矩阵：$A_{1} \\in \\mathbb{R}^{n_{1} \\times n_{1}}$，其中 $n_{1} = 100$ 且\n     $$\n     A_{1} = \\operatorname{tridiag}(-1, 2, -1),\n     $$\n     即对角线上为 $2$，第一条次对角线和超对角线上为 $-1$。目标是 $k_{1} = 3$ 个最大模的特征对。使用 Arnoldi 维度 $m_{1} = 25$，最大外部重启动次数 $I_{1} = 200$，容差 $\\tau_{1} = 10^{-8}$。\n  2. 簇状对称对角矩阵：$A_{2} \\in \\mathbb{R}^{n_{2} \\times n_{2}}$，其中 $n_{2} = 60$，对角线元素为\n     $$\n     \\operatorname{diag}(1,2,\\dots,57, 29.999, 30.000, 30.001),\n     $$\n     即在顶部附近有一个包含三个元素的簇。目标是 $k_{2} = 2$ 个最大模的特征对。使用 $m_{2} = 20$, $I_{2} = 200$，容差 $\\tau_{2} = 10^{-6}$。\n  3. 非正规上双对角矩阵：$A_{3} \\in \\mathbb{R}^{n_{3} \\times n_{3}}$，其中 $n_{3} = 80$，对角线元素在 $1$ 到 $50$ 之间线性分布，恒定的超对角线元素等于 $5$。目标是 $k_{3} = 4$ 个最大模的特征对。使用 $m_{3} = 25$, $I_{3} = 200$，容差 $\\tau_{3} = 10^{-8}$。\n\n您的程序必须：\n- 对每个测试用例，运行所述的、由估计器驱动收敛和位移接受的类 IRAM 重启动 Arnoldi 方法。当存在锁定的向量时，对其进行正交化。\n- 对每个测试用例，返回一个包含三个条目的列表：\n  1. 终止时收敛的特征对的整数计数（最多应为目标 $k$）。\n  2. 终止时锁定的特征对中的最大估计器值 $\\max \\eta$ 的浮点数值。\n  3. 在所有重启动中，因位移接受测试而被拒绝的位移的整数计数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表的列表，按顺序包含三个测试用例的结果。例如：\n\"[ [c1, e1, s1], [c2, e2, s2], [c3, e3, s3] ]\"\n其中 $c_{j}$ 是整数表示的收敛计数，$e_{j}$ 是浮点数表示的最大估计器值，$s_{j}$ 是测试用例 $j$ 的整数表示的拒绝计数。\n\n不涉及物理单位，因此不需要单位说明。不使用角度。所有百分比（如有）必须表示为小数或分数，而不是使用百分号；然而，这里不需要百分比。", "solution": "任务是设计并实现一个隐式重启动 Arnoldi 方法 (IRAM)，该方法包含一个用于收敛性评估和位移接受测试的特定后验误差估计器。该解决方案围绕 Krylov 子空间方法和特征值计算的基本原理构建。\n\n### 1. Arnoldi 分解\n\n该方法的基础是 Arnoldi 分解。对于给定的矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 和起始单位向量 $v_1 \\in \\mathbb{C}^n$，Arnoldi 迭代为 Krylov 子空间 $\\mathcal{K}_m(A, v_1) = \\operatorname{span}\\{v_1, Av_1, \\dots, A^{m-1}v_1\\}$ 构建一个标准正交基 $V_m = [v_1, v_2, \\dots, v_m]$。此过程同时生成一个上 Hessenberg 矩阵 $H_m \\in \\mathbb{C}^{m \\times m}$。经过 $m$ 步后，我们得到 Arnoldi 分解：\n$$A V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^T$$\n其中 $V_{m+1} = [V_m, v_{m+1}]$，$e_m$ 是 $\\mathbb{R}^m$ 中的第 $m$ 个标准基向量，$h_{m+1,m} \\ge 0$ 是一个标量。向量 $v_j$ 是通过 Gram-Schmidt 正交化过程生成的。具体来说，对于 $j = 1, \\dots, m$：\n1. 计算 $w = A v_j$。\n2. 将 $w$ 与先前的基向量 $\\{v_1, \\dots, v_j\\}$ 进行正交化。对于 $i=1, \\dots, j$，设置 $h_{i,j} = v_i^H w$ 并更新 $w \\leftarrow w - h_{i,j} v_i$。\n3. 计算范数 $h_{j+1,j} = \\|w\\|_2$。\n4. 如果 $h_{j+1,j}$ 接近于零（发生崩溃），过程可能停止。否则，进行归一化以获得下一个向量：$v_{j+1} = w / h_{j+1,j}$。\n\n### 2. Ritz 对、残差和误差估计\n\n小 Hessenberg 矩阵 $H_m$ 的特征对为大矩阵 $A$ 的特征对提供了近似。如果 $(\\theta, z)$ 是 $H_m$ 的一个特征对，即 $H_m z = \\theta z$ 且 $\\|z\\|_2 = 1$，则对 $(\\theta, y)$（其中 $y = V_m z$）被称为 $A$ 的一个 Ritz 对。值 $\\theta$ 是一个 Ritz 值，而 $y$ 是一个 Ritz 向量。\n\n残差 $r = Ay - \\theta y$ 衡量了 Ritz 对满足 $A$ 的特征值方程的程度。Arnoldi 分解的一个关键特性是，可以在不构建 $n$ 维向量 $y$ 的情况下，低成本地计算此残差的范数：\n$$ \\|r\\|_2 = \\|AV_m z - \\theta V_m z\\|_2 = \\|(V_m H_m + h_{m+1,m} v_{m+1} e_m^T)z - V_m (\\theta z)\\|_2 $$\n$$ \\|r\\|_2 = \\|V_m(H_m z - \\theta z) + h_{m+1,m} v_{m+1} (e_m^T z)\\|_2 = \\|h_{m+1,m} (e_m^T z) v_{m+1}\\|_2 = |h_{m+1,m}| \\cdot |e_m^T z| $$\n该公式为 Ritz 对提供了精确的残差范数。\n\n问题要求构建一个后验误差估计器 $\\eta(\\theta, y)$。该估计器的灵感来源于 Ritz 向量与真实不变子空间之间夹角的界，这些界通常涉及特征值与谱中其余部分的分离度。我们将该估计器定义为：\n$$ \\eta(\\theta, y) = \\frac{\\|r\\|_2}{\\widehat{\\operatorname{sep}}(\\theta)} $$\n其中分离度代理 $\\widehat{\\operatorname{sep}}(\\theta)$ 是根据可用的 Ritz 值计算的：\n$$ \\widehat{\\operatorname{sep}}(\\theta) = \\min_{\\nu \\in \\mathcal{S}(\\theta)} |\\theta - \\nu| $$\n集合 $\\mathcal{S}(\\theta)$ 包含来自 $m \\times m$ 分析的所有其他当前 Ritz 值，以及任何先前计算并“锁定”的特征值。如果 $\\mathcal{S}(\\theta)$ 为空，则将 $\\widehat{\\operatorname{sep}}(\\theta)$ 设置为一个小的正常数以防止除以零。\n\n### 3. 收敛与锁定\n\n如果一个 Ritz 对 $(\\theta, y)$ 的估计器值低于给定容差 $\\tau$，则该对被声明为“收敛”并被“锁定”：\n$$ \\eta(\\theta, y) \\le \\tau $$\n一旦一个 Ritz 对被锁定，其 Ritz 向量就会被存储。后续的 Arnoldi 迭代将在与所有锁定的 Ritz 向量张成的空间正交的子空间中进行。这是通过在标准的 Gram-Schmidt 过程之前，将每个新向量 $w=Av_j$ 与锁定的向量进行显式正交化来实现的。设 $W_{\\text{lock}}$ 是其列为已锁定的标准正交化 Ritz 向量的矩阵。那么投影操作为 $w \\leftarrow w - W_{\\text{lock}}(W_{\\text{lock}}^H w)$。\n\n### 4. 隐式重启动与位移接受\n\nIRAM 将 Arnoldi 分解与重启动机制相结合，以维持一个固定大小的 Krylov 子空间，从而节省内存和计算成本。在构建了大小为 $m$ 的 Arnoldi 分解后，我们试图将最有价值的谱信息提炼到一个更小的、大小为 $k  m$ 的分解中。这是通过对起始向量隐式应用一个滤波多项式来完成的。\n\n过程如下：\n1.  **位移选择**：从 $m$ 个计算出的 Ritz 值中，将 $k$ 个识别为“想要的”（例如，按问题要求，那些模最大的），而 $p=m-k$ 个是“不想要的”。这 $p$ 个不想要的 Ritz 值 $\\{\\mu_1, \\dots, \\mu_p\\}$ 被用作隐式 QR 算法的位移。\n2.  **位移接受测试**：在使用位移之前，对每个提议的位移 $\\mu_j$ 进行测试。问题指定了一个新颖的测试，以防止位移过于接近已经收敛的“锁定”特征值 $\\theta_\\ell$。如果对于任何锁定的特征值 $\\theta_\\ell$，以下条件成立，则拒绝位移 $\\mu$：\n    $$ |\\mu - \\theta_\\ell|  \\gamma \\cdot \\eta_\\ell \\cdot \\widehat{\\operatorname{sep}}_{\\mathrm{guard}}(\\theta_\\ell) $$\n    其中 $\\gamma=2$ 是一个保护因子，$\\eta_\\ell$ 是为锁定对存储的估计器值，$\\widehat{\\operatorname{sep}}_{\\mathrm{guard}}(\\theta_\\ell)$ 是使用当前所有可用 Ritz 值（包括锁定的和来自最新 $m$ 步分解的）为 $\\theta_\\ell$ 计算的分离度代理。如果一个位移被拒绝，它将被一个移动到该排斥区域边界的修改值所取代，并且拒绝位移的计数器会增加。\n3.  **QR 追踪**：使用 $p$ 个（可能已修改的）位移对 Hessenberg 矩阵 $H_m$ 执行 $p$ 步隐式位移 QR 算法。如果 $H_m^{(0)} = H_m$，则使用位移 $\\mu$ 的一步是：\n    $$ H_m^{(j-1)} - \\mu_j I = Q_j R_j \\quad \\implies \\quad H_m^{(j)} = R_j Q_j + \\mu_j I $$\n    正交变换被累积成一个单一矩阵 $Q_{\\text{accum}} = Q_1 Q_2 \\dots Q_p$。\n4.  **分解更新**：QR 追踪会转换该分解。原始关系 $A V_m = V_m H_m + \\beta v_{m+1} e_m^T$ 被更新为一个新的、更小的、大小为 $k$ 的分解：$A V'_k = V'_k H'_k + \\beta' v'_{k+1} e_k^T$。新分量由变换后的矩阵导出：\n    -   新的 $k$ 维子空间基：$V'_k = V_m Q_{\\text{accum}}[:, :k]$\n    -   新的 $k$ 维 Hessenberg 矩阵：$H'_k = H_m^{(p)}[:k, :k]$\n    -   新的残差项标量：$\\beta' = h'_{k+1,k}$，即 $H_m^{(p)}$ 的 $(k, k-1)$ 项（0-索引）。\n    -   新的残差向量：$v'_{k+1} = (V_m Q_{\\text{accum}})[:, k]$。\n这个新的 $k$ 维分解作为下一个 Arnoldi 扩张周期的起点。\n\n### 5. 算法摘要\n\n完整的 IRAM 过程将这些组件集成到一个迭代循环中：\n\n1.  **初始化**：从一个随机单位向量 $v_1$ 和一个空的锁定特征对集合开始。将计数器置零。\n2.  **外层循环**：重复执行，直到达到最大重启动次数或收敛。\n    a. **Arnoldi 扩张**：如果当前分解的大小小于 $m$，则使用第 1 节中描述的 Arnoldi 过程将其扩展到大小 $m$，确保与任何锁定的向量正交。\n    b. **特征分析**：从 $m \\times m$ 的 Hessenberg 矩阵 $H_m$ 计算 Ritz 对 $(\\theta_j, y_j)$。\n    c. **收敛检查**：对于每个 Ritz 对，计算残差范数 $\\|r_j\\|_2$ 和估计器 $\\eta_j$。识别出满足 $\\eta_j \\le \\tau$ 的新收敛对。\n    d. **锁定**：将新收敛的对添加到锁定集合中。如果锁定对的数量达到目标 $k$，则成功终止。\n    e. **重启动**：如果未收敛，准备重启动。\n        i. 选择 $p = m - k$ 个不需要的 Ritz 值作为位移。\n        ii. 应用位移接受测试，根据需要修改位移并计数拒绝次数。\n        iii. 对 $H_m$ 使用选定的位移执行 QR 追踪，得到 $H'_m$ 和 $Q_{\\text{accum}}$。\n        iv. 如第 4 节所述，将分解更新为新的 $k$ 维分解。这为下一个扩张步骤提供了起点。\n3.  **终止**：循环结束时，报告收敛的特征对数量、它们中的最大估计器值以及被拒绝位移的总数。", "answer": "```python\nimport numpy as np\n\ndef run_iram_case(A, k, m, max_restarts, tol):\n    \"\"\"\n    Implements the Implicitly Restarted Arnoldi Method with a custom error estimator.\n\n    Args:\n        A (np.ndarray): The matrix for which to find eigenvalues.\n        k (int): The number of eigenvalues to find.\n        m (int): The dimension of the Arnoldi factorization (m > k).\n        max_restarts (int): The maximum number of restart iterations.\n        tol (float): The convergence tolerance for the estimator.\n\n    Returns:\n        tuple: (number of converged pairs, max estimator value, number of rejected shifts).\n    \"\"\"\n    n = A.shape[0]\n    \n    # Use complex numbers to handle non-symmetric cases\n    locked_V = np.zeros((n, 0), dtype=np.complex128)\n    locked_thetas = []\n    locked_etas = []\n    rejected_shifts = 0\n\n    # Initial Arnoldi factorization of size 1\n    v = np.random.rand(n)\n    if A.dtype != np.complex128:\n        v = v.astype(A.dtype) # match types if possible early\n    v = v / np.linalg.norm(v)\n\n    V = np.zeros((n, m + 1), dtype=np.complex128)\n    H = np.zeros((m + 1, m), dtype=np.complex128)\n    V[:, 0] = v\n    \n    current_m = 0\n\n    for i_restart in range(max_restarts):\n        # 1. Arnoldi expansion from current_m to m\n        start_j = current_m\n        for j in range(start_j, m):\n            w = A @ V[:, j]\n            w = w.astype(np.complex128)\n\n            if locked_V.shape[1] > 0:\n                w -= locked_V @ (locked_V.conj().T @ w)\n\n            # Modified Gram-Schmidt against current Arnoldi vectors\n            for l in range(j + 1):\n                h_lj = V[:, l].conj().T @ w\n                w -= h_lj * V[:, l]\n                H[l, j] = h_lj\n            \n            h_jp1_j = np.linalg.norm(w)\n            H[j + 1, j] = h_jp1_j\n\n            if h_jp1_j  1e-12:  # Breakdown\n                m = j + 1 # Reduce m dynamically\n                H = H[:m+1, :m]\n                V = V[:, :m+1]\n                break\n            \n            V[:, j + 1] = w / h_jp1_j\n        \n        # 2. Eigen-analysis of H_m\n        H_m = H[:m, :m]\n        try:\n            thetas, Z = np.linalg.eig(H_m)\n        except np.linalg.LinAlgError:\n            break # Eigendecomposition failed, terminate\n\n        # 3. Compute estimator and check convergence\n        res_norms = np.abs(H[m, m-1] * Z[m-1, :])\n        all_potential_ritz = list(thetas) + locked_thetas\n        \n        newly_converged_indices = []\n        etas = np.full(m, np.inf, dtype=float)\n\n        for j in range(m):\n            theta_j = thetas[j]\n            is_already_locked = any(np.isclose(theta_j, lt) for lt in locked_thetas)\n            if is_already_locked:\n                continue\n\n            other_vals = [nu for nu in all_potential_ritz if not np.isclose(nu, theta_j)]\n            if not other_vals:\n                sep_j = np.finfo(float).eps\n            else:\n                sep_j = np.min(np.abs(theta_j - np.array(other_vals)))\n            \n            if sep_j > np.finfo(float).eps:\n                etas[j] = res_norms[j] / sep_j\n            \n            if etas[j] = tol:\n                newly_converged_indices.append(j)\n\n        # 4. Locking\n        if newly_converged_indices:\n            sorted_new_indices = sorted(newly_converged_indices, key=lambda j: res_norms[j])\n            \n            \n            can_lock_count = k - len(locked_thetas)\n            for j in sorted_new_indices[:can_lock_count]:\n                theta_j, z_j, eta_j = thetas[j], Z[:, j], etas[j]\n                \n                y_j = V[:, :m] @ z_j\n                y_j /= np.linalg.norm(y_j)\n\n                new_locked_V = np.hstack([locked_V, y_j[:, np.newaxis]])\n                if new_locked_V.shape[1] > 1:\n                    Q_lock, _ = np.linalg.qr(new_locked_V)\n                    locked_V = Q_lock\n                else:\n                    locked_V = new_locked_V\n\n                locked_thetas.append(theta_j)\n                locked_etas.append(eta_j)\n\n        # 5. Termination check\n        if len(locked_thetas) >= k:\n            break\n\n        # 6. Restart Preparation\n        # For largest magnitude, unwanted shifts are smallest magnitude Ritz values.\n        sort_indices = np.argsort(np.abs(thetas))\n        unwanted_indices = sort_indices[:m - k]\n        shifts = thetas[unwanted_indices]\n        \n        # 7. Shift Acceptance Test\n        gamma = 2.0\n        current_ritz_and_locked = list(thetas) + locked_thetas\n        modified_shifts = []\n        for mu in shifts:\n            is_rejected = False\n            for idx_l, theta_l in enumerate(locked_thetas):\n                eta_l = locked_etas[idx_l]\n                \n                other_vals_guard = [nu for nu in current_ritz_and_locked if not np.isclose(nu, theta_l)]\n                if not other_vals_guard:\n                    sep_guard = np.finfo(float).eps\n                else:\n                    sep_guard = np.min(np.abs(theta_l - np.array(other_vals_guard)))\n                \n                if sep_guard  np.finfo(float).eps: continue\n\n                guard_dist = gamma * eta_l * sep_guard\n                if np.abs(mu - theta_l)  guard_dist:\n                    rejected_shifts += 1\n                    direction = mu - theta_l\n                    if np.abs(direction)  1e-12:\n                        direction = 1.0\n                    mu = theta_l + direction / np.abs(direction) * guard_dist\n                    is_rejected = True\n                    break\n            modified_shifts.append(mu)\n        shifts = np.array(modified_shifts)\n\n        # 8. Implicit Restart (QR Chase)\n        H_chase = np.copy(H[:m, :m])\n        Q_accum = np.identity(m, dtype=np.complex128)\n        \n        for mu in shifts:\n            Q_qr, R_qr = np.linalg.qr(H_chase - mu * np.identity(m))\n            H_chase = R_qr @ Q_qr + mu * np.identity(m)\n            Q_accum = Q_accum @ Q_qr\n                \n        # 9. Update Factorization\n        V_old_m = V[:, :m]\n        beta = H[m, m-1]\n        v_m_plus_1 = V[:, m]\n\n        V_k_prime = V_old_m @ Q_accum[:, :k]\n        H_k_prime = H_chase[:k, :k]\n        beta_prime = H_chase[k, k-1]\n        v_kp1_prime = V_old_m @ Q_accum[:, k]\n        \n        V = np.zeros((n, m + 1), dtype=np.complex128)\n        H = np.zeros((m + 1, m), dtype=np.complex128)\n        \n        V[:, :k] = V_k_prime\n        V[:, k] = v_kp1_prime\n        H[:k, :k] = H_k_prime\n        H[k, k - 1] = beta_prime\n        \n        current_m = k\n    \n    num_converged = len(locked_thetas)\n    max_eta = max(locked_etas) if locked_etas else 0.0\n    \n    return num_converged, max_eta, rejected_shifts\n\n\ndef solve():\n    \"\"\"\n    Sets up and runs the three test cases specified in the problem.\n    \"\"\"\n    # Case 1\n    n1 = 100\n    A1 = np.diag(-1 * np.ones(n1 - 1), -1) + np.diag(2 * np.ones(n1), 0) + np.diag(-1 * np.ones(n1 - 1), 1)\n    k1, m1, I1, tau1 = 3, 25, 200, 1e-8\n\n    # Case 2\n    n2 = 60\n    diag_vals2 = list(range(1, 58)) + [29.999, 30.000, 30.001]\n    A2 = np.diag(np.sort(diag_vals2))\n    k2, m2, I2, tau2 = 2, 20, 200, 1e-6\n\n    # Case 3\n    n3 = 80\n    A3 = np.diag(np.linspace(1, 50, n3)) + np.diag(5 * np.ones(n3 - 1), 1)\n    k3, m3, I3, tau3 = 4, 25, 200, 1e-8\n\n    test_cases = [\n        (A1, k1, m1, I1, tau1),\n        (A2, k2, m2, I2, tau2),\n        (A3, k3, m3, I3, tau3),\n    ]\n\n    results = []\n    # Set a seed for reproducibility of the random starting vector.\n    np.random.seed(42)\n    for A, k, m, max_restarts, tol in test_cases:\n        res = run_iram_case(A, k, m, max_restarts, tol)\n        results.append(list(res))\n\n    # Format output as specified\n    result_str = \"[\"\n    for i, res in enumerate(results):\n        c, e, s = res\n        result_str += f\"[{c}, {e}, {s}]\"\n        if i  len(results) - 1:\n            result_str += \", \"\n    result_str += \"]\"\n    print(result_str)\n\nsolve()\n\n```", "id": "3589838"}]}