{"hands_on_practices": [{"introduction": "缩放与求方法的第一步是确定缩放因子 $s$，以确保缩放后矩阵 $A/2^s$ 的范数足够小，使得Padé近似能够达到预期的精度。这个练习将带你亲手计算这个关键的缩放因子，并深入探讨在众多矩阵范数中，为何选择1-范数作为该算法实际应用中的标准，从而帮助你理解理论要求与计算效率之间的权衡。[@problem_id:3576136]", "problem": "考虑一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的矩阵指数 $\\exp(A)$，它由绝对收敛的幂级数 $\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}$ 定义。一种广泛用于数值计算 $\\exp(A)$ 的方法是缩放平方法。该方法首先通过除以2的幂次来缩放矩阵 $A$ 以减小其范数，然后对缩放后的矩阵应用一个选定阶数 $m$ 的有理Padé逼近，最后进行重复平方。对于选定的Padé阶数 $m$，假设有一个相应的容许阈值 $\\theta_{m}  0$，使得只要输入矩阵 $X$ 满足 $\\|X\\|_{1} \\le \\theta_{m}$，Padé逼近就能达到指定的精度。此处 $\\|\\cdot\\|_{1}$ 表示矩阵的诱导1-范数，定义为 $\\|A\\|_{1} = \\max_{1 \\le j \\le n} \\sum_{i=1}^{n} |a_{ij}|$，它从属于向量1-范数，并且是一种次乘法、绝对齐次的范数。\n\n给定一个矩阵 $A$，其已知的诱导1-范数为 $\\|A\\|_{1} = 683.12$。您选择Padé阶数 $m = 9$，其对应的容许阈值为 $\\theta_{9} = 4.3$。请确定最小的非负整数 $s$，使得 $\\left\\|A / 2^{s}\\right\\|_{1} \\le \\theta_{9}$ 成立。此外，请从核心定义和关于诱导范数及其与界定矩阵函数关系的公认事实出发，为在缩放平方法的缩放步骤里使用不等式 $\\left\\|A / 2^{s}\\right\\|_{1} \\le \\theta_{m}$ 中的诱导1-范数提供一个原则性论证。最终答案必须是确切的整数 $s$。", "solution": "评估问题陈述的有效性。\n\n**步骤1：提取已知条件**\n-   矩阵指数定义：对于实方阵 $A \\in \\mathbb{R}^{n \\times n}$，$\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}$。\n-   数值方法：缩放平方法，使用 $m$ 阶有理Padé逼近。\n-   $m$ 阶的容许阈值：$\\theta_{m}  0$。\n-   逼近的精度条件：$\\|X\\|_{1} \\le \\theta_{m}$。\n-   诱导1-范数定义：$\\|A\\|_{1} = \\max_{1 \\le j \\le n} \\sum_{i=1}^{n} |a_{ij}|$。\n-   给定的矩阵范数：$\\|A\\|_{1} = 683.12$。\n-   选定的Padé阶数：$m = 9$。\n-   给定的容许阈值：$\\theta_{9} = 4.3$。\n-   任务1：找到满足 $\\left\\|A / 2^{s}\\right\\|_{1} \\le \\theta_{9}$ 的最小非负整数 $s$。\n-   任务2：为在缩放步骤的不等式中使用诱导1-范数提供一个原则性论证。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：这个问题是在数值线性代数的背景下提出的，具体涉及矩阵指数的计算。缩放平方法、Padé逼近、矩阵范数以及像 $\\theta_m$ 这样的阈值的使用都是该领域的标准、成熟的概念。给定的数值在数值上是合理的。整个前提在科学上是合理的。\n-   **良态性**：该问题要求两项不同的内容：基于一个明确不等式计算整数 $s$，以及对该方法论的理论论证。第一部分是标准的代数操作，有唯一的整数解。第二部分要求解释一个著名算法中的一个基本选择，这有一个基于矩阵范数理论的标准、有原则的答案。\n-   **客观性**：该问题使用精确、无歧义的数学和数值术语陈述。\n\n**步骤3：结论与行动**\n该问题是有效的，因为它具有科学依据、良态、客观且自洽。将提供完整的解决方案。\n\n问题包括两个部分。第一部分是计算缩放参数 $s$，第二部分是论证在算法中使用特定范数的合理性。\n\n**第1部分：确定缩放参数 $s$**\n\n我们的任务是找到满足以下不等式的最小非负整数 $s$：\n$$ \\left\\|\\frac{A}{2^{s}}\\right\\|_{1} \\le \\theta_{9} $$\n诱导1-范数与所有诱导矩阵范数一样，是绝对齐次的。此性质表明，对于任何标量 $c \\in \\mathbb{R}$ 和任何矩阵 $M \\in \\mathbb{R}^{n \\times n}$，我们有 $\\|cM\\|_{1} = |c| \\|M\\|_{1}$。\n将此性质应用于不等式左侧，其中标量 $c = \\frac{1}{2^{s}}$：\n$$ \\left\\|\\frac{A}{2^{s}}\\right\\|_{1} = \\left|\\frac{1}{2^{s}}\\right| \\|A\\|_{1} $$\n由于 $s$ 是一个非负整数，$2^{s}$ 是严格正数，因此 $\\left|\\frac{1}{2^{s}}\\right| = \\frac{1}{2^{s}}$。不等式变为：\n$$ \\frac{1}{2^{s}} \\|A\\|_{1} \\le \\theta_{9} $$\n我们已知数值 $\\|A\\|_{1} = 683.12$ 和 $\\theta_{9} = 4.3$。将它们代入不等式中得出：\n$$ \\frac{1}{2^{s}} (683.12) \\le 4.3 $$\n为了求 $s$，我们整理不等式以分离出项 $2^{s}$：\n$$ 683.12 \\le 4.3 \\times 2^{s} $$\n$$ 2^{s} \\ge \\frac{683.12}{4.3} $$\n计算右侧的分数得出：\n$$ 2^{s} \\ge 158.865116... $$\n为了找到满足此条件的最小整数 $s$，我们可以对两边取以2为底的对数：\n$$ \\log_{2}(2^{s}) \\ge \\log_{2}(158.865116...) $$\n$$ s \\ge \\log_{2}(158.865116...) $$\n这可以计算为：\n$$ s \\ge \\frac{\\ln(158.865116...)}{\\ln(2)} \\approx \\frac{5.06803}{0.69315} \\approx 7.3129 $$\n由于 $s$ 必须是整数，满足此条件的最小整数值是 $7.3129$ 的向上取整，即 $8$。\n我们可以通过检查2的整数次幂来验证：\n当 $s=7$ 时，$2^{7} = 128$，不大于或等于 $158.865...$。\n当 $s=8$ 时，$2^{8} = 256$，大于或等于 $158.865...$。\n因此，最小的非负整数是 $s=8$。\n\n**第2部分：使用诱导1-范数的合理性论证**\n\n在不等式 $\\left\\|A / 2^{s}\\right\\|_{1} \\le \\theta_{m}$ 中使用诱导1-范数的理由基于两大支柱：矩阵函数误差分析的理论要求和计算效率的实际考量。\n\n1.  **理论要求：次乘法性**\n    对矩阵指数的Padé逼近 $r_{m}(X) \\approx \\exp(X)$ 进行误差分析，依赖于对误差矩阵 $E(X) = \\exp(X) - r_m(X)$ 范数的界定。误差本身可以用矩阵幂级数表示。例如，误差的一个常见表示形式涉及形如 $\\sum_{k=2m+1}^{\\infty} c_k X^k$ 的级数。\n\n    为了界定这样一个级数的范数，我们使用三角不等式和矩阵范数的一个关键性质。对于幂级数 $f(A) = \\sum_{k=0}^{\\infty} c_k A^k$，我们有：\n    $$ \\|f(A)\\| = \\left\\|\\sum_{k=0}^{\\infty} c_k A^k\\right\\| \\le \\sum_{k=0}^{\\infty} \\|c_k A^k\\| = \\sum_{k=0}^{\\infty} |c_k| \\|A^k\\| $$\n    要从这里继续，我们需要界定 $\\|A^k\\|$。这就是矩阵范数的**次乘法**性质变得至关重要的地方。如果对于任意两个矩阵 $M_1, M_2 \\in \\mathbb{R}^{n \\times n}$，范数 $\\|\\cdot\\|$ 满足 $\\|M_1 M_2\\| \\le \\|M_1\\| \\|M_2\\|$，则该范数是次乘法的。通过重复应用此性质，我们得到界 $\\|A^k\\| \\le \\|A\\|^k$。\n\n    将此代入级数界中，得到：\n    $$ \\|f(A)\\| \\le \\sum_{k=0}^{\\infty} |c_k| \\|A\\|^k $$\n    这使我们能够通过标量函数 $f_{\\text{abs}}(\\|A\\|) = \\sum_{k=0}^{\\infty} |c_k| \\|A\\|^k$ 来界定矩阵函数 $f(A)$ 的范数。所有的诱导p-范数，包括1-范数、2-范数和$\\infty$-范数，都是次乘法的，这使它们适合于这项理论任务。阈值 $\\theta_{m}$ 正是通过这类误差分析精确确定的，它保证了如果对于一个合适的次乘法范数有 $\\|X\\| \\le \\theta_{m}$，则Padé逼近的相对误差会被一个期望的容差（例如，机器精度）所界定。\n\n2.  **实际考量：计算成本**\n    尽管理论上任何次乘法范数都可以用来建立收敛性和误差界，但在实际算法中选择范数还必须考虑计算成本。算法的缩放步骤需要计算输入矩阵 $A$ 的范数以确定缩放因子 $s$。\n\n    -   **诱导1-范数** $\\|A\\|_{1} = \\max_{j} \\sum_{i} |a_{ij}|$，通过找到最大的绝对列和来计算。这需要与矩阵中非零元素数量成正比的加法和比较次数，对于稠密矩阵为 $O(n^2)$。\n    -   **诱导$\\infty$-范数** $\\|A\\|_{\\infty} = \\max_{i} \\sum_{j} |a_{ij}|$ 同样计算成本低廉，需要计算最大的绝对行和。\n    -   **诱导2-范数（或谱范数）** $\\|A\\|_{2} = \\sqrt{\\lambda_{\\max}(A^T A)}$，需要找到 $A$ 的最大奇异值。这是一个计算成本显著更高的操作，对于稠密矩阵通常需要一个成本为 $O(n^3)$ 的迭代算法。\n\n    鉴于必须计算范数来启动算法，选择一个计算上不昂贵的范数对于效率至关重要。诱导1-范数（或$\\infty$-范数）以比2-范数低得多的计算成本提供了次乘法性这一必要的理论属性。因此，诱导1-范数被选为实现缩放平方法的实用且理论上合理的选择。然后，特定的阈值 $\\theta_m$ 会专门为此范数预先计算。\n\n总而言之，使用诱导1-范数是因为它是一个**次乘法**范数，这是矩阵幂级数误差分析的理论必要条件；并且它**计算成本低廉**，这是高效算法的实际必要条件。", "answer": "$$ \\boxed{8} $$", "id": "3576136"}, {"introduction": "任何数值算法的实用性都取决于其计算效率。在掌握了缩放与求方法的参数选择后，下一个关键问题是：这个算法到底需要多少计算量？本练习将指导你推导该方法在处理稠密矩阵时的主要计算成本（浮点运算数），让你能够量化算法的性能，并理解计算量如何依赖于矩阵维度 $n$ 和缩放参数 $s$。[@problem_id:3576139]", "problem": "考虑用于矩阵指数的缩放平方法，其中矩阵指数 $\\exp(A)$ 的近似值是通过首先形成缩放后的矩阵 $A_{s} = A / 2^{s}$，然后计算有理 Padé 近似 $r_{13}(A_{s}) = p_{13}(A_{s}) \\, q_{13}(A_{s})^{-1}$，最后对结果进行 $s$ 次重复平方得到的。假设所有矩阵都是 $n \\times n$ 的稠密矩阵，并使用经典算术模型，其中核心运算的首项浮点运算次数（flops）由以下经过充分检验的事实给出：\n- 一个稠密的 $n \\times n$ 矩阵与一个 $n \\times n$ 矩阵的乘法需要 $2 n^{3}$ 次浮点运算（flops），忽略低阶项。\n- 一个稠密的 $n \\times n$ 矩阵带部分主元法的 LU 分解（LU）需要 $\\frac{2}{3} n^{3}$ 次浮点运算，忽略低阶项。\n- 求解两个以稠密 $n \\times n$ 矩阵为右端项的三角系统（在 LU 分解后对 $L$ 进行向前代入，对 $U$ 进行向后代入）总共需要 $2 n^{3}$ 次浮点运算，忽略低阶项。\n\n一种用于计算 $r_{13}$ 中的多项式 $p_{13}$ 和 $q_{13}$ 的标准因式分解方案将计算组织成一个固定的稠密矩阵乘法序列，该序列利用预先计算的幂 $A_{s}^{2}$、$A_{s}^{4}$ 和 $A_{s}^{6}$，以及结构化多项式求值，从而使得构造 $p_{13}(A_{s})$ 和 $q_{13}(A_{s})$ 恰好需要 $6$ 次稠密矩阵乘法（同样，忽略加法和标量-矩阵数乘带来的低阶项）。随后将 $q_{13}(A_{s})^{-1}$ 应用于 $p_{13}(A_{s})$ 的过程，是通过对 $q_{13}(A_{s})$ 进行 LU 分解，然后以 $p_{13}(A_{s})$ 为右端矩阵进行两次三角求解来完成的。\n\n使用这种针对 $p_{13}$ 和 $q_{13}$ 的标准因式分解方案，然后进行 $s$ 次平方，推导计算 $r_{13}(A / 2^{s})$ 的首项浮点运算次数的闭合形式（表示为 $n$ 和 $s$ 的符号表达式）。忽略所有低阶项。您的最终答案必须是关于 $n$ 和 $s$ 的单个解析表达式；不要包含单位。无需取整。", "solution": "该问题陈述是数值线性代数领域中关于计算成本分析的一个适定练习。它具有科学依据、内容自洽且客观。所有必要的数据和定义均已提供，不存在矛盾或歧义。因此，该问题是有效的，我们可以着手推导解答。\n\n目标是推导使用缩放平方法计算矩阵指数 $\\exp(A)$ 近似值的首项浮点运算（flop）次数。矩阵 $A$ 是一个稠密的 $n \\times n$ 矩阵。总成本我们记为 $C_{\\text{total}}$，是两个主要组成部分之和：\n1. 计算 Padé 近似 $r_{13}(A_s)$ 的成本，其中 $A_s = A / 2^s$。设此成本为 $C_{\\text{Pade}}$。\n2. 对结果执行 $s$ 次重复平方的成本。设此成本为 $C_{\\text{squaring}}$。\n\n因此，我们有 $C_{\\text{total}} = C_{\\text{Pade}} + C_{\\text{squaring}}$。我们将分别分析每个组成部分，只考虑关于 $n$ 的首项。\n\n首先，我们分析计算 Padé 近似的成本 $C_{\\text{Pade}}$。计算 $r_{13}(A_s) = p_{13}(A_s) q_{13}(A_s)^{-1}$ 的过程是：首先构建两个矩阵 $P = p_{13}(A_s)$ 和 $Q = q_{13}(A_s)$，然后求解矩阵方程 $Q X = P$ 以得到 $X = r_{13}(A_s)$。\n\n形成多项式矩阵 $p_{13}(A_s)$ 和 $q_{13}(A_s)$ 的成本已知为恰好 $6$ 次稠密矩阵乘法。单次稠密 $n \\times n$ 矩阵乘法的成本为 $2n^3$ flops。因此，形成这两个多项式矩阵的成本 $C_{\\text{poly}}$ 是：\n$$ C_{\\text{poly}} = 6 \\times (2n^3) = 12n^3 $$\n根据题目要求，我们忽略低阶项，例如将 $A$ 初始缩放至 $A_s = A/2^s$ 的成本（$n^2$ flops）以及矩阵加法的成本（$O(n^2)$ flops）。\n\n接下来，我们必须为矩阵 $X$ 求解线性系统 $q_{13}(A_s) X = p_{13}(A_s)$。题目指出，这是通过首先计算 $n \\times n$ 矩阵 $q_{13}(A_s)$ 的 LU 分解，然后以 $n \\times n$ 矩阵 $p_{13}(A_s)$ 作为右端项执行向前和向后代入来完成的。\n对于一个 $n \\times n$ 矩阵，带部分主元法的 LU 分解的成本为 $C_{\\text{LU}} = \\frac{2}{3}n^3$ flops。\n求解以稠密 $n \\times n$ 矩阵为右端项的两个三角系统（向前和向后代入）的成本为 $C_{\\text{solves}} = 2n^3$ flops。\n求解该系统的总成本 $C_{\\text{solve}}$ 是这两项成本之和：\n$$ C_{\\text{solve}} = C_{\\text{LU}} + C_{\\text{solves}} = \\frac{2}{3}n^3 + 2n^3 = \\left(\\frac{2}{3} + \\frac{6}{3}\\right)n^3 = \\frac{8}{3}n^3 $$\n计算 Padé 近似的总成本 $C_{\\text{Pade}}$ 是构造多项式和求解系统的成本之和：\n$$ C_{\\text{Pade}} = C_{\\text{poly}} + C_{\\text{solve}} = 12n^3 + \\frac{8}{3}n^3 = \\left(\\frac{36}{3} + \\frac{8}{3}\\right)n^3 = \\frac{44}{3}n^3 $$\n\n其次，我们分析 $s$ 次平方运算的成本 $C_{\\text{squaring}}$。在计算出 $X_0 = r_{13}(A_s)$ 后，通过计算 $X_1 = X_0^2$，$X_2 = X_1^2 = X_0^4$，依此类推，共进行 $s$ 步来获得最终的近似值：$X_k = X_{k-1}^2$。每一步都是一次平方运算，即一个稠密 $n \\times n$ 矩阵与自身相乘。一次平方运算的成本等于一次矩阵乘法的成本，即 $2n^3$ flops。由于有 $s$ 次这样的平方运算，总成本为：\n$$ C_{\\text{squaring}} = s \\times (2n^3) = 2sn^3 $$\n\n最后，总的首项浮点运算次数 $C_{\\text{total}}$ 是 $C_{\\text{Pade}}$ 和 $C_{\\text{squaring}}$ 之和：\n$$ C_{\\text{total}} = C_{\\text{Pade}} + C_{\\text{squaring}} = \\frac{44}{3}n^3 + 2sn^3 $$\n提出公因子 $n^3$，我们得到总成本的最终表达式：\n$$ C_{\\text{total}} = \\left(\\frac{44}{3} + 2s\\right)n^3 $$\n这个表达式表示了作为矩阵维度 $n$ 和缩放参数 $s$ 的函数的首项浮点运算次数。", "answer": "$$ \\boxed{\\left(\\frac{44}{3} + 2s\\right)n^{3}} $$", "id": "3576139"}, {"introduction": "理论分析为我们提供了算法的框架，但实际应用中的稳健性则需要更深入的检验。此练习将带你进入一个更高级的实践领域：通过编程实现参数选择逻辑，并构建“对抗性”矩阵来“攻击”这个算法，以检验其在极端情况下的表现。你将亲眼看到，对矩阵范数的微小扰动如何能够戏剧性地改变算法的参数选择，从而深刻体会到数值算法设计中对稳健性和敏感性分析的重要性。[@problem_id:3576145]", "problem": "设计并实现一个完整的、可运行的程序，该程序构建对抗性矩阵，以便对计算矩阵指数的伸缩平方方法中的伸缩选择进行压力测试，并量化矩阵范数估计中的微小扰动如何颠覆所选的算法参数。对抗性矩阵应基于一个大的若尔当块，众所周知，这种矩阵会引发非正规行为，对伸缩平方方法构成挑战。\n\n给定一个方阵 $A \\in \\mathbb{R}^{n \\times n}$，矩阵指数 $e^{A}$ 定义为无穷级数 $e^{A} = \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}$。一种广泛用于计算 $e^{A}$ 的算法是伸缩平方方法与 Padé 近似相结合。该方法选择整数对 $(m,s)$，其中 $m$ 是 Padé 近似 $\\text{Padé}(m,m)$ 的次数，$s$ 是伸缩指数，使得 $e^{A} = \\left(e^{A/2^{s}}\\right)^{2^{s}}$，并且 $e^{A/2^{s}}$ 由 $\\text{Padé}(m,m)$ 近似。$(m,s)$ 的选择由阈值 $\\theta_{m}$ 指导，这些阈值取决于 $m$ 和矩阵 1-范数 $\\|A\\|_{1} = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{n} |a_{ij}|$。\n\n使用以下经过充分测试的 1-范数阈值，这些阈值与 $\\text{Padé}(m,m)$ 相关，其中 $m \\in \\{3,5,7,9,13\\}$：\n- $\\theta_{3} = 0.01495585217958292$\n- $\\theta_{5} = 0.2539398330063230$\n- $\\theta_{7} = 0.9504178996162932$\n- $\\theta_{9} = 2.097847961257068$\n- $\\theta_{13} = 5.371920351148152$\n\n使用以下经过充分测试的矩阵乘法计数来评估 $\\text{Padé}(m,m)$ 近似（这些是在标准方案下的最小或接近最小的计数，并可作为一致的成本模型）：\n- $p(3) = 1$, $p(5) = 2$, $p(7) = 4$, $p(9) = 6$, $p(13) = 9$。\n\n您的程序必须实现以下针对给定 1-范数估计值 $\\widehat{\\|A\\|}_{1}$ 的 $(m,s)$ 选择规则：\n- 对于每个 $m \\in \\{3,5,7,9,13\\}$，计算 $s_{m} = \\max\\!\\left(0, \\left\\lceil \\log_{2}\\!\\left( \\frac{\\widehat{\\|A\\|}_{1}}{\\theta_{m}} \\right) \\right\\rceil \\right)$。\n- 定义成本 $C_{m} = p(m) + s_{m}$。\n- 选择使 $C_{m}$ 最小化的 $(m^{\\star}, s^{\\star})$；如果出现平局，则选择较小的 $m$。\n\n使用大小为 $n$ 的幂零若尔当块 $J_{n}$ 构建对抗性矩阵，其定义为 $(J_{n})_{i,i+1} = 1$（对于 $1 \\leq i \\leq n-1$）以及其他位置为 $0$。对于一个标量 $\\alpha  0$，设 $A = \\alpha J_{n}$。注意，对于这个 $A$，有 $\\|A\\|_{1} = \\alpha$。这个选择通过阈值 $\\theta_{m}$ 对 $(m,s)$ 的选择施加压力，因为 $J_{n}$ 是高度非正规的，并且 $\\|A\\|_{1}$ 直接等于缩放参数 $\\alpha$。\n\n为分析对范数估计的敏感性，假设估计器得出 $\\widehat{\\|A\\|}_{1} = (1+\\delta)\\|A\\|_{1}$，其中 $\\delta$ 很小。对每个测试用例的三个估计值评估 $(m,s)$：\n- 基准：$\\delta = 0$，\n- 高估：$\\delta = +\\varepsilon$，\n- 低估：$\\delta = -\\varepsilon$。\n\n将选定的对 $(m,s)$ 编码为整数 $100m + s$。\n\n实现并运行以下固定测试套件，其中 $n$ 是若尔当块的大小，$\\alpha$ 用于缩放该块，$\\varepsilon$ 是扰动水平：\n- 测试 1：$n = 20$, $\\alpha = 2^{3}\\,\\theta_{5}$, $\\varepsilon = 10^{-8}$。\n- 测试 2：$n = 20$, $\\alpha = 2^{5}\\,\\theta_{5}$, $\\varepsilon = 10^{-8}$。\n- 测试 3：$n = 30$, $\\alpha = 2^{7}\\,\\theta_{5}$, $\\varepsilon = 10^{-8}$。\n- 测试 4：$n = 20$, $\\alpha = 3.5\\,\\theta_{5}$, $\\varepsilon = 10^{-8}$。\n\n对于每个测试用例，构建 $A = \\alpha J_{n}$，计算基准、高估和低估情况下的编码选择，并按此顺序报告这三个整数。\n\n您的程序应生成单行输出，其中包含所有结果，形式为用方括号括起来的逗号分隔列表。结果必须按以下顺序排列：\n$[\\text{baseline}_{1}, \\text{over}_{1}, \\text{under}_{1}, \\text{baseline}_{2}, \\text{over}_{2}, \\text{under}_{2}, \\text{baseline}_{3}, \\text{over}_{3}, \\text{under}_{3}, \\text{baseline}_{4}, \\text{over}_{4}, \\text{under}_{4}]$。", "solution": "该问题要求设计并实现一个数值实验，以分析用于计算矩阵指数 $e^{A}$ 的伸缩平方方法中参数选择算法的敏感性。该实验专注于已知对该方法具有挑战性的对抗性矩阵，并研究矩阵范数估计中的微小扰动如何导致不同的算法选择。\n\n伸缩平方方法是计算矩阵指数 $e^{A} = \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}$ 的一个基石算法。其原理在于恒等式 $e^{A} = \\left(e^{A/2^{s}}\\right)^{2^{s}}$，其中 $s$ 是一个非负整数。选择的整数 $s$ 必须足够大，以使伸缩后矩阵的范数 $\\|A/2^{s}\\|_1$ 足够小。然后，伸缩后矩阵的指数 $e^{A/2^{s}}$ 通过有理函数进行近似，通常是 Padé 近似 $\\text{Padé}(m,m)(X)$，其中 $m$ 是近似的次数。最终结果通过将近似值重复平方 $s$ 次获得。参数 $(m,s)$ 的选择至关重要，因为它在计算成本（矩阵乘法次数）与近似精度之间取得平衡。\n\n参数选择过程由一组针对不同次数 $m$ 预先计算的反向误差阈值 $\\theta_m$ 来指导。算法旨在找到一个配对 $(m^{\\star}, s^{\\star})$，以最小化总计算成本，同时确保伸缩后矩阵的范数 $\\|A/2^{s}\\|_1$ 低于相应的阈值 $\\theta_m$。\n\n问题中规定的具体选择算法如下：\n给定矩阵 1-范数的估计值 $\\widehat{\\|A\\|}_{1}$，对于每个可用的 Padé 次数 $m \\in \\{3,5,7,9,13\\}$：\n1.  确定所需的伸缩参数 $s_m$。这是满足 $\\|A/2^{s_m}\\|_1 \\le \\theta_m$ 的最小非负整数。对 $s_m$ 进行整理可得 $2^{s_m} \\ge \\widehat{\\|A\\|}_{1} / \\theta_m$。取 $\\log_2$ 并应用天花板函数以确保整数值满足不等式，从而得出 $s_m$ 的公式：\n    $$s_{m} = \\max\\!\\left(0, \\left\\lceil \\log_{2}\\!\\left( \\frac{\\widehat{\\|A\\|}_{1}}{\\theta_{m}} \\right) \\right\\rceil \\right)$$\n    $\\max(0, \\cdot)$ 处理初始范数 $\\widehat{\\|A\\|}_{1}$ 已小于或等于 $\\theta_m$ 的情况，此时不需要伸缩（$s_m=0$）。\n\n2.  总计算成本 $C_m$ 计算为 Padé 近似求值的矩阵乘法次数 $p(m)$ 与平方次数 $s_m$ 的和：\n    $$C_{m} = p(m) + s_{m}$$\n    给定的 $p(m)$ 值为 $p(3) = 1$, $p(5) = 2$, $p(7) = 4$, $p(9) = 6$, $p(13) = 9$。\n\n3.  选择最优配对 $(m^{\\star}, s^{\\star})$，使其总成本 $C_m$ 最小。如果成本出现平局，则选择具有较小次数 $m$ 的配对。\n\n该问题使用缩放的幂零若尔当块 $A = \\alpha J_{n}$ 来构建对抗性矩阵，其中 $\\alpha  0$，$J_{n}$ 是一个大小为 $n$ 的若尔当块，其第一超对角线上为 1，其他位置为 0。此类矩阵是高度非正规的，可能放大近似误差。对于此特定任务，其关键性质是 $\\|A\\|_1 = \\|\\alpha J_n\\|_1 = \\alpha$。这提供了一种通过标量参数 $\\alpha$ 直接控制矩阵范数的方法。维度 $n$ 定义了矩阵结构，但并未直接进入参数选择逻辑，因为该算法仅依赖于矩阵的 1-范数。\n\n为了测试敏感性，对每个测试用例的三个略有不同的范数估计值运行选择算法：\n-   基准：$\\widehat{\\|A\\|}_{1} = \\|A\\|_{1} = \\alpha$\n-   高估：$\\widehat{\\|A\\|}_{1} = (1+\\varepsilon)\\|A\\|_{1} = (1+\\varepsilon)\\alpha$\n-   低估：$\\widehat{\\|A\\|}_{1} = (1-\\varepsilon)\\|A\\|_{1} = (1-\\varepsilon)\\alpha$\n其中 $\\varepsilon$ 是一个小的正值。测试用例被特意构造成 $\\alpha = 2^k \\theta_m$ 的形式，其中 $k$ 为某个整数，$m$ 为某个次数。这将范数 $\\widehat{\\|A\\|}_{1}$ 精确地置于一个决策边界上，此时 $\\log_2(\\widehat{\\|A\\|}_{1}/\\theta_m)$ 是一个整数。一个微小的扰动 $\\varepsilon$ 会将该值推过这个整数，导致天花板函数 $\\lceil \\cdot \\rceil$ 跳转到下一个整数，从而改变 $s_m$ 并可能改变最优配对 $(m^{\\star}, s^{\\star})$。\n\n让我们追踪测试用例 1：$n=20$, $\\alpha = 2^{3}\\,\\theta_{5}$, $\\varepsilon = 10^{-8}$。真实范数为 $\\|A\\|_1 = 8\\theta_5$。\n\n**A. 基准情况 ($\\delta=0$):** $\\widehat{\\|A\\|}_{1} = 8\\theta_5$。\n我们为 $m \\in \\{3,5,7,9,13\\}$ 计算 $C_m = p(m) + \\max(0, \\lceil \\log_2(8\\theta_5/\\theta_m) \\rceil)$。\n-   $m=3$: $s_3 = \\lceil \\log_2(8\\theta_5/\\theta_3) \\rceil = \\lceil \\log_2(135.8...) \\rceil = 8$。$C_3 = 1+8 = 9$。\n-   $m=5$: $s_5 = \\lceil \\log_2(8\\theta_5/\\theta_5) \\rceil = \\lceil \\log_2(8) \\rceil = 3$。$C_5 = 2+3 = 5$。\n-   $m=7$: $s_7 = \\lceil \\log_2(8\\theta_5/\\theta_7) \\rceil = \\lceil \\log_2(2.13...) \\rceil = 2$。$C_7 = 4+2 = 6$。\n-   $m=9$: $s_9 = \\max(0, \\lceil \\log_2(8\\theta_5/\\theta_9) \\rceil) = \\max(0, \\lceil \\log_2(0.96...) \\rceil) = 0$。$C_9 = 6+0 = 6$。\n-   $m=13$: $s_{13} = \\max(0, \\lceil \\log_2(8\\theta_5/\\theta_{13}) \\rceil) = \\max(0, \\lceil \\log_2(0.37...) \\rceil) = 0$。$C_{13} = 9+0 = 9$。\n成本为 $\\{9, 5, 6, 6, 9\\}$。最小成本为 $5$，对应于 $m=5$。选定的配对为 $(m^{\\star}, s^{\\star}) = (5, 3)$。编码结果为 $100 \\times 5 + 3 = 503$。\n\n**B. 高估情况 ($\\delta=+\\varepsilon$):** $\\widehat{\\|A\\|}_{1} = 8\\theta_5(1+\\varepsilon)$。\n项 $\\log_2(\\widehat{\\|A\\|}_{1}/\\theta_m)$ 变为 $\\log_2(8\\theta_5/\\theta_m) + \\log_2(1+\\varepsilon)$。对于 $m \\neq 5$，第一项不是整数，因此加上小的正值 $\\log_2(1+\\varepsilon)$ 不会改变天花板函数的结果。\n-   对于 $m=5$: $s_5 = \\lceil\\log_2(8(1+\\varepsilon))\\rceil = \\lceil3+\\log_2(1+\\varepsilon)\\rceil = 4$，因为 $\\log_2(1+\\varepsilon)$ 是一个小的正数。\n新成本为 $C_5 = 2+4 = 6$。\n成本变为 $\\{9, 6, 6, 6, 9\\}$。最小成本为 $6$，对于 $m \\in \\{5, 7, 9\\}$ 出现平局。根据平局决胜规则，我们选择最小的 $m$，所以 $m=5$。选定的配对为 $(m^{\\star}, s^{\\star}) = (5, 4)$。编码结果为 $100 \\times 5 + 4 = 504$。\n\n**C. 低估情况 ($\\delta=-\\varepsilon$):** $\\widehat{\\|A\\|}_{1} = 8\\theta_5(1-\\varepsilon)$。\n-   对于 $m=5$: $s_5 = \\lceil\\log_2(8(1-\\varepsilon))\\rceil = \\lceil3+\\log_2(1-\\varepsilon)\\rceil = 3$，因为 $\\log_2(1-\\varepsilon)$ 是一个小的负数。\n成本为 $C_5 = 2+3=5$。所有其他成本不变。\n成本为 $\\{9, 5, 6, 6, 9\\}$，与基准情况相同。最优配对为 $(m^{\\star}, s^{\\star}) = (5, 3)$。编码结果为 $503$。\n\n此分析展示了所设计的敏感性。程序将系统地将此逻辑应用于所有测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and runs a numerical experiment to test the sensitivity\n    of the parameter selection in the scaling-and-squaring method\n    for the matrix exponential.\n    \"\"\"\n\n    # Constants provided in the problem statement\n    THETAS = {\n        3: 0.01495585217958292,\n        5: 0.2539398330063230,\n        7: 0.9504178996162932,\n        9: 2.097847961257068,\n        13: 5.371920351148152,\n    }\n\n    P_COSTS = {3: 1, 5: 2, 7: 4, 9: 6, 13: 9}\n    M_VALUES = sorted(P_COSTS.keys()) # [3, 5, 7, 9, 13]\n\n    def select_params(norm_estimate):\n        \"\"\"\n        Selects the optimal (m, s) pair based on the given norm estimate,\n        according to the specified cost-minimization rule.\n        \n        Args:\n            norm_estimate (float): The estimated one-norm of the matrix.\n\n        Returns:\n            int: The encoded optimal parameters (100 * m + s).\n        \"\"\"\n        min_total_cost = float('inf')\n        best_m = -1\n        best_s = -1\n\n        # Iterate through possible Padé degrees in increasing order.\n        # This naturally handles the tie-breaking rule (choose smaller m\n        # if costs are equal) when updating the best choice.\n        for m in M_VALUES:\n            theta_m = THETAS[m]\n            p_m = P_COSTS[m]\n            \n            # Calculate the scaling exponent s_m using the formula:\n            # s_m = max(0, ceil(log2(norm_estimate / theta_m)))\n            # The norm_estimate is guaranteed to be positive in this problem's context.\n            if norm_estimate > theta_m:\n                s_m = int(np.ceil(np.log2(norm_estimate / theta_m)))\n            else:\n                s_m = 0\n            \n            # Calculate the total cost C_m = p(m) + s_m\n            total_cost = p_m + s_m\n            \n            # If the new cost is strictly lower, we have a new best choice.\n            # If cost is equal, we keep the existing best choice, which has a smaller m.\n            if total_cost  min_total_cost:\n                min_total_cost = total_cost\n                best_m = m\n                best_s = s_m\n        \n        # Encode the result as 100*m + s\n        return 100 * best_m + best_s\n\n    # Fixed test suite from the problem statement\n    # Each tuple is (n, alpha_expr, epsilon), where alpha_expr is a lambda\n    # to compute alpha, as it depends on theta_5.\n    test_cases = [\n        # n is context, not used in calculation of (m,s)\n        (20, lambda t: 2**3 * t[5], 1e-8),  # Test 1\n        (20, lambda t: 2**5 * t[5], 1e-8),  # Test 2\n        (30, lambda t: 2**7 * t[5], 1e-8),  # Test 3\n        (20, lambda t: 3.5 * t[5], 1e-8),   # Test 4\n    ]\n\n    results = []\n    for n, alpha_func, epsilon in test_cases:\n        # The norm of the adversarial matrix A = alpha * J_n is simply alpha.\n        alpha = alpha_func(THETAS)\n        true_norm = alpha\n\n        # Calculate norm estimates\n        norm_baseline = true_norm\n        norm_overestimate = true_norm * (1 + epsilon)\n        norm_underestimate = true_norm * (1 - epsilon)\n\n        # Run the selection algorithm for each estimate\n        res_baseline = select_params(norm_baseline)\n        res_over = select_params(norm_overestimate)\n        res_under = select_params(norm_underestimate)\n\n        # Append results in the required order\n        results.extend([res_baseline, res_over, res_under])\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3576145"}]}