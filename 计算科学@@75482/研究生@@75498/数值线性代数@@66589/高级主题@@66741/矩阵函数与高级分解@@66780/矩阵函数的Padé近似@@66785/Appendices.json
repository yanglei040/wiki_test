{"hands_on_practices": [{"introduction": "理论学习的基石在于亲手实践。这项练习将带你从最基本的定义出发，通过匹配级数系数来手动构建指数函数 $e^z$ 的 $[2/2]$ Padé 近似。这个过程不仅能加深你对 Padé 近似核心定义（即 $q(z)f(z) - p(z)$ 的高阶接触）的理解，还将揭示为何有理函数能够比多项式更有效地逼近某些函数。通过完成这项基础构建工作，你将为理解更复杂的矩阵函数近似奠定坚实的基础。[@problem_id:3564074]", "problem": "设标量指数函数为 $f(z) = \\exp(z)$，其定义为其泰勒级数 $f(z) = \\sum_{k=0}^{\\infty} \\frac{z^{k}}{k!}$，对于一个方阵 $A$，$\\exp(A)$ 由相同的级数定义，只是将 $z$ 替换为 $A$。函数 $f(z)$ 的 $[m/n]$ Padé 近似是有理函数 $r_{mn}(z) = \\frac{p_{m}(z)}{q_{n}(z)}$，其中 $\\deg p_{m} \\leq m$，$\\deg q_{n} \\leq n$，且 $q_{n}(0) = 1$，使得 $q_{n}(z) f(z) - p_{m}(z)$ 的麦克劳林级数在 $z^{m+n}$ 阶（包括此阶）之前的所有项都为零。\n\n仅从这些定义出发，通过级数匹配确定 $p_{2}(z)$ 和 $q_{2}(z)$ 的系数，从而显式地构造出 $f(z) = \\exp(z)$ 的 $[2/2]$ Padé 近似 $r_{22}(z)$。然后，通过找出 $q_{2}(z)\\exp(z) - p_{2}(z)$ 展开式中的第一个非零项，验证当 $z \\to 0$ 时，截断误差满足 $\\exp(z) - r_{22}(z) = O(z^{5})$。最后，解释为什么在任何相容的次乘矩阵范数下，对于范数足够小的矩阵 $A$，只要 $q_{2}(A)$ 可逆，相同的有理函数 $r_{22}(A)$ 就可以作为 $\\exp(A)$ 的一个 $O(\\|A\\|^{5})$ 近似。\n\n以封闭形式提供显式的有理函数 $r_{22}(z)$ 作为最终答案。不需要进行数值舍入。[@problem_id:48]", "solution": "经验证，该问题陈述具有科学依据，表述清晰且客观。它基于数值分析和逼近理论中的标准定义，提出了一个具有唯一解的可形式化任务。\n\n该问题要求构造并验证 $f(z) = \\exp(z)$ 的 $[2/2]$ Padé 近似，并解释其在矩阵指数上的应用。\n\n设 $[2/2]$ Padé 近似表示为 $r_{22}(z) = \\frac{p_{2}(z)}{q_{2}(z)}$。\n根据问题定义，多项式的阶数为 $\\deg p_{2} \\leq 2$ 和 $\\deg q_{2} \\leq 2$。设其形式为：\n$p_{2}(z) = a_0 + a_1 z + a_2 z^2$\n$q_{2}(z) = b_0 + b_1 z + b_2 z^2$\n\n归一化条件是 $q_{2}(0) = 1$，这意味着 $b_0 = 1$。因此，分母为 $q_{2}(z) = 1 + b_1 z + b_2 z^2$。\n\nPadé 近似的核心定义属性是误差函数 $q_{n}(z)f(z) - p_{m}(z)$ 的级数展开式的前几项为零。对于 $[2/2]$ 的情况（$m=2, n=2$），我们需要：\n$q_{2}(z) \\exp(z) - p_{2}(z) = C z^{m+n+1} + \\dots = O(z^{5})$\n这意味着 $q_{2}(z) \\exp(z) - p_{2}(z)$ 的麦克劳林级数中 $z^0, z^1, z^2, z^3, z^4$ 各项的系数必须都为零。\n\n首先，我们写出 $\\exp(z)$ 的麦克劳林级数：\n$\\exp(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} + \\dots = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} + O(z^5)$\n\n接下来，我们展开乘积 $q_{2}(z) \\exp(z)$：\n$q_{2}(z) \\exp(z) = (1 + b_1 z + b_2 z^2) \\left( 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} + O(z^5) \\right)$\n\n我们收集此乘积中 $z$ 的各次幂的系数，直到 $z^4$ 阶：\n$z^0$ 的系数：$1$\n$z^1$ 的系数：$1 + b_1$\n$z^2$ 的系数：$\\frac{1}{2} + b_1 + b_2$\n$z^3$ 的系数：$\\frac{1}{6} + \\frac{b_1}{2} + b_2$\n$z^4$ 的系数：$\\frac{1}{24} + \\frac{b_1}{6} + \\frac{b_2}{2}$\n\n现在我们施加条件 $q_{2}(z)\\exp(z) - p_{2}(z) = O(z^5)$。这意味着 $p_2(z)$ 必须是 $q_2(z)\\exp(z)$ 级数中最高到 2 阶的多项式部分，并且随后的 $z^3$ 和 $z^4$ 的系数必须为零。\n\n匹配 $p_2(z) = a_0 + a_1 z + a_2 z^2$ 的系数：\n- $z^0$ 的系数：$a_0 = 1$\n- $z^1$ 的系数：$a_1 = 1 + b_1$\n- $z^2$ 的系数：$a_2 = \\frac{1}{2} + b_1 + b_2$\n\n将接下来的两个系数设为零以确定 $b_1$ 和 $b_2$：\n- $z^3$ 的系数：$\\frac{1}{6} + \\frac{b_1}{2} + b_2 = 0$\n- $z^4$ 的系数：$\\frac{1}{24} + \\frac{b_1}{6} + \\frac{b_2}{2} = 0$\n\n这是一个关于 $b_1$ 和 $b_2$ 的二元线性方程组：\n1. $\\frac{1}{2} b_1 + b_2 = -\\frac{1}{6}$\n2. $\\frac{1}{6} b_1 + \\frac{1}{2} b_2 = -\\frac{1}{24}$\n\n将第二个方程乘以 $2$：$\\frac{1}{3} b_1 + b_2 = -\\frac{1}{12}$。\n从第一个方程中减去这个新方程：\n$(\\frac{1}{2} b_1 - \\frac{1}{3} b_1) + (b_2 - b_2) = -\\frac{1}{6} - (-\\frac{1}{12})$\n$\\frac{3-2}{6} b_1 = -\\frac{2}{12} + \\frac{1}{12}$\n$\\frac{1}{6} b_1 = -\\frac{1}{12} \\implies b_1 = -\\frac{6}{12} = -\\frac{1}{2}$\n\n将 $b_1 = -1/2$ 代入第一个方程：\n$\\frac{1}{2} \\left(-\\frac{1}{2}\\right) + b_2 = -\\frac{1}{6}$\n$-\\frac{1}{4} + b_2 = -\\frac{1}{6} \\implies b_2 = \\frac{1}{4} - \\frac{1}{6} = \\frac{3-2}{12} = \\frac{1}{12}$\n\n现在我们得到了 $q_2(z)$ 的系数：$b_1 = -1/2$ 和 $b_2 = 1/12$。\n$q_{2}(z) = 1 - \\frac{1}{2}z + \\frac{1}{12}z^2$\n\n我们可以求出 $p_2(z)$ 的系数：\n$a_0 = 1$\n$a_1 = 1 + b_1 = 1 - \\frac{1}{2} = \\frac{1}{2}$\n$a_2 = \\frac{1}{2} + b_1 + b_2 = \\frac{1}{2} - \\frac{1}{2} + \\frac{1}{12} = \\frac{1}{12}$\n\n因此，分子多项式为：\n$p_{2}(z) = 1 + \\frac{1}{2}z + \\frac{1}{12}z^2$\n\n因此，$\\exp(z)$ 的 $[2/2]$ Padé 近似 $r_{22}(z)$ 为：\n$r_{22}(z) = \\frac{1 + \\frac{1}{2}z + \\frac{1}{12}z^2}{1 - \\frac{1}{2}z + \\frac{1}{12}z^2}$\n\n为了验证截断误差，我们找出 $q_{2}(z)\\exp(z) - p_{2}(z)$ 展开式中的第一个非零项。根据构造，直到 $z^4$ 的项都为零。我们计算乘积 $q_{2}(z)\\exp(z)$ 中 $z^5$ 的系数：\n$z^5$ 的系数：（$q_2$ 中 $z^0$ 的系数）$\\cdot$（$\\exp$ 中 $z^5$ 的系数）+（$q_2$ 中 $z^1$ 的系数）$\\cdot$（$\\exp$ 中 $z^4$ 的系数）+（$q_2$ 中 $z^2$ 的系数）$\\cdot$（$\\exp$ 中 $z^3$ 的系数）\n$= 1 \\cdot \\frac{1}{5!} + b_1 \\cdot \\frac{1}{4!} + b_2 \\cdot \\frac{1}{3!}$\n$= 1 \\cdot \\frac{1}{120} + \\left(-\\frac{1}{2}\\right) \\cdot \\frac{1}{24} + \\left(\\frac{1}{12}\\right) \\cdot \\frac{1}{6}$\n$= \\frac{1}{120} - \\frac{1}{48} + \\frac{1}{72}$\n$120$、$48$ 和 $72$ 的最小公倍数是 $720$。\n$= \\frac{6}{720} - \\frac{15}{720} + \\frac{10}{720} = \\frac{6 - 15 + 10}{720} = \\frac{1}{720}$\n\n所以，$q_{2}(z)\\exp(z) - p_{2}(z) = \\frac{1}{720}z^5 + O(z^6)$。\nPadé 近似本身的误差是 $\\exp(z) - r_{22}(z) = \\frac{q_2(z)\\exp(z) - p_2(z)}{q_2(z)}$。\n由于当 $z \\to 0$ 时，$q_2(z) \\to 1$，误差为：\n$\\exp(z) - r_{22}(z) = \\frac{\\frac{1}{720}z^5 + O(z^6)}{1 + O(z)} = \\frac{1}{720}z^5 + O(z^6)$。\n这证实了误差确实是 $O(z^5)$。\n\n最后，我们解释为什么对于范数足够小的方阵 $A$，$r_{22}(A)$ 是 $\\exp(A)$ 的一个 $O(\\|A\\|^5)$ 近似。\n$\\exp(A)$ 以及多项式 $p_2(A)$ 和 $q_2(A)$ 的定义是通过在各自的级数和多项式表达式中用矩阵 $A$ 替换标量 $z$ 得到的。标量恒等式 $q_2(z)\\exp(z) - p_2(z) = \\frac{1}{720}z^5 + O(z^6)$ 是一个收敛幂级数之间的恒等式。当 $z$ 被替换为矩阵 $A$ 时，这个恒等式同样成立：\n$q_2(A)\\exp(A) - p_2(A) = \\frac{1}{720}A^5 + \\sum_{k=6}^{\\infty} c_k A^k$，其中如果 $\\|A\\|$ 在收敛半径内，该级数收敛。\n由于 $p_2(A)$、$q_2(A)$ 和 $\\exp(A)$ 都是 $A$ 的幂级数，它们相互之间是可交换的。因此，$\\exp(A)q_2(A) = q_2(A)\\exp(A)$。\n如果 $q_2(A) = I - \\frac{1}{2}A + \\frac{1}{12}A^2$ 是可逆的，我们可以定义 $r_{22}(A) = p_2(A)[q_2(A)]^{-1}$。\n误差为 $\\exp(A) - r_{22}(A)$。我们可以写成：\n$\\exp(A) - r_{22}(A) = [\\exp(A)q_2(A) - p_2(A)][q_2(A)]^{-1} = [q_2(A)\\exp(A) - p_2(A)][q_2(A)]^{-1}$\n代入误差项的级数展开：\n$\\exp(A) - r_{22}(A) = \\left( \\frac{1}{720}A^5 + \\sum_{k=6}^{\\infty} c_k A^k \\right) [q_2(A)]^{-1}$\n现在我们取一个相容的次乘矩阵范数 $\\| \\cdot \\|$：\n$\\|\\exp(A) - r_{22}(A)\\| \\leq \\left\\| \\frac{1}{720}A^5 + \\sum_{k=6}^{\\infty} c_k A^k \\right\\| \\cdot \\left\\| [q_2(A)]^{-1} \\right\\|$\n对于第一项，当 $\\|A\\| \\to 0$ 时：\n$\\left\\| \\frac{1}{720}A^5 + \\dots \\right\\| \\leq \\frac{1}{720}\\|A\\|^5 + \\sum_{k=6}^{\\infty} |c_k| \\|A\\|^k = O(\\|A\\|^5)$\n对于逆项，$q_2(A) = I - (\\frac{1}{2}A - \\frac{1}{12}A^2)$。如果 $\\|\\frac{1}{2}A - \\frac{1}{12}A^2\\|  1$（这对于足够小的 $\\|A\\|$ 是成立的），那么 $q_2(A)$ 是可逆的，并且它的逆可以用收敛的 Neumann 级数表示。当 $\\|A\\| \\to 0$ 时，$q_2(A) \\to I$，所以 $\\|[q_2(A)]^{-1}\\| \\to \\|I\\| = 1$。这意味着对于小的 $\\|A\\|$，$\\|[q_2(A)]^{-1}\\|$ 是有界的。\n结合这些结果，我们得到：\n$\\|\\exp(A) - r_{22}(A)\\| \\leq O(\\|A\\|^5) \\cdot (\\text{一个有界量})$\n因此，$\\|\\exp(A) - r_{22}(A)\\| = O(\\|A\\|^5)$。", "answer": "$$\n\\boxed{\\frac{1 + \\frac{1}{2}z + \\frac{1}{12}z^2}{1 - \\frac{1}{2}z + \\frac{1}{12}z^2}}\n$$", "id": "3564074"}, {"introduction": "将标量函数推广到矩阵函数时，一个关键的挑战是如何处理不可对角化的（或称“亏损”）矩阵。这项练习通过一个具体的 $3 \\times 3$ Jordan 块，清晰地展示了如何计算有理函数作用于这类矩阵上的结果。你将发现，矩阵函数的值不仅取决于标量函数在特征值处的取值，还取决于其导数值，这揭示了矩阵结构与函数局部行为之间的深刻联系。这个例子是理解和分析更一般矩阵函数算法行为的关键。[@problem_id:3564125]", "problem": "设 $A \\in \\mathbb{C}^{3 \\times 3}$ 是一个亏损矩阵，其特征值 $\\lambda = 0$ 对应一个大小为 $3$ 的若尔当块，具体为 $A = J_{3}(0)$，其中\n$$\nA = \\begin{pmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\n考虑函数 $\\log(1+z)$ 在 $z=0$ 处的有理帕德近似式 $r$，定义为\n$$\nr(z) = \\frac{2z}{2+z}.\n$$\n使用通过围绕特征值的解析延拓和若尔当标准型结构来定义的矩阵函数，计算 $r(A)$，并明确量化导数 $r^{(k)}(\\lambda)$ 如何对这个 $3 \\times 3$ 若尔当块的 $r(A)$ 的元素做出贡献。将你的最终答案表示为单一的闭式矩阵表达式。无需四舍五入。", "solution": "该问题是有效的，因为它在科学上基于矩阵函数理论，信息完备、问题明确，并且陈述客观。我们可以进行形式化的解答。\n\n该问题要求计算 $r(A)$，其中 $A$ 是一个特征值为 $\\lambda=0$ 的 $3 \\times 3$ 若尔当块，而 $r(z)$ 是一个给定的有理函数。若尔当块 $J_k(\\lambda) \\in \\mathbb{C}^{k \\times k}$ 的函数 $f$ 的定义由一个特定的上三角托普利茨矩阵结构给出。对于一个大小为 $k=3$、对应于特征值 $\\lambda$ 的若尔当块，该定义为：\n$$\nf(J_3(\\lambda)) =\n\\begin{pmatrix}\nf(\\lambda)  \\frac{f^{(1)}(\\lambda)}{1!}  \\frac{f^{(2)}(\\lambda)}{2!} \\\\\n0  f(\\lambda)  \\frac{f^{(1)}(\\lambda)}{1!} \\\\\n0  0  f(\\lambda)\n\\end{pmatrix}\n$$\n该矩阵的元素 $(f(J_3(\\lambda)))_{i,j}$ 由函数 $f$ 在特征值 $\\lambda$ 处的导数确定。具体来说，对于 $j \\ge i$，元素由 $\\frac{f^{(j-i)}(\\lambda)}{(j-i)!}$ 给出。\n\n在本问题中，矩阵为 $A = J_3(0)$，这意味着块大小为 $k=3$，特征值为 $\\lambda=0$。函数是有理帕德近似式 $r(z) = \\frac{2z}{2+z}$。因此，为了计算 $r(A)$，我们必须计算 $r(z)$ 及其前两阶导数在 $z=\\lambda=0$ 处的值。\n\n矩阵 $r(A)$ 的形式为：\n$$\nr(A) = r(J_3(0)) =\n\\begin{pmatrix}\nr(0)  r'(0)  \\frac{r''(0)}{2!} \\\\\n0  r(0)  r'(0) \\\\\n0  0  r(0)\n\\end{pmatrix}\n$$\n这个结构明确量化了导数 $r^{(k)}(\\lambda)$ 如何对 $r(A)$ 的元素做出贡献。对角线元素由 $r(0)$ 决定，第一条上对角线由 $r'(0)$ 决定，第二条上对角线由 $\\frac{r''(0)}{2}$ 决定。\n\n我们现在计算 $r(z)$ 所需的导数。首先使用多项式长除法或代数变换来重写 $r(z)$ 会很方便：\n$$\nr(z) = \\frac{2z}{2+z} = \\frac{2(z+2) - 4}{z+2} = 2 - \\frac{4}{2+z} = 2 - 4(2+z)^{-1}\n$$\n这种形式简化了求导过程。\n\n首先，我们计算函数本身在 $z=0$ 处的值：\n$$\nr(0) = 2 - 4(2+0)^{-1} = 2 - \\frac{4}{2} = 2 - 2 = 0\n$$\n\n接下来，我们计算一阶导数 $r'(z)$：\n$$\nr'(z) = \\frac{d}{dz} \\left( 2 - 4(2+z)^{-1} \\right) = -4(-1)(2+z)^{-2} = 4(2+z)^{-2} = \\frac{4}{(2+z)^2}\n$$\n在 $z=0$ 处求值：\n$$\nr'(0) = \\frac{4}{(2+0)^2} = \\frac{4}{4} = 1\n$$\n\n然后，我们计算二阶导数 $r''(z)$：\n$$\nr''(z) = \\frac{d}{dz} \\left( 4(2+z)^{-2} \\right) = 4(-2)(2+z)^{-3} = -8(2+z)^{-3} = \\frac{-8}{(2+z)^3}\n$$\n在 $z=0$ 处求值：\n$$\nr''(0) = \\frac{-8}{(2+0)^3} = \\frac{-8}{8} = -1\n$$\n\n现在我们拥有了构建矩阵 $r(A)$ 所需的所有分量。所需的值为：\n- $r(0) = 0$\n- $r'(0) = 1$\n- $r''(0) = -1$\n- $2! = 2$\n\n将这些值代入 $r(J_3(0))$ 的矩阵结构中：\n$$\nr(A) =\n\\begin{pmatrix}\n0  1  \\frac{-1}{2} \\\\\n0  0  1 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n\n这就是 $r(A)$ 的最终闭式矩阵表达式。作为一种替代性检验方法，由于 $A$ 是幂零矩阵且 $A^3=0$，我们可以使用 $r(z)$ 在 $z=0$ 附近的泰勒级数展开：\n$r(A) = r(0)I + r'(0)A + \\frac{r''(0)}{2!}A^2$。\n已知 $A = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}$ 且 $A^2 = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$，我们得到：\n$r(A) = 0 \\cdot I + 1 \\cdot A + \\frac{-1}{2} \\cdot A^2 = A - \\frac{1}{2}A^2$。\n$$\nr(A) = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  1  -\\frac{1}{2} \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}\n$$\n这验证了我们的结果。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  1  -\\frac{1}{2} \\\\\n0  0  1 \\\\\n0  0  0\n\\end{pmatrix}\n}\n$$", "id": "3564125"}, {"introduction": "在现代科学计算中，我们通常关心的是矩阵函数与向量的乘积 $f(A)b$，而非计算完整的矩阵函数 $f(A)$。这项练习将理论付诸实践，指导你使用部分分式分解法来实现 Padé 近似在向量上的高效作用。这种方法将复杂的有理函数求值问题转化为一系列线性系统求解问题，这在处理大型稀疏矩阵时尤为重要。通过分析一个简化的性能模型，你还将体会到并行计算（如 GPU）相对于串行计算（CPU）在解决这类问题时的理论优势，从而将抽象的数学工具与高性能计算的实际考量联系起来。[@problem_id:3564069]", "problem": "要求您设计并实现一种数值方法，使用 Padé 近似来逼近矩阵函数在向量上的作用，并为一个当移位保持稀疏模式时批量求解移位线性系统的情况量化一个理论性能模型。重点是作为代表性解析函数的矩阵指数，以及一个比较中央处理器 (CPU) 序贯策略与图形处理器 (GPU) 批量策略的成本模型。\n\n您的设计必须基于以下数值线性代数中经过充分检验的定义和事实：\n- 对于一个方阵 $A \\in \\mathbb{C}^{n \\times n}$ 和一个解析函数 $f$，矩阵函数 $f(A)$ 在适用时通过收敛幂级数定义：$$f(A) = \\sum_{k=0}^{\\infty} c_k A^k$$，其中 $f(z) = \\sum_{k=0}^{\\infty} c_k z^k$ 是 $f$ 在 $0$ 点的泰勒级数。\n- 函数 $f(z)$ 的 $(m,m)$ 阶 Padé 近似 $r_{m,m}(z) = \\frac{p_m(z)}{q_m(z)}$ 是唯一的有理函数，其麦克劳林级数与 $f$ 的麦克劳林级数匹配到 $2m$ 阶，即 $f(z) - r_{m,m}(z) = \\mathcal{O}(z^{2m+1})$。\n- 任何分母具有单根的有理函数都允许部分分式展开：$$\\frac{p(z)}{q(z)} = c_0 + \\sum_{j=1}^{K} \\frac{\\alpha_j}{z - \\zeta_j}$$，其中 $\\zeta_j$ 是 $q$ 的根 (极点)，$\\alpha_j$ 是留数，如果该有理函数是非真的，则 $c_0$ 是一个常数。对于单极点，留数满足 $\\alpha_j = \\frac{p(\\zeta_j)}{q'(\\zeta_j)}$。\n- 对于矩阵，$r(A)$ 在向量 $\\mathbf{b}$ 上的作用可以使用预解式实现：$$r(A)\\mathbf{b} = c_0 \\mathbf{b} + \\sum_{j=1}^{K} \\alpha_j (A - \\zeta_j I)^{-1} \\mathbf{b}$$，前提是没有任何极点与 $A$ 的谱重合。\n- 对于矩阵指数，$e^{z}$ 的对角 Padé 近似 $r_{m,m}$ 可以从麦克劳林级数系数 $c_k = \\frac{1}{k!}$ (对于 $k = 0,1,\\dots,2m$) 构建。\n\n您的任务是：\n1) 通过匹配麦克劳林级数系数 $c_k = \\frac{1}{k!}$ (对于 $k = 0,1,\\dots,2m$) 来构建 $e^{z}$ 的对角 Padé 近似 $r_{m,m}(z)$。然后，使用非真有理函数的留数和常数的基本定义，推导出一个稳定的部分分式形式 $r_{m,m}(z) = c_0 + \\sum_{j=1}^{K} \\frac{\\alpha_j}{z - \\zeta_j}$。您的实现必须从多项式 $p_m$ 和 $q_m$ 计算 $c_0$、极点 $\\{\\zeta_j\\}_{j=1}^{K}$ 和留数 $\\{\\alpha_j\\}_{j=1}^{K}$，而不能硬编码任何预先制表的 Padé 系数。\n2) 实现一个函数，对于给定的稀疏矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和向量 $\\mathbf{b} \\in \\mathbb{R}^{n}$，通过求解移位稀疏线性系统 $(A - \\zeta_j I)\\mathbf{x}_j = \\mathbf{b}$ (对于 $j = 1,\\dots,K$) 并将它们组合为 $\\mathbf{y} = c_0 \\mathbf{b} + \\sum_{j=1}^{K} \\alpha_j \\mathbf{x}_j$，使用部分分式表示来计算 $r_{m,m}(A)\\mathbf{b}$。您必须正确处理复数算术，并返回结果的实部（对于实数 $A$ 和 $\\mathbf{b}$，虚部应抵消至数值舍入误差）。\n3) 为了验证，使用标准算法计算一个高精度参考值 $\\mathbf{y}_{\\mathrm{ref}} \\approx e^{A} \\mathbf{b}$，并报告相对误差 $\\|\\mathbf{y} - \\mathbf{y}_{\\mathrm{ref}}\\|_2 / \\|\\mathbf{y}_{\\mathrm{ref}}\\|_2$。\n4) 开发一个理论性能模型，量化在图形处理器 (GPU) 上批量求解 $K$ 个移位系统相对于在中央处理器 (CPU) 上序贯求解的预测加速比，假设所有移位 $\\zeta_j$ 都保持 $A - \\zeta_j I$ 的稀疏模式。使用以下简单的、量纲一致的成本模型，其中 $\\text{nnz}$ 表示 $A$ 的非零元数量，$\\displaystyle n$ 是维度，$\\displaystyle K$ 是极点数：\n- CPU (每次移位序贯执行): $$T_{\\mathrm{CPU}} = K \\big( a_c \\,\\text{nnz} + b_c \\,\\text{nnz}\\, \\sqrt{n} + c_c \\,\\text{nnz} \\big)$$\n- GPU (跨所有移位批量执行，具有共享分析和简化的每次移位常数): $$T_{\\mathrm{GPU}} = a_g \\,\\text{nnz} + K \\big( \\rho\\, b_g \\,\\text{nnz}\\, \\sqrt{n} + \\sigma\\, c_g \\,\\text{nnz} \\big)$$\n使用固定的常数\n$a_c = 8 \\times 10^{-9}$, $b_c = 5 \\times 10^{-8}$, $c_c = 2 \\times 10^{-9}$, $a_g = 1 \\times 10^{-9}$, $b_g = 8 \\times 10^{-9}$, $c_g = 5 \\times 10^{-10}$, $\\rho = 0.5$, 和 $\\sigma = 0.3$,\n时间以秒为单位，$\\text{nnz}$ 无单位。\n5) 将您的方法应用于以下测试套件。在每种情况下，将 $A$ 构建为带狄利克雷边界条件的缩放一维离散拉普拉斯算子，即 $L_n = \\operatorname{tridiag}(-1,2,-1) \\in \\mathbb{R}^{n \\times n}$ 且 $A = -\\alpha L_n$。使用指定的随机种子，用独立的标准正态分布元素构成 $\\mathbf{b}$。对于每个用例，计算：\n- 相对误差 $\\|\\mathbf{y} - \\mathbf{y}_{\\mathrm{ref}}\\|_2 / \\|\\mathbf{y}_{\\mathrm{ref}}\\|_2$。\n- 预测的加速比 $S = T_{\\mathrm{CPU}} / T_{\\mathrm{GPU}}$。\n测试套件参数元组 $(n,\\alpha,m,\\text{seed})$ 为：\n- 用例 $1$: $(40,\\, 0.10,\\, 6,\\, 12345)$。\n- 用例 $2$: $(1,\\, 0.00,\\, 4,\\, 2024)$。\n- 用例 $3$: $(60,\\, 0.08,\\, 8,\\, 31415)$。\n\n角度单位不适用。答案中没有物理单位。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格浮点数列表形式的结果，顺序为\n$[\\text{err}_1, \\text{speedup}_1, \\text{err}_2, \\text{speedup}_2, \\text{err}_3, \\text{speedup}_3]$，\n其中 $\\text{err}_i$ 是用例 $i$ 的相对误差，$\\text{speedup}_i$ 是用例 $i$ 的预测加速比。在打印前将每个浮点数四舍五入到恰好 $8$ 位小数。代码必须是完全自包含的，并且不得读取任何输入。", "solution": "用户提供的问题是一个有效的数值分析任务，它是自包含的、有科学依据且适定的。它要求设计并实现一种使用 Padé 近似来逼近矩阵指数在向量上的作用 $y = e^A b$ 的方法。该方法的核心在于有理近似的部分分式展开，这将问题转化为求解一组移位线性系统。问题还指定了推导一个理论性能模型，用于比较序贯执行策略和批量执行策略。我将进行完整的解答。\n\n解决方案根据问题陈述中定义的任务系统地组织。\n\n### 步骤 1：$e^z$ 的 Padé 近似\n\n如果一个有理函数 $r_{m,m}(z) = p_m(z)/q_m(z)$（其中 $p_m$ 和 $q_m$ 是次数至多为 $m$ 的多项式）的麦克劳林级数展开与解析函数 $f(z)$ 的展开在尽可能高的阶数上一致，那么它就是 $f(z)$ 的 $(m,m)$-Padé 近似。对于 $f(z) = e^z = \\sum_{k=0}^{\\infty} \\frac{z^k}{k!}$，这个条件是 $q_m(z)e^z - p_m(z) = \\mathcal{O}(z^{2m+1})$。\n\n通过求解匹配 $z$ 的幂（最高到 $z^{2m}$）的系数所产生的线性方程组，可以推导出分子 $p_m(z) = \\sum_{k=0}^{m} a_k z^k$ 和分母 $q_m(z) = \\sum_{k=0}^{m} b_k z^k$ 的系数。这些多项式在相差一个缩放因子的情况下是唯一的，并由以下公式给出：\n$$\np_m(z) = \\sum_{k=0}^{m} \\frac{(2m-k)! m!}{(2m)! k! (m-k)!} z^k\n$$\n$$\nq_m(z) = \\sum_{k=0}^{m} \\frac{(2m-k)! m!}{(2m)! k! (m-k)!} (-z)^k\n$$\n值得注意的是，分母与分子的关系是 $q_m(z) = p_m(-z)$。\n\n### 步骤 2：部分分式分解\n\nPadé 近似 $r_{m,m}(z)$ 是一个非真有理函数，因为 $\\deg(p_m) = \\deg(q_m) = m$。它可以用部分分式展开来表示。首先，多项式长除法产生一个常数项 $c_0$ 和一个真有理函数：\n$$\nr_{m,m}(z) = \\frac{p_m(z)}{q_m(z)} = c_0 + \\frac{s_m(z)}{q_m(z)}\n$$\n其中 $s_m(z) = p_m(z) - c_0 q_m(z)$ 是余式多项式，且 $\\deg(s_m)  m$。常数 $c_0$ 是 $p_m(z)$ 和 $q_m(z)$ 首项系数的比值，可以求得为 $c_0 = (-1)^m$。\n\n$r_{m,m}(z)$ 的极点，记作 $\\{\\zeta_j\\}_{j=1}^{m}$，是分母多项式 $q_m(z)$ 的根。对于 $e^z$ 的 Padé 近似，一个已知的性质是这些极点都是单极点，并且位于复平面的右半部分。部分分式展开则为：\n$$\nr_{m,m}(z) = c_0 + \\sum_{j=1}^{m} \\frac{\\alpha_j}{z - \\zeta_j}\n$$\n对应于单极点的留数 $\\{\\alpha_j\\}_{j=1}^{m}$ 使用以下公式计算：\n$$\n\\alpha_j = \\frac{s_m(\\zeta_j)}{q'_m(\\zeta_j)} = \\frac{p_m(\\zeta_j) - c_0 q_m(\\zeta_j)}{q'_m(\\zeta_j)}\n$$\n由于根据极点的定义有 $q_m(\\zeta_j) = 0$，这可以简化为 $\\alpha_j = p_m(\\zeta_j) / q'_m(\\zeta_j)$，其中 $q'_m(z)$ 是 $q_m(z)$ 关于 $z$ 的导数。\n\n### 步骤 3：逼近 $e^A \\mathbf{b}$ 的算法\n\n将标量变量 $z$ 替换为矩阵 $A \\in \\mathbb{R}^{n \\times n}$，有理近似在向量 $\\mathbf{b} \\in \\mathbb{R}^n$ 上的作用由下式给出：\n$$\n\\mathbf{y} = r_{m,m}(A)\\mathbf{b} = \\left(c_0 I + \\sum_{j=1}^{m} \\alpha_j (A - \\zeta_j I)^{-1}\\right) \\mathbf{b} = c_0 \\mathbf{b} + \\sum_{j=1}^{m} \\alpha_j (A - \\zeta_j I)^{-1} \\mathbf{b}\n$$\n这个表达式建议了一种算法，其中我们避免显式地构造矩阵的逆。相反，我们求解一系列移位线性系统。设 $\\mathbf{x}_j = (A - \\zeta_j I)^{-1} \\mathbf{b}$。这等价于求解 $\\mathbf{x}_j$：\n$$\n(A - \\zeta_j I) \\mathbf{x}_j = \\mathbf{b}, \\quad \\text{for } j=1, \\dots, m\n$$\n最终的近似值 $\\mathbf{y}$ 就是这些解的线性组合：\n$$\n\\mathbf{y} = c_0 \\mathbf{b} + \\sum_{j=1}^{m} \\alpha_j \\mathbf{x}_j\n$$\n矩阵 $A$ 是实数矩阵，但极点 $\\zeta_j$ 和留数 $\\alpha_j$ 是复数，并且成共轭对出现。因此，中间向量 $\\mathbf{x}_j$ 和最终的和 $\\mathbf{y}$ 是复数。然而，对于实数矩阵 $A$ 和实数向量 $\\mathbf{b}$，最终结果的虚部会在机器精度范围内抵消，所以我们取 $\\mathbf{y}$ 的实部作为最终答案。\n\n数值实现过程如下：\n1.  对于给定的阶数 $m$，计算 $p_m(z)$ 和 $q_m(z)$ 的系数。\n2.  计算常数 $c_0$、极点 $\\{\\zeta_j\\}$ 和留数 $\\{\\alpha_j\\}$。\n3.  初始化一个复向量 $y_{approx} = c_0 \\mathbf{b}$。\n4.  对于每对极点-留数 $(\\zeta_j, \\alpha_j)$：\n    a. 构建稀疏、复数、移位的矩阵 $M_j = A - \\zeta_j I$。\n    b. 使用稀疏直接求解器求解线性系统 $M_j \\mathbf{x}_j = \\mathbf{b}$ 得到 $\\mathbf{x}_j$。\n    c. 累加结果：$y_{approx} \\leftarrow y_{approx} + \\alpha_j \\mathbf{x}_j$。\n5.  返回 $\\text{Re}(y_{approx})$。\n\n### 步骤 4：验证和误差计算\n\n为了验证 Padé 近似的准确性，将结果 $\\mathbf{y}$ 与高精度参考解 $\\mathbf{y}_{\\mathrm{ref}} \\approx e^A \\mathbf{b}$ 进行比较。这个参考解是使用一种先进的算法计算的，具体是 `scipy.sparse.linalg.expm_multiply` 中实现的算法，该算法基于克雷洛夫子空间方法。相对误差使用欧几里得范数 ($L_2$-范数) 进行量化：\n$$\n\\text{err} = \\frac{\\|\\mathbf{y} - \\mathbf{y}_{\\mathrm{ref}}\\|_2}{\\|\\mathbf{y}_{\\mathrm{ref}}\\|_2}\n$$\n\n### 步骤 5：性能模型和加速比\n\n定义了一个理论性能模型，用于估计在 CPU 上顺序求解 $m$ 个线性系统与在 GPU 上批量求解的计算时间。需要求解的系统数量为 $K=m$。矩阵 $A$ 是一个 $n \\times n$ 大小的缩放离散拉普拉斯算子，它是三对角的，所以其非零元素的数量对于 $n > 1$ 是 $\\text{nnz} = 3n-2$，对于 $n=1$ 是 $\\text{nnz}=1$。\n\n模型方程提供如下：\n-   CPU 时间: $T_{\\mathrm{CPU}} = K \\cdot \\text{nnz} \\cdot (a_c + b_c \\sqrt{n} + c_c)$\n-   GPU 时间: $T_{\\mathrm{GPU}} = \\text{nnz} \\cdot (a_g + K (\\rho b_g \\sqrt{n} + \\sigma c_g))$\n\n预测的加速比 $S$ 是这两个时间的比率：\n$$\nS = \\frac{T_{\\mathrm{CPU}}}{T_{\\mathrm{GPU}}}\n$$\n常数 $a_c, b_c, c_c, a_g, b_g, c_g, \\rho, \\sigma$ 被赋予了固定值。这个模型提供了在批量设置中通过并行化可实现的性能增益的估计。\n\n### 步骤 6：应用于测试用例\n\n所描述的方法应用于每个测试用例 $(n, \\alpha, m, \\text{seed})$。对于每个用例，构造矩阵 $A = -\\alpha \\operatorname{tridiag}(-1, 2, -1)$ 和向量 $\\mathbf{b}$（来自具有指定种子的标准正态分布）。然后按照上述步骤计算 Padé 近似值 $\\mathbf{y}$、参考解 $\\mathbf{y}_{\\mathrm{ref}}$、相对误差和预测加速比。", "answer": "```python\nimport numpy as np\nimport math\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve, expm_multiply\n\ndef get_pade_coeffs(m):\n    \"\"\"\n    Computes coefficients of the numerator p_m(z) and denominator q_m(z)\n    of the (m,m) Padé approximant to exp(z), in descending power order.\n    The formula for the coefficient of z^k in p_m(z) is:\n    c_k = (m! * (2m-k)!) / ((2m)! * k! * (m-k)!)\n    \"\"\"\n    if m  0:\n        raise ValueError(\"Order m must be a non-negative integer.\")\n    p_coeffs = np.zeros(m + 1, dtype=float)\n    q_coeffs = np.zeros(m + 1, dtype=float)\n    \n    try:\n        fact_m = math.factorial(m)\n        fact_2m = math.factorial(2 * m)\n    except ValueError:\n        # Fallback for very large m, though not needed for this problem\n        # Using logarithms for stability with large numbers\n        log_fact_m = math.lgamma(m + 1)\n        log_fact_2m = math.lgamma(2 * m + 1)\n        for k in range(m + 1):\n            log_term = log_fact_m + math.lgamma(2 * m - k + 1) - \\\n                       (log_fact_2m + math.lgamma(k + 1) + math.lgamma(m - k + 1))\n            coeff_val = math.exp(log_term)\n            p_coeffs[m - k] = coeff_val\n            q_coeffs[m - k] = ((-1)**k) * coeff_val\n        return p_coeffs, q_coeffs\n\n\n    for k in range(m + 1):\n        # Coefficients for p_m(z)\n        coeff_val = (fact_m * math.factorial(2 * m - k)) / \\\n                    (fact_2m * math.factorial(k) * math.factorial(m - k))\n        p_coeffs[m - k] = coeff_val\n        # Coefficients for q_m(z) = p_m(-z)\n        q_coeffs[m - k] = ((-1)**k) * coeff_val\n        \n    return p_coeffs, q_coeffs\n\ndef get_pade_partial_fractions(m):\n    \"\"\"\n    Computes the partial fraction expansion of the (m,m) Padé approximant to exp(z).\n    Returns c0, poles (zeta), and residues (alpha).\n    \"\"\"\n    if m == 0:\n        return 1.0, np.array([]), np.array([])\n        \n    p_coeffs, q_coeffs = get_pade_coeffs(m)\n    \n    # Constant c0 from polynomial long division (ratio of leading coefficients)\n    c0 = p_coeffs[0] / q_coeffs[0]\n    \n    # Poles are the roots of the denominator polynomial q_m(z)\n    poles = np.roots(q_coeffs)\n    \n    # Residues alpha_j = p_m(zeta_j) / q'_m(zeta_j)\n    q_prime_coeffs = np.polyder(q_coeffs)\n    \n    p_at_poles = np.polyval(p_coeffs, poles)\n    q_prime_at_poles = np.polyval(q_prime_coeffs, poles)\n    \n    residues = p_at_poles / q_prime_at_poles\n    \n    return c0, poles, residues\n\ndef pade_approx_action(A, b, m):\n    \"\"\"\n    Computes y = r_m,m(A)b using partial fraction expansion.\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return np.array([])\n        \n    c0, poles, residues = get_pade_partial_fractions(m)\n    \n    # Initialize result vector (must be complex)\n    y = c0 * b.astype(np.complex128)\n    \n    A_complex = A.astype(np.complex128)\n    \n    for pole, res in zip(poles, residues):\n        # Construct the shifted sparse matrix\n        M = A_complex - pole * identity(n, format='csc', dtype=np.complex128)\n        \n        # Solve the shifted linear system\n        x = spsolve(M, b)\n        \n        # Accumulate the result\n        y += res * x\n        \n    # For real A and b, the imaginary part should be close to zero\n    return y.real\n\ndef calculate_speedup(n, nnz, K):\n    \"\"\"\n    Calculates the theoretical speedup S = T_CPU / T_GPU based on the problem's model.\n    \"\"\"\n    if n == 0:\n        return 1.0 # Or some neutral value\n    # Model constants\n    a_c, b_c, c_c = 8e-9, 5e-8, 2e-9\n    a_g, b_g, c_g = 1e-9, 8e-9, 5e-10\n    rho, sigma = 0.5, 0.3\n    \n    sqrt_n = math.sqrt(n)\n    \n    # CPU Time\n    T_cpu = K * nnz * (a_c + b_c * sqrt_n + c_c)\n    \n    # GPU Time\n    T_gpu = nnz * (a_g + K * (rho * b_g * sqrt_n + sigma * c_g))\n\n    if T_gpu == 0:\n        return float('inf') if T_cpu > 0 else 1.0\n\n    return T_cpu / T_gpu\n\ndef solve():\n    \"\"\"\n    Main solver function to execute all tasks for the given test cases.\n    \"\"\"\n    test_cases = [\n        (40, 0.10, 6, 12345),\n        (1, 0.00, 4, 2024),\n        (60, 0.08, 8, 31415),\n    ]\n\n    results = []\n    \n    for n, alpha, m, seed in test_cases:\n        # Set up matrix A and vector b\n        np.random.seed(seed)\n        if n > 0:\n             b = np.random.randn(n)\n             if n == 1:\n                 L_n = diags([2], [0], shape=(1, 1), format='csc')\n                 nnz = 1\n             else:\n                 L_n = diags([-1, 2, -1], [-1, 0, 1], shape=(n, n), format='csc')\n                 nnz = 3 * n - 2\n             A = -alpha * L_n\n        else:\n            A = diags([],[], shape=(0,0), format='csc')\n            b = np.array([])\n            nnz = 0\n            \n        # 1. Compute approximation using Padé method\n        y_approx = pade_approx_action(A, b, m)\n\n        # 2. Compute reference solution\n        if n > 0:\n            y_ref = expm_multiply(A, b)\n        else:\n            y_ref = np.array([])\n\n        # 3. Calculate relative error\n        norm_y_ref = np.linalg.norm(y_ref)\n        if norm_y_ref > 1e-15:\n            error = np.linalg.norm(y_approx - y_ref) / norm_y_ref\n        elif np.linalg.norm(y_approx) > 1e-15:\n            error = float('inf')\n        else:\n            error = 0.0\n\n        # 4. Calculate predicted speedup\n        K = m\n        speedup = calculate_speedup(n, nnz, K)\n\n        results.extend([error, speedup])\n\n    # Format output as specified\n    formatted_results = [f\"{val:.8f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3564069"}]}