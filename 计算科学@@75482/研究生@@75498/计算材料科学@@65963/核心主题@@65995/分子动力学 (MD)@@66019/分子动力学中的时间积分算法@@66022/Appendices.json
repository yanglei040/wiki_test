{"hands_on_practices": [{"introduction": "本实践将积分器稳定性的理论分析与真实模拟中时间步长的实际选择联系起来。我们将通过考察广泛应用的速度 Verlet 算法在简谐振子上的表现，来推导其稳定性条件。然后，我们将此条件应用于一个具体的材料科学问题——氢化石墨烯片——通过识别系统的最高振动频率来估算最大允许时间步长 [@problem_id:3497060]。这项练习是建立任何稳定的分子动力学模拟的基础。", "problem": "一个由氢化石墨烯片组成的共价固体被用于分子动力学（MD）建模，其中原子通过谐波键伸缩势相互作用。主要的伸缩键是碳-氢键和碳-碳键，其实验测定的键伸缩刚度分别为 $k_{\\mathrm{C-H}} = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$ 和 $k_{\\mathrm{C-C}} = 1.20 \\times 10^{3}\\ \\mathrm{N/m}$。原子质量为 $m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$ 和 $m_{\\mathrm{C}} = 12.0107\\ \\mathrm{u}$，其中 $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$。假设最硬的振动模式可以很好地近似为由最硬的弹簧连接的轻原子的简谐运动，并使用最硬键的刚度及其连接的较轻原子的质量，通过 $\\omega_{\\max} = \\sqrt{k/m}$ 估算最大角频率。\n\n从应用于谐波势的牛顿第二定律和速度 Verlet 算法的离散更新方程出发，推导对于谐振子，用角频率 $\\omega$ 表示的时间步长 $\\Delta t$ 的线性稳定性条件。使用该条件计算上面确定的最硬模式下速度 Verlet 算法的最大稳定时间步长。以飞秒为单位表示最终的时间步长，使用 $1\\ \\mathrm{fs} = 10^{-15}\\ \\mathrm{s}$，并将您的答案四舍五入到四位有效数字。", "solution": "### 稳定性条件的推导\n\n一维谐振子的无量纲运动由牛顿第二定律描述：\n$$ \\frac{d^2x}{dt^2} = -\\omega^2 x $$\n其中 $\\omega = \\sqrt{k/m}$ 是角频率，$x$ 是偏离平衡位置的位移，$k$ 是弹簧常数，$m$ 是质量。加速度为 $a(t) = -\\omega^2 x(t)$。\n\n速度 Verlet 算法包含以下对位置 $x$ 和速度 $v$ 在一个时间步长 $\\Delta t$ 内的更新步骤：\n$$ x(t+\\Delta t) = x(t) + v(t) \\Delta t + \\frac{1}{2} a(t) (\\Delta t)^2 $$\n$$ v(t+\\Delta t) = v(t) + \\frac{1}{2} [a(t) + a(t+\\Delta t)] \\Delta t $$\n\n设 $x_n = x(n\\Delta t)$、$v_n = v(n\\Delta t)$ 和 $a_n = a(n\\Delta t)$。离散形式的方程为：\n$$ x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t $$\n\n对于谐振子，$a_n = -\\omega^2 x_n$ 且 $a_{n+1} = -\\omega^2 x_{n+1}$。将这些代入更新规则中：\n$$ x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 $$\n$$ v_{n+1} = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t $$\n\n我们可以将其写成状态向量 $\\mathbf{z}_n = \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$ 的矩阵变换形式。首先，我们仅用 $x_n$ 和 $v_n$ 来表示 $x_{n+1}$ 和 $v_{n+1}$。\n$x_{n+1}$ 的方程已经是所需的形式：\n$$ x_{n+1} = \\left(1 - \\frac{1}{2} (\\omega \\Delta t)^2\\right) x_n + (\\Delta t) v_n $$\n现在将这个 $x_{n+1}$ 的表达式代入 $v_{n+1}$ 的方程中：\n$$ v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[x_n + \\left(x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2\\right)\\right] $$\n$$ v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[2x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2\\right] $$\n$$ v_{n+1} = v_n - \\omega^2 \\Delta t x_n - \\frac{1}{2} (\\omega \\Delta t)^2 v_n + \\frac{1}{4} \\omega^4 (\\Delta t)^3 x_n $$\n$$ v_{n+1} = \\left[-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4} (\\omega \\Delta t)^2\\right)\\right] x_n + \\left(1 - \\frac{1}{2} (\\omega \\Delta t)^2\\right) v_n $$\n\n该系统可以写成矩阵形式 $\\mathbf{z}_{n+1} = \\mathbf{A} \\mathbf{z}_n$，其中 $\\mathbf{A}$ 是放大矩阵：\n$$ \\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}(\\omega \\Delta t)^2   \\Delta t \\\\ -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right)   1 - \\frac{1}{2}(\\omega \\Delta t)^2 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} $$\n为使算法稳定，放大矩阵 $\\mathbf{A}$ 的特征值 $\\lambda$ 的模必须小于或等于 $1$。通过求解特征方程 $\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$ 来找到特征值。\n$$ \\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2 - \\lambda\\right)^2 + \\Delta t \\left(\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right)\\right) = 0 $$\n$$ \\lambda^2 - 2\\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2\\right)\\lambda + \\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2\\right)^2 + (\\omega \\Delta t)^2 \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right) = 0 $$\n$$ \\lambda^2 - \\left(2 - (\\omega \\Delta t)^2\\right)\\lambda + \\left(1 - (\\omega \\Delta t)^2 + \\frac{1}{4}(\\omega \\Delta t)^4\\right) + \\left((\\omega \\Delta t)^2 - \\frac{1}{4}(\\omega \\Delta t)^4\\right) = 0 $$\n$$ \\lambda^2 - \\left(2 - (\\omega \\Delta t)^2\\right)\\lambda + 1 = 0 $$\n$\\lambda$ 的解为：\n$$ \\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(2 - (\\omega \\Delta t)^2)^2 - 4}}{2} = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm \\sqrt{\\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 - 1} $$\n为保证稳定性，我们要求 $|\\lambda| \\le 1$。\n如果平方根内的项为非正数，则特征值为复共轭。该项为非正数的条件是：\n$$ \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 - 1 \\le 0 \\implies \\left|1 - \\frac{(\\omega \\Delta t)^2}{2}\\right| \\le 1 $$\n这个不等式展开为：\n$$ -1 \\le 1 - \\frac{(\\omega \\Delta t)^2}{2} \\le 1 $$\n右边，$1 - \\frac{(\\omega \\Delta t)^2}{2} \\le 1$，意味着 $-\\frac{(\\omega \\Delta t)^2}{2} \\le 0$，这总是成立的。\n左边，$-1 \\le 1 - \\frac{(\\omega \\Delta t)^2}{2}$，意味着 $\\frac{(\\omega \\Delta t)^2}{2} \\le 2$，得出 $(\\omega \\Delta t)^2 \\le 4$。\n因此，对于复特征值，稳定性要求 $(\\omega \\Delta t)^2 \\le 4$。在这种情况下，特征值的模为：\n$$ |\\lambda|^2 = \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 + \\left(1 - \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2\\right) = 1 $$\n所以，对于 $(\\omega \\Delta t)^2 \\le 4$，$|\\lambda|=1$。\n如果 $(\\omega \\Delta t)^2  4$，特征值为实数且不相等。设 $X = \\frac{(\\omega \\Delta t)^2}{2}  2$。则 $\\lambda = (1-X) \\pm \\sqrt{(1-X)^2 - 1}$。由于 $1-X  -1$，一个特征值的模将大于 $1$：$\\lambda_{-} = (1-X) - \\sqrt{(1-X)^2 - 1}  -1$。这会导致不稳定的轨迹。\n因此，稳定性极限由边界条件 $(\\omega \\Delta t)^2 = 4$ 给出。\n速度 Verlet 算法的线性稳定性条件是：\n$$ \\omega \\Delta t \\le 2 $$\n\n### 最大稳定时间步长的计算\n\n最大稳定时间步长 $\\Delta t_{\\max}$ 由系统中的最高频率模式 $\\omega_{\\max}$ 决定：\n$$ \\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}} $$\n问题要求使用最硬的键和较轻原子的质量，通过 $\\omega_{\\max} = \\sqrt{k/m}$ 来估算 $\\omega_{\\max}$。\n比较键刚度，$k_{\\mathrm{C-H}} = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$ 和 $k_{\\mathrm{C-C}} = 1.20 \\times 10^{3}\\ \\mathrm{N/m}$，最硬的键是 C-H 键，所以 $k = k_{\\mathrm{C-H}}$。\n该键中的原子是碳 ($m_{\\mathrm{C}}$) 和氢 ($m_{\\mathrm{H}}$)。较轻的原子是氢，所以 $m = m_{\\mathrm{H}}$。\n\n所需值为：\n$k = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$\n$m = m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$\n\n首先，将质量转换为国际单位制（kg）：\n$m = 1.00784\\ \\mathrm{u} \\times (1.66053906660 \\times 10^{-27}\\ \\mathrm{kg/u})$\n$m \\approx 1.673533 \\times 10^{-27}\\ \\mathrm{kg}$\n\n现在，计算 $\\omega_{\\max}$：\n$$ \\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{1.60 \\times 10^{3}\\ \\mathrm{N/m}}{1.673533 \\times 10^{-27}\\ \\mathrm{kg}}} $$\n$$ \\omega_{\\max} \\approx \\sqrt{9.56064 \\times 10^{29}\\ \\mathrm{s^{-2}}} \\approx 9.77785 \\times 10^{14}\\ \\mathrm{s^{-1}} $$\n\n最后，计算最大稳定时间步长 $\\Delta t_{\\max}$：\n$$ \\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}} = \\frac{2}{9.77785 \\times 10^{14}\\ \\mathrm{s^{-1}}} $$\n$$ \\Delta t_{\\max} \\approx 2.04543 \\times 10^{-15}\\ \\mathrm{s} $$\n\n问题要求答案以飞秒（$1\\ \\mathrm{fs} = 10^{-15}\\ \\mathrm{s}$）为单位，并四舍五入到四位有效数字。\n$$ \\Delta t_{\\max} \\approx 2.04543\\ \\mathrm{fs} $$\n四舍五入到四位有效数字得到：\n$$ \\Delta t_{\\max} = 2.045\\ \\mathrm{fs} $$", "answer": "$$ \\boxed{2.045} $$", "id": "3497060"}, {"introduction": "稳定性是必要条件，但一个好的积分器还必须能够随时间精确地再现系统的物理特性。这项动手编程练习 [@problem_id:3497051] 要求您实现速度 Verlet 算法，更重要的是，使用三个关键诊断指标来量化其性能：能量漂移、相位误差和维里误差。通过分析这些指标，您将更深入地理解如何评估积分器在能量守恒、保持时间准确性和正确抽样统计系综方面的保真度。", "problem": "考虑一个受牛顿第二定律支配的一维谐振子，其中一个质量为 $m$ 的粒子连接到一个劲度系数为 $k$ 的理想弹簧上。其位置 $x(t)$ 在力 $f(x) = -k x$ 的作用下演化，加速度为 $a(t) = f(x)/m = -\\omega^{2} x$，其中 $\\omega = \\sqrt{k/m}$ 是角频率。速度为 $v(t) = \\mathrm{d}x/\\mathrm{d}t$。时间积分将使用速度 Verlet 方法进行，该方法需从泰勒展开和牛顿第二定律推导得出，不从外部引入任何公式。\n\n您的任务是实现一个程序，该程序能够：\n- 使用速度 Verlet 方法，对给定的参数 $(m, k, x_{0}, v_{0}, \\Delta t, N_{\\text{steps}})$ 积分轨迹，其中 $x_{0}$ 是初始位置，$v_{0}$ 是初始速度，$\\Delta t$ 是时间步长，$N_{\\text{steps}}$ 是步数。\n- 在整个轨迹上计算积分器的以下性能诊断指标：\n  1. 能量漂移率：将总机械能时间序列 $E(t) = K(t) + U(t)$（其中 $K(t) = \\frac{1}{2} m v^{2}(t)$ 和 $U(t) = \\frac{1}{2} k x^{2}(t)$）在采样时间上拟合成一条直线 $E(t) \\approx \\alpha t + \\beta$，并返回斜率 $\\alpha$ 作为能量漂移率。能量漂移率以焦耳/秒 (J/s) 为单位表示。\n  2. 最终时间的相位误差：对于谐振子，在时间 $t$ 的相空间中的极角定义为 $\\theta(t) = \\operatorname{atan2}\\!\\left(\\frac{v(t)}{\\omega}, x(t)\\right)$。设 $\\theta_{\\text{num}}(t_{N})$ 是在最终时间 $t_{N} = N_{\\text{steps}} \\Delta t$ 时根据数值轨迹计算出的角度。设 $\\theta_{\\text{exact}}(t_{N}) = \\operatorname{atan2}\\!\\left(\\frac{v_{0}}{\\omega}, x_{0}\\right) + \\omega t_{N}$ 是在 $t_{N}$ 时的精确谐振子相位。计算缠绕差 $\\Delta \\theta = \\mathrm{wrap}\\!\\left(\\theta_{\\text{num}}(t_{N}) - \\theta_{\\text{exact}}(t_{N})\\right)$ 到区间 $[-\\pi, \\pi]$，并报告 $|\\Delta \\theta|$ 作为相位误差。相位误差以弧度表示。\n  3. 维里误差：对于幂律势 $U \\propto r^{n}$，经典维里定理指出在平衡状态下 $2 \\langle K \\rangle = n \\langle U \\rangle$，其中尖括号表示时间平均。对于谐振子 ($n = 2$)，该定理简化为 $\\langle K \\rangle = \\langle U \\rangle$。在积分后的轨迹上，计算时间平均值 $\\langle K \\rangle$ 和 $\\langle U \\rangle$，并报告由 $\\varepsilon_{\\mathrm{vir}} = \\frac{|\\langle K \\rangle - \\langle U \\rangle|}{\\langle E \\rangle}$ 定义的归一化维里误差，其中 $\\langle E \\rangle = \\langle K \\rangle + \\langle U \\rangle$。该指标是无量纲的。\n\n所有角度必须以弧度计算和报告。所有物理量必须使用国际单位制 (SI)：质量单位为千克 (kg)，劲度系数单位为牛顿/米 (N/m)，位置单位为米 (m)，速度单位为米/秒 (m/s)，时间单位为秒 (s)，能量单位为焦耳 (J)，能量漂移率单位为焦耳/秒 (J/s)。\n\n设计一个程序，针对以下测试套件，积分轨迹并为每种情况返回三个指标：\n- 测试用例 1 (正常路径): $(m, k, x_{0}, v_{0}, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 1.0, 0.0, 0.05, 200)$。\n- 测试用例 2 (接近积分器稳定边界的大时间步长): $(m, k, x_{0}, v_{0}, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 1.0, 0.0, 1.9, 50)$。注意，对于角频率为 $\\omega = \\sqrt{k/m} = 1.0$ 的谐振子，显式 Verlet 族在 $\\omega \\Delta t = 2.0$ 处表现出稳定边界。此测试旨在探测接近该极限时的性能。\n- 测试用例 3 (小时间步长，混合初始条件): $(m, k, x_{0}, v_{0}, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 0.7, 0.3, 0.001, 5000)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含三个浮点数的列表：$[$能量漂移率 (单位 J/s), 相位误差 (单位弧度), 维里误差 (无量纲)$]$。每个数字必须四舍五入到 $6$ 位小数。例如，输出格式必须严格为：\n$[[\\alpha_{1}, \\Delta\\theta_{1}, \\varepsilon_{\\mathrm{vir},1}],[\\alpha_{2}, \\Delta\\theta_{2}, \\varepsilon_{\\mathrm{vir},2}],[\\alpha_{3}, \\Delta\\theta_{3}, \\varepsilon_{\\mathrm{vir},3}]]$.\n\n除了实现计算之外，请在您的解决方案中解释为什么这些诊断指标共同表征了速度 Verlet 积分器的性能。", "solution": "该问题要求实现并评估用于一维谐振子的速度 Verlet 积分算法。积分器的性能将通过三个不同的指标来表征：能量漂移率、相位误差和维里误差。首先，我们将按规定推导速度 Verlet 算法，然后分析每个诊断指标的重要性。\n\n### 速度 Verlet 算法的推导\n\n速度 Verlet 算法是积分牛顿运动方程的一种数值方法。它可以从位置 $x(t)$ 在时间 $t$ 附近的泰勒级数展开推导出来。在未来时间 $t + \\Delta t$ 的位置由下式给出：\n$$\nx(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2} a(t) \\Delta t^2 + \\frac{1}{6} \\dot{a}(t) \\Delta t^3 + \\mathcal{O}(\\Delta t^4)\n$$\n其中 $v(t) = \\dot{x}(t)$ 是速度，$a(t) = \\ddot{x}(t)$ 是加速度。\n\n速度 Verlet 方法的核心在于对位置和速度更新的一个巧妙组合，它在 $\\Delta t$ 上达到了二阶精度，同时保持了时间可逆性和良好的能量守恒特性。该算法分为两个主要步骤进行。\n\n首先，将位置从时间 $t$ 更新到 $t + \\Delta t$。我们使用截断至二阶项的泰勒展开：\n$$\nx(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2\n$$\n此更新使用当前时间 $t$ 的位置、速度和加速度来计算新位置 $x(t + \\Delta t)$。\n\n其次，我们需要将速度更新到 $v(t + \\Delta t)$。一个简单的前向欧拉更新，$v(t + \\Delta t) = v(t) + a(t)\\Delta t$，仅具有一阶精度，并会导致较差的稳定性。为达到二阶精度，我们对时间步开始和结束时的加速度进行平均。速度更新规则基于加速度积分的梯形法则：\n$$\nv(t + \\Delta t) = v(t) + \\int_{t}^{t+\\Delta t} a(\\tau) d\\tau \\approx v(t) + \\frac{a(t) + a(t + \\Delta t)}{2}\\Delta t\n$$\n这需要新时间点的加速度 $a(t + \\Delta t)$，它可以根据新位置 $x(t + \\Delta t)$ 通过牛顿第二定律计算得出：$a(t + \\Delta t) = f(x(t + \\Delta t))/m$。\n\n结合这些步骤，得到从 $t_i$ 到 $t_{i+1}$ 的单个时间步的完整速度 Verlet 算法：\n1.  更新位置：$x_{i+1} = x_i + v_i \\Delta t + \\frac{1}{2} a_i \\Delta t^2$。\n2.  计算新加速度：$a_{i+1} = \\frac{f(x_{i+1})}{m}$。\n3.  更新速度：$v_{i+1} = v_i + \\frac{1}{2} (a_i + a_{i+1}) \\Delta t$。\n\n该方案是显式的、自启动的、时间可逆的和辛守恒的，这些特性使其具有出色的长期稳定性。\n\n### 性能诊断指标分析\n\n所选择的三个诊断指标——能量漂移、相位误差和维里误差——通过探究积分器对真实动力学的不同物理和统计特性的保真度，提供了对其质量的全面评估。\n\n1.  **能量漂移率 ($\\alpha$)**: 孤立谐振子的总机械能 $E=K+U$ 是一个守恒量。然而，数值积分器通常会引入误差，导致计算出的能量偏离其初始值。速度 Verlet 算法是辛守恒的，这意味着它精确地保守一个接近真实哈密顿量的“影子”哈密顿量。因此，从 Verlet 轨迹计算出的能量在长时间内不会系统性地漂移，而是围绕一个恒定的平均值振荡。这些振荡的振幅与 $\\Delta t^2$ 成比例。能量漂移率 $\\alpha$ 是通过将能量时间序列 $E(t)$ 拟合成一条直线来确定的。对于一个在许多周期上运行的完美辛积分器，该斜率应为零。在有限的模拟中，一个非零的 $\\alpha$ 表明了偏离完美辛性的程度（例如，由于有限精度算术），或者可能是将长周期振荡的一个短片段拟合成直线而产生的假象，尤其是在 $\\Delta t$ 较大时。它是积分器长期稳定性的一个主要度量。\n\n2.  **最终时间的相位误差 ($|\\Delta \\theta|$)**: 虽然 Verlet 积分器表现出优异的长期能量守恒性，但它们通常会在振荡频率上引入一个小的误差。数值轨迹以一个与精确解析频率 $\\omega$ 略有不同的角频率 $\\omega_{\\text{num}}$ 演化。这导致相空间中振子的相角 $\\theta(t)$ 出现长期漂移。相位误差定义为最终时间的数值相位与精确相位之差，它会在模拟过程中累积，与时间近似成线性关系。它是积分器时间精度的直接度量，即它能多准确地再现系统动力学的时间尺度。一个具有大相位误差的积分器可能能够守恒能量，但会产生一条与现实不同步的轨迹。\n\n3.  **维里误差 ($\\varepsilon_{\\mathrm{vir}}$)**: 维里定理提供了时间平均动能 $\\langle K \\rangle$ 和时间平均势能 $\\langle U \\rangle$ 之间的关系。对于形式为 $U \\propto r^n$ 的势，该定理指出 $2\\langle K \\rangle = n \\langle U \\rangle$。对于谐振子，势能为 $U(x) = \\frac{1}{2} k x^2$，所以 $n=2$，该定理简化为 $\\langle K \\rangle = \\langle U \\rangle$。这是一个关于轨迹所采样的状态统计分布的陈述。维里误差 $\\varepsilon_{\\mathrm{vir}}$ 量化了数值轨迹满足这一基本统计力学性质的程度。一个小的维里误差表明积分器正在正确地随时间采样构型和动能分布，这意味着从模拟中获得的热力学和统计力学性质是可靠的。\n\n总之，这三个指标提供了一个多方面的评估：能量漂移评估**稳定性和守恒定律**，相位误差评估**时间精度和动力学传播**，维里误差评估**统计力学完整性**。一个高质量的积分器必须在这三个方面都表现良好。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (m, k, x0, v0, dt, n_steps)\n        (1.0, 1.0, 1.0, 0.0, 0.05, 200),\n        (1.0, 1.0, 1.0, 0.0, 1.9, 50),\n        (1.0, 1.0, 0.7, 0.3, 0.001, 5000),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        m, k, x0, v0, dt, n_steps = case\n        \n        # Run simulation and compute diagnostics\n        alpha, phase_error, virial_error = run_simulation(m, k, x0, v0, dt, n_steps)\n        \n        # Format the result for the current case\n        res_str = f\"[{alpha:.6f}, {phase_error:.6f}, {virial_error:.6f}]\"\n        all_results_str.append(res_str)\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\ndef run_simulation(m, k, x0, v0, dt, n_steps):\n    \"\"\"\n    Integrates a 1D harmonic oscillator using velocity Verlet and computes performance diagnostics.\n\n    Args:\n        m (float): Mass of the particle.\n        k (float): Spring stiffness.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        n_steps (int): Number of integration steps.\n\n    Returns:\n        tuple: A tuple containing (energy_drift_rate, phase_error, virial_error).\n    \"\"\"\n    omega = np.sqrt(k / m)\n    \n    # Initialize arrays to store trajectory data\n    # Size is n_steps + 1 to include the initial state at t=0\n    num_points = n_steps + 1\n    times = np.linspace(0, n_steps * dt, num_points)\n    positions = np.zeros(num_points)\n    velocities = np.zeros(num_points)\n    total_energies = np.zeros(num_points)\n    \n    # Set initial conditions\n    positions[0] = x0\n    velocities[0] = v0\n    \n    # Initial acceleration and energy\n    a_current = -k * positions[0] / m\n    kinetic_energy = 0.5 * m * velocities[0]**2\n    potential_energy = 0.5 * k * positions[0]**2\n    total_energies[0] = kinetic_energy + potential_energy\n    \n    # Velocity Verlet integration loop\n    for i in range(n_steps):\n        # Update position\n        positions[i+1] = positions[i] + velocities[i] * dt + 0.5 * a_current * dt**2\n        \n        # Update acceleration\n        a_next = -k * positions[i+1] / m\n        \n        # Update velocity\n        velocities[i+1] = velocities[i] + 0.5 * (a_current + a_next) * dt\n        \n        # Store new acceleration for the next step\n        a_current = a_next\n        \n        # Calculate and store total energy\n        kinetic_energy = 0.5 * m * velocities[i+1]**2\n        potential_energy = 0.5 * k * positions[i+1]**2\n        total_energies[i+1] = kinetic_energy + potential_energy\n\n    # --- Compute Diagnostics ---\n\n    # 1. Energy Drift Rate\n    # Linear regression of E(t) vs t\n    lin_reg_result = linregress(times, total_energies)\n    alpha = lin_reg_result.slope\n\n    # 2. Phase Error\n    # Final numerical phase angle\n    theta_num_final = np.arctan2(velocities[-1] / omega, positions[-1])\n    \n    # Exact final phase angle\n    theta_initial = np.arctan2(v0 / omega, x0)\n    theta_exact_final = theta_initial + omega * (n_steps * dt)\n    \n    # Wrapped phase difference\n    delta_theta = theta_num_final - theta_exact_final\n    wrapped_delta_theta = (delta_theta + np.pi) % (2 * np.pi) - np.pi\n    phase_error_abs = np.abs(wrapped_delta_theta)\n\n    # 3. Virial Error\n    # Time averages of kinetic and potential energies over the whole trajectory\n    kin_energies = 0.5 * m * velocities**2\n    pot_energies = 0.5 * k * positions**2\n    avg_K = np.mean(kin_energies)\n    avg_U = np.mean(pot_energies)\n    \n    # Avoid division by zero if total energy is zero (unlikely but possible)\n    avg_E = avg_K + avg_U\n    if np.isclose(avg_E, 0):\n        virial_error = 0.0\n    else:\n        virial_error = np.abs(avg_K - avg_U) / avg_E\n        \n    return alpha, phase_error_abs, virial_error\n\nsolve()\n```", "id": "3497051"}, {"introduction": "真实世界的材料模拟通常涉及复杂的多体势，这些势可能具有不可微点或“尖点”，这对标准的时间积分算法构成了重大挑战。在这个高级实践 [@problem_id:3497076] 中，您将研究这种非光滑势对位置 Verlet 和速度 Verlet 两种积分器能量守恒性的影响。此外，您还将探索一种称为力平滑化（mollification）的实用技术来缓解这些数值问题，从而深入了解高保真模拟中物理模型与数值方法之间的相互作用。", "problem": "要求你定量比较两种来自 Verlet 族的 时间积分算法，在一种典型的金属多体势作用下的能量守恒特性，并评估当势函数包含尖点状特征时，力平滑（软化）处理带来的益处。具体情境为一个一维周期性原子链，原子间通过一种简化的类嵌入原子方法（EAM）多体势相互作用，该势的嵌入泛函中存在一个尖点，并包含一个光滑的 Morse 对势。\n\n从以下基本原理出发：\n- 牛顿第二定律：$$m \\frac{d^2 x_i}{dt^2} = F_i,$$ 其中 $m$ 是粒子质量，$x_i$ 是粒子 $i$ 的位置，$F_i$ 是作用在粒子 $i$ 上的总力。\n- 速度定义：$$v_i = \\frac{dx_i}{dt}.$$\n- 总能量：$$E = \\sum_i \\frac{1}{2} m v_i^2 + U(\\{x_i\\}),$$ 其中 $U$ 是总势能。\n- 对于一维、长度为 $L$ 的周期性边界条件下的 $N$ 个原子（$i=1,\\dots,N$），其类 EAM 多体势能为：\n  $$U = \\sum_{i=1}^N F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}),$$\n  其中局部“电子密度”为\n  $$\\rho_i = \\sum_{j \\neq i} f(r_{ij}),$$\n  原子对距离为 $$r_{ij} = \\left| x_i - x_j - L \\,\\mathrm{round}\\left(\\frac{x_i - x_j}{L}\\right) \\right|,$$\n  密度核函数为 $$f(r) = \\begin{cases} \\exp(-\\beta r),  r \\le r_c, \\\\ 0,  r > r_c, \\end{cases}$$\n  光滑对势（Morse 势）为\n  $$\\phi(r) = D\\left(e^{-2\\alpha (r - r_0)} - 2 e^{-\\alpha (r - r_0)}\\right), \\quad r \\le r_c,$$\n  以及一个在 $$\\rho_0$$ 处有尖点的嵌入泛函\n  $$F(\\rho) = A \\, |\\rho - \\rho_0|.$$\n  力平滑（软化）将不可微的 $|\\rho - \\rho_0|$ 替换为一个光滑近似\n  $$F_\\epsilon(\\rho) = A \\sqrt{(\\rho - \\rho_0)^2 + \\epsilon^2},$$\n  其导数为\n  $$F_\\epsilon'(\\rho) = A \\frac{\\rho - \\rho_0}{\\sqrt{(\\rho - \\rho_0)^2 + \\epsilon^2}}.$$\n  在非平滑极限 $\\epsilon \\to 0$ 下，嵌入导数恢复为符号函数 $$F_0'(\\rho) = A \\,\\mathrm{sign}(\\rho - \\rho_0),$$ 在尖点 $\\rho=\\rho_0$ 处的次梯度为 $0$。\n\n原子 $i$ 上受到的力通过对 $U$ 求关于 $x_i$ 的负梯度得到。在一维情况下，根据最小镜像约定和单位方向 $e_{ij} = \\frac{x_i - x_j - L\\,\\mathrm{round}((x_i - x_j)/L)}{r_{ij}}$，每对原子 $(i,j)$ 的力贡献形式如下：\n对势项\n$$F_i^{\\text{pair}} = - \\sum_{j \\neq i} \\phi'(r_{ij}) \\, e_{ij}, \\quad \\phi'(r) = 2 \\alpha D \\left(e^{-\\alpha (r - r_0)} - e^{-2 \\alpha (r - r_0)}\\right),$$\n以及嵌入项\n$$F_i^{\\text{emb}} = - \\sum_{j \\neq i} \\left(F'(\\rho_i) + F'(\\rho_j)\\right) f'(r_{ij}) \\, e_{ij}, \\quad f'(r) = -\\beta \\exp(-\\beta r),$$\n其中 $F'(\\rho)$ 可被解释为软化导数 $F_\\epsilon'(\\rho)$ 或非平滑的基于符号函数的导数 $F_0'(\\rho)$。\n\n你必须实现并比较以下两种时间积分器：\n- 标准位置 Verlet 算法：使用当前和先前的位置以及当前加速度来推进位置，不显式更新速度，然后通过中心差分重构速度以进行能量评估。\n- 速度 Verlet 算法：使用当前和下一步的加速度来推进位置和速度。\n\n系统规格与单位：\n- 长度为 $$L = 10.0 \\,\\mathrm{\\AA}$$ 的一维周期性盒子。\n- 原子数 $$N = 4$$，初始位置为 $$x = [0.0, 2.5, 5.0, 7.5] \\,\\mathrm{\\AA}$$。\n- 初始速度为 $$v = [0.0, 0.02, -0.02, 0.0] \\,\\mathrm{\\AA}/\\mathrm{fs}$$。\n- 每个原子的质量为 $$m = 58.693 \\,\\mathrm{amu}$$。\n- 对势参数：$$D = 0.3 \\,\\mathrm{eV}, \\; \\alpha = 1.2 \\,\\mathrm{\\AA}^{-1}, \\; r_0 = 2.5 \\,\\mathrm{\\AA}, \\; r_c = 6.0 \\,\\mathrm{\\AA}$$。\n- 密度核函数参数 $$\\beta = 1.5 \\,\\mathrm{\\AA}^{-1}$$。\n- 嵌入项振幅 $$A = 0.8 \\,\\mathrm{eV}$$。\n- 尖点位置 $$\\rho_0 = 2 e^{-\\beta r_0} + e^{-2 \\beta r_0}$$。该选择使得在非平滑嵌入模型中，初始状态恰好位于尖点处。\n- 使用一致的物理单位，其中位置单位为 $$\\mathrm{\\AA}$$，速度单位为 $$\\mathrm{\\AA}/\\mathrm{fs}$$，时间步长单位为 $$\\mathrm{fs}$$，能量单位为 $$\\mathrm{eV}$$，质量单位为 $$\\mathrm{amu}$$。在计算加速度时，使用 $$F = m a$$，其中 $$F$$ 的单位是 $$\\mathrm{eV}/\\mathrm{\\AA}$$（需转换为牛顿），$$m$$ 的单位是 $$\\mathrm{kg}$$，然后将 $$a$$ 转换为 $$\\mathrm{\\AA}/\\mathrm{fs}^2$$；在计算动能时，将能量以 $$\\mathrm{eV}$$ 为单位表示。\n\n为包含 $M$ 个步长的轨迹定义以下能量守恒度量：\n- 最大绝对相对能量偏差\n  $$\\Delta_{\\max} = \\max_{0 \\le n  M} \\frac{|E_n - E_0|}{|E_0|},$$\n  其中 $$E_n$$ 是第 $$n$$ 步的总能量，$$E_0$$ 是第 $$n=0$$ 步的初始能量。\n\n实现两种积分器，并在两种嵌入函数（非平滑（$\\epsilon = 0$）和软化（$\\epsilon  0$））下计算 $$\\Delta_{\\max}$$。根据这四个 $$\\Delta_{\\max}$$ 值，计算：\n- 积分器比较比率（非平滑嵌入）：$$R_{\\text{int}} = \\frac{\\Delta_{\\max}^{\\text{position-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{velocity-Verlet, unsmoothed}}}$$。\n- 速度 Verlet 算法的平滑效益：$$R_{\\text{smooth,VV}} = \\frac{\\Delta_{\\max}^{\\text{velocity-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{velocity-Verlet, smoothed}}}$$。\n- 位置 Verlet 算法的平滑效益：$$R_{\\text{smooth,PV}} = \\frac{\\Delta_{\\max}^{\\text{position-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{position-Verlet, smoothed}}}$$。\n\n测试套件：\n对于每组参数，使用两种积分器和两种嵌入函数（非平滑和平滑）运行 $$M = 3000$$ 步，涵盖以下情况：\n1. 理想路径：$$\\Delta t = 1.0 \\,\\mathrm{fs}, \\; \\epsilon = 0.02$$。\n2. 边界靠近尖点且时间分辨率更高：$$\\Delta t = 0.5 \\,\\mathrm{fs}, \\; \\epsilon = 0.02$$。\n3. 大时间步长压力测试：$$\\Delta t = 2.5 \\,\\mathrm{fs}, \\; \\epsilon = 0.02$$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，按顺序包含每个测试用例的三元组 $$[R_{\\text{int}}, R_{\\text{smooth,VV}}, R_{\\text{smooth,PV}}]$$，并将这三个三元组聚合为一个列表，格式为一个由逗号分隔的列表组成的列表，并用方括号括起来（例如：[[r11,r12,r13],[r21,r22,r23],[r31,r32,r33]]）。所有三个比率都必须打印为无单位的十进制浮点数。\n\n在上述推导和算法描述中的所有物理量都必须使用指定的单位处理：位置单位为 $$\\mathrm{\\AA}$$，速度单位为 $$\\mathrm{\\AA}/\\mathrm{fs}$$，时间步长单位为 $$\\mathrm{fs}$$，质量单位为 $$\\mathrm{amu}$$，能量单位为 $$\\mathrm{eV}$$。将最终的比率表示为纯十进制数（无量纲分数）。", "solution": "该问题要求比较位置 Verlet 和速度 Verlet 积分器在一维原子系统中的能量守恒特性，该系统通过一个包含不可微尖点的简化多体势相互作用。同时，也需要量化平滑（软化）此尖点的有益效果。\n\n### 1. 单位换算\n模拟中使用了一套在分子动力学中常见的混合单位制：长度单位为埃（$$\\mathrm{\\AA}$$），时间单位为飞秒（$$\\mathrm{fs}$$），质量单位为原子质量单位（$$\\mathrm{amu}$$），能量单位为电子伏特（$$\\mathrm{eV}$$）。牛顿第二定律 $$F = ma$$ 和动能公式 $$E_K = \\frac{1}{2}mv^2$$ 要求单位一致。我们需要建立转换因子，将单位为 $$\\mathrm{eV}/\\mathrm{\\AA}$$ 的力关联到单位为 $$\\mathrm{\\AA}/\\mathrm{fs}^2$$ 的加速度，以及将单位为 $$\\mathrm{amu} \\cdot (\\mathrm{\\AA}/\\mathrm{fs})^2$$ 的 $$mv^2$$ 项关联到单位为 $$\\mathrm{eV}$$ 的能量。\n\n-   **力到加速度：** 为了从单位为 $$\\mathrm{eV}/\\mathrm{\\AA}$$ 的力 $$F$$ 和单位为 $$\\mathrm{amu}$$ 的质量 $$m$$ 中得到单位为 $$\\mathrm{\\AA}/\\mathrm{fs}^2$$ 的加速度 $$a$$，我们使用转换因子 $$C_{F/m}$$：\n    $$a \\, [\\mathrm{\\AA}/\\mathrm{fs}^2] = \\frac{F \\, [\\mathrm{eV}/\\mathrm{\\AA}]}{m \\, [\\mathrm{amu}]} \\times C_{F/m}$$\n    $$C_{F/m} = \\frac{ (1.602... \\times 10^{-19} \\, \\mathrm{J}/\\mathrm{eV}) / (10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA}) }{ 1.660... \\times 10^{-27} \\, \\mathrm{kg}/\\mathrm{amu} } \\times \\frac{ (10^{-15} \\, \\mathrm{s}/\\mathrm{fs})^2 }{ 10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA} } \\approx 0.0096485$$\n\n-   **动能：** 为了从单位为 $$\\mathrm{amu}$$ 的质量 $$m$$ 和单位为 $$\\mathrm{\\AA}/\\mathrm{fs}$$ 的速度 $$v$$ 中得到单位为 $$\\mathrm{eV}$$ 的动能 $$E_K$$，我们使用转换因子 $$C_{E_K}$$：\n    $$E_K \\, [\\mathrm{eV}] = \\frac{1}{2} m \\, [\\mathrm{amu}] v^2 \\, [(\\mathrm{\\AA}/\\mathrm{fs})^2] \\times C_{E_K}$$\n    $$C_{E_K} = \\frac{ (1.660... \\times 10^{-27} \\, \\mathrm{kg}/\\mathrm{amu}) \\times \\left( (10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA}) / (10^{-15} \\, \\mathrm{s}/\\mathrm{fs}) \\right)^2 }{ 1.602... \\times 10^{-19} \\, \\mathrm{J}/\\mathrm{eV} } \\approx 103.6427$$\n\n### 2. 力与能量的计算\n模拟的核心是计算总势能 $$U$$ 和每个原子所受的力 $$F_i = -\\nabla_i U$$。这包含两个主要步骤：\n1.  对于给定的一组原子位置 $$\\{x_i\\}$$，首先使用最小镜像约定计算所有原子对的距离 $$r_{ij}$$。然后，通过对截断半径 $$r_c$$ 内的邻居原子的贡献 $$f(r_{ij})$$ 求和，计算每个原子位置上的局部电子密度 $$\\rho_i$$。\n2.  在所有 $$\\rho_i$$ 已知的情况下，计算嵌入能贡献 $$U_{emb} = \\sum_i F(\\rho_i)$$ 及其导数 $$F'(\\rho_i)$$。$$F$$ 和 $$F'$$ 的函数形式取决于使用的是平滑模型（$$\\epsilon > 0$$）还是非平滑模型（$$\\epsilon=0$$）。然后，再次遍历所有唯一的原子对 $$(i,j)$$，计算对势能 $$U_{pair} = \\frac{1}{2}\\sum_{i \\neq j} \\phi(r_{ij})$$ 和每个原子上的总力。原子 $$i$$ 上的力是来自所有其他原子 $$j$$ 贡献的总和，包括一个从 $$\\phi'(r_{ij})$$ 导出的对势项和一个涉及 $$F'(\\rho_i)$$、$$F'(\\rho_j)$$ 和 $$f'(r_{ij})$$ 的多体项。\n\n### 3. 积分算法\n\n-   **位置 Verlet 算法：** 该算法在主积分步骤中更新位置，而不显式使用速度。它需要前两个时间步的位置，即 $$x_n$$ 和 $$x_{n-1}$$。\n    -   启动：所需的前一时刻位置 $$x_{-1}$$ 是未知的，必须根据初始条件 $$x_0$$ 和 $$v_0$$ 进行估算。通过泰勒展开可得：$$x_{-1} \\approx x_0 - v_0 \\Delta t + \\frac{1}{2} a_0 (\\Delta t)^2$$，其中 $$a_0 = F(x_0)/m$$。\n    -   时间步：新位置 $$x_{n+1}$$ 由 $$x_n$$、$$x_{n-1}$$ 和当前加速度 $$a_n$$ 计算得出：\n        $$x_{n+1} = 2x_n - x_{n-1} + a_n (\\Delta t)^2$$\n    -   能量计算：为了评估总能量，动能项需要速度。速度通过中心差分公式重构，这与 Verlet 方案的精度阶数相符：\n        $$v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$$\n\n-   **速度 Verlet 算法：** 该算法显式地同时演进位置和速度。它通常是首选算法，因为它在同一时间步提供位置和速度，从而简化了能量计算和恒温控制。\n    -   时间步：更新分两个阶段进行，使用当前步（$$a_n$$）和下一步（$$a_{n+1}$$）的加速度。\n        1.  将位置更新到 $$x_{n+1}$$：$$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n        2.  在新位置 $$x_{n+1}$$ 处计算新的力 $$F_{n+1}$$ 和加速度 $$a_{n+1}$$。\n        3.  将速度更新到 $$v_{n+1}$$：$$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n    -   能量计算：总能量 $$E_{n+1}$$ 使用新计算的位置 $$x_{n+1}$$（用于势能）和速度 $$v_{n+1}$$（用于动能）直接计算。\n\n### 4. 分析\n对于三个测试用例中的每一个，都将执行四次独立的模拟，每次模拟运行 $$M=3000$$ 步：使用和不使用平滑的位置 Verlet 算法，以及使用和不使用平滑的速度 Verlet 算法。对于每次运行，记录最大绝对相对能量偏差 $$\\Delta_{\\max}$$。然后根据这四个 $$\\Delta_{\\max}$$ 值计算指定的比率（$$R_{\\text{int}}, R_{\\text{smooth,VV}}, R_{\\text{smooth,PV}}$$）。所有三个测试用例的结果将汇总到一个最终列表中。非平滑情况通过将平滑参数 $$\\epsilon$$ 设置为 $$0$$ 来进行数值模拟。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics integrator comparison problem.\n    \"\"\"\n    # --- PHYSICAL AND UNIT CONVERSION CONSTANTS ---\n    eV_to_J = 1.602176634e-19\n    amu_to_kg = 1.66053906660e-27\n    Å_to_m = 1e-10\n    fs_to_s = 1e-15\n\n    # F/m conversion factor: [(eV/Å)/amu] -> [Å/fs^2]\n    F_M_CONV = (eV_to_J / Å_to_m) / amu_to_kg * (fs_to_s**2 / Å_to_m)\n\n    # m*v^2 conversion factor: [amu*(Å/fs)^2] -> [eV]\n    MV2_TO_EV = (amu_to_kg * (Å_to_m / fs_to_s)**2) / eV_to_J\n\n    # --- HELPER FUNCTIONS FOR SIMULATION ---\n\n    def calculate_potential_and_forces(x, params, epsilon):\n        N = params['N']; L = params['L']; D = params['D']; alpha = params['alpha']\n        r0_pair = params['r0_pair']; rc = params['rc']; beta = params['beta']\n        A = params['A']; rho0 = params['rho0']\n\n        U_pair = 0.0\n        forces = np.zeros(N)\n        rho = np.zeros(N)\n\n        # Step 1: Calculate local densities rho_i\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dx = dx - L * np.round(dx / L)\n                r_ij = np.abs(dx)\n\n                if r_ij = rc:\n                    f_ij = np.exp(-beta * r_ij)\n                    rho[i] += f_ij\n                    rho[j] += f_ij\n        \n        # Step 2: Calculate embedding energy F(rho) and its derivative F'(rho)\n        delta_rho = rho - rho0\n        if epsilon == 0:\n            U_emb = A * np.sum(np.abs(delta_rho))\n            F_prime_rho = A * np.sign(delta_rho)\n        else:\n            sqrt_term = np.sqrt(delta_rho**2 + epsilon**2)\n            U_emb = A * np.sum(sqrt_term)\n            F_prime_rho = A * delta_rho / sqrt_term\n    \n        # Step 3: Loop over pairs for pair energy and forces\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dx = dx - L * np.round(dx / L)\n                r_ij = np.abs(dx)\n\n                if 0  r_ij = rc:\n                    e_ij = np.sign(dx)\n                    \n                    # Pair potential and force\n                    exp_term = np.exp(-alpha * (r_ij - r0_pair))\n                    phi = D * (exp_term**2 - 2 * exp_term)\n                    phi_prime = 2 * alpha * D * (exp_term - exp_term**2)\n                    \n                    U_pair += phi\n                    F_pair_ij = -phi_prime * e_ij\n                    \n                    # Embedding force\n                    f_prime = -beta * np.exp(-beta * r_ij)\n                    F_emb_ij = -(F_prime_rho[i] + F_prime_rho[j]) * f_prime * e_ij\n                    \n                    # Total pairwise force\n                    F_total_ij = F_pair_ij + F_emb_ij\n                    forces[i] += F_total_ij\n                    forces[j] -= F_total_ij\n    \n        return U_emb + U_pair, forces\n\n    def run_velocity_verlet(x0, v0, params, dt, M, epsilon):\n        m = params['m']; L = params['L']\n        x = np.copy(x0); v = np.copy(v0)\n        \n        U, F = calculate_potential_and_forces(x, params, epsilon)\n        KE = 0.5 * m * np.sum(v**2) * MV2_TO_EV\n        E0 = U + KE\n        if np.abs(E0)  1e-12: return 1.0\n\n        max_abs_dev = 0.0\n        a = F / m * F_M_CONV\n\n        for _ in range(M):\n            x = x + v * dt + 0.5 * a * dt**2\n            x = x % L\n\n            U_next, F_next = calculate_potential_and_forces(x, params, epsilon)\n            a_next = F_next / m * F_M_CONV\n            v = v + 0.5 * (a + a_next) * dt\n            a = a_next\n\n            KE_next = 0.5 * m * np.sum(v**2) * MV2_TO_EV\n            E_next = U_next + KE_next\n            \n            max_abs_dev = max(max_abs_dev, np.abs(E_next - E0))\n        \n        return max_abs_dev / np.abs(E0)\n\n    def run_position_verlet(x0, v0, params, dt, M, epsilon):\n        m = params['m']\n        x_curr = np.copy(x0)\n        \n        U0, F0 = calculate_potential_and_forces(x_curr, params, epsilon)\n        KE0 = 0.5 * m * np.sum(v0**2) * MV2_TO_EV\n        E0 = U0 + KE0\n        if np.abs(E0)  1e-12: return 1.0\n\n        max_abs_dev = 0.0\n        \n        a0 = F0 / m * F_M_CONV\n        x_prev = x_curr - v0 * dt + 0.5 * a0 * dt**2\n        \n        for _ in range(M):\n            U_curr, F_curr = calculate_potential_and_forces(x_curr, params, epsilon)\n            a_curr = F_curr / m * F_M_CONV\n            \n            x_next = 2 * x_curr - x_prev + a_curr * dt**2\n            \n            v_reconstructed = (x_next - x_prev) / (2 * dt)\n            KE_curr = 0.5 * m * np.sum(v_reconstructed**2) * MV2_TO_EV\n            E_curr = U_curr + KE_curr\n            \n            max_abs_dev = max(max_abs_dev, abs(E_curr - E0))\n            x_prev, x_curr = x_curr, x_next\n        \n        return max_abs_dev / np.abs(E0)\n    \n    # --- MAIN EXECUTION ---\n    \n    r0_pair_val = 2.5\n    beta_val = 1.5\n    params = {\n        'N': 4, 'm': 58.693, 'L': 10.0, 'D': 0.3, 'alpha': 1.2, \n        'r0_pair': r0_pair_val, 'rc': 6.0, 'beta': beta_val, 'A': 0.8,\n        'rho0': 2 * np.exp(-beta_val * r0_pair_val) + np.exp(-2 * beta_val * r0_pair_val)\n    }\n    x0 = np.array([0.0, 2.5, 5.0, 7.5])\n    v0 = np.array([0.0, 0.02, -0.02, 0.0])\n\n    test_cases = [\n        {'dt': 1.0, 'epsilon': 0.02, 'M': 3000},\n        {'dt': 0.5, 'epsilon': 0.02, 'M': 3000},\n        {'dt': 2.5, 'epsilon': 0.02, 'M': 3000},\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, epsilon, M = case['dt'], case['epsilon'], case['M']\n        \n        # Unsmoothed runs (epsilon=0)\n        delta_pv_un = run_position_verlet(x0, v0, params, dt, M, epsilon=0)\n        delta_vv_un = run_velocity_verlet(x0, v0, params, dt, M, epsilon=0)\n        \n        # Smoothed runs\n        delta_pv_sm = run_position_verlet(x0, v0, params, dt, M, epsilon)\n        delta_vv_sm = run_velocity_verlet(x0, v0, params, dt, M, epsilon)\n        \n        # Add a small constant to denominators to prevent division by zero\n        safe_denom = 1e-18 \n        R_int = delta_pv_un / (delta_vv_un + safe_denom)\n        R_smooth_VV = delta_vv_un / (delta_vv_sm + safe_denom)\n        R_smooth_PV = delta_pv_un / (delta_pv_sm + safe_denom)\n        \n        results.append([R_int, R_smooth_VV, R_smooth_PV])\n\n    # Format the final output string as per requirements\n    list_strs = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output = f\"[{','.join(list_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3497076"}]}