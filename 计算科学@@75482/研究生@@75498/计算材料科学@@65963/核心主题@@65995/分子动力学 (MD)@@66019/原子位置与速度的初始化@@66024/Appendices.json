{"hands_on_practices": [{"introduction": "将模拟的初始速度设置为与目标温度相匹配是至关重要的。在热平衡状态下，原子的速度分量遵循麦克斯韦-玻尔兹曼分布，这是一个高斯分布。这个练习 [@problem_id:3458384] 要求你从第一性原理出发，通过推导和实现Box-Muller变换来生成符合物理现实的速度分布，并解决实际编程中可能遇到的数值稳定性问题。", "problem": "你的任务是实现一个程序，该程序根据计算材料科学中使用的物理上合理的原理，为单原子气体初始化原子速度分量。从统计力学和基础概率论的第一性原理出发，构建算法，不依赖于预先提供的公式。你的实现和分析必须满足以下要求。\n\n1. 物理基础与目标分布。使用能量均分定理和麦克斯韦-玻尔兹曼分布来论证，在温度为 $T$ 的热平衡状态下，质量为 $m$ 的粒子的速度的每个笛卡尔分量都是一个独立的、均值为零、方差为 $\\sigma^2$ 的高斯随机变量，其中 $\\sigma^2$ 必须从第一性原理推导得出。最终的速度分量以米/秒 (m/s) 表示。为清晰起见：符号 $m$ 必须以千克 (kg) 为单位，$T$ 必须以开尔文 (K) 为单位，玻尔兹曼常数 $k_{\\mathrm{B}}$ 必须以国际单位制 (SI) 正确地包含在内。\n\n2. 概率变换。从独立均匀随机变量的概率密度和保测变换出发，推导一种方法，将开放区间 $(0,1)$ 上的两个独立均匀随机变量映射为两个独立标准正态随机变量。该推导必须基于变量替换公式和几何驱动的变换，且在本问题陈述中不得声明任何快捷公式。角度必须以弧度处理。\n\n3. 对于大 $N$ 的数值鲁棒性。你的算法必须解决在变换接近 $0$ 的均匀分布随机数时出现的数值稳定性问题。具体来说：\n   - 引入一个严格为正的裁剪阈值 $\\epsilon$，使得变换中使用的任何均匀随机变量 $u_1$ 满足 $u_1 \\ge \\epsilon$，以避免出现未定义的对数和极端值。必须分析 $\\epsilon$ 的选择及其影响。\n   - 通过在裁剪前强制将 $u_1$ 的前 $K$ 次抽取值设为 $0$ 来实现可控的病态输入注入，以验证裁剪逻辑并量化其效果。\n   - 通过报告所有生成的速度分量是否为有限值，并报告最大分量绝对值（单位：m/s）来量化稳定性。\n\n4. 种子可复现性。使用一个伪随机数生成器 (PRNG)，其须由一个种子（seed）进行初始化，以保证可复现性。对于每个测试用例，通过使用相同种子生成两次速度分量，并使用不同种子生成一次，来展示可复现性。以布尔值形式报告精确相等性检查结果。\n\n5. 计算诊断。对于每个测试用例，计算并报告：\n   - 所有分量的样本绝对均值，单位为 m/s。\n   - 所有分量的样本方差与理论推导方差 $\\sigma^2$ 之间的相对误差（无量纲），计算公式为 $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$。\n   - 最大分量绝对值，单位为 m/s。\n   - 被裁剪的均匀分布随机数的数量，即在裁剪前有多少个 $u_1$ 低于 $\\epsilon$。\n   - 一个指示所有分量是否有限的布尔值。\n   - 一个指示使用相同种子的两次独立实现是否完全相等的布尔值。\n   - 一个指示使用不同种子的实现是否完全相等的布尔值。\n\n6. 测试套件。实现并运行以下具有科学依据的案例。使用氩原子质量 $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$。使用国际单位制 (SI)。对于每个案例，为每个原子生成三个速度分量（$x$, $y$, 和 $z$），所有分量单位均为 m/s。角度必须是弧度。\n   - 案例 A（正常路径）：$N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 314159265$, $\\epsilon = 10^{-12}$, $K = 0$。\n   - 案例 B（注入零值的稳定性压力测试）：$N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 271828182$, $\\epsilon = 10^{-16}$, $K = 1$。\n   - 案例 C（大 $N$ 可复现性）：$N = 500000$, $T = 1000\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 777$, $\\epsilon = 10^{-12}$, $K = 0$。\n   - 案例 D（边界条件，最小样本）：$N = 1$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, 种子 $= 42$, $\\epsilon = 10^{-12}$, $K = 0$。\n\n7. 最终输出格式。你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。其中每个测试用例的结果本身是一个列表，包含第 5 项中描述的七个条目，并按所述顺序排列。例如，打印的输出必须如下所示\n$[[\\text{float},\\text{float},\\text{float},\\text{int},\\text{bool},\\text{bool},\\text{bool}],[\\dots],\\dots]$\n不得有任何附加文本。\n\n解决方案必须是自包含的，并且无需用户输入即可运行。所有角度计算必须以弧度为单位。所有报告的速度必须以 $\\mathrm{m/s}$ 为单位，所有其他报告的量除非另有说明，否则必须是无量纲的。", "solution": "初始化原子速度是计算材料科学中的一项基础任务，特别是对于像分子动力学 (MD) 模拟这样的方法。其目标是为一个由 $N$ 个粒子组成的系统生成一组速度，这组速度在统计上与给定的热力学状态一致，特别是在温度为 $T$ 的正则系综下。该解决方案需要综合运用统计力学、概率论和数值方法的原理。\n\n### 1. 物理基础与目标分布\n\n该问题的物理基础在于经典统计力学。根据**能量均分定理**，在处于热平衡的系统中，与系统哈密顿量中每个二次自由度相关的平均能量等于 $\\frac{1}{2} k_{\\mathrm{B}} T$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n对于单原子气体，原子被视作质点。质量为 $m$ 的单个原子的动能 $E_k$ 由其沿三个笛卡尔轴的动能之和给出：\n$$ E_k = \\frac{1}{2} m v_x^2 + \\frac{1}{2} m v_y^2 + \\frac{1}{2} m v_z^2 $$\n系统的哈密顿量包含这三项，每一项都是速度分量（$v_x$, $v_y$, 或 $v_z$）的二次函数。因此，每一项都对应一个适用能量均分定理的自由度。对于任何给定的速度分量，比如 $v_i$（其中 $i \\in \\{x, y, z\\}$），其平均能量为：\n$$ \\left\\langle \\frac{1}{2} m v_i^2 \\right\\rangle = \\frac{1}{2} k_{\\mathrm{B}} T $$\n由于 $m$ 是一个常数，这可以简化为：\n$$ \\langle v_i^2 \\rangle = \\frac{k_{\\mathrm{B}} T}{m} $$\n**麦克斯韦-玻尔兹曼分布**描述了处于热平衡状态的气体中粒子速度的分布。该分布的一个关键推论是，单个速度分量 $v_i$ 的概率分布是一个高斯（或正态）分布。概率密度函数 $p(v_i)$ 正比于玻尔兹曼因子 $\\exp(-E_i / (k_{\\mathrm{B}}T))$，其中 $E_i = \\frac{1}{2} m v_i^2$。\n$$ p(v_i) \\propto \\exp\\left(-\\frac{m v_i^2}{2 k_{\\mathrm{B}} T}\\right) $$\n这是零均值高斯分布的函数形式。平均速度 $\\langle v_i \\rangle$ 必须为零，因为在一个简单的平衡状态下，气体在任何方向上都没有净漂移。\n\n速度分量 $v_i$ 的方差 $\\sigma_{v_i}^2$ 定义为 $\\sigma_{v_i}^2 = \\langle (v_i - \\langle v_i \\rangle)^2 \\rangle$。由于 $\\langle v_i \\rangle = 0$，方差就是 $\\sigma_{v_i}^2 = \\langle v_i^2 \\rangle$。根据我们的能量均分结果，我们已经推导出了理论方差：\n$$ \\sigma^2 \\equiv \\sigma_{v_i}^2 = \\frac{k_{\\mathrm{B}} T}{m} $$\n此外，速度分量 $v_x$、$v_y$ 和 $v_z$ 是统计独立的。因此，每个原子的每个速度分量 $v_i$ 都必须从一个独立的、相同的正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取，其均值为 $\\mu=0$，方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$。\n\n### 2. 用于生成正态随机数的概率变换\n\n要从目标分布 $\\mathcal{N}(0, \\sigma^2)$ 中生成一个随机变量 $v_i$，我们可以首先生成一个标准正态随机数 $Z \\sim \\mathcal{N}(0, 1)$，然后对其进行缩放：$v_i = \\sigma Z$。挑战在于如何从我们能轻易产生的随机源（通常是区间 $(0,1)$ 上的均匀随机数）生成标准正态随机数。**Box-Muller 变换**提供了一种将两个独立的均匀随机变量转换为两个独立标准正态随机变量的方法。我们从第一性原理推导此方法。\n\n设 $U_1$ 和 $U_2$ 是从 $(0,1)$ 上的均匀分布中抽取的两个独立随机变量。我们寻求一个变换 $(Z_1, Z_2) = g(U_1, U_2)$，使得 $Z_1$ 和 $Z_2$ 是独立的标准正态变量。$(Z_1, Z_2)$ 的联合概率密度函数 (PDF) 是它们各自 PDF 的乘积：\n$$ p(z_1, z_2) = p(z_1)p(z_2) = \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_1^2/2}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_2^2/2}\\right) = \\frac{1}{2\\pi} e^{-(z_1^2 + z_2^2)/2} $$\n通过变换到极坐标 $(R, \\Theta)$（其中 $Z_1 = R\\cos\\Theta$ 和 $Z_2 = R\\sin\\Theta$），推导过程会变得更容易。半径的平方是 $R^2 = Z_1^2 + Z_2^2$。极坐标下的联合 PDF 可以通过使用变换的雅可比行列式 $R$ 来找到：$p(r, \\theta) dr d\\theta = p(z_1,z_2) dz_1 dz_2$。\n$$ p(r, \\theta) = \\frac{1}{2\\pi} e^{-r^2/2} \\cdot r $$\n这个联合 PDF 可以分离为 $p(r,\\theta) = (\\frac{1}{2\\pi}) \\cdot (r e^{-r^2/2})$。这表明角度 $\\Theta$ 在 $[0, 2\\pi]$ 上均匀分布，并且与半径 $R$ 独立。\n\n因此，我们可以通过一个简单的线性映射从我们的一个均匀随机数（比如 $U_2$）生成 $\\Theta$：\n$$ \\Theta = 2\\pi U_2 $$\n为了生成 $R$，我们使用逆变换采样技术。我们首先找到随机变量 $S=R^2$ 的累积分布函数 (CDF)。$R$ 的 PDF 是 $p_R(r) = \\int_0^{2\\pi} p(r,\\theta) d\\theta = r e^{-r^2/2}$（对于 $r \\ge 0$）。$R$ 的 CDF 是 $F_R(r) = \\int_0^r s e^{-s^2/2} ds = 1-e^{-r^2/2}$。那么 $S=R^2$ 对于某个值 $s_0 \\ge 0$ 的 CDF 是 $F_S(s_0)=P(S \\le s_0) = P(R^2 \\le s_0) = P(R \\le \\sqrt{s_0}) = F_R(\\sqrt{s_0}) = 1 - e^{-s_0/2}$。这是一个速率参数为 $\\lambda=1/2$ 的指数分布的 CDF。\n通过逆变换采样，我们可以通过将其 CDF 设置为一个均匀随机数（比如 $U_1$）来生成一个随机数 $S$：\n$$ U_1 = F_S(S) = 1 - e^{-S/2} $$\n解出 $S$：$e^{-S/2} = 1 - U_1$，得到 $S = -2 \\ln(1 - U_1)$。由于 $U_1$ 在 $(0,1)$ 上是均匀的，变量 $1-U_1$ 也在 $(0,1)$ 上均匀分布。因此，我们可以直接使用 $U_1$ 来简化表达式：\n$$ S = R^2 = -2 \\ln(U_1) $$\n结合我们对 $R$ (即 $\\sqrt{S}$) 和 $\\Theta$ 的结果，我们可以变换回 $Z_1$ 和 $Z_2$ 的笛卡尔坐标：\n$$ Z_1 = R \\cos\\Theta = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2) $$\n$$ Z_2 = R \\sin\\Theta = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2) $$\n这对​​方程构成了 Box-Muller 变换。\n\n### 3. 数值实现策略\n\n生成 $3N$ 个速度分量的总体算法如下：\n1. 确定所需的随机数对的数量，即 $\\lceil 3N/2 \\rceil$。\n2. 使用一个由特定种子初始化的伪随机数生成器 (PRNG) 生成 $2 \\times \\lceil 3N/2 \\rceil$ 个均匀随机数，用于可复现性。将它们组织成对 $(U_1, U_2)$。\n3. Box-Muller 变换中的 $\\ln(U_1)$ 项在 $U_1=0$ 时未定义，并且当 $U_1 \\to 0^+$ 时发散到 $-\\infty$。这可能导致浮点溢出 (`Inf`) 或 `NaN` 值。为确保数值稳定性，我们引入一个裁剪阈值 $\\epsilon > 0$ 并强制 $U_1 \\ge \\epsilon$。任何生成的 $U_1  \\epsilon$ 都将被替换为 $\\epsilon$。此过程限制了生成速度的大小。我们必须计算此裁剪被激活的次数。\n4. 为了验证裁剪机制，我们可以通过在应用裁剪之前强制将 $U_1$ 的前 $K$ 次抽取值设为 $0$ 来注入病态输入。\n5. 对于每对 $(U_1, U_2)$，使用推导出的 Box-Muller 公式计算相应的标准正态随机数对 $(Z_1, Z_2)$。\n6. 将所有生成的 $Z$ 值收集到一个数组中，并将其截断到所需的 $3N$ 大小。\n7. 将每个标准正态随机数 $Z_i$ 乘以标准差 $\\sigma = \\sqrt{k_{\\mathrm{B}} T / m}$，以产生最终的速度分量 $v_i = \\sigma Z_i$。\n\n### 4. 可复现性与诊断\n\n使用具有指定种子的 PRNG 可确保“随机”数序列是确定性的，并且可以被精确复现。我们通过使用相同种子运行两次生成过程，并使用不同种子运行一次来验证这一点，检查所得速度数组是否完全相等。\n\n为了评估生成数据的质量和稳定性，我们为每个测试用例计算几个诊断指标：\n1. **样本绝对均值**：应接近理论均值 $0$。\n2. **相对方差误差**：将所有 $3N$ 个分量的样本方差 $\\hat{\\sigma}^2$ 与理论方差 $\\sigma^2$ 进行比较，公式为 $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$。对于大的 $N$，这个值应该很小。\n3. **最大分量绝对值**：提供了分布“尾部”的度量，并直接受 $U_1$ 裁剪的影响。\n4. **被裁剪的随机数数量**：量化数值稳定性程序的影响。\n5. **有限性检查**：一个布尔值，用于确认没有产生 `Inf` 或 `NaN` 值。\n6. **可复现性检查**：确认相同种子产生相同结果、不同种子产生不同结果的布尔值。\n\n这些步骤为模拟中的原子速度初始化提供了一个完整的、物理和数学上合理的程序，并包含了验证和鲁棒性检查。", "answer": "```python\nimport numpy as np\n\ndef generate_velocities(N, T, m, seed, epsilon, K):\n    \"\"\"\n    Generates atomic velocity components based on the Maxwell-Boltzmann distribution.\n\n    Args:\n        N (int): Number of atoms.\n        T (float): Temperature in Kelvin.\n        m (float): Mass of one atom in kg.\n        seed (int): Seed for the Pseudorandom Number Generator (PRNG).\n        epsilon (float): Clipping threshold for uniform variates.\n        K (int): Number of pathological zero inputs to inject for u1.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: An array of 3*N velocity components (m/s).\n            - int: The number of clipped u1 variates.\n    \"\"\"\n    num_components = 3 * N\n    if num_components == 0:\n        return np.array([]), 0\n\n    # Number of pairs needed for Box-Muller transform\n    num_pairs = (num_components + 1) // 2\n\n    # Initialize a Pseudorandom Number Generator (PRNG) for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Generate uniform variates on (0, 1). Using 'low=np.finfo(float).tiny'\n    # is a robust way to avoid true zeros, but the problem requires\n    # handling zeros explicitly via clipping. So we use low=0.0.\n    u1 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n    u2 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n\n    # Inject K pathological inputs (force first K draws of u1 to zero)\n    if K > 0:\n        u1[:K] = 0.0\n\n    # Count how many u1 values are below the threshold *before* clipping\n    clipped_count = np.sum(u1  epsilon)\n\n    # Apply clipping to avoid log(0)\n    u1 = np.maximum(u1, epsilon)\n\n    # Box-Muller transform to get standard normal variates\n    mag = np.sqrt(-2.0 * np.log(u1))\n    z1 = mag * np.cos(2.0 * np.pi * u2)\n    z2 = mag * np.sin(2.0 * np.pi * u2)\n\n    # Interleave the pairs of standard normals into a single array\n    std_normals = np.empty(num_pairs * 2, dtype=float)\n    std_normals[0::2] = z1\n    std_normals[1::2] = z2\n\n    # Trim to the exact number of components required\n    std_normals = std_normals[:num_components]\n\n    # Scale by sigma = sqrt(k_B * T / m) to get final velocities\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    sigma = np.sqrt((k_B * T) / m)\n    velocities = std_normals * sigma\n\n    return velocities, int(clipped_count)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    m_Ar = 6.6335209e-26  # Mass of Argon atom in kg\n\n    test_cases = [\n        # N, T, m, seed, epsilon, K\n        (100000, 300.0, m_Ar, 314159265, 1e-12, 0),  # Case A\n        (100000, 300.0, m_Ar, 271828182, 1e-16, 1),  # Case B\n        (500000, 1000.0, m_Ar, 777, 1e-12, 0),      # Case C\n        (1, 300.0, m_Ar, 42, 1e-12, 0),              # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, T, m, seed, epsilon, K = case\n        k_B = 1.380649e-23\n\n        # Generate primary set of velocities\n        v_main, clips = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate again with same seed for reproducibility check\n        v_redux, _ = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate with a different seed for reproducibility check\n        v_other, _ = generate_velocities(N, T, m, seed + 1, epsilon, K)\n\n        # 1. Absolute sample mean\n        abs_sample_mean = np.abs(np.mean(v_main)) if v_main.size  0 else 0.0\n\n        # 2. Relative variance error\n        if v_main.size  1:\n            sample_variance = np.var(v_main)\n            theoretical_variance = (k_B * T) / m\n            relative_error_var = (sample_variance - theoretical_variance) / theoretical_variance\n        else:\n            # Variance is not well-defined for a single point, but np.var returns 0.\n            # Avoid division by zero, report a non-sensical but defined value.\n            relative_error_var = 0.0 if N == 0 else -1.0 # By definition, a single point sample has 0 variance. \n\n        # 3. Maximum absolute component magnitude\n        max_abs_mag = np.max(np.abs(v_main)) if v_main.size  0 else 0.0\n        \n        # 4. Count of clipped uniform variates\n        clipped_count = clips\n\n        # 5. Boolean indicating if all components are finite\n        all_finite = np.all(np.isfinite(v_main))\n\n        # 6. Boolean for same-seed equality\n        same_seed_equal = np.array_equal(v_main, v_redux)\n\n        # 7. Boolean for different-seed equality\n        diff_seed_equal = np.array_equal(v_main, v_other)\n        \n        case_results = [\n            abs_sample_mean,\n            relative_error_var,\n            max_abs_mag,\n            clipped_count,\n            all_finite,\n            same_seed_equal,\n            diff_seed_equal\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res_list in all_results:\n        # Convert each item to its string representation\n        # For booleans, Python's str() produces 'True'/'False' which needs to be lowercase.\n        str_items = [str(item).lower() if isinstance(item, bool) else str(item) for item in res_list]\n        case_strings.append(f\"[{','.join(str_items)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3458384"}, {"introduction": "为非晶或液体系统生成初始原子位置是一个核心挑战，因为我们需要一个无序但物理上合理的构型。随机顺序吸积 (Random Sequential Addition, RSA) 算法是一种直观而有效的方法，它通过逐个放置粒子并强制实施最小间距（硬核排斥）来构建无序结构。这个练习 [@problem_id:3458396] 将指导你实现RSA算法，并应用单元格列表等加速策略，同时探索堆积密度极限等理论概念，这些都是生成非晶态材料初始构型的关键技能。", "problem": "您的任务是设计并实现一个有原则的算法，该算法使用带硬核排斥半径的随机顺序添加（RSA）方法，在周期性立方体盒子中为单原子非晶结构初始化原子位置和速度。对于每个测试用例，您的程序必须尝试放置预定数量的原子，同时强制执行严格的最小中心距，然后初始化与目标热力学温度一致的速度。\n\n使用的基本原理包括：牛顿运动定律、速度的定义 $v = dx/dt$、能量均分定理（即每个二次自由度的平均动能等于 $\\tfrac{1}{2} k_{\\mathrm{B}} T$），以及关于麦克斯韦-玻尔兹曼统计和RSA饱和覆盖率的公认物理事实。您必须从这些基本原理推导出您使用的所有公式。\n\n定义和要求：\n\n- 系统是一个边长为 $L$ 的立方体盒子，具有周期性边界条件。所有长度必须以米（m）为单位表示。\n- 目标质量密度为 $\\rho_{\\mathrm{m}}$（单位为 $\\mathrm{kg/m^3}$）。原子质量为 $m_{\\mathrm{u}}$（单位为统一原子质量单位），转换关系为 $m = m_{\\mathrm{u}} \\, m_{u}$，其中 $m_{u} = 1.66053906660 \\times 10^{-27} \\,\\mathrm{kg}$。\n- 原子数 $N$ 是一个整数，由盒子体积 $V = L^3$ 和质量密度计算得出：$N = \\mathrm{round}\\!\\left(\\dfrac{\\rho_{\\mathrm{m}} V}{m}\\right)$。\n- 位置通过RSA进行初始化：在 $[0,L)^3$ 范围内均匀地提出一个随机位置，如果其与每个先前已接受原子的最小镜像距离（使用周期性边界条件）至少为硬核排斥参数 $r_0$（单位为米），则接受该位置，否则拒绝并重试。您可以为每个原子设置尝试次数上限。\n- 程序必须使用最小镜像约定：对于任何位移分量 $\\Delta x$，在计算欧几里得距离之前，应用 $\\Delta x \\leftarrow \\Delta x - L \\,\\mathrm{round}(\\Delta x/L)$ 来强制执行周期性。\n- 速度根据温度为 $T$（单位为开尔文）、质量为 $m$ 的单原子粒子的麦克斯韦-玻尔兹曼分布进行初始化，即每个笛卡尔分量独立服从均值为零、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的正态分布，其中 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。通过减去质心速度来强制实现零净动量，然后利用能量均分定理对可用自由度重新缩放速度，以精确匹配目标温度。\n- 移除质心运动后的瞬时温度计算如下\n$$\nT_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}, \\quad K = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2, \\quad f = 3N-3.\n$$\n通过一个统一的标量因子重新缩放所有速度，使得 $T_{\\mathrm{inst}}$ 等于目标温度 $T$；报告重新缩放后的绝对温度误差 $|T_{\\mathrm{inst}} - T|$，单位为开尔文。\n- 堆积分数的定义是将每个原子视为半径为 $r_0/2$ 的硬球，因此单个球体的体积为 $v_{\\mathrm{s}}(r_0) = \\dfrac{\\pi}{6} r_0^3$。任何给定构型所实现的堆积分数为\n$$\n\\phi = \\frac{N \\, v_{\\mathrm{s}}(r_0)}{V}.\n$$\n所有堆积分数均表示为无量纲浮点数。\n- 从数密度 $\\rho = N/V$ 和硬核排斥模型出发，量化预期堆积分数作为 $r_0$ 的函数。在三维相同球体的无限系统RSA极限下，公认的饱和堆积分数约为 $\\phi_{\\mathrm{sat}} \\approx 0.382$。因此，对于任何给定的 $r_0$，定义预期堆积分数函数\n$$\n\\phi_{\\mathrm{exp}}(r_0) = \\min\\!\\left( \\rho \\, v_{\\mathrm{s}}(r_0), \\, \\phi_{\\mathrm{sat}} \\right).\n$$\n同时定义相应的饱和原子数容量\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor,\n$$\n该值必须在尝试RSA之前用于确定可行性：如果 $N  N_{\\max}(r_0)$，则对于RSA而言，该放置在原则上是不可行的，您的算法必须在不尝试放置的情况下返回失败。\n\n您的程序必须为每个测试用例执行以下操作：\n\n1. 给定输入 $L$、$\\rho_{\\mathrm{m}}$、$m_{\\mathrm{u}}$、$r_0$、$T$ 以及每个原子的最大RSA尝试次数（整数），计算 $N$ 并使用上述 $N_{\\max}(r_0)$ 检查可行性。\n2. 如果可行，使用空间单元列表加速策略尝试在周期性边界条件下进行RSA。如果在尝试次数预算内放置了所有 $N$ 个原子，则报告成功；否则报告失败。\n3. 按照所述方法在温度 $T$ 下初始化速度，强制实现零质心动量，基于能量均分定理重新缩放以达到目标温度，并计算重新缩放后的绝对温度误差 $|T_{\\mathrm{inst}}-T|$（单位为开尔文）。\n4. 如果放置成功，计算实现的堆积分数 $\\phi$；否则，报告 $\\phi = -1.0$。\n5. 计算上面定义的预期堆积分数 $\\phi_{\\mathrm{exp}}(r_0)$。\n\n为保证可复现性，请使用以下固定随机种子：$s = 2025$。\n\n测试套件：\n\n请提供以下三个案例的结果，全部使用国际单位制（SI）。所有常数和结果必须使用指定的单位：\n\n- 案例A（正常路径）：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.2 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 5000$。\n- 案例B（接近饱和但可行）：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.25 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 15000$。\n- 案例C（因RSA饱和界限而不可行）：\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$，\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$，\n  - $m_{\\mathrm{u}} = 26.9815385$，\n  - $r_0 = 2.35 \\times 10^{-10} \\,\\mathrm{m}$，\n  - $T = 300 \\,\\mathrm{K}$，\n  - 每个原子的尝试次数 $= 2000$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个包含三个结果的列表，每个测试用例一个，中间没有空格。每个测试用例的结果本身必须是一个包含四个条目的列表，顺序如下：\n- 成功指示符，1（成功）或0（失败），\n- 实现的堆积分数 $\\phi$，为浮点数，四舍五入到六位小数（失败时使用-1.000000），\n- 预期的堆积分数 $\\phi_{\\mathrm{exp}}$，为浮点数，四舍五入到六位小数，\n- 绝对温度误差 $|T_{\\mathrm{inst}}-T|$，单位为开尔文，四舍五入到六位小数。\n\n例如，整体格式必须类似于\n$[\\,[1,0.123456,0.120000,0.000000],[\\dots],[\\dots]\\,]$\n并替换为您计算出的三个条目。", "solution": "该问题要求设计并实现一个算法，用于在周期性立方体域内为单原子非晶结构的模拟初始化位置和速度。该过程涉及多个基于计算物理和统计力学的步骤，详述如下。\n\n首先，我们确定系统的基本参数。给定立方体盒子的边长 $L$，其体积为 $V = L^3$。单个原子的质量 $m$ 由其以统一原子质量单位表示的质量 $m_{\\mathrm{u}}$ 和转换因子 $m_{u}$ 计算得出，即 $m = m_{\\mathrm{u}} m_{u}$。给定目标质量密度 $\\rho_{\\mathrm{m}}$，盒子中的总质量为 $\\rho_{\\mathrm{m}} V$。然后，原子数 $N$ 通过总质量与单原子质量之比取最接近的整数来确定：\n$$\nN = \\mathrm{round}\\!\\left(\\frac{\\rho_{\\mathrm{m}} V}{m}\\right)\n$$\n\n第二步是使用随机顺序添加（RSA）生成原子位置。这是一个迭代过程，原子被逐一添加到体积中。候选位置 $\\mathbf{r}_{\\mathrm{new}}$ 从盒子内的均匀随机分布中生成，即每个坐标 $x, y, z$ 都在 $[0, L)$ 范围内。只有当新原子不与任何先前放置的原子重叠时，该位置才会被接受。非重叠条件由硬核排斥半径 $r_0$ 强制执行，意味着任何两个原子之间的中心距必须至少为 $r_0$。由于系统具有周期性边界条件（PBC），该距离必须使用最小镜像约定（MIC）计算。对于任意两个位置矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$，它们的位移矢量为 $\\Delta\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$。MIC调整此矢量的每个分量，例如 $\\Delta x$，调整为 $\\Delta x_{\\mathrm{mic}} = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$。然后，平方距离为 $d^2 = \\Delta x_{\\mathrm{mic}}^2 + \\Delta y_{\\mathrm{mic}}^2 + \\Delta z_{\\mathrm{mic}}^2$。如果对于所有先前放置的原子，都有 $d \\ge r_0$，则接受新位置。\n\n对每个新原子与所有现有原子进行暴力距离检查的计算成本很高，复杂度为 $O(N^2)$。为了加速这一过程，采用了单元列表数据结构。模拟盒子被划分为一个由更小的立方单元组成的网格，每个单元的边长至少为 $r_0$。要检查一个候选位置，我们只需要计算它与自身所在单元及相邻26个单元中原子的距离。这将搜索复杂度降低到 $O(N)$。\n\nRSA无法实现任意高的堆积密度。对于三维空间中的相同球体，存在一个理论上的饱和堆积分数 $\\phi_{\\mathrm{sat}} \\approx 0.382$。在尝试放置之前，我们进行可行性检查。单个硬球的体积为 $v_{\\mathrm{s}}(r_0) = \\frac{\\pi}{6} r_0^3$。通过RSA可以放置的最大原子数 $N_{\\max}$ 受此饱和密度的限制：\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor\n$$\n如果目标原子数 $N$ 超过 $N_{\\max}(r_0)$，则该放置被先验地认为是不可行的。如果尝试放置但失败（由于超过了每个原子的有限尝试次数），或者被认为是不可行的，则实现的堆积分数 $\\phi$ 报告为 $-1.0$。如果成功，$\\phi$ 计算为所有原子的总体积除以盒子体积：\n$$\n\\phi = \\frac{N v_{\\mathrm{s}}(r_0)}{V}\n$$\n预期的堆积分数 $\\phi_{\\mathrm{exp}}(r_0)$ 定义为目标数密度 $\\rho = N/V$ 所隐含的堆积分数与饱和极限中的较小者：$\\phi_{\\mathrm{exp}}(r_0) = \\min(\\rho v_{\\mathrm{s}}(r_0), \\phi_{\\mathrm{sat}})$。\n\n第三，在成功放置所有 $N$ 个原子后，分配它们的初始速度。根据统计力学中处于温度 $T$ 的热平衡系统的能量均分定理，每个二次自由度的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T$。对于单原子粒子，有三个平移自由度。这意味着每个速度分量（$v_x, v_y, v_z$）都遵循均值为零、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的高斯（正态）分布。我们从该分布中生成 $3N$ 个随机数，以创建一组初始速度 $\\{\\mathbf{v}_i\\}$。\n\n为确保系统整体没有净漂移（即总动量守恒于零），计算质心速度 $\\mathbf{v}_{\\mathrm{CM}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i$ 并从每个原子的速度中减去：$\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{CM}}$。这个约束从系统中移除了3个自由度，剩下 $f = 3N-3$ 个独立自由度。\n\n最后，对速度进行重新缩放，以确保系统的瞬时温度精确匹配目标温度 $T$。瞬时温度 $T_{\\mathrm{inst}}$ 通过总动能 $K$ 定义：\n$$\nK = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}'_i \\rVert^2, \\quad T_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}\n$$\n由于初始速度生成的统计性质，$T_{\\mathrm{inst}}$ 会接近但不会精确等于 $T$。为了修正这一点，所有速度矢量都乘以一个因子 $\\lambda = \\sqrt{T / T_{\\mathrm{inst}}}$。最终的速度为 $\\mathbf{v}''_i = \\lambda \\mathbf{v}'_i$。根据构造，由这些重新缩放的速度计算出的温度将精确为 $T$，绝对误差 $|T_{\\mathrm{final}} - T|$ 应该仅由于浮点精度限制而不为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation setup for all test cases and print results.\n    \"\"\"\n    # Define physical constants\n    M_U = 1.66053906660e-27  # Unified atomic mass unit in kg\n    K_B = 1.380649e-23       # Boltzmann constant in J/K\n    PHI_SAT = 0.382          # RSA saturation packing fraction for 3D spheres\n    \n    # Global random number generator for reproducibility\n    RNG = np.random.default_rng(2025)\n\n    test_cases = [\n        # Case A (happy path)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.2e-10, 'T': 300, 'trials_per_atom': 5000},\n        # Case B (near saturation)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.25e-10, 'T': 300, 'trials_per_atom': 15000},\n        # Case C (infeasible)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.35e-10, 'T': 300, 'trials_per_atom': 2000},\n    ]\n\n    def solve_case(L, rho_m, m_u, r_0, T, trials_per_atom):\n        \"\"\"\n        Solves a single test case for atomic position and velocity initialization.\n        \"\"\"\n        # 1. Calculate system parameters\n        V = L**3\n        m = m_u * M_U\n        N = int(round((rho_m * V) / m))\n        v_s = (np.pi / 6) * r_0**3\n        r_0_sq = r_0**2\n\n        # 2. Feasibility check and expected packing fraction\n        phi_exp = min((N / V) * v_s, PHI_SAT)\n        if v_s  0:\n            N_max = np.floor((PHI_SAT * V) / v_s)\n        else:\n            N_max = float('inf')\n\n        if N  N_max:\n            return 0, -1.0, phi_exp, 0.0\n\n        # 3. RSA Position Initialization with Cell-List Acceleration\n        positions = np.zeros((N, 3))\n        \n        # If N=0, placement is trivially successful\n        if N == 0:\n             return 1, 0.0, phi_exp, 0.0\n\n        n_cells = int(np.floor(L / r_0))\n        if n_cells  1: # r_0 >= L, can't place more than 1 atom\n            if N > 1:\n                return 0, -1.0, phi_exp, 0.0\n            else: # N=1, this will succeed on first try, no neighbors to check\n                positions[0] = RNG.uniform(0, L, size=3)\n                success = 1\n                phi_achieved = (N * v_s) / V\n                # continue to velocity initialization\n        else: # Standard RSA with cell list\n            cell_size = L / n_cells\n            cells = {}\n            success = 0\n            \n            for i in range(N):\n                placed_atom = False\n                for _ in range(trials_per_atom):\n                    pos_new = RNG.uniform(0, L, size=3)\n                    cell_coords = tuple(np.floor(pos_new / cell_size).astype(int))\n                    \n                    conflict = False\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            for dk in [-1, 0, 1]:\n                                nc_x = (cell_coords[0] + di + n_cells) % n_cells\n                                nc_y = (cell_coords[1] + dj + n_cells) % n_cells\n                                nc_z = (cell_coords[2] + dk + n_cells) % n_cells\n                                neighbor_cell = (nc_x, nc_y, nc_z)\n                                \n                                if neighbor_cell in cells:\n                                    for other_idx in cells[neighbor_cell]:\n                                        delta = pos_new - positions[other_idx]\n                                        delta -= L * np.round(delta / L)\n                                        dist_sq = np.sum(delta**2)\n                                        if dist_sq  r_0_sq:\n                                            conflict = True\n                                            break\n                                if conflict: break\n                            if conflict: break\n                        if conflict: break\n                    \n                    if not conflict:\n                        positions[i] = pos_new\n                        if cell_coords not in cells:\n                            cells[cell_coords] = []\n                        cells[cell_coords].append(i)\n                        placed_atom = True\n                        break\n                \n                if not placed_atom:\n                    return 0, -1.0, phi_exp, 0.0\n\n            success = 1\n            phi_achieved = (N * v_s) / V\n\n        # 4. Velocity Initialization\n        if N > 1 :\n            sigma_v = np.sqrt(K_B * T / m)\n            velocities = RNG.normal(loc=0.0, scale=sigma_v, size=(N, 3))\n            \n            # Remove CoM velocity\n            v_com = np.mean(velocities, axis=0)\n            velocities -= v_com\n\n            # Rescale to target temperature\n            f = 3 * N - 3\n            K_current = 0.5 * m * np.sum(velocities**2)\n            \n            # T_inst can be zero if all velocities happen to be zero after CoM removal\n            if K_current  1e-30:\n                T_inst = 0.0\n            else:\n                T_inst = (2 * K_current) / (f * K_B)\n            \n            if T_inst > 1e-15:\n                scaling_factor = np.sqrt(T / T_inst)\n                velocities *= scaling_factor\n            \n            # Final temperature check\n            K_final = 0.5 * m * np.sum(velocities**2)\n            T_final = (2 * K_final) / (f * K_B)\n            temp_err = abs(T_final - T)\n        else:\n            temp_err = 0.0 # No kinetic energy to scale for N=1 \n\n        return success, phi_achieved, phi_exp, temp_err\n\n    all_results = []\n    for case_params in test_cases:\n        res_tuple = solve_case(\n            L=case_params['L'],\n            rho_m=case_params['rho_m'],\n            m_u=case_params['m_u'],\n            r_0=case_params['r_0'],\n            T=case_params['T'],\n            trials_per_atom=case_params['trials_per_atom']\n        )\n        all_results.append(res_tuple)\n    \n    # Format the final output string exactly as required\n    result_strings = []\n    for res in all_results:\n        success, phi, phi_exp, temp_err = res\n        result_strings.append(f\"[{success},{phi:.6f},{phi_exp:.6f},{temp_err:.6f}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3458396"}, {"introduction": "在创建固溶体（合金）的初始构型时，简单地随机替换主晶格中的原子可能会导致非物理性的原子团簇。一个更合理的方法是生成一个尽可能均匀的溶质分布。这个练习 [@problem_id:3458372] 将此任务构建为一个优化问题：在满足特定组分的前提下，最大化溶质原子之间的最小间距。通过实现一个基于最远点采样的贪心算法，你将学习如何为合金模拟生成一个更加均匀和物理上合理的初始原子排布。", "problem": "考虑一个主晶体，其模型为具有周期性边界条件的简立方晶格。该晶格沿笛卡尔坐标轴方向分别有 $N_x$、$N_y$ 和 $N_z$ 个晶胞，每个晶胞的晶格参数为 $a$ (单位为埃)。晶格点位总数为 $N = N_x N_y N_z$，每个点位的位置矢量为 $\\mathbf{r} = a (i, j, k)$，其中 $i \\in \\{0, 1, \\dots, N_x - 1\\}$，$j \\in \\{0, 1, \\dots, N_y - 1\\}$ 且 $k \\in \\{0, 1, \\dots, N_z - 1\\}$。假设我们希望通过选择恰好 $M$ 个不同的晶格点位来初始化溶质原子的位置，其中 $M$ 由溶质组分 $x_s$ 通过规则 $M = \\mathrm{round}(x_s N)$ 决定，并且约定 $2 \\le M \\le N$。\n\n目标是通过在周期性边界条件下最大化所选溶质点位之间的最小成对距离，以避免团簇现象。令周期性边界条件下两个位置 $\\mathbf{r}_p$ 和 $\\mathbf{r}_q$ 之间的欧几里得距离由最小镜像约定 (MIC) 定义。将模拟盒子的边长表示为 $\\mathbf{L} = (L_x, L_y, L_z) = (a N_x, a N_y, a N_z)$。对于任意位移矢量 $\\Delta \\mathbf{r} = \\mathbf{r}_q - \\mathbf{r}_p$，其最小镜像位移为\n$$\n\\Delta \\mathbf{r}_\\mathrm{MIC} = \\Delta \\mathbf{r} - \\mathbf{L} \\circ \\mathrm{round}\\!\\left(\\frac{\\Delta \\mathbf{r}}{\\mathbf{L}}\\right),\n$$\n其中 $\\circ$ 表示逐分量乘法，距离为 $d(\\mathbf{r}_p, \\mathbf{r}_q) = \\left\\|\\Delta \\mathbf{r}_\\mathrm{MIC}\\right\\|_2$。对于一个选定的索引集合 $\\mathcal{S} \\subset \\{0, 1, \\dots, N-1\\}$ 且 $|\\mathcal{S}| = M$，目标是最大化\n$$\n\\min_{\\substack{p, q \\in \\mathcal{S} \\\\ p \\ne q}} d(\\mathbf{r}_p, \\mathbf{r}_q).\n$$\n\n从基本原理出发，构建用于选择 $M$ 个晶格点位以在最小镜像约定下最大化最小成对距离的优化问题，并设计一个基于特定原理的算法，为中等规模的 $N$ 构建一个计算上可行的近似解。您的程序必须：\n\n1. 实现如上定义的最小镜像约定距离。\n2. 使用一种有合理依据的方法（不依赖于特定领域的快捷公式）构建一个大小为 $M$ 的候选溶质集 $\\mathcal{S}$，该方法旨在最大化最小成对距离。\n3. 计算所选溶质点位之间实现的最小成对距离，以埃为单位表示。\n4. 使用可复现的随机种子来打破平局和初始化过程，每个测试用例会提供一个种子。\n\n物理单位：所有距离必须以埃为单位表示，并报告为四舍五入到五位小数的浮点数。\n\n角度单位：不涉及角度。\n\n百分比：组分 $x_s$ 以小数形式给出，必须直接使用。\n\n您的程序应处理以下测试套件，其中每个案例提供 $(N_x, N_y, N_z, a, x_s, \\text{seed})$：\n\n- 案例 1：$N_x = 3$, $N_y = 3$, $N_z = 3$, $a = 3.6$, $x_s = 0.148$, $\\text{seed} = 42$。\n- 案例 2：$N_x = 5$, $N_y = 5$, $N_z = 5$, $a = 2.5$, $x_s = 0.1$, $\\text{seed} = 123$。\n- 案例 3：$N_x = 6$, $N_y = 2$, $N_z = 2$, $a = 2.0$, $x_s = 0.25$, $\\text{seed} = 7$。\n- 案例 4：$N_x = 4$, $N_y = 4$, $N_z = 4$, $a = 1.0$, $x_s = 0.5$, $\\text{seed} = 2023$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应测试用例实现的最小成对距离（单位为埃），四舍五入到五位小数。例如，您的程序必须精确打印一行形如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$ 的内容，不得包含任何额外文本。", "solution": "为避免团簇而放置溶质原子的问题，可以转化为一个在周期性边界条件下对晶格点位进行的离散最大最小化优化问题。其基础是由最小镜像约定 (MIC) 导出的几何度量，该约定通过将任何位移映射到模拟盒子内的最近等效位置来施加周期性。\n\n我们首先定义简立方晶格。晶格点位的总数为 $N = N_x N_y N_z$。每个晶格点位都可以通过一个三元组 $(i, j, k)$ 进行索引，其中 $i \\in \\{0, 1, \\dots, N_x - 1\\}$，$j \\in \\{0, 1, \\dots, N_y - 1\\}$ 且 $k \\in \\{0, 1, \\dots, N_z - 1\\}$。对应的笛卡尔坐标为 $\\mathbf{r} = a (i, j, k)$，它通过晶格参数 $a$（单位为埃）将离散索引与物理坐标联系起来。模拟盒子的边长为 $\\mathbf{L} = (L_x, L_y, L_z) = (a N_x, a N_y, a N_z)$。\n\n最小镜像约定 (MIC) 是模拟周期性边界条件的核心。对于任意两个位置 $\\mathbf{r}_p$ 和 $\\mathbf{r}_q$，我们定义位移 $\\Delta \\mathbf{r} = \\mathbf{r}_q - \\mathbf{r}_p$。MIC 将此矢量映射为\n$$\n\\Delta \\mathbf{r}_\\mathrm{MIC} = \\Delta \\mathbf{r} - \\mathbf{L} \\circ \\mathrm{round}\\!\\left(\\frac{\\Delta \\mathbf{r}}{\\mathbf{L}}\\right),\n$$\n其中逐分量操作确保每个坐标都被包裹到最近的周期性镜像。物理上相关的间距即为欧几里得范数\n$$\nd(\\mathbf{r}_p, \\mathbf{r}_q) = \\left\\|\\Delta \\mathbf{r}_\\mathrm{MIC}\\right\\|_2 = \\sqrt{\\sum_{\\alpha \\in \\{x, y, z\\}} \\left(\\Delta r_{\\alpha} - L_{\\alpha} \\, \\mathrm{round}\\!\\left(\\frac{\\Delta r_{\\alpha}}{L_{\\alpha}}\\right)\\right)^2}.\n$$\n\n该优化问题可以表述为：选择一个子集 $\\mathcal{S} \\subset \\{0, 1, \\dots, N-1\\}$ 且 $|\\mathcal{S}| = M$，使得目标函数\n$$\nf(\\mathcal{S}) = \\min_{\\substack{p, q \\in \\mathcal{S} \\\\ p \\ne q}} d(\\mathbf{r}_p, \\mathbf{r}_q)\n$$\n被最大化。这是一个在由 MIC 导出的度量空间 $(\\{\\mathbf{r}_i\\}, d)$ 上的离散最大最小化设施选址问题。对于中等规模的 $N$，这是一个组合问题，通常难以精确求解，但经过充分研究的贪心近似算法提供了基于特定原理的有效解法。\n\n一个基于特定原理的算法是贪婪最远点采样（也称为 Gonzalez 算法），它可以在任何度量空间中为最大最小化目标构建一个近似最优集。算法流程如下：\n\n1.  通过随机选择一个点位进行初始化（为保证可复现性，使用指定的种子）。\n2.  对于每个未被选择的点位 $j$，维护量\n    $$\n    \\delta(j) = \\min_{i \\in \\mathcal{S}} d(\\mathbf{r}_j, \\mathbf{r}_i),\n    $$\n    即该点位到当前已选集合的最小距离。\n3.  选择下一个点位 $j^*$，使其在所有未选择的点位 $j$ 中最大化 $\\delta(j)$。使用同样的可复现随机数生成器来打破平局。\n4.  使用新添加的点位更新所有未选点位的 $\\delta(j)$，并重复此过程，直到 $|\\mathcal{S}| = M$。\n\n这种贪心方案的基础是 MIC 度量内含的三角不等式，已知它能为最优最大最小化目标产生一个 2-近似解，这对于计算材料模拟中的初始化任务而言是充分且稳健的。从第一性原理的角度来看，它与将每个后续溶质原子放置在尽可能远离所有先前已放置溶质的位置的直觉相符，从而降低团簇的可能性，并近似一种类似于排斥相互作用的均匀分散状态。\n\n构建 $\\mathcal{S}$ 后，我们计算实现的最小成对距离\n$$\nd_{\\min} = \\min_{\\substack{p, q \\in \\mathcal{S} \\\\ p \\ne q}} d(\\mathbf{r}_p, \\mathbf{r}_q),\n$$\n单位为埃，并按要求将结果四舍五入到五位小数。\n\n高效实现的算法细节：\n\n-   通过索引集预先计算所有晶格坐标 $\\{\\mathbf{r}_i\\}$。此操作的时间复杂度为 $O(N)$。\n-   使用矢量化操作预先计算完整的成对 MIC 距离矩阵 $D \\in \\mathbb{R}^{N \\times N}$，其元素为 $D_{pq} = d(\\mathbf{r}_p, \\mathbf{r}_q)$。此操作的时间和内存复杂度为 $O(N^2)$，对于给定的测试规模是可以接受的。\n-   使用给定的种子初始化一个随机起始索引。维护一个对所有 $j$ 初始化为 $+\\infty$ 的数组 $\\delta(j)$，并在添加点位 $i^*$ 时迭代更新：对所有未选择的 $j$，设置 $\\delta(j) \\leftarrow \\min(\\delta(j), D_{j i^*})$。\n-   最后，通过取 $D$ 限制在所选索引上的上三角部分的最小值来评估 $d_{\\min}$，确保对角线元素（零自距）被排除。\n\n科学现实主义与单位：\n\n-   MIC 距离遵循标准的周期性边界约定，并能在周期性模拟盒子内产生具有物理意义的间距。\n-   晶格参数 $a$ 的单位是埃，所有距离也以相同单位报告，并四舍五入到五位小数。\n\n四个测试案例涵盖了不同的情况：具有低组分的小立方体盒子；具有中等组分的较大盒子；用于测试跨越不等维度周期性包裹的各向异性盒子；以及高组分的中等尺寸盒子，以探测接近密集溶质放置时的行为。输出是代表 $d_{\\min}$（单位为埃）的浮点数，并按要求的单行格式聚合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_lattice_coords(nx, ny, nz, a):\n    \"\"\"Generate lattice coordinates for a simple cubic lattice.\"\"\"\n    # Create grid of indices\n    ix, iy, iz = np.indices((nx, ny, nz))\n    # Flatten and stack, multiply by lattice parameter a\n    coords = np.stack([ix.ravel(), iy.ravel(), iz.ravel()], axis=1).astype(float) * a\n    return coords  # shape (N, 3)\n\ndef mic_displacements(coords, box_lengths):\n    \"\"\"\n    Compute pairwise minimum-image displacements for all pairs.\n    Returns array of shape (N, N, 3).\n    \"\"\"\n    # Broadcast differences: coords[j] - coords[i]\n    # delta[i, j, :] = coords[j, :] - coords[i, :]\n    delta = coords[np.newaxis, :, :] - coords[:, np.newaxis, :]\n    # Apply minimum image convention componentwise:\n    # delta -= L * round(delta / L)\n    # Use broadcasting over the last axis for box lengths\n    delta = delta - box_lengths * np.round(delta / box_lengths)\n    return delta\n\ndef pairwise_mic_distances(coords, box_lengths):\n    \"\"\"Compute full pairwise MIC distance matrix.\"\"\"\n    delta = mic_displacements(coords, box_lengths)\n    dist = np.linalg.norm(delta, axis=2)\n    return dist  # shape (N, N)\n\ndef farthest_point_selection(dist_matrix, m, rng):\n    \"\"\"\n    Greedy farthest-point sampling to select m indices maximizing minimum pairwise distance.\n    dist_matrix: (N, N) symmetric distance matrix with zeros on diagonal.\n    rng: numpy random Generator for reproducibility.\n    Returns list of selected indices.\n    \"\"\"\n    N = dist_matrix.shape[0]\n    # Initialize selection with a random index\n    start = rng.integers(0, N)\n    selected = [int(start)]\n    # Maintain minimum distance to current selected set for each point\n    min_dist = np.full(N, np.inf, dtype=float)\n    # Update from initial selection\n    min_dist = np.minimum(min_dist, dist_matrix[:, selected[-1]])\n    # Mark selected index with zero to avoid re-selection\n    min_dist[selected[-1]] = 0.0\n\n    while len(selected)  m:\n        # Find candidates with maximum min_dist among unselected\n        # Exclude already selected by setting their min_dist to -inf temporarily\n        temp = min_dist.copy()\n        temp[selected] = -np.inf\n        max_val = np.max(temp)\n        # Handle potential ties\n        candidates = np.where(temp == max_val)[0]\n        next_index = int(rng.choice(candidates))\n        selected.append(next_index)\n        # Update min_dist with the newly selected point\n        min_dist = np.minimum(min_dist, dist_matrix[:, next_index])\n        min_dist[next_index] = 0.0\n\n    return selected\n\ndef achieved_min_pair_distance(dist_matrix, selected_indices):\n    \"\"\"Compute the achieved minimum pairwise distance among selected indices.\"\"\"\n    # Extract submatrix\n    sub = dist_matrix[np.ix_(selected_indices, selected_indices)].copy()\n    # Ignore diagonal zeros by setting them to +inf\n    np.fill_diagonal(sub, np.inf)\n    # Return minimum over all off-diagonal entries\n    return float(np.min(sub))\n\ndef compute_case(nx, ny, nz, a, x_s, seed):\n    \"\"\"Compute achieved minimum pair distance for one test case.\"\"\"\n    N = nx * ny * nz\n    # Determine number of solutes M with constraints 2 = M = N\n    M = int(np.round(x_s * N))\n    if M  2:\n        M = 2\n    if M > N:\n        M = N\n\n    # Generate lattice coordinates and box lengths\n    coords = generate_lattice_coords(nx, ny, nz, a)\n    box_lengths = np.array([nx * a, ny * a, nz * a], dtype=float)\n\n    # Compute pairwise MIC distances\n    dist_matrix = pairwise_mic_distances(coords, box_lengths)\n\n    # Greedy farthest-point selection\n    rng = np.random.default_rng(seed)\n    selected = farthest_point_selection(dist_matrix, M, rng)\n\n    # Achieved minimum pairwise distance\n    dmin = achieved_min_pair_distance(dist_matrix, selected)\n    # Round to five decimal places\n    return float(np.round(dmin, 5))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N_x, N_y, N_z, a, x_s, seed)\n    test_cases = [\n        (3, 3, 3, 3.6, 0.148, 42),\n        (5, 5, 5, 2.5, 0.1, 123),\n        (6, 2, 2, 2.0, 0.25, 7),\n        (4, 4, 4, 1.0, 0.5, 2023),\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny, nz, a, x_s, seed = case\n        result = compute_case(nx, ny, nz, a, x_s, seed)\n        results.append(f\"{result:.5f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3458372"}]}