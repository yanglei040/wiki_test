{"hands_on_practices": [{"introduction": "掌握任何一种计算方法的第一步都是亲手实现它。本练习旨在引导您从第一性原理出发，构建三维周期性系统中的埃瓦尔德求和算法。通过计算像氯化钠（NaCl）这类经典离子晶体的马德隆常数，您不仅能验证自己代码的正确性，还能直观地理解埃瓦尔德求和中各项参数（如分割参数 $α$、实空间截断半径 $r_{\\mathrm{cut}}$ 和倒易空间截断 $m_{\\max}$）如何影响计算的精度和效率。[@problem_id:3462178]", "problem": "你需要设计并实现一个三维（3D）周期性数值实验，该实验使用周期性边界条件（PBC）下的Ewald求和法来计算二元离子晶体的无量纲马德隆常数。该实验必须验证，在选择合适的参数后，Ewald求和的实现能够在一个指定的容差范围内再现已知的参考马德隆常数值，并且必须量化由实空间截断、倒易空间截断和分裂参数选择所引起的残余误差。程序必须是自包含的，并在不读取外部输入的情况下为一组固定的测试套件生成结果。必须遵循以下基本原理：点电荷的库仑定律、电中性晶胞的周期性复制，以及通过将条件收敛的晶格和分裂为在实空间和倒易空间中快速衰减的互补部分来实现其收敛的性质。模拟晶胞中的所有距离都必须以立方晶格参数的单位表示，你必须将其设置为 $a = 1$，以便结果是无量纲的。最终答案不需要物理单位或角度单位。\n\n定义二元离子晶体的无量纲马德隆常数 $M$ 如下：取边长为 $a = 1$ 的电中性周期性晶胞中位于位置 $\\mathbf{r}_j$ 的电荷 $q_j \\in \\{+1,-1\\}$，使用Ewald求和法计算每个离子的总相互作用能，并用最近邻间距 $r_0$ 对其进行归一化，使得每个离子的能量为 $E_{\\text{ion}} = -M \\, (q^2 / r_0)$，其中 $q=1$。因此，当 $a=1$ 时，从Ewald计算得到的无量纲估计值为 $M_{\\text{calc}} = - E_{\\text{ion}} \\, r_0$。\n\n你的实现必须：\n- 将每个晶体构建为一个边长为 $a = 1$ 的周期性立方晶胞，并具有指定的分数坐标基 $\\{ \\mathbf{s}_j \\}$ 和电荷 $\\{ q_j \\}$，其中真实位置为 $\\mathbf{r}_j = a \\, \\mathbf{s}_j$。\n- 使用带有参数 $\\alpha > 0$ 的Ewald分裂法、一个球形实空间截断半径 $r_{\\mathrm{cut}}$，以及一个球形倒易空间指数截断 $m_{\\max}$，该截断通过 $\\sqrt{h^2+k^2+\\ell^2} \\le m_{\\max}$ 来限制整数三元组 $(h,k,\\ell)$ 以用于倒易空间求和。程序必须能够为每个测试用例改变 $(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$。\n- 在实空间求和中排除零间距处的自相互作用，并包含适用于点电荷的标准自能校正。\n- 对于每个测试用例，返回相对于已知参考值 $M_{\\text{ref}}$ 的绝对误差 $\\left| M_{\\text{calc}} - M_{\\text{ref}} \\right|$。\n\n测试套件。实现以下四个测试用例，这些用例共同探测了“理想路径”、实空间欠解析、倒易空间欠解析以及边界情况截断。\n\n- 测试用例1（岩盐结构，良好平衡）：\n  - 晶体：氯化钠（NaCl），处于传统的面心立方晶胞中，每个晶胞含8个离子。\n  - 基（分数坐标 $\\mathbf{s}_j$）和电荷 $q_j$：\n    - 阴离子子晶格 ($q=+1$)：$(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n    - 阳离子子晶格 ($q=-1$)：$(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,0)$, $(0,\\tfrac{1}{2},0)$, $(0,0,\\tfrac{1}{2})$。\n  - 最近邻间距 $r_0 = \\tfrac{1}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.747564594$。\n  - 参数：$\\alpha = 6$, $r_{\\mathrm{cut}} = 6$, $m_{\\max} = 8$。\n\n- 测试用例2（氯化铯结构，实空间欠解析）：\n  - 晶体：氯化铯（CsCl），处于简单立方晶胞中，每个晶胞含2个离子。\n  - 基和电荷：\n    - $q=+1$ 位于 $(0,0,0)$，\n    - $q=-1$ 位于 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$。\n  - 最近邻间距 $r_0 = \\tfrac{\\sqrt{3}}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.762675$。\n  - 参数：$\\alpha = 1.5$, $r_{\\mathrm{cut}} = 3$, $m_{\\max} = 4$。\n\n- 测试用例3（闪锌矿结构，良好平衡）：\n  - 晶体：硫化锌（ZnS，闪锌矿），处于传统的面心立方晶胞中，每个晶胞含8个离子。\n  - 基和电荷：\n    - 阴离子子晶格 ($q=+1$)：$(0,0,0)$, $(0,\\tfrac{1}{2},\\tfrac{1}{2})$, $(\\tfrac{1}{2},0,\\tfrac{1}{2})$, $(\\tfrac{1}{2},\\tfrac{1}{2},0)$。\n    - 阳离子子晶格 ($q=-1$)，由 $(\\tfrac{1}{4},\\tfrac{1}{4},\\tfrac{1}{4})$ 位移：$(\\tfrac{1}{4},\\tfrac{1}{4},\\tfrac{1}{4})$, $(\\tfrac{1}{4},\\tfrac{3}{4},\\tfrac{3}{4})$, $(\\tfrac{3}{4},\\tfrac{1}{4},\\tfrac{3}{4})$, $(\\tfrac{3}{4},\\tfrac{3}{4},\\tfrac{1}{4})$。\n  - 最近邻间距 $r_0 = \\tfrac{\\sqrt{3}}{4}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.638055$。\n  - 参数：$\\alpha = 5$, $r_{\\mathrm{cut}} = 6$, $m_{\\max} = 8$。\n\n- 测试用例4（岩盐边界情况，紧凑截断）：\n  - 晶体：氯化钠（NaCl），与测试用例1使用相同的基和电荷。\n  - 最近邻间距 $r_0 = \\tfrac{1}{2}$。\n  - 参考马德隆常数 $M_{\\text{ref}} = 1.747564594$。\n  - 参数：$\\alpha = 3$, $r_{\\mathrm{cut}} = 2$, $m_{\\max} = 2$。\n\n验证容差。在评估计算出的 $M_{\\text{calc}}$ 是否再现 $M_{\\text{ref}}$ 时，使用单一容差 $\\tau = 10^{-3}$。尽管你的程序必须计算并返回所有测试用例的绝对误差，但残余误差应能通过 $(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$ 的选择来解释。\n\n最终输出格式。你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，具体为绝对误差列表 $[\\,|M_{\\text{calc}}^{(1)}-M_{\\text{ref}}^{(1)}|,\\;|M_{\\text{calc}}^{(2)}-M_{\\text{ref}}^{(2)}|,\\;|M_{\\text{calc}}^{(3)}-M_{\\text{ref}}^{(3)}|,\\;|M_{\\text{calc}}^{(4)}-M_{\\text{ref}}^{(4)}|\\,]$。", "solution": "用户提供了一个有效的问题陈述。该问题要求实现Ewald求和法，以计算几种二元离子晶体的无量纲马德隆常数。该问题在科学上基于静电学和固态物理学原理，问题设定良好，有明确的输入和定义的输出，客观且自包含。因此，将提供一个解决方案。\n\n问题的核心是计算一个电中性、周期性的三维点电荷晶格的总静电势能 $E_{\\text{total}}$。马德隆常数 $M$ 将此能量与一对最近邻离子的特征能量联系起来。对于电荷为 $\\pm q$、最近邻间距为 $r_0$ 的二元晶体，每个离子的能量由 $E_{\\text{ion}} = -M \\frac{q^2}{r_0}$ 给出。问题设定基本电荷大小 $q=1$ 和立方晶格参数 $a=1$。因此，计算出的马德隆常数 $M_{\\text{calc}}$ 是从计算出的每个离子的能量 $E_{\\text{ion}}$ 得到的，即 $M_{\\text{calc}} = -E_{\\text{ion}} r_0$。\n\n库仑势的长程性质（其以 $1/r$ 的形式衰减）导致在无限周期晶格上求和时出现条件收敛。Ewald求和法是一种标准技术，通过将求和分成两部分来克服这个问题，这两部分都快速收敛：一个在实空间中计算的短程部分和一个在倒易（傅里叶）空间中计算的长程部分。\n\n晶胞中 $N$ 个离子的总能量 $E_{\\text{total}}$ 是三个分量的总和：\n$$E_{\\text{total}} = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}}$$\n\n下面详细介绍每个分量，假设是一个体积为 $V=a^3$ 且 $a=1$ 的立方晶胞。离子的位置由分数坐标 $\\mathbf{s}_j$ 给出，因此它们的实空间位置是 $\\mathbf{r}_j = a \\mathbf{s}_j = \\mathbf{s}_j$。\n\n1.  **实空间能量 ($E_{\\text{real}}$)**\n    该项考虑了短程相互作用。通过在点电荷周围放置符号相反的高斯电荷分布来屏蔽它们，这使得它们的相互作用势快速衰减。两个相距为 $r$ 的点电荷 $q_i$ 和 $q_j$ 之间的相互作用被替换为 $\\frac{q_i q_j \\text{erfc}(\\alpha r)}{r}$，其中 $\\text{erfc}$ 是互补误差函数，$\\alpha$ 是控制高斯分布宽度的Ewald分裂参数。较大的 $\\alpha$ 会导致实空间中更快的衰减。\n\n    实空间能量是晶胞中所有离子对 $(i,j)$ 及其所有周期性映像的总和，这些映像由晶格矢量 $\\mathbf{L}_{\\mathbf{n}} = n_x \\hat{\\mathbf{x}} + n_y \\hat{\\mathbf{y}} + n_z \\hat{\\mathbf{z}}$ 标识，其中 $\\mathbf{n}=(n_x, n_y, n_z)$ 是整数三元组。求和排除了中心晶胞（$\\mathbf{n}=\\mathbf{0}$）内 $i=j$ 的自相互作用项。\n    $$E_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\sum_{\\mathbf{n}}' \\frac{q_i q_j \\text{erfc}(\\alpha |\\mathbf{s}_{ij} + \\mathbf{n}|)}{|\\mathbf{s}_{ij} + \\mathbf{n}|}$$\n    其中 $\\mathbf{s}_{ij} = \\mathbf{s}_i - \\mathbf{s}_j$，求和上的撇号表示排除了 $i=j, \\mathbf{n}=\\mathbf{0}$ 项。求和被截断，只包括满足 $|\\mathbf{s}_{ij} + \\mathbf{n}| \\le r_{\\mathrm{cut}}$ 的项。因子 $1/2$ 用于校正每对相互作用被重复计算的问题。\n\n2.  **倒易空间能量 ($E_{\\text{recip}}$)**\n    该项校正了在实空间求和中引入的屏蔽效应。它是一个高斯电荷晶格的能量，该晶格抵消了屏蔽高斯分布。由于这种电荷分布是平滑且周期性的，其能量可以在倒易空间中高效计算。求和是对所有倒易晶格矢量 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi (h \\hat{\\mathbf{x}}^* + k \\hat{\\mathbf{y}}^* + \\ell \\hat{\\mathbf{z}}^*)$ 进行的，对于边长为 $a=1$ 的立方晶胞，这些矢量是 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi \\mathbf{m}$，其中 $\\mathbf{m}=(h,k,\\ell)$ 是一个整数三元组。\n\n    倒易空间能量由下式给出：\n    $$E_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{m} \\neq \\mathbf{0}} \\frac{4\\pi}{k_{\\mathbf{m}}^2} \\exp\\left(-\\frac{k_{\\mathbf{m}}^2}{4\\alpha^2}\\right) |S(\\mathbf{k}_{\\mathbf{m}})|^2$$\n    此处，$S(\\mathbf{k}_{\\mathbf{m}})$ 是结构因子：\n    $$S(\\mathbf{k}_{\\mathbf{m}}) = \\sum_{j=1}^{N} q_j \\exp(-i \\mathbf{k}_{\\mathbf{m}} \\cdot \\mathbf{s}_j)$$\n    代入 $V=1$ 和 $\\mathbf{k}_{\\mathbf{m}} = 2\\pi \\mathbf{m}$，能量表达式简化为：\n    $$E_{\\text{recip}} = \\frac{1}{2\\pi} \\sum_{\\mathbf{m} \\neq \\mathbf{0}, |\\mathbf{m}| \\le m_{\\max}} \\frac{\\exp(-\\pi^2 |\\mathbf{m}|^2 / \\alpha^2)}{|\\mathbf{m}|^2} \\left| \\sum_{j=1}^{N} q_j \\exp(-i 2\\pi \\mathbf{m} \\cdot \\mathbf{s}_j) \\right|^2$$\n    求和排除了 $\\mathbf{m}=\\mathbf{0}$ 项（对于电中性晶胞，该项为零），并被截断为只包括球形截断 $|\\mathbf{m}| \\le m_{\\max}$ 内的整数三元组 $\\mathbf{m}$。较小的 $\\alpha$ 会导致倒易空间中更快的收敛。\n\n3.  **自能校正 ($E_{\\text{self}}$)**\n    该项移除了每个高斯电荷分布与其自身的虚假相互作用，这种相互作用已隐含地包含在倒易空间求和中。对于点电荷，此校正为：\n    $$E_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{j=1}^{N} q_j^2$$\n    由于所有电荷都是 $q_j \\in \\{+1, -1\\}$，我们有 $q_j^2=1$，表达式变为 $E_{\\text{self}} = - N \\alpha / \\sqrt{\\pi}$。\n\n该算法通过为每个指定的测试用例实现这三个求和来进行。计算总能量 $E_{\\text{total}}$，然后进行归一化以找到每个离子的能量 $E_{\\text{ion}} = E_{\\text{total}} / N$。计算出的马德隆常数则为 $M_{\\text{calc}} = -E_{\\text{ion}} r_0$。最后，计算并报告绝对误差 $|M_{\\text{calc}} - M_{\\text{ref}}|$。$(\\alpha, r_{\\mathrm{cut}}, m_{\\max})$ 的选择通过控制实空间和倒易空间求和中的截断误差来决定结果的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nimport math\n\ndef compute_madelung(s, q, alpha, r_cut, m_max, r0, m_ref):\n    \"\"\"\n    Computes the Madelung constant using Ewald summation and returns the absolute error.\n\n    Args:\n        s (np.ndarray): Fractional coordinates of ions, shape (N, 3).\n        q (np.ndarray): Charges of ions, shape (N,).\n        alpha (float): Ewald splitting parameter.\n        r_cut (float): Real-space cutoff radius.\n        m_max (int): Reciprocal-space index cutoff.\n        r0 (float): Nearest-neighbor separation.\n        m_ref (float): Reference Madelung constant.\n\n    Returns:\n        float: The absolute error |M_calc - M_ref|.\n    \"\"\"\n    N = len(q)\n    V = 1.0  # a=1, so V=a^3=1\n\n    # Real-space term\n    E_real = 0.0\n    n_max_ceil = math.ceil(r_cut)\n    for i in range(N):\n        for j in range(N):\n            s_ij = s[i] - s[j]\n            for nx in range(-n_max_ceil, n_max_ceil + 1):\n                for ny in range(-n_max_ceil, n_max_ceil + 1):\n                    for nz in range(-n_max_ceil, n_max_ceil + 1):\n                        # Exclude self-interaction in the primary cell\n                        if i == j and nx == 0 and ny == 0 and nz == 0:\n                            continue\n\n                        n_vec = np.array([nx, ny, nz])\n                        dist_vec = s_ij + n_vec\n                        dist = np.linalg.norm(dist_vec)\n\n                        if dist = r_cut:\n                            E_real += q[i] * q[j] * erfc(alpha * dist) / dist\n\n    E_real *= 0.5\n\n    # Reciprocal-space term\n    E_recip = 0.0\n    m_max_sq = m_max**2\n    m_max_floor = math.floor(m_max)\n    for h in range(-m_max_floor, m_max_floor + 1):\n        for k in range(-m_max_floor, m_max_floor + 1):\n            for l in range(-m_max_floor, m_max_floor + 1):\n                m_sq = h**2 + k**2 + l**2\n                if m_sq == 0 or m_sq > m_max_sq:\n                    continue\n                \n                m_vec = np.array([h, k, l])\n                k_vec = 2 * np.pi * m_vec\n                \n                # Structure factor S(k)\n                # S_k = np.sum(q * np.exp(-1j * np.dot(s, k_vec))) -- original k\n                # With k = 2*pi*m and r = a*s = s (since a=1)\n                # k.r = 2*pi*m.s\n                s_dot_m = np.dot(s, m_vec)\n                S_k = np.sum(q * np.exp(-1j * 2 * np.pi * s_dot_m))\n                S_k_sq = np.abs(S_k)**2\n\n                term = (S_k_sq / m_sq) * np.exp(-np.pi**2 * m_sq / alpha**2)\n                E_recip += term\n\n    E_recip *= 1.0 / (2.0 * np.pi * V)\n\n    # Self-energy term\n    E_self = - (alpha / np.sqrt(np.pi)) * np.sum(q**2)\n\n    # Total energy and Madelung constant\n    E_total = E_real + E_recip + E_self\n    E_ion = E_total / N\n    M_calc = - E_ion * r0\n\n    # Absolute error\n    abs_error = abs(M_calc - m_ref)\n    \n    return abs_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define test cases\n    # Test case 1: NaCl, good balance\n    s_nacl_anion = np.array([[0,0,0], [0,0.5,0.5], [0.5,0,0.5], [0.5,0.5,0]])\n    s_nacl_cation = np.array([[0.5,0.5,0.5], [0.5,0,0], [0,0.5,0], [0,0,0.5]])\n    s_nacl = np.vstack((s_nacl_anion, s_nacl_cation))\n    q_nacl = np.array([1,1,1,1,-1,-1,-1,-1])\n    \n    # Test case 3: ZnS (sphalerite)\n    s_zns_anion = np.array([[0,0,0], [0,0.5,0.5], [0.5,0,0.5], [0.5,0.5,0]])\n    s_zns_cation = s_zns_anion + 0.25\n    s_zns = np.vstack((s_zns_anion, s_zns_cation))\n    q_zns = np.array([1,1,1,1,-1,-1,-1,-1])\n    \n    test_cases = [\n        # Case 1: NaCl, good balance\n        {\n            \"s\": s_nacl, \"q\": q_nacl, \"alpha\": 6.0, \"r_cut\": 6.0, \n            \"m_max\": 8.0, \"r0\": 0.5, \"m_ref\": 1.747564594\n        },\n        # Case 2: CsCl, under-resolved real space\n        {\n            \"s\": np.array([[0,0,0], [0.5,0.5,0.5]]), \"q\": np.array([1,-1]), \n            \"alpha\": 1.5, \"r_cut\": 3.0, \"m_max\": 4.0, \n            \"r0\": np.sqrt(3)/2, \"m_ref\": 1.762675\n        },\n        # Case 3: ZnS, good balance\n        {\n            \"s\": s_zns, \"q\": q_zns, \"alpha\": 5.0, \"r_cut\": 6.0, \n            \"m_max\": 8.0, \"r0\": np.sqrt(3)/4, \"m_ref\": 1.638055\n        },\n        # Case 4: NaCl, tight truncations\n        {\n            \"s\": s_nacl, \"q\": q_nacl, \"alpha\": 3.0, \"r_cut\": 2.0, \n            \"m_max\": 2.0, \"r0\": 0.5, \"m_ref\": 1.747564594\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_madelung(\n            case[\"s\"], case[\"q\"], case[\"alpha\"], case[\"r_cut\"], \n            case[\"m_max\"], case[\"r0\"], case[\"m_ref\"]\n        )\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3462178"}, {"introduction": "理论的价值在于解决实际问题。在有限尺寸的周期性边界条件下进行模拟时，带电溶质会与其周期性镜像相互作用，导致计算出的物理量（如溶剂化自由能）与真实宏观系统（热力学极限）的值存在系统性偏差。本练习将向您展示如何运用埃瓦尔德求和的理论框架，推导出这种由有限尺寸效应引起的主要能量偏差，并利用该修正项从模拟原始数据中提取出更为精确的物理观测量。[@problem_id:3462165]", "problem": "在分子模拟中，一个对周期性边界条件（PBC）下的长程静电作用特别敏感的可观测量是净电荷溶质的溶剂化自由能。考虑一个大小为 $q$ 的单一点电荷，嵌入电介质中，并在边长为 $L$ 的立方晶胞内，采用导电（锡箔）边界条件进行模拟，并使用 Ewald 求和法进行计算。通过均匀的中和背景电荷密度使系统保持净电中性。原始模拟的溶剂化自由能 $G(L)$ 因溶质与其周期性镜像以及中和背景之间的相互作用而受到有限晶胞大小的影响，从而产生偏差。已知这种偏差对晶胞尺寸的依赖性由一个形状依赖的晶格常数控制，即对于简单立方几何结构的所谓马德隆常数 $\\xi$，它是一个无量纲数。\n\n从周期性边界条件下均匀中和背景中点电荷的泊松方程 $\\nabla^{2} \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})/\\epsilon_{0}$ 出发，并使用 Ewald 分裂的库仑相互作用来分离短程和长程贡献，推导在导电边界条件下净电荷溶质的领头阶有限尺寸偏差，该偏差是 $q$、$L$ 和 $\\xi$ 的函数。然后，利用此结果，通过从原始模拟值中减去推导出的偏差，将溶剂化自由能外推至热力学极限。\n\n提供了以下数据和定义：\n- 基本电荷大小 $q = e$。\n- 库仑常数 $k_{e} = 1/(4\\pi \\epsilon_{0})$。\n- 当能量以千焦/摩尔（kilojoules per mole）表示，距离以纳米（nanometers）表示时，$k_{e}$ 的数值为 $138.935456$，即 $k_{e}$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。\n- 对于 Ewald 处理单个净电荷加中和背景时出现的晶格和，简单立方马德隆常数 $\\xi = -2.837297$。\n- 进行了两次模拟：\n  - $L_{1} = 3.20\\,\\mathrm{nm}$，原始溶剂化自由能 $G(L_{1}) = -373.9389300785\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - $L_{2} = 4.65\\,\\mathrm{nm}$，原始溶剂化自由能 $G(L_{2}) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n使用您推导的有限尺寸偏差表达式，通过校正 $G(L_{1})$ 或 $G(L_{2})$ 来计算热力学极限溶剂化自由能 $G(\\infty)$，并报告一个单一值。最终能量以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 表示，并将您的答案四舍五入至四位有效数字。", "solution": "该问题要求推导周期性体系中点电荷溶剂化自由能的领头阶有限尺寸偏差，并随后利用该偏差，根据在有限大小模拟晶胞中获得的数据，计算热力学极限下的自由能 $G(\\infty)$。\n\n对问题陈述的验证证实了其具有科学依据、是适定的，并包含充分、一致的信息以得出唯一解。因此，我们可以继续进行。\n\n该系统由一个大小为 $q$ 的单一点电荷组成，放置在边长为 $L$ 的立方模拟晶胞的原点。该晶胞被周期性地复制以填充整个空间。为保持整体电中性，系统中加入了均匀的背景电荷密度 $\\rho_{\\text{bg}} = -q/L^{3}$。该系统内的静电势 $\\phi(\\mathbf{r})$ 由泊松方程决定：\n$$ \\nabla^{2} \\phi(\\mathbf{r}) = -\\frac{\\rho(\\mathbf{r})}{\\epsilon_{0}} $$\n其中 $\\rho(\\mathbf{r})$ 是点电荷晶格和背景的总电荷密度，$\\epsilon_{0}$ 是真空介电常数。\n\n在大小为 $L$ 的有限晶胞中模拟计算出的溶剂化自由能 $G(L)$ 会因人为周期性而受到人为因素的污染。对于带电溶质，领头阶误差（或偏差）源于溶质自身与其周期性镜像以及中和背景电荷之间的静电相互作用。这种相互作用能是周期性边界条件的人为产物，在热力学极限（$L \\to \\infty$）下会消失。\n\nEwald 求和法提供了一种计算这种静电能的方法。对于立方晶格中的单个电荷 $q$，由其所有周期性镜像和中和背景在电荷位置（原点，$\\mathbf{r}=\\mathbf{0}$）产生的电势记为 $\\phi_{\\text{other}}(\\mathbf{0})$。这个电势恰好是该晶格位置的马德隆势。它可以用给定晶格几何结构（本例中为简单立方）和边界条件（导电，或“锡箔”）的无量纲马德隆常数 $\\xi$ 来表示。该电势的表达式为：\n$$ \\phi_{\\text{other}}(\\mathbf{0}) = \\frac{q \\xi}{4 \\pi \\epsilon_{0} L} = \\frac{k_{e} q \\xi}{L} $$\n其中 $k_{e} = 1/(4\\pi\\epsilon_{0})$ 是库仑常数。\n\n由这些长程相互作用引起的模拟晶胞的总静电能，即构成偏差的部分，是将电荷 $q$ 置于此电势中所需要做的功。包含一个 $1/2$ 的因子是为了避免在计算晶胞总能量时重复计算相互作用能：\n$$ G_{\\text{bias}}(L) = \\frac{1}{2} q \\phi_{\\text{other}}(\\mathbf{0}) = \\frac{1}{2} q \\left( \\frac{k_{e} q \\xi}{L} \\right) = \\frac{k_{e} q^{2} \\xi}{2L} $$\n这就是在指定条件下点电荷溶剂化自由能的领头阶有限尺寸偏差。\n\n原始模拟的自由能 $G(L)$ 是真实的热力学极限自由能 $G(\\infty)$ 和这个偏差项（以及我们忽略的其他高阶项）之和：\n$$ G(L) \\approx G(\\infty) + G_{\\text{bias}}(L) $$\n为了求得热力学极限下的值，我们从模拟值中减去偏差：\n$$ G(\\infty) = G(L) - G_{\\text{bias}}(L) = G(L) - \\frac{k_{e} q^{2} \\xi}{2L} $$\n\n我们已知以下数据：\n- 电荷大小 $q = e$。\n- 库仑常数 $k_{e} = 138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$。\n- 简单立方马德隆常数 $\\xi = -2.837297$。\n- 数据点1：$L_{1} = 3.20\\,\\mathrm{nm}$, $G(L_{1}) = -373.9389300785\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 数据点2：$L_{2} = 4.65\\,\\mathrm{nm}$, $G(L_{2}) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n我们可以使用任一数据点来计算 $G(\\infty)$。使用较大模拟晶胞（$L_{2}$）的数据更为可取，因为被忽略的高阶校正项（例如，与 $1/L^{3}$ 成正比的项）会更小。首先，我们计算 $L_{2}$ 的偏差项。由于 $q=e$，项 $k_{e}q^{2}$ 简化为 $k_{e}e^{2}$，并且 $k_{e}$ 的数值是以包含了这一点的单位给出的。\n$$ G_{\\text{bias}}(L_{2}) = \\frac{k_{e} e^{2} \\xi}{2L_{2}} = \\frac{(138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}) \\times (-2.837297)}{2 \\times (4.65\\,\\mathrm{nm})} $$\n$$ G_{\\text{bias}}(L_{2}) = \\frac{-394.2400949...}{9.30}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} = -42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n\n现在，我们计算外推的自由能 $G(\\infty)$：\n$$ G(\\infty) = G(L_{2}) - G_{\\text{bias}}(L_{2}) $$\n$$ G(\\infty) = -354.7322206993\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} - (-42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}) $$\n$$ G(\\infty) = -354.7322206993 + 42.39140805...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ G(\\infty) = -312.3408126...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n\n作为一致性检验，我们可以使用 $L_{1}$ 的数据进行相同的计算：\n$$ G_{\\text{bias}}(L_{1}) = \\frac{k_{e} e^{2} \\xi}{2L_{1}} = \\frac{(138.935456\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}) \\times (-2.837297)}{2 \\times (3.20\\,\\mathrm{nm})} $$\n$$ G_{\\text{bias}}(L_{1}) = \\frac{-394.2400949...}{6.40}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} = -61.59991639...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ G(\\infty) = G(L_{1}) - G_{\\text{bias}}(L_{1}) = -373.9389300785 - (-61.59991639...) = -312.3390136...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n两个计算出的 $G(\\infty)$ 值非常吻合（相差小于 $0.002\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$），这验证了领头阶偏差的 $1/L$ 标度关系。\n\n问题要求提供一个四舍五入至四位有效数字的单一值。使用来自较大模拟盒子（$L_{2}$）的更准确的结果：\n$G(\\infty) = -312.3408126...\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n四舍五入至四位有效数字得到 $-312.3\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。", "answer": "$$\n\\boxed{-312.3}\n$$", "id": "3462165"}, {"introduction": "为了处理大规模系统，直接的埃瓦尔德求和通常被其高效的粒子网格埃瓦尔德（PME）算法所取代。然而，效率的提升伴随着新的近似和误差来源，主要是在将粒子电荷分配到网格时产生的。本练习将引导您深入PME方法的核心，通过监测结构因子 $|S(\\mathbf{k})|^2$ 的高频部分和力计算中的噪声，设计并实现一套诊断工具，以量化和理解插值阶数和网格密度等关键PME参数如何影响模拟的准确性。[@problem_id:3462216]", "problem": "考虑一个边长为 $L$ 的立方晶胞中的周期性点电荷系统，使用质点网格埃瓦尔德 (PME) 方法处理长程静电相互作用。目标是通过监测结构因子平方模 $|S(\\mathbf{k})|^2$ 的高$k$谱以及力噪声随插值阶数 $p$ 变化的情况，设计并实现用于检测PME中混叠和分配误差的诊断工具。从以下基本原理出发。埃瓦尔德求和将库仑相互作用分解为实空间和倒易空间两部分。在倒易空间中，能量贡献由结构因子 $S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$ 计算得出，其中 $q_j$ 是位于位置 $\\mathbf{r}_j$ 的粒子 $j$ 的电荷，而 $\\mathbf{k}$ 位于由周期性晶胞定义的倒易晶格上。在PME中，结构因子通过将电荷分配到网格上并执行快速傅里叶变换 (FFT) 来近似计算，这由于有限的插值阶数和离散化，会内在地引入一个窗函数，并且可能因为在有限网格上的采样而产生混叠。\n\n您必须基于采样定理和PME分配的傅里叶分析，推导、论证并实现诊断工具。使用以下原则：\n\n- 结构因子 $S(\\mathbf{k})$ 可以根据粒子位置和电荷精确计算，也可以通过对网格化电荷进行FFT并随后对分配窗进行反卷积来近似计算。对于一维情况，一个 $p$ 阶基数B样条的分配窗可以近似为函数 $\\mathrm{sinc}(k h / 2)^p$，其中 $\\mathrm{sinc}(x) = \\sin(x)/x$，当每个维度使用 $M$ 个网格点时，$h=L/M$ 是网格间距。三维窗函数是沿 $k_x$、$k_y$ 和 $k_z$ 的一维窗函数的乘积。\n- 粒子 $i$ 上的倒易空间力由倒易空间能量对 $\\mathbf{r}_i$ 求导得出，得到一个对 $\\mathbf{k}$ 的求和，其贡献与 $\\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right)$ 成正比，并带有来自埃瓦尔德求和的高斯屏蔽因子和 $1/k^2$ 标度。具体来说，在库仑常数设为1的约化单位下，使用严格的倒易空间力公式：$$\\mathbf{F}_i^{(k)} = -\\frac{4 \\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-k^2/(4 \\alpha^2)}}{k^2} \\, \\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right) \\, \\mathbf{k},$$ 其中 $V=L^3$，$\\alpha$ 是埃瓦尔德分裂参数，$k = \\|\\mathbf{k}\\|$。\n- 在PME中，近似结构因子 $S_{\\mathrm{est}}(\\mathbf{k})$ 是通过对网格化电荷分配 $G(\\mathbf{k})$ 进行FFT，并与分配窗 $W(\\mathbf{k})$ 进行反卷积得到的，即 $S_{\\mathrm{est}}(\\mathbf{k}) \\approx G(\\mathbf{k})/W(\\mathbf{k})$，当 $W(\\mathbf{k})$ 接近零时需采取数值保护措施。\n\n定义以下两种诊断工具：\n\n- 一个高$k$谱诊断 $R(p)$，用于量化大波矢下混叠和分配误差的影响：$$R(p) := \\frac{\\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{high}}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}{\\sum_{\\mathbf{k} \\neq \\mathbf{0}} |S_{\\mathrm{est}}(\\mathbf{k})|^2},$$ 其中 $\\mathcal{K}_{\\mathrm{high}}$ 包含幅度满足 $k \\ge k_{\\mathrm{thresh}}$ 的波矢 $\\mathbf{k}$，其中 $k_{\\mathrm{thresh}} := r_{\\mathrm{frac}} \\, k_{\\mathrm{max}}$，$k_{\\mathrm{max}}$ 选为网格的径向奈奎斯特幅度。使用 $r_{\\mathrm{frac}} = 0.7$。较大的 $R(p)$ 表示与混叠和分配误差伪影一致的更强的高$k$分量。\n- 一个力噪声诊断 $E(p)$，用于比较使用 $S_{\\mathrm{est}}(\\mathbf{k})$ 计算的PME倒易空间力与使用精确结构因子 $S(\\mathbf{k})$ 计算的参考力：$$E(p) := \\sqrt{\\frac{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}] - \\mathbf{F}_i^{(k)}[S]\\|^2}{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S]\\|^2}},$$ 在约化单位约定下，该值为无量纲。较大的 $E(p)$ 表示由于PME分配和混叠导致的力噪声更大。\n\n您的实现必须：\n\n- 在所有方向上使用均匀网格（每个维度 $M$ 个点）和周期性边界条件。倒易矢量 $\\mathbf{k}$ 对应于采样间距 $h=L/M$ 的离散FFT频率；具体而言，使用 $\\mathbf{k} = 2\\pi \\mathbf{n}/L$，其中整数三元组 $\\mathbf{n}$ 来自FFT频率集。直接从粒子位置和电荷计算精确的 $S(\\mathbf{k})$。使用插值阶数 $p$，通过对电荷分配后的网格进行FFT来计算 $S_{\\mathrm{est}}(\\mathbf{k})$，并与 $W(\\mathbf{k}) = \\prod_{\\mu \\in \\{x,y,z\\}} \\mathrm{sinc}(k_\\mu h/2)^p$ 进行反卷积。\n- 实现电荷分配时，对 $p \\in \\{2,4\\}$ 使用 $p$ 阶基数B样条权重：$p=2$ (Cloud-In-Cell) 和 $p=4$ (分段三次样条)。对于一维情况 $p=2$，如果 $u \\in [0,1)$ 是相对于左侧网格点索引 $i$ 的局部小数坐标，则使用权重 $w_i = 1-u$ 和 $w_{i+1} = u$。对于一维情况 $p=4$，如果 $u \\in [0,1)$ 是相对于中心索引 $i$ 的局部小数坐标，则对索引 $(i-1,i,i+1,i+2)$ 使用权重，分别为 $w_{i-1} = \\frac{1}{6}(1-u)^3$，$w_{i} = \\frac{1}{6}(4 - 6u^2 + 3u^3)$，$w_{i+1} = \\frac{1}{6}(1 + 3u + 3u^2 - 3u^3)$ 和 $w_{i+2} = \\frac{1}{6}u^3$。通过一维权重的乘积扩展到三维，并对索引应用周期性回绕。\n- 使用埃瓦尔德分裂参数 $\\alpha = 3.5 / L$ 和如上所述的倒易空间力，对所有FFT支持的非零 $\\mathbf{k}$ 矢量求和。完全在约化单位下操作，库仑常数设为1，长度单位与 $L$ 相同，以便所有输出都是无量纲浮点数。\n- 为避免反卷积中的数值不稳定性，如果对于一个小的阈值 $\\varepsilon$ 有 $|W(\\mathbf{k})|  \\varepsilon$，则将 $S_{\\mathrm{est}}(\\mathbf{k})$ 设置为0。使用 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n评估三种情况下的诊断结果，这三种情况使用相同的粒子集和盒子长度 $L$，但网格和粒子构型不同，以探究“理想路径”、易混叠和公度边缘情况。使用以下参数值和粒子数据：\n\n- 情况 1（理想路径）：$L = 2.0$, $M = 16$, $N = 12$, 电荷 $q = [1,1,1,1,1,1,-1,-1,-1,-1,-1,-1]$, 晶胞内位置（单位与$L$相同）：\n  $\\mathbf{r}_1 = (0.147, 1.835, 0.410)$,\n  $\\mathbf{r}_2 = (1.120, 0.221, 0.903)$,\n  $\\mathbf{r}_3 = (0.702, 1.401, 1.520)$,\n  $\\mathbf{r}_4 = (1.690, 0.950, 0.250)$,\n  $\\mathbf{r}_5 = (0.330, 0.780, 1.730)$,\n  $\\mathbf{r}_6 = (1.870, 1.620, 1.110)$,\n  $\\mathbf{r}_7 = (0.520, 1.420, 0.310)$,\n  $\\mathbf{r}_8 = (1.300, 0.070, 1.800)$,\n  $\\mathbf{r}_9 = (0.990, 1.910, 0.990)$,\n  $\\mathbf{r}_{10} = (0.240, 0.400, 0.120)$,\n  $\\mathbf{r}_{11} = (1.560, 1.250, 0.780)$,\n  $\\mathbf{r}_{12} = (0.050, 0.950, 1.450)$.\n- 情况 2（因网格粗糙而易混叠）：与情况1相同的$L$、电荷和位置，但 $M = 8$。\n- 情况 3（公度位置）：$L = 2.0$, $M = 16$, $N = 12$, 电荷 $q = [1,1,1,1,1,1,-1,-1,-1,-1,-1,-1]$, 位置：\n  $\\mathbf{r}_1 = (0.5, 0.5, 0.5)$,\n  $\\mathbf{r}_2 = (1.5, 0.5, 0.5)$,\n  $\\mathbf{r}_3 = (0.5, 1.5, 0.5)$,\n  $\\mathbf{r}_4 = (0.5, 0.5, 1.5)$,\n  $\\mathbf{r}_5 = (1.5, 1.5, 0.5)$,\n  $\\mathbf{r}_6 = (1.5, 0.5, 1.5)$,\n  $\\mathbf{r}_7 = (0.5, 1.5, 1.5)$,\n  $\\mathbf{r}_8 = (1.5, 1.5, 1.5)$,\n  $\\mathbf{r}_9 = (1.0, 0.5, 0.5)$,\n  $\\mathbf{r}_{10} = (0.5, 1.0, 0.5)$,\n  $\\mathbf{r}_{11} = (0.5, 0.5, 1.0)$,\n  $\\mathbf{r}_{12} = (1.0, 1.0, 1.0)$.\n\n对于每种情况，评估插值阶数 $p \\in \\{2,4\\}$ 的诊断结果，为每个 $p$ 和每种情况生成一对值 $(R(p), E(p))$。最终输出格式必须将所有情况和阶数的结果汇总到一行文本中，形式为方括号内以逗号分隔的列表，顺序如下：\n$[R_{1,2}, R_{1,4}, E_{1,2}, E_{1,4}, R_{2,2}, R_{2,4}, E_{2,2}, E_{2,4}, R_{3,2}, R_{3,4}, E_{3,2}, E_{3,4}]$。\n所有数值输出必须报告为上述约化单位约定下的无量纲浮点数。", "solution": "该问题要求实现并评估两种诊断工具，用于评估长程静电作用的质点网格埃瓦尔德 (PME) 方法中的混叠和分配误差。所采用的方法是计算一个精确的参考结构因子和力，并将其与从网格化电荷导出的PME近似对应物进行比较。\n\n### 理论框架与算法设计\n\n一个体积为 $V=L^3$ 的晶胞中，包含 $N$ 个位于位置 $\\{\\mathbf{r}_j\\}$ 的点电荷 $\\{q_j\\}$ 的周期性系统的静电能，可以使用埃瓦尔德求和进行计算。该方法将相互作用划分为短程实空间求和与长程倒易空间求和。倒易空间能量由结构因子决定，定义为：\n$$S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$$\n其中 $\\mathbf{k} = 2\\pi \\mathbf{n}/L$（$\\mathbf{n}$ 为整数矢量）是倒易晶格矢量。\n\nPME方法通过首先将电荷分配到一个 $M^3$ 个点的均匀网格上来近似 $S(\\mathbf{k})$。这产生了一个网格化电荷密度 $\\rho(\\mathbf{x})$。然后使用快速傅里叶变换 (FFT) 计算 $G(\\mathbf{k}) = \\mathcal{F}[\\rho(\\mathbf{x})]$。在数学上，分配过程对应于将真实的电荷分布与一个插值核（一个 $p$ 阶B样条）进行卷积。在傅里叶空间中，这个卷积变成与一个窗函数 $W(\\mathbf{k})$ 的乘积。为了恢复结构因子，必须执行反卷积：\n$$S_{\\mathrm{est}}(\\mathbf{k}) = \\frac{G(\\mathbf{k})}{W(\\mathbf{k})}$$\n问题指定了 $p$ 阶基数B样条的窗函数近似：\n$$W(\\mathbf{k}) = \\prod_{\\mu \\in \\{x,y,z\\}} \\left( \\frac{\\sin(k_\\mu h/2)}{k_\\mu h/2} \\right)^p = \\prod_{\\mu \\in \\{x,y,z\\}} \\mathrm{sinc}(k_\\mu h/2)^p$$\n其中 $h=L/M$ 是网格间距。为了防止在 $W(\\mathbf{k})$ 接近零时出现数值不稳定性，如果 $|W(\\mathbf{k})|  \\varepsilon = 10^{-12}$，则将 $S_{\\mathrm{est}}(\\mathbf{k})$ 设为 0。\n\n电荷分配使用问题陈述中指定的 $p=2$（线性插值，Cloud-In-Cell）和 $p=4$（分段三次样条）阶的基数B样条。对于一个标度化坐标为 $(s_x, s_y, s_z) = (\\mathbf{r}/L) M$ 的粒子，我们找到其基准整数网格索引 $\\mathbf{i} = \\lfloor \\mathbf{s} \\rfloor$ 和小数坐标 $\\mathbf{u} = \\mathbf{s} - \\mathbf{i}$。然后根据一维样条权重的乘积将电荷 $q_j$ 分配到 $p^3$ 个相邻的网格点上，这些权重是 $\\mathbf{u}$ 的函数。\n\n粒子 $i$ 上的倒易空间力由能量导出，并由以下公式给出：\n$$\\mathbf{F}_i^{(k)} = -\\frac{4 \\pi q_i}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-k^2/(4 \\alpha^2)}}{k^2} \\, \\mathrm{Im}\\left(e^{-i \\mathbf{k} \\cdot \\mathbf{r}_i} S(\\mathbf{k})\\right) \\, \\mathbf{k}$$\n其中 $\\alpha$ 是埃瓦尔德分裂参数，这里设为 $\\alpha = 3.5 / L$。参考力 $\\mathbf{F}_i^{(k)}[S]$ 使用精确的 $S(\\mathbf{k})$ 计算，而PME力 $\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}]$ 使用近似的 $S_{\\mathrm{est}}(\\mathbf{k})$。求和是在 $M \\times M \\times M$ FFT网格支持的所有非零倒易矢量 $\\mathbf{k}$ 上进行的。\n\n### 诊断指标\n\n计算了两个诊断指标来量化PME近似引入的误差。\n\n1.  **高$k$谱诊断，$R(p)$**：\n    $$R(p) := \\frac{\\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{high}}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}{\\sum_{\\mathbf{k} \\neq \\mathbf{0}} |S_{\\mathrm{est}}(\\mathbf{k})|^2}$$\n    来自电荷分配和混叠（即真实电荷密度的高频分量折叠到网格频率范围内）的误差主要表现为大波矢处的噪声。该指标量化了估计结构因子谱高频部分的相对功率。集合 $\\mathcal{K}_{\\mathrm{high}}$ 包括幅度为 $k = \\|\\mathbf{k}\\| \\ge k_{\\mathrm{thresh}}$ 的波矢，其中 $k_{\\mathrm{thresh}} = r_{\\mathrm{frac}} \\, k_{\\mathrm{max}}$。我们使用 $r_{\\mathrm{frac}}=0.7$，并将径向奈奎斯特幅度定义为 $k_{\\mathrm{max}} = \\sqrt{3}\\pi/h$，对应于网格第一布里渊区的角落。较大的 $R(p)$ 表示更显著的高频伪影。\n\n2.  **力噪声诊断，$E(p)$**：\n    $$E(p) := \\sqrt{\\frac{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}] - \\mathbf{F}_i^{(k)}[S]\\|^2}{\\sum_{i=1}^{N} \\|\\mathbf{F}_i^{(k)}[S]\\|^2}}$$\n    这是倒易空间力的归一化均方根误差。它直接衡量了PME近似对物理上至关重要的粒子间力这一物理量的影响。较大的 $E(p)$ 意味着力计算的准确性较低。\n\n### 实现摘要\n\n对于每个测试案例和插值阶数 $p$，算法按以下步骤进行：\n\n1.  **网格设置**：基于盒子长度 $L$ 和网格大小 $M$ 构建一个 $M \\times M \\times M$ 的倒易矢量 $\\mathbf{k}$ 网格。预先计算其幅度 $k$ 和平方幅度 $k^2$。\n2.  **精确结构因子 $S(\\mathbf{k})$**：对于网格上的所有 $\\mathbf{k}$，使用其定义直接从粒子位置和电荷计算 $S(\\mathbf{k})$。\n3.  **估计结构因子 $S_{\\mathrm{est}}(\\mathbf{k})$**：\n    a. **电荷分配**：创建一个空的 $M^3$ 网格 $\\rho$。使用指定的B样条权重将每个粒子的电荷分配到其 $p^3$ 个相邻的网格点上。对网格索引应用周期性边界条件。\n    b. **FFT**：计算电荷网格的FFT，$G(\\mathbf{k}) = \\mathcal{F}[\\rho]$。\n    c. **反卷积**：计算窗函数 $W(\\mathbf{k})$。然后通过将 $G(\\mathbf{k})$ 除以 $W(\\mathbf{k})$ 来找到 $S_{\\mathrm{est}}(\\mathbf{k})$，并应用数值保护措施。\n4.  **诊断计算**：\n    a. **$R(p)$**：在高$k$区域和整个非零谱上对平方模 $|S_{\\mathrm{est}}(\\mathbf{k})|^2$ 进行求和，以计算比率。\n    b. **$E(p)$**：通过在倒易晶格上求和，为所有粒子计算参考力 $\\mathbf{F}_i^{(k)}[S]$ 和PME力 $\\mathbf{F}_i^{(k)}[S_{\\mathrm{est}}]$。然后计算归一化的RMS误差 $E(p)$。\n\n针对三个指定的测试案例，改变网格大小 $M$ 和粒子构型，并对插值阶数 $p=2$ 和 $p=4$ 进行计算。然后将结果汇总成指定的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to run the PME diagnostics for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 2.0, \"M\": 16, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.147, 1.835, 0.410], [1.120, 0.221, 0.903], [0.702, 1.401, 1.520],\n                [1.690, 0.950, 0.250], [0.330, 0.780, 1.730], [1.870, 1.620, 1.110],\n                [0.520, 1.420, 0.310], [1.300, 0.070, 1.800], [0.990, 1.910, 0.990],\n                [0.240, 0.400, 0.120], [1.560, 1.250, 0.780], [0.050, 0.950, 1.450]\n            ])\n        },\n        {\n            \"L\": 2.0, \"M\": 8, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.147, 1.835, 0.410], [1.120, 0.221, 0.903], [0.702, 1.401, 1.520],\n                [1.690, 0.950, 0.250], [0.330, 0.780, 1.730], [1.870, 1.620, 1.110],\n                [0.520, 1.420, 0.310], [1.300, 0.070, 1.800], [0.990, 1.910, 0.990],\n                [0.240, 0.400, 0.120], [1.560, 1.250, 0.780], [0.050, 0.950, 1.450]\n            ])\n        },\n        {\n            \"L\": 2.0, \"M\": 16, \"N\": 12,\n            \"charges\": np.array([1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1]),\n            \"positions\": np.array([\n                [0.5, 0.5, 0.5], [1.5, 0.5, 0.5], [0.5, 1.5, 0.5], [0.5, 0.5, 1.5],\n                [1.5, 1.5, 0.5], [1.5, 0.5, 1.5], [0.5, 1.5, 1.5], [1.5, 1.5, 1.5],\n                [1.0, 0.5, 0.5], [0.5, 1.0, 0.5], [0.5, 0.5, 1.0], [1.0, 1.0, 1.0]\n            ])\n        }\n    ]\n\n    orders = [2, 4]\n    results = []\n\n    for case in test_cases:\n        case_results = {}\n        for p in orders:\n            R_p, E_p = calculate_diagnostics(case[\"L\"], case[\"M\"], case[\"charges\"], case[\"positions\"], p)\n            case_results[f\"R_{p}\"] = R_p\n            case_results[f\"E_{p}\"] = E_p\n        results.extend([case_results[\"R_2\"], case_results[\"R_4\"], case_results[\"E_2\"], case_results[\"E_4\"]])\n    \n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\ndef calculate_diagnostics(L, M, charges, positions, p, alpha_factor=3.5, deconv_eps=1e-12, r_frac=0.7):\n    \"\"\"Calculates R(p) and E(p) for a given system and interpolation order.\"\"\"\n    N = len(charges)\n    V = L**3\n    h = L / M\n    alpha = alpha_factor / L\n\n    # 1. Setup k-space grid\n    n = np.fft.fftfreq(M, d=1.0/M)\n    kx_v = 2 * np.pi * n / L\n    kx, ky, kz = np.meshgrid(kx_v, kx_v, kx_v, indexing='ij')\n    k2 = kx**2 + ky**2 + kz**2\n    k_mag = np.sqrt(k2)\n\n    # 2. Calculate exact S(k)\n    Sk_exact = np.zeros((M, M, M), dtype=np.complex128)\n    for q_j, r_j in zip(charges, positions):\n        k_dot_r = kx * r_j[0] + ky * r_j[1] + kz * r_j[2]\n        Sk_exact += q_j * np.exp(1j * k_dot_r)\n\n    # 3. Calculate estimated S(k) via PME\n    # 3a. Charge assignment\n    rho = np.zeros((M, M, M))\n    for q_j, r_j in zip(charges, positions):\n        scaled_pos = r_j * M / L\n        base_indices = np.floor(scaled_pos).astype(int)\n        frac_coords = scaled_pos - base_indices\n\n        if p == 2:\n            offsets = range(p)\n            stencil_shift = 0\n            u_vals = frac_coords\n            weights_1d = [\n                1 - u_vals,\n                u_vals\n            ]\n        elif p == 4:\n            offsets = range(p)\n            stencil_shift = -1\n            u = frac_coords\n            u2 = u**2\n            u3 = u**3\n            weights_1d = [\n                (1/6) * (1 - u)**3,\n                (1/6) * (4 - 6*u2 + 3*u3),\n                (1/6) * (1 + 3*u + 3*u2 - 3*u3),\n                (1/6) * u3\n            ]\n        else:\n            raise ValueError(\"Only p=2 and p=4 are supported.\")\n\n        wx = np.array([w[0] for w in weights_1d])\n        wy = np.array([w[1] for w in weights_1d])\n        wz = np.array([w[2] for w in weights_1d])\n\n        for i_off in offsets:\n            ix = (base_indices[0] + i_off + stencil_shift) % M\n            for j_off in offsets:\n                iy = (base_indices[1] + j_off + stencil_shift) % M\n                for k_off in offsets:\n                    iz = (base_indices[2] + k_off + stencil_shift) % M\n                    weight = wx[i_off] * wy[j_off] * wz[k_off]\n                    rho[ix, iy, iz] += q_j * weight\n\n    # 3b. FFT\n    Gk = np.fft.fftn(rho)\n\n    # 3c. Deconvolution\n    def my_sinc(x):\n        return np.divide(np.sin(x), x, out=np.ones_like(x, dtype=float), where=x != 0)\n\n    arg_x, arg_y, arg_z = kx * h / 2, ky * h / 2, kz * h / 2\n    Wk = (my_sinc(arg_x) * my_sinc(arg_y) * my_sinc(arg_z))**p\n    \n    Sk_est = np.zeros_like(Gk)\n    safe_indices = np.abs(Wk) >= deconv_eps\n    Sk_est[safe_indices] = Gk[safe_indices] / Wk[safe_indices]\n    \n    # 4. Calculate R(p)\n    is_k_not_zero = (k2 != 0)\n    Sk_est_sq_mag = np.abs(Sk_est)**2\n    \n    k_max = np.sqrt(3) * np.pi / h\n    k_thresh = r_frac * k_max\n    \n    high_k_mask = (k_mag >= k_thresh)  is_k_not_zero\n    \n    numerator_R = np.sum(Sk_est_sq_mag[high_k_mask])\n    denominator_R = np.sum(Sk_est_sq_mag[is_k_not_zero])\n    R_p = numerator_R / denominator_R if denominator_R != 0 else 0\n\n    # 5. Calculate E(p)\n    Ck = -4 * np.pi / V * np.exp(-k2 / (4 * alpha**2))\n    Ck = np.divide(Ck, k2, out=np.zeros_like(Ck), where=is_k_not_zero)\n\n    sum_sq_diff_F = 0.0\n    sum_sq_F_ref = 0.0\n    for i in range(N):\n        q_i, r_i = charges[i], positions[i]\n        \n        k_dot_r = kx*r_i[0] + ky*r_i[1] + kz*r_i[2]\n        exp_minus_ik_dot_r = np.exp(-1j * k_dot_r)\n        \n        term_ref = np.imag(exp_minus_ik_dot_r * Sk_exact)\n        term_est = np.imag(exp_minus_ik_dot_r * Sk_est)\n        \n        F_ref_vec = q_i * Ck * term_ref\n        F_est_vec = q_i * Ck * term_est\n\n        F_ref = np.array([np.sum(F_ref_vec * kx), np.sum(F_ref_vec * ky), np.sum(F_ref_vec * kz)])\n        F_est = np.array([np.sum(F_est_vec * kx), np.sum(F_est_vec * ky), np.sum(F_est_vec * kz)])\n\n        sum_sq_diff_F += np.sum((F_est - F_ref)**2)\n        sum_sq_F_ref += np.sum(F_ref**2)\n        \n    E_p = np.sqrt(sum_sq_diff_F / sum_sq_F_ref) if sum_sq_F_ref != 0 else 0\n    \n    return R_p, E_p\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3462216"}]}