{"hands_on_practices": [{"introduction": "本练习是理解投影缀加波 (PAW) 方法的基石。它要求您从第一性原理出发，亲手实现将平面波 Bloch 态投影到局域原子投影函数上的过程，这是连接光滑赝波函数与全电子波函数的核心步骤。通过推导并编写此过程，您将具体地理解 PAW 方法的核心变换在数学和数值上是如何实现的。[@problem_id:3480864]", "problem": "您需要从第一性原理出发，在投影缀加波（PAW）方法中，实现单个平面波布洛赫态到以原子为中心的投影函数上的投影，然后为晶胞中的每个原子组装相应的占据矩阵。投影缀加波（PAW）方法使用以原子为中心的投影函数 $p_{a,i}(\\mathbf{r})$，这些函数局域在由 $a$ 索引的每个原子周围，其中 $i$ 枚举了该原子的一组有限的、按角动量分辨的投影 $(l,m)$。给定一个波矢 $\\mathbf{k}$ 和一个或多个由倒格矢 $\\mathbf{G}_{n}$ 表征的平面波态，布洛赫波矢为 $\\mathbf{K}_{n} = \\mathbf{k} + \\mathbf{G}_{n}$。对于原子 $a$、投影 $i$ 和能带指数 $n$ 的交叠振幅 $c_{a,i,n}$ 由积分 $c_{a,i,n} = \\int_{\\mathbb{R}^{3}} p_{a,i}^{*}(\\mathbf{r} - \\mathbf{R}_{a}) \\exp\\left(i \\mathbf{K}_{n} \\cdot \\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}$ 定义，而按原子分辨的占据矩阵为 $D^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i,n} \\, c_{a,j,n}^{*}$，其中 $f_{n}$ 是能带 $n$ 的占据数。您必须计算并报告所有原子及其投影的占据矩阵的实部 $\\operatorname{Re} D^{a}_{ij}$。\n\n您的推导和实现应基于以下科学上标准且经过充分检验的要素：\n- 平面波布洛赫态 $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$ 的定义。\n- 单位球面上球谐函数 $Y_{l}^{m}(\\hat{\\mathbf{r}})$ 的正交归一性。\n- 平面波在球谐函数和球贝塞尔函数中的展开，以及球贝塞尔函数 $j_{l}(x)$ 的性质。\n- 使用带有高斯径向包络的角动量通道构建局域化投影形状。\n\n请使用以下物理上自洽且独立的规范来定义投影函数。对于每个原子 $a$ 和由角动量指数 $(l,m)$ 定义的投影，使用\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$, $\\hat{\\mathbf{r}} = \\mathbf{r}/r$，且 $N_{l}$ 是一个归一化常数，其选择需满足\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1,\n$$\n其中 $\\mathrm{d}\\Omega$ 是立体角元，$\\sigma_{a} > 0$ 是原子 $a$ 的径向宽度参数。$N_{l}$ 的归一化必须从此条件推导得出。\n\n您的实现必须：\n1. 从第一性原理出发，利用平面波的球谐展开和球谐函数的正交性，推导交叠振幅 $c_{a,lm,n}$，将三维积分简化为涉及球贝塞尔函数 $j_{l}(x)$ 和径向包络 $r^{l}\\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)$ 的一维径向积分。\n2. 实现径向积分的数值稳定计算。如果 $\\lVert \\mathbf{K}_{n} \\rVert = 0$，正确处理极限情况，避免未定义的角量。当 $\\lVert \\mathbf{K}_{n} \\rVert > 0$ 时，使用 $\\mathbf{K}_{n}$ 的方向计算所需的球谐函数因子。\n3. 组装每个原子的占据矩阵 $D^{a}_{ij}$ 并返回其实部 $\\operatorname{Re} D^{a}_{ij}$。\n\n角度必须以弧度为单位。位置以埃（$\\mathrm{\\AA}$）为单位，波矢以逆埃（$\\mathrm{\\AA}^{-1}$）为单位，最终的占据矩阵元素是无量纲的。您的程序必须以浮点数形式生成数值输出。\n\n测试套件规范：\n使用以下三个测试用例。在所有用例中，晶胞为简单立方，晶格常数 $a = 5.0\\,\\mathrm{\\AA}$。每个晶胞有两个原子：\n- 原子 $0$ 位于 $\\mathbf{R}_{0} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}$，$\\sigma_{0} = 0.8\\,\\mathrm{\\AA}$。\n- 原子 $1$ 位于 $\\mathbf{R}_{1} = \\left(\\frac{a}{2},\\,\\frac{a}{2},\\,\\frac{a}{2}\\right)\\,\\mathrm{\\AA}$，$\\sigma_{1} = 0.8\\,\\mathrm{\\AA}$。\n\n对于每个原子，按 $(0,0)$、$(1,-1)$、$(1,0)$、$(1,1)$ 的固定顺序定义四个投影，其指数 $(l,m)$ 分别为这四对值。\n\n令 $G_{x} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$ 且 $G_{z} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$。\n\n- 用例 $1$（一般情况）：$\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$，两个能带，分别为 $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$ 和 $(\\mathbf{G}_{1},f_{1}) = ((G_{x},0,0)\\,\\mathrm{\\AA}^{-1},\\,0.5)$。\n- 用例 $2$（边界 $\\Gamma$ 点）：$\\mathbf{k} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}^{-1}$，一个能带，为 $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$。\n- 用例 $3$（方向性边缘情况）：$\\mathbf{k} = (0.0,\\,0.0,\\,0.5)\\,\\mathrm{\\AA}^{-1}$，两个能带，分别为 $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,0.3)$ 和 $(\\mathbf{G}_{1},f_{1}) = ((0,0,-G_{z})\\,\\mathrm{\\AA}^{-1},\\,0.3)$。\n\n输出规范：\n对于上述顺序的每个测试用例，并对每个原子 $a$（先 $a=0$ 后 $a=1$），使用固定顺序 $(0,0)$、$(1,-1)$、$(1,0)$、$(1,1)$ 的投影形成 $4\\times 4$ 矩阵 $D^{a}_{ij}$ 的实部。将每个矩阵按行主序展平成一个长度为 16 的浮点数列表。将原子 $0$ 和原子 $1$ 的列表串联起来，然后将三个测试用例的结果串联起来。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[x_{1},x_{2},\\dots,x_{96}]$，其中 $96$ 是浮点条目的总数（$3$ 个用例 $\\times$ $2$ 个原子 $\\times$ 每个矩阵 $16$ 个条目）。\n\n您的程序必须是自包含的，不需要用户输入，并且可以直接运行。它必须使用所述方法计算占据矩阵并返回指定的输出格式。输出中的所有数值均为无量纲，且必须表示为浮点数。", "solution": "我们从支撑投影缀加波 (PAW) 方法的标准化定义开始。对于位于位置 $\\mathbf{R}_{a}$ 的每个原子 $a$，我们有一组在实空间上定义的投影函数 $p_{a,lm}(\\mathbf{r})$，其角动量指数为 $(l,m)$。波矢为 $\\mathbf{K}$ 的平面波布洛赫态由 $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$ 给出。平面波到以 $\\mathbf{R}_{a}$ 为中心的投影函数上的投影系数 $c_{a,lm}$ 由以下积分定义：\n$$\nc_{a,lm}(\\mathbf{K}) = \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}-\\mathbf{R}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}.\n$$\n进行变量替换 $\\mathbf{r} = \\mathbf{R}_{a} + \\mathbf{r}_{a}$，得到\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}_{a}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}_{a}.\n$$\n我们将投影函数指定为\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$ 且 $\\hat{\\mathbf{r}} = \\mathbf{r}/r$。选择归一化常数 $N_{l}$ 以满足\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1.\n$$\n由于 $\\int_{\\Omega} \\left|Y_{l}^{m}(\\hat{\\mathbf{r}})\\right|^{2} \\,\\mathrm{d}\\Omega = 1$，归一化条件简化为\n$$\nN_{l}^{2} \\int_{0}^{\\infty} r^{2+2l} \\exp\\!\\left(-2\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)\\,\\mathrm{d}r = 1.\n$$\n令 $\\alpha = \\frac{2}{\\sigma_{a}^{2}}$，我们使用标准积分 $\\int_{0}^{\\infty} r^{n} e^{-\\alpha r^{2}} \\,\\mathrm{d}r = \\frac{1}{2} \\alpha^{-(n+1)/2} \\Gamma\\!\\left(\\frac{n+1}{2}\\right)$（对于 $n > -1$），得到\n$$\nN_{l} = \\left[\\frac{1}{2} \\left(\\frac{2}{\\sigma_{a}^{2}}\\right)^{-\\frac{3+2l}{2}} \\Gamma\\!\\left(\\frac{3+2l}{2}\\right)\\right]^{-1/2}.\n$$\n\n为了计算交叠积分，我们引入平面波的球谐展开，这是散射理论中一个经过充分检验的公式：\n$$\n\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 4\\pi \\sum_{l'=0}^{\\infty}\\sum_{m'=-l'}^{l'} i^{\\,l'} j_{l'}(K r) Y_{l'}^{m'}(\\hat{\\mathbf{r}}) Y_{l'}^{m'*}(\\hat{\\mathbf{K}}),\n$$\n其中 $K = \\lVert \\mathbf{K} \\rVert$，$j_{l}(x)$ 是球贝塞尔函数，$Y_{l}^{m}$ 是球谐函数。利用 $Y_{l}^{m}$ 的正交归一性，角向积分得以简化，得到\n$$\n\\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}) \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r} = 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, j_{l}(K r) \\,\\mathrm{d}r.\n$$\n因此，\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\, 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\, I_{l}(K;\\sigma_{a}),\n$$\n其中径向积分为\n$$\nI_{l}(K;\\sigma) = \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) j_{l}(K r) \\,\\mathrm{d}r.\n$$\n\n$K=0$ 的特殊情况：我们有 $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 1$，积分变为\n$$\nc_{a,lm}(\\mathbf{0}) = \\int p_{a,lm}^{*}(\\mathbf{r}) \\,\\mathrm{d}^{3}\\mathbf{r} = N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r \\int_{\\Omega} Y_{l}^{m*}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega.\n$$\n使用 $\\int_{\\Omega} Y_{l}^{m}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega = \\sqrt{4\\pi} \\, \\delta_{l0} \\delta_{m0}$ 和 $j_{0}(0) = 1$（$l>0$ 时 $j_{l}(0) = 0$），我们发现\n$$\nc_{a,00}(\\mathbf{0}) = \\sqrt{4\\pi} \\, N_{0} \\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r,\n$$\n且对于 $l>0$，$c_{a,lm}(\\mathbf{0}) = 0$。在 $K=0$ 时，$l=0$ 的径向积分计算为\n$$\n\\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) \\,\\mathrm{d}r = \\sigma^{3} \\int_{0}^{\\infty} u^{2} e^{-u^{2}} \\,\\mathrm{d}u = \\sigma^{3} \\frac{\\sqrt{\\pi}}{4}.\n$$\n\n占据矩阵：给定由指数 $n$ 标记的能带，其占据数为 $f_{n}$，波矢为 $\\mathbf{K}_{n}$，我们构建\n$$\nD^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i}(\\mathbf{K}_{n}) \\, c_{a,j}^{*}(\\mathbf{K}_{n}),\n$$\n该矩阵根据其构造是厄米（Hermitian）的。我们需要报告 $\\operatorname{Re} D^{a}_{ij}$。\n\n算法实现细节：\n1. 对于每个投影角动量 $l$ 和原子宽度 $\\sigma_{a}$，使用上面的伽马函数公式计算 $N_{l}$。\n2. 对于每个能带波矢 $\\mathbf{K}_{n}$：\n   - 如果 $K_{n} = \\lVert \\mathbf{K}_{n} \\rVert$ 大于一个小的阈值（例如 $10^{-12}$），则从 $\\hat{\\mathbf{K}}_{n} = \\mathbf{K}_{n}/K_{n}$ 计算极角 $(\\theta,\\phi)$，使用 $\\theta = \\arccos(K_{z}/K)$ 和 $\\phi = \\operatorname{atan2}(K_{y},K_{x})$。计算 $Y_{l}^{m}(\\hat{\\mathbf{K}})$ 及其复共轭，并通过一维数值积分法计算径向积分 $I_{l}(K;\\sigma)$。一个实际的积分上限是 $r_{\\max} = 12\\,\\sigma$，因为高斯包络会抑制更大的半径。使用高精度积分程序和球贝塞尔函数 $j_{l}$。\n   - 如果 $K_{n}$ 低于阈值，则使用特殊情况下的公式：如上所示，只有 $(l=0,m=0)$ 的投影具有非零交叠，并且 $c_{a,00}(\\mathbf{0})$ 是解析计算的。所有 $l>0$ 的通道在此极限下交叠为零。\n   - 乘以相位因子 $\\exp\\left(i \\mathbf{K}_{n}\\cdot \\mathbf{R}_{a}\\right)$ 和常数预因子，得到 $c_{a,lm,n}$。\n3. 通过对所有能带 $n$ 求和 $f_{n} c_{a,i,n} c_{a,j,n}^{*}$ 来组装 $D^{a}_{ij}$。\n4. 提取并报告 $\\operatorname{Re} D^{a}_{ij}$，将每个 $4\\times 4$ 矩阵按行主序展平。\n\n单位和数值考虑：\n- 位置 $\\mathbf{R}_{a}$ 以 $\\mathrm{\\AA}$ 为单位，波矢 $\\mathbf{K}_{n}$ 以 $\\mathrm{\\AA}^{-1}$ 为单位，角度以弧度为单位，最终的占据矩阵元素是无量纲的。\n- 球谐函数使用与标准科学库一致的 Condon–Shortley 相位约定进行计算。\n- 数值积分应使用绝对和相对容差以确保径向积分的稳定性。高斯衰减使积分成为良态问题；将积分范围限制在 $[0,12\\sigma]$ 就足够了。\n\n测试套件执行：\n- 用例 $1$ 使用 $\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$ 和位于 $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$（$f_{0}=1.0$）以及 $\\mathbf{G}_{1}=(2\\pi/a,0,0)\\,\\mathrm{\\AA}^{-1}$（$f_{1}=0.5$）的能带。\n- 用例 $2$ 使用 $\\Gamma$ 点 $\\mathbf{k}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ 和单个能带 $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$（$f_{0}=1.0$）；只有 $l=0$ 有贡献。\n- 用例 $3$ 使用 $\\mathbf{k}=(0,0,0.5)\\,\\mathrm{\\AA}^{-1}$ 和能带 $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ 和 $\\mathbf{G}_{1}=(0,0,-2\\pi/a)\\,\\mathrm{\\AA}^{-1}$，占据数分别为 $f_{0}=0.3$ 和 $f_{1}=0.3$，用于探测 $Y_{l}^{m}(\\hat{\\mathbf{K}})$ 的方向敏感性。\n\n输出必须是单个用方括号括起来的逗号分隔列表，按指定顺序串联每个用例中原子 $a=0$ 和 $a=1$ 的 $D^{a}_{ij}$ 实部的展平结果，最终得到 $96$ 个浮点条目。程序必须是自包含的，并在运行时产生这一行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, pi, acos, atan2, isclose, gamma\nfrom scipy.special import sph_harm, spherical_jn\nfrom scipy.integrate import quad\n\ndef normalization_Nl(l: int, sigma: float) -> float:\n    \"\"\"\n    Compute the normalization constant N_l for the projector radial function:\n    p_{lm}(r) = N_l * r^l * exp(-(r/sigma)^2) * Y_l^m(Ω),\n    such that ∫ |p|^2 r^2 dr dΩ = 1.\n\n    N_l^2 ∫_0^∞ r^{2+2l} exp(-2 (r/sigma)^2) dr = 1\n    Using ∫_0^∞ r^n e^{-α r^2} dr = (1/2) α^{-(n+1)/2} Γ((n+1)/2)\n    with α = 2/sigma^2, n = 2 + 2l.\n    \"\"\"\n    alpha = 2.0 / (sigma**2)\n    n = 2 + 2*l\n    integral = 0.5 * (alpha ** (-(n + 1) / 2.0)) * gamma((n + 1) / 2.0)\n    Nl = 1.0 / sqrt(integral)\n    return Nl\n\ndef K_angles(Kvec: np.ndarray):\n    \"\"\"\n    Compute spherical angles (theta, phi) for direction of Kvec.\n    theta in [0, π], phi in [-π, π].\n    \"\"\"\n    Knorm = np.linalg.norm(Kvec)\n    if Knorm < 1e-14:\n        # Undefined direction; caller should handle K=0 separately.\n        return None, None, 0.0\n    kx, ky, kz = Kvec\n    theta = np.arccos(kz / Knorm)\n    phi = np.arctan2(ky, kx)\n    return theta, phi, Knorm\n\ndef radial_integral_Il(l: int, K: float, sigma: float) -> float:\n    \"\"\"\n    Compute I_l(K; sigma) = ∫_0^∞ r^{2+l} exp(-(r/sigma)^2) j_l(K r) dr\n    Numerically via quadrature over [0, Rmax], where Rmax = 12*sigma.\n    Special-case: if K == 0, then j_0(0) = 1 and j_l(0) = 0 for l>0.\n    \"\"\"\n    if K < 1e-14:\n        if l == 0:\n            # Analytic integral: ∫ r^2 exp(-(r/sigma)^2) dr = sigma^3 * sqrt(pi)/4\n            return (sigma**3) * (sqrt(pi) / 4.0)\n        else:\n            return 0.0\n    Rmax = 12.0 * sigma\n    # Integrand for quadrature\n    def integrand(r):\n        return (r**(2 + l)) * np.exp(-(r/sigma)**2) * spherical_jn(l, K * r)\n    val, err = quad(integrand, 0.0, Rmax, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return val\n\ndef overlap_coefficient(atom_R: np.ndarray, l: int, m: int, sigma: float, Kvec: np.ndarray, Nl: float) -> complex:\n    \"\"\"\n    Compute c_{a,lm}(K) = e^{i K·R_a} * 4π * i^l * Y_l^m*(K̂) * N_l * I_l(K; sigma)\n    with appropriate handling of K=0 special case.\n    \"\"\"\n    theta, phi, Knorm = K_angles(Kvec)\n    phase = np.exp(1j * np.dot(Kvec, atom_R))\n    if Knorm < 1e-14:\n        # Special-case: only l=0,m=0 contributes\n        if l == 0 and m == 0:\n            I0 = radial_integral_Il(0, 0.0, sigma)\n            # Angular integral gives √(4π)\n            return phase * (sqrt(4.0 * pi) * Nl * I0)\n        else:\n            return 0.0 + 0.0j\n    # Directional spherical harmonic factor Y_l^m*(K̂)\n    Ylm = sph_harm(m, l, phi, theta)  # sph_harm returns Y_l^m(φ, θ)\n    Ylm_conj = np.conj(Ylm)\n    Il = radial_integral_Il(l, Knorm, sigma)\n    coeff = phase * (4.0 * pi) * ((1j) ** l) * Ylm_conj * Nl * Il\n    return coeff\n\ndef build_D_matrix_for_atom(atom_R: np.ndarray, sigma: float, projectors: list, bands: list) -> np.ndarray:\n    \"\"\"\n    Build D^a_{ij} for one atom.\n    projectors: list of (l, m) pairs in fixed order.\n    bands: list of dicts {'K': np.array, 'f': float}\n    Returns real part of 4x4 D matrix as numpy array.\n    \"\"\"\n    # Precompute N_l per l value to avoid repeated normalization\n    unique_ls = sorted(set([l for (l, m) in projectors]))\n    Nl_map = {l: normalization_Nl(l, sigma) for l in unique_ls}\n    # Compute overlaps c_i,n for each projector i and band n\n    num_proj = len(projectors)\n    num_bands = len(bands)\n    c = np.zeros((num_proj, num_bands), dtype=np.complex128)\n    for i, (l, m) in enumerate(projectors):\n        Nl = Nl_map[l]\n        for n, band in enumerate(bands):\n            Kvec = band['K']\n            c[i, n] = overlap_coefficient(atom_R, l, m, sigma, Kvec, Nl)\n    # Assemble D_ij = sum_n f_n c_i,n c_j,n^*\n    D = np.zeros((num_proj, num_proj), dtype=np.complex128)\n    for n, band in enumerate(bands):\n        f = band['f']\n        cn = c[:, n].reshape((num_proj, 1))\n        D += f * (cn @ np.conj(cn).T)\n    return D.real\n\ndef solve():\n    # Define lattice and atoms\n    a = 5.0  # Angstrom\n    Gx = 2.0 * pi / a  # 1/Angstrom\n    Gz = 2.0 * pi / a  # 1/Angstrom\n\n    atoms = [\n        {'R': np.array([0.0, 0.0, 0.0]), 'sigma': 0.8},\n        {'R': np.array([a/2.0, a/2.0, a/2.0]), 'sigma': 0.8},\n    ]\n\n    # Projectors: fixed order (0,0), (1,-1), (1,0), (1,1)\n    projectors = [(0, 0), (1, -1), (1, 0), (1, 1)]\n\n    # Test cases definition\n    test_cases = [\n        # Case 1: general case\n        {\n            'k': np.array([0.2, 0.0, 0.1]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n                {'G': np.array([Gx, 0.0, 0.0]), 'f': 0.5},\n            ],\n        },\n        # Case 2: Gamma point\n        {\n            'k': np.array([0.0, 0.0, 0.0]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n            ],\n        },\n        # Case 3: directional edge case\n        {\n            'k': np.array([0.0, 0.0, 0.5]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 0.3},\n                {'G': np.array([0.0, 0.0, -Gz]), 'f': 0.3},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        k = case['k']\n        # Form bands as K = k + G\n        bands = []\n        for b in case['bands']:\n            K = k + b['G']\n            bands.append({'K': K, 'f': b['f']})\n        # Compute D matrices for each atom and flatten real parts\n        for atom in atoms:\n            D_real = build_D_matrix_for_atom(atom['R'], atom['sigma'], projectors, bands)\n            # Flatten row-major\n            flat = D_real.flatten(order='C')\n            # Append to results\n            results.extend(flat.tolist())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3480864"}, {"introduction": "在掌握了核心概念之后，本练习将探讨应用 PAW 方法时的一个关键实践问题：计算参数的选择。这个假设性练习旨在模拟赝化半径 $r_c$ 与平面波截断能 $E_{\\text{cut}}$ 之间的权衡关系，揭示更精确的物理描述（更小的 $r_c$）如何导致更高的计算成本（更高的 $E_{\\text{cut}}$）。理解这种相互作用对于执行高效且可靠的密度泛函理论计算至关重要。[@problem_id:3440835]", "problem": "考虑金刚石结构的硅，其中核-价电子分离采用投影缀加波（PAW）方法处理。在 PAW 方法中，赝势化半径 $r_c$ 定义了每个原子周围缀加区域的范围，在该区域内，全电子特征被映射为平滑的赝数量。较小的 $r_c$（通常称为“硬”赝势）能更好地限制缀加区域，但需要更高的平面波能量截断值 $E_{\\text{cut}}$ 来准确表示实空间中的快速变化。您的目标是为硅构建一个由 $r_c$ 参数化的假设性 PAW 数据集族，并分析在均匀应变下 $E_{\\text{cut}}$ 与可移植性之间的相互作用。\n\n从以下基本依据出发：\n- 单粒子电子结构由不含时 Schrödinger 方程决定，并且平面波基组可将动能算符对角化。对于波矢大小为 $G$ 的平面波，其动能为 $E_{\\text{kin}} = \\frac{\\hbar^2 G^2}{2 m_e}$，其中 $\\hbar$ 是约化 Planck 常数，$m_e$ 是电子质量。\n- 为准确表示特征尺寸为 $r_c$ 的实空间特征，平面波展开必须包含大小达到 $G_{\\max}$ 的倒格矢，以解析该特征。一个保守的表示准则是，要求最高可解析的空间频率与半径为 $r_c$ 的球形特征的主要傅里叶分量相当。这暗示了 $G_{\\max}$ 和 $r_c$ 之间存在一种关系，您必须从傅里叶分析中论证这种关系，然后用它通过 $E_{\\text{cut}} = \\frac{\\hbar^2 G_{\\max}^2}{2 m_e}$ 来确定最小 $E_{\\text{cut}}$。\n- 在振幅为 $\\varepsilon$（无量纲，以小数表示，不使用百分号）的微小均匀应变下，由赝势化引起的可移植性误差源于缀加区域内赝散射特性与全电子散射特性之间的不匹配。使用标准的微扰推理来处理应变的主导阶效应：每个原子的能量误差与微扰振幅的平方以及缀加区域尺寸和曲率不匹配的度量成比例。使用形式为 $\\Delta E_{\\text{tr}} \\propto r_c^\\alpha \\varepsilon^2$ 的标度律，对于某个指数 $\\alpha$，您必须对其进行定性论证，并采用一个硅特有的比例常数，以使结果在数值上具体化。\n\n实现要求：\n- 使用玻尔半径作为 $r_c$ 的单位。对于平面波，使用原子单位关系式 $E_{\\text{kin}} = \\frac{G^2}{2}$（哈特里），其中 $G$ 的单位为逆玻尔，能量单位为哈特里，并使用 $1$ 哈特里 $= 27.211386$ 电子伏特将其转换为电子伏特。\n- 对于应变下每个原子的可移植性误差，使用硅的具体校准公式 $\\Delta E_{\\text{tr}} = C_{\\text{Si}} \\, r_c^4 \\, \\varepsilon^2$，其中 $C_{\\text{Si}}$ 是一个常数，其选择使得在实际的 $r_c$ 和 $\\varepsilon$ 下，典型误差在几毫电子伏特的量级。取 $C_{\\text{Si}} = 305.6$ 毫电子伏特/玻尔$^4$。\n- 最终的能量截断值以电子伏特表示，可移植性误差以毫电子伏特表示。将每个能量截断值四舍五入到一位小数，将每个可移植性误差四舍五入到两位小数。\n\n测试组：\n对于下面的每一对 $(r_c,\\varepsilon)$，计算两个输出：表示准则所要求的最小 $E_{\\text{cut}}$（单位为电子伏特）和根据标度律预测的每个原子的可移植性误差（单位为毫电子伏特）：\n1. $r_c = 1.30$ (玻尔), $\\varepsilon = 0.08$。\n2. $r_c = 1.60$ (玻尔), $\\varepsilon = 0.05$。\n3. $r_c = 1.90$ (玻尔), $\\varepsilon = 0.05$。\n4. $r_c = 2.20$ (玻尔), $\\varepsilon = 0.02$。\n5. 边界情况: $r_c = 1.60$ (玻尔), $\\varepsilon = 0.00$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素都是一个包含两项的列表 $[E_{\\text{cut}}~(\\text{eV}), \\Delta E_{\\text{tr}}~(\\text{meV})]$，顺序与测试组一致。例如：[[x1,y1],[x2,y2],...]，其中每个 $x_i$ 和 $y_i$ 都是按上述规定四舍五入的浮点数。", "solution": "目标是量化投影缀加波（PAW）方法中的赝势化半径 $r_c$ 如何同时影响表示缀加区域所需的最小平面波能量截断值 $E_{\\text{cut}}$ 以及赝势在均匀应变下的可移植性。\n\n我们从平面波基组中平面波的动能开始。动能算符可由波矢为 $\\mathbf{G}$ 的平面波对角化，其动能由下式给出\n$$\nE_{\\text{kin}} = \\frac{\\hbar^2 \\, G^2}{2 m_e},\n$$\n其中 $G = \\lVert \\mathbf{G} \\rVert$。在原子单位（哈特里原子单位）中，取 $\\hbar = 1$，$m_e = 1$，该关系简化为\n$$\nE_{\\text{kin}}^{(\\text{Hartree})} = \\frac{G^2}{2}.\n$$\n如果 $G$ 以逆玻尔为单位表示，则 $E_{\\text{kin}}$ 的单位是哈特里。为将哈特里转换为电子伏特，我们使用经过充分检验的常数 $1$ 哈特里 $= 27.211386$ 电子伏特。\n\n为了确定最小 $E_{\\text{cut}}$，我们需要一个足够大的倒易空间截断值 $G_{\\max}$，以解析与半径为 $r_c$ 的缀加区域相关的特征。该启发式方法植根于傅里叶分析：一个半径为 $r_c$ 的球形阶梯状特征具有一个特征傅里叶内容，其主导波长对应的空间频率约为 $G \\sim \\pi / r_c$。这源于球贝塞尔函数 $j_0(G r_c) = \\sin(G r_c)/(G r_c)$ 的振荡行为，该函数表示球形顶帽函数的径向傅里叶变换。$j_0$ 的第一个零点出现在 $G r_c = \\pi$ 处，控制最急剧变化表示的主要傅里叶分量位于该波矢附近。因此，一个保守的表示准则是\n$$\nG_{\\max} \\approx \\frac{\\pi}{r_c}.\n$$\n代入原子单位中的动能表达式，可得\n$$\nE_{\\text{cut}}^{(\\text{Hartree})} = \\frac{1}{2} \\left( \\frac{\\pi}{r_c} \\right)^2,\n$$\n并转换为电子伏特，得到\n$$\nE_{\\text{cut}}^{(\\text{eV})} = 27.211386 \\times \\frac{\\pi^2}{2 r_c^2}.\n$$\n此关系表明，较小的 $r_c$ 会增加 $G_{\\max}$，从而使所需的 $E_{\\text{cut}}$ 大致按 $1/r_c^2$ 的比例增加。\n\n接下来，我们考虑均匀应变下的可移植性。微小应变 $\\varepsilon$ 会扰动局域电子环境，改变键长和键角，从而改变价电子所经历的散射特性。在 PAW 方法中，可移植性误差主要源于缀加区域内赝散射特性与全电子散射特性之间的不匹配。根据微扰理论，主导的能量变化与微扰振幅的平方成正比，因此我们采用 $\\propto \\varepsilon^2$ 的依赖关系。缀加区域的空间范围通过其体积（与 $r_c^3$ 成比例）产生贡献，而曲率不匹配则贡献了另一个对 $r_c$ 的依赖关系，因为赝势化过程会抹平核内的高曲率特征。因此，一个最小的定性模型将每个原子的能量误差的标度关系定为\n$$\n\\Delta E_{\\text{tr}} \\propto r_c^3 \\cdot r_c \\cdot \\varepsilon^2 = r_c^4 \\varepsilon^2.\n$$\n为了使硅的结果定量化，我们采用一个硅特有的比例常数 $C_{\\text{Si}}$，该常数经过校准，使得在实际的 $r_c$ 和 $\\varepsilon$ 下，典型误差在几毫电子伏特的量级。我们设定\n$$\n\\Delta E_{\\text{tr}}^{(\\text{meV})} = C_{\\text{Si}} \\, r_c^4 \\, \\varepsilon^2,\n$$\n其中 $C_{\\text{Si}} = 305.6$ 毫电子伏特/玻尔$^4$。例如，当 $r_c = 1.6$ 玻尔且 $\\varepsilon = 0.05$ 时，此选择得出每个原子的 $\\Delta E_{\\text{tr}} \\approx 5$ 毫电子伏特，这对应变引起的可移植性偏差而言是一个实际的量级。\n\n算法步骤：\n1. 对于每个输入为 $(r_c, \\varepsilon)$ 的测试用例，计算\n$$\nE_{\\text{cut}}^{(\\text{eV})} = 27.211386 \\times \\frac{\\pi^2}{2 r_c^2}.\n$$\n2. 计算预测的可移植性误差\n$$\n\\Delta E_{\\text{tr}}^{(\\text{meV})} = 305.6 \\times r_c^4 \\times \\varepsilon^2.\n$$\n3. 将 $E_{\\text{cut}}^{(\\text{eV})}$ 四舍五入到一位小数，将 $\\Delta E_{\\text{tr}}^{(\\text{meV})}$ 四舍五入到两位小数。\n4. 按照输入顺序将结果汇总到一个列表中，并按规定格式打印单行输出。\n\n这种构造展示了两者间的相互作用：减小 $r_c$ 会使 $E_{\\text{cut}}$ 大致按 $1/r_c^2$ 增加，而在固定的应变水平下，减小 $r_c$ 会使可移植性误差大致按 $r_c^4$ 减小。边界情况 $\\varepsilon = 0$ 因其与应变振幅的二次依赖关系，正确地得出 $\\Delta E_{\\text{tr}} = 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef minimal_energy_cutoff_eV(rc_bohr: float) -> float:\n    \"\"\"\n    Compute minimal plane-wave energy cutoff in eV using the criterion G_max ≈ π / r_c.\n    Atomic units: E(Hartree) = (G^2)/2 with G in 1/bohr.\n    Convert Hartree to eV using 1 Hartree = 27.211386 eV.\n    \"\"\"\n    hartree_to_ev = 27.211386\n    G_max = np.pi / rc_bohr\n    E_hartree = 0.5 * (G_max ** 2)\n    E_eV = hartree_to_ev * E_hartree\n    return E_eV\n\ndef transferability_error_meV(rc_bohr: float, strain: float) -> float:\n    \"\"\"\n    Compute transferability error per atom in meV using ΔE_tr = C_Si * r_c^4 * ε^2.\n    \"\"\"\n    C_Si = 305.6  # meV / bohr^4\n    return C_Si * (rc_bohr ** 4) * (strain ** 2)\n\ndef solve():\n    # Define the test cases from the problem statement: (r_c in bohr, strain epsilon dimensionless)\n    test_cases = [\n        (1.30, 0.08),\n        (1.60, 0.05),\n        (1.90, 0.05),\n        (2.20, 0.02),\n        (1.60, 0.00),  # boundary case: zero strain\n    ]\n\n    results = []\n    for rc, eps in test_cases:\n        ecut = minimal_energy_cutoff_eV(rc)\n        err = transferability_error_meV(rc, eps)\n        # Round as specified: E_cut to 1 decimal, error to 2 decimals\n        ecut_rounded = round(ecut, 1)\n        err_rounded = round(err, 2)\n        results.append([ecut_rounded, err_rounded])\n\n    # Final print statement in the exact required format.\n    # Produce a single line: list of [E_cut(eV), ΔE_tr(meV)] pairs in the given order.\n    # Ensure standard Python list formatting without extra text.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3440835"}, {"introduction": "这项高级实践深入探讨了 PAW 数据集本身的构建过程，这项任务通常由方法开发者完成。通过计算总能量相对于增强半径 $r_c$ 的导数，您将学习如何系统性地优化 PAW 方法中的关键参数。本练习运用了 Hellmann-Feynman 定理，生动地展示了如何利用它来指导精确、高效的 PAW 势函数的自动化生成。[@problem_id:3480862]", "problem": "考虑 Kohn-Sham 密度泛函理论 (DFT) 中的投影缀加波 (PAW) 方法。PAW 总能量可以分解为一个光滑的赝势部分加上局限在原子缀加区域内的在位 (on-site) 缀加修正。对于原子周围的单个球对称缀加区域，将在位缀加贡献近似为径向泛函\n$$\nE(r_c) = \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C,\n$$\n其中 $r_c$ 是缀加半径，$w(r; r_c)$ 是一个切换函数，在缀加区域内近似为 $1$，在区域外近似为 $0$，$F(r)$ 是缀加修正的球对称能量密度替代项，$C$ 是一个与 $r_c$ 无关的常数。切换函数被选择为可微的，并由锐度参数 $a$ 参数化，\n$$\nw(r; r_c) = \\frac{1}{1 + \\exp\\!\\left(\\frac{r - r_c}{a}\\right)}.\n$$\n对缀加能量密度替代项使用以下球对称模型，\n$$\nF(r) = \\Delta n(r)\\, u(r),\n$$\n其中\n$$\n\\Delta n(r) = n_{\\mathrm{AE}}(r) - n_{\\mathrm{PS}}(r),\n$$\n$$\nn_{\\mathrm{AE}}(r) = \\frac{N_e \\alpha^3}{\\pi} \\exp(-2\\alpha r),\n$$\n$$\nn_{\\mathrm{PS}}(r) = n_{\\mathrm{AE}}(r)\\left[1 - \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{m}\\right)\\right],\n$$\n以及有效局域核\n$$\nu(r) = -\\frac{Z_{\\mathrm{eff}}}{r}.\n$$\n此处 $N_e$ 是缀加中表示的价电子数，$\\alpha$ 是类氢衰减参数，$\\sigma$ 是赝势平滑长度尺度，$m$ 是控制平滑度的正偶数整数，$Z_{\\mathrm{eff}}$ 是有效核电荷。所有径向量的单位是玻尔 (Bohr)，能量单位是哈特里 (Hartree)。\n\n从 Kohn-Sham 能量泛函和 PAW 分解出发，并引用积分符号下微分法则和 Hellmann-Feynman 定理，推导导数的表达式\n$$\n\\frac{\\partial E}{\\partial r_c} = \\int_{0}^{\\infty} 4\\pi r^2 \\, F(r) \\, \\frac{\\partial w(r; r_c)}{\\partial r_c} \\, dr,\n$$\n并给出 $\\partial w/\\partial r_c$ 的显式形式。然后，实现一个程序，该程序：\n- 对给定的参数，使用上面的显式积分计算 $\\partial E/\\partial r_c$，单位为哈特里/玻尔 (Hartree per Bohr)。\n- 使用此导数执行投影梯度更新\n$$\nr_c^{(k+1)} = \\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}\\left(r_c^{(k)} - \\eta \\, \\frac{\\partial E}{\\partial r_c}\\bigg|_{r_c^{(k)}}\\right),\n$$\n以指导数据集优化过程中 $r_c$ 的自动选择，其中 $\\eta$ 是一个步长，单位为 玻尔$^2$/哈特里 (Bohr$^2$/Hartree)，$\\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}$ 表示到区间 $[r_{\\min}, r_{\\max}]$ 上的投影。迭代直至 $\\left|\\partial E/\\partial r_c\\right| < \\mathrm{tol}$ 或达到最大迭代次数。报告初始 $r_c$ 处的导数和最终选定的 $r_c$。\n\n你的程序必须在 $r \\in [0, R_{\\mathrm{max}}]$上使用数值积分来实现 $\\partial E/\\partial r_c$ 的积分，其中 $R_{\\mathrm{max}}$ 足够大以捕捉指数尾部，并使用 $w(r; r_c)$ 相对于 $r_c$ 的显式解析导数。全程使用原子单位。将最终导数以哈特里/玻尔 (Hartree per Bohr) 为单位，并将 $r_c$ 以玻尔 (Bohr) 表示为普通浮点数。\n\n测试套件：\n对于每个测试用例，计算初始 $r_c$ 处的导数和自动化程序后选定的 $r_c$。参数如下：\n1. 案例 A (理想情况)：$r_c^{(0)} = 1.0$ 玻尔 (Bohr), $Z_{\\mathrm{eff}} = 6.0$, $\\alpha = 6.0$, $N_e = 4$, $\\sigma = 0.6$ 玻尔 (Bohr), $m = 4$, $a = 0.05$ 玻尔 (Bohr), $r_{\\min} = 0.5$ 玻尔 (Bohr), $r_{\\max} = 2.0$ 玻尔 (Bohr), $\\eta = 0.02$ 玻尔$^2$/哈特里 (Bohr$^2$/Hartree), $\\mathrm{tol} = 1\\times 10^{-8}$ 哈特里/玻尔 (Hartree/Bohr), $\\mathrm{max\\_steps} = 25$。\n2. 案例 B (小半径边界)：$r_c^{(0)} = 0.3$ 玻尔 (Bohr), $Z_{\\mathrm{eff}} = 8.0$, $\\alpha = 7.0$, $N_e = 6$, $\\sigma = 0.5$ 玻尔 (Bohr), $m = 6$, $a = 0.02$ 玻尔 (Bohr), $r_{\\min} = 0.2$ 玻尔 (Bohr), $r_{\\max} = 1.5$ 玻尔 (Bohr), $\\eta = 0.01$ 玻尔$^2$/哈特里 (Bohr$^2$/Hartree), $\\mathrm{tol} = 1\\times 10^{-8}$ 哈特里/玻尔 (Hartree/Bohr), $\\mathrm{max\\_steps} = 30$。\n3. 案例 C (大半径边界)：$r_c^{(0)} = 2.5$ 玻尔 (Bohr), $Z_{\\mathrm{eff}} = 4.0$, $\\alpha = 4.0$, $N_e = 2$, $\\sigma = 0.8$ 玻尔 (Bohr), $m = 4$, $a = 0.1$ 玻尔 (Bohr), $r_{\\min} = 1.0$ 玻尔 (Bohr), $r_{\\max} = 3.0$ 玻尔 (Bohr), $\\eta = 0.05$ 玻尔$^2$/哈特里 (Bohr$^2$/Hartree), $\\mathrm{tol} = 1\\times 10^{-8}$ 哈特里/玻尔 (Hartree/Bohr), $\\mathrm{max\\_steps} = 20$。\n4. 案例 D (粗糙切换函数)：$r_c^{(0)} = 1.2$ 玻尔 (Bohr), $Z_{\\mathrm{eff}} = 10.0$, $\\alpha = 9.0$, $N_e = 8$, $\\sigma = 0.4$ 玻尔 (Bohr), $m = 8$, $a = 0.3$ 玻尔 (Bohr), $r_{\\min} = 0.4$ 玻尔 (Bohr), $r_{\\max} = 2.5$ 玻尔 (Bohr), $\\eta = 0.015$ 玻尔$^2$/哈特里 (Bohr$^2$/Hartree), $\\mathrm{tol} = 1\\times 10^{-8}$ 哈特里/玻尔 (Hartree/Bohr), $\\mathrm{max\\_steps} = 40$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[\\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{案例 A, } r_c^{(0)}}, \\, r_c^{\\text{选定, A}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{案例 B, } r_c^{(0)}}, \\, r_c^{\\text{选定, B}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{案例 C, } r_c^{(0)}}, \\, r_c^{\\text{选定, C}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{案例 D, } r_c^{(0)}}, \\, r_c^{\\text{选定, D}}\\right].\n$$\n所有导数必须以哈特里/玻尔 (Hartree per Bohr) 表示，所有半径必须以玻尔 (Bohr) 表示，均为浮点数。", "solution": "该问题要求在一个简化的投影缀加波 (PAW) 方法模型中，推导并实现一个优化缀加半径 $r_c$ 的程序。该优化由模型能量泛函的梯度 $\\partial E/\\partial r_c$ 指导。\n\n第一步是推导该梯度的显式表达式。在位缀加能量的模型给出如下：\n$$\nE(r_c) = \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C\n$$\n在此，能量密度替代项 $F(r)$ 和常数 $C$ 均与缀加半径 $r_c$ 无关。切换函数 $w(r; r_c)$ 是积分内部对 $r_c$ 依赖的唯一来源。因此，我们可以应用莱布尼茨积分法则（积分符号下微分法）来求 $E$ 相对于 $r_c$ 的导数：\n$$\n\\frac{\\partial E}{\\partial r_c} = \\frac{\\partial}{\\partial r_c} \\left( \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C \\right) = \\int_{0}^{\\infty} 4\\pi r^2 \\, F(r) \\, \\frac{\\partial w(r; r_c)}{\\partial r_c} \\, dr\n$$\n这证实了问题描述中提供的表达式，该表达式是将 Hellmann-Feynman 定理应用于参数 $r_c$ 的直接结果。\n\n接下来，我们必须求出切换函数的偏导数 $\\partial w/\\partial r_c$ 的显式形式。切换函数由下式给出：\n$$\nw(r; r_c) = \\frac{1}{1 + \\exp\\left(\\frac{r - r_c}{a}\\right)}\n$$\n使用链式法则，我们对 $r_c$ 求导：\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = -\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^{-2} \\cdot \\exp\\left(\\frac{r - r_c}{a}\\right) \\cdot \\frac{\\partial}{\\partial r_c}\\left(\\frac{r - r_c}{a}\\right)\n$$\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = -\\frac{\\exp\\left(\\frac{r - r_c}{a}\\right)}{\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^2} \\cdot \\left(-\\frac{1}{a}\\right) = \\frac{1}{a} \\frac{\\exp\\left(\\frac{r - r_c}{a}\\right)}{\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^2}\n$$\n此表达式与 logistic 函数的导数有关，并且可以使用双曲余弦函数重写为数值上更稳定的形式。令 $x = (r - r_c)/a$，我们有 $\\exp(x)/(1+\\exp(x))^2 = 1/(4 \\cosh^2(x/2))$。因此：\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = \\frac{1}{a} \\frac{1}{4\\cosh^2\\left(\\frac{r - r_c}{2a}\\right)}\n$$\n当 $r-r_c$ 很大时，这种形式可以避免指数形式可能出现的浮点溢出。\n\n现在我们组合出 $\\partial E/\\partial r_c$ 的完整被积函数。被积函数是 $4\\pi r^2 F(r) \\frac{\\partial w}{\\partial r_c}$。我们代入给定的表达式 $F(r) = \\Delta n(r) u(r)$：\n\\begin{align*}\n\\Delta n(r) = n_{\\mathrm{AE}}(r) - n_{\\mathrm{PS}}(r) \\\\\n= \\left(\\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r}\\right) - \\left(\\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r}\\right)\\left[1 - e^{-\\left(\\frac{r}{\\sigma}\\right)^{m}}\\right] \\\\\n= \\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r} e^{-\\left(\\frac{r}{\\sigma}\\right)^{m}}\n\\end{align*}\n以及 $u(r) = -Z_{\\mathrm{eff}}/r$。$4\\pi r^2 F(r)$ 项变为：\n$$\n4\\pi r^2 F(r) = 4\\pi r^2 \\left( \\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r - (r/\\sigma)^m} \\right) \\left( -\\frac{Z_{\\mathrm{eff}}}{r} \\right) = -4 N_e \\alpha^3 Z_{\\mathrm{eff}} \\, r \\, e^{-2\\alpha r - (r/\\sigma)^m}\n$$\n完整的被积函数最终为：\n$$\nI(r; r_c) = \\left( -4 N_e \\alpha^3 Z_{\\mathrm{eff}} \\, r \\, e^{-2\\alpha r - (r/\\sigma)^m} \\right) \\left( \\frac{1}{a} \\frac{1}{4\\cosh^2\\left(\\frac{r - r_c}{2a}\\right)} \\right)\n$$\n一个重要的观察是，对于所有 $r > 0$，被积函数中的每一项都有固定的符号：$Z_{\\mathrm{eff}} > 0$，$N_e > 0$，$\\alpha > 0$，$a > 0$，指数函数和双曲函数均为正。唯一的负号是来自 $u(r)$ 的显式负号。因此，对于所有 $r > 0$，被积函数 $I(r; r_c)$ 严格为负，这意味着对于任何参数选择，积分 $\\partial E/\\partial r_c$ 也严格为负。这表示模型能量 $E(r_c)$ 是 $r_c$ 的单调递减函数。\n\n优化过程是一个投影梯度下降更新：\n$$\nr_c^{(k+1)} = \\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}\\left(r_c^{(k)} - \\eta \\, \\frac{\\partial E}{\\partial r_c}\\bigg|_{r_c^{(k)}}\\right)\n$$\n由于 $\\partial E/\\partial r_c < 0$ 且步长 $\\eta > 0$，项 $-\\eta \\, \\partial E/\\partial r_c$ 总是正的。因此，优化算法在每一步都会增加 $r_c$ 的值。迭代过程将在以下三个条件之一终止：\n1. 达到最大迭代次数 $\\mathrm{max\\_steps}$。\n2. 梯度的绝对值 $|\\partial E/\\partial r_c|$ 小于容差 $\\mathrm{tol}$。鉴于此模型中 $E(r_c)$ 的单调性，除非梯度大小碰巧很小，否则这个条件不太可能满足。\n3. 迭代收敛到一个不动点，这在 $r_c$ 停止变化时发生。如果梯度变得可以忽略不计（如条件2），或者如果 $r_c$ 到达投影区间 $[r_{\\min}, r_{\\max}]$ 的边界且梯度向量指向外部，导致投影操作抵消了更新，就会发生这种情况。鉴于 $r_c$ 总是增加，这种情况将在 $r_c$ 达到 $r_{\\max}$ 时发生。\n\n该实现将包括三个主要部分：\n1. 一个使用数值稳定形式计算被积函数 $I(r; r_c)$ 的函数。\n2. 一个通过使用标准求积程序（如 `scipy.integrate.quad`）对 $I(r; r_c)$ 从 $r=0$ 到 $r=\\infty$ 进行数值积分来计算导数 $\\partial E/\\partial r_c$ 的函数。\n3. 一个实现投影梯度下降循环的优化函数，它在每一步调用导数函数，并管理停止条件。该函数将计算初始 $r_c^{(0)}$ 处的导数，并将其与最终选定的 $r_c$ 一起返回。\n主程序将遍历提供的测试用例，为每个用例调用优化例程，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path\n        {'rc0': 1.0, 'Z_eff': 6.0, 'alpha': 6.0, 'Ne': 4, 'sigma': 0.6, 'm': 4, 'a': 0.05,\n         'rmin': 0.5, 'rmax': 2.0, 'eta': 0.02, 'tol': 1e-8, 'max_steps': 25},\n        # Case B: small-radius edge\n        {'rc0': 0.3, 'Z_eff': 8.0, 'alpha': 7.0, 'Ne': 6, 'sigma': 0.5, 'm': 6, 'a': 0.02,\n         'rmin': 0.2, 'rmax': 1.5, 'eta': 0.01, 'tol': 1e-8, 'max_steps': 30},\n        # Case C: large-radius edge\n        {'rc0': 2.5, 'Z_eff': 4.0, 'alpha': 4.0, 'Ne': 2, 'sigma': 0.8, 'm': 4, 'a': 0.1,\n         'rmin': 1.0, 'rmax': 3.0, 'eta': 0.05, 'tol': 1e-8, 'max_steps': 20},\n        # Case D: coarse switching function\n        {'rc0': 1.2, 'Z_eff': 10.0, 'alpha': 9.0, 'Ne': 8, 'sigma': 0.4, 'm': 8, 'a': 0.3,\n         'rmin': 0.4, 'rmax': 2.5, 'eta': 0.015, 'tol': 1e-8, 'max_steps': 40},\n    ]\n\n    results = []\n    for case in test_cases:\n        initial_derivative, final_rc = optimize_rc(case)\n        results.append(initial_derivative)\n        results.append(final_rc)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef integrand_func(r, rc, Z_eff, alpha, Ne, sigma, m, a):\n    \"\"\"\n    Computes the integrand for the dE/drc calculation.\n    Integrand = 4*pi*r^2 * F(r) * d(w)/d(rc)\n    \"\"\"\n    # This term combines 4*pi*r^2 and F(r) = Delta_n(r) * u(r)\n    # The exponent can become very large and negative, causing underflow to 0, which is correct.\n    # We add a check to handle this gracefully.\n    try:\n        exp_arg_density = -2.0 * alpha * r - (r / sigma)**m\n    except OverflowError:\n        exp_arg_density = -np.inf\n        \n    if exp_arg_density < -700.0:  # np.exp(-709) is ~1e-308\n        term_F_part = 0.0\n    else:\n        term_F_part = r * np.exp(exp_arg_density)\n    \n    term_F = -4.0 * Ne * alpha**3 * Z_eff * term_F_part\n\n    # This term is d(w)/d(rc) = (1/a) * 1 / (4 * cosh^2((r-rc)/(2a)))\n    # This form is numerically stable.\n    x = (r - rc) / (2.0 * a)\n    \n    # cosh(x) overflows for |x| > ~710. Use asymptotic behavior to prevent this.\n    if abs(x) > 300.0: # Safe cutoff\n        # For large |x|, 1/(4*cosh^2(x)) -> exp(-2*|x|)\n        term_dw_drc_part = np.exp(-2.0 * abs(x))\n    else:\n        cosh_x = np.cosh(x)\n        term_dw_drc_part = 1.0 / (4.0 * cosh_x**2)\n    \n    term_dw_drc = (1.0 / a) * term_dw_drc_part\n\n    return term_F * term_dw_drc\n\ndef calculate_derivative(rc, params):\n    \"\"\"\n    Calculates dE/drc by numerically integrating the integrand.\n    \"\"\"\n    integral_val, _ = quad(\n        integrand_func, 0, np.inf,\n        args=(\n            rc, params['Z_eff'], params['alpha'], params['Ne'], \n            params['sigma'], params['m'], params['a']\n        )\n    )\n    return integral_val\n\ndef optimize_rc(params):\n    \"\"\"\n    Performs projected gradient descent to find the optimal rc.\n    \"\"\"\n    rc = params['rc0']\n    rmin, rmax = params['rmin'], params['rmax']\n    eta, tol, max_steps = params['eta'], params['tol'], params['max_steps']\n\n    # Calculate and store the derivative at the initial rc\n    initial_derivative = calculate_derivative(rc, params)\n\n    for _ in range(max_steps):\n        dE_drc = calculate_derivative(rc, params)\n\n        # Stop if the gradient magnitude is below the tolerance\n        if abs(dE_drc) < tol:\n            break\n\n        # Perform gradient update step\n        rc_new = rc - eta * dE_drc\n\n        # Project the new rc onto the allowed interval [rmin, rmax]\n        rc_proj = max(rmin, min(rmax, rc_new))\n        \n        # Stop if rc has converged to a fixed point (interior or boundary)\n        if np.isclose(rc_proj, rc):\n            rc = rc_proj\n            break\n            \n        rc = rc_proj\n\n    return initial_derivative, rc\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3480862"}]}