{"hands_on_practices": [{"introduction": "在量子化学计算中，斯莱特型轨道（STO）能够物理上精确地描述原子轨道，但其相关的积分计算非常复杂。高斯型轨道（GTO）虽然对电子波函数在原子核附近的尖峰和远距离的尾部描述不佳，但其积分可以解析计算，从而大大提高了计算效率。本实践旨在通过最小化$L^2$范数误差，用一组高斯基函数来构建一个收缩高斯基，以最佳地近似一个斯莱特型轨道，让学习者亲身体验构建现代基组的核心数学原理 ([@problem_id:3461808])。", "problem": "要求您形式化、实现并测试一种策略，该策略用于从基元高斯函数构建收缩高斯基组，以从第一性原理出发近似基态类氢轨道的Slater型轨道。工作将在三维空间中进行，处理定义在 $\\mathbb{R}^3$ 上的平方可积函数，并使用平方可积函数希尔伯特空间 (Hilbert space) 的常规内积。目标是使积分范数误差达到一个预设的界限。\n\n给定指数为 $\\zeta$ 的归一化Slater型 $1s$ 轨道（Slater Type Orbital, STO），其定义为实空间函数 $\\phi_{\\zeta}(\\mathbf{r}) = N_{\\mathrm{STO}} \\exp(-\\zeta r)$，其中 $r = \\|\\mathbf{r}\\|$，归一化常数 $N_{\\mathrm{STO}}$ 的选择使得 $\\int_{\\mathbb{R}^3} |\\phi_{\\zeta}(\\mathbf{r})|^2 \\, d^3\\mathbf{r} = 1$。同时给定一族归一化的基元 $s$ 型高斯型轨道（Gaussian Type Orbitals, GTO）$g_{\\alpha}(\\mathbf{r}) = N_{\\mathrm{GTO}} \\exp(-\\alpha r^2)$，其高斯指数 $\\alpha > 0$，归一化常数 $N_{\\mathrm{GTO}}$ 的选择使得 $\\int_{\\mathbb{R}^3} |g_{\\alpha}(\\mathbf{r})|^2 \\, d^3\\mathbf{r} = 1$。考虑一个收缩高斯函数\n$$\n\\chi_{n}(\\mathbf{r}) = \\sum_{i=1}^{n} c_i \\, g_{\\alpha_i}(\\mathbf{r}),\n$$\n其中 $\\{\\alpha_i\\}_{i=1}^n$ 是互不相同的正基元指数，而 $\\{c_i\\}_{i=1}^n$ 是实数收缩系数。\n\n您的任务是：\n- 仅从 $L^2(\\mathbb{R}^3)$ 上的内积定义、$\\phi_{\\zeta}$ 和 $g_{\\alpha}$ 的归一化条件以及高斯积分的标准性质出发，推导出能够最小化平方 $L^2$ 误差的系数集 $\\{c_i\\}_{i=1}^n$ 所满足的条件\n$$\n\\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2}^2 = \\int_{\\mathbb{R}^3} \\left| \\phi_{\\zeta}(\\mathbf{r}) - \\sum_{i=1}^{n} c_i g_{\\alpha_i}(\\mathbf{r}) \\right|^2 \\, d^3\\mathbf{r}。\n$$\n除了各个 $g_{\\alpha_i}$ 的独立归一化之外，不要假设它们的任何特殊正交性；您的推导必须仅使用内积定义以及高斯积分和指数积分的基本微积分恒等式。\n- 实现一个算法，对于给定的由 $\\alpha_i = \\alpha_0 \\beta^{i-1}$（给定 $\\alpha_0 > 0$ 和 $\\beta > 1$）定义的均匀律（even-tempered）基元指数集，通过递增 $n$ （取均匀律列表中的前 $n$ 个指数）进行搜索，以找到最小的 $n$，使得最优收缩函数 $\\chi_n$ 满足积分范数误差的预设容差 $\\varepsilon$，即\n$$\n\\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2} \\le \\varepsilon。\n$$\n- 您的实现必须依赖于从第一性原理推导所得到的所有必需重叠积分和其它积分的解析表达式，并且必须使用数值稳定的线性代数过程来计算最优系数。如果重叠矩阵系统是病态的（ill-conditioned），引入一个极小的Tikhonov正则化项，该项不会实质性地影响最小化结果，但能稳定求解过程。\n\n测试输入必须硬编码为一组测试用例。对于每个测试用例，给定 $\\zeta$、$\\alpha_0$、$\\beta$、定义候选池 $\\{\\alpha_1,\\dots,\\alpha_{N_{\\max}}\\}$ 的最大基元数 $N_{\\max}$，以及目标容差 $\\varepsilon$。对于每个测试用例，程序必须返回一个数对 $[n^\\star, e^\\star]$，其中 $n^\\star$ 是找到的最小收缩长度（上限为 $N_{\\max}$），$e^\\star$ 是该 $n^\\star$ 实现的积分范数误差。\n\n测试套件：\n- Case A (正常路径): $\\zeta = $ $1.0$, $\\alpha_0 = $ $0.01$, $\\beta = $ $2.5$, $N_{\\max} = $ $12$, $\\varepsilon = $ $1.0\\times 10^{-4}$.\n- Case B (弥散轨道): $\\zeta = $ $0.25$, $\\alpha_0 = $ $0.0005$, $\\beta = $ $2.5$, $N_{\\max} = $ $14$, $\\varepsilon = $ $4.0\\times 10^{-4}$.\n- Case C (紧凑轨道): $\\zeta = $ $4.0$, $\\alpha_0 = $ $0.02$, $\\beta = $ $3.0$, $N_{\\max} = $ $14$, $\\varepsilon = $ $2.0\\times 10^{-4}$.\n- Case D (边界紧凑容差): $\\zeta = $ $1.0$, $\\alpha_0 = $ $0.01$, $\\beta = $ $2.5$, $N_{\\max} = $ $10$, $\\varepsilon = $ $1.0\\times 10^{-8}$.\n\n所有量均为无量纲量，必须如此处理。不需要物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的四个数对列表，顺序与测试套件一致。每个数对本身必须写成一个包含最小整数 $n^\\star$ 和浮点误差 $e^\\star$ 的双元素列表。对 $e^\\star$ 使用至少有8位有效数字的科学记数法。例如，包含两个假设用例的输出行可能如下所示\n$$\n[[n_1,e_1],[n_2,e_2],[n_3,e_3],[n_4,e_4]]。\n$$\n您的程序不得读取任何输入，也不得打印除所需的单行输出之外的任何文本。", "solution": "所提出的问题要求对一种方法进行形式推导和实现，该方法使用高斯型轨道（GTO）的线性组合（称为收缩高斯函数）来近似Slater型轨道（STO）。目标是最小化目标STO与收缩GTO近似之间的差的平方 $L^2$ 范数。\n\n该问题经验证是合理的。它在科学上基于量子化学基组设计的原理，作为一个希尔伯特空间 (Hilbert space) 中的线性最小二乘问题被良好地提出，并且客观地陈述了解决该问题所需的所有数据。\n\n在此，从第一性原理推导出一个完整的解决方案。\n\n设归一化的 $1s$ STO为 $\\phi_{\\zeta}(\\mathbf{r})$，其指数为 $\\zeta>0$，基元 $s$ 型GTO集合为 $\\{g_{\\alpha_i}(\\mathbf{r})\\}_{i=1}^n$，其指数为 $\\{\\alpha_i > 0\\}$。收缩高斯轨道由 $\\chi_n(\\mathbf{r}) = \\sum_{i=1}^{n} c_i g_{\\alpha_i}(\\mathbf{r})$ 给出。\n\n任务是找到实数收缩系数 $\\{c_i\\}_{i=1}^n$ 以最小化平方 $L^2$ 误差：\n$$\nE = \\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2}^2 = \\left\\langle \\phi_{\\zeta} - \\sum_{i=1}^{n} c_i g_{\\alpha_i}, \\phi_{\\zeta} - \\sum_{j=1}^{n} c_j g_{\\alpha_j} \\right\\rangle\n$$\n其中，对于 $\\mathbb{R}^3$ 上的实数平方可积函数，内积为 $\\langle f, g \\rangle = \\int_{\\mathbb{R}^3} f(\\mathbf{r}) g(\\mathbf{r}) \\, d^3\\mathbf{r}$。\n\n利用内积的线性性质展开：\n$$\nE = \\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle - 2 \\sum_{i=1}^{n} c_i \\langle \\phi_{\\zeta}, g_{\\alpha_i} \\rangle + \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_i c_j \\langle g_{\\alpha_i}, g_{\\alpha_j} \\rangle\n$$\n为了找到最小化 $E$ 的系数 $\\{c_k\\}$，我们必须将 $E$ 对每个 $c_k$ 的偏导数设为零：\n$$\n\\frac{\\partial E}{\\partial c_k} = 0 - 2 \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle + \\sum_{i=1}^{n} c_i \\langle g_{\\alpha_i}, g_{\\alpha_k} \\rangle + \\sum_{j=1}^{n} c_j \\langle g_{\\alpha_k}, g_{\\alpha_j} \\rangle = 0\n$$\n由于内积是对称的，$\\langle g_{\\alpha_i}, g_{\\alpha_k} \\rangle = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$，因此两个和是相同的。于是，对于每个 $k \\in \\{1, \\dots, n\\}$：\n$$\n-2 \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle + 2 \\sum_{i=1}^{n} c_i \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle = 0\n$$\n$$\n\\sum_{i=1}^{n} \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle c_i = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle\n$$\n这是一个线性方程组，可以写成矩阵形式 $\\mathbf{S}\\mathbf{c} = \\mathbf{b}$，其中：\n- $\\mathbf{c}$ 是系数的列向量 $[c_1, \\dots, c_n]^T$。\n- $\\mathbf{S}$ 是GTO基元的 $n \\times n$ 重叠矩阵，其元素为 $S_{ki} = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$。\n- $\\mathbf{b}$ 是长度为 $n$ 的列向量，其元素为 $b_k = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle$。\n\n为了计算 $\\mathbf{S}$ 和 $\\mathbf{b}$ 的元素，我们必须从第一性原理出发计算所需的积分。由于轨道是球对称的，体积元 $d^3\\mathbf{r}$ 可以写成 $4\\pi r^2 dr$。\n\n首先，我们推导归一化常数。设未归一化函数为 $\\tilde{\\phi}_{\\zeta}(r) = e^{-\\zeta r}$ 和 $\\tilde{g}_{\\alpha}(r) = e^{-\\alpha r^2}$。\n对于 $\\phi_{\\zeta}(\\mathbf{r}) = N_{\\mathrm{STO}} \\tilde{\\phi}_{\\zeta}(r)$，其归一化常数 $N_{\\mathrm{STO}}$ 可通过要求 $\\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle = 1$ 求得：\n$$\n1 = N_{\\mathrm{STO}}^2 \\int_{\\mathbb{R}^3} e^{-2\\zeta r} d^3\\mathbf{r} = N_{\\mathrm{STO}}^2 \\int_0^\\infty 4\\pi r^2 e^{-2\\zeta r} dr\n$$\n使用标准积分 $\\int_0^\\infty x^n e^{-ax} dx = n!/a^{n+1}$，其中 $n=2$ 和 $a=2\\zeta$：\n$$\n1 = N_{\\mathrm{STO}}^2 \\cdot 4\\pi \\left(\\frac{2!}{(2\\zeta)^3}\\right) = N_{\\mathrm{STO}}^2 \\frac{8\\pi}{8\\zeta^3} \\implies N_{\\mathrm{STO}} = \\sqrt{\\frac{\\zeta^3}{\\pi}}\n$$\n对于 $g_{\\alpha}(\\mathbf{r}) = N_{\\mathrm{GTO}} \\tilde{g}_{\\alpha}(r)$，其归一化常数 $N_{\\mathrm{GTO}}$ 可通过要求 $\\langle g_{\\alpha}, g_{\\alpha} \\rangle = 1$ 求得：\n$$\n1 = N_{\\mathrm{GTO}}^2 \\int_{\\mathbb{R}^3} e^{-2\\alpha r^2} d^3\\mathbf{r} = N_{\\mathrm{GTO}}^2 \\int_0^\\infty 4\\pi r^2 e^{-2\\alpha r^2} dr\n$$\n使用标准积分 $\\int_0^\\infty x^2 e^{-ax^2} dx = \\frac{1}{4}\\sqrt{\\frac{\\pi}{a^3}}$，其中 $a=2\\alpha$：\n$$\n1 = N_{\\mathrm{GTO}}^2 \\cdot 4\\pi \\left(\\frac{1}{4}\\sqrt{\\frac{\\pi}{(2\\alpha)^3}}\\right) = N_{\\mathrm{GTO}}^2 \\frac{\\pi^{3/2}}{(2\\alpha)^{3/2}} \\implies N_{\\mathrm{GTO}} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\n$$\n重叠矩阵元素 $S_{ki} = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$ 为：\n$$\nS_{ki} = N_{\\mathrm{GTO},k} N_{\\mathrm{GTO},i} \\int_{\\mathbb{R}^3} e^{-\\alpha_k r^2} e^{-\\alpha_i r^2} d^3\\mathbf{r} = N_{\\mathrm{GTO},k} N_{\\mathrm{GTO},i} \\int_0^\\infty 4\\pi r^2 e^{-(\\alpha_k + \\alpha_i)r^2} dr\n$$\n使用相同的高斯积分形式，其中 $a = \\alpha_k + \\alpha_i$：\n$$\nS_{ki} = \\left(\\frac{2\\alpha_k}{\\pi}\\right)^{3/4} \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} \\cdot 4\\pi \\left( \\frac{1}{4} \\sqrt{\\frac{\\pi}{(\\alpha_k+\\alpha_i)^3}} \\right) = \\frac{(4\\alpha_k\\alpha_i)^{3/4}}{\\pi^{3/2}} \\frac{\\pi^{3/2}}{(\\alpha_k+\\alpha_i)^{3/2}} = \\left( \\frac{2\\sqrt{\\alpha_k\\alpha_i}}{\\alpha_k+\\alpha_i} \\right)^{3/2}\n$$\n向量元素 $b_k = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle$ 为：\n$$\nb_k = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\int_{\\mathbb{R}^3} e^{-\\zeta r} e^{-\\alpha_k r^2} d^3\\mathbf{r} = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\int_0^\\infty 4\\pi r^2 e^{-\\zeta r} e^{-\\alpha_k r^2} dr\n$$\n所需的积分 $I(\\alpha_k, \\zeta) = \\int_0^\\infty r^2 e^{-\\alpha_k r^2 -\\zeta r} dr$ 可通过计算 $\\frac{\\partial^2 J(\\alpha_k, \\zeta)}{\\partial \\zeta^2}$ 求得，其中 $J(\\alpha, \\zeta) = \\int_0^\\infty e^{-\\alpha r^2 - \\zeta r} dr$。此推导得出以下表达式：\n$$\nI(\\alpha_k, \\zeta) = \\left(\\frac{\\sqrt{\\pi}(2\\alpha_k+\\zeta^2)}{8\\alpha_k^{5/2}}\\right) e^{\\zeta^2/4\\alpha_k}\\mathrm{erfc}\\left(\\frac{\\zeta}{2\\sqrt{\\alpha_k}}\\right) - \\frac{\\zeta}{4\\alpha_k^2}\n$$\n为了数值稳定性，特别是对于误差函数的大自变量，此式使用缩放互补误差函数 $\\mathrm{erfcx}(z) = e^{z^2}\\mathrm{erfc}(z)$ 来表示。\n$$\nI(\\alpha_k, \\zeta) = \\left(\\frac{\\sqrt{\\pi}(2\\alpha_k+\\zeta^2)}{8\\alpha_k^{5/2}}\\right) \\mathrm{erfcx}\\left(\\frac{\\zeta}{2\\sqrt{\\alpha_k}}\\right) - \\frac{\\zeta}{4\\alpha_k^2}\n$$\n因此，$b_k = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\cdot 4\\pi \\cdot I(\\alpha_k, \\zeta)$。\n\n最优系数向量可通过求解线性方程组 $\\mathbf{c} = \\mathbf{S}^{-1}\\mathbf{b}$ 找到。考虑到如果基元指数相近，$\\mathbf{S}$ 可能会出现病态（ill-conditioning），因此需要一个稳定的数值求解器。\n\n利用最优系数 $\\mathbf{c}$，最小平方误差 $E_{min}$ 为：\n$$\nE_{min} = \\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle - 2\\mathbf{c}^T\\mathbf{b} + \\mathbf{c}^T\\mathbf{S}\\mathbf{c}\n$$\n代入 $\\mathbf{S}\\mathbf{c}=\\mathbf{b}$ 意味着 $\\mathbf{c}^T\\mathbf{S}\\mathbf{c}=\\mathbf{c}^T\\mathbf{b}$。\n$$\nE_{min} = 1 - 2\\mathbf{c}^T\\mathbf{b} + \\mathbf{c}^T\\mathbf{b} = 1 - \\mathbf{c}^T\\mathbf{b}\n$$\n最终的积分范数误差为 $e_n = \\sqrt{E_{min}} = \\sqrt{1 - \\mathbf{c}^T\\mathbf{b}}$。\n\n算法流程如下：对于给定的参数集 $(\\zeta, \\alpha_0, \\beta, N_{\\max}, \\varepsilon)$，我们生成GTO指数池 $\\{\\alpha_i = \\alpha_0 \\beta^{i-1}\\}_{i=1}^{N_{\\max}}$。然后我们从 1 到 $N_{\\max}$ 迭代 $n$。在每次迭代中，我们为前 $n$ 个基元构建并求解线性方程组，以找到最优系数 $\\mathbf{c}_n$ 和相应的误差 $e_n$。使得 $e_n \\le \\varepsilon$ 的第一个 $n$ 值即为所需的最小收缩长度 $n^\\star$。如果对于任何 $n \\le N_{\\max}$ 都未能满足容差，我们则报告 $n=N_{\\max}$ 的结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erfcx\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the minimal contraction length n and corresponding L2 error\n    for approximating a Slater-type orbital with a sum of Gaussians.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    test_cases = [\n        # (zeta, alpha0, beta, N_max, epsilon)\n        (1.0, 0.01, 2.5, 12, 1.0e-4),\n        (0.25, 0.0005, 2.5, 14, 4.0e-4),\n        (4.0, 0.02, 3.0, 14, 2.0e-4),\n        (1.0, 0.01, 2.5, 10, 1.0e-8),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        zeta, alpha0, beta, N_max, epsilon = case\n        \n        # Generate the pool of primitive GTO exponents\n        exponents = np.array([alpha0 * (beta**(i)) for i in range(N_max)])\n\n        # Calculate N_STO once\n        N_sto = math.sqrt(zeta**3 / math.pi)\n\n        # Store errors for n=1 to N_max\n        errors = np.zeros(N_max)\n        \n        for n in range(1, N_max + 1):\n            \n            current_exponents = exponents[:n]\n            \n            # --- Build the overlap matrix S ---\n            S = np.zeros((n, n))\n            for i in range(n):\n                for j in range(i, n):\n                    alpha_i = current_exponents[i]\n                    alpha_j = current_exponents[j]\n                    val = (2 * math.sqrt(alpha_i * alpha_j) / (alpha_i + alpha_j))**1.5\n                    S[i, j] = val\n                    S[j, i] = val\n\n            # --- Build the overlap vector b ---\n            b = np.zeros(n)\n            for i in range(n):\n                alpha = current_exponents[i]\n                \n                # N_GTO for the current exponent\n                N_gto = (2 * alpha / math.pi)**0.75\n                \n                # Integral I(alpha, zeta)\n                z = zeta / (2 * math.sqrt(alpha))\n                # The expression inside I(alpha, zeta) before 4*pi multiplication\n                I_val = (math.sqrt(math.pi) * (2*alpha + zeta**2)) / (8 * alpha**2.5) * erfcx(z) - zeta / (4 * alpha**2)\n                \n                # Full b_i element\n                b[i] = N_sto * N_gto * 4 * math.pi * I_val\n            \n            # --- Solve the linear system and compute error ---\n            try:\n                # Solve Sc = b for coefficients c\n                coeffs = np.linalg.solve(S, b)\n                \n                # Calculate squared error E_min = 1 - c^T * b\n                # Note: c and b are 1-D arrays, so transpose is not needed.\n                squared_error = 1.0 - np.dot(coeffs, b)\n                \n                # Ensure squared error is non-negative due to potential floating point inaccuracies\n                if squared_error  0:\n                    squared_error = 0.0\n                \n                errors[n-1] = math.sqrt(squared_error)\n                \n            except np.linalg.LinAlgError:\n                # If matrix is singular, error is considered infinite\n                errors[n-1] = float('inf')\n\n        # Find the smallest n that meets the tolerance\n        found_n = -1\n        found_error = -1.0\n        \n        for n in range(N_max):\n            if errors[n] = epsilon:\n                found_n = n + 1\n                found_error = errors[n]\n                break\n        \n        # If no n met the tolerance, return the result for N_max\n        if found_n == -1:\n            n_star = N_max\n            e_star = errors[N_max-1]\n        else:\n            n_star = found_n\n            e_star = found_error\n            \n        all_results.append([n_star, e_star])\n    \n    # Format the results for the final output string\n    formatted_results = []\n    for result in all_results:\n        n_val, e_val = result\n        formatted_results.append(f\"[{n_val}, {e_val:.8e}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3461808"}, {"introduction": "从孤立的分子转向周期性晶体时，瓦尼尔函数（Wannier functions）扮演着局域分子轨道的等效角色，为分析化学键合与电学性质提供了实空间的图像。本实践的核心是揭示一个深刻的理论：瓦尼尔函数的实空间局域性与其能带结构的复动量平面的解析性质紧密相关。通过分析一个具有带隙的一维紧束缚模型，您将推导出瓦尼尔函数的渐近衰减长度，从而深刻理解动量空间性质如何决定晶体材料的实空间特征 ([@problem_id:3461802])。", "problem": "考虑一个一维周期性紧束缚模型，每个原胞有两个轨道，分别标记为 $A$ 和 $B$，晶格常数为 $a$。假设在相邻原胞的 $A$ 和 $B$ 轨道之间存在最近邻跃迁，跃迁振幅为 $t0$；轨道 $A$ 的在位能为 $+\\Delta$，轨道 $B$ 的在位能为 $-\\Delta$，其中 $\\Delta0$。在布洛赫表象中，作为晶体动量 $k$ 的函数的哈密顿量为\n$$\nH(k) \\;=\\; \\begin{pmatrix}\n\\Delta  2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta\n\\end{pmatrix}.\n$$\n当 $\\Delta \\neq 0$ 时，对于实数 $k$，该模型存在直接能隙。将与占据带（价带）相关的瓦尼尔函数定义为其布洛赫本征函数在布里渊区上的傅里叶变换，并采用一个平滑规范，使得布洛赫本征函数沿着实数 $k$ 轴是连续的。利用布洛赫本征函数在 $k$ 的复解析延拓下的解析性，以及大距离衰减与能带结构中最近的复奇点之间的联系，确定价带瓦尼尔函数沿链方向的渐近指数衰减长度 $\\ell$（定义为当 $x$ 很大时 $|w(x)| \\propto \\exp(-x/\\ell)$）。\n\n将最终答案表示为包含 $a$、$t$ 和 $\\Delta$ 的单一闭合形式符号表达式，并假设 $a$ 的单位为米，以米为单位给出结果。没有提供数值；无需四舍五入。答案必须是单一的解析表达式。", "solution": "问题要求解给定的一维双能带紧束缚模型中价带瓦尼尔函数的渐近指数衰减长度 $\\ell$。将瓦尼尔函数的空间局域性与能带结构联系起来的基本原理是，指数衰减率由布洛赫能带到复动量平面的解析延拓所决定。具体来说，衰减长度是价带和导带简并时复波矢 $k$ 的虚部最小量值的倒数。这些简并点是能谱 $E(k)$ 的分支点。\n\n步骤如下：\n1.  对角化布洛赫哈密顿量 $H(k)$ 以求出能带 $E(k)$。\n2.  找出使能带简并的复波矢 $k$，即能隙闭合的点。\n3.  确定具有最小非零虚部 $|k_{\\text{im}}|$ 的解。\n4.  衰减长度 $\\ell$ 则由 $\\ell = 1 / |k_{\\text{im}}|$ 给出。\n\n在布洛赫表象中，哈密顿量由下式给出：\n$$\nH(k) \\;=\\; \\begin{pmatrix}\n\\Delta  2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta\n\\end{pmatrix}\n$$\n其中 $\\Delta  0$ 是在位能分裂的一半，$t  0$ 是跃迁振幅，$a$ 是晶格常数。\n\n首先，我们通过求解特征方程 $\\det(H(k) - E I) = 0$ 来求能量本征值 $E$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。\n$$\n\\det \\begin{pmatrix}\n\\Delta - E  2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta - E\n\\end{pmatrix} = 0\n$$\n$$\n(\\Delta - E)(-\\Delta - E) - \\left(2 t \\cos\\!\\left(\\frac{k a}{2}\\right)\\right)^2 = 0\n$$\n$$\nE^2 - \\Delta^2 - 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right) = 0\n$$\n求解 $E$，我们得到两个能带（导带和价带）的能量色散关系：\n$$\nE_{\\pm}(k) = \\pm \\sqrt{\\Delta^2 + 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right)}\n$$\n占据的价带对应于较低的能量 $E_-(k)$，未占据的导带对应于较高的能量 $E_+(k)$。能带之间的能隙为 $E_g(k) = E_+(k) - E_-(k) = 2 \\sqrt{\\Delta^2 + 4 t^2 \\cos^2(ka/2)}$。由于 $\\Delta  0$ 且 $t0$，对于实数 $k$，$\\cos^2(ka/2) \\ge 0$，因此平方根下的项严格为正，这证实了对于所有实数 $k$ 都存在非零能隙。\n\n接下来，我们寻找使能带简并的复数 $k$ 值。这发生在能隙闭合时，即平方根的参数必须为零：\n$$\n\\Delta^2 + 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right) = 0\n$$\n$$\n\\cos^2\\!\\left(\\frac{k a}{2}\\right) = -\\frac{\\Delta^2}{4 t^2}\n$$\n对两边取平方根，得到：\n$$\n\\cos\\!\\left(\\frac{k a}{2}\\right) = \\pm i \\frac{\\Delta}{2 t}\n$$\n为了求解复波矢 $k$，我们令 $k = k_{\\text{re}} + i k_{\\text{im}}$，其中 $k_{\\text{re}}$ 和 $k_{\\text{im}}$ 分别是 $k$ 的实部和虚部。我们使用复数余弦的恒等式 $\\cos(x+iy) = \\cos(x)\\cosh(y) - i\\sin(x)\\sinh(y)$：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\cosh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) - i \\sin\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm i \\frac{\\Delta}{2 t}\n$$\n将此方程的实部和虚部相等，我们得到两个条件。首先，实部必须为零：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\cosh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = 0\n$$\n由于对于任意实数 $y$，$\\cosh(y) \\geq 1$，这个条件只有在余弦项为零时才能满足：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right) = 0\n$$\n这意味着对于任意整数 $n$，$\\frac{k_{\\text{re}} a}{2} = \\frac{\\pi}{2} + n\\pi$。对于这些 $k_{\\text{re}}$ 的值，我们有 $|\\sin(\\frac{k_{\\text{re}} a}{2})| = 1$。\n\n现在，我们让虚部相等：\n$$\n- \\sin\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm \\frac{\\Delta}{2 t}\n$$\n因为 $\\sin(\\frac{k_{\\text{re}} a}{2})$ 可以是 $+1$ 或 $-1$，我们可以写出：\n$$\n\\mp \\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm \\frac{\\Delta}{2 t}\n$$\n无论哪种情况，这都简化为要求 $\\sinh(\\frac{k_{\\text{im}} a}{2})$ 的量值满足：\n$$\n\\left| \\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) \\right| = \\frac{\\Delta}{2 t}\n$$\n我们正在寻找具有最小非零量值 $k_{\\text{im}}$ 的解。不失一般性，我们可以求解一个正的 $k_{\\text{im}}$：\n$$\n\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\frac{\\Delta}{2 t}\n$$\n通过取反双曲正弦来求解 $k_{\\text{im}}$：\n$$\n\\frac{k_{\\text{im}} a}{2} = \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n$$\nk_{\\text{im}} = \\frac{2}{a} \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n这表示能带接触时复波矢虚部的最小正值。当 $x$ 很大时，瓦尼尔函数 $|w(x)|$ 的渐近衰减由 $|w(x)| \\propto \\exp(-|k_{\\text{im}}||x|)$ 给出。问题通过 $|w(x)| \\propto \\exp(-x/\\ell)$ 定义了衰减长度 $\\ell$。通过比较，我们有：\n$$\n\\frac{1}{\\ell} = |k_{\\text{im}}| = \\frac{2}{a} \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n因此，衰减长度 $\\ell$ 是：\n$$\n\\ell = \\frac{a}{2 \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)}\n$$\n这个表达式是用给定的参数 $a$、$t$ 和 $\\Delta$ 表示的。由于 $a$ 的单位是米，而 $\\arcsinh$ 的参数是无量纲的（因为 $\\Delta$ 和 $t$ 都是能量），因此得到的衰减长度 $\\ell$ 的单位是米，符合要求。", "answer": "$$\n\\boxed{\\frac{a}{2 \\arcsinh\\left(\\frac{\\Delta}{2 t}\\right)}}\n$$", "id": "3461802"}, {"introduction": "在理解了瓦尼尔函数的理论特性之后，一个核心的实践挑战是如何在复杂体系（特别是金属）中构建它们。在金属中，导带与价带发生纠缠，使得简单的傅里叶变换方法失效，必须采用“退纠缠”方法来选取一个平滑的子空间。本实践将指导您实现一个鲁棒的规范选择方案，用于在存在能带交叉的情况下计算最大局域瓦尼尔函数（MLWFs），从而掌握分析复杂材料电子结构的一项前沿计算技术 ([@problem_id:3461832])。", "problem": "给定一个具有周期性边界条件的离散一维晶格动量网格、固定数量的纠缠能带，以及一个通过退纠缠和规范选择来构造的固定数量的目标局域化函数。任务是实现一个数学上精确、鲁棒且可复现的方案，该方案构造一个平滑的规范来控制一个离散化的展宽泛函，适用于类金属情况下存在能带交叉的最大局域化瓦尼尔函数。所有角度都应以弧度为单位进行解释。\n\n基本依据与定义：\n- 考虑一组幺正矩阵 $\\{B_k\\}_{k=0}^{K-1}$，其中每个 $B_k \\in \\mathbb{C}^{J \\times J}$ 代表在离散晶格动量点 $k$ 处 $J$ 个纠缠能带的一个正交归一的布洛赫框架，具有周期性边界条件 $k \\mapsto (k+1) \\bmod K$。在纠缠能带表示中，点间交叠矩阵定义为\n$$\nM(k) \\equiv B_k^\\dagger B_{k+1} \\in \\mathbb{C}^{J \\times J}.\n$$\n- 在全局希尔伯特空间中，提供了一组固定的 $J'  J$ 个试探轨道，由矩阵 $T \\in \\mathbb{C}^{J \\times J'}$ 表示。在每个 $k$ 点，定义纠缠能带表示中的投影子空间系数为\n$$\nA(k) \\equiv B_k^\\dagger T \\in \\mathbb{C}^{J \\times J'}.\n$$\n- 每个 $k$ 点的退纠缠子空间由一个具有正交归一列的矩阵 $W(k) \\in \\mathbb{C}^{J \\times J'}$ 来表征，该矩阵通过将 $A(k)$ 的列正交归一化得到（例如，通过薄 $QR$ 分解），使得 $W(k)^\\dagger W(k) = I_{J'}$ 且 $\\operatorname{span}(W(k)) = \\operatorname{span}(A(k))$。\n- 子空间到子空间的连接交叠定义为\n$$\nS(k) \\equiv W(k)^\\dagger M(k) W(k+1) \\in \\mathbb{C}^{J' \\times J'}.\n$$\n- 退纠缠子空间上的一个规范是一组幺正矩阵 $\\{V(k)\\}_{k=0}^{K-1}$，其中 $V(k) \\in \\mathbb{C}^{J' \\times J'}$，产生规范变换后的框架 $W(k)V(k)$。一个需要控制的、依赖于规范的离散展宽量度定义为\n$$\n\\Omega \\equiv \\sum_{k=0}^{K-1} \\left( J' - \\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2 \\right),\n$$\n其中 $k+1$ 在模 $K$ 的意义下理解。\n\n要求的构造方法：\n- 退纠缠：对于每个 $k$，通过将 $A(k) = B_k^\\dagger T$ 的列正交归一化来计算 $W(k)$。\n- 存在能带交叉时的鲁棒规范选择：构造 $V(0) = I_{J'}$，然后对于 $k = 0,1,\\dots,K-1$ 递归地确定 $V(k+1)$，以贪婪地最大化规范变换后框架中连接交叠的对角元素大小。具体来说，在每一步：\n  1. 令 $A_{\\mathrm{link}}(k) \\equiv V(k)^\\dagger S(k)$。\n  2. 在所有大小为 $J' \\times J'$ 的列排列 $\\Pi$ 中（对于 $J' = 2$，只有两种排列），选择能够最大化 $\\sum_{n=1}^{J'} \\left| \\left[A_{\\mathrm{link}}(k)\\Pi\\right]_{nn} \\right|^2$ 的排列 $\\Pi^\\star$。\n  3. 定义一个对角幺正相位矩阵 $D$，其元素为 $D_{nn} = e^{-i \\arg\\left(\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}\\right)}$（如果对角元素为零，则将相位设为 $1$）。设置 $V(k+1) \\equiv \\Pi^\\star D$。\n- 在构造出 $\\{V(k)\\}$ 后，使用给定的公式计算 $\\Omega$。\n\n角度单位：下面指定的所有旋转角均以弧度为单位。\n\n测试套件：\n对于所有测试用例，使用 $J = 3$ 和 $J' = 2$，以及相同的试探轨道矩阵\n$$\nT = \\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0.15  0.2\n\\end{pmatrix}.\n$$\n定义 $3 \\times 3$ 旋转矩阵 $R_{12}(\\theta)$ 和 $R_{23}(\\theta)$ 以及对角幺正矩阵 $D(\\alpha_1,\\alpha_2,\\alpha_3)$ 如下\n$$\nR_{12}(\\theta) \\equiv \\begin{pmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}, \\quad\nR_{23}(\\theta) \\equiv \\begin{pmatrix}\n1  0  0 \\\\\n0  \\cos\\theta  -\\sin\\theta \\\\\n0  \\sin\\theta  \\cos\\theta\n\\end{pmatrix}, \\quad\nD(\\alpha_1,\\alpha_2,\\alpha_3) \\equiv \\operatorname{diag}\\left(e^{i\\alpha_1}, e^{i\\alpha_2}, e^{i\\alpha_3}\\right).\n$$\n令 $I_3$ 为 $3 \\times 3$ 单位矩阵，令 $P$ 为交换前两个基向量同时保持第三个不变的 $3 \\times 3$ 排列矩阵：\n$$\nP \\equiv \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n\n- 测试用例A（无交叉的平滑演化）：\n  - 使用 $K = 4$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(0.2)\\, D(0.1,-0.05,0.2), \\quad\n  B_2 = R_{12}(0.4)\\, R_{23}(0.15)\\, D(0.2,-0.1,0.3), \\quad\n  B_3 = R_{12}(0.6)\\, R_{23}(0.3)\\, D(0.3,-0.15,0.4).\n  $$\n- 测试用例B（通过排列实现的能带交叉）：\n  - 使用 $K = 5$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(0.5)\\, D(0.05,-0.02,0.1), \\quad\n  B_2 = R_{12}(1.0)\\, R_{23}(0.3)\\, D(0.1,-0.04,0.15), \\\\\n  B_3 = P\\, R_{12}(1.2)\\, R_{23}(0.5)\\, D(0.12,-0.05,0.2), \\quad\n  B_4 = P\\, R_{12}(1.4)\\, R_{23}(0.7)\\, D(0.14,-0.06,0.25).\n  $$\n- 测试用例C（由于剧烈旋转导致的近奇异连接）：\n  - 使用 $K = 3$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(1.2)\\, R_{23}(1.2)\\, D(0.2,-0.2,0.3), \\quad\n  B_2 = R_{12}(2.2)\\, R_{23}(2.0)\\, D(0.4,-0.3,0.6).\n  $$\n\n要求：\n- 实现上述的退纠缠和规范构造方案，并为每个测试用例计算 $\\Omega$。\n- 数值稳定性：在对 $A(k)$ 进行正交归一化时，使用数值稳定的算法（例如，薄QR分解）。在计算相位时，将精确为零的复数视为具有相位 $0$。\n- 最终程序必须按顺序计算与测试用例A、测试用例B和测试用例C相对应的三个 $\\Omega$ 值，并将它们打印为单行，形式为方括号内包含的逗号分隔列表，每个值四舍五入到恰好 $10$ 位小数（例如，$[0.1234567890,0.0000000000,1.4142135624]$）。不允许有任何其他输出。", "solution": "该问题要求实现一个特定的计算方案，用于为一维离散晶体中的一组纠缠电子能带构造一个平滑的规范，这是计算金属体系最大局域化瓦尼尔函数的一项常见任务。目标是为三个不同的测试用例计算一个离散的展宽泛函 $\\Omega$。\n\n该过程基于Marzari-Vanderbilt局域化理论的原理，并针对从一个较大的 $J$ 个能带的空间中退纠缠出 $J'$ 个能带的子集进行了调整。其核心思想是选择一个规范（一组幺正变换），使得相邻晶格动量点（$k$点）之间的基态连接尽可能平滑。动量空间中更平滑的连接对应于实空间中更局域化的函数。\n\n该解决方案通过遵循规定的算法步骤来构建：\n\n1.  **子空间定义与退纠缠**：\n    起点是在 $K$ 个动量点的离散网格上的一组 $J$ 个纠缠布洛赫框架 $\\{B_k\\}_{k=0}^{K-1}$。在这个 $J$ 维希尔伯特空间内，通过投影定义一个维度为 $J'$ 的目标子空间。一组由矩阵 $T \\in \\mathbb{C}^{J \\times J'}$ 的列表示的 $J'$ 个全局试探轨道，被投影到每个 $k$ 点的布洛赫框架上。这产生了系数矩阵 $A(k) = B_k^\\dagger T$。$A(k)$ 的列张成了所期望的 $J'$ 维“退纠缠”子空间，但它们通常不是正交归一的。\n    为了获得一个一致且数值稳定的表示，我们在每个 $k$ 点计算该子空间的一个正交归一基。这通过对 $A(k)$ 执行薄QR分解来实现，使得 $A(k) = W(k)R(k)$，其中 $W(k) \\in \\mathbb{C}^{J \\times J'}$ 具有正交归一的列（$W(k)^\\dagger W(k) = I_{J'}$），而 $R(k)$ 是一个上三角矩阵。$W(k)$ 的列构成了在 $k$ 点的退纠缠子空间的正交归一基。\n\n2.  **定义子空间交叠**：\n    为了量化相邻 $k$ 点子空间之间连接的平滑度，我们定义了交叠矩阵。原始纠缠框架之间的交叠是 $M(k) \\equiv B_k^\\dagger B_{k+1}$。退纠缠子空间之间的交叠则由此投影得到，即子空间到子空间的连接矩阵 $S(k) \\equiv W(k)^\\dagger M(k) W(k+1) \\in \\mathbb{C}^{J' \\times J'}$。矩阵 $S(k)$ 描述了 $k$ 点子空间的基如何变换为 $k+1$ 点子空间的基。请注意，所有涉及 $k+1$ 的索引都在模 $K$ 的意义下进行，以遵循晶体的周期性边界条件。\n\n3.  **为平滑性选择规范**：\n    基 $W(k)$ 的唯一性仅在幺正变换 $W(k) \\to W(k)V(k)$ 的意义下成立，其中 $V(k) \\in \\mathbb{C}^{J' \\times J'}$ 是幺正的。这是 $U(J')$ 规范自由度。目标是选择一组规范矩阵 $\\{V(k)\\}_{k=0}^{K-1}$ 以优化平滑度。规范变换后的连接矩阵为 $\\tilde{S}(k) = (W(k)V(k))^\\dagger M(k) (W(k+1)V(k+1)) = V(k)^\\dagger S(k) V(k+1)$。\n    一个平滑的规范是指对于所有 $k$，$\\tilde{S}(k)$ 都“尽可能对角化”。问题将非对角性（或展宽）的度量 $\\Omega$ 定义为：\n    $$ \\Omega \\equiv \\sum_{k=0}^{K-1} \\left( J' - \\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2 \\right) $$\n    最小化 $\\Omega$ 等价于最大化规范变换后连接矩阵对角元素模长的平方和。\n\n4.  **贪心递归算法**：\n    问题指定了一个贪心递归算法来构造规范。\n    - 我们首先固定第一个 $k$ 点的规范，即 $V(0) = I_{J'}$。\n    - 对于从 $0$ 到 $K-2$ 的每一步 $k$，我们基于已知的 $V(k)$ 和预先计算的连接 $S(k)$ 来确定 $V(k+1)$。该选择旨在贪婪地最大化当前连接的对角特性，即最大化 $\\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2$。\n    - 该算法将此优化简化为寻找 $V(k+1)$ 的两步过程。令 $A_{\\mathrm{link}}(k) \\equiv V(k)^\\dagger S(k)$。我们寻找能够最大化 $A_{\\mathrm{link}}(k) V(k+1)$ 对角和的 $V(k+1)$。规定的选择是 $V(k+1) = \\Pi^\\star D$，其中：\n        a. $\\Pi^\\star$ 是一个排列矩阵，它能最优地对齐 $A_{\\mathrm{link}}(k)$ 的列。对于 $J'=2$ 的情况，我们测试单位排列和交换排列，看哪一个能将较大的元素放在 $A_{\\mathrm{link}}(k)\\Pi$ 的对角线上。具体来说，我们选择能够最大化 $\\sum_{n=1}^{J'} |[A_{\\mathrm{link}}(k)\\Pi]_{nn}|^2$ 的排列 $\\Pi$。这一步对于处理能带交叉至关重要，因为在能带交叉处，态的特性可能会交换。\n        b. $D$ 是一个对角幺正矩阵，其相位的选择是为了将得到的对角元素 $\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}$ 旋转为实数且为正。这通过设置 $D_{nn} = \\exp(-i \\arg(\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}))$ 来实现。这确保了对于此连接，对总和 $|\\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn}|^2$ 的贡献被最大化。\n\n5.  **最终计算**：\n    在构造出全套规范矩阵 $\\{V(k)\\}_{k=0}^{K-1}$ 后，通过对每个连接的贡献求和来计算展宽泛函 $\\Omega$，其中包括从 $k=K-1$ 回到 $k=0$ 的周期性连接。\n\n整个过程通过计算实现。所有矩阵都表示为 `numpy` 数组。矩阵乘法和共轭转置等矩阵运算是标准操作。薄QR分解使用 `numpy.linalg.qr` 并在 `mode='reduced'` 模式下执行。复数的辐角使用 `numpy.angle` 计算，该函数能按要求正确处理零值输入。该算法应用于三个测试用例中的每一个，以得出所需的 $\\Omega$ 值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified scheme to construct a smooth gauge and computes the spread functional Omega.\n    \"\"\"\n\n    def get_rot_matrices(theta):\n        \"\"\"Helper to create 3x3 rotation matrices R12 and R23.\"\"\"\n        c, s = np.cos(theta), np.sin(theta)\n        r12 = np.array([\n            [c, -s, 0],\n            [s,  c, 0],\n            [0,  0, 1]\n        ], dtype=float)\n        r23 = np.array([\n            [1, 0,  0],\n            [0, c, -s],\n            [0, s,  c]\n        ], dtype=float)\n        return r12, r23\n\n    def get_diag_unitary(alpha1, alpha2, alpha3):\n        \"\"\"Helper to create a 3x3 diagonal unitary matrix.\"\"\"\n        return np.diag([np.exp(1j*alpha1), np.exp(1j*alpha2), np.exp(1j*alpha3)])\n\n    def compute_omega_for_case(K, B_frames, J, J_prime, T):\n        \"\"\"\n        Computes the spread functional Omega for a single test case.\n        \n        Args:\n            K (int): Number of k-points.\n            B_frames (list): List of JxJ unitary Bloch frames B_k.\n            J (int): Dimension of the entangled band space.\n            J_prime (int): Dimension of the disentangled subspace.\n            T (np.ndarray): JxJ' matrix of trial orbitals.\n            \n        Returns:\n            float: The computed value of the spread functional Omega.\n        \"\"\"\n        \n        # 1. Pre-computation of M, W, and S matrices\n        M_list = []\n        for k in range(K):\n            B_k_plus_1 = B_frames[(k + 1) % K]\n            M_k = B_frames[k].conj().T @ B_k_plus_1\n            M_list.append(M_k)\n\n        W_list = []\n        for k in range(K):\n            A_k = B_frames[k].conj().T @ T\n            # Thin QR factorization for orthonormalization\n            Q, _ = np.linalg.qr(A_k, mode='reduced')\n            W_list.append(Q)\n\n        S_list = []\n        for k in range(K):\n            W_k_plus_1 = W_list[(k + 1) % K]\n            S_k = W_list[k].conj().T @ M_list[k] @ W_k_plus_1\n            S_list.append(S_k)\n\n        # 2. Recursive gauge selection\n        V_list = [None] * K\n        V_list[0] = np.eye(J_prime, dtype=complex)\n        \n        # Permutation matrices for J'=2\n        perm_identity = np.eye(J_prime, dtype=complex)\n        perm_swap = np.array([[0, 1], [1, 0]], dtype=complex)\n        permutations = [perm_identity, perm_swap]\n\n        for k in range(K - 1):\n            V_k = V_list[k]\n            S_k = S_list[k]\n            A_link_k = V_k.conj().T @ S_k\n            \n            # Find the best permutation Pi_star\n            best_perm = None\n            max_sum_sq_diag = -1.0\n\n            for Pi in permutations:\n                M_prime = A_link_k @ Pi\n                current_sum = np.sum(np.abs(np.diag(M_prime))**2)\n                if current_sum > max_sum_sq_diag:\n                    max_sum_sq_diag = current_sum\n                    best_perm = Pi\n            \n            Pi_star = best_perm\n            M_prime = A_link_k @ Pi_star\n            \n            # Construct diagonal phase matrix D\n            diag_elements = np.diag(M_prime)\n            # np.angle(0.0 + 0.0j) is 0.0, satisfying the problem condition\n            phases = np.angle(diag_elements)\n            D_diag = np.exp(-1j * phases)\n            D = np.diag(D_diag)\n            \n            # Set the next gauge matrix\n            V_list[k + 1] = Pi_star @ D\n\n        # 3. Compute Omega\n        omega_total = 0.0\n        for k in range(K):\n            V_k = V_list[k]\n            S_k = S_list[k]\n            V_k_plus_1 = V_list[(k + 1) % K]\n            \n            # Gauge-transformed link matrix\n            L_k = V_k.conj().T @ S_k @ V_k_plus_1\n            \n            # Sum current k-point's contribution to Omega\n            term_k = J_prime - np.sum(np.abs(np.diag(L_k))**2)\n            omega_total += term_k\n            \n        return omega_total\n\n    # --- Problem Constants ---\n    J, J_prime = 3, 2\n    T = np.array([[1, 0], [0, 1], [0.15, 0.2]], dtype=float)\n    I3 = np.eye(J)\n    P = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]], dtype=float)\n\n    # --- Test Case Definitions ---\n    \n    # Test Case A\n    K_A = 4\n    R12_02, _ = get_rot_matrices(0.2)\n    R12_04, _ = get_rot_matrices(0.4)\n    R23_015 = get_rot_matrices(0.15)[1]\n    R12_06, _ = get_rot_matrices(0.6)\n    R23_03 = get_rot_matrices(0.3)[1]\n    B_A = [\n        I3,\n        R12_02 @ get_diag_unitary(0.1, -0.05, 0.2),\n        R12_04 @ R23_015 @ get_diag_unitary(0.2, -0.1, 0.3),\n        R12_06 @ R23_03 @ get_diag_unitary(0.3, -0.15, 0.4)\n    ]\n\n    # Test Case B\n    K_B = 5\n    R12_05, _ = get_rot_matrices(0.5)\n    R12_10, _ = get_rot_matrices(1.0)\n    R23_03_B = get_rot_matrices(0.3)[1]\n    R12_12, _ = get_rot_matrices(1.2)\n    R23_05 = get_rot_matrices(0.5)[1]\n    R12_14, _ = get_rot_matrices(1.4)\n    R23_07 = get_rot_matrices(0.7)[1]\n\n    B_B = [\n        I3,\n        R12_05 @ get_diag_unitary(0.05, -0.02, 0.1),\n        R12_10 @ R23_03_B @ get_diag_unitary(0.1, -0.04, 0.15),\n        P @ R12_12 @ R23_05 @ get_diag_unitary(0.12, -0.05, 0.2),\n        P @ R12_14 @ R23_07 @ get_diag_unitary(0.14, -0.06, 0.25)\n    ]\n    \n    # Test Case C\n    K_C = 3\n    R12_12C, R23_12 = get_rot_matrices(1.2)\n    R12_22, _ = get_rot_matrices(2.2)\n    R23_20 = get_rot_matrices(2.0)[1]\n\n    B_C = [\n        I3,\n        R12_12C @ R23_12 @ get_diag_unitary(0.2, -0.2, 0.3),\n        R12_22 @ R23_20 @ get_diag_unitary(0.4, -0.3, 0.6)\n    ]\n\n    test_cases = [\n        (K_A, B_A),\n        (K_B, B_B),\n        (K_C, B_C)\n    ]\n    \n    results = []\n    for K, B_frames in test_cases:\n        omega = compute_omega_for_case(K, B_frames, J, J_prime, T)\n        results.append(omega)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3461832"}]}