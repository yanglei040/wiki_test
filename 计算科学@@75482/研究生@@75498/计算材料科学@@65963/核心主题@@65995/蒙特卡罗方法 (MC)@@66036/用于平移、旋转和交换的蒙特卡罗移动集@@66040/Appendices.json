{"hands_on_practices": [{"introduction": "任何有效的蒙特卡洛模拟的基石都是细致平衡原理。虽然标准的Metropolis接受准则很简单，但要确保它在复杂的混合移动方案中成立，就需要仔细关注提议概率。这个练习 [@problem_id:3467384] 提供了一个严格的测试来验证细致平衡，迫使你剖析正向和反向的转移概率，并揭示看似无害的依赖状态的移动选择如何可能破坏这一基本条件。", "problem": "你必须实现一个完整的、可运行的程序，该程序用于评估一个在平移、旋转和交换移动之间进行选择的混合移动马尔可夫链蒙特卡罗步骤，在两种不同的移动类型选择方案下是否满足细致平衡条件。该程序必须为每个指定的测试用例计算用于验证细致平衡的比率，并将这些比率作为浮点数输出。\n\n首先从一个基本原则开始：为了使马尔可夫链收敛到玻尔兹曼分布，必须满足细致平衡条件。设一个系统具有状态 $s$，其能量为 $E(s)$，玻尔兹曼平衡概率为 $P_{\\mathrm{eq}}(s) \\propto \\exp(-\\beta E(s))$，其中 $\\beta$ 是逆温度。设从 $s$ 到 $s'$ 的转移概率为 $T(s \\to s') = q(s \\to s') \\, a(s \\to s')$，其中 $q(s \\to s')$ 是提议分布，$a(s \\to s')$ 是接受概率。当提议是对称的时，经典的 Metropolis 接受准则是 $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$。细致平衡要求\n$$\nP_{\\mathrm{eq}}(s)\\,T(s \\to s') \\;=\\; P_{\\mathrm{eq}}(s')\\,T(s' \\to s).\n$$\n为了对单个提议的移动 $s \\to s'$ 进行数值上的细致平衡检验，定义比率\n$$\nR(s,s') \\;=\\; \\frac{P_{\\mathrm{eq}}(s)\\,q(s \\to s')\\,a(s \\to s')}{P_{\\mathrm{eq}}(s')\\,q(s' \\to s)\\,a(s' \\to s)}.\n$$\n如果细致平衡精确成立，则 $R(s,s') = 1$。\n\n系统模型。考虑一个由 $N$ 个格点组成的具有周期性边界条件的一维环。每个格点 $i$ 有一个类型 $t_i \\in \\{\\text{A}, \\text{B}, \\text{E}\\}$（A和B表示被A型和B型分子占据，E表示空）。取向角仅为A型分子定义；设 $\\theta_i$ 是格点 $i$ 上的取向角（如果 $t_i=\\text{A}$），否则未定义。角度必须以弧度处理。\n\n能量模型。使用最近邻相互作用和单体取向场：\n- 定义 $s_i = +1$ 如果 $t_i=\\text{A}$，$s_i = -1$ 如果 $t_i=\\text{B}$，以及 $s_i = 0$ 如果 $t_i=\\text{E}$。\n- 最近邻能量为\n$$\nE_{\\mathrm{nn}}(s) \\;=\\; J \\sum_{i=0}^{N-1} s_i\\,s_{(i+1)\\bmod N}.\n$$\n- A型分子的转动能量为\n$$\nE_{\\mathrm{rot}}(s) \\;=\\; k \\sum_{i: t_i=\\text{A}} \\left(1 - \\cos(\\theta_i)\\right).\n$$\n- 总能量为 $E(s) = E_{\\mathrm{nn}}(s) + E_{\\mathrm{rot}}(s)$。\n\n蒙特卡罗移动集。实现三种移动类型：\n1. 平移：在所有被占据的格点中均匀选择一个格点 $i$。均匀选择一个方向（左或右）。如果相邻格点为空，则提议将格点 $i$ 上的粒子移动到该相邻格点，并携带其取向角 $\\theta_i$。如果相邻格点不为空，则提议保持状态不变（后一种情况在测试套件中不使用；仅测试改变状态的移动）。\n2. 旋转：在所有A型格点中均匀选择一个格点 $i$（$t_i=\\text{A}$）。提议 $\\theta_i' = \\theta_i + \\delta$，其中 $\\delta \\sim \\mathcal{N}(0,\\sigma^2)$；$\\sigma$ 是标准差，提议密度为 $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{\\delta^2}{2\\sigma^2}\\right)$。\n3. 局部交换：在 $N$ 个键中均匀选择一个最近邻键 $(i,i+1)$。如果两个格点都被占据且类型不同（一个A和一个B），则提议交换键两端的类型；如果类型相同或其中一个格点为空，则提议保持状态不变（测试套件仅使用改变状态的交换）。\n\n混合移动的选择方案：\n- 平衡选择：以固定的概率 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$ 选择平移、旋转和交换，这与当前状态无关。在每种移动类型内部，按上文规定均匀选择目标。所产生的提议在经典Metropolis接受准则所要求的意义上是对称的。\n- 有偏（状态依赖）选择：计算当前状态 $s$ 下每种移动类型的合格提议数量：\n    - 设 $m_{\\mathrm{T}}(s)$ 为会改变状态的有序平移提议的数量（每个被占据的格点为其每个空的相邻方向贡献一个计数）。\n    - 设 $m_{\\mathrm{R}}(s)$ 为A型格点的数量。\n    - 设 $m_{\\mathrm{S}}(s)$ 为被不同类型（A–B 或 B–A）占据的最近邻键的数量。\n  定义移动类型选择概率 $p_{\\mathrm{T}}(s) = \\frac{m_{\\mathrm{T}}(s)}{m_{\\Sigma}(s)}$，$p_{\\mathrm{R}}(s) = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)}$，$p_{\\mathrm{S}}(s) = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)}$，其中 $m_{\\Sigma}(s) = m_{\\mathrm{T}}(s) + m_{\\mathrm{R}}(s) + m_{\\mathrm{S}}(s)$。在选定的移动类型内部，从合格的提议中均匀选择。对于旋转，连续的提议密度 $q_{\\mathrm{rot}}(\\delta)$ 乘以离散的选择因子。请注意，此方案使得 $q(s \\to s')$ 与 $1/m_{\\Sigma}(s)$ 和任何特定移动类型的连续密度之积成正比，并且 $m_{\\Sigma}$ 在 $s$ 和 $s'$ 之间可能会改变。\n\n接受准则。在所有情况下，均使用经典的 Metropolis 接受准则 $a(s \\to s') = \\min\\!\\left(1, \\exp\\!\\left(-\\beta (E(s') - E(s))\\right)\\right)$。角度必须以弧度处理。\n\n任务。对于下面的每个测试用例，使用指定的选择方案和移动来计算上面定义的比率 $R(s,s')$。你的程序必须生成单行输出，其中包含所有测试用例的比率，格式为方括号内的逗号分隔列表。\n\n所有测试的常数：$N=4$，$\\beta=1.0$，$J=0.5$，$k=0.3$，$\\sigma=0.1$（弧度）。角度必须以弧度解释。\n\n测试套件：\n- 测试 1 (平衡平移)：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\text{None}, \\theta_3=1.0]$。\n    - 移动：将格点 $i=1$ 的粒子向右平移（到格点 $2$）。\n    - 选择方案：平衡选择，概率为 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$。\n- 测试 2 (改变移动计数的有偏局部交换)：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$。\n    - 移动：交换键 $(0,1)$ 两端的粒子。\n    - 选择方案：有偏选择，概率为定义的 $p_{\\mathrm{T}}(s)$、$p_{\\mathrm{R}}(s)$、$p_{\\mathrm{S}}(s)$。\n- 测试 3 (保持移动计数的有偏旋转)：\n    - 初始类型：$[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n    - 初始角度：$[\\theta_0=0.0, \\text{None}, \\theta_2=0.0, \\text{None}]$。\n    - 移动：在格点 $i=0$ 处旋转 $\\delta = 0.5$ 弧度。\n    - 选择方案：有偏选择，概率为定义的 $p_{\\mathrm{T}}(s)$、$p_{\\mathrm{R}}(s)$、$p_{\\mathrm{S}}(s)$。\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的结果，结果之间用逗号分隔（例如，“[result1,result2,result3]”），其中每个结果是对应测试用例的 $R(s,s')$ 的浮点值，根据上述定义精确计算。角度单位是弧度；不需要其他物理单位。确保数值计算精确且自洽。程序必须是自包含的，并且无需任何用户输入即可产生输出。", "solution": "该问题要求在两种不同的移动选择方案下，为一个混合移动蒙特卡罗模拟计算细致平衡验证比率 $R(s,s')$。该比率定义为：\n$$\nR(s,s') = \\frac{P_{\\mathrm{eq}}(s)\\,T(s \\to s')}{P_{\\mathrm{eq}}(s')\\,T(s' \\to s)}\n$$\n其中 $s$ 和 $s'$ 是初始和最终状态，$P_{\\mathrm{eq}}(x) \\propto \\exp(-\\beta E(x))$ 是平衡概率，$T(x \\to y) = q(x \\to y)\\,a(x \\to y)$ 是转移概率。$q(x \\to y)$ 是提议概率，$a(x \\to y)$ 是接受概率。\n\n问题指定在所有情况下都使用经典的 Metropolis 接受准则：\n$$\na(s \\to s') = \\min\\left(1, \\exp\\left(-\\beta (E(s') - E(s))\\right)\\right)\n$$\n我们来分析比率 $R(s,s')$。代入定义，我们得到：\n$$\nR(s,s') = \\frac{\\exp(-\\beta E(s))}{\\exp(-\\beta E(s'))} \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\frac{a(s \\to s')}{a(s' \\to s)}\n$$\n设 $\\Delta E = E(s') - E(s)$。平衡概率的比值为 $\\exp(-\\beta(E(s)-E(s'))) = \\exp(\\beta\\Delta E)$。\n接受概率的比值为：\n$$\n\\frac{a(s \\to s')}{a(s' \\to s)} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(-(-\\beta\\Delta E)))} = \\frac{\\min(1, \\exp(-\\beta\\Delta E))}{\\min(1, \\exp(\\beta\\Delta E))}\n$$\n设 $X = \\exp(-\\beta\\Delta E)$。接受概率比变为 $\\frac{\\min(1, X)}{\\min(1, 1/X)}$。可以证明，对于任何 $X > 0$，该表达式恒等于 $X$。因此，接受概率比简化为 $\\exp(-\\beta\\Delta E)$。\n\n将这些简化项代回 $R(s,s')$ 的表达式中，得到：\n$$\nR(s,s') = \\exp(\\beta\\Delta E) \\cdot \\frac{q(s \\to s')}{q(s' \\to s)} \\cdot \\exp(-\\beta\\Delta E) = \\frac{q(s \\to s')}{q(s' \\to s)}\n$$\n这是一个显著的简化。验证比率 $R(s,s')$ 简化为正向和反向提议概率的比值。因此，计算时不需要状态的能量、温度 $\\beta$ 以及具体的能量参数 $J$ 和 $k$，尽管它们在问题描述中已给出。任务简化为为每个测试用例正确计算 $q(s \\to s')$ 和 $q(s' \\to s)$。\n\n总提议概率 $q(s \\to s')$ 是选择一种移动类型的概率与在该类型中选择特定基本移动的概率的乘积。\n\n以下是使用常数 $N=4, \\beta=1, J=0.5, k=0.3, \\sigma=0.1$ 对每个测试用例进行的逐步计算。\n\n**测试 1：平衡平移**\n- 初始状态 $s$：类型为 $[\\text{A}, \\text{B}, \\text{E}, \\text{A}]$。有 $3$ 个被占据的格点。\n- 最终状态 $s'$：类型为 $[\\text{A}, \\text{E}, \\text{B}, \\text{A}]$。有 $3$ 个被占据的格点。\n- 移动：将格点 $i=1$ 的粒子平移到格点 $i=2$。\n- 选择方案：平衡选择，概率为 $c_{\\mathrm{T}} = c_{\\mathrm{R}} = c_{\\mathrm{S}} = 1/3$。\n\n正向提议概率 $q(s \\to s')$ 为：\n$q(s \\to s') = P(\\text{select Translation}) \\times P(\\text{select particle at } i=1) \\times P(\\text{select direction right})$\n状态 $s$ 中被占据的格点数为 $3$。\n$$\nq(s \\to s') = c_{\\mathrm{T}} \\times \\frac{1}{\\text{num occupied}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\n反向移动是在状态 $s'$ 中将格点 $i=2$ 的粒子移回格点 $i=1$。\n状态 $s'$ 中被占据的格点数为 $3$。\n$$\nq(s' \\to s) = c_{\\mathrm{T}} \\times \\frac{1}{\\text{num occupied}} \\times \\frac{1}{2} = \\frac{1}{3} \\times \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{18}\n$$\n比率为 $R(s,s') = \\frac{1/18}{1/18} = 1.0$。\n\n**测试 2：有偏局部交换**\n- 初始状态 $s$：格点 $[0, 1, 2, 3]$ 的类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{E}]$。\n- 最终状态 $s'$：类型为 $[\\text{B}, \\text{A}, \\text{A}, \\text{E}]$。\n- 移动：交换键 $(0,1)$ 两端的类型。\n- 选择方案：有偏选择，概率依赖于计数 $m_{\\mathrm{T}}(s)$、$m_{\\mathrm{R}}(s)$ 和 $m_{\\mathrm{S}}(s)$。\n\n对于初始状态 $s = [\\text{A}, \\text{B}, \\text{A}, \\text{E}]$：\n- $m_{\\mathrm{T}}(s)$：向空位点的平移。格点 $0$ 可以向左移动到 $3(\\text{E})$；格点 $2$ 可以向右移动到 $3(\\text{E})$。所以，$m_{\\mathrm{T}}(s)=2$。\n- $m_{\\mathrm{R}}(s)$：A型格点的数量。格点 $0$ 和 $2$ 是A。所以，$m_{\\mathrm{R}}(s)=2$。\n- $m_{\\mathrm{S}}(s)$：A-B键的数量。键 $(0,1)$ 和 $(1,2)$ 是A-B/B-A。所以，$m_{\\mathrm{S}}(s)=2$。\n- 总提议数：$m_{\\Sigma}(s) = m_{\\mathrm{T}}(s)+m_{\\mathrm{R}}(s)+m_{\\mathrm{S}}(s) = 2+2+2=6$。\n\n正向提议概率 $q(s \\to s')$ 为：\n$q(s \\to s') = P(\\text{select Swap}) \\times P(\\text{select bond } (0,1) \\text{ | Swap})$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{S}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{S}}(s)} = \\frac{2}{6} \\times \\frac{1}{2} = \\frac{1}{6}\n$$\n对于最终状态 $s' = [\\text{B}, \\text{A}, \\text{A}, \\text{E}]$：\n- $m_{\\mathrm{T}}(s')$：格点 $0$ 可以向左移动到 $3(\\text{E})$；格点 $2$ 可以向右移动到 $3(\\text{E})$。所以，$m_{\\mathrm{T}}(s')=2$。\n- $m_{\\mathrm{R}}(s')$：格点 $1$ 和 $2$ 是A。所以，$m_{\\mathrm{R}}(s')=2$。\n- $m_{\\mathrm{S}}(s')$：只有键 $(0,1)$ 是B-A。所以，$m_{\\mathrm{S}}(s')=1$。\n- 总提议数：$m_{\\Sigma}(s') = 2+2+1=5$。\n\n反向提议概率 $q(s' \\to s)$ 对应于在状态 $s'$ 中交换键 $(0,1)$：\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{S}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{S}}(s')} = \\frac{1}{5} \\times \\frac{1}{1} = \\frac{1}{5}\n$$\n比率为 $R(s,s') = \\frac{1/6}{1/5} = \\frac{5}{6}$。\n\n**测试 3：有偏旋转**\n- 初始状态 $s$：类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n- 最终状态 $s'$：类型为 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}]$。\n- 移动：将格点 $i=0$ 旋转 $\\delta = 0.5$ 弧度。\n- 选择方案：有偏选择。\n\n对于状态 $s = [\\text{A}, \\text{B}, \\text{A}, \\text{B}]$（以及 $s'$，因为类型不变）：\n- $m_{\\mathrm{T}}(s)$：没有空格点。所以，$m_{\\mathrm{T}}(s)=0$。\n- $m_{\\mathrm{R}}(s)$：格点 $0$ 和 $2$ 是A。所以，$m_{\\mathrm{R}}(s)=2$。\n- $m_{\\mathrm{S}}(s)$：所有四个键都是A-B或B-A。所以，$m_{\\mathrm{S}}(s)=4$。\n- 总提议数：$m_{\\Sigma}(s) = 0+2+4=6$。\n\n正向提议是对格点 $0$ 进行 $\\delta=0.5$ 的旋转。这是一个连续移动，所以我们使用概率密度。\n$q(s \\to s') = P(\\text{select Rotation}) \\times P(\\text{select site } 0 \\text{ | Rotation}) \\times q_{\\mathrm{rot}}(\\delta)$\n$$\nq(s \\to s') = \\frac{m_{\\mathrm{R}}(s)}{m_{\\Sigma}(s)} \\times \\frac{1}{m_{\\mathrm{R}}(s)} \\times q_{\\mathrm{rot}}(0.5) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(0.5)\n$$\n其中 $q_{\\mathrm{rot}}(\\delta) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp(-\\frac{\\delta^2}{2\\sigma^2})$。\n反向移动是对格点 $0$ 进行 $-\\delta=-0.5$ 的旋转。由于 $s'$ 的类型构型相同，离散选择概率是相同的。\n$$\nq(s' \\to s) = \\frac{m_{\\mathrm{R}}(s')}{m_{\\Sigma}(s')} \\times \\frac{1}{m_{\\mathrm{R}}(s')} \\times q_{\\mathrm{rot}}(-\\delta) = \\frac{2}{6} \\times \\frac{1}{2} \\times q_{\\mathrm{rot}}(-0.5) = \\frac{1}{6} q_{\\mathrm{rot}}(-0.5)\n$$\n高斯提议密度是对称的，$q_{\\mathrm{rot}}(\\delta) = q_{\\mathrm{rot}}(-\\delta)$。因此，密度项相互抵消。\n比率为 $R(s,s') = \\frac{(1/6) q_{\\mathrm{rot}}(0.5)}{(1/6) q_{\\mathrm{rot}}(-0.5)} = 1.0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the detailed balance certification ratio R(s, s') for three\n    Monte Carlo move test cases.\n\n    As derived in the solution, the ratio R simplifies to q(s->s') / q(s'->s),\n    where q is the proposal probability. This calculation does not require\n    the energy, temperature, or related physical constants.\n    \"\"\"\n    N = 4\n\n    def get_m_counts(types):\n        \"\"\"\n        Calculates the number of eligible proposals for each move type.\n        m_T: Translation moves (occupied site next to empty site).\n        m_R: Rotation moves (number of 'A' type molecules).\n        m_S: Swap moves (number of A-B or B-A nearest-neighbor bonds).\n        \"\"\"\n        # m_T: Count valid translation moves\n        m_T = 0\n        occupied_indices = [i for i, site_type in enumerate(types) if site_type != 'E']\n        for i in occupied_indices:\n            left_neighbor_idx = (i - 1 + N) % N\n            right_neighbor_idx = (i + 1) % N\n            if types[left_neighbor_idx] == 'E':\n                m_T += 1\n            if types[right_neighbor_idx] == 'E':\n                m_T += 1\n\n        # m_R: Count type-A sites\n        m_R = types.count('A')\n\n        # m_S: Count A-B/B-A bonds\n        m_S = 0\n        for i in range(N):\n            neighbor_idx = (i + 1) % N\n            type_i = types[i]\n            type_j = types[neighbor_idx]\n            if type_i != 'E' and type_j != 'E' and type_i != type_j:\n                m_S += 1\n        \n        return m_T, m_R, m_S\n\n    results = []\n\n    # Test 1: Balanced translation\n    # Initial state s: ['A', 'B', 'E', 'A']. Final state s': ['A', 'E', 'B', 'A']\n    num_occupied_s = 3\n    num_occupied_sp = 3\n    c_T = 1.0 / 3.0\n    \n    q_fwd_1 = c_T * (1.0 / num_occupied_s) * (1.0 / 2.0)\n    q_rev_1 = c_T * (1.0 / num_occupied_sp) * (1.0 / 2.0)\n    ratio_1 = q_fwd_1 / q_rev_1\n    results.append(ratio_1)\n\n    # Test 2: Biased local swap\n    s_types_2 = ['A', 'B', 'A', 'E']\n    sp_types_2 = ['B', 'A', 'A', 'E']\n\n    # Forward move from s to s'\n    mt_s, mr_s, ms_s = get_m_counts(s_types_2)\n    msum_s = mt_s + mr_s + ms_s\n    q_fwd_2 = (ms_s / msum_s) * (1.0 / ms_s)\n\n    # Reverse move from s' to s\n    mt_sp, mr_sp, ms_sp = get_m_counts(sp_types_2)\n    msum_sp = mt_sp + mr_sp + ms_sp\n    q_rev_2 = (ms_sp / msum_sp) * (1.0 / ms_sp)\n\n    ratio_2 = q_fwd_2 / q_rev_2\n    results.append(ratio_2)\n\n    # Test 3: Biased rotation\n    # For a rotation move, the type configuration does not change.\n    # The proposal probability for the angle change, q_rot(delta), is\n    # symmetric for delta and -delta, so it cancels out in the ratio.\n    s_types_3 = ['A', 'B', 'A', 'B']\n\n    # Forward move\n    mt_s3, mr_s3, ms_s3 = get_m_counts(s_types_3)\n    msum_s3 = mt_s3 + mr_s3 + ms_s3\n    # The term for q_rot(delta) is omitted as it will be 1.0 after cancellation.\n    q_fwd_3 = (mr_s3 / msum_s3) * (1.0 / mr_s3)\n\n    # Reverse move (state types are the same)\n    q_rev_3 = q_fwd_3 # Since m_counts are the same and q_rot(-delta) = q_rot(delta)\n    \n    ratio_3 = q_fwd_3 / q_rev_3\n    results.append(ratio_3)\n\n    print(f\"[{','.join(f'{r:.15f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "3467384"}, {"introduction": "从理论转向实践，我们现在考虑材料科学中的一个常见情景：模拟晶格模型。蒙特卡洛方法的计算效率源于能够局域地计算能量变化，从而避免了重新计算整个系统能量的昂贵代价。这个实践 [@problem_id:3467414] 使用团簇展开模型，让你亲手发现并验证这一原理，证明原子交换引起的能量变化仅取决于局域原子环境。", "problem": "考虑一个位于周期性一维晶格上的二元合金，该晶格有 $L$ 个格点，索引为 $i \\in \\{0,1,\\dots,L-1\\}$。原子类型由类自旋的占据变量 $\\sigma_i \\in \\{+1,-1\\}$ 表示，其中 $\\sigma_i = +1$ 表示 $A$ 类原子，$\\sigma_i = -1$ 表示 $B$ 类原子。能量由团簇展开（Cluster Expansion, CE）模型描述，总能量为 $U(\\boldsymbol{\\sigma}) = \\sum_{\\alpha} J_{\\alpha} \\, \\Phi_{\\alpha}(\\boldsymbol{\\sigma})$，其中每个团簇 $\\alpha$ 是一组晶格格点，$J_{\\alpha}$ 是相应的系数（单位为电子伏特，$\\mathrm{eV}$），$\\Phi_{\\alpha}(\\boldsymbol{\\sigma}) = \\prod_{i \\in \\alpha} \\sigma_i$ 是相关的基函数。设该 CE 包含大小为一（单点）、二（最近邻对）和三（沿环的最近邻三联体）的团簇，并采用周期性边界条件。\n\nMetropolis Monte Carlo (MMC) 中两个格点 $i$ 和 $j$ 之间的交换移动会交换 $i$ 和 $j$ 处的原子类型。在二元表示中，这种交换不同种类原子的操作等价于翻转两个自旋：$\\sigma'_i = -\\sigma_i$ 和 $\\sigma'_j = -\\sigma_j$，而所有其他自旋保持不变。如果 $\\sigma_i = \\sigma_j$，则交换操作不会改变 $\\boldsymbol{\\sigma}$。\n\n您必须从玻尔兹曼分布和细致平衡出发，在对称提议概率的假设下，推导出 MMC 交换的接受条件。然后，设计并实现一个计算程序，该程序仅使用局部的团簇能量差——限制在包含格点 $i$ 或格点 $j$ 的团簇上——来预测接受概率，并量化相对于全局重新计算总能量差的计算加速。\n\n您的程序必须对每个测试用例执行以下操作：\n- 为给定的 $L$ 以及单点团簇系数 $J_1$、最近邻对系数 $J_2$ 和最近邻三联体系数 $J_3$（均以 $\\mathrm{eV}$ 为单位）构建 CE。\n- 给定一个初始构型 $\\boldsymbol{\\sigma}$ 以及格点 $i$ 和 $j$ 之间的一次交换，通过在交换前后评估完整的 CE 来计算全局能量差 $\\Delta U_{\\mathrm{global}} = U(\\boldsymbol{\\sigma}') - U(\\boldsymbol{\\sigma})$。\n- 通过仅对满足 $i \\in \\alpha$ 或 $j \\in \\alpha$ 的团簇 $\\alpha$ 进行求和，使用基函数的差值 $J_{\\alpha}\\left(\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') - \\Phi_{\\alpha}(\\boldsymbol{\\sigma})\\right)$，来计算局部能量差 $\\Delta U_{\\mathrm{local}}$。\n- 使用推导出的 MMC 接受规则，在逆温度 $\\beta$（单位为 $\\mathrm{eV}^{-1}$）下，计算交换的接受概率。\n- 在数值容差范围内，验证 $\\Delta U_{\\mathrm{local}}$ 是否等于 $\\Delta U_{\\mathrm{global}}$，从而确认局部团簇能量差能准确预测接受概率。\n- 报告一个加速比，定义为全局重新计算中评估的团簇总数除以局部涉及的团簇数（即包含 $i$ 或 $j$ 的团簇数）。\n\n所有能量必须以 $\\mathrm{eV}$ 处理，逆温度 $\\beta$ 必须以 $\\mathrm{eV}^{-1}$ 为单位。接受概率必须以闭区间 $[0,1]$ 内的小数形式返回。\n\n测试套件：\n使用以下四个测试用例，它们探测了不同情况，包括一般情况、无变化的边界情况，以及为产生显著负能量和正能量变化而设计的情况。对于所有情况，使用 $L = 8$ 和 $\\beta = 40.0$（单位 $\\mathrm{eV}^{-1}$）。系数为 $J_1 = 0.0$（$\\mathrm{eV}$），$J_2 = 0.2$（$\\mathrm{eV}$），以及 $J_3 = -0.05$（$\\mathrm{eV}$）。CE 包括：\n- 单点团簇：对所有 $i$ 的 $\\{i\\}$。\n- 最近邻对：对所有 $i$ 的 $\\{i, (i+1) \\bmod L\\}$。\n- 最近邻三联体：对所有 $i$ 的 $\\{i, (i+1) \\bmod L, (i+2) \\bmod L\\}$。\n\n用例：\n- 用例 1（相邻不同类原子交换，交替构型）：\n  - $\\boldsymbol{\\sigma} = [ +1, -1, +1, -1, +1, -1, +1, -1 ]$\n  - $(i,j) = (1,2)$\n- 用例 2（边界情况，交换相同种类原子无变化）：\n  - $\\boldsymbol{\\sigma} = [ +1, -1, +1, -1, +1, -1, +1, -1 ]$\n  - $(i,j) = (0,2)$\n- 用例 3（设计的负 $\\Delta U$，对齐的邻域）：\n  - $\\boldsymbol{\\sigma} = [ +1, +1, +1, -1, -1, -1, +1, +1 ]$\n  - $(i,j) = (1,4)$\n- 用例 4（设计的正 $\\Delta U$，反对齐的邻域）：\n  - $\\boldsymbol{\\sigma} = [ +1, -1, -1, +1, -1, +1, +1, -1 ]$\n  - $(i,j) = (3,4)$\n\n您的程序应生成单行输出，其中包含每个用例的三元组 $[p_{\\mathrm{acc}}, \\text{match}, r]$，$p_{\\mathrm{acc}}$ 是接受概率（一个小数），$\\text{match}$ 是一个布尔值，指示 $\\Delta U_{\\mathrm{local}}$ 是否在数值容差内等于 $\\Delta U_{\\mathrm{global}}$，$r$ 是加速比（一个小数）。将四个用例的结果汇总到一个列表中，并以逗号分隔的列表形式打印，格式严格如下：\n$[[p_1,\\text{match}_1,r_1],[p_2,\\text{match}_2,r_2],[p_3,\\text{match}_3,r_3],[p_4,\\text{match}_4,r_4]]$", "solution": "此问题的分析和求解分三个阶段进行。首先，我们从细致平衡原理推导 Metropolis Monte Carlo (MMC) 交换移动的接受概率。其次，我们在团簇展开 (CE) 框架内分析交换移动导致的能量变化 $\\Delta U$，并证明它可以局部计算。第三，我们概述解决给定测试用例的计算流程。\n\n### 1. Metropolis 接受概率的推导\n\nMetropolis Monte Carlo 模拟的基础是细致平衡原理，它确保系统向玻尔兹曼平衡分布演化并从中抽样。对于系统的任意两个状态 $\\boldsymbol{\\sigma}$ 和 $\\boldsymbol{\\sigma}'$，细致平衡条件表述为：\n$$P(\\boldsymbol{\\sigma}) W(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') = P(\\boldsymbol{\\sigma}') W(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})$$\n其中 $P(\\boldsymbol{\\sigma})$ 是状态 $\\boldsymbol{\\sigma}$ 的平衡概率，$W(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')$ 是从 $\\boldsymbol{\\sigma}$ 到 $\\boldsymbol{\\sigma}'$ 的转移速率。\n\n在正则系综中，一个状态的概率由玻尔兹曼分布给出：\n$$P(\\boldsymbol{\\sigma}) = \\frac{1}{Z} \\exp(-\\beta U(\\boldsymbol{\\sigma}))$$\n其中 $U(\\boldsymbol{\\sigma})$ 是该状态的能量，$\\beta = 1/(k_B T)$ 是逆温度（由于能量单位是 $\\mathrm{eV}$，$\\beta$ 的单位是 $\\mathrm{eV}^{-1}$，因此 $k_B$ 设为 $1$），$Z$ 是配分函数。\n\n转移速率由提议概率 $g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')$ 和接受概率 $p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')$ 组成：\n$$W(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') = g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')$$\n将玻尔兹曼分布和转移速率表达式代入细致平衡方程，得到：\n$$\\exp(-\\beta U(\\boldsymbol{\\sigma})) g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') = \\exp(-\\beta U(\\boldsymbol{\\sigma}')) g(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma}) p_{\\mathrm{acc}}(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})$$\n这可以重新整理，得到接受概率的比值：\n$$\\frac{p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')}{p_{\\mathrm{acc}}(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})} = \\frac{g(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})}{g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')} \\exp(-\\beta (U(\\boldsymbol{\\sigma}') - U(\\boldsymbol{\\sigma}))) = \\frac{g(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})}{g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')} \\exp(-\\beta \\Delta U)$$\n问题指定了交换移动，即随机选择两个格点并交换它们的占据情况。提议交换格点 $i$ 和 $j$ 的概率与提议交换格点 $j$ 和 $i$ 的概率相同。这意味着提议概率是对称的：$g(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') = g(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})$。因此，提议概率的比值为 1。细致平衡条件简化为：\n$$\\frac{p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}')}{p_{\\mathrm{acc}}(\\boldsymbol{\\sigma}' \\to \\boldsymbol{\\sigma})} = \\exp(-\\beta \\Delta U)$$\n满足此条件的 Metropolis 接受概率选择为：\n$$p_{\\mathrm{acc}}(\\boldsymbol{\\sigma} \\to \\boldsymbol{\\sigma}') = \\min(1, \\exp(-\\beta \\Delta U))$$\n这就是要使用的接受规则。如果能量变化 $\\Delta U$ 为负（新状态更稳定），则移动总是被接受（$p_{\\mathrm{acc}}=1$）。如果 $\\Delta U$ 为正，则移动以概率 $\\exp(-\\beta \\Delta U)$ 被接受，这使得系统能够逃离局部能量极小值。\n\n### 2. 能量变化 $\\Delta U$ 的分析\n\n一个构型 $\\boldsymbol{\\sigma}$ 的总能量由团簇展开给出：\n$$U(\\boldsymbol{\\sigma}) = \\sum_{\\alpha} J_{\\alpha} \\Phi_{\\alpha}(\\boldsymbol{\\sigma})$$\n其中 $\\alpha$ 表示一个格点团簇，$\\Phi_{\\alpha}(\\boldsymbol{\\sigma}) = \\prod_{i \\in \\alpha} \\sigma_i$。从 $\\boldsymbol{\\sigma}$ 转移到 $\\boldsymbol{\\sigma}'$ 时的能量变化是：\n$$\\Delta U = U(\\boldsymbol{\\sigma}') - U(\\boldsymbol{\\sigma}) = \\sum_{\\alpha} J_{\\alpha} (\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') - \\Phi_{\\alpha}(\\boldsymbol{\\sigma}))$$\n在格点 $i$ 和 $j$ 之间涉及不同种类原子（$\\sigma_i \\neq \\sigma_j$）的交换移动等价于翻转两个自旋：$\\sigma'_i = -\\sigma_i$ 和 $\\sigma'_j = -\\sigma_j$，而所有其他格点 $k \\neq i,j$ 的 $\\sigma'_k = \\sigma_k$。如果原子种类相同（$\\sigma_i = \\sigma_j$），交换不产生任何变化，$\\boldsymbol{\\sigma}' = \\boldsymbol{\\sigma}$，且 $\\Delta U = 0$。\n\n考虑非平凡交换（$\\sigma_i \\neq \\sigma_j$）的情况。基函数 $\\Phi_{\\alpha}(\\boldsymbol{\\sigma}')$ 的值与 $\\Phi_{\\alpha}(\\boldsymbol{\\sigma})$ 的关系如下：\n$$\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') = \\prod_{k \\in \\alpha} \\sigma'_k = \\left( \\prod_{k \\in \\alpha \\cap \\{i,j\\}} (-1) \\right) \\left( \\prod_{k \\in \\alpha} \\sigma_k \\right) = (-1)^{|\\alpha \\cap \\{i,j\\}|} \\Phi_{\\alpha}(\\boldsymbol{\\sigma})$$\n仅当 $\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') \\neq \\Phi_{\\alpha}(\\boldsymbol{\\sigma})$ 时，项 $\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') - \\Phi_{\\alpha}(\\boldsymbol{\\sigma})$ 才非零，这发生在指数 $|\\alpha \\cap \\{i,j\\}|$ 为奇数时。由于被翻转的格点集合是 $\\{i,j\\}$，这意味着只有当一个团簇 $\\alpha$ 精确包含这两个格点中的一个时，即 $|\\alpha \\cap \\{i,j\\}|=1$，它才会对 $\\Delta U$ 有贡献。对于这些团簇，$\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') = -\\Phi_{\\alpha}(\\boldsymbol{\\sigma})$，变化量为 $\\Phi_{\\alpha}(\\boldsymbol{\\sigma}') - \\Phi_{\\alpha}(\\boldsymbol{\\sigma}) = -2\\Phi_{\\alpha}(\\boldsymbol{\\sigma})$。对于所有其他团簇（既不包含 $i$ 也不包含 $j$，或同时包含 $i$ 和 $j$），变化量为零。\n\n因此，总能量变化可以写成仅对受交换影响的团簇求和：\n$$\\Delta U = \\sum_{\\alpha \\, : \\, i \\in \\alpha \\text{ or } j \\in \\alpha} J_{\\alpha} \\left( \\Phi_{\\alpha}(\\boldsymbol{\\sigma}') - \\Phi_{\\alpha}(\\boldsymbol{\\sigma}) \\right)$$\n根据问题陈述，此和定义了 $\\Delta U_{\\mathrm{local}}$。该表达式在数学上与全局能量变化 $\\Delta U_{\\mathrm{global}} = U(\\boldsymbol{\\sigma}') - U(\\boldsymbol{\\sigma})$ 完全相同，因为对于不包含 $i$ 或 $j$ 的团簇 $\\alpha$，所有项均为零。这个恒等式是具有局部势的 Monte Carlo 模拟效率高的根本原因：一次更新的计算成本与局部相互作用的团簇数量成正比，而不是与总系统大小成正比。\n\n### 3. 计算流程\n\n每个测试用例的算法如下：\n1.  **定义团簇**：对于大小为 $L=8$ 的晶格，生成完整的团簇集合。这包括 $L=8$ 个单点团簇 $\\{i\\}$，$L=8$ 个最近邻对团簇 $\\{i, (i+1) \\bmod 8\\}$，以及 $L=8$ 个最近邻三联体团簇 $\\{i, (i+1) \\bmod 8, (i+2) \\bmod 8\\}$。团簇总数为 $3L=24$。\n2.  **处理交换**：给定初始构型 $\\boldsymbol{\\sigma}$ 和交换格点 $(i,j)$，检查 $\\sigma_i = \\sigma_j$ 是否成立。\n    *   如果它们相同，则 $\\boldsymbol{\\sigma}' = \\boldsymbol{\\sigma}$，因此 $\\Delta U_{\\mathrm{global}} = \\Delta U_{\\mathrm{local}} = 0$，接受概率为 $p_{\\mathrm{acc}}=1$。\n    *   如果它们不同，通过设置 $\\sigma'_i = -\\sigma_i$ 和 $\\sigma'_j = -\\sigma_j$ 来构建新构型 $\\boldsymbol{\\sigma}'$。\n3.  **全局能量差**：通过遍历所有 $3L$ 个团簇，计算 $U(\\boldsymbol{\\sigma}) = \\sum_{\\alpha} J_{\\alpha} \\prod_{k \\in \\alpha} \\sigma_k$ 和 $U(\\boldsymbol{\\sigma}') = \\sum_{\\alpha} J_{\\alpha} \\prod_{k \\in \\alpha} \\sigma'_k$。计算 $\\Delta U_{\\mathrm{global}} = U(\\boldsymbol{\\sigma}') - U(\\boldsymbol{\\sigma})$。\n4.  **局部能量差**：\n    *   识别局部团簇集合 $\\mathcal{C}_{\\mathrm{local}} = \\{\\alpha \\mid i \\in \\alpha \\text{ or } j \\in \\alpha\\}$。\n    *   计算 $\\Delta U_{\\mathrm{local}} = \\sum_{\\alpha \\in \\mathcal{C}_{\\mathrm{local}}} J_{\\alpha} (\\prod_{k \\in \\alpha} \\sigma'_k - \\prod_{k \\in \\alpha} \\sigma_k)$。\n5.  **验证匹配**：对于一个小的数值容差 $\\epsilon$，确认 $|\\Delta U_{\\mathrm{global}} - \\Delta U_{\\mathrm{local}}|  \\epsilon$。结果为一个布尔值 `match`。\n6.  **接受概率**：使用给定的 $\\beta=40.0 \\, \\mathrm{eV}^{-1}$ 计算 $p_{\\mathrm{acc}} = \\min(1, \\exp(-\\beta \\Delta U_{\\mathrm{local}}))$。\n7.  **加速比**：计算比率 $r = (\\text{团簇总数}) / |\\mathcal{C}_{\\mathrm{local}}|$。分子是 $3L = 24$。分母是包含格点 $i$ 或 $j$ 的团簇数，这取决于 $i$ 和 $j$ 之间的距离。对于给定的格点 $k$，它属于 1 个点团簇、2 个对团簇和 3 个三联体团簇，总共 6 个团簇。对于格点 $i$ 和 $j$， $|\\mathcal{C}_{\\mathrm{local}}| = |\\mathcal{C}_i| + |\\mathcal{C}_j| - |\\mathcal{C}_i \\cap \\mathcal{C}_j| = 12 - |\\mathcal{C}_i \\cap \\mathcal{C}_j|$，其中交集项表示同时包含两个格点的团簇。\n8.  **汇总结果**：为每个用例格式化计算出的三元组 $[p_{\\mathrm{acc}}, \\text{match}, r]$，并将它们收集到一个最终列表中以供输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo swap move problem for the given test cases.\n    \"\"\"\n\n    def get_clusters(L):\n        \"\"\"Generates the single-site, pair, and triplet clusters for a 1D periodic lattice.\"\"\"\n        points = [[i] for i in range(L)]\n        pairs = [[i, (i + 1) % L] for i in range(L)]\n        triplets = [[i, (i + 1) % L, (i + 2) % L] for i in range(L)]\n        return points, pairs, triplets\n\n    def calculate_total_energy(sigma, clusters, J_coeffs):\n        \"\"\"Calculates the total energy of a configuration using the Cluster Expansion.\"\"\"\n        J1, J2, J3 = J_coeffs\n        points, pairs, triplets = clusters\n        energy = 0.0\n\n        # Single-site terms\n        for cluster in points:\n            phi = sigma[cluster[0]]\n            energy += J1 * phi\n\n        # Pair terms\n        for cluster in pairs:\n            phi = sigma[cluster[0]] * sigma[cluster[1]]\n            energy += J2 * phi\n\n        # Triplet terms\n        for cluster in triplets:\n            phi = sigma[cluster[0]] * sigma[cluster[1]] * sigma[cluster[2]]\n            energy += J3 * phi\n            \n        return energy\n\n    def process_case(L, J_coeffs, beta, sigma_initial, swap_sites):\n        \"\"\"\n        Processes a single test case: computes energy differences, acceptance probability,\n        and speed-up ratio for a given swap move.\n        \"\"\"\n        i, j = swap_sites\n        sigma_initial = np.array(sigma_initial)\n\n        if sigma_initial[i] == sigma_initial[j]:\n            sigma_final = sigma_initial.copy()\n            delta_U_global = 0.0\n            delta_U_local = 0.0\n        else:\n            sigma_final = sigma_initial.copy()\n            sigma_final[i] *= -1\n            sigma_final[j] *= -1\n\n            # Get all clusters\n            all_clusters_list = get_clusters(L)\n            \n            # Global energy difference calculation\n            U_initial = calculate_total_energy(sigma_initial, all_clusters_list, J_coeffs)\n            U_final = calculate_total_energy(sigma_final, all_clusters_list, J_coeffs)\n            delta_U_global = U_final - U_initial\n\n            # Local energy difference calculation\n            J1, J2, J3 = J_coeffs\n            delta_U_local = 0.0\n            \n            # Combine all clusters and J's for easier iteration\n            # This is not the most performant way but is clear and correct for the problem scale\n            all_clusters_tagged = []\n            for c in all_clusters_list[0]: all_clusters_tagged.append({'c': c, 'J': J1})\n            for c in all_clusters_list[1]: all_clusters_tagged.append({'c': c, 'J': J2})\n            for c in all_clusters_list[2]: all_clusters_tagged.append({'c': c, 'J': J3})\n\n            for item in all_clusters_tagged:\n                cluster = item['c']\n                J = item['J']\n                # Check if cluster is local to the swap\n                if i in cluster or j in cluster:\n                    phi_initial = np.prod(sigma_initial[cluster])\n                    phi_final = np.prod(sigma_final[cluster])\n                    delta_U_local += J * (phi_final - phi_initial)\n        \n        # Verify match between local and global calculations\n        match = np.isclose(delta_U_global, delta_U_local)\n\n        # Acceptance probability\n        delta_U = delta_U_local # or delta_U_global, they should be the same\n        p_acc = np.min([1.0, np.exp(-beta * delta_U)])\n        \n        # Speed-up ratio calculation\n        total_clusters_count = 3 * L\n        \n        local_clusters = set()\n        all_clusters_flat = get_clusters(L)[0] + get_clusters(L)[1] + get_clusters(L)[2]\n        for cluster in all_clusters_flat:\n            # Use frozenset to make lists hashable for set insertion\n            s_cluster = frozenset(cluster)\n            if i in s_cluster or j in s_cluster:\n                local_clusters.add(s_cluster)\n        \n        local_clusters_count = len(local_clusters)\n        speed_up_ratio = total_clusters_count / local_clusters_count if local_clusters_count > 0 else float('inf')\n\n        return [p_acc, bool(match), speed_up_ratio]\n\n    # Test suite parameters\n    L = 8\n    beta = 40.0\n    J_coeffs = (0.0, 0.2, -0.05)  # J1, J2, J3\n\n    test_cases = [\n        {\n            \"sigma\": [+1, -1, +1, -1, +1, -1, +1, -1],\n            \"swap\": (1, 2)\n        },\n        {\n            \"sigma\": [+1, -1, +1, -1, +1, -1, +1, -1],\n            \"swap\": (0, 2)\n        },\n        {\n            \"sigma\": [+1, +1, +1, -1, -1, -1, +1, +1],\n            \"swap\": (1, 4)\n        },\n        {\n            \"sigma\": [+1, -1, -1, +1, -1, +1, +1, -1],\n            \"swap\": (3, 4)\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(L, J_coeffs, beta, case[\"sigma\"], case[\"swap\"])\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    result_str = \"[\" + \",\".join([f\"[{p},{str(m).lower()},{r}]\" for p, m, r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3467414"}, {"introduction": "连续空间中的模拟带来了新的挑战，尤其是在处理扩展的刚体和周期性边界条件（PBC）时。像旋转这样的移动可能导致分子跨越模拟盒的边界，这使得取向依赖性质的计算变得复杂。这最后一个实践 [@problem_id:3467366] 解决了这个关键的实现细节，指导你正确应用最小镜像约定，并展示一个看似直观但“朴素”的方法如何导致物理上不正确的结果。", "problem": "你需要实现一个自包含的程序，该程序在三维周期性模拟盒子中为刚体执行蒙特卡洛 (MC) 移动提议，同时注意考虑最小镜像的旋转和绕回，并量化周期性如何改变与取向相关的能量和接受概率。该系统由一个或多个刚性二聚体（双位点刚体）组成，在边长为 $L$ 的立方体盒子中受到周期性边界条件 (PBC) 的约束。移动集包括平移、旋转和物种交换移动。能量与取向相关，并与一个空间周期性的外场线性耦合，这使得最小镜像约定在边界附近至关重要。\n\n此问题的基础始于正则系综。在正则系综中，能量为 $E$ 的微观态其概率密度与 $\\exp(-\\beta E)$ 成正比，其中 $\\beta$ 是逆热能 $1/(k_{\\mathrm{B}} T)$。对于一个将能量从 $E_{\\mathrm{old}}$ 变为 $E_{\\mathrm{new}}$ 的提议移动，其 Metropolis 接受准则为 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new}} - E_{\\mathrm{old}})) \\}$。对于刚体旋转，体坐标系中的位移通过一个由轴-角参数化导出的特殊正交矩阵进行旋转，然后使用 PBC 将位置绕回到盒子中。在 PBC 下，使用最小镜像约定来计算取向矢量：对于位移 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$，最小镜像位移是 $\\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\,\\mathrm{round}(\\Delta \\mathbf{r} / L)$，逐分量计算，取向矢量为 $\\mathbf{n} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。对位置进行绕回操作为 $\\mathbf{r} \\mapsto \\mathbf{r} \\bmod L$，逐分量应用。\n\n定义单个二聚体的能量为 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$，其中 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 是位点位置，$\\varepsilon$ 是物种耦合强度，$\\mathbf{n}$ 是使用最小镜像约定计算的二聚体取向，$\\hat{\\mathbf{e}}(\\mathbf{r})$ 是一个空间周期性外场的单位矢量，该外场由 $\\mathbf{e}(\\mathbf{r}) = [\\cos(2 \\pi x / L), \\cos(2 \\pi y / L), \\cos(2 \\pi z / L)]$ 定义，且 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{e}(\\mathbf{r}) / \\|\\mathbf{e}(\\mathbf{r})\\|$（如果 $\\|\\mathbf{e}(\\mathbf{r})\\| \\neq 0$），否则 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{0}$。该能量打破了头尾对称性（关于 $\\mathbf{n}$ 是线性的），使得在边界附近正确计算取向至关重要。对于多二聚体系统，总能量是所有二聚体能量的总和。对于物种交换移动，位置保持固定，而两个二聚体之间的物种耦合参数 $\\varepsilon$ 被交换。\n\n实现两种能量和接受概率的评估：一种是使用最小镜像取向的正确方法，另一种是错误地直接使用绕回后位置差值的朴素方法，即 $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$，并进行归一化。计算 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}} = \\min \\{ 1, \\exp(-\\beta (E_{\\mathrm{new,naive}} - E_{\\mathrm{old,naive}})) \\}$，以展示周期性如何影响与取向相关的能量和接受概率。\n\n角度单位必须是弧度。所有能量都是无量纲的，并以任意一致的单位进行度量。程序必须实现：\n- 平移动作：对选定二聚体的两个位点 $i=1,2$，执行 $\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\Delta \\mathbf{t}$，然后进行绕回。\n- 旋转动作：计算二聚体中心 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\tfrac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$，计算体坐标系位移 $\\mathbf{d}_1 = -\\tfrac{1}{2} \\mathbf{n} a$ 和 $\\mathbf{d}_2 = +\\tfrac{1}{2} \\mathbf{n} a$，其中 $a = \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$ 是键长，通过轴-角旋转矩阵旋转 $\\mathbf{d}_1, \\mathbf{d}_2$，将位点放置在 $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_1^{\\prime}$ 和 $\\mathbf{r}_{\\mathrm{c}} + \\mathbf{d}_2^{\\prime}$，然后进行绕回。\n- 交换动作：交换两个二聚体之间的 $\\varepsilon$ 值，而不改变位置。\n\n测试套件和最终输出规范：\n实现以下四个测试用例。对每个用例，计算并返回一个包含 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}}$（作为浮点数）的列表。\n\n1. 边界附近的旋转（边界敏感情况）：一个二聚体在盒子中，其中 $L = 10.0$，键长 $a = 4.0$，逆温度 $\\beta = 2.0$，物种耦合 $\\varepsilon = 1.0$，初始中心位于 $(9.2, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（因此位点位置为 $(7.2, 5.0, 5.0)$ 和 $(11.2, 5.0, 5.0)$，后者绕回为 $(1.2, 5.0, 5.0)$），提议的旋转是绕轴 $(0, 0, 1)$ 旋转 $0.9$ 弧度。\n\n2. 远离边界的旋转（理想情况）：一个二聚体，其中 $L = 10.0$, $a = 4.0$, $\\beta = 2.0$, $\\varepsilon = 1.0$，初始中心位于 $(5.0, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(3.0, 5.0, 5.0)$ 和 $(7.0, 5.0, 5.0)$），提议的旋转是绕轴 $(0, 0, 1)$ 旋转 $0.9$ 弧度。\n\n3. 边界附近的平移（绕回引起的取向模糊性）：一个二聚体，其中 $L = 10.0$, $a = 4.0$, $\\beta = 2.0$, $\\varepsilon = 1.0$，初始中心位于 $(9.8, 5.0, 5.0)$，初始取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(7.8, 5.0, 5.0)$ 和 $(11.8, 5.0, 5.0)$，后者绕回为 $(1.8, 5.0, 5.0)$），提议的平移矢量为 $(0.6, 0.0, 0.0)$。\n\n4. 物种交换（涉及两个二聚体的交换移动，其中一个靠近边界）：两个二聚体在盒子中，其中 $L = 10.0$, $a = 4.0$, $\\beta = 1.5$，初始物种耦合为 $\\varepsilon_{\\mathrm{A}} = 1.2$ 和 $\\varepsilon_{\\mathrm{B}} = 0.6$。二聚体 A：中心位于 $(9.2, 5.0, 5.0)$，取向沿 $+\\hat{\\mathbf{x}}$ 方向（位点为 $(7.2, 5.0, 5.0)$ 和 $(11.2, 5.0, 5.0)$，后者绕回为 $(1.2, 5.0, 5.0)$）。二聚体 B：中心位于 $(2.0, 5.0, 5.0)$，取向沿 $+\\hat{\\mathbf{y}}$ 方向（位点为 $(2.0, 3.0, 5.0)$ 和 $(2.0, 7.0, 5.0)$）。提议的移动交换两个二聚体之间的物种耦合。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表的每个元素对应一个测试用例，并且本身必须是包含 $p_{\\mathrm{acc}}^{\\mathrm{correct}}$ 和 $p_{\\mathrm{acc}}^{\\mathrm{naive}}$ 的二元列表。例如，最终格式必须完全像这样：[[p1_correct,p1_naive],[p2_correct,p2_naive],[p3_correct,p3_naive],[p4_correct,p4_naive]]。", "solution": "用户提供了一个计算材料科学领域的问题，具体聚焦于周期性边界条件 (PBC) 下刚体的蒙特卡洛 (MC) 移动集的实现和验证。\n\n### 问题验证\n\n**步骤 1: 提取已知条件**\n\n- **系综和接受准则**: 正则系综，概率密度 $p(E) \\propto \\exp(-\\beta E)$，Metropolis 接受概率 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta \\Delta E) \\}$。\n- **系统**: 在边长为 $L$ 的三维立方体盒子中的刚性二聚体。\n- **PBC 和 MIC**: 位置绕回是 $\\mathbf{r} \\mapsto \\mathbf{r} \\bmod L$。最小镜像位移是 $\\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\,\\mathrm{round}(\\Delta \\mathbf{r} / L)$，其中位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$。\n- **取向矢量**:\n    - 正确方法: $\\mathbf{n}_{\\mathrm{correct}} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。\n    - 朴素方法: $\\mathbf{n}_{\\mathrm{naive}} = \\Delta \\mathbf{r}_{\\mathrm{naive}} / \\|\\Delta \\mathbf{r}_{\\mathrm{naive}}|$, 其中 $\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$。\n- **能量函数**: 二聚体的能量为 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$，其中 $\\mathbf{r}_i$ 是位点位置（在绕回后评估），$\\varepsilon$ 是特定物种的耦合强度，$\\hat{\\mathbf{e}}(\\mathbf{r})$ 是一个周期性外场。\n- **外场**: $\\mathbf{e}(\\mathbf{r}) = [\\cos(2 \\pi x / L), \\cos(2 \\pi y / L), \\cos(2 \\pi z / L)]$，其单位矢量为 $\\hat{\\mathbf{e}}(\\mathbf{r}) = \\mathbf{e}(\\mathbf{r}) / \\|\\mathbf{e}(\\mathbf{r})\\|$（如果范数不为零，则为 $\\mathbf{0}$）。\n- **MC 移动**:\n    - 平移: 对 $i=1,2$，$\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\Delta \\mathbf{t}$，然后绕回。\n    - 旋转: 刚性二聚体围绕其中心 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\tfrac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$ 进行旋转。\n    - 交换: 交换两个二聚体之间的 $\\varepsilon$ 值。\n- **测试用例**: 提供了四个具体场景，测试旋转（靠近和远离边界）、平移和物种交换，并明确定义了所有必要参数（$L$, $a$, $\\beta$, $\\varepsilon$, 初始位置、取向和移动参数）。\n\n**步骤 2: 使用提取的已知条件进行验证**\n\n- **具有科学依据**: 该问题基于统计力学和计算物理的既定原理。MC 方法、PBC、MIC 和刚体动力学都是标准且被正确描述的概念。\n- **适定的**: 提供了所有定义、参数和初始条件，使得问题明确且可解。“正确”和“朴素”方法之间的区别是模拟实践中一个定义明确且重要的概念。\n- **客观的**: 问题以精确、定量的术语陈述，没有任何主观性。\n\n**步骤 3: 结论和行动**\n\n该问题在科学上是合理的、适定的和客观的。它包含了唯一解所需的所有信息。因此，该问题是**有效的**。将开发一个完整的解决方案。\n\n### 求解设计和原理\n\n解决方案涉及实现一个模拟框架，以计算三种蒙特卡洛移动的能量变化，从而确定接受概率。问题的核心在于周期性边界条件 (PBC) 下粒子坐标和相互作用的正确处理。\n\n**1. 周期性边界条件和最小镜像约定 (MIC)**\n\n在边长为 $L$ 的模拟盒子中，PBC 意味着系统在所有方向上无限复制。当一个粒子从一个面穿出盒子时，它会从对面重新进入。这通过绕回坐标来处理，即 $\\mathbf{r}_{\\text{wrapped}} = \\mathbf{r} \\bmod L$。\n\n在计算两个粒子之间的相互作用时，我们必须考虑它们最近的周期性镜像之间的相互作用。这是通过最小镜像约定 (MIC) 实现的。位于（未绕回）位置 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 的粒子之间的位移矢量首先计算为 $\\Delta \\mathbf{r} = \\mathbf{r}_2 - \\mathbf{r}_1$。然后通过确保矢量的每个分量在量级上都小于 $L/2$ 来找到 MIC 位移：\n$$ \\Delta \\mathbf{r}_{\\mathrm{MI}} = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r} / L) $$\n此计算正确地找到了连接粒子（或其镜像）穿过周期性边界的最短矢量。可能跨越边界的刚体（如二聚体）的取向必须使用 $\\Delta \\mathbf{r}_{\\mathrm{MI}}$ 来计算。\n\n**2. 朴素方法 vs. 正确方法**\n\n问题关键地指出了一个常见的实现错误。\n- **正确取向**: 取向矢量 $\\mathbf{n}$ 源自 MIC 位移：$\\mathbf{n}_{\\mathrm{correct}} = \\Delta \\mathbf{r}_{\\mathrm{MI}} / \\|\\Delta \\mathbf{r}_{\\mathrm{MI}}\\|$。这反映了刚性键的真实物理取向。\n- **朴素取向**: 朴素的方法可能只是简单地取绕回后粒子位置的差值：$\\Delta \\mathbf{r}_{\\mathrm{naive}} = (\\mathbf{r}_2 \\bmod L) - (\\mathbf{r}_1 \\bmod L)$。如果二聚体跨越边界，这个矢量将不代表短键，而是代表一个穿过模拟盒子的长矢量。这导致物理上不正确的取向矢量 $\\mathbf{n}_{\\mathrm{naive}}$，从而导致错误的能量计算。\n\n**3. 能量计算**\n\n二聚体的能量由 $E = - \\varepsilon \\sum_{i=1}^{2} \\mathbf{n} \\cdot \\hat{\\mathbf{e}}(\\mathbf{r}_i)$ 给出。计算过程如下：\n- 使用正确或朴素方法计算取向矢量 $\\mathbf{n}$。\n- 在两个位点的*绕回后*位置 $\\mathbf{r}_1^{\\mathrm{w}}$ 和 $\\mathbf{r}_2^{\\mathrm{w}}$ 处评估外场 $\\hat{\\mathbf{e}}(\\mathbf{r})$，因为场本身是周期性的。\n- 计算点积并求和，然后乘以 $-\\varepsilon$。\n\n**4. 蒙特卡洛移动**\n\n为了保持物理一致性，所有移动（平移和旋转）都应用于“未绕回”的粒子坐标。移动后，使用新位置计算能量，并确定接受概率。对于此问题，我们将维护每个二聚体的未绕回坐标。\n\n- **平移**: 二聚体的两个位点都通过一个矢量 $\\Delta \\mathbf{t}$ 进行位移：$\\mathbf{r}_i' = \\mathbf{r}_i + \\Delta \\mathbf{t}$。取向矢量 $\\mathbf{n}$ 保持不变，但能量会改变，因为位点在外场中处于新位置。\n\n- **旋转**: 围绕二聚体的质心进行旋转。为了正确处理跨边界的二聚体，此中心定义为 $\\mathbf{r}_{\\mathrm{c}} = \\mathbf{r}_1 + \\frac{1}{2} \\Delta \\mathbf{r}_{\\mathrm{MI}}$，使用一个位点的未绕回位置和 MIC 位移。从中心到每个位点的体坐标系矢量 $\\mathbf{d}_i$ 通过一个旋转矩阵 $\\mathbf{R}$ 进行旋转。新的未绕回位置为 $\\mathbf{r}_i' = \\mathbf{r}_{\\mathrm{c}} + \\mathbf{R} \\mathbf{d}_i$。\n\n- **交换移动**: 位置保持固定，但两个二聚体的物种参数 $\\varepsilon$ 被交换。如果它们的取向和位置导致与场的相互作用能量不同，这将改变两个二聚体的能量。\n\n**5. 接受概率**\n\n对于任何提议的移动，计算能量变化 $\\Delta E = E_{\\mathrm{new}} - E_{\\mathrm{old}}$。该移动以概率 $p_{\\mathrm{acc}} = \\min \\{ 1, \\exp(-\\beta \\Delta E) \\}$ 被接受。对正确和朴素的能量模型分别进行此计算，以展示差异。\n\n实现将遵循这些原则，并使用辅助函数进行绕回、MIC、场计算和能量评估，以确保清晰且正确的程序结构。将按顺序处理测试用例以生成最终所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo move set problem for all test cases.\n    \"\"\"\n\n    def wrap_positions(positions, box_length):\n        \"\"\"Wraps a single or multiple position vectors into the periodic box.\"\"\"\n        return positions % box_length\n\n    def minimum_image_displacement(r1, r2, box_length):\n        \"\"\"Computes the minimum image displacement vector from r1 to r2.\"\"\"\n        # Assumes r1 and r2 are unwrapped coordinates\n        delta_r = r2 - r1\n        return delta_r - box_length * np.around(delta_r / box_length)\n\n    def field_vector(r_wrapped, box_length):\n        \"\"\"Computes the unit vector of the external field at a wrapped position.\"\"\"\n        if box_length == 0: return np.zeros(3)\n        e = np.cos(2 * np.pi * r_wrapped / box_length)\n        norm_e = np.linalg.norm(e)\n        if norm_e == 0:\n            return np.zeros(3)\n        return e / norm_e\n\n    def calculate_dimer_energy(r1, r2, eps, box_length, method):\n        \"\"\"\n        Calculates the energy of a single dimer.\n        r1, r2 are unwrapped positions.\n        method can be 'correct' or 'naive'.\n        \"\"\"\n        r1_w = wrap_positions(r1, box_length)\n        r2_w = wrap_positions(r2, box_length)\n\n        if method == 'correct':\n            delta_r_mic = minimum_image_displacement(r1, r2, box_length)\n            norm_delta_r = np.linalg.norm(delta_r_mic)\n            n_hat = delta_r_mic / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        elif method == 'naive':\n            delta_r_naive = r2_w - r1_w\n            norm_delta_r = np.linalg.norm(delta_r_naive)\n            n_hat = delta_r_naive / norm_delta_r if norm_delta_r > 0 else np.zeros(3)\n        else:\n            raise ValueError(\"Method must be 'correct' or 'naive'\")\n\n        e_field1 = field_vector(r1_w, box_length)\n        e_field2 = field_vector(r2_w, box_length)\n        \n        energy = -eps * (np.dot(n_hat, e_field1) + np.dot(n_hat, e_field2))\n        return energy\n        \n    def calculate_total_energy(dimers, box_length, method):\n        \"\"\"Calculates total energy for a list of dimers.\"\"\"\n        total_e = 0.0\n        for dimer in dimers:\n            r1, r2, eps = dimer\n            total_e += calculate_dimer_energy(r1, r2, eps, box_length, method)\n        return total_e\n\n    def get_acc_prob(delta_e, beta):\n        \"\"\"Computes Metropolis acceptance probability.\"\"\"\n        if delta_e = 0:\n            return 1.0\n        return np.exp(-beta * delta_e)\n\n    # --- Test Cases ---\n\n    results = []\n\n    # Case 1: Rotation near boundary\n    def run_case_1():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([9.2, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Rotation move\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot_vec = rot_axis * rot_angle\n        rot = Rotation.from_rotvec(rot_vec)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n        \n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_1())\n\n    # Case 2: Rotation away from boundary\n    def run_case_2():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([5.0, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        rot_axis = np.array([0.0, 0.0, 1.0])\n        rot_angle = 0.9\n        rot = Rotation.from_rotvec(rot_axis * rot_angle)\n        \n        delta_r_mic = minimum_image_displacement(r1_old, r2_old, L)\n        r_c = r1_old + 0.5 * delta_r_mic\n        d1 = r1_old - r_c\n        d2 = r2_old - r_c\n        \n        r1_new = r_c + rot.apply(d1)\n        r2_new = r_c + rot.apply(d2)\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n\n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_2())\n\n    # Case 3: Translation near boundary\n    def run_case_3():\n        L, a, beta, eps = 10.0, 4.0, 2.0, 1.0\n        r_c_init = np.array([9.8, 5.0, 5.0])\n        n_init = np.array([1.0, 0.0, 0.0])\n        r1_old = r_c_init - n_init * a / 2.0\n        r2_old = r_c_init + n_init * a / 2.0\n\n        dimers_old = [(r1_old, r2_old, eps)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n        \n        # Translation move\n        trans_vec = np.array([0.6, 0.0, 0.0])\n        r1_new = r1_old + trans_vec\n        r2_new = r2_old + trans_vec\n\n        dimers_new = [(r1_new, r2_new, eps)]\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n        \n        return [p_acc_correct, p_acc_naive]\n\n    results.append(run_case_3())\n\n    # Case 4: Species swap\n    def run_case_4():\n        L, a, beta = 10.0, 4.0, 1.5\n        eps_A, eps_B = 1.2, 0.6\n        \n        # Dimer A\n        r_c_A = np.array([9.2, 5.0, 5.0])\n        n_A = np.array([1.0, 0.0, 0.0])\n        r1_A = r_c_A - n_A * a / 2.0\n        r2_A = r_c_A + n_A * a / 2.0\n        \n        # Dimer B\n        r_c_B = np.array([2.0, 5.0, 5.0])\n        n_B = np.array([0.0, 1.0, 0.0])\n        r1_B = r_c_B - n_B * a / 2.0\n        r2_B = r_c_B + n_B * a / 2.0\n\n        dimers_old = [(r1_A, r2_A, eps_A), (r1_B, r2_B, eps_B)]\n        e_old_correct = calculate_total_energy(dimers_old, L, 'correct')\n        e_old_naive = calculate_total_energy(dimers_old, L, 'naive')\n\n        # Swap move\n        dimers_new = [(r1_A, r2_A, eps_B), (r1_B, r2_B, eps_A)] # eps swapped\n        e_new_correct = calculate_total_energy(dimers_new, L, 'correct')\n        e_new_naive = calculate_total_energy(dimers_new, L, 'naive')\n        \n        p_acc_correct = get_acc_prob(e_new_correct - e_old_correct, beta)\n        p_acc_naive = get_acc_prob(e_new_naive - e_old_naive, beta)\n\n        return [p_acc_correct, p_acc_naive]\n        \n    results.append(run_case_4())\n    \n    # Format the final output string\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "3467366"}]}