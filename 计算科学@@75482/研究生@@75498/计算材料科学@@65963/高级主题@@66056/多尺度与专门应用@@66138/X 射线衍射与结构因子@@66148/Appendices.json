{"hands_on_practices": [{"introduction": "要理解衍射实验，第一步是确定衍射峰可能出现的位置。这由晶格的几何结构决定，并在倒易空间中进行描述。本练习将提供实践机会，练习从实空间晶格计算倒易晶格矢量，并利用劳厄条件来确定在给定实验装置下所有可能的衍射点 [@problem_id:3504299]。", "problem": "给定一个实空间中的三斜布拉菲晶格，由三个线性无关的基矢 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 指定，其分量以埃（angstrom）为单位。倒易晶格由倒易基矢 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 定义，满足 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克δ函数，$\\cdot$ 表示欧几里得点积。实空间晶胞体积为 $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$，其中 $\\times$ 表示欧几里得叉积。倒易空间晶胞体积是由 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 张成的平行六面体的有向体积。对于X射线衍射（XRD），衍射条件（劳厄条件）指出，存在一个散射波矢 $\\mathbf{k}_{\\mathrm{out}}$，满足 $|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$，使得 $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$，其中 $\\mathbf{G}$ 是一个倒易晶格矢量。入射波矢的模为 $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi / \\lambda$，其中 $\\lambda$ 是以埃为单位指定的X射线波长，入射方向以单位矢量的形式给出。\n\n从这些定义和物理事实出发，实现一个程序，该程序：\n- 根据 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 计算倒易基矢 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$。\n- 计算倒易晶胞体积，单位为 $\\mathrm{\\AA}^{-3}$（立方埃的倒数），与上述定义一致。\n- 枚举所有非零的倒易晶格矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$，其米勒指数 $(h,k,\\ell)$ 为整数，且同时满足 $|\\mathbf{G}| \\le Q_{\\max}$ 和给定入射束的衍射条件（劳厄条件）。衍射条件通过对由 $|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|$ 隐含的标量方程使用容差 $\\varepsilon$ 进行数值检验。排除平凡情况 $\\mathbf{G} = \\mathbf{0}$。将所有 $\\mathbf{b}_i$ 的矢量分量以 $\\mathrm{\\AA}^{-1}$ 表示，倒易晶胞体积以 $\\mathrm{\\AA}^{-3}$ 表示。在衍射条件的相等性检查中，使用指定的容差 $\\varepsilon$ 作为无量纲界限。\n\n你不能假设任何超出给定定义和上述基本事实的预先推导出的快捷公式。你的推导和实现必须仅依赖于这些基本要素。\n\n对于数值输出：\n- 将所有浮点输出（倒易基矢分量和倒易晶胞体积）四舍五入到六位小数。\n- 角度不直接使用；方向以单位矢量给出，因此不需要指定角度单位。\n- 最终输出必须是单行文本，包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[\\text{b\\_flat\\_list}, \\text{reciprocal\\_volume}, \\text{hkls\\_list}]$ 形式的列表，其中 $\\text{b\\_flat\\_list}$ 是分量的展开列表 $[b_{1x}, b_{1y}, b_{1z}, b_{2x}, b_{2y}, b_{2z}, b_{3x}, b_{3y}, b_{3z}]$（全部以 $\\mathrm{\\AA}^{-1}$ 为单位），$\\text{reciprocal\\_volume}$ 是一个以 $\\mathrm{\\AA}^{-3}$ 为单位的浮点数，$\\text{hkls\\_list}$ 是一个满足条件的整数三元组 $[h,k,\\ell]$ 的列表。\n\n使用以下测试套件。每个案例由 $(\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3, \\lambda, \\hat{\\mathbf{k}}_{\\mathrm{in}}, Q_{\\max}, \\varepsilon)$ 定义：\n1. 一般三斜晶系情况（正常路径）：\n   - $\\mathbf{a}_1 = (\\,4.0,\\,0.2,\\,0.1\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.1,\\,5.0,\\,0.4\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.2,\\,0.3,\\,6.1\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 1.0\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.0,\\,0.0,\\,1.0\\,)$。\n   - $Q_{\\max} = 4.0\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$。\n2. 斜入射及典型波长：\n   - $\\mathbf{a}_1 = (\\,3.5,\\,0.0,\\,0.0\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.2,\\,4.7,\\,0.1\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.1,\\,0.4,\\,5.5\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 1.5406\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.3,\\,0.4,\\,0.866025403784\\,)$。\n   - $Q_{\\max} = 3.0\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$。\n3. 边界情况， $Q_{\\max}$ 较小：\n   - $\\mathbf{a}_1 = (\\,5.2,\\,0.1,\\,0.0\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.0,\\,5.3,\\,0.2\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.1,\\,0.0,\\,5.4\\,)\\,\\mathrm{\\AA}$。\n   - $\\lambda = 0.5\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,1.0,\\,0.0,\\,0.0\\,)$。\n   - $Q_{\\max} = 0.8\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素对应一个如上所述结构的测试用例结果。例如，输出格式必须严格为 $[\\text{case1},\\text{case2},\\text{case3}]$，不含任何多余文本，并使用指定的单位和四舍五入规则。", "solution": "根据指定标准，用户提供的问题被评估为有效。它在科学上基于固态物理学和X射线衍射的原理，问题提法得当，具有完整且一致的给定条件，并且表述客观。问题要求在不依赖预先推导的快捷公式的情况下实现基本定义，构成了一项实质性的计算任务。\n\n解决方案分三个主要阶段进行开发：\n1.  计算倒易基矢和倒易晶胞体积。\n2.  推导用于识别衍射倒易晶格矢量的条件。\n3.  建立枚举这些矢量的算法。\n\n### 1. 倒易基矢和体积的计算\n\n问题将实空间基矢定义为 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$，倒易基矢定义为 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$，它们之间的关系为：\n$$\n\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数。实空间晶胞体积由标量三重积 $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$ 给出。\n\n为了找到 $\\mathbf{b}_1$ 的表达式，我们使用其定义。条件 $\\mathbf{a}_2 \\cdot \\mathbf{b}_1 = 0$ 和 $\\mathbf{a}_3 \\cdot \\mathbf{b}_1 = 0$ 意味着 $\\mathbf{b}_1$ 必须同时与 $\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 正交。因此，$\\mathbf{b}_1$ 必须平行于叉积 $\\mathbf{a}_2 \\times \\mathbf{a}_3$。我们可以写成：\n$$\n\\mathbf{b}_1 = C (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\n其中 $C$ 是某个标量常数。为了求出 $C$，我们使用剩下的条件 $\\mathbf{a}_1 \\cdot \\mathbf{b}_1 = 2\\pi$：\n$$\n\\mathbf{a}_1 \\cdot [C (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\n$$\nC [\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\n使用实空间体积 $V$ 的定义，我们得到 $C V = 2\\pi$，即 $C = 2\\pi/V$。因此，$\\mathbf{b}_1$ 的表达式为：\n$$\n\\mathbf{b}_1 = \\frac{2\\pi}{V} (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\n通过对指标进行循环置换，我们得到 $\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 的表达式：\n$$\n\\mathbf{b}_2 = \\frac{2\\pi}{V} (\\mathbf{a}_3 \\times \\mathbf{a}_1)\n$$\n$$\n\\mathbf{b}_3 = \\frac{2\\pi}{V} (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n\n倒易晶胞体积被定义为由倒易基矢张成的平行六面体的有向体积，由它们的标量三重积给出：\n$$\nV_{\\text{recip}} = \\mathbf{b}_1 \\cdot (\\mathbf{b}_2 \\times \\mathbf{b}_3)\n$$\n我们不会使用常见的快捷方式，即推导出的关系式 $V_{\\text{recip}} = (2\\pi)^3/V$，而是将直接根据计算出的 $\\mathbf{b}_i$ 矢量计算此值，以严格遵守问题的约束。\n\n### 2. 衍射条件\n\n一个倒易晶格矢量由 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$ 给出，其中 $(h,k,\\ell)$ 为整数米勒指数。我们需要找到所有满足两个条件的非零矢量 $\\mathbf{G}$。\n\n**条件1：模长约束**\n倒易晶格矢量的模长必须小于或等于给定的最大值 $Q_{\\max}$：\n$$\n|\\mathbf{G}| \\le Q_{\\max}\n$$\n等价地， $|\\mathbf{G}|^2 \\le Q_{\\max}^2$。\n\n**条件2：劳厄条件**\n衍射（劳厄）条件是 $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$，其中 $\\mathbf{k}_{\\mathrm{in}}$ 是入射波矢，$\\mathbf{k}_{\\mathrm{out}}$ 是散射波矢。对于弹性散射，如X射线衍射，有 $|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$。将 $\\mathbf{k}_{\\mathrm{out}} = \\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}$ 代入弹性散射条件，得到：\n$$\n|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|\n$$\n两边平方得到：\n$$\n(\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) \\cdot (\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) = \\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{k}_{\\mathrm{in}}\n$$\n$$\n|\\mathbf{k}_{\\mathrm{in}}|^2 + 2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = |\\mathbf{k}_{\\mathrm{in}}|^2\n$$\n这化简为衍射矢量 $\\mathbf{G}$ 必须满足的最终方程：\n$$\n2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = 0\n$$\n问题要求使用一个无量纲容差 $\\varepsilon$ 对此条件进行数值检验。通过除以 $|\\mathbf{k}_{\\mathrm{in}}|^2$ 可以获得一个代表与此条件偏差的合适的无量纲量：\n$$\n\\left| \\frac{2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2}{|\\mathbf{k}_{\\mathrm{in}}|^2} \\right| \\le \\varepsilon\n$$\n入射波矢由其模长 $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi/\\lambda$ 和给定的方向单位矢量 $\\hat{\\mathbf{k}}_{\\mathrm{in}}$ 构成：$\\mathbf{k}_{\\mathrm{in}} = (2\\pi/\\lambda)\\hat{\\mathbf{k}}_{\\mathrm{in}}$。\n\n### 3. 枚举算法\n\n为了找到所有满足条件的整数三元组 $(h,k,\\ell)$，我们必须搜索整数格矢的一个有限区域。条件 $|\\mathbf{G}| \\le Q_{\\max}$ 在 $(h,k,\\ell)$ 空间中定义了一个椭球。为了建立一个简单的搜索边界，我们可以找到一个包围该椭球的长方体。\n\n矢量 $\\mathbf{G}$ 可以写成矩阵形式 $\\mathbf{G} = B \\mathbf{m}$，其中 $B$ 是列为 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$ 的矩阵，$\\mathbf{m} = [h, k, \\ell]^T$。因此，$\\mathbf{m} = B^{-1} \\mathbf{G}$。\n设实空间基矢矩阵的行是 $A_{mat} = [\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]^T$。定义 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$ 意味着 $A_{mat} B = 2\\pi I$，所以 $B^{-1} = \\frac{1}{2\\pi} A_{mat}$。$B^{-1}$ 的行是 $\\frac{1}{2\\pi}\\mathbf{a}_1$、$\\frac{1}{2\\pi}\\mathbf{a}_2$ 和 $\\frac{1}{2\\pi}\\mathbf{a}_3$。\n\n$\\mathbf{m}$ 的分量可以被界定。例如，对于 $h$：\n$$\nh = (\\frac{1}{2\\pi}\\mathbf{a}_1) \\cdot \\mathbf{G}\n$$\n根据柯西-施瓦茨不等式， $|h| \\le \\frac{1}{2\\pi}|\\mathbf{a}_1| |\\mathbf{G}|$。因为 $|\\mathbf{G}| \\le Q_{\\max}$，我们有：\n$$\n|h| \\le \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi}\n$$\n这给出了 $h$ 的最大搜索范围，同样地也适用于 $k$ 和 $\\ell$：\n$$\nh_{\\max} = \\lceil \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi} \\rceil, \\quad k_{\\max} = \\lceil \\frac{|\\mathbf{a}_2| Q_{\\max}}{2\\pi} \\rceil, \\quad \\ell_{\\max} = \\lceil \\frac{|\\mathbf{a}_3| Q_{\\max}}{2\\pi} \\rceil\n$$\n其中 $\\lceil \\cdot \\rceil$ 是上取整函数。算法将遍历这些范围内的所有整数 $h, k, \\ell$（从 $-h_{\\max}$ 到 $h_{\\max}$ 等），构建相应的 $\\mathbf{G}$，并根据两个条件进行测试。得到的 $(h,k,\\ell)$ 三元组列表将按字典序排序，以获得确定性输出。\n\n每个测试用例的最终结果需要特定格式：倒易基矢的分量和倒易体积必须四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General triclinic\n        (np.array([4.0, 0.2, 0.1]), np.array([0.1, 5.0, 0.4]), np.array([0.2, 0.3, 6.1]),\n         1.0, np.array([0.0, 0.0, 1.0]), 4.0, 1e-6),\n        # Case 2: Oblique incidence\n        (np.array([3.5, 0.0, 0.0]), np.array([0.2, 4.7, 0.1]), np.array([0.1, 0.4, 5.5]),\n         1.5406, np.array([0.3, 0.4, 0.866025403784]), 3.0, 1e-6),\n        # Case 3: Boundary case\n        (np.array([5.2, 0.1, 0.0]), np.array([0.0, 5.3, 0.2]), np.array([0.1, 0.0, 5.4]),\n         0.5, np.array([1.0, 0.0, 0.0]), 0.8, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # The problem asks for the standard python string representation of lists\n    # which includes spaces after commas. The f-string joins these string\n    # representations with a comma but doesn't alter the inner representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_case(a1, a2, a3, lambda_xray, k_in_hat, Q_max, epsilon):\n    \"\"\"\n    Processes a single test case for X-ray diffraction analysis.\n    \n    Args:\n        a1, a2, a3 (np.ndarray): Real-space basis vectors in Angstroms.\n        lambda_xray (float): Wavelength of the X-ray in Angstroms.\n        k_in_hat (np.ndarray): Unit vector of the incident wavevector.\n        Q_max (float): Maximum magnitude of reciprocal lattice vectors to consider.\n        epsilon (float): Tolerance for the diffraction condition check.\n\n    Returns:\n        list: A list containing [b_flat_list, reciprocal_volume, hkls_list].\n    \"\"\"\n    \n    # 1. Compute real-space volume\n    # V = a1 . (a2 x a3)\n    V_real = np.dot(a1, np.cross(a2, a3))\n    \n    # 2. Compute reciprocal basis vectors\n    factor = 2 * np.pi / V_real\n    b1 = factor * np.cross(a2, a3)\n    b2 = factor * np.cross(a3, a1)\n    b3 = factor * np.cross(a1, a2)\n    \n    # 3. Compute reciprocal cell volume\n    # V_recip = b1 . (b2 x b3)\n    V_recip = np.dot(b1, np.cross(b2, b3))\n    \n    # 4. Enumerate reciprocal lattice vectors G = h*b1 + k*b2 + l*b3\n    k_in_mag = 2 * np.pi / lambda_xray\n    k_in = k_in_mag * k_in_hat\n    k_in_mag_sq = k_in_mag**2\n\n    # Determine search bounds for Miller indices h, k, l\n    h_max = int(np.ceil(np.linalg.norm(a1) * Q_max / (2 * np.pi)))\n    k_max = int(np.ceil(np.linalg.norm(a2) * Q_max / (2 * np.pi)))\n    l_max = int(np.ceil(np.linalg.norm(a3) * Q_max / (2 * np.pi)))\n    \n    hkls_list = []\n    \n    for h in range(-h_max, h_max + 1):\n        for k in range(-k_max, k_max + 1):\n            for l in range(-l_max, l_max + 1):\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                G = h * b1 + k * b2 + l * b3\n                G_mag = np.linalg.norm(G)\n                \n                # Condition 1: |G| = Q_max\n                if G_mag  Q_max:\n                    continue\n                \n                # Condition 2: Diffraction condition (Laue)\n                # Test |(2*k_in.G + |G|^2) / |k_in|^2| = epsilon\n                G_mag_sq = G_mag**2\n                laue_check_numerator = 2 * np.dot(k_in, G) + G_mag_sq\n                \n                # Handle case where k_in_mag_sq is zero, though physically unlikely\n                if k_in_mag_sq == 0:\n                    continue\n                \n                dimensionless_test_val = laue_check_numerator / k_in_mag_sq\n                \n                if abs(dimensionless_test_val) = epsilon:\n                    hkls_list.append([h, k, l])\n\n    # Sort the list for deterministic output\n    hkls_list.sort()\n    \n    # 5. Format the output\n    b_flat = np.concatenate((b1, b2, b3))\n    b_flat_list = [round(comp, 6) for comp in b_flat]\n    reciprocal_volume = round(V_recip, 6)\n    \n    return [b_flat_list, reciprocal_volume, hkls_list]\n\n# Execute the solver\nsolve()\n```", "id": "3504299"}, {"introduction": "一旦我们知道了衍射峰可能出现的位置，结构因子就决定了它们的强度。本练习超越了简单情况，探讨了共振散射如何改变原子散射因子，从而导致在正常条件下本应消失的“禁戒”反射的出现 [@problem_id:3504321]。这展示了X射线衍射对材料细微电子结构和对称性的敏感性。", "problem": "一个二元极性晶体呈纤锌矿结构（空间群 $P6_{3}mc$），每个晶胞中有两个 $A$ 类原子，其分数坐标为 $(0,0,0)$ 和 $(0,0,\\tfrac{1}{2})$，以及两个 $B$ 类原子，其分数坐标为 $(\\tfrac{1}{3},\\tfrac{2}{3},u)$ 和 $(\\tfrac{2}{3},\\tfrac{1}{3},u+\\tfrac{1}{2})$。对于 $(00\\ell)$ 形式的反射，由于 $6_{3}$ 螺旋轴的存在，该结构的常规（非共振）汤姆孙散射对奇数 $\\ell$ 表现出系统性消光。\n\n在 $A$ 类原子的 $K$ 吸收边附近，共振弹性X射线散射获得一个各向异性贡献，其领头项由一个依赖于能量和偏振的原子散射因子修正项来描述。在 $\\sigma \\rightarrow \\pi'$ 偏振通道中，假设对于 $(001)$ 反射， $A$ 原子上的共振各向异性振幅发生变换，使得两个 $A$ 位点在 $(0,0,0)$ 处贡献有效标量振幅 $+\\delta$，在 $(0,0,\\tfrac{1}{2})$ 处贡献 $-\\delta$，而 $B$ 原子在所选能量下对共振项的贡献可以忽略不计。将 $\\delta$ 视为一个依赖于能量和偏振的实值参数（单位为电子）。假设处于运动学（单次散射）区，因此衍射强度与结构因子模的平方成正比。\n\n提供以下与实验相关的信息，用于校准依赖于仪器和样品的比例常数。在相同的光束和探测器条件下，测得的允许反射 $(002)$ 的积分强度为 $I_{\\mathrm{ref}} = 1.20 \\times 10^{6}$ 计数。在 $(002)$ 对应的动量转移下，取非共振（汤姆孙）原子散射因子为 $f_{A}^{(0)} = 12.0$ 电子和 $f_{B}^{(0)} = 7.0$ 电子。内部坐标为 $u = 0.375$。在 $(001)$ 倒易晶格位置，在相同的摇摆曲线窗口内积分的测量背景（主要由荧光引起）为 $B = 1.00 \\times 10^{5}$ 计数，并遵循泊松统计。将可探测性定义为 $(001)$ 反射的积分峰值强度超过背景标准差五倍的条件，即 $I_{001} \\ge 5 \\sqrt{B}$。\n\n仅从结构因子 $F(\\mathbf{Q}) = \\sum_{j} f_{j} \\exp\\!\\left(2\\pi i \\mathbf{Q}\\cdot \\mathbf{r}_{j}\\right)$ 的定义、运动学关系 $I \\propto |F|^{2}$（在相同条件下具有相同的比例常数）以及泊松计数统计出发，推导该共振通道中的 $(001)$ 结构因子和用 $\\delta$ 表示的可探测性判据。使用给定的数值数据，计算满足可探测性条件的最小 $\\delta$。将最终数值答案四舍五入到三位有效数字，并以电子为单位表示（仅报告数字）。所有角度均以弧度为单位，无需进行角度转换。", "solution": "所述问题具有科学依据、内容自洽、提法明确且客观。它描述了共振X射线散射中的一个现实情景，提供了推导出唯一且有意义的解所需的所有物理参数和数学条件。因此，该问题被认为是有效的，并将提供解答。\n\n对于一个晶体，其原子位于位置 $\\mathbf{r}_j$ 且原子散射因子为 $f_j$，其结构因子 $F(\\mathbf{Q})$ 由对晶胞中所有原子 $j$ 的求和给出：\n$$\nF(\\mathbf{Q}) = \\sum_{j} f_{j} \\exp(2\\pi i \\mathbf{Q}\\cdot \\mathbf{r}_{j})\n$$\n对于晶体学反射 $(hkl)$，散射矢量 $\\mathbf{Q}$ 为 $\\mathbf{Q} = h\\mathbf{a}^* + k\\mathbf{b}^* + l\\mathbf{c}^*$。原子 $j$ 的位置以分数坐标给出，为 $\\mathbf{r}_j = x_j\\mathbf{a} + y_j\\mathbf{b} + z_j\\mathbf{c}$。点积简化为 $\\mathbf{Q}\\cdot \\mathbf{r}_j = hx_j + ky_j + lz_j$。因此，$(hkl)$ 反射的结构因子为：\n$$\nF_{hkl} = \\sum_{j} f_{j} \\exp[2\\pi i (hx_j + ky_j + lz_j)]\n$$\n问题考虑的是 $(00\\ell)$ 形式的反射，因此 $h=0$，$k=0$。结构因子表达式简化为：\n$$\nF_{00\\ell} = \\sum_{j} f_{j} \\exp(2\\pi i l z_j)\n$$\n纤锌矿晶胞在指定位置包含四个原子：\n原子 $A1$：$A$ 类，位于 $(x_1, y_1, z_1) = (0,0,0)$\n原子 $A2$：$A$ 类，位于 $(x_2, y_2, z_2) = (0,0,\\tfrac{1}{2})$\n原子 $B1$：$B$ 类，位于 $(x_3, y_3, z_3) = (\\tfrac{1}{3},\\tfrac{2}{3},u)$\n原子 $B2$：$B$ 类，位于 $(x_4, y_4, z_4) = (\\tfrac{2}{3},\\tfrac{1}{3},u+\\tfrac{1}{2})$\n\n该结构 $F_{00\\ell}$ 的通用表达式为：\n$$\nF_{00\\ell} = f_{A1} e^{2\\pi i l (0)} + f_{A2} e^{2\\pi i l (\\frac{1}{2})} + f_{B1} e^{2\\pi i l u} + f_{B2} e^{2\\pi i l (u+\\frac{1}{2})}\n$$\n$$\nF_{00\\ell} = f_{A1} + f_{A2} e^{i\\pi l} + f_{B1} e^{2\\pi i lu} + f_{B2} e^{2\\pi i lu} e^{i\\pi l}\n$$\n$$\nF_{00\\ell} = f_{A1} + f_{A2} e^{i\\pi l} + (f_{B1} + f_{B2} e^{i\\pi l})e^{2\\pi i lu}\n$$\n\n首先，我们分析参考反射 $(002)$。这是一个非共振测量，所以同类原子的散射因子相等：$f_{A1}=f_{A2}=f_A^{(0)}$ 且 $f_{B1}=f_{B2}=f_B^{(0)}$。我们令 $\\ell=2$：\n$$\nF_{002} = f_A^{(0)} + f_A^{(0)} e^{i\\pi (2)} + (f_B^{(0)} + f_B^{(0)} e^{i\\pi (2)})e^{2\\pi i (2)u}\n$$\n由于 $e^{i2\\pi}=1$，这变为：\n$$\nF_{002} = f_A^{(0)} + f_A^{(0)} + (f_B^{(0)} + f_B^{(0)})e^{4\\pi i u} = 2f_A^{(0)} + 2f_B^{(0)}e^{4\\pi i u} = 2(f_A^{(0)} + f_B^{(0)}e^{4\\pi i u})\n$$\n衍射强度与结构因子模的平方成正比，$I_{002} = C|F_{002}|^2$，其中 $C$ 是一个比例常数。\n$$\n|F_{002}|^2 = 4 |f_A^{(0)} + f_B^{(0)}(\\cos(4\\pi u) + i \\sin(4\\pi u))|^2\n$$\n$$\n|F_{002}|^2 = 4 \\left( (f_A^{(0)} + f_B^{(0)}\\cos(4\\pi u))^2 + (f_B^{(0)}\\sin(4\\pi u))^2 \\right)\n$$\n$$\n|F_{002}|^2 = 4 \\left( (f_A^{(0)})^2 + 2f_A^{(0)}f_B^{(0)}\\cos(4\\pi u) + (f_B^{(0)})^2\\cos^2(4\\pi u) + (f_B^{(0)})^2\\sin^2(4\\pi u) \\right)\n$$\n$$\n|F_{002}|^2 = 4 \\left( (f_A^{(0)})^2 + (f_B^{(0)})^2 + 2f_A^{(0)}f_B^{(0)}\\cos(4\\pi u) \\right)\n$$\n使用给定数据 $f_A^{(0)}=12.0$，$f_B^{(0)}=7.0$ 和 $u=0.375=\\frac{3}{8}$：\n$$\n4\\pi u = 4\\pi(\\tfrac{3}{8}) = \\tfrac{3\\pi}{2}\n$$\n因此，$\\cos(4\\pi u) = \\cos(\\tfrac{3\\pi}{2}) = 0$。$|F_{002}|^2$ 的表达式简化为：\n$$\n|F_{002}|^2 = 4( (f_A^{(0)})^2 + (f_B^{(0)})^2 ) = 4( (12.0)^2 + (7.0)^2 ) = 4(144 + 49) = 4(193) = 772\n$$\n比例常数 $C$ 可以从参考强度 $I_{\\mathrm{ref}} = I_{002} = 1.20 \\times 10^6$ 计数确定：\n$$\nC = \\frac{I_{002}}{|F_{002}|^2} = \\frac{1.20 \\times 10^6}{772}\n$$\n\n接下来，我们推导共振条件下的 $(001)$ 反射的结构因子。首先，我们验证 $\\ell=1$ 时的非共振系统性消光。这里 $e^{i\\pi l} = e^{i\\pi} = -1$：\n$$\nF_{001}^{\\text{non-res}} = f_A^{(0)} + f_A^{(0)}(-1) + (f_B^{(0)} + f_B^{(0)}(-1))e^{2\\pi i u} = 0\n$$\n这证实了所述的反射是禁戒的。现在，我们引入指定的共振散射。对于 $(001)$ 反射，原子贡献给出为：$f_{A1}=+\\delta$，$f_{A2}=-\\delta$，以及 $f_B = 0$。使用 $\\ell=1$ 的 $F_{00\\ell}$ 通用表达式：\n$$\nF_{001} = f_{A1} e^{2\\pi i (0)} + f_{A2} e^{2\\pi i (1/2)} + f_{B1} e^{2\\pi i u} + f_{B2} e^{2\\pi i (u+1/2)}\n$$\n$$\nF_{001} = (+\\delta)(1) + (-\\delta)(e^{i\\pi}) + (0)e^{2\\pi i u} + (0)e^{2\\pi i (u+1/2)}\n$$\n$$\nF_{001} = \\delta - \\delta(-1) = 2\\delta\n$$\n这是指定共振通道中 $(001)$ 反射的结构因子。强度 $I_{001}$ 由下式给出：\n$$\nI_{001} = C |F_{001}|^2 = C |2\\delta|^2 = 4C\\delta^2\n$$\n可探测性判据为 $I_{001} \\ge 5\\sqrt{B}$，其中背景 $B = 1.00 \\times 10^5$ 计数。将 $I_{001}$ 的表达式代入，得到用 $\\delta$ 表示的判据：\n$$\n4C\\delta^2 \\ge 5\\sqrt{B}\n$$\n为了找到最小可探测的 $\\delta$，我们使用等式：\n$$\n4C\\delta^2 = 5\\sqrt{B}\n$$\n求解 $\\delta^2$：\n$$\n\\delta^2 = \\frac{5\\sqrt{B}}{4C}\n$$\n现在，代入 $C = I_{002}/|F_{002}|^2$ 的表达式：\n$$\n\\delta^2 = \\frac{5\\sqrt{B}}{4(I_{002}/|F_{002}|^2)} = \\frac{5\\sqrt{B}|F_{002}|^2}{4I_{002}}\n$$\n取平方根（并假设 $\\delta$ 是一个正振幅）：\n$$\n\\delta = \\sqrt{\\frac{5\\sqrt{B}|F_{002}|^2}{4I_{002}}}\n$$\n现在我们代入数值：$B=1.00 \\times 10^5$，$I_{002}=1.20 \\times 10^6$ 和 $|F_{002}|^2=772$。\n$$\n\\delta = \\sqrt{\\frac{5 \\sqrt{1.00 \\times 10^5} \\times 772}{4 \\times 1.20 \\times 10^6}}\n$$\n$$\n\\delta = \\sqrt{\\frac{5 \\times 316.2277... \\times 772}{4.80 \\times 10^6}}\n$$\n$$\n\\delta = \\sqrt{\\frac{1220639.1...}{4.80 \\times 10^6}}\n$$\n$$\n\\delta = \\sqrt{0.2542998...}\n$$\n$$\n\\delta \\approx 0.504281...\n$$\n四舍五入到三位有效数字，$\\delta$ 的最小值为 $0.504$ 电子。", "answer": "$$\n\\boxed{0.504}\n$$", "id": "3504321"}, {"introduction": "X射线衍射的最终目标通常是确定原子结构。然而，实验测量的是强度（$|F|^2$），丢失了结构因子$F$中至关重要的相位信息，这就是所谓的“相位问题”。本练习介绍了帕特森函数，这是一种巧妙的工具，它通过直接处理强度来绘制晶体内部的原子间矢量，从而绕过了相位问题，为解析晶体结构提供了一条有效途径 [@problem_id:3504298]。", "problem": "给定一个在均匀离散网格上建模的晶胞中的周期性电子密度，以及一组具有实数、正散射强度的离散散射中心（原子）。目标是推导并实现帕特森函数的计算，并设计一个自动化程序，用于从二维合成数据集的帕特森图中恢复重原子亚结构。在晶胞中完全使用分数坐标，并在离散格点上施加周期性边界条件。\n\n定义和基本依据：\n- 设晶胞由一个 $N \\times N$ 的网格表示，索引为 $(x,y)$，其中 $x,y \\in \\{0,1,\\dots,N-1\\}$，对应于分数坐标 $(x/N,y/N)$。\n- 离散化的电子密度为 $\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$，通过将原子作为加权的离散脉冲（克罗内克δ函数）放置在网格点上构建：如果有 $M$ 个原子，其网格索引为 $(x_j,y_j)$，散射强度为 $f_j  0$，则对于 $j=1,\\dots,M$，$\\rho[x_j,y_j] \\leftarrow \\rho[x_j,y_j] + f_j$。\n- 离散结构因子是 $\\rho[x,y]$ 的离散傅里叶变换，记为 $F[h,k]$，其中 $h,k \\in \\{0,1,\\dots,N-1\\}$。使用离散傅里叶变换的约定：$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$，且逆变换包含因子 $1/N^2$。\n- 帕特森函数是 $\\rho[x,y]$ 的循环自相关，定义为 $P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$，对于整数位移 $(u,v)$，其中 $u,v \\in \\{0,1,\\dots,N-1\\}$。\n\n任务：\n1) 仅从离散傅里叶变换及其逆变换的定义，以及上述循环自相关的定义出发，推导出帕特森函数可以计算为结构因子幅度平方的离散傅里叶逆变换，即 $P[u,v]$ 等于 $|F[h,k]|^2$ 的离散傅里叶逆变换（在所选离散变换约定的标准归一化下）。提供一个清晰的推导过程，以证明使用快速傅里叶变换（Fast Fourier Transform, FFT）进行计算的路径是合理的。\n\n2) 设计并实现一个算法，该算法在给定帕特森图 $P[u,v]$ 的情况下，能自动重建一个与 $P[u,v]$ 中最强峰一致的重原子亚结构。使用以下建模假设和要求：\n- 原子精确地位于网格点上，即其分数坐标是 $1/N$ 的倍数。\n- 帕特森图在所有原子间差分向量处包含峰，即在对应于所有有序对 $(i,j)$ 的位移 $(x_j-x_i \\bmod N, y_j-y_i \\bmod N)$ 处有峰，包括原点，原点处的峰高是自乘积 $f_j^2$ 的总和。\n- 由于帕特森函数对于原子构型的整体平移和反演是不变的，定义一个报告重建亚结构的标准规范如下：\n  - 将第一个重建的原子固定在网格坐标的原点 $(0,0)$。\n  - 仅使用峰集合和成对差异的一致性来选择后续的原子位置，然后通过除以 $N$ 转换为 $[0,1)$ 内的分数坐标。\n  - 对重建的分数坐标按字典序排序。\n- 为最多 $M=3$ 个原子实现一个确定性的贪心嵌入程序：\n  - 通过搜索局部最大值并丢弃原点 $(u,v)=(0,0)$，从 $P[u,v]$ 中提取一组强的、唯一的非原点峰。保留足够的峰以覆盖最多 $M=3$ 个原子的所有原子间向量。\n  - 按照约定将第一个原子放置在 $(0,0)$。\n  - 使用固定的规则（例如，在对称等效位置中选择字典序最小的索引）从峰集合中确定性地选择一个振幅最高的非原点峰索引 $(u_1,v_1)$，并将第二个原子放置在该处。\n  - 如果存在第三个原子，则将其放置在一个候选峰 $(u_2,v_2)$ 处，使得该位置与第二个原子的差在模运算下与观察到的峰集合一致，即 $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ 或 $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ 存在于观察到的峰中。使用确定性的选择规则，按峰振幅降序然后按索引的字典序来打破平局。\n\n3) 实现完整的流程：\n- 给定 $N$ 和一个由整数索引 $(x_j,y_j)$ 及强度 $f_j$ 指定的原子列表，构建 $\\rho[x,y]$，通过离散傅里叶变换计算 $F[h,k]$，构建强度 $I[h,k] = |F[h,k]|^2$，并通过 $I[h,k]$ 的离散傅里叶逆变换计算帕特森图 $P[u,v]$。\n- 实现上述重原子亚结构搜索算法，以重建一组最多 $M=3$ 个原子的位置，以 $[0,1)$ 内的分数坐标表示，并四舍五入到三位小数。\n- 在标准规范下输出重建的位置。\n\n测试套件：\n为以下三个合成数据集提供结果。所有数据集均为二维，具有周期性边界条件，并且严格位于网格上（网格坐标为整数；分数坐标为整数除以 $N$）：\n- 测试用例 A（边界情况，单个原子）：\n  - $N=32$。\n  - 原子：一个原子位于 $(x_1,y_1)=(8,5)$，强度 $f_1=74$。\n- 测试用例 B（两个原子，强度相等）：\n  - $N=32$。\n  - 原子：两个原子位于 $(x_1,y_1)=(5,9)$ 和 $(x_2,y_2)=(21,15)$，强度 $f_1=f_2=74$。\n- 测试用例 C（三个原子，强度不等，最重的一对占主导）：\n  - $N=32$。\n  - 原子：三个原子，$(x_1,y_1)=(6,10)$ 强度 $f_1=74$；$(x_2,y_2)=(25,22)$ 强度 $f_2=50$；$(x_3,y_3)=(12,27)$ 强度 $f_3=40$。\n\n答案规格：\n- 对于每个测试用例，程序必须返回一个浮点数列表，表示在标准规范下展平的重建分数坐标，四舍五入到三位小数，第一个原子固定在 $(0.000,0.000)$，其余按字典序排序。例如，对于二维中的两个原子，返回四个数字 $[x_1,y_1,x_2,y_2]$，其中 $(x_1,y_1)=(0.000,0.000)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，其本身也是一个浮点数列表。例如：$[[\\dots],[\\dots],[\\dots]]$。\n\n角度单位和物理单位：\n- 不使用物理单位。角度隐含在复指数中，是无量纲的；在此离散设置中不需要单独的角度单位。\n\n您的最终交付成果是一个完整、可运行的程序，该程序通过离散傅里叶变换计算帕特森函数，执行所述的亚结构搜索，并以上述确切格式打印三个测试用例的结果。不需要用户输入；程序应能按原样运行。", "solution": "用户提供了一个材料科学领域的计算问题，具体涉及X射线晶体学中的帕特森函数。该问题将在代表二维晶胞的离散网格上求解。\n\n首先，按照既定协议对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n\n-   **网格**：一个离散的 $N \\times N$ 网格，索引为 $(x,y)$，其中 $x,y \\in \\{0, 1, \\dots, N-1\\}$。\n-   **电子密度 ($\\rho$)**：$\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$ 是由 $M$ 个位于网格点 $(x_j, y_j)$、散射强度为 $f_j  0$ 的原子构建的。每个原子的值 $f_j$ 会累加到 $\\rho[x_j, y_j]$ 上。\n-   **离散傅里叶变换 (DFT)**：结构因子 $F[h,k]$ 是 $\\rho[x,y]$ 的DFT：\n    $$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\n-   **逆DFT**：规定逆变换包含一个归一化因子 $1/N^2$。\n-   **帕特森函数 ($P$)**：电子密度的循环自相关：\n    $$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\n-   **任务1**：推导出 $P[u,v]$ 可以通过计算 $|F[h,k]|^2$ 的逆DFT得到。\n-   **任务2**：设计并实现一个确定性的贪心算法，从帕特森图 $P[u,v]$ 中重建一个最多包含 $M=3$ 个重原子的原子亚结构。这包括：\n    -   提取强的、非原点的峰（局部最大值）。\n    -   定义一个标准规范：原子1位于 $(0,0)$，后续的分数坐标按字典序排序。\n    -   贪心放置：原子2位于振幅最高的峰中字典序最小的索引处。原子3位于候选峰 $(u_2,v_2)$ 处，需满足 $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ 或 $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ 也是一个已观测到的峰，并使用确定性规则解决平局。\n-   **任务3**：实现完整的流程并为三个测试用例提供结果。\n-   **测试用例**：\n    -   A: $N=32$, 1个原子: $((8,5), f=74)$。\n    -   B: $N=32$, 2个原子: $((5,9), f=74)$, $((21,15), f=74)$。\n    -   C: $N=32$, 3个原子: $((6,10), f=74)$, $((25,22), f=50)$, $((12,27), f=40)$。\n-   **答案格式**：单行的JSON风格列表的列表 `[[...],[...],[...]]`，包含每个测试用例展平的、四舍五入到3位小数的分数坐标。\n\n### 步骤2：使用提取的给定信息进行验证\n\n1.  **科学依据**：该问题在傅里叶分析和X射线晶体学中的原理上有坚实的基础。结构因子和帕特森函数的定义是标准的。帕特森函数与结构因子幅度平方之间的关系是傅里叶变换卷积定理的直接结果，这是一个基本结论。将帕特森峰解释为原子间向量是帕特森方法的核心原理。所有前提在科学上都是合理的。\n2.  **良态性**：该问题是良态的。DFT及其逆变换具有一致的归一化约定。亚结构重建的算法要求，包括标准规范和打破平局的规则，都足够详细，以确保每个测试用例都有唯一的、确定性的解。\n3.  **客观性**：问题以精确、客观的数学语言陈述。\n4.  **完整性**：为每个测试用例提供的数据（$N$、原子位置和强度）是完整且足以执行所有要求计算的。所有必要的定义都已提供。\n5.  **可行性**：网格大小（$N=32$）和原子数量（$M\\le3$）都很小，使用标准的快速傅里叶变换（FFT）库函数完全可以实现计算。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。它是一个自洽、科学合理且良态的计算问题。可以继续求解过程。\n\n---\n\n### 解法\n\n解法分为两部分：任务1要求的理论推导，以及任务2和3的计算算法设计。\n\n**第1部分：通过FFT计算帕特森函数的推导**\n\n这部分为高效计算帕特森函数建立了理论基础。\n\n**1. 定义**\n\n设 $N \\times N$ 网格上的离散电子密度为 $\\rho[x,y]$，其中 $x,y \\in \\{0, 1, \\dots, N-1\\}$。该函数为实数且非负。结构因子 $F[h,k]$ 是 $\\rho[x,y]$ 的二维离散傅里叶变换（DFT），记为 $F = \\mathcal{F}\\{\\rho\\}$：\n$$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\n帕特森函数 $P[u,v]$ 是 $\\rho[x,y]$ 的循环自相关：\n$$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\n逆DFT记为 $\\mathcal{F}^{-1}$，其中 $\\rho = \\mathcal{F}^{-1}\\{F\\}$。\n\n**2. 使用互相关定理进行推导**\n\nDFT互相关定理指出，两个信号互相关的DFT等于第一个信号的DFT与第二个信号DFT的复共轭的乘积。由于我们是对实函数 $\\rho$ 进行自相关，这个关系会简化。\n\n我们计算帕特森函数的DFT，$\\mathcal{F}\\{P\\}[h,k]$：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} P[u,v] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\n将 $P[u,v]$ 的定义代入方程：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\right) \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\n重新排列求和顺序：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) \\right) $$\n令 $x' = (x+u) \\bmod N$ 和 $y' = (y+v) \\bmod N$。这意味着 $u = (x' - x) \\bmod N$ 和 $v = (y' - y) \\bmod N$。内部对 $u,v$ 的求和可以重写为对 $x',y'$ 的求和：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{h(x'-x)}{N}+\\frac{k(y'-y)}{N}\\right)\\right) \\right) $$\n分离指数项：\n$$ \\mathcal{F}\\{P\\}[h,k] = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right) \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{hx'}{N}+\\frac{ky'}{N}\\right)\\right) \\right) $$\n第二项是结构因子 $F[h,k]$ 的定义。第一项是 $F[h,k]$ 的复共轭，因为 $\\rho$ 是实数（$\\rho^* = \\rho$）且 $\\exp(i\\theta)^* = \\exp(-i\\theta)$：\n$$ \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right)^* = (F[h,k])^* $$\n因此，我们得到中心关系式：\n$$ \\mathcal{F}\\{P\\}[h,k] = (F[h,k])^* F[h,k] = |F[h,k]|^2 $$\n要获得帕特森函数 $P[u,v]$，我们对两边应用逆DFT：\n$$ P[u,v] = \\mathcal{F}^{-1} \\{ |F[h,k]|^2 \\} $$\n这个推导证实了帕特森图可以通过对密度进行傅里叶变换，计算得到的结构因子的幅度平方（即强度 $I[h,k]$），然后对强度进行逆傅里叶变换来计算。这种基于FFT的方法，其复杂度为 $O(N^2 \\log N)$，远比直接求和的 $O(N^4)$ 方法高效。\n\n**第2部分：算法设计与实现**\n\n完整的流程在一个单一的Python脚本中实现。逻辑遵循问题陈述中指定的任务。\n\n1.  **电子密度构建**：初始化一个大小为 $N \\times N$ 的NumPy二维数组为零。对于输入列表中的每个原子，将其散射强度 $f_j$ 添加到网格位置 $(x_j, y_j)$。\n\n2.  **帕特森图计算**：使用 `numpy.fft.fft2` 和 `numpy.fft.ifft2` 函数。`np.fft.fft2` 计算 $F[h,k]$。然后计算绝对值的平方 $|F[h,k]|^2$。接着对该强度图应用 `np.fft.ifft2`。`numpy` 的 `ifft2` 函数包含了 $1/N^2$ 的归一化因子，与问题的约定相符。取结果的实部得到 $P[u,v]$。\n\n3.  **重原子亚结构搜索**：\n    a.  **峰提取**：使用 `scipy.ndimage.maximum_filter`（采用 $3 \\times 3$ 的足迹和 `'wrap'` 模式以处理周期性边界）来识别帕特森图 $P[u,v]$ 中的局部最大值。对峰进行过滤，只包括那些振幅显著（大于原点峰高的1%）的峰，以避免数值噪声。丢弃位于 $(0,0)$ 的原点峰。将得到的峰存储为元组 `(amplitude, u, v)`，并按振幅降序、坐标字典序升序进行排序。\n    b.  **贪心嵌入**：根据标准规范，初始化一个重建原子网格坐标的列表，第一个原子位于 $(0,0)$。\n        -   **原子2**：如果结构中不止一个原子（即存在非原点峰），则选择振幅最高的非原点峰。如果振幅有平局，则选择网格坐标字典序最小的那个。这决定了第二个原子的位置。\n        -   **原子3**：如果要寻找第三个原子，算法会遍历剩余的已排序峰。对于每个候选峰 $(u_2, v_2)$，进行一致性检查。如果候选峰与第二个原子的向量差 $(u_2-u_1 \\pmod N, v_2-v_1 \\pmod N)$ 或向量和 $(u_2+u_1 \\pmod N, v_2+v_1 \\pmod N)$ 对应于先前识别的峰集合中的一个位置，则接受该候选。由于峰列表是排序的，第一个满足此条件的候选被选中，这是确定性的。\n\n4.  **标准规范与输出格式化**：\n    -   将最终的整数网格坐标列表通过除以 $N$ 转换为分数坐标。\n    -   对这个分数坐标对的列表按字典序排序。\n    -   将排好序的坐标展平为一个单一的浮点数列表。\n    -   将最终列表中的每个数字格式化为三位小数。\n    -   将所有测试用例的结果汇编成一个列表的列表，并打印为单个无空格的字符串，以匹配指定的输出格式 `[[...],[...],[...]]`。\n\n这种结构化的方法确保了所有问题要求都得到满足，为给定的测试用例生成确定性且正确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import maximum_filter\n\ndef solve():\n    \"\"\"\n    Main function to run the Patterson reconstruction pipeline for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 32, 'atoms': [((8, 5), 74)]},\n        {'N': 32, 'atoms': [((5, 9), 74), ((21, 15), 74)]},\n        {'N': 32, 'atoms': [((6, 10), 74), ((25, 22), 50), ((12, 27), 40)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        atoms_data = case['atoms']\n\n        # Task 3, Step 1: Construct electron density rho[x,y]\n        rho = np.zeros((N, N), dtype=float)\n        for (x, y), f in atoms_data:\n            rho[x, y] += f\n\n        # Task 3, Step 2: Compute structure factors, intensities, and Patterson map\n        # numpy's fft/ifft conventions match the problem's requirements:\n        # - fft2: no normalization\n        # - ifft2: 1/N^2 normalization\n        F = np.fft.fft2(rho)\n        I = np.abs(F)**2\n        P = np.fft.ifft2(I).real\n\n        # Task 2  3: Implement heavy-atom substructure search\n        TOL = 1e-6 # Tolerance for floating point comparisons\n\n        # Find local maxima in the Patterson map using a maximum filter\n        p_max_filter = maximum_filter(P, size=3, mode='wrap')\n        maxima_mask = np.abs(P - p_max_filter)  TOL\n        \n        # Filter for significant peaks to avoid numerical artifacts\n        origin_peak_val = P[0, 0]\n        # A low threshold is sufficient for this clean synthetic data.\n        significant_mask = P  origin_peak_val * 0.01 \n\n        peak_coords = np.argwhere(maxima_mask  significant_mask)\n\n        # Create a list of (amplitude, u, v) for unique non-origin peaks\n        non_origin_peaks = []\n        for u, v in peak_coords:\n            if u == 0 and v == 0:\n                continue\n            non_origin_peaks.append((P[u, v], u, v))\n\n        # Sort peaks by amplitude (desc), then u (asc), then v (asc)\n        non_origin_peaks.sort(key=lambda p: (-p[0], p[1], p[2]))\n        \n        # Create a set of peak locations for efficient O(1) average-case lookup\n        peak_locations = {(u, v) for amp, u, v in non_origin_peaks}\n\n        # --- GREEDY EMBEDDING PROCEDURE ---\n        \n        reconstructed_atoms_grid = [(0, 0)] # Atom 1 at origin by convention\n\n        num_atoms_in_case = len(atoms_data)\n\n        if num_atoms_in_case  1 and len(non_origin_peaks)  0:\n            # Place Atom 2\n            # Find all peaks with the max amplitude\n            max_amp = non_origin_peaks[0][0]\n            top_peaks = [p for p in non_origin_peaks if abs(p[0] - max_amp)  TOL]\n            \n            # Choose the one with the lexicographically smallest index.\n            # a_priori sorting ensures top_peaks[0] is the correct choice.\n            _, u1, v1 = top_peaks[0]\n            \n            reconstructed_atoms_grid.append((u1, v1))\n\n            if num_atoms_in_case  2 and len(non_origin_peaks)  1:\n                # Place Atom 3\n                # Create a list of candidate peaks, excluding the one already chosen\n                candidate_peaks = [p for p in non_origin_peaks if (p[1], p[2]) != (u1, v1)]\n                \n                for _, u2, v2 in candidate_peaks:\n                    # Consistency check as per the specific problem instruction\n                    # Check 1: Difference vector\n                    diff_vec = ((u2 - u1) % N, (v2 - v1) % N)\n                    # Check 2: Sum vector\n                    sum_vec = ((u2 + u1) % N, (v2 + v1) % N)\n                    \n                    if diff_vec in peak_locations or sum_vec in peak_locations:\n                        reconstructed_atoms_grid.append((u2, v2))\n                        break\n\n        # --- CANONICAL GAUGE AND FORMATTING ---\n        \n        # Convert integer grid coordinates to fractional coordinates\n        frac_coords = [ (p[0] / N, p[1] / N) for p in reconstructed_atoms_grid ]\n        \n        # Sort the reconstructed atoms' fractional coordinates lexicographically\n        frac_coords.sort()\n\n        # Flatten the list of coordinate pairs\n        final_coords_flat = [coord for pos in frac_coords for coord in pos]\n        \n        results.append(final_coords_flat)\n\n    # Final print statement in the exact required format:\n    # A single string representing a list of lists, e.g., [[...],[...]],\n    # with no spaces and with numbers formatted to three decimal places.\n    final_output_parts = []\n    for res_list in results:\n        formatted_list_str = '[' + ','.join([f'{x:.3f}' for x in res_list]) + ']'\n        final_output_parts.append(formatted_list_str)\n    \n    print('[' + ','.join(final_output_parts) + ']')\n\nsolve()\n```", "id": "3504298"}]}