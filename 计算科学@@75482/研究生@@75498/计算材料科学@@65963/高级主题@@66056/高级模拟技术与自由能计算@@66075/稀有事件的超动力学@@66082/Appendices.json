{"hands_on_practices": [{"introduction": "我们从一项最基本的任务开始：验证超动力学的核心原理。这个练习使用一个简单的一维双势阱模型，这是研究稀有事件的经典范例。你将通过实现标准的和带偏置的朗之万动力学模拟，来证明经过正确的时间重加权后，超动力学能够精确地复现事件的逃逸时间统计分布，从而证实其理论基础的正确性[@problem_id:3458021]。", "problem": "考虑一个由 $V(x)=a x^4 - b x^2$ 定义的一维四次双阱势，其中 $a>0$ 且 $b>0$，以及一个由 $V_b(x)=\\lambda\\,\\max\\left(0, x_c^2 - x^2\\right)$ 定义的依赖于构型的偏置势，其中 $\\lambda\\ge 0$。势阱盆地 $B$ 是闭区间 $[-x_c, x_c]$，其边界是点集 $\\{|x|=x_c\\}$，在边界上偏置势为零。系统使用欧拉-丸山积分器，根据过阻尼朗之万动力学演化，迁移率设为 $1$，逆热能为 $\\beta$，扩散系数为 $D=1/\\beta$。上划线表示在限制于 $B$ 的相关稳态分布上的系综平均。\n\n您的任务是：\n1. 从玻尔兹曼分布和受限配分函数的定义出发，推导超动力学增强因子 $\\alpha$ 的表达式，该表达式为因子 $e^{\\beta V_b(x)}$ 在限制于 $B$ 的偏置稳态分布上的平衡平均值。用涉及 $V(x)$ 和 $V_b(x)$ 的在 $B$ 上的积分明确表示 $\\alpha$，并对给定的参数集通过数值积分计算 $\\alpha$。\n2. 从严格在 $B$ 内部的初始点 $x_0$ 开始，实现两次到达边界 $\\{|x|=x_c\\}$ 的首次穿越模拟：\n   - 无偏置动力学，漂移为 $-\\partial_x V(x)$，扩散系数为 $D=1/\\beta$，得到以特征时间 $\\tau_0$ 为单位的无偏置首次穿越时间 $t$。\n   - 有偏置的超动力学，漂移为 $-\\partial_x\\left(V(x)+V_b(x)\\right)$，扩散系数相同，通过重加权规则 $t_{\\text{phys}}=\\sum_{n} \\Delta t\\, e^{\\beta V_b(x_n)}$ 累积物理时间，其中 $x_n$ 是第 $n$ 个时间步开始时的状态，$\\Delta t$ 是数值积分的时间步长。通过双样本柯尔莫洛戈夫-斯米尔诺夫（KS）检验，从统计上验证 $t_{\\text{phys}}$ 的分布与 $t$ 的分布相匹配。报告一个布尔值，指示 KS 检验的 $p$ 值是否大于 $0.05$。\n3. 使用以下测试套件。对于每种情况，设置 $x_0=-x_c/2$，所有时间以 $\\tau_0$ 为单位表示，并为无偏置和有偏置的模拟执行指定数量的独立轨迹。使用固定的时间步长 $\\Delta t$，并在每次轨迹首次到达 $\\{|x| \\ge x_c\\}$ 时终止。\n   - 情况 A（正常情况）：$a=1.0$, $b=4.0$, $\\beta=4.0$, $\\lambda=1.0$, $x_c=0.6$, $\\Delta t=1\\times 10^{-4}$，轨迹数 $N=1200$。\n   - 情况 B（边界条件）：$a=1.0$, $b=4.0$, $\\beta=4.0$, $\\lambda=0.0$, $x_c=0.6$, $\\Delta t=1\\times 10^{-4}$，轨迹数 $N=1000$。\n   - 情况 C（偏置更强、温度更低的边缘情况）：$a=1.0$, $b=6.0$, $\\beta=6.0$, $\\lambda=2.5$, $x_c=0.5$, $\\Delta t=7\\times 10^{-5}$，轨迹数 $N=1200$。\n4. 您的程序必须：\n   - 通过在 $[-x_c,x_c]$ 上的积分进行数值求积，为每种情况计算 $\\alpha$。\n   - 生成无偏置的首次穿越时间 $t$ 和有偏置重加权的物理时间 $t_{\\text{phys}}$，并执行双样本柯尔莫洛戈夫-斯米尔诺夫（KS）检验以比较分布 $t$ 和 $t_{\\text{phys}}$，返回一个布尔值，指示 KS 检验的 $p$ 值是否超过 $0.05$。\n   - 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，对于每种情况，您需要输出 $\\alpha$ 的数值（浮点数，保留六位小数）和 KS 检验的布尔决策。因此，最终输出必须是一个包含六个项目的列表：$[\\alpha_A,\\text{KS}_A,\\alpha_B,\\text{KS}_B,\\alpha_C,\\text{KS}_C]$。\n\n使用的基本原理：\n- 一维过阻尼朗之万动力学：$dx_t = -\\partial_x U(x_t)\\,dt + \\sqrt{2D}\\,dW_t$，其中对于无偏置动力学 $U(x)=V(x)$，对于有偏置动力学 $U(x)=V(x)+V_b(x)$，$D=1/\\beta$，$W_t$ 是标准维纳过程。\n- 平衡态下的玻尔兹曼统计：在 $B$ 中，对于势 $U(x)$，稳态密度正比于 $e^{-\\beta U(x)}$。\n- 势阱盆地 $B$ 内的超动力学重加权规则：物理时间增量为 $d t_{\\text{phys}} = e^{\\beta V_b(x)}\\, dt$。\n- 柯尔莫洛戈夫-斯米尔诺夫（KS）检验比较两个经验分布函数，并返回一个 $p$ 值，用于评估这些样本是否可被认为来自相同的底层分布。\n\n角度单位不适用。所有物理时间必须以 $\\tau_0$ 为单位报告。增强因子 $\\alpha$ 是无量纲的。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。", "solution": "该问题被验证为具有科学依据、定义明确且客观。它展示了将超动力学理论应用于简单一维系统的标准应用，这是计算统计物理学中一个常见的教学示例。所有提供的参数和方程都符合统计力学和随机动力学的原理。关于特征时间单位 $\\tau_0$ 的模糊性已被注意到，但这并不妨碍所需无量纲增强因子 $\\alpha$ 的计算，或与尺度无关的柯尔莫洛戈夫-斯米尔诺夫检验结果。因此，我们可以进行完整的解答。\n\n解答分为两个主要部分：首先是超动力学增强因子 $\\alpha$ 的解析推导和数值计算，其次是随机模拟的实现以统计验证超动力学的核心原理。\n\n**1. 增强因子 $\\alpha$ 的推导与计算**\n\n对于一个在逆温 $\\beta$ 下由势能 $U(x)$ 描述的系统，其稳态概率分布是玻尔兹曼分布，$p(x) \\propto e^{-\\beta U(x)}$。\n\n在超动力学模拟中，系统在偏置势 $U_b(x) = V(x) + V_b(x)$ 下演化。相应的稳态概率密度，当限制在势阱盆地 $B = [-x_c, x_c]$ 时，由下式给出：\n$$\np_b(x) = \\frac{1}{Z_b} e^{-\\beta (V(x) + V_b(x))} \\quad \\text{for } x \\in B\n$$\n其中 $Z_b$ 是偏置系统的受限配分函数，定义为在盆地 $B$ 上的积分：\n$$\nZ_b = \\int_{B} e^{-\\beta (V(x) + V_b(x))} dx = \\int_{-x_c}^{x_c} e^{-\\beta (V(x) + V_b(x))} dx\n$$\n问题将增强因子 $\\alpha$ 定义为重加权因子 $e^{\\beta V_b(x)}$ 在该偏置稳态分布上的系综平均值。这个平均值，记作 $\\overline{e^{\\beta V_b(x)}}_{\\text{biased}}$，计算如下：\n$$\n\\alpha = \\int_{B} e^{\\beta V_b(x)} p_b(x) dx\n$$\n将 $p_b(x)$ 的表达式代入此积分，得到：\n$$\n\\alpha = \\int_{-x_c}^{x_c} e^{\\beta V_b(x)} \\left( \\frac{1}{Z_b} e^{-\\beta (V(x) + V_b(x))} \\right) dx = \\frac{1}{Z_b} \\int_{-x_c}^{x_c} e^{\\beta V_b(x)} e^{-\\beta V(x)} e^{-\\beta V_b(x)} dx\n$$\n涉及偏置势的指数项 $e^{\\beta V_b(x)}$ 和 $e^{-\\beta V_b(x)}$ 相互抵消，将表达式简化为：\n$$\n\\alpha = \\frac{1}{Z_b} \\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx\n$$\n我们认识到分子中的积分是原始无偏置系统的受限配分函数，$Z_u = \\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx$。因此，增强因子 $\\alpha$ 可以优雅地表示为无偏置与有偏置受限配分函数之比：\n$$\n\\alpha = \\frac{Z_u}{Z_b} = \\frac{\\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx}{\\int_{-x_c}^{x_c} e^{-\\beta (V(x) + V_b(x))} dx}\n$$\n给定 $V(x) = ax^4 - bx^2$ 和 $V_b(x) = \\lambda \\max(0, x_c^2 - x^2)$ 的具体形式，并注意到对于 $x \\in [-x_c, x_c]$，表达式简化为 $V_b(x) = \\lambda(x_c^2 - x^2)$，我们得到用于数值计算的最终公式：\n$$\n\\alpha = \\frac{\\int_{-x_c}^{x_c} \\exp\\left(-\\beta (ax^4 - bx^2)\\right) dx}{\\int_{-x_c}^{x_c} \\exp\\left(-\\beta (ax^4 - bx^2 + \\lambda(x_c^2 - x^2))\\right) dx}\n$$\n这些一维积分使用数值求积法计算。\n\n**2. 模拟与统计验证**\n\n系统的演化由过阻尼朗之万方程描述，我们使用时间步长为 $\\Delta t$ 的欧拉-丸山格式将其离散化：\n$$\nx_{n+1} = x_n + F(x_n)\\Delta t + \\sqrt{2D\\Delta t} \\cdot \\mathcal{N}(0,1)\n$$\n其中，$F(x) = -\\partial_x U(x)$ 是力，$D = 1/\\beta$ 是扩散系数，$\\mathcal{N}(0,1)$ 是标准正态随机变量。\n\n对于**无偏置模拟**，势为 $U(x) = V(x) = ax^4 - bx^2$，力为 $F_u(x) = 2bx - 4ax^3$。每条轨迹从 $x_0 = -x_c/2$ 开始演化，直到首次到达边界 $\\{|x| \\ge x_c\\}$。总耗时 $t = N_{\\text{steps}} \\Delta t$ 被记录为无偏置首次穿越时间。\n\n对于**有偏置（超动力学）模拟**，盆地内的势为 $U(x) = V(x) + V_b(x) = ax^4 - (b+\\lambda)x^2 + \\lambda x_c^2$。力为 $F_b(x) = 2(b+\\lambda)x - 4ax^3$。轨迹在此修正力下演化，这加速了从盆地的逃逸。物理时间与模拟时间不等价。它通过累积重加权的时间步长来重建：\n$$\nt_{\\text{phys}} = \\sum_{n=0}^{N_{\\text{steps}}-1} \\Delta t \\cdot e^{\\beta V_b(x_n)}\n$$\n其中 $x_n$ 是粒子在第 $n$ 个时间步开始时的位置。到达边界时累积的 $t_{\\text{phys}}$ 是重加权的首次穿越时间。\n\n为了**验证该方法**，我们生成 $N$ 个无偏置首次穿越时间 $\\{t_i\\}$ 的独立样本，以及 $N$ 个有偏置重加权时间 $\\{t_{\\text{phys}, i}\\}$ 的样本。超动力学理论假定这两组样本应来自相同的底层统计分布。我们使用双样本柯尔莫洛戈夫-斯米尔诺夫（KS）检验来测试这一假设。该检验得出一个 $p$ 值。当 $p$ 值大于选定的显著性水平（此处为 $0.05$）时，表明没有统计学证据来拒绝两个分布相同的零假设。程序将为此检验报告一个布尔值（如果 $p > 0.05$ 则为 `True`，否则为 `False`）。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate, stats\n\ndef calculate_alpha(a, b, beta, lambda_, xc):\n    \"\"\"\n    Calculates the hyperdynamics boost factor alpha via numerical quadrature.\n    alpha = Z_u / Z_b = integral(exp(-beta*V)) / integral(exp(-beta*(V+Vb))).\n    \"\"\"\n\n    def unbiased_integrand(x):\n        \"\"\"Integrand for the unbiased partition function Z_u.\"\"\"\n        V = a * x**4 - b * x**2\n        return np.exp(-beta * V)\n\n    def biased_integrand(x):\n        \"\"\"Integrand for the biased partition function Z_b.\"\"\"\n        V = a * x**4 - b * x**2\n        # Inside the basin [-xc, xc], max(0, xc^2 - x^2) is (xc^2 - x^2)\n        Vb = lambda_ * (xc**2 - x**2)\n        return np.exp(-beta * (V + Vb))\n\n    # Numerical integration over the basin B = [-xc, xc]\n    Z_u, _ = integrate.quad(unbiased_integrand, -xc, xc, limit=200)\n    Z_b, _ = integrate.quad(biased_integrand, -xc, xc, limit=200)\n\n    # Avoid division by zero, though Z_b should always be positive.\n    if Z_b == 0:\n        return np.inf\n    \n    return Z_u / Z_b\n\ndef run_simulations(params):\n    \"\"\"\n    Runs both unbiased and biased simulations to collect first-passage times.\n    \"\"\"\n    a, b, beta, lambda_, xc, dt, N = params['a'], params['b'], params['beta'], params['lambda_'], params['xc'], params['dt'], params['N']\n    \n    D = 1.0 / beta\n    x0 = -xc / 2.0\n    \n    sqrt_2Ddt = np.sqrt(2 * D * dt)\n\n    def simulate_trajectories(is_biased):\n        \"\"\"Helper function to run N trajectories for one type of dynamics.\"\"\"\n        times = np.zeros(N)\n        for i in range(N):\n            x = x0\n            t_physical = 0.0\n            t_simulation = 0.0\n\n            while np.abs(x)  xc:\n                x_n = x  # Position at start of step\n                \n                if is_biased:\n                    force = 2 * (b + lambda_) * x_n - 4 * a * x_n**3\n                else:\n                    force = 2 * b * x_n - 4 * a * x_n**3\n                \n                # Euler-Maruyama step\n                noise_term = sqrt_2Ddt * np.random.randn()\n                x = x_n + force * dt + noise_term\n                \n                # Time accumulation\n                if is_biased:\n                    Vb = lambda_ * (xc**2 - x_n**2)\n                    t_physical += dt * np.exp(beta * Vb)\n                else:\n                    t_simulation += dt\n\n            if is_biased:\n                times[i] = t_physical\n            else:\n                times[i] = t_simulation\n        return times\n\n    unbiased_times = simulate_trajectories(is_biased=False)\n    biased_reweighted_times = simulate_trajectories(is_biased=True)\n    \n    return unbiased_times, biased_reweighted_times\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 1.0, 'b': 4.0, 'beta': 4.0, 'lambda_': 1.0, 'xc': 0.6, 'dt': 1e-4, 'N': 1200},\n        {'a': 1.0, 'b': 4.0, 'beta': 4.0, 'lambda_': 0.0, 'xc': 0.6, 'dt': 1e-4, 'N': 1000},\n        {'a': 1.0, 'b': 6.0, 'beta': 6.0, 'lambda_': 2.5, 'xc': 0.5, 'dt': 7e-5, 'N': 1200},\n    ]\n\n    results = []\n    # Set a seed for reproducibility of the stochastic simulations\n    np.random.seed(42)\n\n    for case in test_cases:\n        # Task 1: Compute boost factor alpha\n        alpha = calculate_alpha(case['a'], case['b'], case['beta'], case['lambda_'], case['xc'])\n        results.append(str(round(alpha, 6)))\n\n        # Task 2  3: Run simulations and perform KS test\n        t_unbiased, t_phys_biased = run_simulations(case)\n        \n        # Two-sample Kolmogorov-Smirnov test\n        _ks_statistic, p_value = stats.ks_2samp(t_unbiased, t_phys_biased)\n        \n        # Report boolean for p-value > 0.05\n        ks_decision = p_value > 0.05\n        results.append(str(ks_decision))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3458021"}, {"introduction": "在掌握基本原理后，我们从使用预定义的偏置势转向一种在真实模拟中更实用、更具适应性的方法。这个练习将指导你如何基于势能面的局部曲率（通过Hessian矩阵的最小特征值 $\\lambda_{\\min}$ 来识别）“动态地”构建偏置势 $V_b$ [@problem_id:3457977]。你还将解决一个关键的实际挑战：创建一个平滑的偏置势，并确保其在过渡态附近精确地为零，这是保证速率计算准确性的关键一步。", "problem": "要求您形式化并实现一个超动力学偏置势，该偏置势取决于分子动力学轨迹上Hessian矩阵的最小特征值。请从以下基础开始：根据过渡态理论 (TST)，在过渡态分割面上恒为零的非负偏置势不会改变稀有事件的速率。对于一个状态由离散时间样本索引的轨迹，设在某个采样构象下Hessian矩阵的最小特征值为$\\lambda_{\\min}$，它在鞍点区域可以为负，在势阱中可以为正。目标是基于$\\lambda_{\\min}$的阈值构建一个偏置势，同时强制该偏置在鞍点区域周围的一个小带内消失，以保持TST的一致性。\n\n仅使用基本原理和定义，在单个完整的程序中完成以下任务。所有能量必须以电子伏特（写作 $\\mathrm{eV}$）表示，能量的倒数以 $\\mathrm{eV}^{-1}$ 表示。不使用角度。您的程序必须使用下面详述的精确数值参数和测试数组。\n\n1. 为给定样本定义一个朴素偏置势 $V_b^{\\mathrm{naive}}(\\lambda_{\\min}) = c \\,\\max\\!\\big(0,\\ \\lambda^* - \\lambda_{\\min}\\big)$，其中 $c$ 的单位是每单位 $\\lambda_{\\min}$ 的 $\\mathrm{eV}$，$\\lambda^*$ 是为 $\\lambda_{\\min}$ 选择的阈值。根据构造，此函数是非负的。\n\n2. 认识到在 $\\lambda_{\\min} \\approx 0$ 的非谐鞍点区域，朴素偏置通常非零，您必须引入一个平滑核函数 $K(\\lambda_{\\min};\\delta)$，该函数强制在 $|\\lambda_{\\min}|\\le\\delta$ 时 $V_b=0$，同时平滑地过渡到远离鞍点区域时不进行抑制。构建 $K$ 使其二阶连续可微并满足：\n   - 当 $|\\lambda_{\\min}| \\le \\delta$ 时，$K(\\lambda_{\\min};\\delta) = 0$，\n   - 当 $|\\lambda_{\\min}| \\ge 2\\delta$ 时，$K(\\lambda_{\\min};\\delta) = 1$，\n   - 在区间 $\\delta \\lt |\\lambda_{\\min}| \\lt 2\\delta$ 上，随 $|\\lambda_{\\min}|$ 单调增加，\n   - 在 $|\\lambda_{\\min}|=\\delta$ 和 $|\\lambda_{\\min}|=2\\delta$ 处，一阶和二阶导数连续。\n   为实现此目的，通过 $t = \\big(|\\lambda_{\\min}| - \\delta\\big)/\\delta$ 将 $|\\lambda_{\\min}|$ 映射到归一化坐标 $t \\in [0,1]$，并使用满足 $S(0)=0$, $S(1)=1$, $S'(0)=0$, $S'(1)=0$, $S''(0)=0$, $S''(1)=0$ 的最小次数多项式来显式构建核函数。定义当 $t \\le 0$ 时 $K(\\lambda_{\\min};\\delta) = 0$，当 $t \\ge 1$ 时 $K(\\lambda_{\\min};\\delta) = 1$，当 $t \\in (0,1)$ 时 $K(\\lambda_{\\min};\\delta) = S(t)$。\n\n3. 将平滑偏置势定义为 $V_b^{\\mathrm{sm}}(\\lambda_{\\min}) = K(\\lambda_{\\min};\\delta)\\,V_b^{\\mathrm{naive}}(\\lambda_{\\min})$。\n\n4. 对于给定的逆热能 $\\beta$（单位为 $\\mathrm{eV}^{-1}$），将样本的瞬时超动力学增强因子定义为 $b = \\exp(\\beta V_b)$，并将离散轨迹段上的时间平均值定义为样本上的算术平均值 $\\langle b \\rangle$。\n\n5. 对于每个轨迹段，通过计算在鞍带 $|\\lambda_{\\min}|\\le\\delta$ 内的最大伪偏置来量化注入鞍带的伪偏置；分别为朴素偏置和平滑偏置定义此量。\n\n6. 为您的核函数实现一个数值可微性检查：在 $x=\\delta$ 和 $x=2\\delta$ 处，使用步长 $\\varepsilon=\\delta/1000$ 的单边有限差分来验证关于 $x=|\\lambda_{\\min}|$ 的一阶和二阶导数的双边连续性。具体来说，使用一阶单边差分计算左右一阶导数，使用二阶单边差分计算左右二阶导数，并返回一个布尔值，如果每个点上左右导数之间的绝对差对于一阶导数低于 $10^{-6}$ 且对于二阶导数低于 $10^{-4}$，则该布尔值为真。\n\n使用以下固定参数，这些参数在所有测试中保持不变：\n- 逆热能 $\\beta = 20.0\\ \\mathrm{eV}^{-1}$（将数字写作 $20.0$）。\n- 偏置缩放因子 $c = 0.02\\ \\mathrm{eV}$ 每单位 $\\lambda_{\\min}$（将数字写作 $0.02$）。\n- 阈值 $\\lambda^* = 1.0$（将数字写作 $1.0$）。\n- 平滑半宽度 $\\delta = 0.05$（将数字写作 $0.05$）。\n\n将您的实现应用于以下四个轨迹段的测试套件，每个轨迹段都以 $\\lambda_{\\min}$ 样本的有序列表形式给出：\n- 测试 A（远离鞍点的势阱区域）：$\\big[0.7,\\ 0.8,\\ 0.9,\\ 0.85,\\ 0.75\\big]$。\n- 测试 B（非谐鞍带）：$\\big[-0.02,\\ 0.01,\\ -0.03,\\ 0.0,\\ 0.02,\\ -0.01\\big]$。\n- 测试 C（围绕 $\\delta$ 和 $2\\delta$ 的边界检查）：$\\big[-0.05,\\ 0.05,\\ -0.10,\\ 0.10,\\ -0.049,\\ 0.049,\\ -0.051,\\ 0.051,\\ -0.099,\\ 0.099,\\ -0.101,\\ 0.101\\big]$。\n- 测试 D（深鞍状区域）：$\\big[-0.5,\\ -0.2,\\ -0.3,\\ -0.25,\\ -0.4\\big]$。\n\n对于每个测试段，按顺序产生以下输出：\n- 朴素偏置的时间平均增强因子，$\\langle \\exp(\\beta V_b^{\\mathrm{naive}}) \\rangle$，作为浮点数。\n- 平滑偏置的时间平均增强因子，$\\langle \\exp(\\beta V_b^{\\mathrm{sm}}) \\rangle$，作为浮点数。\n- 鞍带 $|\\lambda_{\\min}|\\le\\delta$ 内的最大伪朴素偏置，作为浮点数，单位为 $\\mathrm{eV}$。\n- 鞍带 $|\\lambda_{\\min}|\\le\\delta$ 内的最大伪平滑偏置，作为浮点数，单位为 $\\mathrm{eV}$。\n- 上述的核函数可微性检查布尔值。\n\n您的程序应产生单行输出，其中包含一个逗号分隔的列表，列表内容为每个测试的结果，每个测试结果是一个包含上述五个条目的列表，并用方括号括起来。例如，您的最终输出必须是单行形式，如下所示：\n$[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5], [d_1,d_2,d_3,d_4,d_5] ]$\n其中占位符被计算值替换。所有浮点输出必须是标准十进制表示。不应打印其他任何文本。", "solution": "我们构建一个用于超动力学的偏置，该偏置通过强制其在过渡态分割面上消失来保持过渡态理论 (TST) 的速率。其基本依据是TST的论述，即添加一个在分割面上恒为零的非负偏置势 $V_b$ 不会改变穿越概率，并且可以通过使用因子 $\\exp(\\beta V_b)$ 进行重加权来恢复加速后的时间，其中 $\\beta$ 是逆热能，单位为 $\\mathrm{eV}^{-1}$。对于由 $i$ 索引的离散时间序列，朴素的瞬时增强因子是 $b_i^{\\mathrm{naive}}=\\exp(\\beta V_{b,i}^{\\mathrm{naive}})$，时间平均增强因子是算术平均值 $\\langle b^{\\mathrm{naive}}\\rangle=\\frac{1}{N}\\sum_{i=1}^N b_i^{\\mathrm{naive}}$，平滑对应项的定义相同。\n\n1. 给定最小Hessian特征值 $\\lambda_{\\min}$，定义一个朴素偏置\n$$\nV_b^{\\mathrm{naive}}(\\lambda_{\\min}) \\;=\\; c\\,\\max\\!\\big(0,\\ \\lambda^*-\\lambda_{\\min}\\big),\n$$\n其中 $c$ 的单位是每单位 $\\lambda_{\\min}$ 的 $\\mathrm{eV}$。这个选择是非负的，因为它是一个正常数乘以一个与零的最大值。然而，在 $\\lambda_{\\min}\\approx 0$（由于非谐性可能略为负）的鞍点区域，只要 $\\lambda^*-\\lambda_{\\min}>0$，朴素偏置就保持为正，这违反了TST要求的在分割面上偏置为零的条件。因此，我们需要一个平滑因子，以消除在零点周围的小带 $|\\lambda_{\\min}|\\le\\delta$ 内的偏置。\n\n2. 我们需要一个核函数 $K(\\lambda_{\\min};\\delta)$，具有以下性质：\n- 当 $|\\lambda_{\\min}|\\le\\delta$ 时，$K(\\lambda_{\\min};\\delta)=0$，\n- 当 $|\\lambda_{\\min}|\\ge 2\\delta$ 时，$K(\\lambda_{\\min};\\delta)=1$，\n- 在 $\\delta  |\\lambda_{\\min}|  2\\delta$ 上，随 $|\\lambda_{\\min}|$ 单调增加，\n- 在连接点 $|\\lambda_{\\min}|=\\delta$ 和 $|\\lambda_{\\min}|=2\\delta$ 处，二阶连续可微。\n\n为了获得满足平滑性约束的最小次数多项式，我们引入归一化坐标\n$$\nt \\;=\\; \\frac{|\\lambda_{\\min}| - \\delta}{\\delta},\n$$\n它将 $|\\lambda_{\\min}|=\\delta$ 映射到 $t=0$，将 $|\\lambda_{\\min}|=2\\delta$ 映射到 $t=1$。我们寻求一个多项式 $S(t)$ 使得\n$$\nS(0)=0,\\quad S(1)=1,\\quad S'(0)=0,\\quad S'(1)=0,\\quad S''(0)=0,\\quad S''(1)=0.\n$$\n满足六个独立线性条件的最小次数多项式是五次多项式，$S(t)=a_0+a_1 t+a_2 t^2+a_3 t^3+a_4 t^4+a_5 t^5$。强制执行这些条件可以得到一个关于系数的线性系统。根据 $S(0)=0$ 设 $a_0=0$，根据 $S'(0)=0$ 和 $S''(0)=0$ 设 $a_1=0$，$a_2=0$。使用在 $t=1$ 处的端点条件：\n$$\n\\begin{aligned}\nS(1)=a_3+a_4+a_5=1,\\\\\nS'(1)=3a_3+4a_4+5a_5=0,\\\\\nS''(1)=6a_3+12a_4+20a_5=0,\n\\end{aligned}\n$$\n我们解出 $a_3$、$a_4$ 和 $a_5$。从第三个方程中减去第二个方程的两倍，得到 $(6a_3+12a_4+20a_5) - 2(3a_3+4a_4+5a_5) = 0$，因此 $4a_4+10a_5=0$ 且 $a_4=-\\tfrac{5}{2}a_5$。代入第二个方程得到 $3a_3+4(-\\tfrac{5}{2}a_5)+5a_5=3a_3-10a_5+5a_5=3a_3-5a_5=0$，所以 $a_3=\\tfrac{5}{3}a_5$。使用第一个方程，$\\tfrac{5}{3}a_5-\\tfrac{5}{2}a_5+a_5=1$，简化为 $\\big(\\tfrac{5}{3}-\\tfrac{5}{2}+1\\big)a_5=1$。括号中的系数是 $\\tfrac{10}{6}-\\tfrac{15}{6}+\\tfrac{6}{6}=\\tfrac{1}{6}$，所以 $a_5=6$。然后 $a_3=\\tfrac{5}{3}\\cdot 6=10$ 且 $a_4=-\\tfrac{5}{2}\\cdot 6=-15$。因此\n$$\nS(t) \\;=\\; 10 t^3 - 15 t^4 + 6 t^5 \\;=\\; 6 t^5 - 15 t^4 + 10 t^3,\n$$\n这是著名的五次smoothstep函数，它是 $C^2$ 连续的。然后我们定义\n$$\nK(\\lambda_{\\min};\\delta) \\;=\\;\n\\begin{cases}\n0,   t\\le 0,\\\\\nS(t),   0\\lt t\\lt 1,\\\\\n1,   t\\ge 1,\n\\end{cases}\n\\qquad\\text{其中}\\quad t=\\dfrac{|\\lambda_{\\min}|-\\delta}{\\delta}.\n$$\n根据构造，$K$ 在 $\\delta|\\lambda_{\\min}|2\\delta$ 上随 $|\\lambda_{\\min}|$ 单调增加，并且由于 $S'(0)=S'(1)=0$ 和 $S''(0)=S''(1)=0$，其一阶和二阶导数在端点处与左右两边的常数部分连续匹配。\n\n3. 平滑偏置是\n$$\nV_b^{\\mathrm{sm}}(\\lambda_{\\min}) \\;=\\; K(\\lambda_{\\min};\\delta)\\, V_b^{\\mathrm{naive}}(\\lambda_{\\min}).\n$$\n对于 $|\\lambda_{\\min}|\\le \\delta$，我们有 $K=0$，因此 $V_b^{\\mathrm{sm}}=0$，满足了在分割面附近的TST要求。对于 $|\\lambda_{\\min}|\\ge 2\\delta$，$K=1$，偏置简化为朴素形式，从而在深势阱中或远离鞍带区域时保持加速效果。\n\n4. 对于每个具有样本 $\\{\\lambda_{\\min,i}\\}_{i=1}^N$ 的时间序列段，我们计算瞬时增强因子 $b_i^{\\mathrm{naive}}=\\exp(\\beta V_{b,i}^{\\mathrm{naive}})$ 和 $b_i^{\\mathrm{sm}}=\\exp(\\beta V_{b,i}^{\\mathrm{sm}})$，然后计算平均值\n$$\n\\left\\langle b^{\\mathrm{naive}}\\right\\rangle \\;=\\; \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\big(\\beta V_{b,i}^{\\mathrm{naive}}\\big),\\qquad\n\\left\\langle b^{\\mathrm{sm}}\\right\\rangle \\;=\\; \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\big(\\beta V_{b,i}^{\\mathrm{sm}}\\big).\n$$\n鞍带内的伪偏置通过以下方式量化\n$$\n\\max_{i:\\ |\\lambda_{\\min,i}|\\le\\delta} V_{b,i}^{\\mathrm{naive}},\\qquad\n\\max_{i:\\ |\\lambda_{\\min,i}|\\le\\delta} V_{b,i}^{\\mathrm{sm}},\n$$\n并约定空集上的最大值为 $0$。\n\n5. 数值可微性检查。在 $x=\\delta$ 和 $x=2\\delta$ 处，其中 $x=|\\lambda_{\\min}|$，我们定义步长 $\\varepsilon=\\delta/1000$ 并计算导数的单边有限差分近似。对于函数 $f(x)=K(x;\\delta)$ 其中 $x\\ge 0$，在 $x_0$ 处的左一阶导数近似为\n$$\nf'_-(x_0)\\;\\approx\\;\\frac{f(x_0)-f(x_0-\\varepsilon)}{\\varepsilon},\n$$\n右一阶导数近似为\n$$\nf'_+(x_0)\\;\\approx\\;\\frac{f(x_0+\\varepsilon)-f(x_0)}{\\varepsilon}.\n$$\n类似地，左二阶导数可以用\n$$\nf''_-(x_0)\\;\\approx\\;\\frac{f(x_0)-2f(x_0-\\varepsilon)+f(x_0-2\\varepsilon)}{\\varepsilon^2},\n$$\n来近似，右二阶导数可以用\n$$\nf''_+(x_0)\\;\\approx\\;\\frac{f(x_0+2\\varepsilon)-2f(x_0+\\varepsilon)+f(x_0)}{\\varepsilon^2}.\n$$\n来近似。然后我们检查对于 $x_0=\\delta$ 和 $x_0=2\\delta$，是否有 $|f'_+(x_0)-f'_-(x_0)|10^{-6}$ 和 $|f''_+(x_0)-f''_-(x_0)|10^{-4}$。因为 $K$ 在 $[0,\\delta]$ 和 $[2\\delta,\\infty)$ 上是常数，且 $S'(0)=S'(1)=0$，$S''(0)=S''(1)=0$，这些差值在数值精度范围内应接近于零。\n\n6. 参数和测试。我们使用固定参数 $\\beta=20.0\\ \\mathrm{eV}^{-1}$，$c=0.02\\ \\mathrm{eV}$ 每单位 $\\lambda_{\\min}$，$\\lambda^*=1.0$ 和 $\\delta=0.05$。四个轨迹段是\n- 测试 A: $\\big[0.7,\\ 0.8,\\ 0.9,\\ 0.85,\\ 0.75\\big]$,\n- 测试 B: $\\big[-0.02,\\ 0.01,\\ -0.03,\\ 0.0,\\ 0.02,\\ -0.01\\big]$,\n- 测试 C: $\\big[-0.05,\\ 0.05,\\ -0.10,\\ 0.10,\\ -0.049,\\ 0.049,\\ -0.051,\\ 0.051,\\ -0.099,\\ 0.099,\\ -0.101,\\ 0.101\\big]$,\n- 测试 D: $\\big[-0.5,\\ -0.2,\\ -0.3,\\ -0.25,\\ -0.4\\big]$。\n\n7. 输出规范。对于每个测试，输出一个包含五个条目的列表：$\\langle \\exp(\\beta V_b^{\\mathrm{naive}}) \\rangle$，$\\langle \\exp(\\beta V_b^{\\mathrm{sm}}) \\rangle$，$\\max_{|\\lambda_{\\min}|\\le\\delta} V_b^{\\mathrm{naive}}$（单位 $\\mathrm{eV}$），$\\max_{|\\lambda_{\\min}|\\le\\delta} V_b^{\\mathrm{sm}}$（单位 $\\mathrm{eV}$），以及可微性检查布尔值。将四个测试的列表聚合到单个列表中，并在一行上打印该单个列表，不含其他文本。\n\n要实现的算法步骤：\n- 实现 $S(t)=6t^5-15t^4+10t^3$ 和分段函数 $K(\\lambda_{\\min};\\delta)$，使用 $t=\\big(|\\lambda_{\\min}|-\\delta\\big)/\\delta$，并对 $t\\le 0$ 和 $t\\ge 1$ 进行截断处理。\n- 为每个样本计算 $V_b^{\\mathrm{naive}}$ 和 $V_b^{\\mathrm{sm}}$。\n- 计算 $\\exp(\\beta V_b)$ 的平均值。\n- 计算集合 $\\{i:\\ |\\lambda_{\\min,i}|\\le\\delta\\}$ 内 $V_b$ 的最大值，若集合为空则为 $0$。\n- 使用 $\\varepsilon=\\delta/1000$ 在 $x=\\delta$ 和 $x=2\\delta$ 处实现单边有限差分检查。\n\n数值输出中，增强因子是无量纲的，偏置的单位是 $\\mathrm{eV}$。所有要求的输出都是浮点数或布尔值。", "answer": "```python\nimport numpy as np\n\ndef smoothstep_quintic(t):\n    # S(t) = 6 t^5 - 15 t^4 + 10 t^3 for t in [0,1]\n    return ((6.0 * t - 15.0) * t + 10.0) * t**3\n\ndef kernel_K(lam, delta):\n    # K depends on |lambda_min|\n    x = abs(lam)\n    if x = delta:\n        return 0.0\n    elif x >= 2.0 * delta:\n        return 1.0\n    else:\n        t = (x - delta) / delta  # in (0,1)\n        return smoothstep_quintic(t)\n\ndef bias_naive(lam, c, lam_star):\n    return c * max(0.0, lam_star - lam)\n\ndef bias_smoothed(lam, c, lam_star, delta):\n    return kernel_K(lam, delta) * bias_naive(lam, c, lam_star)\n\ndef avg_boost(lams, beta, c, lam_star, delta=None):\n    if delta is None:\n        vb = np.array([bias_naive(l, c, lam_star) for l in lams], dtype=float)\n    else:\n        vb = np.array([bias_smoothed(l, c, lam_star, delta) for l in lams], dtype=float)\n    return float(np.mean(np.exp(beta * vb)))\n\ndef max_spurious_bias(lams, c, lam_star, delta, smoothed=False):\n    mask = np.array([abs(l) = delta for l in lams], dtype=bool)\n    if not np.any(mask):\n        return 0.0\n    if smoothed:\n        arr = np.array([bias_smoothed(l, c, lam_star, delta) for l in lams], dtype=float)\n    else:\n        arr = np.array([bias_naive(l, c, lam_star) for l in lams], dtype=float)\n    return float(np.max(arr[mask])) if arr[mask].size > 0 else 0.0\n\ndef kernel_derivative_checks(delta, atol1=1e-6, atol2=1e-4):\n    # Check at x = delta, x = 2*delta using one-sided finite differences\n    eps = delta / 1000.0 if delta > 0 else 1e-9\n\n    def Kx(x):\n        # K as a function of x = |lambda_min|, x >= 0\n        if x = delta:\n            return 0.0\n        elif x >= 2.0 * delta:\n            return 1.0\n        else:\n            t = (x - delta) / delta\n            return smoothstep_quintic(t)\n\n    def first_deriv_left(x0):\n        # (f(x0) - f(x0 - eps)) / eps\n        return (Kx(x0) - Kx(x0 - eps)) / eps\n\n    def first_deriv_right(x0):\n        # (f(x0 + eps) - f(x0)) / eps\n        return (Kx(x0 + eps) - Kx(x0)) / eps\n\n    def second_deriv_left(x0):\n        # (f(x0) - 2 f(x0 - eps) + f(x0 - 2 eps)) / eps^2\n        return (Kx(x0) - 2.0 * Kx(x0 - eps) + Kx(x0 - 2.0 * eps)) / (eps ** 2)\n\n    def second_deriv_right(x0):\n        # (f(x0 + 2 eps) - 2 f(x0 + eps) + f(x0)) / eps^2\n        return (Kx(x0 + 2.0 * eps) - 2.0 * Kx(x0 + eps) + Kx(x0)) / (eps ** 2)\n\n    checks = []\n    for x0 in (delta, 2.0 * delta):\n        dL = first_deriv_left(x0)\n        dR = first_deriv_right(x0)\n        ddL = second_deriv_left(x0)\n        ddR = second_deriv_right(x0)\n        ok1 = abs(dR - dL)  atol1\n        ok2 = abs(ddR - ddL)  atol2\n        checks.append(ok1 and ok2)\n    return all(checks)\n\ndef solve():\n    # Fixed parameters\n    beta = 20.0  # eV^{-1}\n    c = 0.02     # eV per unit of lambda_min\n    lam_star = 1.0\n    delta = 0.05\n\n    # Test suite: lists of lambda_min samples\n    tests = [\n        [0.7, 0.8, 0.9, 0.85, 0.75],  # Test A\n        [-0.02, 0.01, -0.03, 0.0, 0.02, -0.01],  # Test B\n        [-0.05, 0.05, -0.10, 0.10, -0.049, 0.049, -0.051, 0.051, -0.099, 0.099, -0.101, 0.101],  # Test C\n        [-0.5, -0.2, -0.3, -0.25, -0.4],  # Test D\n    ]\n\n    results = []\n    for lams in tests:\n        # Average boost factors\n        avg_boost_naive_val = avg_boost(lams, beta, c, lam_star, delta=None)\n        avg_boost_smoothed_val = avg_boost(lams, beta, c, lam_star, delta=delta)\n        # Spurious bias in saddle band\n        max_spurious_naive = max_spurious_bias(lams, c, lam_star, delta, smoothed=False)\n        max_spurious_smoothed = max_spurious_bias(lams, c, lam_star, delta, smoothed=True)\n        # Kernel differentiability boolean\n        kernel_ok = kernel_derivative_checks(delta)\n        results.append([\n            avg_boost_naive_val,\n            avg_boost_smoothed_val,\n            max_spurious_naive,\n            max_spurious_smoothed,\n            kernel_ok\n        ])\n\n    # Print results as a single-line list of lists\n    # Ensure default string conversion for booleans and floats\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3457977"}, {"introduction": "许多现实世界中的过程涉及多种可能的演化结果。这个实践将探讨超动力学如何处理具有多个不同逃逸通道的复杂系统[@problem_id:3457997]。你将验证一个正确施加的偏置势能够保持分支概率（即每种结果的相对可能性）不变，然后通过构建一个反例来探索对超动力学条件的微小违背是如何导致错误预测的，从而加深你对该方法适用边界的理解。", "problem": "考虑一个二维构型空间中的盆地区域，该区域有两个不同的出口通道，终止于两个不重叠的分界表面 $S_1$ 和 $S_2$。设物理势能为 $U(\\mathbf{r})$，其中 $\\mathbf{r} = (x,y)$，温度为 $T$，因此逆热能为 $\\beta = 1/(k_\\mathrm{B} T)$，其中 $k_\\mathrm{B}$ 是玻尔兹曼常数。在物理势上增加一个超动力学偏置势 $V_b(\\mathbf{r})$，以加速稀有事件逃逸，同时旨在保持多出口分支概率。根据过渡态理论（TST），从盆地到出口 $i$ 的速率与穿过 $S_i$ 的反应通量成正比，分支概率 $\\pi_i$ 定义为该通量与总通量之比，即 $\\pi_i = J_i / \\sum_j J_j$。能量必须以 $k_\\mathrm{B} T$ 为单位处理（因此 $\\beta$ 是无量纲的），几何结构也是无量纲的。\n\n从正则平衡分布和过渡态理论的反应通量定义出发，推导并实现一个数值方案来完成以下任务：\n1. 计算到每个出口 $i$ 的反应通量 $J_i$ 和相应的分支概率 $\\pi_i$。\n2. 当偏置势 $V_b(\\mathbf{r})$ 在每个分界表面 $S_i$ 上逐点为零时，通过验证 $\\sum_i \\pi_i = 1$ 且每个 $\\pi_i$ 在此情况下对 $V_b$ 保持不变，来证明超动力学保持多出口分支特性。\n3. 构建一个反例，其中偏置势 $V_b(\\mathbf{r})$ 调制紧邻一个分界表面的窄通道中的力，使得 $V_b(\\mathbf{r})$ 在紧靠 $S_1$ 内部、厚度为 $\\delta$ 的薄带中具有非零的法向梯度（允许 $V_b$ 在 $S_1$ 本身上为零）。根据 $V_b$ 沿该薄带的局域梯度来量化变化量 $\\Delta \\pi_i$。\n\n您必须使用以下数学上指定的测试几何结构，它将多维通量积分压缩为沿每个分界表面的易于处理的一维表示，并带有一个有限厚度的内部薄带以容纳力调制效应：\n\n- 两个分界表面取为位于 $x=+L$ 和 $x=-L$ 的垂直线段，其中 $y \\in [-W, W]$，分别记为 $S_1$ 和 $S_2$。\n- 限制在每个分界表面上的物理势为\n$$\nU|_{S_1}(y) = E_0 + b_1 y^2, \\quad U|_{S_2}(y) = E_0 + b_2 y^2,\n$$\n其中 $E_0 > 0$ 设定了基线势垒，$b_1, b_2 > 0$ 设定了决定沿 $y$ 方向通道宽度的局部曲率，所有量均以 $k_\\mathrm{B} T$ 为单位。\n- 通过沿向内法线方向，在紧靠每个分界表面内部的有限厚度薄带上对玻尔兹曼因子进行积分，来近似计算通过该薄带的TST反应通量，积分范围为薄带厚度 $\\xi \\in [0, \\delta]$，其中对于 $S_1$ 有 $\\xi = L - x$，对于 $S_2$ 有 $\\xi = x + L$。当 $U$ 在薄带上不依赖于 $x$ 时，无偏置通量与 $\\delta$ 成正比。\n- 超动力学偏置 $V_b(\\mathbf{r})$ 以两种方式引入：\n  - 对于不变性检验，选择 $V_b(\\mathbf{r})$ 在两个薄带（以及在 $S_1$ 和 $S_2$ 上）内严格为零，而在盆地的其他地方可能非零。\n  - 对于反例，在邻近 $S_1$ 的薄带（$\\xi \\in [0,\\delta]$）中定义 $V_b(\\xi,y) = g \\, \\xi \\, f(y)$，其中 $f(y) = \\exp\\!\\left(-y^2/\\sigma_y^2\\right)$，而在邻近 $S_2$ 的薄带中 $V_b(\\mathbf{r}) = 0$。这里 $g$ 是向内法线方向上的恒定梯度大小，$\\sigma_y$ 设定了横向调制宽度，两者都是无量纲的。这种形式确保 $V_b$ 在 $S_1$ 上（$\\xi=0$）精确为零，但在整个薄带上具有非零的法向梯度，从而在穿越前调制力。\n\n在这些规范下，到出口 $i$ 的TST薄带积分反应通量为\n$$\nJ_i = \\int_{-W}^{W} \\int_{0}^{\\delta} \\exp\\!\\left(-\\beta \\left[ U|_{S_i}(y) + V_b(\\xi,y) \\right] \\right) \\, d\\xi \\, dy,\n$$\n且分支概率为 $\\pi_i = J_i / (J_1 + J_2)$。您必须计算：\n- 下述情况下的 $\\pi_1$ 和 $\\pi_2$。\n- 在所有情况下验证 $\\sum_i \\pi_i = 1$。\n- 当 $V_b$ 在整个薄带内为零时，验证 $\\pi_i$ 对 $V_b$ 的不变性。\n- 通过报告 $\\Delta \\pi_1 = \\pi_1^\\text{biased} - \\pi_1^\\text{unbiased}$ 和一个基于梯度的一阶估计 $\\Delta \\pi_1$ 来量化反例。该估计通过将 $S_1$ 的内层薄带积分展开到 $g$ 的领头阶得到，即处理\n$$\n\\int_0^\\delta \\exp\\!\\left(-\\beta g \\xi f(y)\\right) \\, d\\xi \\approx \\delta - \\frac{1}{2} \\beta g \\delta^2 f(y),\n$$\n并将此修正传播到 $\\Delta \\pi_1$ 中。\n\n设计一个完整的程序，使用对 $y$ 的均匀网格上的数值积分和根据需要对 $\\xi$ 的精确积分或数值积分来实现上述通量计算。在能量单位为 $k_\\mathrm{B} T$ 且 $\\beta = 1$ 的单位制中工作。\n\n测试套件：\n- 情况 A（不对称通道，不变性检验）：$E_0 = 6$, $b_1 = 4$, $b_2 = 3$, $L = 1$, $W = 2$, $\\delta = 0.05$, $\\sigma_y = 0.4$, $\\beta = 1$，且在两个薄带中 $V_b(\\mathbf{r}) = 0$。计算 $\\pi_1$ 和 $\\pi_2$ 并验证 $\\pi_1 + \\pi_2 = 1$。引入一个在盆地内部非零但在两个薄带内始终为零的 $V_b$，并验证 $\\pi_i$ 在数值上（在容差范围内）与无偏置时的值相同。\n- 情况 B（在 $S_1$ 附近有力调制的反例）：使用与情况 A 相同的 $E_0$, $b_1$, $b_2$, $L$, $W$, $\\delta$, $\\sigma_y$ 和 $\\beta$。在邻近 $S_1$ 的薄带中设置 $V_b(\\xi,y) = g \\, \\xi \\, \\exp\\!\\left(-y^2/\\sigma_y^2\\right)$，在邻近 $S_2$ 的薄带中设置 $V_b = 0$。使用 $g = 5.0$。计算实际的 $\\Delta \\pi_1$ 和从 $g$ 的领头阶展开推导出的基于梯度的一阶估计 $\\Delta \\pi_1$。\n- 情况 C（在薄带中仍为零的强内部偏置，不变性压力测试）：使用与情况 A 相同的 $E_0$, $b_1$, $b_2$, $L$, $W$, $\\delta$, $\\sigma_y$ 和 $\\beta$。选择一个在两个薄带内恒为零的大振幅内部 $V_b(\\mathbf{r})$。验证计算出的 $\\pi_i$ 在指定的数值容差内与无偏置时的值匹配。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果按以下顺序和类型排列：\n- 情况 A：两个布尔值，第一个布尔值确认 $\\pi_1 + \\pi_2 = 1$（容差为 $10^{-12}$），第二个布尔值确认在仅内部有 $V_b$ 时 $\\pi_i$ 的不变性（容差为 $10^{-12}$）。\n- 情况 B：两个浮点数，实际的 $\\Delta \\pi_1$ 和基于梯度的一阶估计 $\\Delta \\pi_1$，每个都报告为 Python 浮点数。\n- 情况 C：一个布尔值，确认在强内部仅有 $V_b$ 时 $\\pi_i$ 的不变性（容差为 $10^{-12}$）。\n\n因此，最终的输出格式必须严格为：“[bool,bool,float,float,bool]”。", "solution": "该问题要求基于过渡态理论（TST），分析超动力学在双出口系统中引起的分支概率变化。我们将首先验证其理论基础，然后为指定的测试用例推导用于数值计算的表达式。我们采用无量纲单位，其中能量以 $k_\\mathrm{B} T$ 的倍数表示，因此逆热能 $\\beta = 1/(k_\\mathrm{B} T)$ 设为 $\\beta=1$。\n\n计算的基础是TST反应通量 $J_i$，它通过紧邻分界表面 $S_i$ 的一个厚度为 $\\delta$ 的薄带。问题给出了该通量的表达式：\n$$\nJ_i = \\int_{-W}^{W} \\int_{0}^{\\delta} \\exp\\!\\left(-\\beta \\left[ U|_{S_i}(y) + V_b(\\xi,y) \\right] \\right) \\, d\\xi \\, dy\n$$\n其中 $\\mathbf{r}=(x,y)$，$U|_{S_i}(y)$ 是分界表面上的物理势，$V_b(\\xi,y)$ 是薄带中的偏置势，$\\xi$ 是垂直于表面的坐标，从 $\\xi=0$（在表面上）延伸到 $\\xi=\\delta$（进入盆地内部）。到出口 $i$ 的分支概率为 $\\pi_i = J_i / \\sum_k J_k$。\n\n表面 $S_1$ 和 $S_2$ 分别位于 $x=+L$ 和 $x=-L$，其中 $y \\in [-W, W]$。这些表面上的势由 $U|_{S_1}(y) = E_0 + b_1 y^2$ 和 $U|_{S_2}(y) = E_0 + b_2 y^2$ 给出。\n\n**情况 A 和 C：分支概率的不变性**\n\n在这些情况下，超动力学偏置势 $V_b(\\mathbf{r})$ 被构造成在紧邻两个分界表面的反应物薄带内恒为零。也就是说，对于两个 $i=1$ 和 $i=2$，在所有相关的 $\\xi \\in [0, \\delta]$ 和 $y \\in [-W, W]$ 范围内，$V_b(\\xi,y) = 0$。对于此TST计算，$V_b$ 在盆地其他区域的值是无关紧要的，因为通量积分的域被限制在这些薄带内。\n\n当 $V_b(\\xi,y)=0$ 且 $\\beta=1$ 时，出口 $i$ 的通量积分为：\n$$\nJ_i^{\\text{unbiased}} = \\int_{-W}^{W} \\int_{0}^{\\delta} \\exp\\!\\left(-(E_0 + b_i y^2)\\right) \\, d\\xi \\, dy\n$$\n被积函数与 $\\xi$ 无关，因此内层积分是平凡的：\n$$\n\\int_{0}^{\\delta} d\\xi = \\delta\n$$\n这将通量简化为对 $y$ 的一维积分：\n$$\nJ_i^{\\text{unbiased}} = \\delta \\int_{-W}^{W} \\exp\\!\\left(-E_0 - b_i y^2\\right) \\, dy = \\delta e^{-E_0} \\int_{-W}^{W} e^{-b_i y^2} \\, dy\n$$\n我们定义积分 $G(b, W) = \\int_{-W}^{W} e^{-b y^2} \\, dy$。该积分将使用数值积分法计算。\n通量为 $J_1^{\\text{unbiased}} = \\delta e^{-E_0} G(b_1, W)$ 和 $J_2^{\\text{unbiased}} = \\delta e^{-E_0} G(b_2, W)$。\n\n相应的分支概率为：\n$$\n\\pi_1^{\\text{unbiased}} = \\frac{J_1^{\\text{unbiased}}}{J_1^{\\text{unbiased}} + J_2^{\\text{unbiased}}} = \\frac{\\delta e^{-E_0} G(b_1, W)}{\\delta e^{-E_0} (G(b_1, W) + G(b_2, W))} = \\frac{G(b_1, W)}{G(b_1, W) + G(b_2, W)}\n$$\n$$\n\\pi_2^{\\text{unbiased}} = \\frac{G(b_2, W)}{G(b_1, W) + G(b_2, W)}\n$$\n从这些表达式中可以清楚地看出 $\\pi_1^{\\text{unbiased}} + \\pi_2^{\\text{unbiased}} = 1$。这证实了情况 A 的第一部分。情况 A 的第二部分和整个情况 C 涉及一个在盆地内部非零但在薄带中为零的偏置势。如上所示，TST通量仅取决于薄带内的势，因此所得的分支概率必须与无偏置情况相同。这证明了超动力学的关键原理：当偏置势在分界表面上（以及在本模型中的表面前薄带中）为零时，TST分支概率得以保持。\n\n**情况 B：带有力调制的反例**\n\n这种情况展示了一个场景，其中标准的超动力学条件被巧妙地违反，导致分支概率发生改变。偏置势 $V_b$ 在分界表面 $S_1$ 本身（在 $\\xi=0$ 处）为零，但在相邻的薄带内具有非零的法向梯度。\n- 在 $S_1$ 处的薄带：$V_b(\\xi,y) = g \\xi f(y)$，其中 $f(y) = \\exp(-y^2/\\sigma_y^2)$ 且 $\\beta=1$。\n- 在 $S_2$ 处的薄带：$V_b(\\xi,y) = 0$。\n\n出口 2 的通量保持不变：$J_2^{\\text{biased}} = J_2^{\\text{unbiased}}$。\n出口 1 的通量被修改：\n$$\nJ_1^{\\text{biased}} = \\int_{-W}^{W} e^{-(E_0 + b_1 y^2)} \\left( \\int_{0}^{\\delta} e^{-g \\xi f(y)} \\, d\\xi \\right) \\, dy\n$$\n对 $\\xi$ 的内层积分可以解析计算：\n$$\n\\int_{0}^{\\delta} e^{-g \\xi f(y)} \\, d\\xi = \\left[ \\frac{e^{-g \\xi f(y)}}{-g f(y)} \\right]_{\\xi=0}^{\\xi=\\delta} = \\frac{e^{-g \\delta f(y)} - 1}{-g f(y)} = \\frac{1 - e^{-g \\delta f(y)}}{g f(y)}\n$$\n在外部数值积分过程中，对每个 $y$ 值都需对此表达式进行数值评估。为保证在 $g f(y) \\to 0$ 时的稳定性，我们注意到其极限为 $\\delta$。\n\n有偏置的分支概率为 $\\pi_1^{\\text{biased}} = J_1^{\\text{biased}} / (J_1^{\\text{biased}} + J_2^{\\text{unbiased}})$，其变化量为 $\\Delta \\pi_1 = \\pi_1^{\\text{biased}} - \\pi_1^{\\text{unbiased}}$。\n\n**$\\Delta \\pi_1$ 的一阶估计**\n\n我们被要求基于对小 $g$ 的内层积分展开，来推导 $\\Delta \\pi_1$ 的一阶估计。问题提供了以下近似：\n$$\n\\int_0^\\delta e^{-g \\xi f(y)} \\, d\\xi \\approx \\delta - \\frac{1}{2} g \\delta^2 f(y)\n$$\n使用这个近似，近似通量 $J_1^{\\text{approx}}$ 为：\n$$\nJ_1^{\\text{approx}} = \\int_{-W}^{W} e^{-(E_0+b_1 y^2)} \\left( \\delta - \\frac{1}{2} g \\delta^2 f(y) \\right) dy\n$$\n$$\nJ_1^{\\text{approx}} = \\delta \\int_{-W}^{W} e^{-(E_0+b_1 y^2)} dy - \\frac{1}{2} g \\delta^2 \\int_{-W}^{W} e^{-(E_0+b_1 y^2)} f(y) \\, dy\n$$\n第一项恰好是 $J_1^{\\text{unbiased}}$。第二项是一阶修正项 $\\Delta J_1$：\n$$\n\\Delta J_1 = -\\frac{1}{2} g \\delta^2 e^{-E_0} \\int_{-W}^{W} e^{-b_1 y^2} e^{-y^2/\\sigma_y^2} \\, dy = -\\frac{1}{2} g \\delta^2 e^{-E_0} \\int_{-W}^{W} e^{-(b_1 + 1/\\sigma_y^2)y^2} \\, dy\n$$\n新的分支概率为 $\\pi_1^{\\text{approx}} = (J_1^{\\text{unbiased}} + \\Delta J_1) / (J_1^{\\text{unbiased}} + \\Delta J_1 + J_2^{\\text{unbiased}})$。\n变化量为 $\\Delta \\pi_1 \\approx \\pi_1^{\\text{approx}} - \\pi_1^{\\text{unbiased}}$。对于小的 $\\Delta J_1$，我们可以使用一阶展开：\n$$\n\\Delta \\pi_1 \\approx \\frac{\\partial \\pi_1}{\\partial J_1} \\Delta J_1 = \\frac{\\partial}{\\partial J_1} \\left( \\frac{J_1}{J_1+J_2} \\right) \\Delta J_1 = \\frac{(J_1+J_2) - J_1}{(J_1+J_2)^2} \\Delta J_1 = \\frac{J_2}{(J_1+J_2)^2} \\Delta J_1\n$$\n在无偏置状态下对此进行评估，得到估计值：\n$$\n\\Delta \\pi_1^{\\text{est}} = \\frac{J_2^{\\text{unbiased}}}{(J_1^{\\text{unbiased}} + J_2^{\\text{unbiased}})^2} \\Delta J_1\n$$\n这个表达式将与精确计算一起进行数值实现。对 $y$ 的积分将使用数值积分法执行。\n\n以下程序为指定的测试套件实现了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the hyperdynamics branching probability problem.\n    \"\"\"\n    # Define parameters for the test cases as a dictionary.\n    params = {\n        'E0': 6.0,\n        'b1': 4.0,\n        'b2': 3.0,\n        'L': 1.0,\n        'W': 2.0,\n        'delta': 0.05,\n        'sigma_y': 0.4,\n        'beta': 1.0,\n        'g': 5.0,\n        'tol': 1e-12,\n    }\n\n    def calculate_flux(b_val, bias_type='none'):\n        \"\"\"\n        Computes the reactive flux J for a given channel.\n\n        Args:\n            b_val (float): The potential curvature parameter b_i for the channel.\n            bias_type (str): 'none' for unbiased or 'force_mod' for force modulation bias.\n\n        Returns:\n            float: The calculated reactive flux J_i.\n        \"\"\"\n        E0 = params['E0']\n        beta = params['beta']\n        W = params['W']\n        delta = params['delta']\n\n        U_on_S = lambda y: E0 + b_val * y**2\n\n        # Inner integral over the strip thickness xi.\n        # This is done analytically.\n        if bias_type == 'force_mod':\n            g = params['g']\n            sigma_y = params['sigma_y']\n            \n            def inner_integral_val(y):\n                fy = np.exp(-y**2 / sigma_y**2)\n                arg_no_delta = beta * g * fy\n                arg_with_delta = arg_no_delta * delta\n                \n                # Use a threshold to switch to the limit to avoid 0/0.\n                # The limit of (1-exp(-ax))/a as a->0 is x.\n                # Here, a is arg_no_delta and x is delta.\n                if np.abs(arg_no_delta)  1e-9:\n                    return delta\n                else:\n                    # Use np.expm1 for better numerical precision with small arguments.\n                    # -expm1(-x) is equivalent to 1-exp(-x).\n                    return -np.expm1(-arg_with_delta) / arg_no_delta\n\n        elif bias_type == 'none':\n            def inner_integral_val(y):\n                return delta\n        else:\n            raise ValueError(\"Unknown bias type specified.\")\n            \n        # The full integrand for the outer y-integral.\n        def integrand(y):\n            return np.exp(-beta * U_on_S(y)) * inner_integral_val(y)\n\n        # Perform numerical quadrature over y.\n        result, _ = integrate.quad(integrand, -W, W)\n        return result\n\n    # --- Case A (Invariance Check for V_b=0 in strips) ---\n    J1_unbiased = calculate_flux(params['b1'], bias_type='none')\n    J2_unbiased = calculate_flux(params['b2'], bias_type='none')\n    \n    J_tot_unbiased = J1_unbiased + J2_unbiased\n    pi1_unbiased = J1_unbiased / J_tot_unbiased\n    pi2_unbiased = J2_unbiased / J_tot_unbiased\n    \n    # 1. Verify sum of probabilities is 1.\n    result_A1 = bool(np.isclose(pi1_unbiased + pi2_unbiased, 1.0, atol=params['tol']))\n    \n    # 2. Verify invariance for an interior-only V_b.\n    # The calculation is identical since V_b=0 in the strips.\n    J1_interior_vb = calculate_flux(params['b1'], bias_type='none')\n    J_tot_interior_vb = J1_interior_vb + J2_unbiased\n    pi1_interior_vb = J1_interior_vb / J_tot_interior_vb\n    result_A2 = bool(np.isclose(pi1_unbiased, pi1_interior_vb, atol=params['tol']))\n\n    # --- Case B (Counterexample) ---\n    # Use unbiased results from Case A.\n    J1_biased = calculate_flux(params['b1'], bias_type='force_mod')\n    J2_biased = J2_unbiased  # Vb is zero in strip 2.\n    \n    J_tot_biased = J1_biased + J2_biased\n    pi1_biased = J1_biased / J_tot_biased\n    \n    # 3. Compute the actual change in branching probability.\n    actual_delta_pi1 = pi1_biased - pi1_unbiased\n    \n    # 4. Compute the first-order gradient-based estimate for the change.\n    beta = params['beta']\n    g = params['g']\n    delta = params['delta']\n    E0 = params['E0']\n    W = params['W']\n    b1 = params['b1']\n    sigma_y = params['sigma_y']\n    \n    def integrand_delta_J1(y):\n        return np.exp(-(b1 + 1.0/sigma_y**2) * y**2)\n    \n    integral_part, _ = integrate.quad(integrand_delta_J1, -W, W)\n    \n    delta_J1 = -0.5 * beta * g * delta**2 * np.exp(-beta * E0) * integral_part\n\n    estimated_delta_pi1 = (delta_J1 * J2_unbiased) / (J_tot_unbiased**2)\n    \n    # --- Case C (Strong Interior Bias, Invariance Stress Test) ---\n    # The setup is mathematically identical to the second part of Case A.\n    # The TST flux calculation is insensitive to any Vb outside the strips.\n    J1_case_c = calculate_flux(params['b1'], bias_type='none')\n    J_tot_case_c = J1_case_c + J2_unbiased\n    pi1_case_c = J1_case_c / J_tot_case_c\n    \n    # 5. Verify invariance.\n    result_C = bool(np.isclose(pi1_unbiased, pi1_case_c, atol=params['tol']))\n    \n    # --- Final Output ---\n    final_results = [\n        result_A1,\n        result_A2,\n        actual_delta_pi1,\n        estimated_delta_pi1,\n        result_C,\n    ]\n    \n    # Print the results in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3457997"}]}