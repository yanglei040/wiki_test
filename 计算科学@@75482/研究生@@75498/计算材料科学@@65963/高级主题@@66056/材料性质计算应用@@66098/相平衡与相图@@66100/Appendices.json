{"hands_on_practices": [{"introduction": "在计算材料科学中，理解和预测相稳定性是设计新材料的基石。在绝对零度（$T=0$）下，系统的热力学稳定性完全由其能量决定。这个实践练习将指导你通过一个基本但极其强大的几何方法——构建凸包（convex hull）——来确定二元合金的稳定相和相区[@problem_id:3474911]。通过处理从第一性原理计算中获得的形成能数据，你将亲身体验如何将离散的原子构型能量点转化为连续的相图信息，这是连接量子力学计算和宏观热力学性质的关键一步。", "problem": "给定从第一性原理电子结构计算得到的有序二元化合物在零温度下的形成能。对于一个二元体系，组分由组分 $B$ 的原子分数表示，记作 $x \\in [0,1]$。在组分为 $x$ 时，一个有序构型的每个原子的形成能记作 $E_f(x)$，单位为每个原子的电子伏特。在零温度（$T = 0$）下，热力学稳定性由能量最小化决定。一个由组分为 $x_1$ 和 $x_2$ 的两相组成的混合物可以实现任何总组分 $x = \\lambda x_1 + (1-\\lambda)x_2$（其中 $0 \\le \\lambda \\le 1$），其能量为 $E_{\\text{mix}}(x) = \\lambda E_f(x_1) + (1-\\lambda) E_f(x_2)$。这里假设在两相混合物中，相是理想分离的，且相间没有相互作用能。一个组分为 $x$ 的单相有序化合物是稳定的，当且仅当它位于点集 $\\{(x_i, E_f(x_i))\\}$ 的下凸包络线上，这意味着 $E_f(x)$ 的值无法通过分解成其他相的混合物来降低。下凸包络线是在二维平面中的下凸包，其中水平轴是 $x$，垂直轴是 $E_f$。\n\n从这些热力学和几何原理出发，为每个提供的测试集构建 $E_f$ 相对于 $x$ 的下凸包。然后，为每个凸包确定：\n- 位于组分 $x_i$ 处的断点（凸包顶点）及其能量 $E_f(x_i)$，两者均以其适当的单位表示（$x$ 作为组分 $B$ 的分数是无量纲的，能量必须以每个原子的电子伏特表示）。\n- 内部稳定的有序化合物（即严格在 $0  x  1$ 范围内的顶点）。\n- 连续凸包顶点之间的两相组分区间 $(x_{\\text{low}}, x_{\\text{high}})$，其中该开区间内的任何组分都会分解为两个端点相。将每个区间报告为一对浮点数 $[x_{\\text{low}}, x_{\\text{high}}]$。\n- 对于连接连续凸包顶点 $(x_i, E_f(x_i))$ 和 $(x_{i+1}, E_f(x_{i+1}))$ 的每个两相面（连接线），计算：\n  1. 面的斜率 $m = \\dfrac{E_f(x_{i+1}) - E_f(x_i)}{x_{i+1} - x_i}$，以每个原子每个组分分数的电子伏特为单位报告。\n  2. 在 $(x, E_f)$ 平面中，面的单位法向量 $\\hat{\\boldsymbol{n}}$，其方向应使其能量分量为负（即 $\\hat{\\boldsymbol{n}}$ 的第二个分量  0）。对于边向量 $\\boldsymbol{v} = (x_{i+1} - x_i, E_f(x_{i+1}) - E_f(x_i))$ 且 $x_{i+1}  x_i$，将（非归一化的）法向量定义为 $\\boldsymbol{n} = (E_f(x_{i+1}) - E_f(x_i), -(x_{i+1} - x_i))$，并通过 $\\hat{\\boldsymbol{n}} = \\dfrac{\\boldsymbol{n}}{\\lVert \\boldsymbol{n} \\rVert}$ 获得单位法向量，其中 $\\lVert \\cdot \\rVert$ 是欧几里得范数。\n\n仅使用由凸性和上述定义所隐含的基本几何操作；不要假设任何专门的凸包例程。如果数据集包含重复的组分，您必须保留相同组分中能量最低的一个。如果数据中不存在 $x=0$ 和 $x=1$，您必须包含纯元素端点，即 $x=0$ 和 $x=1$ 时 $E_f(0)=0$ 和 $E_f(1)=0$（单位为每个原子的电子伏特），因为形成能是相对于纯元素定义的。\n\n您的程序必须为每个测试用例实现以下内容：\n1. 构建点 $(x_i, E_f(x_i))$ 的下凸包。\n2. 返回：\n   - 凸包上按升序排列的断点组分列表 $[x_0, x_1, \\dots, x_k]$。\n   - 与断点组分对齐的断点能量列表 $[E_f(x_0), E_f(x_1), \\dots, E_f(x_k)]$，单位为每个原子的电子伏特。\n   - 满足 $0  x_j  1$ 的内部稳定有序化合物列表 $[x_j]$。\n   - 两相区间列表 $[[x_0, x_1], [x_1, x_2], \\dots, [x_{k-1}, x_k]]$。\n   - 单位面法向量列表 $[[n_x^{(0)}, n_E^{(0)}], \\dots, [n_x^{(k-1)}, n_E^{(k-1)}]]$。\n   - 面斜率列表 $[m_0, m_1, \\dots, m_{k-1}]$，单位为每个原子每个组分分数的电子伏特。\n\n物理单位：\n- 能量必须以每个原子的电子伏特报告。\n- 斜率必须以每个原子每个组分分数的电子伏特报告。\n- 组分是 $[0,1]$ 范围内的无量纲分数。\n\n不涉及角度单位。不应使用百分比；组分必须是小数分数。\n\n测试套件：\n- 案例A（正常路径，多个内部候选）：\n  - $x = [\\,0.0,\\,0.25,\\,0.33,\\,0.5,\\,0.66,\\,0.75,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.08,\\,-0.15,\\,-0.12,\\,-0.14,\\,-0.09,\\,0.0\\,]$ 单位为每个原子的电子伏特\n- 案例B（边界条件，一个点在连接线上）：\n  - $x = [\\,0.0,\\,0.4,\\,0.6,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.05,\\,-0.075,\\,0.0\\,]$ 单位为每个原子的电子伏特\n- 案例C（重复组分，保留最低能量）：\n  - $x = [\\,0.0,\\,0.5,\\,0.5,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.10,\\,-0.12,\\,0.0\\,]$ 单位为每个原子的电子伏特\n- 案例D（中心深最小值，两端附近对称的浅最小值）：\n  - $x = [\\,0.0,\\,0.2,\\,0.5,\\,0.8,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.02,\\,-0.14,\\,-0.02,\\,0.0\\,]$ 单位为每个原子的电子伏特\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果应是包含上述指定顺序的六个项目的列表。整个输出应以无空格的 JavaScript 对象表示法 (JSON) 表示，例如：\n\"[caseA_result,caseB_result,caseC_result,caseD_result]\"。", "solution": "该问题要求为代表零温度 $T=0$ 下二元体系的形成能 $E_f$ 与组分 $x$ 关系的一组点构建下凸包。需要从这个凸包中提取几个热力学和几何属性。解决方案基于热力学稳定性和计算几何的基本原理。\n\n在 $T=0$ 时，体系的吉布斯自由能等于其内能。对于二元合金，在给定总组分下的稳定状态是使每个原子的总能量最小化的状态。一个组分为 $x_i$、形成能为 $E_f(x_i)$ 的单相有序化合物是热力学稳定的，当且仅当其对应的点 $(x_i, E_f(x_i))$ 位于所有可能构型 $\\{ (x_j, E_f(x_j)) \\}$ 的下凸包络线上。任何位于凸包上两个稳定化合物（例如在 $x_i$ 和 $x_{i+1}$ 处）之间的组分 $x$，都将分解为这两种化合物的两相混合物。这种混合物的能量位于连接点 $(x_i, E_f(x_i))$ 和 $(x_{i+1}, E_f(x_{i+1}))$ 的直线段或连接线上。这种几何构造被称为形成能的凸包。\n\n解决此问题的算法分三个阶段实现：数据预处理、下凸包构建以及物理量提取。\n\n**步骤 1：数据预处理**\n\n首先，必须为寻找凸包的算法准备输入数据，这些数据由组分 $x$ 和形成能 $E_f$ 组成。\n1.  **重复的组分**：问题指出，如果同一组分存在多个能量值，则只有能量最低的点在热力学上是相关的。该组分下的所有其他点相对于此点都是亚稳或不稳定的。我们通过使用以组分为键的字典或映射数据结构来强制执行此规则，确保每个唯一组分只保留最低能量。\n2.  **端点**：形成能 $E_f$ 是相对于纯元素定义的。根据定义，纯组分的形成能为零。因此，纯组分 A 的点 $(0, 0)$ 和纯组分 B 的点 $(1, 0)$ 必须包含在我们的点集中。我们显式地添加或更新这些点，以确保它们在 $E_f=0$ 处存在。\n3.  **排序**：然后根据组分 $x$ 的升序对唯一的点集进行排序。这是用于构建凸包的 Monotone Chain 算法的一个先决条件。设排序后的点为 $p_0, p_1, \\dots, p_{N-1}$，其中 $p_i = (x_i, E_f(x_i))$。\n\n**步骤 2：下凸包构建**\n\n我们将实现 Monotone Chain 算法（也称为 Andrew 算法），并对其进行调整以仅寻找下凸包。该算法遍历排序后的点并增量式地构建凸包。算法的核心是方向测试，该测试确定三个点的序列是构成“左转”还是“右转”。此测试使用二维叉积来执行。\n\n对于三个点 $p_1=(x_1, y_1)$, $p_2=(x_2, y_2)$ 和 $p_3=(x_3, y_3)$，向量 $\\vec{p_1 p_2}$ 和 $\\vec{p_1 p_3}$ 的叉积的‘z’分量由下式给出：\n$$ \\text{cross\\_product}(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1) $$\n此值的符号表示方向：\n-    0：逆时针，或从 $\\vec{p_1 p_2}$ 到 $\\vec{p_1 p_3}$ 的“左转”。\n-    0：顺时针，或“右转”。\n-   = 0：点共线。\n\n为了构建下凸包，我们遍历排序后的点，并维护一个栈 `lower_hull`，代表到目前为止找到的凸包顶点。对于每个新点 $p_i$，我们检查栈顶的两个点（`lower_hull[-2]`、`lower_hull[-1]`）和新点 $p_i$ 形成的方向。下凸包必须由一系列“左转”（或直线）组成。如果添加 $p_i$ 会产生一个“右转”或一条直线延续，这意味着栈上的最后一个点 `lower_hull[-1]` 不属于`严格`凸包，并且位于新线段的上方或线上。因此，必须将其从栈中弹出。重复此检查，直到序列形成一个左转。\n\n步骤如下：\n- 初始化一个空列表 `lower_hull`。\n- 对于排序后点列表中的每个点 $p_i$：\n  - 当 `lower_hull` 至少包含两个点且 $\\text{cross\\_product}(\\text{lower\\_hull}[-2], \\text{lower\\_hull}[-1], p_i) \\le 0$ 时：\n    - 从 `lower_hull` 中弹出最后一个点。\n  - 将 $p_i$ 追加到 `lower_hull`。\n\n条件 $\\le 0$ 确保我们弹出形成右转或共线的点，从而正确识别严格凸包的顶点，这些顶点代表稳定的化合物。最终的 `lower_hull` 列表按组分递增的顺序包含凸包顶点（断点）。\n\n**步骤 3：物理量提取**\n\n一旦确定了凸包顶点的列表 $\\{ (x_0, E_f(x_0)), (x_1, E_f(x_1)), \\dots, (x_k, E_f(x_k)) \\}$，我们就可以推导出所需的属性。\n\n1.  **断点组分和能量**：这些可以直接通过从最终 `lower_hull` 列表中的点分离出 $x$ 和 $E_f$ 坐标来获得。\n2.  **内部稳定有序化合物**：这些是组分严格介于 $0$ 和 $1$ 之间的凸包顶点。我们遍历凸包顶点并收集所有满足 $0  x_i  1$ 的 $x_i$。\n3.  **两相区间**：凸包的每条边都代表一个两相区域。对于每对连续的顶点 $(x_i, E_f(x_i))$ 和 $(x_{i+1}, E_f(x_{i+1}))$，对应的两相区间是 $[x_i, x_{i+1}]$。\n4.  **面斜率和法向量**：对于每个这样的连续顶点对，我们计算连接它们的面（连接线）的属性。设边向量为 $\\boldsymbol{v} = (x_{i+1} - x_i, E_f(x_{i+1}) - E_f(x_i)) = (\\Delta x, \\Delta E)$。\n    -   **斜率 ($m$)**：连接线的斜率代表两相混合物中组分的共同化学势。\n        $$ m = \\frac{\\Delta E}{\\Delta x} = \\frac{E_f(x_{i+1}) - E_f(x_i)}{x_{i+1} - x_i} $$\n    -   **单位法向量 ($\\hat{\\boldsymbol{n}}$)**：问题提供了法向量的公式 $\\boldsymbol{n} = (\\Delta E, -\\Delta x)$，这是通过将边向量 $\\boldsymbol{v} = (\\Delta x, \\Delta E)$ 旋转 $-90^\\circ$ 并交换分量得到的。由于凸包点按组分排序，$\\Delta x = x_{i+1} - x_i  0$。因此，$\\boldsymbol{n}$ 的第二个分量 $-\\Delta x$ 始终为负，满足指定的方向要求。单位法向量 $\\hat{\\boldsymbol{n}}$ 是通过将 $\\boldsymbol{n}$ 除以其欧几里得范数 $\\lVert \\boldsymbol{n} \\rVert$ 得到的：\n        $$ \\hat{\\boldsymbol{n}} = \\frac{\\boldsymbol{n}}{\\lVert \\boldsymbol{n} \\rVert} = \\frac{(\\Delta E, -\\Delta x)}{\\sqrt{(\\Delta E)^2 + (-\\Delta x)^2}} $$\n        该向量的分量 $[n_x, n_E]$ 将被附加到每个面的结果中。\n\n这个综合过程结合了数据清理、经典的几何算法和基于物理的计算，为问题提供了稳健且正确的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": [0.0, 0.25, 0.33, 0.5, 0.66, 0.75, 1.0],\n            \"E_f\": [0.0, -0.08, -0.15, -0.12, -0.14, -0.09, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.4, 0.6, 1.0],\n            \"E_f\": [0.0, -0.05, -0.075, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.5, 0.5, 1.0],\n            \"E_f\": [0.0, -0.10, -0.12, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.2, 0.5, 0.8, 1.0],\n            \"E_f\": [0.0, -0.02, -0.14, -0.02, 0.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = compute_phase_diagram(case[\"x\"], case[\"E_f\"])\n        results.append(json.dumps(case_result, separators=(',', ':')))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_phase_diagram(compositions, energies):\n    \"\"\"\n    Computes the lower convex hull and derives thermodynamic properties for a single binary system.\n\n    Args:\n        compositions (list[float]): List of atomic fractions of component B.\n        energies (list[float]): List of formation energies in eV/atom.\n\n    Returns:\n        list: A list containing six lists:\n              1. Breakpoint compositions on the hull.\n              2. Breakpoint energies on the hull.\n              3. Compositions of interior stable compounds.\n              4. Two-phase composition intervals.\n              5. Unit normal vectors for each facet.\n              6. Slopes for each facet.\n    \"\"\"\n    \n    # Step 1: Data Preprocessing\n    points_map = {}\n    for x, e in zip(compositions, energies):\n        if x in points_map:\n            points_map[x] = min(points_map[x], e)\n        else:\n            points_map[x] = e\n            \n    # Ensure endpoints are present with Ef=0\n    points_map[0.0] = min(points_map.get(0.0, 0.0), 0.0)\n    points_map[1.0] = min(points_map.get(1.0, 0.0), 0.0)\n\n    # Sort points by composition\n    sorted_points = sorted(points_map.items())\n\n    # Step 2: Lower Convex Hull Construction (Monotone Chain)\n    def cross_product(p1, p2, p3):\n        # (x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    lower_hull = []\n    # Using a small tolerance for floating point comparisons\n    epsilon = 1e-9\n\n    for p in sorted_points:\n        # Pop points that create a right turn or are collinear. For a lower hull, we pop non-left turns.\n        while len(lower_hull) >= 2 and cross_product(lower_hull[-2], lower_hull[-1], p) = epsilon:\n            lower_hull.pop()\n        lower_hull.append(p)\n\n    # Step 3: Extraction of Physical Quantities\n    hull_x = [p[0] for p in lower_hull]\n    hull_e = [p[1] for p in lower_hull]\n\n    interior_stable_x = [x for x in hull_x if 0  x  1]\n    \n    two_phase_intervals = []\n    facet_normals = []\n    facet_slopes = []\n\n    for i in range(len(lower_hull) - 1):\n        p1 = lower_hull[i]\n        p2 = lower_hull[i+1]\n        \n        # Two-phase interval\n        two_phase_intervals.append([p1[0], p2[0]])\n\n        # Facet slope and normal\n        dx = p2[0] - p1[0]\n        de = p2[1] - p1[1]\n\n        if abs(dx)  epsilon: # Should not happen with pre-processing\n            continue\n            \n        # Slope\n        slope = de / dx\n        facet_slopes.append(slope)\n\n        # Normal vector n = (dE, -dx)\n        # The second component, -dx, is guaranteed negative since dx > 0\n        norm_magnitude = np.sqrt(de**2 + (-dx)**2)\n        if norm_magnitude  epsilon:\n            unit_normal = [0.0, 0.0] # Should not happen for distinct points\n        else:\n            unit_normal = [de / norm_magnitude, -dx / norm_magnitude]\n        facet_normals.append(unit_normal)\n        \n    return [hull_x, hull_e, interior_stable_x, two_phase_intervals, facet_normals, facet_slopes]\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3474911"}, {"introduction": "当温度升高时，熵的贡献变得不可忽视，系统的稳定性由最小化吉布斯自由能（Gibbs free energy）决定。公切面（common tangent plane）构造是零温下凸包方法的直接推广，它为确定有限温度下多相共存的平衡成分提供了通用的图形和计算框架。在这个练习中，你将通过约束优化算法，在给定的自由能模型下寻找二元和三元系统的平衡相成分，即连接线（tie-line）的端点[@problem_id:3474881]。这项实践是CALPHAD方法的核心，对于计算和理解真实温度下的相图至关重要。", "problem": "您的任务是实现一个完整的、可运行的程序，在计算材料科学中相平衡和相图的框架下，使用约束优化方法计算多组分吉布斯能量面上的双相连接线并验证公切面。该程序必须从第一性原理和经过充分检验的模型出发，并且除了这些基本原理外，不得依赖任何快捷公式。所有结果必须以无量纲的摩尔分数表示，并按照下文指定的格式，在单个聚合的输出行中返回。\n\n基本原理和设定：在恒定温度 $T$ 和压力 $P$ 下，混合物中相的平衡取决于总吉布斯自由能的最小化和化学势的相等。对于一个组分由索引 $i$ 标记、摩尔分数为 $\\{x_i\\}$（满足 $\\sum_i x_i = 1$ 和 $x_i \\ge 0$）的混合物，吉布斯自由能面 $G(T,P,\\{x_i\\})$ 是在恒定 $T$ 和 $P$ 下组分的函数。当一个斜率向量等于化学势向量的平面在组分 $\\mathbf{x}^{\\alpha}$ 和 $\\mathbf{x}^{\\beta}$ 两点上接触能量面，并且在该两点所张成的凸包内，该平面不位于 $G(T,P,\\{x_i\\})$ 之上时，则存在公切面。相平衡条件源于共存相之间化学势的相等和质量平衡。\n\n使用的定义：\n- 在恒定 $T$ 和 $P$ 下，二元规则溶液的混合吉布斯自由能模型为\n$$\nG_{\\text{bin}}(x;T) = RT\\left[x\\ln x + (1-x)\\ln(1-x)\\right] + \\Omega x(1-x),\n$$\n其中 $x$ 是组分A的摩尔分数，$R$ 是普适气体常数，$T$ 是温度，$\\Omega$ 是二元相互作用参数（假定与组分无关）。纯组分贡献的基线被吸收到一个恒定的参考值中，不影响在恒定 $T$ 和 $P$ 下的相分离。\n- 在恒定 $T$ 和 $P$ 下，三元规则溶液的混合吉布斯自由能模型为\n$$\nG_{\\text{ter}}(\\mathbf{x};T) = RT\\left[\\sum_{i=1}^{3} x_i \\ln x_i\\right] + \\Omega_{12} x_1 x_2 + \\Omega_{23} x_2 x_3 + \\Omega_{13} x_1 x_3,\n$$\n其中 $\\mathbf{x}=(x_1,x_2,x_3)$，$\\sum_i x_i=1$，$x_i\\ge 0$，$\\Omega_{ij}$ 是对相互作用参数。\n- 化学势 $\\mu_i$ 定义为在恒定 $T$、$P$ 和其他 $n_j$ 条件下，吉布斯能量对摩尔数 $n_i$ 的偏导数。在总摩尔数固定的组分空间中，这对应于在单形约束下 $G(T,P,\\{x_i\\})$ 相对于 $x_i$ 的梯度。\n\n公切面准则：在组分 $\\mathbf{x}^{\\alpha}$ 和 $\\mathbf{x}^{\\beta}$ 处两相共存，意味着存在一个平面，其斜率向量等于共同的化学势向量 $\\boldsymbol{\\mu}$，使得\n$$\nG(T,P,\\mathbf{x}^{\\alpha}) - \\boldsymbol{\\mu}\\cdot \\mathbf{x}^{\\alpha} = G(T,P,\\mathbf{x}^{\\beta}) - \\boldsymbol{\\mu}\\cdot \\mathbf{x}^{\\beta}\n$$\n并且 $\\boldsymbol{\\mu}$ 等于 $G$ 在这两点的梯度，同时该平面在 $\\mathbf{x}^{\\alpha}$ 和 $\\mathbf{x}^{\\beta}$ 之间的凸组合线段上位于或低于能量面。对于总组分 $\\mathbf{x}^{0}$，质量平衡要求\n$$\n\\mathbf{x}^{0} = \\lambda \\,\\mathbf{x}^{\\alpha} + (1-\\lambda)\\,\\mathbf{x}^{\\beta},\n$$\n其中 $0 \\le \\lambda \\le 1$ 是相 $\\alpha$ 的相分数。\n\n计算任务：实现一个约束优化算法，对于给定的总组分和吉布斯能量模型，找出两个相组分和一个相分数，以在质量平衡和单形约束下最小化总吉布斯能量。该算法必须：\n- 最小化\n$$\nF = \\lambda \\, G(T,P,\\mathbf{x}^{\\alpha}) + (1-\\lambda)\\, G(T,P,\\mathbf{x}^{\\beta})\n$$\n约束条件为 $0 \\le \\lambda \\le 1$，$\\mathbf{x}^{\\alpha}, \\mathbf{x}^{\\beta} \\in \\Delta$，其中 $\\Delta$ 是组分单形（$x_i \\ge 0$，$\\sum_i x_i = 1$），以及 $\\mathbf{x}^{0} = \\lambda \\,\\mathbf{x}^{\\alpha} + (1-\\lambda)\\, \\mathbf{x}^{\\beta}$。\n- 通过检查最小化的 $F$ 相对于在 $\\mathbf{x}^{0}$ 处的单相吉布斯能量是否有严格减小（即 $F  G(T,P,\\mathbf{x}^{0})$），来隐式验证公切面的存在。如果在数值公差范围内没有实现能量降低，则返回单相组分（$\\mathbf{x}^{\\alpha} = \\mathbf{x}^{\\beta} = \\mathbf{x}^{0}$）。\n- 为每个测试用例返回连接线端点 $(\\mathbf{x}^{\\alpha}, \\mathbf{x}^{\\beta})$。对于二元体系，报告 $[x^{\\alpha}, x^{\\beta}]$。对于三元体系，报告 $[x_1^{\\alpha}, x_2^{\\alpha}, x_3^{\\alpha}, x_1^{\\beta}, x_2^{\\beta}, x_3^{\\beta}]$。\n\n物理单位和数值约定：\n- 使用普适气体常数 $R = 8.314$，单位为 $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。\n- 温度 $T$ 必须以开尔文为单位指定。\n- 相互作用参数 $\\Omega$ 和 $\\Omega_{ij}$ 必须以 $\\mathrm{J\\,mol^{-1}}$ 为单位指定。\n- 所有输出均为无量纲的摩尔分数；将每个报告的摩尔分数四舍五入到 $6$ 位小数。\n\n本任务不涉及角度单位。不允许使用百分比；请使用小数形式的摩尔分数。\n\n测试套件：实现您的程序，为以下四个参数集计算结果，每个参数集代表问题的不同方面，包括一般情况、无相分离情况、多元内部组分情况和近边界组分情况。\n\n- 情况 $1$（二元，存在互溶间隙）：\n  - $T = 298$ $\\mathrm{K}$,\n  - $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$,\n  - $\\Omega = 7000$ $\\mathrm{J\\,mol^{-1}}$,\n  - 总组分 $x^{0} = 0.40$。\n- 情况 $2$（二元，无相分离）：\n  - $T = 298$ $\\mathrm{K}$,\n  - $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$,\n  - $\\Omega = 500$ $\\mathrm{J\\,mol^{-1}}$,\n  - 总组分 $x^{0} = 0.40$。\n- 情况 $3$（三元，具有强相互作用的内部组分）：\n  - $T = 900$ $\\mathrm{K}$,\n  - $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$,\n  - $\\Omega_{12} = 20000$ $\\mathrm{J\\,mol^{-1}}$, $\\Omega_{23} = 15000$ $\\mathrm{J\\,mol^{-1}}$, $\\Omega_{13} = 18000$ $\\mathrm{J\\,mol^{-1}}$,\n  - 总组分 $\\mathbf{x}^{0} = (0.33,\\,0.33,\\,0.34)$。\n- 情况 $4$（三元，具有弱相互作用的近边界组分）：\n  - $T = 900$ $\\mathrm{K}$,\n  - $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$,\n  - $\\Omega_{12} = 3000$ $\\mathrm{J\\,mol^{-1}}$, $\\Omega_{23} = 3000$ $\\mathrm{J\\,mol^{-1}}$, $\\Omega_{13} = 3000$ $\\mathrm{J\\,mol^{-1}}$,\n  - 总组分 $\\mathbf{x}^{0} = (0.95,\\,0.04,\\,0.01)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果格式化为一个不含空格的、四舍五入后的摩尔分数列表。例如，对于两个二元和两个三元情况，输出应类似于\n$[ [x^{\\alpha}_1,x^{\\beta}_1], [x^{\\alpha}_2,x^{\\beta}_2], [x_1^{\\alpha},x_2^{\\alpha},x_3^{\\alpha},x_1^{\\beta},x_2^{\\beta},x_3^{\\beta}], [x_1^{\\alpha},x_2^{\\alpha},x_3^{\\alpha},x_1^{\\beta},x_2^{\\beta},x_3^{\\beta}] ]$\n但不含空格。您的程序必须严格只打印这一行。每个摩尔分数必须四舍五入到 $6$ 位小数。", "solution": "所提出的问题是有效的。这是计算热力学中一个明确定义的任务，其基础是通过吉布斯自由能最小化来确定相平衡的基本原理。所提供的模型、参数和目标足够清晰且具有科学合理性，能够得出一个严谨、唯一的解。该问题要求实现一个约束优化算法，以在恒定温度 $T$ 和压力 $P$ 下，为二元和三元规则溶液找到平衡相的组分（连接线端点）。\n\n该方法的核心是解决一个约束非线性优化问题。一个总组分为 $\\mathbf{x}^{0}$ 的潜在双相体系的平衡状态，是通过最小化混合物的总吉布斯自由能 $F$ 来找到的。该混合物被假定由两个相 $\\alpha$ 和 $\\beta$ 组成，其组分分别为 $\\mathbf{x}^{\\alpha}$ 和 $\\mathbf{x}^{\\beta}$，相 $\\alpha$ 的相分数为 $\\lambda$。因此，总吉布斯自由能由各相吉布斯能量的加权平均值给出：\n$$\nF(\\lambda, \\mathbf{x}^{\\alpha}, \\mathbf{x}^{\\beta}) = \\lambda G(T,P,\\mathbf{x}^{\\alpha}) + (1-\\lambda)G(T,P,\\mathbf{x}^{\\beta})\n$$\n混合吉布斯自由能 $G(T,P,\\mathbf{x})$ 由二元和三元体系的规则溶液模型提供。对于摩尔分数为 $x$ 的二元体系：\n$$\nG_{\\text{bin}}(x;T) = RT\\left[x\\ln x + (1-x)\\ln(1-x)\\right] + \\Omega x(1-x)\n$$\n对于摩尔分数向量为 $\\mathbf{x}=(x_1,x_2,x_3)$ 的三元体系：\n$$\nG_{\\text{ter}}(\\mathbf{x};T) = RT\\left[\\sum_{i=1}^{3} x_i \\ln x_i\\right] + \\Omega_{12} x_1 x_2 + \\Omega_{23} x_2 x_3 + \\Omega_{13} x_1 x_3\n$$\n此最小化是针对相分数 $\\lambda$ 和组分 $\\mathbf{x}^{\\alpha}$、$\\mathbf{x}^{\\beta}$ 进行的，并受以下几个约束：\n1. 相分数 $\\lambda$ 必须在 $0$ 和 $1$ 之间：$0 \\le \\lambda \\le 1$。\n2. 相组分必须物理上有效，即它们必须位于组分单形 $\\Delta$ 内。对于一个有 $C$ 个组分的体系，这意味着对于所有 $i=1,...,C$，$x_i \\ge 0$ 且 $\\sum_{i=1}^{C} x_i = 1$。\n3. 必须满足质量守恒定律，该定律通过杠杆定律将总组分 $\\mathbf{x}^0$ 与相组分和相分数联系起来：$\\mathbf{x}^{0} = \\lambda \\mathbf{x}^{\\alpha} + (1-\\lambda) \\mathbf{x}^{\\beta}$。\n\n这个约束优化问题可以进行数值求解。SciPy库中的`scipy.optimize.minimize`函数，特别是使用序列最小二乘规划（`SLSQP`）方法，非常适合此任务，因为它能同时处理等式和不等式约束。\n\n对于二元体系，优化变量为 $(x^{\\alpha}, x^{\\beta}, \\lambda)$，共 $3$ 个变量。约束条件是：$0 \\le x^{\\alpha} \\le 1$，$0 \\le x^{\\beta} \\le 1$，$0 \\le \\lambda \\le 1$，以及标量质量平衡方程 $x^0 = \\lambda x^{\\alpha} + (1-\\lambda) x^{\\beta}$。\n\n对于三元体系，我们可以通过使用约束 $\\sum x_i = 1$ 来减少组分变量的数量。独立变量可以选择为 $(x_1^{\\alpha}, x_2^{\\alpha}, x_1^{\\beta}, x_2^{\\beta}, \\lambda)$，共 $5$ 个变量。约束条件是：\n- 边界：$x_{1,2}^{\\alpha,\\beta} \\ge 0$，$\\lambda \\in [0,1]$。\n- 单形约束：$x_1^{\\alpha} + x_2^{\\alpha} \\le 1$ 和 $x_1^{\\beta} + x_2^{\\beta} \\le 1$。\n- 质量平衡（一个向量方程，提供两个独立的标量方程）：\n$$\nx_1^0 = \\lambda x_1^{\\alpha} + (1-\\lambda) x_1^{\\beta}\n$$\n$$\nx_2^0 = \\lambda x_2^{\\alpha} + (1-\\lambda) x_2^{\\beta}\n$$\n\n吉布斯能量表达式中的对数项 $x \\ln x$ 在 $x=0$ 处需要特殊处理，其数学极限为 $0$。在数值上，这通过将摩尔分数的优化变量限制在一个小的正值范围内（例如 $[10^{-9}, 1-10^{-9}]$）来管理，以避免计算 $\\ln(0)$。\n\n优化收敛到最小总能量 $F_{min}$ 后，将此值与总组分为 $\\mathbf{x}^0$ 的单相体系的吉布斯能量 $G(T,P,\\mathbf{x}^0)$ 进行比较。如果 $F_{min}  G(T,P,\\mathbf{x}^0)$（在一个小的数值公差范围内），则表示双相状态在能量上更有利。得到的组分 $\\mathbf{x}^{\\alpha}$ 和 $\\mathbf{x}^{\\beta}$ 是平衡连接线的端点。如果 $F_{min} \\ge G(T,P,\\mathbf{x}^0)$，则体系作为单相是稳定的，连接线的端点都等于总组分，即 $\\mathbf{x}^{\\alpha} = \\mathbf{x}^{\\beta} = \\mathbf{x}^0$。\n\n为确保确定性的输出，得到的相组分对 $(\\mathbf{x}^{\\alpha}, \\mathbf{x}^{\\beta})$ 在报告前按字典序排序。所有摩尔分数输出均按要求四舍五入到 $6$ 位小数。该实现将处理每个测试用例，应用相应的二元或三元求解器，并将收集到的结果格式化为单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for phase equilibria.\n    \"\"\"\n    R = 8.314  # Universal gas constant in J/(mol*K)\n\n    test_cases = [\n        {'type': 'binary', 'T': 298.0, 'Omega': 7000.0, 'x0': 0.40},\n        {'type': 'binary', 'T': 298.0, 'Omega': 500.0, 'x0': 0.40},\n        {'type': 'ternary', 'T': 900.0, 'Omegas': (20000.0, 15000.0, 18000.0), 'x0': np.array([0.33, 0.33, 0.34])},\n        {'type': 'ternary', 'T': 900.0, 'Omegas': (3000.0, 3000.0, 3000.0), 'x0': np.array([0.95, 0.04, 0.01])},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'binary':\n            result = solve_binary(case['T'], R, case['Omega'], case['x0'])\n        else:  # ternary\n            result = solve_ternary(case['T'], R, case['Omegas'], case['x0'])\n        results.append(result)\n\n    format_and_print_results(results)\n\ndef xlogx(x):\n    \"\"\"\n    Calculates x * log(x) element-wise, handling x=0 case where the limit is 0.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    res = np.zeros_like(x)\n    mask = x > 0\n    res[mask] = x[mask] * np.log(x[mask])\n    return res\n\ndef g_bin(x, RT, Omega):\n    \"\"\"\n    Calculates the Gibbs free energy of mixing for a binary regular solution.\n    \"\"\"\n    return RT * (xlogx(x) + xlogx(1 - x)) + Omega * x * (1 - x)\n\ndef g_ter(x, RT, Omegas):\n    \"\"\"\n    Calculates the Gibbs free energy of mixing for a ternary regular solution.\n    x must be a 3-element numpy array.\n    Omegas is a tuple (O12, O23, O13).\n    \"\"\"\n    O12, O23, O13 = Omegas\n    entropy_term = RT * np.sum(xlogx(x))\n    enthalpy_term = O12 * x[0] * x[1] + O23 * x[1] * x[2] + O13 * x[0] * x[2]\n    return entropy_term + enthalpy_term\n\ndef solve_binary(T, R, Omega, x0):\n    \"\"\"\n    Solves for the two-phase equilibrium in a binary system.\n    \"\"\"\n    RT = R * T\n\n    def objective(v):\n        xa, xb, lam = v\n        ga = g_bin(xa, RT, Omega)\n        gb = g_bin(xb, RT, Omega)\n        return lam * ga + (1 - lam) * gb\n\n    # Initial guess: two compositions bracketing x0, 50% phase fraction\n    v0 = [0.1, 0.9, 0.5]\n    bounds = [(1e-9, 1.0 - 1e-9), (1e-9, 1.0 - 1e-9), (1e-9, 1.0 - 1e-9)]\n    constraints = [{'type': 'eq', 'fun': lambda v: v[2] * v[0] + (1 - v[2]) * v[1] - x0}]\n\n    res = minimize(objective, v0, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-12)\n\n    F_min = res.fun\n    G_x0 = g_bin(x0, RT, Omega)\n\n    # Compare minimized two-phase energy with single-phase energy\n    if F_min  G_x0 - 1e-9:\n        xa, xb, _ = res.x\n        return sorted([xa, xb])\n    else:\n        return [x0, x0]\n\ndef solve_ternary(T, R, Omegas, x0):\n    \"\"\"\n    Solves for the two-phase equilibrium in a ternary system.\n    \"\"\"\n    RT = R * T\n\n    def objective(v):\n        x1a, x2a, x1b, x2b, lam = v\n        xa = np.array([x1a, x2a, 1 - x1a - x2a])\n        xb = np.array([x1b, x2b, 1 - x1b - x2b])\n        # Penalty for invalid compositions (violating x_i >= 0)\n        if np.any(xa  -1e-9) or np.any(xb  -1e-9):\n            return 1e10\n        ga = g_ter(xa, RT, Omegas)\n        gb = g_ter(xb, RT, Omegas)\n        return lam * ga + (1 - lam) * gb\n\n    # Initial guess: compositions rich in different components, 50% phase fraction\n    v0 = [0.8, 0.1, 0.1, 0.8, 0.5]\n    bounds = [(1e-9, 1.0-1e-9)] * 4 + [(1e-9, 1.0-1e-9)]\n    constraints = [\n        {'type': 'ineq', 'fun': lambda v: 1.0 - v[0] - v[1]},  # x1a + x2a = 1\n        {'type': 'ineq', 'fun': lambda v: 1.0 - v[2] - v[3]},  # x1b + x2b = 1\n        {'type': 'eq', 'fun': lambda v: v[4] * v[0] + (1 - v[4]) * v[2] - x0[0]},  # mass balance x1\n        {'type': 'eq', 'fun': lambda v: v[4] * v[1] + (1 - v[4]) * v[3] - x0[1]}   # mass balance x2\n    ]\n\n    res = minimize(objective, v0, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-12)\n\n    F_min = res.fun\n    G_x0 = g_ter(x0, RT, Omegas)\n\n    if F_min  G_x0 - 1e-9:\n        x1a, x2a, x1b, x2b, _ = res.x\n        xa = np.array([x1a, x2a, 1 - x1a - x2a])\n        xb = np.array([x1b, x2b, 1 - x1b - x2b])\n        # Sort for canonical output\n        if list(xa) > list(xb):\n            xa, xb = xb, xa\n        return list(xa) + list(xb)\n    else:\n        return list(x0) + list(x0)\n\ndef format_and_print_results(results):\n    \"\"\"\n    Formats the final results list into the required single-line string format.\n    \"\"\"\n    str_parts = []\n    for res_item in results:\n        rounded_res = [f\"{x:.6f}\" for x in res_item]\n        str_parts.append(f\"[{','.join(rounded_res)}]\")\n    final_output = f\"[{','.join(str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3474881"}, {"introduction": "相图不仅描绘了全局最稳定的平衡态，还包含了亚稳态和非稳态区域，这些区域对于理解相变动力学（如旋节线分解）至关重要。与寻找全局自由能最小值的公切面法不同，本练习聚焦于判断一个单相的局部稳定性（local stability）。你将通过分析吉布斯自由能对成分的二阶偏导数矩阵（Hessian矩阵）的本征值，来确定三元体系中的旋节线（spinodal）边界[@problem_id:3474922]。掌握这一方法能够让你区分亚稳和不稳区域，并理解材料发生自发相分离的热力学驱动力。", "problem": "您将编写一个完整、可运行的程序，通过分析无量纲摩尔吉布斯自由能的组分约束Hessian矩阵的正定性丧失，来实现对恒温恒压下三元混合物斯平诺线的基于原理的计算。其基本依据是热力学稳定性条件：在恒定的温度和压力下，混合物的局部稳定性要求对于所有允许的组分变化，吉布斯自由能的二阶变分均为正。对于一个组分为$\\mathbf{x}=(x_1,x_2,x_3)$的三元体系，摩尔分数守恒约束要求$x_1+x_2+x_3=1$，一个便利的独立坐标选择是$(x_1,x_2)$，其中$x_3=1-x_1-x_2$，且$0  x_1, 0  x_2, x_1+x_2  1$。混合吉布斯自由能对这两个独立组分的Hessian矩阵定义为\n$$ \\mathbf{H} = \\begin{pmatrix} \\frac{\\partial^2 g}{\\partial x_1^2}  \\frac{\\partial^2 g}{\\partial x_1 \\partial x_2} \\\\ \\frac{\\partial^2 g}{\\partial x_2 \\partial x_1}  \\frac{\\partial^2 g}{\\partial x_2^2} \\end{pmatrix} $$\n斯平诺线是Hessian矩阵失去正定性的轨迹，即其最小特征值为零的轨迹。您的任务是实现一个程序，该程序：\n1. 在三元组分三角形的规则网格上计算上述Hessian矩阵。\n2. 确定每个网格点处的局部稳定性（稳定、亚稳或不稳）。\n3. 计算满足不稳条件（$\\det(\\mathbf{H})  0$ 或等价地，最小特征值 $ 0$）的网格点的分数。\n4. 明确检查等摩尔组分点（$x_1=x_2=x_3=1/3$）是否不稳定。\n您需要在由相互作用参数$\\chi_{12}, \\chi_{13}, \\chi_{23}$和网格分辨率$N$定义的多个测试用例中执行此操作。在$x_i \\le \\delta = 10^{-6}$的边界附近应排除点。输出必须包含不稳点分数和等摩尔点稳定性的布尔标志。", "solution": "该问题要求通过分析三元规则溶液模型下吉布斯自由能的Hessian矩阵来确定斯平诺（旋节线）区域。热力学稳定性的基本判据是，在恒定温度和压力下，吉布斯自由能曲面必须是局部凸的。对于多组分体系，这意味着吉布斯自由能对独立成分变量的Hessian矩阵必须是正定的。\n\n**1. 理论框架**\n\n给定三元体系的无量纲吉布斯自由能 $g(x_1, x_2, x_3)$，并使用质量守恒约束 $x_3 = 1 - x_1 - x_2$ 将其简化为两个独立变量 $(x_1, x_2)$ 的函数。局部稳定性要求 $g(x_1, x_2)$ 的Hessian矩阵 $\\mathbf{H}$ 是正定的。$\\mathbf{H}$ 的元素是二阶偏导数：\n$$\nH_{ij} = \\frac{\\partial^2 g}{\\partial x_i \\partial x_j} \\quad (i, j \\in \\{1, 2\\})\n$$\n对于问题中给出的规则溶液模型：\n$$\ng(\\mathbf{x}) = \\sum_{i=1}^{3} x_i \\ln x_i + \\chi_{12}x_1x_2 + \\chi_{13}x_1x_3 + \\chi_{23}x_2x_3\n$$\n将 $x_3 = 1-x_1-x_2$ 代入并求导，可得Hessian矩阵的解析表达式：\n$$\nH_{11} = \\frac{1}{x_1} + \\frac{1}{x_3} - 2\\chi_{13}\n$$\n$$\nH_{22} = \\frac{1}{x_2} + \\frac{1}{x_3} - 2\\chi_{23}\n$$\n$$\nH_{12} = H_{21} = \\frac{1}{x_3} + \\chi_{12} - \\chi_{13} - \\chi_{23}\n$$\n矩阵 $\\mathbf{H}$ 正定的条件是其两个主子行列式都为正，或者等价地，其所有特征值都为正。斯平诺边界是稳定性丧失的临界点，定义为Hessian矩阵的最小特征值 $\\lambda_{\\min} = 0$（或 $\\det(\\mathbf{H}) = 0$）的轨迹。在斯平诺线内部，$\\lambda_{\\min}  0$，体系对微小成分涨落不稳定，会发生自发的相分离（旋节线分解）。\n\n**2. 计算策略**\n\n解决此问题的算法遵循以下步骤：\n1.  **网格离散化**：在三元组分空间（一个等边三角形）上生成一个规则的网格点。网格由分辨率参数 $N$ 定义，其中组分 $x_1 = i/N, x_2 = j/N$，$i, j$ 是整数，且 $i+j \\le N$。\n2.  **边界排除**：根据问题要求，为避免在 $x_i \\to 0$ 时出现数值奇点（源于 $\\ln x_i$ 项），需排除靠近纯组分顶点的网格点，即忽略任何 $x_i  \\delta$ 的点。\n3.  **稳定性检查**：对于每个有效的网格点 $(x_1, x_2, x_3)$：\n    a. 使用上述解析公式计算Hessian矩阵 $\\mathbf{H}$ 的三个独立元素 $H_{11}, H_{22}, H_{12}$。\n    b. 计算 $2 \\times 2$ 矩阵 $\\mathbf{H}$ 的两个特征值。由于 $\\mathbf{H}$ 是对称的，特征值是实数。\n    c. 检查最小特征值 $\\lambda_{\\min}$ 的符号。如果 $\\lambda_{\\min}  0$（考虑到数值公差，即 $\\lambda_{\\min}  -\\tau$），则该点位于不稳定的斯平诺区域内。\n4.  **统计与评估**：\n    a. 统计被识别为不稳定的网格点数量，并除以总的有效网格点数，得到不稳区域的面积分数。\n    b. 单独对等摩尔组分点 $(1/3, 1/3, 1/3)$ 执行相同的稳定性检查，以确定其是否不稳定，并返回一个布尔值。\n\n该方法将连续的稳定性问题转化为在离散网格上的计算任务，从而能够有效地绘制出斯平诺区域并量化其大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spinodal boundaries for a ternary mixture based on the regular solution model.\n    \"\"\"\n    \n    test_cases = [\n        {'chi_params': (0.5, 0.5, 0.5), 'N': 120},  # Case 1\n        {'chi_params': (3.5, 3.5, 3.5), 'N': 120},  # Case 2\n        {'chi_params': (2.8, 0.8, 3.2), 'N': 100},  # Case 3\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        chi_params = case['chi_params']\n        N = case['N']\n        \n        # Calculate properties for the current test case\n        result = calculate_spinodal_properties(chi_params, N)\n        results.append(result)\n\n    # Format the final output string as per requirements\n    # e.g., [[f1,b1],[f2,b2],[f3,b3]] with lowercase booleans\n    formatted_results = []\n    for f_val, b_val in results:\n        # Round the float to 6 decimal places\n        f_val_rounded = round(f_val, 6)\n        # Convert boolean to lowercase string 'true' or 'false'\n        b_val_str = str(b_val).lower()\n        formatted_results.append(f\"[{f_val_rounded},{b_val_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_spinodal_properties(chi_params, N):\n    \"\"\"\n    Calculates the fraction of unstable points on a grid and checks stability at the equimolar point.\n\n    Args:\n        chi_params (tuple): A tuple of (chi_12, chi_13, chi_23).\n        N (int): The grid resolution.\n\n    Returns:\n        list: A list containing [unstable_fraction, is_equimolar_unstable].\n    \"\"\"\n    chi12, chi13, chi23 = chi_params\n    delta = 1e-6\n    tau = 1e-10\n\n    unstable_count = 0\n    total_points = 0\n\n    # Discretize the composition triangle and evaluate stability at each point\n    for i in range(N + 1):\n        for j in range(N - i + 1):\n            x1 = i / N\n            x2 = j / N\n            x3 = 1.0 - x1 - x2\n\n            # Exclude points near the boundary as per the cutoff delta\n            if x1  delta or x2  delta or x3  delta:\n                continue\n\n            total_points += 1\n\n            # Compute the Hessian matrix elements\n            H11 = 1/x1 + 1/x3 - 2 * chi13\n            H22 = 1/x2 + 1/x3 - 2 * chi23\n            H12 = 1/x3 + chi12 - chi13 - chi23\n            \n            H = np.array([[H11, H12], [H12, H22]])\n\n            # Compute eigenvalues and check for instability\n            min_eig = np.linalg.eigvalsh(H)[0]\n            if min_eig  -tau:\n                unstable_count += 1\n    \n    fraction_unstable = 0.0\n    if total_points > 0:\n        fraction_unstable = unstable_count / total_points\n\n    # Separately evaluate stability at the equimolar composition\n    x_eq = 1.0 / 3.0\n    H11_eq = 1/x_eq + 1/x_eq - 2 * chi13\n    H22_eq = 1/x_eq + 1/x_eq - 2 * chi23\n    H12_eq = 1/x_eq + chi12 - chi13 - chi23\n    \n    H_eq = np.array([[H11_eq, H12_eq], [H12_eq, H22_eq]])\n    \n    min_eig_eq = np.linalg.eigvalsh(H_eq)[0]\n    is_equimolar_unstable = min_eig_eq  -tau\n    \n    return [fraction_unstable, is_equimolar_unstable]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3474922"}]}