{"hands_on_practices": [{"introduction": "在构建复杂的势函数之前，理解其训练过程的统计学基础至关重要。本练习将探讨如何将能量、力和应力等不同类型的量子化学计算数据整合到一个统一的损失函数中。通过从最大似然估计原理出发，您将揭示训练数据中的假设噪声与损失函数中各项权重之间的深刻联系 [@problem_id:3468393]，为拟合任何类型的原子间势提供了坚实的理论依据。", "problem": "考虑在计算材料科学中训练一个原子间势，该势使用一个受神经网络和核方法启发的参数模型，来同时拟合能量、力和维里应力。例如，神经网络中的末端线性层，或高斯近似势 (Gaussian Approximation Potential, GAP) 或矩张量势 (Moment Tensor Potential, MTP) 中的线性核展开。设参数向量为 $\\boldsymbol{\\theta} \\in \\mathbb{R}^{2}$，并假设对于单个构型，预测的可观测量通过固定的描述符与 $\\boldsymbol{\\theta}$ 呈线性关系：\n$$E_{\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{E}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{E} = \\begin{pmatrix}2 \\\\ 1 \\end{pmatrix},$$\n$$F_{x,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{F_x}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{F_x} = \\begin{pmatrix}-3 \\\\ 0.5 \\end{pmatrix}, \\qquad F_{y,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{F_y}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{F_y} = \\begin{pmatrix}1 \\\\ -2 \\end{pmatrix},$$\n$$\\sigma_{xx,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{S_{xx}}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{S_{xx}} = \\begin{pmatrix}4 \\\\ -1 \\end{pmatrix}, \\quad \\sigma_{yy,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{S_{yy}}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{S_{yy}} = \\begin{pmatrix}-1 \\\\ 3 \\end{pmatrix},$$\n$$\\sigma_{xy,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_{S_{xy}}^{\\top}\\boldsymbol{\\theta}, \\quad \\boldsymbol{\\phi}_{S_{xy}} = \\begin{pmatrix}0.5 \\\\ 0.5 \\end{pmatrix}.$$\n假设每种类型的可观测量都服从独立的高斯噪声模型，能量的方差为 $\\sigma_{E}^{2} = 0.01$，每个力分量的方差为 $\\sigma_{F}^{2} = 0.04$，每个应力分量的方差为 $\\sigma_{S}^{2} = 0.09$。将测量值 $E$、$F_{x}$、$F_{y}$、$\\sigma_{xx}$、$\\sigma_{yy}$ 和 $\\sigma_{xy}$ 视为固定数据。\n\n从独立高斯误差下的最大似然原理和费雪信息矩阵 (FIM) 的定义出发，完成以下任务：\n\n1. 推导组合训练损失 $L(\\boldsymbol{\\theta})$，它等于负对数似然（可相差一个与 $\\boldsymbol{\\theta}$ 无关的加性常数），并同时包含能量、力和应力的残差。您的推导必须明确展示权重是如何从噪声方差中产生的。\n\n2. 推导此线性模型的费雪信息矩阵 $\\mathbf{I}(\\boldsymbol{\\theta})$，并展示权重（由 $\\sigma_{E}^{2}$、$\\sigma_{F}^{2}$ 和 $\\sigma_{S}^{2}$ 决定）如何确定能量、力和应力的相对贡献。\n\n3. 将相对影响比 $r$ 定义为费雪信息矩阵中来自力的迹贡献与来自能量的迹贡献之比：\n$$r = \\frac{\\operatorname{tr}(\\mathbf{I}_{F})}{\\operatorname{tr}(\\mathbf{I}_{E})},$$\n其中 $\\mathbf{I}_{F}$ 和 $\\mathbf{I}_{E}$ 分别表示由力和能量可观测量产生的对费雪信息矩阵的加性贡献。使用上面给出的描述符和方差，计算 $r$。\n\n将最终的比率 $r$ 表示为一个无量纲小数，并四舍五入到四位有效数字。", "solution": "该问题要求针对一个线性原子间势模型，推导损失函数、费雪信息矩阵 (FIM) 以及迹贡献的一个特定比率。推导基于最大似然估计原理，并假设每个可观测量都存在独立的高斯噪声。\n\n### 第1部分：组合训练损失 $L(\\boldsymbol{\\theta})$ 的推导\n\n参数向量 $\\boldsymbol{\\theta}$ 的训练被构建为一个最大似然估计问题。我们给定一组测量数据 $\\mathcal{D} = \\{y_k\\}$，包括能量 $E$、力分量 $F_x, F_y$ 和应力分量 $\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}$。假设每个测量值 $y_k$ 均从高斯分布中抽取，其均值为模型的预测值 $y_{k,\\text{pred}}(\\boldsymbol{\\theta})$，方差为已知的 $\\sigma_k^2$。单个观测值 $y_k$ 的概率密度函数为：\n$$p(y_k | \\boldsymbol{\\theta}) = \\frac{1}{\\sqrt{2\\pi\\sigma_k^2}} \\exp\\left(-\\frac{(y_k - y_{k,\\text{pred}}(\\boldsymbol{\\theta}))^2}{2\\sigma_k^2}\\right)$$\n假设可观测量具有独立的噪声。因此，在给定参数 $\\boldsymbol{\\theta}$ 的情况下，观测到整个数据集 $\\mathcal{D}$ 的总似然是各个概率密度的乘积：\n$$P(\\mathcal{D}|\\boldsymbol{\\theta}) = \\prod_{k \\in \\mathcal{D}} p(y_k | \\boldsymbol{\\theta})$$\n为了最大化似然，计算上更方便的是最大化其对数，即对数似然 $\\ln P(\\mathcal{D}|\\boldsymbol{\\theta})$：\n$$\\ln P(\\mathcal{D}|\\boldsymbol{\\theta}) = \\sum_{k \\in \\mathcal{D}} \\ln p(y_k | \\boldsymbol{\\theta}) = \\sum_{k \\in \\mathcal{D}} \\left( -\\frac{1}{2}\\ln(2\\pi\\sigma_k^2) - \\frac{(y_k - y_{k,\\text{pred}}(\\boldsymbol{\\theta}))^2}{2\\sigma_k^2} \\right)$$\n训练损失 $L(\\boldsymbol{\\theta})$ 定义为负对数似然。最大化对数似然等价于最小化损失。舍去与 $\\boldsymbol{\\theta}$ 无关的常数项，我们得到：\n$$L(\\boldsymbol{\\theta}) = \\sum_{k \\in \\mathcal{D}} \\frac{(y_k - y_{k,\\text{pred}}(\\boldsymbol{\\theta}))^2}{2\\sigma_k^2}$$\n该表达式是加权残差平方和，其中每个残差的权重是其噪声方差的倒数 $1/\\sigma_k^2$。因子 $1/2$ 是一个常见的约定。\n\n代入问题陈述中的具体可观测量，组合损失函数为：\n$$L(\\boldsymbol{\\theta}) = \\frac{(E - E_{\\text{pred}})^{2}}{2\\sigma_{E}^{2}} + \\frac{(F_x - F_{x,\\text{pred}})^{2}}{2\\sigma_{F}^{2}} + \\frac{(F_y - F_{y,\\text{pred}})^{2}}{2\\sigma_{F}^{2}} + \\frac{(\\sigma_{xx} - \\sigma_{xx,\\text{pred}})^{2}}{2\\sigma_{S}^{2}} + \\frac{(\\sigma_{yy} - \\sigma_{yy,\\text{pred}})^{2}}{2\\sigma_{S}^{2}} + \\frac{(\\sigma_{xy} - \\sigma_{xy,\\text{pred}})^{2}}{2\\sigma_{S}^{2}}$$\n使用线性模型定义 $y_{k,\\text{pred}}(\\boldsymbol{\\theta}) = \\boldsymbol{\\phi}_k^\\top\\boldsymbol{\\theta}$：\n$$L(\\boldsymbol{\\theta}) = \\frac{(E - \\boldsymbol{\\phi}_{E}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{E}^{2}} + \\frac{(F_x - \\boldsymbol{\\phi}_{F_x}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{F}^{2}} + \\frac{(F_y - \\boldsymbol{\\phi}_{F_y}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{F}^{2}} + \\frac{(\\sigma_{xx} - \\boldsymbol{\\phi}_{S_{xx}}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{S}^{2}} + \\frac{(\\sigma_{yy} - \\boldsymbol{\\phi}_{S_{yy}}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{S}^{2}} + \\frac{(\\sigma_{xy} - \\boldsymbol{\\phi}_{S_{xy}}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_{S}^{2}}$$\n这明确地表明，损失函数中能量、力和应力残差的相对权重由它们各自噪声方差的倒数决定。\n\n### 第2部分：费雪信息矩阵 $\\mathbf{I}(\\boldsymbol{\\theta})$ 的推导\n\n参数向量 $\\boldsymbol{\\theta}$ 的费雪信息矩阵 (FIM) 定义为对数似然的海森矩阵（Hessian matrix）的负期望值：\n$$\\mathbf{I}_{ij}(\\boldsymbol{\\theta}) = -E\\left[\\frac{\\partial^2 \\ln P(\\mathcal{D}|\\boldsymbol{\\theta})}{\\partial \\theta_i \\partial \\theta_j}\\right]$$\n对于具有加性高斯噪声的线性模型，对数似然的海森矩阵是常数，不依赖于数据值 $\\{y_k\\}$。因此，期望的计算是平凡的。FIM 就是我们损失函数 $L(\\boldsymbol{\\theta})$ 的海森矩阵：\n$$\\mathbf{I}(\\boldsymbol{\\theta}) = \\nabla_{\\boldsymbol{\\theta}} \\nabla_{\\boldsymbol{\\theta}}^{\\top} L(\\boldsymbol{\\theta})$$\n让我们计算损失中单项的海森矩阵：\n$$\\frac{\\partial^2}{\\partial \\theta_j \\partial \\theta_i} \\left[ \\frac{(y_k - \\boldsymbol{\\phi}_{k}^{\\top}\\boldsymbol{\\theta})^2}{2\\sigma_k^2} \\right] = \\frac{\\partial}{\\partial \\theta_j} \\left[ \\frac{y_k - \\boldsymbol{\\phi}_{k}^{\\top}\\boldsymbol{\\theta}}{-\\sigma_k^2} (\\phi_k)_i \\right] = \\frac{(\\phi_k)_j (\\phi_k)_i}{\\sigma_k^2}$$\n此处，$(\\phi_k)_i$ 是向量 $\\boldsymbol{\\phi}_k$ 的第 $i$ 个分量。用矩阵表示法，此项的海森矩阵是外积 $\\frac{1}{\\sigma_k^2} \\boldsymbol{\\phi}_k \\boldsymbol{\\phi}_k^\\top$。\n\n由于总损失是独立项的和，总 FIM 是每个可观测量贡献的总和：\n$$\\mathbf{I} = \\sum_{k \\in \\mathcal{D}} \\frac{1}{\\sigma_k^2} \\boldsymbol{\\phi}_k \\boldsymbol{\\phi}_k^\\top$$\n对于此模型，FIM 与 $\\boldsymbol{\\theta}$ 无关。它可以分解为来自能量、力和应力的加性贡献：\n$$\\mathbf{I} = \\mathbf{I}_{E} + \\mathbf{I}_{F} + \\mathbf{I}_{S}$$\n其中：\n$$\\mathbf{I}_{E} = \\frac{1}{\\sigma_{E}^{2}} \\boldsymbol{\\phi}_{E} \\boldsymbol{\\phi}_{E}^{\\top}$$\n$$\\mathbf{I}_{F} = \\frac{1}{\\sigma_{F}^{2}} \\left( \\boldsymbol{\\phi}_{F_x} \\boldsymbol{\\phi}_{F_x}^{\\top} + \\boldsymbol{\\phi}_{F_y} \\boldsymbol{\\phi}_{F_y}^{\\top} \\right)$$\n$$\\mathbf{I}_{S} = \\frac{1}{\\sigma_{S}^{2}} \\left( \\boldsymbol{\\phi}_{S_{xx}} \\boldsymbol{\\phi}_{S_{xx}}^{\\top} + \\boldsymbol{\\phi}_{S_{yy}} \\boldsymbol{\\phi}_{S_{yy}}^{\\top} + \\boldsymbol{\\phi}_{S_{xy}} \\boldsymbol{\\phi}_{S_{xy}}^{\\top} \\right)$$\n权重 $1/\\sigma_k^2$ 决定了每种可观测量类型对总费雪信息的贡献的相对大小。\n\n### 第3部分：相对影响比 $r$ 的计算\n\n比率 $r$ 定义为 FIM 中力的贡献的迹与能量的贡献的迹之比：\n$$r = \\frac{\\operatorname{tr}(\\mathbf{I}_{F})}{\\operatorname{tr}(\\mathbf{I}_{E})}$$\n我们利用迹算子的性质 $\\operatorname{tr}(\\mathbf{A}+\\mathbf{B}) = \\operatorname{tr}(\\mathbf{A}) + \\operatorname{tr}(\\mathbf{B})$ 以及循环性质，它意味着 $\\operatorname{tr}(\\mathbf{v}\\mathbf{v}^\\top) = \\mathbf{v}^\\top\\mathbf{v} = ||\\mathbf{v}||_2^2$，即向量 $\\mathbf{v}$ 的欧几里得范数的平方。\n\n首先，我们计算能量贡献的迹 $\\operatorname{tr}(\\mathbf{I}_{E})$：\n$$\\operatorname{tr}(\\mathbf{I}_{E}) = \\operatorname{tr}\\left( \\frac{1}{\\sigma_{E}^2} \\boldsymbol{\\phi}_{E} \\boldsymbol{\\phi}_{E}^{\\top} \\right) = \\frac{1}{\\sigma_{E}^2} \\operatorname{tr}(\\boldsymbol{\\phi}_{E} \\boldsymbol{\\phi}_{E}^{\\top}) = \\frac{||\\boldsymbol{\\phi}_{E}||_2^2}{\\sigma_{E}^2}$$\n接下来，我们计算力贡献的迹 $\\operatorname{tr}(\\mathbf{I}_{F})$：\n$$\\operatorname{tr}(\\mathbf{I}_{F}) = \\operatorname{tr}\\left( \\frac{1}{\\sigma_{F}^2} \\left( \\boldsymbol{\\phi}_{F_x} \\boldsymbol{\\phi}_{F_x}^{\\top} + \\boldsymbol{\\phi}_{F_y} \\boldsymbol{\\phi}_{F_y}^{\\top} \\right) \\right) = \\frac{1}{\\sigma_{F}^2} \\left[ \\operatorname{tr}(\\boldsymbol{\\phi}_{F_x} \\boldsymbol{\\phi}_{F_x}^{\\top}) + \\operatorname{tr}(\\boldsymbol{\\phi}_{F_y} \\boldsymbol{\\phi}_{F_y}^{\\top}) \\right] = \\frac{||\\boldsymbol{\\phi}_{F_x}||_2^2 + ||\\boldsymbol{\\phi}_{F_y}||_2^2}{\\sigma_{F}^2}$$\n现在，我们代入给定的值：\n- $\\boldsymbol{\\phi}_{E} = \\begin{pmatrix}2 \\\\ 1 \\end{pmatrix}$\n- $\\boldsymbol{\\phi}_{F_x} = \\begin{pmatrix}-3 \\\\ 0.5 \\end{pmatrix}$\n- $\\boldsymbol{\\phi}_{F_y} = \\begin{pmatrix}1 \\\\ -2 \\end{pmatrix}$\n- $\\sigma_E^2 = 0.01$\n- $\\sigma_F^2 = 0.04$\n\n计算描述符向量的范数平方：\n$$||\\boldsymbol{\\phi}_{E}||_2^2 = (2)^2 + (1)^2 = 4 + 1 = 5$$\n$$||\\boldsymbol{\\phi}_{F_x}||_2^2 = (-3)^2 + (0.5)^2 = 9 + 0.25 = 9.25$$\n$$||\\boldsymbol{\\phi}_{F_y}||_2^2 = (1)^2 + (-2)^2 = 1 + 4 = 5$$\n\n现在，计算迹：\n$$\\operatorname{tr}(\\mathbf{I}_{E}) = \\frac{5}{0.01} = 500$$\n$$\\operatorname{tr}(\\mathbf{I}_{F}) = \\frac{9.25 + 5}{0.04} = \\frac{14.25}{0.04} = 356.25$$\n\n最后，计算比率 $r$：\n$$r = \\frac{\\operatorname{tr}(\\mathbf{I}_{F})}{\\operatorname{tr}(\\mathbf{I}_{E})} = \\frac{356.25}{500} = 0.7125$$\n问题要求答案为一个四舍五入到四位有效数字的小数。值 $0.7125$ 已经有四位有效数字。", "answer": "$$\\boxed{0.7125}$$", "id": "3468393"}, {"introduction": "在掌握了基本的拟合原理之后，我们将着手从零开始构建一个原子间势。本练习将指导您完成一个简化版矩张量势 (Moment Tensor Potential, MTP) 的实现 [@problem_id:3468372]。通过亲手构建旋转不变性描述符并求解线性方程组，您将对这类势函数如何表征原子局域环境并预测能量获得具体而深入的理解。", "problem": "您需要实现一个最小化的、完全指定的层级为 $2$ 的矩张量势 (Moment Tensor Potential, MTP)，用于处理原子局域环境，显式地构建一个旋转不变量基，为一组给定的环境构建设计矩阵，并求解一个线性最小二乘问题以获得能量系数。所有计算都必须在三维笛卡尔坐标系中进行，并且必须使用以下基本定义。\n\n定义和约束：\n- 一个局域环境是相对于中心原子的一组有限的邻居矢量集合 $\\{\\mathbf{r}_j\\}_{j=1}^{N}$，位于 $\\mathbb{R}^3$ 中。距离单位为埃（ångström）。\n- 截断函数为：当 $r \\le r_c$ 时，$f_{\\mathrm{cut}}(r) = \\tfrac{1}{2}\\big(\\cos(\\pi r / r_c) + 1\\big)$；当 $r > r_c$ 时，$f_{\\mathrm{cut}}(r) = 0$。其中 $r = \\|\\mathbf{r}\\|$，$r_c$ 是截断半径（单位为埃）。\n- 当 $r \\le r_c$ 时，径向基函数为 $R_1(r) = r_c - r$ 和 $R_2(r) = (r_c - r)^2$。当 $r > r_c$ 时，由于 $f_{\\mathrm{cut}}(r)=0$，它们的贡献隐式地为零。\n- 对于 $\\mu \\in \\{1,2\\}$，定义矩张量如下：\n  $$M_{\\mu,0} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j),$$\n  $$M_{\\mu,1} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j \\in \\mathbb{R}^3,$$\n  $$M_{\\mu,2} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j \\otimes \\mathbf{r}_j \\in \\mathbb{R}^{3 \\times 3}.$$\n- 通过以下缩并构建层级最高为 $2$ 的标量、旋转不变量基函数：\n  1. $B_1 = M_{1,0}$,\n  2. $B_2 = M_{2,0}$,\n  3. $B_3 = \\mathrm{Tr}(M_{1,2})$,\n  4. $B_4 = \\mathrm{Tr}(M_{2,2})$,\n  5. $B_5 = M_{1,1} \\cdot M_{1,1}$,\n  6. $B_6 = M_{1,1} \\cdot M_{2,1}$,\n  7. $B_7 = M_{2,1} \\cdot M_{2,1}$,\n  其中 $\\mathrm{Tr}(\\cdot)$ 是矩阵的迹，$\\cdot$ 表示 $\\mathbb{R}^3$ 中的欧几里得点积。\n- 一个局域环境的能量被建模为这些不变量的线性组合：\n  $$E = \\sum_{k=1}^{7} c_k\\, B_k,$$\n  其中 $c_k$ 是常数系数（单位为电子伏特）。\n\n使用以下固定参数和数据：\n- 截断半径 $r_c = 4.5$ 埃。\n- 基准真相系数（单位为电子伏特）：$c = \\big[c_1,\\dots,c_7\\big] = \\big[0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08\\big]$。\n- 包含 9 个局域环境的测试套件，每个环境都以邻居矢量 $\\mathbf{r}_j = (x_j, y_j, z_j)$ 的显式列表形式给出（单位为埃）：\n  1. 环境 1：没有邻居，$\\{\\}$。\n  2. 环境 2：$\\{(2.0, 0.0, 0.0)\\}$。\n  3. 环境 3：$\\{(2.5, 0.0, 0.0),\\, (-2.5, 0.0, 0.0)\\}$。\n  4. 环境 4：$\\{(2.0, 0.0, 0.0),\\, (0.0, 2.0, 0.0)\\}$。\n  5. 环境 5：$\\{(1.8, 0.0, 0.0),\\, (0.0, 2.2, 0.0),\\, (0.0, 0.0, 2.5)\\}$。\n  6. 环境 6：位于 $xy$ 平面内、半径为 $2.4$ 的等边三角形，即 $\\{(2.4, 0.0, 0.0),\\, (-1.2, 2.4\\cdot \\sqrt{3}/2, 0.0),\\, (-1.2, -2.4\\cdot \\sqrt{3}/2, 0.0)\\}$。\n  7. 环境 7：缩放到长度 $2.8$ 的正四面体方向，即 $\\{ \\tfrac{2.8}{\\sqrt{3}}(1,1,1),\\, \\tfrac{2.8}{\\sqrt{3}}(1,-1,-1),\\, \\tfrac{2.8}{\\sqrt{3}}(-1,1,-1),\\, \\tfrac{2.8}{\\sqrt{3}}(-1,-1,1)\\}$。\n  8. 环境 8：$\\{(1.9, 0.5, 0.2),\\, (-0.3, 2.4, 0.1),\\, (0.4, -0.2, 2.6),\\, (-1.1, -0.8, 2.0)\\}$。\n  9. 环境 9：单个邻居在截断半径之外，$\\{(5.0, 0.0, 0.0)\\}$。\n\n需要实现的任务：\n1. 对每个环境，使用上述定义计算 7 维不变量矢量 $\\mathbf{B} = [B_1,\\dots,B_7]$。\n2. 按 1 到 9 的顺序，将每个环境的 $\\mathbf{B}^{\\top}$ 作为行，构建设计矩阵 $X \\in \\mathbb{R}^{9 \\times 7}$。\n3. 通过 $\\mathbf{y} = X\\, \\mathbf{c}$，从基准真相系数生成观测能量 $\\mathbf{y} \\in \\mathbb{R}^{9}$。\n4. 从 $(X,\\mathbf{y})$ 求解线性最小二乘问题，以估计作为 $\\|\\!|X \\mathbf{c} - \\mathbf{y}\\|\\!|_2^2$ 最小化子的 $\\widehat{\\mathbf{c}}$。\n5. 使用 $\\widehat{\\mathbf{c}}$ 计算预测能量 $\\widehat{\\mathbf{y}} = X\\, \\widehat{\\mathbf{c}}$，并报告每个环境的绝对误差 $e_i = |y_i - \\widehat{y}_i|$。\n\n物理和数值单位：\n- 距离必须以埃（ångström）为单位处理；截断半径以埃为单位给出。\n- 能量和能量误差必须以电子伏特（eV）为单位，用十进制数表示。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表按顺序包含 9 个环境的绝对能量误差，即 $[e_1,e_2,\\dots,e_9]$，其中每个 $e_i$ 的单位是 $\\mathrm{eV}$。将每个 $e_i$ 四舍五入到至少 10 位小数。\n\n覆盖性设计：\n- 环境 1 测试没有邻居的边界情况（所有不变量为零，能量为 $0$）。\n- 环境 9 测试截断边界，其中一个邻居在截断半径之外（所有不变量为零，能量为 $0$）。\n- 环境 3 和 4 测试对称性效应，这些效应会使 $M_{\\mu,1}$ 抵消为零，同时保持更高阶矩为非零。\n- 环境 6 和 7 测试非平凡的多邻居构型，这些构型会导致多样化的不变量值。", "solution": "该问题要求实现并验证一个简化的矩张量势 (MTP) 模型。该过程涉及为一组给定的原子环境计算旋转不变量基函数，构建一个设计矩阵，并执行线性回归以验证模型的实现。\n\nMTP 框架的核心是通过一组在旋转下保持不变的描述符来表示一个局域原子环境（该环境由中心原子周围的一组邻居矢量 $\\{\\mathbf{r}_j\\}_{j=1}^{N}$ 定义）。这确保了如果整个系统被旋转，环境的预测能量不会改变，这是一项基本的物理要求。\n\n该过程可分解为以下步骤：\n\n1.  **矩张量的计算**：\n    对于每个局域环境，我们首先计算矩张量，它们是环境中原子的加权和。权重涉及一个平滑的截断函数 $f_{\\mathrm{cut}}(r)$ 和一组径向基函数 $R_{\\mu}(r)$。\n\n    - 截断函数 $f_{\\mathrm{cut}}(r) = \\tfrac{1}{2}\\big(\\cos(\\pi r / r_c) + 1\\big)$（当 $r \\le r_c$ 时，否则为 0），确保当一个原子与中心原子的距离 $r$ 接近截断半径 $r_c = 4.5$ Å 时，其影响平滑地趋于零。这种局域性对于大规模模拟中的计算效率至关重要。\n\n    - 径向基函数 $R_1(r) = r_c - r$ 和 $R_2(r) = (r_c - r)^2$ 将距离信息编码到模型中。\n\n    对于每个径向基函数索引 $\\mu \\in \\{1,2\\}$，我们定义秩（层级）递增的矩张量：\n    - 0 阶（标量）：$M_{\\mu,0} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)$\n    - 1 阶（矢量）：$M_{\\mu,1} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j$\n    - 2 阶（矩阵）：$M_{\\mu,2} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, (\\mathbf{r}_j \\otimes \\mathbf{r}_j)$\n\n    这里，$\\mathbf{r}_j \\otimes \\mathbf{r}_j$ 表示矢量 $\\mathbf{r}_j$ 与其自身的外积，结果是一个 $3 \\times 3$ 矩阵。这些张量捕捉了关于原子邻域几何形状的日益复杂的信息。对于空环境或所有原子都在截断半径 $r_c$ 之外的环境，所有矩张量均为零。\n\n2.  **旋转不变量基函数的构建**：\n    矩张量本身不是旋转不变量（例如，$M_{\\mu,1}$ 是一个矢量，会随坐标系旋转）。为了实现旋转不变性，我们通过缩并这些张量来形成标量。问题指定了七个这样的基函数 $B_k$：\n    - $B_1 = M_{1,0}$ 和 $B_2 = M_{2,0}$：这些本身就是标量，因此是固有不变量。它们代表邻居的加权计数。\n    - $B_3 = \\mathrm{Tr}(M_{1,2})$ 和 $B_4 = \\mathrm{Tr}(M_{2,2})$：矩阵的迹 $\\mathrm{Tr}(\\cdot)$ 在旋转下是不变的。这些不变量与邻居距离平方的加权和有关。\n    - $B_5 = M_{1,1} \\cdot M_{1,1}$、$B_6 = M_{1,1} \\cdot M_{2,1}$ 和 $B_7 = M_{2,1} \\cdot M_{2,1}$：两个矢量的点积产生一个标量，它也是旋转不变量。这些不变量捕捉了关于环境不对称性的信息。对于具有高点群对称性（如以原点为中心的正四面体或等边三角形）的环境，矢量矩 $M_{\\mu,1}$ 的和为零，导致这些不变量消失。\n\n    对于所提供的 9 个环境中的每一个，我们都计算出相应的不变量 7 维矢量 $\\mathbf{B} = [B_1, B_2, B_3, B_4, B_5, B_6, B_7]$。\n\n3.  **设计矩阵和能量矢量的构建**：\n    一个环境的能量被建模为基不变量的线性组合：$E = \\sum_{k=1}^{7} c_k\\, B_k$。这可以写成矢量形式 $E = \\mathbf{B} \\cdot \\mathbf{c}$。\n    我们构建一个设计矩阵 $X \\in \\mathbb{R}^{9 \\times 7}$，其中第 $i$ 行是第 $i$ 个环境的不变量矢量 $\\mathbf{B}^{(i)}$。\n    然后，使用基准真相系数 $\\mathbf{c} = [0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08]^{\\top}$ 生成所有 9 个环境的“观测”能量。这是一个矩阵-矢量乘积：$\\mathbf{y} = X\\,\\mathbf{c}$，其中 $\\mathbf{y} \\in \\mathbb{R}^9$ 是能量矢量。\n\n4.  **线性最小二乘拟合与误差计算**：\n    该问题构成了一个“往返”测试。我们从一个已知的线性模型生成了数据 $(\\mathbf{X}, \\mathbf{y})$。下一步是求解线性最小二乘问题，以找到使残差的平方范数 $\\|\\!|X \\widehat{\\mathbf{c}} - \\mathbf{y}\\|\\!|_2^2$ 最小化的系数 $\\widehat{\\mathbf{c}}$。\n    由于数据 $\\mathbf{y}$ 是无噪声的，并且是直接从 $X$ 生成的（即 $\\mathbf{y}$ 精确地位于 $X$ 的列空间中），最小二乘解将产生与“观测”能量 $\\mathbf{y}$ 完全相同的预测能量 $\\widehat{\\mathbf{y}} = X \\widehat{\\mathbf{c}}$。因此，在浮点精度的限制内，每个环境的绝对误差 $e_i = |y_i - \\widehat{y}_i|$ 预期为零。非零误差将表明基函数计算的实现不正确。\n\n    算法流程如下：\n    - 使用标准的线性最小二乘求解器求解 $\\widehat{\\mathbf{c}}$，`scipy.linalg.lstsq` 非常适合此任务。\n    - 计算预测能量 $\\widehat{\\mathbf{y}} = X \\widehat{\\mathbf{c}}$。\n    - 计算绝对误差 $\\mathbf{e} = |\\mathbf{y} - \\widehat{\\mathbf{y}}|$。\n    - 报告按要求精度格式化的 $\\mathbf{e}$ 的分量。\n\n此验证过程确保了复杂基函数计算的正确性，这是在任何实际应用中使用 MTP 模型的根本先决条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lstsq\n\ndef solve():\n    \"\"\"\n    Implements a simplified Moment Tensor Potential (MTP) model,\n    calculates invariants for given environments, and verifies the\n    implementation via a linear least squares round-trip test.\n    \"\"\"\n\n    # Define the fixed parameters from the problem statement.\n    r_c = 4.5  # Cutoff radius in angstrom\n    c_true = np.array([0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08]) # Ground-truth coefficients in eV\n\n    # Define the test suite of 9 local environments.\n    sqrt3 = np.sqrt(3)\n    environments = [\n        [],  # Env 1: no neighbors\n        [(2.0, 0.0, 0.0)],  # Env 2\n        [(2.5, 0.0, 0.0), (-2.5, 0.0, 0.0)],  # Env 3\n        [(2.0, 0.0, 0.0), (0.0, 2.0, 0.0)],  # Env 4\n        [(1.8, 0.0, 0.0), (0.0, 2.2, 0.0), (0.0, 0.0, 2.5)],  # Env 5\n        [(2.4, 0.0, 0.0), (-1.2, 2.4 * sqrt3 / 2.0, 0.0), (-1.2, -2.4 * sqrt3 / 2.0, 0.0)],  # Env 6\n        [\n            (2.8 / sqrt3 * v[0], 2.8 / sqrt3 * v[1], 2.8 / sqrt3 * v[2])\n            for v in [(1, 1, 1), (1, -1, -1), (-1, 1, -1), (-1, -1, 1)]\n        ],  # Env 7\n        [(1.9, 0.5, 0.2), (-0.3, 2.4, 0.1), (0.4, -0.2, 2.6), (-1.1, -0.8, 2.0)],  # Env 8\n        [(5.0, 0.0, 0.0)],  # Env 9: out of cutoff\n    ]\n\n    def calculate_invariants(neighbor_vectors, rc):\n        \"\"\"\n        Calculates the 7 MTP basis invariants for a single environment.\n        \"\"\"\n        # Initialize moment tensors\n        m_10, m_20 = 0.0, 0.0\n        m_11, m_21 = np.zeros(3), np.zeros(3)\n        m_12, m_22 = np.zeros((3, 3)), np.zeros((3, 3))\n\n        for vec in neighbor_vectors:\n            r_j = np.array(vec)\n            r = np.linalg.norm(r_j)\n\n            if r = rc and r > 1e-9:  # Check cutoff and avoid division by zero\n                # Calculate cutoff function and radial basis functions\n                f_cut = 0.5 * (np.cos(np.pi * r / rc) + 1.0)\n                r1_val = rc - r\n                r2_val = (rc - r) ** 2\n                \n                # Pre-calculate weighted radial terms\n                w1 = f_cut * r1_val\n                w2 = f_cut * r2_val\n                \n                # Accumulate moment tensors\n                m_10 += w1\n                m_20 += w2\n                \n                m_11 += w1 * r_j\n                m_21 += w2 * r_j\n                \n                m_12 += w1 * np.outer(r_j, r_j)\n                m_22 += w2 * np.outer(r_j, r_j)\n\n        # Construct the 7 scalar invariants B_k\n        b_vec = np.zeros(7)\n        b_vec[0] = m_10                # B1 = M_1,0\n        b_vec[1] = m_20                # B2 = M_2,0\n        b_vec[2] = np.trace(m_12)      # B3 = Tr(M_1,2)\n        b_vec[3] = np.trace(m_22)      # B4 = Tr(M_2,2)\n        b_vec[4] = np.dot(m_11, m_11)  # B5 = M_1,1 . M_1,1\n        b_vec[5] = np.dot(m_11, m_21)  # B6 = M_1,1 . M_2,1\n        b_vec[6] = np.dot(m_21, m_21)  # B7 = M_2,1 . M_2,1\n        \n        return b_vec\n\n    # 1.  2. Compute invariants and assemble the design matrix X\n    num_environments = len(environments)\n    num_invariants = 7\n    X = np.zeros((num_environments, num_invariants))\n    for i, env in enumerate(environments):\n        X[i, :] = calculate_invariants(env, r_c)\n\n    # 3. Generate the \"observed\" energies y\n    y = X @ c_true\n\n    # 4. Solve the linear least squares problem for c_hat\n    c_hat, residuals, rank, s = lstsq(X, y)\n\n    # 5. Compute predicted energies and absolute errors\n    y_hat = X @ c_hat\n    errors = np.abs(y - y_hat)\n\n    # Format the final output string\n    # Using high precision formatting to show the errors are numerically zero\n    error_strs = [f\"{err:.17f}\" for err in errors]\n    print(f\"[{','.join(error_strs)}]\")\n\nsolve()\n```", "id": "3468372"}, {"introduction": "原子间势的最终目标之一是进行分子动力学模拟，而这需要精确的原子间作用力。本练习将聚焦于一个基于高斯过程 (Gaussian Process) 和著名 SOAP 描述符的模型，并解决通过解析微分核函数来计算力的关键任务 [@problem_id:3468379]。这项实践将带您跨越从静态能量模型到能够驱动模拟的动态势函数的鸿沟，展示了如何从机器学习模型中获得物理上至关重要的力。", "problem": "给定一个包含三个局域原子环境的玩具数据集，您的任务是使用高斯过程 (GP) 和光滑原子位置重叠 (SOAP) 核函数来为其位点能量建模，然后通过对核函数关于探针原子坐标求导，计算探针原子在几个查询环境中的预测平均能量和相应的力。设定为单物种、有限范围相互作用，且 SOAP 描述符被简化为在固定一维网格上离散化的径向密度。模型和计算必须以与计算材料科学相关的、科学上合理且物理上可信的术语来表达。\n\n需使用的定义和建模假设：\n- 光滑原子位置重叠 (SOAP) 描述符由径向邻居密度近似。对于一个位于位置 $\\mathbf{r}_{\\mathrm{p}} \\in \\mathbb{R}^{3}$ 的探针原子和位于位置 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N_{\\mathrm{n}}}$ 的邻居原子，定义径向距离 $d_{j} = \\|\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}\\|$，并在一个径向网格 $\\{r_{g}\\}_{g=1}^{G}$（网格值见下文）上评估一个离散化的密度。在 $r_{g}$ 处的密度贡献被建模为以每个 $d_{j}$ 为中心的高斯函数之和，该和由一个光滑截断函数进行调制，高斯宽度为 $\\sigma$，截断半径为 $r_{\\mathrm{c}}$（具体值见下文）。这样，每个环境都会产生一个描述符向量 $\\mathbf{x} \\in \\mathbb{R}^{G}$。假设通过使用相对坐标 $\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}$ 来捕捉平移不变性。\n- 两个环境的描述符分别为 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^{G}$，它们之间的 SOAP 核函数是归一化点积的正整数 $\\zeta$ 次幂：$k(\\mathbf{x}, \\mathbf{y}) = s(\\mathbf{x}, \\mathbf{y})^{\\zeta}$，其中 $s(\\mathbf{x}, \\mathbf{y})$ 是余弦相似度 $s(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathbf{x} \\cdot \\mathbf{y}}{\\|\\mathbf{x}\\| \\, \\|\\mathbf{y}\\|}$。\n- 使用高斯过程 (GP) 回归对位点能量进行建模，训练输出为 $\\mathbf{y}_{\\text{train}} \\in \\mathbb{R}^{N}$，核矩阵 $K \\in \\mathbb{R}^{N \\times N}$ 由训练环境上的 SOAP 核函数构建。在对角线上添加方差为 $\\sigma_{\\mathrm{n}}^{2}$ 的同方差观测噪声。对于查询描述符 $\\mathbf{x}_{*}$，GP 预测均值为 $m(\\mathbf{x}_{*}) = \\mathbf{k}_{*}^{\\top} \\boldsymbol{\\alpha}$，其中 $\\mathbf{k}_{*} \\in \\mathbb{R}^{N}$ 的元素为 $k(\\mathbf{x}_{*}, \\mathbf{x}_{i})$，且 $\\boldsymbol{\\alpha} = (K + \\sigma_{\\mathrm{n}}^{2} I)^{-1} \\mathbf{y}_{\\text{train}}$。\n- 探针原子上的力是 GP 预测平均能量相对于探针原子坐标的负梯度，$\\mathbf{F} = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} m(\\mathbf{x}_{*})$。该梯度通过链式法则以及描述符 $\\mathbf{x}_{*}$ 对原子距离的依赖性，对核函数 $k(\\mathbf{x}_{*}, \\mathbf{x}_{i})$ 关于 $\\mathbf{r}_{\\mathrm{p}}$ 求导来计算。\n\n参数（请精确使用这些值和单位）：\n- 径向网格（单位：埃，Å）：$\\{ r_{g} \\}_{g=1}^{G} = \\{ 0.5, 1.0, 1.5, 2.0, 2.5 \\}$，因此 $G = 5$。\n- 高斯宽度（单位：Å）：$\\sigma = 0.25$。\n- 截断半径（单位：Å）：$r_{\\mathrm{c}} = 3.0$。\n- SOAP 核指数：$\\zeta = 2$。\n- GP 观测噪声标准差（单位：电子伏特，eV）：$\\sigma_{\\mathrm{n}} = 0.05$。\n\n包含三个环境的训练集（坐标单位：Å，能量单位：eV）：\n- 环境 1：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.0, 0.0, 0.0)$、$(-1.0, 0.0, 0.0)$、$(0.0, 1.5, 0.0)$，能量 $y_{1} = -0.80$。\n- 环境 2：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.3, 0.0, 0.0)$、$(0.0, 1.3, 0.0)$，能量 $y_{2} = -0.65$。\n- 环境 3：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(2.2, 0.0, 0.0)$、$(0.0, 2.0, 0.0)$、$(1.5, 1.5, 0.0)$，能量 $y_{3} = -1.10$。\n\n查询环境测试套件（坐标单位：Å）：\n- 情况 A（一般情况）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.2, 0.0, 0.0)$、$(0.0, 1.0, 0.0)$、$(-1.4, 0.0, 0.0)$。\n- 情况 B（接近截断边界）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(2.95, 0.0, 0.0)$、$(0.0, 2.80, 0.0)$。\n- 情况 C（力对称性边界情况）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.0, 0.0, 0.0)$、$(-1.0, 0.0, 0.0)$。\n\n您的程序必须：\n- 使用上述建模假设，为所有训练和查询环境构建简化的 SOAP 径向描述符。\n- 使用给定的指数 $\\zeta$ 构建训练环境上的 SOAP 核矩阵，并根据带有观测噪声 $\\sigma_{\\mathrm{n}}$ 的 GP 规则计算 $\\boldsymbol{\\alpha}$。\n- 对于每个查询环境，计算 GP 预测平均能量 $m(\\mathbf{x}_{*})$（单位：eV）和探针原子上的力矢量 $\\mathbf{F}$（单位：eV/Å），计算方法是对核函数关于探针原子坐标求导。\n- 使用一个光滑截断函数，该函数在距离严格小于 $r_{\\mathrm{c}}$ 时可微，在超出 $r_{\\mathrm{c}}$ 时为零；并使用以每个邻居距离为中心的高斯展宽应用在径向网格上。\n- 通过使用数学上合理的极限程序或不改变物理释义的微小正则化，确保在梯度计算中可能出现的 $d_{j} = 0$ 处的除零操作具有数值鲁棒性。\n\n不涉及角度单位。距离必须以 Å 为单位处理，能量以 eV 为单位。力必须以 eV/Å 表示。最终输出必须是实值浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由三个子列表组成的列表，每个子列表对应一个查询情况。每个子列表必须按顺序包含四个浮点数 $[ m, F_{x}, F_{y}, F_{z} ]$，其中 $m$ 是预测平均能量（eV），$(F_{x}, F_{y}, F_{z})$ 是力分量（eV/Å）。整个输出必须是一个用方括号括起来的逗号分隔列表，例如：$[ [ m_{A}, F_{x,A}, F_{y,A}, F_{z,A} ], [ m_{B}, F_{x,B}, F_{y,B}, F_{z,B} ], [ m_{C}, F_{x,C}, F_{y,C}, F_{z,C} ] ]$。\n\n程序必须完全自包含，无需用户输入，并严格遵守指定的执行环境。提供科学上合理的计算，并确保为每个测试用例返回的数值是浮点数。", "solution": "该问题要求使用一个基于简化的光滑原子位置重叠 (SOAP) 核函数的高斯过程 (GP) 回归模型，来计算位点能量和原子间力。解决方案分三个主要阶段执行：首先，通过计算描述符和相关的核矩阵来构建训练模型；其次，推导查询原子的预测能量和力的解析表达式；第三，将这些公式应用于指定的测试用例。\n\n### 1. 模型构建\n\n该模型的核心是通过一个描述符向量来表示局域原子环境，该向量作为核函数的输入。\n\n#### 1.1. 径向密度描述符\n\n对于一个以探针原子为中心（位置为 $\\mathbf{r}_{\\mathrm{p}}$），且拥有 $N_{\\mathrm{n}}$ 个邻居原子（位置为 $\\{\\mathbf{r}_{j}\\}$）的给定原子环境，我们首先计算径向距离集合 $d_{j} = \\|\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}\\|$。\n\n采用一个光滑截断函数 $f_c(d)$ 来确保相互作用在有限的截断半径 $r_{\\mathrm{c}} = 3.0 \\, \\text{Å}$ 处平滑衰减至零。一个在 $d=0$ 和 $d=r_{\\mathrm{c}}$ 处都连续可微 ($C^1$) 的 $f_c(d)$ 合适选择是基于余弦的函数：\n$$\nf_c(d) = \\begin{cases} \\frac{1}{2} \\left[ \\cos\\left(\\frac{\\pi d}{r_{\\mathrm{c}}}\\right) + 1 \\right]  \\text{if } d \\le r_{\\mathrm{c}} \\\\ 0  \\text{if } d  r_{\\mathrm{c}} \\end{cases}\n$$\n该函数的导数（用于计算力）为：\n$$\nf_c'(d) = \\begin{cases} -\\frac{\\pi}{2 r_{\\mathrm{c}}} \\sin\\left(\\frac{\\pi d}{r_{\\mathrm{c}}}\\right)  \\text{if } d \\le r_{\\mathrm{c}} \\\\ 0  \\text{if } d  r_{\\mathrm{c}} \\end{cases}\n$$\n\n简化的 SOAP 描述符是一个向量 $\\mathbf{x} \\in \\mathbb{R}^{G}$，表示一个离散化的径向密度。每个分量 $x_g$ 是密度在网格点 $r_g$ 上的值，该网格点来自集合 $\\{0.5, 1.0, 1.5, 2.0, 2.5\\} \\, \\text{Å}$。该密度是通过对以每个邻居距离 $d_j$ 为中心的高斯函数求和构建的，每个高斯函数都由截断函数加权。高斯宽度为 $\\sigma = 0.25 \\, \\text{Å}$，描述符的第 $g$ 个分量是：\n$$\nx_g = \\sum_{j=1}^{N_{\\mathrm{n}}} f_c(d_j) \\exp\\left(-\\frac{(r_g - d_j)^2}{2\\sigma^2}\\right)\n$$\n\n#### 1.2. SOAP 核函数\n\n两个原子环境之间的相似性由 SOAP 核函数度量，这两个环境由它们的描述符 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 表示。我们使用基于余弦相似度 $s(\\mathbf{x}_i, \\mathbf{x}_j)$ 的归一化多项式核：\n$$\nk(\\mathbf{x}_i, \\mathbf{x}_j) = s(\\mathbf{x}_i, \\mathbf{x}_j)^{\\zeta} = \\left( \\frac{\\mathbf{x}_i \\cdot \\mathbf{x}_j}{\\|\\mathbf{x}_i\\| \\|\\mathbf{x}_j\\|} \\right)^{\\zeta}\n$$\n其中指数给定为 $\\zeta = 2$。归一化确保了核函数对相同邻居的排列不变，并提供了一个鲁棒的相似性度量。为保证数值稳定性，如果一个描述符的范数 $\\|\\mathbf{x}\\|$ 为零（即所有邻居都在截断半径之外），则核函数值定义为 $0$。\n\n#### 1.3. 高斯过程回归\n\n位点能量 $E$ 被建模为一个高斯过程，即 $E(\\mathbf{x}) \\sim \\mathcal{GP}(m(\\mathbf{x}), k(\\mathbf{x}, \\mathbf{x}'))$。给定一个包含 $N=3$ 个环境的训练集，其描述符为 $\\{\\mathbf{x}_i\\}_{i=1}^N$，对应能量为 $\\mathbf{y}_{\\text{train}} = [y_1, y_2, y_3]^{\\top}$，对于一个描述符为 $\\mathbf{x}_{*}$ 的新查询环境，其 GP 预测平均能量为：\n$$\nm(\\mathbf{x}_{*}) = \\mathbf{k}_{*}^{\\top} \\boldsymbol{\\alpha}\n$$\n其中 $\\mathbf{k}_{*} \\in \\mathbb{R}^{N}$ 是查询环境与训练环境之间核相似度的向量，其元素为 $k_{*i} = k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。权重向量 $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{N}$ 通过求解线性系统得到：\n$$\n\\boldsymbol{\\alpha} = (K + \\sigma_{\\mathrm{n}}^{2} I)^{-1} \\mathbf{y}_{\\text{train}}\n$$\n这里，$K$ 是训练数据的 $N \\times N$ 格拉姆矩阵，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$，$I$ 是单位矩阵，$\\sigma_{\\mathrm{n}}^{2}$ 是观测噪声的方差，其中 $\\sigma_{\\mathrm{n}} = 0.05 \\, \\text{eV}$。$\\sigma_{\\mathrm{n}}^{2}I$ 项对矩阵进行正则化，确保其是良态且可逆的。\n\n### 2. 力的推导\n\n探针原子上的力是预测平均能量相对于探针原子位置 $\\mathbf{r}_{\\mathrm{p}}$ 的负梯度：\n$$\n\\mathbf{F} = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} m(\\mathbf{x}_{*}) = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\left( \\sum_{i=1}^{N} \\alpha_i k(\\mathbf{x}_{*}, \\mathbf{x}_i) \\right) = - \\sum_{i=1}^{N} \\alpha_i \\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)\n$$\n力计算的核心在于计算核函数 $k(\\mathbf{x}_{*}, \\mathbf{x}_i)$ 的梯度 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。由于只有查询描述符 $\\mathbf{x}_{*}$ 依赖于 $\\mathbf{r}_{\\mathrm{p}}$，我们应用链式法则。\n\n令 $s_{*} = s(\\mathbf{x}_{*}, \\mathbf{x}_i)$。核函数的梯度是：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i) = \\frac{\\partial k}{\\partial s_{*}} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*} = \\zeta s_{*}^{\\zeta-1} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*}\n$$\n接下来，我们求相似度 $s_{*} = \\frac{\\mathbf{x}_{*} \\cdot \\mathbf{x}_i}{\\|\\mathbf{x}_{*}\\| \\|\\mathbf{x}_i\\|}$ 的梯度。使用归一化向量 $\\hat{\\mathbf{x}}_{*} = \\mathbf{x}_{*}/\\|\\mathbf{x}_{*}\\|$ 和 $\\hat{\\mathbf{x}}_i = \\mathbf{x}_i/\\|\\mathbf{x}_i\\|$，我们有 $s_{*} = \\hat{\\mathbf{x}}_{*} \\cdot \\hat{\\mathbf{x}}_i$。梯度可以优雅地表示为：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*} = \\frac{1}{\\|\\mathbf{x}_{*}\\|} (\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*})^{\\top} (\\hat{\\mathbf{x}}_i - s_{*} \\hat{\\mathbf{x}}_{*})\n$$\n其中 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*}$ 是一个 $G \\times 3$ 的雅可比矩阵，其 $(g, \\beta)$ 元素为 $\\frac{\\partial x_{*g}}{\\partial r_{\\mathrm{p},\\beta}}$，其中 $\\beta \\in \\{x, y, z\\}$。\n\n最后一步是确定这个雅可比矩阵。描述符分量 $x_{*g}$ 对 $\\mathbf{r}_{\\mathrm{p}}$ 的导数，是通过对查询环境中每个邻居 $j$ 的贡献求和得到的：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} x_{*g} = \\sum_{j} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\left[ f_c(d_j) \\exp\\left(-\\frac{(r_g - d_j)^2}{2\\sigma^2}\\right) \\right]\n$$\n再次应用链式法则，$\\nabla_{\\mathbf{r}_{\\mathrm{p}}} (\\cdot) = \\frac{\\partial (\\cdot)}{\\partial d_j} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} d_j$。距离的梯度是 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} d_j = \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\|\\mathbf{r}_j - \\mathbf{r}_{\\mathrm{p}}\\| = -\\frac{\\mathbf{r}_j - \\mathbf{r}_{\\mathrm{p}}}{d_j}$。关于距离 $d_j$ 的导数是：\n$$\n\\frac{\\partial}{\\partial d_j} \\left[ f_c(d_j) e^{-\\frac{(r_g-d_j)^2}{2\\sigma^2}} \\right] = \\left( f_c'(d_j) + f_c(d_j) \\frac{r_g-d_j}{\\sigma^2} \\right) e^{-\\frac{(r_g-d_j)^2}{2\\sigma^2}}\n$$\n通过组合这些分量，我们可以计算每个核函数元素的梯度，并因此计算出总力矢量 $\\mathbf{F}$。在涉及 $d_j$ 或 $\\|\\mathbf{x}\\|$ 的分母中加入一个小的 epsilon，以防止在原子重叠或描述符为空的罕见情况下出现除零错误，从而确保数值稳定性。\n\n### 3. 实现总结\n\n算法流程如下：\n1.  **训练阶段**:\n    a. 对于 $N=3$ 个训练环境中的每一个，计算其 $G=5$ 维的描述符向量 $\\mathbf{x}_i$。\n    b. 构建 $3 \\times 3$ 的核矩阵 $K$，其中 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。\n    c. 将噪声项 $\\sigma_{\\mathrm{n}}^{2} = (0.05)^2$ 添加到 $K$ 的对角线上。\n    d. 求解线性系统 $(K + \\sigma_{\\mathrm{n}}^{2}I)\\boldsymbol{\\alpha} = \\mathbf{y}_{\\text{train}}$，得到权重 $\\boldsymbol{\\alpha}$。\n\n2.  **预测阶段**:\n    a. 对于三个查询环境中的每一个：\n    b. 计算查询描述符 $\\mathbf{x}_{*}$ 及其 $G \\times 3$ 的雅可比矩阵 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*}$。\n    c. 计算预测平均能量 $m(\\mathbf{x}_{*}) = \\sum_{i=1}^{N} \\alpha_i k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。\n    d. 使用推导出的解析表达式，通过对加权梯度求和 $-\\sum_{i=1}^{N} \\alpha_i \\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)$ 来计算力矢量 $\\mathbf{F}$。\n    e. 存储每个情况的结果 $[m, F_x, F_y, F_z]$。\n\n此过程被实现以生成指定查询案例的最终数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of predicting site energies and atomic forces using a \n    Gaussian Process model with a simplified SOAP kernel.\n    \"\"\"\n    \n    # --- Parameters (as defined in the problem) ---\n    R_GRID = np.array([0.5, 1.0, 1.5, 2.0, 2.5]) # Radial grid, Å\n    G_DIM = len(R_GRID)                         # Dimension of descriptor\n    SIGMA = 0.25                                # Gaussian width, Å\n    R_CUT = 3.0                                 # Cutoff radius, Å\n    ZETA = 2                                    # SOAP kernel exponent\n    SIGMA_N = 0.05                              # GP observation noise, eV\n    EPS = 1e-12                                 # Small epsilon for numerical stability\n\n    # --- Training Data ---\n    train_environments = [\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.0, 0.0, 0.0]), np.array([-1.0, 0.0, 0.0]), np.array([0.0, 1.5, 0.0])], 'energy': -0.80},\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.3, 0.0, 0.0]), np.array([0.0, 1.3, 0.0])], 'energy': -0.65},\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([2.2, 0.0, 0.0]), np.array([0.0, 2.0, 0.0]), np.array([1.5, 1.5, 0.0])], 'energy': -1.10}\n    ]\n    N_TRAIN = len(train_environments)\n    Y_TRAIN = np.array([env['energy'] for env in train_environments])\n\n    # --- Test (Query) Data ---\n    query_environments = [\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.2, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([-1.4, 0.0, 0.0])]}, # Case A\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([2.95, 0.0, 0.0]), np.array([0.0, 2.80, 0.0])]}, # Case B\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.0, 0.0, 0.0]), np.array([-1.0, 0.0, 0.0])]}, # Case C\n    ]\n\n    # --- Helper Functions ---\n\n    def cutoff_f(d, r_c):\n        \"\"\"Smooth cosine cutoff function.\"\"\"\n        return np.where(d = r_c, 0.5 * (np.cos(np.pi * d / r_c) + 1.0), 0.0)\n\n    def cutoff_f_prime(d, r_c):\n        \"\"\"Derivative of the smooth cosine cutoff function.\"\"\"\n        return np.where(d = r_c, -0.5 * (np.pi / r_c) * np.sin(np.pi * d / r_c), 0.0)\n\n    def compute_descriptor_and_grad(probe_pos, neighbors_pos, r_grid, sigma, r_c):\n        \"\"\"\n        Computes the radial descriptor and its gradient w.r.t. probe_pos.\n        Returns:\n            x (np.ndarray): Descriptor vector of shape (G_DIM,).\n            dx_drp (np.ndarray): Jacobian matrix of shape (G_DIM, 3).\n        \"\"\"\n        x = np.zeros(G_DIM)\n        dx_drp = np.zeros((G_DIM, 3))\n\n        for r_j in neighbors_pos:\n            vec_jp = r_j - probe_pos\n            d_j = np.linalg.norm(vec_jp)\n            \n            if d_j > r_c or d_j  EPS:\n                continue\n\n            # Unit vector from probe to neighbor\n            d_hat_j = vec_jp / (d_j + EPS)\n\n            # --- Density contribution from neighbor j ---\n            f_c_val = cutoff_f(d_j, r_c)\n            exp_term = np.exp(-(r_grid - d_j)**2 / (2 * sigma**2))\n            rho_j = f_c_val * exp_term\n            x += rho_j\n\n            # --- Gradient contribution from neighbor j ---\n            f_c_prime_val = cutoff_f_prime(d_j, r_c)\n            d_rho_j_dd_j = (f_c_prime_val + f_c_val * (r_grid - d_j) / sigma**2) * exp_term\n            \n            # Chain rule: grad_rp(rho) = (d(rho)/d(d_j)) * grad_rp(d_j)\n            # grad_rp(d_j) = -vec_jp / d_j = -d_hat_j\n            grad_rp_rho_j = -np.outer(d_rho_j_dd_j, d_hat_j)\n            dx_drp += grad_rp_rho_j\n\n        return x, dx_drp\n\n    def soap_kernel(x1, x2, zeta):\n        \"\"\"Computes the SOAP kernel between two descriptors.\"\"\"\n        norm1 = np.linalg.norm(x1)\n        norm2 = np.linalg.norm(x2)\n        \n        if norm1  EPS or norm2  EPS:\n            return 0.0\n            \n        similarity = np.dot(x1, x2) / (norm1 * norm2)\n        # Clip similarity to avoid numerical issues with arccos domain for debug, or for powers\n        similarity = np.clip(similarity, -1.0, 1.0)\n        return similarity**zeta\n\n    # --- 1. Training Phase ---\n    \n    train_descriptors = []\n    for env in train_environments:\n        desc, _ = compute_descriptor_and_grad(env['probe'], env['neighbors'], R_GRID, SIGMA, R_CUT)\n        train_descriptors.append(desc)\n\n    K = np.zeros((N_TRAIN, N_TRAIN))\n    for i in range(N_TRAIN):\n        for j in range(N_TRAIN):\n            K[i, j] = soap_kernel(train_descriptors[i], train_descriptors[j], ZETA)\n            \n    K_reg = K + np.eye(N_TRAIN) * (SIGMA_N**2)\n\n    # Solve for alpha weights\n    alpha = np.linalg.solve(K_reg, Y_TRAIN)\n    \n    # --- 2. Prediction Phase ---\n    \n    results = []\n    for query_env in query_environments:\n        # a. Compute query descriptor and its gradient\n        x_star, dx_star_drp = compute_descriptor_and_grad(query_env['probe'], query_env['neighbors'], R_GRID, SIGMA, R_CUT)\n\n        # b. Compute predictive mean energy\n        k_star = np.array([soap_kernel(x_star, x_i, ZETA) for x_i in train_descriptors])\n        energy = np.dot(k_star, alpha)\n\n        # c. Compute force\n        force = np.zeros(3)\n        norm_x_star = np.linalg.norm(x_star)\n        \n        if norm_x_star  EPS:\n            results.append([energy, 0.0, 0.0, 0.0])\n            continue\n\n        x_hat_star = x_star / norm_x_star\n        \n        for i in range(N_TRAIN):\n            x_i = train_descriptors[i]\n            norm_x_i = np.linalg.norm(x_i)\n            \n            if norm_x_i  EPS:\n                continue\n\n            x_hat_i = x_i / norm_x_i\n            s = np.dot(x_hat_star, x_hat_i)\n            s = np.clip(s, -1.0, 1.0)\n\n            # Gradient of similarity: grad_s = (1/norm_x_star) * (dx_star_drp)^T * (x_hat_i - s * x_hat_star)\n            grad_s = (1.0 / norm_x_star) * dx_star_drp.T @ (x_hat_i - s * x_hat_star)\n            \n            # Gradient of kernel: grad_k = zeta * s^(zeta-1) * grad_s\n            # Handle s=0 case for zeta-1 > 0, although here zeta=2, so it's fine.\n            if abs(s)  EPS and ZETA > 1:\n                grad_k = np.zeros(3)\n            else:\n                grad_k = ZETA * (s**(ZETA - 1)) * grad_s\n            \n            force -= alpha[i] * grad_k\n            \n        results.append([energy] + force.tolist())\n\n    # --- Final Output Formatting ---\n    sublist_strs = [f\"[{','.join(f'{val:.8f}' for val in sublist)}]\" for sublist in results]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3468379"}]}