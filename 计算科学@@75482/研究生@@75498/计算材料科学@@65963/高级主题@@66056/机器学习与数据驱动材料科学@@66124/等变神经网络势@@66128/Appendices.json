{"hands_on_practices": [{"introduction": "为什么等变性如此重要？理论学习的最佳方式之一就是观察不满足该性质的模型会如何失效。本练习将通过一个具体的反例，帮助你理解在原子系统中强制执行旋转对称性的必要性。你将构建一个简单的、非等变的人工神经网络，并定量地展示其预测的力如何在坐标旋转下违反了物理上必需的协变性[@problem_id:3449440]。", "problem": "考虑一个计算材料科学的场景，其中原子间力由一个学习的能量模型预测。在一个物理上有效的模型中，力必须满足旋转协变性：如果一个构型绕单位轴 $\\hat{\\mathbf{a}}$ 旋转角度 $\\theta$，那么力矢量也必须经过相同的刚体旋转。一个将原始笛卡尔坐标直接映射到标量能量而不构建旋转不变特征的学习能量模型可能是非等变的，并产生违反旋转协变性的力，即使在底层物理需要协变性的情况下也是如此。目标是构造一个最小的、明确的反例，并在指定的测试旋转下量化协变误差。\n\n从以下基本基础出发：\n- 经典力学中的旋转对称性：描述一个没有外场的孤立系统的标量能量 $E$ 必须在刚性旋转下保持不变；由 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$ 定义的力必须在旋转下作为协变矢量进行变换。\n- 多变量微积分的链式法则：如果 $\\mathbf{y} = \\mathbf{R}\\mathbf{x}$，其中 $\\mathbf{R}$ 是三维特殊正交群中的一个正交旋转矩阵，那么梯度的变换方式由雅可比矩阵决定。\n\n定义一个直接依赖于原始笛卡尔坐标的非等变人工神经网络（ANN）能量模型。对于一个由 $N$ 个原子组成的系统，其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，通过拼接将坐标堆叠成一个单一向量 $\\mathbf{x} \\in \\mathbb{R}^{3N}$。设能量定义为\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c,\n$$\n其中 $H$ 是隐藏单元的数量，$\\mathbf{w}_h \\in \\mathbb{R}^{3N}$ 是权重矩阵 $W_1 \\in \\mathbb{R}^{H \\times 3N}$ 的行向量，$b_h \\in \\mathbb{R}$ 是偏置，$\\alpha_h \\in \\mathbb{R}$ 是输出权重，$c \\in \\mathbb{R}$ 是一个标量偏移。这个ANN被刻意构造成非等变的：它在原始笛卡尔坐标上使用各向异性权重，没有任何保持对称性的架构。\n\n力定义为能量相对于堆叠坐标的负梯度：\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x}) \\in \\mathbb{R}^{3N}.\n$$\n当一个构型绕轴 $\\hat{\\mathbf{a}}$ 旋转角度 $\\theta$ 时，令 $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}}) \\in \\mathbb{R}^{3 \\times 3}$ 为相应的旋转矩阵。旋转后的构型为 $\\mathbf{x}_{\\mathrm{rot}} = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{x}$，其中 $\\mathrm{I}_N$ 是 $N \\times N$ 单位矩阵，$\\otimes$ 表示克罗内克积。一个旋转协变模型应满足\n$$\n\\mathbf{F}_{\\mathrm{cov}}(\\mathbf{x}_{\\mathrm{rot}}) = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}),\n$$\n但这个非等变的ANN通常不会满足此条件。\n\n通过相对误差来量化旋转协变性违规：\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) \\right\\|_2, \\epsilon\\big)},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\epsilon$ 是一个小的正常数，用于避免除以零。在本练习中，所有量都是无量纲的。\n\n使用以下具有 $N=3$ 个原子的显式、固定分子构型：\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}.\n$$\n按 $\\mathbf{r}_1$、$\\mathbf{r}_2$、$\\mathbf{r}_3$ 的顺序将它们拼接成 $\\mathbf{x} \\in \\mathbb{R}^{9}$。\n\n使用以下ANN参数，其中 $H=3$ 且 $3N=9$：\n$$\nW_1 = \\begin{bmatrix}\n0.8  -0.4  0.2  0.1  0.6  -0.3  -0.5  0.7  -0.2 \\\\\n-0.3  0.9  -0.6  0.4  -0.1  0.5  0.2  -0.8  0.3 \\\\\n0.5  0.2  0.7  -0.9  0.3  -0.4  0.6  -0.1  0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1.\n$$\n\n通过使用单位轴 $\\hat{\\mathbf{a}}$ 和角度 $\\theta$（以弧度为单位）的罗德里格斯旋转公式来实现 $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}})$。\n\n测试套件：\n为以下五个情况计算 $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$，这些情况共同探测了正常路径、边界条件和一般轴：\n- 情况 1：$\\theta = 0$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 2：$\\theta = \\pi/6$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 3：$\\theta = \\pi/2$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 4：$\\theta = \\pi$，$\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$。\n- 情况 5：$\\theta = \\pi/3$，$\\hat{\\mathbf{a}} = \\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}$。\n\n答案规格和输出格式：\n- 对于每个测试用例，返回一个等于 $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$ 的浮点数。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $\\big[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5\\big]$。\n- 角度必须以弧度解释。不使用物理单位；所有量都是无量纲的。", "solution": "该问题要求计算一个非等变神经网络势的旋转协变误差。解决方案首先从给定的能量模型中推导出原子间力的解析表达式，然后实现旋转操作，最后为一组测试用例计算指定的误差度量。\n\n### 步骤1：系统与模型定义\n\n该系统包含 $N=3$ 个原子，其初始笛卡尔坐标为 $\\mathbf{r}_i \\in \\mathbb{R}^3$：\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}\n$$\n这些坐标被拼接成一个单一的状态向量 $\\mathbf{x} \\in \\mathbb{R}^{3N} = \\mathbb{R}^9$：\n$$\n\\mathbf{x} = \\begin{bmatrix} \\mathbf{r}_1 \\\\ \\mathbf{r}_2 \\\\ \\mathbf{r}_3 \\end{bmatrix} = \\begin{bmatrix} 0.0, 0.0, 0.0, 1.2, 0.5, -0.3, -0.8, -1.0, 0.7 \\end{bmatrix}^\\top\n$$\n能量 $E(\\mathbf{x})$ 由一个具有 $H=3$ 个隐藏单元的单隐藏层人工神经网络（ANN）定义：\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c\n$$\n这里，$\\mathbf{w}_h^\\top$ 代表权重矩阵 $W_1 \\in \\mathbb{R}^{H \\times 3N}$ 的第 $h$ 行。给定的参数是：\n$$\nW_1 = \\begin{bmatrix}\n0.8  -0.4  0.2  0.1  0.6  -0.3  -0.5  0.7  -0.2 \\\\\n-0.3  0.9  -0.6  0.4  -0.1  0.5  0.2  -0.8  0.3 \\\\\n0.5  0.2  0.7  -0.9  0.3  -0.4  0.6  -0.1  0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1\n$$\n\n### 步骤2：力矢量的推导\n\n力矢量 $\\mathbf{F}(\\mathbf{x}) \\in \\mathbb{R}^{3N}$ 是标量能量 $E(\\mathbf{x})$ 相对于坐标 $\\mathbf{x}$ 的负梯度：\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x})\n$$\n我们使用链式法则来计算梯度。令第 $h$ 个隐藏单元的激活前值为 $u_h(\\mathbf{x}) = \\mathbf{w}_h^\\top \\mathbf{x} + b_h$。能量的梯度是：\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\left( \\sum_{h=1}^{H} \\alpha_h \\tanh(u_h(\\mathbf{x})) + c \\right) = \\sum_{h=1}^{H} \\alpha_h \\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x})))\n$$\n对每一项应用链式法则：\n$$\n\\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x}))) = \\frac{d}{du_h}(\\tanh(u_h)) \\cdot \\nabla_{\\mathbf{x}} u_h\n$$\n$\\tanh$ 的导数是 $\\text{sech}^2(u_h)$，可以表示为 $1 - \\tanh^2(u_h)$。$u_h$ 的梯度是 $\\nabla_{\\mathbf{x}} (\\mathbf{w}_h^\\top \\mathbf{x} + b_h) = \\mathbf{w}_h$。将这些代回可得：\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\n因此，力矢量为：\n$$\n\\mathbf{F}(\\mathbf{x}) = - \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\n用矩阵表示法，这可以更紧凑地写为：\n$$\n\\mathbf{F}(\\mathbf{x}) = -W_1^\\top \\big( \\boldsymbol{\\alpha} \\odot \\text{sech}^2(W_1 \\mathbf{x} + \\mathbf{b}_1) \\big)\n$$\n其中 $\\odot$ 表示逐元素（哈达玛）积。此表达式为计算任何给定构型 $\\mathbf{x}$ 的力矢量提供了一种直接方法。\n\n### 步骤3：旋转算子\n\n在 $\\mathbb{R}^3$ 中绕单位轴 $\\hat{\\mathbf{a}}$ 旋转角度 $\\theta$ 的操作由一个 $3 \\times 3$ 矩阵 $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$ 表示，该矩阵使用罗德里格斯旋转公式构造：\n$$\n\\mathbf{R}(\\theta, \\hat{\\mathbf{a}}) = \\mathbf{I}_3 + \\sin(\\theta)\\mathbf{K} + (1 - \\cos(\\theta))\\mathbf{K}^2\n$$\n其中 $\\mathbf{I}_3$ 是 $3 \\times 3$ 单位矩阵，$\\mathbf{K}$ 是 $\\hat{\\mathbf{a}} = [a_x, a_y, a_z]^\\top$ 的叉积矩阵：\n$$\n\\mathbf{K} = \\begin{bmatrix} 0  -a_z  a_y \\\\ a_z  0  -a_x \\\\ -a_y  a_x  0 \\end{bmatrix}\n$$\n为了旋转整个 $N$-原子系统，我们将此旋转应用于每个原子的坐标矢量。这可以通过使用由克罗内克积形成的块对角矩阵来实现：\n$$\n\\mathbf{R}_{\\text{block}} = \\mathbf{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})\n$$\n对于 $N=3$，这将产生一个 $9 \\times 9$ 的矩阵。\n\n### 步骤4：协变误差的公式化\n\n问题的核心是量化旋转协变性的违规程度。旋转后的构型为 $\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$。在此新构型上计算出的力为 $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$。\n\n对于一个真正协变的模型，力矢量会随系统刚性旋转。正确变换后的力矢量，记为 $\\mathbf{F}_{\\mathrm{cov}}$，是通过将相同的旋转应用于原始力矢量得到的：\n$$\n\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})\n$$\n旋转协变误差 $\\varepsilon$ 是在旋转系统上计算的力 $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$ 与旋转后的原始力 $\\mathbf{F}_{\\mathrm{cov}}$ 之间的相对差异：\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| \\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| \\mathbf{F}_{\\mathrm{cov}} \\right\\|_2, \\epsilon\\big)}\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\epsilon$ 是一个小的正常数（例如 $10^{-9}$），用于防止除以零或接近零的数。\n\n### 步骤5：计算算法\n\n对于每个测试用例 $(\\theta, \\hat{\\mathbf{a}})$：\n1.  使用步骤2中推导的解析公式计算原始力矢量 $\\mathbf{F}(\\mathbf{x})$。\n2.  使用罗德里格斯公式构造 $3 \\times 3$ 旋转矩阵 $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$。\n3.  构造 $9 \\times 9$ 块旋转矩阵 $\\mathbf{R}_{\\text{block}} = \\mathbf{I}_3 \\otimes \\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$。\n4.  计算正确变换后的力矢量：$\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})$。\n5.  计算旋转后的坐标矢量：$\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$。\n6.  计算旋转构型上的力矢量：$\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$。\n7.  计算差值的L2范数：$\\|\\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})\\|_2$。\n8.  计算参考力的L2范数：$\\|\\mathbf{F}_{\\mathrm{cov}}\\|_2$。\n9.  使用步骤4中的公式计算最终误差 $\\varepsilon$。\n\n此过程将针对五个指定的测试用例执行。$\\theta=0$ 的情况用作合理性检查，因为它对应于单位旋转，必须产生0的误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the rotational covariance error for a non-equivariant ANN potential.\n    \"\"\"\n    \n    # --- Step 1: Define Givens (System and Model Parameters) ---\n    N = 3\n    \n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.2, 0.5, -0.3])\n    r3 = np.array([-0.8, -1.0, 0.7])\n    x = np.concatenate((r1, r2, r3))\n\n    W1 = np.array([\n        [0.8, -0.4, 0.2, 0.1, 0.6, -0.3, -0.5, 0.7, -0.2],\n        [-0.3, 0.9, -0.6, 0.4, -0.1, 0.5, 0.2, -0.8, 0.3],\n        [0.5, 0.2, 0.7, -0.9, 0.3, -0.4, 0.6, -0.1, 0.8]\n    ])\n\n    b1 = np.array([0.1, -0.2, 0.05])\n    alpha = np.array([1.2, -0.7, 0.9])\n    \n    # Small constant for denominator stabilization, as per the problem statement\n    epsilon_small = 1e-9\n\n    # --- Step 2: Define Helper Functions ---\n    \n    def calculate_force(pos_vec):\n        \"\"\"\n        Calculates the force F(x) = -nabla_x E(x) based on the derived formula.\n        \"\"\"\n        # u = W1 @ x + b1\n        u = W1 @ pos_vec + b1\n        \n        # sech^2(u) = 1 - tanh^2(u)\n        tanh_u = np.tanh(u)\n        sech_sq_u = 1.0 - tanh_u**2\n        \n        # v = alpha .* sech^2(u)\n        v = alpha * sech_sq_u\n        \n        # gradient = W1^T @ v\n        gradient = W1.T @ v\n        \n        force = -gradient\n        return force\n\n    def rodrigues_rotation(theta, axis):\n        \"\"\"\n        Computes the 3x3 rotation matrix R(theta, a_hat) via Rodrigues' formula.\n        \"\"\"\n        # Ensure the axis is a unit vector\n        axis = axis / np.linalg.norm(axis)\n        ax, ay, az = axis\n        \n        K = np.array([\n            [0, -az, ay],\n            [az, 0, -ax],\n            [-ay, ax, 0]\n        ])\n        \n        I = np.eye(3)\n        R = I + np.sin(theta) * K + (1 - np.cos(theta)) * (K @ K)\n        return R\n\n    # --- Step 3: Define Test Suite ---\n    test_cases = [\n        # Case 1: theta = 0, a_hat = [0, 0, 1]\n        (0.0, np.array([0.0, 0.0, 1.0])),\n        # Case 2: theta = pi/6, a_hat = [0, 0, 1]\n        (np.pi / 6, np.array([0.0, 0.0, 1.0])),\n        # Case 3: theta = pi/2, a_hat = [0, 0, 1]\n        (np.pi / 2, np.array([0.0, 0.0, 1.0])),\n        # Case 4: theta = pi, a_hat = [0, 0, 1]\n        (np.pi, np.array([0.0, 0.0, 1.0])),\n        # Case 5: theta = pi/3, a_hat = [1, 1, 1] / sqrt(3)\n        (np.pi / 3, np.array([1.0, 1.0, 1.0]) / np.sqrt(3))\n    ]\n\n    results = []\n\n    # --- Step 4: Execute Test Cases and Calculate Error ---\n    for theta, a_hat in test_cases:\n        # Calculate force on the original configuration\n        F_x = calculate_force(x)\n\n        # Construct the rotation matrices\n        R_3x3 = rodrigues_rotation(theta, a_hat)\n        R_block = np.kron(np.eye(N), R_3x3)\n\n        # Calculate the covariantly transformed force\n        F_cov = R_block @ F_x\n\n        # Calculate the rotated configuration\n        x_rot = R_block @ x\n\n        # Calculate the force on the rotated configuration\n        F_x_rot = calculate_force(x_rot)\n\n        # Calculate the error numerator and denominator\n        numerator = np.linalg.norm(F_cov - F_x_rot)\n        denominator = np.linalg.norm(F_cov)\n        \n        # Calculate the relative error\n        error = numerator / max(denominator, epsilon_small)\n        results.append(error)\n        \n    # --- Step 5: Format and Print Final Answer ---\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```", "id": "3449440"}, {"introduction": "在理解了等变性的必要性之后，我们来探索其核心数学机制。等变神经网络的关键在于使用根据旋转群的不可约表示（irreps）进行变换的特征，而球谐函数（spherical harmonics, $Y_{\\ell m}$）正是构建这些特征的基石。本练习将引导你通过数值计算，直接验证一个由球谐函数构建的矢量特征（秩为1，即 $\\ell=1$）是如何在旋转操作下，严格遵循其对应的维格纳D矩阵（Wigner $D$-matrix）所描述的变换法则的[@problem_id:3449495]。", "problem": "要求您通过直接数值计算，验证一个由复球谐函数构建的秩-$1$（向量）特征在刚性旋转下的等变变换。计算将在三维特殊正交群 (SO(3)) 中进行，并使用 $Z\\text{-}Y\\text{-}Z$ 欧拉角约定。\n\n定义与基本依据：\n- 令 $\\hat{\\mathbf{r}} = (x,y,z)/\\|\\,(x,y,z)\\,\\|$ 为 $\\mathbb{R}^3$ 中的一个单位方向。通过 $\\theta = \\arccos(z)$ 和 $\\phi = \\operatorname{atan2}(y,x)$ 定义球面角 $\\theta \\in [0,\\pi]$ 和 $\\phi \\in [0,2\\pi)$。\n- 令 $Y_{\\ell m}(\\theta,\\phi)$ 为复球谐函数，其采用 Condon–Shortley 相位和物理学约定（磁量子数 $m$ 作为第一个参数），其中 $\\ell \\in \\mathbb{N}_0$ 且 $m \\in \\{-\\ell,\\ldots,\\ell\\}$。\n- 对于一个具有实数权重 $\\{w_i\\}_{i=1}^{N}$ 的有限邻近方向集合 $\\{\\hat{\\mathbf{r}}_i\\}_{i=1}^{N}$，定义 $\\ell=1$ 特征向量，其分量为\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i),\n\\quad m \\in \\{1,0,-1\\},\n$$\n其中 $(\\theta_i,\\phi_i)$ 是 $\\hat{\\mathbf{r}}_i$ 的球面角。\n- 令一个旋转 $R \\in \\mathrm{SO}(3)$ 由 $Z\\text{-}Y\\text{-}Z$ 欧拉角 $(\\alpha,\\beta,\\gamma)$（以弧度为单位）参数化。在 $\\ell=1$ 不可约表示中，相关的 Wigner D-矩阵 $D^{(1)}(R)\\in \\mathbb{C}^{3\\times 3}$（其行和列按 $m=1,0,-1$ 的顺序排列）为\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma},\n$$\n其中 $\\ell=1$ 的 Wigner 小-$d$ 矩阵元素为\n$$\n\\begin{aligned}\nd^{(1)}_{1,1}(\\beta) = \\tfrac{1+\\cos\\beta}{2}, \\quad \nd^{(1)}_{1,0}(\\beta) = -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{1,-1}(\\beta) = \\tfrac{1-\\cos\\beta}{2}, \\\\\nd^{(1)}_{0,1}(\\beta) = \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{0,0}(\\beta) = \\cos\\beta, \\quad \nd^{(1)}_{0,-1}(\\beta) = -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\\\\nd^{(1)}_{-1,1}(\\beta) = \\tfrac{1-\\cos\\beta}{2}, \\quad \nd^{(1)}_{-1,0}(\\beta) = \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad \nd^{(1)}_{-1,-1}(\\beta) = \\tfrac{1+\\cos\\beta}{2}.\n\\end{aligned}\n$$\n- 基本变换定律：对于方向的主动旋转 $\\hat{\\mathbf{r}}_i \\mapsto R\\,\\hat{\\mathbf{r}}_i$，球谐函数满足\n$$\nY_{1m}(\\widehat{R\\,\\mathbf{r}}) \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1}) \\, Y_{1m'}(\\hat{\\mathbf{r}}),\n$$\n这意味着等变特征的变换方式为\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\, F_{m'},\n$$\n其中 $F^{\\mathrm{rot}}_m$ 是由旋转后的邻近方向构建的。角度必须以弧度为单位。\n\n您的任务：\n- 实现一个程序，对于下方的每个测试用例，该程序需要：从提供的邻近点和权重构建 $F$，通过指定的旋转 $R$（使用 $Z\\text{-}Y\\text{-}Z$ 约定）旋转所有邻近方向，从旋转后的方向构建 $F^{\\mathrm{rot}}$，计算 $D^{(1)}(R)$，然后构成 $D^{(1)}(R^{-1}) = \\left(D^{(1)}(R)\\right)^{\\dagger}$，最后报告逐分量的最大绝对偏差\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|.\n$$\n- 所有计算必须使用上述定义。在提取 $(\\theta,\\phi)$ 之前，必须将邻近方向向量归一化为单位长度。三角函数和球谐函数必须使用弧度。偏差 $\\varepsilon$ 是一个非负实数浮点数。\n\n测试套件（请精确使用以下三个用例）：\n- 用例 $1$（一般旋转）：\n  - 邻近点（每个点格式为 $(x,y,z)$）：$(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(-1,-1,1)$。\n  - 权重：$[1.0,\\,0.5,\\,-0.7,\\,1.2]$。\n  - 欧拉角 $(\\alpha,\\beta,\\gamma)$（以弧度为单位）：$(0.7,\\,1.1,\\,-0.4)$。\n- 用例 $2$（单位旋转边界）：\n  - 邻近点：$(2,1,0)$, $(0,-3,1)$, $(-1,0,2)$, $(1,-1,-1)$。\n  - 权重：$[1.0,\\,-0.3,\\,2.0,\\,-1.0]$。\n  - 欧拉角：$(0.0,\\,0.0,\\,0.0)$。\n- 用例 $3$（绕 z 轴旋转 $\\pi$ 的纯旋转）：\n  - 邻近点：$(1.0,\\,0.0,\\,0.2)$, $(0.3,\\,0.953939,\\,-0.4)$, $(-0.588,\\,-0.809,\\,0.7)$。\n  - 权重：$[0.8,\\,-1.1,\\,0.6]$。\n  - 欧拉角：$(\\pi,\\,0.0,\\,0.0)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果。结果应是按用例 1、2、3 的顺序排列、用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_k$ 是用例 $k$ 的浮点数 $\\varepsilon$。", "solution": "用户要求对一个由复球谐函数构建的秩-1 特征向量的旋转等变性质进行数值验证。该问题是良定的，其科学依据在于旋转群 $\\mathrm{SO}(3)$ 的表示论，并为获得唯一解提供了所有必要的定义和数据。\n\n核心任务是为三个测试用例计算偏差 $\\varepsilon$，其中 $\\varepsilon$ 定义为：\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|\n$$\n这涉及对变换后的特征向量进行两种独立的计算：\n$1$. “直接”变换 $F^{\\mathrm{rot}}$：首先在 $\\mathbb{R}^3$ 中旋转输入坐标，然后对这些新坐标执行特征向量构建流程来计算。\n$2$. “等变”变换，我们可以表示为 $F^{\\mathrm{equiv}}$：通过将相应的 Wigner D-矩阵 $D^{(1)}(R^{-1})$ 应用于原始特征向量 $F$ 来计算。\n\n验证过程在于证明 $F^{\\mathrm{rot}}$ 和 $F^{\\mathrm{equiv}}$ 在浮点精度范围内是数值上相同的。值 $\\varepsilon$ 量化了它们的差异。\n\n每个测试用例的计算步骤如下：\n\n**步骤 1：球谐函数的实现**\n特征向量依赖于角动量 $\\ell=1$ 的复球谐函数。遵循 Condon–Shortley 相位约定，所需的函数为：\n$$\n\\begin{aligned}\nY_{1,1}(\\theta, \\phi) = -\\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{i\\phi} \\\\\nY_{1,0}(\\theta, \\phi) = \\sqrt{\\frac{3}{4\\pi}} \\cos\\theta \\\\\nY_{1,-1}(\\theta, \\phi) = \\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{-i\\phi}\n\\end{aligned}\n$$\n这些函数以弧度为单位的球面角 $(\\theta, \\phi)$ 作为输入。\n\n**步骤 2：坐标和特征向量计算（旋转前）**\n对于给定的邻近向量集合 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ 和权重集合 $\\{w_i\\}_{i=1}^{N}$：\n$1$. 归一化每个邻近向量：$\\hat{\\mathbf{r}}_i = \\mathbf{r}_i / \\|\\mathbf{r}_i\\|$。\n$2$. 将每个 $\\hat{\\mathbf{r}}_i$ 的笛卡尔坐标 $(x_i, y_i, z_i)$ 转换为球面坐标 $(\\theta_i, \\phi_i)$。给定 $\\hat{\\mathbf{r}}_i=(x_i,y_i,z_i)$，转换公式为 $\\theta_i = \\arccos(z_i)$ 和 $\\phi_i = \\operatorname{atan2}(y_i, x_i)$。\n$3$. 构建原始特征向量 $F$，它是一个由 $m \\in \\{1, 0, -1\\}$ 索引的 3 分量复向量。其分量为：\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i)\n$$\n\n**步骤 3：直接变换（在 $\\mathbb{R}^3$ 中旋转）**\n$1$. 根据给定的 $Z\\text{-}Y\\text{-}Z$ 欧拉角 $(\\alpha, \\beta, \\gamma)$ 构建笛卡尔旋转矩阵 $R(\\alpha, \\beta, \\gamma) \\in \\mathrm{SO}(3)$。该矩阵是乘积 $R = R_z(\\alpha) R_y(\\beta) R_z(\\gamma)$，其中 $R_z$ 和 $R_y$ 是绕相应坐标轴的标准旋转矩阵。\n$2$. 将此旋转应用于每个原始单位向量：$\\hat{\\mathbf{r}}_i^{\\mathrm{rot}} = R\\,\\hat{\\mathbf{r}}_i$。\n$3$. 将每个 $\\hat{\\mathbf{r}}_i^{\\mathrm{rot}}$ 的所得笛卡尔坐标转换为一组新的球面坐标 $(\\theta_i^{\\mathrm{rot}}, \\phi_i^{\\mathrm{rot}})$。\n$4$. 使用这些新的球面坐标和原始权重构建旋转后的特征向量 $F^{\\mathrm{rot}}$：\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i^{\\mathrm{rot}},\\phi_i^{\\mathrm{rot}})\n$$\n\n**步骤 4：等变变换（在表示空间中旋转）**\n$1$. 使用欧拉角 $(\\alpha, \\beta, \\gamma)$ 构建 $\\ell=1$ 的 Wigner D-矩阵 $D^{(1)}(R) \\in \\mathbb{C}^{3\\times 3}$。其元素由下式给出：\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma}\n$$\n矩阵的行和列按 $m, m' \\in \\{1, 0, -1\\}$ 的顺序排列。小-d 矩阵元素 $d^{(1)}_{mm'}(\\beta)$ 在问题陈述中已提供。\n$2$. 变换定律需要逆旋转 $R^{-1}$ 的矩阵。对于 $\\mathrm{SO}(3)$ 的酉表示，这是正向旋转矩阵的共轭转置：$D^{(1)}(R^{-1}) = (D^{(1)}(R))^{\\dagger}$。\n$3. $通过矩阵-向量乘法将此变换应用于原始特征向量 $F$，以获得等变变换后的向量 $F^{\\mathrm{equiv}}$：\n$$\nF^{\\mathrm{equiv}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'}\n$$\n\n**步骤 5：偏差计算**\n最后，计算两个结果向量 $F^{\\mathrm{rot}}$ 和 $F^{\\mathrm{equiv}}$ 分量之间的最大绝对差：\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m - F^{\\mathrm{equiv}}_m \\,\\right|\n$$\n如果实现正确，该值应接近机器精度（例如，$\\approx 10^{-15}$），从而证实等变性质。以下程序为三个指定的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Verifies the equivariant transformation of a rank-1 spherical harmonic feature.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, -1.0, 1.0]]),\n            \"weights\": np.array([1.0, 0.5, -0.7, 1.2]),\n            \"euler_angles\": np.array([0.7, 1.1, -0.4]),\n        },\n        {\n            \"neighbors\": np.array([[2.0, 1.0, 0.0], [0.0, -3.0, 1.0], [-1.0, 0.0, 2.0], [1.0, -1.0, -1.0]]),\n            \"weights\": np.array([1.0, -0.3, 2.0, -1.0]),\n            \"euler_angles\": np.array([0.0, 0.0, 0.0]),\n        },\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.2], [0.3, 0.953939, -0.4], [-0.588, -0.809, 0.7]]),\n            \"weights\": np.array([0.8, -1.1, 0.6]),\n            \"euler_angles\": np.array([np.pi, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    \n    # m-values ordering for feature vectors and Wigner matrices\n    m_vals = np.array([1, 0, -1])\n\n    def get_spherical_harmonics_l1(theta, phi):\n        \"\"\"\n        Computes Y_1m(theta, phi) for m=1,0,-1.\n        Vectorized over theta and phi.\n        \"\"\"\n        c1 = np.sqrt(3 / (8 * np.pi))\n        c0 = np.sqrt(3 / (4 * np.pi))\n        \n        sin_theta = np.sin(theta)\n        cos_theta = np.cos(theta)\n        \n        y11 = -c1 * sin_theta * np.exp(1j * phi)\n        y10 =  c0 * cos_theta\n        y1m1 = c1 * sin_theta * np.exp(-1j * phi)\n        \n        # Return in order m=1, 0, -1\n        return np.array([y11, y10, y1m1])\n\n    def get_feature_vector(neighbors, weights):\n        \"\"\"\n        Computes the feature vector F_m from neighbors and weights.\n        \"\"\"\n        norms = np.linalg.norm(neighbors, axis=1)\n        unit_vectors = neighbors / norms[:, np.newaxis]\n        \n        x, y, z = unit_vectors.T\n        \n        theta = np.arccos(z)\n        phi = np.arctan2(y, x)\n        \n        y1m_vals = get_spherical_harmonics_l1(theta, phi) # Shape (3, N)\n        \n        # F_m = sum_i w_i Y_1m(theta_i, phi_i)\n        # weights are (N,), y1m_vals are (3, N), broadcasting does the trick\n        F = np.sum(weights * y1m_vals, axis=1) # Shape (3,)\n        return F, unit_vectors\n\n    def get_rotation_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Z-Y-Z Euler rotation matrix.\n        \"\"\"\n        ca, sa = np.cos(alpha), np.sin(alpha)\n        cb, sb = np.cos(beta), np.sin(beta)\n        cg, sg = np.cos(gamma), np.sin(gamma)\n        \n        Rz_a = np.array([[ca, -sa, 0], [sa, ca, 0], [0, 0, 1]])\n        Ry_b = np.array([[cb, 0, sb], [0, 1, 0], [-sb, 0, cb]])\n        Rz_g = np.array([[cg, -sg, 0], [sg, cg, 0], [0, 0, 1]])\n        \n        return Rz_a @ Ry_b @ Rz_g\n\n    def get_wigner_d1_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Wigner D-matrix for l=1.\n        Rows/cols are ordered by m=1, 0, -1.\n        \"\"\"\n        cb, sb = np.cos(beta), np.sin(beta)\n        sqrt2 = np.sqrt(2)\n        \n        # Wigner small-d matrix for l=1\n        d1 = np.array([\n            [(1 + cb) / 2, -sb / sqrt2, (1 - cb) / 2],\n            [sb / sqrt2,        cb,    -sb / sqrt2],\n            [(1 - cb) / 2,  sb / sqrt2, (1 + cb) / 2]\n        ])\n        \n        exp_a = np.exp(-1j * m_vals * alpha)\n        exp_g = np.exp(-1j * m_vals * gamma)\n        \n        # D(R) = diag(exp(-im*alpha)) * d(beta) * diag(exp(-im'*gamma))\n        D1 = np.diag(exp_a) @ d1 @ np.diag(exp_g)\n        return D1\n\n    for case in test_cases:\n        neighbors = case[\"neighbors\"]\n        weights = case[\"weights\"]\n        alpha, beta, gamma = case[\"euler_angles\"]\n\n        # 1. Compute original feature vector F\n        F, unit_vectors = get_feature_vector(neighbors, weights)\n        \n        # 2. Compute rotated feature vector F_rot by rotating coordinates\n        R_cartesian = get_rotation_matrix(alpha, beta, gamma)\n        rotated_unit_vectors = (R_cartesian @ unit_vectors.T).T\n        F_rot, _ = get_feature_vector(rotated_unit_vectors, weights)\n        \n        # 3. Compute transformed vector F_equiv using Wigner D-matrix\n        D1_R = get_wigner_d1_matrix(alpha, beta, gamma)\n        # D(R^-1) = D(R)^dagger for unitary representations\n        D1_R_inv = D1_R.conj().T\n        F_equiv = D1_R_inv @ F\n        \n        # 4. Calculate the discrepancy\n        discrepancy = np.max(np.abs(F_rot - F_equiv))\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    # Use a format specifier for consistent scientific notation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "3449495"}, {"introduction": "现在，你已经理解了“为什么”需要等变性以及“如何”通过特定数学工具实现它，是时候将这些模块组合成一个完整的模型了。本练习将指导你完成一个迷你的双层 $E(3)$ 等变消息传递网络的正向传播计算。你将学习如何利用张量积（tensor products）来耦合不同阶数（如 $\\ell=0$ 的标量和 $\\ell=1$ 的矢量）的特征，构建等变消息，并最终得到一个旋转不变的能量预测值[@problem_id:3449494]。", "problem": "要求您从第一性原理出发，为小分子构建一个最小但非平凡的双层三维欧几里得群 (E(3)) 等变消息传递神经网络。该网络必须作用于分解为三维特殊正交群 (SO(3)) 不可约表示的节点特征，特别是 $l=0$ 度的标量特征和 $l=1$ 度的矢量特征。您将仅使用等变耦合的数学规则以及一组指定的标量权重和径向函数，在一组固定的测试构型上实现一个显式的正向传播。最终输出必须是单行文本，包含一个浮点数结果列表，对应于所提供的测试套件。\n\n基本原理与约束：\n- 三维欧几里得群 (E(3)) 对称性通过旋转和平移作用于点的坐标。旋转等变性定义为：矢量特征根据 $l=1$ 不可约表示进行变换，而标量特征保持不变。平移只影响相对位置，因此使用相对位移可确保平移不变性。\n- 对于从节点 $j$ 到节点 $i$ 的每条有向边，设位移为 $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$，距离为 $r_{ij} = \\|\\mathbf{r}_{ij}\\|$，单位方向为 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$。在由矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 表示的旋转下，诸如 $\\mathbf{r}$ 和 $l=1$ 特征的矢量变换为 $\\mathbf{v} \\mapsto \\mathbf{R} \\mathbf{v}$，标量保持不变，而内积（如 $\\mathbf{u} \\cdot \\mathbf{v}$）也不变。\n- 在 $l \\in \\{0, 1\\}$ 级别上的等变张量积可以通过以下耦合实现：\n  - 标量-标量到标量：$0 \\otimes 0 \\rightarrow 0$，通过乘以一个标量径向包络实现。\n  - 矢量-矢量到标量：$1 \\otimes 1 \\rightarrow 0$，通过点积实现。\n  - 标量-矢量和矢量-标量到矢量：$0 \\otimes 1 \\rightarrow 1$ 和 $1 \\otimes 0 \\rightarrow 1$，通过用标量缩放矢量实现。\n  - 矢量-矢量到矢量：$1 \\otimes 1 \\rightarrow 1$，通过将一个矢量投影到另一个矢量的方向上实现，例如 $(\\mathbf{v} \\cdot \\hat{\\mathbf{r}})\\,\\hat{\\mathbf{r}}$。\n- 使用平滑的径向包络以确保局部性和连续性：对于一个截断半径 $R_{c}$ 和径向衰减常数 $\\alpha$，定义\n  $$\\phi(r) = \\exp(-\\alpha r), \\quad f_{\\mathrm{cut}}(r) = \\begin{cases} \\tfrac{1}{2}\\left(\\cos\\left(\\pi r / R_{c}\\right)+1\\right),  r \\le R_{c} \\\\ 0,  r > R_{c} \\end{cases}, \\quad s(r) = \\phi(r)\\, f_{\\mathrm{cut}}(r).$$\n\n架构与正向传播规范：\n- 在层 $l \\in \\{0, 1, 2\\}$，节点携带标量特征 $s^{(l)}_{i} \\in \\mathbb{R}$ 和矢量特征 $\\mathbf{v}^{(l)}_{i} \\in \\mathbb{R}^{3}$。\n- 初始化使用一个嵌入，将原子序数 $Z$ 映射到一个初始标量和矢量：\n  - 对于 $Z=1$ (氢)，$s^{(0)} = 0.7$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n  - 对于 $Z=6$ (碳)，$s^{(0)} = 0.4$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n  - 对于 $Z=8$ (氧)，$s^{(0)} = -0.2$，$\\mathbf{v}^{(0)} = (0, 0, 0)$。\n- 不存在自环边。在层 $l$ 上，节点 $i$ 的消息是通过对所有 $j \\neq i$ 求和来聚合的：\n  - 标量消息：\n    $$m^{(l)}_{0,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{00}\\, s(r_{ij})\\, s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right).$$\n  - 矢量消息：\n    $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{01}\\, s(r_{ij})\\, s^{(l)}_{j}\\, \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1}\\, s(r_{ij})\\, (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij})\\, \\hat{\\mathbf{r}}_{ij} \\right).$$\n- 特征更新对标量是仿射的，对矢量是线性的：\n  $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}, \\quad \\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}.$$\n- 读出层为每个节点生成一个不变的能量贡献，该贡献结合了标量和矢量的平方范数：\n  $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}, \\quad E = \\sum_{i} e_{i}.$$\n\n超参数和权重：\n- 截断半径 $R_{c} = 2.5$，径向衰减 $\\alpha = 1.0$，在各层之间共享。\n- $l=0$ 层权重：\n  - $w^{(0)}_{00} = 0.8$, $w^{(0)}_{11\\rightarrow 0} = 0.3$, $w^{(0)}_{01} = 1.1$, $w^{(0)}_{10} = 0.5$, $w^{(0)}_{11\\rightarrow 1} = 0.7$。\n  - $a^{(0)}_{0} = 0.9$, $b^{(0)}_{0} = 1.2$, $\\mathrm{bias}^{(0)}_{0} = 0.05$。\n  - $a^{(0)}_{1} = 0.8$, $b^{(0)}_{1} = 1.0$。\n- $l=1$ 层权重：\n  - $w^{(1)}_{00} = -0.4$, $w^{(1)}_{11\\rightarrow 0} = 0.2$, $w^{(1)}_{01} = 0.6$, $w^{(1)}_{10} = 0.9$, $w^{(1)}_{11\\rightarrow 1} = -0.3$。\n  - $a^{(1)}_{0} = 1.1$, $b^{(1)}_{0} = 0.7$, $\\mathrm{bias}^{(1)}_{0} = -0.02$。\n  - $a^{(1)}_{1} = 0.95$, $b^{(1)}_{1} = 0.85$。\n- 读出层权重：$c_{0} = 1.3$, $c_{1} = 0.2$。\n\n分子构型测试套件及所需输出：\n- 所有坐标单位为埃（angstrom），最终能量单位为任意能量单位。角度单位必须为弧度。\n- 情况 1 (类水几何结构): 三个原子及其原子序数和位置\n  - $Z = 8$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(0.9572, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(-0.2390, 0.9270, 0.0)$。\n  计算 $E_{1}$。\n- 情况 2 (旋转后的情况 1): 将情况 1 的所有位置绕 $z$ 轴旋转角度 $\\theta = 0.61$ 以获得新构型。计算 $E_{2}$，然后计算绝对差 $\\Delta = |E_{1} - E_{2}|$ 作为此情况的结果。\n- 情况 3 (超出截断半径): 两个原子\n  - $Z = 6$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 1$ 位于 $(3.0, 0.0, 0.0)$。\n  计算 $E_{3}$。\n- 情况 4 (带有截断边界的共线三原子): 三个原子\n  - $Z = 6$ 位于 $(0.0, 0.0, 0.0)$，\n  - $Z = 6$ 位于 $(1.25, 0.0, 0.0)$，\n  - $Z = 6$ 位于 $(2.5, 0.0, 0.0)$。\n  计算 $E_{4}$。\n\n程序要求：\n- 严格按照规定实现双层等变消息传递网络，使用给定的权重、特征和径向函数。使用成对的有向边，不含自环。对于矢量耦合，使用单位方向 $\\hat{\\mathbf{r}}_{ij}$。\n- 确保数值稳定性，避免除以零；在此设置中，$r_{ij} = 0$ 不会发生，因为没有自环边。\n- 按如下方式计算四个情况的结果：第一个元素是 $E_{1}$，第二个是情况 2 中的 $\\Delta$，第三个是 $E_{3}$，第四个是 $E_{4}$。\n- 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$）。每个浮点结果必须四舍五入到 $6$ 位小数。", "solution": "该问题要求构建并实现一个双层三维欧几里得群 (E(3)) 等变消息传递神经网络，以计算小分子构型的势能。解决方案遵循了指定的架构、权重和数学原理。\n\nE(3) 等变网络的基本原理是其操作必须尊重三维空间的对称性：平移、旋转和反演。对于一个原子系统，势能 $E$ 必须在整个系统的任何刚性平移或旋转下保持不变。\n\n1.  **对称性考量**：\n    - **平移不变性**：这是通过让网络作用于相对位置矢量 $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$ 而非绝对坐标 $\\mathbf{x}_i$ 来实现的。由于 $\\mathbf{r}_{ij}$ 在对所有 $k$ 进行全局平移 $\\mathbf{x}_k \\mapsto \\mathbf{x}_k + \\mathbf{t}$ 时保持不变，因此所有基于这些位移的后续计算也将是平移不变的。\n    - **旋转等变性**：这是通过根据特征在特殊正交群 SO(3) 下的变换性质来表征特征来管理的。特征被分解为不可约表示 (irreps)，由度 $l \\in \\{0, 1, 2, \\dots\\}$ 索引。在这个问题中，我们只考虑标量特征（$l=0$ 度，旋转不变）和矢量特征（$l=1$ 度，像坐标矢量一样旋转）。如果对输入进行旋转然后执行操作，与先执行操作然后旋转其输出得到的结果相同，则该操作是等变的。对于像能量这样的最终不变量，网络在中间层必须是等变的，并以一个不变的读出层结束。\n\n2.  **网络架构**：该网络由三个阶段组成：初始化、两层消息传递和最终的能量读出。\n\n    - **特征初始化（$l=0$ 层）**：每个原子 $i$ 根据其原子序数 $Z_i$ 初始化一个标量特征 $s^{(0)}_{i}$ 和一个矢量特征 $\\mathbf{v}^{(0)}_{i}$。根据规定，初始矢量特征 $\\mathbf{v}^{(0)}_{i}$ 均为零矢量，$\\mathbf{v}^{(0)}_{i} = (0, 0, 0)$，这是平凡等变的。初始标量特征对每种元素类型都是常数：对于 $Z=1$，$s^{(0)} = 0.7$；对于 $Z=6$，$s^{(0)} = 0.4$；对于 $Z=8$，$s^{(0)} = -0.2$。\n\n    - **消息传递（$l=0, 1$ 层）**：在每一层 $l$ 中，每个原子 $i$ 从所有其他原子 $j \\neq i$ 接收消息。这些消息是使用原子 $j$ 的特征与来自相对位置矢量 $\\mathbf{r}_{ij}$ 的几何信息的等变张量积构建的。\n      - 几何信息被编码在距离 $r_{ij} = \\|\\mathbf{r}_{ij}\\|$ 和方向矢量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$ 中。\n      - 使用一个径向函数 $s(r) = \\exp(-\\alpha r) \\cdot \\frac{1}{2}(\\cos(\\pi r / R_{c})+1)$（对于 $r \\le R_c$）和 $s(r)=0$（对于 $r > R_c$），为所有相互作用提供一个可学习的、平滑且局部的（在截断半径 $R_c$ 内）权重。给定的参数为 $R_c=2.5$ 和 $\\alpha=1.0$。\n      - **标量消息 $m^{(l)}_{0,i}$**：标量消息是一个不变量（$l=0$ 度）。它通过对邻居 $j$ 的两种不变量项求和形成：\n        1.  $s^{(l)}_j \\cdot s(r_{ij})$：两个标量的乘积（类型 $0 \\otimes 0 \\to 0$），由 $w^{(l)}_{00}$ 加权。\n        2.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\cdot s(r_{ij})$：两个矢量的点积（类型 $1 \\otimes 1 \\to 0$），由 $w^{(l)}_{11\\rightarrow 0}$ 加权。\n        原子 $i$ 的总标量消息为：\n        $$m^{(l)}_{0,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{00} s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0} \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right)$$\n      - **矢量消息 $\\mathbf{m}^{(l)}_{1,i}$**：矢量消息是一个等变矢量（$l=1$ 度）。它是三个等变矢量项的和：\n        1.  $s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$：一个标量乘以一个矢量（类型 $0 \\otimes 1 \\to 1$），由 $w^{(l)}_{01}$ 加权。\n        2.  $\\mathbf{v}^{(l)}_{j} \\cdot s(r_{ij})$：一个类标量的径向函数乘以一个矢量（类型 $1 \\otimes 0 \\to 1$），由 $w^{(l)}_{10}$ 加权。\n        3.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$：一个矢量在另一个矢量上的投影（类型 $1 \\otimes 1 \\to 1$），由 $w^{(l)}_{11\\rightarrow 1}$ 加权。\n        原子 $i$ 的总矢量消息为：\n        $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{01} s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10} \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1} (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\right)$$\n\n    - **特征更新**：下一层的特征 $s^{(l+1)}_{i}$ 和 $\\mathbf{v}^{(l+1)}_{i}$ 是根据当前特征和聚合的消息计算得出的。更新规则必须保持特征的变换性质。\n      - 标量更新是仿射变换，保持了其标量性质：\n        $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}$$\n      - 矢量更新是两个矢量（上一层的矢量 $\\mathbf{v}^{(l)}_{i}$ 和消息矢量 $\\mathbf{m}^{(l)}_{1,i}$）的线性组合，其结果是一个等变变换的矢量：\n        $$\\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}$$\n      这个过程对 $l=0$ 层执行以生成特征 $(s^{(1)}, \\mathbf{v}^{(1)})$，然后对 $l=1$ 层执行以生成特征 $(s^{(2)}, \\mathbf{v}^{(2)})$。问题陈述中提供了每层和每次更新的具体权重。\n\n    - **能量读出**：最后一步是从最后一层的特征中计算出一个单一的、旋转和平移不变的总能量 $E$。这是通过首先计算每个原子的不变能量贡献 $e_i$，然后对所有原子求和来完成的。\n      - 每个原子的能量 $e_i$ 是从第2层特征导出的两个不变量的线性组合：标量特征 $s^{(2)}_{i}$（本身就是不变量）和矢量特征的平方范数 $\\|\\mathbf{v}^{(2)}_{i}\\|^2$（它是不变的，因为矢量的范数在旋转下不会改变）。\n        $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}$$\n      - 总能量是所有原子的能量之和：\n        $$E = \\sum_{i} e_{i}$$\n      读出层权重给定为 $c_{0} = 1.3$ 和 $c_{1} = 0.2$。\n\n3.  **测试用例实现**：该算法应用于四个指定的测试用例。对于每个用例，原子序数和位置被用来初始化网络。然后依次执行两个消息传递层，最后进行能量读出。\n    - **情况 1**：对一个类水分子进行直接计算以求得 $E_1$。\n    - **情况 2**：旋转情况 1 的坐标。网络旋转不变性的一个关键测试是，旋转后系统的能量 $E_2$ 必须等于 $E_1$。此情况的结果是绝对差 $\\Delta = |E_1 - E_2|$，预期该值接近于零。\n    - **情况 3**：涉及两个原子，其间距离大于截断半径 $R_c$。这测试了相互作用的局部性；由于 $s(r_{ij})=0$，所有消息项均为零，特征仅根据其先前的值进行更新（更新规则中的“自相互作用”部分）。\n    - **情况 4**：一个共线系统，其中一个原子间距离恰好等于截断半径。这测试了截断函数 $f_{\\mathrm{cut}}(R_c)=0$ 的边界条件，该条件应使那对特定原子之间的相互作用无效。\n\n最终的 Python 实现封装了整个过程，精确地遵循公式并使用提供的参数来计算测试套件所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the equivariant network model.\n    \"\"\"\n\n    def radial_s(r, R_c, alpha):\n        \"\"\"Computes the radial basis function s(r).\"\"\"\n        if r > R_c or r == 0:\n            return 0.0\n        phi_r = np.exp(-alpha * r)\n        f_cut = 0.5 * (np.cos(np.pi * r / R_c) + 1.0)\n        return phi_r * f_cut\n\n    def run_forward_pass(atomic_numbers, positions):\n        \"\"\"\n        Executes the full forward pass of the 2-layer E(3)-equivariant network.\n        \"\"\"\n        # Hyperparameters and weights\n        R_c = 2.5\n        alpha = 1.0\n\n        weights = [\n            {  # Layer l=0\n                'w00': 0.8, 'w11_0': 0.3, 'w01': 1.1, 'w10': 0.5, 'w11_1': 0.7,\n                'a0': 0.9, 'b0': 1.2, 'bias0': 0.05,\n                'a1': 0.8, 'b1': 1.0\n            },\n            {  # Layer l=1\n                'w00': -0.4, 'w11_0': 0.2, 'w01': 0.6, 'w10': 0.9, 'w11_1': -0.3,\n                'a0': 1.1, 'b0': 0.7, 'bias0': -0.02,\n                'a1': 0.95, 'b1': 0.85\n            }\n        ]\n        readout_weights = {'c0': 1.3, 'c1': 0.2}\n\n        # Initial feature embeddings\n        embeddings = {\n            1: {'s': 0.7, 'v': np.array([0.0, 0.0, 0.0])},  # H\n            6: {'s': 0.4, 'v': np.array([0.0, 0.0, 0.0])},  # C\n            8: {'s': -0.2, 'v': np.array([0.0, 0.0, 0.0])}, # O\n        }\n\n        num_atoms = len(atomic_numbers)\n        s_features = np.array([embeddings[z]['s'] for z in atomic_numbers])\n        v_features = np.array([embeddings[z]['v'] for z in atomic_numbers])\n        \n        # Two message passing layers\n        for l in range(2):\n            w = weights[l]\n            s_next = np.zeros(num_atoms)\n            v_next = np.zeros((num_atoms, 3))\n\n            for i in range(num_atoms):\n                m0_i = 0.0\n                m1_i = np.zeros(3)\n                \n                for j in range(num_atoms):\n                    if i == j:\n                        continue\n                    \n                    r_ij_vec = positions[j] - positions[i]\n                    r_ij_norm = np.linalg.norm(r_ij_vec)\n                    \n                    if r_ij_norm > R_c or r_ij_norm == 0: # Explicitly handle zero norm for safety though problem says it won't happen\n                        continue\n                    \n                    r_ij_hat = r_ij_vec / r_ij_norm\n                    s_r = radial_s(r_ij_norm, R_c, alpha)\n                    \n                    s_j = s_features[j]\n                    v_j = v_features[j]\n                    \n                    v_j_dot_r_hat = np.dot(v_j, r_ij_hat)\n                    \n                    # Scalar message aggregation\n                    m0_i += s_r * (w['w00'] * s_j + w['w11_0'] * v_j_dot_r_hat)\n                    \n                    # Vector message aggregation\n                    term1 = w['w01'] * s_j * r_ij_hat\n                    term2 = w['w10'] * v_j\n                    term3 = w['w11_1'] * v_j_dot_r_hat * r_ij_hat\n                    m1_i += s_r * (term1 + term2 + term3)\n                \n                # Feature updates\n                s_next[i] = w['a0'] * s_features[i] + w['b0'] * m0_i + w['bias0']\n                v_next[i, :] = w['a1'] * v_features[i] + w['b1'] * m1_i\n            \n            s_features = s_next\n            v_features = v_next\n        \n        # Energy Readout\n        total_energy = 0.0\n        for i in range(num_atoms):\n            s2_i = s_features[i]\n            v2_i_norm_sq = np.linalg.norm(v_features[i])**2\n            e_i = readout_weights['c0'] * s2_i + readout_weights['c1'] * v2_i_norm_sq\n            total_energy += e_i\n            \n        return total_energy\n\n    # --- Test Suite ---\n    \n    # Case 1: Water-like geometry\n    z1 = [8, 1, 1]\n    pos1 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.9572, 0.0, 0.0],\n        [-0.2390, 0.9270, 0.0]\n    ])\n    E1 = run_forward_pass(z1, pos1)\n\n    # Case 2: Rotated Case 1\n    theta = 0.61\n    c, s = np.cos(theta), np.sin(theta)\n    R_z = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    pos2 = pos1 @ R_z.T \n    E2 = run_forward_pass(z1, pos2)\n    Delta = abs(E1 - E2)\n\n    # Case 3: Beyond cutoff\n    z3 = [6, 1]\n    pos3 = np.array([\n        [0.0, 0.0, 0.0],\n        [3.0, 0.0, 0.0]\n    ])\n    E3 = run_forward_pass(z3, pos3)\n\n    # Case 4: Collinear triatomic with cutoff boundary\n    z4 = [6, 6, 6]\n    pos4 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.25, 0.0, 0.0],\n        [2.5, 0.0, 0.0]\n    ])\n    E4 = run_forward_pass(z4, pos4)\n\n    results = [E1, Delta, E3, E4]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3449494"}]}