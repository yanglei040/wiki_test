{"hands_on_practices": [{"introduction": "要将理论模型转化为计算预测，我们必须首先掌握数值实现的技巧。第一个练习 [@problem_id:3488606] 为编码 Rashba 自旋轨道耦合哈密顿量提供了一个基础练习，这是二维系统的一个范例模型。通过在动量空间网格上实现这个模型，您将培养评估数值收敛性、利用对称性提高效率以及诊断潜在数值不稳定性的基本技能。", "problem": "考虑一个方形晶格上的二维电子气，在无量纲单位制下建模，其中晶格常数 $a$ 设为 $1$，约化普朗克常数 $\\hbar$ 设为 $1$，有效质量 $m$ 设为 $1$。该系统表现出由相对论效应引起的自旋轨道耦合。为进行计算，请在动量空间中对该系统建模，其在波矢 $\\mathbf{k} = (k_x,k_y)$ 处的有效哈密顿量如下：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2,\n$$\n其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$\\sigma_x$ 和 $\\sigma_y$ 是泡利矩阵，$\\alpha$ 是无量纲的自旋轨道耦合强度，$\\eta$ 是为减轻数值不稳定性而添加到对角线上的一个小的正则化项。所有量均为无量纲。\n\n从自旋轨道耦合和时间反演对称性的基本原理出发，你必须设计一个程序，该程序能够：\n$1.$ 对布里渊区进行均匀矩形采样，在 $k_x, k_y \\in [-\\pi,\\pi]$ 范围内使用一个均匀的 $N \\times N$ 网格，并为每个采样点构建 $H(\\mathbf{k})$。\n$2.$ 对于网格上的每个 $\\mathbf{k}$，计算 $H(\\mathbf{k})$ 的两个本征值 $E_1(\\mathbf{k})$ 和 $E_2(\\mathbf{k})$，并定义能级分裂 $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$。\n$3.$ 计算整个网格上的平均能级分裂，\n$$\n\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\Delta(k_x^{(i)}, k_y^{(j)}),\n$$\n其中 $k_x^{(i)}$ 和 $k_y^{(j)}$ 是 $[-\\pi,\\pi]$ 内均匀间隔的网格点。\n$4.$ 通过仅在第一象限 $k_x, k_y \\in [0,\\pi]$ 的 $N \\times N$ 网格上采样，并利用由时间反演对称性和符号反射导出的权重来重构全网格平均值，从而实现对称性约化。具体来说，为每个采样点分配一个权重 $w(\\mathbf{k})$ 如下：如果 $k_x = 0$ 且 $k_y = 0$，则使用 $w(\\mathbf{k}) = 1$；如果 $k_x$ 或 $k_y$ 中恰好有一个为零，则使用 $w(\\mathbf{k}) = 2$；否则使用 $w(\\mathbf{k}) = 4$。定义对称性约化平均值\n$$\n\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i=1}^{N} \\sum_{j=1}^{N} w(k_x^{(i)}, k_y^{(j)})},\n$$\n其中现在 $k_x^{(i)}, k_y^{(j)} \\in [0,\\pi]$。\n$5.$ 通过计算 $\\langle \\Delta \\rangle_{N}$ 和 $\\langle \\Delta \\rangle_{2N}$，然后评估\n$$\n\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|,\n$$\n来测试收敛性，并报告对于给定的容差 $\\varepsilon$，是否有 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$。\n$6.$ 通过计算绝对差\n$$\n\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|.\n$$\n来测试对称性约化的准确性。\n$7.$ 通过在每个 $\\mathbf{k}$ 处计算条件数\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))},\n$$\n来评估数值稳定性，其中 $s_{\\max}$ 和 $s_{\\min}$ 分别是 $H(\\mathbf{k})$ 的最大和最小奇异值。报告对于给定的阈值 $\\kappa_{\\max}$，是否有 $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$。\n\n你的程序必须实现以上所有功能，并为以下参数集测试套件 $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max})$ 生成结果：\n$1.$ $(0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$，\n$2.$ $(0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$，\n$3.$ $(0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$，\n$4.$ $(1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$，\n$5.$ $(2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$。\n\n对于每个参数集，你的程序必须按顺序计算并输出三个值：收敛性容差的布尔值（如果 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$ 则为 true），浮点数 $\\delta_{\\mathrm{sym}}$，以及稳定性阈值的布尔值（如果 $\\max_{\\mathbf{k}} \\kappa(H(\\mathbf{k})) \\le \\kappa_{\\max}$ 则为 true）。所有计算量均为无量纲。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，测试用例 1 的值后跟着测试用例 2 的值，以此类推，总共 15 个条目。例如，输出格式应与 $[v_1,v_2,\\dots,v_{15}]$ 完全一样，其中每个 $v_i$ 是布尔值或浮点数。", "solution": "该问题要求分析方形晶格上的二维电子气，该系统由动量空间中一个特定的有效哈密顿量描述。分析内容涉及计算平均能级分裂、测试收敛性、评估对称性约化方案以及评定数值稳定性。\n\n首先，我们验证问题陈述。\n\n### 步骤 1：提取给定条件\n- **无量纲单位**：晶格常数 $a=1$，约化普朗克常数 $\\hbar=1$，有效质量 $m=1$。\n- **系统**：具有自旋轨道耦合的方形晶格上的二维电子气。\n- **哈密顿量**：$H(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2$，对于波矢 $\\mathbf{k} = (k_x, k_y)$。\n- **定义**：$I_2$ 是 $2 \\times 2$ 单位矩阵，$\\sigma_x$ 和 $\\sigma_y$ 是泡利矩阵，$\\alpha$ 是自旋轨道耦合强度，$\\eta$ 是一个正的正则化参数。\n- **任务 1**：在 $k_x, k_y \\in [-\\pi,\\pi]$ 的均匀 $N \\times N$ 网格上构建 $H(\\mathbf{k})$。\n- **任务 2**：计算本征值 $E_1(\\mathbf{k})$、$E_2(\\mathbf{k})$ 以及能级分裂 $\\Delta(\\mathbf{k}) = |E_1(\\mathbf{k}) - E_2(\\mathbf{k})|$。\n- **任务 3**：计算全网格平均值 $\\langle \\Delta \\rangle_{N} = \\frac{1}{N^2} \\sum_{i,j} \\Delta(k_x^{(i)}, k_y^{(j)})$，其中 $(k_x^{(i)}, k_y^{(j)})$ 在 $[-\\pi, \\pi]^2$ 上的 $N \\times N$ 网格上。\n- **任务 4**：实现对称性约化。在 $k_x, k_y \\in [0,\\pi]$ 的 $N \\times N$ 网格上采样。在 $(0,0)$ 处使用权重 $w(\\mathbf{k})=1$，在坐标轴上（不包括原点）使用 $w(\\mathbf{k})=2$，其他地方使用 $w(\\mathbf{k})=4$。计算对称性约化平均值 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} = \\frac{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)}) \\, \\Delta(k_x^{(i)}, k_y^{(j)})}{\\sum_{i,j} w(k_x^{(i)}, k_y^{(j)})}$，其中 $(k_x^{(i)}, k_y^{(j)})$ 在 $[0, \\pi]^2$ 上的 $N \\times N$ 网格上。\n- **任务 5**：通过评估 $\\delta_{\\mathrm{conv}} = \\left| \\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N} \\right|$ 并检查是否 $\\delta_{\\mathrm{conv}} \\le \\varepsilon$ 来测试收敛性。\n- **任务 6**：通过计算 $\\delta_{\\mathrm{sym}} = \\left| \\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}} \\right|$ 来测试对称性约化的准确性。\n- **任务 7**：通过在全网格上找到最大条件数 $\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}(H(\\mathbf{k}))}{s_{\\min}(H(\\mathbf{k}))}$ 并检查其是否低于阈值 $\\kappa_{\\max}$ 来测试数值稳定性。\n- **测试套件**：\n  1. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.0, 25, 10^{-8}, 10^{-9}, 10^{8})$\n  2. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.01, 25, 10^{-8}, 10^{-6}, 10^{6})$\n  3. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (0.10, 25, 10^{-8}, 10^{-5}, 10^{6})$\n  4. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (1.00, 25, 10^{-8}, 10^{-5}, 10^{7})$\n  5. $(\\alpha, N, \\eta, \\varepsilon, \\kappa_{\\max}) = (2.00, 25, 10^{-6}, 10^{-4}, 10^{7})$\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学基础**：该哈密顿量是二维电子气的标准 Rashba 自旋轨道耦合哈密顿量。这些项分别代表动能、自旋轨道相互作用和恒定的能量偏移。该模型是凝聚态物理和计算材料科学的基石。对于自旋-$1/2$ 系统，使用泡利矩阵是标准做法。该问题在科学上是合理的。\n- **良构性**：所有任务都用明确的数学公式和算法定义。输入被清晰指定，所需的输出是唯一的数值或布尔值。\n- **客观性**：问题以精确、正式的语言陈述，没有任何主观性或歧义。\n- **缺陷分析**：\n  1.  **科学/事实不成立**：无。该模型在物理上是有效的。\n  2.  **不可形式化/不相关**：无。该问题是一个可形式化的计算任务，与指定主题直接相关。\n  3.  **不完整/矛盾的设置**：无。计算所需的所有必要参数和定义都已提供。网格定义和平均程序是明确的。\n  4.  **不切实际/不可行**：无。此类模型的参数在合理范围内，计算任务是可行的。\n  5.  **不适定/结构不良**：无。该问题被构建为一系列定义明确的计算步骤，导向唯一的解。\n  6.  **伪深刻/琐碎**：该问题需要对基于物理原理的数值方法进行非琐碎的实现，涵盖了数值积分、对称性、收敛性和稳定性的概念。它并非琐碎问题。\n  7.  **超出科学可验证范围**：无。结果可通过计算进行验证。\n\n### 步骤 3：结论与行动\n该问题有效。我们继续进行求解。\n\n### 基于原理的设计与求解\n\n问题的核心在于对哈密顿量 $H(\\mathbf{k})$ 的分析。让我们首先解析地确定其性质，这将大大简化计算任务。\n\n给定的哈密顿量是：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2}\\, I_2 + \\alpha \\left(k_y\\, \\sigma_x - k_x\\, \\sigma_y \\right) + \\eta\\, I_2\n$$\n泡利矩阵为 $\\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$ 和 $\\sigma_y = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}$。将这些代入哈密顿量，得到明确的矩阵形式：\n$$\nH(\\mathbf{k}) = \\frac{k_x^2 + k_y^2}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + \\alpha \\left( k_y \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} - k_x \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix} \\right) + \\eta \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n$$\nH(\\mathbf{k}) = \\begin{pmatrix} \\frac{k_x^2+k_y^2}{2}+\\eta  & \\alpha(k_y + ik_x) \\\\ \\alpha(k_y - ik_x)  & \\frac{k_x^2+k_y^2}{2}+\\eta \\end{pmatrix}\n$$\n这是一个形如 $\\begin{pmatrix} A  C \\\\ C^*  A \\end{pmatrix}$ 的 $2 \\times 2$ 厄米矩阵。其本征值 $E$ 由特征方程 $\\det(H - E I_2) = 0$ 的解给出，该方程可简化为 $(A - E)^2 - |C|^2 = 0$。因此，本征值为 $E = A \\pm |C|$。\n\n这里，$A = \\frac{k_x^2+k_y^2}{2} + \\eta$ 且 $|C| = |\\alpha(k_y + ik_x)| = |\\alpha|\\sqrt{k_y^2 + k_x^2}$。令 $k = \\sqrt{k_x^2 + k_y^2}$ 为波矢的模。两个本征值为：\n$$\nE_{\\pm}(\\mathbf{k}) = \\frac{k^2}{2} + \\eta \\pm |\\alpha| k\n$$\n这个解析结果至关重要，因为它避免了在网格上每个点对矩阵 $H(\\mathbf{k})$ 进行数值对角化的需要，从而实现了一个高效的算法。\n\n**任务 2：能级分裂**\n能级分裂 $\\Delta(\\mathbf{k})$ 是两个本征值之间的绝对差：\n$$\n\\Delta(\\mathbf{k}) = |E_{+}(\\mathbf{k}) - E_{-}(\\mathbf{k})| = \\left| \\left(\\frac{k^2}{2} + \\eta + |\\alpha| k\\right) - \\left(\\frac{k^2}{2} + \\eta - |\\alpha| k\\right) \\right| = |2 |\\alpha| k| = 2 |\\alpha| \\sqrt{k_x^2 + k_y^2}\n$$\n\n**任务 3：全网格平均值 $\\langle \\Delta \\rangle_{N}$**\n为了计算平均分裂，我们首先在区域 $[-\\pi, \\pi] \\times [-\\pi, \\pi]$ 中定义一个均匀的 $N \\times N$ 网格点 $(k_x, k_y)$。这是通过分别为 $k_x$ 和 $k_y$ 创建线性间隔的点，然后形成一个网格来实现的。对于此网格上的每个点，我们使用导出的解析公式计算 $\\Delta(\\mathbf{k})$，然后对所有 $N^2$ 个网格点取算术平均值。\n\n**任务 4：对称性约化平均值 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$**\n函数 $\\Delta(\\mathbf{k}) = 2|\\alpha|k$ 仅依赖于模长 $k = \\sqrt{k_x^2+k_y^2}$。该函数表现出高度对称性：$\\Delta(k_x, k_y) = \\Delta(\\pm k_x, \\pm k_y)$。这意味着它在布里渊区的所有四个象限中的值都是相同的。因此，可以通过仅在第一象限 $[0, \\pi] \\times [0, \\pi]$ 上进行平均，并对边界上的点进行适当加权，来高效地估算全区的平均值。权重考虑了点在反射到其他象限时的重数：\n- 一个点 $(k_x, k_y)$，其中 $k_x > 0, k_y > 0$，在全区中有 $4$ 个等效点。权重 $w=4$。\n- 坐标轴上的一个点，$(k_x, 0)$ 其中 $k_x > 0$ 或 $(0, k_y)$ 其中 $k_y > 0$，有 $2$ 个等效点。权重 $w=2$。\n- 原点 $(0,0)$ 是唯一的。权重 $w=1$。\n对称性约化平均值是第一象限中 $N \\times N$ 网格上的加权平均值，由 $\\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}$ 的公式指定。\n\n**任务 5：收敛性测试**\n$\\langle \\Delta \\rangle_{N}$ 的计算是积分 $I = \\frac{1}{(2\\pi)^2} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} \\Delta(k_x, k_y) \\,dk_x dk_y$ 的数值近似。随着网格变得更密集（即 $N$ 增加），近似值应收敛到积分的真实值。收敛性测试 $\\delta_{\\mathrm{conv}} = |\\langle \\Delta \\rangle_{2N} - \\langle \\Delta \\rangle_{N}| \\le \\varepsilon$ 检查当网格密度加倍时，计算出的平均值的变化是否小于容差 $\\varepsilon$。这是评估数值积分收敛性的标准程序。\n\n**任务 6：对称性准确性测试**\n量 $\\delta_{\\mathrm{sym}} = |\\langle \\Delta \\rangle_{N} - \\langle \\Delta \\rangle_{N}^{\\mathrm{sym}}|$ 直接比较了全网格计算和对称性约化计算的结果。虽然 $\\Delta(\\mathbf{k})$ 的对称性是精确的，但两种数值方案使用的网格可能不完全对应，导致一个虽小但非零的差异。此测试量化了这种特定对称性约化实现的准确性。\n\n**任务 7：数值稳定性测试**\n矩阵 $M$ 的条件数 $\\kappa(M)$ 衡量了方程 $Mx=b$ 的解对 $M$ 或 $b$ 中扰动的敏感度。对于像 $H(\\mathbf{k})$ 这样的厄米矩阵，其奇异值 $s_i$ 是其本征值的绝对值，即 $s_i = |E_i|$。条件数由下式给出：\n$$\n\\kappa(H(\\mathbf{k})) = \\frac{s_{\\max}}{s_{\\min}} = \\frac{\\max(|E_+|, |E_-|)}{\\min(|E_+|, |E_-|)} = \\frac{|\\frac{k^2}{2} + \\eta + |\\alpha| k|}{|\\frac{k^2}{2} + \\eta - |\\alpha| k|}\n$$\n一个非常大的条件数表明矩阵接近奇异，这可能导致数值不稳定性。这通常发生在分母 $|E_-(\\mathbf{k})|$ 接近零时。二次方程 $\\frac{k^2}{2} - |\\alpha|k + \\eta = 0$ 在 $k = |\\alpha| \\pm \\sqrt{\\alpha^2 - 2\\eta}$ 处有根。如果 $\\alpha^2 \\ge 2\\eta$，则存在实数 $k$ 值使得 $E_-$ 可以为零。参数 $\\eta$ 充当正则化项，确保分母保持非零（或不太小），从而使条件数有界。该算法计算全网格上所有点的 $\\kappa(H(\\mathbf{k}))$ 并找到最大值，然后将其与阈值 $\\kappa_{\\max}$ 进行比较。\n\n最终的实现将把这些计算封装在函数中，并对测试套件中的每组参数调用这些函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(alpha, N, eta):\n    \"\"\"\n    Computes metrics on a full uniform grid over [-pi, pi] x [-pi, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter.\n        \n    Returns:\n        tuple: A tuple containing:\n            - avg_delta (float): The average energy splitting over the grid.\n            - max_kappa (float): The maximum condition number over the grid.\n    \"\"\"\n    if N == 0:\n        return 0.0, 1.0\n    \n    k_range = np.linspace(-np.pi, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    avg_delta = np.mean(delta)\n    \n    # Calculate condition number kappa(k)\n    abs_alpha = np.abs(alpha)\n    k_sq_half = 0.5 * k**2\n    \n    # Eigenvalues are E_pm = k^2/2 + eta +/- |alpha|*k\n    # Singular values for a Hermitian matrix are the absolute values of its eigenvalues.\n    s_plus = np.abs(k_sq_half + eta + abs_alpha * k)\n    s_minus = np.abs(k_sq_half + eta - abs_alpha * k)\n    \n    # s_max and s_min must be determined at each point\n    s_max = np.maximum(s_plus, s_minus)\n    s_min = np.minimum(s_plus, s_minus)\n    \n    # Handle division by zero for condition number. If s_min is zero, kappa is infinite.\n    kappa = np.divide(s_max, s_min, out=np.full_like(s_max, np.inf), where=s_min != 0)\n    \n    max_kappa = np.max(kappa)\n    \n    return avg_delta, max_kappa\n\ndef calculate_sym_avg_delta(alpha, N, eta):\n    \"\"\"\n    Computes the average energy splitting using symmetry reduction on a grid over [0, pi] x [0, pi].\n    \n    Args:\n        alpha (float): Spin-orbit coupling strength.\n        N (int): Grid dimension (N x N).\n        eta (float): Regularization parameter (unused in this simplified calc but kept for API consistency).\n\n    Returns:\n        float: The symmetry-reduced average energy splitting.\n    \"\"\"\n    if N == 0:\n        return 0.0\n    if N == 1: # Grid is just the origin\n        return 0.0\n\n    k_range = np.linspace(0, np.pi, N)\n    kx, ky = np.meshgrid(k_range, k_range)\n    \n    k = np.sqrt(kx**2 + ky**2)\n    \n    # Calculate energy splitting Delta(k)\n    delta = 2.0 * np.abs(alpha) * k\n    \n    # Define weights for symmetry reduction\n    weights = np.full((N, N), 4.0)\n    weights[0, :] = 2.0\n    weights[:, 0] = 2.0\n    weights[0, 0] = 1.0\n    \n    # Compute weighted average\n    avg_delta_sym = np.sum(weights * delta) / np.sum(weights)\n\n    return avg_delta_sym\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0.0, 25, 1e-8, 1e-9, 1e8),\n        (0.01, 25, 1e-8, 1e-6, 1e6),\n        (0.10, 25, 1e-8, 1e-5, 1e6),\n        (1.00, 25, 1e-8, 1e-5, 1e7),\n        (2.00, 25, 1e-6, 1e-4, 1e7)\n    ]\n\n    results = []\n\n    for alpha, N, eta, epsilon, kappa_max in test_cases:\n        # Task 3  7: Full grid calculations for N\n        avg_delta_N, max_kappa_N = calculate_metrics(alpha, N, eta)\n        \n        # Task 5: Convergence test requires calculation at 2N\n        avg_delta_2N, _ = calculate_metrics(alpha, 2 * N, eta)\n        delta_conv = np.abs(avg_delta_2N - avg_delta_N)\n        conv_check = delta_conv = epsilon\n        \n        # Task 4  6: Symmetry reduction test\n        avg_delta_N_sym = calculate_sym_avg_delta(alpha, N, eta)\n        delta_sym = np.abs(avg_delta_N - avg_delta_N_sym)\n        \n        # Task 7: Stability check\n        stability_check = max_kappa_N = kappa_max\n        \n        results.extend([conv_check, delta_sym, stability_check])\n\n    # The problem asks for float for delta_sym, and lowercase boolean strings.\n    formatted_results = []\n    for i in range(len(results)):\n        # Indices 0, 1, 2 correspond to the 3 results for the first test case, etc.\n        # Boolean results are at indices i%3 == 0 and i%3 == 2\n        if i % 3 == 0 or i % 3 == 2:\n             formatted_results.append(str(results[i]).lower())\n        else: # Float result (delta_sym)\n             formatted_results.append(str(results[i]))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3488606"}, {"introduction": "超越简单的模型，计算理论学家的一个关键技能是构建能够捕捉真实材料基本物理的有效哈密顿量。这个练习 [@problem_id:3488731] 将指导您为钙钛矿铱氧化物构建一个对称性约束的紧束缚模型，其中强自旋轨道耦合产生了新颖的 $j_{\\mathrm{eff}}=1/2$ 基态。您将学习如何表示轨道和自旋算符，将它们与跳跃项结合，并使用投影分析将模型的能带结构与其潜在的相对论量子特性联系起来。", "problem": "要求您为一个具有在位自旋轨道耦合 (SOC) 的立方钙钛矿铱氧化物的 $t_{2g}$ 轨道流形，构建并分析一个对称性约束的紧束缚模型。目标是提取 $j_{\\mathrm{eff}}=1/2$ 能带，并计算一个验证指标，该指标模拟与密度泛函理论 (DFT) 加 SOC 的轨道投影算符的比较。您的最终答案必须是一个完整的、可运行的程序，该程序执行以下任务，为所提供的一套参数值测试套件输出指定的指标，并遵循文末描述的输出格式。\n\n从以下具有物理依据的基础开始：\n\n- 相对论性 SOC 源于 Dirac 方程，在中心势中电子的非相对论极限下，产生一个有效的在位 SOC 项 $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$，其中 $\\lambda$ 是一个包含径向信息的有效 SOC 参数（对于固体，这被视为一个唯象的在位参数），$\\mathbf{L}$ 是轨道角动量算符，$\\mathbf{S}$ 是自旋角动量算符。\n- 在理想的立方钙钛矿中，晶体场将 $d$ 轨道流形分裂，使得 $t_{2g}$ 轨道 $\\{d_{xy},d_{yz},d_{zx}\\}$ 在费米能级附近占主导地位。在 $t_{2g}$ 子空间内，轨道角动量由一个有效的 $\\ell_{\\mathrm{eff}}=1$ 表示来描述，相对于通常的 $p$-轨道表示，它带有一个总体的负号。\n\n模型定义：\n\n1. 基矢。使用六维局域基矢 $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$，其中 $\\uparrow$ 和 $\\downarrow$ 表示自旋态。\n\n2. 在位 SOC。实现\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i,\n$$\n其中 $S_i=\\frac{1}{2}\\sigma_i$，$\\sigma_i$ 为泡利矩阵，$L_i$ 是限制在 $t_{2g}$ 子空间上的轨道角动量矩阵。在有序轨道基矢 $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$ 中，使用\n$$\nL_x=\\begin{pmatrix}\n0  0  0\\\\\n0  0  i\\\\\n0  -i  0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0  0  -i\\\\\n0  0  0\\\\\ni  0  0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0  i  0\\\\\n-i  0  0\\\\\n0  0  0\n\\end{pmatrix},\n$$\n这些矩阵包含了适用于 $t_{2g}$ 子空间的有效负号。\n\n3. 对称性约束的跃迁。在一个晶格常数设为单位 1 的简单立方晶格上，沿着轨道对称性允许的方向，施加振幅为 $t_\\pi$ 的最近邻跃迁：\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right),\n$$\n其中 $\\mathbf{k}=(k_x,k_y,k_z)$ 是晶体动量，所有角度均以弧度表示。\n\n4. 晶体场畸变。包含一个在位晶体场项\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\n其中 $I_2$ 是自旋空间中的 $2\\times 2$ 单位矩阵。对于四方畸变，一个常见的保持对称性的选择是 $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$，这确保了在轨道子空间内的迹为零。\n\n总哈密顿量为\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}},\n$$\n其中 $H_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2$。\n\n$j_{\\mathrm{eff}}=1/2$ 能带的提取与验证指标：\n\n- 通过对角化在位哈密顿量 $H_{\\mathrm{SO}}$ 并选择与 $j_{\\mathrm{eff}}=1/2$ 二重态对应的两个本征矢量（对于 $\\lambda0$ 和 $t_{2g}$ 符号约定，这是能量最高的一对），来构建到 $j_{\\mathrm{eff}}=1/2$ 子空间的投影算符 $P_{1/2}$。将 $P_{1/2}$ 构造为这两个归一化本征矢量的外积之和。该投影算符与 $\\mathbf{k}$ 无关。\n- 对于立方布里渊区中高对称路径 $\\Gamma\\to X\\to M\\to R$ 上的一系列 $\\mathbf{k}$ 点，其中 $\\Gamma=(0,0,0)$，$X=(\\pi,0,0)$，$M=(\\pi,\\pi,0)$ 和 $R=(\\pi,\\pi,\\pi)$，每段路径采样 5 个等间距点（包括端点），角度使用弧度。\n- 在每个采样的 $\\mathbf{k}$ 点，对角化 $H(\\mathbf{k})$ 以获得本征值和本征矢量。对每个能带 $n$ 计算 $j_{\\mathrm{eff}}=1/2$ 投影权重 $w_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle$。在每个 $\\mathbf{k}$ 点，将具有最大投影权重的两个能带识别为 $j_{\\mathrm{eff}}=1/2$ 能带。\n- 为每组参数定义以下指标：\n  1. 在所有选定能带和所有 $\\mathbf{k}$ 点上的平均 $j_{\\mathrm{eff}}=1/2$ 权重：\n  $$\n  \\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}),\n  $$\n  其中 $N_k$ 是采样的 $\\mathbf{k}$ 点数，$w_m^{\\mathrm{(sel)}}$ 是两个选定能带的权重。\n  2. 一个模拟与 DFT+SOC 轨道投影算符比较的验证误差，计算为选定的 $j_{\\mathrm{eff}}=1/2$ 能带与理想投影权重 1 的均方根偏差：\n  $$\n  \\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}。\n  $$\n  3. 在 $\\Gamma$ 点，$j_{\\mathrm{eff}}=1/2$ 二重态与 $j_{\\mathrm{eff}}=3/2$ 四重态之间的能量分裂，定义为它们在 $\\Gamma$ 点各自平均能带能量之差，\n  $$\n  \\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n  $$\n  以电子伏特 (eV) 为单位。这里 $E_{m}^{(1/2)}(\\Gamma)$ 是在 $\\Gamma$ 点具有最大投影权重的两个能带的能量，$E_{n}^{(3/2)}(\\Gamma)$ 是其余四个能带的能量。\n\n测试套件：\n\n对以下参数集计算上述指标，所有能量单位为电子伏特 (eV)，角度单位为弧度：\n\n- 案例 1：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 案例 2：$\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 案例 3：$\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$。\n- 案例 4：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个列表的列表，每个子列表按上述顺序包含每个案例的三个指标。例如，它应如下所示：\n$$\n[[\\overline{w}_1,\\mathrm{RMS}_1,\\Delta E_{\\Gamma,1}],\\dots,[\\overline{w}_4,\\mathrm{RMS}_4,\\Delta E_{\\Gamma,4}]]\n$$\n其中每个条目都是一个浮点数。请精确打印这一行，不要附加任何其他文本。", "solution": "起点是自旋轨道耦合的相对论起源。从中心势 $V(r)$ 中的 Dirac 方程出发，Foldy–Wouthuysen 变换得到一个非相对论哈密顿量，其中包含一个与 $\\mathbf{L}\\cdot\\mathbf{S}$ 成正比的 SOC 项。在原子背景下，这表现为我们所熟知的形式 $H_{\\mathrm{SO}}=\\lambda\\,\\mathbf{L}\\cdot\\mathbf{S}$，其中 $\\lambda$ 包含了径向期望值 $\\lambda\\sim \\frac{\\hbar^2}{2m^2c^2}\\left\\langle \\frac{1}{r}\\frac{dV}{dr}\\right\\rangle$。在固体中，尤其是在 5d 铱氧化物中，$\\lambda$ 在关联子空间内被视为一个有效的在位参数。\n\n在理想的立方钙钛矿中，由周围氧原子产生的晶体场将 $d$ 轨道分裂为 $e_g$ 和 $t_{2g}$ 流形，其中 $t_{2g}$ 态 ($d_{xy}$、$d_{yz}$、$d_{zx}$) 靠近费米能级。$t_{2g}$ 流形可以用一个有效的轨道角动量 $\\ell_{\\mathrm{eff}}=1$ 来表示，相对于 $p$-轨道表示，它带有一个总体的负号。这个负号的出现是因为 $t_{2g}$ 子空间与 $p$-轨道基矢在旋转下的变换方式相反，这反映在投影后 $L_i$ 矩阵的具体形式中。\n\n算法构造：\n\n1. 定义基矢 $\\{|d_{xy}\\uparrow\\rangle,|d_{yz}\\uparrow\\rangle,|d_{zx}\\uparrow\\rangle,|d_{xy}\\downarrow\\rangle,|d_{yz}\\downarrow\\rangle,|d_{zx}\\downarrow\\rangle\\}$。\n\n2. 在有序轨道基矢 $\\{|d_{xy}\\rangle,|d_{yz}\\rangle,|d_{zx}\\rangle\\}$ 中构造轨道角动量矩阵 $L_x$、$L_y$、$L_z$：\n$$\nL_x=\\begin{pmatrix}\n0  0  0\\\\\n0  0  i\\\\\n0  -i  0\n\\end{pmatrix},\\quad\nL_y=\\begin{pmatrix}\n0  0  -i\\\\\n0  0  0\\\\\ni  0  0\n\\end{pmatrix},\\quad\nL_z=\\begin{pmatrix}\n0  i  0\\\\\n-i  0  0\\\\\n0  0  0\n\\end{pmatrix}.\n$$\n这些已经编码了有效的负号（它们是 $-L^{(p)}$）。\n\n3. 构造自旋算符 $S_i=\\frac{1}{2}\\sigma_i$，其中泡利矩阵 $\\sigma_i$ 作用于自旋空间。构建\n$$\nH_{\\mathrm{SO}}=\\lambda\\sum_{i=x,y,z}L_i\\otimes S_i=\\frac{\\lambda}{2}\\left(L_x\\otimes \\sigma_x+L_y\\otimes \\sigma_y+L_z\\otimes \\sigma_z\\right).\n$$\n对角化 $H_{\\mathrm{SO}}$ 会产生两个位于 $+\\lambda$ 的本征值（$j_{\\mathrm{eff}}=1/2$ 二重态）和四个位于 $-\\lambda/2$ 的本征值（$j_{\\mathrm{eff}}=3/2$ 四重态），这与在考虑 $t_{2g}$ 子空间的有效负号（$\\ell=1$ 和 $s=1/2$）时能量表达式 $E_j=-\\frac{\\lambda}{2}\\left[j(j+1)-\\ell(\\ell+1)-s(s+1)\\right]$ 的结果一致。\n\n4. 构建对称性约束的跃迁哈密顿量 $H_{\\mathrm{hop}}(\\mathbf{k})$ 为\n$$\nH_{\\mathrm{hop}}(\\mathbf{k})=\\mathrm{diag}(\\varepsilon_{xy}(\\mathbf{k}),\\varepsilon_{yz}(\\mathbf{k}),\\varepsilon_{zx}(\\mathbf{k}))\\otimes I_2,\n$$\n其中\n$$\n\\varepsilon_{xy}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_x + \\cos k_y\\right),\\quad\n\\varepsilon_{yz}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_y + \\cos k_z\\right),\\quad\n\\varepsilon_{zx}(\\mathbf{k})=-2t_\\pi\\left(\\cos k_z + \\cos k_x\\right).\n$$\n这强制了立方对称性，只允许每个 $t_{2g}$ 轨道沿着对称性允许的方向跃迁。\n\n5. 包含晶体场项\n$$\nH_{\\mathrm{CF}}=\\mathrm{diag}(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})\\otimes I_2,\n$$\n以捕捉四方畸变。一个保持对称性的选择是 $\\Delta_{yz}=\\Delta_{zx}=-\\Delta_{xy}/2$，保持迹为零。\n\n6. 总哈密顿量为\n$$\nH(\\mathbf{k})=H_{\\mathrm{hop}}(\\mathbf{k})+H_{\\mathrm{SO}}+H_{\\mathrm{CF}}.\n$$\n对于给定的 $\\mathbf{k}$，对角化 $H(\\mathbf{k})$ 以获得本征值和归一化的本征矢量 $\\{E_n(\\mathbf{k}),|\\psi_n(\\mathbf{k})\\rangle\\}$。\n\n7. 通过单独对角化 $H_{\\mathrm{SO}}$ 并将与 $+\\lambda$ 本征值对应的两个本征矢量的投影算符求和，来构造 $j_{\\mathrm{eff}}=1/2$ 投影算符 $P_{1/2}$。由于 $H_{\\mathrm{SO}}$ 与 $\\mathbf{k}$ 无关且是纯在位的，所以 $P_{1/2}$ 是一个固定的 $6\\times 6$ 投影算符。\n\n8. 对每个本征态 $|\\psi_n(\\mathbf{k})\\rangle$，计算 $j_{\\mathrm{eff}}=1/2$ 权重\n$$\nw_n(\\mathbf{k})=\\langle \\psi_n(\\mathbf{k})|P_{1/2}|\\psi_n(\\mathbf{k})\\rangle,\n$$\n其值介于 0 和 1 之间。\n\n9. 在沿路径 $\\Gamma\\to X\\to M\\to R$ 采样的每个 $\\mathbf{k}$ 点（每段 5 个点，角度以弧度为单位），将具有最大 $w_n(\\mathbf{k})$ 的两个能带识别为该 $\\mathbf{k}$ 点的 $j_{\\mathrm{eff}}=1/2$ 能带。\n\n10. 计算指标：\n- 平均 $j_{\\mathrm{eff}}=1/2$ 权重，\n$$\n\\overline{w}=\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}w_{m}^{\\mathrm{(sel)}}(\\mathbf{k}).\n$$\n这量化了所提取的能带在整个路径上 $j_{\\mathrm{eff}}=1/2$ 特性的纯度。\n- 模拟 DFT+SOC 投影算符比较的验证误差，即与理想权重 1 的均方根偏差，\n$$\n\\mathrm{RMS}=\\sqrt{\\frac{1}{2N_k}\\sum_{\\mathbf{k}}\\sum_{m=1}^{2}\\left(1-w_{m}^{\\mathrm{(sel)}}(\\mathbf{k})\\right)^2}。\n$$\n对于强 SOC 和弱跃迁，$\\overline{w}\\to 1$ 且 $\\mathrm{RMS}\\to 0$；对于弱 SOC 或强畸变，混合增加，导致 $\\overline{w}$ 减小和 $\\mathrm{RMS}$ 增大。\n- 在 $\\Gamma$ 点的能量分裂，\n$$\n\\Delta E_{\\Gamma}=\\frac{1}{2}\\sum_{m=1}^{2}E_{m}^{(1/2)}(\\Gamma)-\\frac{1}{4}\\sum_{n=1}^{4}E_{n}^{(3/2)}(\\Gamma),\n$$\n单位为电子伏特 (eV)。在 $t_\\pi=0$ 且无晶体场畸变的原子极限下，这简化为 $\\Delta E_{\\Gamma}=\\lambda-\\left(-\\lambda/2\\right)=\\frac{3}{2}\\lambda$，与 $j_{\\mathrm{eff}}$ 分裂一致；跃迁和晶体场项会修正此分裂。\n\n11. 将上述步骤应用于测试套件：\n- 案例 1：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，代表一个典型的类铱氧化物体系。\n- 案例 2：$\\lambda=1.0$, $t_\\pi=0.05$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，强 SOC 极限。\n- 案例 3：$\\lambda=0.05$, $t_\\pi=0.30$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.0,0.0,0.0)$，强跃迁弱 SOC，用于探究混合效应。\n- 案例 4：$\\lambda=0.4$, $t_\\pi=0.15$, $(\\Delta_{xy},\\Delta_{yz},\\Delta_{zx})=(0.1,-0.05,-0.05)$，迹为零的四方畸变，用于测试对称性破缺效应。\n\n实现的程序遵循这些步骤，为每个案例计算指标，并以要求的单行格式打印它们。这种方法综合了 SOC 的相对论起源、对称性约束的紧束缚描述以及基于投影算符的 $j_{\\mathrm{eff}}=1/2$ 特性提取，为 DFT+SOC 轨道投影算符的比较提供了一个有科学依据且在算法上可测试的验证代理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef t2g_L_matrices():\n    \"\"\"Return Lx, Ly, Lz matrices in the t2g orbital basis {xy, yz, zx}.\"\"\"\n    i = 1j\n    Lx = np.array([[0, 0, 0],\n                   [0, 0, i],\n                   [0, -i, 0]], dtype=complex)\n    Ly = np.array([[0, 0, -i],\n                   [0, 0, 0],\n                   [i, 0, 0]], dtype=complex)\n    Lz = np.array([[0, i, 0],\n                   [-i, 0, 0],\n                   [0, 0, 0]], dtype=complex)\n    return Lx, Ly, Lz\n\ndef pauli_matrices():\n    \"\"\"Return Pauli matrices sigma_x, sigma_y, sigma_z.\"\"\"\n    sigma_x = np.array([[0, 1],\n                        [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j],\n                        [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0],\n                        [0, -1]], dtype=complex)\n    return sigma_x, sigma_y, sigma_z\n\ndef kron(A, B):\n    \"\"\"Kronecker product, returning complex dtype.\"\"\"\n    return np.kron(A, B).astype(complex)\n\ndef H_soc(lambda_ev):\n    \"\"\"Construct on-site SOC Hamiltonian H_SO = (lambda/2) sum_i L_i ⊗ sigma_i.\"\"\"\n    Lx, Ly, Lz = t2g_L_matrices()\n    sx, sy, sz = pauli_matrices()\n    H = (lambda_ev / 2.0) * (kron(Lx, sx) + kron(Ly, sy) + kron(Lz, sz))\n    return H\n\ndef H_hop(kx, ky, kz, t_pi):\n    \"\"\"Construct hopping Hamiltonian H_hop(k) = diag(eps_xy, eps_yz, eps_zx) ⊗ I2.\"\"\"\n    eps_xy = -2.0 * t_pi * (np.cos(kx) + np.cos(ky))\n    eps_yz = -2.0 * t_pi * (np.cos(ky) + np.cos(kz))\n    eps_zx = -2.0 * t_pi * (np.cos(kz) + np.cos(kx))\n    eps = np.array([eps_xy, eps_yz, eps_zx], dtype=float)\n    H_orb = np.diag(eps).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef H_cf(delta_xy, delta_yz, delta_zx):\n    \"\"\"Construct crystal-field Hamiltonian H_CF = diag(Delta_xy, Delta_yz, Delta_zx) ⊗ I2.\"\"\"\n    deltas = np.array([delta_xy, delta_yz, delta_zx], dtype=float)\n    H_orb = np.diag(deltas).astype(complex)\n    I2 = np.eye(2, dtype=complex)\n    return kron(H_orb, I2)\n\ndef j_eff_half_projector():\n    \"\"\"\n    Build the k-independent projector onto j_eff=1/2 subspace by diagonalizing H_SOC (lambda=1).\n    Returns a 6x6 Hermitian projector matrix P.\n    \"\"\"\n    H = H_soc(1.0)  # Eigenvectors independent of lambda scaling for lambda>0\n    evals, evecs = np.linalg.eigh(H)\n    # Identify the two largest eigenvalues (j_eff=1/2 doublet at +lambda)\n    idx_sorted = np.argsort(evals)  # ascending\n    idx_top2 = idx_sorted[-2:]      # last two are the largest\n    P = np.zeros((6, 6), dtype=complex)\n    for idx in idx_top2:\n        v = evecs[:, idx]\n        # Normalize (should already be normalized by eigh)\n        v = v / np.linalg.norm(v)\n        P += np.outer(v, np.conjugate(v))\n    # Ensure Hermitian projector numerically\n    P = (P + P.conjugate().T) / 2.0\n    return P\n\ndef sample_k_path(n_per_segment=5):\n    \"\"\"\n    Sample 5 equally spaced points per segment along Gamma->X->M->R path.\n    Angles in radians. Returns a list of (kx, ky, kz).\n    \"\"\"\n    # Parameter t in [0,1] with n points including endpoints\n    ts = np.linspace(0.0, 1.0, n_per_segment)\n    pts = []\n    # Gamma (0,0,0) to X (pi,0,0)\n    for t in ts:\n        pts.append((np.pi * t, 0.0, 0.0))\n    # X (pi,0,0) to M (pi,pi,0)\n    for t in ts:\n        pts.append((np.pi, np.pi * t, 0.0))\n    # M (pi,pi,0) to R (pi,pi,pi)\n    for t in ts:\n        pts.append((np.pi, np.pi, np.pi * t))\n    # Remove exact duplicates while preserving order\n    unique = []\n    seen = set()\n    for k in pts:\n        key = (round(k[0], 12), round(k[1], 12), round(k[2], 12))\n        if key not in seen:\n            seen.add(key)\n            unique.append(k)\n    return unique\n\ndef compute_metrics(lambda_ev, t_pi, delta_xy, delta_yz, delta_zx):\n    \"\"\"\n    Compute:\n    - average j_eff=1/2 weight over selected bands and k-points,\n    - RMS deviation from ideal projector weight 1,\n    - Gamma-point splitting between j_eff=1/2 and j_eff=3/2 means (in eV).\n    \"\"\"\n    P = j_eff_half_projector()\n    k_list = sample_k_path(n_per_segment=5)\n    weights_selected = []  # collect weights of the two selected bands across all k\n    # For Gamma splitting calculation\n    kx_g, ky_g, kz_g = (0.0, 0.0, 0.0)\n    H_gamma = H_hop(kx_g, ky_g, kz_g, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n    evals_g, evecs_g = np.linalg.eigh(H_gamma)\n    # Compute weights at Gamma\n    weights_g = np.array([np.real(np.conjugate(evecs_g[:, n]).T @ (P @ evecs_g[:, n])) for n in range(6)], dtype=float)\n    # Identify top2 bands at Gamma\n    idx_top2_g = np.argsort(weights_g)[-2:]\n    # j_eff=1/2 energies (mean of two)\n    E_j12_gamma = np.mean(evals_g[idx_top2_g].real)\n    # j_eff=3/2 energies: the remaining four\n    idx_rest_g = np.array([n for n in range(6) if n not in idx_top2_g], dtype=int)\n    E_j32_gamma = np.mean(evals_g[idx_rest_g].real)\n\n    # Loop over k-points for weights and RMS\n    for (kx, ky, kz) in k_list:\n        Hk = H_hop(kx, ky, kz, t_pi) + H_soc(lambda_ev) + H_cf(delta_xy, delta_yz, delta_zx)\n        evals, evecs = np.linalg.eigh(Hk)\n        # Compute projector weights for all bands\n        ws = np.array([np.real(np.conjugate(evecs[:, n]).T @ (P @ evecs[:, n])) for n in range(6)], dtype=float)\n        # Select two bands with largest weights\n        idx_top2 = np.argsort(ws)[-2:]\n        weights_selected.extend(ws[idx_top2].tolist())\n\n    # Metrics\n    weights_selected = np.array(weights_selected, dtype=float)\n    avg_weight = float(np.mean(weights_selected))\n    rms_error = float(np.sqrt(np.mean((1.0 - weights_selected) ** 2)))\n    delta_E_gamma = float(E_j12_gamma - E_j32_gamma)  # in eV\n\n    return [avg_weight, rms_error, delta_E_gamma]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lambda_ev, t_pi, delta_xy, delta_yz, delta_zx)\n    test_cases = [\n        (0.4, 0.15, 0.0, 0.0, 0.0),        # Case 1\n        (1.0, 0.05, 0.0, 0.0, 0.0),        # Case 2\n        (0.05, 0.30, 0.0, 0.0, 0.0),       # Case 3\n        (0.4, 0.15, 0.1, -0.05, -0.05),    # Case 4 (tetragonal, zero trace)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_ev, t_pi, dxy, dyz, dzx = case\n        metrics = compute_metrics(lambda_ev, t_pi, dxy, dyz, dzx)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists with floats.\n    # Ensure default Python string formatting without extra text.\n    print(str(results))\n\nsolve()\n```", "id": "3488731"}, {"introduction": "第一性原理计算（例如基于密度泛函理论-DFT的计算）的可靠性，在很大程度上取决于所用赝势的质量。最后一个练习 [@problem_id:3488724] 深入探讨了涉及重元素（其中SOC效应显著）的计算中一个至关重要的验证步骤。通过数值求解径向薛定谔方程，您将学会如何检测一个构造不良的赝势可能引入的非物理“鬼”态，这是确保您的模拟具有预测能力的一项重要技能。", "problem": "考虑一个由泡利近似推导出的中心场单粒子哈密顿量，该哈密顿量包含自旋轨道耦合（SOC）。在原子单位（其中 $\\hbar=1$，$m=1$，$e=1$）中，对于给定的轨道角动量 $l$ 和总角动量 $j$ 通道，该哈密顿量可以分离为一个关于约化径向波函数 $u_{l}^{j}(r)$ 的径向方程：\n$$\n-\\frac{1}{2}\\frac{d^{2}u_{l}^{j}}{dr^{2}} + V_{\\mathrm{eff}}^{(l,j)}(r) \\, u_{l}^{j}(r) = E \\, u_{l}^{j}(r),\n$$\n其有效势为\n$$\nV_{\\mathrm{eff}}^{(l,j)}(r) = V(r) + \\frac{l(l+1)}{2 r^{2}} + \\frac{1}{2 c^{2}} \\frac{1}{r} \\frac{dV}{dr} \\, \\kappa_{l j},\n$$\n其中 $c$ 是原子单位下的光速，$\\kappa_{l j} = \\frac{1}{2}\\left[j(j+1) - l(l+1) - \\frac{3}{4}\\right]$ 是 $(l,j)$ 通道中轨道-自旋耦合算符 $\\mathbf{L}\\cdot\\mathbf{S}$ 的本征值。\n\n为了根据一个光滑的全电子参考来验证特定 $(l,j)$ 通道的自旋轨道耦合赝势，并检测非物理的“鬼态”，您将比较在固定核半径 $r_c$ 处对数微商的能量依赖性，\n$$\nL_{l}^{j}(E; r_c) = r_c \\, \\frac{u'(r_c)}{u(r_c)},\n$$\n该比较针对两种势：\n1. 一个光滑的全电子参考势\n$$\nV_{\\mathrm{AE}}(r) = -\\frac{Z}{\\sqrt{r^{2} + a^{2}}},\n$$\n其参数为 $Z$（有效核电荷）和 $a$（正则化长度）。\n2. 一个自旋轨道赝势，此处定义为一个局域模型，它在相同的长程参考势的核区内部增加了一个依赖于通道的短程吸引高斯势阱，\n$$\nV_{\\mathrm{PS}}(r) = V_{\\mathrm{AE}}(r) - V_{0} \\, \\exp\\!\\left[-\\left(\\frac{r}{r_{w}}\\right)^{2}\\right],\n$$\n其参数为 $V_{0}$（势阱深度）和 $r_{w}$（势阱宽度）。SOC 贡献项对赝势使用 $\\frac{dV_{\\mathrm{PS}}}{dr}$，对全电子参考使用 $\\frac{dV_{\\mathrm{AE}}}{dr}$。\n\n在赝势验证中，鬼态的一个标准指标是在物理相关的能量窗口内，$L_{l}^{j}(E; r_c)$ 相对于参考势多出一个额外的极点。$L_{l}^{j}(E; r_c)$ 的极点出现在能量 $E$ 处，此时径向方程的正则解（在原点处有限）满足 $u(r_c)=0$，这对应于半径为 $r_c$ 的“球中原子”问题的狄利克雷本征值。为检测鬼态，需要在指定的能量区间内对 $V_{\\mathrm{AE}}$ 和 $V_{\\mathrm{PS}}$ 计算此类能量（极点）的数量；若 $V_{\\mathrm{PS}}$ 的计数更多，则表明存在鬼态。\n\n实现一个程序，该程序：\n- 求解具有正则边界条件 $u(r) \\sim r^{l+1}$（当 $r \\to 0$ 时）的径向方程以得到 $u_{l}^{j}(r)$。\n- 在指定区间的均匀能量格点上，计算 $u(r_c)$ 和对数微商 $L_{l}^{j}(E; r_c)$。\n- 通过计算连续能量点上 $u(r_c)$ 的符号变化次数来检测极点。\n- 对于每个测试用例，返回一个布尔值，指示赝势是否表现出鬼态（如果赝势在区间内的极点数严格大于参考势的极点数，则为 True，否则为 False）。\n\n使用以下测试套件，所有距离单位为玻尔半径，所有能量单位为哈特里：\n- 测试用例 1（基准，无势阱）：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 1, 3/2, 0.0, 0.5, 0.2, 2.0, 150)$。\n- 测试用例 2（深势阱，可能在 $p_{1/2}$ 通道有鬼态）：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 1, 1/2, 60.0, 0.3, 0.2, 2.0, 150)$。\n- 测试用例 3（边界情况，$s$ 通道，自旋轨道耦合为零）：$(Z,a,r_c,l,j,V_{0},r_{w},E_{\\min},E_{\\max},N_{E}) = (4, 0.1, 1.0, 0, 1/2, 0.0, 0.5, 0.2, 2.0, 150)$。\n\n您的程序必须通过扫描具有 $N_{E}$ 个均匀间隔能量点的区间 $[E_{\\min},E_{\\max}]$ 来计算极点数，然后输出一行，其中包含一个包含三个布尔值的列表，每个布尔值对应一个测试用例，顺序如上所示。最终输出必须是格式为 $[b_{1},b_{2},b_{3}]$ 的单行，其中每个 $b_{i}$ 是 True 或 False。\n\n您的实现必须使用稳定、自包含的逻辑来数值求解径向方程，并且不得依赖外部数据。最终结果是无单位的布尔值，但所有内部计算必须遵循上述指定的物理单位。", "solution": "用户希望通过检测非物理的“鬼态”来验证赝势与全电子参考的一致性。这是通过比较在给定能量窗口内径向波函数对数微商的极点数量来实现的。如果赝势表现出比全电子参考更多的极点，则认为存在鬼态。\n\n这个问题的基础是数值求解中心场中单个粒子的径向薛定谔方程，其中包括通过泡利近似考虑的相对论性自旋轨道耦合（SOC）效应。该方程在原子单位下给出：\n$$\n-\\frac{1}{2}\\frac{d^{2}u_{l}^{j}}{dr^{2}} + V_{\\mathrm{eff}}^{(l,j)}(r) \\, u_{l}^{j}(r) = E \\, u_{l}^{j}(r)\n$$\n其中 $u_{l}^{j}(r)$ 是轨道角动量量子数为 $l$、总角动量量子数为 $j$ 的状态的约化径向波函数。状态的能量为 $E$。\n\n有效势 $V_{\\mathrm{eff}}^{(l,j)}(r)$ 包含了中心势 $V(r)$、离心势垒和自旋轨道耦合项：\n$$\nV_{\\mathrm{eff}}^{(l,j)}(r) = V(r) + \\frac{l(l+1)}{2 r^{2}} + \\frac{1}{2 c^{2}} \\frac{1}{r} \\frac{dV}{dr} \\, \\kappa_{l j}\n$$\n这里，$c \\approx 137.036$ 是原子单位下的光速。给定 $(l,j)$ 通道的 SOC 强度由 $\\kappa_{l j}$ 决定，它是 $\\mathbf{L}\\cdot\\mathbf{S}$ 算符的本征值，计算公式为：\n$$\n\\kappa_{l j} = \\frac{1}{2}\\left[j(j+1) - l(l+1) - s(s+1)\\right]\n$$\n对于电子，自旋 $s = 1/2$，因此 $s(s+1) = 3/4$。\n\n问题要求在两种中心势之间进行比较：\n1.  一个正则化的全电子（AE）势：$V_{\\mathrm{AE}}(r) = -Z / \\sqrt{r^2 + a^2}$。\n2.  一个局域赝势（PS）模型：$V_{\\mathrm{PS}}(r) = V_{\\mathrm{AE}}(r) - V_0 \\exp[-(r/r_w)^2]$。\n\n核心任务是在固定半径 $r_c$ 处，找到对数微商 $L_{l}^{j}(E; r_c) = r_c \\, u'(r_c)/u(r_c)$ 的极点数量。极点出现在能量 $E$ 处，此时分母 $u(r_c)$ 为零。这些能量是具有狄利克雷边界条件 $u(r_c)=0$ 的径向薛定谔方程的本征值。\n\n数值策略如下：\n1.  对于每个测试用例，我们定义一个跨越区间 $[E_{\\min}, E_{\\max}]$ 的能量格点。\n2.  对于格点中的每个能量 $E$，我们求解径向方程以找到波函数在 $r_c$ 处的值 $u(r_c)$。\n3.  我们遍历能量格点，计算 $u(r_c)$ 改变符号的次数。每次符号改变表示穿过了一个根（也就是 $L$ 的一个极点）。\n4.  这个极点计数过程执行两次：一次用于 AE 势（通过设置 $V_0=0$），一次用于 PS 势（使用给定的 $V_0$）。\n5.  如果 PS 的极点数严格大于 AE 参考的极点数，则存在鬼态。\n\n为了求解这个二阶常微分方程（ODE）的径向方程，我们将其转换为一个由两个一阶 ODE 组成的系统。设 $y_0(r) = u(r)$ 和 $y_1(r) = u'(r)$。该系统为：\n$$\n\\frac{dy_0}{dr} = y_1\n$$\n$$\n\\frac{dy_1}{dr} = 2 [V_{\\mathrm{eff}}(r) - E] y_0\n$$\n该系统通过数值方法求解。解必须是“正则的”，意味着它在原点处是物理上表现良好的。对于给定的 $l$，正则解在 $r \\to 0$ 时的行为是 $u(r) \\sim r^{l+1}$。为避免离心项和 SOC 项在 $r=0$ 处的奇异性，我们从一个小的半径 $r_{start}  0$ 开始数值积分。初始条件根据这种渐近行为设置：$u(r_{start}) = r_{start}^{l+1}$ 和 $u'(r_{start}) = (l+1)r_{start}^l$。任意的归一化常数设为 $1$，因为它不影响 $u(r_c)$ 的符号。\n\n实现中使用了 `scipy.integrate.solve_ivp`，这是一个强大的自适应步长 ODE 求解器，用于将系统从 $r_{start}$ 积分到 $r_c$，并为每个能量获得 $u(r_c)$ 的值。定义了势、其导数以及完整有效势的函数，以处理数学形式并避免在 $r=0$ 附近的数值问题。每个测试用例的最终布尔结果由条件 `pole_count_PS  pole_count_AE` 确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# All calculations are in atomic units (Hartree for energy, Bohr for distance).\n# Speed of light in atomic units\nC_AU = 137.035999084\n\ndef count_poles(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E):\n    \"\"\"\n    Counts the number of poles of the logarithmic derivative in a given energy range.\n    This corresponds to counting the number of sign changes of u(rc) by solving\n    the radial Schrödinger equation over a grid of energies.\n\n    Args:\n        Z (float): Effective nuclear charge.\n        a (float): Regularization length for the AE potential.\n        rc (float): Core radius for evaluation.\n        l (int): Orbital angular momentum quantum number.\n        j (float): Total angular momentum quantum number.\n        V0 (float): Depth of the Gaussian pseudopotential well. If 0, this is an AE calculation.\n        rw (float): Width of the Gaussian pseudopotential well.\n        E_min (float): Minimum of the energy scan window.\n        E_max (float): Maximum of the energy scan window.\n        N_E (int): Number of energy points in the scan.\n\n    Returns:\n        int: The number of poles detected in the energy window.\n    \"\"\"\n    C_AU_SQ = C_AU**2\n    energy_grid = np.linspace(E_min, E_max, N_E)\n    kappa = 0.5 * (j * (j + 1) - l * (l + 1) - 0.75)\n\n    def V_potential(r):\n        v_ae = -Z / np.sqrt(r**2 + a**2)\n        v_ps_add = -V0 * np.exp(-(r / rw)**2)\n        return v_ae + v_ps_add\n\n    def dV_dr(r):\n        if r  1e-9: return 0.0\n        dv_ae_dr = Z * r * (r**2 + a**2)**(-1.5)\n        dv_ps_add_dr = (2 * V0 * r / rw**2) * np.exp(-(r / rw)**2)\n        return dv_ae_dr + dv_ps_add_dr\n\n    def V_effective(r):\n        if r  1e-9: return np.inf\n        \n        centrifugal = l * (l + 1) / (2 * r**2)\n        \n        soc_term = 0.0\n        # SOC is non-zero only for l > 0 and kappa != 0\n        if l > 0 and abs(kappa) > 1e-9:\n            soc_term = (1 / (2 * C_AU_SQ)) * (1 / r) * dV_dr(r) * kappa\n            \n        return V_potential(r) + centrifugal + soc_term\n\n    def ode_system(r, y, E):\n        u, u_prime = y\n        try:\n            v_eff_val = V_effective(r)\n        except FloatingPointError: # Catch divergence\n            v_eff_val = np.inf\n        \n        u_double_prime = 2 * (v_eff_val - E) * u\n        return [u_prime, u_double_prime]\n\n    pole_count = 0\n    last_u_rc_sign = 0\n\n    for E in energy_grid:\n        r_start = 1e-6\n        # Initial conditions: u(r) ~ r^(l+1) for small r\n        u_start = r_start**(l + 1)\n        u_prime_start = (l + 1) * r_start**l\n        y_start = [u_start, u_prime_start]\n        \n        sol = solve_ivp(\n            fun=lambda r, y: ode_system(r, y, E),\n            t_span=[r_start, rc],\n            y0=y_start,\n            t_eval=[rc],\n            method='RK45',\n            atol=1e-8, rtol=1e-8\n        )\n        \n        if sol.status != 0:\n            continue\n            \n        current_u_rc_val = sol.y[0, -1]\n        current_u_rc_sign = np.sign(current_u_rc_val)\n        \n        if last_u_rc_sign != 0 and current_u_rc_sign != 0 and current_u_rc_sign != last_u_rc_sign:\n            pole_count += 1\n        \n        if current_u_rc_sign != 0:\n            last_u_rc_sign = current_u_rc_sign\n\n    return pole_count\n\n\ndef check_for_ghost_state(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E):\n    \"\"\"\n    Compares pole counts for AE and PS potentials to detect a ghost state.\n    Returns True if the PS potential has strictly more poles than the AE reference.\n    \"\"\"\n    poles_ae = count_poles(Z, a, rc, l, j, 0.0, rw, E_min, E_max, N_E)\n    poles_ps = count_poles(Z, a, rc, l, j, V0, rw, E_min, E_max, N_E)\n    return poles_ps > poles_ae\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Z, a, rc, l, j, V0, rw, Emin, Emax, NE)\n        (4, 0.1, 1.0, 1, 1.5, 0.0, 0.5, 0.2, 2.0, 150),\n        (4, 0.1, 1.0, 1, 0.5, 60.0, 0.3, 0.2, 2.0, 150),\n        (4, 0.1, 1.0, 0, 0.5, 0.0, 0.5, 0.2, 2.0, 150),\n    ]\n\n    results = []\n    for case in test_cases:\n        has_ghost = check_for_ghost_state(*case)\n        results.append(has_ghost)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3488724"}]}