{"hands_on_practices": [{"introduction": "遍历性假设的实际意义在于，足够长的单次模拟可以替代对系统系综的平均。这个练习将理论陈述与“多长时间才算足够长？”这一实际问题联系起来[@problem_id:3475291]。它引入了积分自相关时间这一关键指标，用于确定模拟的统计效率，并估算达到给定精度所需的模拟时长。", "problem": "考虑一个使用分子动力学（MD）模拟的兰纳-琼斯（LJ）流体。令 $U(t)$ 表示作为时间 $t$ 函数的瞬时势能。假设该过程是平稳遍历的，即当轨迹长度趋于无穷大时，时间平均等于系综平均。将长度为 $T$ 的轨迹上的势能的时间平均定义为\n$$\n\\overline{U}_T = \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt,\n$$\n并将系综平均表示为\n$$\n\\langle U \\rangle = \\mathbb{E}[U(t)].\n$$\n令涨落为 $\\delta U(t) = U(t) - \\langle U \\rangle$。定义自协方差函数\n$$\nC(\\tau) = \\langle \\delta U(0)\\,\\delta U(\\tau) \\rangle,\n$$\n以及归一化自相关函数（ACF）\n$$\n\\rho(\\tau) = \\frac{C(\\tau)}{C(0)},\n$$\n其中 $C(0) = \\sigma^2$ 是 $U(t)$ 的方差。对于连续时间过程，积分自相关时间（IAT）为\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau,\n$$\n而对于采样间隔为 $\\Delta t$、延迟由整数 $k \\in \\{0,1,2,\\dots\\}$ 索引的离散时间采样过程，以步数计的 IAT 为\n$$\n\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k,\n$$\n以时间单位计的 IAT 由 $\\tau_{\\mathrm{int,time}} = \\Delta t \\,\\tau_{\\mathrm{int,steps}}$ 给出。\n\n仅从这些定义、平稳过程的性质和基础概率演算出发，推导一个最小轨迹长度 $T$ 的表达式，使得 $\\overline{U}_T$ 相对于 $\\langle U \\rangle$ 的均方根偏差不超过给定的能量单位容差 $\\varepsilon$。最终表达式必须显示 $T$ 如何依赖于 $\\sigma^2$、$\\varepsilon$ 和积分自相关时间（IAT）。\n\n实现一个程序，针对以下每个测试用例，计算所需的最小轨迹长度 $T$，以使均方根偏差最多为 $\\varepsilon$。所有 $T$ 值必须以皮秒为单位报告。对于连续时间情况，使用连续时间的 IAT。对于离散时间情况，通过对 ACF 求和直至项的量级低于 $10^{-12}$ 的阈值来计算 $\\tau_{\\mathrm{int,steps}}$，然后使用 $\\Delta t$ 转换为时间单位。\n\n测试套件规格：\n- 情况1（连续时间指数型 ACF）：\n  - $\\rho(\\tau) = \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right)$，\n  - $\\tau_c = 2.5$ $\\mathrm{ps}$，\n  - $\\sigma^2 = 25$ $(\\mathrm{kJ/mol})^2$，\n  - $\\varepsilon = 0.5$ $\\mathrm{kJ/mol}$。\n- 情况2（连续时间拉伸指数型 ACF）：\n  - $\\rho(\\tau) = \\exp\\left(-\\left(\\frac{\\tau}{\\tau_c}\\right)^{\\beta}\\right)$，\n  - $\\tau_c = 1.0$ $\\mathrm{ps}$，\n  - $\\beta = 0.5$，\n  - $\\sigma^2 = 9$ $(\\mathrm{kJ/mol})^2$，\n  - $\\varepsilon = 0.3$ $\\mathrm{kJ/mol}$。\n- 情况3（离散时间指数型 ACF）：\n  - $\\rho_k = \\exp\\left(-\\frac{k\\,\\Delta t}{\\tau_c}\\right)$，\n  - $\\Delta t = 0.693147$ $\\mathrm{ps}$，\n  - $\\tau_c = 1.0$ $\\mathrm{ps}$，\n  - $\\sigma^2 = 4$ $(\\mathrm{kJ/mol})^2$，\n  - $\\varepsilon = 0.2$ $\\mathrm{kJ/mol}$。\n- 情况4（离散时间不相关边界情况）：\n  - $\\rho_k = 0$ 对所有 $k \\ge 1$，\n  - $\\Delta t = 0.5$ $\\mathrm{ps}$，\n  - $\\sigma^2 = 16$ $(\\mathrm{kJ/mol})^2$，\n  - $\\varepsilon = 1.0$ $\\mathrm{kJ/mol}$。\n\n角度单位不适用。所有物理单位必须一致处理。将最终轨迹长度 $T$ 以皮秒表示，并四舍五入到小数点后3位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况1到情况4的顺序排列为 $[T_1, T_2, T_3, T_4]$，例如 $[T_1,T_2,T_3,T_4]$，其中每个 $T_i$ 是一个以皮秒为单位、四舍五入到小数点后3位的浮点数。", "solution": "该问题陈述是计算模拟中时间序列数据统计分析的一个有效且适定的练习，这是计算材料科学中的一个标准课题。它在科学上植根于统计力学的原理，特别是涨落理论和时间相关函数理论。所提供的时间平均、系综平均、自相关函数（ACF）和积分自相关时间（IAT）的定义都是标准的。测试用例的所有参数都已明确给出，问题是自洽且内部一致的。不存在科学上的不准确、模糊或矛盾之处。\n\n核心任务是推导出一个所需最小模拟时间 $T$ 的表达式，用以在指定的统计精度下估算势能的系综平均 $\\langle U \\rangle$。精度由以下条件定义：时间平均势能 $\\overline{U}_T$ 与真实系综平均值之间的均方根偏差不超过容差 $\\varepsilon$。该条件可正式表示为：\n$$\n\\sqrt{\\mathbb{E}\\left[ (\\overline{U}_T - \\langle U \\rangle)^2 \\right]} \\le \\varepsilon\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示期望算符。两边平方得到关于时间平均的方差 $\\text{Var}(\\overline{U}_T)$ 的条件：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ (\\overline{U}_T - \\langle U \\rangle)^2 \\right] \\le \\varepsilon^2\n$$\n注意，对于平稳过程，$\\mathbb{E}[\\overline{U}_T] = \\langle U \\rangle$。我们的第一步是推导 $\\text{Var}(\\overline{U}_T)$ 的表达式。\n\n从连续时间过程的时间平均 $\\overline{U}_T$ 的定义开始：\n$$\n\\overline{U}_T = \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt\n$$\n方差为：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ \\left( \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt - \\langle U \\rangle \\right)^2 \\right]\n$$\n使用涨落 $\\delta U(t) = U(t) - \\langle U \\rangle$，我们可以将其重写为：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ \\left( \\frac{1}{T} \\int_{0}^{T} \\delta U(t)\\, dt \\right)^2 \\right] = \\frac{1}{T^2} \\mathbb{E}\\left[ \\int_{0}^{T} \\int_{0}^{T} \\delta U(t) \\delta U(t')\\, dt\\, dt' \\right]\n$$\n通过应用 Fubini 定理交换期望和积分算符，我们得到：\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{1}{T^2} \\int_{0}^{T} \\int_{0}^{T} \\mathbb{E}[ \\delta U(t) \\delta U(t') ]\\, dt\\, dt'\n$$\n积分内的项是自协方差函数，对于平稳过程，它仅依赖于时间差 $\\tau = t - t'$：$C(t-t') = \\langle \\delta U(t) \\delta U(t') \\rangle$。\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{1}{T^2} \\int_{0}^{T} \\int_{0}^{T} C(t - t')\\, dt\\, dt'\n$$\n这个在方形域上的二重积分可以被简化。通过变量替换或几何方法计算该积分，可以得到标准结果：\n$$\n\\int_{0}^{T} \\int_{0}^{T} C(t - t')\\, dt\\, dt' = 2 \\int_{0}^{T} (T-\\tau) C(\\tau)\\, d\\tau\n$$\n因此，方差变为：\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{2}{T} \\int_{0}^{T} \\left(1 - \\frac{\\tau}{T}\\right) C(\\tau)\\, d\\tau\n$$\n对于长度为 $T$ 的轨迹，如果其远大于相关性衰减的时间尺度（即，对于所有 $C(\\tau)$ 不可忽略的 $\\tau$，都有 $T \\gg \\tau$），则 $\\tau/T$ 项变得不重要，积分上限可以扩展到无穷大而不会引入显著误差。这个近似得出：\n$$\n\\text{Var}(\\overline{U}_T) \\approx \\frac{2}{T} \\int_{0}^{\\infty} C(\\tau)\\, d\\tau\n$$\n使用定义 $C(\\tau) = C(0) \\rho(\\tau) = \\sigma^2 \\rho(\\tau)$ 和 $\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau$，我们发现：\n$$\n\\text{Var}(\\overline{U}_T) \\approx \\frac{2 \\sigma^2}{T} \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{T}\n$$\n将此代入我们的精度要求 $\\text{Var}(\\overline{U}_T) \\le \\varepsilon^2$：\n$$\n\\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{T} \\le \\varepsilon^2\n$$\n求解最小轨迹长度 $T$ 得到主要结果：\n$$\nT \\ge \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}\n$$\n因此，最小长度为 $T = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}$。\n\n对于采样间隔为 $\\Delta t$ 的离散时间过程，一个类似的推导可得出 $N$ 个样本均值的方差为 $\\text{Var}(\\overline{U}_N) \\approx \\frac{\\sigma^2}{N} \\left( 1 + 2 \\sum_{k=1}^{\\infty} \\rho_k \\right)$。使用问题中对以步数计的 IAT 的定义 $\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k$，括号中的项为 $2 \\tau_{\\mathrm{int,steps}}$。因此，$\\text{Var}(\\overline{U}_N) \\approx \\frac{2 \\sigma^2 \\tau_{\\mathrm{int,steps}}}{N}$。总时间为 $T = N \\Delta t$。条件变为 $\\frac{2 \\sigma^2 \\tau_{\\mathrm{int,steps}}}{T / \\Delta t} \\le \\varepsilon^2$，简化为 $T \\ge \\frac{2 \\sigma^2 (\\tau_{\\mathrm{int,steps}} \\Delta t)}{\\varepsilon^2}$。定义 $\\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\Delta t$ 后，$T$ 的公式与连续情况下的形式保持一致。\n\n我们现在将此主公式 $T = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}$ 应用于每个测试用例。\n\n**情况1：连续时间指数型 ACF**\n- 给定：$\\rho(\\tau) = \\exp(-\\tau/\\tau_c)$，$\\tau_c = 2.5$ $\\mathrm{ps}$，$\\sigma^2 = 25$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.5$ $\\mathrm{kJ/mol}$。\n- 首先，我们计算 IAT：\n  $$ \\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right) d\\tau = \\left[ -\\tau_c \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right) \\right]_0^\\infty = 0 - (-\\tau_c) = \\tau_c = 2.5 \\text{ ps} $$\n- 然后，我们计算最小轨迹长度 $T$：\n  $$ T_1 = \\frac{2 \\cdot 25 \\cdot 2.5}{(0.5)^2} = \\frac{125}{0.25} = 500.0 \\text{ ps} $$\n\n**情况2：连续时间拉伸指数型 ACF**\n- 给定：$\\rho(\\tau) = \\exp(-(\\tau/\\tau_c)^\\beta)$，$\\tau_c = 1.0$ $\\mathrm{ps}$，$\\beta = 0.5$，$\\sigma^2 = 9$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.3$ $\\mathrm{kJ/mol}$。\n- 我们通过变量替换 $x = (\\tau/\\tau_c)^\\beta$ 来计算 IAT：\n  $$ \\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\exp\\left(-\\left(\\frac{\\tau}{\\tau_c}\\right)^\\beta\\right) d\\tau = \\frac{\\tau_c}{\\beta} \\int_{0}^{\\infty} x^{\\frac{1}{\\beta}-1} e^{-x} dx = \\frac{\\tau_c}{\\beta} \\Gamma\\left(\\frac{1}{\\beta}\\right) $$\n- 当 $\\beta = 0.5$ 时，我们有 $1/\\beta = 2$。使用 $\\Gamma(2) = 1! = 1$：\n  $$ \\tau_{\\mathrm{int}} = \\frac{1.0}{0.5} \\Gamma(2) = 2 \\cdot 1 = 2.0 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_2 = \\frac{2 \\cdot 9 \\cdot 2.0}{(0.3)^2} = \\frac{36}{0.09} = 400.0 \\text{ ps} $$\n\n**情况3：离散时间指数型 ACF**\n- 给定：$\\rho_k = \\exp(-k \\Delta t/\\tau_c)$，$\\Delta t = 0.693147$ $\\mathrm{ps}$，$\\tau_c = 1.0$ $\\mathrm{ps}$，$\\sigma^2 = 4$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.2$ $\\mathrm{kJ/mol}$。\n- 我们计算 $\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k$。该和是一个几何级数 $\\sum_{k=1}^{\\infty} r^k$，其中 $r = \\exp(-\\Delta t/\\tau_c) = \\exp(-0.693147) \\approx 0.5$。和为 $\\frac{r}{1-r} = \\frac{0.5}{1-0.5} = 1$。在 $10^{-12}$ 的容差下进行数值求和将非常接近这个值。\n  $$ \\tau_{\\mathrm{int,steps}} = 0.5 + 1.0 = 1.5 $$\n- 以时间单位计的 IAT 为：\n  $$ \\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\cdot \\Delta t = 1.5 \\cdot 0.693147 \\text{ ps} \\approx 1.0397205 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_3 = \\frac{2 \\cdot 4 \\cdot 1.0397205}{(0.2)^2} = \\frac{8 \\cdot 1.0397205}{0.04} = 200 \\cdot 1.0397205 \\approx 207.944 \\text{ ps} $$\n\n**情况4：离散时间不相关边界情况**\n- 给定：$\\rho_k = 0$ 对 $k \\ge 1$，$\\Delta t = 0.5$ $\\mathrm{ps}$，$\\sigma^2 = 16$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 1.0$ $\\mathrm{kJ/mol}$。\n- 我们计算 $\\tau_{\\mathrm{int,steps}}$：\n  $$ \\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} 0 = 0.5 $$\n- 这种情况代表一个完全不相关的过程（白噪声）。以时间单位计的 IAT 为：\n  $$ \\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\cdot \\Delta t = 0.5 \\cdot 0.5 \\text{ ps} = 0.25 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_4 = \\frac{2 \\cdot 16 \\cdot 0.25}{(1.0)^2} = 32 \\cdot 0.25 = 8.0 \\text{ ps} $$\n这对应于需要 $N = T/\\Delta t = 8.0/0.5 = 16$ 个样本，其均值的方差为 $\\sigma^2/N = 16/16 = 1 = \\varepsilon^2$，这与独立样本的预期相符。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Computes the minimal trajectory length T required for a given statistical tolerance\n    based on the integrated autocorrelation time of a stationary process.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Structure: (case_type, parameters_dict)\n    test_cases = [\n        ('continuous', {\n            'type': 'exponential', 'tau_c': 2.5, 'sigma_sq': 25.0, 'epsilon': 0.5\n        }),\n        ('continuous', {\n            'type': 'stretched_exponential', 'tau_c': 1.0, 'beta': 0.5, 'sigma_sq': 9.0, 'epsilon': 0.3\n        }),\n        ('discrete', {\n            'type': 'exponential', 'delta_t': 0.693147, 'tau_c': 1.0, 'sigma_sq': 4.0, 'epsilon': 0.2\n        }),\n        ('discrete', {\n            'type': 'uncorrelated', 'delta_t': 0.5, 'sigma_sq': 16.0, 'epsilon': 1.0\n        })\n    ]\n\n    results = []\n\n    for case_type, params in test_cases:\n        sigma_sq = params['sigma_sq']\n        epsilon = params['epsilon']\n\n        if case_type == 'continuous':\n            if params['type'] == 'exponential':\n                # For rho(tau) = exp(-tau/tau_c), the IAT is tau_c.\n                tau_int = params['tau_c']\n            elif params['type'] == 'stretched_exponential':\n                # For rho(tau) = exp(-(tau/tau_c)^beta), IAT = (tau_c/beta) * Gamma(1/beta)\n                tau_c = params['tau_c']\n                beta = params['beta']\n                tau_int = (tau_c / beta) * gamma(1.0 / beta)\n        \n        elif case_type == 'discrete':\n            delta_t = params['delta_t']\n            \n            sum_rho_k = 0.0\n            if params['type'] == 'exponential':\n                tau_c = params['tau_c']\n                k = 1\n                ratio = delta_t / tau_c\n                # Sum ACF terms until they are smaller than the given threshold.\n                while True:\n                    term = np.exp(-k * ratio)\n                    if term  1e-12:\n                        break\n                    sum_rho_k += term\n                    k += 1\n            elif params['type'] == 'uncorrelated':\n                # rho_k = 0 for k>=1, so the sum is 0.\n                sum_rho_k = 0.0\n            \n            # IAT in units of steps\n            tau_int_steps = 0.5 + sum_rho_k\n            # IAT in units of time\n            tau_int = tau_int_steps * delta_t\n            \n        # The master formula for minimal trajectory length T\n        # T = (2 * sigma^2 * tau_int) / epsilon^2\n        T = (2.0 * sigma_sq * tau_int) / (epsilon**2)\n        results.append(T)\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to 3 decimal places, enclosed in brackets.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3475291"}, {"introduction": "在了解了需要模拟多长时间之后，我们必须确保模拟的动力学过程在物理上是可靠的。对于哈密顿系统，这意味着要保持相空间的结构，这一性质被称为辛性[@problem_id:3475273]。本练习将深入探讨分子动力学中的主力积分算法——速度-Verlet算法，并要求你通过数值方法验证其关键的相空间体积保持特性，这是精确动力学中刘维尔定理的直接体现。", "problem": "考虑一个一维Lennard-Jones二聚体，它由两个质量为$m$的相同粒子组成，通过Lennard-Jones势$U(r) = 4\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right]$相互作用。其中$r = |x_1 - x_2|$，$x_1$和$x_2$是粒子位置，粒子的速度分别为$v_1$和$v_2$。假设系统在约化单位下进行描述，其中$m = 1$，$\\varepsilon = 1$，$\\sigma = 1$。哈密顿量为$H = \\dfrac{p_1^2}{2m} + \\dfrac{p_2^2}{2m} + U(|x_1 - x_2|)$，正则变量为$(x_1,x_2,p_1,p_2)$，且$p_i = m v_i$。\n\n通过将velocity-Verlet积分器的一个步长应用于状态向量$y = (x_1,x_2,v_1,v_2)$，定义一个时间离散映射$T_{\\Delta t}$：\n- 第一步半踢：$v_i^{n+1/2} = v_i^n + \\dfrac{\\Delta t}{2} a_i(x_1^n,x_2^n)$。\n- 漂移：$x_i^{n+1} = x_i^n + \\Delta t \\, v_i^{n+1/2}$。\n- 第二步半踢：$v_i^{n+1} = v_i^{n+1/2} + \\dfrac{\\Delta t}{2} a_i(x_1^{n+1},x_2^{n+1})$。\n\n此处$a_i = F_i/m$，$F_i$是作用在粒子$i$上的Lennard-Jones力，由$U(r)$通过$F_1 = -\\dfrac{dU}{dr} \\dfrac{x_1 - x_2}{r}$和$F_2 = -F_1$计算得出。\n\n您的任务是在一个固定的参考状态$y$下，通过中心有限差分法数值估计雅可比矩阵$J(\\Delta t) = \\dfrac{\\partial T_{\\Delta t}}{\\partial y}$，并计算其行列式$\\det J(\\Delta t)$。由于velocity-Verlet映射是辛映射，其真实行列式恰好为$1$。然而，由于有限差分近似中的截断误差，您的数值估计值会偏离$1$。使用中心差分扰动幅度$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$（其中$c = 10^{-2}$），并将其独立应用于$y$的每个分量，以近似雅可比矩阵的各列：\n$$\nJ_{\\cdot,i}(\\Delta t) \\approx \\frac{T_{\\Delta t}(y + \\varepsilon_{\\text{fd}} e_i) - T_{\\Delta t}(y - \\varepsilon_{\\text{fd}} e_i)}{2 \\, \\varepsilon_{\\text{fd}}}, \\quad i \\in \\{1,2,3,4\\},\n$$\n其中$e_i$是$\\mathbb{R}^4$中的第$i$个单位向量。定义绝对偏差$\\delta(\\Delta t) = \\left|\\det J(\\Delta t) - 1\\right|$。\n\n实现一个完整、可运行的程序，该程序：\n1. 在一维空间中，对两个粒子使用velocity-Verlet映射$T_{\\Delta t}$和Lennard-Jones力，采用约化单位制，其中$m = 1$，$\\varepsilon = 1$，$\\sigma = 1$。\n2. 对于每个指定的时间步长$\\Delta t$，在固定参考状态$y = (x_1, x_2, v_1, v_2) = (0, 1.5, 0.1, -0.05)$下，使用中心差分格式（其中$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$且$c = 10^{-2}$）计算有限差分雅可比矩阵。\n3. 返回所提供测试套件的绝对偏差$\\delta(\\Delta t)$列表。\n\n测试套件：\n- 使用时间步长$\\Delta t \\in \\{0.001, 0.002, 0.005, 0.01, 0.02\\}$。\n- 使用有限差分缩放因子$c = 10^{-2}$，使得对于每个$\\Delta t$都有$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$。\n- 使用固定初始状态$y = (0, 1.5, 0.1, -0.05)$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为$[r_1,r_2,r_3,r_4,r_5]$，其中$r_k$是测试套件中第$k$个时间步长对应的$\\delta(\\Delta t_k)$的浮点值。\n- 所有输出必须是无单位的实数（浮点数）。", "solution": "该问题是有效的。这是一个计算物理学中定义明确、科学合理的问题，旨在探究哈密顿系统数值积分器的性质。\n\n核心任务是数值评估velocity-Verlet积分算法的辛性。辛映射$T$描述了哈密顿系统在相空间中的演化，其一个关键性质是它保持相空间体积不变。这在数学上表示为映射的雅可bi矩阵$J$的行列式恰好为1：$\\det(J) = 1$。velocity-Verlet算法是一种著名的几何积分器，其设计初衷就是为了保持辛性。然而，题目要求我们并非解析地计算其雅可比矩阵，而是使用有限差分近似进行数值计算。这将引入截断误差，导致我们计算出的行列式偏离$1$。该问题要求计算对于一个特定系统和一组时间步长$\\Delta t$，这个偏差$\\delta(\\Delta t) = |\\det J(\\Delta t) - 1|$是多少。\n\n首先，我们定义物理系统。它由两个质量为$m=1$的一维相同粒子组成，通过Lennard-Jones (LJ) 势相互作用。在指定的约化单位（其中$\\varepsilon=1$和$\\sigma=1$）下，势能为：\n$$\nU(r) = 4\\left(r^{-12} - r^{-6}\\right)\n$$\n其中$r = |x_1 - x_2|$是位于$x_1$和$x_2$处粒子间的距离。系统的哈密顿量为$H = \\frac{p_1^2}{2m} + \\frac{p_2^2}{2m} + U(|x_1 - x_2|)$。运动方程由牛顿第二定律$m a_i = F_i$给出，其中$a_i$是粒子$i$的加速度，$F_i$是作用在该粒子上的力。由于$m=1$，我们有$a_i = F_i$。力是势的负梯度。对于粒子1，力由$F_1 = -\\frac{dU}{dr} \\frac{x_1 - x_2}{r}$给出。根据牛顿第三定律，作用在粒子2上的力为$F_2 = -F_1$。\n\nLJ势对$r$的导数为：\n$$\n\\frac{dU}{dr} = 4\\left(-12r^{-13} + 6r^{-7}\\right) = \\frac{24}{r}\\left(-2r^{-12} + r^{-6}\\right)\n$$\n该表达式使我们能够为任意给定的粒子位置对$(x_1, x_2)$计算力和加速度。\n\n接下来，我们使用velocity-Verlet积分器来形式化时间演化过程。系统的状态由一个4维向量$y = (x_1, x_2, v_1, v_2)$描述。一个持续时间为$\\Delta t$的单个积分步将时间$t_n$的状态$y^n$映射到时间$t_{n+1} = t_n + \\Delta t$的状态$y^{n+1}$。此映射记为$T_{\\Delta t}$，因此$y^{n+1} = T_{\\Delta t}(y^n)$。该算法分三步进行：\n1.  计算中间步的速度：$v_i^{n+1/2} = v_i^n + \\frac{\\Delta t}{2} a_i(x_1^n, x_2^n)$，其中$i \\in \\{1,2\\}$。\n2.  使用这些中間步的速度更新位置：$x_i^{n+1} = x_i^n + \\Delta t \\, v_i^{n+1/2}$，其中$i \\in \\{1,2\\}$。\n3.  计算新位置处的加速度$a_i(x_1^{n+1}, x_2^{n+1})$，并完成速度更新：$v_i^{n+1} = v_i^{n+1/2} + \\frac{\\Delta t}{2} a_i(x_1^{n+1}, x_2^{n+1})$，其中$i \\in \\{1,2\\}$。\n\n问题的核心部分是计算该映射的雅可比矩阵$J(\\Delta t)$，并在特定参考状态$y = (0, 1.5, 0.1, -0.05)$下进行求值。雅可比矩阵是一个$4 \\times 4$矩阵，其元素为$J_{ij} = \\frac{\\partial (T_{\\Delta t}(y))_i}{\\partial y_j}$。我们将使用中心有限差分公式来近似雅可比矩阵的每一列。对于第$j$列（$j \\in \\{1,2,3,4\\}$）：\n$$\nJ_{\\cdot,j}(\\Delta t) \\approx \\frac{T_{\\Delta t}(y + \\varepsilon_{\\text{fd}} e_j) - T_{\\Delta t}(y - \\varepsilon_{\\text{fd}} e_j)}{2 \\varepsilon_{\\text{fd}}}\n$$\n此处，$e_j$是$\\mathbb{R}^4$中的第$j$个标准基向量（例如，$e_1 = (1,0,0,0)$），$\\varepsilon_{\\text{fd}}$是一个小的扰动幅度。问题规定此幅度应随时间步長缩放：$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$，其中$c = 10^{-2}$。\n\n总体算法如下：\n1.  对于给定测试套件$\\{0.001, 0.002, 0.005, 0.01, 0.02\\}$中的每个时间步长$\\Delta t$。\n2.  设置有限差分扰动$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$。\n3.  初始化一个空的$4 \\times 4$矩阵$J$。\n4.  对于从1到4的每个列索引$j$：a. 定义受扰动的初始状态$y^+ = y + \\varepsilon_{\\text{fd}} e_j$和$y^- = y - \\varepsilon_{\\text{fd}} e_j$。b. 使用velocity-Verlet映射将$y^+$和$y^-$演化一个时间步长，得到$y'^+ = T_{\\Delta t}(y^+)$和$y'^- = T_{\\Delta t}(y^-)$。c. 计算雅可比矩阵的第$j$列为$(y'^+ - y'^-) / (2 \\varepsilon_{\\text{fd}})$。\n5.  构建完整的矩阵$J$后，计算其行列式$\\det J(\\Delta t)$。\n6.  计算绝对偏差$\\delta(\\Delta t) = |\\det J(\\Delta t) - 1|$。\n7.  收集所有指定的$\\Delta t$对应的$\\delta(\\Delta t)$值。\n\n此过程将使用`numpy`库在Python程序中实现，以便进行高效的向量和矩阵运算，包括行列式计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the deviation of the numerically computed Jacobian determinant of the\n    velocity-Verlet map from 1 for a 1D Lennard-Jones dimer.\n    \"\"\"\n\n    # Reduced unit constants from the problem statement\n    M = 1.0\n    EPSILON = 1.0\n    SIGMA = 1.0\n    \n    # Finite-difference scaling factor\n    C_FD = 1e-2\n\n    # Fixed reference state y = (x1, x2, v1, v2)\n    y_ref = np.array([0.0, 1.5, 0.1, -0.05])\n    \n    # Test suite of time steps\n    test_cases = [0.001, 0.002, 0.005, 0.01, 0.02]\n\n    def calculate_accelerations(positions):\n        \"\"\"\n        Computes the accelerations of the two particles based on their positions.\n        \n        Args:\n            positions (np.ndarray): A 2-element array [x1, x2].\n            \n        Returns:\n            np.ndarray: A 2-element array [a1, a2].\n        \"\"\"\n        x1, x2 = positions[0], positions[1]\n        r_vec = x1 - x2\n        r = abs(r_vec)\n\n        # Avoid division by zero, though unlikely with the LJ potential\n        if r == 0.0:\n            return np.array([0.0, 0.0])\n\n        r_inv = SIGMA / r\n        r_inv6 = r_inv**6\n        r_inv12 = r_inv6**2\n\n        # Force calculation based on F = -dU/dr * (x1-x2)/r\n        # dU/dr = (24 * EPSILON / r) * (-2 * (SIGMA/r)**12 + (SIGMA/r)**6)\n        dU_dr = (24.0 * EPSILON / r) * (-2.0 * r_inv12 + r_inv6)\n        \n        # In 1D, (x1-x2)/r is just sign(x1-x2)\n        force_on_1 = -dU_dr * np.sign(r_vec) if r_vec != 0 else 0\n\n        # Acceleration a = F/m\n        accel_1 = force_on_1 / M\n        accel_2 = -accel_1  # By Newton's third law\n\n        return np.array([accel_1, accel_2])\n\n    def velocity_verlet_step(y, dt):\n        \"\"\"\n        Performs one step of the velocity-Verlet integration.\n        \n        Args:\n            y (np.ndarray): The 4-element state vector [x1, x2, v1, v2].\n            dt (float): The time step.\n            \n        Returns:\n            np.ndarray: The new state vector after one time step.\n        \"\"\"\n        pos_n = y[0:2]\n        vel_n = y[2:4]\n\n        # First half-kick\n        accel_n = calculate_accelerations(pos_n)\n        vel_half = vel_n + 0.5 * dt * accel_n\n\n        # Drift\n        pos_new = pos_n + dt * vel_half\n\n        # Second half-kick\n        accel_new = calculate_accelerations(pos_new)\n        vel_new = vel_half + 0.5 * dt * accel_new\n\n        return np.concatenate((pos_new, vel_new))\n\n    results = []\n    for dt in test_cases:\n        eps_fd = C_FD * dt\n        jacobian = np.zeros((4, 4))\n        \n        for i in range(4):\n            # Create perturbation vectors\n            perturbation = np.zeros(4)\n            perturbation[i] = eps_fd\n\n            y_plus = y_ref + perturbation\n            y_minus = y_ref - perturbation\n\n            # Evolve perturbed states\n            y_next_plus = velocity_verlet_step(y_plus, dt)\n            y_next_minus = velocity_verlet_step(y_minus, dt)\n\n            # Compute column of the Jacobian using central differences\n            jacobian_col = (y_next_plus - y_next_minus) / (2.0 * eps_fd)\n            jacobian[:, i] = jacobian_col\n\n        # Calculate determinant and its deviation from 1\n        det_J = np.linalg.det(jacobian)\n        deviation = abs(det_J - 1.0)\n        results.append(deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3475273"}, {"introduction": "我们前两个练习都假设了系统是遍历的。但如果系统不是遍历的呢？这最后一个练习探讨了一种情景，其中系统的状态空间分裂成不相连的区域，导致遍历性破缺[@problem_id:3475310]。通过一个空位扩散的动力学蒙特卡洛模型，你将学习如何通过分析状态空间图的连通性来诊断此问题，并使用转变矩阵的谱隙来量化遍历性破缺的严重程度。", "problem": "考虑一个二维 Bravais 晶格上的单空位扩散模型，该模型表示为一个具有有限状态空间的连续时间马尔可夫链。每个状态对应空位所占据的晶格位置，允许的转移对应最近邻跃迁。设从状态 $i$ 到状态 $j$ 的跃遷速率由阿伦尼乌斯形式给出 $k_{ij}=\\nu \\exp(-E_{ij}/(k_{\\mathrm{B}} T))$，其中 $\\nu$ 为尝试频率，$E_{ij}$ 为能垒，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。该连续时间过程的生成矩阵 $Q$ 满足：当 $i \\neq j$ 时，$Q_{ij} = k_{ij}$；当 $i = j$ 时，$Q_{ii} = -\\sum_{j \\neq i} k_{ij}$。使用均匀化构造，其中全局速率 $\\gamma$ 严格大于最大离开速率 $r_{\\max}=\\max_i \\sum_{j \\neq i} k_{ij}$，来定义离散时间转移矩阵 $P = I + Q / \\gamma$。对于均匀化，设 $\\gamma=\\alpha r_{\\max}$，其中固定 $\\alpha1$。\n\n从连续时间马尔可夫链、最近邻空位扩散和阿伦尼乌斯定律的基本定义出发，对一个尺寸为 $L_x \\times L_y$、具有周期性边界或开放边界的有限矩形晶格，执行以下操作：\n1. 构建状态图（以晶格位置为节点），其中允许的最近邻跃迁为无向边。对于每个允许的边 $\\{i,j\\}$，分配一个以电子伏特为单位的能垒 $E_{ij}$，并为 $i \\to j$ 和 $j \\to i$ 两个方向设置 $k_{ij}=\\nu \\exp(-E_{ij}/(k_{\\mathrm{B}} T))$。如果某条边被禁止，则视为其具有无限大能垒，从而相关速率为零，该边不存在。\n2. 根据速率构建生成矩阵 $Q$，然后构建均匀化转移矩阵 $P=I+Q/\\gamma$，其中 $\\gamma=\\alpha r_{\\max}$ 且 $\\alpha1$，使得只要节点的离开速率为正，其对应的对角元素 $P_{ii}$ 就严格为正。\n3. 通过检查底层无向图的连通性来判断 $P$ 的不可约性。根据基本原理判断 $P$ 的非周期性：对于一个不可约链，如果存在任何状态的自转移概率 $P_{ii}0$ 严格为正，则周期为 $1$。如果链是可约的，则报告其对于整个状态空间不是非周期的。\n4. 计算 $P$ 的谱隙 $\\lambda_2$，公式为 $\\lambda_2 = 1 - \\max_{i \\ge 2} |\\lambda_i|$，其中 $\\{\\lambda_i\\}$ 是 $P$ 的特征值，按模非递增排序，对于随机矩阵 $\\lambda_1=1$。如果链是可约的，则特征值 $1$ 的重数大于 $1$，这意味着 $\\lambda_2=0$。\n\n使用以下具有指定物理单位的常量：\n- $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ 电子伏特/开尔文,\n- $\\nu = 1.0 \\times 10^{13}$ /秒,\n- $\\alpha = 1.1$ (无量纲),\n- 所有能垒 $E_{ij}$ 单位为电子伏特,\n- 温度 $T$ 单位为开尔文。\n\n实现一个程序，对以下晶格和能垒规格的测试套件执行上述构造和分析。在每种情况下，空位可以跃迁到四个允许的最近邻位置。所有未指定的边都使用一个均匀能垒 $E_0$。\n\n测试套件：\n- 情况 1（理想情况，周期性，均匀能垒）：$L_x = 4$，$L_y = 4$，双向启用周期性边界， $E_0 = 0.6$ 电子伏特，$T = 800$ 开尔文，无禁止边，无特殊能垒分配。\n- 情况 2（通过禁止移动导致遍历性丧失，开放边界）：$L_x = 3$，$L_y = 3$，开放边界（无周期性），$E_0 = 0.6$ 电子伏特，$T = 800$ 开尔文，所有连接 $(x,y)=(0,1),(1,1),(2,1)$ 到 $(x,y)=(0,2),(1,2),(2,2)$ 的垂直边都被禁止。这将晶格划分为不连通的组件。\n- 情况 3（小型周期性晶格）：$L_x = 2$，$L_y = 2$，启用周期性边界，$E_0 = 0.6$ 电子伏特，$T = 800$ 开尔文，无禁止边，无特殊能垒。\n- 情况 4（连通但有瓶颈，周期性，带有高能垒切割）：$L_x = 6$，$L_y = 6$，启用周期性边界，$E_0 = 0.6$ 电子伏特，$T = 800$ 开尔文。对于 $x \\in \\{0,1,2,3,4,5\\}$，所有行 $y=2$ 和 $y=3$ 之间的垂直边具有更高的能垒 $E_{\\mathrm{high}} = 1.5$ 电子伏特；所有其他边使用 $E_0$。这引入了一个严重的动力学瓶颈，但并未使图断开。\n\n您的程序必须为每种情况生成一个包含三个值的列表：一个不可约性布尔值、一个非周期性布尔值以及保留六位小数的谱隙 $\\lambda_2$。将所有情况的结果按给定顺序汇总到一个列表中，并仅打印包含此汇总列表的单行作为最终格式。\n\n最终输出格式：\n- 单行输出，包含一个 Python 风格的列表的列表，每种情况一个，其中每个内部列表的形式为 $[\\text{irreducible}, \\text{aperiodic}, \\lambda_2]$，布尔值打印为 $\\text{True}$ 或 $\\text{False}$，$\\lambda_2$ 为保留六位小数的浮点数。例如，一个有效的输出形式为 $[[\\text{True},\\text{True},0.123456],[\\text{False},\\text{False},0.000000],[\\text{True},\\text{True},0.987654],[\\text{True},\\text{True},0.012345]]$。", "solution": "该问题要求分析二维晶格上的单空位扩散模型。此分析涉及确定一个连续时间马尔可夫链（CTMC）模型在不同晶格配置下的不可约性、非周期性和谱隙。该方法基于马尔可夫链理论的标准原理及其在材料科学中的应用。\n\n### 1. 模型构建：空位扩散的 CTMC\n\n系统的状态空间是单个空位可以占据的所有可能晶格位置的集合。对于一个尺寸为 $L_x \\times L_y$ 的矩形晶格，存在 $N = L_x \\times L_y$ 个状态。我们将一个位置的二维坐标 $(x,y)$（其中 $0 \\le x  L_x$ 且 $0 \\le y  L_y$）映射到一个一维索引 $i = y \\cdot L_x + x$。\n\n状态之间的转移对应于空位跃迁到相邻的最近邻位置。该过程被建模为一个 CTMC，由生成矩阵 $Q$ 控制。对于 $i \\neq j$，非对角元素 $Q_{ij}$ 表示从状态 $i$ 到状态 $j$ 的转移速率，而对角元素为 $Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$，表示从状态 $i$ 的总离开速率。\n\n转移速率 $k_{ij}$ 由阿伦尼乌斯方程给出：\n$$ k_{ij} = \\nu \\exp\\left(-\\frac{E_{ij}}{k_{\\mathrm{B}} T}\\right) $$\n其中 $\\nu$ 是尝试频率，$E_{ij}$ 是跃迁的能垒，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。对于最近邻扩散，问题指定能垒是对称的，$E_{ij} = E_{ji}$，这意味着速率也是对称的，$k_{ij} = k_{ji}$。如果一个跃迁被禁止，其能垒实际上是无限的，使得速率 $k_{ij} = 0$。\n\n### 2. 均匀化：从 CTMC 到 DTMC\n\n为便于分析，使用均匀化技术将 CTMC 转换为等效的离散时间马尔可夫链 (DTMC)。这需要一个均匀速率 $\\gamma$，该速率严格大于任何状态的最大离开速率 $r_{\\max} = \\max_i (-Q_{ii})$。问题指定使用 $\\gamma = \\alpha r_{\\max}$，其中 $\\alpha  1$。\n\n resultant DTMC 的转移矩阵 $P$ 由下式给出：\n$$ P = I + \\frac{1}{\\gamma} Q $$\n其中 $I$ 是单位矩阵。$P$ 的元素为：\n- $P_{ij} = \\frac{Q_{ij}}{\\gamma} = \\frac{k_{ij}}{\\gamma}$ 对于 $i \\neq j$。\n- $P_{ii} = 1 + \\frac{Q_{ii}}{\\gamma} = 1 - \\frac{\\sum_{j \\neq i} k_{ij}}{\\gamma}$。\n\n由于对于所有 $i$，$\\gamma  r_{\\max} \\ge \\sum_{j \\neq i} k_{ij}$，所有元素 $P_{ij}$ 都是非负的。$P$ 的行和为 $1$，使其成为一个有效的随机矩阵：\n$$ \\sum_j P_{ij} = P_{ii} + \\sum_{j \\neq i} P_{ij} = \\left(1 - \\frac{\\sum_{j \\neq i} k_{ij}}{\\gamma}\\right) + \\sum_{j \\neq i} \\frac{k_{ij}}{\\gamma} = 1 $$\n\n### 3. 遍历性分析：不可约性与非周期性\n\n如果马尔可夫链既是不可约的又是非周期的，则它是遍历的。遍历性确保了系统在长时间演化后会收敛到一个唯一的平稳分布。\n\n- **不可约性**：如果每个状态都可以从任何其他状态到达，则链是不可约的。对于具有对称速率（$k_{ij} = k_{ji}$）的链，这等价于底层无向图的连通性。该图的节点是晶格位置（状态），如果两个节点之间的转移速率非零，则它们之间存在一条边。我们可以通过算法验证连通性，例如，从一个任意节点开始执行广度优先搜索（BFS）或深度优先搜索（DFS），并检查是否访问了所有 $N$ 个节点。\n\n- **非周期性**：对于不可约链，如果至少存在一个状态 $i$ 的自转移概率 $P_{ii}  0$，则可以保证其非周期性（周期为 1）。在我们的均匀化构造中，对于任何非孤立的状态 $i$（即至少有一次允许的向邻居的跃迁），其离开速率 $\\sum_{j \\neq i} k_{ij}$ 为正。由于 $\\gamma  \\sum_{j \\neq i} k_{ij}$，其自转移概率 $P_{ii} = 1 - (\\sum_{j \\neq i} k_{ij}) / \\gamma$ 严格大于 $0$ 且小于 $1$。在超过一个状态的不可约链中，没有状态可以是孤立的。因此，每个状态都将具有正的自转移概率，从而保证以这种方式构造的任何不可约链也是非周期的。如果链是可约的，问题指示将其报告为非周期性为否。\n\n### 4. 收敛速率：谱隙\n\n收敛到平稳分布的速率由转移矩阵 P 的谱隙决定。$P$ 的特征值 $\\{\\lambda_i\\}_{i=1}^N$ 按其模非递增排序，$|\\lambda_{(1)}| \\ge |\\lambda_{(2)}| \\ge \\dots \\ge |\\lambda_{(N)}|$。对于任何随机矩阵，最大的特征值是 $\\lambda_{(1)} = 1$。谱隙定义为：\n$$ \\lambda_2 = 1 - |\\lambda_{(2)}| $$\n其中 $|\\lambda_{(2)}|$ 是第二大特征值的模。\n\n如果链是不可约的，则特征值 $1$ 的重数为一，因此 $|\\lambda_{(2)}|  1$ 且谱隙 $\\lambda_2$ 为正。更大的谱隙意味着更快的收敛。如果链是可约的，它有多个通信类，并且特征值 $1$ 出现的重数等于类的数量。在这种情况下，$|\\lambda_{(2)}| = 1$，谱隙为 $\\lambda_2 = 0$，表示在整个状态空间上不会收敛到唯一的平稳分布。\n\n### 5. 算法实现\n\n该解决方案通过对每个测试案例执行上述步骤来实现：\n1.  **图的构建**：对于给定的晶格尺寸（$L_x, L_y$）和边界条件，构建状态图。这包括为每个位置识别最近邻，并检查是否存在禁止边或具有特殊能垒的边。\n2.  **矩阵填充**：根据分配的能垒、温度 $T$ 以及常数 $\\nu$ 和 $k_{\\mathrm{B}}$ 来构建速率矩阵 $K$（其中 $K_{ij}=k_{ij}$）。从 $K$ 构建生成矩阵 $Q$。\n3.  **不可约性/非周期性检查**：在由非零速率定义的图上执行图遍历（BFS）以检查连通性，从而确定不可约性。然后根据不可约性推断非周期性。\n4.  **谱隙计算**：如果链是可约的，则谱隙为 $0$。否则，计算均匀化速率 $\\gamma$ 并构建矩阵 $P$。使用数值库计算其特征值。然后从第二大特征值的模计算谱隙。\n5.  **结果聚合**：对于每个测试案例，收集计算出的不可约性和非周期性的布尔值，以及四舍五入到六位小数的谱隙，并将其格式化为所需的输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n\n    def process_case(Lx, Ly, boundary, T, E0, forbidden_edges_coords, special_barriers_coords):\n        \"\"\"\n        Processes a single test case for the vacancy diffusion model.\n\n        Args:\n            Lx (int): Lattice dimension in x.\n            Ly (int): Lattice dimension in y.\n            boundary (str): 'periodic' or 'open'.\n            T (float): Temperature in Kelvin.\n            E0 (float): Default energy barrier in eV.\n            forbidden_edges_coords (set): A set of frozensets of coordinate tuples for forbidden edges.\n            special_barriers_coords (dict): A dict mapping frozensets of coordinate tuples to special barriers.\n\n        Returns:\n            list: A list containing [irreducibility, aperiodicity, spectral_gap].\n        \"\"\"\n        N = Lx * Ly\n        if N == 0:\n            return [True, True, 1.0]\n\n        KB = 8.617333262145e-5  # eV/K\n        NU = 1.0e13  # s^-1\n        ALPHA = 1.1\n\n        # Helper to map 2D coords to 1D index\n        def to_idx(x, y):\n            return y * Lx + x\n\n        # Pre-process edge specifications from coordinates to indices\n        forbidden_edges_idx = {frozenset({to_idx(c1[0], c1[1]), to_idx(c2[0], c2[1])}) for c1, c2 in forbidden_edges_coords}\n        special_barriers_idx = {frozenset({to_idx(c1[0], c1[1]), to_idx(c2[0], c2[1])}): val for (c1, c2), val in special_barriers_coords.items()}\n\n        # 1. Build rate matrix K from graph\n        K = np.zeros((N, N))\n        for y_i in range(Ly):\n            for x_i in range(Lx):\n                i = to_idx(x_i, y_i)\n                # Iterate over right and up neighbors to avoid double counting\n                for dx, dy in [(1, 0), (0, 1)]:\n                    x_j_raw, y_j_raw = x_i + dx, y_i + dy\n\n                    if boundary == 'periodic':\n                        x_j, y_j = x_j_raw % Lx, y_j_raw % Ly\n                        is_valid_neighbor = True\n                    else:  # 'open'\n                        x_j, y_j = x_j_raw, y_j_raw\n                        is_valid_neighbor = (0 = x_j  Lx) and (0 = y_j  Ly)\n\n                    if is_valid_neighbor:\n                        j = to_idx(x_j, y_j)\n                        edge_idx = frozenset({i, j})\n\n                        if edge_idx in forbidden_edges_idx:\n                            continue\n\n                        barrier = special_barriers_idx.get(edge_idx, E0)\n                        rate = NU * np.exp(-barrier / (KB * T))\n                        K[i, j] = rate\n                        K[j, i] = rate\n\n        # 2. Check for irreducibility (graph connectivity) via BFS\n        is_irreducible = False\n        if N > 0:\n            q = [0]\n            visited = {0}\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                for v_neighbor, rate in enumerate(K[u]):\n                    if rate > 0 and v_neighbor not in visited:\n                        visited.add(v_neighbor)\n                        q.append(v_neighbor)\n            is_irreducible = len(visited) == N\n\n        # 3. Check for aperiodicity\n        is_aperiodic = is_irreducible\n\n        # 4. Compute spectral gap\n        spectral_gap = 0.0\n        if is_irreducible:\n            if N == 1:\n                spectral_gap = 1.0 # By convention\n            else:\n                Q = np.copy(K)\n                exit_rates = np.sum(K, axis=1)\n                np.fill_diagonal(Q, -exit_rates)\n\n                r_max = np.max(exit_rates)\n                \n                if r_max > 0:\n                    gamma = ALPHA * r_max\n                    P = np.identity(N) + Q / gamma\n                    \n                    eigvals = np.linalg.eigvals(P)\n                    eig_mags = sorted(np.abs(eigvals), reverse=True)\n                    \n                    second_largest_mag = eig_mags[1]\n                    spectral_gap = 1.0 - second_largest_mag\n                else: # Graph with no edges (but connected, so N=1)\n                    spectral_gap = 1.0\n\n        return [is_irreducible, is_aperiodic, spectral_gap]\n\n    # --- Test Suite Definition ---\n\n    # Case 1: 4x4, periodic, uniform barriers\n    case1_params = {\n        \"Lx\": 4, \"Ly\": 4, \"boundary\": \"periodic\", \"T\": 800, \"E0\": 0.6,\n        \"forbidden_edges_coords\": set(), \"special_barriers_coords\": {}\n    }\n\n    # Case 2: 3x3, open, disconnected\n    case2_params = {\n        \"Lx\": 3, \"Ly\": 3, \"boundary\": \"open\", \"T\": 800, \"E0\": 0.6,\n        \"forbidden_edges_coords\": {\n            frozenset({(0, 1), (0, 2)}),\n            frozenset({(1, 1), (1, 2)}),\n            frozenset({(2, 1), (2, 2)}),\n        },\n        \"special_barriers_coords\": {}\n    }\n\n    # Case 3: 2x2, periodic, uniform barriers\n    case3_params = {\n        \"Lx\": 2, \"Ly\": 2, \"boundary\": \"periodic\", \"T\": 800, \"E0\": 0.6,\n        \"forbidden_edges_coords\": set(), \"special_barriers_coords\": {}\n    }\n\n    # Case 4: 6x6, periodic, bottleneck\n    Lx_c4, Ly_c4 = 6, 6\n    E_high = 1.5\n    special_barriers_c4 = {\n        frozenset({(x, 2), (x, 3)}): E_high for x in range(Lx_c4)\n    }\n    case4_params = {\n        \"Lx\": Lx_c4, \"Ly\": Ly_c4, \"boundary\": \"periodic\", \"T\": 800, \"E0\": 0.6,\n        \"forbidden_edges_coords\": set(), \"special_barriers_coords\": special_barriers_c4\n    }\n\n    test_cases = [case1_params, case2_params, case3_params, case4_params]\n    \n    results = []\n    for params in test_cases:\n        result = process_case(**params)\n        results.append(result)\n\n    # Format output as specified\n    sublist_strings = [f\"[{res[0]},{res[1]},{res[2]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(sublist_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3475310"}]}