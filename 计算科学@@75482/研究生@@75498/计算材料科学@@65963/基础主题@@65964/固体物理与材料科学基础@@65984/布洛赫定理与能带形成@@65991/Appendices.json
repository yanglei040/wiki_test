{"hands_on_practices": [{"introduction": "将连续的薛定谔方程转化为可计算的矩阵问题是计算材料科学的核心。本练习将指导您使用平面波基组，为一维周期性势构建哈密顿量，并通过收敛性分析，亲身体验选择截断能 $E_{\\text{cut}}$ 这一基础且关键的步骤。掌握这一技能对于确保任何平面波计算的准确性和可靠性至关重要。", "problem": "要求您实现一维不含时薛定谔方程的平面波离散化，该方程用于描述一个质量为 $m$ 的电子在空间周期性势中的运动，并量化最低布洛赫能带能量相对于平面波动能截断的收敛性。该物理系统由势 $V(x)=V_0\\cos(2\\pi x/a)$ 定义，其中 $a$ 是晶格常数，$V_0$ 是势振幅。在整个计算过程中使用以下约化单位：令约化普朗克常数 $\\hbar=1$ 和电子质量 $m=1$，因此能量是无量纲的。您的程序必须为下面描述的每个测试用例输出一个收敛指数，输出值无需物理单位。\n\n起点与核心定义：\n- 考虑一维不含时薛定谔方程 $H\\psi_k(x)=E_k\\psi_k(x)$，其中 $H=-\\frac{1}{2}\\frac{d^2}{dx^2}+V(x)$，周期性势 $V(x)=V_0\\cos(2\\pi x/a)$。\n- 根据布洛赫定理，本征函数具有形式 $\\psi_k(x)=e^{ikx}u_k(x)$，其中 $u_k(x)$ 是周期为 $a$ 的周期函数，$k$ 是第一布里渊区中的晶体动量。\n- 将 $u_k(x)$ 在平面波 $e^{iGx}$ 中展开，其中 $G$ 遍历倒易晶格矢量 $G_0=2\\pi/a$ 的整数倍，即 $G=nG_0$，其中 $n\\in\\mathbb{Z}$。在平面波基矢 $\\{\\lvert k+G\\rangle\\}$ 中，哈密顿矩阵由动能和 $V(x)$ 的傅里叶分量确定。\n\n实现要求：\n- 对于给定的 $k$、$V_0$ 和 $a$，定义动能平面波截断 $E_{\\text{cut}}>0$，并将基矢限制在所有动能不超过该截断的平面波 $\\lvert k+nG_0\\rangle$ 上：包括所有满足 $\\frac{1}{2}(k+nG_0)^2\\le E_{\\text{cut}}$ 的整数 $n$。\n- 在此截断基矢中，使用以下公式构建哈密顿矩阵：\n  - 动能矩阵元：$\\langle k+nG_0\\lvert -\\frac{1}{2}\\frac{d^2}{dx^2}\\rvert k+n'G_0\\rangle=\\frac{1}{2}(k+nG_0)^2\\,\\delta_{n,n'}$。\n  - 势能矩阵元由 $V(x)=V_0\\cos(2\\pi x/a)$ 的傅里叶级数确定；唯一非零的傅里叶系数位于 $G=\\pm G_0$ 处，其振幅为 $V_{\\pm G_0}=V_0/2$。因此，在 $\\{n\\}$ 指数下，唯一非零的非对角耦合发生在最近邻之间：$\\langle k+nG_0\\lvert V\\rvert k+n'G_0\\rangle=(V_0/2)\\,(\\delta_{n,n'+1}+\\delta_{n,n'-1})$。\n- 对于指定列表中的每个 $E_{\\text{cut}}$，计算截断后哈密顿量的最低本征值 $E_0(k;E_{\\text{cut}})$。使用一个非常大的截断 $E_{\\text{cut}}^{\\text{ref}}$ 来定义一个参考值 $E_0^{\\text{ref}}(k)=E_0(k;E_{\\text{cut}}^{\\text{ref}})$，并定义绝对本征值误差 $\\varepsilon(E_{\\text{cut}})=\\lvert E_0(k;E_{\\text{cut}})-E_0^{\\text{ref}}(k)\\rvert$。\n- 对所提供截断值列表中的 $\\log \\varepsilon(E_{\\text{cut}})$ 与 $\\log E_{\\text{cut}}$ 进行对数-对数线性回归，并报告斜率 $s$，该斜率估计了收敛速率指数，即当 $E_{\\text{cut}}\\to\\infty$ 时，$\\varepsilon(E_{\\text{cut}})\\sim C\\,E_{\\text{cut}}^{\\,s}$。\n\n角度和单位说明：\n- 所有三角函数的参数均以弧度为单位。\n- 由于采用了 $\\hbar=1$ 和 $m=1$ 的约化单位约定，您计算中的能量和动量均为无量纲。将最终的数值斜率报告为无量纲浮点数。\n\n测试套件：\n- 使用倒易晶格矢量 $G_0=2\\pi/a$，其中 $a=1$。\n- 对于每个测试用例，使用以下参数和截断值计算斜率 $s$，并将参考截断值设为 $E_{\\text{cut}}^{\\text{ref}}=2000$。\n  1. 测试用例 1：$V_0=2$, $a=1$, $k=0$, $E_{\\text{cut}}\\in\\{30,60,120,240\\}$。\n  2. 测试用例 2：$V_0=2$, $a=1$, $k=\\pi/a$, $E_{\\text{cut}}\\in\\{30,60,120,240\\}$。\n  3. 测试用例 3：$V_0=5$, $a=1$, $k=(\\pi/2)/a$, $E_{\\text{cut}}\\in\\{40,80,160,320\\}$。\n\n算法约束：\n- 哈密顿量的构建必须遵循所述的动能项和余弦势的非零傅里叶分量。对于每个 $E_{\\text{cut}}$，实现必须精确地包含满足动能截断条件 $\\frac{1}{2}(k+nG_0)^2\\le E_{\\text{cut}}$ 的基矢态。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目，顺序与上面列出的一致。每个条目必须是拟合的斜率 $s$，表示为浮点数，并四舍五入到三位小数。例如，一个有效的输出可能看起来像“[$-1.002,-1.015,-0.998$]”。\n\n科学真实性要求：\n- 仅使用此处陈述的定义和构造，不使用任何外部数据。确保所有矩阵都是厄米的，并且对于给定的尺寸，本征问题都求解到完全的数值精度。\n\n您的程序必须实现上述要求，并严格按照指定的最终输出格式打印。程序在运行时不提供任何输入；所有参数均如上所述。斜率计算必须使用每个测试用例列出的所有截断值。", "solution": "该问题要求实现一种平面波离散化方法，以求解周期性势场中的一维不含时薛定谔方程，并分析基态能量相对于基组动能截断的收敛性。\n\n物理系统是一个质量为 $m=1$ 的电子在势 $V(x) = V_0\\cos(2\\pi x/a)$ 中运动，其哈密顿量为 $H=-\\frac{1}{2}\\frac{d^2}{dx^2}+V(x)$，其中约化普朗克常数 $\\hbar=1$。根据布洛赫定理，对于给定的晶体动量 $k$，波函数可以写为 $\\psi_k(x) = e^{ikx}u_k(x)$，其中 $u_k(x)$ 与势具有相同的周期性 $a$。周期函数 $u_k(x)$ 可以在倒易晶格矢量 $G_n = nG_0 = n(2\\pi/a)$（其中 $n$ 为整数）上展开为傅里叶级数：\n$$u_k(x) = \\sum_n c_{n} e^{iG_n x}$$\n这导致了完整波函数 $\\psi_k(x)$ 在平面波基矢上的展开：\n$$\\psi_k(x) = \\sum_n c_{n} e^{i(k+G_n)x}$$\n通过在该基矢中求解薛定谔方程 $H\\psi_k(x) = E_k\\psi_k(x)$，可以找到系数 $c_n$ 和能量本征值 $E_k$。将平面波展开式代入薛定谔方程，并投影到基矢态 $\\lvert k+G_{n'}\\rangle$（由函数 $e^{i(k+G_{n'})x}$ 表示）上，得到以系数 $\\vec{c}$ 为基的矩阵本征值方程：\n$$\\sum_n H_{n',n} c_n = E_k c_{n'}$$\n其中 $H_{n',n}$ 是哈密顿量在平面波基矢 $\\{\\lvert k+G_n\\rangle\\}$ 中的矩阵元。\n\n矩阵元由 $H_{n',n} = \\langle k+G_{n'} | H | k+G_n \\rangle$ 给出。哈密顿量由一个动能项 $T = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 和一个势能项 $V(x)$ 组成。\n\n动能算符在平面波基矢中是对角的。其矩阵元为：\n$$T_{n',n} = \\langle k+G_{n'} | T | k+G_n \\rangle = \\frac{1}{2}(k+G_n)^2 \\delta_{n',n}$$\n势能为 $V(x) = V_0\\cos(G_0 x) = \\frac{V_0}{2}(e^{iG_0x} + e^{-iG_0x})$。其矩阵元由势能的傅里叶变换给出：\n$$V_{n',n} = \\langle k+G_{n'} | V(x) | k+G_n \\rangle = \\frac{1}{L} \\int_0^L e^{-i(k+G_{n'})x} V(x) e^{i(k+G_n)x} dx$$\n$$V_{n',n} = \\frac{V_0}{2L} \\int_0^L e^{-i(G_{n'}-G_n)x} (e^{iG_0x} + e^{-iG_0x}) dx$$\n$$V_{n',n} = \\frac{V_0}{2L} \\int_0^L (e^{i(G_n-G_{n'}+G_0)x} + e^{i(G_n-G_{n'}-G_0)x}) dx$$\n只有当指数为零时，积分才不为零。这发生在 $G_n-G_{n'}+G_0 = 0$（即 $n-n'+1=0$，所以 $n'=n+1$）或 $G_n-G_{n'}-G_0 = 0$（即 $n-n'-1=0$，所以 $n'=n-1$）时。因此，矩阵元的值为 $\\frac{V_0}{2}$。综合这些，我们得到：\n$$V_{n',n} = \\frac{V_0}{2}(\\delta_{n',n+1} + \\delta_{n',n-1})$$\n因此，完整的哈密顿矩阵是一个实对称三对角矩阵，其矩阵元为：\n$$H_{n',n} = \\frac{1}{2}(k+nG_0)^2 \\delta_{n',n} + \\frac{V_0}{2}(\\delta_{n',n+1} + \\delta_{n',n-1})$$\n\n对于实际计算，必须对无限基矢进行截断。这通过施加一个动能截断 $E_{\\text{cut}}$ 来实现，只包括那些动能低于该截断的平面波 $\\lvert k+G_n\\rangle$：\n$$\\frac{1}{2}(k+nG_0)^2 \\le E_{\\text{cut}}$$\n这个不等式为给定的 $E_{\\text{cut}}$ 确定了一个有限的整数 $n$ 范围，这些整数构成了基组。对于给定的一组参数 $(V_0, a, k)$ 和一个截断值 $E_{\\text{cut}}$，我们执行以下步骤：\n1. 确定满足截断条件的整数集合 $\\{n\\}$。设 $N$ 是这些整数的数量。\n2. 使用上面定义的矩阵元 $H_{n',n}$ 构建 $N \\times N$ 的哈密顿矩阵 $H$，其中索引现在遍历所选的整数集合。\n3. 求解该矩阵的本征值问题。最低的本征值是该基矢下的基态能量 $E_0(k; E_{\\text{cut}})$。\n\n为了量化收敛性，我们为一系列递增的截断值 $E_{\\text{cut}}$ 计算这个能量。误差是相对于一个高度收敛的参考能量 $E_0^{\\text{ref}}(k) = E_0(k; E_{\\text{cut}}^{\\text{ref}})$ 定义的，该参考能量是用一个非常大的截断值 $E_{\\text{cut}}^{\\text{ref}}$ 计算得到的。误差为 $\\varepsilon(E_{\\text{cut}}) = \\lvert E_0(k; E_{\\text{cut}}) - E_0^{\\text{ref}}(k)\\rvert$。收敛速率通过假设一个幂律关系 $\\varepsilon(E_{\\text{cut}}) \\propto E_{\\text{cut}}^{\\,s}$ 来估计。对两边取对数得到 $\\log \\varepsilon = s \\log E_{\\text{cut}} + \\text{const}$。因此，指数 $s$ 可以通过对 $\\log \\varepsilon$ 与 $\\log E_{\\text{cut}}$ 进行线性回归的斜率来找到。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 设置参数 $V_0$、$a$ 和 $k$。倒易晶格矢量为 $G_0 = 2\\pi/a$。\n2. 使用参考截断值 $E_{\\text{cut}}^{\\text{ref}} = 2000$ 计算参考能量 $E_0^{\\text{ref}}$。\n3. 对于所提供列表中的每个 $E_{\\text{cut}}$：\n    a. 从条件 $\\frac{-k-\\sqrt{2E_{\\text{cut}}}}{G_0} \\le n \\le \\frac{-k+\\sqrt{2E_{\\text{cut}}}}{G_0}$ 确定整数范围 $n_{\\text{min}} \\le n \\le n_{\\text{max}}$。\n    b. 为整数集合 $\\{n_{\\text{min}}, \\dots, n_{\\text{max}}\\}$ 构建哈密顿矩阵。\n    c. 找到其最低本征值 $E_0(E_{\\text{cut}})$。\n4. 计算所有截断值对应的误差 $\\varepsilon(E_{\\text{cut}})$。\n5. 对点集 $(\\log E_{\\text{cut}}, \\log \\varepsilon(E_{\\text{cut}}))$ 进行线性拟合以获得斜率 $s$。\n\n然后对问题陈述中指定的所有测试用例重复此过程。将得到的斜率 $s$ 收集起来并格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    It calculates the convergence exponent for the lowest Bloch band energy\n    with respect to the plane-wave kinetic energy cutoff.\n    \"\"\"\n\n    # Test cases as defined in the problem statement:\n    # (V0, a, k, list_of_E_cut)\n    test_cases = [\n        (2.0, 1.0, 0.0, [30.0, 60.0, 120.0, 240.0]),\n        (2.0, 1.0, np.pi / 1.0, [30.0, 60.0, 120.0, 240.0]),\n        (5.0, 1.0, (np.pi / 2.0) / 1.0, [40.0, 80.0, 160.0, 320.0]),\n    ]\n    ref_e_cut = 2000.0\n\n    results = []\n\n    for v0, a, k, e_cuts in test_cases:\n        \n        # Calculate reference energy with a high cutoff\n        ref_energy = _calculate_lowest_eigenvalue(v0, a, k, ref_e_cut)\n\n        energies = []\n        for e_cut in e_cuts:\n            energy = _calculate_lowest_eigenvalue(v0, a, k, e_cut)\n            energies.append(energy)\n        \n        energies = np.array(energies)\n        e_cuts_np = np.array(e_cuts)\n        \n        # Calculate the absolute error\n        errors = np.abs(energies - ref_energy)\n\n        # It's possible for an error to be zero if the basis set is the same\n        # as the reference (unlikely here) or if numerical precision issues arise.\n        # We filter out such points to avoid log(0).\n        valid_indices = errors > 0\n        \n        log_e_cuts = np.log(e_cuts_np[valid_indices])\n        log_errors = np.log(errors[valid_indices])\n\n        # Perform log-log linear regression to find the slope\n        # polyfit(x, y, 1) returns [slope, intercept]\n        if len(log_e_cuts) > 1:\n            slope, _ = np.polyfit(log_e_cuts, log_errors, 1)\n        else:\n            # Not enough points for a fit, this case should not happen\n            # with the given problem data.\n            slope = np.nan\n\n        results.append(slope)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _calculate_lowest_eigenvalue(v0, a, k, e_cut):\n    \"\"\"\n    Calculates the lowest energy eigenvalue for a given set of parameters.\n\n    Args:\n        v0 (float): Potential amplitude.\n        a (float): Lattice constant.\n        k (float): Crystal momentum.\n        e_cut (float): Kinetic energy cutoff.\n\n    Returns:\n        float: The lowest eigenvalue of the Hamiltonian.\n    \"\"\"\n    g0 = 2 * np.pi / a\n\n    # Determine the range of integers n for the basis set\n    # from the condition 1/2 * (k + n*g0)^2 = e_cut\n    sqrt_2_e_cut = np.sqrt(2 * e_cut)\n    n_min_bound = (-k - sqrt_2_e_cut) / g0\n    n_max_bound = (-k + sqrt_2_e_cut) / g0\n\n    n_min = int(np.ceil(n_min_bound))\n    n_max = int(np.floor(n_max_bound))\n\n    n_values = np.arange(n_min, n_max + 1)\n    basis_size = len(n_values)\n\n    if basis_size == 0:\n        return np.inf\n\n    # Create a mapping from integer n to matrix index\n    n_to_idx = {n: i for i, n in enumerate(n_values)}\n\n    # Assemble the Hamiltonian matrix\n    hamiltonian = np.zeros((basis_size, basis_size))\n\n    # Fill kinetic energy (diagonal) and potential (off-diagonal) terms\n    for i, n in enumerate(n_values):\n        # Kinetic energy term\n        hamiltonian[i, i] = 0.5 * (k + n * g0)**2\n        \n        # Potential coupling term to n-1\n        n_prev = n - 1\n        if n_prev in n_to_idx:\n            j = n_to_idx[n_prev]\n            hamiltonian[i, j] = v0 / 2.0\n        \n        # Potential coupling term to n+1\n        n_next = n + 1\n        if n_next in n_to_idx:\n            j = n_to_idx[n_next]\n            hamiltonian[i, j] = v0 / 2.0\n\n    # The Hamiltonian is Hermitian (real and symmetric).\n    # eigh is efficient for such matrices and returns sorted eigenvalues.\n    eigenvalues = eigh(hamiltonian, eigvals_only=True)\n    \n    return eigenvalues[0]\n\nsolve()\n```", "id": "3435162"}, {"introduction": "与平面波方法不同，紧束缚模型从原子轨道的线性组合出发，为理解能带的化学起源提供了直观的图像。本练习要求您为一个面心立方（FCC）晶格构建紧束缚模型，并实现Monkhorst-Pack方法对布里渊区进行k点采样。通过此练习，您将理解如何计算材料的积分性质以及如何利用对称性来提高计算效率。", "problem": "设计并实现一个完整的程序，该程序为面心立方 (FCC) 晶格构建一个 Monkhorst–Pack (MP) 网格，使用最近邻紧束缚模型计算价带能量，并分析这些能量相对于网格密度和对称性约化的收敛性。该分析必须基于 Bloch 定理和紧束缚框架。程序必须是独立完整的，并为指定的测试套件生成结果。\n\n从以下基本依据开始：\n- Bloch 定理：周期势中的一个本征态可以写作 $\\psi_{\\mathbf{k}}(\\mathbf{r}) = \\mathrm{e}^{\\mathrm{i} \\mathbf{k}\\cdot \\mathbf{r}} u_{\\mathbf{k}}(\\mathbf{r})$，其中对于任意正格矢 $\\mathbf{R}$，都有 $u_{\\mathbf{k}}(\\mathbf{r}+\\mathbf{R}) = u_{\\mathbf{k}}(\\mathbf{r})$。\n- 对于每个格点只有一个轨道且只有最近邻跃迁的 Bravais 晶格的紧束缚哈密顿量：$H = \\sum_{\\mathbf{R}} \\varepsilon_{s} c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}} + \\sum_{\\langle \\mathbf{R}, \\mathbf{R}' \\rangle} t \\, c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}'}$，其中 $\\varepsilon_{s}$ 是在位能，$t$ 是最近邻跃迁积分，$\\langle \\cdot, \\cdot \\rangle$ 表示最近邻。\n\n几何结构与倒易晶格：\n- 考虑一个具有常规立方晶格参数 $a$ 和标准 FCC 最近邻几何结构的 FCC 晶格。使用形式为 $(a/2)\\,(0,\\pm 1,\\pm 1)$、$(a/2)\\,(\\pm 1,0,\\pm 1)$ 和 $(a/2)\\,(\\pm 1,\\pm 1,0)$ 的正格矢最近邻位移矢量 $\\mathbf{d}$，总计 12 个矢量。\n- 使用原胞倒易晶格基矢 $\\mathbf{b}_{1} = \\frac{2\\pi}{a}(-1,1,1)$、$\\mathbf{b}_{2} = \\frac{2\\pi}{a}(1,-1,1)$ 和 $\\mathbf{b}_{3} = \\frac{2\\pi}{a}(1,1,-1)$，它们满足 $\\mathbf{a}_{i}\\cdot \\mathbf{b}_{j} = 2\\pi \\delta_{ij}$。\n\nMonkhorst–Pack 采样：\n- 定义一个 Monkhorst–Pack 网格，每个倒易原胞基矢方向上有 $N_{1}=N_{2}=N_{3}=N$ 个点，其分数坐标为 $q_{i}(m_{i}) = \\frac{2 m_{i} - N_{i} - 1}{2 N_{i}}$，其中 $m_{i} \\in \\{1,2,\\ldots,N_{i}\\}$。\n- 晶体动量点为 $\\mathbf{k}(m_{1},m_{2},m_{3}) = q_{1}(m_{1}) \\mathbf{b}_{1} + q_{2}(m_{2}) \\mathbf{b}_{2} + q_{3}(m_{3}) \\mathbf{b}_{3}$。\n\n价带能量模型：\n- 使用 Bloch 定理和针对每个晶格点一个 s 轨道的最近邻紧束缚哈密顿量，推导能带能量 $E(\\mathbf{k})$ 作为 $\\mathbf{k}$、邻近矢量 $\\mathbf{d}$、在位能 $\\varepsilon_{s}$ 和跃迁积分 $t$ 的函数。不要假定任何特定的简化公式；直接从 12 个最近邻贡献的相位因子 $\\mathrm{e}^{\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{d}}$ 进行推导。在晶体动量 $\\mathbf{k}$ 处的价带能量是在电子伏特单位下的单能带紧束缚能量 $E(\\mathbf{k})$。\n\n对称性约化：\n- 实现时间反演对称性约化（对于非磁性、实数紧束缚哈密顿量的一种特殊对称性）：$E(\\mathbf{k}) = E(-\\mathbf{k})$。使用此性质通过将 $\\mathbf{k}$ 和 $-\\mathbf{k}$ 配对成一个重复度为 2 的单一代表点来约化 MP 网格，除非当 $\\mathbf{k} = -\\mathbf{k}$（例如 Γ 点）时，其重复度为 1。\n\n收敛性分析任务：\n- 对于每个网格密度 $N$，计算以下量：\n  1. $E_{\\min}^{\\text{full}}(N)$: 在整个 MP 网格中所有 $\\mathbf{k}$ 点上的最小价带能量。\n  2. $\\overline{E}^{\\text{full}}(N)$: 在整个 MP 网格上 $E(\\mathbf{k})$ 的简单平均值，按 $\\mathbf{k}$ 点总数归一化。\n  3. $E_{\\min}^{\\text{red}}(N)$: 在时间反演约化的代表点集上的最小价带能量。\n  4. $\\overline{E}^{\\text{red}}(N)$: 在约化集上 $E(\\mathbf{k})$ 的加权平均值，权重等于重复度除以完整网格中的 $\\mathbf{k}$ 点总数。\n  5. $\\Delta \\overline{E}(N) = \\left| \\overline{E}^{\\text{full}}(N) - \\overline{E}^{\\text{red}}(N) \\right|$。\n  6. $r(N)$: 约化比，定义为约化代表点数除以完整网格中的总点数。\n\n物理单位：\n- 所有能量以电子伏特 (eV) 表示。晶格常数 $a$ 必须以埃 (Å) 为单位处理，晶体动量分量以埃的倒数 (Å⁻¹) 为单位，以便 $\\mathbf{k}\\cdot\\mathbf{d}$ 在三角函数内部是无量纲的。\n\n测试套件：\n- 使用以下物理上合理的参数作为测试套件。对于每种情况，程序必须按规定的顺序生成上述六个输出。\n  - 情况 1 (边界): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 1$。\n  - 情况 2 (偶数网格): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 2$。\n  - 情况 3 (中等网格): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 5$。\n  - 情况 4 (更密网格): $a = 3.600$ Å, $\\varepsilon_{s} = -5.000$ eV, $t = -1.000$ eV, $N = 10$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身是一个包含六个浮点数的列表，顺序为 $[E_{\\min}^{\\text{full}}, \\overline{E}^{\\text{full}}, E_{\\min}^{\\text{red}}, \\overline{E}^{\\text{red}}, \\Delta \\overline{E}, r]$。例如，输出必须如下所示：\n- \"[[case1_values],[case2_values],[case3_values],[case4_values]]\"\n不应打印任何其他文本。", "solution": "该问题要求设计并实现一个程序，用以分析面心立方 (FCC) 晶格中紧束缚价带能量相对于 Monkhorst–Pack (MP) k 点网格密度的收敛性。这涉及推导能量色散关系、生成 k 点网格、计算能量，并应用时间反演对称性来降低计算成本。分析将针对一个特定的测试套件进行。\n\n### 步骤 1：紧束缚能量色散的推导\n\n该系统由一个在 Bravais 晶格上的单轨道、最近邻紧束缚哈密顿量描述：\n$$ H = \\sum_{\\mathbf{R}} \\varepsilon_{s} c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}} + \\sum_{\\langle \\mathbf{R}, \\mathbf{R}' \\rangle} t \\, c_{\\mathbf{R}}^{\\dagger} c_{\\mathbf{R}'} $$\n其中 $\\varepsilon_{s}$ 是 s 轨道的在位能，$t$ 是位于位置 $\\mathbf{R}$ 和 $\\mathbf{R}'$ 的最近邻格点之间的跃迁积分，$c_{\\mathbf{R}}^{\\dagger}$ ($c_{\\mathbf{R}}$) 是在格点 $\\mathbf{R}$ 处电子的产生（湮灭）算符。\n\n根据 Bloch 定理，周期势中的本征态可以写成 Bloch 波。对于每个原胞一个轨道的情况，试探波函数是原子轨道 $\\phi(\\mathbf{r} - \\mathbf{R})$ 的 Bloch 和：\n$$ |\\psi_{\\mathbf{k}}\\rangle = \\frac{1}{\\sqrt{N_{\\text{sites}}}} \\sum_{\\mathbf{R}} e^{i\\mathbf{k}\\cdot\\mathbf{R}} |\\mathbf{R}\\rangle $$\n其中 $|\\mathbf{R}\\rangle$ 表示位于晶格点 $\\mathbf{R}$ 的原子轨道，$\\mathbf{k}$ 是第一布里渊区中的一个晶体动量矢量。\n\n能量色散 $E(\\mathbf{k})$ 是该状态下哈密顿量的期望值：\n$$ E(\\mathbf{k}) = \\langle\\psi_{\\mathbf{k}}|H|\\psi_{\\mathbf{k}}\\rangle = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}, \\mathbf{R}'} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} \\langle\\mathbf{R}|H|\\mathbf{R}'\\rangle e^{i\\mathbf{k}\\cdot\\mathbf{R}'} $$\n哈密顿量矩阵元为：如果 $\\mathbf{R}=\\mathbf{R}'$，则 $\\langle\\mathbf{R}|H|\\mathbf{R}'\\rangle = \\varepsilon_{s}$；如果 $\\mathbf{R}$ 和 $\\mathbf{R}'$ 是最近邻，则为 $t$；其他情况为 $0$。\n将这些代入能量表达式，可将求和分为在位贡献和跃迁贡献。\n\n在位项：\n$$ E_{\\text{on-site}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} (\\varepsilon_{s}) e^{i\\mathbf{k}\\cdot\\mathbf{R}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\varepsilon_{s} = \\varepsilon_{s} $$\n\n跃迁项涉及对最近邻对的求和。令 $\\mathbf{R}' = \\mathbf{R} + \\mathbf{d}$，其中 $\\mathbf{d}$ 是一个最近邻位移矢量。\n$$ E_{\\text{hopping}} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\sum_{\\mathbf{d}} e^{-i\\mathbf{k}\\cdot\\mathbf{R}} (t) e^{i\\mathbf{k}\\cdot(\\mathbf{R}+\\mathbf{d})} = \\frac{1}{N_{\\text{sites}}} \\sum_{\\mathbf{R}} \\sum_{\\mathbf{d}} t \\, e^{i\\mathbf{k}\\cdot\\mathbf{d}} = t \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} $$\n求和遍及所有最近邻矢量 $\\mathbf{d}$。结合各项，我们得到能量色散关系：\n$$ E(\\mathbf{k}) = \\varepsilon_{s} + t \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} $$\n对于具有常规晶格参数 $a$ 的 FCC 晶格，存在 12 个形式为 $(a/2)(\\pm 1, \\pm 1, 0)$ 及其排列组合的最近邻矢量。该矢量集在反演操作下是对称的，即如果 $\\mathbf{d}$ 是一个最近邻矢量，那么 $-\\mathbf{d}$ 也是。这使我们可以将指数和写成余弦和：\n$$ \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} = \\sum_{\\mathbf{d}} \\cos(\\mathbf{k}\\cdot\\mathbf{d}) + i \\sum_{\\mathbf{d}} \\sin(\\mathbf{k}\\cdot\\mathbf{d}) = \\sum_{\\mathbf{d}} \\cos(\\mathbf{k}\\cdot\\mathbf{d}) $$\n虚部消失，因为对于每个 $\\mathbf{d}$，项 $\\sin(\\mathbf{k}\\cdot\\mathbf{d})$ 被 $\\sin(\\mathbf{k}\\cdot(-\\mathbf{d})) = -\\sin(\\mathbf{k}\\cdot\\mathbf{d})$ 所抵消。令 $\\mathbf{k}=(k_x, k_y, k_z)$。求和结果为：\n$$ \\sum_{\\mathbf{d}} e^{i\\mathbf{k}\\cdot\\mathbf{d}} = 4 \\left( \\cos\\left(\\frac{k_x a}{2}\\right)\\cos\\left(\\frac{k_y a}{2}\\right) + \\cos\\left(\\frac{k_y a}{2}\\right)\\cos\\left(\\frac{k_z a}{2}\\right) + \\cos\\left(\\frac{k_z a}{2}\\right)\\cos\\left(\\frac{k_x a}{2}\\right) \\right) $$\n因此，能带能量的最终表达式为：\n$$ E(\\mathbf{k}) = \\varepsilon_{s} + 4t \\left( \\cos\\left(\\frac{k_x a}{2}\\right)\\cos\\left(\\frac{k_y a}{2}\\right) + \\cos\\left(\\frac{k_y a}{2}\\right)\\cos\\left(\\frac{k_z a}{2}\\right) + \\cos\\left(\\frac{k_z a}{2}\\right)\\cos\\left(\\frac{k_x a}{2}\\right) \\right) $$\n\n### 步骤 2：Monkhorst–Pack 网格生成\n\n晶体动量矢量 $\\mathbf{k}$ 在第一布里渊区内的规则网格上采样。Monkhorst-Pack 方案提供了一种生成此网格的系统方法。指定的 MP 网格由每个倒易原胞晶格方向上的 $N_1 = N_2 = N_3 = N$ 个点定义。k 点由下式给出：\n$$ \\mathbf{k}(m_{1},m_{2},m_{3}) = q_{1}(m_{1}) \\mathbf{b}_{1} + q_{2}(m_{2}) \\mathbf{b}_{2} + q_{3}(m_{3}) \\mathbf{b}_{3} $$\n其中 $m_i \\in \\{1, 2, \\ldots, N\\}$。分数坐标 $q_i$ 定义为：\n$$ q_{i}(m_{i}) = \\frac{2 m_{i} - N - 1}{2 N} $$\n当 $N$ 为奇数时，这种选择将网格中心置于 Γ 点 $(\\mathbf{k}=\\mathbf{0})$，因为当 $m_i = (N+1)/2$ 时，$q_i=0$。当 $N$ 为偶数时，网格是偏移的，不包含 Γ 点。\nFCC 原胞倒易晶格基矢在笛卡尔坐标中给出：\n$$ \\mathbf{b}_{1} = \\frac{2\\pi}{a}(-1,1,1), \\quad \\mathbf{b}_{2} = \\frac{2\\pi}{a}(1,-1,1), \\quad \\mathbf{b}_{3} = \\frac{2\\pi}{a}(1,1,-1) $$\nk 点的笛卡尔分量 $(k_x, k_y, k_z)$ 通过线性组合找到：\n$$ k_x = \\frac{2\\pi}{a}(-q_1 + q_2 + q_3) $$\n$$ k_y = \\frac{2\\pi}{a}(q_1 - q_2 + q_3) $$\n$$ k_z = \\frac{2\\pi}{a}(q_1 + q_2 - q_3) $$\n完整网格中的 k 点总数为 $N^3$。\n\n### 步骤 3：对称性约化\n\n对于在实空间中为实数且没有磁场存在的哈密顿量，时间反演对称性规定 $E(\\mathbf{k}) = E(-\\mathbf{k})$。MP 网格的构造是对称的，因此如果 $\\mathbf{k}$ 是网格上的一个点，那么 $-\\mathbf{k}$ 也在网格上。可以利用这种冗余性来减少必须显式计算能量的 k 点数量。\n通过从每对 $(\\mathbf{k}, -\\mathbf{k})$（其中 $\\mathbf{k} \\neq -\\mathbf{k}$）中选择一个代表点来约化网格。这样的代表点被赋予重复度（或权重）$w=2$。是其自身逆的点，$\\mathbf{k} = -\\mathbf{k}$（相差一个倒格矢），被称为时间反演不变动量点 (TRIMs)。在指定的 MP 方案中，唯一的 TRIM 是 Γ 点 $(\\mathbf{k}=\\mathbf{0})$，它在 $N$ 为奇数时出现。一个 TRIM 的重复度为 $w=1$。\n约化可以通过遍历网格索引 $(m_1, m_2, m_3)$ 来实现。对于每个索引元组，其逆是 $(N+1-m_1, N+1-m_2, N+1-m_3)$。我们通过从每对索引元组中只包含一个代表点来构建一个约化集，并跟踪那些已经被包含的点。\n\n### 步骤 4：计算分析\n\n对于由 $(a, \\varepsilon_s, t, N)$ 定义的每个测试用例，计算以下量：\n\n1.  **完整网格计算**：\n    -   生成所有 $N^3$ 个 k 点。\n    -   为每个点计算 $E(\\mathbf{k})$。\n    -   $E_{\\min}^{\\text{full}}(N)$: 在整个网格中找到的最小能量。\n    -   $\\overline{E}^{\\text{full}}(N)$: 所有计算能量的简单平均值，$\\frac{1}{N^3}\\sum_i E_i$。\n\n2.  **约化网格计算**：\n    -   生成代表性 k 点集及其对应的重复度 $\\{w_j\\}$。\n    -   $E_{\\min}^{\\text{red}}(N)$: 在约化集中的最小能量。由于能量值集合与完整网格相同，因此 $E_{\\min}^{\\text{red}}(N) = E_{\\min}^{\\text{full}}(N)$。\n    -   $\\overline{E}^{\\text{red}}(N)$: 约化集上的加权平均值。问题将其定义为 $\\sum_{j \\in \\text{red}} E(\\mathbf{k}_j) \\left(\\frac{w_j}{N^3}\\right)$。根据构造，这个和在数学上等同于完整网格上的简单平均值：\n    $$ \\overline{E}^{\\text{red}}(N) = \\frac{1}{N^3} \\sum_{j \\in \\text{red}} w_j E(\\mathbf{k}_j) = \\frac{1}{N^3} \\sum_{i \\in \\text{full}} E(\\mathbf{k}_i) = \\overline{E}^{\\text{full}}(N) $$\n\n3.  **最终指标**：\n    -   $\\Delta \\overline{E}(N) = \\left| \\overline{E}^{\\text{full}}(N) - \\overline{E}^{\\text{red}}(N) \\right|$。在浮点精度范围内，这个值应该为零，可作为对称性约化实现的验证。\n    -   $r(N)$: 约化比，定义为约化集中的点数除以完整网格中的总点数 ($N^3$)。对于偶数 $N$，$r(N) = 0.5$。对于奇数 $N$，$r(N) = ( (N^3-1)/2 + 1 ) / N^3 = 0.5 + 1/(2N^3)$。\n\n实现过程首先定义几何和物理参数。然后，对于每个测试用例，它遍历 k 点索引，计算笛卡尔 k 矢量，并计算它们的能量。这些能量被聚合以找到完整网格的统计数据。同时或随后，应用对称性约化逻辑以生成约化集并计算其统计数据。最后，收集所需的六个量并格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates the calculation for each case and formats the final output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3.600, -5.000, -1.000, 1),\n        (3.600, -5.000, -1.000, 2),\n        (3.600, -5.000, -1.000, 5),\n        (3.600, -5.000, -1.000, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, eps_s, t, N = case\n        case_results = analyze_fcc_tight_binding_grid(a, eps_s, t, N)\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python list is used for each sub-list.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef analyze_fcc_tight_binding_grid(a, eps_s, t, N):\n    \"\"\"\n    Performs the full analysis for a single FCC tight-binding case.\n\n    Args:\n        a (float): Lattice constant in Angstroms.\n        eps_s (float): On-site energy in eV.\n        t (float): Nearest-neighbor hopping integral in eV.\n        N (int): Monkhorst-Pack grid division number.\n\n    Returns:\n        list: A list of 6 float values corresponding to the analysis tasks.\n    \"\"\"\n    \n    # 1. Define geometry and reciprocal basis vectors\n    b1 = (2 * np.pi / a) * np.array([-1, 1, 1])\n    b2 = (2 * np.pi / a) * np.array([1, -1, 1])\n    b3 = (2 * np.pi / a) * np.array([1, 1, -1])\n\n    # 2. Generate full Monkhorst-Pack grid and compute energies\n    m_indices_1d = np.arange(1, N + 1)\n    \n    full_energies = np.zeros(N**3)\n    \n    # Iterate through all points in the grid using their 1D indices\n    # m1 changes slowest, m3 changes fastest\n    idx = 0\n    for m1 in m_indices_1d:\n        for m2 in m_indices_1d:\n            for m3 in m_indices_1d:\n                q1 = (2 * m1 - N - 1) / (2 * N)\n                q2 = (2 * m2 - N - 1) / (2 * N)\n                q3 = (2 * m3 - N - 1) / (2 * N)\n                \n                k_vec = q1 * b1 + q2 * b2 + q3 * b3\n                kx, ky, kz = k_vec\n                \n                # Energy calculation based on the derived formula\n                cos_term = (np.cos(kx * a / 2) * np.cos(ky * a / 2) +\n                            np.cos(ky * a / 2) * np.cos(kz * a / 2) +\n                            np.cos(kz * a / 2) * np.cos(kx * a / 2))\n                \n                energy = eps_s + 4 * t * cos_term\n                full_energies[idx] = energy\n                idx += 1\n\n    # 3. Calculate full grid quantities\n    E_min_full = np.min(full_energies)\n    E_avg_full = np.mean(full_energies)\n\n    # 4. Perform symmetry reduction and related calculations\n    reduced_indices_tuples = []\n    multiplicities = []\n    seen_indices_tuples = set()\n\n    for m1 in m_indices_1d:\n        for m2 in m_indices_1d:\n            for m3 in m_indices_1d:\n                current_m_idx = (m1, m2, m3)\n                if current_m_idx in seen_indices_tuples:\n                    continue\n\n                inv_m_idx = (N + 1 - m1, N + 1 - m2, N + 1 - m3)\n                \n                reduced_indices_tuples.append(current_m_idx)\n                \n                if current_m_idx == inv_m_idx:\n                    multiplicities.append(1)\n                    seen_indices_tuples.add(current_m_idx)\n                else:\n                    multiplicities.append(2)\n                    seen_indices_tuples.add(current_m_idx)\n                    seen_indices_tuples.add(inv_m_idx)\n\n    # 5. Calculate reduced grid quantities\n    reduced_energies = []\n    for m_idx_tuple in reduced_indices_tuples:\n        m1, m2, m3 = m_idx_tuple\n        # Map 3D index (m1, m2, m3) to 1D index of the energy array\n        linear_idx = int((m1 - 1) * N * N + (m2 - 1) * N + (m3 - 1))\n        reduced_energies.append(full_energies[linear_idx])\n    \n    reduced_energies = np.array(reduced_energies)\n    E_min_red = np.min(reduced_energies)\n\n    # Weighted average over the reduced set\n    total_points = N**3\n    weights = np.array(multiplicities)\n    E_avg_red = np.sum(reduced_energies * weights) / total_points\n    \n    # 6. Final analysis quantities\n    delta_E_avg = np.abs(E_avg_full - E_avg_red)\n    reduction_ratio = len(reduced_indices_tuples) / total_points\n    \n    return [\n        round(E_min_full, 12),\n        round(E_avg_full, 12),\n        round(E_min_red, 12),\n        round(E_avg_red, 12),\n        round(delta_E_avg, 12),\n        round(reduction_ratio, 12)\n    ]\n\n# Execute the main function when the script is run.\nsolve()\n```", "id": "3435201"}, {"introduction": "超越简单的点群对称性，晶体中存在的非点式对称性（如滑移面和螺旋轴）能够导致能带结构中奇特且受保护的简并。本练习将带您探索一个包含滑移对称性的二维晶格模型，并从理论和数值上验证在布里渊区边界处出现的强制能带粘连现象。这个实践将揭示抽象的对称性原理如何深刻地影响材料的电子性质。", "problem": "考虑一个二维晶格，其原胞矢量为 $\\mathbf{a} = (a,0)$ 和 $\\mathbf{b} = (0,b)$，每个单位晶胞有两个无自旋轨道，分别位于 $\\mathbf{r}_A = (0,0)$ 和 $\\mathbf{r}_B = (a/2,0)$。设 $a=b=1$，并将所有能量视为无量纲。假设紧束缚跃迁过程是平移不变且实值的，确保了无自旋粒子（时间反演对称性平方为 $+1$）的时间反演对称性。该晶体具有一个非点式滑移对称性 $G$，其操作为先对 $y$ 进行反射 $y \\mapsto -y$，再沿着 $x$ 方向进行半平移 $(a/2,0)$。在具有偶镜像宇称轨道的布洛赫基 $\\{ \\lvert A\\rangle, \\lvert B\\rangle \\}$ 中，$G$ 的对称性操作由幺正矩阵 $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$ 表示，其中 $\\sigma_x$ 是作用在子格空间中的泡利矩阵，$\\mathbf{k}=(k_x,k_y)$ 是晶体动量。\n\n仅从布洛赫定理和上述定义的对称性操作出发，在子格基下构造一个满足以下条件的最小 $2\\times 2$ 布洛赫哈密顿量 $H(\\mathbf{k})$：\n- 尊重平移不变性和时间反演对称性（实数跃迁振幅）。\n- 在 $U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$ 的意义下尊重滑移对称性。\n- 由以下具有物理动机的实空间跃迁过程生成：\n  1. 沿 $\\pm \\mathbf{a}$ 方向、振幅为 $t_x$ 的相同子格内最近邻跃迁，以及沿 $\\pm \\mathbf{b}$ 方向、振幅为 $t_y$ 的相同子格内最近邻跃迁（对于 $A$ 和 $B$ 是相同的，因为它们通过滑移对称性相关联）。\n  2. 沿位移 $(\\pm a/2, 0)$、振幅为 $t_1$ 的 $A$ 和 $B$ 之间的子格间跃迁；以及对称地沿 $(\\pm a/2, \\pm b)$、振幅为 $t_2$ 和 $(\\pm a/2, \\pm 2b)$、振幅为 $t_3$ 的子格间跃迁。这些组合以镜像对称的形式包含，以使得最终的子格间矩阵元是 $k_y$ 的偶函数并且是实数。\n  3. 一个由 $t_{\\mathrm{odd}}$ 参数化的、允许的、滑移对称的、子格奇的纵向贡献，该项是 $k_y$ 的奇函数并乘以 $\\sigma_z$。你可以直接在布洛赫哈密顿量的层面上，通过一个 $\\sin(k_y b)$ 因子来实现此项；这在对称性上是允许的，并对应于 $A$ 和 $B$ 色散之间的差异，该差异在 $k_y \\mapsto -k_y$ 变换下会改变符号。\n  4. 为了测试简并的脆弱性，引入一个与 $\\sigma_z$ 成正比的、显式破坏滑移对称性的子格不平衡项 $\\Delta_{\\mathrm{break}}$，该项是 $k_y$ 的偶函数（一个常数）。这违反了滑移约束，并且仅在下面的测试套件中用作边缘情况。\n\n你的模型应写成厄米矩阵的形式 $H(\\mathbf{k}) = d_0(\\mathbf{k})\\, \\sigma_0 + d_x(\\mathbf{k})\\, \\sigma_x + d_y(\\mathbf{k})\\, \\sigma_y + d_z(\\mathbf{k})\\, \\sigma_z$，其中 $\\sigma_0$ 是单位矩阵，$\\sigma_{x,y,z}$ 是在 $\\{A,B\\}$ 基下的泡利矩阵。推导在 $k_y \\mapsto -k_y$ 变换下，由滑移关系施加在 $d_\\mu(\\mathbf{k})$ 上的宇称约束，然后利用布洛赫定理，获得由指定的实空间跃迁引起的 $k$ 依赖关系。你不能在没有推导的情况下假设任何最终表达式。\n\n使用构造的 $H(\\mathbf{k})$，证明：\n- 滑移表示满足 $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$。特别地，在布里渊区边界 $k_x=\\pi/a$，有 $U_G^2 = - \\sigma_0$，并且滑移本征值为 $\\pm i$。\n- 沿着滑移不变线 $k_y=0$ 和 $k_y=\\pi/b$，时间反演对称性确保了在时间反演不变动量点 $X=(\\pi/a,0)$ 和 $M=(\\pi/a,\\pi/b)$，当滑移对称性保持时，能带必须粘连成简并对，这与通过复共轭滑移本征值 $\\pm i$ 配对的不可约表示一致。\n\n你的程序必须：\n1. 实现对 $a=b=1$ 时推导出的 $H(\\mathbf{k})$ 和 $U_G(\\mathbf{k})$。\n2. 对于下面测试套件中列出的每个参数集，数值计算哈密顿量 $H(\\mathbf{k})$ 在三个动量点 $X=(\\pi,0)$、$M=(\\pi,\\pi)$ 和非时间反演不变的边界点 $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$ 的两个本征值。如果两个本征值之间的绝对差值小于容差 $\\tau = 10^{-8}$，则声明简并为“true”，否则为“false”。\n3. 对于每个参数集，计算在 $X=(\\pi,0)$ 处对易子 $[H(\\mathbf{k}), U_G(\\mathbf{k})]$ 的弗罗贝尼乌斯范数，结果为一个非负实数。当滑移对称性保持时，该范数必须精确为零；当被 $\\Delta_{\\mathrm{break}}$ 破坏时，通常为非零。\n4. 对每个参数集，汇总一个包含四个结果的列表：三个布尔值，分别表示在 $X$、$M$、$B_{\\mathrm{mid}}$ 处的简并情况，随后是等于在 $X$ 处对易子范数的浮点数。\n\n测试套件 (使用 $a=b=1$):\n- 情况 1 (存在子格奇纵向项的通用滑移对称情况): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0$。\n- 情况 2 (无子格奇项的滑移对称情况，导致完全的边界粘连): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0$, $\\Delta_{\\mathrm{break}}=0$。\n- 情况 3 (显式破坏滑移对称性的边缘情况): $\\epsilon = 0$, $t_x=-0.8$, $t_y=-0.6$, $t_1=1.0$, $t_2=0.35$, $t_3=-0.2$, $t_{\\mathrm{odd}}=0.5$, $\\Delta_{\\mathrm{break}}=0.1$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、由逗号分隔的三个情况的结果列表。每个情况的结果本身也是一个列表，顺序为 $[\\mathrm{degX}, \\mathrm{degM}, \\mathrm{degBmid}, \\mathrm{comm\\_X}]$。例如：$[[\\mathrm{true},\\mathrm{true},\\mathrm{false},0.0],[\\dots],[\\dots]]$。布尔值必须以 Python 的标准小写形式打印，浮点数必须以标准十进制数形式打印。无需报告物理单位，因为根据设定，$a=b=1$ 且能量是无量纲的。", "solution": "该问题要求构造和分析一个具有非点式滑移对称性的二维晶格的 $2 \\times 2$ 紧束缚布洛赫哈密顿量 $H(\\mathbf{k})$。分析将分几步进行：验证问题的有效性，从对称性和跃迁项推导哈密顿量，分析由对称性强制要求的能带简并，最后通过数值实现来验证这些物理结果。\n\n### 问题验证\n首先对问题进行严格的验证。\n\n**第 1 步：提取的已知条件**\n- **晶格和基矢**：二维晶格，原胞矢量为 $\\mathbf{a} = (a,0)$ 和 $\\mathbf{b} = (0,b)$。每个晶胞有两个无自旋轨道，分别位于 $\\mathbf{r}_A = (0,0)$ 和 $\\mathbf{r}_B = (a/2,0)$。\n- **常数**：$a=1$, $b=1$。能量是无量纲的。\n- **对称性**：平移不变性，时间反演对称性（TRS，具有实数跃迁），以及一个非点式滑移对称性 $G$。\n- **滑移对称性表示**：$G$ 为 $y \\mapsto -y$ 反射加上 $(a/2,0)$ 平移。其矩阵表示为 $U_G(\\mathbf{k}) = e^{- i k_x a/2}\\, \\sigma_x$。\n- **对称性约束**：$U_G(\\mathbf{k})\\, H(k_x,k_y)\\, U_G^\\dagger(\\mathbf{k}) = H(k_x,-k_y)$。\n- **用于构造的跃迁项**：\n    1.  相同子格内（子格内）最近邻跃迁：沿 $\\pm\\mathbf{a}$ 方向振幅为 $t_x$，沿 $\\pm\\mathbf{b}$ 方向振幅为 $t_y$。\n    2.  子格间跃迁：位移为 $(\\pm a/2, 0)$ 时振幅为 $t_1$；位移为 $(\\pm a/2, \\pm b)$ 时振幅为 $t_2$；位移为 $(\\pm a/2, \\pm 2b)$ 时振幅为 $t_3$。\n    3.  子格奇项：$t_{\\mathrm{odd}}\\sin(k_y b)\\sigma_z$。\n    4.  对称性破缺项：$\\Delta_{\\mathrm{break}}\\sigma_z$。\n- **要求的推导**：\n    1.  证明 $U_G^2(\\mathbf{k}) = e^{- i k_x a}\\, \\sigma_0$ 且在 $k_x=\\pi/a$ 时本征值为 $\\pm i$。\n    2.  解释在 $X=(\\pi/a,0)$ 和 $M=(\\pi/a,\\pi/b)$ 处的能带粘连。\n- **数值任务**：对于三个指定的参数集，计算 $H(\\mathbf{k})$ 在 $X$、$M$ 和 $B_{\\mathrm{mid}}=(\\pi,\\pi/2)$ 的本征值，检查是否存在简并（容差 $\\tau = 10^{-8}$），并计算 $[H(X), U_G(X)]$ 的弗罗贝尼乌斯范数。\n\n**第 2 和第 3 步：结论与行动**\n该问题是**有效的**。这是一个来自理论凝聚态物理领域的、提法恰当且具有科学依据的问题。它自成体系，提供了所有必要的参数和定义。任务涉及该领域中标准的、尽管并非微不足道的推导和数值验证。其中没有矛盾、模糊之处或事实错误。因此可以开始求解过程。\n\n### 理论推导\n在推导中，我们将设 $a=1$ 和 $b=1$。\n\n**1. $H(\\mathbf{k})$ 上的滑移对称性约束**\n哈密顿量在泡利矩阵基下表示为：$H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_y(\\mathbf{k})\\sigma_y + d_z(\\mathbf{k})\\sigma_z$。滑移对称性约束为 $U_G(\\mathbf{k})H(\\mathbf{k})U_G^\\dagger(\\mathbf{k}) = H(k_x, -k_y)$。\n代入 $U_G(\\mathbf{k}) = e^{-i k_x/2}\\sigma_x$ 和 $U_G^\\dagger(\\mathbf{k}) = \\sigma_x e^{i k_x/2}$：\n$$ e^{-i k_x/2}\\sigma_x \\left( \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, k_y) \\sigma_\\mu \\right) \\sigma_x e^{i k_x/2} = \\sum_{\\mu=0,x,y,z} d_\\mu(k_x, -k_y) \\sigma_\\mu $$\n$$ \\sigma_x H(k_x, k_y) \\sigma_x = H(k_x, -k_y) $$\n使用泡利代数恒等式 $\\sigma_x \\sigma_0 \\sigma_x = \\sigma_0$、$\\sigma_x \\sigma_x \\sigma_x = \\sigma_x$、$\\sigma_x \\sigma_y \\sigma_x = -\\sigma_y$ 和 $\\sigma_x \\sigma_z \\sigma_x = -\\sigma_z$，我们得到：\n$$ d_0(k_x,k_y)\\sigma_0 + d_x(k_x,k_y)\\sigma_x - d_y(k_x,k_y)\\sigma_y - d_z(k_x,k_y)\\sigma_z = d_0(k_x,-k_y)\\sigma_0 + d_x(k_x,-k_y)\\sigma_x + d_y(k_x,-k_y)\\sigma_y + d_z(k_x,-k_y)\\sigma_z $$\n比较泡利矩阵的系数，得到在 $k_y \\mapsto -k_y$ 变换下的宇称约束：\n- $d_0$ 必须是 $k_y$ 的偶函数。\n- $d_x$ 必须是 $k_y$ 的偶函数。\n- $d_y$ 必须是 $k_y$ 的奇函数。\n- $d_z$ 必须是 $k_y$ 的奇函数。\n\n**2. 布洛赫哈密顿量的构造**\n布洛赫哈密顿量的矩阵元是实空间跃迁积分 $t(\\vec{\\delta})$ 对所有位移矢量 $\\vec{\\delta}$ 的晶格傅里叶变换。对于一个双分量基 $\\{A, B\\}$，哈密顿量是一个 $2\\times 2$ 矩阵 $H(\\mathbf{k}) = \\begin{pmatrix} H_{AA}(\\mathbf{k})  H_{AB}(\\mathbf{k}) \\\\ H_{BA}(\\mathbf{k})  H_{BB}(\\mathbf{k}) \\end{pmatrix}$。对于实数跃迁振幅，厄米性意味着 $H_{BA}(\\mathbf{k}) = H_{AB}^*(\\mathbf{k})$。其分解为 $H_{AA} = d_0+d_z$，$H_{BB} = d_0-d_z$，以及 $H_{AB} = d_x-id_y$。\n\n- **子格内项 ($H_{AA}$, $H_{BB}$)**：连接相同类型格点的跃迁。问题陈述这些项对于 $A$ 和 $B$ 是相同的，这意味着这些项只对 $d_0$ 有贡献。\n  位移矢量为 $\\pm\\mathbf{a}=(\\pm 1, 0)$ 和 $\\pm\\mathbf{b}=(0, \\pm 1)$。\n  $$ H_{AA}(\\mathbf{k}) = H_{BB}(\\mathbf{k}) = t_x(e^{i k_x} + e^{-i k_x}) + t_y(e^{i k_y} + e^{-i k_y}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y) $$\n  这部分贡献给 $d_0$。测试套件中的参数 $\\epsilon$，如果解释为整体能量偏移，会加到 $d_0$ 上。由于 $\\epsilon=0$，我们忽略它。因此，$d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$。这是 $k_y$ 的偶函数，符合要求。\n\n- **子格间项 ($H_{AB}$)**：连接 $A$ 和 $B$ 格点的跃迁。$H_{AB}(\\mathbf{k}) = \\sum_{\\vec{\\delta}_{AB}} t(\\vec{\\delta}_{AB}) e^{i\\mathbf{k}\\cdot\\vec{\\delta}_{AB}}$。\n  1.  振幅为 $t_1$、位移为 $(\\pm 1/2, 0)$ 的跃迁：$t_1(e^{i k_x/2} + e^{-i k_x/2}) = 2t_1\\cos(k_x/2)$。\n  2.  振幅为 $t_2$、位移为 $(\\pm 1/2, \\pm 1)$ 的跃迁：$t_2 \\sum_{\\sigma_x, \\sigma_y = \\pm 1} e^{i(\\sigma_x k_x/2 + \\sigma_y k_y)} = 4t_2\\cos(k_x/2)\\cos(k_y)$。\n  3.  振幅为 $t_3$、位移为 $(\\pm 1/2, \\pm 2)$ 的跃迁：$4t_3\\cos(k_x/2)\\cos(2k_y)$。\n  将这些项合并，得到：\n  $$ H_{AB}(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right) $$\n  由于所有跃迁振幅都是实数，$H_{AB}(\\mathbf{k})$ 是实数。厄米性要求 $H_{BA}(\\mathbf{k}) = H_{AB}(\\mathbf{k})$。这意味着 $d_x = H_{AB}$ 且 $d_y = 0$。$d_x$（$k_y$ 的偶函数）和 $d_y$（平凡地是 $k_y$ 的奇函数）都满足对称性约束。\n\n- **子格奇项和对称性破缺项**：这些项对 $d_z$ 有贡献。\n  问题指定了一个项 $t_{\\mathrm{odd}}\\sin(k_y)\\sigma_z$ 和一个破缺项 $\\Delta_{\\mathrm{break}}\\sigma_z$。\n  所以，$d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$。\n  在滑移对称的情况下（$\\Delta_{\\mathrm{break}}=0$），$d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y)$ 是 $k_y$ 的奇函数，满足约束。常数项 $\\Delta_{\\mathrm{break}}$ 是偶函数，并显式地破坏了滑移对称性。\n\n- **最终哈密顿量**：\n  $H(\\mathbf{k}) = d_0(\\mathbf{k})\\sigma_0 + d_x(\\mathbf{k})\\sigma_x + d_z(\\mathbf{k})\\sigma_z$，其中\n  $d_0(\\mathbf{k}) = 2t_x\\cos(k_x) + 2t_y\\cos(k_y)$\n  $d_x(\\mathbf{k}) = 2\\cos(k_x/2) \\left( t_1 + 2t_2\\cos(k_y) + 2t_3\\cos(2k_y) \\right)$\n  $d_z(\\mathbf{k}) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$\n\n**3. 对称性保护的简并**\n- **滑移算符性质**：$U_G(\\mathbf{k}) = e^{-ik_x/2}\\sigma_x$。对该算符平方得到：\n  $$ U_G^2(\\mathbf{k}) = (e^{-ik_x/2}\\sigma_x)^2 = e^{-ik_x}\\sigma_x^2 = e^{-ik_x}\\sigma_0 $$\n  在布里渊区边界 $k_x=\\pi$ 处，这变为 $U_G^2(\\pi,k_y) = e^{-i\\pi}\\sigma_0 = -\\sigma_0$。$U_G(\\pi,k_y)$ 的本征值 $\\lambda_G$ 必须满足 $\\lambda_G^2 = -1$，这意味着 $\\lambda_G = \\pm i$。\n\n- **在 $X$ 和 $M$ 点的能带粘连**：哈密顿量的本征值为 $E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_y(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。当 $d_y=0$ 时，$E_{\\pm}(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm \\sqrt{d_x(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。当且仅当根号下的项消失时，即 $d_x(\\mathbf{k})=0$ 和 $d_z(\\mathbf{k})=0$ 时，出现简并。\n\n  我们来分析在 $k_x = \\pi$ 这条线上的行为：\n  $d_x(\\pi, k_y) = 2\\cos(\\pi/2)(\\dots) = 0$。因此，$d_x$ 在整条线上恒为零。\n  $d_z(\\pi, k_y) = t_{\\mathrm{odd}}\\sin(k_y) + \\Delta_{\\mathrm{break}}$。\n  \n  在滑移对称的情况下（$\\Delta_{\\mathrm{break}}=0$），简并要求 $d_z = t_{\\mathrm{odd}}\\sin(k_y) = 0$。这个条件在高对称动量点 $k_y=0$（点 $X(\\pi,0)$）和 $k_y=\\pi$（点 $M(\\pi,\\pi)$）得到满足。因此，能带在 $X$ 和 $M$ 点必须是简并的。这种由于非点式对称性和时间反演，导致能带在特定高对称点上被迫简并的现象，被称为能带粘连。如果 $t_{\\mathrm{odd}}\\neq 0$，在线上的一个普通点，如 $B_{\\mathrm{mid}}(\\pi, \\pi/2)$ 处的简并会被解除。如果 $t_{\\mathrm{odd}}=0$，则能带在整个 $k_x=\\pi$ 线上都是简并的。\n\n**4. 对易子计算**\n我们计算在点 $X=(\\pi,0)$ 处的对易子 $C = [H(\\mathbf{k}), U_G(\\mathbf{k})]$。\n在 $X$ 点，$U_G(X) = e^{-i\\pi/2}\\sigma_x = -i\\sigma_x$。\n哈密顿量的系数为：\n$d_0(X) = 2t_x\\cos(\\pi) + 2t_y\\cos(0) = -2t_x + 2t_y$。\n$d_x(X) = 0$。\n$d_z(X) = t_{\\mathrm{odd}}\\sin(0) + \\Delta_{\\mathrm{break}} = \\Delta_{\\mathrm{break}}$。\n所以，$H(X) = (-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z$。\n$$ C = [H(X), U_G(X)] = [(-2t_x + 2t_y)\\sigma_0 + \\Delta_{\\mathrm{break}}\\sigma_z, -i\\sigma_x] = -i\\Delta_{\\mathrm{break}}[\\sigma_z, \\sigma_x] $$\n使用 $[\\sigma_z, \\sigma_x] = 2i\\sigma_y$：\n$$ C = -i\\Delta_{\\mathrm{break}}(2i\\sigma_y) = 2\\Delta_{\\mathrm{break}}\\sigma_y = \\begin{pmatrix} 0  -2i\\Delta_{\\mathrm{break}} \\\\ 2i\\Delta_{\\mathrm{break}}  0 \\end{pmatrix} $$\n弗罗贝尼乌斯范数为 $\\|C\\|_F = \\sqrt{\\mathrm{Tr}(C^\\dagger C)} = \\sqrt{|-2i\\Delta_{\\mathrm{break}}|^2 + |2i\\Delta_{\\mathrm{break}}|^2} = \\sqrt{4\\Delta_{\\mathrm{break}}^2 + 4\\Delta_{\\mathrm{break}}^2} = \\sqrt{8\\Delta_{\\mathrm{break}}^2} = 2\\sqrt{2}|\\Delta_{\\mathrm{break}}|$。该范数当且仅当 $\\Delta_{\\mathrm{break}}=0$ 时为零，证实了此参数会破坏滑移对称性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a tight-binding Hamiltonian for a 2D lattice\n    with non-symmorphic glide symmetry, checking for symmetry-protected\n    degeneracies and symmetry breaking.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Generic glide-symmetric case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.0},\n        # Case 2: Glide-symmetric with t_odd=0, leading to full boundary sticking\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.0, 'delta_break':0.0},\n        # Case 3: Explicit glide-breaking case\n        {'epsilon': 0, 'tx':-0.8, 'ty':-0.6, 't1':1.0, 't2':0.35, 't3':-0.2, 't_odd':0.5, 'delta_break':0.1},\n    ]\n\n    def build_hamiltonian(k, params):\n        \"\"\"Constructs the 2x2 Bloch Hamiltonian H(k).\"\"\"\n        kx, ky = k\n        a, b = 1.0, 1.0 # Set lattice constants to 1\n        \n        # Unpack parameters\n        tx = params['tx']\n        ty = params['ty']\n        t1 = params['t1']\n        t2 = params['t2']\n        t3 = params['t3']\n        t_odd = params['t_odd']\n        delta_break = params['delta_break']\n\n        # Pauli matrices\n        sigma0 = np.array([[1, 0], [0, 1]], dtype=complex)\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        sigmaz = np.array([[1, 0], [0, -1]], dtype=complex)\n\n        # Calculate coefficients d_mu(k)\n        d0 = 2 * tx * np.cos(kx * a) + 2 * ty * np.cos(ky * b)\n        dx = 2 * np.cos(kx * a / 2.0) * (t1 + 2 * t2 * np.cos(ky * b) + 2 * t3 * np.cos(2 * ky * b))\n        # dy is zero for this model\n        dz = t_odd * np.sin(ky * b) + delta_break\n\n        H = d0 * sigma0 + dx * sigmax + dz * sigmaz\n        return H\n\n    def build_glide_op(k):\n        \"\"\"Constructs the 2x2 glide symmetry operator U_G(k).\"\"\"\n        kx, _ = k\n        a = 1.0\n        sigmax = np.array([[0, 1], [1, 0]], dtype=complex)\n        Ug = np.exp(-1j * kx * a / 2.0) * sigmax\n        return Ug\n\n    results = []\n    tolerance = 1e-8\n    \n    # Define high-symmetry momenta\n    k_X = (np.pi, 0.0)\n    k_M = (np.pi, np.pi)\n    k_Bmid = (np.pi, np.pi / 2.0)\n    momenta = [k_X, k_M, k_Bmid]\n\n    for params in test_cases:\n        case_results = []\n        \n        # 1. Check for degeneracies at X, M, B_mid\n        for k in momenta:\n            H = build_hamiltonian(k, params)\n            eigvals = np.linalg.eigvalsh(H)\n            is_degenerate = np.abs(eigvals[0] - eigvals[1]) < tolerance\n            case_results.append(is_degenerate)\n            \n        # 2. Compute the Frobenius norm of the commutator [H(X), U_G(X)]\n        H_X = build_hamiltonian(k_X, params)\n        Ug_X = build_glide_op(k_X)\n        commutator = H_X @ Ug_X - Ug_X @ H_X\n        comm_norm = np.linalg.norm(commutator, 'fro')\n        case_results.append(comm_norm)\n        \n        results.append(case_results)\n\n    # Format the final output string as per the requirements\n    def format_case_result(res_list):\n        # [bool, bool, bool, float] -> \"[true,true,false,0.0]\"\n        bool_strs = [str(b).lower() for b in res_list[:3]]\n        float_str = str(res_list[3])\n        return f\"[{','.join(bool_strs)},{float_str}]\"\n\n    final_output_str = f\"[{','.join(map(format_case_result, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3435165"}]}