{"hands_on_practices": [{"introduction": "在编写任何大规模计算代码之前，估算其所需的计算资源是计算科学家的一项基本功。本练习将指导您完成一项基本的“信封背面”计算，以确定求解一个大型矩量法系统所需的计算时间和内存占用。通过这项实践，您将把抽象的 $O(N^3)$ 复杂度与具体、实际的硬件限制联系起来，从而对稠密直接求解器的可行性有更深刻的认识。", "problem": "一个稠密的矩量法 (MoM) 阻抗矩阵产生于对自由空间中理想导电散射体的频域电场积分方程进行离散化。由此产生的线性系统为 $Z I = V$，其中 $Z \\in \\mathbb{C}^{N \\times N}$ 是一个稠密的非厄米矩阵。考虑使用部分主元高斯消去法（原地 LU 分解）的直接稠密求解器来求解该系统。\n\n从以下基本依据出发：\n- 在高斯消去法中，在第 $k$ 列选择一个主元后，大小为 $(N-k) \\times (N-k)$ 的尾随子矩阵的更新是一种形式为 $A \\leftarrow A - u v^{T}$ 的外积（秩-1）更新。\n- 一次复数乘法需要 $6$ 次实数浮点运算，一次复数加法或减法需要 $2$ 次实数浮点运算。\n- 与大的 $N$ 的立方阶尾随更新成本相比，主元搜索、除法和置换产生的低阶成本可以忽略不计。\n\n推导一个稠密的 $N \\times N$ 复双精度矩阵进行 LU 分解所需的主阶实数浮点运算次数。然后，对于 $N = 5000$ 的情况，估算在一个每秒能维持 $1 \\times 10^{12}$ 次双精度实数浮点运算的单个计算节点上，进行分解所需的墙上时钟时间。接着，假设每个复双精度数占用 $16$ 字节，并忽略低阶工作空间，估算以吉比字节 (GiB) 为单位存储该稠密复数矩阵及其原地 LU 因子的内存占用。简要评估在具有 $64\\,\\mathrm{GiB}$ 内存的节点上进行此分解是否可行。\n\n以秒为单位表示最终时间，并将最终数值答案四舍五入至三位有效数字。作为您的最终数值答案，仅报告以秒为单位的估算分解时间。", "solution": "该问题已经过验证，被认为是有效的。它具有科学依据、内容自洽且问题良定，是计算科学和数值线性代数中的一个标准问题。因此，我们可以进行形式化的求解。\n\n任务是确定对一个稠密的非厄米复数矩阵 $Z \\in \\mathbb{C}^{N \\times N}$ 进行 LU 分解的计算成本和内存需求，并评估在特定矩阵大小和硬件配置下此操作的可行性。\n\n首先，我们推导 LU 分解的主阶实数浮点运算（FLOP）次数。该算法是高斯消去法，分 $N-1$ 步进行。在第 $k$ 步（$k$ 从 $1$ 到 $N-1$），主要的计算工作是更新大小为 $(N-k) \\times (N-k)$ 的尾随子矩阵。问题陈述指明这是一个形式为 $A \\leftarrow A - u v^{T}$ 的秩-1 更新，其中 $A$ 是尾随子矩阵，$u, v$ 是长度为 $N-k$ 的复数向量。\n\n让我们分析第 $k$ 步更新的成本。子矩阵的大小是 $M \\times M$，其中 $M = N-k$。\n1.  外积 $u v^{T}$ 产生一个 $M \\times M$ 矩阵。其 $M^2$ 个元素中的每一个都是一个来自 $u$ 的复数和一个来自 $v$ 的复数的乘积。这需要 $M^2$ 次复数乘法。\n2.  从子矩阵 $A$ 中减去这个结果矩阵需要 $M^2$ 次复数减法。\n\n问题给出了这些复数运算以实数浮点运算表示的成本：\n-   一次复数乘法需要 $6$ 次实数浮点运算。\n-   一次复数减法需要 $2$ 次实数浮点运算。\n\n因此，第 $k$ 步秩-1 更新的总成本是：\n$$ \\text{Cost}_k = (N-k)^2 \\times (\\text{cost of complex multiply}) + (N-k)^2 \\times (\\text{cost of complex subtract}) $$\n$$ \\text{Cost}_k = (N-k)^2 \\times 6 + (N-k)^2 \\times 2 = 8(N-k)^2 \\text{ real FLOPs} $$\n\n分解的总运算次数是所有步骤（从 $k=1$ 到 $N-1$）成本的总和。根据指示，我们只考虑大的 $N$ 的主阶成本，这为忽略主元选取和除法所产生的成本提供了理由。\n$$ \\text{Total FLOPs} = \\sum_{k=1}^{N-1} \\text{Cost}_k = \\sum_{k=1}^{N-1} 8(N-k)^2 $$\n让我们进行变量替换 $j = N-k$。当 $k$ 从 $1$ 变化到 $N-1$ 时，$j$ 从 $N-1$ 变化到 $1$。\n$$ \\text{Total FLOPs} = 8 \\sum_{j=1}^{N-1} j^2 $$\n我们使用著名公式来计算前 $m$ 个平方数的和：$\\sum_{j=1}^{m} j^2 = \\frac{m(m+1)(2m+1)}{6}$。当 $m = N-1$ 时：\n$$ \\text{Total FLOPs} = 8 \\left( \\frac{(N-1)N(2N-1)}{6} \\right) = \\frac{4}{3}N(N-1)(2N-1) $$\n对于大的 $N$，我们可以通过只保留 $N$ 的最高次幂来找到主阶项：\n$$ \\text{Total FLOPs} \\approx \\frac{4}{3}N(N)(2N) = \\frac{8}{3}N^3 $$\n这就是对一个稠密的 $N \\times N$ 复数矩阵进行 LU 分解所需的主阶实数浮点运算次数。\n\n接下来，我们将此公式应用于 $N = 5000$ 的情况。\n$$ N = 5 \\times 10^3 $$\n$$ \\text{Total FLOPs} = \\frac{8}{3} (5 \\times 10^3)^3 = \\frac{8}{3} (125 \\times 10^9) = \\frac{1000}{3} \\times 10^9 \\approx 3.333... \\times 10^{11} \\text{ real FLOPs} $$\n\n该计算节点维持的性能为 $P = 1 \\times 10^{12}$ 次实数浮点运算/秒（FLOPS）。估算的分解墙上时钟时间 $T$ 为：\n$$ T = \\frac{\\text{Total FLOPs}}{P} = \\frac{\\frac{1000}{3} \\times 10^9}{1 \\times 10^{12}} = \\frac{10^{3} \\times 10^9}{3 \\times 10^{12}} = \\frac{10^{12}}{3 \\times 10^{12}} = \\frac{1}{3} \\text{ seconds} $$\n四舍五入到三位有效数字，时间为 $0.333$ 秒。\n\n现在，我们估算存储矩阵的内存占用。分解是“原地”执行的，所以 $L$ 和 $U$ 因子的内存会覆盖原始矩阵 $Z$。因此，我们只需要考虑存储一个 $N \\times N$ 复数矩阵。\n该矩阵有 $N^2$ 个元素。每个元素是一个复双精度数，占用 $16$ 字节。\n$$ N = 5000 $$\n$$ \\text{Memory (bytes)} = N^2 \\times 16 = (5000)^2 \\times 16 = (25 \\times 10^6) \\times 16 = 400 \\times 10^6 \\text{ bytes} $$\n为了以吉比字节 (GiB) 表示，我们使用换算关系 $1 \\text{ GiB} = 2^{30}$ 字节。\n$$ \\text{Memory (GiB)} = \\frac{400 \\times 10^6}{2^{30}} = \\frac{400,000,000}{1,073,741,824} \\approx 0.3725 \\text{ GiB} $$\n\n最后，我们评估在具有 $64\\,\\mathrm{GiB}$ 可用内存的计算节点上进行此分解的可行性。\n所需内存约为 $0.373\\,\\mathrm{GiB}$，远小于可用的 $64\\,\\mathrm{GiB}$（$0.373 \\ll 64$）。估算时间小于一秒。因此，内存占用和计算时间都完全在指定计算节点的能力范围之内。该分解是完全可行的。", "answer": "$$\n\\boxed{0.333}\n$$", "id": "3299502"}, {"introduction": "矩量法解的准确性不仅取决于求解器，还取决于阻抗矩阵本身的构建精度。最后的这项实践提供了一个数值实验，旨在研究数值积分（特别是奇异和近奇异积分）产生的误差是如何传播并影响 LU 分解的稳定性的。您将探索这些输入扰动如何改变主元选择和增长因子，从而将离散化阶段与求解器的数值行为直接联系起来。", "problem": "您正在研究计算电磁学中矩量法（MoM）产生的阻抗矩阵中，奇异和近奇异相互作用的数值积分误差所带来的影响，以及这种扰动如何影响采用部分主元法的 LU（Lower-Upper）分解中的主元选择和增长因子。考虑一个一维模型问题，该问题旨在分离奇异和近奇异核函数的影响，同时在数值上保持易于处理：实数轴上的两个不相交的线性段，一个占据区间 $[0,1]$，另一个占据区间 $[1+\\gamma, 2+\\gamma]$，其中 $\\gamma \\ge 0$ 是一个预设的“间隙”参数，用于控制两个段之间的近奇异相互作用。每个段被均匀地划分为预定数量的面元，并使用分段常数基函数/检验函数。\n\n为了模拟在二维公式中发现的弱奇异格林函数相互作用，定义核函数为\n$$\nK(x,x') = -\\ln\\!\\big(\\sqrt{(x - x')^{2} + \\sigma^{2}}\\big),\n$$\n其中 $\\sigma > 0$ 是一个小的正则化长度，它以科学上合理的方式平滑了在 $x = x'$ 处的对数奇异性。面元 $i$ 和面元 $j$ 之间的矩量法（MoM）阻抗矩阵元素 $Z_{ij}$ 是双线性形式\n$$\nZ_{ij} = \\int_{a_i}^{b_i} \\int_{a_j}^{b_j} K(x,x') \\,\\mathrm{d}x' \\,\\mathrm{d}x,\n$$\n其中 $[a_i,b_i]$ 和 $[a_j,b_j]$ 是相应面元的端点。最终得到的阻抗矩阵 $Z$ 是一个稠密矩阵。\n\n将采用两种数值积分等级来构建该矩阵：\n- 一个高阶参考积分，每个积分维度使用 $n_{\\text{ref}}$ 个高斯-勒让德节点，得到参考矩阵 $Z^{\\text{ref}}$。\n- 一个低阶积分，每个积分维度使用 $n_{\\text{low}}$ 个高斯-勒让德节点，得到扰动矩阵 $Z^{\\text{low}}$。\n\n定义积分误差扰动为\n$$\nE = Z^{\\text{low}} - Z^{\\text{ref}},\n$$\n并通过矩阵无穷范数来量化它\n$$\n\\|E\\|_{\\infty} = \\max_{i} \\sum_{j} |E_{ij}|.\n$$\n\n使用带部分主元的高斯消去法（GEPP）对 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$ 进行 LU 分解。将分解得到的上三角因子表示为 $U^{\\text{ref}}$ 和 $U^{\\text{low}}$，并将编码行交换序列的相应主元索引数组表示为 $p^{\\text{ref}}$ 和 $p^{\\text{low}}$。定义一个矩阵 $A$ 在 GEPP 下的增长因子为\n$$\ng(A) = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|},\n$$\n其中 $U$ 是对 $A$ 应用 GEPP 过程得到的最终上三角因子。比较主元索引数组以确定积分误差是否改变了主元选择决策。\n\n您的任务是：\n1. 对于指定的测试几何结构，使用乘积高斯-勒让德积分法，根据所提供的 $\\sigma$、$n_{\\text{ref}}$ 和 $n_{\\text{low}}$ 值，构建 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$。\n2. 计算每个测试几何结构的 $\\|E\\|_{\\infty}$。\n3. 对 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$ 执行带部分主元法的 LU 分解；计算 $g(Z^{\\text{ref}})$ 和 $g(Z^{\\text{low}})$。\n4. 确定主元索引数组是否相同。如果相同，则报告一个表示为整数 $1$ 的布尔值，否则报告 $0$。\n\n使用以下测试套件，该套件通过间隙参数 $\\gamma$、面元数量和积分阶数来改变近奇异性。所有量均为无量纲。\n\n- 测试用例 1（具有中等近奇异性的一般情况）：\n    - 第一个段上的面元数：$N_1 = 4$。\n    - 第二个段上的面元数：$N_2 = 4$。\n    - 间隙：$\\gamma = 0.1$。\n    - 正则化：$\\sigma = 10^{-12}$。\n    - 参考积分阶数：$n_{\\text{ref}} = 64$。\n    - 低阶积分：$n_{\\text{low}} = 8$。\n\n- 测试用例 2（强近奇异性和较低的积分精度）：\n    - 第一个段上的面元数：$N_1 = 6$。\n    - 第二个段上的面元数：$N_2 = 6$。\n    - 间隙：$\\gamma = 10^{-3}$。\n    - 正则化：$\\sigma = 10^{-12}$。\n    - 参考积分阶数：$n_{\\text{ref}} = 64$。\n    - 低阶积分：$n_{\\text{low}} = 4$。\n\n- 测试用例 3（弱近奇异性；远场相互作用占主导）：\n    - 第一个段上的面元数：$N_1 = 3$。\n    - 第二个段上的面元数：$N_2 = 3$。\n    - 间隙：$\\gamma = 0.5$。\n    - 正则化：$\\sigma = 10^{-12}$。\n    - 参考积分阶数：$n_{\\text{ref}} = 64$。\n    - 低阶积分：$n_{\\text{low}} = 8$。\n\n对于每个测试用例，您的程序必须按以下顺序输出一个包含四个元素的列表：\n- 标量 $\\|E\\|_{\\infty}$，为浮点数。\n- 标量 $g(Z^{\\text{ref}})$，为浮点数。\n- 标量 $g(Z^{\\text{low}})$，为浮点数。\n- 指示 $p^{\\text{ref}}$ 和 $p^{\\text{low}}$ 是否相同的布尔指示符，编码为整数（$1$ 或 $0$）。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是如上所述格式的列表；例如，\n$$\n\\text{[ [e_1, g_{\\text{ref},1}, g_{\\text{low},1}, b_1], [e_2, g_{\\text{ref},2}, g_{\\text{low},2}, b_2], [e_3, g_{\\text{ref},3}, g_{\\text{low},3}, b_3] ]}.\n$$\n不涉及物理单位，因此请报告纯数值。", "solution": "### 第 1 步：提取已知条件\n- **几何结构**：实数轴上的两个不相交的线性段：$[0,1]$ 和 $[1+\\gamma, 2+\\gamma]$。\n- **面元数量**：第一个段上有 $N_1$ 个面元，第二个段上有 $N_2$ 个面元。使用分段常数基函数/检验函数。\n- **间隙参数**：$\\gamma \\ge 0$。\n- **核函数**：$K(x,x') = -\\ln\\!\\big(\\sqrt{(x - x')^{2} + \\sigma^{2}}\\big)$。\n- **正则化长度**：$\\sigma > 0$。\n- **阻抗矩阵元素**：$Z_{ij} = \\int_{a_i}^{b_i} \\int_{a_j}^{b_j} K(x,x') \\,\\mathrm{d}x' \\,\\mathrm{d}x$，其中 $[a_i,b_i]$ 是面元 $i$ 的端点。\n- **参考积分**：每个积分维度使用 $n_{\\text{ref}}$ 个高斯-勒让德节点，得到 $Z^{\\text{ref}}$。\n- **低阶积分**：每个积分维度使用 $n_{\\text{low}}$ 个高斯-勒让德节点，得到 $Z^{\\text{low}}$。\n- **积分误差**：$E = Z^{\\text{low}} - Z^{\\text{ref}}$。\n- **误差范数**：$\\|E\\|_{\\infty} = \\max_{i} \\sum_{j} |E_{ij}|$。\n- **分解**：对 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$ 进行带部分主元法的 LU 分解（GEPP）。\n- **GEPP 输出**：上三角因子 $U^{\\text{ref}}, U^{\\text{low}}$；主元索引数组 $p^{\\text{ref}}, p^{\\text{low}}$。\n- **增长因子**：$g(A) = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}$。\n- **主元比较**：布尔指示符（相同为 1，不同为 0）。\n- **测试用例**：\n    1.  $N_1 = 4$, $N_2 = 4$, $\\gamma = 0.1$, $\\sigma = 10^{-12}$, $n_{\\text{ref}} = 64$, $n_{\\text{low}} = 8$。\n    2.  $N_1 = 6$, $N_2 = 6$, $\\gamma = 10^{-3}$, $\\sigma = 10^{-12}$, $n_{\\text{ref}} = 64$, $n_{\\text{low}} = 4$。\n    3.  $N_1 = 3$, $N_2 = 3$, $\\gamma = 0.5$, $\\sigma = 10^{-12}$, $n_{\\text{ref}} = 64$, $n_{\\text{low}} = 8$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学上合理**：该问题是计算电磁学（CEM）中一个真实且表述清晰的数值实验。矩量法（MoM）、对数核函数、奇异积分的数值积分方法、LU 分解以及增长因子的概念都是数值分析和计算电磁学中的标准和基础课题。\n- **适定性**：问题是适定的。输入参数足以且一致地定义一个唯一的计算任务。核函数通过 $\\sigma > 0$ 进行了正则化，确保所有积分都是有限的，并且最终的阻抗矩阵 $Z$ 是明确定义且非奇异的。数值积分和 LU 分解的程序是标准和确定性的。\n- **客观性**：问题使用精确的数学定义和客观的数值参数来陈述。没有歧义或主观性。\n\n### 第 3 步：结论与行动\n该问题是有效的，因为它在科学上合理、适定、客观且完整。我将继续提供完整解法。\n\n### 解决方案\n\n目标是量化数值积分误差对应用于模型矩量法（MoM）阻抗矩阵的带部分主元的高斯消去法（GEPP）的稳定性和主元选择策略的影响。该模型问题分离了近奇异相互作用，这是 MoM 中数值困难的主要来源。\n\n**1. 离散化与矩阵构建**\n几何结构由两个段 $[0,1]$ 和 $[1+\\gamma, 2+\\gamma]$ 组成，分别离散为 $N_1$ 和 $N_2$ 个面元。总面元数，即阻抗矩阵 $Z$ 的维度，为 $N = N_1 + N_2$。对于分段常数基函数，面元由每个段的均匀剖分定义。\n- 对于 $i \\in \\{0, 1, \\dots, N_1-1\\}$，面元 $i$ 为 $[i/N_1, (i+1)/N_1]$。\n- 对于 $i \\in \\{N_1, \\dots, N-1\\}$，令 $k = i - N_1$。面元 $i$ 为 $[1+\\gamma+k/N_2, 1+\\gamma+(k+1)/N_2]$。\n\n阻抗矩阵元素 $Z_{ij}$ 表示面元 $i$ 和面元 $j$ 之间的相互作用。它由核函数在面元域上的二重积分给出：\n$$\nZ_{ij} = \\int_{a_i}^{b_i} \\int_{a_j}^{b_j} K(x,x') \\,\\mathrm{d}x' \\,\\mathrm{d}x = -\\frac{1}{2} \\int_{a_i}^{b_i} \\int_{a_j}^{b_j} \\ln((x - x')^{2} + \\sigma^{2}) \\,\\mathrm{d}x' \\,\\mathrm{d}x\n$$\n该积分使用乘积高斯-勒让德积分法则进行数值计算。设 $\\{\\xi_k, w_k\\}_{k=1}^n$ 是 $[-1,1]$ 上 $n$ 点高斯-勒让德积分法则的节点和权重。通过将积分域 $[a,b]$ 映射到 $[-1,1]$，二重积分近似为：\n$$\nZ_{ij} \\approx \\left(\\frac{b_i-a_i}{2}\\right) \\left(\\frac{b_j-a_j}{2}\\right) \\sum_{k=1}^{n} \\sum_{l=1}^{n} w_k w_l K(x_k, x'_l)\n$$\n其中 $x_k = \\frac{b_i-a_i}{2}\\xi_k + \\frac{a_i+b_i}{2}$ 和 $x'_l = \\frac{b_j-a_j}{2}\\xi_l + \\frac{a_j+b_j}{2}$ 是映射到面元 $i$ 和 $j$ 上的积分点。此计算在 $n=n_{\\text{ref}}$ 时执行以生成高保真度参考矩阵 $Z^{\\text{ref}}$，在 $n=n_{\\text{low}}$ 时执行以生成扰动矩阵 $Z^{\\text{low}}$。\n\n**2. 误差与稳定性分析**\n由低阶积分引入的扰动由误差矩阵 $E = Z^{\\text{low}} - Z^{\\text{ref}}$ 捕捉。其大小由矩阵无穷范数 $\\|E\\|_{\\infty} = \\max_{i} \\sum_{j=1}^{N} |E_{ij}|$ 衡量，该范数对应于最大绝对行和。此范数是矩阵任一行所经历的最大扰动的直接度量。\n\n采用 GEPP 对 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$ 进行分解。该算法在 `scipy.linalg.lu_factor` 中实现，它返回 $L$ 和 $U$ 因子的紧凑表示，以及一个记录行交换的主元数组 $p$。分解的稳定性通过增长因子来评估，定义为：\n$$\ng(A) = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}\n$$\n一个小的增长因子（接近 1）表示一个稳定的分解过程，其中矩阵元素的大小不会失控增长，从而保持数值精度。大的增长因子是数值不稳定的症状。\n\n最后，比较主元数组 $p^{\\text{ref}}$ 和 $p^{\\text{low}}$。如果 $p^{\\text{ref}} \\neq p^{\\text{low}}$，则表示积分误差 $E$ 的影响足够大以至于改变了 GEPP 的主元选择策略。主元选择的改变可能导致不同的增长因子，从而导致分解的数值稳定性水平不同。\n\n**3. 算法实现**\n该解决方案以 Python 脚本的形式实现。一个核心函数 `assemble_z` 负责为一组给定的几何和积分参数构建阻抗矩阵。脚本的主体部分遍历每个指定的测试用例。在每次迭代中，它：\n1.  分别使用 $n_{\\text{ref}}$ 和 $n_{\\text{low}}$ 调用 `assemble_z` 来构建 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$。\n2.  计算误差矩阵 $E$ 及其无穷范数 $\\|E\\|_{\\infty}$。\n3.  对 $Z^{\\text{ref}}$ 和 $Z^{\\text{low}}$ 调用 `scipy.linalg.lu_factor` 以获得 LU 分解和主元数组。\n4.  提取上三角矩阵 $U^{\\text{ref}}$ 和 $U^{\\text{low}}$，并计算相应的增长因子 $g(Z^{\\text{ref}})$ 和 $g(Z^{\\text{low}})$。\n5.  比较主元数组 $p^{\\text{ref}}$ 和 $p^{\\text{low}}$ 是否相等。\n每个测试用例的结果——$\\|E\\|_{\\infty}$、$g(Z^{\\text{ref}})$、$g(Z^{\\text{low}})$ 以及主元比较——被收集并以指定格式打印。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (N1, N2, gamma, sigma, n_ref, n_low)\n        (4, 4, 0.1, 1e-12, 64, 8),\n        (6, 6, 1e-3, 1e-12, 64, 4),\n        (3, 3, 0.5, 1e-12, 64, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        n1, n2, gamma, sigma, n_ref, n_low = case\n\n        # 1. Assemble Z^ref and Z^low\n        z_ref = assemble_z(n1, n2, gamma, sigma, n_ref)\n        z_low = assemble_z(n1, n2, gamma, sigma, n_low)\n\n        # 2. Compute ||E||_inf\n        e_matrix = z_low - z_ref\n        norm_e_inf = np.linalg.norm(e_matrix, ord=np.inf)\n\n        # 3. Perform LU on Z^ref and compute g(Z^ref)\n        max_abs_z_ref = np.max(np.abs(z_ref))\n        if max_abs_z_ref == 0:\n            g_ref = np.nan\n            piv_ref = np.array([])\n        else:\n            lu_ref, piv_ref = scipy.linalg.lu_factor(z_ref)\n            u_ref = np.triu(lu_ref)\n            max_abs_u_ref = np.max(np.abs(u_ref))\n            g_ref = max_abs_u_ref / max_abs_z_ref\n\n        # 3. Perform LU on Z^low and compute g(Z^low)\n        max_abs_z_low = np.max(np.abs(z_low))\n        if max_abs_z_low == 0:\n            g_low = np.nan\n            piv_low = np.array([])\n        else:\n            lu_low, piv_low = scipy.linalg.lu_factor(z_low)\n            u_low = np.triu(lu_low)\n            max_abs_u_low = np.max(np.abs(u_low))\n            g_low = max_abs_u_low / max_abs_z_low\n\n        # 4. Compare pivot arrays\n        pivots_identical = 1 if np.array_equal(piv_ref, piv_low) else 0\n\n        results.append([norm_e_inf, g_ref, g_low, pivots_identical])\n    \n    # Format the final output string to match the problem specification\n    outer_list_str = []\n    for res in results:\n        inner_list_str = f\"[{res[0]}, {res[1]}, {res[2]}, {res[3]}]\"\n        outer_list_str.append(inner_list_str)\n    final_str = f\"[{', '.join(outer_list_str)}]\"\n    \n    print(final_str)\n\ndef kernel(x, xp, sigma):\n    \"\"\"\n    Computes the kernel K(x, x') = -0.5 * ln((x - x')^2 + sigma^2).\n    \"\"\"\n    return -0.5 * np.log((x - xp)**2 + sigma**2)\n\ndef assemble_z(n1, n2, gamma, sigma, n_quad):\n    \"\"\"\n    Assembles the MoM impedance matrix Z using product Gauss-Legendre quadrature.\n\n    Args:\n        n1 (int): Number of panels on the first segment.\n        n2 (int): Number of panels on the second segment.\n        gamma (float): Gap between segments.\n        sigma (float): Regularization parameter.\n        n_quad (int): Order of Gauss-Legendre quadrature.\n\n    Returns:\n        np.ndarray: The assembled N x N impedance matrix, where N = n1 + n2.\n    \"\"\"\n    n_total = n1 + n2\n    z = np.zeros((n_total, n_total))\n    \n    # Define panel endpoints\n    panel_endpoints = []\n    h1 = 1.0 / n1\n    for i in range(n1):\n        panel_endpoints.append((i * h1, (i + 1) * h1))\n    \n    h2 = 1.0 / n2\n    for i in range(n2):\n        panel_endpoints.append((1 + gamma + i * h2, 1 + gamma + (i + 1) * h2))\n\n    # Get Gauss-Legendre nodes and weights for the interval [-1, 1]\n    nodes, weights = np.polynomial.legendre.leggauss(n_quad)\n        \n    for i in range(n_total):\n        ai, bi = panel_endpoints[i]\n        len_i = bi - ai\n        # Map nodes from [-1, 1] to the panel interval [ai, bi]\n        x_nodes = 0.5 * len_i * nodes + 0.5 * (ai + bi)\n\n        for j in range(n_total):\n            aj, bj = panel_endpoints[j]\n            len_j = bj - aj\n            # Map nodes from [-1, 1] to the panel interval [aj, bj]\n            xp_nodes = 0.5 * len_j * nodes + 0.5 * (aj + bj)\n\n            # Create meshgrids to evaluate the kernel at all pairs of quadrature points\n            x_mesh, xp_mesh = np.meshgrid(x_nodes, xp_nodes, indexing='ij')\n            w_mesh, wp_mesh = np.meshgrid(weights, weights, indexing='ij')\n\n            # Evaluate kernel on the grid of points\n            kernel_vals = kernel(x_mesh, xp_mesh, sigma)\n            \n            # Compute the integral via summation\n            integral_val = np.sum(w_mesh * wp_mesh * kernel_vals)\n\n            # Scale by Jacobians of the transformations\n            z[i, j] = (len_i / 2.0) * (len_j / 2.0) * integral_val\n            \n    return z\n\nsolve()\n```", "id": "3299506"}]}