{"hands_on_practices": [{"introduction": "在对奇异性进行数值处理之前，我们必须首先理解其解析形式。本练习提供了一项基础实践，要求推导二维亥姆霍兹格林函数的小宗量渐近行为，从而揭示其特有的对数奇异性。掌握这一推导过程 [@problem_id:3348056] 对于理解为何奇异性减法等技术会采用其特有的设计至关重要。", "problem": "考虑二维空间中的时谐标量亥姆霍兹方程，其边界条件为自由空间边界条件，\n$$(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r}),$$\n其中 $k>0$ 是波数，$\\delta(\\cdot)$ 是狄拉克δ分布。自由空间格林函数由下式给出\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r),$$\n其中 $r = \\|\\mathbf{r}\\|$，$H_{0}^{(1)}$ 是第一类零阶汉克尔函数。在计算电磁学中，特别是在边界积分公式和边界元法 (BEM) 中，标准的做法是通过减去静态二维格林函数核 $-\\frac{1}{2\\pi}\\ln r$ 来进行奇异性提取，以便在重合点处分离出有限的余项。\n\n从构成 $H_{0}^{(1)} = J_{0} + i Y_{0}$ 的贝塞尔函数 $J_{0}$ 和 $Y_{0}$ 的基本定义和经过充分检验的级数表示出发，推导当 $r \\to 0^{+}$ 时 $G(\\mathbf{r})$ 的小宗量渐近行为，识别其主导的对数奇异性，并确定在减去 $-\\frac{1}{2\\pi}\\ln r$ 后剩下的有限常数项。你的推导必须清楚地说明对数奇异性是如何产生的，以及常数项如何依赖于 $k$。\n\n作为最终答案，请给出 $G(\\mathbf{r})$ 的显式渐近表达式，该表达式应包含到常数项为止，即形式为\n$-\\frac{1}{2\\pi}\\ln r + \\text{常数}$\n其中依赖于 $k$ 的常数需要被完全确定。不需要进行数值计算或四舍五入。最终答案必须是一个单一的闭式解析表达式。", "solution": "首先对问题进行验证。\n\n### 步骤1：提取已知条件\n- 控制方程是二维时谐标量亥姆霍兹方程：$(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r})$。\n- 波数 $k$ 是一个正实数，$k>0$。\n- 源项是狄拉克δ分布，$\\delta(\\mathbf{r})$。\n- 自由空间格林函数为 $G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$，其中 $r = \\|\\mathbf{r}\\|$。\n- $H_{0}^{(1)}$ 是第一类零阶汉克尔函数。\n- 奇异性提取技术涉及减去静态格林函数，即 $-\\frac{1}{2\\pi}\\ln r$。\n- 汉克尔函数通过 $H_{0}^{(1)} = J_{0} + i Y_{0}$ 与第一类贝塞尔函数 ($J_0$) 和第二类贝塞尔函数 ($Y_0$) 相关联。\n- 任务是利用 $J_0$ 和 $Y_0$ 的级数表示，推导当 $r \\to 0^{+}$ 时 $G(\\mathbf{r})$ 的小宗量渐近行为，并将结果表示为 $-\\frac{1}{2\\pi}\\ln r + \\text{常数}$ 的形式。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据充分：** 问题陈述完全基于成熟的数学物理和计算科学。亥姆霍兹方程、格林函数、贝塞尔函数和汉克尔函数，以及奇异性提取方法都是标准且有据可查的概念。\n- **适定性：** 这是一个适定问题。它要求推导一个已定义函数的特定、已知的渐近极限。所需的步骤已经列出，并且存在唯一的解析解。\n- **客观性：** 问题以精确、客观、形式化的数学语言陈述，没有任何歧义或主观因素。\n- **结论：** 该问题在科学上是合理的，内部一致，完整且适定的。它不违反任何指定的无效标准。\n\n### 步骤3：判定与行动\n该问题是 **有效的**。将提供完整解答。\n\n### 渐近表达式的推导\n\n目标是确定亥姆霍兹方程的二维自由空间格林函数在径向距离 $r = \\|\\mathbf{r}\\|$ 趋近于零时的渐近行为。格林函数由下式给出：\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$$\n其中 $k > 0$ 是波数，$H_{0}^{(1)}$ 是第一类零阶汉克尔函数。\n\n首先，我们将汉克尔函数用第一类贝塞尔函数 $J_0$ 和第二类贝塞尔函数（或诺伊曼函数） $Y_0$ 来表示：\n$$H_{0}^{(1)}(z) = J_{0}(z) + i Y_{0}(z)$$\n将此定义代入 $G(\\mathbf{r})$ 的表达式，并设宗量为 $z = kr$：\n$$G(\\mathbf{r}) = \\frac{i}{4} \\left( J_{0}(k r) + i Y_{0}(k r) \\right) = \\frac{i}{4} J_{0}(k r) - \\frac{1}{4} Y_{0}(k r)$$\n为了找到当 $r \\to 0^{+}$ 时的行为，我们需要 $J_0(z)$ 和 $Y_0(z)$ 在 $z \\to 0^{+}$ 时的小宗量渐近展开式。\n\n$J_0(z)$ 贝塞尔函数的级数表示为：\n$$J_{0}(z) = \\sum_{m=0}^{\\infty} \\frac{(-1)^{m}}{(m!)^{2}} \\left(\\frac{z}{2}\\right)^{2m} = 1 - \\frac{z^2}{4} + \\frac{z^4}{64} - \\dots$$\n当 $z \\to 0$ 时，主导项是 $1$。因此，对于小的 $r$：\n$$J_{0}(k r) = 1 + O((kr)^2)$$\n\n第二类贝塞尔函数 $Y_0(z)$ 的小宗量展开式更为复杂，并且是对数奇异性的来源。其标准展开式为：\n$$Y_{0}(z) = \\frac{2}{\\pi} \\left[ \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) J_0(z) - \\sum_{m=1}^{\\infty} \\frac{(-1)^m}{(m!)^2} \\left( \\sum_{j=1}^{m} \\frac{1}{j} \\right) \\left(\\frac{z}{2}\\right)^{2m} \\right]$$\n其中 $\\gamma \\approx 0.5772$ 是欧拉-马歇罗尼常数。\n对于 $z \\to 0$，我们知道 $J_0(z) \\to 1$。求和项的行为是 $O(z^2)$。因此，$Y_0(z)$ 的主导阶行为由第一项决定：\n$$Y_{0}(z) \\approx \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) \\cdot 1 = \\frac{2}{\\pi} \\left( \\ln(z) - \\ln(2) + \\gamma \\right)$$\n代入 $z=kr$，我们得到 $Y_0(kr)$ 的小宗量行为：\n$$Y_{0}(k r) = \\frac{2}{\\pi} \\left( \\ln(kr) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr)) = \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr))$$\n\n现在我们将 $J_0(kr)$ 和 $Y_0(kr)$ 的渐近形式代回到 $G(\\mathbf{r})$ 的表达式中：\n$$G(\\mathbf{r}) \\approx \\frac{i}{4}(1) - \\frac{1}{4} \\left[ \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) \\right]$$\n简化这个表达式：\n$$G(\\mathbf{r}) \\approx \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right)$$\n为了匹配所要求的形式，我们分离出包含 $\\ln(r)$ 的项：\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\left[ \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) \\right]$$\n项 $-\\frac{1}{2\\pi}\\ln(r)$ 是预期的对数奇异性，它与二维拉普拉斯算子的格林函数（常被称为静态核）相同。剩余部分是关于 $r$ 的一个常数：\n$$\\text{常数} = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{k}{2}\\right) + \\gamma \\right)$$\n这个常数代表了亥姆霍兹格林函数在减去对数奇异性后在原点的有限部分。它对波数 $k$ 的依赖性直接源于 $Y_0$ 展开式中对数的宗量。\n\n因此，当 $r \\to 0^{+}$ 时，$G(\\mathbf{r})$ 直至常数项的完整渐近表达式为：\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)$$\n这个结果对于像边界元法这样的数值方法是基础性的，在这些方法中，减去这种奇异性的解析形式可以对余下的良态函数进行精确的数值积分。", "answer": "$$\n\\boxed{-\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)}\n$$", "id": "3348056"}, {"introduction": "理论告诉我们“是什么”，而数值实现则展示了“为什么”。本实践问题将从纯理论转向实际应用，处理一个近奇异积分——这是边界元法中常见的挑战。通过实现并比较朴素数值积分与奇异性减法策略 [@problem_id:3348122]，您将定量地衡量精度的显著提升，并对该技术的强大之处获得切实的体会。", "problem": "考虑拉普拉斯方程的静态自由空间格林核，其定义为 $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\|\\mathbf{r} - \\mathbf{r}'\\|}$，其中 $\\mathbf{r}$ 是观测点，$\\mathbf{r}'$ 是位于一个平面上的源点。令参考三角形为位于平面 $z=0$ 内的直角三角形，其顶点为 $(0,0,0)$、$(1,0,0)$ 和 $(0,1,0)$。其形心位于 $\\mathbf{r}_{c} = (\\frac{1}{3}, \\frac{1}{3}, 0)$。对于一个位于形心上方距离 $\\delta$ 处的观测点 $\\mathbf{r}_{\\text{obs}}(\\delta) = (\\frac{1}{3}, \\frac{1}{3}, \\delta)$（其中 $\\delta > 0$），将该三角形上的核定义为\n$$\nG(x,y;\\delta) = \\frac{1}{4\\pi\\sqrt{(x - \\tfrac{1}{3})^2 + (y - \\tfrac{1}{3})^2 + \\delta^2}},\n$$\n其中 $(x,y)$ 位于三角形 $\\{(x,y)\\,|\\, x \\ge 0,\\ y \\ge 0,\\ x + y \\le 1\\}$ 内部。\n\n令源权重为与顶点 $(1,0,0)$ 相关联的重心坐标所对应的线性基函数，即 $\\phi(x,y) = x$。待求量为曲面积分\n$$\nI(\\delta) = \\int_{T} \\phi(x,y)\\,G(x,y;\\delta)\\, \\mathrm{d}S = \\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\,\\mathrm{d}y\\,\\mathrm{d}x,\n$$\n其中 $T$ 表示参考三角形，$\\mathrm{d}S$ 是以 $\\mathrm{m}^2$ 为单位的面积元。尽管对于任何 $\\delta > 0$，$I(\\delta)$ 都是有限的，但当 $\\delta$ 很小时，由于 $G(x,y;\\delta)$ 在 $(x,y) = (\\frac{1}{3}, \\frac{1}{3})$ 附近的近奇异行为，数值计算变得具有挑战性。\n\n一种经典的奇异性提取与减去技术将该积分重写为\n$$\nI(\\delta) = \\underbrace{\\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S}_{I_{\\text{rem}}(\\delta)}\\;+\\; \\underbrace{\\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S}_{I_{\\text{sing}}(\\delta)},\n$$\n其中 $\\phi(\\mathbf{r}_{c}) = \\frac{1}{3}$，并且 $I_{\\text{rem}}(\\delta)$ 具有更平缓的局部行为，因为 $\\phi(x,y) - \\phi(\\mathbf{r}_{c})$ 在形心处为零，从而降低了被积函数在奇异点附近的峰值严重程度。\n\n从格林函数的基本定义和三角形的几何参数化出发，实现并比较两种计算 $I(\\delta)$ 的数值策略：\n- 一种在 $(x,y)$ 域上的朴素张量积 Gauss-Legendre 求积法，使用固定的适中阶数 $n$，直接近似二重积分 $\\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\, \\mathrm{d}y\\,\\mathrm{d}x$。\n- 一种基于减法的策略，使用相同的适中求积阶数 $n$ 来计算 $I_{\\text{rem}}(\\delta)$，并使用一个阶数高得多的求积法 $n_{\\text{ref}}$ 来计算 $I_{\\text{sing}}(\\delta)$，以在实践中模拟解析已知的奇异贡献。\n\n使用一维 Gauss-Legendre 求积法来近似 $x \\in [0,1]$ 上的积分，以及对于每个 $x$，在 $y \\in [0,1-x]$ 上的积分，并进行正确的仿射映射和权重缩放。您的程序必须：\n- 通过将高阶求积 $n_{\\text{ref}}$ 直接应用于 $I(\\delta)$（不使用减法），计算一个高精度参考值 $I_{\\text{ref}}(\\delta)$。\n- 计算朴素方法的绝对误差，$E_{\\text{naive}}(\\delta) = | I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta) |$。\n- 计算减法方法的绝对误差，$E_{\\text{sub}}(\\delta) = | I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta) |$。\n- 报告精度增益，其定义为\n$$\n\\Gamma(\\delta) = \\frac{E_{\\text{naive}}(\\delta)}{E_{\\text{sub}}(\\delta)}.\n$$\n\n物理单位：将 $\\delta$ 视为米，面积视为平方米，但将最终的精度增益 $\\Gamma(\\delta)$ 报告为无量纲浮点数。\n\n本问题不涉及角度单位。\n\n测试套件：\n- 使用三个 $\\delta$ 值来测试不同情况：$\\delta_1 = 10^{-1}\\,\\mathrm{m}$，$\\delta_2 = 10^{-3}\\,\\mathrm{m}$ 和 $\\delta_3 = 10^{-5}\\,\\mathrm{m}$。\n- 对朴素积分和余项积分使用适中的求积阶数 $n = 24$，对参考积分和减法方法中的奇异部分使用高阶 $n_{\\text{ref}} = 400$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试套件的顺序排列，例如 $[\\Gamma(\\delta_1),\\Gamma(\\delta_2),\\Gamma(\\delta_3)]$。输出必须采用标准 Python 浮点数格式。\n\n通过基于上述格林函数定义和正确的求积法则来确保科学真实性。不要使用任何外部数据或捷径；严格按照规定实现求积和减法。", "solution": "该问题要求比较两种数值积分策略，用于处理在拉普拉斯方程的边界元法背景下出现的近奇异积分。待求量是在参考三角形 $T$ 上的积分 $I(\\delta) = \\int_{T} \\phi(x,y) G(x,y;\\delta) \\mathrm{d}S$，其中 $G$ 是静态自由空间格林核，$\\phi$ 是一个线性源权重。当位于三角形形心上方距离 $\\delta$ 处的观测点接近曲面时（即 $\\delta \\to 0$），便会产生近奇异性。我们将比较一种直接、朴素的数值求积方法与一种更复杂的奇异性减去技术。\n\n奇异性减去的核心原理是对被积函数进行正则化。积分 $I(\\delta)$ 被重写为：\n$$\nI(\\delta) = \\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S \\;+\\; \\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S\n$$\n这将原始积分分解为一个“余项”$I_{\\text{rem}}(\\delta)$ 和一个“奇异项”$I_{\\text{sing}}(\\delta)$。关键的洞见在于源权重函数 $\\phi(x,y)=x$ 是光滑的。通过减去其在形心处的值 $\\phi(\\mathbf{r}_c) = \\phi(1/3, 1/3) = 1/3$，余项被积函数中的新因子 $\\phi(x,y) - \\phi(\\mathbf{r}_c) = x - 1/3$ 在近奇异点位置的 $x$ 坐标处变为零。这种对消显著降低了被积函数的峰值，使得 $I_{\\text{rem}}(\\delta)$ 变得更加光滑，从而更易于使用低阶数值求积进行精确近似。奇异行为被分离到 $I_{\\text{sing}}(\\delta)$ 中，然后可以用高精度方法（此处为高阶求积）处理，或在实践中使用解析公式处理。\n\n为了在参考三角形 $T = \\{(x,y)\\,|\\, x \\ge 0,\\, y \\ge 0,\\, x + y \\le 1\\}$ 上执行数值积分，我们将曲面积分表示为累次积分：\n$$\n\\int_{T} f(x,y) \\mathrm{d}S = \\int_{0}^{1} \\left( \\int_{0}^{1-x} f(x,y) \\mathrm{d}y \\right) \\mathrm{d}x\n$$\n我们应用一维 Gauss-Legendre 求积法则的张量积。这需要将标准求积区间 $[-1, 1]$ 映射到外层积分的积分限 $[0, 1]$ 和内层积分的积分限 $[0, 1-x]$。\n\n对于关于 $x$ 的外层积分，从 $\\xi \\in [-1, 1]$ 到 $x \\in [0, 1]$ 的仿射映射是 $x(\\xi) = \\frac{1}{2}(\\xi+1)$，其雅可比式为 $\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{1}{2}$。\n对于关于 $y$ 的内层积分，对于固定的 $x$，从 $\\eta \\in [-1, 1]$ 到 $y \\in [0, 1-x]$ 的映射是 $y(\\eta) = \\frac{1-x}{2}(\\eta+1)$，其雅可比式为 $\\frac{\\mathrm{d}y}{\\mathrm{d}\\eta} = \\frac{1-x}{2}$。\n\n结合这些，每个维度上使用 N 点求积的近似公式变为：\n$$\nI \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} f(x_i, y_{ij}) \\, w_i w_j \\, \\left(\\frac{1-x_i}{4}\\right)\n$$\n其中 $(\\xi_k, w_k)$（$k=1, \\dots, N$）是 N 点 Gauss-Legendre 节点和权重，求值点为 $x_i = \\frac{1}{2}(\\xi_i+1)$ 和 $y_{ij} = \\frac{1-x_i}{2}(\\eta_j+1)$（使用 $\\eta_j = \\xi_j$）。\n\n计算过程如下：\n1. 使用高阶求积 $n_{\\text{ref}} = 400$ 对原始被积函数 $\\phi(x,y)G(x,y;\\delta)$ 进行积分，从而计算出高精度参考值 $I_{\\text{ref}}(\\delta)$。\n2. 对相同的函数进行积分，但使用适中的求积阶数 $n = 24$，从而计算出朴素近似值 $I_{\\text{naive}}(\\delta)$。\n3. 减法方法的近似值 $I_{\\text{sub}}(\\delta)$ 分两部分计算：\n    -   正则部分 $I_{\\text{rem}}(\\delta)$ 通过使用适中阶数 $n = 24$ 对正则化后的被积函数 $(\\phi(x,y) - \\phi(\\mathbf{r}_c))G(x,y;\\delta)$ 进行积分来计算。\n    -   奇异部分 $I_{\\text{sing}}(\\delta)$ 通过计算 $\\phi(\\mathbf{r}_c) \\int_T G(x,y;\\delta)\\,\\mathrm{d}S$ 来求得，其中格林函数 $G$ 的积分使用高阶 $n_{\\text{ref}} = 400$ 来计算。\n    -   最终值为 $I_{\\text{sub}}(\\delta) = I_{\\text{rem}}(\\delta) + I_{\\text{sing}}(\\delta)$。\n4. 对于每个 $\\delta$，计算绝对误差 $E_{\\text{naive}}(\\delta) = |I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta)|$ 和 $E_{\\text{sub}}(\\delta) = |I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta)|$。精度增益 $\\Gamma(\\delta) = E_{\\text{naive}}(\\delta) / E_{\\text{sub}}(\\delta)$ 量化了减法方法的有效性。$\\Gamma(\\delta)$ 值越大，表示在相同的计算成本下（正则部分的成本），精度提升越大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the accuracy gain of a singularity subtraction technique for a near-singular\n    integral over a triangular domain.\n    \"\"\"\n\n    # Define the test cases and parameters from the problem statement.\n    test_deltas = [1e-1, 1e-3, 1e-5]\n    n_modest = 24\n    n_ref = 400\n    phi_centroid = 1.0 / 3.0\n    xc, yc = 1.0 / 3.0, 1.0 / 3.0\n\n    # Pre-compute Gauss-Legendre nodes and weights to avoid redundant calculations.\n    nodes_modest, weights_modest = roots_legendre(n_modest)\n    nodes_ref, weights_ref = roots_legendre(n_ref)\n\n    def G(x, y, delta):\n        \"\"\"\n        The static free-space Green's kernel for the Laplace equation.\n        G(r, r') = 1 / (4 * pi * ||r - r'||)\n        \"\"\"\n        inv_4pi = 1.0 / (4.0 * np.pi)\n        distance_sq = (x - xc)**2 + (y - yc)**2 + delta**2\n        return inv_4pi / np.sqrt(distance_sq)\n\n    def naive_integrand(x, y, delta):\n        \"\"\"\n        The original integrand: phi(x,y) * G(x,y;delta).\n        phi(x,y) = x\n        \"\"\"\n        return x * G(x, y, delta)\n\n    def rem_integrand(x, y, delta):\n        \"\"\"\n        The remainder integrand after subtraction: (phi(x,y) - phi_c) * G.\n        \"\"\"\n        return (x - phi_centroid) * G(x, y, delta)\n\n    def quad_2d_triangle(func, delta, nodes, weights):\n        \"\"\"\n        Performs 2D Gauss-Legendre quadrature over the reference triangle.\n        The integration is done on a [-1,1] x [-1,1] square and mapped to the triangle.\n        \"\"\"\n        # Create a 2D grid of nodes and weights using broadcasting\n        xi = nodes[:, np.newaxis]\n        eta = nodes[np.newaxis, :]\n        wi = weights[:, np.newaxis]\n        wj = weights[np.newaxis, :]\n\n        # Affine mapping from standard square to triangle\n        x = 0.5 * (xi + 1.0)\n        y = 0.5 * (1.0 - x) * (eta + 1.0)\n\n        # Jacobian of the transformation\n        jacobian = 0.5 * (1.0 - x) * 0.5\n\n        # Evaluate the integrand at all quadrature points\n        integrand_values = func(x, y, delta)\n\n        # Compute the integral by summing weighted values\n        integral = np.sum(wi * wj * integrand_values * jacobian)\n        \n        return integral\n\n\n    results = []\n    for delta in test_deltas:\n        # 1. Compute the high-accuracy reference value using n_ref points.\n        I_ref = quad_2d_triangle(naive_integrand, delta, nodes_ref, weights_ref)\n\n        # 2. Compute the naive approximation using n_modest points.\n        I_naive = quad_2d_triangle(naive_integrand, delta, nodes_modest, weights_modest)\n\n        # 3. Compute the subtraction-based approximation.\n        #    - The remainder term is integrated with the modest order.\n        I_rem = quad_2d_triangle(rem_integrand, delta, nodes_modest, weights_modest)\n        #    - The singular term's integral part is computed with high order.\n        I_G_ref = quad_2d_triangle(G, delta, nodes_ref, weights_ref)\n        I_sing = phi_centroid * I_G_ref\n        \n        I_sub = I_rem + I_sing\n\n        # 4. Compute absolute errors and the accuracy gain.\n        E_naive = np.abs(I_naive - I_ref)\n        E_sub = np.abs(I_sub - I_ref)\n        \n        # Handle the case where the subtraction method is extremely accurate,\n        # to avoid division by a number close to machine epsilon.\n        if E_sub == 0.0:\n            # If the subtraction method error is zero, the gain is effectively infinite.\n            # This can happen due to floating point limitations. We can report a large number\n            # or handle it as a special case. Here, if E_naive is also zero, gain is 1.\n            # Otherwise, gain is large. Since E_naive is not expected to be zero, it's safe to say gain is huge.\n            gamma = np.inf if E_naive > 0.0 else 1.0\n        else:\n            gamma = E_naive / E_sub\n            \n        results.append(gamma)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3348122"}, {"introduction": "我们已经看到奇异性减法是有效的，但其效果究竟如何？我们又该如何控制其精度？本练习通过分析该方法的收敛特性来回答这些问题。您将推导光滑“余项”数值积分的误差上界 [@problem_id:3348057]，从而将积分阶数（$p$）和单元尺寸（$h$）与整体精度联系起来。这项分析为开发高阶、高效的数值格式奠定了理论基础。", "problem": "在计算电磁学中，奇异性提取用于将边界积分核的奇异部分与光滑余项分离，以便对后者应用高阶求积。考虑与三维亥姆霍兹方程相关的标量势公式，其中自由空间格林函数通过奇异性提取被分解为一个奇异核和一个光滑余项。在一个长度为 $h$ 的直边界元上，记提取后的光滑余项为 $R(x)$，其中 $x$ 是沿该元的一维坐标。假设在闭合元上 $R \\in C^{m}$，且 $m \\ge 2p$，并定义积分\n$$\nI_{h} \\equiv \\int_{x_{c}-h/2}^{x_{c}+h/2} R(x) \\, dx,\n$$\n其中 $x_{c}$ 是单元中心。使用从参考区间 $[-1,1]$ 映射到该元的 $p$ 点高斯-勒让德法则来近似 $I_{h}$。\n\n从奇异性提取的基本定义（将被积函数分解为奇异部分和光滑部分）和插值型高斯求积的标准误差表示出发，推导绝对求积误差关于 $p$、$h$ 以及 $R$ 的 $2p$ 阶导数的界的一个严格上界。具体来说，令\n$$\nM_{2p} \\equiv \\max_{x \\in [x_{c}-h/2,\\, x_{c}+h/2]} \\left| \\frac{d^{2p} R(x)}{dx^{2p}} \\right|.\n$$\n将你的最终界表示为一个仅依赖于 $p$、$h$ 和 $M_{2p}$ 的单一闭式表达式。\n\n你的最终答案必须是一个单一的解析表达式。不要包含单位。不要以不等式或方程式的形式给出最终答案；仅需给出作为 $p$、$h$ 和 $M_{2p}$ 函数的边界表达式本身。", "solution": "所述问题具有科学依据，是适定的、客观的且内部一致的。它提出了一个数值分析中的标准练习，具体是推导应用于任意区间上积分的高斯求积的误差界。因此，我们可以进行推导。\n\n目标是找到在使用 $p$ 点高斯-勒让德求积法则近似积分\n$$\nI_{h} \\equiv \\int_{x_{c}-h/2}^{x_{c}+h/2} R(x) \\, dx\n$$\n时的绝对误差的上界。函数 $R(x)$ 假定在积分区间上属于 $C^{2p}$ 类。\n\n$p$ 点高斯-勒让德求积的标准误差公式定义在参考区间 $[-1, 1]$ 上。因此，第一步是将积分 $I_h$ 从物理区间 $[x_{c}-h/2, x_{c}+h/2]$ 变换到参考区间 $[-1, 1]$。我们对坐标 $x$ 使用一个线性仿射映射：\n$$\nx(\\xi) = a\\xi + b\n$$\n我们要求 $x(-1) = x_{c}-h/2$ 和 $x(1) = x_{c}+h/2$。解这个关于 $a$ 和 $b$ 的二元线性方程组，得到：\n$$\na = \\frac{h}{2}, \\quad b = x_{c}\n$$\n因此，变换为：\n$$\nx(\\xi) = \\frac{h}{2}\\xi + x_{c}\n$$\n微分元变换为 $dx = \\frac{h}{2} d\\xi$。将此代入积分 $I_h$ 中，得到：\n$$\nI_{h} = \\int_{-1}^{1} R\\left(\\frac{h}{2}\\xi + x_{c}\\right) \\frac{h}{2} \\, d\\xi\n$$\n让我们定义一个新函数 $f(\\xi)$，对应于参考区间上的被积函数：\n$$\nf(\\xi) \\equiv \\frac{h}{2} R\\left(\\frac{h}{2}\\xi + x_{c}\\right)\n$$\n该积分现在表示为 $I_h = \\int_{-1}^1 f(\\xi) d\\xi$。$I_h$ 的求积误差与将 $p$ 点高斯-勒让德法则应用于 $[-1, 1]$ 上的 $f(\\xi)$ 的误差相同。\n\n对于定义在 $[-1, 1]$ 上的函数 $f(\\xi)$，假设 $f \\in C^{2p}([-1,1])$，其 $p$ 点高斯-勒让德求积的误差 $E_p[f]$ 的标准公式由下式给出：\n$$\nE_p[f] = \\frac{2^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} f^{(2p)}(\\eta)\n$$\n其中 $\\eta \\in (-1, 1)$。这里，$f^{(2p)}(\\eta)$ 表示 $f$ 关于 $\\xi$ 的 $2p$ 阶导数在 $\\eta$ 点的值。\n\n为应用此公式，我们必须计算我们特定函数 $f(\\xi)$ 的 $2p$ 阶导数。我们使用微分的链式法则。令 $R^{(k)}(x)$ 表示 $\\frac{d^k R}{dx^k}$。\n$$\n\\frac{d}{d\\xi} = \\frac{dx}{d\\xi} \\frac{d}{dx} = \\frac{h}{2} \\frac{d}{dx}\n$$\n将此算子应用于 $f(\\xi)$ $2p$ 次：\n$$\nf^{(2p)}(\\xi) = \\frac{d^{2p}}{d\\xi^{2p}} f(\\xi) = \\frac{d^{2p}}{d\\xi^{2p}} \\left[ \\frac{h}{2} R(x(\\xi)) \\right] = \\frac{h}{2} \\left(\\frac{h}{2}\\right)^{2p} R^{(2p)}(x(\\xi)) = \\left(\\frac{h}{2}\\right)^{2p+1} R^{(2p)}(x(\\xi))\n$$\n现在，我们将 $f^{(2p)}(\\xi)$ 的这个表达式代入误差公式：\n$$\nE_p[f] = \\frac{2^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} \\left[ \\left(\\frac{h}{2}\\right)^{2p+1} R^{(2p)}(x(\\eta)) \\right]\n$$\n通过合并 $2$ 的幂来简化表达式：\n$$\nE_p[f] = \\frac{2^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} \\frac{h^{2p+1}}{2^{2p+1}} R^{(2p)}(x(\\eta)) = \\frac{h^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} R^{(2p)}(x(\\eta))\n$$\n值 $\\zeta = x(\\eta)$ 是原始积分区间 $(x_{c}-h/2, x_{c}+h/2)$ 内的一点。因此，$I_h$ 的求积误差，我们记作 $E_h$，为：\n$$\nE_h = \\frac{h^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} R^{(2p)}(\\zeta)\n$$\n问题要求绝对求积误差 $|E_h|$ 的一个上界。取两边的绝对值：\n$$\n|E_h| = \\left| \\frac{h^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} R^{(2p)}(\\zeta) \\right| = \\frac{h^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} \\left| R^{(2p)}(\\zeta) \\right|\n$$\n问题给出了 $R$ 的 $2p$ 阶导数在元上的大小的界：\n$$\nM_{2p} \\equiv \\max_{x \\in [x_{c}-h/2,\\, x_{c}+h/2]} \\left| \\frac{d^{2p} R(x)}{dx^{2p}} \\right|\n$$\n由于 $\\zeta$ 位于此区间内，我们有 $\\left| R^{(2p)}(\\zeta) \\right| \\le M_{2p}$。\n将此代入 $|E_h|$ 的表达式，得到所需的上界：\n$$\n|E_h| \\le \\frac{h^{2p+1}(p!)^4}{(2p+1)\\left((2p)!\\right)^3} M_{2p}\n$$\n问题要求的是边界表达式本身。", "answer": "$$\n\\boxed{\\frac{h^{2p+1} (p!)^4}{(2p+1)\\left((2p)!\\right)^3} M_{2p}}\n$$", "id": "3348057"}]}