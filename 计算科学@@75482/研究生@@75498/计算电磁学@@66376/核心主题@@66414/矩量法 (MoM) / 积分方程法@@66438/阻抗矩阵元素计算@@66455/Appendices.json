{"hands_on_practices": [{"introduction": "在计算电磁学中，将连续的积分方程转化为离散的矩阵系统是矩量法 (Method of Moments, MoM) 的核心。本练习将指导您完成这一基本过程，专注于一个典型的一维问题：细直导线。通过为脉冲基函数和伽辽金测试实现一个数值积分程序，您将亲手实践如何计算阻抗矩阵元，并学习如何通过正则化处理积分核中的奇异性，这是任何矩量法代码开发的第一步 [@problem_id:3317567]。", "problem": "考虑一根位于自由空间中、与 $x$ 轴对齐的、半径为 $a$ 的有限长完美导电细直导线。在使用矩量法 (MoM) 求解的电场积分方程 (EFIE) 中，使用脉冲（分段常数）基函数和伽辽金测试法来构建阻抗矩阵。我们只关注磁矢量势对 EFIE 算子的贡献，并忽略标量势项。\n\n从第一性原理出发，使用麦克斯韦方程组和自由空间标量格林函数，推导并计算两个脉冲基函数之间的伽辽金阻抗矩阵元素中磁矢量势的贡献，这两个基函数分别支撑在导线的段 $\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$ 和 $\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$ 上。假设导线的有限半径通过将欧几里得距离替换为 $R(x,x') = \\sqrt{(x - x')^2 + a^2}$ 来正则化轴上奇点。自由空间标量格林函数为 $G(R) = \\dfrac{e^{-j k R}}{4\\pi R}$，其中 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$，$\\omega = 2\\pi f$，$\\mu_0$ 是真空磁导率，$\\epsilon_0$ 是真空介电常数。磁矢量势部分的伽辽金阻抗矩阵元素为\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x.\n$$\n所有长度必须以米为单位，频率以赫兹为单位，输出的阻抗值以欧姆为单位。\n\n您的任务是实现一个完整的、自包含的程序，对于指定的测试套件，使用高阶张量积高斯求积法在两个线段上数值计算 $Z_{mn}^{(A)}$ 的实部，并采用给定的正则化 $R(x,x') = \\sqrt{(x-x')^2 + a^2}$。数值积分必须直接在二重积分上执行，不得进行解析简化。程序应设计为能够通过适当选择足够的求积阶数来稳健地处理近奇异配置（例如，重叠或相邻的线段）。\n\n使用以下物理常数：$\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$ 和 $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\,\\mathrm{F/m}$。对于每个测试用例，波数为 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0}$，其中 $\\omega = 2\\pi f$。虚数单位为 $j = \\sqrt{-1}$。\n\n实现程序以处理以下测试套件。每个测试用例是一个元组 $(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$：\n- 测试 1（自作用项，中等频率，中等半径）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n- 测试 2（带有小间隙的相邻段）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.05,\\; 0.0,\\; 0.001,\\; 0.051)$\n- 测试 3（远距离分离的段）：$(300\\times 10^6,\\; 1\\times 10^{-3},\\; -0.025,\\; 0.025,\\; 0.975,\\; 1.025)$\n- 测试 4（准静态状态，半径较小）：$(1\\times 10^3,\\; 1\\times 10^{-4},\\; -0.025,\\; 0.025,\\; -0.025,\\; 0.025)$\n\n对于每个测试用例，计算 $Z_{mn}^{(A)}$ 的实部，并以欧姆表示。您的程序必须输出一行，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序列出测试用例的结果，每个结果四舍五入到 6 位小数，例如 $[z_1,z_2,z_3,z_4]$，其中每个 $z_i$ 是测试 $i$ 的 $Z_{mn}^{(A)}$ 的实部（单位为欧姆）。\n\n您的解决方案必须仅依赖于对给定二重积分使用指定正则化进行的数值评估。该算法必须是通用的，并适用于任何线段对和任何正频率。不要使用外部文件或用户输入。最终的程序必须能够直接运行。", "solution": "用户提供的问题已经过分析和验证。这是一个计算电磁学中提法正确、有科学依据的问题。所有必要的参数和定义都已提供，不存在不一致或模糊之处。因此，我们可以进行完整的解答。\n\n主要目标是计算阻抗矩阵元素 $Z_{mn}^{(A)}$ 的实部，该元素源于细导线电场积分方程 (EFIE) 的矩量法 (MoM) 解中磁矢量势的贡献。问题指定使用脉冲基函数和伽辽金测试法。\n\n阻抗元素的表达式如下：\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 \\int_{\\Gamma_m} \\int_{\\Gamma_n} G\\!\\left(R(x,x')\\right)\\, \\mathrm{d}x' \\,\\mathrm{d}x\n$$\n其中 $j = \\sqrt{-1}$ 是虚数单位，$\\omega$ 是角频率，$\\mu_0$ 是真空磁导率。积分域是导线段 $\\Gamma_m = [x_m^{(1)}, x_m^{(2)}]$ 和 $\\Gamma_n = [x_n^{(1)}, x_n^{(2)}]$。\n\n积分的核是自由空间标量格林函数 $G(R) = \\frac{e^{-j k R}}{4\\pi R}$，在正则化距离 $R(x,x') = \\sqrt{(x - x')^2 + a^2}$ 处求值。这里，$a$ 是导线半径，$k = \\omega/c_0$ 是自由空间波数，$c_0 = 1/\\sqrt{\\mu_0 \\epsilon_0}$ 是真空中的光速。\n\n为求 $Z_{mn}^{(A)}$ 的实部，我们首先代入格林函数并使用欧拉公式 $e^{-j\\theta} = \\cos(\\theta) - j\\sin(\\theta)$：\n$$\nG(R) = \\frac{\\cos(k R) - j \\sin(k R)}{4\\pi R}\n$$\n该二重积分可以分解为实部和虚部：\n$$\nI_{mn} = \\int_{\\Gamma_m} \\int_{\\Gamma_n} G(R) \\, \\mathrm{d}x' \\, \\mathrm{d}x = \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\cos(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x - j \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\n设该积分的实部为 $I_{Re}$，虚部为 $I_{Im}$。则 $I_{mn} = I_{Re} + j I_{Im}$，其中：\n$$\nI_{Im} = - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\n将此代回 $Z_{mn}^{(A)}$ 的表达式中：\n$$\nZ_{mn}^{(A)} = j \\,\\omega \\,\\mu_0 (I_{Re} + j I_{Im}) = j\\,\\omega\\,\\mu_0 I_{Re} + j^2\\,\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 I_{Im} + j\\,\\omega\\,\\mu_0 I_{Re}\n$$\n$Z_{mn}^{(A)}$ 的实部因此为：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = -\\omega\\,\\mu_0 I_{Im} = -\\omega\\,\\mu_0 \\left( - \\int_{\\Gamma_m} \\int_{\\Gamma_n} \\frac{\\sin(kR)}{4\\pi R} \\, \\mathrm{d}x' \\, \\mathrm{d}x \\right)\n$$\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0}{4\\pi} \\int_{x_m^{(1)}}^{x_m^{(2)}} \\int_{x_n^{(1)}}^{x_n^{(2)}} \\frac{\\sin(k \\sqrt{(x-x')^2 + a^2})}{\\sqrt{(x-x')^2 + a^2}} \\, \\mathrm{d}x' \\, \\mathrm{d}x\n$$\n这就是需要进行数值计算的最终积分。被积函数是一个缩放的 sinc 函数 $\\mathrm{sinc}(kR) = \\sin(kR)/(kR)$，其性质良好。使用半径 $a > 0$ 进行的正则化确保了分母 $R$ 永远不为零，从而避免了奇点。\n\n问题要求使用张量积高斯求积法进行数值评估。该方法将规范区间 $[-1, 1]$ 上的定积分近似为一个加权和：\n$$\n\\int_{-1}^{1} f(u) \\, \\mathrm{d}u \\approx \\sum_{i=1}^{N} w_i f(u_i)\n$$\n其中 $u_i$ 是求积节点（$N$ 阶勒让德多项式的根），$w_i$ 是相应的权重。为了将其应用于我们任意的积分区间，我们对每个积分执行线性变量替换。\n\n对于外部积分，变量 $x$ 的范围是 $[x_m^{(1)}, x_m^{(2)}]$：\n令 $x = x_m^{(c)} + u h_m$，其中 $x_m^{(c)} = \\frac{x_m^{(1)} + x_m^{(2)}}{2}$ 是区间 $\\Gamma_m$ 的中心，$h_m = \\frac{x_m^{(2)} - x_m^{(1)}}{2}$ 是其半宽。则 $\\mathrm{d}x = h_m \\mathrm{d}u$，其中 $u \\in [-1,1]$。\n\n对于内部积分，变量 $x'$ 的范围是 $[x_n^{(1)}, x_n^{(2)}]$：\n类似地，令 $x' = x_n^{(c)} + v h_n$，其中 $x_n^{(c)} = \\frac{x_n^{(1)} + x_n^{(2)}}{2}$，$h_n = \\frac{x_n^{(2)} - x_n^{(1)}}{2}$。则 $\\mathrm{d}x' = h_n \\mathrm{d}v$，其中 $v \\in [-1,1]$。\n\n二重积分变换为：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} = \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\int_{-1}^{1} \\int_{-1}^{1} \\frac{\\sin(k R(u,v))}{R(u,v)} \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\n其中 $R(u,v) = \\sqrt{((x_m^{(c)} + u h_m) - (x_n^{(c)} + v h_n))^2 + a^2}$。\n\n对每个维度应用具有 $N$ 个点的张量积高斯求积法则，我们得到数值近似：\n$$\n\\mathrm{Re}\\{Z_{mn}^{(A)}\\} \\approx \\frac{\\omega \\mu_0 h_m h_n}{4\\pi} \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\frac{\\sin(k R_{ij})}{R_{ij}}\n$$\n其中 $u_i$ 和 $v_j$ 是求积节点，$w_i$ 和 $w_j$ 是权重，$R_{ij}$ 是距离 $R(u_i,v_j)$。对于伽辽金测试法，基函数和测试函数的域通常是相同的，但此公式是通用的。\n\n选择高求积阶数 $N$ 以确保准确性，特别是对于自作用项（其中 $\\Gamma_m = \\Gamma_n$）或相邻段，因为此时被积函数在 $x=x'$ 附近变得更尖锐。对于指定的测试用例，取值 $N=96$ 是稳健的。\n\n实现中将定义一个函数来执行此计算。物理常数 $\\mu_0$ 和 $\\epsilon_0$ 用于计算 $c_0$ 和 $k$。对于每个测试用例，参数 $(f, a, x_m^{(1)}, x_m^{(2)}, x_n^{(1)}, x_n^{(2)})$ 会传递给此函数。最终结果被收集、格式化为 6 位小数并打印。为保证数值稳定性，建议使用 `numpy.sinc`，注意其定义要求将参数除以 $\\pi$。表达式 $\\sin(y)/y$ 等效于 `numpy.sinc(y/numpy.pi)`。因此，被积函数可以写成 $k \\times \\mathrm{numpy.sinc}(kR/\\pi)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically evaluating the impedance matrix elements\n    for the provided test cases.\n    \"\"\"\n\n    # Physical constants as specified in the problem\n    MU_0 = 4 * np.pi * 1e-7\n    EPSILON_0 = 8.854187817e-12\n    C_0 = 1 / np.sqrt(MU_0 * EPSILON_0)\n\n    def evaluate_z_mn_a_real(f, a, xm1, xm2, xn1, xn2, n_quad):\n        \"\"\"\n        Calculates the real part of Z_mn^(A) using tensor-product Gaussian quadrature.\n        \n        Args:\n            f (float): Frequency in Hertz.\n            a (float): Wire radius in meters.\n            xm1 (float): Start of segment m in meters.\n            xm2 (float): End of segment m in meters.\n            xn1 (float): Start of segment n in meters.\n            xn2 (float): End of segment n in meters.\n            n_quad (int): Order of Gaussian quadrature.\n            \n        Returns:\n            float: The real part of the impedance element Z_mn^(A) in Ohms.\n        \"\"\"\n        omega = 2 * np.pi * f\n        k = omega / C_0\n\n        # Get Gauss-Legendre nodes and weights for the interval [-1, 1]\n        nodes, weights = roots_legendre(n_quad)\n\n        # Calculate interval centers and half-widths for the change of variables\n        xm_c = (xm1 + xm2) / 2.0\n        hm = (xm2 - xm1) / 2.0\n        xn_c = (xn1 + xn2) / 2.0\n        hn = (xn2 - xn1) / 2.0\n\n        # Handle zero-length segments\n        if hm == 0 or hn == 0:\n            return 0.0\n\n        # Map nodes from [-1, 1] to the physical segment intervals [xm1, xm2] and [xn1, xn2]\n        x_nodes = xm_c + nodes * hm\n        xp_nodes = xn_c + nodes * hn\n\n        # Perform 2D numerical integration using the tensor-product rule\n        integral_sum = 0.0\n        for i in range(n_quad):\n            for j in range(n_quad):\n                x = x_nodes[i]\n                xp = xp_nodes[j]\n                wi = weights[i]\n                wj = weights[j]\n\n                # Calculate the regularized distance R(x, x')\n                dx_sq = (x - xp)**2\n                R = np.sqrt(dx_sq + a**2)\n                \n                # Evaluate the integrand sin(k*R)/R.\n                # This formulation is numerically stable for small R because a > 0.\n                # For enhanced stability, one could use k * np.sinc(k * R / np.pi)\n                # but direct division is fine here since R is never zero.\n                if R == 0.0:\n                    # This case does not occur since a > 0, but as a safeguard.\n                    # The limit of sin(k*R)/R as R->0 is k.\n                    integrand = k\n                else:\n                    integrand = np.sin(k * R) / R\n\n                integral_sum += wi * wj * integrand\n\n        # Combine terms to get the final result\n        prefactor = (omega * MU_0) / (4 * np.pi)\n        result = prefactor * hm * hn * integral_sum\n        return result\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        # (f, a, x_m^(1), x_m^(2), x_n^(1), x_n^(2))\n        (300e6, 1e-3, -0.025, 0.025, -0.025, 0.025),\n        (300e6, 1e-3, -0.05, 0.0, 0.001, 0.051),\n        (300e6, 1e-3, -0.025, 0.025, 0.975, 1.025),\n        (1e3, 1e-4, -0.025, 0.025, -0.025, 0.025),\n    ]\n\n    # A high quadrature order is chosen for accuracy, especially for self-terms\n    # and near-singular configurations.\n    N_QUAD = 96\n    \n    results = []\n    for case in test_cases:\n        z_real = evaluate_z_mn_a_real(*case, n_quad=N_QUAD)\n        results.append(f\"{z_real:.6f}\")\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3317567"}, {"introduction": "在掌握了阻抗矩阵元的基本数值计算之后，我们深入探讨其背后的理论基础，特别是奇异积分算子的处理。本练习要求您从第一性原理出发，解析地计算组合场积分方程 (Combined Field Integral Equation, CFIE) 中由磁场积分方程 (Magnetic Field Integral Equation, MFIE) 贡献的奇异项。通过应用奇异边界积分算子的跳跃关系，您将揭示MFIE的自作用项是如何产生的，这对于理解和构建稳定的积分方程至关重要 [@problem_id:3317565]。", "problem": "考虑一个理想电导体（PEC）光滑闭合表面，该表面由两个共享一条公共边的相同等边平面三角形离散化，边长为 $s$。在这两个三角形上使用单个 Rao–Wilton–Glisson (RWG) 基函数 $\\mathbf{f}$，并采用与该 RWG 函数相同的 Galerkin 测试方案。假设自由空间的介电常数为 $\\varepsilon$，磁导率为 $\\mu$，波数为 $k$，波阻抗为 $\\eta = \\sqrt{\\mu/\\varepsilon}$。组合场积分方程（CFIE）由电场积分方程（EFIE）和磁场积分方程（MFIE）通过参数 $\\alpha \\in (0,1)$ 的凸组合构成，因此作用于表面电流密度 $\\mathbf{J}$ 的 CFIE 算子为 $\\,\\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}\\,$。\n\n从时谐麦克斯韦方程组 $\\,\\nabla \\times \\mathbf{E} = i \\omega \\mu \\mathbf{H}\\,$ 和 $\\,\\nabla \\times \\mathbf{H} = -i \\omega \\varepsilon \\mathbf{E}\\,$、自由空间格林函数 $\\,G(\\mathbf{r},\\mathbf{r}')=\\exp(i k |\\mathbf{r}-\\mathbf{r}'|)/(4\\pi |\\mathbf{r}-\\mathbf{r}'|)\\,$、以及由表面电流片引起的散射磁场的边界积分表示出发，利用光滑闭合表面上奇异边界积分算子的正则跳跃关系，来确定 MFIE 的主值贡献。然后，在假设双三角形支撑域上的局部曲率可以忽略不计（从而平面 RWG 几何有效）的情况下，计算与 $\\mathbf{f}$ 相关的 CFIE 对角阻抗矩阵元素 $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ 的奇异 MFIE 贡献，该贡献通过 Galerkin 双线性形式 $\\,\\langle \\mathbf{f}, \\cdot \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot (\\cdot)\\, \\mathrm{d}S\\,$ 表示。\n\n为了进行计算，使用等边三角形对上的标准 RWG 定义：在自由顶点位于 $\\mathbf{r}^{+}$ 的“正”三角形 $T^{+}$ 上，设 $\\,\\mathbf{f}(\\mathbf{r}) = \\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{+}(\\mathbf{r})\\,$；在自由顶点位于 $\\mathbf{r}^{-}$ 的“负”三角形 $T^{-}$ 上，设 $\\,\\mathbf{f}(\\mathbf{r}) = -\\dfrac{\\ell}{2 A}\\, \\boldsymbol{\\rho}^{-}(\\mathbf{r})\\,$。其中 $\\,\\ell=s\\,$ 是公共边长，$\\,A=\\dfrac{\\sqrt{3}}{4}s^{2}\\,$ 是三角形面积，$\\,\\boldsymbol{\\rho}^{\\pm}(\\mathbf{r})$ 是从自由顶点到点 $\\mathbf{r}$ 的三角形内向量。用 $\\,\\mathbf{r}(u,v)=u\\,\\mathbf{a}+v\\,\\mathbf{b}\\,$ 参数化每个等边三角形，其中 $\\,u\\ge 0\\,$, $\\,v\\ge 0\\,$, $\\,u+v\\le 1\\,$，且 $\\,\\mathbf{a}\\,$ 和 $\\,\\mathbf{b}\\,$ 是长度为 $\\,|\\mathbf{a}|=|\\mathbf{b}|=s\\,$、夹角为 $\\,60^{\\circ}\\,$ 的边向量。面积元满足 $\\,\\mathrm{d}S = |\\mathbf{a}\\times \\mathbf{b}|\\, \\mathrm{d}u\\,\\mathrm{d}v\\,$，其中 $\\,|\\mathbf{a}\\times \\mathbf{b}| = \\dfrac{\\sqrt{3}}{2}s^{2}\\,$。\n\n以 $\\,\\alpha\\,$, $\\,\\eta\\,$ 和 $\\,s\\,$ 的形式，给出 $\\,Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}\\,$ 的闭式解析表达式。最终表达式中不需要进行数值取整，也不应包含物理单位。", "solution": "该问题要求使用带有 Rao-Wilton-Glisson (RWG) 基函数的 Galerkin 方案，计算磁场积分方程 (MFIE) 对组合场积分方程 (CFIE) 对角阻抗矩阵元素的奇异贡献。\n\n问题陈述已经过验证，被认为是具有科学依据、适定且客观的。所有提供的定义和参数均与计算电磁学领域的标准文献一致。\n\n作用于表面电流密度 $\\mathbf{J}$ 的 CFIE 算子为 $\\mathcal{L}_{\\mathrm{CFIE}} = \\alpha\\,\\mathcal{T}_{\\mathrm{E}} + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}$，其中 $\\mathcal{T}_{\\mathrm{E}}$ 和 $\\mathcal{T}_{\\mathrm{M}}$ 分别是电场和磁场积分方程算子，$\\alpha \\in (0,1)$ 是一个组合参数，$\\eta$ 是介质的波阻抗。\n\n在基于 Galerkin 的矩量法 (MoM) 公式中，与基函数 $\\mathbf{f}$ 相关的对角阻抗元素 $Z$ 由内积给出：\n$$Z = \\langle \\mathbf{f}, \\mathcal{L}_{\\mathrm{CFIE}}(\\mathbf{f}) \\rangle = \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\left[ \\alpha\\,\\mathcal{T}_{\\mathrm{E}}(\\mathbf{f})(\\mathbf{r}) + (1-\\alpha)\\,\\eta\\,\\mathcal{T}_{\\mathrm{M}}(\\mathbf{f})(\\mathbf{r}) \\right] \\mathrm{d}S$$\n问题要求我们找出该表达式中由 MFIE 部分产生的奇异贡献。MFIE 算子将表面电流密度 $\\mathbf{J}$ 与入射磁场联系起来。其公式涉及一个核函数是奇异的积分算子。该算子在表面上的行为由跳跃条件描述。点 $\\mathbf{r}$ 处的散射磁场 $\\mathbf{H}^s$ 由 $\\mathbf{H}^s(\\mathbf{r}) = \\nabla \\times \\int_S \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') \\mathrm{d}S'$ 给出，其中 $G$ 是自由空间格林函数。该场在表面 $S$ 上的切向分量的跳跃条件产生了一个局部项和一个主值 (P.V.) 积分。作用于电流 $\\mathbf{J}$ 的 MFIE 算子可以表示为：\n$$\\mathcal{T}_{\\mathrm{M}}(\\mathbf{J})(\\mathbf{r}) = \\frac{1}{2}\\mathbf{J}(\\mathbf{r}) + \\mathbf{\\hat{n}}(\\mathbf{r}) \\times \\mathrm{P.V.} \\int_S \\nabla G(\\mathbf{r}, \\mathbf{r}') \\times \\mathbf{J}(\\mathbf{r}') \\mathrm{d}S'$$\n项 $\\frac{1}{2}\\mathbf{J}(\\mathbf{r})$ 是由格林函数核的奇异性产生的局部非积分贡献。这就是由跳跃关系分离出的“主值贡献”，也是问题要求我们计算的。另一项，柯西主值积分，计算量大但为弱奇异，在此背景下不被视为“奇异贡献”的一部分。EFIE 算子 $\\mathcal{T}_{\\mathrm{E}}$ 涉及更强的（超奇异）奇异性，其处理方式不同，也不是这里的重点。\n\n因此，对 CFIE 算子的奇异贡献为 $\\mathcal{L}_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = (1-\\alpha)\\eta\\,\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}$，其中 $\\mathcal{T}_{\\mathrm{M}}^{\\mathrm{(sing)}}(\\mathbf{f}) = \\frac{1}{2}\\mathbf{f}$。\n对角阻抗元素 $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ 对应的奇异贡献为：\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\left\\langle \\mathbf{f}, (1-\\alpha)\\eta \\left(\\frac{1}{2}\\mathbf{f}\\right) \\right\\rangle = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} \\mathbf{f}(\\mathbf{r}) \\cdot \\mathbf{f}(\\mathbf{r}) \\, \\mathrm{d}S = \\frac{1}{2}(1-\\alpha)\\eta \\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\n该积分是在 $\\mathbf{f}$ 的支撑域上进行的，该支撑域由两个相邻的等边三角形 $T^{+}$ 和 $T^{-}$ 组成。由于基函数在两个相同三角形上的定义具有对称性，整个支撑域上的积分是单个三角形上积分的两倍：\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S + \\int_{T^{-}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\n在“正”三角形 $T^{+}$ 上的 RWG 基函数定义为 $\\mathbf{f}(\\mathbf{r}) = \\frac{\\ell}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r})$，其中 $\\ell=s$ 是边长， $A=\\frac{\\sqrt{3}}{4}s^2$ 是单个三角形的面积，$\\boldsymbol{\\rho}^{+}(\\mathbf{r}) = \\mathbf{r} - \\mathbf{r}^{+}$ 是从自由顶点 $\\mathbf{r}^{+}$ 到点 $\\mathbf{r} \\in T^{+}$ 的位置向量。\n在 $T^{+}$ 上的积分变为：\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{T^{+}} \\left| \\frac{s}{2A} \\boldsymbol{\\rho}^{+}(\\mathbf{r}) \\right|^2 \\, \\mathrm{d}S = \\left(\\frac{s}{2A}\\right)^2 \\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$$\n积分 $\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S$ 是三角形区域 $T^{+}$ 关于其自由顶点的极转动惯量，假设均匀质量密度为 $1$。我们可以通过参数化三角形来计算它。设自由顶点 $\\mathbf{r}^{+}$ 位于原点。其他顶点由长度为 $s$、夹角为 $60^{\\circ}$ 的向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 定义。三角形中的一点 $\\mathbf{r}$ 为 $\\mathbf{r}(u,v) = u\\mathbf{a} + v\\mathbf{b}$，其中 $u \\ge 0, v \\ge 0, u+v \\le 1$。\n于是 $|\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 = |\\mathbf{r}|^2 = |u\\mathbf{a} + v\\mathbf{b}|^2 = u^2|\\mathbf{a}|^2 + v^2|\\mathbf{b}|^2 + 2uv(\\mathbf{a}\\cdot\\mathbf{b}) = s^2(u^2+v^2+uv)$。\n面积元为 $\\mathrm{d}S = |\\mathbf{a} \\times \\mathbf{b}| \\mathrm{d}u\\mathrm{d}v = s^2\\sin(60^{\\circ})\\mathrm{d}u\\mathrm{d}v = \\frac{\\sqrt{3}}{2}s^2 \\mathrm{d}u\\mathrm{d}v$。\n该积分为：\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\int_{u=0}^{1} \\int_{v=0}^{1-u} s^2(u^2+v^2+uv) \\left(\\frac{\\sqrt{3}}{2}s^2\\right) \\mathrm{d}v\\mathrm{d}u$$\n$$ = \\frac{\\sqrt{3}}{2}s^4 \\int_{u=0}^{1}\\int_{v=0}^{1-u} (u^2+v^2+uv) \\mathrm{d}v\\mathrm{d}u$$\n使用单位单纯形上的标准积分公式 $\\int_{0}^{1}\\int_{0}^{1-u} u^a v^b \\mathrm{d}v\\mathrm{d}u = \\frac{a!b!}{(a+b+2)!}$：\n$$\\int_{0}^{1}\\int_{0}^{1-u} u^2 \\mathrm{d}v\\mathrm{d}u = \\frac{2!0!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} v^2 \\mathrm{d}v\\mathrm{d}u = \\frac{0!2!}{4!} = \\frac{2}{24} = \\frac{1}{12}$$\n$$\\int_{0}^{1}\\int_{0}^{1-u} uv \\mathrm{d}v\\mathrm{d}u = \\frac{1!1!}{4!} = \\frac{1}{24}$$\n这些积分的和是 $\\frac{1}{12} + \\frac{1}{12} + \\frac{1}{24} = \\frac{2+2+1}{24} = \\frac{5}{24}$。\n因此，极转动惯量为：\n$$\\int_{T^{+}} |\\boldsymbol{\\rho}^{+}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\frac{\\sqrt{3}}{2}s^4 \\left(\\frac{5}{24}\\right) = \\frac{5\\sqrt{3}}{48}s^4$$\n现在我们将其代回。前置因子为：\n$$\\left(\\frac{s}{2A}\\right)^2 = \\left(\\frac{s}{2 \\cdot \\frac{\\sqrt{3}}{4}s^2}\\right)^2 = \\left(\\frac{s}{\\frac{\\sqrt{3}}{2}s^2}\\right)^2 = \\left(\\frac{2}{\\sqrt{3}s}\\right)^2 = \\frac{4}{3s^2}$$\n单个三角形上的积分为：\n$$\\int_{T^{+}} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = \\left(\\frac{4}{3s^2}\\right) \\left(\\frac{5\\sqrt{3}}{48}s^4\\right) = \\frac{20\\sqrt{3}}{144}s^2 = \\frac{5\\sqrt{3}}{36}s^2$$\n在支撑域 $S = T^{+} \\cup T^{-}$ 上的总积分为：\n$$\\int_{S} |\\mathbf{f}(\\mathbf{r})|^2 \\, \\mathrm{d}S = 2 \\times \\frac{5\\sqrt{3}}{36}s^2 = \\frac{5\\sqrt{3}}{18}s^2$$\n最后，我们可以计算 $Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}}$ 的值：\n$$Z_{\\mathrm{CFIE}}^{\\mathrm{(sing)}} = \\frac{1}{2}(1-\\alpha)\\eta \\left( \\frac{5\\sqrt{3}}{18}s^2 \\right) = \\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^2$$\n该表达式表示了 MFIE 算子对所求对角阻抗元素的奇异贡献。", "answer": "$$\n\\boxed{\\frac{5\\sqrt{3}}{36}(1-\\alpha)\\eta s^{2}}\n$$", "id": "3317565"}, {"introduction": "标准的数值积分方法在处理近奇异情况（例如两个贴近的单元）时会遇到精度瓶颈。本练习介绍了一种先进的解决方案：坐标伸展变换。您将通过实现一种为弱奇异积分量身定制的特殊求积法则，来处理两个平行方形板之间的相互作用。这项实践不仅能显著提高近场计算的准确性，还能让您深入理解如何通过巧妙的数学变换来克服数值计算中的挑战，这是开发高性能电磁仿真工具的关键策略之一 [@problem_id:3317563]。", "problem": "考虑三维自由空间中两个共轴、平行的方形板，边长为 $2a$。源板位于平面 $z=0$ 上，测试板位于平行平面 $z=\\delta$ 上，其中 $\\delta>0$ 是最小间隙距离。令 $\\mathbf{r}=(x,y,0)$ 和 $\\mathbf{r}'=(x',y',\\delta)$，其中 $(x,y)$ 和 $(x',y')$ 均在方形区域 $[-a,a]\\times[-a,a]$ 内变化。对于波数为 $k$（单位为弧度/米）的三维 Helmholtz 方程，自由空间标量 Green 函数为 $G_k(r)=\\exp(i k r)/(4\\pi r)$，其中 $r=\\|\\mathbf{r}-\\mathbf{r}'\\|$。在脉冲基、脉冲测试的矩量法阻抗矩阵元中，其代表性元素为双重面积分\n$$\nZ(a,\\delta,k) \\;=\\; \\iint_{S_t} \\iint_{S_s} G_k\\big(\\|\\mathbf{r}-\\mathbf{r}'\\|\\big)\\, dS_{\\mathbf{r}}\\, dS_{\\mathbf{r}'},\n$$\n其中 $S_t=S_s=[-a,a]\\times[-a,a]$。通过引入差分变量 $\\Delta x=x-x'$ 和 $\\Delta y=y-y'$，该积分可以写成一个加权卷积积分\n$$\nZ(a,\\delta,k) \\;=\\; \\int_{-2a}^{2a} \\int_{-2a}^{2a} \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big)\\, \\frac{e^{i k \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}}}{4\\pi \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}} \\, d\\Delta x\\, d\\Delta y.\n$$\n当 $\\delta\\to 0^+$ 时，其核是弱奇异的，即在 $\\rho=0$ 附近其行为类似于 $1/\\sqrt{\\rho^2+\\delta^2}$，其中 $\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}$。在 $[-2a,2a]\\times[-2a,2a]$ 上，一个没有坐标伸展的标准张量积 Gauss–Legendre 求积法，会因为在 $\\rho=0$ 附近分辨率不足，而在 $\\delta$ 很小时产生较大误差。为解决此问题，需要通过映射到一个与最小间隙方向对齐的伸展坐标系来建立一种求积法则，使用如下变换\n$$\n\\Delta x \\;=\\; s(\\xi) \\;=\\; \\frac{2a\\,\\sinh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\quad \\Delta y \\;=\\; s(\\eta) \\;=\\; \\frac{2a\\,\\sinh(\\gamma \\eta)}{\\sinh(\\gamma)}, \\quad \\xi,\\eta \\in [-1,1],\n$$\n其雅可比行列式为\n$$\n\\frac{d\\Delta x}{d\\xi} \\;=\\; \\frac{2a\\,\\gamma \\cosh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\qquad \\frac{d\\Delta y}{d\\eta} \\;=\\; \\frac{2a\\,\\gamma \\cosh(\\gamma \\eta)}{\\sinh(\\gamma)}.\n$$\n选择伸展参数为\n$$\n\\gamma \\;=\\; \\operatorname{asinh}\\left(\\frac{2a}{\\delta}\\right),\n$$\n这样，当 $\\delta\\to 0^+$ 时，$\\rho=0$ 附近的最小几何尺度在伸展坐标系中可以被均匀地解析。在 $(\\xi,\\eta)$ 中应用 $N$ 阶张量积 Gauss–Legendre 求积法，通过此映射来近似 $Z(a,\\delta,k)$。标准（未伸展）法则对应于仿射映射 $\\Delta x=2a\\,\\xi$, $\\Delta y=2a\\,\\eta$，其雅可比行列式为常数 $4a^2$。\n\n任务：\n- 从上面 $Z(a,\\delta,k)$ 的定义和加权差分变量公式出发，为指定的伸展变换推导在 $(\\xi,\\eta)$ 中的映射求积公式。您的推导必须基于 Green 函数的基本表达式和多重积分的变量替换定理。\n- 在固定求积阶数 $N$ 和固定板半尺寸 $a$ 的假设下，提供一个基于原理的推导，说明伸展法则求积的渐近误差相对于 $\\delta$ 和 $k$ 的标度关系。您的推导应解释为什么将坐标变换与最小间隙距离 $\\delta$ 对齐可以缓解弱奇异性，以及 $k$ 是如何通过 $e^{i k r}$ 的振荡影响分辨率要求的。\n- 实现上述的标准仿射求积法和伸展求积法，并通过与一个使用更高求积阶数 $N_{\\mathrm{ref}}$ 的伸展映射计算出的 $Z(a,\\delta,k)$ 的高精度参考近似值进行比较，来估计绝对求积误差。该积分需要进行数值计算；没有可用的闭合形式目标值。\n\n使用以下数值参数作为测试套件：\n- 板半尺寸：$a=0.5$ 米。\n- 求积阶数：标准仿射法则和伸展法则均为 $N=16$；高精度参考近似值为 $N_{\\mathrm{ref}}=80$。\n- 为在固定 $k$ 值下检验 $\\delta$ 的标度关系，使用 $\\delta \\in \\{10^{-1},\\,5\\times 10^{-2},\\,2.5\\times 10^{-2},\\,1.25\\times 10^{-2}\\}$ 米和 $k=10$ 弧度/米。\n- 为在固定 $\\delta$ 值下检验 $k$ 的标度关系，使用 $k \\in \\{1,\\,2,\\,5,\\,10\\}$ 弧度/米和 $\\delta=1.25\\times 10^{-2}$ 米。\n\n对于每组参数，计算：\n- 在固定 $k$ 值下，标准法则的绝对误差的 $\\log_{10}$ 值相对于 $\\log_{10}\\delta$ 的斜率 $s_{\\mathrm{std},\\delta}$（对上述 $\\delta$ 值进行线性回归）。\n- 在固定 $k$ 值下，伸展法则的绝对误差的 $\\log_{10}$ 值相对于 $\\log_{10}\\delta$ 的斜率 $s_{\\mathrm{str},\\delta}$（对上述 $\\delta$ 值进行线性回归）。\n- 在固定 $\\delta$ 值下，伸展法则的绝对误差的 $\\log_{10}$ 值相对于 $\\log_{10}k$ 的斜率 $s_{\\mathrm{str},k}$（对上述 $k$ 值进行线性回归）。\n- 在 $\\delta=1.25\\times 10^{-2}$ 米和 $k=10$ 弧度/米时的改进比 $R=\\mathcal{E}_{\\mathrm{std}}/\\mathcal{E}_{\\mathrm{str}}$，其中 $\\mathcal{E}_{\\mathrm{std}}$ 和 $\\mathcal{E}_{\\mathrm{str}}$ 分别是标准法则和伸展法则的绝对误差。\n\n所有物理长度必须以米为单位处理，波数以弧度/米为单位处理。绝对误差和斜率是无量纲的。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[s_{\\mathrm{std},\\delta}, s_{\\mathrm{str},\\delta}, s_{\\mathrm{str},k}, R]$。", "solution": "目标是使用两种不同的求积方案，数值计算两个平行、共轴方形板之间相互作用的阻抗矩阵元 $Z(a,\\delta,k)$，并分析它们的误差特性。该积分由下式给出\n$$\nZ(a,\\delta,k) = \\int_{-2a}^{2a} \\int_{-2a}^{2a} \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big)\\, \\frac{e^{i k \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}}}{4\\pi \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}} \\, d\\Delta x\\, d\\Delta y.\n$$\n对于较小的间隙距离 $\\delta$，该积分在数值计算上具有挑战性，因为其核在原点 $(\\Delta x, \\Delta y) = (0,0)$ 处表现出弱奇异性。我们将推导并比较一种标准的仿射张量积 Gauss-Legendre 求积法与一种基于坐标伸展变换的专门求积法，后者旨在缓解这种奇异性。\n\n**映射求积公式的推导**\n\n任务的核心是将积分从物理差分变量域 $(\\Delta x, \\Delta y) \\in [-2a, 2a] \\times [-2a, 2a]$ 变换到计算域 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$，在后者上可以应用标准的张量积 Gauss-Legendre 求积法。对于该计算域上的积分，$N$ 阶张量积求积近似的一般形式为\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} F(\\xi, \\eta) \\,d\\xi\\,d\\eta \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j F(\\xi_i, \\xi_j)\n$$\n其中 $(\\xi_i, w_i)$ 是 $[-1, 1]$ 上的 $N$ 个 Gauss-Legendre 节点和权重。\n\n将被积函数表示为\n$$\nI(\\Delta x, \\Delta y) = \\big(2a-|\\Delta x|\\big)\\big(2a-|\\Delta y|\\big) G_k\\big(\\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2}\\big),\n$$\n其中 $G_k(r) = e^{ikr}/(4\\pi r)$ 是自由空间 Green 函数。\n\n**1. 标准仿射求积法则**\n标准法则使用一个从计算域到物理域的简单仿射映射：\n$$\n\\Delta x = 2a\\,\\xi, \\qquad \\Delta y = 2a\\,\\eta.\n$$\n微分面积元根据映射的雅可比行列式进行变换：\n$$\nd\\Delta x\\,d\\Delta y = \\left|\\frac{\\partial(\\Delta x, \\Delta y)}{\\partial(\\xi, \\eta)}\\right| d\\xi\\,d\\eta = \\left(\\frac{d\\Delta x}{d\\xi}\\right) \\left(\\frac{d\\Delta y}{d\\eta}\\right) d\\xi\\,d\\eta = (2a)(2a)\\,d\\xi\\,d\\eta = 4a^2\\,d\\xi\\,d\\eta.\n$$\n将此代入 $Z(a,\\delta,k)$ 的积分中可得：\n$$\nZ_{\\mathrm{std}}(a,\\delta,k) = \\int_{-1}^{1}\\int_{-1}^{1} I(2a\\xi, 2a\\eta) \\cdot 4a^2 \\,d\\xi\\,d\\eta.\n$$\n应用 $N$ 阶 Gauss-Legendre 求积法则可得数值近似：\n$$\nZ_{\\mathrm{std}}(a,\\delta,k) \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\left[ \\big(2a-2a|\\xi_i|\\big)\\big(2a-2a|\\xi_j|\\big) \\frac{e^{i k r_{ij}}}{4\\pi r_{ij}} \\cdot 4a^2 \\right],\n$$\n其中 $r_{ij} = \\sqrt{(2a\\xi_i)^2+(2a\\xi_j)^2+\\delta^2}$。\n\n**2. 伸展求积法则**\n伸展法则采用非线性变换：\n$$\n\\Delta x = s(\\xi) = \\frac{2a\\,\\sinh(\\gamma \\xi)}{\\sinh(\\gamma)}, \\qquad \\Delta y = s(\\eta) = \\frac{2a\\,\\sinh(\\gamma \\eta)}{\\sinh(\\gamma)}.\n$$\n伸展参数选择为 $\\gamma = \\operatorname{asinh}(2a/\\delta)$。此变换的雅可比行列式由导数之积给出：\n$$\nJ(\\xi, \\eta) = \\frac{d\\Delta x}{d\\xi} \\frac{d\\Delta y}{d\\eta} = \\left(\\frac{2a\\,\\gamma \\cosh(\\gamma \\xi)}{\\sinh(\\gamma)}\\right) \\left(\\frac{2a\\,\\gamma \\cosh(\\gamma \\eta)}{\\sinh(\\gamma)}\\right) = \\left(\\frac{2a\\gamma}{\\sinh(\\gamma)}\\right)^2 \\cosh(\\gamma \\xi) \\cosh(\\gamma \\eta).\n$$\n$Z(a,\\delta,k)$ 的积分变换为：\n$$\nZ_{\\mathrm{str}}(a,\\delta,k) = \\int_{-1}^{1}\\int_{-1}^{1} I(s(\\xi), s(\\eta)) J(\\xi, \\eta) \\,d\\xi\\,d\\eta.\n$$\n则求积近似为：\n$$\nZ_{\\mathrm{str}}(a,\\delta,k) \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j \\left[ \\big(2a-|s(\\xi_i)|\\big)\\big(2a-|s(\\eta_j)|\\big) \\frac{e^{i k r_{ij}}}{4\\pi r_{ij}} J(\\xi_i, \\xi_j) \\right],\n$$\n其中 $r_{ij} = \\sqrt{s(\\xi_i)^2+s(\\eta_j)^2+\\delta^2}$。注意，由于 $\\sinh(t)$ 是一个奇函数，因此 $|s(t)| = s(|t|)$。\n\n**渐近误差标度分析**\n\nGauss-Legendre 求积的误差与被积函数高阶导数的幅度有关。当前问题中的挑战源于当 $\\delta \\to 0^+$ 时被积函数的行为。\n\n**关于 $\\delta$ 的误差标度**\n数值计算困难的来源是 $1/r = 1/\\sqrt{\\rho^2 + \\delta^2}$ 这一项，其中 $\\rho^2 = (\\Delta x)^2 + (\\Delta y)^2$。当 $\\delta \\to 0$ 时，该函数在 $\\rho=0$ 处形成一个尖峰，其特征宽度与 $\\delta$ 成正比。\n\n- **标准法则误差 ($s_{\\mathrm{std},\\delta}$)**：仿射映射在 $(\\Delta x, \\Delta y)$ 平面上均匀分布求积点（在考虑了 Gauss 节点在边界附近的自然聚集后）。随着 $\\delta$ 的减小，被积函数的尖峰变得比原点附近固定求积点之间的间距更窄。求积法则的固定阶多项式基无法准确表示这个日益尖锐的特征。因此，求积误差随着 $\\delta$ 的减小而增大。我们预期误差 $\\mathcal{E}_{\\mathrm{std}}$ 的标度关系类似 $\\delta^{\\alpha}$，其中 $\\alpha  0$，这导致负斜率 $s_{\\mathrm{std},\\delta} = d(\\log_{10}\\mathcal{E}_{\\mathrm{std}})/d(\\log_{10}\\delta)  0$。\n\n- **伸展法则误差 ($s_{\\mathrm{str},\\delta}$)**：伸展变换是专门为解决此问题而设计的。考虑在原点 $(\\xi, \\eta) \\to (0,0)$ 附近的行为。对于小自变量，$\\sinh(\\gamma t) \\approx \\gamma t$。由于 $\\gamma = \\operatorname{asinh}(2a/\\delta)$，我们有 $\\sinh(\\gamma) = 2a/\\delta$。变换变为：\n$$\n\\Delta x = s(\\xi) \\approx \\frac{2a(\\gamma \\xi)}{2a/\\delta} = \\delta\\gamma\\xi.\n$$\n类似地，$\\Delta y \\approx \\delta\\gamma\\eta$。那么原点附近的距离 $r$ 为\n$$\nr = \\sqrt{(\\Delta x)^2+(\\Delta y)^2+\\delta^2} \\approx \\sqrt{(\\delta\\gamma\\xi)^2+(\\delta\\gamma\\eta)^2+\\delta^2} = \\delta\\sqrt{\\gamma^2(\\xi^2+\\eta^2)+1}.\n$$\n关键的结果是分离参数 $\\delta$ 被从平方根中提了出来。剩余项 $\\sqrt{\\gamma^2(\\xi^2+\\eta^2)+1}$ 是 $(\\xi, \\eta)$ 的一个光滑函数，其形状取决于 $\\gamma$，但在 $\\delta\\to 0$ 时不具有奇异性。该映射有效地在物理空间中“放大”了原点，将更多的求积点分配给变化剧烈的区域。这使得被积函数在计算域 $(\\xi, \\eta)$ 中被正则化。因此，求积误差在很大程度上对 $\\delta$ 的值不敏感。因此我们预期误差斜率 $s_{\\mathrm{str},\\delta}$ 接近于零。\n\n**关于 $k$ 的误差标度 ($s_{\\mathrm{str},k}$)**\n波数 $k$ 控制着复指数项 $e^{ikr}$ 的振荡。这些振荡的空间频率与 $k$ 成正比。一个固定阶数 $N$ 的求积法则有固定数量的采样点。随着 $k$ 的增加，被积函数振荡得更快。当局部波长变得与求积点之间的间距相当或更小时，求积法则就无法再准确地捕捉函数的行为，导致误差迅速增加。对于振荡函数，基于多项式的求积误差通常随频率呈多项式增长。因此，我们预期误差 $\\mathcal{E}_{\\mathrm{str}}$ 会随着 $k$ 的增加而增加，从而产生一个正斜率 $s_{\\mathrm{str},k} = d(\\log_{10}\\mathcal{E}_{\\mathrm{str}})/d(\\log_{10}k)  0$。伸展变换不解决这些振荡问题；它是为解决 $\\rho=0$ 处的奇异性而设计的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the error of standard and stretched quadrature rules\n    for a Method of Moments impedance matrix element.\n    \"\"\"\n    \n    # ------------------ Parameters ------------------\n    a = 0.5  # Panel half-size in meters\n    N = 16   # Quadrature order for test rules\n    N_ref = 80 # Quadrature order for reference solution\n\n    # Parameter sweeps from the problem statement\n    # Delta-scaling test parameters\n    k_fixed_for_delta_sweep = 10.0\n    delta_vals = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2])\n    \n    # K-scaling test parameters\n    delta_fixed_for_k_sweep = 1.25e-2\n    k_vals = np.array([1.0, 2.0, 5.0, 10.0])\n\n    # Cache for Gauss-Legendre nodes and weights\n    _quad_cache = {}\n    def get_quad_points(order):\n        if order not in _quad_cache:\n            nodes, weights = roots_legendre(order)\n            _quad_cache[order] = (nodes, weights)\n        return _quad_cache[order]\n\n    # ------------------ Quadrature Implementation ------------------\n    def compute_Z(a_val, delta, k, order, use_stretching):\n        \"\"\"\n        Computes the impedance integral Z using tensor-product Gauss-Legendre quadrature.\n        \"\"\"\n        nodes, weights = get_quad_points(order)\n        z_integral = 0.0 + 0.0j\n\n        if use_stretching:\n            # Stretched coordinate transformation\n            if delta == 0:\n                gamma = np.inf\n                sinh_gamma = np.inf\n            else:\n                gamma = np.arcsinh(2.0 * a_val / delta)\n                sinh_gamma = np.sinh(gamma)\n            \n            for i in range(order):\n                xi = nodes[i]\n                wi = weights[i]\n                \n                sinh_gamma_xi = np.sinh(gamma * xi)\n                cosh_gamma_xi = np.cosh(gamma * xi)\n                \n                delta_x = 2.0 * a_val * sinh_gamma_xi / sinh_gamma\n                jacobian_x = 2.0 * a_val * gamma * cosh_gamma_xi / sinh_gamma\n                \n                for j in range(order):\n                    eta = nodes[j]\n                    wj = weights[j]\n                    \n                    sinh_gamma_eta = np.sinh(gamma * eta)\n                    cosh_gamma_eta = np.cosh(gamma * eta)\n\n                    delta_y = 2.0 * a_val * sinh_gamma_eta / sinh_gamma\n                    jacobian_y = 2.0 * a_val * gamma * cosh_gamma_eta / sinh_gamma\n                    \n                    r = np.sqrt(delta_x**2 + delta_y**2 + delta**2)\n                    \n                    if r == 0:\n                        continue # Integrand is singular, but this point has zero measure\n                    \n                    # Full integrand including transformation Jacobian\n                    weight_func = (2.0 * a_val - np.abs(delta_x)) * (2.0 * a_val - np.abs(delta_y))\n                    green_func = np.exp(1j * k * r) / (4.0 * np.pi * r)\n                    jacobian = jacobian_x * jacobian_y\n                    \n                    integrand_val = weight_func * green_func * jacobian\n                    z_integral += wi * wj * integrand_val\n        else:\n            # Standard affine transformation\n            jacobian = (2.0 * a_val)**2\n            for i in range(order):\n                xi = nodes[i]\n                wi = weights[i]\n                delta_x = 2.0 * a_val * xi\n                \n                for j in range(order):\n                    eta = nodes[j]\n                    wj = weights[j]\n                    delta_y = 2.0 * a_val * eta\n                    \n                    r = np.sqrt(delta_x**2 + delta_y**2 + delta**2)\n\n                    if r == 0:\n                        continue\n\n                    weight_func = (2.0 * a_val - np.abs(delta_x)) * (2.0 * a_val - np.abs(delta_y))\n                    green_func = np.exp(1j * k * r) / (4.0 * np.pi * r)\n                    \n                    integrand_val = weight_func * green_func * jacobian\n                    z_integral += wi * wj * integrand_val\n                    \n        return z_integral\n\n    # ------------------ Numerical Experiments ------------------\n\n    # 1. Delta-scaling analysis\n    log_delta = np.log10(delta_vals)\n    errors_std_delta_sweep = []\n    errors_str_delta_sweep = []\n\n    for delta in delta_vals:\n        z_ref = compute_Z(a, delta, k_fixed_for_delta_sweep, N_ref, use_stretching=True)\n        z_std = compute_Z(a, delta, k_fixed_for_delta_sweep, N, use_stretching=False)\n        z_str = compute_Z(a, delta, k_fixed_for_delta_sweep, N, use_stretching=True)\n        \n        errors_std_delta_sweep.append(np.abs(z_std - z_ref))\n        errors_str_delta_sweep.append(np.abs(z_str - z_ref))\n\n    log_errors_std = np.log10(errors_std_delta_sweep)\n    log_errors_str = np.log10(errors_str_delta_sweep)\n    \n    s_std_delta = np.polyfit(log_delta, log_errors_std, 1)[0]\n    s_str_delta = np.polyfit(log_delta, log_errors_str, 1)[0]\n    \n    # 2. K-scaling analysis\n    log_k = np.log10(k_vals)\n    errors_str_k_sweep = []\n\n    for k in k_vals:\n        z_ref = compute_Z(a, delta_fixed_for_k_sweep, k, N_ref, use_stretching=True)\n        z_str = compute_Z(a, delta_fixed_for_k_sweep, k, N, use_stretching=True)\n        \n        errors_str_k_sweep.append(np.abs(z_str - z_ref))\n        \n    log_errors_str_k = np.log10(errors_str_k_sweep)\n    s_str_k = np.polyfit(log_k, log_errors_str_k, 1)[0]\n    \n    # 3. Improvement ratio R\n    # These are the errors at delta=1.25e-2 and k=10, which is the last point in the delta sweep\n    error_std_at_endpoint = errors_std_delta_sweep[-1]\n    error_str_at_endpoint = errors_str_delta_sweep[-1]\n    \n    R = error_std_at_endpoint / error_str_at_endpoint\n    \n    # ------------------ Final Output ------------------\n    # The output must be a single line with the specified format.\n    print(f\"[{s_std_delta},{s_str_delta},{s_str_k},{R}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3317563"}]}