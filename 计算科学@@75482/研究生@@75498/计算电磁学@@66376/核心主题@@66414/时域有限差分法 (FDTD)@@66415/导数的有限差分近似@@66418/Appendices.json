{"hands_on_practices": [{"introduction": "在计算电磁学中，为了精确模拟波的传播并减少数值色散，常常需要使用高阶精度的差分格式。本练习将指导你通过泰勒级数展开，构造一个四阶精度的中心差分格式来逼近一阶导数。这个过程不仅是推导特定公式的练习，更是掌握利用待定系数法系统性地消除低阶误差项、构建任意高阶差分算子的核心技能 [@problem_id:3307345]。", "problem": "在计算电磁学中，麦克斯韦方程组旋度项中的空间导数通常使用有限差分法在均匀笛卡尔网格上进行离散化。为了减小时域有限差分 (FDTD) 方法中的数值色散，考虑使用仅在 $x \\pm h$ 和 $x \\pm 2h$ 处的网格采样点来近似一个足够光滑的标量场 $f$ 在点 $x$ 处的导数，其中 $h > 0$ 是均匀网格间距。\n\n从导数的定义和带余项的泰勒定理出发，构建一个由 $x \\pm h$ 和 $x \\pm 2h$ 处的采样值组成，并除以 $h$ 的反对称线性组合，用以近似 $f'(x)$。确定这些系数，使得近似在 $h$ 上达到四阶精度，即截断误差的量级为 $\\mathcal{O}(h^4)$。然后将得到的差分格式简化为单一的解析表达式，并通过显式级数展开验证其主截断误差项与 $h^4$ 成正比。\n\n请提供仅使用点 $x \\pm h$ 和 $x \\pm 2h$ 的 $f'(x)$ 的四阶中心差分近似的单一闭式解析表达式作为最终答案。", "solution": "该问题要求使用一组特定的网格点，构建一个用于一阶导数 $f'(x)$ 的四阶精度有限差分近似。求解过程始于对问题陈述的验证。该问题被认定为具有科学依据、适定且客观。这是一个数值分析中的标准问题，特别是在推导高阶有限差分格式的背景下，这些格式在求解麦克斯韦方程组的时域有限差分 (FDTD) 等方法中至关重要。所有必要条件均已提供，且不存在矛盾。因此，该问题是有效的，我们可以继续进行求解。\n\n令 $f'(x)$ 的近似记为 $D_h f(x)$。问题规定，该近似必须是在 $x \\pm h$ 和 $x \\pm 2h$ 处采样的函数值的反对称线性组合，再除以网格间距 $h$。这种结构可以写成：\n$$ D_h f(x) = \\frac{c_1 [f(x+h) - f(x-h)] + c_2 [f(x+2h) - f(x-2h)]}{h} $$\n其中 $c_1$ 和 $c_2$ 是待定系数。假设场 $f$ 足够光滑，这允许我们围绕点 $x$ 使用泰勒级数展开。\n\n我们将每个函数值在点 $x$ 附近进行泰勒级数展开：\n$$ f(x+kh) = f(x) + (kh)f'(x) + \\frac{(kh)^2}{2!}f''(x) + \\frac{(kh)^3}{3!}f'''(x) + \\frac{(kh)^4}{4!}f^{(4)}(x) + \\frac{(kh)^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^6) $$\n$$ f(x-kh) = f(x) - (kh)f'(x) + \\frac{(kh)^2}{2!}f''(x) - \\frac{(kh)^3}{3!}f'''(x) + \\frac{(kh)^4}{4!}f^{(4)}(x) - \\frac{(kh)^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^6) $$\n将这两个展开式相减，我们得到中心差分的一般公式：\n$$ f(x+kh) - f(x-kh) = 2(kh)f'(x) + \\frac{2(kh)^3}{3!}f'''(x) + \\frac{2(kh)^5}{5!}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n对于包含 $x \\pm h$ 的项，我们令 $k=1$：\n$$ f(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{6}f'''(x) + \\frac{2h^5}{120}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n$$ f(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f'''(x) + \\frac{h^5}{60}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n对于包含 $x \\pm 2h$ 的项，我们令 $k=2$：\n$$ f(x+2h) - f(x-2h) = 2(2h)f'(x) + \\frac{2(2h)^3}{6}f'''(x) + \\frac{2(2h)^5}{120}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n$$ f(x+2h) - f(x-2h) = 4hf'(x) + \\frac{16h^3}{6}f'''(x) + \\frac{64h^5}{120}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n$$ f(x+2h) - f(x-2h) = 4hf'(x) + \\frac{8h^3}{3}f'''(x) + \\frac{8h^5}{15}f^{(5)}(x) + \\mathcal{O}(h^7) $$\n现在，我们将这些表达式代回 $D_h f(x)$ 的公式中：\n$$ D_h f(x) = \\frac{c_1}{h} \\left( 2hf'(x) + \\frac{h^3}{3}f'''(x) + \\frac{h^5}{60}f^{(5)}(x) + \\dots \\right) + \\frac{c_2}{h} \\left( 4hf'(x) + \\frac{8h^3}{3}f'''(x) + \\frac{8h^5}{15}f^{(5)}(x) + \\dots \\right) $$\n除以 $h$ 并根据 $f(x)$ 的导数阶数收集项：\n$$ D_h f(x) = (2c_1 + 4c_2)f'(x) + \\left(\\frac{c_1}{3} + \\frac{8c_2}{3}\\right)h^2 f'''(x) + \\left(\\frac{c_1}{60} + \\frac{8c_2}{15}\\right)h^4 f^{(5)}(x) + \\mathcal{O}(h^6) $$\n为了实现四阶精度，我们要求该近似对阶数最高为4的多项式是精确的。这转化为对系数的以下条件。\n首先，为使近似与 $f'(x)$ 一致， $f'(x)$ 的系数必须为1：\n$$ 2c_1 + 4c_2 = 1 $$\n其次，为达到高于二阶的精度， $h^2 f'''(x)$ 项的系数必须为零，从而消除标准中心差分的主误差项：\n$$ \\frac{c_1}{3} + \\frac{8c_2}{3} = 0 \\implies c_1 + 8c_2 = 0 \\implies c_1 = -8c_2 $$\n我们现在求解这个关于 $c_1$ 和 $c_2$ 的二元线性方程组。将第二个方程代入第一个方程得到：\n$$ 2(-8c_2) + 4c_2 = 1 $$\n$$ -16c_2 + 4c_2 = 1 $$\n$$ -12c_2 = 1 \\implies c_2 = -\\frac{1}{12} $$\n将此值代回以求得 $c_1$：\n$$ c_1 = -8\\left(-\\frac{1}{12}\\right) = \\frac{8}{12} = \\frac{2}{3} $$\n因此，系数为 $c_1 = 2/3$ 和 $c_2 = -1/12$。我们将它们代回 $D_h f(x)$ 的原始公式中：\n$$ D_h f(x) = \\frac{\\frac{2}{3}[f(x+h) - f(x-h)] - \\frac{1}{12}[f(x+2h) - f(x-2h)]}{h} $$\n为了得到单一的解析表达式，我们为系数找到一个公分母：\n$$ D_h f(x) = \\frac{1}{h} \\left( \\frac{8}{12}[f(x+h) - f(x-h)] - \\frac{1}{12}[f(x+2h) - f(x-2h)] \\right) $$\n$$ D_h f(x) = \\frac{1}{12h} \\left( 8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h)) \\right) $$\n$$ D_h f(x) = \\frac{8f(x+h) - 8f(x-h) - f(x+2h) + f(x-2h)}{12h} $$\n根据分子中各项相对于 $x$ 的位置重新排列它们：\n$$ D_h f(x) = \\frac{-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)}{12h} $$\n这就是所求的四阶中心差分近似。\n\n最后，我们必须验证截断误差的主项与 $h^4$ 成正比。截断误差 $T(h)$ 由 $T(h) = D_h f(x) - f'(x)$ 给出。根据我们对 $D_h f(x)$ 的展开式，其中 $f'(x)$ 和 $f'''(x)$ 的项已正确设置，我们有：\n$$ D_h f(x) = f'(x) + \\left(\\frac{c_1}{60} + \\frac{8c_2}{15}\\right)h^4 f^{(5)}(x) + \\mathcal{O}(h^6) $$\n主误差项由 $h^4 f^{(5)}(x)$ 的系数决定。代入 $c_1$ 和 $c_2$ 的值：\n$$ \\text{Coefficient of } h^4 f^{(5)}(x) = \\frac{c_1}{60} + \\frac{8c_2}{15} = \\frac{c_1}{60} + \\frac{32c_2}{60} = \\frac{1}{60}(c_1 + 32c_2) $$\n$$ = \\frac{1}{60} \\left( \\frac{2}{3} + 32\\left(-\\frac{1}{12}\\right) \\right) = \\frac{1}{60} \\left( \\frac{2}{3} - \\frac{32}{12} \\right) = \\frac{1}{60} \\left( \\frac{2}{3} - \\frac{8}{3} \\right) = \\frac{1}{60} \\left( -\\frac{6}{3} \\right) = \\frac{-2}{60} = -\\frac{1}{30} $$\n所以，该近似为：\n$$ D_h f(x) = f'(x) - \\frac{1}{30}h^4f^{(5)}(x) + \\mathcal{O}(h^6) $$\n截断误差为 $T(h) = D_h f(x) - f'(x) = -\\frac{1}{30}h^4 f^{(5)}(x) + \\mathcal{O}(h^6)$。主项确实与 $h^4$ 成正比，这证实了所推导的差分格式具有四阶精度。\n该近似的最终表达式是上面推导出的闭式形式。", "answer": "$$ \\boxed{\\frac{-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)}{12h}} $$", "id": "3307345"}, {"introduction": "理论上的收敛阶数是评估数值方法精度的关键指标，但在实际计算中，其行为会受到有限精度算法的制约。本练习通过一个网格加密研究，让你亲手实现并观察一个中心差分格式在逼近导数时的误差表现。你将从中深刻理解截断误差与舍入误差之间的权衡，并揭示为何在步长 $h$ 过小时，数值精度反而会恶化 [@problem_id:3307315]。", "problem": "考虑空间微分在计算电磁学中的作用，特别是在麦克斯韦方程组的有限差分​​离散化中。在诸如时域有限差分 (FDTD) 方案等方法中，空间导数通过网格上的有限差分进行近似，电磁场更新方程的准确性和稳定性取决于导数算子的离散化方式以及步长。为了在受控的环境中研究这些数值特性，我们将重点使用对称模板来近似一个光滑标量函数的导数。\n\n从一个充分光滑的函数 $f$ 在点 $x$ 附近的泰勒展开出发，推导出一个对称的双点模板来近似导数 $f'(x)$。该近似通过在必要的最低阶截断泰勒级数以消除 $h$ 的奇数阶项，并实现关于 $h$ 的二阶相容性。在您的程序中，将此近似应用于特定函数 $f(x) = \\cos x$ 在点 $x = 1$ 的情况，角度以弧度为单位。\n\n将步长为 $h$ 时的绝对误差定义为 $E(h) = |D(h) - f'(1)|$，其中 $D(h)$ 是您使用对称模板获得的 $f'(1)$ 的数值近似值，$f'(1)$ 是在 $x = 1$ 处的精确导数。使用一个递减的步长序列 $(h_i)$，将连续步长之间的观测阶数定义为\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}.\n$$\n在网格加密研究中，当截断误差占主导时，理论上的二阶行为意味着 $p_i \\approx 2$。对于足够小的 $h$，$f(x+h) - f(x-h)$ 中的相减抵消以及浮点舍入（由机器精度表征）会导致偏离这种理想行为。您的解答必须根据截断误差和舍入误差来解释这些偏差的来源。\n\n实现一个程序，对以下每个 $h$ 的测试序列，计算：\n- $f'(1)$ 的数值近似序列 $D(h_i)$，\n- 绝对误差序列 $E(h_i)$，\n- 连续步长对 $(h_i, h_{i+1})$ 的观测阶数序列 $(p_i)$。\n\n角度必须以弧度为单位。此问题中没有其他物理单位。程序的最终输出应将所有测试序列的观测阶数汇总到一行中，该行包含一个列表的列表，其中每个内部列表对应一个测试序列，并包含作为浮点数的 $p_i$ 值。\n\n步长序列测试套件：\n- 情况 A (中等程度加密): $[10^{-1},\\, 5 \\cdot 10^{-2},\\, 2.5 \\cdot 10^{-2},\\, 1.25 \\cdot 10^{-2}]$。\n- 情况 B (从粗到中等程度加密): $[5 \\cdot 10^{-1},\\, 2.5 \\cdot 10^{-1},\\, 1.25 \\cdot 10^{-1},\\, 6.25 \\cdot 10^{-2}]$。\n- 情况 C (接近平衡截断误差和舍入误差的预期最优 $h$): $[10^{-5},\\, 5 \\cdot 10^{-6},\\, 2.5 \\cdot 10^{-6},\\, 1.25 \\cdot 10^{-6}]$。\n- 情况 D (舍入误差占主导的极小步长): $[10^{-8},\\, 5 \\cdot 10^{-9},\\, 2.5 \\cdot 10^{-9},\\, 1.25 \\cdot 10^{-9}]$。\n- 情况 E (非均匀比率以测试通用性): $[10^{-3},\\, 7.5 \\cdot 10^{-4},\\, 3 \\cdot 10^{-4},\\, 10^{-4},\\, 7.5 \\cdot 10^{-5}]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应情况的内部观测阶数列表（例如， $[[p_{A,1},p_{A,2},p_{A,3}],[p_{B,1},\\dots],\\dots]$）。", "solution": "该问题要求推导一阶导数的二阶精确有限差分近似，分析其数值误差特性，并实现一个程序来计算特定函数和几组步长下的收敛观测阶数。\n\n**1. 对称有限差分模板的推导**\n\n为推导一阶导数 $f'(x)$ 的对称双点模板，我们从一个充分光滑的函数 $f(x)$ 在点 $x$ 附近对点 $x+h$ 和 $x-h$ 的泰勒级数展开开始，其中 $h > 0$ 是步长。\n\n$f(x+h)$ 关于 $x$ 的泰勒展开式为：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2!}f''(x) + \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) + \\dots\n$$\n\n$f(x-h)$ 关于 $x$ 的泰勒展开式为：\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2!}f''(x) - \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) - \\dots\n$$\n\n为了分离出一阶导数项 $f'(x)$，我们将第二个展开式从第一个展开式中减去。这样做可以方便地消去所有 $h$ 的偶次幂项：\n$$\nf(x+h) - f(x-h) = (f(x) - f(x)) + (h - (-h))f'(x) + \\left(\\frac{h^2}{2} - \\frac{h^2}{2}\\right)f''(x) + \\left(\\frac{h^3}{6} - \\left(-\\frac{h^3}{6}\\right)\\right)f'''(x) + \\dots\n$$\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{6}f'''(x) + \\mathcal{O}(h^5)\n$$\n其中 $\\mathcal{O}(h^5)$ 代表 $h^5$ 阶及更高阶的项。\n\n重新整理此方程以求解 $f'(x)$，得到：\n$$\nf'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{6}f'''(x) - \\mathcal{O}(h^4)\n$$\n\n由此，我们通过截断级数来定义 $f'(x)$ 的数值近似 $D(h)$：\n$$\nD(h) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n这就是所要求的对称双点模板，通常称为中心差分公式。\n\n此近似的误差，称为截断误差 $E_t(h)$，是精确导数与其近似值之间的差：\n$$\nE_t(h) = f'(x) - D(h) = -\\frac{h^2}{6}f'''(x) - \\mathcal{O}(h^4)\n$$\n由于误差的主导项与 $h^2$ 成正比，该方法是二阶精确的（或具有二阶相容性）。\n\n**2. 数值误差来源分析**\n\n在浮点计算中，总绝对误差 $E(h) = |D(h) - f'(x)|$ 是两个主要来源的组合：截断误差和舍入误差。\n\n**截断误差**：如上所述，截断误差源于用有限过程（模板）近似无限过程（泰勒级数）。对于较小的 $h$，此误差由其主导项决定：\n$$\nE_t(h) \\approx \\left|-\\frac{h^2}{6}f'''(x)\\right| = C_t h^2\n$$\n其中 $C_t = |f'''(x)|/6$。随着 $h$ 的减小，该误差呈二次方减小。对于指定的函数 $f(x) = \\cos x$，我们有 $f'(x) = -\\sin x$，$f''(x) = -\\cos x$ 以及 $f'''(x) = \\sin x$。在 $x=1$ 处，常数为 $C_t = \\sin(1)/6 \\approx 0.140$。\n\n**舍入误差**：舍入误差的产生是因为数字计算机使用有限精度表示实数。当 $h$ 非常小时，$f(x+h)$ 和 $f(x-h)$ 的值变得非常接近。此时，减法 $f(x+h) - f(x-h)$ 会遭受**相减抵消**，导致有效数字的损失。设 $\\epsilon_{mach}$ 为机器 epsilon（浮点运算中因舍入引起的相对误差的上限）。计算分子 $f(x+h) - f(x-h)$ 的误差大约与 $|f(x)|\\epsilon_{mach}$ 成正比。这个误差随后被除以一个小数 $2h$ 而放大。因此，舍入误差 $E_r(h)$ 可以建模为：\n$$\nE_r(h) \\approx \\frac{C_r}{h}\n$$\n其中常数 $C_r$ 的数量级约为 $|f(x)|\\epsilon_{mach}$。随着 $h$ 的减小，该误差会增大。\n\n**总误差和最优步长**：总误差是这两个分量的和：\n$$\nE(h) \\approx C_t h^2 + \\frac{C_r}{h}\n$$\n对于较大的 $h$，$C_t h^2$ 项占主导。对于非常小的 $h$，$C_r/h$ 项占主导。存在一个最优步长 $h_{opt}$ 可以使总误差最小化，可通过将 $E(h)$ 对 $h$ 的导数设为零来找到：\n$$\n\\frac{dE}{dh} = 2C_t h - \\frac{C_r}{h^2} = 0 \\implies h_{opt} = \\left(\\frac{C_r}{2C_t}\\right)^{1/3}\n$$\n对于双精度浮点运算，$\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$。对于函数 $f(x)=\\cos x$ 在 $x=1$ 处，$h_{opt}$ 的数量级在 $10^{-5}$ 到 $10^{-6}$ 之间。\n\n**3. 收敛的观测阶数**\n\n两个连续步长 $h_i$ 和 $h_{i+1}$ 之间的收敛观测阶数 $p_i$ 计算如下：\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}\n$$\n该公式源于假设误差行为符合 $E(h) \\approx C h^p$。如果该假设成立，则 $E(h_i)/E(h_{i+1}) \\approx (h_i/h_{i+1})^p$，对两边取对数即可解出 $p$。\n\n对于这些测试用例，$p_i$ 的预期行为如下：\n- **情况 A、B 和 E**：步长 $h_i$ 处于截断误差占主导的区间 ($E(h) \\propto h^2$)。因此，我们预期观测阶数 $p_i$ 约等于 $2$。\n- **情况 C**：步长接近 $h_{opt}$。在此区域，截断误差和舍入误差均很显著。误差不再遵循简单的幂律关系，因此 $p_i$ 将偏离 $2$，并可能减小。\n- **情况 D**：步长非常小，深陷于舍入误差主导的区间。误差预计会随着 $h$ 的减小而增大，大致遵循 $E(h) \\propto 1/h$。在这种情况下，$E(h_i)/E(h_{i+1}) \\approx (1/h_i)/(1/h_{i+1}) = h_{i+1}/h_i$。$p_i$ 的公式得出 $p_i \\approx \\log(h_{i+1}/h_i) / \\log(h_i/h_{i+1}) = -1$。由于浮点运算的随机性，观测值可能会混乱，但通常应为负数或接近于零，表明收敛性已经破坏。\n现在，实现将根据指定的测试用例计算这些值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a central difference approximation for f'(x) to study\n    numerical error behavior. The function computes numerical derivatives, errors,\n    and observed orders of convergence for several sequences of step sizes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderate refinement)\n        [1e-1, 5e-2, 2.5e-2, 1.25e-2],\n        # Case B (coarse-to-moderate refinement)\n        [5e-1, 2.5e-1, 1.25e-1, 6.25e-2],\n        # Case C (near the expected optimal h)\n        [1e-5, 5e-6, 2.5e-6, 1.25e-6],\n        # Case D (extremely small steps where round-off dominates)\n        [1e-8, 5e-9, 2.5e-9, 1.25e-9],\n        # Case E (non-uniform ratios to test generality)\n        [1e-3, 7.5e-4, 3e-4, 1e-4, 7.5e-5],\n    ]\n\n    # The point at which to evaluate the derivative\n    x = 1.0\n    \n    # The function f(x) = cos(x)\n    f = np.cos\n    \n    # The exact derivative f'(x) = -sin(x) at x=1\n    f_prime_exact = -np.sin(x)\n\n    all_p_results = []\n\n    for h_sequence in test_cases:\n        errors = []\n        for h in h_sequence:\n            # Symmetric, two-point stencil (central difference) approximation\n            # D(h) = (f(x+h) - f(x-h)) / (2*h)\n            d_approx = (f(x + h) - f(x - h)) / (2.0 * h)\n            \n            # Absolute error E(h) = |D(h) - f'(x)|\n            error = np.abs(d_approx - f_prime_exact)\n            errors.append(error)\n\n        p_values = []\n        # Calculate observed order p_i for successive pairs (h_i, h_{i+1})\n        for i in range(len(h_sequence) - 1):\n            h_i = h_sequence[i]\n            h_i_plus_1 = h_sequence[i+1]\n            \n            error_i = errors[i]\n            error_i_plus_1 = errors[i+1]\n            \n            # Formula for observed order: p_i = log(E_i/E_{i+1}) / log(h_i/h_{i+1})\n            # Handle cases where error might be zero to avoid log(0)\n            if error_i_plus_1 == 0.0 or error_i == 0.0:\n                # If the error becomes zero, the order is theoretically infinite.\n                # In practice with floating point, this suggests perfect cancellation or\n                # reaching the limits of precision.\n                p = np.inf\n            else:\n                log_error_ratio = np.log(error_i / error_i_plus_1)\n                log_h_ratio = np.log(h_i / h_i_plus_1)\n                p = log_error_ratio / log_h_ratio\n            \n            p_values.append(p)\n        \n        all_p_results.append(p_values)\n\n    # Format the final output string exactly as required: [[...],[...],...]\n    # without extraneous spaces.\n    outer_list_str = []\n    for p_list in all_p_results:\n        inner_list_str = \"[\" + \",\".join(map(str, p_list)) + \"]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(outer_list_str) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3307315"}, {"introduction": "除了扩展模板宽度，紧致差分格式为实现高精度计算提供了另一条有效途径，它能在保持模板紧凑性的同时达到高阶精度。本练习将引导你推导并实现一个四阶紧致差分格式，这需要求解一个循环三对角线性系统。这个过程将让你接触到计算科学中常见的高效算法，例如利用快速傅里叶变换（FFT）求解此类特殊结构矩阵的方法，这对于大规模周期性问题的仿真是至关重要的 [@problem_id:3307323]。", "problem": "考虑在一维周期性网格上计算空间导数 $\\partial_x E_y$ 的任务，这在计算电磁学中离散化 Maxwell 方程组的旋度算子时会出现。在区间 $[0,2\\pi)$ 上使用一个包含 $N$ 个点的均匀周期性网格，网格间距为 $\\Delta x = 2\\pi/N$，节点位置为 $x_i = i \\Delta x$，其中 $i = 0,1,\\dots,N-1$。角度必须以弧度为单位。从导数的定义和围绕网格点的泰勒级数展开出发，推导一个用于计算 $\\partial_x E_y$ 的三点四阶紧致有限差分格式，该格式具有以下特点：\n\n- 在节点 $i$ 处的近似使用一个线性系统，该系统通过左侧的对称最近邻模板耦合离散导数 $\\{(\\partial_x E_y)_j\\}$，并在右侧的函数值 $\\{E_y(x_j)\\}$ 中使用最近邻反对称模板。\n- 对于光滑周期函数 $E_y(x)$，该格式必须达到四阶精度，即局部截断误差为 $\\mathcal{O}(\\Delta x^4)$。\n- 由于周期性边界条件，所得到的关于离散导数向量的全局线性系统必须是循环三对角的。\n\n根据这些要求：\n\n1. 确定能够为符合上述约束的三点紧致格式产生四阶精度的唯一系数（如果存在）。仅使用导数的基本定义以及 $E_y(x)$ 及其在相邻节点上的导数的泰勒展开，通过匹配泰勒级数系数来推导这些系数。\n\n2. 明确写出为获得离散导数向量 $\\mathbf{d} \\in \\mathbb{R}^N$（其中 $d_i \\approx (\\partial_x E_y)(x_i)$）而必须求解的线性系统，并强调系统矩阵的循环三对角结构。概述一个利用此结构且不使用稠密线性代数的高效求解器的原理。您的概述必须基于对可逆矩阵进行低秩更新的基本线性代数恒等式。\n\n3. 将该方法实现为一个程序，该程序：\n   - 使用指定的 $N$ 构建周期性网格 $x_i$，并使用 $\\Delta x = 2\\pi/N$。\n   - 对于下面列出的每个测试函数 $E_y(x)$，组装相应的右侧项，并求解循环三对角线性系统，以获得 $\\partial_x E_y$ 的紧致四阶近似。\n   - 将数值结果与每个网格点上的精确导数进行比较，并返回每个测试用例在整个网格上的最大绝对误差。\n\n仅使用纯数学单位（不需要物理单位），角度必须以弧度为单位。最终输出必须将所有测试用例的结果汇总为单行，形式为一个用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的最大绝对误差，以浮点数形式打印。您必须将每个条目四舍五入到 $12$ 位有效数字的科学计数法形式。\n\n测试套件（每个用例必须按给定顺序独立评估）：\n\n- 用例 1 (光滑，中等波数): $N = 64$, $E_y(x) = \\sin(3 x)$, 精确导数 $\\partial_x E_y = 3 \\cos(3 x)$。\n- 用例 2 (恒定场): $N = 32$, $E_y(x) = 5$, 精确导数 $\\partial_x E_y = 0$。\n- 用例 3 (近奈奎斯特高频): $N = 128$, 令 $k = N/2 - 1 = 63$, $E_y(x) = \\sin(k x)$, 精确导数 $\\partial_x E_y = k \\cos(k x)$。\n- 用例 4 (非多项式光滑函数): $N = 100$, $E_y(x) = \\exp(\\sin x)$, 精确导数 $\\partial_x E_y = \\cos x \\exp(\\sin x)$。\n- 用例 5 (非常小的网格): $N = 4$, $E_y(x) = \\sin x$, 精确导数 $\\partial_x E_y = \\cos x$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同（例如，\"[v1,v2,v3,v4,v5]\"）。每个值都必须是科学计数法表示的浮点数，并四舍五入到 $12$ 位有效数字。\n\n不应从用户读取任何输入，也不应使用任何外部文件。实现应以通用方式表达，使其适用于任何 $N \\ge 4$ 和遵循指定模板的任何光滑周期函数 $E_y(x)$，但它应仅计算并打印上述给定测试套件的结果。", "solution": "该问题要求对一维周期性网格上的一阶导数，进行三点四阶紧致有限差分格式的推导、分析和实现。验证过程确认了该问题在科学上是合理的、适定的、客观的，并包含足够的信息以获得唯一解。这是偏微分方程数值分析中的一个标准问题。\n\n**第 1 部分：紧致格式系数的推导**\n\n我们的任务是在间距为 $\\Delta x = 2\\pi/N$ 的均匀周期性网格上，为网格点 $x_i = i \\Delta x$（$i = 0, 1, \\dots, N-1$）上的导数 $\\partial_x E_y$ 寻找一个有限差分近似。设 $d_i$ 是 $E_y'(x_i) \\equiv (\\partial_x E_y)(x_i)$ 的数值近似，并设 $E_{y,i}$ 表示 $E_y(x_i)$。\n\n问题指明了紧致格式的形式。在每个节点 $i$，$d_j$ 的离散导数通过一个对称的最近邻模板耦合，而函数值 $\\{E_{y,j}\\}$ 通过一个最近邻的反对称模板耦合。这种结构可以表示为：\n$$\n\\alpha d_{i-1} + \\beta d_i + \\alpha d_{i+1} = \\frac{1}{\\Delta x} \\left( c E_{y,i+1} - c E_{y,i-1} \\right)\n$$\n其中 $\\alpha$、$\\beta$ 和 $c$ 是待确定的未知系数。左侧（LHS）的对称性要求 $d_{i-1}$ 和 $d_{i+1}$ 的系数相同。右侧（RHS）的反对称性给出了 $E_{y,i+1} - E_{y,i-1}$ 的形式。不失一般性，我们可以将 $d_i$ 的系数归一化为 $\\beta=1$。RHS 上的因子 $1/\\Delta x$ 是一阶导数近似的常规做法。为了代数上的方便，我们还将 RHS 的系数重新缩放为 $a/2$，以匹配标准中心差分的形式。该格式变为：\n$$\n\\alpha d_{i-1} + d_i + \\alpha d_{i+1} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n为了找到能产生四阶精度的系数 $\\alpha$ 和 $a$，我们将所有项替换为它们在点 $x_i$ 附近的泰勒级数展开。我们将 $E_y(x)$ 在 $x_i$ 处的精确导数表示为 $E_y'$、$E_y''$ 等。在此误差分析中，假设数值导数 $d_j$ 等于精确导数 $E_y'(x_j)$。\n\n$E_y(x)$ 在相邻点 $x_{i\\pm1} = x_i \\pm \\Delta x$ 的泰勒级数为：\n$$\nE_{y,i\\pm1} = E_y \\pm \\Delta x E_y' + \\frac{(\\Delta x)^2}{2!} E_y'' \\pm \\frac{(\\Delta x)^3}{3!} E_y''' + \\frac{(\\Delta x)^4}{4!} E_y^{(4)} \\pm \\frac{(\\Delta x)^5}{5!} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n导数 $E_y'(x)$ 在相邻点的泰勒级数为：\n$$\nd_{i\\pm1} \\approx E_y'(x_{i\\pm1}) = E_y' \\pm \\Delta x E_y'' + \\frac{(\\Delta x)^2}{2!} E_y''' \\pm \\frac{(\\Delta x)^3}{3!} E_y^{(4)} + \\frac{(\\Delta x)^4}{4!} E_y^{(5)} + \\mathcal{O}((\\Delta x)^5)\n$$\n\n首先，我们展开格式的 RHS：\n$$\n\\text{RHS} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{a}{2\\Delta x} \\left( 2\\Delta x E_y' + 2\\frac{(\\Delta x)^3}{6} E_y''' + 2\\frac{(\\Delta x)^5}{120} E_y^{(5)} + \\mathcal{O}((\\Delta x)^7) \\right)\n$$\n$$\n\\text{RHS} = a E_y' + \\frac{a(\\Delta x)^2}{6} E_y''' + \\frac{a(\\Delta x)^4}{120} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n\n接下来，我们展开格式的 LHS：\n$$\n\\text{LHS} = \\alpha (d_{i-1} + d_{i+1}) + d_i \\approx \\alpha (E_y'(x_{i-1}) + E_y'(x_{i+1})) + E_y'(x_i)\n$$\n$$\n\\text{LHS} \\approx \\alpha \\left( 2E_y' + 2\\frac{(\\Delta x)^2}{2} E_y''' + 2\\frac{(\\Delta x)^4}{24} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6) \\right) + E_y'\n$$\n$$\n\\text{LHS} \\approx (1+2\\alpha)E_y' + \\alpha(\\Delta x)^2 E_y''' + \\frac{\\alpha(\\Delta x)^4}{12} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n\n为使格式精确，表达式 LHS - RHS 必须尽可能接近于零。我们令等式两边 $E_y$ 的各阶导数系数相等。\n\\begin{itemize}\n    \\item $E_y'$ 的系数：$1+2\\alpha = a$\n    \\item $E_y''$ 的系数：由于对称性，$E_y$ 的奇数阶导数项消失，这是该中心格式的一个关键特性。\n    \\item $E_y'''$ 的系数：为达到高于二阶的精度，$(\\Delta x)^2$ 项必须抵消。\n    $$ \\alpha(\\Delta x)^2 = \\frac{a(\\Delta x)^2}{6} \\implies \\alpha = \\frac{a}{6} $$\n\\end{itemize}\n\n我们现在有一个关于两个未知数 $\\alpha$ 和 $a$ 的二元线性方程组：\n1. $a = 1 + 2\\alpha$\n2. $a = 6\\alpha$\n\n将 (2) 代入 (1) 得到 $6\\alpha = 1 + 2\\alpha$，解得 $4\\alpha = 1$，所以 $\\alpha = 1/4$。\n将 $\\alpha=1/4$ 代回 (2) 得到 $a = 6(1/4) = 3/2$。\n\n唯一的系数是 $\\alpha = 1/4$ 和 $a = 3/2$。该格式为：\n$$\n\\frac{1}{4} d_{i-1} + d_i + \\frac{1}{4} d_{i+1} = \\frac{3/2}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n局部截断误差 (LTE) 由展开式中的第一个非零项确定。我们比较 $(\\Delta x)^4$ 项的系数：\n$$\n\\text{LTE} \\propto \\left( \\frac{\\alpha(\\Delta x)^4}{12} - \\frac{a(\\Delta x)^4}{120} \\right) E_y^{(5)} = \\left( \\frac{1/4}{12} - \\frac{3/2}{120} \\right) (\\Delta x)^4 E_y^{(5)}\n$$\n$$\n= \\left( \\frac{1}{48} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\left( \\frac{5}{240} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\frac{2}{240} (\\Delta x)^4 E_y^{(5)} = \\frac{1}{120} (\\Delta x)^4 E_y^{(5)}\n$$\n误差与 $(\\Delta x)^4$ 成正比，证实了该格式是四阶精度的。截断误差的正式定义是当精确解代入归一化差分算子时产生的残差。除以归一化因子 $1+2\\alpha = 3/2$ 后，误差为 $T_i = -\\frac{1}{180}(\\Delta x)^4 E_y^{(5)}(x_i) + \\mathcal{O}((\\Delta x)^6)$。\n\n**第 2 部分：线性系统和高效求解器**\n\n该格式必须应用于从 $i=0$ 到 $i=N-1$ 的所有 $N$ 个网格点。这将为 $N$ 个未知导数 $d_0, d_1, \\dots, d_{N-1}$ 生成一个包含 $N$ 个线性方程的系统。设 $\\mathbf{d} = [d_0, d_1, \\dots, d_{N-1}]^T$ 为离散导数向量。该系统可以写成矩阵形式 $A \\mathbf{d} = \\mathbf{b}$，其中 $A$ 是系数矩阵，$\\mathbf{b}$ 是右侧向量。\n\n对于一个一般内部点 $i$ 的方程是：\n$$\n(\\frac{1}{4}) d_{i-1} + (1) d_i + (\\frac{1}{4}) d_{i+1} = b_i\n$$\n其中 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$。\n\n由于周期性边界条件，指数需对 $N$ 取模。对于 $i=0$，$d_{i-1}=d_{-1}$ 变为 $d_{N-1}$。对于 $i=N-1$，$d_{i+1}=d_N$ 变为 $d_0$。这种“环绕”特性赋予矩阵 $A$ 其特有的结构：\n$$\nA = \\begin{pmatrix}\n1   1/4  0  \\dots  0  1/4 \\\\\n1/4  1  1/4  \\dots  0  0 \\\\\n0  1/4  1  \\dots  0  0 \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n0  0  0  \\dots  1  1/4 \\\\\n1/4  0  0  \\dots  1/4  1\n\\end{pmatrix}\n$$\n这是一个对称、三对角、循环矩阵。右侧向量 $\\mathbf{b}$ 的分量为 $b_i = \\frac{3}{4\\Delta x} (E_{y,(i+1)\\%N} - E_{y,(i-1+N)\\%N})$。\n\n一个高效的求解器必须利用这种循环结构。\n一种复杂度为 $\\mathcal{O}(N \\log N)$ 的高效方法是基于离散傅里叶变换 (DFT)，因为循环矩阵可以被 DFT 对角化。\n1.  令 $\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$ 为 $A$ 的第一行。卷积定理指出，对于一个循环矩阵 $A$，矩阵向量乘积 $A\\mathbf{d}$ 等价于 $\\mathbf{c}$ 和 $\\mathbf{d}$ 的循环卷积。\n2.  对系统 $A\\mathbf{d} = \\mathbf{b}$ 应用 DFT（记为 $\\mathcal{F}$），得到 $\\mathcal{F}(A\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$。\n3.  这变为 $\\mathcal{F}(\\mathbf{c}) \\odot \\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$，其中 $\\odot$ 表示逐元素乘法。向量 $\\mathbf{\\Lambda} = \\mathcal{F}(\\mathbf{c})$ 包含 $A$ 的特征值。\n4.  该系统在频域中通过逐元素除法求解：$\\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda}$。\n5.  通过应用逆 DFT 恢复解向量 $\\mathbf{d}$：$\\mathbf{d} = \\mathcal{F}^{-1}(\\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda})$。对 DFT 及其逆变换使用快速傅里叶变换 (FFT) 算法使该方法非常快速。$A$ 的特征值由 $\\lambda_j = 1 + (1/4)e^{i 2\\pi j/N} + (1/4)e^{-i 2\\pi j/N} = 1 + (1/2)\\cos(2\\pi j/N)$ 给出，其中 $j=0, \\dots, N-1$。由于 $|\\cos(\\theta)| \\le 1$，所有特征值均为正，确保了矩阵是非奇异的。\n\n另一种高效的 $\\mathcal{O}(N)$ 方法，即提示中所提到的“低秩更新”，是使用 Sherman-Morrison-Woodbury 公式。矩阵 $A$ 可以写成一个简单的三对角矩阵 $T$ 加上一个针对角元素的秩-2 校正 $U V^T$：$A = T + \\alpha(\\mathbf{e}_0 \\mathbf{e}_{N-1}^T + \\mathbf{e}_{N-1} \\mathbf{e}_0^T)$，其中 $\\alpha=1/4$。然后，可以通过求解几个三对角系统（使用 $\\mathcal{O}(N)$ 的 Thomas 算法）和一个小的 $2 \\times 2$ 系统来找到 $A\\mathbf{d} = \\mathbf{b}$ 的解。\n\n**第 3 部分：实现策略**\n\n实现将遵循基于 FFT 的方法，`scipy.linalg.solve_circulant` 方便地提供了该功能。\n对于每个指定的测试用例：\n1.  设置网格大小 $N$ 并定义函数 $E_y(x)$ 及其解析导数。\n2.  构建网格 $x_i = i (2\\pi/N)$，其中 $i=0, \\dots, N-1$。\n3.  在网格上评估函数以创建向量 $\\mathbf{E}_y$。\n4.  使用公式 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$ 构建右侧向量 $\\mathbf{b}$。使用 `numpy.roll` 可以高效地处理周期性索引。\n5.  定义循环矩阵 $A$ 的第一行：$\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$。\n6.  使用 `scipy.linalg.solve_circulant(c, b)` 求解系统 $A\\mathbf{d} = \\mathbf{b}$ 得到 $\\mathbf{d}$。\n7.  在网格上评估精确导数以获得向量 $\\mathbf{d}_{\\text{exact}}$。\n8.  计算整个网格上的最大绝对误差：$\\max(|\\mathbf{d} - \\mathbf{d}_{\\text{exact}}|)$。\n9.  收集所有测试用例的误差，并格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Derives and implements a fourth-order compact finite difference scheme\n    to compute the first derivative of periodic functions.\n    \"\"\"\n\n    def compact_fourth_order_derivative(Ey_values, N):\n        \"\"\"\n        Computes the derivative using the 4th-order compact scheme.\n\n        Args:\n            Ey_values (np.ndarray): The function values E_y(x_i) on the grid.\n            N (int): The number of grid points.\n\n        Returns:\n            np.ndarray: The numerical derivative d_i at each grid point.\n        \"\"\"\n        # Grid spacing\n        delta_x = 2.0 * np.pi / N\n\n        # Coefficients of the scheme derived from Taylor series analysis.\n        # Scheme: (1/4)d_{i-1} + d_i + (1/4)d_{i+1} = (3/4 * delta_x) * (E_{y,i+1} - E_{y,i-1})\n        alpha = 1.0 / 4.0\n        a = 3.0 / 2.0\n\n        # Construct the right-hand side (RHS) vector b.\n        # np.roll handles the periodic boundary conditions efficiently.\n        Ey_plus_1 = np.roll(Ey_values, -1)\n        Ey_minus_1 = np.roll(Ey_values, 1)\n        \n        rhs_b = (a / (2.0 * delta_x)) * (Ey_plus_1 - Ey_minus_1)\n\n        # Construct the first row of the circulant-cyclic tridiagonal matrix A.\n        # A has 1 on the main diagonal, and alpha on the sub- and super-diagonals,\n        # with cyclic wrap-around.\n        circulant_first_row = np.zeros(N)\n        circulant_first_row[0] = 1.0\n        circulant_first_row[1] = alpha\n        circulant_first_row[N - 1] = alpha  # or circulant_first_row[-1]\n\n        # Solve the linear system A*d = b using the efficient circulant solver,\n        # which is based on FFTs.\n        d_numerical = solve_circulant(circulant_first_row, rhs_b)\n\n        return d_numerical\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64,\n            \"Ey_func\": lambda x: np.sin(3 * x),\n            \"dEy_exact_func\": lambda x: 3 * np.cos(3 * x),\n        },\n        {\n            \"N\": 32,\n            \"Ey_func\": lambda x: np.full_like(x, 5.0),\n            \"dEy_exact_func\": lambda x: np.zeros_like(x),\n        },\n        {\n            \"N\": 128,\n            \"k\": 63, # k = N/2 - 1\n            \"Ey_func\": lambda x, k=63: np.sin(k * x),\n            \"dEy_exact_func\": lambda x, k=63: k * np.cos(k * x),\n        },\n        {\n            \"N\": 100,\n            \"Ey_func\": lambda x: np.exp(np.sin(x)),\n            \"dEy_exact_func\": lambda x: np.cos(x) * np.exp(np.sin(x)),\n        },\n        {\n            \"N\": 4,\n            \"Ey_func\": lambda x: np.sin(x),\n            \"dEy_exact_func\": lambda x: np.cos(x),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Create the periodic grid\n        x_grid = np.arange(N) * (2.0 * np.pi / N)\n\n        # Evaluate the function and its exact derivative on the grid\n        Ey_values = case[\"Ey_func\"](x_grid)\n        dEy_exact = case[\"dEy_exact_func\"](x_grid)\n        \n        # Compute the numerical derivative\n        dEy_numerical = compact_fourth_order_derivative(Ey_values, N)\n        \n        # Calculate the maximum absolute error\n        max_abs_error = np.max(np.abs(dEy_numerical - dEy_exact))\n        \n        results.append(max_abs_error)\n\n    # Format output as a comma-separated list of values in scientific notation\n    # with 12 significant digits.\n    formatted_results = [f\"{res:.11e}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3307323"}]}