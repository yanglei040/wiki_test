{"hands_on_practices": [{"introduction": "我们从有限差分格式中执行诺伊曼边界条件最常用的技术之一开始：鬼点法（ghost cell method）。这项实践将指导您在一个简单的一维环境中推导和实现该方法，为解决更复杂的问题奠定坚实的基础。通过离散亥姆霍兹或扩散方程，您将看到一个位于域外的虚拟“鬼”点如何让我们能在边界上直接使用对称的二阶精度模板 [@problem_id:3305488]。", "problem": "考虑在区间 $[0,L]$ 上的一维标量边值问题，使用包含 $N$ 个区间的均匀网格，网格间距为 $h = L/N$，网格节点为 $x_i = i h$，其中 $i = 0,1,\\dots,N$。主要目标是使用鬼点在左边界 $x=0$ 处施加诺伊曼(Neumann)边界条件，并推导出一个等效的二阶精度单边边界模板，用以在边界 $\\partial \\Omega$ 处施加法向导数条件 $\\partial_n u = g$。三角函数中的所有角度都必须以弧度为单位。\n\n您将从以下基本事实出发：\n- 一维标量亥姆霍兹(Helmholtz)方程为 $u''(x) + k^2 u(x) = s(x)$，其中 $k$ 是给定的波数，$s(x)$ 是已知源项。\n- 一维标量稳态扩散（泊松(Poisson)）方程（单位传导率）为 $-u''(x) = f(x)$，其中 $f(x)$ 是已知源项。\n- 对于内部点，二阶导数的二阶精度中心差分近似为 $u''(x_i) \\approx (u_{i-1} - 2 u_i + u_{i+1})/h^2$。\n- 左边界上的诺伊曼(Neumann)边界条件为 $u'(0) = g$。对于一维区间，在 $x=0$ 处，外法线方向为 $-x$ 方向，因此 $\\partial_n u = -u'(x)$。这里我们直接施加 $u'(0) = g$。\n\n任务：\n- 从关于 $x=0$ 的泰勒(Taylor)展开式出发，推导一个二阶精度的鬼点关系式。当该关系式与亥姆霍兹(Helmholtz)或扩散算子的标准三点二阶内部模板结合使用时，可以施加 $u'(0) = g$。引入一个位于 $x=-h$ 的鬼点 $u_{-1}$，并推导一个用 $u_1$、$g$ 和 $h$ 表示 $u_{-1}$ 的关系式，该关系式适用于二阶精度地施加 $u'(0)=g$。\n- 独立于泰勒(Taylor)展开式，推导一个用 $u_0$、$u_1$、$u_2$ 和 $h$ 表示的 $u'(0)$ 的二阶精度单边边界模板，该模板用于在 $x=0$ 处施加 $u'(0)=g$。\n- 展示鬼点关系式如何修改每个算子的最左侧离散方程：\n  - 对于亥姆霍兹(Helmholtz)算子，在 $i=0$ 的离散方程中使用 $u_{-1}$ 会得到一个形式为 $a_{00} u_0 + a_{01} u_1 = b_0$ 的修改后方程，其中 $a_{00}$、$a_{01}$ 和 $b_0$ 必须用 $h$、$k$、$s(0)$ 和 $g$ 表示。\n  - 对于扩散算子，在 $i=0$ 的离散方程中使用 $u_{-1}$ 会得到一个形式为 $a_{00} u_0 + a_{01} u_1 = b_0$ 的修改后方程，其中 $a_{00}$、$a_{01}$ 和 $b_0$ 必须用 $h$、$f(0)$ 和 $g$ 表示。\n- 实现一个求解器，该求解器组装并求解具有以下条件的线性系统：\n  - 对于 $i=1,2,\\dots,N-1$，亥姆霍兹(Helmholtz)或扩散内部算子使用二阶中心差分进行离散化。\n  - 在 $i=0$ 处的诺伊曼(Neumann)边界条件通过上述推导的鬼点关系式施加，并代入 $i=0$ 处的离散方程。\n  - 在 $x=L$ 处的狄利克雷(Dirichlet)边界条件通过设置 $u_N = u(L)$ 来施加，使用一个已知的精确解 $u(x)$ 来定义该边值。这可以避免扩散问题的奇异性，并确保离散解的唯一性。\n\n使用以下参数集测试套件。对于每个测试用例，您必须计算解向量 $\\{u_i\\}_{i=0}^N$ 并报告一个指定的标量值。\n\n- 测试用例 1 (亥姆霍兹(Helmholtz)，理想路径)：$L=1$，$N=64$，$k=3$，精确解 $u(x) = \\cos(2 x) + 0.1 x$，源项由 $s(x) = u''(x) + k^2 u(x)$ 定义，诺伊曼(Neumann)数据 $g = u'(0)$，狄利克雷(Dirichlet)数据 $u(L)$ 来自精确解。报告离散 $L^2$ 误差范数 $\\left(\\,h\\sum_{i=0}^N \\left(u_i - u(x_i)\\right)^2\\,\\right)^{1/2}$，结果为浮点数。\n- 测试用例 2 (亥姆霍兹(Helmholtz)，使用粗网格探测离散化)：$L=1$，$N=8$，$k=3$，与测试用例 1 中相同的精确解和源项，相同的边界数据。报告离散 $L^2$ 误差范数。\n- 测试用例 3 (扩散，混合边界条件)：$L=1$，$N=64$，精确解 $u(x) = \\sin(\\pi x) + x$，源项由 $f(x) = -u''(x)$ 定义，诺伊曼(Neumann)数据 $g = u'(0)$，狄利克雷(Dirichlet)数据 $u(L)$ 来自精确解。报告离散 $L^2$ 误差范数。\n- 测试用例 4 (亥姆霍兹(Helmholtz)，齐次源项和 $x=0$ 处的齐次诺伊曼(Neumann)条件)：$L=1$，$N=32$，$k=2$，精确解 $u(x) = \\cos(2 x)$，因此 $s(x) \\equiv 0$，$g = u'(0) = 0$，狄利克雷(Dirichlet)数据 $u(L)$ 来自精确解。使用推导的二阶单边模板，根据数值解计算并报告边界导数施加绝对误差 $\\left|\\,(-3 u_0 + 4 u_1 - u_2)/(2 h) - g\\,\\right|$。\n\n实现细节和要求：\n- 使用一个具有节点 $x_i = i h$（$i=0,1,\\dots,N$）的单一均匀网格。\n- 对于内部点 $i=1,2,\\dots,N-1$：\n  - 亥姆霍兹(Helmholtz)：通过 $(u_{i-1} - 2 u_i + u_{i+1})/h^2 + k^2 u_i = s(x_i)$ 离散化 $u''(x_i) + k^2 u(x_i) = s(x_i)$。\n  - 扩散：通过 $(-u_{i-1} + 2 u_i - u_{i+1})/h^2 = f(x_i)$ 离散化 $-u''(x_i) = f(x_i)$。\n- 在左边界 $i=0$ 处，通过您推导的鬼点关系式消去鬼点 $u_{-1}$，并将其代入 $i=0$ 处的离散算子方程，以施加 $u'(0)=g$。\n- 在右边界 $i=N$ 处，通过 $u_N = u(L)$ 精确施加狄利克雷(Dirichlet)条件。\n- 精确地按照每个测试用例的规定计算并报告标量输出。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。\n\n所有输出均为无量纲数。三角函数中的角度必须以弧度为单位。最终输出必须是浮点数。程序不得要求任何输入，且必须能按原样运行以生成所需的单行输出。", "solution": "用户提供了一个定义明确的计算问题，该问题科学上合理、自洽且客观。该问题是有效的，并且可以按所述方式解决。\n\n该问题要求为一维标量边值问题推导数值模板并实现一个有限差分求解器。核心任务是使用鬼点法处理诺伊曼(Neumann)边界条件，并对照已知的精确解来验证实现。\n\n### 第1部分：鬼点关系式的推导\n\n我们的任务是推导一个位于 $x = -h$ 的鬼点 $u_{-1}$ 的二阶精度关系式，以施加诺伊曼(Neumann)条件 $u'(0) = g$。我们使用 $u(x)$ 在 $x=0$ 附近的泰勒级数展开。\n\n$u(x)$ 在 $x=h$ (节点 $x_1$) 处的展开式为：\n$$u(h) = u(0) + h u'(0) + \\frac{h^2}{2} u''(0) + \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\n离散形式为 $u_1 = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$。\n\n$u(x)$ 在 $x=-h$ (鬼点 $x_{-1}$) 处的展开式为：\n$$u(-h) = u(0) - h u'(0) + \\frac{h^2}{2} u''(0) - \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\n离散形式为 $u_{-1} = u_0 - h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$。\n\n为了获得 $u'(0)$ 的二阶精度近似，我们可以构造一个中心差分。从第一个展开式中减去第二个展开式，得到：\n$$u(h) - u(-h) = 2h u'(0) + \\frac{h^3}{3} u'''(0) + \\mathcal{O}(h^5)$$\n整理得到 $u'(0)$：\n$$\\frac{u(h) - u(-h)}{2h} = u'(0) + \\frac{h^2}{6} u'''(0) + \\mathcal{O}(h^4)$$\n截断高阶项，得到在 $x=0$ 处一阶导数的二阶精度中心差分近似：\n$$u'(0) \\approx \\frac{u_1 - u_{-1}}{2h}$$\n为了施加诺伊曼(Neumann)条件 $u'(0) = g$，我们设置：\n$$\\frac{u_1 - u_{-1}}{2h} = g$$\n解出鬼点值 $u_{-1}$，得到所需的关系式：\n$$u_{-1} = u_1 - 2hg$$\n该关系式用内部点值 $u_1$ 和指定的导数 $g$ 表示了鬼点值 $u_{-1}$，并具有二阶精度。\n\n### 第2部分：单边边界模板的推导\n\n作为独立检验和验证之用，我们使用网格点值 $u_0$、$u_1$ 和 $u_2$ 推导一个用于 $u'(0)$ 的二阶精度单边模板。我们寻求系数 $a, b, c$ 使得：\n$$u'(0) \\approx a u_0 + b u_1 + c u_2$$\n我们使用 $u_1 = u(h)$ 和 $u_2 = u(2h)$ 在 $x=0$ 附近的泰勒(Taylor)展开式：\n$$u_1 = u(h) = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$$\n$$u_2 = u(2h) = u_0 + 2h u'(0) + \\frac{(2h)^2}{2} u''(0) + \\mathcal{O}(h^3) = u_0 + 2h u'(0) + 2h^2 u''(0) + \\mathcal{O}(h^3)$$\n将这些代入模板形式：\n$$a u_0 + b \\left(u_0 + h u'(0) + \\frac{h^2}{2} u''(0)\\right) + c \\left(u_0 + 2h u'(0) + 2h^2 u''(0)\\right) + \\mathcal{O}(h^3)$$\n$$= (a+b+c)u_0 + (bh + 2ch)u'(0) + \\left(b\\frac{h^2}{2} + c(2h^2)\\right)u''(0) + \\mathcal{O}(h^3)$$\n为了让此表达式成为 $u'(0)$ 的一个二阶精度近似，系数必须满足：\n1.  $u_0$ 的系数：$a+b+c = 0$\n2.  $u'(0)$ 的系数：$h(b+2c) = 1$\n3.  $u''(0)$ 的系数：$b\\frac{h^2}{2} + 2ch^2 = 0 \\implies b+4c=0$\n\n由(3)得，$b = -4c$。代入(2)：$h(-4c+2c)=1 \\implies -2ch=1 \\implies c = -\\frac{1}{2h}$。\n于是，$b = -4c = -4(-\\frac{1}{2h}) = \\frac{2}{h}$。\n由(1)得，$a = -b-c = -\\frac{2}{h} - (-\\frac{1}{2h}) = -\\frac{4}{2h} + \\frac{1}{2h} = -\\frac{3}{2h}$。\n得到的模板是：\n$$u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}$$\n这是用于一阶导数的二阶精度向前差分公式。\n\n### 第3部分：最左侧离散方程的修改\n\n现在，我们将鬼点关系式 $u_{-1} = u_1 - 2hg$ 代入第一个节点 $i=0$ 处的标准中心差分方程。\n\n**对于亥姆霍兹(Helmholtz)算子：**\n在 $x_0=0$ 处的离散方程为：\n$$\\frac{u_{-1} - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\n代入 $u_{-1}$：\n$$\\frac{(u_1 - 2hg) - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\n合并项：\n$$\\frac{-2u_0 + 2u_1 - 2hg}{h^2} + k^2 u_0 = s_0$$\n整理成 $a_{00} u_0 + a_{01} u_1 = b_0$ 的形式：\n$$\\left(k^2 - \\frac{2}{h^2}\\right) u_0 + \\frac{2}{h^2} u_1 = s_0 + \\frac{2g}{h}$$\n系数为：\n$a_{00} = k^2 - \\frac{2}{h^2}$\n$a_{01} = \\frac{2}{h^2}$\n$b_0 = s(0) + \\frac{2g}{h}$\n\n**对于扩散算子：**\n标准离散形式为 $(-u_{i-1} + 2u_i - u_{i+1})/h^2 = f_i$。在 $x_0=0$ 处：\n$$\\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f_0$$\n代入 $u_{-1}$：\n$$\\frac{-(u_1 - 2hg) + 2u_0 - u_1}{h^2} = f_0$$\n合并项：\n$$\\frac{2u_0 - 2u_1 + 2hg}{h^2} = f_0$$\n整理成 $a_{00} u_0 + a_{01} u_1 = b_0$ 的形式：\n$$\\frac{2}{h^2} u_0 - \\frac{2}{h^2} u_1 = f_0 - \\frac{2g}{h}$$\n系数为：\n$a_{00} = \\frac{2}{h^2}$\n$a_{01} = -\\frac{2}{h^2}$\n$b_0 = f(0) - \\frac{2g}{h}$\n\n### 第4部分：系统组装与求解\n\n问题在 $N+1$ 个节点 $x_0, \\dots, x_N$ 上离散化。未知量是 $u_0, \\dots, u_{N-1}$，形成一个大小为 $N$ 的向量。$u_N$ 由狄利克雷(Dirichlet)条件给出。这会得到一个 $N \\times N$ 的线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。\n\n矩阵 $A$ 和向量 $\\mathbf{b}$ 的构建如下：\n\n**$i=0$ 的方程 (诺伊曼(Neumann)边界条件)：** 如上所述推导。\n\n**$i=1, \\dots, N-2$ 的方程 (内部点)：**\n-   亥姆霍兹(Helmholtz)：$\\frac{1}{h^2} u_{i-1} + \\left(k^2 - \\frac{2}{h^2}\\right) u_i + \\frac{1}{h^2} u_{i+1} = s_i$。\n-   扩散：$-\\frac{1}{h^2} u_{i-1} + \\frac{2}{h^2} u_i - \\frac{1}{h^2} u_{i+1} = f_i$。\n这些构成了矩阵 $A$ 的三对角部分。\n\n**$i=N-1$ 的方程 (邻近狄利克雷(Dirichlet)边界条件)：**\n模板涉及 $u_{N-2}, u_{N-1}, u_N$。由于 $u_N$ 已知，其项被移到右侧。\n-   亥姆霍兹(Helmholtz)：$\\frac{1}{h^2} u_{N-2} + \\left(k^2 - \\frac{2}{h^2}\\right) u_{N-1} = s_{N-1} - \\frac{u_N}{h^2}$。\n-   扩散：$-\\frac{1}{h^2} u_{N-2} + \\frac{2}{h^2} u_{N-1} = f_{N-1} + \\frac{u_N}{h^2}$。\n\n然后求解得到的 $N \\times N$ 系统以获得 $\\mathbf{u}$。完整的数值解是向量 $[u_0, \\dots, u_{N-1}, u_N]$。以下的 Python 实现为指定的测试用例组装并求解该系统。", "answer": "```python\nimport numpy as np\n\ndef build_and_solve_system(params):\n    \"\"\"\n    Builds and solves the finite difference system for 1D BVP.\n    \"\"\"\n    problem_type = params[\"type\"]\n    L = params[\"L\"]\n    N = params[\"N\"]\n    k = params.get(\"k\", 0)\n    u_ex = params[\"u_ex\"]\n    u_prime = params[\"u_prime\"]\n    u_dprime = params[\"u_dprime\"]\n\n    # 1. Grid and parameters\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    # 2. Source term and boundary conditions from exact solution\n    if problem_type == \"helmholtz\":\n        s = u_dprime(x) + k**2 * u_ex(x)\n    elif problem_type == \"diffusion\":\n        f = -u_dprime(x)\n    else:\n        raise ValueError(\"Unknown problem type\")\n\n    g = u_prime(x[0])\n    u_N_val = u_ex(x[N])\n\n    # 3. Assemble the N x N linear system A*u = b\n    # The unknowns are u_0, u_1, ..., u_{N-1}\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Pre-calculate common coefficients\n    h2_inv = 1 / h**2\n    \n    # Equation for i=0 (Neumann BC at x=0)\n    if problem_type == \"helmholtz\":\n        A[0, 0] = k**2 - 2 * h2_inv\n        A[0, 1] = 2 * h2_inv\n        b[0] = s[0] + 2 * g / h\n    elif problem_type == \"diffusion\":\n        A[0, 0] = 2 * h2_inv\n        A[0, 1] = -2 * h2_inv\n        b[0] = f[0] - 2 * g / h\n\n    # Equations for i = 1 to N-2 (Interior points)\n    for i in range(1, N - 1):\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            A[i, i + 1] = h2_inv\n            b[i] = s[i]\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            A[i, i + 1] = -h2_inv\n            b[i] = f[i]\n\n    # Equation for i = N-1 (adjacent to Dirichlet BC)\n    if N > 1:\n        i = N - 1\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            b[i] = s[i] - u_N_val * h2_inv\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            b[i] = f[i] + u_N_val * h2_inv\n\n    # 4. Solve the system and construct the full solution vector\n    u_sol_part = np.linalg.solve(A, b)\n    u_sol = np.zeros(N + 1)\n    u_sol[0:N] = u_sol_part\n    u_sol[N] = u_N_val\n\n    # 5. Compute the required metric\n    report_metric = params[\"report\"]\n    if report_metric == \"l2_error\":\n        u_exact_nodes = u_ex(x)\n        error = u_sol - u_exact_nodes\n        l2_norm = np.sqrt(h * np.sum(error**2))\n        return l2_norm\n    elif report_metric == \"bdy_deriv_error\":\n        u0, u1, u2 = u_sol[0], u_sol[1], u_sol[2]\n        g_numerical = (-3 * u0 + 4 * u1 - u2) / (2 * h)\n        # The specified g is the exact derivative at 0\n        g_exact = g\n        return np.abs(g_numerical - g_exact)\n    else:\n        raise ValueError(\"Unknown report metric\")\n\ndef solve():\n    # Define test case parameters\n    test_cases = [\n        {\n            \"case\": 1, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 64, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 2, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 8, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 3, \"type\": \"diffusion\", \"L\": 1.0, \"N\": 64,\n            \"u_ex\": lambda x: np.sin(np.pi * x) + x,\n            \"u_prime\": lambda x: np.pi * np.cos(np.pi * x) + 1,\n            \"u_dprime\": lambda x: -np.pi**2 * np.sin(np.pi * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 4, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 32, \"k\": 2.0,\n            \"u_ex\": lambda x: np.cos(2 * x),\n            \"u_prime\": lambda x: -2 * np.sin(2 * x),\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"bdy_deriv_error\"\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = build_and_solve_system(params)\n        results.append(f\"{result:.16g}\") # Format to avoid scientific notation if small\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3305488"}, {"introduction": "一个稳健的数值方案不仅要精确，还必须遵循其内在的物理守恒律。本练习将我们的重点转移到本质上是守恒的有限体积法，并探讨在一个带有混合狄利克雷和诺伊曼条件的静电问题中，如何对全局电荷中性进行数值验证。您将实现一个求解器，然后计算穿过整个区域边界的总通量，从而验证您的实现能够在数值精度范围内正确地平衡流入和流出通量 [@problem_id:3305444]。", "problem": "考虑在没有自由电荷的二维静电学问题，该问题由麦克斯韦方程组的散度形式控制：在一个矩形区域 $\\Omega = [0,L_x]\\times[0,L_y]$ 上的标量电势场 $u(x,y)$ 满足偏微分方程 $\\nabla\\cdot(\\epsilon(x,y)\\nabla u) = 0$，其中 $\\epsilon(x,y)$ 是随空间变化的介电常数。在不相交的电极区域 $\\Gamma_D \\subset \\partial\\Omega$ 上施加狄利克雷边界条件（给定电势值），而在其他边界 $\\Gamma_N = \\partial\\Omega \\setminus \\Gamma_D$ 上施加诺伊曼边界条件（给定表示为 $\\epsilon\\,\\partial_n u$ 的法向通量值）。目标是数值验证，在离散化和求解器容差范围内，边界通量之和为零的电荷中性恒等式，即，当 $u$ 使用守恒离散化在网格上计算时，积分恒等式\n$$\n\\sum_{\\text{Neumann sides}} \\int_{\\Gamma_N} \\epsilon\\,\\partial_n u\\,ds \\;=\\; -\\sum_{\\text{Dirichlet sides}} \\int_{\\Gamma_D} \\epsilon\\,\\partial_n u\\,ds\n$$\n成立。此问题中的所有物理量必须使用国际单位制（SI单位）表示。电势 $u$ 的单位是伏特，介电常数 $\\epsilon$ 的单位是法拉每米，长度单位是米，边界积分 $\\int \\epsilon\\,\\partial_n u\\,ds$ 的单位是库仑每米。\n\n您的任务是编写一个完整的程序，对下面定义的每个测试用例，构建一个矩形网格上的均匀单元中心有限体积离散化，施加混合边界条件（在给定的电极段上为狄利克雷条件，其他地方为诺伊曼条件），求解得到的线性系统以获得 $u$，然后计算在 $\\Gamma_D$ 和 $\\Gamma_N$ 上的边积分以计算残差\n$$\nR \\;=\\; \\left|\\;\\sum_{\\Gamma_N}\\int_{\\Gamma_N}\\epsilon\\,\\partial_n u\\,ds \\;+\\; \\sum_{\\Gamma_D}\\int_{\\Gamma_D}\\epsilon\\,\\partial_n u\\,ds\\;\\right|\n$$\n单位为库仑每米。您的程序必须为每个测试报告单个浮点数 $R$。\n\n基本原理和数值执行要求：\n- 以 $\\nabla\\cdot\\mathbf{D} = 0$（其中 $\\mathbf{D} = -\\epsilon\\nabla u$）和域内无自由电荷为物理出发点。在此设定下，电势 $u$ 满足 $\\nabla\\cdot(\\epsilon\\nabla u)=0$。\n- 通过对每个控制体进行积分并近似面法向导数，以守恒形式离散化算子。在具有 $N_x\\times N_y$ 个尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$ 的矩形单元的均匀网格上，使用单元中心有限体积法。\n- 在内表面上，使用一种一致的表面介电常数，以保持法向通量在材料跳变处的连续性。一个标准的选择是在每个面上使用相邻单元介电常数的调和平均值。在与一个单元相邻的边界面上，使用该相邻内部单元的介电常数。\n- 通过消除虚单元值并将面法向电势导数表示为内部单元中心电势和给定边界值的形式，来施加狄利克雷边界条件。通过在有限体积残差中规定 $\\epsilon\\,\\partial_n u=g(s)$ 作为一个边通量项，来施加诺伊曼边界条件，其中 $s$ 是沿该边的弧长坐标。假设平面外方向的厚度为单位厚度。\n- 求解出 $u$ 后，按如下方式计算边积分：\n  - 对于每个狄利克雷边界面，将 $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ 近似为 $\\epsilon \\, (u_B - u_C)/d \\times \\ell$，其中 $u_B$ 是该面元上给定的边界电势，$u_C$ 是相邻内部单元中心的电势，$d$ 是从该单元中心到边界沿外法线方向的距离，$\\ell$ 是该面元的长度。\n  - 对于给定数据为 $g(s)=\\epsilon\\,\\partial_n u$ 的每个诺伊曼边界面，将 $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ 近似为 $g(s_f)\\times \\ell$，其中 $s_f$ 是面中心的弧长坐标，$\\ell$ 是面长度。在诺伊曼条件为齐次的地方使用 $g(s)=0$。\n您的实现必须确保离散算子和积分计算之间的数值一致性，使得任何残差 $R$ 仅反映数值误差。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，您必须使用指定的几何形状、材料、网格和边界数据。所有角度都应以弧度处理。\n\n- 测试 1 (标准路径，均匀介质，除电极外侧面绝缘):\n  - 区域: $L_x = 0.01\\,\\text{m}$, $L_y = 0.01\\,\\text{m}$.\n  - 网格: $N_x = 64$, $N_y = 64$.\n  - 介电常数: $\\epsilon(x,y) = \\epsilon_r \\epsilon_0$，其中 $\\epsilon_r = 3.2$ 且 $\\epsilon_0 = 8.854187817\\times 10^{-12}\\,\\text{F/m}$。\n  - 狄利克雷电极:\n    - 顶边，对于 $x\\in[0.3L_x,\\,0.7L_x]$: $u=1.0\\,\\text{V}$。\n    - 底边，对于 $x\\in[0.1L_x,\\,0.2L_x]$: $u=0.0\\,\\text{V}$。\n  - 其他地方为诺伊曼条件: 齐次，即在所有其他边界段上 $g(s)=0$。\n\n- 测试 2 (非均匀介质，一侧有非零诺伊曼条件):\n  - 区域: $L_x = 0.02\\,\\text{m}$, $L_y = 0.02\\,\\text{m}$.\n  - 网格: $N_x = 60$, $N_y = 60$.\n  - 介电常数: 分段函数，若 $x  L_x/2$，则 $\\epsilon(x,y) = \\epsilon_0$；若 $x \\ge L_x/2$，则 $\\epsilon(x,y) = 4\\epsilon_0$。\n  - 狄利克雷电极:\n    - 左边，对于 $y\\in[0.4L_y,\\,0.7L_y]$: $u=0.0\\,\\text{V}$。\n    - 顶边，对于 $x\\in[0.5L_x,\\,0.9L_x]$: $u=5.0\\,\\text{V}$。\n  - 右侧的诺伊曼边界条件: $g(y) = 1.0\\times 10^{-7}\\,\\big(0.5 + 0.5\\sin(2\\pi y/L_y)\\big)\\,\\text{C/m}^2$。\n  - 其他地方为诺伊曼条件: 齐次，即 $g(s)=0$。\n\n- 测试 3 (角点附近的小电极，顶边为常数诺伊曼条件):\n  - 区域: $L_x = 0.03\\,\\text{m}$, $L_y = 0.015\\,\\text{m}$.\n  - 网格: $N_x = 80$, $N_y = 40$.\n  - 介电常数: $\\epsilon(x,y)=2\\epsilon_0$。\n  - 狄利克雷电极:\n    - 底边，对于 $x\\in[0.0,\\,0.005]$: $u=0.0\\,\\text{V}$。\n    - 右边，对于 $y\\in[0.0,\\,0.004]$: $u=1.0\\,\\text{V}$。\n  - 顶边的诺伊曼边界条件: $g(x) = -5.0\\times 10^{-8}\\,\\text{C/m}^2$ (常数)。\n  - 其他地方为诺伊曼条件: 齐次，即 $g(s)=0$。\n\n输出规范：\n- 对于每个测试用例，计算如上定义的残差 $R$，单位为库仑每米。\n- 您的程序应生成单行输出，其中包含三个残差，按测试1、测试2、测试3的顺序，以逗号分隔列表形式并用方括号括起来。例如：\"[r1,r2,r3]\"。\n- 每个 $r_i$ 必须是一个浮点数。不应打印任何额外文本。\n\n所有数值步骤和执行选择必须在您提交的程序中实现。无需用户输入。正确性标准是，如果边界条件被正确施加且离散化是守恒的，每个残差 $r_i$ 应很小（接近于零），其偏差仅归因于数值近似和求解器容差。所有计算出的残差都以库仑每米表示。", "solution": "该问题要求对二维静电系统中的电荷中性 $\\oint_{\\partial\\Omega} \\epsilon \\partial_n u \\, ds = 0$ 进行数值验证，该系统由 $\\nabla \\cdot (\\epsilon \\nabla u) = 0$ 控制。这是通过使用单元中心有限体积法实现的。该方法的核心在于对每个网格单元（控制体）积分控制方程，并应用散度定理。\n\n对于一个中心为 $(x_i, y_j)$ 的单元 $V_{i,j}$，这会得到：\n$$\n\\int_{V_{i,j}} \\nabla \\cdot (\\epsilon \\nabla u) \\, dV = \\oint_{\\partial V_{i,j}} (\\epsilon \\nabla u) \\cdot \\mathbf{n}_{\\text{cell}} \\, dS = 0\n$$\n其中 $\\mathbf{n}_{\\text{cell}}$ 是从单元边界 $\\partial V_{i,j}$ 指向外部的法向量。边界积分是单元四个面（东、西、南、北）通量之和：\n$$\nF_E + F_W + F_N + F_S = 0\n$$\n每个通量项 $F$ 表示 $\\epsilon \\nabla u$ 的法向分量在单元面上的积分。例如，流出东面的通量是 $F_E = \\int_{\\text{east face}} \\epsilon \\frac{\\partial u}{\\partial x} \\, dy$。\n\n**通量的离散化**\n\n通量使用单元中心电势之间的有限差分来近似。\n对于位于单元 $(i,j)$ 与其东边相邻单元 $(i+1,j)$ 之间的**内表面**，通量近似为：\n$$\nF_E \\approx \\left(\\epsilon_{i+1/2,j} \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x}\\right) \\Delta y\n$$\n这里，$u_{i,j}$ 是单元 $(i,j)$ 中心的电势，$\\epsilon_{i+1/2,j}$ 是界面处的介电常数。根据规定，我们使用调和平均值：$\\epsilon_{i+1/2,j} = \\frac{2\\epsilon_{i,j}\\epsilon_{i+1,j}}{\\epsilon_{i,j}+\\epsilon_{i+1,j}}$。这确保了电位移场 $\\mathbf{D}$ 的法向分量在材料界面上的连续性。\n\n对于**边界面**，通量的近似取决于边界条件。\n1.  **诺伊曼边界条件**：法向通量的值 $g(s) = \\epsilon \\partial_n u$ 是给定的。在长度为 $\\ell$ 的边界面上，流出单元的通量就是 $F_{\\text{bnd}} \\approx g(s_f)\\ell$，其中 $s_f$ 是面中心的坐标。这个值是一个已知的常数，并移到线性系统的右侧。\n\n2.  **狄利克雷边界条件**：边界上的电势 $u_B$ 是给定的。通量使用相邻内部单元的电势 $u_C$ 和边界电势 $u_B$ 来近似。对于距离单元中心为 $d$ 的面，法向导数为 $\\partial_n u \\approx (u_B - u_C)/d$（注意法线的符号）。问题给出了流出区域的通量积分公式：$\\int \\epsilon\\,\\partial_n u\\,ds \\approx \\epsilon_C (u_B-u_C)/d \\times \\ell$。流出单元的通量与此表达式一致。例如，对于单元 $(0,j)$ 的西面，从单元向外的法线是 $-\\hat{\\mathbf{x}}$，这也是从区域向外的法线。流出单元的通量是 $F_W = \\int -\\epsilon \\frac{\\partial u}{\\partial x} dy$。使用 $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{0,j}-u_B}{\\Delta x/2}$，通量变为 $F_W \\approx -\\epsilon_{0,j} \\frac{u_{0,j}-u_B}{\\Delta x/2} \\Delta y = \\epsilon_{0,j}\\frac{u_B-u_{0,j}}{\\Delta x/2}\\Delta y$。此项依赖于未知的 $u_{0,j}$，并且也为右侧贡献一个涉及 $u_B$ 的常数项。\n\n**线性系统与守恒性**\n\n为 $N_x \\times N_y$ 网格中的每个单元 $(i,j)$ 组装通量平衡方程，会得到一个包含 $N_x N_y$ 个线性方程的系统，可以写成矩阵形式 $A\\mathbf{u} = \\mathbf{b}$。这里，$\\mathbf{u}$ 是未知单元中心电势的向量，$A$ 是一个系数稀疏矩阵，$\\mathbf{b}$ 是包含边界条件贡献的右侧向量。\n\n这种守恒有限体积公式的一个关键特性是，如果我们将区域中所有单元的离散通量平衡方程相加，内部面上的通量会完全抵消。这是因为离开一个单元的通量与进入相邻单元的通量在大小上相同但符号相反。总和简化为：\n$$\n\\sum_{\\text{all boundary faces}} F_{\\text{bnd, out of cell}} = 0\n$$\n其中 $F_{\\text{bnd, out of cell}}$ 是用于构建矩阵系统 A 和向量 b 的离散通量表达式。问题要求计算残差 $R$，即流出区域边界的总通量的绝对值，使用与推导矩阵 $A$ 和向量 $\\mathbf{b}$ 一致的近似方法计算。由于守恒性质，对于离散系统的精确解，这个总和必须为零。任何非零结果仅归因于求解器的数值容差和浮点算术误差。\n\n**实现细节**\n\n对于每个测试用例，解决方案包括以下步骤：\n1.  **网格与材料设置**：定义区域大小、网格分辨率以及每个单元的介电常数 $\\epsilon(x,y)$。\n2.  **矩阵组装**：创建一个稀疏矩阵 $A$ 和一个向量 $\\mathbf{b}$。遍历每个单元 $(i,j)$，并对其四个面中的每一个，根据面是内部还是边界来计算相应的系数并更新 $A$ 和/或 $\\mathbf{b}$。对于诺伊曼边界，通量 $g(s)\\ell$ 从 $\\mathbf{b}$ 的相应项中减去。对于狄利克雷边界，项被分配到 $A$ 和 $\\mathbf{b}$ 中。\n3.  **求解**：使用 `scipy.sparse.linalg.spsolve` 求解线性系统 $A\\mathbf{u}=\\mathbf{b}$ 以获得电势向量 $\\mathbf{u}$。\n4.  **残差计算**：初始化总通量累加器为零。遍历所有边界面（左、右、底、顶）。对于每个面，使用规定的数值近似和新计算的电势 $u_{i,j}$ 计算流出区域的通量。将此通量加到累加器中。最终的残差 $R$ 是此总和的绝对值。\n对所有三个测试用例重复此过程，以生成所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Physical constant\n    EPS0 = 8.854187817e-12  # Permittivity of free space in F/m\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"name\": \"Test 1\",\n            \"Lx\": 0.01, \"Ly\": 0.01, \"Nx\": 64, \"Ny\": 64,\n            \"eps_func\": lambda x, y: 3.2 * EPS0,\n            \"bcs\": [\n                {'side': 'N', 'type': 'D', 'value': 1.0, 'range': (0.3, 0.7)},\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0.1, 0.2)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 2\",\n            \"Lx\": 0.02, \"Ly\": 0.02, \"Nx\": 60, \"Ny\": 60,\n            \"eps_func\": lambda x, y: EPS0 if x  0.01 else 4 * EPS0,\n            \"bcs\": [\n                {'side': 'W', 'type': 'D', 'value': 0.0, 'range': (0.4, 0.7)},\n                {'side': 'N', 'type': 'D', 'value': 5.0, 'range': (0.5, 0.9)},\n                {'side': 'E', 'type': 'N', 'value': lambda y, Ly: 1.0e-7 * (0.5 + 0.5 * np.sin(2 * np.pi * y / Ly)), 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 3\",\n            \"Lx\": 0.03, \"Ly\": 0.015, \"Nx\": 80, \"Ny\": 40,\n            \"eps_func\": lambda x, y: 2.0 * EPS0,\n            \"bcs\": [\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0, 0.005)},\n                {'side': 'E', 'type': 'D', 'value': 1.0, 'range': (0, 0.004)},\n                {'side': 'N', 'type': 'N', 'value': -5.0e-8, 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = solve_one_case(case)\n        results.append(res)\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef solve_one_case(case_params):\n    \"\"\"\n    Solves a single electrostatic problem using a finite volume method.\n    \"\"\"\n    Lx, Ly = case_params[\"Lx\"], case_params[\"Ly\"]\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    eps_func = case_params[\"eps_func\"]\n    \n    dx, dy = Lx / Nx, Ly / Ny\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    \n    eps_grid = np.zeros((Ny, Nx))\n    for j in range(Ny):\n        for i in range(Nx):\n            eps_grid[j, i] = eps_func(x_centers[i], y_centers[j])\n\n    def get_bc_for_face(side, index):\n        coord = 0.0\n        domain_len = 0.0\n        if side in ['N', 'S']:\n            coord = x_centers[index]\n            domain_len = Lx\n        else:  # 'W', 'E'\n            coord = y_centers[index]\n            domain_len = Ly\n\n        for bc in case_params['bcs']:\n            if bc['side'] == side:\n                is_relative_range = all(0.0 = val = 1.0 for val in bc['range'])\n                start, end = bc['range']\n                \n                if is_relative_range:\n                    start *= domain_len\n                    end   *= domain_len\n\n                if start = coord  end:\n                    return bc['type'], bc['value']\n\n        return case_params['default_bc']['type'], case_params['default_bc']['value']\n\n    N_total = Nx * Ny\n    A = lil_matrix((N_total, N_total))\n    b = np.zeros(N_total)\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx\n            \n            # West Face\n            if i > 0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i-1] / (eps_grid[j, i] + eps_grid[j, i-1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k-1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('W', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, 0] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n\n            # East Face\n            if i  Nx - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i+1] / (eps_grid[j, i] + eps_grid[j, i+1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k+1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('E', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, -1] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n            \n            # South Face\n            if j > 0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j-1, i] / (eps_grid[j, i] + eps_grid[j-1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k - Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('S', i)\n                if bc_type == 'D':\n                    c = eps_grid[0, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n            \n            # North Face\n            if j  Ny - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j+1, i] / (eps_grid[j, i] + eps_grid[j+1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k + Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('N', i)\n                if bc_type == 'D':\n                    c = eps_grid[-1, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n    \n    u_vec = spsolve(A.tocsr(), b)\n    u_grid = u_vec.reshape((Ny, Nx))\n\n    total_flux = 0.0\n\n    # West (i=0): n_out = -x_hat, d_n u = -du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('W', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, 0] * (bc_val - u_grid[j, 0]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # East (i=Nx-1): n_out = +x_hat, d_n u = +du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('E', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, -1] * (bc_val - u_grid[j, -1]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # South (j=0): n_out = -y_hat, d_n u = -du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('S', i)\n        if bc_type == 'D':\n            flux = eps_grid[0, i] * (bc_val - u_grid[0, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n\n    # North (j=Ny-1): n_out = +y_hat, d_n u = +du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('N', i)\n        if bc_type == 'D':\n            flux = eps_grid[-1, i] * (bc_val - u_grid[-1, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n        \n    return abs(total_flux)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3305444"}, {"introduction": "最后，我们探索一个被称为离散外微分（Discrete Exterior Calculus, DEC）的现代化、优美的框架，它用微分几何的语言重塑了电磁理论。这项实践展示了狄利克雷和诺伊曼条件如何自然地表达为对生活在原始-对偶网格复形上的离散微分形式（上链）的约束。通过实现一个基于DEC的求解器，您不仅能处理边界条件，还能验证该框架如何以其离散形式自动保持斯托克斯定理和高斯定理等基本拓扑恒等式 [@problem_id:3305471]。", "problem": "考虑一个由单位正方形 $\\Omega = [0,1]\\times[0,1]$ 给出的二维单连通域。通过将 $\\Omega$ 细分为一个 $N\\times N$ 方格的均匀笛卡尔网格，并将每个方格沿一条对角线分割成两个三角形，得到一族协调的三角形网格 $\\{\\mathcal{T}_h\\}$，其中 $h = 1/N$。使用离散外微分（DEC）框架，在原始单纯复形及其外心对偶上，构建并求解标量势问题，并检验与斯托克斯（Stokes）定理和高斯（Gauss）定理相对应的离散积分恒等式。\n\n本问题的基本依据是：\n- 静电极限下的麦克斯韦方程组简化为标量电势 $u$ 的泊松方程 $-\\nabla\\cdot(\\nabla u)=f$。\n- 在离散外微分中，外导数由作用于 $k$-上链的余边缘算子 $d_k$ 表示，而霍奇星算子（Hodge star）将原始 $k$-上链映射到对偶 $(2-k)$-上链。$0$-上链上的离散拉普拉斯算子实现为 $L = d_0^\\top \\star_1 d_0$，其中 $\\star_1$ 是 $1$-上链上的离散霍奇星算子，$d_0$ 是从顶点到边的关联矩阵。\n- 狄利克雷（Dirichlet）边界条件对应于固定边界顶点上的 $0$-上链值。诺伊曼（Neumann）边界条件对应于固定边界 $(1)$-单纯形上的法向通量；在弱形式中，这对每个测试函数 $\\varphi$ 贡献一个边界积分 $\\int_{\\partial\\Omega} q\\,\\varphi\\,ds$。\n- 离散斯托克斯恒等式是指在任何单纯复形上 $d_1 d_0 = 0$ 成立，这对应于连续恒等式 $\\nabla\\times(\\nabla u) = \\mathbf{0}$。离散高斯（散度）定理指出，一个单元边界上的向外通量之和等于该单元上散度的积分；在使用精确积分时，此恒等式是精确的，而使用数值求积时，它近似满足并在网格加密下收敛。\n\n你需要在两个网格 $\\mathcal{T}_{h_c}$ 和 $\\mathcal{T}_{h_f}$（其中 $h_c = 1/8$ 和 $h_f = 1/16$）上实现以下实验：\n\n1) 狄利克雷问题（在 $0$-上链上强施加）。考虑精确解 $u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，它满足 $-\\Delta u^\\star = f$，其中 $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，以及齐次狄利克雷边界条件 $u^\\star|_{\\partial\\Omega}=0$。使用DEC，其中刚度算子为 $K = d_0^\\top \\star_1 d_0$，集中质量矩阵为 $M=\\star_0$（一个由原始-对偶顶点体积构成的对角矩阵），求解离散系统 $K u = M f$，并在边界顶点上固定狄利克雷值为 $u^\\star$。计算离散 $L^2$ 误差\n$$\nE_D(h) = \\sqrt{(u - u^\\star)^\\top M (u - u^\\star)}.\n$$\n报告 $E_D(h_c)$ 和 $E_D(h_f)$ 作为无量纲浮点数。\n\n2) 诺伊曼问题（通过 $1$-单纯形上的边界通量自然施加）。考虑 $u^\\star(x,y)=x$，因此 $-\\Delta u^\\star = 0$，诺伊曼边界数据为 $q = \\nabla u^\\star \\cdot \\mathbf{n}$，其中 $\\mathbf{n}$ 是单位外法向量。这得到在 $x=0$ 上 $q=-1$，在 $x=1$ 上 $q=+1$，在 $y=0$ 和 $y=1$ 上 $q=0$。组装相同的刚度算子 $K$，并将右端项设置为边界贡献 $b_i = \\int_{\\partial\\Omega} q \\,\\varphi_i\\, ds$，其中 $\\{\\varphi_i\\}$ 是 $\\mathcal{T}_h$ 上的标准分片线性节点基函数。在每个边界边上使用梯形法则，对于线性 $\\varphi_i$，这精确地等效于将边上的贡献均分给其两个端点。通过约束 $u$ 的均值为零来施加相容性条件。从增广线性系统中求解 $u$。计算梯度在三角形上的面积加权 $L^2$ 误差：\n$$\nE_N(h) = \\sqrt{\\sum_{T\\in \\mathcal{T}_h} |T| \\,\\|\\nabla u|_{T} - \\nabla u^\\star\\|_2^2},\n$$\n其中 $\\nabla u|_T$ 是在三角形 $T$ 上由其节点值得到的常数梯度，且 $\\nabla u^\\star = [1,0]^\\top$。报告 $E_N(h_c)$ 和 $E_N(h_f)$ 作为无量纲浮点数。\n\n3) 离散斯托克斯恒等式检验。对于每个网格上的一个随机 $0$-上链 $u$，计算 $2$-上链 $d_1(d_0 u)$ 并验证其在数值容差范围内是零上链。报告一个布尔值，指示 $\\|d_1 d_0 u\\|_2  10^{-12}$ 是否在两个网格上都成立。\n\n4) 离散高斯（散度）近似和加密行为。考虑向量场 $\\mathbf{v}(x,y) = [x^2,\\, y]^\\top$，其散度为 $\\nabla\\cdot\\mathbf{v} = 2x + 1$。对于每个三角形 $T\\in \\mathcal{T}_h$，通过使用中点求值法对其三条边上的向外法向通量求和来近似平均散度：\n$$\n\\overline{\\operatorname{div}}_h(T) = \\frac{1}{|T|} \\sum_{e\\subset \\partial T} \\left(\\mathbf{v}(\\mathbf{m}_e)\\cdot \\mathbf{n}_{e\\to T}\\right)\\,\\ell_e,\n$$\n其中 $\\mathbf{m}_e$ 是边的中点，$\\mathbf{n}_{e\\to T}$ 是边 $e$ 相对于三角形 $T$ 的单位外法向量，$\\ell_e$ 是边 $e$ 的长度。对于线性散度，在 $T$ 上的精确平均散度为 $\\overline{\\operatorname{div}}(T)=2x_c+1$，其中 $x_c$ 是 $T$ 的形心的 $x$ 坐标。计算面积加权 $L^2$ 误差：\n$$\nE_G(h) = \\sqrt{\\sum_{T\\in \\mathcal{T}_h} |T|\\,\\left(\\overline{\\operatorname{div}}_h(T) - (2x_c+1)\\right)^2}.\n$$\n报告 $E_G(h_c)$ 和 $E_G(h_f)$，以及一个布尔值，当且仅当 $E_G(h_f)  E_G(h_c)/2$ 时为真。\n\n测试套件和要求输出：\n- 使用两个网格，其中 $N\\in\\{8,16\\}$。\n- 按顺序计算并汇总以下结果：\n  1. $E_D(h_c)$,\n  2. $E_D(h_f)$,\n  3. $E_N(h_c)$,\n  4. $E_N(h_f)$,\n  5. 一个表示斯托克斯恒等式在两个网格上是否成立的布尔值，\n  6. $E_G(h_c)$,\n  7. $E_G(h_f)$,\n  8. 一个表示高斯误差是否至少减小了2倍的布尔值。\n- 所有浮点数都是无量纲的。不涉及角度。不涉及百分比。\n\n最终输出格式：\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6,result7,result8]”）。布尔值必须显示为字面量“True”或“False”，浮点数使用标准十进制表示法。", "solution": "用户的问题是在计算电磁学领域内一组适定的数值实验，它在离散外微分（DEC）的框架下构建。该问题具有科学依据，是客观的，并包含足够的信息以进行求解。未检测到任何使其无效的缺陷。\n\n解决方案需要在二维均匀三角形网格上实现一个用于标量泊松方程的DEC求解器。这包括以下几个步骤：\n1.  **网格生成**：为给定的网格分辨率 $N$ 创建原始单纯复形（顶点、边、三角形）的程序。域 $\\Omega = [0,1]\\times[0,1]$ 被离散化为一个 $N \\times N$ 的方格网格，其中每个方格通过一条对角线被剖分成两个直角三角形。\n2.  **算子组装**：构造与外导数（$d_0, d_1$）和霍奇星算子（$\\star_0, \\star_1$）相对应的离散算子。\n    -   余边缘算子 $d_0$ 是将顶点映射到边的关联矩阵。它代表离散梯度。\n    -   余边缘算子 $d_1$ 将边映射到三角形，并代表离散旋度。基本性质 $d_1 d_0 = 0$ 是 $\\nabla \\times (\\nabla u) = \\mathbf{0}$ 的离散模拟。\n    -   霍奇星算子在原始复形和对偶复形之间进行映射。对于此特定网格上指定的外心对偶，它们具有简单的结构。$1$-上链上的霍奇星算子 $\\star_1$ 是一个对角矩阵，其对角元对于轴对齐的边为 $1$，对于对角线边为 $0$。$0$-上链上的霍奇星算子 $\\star_0$ 是一个对角矩阵，其对角元是围绕每个原始顶点的对偶Voronoi单元的面积。\n3.  **问题1：狄利克雷边界条件**：泊松方程 $-\\Delta u = f$ 被离散化为 $K u = M f$，其中 $K = d_0^\\top \\star_1 d_0$ 是刚度矩阵（离散拉普拉斯算子），$M = \\star_0$ 是质量矩阵。对于给定的精确解 $u^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，源项是 $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，边界条件是 $u|_{\\partial\\Omega}=0$。通过对内部和边界顶点进行划分，并强制施加已知的边界值来求解离散系统。误差在离散 $L^2$-范数下度量，$E_D(h) = \\sqrt{(u - u^\\star)^\\top M (u - u^\\star)}$。\n4.  **问题2：诺伊曼边界条件**：对于 $u^\\star(x,y) = x$，我们有 $-\\Delta u=0$ 以及跨越边界的诺伊曼通量 $q = \\nabla u^\\star \\cdot \\mathbf{n}$。离散系统 $K u = b$ 的右端项现在来自于边界积分 $\\int_{\\partial\\Omega} q \\varphi_i ds$，该积分通过对每个边界边应用梯形法则来计算。得到的线性系统是奇异的，这反映了解仅在相差一个常数的情况下是确定的。通过施加 $u$ 的均值为零的约束来获得唯一解，这通过在增广系统中使用拉格朗日乘子实现。误差 $E_N(h)$ 在梯度的 $L^2$-范数下度量。\n5.  **问题3：离散斯托克斯恒等式**：通过将复合算子应用于一个随机的 $0$-上链 $u$，并检查得到的 $2$-上链 $d_1(d_0 u)$ 是否在机器精度内为零向量，来数值验证恒等式 $d_1 d_0 = 0$。\n6.  **问题4：离散高斯定理**：使用散度定理在每个三角形上近似向量场 $\\mathbf{v}(x,y) = [x^2, y]^\\top$ 的散度：即对通过三角形各边的通量求和。将此数值近似与三角形上的精确平均散度进行比较。计算总的面积加权 $L^2$ 误差 $E_G(h)$，并检查其在网格加密时的收敛行为。\n\n这四个实验将在两个网格分辨率 $N=8$ 和 $N=16$ 下执行，并报告指定的数值结果。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run all DEC experiments and print the final results.\n    \"\"\"\n\n    def get_triangle_grad_matrix_inv(p1, p2, p3):\n        \"\"\"Computes the inverse of the matrix used to find the gradient on a triangle.\"\"\"\n        mat = np.array([[p2[0] - p1[0], p2[1] - p1[1]],\n                        [p3[0] - p1[0], p3[1] - p1[1]]])\n        return np.linalg.inv(mat)\n\n    def run_experiments(N):\n        \"\"\"\n        Runs all experiments for a given mesh size N.\n        \"\"\"\n        h = 1.0 / N\n\n        # --- Part 1: Mesh Generation ---\n        num_verts = (N + 1) * (N + 1)\n        verts = np.zeros((num_verts, 2))\n        for j in range(N + 1):\n            for i in range(N + 1):\n                idx = j * (N + 1) + i\n                verts[idx] = [i * h, j * h]\n\n        num_tris = 2 * N * N\n        tris = np.zeros((num_tris, 3), dtype=int)\n        for j in range(N):\n            for i in range(N):\n                v00 = j * (N + 1) + i\n                v01 = j * (N + 1) + (i + 1)\n                v10 = (j + 1) * (N + 1) + i\n                v11 = (j + 1) * (N + 1) + (i + 1)\n                \n                # Triangles with consistent CCW orientation\n                tris[2 * (j * N + i)] = [v00, v01, v11]\n                tris[2 * (j * N + i) + 1] = [v00, v11, v10]\n        \n        edge_map = {}\n        edge_is_diagonal = []\n        for tri in tris:\n            t_edges = [tuple(sorted((tri[0], tri[1]))),\n                       tuple(sorted((tri[1], tri[2]))),\n                       tuple(sorted((tri[2], tri[0])))]\n            for edge in t_edges:\n                if edge not in edge_map:\n                    edge_map[edge] = len(edge_map)\n                    p1, p2 = verts[edge[0]], verts[edge[1]]\n                    is_diag = not (np.isclose(p1[0], p2[0]) or np.isclose(p1[1], p2[1]))\n                    edge_is_diagonal.append(is_diag)\n\n        edges = np.array([list(k) for k, v in sorted(edge_map.items(), key=lambda item: item[1])])\n        num_edges = len(edges)\n\n        # --- Part 2: DEC Operator Assembly ---\n        d0_rows, d0_cols, d0_data = [], [], []\n        for i, edge in enumerate(edges):\n            v1, v2 = edge\n            d0_rows.extend([i, i]); d0_cols.extend([v1, v2]); d0_data.extend([-1, 1])\n        d0 = sparse.csc_matrix((d0_data, (d0_rows, d0_cols)), shape=(num_edges, num_verts))\n\n        star1_diag = [0.0 if is_diag else 1.0 for is_diag in edge_is_diagonal]\n        star1 = sparse.diags(star1_diag, format='csc')\n        \n        K = d0.T @ star1 @ d0\n\n        star0_diag = np.zeros(num_verts)\n        for j in range(N + 1):\n            for i in range(N + 1):\n                idx = j * (N + 1) + i\n                is_on_x_bdy = (i == 0 or i == N)\n                is_on_y_bdy = (j == 0 or j == N)\n                if is_on_x_bdy and is_on_y_bdy: star0_diag[idx] = 0.25 * h**2\n                elif is_on_x_bdy or is_on_y_bdy: star0_diag[idx] = 0.5 * h**2\n                else: star0_diag[idx] = h**2\n        M = sparse.diags(star0_diag, format='csc')\n\n        # --- Experiment 1: Dirichlet Problem ---\n        f_vals = 2 * np.pi**2 * np.sin(np.pi * verts[:, 0]) * np.sin(np.pi * verts[:, 1])\n        b = M @ f_vals\n        u_exact_vals = np.sin(np.pi * verts[:, 0]) * np.sin(np.pi * verts[:, 1])\n\n        boundary_verts = [idx for idx in range(num_verts) if (\n            np.isclose(verts[idx, 0], 0.0) or np.isclose(verts[idx, 0], 1.0) or\n            np.isclose(verts[idx, 1], 0.0) or np.isclose(verts[idx, 1], 1.0))]\n        interior_verts = np.setdiff1d(np.arange(num_verts), boundary_verts)\n\n        K_II = K[interior_verts, :][:, interior_verts]\n        b_I = b[interior_verts] - K[interior_verts, :][:, boundary_verts] @ u_exact_vals[boundary_verts]\n        u_I = spsolve(K_II, b_I)\n\n        u_sol = np.zeros(num_verts); u_sol[interior_verts] = u_I\n        u_sol[boundary_verts] = u_exact_vals[boundary_verts]\n        \n        err_vec = u_sol - u_exact_vals\n        E_D = np.sqrt(err_vec.T @ M @ err_vec)\n\n        # --- Experiment 2: Neumann Problem ---\n        b_N = np.zeros(num_verts)\n        boundary_edges = [i for i,e in enumerate(edges) if e[0] in boundary_verts and e[1] in boundary_verts and (\n                          (np.isclose(verts[e[0],0], verts[e[1],0]) and (np.isclose(verts[e[0],0],0) or np.isclose(verts[e[0],0],1))) or\n                          (np.isclose(verts[e[0],1], verts[e[1],1]) and (np.isclose(verts[e[0],1],0) or np.isclose(verts[e[0],1],1))))]\n        \n        for edge_idx in boundary_edges:\n            v1_idx, v2_idx = edges[edge_idx]\n            p1, p2 = verts[v1_idx], verts[v2_idx]\n            length = np.linalg.norm(p1 - p2)\n            \n            q1, q2 = 0.0, 0.0\n            if np.isclose(p1[0], 0.0): q1 = -1.0\n            elif np.isclose(p1[0], 1.0): q1 = 1.0\n            if np.isclose(p2[0], 0.0): q2 = -1.0\n            elif np.isclose(p2[0], 1.0): q2 = 1.0\n                \n            b_N[v1_idx] += length * (q1) / 2.0\n            b_N[v2_idx] += length * (q2) / 2.0\n        \n        aug_K = sparse.bmat([[K, np.ones((num_verts, 1))], [np.ones((1, num_verts)), None]], format='csc')\n        aug_b = np.concatenate([b_N, [0]])\n        u_N_aug = spsolve(aug_K, aug_b)\n        u_N = u_N_aug[:-1]\n\n        grad_err_sq_sum = 0.0\n        u_grad_exact = np.array([1.0, 0.0])\n        for tri in tris:\n            p1, p2, p3 = verts[tri[0]], verts[tri[1]], verts[tri[2]]\n            u1, u2, u3 = u_N[tri[0]], u_N[tri[1]], u_N[tri[2]]\n            grad_mat_inv = get_triangle_grad_matrix_inv(p1, p2, p3)\n            u_grad_num = grad_mat_inv @ np.array([u2 - u1, u3 - u1])\n            area = 0.5 * h**2\n            grad_err_sq_sum += area * np.sum((u_grad_num - u_grad_exact)**2)\n        E_N = np.sqrt(grad_err_sq_sum)\n\n        # --- Experiment 3: Discrete Stokes Identity ---\n        d1_rows, d1_cols, d1_data = [], [], []\n        for i, tri in enumerate(tris):\n            v1, v2, v3 = tri\n            e1, e2, e3 = tuple(sorted((v1, v2))), tuple(sorted((v2, v3))), tuple(sorted((v3, v1)))\n            s1 = (1 if v1  v2 else -1)\n            s2 = (1 if v2  v3 else -1)\n            s3 = (1 if v3  v1 else -1)\n            d1_rows.extend([i, i, i]); d1_cols.extend([edge_map[e1], edge_map[e2], edge_map[e3]]); d1_data.extend([s1, s2, s3])\n        d1 = sparse.csc_matrix((d1_data, (d1_rows, d1_cols)), shape=(num_tris, num_edges))\n\n        u_rand = np.random.rand(num_verts)\n        stokes_check_val = np.linalg.norm(d1 @ (d0 @ u_rand))\n        stokes_check = stokes_check_val  1e-12\n\n        # --- Experiment 4: Discrete Gauss Theorem ---\n        gauss_err_sq_sum = 0.0\n        v_field = lambda p: np.array([p[0]**2, p[1]])\n        for tri in tris:\n            p1, p2, p3 = verts[tri[0]], verts[tri[1]], verts[tri[2]]\n            area = 0.5 * h**2\n            tri_edges_pts = [(p1, p2), (p2, p3), (p3, p1)]\n            total_flux = 0.0\n            for p_start, p_end in tri_edges_pts:\n                edge_vec = p_end - p_start\n                normal = np.array([edge_vec[1], -edge_vec[0]])\n                total_flux += np.dot(v_field((p_start + p_end) / 2.0), normal)\n\n            div_h = total_flux / area\n            centroid = (p1 + p2 + p3) / 3.0\n            div_exact_mean = 2 * centroid[0] + 1\n            gauss_err_sq_sum += area * (div_h - div_exact_mean)**2\n        E_G = np.sqrt(gauss_err_sq_sum)\n\n        return E_D, E_N, stokes_check, E_G\n\n    test_cases = [8, 16]\n    E_D_c, E_N_c, stokes_c, E_G_c = run_experiments(test_cases[0])\n    E_D_f, E_N_f, stokes_f, E_G_f = run_experiments(test_cases[1])\n    \n    stokes_ok = stokes_c and stokes_f\n    gauss_conv_ok = E_G_f  E_G_c / 2.0\n    \n    final_results = [\n        E_D_c, E_D_f,\n        E_N_c, E_N_f,\n        stokes_ok,\n        E_G_c, E_G_f,\n        gauss_conv_ok\n    ]\n    \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3305471"}]}