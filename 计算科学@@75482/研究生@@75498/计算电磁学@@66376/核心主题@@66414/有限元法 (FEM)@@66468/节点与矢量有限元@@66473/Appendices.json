{"hands_on_practices": [{"introduction": "有限元方法的核心在于将复杂的连续问题分解为在简单几何单元（如四面体）上的局部计算。本练习将指导您从第一性原理出发，推导最低阶 Nédélec 矢量单元的单元刚度矩阵 $K$ 和质量矩阵 $M$。通过这个过程，您将深刻理解材料属性（$\\mu$ 和 $\\epsilon$）与单元几何（通过雅可比矩阵 $J$ 体现）是如何被编码到有限元模型中的。[@problem_id:3334027]", "problem": "考虑在各向同性、分片常数介质中电磁场的频域旋度-旋度公式。在一个通过从参考四面体 $\\widehat{T}$（其顶点位于 $(0,0,0)$、$(1,0,0)$、$(0,1,0)$、$(0,0,1)$）进行的仿射映射得到的四面体单元 $T$ 上，使用与 $T$ 的边相关联的最低阶 Nédélec（第一类）边基函数 $\\{N_i\\}$。设 $\\mu>0$ 和 $\\epsilon>0$ 在 $T$ 上为常数（无量纲单位）。从第一性原理出发，即：\n- 参考四面体上最低阶 Nédélec 基函数依据重心坐标 $\\{\\lambda_a\\}_{a=1}^4$ 及其梯度的定义，\n- 由 $x = J \\,\\hat{x} + b$ 给出的仿射映射 $F:\\widehat{T}\\to T$，其中雅可比矩阵 $J\\in\\mathbb{R}^{3\\times 3}$ 为常数，平移向量 $b\\in\\mathbb{R}^3$，\n- 保持 $H(\\mathrm{curl})$ 场切向分量不变的协变 Piola 变换以及仿射映射下旋度的诱导变换，\n推导单元矩阵\n$$\nK_{ij} \\;=\\; \\int_T \\mu^{-1}\\, (\\nabla\\times N_i)\\cdot(\\nabla\\times N_j)\\, dx,\n\\qquad\nM_{ij} \\;=\\; \\int_T \\epsilon\\, N_i\\cdot N_j\\, dx,\n$$\n用在 $\\widehat{T}$ 上的积分、雅可比矩阵 $J$ 及其相关的度量张量表示。你的推导必须明确展示基函数及其旋度如何变换，以及行列式和度量张量如何进入映射后的积分。然后，清晰地描述通过在 $\\widehat{T}$ 上进行映射求积来计算这些矩阵所需的算法步骤。\n\n最后，将您的公式应用于具有 $J=\\mathrm{diag}(2,3,4)$ 和任意平移 $b$（这对积分无关紧要）的特定仿射映射，使用如下的边枚举\n- 边 1: $(1,2)$,\n- 边 2: $(1,3)$,\n- 边 3: $(1,4)$,\n- 边 4: $(2,3)$,\n- 边 5: $(2,4)$,\n- 边 6: $(3,4)$,\n其中 $(a,b)$ 表示在 $\\widehat{T}$ 上从顶点 $a$ 到顶点 $b$ 的有向边。\n\n以 $\\mu$ 的函数形式，计算单个刚度矩阵项 $K_{12}$ 的闭式解。将您的最终答案表示为仅含 $\\mu$ 的单个闭式符号表达式。不包括单位。不要近似计算。", "solution": "该问题是有效的，因为它科学地基于计算电磁学的原理，特别是有限元方法。它适定、客观、自洽，并且需要一个标准但非平凡的推导。我们将首先推导仿射映射下单元刚度矩阵和质量矩阵的一般表达式，然后将结果应用于给定的特定情况。\n\n令物理四面体单元表示为 $T$，参考四面体表示为 $\\widehat{T}$。参考单元 $\\widehat{T}$ 的顶点为 $\\hat{v}_1=(0,0,0)$、$\\hat{v}_2=(1,0,0)$、$\\hat{v}_3=(0,1,0)$ 和 $\\hat{v}_4=(0,0,1)$。该参考单元的体积为 $\\mathrm{vol}(\\widehat{T}) = \\frac{1}{6}$。在 $\\widehat{T}$ 上的重心坐标是线性函数 $\\hat{\\lambda}_a(\\hat{x})$（对于 $a \\in \\{1,2,3,4\\}$），由 $\\hat{\\lambda}_a(\\hat{v}_b) = \\delta_{ab}$ 定义，其中 $\\delta_{ab}$ 是克罗内克 δ。它们由以下公式给出：\n$$\n\\hat{\\lambda}_1(\\hat{x}) = 1 - \\hat{x}_1 - \\hat{x}_2 - \\hat{x}_3, \\quad \\hat{\\lambda}_2(\\hat{x}) = \\hat{x}_1, \\quad \\hat{\\lambda}_3(\\hat{x}) = \\hat{x}_2, \\quad \\hat{\\lambda}_4(\\hat{x}) = \\hat{x}_3\n$$\n这些重心坐标相对于参考坐标 $\\hat{x}$ 的梯度是常向量：\n$$\n\\hat{\\nabla} \\hat{\\lambda}_1 = \\begin{pmatrix}-1 \\\\ -1 \\\\ -1\\end{pmatrix}, \\quad \\hat{\\nabla} \\hat{\\lambda}_2 = \\begin{pmatrix}1 \\\\ 0 \\\\ 0\\end{pmatrix}, \\quad \\hat{\\nabla} \\hat{\\lambda}_3 = \\begin{pmatrix}0 \\\\ 1 \\\\ 0\\end{pmatrix}, \\quad \\hat{\\nabla} \\hat{\\lambda}_4 = \\begin{pmatrix}0 \\\\ 0 \\\\ 1\\end{pmatrix}\n$$\n$\\widehat{T}$ 上的最低阶 Nédélec（第一类）基函数与四面体的 6 条边相关联。对于连接顶点 $\\hat{v}_a$ 和顶点 $\\hat{v}_b$ 的边 $\\hat{e}_i$，相应的向量基函数为：\n$$\n\\widehat{N}_i(\\hat{x}) = \\widehat{N}_{ab}(\\hat{x}) = \\hat{\\lambda}_a(\\hat{x}) \\hat{\\nabla} \\hat{\\lambda}_b - \\hat{\\lambda}_b(\\hat{x}) \\hat{\\nabla} \\hat{\\lambda}_a\n$$\n参考单元上此基函数的旋度是一个常向量：\n$$\n\\hat{\\nabla} \\times \\widehat{N}_{ab}(\\hat{x}) = \\hat{\\nabla} \\times (\\hat{\\lambda}_a \\hat{\\nabla} \\hat{\\lambda}_b) - \\hat{\\nabla} \\times (\\hat{\\lambda}_b \\hat{\\nabla} \\hat{\\lambda}_a) = (\\hat{\\nabla} \\hat{\\lambda}_a \\times \\hat{\\nabla} \\hat{\\lambda}_b) - (\\hat{\\nabla} \\hat{\\lambda}_b \\times \\hat{\\nabla} \\hat{\\lambda}_a) = 2 \\hat{\\nabla} \\hat{\\lambda}_a \\times \\hat{\\nabla} \\hat{\\lambda}_b\n$$\n\n物理单元 $T$ 通过仿射映射 $F(\\hat{x}) = x = J\\hat{x} + b$ 与 $\\widehat{T}$ 相关，其中 $J \\in \\mathbb{R}^{3\\times 3}$ 是常数雅可比矩阵，$b \\in \\mathbb{R}^3$ 是平移向量。微分算子和积分的变换规则如下：\n1. 微分体积元：$dx = |\\det(J)| d\\hat{x}$。假设映射保持定向，则为 $dx = \\det(J) d\\hat{x}$。\n2. 梯度算子：$\\nabla_x = (J^{-1})^T \\hat{\\nabla}_{\\hat{x}}$。\n3. $H(\\mathrm{curl})$ 场的协变 Piola 变换：$\\widehat{T}$ 上的向量场 $\\widehat{N}$ 变换为 $T$ 上的场 $N$，其形式为 $N(x) = (J^{-1})^T \\widehat{N}(\\hat{x})$，其中 $\\hat{x} = F^{-1}(x)$。此变换保持了向量场沿单元边的切向分量。\n4. 旋度算子变换：变换后场的旋度由 $\\nabla_x \\times N(x) = \\frac{1}{\\det(J)} J (\\hat{\\nabla}_{\\hat{x}} \\times \\widehat{N}(\\hat{x}))$ 给出。\n\n利用这些规则，我们可以将刚度矩阵 $K_{ij}$ 和质量矩阵 $M_{ij}$ 的积分从物理域 $T$ 变换到参考域 $\\widehat{T}$。\n\n首先，考虑质量矩阵项 $M_{ij}$：\n$$\nM_{ij} = \\int_T \\epsilon N_i(x) \\cdot N_j(x) dx\n$$\n代入 $N_i$、$N_j$ 和 $dx$ 的变换：\n$$\nM_{ij} = \\int_{\\widehat{T}} \\epsilon \\left( (J^{-1})^T \\widehat{N}_i(\\hat{x}) \\right) \\cdot \\left( (J^{-1})^T \\widehat{N}_j(\\hat{x}) \\right) \\det(J) d\\hat{x}\n$$\n点积可以重写为二次型：$(A\\mathbf{u})\\cdot(A\\mathbf{v}) = \\mathbf{u}^T A^T A \\mathbf{v}$。此处 $A=(J^{-1})^T$。因此 $A^T A = (J^{-1}) (J^{-1})^T = (J^T J)^{-1}$。令 $G = J^T J$ 为与映射相关的度量张量。则 $(J^T J)^{-1} = G^{-1}$。\n$$\nM_{ij} = \\epsilon \\det(J) \\int_{\\widehat{T}} \\widehat{N}_i(\\hat{x})^T G^{-1} \\widehat{N}_j(\\hat{x}) d\\hat{x}\n$$\n\n接下来，考虑刚度矩阵项 $K_{ij}$：\n$$\nK_{ij} = \\int_T \\mu^{-1} (\\nabla \\times N_i(x)) \\cdot (\\nabla \\times N_j(x)) dx\n$$\n代入旋度变换和体积元变换：\n$$\nK_{ij} = \\int_{\\widehat{T}} \\mu^{-1} \\left( \\frac{1}{\\det(J)} J (\\hat{\\nabla} \\times \\widehat{N}_i) \\right) \\cdot \\left( \\frac{1}{\\det(J)} J (\\hat{\\nabla} \\times \\widehat{N}_j) \\right) \\det(J) d\\hat{x}\n$$\n$$\nK_{ij} = \\frac{\\mu^{-1}}{\\det(J)} \\int_{\\widehat{T}} \\left( J (\\hat{\\nabla} \\times \\widehat{N}_i) \\right) \\cdot \\left( J (\\hat{\\nabla} \\times \\widehat{N}_j) \\right) d\\hat{x}\n$$\n点积可以重写为 $(\\hat{\\nabla} \\times \\widehat{N}_i)^T J^T J (\\hat{\\nabla} \\times \\widehat{N}_j) = (\\hat{\\nabla} \\times \\widehat{N}_i)^T G (\\hat{\\nabla} \\times \\widehat{N}_j)$。\n项 $\\hat{\\nabla} \\times \\widehat{N}_i$ 在 $\\widehat{T}$ 上是常向量。因此，整个被积函数是常数。积分就是被积函数乘以参考单元的体积，即 $\\mathrm{vol}(\\widehat{T}) = \\frac{1}{6}$。\n$$\nK_{ij} = \\frac{\\mu^{-1}}{\\det(J)} \\left( (\\hat{\\nabla} \\times \\widehat{N}_i)^T G (\\hat{\\nabla} \\times \\widehat{N}_j) \\right) \\mathrm{vol}(\\widehat{T})\n$$\n$$\nK_{ij} = \\frac{\\mu^{-1}}{6\\det(J)} (\\hat{\\nabla} \\times \\widehat{N}_i) \\cdot (G (\\hat{\\nabla} \\times \\widehat{N}_j))\n$$\n\n计算这些矩阵的算法步骤如下：\n1. 对于给定的具有顶点 $\\{v_k\\}_{k=1}^4$ 的物理单元 $T$，确定从 $\\widehat{T}$ 到 $T$ 的仿射映射的雅可比矩阵 $J$。如果 $\\hat{v}_1$ 映射到 $v_1$，则 $J$ 的列由 $v_2-v_1$、$v_3-v_1$ 和 $v_4-v_1$ 给出。\n2. 计算 $\\det(J)$ 和度量张量 $G = J^T J$。\n3. 在参考单元上预先计算并存储 6 个常旋度向量 $\\hat{C}_i = \\hat{\\nabla} \\times \\widehat{N}_i$。\n4. 为计算刚度矩阵 $K$，对每个矩阵项 $(i, j)$，计算 $K_{ij} = \\frac{\\mu^{-1}}{6\\det(J)} \\hat{C}_i^T G \\hat{C}_j$。\n5. 为计算质量矩阵 $M$，对每个矩阵项 $(i, j)$，计算积分 $M_{ij} = \\epsilon \\det(J) \\int_{\\widehat{T}} \\widehat{N}_i^T G^{-1} \\widehat{N}_j d\\hat{x}$。该积分涉及重心坐标的二次多项式，通常使用在 $\\widehat{T}$ 上对至少 2 次多项式精确的数值求积法则进行计算。\n\n现在，我们将其应用于给定的特定情况。雅可比矩阵为 $J = \\mathrm{diag}(2, 3, 4)$。\n行列式为 $\\det(J) = 2 \\times 3 \\times 4 = 24$。\n度量张量为 $G = J^T J = \\mathrm{diag}(2, 3, 4) \\mathrm{diag}(2, 3, 4) = \\mathrm{diag}(4, 9, 16)$。\n平移向量 $b$ 是无关紧要的，因为它在所有导数和被积函数的变换中都消失了。\n\n我们需要计算刚度矩阵项 $K_{12}$。这需要边 1 和边 2 的基函数。\n边 1 是 $(\\hat{v}_1, \\hat{v}_2)$，因此 $i=1$ 对应于对偶 $(a,b)=(1,2)$。\n边 2 是 $(\\hat{v}_1, \\hat{v}_3)$，因此 $j=2$ 对应于对偶 $(a,b)=(1,3)$。\n\n基函数 $\\widehat{N}_1 = \\widehat{N}_{12}$ 的旋度为：\n$$\n\\hat{\\nabla} \\times \\widehat{N}_1 = 2 (\\hat{\\nabla} \\hat{\\lambda}_1 \\times \\hat{\\nabla} \\hat{\\lambda}_2) = 2 \\left( \\begin{pmatrix}-1 \\\\ -1 \\\\ -1\\end{pmatrix} \\times \\begin{pmatrix}1 \\\\ 0 \\\\ 0\\end{pmatrix} \\right) = 2 \\begin{pmatrix}0 \\\\ -1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 2\\end{pmatrix}\n$$\n基函数 $\\widehat{N}_2 = \\widehat{N}_{13}$ 的旋度为：\n$$\n\\hat{\\nabla} \\times \\widehat{N}_2 = 2 (\\hat{\\nabla} \\hat{\\lambda}_1 \\times \\hat{\\nabla} \\hat{\\lambda}_3) = 2 \\left( \\begin{pmatrix}-1 \\\\ -1 \\\\ -1\\end{pmatrix} \\times \\begin{pmatrix}0 \\\\ 1 \\\\ 0\\end{pmatrix} \\right) = 2 \\begin{pmatrix}1 \\\\ 0 \\\\ -1\\end{pmatrix} = \\begin{pmatrix}2 \\\\ 0 \\\\ -2\\end{pmatrix}\n$$\n现在我们计算 $K_{12}$ 公式内的矩阵-向量乘积：\n$$\n(\\hat{\\nabla} \\times \\widehat{N}_1)^T G (\\hat{\\nabla} \\times \\widehat{N}_2) = \\begin{pmatrix}0 & -2 & 2\\end{pmatrix} \\begin{pmatrix}4 & 0 & 0 \\\\ 0 & 9 & 0 \\\\ 0 & 0 & 16\\end{pmatrix} \\begin{pmatrix}2 \\\\ 0 \\\\ -2\\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix}0 & -2 & 2\\end{pmatrix} \\begin{pmatrix}4 \\times 2 \\\\ 9 \\times 0 \\\\ 16 \\times (-2)\\end{pmatrix} = \\begin{pmatrix}0 & -2 & 2\\end{pmatrix} \\begin{pmatrix}8 \\\\ 0 \\\\ -32\\end{pmatrix}\n$$\n$$\n= (0)(8) + (-2)(0) + (2)(-32) = -64\n$$\n最后，我们将此值代入 $K_{12}$ 的表达式中：\n$$\nK_{12} = \\frac{\\mu^{-1}}{6\\det(J)} (-64) = \\frac{\\mu^{-1}}{6 \\times 24} (-64) = \\frac{-64}{144} \\mu^{-1}\n$$\n通过将分子和分母除以它们的最大公约数 16 来化简分数 $\\frac{-64}{144}$：\n$$\n\\frac{-64 \\div 16}{144 \\div 16} = \\frac{-4}{9}\n$$\n因此，刚度矩阵项 $K_{12}$ 是：\n$$\nK_{12} = -\\frac{4}{9} \\mu^{-1} = -\\frac{4}{9\\mu}\n$$", "answer": "$$\\boxed{-\\frac{4}{9\\mu}}$$", "id": "3334027"}, {"introduction": "在掌握了单元矩阵的计算和全局组装之后，我们将探索一个更深层次的数学结构，正是这个结构保证了矢量有限元方法的优越性。本练习要求您通过编程来验证，在由 Whitney 形式构建的有限元空间上，离散的梯度、旋度和散度算子（$D_0, D_1, D_2$）与拓扑学中的关联矩阵（$B_0, B_1, B_2$）是等价的。这一结果确认了离散 de Rham 序列的“正合性”，这也是 Nédélec 单元能够在适当的条件下消除“伪解”的根本原因。[@problem_id:3334023]", "problem": "构建一个完整的、可运行的程序，该程序使用 Whitney $1$-形式在单个四面体上实现第一类 Nédélec 边基函数，并通过伽辽金（Galerkin）投影数值验证离散正合序列\n$$\nH^1 \\xrightarrow{\\nabla} H(\\mathrm{curl}) \\xrightarrow{\\nabla \\times} H(\\mathrm{div}) \\xrightarrow{\\nabla \\cdot} L^2\n$$\n在一个可收缩网格上成立。\n\n您必须使用以下基础，从第一性原理出发进行推导和实现：\n\n- 矢量微积分的基本定律：梯度 $\\nabla$、旋度 $\\nabla \\times$、散度 $\\nabla \\cdot$ 和散度定理。\n- 单纯形上的 Whitney 形式及其与最低阶有限元空间的对应关系：Whitney $0$-形式（节点）、Whitney $1$-形式（第一类 Nédélec）、Whitney $2$-形式（基于面的 $H(\\mathrm{div})$ 场）和 Whitney $3$-形式（单元常数 $L^2$ 场）。\n- 由连续维度的单纯形之间的上边缘（关联）矩阵实现的离散外导数。\n- 在可收缩域上的正合性：每个映射的像等于下一个映射的核。\n\n使用具有以下顶点的单个四面体\n$$\n\\mathbf{v}_0=(0,0,0),\\quad \\mathbf{v}_1=(1,0,0),\\quad \\mathbf{v}_2=(0,1,0),\\quad \\mathbf{v}_3=(0,0,1),\n$$\n因此该域是可收缩的。设带方向的四面体为 $[0,1,2,3]$。使用全局定向的边作为有序对\n$$\n(0,1),\\ (0,2),\\ (0,3),\\ (1,2),\\ (1,3),\\ (2,3),\n$$\n以及由四面体边界给出的带方向的面\n$$\n[1,2,3],\\ [0,2,3],\\ [0,1,3],\\ [0,1,2],\n$$\n其标准边界方向符号分别为 $+1,-1,+1,-1$。\n\n在四面体上定义重心坐标 $\\{\\lambda_i\\}_{i=0}^3$，其梯度 $\\{\\nabla \\lambda_i\\}_{i=0}^3$ 为常数。定义基函数：\n\n- Whitney $0$-形式（节点）：对于顶点 $i$ 为 $\\lambda_i$。\n- 与有向边 $(i,j)$ 相关的 Whitney $1$-形式（第一类 Nédélec）：\n$$\n\\mathbf{N}_{ij}=\\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i.\n$$\n- 与有向面 $(i,j,k)$ 相关的 Whitney $2$-形式（$H(\\mathrm{div})$ 中的向量代理）：\n$$\n\\mathbf{W}_{ijk}=2\\left(\\lambda_i\\, (\\nabla \\lambda_j \\times \\nabla \\lambda_k) + \\lambda_j\\, (\\nabla \\lambda_k \\times \\nabla \\lambda_i) + \\lambda_k\\, (\\nabla \\lambda_i \\times \\nabla \\lambda_j)\\right).\n$$\n- Whitney $3$-形式基取为四面体上的常数标量 $\\chi_T = 1/|T|$，其中 $|T|$ 是四面体的体积，因此 $\\int_T \\chi_T\\, \\mathrm{d}V = 1$。\n\n使用这些基，构建在有限元空间上实现离散外导数的伽辽金矩阵：\n\n- 离散梯度矩阵 $D_0 \\in \\mathbb{R}^{E \\times V}$ 通过\n$$\nM_1 D_0 = P_0,\\quad (M_1)_{e,e'}=\\int_T \\mathbf{N}_e\\cdot \\mathbf{N}_{e'}\\, \\mathrm{d}V,\\quad (P_0)_{e,i}=\\int_T \\mathbf{N}_e \\cdot \\nabla \\lambda_i\\, \\mathrm{d}V.\n$$\n- 离散旋度矩阵 $D_1 \\in \\mathbb{R}^{F \\times E}$ 通过\n$$\nM_2 D_1 = P_1,\\quad (M_2)_{f,f'}=\\int_T \\mathbf{W}_f\\cdot \\mathbf{W}_{f'}\\, \\mathrm{d}V,\\quad (P_1)_{f,e}=\\int_T \\mathbf{W}_f \\cdot (\\nabla \\times \\mathbf{N}_e)\\, \\mathrm{d}V.\n$$\n- 离散散度矩阵 $D_2 \\in \\mathbb{R}^{T \\times F}$ 通过\n$$\nM_3 D_2 = P_2,\\quad M_3 = \\int_T \\chi_T^2\\, \\mathrm{d}V = \\frac{1}{|T|},\\quad (P_2)_{t,f}=\\int_T \\chi_T\\, (\\nabla \\cdot \\mathbf{W}_f)\\, \\mathrm{d}V.\n$$\n\n同时构建纯拓扑关联矩阵：\n\n- 边-顶点关联矩阵 $B_0 \\in \\mathbb{R}^{E \\times V}$，其元素在每个有向边的尾部为 $-1$，头部为 $+1$。\n- 面-边关联矩阵 $B_1 \\in \\mathbb{R}^{F \\times E}$，其元素由每个面的定向边界给出。\n- 体-面关联矩阵 $B_2 \\in \\mathbb{R}^{T \\times F}$，其元素由四面体的定向边界给出。\n\n然后，您必须数值验证伽辽金实现的离散导数可复现关联矩阵，并且离散复形在此可收缩网格上是正合的，具体如下：\n\n- 验证 $\\|D_0 - B_0\\|_{\\max} \\le \\tau$。\n- 验证 $\\|D_1 - B_1\\|_{\\max} \\le \\tau$。\n- 验证 $\\|D_2 - B_2\\|_{\\max} \\le \\tau$。\n- 验证 $\\|D_1 D_0\\|_{\\max} \\le \\tau$ 和 $\\|D_2 D_1\\|_{\\max} \\le \\tau$（离散正合性）。\n- 使用奇异值阈值 $\\sigma_{\\mathrm{th}} = \\epsilon \\cdot \\sigma_{\\max}$（其中 $\\epsilon$ 已给出）计算数值秩 $\\mathrm{rank}(D_0)$、$\\mathrm{rank}(D_1)$、$\\mathrm{rank}(D_2)$。\n\n所有积分必须使用标准的四面体重心坐标单项式积分恒等式精确计算：对于四面体体积 $|T|$，有 $\\int_T \\lambda_i\\, \\mathrm{d}V = |T|/4$，$\\int_T \\lambda_i^2\\, \\mathrm{d}V = |T|/10$，以及当 $i \\ne j$ 时 $\\int_T \\lambda_i \\lambda_j\\, \\mathrm{d}V = |T|/20$。\n\n测试套件：\n- 对所有矩阵和复合的比较使用容差 $\\tau = 10^{-10}$。\n- 对数值秩计算使用奇异值阈值参数 $\\epsilon = 10^{-12}$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\mathrm{b\\_grad},\\mathrm{b\\_curl},\\mathrm{b\\_div},\\mathrm{b\\_curl\\_grad},\\mathrm{b\\_div\\_curl},r_0,r_1,r_2],\n$$\n其中前五项是上述验证的布尔值，后三项是等于 $\\mathrm{rank}(D_0)$、$\\mathrm{rank}(D_1)$ 和 $\\mathrm{rank}(D_2)$ 的整数。不涉及物理单位；所有量均为无量纲。不使用角度。\n\n您的实现必须是完全自包含的，且不要求任何用户输入。结果必须对给定的四面体成立。程序必须在现代语言和环境中运行，并遵守指定的输出格式。", "solution": "任务是在单个四面体（其可作为一个可收缩域）上，数值验证离散 de Rham 序列的性质。这包括证明通过伽辽金有限元方法构建的离散微分算子（梯度、旋度、散度）等价于拓扑上边缘算子（关联矩阵），并且所得到的算子序列是正合的。\n\n首先，我们建立几何和拓扑设置。域是一个四面体 $T$，其顶点为 $\\mathbf{v}_0=(0,0,0)$、$\\mathbf{v}_1=(1,0,0)$、$\\mathbf{v}_2=(0,1,0)$ 和 $\\mathbf{v}_3=(0,0,1)$。其体积为 $|T|=1/6$。重心坐标 $\\lambda_i(\\mathbf{x})$ 是线性函数，其梯度 $\\nabla\\lambda_i$ 是常数向量。具体来说，对于点 $\\mathbf{x}=(x,y,z)$，我们有 $\\lambda_1=x, \\lambda_2=y, \\lambda_3=z$ 和 $\\lambda_0=1-x-y-z$。梯度为 $\\nabla\\lambda_0=(-1,-1,-1)$, $\\nabla\\lambda_1=(1,0,0)$, $\\nabla\\lambda_2=(0,1,0)$ 和 $\\nabla\\lambda_3=(0,0,1)$。\n\n问题使用 Whitney 形式作为基函数定义了四个有限元空间：\n1.  节点基 ($H^1$)：Whitney $0$-形式 $\\{\\lambda_i\\}_{i=0}^3$，与顶点相关联。\n2.  Nédélec 边基 ($H(\\mathrm{curl})$)：Whitney $1$-形式 $\\{\\mathbf{N}_{ij} = \\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i\\}$，与有向边 $(i,j)$ 相关联。\n3.  面基 ($H(\\mathrm{div})$)：Whitney $2$-形式 $\\{\\mathbf{W}_{ijk}\\}$，与有向面 $(i,j,k)$ 相关联。\n4.  体元基 ($L^2$)：一个 Whitney $3$-形式，选择为常数函数 $\\chi_T = 1/|T|$，与四面体体元相关联。\n\n问题的核心是构建梯度、旋度和散度算子的矩阵表示。这些离散算子记为 $D_0, D_1, D_2$，是通过伽辽金投影得到的。例如，为了找到 $u \\in \\mathrm{span}\\{\\lambda_i\\}$ 的 $\\nabla u$ 在边空间中的表示，我们将 $\\nabla \\lambda_i$ 投影到基 $\\{\\mathbf{N}_e\\}$ 上。这会导出一个线性系统 $M_1 D_0 = P_0$，其中 $M_1$ 是边元的质量矩阵，$P_0$ 是投影矩阵。类似的过程可得到 $D_1$ 和 $D_2$。所有矩阵项都是通过在四面体上对基函数或其导数的乘积进行积分来计算的。这些积分可以使用重心坐标单项式的公式精确计算：\n$$\n\\int_T \\prod_{k=0}^3 \\lambda_k^{\\alpha_k} \\,dV = \\frac{\\prod_{k=0}^3 \\alpha_k!}{(\\sum_{k=0}^3 \\alpha_k + 3)!} 3!|T|\n$$\n由于我们特定的四面体满足 $3!|T| = 6(1/6) = 1$，该公式简化为阶乘的比值。\n\n同时，我们构建拓扑关联矩阵 $B_0, B_1, B_2$。这些矩阵编码了网格的连通性：\n-   $B_0$（边-顶点）：其项 $(B_0)_{e,v}$ 在顶点 $v$ 是边 $e$ 的起点时为 -1，是终点时为 +1，否则为 0。\n-   $B_1$（面-边）：其项 $(B_1)_{f,e}$ 描述了边如何构成面的定向边界。\n-   $B_2$（体-面）：其项 $(B_2)_{c,f}$ 描述了面如何构成体元的定向边界。\n\n有限元外微分（FEEC）的一个基本结果指出，对于 Whitney 形式，涉及微分算子及其离散对应物的图是交换的。这意味着伽辽金矩阵 $D_k$ 应与关联矩阵 $B_k$ 相同。程序首先数值验证这个恒等式，即对于一个小的容差 $\\tau$，有 $\\|D_k - B_k\\|_{\\max} \\le \\tau$。\n\n第二个要验证的性质是离散序列的正合性，这是矢量微积分恒等式 $\\nabla \\times (\\nabla \\phi) = 0$ 和 $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$ 的离散模拟。这对应于检查离散算子的复合是否产生零矩阵：$D_1 D_0 = 0$ 和 $D_2 D_1 = 0$。这个性质是拓扑性质 $\\partial \\circ \\partial = 0$（边界的边界为空）的直接代数结果，这可以转换为 $B_1 B_0 = 0$ 和 $B_2 B_1 = 0$。由于我们期望 $D_k=B_k$，离散序列的正合性随之成立。\n\n最后，我们计算矩阵 $D_0, D_1, D_2$ 的数值秩。对于一个可收缩域，离散算子的秩由复形的贝蒂数决定，除了第0个贝蒂数外，其余均为零。第 k 个算子的秩通过秩-零度定理与空间的维数以及相邻算子的秩相关联。对于单个四面体（$V=4, E=6, F=4, T=1$），预测的秩为：\n-   $\\mathrm{rank}(D_0) = V-1 = 3$。\n-   $\\mathrm{rank}(D_1) = E - \\mathrm{rank}(D_0) - (\\text{欧拉示性数项}) = 6 - 3 = 3$。（因为在可收缩域上 $\\ker(D_1)=\\text{im}(D_0)$）。\n-   $\\mathrm{rank}(D_2) = F - \\mathrm{rank}(D_1) = 4 - 3 = 1$。\n数值秩是通过计算相对于最大奇异值而言显著的奇异值数量来确定的，这一过程由一个阈值参数 $\\epsilon$ 控制。\n\n实现过程是系统地构建这些矩阵，执行指定的数值验证，并计算秩，最终在这个典范例子上证实了 FEEC 的核心原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import factorial\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the discrete de Rham complex on a single tetrahedron.\n    \"\"\"\n    # -- 1. Problem Setup: Constants, Geometry, and Topology --\n\n    # Constants for numerical comparisons\n    tau = 1e-10\n    epsilon = 1e-12\n\n    # Geometric data for the reference tetrahedron\n    # The problem specifies these vertices.\n    verts = np.array([\n        [0., 0., 0.],  # v0\n        [1., 0., 0.],  # v1\n        [0., 1., 0.],  # v2\n        [0., 0., 1.]   # v3\n    ])\n    T_vol = 1.0 / 6.0  # Volume of the tetrahedron with these vertices\n\n    # Topological data (oriented simplices)\n    # The order defines the basis function and matrix indexing.\n    vertices = [0, 1, 2, 3]\n    edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n    faces = [(1, 2, 3), (0, 2, 3), (0, 1, 3), (0, 1, 2)]\n    \n    num_verts = len(vertices)\n    num_edges = len(edges)\n    num_faces = len(faces)\n    num_cells = 1\n\n    # Mappings for convenience to look up indices\n    edge_map = {edge: i for i, edge in enumerate(edges)}\n\n    # -- 2. Basis Functions and their Properties --\n\n    # Gradients of barycentric coordinates are constant vectors.\n    # For a point x, lambda_1=x, lambda_2=y, lambda_3=z, lambda_0=1-x-y-z.\n    grads = np.array([\n        [-1., -1., -1.],  # grad(lambda_0)\n        [ 1.,  0.,  0.],  # grad(lambda_1)\n        [ 0.,  1.,  0.],  # grad(lambda_2)\n        [ 0.,  0.,  1.]   # grad(lambda_3)\n    ])\n\n    # Precompute dot and cross products of gradients for efficiency\n    grad_dots = grads @ grads.T\n    grad_cross = np.zeros((num_verts, num_verts, 3))\n    for i in range(num_verts):\n        for j in range(num_verts):\n            grad_cross[i, j] = np.cross(grads[i], grads[j])\n\n    def tetra_integral(powers):\n        \"\"\"\n        Computes the exact integral of a monomial of barycentric coordinates over the tetrahedron.\n        Formula: Integral(Product(lambda_i^alpha_i)) = (Product(alpha_i!) * 3! * |T|) / (Sum(alpha_i) + 3)!.\n        For our tetrahedron, 3! * |T| = 1.\n        \"\"\"\n        numerator = 1.0\n        for p in powers:\n            numerator *= factorial(p)\n        denominator = factorial(sum(powers) + 3)\n        return numerator / denominator\n\n    # -- 3. Construction of Topological Incidence Matrices (B_k) --\n\n    # B0: Edge-Vertex incidence matrix (6x4)\n    B0 = np.zeros((num_edges, num_verts))\n    for i, edge in enumerate(edges):\n        B0[i, edge[0]] = -1.\n        B0[i, edge[1]] = 1.\n\n    # B1: Face-Edge incidence matrix (4x6)\n    B1 = np.zeros((num_faces, num_edges))\n    for i, face in enumerate(faces):\n        # Boundary of face (v0, v1, v2) is edges (v0,v1), (v1,v2), (v2,v0)\n        f_edges = [(face[0], face[1]), (face[1], face[2]), (face[2], face[0])]\n        for v_start, v_end in f_edges:\n            if (v_start, v_end) in edge_map:\n                B1[i, edge_map[(v_start, v_end)]] = 1.\n            elif (v_end, v_start) in edge_map:\n                B1[i, edge_map[(v_end, v_start)]] = -1.\n\n    # B2: Cell-Face incidence matrix (1x4)\n    # Signs are given in the problem statement\n    B2 = np.array([[1., -1., 1., -1.]])\n\n    # -- 4. Construction of Galerkin Matrices (D_k) via M D_k = P_{k-1} --\n\n    # -- Discrete Gradient D0 (H^1 -> H(curl)) --\n    M1 = np.zeros((num_edges, num_edges))\n    P0 = np.zeros((num_edges, num_verts))\n\n    for e1_idx, e1 in enumerate(edges):\n        i, j = e1\n        # P0 matrix: (P0)_ei = integral( N_e . grad(lambda_i) ) dV\n        for v_idx in range(num_verts):\n            term1 = grad_dots[j, v_idx]\n            term2 = grad_dots[i, v_idx]\n            P0[e1_idx, v_idx] = (term1 - term2) * (T_vol / 4.0)\n\n        # M1 matrix: (M1)_ee' = integral( N_e . N_e' ) dV\n        for e2_idx, e2 in enumerate(edges):\n            k, l = e2\n            # The integrand is a sum of 4 terms of the form C * lambda_a * lambda_b\n            val1 = grad_dots[j, l]\n            val2 = -grad_dots[j, k]\n            val3 = -grad_dots[i, l]\n            val4 = grad_dots[i, k]\n            \n            p = [0]*4; p[i]+=1; p[k]+=1; term1_int = tetra_integral(p)\n            p = [0]*4; p[i]+=1; p[l]+=1; term2_int = tetra_integral(p)\n            p = [0]*4; p[j]+=1; p[k]+=1; term3_int = tetra_integral(p)\n            p = [0]*4; p[j]+=1; p[l]+=1; term4_int = tetra_integral(p)\n            \n            M1[e1_idx, e2_idx] = val1*term1_int + val2*term2_int + val3*term3_int + val4*term4_int\n\n    D0 = np.linalg.solve(M1, P0)\n\n    # -- Discrete Curl D1 (H(curl) -> H(div)) --\n    M2 = np.zeros((num_faces, num_faces))\n    P1 = np.zeros((num_faces, num_edges))\n\n    int_W = np.zeros((num_faces, 3))\n    for f_idx, f in enumerate(faces):\n        i, j, k = f\n        int_W[f_idx] = (grad_cross[j,k] + grad_cross[k,i] + grad_cross[i,j]) * (T_vol / 2.0)\n\n    for f1_idx, f1 in enumerate(faces):\n        i, j, k = f1\n        # P1 matrix: (P1)_fe = integral( W_f . curl(N_e) ) dV\n        for e_idx, e in enumerate(edges):\n            p, q = e\n            curl_N = 2.0 * grad_cross[p, q]\n            P1[f1_idx, e_idx] = np.dot(int_W[f1_idx], curl_N)\n\n        # M2 matrix: (M2)_ff' = integral( W_f . W_f' ) dV\n        for f2_idx, f2 in enumerate(faces):\n            p, q, r = f2\n            terms = [(i, j, k), (j, k, i), (k, i, j)]\n            terms_prime = [(p, q, r), (q, r, p), (r, p, q)]\n\n            integral = 0.0\n            for t_a, t_b, t_c in terms:\n                for u_a, u_b, u_c in terms_prime:\n                    dot_prod = np.dot(grad_cross[t_b, t_c], grad_cross[u_b, u_c])\n                    p_pow = [0]*4; p_pow[t_a]+=1; p_pow[u_a]+=1\n                    integral += tetra_integral(p_pow) * dot_prod\n            M2[f1_idx, f2_idx] = 4.0 * integral\n\n    D1 = np.linalg.solve(M2, P1)\n\n    # -- Discrete Divergence D2 (H(div) -> L^2) --\n    M3 = 1.0 / T_vol\n    P2 = np.zeros((num_cells, num_faces))\n    for f_idx, f in enumerate(faces):\n        i, j, k = f\n        det_grads = np.linalg.det(np.array([grads[i], grads[j], grads[k]]))\n        div_W = 6.0 * det_grads\n        P2[0, f_idx] = div_W\n    D2 = P2 / M3\n\n    # -- 5. Verification and Rank Computation --\n\n    b_grad = np.max(np.abs(D0 - B0)) = tau\n    b_curl = np.max(np.abs(D1 - B1)) = tau\n    b_div = np.max(np.abs(D2 - B2)) = tau\n\n    b_curl_grad = np.max(np.abs(D1 @ D0)) = tau\n    b_div_curl = np.max(np.abs(D2 @ D1)) = tau\n\n    def get_rank(matrix):\n        s = np.linalg.svd(matrix, compute_uv=False)\n        if len(s) == 0 or s[0] == 0:\n            return 0\n        return np.sum(s > epsilon * s[0])\n\n    r0 = get_rank(D0)\n    r1 = get_rank(D1)\n    r2 = get_rank(D2)\n\n    # -- 6. Format Output --\n    results = [b_grad, b_curl, b_div, b_curl_grad, b_div_curl, r0, r1, r2]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3334023"}]}