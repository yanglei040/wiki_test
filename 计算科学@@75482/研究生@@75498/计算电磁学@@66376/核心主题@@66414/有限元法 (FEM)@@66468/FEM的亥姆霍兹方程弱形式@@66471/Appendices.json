{"hands_on_practices": [{"introduction": "在应用有限元方法求解任何问题之前，首要且最关键的一步是将描述物理系统的微分方程（强形式）转化为等价的积分形式（弱形式）。本练习将引导您完成亥姆霍兹方程的这一基础推导过程。通过这个练习，您不仅能巩固对有限元方法数学基础的理解，还将揭示弱形式中一个优雅的性质——对称性，并由此引出深刻的物理互易原理。[@problem_id:3360923]", "problem": "考虑一个标量亥姆霍兹边值问题，该问题是在无损、非均匀、一维介质中时谐电磁波传播的模型降阶中产生的。设 $\\Omega = (0,1)$，并设 $a(x)$ 和 $b(x)$ 为代表等效材料参数的实值、有界、严格正的系数函数。对于给定的实波数 $k \\in \\mathbb{R}$ 和给定的源函数 $f \\in L^2(\\Omega)$，其强形式为：求 $u:\\Omega \\to \\mathbb{R}$，使得\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\quad u(1)=0,\n$$\n其中所有量均为无量纲。\n\n1) 从散度定理和索博列夫空间 $H_0^1(\\Omega)$ 的定义出发，推导其弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n请明确指出 $a(x)$、$b(x)$ 和边界条件的哪些性质确保了双线性形式\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n是对称的。请从第一性原理出发，解释为什么这种对称性对于任意两个分别对应于源 $f_1,f_2 \\in L^2(\\Omega)$ 的弱解 $u_1,u_2 \\in H_0^1(\\Omega)$，都蕴含着一个互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx.\n$$\n\n2) 考虑在具有 $N$ 个单元的均匀网格上，使用全局连续分片线性基函数的协调伽辽金有限元法 (FEM)。设 $\\{\\phi_i(x)\\}_{i=0}^N$ 表示在节点为 $0=x_0  x_1  \\cdots  x_N = 1$ 的 $[0,1]$ 区间划分上的标准节点基。使用中点求积进行单元组装，定义单元矩阵和向量以组装全局矩阵\n$$\nA \\equiv K - k^2 M,\n$$\n其中刚度矩阵项为 $K_{ij} \\approx \\int_0^1 a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx$，质量矩阵项为 $M_{ij} \\approx \\int_0^1 b(x)\\, \\phi_i(x)\\, \\phi_j(x)\\, dx$，载荷向量项为 $b_i \\approx \\int_0^1 f(x)\\, \\phi_i(x)\\, dx$。在端点处强施加齐次狄利克雷边界条件。从组装后系统的代数结构出发，证明当 $A$ 是对称的，且两个离散解 $U^{(1)}$ 和 $U^{(2)}$ 均满足 $A U^{(m)} = b^{(m)}$（使用相同的 $A$）时，以下离散互易恒等式在有限精度算术中精确成立（除线性求解器舍入误差外）：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}.\n$$\n\n3) 构建一个数值测试，通过计算差异\n$$\nr \\equiv \\left| \\left(U^{(2)}\\right)^\\top b^{(1)} - \\left(U^{(1)}\\right)^\\top b^{(2)} \\right|\n$$\n来检测离散设置中违反互易性的实现错误。实现一个独立完整的程序，该程序：\n- 使用中点求积组装一维分片线性 FEM 系统。\n- 求解具有源 $f_1$ 和 $f_2$ 的两个离散问题。\n- 报告互易差异 $r$。\n\n您的程序必须评估以下测试套件，并将四个差异值以浮点数形式输出。所有量均为无量纲。\n\n- 测试 1（理想情况，光滑系数和源）：\n  - $N = 64$，$k = 7.3$，$a(x) = 1$，$b(x) = 1$，\n  - $f_1(x) = \\sin(3\\pi x)$，$f_2(x) = \\cos(5\\pi x)$，\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 2（非均匀系数，光滑局部化源）：\n  - $N = 64$，$k = 4.2$，\n  - $a(x) = 1$ 对于 $x  0.5$ 且 $a(x) = 3$ 对于 $x \\ge 0.5$，$b(x) = 1$，\n  - $f_1(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right)$，$f_2(x) = \\exp\\!\\left(-120\\,(x-0.7)^2\\right)$，\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 3（边界尺寸网格，粗糙离散化边缘情况）：\n  - $N = 2$，$k = 2.0$，$a(x) = 1$，$b(x) = 1$，\n  - $f_1(x) = x\\,(1-x)$，$f_2(x) = 1 - 2x$，\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 4（通过模拟组装错误的斜扰动故意违反互易性）：\n  - 从与测试 1 相同的配置开始。\n  - 组装对称矩阵 $A$ 后，通过向单个非对角内部项添加一个斜扰动 $\\varepsilon = 10^{-2}$ 来创建一个扰动矩阵 $\\tilde{A}$：对于 $p = \\lfloor N/2 \\rfloor$，$\\tilde{A}_{p,p+1} \\leftarrow \\tilde{A}_{p,p+1} + \\varepsilon$，而不对 $\\tilde{A}_{p+1,p}$ 进行相应更改。\n  - 求解 $A U^{(1)} = b^{(1)}$ 和 $\\tilde{A} U^{(2)} = b^{(2)}$。\n  - 使用 $U^{(1)},U^{(2)},b^{(1)},b^{(2)}$ 计算 $r$。此配置应产生比测试 1-3 中大几个数量级的差异。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个互易差异值，格式为逗号分隔的列表，并用方括号括起来（例如，“[r1,r2,r3,r4]”）。每个 $r_m$ 都必须是浮点数。不应打印任何额外文本。此问题完全无量纲；不需要物理单位，也不涉及角度。", "solution": "问题要求对一维标量亥姆霍兹方程的互易原理进行理论推导和数值验证。我们将首先验证问题陈述，然后进行详细解答。\n\n### 第 1 部分：弱形式和互易恒等式的推导\n\n边值问题的强形式是求定义在域 $\\Omega = (0,1)$ 上的函数 $u:\\Omega \\to \\mathbb{R}$，使其满足：\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n并服从齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。系数 $a(x)$ 和 $b(x)$ 是实值、有界且严格为正的函数，$k \\in \\mathbb{R}$ 是波数，$f \\in L^2(\\Omega)$ 是源项。\n\n为了推导弱形式，我们采用标准程序，即将微分方程乘以一个测试函数 $v$，然后在域 $\\Omega$ 上积分。解 $u$ 和测试函数 $v$ 的适定空间都是索博列夫空间 $H_0^1(\\Omega)$。该空间由 $L^2(\\Omega)$ 中弱导数也在 $L^2(\\Omega)$ 中且满足齐次边界条件（即 $u(0)=v(0)=0$ 和 $u(1)=v(1)=0$）的函数组成。\n\n将强形式乘以 $v \\in H_0^1(\\Omega)$ 并积分得到：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n我们关注第一项并应用分部积分法，这是一维版本的散度定理：$\\int_\\Omega (\\nabla \\cdot \\mathbf{F}) \\phi \\, dV = -\\int_\\Omega \\mathbf{F} \\cdot (\\nabla \\phi) \\, dV + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$。在一维中，这变成 $\\int_0^1 \\frac{dF}{dx} v \\, dx = [Fv]_0^1 - \\int_0^1 F\\frac{dv}{dx} \\, dx$。\n令 $F(x) = -a(x)\\frac{du}{dx}$，我们有：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx = - \\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 + \\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\n边界项 $\\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 = a(1)\\frac{du}{dx}(1)v(1) - a(0)\\frac{du}{dx}(0)v(0)$ 为零，因为测试函数 $v$ 属于 $H_0^1(\\Omega)$，这意味着 $v(0)=0$ 和 $v(1)=0$。\n\n将此代回到积分方程中，我们得到弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n这可以写成抽象形式 $B(u,v) = L(v)$，其中 $B(u,v)$ 是双线性形式，$L(v)$ 是右侧的线性泛函。\n\n双线性形式 $B(u,v)$ 定义为：\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n为使 $B(u,v)$ 对称，我们需要对所有 $u,v \\in H_0^1(\\Omega)$ 都有 $B(u,v) = B(v,u)$。我们来检验 $B(v,u)$：\n$$\nB(v,u) = \\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx - k^2 \\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx\n$$\n由于 $u(x)$、$v(x)$ 及其导数是标量实值函数，且系数 $a(x)$ 和 $b(x)$ 也是实值的，因此这些函数的乘法是可交换的。即 $u'(x)v'(x) = v'(x)u'(x)$ 且 $u(x)v(x) = v(x)u(x)$。因此：\n$$\n\\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx\n$$\n$$\n\\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx = \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n这证明了 $B(u,v) = B(v,u)$。双线性形式的对称性得到保证，因为问题处理的是实值函数和系数。\n\n现在，我们推导互易恒等式。设 $u_1, u_2 \\in H_0^1(\\Omega)$ 是分别对应于两个不同源函数 $f_1, f_2 \\in L^2(\\Omega)$ 的两个弱解。根据弱解的定义，它们满足：\n1. 对所有 $v \\in H_0^1(\\Omega)$，有 $B(u_1, v) = \\int_0^1 f_1(x) v(x) dx$。\n2. 对所有 $v \\in H_0^1(\\Omega)$，有 $B(u_2, v) = \\int_0^1 f_2(x) v(x) dx$。\n\n由于 $u_1, u_2 \\in H_0^1(\\Omega)$，它们本身就是有效的测试函数。我们可以在第一个方程中选择 $v=u_2$，在第二个方程中选择 $v=u_1$：\n1. $B(u_1, u_2) = \\int_0^1 f_1(x) u_2(x) dx$\n2. $B(u_2, u_1) = \\int_0^1 f_2(x) u_1(x) dx$\n\n正如我们刚才所证，双线性形式 $B(\\cdot, \\cdot)$ 是对称的，因此 $B(u_1, u_2) = B(u_2, u_1)$。令上述两个表达式的右侧相等，即可得到互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx\n$$\n该恒等式表明，第一个源对第二个解所做的功等于第二个源对第一个解所做的功。\n\n### 第 2 部分：离散公式化和互易性\n\n我们使用协调伽辽金有限元法 (FEM) 对问题进行离散化，该方法在 $[0,1]$ 区间的均匀网格上使用分片线性基函数 $\\phi_i(x)$。该网格有 $N$ 个单元，步长为 $h=1/N$。节点为 $x_i = i h$，其中 $i=0, \\dots, N$。帽子函数 $\\phi_i(x)$ 在节点 $x_i$ 处为 1，在所有其他节点处为 0。\n\nFEM 解 $u_h(x)$ 在由内部基函数 $\\{\\phi_i\\}_{i=1}^{N-1}$ 张成的有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中寻找。解表示为这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\n$$\n其中 $U_j$ 是未知系数，代表解在内部节点 $x_j$ 处的值。注意，$U_0=0$ 和 $U_N=0$ 是强施加的。\n\n伽辽金法要求弱形式对所有测试函数 $v_h \\in V_h$ 均成立。我们选择基函数本身作为测试函数，即 $v = \\phi_i(x)$，其中 $i=1, \\dots, N-1$：\n$$\nB\\left(\\sum_{j=1}^{N-1} U_j \\phi_j, \\phi_i\\right) = L(\\phi_i) \\quad \\text{for } i=1, \\dots, N-1\n$$\n根据双线性形式的线性性质，这变成一个线性方程组：\n$$\n\\sum_{j=1}^{N-1} U_j B(\\phi_j, \\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n这就是代数系统 $A U = b$，其中 $U = [U_1, \\dots, U_{N-1}]^\\top$ 是未知节点值的向量，矩阵 $A$（大小为 $(N-1) \\times (N-1)$）和向量 $b$（大小为 $(N-1) \\times 1$）的项分别为：\n$$\nA_{ij} = B(\\phi_j, \\phi_i) = \\int_0^1 a(x) \\phi_j'(x) \\phi_i'(x) dx - k^2 \\int_0^1 b(x) \\phi_j(x) \\phi_i(x) dx\n$$\n$$\nb_i = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n问题指定使用中点求积来组装系统。对于一个单元 $e_m = [x_{m-1}, x_m]$，其中点为 $x_{m-1/2} = (x_{m-1}+x_m)/2$：\n- 单元刚度矩阵 $K^{(m)}$ 的局部项为 $K_{ij}^{(m)} \\approx h \\cdot a(x_{m-1/2}) \\phi_j'(x_{m-1/2}) \\phi_i'(x_{m-1/2})$。局部线性基函数的导数是常数，为 $\\pm 1/h$。这会得到对称的单元矩阵：$K^{(m)} \\approx \\frac{a(x_{m-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n- 单元质量矩阵 $M^{(m)}$ 的局部项为 $M_{ij}^{(m)} \\approx h \\cdot b(x_{m-1/2}) \\phi_j(x_{m-1/2}) \\phi_i(x_{m-1/2})$。在单元中点，局部基函数的值均为 $1/2$。这会得到对称的单元矩阵：$M^{(m)} \\approx \\frac{h \\cdot b(x_{m-1/2})}{4} \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}$。\n- 单元载荷向量 $b^{(m)}$ 的项为 $b_i^{(m)} \\approx h \\cdot f(x_{m-1/2}) \\phi_i(x_{m-1/2})$。这得到 $b^{(m)} \\approx \\frac{h \\cdot f(x_{m-1/2})}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n全局矩阵 $K$ 和 $M$ 是通过将这些对称的单元贡献相加而形成的。对称矩阵之和是对称的，因此 $K$ 和 $M$ 是对称的。因此，系统矩阵 $A = K - k^2 M$ 也是对称的，即 $A = A^\\top$。\n\n现在，我们来推导离散互易恒等式。考虑两个具有相同矩阵 $A$ 但不同源 $b^{(1)}$ 和 $b^{(2)}$ 的离散问题：\n1. $A U^{(1)} = b^{(1)}$\n2. $A U^{(2)} = b^{(2)}$\n我们要证明 $(U^{(2)})^\\top b^{(1)} = (U^{(1)})^\\top b^{(2)}$。\n从左侧开始，代入第一个方程中的 $b^{(1)}$：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(2)}\\right)^\\top \\left(A U^{(1)}\\right)\n$$\n使用转置性质 $(XY)^\\top = Y^\\top X^\\top$，我们可以将其写为：\n$$\n\\left(U^{(2)}\\right)^\\top A U^{(1)} = \\left(U^{(2)}\\right)^\\top A^\\top U^{(1)} = \\left(A U^{(2)}\\right)^\\top U^{(1)}\n$$\n这一步依赖于 $A$ 的对称性，即 $A = A^\\top$。现在，从第二个方程代入 $A U^{(2)} = b^{(2)}$：\n$$\n\\left(A U^{(2)}\\right)^\\top U^{(1)} = \\left(b^{(2)}\\right)^\\top U^{(1)}\n$$\n最后，由于行向量和列向量的乘积是一个标量，它等于其自身的转置。$(b^{(2)})^\\top U^{(1)$ 的转置是 $(U^{(1)})^\\top b^{(2)}$。因此，\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}\n$$\n这个恒等式在代数层面上是精确成立的。任何数值偏差都必然源于非对称矩阵组装（错误）、两次求解使用不同的矩阵，或线性求解器中的浮点舍入误差等。所提出的数值测试旨在测量这种偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly needed, numpy is sufficient\n\ndef run_reciprocity_test(N, k, a_func, b_func, f1_func, f2_func, A_perturbation=None):\n    \"\"\"\n    Assembles and solves two 1D Helmholtz problems using FEM and calculates the reciprocity discrepancy.\n    \n    Args:\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        a_func (callable): Coefficient function a(x).\n        b_func (callable): Coefficient function b(x).\n        f1_func (callable): Source function f1(x).\n        f2_func (callable): Source function f2(x).\n        A_perturbation (tuple, optional): A tuple (row, col, value) to perturb the matrix A for the \n                                          second solve. Defaults to None.\n    \n    Returns:\n        float: The reciprocity discrepancy |(U2)^T b1 - (U1)^T b2|.\n    \"\"\"\n    \n    # Mesh properties\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    # Initialize global stiffness and mass matrices, and load vectors\n    # Full size (N+1)x(N+1) to simplify assembly indexing\n    K = np.zeros((N + 1, N + 1))\n    M = np.zeros((N + 1, N + 1))\n    b1 = np.zeros(N + 1)\n    b2 = np.zeros(N + 1)\n    \n    # Element properties (constant for all elements with linear basis functions)\n    # Element stiffness matrix for a(x)=1, h=1\n    k_elem_base = np.array([[1, -1], [-1, 1]])\n    # Element mass matrix for b(x)=1, h=1\n    m_elem_base = np.array([[1/4, 1/4], [1/4, 1/4]])\n    \n    # Loop over elements to assemble the system\n    for i in range(N):\n        # Global indices for the current element's nodes\n        idx0, idx1 = i, i + 1\n        \n        # Midpoint of the element\n        midpoint = nodes[idx0] + h / 2.0\n        \n        # Evaluate coefficients and sources at the midpoint\n        a_mid = a_func(midpoint)\n        b_mid = b_func(midpoint)\n        f1_mid = f1_func(midpoint)\n        f2_mid = f2_func(midpoint)\n        \n        # Scale element matrices by coefficients and mesh size\n        k_elem = (a_mid / h) * k_elem_base\n        m_elem = (b_mid * h) * m_elem_base\n        \n        # Assemble element matrices into global matrices\n        K[idx0:idx1+1, idx0:idx1+1] += k_elem\n        M[idx0:idx1+1, idx0:idx1+1] += m_elem\n        \n        # Assemble element load vectors\n        b1[idx0] += h * f1_mid * 0.5\n        b1[idx1] += h * f1_mid * 0.5\n        b2[idx0] += h * f2_mid * 0.5\n        b2[idx1] += h * f2_mid * 0.5\n\n    # Form the system matrix A\n    A = K - k**2 * M\n    \n    # Enforce homogeneous Dirichlet boundary conditions by using only interior nodes\n    # The interior system involves nodes 1 to N-1\n    A_int = A[1:N, 1:N]\n    b1_int = b1[1:N]\n    b2_int = b2[1:N]\n    \n    # --- Solve for U1 ---\n    # The matrix for the first solve is always the unperturbed one\n    U1 = np.linalg.solve(A_int, b1_int)\n    \n    # --- Solve for U2 ---\n    # The matrix for the second solve might be perturbed\n    A2_int = A_int.copy()\n    if A_perturbation:\n        row, col, value = A_perturbation\n        A2_int[row, col] += value\n    \n    U2 = np.linalg.solve(A2_int, b2_int)\n    \n    # --- Calculate reciprocity discrepancy ---\n    # r = | (U2)^T @ b1 - (U1)^T @ b2 |\n    discrepancy = np.abs(U2.T @ b1_int - U1.T @ b2_int)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the reciprocity check.\n    \"\"\"\n    \n    # Test 1: Happy path, smooth coefficients and sources\n    N1 = 64\n    k1 = 7.3\n    a1 = lambda x: 1.0\n    b1 = lambda x: 1.0\n    f1_1 = lambda x: np.sin(3 * np.pi * x)\n    f2_1 = lambda x: np.cos(5 * np.pi * x)\n    \n    # Test 2: Heterogeneous coefficient, smooth localized sources\n    N2 = 64\n    k2 = 4.2\n    a2 = lambda x: 3.0 if x >= 0.5 else 1.0\n    b2 = lambda x: 1.0\n    f1_2 = lambda x: np.exp(-100 * (x - 0.3)**2)\n    f2_2 = lambda x: np.exp(-120 * (x - 0.7)**2)\n    \n    # Test 3: Boundary-size mesh, coarse discretization edge case\n    N3 = 2\n    k3 = 2.0\n    a3 = lambda x: 1.0\n    b3 = lambda x: 1.0\n    f1_3 = lambda x: x * (1 - x)\n    f2_3 = lambda x: 1 - 2 * x\n\n    # Test 4: Intentional reciprocity violation via a skew perturbation\n    N4 = 64 # Same as Test 1\n    k4 = 7.3\n    a4 = lambda x: 1.0\n    b4 = lambda x: 1.0\n    f1_4 = lambda x: np.sin(3 * np.pi * x)\n    f2_4 = lambda x: np.cos(5 * np.pi * x)\n    # The interior matrix indices are 0...N-2.\n    # Node p = floor(N/2) = 32 has matrix index 32-1=31.\n    # Node p+1 = 33 has matrix index 33-1=32.\n    perturbation = (31, 32, 1e-2)\n\n    test_cases = [\n        (N1, k1, a1, b1, f1_1, f2_1, None),\n        (N2, k2, a2, b2, f1_2, f2_2, None),\n        (N3, k3, a3, b3, f1_3, f2_3, None),\n        (N4, k4, a4, b4, f1_4, f2_4, perturbation),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_reciprocity_test(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3360923"}, {"introduction": "建立了连续弱形式之后，下一步是将其离散化，从而得到一个可解的线性方程组。本练习将聚焦于应用伽辽金方法和线性基函数，探讨连续的互易原理如何在离散的代数系统中得以体现。通过这个过程，您将清晰地看到连续双线性形式的对称性如何直接转化为最终系统矩阵的对称性，为后续的数值验证和代码调试提供了关键的理论依据。[@problem_id:3360923]", "problem": "考虑一个标量亥姆霍兹边界值问题，该问题是无损耗、非均匀一维介质中时谐电磁波传播模型的一种简化。设 $\\Omega = (0,1)$，并设 $a(x)$ 和 $b(x)$ 为代表等效材料参数的实值、有界、严格为正的系数函数。对于给定的实数波数 $k \\in \\mathbb{R}$ 和给定的源函数 $f \\in L^2(\\Omega)$，其强形式为：求 $u:\\Omega \\to \\mathbb{R}$，使得\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\quad u(1)=0,\n$$\n其中所有量均为无量纲。\n\n1) 从散度定理和索博列夫空间 $H_0^1(\\Omega)$ 的定义出发，推导出弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n请精确说明 $a(x)$、$b(x)$ 的哪些性质以及边界条件确保了双线性形式\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n是对称的。请从基本原理出发，解释为何这种对称性能够推导出任意两个对应于源 $f_1,f_2 \\in L^2(\\Omega)$ 的弱解 $u_1,u_2 \\in H_0^1(\\Omega)$ 之间的互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx.\n$$\n\n2) 考虑在具有 $N$ 个单元的均匀网格上，使用全局连续的分片线性基函数的协调伽辽金有限元法 (FEM)。设 $\\{\\phi_i(x)\\}_{i=0}^N$ 表示在区间 $[0,1]$ 的划分上的标准节点基，其节点为 $0=x_0  x_1  \\cdots  x_N = 1$。使用中点求积法进行逐单元组装，定义用以组装全局矩阵\n$$\nA \\equiv K - k^2 M,\n$$\n的单元矩阵和向量，其中刚度矩阵的元为 $K_{ij} \\approx \\int_0^1 a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx$，质量矩阵的元为 $M_{ij} \\approx \\int_0^1 b(x)\\, \\phi_i(x)\\, \\phi_j(x)\\, dx$，以及载荷向量的元为 $b_i \\approx \\int_0^1 f(x)\\, \\phi_i(x)\\, dx$。在端点处强施加齐次狄利克雷边界条件。从组装后系统的代数结构出发，证明当 $A$ 是对称的，且两个离散解 $U^{(1)}$ 和 $U^{(2)}$ 满足使用相同 $A$ 的 $A U^{(m)} = b^{(m)}$ 时，下面的离散互易恒等式在线性求解器舍入误差范围内、在有限精度算术下精确成立：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}.\n$$\n\n3) 构建一个数值测试，通过计算差异\n$$\nr \\equiv \\left| \\left(U^{(2)}\\right)^\\top b^{(1)} - \\left(U^{(1)}\\right)^\\top b^{(2)} \\right|\n$$\n来检测在离散设置中违反互易性的实现错误。实现一个独立完整的程序，该程序：\n- 使用中点求积法组装一维分片线性有限元系统。\n- 求解两个分别带有源 $f_1$ 和 $f_2$ 的离散问题。\n- 报告互易性差异 $r$。\n\n你的程序必须评估以下测试套件，并以浮点数形式输出四个差异值。所有量均为无量纲。\n\n- 测试1（理想路径，光滑的系数和源）：\n  - $N = 64$, $k = 7.3$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = \\sin(3\\pi x)$, $f_2(x) = \\cos(5\\pi x)$,\n  - 两个求解过程均使用相同的组装矩阵 $A$。\n\n- 测试2（非均匀系数，光滑的局部化源）：\n  - $N = 64$, $k = 4.2$,\n  - 当 $x  0.5$ 时 $a(x) = 1$，当 $x \\ge 0.5$ 时 $a(x) = 3$，$b(x) = 1$,\n  - $f_1(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right)$, $f_2(x) = \\exp\\!\\left(-120\\,(x-0.7)^2\\right)$,\n  - 两个求解过程均使用相同的组装矩阵 $A$。\n\n- 测试3（极小尺寸网格，粗糙离散化边界情况）：\n  - $N = 2$, $k = 2.0$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = x\\,(1-x)$, $f_2(x) = 1 - 2x$,\n  - 两个求解过程均使用相同的组装矩阵 $A$。\n\n- 测试4（通过模拟组装错误的斜对称扰动来有意违反互易性）：\n  - 从与测试1相同的配置开始。\n  - 在组装对称矩阵 $A$ 之后，通过向单个非对角内部元添加一个斜对称扰动 $\\varepsilon = 10^{-2}$ 来创建一个扰动矩阵 $\\tilde{A}$：$\\tilde{A}_{p,p+1} \\leftarrow \\tilde{A}_{p,p+1} + \\varepsilon$，其中 $p = \\lfloor N/2 \\rfloor$，而不对 $\\tilde{A}_{p+1,p}$ 做相应改变。\n  - 求解 $A U^{(1)} = b^{(1)}$ 和 $\\tilde{A} U^{(2)} = b^{(2)}$。\n  - 使用 $U^{(1)},U^{(2)},b^{(1)},b^{(2)}$ 计算 $r$。此配置应产生比测试1-3大几个数量级的差异。\n\n最终输出格式：你的程序应生成单行输出，其中包含四个互易性差异值，形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。每个 $r_m$ 必须是浮点数。不应打印任何其他文本。该问题完全是无量纲的；不需要物理单位，也不涉及角度。", "solution": "该问题要求对一维标量亥姆霍兹方程的互易原理进行理论推导和数值验证。我们将首先验证问题陈述，然后进行详细的解答。\n\n### 第1部分：弱形式和互易恒等式的推导\n\n该边界值问题的强形式为，在定义域 $\\Omega = (0,1)$ 上求一个函数 $u:\\Omega \\to \\mathbb{R}$，使其满足：\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n并满足齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。系数 $a(x)$ 和 $b(x)$ 是实值、有界且严格为正的函数，$k \\in \\mathbb{R}$ 是波数，$f \\in L^2(\\Omega)$ 是源项。\n\n为推导弱形式，我们采用标准步骤：将微分方程乘以一个检验函数 $v$，然后在定义域 $\\Omega$ 上积分。解 $u$ 和检验函数 $v$ 适用的空间均为索博列夫空间 $H_0^1(\\Omega)$。该空间由 $L^2(\\Omega)$ 中的函数组成，这些函数的弱导数也在 $L^2(\\Omega)$ 中，并且它们满足齐次边界条件，即 $u(0)=v(0)=0$ 和 $u(1)=v(1)=0$。\n\n将强形式乘以 $v \\in H_0^1(\\Omega)$ 并积分可得：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n我们关注第一项，并应用分部积分，这是一维形式的散度定理：$\\int_\\Omega (\\nabla \\cdot \\mathbf{F}) \\phi \\, dV = -\\int_\\Omega \\mathbf{F} \\cdot (\\nabla \\phi) \\, dV + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$。在一维情况下，这变为 $\\int_0^1 \\frac{dF}{dx} v \\, dx = [Fv]_0^1 - \\int_0^1 F\\frac{dv}{dx} \\, dx$。\n令 $F(x) = -a(x)\\frac{du}{dx}$，我们得到：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx = - \\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 + \\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\n边界项 $\\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 = a(1)\\frac{du}{dx}(1)v(1) - a(0)\\frac{du}{dx}(0)v(0)$ 为零，因为检验函数 $v$ 属于 $H_0^1(\\Omega)$，这意味着 $v(0)=0$ 且 $v(1)=0$。\n\n将此结果代回积分方程，我们得到弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n这可以写成抽象形式 $B(u,v) = L(v)$，其中 $B(u,v)$ 是双线性形式，$L(v)$ 是右侧的线性泛函。\n\n双线性形式 $B(u,v)$ 定义为：\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n为使 $B(u,v)$ 对称，我们需要对所有 $u,v \\in H_0^1(\\Omega)$ 都有 $B(u,v) = B(v,u)$。我们来考察 $B(v,u)$：\n$$\nB(v,u) = \\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx - k^2 \\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx\n$$\n由于 $u(x)$、$v(x)$ 及其导数都是标量实值函数，且系数 $a(x)$ 和 $b(x)$ 也是实值的，因此这些函数的乘法是可交换的。即 $u'(x)v'(x) = v'(x)u'(x)$ 且 $u(x)v(x) = v(x)u(x)$。因此：\n$$\n\\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx\n$$\n$$\n\\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx = \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n这证明了 $B(u,v) = B(v,u)$。由于该问题处理的是实值函数和系数，双线性形式的对称性得到了保证。\n\n现在，我们来推导互易恒等式。设 $u_1, u_2 \\in H_0^1(\\Omega)$ 分别是对应于两个不同源函数 $f_1, f_2 \\in L^2(\\Omega)$ 的弱解。根据弱解的定义，它们满足：\n1. $B(u_1, v) = \\int_0^1 f_1(x) v(x) dx$ for all $v \\in H_0^1(\\Omega)$.\n2. $B(u_2, v) = \\int_0^1 f_2(x) v(x) dx$ for all $v \\in H_0^1(\\Omega)$.\n\n由于 $u_1, u_2 \\in H_0^1(\\Omega)$，它们本身就是有效的检验函数。我们可以在第一个方程中选择 $v=u_2$，在第二个方程中选择 $v=u_1$：\n1. $B(u_1, u_2) = \\int_0^1 f_1(x) u_2(x) dx$\n2. $B(u_2, u_1) = \\int_0^1 f_2(x) u_1(x) dx$\n\n正如我们刚才所证，双线性形式 $B(\\cdot, \\cdot)$ 是对称的，因此有 $B(u_1, u_2) = B(u_2, u_1)$。令上述两个表达式的右侧相等，即可得到互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx\n$$\n该恒等式表明，第一个源对第二个解所做的功等于第二个源对第一个解所做的功。\n\n### 第2部分：离散公式和互易性\n\n我们使用协调伽辽金有限元法 (FEM) 对问题进行离散化，在区间 $[0,1]$ 上使用包含 $N$ 个单元、步长为 $h=1/N$ 的均匀网格以及分片线性基函数 $\\phi_i(x)$。节点为 $x_i = i h$，其中 $i=0, \\dots, N$。帽子函数 $\\phi_i(x)$ 在节点 $x_i$ 处为1，在所有其他节点处为0。\n\n有限元解 $u_h(x)$ 在由内部基函数 $\\{\\phi_i\\}_{i=1}^{N-1}$ 张成的有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中求解。解表示为这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\n$$\n其中 $U_j$ 是未知系数，代表解在内部节点 $x_j$ 处的值。注意，$U_0=0$ 和 $U_N=0$ 是强施加的。\n\n伽辽金方法要求弱形式对所有检验函数 $v_h \\in V_h$ 成立。我们选择基函数自身作为检验函数，即 $v = \\phi_i(x)$，其中 $i=1, \\dots, N-1$：\n$$\nB\\left(\\sum_{j=1}^{N-1} U_j \\phi_j, \\phi_i\\right) = L(\\phi_i) \\quad \\text{for } i=1, \\dots, N-1\n$$\n根据双线性形式的线性性质，这变成一个线性方程组：\n$$\n\\sum_{j=1}^{N-1} U_j B(\\phi_j, \\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n这是一个代数系统 $A U = b$，其中 $U = [U_1, \\dots, U_{N-1}]^\\top$ 是未知节点值的向量，矩阵 $A$（尺寸为 $(N-1) \\times (N-1)$）和向量 $b$（尺寸为 $(N-1) \\times 1$）的元分别为：\n$$\nA_{ij} = B(\\phi_j, \\phi_i) = \\int_0^1 a(x) \\phi_j'(x) \\phi_i'(x) dx - k^2 \\int_0^1 b(x) \\phi_j(x) \\phi_i(x) dx\n$$\n$$\nb_i = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n问题指定使用中点求积法来组装系统。对于一个中点为 $x_{m-1/2} = (x_{m-1}+x_m)/2$ 的单元 $e_m = [x_{m-1}, x_m]$：\n- 单元刚度矩阵 $K^{(m)}$ 的局部元为 $K_{ij}^{(m)} \\approx h \\cdot a(x_{m-1/2}) \\phi_j'(x_{m-1/2}) \\phi_i'(x_{m-1/2})$。局部线性基函数的导数是常数 $\\pm 1/h$。这导出了对称的单元矩阵：$K^{(m)} \\approx \\frac{a(x_{m-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n- 单元质量矩阵 $M^{(m)}$ 的局部元为 $M_{ij}^{(m)} \\approx h \\cdot b(x_{m-1/2}) \\phi_j(x_{m-1/2}) \\phi_i(x_{m-1/2})$。在单元中点，两个局部基函数的值均为 $1/2$。这导出了对称的单元矩阵：$M^{(m)} \\approx \\frac{h \\cdot b(x_{m-1/2})}{4} \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}$。\n- 单元载荷向量 $b^{(m)}$ 的元为 $b_i^{(m)} \\approx h \\cdot f(x_{m-1/2}) \\phi_i(x_{m-1/2})$。这给出 $b^{(m)} \\approx \\frac{h \\cdot f(x_{m-1/2})}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n全局矩阵 $K$ 和 $M$ 是通过将这些对称的单元贡献相加而形成的。对称矩阵的和是对称的，所以 $K$ 和 $M$ 是对称的。因此，系统矩阵 $A = K - k^2 M$ 也是对称的，即 $A = A^\\top$。\n\n现在，我们来推导离散互易恒等式。考虑两个具有相同矩阵 $A$ 但不同源 $b^{(1)}$ 和 $b^{(2)}$ 的离散问题：\n1. $A U^{(1)} = b^{(1)}$\n2. $A U^{(2)} = b^{(2)}$\n我们想要证明 $(U^{(2)})^\\top b^{(1)} = (U^{(1)})^\\top b^{(2)}$。从左侧开始，代入第一个方程中的 $b^{(1)}$：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(2)}\\right)^\\top \\left(A U^{(1)}\\right)\n$$\n利用转置性质 $(XY)^\\top = Y^\\top X^\\top$，我们可以将其写为：\n$$\n\\left(U^{(2)}\\right)^\\top A U^{(1)} = \\left(U^{(2)}\\right)^\\top A^\\top U^{(1)} = \\left(A U^{(2)}\\right)^\\top U^{(1)}\n$$\n这一步依赖于 $A$ 的对称性，即 $A = A^\\top$。现在，代入第二个方程中的 $A U^{(2)} = b^{(2)}$：\n$$\n\\left(A U^{(2)}\\right)^\\top U^{(1)} = \\left(b^{(2)}\\right)^\\top U^{(1)}\n$$\n最后，由于行向量和列向量的乘积是一个标量，它等于其自身的转置。$(b^{(2)})^\\top U^{(1)}$ 的转置是 $(U^{(1)})^\\top b^{(2)}$。因此，\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}\n$$\n这个恒等式在代数层面上是精确成立的。任何数值上的偏差都必定源于非对称矩阵组装（程序错误）、两次求解使用不同矩阵，或线性求解器中的浮点舍入误差等。所提出的数值测试旨在测量这种偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly needed, numpy is sufficient\n\ndef run_reciprocity_test(N, k, a_func, b_func, f1_func, f2_func, A_perturbation=None):\n    \"\"\"\n    Assembles and solves two 1D Helmholtz problems using FEM and calculates the reciprocity discrepancy.\n    \n    Args:\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        a_func (callable): Coefficient function a(x).\n        b_func (callable): Coefficient function b(x).\n        f1_func (callable): Source function f1(x).\n        f2_func (callable): Source function f2(x).\n        A_perturbation (tuple, optional): A tuple (row, col, value) to perturb the matrix A for the \n                                          second solve. Defaults to None.\n    \n    Returns:\n        float: The reciprocity discrepancy |(U2)^T b1 - (U1)^T b2|.\n    \"\"\"\n    \n    # Mesh properties\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    # Initialize global stiffness and mass matrices, and load vectors\n    # Full size (N+1)x(N+1) to simplify assembly indexing\n    K = np.zeros((N + 1, N + 1))\n    M = np.zeros((N + 1, N + 1))\n    b1 = np.zeros(N + 1)\n    b2 = np.zeros(N + 1)\n    \n    # Element properties (constant for all elements with linear basis functions)\n    # Element stiffness matrix for a(x)=1, h=1\n    k_elem_base = np.array([[1, -1], [-1, 1]])\n    # Element mass matrix for b(x)=1, h=1\n    m_elem_base = np.array([[1/4, 1/4], [1/4, 1/4]])\n    \n    # Loop over elements to assemble the system\n    for i in range(N):\n        # Global indices for the current element's nodes\n        idx0, idx1 = i, i + 1\n        \n        # Midpoint of the element\n        midpoint = nodes[idx0] + h / 2.0\n        \n        # Evaluate coefficients and sources at the midpoint\n        a_mid = a_func(midpoint)\n        b_mid = b_func(midpoint)\n        f1_mid = f1_func(midpoint)\n        f2_mid = f2_func(midpoint)\n        \n        # Scale element matrices by coefficients and mesh size\n        k_elem = (a_mid / h) * k_elem_base\n        m_elem = (b_mid * h) * m_elem_base\n        \n        # Assemble element matrices into global matrices\n        K[idx0:idx1+1, idx0:idx1+1] += k_elem\n        M[idx0:idx1+1, idx0:idx1+1] += m_elem\n        \n        # Assemble element load vectors\n        b1[idx0] += h * f1_mid * 0.5\n        b1[idx1] += h * f1_mid * 0.5\n        b2[idx0] += h * f2_mid * 0.5\n        b2[idx1] += h * f2_mid * 0.5\n\n    # Form the system matrix A\n    A = K - k**2 * M\n    \n    # Enforce homogeneous Dirichlet boundary conditions by using only interior nodes\n    # The interior system involves nodes 1 to N-1\n    A_int = A[1:N, 1:N]\n    b1_int = b1[1:N]\n    b2_int = b2[1:N]\n    \n    # --- Solve for U1 ---\n    # The matrix for the first solve is always the unperturbed one\n    U1 = np.linalg.solve(A_int, b1_int)\n    \n    # --- Solve for U2 ---\n    # The matrix for the second solve might be perturbed\n    A2_int = A_int.copy()\n    if A_perturbation:\n        row, col, value = A_perturbation\n        A2_int[row, col] += value\n    \n    U2 = np.linalg.solve(A2_int, b2_int)\n    \n    # --- Calculate reciprocity discrepancy ---\n    # r = | (U2)^T @ b1 - (U1)^T @ b2 |\n    discrepancy = np.abs(U2.T @ b1_int - U1.T @ b2_int)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the reciprocity check.\n    \"\"\"\n    \n    # Test 1: Happy path, smooth coefficients and sources\n    N1 = 64\n    k1 = 7.3\n    a1 = lambda x: 1.0\n    b1 = lambda x: 1.0\n    f1_1 = lambda x: np.sin(3 * np.pi * x)\n    f2_1 = lambda x: np.cos(5 * np.pi * x)\n    \n    # Test 2: Heterogeneous coefficient, smooth localized sources\n    N2 = 64\n    k2 = 4.2\n    a2 = lambda x: 3.0 if x >= 0.5 else 1.0\n    b2 = lambda x: 1.0\n    f1_2 = lambda x: np.exp(-100 * (x - 0.3)**2)\n    f2_2 = lambda x: np.exp(-120 * (x - 0.7)**2)\n    \n    # Test 3: Boundary-size mesh, coarse discretization edge case\n    N3 = 2\n    k3 = 2.0\n    a3 = lambda x: 1.0\n    b3 = lambda x: 1.0\n    f1_3 = lambda x: x * (1 - x)\n    f2_3 = lambda x: 1 - 2 * x\n\n    # Test 4: Intentional reciprocity violation via a skew perturbation\n    N4 = 64 # Same as Test 1\n    k4 = 7.3\n    a4 = lambda x: 1.0\n    b4 = lambda x: 1.0\n    f1_4 = lambda x: np.sin(3 * np.pi * x)\n    f2_4 = lambda x: np.cos(5 * np.pi * x)\n    # The interior matrix indices are 0...N-2.\n    # Node p = floor(N/2) = 32 has matrix index 32-1=31.\n    # Node p+1 = 33 has matrix index 33-1=32.\n    perturbation = (31, 32, 1e-2)\n\n    test_cases = [\n        (N1, k1, a1, b1, f1_1, f2_1, None),\n        (N2, k2, a2, b2, f1_2, f2_2, None),\n        (N3, k3, a3, b3, f1_3, f2_3, None),\n        (N4, k4, a4, b4, f1_4, f2_4, perturbation),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_reciprocity_test(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3360923"}, {"introduction": "理论的威力在于其能够指导和验证实践。在这个动手编程练习中，您将把离散互易原理实现为一个对有限元求解器的数值“试金石”。您将编写一个程序来检测那些破坏矩阵对称性的微小实现错误，这些错误在常规测试中可能难以发现。这个练习将有力地展示，抽象的数学性质如何能转化为调试和确保科学计算代码正确性的实用工具。[@problem_id:3360923]", "problem": "考虑一个标量亥姆霍兹边值问题，该问题是作为无损、非均匀、一维介质中时谐电磁波传播的模型简化而产生的。令 $\\Omega = (0,1)$，并设 $a(x)$ 和 $b(x)$ 为代表有效材料参数的实值、有界、严格正的系数函数。对于给定的实数波数 $k \\in \\mathbb{R}$ 和给定的源函数 $f \\in L^2(\\Omega)$，其强形式为：求 $u:\\Omega \\to \\mathbb{R}$ 使得\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\quad u(1)=0,\n$$\n其中所有量均为无量纲。\n\n1) 从散度定理和索博列夫空间 $H_0^1(\\Omega)$ 的定义出发，推导其弱形式：求 $u \\in H_0^1(\\Omega)$ 使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n明确指出 $a(x)$、$b(x)$ 和边界条件的哪些性质确保了双线性形式\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n是对称的。从第一性原理出发，解释为什么这种对称性意味着对应于源 $f_1,f_2 \\in L^2(\\Omega)$ 的任意两个弱解 $u_1,u_2 \\in H_0^1(\\Omega)$ 之间存在一个互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx.\n$$\n\n2) 考虑使用协调伽辽金有限元法 (FEM)，其基函数为定义在具有 $N$ 个单元的均匀网格上的全局连续分段线性函数。令 $\\{\\phi_i(x)\\}_{i=0}^N$ 表示在区间 $[0,1]$ 剖分上的标准节点基，其节点为 $0=x_0  x_1  \\cdots  x_N = 1$。使用中点求积法进行逐单元组装，定义单元矩阵和向量以组装全局矩阵\n$$\nA \\equiv K - k^2 M,\n$$\n其中刚度矩阵项为 $K_{ij} \\approx \\int_0^1 a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx$，质量矩阵项为 $M_{ij} \\approx \\int_0^1 b(x)\\, \\phi_i(x)\\, \\phi_j(x)\\, dx$，载荷向量项为 $b_i \\approx \\int_0^1 f(x)\\, \\phi_i(x)\\, dx$。在端点处强施加齐次狄利克雷边界条件。从组装系统的代数结构出发，证明当 $A$ 是对称的，并且两个离散解 $U^{(1)}$ 和 $U^{(2)}$ 都满足 $A U^{(m)} = b^{(m)}$（其中 $A$ 相同）时，以下离散互易恒等式在有限精度算术中精确成立，误差仅为线性求解器的舍入误差：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}.\n$$\n\n3) 构建一个数值测试，通过计算差异\n$$\nr \\equiv \\left| \\left(U^{(2)}\\right)^\\top b^{(1)} - \\left(U^{(1)}\\right)^\\top b^{(2)} \\right|.\n$$\n来检测离散设置中违反互易性的实现错误。\n实现一个独立的程序，该程序：\n- 使用中点求积法组装一维分段线性有限元系统。\n- 求解两个分别以 $f_1$ 和 $f_2$ 为源的离散问题。\n- 报告互易性差异 $r$。\n\n您的程序必须评估以下测试套件，并输出四个差异值作为浮点数。所有量均为无量纲。\n\n- 测试 1（理想情况，光滑的系数和源）：\n  - $N = 64$, $k = 7.3$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = \\sin(3\\pi x)$, $f_2(x) = \\cos(5\\pi x)$,\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 2（非均匀系数，光滑的局部化源）：\n  - $N = 64$, $k = 4.2$,\n  - 当 $x  0.5$ 时 $a(x) = 1$，当 $x \\ge 0.5$ 时 $a(x) = 3$，$b(x) = 1$,\n  - $f_1(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right)$, $f_2(x) = \\exp\\!\\left(-120\\,(x-0.7)^2\\right)$,\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 3（极粗糙网格，粗糙离散化边缘情况）：\n  - $N = 2$, $k = 2.0$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = x\\,(1-x)$, $f_2(x) = 1 - 2x$,\n  - 两次求解均使用相同的组装矩阵 $A$。\n\n- 测试 4（通过模拟组装错误的斜扰动来故意违反互易性）：\n  - 从与测试 1 相同的配置开始。\n  - 组装对称矩阵 $A$ 后，通过向单个非对角内部元素添加一个斜扰动 $\\varepsilon = 10^{-2}$ 来创建一个扰动矩阵 $\\tilde{A}$：$\\tilde{A}_{p,p+1} \\leftarrow \\tilde{A}_{p,p+1} + \\varepsilon$ (其中 $p = \\lfloor N/2 \\rfloor$)，而不对 $\\tilde{A}_{p+1,p}$ 进行相应更改。\n  - 求解 $A U^{(1)} = b^{(1)}$ 和 $\\tilde{A} U^{(2)} = b^{(2)}$。\n  - 使用 $U^{(1)},U^{(2)},b^{(1)},b^{(2)}$ 计算 $r$。此配置应产生比测试 1-3 大几个数量级的差异。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个互易性差异，格式为方括号内的逗号分隔列表（例如，\"[r1,r2,r3,r4]\"）。每个 $r_m$ 必须是一个浮点数。不应打印任何附加文本。该问题完全无量纲；不需要物理单位，也不涉及角度。", "solution": "该问题要求对一维标量亥姆霍兹方程的互易原理进行理论推导和数值验证。我们将首先验证问题陈述，然后进行详细求解。\n\n### 第 1 部分：弱形式和互易恒等式的推导\n\n边值问题的强形式是求定义在域 $\\Omega = (0,1)$ 上的函数 $u:\\Omega \\to \\mathbb{R}$，使其满足：\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n并服从齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。系数 $a(x)$ 和 $b(x)$ 是实值、有界且严格为正的函数， $k \\in \\mathbb{R}$ 是波数，$f \\in L^2(\\Omega)$ 是源项。\n\n为推导弱形式，我们采用标准程序，即将微分方程乘以一个测试函数 $v$，然后在定义域 $\\Omega$ 上积分。解 $u$ 和测试函数 $v$ 的适当空间都是索博列夫空间 $H_0^1(\\Omega)$。该空间由 $L^2(\\Omega)$ 中的函数组成，这些函数的弱导数也在 $L^2(\\Omega)$ 中，并且满足齐次边界条件，即 $u(0)=v(0)=0$ 和 $u(1)=v(1)=0$。\n\n将强形式乘以 $v \\in H_0^1(\\Omega)$ 并积分可得：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n我们关注第一项并应用分部积分，这是一维版本的散度定理：$\\int_\\Omega (\\nabla \\cdot \\mathbf{F}) \\phi \\, dV = -\\int_\\Omega \\mathbf{F} \\cdot (\\nabla \\phi) \\, dV + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$。在一维中，这变为 $\\int_0^1 \\frac{dF}{dx} v \\, dx = [Fv]_0^1 - \\int_0^1 F\\frac{dv}{dx} \\, dx$。\n令 $F(x) = -a(x)\\frac{du}{dx}$，我们有：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx = - \\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 + \\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\n边界项 $\\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 = a(1)\\frac{du}{dx}(1)v(1) - a(0)\\frac{du}{dx}(0)v(0)$ 为零，因为测试函数 $v$ 属于 $H_0^1(\\Omega)$，这意味着 $v(0)=0$ 和 $v(1)=0$。\n\n将其代回积分方程，我们得到弱形式：求 $u \\in H_0^1(\\Omega)$ 使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n这可以写成抽象形式 $B(u,v) = L(v)$，其中 $B(u,v)$ 是双线性形式，$L(v)$ 是右侧的线性泛函。\n\n双线性形式 $B(u,v)$ 定义为：\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n为了使 $B(u,v)$ 是对称的，我们需要对所有 $u,v \\in H_0^1(\\Omega)$ 都有 $B(u,v) = B(v,u)$。让我们检查 $B(v,u)$:\n$$\nB(v,u) = \\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx - k^2 \\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx\n$$\n由于 $u(x)$、$v(x)$ 及其导数是标量实值函数，系数 $a(x)$ 和 $b(x)$ 也是实值的，因此这些函数的乘法是可交换的。即 $u'(x)v'(x) = v'(x)u'(x)$ 和 $u(x)v(x) = v(x)u(x)$。因此：\n$$\n\\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx\n$$\n$$\n\\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx = \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n这证明了 $B(u,v) = B(v,u)$。由于该问题处理的是实值函数和系数，因此双线性形式的对称性得到了保证。\n\n现在，我们推导互易恒等式。设 $u_1, u_2 \\in H_0^1(\\Omega)$ 分别是对应于两个不同源函数 $f_1, f_2 \\in L^2(\\Omega)$ 的两个弱解。根据弱解的定义，它们满足：\n1. 对所有 $v \\in H_0^1(\\Omega)$，有 $B(u_1, v) = \\int_0^1 f_1(x) v(x) dx$。\n2. 对所有 $v \\in H_0^1(\\Omega)$，有 $B(u_2, v) = \\int_0^1 f_2(x) v(x) dx$。\n\n由于 $u_1, u_2 \\in H_0^1(\\Omega)$，它们本身就是有效的测试函数。我们可以在第一个方程中选择 $v=u_2$，在第二个方程中选择 $v=u_1$：\n1. $B(u_1, u_2) = \\int_0^1 f_1(x) u_2(x) dx$\n2. $B(u_2, u_1) = \\int_0^1 f_2(x) u_1(x) dx$\n\n正如我们刚才所证明的，双线性形式 $B(\\cdot, \\cdot)$ 是对称的，从而 $B(u_1, u_2) = B(u_2, u_1)$。将上述两个表达式的右侧相等，即可得到互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx\n$$\n该恒等式表明，第一个源对第二个解所做的功等于第二个源对第一个解所做的功。\n\n### 第 2 部分：离散形式和互易性\n\n我们使用协调伽辽金有限元法 (FEM) 对问题进行离散化，基函数为在具有 $N$ 个单元、步长为 $h=1/N$ 的 $[0,1]$ 均匀网格上的分段线性函数 $\\phi_i(x)$。节点为 $x_i = i h$，其中 $i=0, \\dots, N$。帽函数 $\\phi_i(x)$ 在节点 $x_i$ 处为 1，在所有其他节点处为 0。\n\n有限元解 $u_h(x)$ 在由内部基函数 $\\{\\phi_i\\}_{i=1}^{N-1}$ 张成的有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中求解。解表示为这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\n$$\n其中 $U_j$ 是未知系数，代表解在内部节点 $x_j$ 处的值。注意，我们强施加了 $U_0=0$ 和 $U_N=0$。\n\n伽辽金方法要求弱形式对所有测试函数 $v_h \\in V_h$ 都成立。我们选择基函数本身作为测试函数，$v = \\phi_i(x)$ for $i=1, \\dots, N-1$:\n$$\nB\\left(\\sum_{j=1}^{N-1} U_j \\phi_j, \\phi_i\\right) = L(\\phi_i) \\quad \\text{for } i=1, \\dots, N-1\n$$\n根据双线性形式的线性性质，这变成一个线性方程组：\n$$\n\\sum_{j=1}^{N-1} U_j B(\\phi_j, \\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n这是代数系统 $A U = b$，其中 $U = [U_1, \\dots, U_{N-1}]^\\top$ 是未知节点值的向量，矩阵 $A$（大小为 $(N-1) \\times (N-1)$）和向量 $b$（大小为 $(N-1) \\times 1$）的项为：\n$$\nA_{ij} = B(\\phi_j, \\phi_i) = \\int_0^1 a(x) \\phi_j'(x) \\phi_i'(x) dx - k^2 \\int_0^1 b(x) \\phi_j(x) \\phi_i(x) dx\n$$\n$$\nb_i = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n问题指定使用中点求积法来组装系统。对于单元 $e_m = [x_{m-1}, x_m]$，其中点为 $x_{m-1/2} = (x_{m-1}+x_m)/2$：\n- 单元刚度矩阵 $K^{(m)}$ 的局部项为 $K_{ij}^{(m)} \\approx h \\cdot a(x_{m-1/2}) \\phi_j'(x_{m-1/2}) \\phi_i'(x_{m-1/2})$。局部线性基函数的导数是常数 $\\pm 1/h$。这导出了对称的单元矩阵：$K^{(m)} \\approx \\frac{a(x_{m-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n- 单元质量矩阵 $M^{(m)}$ 的局部项为 $M_{ij}^{(m)} \\approx h \\cdot b(x_{m-1/2}) \\phi_j(x_{m-1/2}) \\phi_i(x_{m-1/2})$。在单元中点，两个局部基函数的值均为 $1/2$。这导出了对称的单元矩阵：$M^{(m)} \\approx \\frac{h \\cdot b(x_{m-1/2})}{4} \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}$。\n- 单元载荷向量 $b^{(m)}$ 的项为 $b_i^{(m)} \\approx h \\cdot f(x_{m-1/2}) \\phi_i(x_{m-1/2})$。这得到 $b^{(m)} \\approx \\frac{h \\cdot f(x_{m-1/2})}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n全局矩阵 $K$ 和 $M$ 是通过将这些对称的单元贡献相加而形成的。对称矩阵之和是对称的，因此 $K$ 和 $M$ 是对称的。因此，系统矩阵 $A = K - k^2 M$ 也是对称的，即 $A = A^\\top$。\n\n现在，让我们推导离散互易恒等式。考虑两个具有相同矩阵 $A$ 但不同源 $b^{(1)}$ 和 $b^{(2)}$ 的离散问题：\n1. $A U^{(1)} = b^{(1)}$\n2. $A U^{(2)} = b^{(2)}$\n我们想证明 $(U^{(2)})^\\top b^{(1)} = (U^{(1)})^\\top b^{(2)}$。\n从左侧开始，代入第一个方程中的 $b^{(1)}$：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(2)}\\right)^\\top \\left(A U^{(1)}\\right)\n$$\n使用转置性质 $(XY)^\\top = Y^\\top X^\\top$，我们可以将其写为：\n$$\n\\left(U^{(2)}\\right)^\\top A U^{(1)} = \\left(U^{(2)}\\right)^\\top A^\\top U^{(1)} = \\left(A U^{(2)}\\right)^\\top U^{(1)}\n$$\n这一步依赖于 $A$ 的对称性，即 $A = A^\\top$。现在，从第二个方程代入 $A U^{(2)} = b^{(2)}$：\n$$\n\\left(A U^{(2)}\\right)^\\top U^{(1)} = \\left(b^{(2)}\\right)^\\top U^{(1)}\n$$\n最后，由于行向量和列向量的乘积是一个标量，它等于其自身的转置。$(b^{(2)})^\\top U^{(1)}$ 的转置是 $(U^{(1)})^\\top b^{(2)}$。因此，\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}\n$$\n这个恒等式在代数层面是精确成立的。任何数值偏差都必定源于非对称矩阵组装（程序错误）、两次求解使用了不同的矩阵，或线性求解器中的浮点舍入误差。所提出的数值测试旨在衡量这种偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly needed, numpy is sufficient\n\ndef run_reciprocity_test(N, k, a_func, b_func, f1_func, f2_func, A_perturbation=None):\n    \"\"\"\n    Assembles and solves two 1D Helmholtz problems using FEM and calculates the reciprocity discrepancy.\n    \n    Args:\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        a_func (callable): Coefficient function a(x).\n        b_func (callable): Coefficient function b(x).\n        f1_func (callable): Source function f1(x).\n        f2_func (callable): Source function f2(x).\n        A_perturbation (tuple, optional): A tuple (row, col, value) to perturb the matrix A for the \n                                          second solve. Defaults to None.\n    \n    Returns:\n        float: The reciprocity discrepancy |(U2)^T b1 - (U1)^T b2|.\n    \"\"\"\n    \n    # Mesh properties\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    # Initialize global stiffness and mass matrices, and load vectors\n    # Full size (N+1)x(N+1) to simplify assembly indexing\n    K = np.zeros((N + 1, N + 1))\n    M = np.zeros((N + 1, N + 1))\n    b1 = np.zeros(N + 1)\n    b2 = np.zeros(N + 1)\n    \n    # Element properties (constant for all elements with linear basis functions)\n    # Element stiffness matrix for a(x)=1, h=1\n    k_elem_base = np.array([[1, -1], [-1, 1]])\n    # Element mass matrix for b(x)=1, h=1\n    m_elem_base = np.array([[1/4, 1/4], [1/4, 1/4]])\n    \n    # Loop over elements to assemble the system\n    for i in range(N):\n        # Global indices for the current element's nodes\n        idx0, idx1 = i, i + 1\n        \n        # Midpoint of the element\n        midpoint = nodes[idx0] + h / 2.0\n        \n        # Evaluate coefficients and sources at the midpoint\n        a_mid = a_func(midpoint)\n        b_mid = b_func(midpoint)\n        f1_mid = f1_func(midpoint)\n        f2_mid = f2_func(midpoint)\n        \n        # Scale element matrices by coefficients and mesh size\n        k_elem = (a_mid / h) * k_elem_base\n        m_elem = (b_mid * h) * m_elem_base\n        \n        # Assemble element matrices into global matrices\n        K[idx0:idx1+1, idx0:idx1+1] += k_elem\n        M[idx0:idx1+1, idx0:idx1+1] += m_elem\n        \n        # Assemble element load vectors\n        b1[idx0] += h * f1_mid * 0.5\n        b1[idx1] += h * f1_mid * 0.5\n        b2[idx0] += h * f2_mid * 0.5\n        b2[idx1] += h * f2_mid * 0.5\n\n    # Form the system matrix A\n    A = K - k**2 * M\n    \n    # Enforce homogeneous Dirichlet boundary conditions by using only interior nodes\n    # The interior system involves nodes 1 to N-1\n    A_int = A[1:N, 1:N]\n    b1_int = b1[1:N]\n    b2_int = b2[1:N]\n    \n    # --- Solve for U1 ---\n    # The matrix for the first solve is always the unperturbed one\n    U1 = np.linalg.solve(A_int, b1_int)\n    \n    # --- Solve for U2 ---\n    # The matrix for the second solve might be perturbed\n    A2_int = A_int.copy()\n    if A_perturbation:\n        row, col, value = A_perturbation\n        A2_int[row, col] += value\n    \n    U2 = np.linalg.solve(A2_int, b2_int)\n    \n    # --- Calculate reciprocity discrepancy ---\n    # r = | (U2)^T @ b1 - (U1)^T @ b2 |\n    discrepancy = np.abs(U2.T @ b1_int - U1.T @ b2_int)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the reciprocity check.\n    \"\"\"\n    \n    # Test 1: Happy path, smooth coefficients and sources\n    N1 = 64\n    k1 = 7.3\n    a1 = lambda x: 1.0\n    b1 = lambda x: 1.0\n    f1_1 = lambda x: np.sin(3 * np.pi * x)\n    f2_1 = lambda x: np.cos(5 * np.pi * x)\n    \n    # Test 2: Heterogeneous coefficient, smooth localized sources\n    N2 = 64\n    k2 = 4.2\n    a2 = lambda x: 3.0 if x >= 0.5 else 1.0\n    b2 = lambda x: 1.0\n    f1_2 = lambda x: np.exp(-100 * (x - 0.3)**2)\n    f2_2 = lambda x: np.exp(-120 * (x - 0.7)**2)\n    \n    # Test 3: Boundary-size mesh, coarse discretization edge case\n    N3 = 2\n    k3 = 2.0\n    a3 = lambda x: 1.0\n    b3 = lambda x: 1.0\n    f1_3 = lambda x: x * (1 - x)\n    f2_3 = lambda x: 1 - 2 * x\n\n    # Test 4: Intentional reciprocity violation via a skew perturbation\n    N4 = 64 # Same as Test 1\n    k4 = 7.3\n    a4 = lambda x: 1.0\n    b4 = lambda x: 1.0\n    f1_4 = lambda x: np.sin(3 * np.pi * x)\n    f2_4 = lambda x: np.cos(5 * np.pi * x)\n    # The interior matrix indices are 0...N-2.\n    # Node p = floor(N/2) = 32 has matrix index 32-1=31.\n    # Node p+1 = 33 has matrix index 33-1=32.\n    perturbation = (31, 32, 1e-2)\n\n    test_cases = [\n        (N1, k1, a1, b1, f1_1, f2_1, None),\n        (N2, k2, a2, b2, f1_2, f2_2, None),\n        (N3, k3, a3, b3, f1_3, f2_3, None),\n        (N4, k4, a4, b4, f1_4, f2_4, perturbation),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_reciprocity_test(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3360923"}]}