{"hands_on_practices": [{"introduction": "基于梯度的拓扑优化其成功与否完全依赖于灵敏度计算的准确性。这个实践练习将指导你使用复步法（complex-step method）构建一个“黄金标准”的验证工具，这是一种用于计算高精度导数的数值稳定技术。通过实现这个方法来检验解析推导的伴随梯度，你不仅能对自己的代码建立信心，还能更深入地理解灵敏度分析的本质。[@problem_id:3356381]", "problem": "您的任务是为用于拓扑优化的频域电磁模型设计并实现一个复步梯度检验，以检验标量目标相对于空间分布的材料密度的灵敏度。该问题必须在计算电磁学的框架内构建，并从第一性原理出发。\n\n考虑谐波时间依赖下的二维横电 (TE) 极化。从麦克斯韦方程组及其频域形式出发，标量TE场满足一个亥姆霍兹型方程。在归一化单位下（并假设磁导率均匀），平面外场的控制方程强形式为\n$$\n\\nabla^2 u(\\mathbf{x}) + \\omega^2 \\mu \\epsilon(\\rho(\\mathbf{x}))\\, u(\\mathbf{x}) = s(\\mathbf{x}),\n$$\n其中 $u$ 是平面外电场分量，$\\omega$ 是角频率，$\\mu$ 是磁导率（常数），$\\epsilon(\\rho)$ 是随空间变化的介电常数，作为材料密度变量 $\\rho(\\mathbf{x}) \\in [0,1]$ 的函数，而 $s$ 是一个给定的源分布。假设在方形域上采用均匀狄利克雷边界条件以保证适定性。\n\n使用频域有限差分 (FDFD) 方法离散化控制方程，得到一个线性系统\n$$\nA(\\rho)\\, u = b,\n$$\n其中 $A(\\rho) = K + \\omega^2 \\mu\\, M(\\rho)$，$K$ 是在 $N \\times N$ 内部网格上带有均匀狄利克雷边界条件的离散拉普拉斯算子，$M(\\rho)$ 是一个对角矩阵，其对角元为对应网格点 $i$ 处的 $\\epsilon(\\rho_i)$。对介电常数采用一种物理上合理且单调递增的材料插值\n$$\n\\epsilon(\\rho) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\, \\rho,\n$$\n其中 $\\epsilon_{\\min}$ 和 $\\epsilon_{\\max}$ 为正实数。\n\n定义一个复值目标\n$$\nf(u) = c^\\top u,\n$$\n其中 $c$ 是一个固定的实数权重向量，用于选择场的一个线性泛函（例如，目标位置的场振幅或某个区域上的加权和）。这个目标函数适用于伴随灵敏度分析和复步验证，因为它对 $u$ 是线性的，并且通过 $u(\\rho)$ 对参数是全纯的。\n\n您的任务是：\n- 从离散控制方程和目标函数的定义出发，仅从上述第一性原理推导灵敏度 $df/d\\rho$ 的伴随表达式。您的推导必须明确应用链式法则、状态方程的线性化，并通过适当的转置系统引入伴随场。您必须通过明确说明任何假设（例如，恒定的 $\\mu$，实数 $\\epsilon(\\rho)$）来确保科学真实性。\n- 设计并实现一个复步梯度检验。也就是说，对于设计空间中选定的方向向量 $d$，用一个小的实数增量 $\\Delta$ 将设计变量扰动为 $\\rho \\mapsto \\rho + i\\, \\Delta\\, d$，求解扰动后的复数系统，计算 $f$，并计算方向导数估计\n$$\n\\frac{d f}{d \\rho}\\cdot d \\approx \\frac{\\operatorname{Im}\\left[f\\left(\\rho + i\\, \\Delta\\, d\\right)\\right]}{\\Delta}.\n$$\n解释为什么当 $\\epsilon(\\rho)$ 是实数且从 $\\rho$ 到 $A(\\rho)$ 的映射是解析的时，此过程有效，以及它如何避免相消误差。\n\n您的程序必须：\n- 在均匀狄利克雷边界条件下，使用标准的五点模板为 $N \\times N$ 内部网格构建 $K$，并组装 $A(\\rho) = K + \\omega^2 \\mu\\, \\operatorname{diag}(\\epsilon(\\rho))$。\n- 将 $b$ 构建为位于内部网格左侧附近的单点源，将 $c$ 构建为右侧附近的选择器（具体索引如下所述）。\n- 对于给定的方向 $d$ 和增量 $\\Delta$，计算伴随灵敏度向量 $g = df/d\\rho$ 和复步方向导数。\n- 对于每个测试案例，报告伴随方向导数 $g \\cdot d$ 与复步估计值之间的相对误差，定义为\n$$\n\\mathrm{err} = \\frac{\\left|\\, (g \\cdot d) - \\frac{\\operatorname{Im}(f(\\rho + i\\, \\Delta\\, d))}{\\Delta} \\,\\right|}{\\max\\left(\\left|g \\cdot d\\right|, 10^{-12}\\right)}.\n$$\n\n使用以下固定参数和测试套件：\n- 网格尺寸：每个维度 $N = 12$ 个内部点。网格间距归一化为 $1$。\n- 角频率：$\\omega = 10$（无量纲归一化单位）。\n- 磁导率：$\\mu = 1$（归一化单位）。\n- 介电常数界限：$\\epsilon_{\\min} = 1$, $\\epsilon_{\\max} = 12$。\n- 源向量 $b$：在网格索引 $(i,j) = (N//2, 1)$ 处具有单位振幅，使用行主序映射到单个索引。\n- 目标选择器 $c$：在相同排序下，位于网格索引 $(i,j) = (N//2, N-2)$ 处的单位选择器。\n- 设计变量 $\\rho \\in \\mathbb{R}^{N^2}$，其元素在 $[0,1]$ 区间内。\n\n测试案例：\n1. 理想路径：随机的 $\\rho$（从 $[0,1]$ 均匀抽取，种子为 $42$），方向 $d$ 为一个归一化到单位欧几里得范数的随机向量（相同种子），复步增量 $\\Delta = 10^{-20}$。\n2. 步长鲁棒性：与案例1相同，但 $\\Delta = 10^{-10}$。\n3. 边界设计极端情况：均匀设计 $\\rho = \\mathbf{0}$，方向 $d$ 为选择中心网格索引 $(i,j) = (N//2, N//2)$ 的标准基向量，且 $\\Delta = 10^{-20}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是一个浮点数，等于相应测试案例定义的相对误差。由于所有量都是无量纲数，输出中不需要物理单位。", "solution": "该问题要求对一个频域电磁模型进行伴随灵敏度分析的推导和验证，并使用复步法作为高精度基准。推导和实现将根据问题陈述中列出的第一性原理进行。\n\n### 1. 伴随灵敏度分析推导\n\n分析始于控制电场 $u$ 的离散方程组和标量目标函数 $f$。\n\n**给定：**\n- 状态方程: $A(\\rho)u = b$, 其中 $A(\\rho) = K + \\omega^2 \\mu M(\\rho)$\n- 目标函数: $f(u) = c^\\top u$\n\n此处，$\\rho$ 是设计变量（材料密度）向量，$u$ 是状态向量（离散化电场），$b$ 是源向量，$c$ 是目标权重向量。我们假设对于给定的参数，$A$ 是可逆的，从而保证 $u$ 有唯一解。目标是计算目标函数相对于设计变量的梯度，$g = \\frac{df}{d\\rho}$。\n\n梯度的分量为 $g_j = \\frac{df}{d\\rho_j}$，对应每个设计变量 $\\rho_j$。我们对目标函数 $f(u(\\rho))$ 应用链式法则：\n$$\n\\frac{df}{d\\rho_j} = \\frac{\\partial f}{\\partial u} \\frac{du}{d\\rho_j}\n$$\n项 $\\frac{\\partial f}{\\partial \\rho_j}$ 为零，因为 $f$ 仅通过 $u$ 隐式地依赖于 $\\rho_j$。根据定义 $f(u)=c^\\top u$，我们有 $\\frac{\\partial f}{\\partial u} = c^\\top$。因此，\n$$\n\\frac{df}{d\\rho_j} = c^\\top \\frac{du}{d\\rho_j}\n$$\n为了求得状态灵敏度向量 $\\frac{du}{d\\rho_j}$，我们对状态方程 $A u = b$ 关于 $\\rho_j$ 求导。假定源向量 $b$ 与 $\\rho$无关。\n$$\n\\frac{d}{d\\rho_j} (A(\\rho) u(\\rho)) = \\frac{d b}{d\\rho_j} = 0\n$$\n应用乘积法则：\n$$\n\\frac{\\partial A}{\\partial \\rho_j} u + A \\frac{du}{d\\rho_j} = 0\n$$\n求解 $\\frac{du}{d\\rho_j}$：\n$$\n\\frac{du}{d\\rho_j} = -A^{-1} \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n将此代回灵敏度的表达式中：\n$$\n\\frac{df}{d\\rho_j} = -c^\\top A^{-1} \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n这个表达式构成了灵敏度分析的“直接法”。如果设计变量的数量（$N^2$）很大，这种方法的计算成本会很高，因为它需要为每个变量求解一次 $A^{-1}$与一个向量的乘积。\n\n为了推导更高效的伴随法，我们重新组合这些项。我们定义伴随向量 $\\lambda$ 为以下线性系统的解：\n$$\nA^\\top \\lambda = c\n$$\n这使我们可以写出 $\\lambda^\\top = c^\\top (A^\\top)^{-1} = c^\\top (A^{-1})^\\top$。如果 $A$ 是对称的，如此处的情况（$K$ 是实对称矩阵，$M(\\rho)$ 是实对角矩阵，所以 $A$ 是实对称矩阵），则 $A^\\top = A$ 且 $\\lambda^\\top = c^\\top A^{-1}$。灵敏度表达式于是变为：\n$$\n\\frac{df}{d\\rho_j} = -\\lambda^\\top \\frac{\\partial A}{\\partial \\rho_j} u\n$$\n伴随法仅需一次正向求解（$Au=b$）来求得 $u$，以及一次伴随求解（$A^\\top \\lambda=c$）来求得 $\\lambda$。一旦 $u$ 和 $\\lambda$ 已知，每个 $\\rho_j$ 的梯度分量就可以被高效地计算出来。\n\n现在，我们来求 $\\frac{\\partial A}{\\partial \\rho_j}$ 的具体形式。矩阵 $A$ 定义为 $A(\\rho) = K + \\omega^2 \\mu M(\\rho)$。离散拉普拉斯算子 $K$、角频率 $\\omega$ 和磁导率 $\\mu$ 相对于 $\\rho$ 是常数。质量矩阵 $M(\\rho)$ 是对角矩阵，其对角元由材料插值法则给出：\n$M(\\rho) = \\operatorname{diag}(\\epsilon(\\rho_i))$, 其中 $\\epsilon(\\rho_i) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\rho_i$。\n\n$A$ 关于 $\\rho_j$ 的偏导数为：\n$$\n\\frac{\\partial A}{\\partial \\rho_j} = \\omega^2 \\mu \\frac{\\partial M(\\rho)}{\\partial \\rho_j}\n$$\n矩阵 $\\frac{\\partial M(\\rho)}{\\partial \\rho_j}$ 是一个对角矩阵，其中只有第 $j$ 个对角元素非零：\n$$\n\\left(\\frac{\\partial M(\\rho)}{\\partial \\rho_j}\\right)_{ii} = \\frac{d\\epsilon(\\rho_i)}{d\\rho_j} = (\\epsilon_{\\max} - \\epsilon_{\\min}) \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ。因此，$\\frac{\\partial A}{\\partial \\rho_j}$ 是一个只有一个非零项的矩阵，该非零项位于位置 $(j,j)$，其值为 $\\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min})$。\n灵敏度则为：\n$$\n\\frac{df}{d\\rho_j} = -\\lambda^\\top \\left( \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) E_{jj} \\right) u\n$$\n其中 $E_{jj}$ 是一个在 $(j,j)$ 位置为 $1$、其余位置为零的矩阵。这可简化为：\n$$\n\\frac{df}{d\\rho_j} = - \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) \\lambda_j u_j\n$$\n完整的梯度向量 $g = df/d\\rho$ 可以使用哈达玛（逐元素）积 $\\odot$ 紧凑地表示为：\n$$\ng = - \\omega^2 \\mu (\\epsilon_{\\max} - \\epsilon_{\\min}) (\\lambda \\odot u)\n$$\n\n### 2. 复步梯度检验\n\n复步法是一种数值微分技术，它能够提供高精度的导数，同时避免了有限差分法中固有的相消误差。\n\n考虑一个标量函数 $g(\\alpha) = f(\\rho + \\alpha d)$，其中 $\\alpha$ 是一个标量，$d$ 是一个方向向量。$f$ 在 $\\rho$ 点沿方向 $d$ 的方向导数是 $g'(0)$。为了计算它，我们使用一个复数步长。如果函数 $f$（以及 $g$）是解析的，它可以在 $\\alpha=0$ 附近展开为泰勒级数。在一个纯虚步长 $\\alpha = i\\Delta$ 处求值：\n$$\ng(i\\Delta) = g(0) + g'(0)(i\\Delta) + \\frac{g''(0)}{2!}(i\\Delta)^2 + \\frac{g'''(0)}{3!}(i\\Delta)^3 + \\mathcal{O}(\\Delta^4)\n$$\n$$\ng(i\\Delta) = g(0) + i g'(0)\\Delta - \\frac{g''(0)}{2}\\Delta^2 - i \\frac{g'''(0)}{6}\\Delta^3 + \\mathcal{O}(\\Delta^4)\n$$\n假设当 $\\alpha$ 为实数时 $g(\\alpha)$ 为实数，那么 $g(0) = f(\\rho)$ 是实数，其各阶导数 $g^{(k)}(0)$ 也都是实数。取上述方程的虚部：\n$$\n\\operatorname{Im}[g(i\\Delta)] = g'(0)\\Delta - \\frac{g'''(0)}{6}\\Delta^3 + \\mathcal{O}(\\Delta^5)\n$$\n求解 $g'(0)$：\n$$\ng'(0) = \\frac{\\operatorname{Im}[g(i\\Delta)]}{\\Delta} + \\frac{g'''(0)}{6}\\Delta^2 + \\mathcal{O}(\\Delta^4)\n$$\n因此，方向导数的复步近似为：\n$$\n\\frac{df}{d\\rho} \\cdot d = g'(0) \\approx \\frac{\\operatorname{Im}[f(\\rho + i\\Delta d)]}{\\Delta}\n$$\n主导误差项是 $\\mathcal{O}(\\Delta^2)$ 阶，这允许通过选择一个非常小的 $\\Delta$（例如 $\\Delta=10^{-20}$）来获得高精度。关键是，这个公式不涉及两个几乎相等的数的相减，从而绕过了在小步长下困扰有限差分格式的舍入误差。\n\n该方法对当前问题有效，因为映射 $\\rho \\mapsto f(\\rho)$ 是解析的。这可以通过检查依赖链来看出：\n1.  $\\rho \\mapsto \\epsilon(\\rho) = \\epsilon_{\\min} + (\\epsilon_{\\max} - \\epsilon_{\\min})\\rho$。这是一个线性函数，因此是解析的。\n2.  $\\epsilon(\\rho) \\mapsto A(\\rho) = K + \\omega^2 \\mu \\operatorname{diag}(\\epsilon(\\rho))$。这也是关于 $\\epsilon$ 的线性函数，因此关于 $\\rho$ 是解析的。\n3.  $A(\\rho) \\mapsto u(\\rho) = A(\\rho)^{-1}b$。矩阵求逆是一个解析操作，因此只要 $A(\\rho)$ 是非奇异的，$u(\\rho)$就是解析的。假定问题是非共振的。\n4.  $u(\\rho) \\mapsto f(u) = c^\\top u$。这是一个线性泛函，它是解析的。\n\n由于解析函数的复合仍是解析函数，所以 $f(\\rho)$ 是解析的，这证明了使用复步法是合理的。\n\n### 3. 实现与验证\n\n实现将按以下步骤进行：\n1.  为具有均匀狄利克雷边界条件的 $N \\times N$ 内部网格构建离散拉普拉斯算子 $K$。\n2.  对每个测试案例，定义设计向量 $\\rho$ 和方向向量 $d$。\n3.  **伴随法**：\n    a. 计算 $\\epsilon(\\rho)$ 并组装实对称矩阵 $A(\\rho)$。\n    b. 求解正向系统 $A u = b$ 得到场 $u$。\n    c. 求解伴随系统 $A^{\\top} \\lambda = c$ （由于对称性即为 $A \\lambda = c$）得到伴随场 $\\lambda$。\n    d. 使用推导出的公式计算梯度向量 $g$。\n    e. 计算方向导数 $g \\cdot d$。\n4.  **复步法**：\n    a. 构造复数设计向量 $\\rho_{\\text{cs}} = \\rho + i\\Delta d$。\n    b. 计算复介电常数 $\\epsilon(\\rho_{\\text{cs}})$ 并组装复对称矩阵 $A(\\rho_{\\text{cs}})$。\n    c. 求解复数系统 $A_{\\text{cs}} u_{\\text{cs}} = b$ 得到复数场 $u_{\\text{cs}}$。\n    d. 计算复目标函数 $f_{\\text{cs}} = c^\\top u_{\\text{cs}}$。\n    e. 计算方向导数近似值 $\\operatorname{Im}(f_{\\text{cs}})/\\Delta$。\n5.  按照规定计算伴随法结果与复步法结果之间的相对误差。这可用于验证伴随法的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, eye\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating adjoint sensitivities for a 2D FDFD\n    electromagnetic model using the complex-step method.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 12\n    omega = 10.0\n    mu = 1.0\n    eps_min = 1.0\n    eps_max = 12.0\n    grid_spacing = 1.0\n\n    # Total number of degrees of freedom (interior grid points)\n    N_dof = N * N\n\n    # Construct the 2D discrete Laplacian K for an N x N interior grid\n    # with homogeneous Dirichlet boundary conditions.\n    # The five-point stencil for del^2 u is (u_i-1 + u_i+1 + ... - 4*u_i) / h^2.\n    # With h=1, the matrix entries are 1 for neighbors and -4 for the center.\n    # We use the kronecker product of 1D Laplacian matrices to build the 2D operator.\n    T_N = diags([1, -2, 1], [-1, 0, 1], shape=(N, N), format='csc') / (grid_spacing**2)\n    I_N = eye(N, format='csc')\n    K = kron(I_N, T_N) + kron(T_N, I_N)\n\n    # Define source vector b and objective selector c.\n    # Indices are based on row-major ordering: idx = row * N + col.\n    src_idx = (N // 2) * N + 1\n    obj_idx = (N // 2) * N + (N - 2)\n\n    b = np.zeros(N_dof, dtype=np.float64)\n    b[src_idx] = 1.0\n\n    c = np.zeros(N_dof, dtype=np.float64)\n    c[obj_idx] = 1.0\n\n    # Define the test cases.\n    test_cases = [\n        {'seed': 42, 'rho_type': 'random', 'd_type': 'random_normalized', 'delta': 1e-20},\n        {'seed': 42, 'rho_type': 'random', 'd_type': 'random_normalized', 'delta': 1e-10},\n        {'seed': None, 'rho_type': 'zeros', 'd_type': 'basis', 'delta': 1e-20},\n    ]\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        # --- 1. Set up design (rho) and direction (d) vectors for the case ---\n        if case['rho_type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            rho = rng.random(N_dof)\n        elif case['rho_type'] == 'zeros':\n            rho = np.zeros(N_dof)\n\n        if case['d_type'] == 'random_normalized':\n            # Use the same seed for d to ensure reproducibility with rho\n            rng = np.random.default_rng(case['seed'])\n            d = rng.random(N_dof)\n            d /= np.linalg.norm(d)\n        elif case['d_type'] == 'basis':\n            d_idx = (N // 2) * N + (N // 2)\n            d = np.zeros(N_dof)\n            d[d_idx] = 1.0\n        \n        delta = case['delta']\n\n        # --- 2. Adjoint Sensitivity Calculation ---\n        # Material interpolation: eps(rho)\n        eps_rho = eps_min + (eps_max - eps_min) * rho\n        M_rho = diags(eps_rho, 0, shape=(N_dof, N_dof), format='csc')\n        \n        # System matrix: A(rho) = K + omega^2 * mu * M(rho)\n        A = K + (omega**2 * mu) * M_rho\n\n        # Solve forward problem: A * u = b\n        u = spsolve(A, b)\n        \n        # Solve adjoint problem: A.T * lambda = c\n        # Since A is real and symmetric, A.T = A.\n        lambda_adj = spsolve(A.T, c)\n\n        # Compute gradient vector g = df/d(rho)\n        # g_j = -omega^2 * mu * (eps_max - eps_min) * lambda_j * u_j\n        g = -(omega**2 * mu * (eps_max - eps_min)) * (lambda_adj * u)\n        \n        # Compute directional derivative: g . d\n        adjoint_deriv = np.dot(g, d)\n\n        # --- 3. Complex-Step Derivative Calculation ---\n        # Perturb design variable: rho_cs = rho + i*delta*d\n        rho_cs = rho + 1j * delta * d\n        \n        # Complex material properties and system matrix\n        eps_rho_cs = eps_min + (eps_max - eps_min) * rho_cs\n        M_rho_cs = diags(eps_rho_cs, 0, shape=(N_dof, N_dof), format='csc')\n        A_cs = K + (omega**2 * mu) * M_rho_cs\n        \n        # Solve complex forward system: A_cs * u_cs = b\n        u_cs = spsolve(A_cs, b)\n        \n        # Evaluate complex objective function: f_cs = c.T * u_cs\n        f_cs = np.dot(c, u_cs)\n        \n        # Compute complex-step derivative estimate\n        cs_deriv = np.imag(f_cs) / delta\n\n        # --- 4. Calculate Relative Error ---\n        numerator = np.abs(adjoint_deriv - cs_deriv)\n        # Use a floor for the denominator to handle cases where the derivative is near zero\n        denominator = np.maximum(np.abs(adjoint_deriv), 1e-12)\n        relative_error = numerator / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3356381"}, {"introduction": "初级的拓扑优化算法常常会产生包含非物理“棋盘格”和中间“灰色”材料密度的结果，这些结果无法被制造。本练习将通过动手实践，教你实现两种基本的正则化技术：密度滤波器，用以强制施加最小特征尺寸；以及平滑的亥维赛德投影（Heaviside projection），用以获得清晰的黑白设计。掌握这些技术对于生成实用且高性能的器件布局至关重要。[@problem_id:3356441]", "problem": "考虑在均匀笛卡尔网格上离散化的有界域中，角频率为 $\\omega$、电场为 $\\mathbf{E}$、磁导率为 $\\mu$、介电常数为 $\\varepsilon$、外加电流密度为 $\\mathbf{J}$ 的时谐麦克斯韦方程组。其控制方程可以写成旋度-旋度形式\n$$\n\\nabla \\times \\left( \\mu^{-1} \\nabla \\times \\mathbf{E} \\right) - \\omega^2 \\varepsilon(\\rho) \\mathbf{E} = i \\omega \\mathbf{J},\n$$\n其中 $\\varepsilon(\\rho)$ 表示材料插值，它依赖于单元级的设计变量密度 $\\rho \\in [0,1]$。在基于密度的拓扑优化中，强制施加最小特征尺寸和促进材料的近二值化对于抑制非物理的棋盘格和灰度区域至关重要，这些现象会降低电磁性能和可制造性。一种标准方法是组合使用空间密度滤波器和平滑的亥维赛投影：\n$$\n\\tilde{\\rho} = \\mathrm{proj}\\!\\left( \\mathrm{filter}(\\rho) \\right),\n$$\n其中 $\\mathrm{filter}$ 强制施加最小长度尺度，而 $\\mathrm{proj}$ 将密度推向 $0$ 或 $1$，同时为基于梯度的优化保留可微性。\n\n您将实现以下算子，并分析针对投影锐度参数的连续化策略，以减少棋盘格现象：\n\n1. 密度滤波器。假设网格大小为 $N \\times N$，单位网格间距。对于给定的滤波器半径 $r > 0$，定义权重\n$$\nw_{ij} = \\max\\!\\left( 0,\\, r - d_{ij} \\right),\n$$\n其中 $d_{ij}$ 是像素 $i$ 和像素 $j$ 之间的欧几里得距离（以网格间距为单位），$i$ 和 $j$ 是网格位置的索引。像素 $i$ 处的滤波后密度为\n$$\n\\hat{\\rho}_i = \\frac{\\sum_j w_{ij} \\rho_j}{\\sum_j w_{ij}}.\n$$\n在均匀网格上，$w_{ij}$ 仅取决于像素之间的相对偏移，因此滤波可以通过与径向对称核的卷积，然后进行逐点归一化来实现：\n$$\n\\hat{\\rho} = \\frac{K * \\rho}{K * \\mathbf{1}},\n$$\n其中 $K$ 是权重 $w_{ij}$ 构成的核，* 表示在边界处进行零填充的离散卷积，$\\mathbf{1}$ 是全为1的图像。\n\n2. 亥维赛投影。对于锐度参数 $\\beta > 0$ 和阈值 $\\eta \\in (0,1)$，使用平滑投影\n$$\n\\tilde{\\rho}_i = \\frac{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n该映射对于 $\\hat{\\rho}$ 是可微的，基于梯度的更新所需的导数为\n$$\n\\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} = \\frac{\\beta \\left( 1 - \\tanh^2\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n\n3. 用于正则化和二值化的代理目标函数。为了在不求解完整电磁场的情况下研究滤波和投影的效果，我们考虑关于投影密度的代理泛函\n$$\n\\Phi(\\tilde{\\rho}) = \\lambda_{\\mathrm{smooth}} \\sum_{i} \\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2 \\;+\\; \\lambda_{\\mathrm{binary}} \\sum_i \\tilde{\\rho}_i (1 - \\tilde{\\rho}_i) \\;+\\; \\lambda_{\\mathrm{target}} \\sum_i T_i \\tilde{\\rho}_i,\n$$\n其中 $\\nabla$ 是单位间距的离散梯度，$\\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2$ 是通过在平滑项的梯度中使用标准的5点离散拉普拉斯算子实现的，$T$ 是一个固定的目标掩模，用于鼓励在指定子区域内存在材料。其相对于 $\\tilde{\\rho}$ 的导数为\n$$\n\\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T,\n$$\n其中 $\\Delta$ 表示离散拉普拉斯算子。根据链式法则，可得相对于原始设计变量 $\\rho$ 的梯度：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho_j} = \\sum_i \\left( \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} \\cdot \\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} \\right) \\;=\\; \\sum_i \\left( g^{\\mathrm{tilde}}_i \\cdot s_i \\cdot \\frac{w_{ij}}{\\sum_k w_{ik}} \\right),\n$$\n其中 $g^{\\mathrm{tilde}} = \\partial \\Phi / \\partial \\tilde{\\rho}$ 且 $s_i = \\partial \\tilde{\\rho}_i / \\partial \\hat{\\rho}_i$。在计算上，这可以通过将场 $g^{\\mathrm{tilde}} \\cdot s / (K * \\mathbf{1})$ 与核 $K$ 进行卷积来求值。\n\n4. 关于 $\\beta$ 的连续化策略。连续化策略选择一个递增的 $\\beta$ 值序列，以逐渐锐化投影，同时避免过早的不可微性，这种不可微性可能会锁定棋盘格图案。您将模拟在计划中每个 $\\beta$ 值下，以步长 $\\alpha > 0$ 对 $\\rho$ 进行固定次数迭代的梯度下降更新：\n$$\n\\rho^{(k+1)} = \\mathrm{clip}_{[0,1]}\\!\\left( \\rho^{(k)} - \\alpha \\frac{\\partial \\Phi}{\\partial \\rho}\\bigg|_{\\rho^{(k)}} \\right),\n$$\n其中在每次迭代中，$\\hat{\\rho} = \\mathrm{filter}(\\rho)$，$\\tilde{\\rho} = \\mathrm{proj}_{\\beta,\\eta}(\\hat{\\rho})$，并且 $\\partial \\Phi / \\partial \\rho$ 通过上述链式法则计算。\n\n5. 评价指标。完成连续化计划后，计算最终 $\\tilde{\\rho}$ 的以下两个指标：\n- 棋盘格指数\n$$\nI_{\\mathrm{cb}} = \\frac{\\left| \\sum_{i,j} \\tilde{\\rho}_{ij} (-1)^{i + j} \\right|}{\\sum_{i,j} \\left| \\tilde{\\rho}_{ij} \\right|}.\n$$\n这量化了与交替高频图案的归一化相关性。\n- 灰度（二值化惩罚）\n$$\nG = \\frac{1}{N^2} \\sum_{i,j} 4 \\tilde{\\rho}_{ij} (1 - \\tilde{\\rho}_{ij}),\n$$\n对于完全二值化的设计，该值为 $0$；当所有条目都等于 $0.5$ 时，该值为 $1$。\n\n实现细节：\n- 使用单位网格间距；滤波器半径 $r$ 以网格间距为单位进行测量。\n- 在边界处使用零填充进行卷积。\n- 对离散拉普拉斯算子使用标准的5点模板，并通过复制边缘进行类诺伊曼（Neumann-like）边界处理。\n- 使用 $\\lambda_{\\mathrm{smooth}} = 0.1$，$\\lambda_{\\mathrm{binary}} = 1.0$，$\\lambda_{\\mathrm{target}} = 0.05$ 和步长 $\\alpha = 0.2$。\n- 目标掩模 $T$ 定义为：在网格中心的 $6 \\times 6$ 方框内 $T_{ij} = -1$，其他位置 $T_{ij} = 0$；这鼓励在中心区域存在材料。\n\n测试套件：\n对于每个测试用例，运行连续化计划，每个 $\\beta$ 值的迭代次数固定为 $10$ 次。\n\n- 测试用例 1（正常情况）：$N = 16$，$r = 3.0$，$\\eta = 0.5$，计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$，初始 $\\rho$ 在 $[0,1]$ 上独立同分布均匀，随机种子为 $0$。\n- 测试用例 2（边界条件：均匀初始设计）：$N = 16$，$r = 3.0$，$\\eta = 0.5$，计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$，所有 $i,j$ 的初始 $\\rho_{ij} = 0.5$。\n- 测试用例 3（边缘情况：几乎没有滤波和激进的投影）：$N = 16$，$r = 1.0$，$\\eta = 0.5$，计划 $\\beta = [16.0, 16.0, 16.0, 16.0]$，如果 $(i + j)$ 是偶数，则初始 $\\rho_{ij} = 1$，否则 $\\rho_{ij} = 0$（完美的棋盘格）。\n- 测试用例 4（大滤波器半径和非单调连续化）：$N = 16$，$r = 7.9$，$\\eta = 0.5$，计划 $\\beta = [1.0, 1.0, 2.0, 1.0, 4.0]$，初始 $\\rho$ 在 $[0,1]$ 上独立同分布均匀，随机种子为 $42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果是一个包含两个浮点数条目的列表 $[I_{\\mathrm{cb}}, G]$。总输出是这些逐测试用例列表的列表，例如 $\\left[ [I_{\\mathrm{cb},1}, G_1], [I_{\\mathrm{cb},2}, G_2], [I_{\\mathrm{cb},3}, G_3], [I_{\\mathrm{cb},4}, G_4] \\right]$。", "solution": "我们从时谐麦克斯韦方程组开始，其离散形式引出一个旋度-旋度算子和一个材料插值 $\\varepsilon(\\rho)$，该插值将电磁响应与设计变量密度场 $\\rho \\in [0,1]$ 联系起来。在基于密度的拓扑优化中，由于旋度-旋度算子和刚度插值的离散特性，可能会出现网格尺度上的数值振荡，这表现为棋盘格现象：一种交替的高频图案，它能最小化离散能量，但并不对应于物理上可实现的结构。强制施加最小特征尺寸和促进近二值化设计是标准的解决方法。\n\n强制施加最小特征尺寸是通过对设计变量施加空间滤波器来实现的。在单位间距的网格上，一个半径为 $r$ 的基于距离的滤波器使用权重 $w_{ij} = \\max(0, r - d_{ij})$ 来构成\n$$\n\\hat{\\rho}_i = \\frac{\\sum_j w_{ij} \\rho_j}{\\sum_j w_{ij}}.\n$$\n因为 $w_{ij}$ 仅取决于相对偏移，我们可以将其实现为与核 $K$ 的卷积，然后使用 $K * \\mathbf{1}$ 进行逐点归一化。这会抑制小于 $r$ 的特征，并衰减导致棋盘格现象的高空间频率。\n\n为了鼓励近二值化材料，我们应用一个带有阈值 $\\eta$ 和锐度 $\\beta$ 的平滑亥维赛投影：\n$$\n\\tilde{\\rho}_i = \\frac{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n当 $\\beta \\to \\infty$ 时，此映射趋近于阶跃函数，但对于有限的 $\\beta$，它保持可微。其导数为\n$$\n\\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} = \\frac{\\beta \\left( 1 - \\tanh^2\\!\\left( \\beta (\\hat{\\rho}_i - \\eta) \\right) \\right)}{\\tanh\\!\\left( \\beta \\eta \\right) + \\tanh\\!\\left( \\beta (1 - \\eta) \\right)}.\n$$\n该导数缩放了灵敏度，从而控制投影对梯度的影响有多锐利。\n\n为了在不求解电磁场的情况下研究这些算子的效果，我们定义一个代理目标函数，该函数编码了两种正则化机制和一个温和的目标偏好：\n$$\n\\Phi(\\tilde{\\rho}) = \\lambda_{\\mathrm{smooth}} \\sum_i \\left\\| \\nabla \\tilde{\\rho}_i \\right\\|^2 + \\lambda_{\\mathrm{binary}} \\sum_i \\tilde{\\rho}_i (1 - \\tilde{\\rho}_i) + \\lambda_{\\mathrm{target}} \\sum_i T_i \\tilde{\\rho}_i.\n$$\n第一项惩罚 $\\tilde{\\rho}$ 中的高梯度，类似于不鼓励可能导致数值伪影的材料快速变化。第二项通过使 $\\tilde{\\rho}_i$ 接近 $0$ 或 $1$ 来惩罚灰度区域。第三项引入一个简单的目标掩模 $T$，以使问题非平凡，并模拟在场可能集中的区域对材料的偏好。为了计算梯度，我们对 $\\left\\| \\nabla \\tilde{\\rho} \\right\\|^2$ 使用离散的5点拉普拉斯算子 $\\Delta$，得到\n$$\n\\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T.\n$$\n\n链式法则将灵敏度传播回 $\\rho$：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho_j} = \\sum_i \\left( \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i} \\cdot \\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} \\right).\n$$\n给定\n$$\n\\frac{\\partial \\hat{\\rho}_i}{\\partial \\rho_j} = \\frac{w_{ij}}{\\sum_k w_{ik}},\n$$\n计算可简化为构造场\n$$\ng^{\\mathrm{hat}}_i = \\frac{\\partial \\Phi}{\\partial \\tilde{\\rho}_i} \\cdot \\frac{\\partial \\tilde{\\rho}_i}{\\partial \\hat{\\rho}_i}, \\quad f_i = \\frac{g^{\\mathrm{hat}}_i}{\\sum_k w_{ik}},\n$$\n然后将 $f$ 与 $K$ 进行卷积：\n$$\n\\frac{\\partial \\Phi}{\\partial \\rho} = K * f.\n$$\n这与滤波器归一化保持一致，并通过零填充和归一化图 $K * \\mathbf{1}$ 正确处理了边界效应。\n\n我们执行步长为 $\\alpha$ 的梯度下降，并通过裁剪到 $[0,1]$ 区间来强制施加对 $\\rho$ 的箱式约束：\n$$\n\\rho^{(k+1)} = \\mathrm{clip}_{[0,1]}\\!\\left( \\rho^{(k)} - \\alpha \\frac{\\partial \\Phi}{\\partial \\rho} \\right).\n$$\n在每次迭代中，我们重新计算 $\\hat{\\rho} = \\mathrm{filter}(\\rho)$，$\\tilde{\\rho} = \\mathrm{proj}(\\hat{\\rho})$，并通过链式法则计算梯度。\n\n$\\beta$ 的连续化通过首先使用适中的 $\\beta$ 值进行数次迭代，然后增加 $\\beta$ 以锐化投影来实现。其基本原理是，较小的 $\\beta$ 值可以保持灵敏度的平滑性，从而允许滤波器和平滑度惩罚项在投影将密度推向二值化之前抑制高频内容。过早使用过于激进的 $\\beta$ 值可能会锁定高频棋盘格，尤其是在滤波器半径 $r$ 较小的情况下。\n\n我们评估最终 $\\tilde{\\rho}$ 的两个指标：\n- 棋盘格指数\n$$\nI_{\\mathrm{cb}} = \\frac{\\left| \\sum_{i,j} \\tilde{\\rho}_{ij} (-1)^{i+j} \\right|}{\\sum_{i,j} \\left| \\tilde{\\rho}_{ij} \\right|}.\n$$\n如果 $\\tilde{\\rho}$ 与棋盘格非常相似，则分子相对于分母会变得很大，在极端情况下会接近 $1$。对于均匀或低频图案，分子会抵消，从而使 $I_{\\mathrm{cb}}$ 变小。\n- 灰度\n$$\nG = \\frac{1}{N^2} \\sum_{i,j} 4 \\tilde{\\rho}_{ij} (1 - \\tilde{\\rho}_{ij}),\n$$\n对于二值化设计，其值为 $0$；对于均匀的 $\\tilde{\\rho} = 0.5$，其值为 $1$。\n\n我们使用固定的常数 $\\lambda_{\\mathrm{smooth}} = 0.1$，$\\lambda_{\\mathrm{binary}} = 1.0$，$\\lambda_{\\mathrm{target}} = 0.05$ 和 $\\alpha = 0.2$。目标掩模 $T$ 在中心的 $6 \\times 6$ 方框内为 $-1$，其他位置为 $0$，这在最小化 $\\Phi$ 时有效地激励了中心区域材料的存在。\n\n测试套件探讨了：\n- 一个典型情况（$N = 16$，$r = 3.0$，$\\eta = 0.5$，计划 $\\beta = [1.0, 2.0, 4.0, 8.0]$），使用随机初始 $\\rho$ 来验证预期行为。\n- 一个均匀的初始 $\\rho = 0.5$，以测试在相同计划下二值化和目标偏好如何相互作用。\n- 一个几乎没有滤波的情况（$r = 1.0$）和激进的投影（$\\beta$ 固定为 $16.0$），从完美的棋盘格开始，以揭示滤波不足时的失效模式。\n- 一个大的滤波器半径（$r = 7.9$）和一个非单调的计划 $\\beta = [1.0, 1.0, 2.0, 1.0, 4.0]$，以测试强平滑下的鲁棒性。\n\n每个测试用例的算法步骤：\n1. 根据用例定义初始化 $\\rho$。\n2. 对于计划中的每个 $\\beta$，执行 $10$ 次梯度下降迭代：\n   - 构建半径为 $r$ 的核 $K$，其权重为 $w_{ij} = \\max(0, r - \\sqrt{\\Delta x^2 + \\Delta y^2})$。\n   - 计算 $\\hat{\\rho} = (K * \\rho) / (K * \\mathbf{1})$。\n   - 通过投影公式计算 $\\tilde{\\rho}$。\n   - 计算 $\\partial \\Phi / \\partial \\tilde{\\rho} = -2 \\lambda_{\\mathrm{smooth}} \\Delta \\tilde{\\rho} + \\lambda_{\\mathrm{binary}} (1 - 2 \\tilde{\\rho}) + \\lambda_{\\mathrm{target}} T$。\n   - 计算 $s = \\partial \\tilde{\\rho} / \\partial \\hat{\\rho}$ 和 $g^{\\mathrm{hat}} = (\\partial \\Phi / \\partial \\tilde{\\rho}) \\cdot s$。\n   - 计算 $f = g^{\\mathrm{hat}} / (K * \\mathbf{1})$，然后计算 $\\partial \\Phi / \\partial \\rho = K * f$。\n   - 更新 $\\rho \\leftarrow \\mathrm{clip}_{[0,1]}( \\rho - \\alpha \\, \\partial \\Phi / \\partial \\rho )$。\n3. 在计划结束后，使用最后一个 $\\beta$ 和滤波器半径 $r$ 计算最终的 $\\tilde{\\rho}$，然后评估 $I_{\\mathrm{cb}}$ 和 $G$。\n4. 返回数对 $[I_{\\mathrm{cb}}, G]$。\n\n单行输出将四个测试用例的结果聚合为一个包含两个元素列表的列表。该实验从第一性原理出发，并与电磁正则化需求相一致，展示了滤波和平滑投影与连续化策略相结合如何影响设计变量中的高频伪影和二值性，从而提供了一种在锐化材料分布之前抑制棋盘格现象的计算上稳健的策略。", "answer": "```python\nimport numpy as np\n\n# Implement density filter and Heaviside projection with continuation on beta.\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 allowed but not needed.\n\ndef build_kernel(radius: float):\n    \"\"\"\n    Build a radially symmetric distance-weighted kernel K with weights\n    w(dx,dy) = max(0, radius - sqrt(dx^2 + dy^2)),\n    over offsets in the square [-R, R] x [-R, R], where R = ceil(radius).\n    \"\"\"\n    R = int(np.ceil(radius))\n    size = 2 * R + 1\n    K = np.zeros((size, size), dtype=np.float64)\n    for i in range(size):\n        for j in range(size):\n            dx = i - R\n            dy = j - R\n            dist = np.sqrt(dx * dx + dy * dy)\n            w = max(0.0, radius - dist)\n            K[i, j] = w\n    return K\n\ndef convolve2d_same(image: np.ndarray, kernel: np.ndarray):\n    \"\"\"\n    Convolve a 2D image with kernel using zero padding, output same size as image.\n    \"\"\"\n    H, W = image.shape\n    kH, kW = kernel.shape\n    pad_h = kH // 2\n    pad_w = kW // 2\n    # Pad image with zeros\n    padded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode='constant', constant_values=0.0)\n    result = np.zeros_like(image, dtype=np.float64)\n    # Flip kernel for convolution\n    kflip = kernel[::-1, ::-1]\n    for i in range(H):\n        for j in range(W):\n            window = padded[i:i + kH, j:j + kW]\n            result[i, j] = np.sum(window * kflip)\n    return result\n\ndef density_filter(rho: np.ndarray, kernel: np.ndarray):\n    \"\"\"\n    Apply density filter: hat_rho = (K * rho) / (K * 1).\n    \"\"\"\n    ones = np.ones_like(rho, dtype=np.float64)\n    num = convolve2d_same(rho, kernel)\n    den = convolve2d_same(ones, kernel)\n    # Avoid division by zero by adding tiny epsilon\n    eps = 1e-12\n    hat_rho = num / (den + eps)\n    return hat_rho, den\n\ndef heaviside_projection(hat_rho: np.ndarray, beta: float, eta: float):\n    \"\"\"\n    Smooth Heaviside projection with sharpness beta and threshold eta.\n    \"\"\"\n    th_eta = np.tanh(beta * eta)\n    th_one = np.tanh(beta * (1.0 - eta))\n    denom = th_eta + th_one\n    proj = (th_eta + np.tanh(beta * (hat_rho - eta))) / denom\n    return proj\n\ndef dproj_dhat(hat_rho: np.ndarray, beta: float, eta: float):\n    \"\"\"\n    Derivative of the smooth Heaviside projection with respect to hat_rho.\n    \"\"\"\n    th_eta = np.tanh(beta * eta)\n    th_one = np.tanh(beta * (1.0 - eta))\n    denom = th_eta + th_one\n    tanh_arg = np.tanh(beta * (hat_rho - eta))\n    deriv = beta * (1.0 - tanh_arg ** 2) / denom\n    return deriv\n\ndef laplacian_5pt(u: np.ndarray):\n    \"\"\"\n    Discrete 5-point Laplacian with Neumann-like edge handling by replication.\n    \"\"\"\n    H, W = u.shape\n    # Pad by replication\n    up = np.pad(u, ((1,1),(1,1)), mode='edge')\n    center = up[1:-1, 1:-1]\n    left = up[1:-1, 0:-2]\n    right = up[1:-1, 2:]\n    upv = up[0:-2, 1:-1]\n    down = up[2:, 1:-1]\n    lap = (left + right + upv + down - 4.0 * center)\n    return lap\n\ndef surrogate_gradient_tilde(tilde_rho: np.ndarray, lamb_smooth: float, lamb_binary: float, lamb_target: float, T: np.ndarray):\n    \"\"\"\n    Compute dPhi/d(tilde_rho) for the surrogate objective.\n    \"\"\"\n    grad = -2.0 * lamb_smooth * laplacian_5pt(tilde_rho) + lamb_binary * (1.0 - 2.0 * tilde_rho) + lamb_target * T\n    return grad\n\ndef checkerboard_index(tilde_rho: np.ndarray):\n    \"\"\"\n    Compute checkerboard index I_cb = |sum tilde_rho * (-1)^(i+j)| / sum |tilde_rho|.\n    \"\"\"\n    H, W = tilde_rho.shape\n    # Build alternating sign pattern\n    ii, jj = np.indices((H, W))\n    sign = ((ii + jj) % 2) * 2 - 1  # values in {-1, +1}\n    num = np.abs(np.sum(tilde_rho * sign))\n    den = np.sum(np.abs(tilde_rho)) + 1e-12\n    return float(num / den)\n\ndef grayness(tilde_rho: np.ndarray):\n    \"\"\"\n    Compute grayness G = mean(4 * x * (1 - x)).\n    \"\"\"\n    g = 4.0 * tilde_rho * (1.0 - tilde_rho)\n    return float(np.mean(g))\n\ndef run_case(N: int, r: float, eta: float, beta_schedule: list, rho_init: np.ndarray, iterations_per_beta: int = 10,\n             lamb_smooth: float = 0.1, lamb_binary: float = 1.0, lamb_target: float = 0.05, alpha: float = 0.2):\n    \"\"\"\n    Run continuation schedule on a test case and return [I_cb, G] on final projected density.\n    \"\"\"\n    # Build target mask T: central 6x6 box has -1, else 0\n    T = np.zeros((N, N), dtype=np.float64)\n    c0 = N // 2 - 3\n    c1 = N // 2 + 3\n    T[c0:c1, c0:c1] = -1.0\n\n    # Build kernel once per case (radius fixed)\n    K = build_kernel(r)\n    rho = rho_init.copy()\n\n    for beta in beta_schedule:\n        for _ in range(iterations_per_beta):\n            hat_rho, den_map = density_filter(rho, K)\n            tilde = heaviside_projection(hat_rho, beta, eta)\n            # Gradient on tilde_rho\n            g_tilde = surrogate_gradient_tilde(tilde, lamb_smooth, lamb_binary, lamb_target, T)\n            # Chain rule through projection\n            s = dproj_dhat(hat_rho, beta, eta)\n            g_hat = g_tilde * s\n            # Divide by local filter normalization\n            f = g_hat / (den_map + 1e-12)\n            # Gradient wrt rho is convolution of f with K\n            g_rho = convolve2d_same(f, K)\n            # Update and clip\n            rho = np.clip(rho - alpha * g_rho, 0.0, 1.0)\n\n    # Final metrics computed on final projected density with last beta\n    hat_rho, _ = density_filter(rho, K)\n    tilde = heaviside_projection(hat_rho, beta_schedule[-1], eta)\n    Icb = checkerboard_index(tilde)\n    G = grayness(tilde)\n    return [Icb, G]\n\ndef solve():\n    # Define test cases from the problem statement.\n    # Test case 1: happy path\n    N1 = 16\n    r1 = 3.0\n    eta1 = 0.5\n    beta_sched1 = [1.0, 2.0, 4.0, 8.0]\n    rng1 = np.random.default_rng(0)\n    rho_init1 = rng1.random((N1, N1))\n\n    # Test case 2: uniform initial design\n    N2 = 16\n    r2 = 3.0\n    eta2 = 0.5\n    beta_sched2 = [1.0, 2.0, 4.0, 8.0]\n    rho_init2 = np.full((N2, N2), 0.5, dtype=np.float64)\n\n    # Test case 3: near-absent filtering with aggressive projection, starting from perfect checkerboard\n    N3 = 16\n    r3 = 1.0\n    eta3 = 0.5\n    beta_sched3 = [16.0, 16.0, 16.0, 16.0]\n    ii3, jj3 = np.indices((N3, N3))\n    rho_init3 = (((ii3 + jj3) % 2) == 0).astype(np.float64)\n\n    # Test case 4: large filter radius with non-monotone continuation, random seed 42\n    N4 = 16\n    r4 = 7.9\n    eta4 = 0.5\n    beta_sched4 = [1.0, 1.0, 2.0, 1.0, 4.0]\n    rng4 = np.random.default_rng(42)\n    rho_init4 = rng4.random((N4, N4))\n\n    results = []\n    results.append(run_case(N1, r1, eta1, beta_sched1, rho_init1))\n    results.append(run_case(N2, r2, eta2, beta_sched2, rho_init2))\n    results.append(run_case(N3, r3, eta3, beta_sched3, rho_init3))\n    results.append(run_case(N4, r4, eta4, beta_sched4, rho_init4))\n\n    # Final print statement in the exact required format: single line, comma-separated list enclosed in brackets.\n    # Each result is a two-element list [I_cb, G].\n    def fmt_pair(pair):\n        # Format floats with adequate precision\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in pair) + \"]\"\n    print(\"[\" + \",\".join(fmt_pair(res) for res in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3356441"}, {"introduction": "这是一个高级的、总结性的练习，它展示了拓扑优化在系统级设计中的真正威力。这个问题将挑战你协同设计一个整流天线（rectenna），其中电磁天线结构与非线性整流电路被同时优化。这需要一个复杂的“复合伴随”（composite adjoint）方法，以便将灵敏度信息同时在电磁求解器和非线性谐波平衡求解器中进行传播，从而展示了一种前沿的应用。[@problem_id:3356353]", "problem": "您将获得一个简化的、但物理上一致的射频整流天线（rectenna）协同设计模型，该模型将一个线性电磁梯形网络耦合到一个基于非线性二极管的整流器。您的任务是实现一个完整的、可运行的程序，在每个测试用例中，执行几次基于梯度的拓扑优化，以优化梯形网络的材料分布，从而最大化直流输出电压 $V_{\\mathrm{dc}}$。此过程使用一种复合伴随法，该方法能够对谐波平衡非线性电路求解和线性电磁网络进行微分。\n\n电磁子问题被建模为一个一维梯形网络，它通过传输线模拟代表了麦克斯韦方程组的有限差分。该网络有 $N$ 个节点，索引为 $i \\in \\{0,\\dots,N-1\\}$；节点 $i=0$ 是输入（端口）节点。每个节点 $i$ 通过一个并联电容器接地，其电容为 $C_i(\\rho_i)$，其中 $\\rho_i \\in [0,1]$ 是一个设计变量（材料密度），材料插值使用标准的固态各向同性材料惩罚模型 (SIMP) 形式\n$$\nC_i(\\rho_i) = C_{\\min} + \\rho_i^p \\left(C_{\\max} - C_{\\min}\\right),\n$$\n其中惩罚指数 $p \\ge 1$。相邻节点 $i$ 和 $i+1$ 由一个串联电感器连接，其电感 $L$ 与设计变量无关。最后一个节点 $i = N-1$ 通过一个实值电阻 $R_{\\mathrm{term}}$ 接地，以模拟吸收（辐射）并避免平凡谐振。在角频率 $\\omega$ 下，通过基尔霍夫电流定律 (KCL) 组装复节点导纳矩阵 $\\mathbf{G}(\\omega,\\boldsymbol{\\rho}) \\in \\mathbb{C}^{N \\times N}$。对于每个串联电感支路，串联导纳为 $Y_L(\\omega) = 1/(j\\omega L)$；对于每个并联电容，并联导纳为 $Y_{Ci}(\\omega) = j\\omega C_i(\\rho_i)$；终端在节点 $N-1$ 处贡献一个电导 $G_{\\mathrm{term}} = 1/R_{\\mathrm{term}}$。通过求解\n$$\n\\mathbf{G}(\\omega,\\boldsymbol{\\rho}) \\mathbf{v} = \\mathbf{e}_0,\n$$\n计算节点 $i=0$ 处的驱动点（端口）导纳，记为 $Y_{\\mathrm{em}}(\\omega,\\boldsymbol{\\rho})$，其中 $\\mathbf{e}_0$ 是在索引 $0$ 处为 $1$、其他位置为 $0$ 的单位向量，从而得到端口电压 $V_0 = \\left(\\mathbf{G}^{-1}\\mathbf{e}_0\\right)_0$。驱动点导纳为\n$$\nY_{\\mathrm{em}}(\\omega,\\boldsymbol{\\rho}) = \\frac{1}{V_0}.\n$$\n\n整流器被建模为一个在端口节点处接地的单非线性二极管，其电流-电压定律为\n$$\ni_{\\mathrm{d}}(t) = I_{\\mathrm{s}} \\left( \\exp\\!\\left(\\frac{v(t)}{V_{\\mathrm{t}}}\\right) - 1 \\right),\n$$\n其中 $I_{\\mathrm{s}}$ 是反向饱和电流，$V_{\\mathrm{t}}$ 是热电压。交流 (AC) 源是一个基波角频率为 $\\omega$ 的戴维南源，其串联阻抗为 $Z_{\\mathrm{s}}$，且仅在基波上具有复相量幅值为 $V_{\\mathrm{s}}$ 的正弦电压。在诺顿形式中，这是一个交流诺顿电流 $I_{\\mathrm{N},1} = V_{\\mathrm{s}}/Z_{\\mathrm{s}}$，与所有谐波 $k \\ge 1$ 上的源导纳 $Y_{\\mathrm{s}} = 1/Z_{\\mathrm{s}}$并联。整流后的直流 (DC) 电流通过一个理想的低通路径被提取到一个连接在端口节点的直流负载电阻 $R_{\\mathrm{L}}$ 中。我们假设电磁网络在 $k=0$ 时不导通，因此 $Y_{\\mathrm{em}}(0,\\boldsymbol{\\rho}) = 0$。\n\n为了包含非线性整流和高次谐波的产生，使用谐波平衡法，并截断至 $k \\in \\{0,1,2\\}$ 次谐波，其中端口电压表示为实值波形\n$$\nv(t) = V_0 + \\operatorname{Re}\\!\\left( V_1 e^{j\\omega t} + V_2 e^{j 2\\omega t} \\right),\n$$\n其中 $V_0 \\in \\mathbb{R}$ 且 $V_1,V_2 \\in \\mathbb{C}$。二极管电流 $i_{\\mathrm{d}}(t)$ 在一个周期内均匀采样，并通过离散时间傅里叶变换转换为傅里叶系数 $\\{I_0, I_1, I_2\\}$。在端口处，对于 $k \\in \\{0,1,2\\}$，谐波平衡 KCL 方程为\n$$\n\\begin{aligned}\n=0:  G_{\\mathrm{L}} V_0 + I_0(V_0,V_1,V_2) = 0, \\quad G_{\\mathrm{L}} = \\frac{1}{R_{\\mathrm{L}}}, \\\\\n=1:  \\left( Y_{\\mathrm{s}} + Y_{\\mathrm{em}}(\\omega,\\boldsymbol{\\rho}) \\right) V_1 + I_1(V_0,V_1,V_2) - I_{\\mathrm{N},1} = 0, \\\\\n=2:  \\left( Y_{\\mathrm{s}} + Y_{\\mathrm{em}}(2\\omega,\\boldsymbol{\\rho}) \\right) V_2 + I_2(V_0,V_1,V_2) = 0.\n\\end{aligned}\n$$\n这些方程定义了一个非线性残差 $\\mathbf{F}(\\mathbf{x},\\boldsymbol{\\rho}) = \\mathbf{0}$，其中 $\\mathbf{x} = [V_0, \\operatorname{Re}V_1, \\operatorname{Im}V_1, \\operatorname{Re}V_2, \\operatorname{Im}V_2]^T \\in \\mathbb{R}^5$。您必须使用带线搜索的牛顿法求解此系统，通过对离散傅里叶变换和二极管非线性进行微分来解析地构建雅可比矩阵 $\\partial \\mathbf{F}/\\partial \\mathbf{x}$。\n\n协同设计的目标是端口处的直流输出电压，\n$$\nJ(\\mathbf{x}) = V_0,\n$$\n您必须通过少数几次梯度上升迭代，在 $\\boldsymbol{\\rho} \\in [0,1]^N$ 的约束下最大化该目标。通过复合伴随法计算全导数 $\\mathrm{d}J/\\mathrm{d}\\boldsymbol{\\rho}$，该方法能够对谐波平衡系统和电磁导纳进行微分。具体来说，令 $\\mathbf{J}_x = \\partial \\mathbf{F}/\\partial \\mathbf{x}$ 和 $\\mathbf{J}_\\rho = \\partial \\mathbf{F}/\\partial \\boldsymbol{\\rho}$。伴随向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^5$ 求解\n$$\n\\mathbf{J}_x^T \\boldsymbol{\\lambda} = \\left( \\frac{\\partial J}{\\partial \\mathbf{x}} \\right)^T,\n$$\n梯度则为\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}\\boldsymbol{\\rho}} = - \\boldsymbol{\\lambda}^T \\mathbf{J}_\\rho.\n$$\n$\\mathbf{F}$ 中对 $\\boldsymbol{\\rho}$ 的唯一依赖性是通过 $Y_{\\mathrm{em}}(k\\omega,\\boldsymbol{\\rho})$（对于 $k \\in \\{1,2\\}$）引入的。利用驱动点导纳对实参数的导数恒等式（通过对 $\\mathbf{G}^{-1}$ 微分得到），\n$$\n\\frac{\\partial Y_{\\mathrm{em}}}{\\partial \\rho_i}(k\\omega) = \\frac{\\mathbf{a}^T \\left( \\frac{\\partial \\mathbf{G}}{\\partial \\rho_i} \\right) \\mathbf{a}}{\\left( \\mathbf{a}_0 \\right)^2}, \\quad \\mathbf{a} = \\mathbf{G}(k\\omega,\\boldsymbol{\\rho})^{-1} \\mathbf{e}_0, \\quad \\mathbf{a}_0 = \\left( \\mathbf{G}^{-1} \\mathbf{e}_0 \\right)_0,\n$$\n并且考虑到 $\\partial \\mathbf{G}/\\partial \\rho_i$ 仅由节点 $i$ 处的并联电容产生，\n$$\n\\frac{\\partial \\mathbf{G}}{\\partial \\rho_i} = j k \\omega \\frac{\\partial C_i}{\\partial \\rho_i} \\mathbf{E}_{ii}, \\quad \\frac{\\partial C_i}{\\partial \\rho_i} = p \\,\\rho_i^{p-1} \\left( C_{\\max} - C_{\\min} \\right),\n$$\n其中 $\\mathbf{E}_{ii}$ 是在位置 $(i,i)$ 处为 $1$、其他位置为 $0$ 的矩阵。\n\n为了高效地组装标量梯度，直接在谐波平衡的复数形式下工作。令谐波 $k=1,2$ 的伴随分量为 $\\lambda_k = \\lambda_{k,\\mathrm{re}} + j \\lambda_{k,\\mathrm{im}}$，从 $\\boldsymbol{\\lambda}$ 的相应行中收集，并令 $V_k$ 为谐波 $k$ 处的复端口电压。对于每个设计分量 $i$，标量积 $-\\boldsymbol{\\lambda}^T \\mathbf{J}_\\rho$ 中由电磁导纳贡献的部分等于\n$$\n-\\sum_{k=1}^2 \\operatorname{Re}\\!\\left\\{ \\overline{\\lambda_k} \\, V_k \\, \\frac{\\partial Y_{\\mathrm{em}}(k\\omega,\\boldsymbol{\\rho})}{\\partial \\rho_i} \\right\\},\n$$\n其中上划线表示复共轭。代入 $\\partial Y_{\\mathrm{em}}/\\partial \\rho_i$ 的表达式，可以得到一个明确的、可高效计算的梯度。\n\n实现要求：\n- 使用带回溯线搜索的牛顿法求解谐波平衡方程。每个周期至少使用 $M$ 个均匀时间样本，相位为 $\\phi_m = 2\\pi m/M$（其中 $m \\in \\{0,\\dots,M-1\\}$），以评估二极管非线性及其离散傅里叶变换。角度必须以弧度为单位。\n- 使用关于实变量 $(V_0, \\operatorname{Re}V_1, \\operatorname{Im}V_1, \\operatorname{Re}V_2, \\operatorname{Im}V_2)$ 的精确雅可比矩阵，该矩阵由线性复导纳映射与傅里叶线性化的二极管贡献组合而成。\n- 使用复合伴随法计算 $\\mathrm{d}J/\\mathrm{d}\\boldsymbol{\\rho}$，并在简单的边界约束 $\\rho_i \\in [0,1]$ 下对 $\\boldsymbol{\\rho}$ 执行投影梯度上升。在步进之前，通过其无穷范数对上升方向进行归一化，并将更新后的 $\\boldsymbol{\\rho}$ 裁剪到可行区间内。\n- 对于每个测试用例，将所有 $\\rho_i$ 初始化为 $0.5$，执行指定次数的设计迭代，并报告最终优化的直流电压 $V_{\\mathrm{dc}} = V_0$。\n\n物理单位：\n- 电感单位为亨利 (H)，电容单位为法拉 (F)，电阻单位为欧姆 (Ω)，频率单位为赫兹 (Hz)，电压单位为伏特 (V)，电流单位为安培 (A)。以伏特 (V) 为单位表示最终的 $V_{\\mathrm{dc}}$，并四舍五入到六位小数。\n\n测试套件：\n每个测试用例指定为 $(N, f, V_{\\mathrm{s}}, Z_{\\mathrm{s}}, R_{\\mathrm{L}}, R_{\\mathrm{term}}, L, C_{\\min}, C_{\\max}, p, M, \\text{iters})$。\n\n为以下三个案例提供结果：\n- 案例 1 (理想情况): $N=6$, $f=2.0\\times 10^9\\,\\mathrm{Hz}$, $V_{\\mathrm{s}}=1.0\\,\\mathrm{V}$, $Z_{\\mathrm{s}}=50\\,\\Omega$, $R_{\\mathrm{L}}=10{,}000\\,\\Omega$, $R_{\\mathrm{term}}=50\\,\\Omega$, $L=1.5\\times 10^{-9}\\,\\mathrm{H}$, $C_{\\min}=0.05\\times 10^{-12}\\,\\mathrm{F}$, $C_{\\max}=2.0\\times 10^{-12}\\,\\mathrm{F}$, $p=3$, $M=64$, $\\text{iters}=12$。\n- 案例 2 (近线性激励): $N=5$, $f=1.5\\times 10^9\\,\\mathrm{Hz}$, $V_{\\mathrm{s}}=0.5\\,\\mathrm{V}$, $Z_{\\mathrm{s}}=50\\,\\Omega$, $R_{\\mathrm{L}}=10{,}000\\,\\Omega$, $R_{\\mathrm{term}}=75\\,\\Omega$, $L=1.0\\times 10^{-9}\\,\\mathrm{H}$, $C_{\\min}=0.05\\times 10^{-12}\\,\\mathrm{F}$, $C_{\\max}=2.0\\times 10^{-12}\\,\\mathrm{F}$, $p=3$, $M=64$, $\\text{iters}=12$。\n- 案例 3 (更高频率，不同源阻抗): $N=8$, $f=3.0\\times 10^9\\,\\mathrm{Hz}$, $V_{\\mathrm{s}}=0.8\\,\\mathrm{V}$, $Z_{\\mathrm{s}}=75\\,\\Omega$, $R_{\\mathrm{L}}=10{,}000\\,\\Omega$, $R_{\\mathrm{term}}=50\\,\\Omega$, $L=1.2\\times 10^{-9}\\,\\mathrm{H}$, $C_{\\min}=0.05\\times 10^{-12}\\,\\mathrm{F}$, $C_{\\max}=2.0\\times 10^{-12}\\,\\mathrm{F}$, $p=3$, $M=64$, $\\text{iters}=12$。\n\n非线性二极管参数在所有案例中都是固定的：$I_{\\mathrm{s}}=1.0\\times 10^{-12}\\,\\mathrm{A}$, $V_{\\mathrm{t}}=0.02585\\,\\mathrm{V}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含最终优化的直流电压，形式为逗号分隔的浮点数列表，四舍五入到六位小数，并用方括号括起来，按测试用例的顺序排列。例如：\"[0.123456,0.234567,0.345678]\"。", "solution": "用户在计算电磁学和非线性电路协同设计领域提供了一个定义明确且有科学依据的问题。该问题要求对一个简化的射频整流天线（rectenna）进行基于梯度的拓扑优化。该系统由一个线性一维电磁梯形网络和一个非线性二极管整流器耦合而成。目标是最大化直流（DC）输出电压。该问题是有效的，因为它自成体系、物理上现实且数学上定义明确。所有必需的参数、方程和算法步骤都已指定。\n\n解决方案通过实现一个投影梯度上升算法来推进。对于每个测试用例，代表材料密度的设计变量 $\\boldsymbol{\\rho}$ 被初始化为 $0.5$。优化过程包含指定次数的迭代，每次迭代包括三个主要步骤：\n\n1.  **正向分析**：问题的核心是一个源自谐波平衡 (HB) 理论的非线性方程组，它将电磁网络的响应与二极管的非线性行为耦合起来。状态向量 $\\mathbf{x} = [V_0, \\operatorname{Re}V_1, \\operatorname{Im}V_1, \\operatorname{Re}V_2, \\operatorname{Im}V_2]^T$ 代表直流电压 ($V_0$) 以及设备端口处前两个谐波的复相量 ($V_1, V_2$)。这个表示为 $\\mathbf{F}(\\mathbf{x}, \\boldsymbol{\\rho})=\\mathbf{0}$ 的 $5 \\times 5$ 非线性系统使用带回溯线搜索的牛顿法求解 $\\mathbf{x}$，以增强鲁棒性。\n    -   在谐波 $k=1,2$ 处需要电磁网络的频率相关驱动点导纳 $Y_{\\mathrm{em}}(k\\omega, \\boldsymbol{\\rho})$。这通过构建 $N \\times N$ 的节点导纳矩阵 $\\mathbf{G}(k\\omega, \\boldsymbol{\\rho})$ 并求解线性系统 $\\mathbf{G}\\mathbf{v}=\\mathbf{e}_0$ 来计算。\n    -   非线性二极管电流在时域中处理。从 $\\mathbf{x}$ 构建端口电压波形 $v(t)$，并使用给定的指数定律计算相应的二极管电流 $i_{\\mathrm{d}}(t)$。使用离散傅里叶变换 (DFT) 找到 HB 残差方程所需的 $i_{\\mathrm{d}}(t)$ 的谐波分量。\n    -   HB 系统的雅可比矩阵 $\\mathbf{J}_x = \\partial\\mathbf{F}/\\partial\\mathbf{x}$ 被解析计算。这涉及到线性网络导纳的导数以及二极管谐波电流相对于电压谐波的导数。后者在频域中是卷积，等效于时域二极管跨导与电压谐波基函数乘积的傅里叶变换。\n\n2.  **伴随灵敏度分析**：目标函数是直流电压 $J(\\mathbf{x}) = V_0$。为了计算其相对于设计变量的梯度 $\\mathrm{d}J/\\mathrm{d}\\boldsymbol{\\rho}$，采用了复合伴随法。这避免了代价高昂的直接计算 $\\mathrm{d}\\mathbf{x}/\\mathrm{d}\\boldsymbol{\\rho}$。首先，通过求解线性系统 $\\mathbf{J}_x^T \\boldsymbol{\\lambda} = (\\partial J/\\partial \\mathbf{x})^T = [1, 0, 0, 0, 0]^T$ 来找到一个实值伴随向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^5$。然后，梯度由链式法则表达式 $\\mathrm{d}J/\\mathrm{d}\\boldsymbol{\\rho} = -\\boldsymbol{\\lambda}^T (\\partial \\mathbf{F}/\\partial \\boldsymbol{\\rho})$ 给出。\n    -   项 $\\partial \\mathbf{F}/\\partial \\boldsymbol{\\rho}$ 表示由于设计变量变化引起的 HB 残差变化。由于 $\\boldsymbol{\\rho}$ 只影响并联电容，该导数仅通过 $Y_{\\mathrm{em}}(k\\omega, \\boldsymbol{\\rho})$ 项非零。\n    -   驱动点导纳的导数 $\\partial Y_{\\mathrm{em}}/\\partial \\rho_i$ 使用线性网络的标准伴随恒等式计算。这需要来自正向电磁求解的电压向量。\n    -   然后，如问题陈述中所指定的，使用（从 $\\boldsymbol{\\lambda}$ 重构的）复值伴随变量 $\\lambda_k$ 和已求解的谐波电压 $V_k$ 来高效地组装标量梯度分量 $\\mathrm{d}J/\\mathrm{d}\\rho_i$。\n\n3.  **梯度上升更新**：计算出梯度 $\\mathrm{d}J/\\mathrm{d}\\boldsymbol{\\rho}$ 后，更新设计变量。梯度通过其无穷范数进行归一化，以创建一个统一的上升方向。然后，更新后的设计变量被投影（裁剪）回可行范围 $[0, 1]$ 内。\n\n在指定次数的迭代之后，对优化后的设计 $\\boldsymbol{\\rho}$ 执行最终的正向分析，以确定最终的直流输出电压，并将其作为结果报告。整个过程被封装在一个遵循指定库约束的 Python 程序中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import solve, norm\nimport sys\n\n# Suppress potential overflow warnings from the exponential in the diode model,\n# which are handled by clipping.\nnp.seterr(over='ignore', invalid='ignore')\n\ndef solve_problem():\n    \"\"\"\n    Main function to run the optimization for all test cases and print results.\n    \"\"\"\n    # Diode parameters (fixed)\n    IS = 1.0e-12  # A\n    VT = 0.02585 # V\n\n    test_cases = [\n        # Case 1: (N, f, Vs, Zs, RL, Rterm, L, Cmin, Cmax, p, M, iters)\n        (6, 2.0e9, 1.0, 50.0, 10000.0, 50.0, 1.5e-9, 0.05e-12, 2.0e-12, 3.0, 64, 12),\n        # Case 2\n        (5, 1.5e9, 0.5, 50.0, 10000.0, 75.0, 1.0e-9, 0.05e-12, 2.0e-12, 3.0, 64, 12),\n        # Case 3\n        (8, 3.0e9, 0.8, 75.0, 10000.0, 50.0, 1.2e-9, 0.05e-12, 2.0e-12, 3.0, 64, 12),\n    ]\n\n    results = []\n    for params in test_cases:\n        optimizer = RectennaOptimizer(params, IS, VT)\n        final_vdc = optimizer.optimize()\n        results.append(f\"{final_vdc:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nclass RectennaOptimizer:\n    \"\"\"\n    Implements the co-design optimization of a rectenna.\n    \"\"\"\n    def __init__(self, params, Is, Vt):\n        \"\"\"Initializes the optimizer with problem parameters.\"\"\"\n        (self.N, self.f, self.Vs, self.Zs, self.RL, self.Rterm, self.L,\n         self.Cmin, self.Cmax, self.p, self.M, self.iters) = params\n        self.Is = Is\n        self.Vt = Vt\n\n        self.omega = 2 * np.pi * self.f\n        self.Ys = 1.0 / self.Zs\n        self.IN1 = self.Vs / self.Zs\n        self.GL = 1.0 / self.RL\n\n    def _C(self, rho):\n        \"\"\"Computes capacitance using the SIMP model.\"\"\"\n        return self.Cmin + rho**self.p * (self.Cmax - self.Cmin)\n\n    def _dC_drho(self, rho):\n        \"\"\"Computes the derivative of capacitance w.r.t. rho.\"\"\"\n        # Handle rho=0 case for p>1, though p>=1 here.\n        rho_safe = np.maximum(rho, 1e-12)\n        return self.p * rho_safe**(self.p - 1) * (self.Cmax - self.Cmin)\n\n    def _build_G(self, freq, rho):\n        \"\"\"Assembles the N x N complex nodal admittance matrix G.\"\"\"\n        w = 2 * np.pi * freq\n        if abs(w)  1e-9:\n             return np.diag(np.full(self.N, 1e-12)) # Represents Yem(0,rho)=0\n\n        yc = 1j * w * self._C(rho)\n        diag_terms = np.copy(yc)\n        \n        if self.N == 1:\n            diag_terms[0] += 1.0 / self.Rterm\n            G = np.diag(diag_terms)\n        else:\n            yl = 1.0 / (1j * w * self.L)\n            diag_terms[0] += yl\n            diag_terms[-1] += yl + (1.0 / self.Rterm)\n            diag_terms[1:-1] += 2 * yl\n            G = np.diag(diag_terms)\n            off_diag = np.full(self.N - 1, -yl)\n            G += np.diag(off_diag, k=1)\n            G += np.diag(off_diag, k=-1)\n        return G\n\n    def _solve_em(self, freq, rho):\n        \"\"\"Computes driving-point admittance and EM voltage vector 'a'.\"\"\"\n        G = self._build_G(freq, rho)\n        e0 = np.zeros(self.N, dtype=complex)\n        e0[0] = 1.0\n        try:\n            # Add small regularization to handle potential resonances\n            G_reg = G + np.eye(self.N) * 1e-12\n            a = solve(G_reg, e0)\n        except np.linalg.LinAlgError:\n            return np.inf, None\n        if abs(a[0])  1e-12: return np.inf, None\n        Yem = 1.0 / a[0]\n        return Yem, a\n\n    def _hb_system(self, x, rho, Yem1, Yem2):\n        \"\"\"Computes the HB residual F and Jacobian Jx.\"\"\"\n        V0, V1r, V1i, V2r, V2i = x\n        V1 = V1r + 1j * V1i\n        V2 = V2r + 1j * V2i\n\n        phi = 2 * np.pi * np.arange(self.M) / self.M\n        vt = V0 + np.real(V1 * np.exp(1j * phi) + V2 * np.exp(2j * phi))\n        \n        vt_clipped = np.clip(vt, -np.inf, 20 * self.Vt)\n        exp_term = np.exp(vt_clipped / self.Vt)\n        it = self.Is * (exp_term - 1)\n        gt = (self.Is / self.Vt) * exp_term\n\n        I_fft = np.fft.fft(it) / self.M\n        I0 = I_fft[0].real\n        I1 = 2 * I_fft[1] if self.M > 1 else I_fft[0]\n        I2 = 2 * I_fft[2] if self.M > 2 else 0.0\n\n        F = np.zeros(5)\n        F[0] = self.GL * V0 + I0\n        Res1 = (self.Ys + Yem1) * V1 + I1 - self.IN1\n        F[1], F[2] = Res1.real, Res1.imag\n        Res2 = (self.Ys + Yem2) * V2 + I2\n        F[3], F[4] = Res2.real, Res2.imag\n        \n        J = np.zeros((5, 5))\n        J[0, 0] = self.GL\n        Y1_eff = self.Ys + Yem1\n        J[1:3, 1:3] = [[Y1_eff.real, -Y1_eff.imag], [Y1_eff.imag, Y1_eff.real]]\n        Y2_eff = self.Ys + Yem2\n        J[3:5, 3:5] = [[Y2_eff.real, -Y2_eff.imag], [Y2_eff.imag, Y2_eff.real]]\n\n        s_basis = [\n            np.ones(self.M), np.cos(phi), -np.sin(phi),\n            np.cos(2*phi), -np.sin(2*phi)\n        ]\n\n        for j in range(5):\n            d_it = gt * s_basis[j]\n            dI_fft = np.fft.fft(d_it) / self.M\n            J[0, j] += dI_fft[0].real\n            if self.M > 1:\n                dI1 = 2 * dI_fft[1]\n                J[1, j] += dI1.real\n                J[2, j] += dI1.imag\n            if self.M > 2:\n                dI2 = 2 * dI_fft[2]\n                J[3, j] += dI2.real\n                J[4, j] += dI2.imag\n        \n        return F, J\n\n    def solve_hb(self, rho, x_init=None):\n        \"\"\"Solves the HB nonlinear system using Newton's method.\"\"\"\n        x = np.zeros(5) if x_init is None else np.copy(x_init)\n        \n        Yem1, _ = self._solve_em(self.f, rho)\n        Yem2, _ = self._solve_em(2 * self.f, rho)\n        if np.isinf(Yem1) or np.isinf(Yem2):\n            return None, False\n\n        for _ in range(25):\n            F, J = self._hb_system(x, rho, Yem1, Yem2)\n            if norm(F)  1e-10:\n                return x, True\n            try:\n                delta_x = solve(J, -F)\n            except np.linalg.LinAlgError:\n                return x, False\n\n            alpha = 1.0\n            norm_F = norm(F)\n            for _ in range(10):\n                x_new = x + alpha * delta_x\n                F_new, _ = self._hb_system(x_new, rho, Yem1, Yem2)\n                if norm(F_new)  norm_F:\n                    break\n                alpha /= 2.0\n            else:\n                return x, norm(F)  1e-8\n\n            x = x_new\n            if norm(alpha * delta_x)  1e-10:\n                return x, True\n\n        return x, norm(F)  1e-8\n\n    def _calculate_gradient(self, x, rho, Yem1, a1, Yem2, a2):\n        \"\"\"Computes the gradient dJ/d(rho) using the adjoint method.\"\"\"\n        V0, V1r, V1i, V2r, V2i = x\n        V1 = V1r + 1j * V1i\n        V2 = V2r + 1j * V2i\n        \n        _, Jx = self._hb_system(x, rho, Yem1, Yem2)\n        rhs_adj = np.array([1.0, 0, 0, 0, 0])\n        try:\n            lmbda = solve(Jx.T, rhs_adj)\n        except np.linalg.LinAlgError:\n            return np.zeros_like(rho)\n\n        lmbda_cplx = [lmbda[1] + 1j * lmbda[2], lmbda[3] + 1j * lmbda[4]]\n        dC_drho_vals = self._dC_drho(rho)\n        grad = np.zeros(self.N)\n\n        for i in range(self.N):\n            dC_dr_i = dC_drho_vals[i]\n            if abs(dC_dr_i)  1e-20: continue\n\n            w1 = 2 * np.pi * self.f\n            dG_drho_i_1 = 1j * w1 * dC_dr_i\n            dYem_drho_i_1 = (a1[i]**2 / a1[0]**2) * dG_drho_i_1\n            grad_term1 = np.real(np.conj(lmbda_cplx[0]) * V1 * dYem_drho_i_1)\n            \n            w2 = 2 * np.pi * 2 * self.f\n            dG_drho_i_2 = 1j * w2 * dC_dr_i\n            dYem_drho_i_2 = (a2[i]**2 / a2[0]**2) * dG_drho_i_2\n            grad_term2 = np.real(np.conj(lmbda_cplx[1]) * V2 * dYem_drho_i_2)\n            \n            grad[i] = -(grad_term1 + grad_term2)\n\n        return grad\n\n    def optimize(self):\n        \"\"\"Runs the gradient ascent optimization loop.\"\"\"\n        rho = np.full(self.N, 0.5)\n        x_sol = None\n        step_size = 0.1\n        direction = np.zeros(self.N)\n\n        for _ in range(self.iters):\n            Yem1, a1 = self._solve_em(self.f, rho)\n            Yem2, a2 = self._solve_em(2 * self.f, rho)\n\n            if np.isinf(Yem1) or np.isinf(Yem2) or a1 is None or a2 is None:\n                rho = np.clip(rho - step_size * direction, 0.0, 1.0)\n                continue\n                \n            x_sol, success = self.solve_hb(rho, x_init=x_sol)\n            if not success:\n                break\n\n            grad = self._calculate_gradient(x_sol, rho, Yem1, a1, Yem2, a2)\n            \n            grad_norm_inf = norm(grad, ord=np.inf)\n            if grad_norm_inf > 1e-12:\n                direction = grad / grad_norm_inf\n            else:\n                break\n\n            rho = rho + step_size * direction\n            rho = np.clip(rho, 0.0, 1.0)\n\n        final_x, success = self.solve_hb(rho, x_init=x_sol)\n        return final_x[0] if success and final_x is not None else (x_sol[0] if x_sol is not None else 0.0)\n\nif __name__ == '__main__':\n    solve_problem()\n```", "id": "3356353"}]}