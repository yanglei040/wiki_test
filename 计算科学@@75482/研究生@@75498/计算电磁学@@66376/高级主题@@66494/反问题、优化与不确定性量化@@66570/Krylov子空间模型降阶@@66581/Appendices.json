{"hands_on_practices": [{"introduction": "任何模型降阶方法的首要问题是评估降阶模型（ROM）的准确性。本实践介绍了一个核心概念：残差，它量化了降阶解在多大程度上满足原始高维方程。通过在多个频率点计算并加权聚合残差的范数，我们可以构建一个有效的宽带误差指标，作为评估模型在整个频带上性能的实用工具。", "problem": "考虑一个由有限元法离散化的麦克斯韦方程组的频域公式，其产生一个广义线性时不变系统，包含矩阵 $E \\in \\mathbb{R}^{n \\times n}$ 和 $A \\in \\mathbb{R}^{n \\times n}$、一个输入矩阵 $B \\in \\mathbb{R}^{n \\times m}$ 和一个输出矩阵 $C \\in \\mathbb{R}^{p \\times n}$。对于一个复频移 $s \\in \\mathbb{C}$，全阶状态 $X(s) \\in \\mathbb{C}^{n \\times m}$ 满足线性系统 $$(sE - A) X(s) = B,$$ 且相关的传递函数为 $$H(s) = C X(s) = C (sE - A)^{-1} B.$$ 在使用克雷洛夫子空间的基于投影的模型降阶中，一个列-正交投影矩阵 $V \\in \\mathbb{R}^{n \\times r}$ 定义了降阶算子 $$E_r = V^\\top E V, \\quad A_r = V^\\top A V, \\quad B_r = V^\\top B, \\quad C_r = C V.$$ 状态的降阶近似则为 $$\\widetilde{X}(s) = V (s E_r - A_r)^{-1} B_r,$$ 相应的降阶传递函数为 $$H_r(s) = C_r (s E_r - A_r)^{-1} B_r.$$\n\n在一个频率区间上的宽带精度可以通过聚合多个频移点 $\\{ s_i \\}_{i=1}^q$ 上的信息来评估，其中使用非负求积权重 $\\{ w_i \\}_{i=1}^q$ 来近似频带上的积分，这本着虚轴上哈代空间 $\\mathcal{H}_2$ 范数的精神。您的任务是设计一个误差指标，该指标组合在这些频移点上由降阶近似产生的残差，其聚合过程由求积权重控制，从而使其成为频带上类 $\\mathcal{H}_2$ 范数的一个物理上有意义且计算上易于处理的替代品。在某个频移点上的残差应根据原始全阶算子和降阶近似状态来定义。\n\n基于第一性原理，推导这样一个指标，并编写一个程序来为以下测试套件计算它。每个测试用例提供了 $E$、$A$、$B$、$V$、一个虚轴频移列表 $s_i = \\jmath \\omega_i$（其中 $\\omega_i \\in \\mathbb{R}_{\\ge 0}$）和求积权重 $w_i \\in \\mathbb{R}_{\\ge 0}$。跨频移点组合的残差范数必须以一种对于多个右端项（B 的多列）都一致的方式计算，并且跨频移点的聚合必须包含给定的权重。\n\n您必须生成单行输出，其中包含所有测试用例的结果，形式为一个包含在方括号中的逗号分隔列表。将每个结果表示为浮点数。输出中不需要物理单位。\n\n使用以下测试套件：\n\n- 测试用例 1 (正常情况，多输入):\n  - $n=4$, $m=2$, $r=2$.\n  - $$E = \\mathrm{diag}(2.0,\\,1.5,\\,1.0,\\,0.8).$$\n  - $$A = \\begin{bmatrix}\n  6.0  -1.0  0.0  0.0 \\\\\n  -1.0  5.0  -1.0  0.0 \\\\\n  0.0  -1.0  4.5  -0.8 \\\\\n  0.0  0.0  -0.8  3.5\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  1.0  0.5 \\\\\n  0.2  -0.3 \\\\\n  0.0  0.1 \\\\\n  -0.1  0.2\n  \\end{bmatrix}.$$\n  - $$V = \\begin{bmatrix}\n  1.0  0.0 \\\\\n  0.0  1.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0\n  \\end{bmatrix}.$$\n  - 虚轴上的频移点: $\\omega_1 = 1.0\\times 10^8$, $\\omega_2 = 2.0\\times 10^8$, $\\omega_3 = 3.0\\times 10^8$.\n  - 频带 $[1.0\\times 10^8,\\,3.0\\times 10^8]$ 上的辛普森法则权重: $w_1 = \\dfrac{2.0\\times 10^8}{6}$, $w_2 = \\dfrac{4\\cdot 2.0\\times 10^8}{6}$, $w_3 = \\dfrac{2.0\\times 10^8}{6}$.\n\n- 测试用例 2 (单位质量矩阵，零权重边界):\n  - $n=4$, $m=1$, $r=1$.\n  - $$E = I_4.$$\n  - $$A = \\begin{bmatrix}\n  4.0  -1.0  0.0  0.0 \\\\\n  -1.0  4.0  -1.0  0.0 \\\\\n  0.0  -1.0  3.5  -1.0 \\\\\n  0.0  0.0  -1.0  3.0\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  1.0 \\\\\n  0.0 \\\\\n  0.5 \\\\\n  -0.2\n  \\end{bmatrix}.$$\n  - $$V = \\frac{1}{2} \\begin{bmatrix}\n  1.0 \\\\\n  1.0 \\\\\n  1.0 \\\\\n  1.0\n  \\end{bmatrix}.$$\n  - 频移点: $\\omega_1 = 5.0\\times 10^7$, $\\omega_2 = 1.5\\times 10^8$.\n  - 权重: $w_1 = 1.0$, $w_2 = 0.0$.\n\n- 测试用例 3 (近共振频带，单输入):\n  - $n=3$, $m=1$, $r=1$.\n  - $$E = \\mathrm{diag}(1.0,\\,0.8,\\,0.6).$$\n  - $$A = \\begin{bmatrix}\n  2.0  -0.9  0.0 \\\\\n  -0.9  2.2  -0.8 \\\\\n  0.0  -0.8  1.8\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  0.3 \\\\\n  0.1 \\\\\n  0.2\n  \\end{bmatrix}.$$\n  - $$V = \\begin{bmatrix}\n  1.0 \\\\\n  0.0 \\\\\n  0.0\n  \\end{bmatrix}.$$\n  - 频移点: $\\omega_1 = 1.0\\times 10^7$, $\\omega_2 = 7.0\\times 10^7$, $\\omega_3 = 1.3\\times 10^8$, $\\omega_4 = 1.9\\times 10^8$.\n  - 对于均匀间距 $h = 6.0\\times 10^7$ 的梯形法则权重: $w_1 = \\dfrac{h}{2}$, $w_2 = h$, $w_3 = h$, $w_4 = \\dfrac{h}{2}$.\n\n- 测试用例 4 (一致性检查，全阶子空间应产生零残差):\n  - 使用与测试用例 3 相同的 $E$, $A$, $B$, 频移点和权重。\n  - 选择 $V = I_3$.\n\n您的程序必须生成单行输出，其中包含的结果为一个逗号分隔的列表，并用方括号括起来 (例如, $[result1,result2,result3,result4]$)。每个 $resultk$ 必须是根据您推导的指标，使用提供的权重聚合给定频移点上的残差计算出的浮点数。", "solution": "该问题要求推导并实现一个用于线性时不变系统（源于离散化的麦克斯韦方程组）的基于投影的模型降阶的宽带误差指标。该指标必须聚合多个频率点上的残差，并由求积系数加权，以作为频带上类 $\\mathcal{H}_2$ 范数的替代。\n\n### 步骤 1：问题验证\n\n第一步是对问题陈述进行关键性验证。\n\n#### 步骤 1.1：提取的已知条件\n- **全阶系统**：\n  - 方程： $(sE - A) X(s) = B$\n  - 矩阵： $E \\in \\mathbb{R}^{n \\times n}$，$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$C \\in \\mathbb{R}^{p \\times n}$\n  - 状态： $X(s) \\in \\mathbb{C}^{n \\times m}$\n  - 传递函数： $H(s) = C (sE - A)^{-1} B$\n- **降阶系统**：\n  - 投影矩阵： $V \\in \\mathbb{R}^{n \\times r}$，列-正交 ($V^\\top V = I_r$)\n  - 降阶算子： $E_r = V^\\top E V$，$A_r = V^\\top A V$，$B_r = V^\\top B$，$C_r = C V$\n  - 近似状态： $\\widetilde{X}(s) = V (s E_r - A_r)^{-1} B_r$\n  - 近似传递函数： $H_r(s) = C_r (s E_r - A_r)^{-1} B_r$\n- **误差指标要求**：\n  - 采样点：一组复频移 $\\{ s_i \\}_{i=1}^q$，其中 $s_i = \\jmath \\omega_i$ 且 $\\omega_i \\in \\mathbb{R}_{\\ge 0}$。\n  - 求积权重：一组非负权重 $\\{ w_i \\}_{i=1}^q$。\n  - 指标必须组合根据全阶算子（$E, A$）和降阶近似状态（$\\widetilde{X}(s)$）定义的残差。\n  - 聚合过程必须使用权重 $w_i$。\n  - 用于残差的范数必须对于多个右端项（即 B 的多列）是一致的。\n- **测试套件**：提供了四个测试用例，每个都指定了 $E$、$A$、$B$、$V$、频移点 $\\{\\omega_i\\}$ 和权重 $\\{w_i\\}$ 的数值。指定了计算出的指标值的输出格式。请注意，矩阵 $C$ 在前言中被引入，但在测试用例中未提供，且对于基于状态的残差计算并非必需。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n- **科学上合理**：该问题在基于投影的线性时不变系统模型降阶的成熟理论中有很好的基础，这是计算电磁学和控制理论中的标准技术。所有方程和定义都是标准的。\n- **良态的**：问题是良态的。它要求基于明确的约束推导一个特定的量（误差指标），并为在测试套件中进行计算提供了所有必要的数据。矩阵 $C$ 的缺失不是一个缺陷，因为任务明确要求根据状态近似 $\\widetilde{X}(s)$ 定义残差，而不是输出近似 $H_r(s)$。\n- **客观的**：问题使用精确和客观的数学语言陈述。\n- **缺陷分析**：\n  1.  **科学上不合理**：无。该框架是标准的。\n  2.  **无法形式化/不相关**：无。问题高度具体且可形式化。\n  3.  **设置不完整/矛盾**：无。计算基于状态的残差所需的所有数据都已提供。\n  4.  **不现实/不可行**：无。提供的矩阵很小，条件良好，适合计算测试。\n  5.  **病态/结构不良**：无。推导过程会导向一个唯一且有意义的数值结果。\n  6.  **伪深奥/琐碎**：无。任务需要正确的推导和实现，这并非易事。测试用例 4，其中投影空间是全空间，提供了一个非平凡的一致性检查。\n  7.  **超出科学可验证性范围**：无。结果在数值上是可验证的。\n\n#### 步骤 1.3：结论与行动\n问题是**有效的**。将推导并实现一个解决方案。\n\n### 步骤 2：误差指标的推导\n\n目标是构建一个标量误差指标 $\\mathcal{E}$，用于量化降阶模型在频带上的精度。按照要求，从第一性原理进行推导。\n\n1.  **状态残差**：误差的基本度量是残差，它量化了近似解满足原始控制方程的程度。全阶系统由 $(sE - A) X(s) = B$ 定义。我们将来自降阶模型的近似状态 $\\widetilde{X}(s)$ 代入此方程。产生的不平衡量就是状态残差矩阵 $R(s) \\in \\mathbb{C}^{n \\times m}$：\n    $$ R(s) = (sE - A) \\widetilde{X}(s) - B $$\n    较小的残差意味着对系统内部动态更好的近似。\n\n2.  **残差的范数**：残差 $R(s)$ 是一个矩阵。为了量化其在单一频率 $s_i$ 上的大小，我们需要一个矩阵范数。对于具有多个输入（即 $m > 1$）的问题，需要一个能公平对待残差矩阵所有列的范数。弗罗贝尼乌斯范数是自然的选择，因为它是欧几里得向量范数的矩阵扩展，定义为其所有元素幅度平方和的平方根。弗罗贝尼乌斯范数的平方由下式给出：\n    $$ \\| R(s_i) \\|_F^2 = \\sum_{j=1}^n \\sum_{k=1}^m |(R(s_i))_{jk}|^2 = \\mathrm{Tr}(R(s_i)^H R(s_i)) $$\n    其中 $H$ 表示共轭转置。此范数计算方便，并能恰当地聚合所有状态和所有输入的误差。\n\n3.  **跨频率聚合**：问题要求一个宽带误差指标，以近似一个通过在频率轴上积分定义的类 $\\mathcal{H}_2$ 范数。我们得到了求积点 $s_i = \\jmath \\omega_i$ 和相应的权重 $w_i$。这个设置直接对应于一个用于近似积分的数值求积格式。频带上残差的弗罗贝尼乌斯范数平方的积分可以通过加权和来近似：\n    $$ \\int_{\\text{band}} \\|R(\\jmath \\omega)\\|_F^2 \\, d\\omega \\approx \\sum_{i=1}^q w_i \\|R(s_i)\\|_F^2 $$\n    这个加权和，我们称之为 $\\mathcal{E}^2$，代表了由给定求积法则近似的频带上的总平方误差。\n\n4.  **最终误差指标**：最终误差指标 $\\mathcal{E}$ 应与残差范数本身具有相同的单位，而不是其平方。因此，我们将指标定义为聚合和的平方根：\n    $$ \\mathcal{E} = \\sqrt{\\sum_{i=1}^q w_i \\|R(s_i)\\|_F^2} $$\n    这是我们为积分残差范数推导出的物理上有意义且计算上易于处理的替代品。\n\n### 步骤 3：计算算法\n\n基于推导出的指标，其计算算法如下：\n\n1.  给定系统矩阵 $E, A, B$，投影矩阵 $V$，频率采样点 $\\{\\omega_i\\}_{i=1}^q$，以及求积权重 $\\{w_i\\}_{i=1}^q$。\n2.  预计算与频率无关的降阶矩阵：\n    $$ E_r = V^\\top E V \\quad \\in \\mathbb{R}^{r \\times r} $$\n    $$ A_r = V^\\top A V \\quad \\in \\mathbb{R}^{r \\times r} $$\n    $$ B_r = V^\\top B \\quad \\in \\mathbb{R}^{r \\times m} $$\n3.  初始化一个变量用于表示总加权平方误差，$\\mathcal{E}^2_{\\text{total}} = 0$。\n4.  对于每个采样索引 $i = 1, \\dots, q$：\n    a.  设置复频率 $s_i = \\jmath \\omega_i$。\n    b.  构建此频率下的降阶系统矩阵：$M_{r,i} = s_i E_r - A_r$。\n    c.  求解 $r \\times r$ 复线性系统，以获得降阶状态系数矩阵 $Y(s_i) \\in \\mathbb{C}^{r \\times m}$：\n        $$ M_{r,i} Y(s_i) = B_r \\implies Y(s_i) = M_{r,i}^{-1} B_r $$\n    d.  将解投影回完整的 $n$ 维空间，以获得近似状态 $\\widetilde{X}(s_i) \\in \\mathbb{C}^{n \\times m}$：\n        $$ \\widetilde{X}(s_i) = V Y(s_i) $$\n    e.  计算全阶残差矩阵 $R(s_i) \\in \\mathbb{C}^{n \\times m}$：\n        $$ R(s_i) = (s_i E - A) \\widetilde{X}(s_i) - B $$\n    f.  计算残差的弗罗贝尼乌斯范数平方，$\\epsilon_i^2 = \\|R(s_i)\\|_F^2$。\n    g.  将加权贡献加到总和中：$\\mathcal{E}^2_{\\text{total}} = \\mathcal{E}^2_{\\text{total}} + w_i \\epsilon_i^2$。\n5.  最终的误差指标是 $\\mathcal{E} = \\sqrt{\\mathcal{E}^2_{\\text{total}}}$。\n\n此算法将被实现以解决所提供的测试用例。对于测试用例 4，其中 $V = I_n$，我们有 $r=n$。降阶系统与全阶系统相同，导致 $\\widetilde{X}(s) = X(s)$。因此，对于所有 $s$，残差 $R(s)$ 必须为零，最终指标 $\\mathcal{E}$ 也必须为零。这可作为实现正确性的关键检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a wideband error indicator for Krylov subspace model reduction.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, multiple inputs)\n        {\n            \"E\": np.diag([2.0, 1.5, 1.0, 0.8]),\n            \"A\": np.array([\n                [6.0, -1.0, 0.0, 0.0],\n                [-1.0, 5.0, -1.0, 0.0],\n                [0.0, -1.0, 4.5, -0.8],\n                [0.0, 0.0, -0.8, 3.5]\n            ]),\n            \"B\": np.array([\n                [1.0, 0.5],\n                [0.2, -0.3],\n                [0.0, 0.1],\n                [-0.1, 0.2]\n            ]),\n            \"V\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ]),\n            \"omegas\": np.array([1.0e8, 2.0e8, 3.0e8]),\n            \"weights\": np.array([2.0e8 / 6, 4 * 2.0e8 / 6, 2.0e8 / 6])\n        },\n        # Test case 2 (identity mass, zero weight edge)\n        {\n            \"E\": np.identity(4),\n            \"A\": np.array([\n                [4.0, -1.0, 0.0, 0.0],\n                [-1.0, 4.0, -1.0, 0.0],\n                [0.0, -1.0, 3.5, -1.0],\n                [0.0, 0.0, -1.0, 3.0]\n            ]),\n            \"B\": np.array([\n                [1.0],\n                [0.0],\n                [0.5],\n                [-0.2]\n            ]),\n            \"V\": 0.5 * np.array([\n                [1.0],\n                [1.0],\n                [1.0],\n                [1.0]\n            ]),\n            \"omegas\": np.array([5.0e7, 1.5e8]),\n            \"weights\": np.array([1.0, 0.0])\n        },\n        # Test case 3 (near-resonant band, single input)\n        {\n            \"E\": np.diag([1.0, 0.8, 0.6]),\n            \"A\": np.array([\n                [2.0, -0.9, 0.0],\n                [-0.9, 2.2, -0.8],\n                [0.0, -0.8, 1.8]\n            ]),\n            \"B\": np.array([\n                [0.3],\n                [0.1],\n                [0.2]\n            ]),\n            \"V\": np.array([\n                [1.0],\n                [0.0],\n                [0.0]\n            ]),\n            \"omegas\": np.array([1.0e7, 7.0e7, 1.3e8, 1.9e8]),\n            \"weights\": np.array([6e7/2, 6e7, 6e7, 6e7/2])\n        },\n        # Test case 4 (consistency check, full-order subspace should give zero residual)\n        {\n            \"E\": np.diag([1.0, 0.8, 0.6]),\n            \"A\": np.array([\n                [2.0, -0.9, 0.0],\n                [-0.9, 2.2, -0.8],\n                [0.0, -0.8, 1.8]\n            ]),\n            \"B\": np.array([\n                [0.3],\n                [0.1],\n                [0.2]\n            ]),\n            \"V\": np.identity(3),\n            \"omegas\": np.array([1.0e7, 7.0e7, 1.3e8, 1.9e8]),\n            \"weights\": np.array([6e7/2, 6e7, 6e7, 6e7/2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E, A, B, V = case[\"E\"], case[\"A\"], case[\"B\"], case[\"V\"]\n        omegas, weights = case[\"omegas\"], case[\"weights\"]\n        \n        # 1. Compute reduced system matrices\n        E_r = V.T @ E @ V\n        A_r = V.T @ A @ V\n        B_r = V.T @ B\n\n        total_weighted_sq_err = 0.0\n\n        for omega, w in zip(omegas, weights):\n            if w == 0.0:\n                continue\n\n            # 2. Set complex frequency\n            s = 1j * omega\n\n            # 3. Solve the reduced system\n            # M_r * Y = B_r\n            M_r = s * E_r - A_r\n            try:\n                Y = np.linalg.solve(M_r, B_r)\n            except np.linalg.LinAlgError:\n                # Handle potential singularity, though not expected in these test cases\n                # If singular, the residual norm would be infinite.\n                Y = np.linalg.pinv(M_r) @ B_r\n            \n            # 4. Reconstruct approximate full-order state\n            X_tilde = V @ Y\n\n            # 5. Compute the residual\n            R = (s * E - A) @ X_tilde - B\n\n            # 6. Compute squared Frobenius norm of the residual\n            sq_frob_norm = np.linalg.norm(R, 'fro')**2\n\n            # 7. Add weighted contribution to total error\n            total_weighted_sq_err += w * sq_frob_norm\n\n        # 8. Compute the final indicator\n        indicator = np.sqrt(total_weighted_sq_err)\n        results.append(indicator)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3322065"}, {"introduction": "在学会如何量化误差之后，一个自然而然的进阶是利用误差信息来智能地构建更优的降阶模型。本实践将引导您实现一种自适应基函数增量算法，该算法通过迭代地在误差最大的频率点增加新的基函数，从而精确地“修复”模型的不足之处。这种目标驱动的策略能够以最小的计算代价构建出满足特定精度要求的紧凑模型，并将其应用于一个经典的二阶波导物理问题。", "problem": "实现一个完整的程序，该程序构建、降阶和评估一个用于矩形波导一维代理模型的二阶线性时不变描述系统模型，并计算一个近似模型降阶误差的Hardy空间 $H_\\infty$ 范数的宽带误差指标。模型降阶必须使用一种由采样频域误差指标的峰值驱动的自适应Krylov子空间富集策略。\n\n从计算电磁学中标准的以下基本根据和建模假设出发。在一个理想电导体矩形波导中，对于无损耗、均匀且单位磁导率和介电常数（因此在归一化单位中波速 $c = 1$）的介质，麦克斯韦方程组允许变量分离，从而得到与横截面相关的截止常数和沿轴向坐标的传播方程。在一个沿轴向坐标 $z \\in (0,L)$ 的单模代理模型中，其截止波数为 $k_c = \\pi/a$（对应于较宽边长为 $a$ 的矩形波导中的主模），横向场分量可以通过频域中的标量二阶系统来建模\n$$\n(K - \\omega^2 M)\\, q(\\omega) = b, \\quad y(\\omega) = c^\\top q(\\omega),\n$$\n其中 $M$ 是一个对称正定的“质量”算子，$K$ 是一个对称正定的“刚度”算子，它包括轴向二阶导数和截止项 $k_c^2$，$b$ 是一个位于 $z=0$ 附近的输入激励，$c$ 用于提取 $z=L$ 附近的响应。频率变量是角频率 $\\omega$，单位为弧度/秒。相应的单输入单输出传递函数是\n$$\nG(\\mathrm{j}\\omega) = c^\\top (K - \\omega^2 M)^{-1} b.\n$$\n\n通过 $N_z$ 个内部网格点离散化区间 $(0,L)$，间距为 $h = L/(N_z+1)$，并在 $z=0$ 和 $z=L$ 处施加Dirichlet边界条件（理想电导体终端）。使用一维拉普拉斯算子的标准二阶中心有限差分近似来构成刚度矩阵\n$$\nK = T + k_c^2 I, \\quad T = \\frac{1}{h^2}\\,\\mathrm{tridiag}(-1,2,-1)\\in\\mathbb{R}^{N_z\\times N_z}, \\quad k_c = \\frac{\\pi}{a},\n$$\n并将质量矩阵设置为\n$$\nM = I \\in \\mathbb{R}^{N_z\\times N_z}.\n$$\n在最左侧的内部节点使用单位点输入，并在最右侧的内部节点提取响应，即\n$$\nb = e_1 \\in \\mathbb{R}^{N_z}, \\quad c = e_{N_z} \\in \\mathbb{R}^{N_z}.\n$$\n\n定义宽带误差指标，通过对频率轴进行均匀采样来近似 $\\lVert G - G_r\\rVert_{H_\\infty}$，\n$$\n\\mathcal{E} = \\max_{\\omega\\in\\Omega_{\\mathrm{s}}} \\left| G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)\\right|,\n$$\n其中 $\\Omega_{\\mathrm{s}} = \\{\\omega_1,\\dots,\\omega_{N_\\Omega}\\}$ 是用户指定的一组角频率（单位为弧度/秒），$G(\\mathrm{j}\\omega)$ 是全阶传递函数，$G_r(\\mathrm{j}\\omega)$ 是降阶传递函数。\n\n通过投影到二阶形式的有理Krylov子空间来构建降阶模型，该子空间由在自适应选择的频率处的频移解构建而成。具体来说，对于每个选定的角频率 $\\omega_k$，构建向量\n$$\nv_k = (K - \\omega_k^2 M)^{-1} b,\n$$\n在标准欧几里得内积下，将其与当前基 $\\{v_1,\\dots,v_{k-1}\\}$ 进行正交归一化，并扩充基矩阵 $V = [v_1,\\dots,v_r] \\in \\mathbb{C}^{N_z\\times r}$。然后将降阶算子以及降阶输入和输出定义为\n$$\nK_r = V^H K V,\\quad M_r = V^H M V,\\quad b_r = V^H b,\\quad c_r^\\top = c^\\top V,\n$$\n以及将降阶传递函数定义为\n$$\nG_r(\\mathrm{j}\\omega) = c_r^\\top (K_r - \\omega^2 M_r)^{-1} b_r.\n$$\n使用以下自适应富集策略：\n- 在采样频带的中点频率处计算一个向量来初始化基。\n- 在每次迭代中，在整个采样集 $\\Omega_{\\mathrm{s}}$ 上评估采样指标 $\\left| G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)\\right|$，找到使该指标最大化的峰值频率 $\\omega_\\star$，并用新向量 $(K - \\omega_\\star^2 M)^{-1} b$（经正交归一化后）来富集基。\n- 当当前最大采样指标低于给定容差或达到允许的最大基大小时停止。\n\n为避免在共振时出现精确奇点，在采样和富集求解过程中通过将 $K - \\omega^2 M$ 替换为 $K - (1 - \\mathrm{j}\\eta)\\omega^2 M$ 来增加一个无穷小的正损耗，其中 $\\eta$ 是一个固定的微小正常数。\n\n角度单位必须是弧度/秒。在归一化单位系统中，所有其他量均为无量纲。每个测试所需的最终答案是纯数字（浮点数和整数），输出中不带单位标签。\n\n您的程序必须实现以上内容并运行以下测试套件。对于每个测试用例，构建模型，运行自适应富集，并报告一个三元组，包括：\n- 最终最大采样指标 $\\mathcal{E}$（浮点数），\n- 最后一轮迭代指标达到最大值时的角频率 $\\omega_\\star$（浮点数），\n- 最终降阶基的大小 $r$（整数）。\n\n每个测试用例由元组 $(N_z, L, a, \\omega_{\\min}, \\omega_{\\max}, N_\\Omega, \\text{tol}, r_{\\max})$ 指定：\n1. $(60, 1.0, 1.0, 2.0, 3.5, 40, 1\\times 10^{-5}, 6)$\n2. $(60, 1.0, 1.0, 4.0, 6.0, 60, 1\\times 10^{-4}, 12)$\n3. $(60, 1.0, 1.0, 6.5, 8.5, 60, 1\\times 10^{-4}, 14)$\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应测试用例的列表，顺序为 $[\\mathcal{E}, \\omega_\\star, r]$。例如，三个测试的语法有效输出将类似于\n\"[ [0.0123,4.567,5],[0.001,5.432,7],[0.1,7.0,8] ]\"\n但使用的是您实现中实际计算出的值。角频率必须以弧度/秒为单位。不应打印任何额外文本。", "solution": "所提出的问题是有效的，因为它具有科学依据、是良定的、客观且完整的，除了一个可以假设的次要标准数值参数外。它要求实现一个二阶系统的自适应模型降阶方案，这是计算科学与工程中的一个成熟流程。\n\n目标是为波导代理模型的一维有限差分离散构建一个降阶模型 (ROM)。该降阶过程将使用一种自适应有理Krylov子空间方法执行，其中通过选择与全阶模型 (FOM) 和降阶模型 (ROM) 之间频域误差峰值对应的新展开频率，来对子空间进行迭代富集。\n\n### 1. 全阶模型 (FOM) 构建\n\n问题始于频域中的一个二阶线性时不变系统，代表单模波导中的横向场分量：\n$$\n(K - \\omega^2 M)\\, q(\\omega) = b, \\quad y(\\omega) = c^\\top q(\\omega)\n$$\n系统的频率响应由传递函数 $G(\\mathrm{j}\\omega) = c^\\top (K - \\omega^2 M)^{-1} b$ 来表征。\n\n空间域是区间 $z \\in (0, L)$，使用 $N_z$ 个内部网格点进行离散化。网格间距为 $h = L / (N_z + 1)$。该模型在 $z=0$ 和 $z=L$ 处采用Dirichlet边界条件。\n\n系统矩阵定义如下：\n-   **质量矩阵** $M$ 是单位矩阵，$M = I \\in \\mathbb{R}^{N_z \\times N_z}$。\n-   **刚度矩阵** $K \\in \\mathbb{R}^{N_z \\times N_z}$ 由 $K = T + k_c^2 I$ 给出，其中 $k_c = \\pi/a$ 是截止波数。矩阵 $T$ 是负二阶导数算子的标准二阶中心有限差分近似，并乘以比例因子 $1/h^2$：\n    $$\n    T = \\frac{1}{h^2}\n    \\begin{pmatrix}\n    2  -1   \\\\\n    -1  2  -1  \\\\\n     \\ddots  \\ddots  \\ddots \\\\\n      -1  2  -1 \\\\\n       -1  2\n    \\end{pmatrix}\n    $$\n    $K$ 和 $M$ 都是对称正定的。\n-   **输入向量** $b$ 代表在第一个内部节点的点源激励，$b = e_1 = [1, 0, \\dots, 0]^\\top \\in \\mathbb{R}^{N_z}$。\n-   **输出向量** $c$ 代表在最后一个内部节点的探针，$c = e_{N_z} = [0, \\dots, 0, 1]^\\top \\in \\mathbb{R}^{N_z}$。\n\n### 2. 通过投影进行模型降阶\n\n模型降阶旨在找到FOM的低维近似。我们使用一种基于投影的方法，其中状态向量 $q(\\omega) \\in \\mathbb{C}^{N_z}$ 在一个低维子空间内被近似。该子空间由一个正交归一矩阵 $V \\in \\mathbb{C}^{N_z \\times r}$ 的列向量张成，其中 $r \\ll N_z$ 是降阶阶数。近似为 $q(\\omega) \\approx V z(\\omega)$，其中 $z(\\omega) \\in \\mathbb{C}^r$ 是降阶状态向量。\n\n将此ansatz代入FOM方程并应用Galerkin投影（强加残差与由 $V$ 张成的子空间正交），得到ROM：\n$$\nV^H (K - \\omega^2 M) V z(\\omega) = V^H b\n$$\n$$\n(V^H K V - \\omega^2 V^H M V) z(\\omega) = V^H b\n$$\n这定义了降阶系统矩阵：\n-   降阶刚度矩阵：$K_r = V^H K V \\in \\mathbb{C}^{r \\times r}$\n-   降阶质量矩阵：$M_r = V^H M V \\in \\mathbb{C}^{r \\times r}$\n-   降阶输入向量：$b_r = V^H b \\in \\mathbb{C}^r$\n\n降阶输出为 $y_r(\\omega) = c^\\top (V z(\\omega)) = (c^\\top V) z(\\omega) = c_r^\\top z(\\omega)$，其中降阶输出向量定义为 $c_r = V^H c \\in \\mathbb{C}^r$。注意在构建 $c_r$ 时使用了共轭转置，这在 $V$ 是复数时为保持一致性是必需的。\n\n那么，降阶传递函数为：\n$$\nG_r(\\mathrm{j}\\omega) = c_r^\\top (K_r - \\omega^2 M_r)^{-1} b_r\n$$\n\n### 3. 自适应有理Krylov方法\n\nROM的质量关键取决于投影基 $V$ 的选择。问题指定了一种自适应有理Krylov方法。基向量由FOM在特定的、自适应选择的角频率（展开点）$\\omega_k$ 处的解生成：\n$$\nv'_k = (K - \\omega_k^2 M)^{-1} b\n$$\n然后将这些向量进行正交归一化，形成基 $V = [v_1, v_2, \\dots, v_r]$。我们使用数值稳定的修正Gram-Schmidt (MGS) 算法进行正交归一化。对于一个新向量 $v'$，MGS通过依次移除其在每个现有基向量上的投影来进行。\n\n自适应过程如下：\n1.  **初始化**：感兴趣的频带是 $[\\omega_{\\min}, \\omega_{\\max}]$，在 $N_\\Omega$ 个点上采样形成集合 $\\Omega_s$。初始基由单个向量组成（$r=1$），该向量在中点频率 $\\omega_1 = (\\omega_{\\min} + \\omega_{\\max}) / 2$ 处生成。\n2.  **迭代**：算法通过迭代来富集基。在每次迭代中，对于大小为 $r$ 的基：\n    a. 构建ROM $\\{K_r, M_r, b_r, c_r\\}$。\n    b. 通过在采样频率上找到全阶和降阶传递函数之间绝对差的最大值来计算误差指标 $\\mathcal{E}$：\n       $$\n       \\mathcal{E} = \\max_{\\omega \\in \\Omega_s} |G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)|\n       $$\n    c. 确定出现此最大误差的频率 $\\omega_\\star \\in \\Omega_s$。\n    d. **停止标准检查**：如果 $\\mathcal{E}$ 低于指定的容差 `tol` 或基大小 $r$ 已达到允许的最大大小 `r_max`，则算法终止。\n    e. **富集**：如果未满足停止标准，则用一个新向量扩充基。这个新向量是使用 $\\omega_\\star$ 作为下一个展开点生成的。计算原始向量 $(K - \\omega_\\star^2 M)^{-1} b$ 并使用MGS与现有基向量进行正交归一化以产生 $v_{r+1}$。更新基，$V \\leftarrow [V, v_{r+1}]$，其大小变为 $r+1$。\n\n### 4. 数值实现\n\n为避免当展开频率 $\\omega_k$ 与无阻尼系统的自然频率（即共振）重合时出现奇点，引入了一个小的人工阻尼项。系统矩阵被修改为 $K - (1 - \\mathrm{j}\\eta)\\omega^2 M$，其中 $\\eta$ 是一个微小的正常数。对于此问题，选择标准值 $\\eta = 10^{-8}$。此修改使系统矩阵变为复数，因此基 $V$ 和降阶矩阵也将是复数。\n\n求解算法如下：\n1.  对于每个测试用例，构建FOM矩阵 $K, M, b, c$。$K$ 被构建为稀疏矩阵。\n2.  为所有 $\\omega \\in \\Omega_s$ 预计算FOM传递函数 $G(\\mathrm{j}\\omega)$。这是通过对每个频率求解复线性系统 $(K - (1 - \\mathrm{j}\\eta)\\omega^2 M)q(\\omega)=b$ 来完成的。\n3.  用在频带中点频率处生成的一个向量初始化基 $V$。设置 $r=1$。\n4.  进入自适应循环：\n    - 构建当前的 $r \\times r$ ROM。\n    - 在 $\\Omega_s$ 上评估ROM传递函数 $G_r(\\mathrm{j}\\omega)$。这涉及为每个频率求解一个小的 $r \\times r$ 线性系统。\n    - 计算误差指标 $\\mathcal{E}$ 及其峰值频率 $\\omega_\\star$。\n    - 如果 $\\mathcal{E}  \\text{tol}$ 或 $r \\ge r_{\\max}$，则退出循环并报告 $(\\mathcal{E}, \\omega_\\star, r)$。\n    - 否则，使用 $\\omega_\\star$ 作为展开点并通过MGS过程将基富集到大小 $r+1$。$r$ 递增并继续循环。\n\n此过程为每个测试用例产生最终误差、该误差的峰值频率以及最终降阶模型的大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\n\ndef build_fom(Nz, L, a):\n    \"\"\"Builds the full-order model matrices and vectors.\"\"\"\n    h = L / (Nz + 1)\n    kc = np.pi / a\n\n    # Stiffness matrix T for the 1D Laplacian\n    diagonals = [-np.ones(Nz-1), 2*np.ones(Nz), -np.ones(Nz-1)]\n    T = sparse.diags(diagonals, [-1, 0, 1], shape=(Nz, Nz), format='csc') / (h**2)\n    \n    # K and M matrices\n    I_Nz = sparse.identity(Nz, format='csc')\n    K = T + (kc**2) * I_Nz\n    M = I_Nz.copy()\n\n    # Input and output vectors\n    b = np.zeros(Nz)\n    b[0] = 1.0\n    c = np.zeros(Nz)\n    c[Nz-1] = 1.0\n\n    return K, M, b, c\n\ndef evaluate_transfer_function(sys_mat, b, c, omega_samples, eta, is_fom=True):\n    \"\"\"Evaluates the transfer function G(jw) for a set of frequencies.\"\"\"\n    K, M = sys_mat\n    Nz = K.shape[0]\n    G_values = np.zeros(len(omega_samples), dtype=np.complex128)\n\n    if is_fom:\n        # For FOM, K and M are sparse\n        for i, w in enumerate(omega_samples):\n            if w == 0:\n                # Handle DC case, though not expected in test cases\n                A = K\n            else:\n                A = K - (1 - 1j * eta) * (w**2) * M\n            # Use sparse solver for the large system\n            q = sla.spsolve(A, b)\n            G_values[i] = c.T @ q\n    else:\n        # For ROM, Kr and Mr are small dense matrices\n        Kr, Mr = sys_mat\n        br, cr_T = b, c\n        for i, w in enumerate(omega_samples):\n            if w == 0:\n                Ar = Kr\n            else:\n                Ar = Kr - (w**2) * Mr\n            # Use dense solver for the small system\n            zr = np.linalg.solve(Ar, br)\n            G_values[i] = cr_T @ zr\n            \n    return G_values\n\ndef run_adaptive_reduction(Nz, L, a, w_min, w_max, Nw, tol, r_max):\n    \"\"\"Performs the adaptive Krylov subspace model reduction.\"\"\"\n    eta = 1e-8\n    \n    # 1. Setup FOM and frequency samples\n    K, M, b, c = build_fom(Nz, L, a)\n    omega_samples = np.linspace(w_min, w_max, Nw)\n\n    # 2. Pre-compute FOM response\n    G_full = evaluate_transfer_function((K, M), b, c, omega_samples, eta, is_fom=True)\n\n    # 3. Initialization (r=1)\n    w_expand = (w_min + w_max) / 2.0\n    A_expand = K - (1 - 1j * eta) * (w_expand**2) * M\n    v_raw = sla.spsolve(A_expand, b)\n    v_new = v_raw / np.linalg.norm(v_raw)\n    V = v_new.reshape(-1, 1)\n    r = 1\n\n    # 4. Adaptive loop\n    while True:\n        # Project FOM to create ROM\n        br = V.T.conj() @ b\n        cr_T = c.T @ V # c is real, so c.T is fine\n        Kr = V.T.conj() @ K @ V\n        Mr = V.T.conj() @ M @ V\n\n        # Evaluate ROM response\n        G_reduced = evaluate_transfer_function((Kr, Mr), br, cr_T, omega_samples, eta, is_fom=False)\n\n        # Compute error\n        error_indicator = np.abs(G_full - G_reduced)\n        max_error = np.max(error_indicator)\n        w_star_idx = np.argmax(error_indicator)\n        w_star = omega_samples[w_star_idx]\n\n        # Check stopping criteria\n        if max_error  tol or r >= r_max:\n            return max_error, w_star, r\n\n        # Enrich basis at peak error frequency\n        w_expand = w_star\n        A_expand = K - (1 - 1j * eta) * (w_expand**2) * M\n        v_raw = sla.spsolve(A_expand, b)\n        \n        # Modified Gram-Schmidt orthonormalization\n        w = v_raw.copy()\n        for i in range(r):\n            v_i = V[:, i]\n            proj_coeff = np.vdot(v_i, w)\n            w -= proj_coeff * v_i\n        \n        norm_w = np.linalg.norm(w)\n        if norm_w  1e-10: \n            # Vector is linearly dependent, stop enrichment\n            return max_error, w_star, r\n            \n        v_new = w / norm_w\n        V = np.hstack((V, v_new.reshape(-1, 1)))\n        r += 1\n\n\ndef solve():\n    test_cases = [\n        # (Nz, L, a, w_min, w_max, Nw, tol, r_max)\n        (60, 1.0, 1.0, 2.0, 3.5, 40, 1e-5, 6),\n        (60, 1.0, 1.0, 4.0, 6.0, 60, 1e-4, 12),\n        (60, 1.0, 1.0, 6.5, 8.5, 60, 1e-4, 14),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, w_star, r = run_adaptive_reduction(*case)\n        results.append([E, w_star, r])\n\n    # Format output string manually to match the required format\n    # \"[ [E1,w1,r1],[E2,w2,r2],... ]\"\n    results_str_list = []\n    for res in results:\n        # res[0] is E (float), res[1] is w_star (float), res[2] is r (int)\n        results_str_list.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3322115"}, {"introduction": "在实际的电磁仿真中，扫频分析是一项常见但计算成本高昂的任务，在每个频率点从头构建克雷洛夫子空间是极其低效的。本实践旨在解决这一挑战，您将实现一种子空间重用策略，即利用前一个频率点计算得到的 Ritz 向量作为当前频率点子空间构建的“热启动”种子。通过这种方式，可以显著减少求解大型线性系统的次数，从而在保证精度的前提下大幅提升扫频分析的效率。", "problem": "给定一个线性时不变描述符系统，该系统源于计算电磁学中麦克斯韦方程组的半离散化。该系统由一阶形式的描述符状态空间方程表示：\n$$\nE \\, \\dot{x}(t) = A \\, x(t) + B \\, u(t), \\quad y(t) = C \\, x(t),\n$$\n其中 $E \\in \\mathbb{R}^{n \\times n}$ 是非奇异对称正定矩阵，$A \\in \\mathbb{R}^{n \\times n}$ 是实数稳定矩阵（即 $(A,E)$ 的广义特征值位于开放左半平面），$B \\in \\mathbb{R}^{n \\times 1}$，$C \\in \\mathbb{R}^{1 \\times n}$。频域传递函数为：\n$$\nG(s) = C \\,(s E - A)^{-1} B, \\quad s \\in \\mathbb{C}.\n$$\n本任务专注于通过在纯虚位移 $s = j \\omega$ 处进行克雷洛夫子空间投影来进行模型降阶，并研究在频率扫描中循环使用克雷洛夫子空间。对于每个频率样本 $s_k = j \\omega_k$，你将通过有理克雷洛夫子空间构建一个阶数为 $m$ 的降阶模型，并比较两种工作流程：\n\n- 在每个 $s_k$ 处不使用先验信息进行冷启动有理 Arnoldi 算法。\n- 在 $s_k$ 处，使用从 $s_{k-1}$ 处的降阶矩阵束计算出的 Ritz 向量作为种子进行循环工作流程。\n\n对于单位移 $s$ 的单输入系统，有理克雷洛夫子空间可由线性算子生成：\n$$\n\\mathcal{M}_s(v) = (A - s E)^{-1} (E v),\n$$\n以及输入种子向量：\n$$\nr_0(s) = (A - s E)^{-1} B.\n$$\n通过对从 $r_0(s)$ 开始并重复应用 $\\mathcal{M}_s(\\cdot)$ 得到的序列执行修正的 Gram–Schmidt 算法，构建一个标准正交基 $V_m(s) \\in \\mathbb{C}^{n \\times m}$（相对于标准欧几里得内积）。降阶模型通过 Galerkin 投影得到：\n$$\nA_r(s) = V_m(s)^{\\ast} A V_m(s), \\quad E_r(s) = V_m(s)^{\\ast} E V_m(s), \\quad B_r(s) = V_m(s)^{\\ast} B, \\quad C_r(s) = C V_m(s),\n$$\n以及\n$$\nG_r(s) = C_r(s) \\, \\big(s E_r(s) - A_r(s)\\big)^{-1} B_r(s).\n$$\n\n对于循环利用，假设在 $s_{k-1}$ 处你已经计算了 $V_m(s_{k-1})$ 和降阶矩阵束 $(A_r(s_{k-1}), E_r(s_{k-1}))$。计算其广义特征对 $(\\lambda_i, z_i)$：\n$$\nA_r(s_{k-1}) \\, z_i = \\lambda_i \\, E_r(s_{k-1}) \\, z_i,\n$$\n并通过 $v_i = V_m(s_{k-1}) \\, z_i$ 在全空间中形成 Ritz 向量。按特征值模长 $|\\lambda_i|$ 的升序排序，并选择前 $q$ 个对应的向量 $\\{v_i\\}_{i=1}^q$。在 $s_k$ 处，通过对这 $q$ 个向量进行正交化来为 Arnoldi 过程提供种子，如果基的大小仍小于 $m$，则包含 $r_0(s_k)$，然后继续应用 $\\mathcal{M}_{s_k}$ 直到获得 $m$ 个向量。这个工作流程旨在减少在整个扫描过程中 $(A - s E)^{-1}$ 的应用次数。\n\n对于此问题：\n1. 对每个测试用例，给定整数大小 $n$ 和整数随机种子 $\\sigma$，使用以下确定性构造方法来构建系统矩阵：\n   - 使用种子 $\\sigma$ 生成一个实数矩阵 $S \\in \\mathbb{R}^{n \\times n}$，其元素为独立的标准正态分布。\n   - 设置\n     $$\n     E = \\operatorname{diag}(e_1,\\dots,e_n), \\quad e_i \\sim \\text{Uniform}(0.5, 2.0) \\text{ 使用相同的种子 } \\sigma,\n     $$\n     $$\n     A = -\\big(S^{\\mathsf{T}} S + \\gamma I\\big),\n     $$\n     其中 $\\gamma = 0.1$，$I$ 是单位矩阵。\n   - 使用相同的种子 $\\sigma$ 生成 $B \\in \\mathbb{R}^{n \\times 1}$ 和 $C \\in \\mathbb{R}^{1 \\times n}$，其元素为独立的标准正态分布。\n   - 这会生成一个稳定的描述符系统，其中 $E$ 是对称正定的，$A$ 是负定的。\n2. 对于每个频率 $s_k = j \\omega_k$，通过计算将 $(A - s_k E)$ 应用于右侧向量的线性求解次数来衡量子空间构造的计算成本。不要计算矩阵分解；只计算对右侧向量的求解次数。在每个 $s_k$ 处的冷启动中，初始向量 $r_0(s_k)$ 计为一次求解，每次应用 $\\mathcal{M}_{s_k}$ 计为一次求解。\n3. 对于每个频率 $s_k = j \\omega_k$，使用在 $s_k$ 处生成的子空间计算降阶传递函数 $G_r(s_k)$。将每个工作流程的精度度量定义为\n   $$ \n   \\max_k \\big| G(j \\omega_k) - G_r(j \\omega_k) \\big|,\n   $$\n   即在扫描样本上的最大绝对标量误差。\n4. 在频率扫描 $\\{s_k\\}_{k=1}^K$ 中实现这两种工作流程并报告：\n   - 由于循环利用而节省的总求解次数的分数，\n     $$\n     \\frac{N_{\\text{cold}} - N_{\\text{recycle}}}{N_{\\text{cold}}},\n     $$\n     其中 $N_{\\text{cold}}$ 和 $N_{\\text{recycle}}$ 是所有频率上的总次数。\n   - 冷启动和循环利用的最大绝对误差，如第3项中所定义。\n\n你的程序必须精确地实现上述内容，并为以下测试套件生成结果。在每个测试中，每个频率使用 $m$ 个 Arnoldi 基向量，在步骤 $k>1$ 时选择 $q$ 个 Ritz 向量作为种子，并构造扫描频率为 $[\\omega_{\\min}, \\omega_{\\max}]$ 上（包含端点）的 $K$ 个对数间隔样本：\n- 测试 1 (happy path): $n = 50$, $m = 15$, $q = 6$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n- 测试 2 (boundary: no recycling): $n = 50$, $m = 15$, $q = 0$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n- 测试 3 (boundary: aggressive recycling): $n = 50$, $m = 15$, $q = 14$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n\n输出规范：\n- 对于每个测试，按以下顺序输出一个包含三个浮点数的列表\n  $$\n  \\left[ \\frac{N_{\\text{cold}} - N_{\\text{recycle}}}{N_{\\text{cold}}},\\ \\max_k |G(j\\omega_k) - G_r^{\\text{cold}}(j\\omega_k)|,\\ \\max_k |G(j\\omega_k) - G_r^{\\text{recycle}}(j\\omega_k)| \\right].\n  $$\n- 你的程序应生成单行输出，其中包含三个测试结果，格式为一个逗号分隔的列表，用方括号括起来，每个测试结果本身也是一个用方括号括起来的逗号分隔列表。例如：\"[[a1,a2,a3],[b1,b2,b3],[c1,c2,c3]]\"。\n- 输出不需要物理单位。根据构造 $s = j \\omega$，角度单位为弧度。\n\n你的程序必须是完全自包含的，仅使用指定的库，并且不得读取输入。它必须完全按照上述描述实现两种工作流程、求解次数的计数、子空间的构造与投影以及误差度量。", "solution": "我们从模拟半离散麦克斯韦方程组的描述符形式开始，其中空间离散化（例如，通过在旋度协调空间上使用有限元）产生一个矩阵束 $(A,E)$，其中 $E$ 是对称正定的，$A$ 是负半定的外加阻尼。在频域中，对于 $s \\in \\mathbb{C}$，单输入单输出情况下的传递函数为\n$$\nG(s) = C \\, (s E - A)^{-1} B.\n$$\n对于纯虚频率 $s = j \\omega$，这是一个良定义的复标量，因为当 $A$ 是负定的且 $E$ 是正定的时，$sE - A$ 对所有实数 $\\omega$ 都是可逆的。\n\n通过投影进行模型降阶，首先构建一个子空间 $\\mathcal{V} \\subset \\mathbb{C}^n$ 和一个基矩阵 $V \\in \\mathbb{C}^{n \\times m}$（其列张成 $\\mathcal{V}$），然后形成降阶矩阵：\n$$\nA_r = V^{\\ast} A V, \\quad E_r = V^{\\ast} E V, \\quad B_r = V^{\\ast} B, \\quad C_r = C V,\n$$\n从而\n$$\nG_r(s) = C_r \\, (s E_r - A_r)^{-1} B_r.\n$$\n$G_r(s)$ 的质量取决于子空间在多大程度上捕捉了 $(s E - A)^{-1}$ 对 $B$ 以及通过重复应用涉及 $E$ 的算子所遇到的向量的作用。\n\n针对位移 $s$ 和单输入的有理克雷洛夫子空间由算子生成：\n$$\n\\mathcal{M}_s(v) = (A - s E)^{-1} (E v),\n$$\n这与匹配围绕 $s$ 的频域矩是一致的。一个标准的有理 Arnoldi 迭代过程如下：\n- 计算 $r_0(s) = (A - s E)^{-1} B$。\n- 将 $r_0(s)$ 正交化以获得 $v_1$。\n- 对于 $j = 1, \\dots, m-1$，计算 $w = \\mathcal{M}_s(v_j) = (A - s E)^{-1} (E v_j)$，通过带有可选重正交化的修正 Gram–Schmidt 算法将 $w$ 相对于现有基向量 $\\{v_i\\}_{i=1}^j$ 进行正交化，归一化得到 $v_{j+1}$，并将其附加到基中。\n\n这就构建了 $V_m(s) = [v_1, \\dots, v_m]$。每个频率 $s$ 的主要计算成本是重复求解涉及 $A - s E$ 的线性系统。如果我们使用直接求解器，我们可以对每个频率分解一次 $A - s E$，每次将 $(A - s E)^{-1}$ 应用于右侧向量都算作一次求解。在冷启动中，每个频率的求解次数是 $r_0(s)$ 的 1 次加上 $\\mathcal{M}_s$ 应用的 $m-1$ 次，总计 $m$ 次。\n\n为了在频率扫描 $\\{s_k\\}_{k=1}^K$ 中循环利用信息，我们通过冷启动计算 $V_m(s_1)$，然后在 $k \\ge 2$ 时从 $s_{k-1}$ 处的降阶矩阵束中导出 Ritz 向量。降阶广义特征问题\n$$\nA_r(s_{k-1}) z_i = \\lambda_i \\, E_r(s_{k-1}) z_i\n$$\n产生了投影到子空间中的原始矩阵束的近似特征方向。提升后的向量 $v_i = V_m(s_{k-1}) z_i$ 是全空间中的 Ritz 向量。按 $|\\lambda_i|$ 递增排序反映了优先考虑慢（近共振）动力学，这在低频和中频时通常占主导地位；在耗散电磁学中，这种选择是一种有原则的启发式方法。用 $q$ 个前导向量 $\\{v_i\\}$ 作为 $s_k$ 处 Arnoldi 过程的种子，减少了达到维度 $m$ 所需的额外 $\\mathcal{M}_{s_k}$ 应用次数。具体来说，如果我们从 $q$ 个正交种子向量开始，并且在必要时包含输入条件向量 $r_0(s_k)$，那么我们最多需要 $m - q - 1$ 次后续的 $(A - s_k E)$ 求解来填充基（如果 $q \\le m-1$）。因此，在包含输入向量的情况下，每个频率的总求解次数理想地从 $m$ 减少到大约 $\\max(1, m - q)$，从而在整个扫描过程中实现显著的节省。\n\n为了量化精度，对于每个工作流程在每个采样频率 $s_k$ 处，我们计算一个降阶模型 $G_r^{(k)}(s_k)$ 并报告\n$$\n\\max_k \\left| G(j \\omega_k) - G_r^{(k)}(j \\omega_k) \\right|.\n$$\n这个度量评估了在采样点处的峰值绝对失配。尽管这不是一个在所有频率上统一的单一降阶模型，但它与在频率扫描中为每个 $s_k$ 局部构建和使用降阶解的工作流程是一致的。\n\n每个测试用例的算法步骤：\n1. 确定性地构建 $(A,E,B,C)$：\n   - 生成具有标准正态分布条目的 $S$，生成 $e_i \\sim \\text{Uniform}(0.5, 2.0)$ 来设置 $E = \\mathrm{diag}(e_i)$，设置 $A = -(S^{\\mathsf{T}} S + \\gamma I)$ 其中 $\\gamma = 0.1$，并生成具有标准正态分布条目的 $B$ 和 $C$，都使用相同的随机种子。\n2. 构建一个在 $[\\omega_{\\min}, \\omega_{\\max}]$ 上对数间隔的频率网格 $\\{\\omega_k\\}_{k=1}^K$，并设置 $s_k = j \\omega_k$。\n3. 在每个 $s_k$ 处的冷启动工作流程：\n   - 分解一次 $A - s_k E$。\n   - 通过上述的有理 Arnoldi 构建 $V_m(s_k)$，并计算求解次数。形成降阶矩阵并计算 $G_r(s_k)$。\n   - 累加总求解次数并跟踪在 $s_k$ 处的绝对误差。\n4. 扫描过程中的循环工作流程：\n   - 在 $k=1$ 时，执行冷启动。计算 $(A_r(s_1), E_r(s_1))$ 的降阶广义特征对，按 $|\\lambda_i|$ 递增排序，并计算全空间中对应的 Ritz 向量作为种子。\n   - 对于 $k \\ge 2$，使用上一步中最多 $q$ 个正交化的 Ritz 向量作为 $s_k$ 处 Arnoldi 过程的种子，如果基大小未达到 $m$，则包含 $r_0(s_k)$，并继续 Arnoldi 直到获得 $m$ 个向量。计算求解次数，计算降阶传递函数，并为下一步更新 Ritz 向量。\n5. 报告：\n   - 节省的分数 $(N_{\\text{cold}} - N_{\\text{recycle}})/N_{\\text{cold}}$。\n   - 冷启动和循环利用在整个扫描中的最大绝对误差。\n\n测试套件指定了三种情况：\n- 测试 1: $n = 50$, $m = 15$, $q = 6$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n- 测试 2: $n = 50$, $m = 15$, $q = 0$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n- 测试 3: $n = 50$, $m = 15$, $q = 14$, $K = 8$, $\\omega_{\\min} = 1.0$, $\\omega_{\\max} = 100.0$, $\\sigma = 2025$。\n\n实现细节与理由：\n- 算子应用 $(A - s E)^{-1}(\\cdot)$ 的执行方式是：对每个 $s$ 分解一次 $A - s E$，并针对多个右侧向量进行求解；成本度量仅计算求解次数，以反映克雷洛夫步数和输入条件化操作的次数。\n- 正交化使用带有重正交化的修正 Gram–Schmidt 方法以保持数值稳定性。此处使用标准欧几里得内积是合适的，因为如果 $E$ 是正定的且 $V$ 是满列秩的，Galerkin 投影可以确保 $E_r$ 保持正定。\n- 通过最小 $|\\lambda_i|$ 选择的 Ritz 向量为电磁问题提供了一种实用的启发式方法，因为它们强调了影响宽频率范围的慢衰减或近共振模式。尽管存在更复杂的选择标准（例如，自适应位移或切向插值），但对于指定的扫描，此选择足以展示节省效果和精度趋势。\n\n最终程序对所有测试执行这些步骤，并以所需格式打印单行，其中包含一个由三个列表组成的列表，每个测试一个列表，每个列表包含节省的分数和两个最大误差。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, eig\n\ndef build_system(n: int, seed: int, gamma: float = 0.1):\n    rng = np.random.default_rng(seed)\n    S = rng.standard_normal((n, n))\n    e = rng.uniform(0.5, 2.0, size=n)\n    E = np.diag(e)\n    A = -(S.T @ S + gamma * np.eye(n))\n    B = rng.standard_normal((n, 1))\n    C = rng.standard_normal((1, n))\n    return A, E, B, C\n\nclass ShiftedSolver:\n    def __init__(self, A, E, s):\n        self.s = s\n        self.n = A.shape[0]\n        self.M = (A - s * E).astype(np.complex128)\n        self.lu, self.piv = lu_factor(self.M)\n        self.solve_count = 0\n\n    def solve(self, rhs):\n        self.solve_count += 1\n        rhs_c = rhs.astype(np.complex128, copy=False)\n        return lu_solve((self.lu, self.piv), rhs_c)\n\ndef modified_gram_schmidt(V_list, w, reorth=True, tol=1e-12):\n    # Orthonormalize w against columns in V_list\n    v = w.copy()\n    for _ in (0, 1) if reorth else (0,):\n        for q in V_list:\n            h = np.vdot(q, v)\n            v = v - h * q\n    norm_v = np.linalg.norm(v)\n    if norm_v  tol:\n        return None\n    return v / norm_v\n\ndef rational_krylov(A, E, B, s, m, seed_basis=None):\n    n = A.shape[0]\n    solver = ShiftedSolver(A, E, s)\n    V_list = []\n\n    # Start with seeded basis if provided\n    if seed_basis is not None and seed_basis.size > 0:\n        # Orthonormalize the seed columns\n        for j in range(seed_basis.shape[1]):\n            vec = seed_basis[:, j:j+1]\n            vec = vec.astype(np.complex128)\n            v = modified_gram_schmidt(V_list, vec)\n            if v is not None:\n                V_list.append(v)\n\n    # Include input-conditioned vector if we still need more\n    if len(V_list)  m:\n        r0 = solver.solve(B)\n        v = modified_gram_schmidt(V_list, r0)\n        if v is not None:\n            V_list.append(v)\n\n    # Arnoldi-like expansion\n    while len(V_list)  m:\n        v_last = V_list[-1]\n        w = solver.solve(E @ v_last)\n        v_new = modified_gram_schmidt(V_list, w)\n        if v_new is None:\n            # Breakdown: inject a random vector to continue\n            rng = np.random.default_rng(0).standard_normal((n, 1)).astype(np.complex128)\n            v_new = modified_gram_schmidt(V_list, rnd)\n            if v_new is None:\n                break\n        V_list.append(v_new)\n\n    if len(V_list) == 0:\n        # Fallback: construct at least one vector\n        r0 = solver.solve(B)\n        v = r0 / np.linalg.norm(r0)\n        V_list.append(v)\n\n    V = np.hstack(V_list)  # n x r (r = m)\n    return V, solver.solve_count\n\ndef reduce_matrices(A, E, B, C, V):\n    Ar = V.conj().T @ A @ V\n    Er = V.conj().T @ E @ V\n    Br = V.conj().T @ B\n    Cr = C @ V\n    return Ar, Er, Br, Cr\n\ndef transfer_full(A, E, B, C, s):\n    M = (s * E - A).astype(np.complex128)\n    lu, piv = lu_factor(M)\n    x = lu_solve((lu, piv), B.astype(np.complex128))\n    y = (C @ x).item()\n    return y\n\ndef transfer_reduced(Ar, Er, Br, Cr, s):\n    Mr = (s * Er - Ar).astype(np.complex128)\n    lu, piv = lu_factor(Mr)\n    xr = lu_solve((lu, piv), Br.astype(np.complex128))\n    yr = (Cr @ xr).item()\n    return yr\n\ndef ritz_seed(V_prev, Ar_prev, Er_prev, q):\n    # Compute generalized eigenpairs of (Ar_prev, Er_prev)\n    # Sort by increasing |lambda| and return the Ritz vectors in full space\n    vals, vecs = eig(Ar_prev, Er_prev)\n    # Handle potential numerical issues by filtering finite values\n    idx = np.argsort(np.abs(vals))\n    if q == 0:\n        return None\n    q = min(q, vecs.shape[0])\n    Zq = vecs[:, idx[:q]]\n    seed = V_prev @ Zq\n    # Orthonormalization will be handled by rational_krylov\n    return seed\n\ndef frequency_sweep_metrics(n, m, q, K, wmin, wmax, seed):\n    A, E, B, C = build_system(n, seed)\n    # Frequencies and shifts\n    w = np.logspace(np.log10(wmin), np.log10(wmax), K)\n    s_list = 1j * w\n\n    # Cold-start workflow\n    cold_total_solves = 0\n    cold_errors = []\n    # Recycling workflow\n    rec_total_solves = 0\n    rec_errors = []\n\n    # For recycling seeds\n    V_prev = None\n    Ar_prev = None\n    Er_prev = None\n\n    for idx, s in enumerate(s_list):\n        # Cold-start at this s\n        V_cold, solves_cold = rational_krylov(A, E, B, s, m, seed_basis=None)\n        cold_total_solves += solves_cold\n        Ar_c, Er_c, Br_c, Cr_c = reduce_matrices(A, E, B, C, V_cold)\n        G_full = transfer_full(A, E, B, C, s)\n        G_red_c = transfer_reduced(Ar_c, Er_c, Br_c, Cr_c, s)\n        cold_errors.append(abs(G_full - G_red_c))\n\n        # Recycling\n        if idx == 0 or q == 0 or V_prev is None:\n            seed_basis = None\n        else:\n            seed_basis = ritz_seed(V_prev, Ar_prev, Er_prev, q)\n        V_rec, solves_rec = rational_krylov(A, E, B, s, m, seed_basis=seed_basis)\n        rec_total_solves += solves_rec\n        Ar_r, Er_r, Br_r, Cr_r = reduce_matrices(A, E, B, C, V_rec)\n        G_red_r = transfer_reduced(Ar_r, Er_r, Br_r, Cr_r, s)\n        rec_errors.append(abs(G_full - G_red_r))\n\n        # Update previous for next recycling step\n        V_prev, Ar_prev, Er_prev = V_rec, Ar_r, Er_r\n\n    # Metrics\n    cold_max_err = float(np.max(cold_errors))\n    rec_max_err = float(np.max(rec_errors))\n    if cold_total_solves > 0:\n        savings = (cold_total_solves - rec_total_solves) / cold_total_solves\n    else:\n        savings = 0.0\n    return float(savings), cold_max_err, rec_max_err\n\ndef solve():\n    test_cases = [\n        # (n, m, q, K, wmin, wmax, seed)\n        (50, 15, 6, 8, 1.0, 100.0, 2025),   # Test 1: happy path\n        (50, 15, 0, 8, 1.0, 100.0, 2025),   # Test 2: no recycling\n        (50, 15, 14, 8, 1.0, 100.0, 2025),  # Test 3: aggressive recycling\n    ]\n\n    results = []\n    for n, m, q, K, wmin, wmax, seed in test_cases:\n        savings, err_cold, err_rec = frequency_sweep_metrics(n, m, q, K, wmin, wmax, seed)\n        results.append([savings, err_cold, err_rec])\n\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3322055"}]}