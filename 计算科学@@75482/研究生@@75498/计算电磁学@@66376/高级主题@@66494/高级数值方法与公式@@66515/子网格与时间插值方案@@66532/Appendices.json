{"hands_on_practices": [{"introduction": "子网格界面的一个核心挑战是抑制非物理反射。这个练习将连续介质中的波阻抗概念推广到离散的计算网格中，引入了数值阻抗。通过在界面处应用电场和磁场的切向连续性边界条件，我们可以推导出离散的反射和透射系数，从而将数值反射的强度直接与粗细网格间数值阻抗的失配联系起来 [@problem_id:3351855]。这项实践有助于深入理解数值反射的根本原因，并为评估和设计低反射界面方案提供了理论基础。", "problem": "考虑一个位于 $z=0$ 处的一维子网格界面，该界面分隔了两个时域有限差分 (FDTD) 区域。这两个区域在无损耗的相同介质中实施Yee网格方案，介电常数为 $\\epsilon$，磁导率为 $\\mu$。区域 $z0$ 为粗网格，其空间步长为 $\\Delta_{c}$，时间步长为 $\\Delta t_{c}$；区域 $z>0$ 为细网格，其空间步长为 $\\Delta_{f}$，时间步长为 $\\Delta t_{f}$。跨界面的场交换在细网格一侧使用线性时间插值，以满足在交错的Yee时间层级上的耦合条件。一列角频率为 $\\omega$ 的垂直入射横电 (TE) 平面波从 $z0$ 向 $z>0$ 传播。令 $E_{i}$ 和 $H_{i}$ 表示粗网格区域中入射的切向电场和磁场的相量振幅，$E_{r}$ 和 $H_{r}$ 表示粗网格区域中反射波的振幅，$E_{t}$ 和 $H_{t}$ 表示细网格区域中透射波的振幅。假设时谐依赖关系为 $\\exp(-\\mathrm{i}\\omega t)$，并忽略入射波以外的任何源。\n\n将每个区域中的数值阻抗 $Z(\\omega)$ 定义为满足局部离散色散关系和局部更新方案（包括由界面处的线性时间插值引起的任何修正）的前向传播离散平面波的切向电场与磁场相量振幅之比。将粗网格区域的阻抗表示为 $Z_{c}(\\omega)$，细网格区域的阻抗表示为 $Z_{f}(\\omega)$。在 $z=0$ 处，切向电场和磁场是连续的。\n\n仅使用麦克斯韦方程组所蕴含的边界条件以及前向和后向传播波的数值阻抗定义，推导子网格界面处切向电场的离散反射系数 $R(\\omega)=E_{r}/E_{i}$ 和透射系数 $T(\\omega)=E_{t}/E_{i}$。明确地用 $Z_{c}(\\omega)$ 和 $Z_{f}(\\omega)$ 之间的失配来表示 $R(\\omega)$，并给出 $T(\\omega)$ 的闭合形式表达式。最终答案必须是包含 $R(\\omega)$ 和 $T(\\omega)$ 的单个闭合形式解析表达式；不需要进行数值计算。$R(\\omega)$ 和 $T(\\omega)$ 均为无量纲量。不要四舍五入；请提供精确表达式。", "solution": "该问题要求推导子网格界面处的离散反射系数 $R(\\omega)$ 和透射系数 $T(\\omega)$。推导基于界面 $z=0$ 处切向电场和磁场的连续性原理。\n\n在粗网格区域 ($z0$)，总场是入射波和反射波的叠加。根据数值阻抗的定义，总切向电场和磁场为：\n$$\nE_{total, c} = E_{i} + E_{r}\n$$\n$$\nH_{total, c} = H_{i} + H_{r} = \\frac{E_{i}}{Z_{c}(\\omega)} - \\frac{E_{r}}{Z_{c}(\\omega)}\n$$\n注意，后向传播的反射波的磁场符号为负。\n\n在细网格区域 ($z>0$)，只有前向传播的透射波：\n$$\nE_{total, f} = E_{t}\n$$\n$$\nH_{total, f} = H_{t} = \\frac{E_{t}}{Z_{f}(\\omega)}\n$$\n\n在界面 $z=0$ 处应用切向场的连续性条件：\n1.  电场连续性: $E_{total, c} = E_{total, f} \\implies E_{i} + E_{r} = E_{t}$\n2.  磁场连续性: $H_{total, c} = H_{total, f} \\implies \\frac{E_{i} - E_{r}}{Z_{c}(\\omega)} = \\frac{E_{t}}{Z_{f}(\\omega)}$\n\n我们现在求解这个关于 $E_r$ 和 $E_t$ 的方程组。将第一个方程代入第二个方程以消去 $E_t$：\n$$\n\\frac{E_{i} - E_{r}}{Z_{c}(\\omega)} = \\frac{E_{i} + E_{r}}{Z_{f}(\\omega)}\n$$\n整理后得到：\n$$\nZ_{f}(\\omega) (E_{i} - E_{r}) = Z_{c}(\\omega) (E_{i} + E_{r})\n$$\n$$\nE_{i} (Z_{f}(\\omega) - Z_{c}(\\omega)) = E_{r} (Z_{f}(\\omega) + Z_{c}(\\omega))\n$$\n因此，反射系数 $R(\\omega) = E_{r}/E_{i}$ 为：\n$$\nR(\\omega) = \\frac{Z_{f}(\\omega) - Z_{c}(\\omega)}{Z_{f}(\\omega) + Z_{c}(\\omega)}\n$$\n利用 $E_{t} = E_{i} + E_{r}$，透射系数 $T(\\omega) = E_{t}/E_{i}$ 为：\n$$\nT(\\omega) = 1 + R(\\omega) = 1 + \\frac{Z_{f}(\\omega) - Z_{c}(\\omega)}{Z_{f}(\\omega) + Z_{c}(\\omega)} = \\frac{(Z_{f}(\\omega) + Z_{c}(\\omega)) + (Z_{f}(\\omega) - Z_{c}(\\omega))}{Z_{f}(\\omega) + Z_{c}(\\omega)}\n$$\n$$\nT(\\omega) = \\frac{2 Z_{f}(\\omega)}{Z_{f}(\\omega) + Z_{c}(\\omega)}\n$$\n这两个表达式构成了完整的解。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nR(\\omega) = \\frac{Z_{f}(\\omega) - Z_{c}(\\omega)}{Z_{f}(\\omega) + Z_{c}(\\omega)},  T(\\omega) = \\frac{2 Z_{f}(\\omega)}{Z_{f}(\\omega) + Z_{c}(\\omega)}\n\\end{pmatrix}\n}\n$$", "id": "3351855"}, {"introduction": "除了反射，一个优秀的数值格式还必须遵守物理守恒律，尤其是能量守恒。然而，许多看似简单的时间插值方案（如线性插值）并不能保证离散能量的守恒，这可能导致在长时间模拟中出现能量的非物理性增加或减少。本练习旨在通过解析推导来量化由线性时间插值引入的“能量缺陷”[@problem_id:3351891]。通过这个过程，你将学会如何分析数值格式的能量行为，并理解插值误差如何转化为一个非物理的能量源或汇。", "problem": "一个角频率为 $\\omega$、电场振幅为 $E_0$ 的一维横向电磁平面波，在时域有限差分 (FDTD) 的子网格界面处，从一个均匀粗网格传播到一个均匀细网格中。粗网格使用的时间步长为 $\\Delta t_c$，细网格使用的时间步长为 $\\Delta t_f$，其中 $\\Delta t_f$ 是 $\\Delta t_c$ 的整数细分。在细网格一侧的界面上，切向电场和磁场是在细时间点上通过对粗网格在时间 $t_k = k \\Delta t_c$ 采集的场样本进行线性时间插值来提供的。假设法向入射，并忽略界面处的空间交錯。\n\n设粗网格和细网格的离散阻抗（数值支持的角频率为 $\\omega$ 的传播模式下平面波切向电场与磁场之比）分别为 $Z_c(\\omega)$ 和 $Z_f(\\omega)$。在粗网格上，入射波的场满足 $H_c(t) = E_c(t)/Z_c(\\omega)$；在细网格上，理想透射波将满足 $H_f(t) = E_f(t)/Z_f(\\omega)$。考虑单个粗时间间隔 $t \\in [0,\\Delta t_c]$，并假设在此间隔内入射电场为 $E_c(t) = E_0 \\cos(\\omega t)$，因此在 $t=0$ 和 $t=\\Delta t_c$ 处的粗网格样本分别为 $E_0$ 和 $E_0 \\cos(\\omega \\Delta t_c)$。\n\n将穿过界面的瞬时能量通量密度定义为标量坡印廷积 $S(t) = E(t) H(t)$，并将一个粗时间步长内的能量缺陷分数定义为\n$$\n\\delta \\equiv \\frac{\\displaystyle \\int_{0}^{\\Delta t_c} E_{\\mathrm{interp}}(t)\\, H_{\\mathrm{interp}}(t)\\, dt - \\int_{0}^{\\Delta t_c} \\frac{E_{\\mathrm{exact}}(t)^2}{Z_f(\\omega)}\\, dt}{\\displaystyle \\int_{0}^{\\Delta t_c} \\frac{E_{\\mathrm{exact}}(t)^2}{Z_f(\\omega)}\\, dt},\n$$\n其中 $E_{\\mathrm{interp}}(t)$ 和 $H_{\\mathrm{interp}}(t)$ 是根据粗网格样本构建的、在细网格一侧经过线性时间插值的场，而 $E_{\\mathrm{exact}}(t) = E_0 \\cos(\\omega t)$ 是精确的谐波场。从麦克斯韦方程组和坡印廷通量的定义出发，推导并给出一个关于 $\\delta$ 的闭式解析表达式，该表达式应以 $\\omega \\Delta t_c$ 和由 $Z_f(\\omega)/Z_c(\\omega)$ 量化的阻抗失配来表示。将你的最终答案表示为单个解析表达式；不需要数值近似或舍入。", "solution": "能量缺陷分数 $\\delta$ 定义为：\n$$\n\\delta = \\frac{\\displaystyle \\int_{0}^{\\Delta t_c} E_{\\mathrm{interp}}(t)\\, H_{\\mathrm{interp}}(t)\\, dt}{\\displaystyle \\int_{0}^{\\Delta t_c} \\frac{E_{\\mathrm{exact}}(t)^2}{Z_f(\\omega)}\\, dt} - 1\n$$\n我们分别计算分子和分母中的积分。\n\n**1. 插值场的能量通量积分**\n\n在时间区间 $[0, \\Delta t_c]$ 内，线性插值的电场 $E_{\\mathrm{interp}}(t)$ 基于样本 $E_c(0) = E_0$ 和 $E_c(\\Delta t_c) = E_0 \\cos(\\omega \\Delta t_c)$ 给出：\n$$\nE_{\\mathrm{interp}}(t) = E_0\\left(1 - \\frac{t}{\\Delta t_c}(1 - \\cos(\\omega \\Delta t_c))\\right)\n$$\n根据问题描述，插值磁场满足 $H_{\\mathrm{interp}}(t) = E_{\\mathrm{interp}}(t)/Z_c(\\omega)$。因此，分子中的积分为：\n$$\nI_{\\mathrm{interp}} = \\int_{0}^{\\Delta t_c} \\frac{E_{\\mathrm{interp}}(t)^2}{Z_c(\\omega)} dt\n$$\n为简化计算，令 $\\theta = \\omega \\Delta t_c$ 并进行换元 $u = t/\\Delta t_c$：\n$$\nI_{\\mathrm{interp}} = \\frac{E_0^2 \\Delta t_c}{Z_c(\\omega)} \\int_{0}^{1} \\left(1 - u(1 - \\cos\\theta)\\right)^2 du\n$$\n$$\nI_{\\mathrm{interp}} = \\frac{E_0^2 \\Delta t_c}{Z_c(\\omega)} \\left[u - u^2(1 - \\cos\\theta) + \\frac{u^3}{3}(1 - \\cos\\theta)^2\\right]_0^1\n$$\n$$\nI_{\\mathrm{interp}} = \\frac{E_0^2 \\Delta t_c}{Z_c(\\omega)} \\left(1 - (1 - \\cos\\theta) + \\frac{1}{3}(1 - \\cos\\theta)^2\\right) = \\frac{E_0^2 \\Delta t_c}{3Z_c(\\omega)} (1 + \\cos\\theta + \\cos^2\\theta)\n$$\n\n**2. 精确场的能量通量积分**\n\n分母中的积分，对应于理想的透射波，为：\n$$\nI_{\\mathrm{exact}} = \\int_{0}^{\\Delta t_c} \\frac{E_{\\mathrm{exact}}(t)^2}{Z_f(\\omega)} dt = \\frac{E_0^2}{Z_f(\\omega)} \\int_{0}^{\\Delta t_c} \\cos^2(\\omega t) dt\n$$\n使用恒等式 $\\cos^2(x) = \\frac{1}{2}(1 + \\cos(2x))$：\n$$\nI_{\\mathrm{exact}} = \\frac{E_0^2}{2Z_f(\\omega)} \\left[t + \\frac{\\sin(2\\omega t)}{2\\omega}\\right]_0^{\\Delta t_c} = \\frac{E_0^2 \\Delta t_c}{2Z_f(\\omega)} \\left(1 + \\frac{\\sin(2\\omega \\Delta t_c)}{2\\omega \\Delta t_c}\\right)\n$$\n代入 $\\theta = \\omega \\Delta t_c$，可得：\n$$\nI_{\\mathrm{exact}} = \\frac{E_0^2 \\Delta t_c}{2Z_f(\\omega)} \\left(1 + \\frac{\\sin(2\\theta)}{2\\theta}\\right)\n$$\n\n**3. 能量缺陷分数的推导**\n\n将上述结果代入 $\\delta$ 的定义：\n$$\n\\delta = \\frac{I_{\\mathrm{interp}}}{I_{\\mathrm{exact}}} - 1 = \\frac{\\frac{E_0^2 \\Delta t_c}{3Z_c(\\omega)} (1 + \\cos\\theta + \\cos^2\\theta)}{\\frac{E_0^2 \\Delta t_c}{2Z_f(\\omega)} \\left(1 + \\frac{\\sin(2\\theta)}{2\\theta}\\right)} - 1\n$$\n简化后得到：\n$$\n\\delta = \\frac{Z_f(\\omega)}{Z_c(\\omega)} \\cdot \\frac{2 (1 + \\cos\\theta + \\cos^2\\theta)}{3 \\left(1 + \\frac{\\sin(2\\theta)}{2\\theta}\\right)} - 1\n$$\n将 $\\theta$ 替换为 $\\omega \\Delta t_c$，并利用 $\\sin(2\\theta) = 2\\sin\\theta\\cos\\theta$，得到最终表达式：\n$$\n\\delta = \\frac{2\\omega \\Delta t_c \\frac{Z_f(\\omega)}{Z_c(\\omega)} (1 + \\cos(\\omega \\Delta t_c) + \\cos^2(\\omega \\Delta t_c))}{3(\\omega \\Delta t_c + \\sin(\\omega \\Delta t_c)\\cos(\\omega \\Delta t_c))} - 1\n$$", "answer": "$$\n\\boxed{\\frac{2\\omega \\Delta t_c \\frac{Z_f(\\omega)}{Z_c(\\omega)}\\left(1 + \\cos(\\omega \\Delta t_c) + \\cos^2(\\omega \\Delta t_c)\\right)}{3\\left(\\omega \\Delta t_c + \\sin(\\omega \\Delta t_c)\\cos(\\omega \\Delta t_c)\\right)} - 1}\n$$", "id": "3351891"}, {"introduction": "理论分析为我们提供了洞见，但如何确保我们的代码实现是正确的呢？制造解方法（Method of Manufactured Solutions, MMS）是代码验证的黄金标准。这项实践是一项动手编程练习，指导你构建一个计算测试平台，使用一个已知的解析解来严格测试插值算法的精度 [@problem_id:3351846]。你将通过测量误差范数并计算收敛率，来验证你所实现的时间和空间插值格式是否达到了其理论预期的精度阶数，这是开发可靠科学计算软件的一项关键技能。", "problem": "你需要构建一个基于麦克斯韦方程组的计算测试框架，以使用具有已知解析电场和磁场的制造解来评估子网格界面处的时间和空间插值方案。背景是一维真空电磁学，目标是在子网格化条件下，推导预期的界面误差范数并验证时间和空间上的收敛率。\n\n考虑一维无源真空中的麦克斯韦方程组，\n$$\n\\frac{\\partial E}{\\partial t} = -\\frac{1}{\\varepsilon_0}\\frac{\\partial H}{\\partial x}, \\quad \\frac{\\partial H}{\\partial t} = -\\frac{1}{\\mu_0}\\frac{\\partial E}{\\partial x},\n$$\n其中 $E(x,t)$ 是电场，单位为伏特每米 (V/m)；$H(x,t)$ 是磁场，单位为安培每米 (A/m)；$\\varepsilon_0$ 是真空介电常数，单位为法拉每米 (F/m)；$\\mu_0$ 是真空磁导率，单位为亨利每米 (H/m)。设真空光速 $c = 299792458$ 米每秒 (m/s)，真空波阻抗 $\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0}$，单位为欧姆 ($\\Omega$)。\n\n使用制造的行波解\n$$\nE(x,t) = \\sin(k x - \\omega t), \\quad H(x,t) = \\frac{1}{\\eta_0}\\sin(k x - \\omega t),\n$$\n其中域长度 $L = 1$ 米 (m)，波数 $k = 2\\pi/L$，角频率 $\\omega = c k$。这个制造解精确满足连续方程，并在任何时空点提供已知的精确值。\n\n定义一个粗网格空间步长 $\\Delta x_c$ 和一个子网格比率 $r \\in \\mathbb{N}$，细网格空间步长为 $\\Delta x_f = \\Delta x_c / r$。使用 Courant–Friedrichs–Lewy 数 $\\lambda \\in (0,1)$ 定义粗网格时间步长为 $\\Delta t_c = \\lambda \\Delta x_c / c$，并通过子循环定义细网格时间步长为 $\\Delta t_f = \\Delta t_c / r$。在子网格界面上，信息在时间上从粗网格传递到细网格，在空间上从细网格传递到粗网格。我们使用多项式 (Lagrange) 插值来理想化这些传递：\n\n- 从粗糙时间样本进行时间插值：使用一个由 $p+1$ 个均匀间隔的粗糙样本（位于时间点 $t_n + j \\Delta t_c$）构建的 $p$ 次多项式，来近似在中间细子步长 $t \\in (t_n, t_{n+1})$ 处的 $E(x_0,t)$。其中整数 $j$ 跨越一个包含 $t$ 的合适模板。\n\n- 从精细空间样本进行空间插值（限制）：使用一个由 $q+1$ 个均匀间隔的细网格样本（位于位置 $x_i + \\ell \\Delta x_f$）构建的 $q$ 次多项式，来近似在目标点 $x \\in (x_i, x_{i+1})$ 处的 $E(x,t_0)$。其中整数 $\\ell$ 跨越一个包含 $x$ 的合适模板。\n\n对于平滑的 $E$，Lagrange 插值余项表明，时间上的点态插值误差量级为 $\\mathcal{O}(\\Delta t_c^{p+1})$，空间上的点态插值误差量级为 $\\mathcal{O}(\\Delta x_f^{q+1})$。为了量化此测试框架的界面误差，定义以下误差范数：\n\n- 跨一个粗糙间隔的时间界面误差：对于固定的空间位置 $x_0$、固定的粗糙步长索引 $n$ 以及在时间点 $t_n + m \\Delta t_f$ 的细子步 $m = 1,2,\\dots,r-1$，定义\n$$\n\\mathcal{E}_t = \\left( \\frac{1}{r-1} \\sum_{m=1}^{r-1} \\left( \\widetilde{E}(x_0, t_n + m \\Delta t_f) - E(x_0, t_n + m \\Delta t_f) \\right)^2 \\right)^{1/2},\n$$\n其中 $\\widetilde{E}$ 表示由相邻粗糙样本构建的 $p$ 阶时间多项式插值。\n\n- 单个目标位置处的空间界面误差：对于固定的时间 $t_0$、严格位于细网格节点之间的目标位置 $x^\\star$ 以及宽度为 $q+1$ 的细网格模板，定义\n$$\n\\mathcal{E}_x = \\left| \\widetilde{E}(x^\\star, t_0) - E(x^\\star, t_0) \\right|,\n$$\n其中 $\\widetilde{E}$ 表示由相邻细网格样本构建的 $q$ 阶空间多项式插值。\n\n在加密 $\\Delta t_c \\mapsto \\Delta t_c/2$（固定 $r$）和 $\\Delta x_c \\mapsto \\Delta x_c/2$（因此 $\\Delta x_f \\mapsto \\Delta x_f/2$）的情况下，观测到的收敛率定义为\n$$\n\\mathsf{rate}_t = \\frac{\\log\\left(\\mathcal{E}_t(\\Delta t_c) / \\mathcal{E}_t(\\Delta t_c/2)\\right)}{\\log(2)}, \\quad\n\\mathsf{rate}_x = \\frac{\\log\\left(\\mathcal{E}_x(\\Delta x_f) / \\mathcal{E}_x(\\Delta x_f/2)\\right)}{\\log(2)}.\n$$\n预期的收敛率在时间上是 $p+1$，在空间上是 $q+1$。对于组合误差代理，定义\n$$\n\\mathcal{E}_{\\mathrm{comb}} = \\left( \\mathcal{E}_t^2 + \\mathcal{E}_x^2 \\right)^{1/2},\n$$\n在同时加密 $\\Delta t_c \\propto \\Delta x_c$ 的情况下，预期的观测收敛率是 $\\min\\{p+1, q+1\\}$。\n\n实现一个程序，该程序使用制造解 $E(x,t)$ 构建此测试框架，并通过比较所述的两个加密级别的误差来计算观测到的收敛率。使用以下物理常数和设置：\n\n- $c = 299792458$ (m/s)，$\\mu_0 = 4\\pi \\times 10^{-7}$ (H/m)，$\\varepsilon_0 = 1/(\\mu_0 c^2)$ (F/m)，$\\eta_0 = \\sqrt{\\mu_0/\\varepsilon_0}$ ($\\Omega$)。\n- 域长度 $L = 1$ (m)，波数 $k = 2\\pi/L$，角频率 $\\omega = c k$。\n- Courant–Friedrichs–Lewy 数 $\\lambda = 0.9$ (无量纲)，因此 $\\Delta t_c = \\lambda \\Delta x_c / c$。\n- 对于时间插值，使用粗糙间隔 $[t_n, t_{n+1}]$，其中 $n = 10$，空间位置为 $x_0 = 0.37 L$。\n- 对于空间插值，使用时间 $t_0 = 0.11 \\times 2\\pi/\\omega$，目标位置为 $x^\\star = x_c + \\alpha \\Delta x_f$，其中 $x_c = 0.37 L$ 且 $\\alpha = 0.3$。\n\n使用以下参数值的测试套件。对于每个测试，计算观测到的收敛率并与预期收敛率（或预期的零误差）进行比较，如果满足标准则返回布尔值 true，否则返回 false。\n\n- 测试 1 (时间，阶数 $p=1$)：$r=3$，基础粗网格步长 $\\Delta x_c = L/80$。预期时间收敛率 $= p+1 = 2$。要求：观测到的时间收敛率 $\\ge 1.8$。\n- 测试 2 (时间，阶数 $p=2$)：$r=4$，基础粗网格步长 $\\Delta x_c = L/80$。预期时间收敛率 $= p+1 = 3$。要求：观测到的时间收敛率 $\\ge 2.8$。\n- 测试 3 (空间，阶数 $q=1$)：$r=3$，基础粗网格步长 $\\Delta x_c = L/80$ (因此 $\\Delta x_f = \\Delta x_c/r$)。预期空间收敛率 $= q+1 = 2$。要求：观测到的空间收敛率 $\\ge 1.8$。\n- 测试 4 (空间，阶数 $q=2$)：$r=4$，基础粗网格步长 $\\Delta x_c = L/80$。预期空间收敛率 $= q+1 = 3$。要求：观测到的空间收敛率 $\\ge 2.8$。\n- 测试 5 (边界情况，无子循环)：$r=1$，任意 $p$ 和 $\\Delta x_c = L/80$。要求：时间界面误差 $\\mathcal{E}_t = 0$ 精确成立 (在数值公差范围内，将小于 $10^{-12}$ 的值视为零)。\n- 测试 6 (组合，同时加密)：$p=2$，$q=1$，$r=3$，基础粗网格步长 $\\Delta x_c = L/80$，将 $\\Delta x_c$ 和 $\\Delta t_c$ 都加密2倍。预期组合收敛率 $= \\min\\{p+1,q+1\\} = 2$。要求：观测到的组合收敛率 $\\ge 1.8$。\n\n你的程序必须在均匀粗糙时间节点上实现 $p$ 阶时间 Lagrange 插值，在均匀细网格空间节点上实现 $q$ 阶空间 Lagrange 插值，计算如上定义的误差范数 $\\mathcal{E}_t$、$\\mathcal{E}_x$ 和 $\\mathcal{E}_{\\mathrm{comb}}$，估计观测到的收敛率，并评估所有六个测试的布尔标准。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来、以逗号分隔的布尔值列表的结果，不含空格，形如 $[b_1,b_2,b_3,b_4,b_5,b_6]$，其中每个 $b_j$ 为 True 或 False。不允许有其他额外输出。除定义了物理常数的地方外，所有计算都是无量纲的；最终的布尔值是无单位的。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于电磁学和数值分析的原理，特别是使用麦克斯韦方程组和制造解方法进行代码验证。该问题是适定的、客观的，并包含足够的信息来构建一个唯一的、可计算的解。任务是创建一个计算测试框架，以评估子网格界面处时间和空间插值方案的收敛率。\n\n该问题的基础是一维无源真空中的麦克斯韦方程组：\n$$\n\\frac{\\partial E}{\\partial t} = -\\frac{1}{\\varepsilon_0}\\frac{\\partial H}{\\partial x}, \\quad \\frac{\\partial H}{\\partial t} = -\\frac{1}{\\mu_0}\\frac{\\partial E}{\\partial x}\n$$\n其中 $E$ 是电场，$H$ 是磁场，$\\varepsilon_0$ 是真空介电常数，$\\mu_0$ 是真空磁导率。提供了一个制造的行波解：\n$$\nE(x,t) = \\sin(k x - \\omega t)\n$$\n域长度 $L=1$ 米，波数 $k = 2\\pi/L = 2\\pi$ m$^{-1}$，角频率 $\\omega = ck$，其中 $c$ 是光速。这个解析解允许精确计算数值近似的误差。\n\n数值格式涉及一个空间步长为 $\\Delta x_c$、时间步长为 $\\Delta t_c$ 的粗网格，以及一个 $\\Delta x_f = \\Delta x_c / r$ 和 $\\Delta t_f = \\Delta t_c / r$ 的细网格，其中 $r$ 是子网格比率。时间步长通过 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = 0.9$ 与空间步长相关联，使得 $\\Delta t_c = \\lambda \\Delta x_c / c$。\n\n网格之间的插值使用 Lagrange 多项式进行。对于平滑函数，在步长为 $h$ 的网格上进行 $p$ 阶多项式插值的误差量级为 $\\mathcal{O}(h^{p+1})$。我们的目标是验证这个理论收敛率。\n\n插值模板的选择遵循标准的数值实践。\n对于在粗糙时间区间 $[t_n, t_{n+1}]$（其中 $t_n = n \\Delta t_c$）内进行 $p$ 阶时间插值，我们选择一个包含 $p+1$ 个粗糙时间点的模板。\n- 对于 $p=1$（线性），模板是 $\\{t_n, t_{n+1}\\}$。\n- 对于 $p=2$（二次），我们使用模板 $\\{t_{n-1}, t_n, t_{n+1}\\}$，它使用了一个历史点。\n\n对于在目标点 $x^\\star = x_c + \\alpha \\Delta x_f = 0.37L + 0.3\\Delta x_f$ 处进行 $q$ 阶空间插值，我们利用一个包含 $q+1$ 个细网格点的模板。细网格模板相对于点 $x_c=0.37L$ 定义，这样一个细网格节点就精确地位于 $x_c$。目标点 $x^\\star$ 位于细网格区间 $[x_c, x_c+\\Delta x_f]$ 内。\n- 对于 $q=1$（线性），模板是 $\\{x_c, x_c+\\Delta x_f\\}$。\n- 对于 $q=2$（二次），我们使用中心模板 $\\{x_c-\\Delta x_f, x_c, x_c+\\Delta x_f\\}$。\n\n误差使用定义的范数 $\\mathcal{E}_t$ 和 $\\mathcal{E}_x$ 进行量化。\n- 时间误差 $\\mathcal{E}_t$ 是在单个粗糙时间区间 $[t_n, t_{n+1}]$ 内，于 $r-1$ 个细时间步上评估的时间插值量的均方根误差，固定位置为 $x_0 = 0.37L$，粗糙步长索引为 $n=10$。\n- 空间误差 $\\mathcal{E}_x$ 是在固定时间 $t_0 = 0.11 \\times 2\\pi/\\omega$ 于单点 $x^\\star$ 处的空间插值量的绝对误差。\n\n对于一个误差度量 $\\mathcal{E}$，在网格步长从 $h$ 加密到 $h/2$ 的情况下，观测到的收敛率计算如下：\n$$\n\\mathsf{rate} = \\frac{\\log\\left(\\mathcal{E}(h) / \\mathcal{E}(h/2)\\right)}{\\log(2)}\n$$\n我们将计算 $\\mathcal{E}_t$（加密 $\\Delta t_c$）、$\\mathcal{E}_x$（加密 $\\Delta x_f$）以及在同时加密下的组合误差 $\\mathcal{E}_{\\mathrm{comb}} = (\\mathcal{E}_t^2 + \\mathcal{E}_x^2)^{1/2}$ 的这些收敛率。\n\n六个测试中每一个的步骤如下：\n1.  **测试 1 (时间, $p=1$)：** 当 $p=1$，$r=3$，基础 $\\Delta x_c = L/80$ 时，我们计算 $\\Delta x_c$ 和 $\\Delta x_c/2 = L/160$ 对应的 $\\mathcal{E}_t$。计算观测到的时间收敛率，并检查其是否满足 $\\ge 1.8$ 的要求。预期收敛率为 $p+1=2$。\n2.  **测试 2 (时间, $p=2$)：** 当 $p=2$，$r=4$，基础 $\\Delta x_c = L/80$ 时，我们计算 $\\Delta x_c$ 和 $\\Delta x_c/2$ 对应的 $\\mathcal{E}_t$。将观测到的收敛率与要求 $\\ge 2.8$ 进行比较。预期收敛率为 $p+1=3$。\n3.  **测试 3 (空间, $q=1$)：** 当 $q=1$，$r=3$，基础 $\\Delta x_c = L/80$（意味着基础细网格步长 $\\Delta x_f = L/240$）时，我们计算此 $\\Delta x_c$ 和 $\\Delta x_c/2$（意味着 $\\Delta x_f/2 = L/480$）对应的 $\\mathcal{E}_x$。检查收敛率是否满足要求 $\\ge 1.8$。预期收敛率为 $q+1=2$。\n4.  **测试 4 (空间, $q=2$)：** 当 $q=2$，$r=4$，基础 $\\Delta x_c = L/80$（基础 $\\Delta x_f = L/320$）时，我们计算此 $\\Delta x_c$ 和 $\\Delta x_c/2$（$\\Delta x_f/2 = L/640$）对应的 $\\mathcal{E}_x$。检查收敛率是否满足要求 $\\ge 2.8$。预期收敛率为 $q+1=3$。\n5.  **测试 5 (边界情况, $r=1$)：** 对于 $r=1$，细时间步长和粗时间步长相同，即 $\\Delta t_f = \\Delta t_c$。在粗时间步内没有可供插值的中间时间点。$\\mathcal{E}_t$ 定义中的求和是空的（从 $m=1$ 到 $r-1=0$），其值为 $0$。因此，时间插值误差 $\\mathcal{E}_t$ 解析上为零。该测试检查计算出的误差是否低于数值公差 $10^{-12}$。\n6.  **测试 6 (组合)：** 当 $p=2$，$q=1$，$r=3$，基础 $\\Delta x_c = L/80$ 时，我们计算 $\\Delta x_c$ 和 $\\Delta x_c/2$ 对应的 $\\mathcal{E}_{\\mathrm{comb}}$。在此同时加密下计算观测到的收敛率，并与要求 $\\ge 1.8$ 进行比较。预期收敛率为 $\\min\\{p+1, q+1\\} = \\min\\{3,2\\} = 2$。\n\n实现将使用 `scipy.interpolate.lagrange` 来构建必要的多项式插值函数，并使用 `numpy` 进行数值计算。物理常数按规定定义：$c = 299792458$ m/s, $\\mu_0 = 4\\pi \\times 10^{-7}$ H/m, $\\varepsilon_0 = 1/(\\mu_0 c^2)$ F/m。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\n\ndef solve():\n    \"\"\"\n    Constructs a computational test harness to assess temporal and spatial\n    interpolation schemes at a subgridding interface.\n    \"\"\"\n    # Physical and problem constants\n    C = 299792458.0  # Speed of light in m/s\n    L = 1.0          # Domain length in m\n    K = 2.0 * np.pi / L  # Wavenumber in rad/m\n    OMEGA = C * K    # Angular frequency in rad/s\n    LAMBDA = 0.9     # Courant-Friedrichs-Lewy number\n    N_IDX = 10       # Coarse time step index for temporal error\n    X0 = 0.37 * L    # Spatial location for temporal error\n    T0 = 0.11 * (2.0 * np.pi / OMEGA) # Time for spatial error\n    XC_BASE = 0.37 * L  # Base location for spatial stencil\n    ALPHA = 0.3      # Offset for spatial target point\n\n    def exact_E(x, t):\n        \"\"\"Computes the exact analytical electric field E(x,t).\"\"\"\n        return np.sin(K * x - OMEGA * t)\n\n    def compute_temporal_error(delta_xc, p, r):\n        \"\"\"Computes the temporal interface error norm E_t.\"\"\"\n        if r == 1:\n            # For r=1, no sub-steps exist, so the interpolation error is zero.\n            return 0.0\n\n        delta_tc = LAMBDA * delta_xc / C\n        delta_tf = delta_tc / r\n\n        # Define coarse time stencil nodes\n        if p == 1:\n            # Stencil {t_n, t_{n+1}}\n            coarse_t_nodes = (N_IDX + np.arange(p + 1)) * delta_tc\n        elif p == 2:\n            # Stencil {t_{n-1}, t_n, t_{n+1}}\n            coarse_t_nodes = (N_IDX - 1 + np.arange(p + 1)) * delta_tc\n        else:\n            raise ValueError(f\"Unsupported temporal interpolation degree p={p}\")\n\n        # Get exact E-field values at these coarse nodes\n        coarse_E_values = exact_E(X0, coarse_t_nodes)\n\n        # Create Lagrange interpolator\n        poly = lagrange(coarse_t_nodes, coarse_E_values)\n\n        # Define fine time evaluation points t_n + m*dt_f for m=1..r-1\n        fine_t_points = (N_IDX * delta_tc) + np.arange(1, r) * delta_tf\n\n        # Evaluate interpolant and exact solution at fine points\n        E_interp = poly(fine_t_points)\n        E_exact_vals = exact_E(X0, fine_t_points)\n\n        # Compute RMS error E_t\n        error = np.sqrt(np.mean((E_interp - E_exact_vals)**2))\n        return error\n\n    def compute_spatial_error(delta_xc, q, r):\n        \"\"\"Computes the spatial interface error norm E_x.\"\"\"\n        delta_xf = delta_xc / r\n        x_star = XC_BASE + ALPHA * delta_xf\n\n        # Define fine space stencil nodes\n        if q == 1:\n            # Stencil {x_c, x_c + dx_f}\n            fine_x_nodes = XC_BASE + np.arange(q + 1) * delta_xf\n        elif q == 2:\n            # Stencil {x_c - dx_f, x_c, x_c + dx_f}\n            fine_x_nodes = XC_BASE + np.arange(-1, q) * delta_xf\n        else:\n            raise ValueError(f\"Unsupported spatial interpolation degree q={q}\")\n\n        # Get exact E-field values at these fine nodes\n        fine_E_values = exact_E(fine_x_nodes, T0)\n\n        # Create Lagrange interpolator\n        poly = lagrange(fine_x_nodes, fine_E_values)\n\n        # Evaluate interpolant and exact solution at x_star\n        E_interp = poly(x_star)\n        E_exact_val = exact_E(x_star, T0)\n\n        # Compute absolute error E_x\n        error = np.abs(E_interp - E_exact_val)\n        return error\n\n    def compute_rate(error1, error2):\n        \"\"\"Computes the convergence rate.\"\"\"\n        if error1 == 0.0 or error2 == 0.0:\n            return np.inf # Or handle as a special case if needed\n        return np.log(error1 / error2) / np.log(2.0)\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'type': 'temporal', 'p': 1, 'q': None, 'r': 3, 'dx_c': L/80, 'req': 1.8},\n        {'type': 'temporal', 'p': 2, 'q': None, 'r': 4, 'dx_c': L/80, 'req': 2.8},\n        {'type': 'spatial', 'p': None, 'q': 1, 'r': 3, 'dx_c': L/80, 'req': 1.8},\n        {'type': 'spatial', 'p': None, 'q': 2, 'r': 4, 'dx_c': L/80, 'req': 2.8},\n        {'type': 'boundary', 'p': 1, 'q': None, 'r': 1, 'dx_c': L/80, 'req': 1e-12},\n        {'type': 'combined', 'p': 2, 'q': 1, 'r': 3, 'dx_c': L/80, 'req': 1.8},\n    ]\n\n    results = []\n    for params in test_cases:\n        dx_c1 = params['dx_c']\n        dx_c2 = dx_c1 / 2.0\n        \n        if params['type'] == 'temporal':\n            p = params['p']\n            r = params['r']\n            err1 = compute_temporal_error(dx_c1, p, r)\n            err2 = compute_temporal_error(dx_c2, p, r)\n            rate = compute_rate(err1, err2)\n            results.append(rate >= params['req'])\n            \n        elif params['type'] == 'spatial':\n            q = params['q']\n            r = params['r']\n            err1 = compute_spatial_error(dx_c1, q, r)\n            err2 = compute_spatial_error(dx_c2, q, r)\n            rate = compute_rate(err1, err2)\n            results.append(rate >= params['req'])\n            \n        elif params['type'] == 'boundary':\n            p = params['p']\n            r = params['r']\n            err = compute_temporal_error(dx_c1, p, r)\n            results.append(err  params['req'])\n            \n        elif params['type'] == 'combined':\n            p = params['p']\n            q = params['q']\n            r = params['r']\n            \n            # Errors at resolution 1\n            err_t1 = compute_temporal_error(dx_c1, p, r)\n            err_x1 = compute_spatial_error(dx_c1, q, r)\n            err_comb1 = np.sqrt(err_t1**2 + err_x1**2)\n            \n            # Errors at resolution 2\n            err_t2 = compute_temporal_error(dx_c2, p, r)\n            err_x2 = compute_spatial_error(dx_c2, q, r)\n            err_comb2 = np.sqrt(err_t2**2 + err_x2**2)\n            \n            rate = compute_rate(err_comb1, err_comb2)\n            results.append(rate >= params['req'])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3351846"}]}