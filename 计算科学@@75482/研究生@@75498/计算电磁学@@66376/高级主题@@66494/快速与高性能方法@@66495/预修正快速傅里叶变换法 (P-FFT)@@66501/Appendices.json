{"hands_on_practices": [{"introduction": "第一个实践旨在让您从定量的角度理解，为何像预修正快速傅里叶变换（pFFT）这样的方法对于大规模电磁分析是不可或缺的。通过针对一个实际问题，计算并比较直接矩量法（MoM）实现与 pFFT 的内存需求，您将对使求解电大尺寸问题在计算上变得可行的渐进优势有一个具体的认识。这个练习将 $O(N \\log N)$ 与 $O(N^2)$ 的抽象复杂度分析，置于一个实际的场景中 [@problem_id:3343090]。", "problem": "一个边长为 $L_{x} = 1~\\mathrm{m}$，$L_{y} = 0.5~\\mathrm{m}$ 和 $L_{z} = 0.2~\\mathrm{m}$ 的矩形完美导电箱，采用矩量法 (MoM) 离散化的表面电流公式进行建模。假设在频率 $f = 3~\\mathrm{GHz}$ 下有时谐激励，光速为 $c = 3 \\times 10^{8}~\\mathrm{m/s}$，因此波长为 $\\lambda = c/f$。设表面网格的平均边长为 $h = \\lambda/10$。对于 Rao–Wilton–Glisson 基函数，未知数的数量近似为 $N \\approx 2A/h^{2}$，其中 $A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z})$ 是总表面积。\n\n考虑使用预修正快速傅里叶变换 (pFFT) 方法来加速矩阵向量乘积。pFFT 使用一个均匀的三维卷积网格，其各轴上的间距与 $h$ 匹配，因此网格大小为 $n_{x} = L_{x}/h$，$n_{y} = L_{y}/h$ 和 $n_{z} = L_{z}/h$，网格点总数为 $M = n_{x} n_{y} n_{z}$。假设 pFFT 的内存组件如下：\n- 一组 $a = 4$ 个复数实空间或工作空间网格数组，每个数组的长度为 $M$。\n- 一个预先计算的谱域标量格林函数核，存储为 $k = 1$ 个长度为 $M$ 的复数网格数组。\n- 一个以压缩稀疏行 (CSR) 格式存储的稀疏预修正矩阵，每行平均有 $s = 60$ 个非零元。在 CSR 格式中，每个复数值占用 $b_{c} = 16$ 字节进行存储，列索引每个整数占用 $b_{i} = 4$ 字节，长度为 $N+1$ 的行指针数组每个整数占用 $b_{i} = 4$ 字节。\n\n对于稠密 MoM，假设阻抗矩阵存储为 $N \\times N$ 的复数双精度项，每项占用 $b_{c} = 16$ 字节。\n\n从以上定义和离散化假设出发，推导 pFFT 和稠密 MoM 所需总内存的符号表达式（单位为字节），代入给定参数，并计算比率\n$$R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}}.$$\n将最终比率 $R$ 表示为小数，并将答案四舍五入到四位有效数字。", "solution": "首先根据既定标准对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- 矩形箱的边长：$L_{x} = 1~\\mathrm{m}$，$L_{y} = 0.5~\\mathrm{m}$，$L_{z} = 0.2~\\mathrm{m}$。\n- 激励频率：$f = 3~\\mathrm{GHz} = 3 \\times 10^{9}~\\mathrm{Hz}$。\n- 光速：$c = 3 \\times 10^{8}~\\mathrm{m/s}$。\n- 波长定义：$\\lambda = c/f$。\n- 表面网格的平均边长：$h = \\lambda/10$。\n- 未知数数量的近似值 (Rao–Wilton–Glisson 基函数)：$N \\approx 2A/h^{2}$。\n- 总表面积：$A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z})$。\n- pFFT 卷积网格大小：$n_{x} = L_{x}/h$，$n_{y} = L_{y}/h$，$n_{z} = L_{z}/h$。\n- pFFT 网格点总数：$M = n_{x} n_{y} n_{z}$。\n- pFFT 工作空间网格数组数量：$a = 4$。\n- pFFT 格林函数核数组数量：$k = 1$。\n- 稀疏预修正矩阵每行平均非零元数：$s = 60$。\n- 每个复数占用的字节数：$b_{c} = 16$。\n- CSR 格式中每个整数占用的字节数：$b_{i} = 4$。\n- 稠密 MoM 阻抗矩阵大小：$N \\times N$，每个元素为复数。\n- 要求输出：比率 $R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}}$，四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，它对计算电磁学中两种成熟的数值方法（稠密 MoM 和 pFFT）的内存需求进行了标准比较。所有术语均按该领域的常规方式定义。该问题提法得当，提供了计算唯一数值答案所需的所有参数和公式。设定是自洽且一致的。不存在科学、逻辑或事实上的缺陷。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。将提供完整的解答。\n\n首先，我们推导每种方法所需内存的符号表达式。\n\n对于稠密矩量法 (MoM)，内存主要由存储 $N \\times N$ 阻抗矩阵所占用。由于每个元素都是一个需要 $b_{c}$ 字节的复数，总内存为：\n$$ \\text{memory}_{\\mathrm{MoM}} = N^{2} b_{c} $$\n\n对于预修正快速傅里叶变换 (pFFT) 方法，总内存是三个部分的总和：\n1.  工作空间和核函数网格数组。有 $a$ 个工作空间数组和 $k$ 个核函数数组，每个都是大小为 $M$ 的复数网格。这部分的内存为：\n    $$ \\text{memory}_{\\mathrm{grids}} = (a + k) M b_{c} $$\n2.  以压缩稀疏行 (CSR) 格式存储的稀疏预修正矩阵。行数为 $N$，每行平均非零元素数量为 $s$。因此，非零元的总数约为 $\\text{nnz} = Ns$。CSR 格式需要存储：\n    - 非零复数值：$\\text{nnz} \\times b_{c} = N s b_{c}$。\n    - 每个非零值的列索引：$\\text{nnz} \\times b_{i} = N s b_{i}$。\n    - 一个长度为 $N+1$ 的行指针数组：$(N+1) b_{i}$。\n    预修正矩阵的总内存为：\n    $$ \\text{memory}_{\\mathrm{CSR}} = N s b_{c} + N s b_{i} + (N+1) b_{i} = N s (b_{c} + b_{i}) + (N+1) b_{i} $$\n\npFFT 方法的总内存是这些部分的总和：\n$$ \\text{memory}_{\\mathrm{pFFT}} = \\text{memory}_{\\mathrm{grids}} + \\text{memory}_{\\mathrm{CSR}} = (a + k) M b_{c} + N s (b_{c} + b_{i}) + (N+1) b_{i} $$\n\n因此，比率 $R$ 为：\n$$ R = \\frac{\\text{memory}_{\\mathrm{pFFT}}}{\\text{memory}_{\\mathrm{MoM}}} = \\frac{(a + k) M b_{c} + N s (b_{c} + b_{i}) + (N+1) b_{i}}{N^{2} b_{c}} $$\n\n接下来，我们根据给定的数据计算中间参数的数值。\n波长 $\\lambda$ 是：\n$$ \\lambda = \\frac{c}{f} = \\frac{3 \\times 10^{8}~\\mathrm{m/s}}{3 \\times 10^{9}~\\mathrm{Hz}} = 0.1~\\mathrm{m} $$\n网格的平均边长 $h$ 是：\n$$ h = \\frac{\\lambda}{10} = \\frac{0.1~\\mathrm{m}}{10} = 0.01~\\mathrm{m} $$\n箱子的总表面积 $A$ 是：\n$$ A = 2(L_{x}L_{y} + L_{x}L_{z} + L_{y}L_{z}) = 2((1)(0.5) + (1)(0.2) + (0.5)(0.2))~\\mathrm{m}^{2} $$\n$$ A = 2(0.5 + 0.2 + 0.1)~\\mathrm{m}^{2} = 2(0.8)~\\mathrm{m}^{2} = 1.6~\\mathrm{m}^{2} $$\n未知数数量 $N$ 是：\n$$ N \\approx \\frac{2A}{h^{2}} = \\frac{2(1.6)}{(0.01)^{2}} = \\frac{3.2}{0.0001} = 32000 $$\npFFT 网格的尺寸是：\n$$ n_{x} = \\frac{L_{x}}{h} = \\frac{1}{0.01} = 100 $$\n$$ n_{y} = \\frac{L_{y}}{h} = \\frac{0.5}{0.01} = 50 $$\n$$ n_{z} = \\frac{L_{z}}{h} = \\frac{0.2}{0.01} = 20 $$\n网格点总数 $M$ 是：\n$$ M = n_{x} n_{y} n_{z} = (100)(50)(20) = 100000 $$\n\n现在，我们可以计算每种方法所需的内存（以字节为单位）。\n$$ \\text{memory}_{\\mathrm{MoM}} = N^{2} b_{c} = (32000)^{2} \\times 16 = 1024000000 \\times 16 = 16384000000~\\text{bytes} $$\n对于 pFFT 内存，我们使用以下数值：$a=4$，$k=1$，$s=60$，$b_{c}=16$，$b_{i}=4$，$N=32000$ 和 $M=100000$。\n$$ \\text{memory}_{\\mathrm{pFFT}} = (4+1)(100000)(16) + (32000)(60)(16+4) + (32000+1)(4) $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = (5)(100000)(16) + (32000)(60)(20) + (32001)(4) $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = 8000000 + 38400000 + 128004 $$\n$$ \\text{memory}_{\\mathrm{pFFT}} = 46528004~\\text{bytes} $$\n\n最后，我们计算比率 $R$：\n$$ R = \\frac{46528004}{16384000000} \\approx 0.00283984399 $$\n将结果四舍五入到四位有效数字得到：\n$$ R \\approx 0.002840 $$\n这个结果表明，对于此类问题，pFFT 方法相比于稠密 MoM 具有显著的内存优势。", "answer": "$$\\boxed{0.002840}$$", "id": "3343090"}, {"introduction": "“预修正”步骤是 pFFT 方法的核心概念，它确保了在标准基于 FFT 的卷积会失效的情况下，依然能保持精度。这个动手编码练习将阐明这一关键过程，指导您实现并对比一个简单的点采样相互作用核函数与一个高精度的直接求积计算在近场相互作用中的结果。通过这个实践，您将验证用精确的近场项替换非精确项，如何形成一种兼具 FFT 效率和直接积分精度的混合方法 [@problem_id:3343124]。", "problem": "给定一个单位正方形上 $M \\times M$ 面元的均匀方形网格，面元边长为 $h = 1/M$，中心位于笛卡尔坐标 $x_i = \\left( \\left(i_x + \\tfrac{1}{2}\\right)h,\\left(i_y + \\tfrac{1}{2}\\right)h \\right)$，其中 $i_x,i_y \\in \\{0,1,\\dots,M-1\\}$。考虑此网格上分段常数源分布 $q(x)$ 的势，其使用一个平滑的衰减核通过卷积表示\n$$\nK(r) = \\frac{e^{-\\mu r}}{\\sqrt{r^2 + \\epsilon^2}},\n$$\n其中 $r$ 是欧几里得距离，$\\mu  0$ 是一个衰减参数，$\\epsilon  0$ 是一个正则化长度，它模拟了有限厚度的基函数并移除了 $r=0$ 处的奇点。面元中心的离散势将通过方形面元间的相互作用来计算。\n\n预校正快速傅里叶变换 (PC-FFT) 方法通过将那些近邻网格偏移的项替换为更高精度的积分，来校正基于傅里叶变换的卷积中由点采样引入的近场相互作用的不准确性。在本问题中，您将：\n\n1. 构建一个大小为 $(2M-1)\\times(2M-1)$ 的点采样离散核 $K_{\\text{pt}}(u,v)$，它通过下式近似偏移量为 $(u,v) \\in \\{-M+1,\\dots,M-1\\}^2$ 的面元间相互作用：\n$$\nK_{\\text{pt}}(u,v) = h^2 K\\left(\\sqrt{(uh)^2 + (vh)^2}\\right),\n$$\n这对应于在源面元中心近似其贡献，并按面元面积 $h^2$ 进行缩放。\n\n2. 构建一个同样大小的直接求积离散核 $K_{\\text{dir}}(u,v)$，通过计算\n$$\nK_{\\text{dir}}(u,v) \\approx \\iint_{P_{u,v}} K\\left(\\sqrt{(uh + \\Delta x)^2 + (vh + \\Delta y)^2}\\right)\\, d\\Delta x\\, d\\Delta y\n$$\n其中 $P_{u,v}$ 是中心位于 $(uh,vh)$、边长为 $h$ 的源面元正方形，该积分使用每维 $S$ 个点的张量积中点法则进行评估。具体来说，使用中点 $\\Delta x_i = \\left(\\frac{i+\\frac{1}{2}}{S} - \\frac{1}{2}\\right)h$ 和 $\\Delta y_j = \\left(\\frac{j+\\frac{1}{2}}{S} - \\frac{1}{2}\\right)h$（其中 $i,j\\in\\{0,1,\\dots,S-1\\}$）以及权重 $w = h^2/S^2$：\n$$\nK_{\\text{dir}}(u,v) \\approx \\sum_{i=0}^{S-1}\\sum_{j=0}^{S-1} K\\left(\\sqrt{(uh + \\Delta x_i)^2 + (vh + \\Delta y_j)^2}\\right)\\, w.\n$$\n\n3. 将近场模板定义为满足 $|u| \\le r_c$ 和 $|v| \\le r_c$ 的偏移量 $(u,v)$ 的集合，其中 $r_c$ 是一个小的非负整数半径。构建预校正核 $K_{\\text{pc}}(u,v)$ 如下：\n$$\nK_{\\text{pc}}(u,v) = \\begin{cases}\nK_{\\text{dir}}(u,v),  \\text{若 } |u|\\le r_c \\text{ 且 } |v|\\le r_c,\\\\\nK_{\\text{pt}}(u,v),  \\text{其他情况}。\n\\end{cases}\n$$\n\n4. 对于一个确定性源分布 $q_{i_x,i_y} = \\sin(2\\pi x_{i_x})\\sin(2\\pi y_{i_y}) + 0.25\\cos(4\\pi x_{i_x})$，使用快速傅里叶变换 (FFT) 在面元中心通过关系式\n$$\n\\phi(\\cdot) = (q * K)(\\cdot)\n$$\n以线性卷积的方式计算势，分别对核 $K_{\\text{pt}}$、$K_{\\text{pc}}$ 和 $K_{\\text{dir}}$ 进行计算。使用通过二维基于 FFT 的卷积实现的线性卷积。所有量均为无量纲。\n\n从边界积分方程中势的积分表示和计算电磁学中 PC-FFT 方法的定义出发，推导为什么近场校正是必要的，以及它如何如上所述实现。然后，通过计算以下各项，量化预校正对最坏情况近场项的影响，并确认校正后的值与直接计算结果相匹配：\n\n- 点采样核的最坏情况近场项绝对误差：\n$$\nE_{\\text{near}}^{\\text{pt}} = \\max_{\\substack{|u|\\le r_c\\\\|v|\\le r_c}} \\left|K_{\\text{dir}}(u,v) - K_{\\text{pt}}(u,v)\\right|.\n$$\n\n- 预校正后最坏情况近场项绝对误差：\n$$\nE_{\\text{near}}^{\\text{pc}} = \\max_{\\substack{|u|\\le r_c\\\\|v|\\le r_c}} \\left|K_{\\text{dir}}(u,v) - K_{\\text{pc}}(u,v)\\right|.\n$$\n\n- 比较 $K_{\\text{pt}}$ 与 $K_{\\text{dir}}$ 时，仅近场势贡献的最坏情况绝对误差：\n$$\nE_{\\phi,\\text{near}}^{\\text{pt}} = \\max_{i_x,i_y} \\left| \\left(q * K_{\\text{pt,near}}\\right)_{i_x,i_y} - \\left(q * K_{\\text{dir,near}}\\right)_{i_x,i_y} \\right|,\n$$\n其中 $K_{\\text{pt,near}}$ 和 $K_{\\text{dir,near}}$ 是在近场模板上等于 $K_{\\text{pt}}$ 或 $K_{\\text{dir}}$，在其他地方为零的核。\n\n- 一个布尔值，指示预校正的仅近场势是否在数值容差 $10^{-12}$ 内与直接计算的仅近场势完全匹配：\n$$\nB_{\\text{near}}^{\\text{pc}} = \\left[ \\max_{i_x,i_y} \\left| \\left(q * K_{\\text{pc,near}}\\right)_{i_x,i_y} - \\left(q * K_{\\text{dir,near}}\\right)_{i_x,i_y} \\right|  10^{-12} \\right],\n$$\n其中 $K_{\\text{pc,near}}$ 在近场模板上等于 $K_{\\text{pc}}$，在其他地方为零。\n\n您的程序必须为以下参数值测试套件实现上述计算，每个案例指定为 $(M,r_c,\\mu,S)$，并将 $\\epsilon$ 设置为 $\\epsilon = 0.5h$：\n- 案例 1 (一般情况): $(M=12, r_c=1, \\mu=0.04, S=48)$。\n- 案例 2 (自相互作用项边界情况): $(M=10, r_c=0, \\mu=0.02, S=64)$。\n- 案例 3 (更宽近场模板情况): $(M=14, r_c=2, \\mu=0.08, S=32)$。\n\n所有量均为无量纲，且不出现角度。您的程序应生成单行输出，其中包含一个由方括号括起的逗号分隔列表形式的结果。对于每个测试案例，按顺序 $[E_{\\text{near}}^{\\text{pt}}, E_{\\text{near}}^{\\text{pc}}, E_{\\phi,\\text{near}}^{\\text{pt}}, B_{\\text{near}}^{\\text{pc}}]$ 输出一个包含四个条目的子列表，并将三个子列表聚合为一个列表，例如 \"[[x11,x12,x13,b1],[x21,x22,x23,b2],[x31,x32,x33,b3]]\"，其中每个 $xij$ 是一个浮点数，每个 $bk$ 是一个布尔值。", "solution": "当前问题是积分方程数值方法领域中一个明确定义的计算练习，具体涉及预校正快速傅里叶变换 (PC-FFT) 方法。所有参数、方程和任务都已足够清晰地指定，并且在科学上是合理的，为数值求解构成了有效的基础。该问题基于计算电磁学和物理学的既定原理，涉及通过与一个正则化的、带屏蔽的库仑核进行卷积来计算势。该过程是客观、一致且计算上可行的。因此，可以构建一个完整的解决方案。\n\n在许多物理和工程领域，基本任务是计算由一个域 $\\Omega$ 上的源分布 $q(x')$ 产生的势场 $\\phi(x)$。这由一个第一类弗雷德霍姆积分方程表示：\n$$\n\\phi(x) = \\int_{\\Omega} K(x, x') q(x') d\\Omega'\n$$\n此处，$K(x, x')$ 是核函数或格林函数，它描述了 $x'$ 处的点源对 $x$ 处势的影响。对于在均匀网格上具有平移不变性的问题，核函数仅依赖于位移矢量 $x-x'$，即 $K(x, x') = K(x-x')$。\n\n直接数值求解此积分方程通常涉及将域 $\\Omega$ 离散化为一组 $N$ 个较小的单元或面元，$\\{P_j\\}_{j=1}^N$。假设对源进行分段常数近似，即对于所有 $x' \\in P_j$ 都有 $q(x') = q_j$，则面元 $P_i$ 中心 $x_i$ 处的势由以下总和给出：\n$$\n\\phi_i = \\sum_{j=1}^{N} q_j \\left( \\int_{P_j} K(x_i - x') d\\Omega' \\right)\n$$\n这可以写成矩阵向量积 $\\boldsymbol{\\phi} = \\mathbf{A}\\mathbf{q}$，其中矩阵项 $A_{ij}$ 是核函数在源面元 $P_j$ 上的积分。对于一个 $M \\times M$ 面元的均匀网格，$N=M^2$，相互作用矩阵 $\\mathbf{A}$ 成为一个块托普利茨矩阵，反映了平移不变性。该矩阵向量积是一个离散卷积：\n$$\n\\phi_i = \\sum_{j} q_j \\mathcal{K}_{i-j}\n$$\n其中 $\\mathcal{K}_{i-j} = \\int_{P_j} K(x_i - x') d\\Omega'$ 是对应于偏移量 $i-j$ 的面元积分核。这种卷积可以使用快速傅里叶变换 (FFT) 通过卷积定理以 $O(N \\log N)$ 的计算复杂度进行计算：$\\mathcal{F}(\\boldsymbol{\\phi}) = \\mathcal{F}(\\mathbf{q}) \\odot \\mathcal{F}(\\boldsymbol{\\mathcal{K}})$，其中 $\\odot$ 表示逐元素乘积。\n\n近场校正的必要性源于使用这种基于 FFT 方法的实际困难。FFT 需要网格上的核值 $\\mathcal{K}$。对于 $\\mathcal{K}_{i-j}$，一个直接且计算成本低的近似是使用点对点相互作用，其中整个源面元 $P_j$ 由其中心 $x_j$ 处的一个点电荷表示。然后，该相互作用按面元面积 $h^2$ 进行缩放。这产生了问题中定义的点采样核：\n$$\nK_{\\text{pt}}(x_i - x_j) = h^2 K(x_i - x_j)\n$$\n这种近似仅在面元之间的距离 $|x_i - x_j|$ 远大于面元尺寸 $h$ 时才准确。对于邻近的面元（“近场”），核函数 $K(r)$ 在源面元 $P_j$ 的区域内可能变化很大。对于给定的核 $K(r) = e^{-\\mu r}/\\sqrt{r^2 + \\epsilon^2}$，当 $r$ 很小时，该函数及其梯度都很大，这使得点采样近似在小间距时非常不准确。近场核项的这种不准确性导致计算出的势 $\\boldsymbol{\\phi}$ 出现显著误差。\n\n预校正快速傅里叶变换 (PC-FFT) 方法解决了这个问题。其核心思想是对大部分相互作用（“远场”）使用高效的基于 FFT 的卷积（在其准确的区域），并校正错误的近场贡献。这是通过在执行卷积之前创建一个“预校正”核 $K_{\\text{pc}}$ 来实现的。\n\n正如问题中所述，其实现如下：\n1. 对于选定半径 $r_c$ 内的近场偏移量 $(u,v)$，计算一个高精度的“直接”核 $K_{\\text{dir}}(u,v)$。这是通过使用高阶数值求积来近似积分 $\\int_{P_j} K(x_i - x') d\\Omega'$，从而为相互作用提供一个基准真值。\n2. 对于所有其他的“远场”偏移量，使用计算成本低的点采样核 $K_{\\text{pt}}(u,v)$。\n3. 将这两者结合起来形成预校正核：\n    $$\n    K_{\\text{pc}}(u,v) = \\begin{cases}\n    K_{\\text{dir}}(u,v),   \\text{若 } |u|\\le r_c \\text{ 且 } |v|\\le r_c \\text{ (近场)}\\\\\n    K_{\\text{pt}}(u,v),   \\text{其他情况 (远场)}\n    \\end{cases}\n    $$\n然后，通过使用源 $q$ 与此混合核 $K_{\\text{pc}}$ 进行基于 FFT 的卷积，一步计算出最终的势。该方法有效地将点采样核中不准确的近场项替换为它们准确的、直接积分的对应项。由于近场相互作用的数量很少（与 $(2r_c+1)^2$ 成正比），为这几个偏移量计算 $K_{\\text{dir}}$ 的成本是可控的，并且保留了基于 FFT 卷积的整体 $O(N \\log N)$ 复杂度。\n\n待计算的量用于验证这一推理：\n- $E_{\\text{near}}^{\\text{pt}}$ 量化了点采样近似在近场中引入的巨大误差。\n- $E_{\\text{near}}^{\\text{pc}}$ 确认了预校正步骤成功替换了近场核项，将这些特定项的误差减小到零（在机器精度范围内）。\n- $E_{\\phi,\\text{near}}^{\\text{pt}}$ 衡量了近场核误差对最终势计算的影响，隔离了来自近邻相互作用的贡献。\n- $B_{\\text{near}}^{\\text{pc}}$ 确认了使用预校正核计算的近邻势贡献，与使用高精度直接求积核为相同邻居计算的势完全匹配。这证明了校正的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\nimport math\n\ndef solve():\n    \"\"\"\n    Implements the PC-FFT analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (M, r_c, mu, S)\n        (12, 1, 0.04, 48),\n        (10, 0, 0.02, 64),\n        (14, 2, 0.08, 32),\n    ]\n\n    all_results = []\n\n    for M, r_c, mu, S in test_cases:\n        h = 1.0 / M\n        epsilon = 0.5 * h\n\n        # Define the kernel function K(r)\n        def kernel_func(r, mu_param, eps_param):\n            # Handle r=0 case, which is possible with uh=0, vh=0\n            # and dx=0, dy=0 in quadrature, though unlikely with midpoint rule.\n            # The epsilon term prevents division by zero.\n            return np.exp(-mu_param * r) / np.sqrt(r**2 + eps_param**2)\n\n        # 1. Construct kernels K_pt and K_dir\n        kernel_size = 2 * M - 1\n        K_pt = np.zeros((kernel_size, kernel_size))\n        K_dir = np.zeros((kernel_size, kernel_size))\n\n        u_offsets = np.arange(-M + 1, M)\n        v_offsets = np.arange(-M + 1, M)\n        \n        # Grid of offsets (u,v) for vectorization\n        U_grid, V_grid = np.meshgrid(u_offsets, v_offsets, indexing='xy')\n        \n        # Point-sampled kernel K_pt\n        R_pt = np.sqrt((U_grid * h)**2 + (V_grid * h)**2)\n        K_pt = h**2 * kernel_func(R_pt, mu, epsilon)\n\n        # Direct-quadrature kernel K_dir\n        quad_indices = np.arange(S)\n        delta_x = ((quad_indices + 0.5) / S - 0.5) * h\n        delta_y = ((quad_indices + 0.5) / S - 0.5) * h\n        w = h**2 / S**2\n        \n        # Vectorized quadrature summation\n        for v_idx, v in enumerate(v_offsets):\n            for u_idx, u in enumerate(u_offsets):\n                # Positions inside the source panel relative to the origin\n                x_quad = u * h + delta_x[:, np.newaxis]\n                y_quad = v * h + delta_y[np.newaxis, :]\n                \n                # Distances for all quadrature points\n                r_quad = np.sqrt(x_quad**2 + y_quad**2)\n                \n                # Sum kernel values and multiply by weight\n                integral_sum = np.sum(kernel_func(r_quad, mu, epsilon))\n                K_dir[v_idx, u_idx] = integral_sum * w\n\n        # 2. Define near-field stencil and build K_pc\n        near_mask = (np.abs(U_grid) = r_c)  (np.abs(V_grid) = r_c)\n        \n        K_pc = K_pt.copy()\n        K_pc[near_mask] = K_dir[near_mask]\n\n        # 3. Compute error metrics for kernels\n        E_near_pt = np.max(np.abs(K_dir[near_mask] - K_pt[near_mask])) if np.any(near_mask) else 0.0\n        E_near_pc = np.max(np.abs(K_dir[near_mask] - K_pc[near_mask])) if np.any(near_mask) else 0.0\n\n        # 4. Compute potential contributions via convolution\n        # Source distribution q\n        ix = np.arange(M)\n        iy = np.arange(M)\n        x_centers = (ix + 0.5) * h\n        y_centers = (iy + 0.5) * h\n        X_q, Y_q = np.meshgrid(x_centers, y_centers, indexing='xy')\n        q = np.sin(2 * np.pi * X_q) * np.sin(2 * np.pi * Y_q) + 0.25 * np.cos(4 * np.pi * X_q)\n\n        # Near-field-only kernels\n        K_pt_near = np.zeros_like(K_pt)\n        K_pt_near[near_mask] = K_pt[near_mask]\n        \n        K_dir_near = np.zeros_like(K_dir)\n        K_dir_near[near_mask] = K_dir[near_mask]\n        \n        K_pc_near = np.zeros_like(K_pc)\n        K_pc_near[near_mask] = K_pc[near_mask]\n\n        # Convolutions\n        # scipy.signal.fftconvolve with mode='same' calculates the linear convolution\n        # and returns the central part of the output that is the same size as the first input (q).\n        phi_pt_near = fftconvolve(q, K_pt_near, mode='same')\n        phi_dir_near = fftconvolve(q, K_dir_near, mode='same')\n        phi_pc_near = fftconvolve(q, K_pc_near, mode='same')\n        \n        # Error metrics for potential\n        E_phi_near_pt = np.max(np.abs(phi_pt_near - phi_dir_near))\n        \n        # Boolean check for PC potential\n        B_near_pc = np.max(np.abs(phi_pc_near - phi_dir_near))  1e-12\n\n        all_results.append([E_near_pt, E_near_pc, E_phi_near_pt, B_near_pc])\n\n    # Final print statement\n    # The string representation of list of lists with booleans will be e.g.,\n    # [[0.1, 0.0, 0.2, True], [0.3, 0.0, 0.4, True]]\n    # This is joined by commas to give:\n    # \"[[0.1, 0.0, 0.2, True],[0.3, 0.0, 0.4, True]]\"\n    # as string, which matches the required format schema.\n    final_str = \",\".join(map(str, all_results))\n    print(f\"[{final_str}]\")\n\n\nsolve()\n\n```", "id": "3343124"}]}