{"hands_on_practices": [{"introduction": "在宇宙学微扰理论中，一个核心任务是通过泊松方程将标量势 $\\Phi$ 与密度微扰 $\\delta$ 联系起来。在周期性网格的傅里叶空间中，该方程在波数 $\\mathbf{k}=\\mathbf{0}$ 处会遇到奇点。本练习 [@problem_id:3485164] 旨在通过实践，探索如何通过施加零平均值的物理约束来正确处理此问题，并量化一种常见但欠严谨的“红外截断”修正方法所引入的误差，从而加深对数值模拟中规范固定的理解。", "problem": "考虑一个边长为 $L$ 的周期性、立方、共动模拟盒子，以及一个每个维度有 $N$ 个点的离散网格。设 $\\delta(\\mathbf{x})$ 是定义在此网格上的一个无量纲标量微扰场。在数值宇宙学中使用的标量、矢量和张量微扰分解中，标量部分可以由一个标量势 $\\Phi(\\mathbf{x})$ 表示，该标量势由 $\\delta(\\mathbf{x})$ 通过一个泊松型关系作为源。基于以下基本原理：\n- 标量势 $\\Phi(\\mathbf{x})$ 由泊松方程 $\\nabla^2 \\Phi(\\mathbf{x}) = \\mathcal{S}\\,\\delta(\\mathbf{x})$ 在周期性边界条件下确定，其中 $\\mathcal{S}$ 是一个常数归一化因子。由于只需要相对比较，设 $\\mathcal{S}=1$ 以保持所有量都无量纲。\n- 在周期性域上，傅里叶基使拉普拉斯算符对角化。将 $\\Phi(\\mathbf{x})$ 的离散傅里叶变换表示为 $\\Phi(\\mathbf{k})$，将 $\\delta(\\mathbf{x})$ 的离散傅里叶变换表示为 $\\delta(\\mathbf{k})$。然后，对于每个非零波矢 $\\mathbf{k}$，有 $-k^2 \\Phi(\\mathbf{k}) = \\delta(\\mathbf{k})$，其中 $k \\equiv \\lvert \\mathbf{k} \\rvert$。零模式 $\\mathbf{k}=\\mathbf{0}$ 是奇异的，因为 $k^2=0$。\n- 周期性域中的亥姆霍兹分解意味着向 $\\Phi(\\mathbf{x})$ 添加一个空间常数不会改变其标量梯度分量。因此，$\\Phi(\\mathbf{x})$ 的 $\\mathbf{k}=\\mathbf{0}$ 分量可以通过规范约定来固定。对 $\\Phi(\\mathbf{x})$ 强制零均值可设定 $\\Phi(\\mathbf{k}=\\mathbf{0})=0$，从而避免 $\\mathbf{k}=\\mathbf{0}$ 处的奇异性。\n\n考虑两种数值求解器：\n- 零均值强制（对于周期性盒子中的标量势是物理上正确的）：设置 $\\delta(\\mathbf{k}=\\mathbf{0})=0$（等效于减去 $\\delta(\\mathbf{x})$ 的空间平均值），并对所有非零 $\\mathbf{k}$ 求解 $\\Phi_0(\\mathbf{k}) = -\\delta(\\mathbf{k})/k^2$；设置 $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$。\n- 红外正则化求解器（在实践中常被用作一种简易的修正方法）：对所有 $\\mathbf{k}$ 求解 $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k})/(k^2+\\epsilon^2)$，其中 $\\epsilon$ 是一个小的正红外正则化子（单位为长度的倒数）。这会消除奇异性，但也会改变长波模式。\n\n您的任务是编写一个完整的程序，该程序：\n1. 在三维网格上构造 $\\delta(\\mathbf{x})$，作为具有确定性伪随机种子的独立同分布、零均值、单位方差的高斯随机变量。然后，在指定时向 $\\delta(\\mathbf{x})$ 添加一个指定的常数偏移（可能为零），以模拟非零的平均密度对比。\n2. 使用角频率约定 $k_i = 2\\pi n_i/L$（其中 $n_i \\in \\{-\\lfloor N/2 \\rfloor,\\dots, \\lfloor(N-1)/2\\rfloor\\}$）计算离散傅里叶变换和与边长为 $L$ 的周期性盒子相一致的相应波矢。\n3. 实现上述两种求解器以获得 $\\Phi_0(\\mathbf{k})$ 和 $\\Phi_\\epsilon(\\mathbf{k})$。对于零均值强制，设置 $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$ 并仅处理 $k>0$ 的情况。对于红外正则化求解器，对所有 $\\mathbf{k}$（包括 $\\mathbf{0}$）应用相同的公式。\n4. 通过计算在基本非零波数大小 $k_{\\min} = 2\\pi/L$ 处的壳层平均分数振幅偏差来量化对长波模式的影响。将基本壳层定义为离散网格上所有大小恰好为 $k_{\\min}$ 的模式。设场 $\\Phi(\\mathbf{k})$ 的壳层平均振幅为在该壳层上 $\\lvert \\Phi(\\mathbf{k}) \\rvert^2$ 平均值的平方根。报告分数偏差\n$$\nB \\equiv \\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}} - 1,\n$$\n该偏差是无量纲的。负的 $B$ 值表示红外正则化子 $\\epsilon$ 对长波振幅的阻尼效应。\n5. 生成单行输出，其中包含每个测试用例的结果，格式为方括号内以逗号分隔的列表，每个 $B$ 值四舍五入到 $6$ 位小数。此问题中没有物理单位；所有量都是无量纲的。不使用角度。\n\n使用以下测试套件，它改变了网格分辨率 $N$、盒子大小 $L$、伪随机种子、添加到 $\\delta(\\mathbf{x})$ 的常数偏移以及选择为基本波数 $k_{\\min}$ 倍数的红外正则化子：\n- 测试用例 1（具有非零均值和中等红外正则化的理想路径）：$N=32$， $L=1.0$，种子 $=1234$，偏移量 $=0.2$，$\\epsilon = 0.5\\,k_{\\min}$。\n- 测试用例 2（零均值和弱红外正则化）：$N=24$， $L=1.0$，种子 $=1$，偏移量 $=0.0$，$\\epsilon = 0.1\\,k_{\\min}$。\n- 测试用例 3（零均值和强红外正则化，探测一个类似边界的情况）：$N=24$， $L=1.0$，种子 $=42$，偏移量 $=0.0$，$\\epsilon = 1.0\\,k_{\\min}$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内的逗号分隔列表（例如 $[result1,result2,result3]$），其中每个条目是对应测试用例的标量值 $B$，四舍五入到 $6$ 位小数。", "solution": "该问题要求我们量化在周期性网格上求解泊松方程时红外正则化方案的效果，这是数值宇宙学中的一个常见任务。我们需要比较两种方法：一种是基于物理动机的零均值强制法，另一种是数值上方便的红外正则化求解器。通过计算最长波长模式振幅的分数偏差 $B$ 来进行比较。\n\n问题的核心是在边长为 $L$ 的周期性域上求解泊松方程 $\\nabla^2 \\Phi(\\mathbf{x}) = \\delta(\\mathbf{x})$。在傅里叶空间中，该方程变为 $-k^2 \\Phi(\\mathbf{k}) = \\delta(\\mathbf{k})$，其中 $\\mathbf{k}$ 是波矢，$k = \\lvert \\mathbf{k} \\rvert$ 是其大小。在零模式 $\\mathbf{k}=\\mathbf{0}$ 处会出现奇异性，因为在该点 $k^2 = 0$。\n\n问题提出了两种处理这种奇异性的不同方法。\n\n**方法1：零均值强制（物理上正确）**\n势 $\\Phi$ 的定义只到相差一个可加常数为止，因为 $\\nabla^2(\\Phi + C) = \\nabla^2\\Phi$。在周期性域中，这种自由度对应于势的 $\\mathbf{k}=\\mathbf{0}$ 模式，即 $\\Phi(\\mathbf{k}=\\mathbf{0})$。一个标准的规范选择是将势的空间平均值设为零，这意味着 $\\Phi(\\mathbf{k}=\\mathbf{0})=0$。为了使泊松方程在该规范下保持一致，源项也必须具有零均值，这在傅里叶空间中意味着 $\\delta(\\mathbf{k}=\\mathbf{0})=0$。这可以通过在求解前从场中减去 $\\delta(\\mathbf{x})$ 的平均值来实现。解，我们记作 $\\Phi_0(\\mathbf{k})$，则为：\n$$\n\\Phi_0(\\mathbf{k}) =\n\\begin{cases}\n    -\\frac{\\delta(\\mathbf{k}) - \\delta_{\\mathbf{k},\\mathbf{0}} \\delta(\\mathbf{k}=\\mathbf{0})}{k^2} & \\text{for } k > 0 \\\\\n    0 & \\text{for } k = 0\n\\end{cases}\n$$\n其中 $\\delta_{\\mathbf{k},\\mathbf{0}}$ 是克罗内克 delta。这等效于取输入场 $\\delta(\\mathbf{k})$，将其 $\\mathbf{k}=\\mathbf{0}$ 分量设为零，然后使用标准公式求解 $\\Phi(\\mathbf{k})$，同时明确设置 $\\Phi(\\mathbf{k}=\\mathbf{0})=0$。\n\n**方法2：红外正则化求解器（数值修正）**\n一种更简单但物理上不那么严谨的方法是在分母上添加一个小的正项 $\\epsilon^2$ 来对其进行正则化。解，记作 $\\Phi_\\epsilon(\\mathbf{k})$，由下式给出：\n$$\n\\Phi_\\epsilon(\\mathbf{k}) = -\\frac{\\delta(\\mathbf{k})}{k^2 + \\epsilon^2}\n$$\n对所有 $\\mathbf{k}$（包括 $\\mathbf{k}=\\mathbf{0}$）都成立。这避免了除以零，但修改了所有尺度上的解，对小 $k$（长波长）的影响最为显著。\n\n**量化偏差 $B$**\n我们被要求计算在基本非零波数 $k_{\\min} = 2\\pi/L$ 处的分数偏差 $B$。这是能放入盒子中的最长波长模式。偏差定义为：\n$$\nB \\equiv \\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{\\lvert \\mathbf{k} \\rvert = k_{\\min}}}} - 1\n$$\n我们来分析这个度量。壳层平均 $\\langle \\cdot \\rangle$ 是对所有满足 $\\lvert\\mathbf{k}\\rvert = k_{\\min}$ 的模式 $\\mathbf{k}$ 进行的。对于这些模式，$k > 0$，所以 $\\Phi_0(\\mathbf{k})$ 表达式中的 $\\delta_{\\mathbf{k},\\mathbf{0}}\\delta(\\mathbf{k}=\\mathbf{0})$ 项为零。因此，对于该壳层上的所有模式，$\\Phi_0(\\mathbf{k}) = -\\delta(\\mathbf{k}) / k_{\\min}^2$。正则化求解器的相应表达式为 $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k}) / (k_{\\min}^2 + \\epsilon^2)$。\n\n对于此壳层上的任何单个模式 $\\mathbf{k}$，振幅平方的比值为：\n$$\n\\frac{\\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2}{\\lvert \\Phi_0(\\mathbf{k}) \\rvert^2} = \\frac{\\lvert -\\delta(\\mathbf{k}) / (k_{\\min}^2 + \\epsilon^2) \\rvert^2}{\\lvert -\\delta(\\mathbf{k}) / k_{\\min}^2 \\rvert^2} = \\left(\\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\\right)^2\n$$\n此比值对于壳层上的所有模式都是恒定的。因此，壳层平均振幅平方的比值是相同的：\n$$\n\\frac{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}} = \\left(\\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\\right)^2\n$$\n两边取平方根，得到均方根振幅的比值：\n$$\n\\frac{\\sqrt{\\langle \\lvert \\Phi_\\epsilon(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}}{\\sqrt{\\langle \\lvert \\Phi_0(\\mathbf{k}) \\rvert^2 \\rangle_{k=k_{\\min}}}} = \\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2}\n$$\n将此代入 $B$ 的定义中：\n$$\nB = \\frac{k_{\\min}^2}{k_{\\min}^2 + \\epsilon^2} - 1 = \\frac{k_{\\min}^2 - (k_{\\min}^2 + \\epsilon^2)}{k_{\\min}^2 + \\epsilon^2} = -\\frac{\\epsilon^2}{k_{\\min}^2 + \\epsilon^2}\n$$\n问题将 $\\epsilon$ 指定为 $k_{\\min}$ 的倍数，即 $\\epsilon = f \\cdot k_{\\min}$，其中 $f$ 为某个因子。将其代入：\n$$\nB = -\\frac{(f \\cdot k_{\\min})^2}{k_{\\min}^2 + (f \\cdot k_{\\min})^2} = -\\frac{f^2 k_{\\min}^2}{k_{\\min}^2(1 + f^2)} = -\\frac{f^2}{1 + f^2}\n$$\n这是一个显著的结果：偏差 $B$ 仅取决于比率 $f = \\epsilon/k_{\\min}$，并且与网格大小 $N$、盒子大小 $L$、随机种子和密度偏移无关。数值实现应该能重现这一解析预测。\n\n我们来计算测试用例的期望值：\n1.  **测试用例 1**: $\\epsilon = 0.5\\,k_{\\min} \\implies f=0.5$。\n    $B = -0.5^2 / (1 + 0.5^2) = -0.25 / 1.25 = -0.2$。\n2.  **测试用例 2**: $\\epsilon = 0.1\\,k_{\\min} \\implies f=0.1$。\n    $B = -0.1^2 / (1 + 0.1^2) = -0.01 / 1.01 \\approx -0.00990099$。\n3.  **测试用例 3**: $\\epsilon = 1.0\\,k_{\\min} \\implies f=1.0$。\n    $B = -1.0^2 / (1 + 1.0^2) = -1.0 / 2.0 = -0.5$。\n\n实现将按以下步骤进行：\n1.  对于每个测试用例，定义参数 $N$、$L$、种子、偏移量以及 $\\epsilon$ 的因子 $f$。\n2.  生成一个大小为 $N \\times N \\times N$ 的三维实空间网格。使用给定的种子用高斯随机变量填充它，并添加常数偏移以创建 $\\delta(\\mathbf{x})$。\n3.  计算三维离散傅里叶变换以得到 $\\delta(\\mathbf{k}) = \\texttt{FFT}[\\delta(\\mathbf{x})]$。\n4.  构建三维波矢 $\\mathbf{k}$ 网格。分量为 $k_i = 2\\pi n_i/L$，其中 $n_i$ 是由 `numpy.fft.fftfreq` 提供的整数模式数。由此计算出大小平方 $k^2 = k_x^2+k_y^2+k_z^2$ 的网格。\n5.  实现零均值求解器：创建 $\\delta(\\mathbf{k})$ 的一个副本，并将其 $(0,0,0)$ 分量设为零。然后对 $k>0$ 计算 $\\Phi_0(\\mathbf{k}) = -\\delta_{\\text{zero-mean}}(\\mathbf{k})/k^2$，并设置 $\\Phi_0(\\mathbf{k}=\\mathbf{0})=0$。\n6.  实现正则化求解器：计算 $\\Phi_\\epsilon(\\mathbf{k}) = -\\delta(\\mathbf{k})/(k^2 + \\epsilon^2)$。\n7.  识别基本壳层模式，其中 $k^2$ 恰好等于 $(2\\pi/L)^2$。\n8.  在此壳层上计算 $|\\Phi_0(\\mathbf{k})|^2$ 和 $|\\Phi_\\epsilon(\\mathbf{k})|^2$ 的平均值，然后分别取平方根以得到壳层平均振幅。\n9.  计算偏差 $B$ 并将其四舍五入到指定的精度。\n此过程将通过数值方式验证上面推导出的解析结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical cosmology problem for the given test cases.\n\n    This function calculates the fractional bias B between two Poisson solvers\n    on a periodic grid: one with proper zero-mean enforcement and another\n    with an infrared cutoff regularization.\n    \"\"\"\n\n    # Test cases are defined as tuples:\n    # (N, L, seed, offset, epsilon_factor)\n    # where epsilon = epsilon_factor * k_min.\n    test_cases = [\n        (32, 1.0, 1234, 0.2, 0.5), # Test case 1\n        (24, 1.0, 1, 0.0, 0.1),    # Test case 2\n        (24, 1.0, 42, 0.0, 1.0),    # Test case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, seed, offset, epsilon_factor = case\n\n        # 1. Construct the scalar perturbation field delta(x)\n        rng = np.random.default_rng(seed)\n        # Generate i.i.d. zero-mean, unit-variance Gaussian random variates\n        delta_x = rng.standard_normal(size=(N, N, N))\n        # Add the specified constant offset\n        delta_x += offset\n\n        # 2. Compute the discrete Fourier transform\n        delta_k = np.fft.fftn(delta_x)\n\n        # 3. Construct the wavevector grid\n        # The wavevector components are k_i = 2*pi*n_i/L.\n        # np.fft.fftfreq(N, d=L/N) gives frequencies f_i = n_i/L in cycles/length.\n        # We need angular frequencies k_i = 2*pi*f_i.\n        k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n        \n        # Create 3D grids for kx, ky, kz using 'ij' indexing to match\n        # numpy's array axis order (axis 0, 1, 2).\n        kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n\n        # Calculate the squared magnitude of the wavevector for each mode.\n        k_sq = kx**2 + ky**2 + kz**2\n\n        # 4. Implement the two solvers\n        \n        # Solver 1: Zero-mean enforcement\n        # Copy delta_k to modify for this solver.\n        delta_k_0 = delta_k.copy()\n        # Enforce zero mean for the source term by setting the k=0 mode to zero.\n        delta_k_0[0, 0, 0] = 0\n        \n        # Solve for Phi_0(k) = -delta(k)/k^2, avoiding division by zero at k=0.\n        # The result for k=0 is 0 by the gauge choice.\n        Phi_0_k = np.divide(-delta_k_0, k_sq, \n                            out=np.zeros_like(delta_k_0, dtype=np.complex128), \n                            where=(k_sq > 0))\n\n        # Solver 2: Infrared-regularized solver\n        # Calculate the fundamental wavenumber k_min and the regulator epsilon.\n        k_min = 2 * np.pi / L\n        epsilon = epsilon_factor * k_min\n        \n        # Solve for Phi_epsilon(k) = -delta(k)/(k^2 + epsilon^2).\n        # This is numerically stable for all k since epsilon > 0.\n        denominator = k_sq + epsilon**2\n        Phi_eps_k = -delta_k / denominator\n\n        # 5. Quantify the bias B at the fundamental shell\n        \n        # Identify the fundamental shell: all modes with magnitude exactly k_min.\n        # This corresponds to k^2 = k_min^2.\n        k_min_sq = k_min**2\n        # Use np.isclose for robust floating-point comparison.\n        shell_mask = np.isclose(k_sq, k_min_sq)\n\n        # Calculate the shell-averaged amplitude for each field.\n        # The amplitude is sqrt(mean of |Phi(k)|^2 over the shell).\n        # np.abs computes the modulus for complex numbers.\n        \n        # For Phi_0\n        avg_amp_sq_0 = np.mean(np.abs(Phi_0_k[shell_mask])**2)\n        amp_0 = np.sqrt(avg_amp_sq_0)\n\n        # For Phi_epsilon\n        avg_amp_sq_eps = np.mean(np.abs(Phi_eps_k[shell_mask])**2)\n        amp_eps = np.sqrt(avg_amp_sq_eps)\n\n        # Calculate the fractional bias B.\n        # Handle the unlikely case of amp_0 being zero to avoid division by zero.\n        if amp_0 == 0:\n            # This should not happen with a random field, but it is good practice.\n            # If the reference amplitude is zero, the bias is undefined.\n            # We can also say if amp_eps is also 0, bias is 0, else it's infinite.\n            # Based on the analytical derivation, amp_0 will not be zero.\n            bias = np.nan\n        else:\n            bias = (amp_eps / amp_0) - 1\n            \n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    # Each result is a scalar value rounded to 6 decimal places.\n    print(f\"[{','.join(f'{b:.6f}' for b in results)}]\")\n\nsolve()\n```", "id": "3485164"}, {"introduction": "纯矢量模式的一个关键特征是其无散性（divergence-free）。尽管在连续的演化方程（如扩散方程）中此性质是守恒的，但数值离散化过程可能会破坏这一约束，从而产生虚假的标量“污染”。本练习 [@problem_id:3485188] 将通过模拟一个纯矢量场的扩散过程，来衡量不同精度的数值格式如何引入并放大这种虚假的散度分量，这揭示了在长期宇宙学演化模拟中保持模式纯净性的关键挑战。", "problem": "考虑一个边长为 $L=2\\pi$ 的二维、周期性、方形域，其上有一个大小为 $N\\times N$ 的均匀网格，以及无量纲坐标 $(x,y)\\in[0,2\\pi)\\times[0,2\\pi)$。在宇宙学微扰理论中，速度微扰场 $\\mathbf{v}^{\\mathrm{V}}$ 的矢量（螺线管）分量由约束 $\\nabla\\cdot \\mathbf{v}^{\\mathrm{V}} = 0$ 定义。数值演化得到的速度场 $\\mathbf{v}$ 中的标量污染可以通过监测 $\\nabla\\cdot \\mathbf{v}$ 随时间的增长来量化。\n\n您将研究在演化一个初始无散场时，空间有限差分模板和显式时间积分器如何影响散度约束。使用以下基于扩散方程的、在物理和数值上都适定的设置，该设置在解析上保持螺线性：场根据以下方程演化\n$$\n\\partial_t \\mathbf{v}(x,y,t) = \\nu \\nabla^2 \\mathbf{v}(x,y,t),\n$$\n其中粘性系数 $\\nu>0$，并且在两个方向上都具有周期性边界条件。其解析性质为\n$$\n\\partial_t (\\nabla\\cdot \\mathbf{v}) = \\nu \\nabla^2 (\\nabla\\cdot \\mathbf{v})\n$$\n这意味着，如果在初始时刻 $\\nabla\\cdot \\mathbf{v}(x,y,0) = 0$，那么在连续介质中，对于所有 $t$，都有 $\\nabla\\cdot \\mathbf{v}(x,y,t)=0$。计算中出现的任何非零 $\\nabla\\cdot \\mathbf{v}$ 都是由离散化和时间积分误差引起的。\n\n通过流函数 $\\Psi(x,y)$ 构建初始无散场，使得\n$$\n\\mathbf{v}(x,y,0) \\equiv \\mathbf{v}^{\\mathrm{V}}(x,y,0) = (\\partial_y \\Psi,\\,-\\partial_x \\Psi),\n$$\n其中\n$$\n\\Psi(x,y) = \\sin(k x)\\sin(k y),\n$$\n$k$ 是一个整数波数。这在解析上保证了 $\\nabla\\cdot \\mathbf{v}(x,y,0)=0$。\n\n拉普拉斯算子 $\\nabla^2$ 的空间离散化必须在间距为 $\\Delta x = \\Delta y = 2\\pi/N$ 的均匀网格上，使用以下有限差分中心模板之一进行，并采用周期性环绕：\n- 每个方向上二阶精度的拉普拉斯算子：\n$$\n\\partial_{xx} f \\approx \\frac{f_{i+1,j} - 2 f_{i,j} + f_{i-1,j}}{\\Delta x^2},\\quad\n\\partial_{yy} f \\approx \\frac{f_{i,j+1} - 2 f_{i,j} + f_{i,j-1}}{\\Delta x^2}.\n$$\n- 每个方向上四阶精度的拉普拉斯算子：\n$$\n\\partial_{xx} f \\approx \\frac{-f_{i+2,j} + 16 f_{i+1,j} - 30 f_{i,j} + 16 f_{i-1,j} - f_{i-2,j}}{12\\,\\Delta x^2},\\quad\n\\partial_{yy} f \\approx \\frac{-f_{i,j+2} + 16 f_{i,j+1} - 30 f_{i,j} + 16 f_{i,j-1} - f_{i,j-2}}{12\\,\\Delta x^2}.\n$$\n\n时间积分必须使用以下显式格式之一进行：\n- 前向欧拉法（一阶）：\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\Delta t\\, \\nu \\nabla^2 \\mathbf{v}^n.\n$$\n- 二阶二步龙格－库塔法（霍恩法）：\n$$\n\\mathbf{v}^{(1)} = \\mathbf{v}^n + \\Delta t\\, \\nu \\nabla^2 \\mathbf{v}^n,\\quad\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\left[\\nu \\nabla^2 \\mathbf{v}^n + \\nu \\nabla^2 \\mathbf{v}^{(1)}\\right].\n$$\n\n为了独立于所选的有限差分模板来测量标量污染，使用快速傅里叶变换（FFT）通过谱方法求导来计算散度场 $\\nabla\\cdot\\mathbf{v}$。波数定义为 $k_x = 2\\pi\\,\\mathrm{fftfreq}(N,\\Delta x)$， $k_y$ 也类似，因此在傅里叶空间中散度为\n$$\n\\widehat{\\nabla\\cdot\\mathbf{v}}(\\mathbf{k}) = i k_x \\widehat{v_x}(\\mathbf{k}) + i k_y \\widehat{v_y}(\\mathbf{k}),\n$$\n然后通过逆快速傅里叶变换返回到物理空间。在最终时间 $T = \\mathrm{steps}\\times \\Delta t$ 时，通过均方根（RMS）范数的比率来量化污染\n$$\nR \\equiv \\frac{\\sqrt{\\langle (\\nabla\\cdot \\mathbf{v})^2 \\rangle}}{\\sqrt{\\langle |\\mathbf{v}|^2 \\rangle}},\n$$\n其中 $\\langle\\cdot\\rangle$ 表示在网格上的空间平均，且 $|\\mathbf{v}|^2 = v_x^2 + v_y^2$。由于所有量都在无量纲域上定义，因此这个 $R$ 是无量纲的。\n\n实现一个完整、可运行的程序，该程序：\n- 使用 $k=4$ 从 $\\Psi$ 初始化 $\\mathbf{v}(x,y,0)$，\n- 根据指定的 $\\nu$、有限差分拉普拉斯算子阶数和时间积分器选择来演化场，\n- 使用基于 FFT 的散度计算最终的污染率 $R$。\n\n使用以下参数值测试套件来探究模板精度和时间积分对散度增长的影响。所有量均为无量纲；所有答案均表示为浮点数。三角函数的角度单位是弧度。\n\n测试套件（每个案例是一个元组 $(N,\\mathrm{order},\\mathrm{integrator},\\Delta t,\\mathrm{steps},\\nu)$）：\n1. $(64,\\,2,\\,\\text{euler},\\,0.02,\\,100,\\,0.1)$\n2. $(64,\\,2,\\,\\text{rk2},\\,0.02,\\,100,\\,0.1)$\n3. $(64,\\,4,\\,\\text{euler},\\,0.005,\\,400,\\,0.1)$\n4. $(64,\\,4,\\,\\text{rk2},\\,0.01,\\,200,\\,0.1)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是为测试案例 $i$ 计算的最终污染率 $R$。输出必须严格遵守此格式，且不包含任何附加文本。", "solution": "用户提供的问题已经过分析，被认为是有效的。它具有科学依据，问题设定适定、客观，并包含了获得唯一解所需的所有信息。以下是一个完整的、合理的解决方案。\n\n### **1. 方法原理**\n\n核心任务是在一个周期性方形域上模拟二维速度场 $\\mathbf{v}(x,y,t)$ 的粘性扩散，并量化一个解析上守恒的性质——无散（螺线管）条件——因数值误差而遭破坏的程度。该演化由矢量扩散方程控制：\n$$\n\\partial_t \\mathbf{v} = \\nu \\nabla^2 \\mathbf{v}\n$$\n其中 $\\nu$ 是运动粘度。解析上，如果初始场是无散的，即 $\\nabla \\cdot \\mathbf{v}(t=0) = 0$，那么它在所有时间 $t>0$ 都保持无散。这是因为散度算子和拉普拉斯算子可以交换运算顺序：$\\partial_t(\\nabla \\cdot \\mathbf{v}) = \\nabla \\cdot (\\partial_t \\mathbf{v}) = \\nabla \\cdot (\\nu \\nabla^2 \\mathbf{v}) = \\nu \\nabla^2 (\\nabla \\cdot \\mathbf{v})$。因此，散度本身服从一个扩散方程，如果它初始处处为零，那么它将保持为零。\n\n在使用有限差分方法的数值模拟中，散度的离散算子和拉普拉斯算子的离散算子可能无法完美交换。这会导致产生虚假的、非零的散度，在宇宙学中常被称为标量污染。这种污染的大小取决于空间离散化和时间积分格式的精度。本问题通过比较不同的数值格式来研究此效应。\n\n### **2. 离散化和初始条件**\n\n模拟在 $[0, 2\\pi) \\times [0, 2\\pi)$ 域上的一个均匀 $N \\times N$ 网格上进行。网格间距为 $\\Delta x = \\Delta y = 2\\pi/N$。\n\n初始速度场必须是无散的。这可以通过从流函数 $\\Psi(x,y)$ 构建来保证：\n$$\n\\mathbf{v}(x,y,0) = (v_x, v_y) = (\\partial_y \\Psi, -\\partial_x \\Psi)\n$$\n对于光滑函数，这自动满足 $\\nabla \\cdot \\mathbf{v} = \\partial_x v_x + \\partial_y v_y = \\partial_x(\\partial_y \\Psi) + \\partial_y(-\\partial_x \\Psi) = \\partial_x \\partial_y \\Psi - \\partial_y \\partial_x \\Psi = 0$。\n\n使用给定的流函数 $\\Psi(x,y) = \\sin(k x)\\sin(k y)$ 和波数 $k=4$，初始速度分量被解析计算出来，然后在网格点 $(x_i, y_j)$ 上求值：\n$$\nv_x(x,y,0) = \\partial_y \\Psi = k \\sin(k x) \\cos(k y)\n$$\n$$\nv_y(x,y,0) = -\\partial_x \\Psi = -k \\cos(k x) \\sin(k y)\n$$\n这为时间演化提供了初始离散场 $(v_x^0, v_y^0)$。\n\n### **3. 数值实现**\n\n#### **3.1. 空间离散化：拉普拉斯算子**\n\n拉普拉斯算子 $\\nabla^2 = \\partial_{xx} + \\partial_{yy}$ 使用中心有限差分模板进行近似。由于域是周期性的，边界外的网格点会映射回域内。这可以通过 `numpy.roll` 高效实现，该函数可以对数组元素进行环绕式移位。需要两种精度的模板：\n\n- **二阶：** 对于场 $f_{i,j}$，拉普拉斯算子离散化为：\n$$\n(\\nabla^2 f)_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{\\Delta x^2} + \\frac{f_{i,j+1} - 2f_{i,j} + f_{i,j-1}}{\\Delta y^2}\n$$\n- **四阶：** 高阶模板提供了更精确的近似：\n$$\n(\\nabla^2 f)_{i,j} \\approx \\frac{-f_{i+2,j} + 16f_{i+1,j} - 30f_{i,j} + 16f_{i-1,j} - f_{i-2,j}}{12\\Delta x^2} + \\frac{-f_{i,j+2} + 16f_{i,j+1} - 30f_{i,j} + 16f_{i,j-1} - f_{i,j-2}}{12\\Delta y^2}\n$$\n一个函数会实现这些模板，将场、模板阶数和网格间距 $\\Delta x$ 作为输入。\n\n#### **3.2. 时间积分**\n\n由空间离散化产生的常微分方程组 $\\frac{d\\mathbf{v}}{dt} = \\nu \\nabla^2_{FD} \\mathbf{v}$，使用以下两种显式时间步进方法之一求解。\n\n- **前向欧拉法（一阶）：** 一种简单的一步法。\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\Delta t \\, (\\nu \\nabla^2_{FD} \\mathbf{v}^n)\n$$\n- **霍恩法（二阶龙格-库塔）：** 一种具有更高精度的两阶段预测-校正方法。\n$$\n\\mathbf{v}^{*} = \\mathbf{v}^n + \\Delta t \\, (\\nu \\nabla^2_{FD} \\mathbf{v}^n) \\quad\\text{(预测步)}\n$$\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{\\Delta t}{2} \\left[ \\nu \\nabla^2_{FD} \\mathbf{v}^n + \\nu \\nabla^2_{FD} \\mathbf{v}^{*} \\right] \\quad\\text{(校正步)}\n$$\n演化过程将执行指定的步数 `steps`。\n\n### **4. 标量污染分析**\n\n在最后一个时间步之后，对标量污染的水平进行量化。\n\n#### **4.1. 通过 FFT 计算散度**\n\n为了获得高精度的散度测量，且该测量独立于用于演化的有限差分模板，我们采用谱方法。傅里叶变换的微分性质指出，实空间中的微分对应于傅里叶空间中乘以 $i\\mathbf{k}$，其中 $\\mathbf{k}=(k_x, k_y)$ 是波矢量。\n\n算法如下：\n1.  计算最终速度分量的二维快速傅里叶变换（FFT）：$\\widehat{v_x}(\\mathbf{k}) = \\mathcal{F}(v_x)$ 和 $\\widehat{v_y}(\\mathbf{k}) = \\mathcal{F}(v_y)$。\n2.  定义与网格对应的离散波矢量，如指定：$k_x = 2\\pi\\,\\mathrm{fftfreq}(N, \\Delta x)$ 和 $k_y = 2\\pi\\,\\mathrm{fftfreq}(N, \\Delta y)$。\n3.  计算散度场的 FFT：$\\widehat{\\nabla\\cdot\\mathbf{v}}(\\mathbf{k}) = i k_x \\widehat{v_x}(\\mathbf{k}) + i k_y \\widehat{v_y}(\\mathbf{k})$。\n4.  计算逆 FFT 将结果变换回实空间：$\\nabla\\cdot\\mathbf{v}(x,y) = \\mathcal{F}^{-1}(\\widehat{\\nabla\\cdot\\mathbf{v}})$。结果是一个实值场，因此舍弃由数值噪声产生的虚部。\n\n#### **4.2. 污染率 $R$**\n\n最终的污染由无量纲比率 $R$ 来衡量，该比率将流场中散度分量的“能量”与总流场能量进行归一化。它使用均方根（RMS）空间平均（表示为 $\\langle \\cdot \\rangle$）来计算：\n$$\nR = \\frac{\\sqrt{\\langle (\\nabla\\cdot \\mathbf{v})^2 \\rangle}}{\\sqrt{\\langle |\\mathbf{v}|^2 \\rangle}} = \\frac{\\sqrt{\\frac{1}{N^2}\\sum_{i,j} (\\nabla\\cdot \\mathbf{v}_{i,j})^2}}{\\sqrt{\\frac{1}{N^2}\\sum_{i,j} (v_{x,i,j}^2 + v_{y,i,j}^2)}}\n$$\n对于每个测试案例，该比率都是根据速度场的最终状态计算的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_laplacian(field, order, dx):\n    \"\"\"\n    Computes the 2D Laplacian of a field on a periodic grid using finite differences.\n    \n    Args:\n        field (np.ndarray): The 2D input field.\n        order (int): The order of accuracy of the stencil (2 or 4).\n        dx (float): The grid spacing, assumed equal in both directions.\n\n    Returns:\n        np.ndarray: The discretized Laplacian of the field.\n    \"\"\"\n    if order == 2:\n        d2_dx2 = (np.roll(field, -1, axis=0) - 2 * field + np.roll(field, 1, axis=0)) / dx**2\n        d2_dy2 = (np.roll(field, -1, axis=1) - 2 * field + np.roll(field, 1, axis=1)) / dx**2\n        return d2_dx2 + d2_dy2\n    elif order == 4:\n        # Coefficients for the 5-point, 4th-order stencil\n        c = np.array([-1., 16., -30., 16., -1.])\n        denom = 12. * dx**2\n        \n        d2_dx2 = (c[0] * np.roll(field, -2, axis=0) +\n                  c[1] * np.roll(field, -1, axis=0) +\n                  c[2] * field +\n                  c[3] * np.roll(field, 1, axis=0) +\n                  c[4] * np.roll(field, 2, axis=0)) / denom\n        \n        d2_dy2 = (c[0] * np.roll(field, -2, axis=1) +\n                  c[1] * np.roll(field, -1, axis=1) +\n                  c[2] * field +\n                  c[3] * np.roll(field, 1, axis=1) +\n                  c[4] * np.roll(field, 2, axis=1)) / denom\n        return d2_dx2 + d2_dy2\n    else:\n        raise ValueError(\"Stencil order must be 2 or 4\")\n\ndef compute_contamination_ratio(vx, vy, N, dx):\n    \"\"\"\n    Computes the scalar contamination ratio R using FFT-based divergence.\n\n    Args:\n        vx (np.ndarray): The x-component of the velocity field.\n        vy (np.ndarray): The y-component of the velocity field.\n        N (int): The grid size in one dimension.\n        dx (float): The grid spacing.\n\n    Returns:\n        float: The dimensionless contamination ratio R.\n    \"\"\"\n    # 1. Compute divergence using spectral method\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n\n    vx_hat = np.fft.fft2(vx)\n    vy_hat = np.fft.fft2(vy)\n\n    div_v_hat = 1j * kx * vx_hat + 1j * ky * vy_hat\n    div_v = np.fft.ifft2(div_v_hat).real\n\n    # 2. Compute RMS norms\n    rms_div_v = np.sqrt(np.mean(div_v**2))\n    rms_v = np.sqrt(np.mean(vx**2 + vy**2))\n    \n    if rms_v == 0:\n        return 0.0\n\n    return rms_div_v / rms_v\n\ndef run_simulation(N, order, integrator, dt, steps, nu):\n    \"\"\"\n    Runs a single simulation case and returns the final contamination ratio.\n\n    Args:\n        N (int): Grid size.\n        order (int): Stencil order.\n        integrator (str): Time integrator ('euler' or 'rk2').\n        dt (float): Time step size.\n        steps (int): Number of time steps.\n        nu (float): Viscosity coefficient.\n\n    Returns:\n        float: The final contamination ratio R.\n    \"\"\"\n    L = 2. * np.pi\n    k_wave = 4.\n    dx = L / N\n\n    # Initialize grid and velocity field\n    grid_pts = np.arange(N) * dx\n    x, y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    \n    vx = k_wave * np.sin(k_wave * x) * np.cos(k_wave * y)\n    vy = -k_wave * np.cos(k_wave * x) * np.sin(k_wave * y)\n\n    # Time evolution loop\n    for _ in range(steps):\n        if integrator == 'euler':\n            lap_vx = get_laplacian(vx, order, dx)\n            lap_vy = get_laplacian(vy, order, dx)\n            vx += dt * nu * lap_vx\n            vy += dt * nu * lap_vy\n        elif integrator == 'rk2':\n            # Stage 1 (predictor)\n            lap_vx_n = get_laplacian(vx, order, dx)\n            lap_vy_n = get_laplacian(vy, order, dx)\n            \n            vx_star = vx + dt * nu * lap_vx_n\n            vy_star = vy + dt * nu * lap_vy_n\n            \n            # Stage 2 (corrector)\n            lap_vx_star = get_laplacian(vx_star, order, dx)\n            lap_vy_star = get_laplacian(vy_star, order, dx)\n            \n            vx += 0.5 * dt * nu * (lap_vx_n + lap_vx_star)\n            vy += 0.5 * dt * nu * (lap_vy_n + lap_vy_star)\n        else:\n            raise ValueError(f\"Unknown integrator: {integrator}\")\n\n    # Compute final answer\n    return compute_contamination_ratio(vx, vy, N, dx)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, order, integrator, dt, steps, nu)\n        (64, 2, 'euler', 0.02, 100, 0.1),\n        (64, 2, 'rk2', 0.02, 100, 0.1),\n        (64, 4, 'euler', 0.005, 400, 0.1),\n        (64, 4, 'rk2', 0.01, 200, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3485188"}]}