{"hands_on_practices": [{"introduction": "本章的第一个练习是建立数值建模信心的关键一步。我们将实现一个基于体元的正演模型，并对照均匀球体的精确解析解对其进行验证。这项实践练习 [@problem_id:3597417] 不仅能巩固我们对离散化的理解，还提供了一种具体的方法来量化数值误差如何随模型分辨率和观测距离的变化而变化。", "problem": "考虑一个半径为 $R$、密度异常为 $\\Delta \\rho$ 的球对称均匀体，该球体嵌入在均匀背景中。设国际单位制（SI）中的引力常数为 $G$。观测点位于球心正上方 $h$ 高度的垂直轴上，其重力加速度的垂直分量记为 $g_z(h)$，并采用向下为正的符号约定。您的任务是通过量化绝对误差（作为体素大小和观测高度 $h$ 的函数），来验证一个基于体素的 $g_z$ 正演模型与均匀球体解析异常的一致性。\n\n从牛顿万有引力定律和由连续质量分布引起的重力加速度的定义出发，推导均匀球体 $g_z(h)$ 的解析表达式。然后，设计一个算法，用一组边长为 $\\Delta$、密度异常恒为 $\\Delta \\rho$ 的相同立方体素来近似该球体。每个体素由位于其中心的质点表示，总的 $g_z$ 是通过对所有中心位于球体内部的体素的贡献求和得到的。对于位于位置 $(x_i,y_i,z_i)$、体积为 $\\Delta^3$、质量为 $\\Delta \\rho \\Delta^3$ 的体素，其对观测点 $(0,0,h)$ 处 $g_z$ 的贡献是根据第一性原理计算的，不使用任何简化公式。仅使用重力正演模拟所需的定律和定义。\n\n您将实现以下内容进行验证：\n1.  计算半径为 $R$、密度异常为 $\\Delta \\rho$ 的均匀球体的解析解 $g_z(h)$。\n2.  如上所述，通过用边长为 $\\Delta$ 的体素对球体进行离散化，计算基于体素的 $g_z^{\\mathrm{vox}}(h,\\Delta)$。\n3.  计算绝对误差 $E(h,\\Delta) = \\left| g_z^{\\mathrm{vox}}(h,\\Delta) - g_z(h) \\right|$。\n4.  以微伽（µGal）为单位报告 $E(h,\\Delta)$，其中 $1~\\mathrm{microgal} = 10^{-8}~\\mathrm{m/s^2}$。\n\n使用以下固定的物理参数，这些参数是现实且科学合理的：\n- 引力常数 $G = 6.67430 \\times 10^{-11}~\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，\n- 球体半径 $R = 1000~\\mathrm{m}$，\n- 密度异常 $\\Delta \\rho = 400~\\mathrm{kg/m^3}$。\n\n观测点始终位于 $(0,0,h)$，球心位于原点。在球体的包围立方体 $[-R,R] \\times [-R,R] \\times [-R,R]$ 内的规则网格上构建体素中心，间距为 $\\Delta$，各轴上的中心坐标为 $-R + \\Delta/2, -R + 3\\Delta/2, \\ldots, R - \\Delta/2$。当且仅当一个体素的中心位于球体内部时，即 $x_i^2 + y_i^2 + z_i^2 \\le R^2$，才将其纳入求和。\n\n将所有误差 $E(h,\\Delta)$ 表示为以微伽（µGal）为单位的实值浮点数。本问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n计算并报告以下四种情况的 $E(h,\\Delta)$，这些情况旨在检验不同情景：\n- 情况1（场内，中等粗糙体素）：$\\Delta = 500~\\mathrm{m}$，$h = 500~\\mathrm{m}$。\n- 情况2（边界，中等体素）：$\\Delta = 250~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n- 情况3（远场，精细体素）：$\\Delta = 100~\\mathrm{m}$，$h = 5000~\\mathrm{m}$。\n- 情况4（边界，非常粗糙的体素）：$\\Delta = 1000~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述情况顺序排列的四个绝对误差 $[E(h,\\Delta)]$，格式为用逗号分隔的列表，并用方括号括起来，例如，“[e1,e2,e3,e4]”。每个条目应为以微伽（µGal）为单位的浮点数。", "solution": "在进行求解之前，需要对问题陈述进行验证。\n\n### 第一步：提取已知条件\n- **物体：** 球对称均匀体。\n- **参数：** 半径 $R$，密度异常 $\\Delta \\rho$，引力常数 $G$。\n- **观测几何：** 观测点位于 $(0,0,h)$，在球心（原点 $(0,0,0)$）正上方的垂直轴上。\n- **测量量：** 重力加速度的垂直分量 $g_z(h)$，定义向下为正。\n- **任务：** 通过量化绝对误差 $E(h,\\Delta) = \\left| g_z^{\\mathrm{vox}}(h,\\Delta) - g_z(h) \\right|$，验证基于体素的 $g_z$ 正演模型与解析解的一致性。\n- **解析模型：** 从第一性原理推导均匀球体的 $g_z(h)$ 表达式。\n- **数值模型：** 用边长为 $\\Delta$、密度异常恒为 $\\Delta \\rho$ 的相同立方体素近似球体。每个体素视为其中心的质点。总的 $g_z^{\\mathrm{vox}}$ 是所有中心位于球体内部（$x_i^2 + y_i^2 + z_i^2 \\le R^2$）的体素贡献之和。每个体素的贡献必须从第一性原理推导。\n- **体素网格：** 体素中心位于覆盖立方体 $[-R,R] \\times [-R,R] \\times [-R,R]$ 的规则网格上，间距为 $\\Delta$。各轴上的中心坐标为 $-R + \\Delta/2, -R + 3\\Delta/2, \\ldots, R - \\Delta/2$。\n- **常数：**\n    - 引力常数：$G = 6.67430 \\times 10^{-11}~\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n    - 球体半径：$R = 1000~\\mathrm{m}$。\n    - 密度异常：$\\Delta \\rho = 400~\\mathrm{kg/m^3}$。\n- **单位转换：** 以微伽（µGal）为单位报告误差 $E(h, \\Delta)$，其中 $1~\\mathrm{µGal} = 10^{-8}~\\mathrm{m/s^2}$。\n- **测试套件：**\n    - 情况1：$\\Delta = 500~\\mathrm{m}$，$h = 500~\\mathrm{m}$。\n    - 情况2：$\\Delta = 250~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n    - 情况3：$\\Delta = 100~\\mathrm{m}$，$h = 5000~\\mathrm{m}$。\n    - 情况4：$\\Delta = 1000~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n- **输出格式：** 一个包含四个浮点误差值的列表，以微伽为单位，格式为 `[e1,e2,e3,e4]`。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学性：** 该问题是位场地球物理学中的一个经典练习，基于牛顿万有引力定律。所有物理原理、常数（$G, R, \\Delta\\rho$）和单位都是科学上合理且符合实际的。\n- **适定性：** 问题提供了一套完整的参数和清晰明确的步骤来计算解析解和数值解。每个测试案例都存在唯一且有意义的结果（离散化误差）。\n- **客观性：** 问题以精确、定量和客观的语言陈述，没有任何主观性或歧义。\n- **缺陷清单：**\n    1.  **科学/事实不成立：** 无。该问题基于基础物理学。\n    2.  **非形式化/不相关：** 无。这是计算地球物理学的核心课题。\n    3.  **不完整/矛盾：** 无。所有必要信息均已提供，且无矛盾之处。体素网格的规范是完整的，并与测试案例一致。\n    4.  **不现实/不可行：** 无。物理参数是现实的，所需的计算是可行的。\n    5.  **不适定/结构不良：** 无。问题结构清晰，解的定义明确。\n    6.  **伪深刻/琐碎：** 无。该问题涉及解析解与数值近似之间的非平凡比较，这是科学和工程中的一个标准且有意义的任务。\n    7.  **超出科学可验证范围：** 无。结果完全可以通过计算进行验证。\n\n### 第三步：结论与行动\n该问题是**有效的**。将提供解答。\n\n### 基于原理的求解设计\n\n该解答需要两个主要部分：推导球体的解析重力异常，以及使用基于体素的模型实现数值近似。\n\n#### 1. $g_z(h)$ 的解析解\n球对称质量分布的引力场可以使用球壳定理确定，该定理是牛顿引力定律积分的直接结果。该定理与本问题相关的有两个部分：\n1.  球体对外部质点产生的引力，等效于球体全部质量集中于其中心时产生的引力。\n2.  球壳对其内部任何质点产生的引力为零。\n\n设球体半径为 $R$，均匀密度异常为 $\\Delta \\rho$。总异常质量为 $M = \\Delta \\rho \\cdot V = \\Delta \\rho \\left( \\frac{4}{3}\\pi R^3 \\right)$。观测点位于 z 轴上高度为 $h$ 的位置，其坐标为 $(0, 0, h)$。\n\n情况 A：观测点在球体外部（$h \\ge R$）\n根据球壳定理，该球体的作用如同一个质量为 $M$ 的质点位于原点。作用在 $(0, 0, h)$ 处测试质量 $m_t$ 上的引力指向原点。加速度矢量为 $\\vec{g} = -\\frac{GM}{h^2} \\hat{k}$，其中 $\\hat{k}$ 是 $+z$ 方向的单位矢量。垂直分量为 $g_z = \\vec{g} \\cdot \\hat{k} = -\\frac{GM}{h^2}$。问题定义 $g_z$ 向下为正，因此我们取其向下分量的大小：\n$$ g_z(h) = \\frac{GM}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi R^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2} \\quad \\text{for } h \\ge R $$\n\n情况 B：观测点在球体内部（$h  R$）\n在距中心距离为 $h$ 的位置，外部质量壳层（半径从 $h$ 到 $R$）不产生净力。引力仅由半径为 $h$ 的内部球体产生。该内部球体的质量为 $M_{\\text{inner}} = \\Delta \\rho \\left( \\frac{4}{3}\\pi h^3 \\right)$。对这个内部质量应用球壳定理的第一部分，重力加速度为：\n$$ g_z(h) = \\frac{G M_{\\text{inner}}}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi h^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho h \\quad \\text{for } h  R $$\n\n综合两种情况，解析解为：\n$$ g_z(h) = \\begin{cases} \\frac{4}{3}\\pi G \\Delta \\rho h   \\text{if } h  R \\\\ \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2}   \\text{if } h \\ge R \\end{cases} $$\n\n#### 2. 基于体素的数值解 $g_z^{\\mathrm{vox}}(h, \\Delta)$\n球体被离散化为一组立方体素。每个体素被视为位于其中心的质点。\n设一个体素的边长为 $\\Delta$。其体积为 $V_{\\mathrm{vox}} = \\Delta^3$，质量为 $m_{\\mathrm{vox}} = \\Delta \\rho \\Delta^3$。\n考虑一个中心位于 $\\vec{r}_i = (x_i, y_i, z_i)$ 的单个体素。观测点位于 $\\vec{r}_{\\mathrm{obs}} = (0, 0, h)$。从体素到观测点的位移矢量为 $\\vec{d} = \\vec{r}_{\\mathrm{obs}} - \\vec{r}_i = (-x_i, -y_i, h-z_i)$。距离为 $d = |\\vec{d}| = \\sqrt{x_i^2 + y_i^2 + (h-z_i)^2}$。\n\n根据牛顿万有引力定律，该体素对观测点处的测试质量 $m_t$ 产生的引力是吸引力，即从 $\\vec{r}_{\\mathrm{obs}}$ 指向 $\\vec{r}_i$。力矢量为：\n$$ \\vec{F}_i = - \\frac{G m_{\\mathrm{vox}} m_t}{d^2} \\hat{d} = - \\frac{G m_{\\mathrm{vox}} m_t}{d^3} \\vec{d} = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (-\\vec{d}) = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (x_i, y_i, z_i-h) $$\n该体素的加速度贡献为 $\\vec{g}_i = \\vec{F}_i / m_t = \\frac{G m_{\\mathrm{vox}}}{d^3} (x_i, y_i, z_i-h)$。\n该加速度的垂直（$z$）分量为 $g_{z,i} = \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3}$。\n按照问题的符号约定（向下为正），我们寻求 $-z$ 方向上的加速度分量。即 $-g_{z,i}$：\n$$ g_{z,i}^{\\text{downward}} = - \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3} = \\frac{G m_{\\mathrm{vox}} (h - z_i)}{(x_i^2 + y_i^2 + (h-z_i)^2)^{3/2}} $$\n体素模型的总垂直重力异常是所有中心 $(x_i, y_i, z_i)$ 满足包含条件 $x_i^2 + y_i^2 + z_i^2 \\le R^2$ 的体素贡献之和：\n$$ g_z^{\\mathrm{vox}}(h, \\Delta) = \\sum_{i,j,k \\text{ s.t. } x_{ijk}^2 + y_{ijk}^2 + z_{ijk}^2 \\le R^2} \\frac{G (\\Delta\\rho \\Delta^3) (h - z_{ijk})}{\\left( x_{ijk}^2 + y_{ijk}^2 + (h-z_{ijk})^2 \\right)^{3/2}} $$\n体素中心坐标 $(x_{ijk}, y_{ijk}, z_{ijk})$ 在指定的网格上生成。对于一个轴，坐标为 $c_n = -R + (n+0.5)\\Delta$，其中 $n \\in \\{0, 1, ..., N-1\\}$ 且 $N = 2R/\\Delta$。\n\n#### 3. 误差计算\n绝对误差 $E(h, \\Delta)$ 以 SI 单位（$\\mathrm{m/s^2}$）计算，然后转换为微伽（µGal）。\n$$ E(h, \\Delta) [\\mathrm{m/s^2}] = \\left| g_z^{\\mathrm{vox}}(h, \\Delta) - g_z(h) \\right| $$\n$$ E(h, \\Delta) [\\mathrm{µGal}] = E(h, \\Delta) [\\mathrm{m/s^2}] \\times 10^8 $$\n\n算法将迭代四个测试案例，对每个案例执行这些计算，并以指定格式报告最终误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between analytic and voxel-based gravity models\n    for a homogeneous sphere for a suite of test cases.\n    \"\"\"\n    # Define physical constants and model parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    R = 1000.0  # m\n    DELTA_RHO = 400.0  # kg/m^3\n    \n    # Unit conversion factor from m/s^2 to microgal\n    M_S2_TO_UGAL = 1e8\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_m, h_m)\n    test_cases = [\n        (500.0, 500.0),    # Case 1\n        (250.0, 1000.0),   # Case 2\n        (100.0, 5000.0),   # Case 3\n        (1000.0, 1000.0)   # Case 4\n    ]\n\n    results = []\n    for delta, h in test_cases:\n        # --- 1. Compute the analytic gravity anomaly g_z(h) ---\n        if h  R:\n            # Inside the sphere: g_z = (4/3) * pi * G * delta_rho * h\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * h\n        else: # h >= R\n            # Outside or on the surface of the sphere: g_z = G * M / h^2\n            # M = delta_rho * (4/3) * pi * R^3\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * (R**3 / h**2)\n\n        # --- 2. Compute the voxel-based gravity anomaly g_z^vox(h, delta) ---\n        \n        # Number of voxels along one dimension of the bounding box\n        # Per problem spec, 2R/delta is an integer for all test cases\n        N = int(2 * R / delta)\n        \n        # Generate 1D array of voxel center coordinates for one axis\n        coords_1d = -R + (np.arange(N) + 0.5) * delta\n        \n        # Create 3D grid of voxel center coordinates (x, y, z)\n        x_grid, y_grid, z_grid = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n        # Calculate the squared distance of each voxel center from the origin\n        dist_sq_from_origin = x_grid**2 + y_grid**2 + z_grid**2\n        \n        # Create a boolean mask for voxels whose centers are inside the sphere\n        inside_sphere_mask = dist_sq_from_origin = R**2\n\n        # Filter the coordinates to get only those inside the sphere\n        x_inside = x_grid[inside_sphere_mask]\n        y_inside = y_grid[inside_sphere_mask]\n        z_inside = z_grid[inside_sphere_mask]\n        \n        # If no voxel centers are inside the sphere (e.g., very coarse grid),\n        # the voxel contribution is zero.\n        if x_inside.size == 0:\n            g_z_vox = 0.0\n        else:\n            # Mass of a single voxel\n            m_vox = DELTA_RHO * delta**3\n    \n            # Calculate the squared distance from each included voxel to the observation point (0, 0, h)\n            dist_sq_from_obs = x_inside**2 + y_inside**2 + (h - z_inside)**2\n            dist_from_obs = np.sqrt(dist_sq_from_obs)\n\n            # Calculate the downward vertical gravity contribution from each voxel\n            # g_z_i = G * m_vox * (h - z_i) / d^3\n            # Note: dist_from_obs is guaranteed to be non-zero as per analysis in the thought process.\n            g_z_contributions = G * m_vox * (h - z_inside) / (dist_from_obs**3)\n    \n            # Sum the contributions from all voxels\n            g_z_vox = np.sum(g_z_contributions)\n\n        # --- 3. Compute the absolute error E(h, delta) ---\n        error_si = np.abs(g_z_vox - g_z_analytic)\n        \n        # Convert error to microgal (µGal)\n        error_ugal = error_si * M_S2_TO_UGAL\n        \n        results.append(error_ugal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3597417"}, {"introduction": "在单体模型的基础上，我们现在将探讨包含多个地质体的场景，这依赖于线性叠加原理。这项练习 [@problem_id:3597400] 具有双重目的：首先是通过数值方法验证总重力异常是个体异常之和，其次是直面浮点数求和误差这一实际的计算挑战。通过比较不同的求和策略，我们将获得关于如何确保数值代码准确性和稳定性的重要见解。", "problem": "设计并实现一个完整的、可运行的程序，构建一个数值测试框架，以验证重力异常的线性叠加原理并量化浮点求和误差。请严格遵循第一性原理：从 Newton 引力定律和球壳定理出发，实现由多个均匀密度球体引起的引力加速度的垂直分量，然后构建测试来 (i) 在数值上验证线性叠加原理，以及 (ii) 测量不同求和顺序下的累积误差。\n\n使用以下基本原理：\n- Newton 引力定律：一个位于位置 $\\mathbf{r}_\\mathrm{c}$、质量为 $M$ 的质点，在位置 $\\mathbf{r}_0$ 处产生的加速度等于 $\\mathbf{g}(\\mathbf{r}_0) = G M \\dfrac{\\mathbf{r}_\\mathrm{c}-\\mathbf{r}_0}{\\lVert \\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0 \\rVert^3}$，其中 $G$ 是引力常数。\n- 球壳定理：对于一个半径为 $a$、质量为 $M$ 的均匀实心球体，其外部场（$R \\ge a$）与位于中心的质点产生的场相同，其内部场（$R  a$）与到中心的距离 $R$ 呈线性关系，其表达式为 $\\mathbf{g} = - G M \\dfrac{\\mathbf{r}_0-\\mathbf{r}_\\mathrm{c}}{a^3}$。\n- 均匀球体的质量：$M = \\dfrac{4}{3}\\pi a^3 \\rho$，其中 $\\rho$ 是密度（此处解释为密度差）。\n\n采用右手坐标系，$x$ 轴指向东，$y$ 轴指向北，$z$ 轴正方向朝上。根据地球物理学的惯例，重力的垂直分量应以向下为正方向报告。根据上述基本原理，由一个中心位于 $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c},y_\\mathrm{c},z_\\mathrm{c})$、半径为 $a$、密度为 $\\rho$ 的均匀球体在点 $\\mathbf{r}_0 = (x_0,y_0,z_0)$ 处产生的垂直分量为：\n- 定义 $\\Delta x = x_0 - x_\\mathrm{c}$，$\\Delta y = y_0 - y_\\mathrm{c}$，$\\Delta z = z_0 - z_\\mathrm{c}$，以及 $R = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$；\n- 定义 $M = \\dfrac{4}{3}\\pi a^3 \\rho$；\n- 定义向下为正的垂直分量为 $g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$\n\n使用国际单位制 (SI)。将引力常数设置为 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。所有长度单位必须是 $\\mathrm{m}$，密度单位是 $\\mathrm{kg/m^3}$，程序必须以微伽 (microgal, microgalileo) 为单位报告重力差，其中 $1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$，并在需要时以相同单位报告总重力值。\n\n针对每个球体的贡献值 $\\{g_{z,i}^\\downarrow\\}_{i=1}^N$，实现三种求和策略：\n- 朴素前向求和（从左到右）。\n- 按绝对值升序和降序重新排序后的朴素求和。\n- 使用 Kahan 算法的补偿求和。\n\n对于下述每个测试用例，计算：\n- $d_\\mathrm{order}$：按 $|g_{z,i}^\\downarrow|$ 升序和降序进行朴素求和所得结果之间的绝对差，单位为微伽；\n- $d_\\mathrm{naive\\_kahan}$：朴素前向求和（按原始物体顺序）与 Kahan 补偿求和结果之间的绝对差，单位为微伽；\n- 一个线性检查布尔值，通过将物体集合划分为两个指定的组 $A$ 和 $B$ 来计算，在每个组内使用 Kahan 补偿求和计算 $S_A$ 和 $S_B$，然后检验是否满足 $| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$，其中 $S_{\\mathrm{all}}$ 是对所有物体进行 Kahan 补偿求和的结果，且 $\\tau = 0.1\\,\\mathrm{microgal}$。\n\n测试套件和参数。对于所有情况，观测点为 $\\mathbf{r}_0 = (0,0,0)\\,\\mathrm{m}$，程序必须计算并报告上述定义的各量。每个球体由一个元组 $(x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c}, a, \\rho)$ 指定，单位为 $(\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{kg/m^3})$。负的 $\\rho$ 值表示负密度差，在异常的背景下是物理上允许的。\n\n- 用例 1（平衡、不重叠、中等密度差；“理想路径”）：\n  - 物体（八个球体）：\n    - $(+1500, 0, -1500, 300, +350)$，\n    - $(-1500, 0, -1500, 300, +350)$，\n    - $(0, +1500, -1500, 300, +350)$，\n    - $(0, -1500, -1500, 300, +350)$，\n    - $(+1200, +1200, -2200, 250, +200)$，\n    - $(-1200, +1200, -2200, 250, +200)$，\n    - $(+1200, -1200, -2200, 250, +200)$，\n    - $(-1200, -1200, -2200, 250, +200)$。\n  - 线性检查的分区：A 组为所列的前四个球体；B 组为后四个球体。\n\n- 用例 2（强抵消；交替密度差）：\n  - 物体：对于 $k \\in \\{1,2,\\dots,10\\}$，在相同深度定义两个球体，\n    - $(+500k, 0, -2000, 400, +400)$，\n    - $(-500k, 0, -2000, 400, -400)$。\n    总共产生 20 个球体。\n  - 分区：A 组为所有 $\\rho  0$ 的球体，B 组为所有 $\\rho  0$ 的球体。\n\n- 用例 3（极端动态范围；一个占主导地位的近源加上许多弱的远源）：\n  - 物体：\n    - 一个主导球体：$(0, 0, -1200, 800, +500)$。\n    - 两个具有交替符号密度差的小球体环：\n      - 环 1：半径 $R_1 = 10000$，深度 $z = -8000$，半径 $a = 50$，密度大小 $|\\rho| = 100$，角度 $\\theta_k = k \\times 15^\\circ$，其中 $k \\in \\{0,1,\\dots,23\\}$。对于每个 $k$，在 $(R_1 \\cos\\theta_k, R_1 \\sin\\theta_k, -8000, 50, \\rho_k)$ 处放置一个球体，其中当 $k$ 为偶数时 $\\rho_k = (+100)$，当 $k$ 为奇数时 $\\rho_k = (-100)$。\n      - 环 2：半径 $R_2 = 15000$，深度 $z = -10000$，半径 $a = 50$，密度大小 $|\\rho| = 100$，角度 $\\phi_k = k \\times 15^\\circ$，其中 $k \\in \\{0,1,\\dots,23\\}$。对于每个 $k$，在 $(R_2 \\cos\\phi_k, R_2 \\sin\\phi_k, -10000, 50, \\rho'_k)$ 处放置一个球体，其中当 $k$ 为偶数时 $\\rho'_k = (-100)$，当 $k$ 为奇数时 $\\rho'_k = (+100)$。\n  - 分区：A 组为单个主导球体；B 组为所有小环上的球体。\n\n计算要求：\n- 在 SI 单位制下使用 $G = 6.67430 \\times 10^{-11}$。\n- 所有计算均使用双精度浮点数处理。\n- 对于每种情况下的三个度量指标，差值以微伽表示。线性检查必须精确使用 $\\tau = 0.1$ 微伽的容差。\n- 程序必须在无输入和无外部文件的情况下运行，并生成单行输出，其中包含一个由三个条目（每个条目对应一个案例）组成的逗号分隔列表，每个条目本身是包含三个值 $[d_\\mathrm{order}, d_\\mathrm{naive\\_kahan}, \\text{linearity\\_ok}]$ 的列表。例如，一个语法正确的输出形式为 $[[x_1,y_1,b_1],[x_2,y_2,b_2],[x_3,y_3,b_3]]$，其中三个 $b_i$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。所有 $x_i$ 和 $y_i$ 都必须是表示微伽值的浮点数。", "solution": "该问题要求在 Python 中设计和实现一个数值测试框架，以验证重力异常的线性叠加原理并量化浮点求和误差。这涉及到对多个球体产生的垂直引力加速度进行建模，实现多种求和算法，以及运行一套已定义的测试用例。该解决方案按要求从第一性原理开始构建。\n\n### 1. 引力模型公式化\n\n模型的基础是 Newton 万有引力定律和球壳定理。我们关心的是在观测点 $\\mathbf{r}_0 = (x_0, y_0, z_0)$ 处，由一组均匀球体引起的引力加速度的垂直分量 $g_z^\\downarrow$。坐标系定义为 $z$ 轴正方向朝上。遵循地球物理学惯例，我们将 $g_z^\\downarrow$ 定义为向下为正。\n\n对于一个半径为 $a$、密度差为 $\\rho$、中心位于 $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c})$ 的球体，其质量由 $M = \\frac{4}{3}\\pi a^3 \\rho$ 给出。从球心到观测点的矢量为 $\\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} = (\\Delta x, \\Delta y, \\Delta z)$。距离为 $R = \\lVert \\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} \\rVert$。\n\n引力加速度矢量 $\\mathbf{g}$ 对于外部点（$R \\ge a$）由 $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{R^3}$ 给出，对于内部点（$R  a$）由 $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{a^3}$ 给出。该矢量的垂直（$z$）分量在外部情况下为 $g_z = G M \\frac{z_\\mathrm{c} - z_0}{R^3} = -G M \\frac{\\Delta z}{R^3}$。因此，向下为正的分量为 $g_z^\\downarrow = -g_z = G M \\frac{\\Delta z}{R^3}$。对内部情况进行类似推导，可得 $g_z^\\downarrow = G M \\frac{\\Delta z}{a^3}$。这些表达式被合并成一个单一的函数：\n$$g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$$\n这个公式在一个名为 `calculate_gz_down` 的函数中实现，该函数接收一个球体的属性和观测点坐标作为参数，返回以 SI 单位（$\\mathrm{m/s^2}$）表示的垂直重力异常。引力常数被设置为 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。\n\n### 2. 求和算法与误差量化\n\n总重力异常是所有球体贡献的总和，即 $g_{z, \\mathrm{total}}^\\downarrow = \\sum_{i=1}^N g_{z,i}^\\downarrow$。由于浮点运算的精度有限，这个求和的结果可能取决于运算的顺序。问题要求实现并比较三种求和策略。\n\n1.  **朴素求和**：这是对各个重力值 $\\{g_{z,i}^\\downarrow\\}$ 进行的直接从左到右的求和。它针对三种不同的排序方式实现：\n    a.  球体定义的原始顺序（在初始列表上使用 `naive_sum`）。\n    b.  按绝对值升序，即从最小的 $|g_{z,i}^\\downarrow|$ 加到最大的。\n    c.  按绝对值降序。\n    升序和降序求和之间的差值 $d_\\mathrm{order} = |S_{\\mathrm{asc}} - S_{\\mathrm{desc}}|$，量化了朴素求和的顺序依赖性。\n\n2.  **Kahan 补偿求和**：这是一个著名算法，能显著减少浮点数求和中的数值误差。它维护一个运行中的补偿变量 $c$，用以累加每次加法中丢失的低位比特。对一个值序列 $v_i$ 进行求和的算法如下：\n    - 初始化总和 $s = 0$ 和补偿 $c = 0$。\n    - 对于每个值 $v_i$：\n        - $y = v_i - c$\n        - $t = s + y$\n        - $c = (t - s) - y$\n        - $s = t$\n    - 最终结果是 $s$。\n    这在一个名为 `kahan_sum` 的函数中实现。朴素前向求和与 Kahan 求和之间的差值 $d_\\mathrm{naive\\_kahan} = |S_{\\mathrm{forward}} - S_{\\mathrm{Kahan}}|$，衡量了最简单的求和方法相对于更精确方法的误差。\n\n### 3. 线性验证\n\n叠加原理指出，来自多个源的总场是每个独立源产生的场的总和。在我们的情境下，这意味着如果所有物体的集合被划分为两个不相交的子集 $A$ 和 $B$，那么总异常应等于每个子集异常的总和：$S_{\\mathrm{all}} = S_A + S_B$。虽然这在解析上是正确的，但浮点误差可能会导致差异。\n\n线性检查旨在从数值上检验这一点。使用高精度的 Kahan 求和进行所有计算，我们计算所有物体的总和 $S_{\\mathrm{all}}$，以及指定组 A 和 B 的总和 $S_A$ 和 $S_B$。如果绝对差在指定的容差 $\\tau = 0.1\\,\\mathrm{microgal}$ 范围内，则检查通过：\n$$| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$$\n报告一个布尔结果 `linearity_ok`。此测试主要验证分区和求和逻辑的正确性，因为 Kahan 求和预计足够精确，能使该恒等式以高精度成立。\n\n### 4. 实现结构\n\n一个主函数 `solve` 负责协调整个过程。它为三个测试用例定义了参数，包括为用例 2 和用例 3 以编程方式生成球体位置。对于每个用例，会调用一个 `process_case` 函数，该函数会：\n1.  在观测点 $\\mathbf{r}_0 = (0,0,0)$ 计算所有球体的独立 $g_{z,i}^\\downarrow$ 值。\n2.  使用各种方法（在不同排序上使用 `naive_sum`，`kahan_sum`）计算总和。\n3.  计算所需的度量指标：$d_\\mathrm{order}$ 和 $d_\\mathrm{naive\\_kahan}$。\n4.  基于指定的分区执行线性检查。\n5.  通过乘以 $10^8$ 将最终的差值从 SI 单位转换为微伽（$1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$）。\n6.  以列表形式返回三个结果：$[d_\\mathrm{order}, d_\\mathrm{naive\\_kahan}, \\mathrm{linearity\\_ok}]$。\n\n最后，`solve` 函数收集所有测试用例的结果，并以指定的单行格式打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test harness for gravity anomaly calculations.\n    \"\"\"\n\n    # --- Constants and Unit Conversions ---\n    G = 6.67430e-11  # Gravitational constant in SI units (m^3 kg^-1 s^-2)\n    MKS_TO_MICROGAL = 1e8  # Conversion factor from m/s^2 to microgal\n    LINEARITY_TOLERANCE_MICROGAL = 0.1  # Tolerance for linearity check\n\n    # --- Core Calculation and Summation Functions ---\n\n    def calculate_gz_down(sphere, r0):\n        \"\"\"\n        Calculates the downward-positive vertical gravity component from a single sphere.\n        \n        Args:\n            sphere (tuple): (xc, yc, zc, a, rho) for the sphere.\n            r0 (tuple): (x0, y0, z0) for the observation point.\n\n        Returns:\n            float: The gravity anomaly gz_down in m/s^2.\n        \"\"\"\n        xc, yc, zc, a, rho = sphere\n        x0, y0, z0 = r0\n        \n        delta_x = x0 - xc\n        delta_y = y0 - yc\n        delta_z = z0 - zc\n        \n        R2 = delta_x**2 + delta_y**2 + delta_z**2\n        \n        if R2 == 0:\n            # Observation point is at the center of the sphere.\n            # Gravitational acceleration is zero by symmetry.\n            return 0.0\n\n        R = math.sqrt(R2)\n        mass = (4.0 / 3.0) * np.pi * (a**3) * rho\n        \n        if R >= a:\n            # External field\n            factor = R**(-3)\n        else:\n            # Internal field\n            factor = a**(-3)\n            \n        gz_down = G * mass * delta_z * factor\n        return gz_down\n\n    def naive_sum(values):\n        \"\"\"Naive left-to-right summation.\"\"\"\n        s = 0.0\n        for val in values:\n            s += val\n        return s\n\n    def kahan_sum(values):\n        \"\"\"Compensated summation using Kahan's algorithm.\"\"\"\n        s = 0.0\n        c = 0.0  # A running compensation for lost low-order bits.\n        for val in values:\n            y = val - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    def process_case(spheres, partition):\n        \"\"\"\n        Processes a single test case to compute the required metrics.\n        \"\"\"\n        r0 = (0.0, 0.0, 0.0)\n        \n        # Step 1: Calculate individual gravity contributions in SI units (m/s^2)\n        gz_values = [calculate_gz_down(s, r0) for s in spheres]\n        \n        # Step 2: Perform Summations\n        s_naive_forward = naive_sum(gz_values)\n        \n        gz_sorted_asc = sorted(gz_values, key=abs)\n        s_asc = naive_sum(gz_sorted_asc)\n        \n        gz_sorted_desc = sorted(gz_values, key=abs, reverse=True)\n        s_desc = naive_sum(gz_sorted_desc)\n        \n        s_kahan_all = kahan_sum(gz_values)\n        \n        # Step 3: Calculate difference metrics\n        d_order = abs(s_asc - s_desc) * MKS_TO_MICROGAL\n        d_naive_kahan = abs(s_naive_forward - s_kahan_all) * MKS_TO_MICROGAL\n        \n        # Step 4: Linearity Check\n        group_A_indices, group_B_indices = partition\n        gz_group_A = [gz_values[i] for i in group_A_indices]\n        gz_group_B = [gz_values[i] for i in group_B_indices]\n        \n        s_kahan_A = kahan_sum(gz_group_A)\n        s_kahan_B = kahan_sum(gz_group_B)\n        \n        linearity_error = abs((s_kahan_A + s_kahan_B) - s_kahan_all) * MKS_TO_MICROGAL\n        linearity_ok = linearity_error = LINEARITY_TOLERANCE_MICROGAL\n        \n        return [d_order, d_naive_kahan, linearity_ok]\n    \n    # --- Define Test Cases ---\n\n    # Case 1: Balanced, non-overlapping, moderate contrasts\n    spheres_case1 = [\n        (1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (-1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (0.0, 1500.0, -1500.0, 300.0, 350.0),\n        (0.0, -1500.0, -1500.0, 300.0, 350.0),\n        (1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (1200.0, -1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, -1200.0, -2200.0, 250.0, 200.0),\n    ]\n    partition_case1 = (range(4), range(4, 8))\n\n    # Case 2: Strong cancellation; alternating contrasts\n    spheres_case2 = []\n    group_A_indices_c2, group_B_indices_c2 = [], []\n    for k in range(1, 11):\n        spheres_case2.append((500.0 * k, 0.0, -2000.0, 400.0, 400.0))\n        group_A_indices_c2.append(len(spheres_case2) - 1)\n        spheres_case2.append((-500.0 * k, 0.0, -2000.0, 400.0, -400.0))\n        group_B_indices_c2.append(len(spheres_case2) - 1)\n    partition_case2 = (group_A_indices_c2, group_B_indices_c2)\n\n    # Case 3: Extreme dynamic range\n    spheres_case3 = []\n    # Dominant sphere\n    spheres_case3.append((0.0, 0.0, -1200.0, 800.0, 500.0))\n    # Ring 1\n    R1, z1, a1, rho_mag1 = 10000.0, -8000.0, 50.0, 100.0\n    for k in range(24):\n        theta = k * np.pi / 12.0\n        xc, yc = R1 * np.cos(theta), R1 * np.sin(theta)\n        rho = rho_mag1 if k % 2 == 0 else -rho_mag1\n        spheres_case3.append((xc, yc, z1, a1, rho))\n    # Ring 2\n    R2, z2, a2, rho_mag2 = 15000.0, -10000.0, 50.0, 100.0\n    for k in range(24):\n        phi = k * np.pi / 12.0\n        xc, yc = R2 * np.cos(phi), R2 * np.sin(phi)\n        rho = -rho_mag2 if k % 2 == 0 else rho_mag2\n        spheres_case3.append((xc, yc, z2, a2, rho))\n    partition_case3 = ([0], range(1, 49))\n\n    test_cases = [\n        (spheres_case1, partition_case1),\n        (spheres_case2, partition_case2),\n        (spheres_case3, partition_case3),\n    ]\n\n    # --- Run Tests and Collect Results ---\n    results = [process_case(spheres, partition) for spheres, partition in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3597400"}, {"introduction": "最后的实践练习将介绍一种强大的数据处理与解释技术：向上延拓。我们将从空间域转换到波数（或傅里叶）域，以理解重力场如何随高度自然衰減。通过实现向上延拓算子 [@problem_id:3597422]，您将直接观察其作为低通滤波器的效果，并量化短波长（浅源）和长波长（深源）特征的不同衰減方式，这是分离区域和剩余异常的关键概念。", "problem": "当一个二维地表重力异常场由完全位于观测平面下方的地下质量分布引起时，该场在观测平面上方是一个调和函数。从牛顿引力以及引力位在无源区域满足拉普拉斯方程的性质出发，推导重力异常场在水平波数域中的向上延拓算子。然后实现该算子，并量化向上延拓如何衰减不同的水平波长。不要使用任何预先推导的向上延拓公式；相反，应从控制方程出发进行推导。\n\n假设以下基本依据：\n- 牛顿引力定律：由质量密度 $\\rho(\\mathbf{r}')$ 产生的引力位 $\\Phi(\\mathbf{r})$ 满足泊松方程 $\\nabla^2 \\Phi(\\mathbf{r}) = 4 \\pi G \\rho(\\mathbf{r})$，其中 $G$ 是引力常数，$\\mathbf{r}$ 是位置。\n- 在无源区域，引力位满足拉普拉斯方程 $\\nabla^2 \\Phi(\\mathbf{r}) = 0$。\n- 在水平面上测量的重力异常与位的空间导数有关，并继承了该平面上方的调和性质。\n\n基于这些原理，证明场的每个水平傅里叶模式随高度衰减，并推导其对水平波数大小的函数依赖关系。\n\n算法任务：\n1. 在一个矩形网格上构建一个合成的二维重力异常场 $g(x,y)$，该场在 $x$ 方向上是周期的，与 $y$ 无关，但在整个二维网格上都有定义。该场是波长为 $\\lambda \\in \\{2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}, 10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}\\}$ 的余弦分量之和，每个分量的振幅为单位振幅。网格参数如下：\n   - $x$ 方向的采样点数：$N_x = 320$。\n   - $y$ 方向的采样点数：$N_y = 128$。\n   - $x$ 方向的采样间隔：$\\Delta x = 500\\,\\mathrm{m}$。\n   - $y$ 方向的采样间隔：$\\Delta y = 500\\,\\mathrm{m}$。\n   因此，域长度为 $L_x = N_x \\Delta x = 160000\\,\\mathrm{m}$ 和 $L_y = N_y \\Delta y = 64000\\,\\mathrm{m}$。使用余弦分量 $\\cos\\left(2\\pi x / \\lambda\\right)$，以使每个波长在域 $L_x$ 中包含整数个周期。\n2. 计算 $g(x,y)$ 的二维快速傅里叶变换 (FFT) $G(\\mathbf{k})$，其中 $\\mathbf{k} = (k_x, k_y)$ 且 $k_x = 2\\pi f_x$，$k_y = 2\\pi f_y$，而 $f_x$ 和 $f_y$ 是来自离散傅里叶变换频率网格的空间频率，单位为周/米。\n3. 基于每个傅里叶模式的拉普拉斯方程解，推导并实现在波数域中的向上延拓算子。将该算子应用于 $G(\\mathbf{k})$，以获得在原始观测平面上方高度 $h$ 处的谱。然后，如果需要，计算逆 FFT 以获得向上延拓后的场 $g_h(x,y)$。\n4. 对于指定的测试高度和目标波长，计算每个波长的衰减因子，即在向上延拓前后，对应水平波数处的谱振幅之比。对于目标波长 $\\lambda$，确定相应的 $k_x$ 单元索引 $m = L_x / \\lambda$（一个整数），并使用位于 $(k_x = +2\\pi m / L_x, k_y = 0)$ 和 $(k_x = -2\\pi m / L_x, k_y = 0)$ 的一对谱系数。一个波长的衰减因子定义为向上延拓后这两个系数的幅值之和与向上延拓前这两个系数的幅值之和的比值。该比值为无量纲。\n5. 所有高度均以米表示。最终的衰减值为无量纲浮点数。\n\n测试套件：\n- 情况 A (一般情况)：高度 $h = 2000\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n- 情况 B (靠近较高波数的边缘情况)：高度 $h = 500\\,\\mathrm{m}$，波长 $\\lambda = [2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}]$。\n- 情况 C (边界条件)：高度 $h = 0\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n- 情况 D (强衰减)：高度 $h = 20000\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是该用例中各波长衰减因子的浮点数列表。例如，输出必须类似于：“[[a1,a2,a3],[b1,b2,b3],[c1,c2,c3],[d1,d2,d3]]”，不带任何附加文本。", "solution": "所提供的问题经评估是有效的。它以位场理论原理为科学依据，是适定的，具有明确定义的目标和一套完整的参数，并使用客观、正式的语言。它代表了计算地球物理学中的一个标准问题。\n\n### 向上延拓算子的推导\n\n推导从牛顿引力的基本原理开始。\n\n1.  **控制方程**：问题指出，源于地下质量分布的地表重力异常场，在源上方的无源区域是一个调和函数。设重力异常场表示为 $g(x, y, z)$。观测平面位于 $z=0$，向上方向为正 $z$ 方向。在无源半空间 $z \\ge 0$ 中，$g$ 满足拉普拉斯方程：\n    $$ \\nabla^2 g(x, y, z) = \\frac{\\partial^2 g}{\\partial x^2} + \\frac{\\partial^2 g}{\\partial y^2} + \\frac{\\partial^2 g}{\\partial z^2} = 0 $$\n\n2.  **傅里叶变换法**：我们可以通过对水平空间变量 $x$ 和 $y$ 应用二维傅里叶变换来求解这个线性偏微分方程。设 $\\hat{g}(k_x, k_y, z)$ 是 $g(x, y, z)$ 的傅里叶变换：\n    $$ \\hat{g}(k_x, k_y, z) = \\mathcal{F}_{xy}[g(x, y, z)] = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} g(x, y, z) e^{-i(k_x x + k_y y)} dx dy $$\n    其中 $k_x$ 和 $k_y$ 分别是 $x$ 和 $y$ 方向的角波数。傅里叶变换的性质指出，对空间变量的微分在傅里叶域中变成乘以相应的虚波数：\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial x^2}\\right] = (i k_x)^2 \\hat{g} = -k_x^2 \\hat{g} $$\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial y^2}\\right] = (i k_y)^2 \\hat{g} = -k_y^2 \\hat{g} $$\n    对 $z$ 的导数不受水平变换的影响。将傅里叶变换应用于拉普拉斯方程，得到：\n    $$ -k_x^2 \\hat{g}(k_x, k_y, z) - k_y^2 \\hat{g}(k_x, k_y, z) + \\frac{\\partial^2 \\hat{g}(k_x, k_y, z)}{\\partial z^2} = 0 $$\n\n3.  **常微分方程**：这将偏微分方程简化为对每个波数对 $(k_x, k_y)$ 关于变量 $z$ 的常微分方程 (ODE)：\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = (k_x^2 + k_y^2) \\hat{g} $$\n    令 $k_r = \\sqrt{k_x^2 + k_y^2}$ 为水平波数向量的大小。该 ODE 变为：\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = k_r^2 \\hat{g} $$\n\n4.  **通解**：这个二阶线性常微分方程的通解为：\n    $$ \\hat{g}(k_x, k_y, z) = A(k_x, k_y) e^{k_r z} + B(k_x, k_y) e^{-k_r z} $$\n    其中 $A$ 和 $B$ 是依赖于波数并由边界条件决定的系数。\n\n5.  **边界条件**：\n    a.  当远离源至无穷远处时，引力场必须保持有限并衰减到零。因此，我们要求当 $z \\to \\infty$ 时，$g(x, y, z)$ 是有界的。在波数域中，这意味着 $\\hat{g}(k_x, k_y, z)$ 也必须是有界的。由于 $k_r = \\sqrt{k_x^2 + k_y^2} \\ge 0$，对于任何 $k_r  0$，项 $e^{k_r z}$ 随 $z$ 无界增长。为了满足物理边界条件，其系数必须为零：$A(k_x, k_y) = 0$。这样剩下：\n    $$ \\hat{g}(k_x, k_y, z) = B(k_x, k_y) e^{-k_r z} $$\n    b.  在观测平面 $z=0$ 处，场为 $g(x, y, 0)$，其傅里叶变换为 $\\hat{g}(k_x, k_y, 0)$。我们将这个已知谱记为 $G(k_x, k_y)$。在我们的解中令 $z=0$：\n    $$ \\hat{g}(k_x, k_y, 0) = B(k_x, k_y) e^0 = B(k_x, k_y) $$\n    因此，系数 $B$ 就是地表重力异常的傅里叶谱 $G(k_x, k_y)$。\n\n6.  **向上延拓算子**：将 $B$ 代回解中，我们得到在任意高度 $h  0$ 处的场谱：\n    $$ \\hat{g}(k_x, k_y, h) \\equiv G_h(k_x, k_y) = G(k_x, k_y) e^{-k_r h} = G(k_x, k_y) e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n    将 $z=0$ 处的谱变换到 $z=h$ 处的谱的算子，就是在波数域中的**向上延拓算子**：\n    $$ U(k_x, k_y, h) = e^{-k_r h} = e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n\n7.  **解释与衰减**：算子 $U$ 是一个实值指数函数，依赖于高度 $h$ 和径向波数 $k_r$。由于 $h0$ 且 $k_r \\ge 0$，算子的值总是在 $0$ 和 $1$ 之间。它起到低通滤波器的作用。对于高波数（短波长，对应于小的、尖锐的特征），$k_r$ 很大，指数项 $e^{-k_r h}$ 变得非常小，从而严重衰减这些分量。对于低波数（长波长，对应于大的、宽广的特征），$k_r$ 很小，$e^{-k_r h}$ 接近于 $1$，因此这些分量仅被微弱衰减。给定波数的衰减因子是延拓前后振幅的比值：\n    $$ \\text{衰减因子} = \\frac{|G_h(k_x, k_y)|}{|G(k_x, ky)|} = \\frac{|G(k_x, k_y) e^{-k_r h}|}{|G(k_x, k_y)|} = |e^{-k_r h}| = e^{-k_r h} $$\n\n### 算法实现\n\n算法任务涉及对此原理进行数值实现。\n\n1.  **场合成**：在一个大小为 $N_x \\times N_y$、采样间隔为 $\\Delta x, \\Delta y$ 的网格上合成一个二维重力异常场 $g(x,y)$。该场是指定波长 $\\lambda$ 的余弦函数之和，在 $x$ 方向上是周期的，在 $y$ 方向上是恒定的。\n    $$ g(x,y) = \\sum_{\\lambda} \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right) $$\n\n2.  **FFT**：使用 `numpy.fft.fft2` 计算该场的二维快速傅里叶变换 (FFT) $G(k_x, k_y)$。\n\n3.  **算子构建**：根据 `numpy.fft.fftfreq` 提供的离散频率，构建相应的二维角波数网格 $k_x$ 和 $k_y$。由此计算出径向波数网格 $k_r = \\sqrt{k_x^2 + k_y^2}$。然后为给定高度 $h$ 构建向上延拓算子 $U(k_x, k_y, h) = e^{-k_r h}$。\n\n4.  **应用与分析**：通过逐元素乘法将算子应用于谱 $G(k_x, k_y)$，得到向上延拓后的谱 $G_h(k_x, k_y) = G(k_x, k_y) \\cdot U(k_x, k_y, h)$。\n\n5.  **衰减计算**：对于每个目标波长 $\\lambda$，找到相应的离散波数索引 $m = L_x / \\lambda$。由于输入信号是余弦的实数和，其谱是共轭对称的，能量集中在正负频率对上。衰减因子按问题中的定义计算：延拓前后在 $(k_x(\\pm m), k_y(0))$ 处的谱系数幅值之和的比值。\n    $$ \\text{衰减}(\\lambda) = \\frac{|\\hat{g}_h(m,0)| + |\\hat{g}_h(N_x-m,0)|}{|\\hat{g}(m,0)| + |\\hat{g}(N_x-m,0)|} $$\n    对所有测试用例重复此过程。对于 $h=0$ 的情况，算子为1，衰减因子为 $1.0$，符合预期。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies the upward continuation operator for a gravity anomaly field.\n    \"\"\"\n\n    #\n    # Part 1: Define grid and synthetic gravity field\n    #\n    Nx = 320         # Number of samples in x\n    Ny = 128         # Number of samples in y\n    dx = 500.0       # Sampling interval in x (m)\n    dy = 500.0       # Sampling interval in y (m)\n    Lx = Nx * dx     # Domain length in x (m)\n\n    # Wavelengths for the synthetic signal\n    signal_lambdas = [2000.0, 4000.0, 8000.0, 10000.0, 20000.0, 40000.0]\n\n    # Create the 1D x-coordinate vector\n    x = np.arange(Nx) * dx\n\n    # Create the 1D signal as a sum of cosine components\n    g_1d = np.zeros(Nx, dtype=float)\n    for lam in signal_lambdas:\n        g_1d += np.cos(2 * np.pi * x / lam)\n\n    # Tile the 1D signal to create the 2D field g(x,y)\n    g_xy = np.tile(g_1d, (Ny, 1))\n\n    #\n    # Part 2: Compute the 2D Fast Fourier Transform of the field\n    #\n    G_k = np.fft.fft2(g_xy)\n\n    #\n    # Part 3: Construct wavenumber grids for the operator\n    #\n    # Spatial frequencies (cycles/meter)\n    fx = np.fft.fftfreq(Nx, dx)\n    fy = np.fft.fftfreq(Ny, dy)\n\n    # Angular wavenumbers (radians/meter)\n    kx = 2 * np.pi * fx\n    ky = 2 * np.pi * fy\n\n    # Create 2D wavenumber grids\n    kxx, kyy = np.meshgrid(kx, ky)\n\n    # Radial wavenumber grid\n    kr = np.sqrt(kxx**2 + kyy**2)\n\n    #\n    # Part 4  5: Process test cases and compute attenuation factors\n    #\n    test_cases = [\n        # Case A: h=2000, lambdas=[10000, 20000, 40000]\n        (2000.0, [10000.0, 20000.0, 40000.0]),\n        # Case B: h=500, lambdas=[2000, 4000, 8000]\n        (500.0, [2000.0, 4000.0, 8000.0]),\n        # Case C: h=0, lambdas=[10000, 20000, 40000]\n        (0.0, [10000.0, 20000.0, 40000.0]),\n        # Case D: h=20000, lambdas=[10000, 20000, 40000]\n        (20000.0, [10000.0, 20000.0, 40000.0]),\n    ]\n\n    all_results = []\n\n    for h, target_lambdas in test_cases:\n        # Construct the upward continuation operator for the current height h\n        upward_continuation_operator = np.exp(-kr * h)\n\n        # Apply the operator to get the upward-continued spectrum\n        Gh_k = G_k * upward_continuation_operator\n\n        case_results = []\n        for lam in target_lambdas:\n            # The problem guarantees Lx / lam is an integer\n            m = int(round(Lx / lam))\n\n            # Indices for kx = +2*pi/lambda and kx = -2*pi/lambda\n            idx_pos_k = m\n            idx_neg_k = Nx - m\n\n            # The field is y-independent, so spectral energy is on the ky=0 axis (index 0)\n            ky_idx = 0\n\n            # Get the sum of magnitudes of the two spectral coefficients before continuation\n            sum_mag_before = np.abs(G_k[ky_idx, idx_pos_k]) + np.abs(G_k[ky_idx, idx_neg_k])\n\n            # Get the sum of magnitudes of the two spectral coefficients after continuation\n            sum_mag_after = np.abs(Gh_k[ky_idx, idx_pos_k]) + np.abs(Gh_k[ky_idx, idx_neg_k])\n\n            # The attenuation factor is the ratio of these sums.\n            # A check for sum_mag_before being near zero is good practice, but not\n            # strictly necessary here as the input signal guarantees energy at these wavelengths.\n            if sum_mag_before  1e-9:\n                attenuation = 1.0 if h == 0.0 else 0.0\n            else:\n                attenuation = sum_mag_after / sum_mag_before\n            \n            case_results.append(attenuation)\n\n        all_results.append(case_results)\n\n    # The final print statement must produce a single-line string representation\n    # of the list of lists, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3597422"}]}