{"hands_on_practices": [{"introduction": "LASSO解的路径是关于正则化参数$\\lambda$的分段线性函数。要理解整个路径的构造，我们首先需要掌握其局部行为。本练习旨在引导你推导在一个给定的活动集上解路径的导数，即路径的“斜率”。这个基本量的推导是理解和实现同伦方法的关键第一步，它揭示了在两次“事件”（即活动集变化）之间，解是如何随$\\lambda$线性变化的 [@problem_id:3451804]。", "problem": "考虑参数化的凸优化问题（最小绝对值收敛和选择算子，也称为Lasso）\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1,\n$$\n其中数据矩阵为 $A \\in \\mathbb{R}^{m \\times n}$，数据向量为 $b \\in \\mathbb{R}^m$，正则化参数为 $\\lambda \\ge 0$。令 $x^{\\star}(\\lambda)$ 表示作为 $\\lambda$ 函数的解。假设存在一个 $\\lambda$ 值的区间，在该区间上激活集 $S \\subset \\{1,\\dots,n\\}$ 和符号 $\\operatorname{sign}(x^{\\star}_S(\\lambda))$ 保持不变，且在该区间上有 $x^{\\star}_{S^c}(\\lambda) = 0$。\n\n1) 从凸最优性的基本原理（即 Karush–Kuhn–Tucker (KKT) 条件和 $\\ell_1$-范数的次微分）出发，推导在该区间上路径导数 $\\dot{x}_S(\\lambda) := \\frac{d}{d\\lambda} x^{\\star}_S(\\lambda)$ 的显式表达式，用 $A_S$ 和 $\\operatorname{sign}(x^{\\star}_S(\\lambda))$ 表示。你的推导必须只使用所述的最优性框架，以及基本的微分法则和在激活集上 $A_S^{\\top}A_S$ 的可逆性。\n\n2) 构建并分析以下具体实例，以说明 $\\dot{x}_S(\\lambda)$ 如何预测一个即将发生的系数符号翻转。令 $p = m = 2$，$S = \\{1,2\\}$，且\n$$\nA = \\begin{pmatrix} \\sqrt{\\tfrac{1}{2}}  \\sqrt{2} \\\\ 0  \\sqrt{3} \\end{pmatrix}, \\qquad\n\\lambda_0 = 1, \\qquad\nx^{\\star}(\\lambda_0) = \\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix},\n$$\n激活集 $S$ 上的符号向量由 $\\operatorname{sign}(x^{\\star}_S(\\lambda_0)) = (1,1)^{\\top}$ 给出。选择 $b \\in \\mathbb{R}^2$，使得在此激活集和符号配置下，KKT 平稳性条件在 $\\lambda_0$ 处成立。然后，使用你在第1部分得到的一般表达式，计算 $\\dot{x}_S(\\lambda_0)$，并使用得到的局部线性模型\n$$\nx^{\\star}_S(\\lambda) = x^{\\star}_S(\\lambda_0) + (\\lambda - \\lambda_0)\\,\\dot{x}_S(\\lambda_0)\n$$\n来预测第一个参数值 $\\lambda_{\\text{flip}}  \\lambda_0$，在该值处，当前激活的坐标之一达到零（因此预测在 $\\lambda$ 进一步减小时会发生符号翻转），假设在该事件发生前没有其他支撑集变化。\n\n将由此构造产生的 $\\lambda_{\\text{flip}}$ 的精确值作为你的最终答案。将最终答案表示为精确分数。不要包含任何单位。", "solution": "我们从凸最优性条件开始。目标函数是\n$$\nf(x,\\lambda) = \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1.\n$$\n$\\ell_1$-范数的次微分是\n$$\n\\partial \\|x\\|_1 = \\{ z \\in \\mathbb{R}^p \\;:\\; z_i = \\operatorname{sign}(x_i) \\text{ if } x_i \\ne 0,\\; \\text{and}\\; z_i \\in [-1,1] \\text{ if } x_i = 0 \\}.\n$$\n最优性的 Karush–Kuhn–Tucker (KKT) 平稳性条件是\n$$\n0 \\in \\nabla_x \\left( \\tfrac{1}{2}\\|A x - b\\|_2^2 \\right) + \\lambda \\,\\partial \\|x\\|_1 = A^{\\top}(A x - b) + \\lambda \\,\\partial \\|x\\|_1.\n$$\n假设存在一个 $\\lambda$ 的区间，在该区间上激活集 $S$ 和 $S$ 上的符号保持不变，且 $x_{S^c}(\\lambda) = 0$。令该区间上的 $s_S := \\operatorname{sign}(x_S(\\lambda))$。那么限制在 $S$ 上的平稳性条件就是等式\n$$\nA_S^{\\top}(A_S x_S - b) + \\lambda \\, s_S = 0,\n$$\n因为在 $S$ 上我们有确定的次梯度 $z_S = s_S$。重新整理，\n$$\nA_S^{\\top} A_S \\, x_S - A_S^{\\top} b + \\lambda \\, s_S = 0.\n$$\n假设 $A_S^{\\top} A_S$ 是可逆的（在 $S$ 上是列满秩的），我们可以在 $S$ 和 $s_S$ 固定的区间上对等式两边关于 $\\lambda$ 求导。利用 $A_S^{\\top} A_S$ 和 $A_S^{\\top} b$ 关于 $\\lambda$ 是常数，以及 $s_S$ 在此区间上是常数的事实，我们得到\n$$\nA_S^{\\top} A_S \\, \\dot{x}_S(\\lambda) + s_S = 0.\n$$\n对激活集上的路径导数求解，得到显式表达式\n$$\n\\dot{x}_S(\\lambda) = -\\left(A_S^{\\top} A_S\\right)^{-1} \\, s_S.\n$$\n\n现在我们将该例子实例化。取 $p = m = 2$，$S = \\{1,2\\}$，且\n$$\nA = \\begin{pmatrix} \\sqrt{\\tfrac{1}{2}}  \\sqrt{2} \\\\ 0  \\sqrt{3} \\end{pmatrix}, \\qquad\n\\lambda_0 = 1, \\qquad\nx^{\\star}(\\lambda_0) = \\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix}, \\qquad\ns_S = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n在 $\\lambda_0$ 处，关于 $S$ 的 KKT 平稳性条件要求\n$$\nA^{\\top} A \\, x^{\\star}(\\lambda_0) - A^{\\top} b + \\lambda_0 \\, s_S = 0\n\\quad\\Longleftrightarrow\\quad\nA^{\\top} b = A^{\\top} A \\, x^{\\star}(\\lambda_0) + \\lambda_0 \\, s_S.\n$$\n计算 Gram 矩阵\n$$\nA^{\\top} A = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix}.\n$$\n因此\n$$\nA^{\\top} A \\, x^{\\star}(\\lambda_0) = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix}\n\\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix}\n= \\begin{pmatrix} 0.2 \\\\ 0.7 \\end{pmatrix},\n$$\n从而\n$$\nA^{\\top} b = \\begin{pmatrix} 0.2 \\\\ 0.7 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n= \\begin{pmatrix} 1.2 \\\\ 1.7 \\end{pmatrix}.\n$$\n由于 $A$ 是可逆的，我们可以选择\n$$\nb = \\left(A^{\\top}\\right)^{-1} \\begin{pmatrix} 1.2 \\\\ 1.7 \\end{pmatrix}.\n$$\n现在使用通用公式计算 $\\dot{x}_S(\\lambda_0)$。首先，求 Gram 矩阵的逆。对于\n$$\nG = A^{\\top} A = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix},\n$$\n其行列式为\n$$\n\\det(G) = \\frac{1}{2}\\cdot 5 - 1^2 = \\frac{5}{2} - 1 = \\frac{3}{2},\n$$\n其逆矩阵为\n$$\nG^{-1} = \\frac{1}{\\det(G)} \\begin{pmatrix} 5  -1 \\\\ -1  \\frac{1}{2} \\end{pmatrix}\n= \\frac{2}{3} \\begin{pmatrix} 5  -1 \\\\ -1  \\frac{1}{2} \\end{pmatrix}\n= \\begin{pmatrix} \\frac{10}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{1}{3} \\end{pmatrix}.\n$$\n因此，\n$$\n\\dot{x}_S(\\lambda_0) = -G^{-1} s_S = - \\begin{pmatrix} \\frac{10}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n= - \\begin{pmatrix} \\frac{8}{3} \\\\ -\\frac{1}{3} \\end{pmatrix}\n= \\begin{pmatrix} -\\frac{8}{3} \\\\ \\frac{1}{3} \\end{pmatrix}.\n$$\n这个导数预测，当 $\\lambda$ 从 $\\lambda_0$ 减小时，第一个坐标会增加（因为对于 $\\lambda  \\lambda_0$，我们有 $\\lambda - \\lambda_0  0$，且 $\\dot{x}_{1}(\\lambda_0)  0$），而第二个坐标会减小（因为 $\\dot{x}_{2}(\\lambda_0) > 0$），向零移动，并有可能在穿过零后翻转符号。\n\n在支撑集和符号固定的区间上使用局部线性路径模型：\n$$\nx_S(\\lambda) = x_S(\\lambda_0) + (\\lambda - \\lambda_0) \\,\\dot{x}_S(\\lambda_0).\n$$\n第二个坐标在第一个满足以下条件的 $\\lambda  \\lambda_0$ 处达到零：\n$$\n0 = x_2(\\lambda) = 0.1 + (\\lambda - 1)\\cdot \\frac{1}{3}.\n$$\n对 $\\lambda$ 求解可得\n$$\n(\\lambda - 1)\\cdot \\frac{1}{3} = -0.1\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda - 1 = -0.3\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda = 0.7 = \\frac{7}{10}.\n$$\n没有更早的事件发生，因为随着 $\\lambda$ 的减小，第一个坐标会远离零。因此，局部模型预测在以下值处会发生即将到来的符号翻转：\n$$\n\\lambda_{\\text{flip}} = \\frac{7}{10}.\n$$\n这个值作为有理数是精确的。", "answer": "$$\\boxed{\\frac{7}{10}}$$", "id": "3451804"}, {"introduction": "掌握了路径的局部导数后，我们便可以将这些线性的路径片段拼接起来，从而追踪完整的LASSO解路径。这要求我们不仅能计算每个片段上的方向，还必须精确地识别出路径改变方向的“断点”，即系数进入或离开活动集的事件。本练习将指导你从头开始实现一个完整的同伦算法，这是深入理解$\\ell_1$路径追踪机制的核心实践 [@problem_id:3451768]。", "problem": "您的任务是为压缩感知和稀疏优化中的最小绝对收缩和选择算子（LASSO）问题构建并分析一条同伦路径。重点是显式地跟踪支撑集的变化，并验证 LASSO 解路径相对于正则化参数的分段线性特性。该路径应通过应用 Karush-Kuhn-Tucker (KKT) 条件和同伦方法（也称为带有 LASSO 修正的最小角回归）来追踪。\n\n考虑 LASSO 目标函数\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1,\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$\\lambda \\ge 0$ 是正则化参数。最优性的 KKT 条件表明\n$$\nA^\\top \\left(b - A x(\\lambda)\\right) \\in \\lambda \\, \\partial \\|x(\\lambda)\\|_1,\n$$\n这等价于\n$$\n\\begin{cases}\nA_i^\\top \\left(b - A x(\\lambda)\\right) = \\lambda \\, \\operatorname{sign}\\left(x_i(\\lambda)\\right),  \\text{若 } x_i(\\lambda) \\ne 0, \\\\\n\\left|A_i^\\top \\left(b - A x(\\lambda)\\right)\\right| \\le \\lambda,  \\text{若 } x_i(\\lambda) = 0,\n\\end{cases}\n$$\n对于每个索引 $i \\in \\{1,\\ldots,n\\}$。用于 $\\ell_1$ 路径的同伦方法从 $\\lambda_{\\max} = \\|A^\\top b\\|_\\infty$ 开始，此时 $x(\\lambda_{\\max}) = 0$，然后减小 $\\lambda$，在保持 KKT 条件的同时跟踪激活支撑集和符号的变化。在支撑集变化事件之间，解 $x(\\lambda)$ 随 $\\lambda$ 线性演化。\n\n您的程序必须：\n\n1. 构造能够引导出可预测且非平凡的 LASSO 路径的合成矩阵 $A$ 和向量 $b$，包括多个系数剔除（索引离开激活集）以及没有剔除的情况。\n\n2. 从 $\\lambda_{\\max} = \\|A^\\top b\\|_\\infty$ 开始，通过迭代追踪同伦路径：\n   - 当一个非激活相关性达到 $\\pm \\lambda$ 时，将条目选入激活集。\n   - 计算保持激活集上等相关性的等角下降方向。\n   - 当一个激活系数达到零时，检测并应用剔除。\n   - 在事件之间，沿着所选方向线性更新 $x(\\lambda)$ 和 $\\lambda$。\n   - 在每个断点处强制执行 KKT 条件。\n\n3. 预测并输出支撑集变化的确切序列，作为路径上的事件列表，编码为整数对 $[e,i]$，其中 $e=1$ 表示索引 $i$ 进入激活集，$e=-1$ 表示索引 $i$ 从激活集中剔除。索引必须使用基于1的索引报告。\n\n4. 对于每个连续支撑集变化事件之间的分段，验证：\n   - 通过检查 $A^\\top(b - A x(\\lambda))$ 与 $\\lambda \\, \\partial \\|x\\|_1$ 的关系，验证分段端点处的 KKT 可行性。\n   - 通过确认 $x(\\lambda)$ 相对于 $\\lambda$ 的每段斜率是恒定的并且与计算出的等角方向匹配，来验证分段线性。\n\n所有计算都是纯数学和无量纲的；没有物理单位。不涉及角度。\n\n测试套件：\n提供三个涵盖不同行为的测试用例：\n- 用例 1（多次剔除）：$m = 4$，$n = 5$，$A$ 的列通过规范基 $\\{e_1,e_2,e_3,e_4\\}$ 的组合定义，然后归一化为单位 $\\ell_2$ 范数。列的定义如下：\n  $$\n  \\begin{aligned}\n  a_1 = e_1 \\\\\n  a_2 = 0.98\\, e_1 + 0.20\\, e_2 \\\\\n  a_3 = -0.95\\, e_1 + 0.30\\, e_3 \\\\\n  a_4 = 0.60\\, e_2 + 0.20\\, e_3 \\\\\n  a_5 = 0.60\\, e_3 + 0.20\\, e_1\n  \\end{aligned}\n  $$\n  而 $b = 1.00\\, e_1 + 0.45\\, e_2 - 0.50\\, e_3 + 0.05\\, e_4$。\n  在对 $A$ 进行列归一化后，追踪 LASSO 路径。此用例旨在展示由于正相关和负相关预测变量相互竞争而导致的多次剔除。\n\n- 用例 2（无剔除，正交设计）：$m = 5$，$n = 5$，$A = I_5$ 且\n  $$\n  b = \\begin{bmatrix} 1.0 \\\\ 0.8 \\\\ 0.6 \\\\ 0.4 \\\\ 0.2 \\end{bmatrix}.\n  $$\n  该路径应为软阈值，具有单调的条目且无剔除。\n\n- 用例 3（近共线性预测变量）：$m = 6$，$n = 6$，列由 $\\{e_1,\\ldots,e_6\\}$ 构造并归一化：\n  $$\n  \\begin{aligned}\n  a_1 = e_1 \\\\\n  a_2 = 0.99\\, e_1 + 0.10\\, e_2 \\\\\n  a_3 = 0.99\\, e_1 - 0.10\\, e_2 \\\\\n  a_4 = e_2 \\\\\n  a_5 = e_3 \\\\\n  a_6 = 0.50\\, e_3 + 0.40\\, e_4\n  \\end{aligned}\n  $$\n  而 $b = 1.00\\, e_1 + 0.70\\, e_2 + 0.25\\, e_3 - 0.20\\, e_4 + 0.10\\, e_6$。\n\n要求的输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个测试用例的结果必须是包含以下三个组件的列表：\n- 支撑集变化事件列表，表示为整数对 $[e,i]$，其中 $e \\in \\{1,-1\\}$，$i$ 是基于1的索引。\n- 一个布尔值，指示所有在断点处的 KKT 检查是否成功。\n- 一个布尔值，指示所有每段的分段线性检查是否成功。\n\n例如，整体输出应如下所示：\n$$\n[\\,[\\,[e_1,i_1],\\ldots,[e_k,i_k]\\, ,\\, \\text{True}\\, ,\\, \\text{True}\\, ]\\, ,\\, \\ldots\\, ].\n$$\n您的程序必须从头开始实现同伦追踪和验证，并以指定的格式生成确切的单行输出。", "solution": "用户提供了一个有效的问题陈述。任务是为 LASSO 优化问题实现同伦方法，将解路径追踪为正则化参数 $\\lambda$ 的函数，识别支撑集的变化（系数的进入和剔除），并根据 Karush-Kuhn-Tucker (KKT) 条件及其分段线性性质验证路径的正确性。\n\nLASSO 问题定义为：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1\n$$\n解 $x(\\lambda)$ 随着 $\\lambda$ 的变化描绘出一条分段线性路径。同伦方法，也称为 LARS-LASSO 算法，提供了一种计算这整个路径的方法。我们从一个大的 $\\lambda$ 开始，此时解为 $x=0$，然后逐渐减小 $\\lambda$，跟踪非零系数激活集的变化。\n\n算法流程如下：\n\n**1. 初始化**\n路径始于 $\\lambda = \\lambda_{\\max}$，此时解是平凡的，$x(\\lambda_{\\max}) = 0$。此时，残差为 $r = b - A x = b$。KKT 条件要求对于所有 $i$，有 $|A_i^\\top(b-Ax)| \\le \\lambda$。为了找到可能首次出现非零解的最大 $\\lambda$，我们找到该不等式对至少一个索引变为等式的点。这发生在：\n$$\n\\lambda_{\\max} = \\|A^\\top b\\|_{\\infty}\n$$\n令 $j_0$ 是一个索引，使得 $|A_{j_0}^\\top b| = \\lambda_{\\max}$。该索引是第一个进入激活集 $\\mathcal{A}$ 的索引。\n- 初始解：$x_0 = 0 \\in \\mathbb{R}^n$。\n- 初始 $\\lambda$：$\\lambda_0 = \\lambda_{\\max}$。\n- 初始激活集：$\\mathcal{A} = \\{j_0\\}$。\n- 初始符号：$s_{\\mathcal{A}} = [\\operatorname{sign}((A^\\top b)_{j_0})]$。\n\n**2. 路径分段构造**\n在两个连续事件（激活集的变化）之间，解 $x(\\lambda)$ 是 $\\lambda$ 的线性函数。对于给定的激活集 $\\mathcal{A}$ 和相应的符号 $s_{\\mathcal{A}}$，激活的 KKT 条件是：\n$$\nA_{\\mathcal{A}}^\\top (b - A x(\\lambda)) = \\lambda s_{\\mathcal{A}}\n$$\n其中 $A_{\\mathcal{A}}$ 是 $A$ 中包含由 $\\mathcal{A}$ 索引的列的子矩阵，对于 $i \\notin \\mathcal{A}$，$x_i(\\lambda) = 0$。这可以简化为：\n$$\nA_{\\mathcal{A}}^\\top (b - A_{\\mathcal{A}} x_{\\mathcal{A}}(\\lambda)) = \\lambda s_{\\mathcal{A}}\n$$\n对 $\\lambda$ 求导，我们得到激活系数的路径方向：\n$$\n-A_{\\mathcal{A}}^\\top A_{\\mathcal{A}} \\frac{dx_{\\mathcal{A}}}{d\\lambda} = s_{\\mathcal{A}}\n$$\n求解导数，它代表了路径分段的斜率：\n$$\n\\frac{dx_{\\mathcal{A}}}{d\\lambda} = -(A_{\\mathcal{A}}^\\top A_{\\mathcal{A}})^{-1} s_{\\mathcal{A}}\n$$\n让我们将路径更新方向定义为 $w_{\\mathcal{A}} = (A_{\\mathcal{A}}^\\top A_{\\mathcal{A}})^{-1} s_{\\mathcal{A}}$。完整的方向向量 $w \\in \\mathbb{R}^n$ 仅在 $\\mathcal{A}$ 中的索引处有非零项。当我们从当前值 $\\lambda_{\\text{curr}}$ 减小 $\\lambda$ 一个量 $\\delta_{\\lambda}  0$ 时，解更新为：\n$$\nx_{\\text{new}} = x_{\\text{curr}} + \\delta_{\\lambda} w\n$$\n新的 $\\lambda$ 将是 $\\lambda_{\\text{new}} = \\lambda_{\\text{curr}} - \\delta_{\\lambda}$。\n\n**3. 事件检测**\n路径分段的线性演化在激活集必须改变之前是有效的。这是一个“事件”。我们必须找到触发此类事件的最小步长 $\\delta_{\\lambda}  0$。有两种类型的事件：\n\n- **进入事件**：对于 $j \\notin \\mathcal{A}$ 的一个系数 $x_j$ 变为非零。这发生在其对应的相关性 $c_j = A_j^\\top(b - Ax)$ 达到边界 $\\pm\\lambda$ 时。相关性演化为 $c_j(\\lambda_{\\text{new}}) = c_j(\\lambda_{\\text{curr}}) - \\delta_{\\lambda} A_j^\\top A w$。我们需要找到满足 $|c_j(\\lambda_{\\text{curr}}) - \\delta_{\\lambda} A_j^\\top A w| = \\lambda_{\\text{curr}} - \\delta_{\\lambda}$ 的最小正 $\\delta_{\\lambda}$，对于某个 $j \\notin \\mathcal{A}$。这导致每个非激活索引 $j$ 对应两个关于 $\\delta_{\\lambda}$ 的线性方程：\n    $$\n    \\delta_{\\lambda} = \\frac{\\lambda_{\\text{curr}} - c_j(\\lambda_{\\text{curr}})}{1 - A_j^\\top A w} \\quad \\text{和} \\quad \\delta_{\\lambda} = \\frac{\\lambda_{\\text{curr}} + c_j(\\lambda_{\\text{curr}})}{1 + A_j^\\top A w}\n    $$\n    我们考虑在所有 $j \\notin \\mathcal{A}$ 中找到的最小正 $\\delta_{\\lambda}$。\n\n- **剔除事件**：对于 $k \\in \\mathcal{A}$ 的一个激活系数 $x_k(\\lambda)$ 穿过零。LARS 的 LASSO 修正要求将这样的系数从激活集中移除。这发生在 $x_k(\\lambda_{\\text{new}}) = x_k(\\lambda_{\\text{curr}}) + \\delta_{\\lambda} w_k = 0$ 时。这给出了步长：\n    $$\n    \\delta_{\\lambda} = -x_k(\\lambda_{\\text{curr}}) / w_k\n    $$\n    仅当 $\\delta_{\\lambda}  0$ 时，这才是未来事件的候选，这发生在 $x_k$ 和 $w_k$ 符号相反时。我们在所有 $k \\in \\mathcal{A}$ 中找到最小的正 $\\delta_{\\lambda}$。\n\n下一个事件发生在 $\\delta_{\\lambda} = \\min(\\delta_{\\lambda, \\text{entry}}, \\delta_{\\lambda, \\text{dropout}})$。\n\n**4. 迭代和验证**\n算法迭代地计算方向 $w$，找到最小步长 $\\delta_{\\lambda}$，更新状态 $(x, \\lambda)$，并根据事件类型修改激活集 $\\mathcal{A}$ 和符号 $s_{\\mathcal{A}}$。这个过程持续进行，直到 $\\lambda$ 达到零或满足其他终止条件。\n\n在每个断点（即每一步之后），我们执行两项验证：\n- **KKT 验证**：我们检查 KKT 条件是否在新点 $(x_{\\text{new}}, \\lambda_{\\text{new}})$ 对*新*激活集成立。即，对于激活索引 $i$，有 $|A_i^\\top(b-Ax_{\\text{new}})| = \\lambda_{\\text{new}}$；对于非激活索引 $j$，有 $|A_j^\\top(b-Ax_{\\text{new}})| \\le \\lambda_{\\text{new}}$。\n- **分段线性 (PWL) 验证**：我们确认分段上 $x$ 的变化与计算出的路径方向一致。经验斜率为 $(\\Delta x) / (\\Delta \\lambda) = (x_{\\text{new}} - x_{\\text{curr}}) / (\\lambda_{\\text{new}} - \\lambda_{\\text{curr}})$。这必须与理论斜率 $dx/d\\lambda = -w$ 相匹配。\n\n实现将使用一个小的容差 $\\epsilon$ 来处理数值精度比较。测试用例旨在检验算法的不同方面，包括剔除（用例1）、简单的单调路径（用例2）和近共线性（用例3）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the LASSO path algorithm.\n    It formats and prints the results as specified.\n    \"\"\"\n    \n    TOL = 1e-9\n\n    def format_result(result_list):\n        \"\"\"Custom formatter to match the output string format [item1,item2,...].\"\"\"\n        events_str = '[' + ','.join([f'[{e},{i}]' for e, i in result_list[0]]) + ']'\n        kkt_str = 'True' if result_list[1] else 'False'\n        pwl_str = 'True' if result_list[2] else 'False'\n        return f\"[[{','.join(f'[{e},{i}]' for e, i in result_list[0])}],{kkt_str},{pwl_str}]\"\n    \n    # Case 1: Multiple dropouts\n    m1, n1 = 4, 5\n    A1_unnormalized = np.zeros((m1, n1))\n    e = np.eye(m1)\n    A1_unnormalized[:, 0] = e[:, 0]\n    A1_unnormalized[:, 1] = 0.98 * e[:, 0] + 0.20 * e[:, 1]\n    A1_unnormalized[:, 2] = -0.95 * e[:, 0] + 0.30 * e[:, 2]\n    A1_unnormalized[:, 3] = 0.60 * e[:, 1] + 0.20 * e[:, 2]\n    A1_unnormalized[:, 4] = 0.60 * e[:, 2] + 0.20 * e[:, 0]\n    b1 = 1.00 * e[:, 0] + 0.45 * e[:, 1] - 0.50 * e[:, 2] + 0.05 * e[:, 3]\n    \n    # Case 2: Orthonormal design\n    m2, n2 = 5, 5\n    A2_unnormalized = np.eye(m2)\n    b2 = np.array([1.0, 0.8, 0.6, 0.4, 0.2])\n\n    # Case 3: Near-collinear predictors\n    m3, n3 = 6, 6\n    A3_unnormalized = np.zeros((m3, n3))\n    e = np.eye(m3)\n    A3_unnormalized[:, 0] = e[:, 0]\n    A3_unnormalized[:, 1] = 0.99 * e[:, 0] + 0.10 * e[:, 1]\n    A3_unnormalized[:, 2] = 0.99 * e[:, 0] - 0.10 * e[:, 1]\n    A3_unnormalized[:, 3] = e[:, 1]\n    A3_unnormalized[:, 4] = e[:, 2]\n    A3_unnormalized[:, 5] = 0.50 * e[:, 2] + 0.40 * e[:, 3]\n    b3 = 1.00 * e[:, 0] + 0.70 * e[:, 1] + 0.25 * e[:, 2] - 0.20 * e[:, 3] + 0.10 * e[:, 5]\n\n    test_cases = [\n        (A1_unnormalized, b1, TOL),\n        (A2_unnormalized, b2, TOL),\n        (A3_unnormalized, b3, TOL)\n    ]\n    \n    final_results = []\n    for A_un, b, tol in test_cases:\n        # Normalize columns of A\n        A = A_un.copy()\n        norms = np.linalg.norm(A, axis=0)\n        non_zero_norms = norms > tol\n        A[:, non_zero_norms] /= norms[non_zero_norms]\n        \n        res = run_lasso_path(A, b, tol)\n        final_results.append(format_result(res))\n    \n    print(f\"[{','.join(final_results)}]\")\n\ndef run_lasso_path(A, b, tol):\n    \"\"\"\n    Implements the homotopy (LARS-LASSO) algorithm to trace the LASSO solution path.\n    \"\"\"\n    m, n = A.shape\n    x = np.zeros(n)\n    events = []\n    kkt_ok = True\n    pwl_ok = True\n\n    c = A.T @ (b - A @ x)\n    lam = np.max(np.abs(c))\n    \n    full_indices = np.arange(n)\n    active_set = {np.argmax(np.abs(c))}\n    \n    events.append([1, list(active_set)[0] + 1])\n\n    while lam > tol and len(active_set) > 0 and len(active_set) = m:\n        active_indices = sorted(list(active_set))\n        inactive_indices = np.setdiff1d(full_indices, active_indices)\n\n        x_old = x.copy()\n        lam_old = lam\n\n        c = A.T @ (b - A @ x)\n        signs = np.sign(c[active_indices])\n        \n        zero_sign_mask = np.abs(signs)  tol\n        if np.any(zero_sign_mask):\n             signs[zero_sign_mask] = 1.0\n\n        A_active = A[:, active_indices]\n        try:\n            G_active = A_active.T @ A_active\n            w_active = np.linalg.solve(G_active, signs)\n        except np.linalg.LinAlgError:\n            kkt_ok = False\n            break\n        \n        w = np.zeros(n)\n        w[active_indices] = w_active\n        \n        delta_lam = lam\n        delta_lam_entry = delta_lam\n        entry_candidates = []\n        if len(inactive_indices) > 0:\n            a_corr = A.T @ (A @ w)\n            for j in inactive_indices:\n                if abs(1 - a_corr[j]) > tol:\n                    d1 = (lam - c[j]) / (1 - a_corr[j])\n                    if d1 > tol: entry_candidates.append(d1)\n                if abs(1 + a_corr[j]) > tol:\n                    d2 = (lam + c[j]) / (1 + a_corr[j])\n                    if d2 > tol: entry_candidates.append(d2)\n            if entry_candidates:\n                delta_lam_entry = min(entry_candidates)\n        \n        delta_lam_dropout = delta_lam\n        dropout_candidates = []\n        for i, k in enumerate(active_indices):\n            if abs(w[k]) > tol:\n                d = -x[k] / w[k]\n                if d > tol:\n                    dropout_candidates.append(d)\n        if dropout_candidates:\n            delta_lam_dropout = min(dropout_candidates)\n\n        delta_lam = min(delta_lam_entry, delta_lam_dropout)\n        \n        if delta_lam >= lam or delta_lam  tol:\n            delta_lam = lam\n        \n        lam -= delta_lam\n        x += delta_lam * w\n        x[np.abs(x)  tol] = 0.0\n        \n        if lam_old - lam > tol:\n            slope_empirical = (x - x_old) / (lam - lam_old)\n            slope_theoretical = -w\n            if not np.allclose(slope_empirical, slope_theoretical, atol=tol*10):\n                 pwl_ok = False\n        \n        c_new = A.T @ (b - A @ x)\n        is_entry = delta_lam_entry = delta_lam_dropout + tol\n        is_dropout = delta_lam_dropout = delta_lam_entry + tol\n        \n        next_active_set = active_set.copy()\n        newly_added = set()\n        if is_entry:\n            a_corr = A.T @ (A @ w)\n            for j in inactive_indices:\n                if abs(1 - a_corr[j]) > tol and abs((lam_old - c[j]) / (1 - a_corr[j]) - delta_lam)  tol:\n                    newly_added.add(j)\n                if abs(1 + a_corr[j]) > tol and abs((lam_old + c[j]) / (1 + a_corr[j]) - delta_lam)  tol:\n                    newly_added.add(j)\n            next_active_set.update(newly_added)\n\n        newly_removed = set()\n        if is_dropout:\n            for k in active_indices:\n                if abs(w[k]) > tol and abs(-x_old[k] / w[k] - delta_lam)  tol:\n                    newly_removed.add(k)\n            next_active_set.difference_update(newly_removed)\n        \n        next_active_indices = sorted(list(next_active_set))\n        if next_active_indices:\n            if not np.allclose(np.abs(c_new[next_active_indices]), lam, atol=tol*10): kkt_ok = False\n        \n        for k in range(n):\n            if k not in next_active_set and abs(c_new[k]) > lam + tol * 10: kkt_ok = False\n        if not kkt_ok: break\n\n        for j in sorted(list(newly_added)): events.append([1, j + 1])\n        for j in sorted(list(newly_removed)): events.append([-1, j + 1])\n        \n        active_set = next_active_set\n        \n        if lam  tol: break\n\n    return [events, kkt_ok, pwl_ok]\n\nsolve()\n```", "id": "3451768"}, {"introduction": "在静态数据上构建和分析LASSO路径是基础，但在许多现实应用中，数据是动态变化的。本练习将我们带入一个更高级的“流式”数据场景，其中新的观测数据会不断加入。你的任务是探索如何在不完全重启计算的情况下，利用KKT条件和矩阵更新原理来高效地更新解路径，这突显了同伦方法框架的分析威力与灵活性 [@problem_id:3451784]。", "problem": "考虑通过最小化以下目标函数定义的最小绝对收缩和选择算子 (LASSO) 路径\n$$\\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\lambda \\|x\\|_{1},$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$x \\in \\mathbb{R}^{n}$，且 $\\lambda \\geq 0$。该路径通过减小 $\\lambda$ 并维持 Karush–Kuhn–Tucker (KKT) 条件来追踪。在一个活动集 $S \\subset \\{1,\\dots,n\\}$ 和相关符号向量 $s \\in \\mathbb{R}^{|S|}$ 固定的路径段上，KKT 条件意味着 $x_{S^{c}}(\\lambda)=0$，驻点性条件 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$，以及对偶可行性条件 $|A_{j}^{\\top}(A x(\\lambda) - b)| \\leq \\lambda$ 对每个非活动索引 $j \\in S^{c}$ 成立。\n\n对于以下数据，您当前处于一个活动集为 $S = \\{1\\}$ 且固定符号为 $s_{1} = +1$ 的路径段上\n$$A = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0\n\\end{pmatrix}, \\qquad b = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}.$$\n在没有流式更新的情况下，此路径段上的下一个断点由非活动索引 $j^{\\star} = 2$ 在其对偶约束达到等式时变为活动状态所决定。\n\n现在假设一个流式更新附加了一个新行 $a^{\\top} \\in \\mathbb{R}^{n}$ 和一个新条目 $b_{\\mathrm{new}} \\in \\mathbb{R}$：\n$$a^{\\top} = \\begin{pmatrix} 1  0.25  0 \\end{pmatrix}, \\qquad b_{\\mathrm{new}} = 1.2,$$\n因此更新后的系统为\n$$A' = \\begin{pmatrix}\nA \\\\\na^{\\top}\n\\end{pmatrix}, \\qquad b' = \\begin{pmatrix}\nb \\\\\nb_{\\mathrm{new}}\n\\end{pmatrix}.$$\n仅使用基本的 KKT 条件和秩一矩阵逆更新原理，推导更新后的主变量 $x_{S}(\\lambda)$ 的公式，而无需重新启动同伦过程，并表示在流式更新下非活动索引 $j^{\\star} = 2$ 的非活动相关性。然后，确定旧的下一个断点 $\\lambda_{\\mathrm{old}}$ 和新的下一个断点 $\\lambda_{\\mathrm{new}}$，在这两个断点处，非活动索引 $j^{\\star} = 2$ 分别达到 $|A_{2}^{\\top}(A x(\\lambda) - b)| = \\lambda$ 和 $|A'_{2}{}^{\\top}(A' x(\\lambda) - b')| = \\lambda$，同时活动集保持为 $S = \\{1\\}$ 且 $s_{1} = +1$ 直到这些断点。\n\n最后，计算扰动\n$$\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}},$$\n并以最简分数形式给出其精确值。不要四舍五入。", "solution": "首先验证问题，以确保其科学上可靠、适定且客观。\n\n### 步骤 1：提取已知条件\n- **目标函数**：$\\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\lambda \\|x\\|_{1}$\n- **数据矩阵和向量**：$A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$x \\in \\mathbb{R}^{n}$，$\\lambda \\geq 0$。\n- **KKT 条件**：\n    1. 主可行性：由解路径满足。\n    2. 次梯度/驻点性：对于活动集 $S$ 及其符号向量 $s \\in \\mathbb{R}^{|S|}$，$x_{S^{c}}(\\lambda)=0$ 且 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$。\n    3. 对偶可行性：对于每个非活动索引 $j \\in S^{c}$，有 $|A_{j}^{\\top}(A x(\\lambda) - b)| \\leq \\lambda$。\n- **初始数据**：\n    - $A = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\end{pmatrix}$\n    - $b = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$\n- **路径段**：\n    - 活动集 $S = \\{1\\}$。\n    - 符号向量 $s = s_{1} = +1$。\n    - 下一个断点由非活动索引 $j^{\\star} = 2$ 决定。\n- **流式更新**：\n    - 新行：$a^{\\top} = \\begin{pmatrix} 1  0.25  0 \\end{pmatrix}$\n    - 新条目：$b_{\\mathrm{new}} = 1.2$\n- **更新后的系统**：\n    - $A' = \\begin{pmatrix} A \\\\ a^{\\top} \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 1  0.25  0 \\end{pmatrix}$\n    - $b' = \\begin{pmatrix} b \\\\ b_{\\mathrm{new}} \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix}$\n- **任务**：\n    1. 推导当 $S=\\{1\\}$ 时，路径段上更新后的主解 $x_{S}(\\lambda)$ 的公式。\n    2. 表示在流式更新下非活动索引 $j^{\\star} = 2$ 的非活动相关性。\n    3. 确定旧断点 $\\lambda_{\\mathrm{old}}$ 和新断点 $\\lambda_{\\mathrm{new}}$。\n    4. 计算扰动 $\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}}$ 并表示为最简分数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题设定在稀疏优化和压缩感知的标准数学框架内，特别涉及求解 LASSO 的同伦方法。所有术语（$A$、$b$、$\\lambda$、KKT 条件、活动集、断点）在该领域都是明确定义和标准的。所提供的数据是完整和一致的，可以计算出唯一的解路径。该任务是将这些原理直接应用于一个涉及流式数据更新的具体数值示例，这是现代数据分析中的一个相关主题。该问题不违反任何科学原理，没有歧义，并且是可形式化的。\n\n### 步骤 3：结论与行动\n问题有效。我们继续进行求解。\n\n#### 原始系统分析（更新前）\n\n我们首先分析流式更新前的系统。活动集为 $S=\\{1\\}$，活动系数的符号为 $s_{1}=+1$。解向量的形式为 $x(\\lambda) = (x_1(\\lambda), 0, 0)^{\\top}$。KKT 驻点性条件由 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$ 给出。\n\n这里，$A_S = A_1$（$A$ 的第一列），即 $A_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。条件变为：\n$$A_{1}^{\\top}(A_1 x_1(\\lambda) - b) + \\lambda s_1 = 0$$\n我们计算各项：\n$A_1^{\\top} A_1 = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 1$\n$A_1^{\\top} b = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = 2$\n将这些代入驻点性方程：\n$(1) x_1(\\lambda) - 2 + \\lambda (1) = 0$\n这给出了活动系数的主路径：\n$$x_1(\\lambda) = 2 - \\lambda$$\n下一个断点 $\\lambda_{\\mathrm{old}}$ 发生在某个非活动索引 $j \\in S^c = \\{2, 3\\}$ 首次以等式满足对偶可行性条件时：$|A_{j}^{\\top}(A x(\\lambda) - b)| = \\lambda$。问题指明该索引为 $j^{\\star} = 2$。\n残差为 $r(\\lambda) = A x(\\lambda) - b = A_1 x_1(\\lambda) - b = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} (2 - \\lambda) - \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2 - \\lambda - 2 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} -\\lambda \\\\ -1 \\end{pmatrix}$。\n对于非活动索引 $j^{\\star}=2$ 的相关性为 $c_2(\\lambda) = A_2^{\\top} r(\\lambda)$。其中 $A_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$：\n$c_2(\\lambda) = \\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} -\\lambda \\\\ -1 \\end{pmatrix} = -1$\n断点条件为 $|c_2(\\lambda)| = \\lambda$，即 $|-1| = \\lambda$。\n因此，旧断点为 $\\lambda_{\\mathrm{old}} = 1$。\n\n#### 更新后系统分析\n\n流式更新后，我们得到由 $A'$ 和 $b'$ 定义的新系统。假设在新的路径段上，活动集 $S=\\{1\\}$ 和符号 $s_1=+1$ 保持不变。设新的主路径为 $x'(\\lambda) = (x'_1(\\lambda), 0, 0)^{\\top}$。\n更新后系统的 KKT 驻点性条件是 $A'_{S}{}^{\\top}(A' x'(\\lambda) - b') + \\lambda s = 0$。\n这里，$A'_S = A'_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$。我们计算新的格拉姆矩阵以及与 $b'$ 的相关性：\n$A'_{1}{}^{\\top} A'_{1} = \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = 1 + 0 + 1 = 2$。\n此更新对应于 $A_{S}^{\\top}A_{S} \\to A_{S}^{\\top}A_{S} + a_{S}a_{S}^{\\top}$，一个秩一更新。\n$A'_{1}{}^{\\top} b' = \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix} = 2 + 0 + 1.2 = 3.2$。\n\n驻点性方程变为：\n$(2) x'_1(\\lambda) - 3.2 + \\lambda(1) = 0$\n求解 $x'_1(\\lambda)$，我们得到更新后的主解的公式：\n$$x'_1(\\lambda) = \\frac{3.2 - \\lambda}{2} = 1.6 - 0.5\\lambda$$\n\n接下来，我们找到由非活动索引 $j^{\\star} = 2$ 确定的新断点 $\\lambda_{\\mathrm{new}}$。我们计算更新后的非活动相关性 $c'_2(\\lambda) = A'_{2}{}^{\\top}(A' x'(\\lambda) - b')$。\n新的残差是 $r'(\\lambda) = A' x'(\\lambda) - b' = A'_1 x'_1(\\lambda) - b'$。\n$r'(\\lambda) = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} (1.6 - 0.5\\lambda) - \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix} = \\begin{pmatrix} 1.6 - 0.5\\lambda - 2 \\\\ -1 \\\\ 1.6 - 0.5\\lambda - 1.2 \\end{pmatrix} = \\begin{pmatrix} -0.4 - 0.5\\lambda \\\\ -1 \\\\ 0.4 - 0.5\\lambda \\end{pmatrix}$。\n$A'$ 的第二列是 $A'_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0.25 \\end{pmatrix}$。\n更新后对于 $j^{\\star}=2$ 的非活动相关性为：\n$c'_2(\\lambda) = A'_{2}{}^{\\top} r'(\\lambda) = \\begin{pmatrix} 0  1  0.25 \\end{pmatrix} \\begin{pmatrix} -0.4 - 0.5\\lambda \\\\ -1 \\\\ 0.4 - 0.5\\lambda \\end{pmatrix}$\n$c'_2(\\lambda) = (0) + (-1) + 0.25(0.4 - 0.5\\lambda) = -1 + 0.1 - 0.125\\lambda$\n$$c'_2(\\lambda) = -0.9 - 0.125\\lambda$$\n通过求解 $|c'_2(\\lambda)| = \\lambda$ 来找到新断点 $\\lambda_{\\mathrm{new}}$：\n$|-0.9 - 0.125\\lambda| = \\lambda$\n由于 $\\lambda \\geq 0$，项 $-0.9 - 0.125\\lambda$ 总是负的。因此，我们可以写成：\n$0.9 + 0.125\\lambda = \\lambda$\n$0.9 = \\lambda - 0.125\\lambda = 0.875\\lambda$\n$\\lambda_{\\mathrm{new}} = \\frac{0.9}{0.875}$\n为了将其表示为最简分数，我们将小数转换为分数：$0.9 = \\frac{9}{10}$ 和 $0.875 = \\frac{875}{1000} = \\frac{7}{8}$。\n$\\lambda_{\\mathrm{new}} = \\frac{9/10}{7/8} = \\frac{9}{10} \\times \\frac{8}{7} = \\frac{72}{70} = \\frac{36}{35}$。\n\n#### 扰动计算\n\n最后，我们计算扰动 $\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}}$。\n$\\Delta = \\frac{36}{35} - 1 = \\frac{36}{35} - \\frac{35}{35} = \\frac{1}{35}$。", "answer": "$$\\boxed{\\frac{1}{35}}$$", "id": "3451784"}]}