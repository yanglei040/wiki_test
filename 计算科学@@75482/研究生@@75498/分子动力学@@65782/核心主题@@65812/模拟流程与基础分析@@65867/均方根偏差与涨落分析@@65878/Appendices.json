{"hands_on_practices": [{"introduction": "均方根偏差（Root-Mean-Square Deviation, RMSD）是衡量两种分子构象相似性的核心指标。然而，在计算 RMSD 之前，必须通过刚体运动（旋转和平移）将一个构象最佳地叠合到另一个之上。本练习将指导您从第一性原理出发，推导出计算质量加权坐标最佳叠合的数学过程，为理解结构比对算法奠定坚实的理论基础 [@problem_id:3443709]。", "problem": "考虑用于分子动力学中均方根偏差（RMSD）分析的，处于三维空间中的一个大分子的两种构象。这些构象由原子坐标集 $\\{x_{i}\\}_{i=1}^{N}$ 和 $\\{y_{i}\\}_{i=1}^{N}$ 表示，其中 $x_{i}, y_{i} \\in \\mathbb{R}^{3}$，原子质量 $\\{m_{i}\\}_{i=1}^{N}$ 严格为正。最优叠合定义为一种刚性运动，它包含一个旋转 $R \\in \\mathrm{SO}(3)$（3维特殊正交群，即满足 $R^{\\top}R = I$ 和 $\\det(R) = 1$）和一个平移 $t \\in \\mathbb{R}^{3}$，该运动能最小化质量加权平方偏差和\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}.\n$$\n从第一性原理（质量加权最小二乘目标的定义以及对 $R$ 的约束）出发，通过先对平移 $t$ 最小化 $J(R,t)$，然后用中心化坐标重新表达目标函数，来推导质量加权最优叠合，并识别出用于计算最优旋转 $R$ 的量。特别地，请给出以下各项的显式解析表达式：\n- $x$ 坐标的质量加权质心，\n- $y$ 坐标的质量加权质心，\n- 用于旋转计算的质量加权协方差矩阵（例如，通过奇异值分解（SVD）），\n- 以及用 $R$ 和质心表示的最优平移 $t^{\\star}$。\n\n您的最终答案必须是包含这四个量的单个闭式解析表达式。不需要进行数值计算。如果需要任何中间标量归一化，请用符号表示。最终答案中不要包含任何单位。", "solution": "用户提供的问题陈述具有科学依据、是良定的、客观且自洽的。这是计算结构生物学和分子动力学领域的一个标准推导，具体涉及两个分子结构的最优叠合。该问题基于多变量微积分和线性代数的既定数学原理。所有必要的数据和定义均已提供，不存在矛盾或歧义。因此，该问题被视为有效，并将提供解答。\n\n目标是找到最优旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $t \\in \\mathbb{R}^{3}$，以最小化两组原子坐标 $\\{x_{i}\\}_{i=1}^{N}$ 和 $\\{y_{i}\\}_{i=1}^{N}$ 之间的质量加权平方偏差和。目标函数由下式给出：\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}\n$$\n其中 $\\{m_{i}\\}_{i=1}^{N}$ 是严格为正的原子质量。\n\n最小化过程可分两步进行：首先对平移向量 $t$ 进行最小化，然后对旋转矩阵 $R$ 进行最小化。\n\n**步骤 1：对平移 $t$ 进行最小化**\n\n对于一个固定的旋转 $R$，最优平移 $t^{\\star}$ 可以通过将 $J(R,t)$ 关于 $t$ 的梯度设为零向量来找到。梯度 $\\nabla_{t} J$ 计算如下：\n$$\n\\nabla_{t} J(R,t) = \\nabla_{t} \\sum_{i=1}^{N} m_{i} (R x_{i} + t - y_{i})^{\\top}(R x_{i} + t - y_{i})\n$$\n使用恒等式 $\\nabla_{v} (u^{\\top}u) = 2 u^{\\top} \\nabla_{v}u$，并注意到 $\\nabla_{t}(R x_{i} + t - y_{i}) = I$（单位矩阵），我们得到：\n$$\n\\nabla_{t} J(R,t) = \\sum_{i=1}^{N} m_{i} \\cdot 2(R x_{i} + t - y_{i})^{\\top}\n$$\n将梯度（转置为列向量）设为零：\n$$\n\\sum_{i=1}^{N} 2 m_{i} (R x_{i} + t^{\\star} - y_{i}) = 0\n$$\n由于 $m_i > 0$，我们可以除以 $2$ 并重排求和项：\n$$\n\\sum_{i=1}^{N} m_{i} R x_{i} + \\sum_{i=1}^{N} m_{i} t^{\\star} - \\sum_{i=1}^{N} m_{i} y_{i} = 0\n$$\n$$\nR \\left(\\sum_{i=1}^{N} m_{i} x_{i}\\right) + t^{\\star} \\left(\\sum_{i=1}^{N} m_{i}\\right) - \\left(\\sum_{i=1}^{N} m_{i} y_{i}\\right) = 0\n$$\n为简化此表达式，我们定义总质量 $M$ 和两坐标集的质量加权质心。设总质量为 $M = \\sum_{k=1}^{N} m_{k}$。质量加权质心为：\n- $\\{x_{i}\\}$ 坐标的质心：$x_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} x_{i}$。\n- $\\{y_{i}\\}$ 坐标的质心：$y_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} y_{i}$。\n\n将这些定义代入关于 $t^{\\star}$ 的方程：\n$$\nR (M x_{c}) + M t^{\\star} - M y_{c} = 0\n$$\n由于 $M > 0$，我们可以除以 $M$ 得到：\n$$\nR x_{c} + t^{\\star} - y_{c} = 0\n$$\n这得出了用旋转 $R$ 和质心表示的最优平移 $t^{\\star}$ 的表达式：\n$$\nt^{\\star} = y_{c} - R x_{c}\n$$\n这是问题要求解的第四个量。前两个量是质心 $x_c$ 和 $y_c$ 的显式表达式。\n\n**步骤 2：重新表达目标函数并识别协方差矩阵**\n\n现在，我们将最优平移 $t^{\\star}$ 代回目标函数 $J(R,t)$，得到一个仅依赖于旋转 $R$ 的函数：\n$$\nJ(R) = J(R, t^{\\star}) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + (y_{c} - R x_{c}) - y_{i} \\right\\|^{2}\n$$\n重排范数内的各项：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| (R x_{i} - R x_{c}) - (y_{i} - y_{c}) \\right\\|^{2} = \\sum_{i=1}^{N} m_{i} \\left\\| R(x_{i} - x_{c}) - (y_{i} - y_{c}) \\right\\|^{2}\n$$\n我们引入中心化坐标：\n- $x'_{i} = x_{i} - x_{c}$\n- $y'_{i} = y_{i} - y_{c}$\n目标函数变为一个寻找能最佳对齐中心化坐标集的旋转的问题：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| R x'_{i} - y'_{i} \\right\\|^{2}\n$$\n展开平方范数：\n$$\n\\left\\| R x'_{i} - y'_{i} \\right\\|^{2} = (R x'_{i} - y'_{i})^{\\top}(R x'_{i} - y'_{i}) = (R x'_{i})^{\\top}(R x'_{i}) - 2(R x'_{i})^{\\top}y'_{i} + (y'_{i})^{\\top}y'_{i}\n$$\n由于 $R$ 是一个正交矩阵（$R^{\\top}R = I$），我们有 $(R x'_{i})^{\\top}(R x'_{i}) = (x'_{i})^{\\top}R^{\\top}R x'_{i} = (x'_{i})^{\\top}I x'_{i} = \\|x'_{i}\\|^{2}$。\n展开项为 $\\|x'_{i}\\|^{2} - 2(x'_{i})^{\\top}R^{\\top}y'_{i} + \\|y'_{i}\\|^{2}$。\n将此代回 $J(R)$ 的表达式中：\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} \\right) - 2 \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\n要最小化 $J(R)$，我们必须最大化依赖于 $R$ 的那一项。求和的第一部分 $\\sum_{i=1}^{N} m_{i} ( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} )$ 对于 $R$ 而言是常数。因此，最小化 $J(R)$ 等价于最大化量 $S(R)$：\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\n我们可以使用迹算子来表示这个和。对于任意标量 $a$，有 $a = \\mathrm{Tr}(a)$。\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( (x'_{i})^{\\top}R^{\\top}y'_{i} \\right)\n$$\n利用迹的循环性质 $\\mathrm{Tr}(ABC) = \\mathrm{Tr}(BCA)$：\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( R^{\\top}y'_{i}(x'_{i})^{\\top} \\right)\n$$\n根据迹算子的线性性质：\n$$\nS(R) = \\mathrm{Tr}\\left( R^{\\top} \\left( \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} \\right) \\right)\n$$\n这个表达式识别出了决定问题旋转部分的矩阵。这就是质量加权协方差矩阵 $C$：\n$$\nC = \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}\n$$\n因此，寻找最优旋转 $R$ 的问题被归结为最大化 $\\mathrm{Tr}(R^{\\top}C)$。这通常通过计算矩阵 $C$ 的奇异值分解（SVD）来解决。这个矩阵 $C$ 是问题要求解的第三个量。\n\n因此，所要求的四个量是：\n1.  $x$ 坐标的质量加权质心：$x_{c} = \\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}$。\n2.  $y$ 坐标的质量加权质心：$y_{c} = \\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}}$。\n3.  质量加权协方差矩阵：$C = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}$。\n4.  最优平移：$t^{\\star} = y_{c} - R x_{c}$。\n\n这些量在最终答案中被汇总到一个单一的解析表达式中。", "answer": "$$\n\\boxed{\n\\pmatrix{\n\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}  \n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}}  \n\\sum_{i=1}^{N} m_{i} \\left(y_{i} - \\frac{\\sum_{j=1}^{N} m_{j} y_{j}}{\\sum_{k=1}^{N} m_{k}}\\right)\\left(x_{i} - \\frac{\\sum_{l=1}^{N} m_{l} x_{l}}{\\sum_{k=1}^{N} m_{k}}\\right)^{\\top}  \n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}} - R\\left(\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}\\right)\n}\n}\n$$", "id": "3443709"}, {"introduction": "从理想的数学模型转向分子动力学模拟的实际应用，我们必须考虑周期性边界条件（Periodic Boundary Conditions, PBC）的影响。在模拟中，分子穿过模拟盒边界会导致坐标发生人为的跳跃，若不加处理，会严重扭曲 RMSD 和 RMSF 的计算结果。本练习将通过一个编程实践，展示如何识别并使用“最小镜像约定”（Minimal-Image Convention）来修正这些边界伪影，从而获得具有物理意义的构象偏差和涨落 [@problem_id:3443654]。", "problem": "您必须编写一个完整且可运行的程序，对于正交周期性盒子中原子的轨迹，通过比较朴素的包裹坐标与最小镜像校正的位移，量化周期性边界条件（PBC）对均方根偏差（RMSD）和均方根涨落（RMSF）的影响。程序必须是自包含的，并能为指定的测试套件生成所要求的数值结果，且输出格式需完全一致。\n\n需要使用的基本原理和定义：\n- 欧几里得几何：对于任意向量 $\\mathbf{a}\\in\\mathbb{R}^3$，其范数的平方为 $\\|\\mathbf{a}\\|^2 = a_x^2 + a_y^2 + a_z^2$ 且 $\\|\\mathbf{a}\\| = \\sqrt{\\|\\mathbf{a}\\|^2}$。\n- 时间平均：对于一个时间序列 $\\{x(t)\\}_{t=1}^T$，其平均值为 $\\overline{x} = \\frac{1}{T}\\sum_{t=1}^T x(t)$。\n- 正交盒子中的周期性边界条件（PBC）：盒子长度由 $\\mathbf{L} = (L_x, L_y, L_z)$ 给出，并且在每个笛卡尔分量 $\\alpha\\in\\{x,y,z\\}$ 中，位置被包裹在区间 $[0,L_\\alpha)$ 内。\n- 最小镜像校正：对于每个原子 $i$ 在时间 $t$，逐分量选择 $\\mathbf{n}_{i}(t)\\in \\mathbb{Z}^3$，使得校正后的位移向量 $\\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t)\\circ \\mathbf{L}$ 具有最小欧几里得范数，其中 $\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$ 且 $\\circ$ 表示逐元素乘积。该选择必须在每个分量上独立进行，通过选择最接近 $\\Delta r_{i,\\alpha}(t)/L_\\alpha$ 的整数；当恰好在盒子一半处出现平局时（$\\Delta r_{i,\\alpha}(t)/L_\\alpha = \\pm \\tfrac{1}{2}$），必须向最近的偶数取整，以确保确定性行为。\n- 均方根偏差（RMSD）：对于 $N$ 个原子，在时间 $t$ 使用位移约定 $\\Delta\\mathbf{r}_i(t)$，定义 $R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2}$ 并报告其时间平均值 $\\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t)$。\n- 均方根涨落（RMSF）：对于每个原子 $i$，通过将位移加到参考坐标上来重构坐标 $\\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t)$，计算时间平均 $\\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t)$，并定义 $\\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2}$。报告所有原子的平均值 $\\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i$。\n- 必须比较两种位移约定：\n  1. 朴素包裹位移：$\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$。\n  2. 最小镜像校正位移：$\\Delta\\mathbf{r}_i^{MIC}(t)$ 如上构造。\n对于每个测试用例，计算并报告四个浮点数：$\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$、$\\overline{\\mathrm{F}}^{MIC}$。\n\n所有位置和盒子长度均以纳米为单位，所有输出也必须以纳米为单位报告，并四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 $1$（单个原子穿越边界）：\n  - 盒子：$\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=1$。\n  - 帧数：$T=4$。\n  - 参考位置：$\\mathbf{r}_1^{ref} = (\\,0.90,\\,0.00,\\,0.00\\,)$，单位 $\\mathrm{nm}$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$: $\\mathbf{r}_1(1) = (\\,0.90,\\,0.00,\\,0.00\\,)$，\n    $t=2$: $\\mathbf{r}_1(2) = (\\,0.95,\\,0.00,\\,0.00\\,)$，\n    $t=3$: $\\mathbf{r}_1(3) = (\\,0.98,\\,0.00,\\,0.00\\,)$，\n    $t=4$: $\\mathbf{r}_1(4) = (\\,0.02,\\,0.00,\\,0.00\\,)$。\n- 案例 $2$（三个原子在不同维度上穿越边界）：\n  - 盒子：$\\mathbf{L} = (\\,2.0,\\,1.0,\\,1.5\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=3$。\n  - 帧数：$T=3$。\n  - 参考位置（单位 $\\mathrm{nm}$）：\n    $\\mathbf{r}_1^{ref} = (\\,1.80,\\,0.20,\\,0.75\\,)$，\n    $\\mathbf{r}_2^{ref} = (\\,0.10,\\,0.90,\\,0.10\\,)$，\n    $\\mathbf{r}_3^{ref} = (\\,1.99,\\,0.05,\\,1.49\\,)$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,1.85,\\,0.22,\\,0.78\\,)$，\n      $\\mathbf{r}_2(1) = (\\,0.15,\\,0.92,\\,0.14\\,)$，\n      $\\mathbf{r}_3(1) = (\\,1.98,\\,0.06,\\,1.48\\,)$。\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.05,\\,0.22,\\,0.78\\,)$，\n      $\\mathbf{r}_2(2) = (\\,0.15,\\,0.02,\\,0.14\\,)$，\n      $\\mathbf{r}_3(2) = (\\,1.98,\\,0.06,\\,0.01\\,)$。\n    $t=3$:\n      $\\mathbf{r}_1(3) = (\\,0.10,\\,0.24,\\,0.77\\,)$，\n      $\\mathbf{r}_2(3) = (\\,0.18,\\,0.05,\\,0.08\\,)$，\n      $\\mathbf{r}_3(3) = (\\,0.02,\\,0.04,\\,0.02\\,)$。\n- 案例 $3$（分量上位移恰好为半个盒子长度的边界情况）：\n  - 盒子：$\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$，单位 $\\mathrm{nm}$。\n  - 原子数：$N=2$。\n  - 帧数：$T=2$。\n  - 参考位置（单位 $\\mathrm{nm}$）：\n    $\\mathbf{r}_1^{ref} = (\\,0.25,\\,0.25,\\,0.25\\,)$，\n    $\\mathbf{r}_2^{ref} = (\\,0.75,\\,0.75,\\,0.75\\,)$。\n  - 轨迹帧（包裹坐标，单位 $\\mathrm{nm}$）：\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,0.75,\\,0.25,\\,0.25\\,)$，\n      $\\mathbf{r}_2(1) = (\\,0.25,\\,0.75,\\,0.75\\,)$。\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.75,\\,0.75,\\,0.25\\,)$，\n      $\\mathbf{r}_2(2) = (\\,0.25,\\,0.25,\\,0.75\\,)$。\n\n程序要求：\n- 实现函数以精确计算 $\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$，完全按照上述描述，对最小镜像选择使用指定的平局打破规则（在每个笛卡尔分量上独立地，向最近的整数取整，平局时取偶数）。\n- 单位：输入以 $\\mathrm{nm}$ 为单位，输出也必须以 $\\mathrm{nm}$ 为单位。\n- 输出取整：将报告的每个浮点数四舍五入到 $6$ 位小数。\n- 最终输出格式：一行包含所有测试用例的结果列表，其中每个测试用例贡献一个包含四个浮点数的列表，顺序为 $[\\overline{R}^{wrap},\\overline{R}^{MIC},\\overline{\\mathrm{F}}^{wrap},\\overline{\\mathrm{F}}^{MIC}]$。总输出必须是这些列表组成的单个列表，并严格按照 Python 列表字面量的形式打印，例如 `[[a1, b1, c1, d1], [a2, b2, c2, d2], [a3, b3, c3, d3]]`。", "solution": "所提出的问题是分子动力学模拟分析领域一个定义明确的计算任务。它要求在两种不同的约定下，计算带有周期性边界条件（PBC）的体系中粒子位移的两个标准度量：均方根偏差（RMSD）和均方根涨落（RMSF）。该问题具有科学依据，内部一致，并为获得唯一、可验证的解提供了所有必要的数据和定义。因此，该问题被认为是有效的，并将构建一个解。\n\n问题的核心在于比较一种“朴素”计算（忽略粒子穿越周期性边界）和一种“校正”计算（使用最小镜像约定（MIC）来处理此类穿越）。我们的任务是量化 RMSD 和 RMSF 在这两种计算下的差异。让我们系统地定义所需的量，并概述计算过程。\n\n所有位置 $\\mathbf{r}$ 和盒子长度 $\\mathbf{L}$ 都是 $\\mathbb{R}^3$ 中的向量。给定一个包含 $N$ 个原子的集合、一个参考构型 $\\{\\mathbf{r}_i^{ref}\\}_{i=1}^N$ 以及一个包含 $T$ 个时间帧的轨迹 $\\{\\mathbf{r}_i(t)\\}_{i=1, t=1}^{N, T}$。\n\n**1. 位移约定**\n\n指定了两种计算位移向量 $\\Delta\\mathbf{r}_i(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$ 的方法。\n\n*   **朴素包裹位移 ($\\Delta\\mathbf{r}^{wrap}$):** 这是时间 $t$ 时的包裹坐标与参考坐标之间的简单向量差。\n    $$ \\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref} $$\n    如果一个原子穿过了周期性边界，这种计算可能会产生人为的巨大位移。\n\n*   **最小镜像校正位移 ($\\Delta\\mathbf{r}^{MIC}$):** 此约定通过寻找在时间 $t$ 时原子 $i$ 的周期性镜像中离其参考位置最近的一个来校正包裹位移。对于边长为 $\\mathbf{L}=(L_x, L_y, L_z)$ 的正交盒子，校正后的位移是：\n    $$ \\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t) \\circ \\mathbf{L} $$\n    其中 $\\circ$ 表示逐元素（哈达玛）乘积，而 $\\mathbf{n}_i(t)$ 是一个整数向量，其选择旨在最小化范数 $\\|\\Delta\\mathbf{r}_i^{MIC}(t)\\|$。这是通过独立地最小化每个分量来实现的。对于每个笛卡尔分量 $\\alpha \\in \\{x, y, z\\}$，我们必须选择一个整数 $n_{i, \\alpha}(t)$ 以使 $|\\Delta r_{i,\\alpha}^{wrap}(t) + n_{i, \\alpha}(t) L_{\\alpha}|$ 最小化。这等效于确保校正后的分量位于区间 $[-L_{\\alpha}/2, L_{\\alpha}/2]$ 内。整数 $n_{i, \\alpha}(t)$ 的计算方式如下：\n    $$ n_{i, \\alpha}(t) = -\\text{round}\\left(\\frac{\\Delta r_{i, \\alpha}^{wrap}(t)}{L_{\\alpha}}\\right) $$\n    问题为当缩放位移恰好为 $\\pm 0.5$ 时指定了平局打破规则：该值向最近的偶数取整。这确保了确定性行为。\n\n**2. 均方根偏差 (RMSD)**\n\nRMSD 测量给定构型中原子与参考构型中原子之间的平均距离。\n首先，对于每个时间帧 $t$，我们计算瞬时均方根距离 $R(t)$：\n$$ R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2} $$\n其中 $\\|\\cdot\\|$ 是欧几里得范数。最终报告的 RMSD, $\\overline{R}$，是 $R(t)$ 的时间平均值：\n$$ \\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t) $$\n我们将对两种位移约定都计算这个值，得到 $\\overline{R}^{wrap}$ 和 $\\overline{R}^{MIC}$。\n\n**3. 均方根涨落 (RMSF)**\n\nRMSF 测量每个原子在其轨迹上围绕其平均位置的涨落。\n首先，我们必须基于所选的位移约定重构一个连续（未包裹）的轨迹 $\\mathbf{u}_i(t)$：\n$$ \\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t) $$\n接下来，我们找到每个原子的时间平均位置 $\\overline{\\mathbf{u}}_i$：\n$$ \\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t) $$\n原子 $i$ 的 RMSF，$\\mathrm{RMSF}_i$，是其偏离该平均位置的偏差的均方根：\n$$ \\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2} $$\n最终报告的值 $\\overline{\\mathrm{F}}$ 是单个原子 RMSF 值在所有原子上的平均值：\n$$ \\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i $$\n我们将对两种位移约定都计算这个值，得到 $\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$。\n\n**算法实现**\n\n解法将使用 Python 和 `numpy` 库来实现，以进行高效的向量化操作。\n\n1.  对于每个测试用例，输入数据（盒子尺寸 $\\mathbf{L}$、参考位置 $\\mathbf{r}^{ref}$ 和轨迹位置 $\\mathbf{r}(t)$）被加载到 `numpy` 数组中。\n2.  包裹位移 $\\Delta\\mathbf{r}^{wrap}$ 被计算为一个 $T \\times N \\times 3$ 的数组。\n3.  使用一个实现 MIC 规则的函数来计算 MIC 位移 $\\Delta\\mathbf{r}^{MIC}$，同样是一个 $T \\times N \\times 3$ 的数组。`numpy.round` 自然地实现了指定的“四舍五入到最近的偶数”的平局打破规则。\n4.  实现独立的函数，根据给定的位移数组 ($T \\times N \\times 3$) 和参考位置来计算 $\\overline{R}$ 和 $\\overline{\\mathrm{F}}$。\n5.  用 $\\Delta\\mathbf{r}^{wrap}$ 和 $\\Delta\\mathbf{r}^{MIC}$ 这两种位移调用这些函数，以获得四个所需的度量：$\\overline{R}^{wrap}$、$\\overline{R}^{MIC}$、$\\overline{\\mathrm{F}}^{wrap}$ 和 $\\overline{\\mathrm{F}}^{MIC}$。\n6.  每个用例的结果四舍五入到 6 位小数并被收集。\n7.  最后，将所有测试用例收集到的结果格式化为代表列表的列表的单个字符串，如规范所示。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 1,\n            \"T\": 4,\n            \"ref_pos\": [[0.90, 0.00, 0.00]],\n            \"traj\": [\n                [[0.90, 0.00, 0.00]],\n                [[0.95, 0.00, 0.00]],\n                [[0.98, 0.00, 0.00]],\n                [[0.02, 0.00, 0.00]],\n            ],\n        },\n        {\n            \"L\": (2.0, 1.0, 1.5),\n            \"N\": 3,\n            \"T\": 3,\n            \"ref_pos\": [\n                [1.80, 0.20, 0.75],\n                [0.10, 0.90, 0.10],\n                [1.99, 0.05, 1.49],\n            ],\n            \"traj\": [\n                [\n                    [1.85, 0.22, 0.78],\n                    [0.15, 0.92, 0.14],\n                    [1.98, 0.06, 1.48],\n                ],\n                [\n                    [0.05, 0.22, 0.78],\n                    [0.15, 0.02, 0.14],\n                    [1.98, 0.06, 0.01],\n                ],\n                [\n                    [0.10, 0.24, 0.77],\n                    [0.18, 0.05, 0.08],\n                    [0.02, 0.04, 0.02],\n                ],\n            ],\n        },\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 2,\n            \"T\": 2,\n            \"ref_pos\": [\n                [0.25, 0.25, 0.25],\n                [0.75, 0.75, 0.75],\n            ],\n            \"traj\": [\n                [\n                    [0.75, 0.25, 0.25],\n                    [0.25, 0.75, 0.75],\n                ],\n                [\n                    [0.75, 0.75, 0.25],\n                    [0.25, 0.25, 0.75],\n                ]\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = _compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # The string representation of a list of lists is the required format.\n    print(str(results))\n\ndef _get_mic_displacements(delta_r_wrap, L_array):\n    \"\"\"\n    Computes minimal-image corrected displacements from wrapped displacements.\n    The tie-breaking rule (round half to nearest even integer) is the default\n    behavior of numpy.round().\n    \"\"\"\n    scaled_dr = delta_r_wrap / L_array\n    n = -np.round(scaled_dr)\n    delta_r_mic = delta_r_wrap + n * L_array\n    return delta_r_mic\n\ndef _compute_avg_rmsd(displacements, N, T):\n    \"\"\"Computes time-averaged RMSD from a displacement array.\"\"\"\n    sq_norms = np.sum(displacements**2, axis=2)  # Shape: (T, N)\n    msd_t = np.mean(sq_norms, axis=1)           # Shape: (T,)\n    R_t = np.sqrt(msd_t)\n    avg_R = np.mean(R_t)\n    return avg_R\n\ndef _compute_avg_rmsf(displacements, ref_pos, N, T):\n    \"\"\"Computes atom-averaged RMSF from a displacement array and reference positions.\"\"\"\n    # Reconstruct continuous trajectory u_i(t) = r_ref_i + delta_r_i(t)\n    # ref_pos has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    u = ref_pos[np.newaxis, :, :] + displacements\n    \n    # Compute time-averaged position for each atom, u_mean has shape (N, 3)\n    u_mean = np.mean(u, axis=0)\n    \n    # Calculate deviations from the mean: u(t) - u_mean\n    # u_mean has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    dev_from_mean = u - u_mean[np.newaxis, :, :]\n    \n    # Compute RMSF per atom\n    sq_norms_dev = np.sum(dev_from_mean**2, axis=2) # Shape: (T, N)\n    msd_i = np.mean(sq_norms_dev, axis=0)          # Shape: (N,)\n    RMSF_i = np.sqrt(msd_i)\n    \n    # Average RMSF over all atoms\n    avg_F = np.mean(RMSF_i)\n    return avg_F\n\ndef _compute_metrics_for_case(case_data):\n    \"\"\"\n    Processes a single test case to compute all four required metrics.\n    \"\"\"\n    L = np.array(case_data[\"L\"])\n    ref_pos = np.array(case_data[\"ref_pos\"])\n    traj = np.array(case_data[\"traj\"])\n    N = case_data[\"N\"]\n    T = case_data[\"T\"]\n\n    # Calculate wrapped displacements: traj - ref_pos\n    # ref_pos has shape (N, 3). Add a new axis to broadcast to (T, N, 3).\n    delta_r_wrap = traj - ref_pos[np.newaxis, :, :]\n\n    # Calculate minimal-image corrected displacements\n    delta_r_mic = _get_mic_displacements(delta_r_wrap, L)\n\n    # Compute RMSD for both conventions\n    R_wrap = _compute_avg_rmsd(delta_r_wrap, N, T)\n    R_mic = _compute_avg_rmsd(delta_r_mic, N, T)\n\n    # Compute RMSF for both conventions\n    F_wrap = _compute_avg_rmsf(delta_r_wrap, ref_pos, N, T)\n    F_mic = _compute_avg_rmsf(delta_r_mic, ref_pos, N, T)\n\n    # Round results to 6 decimal places\n    return [\n        round(R_wrap, 6),\n        round(R_mic, 6),\n        round(F_wrap, 6),\n        round(F_mic, 6)\n    ]\n\n# Run the solution\nsolve()\n```", "id": "3443654"}, {"introduction": "除了笛卡尔坐标，内坐标（如二面角）的分析也至关重要，而它们的周期性特性带来了独特的挑战。例如，对物理上几乎相同但数值上分别为 $\\pi$ 和 $-\\pi$ 的角度进行简单的算术平均，会得出毫无意义的结果。本练习旨在揭示这种“环绕问题”（wrap-around problem），并引导您使用复数表示法推导出处理周期性数据的正确统计方法，从而精确计算角度的平均值与涨落 [@problem_id:3443644]。", "problem": "考虑一个肽二面角的分子动力学轨迹，其中该角度是圆周上的一个周期性变量。在八个等间隔的帧中记录其角坐标，得到以弧度为单位的值 $\\{\\theta_k\\}_{k=1}^{8}$：\n$$\n\\theta_1 = \\pi - 0.03,\\quad \\theta_2 = \\pi - 0.04,\\quad \\theta_3 = \\pi - 0.05,\\quad \\theta_4 = \\pi - 0.06,\\\\\n\\theta_5 = -\\pi + 0.03,\\quad \\theta_6 = -\\pi + 0.04,\\quad \\theta_7 = -\\pi + 0.05,\\quad \\theta_8 = -\\pi + 0.06.\n$$\n该可观测量是一个具有 $2\\pi$ 周期性的扭转自由度。你的任务是，以一种与圆周拓扑结构以及均方根偏差和涨落分析的目标相一致的方式，来分析其平均值和涨落。\n\n从适用于分子动力学中角度数据的第一性原理出发：\n- 论证为何基于角度的周期性等同以及实数轴上在 $\\pm \\pi$ 处存在不连续接缝，直接将角度作为实数轴上的数来求平均值会产生误导性结果。\n- 通过欧拉公式将每个角度 $\\theta_k$ 表示为一个单位复数，推导出尊重圆周拓扑结构的角平均方向估计量和一个类似方差的集中度度量。\n- 使用你的推导，定义角度数据关于平均方向的均方根测地偏差，并计算其对于给定数据集的值。\n\n将最终数值答案四舍五入至四位有效数字，并以弧度表示。仅提供以弧度表示的均方根测地偏差的最终数值作为答案。", "solution": "分子动力学中角度统计的恰当基础是，将圆的几何学与将角度表示为单位圆上的点的方法相结合。角度 $\\theta$ 存在于流形 $S^1$ 上，其中 $\\theta$ 和 $\\theta + 2\\pi$ 表示相同的物理状态。在实数轴上的朴素平均不尊重这种等同关系，并且可能对 $\\pm \\pi$ 处不连续接缝的位置表现出病态的敏感性。\n\n首先，考虑给定角度的朴素算术平均值：\n$$\n\\bar{\\theta}_{\\text{naive}} = \\frac{1}{8}\\sum_{k=1}^{8}\\theta_k.\n$$\n将数据分组为数对 $(\\pi - \\varepsilon, -\\pi + \\varepsilon)$，其中 $\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}$。对于任意这样的数对，\n$$\n(\\pi - \\varepsilon) + (-\\pi + \\varepsilon) = 0,\n$$\n所以所有八个角度的总和为 $0$，因此 $\\bar{\\theta}_{\\text{naive}} = 0$。这是具有误导性的：这八个角度聚集在 $\\theta \\approx \\pm \\pi$ 附近，所以物理上的平均方向应该接近 $\\pi$（或等价地 $-\\pi$），而不是接近 $0$。这种病态现象的产生是由于在实数轴上求平均值没有考虑在 $\\pm \\pi$ 处的环绕效应，实际上是将刚好处在 $-\\pi$ 左侧的值拖向大的负值，并将刚好处在 $\\pi$ 右侧的值拖向大的正值，尽管它们在圆周上物理上是相邻的，但在求和中却相互抵消了。\n\n为避免此问题，我们使用欧拉公式将角度嵌入复平面。对于每个数据点，\n$$\nz_k = \\exp(i\\theta_k) = \\cos(\\theta_k) + i\\sin(\\theta_k),\\quad k=1,\\dots,8.\n$$\n定义合矢量\n$$\nS = \\sum_{k=1}^{8} z_k,\\quad R = \\frac{|S|}{8},\n$$\n其中 $|S|$ 是 $S$ 的模。平均方向的估计量是 $S$ 的辐角：\n$$\n\\hat{\\mu} = \\arg(S),\n$$\n而集中度（类似方差）的度量可以用平均合矢量长度 $R$ 来定义，例如圆周方差 $V$ 由\n$$\nV = 1 - R,\n$$\n给出，当角度更紧密地聚集在一个方向周围时，$V$ 会减小。\n\n计算给定数据集的 $S$。使用恒等式\n$$\n\\exp\\!\\big(i(\\pi - \\varepsilon)\\big) = -\\cos(\\varepsilon) + i\\sin(\\varepsilon),\\quad\n\\exp\\!\\big(i(-\\pi + \\varepsilon)\\big) = -\\cos(\\varepsilon) - i\\sin(\\varepsilon).\n$$\n对于每对 $(\\pi - \\varepsilon, -\\pi + \\varepsilon)$，其和为\n$$\n-\\cos(\\varepsilon) + i\\sin(\\varepsilon) + \\big(-\\cos(\\varepsilon) - i\\sin(\\varepsilon)\\big) = -2\\cos(\\varepsilon).\n$$\n对 $\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}$ 求和，\n$$\nS = -2\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\cos(\\varepsilon),\n$$\n它位于负实轴上，因此\n$$\n\\hat{\\mu} = \\pi,\\quad R = \\frac{|S|}{8} = \\frac{2\\sum \\cos(\\varepsilon)}{8} = \\frac{1}{4}\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\cos(\\varepsilon).\n$$\n这正确地将平均方向定位于 $\\pi$，与朴素平均值 $\\bar{\\theta}_{\\text{naive}} = 0$ 形成对比。\n\n对于圆周上的均方根偏差和涨落分析，我们必须沿 $S^1$ 上的测地线测量偏差，即最小环绕差。定义关于 $\\hat{\\mu}$ 的环绕差：\n$$\n\\delta_k = \\mathrm{wrap}_{(-\\pi,\\pi]}\\!\\big(\\theta_k - \\hat{\\mu}\\big),\n$$\n这是 $\\theta_k - \\hat{\\mu}$ 在 $(-\\pi,\\pi]$ 区间内的代表元。关于 $\\hat{\\mu}$ 的均方根测地偏差（圆周均方根偏差）是\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{\\frac{1}{8}\\sum_{k=1}^{8}\\delta_k^{2}}.\n$$\n在我们的数据集中，当 $\\hat{\\mu} = \\pi$ 时，我们有\n$$\n\\theta = \\pi - \\varepsilon \\;\\Rightarrow\\; \\delta = -\\varepsilon,\\qquad\n\\theta = -\\pi + \\varepsilon \\;\\Rightarrow\\; \\delta = \\varepsilon,\n$$\n所以对每个角度都有 $|\\delta| = \\varepsilon$。因此，\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{\\frac{1}{8}\\left(2\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\varepsilon^{2}\\right)}.\n$$\n计算平方和：\n$$\n0.03^{2} = 0.0009,\\quad 0.04^{2} = 0.0016,\\quad 0.05^{2} = 0.0025,\\quad 0.06^{2} = 0.0036,\n$$\n所以\n$$\n\\sum_{\\varepsilon} \\varepsilon^{2} = 0.0009 + 0.0016 + 0.0025 + 0.0036 = 0.0086,\n$$\n且\n$$\n\\frac{1}{8}\\left(2\\sum \\varepsilon^{2}\\right) = \\frac{1}{8}\\times 2 \\times 0.0086 = \\frac{0.0172}{8} = 0.00215.\n$$\n因此，\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{0.00215}.\n$$\n以弧度为单位计算并四舍五入到四位有效数字，\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} \\approx 0.04637.\n$$\n这个值量化了关于正确的圆周平均值的均方根角涨落，并避免了朴素线性平均所固有的环绕病态问题。", "answer": "$$\\boxed{0.04637}$$", "id": "3443644"}]}