{"hands_on_practices": [{"introduction": "第一个练习是基础性的。我们将实现并比较两种常见的积分器——辛速度Verlet算法和非辛的四阶龙格-库塔方法。通过模拟简谐振子和Lennard-Jones二聚体等简单系统，我们将学会计算关键的诊断指标：能量漂移率、涨落幅度和时间可逆性误差。这个练习将直接展示这两类算法在长期稳定性上的实际差异。[@problem_id:3409941]", "problem": "考虑一个分子动力学中的确定性、封闭经典系统，其哈密顿量为 $H(q,p) = T(p) + U(q)$，其中 $q$ 表示位置，$p$ 表示动量，$T(p)$ 是动能，$U(q)$ 是势能。精确的动力学遵循牛顿第二定律和哈密顿方程，确保总能量 $E(t) = H(q(t),p(t))$ 是守恒的，即对于连续轨迹，$dE/dt = 0$。在时间步长为 $\\Delta t$ 的离散时间数值模拟中，数值流取决于所用的积分器。辛、时间可逆积分器（例如，速度 Verlet 方法）已知能在长时间内对一个修正（影子）哈密顿量表现出近似守恒，而通用的非辛积分器（例如，经典四阶龙格-库塔方法）则可能表现出长期的能量漂移。能量审计与诊断用于量化一个算法在给定系统上的能量守恒性、漂移和长期稳定性。\n\n你的任务是为两个系统实现两种数值积分器，运行长轨迹，并为每个测试用例计算三个诊断指标：\n\n- 线性能量漂移率 $s$，定义为 $\\Delta E(t) = E(t) - E(0)$ 作为 $t$ 的函数的最小二乘拟合的斜率。\n- $\\Delta E(t)$ 在减去最佳拟合线后的均方根涨落幅度 $R$，即拟合的残差平方的均值的平方根。\n- 时间可逆性误差 $J$，通过向前积分 $N$ 步，反转速度，再向前积分 $N$ 步，并测量最终状态与初始状态之间的欧几里得相空间误差来计算。\n\n仅基于以下基本定律和定义进行工作：\n- 牛顿第二定律：$m \\, \\ddot{q} = F(q)$，其中 $F(q) = - \\nabla U(q)$。\n- 运动学：$\\dot{q} = v$，$\\dot{v} = a(q)$，其中 $a(q) = F(q)/m$。\n- 适用于每个系统的动能和势能定义。\n- 应用于 $(q,v)$ 一阶系统的标准、广泛使用的数值方案（速度 Verlet 和经典四阶龙格-库塔）。\n\n在约化单位下，为两个封闭系统实现这两种积分器：\n\n系统 A（一维谐振子）：\n- 质量 $m = 1$。\n- 弹性系数 $k = 1$。\n- 力 $F(x) = -k x$。\n- 能量 $E = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2$。\n\n系统 B（三维双粒子 Lennard–Jones 二聚体）：\n- 两个相同的粒子，质量 $m = 1$。\n- Lennard–Jones 参数 $\\varepsilon = 1$，$\\sigma = 1$。对于粒子间距 $r$，对势为 $U(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$。\n- 力是中心力，作用于两个粒子上的力大小相等、方向相反。\n- 能量 $E = \\sum_{i=1}^{2} \\tfrac{1}{2} m \\|v_i\\|^2 + U(\\|r_1 - r_2\\|)$。\n\n为每个测试用例计算的诊断指标：\n- 通过对从 $t=0$ 开始的整个轨迹进行最小二乘拟合，将 $\\Delta E(t)$ 拟合为一条直线 $\\Delta E(t) \\approx s \\, t + b$，并报告拟合的斜率 $s$。\n- 报告 $R = \\sqrt{\\tfrac{1}{M} \\sum_{j=1}^{M} [\\Delta E(t_j) - (s \\, t_j + b)]^2}$，其中 $M$ 是采样的时间点数量。\n- 对于时间可逆性，从 $(q_0,v_0)$ 开始，向前积分 $N$ 步到 $(q_N, v_N)$，设置 $(q^*, v^*) = (q_N, -v_N)$，再向前积分 $N$ 步到 $(\\tilde{q}, \\tilde{v})$，并报告 $J = \\sqrt{\\| \\tilde{q} - q_0 \\|^2 + \\| \\tilde{v} - v_0 \\|^2}$。\n\n使用以下测试套件。所有量均以约化单位指定，所有输出必须报告为十进制浮点数，其中 $s$ 的单位为约化能量单位每单位时间， $R$ 的单位为约化能量单位，$J$ 的单位为约化单位。\n\n测试用例 $1$（系统 A，速度 Verlet）：\n- 初始条件：$x(0) = 1$，$v(0) = 0$。\n- 时间步长：$\\Delta t = 0.1$。\n- 步数：$N = 20000$。\n\n测试用例 $2$（系统 A，经典四阶龙格-库塔）：\n- 初始条件：$x(0) = 1$，$v(0) = 0$。\n- 时间步长：$\\Delta t = 0.1$。\n- 步数：$N = 20000$。\n\n测试用例 $3$（系统 B，速度 Verlet）：\n- 初始位置：$r_1(0) = (-0.65, 0, 0)$，$r_2(0) = (0.65, 0, 0)$，使得初始距离为 $r(0) = 1.3$。\n- 初始速度：$v_1(0) = (0, 0, 0)$，$v_2(0) = (0, 0, 0)$。\n- 时间步长：$\\Delta t = 0.002$。\n- 步数：$N = 20000$。\n\n测试用例 $4$（系统 A，速度 Verlet，接近稳定边界）：\n- 初始条件：$x(0) = 1$，$v(0) = 0$。\n- 时间步长：$\\Delta t = 1.9$。\n- 步数：$N = 5000$。\n\n数值要求：\n- 实现应用于 $(q,v)$ 一阶系统的速度 Verlet 和经典四阶龙格-库塔积分器。\n- 使用双精度算术。\n- 为了进行回归分析，在从 $t = 0$ 到 $t = N \\Delta t$（含两端）的每个 $\\Delta t$ 的整数倍处采样并使用能量值。\n- 最小二乘拟合必须包括截距 $b$。\n- 时间可逆性测试对每种情况使用与能量审计相同的 $\\Delta t$ 和 $N$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来，其中每个元素对应一个测试用例，并且本身是一个三元素列表 $[s,R,J]$，顺序如此。例如，生成形如 $[[s_1,R_1,J_1],[s_2,R_2,J_2],[s_3,R_3,J_3],[s_4,R_4,J_4]]$ 的一行，不含内嵌空格。", "solution": "所提出的问题要求对分子动力学中两种常用积分算法的特性进行数值研究：速度 Verlet 方法和经典四阶龙格-库塔（RK4）方法。该研究将在两个代表性的物理系统上进行：一维谐振子和三维双粒子 Lennard-Jones 系统。任务的核心是量化这些积分器的三个关键性能指标：长期能量漂移率 ($s$)、能量涨落幅度 ($R$) 和时间可逆性误差 ($J$)。此分析突出了辛、时间可逆积分器与通用非辛积分器在保守系统长期模拟背景下的根本区别。\n\n**数值积分算法**\n\n系统的动力学由牛顿第二定律支配，可表示为一组一阶常微分方程（ODEs）：\n$$\n\\frac{d\\mathbf{q}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{q}) = \\frac{\\mathbf{F}(\\mathbf{q})}{m}\n$$\n其中 $\\mathbf{q}$、$\\mathbf{v}$ 和 $\\mathbf{a}$ 分别是广义位置、速度和加速度，$m$ 是质量。\n\n**速度 Verlet 积分器**\n速度 Verlet 算法是一种几何积分器，专为哈密顿系统设计。它通过以下序列将状态从时间 $t$ 推进到 $t+\\Delta t$：\n1. 将速度更新到半步：\n$$\n\\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) = \\mathbf{v}(t) + \\tfrac{1}{2}\\mathbf{a}(t)\\Delta t\n$$\n2. 将位置更新到完整步长：\n$$\n\\mathbf{q}(t + \\Delta t) = \\mathbf{q}(t) + \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t)\\Delta t\n$$\n3. 根据新位置 $\\mathbf{q}(t+\\Delta t)$ 的力计算新加速度 $\\mathbf{a}(t+\\Delta t)$。\n4. 完成速度更新到完整步长：\n$$\n\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) + \\tfrac{1}{2}\\mathbf{a}(t + \\Delta t)\\Delta t\n$$\n速度 Verlet 方法的关键特性是它既是辛的也是时间可逆的。辛性确保积分器精确地保持一个“影子”哈密顿量，这是一个与系统真实哈密顿量非常接近的守恒量。这导致测量的能量 $E(t)$ 在其初始值附近有界振荡，并排除了系统性的长期能量漂移。时间可逆性确保了在时间上向后积分可以完美地撤销向前积分的步骤，这一特性对长期稳定性至关重要。\n\n**经典四阶龙格-库塔（RK4）积分器**\nRK4 方法是一种广泛使用的高精度通用常微分方程求解器。对于一阶系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，其中状态向量为 $\\mathbf{y} = (\\mathbf{q}, \\mathbf{v})$，不依赖时间的导数为 $f(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{q}))$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的单步计算如下：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n中间阶段的向量 $\\mathbf{k}_i$ 计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n\\end{aligned}\n$$\n虽然 RK4 具有很高的局部精度（步长误差为 $O(\\Delta t^5)$ 阶），但它不是一个辛算法。因此，它不保持影子哈密顿量，并且对于哈密顿系统，通常会在长时间的模拟中引入总能量的长期（系统性）漂移。它也不是时间可逆的，这是导致其在这种情况下长期稳定性差的另一个原因。\n\n**物理系统**\n\n**系统 A：一维谐振子**\n这是一个基本的线性系统，质量 $m=1$，弹性系数 $k=1$。\n- 势能：$U(x) = \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} x^2$\n- 力：$F(x) = -\\frac{dU}{dx} = -k x = -x$\n- 加速度：$a(x) = F(x)/m = -x$\n- 总能量：$E = T + U = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} v^2 + \\tfrac{1}{2} x^2$\n\n**系统 B：三维 Lennard-Jones 二聚体**\n该系统由两个相同的质量为 $m=1$ 的粒子组成，它们通过 Lennard-Jones 势相互作用，参数为 $\\varepsilon=1$ 和 $\\sigma=1$。设 $\\mathbf{r}_1, \\mathbf{r}_2$ 为位置向量，$\\mathbf{v}_1, \\mathbf{v}_2$ 为速度向量。粒子间的分离向量为 $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$，其大小为 $r = \\|\\mathbf{r}_{12}\\|_2$。\n- 势能：$U(r) = 4\\varepsilon [(\\frac{\\sigma}{r})^{12} - (\\frac{\\sigma}{r})^6] = 4(r^{-12} - r^{-6})$\n- 作用在粒子 1 上的力是 $\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r) = -\\frac{dU}{dr} \\frac{\\mathbf{r}_{12}}{r}$。势的导数为 $\\frac{dU}{dr} = 24\\varepsilon(\\sigma^6 r^{-7} - 2\\sigma^{12} r^{-13})$。使用给定参数，这变为：\n$$\n\\mathbf{F}_1 = -24(r^{-7} - 2r^{-13}) \\frac{\\mathbf{r}_{12}}{r} = 24(2r^{-14} - r^{-8})\\mathbf{r}_{12}\n$$\n- 根据牛顿第三定律，作用在粒子 2 上的力是 $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n- 加速度为 $\\mathbf{a}_1 = \\mathbf{F}_1/m = \\mathbf{F}_1$ 和 $\\mathbf{a}_2 = \\mathbf{F}_2/m = \\mathbf{F}_2$。\n- 总能量：$E = \\sum_{i=1}^2 \\tfrac{1}{2}m_i \\|\\mathbf{v}_i\\|^2 + U(r) = \\tfrac{1}{2}(\\|\\mathbf{v}_1\\|^2 + \\|\\mathbf{v}_2\\|^2) + 4(r^{-12} - r^{-6})$。\n\n**诊断指标**\n\n对于 4 个测试用例中的每一个，计算三个诊断指标以评估积分器的性能。\n1. **能量漂移率 ($s$) 和涨落幅度 ($R$)**：在每个时间步 $t_j = j \\Delta t$（其中 $j \\in [0, N]$）计算总能量相对于其初始值的变化 $\\Delta E(t_j) = E(t_j) - E(0)$。通过最小二乘法将这些数据拟合到线性模型 $\\Delta E(t) \\approx s t + b$。得到的斜率 $s$ 是能量漂移率。此拟合残差的均方根，$R = \\sqrt{\\frac{1}{M} \\sum_{j=0}^{N} [\\Delta E(t_j) - (s t_j + b)]^2}$（其中 $M=N+1$），量化了能量围绕拟合漂移线的涨落幅度。\n2. **时间可逆性误差 ($J$)**：该指标量化了与完美时间可逆性的偏差。首先，从初始状态 $(\\mathbf{q}_0, \\mathbf{v}_0)$ 开始，向前运行模拟 $N$ 步，到达最终状态 $(\\mathbf{q}_N, \\mathbf{v}_N)$。然后反转速度，得到 $(\\mathbf{q}_N, -\\mathbf{v}_N)$，并再次向前运行模拟 $N$ 步，到达状态 $(\\tilde{\\mathbf{q}}, \\tilde{\\mathbf{v}})$。误差是最终状态和初始状态在相空间中的欧几里得距离：\n    $$\n    J = \\sqrt{\\| \\tilde{\\mathbf{q}} - \\mathbf{q}_0 \\|^2 + \\| \\tilde{\\mathbf{v}} - \\mathbf{v}_0 \\|^2}\n    $$\n    对于一个完全时间可逆的积分器和精确算术，J 将为零。\n\n**实现策略**\n该解决方案使用 Python 实现，并利用 `numpy` 库进行高效的向量化计算。一个主函数 `solve` 协调 4 个测试用例。对于每个用例，通过重复调用适当的积分步进函数（`step_verlet` 或 `step_rk4`）来执行模拟。这些步进函数被设计为通用的，以当前状态和加速度函数作为输入。特定于系统的函数（`acc_ho`、`energy_ho`、`acc_lj`、`energy_lj`）提供了物理模型。生成能量轨迹后，使用 `numpy.polyfit` 进行线性回归以确定 $s$ 和 $b$，然后计算 $R$。为时间可逆性测试运行一个单独的模拟以计算 $J$。所有计算都以双精度算术执行。收集结果并格式化为指定的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy is sufficient as allowed.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # --- System A: 1D Harmonic Oscillator ---\n    def acc_ho(q, m=1.0, k=1.0):\n        \"\"\"Acceleration for 1D harmonic oscillator.\"\"\"\n        return -k * q / m\n\n    def energy_ho(q, v, m=1.0, k=1.0):\n        \"\"\"Total energy for 1D harmonic oscillator.\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * q**2\n\n    # --- System B: 3D Lennard-Jones Dimer ---\n    def acc_lj(q, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Acceleration for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check for particle overlap\n        if dist_sq == 0:\n            return np.zeros_like(q)\n\n        inv_dist_sq = 1.0 / dist_sq\n        inv_dist_6 = inv_dist_sq**3\n        \n        # Force calculation based on dU/dr\n        # F1 = 24 * epsilon * (2 * sigma^12 * r^-14 - sigma^6 * r^-8) * r12\n        force_mag_term = 24.0 * epsilon * (2.0 * (sigma**12) * inv_dist_6**2 * inv_dist_sq - (sigma**6) * inv_dist_6 * inv_dist_sq)\n        f1 = force_mag_term * r12\n        f2 = -f1\n        \n        # Since mass is 1 for both particles\n        a1 = f1 / m\n        a2 = f2 / m\n        \n        return np.array([a1, a2]).flatten()\n\n    def energy_lj(q, v, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Total energy for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        v1, v2 = v.reshape(2, 3)\n        \n        ke = 0.5 * m * (np.sum(v1**2) + np.sum(v2**2))\n        \n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check\n        if dist_sq == 0:\n            pe = np.inf\n        else:\n            inv_dist_sq = 1.0 / dist_sq\n            inv_dist_6 = inv_dist_sq**3\n            pe = 4.0 * epsilon * (inv_dist_6**2 - inv_dist_6)\n\n        return ke + pe\n\n    # --- Numerical Integrators ---\n    def step_verlet(q, v, dt, acc_func):\n        \"\"\"A single step of the velocity Verlet integrator.\"\"\"\n        a = acc_func(q)\n        v_half = v + 0.5 * dt * a\n        q_next = q + dt * v_half\n        a_next = acc_func(q_next)\n        v_next = v_half + 0.5 * dt * a_next\n        return q_next, v_next\n\n    def step_rk4(q, v, dt, acc_func):\n        \"\"\"A single step of the classical 4th-order Runge-Kutta integrator.\"\"\"\n        # k1\n        k1_q = v\n        k1_v = acc_func(q)\n        # k2\n        k2_q = v + 0.5 * dt * k1_v\n        k2_v = acc_func(q + 0.5 * dt * k1_q)\n        # k3\n        k3_q = v + 0.5 * dt * k2_v\n        k3_v = acc_func(q + 0.5 * dt * k2_q)\n        # k4\n        k4_q = v + dt * k3_v\n        k4_v = acc_func(q + dt * k3_q)\n        # update\n        q_next = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n        v_next = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n        return q_next, v_next\n\n    # --- Simulation and Diagnostics ---\n    def run_simulation(q0, v0, dt, N, step_func, acc_func, energy_func):\n        \"\"\"Runs a simulation and returns diagnostic metrics.\"\"\"\n        q, v = np.copy(q0), np.copy(v0)\n        \n        # Energy audit\n        energies = np.zeros(N + 1, dtype=np.float64)\n        energies[0] = energy_func(q, v)\n        \n        for i in range(1, N + 1):\n            q, v = step_func(q, v, dt, acc_func)\n            energies[i] = energy_func(q, v)\n\n        times = np.arange(N + 1) * dt\n        e0 = energies[0]\n        delta_e = energies - e0\n        \n        # Calculate s and R\n        s, b = np.polyfit(times, delta_e, 1)\n        residuals = delta_e - (s * times + b)\n        R = np.sqrt(np.mean(residuals**2))\n\n        # Time-reversibility test\n        q, v = np.copy(q0), np.copy(v0)\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        # Reverse and integrate back\n        v = -v\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        q_tilde, v_tilde = q, v\n        \n        # Calculate J\n        q_error = np.linalg.norm(q_tilde - q0)\n        v_error = np.linalg.norm(v_tilde - v0)\n        J = np.sqrt(q_error**2 + v_error**2)\n        \n        return s, R, J\n\n    test_cases = [\n        # Case 1: System A, Verlet\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 2: System A, RK4\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_rk4, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 3: System B, Verlet\n        dict(q0=np.array([-0.65, 0, 0, 0.65, 0, 0]), \n             v0=np.array([0, 0, 0, 0, 0, 0]), \n             dt=0.002, N=20000, \n             step_func=step_verlet, acc_func=acc_lj, energy_func=energy_lj),\n        # Case 4: System A, Verlet, near stability boundary\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=1.9, N=5000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, R, J = run_simulation(case['q0'], case['v0'], case['dt'], case['N'], \n                                   case['step_func'], case['acc_func'], case['energy_func'])\n        results.append([s, R, J])\n        \n    def format_list(lst):\n        return '[' + ','.join(f'{x:.8e}' for x in lst) + ']'\n    \n    # Custom formatting to remove spaces\n    result_str = '[' + ','.join(map(format_list, results)) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "3409941"}, {"introduction": "在我们学会测量能量漂移之后，本练习将深入探讨该误差如何随积分时间步长 $\\Delta t$ 变化。通过系统地改变 $\\Delta t$ 并将产生的能量偏差拟合到幂律关系，我们可以凭经验确定积分器的精度阶数。这项练习不仅巩固了方法阶数的理论概念，还为验证模拟代码的实现提供了有力的工具。[@problem_id:3409975]", "problem": "考虑一个确定性的微正则分子动力学 (MD) 模拟，该模拟针对一个小系统在牛顿第二定律下演化。其中，$N$ 个质量为 $m$ 的相同粒子的位置 $x_i(t)$ 和速度 $v_i(t)$ 的运动方程由 $m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$ 给出，其中 $F_i(x) = -\\nabla_{x_i} V(x)$。假设总能量 $E(x,v) = K(v) + V(x)$，其中动能为 $K(v) = \\dfrac{1}{2} \\sum_{i=1}^{N} m\\, v_i^2$，势能 $V(x)$ 是保守且不依赖于时间的。该系统使用时间步长为 $\\Delta t$ 的显式时间步进方法进行数值积分。数值积分器的阶数为 $p$，意味着在固定的总时间后，状态变量的全局误差与 $\\mathcal{O}(\\Delta t^p)$ 成比例。\n\n您将测试两种边界条件设置下的长期能量守恒和漂移标度：周期性单元和固定软墙。目标是量化能量漂移度量如何随 $\\Delta t^p$ 标度变化，并通过对数-对数拟合凭经验估计标度指数 $p$。\n\n设置的基本原理：\n- 粒子 $i$ 的牛顿第二定律：$m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$。\n- 速度定义为 $v_i = \\dfrac{dx_i}{dt}$。\n- 由于势是时间无关的且系统是孤立的（微正则系综），总能量 $E(t) = K(t) + V(t)$ 对于精确动力学必须是守恒的。\n\n系统规格：\n- 在一维空间中使用 $N = 2$ 个粒子，其位置为 $x_1$ 和 $x_2$，速度为 $v_1$ 和 $v_2$。\n- 使用约化的 Lennard-Jones 单位：长度单位为 $\\sigma$，能量单位为 $\\varepsilon$，时间单位为 $\\sigma \\sqrt{m/\\varepsilon}$。\n- 对相互作用通过在截断距离 $r_c$ 处截断的移力 Lennard-Jones 势进行，以确保力在 $r_c$ 处的连续性。定义未移动的 Lennard-Jones 势\n$$\nV_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right],\n$$\n其相应的力的大小（沿粒子间分离方向作用）为\n$$\nf_{\\mathrm{LJ}}(r) = 24\\varepsilon\\left[\\dfrac{2\\sigma^{12}}{r^{13}} - \\dfrac{\\sigma^6}{r^7}\\right] = 24\\varepsilon\\left[\\dfrac{2\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6}{r}\\right]。\n$$\n设 $r_c$ 为截断距离，并记 $V_c = V_{\\mathrm{LJ}}(r_c)$ 和 $f_c = f_{\\mathrm{LJ}}(r_c)$。对于 $r  r_c$，移力势和力为\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_c - (r - r_c)\\, \\left.\\dfrac{d V_{\\mathrm{LJ}}}{dr}\\right|_{r_c},\n$$\n$$\nf_{\\mathrm{SF}}(r) = f_{\\mathrm{LJ}}(r) - f_c,\n$$\n对于 $r \\ge r_c$，两者均为零。在一维中，粒子 $j$ 对粒子 $i$ 的力是 $F_{i \\leftarrow j} = f_{\\mathrm{SF}}(|r|)\\,\\mathrm{sign}(x_i - x_j)$，其中 $r = x_i - x_j$。\n\n边界条件：\n- 长度为 $L$ 的周期性单元：使用最小镜像约定计算粒子间距离。对于任何分离 $r = x_2 - x_1$，定义 $r_{\\mathrm{MIC}} = r - L\\,\\mathrm{round}(r/L)$ 并在 $V_{\\mathrm{SF}}$ 和 $f_{\\mathrm{SF}}$ 中使用 $|r_{\\mathrm{MIC}}|$。每一步后，应将位置包裹回主单元 $[0,L)$ 以避免无界坐标；此包裹操作不影响最小镜像约定下的力。\n- 在 $x=0$ 和 $x=L$ 处的固定软墙：除了对相互作用外，还为每个粒子包括一个平滑的排斥墙势，\n$$\nV_{\\mathrm{wall}}(x) = \\varepsilon_w \\left[\\left(\\dfrac{\\sigma_w}{x}\\right)^{12} + \\left(\\dfrac{\\sigma_w}{L - x}\\right)^{12}\\right],\n$$\n其相应的墙壁力为\n$$\nF_{\\mathrm{wall}}(x) = -\\dfrac{d V_{\\mathrm{wall}}}{dx} = 12 \\varepsilon_w \\sigma_w^{12}\\left[\\dfrac{1}{x^{13}} - \\dfrac{1}{(L - x)^{13}}\\right]。\n$$\n\n待比较的数值积分器：\n- Velocity Verlet（一种二阶辛方法）：使用标准的交错半步速度算法更新位置和速度。方法阶数 $p = 2$。\n- 经典的四阶 Runge–Kutta 方法：将标准的 Butcher 展开应用于状态 $\\left[x, v\\right]$，其中 $x' = v$ 和 $v' = a(x) = F(x)/m$。方法阶数 $p = 4$。\n\n能量漂移度量：\n- 对于给定的 $\\Delta t$ 和总模拟时间 $T$，记录在时间步 $t_n = n\\,\\Delta t$（$n = 0, 1, \\dots, N_t$，$N_t = T/\\Delta t$）下的能量时间序列 $E(t_n)$。\n- 定义能量偏差 $\\delta E(t_n) = E(t_n) - E(0)$。\n- 定义均方根能量偏差\n$$\nD(\\Delta t) = \\sqrt{\\dfrac{1}{N_t + 1}\\sum_{n=0}^{N_t}\\left[\\delta E(t_n)\\right]^2}。\n$$\n通过对一组 $\\Delta t$ 值进行 $\\log D(\\Delta t)$ 对 $\\log \\Delta t$ 的最小二乘拟合，凭经验估计标度指数 $p$，并将斜率作为估计值 $\\hat{p}$。\n\n所有测试通用的初始条件和参数（以约化单位表示），除非明确改变：\n- 粒子数：$N = 2$。\n- 质量：每个粒子 $m = 1$。\n- Lennard-Jones 参数：$\\varepsilon = 1$，$\\sigma = 1$，截断距离 $r_c = 2.5$。\n- 单元长度：$L = 5$。\n- 墙参数（仅用于固定墙情况）：$\\varepsilon_w = 0.5$，$\\sigma_w = 0.5$。\n- 总模拟时间：$T = 10$。\n- 初始位置：$x_1(0) = 1.25$，$x_2(0) = 3.60$。\n- 初始速度：$v_1(0) = 0.15$，$v_2(0) = -0.10$。\n\n测试套件：\n- 案例 1：周期性边界，Velocity Verlet 积分器，$\\Delta t$ 值 {0.01, 0.005, 0.0025}。\n- 案例 2：周期性边界，四阶 Runge–Kutta 积分器，$\\Delta t$ 值 {0.012, 0.006, 0.003}。\n- 案例 3：固定软墙，Velocity Verlet 积分器，$\\Delta t$ 值 {0.008, 0.004, 0.002}。\n- 案例 4：固定软墙，四阶 Runge–Kutta 积分器，$\\Delta t$ 值 {0.01, 0.005, 0.0025}。\n\n要求输出：\n- 对于每种情况，计算估计的标度指数 $\\hat{p}$，以浮点数形式表示。不需要物理单位，因为 $\\hat{p}$ 是无量纲的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按 $\\left[\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\hat{p}_4\\right]$ 的顺序排列，每个浮点数格式化为三位小数（例如，$\\left[2.003,3.998,2.012,3.955\\right]$）。\n\n模拟中的所有量均以约化的 Lennard-Jones 单位表示；不涉及角度；不使用百分比。程序必须是自包含的，并且不需要用户输入。", "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，提法明确，且客观。确定性模拟所需的所有必要参数和定义都已提供，并且没有内部矛盾或含糊之处。任务是实现一个分子动力学模拟，以研究两种标准数值积分器的能量守恒特性。\n\n目标是凭经验确定能量漂移度量 $D(\\Delta t)$ 相对于积分时间步长 $\\Delta t$ 的标度指数 $\\hat{p}$。该度量预计将按 $D(\\Delta t) \\propto (\\Delta t)^p$ 进行标度，其中 $p$ 是数值积分方法的阶数。指数 $\\hat{p}$ 通过对 $\\log D(\\Delta t)$ 与 $\\log \\Delta t$ 进行线性拟合得到的斜率来估计。\n\n该模拟涉及一个在一维空间中由 $N=2$ 个质量为 $m=1$ 的粒子组成的系统，它们通过移力 Lennard-Jones 势相互作用。考虑了两种边界条件情景：长度为 $L=5$ 的单元中的周期性边界条件 (PBC)，以及在位置 $x=0$ 和 $x=L=5$ 处的固定软排斥墙。测试了两种数值积分方案：二阶 Velocity Verlet (VV) 算法和四阶经典 Runge-Kutta (RK4) 方法。所有量均采用约化的 Lennard-Jones 单位，其中 $\\varepsilon=1$ 和 $\\sigma=1$。\n\n解决方案的核心包括以下步骤：\n1.  定义物理模型，包括势能函数和相应的力。\n2.  实现数值积分器，以随时间演化系统状态（位置和速度）。\n3.  对四个指定的测试案例中的每一个执行模拟，改变时间步长 $\\Delta t$。\n4.  对于每次模拟，计算总能量时间序列和均方根能量偏差度量 $D(\\Delta t)$。\n5.  对于每个测试案例，对对数数据 $(\\log \\Delta t, \\log D(\\Delta t))$ 执行线性回归以找到标度指数 $\\hat{p}$。\n\n**1. 势和力的计算**\n\n每个粒子上的总力是总势能的负梯度。势能函数根据边界条件而变化。\n\n对相互作用由移力 Lennard-Jones 势控制，对于粒子间距 $r \\ge r_c$，该势为零。对于 $r  r_c = 2.5$，势为：\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_{\\mathrm{LJ}}(r_c) - (r - r_c) \\left.\\frac{dV_{\\mathrm{LJ}}}{dr}\\right|_{r=r_c}\n$$\n相应的力的大小为：\n$$\nf_{\\mathrm{SF}}(r) = -\\frac{dV_{\\mathrm{SF}}}{dr} = f_{\\mathrm{LJ}}(r) - f_{\\mathrm{LJ}}(r_c)\n$$\n其中 $V_{\\mathrm{LJ}}(r) = 4\\varepsilon[(\\sigma/r)^{12} - (\\sigma/r)^6]$ 且 $f_{\\mathrm{LJ}}(r) = -\\frac{dV_{\\mathrm{LJ}}}{dr} = 24\\varepsilon/r[2(\\sigma/r)^{12} - (\\sigma/r)^6]$。当 $\\varepsilon=1$ 和 $\\sigma=1$ 时，这些简化为 $V_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$ 和 $f_{\\mathrm{LJ}}(r) = 24(2r^{-13} - r^{-7})$。\n\n**a) 周期性边界条件 (PBC)：**\n总势能为 $V(x_1, x_2) = V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$，其中 $r_{\\mathrm{MIC}} = (x_2-x_1) - L\\,\\mathrm{round}((x_2-x_1)/L)$ 是在最小镜像约定下的距离。作用在粒子上的力大小相等，方向相反：$F_1 = -F_2$，其中 $F_2 = f_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|) \\mathrm{sign}(r_{\\mathrm{MIC}})$。总能量为 $E = \\frac{1}{2}m(v_1^2 + v_2^2) + V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$。\n\n**b) 固定软墙：**\n粒子被限制在 $x=0$ 和 $x=L$ 的墙壁之间。总势能包括对相互作用以及每个粒子的墙壁相互作用：\n$$\nV(x_1, x_2) = V_{\\mathrm{SF}}(|x_2-x_1|) + V_{\\mathrm{wall}}(x_1) + V_{\\mathrm{wall}}(x_2)\n$$\n一个粒子在位置 $x$ 的墙势为 $V_{\\mathrm{wall}}(x) = \\varepsilon_w [(\\sigma_w/x)^{12} + (\\sigma_w/(L - x))^{12}]$。作用在粒子 $i$ 上的力是 $F_i = F_{i \\leftarrow j} + F_{\\mathrm{wall}}(x_i)$，其中 $F_{i \\leftarrow j}$ 是对相互作用力，$F_{\\mathrm{wall}}(x) = -\\frac{dV_{\\mathrm{wall}}}{dx}$。总能量为 $E = \\frac{1}{2}m(v_1^2 + v_2^2) + V(x_1, x_2)$。\n\n**2. 数值积分**\n\n设系统的状态由位置向量 $x = (x_1, x_2)$ 和速度向量 $v = (v_1, v_2)$ 描述。加速度为 $a(x) = F(x)/m$。\n\n**a) Velocity Verlet (VV)：**\n这是一个二阶 ($p=2$) 的辛积分器。从时间 $t$ 到 $t+\\Delta t$ 的一步计算如下：\n1.  计算半步速度：$v(t + \\frac{1}{2}\\Delta t) = v(t) + \\frac{1}{2} a(x(t)) \\Delta t$。\n2.  更新位置：$x(t + \\Delta t) = x(t) + v(t + \\frac{1}{2}\\Delta t) \\Delta t$。\n3.  对 PBC 应用位置包裹：$x(t + \\Delta t) \\leftarrow x(t + \\Delta t) \\pmod L$。\n4.  使用新位置计算新加速度 $a(x(t + \\Delta t))$。\n5.  更新全步速度：$v(t + \\Delta t) = v(t + \\frac{1}{2}\\Delta t) + \\frac{1}{2} a(x(t + \\Delta t)) \\Delta t$。\n对于辛积分器，在哈密顿系统中，数值能量在长时间内不表现出系统性漂移；相反，它围绕初始值振荡。这些振荡的幅度预计与 $\\mathcal{O}(\\Delta t^2)$ 成比例。\n\n**b) 四阶 Runge-Kutta (RK4)：**\n这是一个通用的四阶 ($p=4$) 积分器。设系统状态为单个向量 $Y = [x_1, x_2, v_1, v_2]$。时间导数为 $\\frac{dY}{dt} = f(t, Y) = [v_1, v_2, a_1(x), a_2(x)]$。一步计算如下：\n1.  $k_1 = \\Delta t \\cdot f(t_n, Y_n)$\n2.  $k_2 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_1}{2})$\n3.  $k_3 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_2}{2})$\n4.  $k_4 = \\Delta t \\cdot f(t_n + \\Delta t, Y_n + k_3)$\n5.  $Y_{n+1} = Y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n6.  对 $Y_{n+1}$ 的位置分量应用 PBC 位置包裹。\nRK4 不是辛方法，对于长时间的模拟，它通常会导致总能量的系统性漂移。累积误差以及因此的能量偏差度量 $D(\\Delta t)$ 预计将与 $\\mathcal{O}(\\Delta t^4)$ 成比例。\n\n**3. 模拟与分析**\n对于每种情况，我们使用一组给定的 $\\Delta t$ 值进行总时间为 $T=10$ 的模拟。\n1.  将系统初始化为 $x_1(0)=1.25, x_2(0)=3.60, v_1(0)=0.15, v_2(0)=-0.10$。\n2.  计算初始总能量 $E(0)$。\n3.  在从 $n=0$ 到 $N_t = T/\\Delta t$ 的每个时间步 $t_n = n \\Delta t$，计算总能量 $E(t_n)$ 和偏差的平方 $[\\delta E(t_n)]^2 = [E(t_n) - E(0)]^2$。\n4.  计算均方根能量偏差 $D(\\Delta t) = \\sqrt{\\frac{1}{N_t+1}\\sum_{n=0}^{N_t} [\\delta E(t_n)]^2}$。\n5.  在获得一个测试案例中所有 $\\Delta t$ 值的 $D(\\Delta t)$ 后，我们假设存在一个幂律关系 $D(\\Delta t) \\approx C(\\Delta t)^{\\hat{p}}$。\n6.  取对数得到 $\\log D(\\Delta t) \\approx \\log C + \\hat{p} \\log \\Delta t$。\n7.  通过对收集到的数据点 $(\\log \\Delta t, \\log D(\\Delta t))$ 进行线性最小二乘拟合并取其斜率来估计指数 $\\hat{p}$。这通过使用 `numpy.polyfit` 来完成。\n\n对于 Velocity Verlet 案例，预期结果为 $\\hat{p} \\approx 2$；对于 RK4 案例，预期结果为 $\\hat{p} \\approx 4$，这反映了积分器的阶数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics energy drift scaling problem.\n    \"\"\"\n    # System and potential parameters in reduced units\n    N_PARTICLES = 2\n    MASS = 1.0\n    EPSILON = 1.0\n    SIGMA = 1.0\n    RC = 2.5\n    L = 5.0\n    EPSILON_W = 0.5\n    SIGMA_W = 0.5\n    T_TOTAL = 10.0\n\n    # Initial conditions\n    INITIAL_CONDITIONS = {\n        'pos': np.array([1.25, 3.60]),\n        'vel': np.array([0.15, -0.10]),\n    }\n\n    # Pre-calculate Lennard-Jones constants at the cutoff\n    _rc_pow6 = RC**6\n    _rc_pow12 = _rc_pow6**2\n    V_LJ_RC = 4.0 * EPSILON * ((SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    F_LJ_RC = 24.0 * EPSILON / RC * (2.0 * (SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    _sw12 = SIGMA_W**12\n\n    def get_accel_and_potential(pos, bc_type):\n        \"\"\"Calculates accelerations and potential energy for the 2-particle system.\"\"\"\n        accel = np.zeros(N_PARTICLES)\n        potential = 0.0\n        \n        # Pair interaction\n        r12 = pos[1] - pos[0]\n        dr = r12\n        if bc_type == 'periodic':\n            dr = dr - L * np.round(dr / L)\n        \n        r_abs = np.abs(dr)\n        \n        if r_abs > 0 and r_abs  RC:\n            r_inv = SIGMA / r_abs\n            r_inv6 = r_inv**6\n            r_inv12 = r_inv6**2\n            \n            v_lj = 4.0 * EPSILON * (r_inv12 - r_inv6)\n            f_lj_mag = 24.0 * EPSILON / r_abs * (2.0 * r_inv12 - r_inv6)\n            \n            # Shifted-force potential and force\n            potential_pair = v_lj - V_LJ_RC - (r_abs - RC) * (-F_LJ_RC) # dV/dr = -F\n            force_mag = f_lj_mag - F_LJ_RC\n\n            potential += potential_pair\n            force_on_2 = force_mag * np.sign(dr)\n            accel[1] += force_on_2 / MASS\n            accel[0] -= force_on_2 / MASS\n\n        # Wall interactions for 'fixed' boundary conditions\n        if bc_type == 'fixed':\n            for i in range(N_PARTICLES):\n                x = pos[i]\n                if x > 0 and x  L:\n                    term1 = (SIGMA_W / x)**12\n                    term2 = (SIGMA_W / (L - x))**12\n                    potential += EPSILON_W * (term1 + term2)\n                    \n                    force_wall = 12.0 * EPSILON_W * _sw12 * (x**-13 - (L - x)**-13) * -1\n                    accel[i] += force_wall / MASS\n\n        return accel, potential\n\n    def step_vv(pos, vel, dt, bc_type):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        vel_half = vel + 0.5 * accel * dt\n        pos_new = pos + vel_half * dt\n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n        \n        accel_new, _ = get_accel_and_potential(pos_new, bc_type)\n        vel_new = vel_half + 0.5 * accel_new * dt\n        return pos_new, vel_new\n\n    def get_state_derivative(state, bc_type):\n        \"\"\"Calculates the time derivative of the state vector [pos, vel] for RK4.\"\"\"\n        pos = state[:N_PARTICLES]\n        vel = state[N_PARTICLES:]\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        return np.concatenate((vel, accel))\n\n    def step_rk4(pos, vel, dt, bc_type):\n        \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n        state = np.concatenate((pos, vel))\n        \n        k1 = get_state_derivative(state, bc_type)\n        k2 = get_state_derivative(state + 0.5 * dt * k1, bc_type)\n        k3 = get_state_derivative(state + 0.5 * dt * k2, bc_type)\n        k4 = get_state_derivative(state + dt * k3, bc_type)\n        \n        state_new = state + dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n        \n        pos_new = state_new[:N_PARTICLES]\n        vel_new = state_new[N_PARTICLES:]\n        \n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n            \n        return pos_new, vel_new\n\n    def run_simulation(integrator_func, bc_type, dt, ic):\n        \"\"\"Runs a simulation and returns the RMS energy deviation.\"\"\"\n        pos, vel = ic['pos'].copy(), ic['vel'].copy()\n        \n        num_steps = int(round(T_TOTAL / dt))\n        \n        _, v0 = get_accel_and_potential(pos, bc_type)\n        k0 = 0.5 * MASS * np.sum(vel**2)\n        e0 = k0 + v0\n        \n        energy_devs_sq = [0.0]\n        \n        for _ in range(num_steps):\n            pos, vel = integrator_func(pos, vel, dt, bc_type)\n            _, v_current = get_accel_and_potential(pos, bc_type)\n            k_current = 0.5 * MASS * np.sum(vel**2)\n            e_current = k_current + v_current\n            \n            delta_e = e_current - e0\n            energy_devs_sq.append(delta_e**2)\n            \n        return np.sqrt(np.mean(energy_devs_sq))\n\n    def estimate_p_hat(dts, Ds):\n        \"\"\"Estimates the scaling exponent p from log-log data.\"\"\"\n        log_dts = np.log(dts)\n        log_Ds = np.log(Ds)\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_dts, log_Ds, 1)\n        return slope\n        \n    test_cases = [\n        {'integrator': step_vv, 'bc_type': 'periodic', 'dts': [0.01, 0.005, 0.0025]},\n        {'integrator': step_rk4, 'bc_type': 'periodic', 'dts': [0.012, 0.006, 0.003]},\n        {'integrator': step_vv, 'bc_type': 'fixed', 'dts': [0.008, 0.004, 0.002]},\n        {'integrator': step_rk4, 'bc_type': 'fixed', 'dts': [0.01, 0.005, 0.0025]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        dts = np.array(case['dts'])\n        Ds = np.array([run_simulation(case['integrator'], case['bc_type'], dt, INITIAL_CONDITIONS) for dt in dts])\n        p_hat = estimate_p_hat(dts, Ds)\n        results.append(p_hat)\n        \n    print(f\"[{','.join(f'{p:.3f}' for p in results)}]\")\n\nsolve()\n```", "id": "3409975"}, {"introduction": "为什么辛积分器表现出如此出色的长期能量稳定性？这个高级练习将引导我们通过经验验证“影子哈密顿量”的存在——这是一个经过轻微修正的能量函数，数值轨迹几乎完美地守恒它。通过将能量涨落分析为时间步长的多项式，我们可以识别出该影子哈密顿量的主要项，并将我们的发现与来自后向误差分析的理论预测进行比较。这项练习为辛积分的几何性质提供了深刻而具体的见解。[@problem_id:3409974]", "problem": "构建一个完整的、可运行的程序，通过对测量得到的能量时间序列进行关于时间步长的多项式拟合，来研究辛分子动力学积分器的影子哈密顿量的辨识问题，并将拟合系数与理论后向误差分析预测的系数进行比较。使用一维谐振子作为模型系统，其质量为单位1，角频率为 $\\omega$。其基本出发点是牛顿第二定律和哈密顿动力学：$\\dot{q} = \\partial H / \\partial p$、$\\dot{p} = -\\partial H / \\partial q$，哈密顿量为 $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$。数值积分器是时间可逆的辛速度Verlet方法，以时间步长 $\\Delta t$ 应用：\n- $p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\, \\omega^2 q_n$，\n- $q_{n+1} = q_n + \\Delta t \\, p_{n+\\frac{1}{2}}$，\n- $p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\, \\omega^2 q_{n+1}$。\n\n目标是通过将时间平均的真实能量与其初始值的偏差拟合为 $\\Delta t^2$ 的多项式，从而经验性地检测出辛方法近似守恒的影子哈密顿量 $\\tilde{H}$，然后与通过后向误差分析获得的理论预测进行比较。\n\n您的程序必须基于第一性原理实现以下步骤：\n1. 对于每个指定的 $\\Delta t$，使用速度Verlet方案，从指定的初始条件 $(q_0, p_0)$ 开始，模拟谐振子运动达预设的步数 $N$。在每个离散时间 $t_n = n \\, \\Delta t$，计算并累加真实能量 $E_n = \\frac{1}{2} p_n^2 + \\frac{1}{2} \\omega^2 q_n^2$。计算时间平均值 $\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n$。\n2. 对于案例中的一组 $\\Delta t$ 值，构建数据对 $\\left(u, y\\right)$，其中 $u = (\\Delta t)^2$ 且 $y = \\overline{E}(\\Delta t) - E_0$，而 $E_0 = \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2$ 是初始真实能量。对提供的 $u$ 值，通过最小二乘法拟合模型 $y \\approx c_2 \\, u + c_4 \\, u^2$，以获得经验系数 $c_2^{\\mathrm{emp}}$ 和 $c_4^{\\mathrm{emp}}$。\n3. 使用后向误差分析，独立推导影子哈密顿量主导修正系数的理论预测。对于应用于谐振子二次型哈密顿量的速度Verlet方法，存在一个被离散映射所守恒的精确二次不变量（影子能量）$\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2$。将 $\\tilde{E} - E$ 按 $(\\Delta t)$ 的幂次展开，得到 $\\tilde{E} - E = -\\frac{\\omega^4 q^2}{8} (\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)$。因此，能量偏差的多项式近似的理论系数为 $c_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8}$ 和 $c_4^{\\mathrm{th}} = 0$。\n4. 对每个测试案例，计算并报告绝对误差 $\\left|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}\\right|$ 和 $\\left|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}\\right|$。\n\n所有量均为无量纲；不要包含物理单位。\n\n测试套件：\n- 案例1（一般小步长区域）：$\\omega = 1.0$, $q_0 = 1.0$, $p_0 = 0.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.05, 0.10, 0.15, 0.20\\}$。\n- 案例2（初始位置为零的边界情况）：$\\omega = 1.5$, $q_0 = 0.0$, $p_0 = 1.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.03, 0.05, 0.08, 0.10\\}$。\n- 案例3（混合初始条件，$\\Delta t$ 分布范围宽且远在稳定性范围内）：$\\omega = 0.7$, $q_0 = 0.8$, $p_0 = -0.6$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60\\}$。\n- 案例4（接近稳定性边界，大步长）：$\\omega = 1.0$, $q_0 = 0.5$, $p_0 = 0.2$, $N = 20000$, $\\Delta t \\in \\{0.40, 0.80, 1.20, 1.60, 1.80\\}$。此系统上速度Verlet方法的稳定性条件是 $\\omega \\, \\Delta t  2$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果。该列表必须按顺序包含每个案例的两个浮点数：$\\left|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}\\right|$ 和 $\\left|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}\\right|$。例如，格式必须是 $[e_{2,1},e_{4,1},e_{2,2},e_{4,2},e_{2,3},e_{4,3},e_{2,4},e_{4,4}]$，其中 $e_{2,i}$ 和 $e_{4,i}$ 表示案例 $i$ 的绝对误差。", "solution": "该问题要求通过将经验拟合系数与理论预测进行比较，来研究辛数值积分器的影子哈密顿量概念。物理系统是一维简谐振子，积分器是速度Verlet方法。\n\n核心原理基于哈密頓力学中辛积分器的特性。虽然这些积分器不能完美地守恒真实哈密顿量（能量）$H$，但它们能精确地守恒一个邻近的、修正过的哈密顿量，通常称为影子哈密顿量 $\\tilde{H}$。这一性质确保了长期稳定性并防止了系统性能量漂移，这些都是高质量几何积分器的标志。对于应用于简谐振子的速度Verlet方法这一特定情况，出现了一个罕见且方便的性质：影子哈密顿量不仅仅是一个形式上的无穷级数，而是离散映射的一个简单的、精确的二次不变量。\n\n系统的哈密顿量由下式给出：\n$$\nH(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2\n$$\n其中 $q$ 是位置，$p$ 是动量，$\\omega$ 是角频率。质量取为1。运动方程为 $\\dot{q} = p$ 和 $\\dot{p} = -\\omega^2 q$。\n\n速度Verlet算法通过以下步骤将系统从时间 $t_n = n \\Delta t$推进到 $t_{n+1} = (n+1) \\Delta t$：\n1.  将动量更新到中点：$p_{n+1/2} = p_n + \\frac{\\Delta t}{2} F(q_n)$，其中力为 $F(q) = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q$。\n    $$p_{n+1/2} = p_n + \\frac{\\Delta t}{2} (-\\omega^2 q_n) = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$$\n2.  将位置更新到下一步：\n    $$q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$$\n3.  使用新位置 $q_{n+1}$ 处的力，将动量从中点更新到完整步：\n    $$p_{n+1} = p_{n+1/2} - \\frac{\\Delta t}{2} \\omega^2 q_{n+1}$$\n\n该方法论涉及以下计算步骤：\n\n首先，对于测试案例中提供的每组参数，我们执行一系列数值模拟。每次模拟对应于给定集合中的一个特定时间步长 $\\Delta t$ 值。从初始条件 $(q_0, p_0)$ 开始，使用速度Verlet算法将系统演化 $N$ 步。在模拟过程中，在每一步 $n$ 计算真实能量 $E_n = H(q_n, p_n)$。模拟完成后，计算时间平均能量：\n$$\n\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n\n$$\n\n其次，我们分析这个时间平均能量与初始能量 $E_0 = H(q_0, p_0)$ 的偏差。根据后向误差分析，该偏差应为 $\\Delta t$ 的偶次幂级数。我们构建数据对 $(u, y)$，其中 $u = (\\Delta t)^2$ 且 $y = \\overline{E}(\\Delta t) - E_0$。然后我们将此数据拟合到一个二次多项式模型：\n$$\ny(u) \\approx c_2^{\\mathrm{emp}} u + c_4^{\\mathrm{emp}} u^2\n$$\n系数 $c_2^{\\mathrm{emp}}$ 和 $c_4^{\\mathrm{emp}}$ 通过线性最小二乘拟合确定。这可以表示为一个矩阵问题 $\\mathbf{A}\\mathbf{c} = \\mathbf{y}$，其中 $\\mathbf{y}$ 是观测到的能量偏差向量，$\\mathbf{c} = [c_2^{\\mathrm{emp}}, c_4^{\\mathrm{emp}}]^T$ 是待求的系数向量，而 $\\mathbf{A}$ 是设计矩阵，其行由每个 $\\Delta t_i$ 对应的 $[u_i, u_i^2]$ 组成。解由 $\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$ 给出。\n\n第三，我们计算理论基准系数。问题指出，对于此系统和积分器，存在一个精确的二次不变量（影子能量）：\n$$\n\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2\n$$\n这个影子能量 $\\tilde{E}$ 被离散动力学精确守恒，即对所有 $n$ 都有 $\\tilde{E}(q_n, p_n) = \\tilde{E}(q_0, p_0)$。\n问题基于影子能量与真实能量之间的初始偏差来定义理论系数：\n$$\n\\tilde{E}(q_0, p_0) - E_0 = \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 - \\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2 \\right] - \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 \\right] = -\\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2\n$$\n由此，问题将 $\\overline{E} - E_0$ 拟合的理论系数定义为：\n$$\nc_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8} \\quad \\text{and} \\quad c_4^{\\mathrm{th}} = 0\n$$\n这是一个微妙但重要的点：该理论值仅从初始状态 $(q_0, p_0)$ 推导得出，而经验拟合是基于时间平均能量 $\\overline{E}$。时间平均偏差 $\\overline{E}-E_0$ 的实际理论系数是 $\\frac{\\omega^4}{8}(\\overline{q^2}-q_0^2)$，这取决于数值轨迹上的时间平均位置平方。问题的定义建立了一个特定的、明确的比较，即比较时间平均的经验结果与基于初始条件的理论预测，这是一个有效且具有启发性的数值实验。\n\n最后，对于每个测试案例，我们计算经验拟合系数与理论定义系数之间的绝对误差：$|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ 和 $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$。所有测试案例的这些误差的集合构成了最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the shadow Hamiltonian for a symplectic integrator by fitting\n    the energy time series of a harmonic oscillator and comparing with theory.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General small-step regime\n        {\n            \"omega\": 1.0, \"q0\": 1.0, \"p0\": 0.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.05, 0.10, 0.15, 0.20])\n        },\n        # Case 2: Edge with zero initial position\n        {\n            \"omega\": 1.5, \"q0\": 0.0, \"p0\": 1.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.03, 0.05, 0.08, 0.10])\n        },\n        # Case 3: Mixed initial conditions, broad dt spread\n        {\n            \"omega\": 0.7, \"q0\": 0.8, \"p0\": -0.6, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60])\n        },\n        # Case 4: Near the stability boundary\n        {\n            \"omega\": 1.0, \"q0\": 0.5, \"p0\": 0.2, \"N\": 20000,\n            \"dts\": np.array([0.40, 0.80, 1.20, 1.60, 1.80])\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega = case[\"omega\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        N = case[\"N\"]\n        dts = case[\"dts\"]\n        \n        u_values = []\n        y_values = []\n        \n        E0 = 0.5 * p0**2 + 0.5 * omega**2 * q0**2\n        \n        for dt in dts:\n            q, p = q0, p0\n            total_energy = 0.0\n            \n            # Pre-calculate constant factor for force\n            force_factor = omega**2\n            \n            # Simulation loop\n            for _ in range(N):\n                # Calculate and accumulate energy for the current step (q_n, p_n)\n                current_energy = 0.5 * p**2 + 0.5 * force_factor * q**2\n                total_energy += current_energy\n                \n                # Velocity Verlet integration step\n                # p_{n+1/2} = p_n - (dt/2) * omega^2 * q_n\n                p_half = p - 0.5 * dt * force_factor * q\n                # q_{n+1} = q_n + dt * p_{n+1/2}\n                q_next = q + dt * p_half\n                # p_{n+1} = p_{n+1/2} - (dt/2) * omega^2 * q_{n+1}\n                p_next = p_half - 0.5 * dt * force_factor * q_next\n                \n                q, p = q_next, p_next\n            \n            # Calculate time-averaged energy and its deviation from initial\n            E_avg = total_energy / N\n            y = E_avg - E0\n            \n            # Store u = dt^2 and y for fitting\n            u_values.append(dt**2)\n            y_values.append(y)\n            \n        # Perform least-squares fit: y = c2*u + c4*u^2\n        u_vals = np.array(u_values)\n        y_vals = np.array(y_values)\n        \n        # Design matrix A for the fit Ax = y\n        # Column 1 is u, Column 2 is u^2\n        A = np.vstack([u_vals, u_vals**2]).T\n        \n        # Solve for coefficients [c2, c4]\n        coeffs, _, _, _ = np.linalg.lstsq(A, y_vals, rcond=None)\n        c2_emp, c4_emp = coeffs[0], coeffs[1]\n        \n        # Calculate theoretical coefficients\n        # c2_th fromtilde{E} - E evaluated at t=0\n        c2_th = - (omega**4 * q0**2) / 8.0\n        c4_th = 0.0\n        \n        # Calculate absolute errors\n        error_c2 = np.abs(c2_emp - c2_th)\n        error_c4 = np.abs(c4_emp - c4_th)\n        \n        results.extend([error_c2, error_c4])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3409974"}]}