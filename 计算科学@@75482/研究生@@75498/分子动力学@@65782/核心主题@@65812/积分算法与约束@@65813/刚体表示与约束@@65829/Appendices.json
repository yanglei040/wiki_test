{"hands_on_practices": [{"introduction": "这个练习旨在对比两种用于维持分子刚性的经典算法：迭代式的 SHAKE 和解析式的 SETTLE。通过对一个水分子模型同时实现这两种算法，你将直观地理解它们在计算方法和性能上的差异。这项实践突显了分子的几何特性（例如键角趋于线性）如何影响迭代方法的数值稳定性与收敛性 ([@problem_id:3442797])，这是设计稳健模拟时的一个关键概念。", "problem": "要求您设计并实现一个程序，用于比较解析刚体投影（类似SETTLE）与迭代约束强制方案（类似SHAKE）在处理具有刚性内几何构型的单个三原子分子（类似水分子的三原子体系）时的表现。您的比较指标是迭代方法达到指定容差 $\\epsilon$ 所需的迭代次数，记为 $k$。您还必须将观察到的迭代次数与约束雅可比矩阵的条件数联系起来。\n\n基本原理和物理模型：\n- 考虑三个点质量，其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，索引为 $i \\in \\{O, H_1, H_2\\}$。它们的质量分别为 $m_O$、$m_H$ 和 $m_H$。\n- 完整约束（Holonomic constraints）强制原子对之间的距离固定：$\\|\\mathbf{r}_O - \\mathbf{r}_{H_1}\\| = b$、$\\|\\mathbf{r}_O - \\mathbf{r}_{H_2}\\| = b$ 以及 $\\|\\mathbf{r}_{H_1} - \\mathbf{r}_{H_2}\\| = d_{HH}$，其中 $d_{HH}$ 通过余弦定理由指定的角度 $\\theta$ 确定。该分子位于一个平面内，但必须在三维空间中处理。\n- 使用质量 $m_O = 16$ 和 $m_H = 1$（无量纲质量单位），键长 $b = 0.09572$ 纳米，以及以度为单位指定的角度 $\\theta$；在构建数学表达式时将角度转换为弧度。所有距离以纳米表示，所有指定角度以度表示。计算内部的角度单位必须是弧度。\n- 从约束动力学的角度来看，牛顿第二定律和带有拉格朗日乘子的完整约束意味着需要一个校正步骤来求解位移 $\\Delta \\mathbf{r}$ 以消除约束违背。迭代的类 SHAKE 方案应用源自距离约束的局部线性和质量加权的顺序成对校正。相比之下，解析的类 SETTLE 投影利用刚体特性，通过刚性变换将刚性模板对齐到无约束位置，从而计算出一次性投影，精确满足所需的内几何距离。\n\n所需任务：\n1. 为三个原子定义一个理想的刚性内几何构型：氧原子位于原点，$H_1$ 位于 $x$ 轴上距离原点为 $b$ 的位置，$H_2$ 位于 $xy$ 平面内，使得在 $O$ 处的夹角等于 $\\theta$。使用此构型为给定的 $\\theta$ 生成一个以纳米为单位的模板坐标集 $\\mathbf{R}_0 \\in \\mathbb{R}^{3 \\times 3}$。\n2. 通过向 $\\mathbf{R}_0$ 的每个原子添加一个小的、固定的、确定性的偏移量（以纳米为单位），构建一个受扰动的无约束坐标集 $\\mathbf{R}'$。这模拟了一个违背了约束的无约束积分步骤。\n3. 实现一个解析刚体投影，找到将模板 $\\mathbf{R}_0$ 映射到受扰动位置 $\\mathbf{R}'$ 的质量加权最佳拟合刚性变换（旋转和平移）。根据构造，结果 $\\mathbf{R}_{\\text{analytic}}$ 精确满足内几何距离 $b, b, d_{HH}$。使用质量加权的正交 Procrustes 对齐（也称为带质量的 Kabsch 算法）作为您的解析“类 SETTLE”投影。\n4. 实现一个迭代的类 SHAKE 求解器，从 $\\mathbf{R}'$ 开始，按固定顺序对三个约束 $(O,H_1)$、$(O,H_2)$ 和 $(H_1,H_2)$ 应用顺序成对距离约束校正，循环进行直到所有三个距离误差都低于给定的容差 $\\epsilon$（纳米）或达到最大迭代次数。将对所有约束的一次完整扫描计为一次迭代 $k$。\n5. 对于每种情况，计算三个标量约束相对于九个笛卡尔坐标的约束雅可比矩阵 $\\mathbf{J}$，在 $\\mathbf{R}_{\\text{analytic}}$ 处求值。设 $\\mathbf{M}$ 是一个 $9 \\times 9$ 的对角质量矩阵，其对角线元素按坐标顺序 $(O_x, O_y, O_z, H1_x, H1_y, H1_z, H2_x, H2_y, H2_z)$ 排列为 $(m_O, m_O, m_O, m_H, m_H, m_H, m_H, m_H, m_H)$。构建质量加权的格拉姆矩阵 $\\mathbf{G} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$。报告其 2-范数条件数 $\\kappa(\\mathbf{G})$，作为约束耦合和病态程度的量化指标。\n6. 按照惯例，将解析方法的“迭代次数”定义为 $k_{\\text{analytic}} = 1$（单次解析投影），并报告类 SHAKE 求解器的实际计数的 $k_{\\text{iter}}$。\n7. 对于所有测试用例，您必须以单行列表的形式生成输出，该列表包含多个子列表。每个内部列表的形式必须为 $[\\theta_{\\text{deg}}, \\epsilon, k_{\\text{iter}}, k_{\\text{analytic}}, \\kappa(\\mathbf{G})]$，其中所有条目均为数值（整数或浮点数）。\n\n需使用的数学和算法基础：\n- 使用完整距离约束 $C_\\alpha(\\mathbf{r}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_\\alpha^2 = 0$，其中 $d_\\alpha \\in \\{b, b, d_{HH}\\}$。雅可比矩阵的行是相对于九个笛卡尔坐标的梯度 $\\nabla C_\\alpha$。\n- 使用牛顿第二定律和拉格朗日乘子作为推导类 SHAKE 成对校正的基本基础。对解析刚体投影使用质量加权的最佳拟合对齐（刚性旋转和平移）。\n\n角度和单位要求：\n- 所有距离必须以纳米为单位表示和计算。\n- 所有角度作为参数提供时必须以度为单位指定；内部计算必须转换为弧度。\n- 容差 $\\epsilon$ 是以纳米为单位的距离容差。\n- 不涉及百分比。\n\n测试套件和覆盖范围：\n您必须实现您的程序，以在没有任何用户输入的情况下运行以下六个测试用例。对于每个用例，使用给定的角度 $\\theta_{\\text{deg}}$ 和相同的键长 $b$ 定义模板几何构型，通过应用相同的固定小偏移量形成 $\\mathbf{R}'$，运行两种投影方法，并报告所要求的结果。\n- 用例 1：$\\theta_{\\text{deg}} = 104.5$，$\\epsilon = 1.0 \\times 10^{-4}$。\n- 用例 2：$\\theta_{\\text{deg}} = 160.0$，$\\epsilon = 1.0 \\times 10^{-4}$。\n- 用例 3：$\\theta_{\\text{deg}} = 175.0$，$\\epsilon = 1.0 \\times 10^{-4}$。\n- 用例 4：$\\theta_{\\text{deg}} = 175.0$，$\\epsilon = 1.0 \\times 10^{-6}$。\n- 用例 5：$\\theta_{\\text{deg}} = 179.0$，$\\epsilon = 1.0 \\times 10^{-4}$。\n- 用例 6：$\\theta_{\\text{deg}} = 104.5$，$\\epsilon = 1.0 \\times 10^{-6}$。\n\n数值和终止细节：\n- 对迭代求解器使用最大迭代次数 $k_{\\max} = 10000$。如果算法在 $k_{\\max}$ 次迭代内未能收敛到容差，则该测试用例返回 $k_{\\text{iter}} = -1$。\n- 在迭代求解器中，将每个约束的误差定义为 $|\\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_\\alpha|$，收敛测试定义为所有约束上的这些误差的最大值小于或等于 $\\epsilon$。\n- 使用相同的固定小确定性偏移量（以纳米为单位）从 $\\mathbf{R}_0$ 构建 $\\mathbf{R}'$：向 $O$ 添加 $(+0.002, -0.001, 0.0)$，向 $H_1$ 添加 $(-0.0015, +0.0012, 0.0)$，向 $H_2$ 添加 $(+0.0005, -0.0008, 0.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由六个测试用例结果组成的逗号分隔列表，每个用例结果本身都是一个用方括号括起来的逗号分隔列表。例如：“[[theta1,epsilon1,k_iter1,k_analytic1,kappa1],[theta2,epsilon2,k_iter2,k_analytic2,kappa2],...]”，不含任何额外文本。\n\n您的实现必须是一个完整、可运行的程序。", "solution": "该问题要求在分子动力学背景下，对两种不同的方法进行比较分析，这两种方法用于对三原子分子施加刚体约束。第一种方法是类似于 SETTLE 算法的直接解析投影，而第二种是类似于 SHAKE 算法的迭代顺序校正方案。比较的主要指标是收敛所需的迭代次数，以及质量加权约束格拉姆矩阵的条件数，后者量化了约束系统的数值稳定性。\n\n**1. 分子模型和约束定义**\n\n该系统由三个原子组成，分别指定为 $O$、$H_1$ 和 $H_2$，其质量（以原子质量单位计）分别为 $m_O = 16$ 和 $m_H = 1$。它们的位置由向量 $\\mathbf{r}_O, \\mathbf{r}_{H_1}, \\mathbf{r}_{H_2} \\in \\mathbb{R}^3$ 给出。分子的内几何构型由三个完整距离约束定义：\n1. $O$ 和 $H_1$ 之间的距离是固定的：$\\|\\mathbf{r}_O - \\mathbf{r}_{H_1}\\| = b$。\n2. $O$ 和 $H_2$ 之间的距离是固定的：$\\|\\mathbf{r}_O - \\mathbf{r}_{H_2}\\| = b$。\n3. $H_1$ 和 $H_2$ 之间的距离是固定的：$\\|\\mathbf{r}_{H_1} - \\mathbf{r}_{H_2}\\| = d_{HH}$。\n\n键长为 $b = 0.09572$ nm。氢原子间距离 $d_{HH}$ 由键角 $\\theta = \\angle H_1 O H_2$ 通过余弦定理确定：$d_{HH}^2 = b^2 + b^2 - 2b^2\\cos\\theta = 2b^2(1 - \\cos\\theta)$。\n\n为了分析，数值上更倾向于使用距离的平方。因此，约束被表述为一组函数 $C_\\alpha(\\mathbf{r}) = 0$：\n$$ C_1(\\mathbf{r}) = \\|\\mathbf{r}_O - \\mathbf{r}_{H_1}\\|^2 - b^2 = 0 $$\n$$ C_2(\\mathbf{r}) = \\|\\mathbf{r}_O - \\mathbf{r}_{H_2}\\|^2 - b^2 = 0 $$\n$$ C_3(\\mathbf{r}) = \\|\\mathbf{r}_{H_1} - \\mathbf{r}_{H_2}\\|^2 - d_{HH}^2 = 0 $$\n\n对于给定的角度 $\\theta$，构建一个理想的参考几何构型，即模板 $\\mathbf{R}_0$。氧原子置于原点 $\\mathbf{r}_{O,0} = (0,0,0)$。第一个氢原子 $H_1$ 置于 $x$ 轴上，$\\mathbf{r}_{H_1,0} = (b,0,0)$。第二个氢原子 $H_2$ 置于 $xy$ 平面内，$\\mathbf{r}_{H_2,0} = (b\\cos\\theta, b\\sin\\theta, 0)$，以满足角度约束。然后，通过对这些模板位置添加小的、确定性的扰动来生成一个无约束构型 $\\mathbf{R}'$，模拟动力学模拟中无约束积分步骤的结果。\n\n**2. 解析刚体投影（类 SETTLE）**\n\n此方法将分子视为单个刚体，并找到将理想模板 $\\mathbf{R}_0$ 对齐到受扰动位置 $\\mathbf{R}'$ 的最优刚性变换（旋转 $\\mathbf{U}$ 和平移 $\\mathbf{t}$）。“最佳拟合”定义为使质量加权的平方偏差和最小化的变换：\n$$ L(\\mathbf{U}, \\mathbf{t}) = \\sum_{i \\in \\{O,H_1,H_2\\}} m_i \\|\\mathbf{r}'_i - (\\mathbf{U}\\mathbf{r}_{0,i} + \\mathbf{t})\\|^2 $$\n这是一个质量加权的正交 Procrustes 问题，可使用 Kabsch 算法高效求解：\n1. **中心化**：计算两个坐标集的质量加权质心 $\\mathbf{c}_0 = \\frac{\\sum m_i \\mathbf{r}_{0,i}}{\\sum m_i}$ 和 $\\mathbf{c}' = \\frac{\\sum m_i \\mathbf{r}'_i}{\\sum m_i}$。然后通过减去各自的质心来中心化坐标：$\\mathbf{p}_{0,i} = \\mathbf{r}_{0,i} - \\mathbf{c}_0$ 和 $\\mathbf{p}'_i = \\mathbf{r}'_i - \\mathbf{c}'$。\n2. **协方差矩阵**：通过中心化、质量加权的位置向量的外积构建一个 $3 \\times 3$ 的协方差矩阵 $\\mathbf{H}$：$\\mathbf{H} = \\sum_i m_i \\mathbf{p}_{0,i} (\\mathbf{p}'_i)^\\top$。\n3. **奇异值分解 (SVD)**：计算 $\\mathbf{H}$ 的 SVD，得到 $\\mathbf{H} = \\mathbf{L} \\mathbf{\\Sigma} \\mathbf{R}^\\top$。\n4. **最优旋转**：最优旋转矩阵为 $\\mathbf{U} = \\mathbf{R} \\mathbf{L}^\\top$。需进行特殊检查以确保 $\\mathbf{U}$ 是纯旋转（即 $\\det(\\mathbf{U}) = +1$）而非反射。如果 $\\det(\\mathbf{U}) = -1$，则在重新计算 $\\mathbf{U}$ 之前，将 $\\mathbf{L}$ 的其中一列反转。\n5. **变换**：通过将最优旋转应用于中心化的模板并加上受扰动集的质心，获得最终满足约束的位置：$\\mathbf{R}_{\\text{analytic},i} = \\mathbf{U} \\mathbf{p}_{0,i} + \\mathbf{c}'$。根据构造，所得集合 $\\mathbf{R}_{\\text{analytic}}$ 具有与 $\\mathbf{R}_0$ 完全相同的内几何构型。整个过程构成一个单一的解析步骤，因此其迭代次数定义为 $k_{\\text{analytic}} = 1$。\n\n**3. 迭代约束求解器（类 SHAKE）**\n\n类 SHAKE 方法以迭代方式校正约束违背。它顺序处理三个距离约束中的每一个，更新所涉及原子的位置。对所有约束的一次完整遍历构成一次迭代。此过程重复进行，直到所有约束违背都低于指定的容差 $\\epsilon$。\n\n对于单个距离约束 $C_\\alpha = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_\\alpha^2 = 0$，其校正是从线性化约束方程推导出来的。位置通过位移 $\\Delta\\mathbf{r}_k$ 进行更新，该位移与约束梯度成正比，并按质量的倒数加权：$\\Delta\\mathbf{r}_k = \\lambda_\\alpha m_k^{-1} \\nabla_k C_\\alpha$。标量拉格朗日乘子 $\\lambda_\\alpha$ 由校正后约束必须满足的要求确定，即 $C_\\alpha(\\mathbf{r} + \\Delta\\mathbf{r}) \\approx C_\\alpha(\\mathbf{r}) + \\nabla C_\\alpha \\cdot \\Delta\\mathbf{r} = 0$。这导致：\n$$ \\lambda_\\alpha = - \\frac{C_\\alpha(\\mathbf{r})}{\\sum_k m_k^{-1} \\|\\nabla_k C_\\alpha\\|^2} $$\n对于原子 $i$ 和 $j$ 之间的距离约束，梯度为 $\\nabla_i C_\\alpha = 2(\\mathbf{r}_i - \\mathbf{r}_j)$ 和 $\\nabla_j C_\\alpha = -2(\\mathbf{r}_i - \\mathbf{r}_j)$，所有其他梯度为零。将这些代入 $\\lambda_\\alpha$ 的公式和位移表达式，即可得到 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的显式更新。\n\n该算法流程如下：\n1. 将位置初始化为受扰动状态，$\\mathbf{R}_{\\text{current}} = \\mathbf{R}'$。\n2. 对于迭代 $k = 1, 2, \\dots, k_{\\max}$：\n    a. 对 $(O, H_1)$ 约束应用校正位移。\n    b. 使用新更新的位置，对 $(O, H_2)$ 约束应用校正。\n    c. 最后，使用最新的位置，对 $(H_1, H_2)$ 约束进行校正。\n    d. 在完整扫描后，计算最大约束误差 $\\max_\\alpha(|\\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_\\alpha|)$。\n    e. 如果最大误差小于或等于容差 $\\epsilon$，则算法收敛。返回迭代次数 $k_{\\text{iter}} = k$。\n3. 如果在 $k_{\\max} = 10000$ 次迭代内未达到收敛，则终止该过程，并返回 $k_{\\text{iter}} = -1$。\n\n**4. 约束条件数分析**\n\n像 SHAKE 这样的迭代方案的收敛速度与约束系统的条件数密切相关。这可以通过分析约束雅可比矩阵 $\\mathbf{J}$ 和相关的质量加权格拉姆矩阵 $\\mathbf{G}$ 来量化。\n雅可比矩阵是一个 $3 \\times 9$ 的矩阵，其元素是三个约束函数相对于九个原子笛卡尔坐标的偏导数，$J_{\\alpha k} = \\partial C_\\alpha / \\partial q_k$。它的行是约束梯度，例如，第一行是 $[\\nabla_{\\mathbf{r}_O} C_1, \\nabla_{\\mathbf{r}_{H1}} C_1, \\nabla_{\\mathbf{r}_{H2}} C_1]$。\n\n质量加权的格拉姆矩阵是一个 $3 \\times 3$ 的矩阵，定义为 $\\mathbf{G} = \\mathbf{J} \\mathbf{M}^{-1} \\mathbf{J}^\\top$，其中 $\\mathbf{M}$ 是 $9 \\times 9$ 的对角质量矩阵。元素 $G_{\\alpha \\beta} = (\\nabla C_\\alpha) \\cdot \\mathbf{M}^{-1} (\\nabla C_\\beta)$ 表示一个约束梯度到另一个约束梯度上的质量加权投影。\n该矩阵的 2-范数条件数 $\\kappa(\\mathbf{G}) = \\|\\mathbf{G}\\|_2 \\|\\mathbf{G}^{-1}\\|_2$ 是其最大特征值与最小特征值之比。一个大的 $\\kappa(\\mathbf{G})$ 值表明该矩阵接近奇异，这种情况发生在约束梯度（$\\mathbf{J}$ 的行）近似线性相关时。\n\n在物理上，对于三原子分子，当角度 $\\theta$ 接近 $180^\\circ$ 时，就会出现这种病态条件。在完全线性的构型中（$\\theta = 180^\\circ$），连接原子的向量（$\\mathbf{r}_O - \\mathbf{r}_{H_1}$、$\\mathbf{r}_O - \\mathbf{r}_{H_2}$、$\\mathbf{r}_{H_1} - \\mathbf{r}_{H_2}$）会共线。因此，约束梯度变得线性相关，使得 $\\mathbf{G}$ 奇异，$\\kappa(\\mathbf{G})$ 为无穷大。对于接近 $180^\\circ$ 的角度，$\\mathbf{G}$ 是病态的，这会减慢 SHAKE 算法的收敛速度，导致更高的迭代次数 $k_{\\text{iter}}$。然而，解析投影不受这种几何简并性的影响。\n\n该程序实现了这些算法，并为每个测试用例计算所需的值，从而展示了分子几何构型、约束条件数和算法性能之间的关系。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\n# Problem constants\nM_O = 16.0\nM_H = 1.0\nBOND_LENGTH = 0.09572  # nm\nMASSES = np.array([M_O, M_H, M_H])\nOFFSETS = np.array([\n    [0.002, -0.001, 0.0],   # O\n    [-0.0015, 0.0012, 0.0],  # H1\n    [0.0005, -0.0008, 0.0]   # H2\n])\nK_MAX = 10000\n\n# Atom indices for clarity\nO_IDX, H1_IDX, H2_IDX = 0, 1, 2\n\ndef get_template_geometry(theta_deg, b):\n    \"\"\"Constructs the ideal template coordinates for a given angle.\"\"\"\n    theta_rad = np.deg2rad(theta_deg)\n    r_o = np.array([0.0, 0.0, 0.0])\n    r_h1 = np.array([b, 0.0, 0.0])\n    r_h2 = np.array([b * np.cos(theta_rad), b * np.sin(theta_rad), 0.0])\n    r0 = np.array([r_o, r_h1, r_h2])\n    return r0\n\ndef analytic_projection(r0, r_prime, masses):\n    \"\"\"\n    Performs a mass-weighted rigid-body alignment (Kabsch algorithm)\n    to find the best-fit transformation from r0 to r_prime.\n    \"\"\"\n    # 1. Compute mass-weighted centroids and center the coordinates\n    total_mass = np.sum(masses)\n    c0 = np.sum(r0 * masses[:, np.newaxis], axis=0) / total_mass\n    c_prime = np.sum(r_prime * masses[:, np.newaxis], axis=0) / total_mass\n    \n    p0 = r0 - c0\n    p_prime = r_prime - c_prime\n\n    # 2. Compute the covariance matrix H = P0^T W P_prime\n    w_diag = np.diag(masses)\n    h_matrix = p0.T @ w_diag @ p_prime\n    \n    # 3. SVD of H\n    l_svd, _, r_svd_t = svd(h_matrix)\n    r_svd = r_svd_t.T\n\n    # 4. Compute optimal rotation matrix U, correcting for reflections\n    u_matrix = r_svd @ l_svd.T\n    if np.linalg.det(u_matrix)  0:\n        l_svd[:, -1] *= -1\n        u_matrix = r_svd @ l_svd.T\n        \n    # 5. Apply the transformation to the original template positions\n    r_analytic = (p0 @ u_matrix.T) + c_prime\n    \n    return r_analytic\n\ndef iterative_solver(r_prime, target_distances, masses, epsilon, k_max):\n    \"\"\"\n    Applies sequential SHAKE-like corrections until convergence.\n    \"\"\"\n    r_current = np.copy(r_prime)\n    inv_masses = 1.0 / masses\n    \n    constraints = [\n        (O_IDX, H1_IDX, target_distances[0]**2),\n        (O_IDX, H2_IDX, target_distances[1]**2),\n        (H1_IDX, H2_IDX, target_distances[2]**2)\n    ]\n\n    for k in range(1, k_max + 1):\n        # One sweep over all constraints (Gauss-Seidel like)\n        for i, j, d_sq in constraints:\n            r_i, r_j = r_current[i], r_current[j]\n            r_ij = r_i - r_j\n            r_ij_sq = np.dot(r_ij, r_ij)\n\n            # Constraint value for C(r) = ||r_i-r_j||^2 - d^2\n            constraint_val = r_ij_sq - d_sq\n            \n            # Denominator term for lambda calculation\n            denom = 4.0 * r_ij_sq * (inv_masses[i] + inv_masses[j])\n            \n            if abs(denom)  1e-12: continue\n\n            lambda_ = -constraint_val / denom\n            \n            # Displacements based on linearized correction\n            delta_r_i = (2.0 * lambda_ * inv_masses[i]) * r_ij\n            delta_r_j = (-2.0 * lambda_ * inv_masses[j]) * r_ij\n            \n            r_current[i] += delta_r_i\n            r_current[j] += delta_r_j\n            \n        # Check for convergence after a full sweep\n        max_error = 0.0\n        for i, j, d_sq in constraints:\n             dist = np.linalg.norm(r_current[i] - r_current[j])\n             error = abs(dist - np.sqrt(d_sq))\n             if error > max_error:\n                 max_error = error\n        \n        if max_error = epsilon:\n            return k\n            \n    return -1 # Return -1 if max iterations reached\n\ndef compute_kappa(r_analytic, masses):\n    \"\"\"\n    Computes the condition number of the mass-weighted Gram matrix G.\n    \"\"\"\n    ro, rh1, rh2 = r_analytic[O_IDX], r_analytic[H1_IDX], r_analytic[H2_IDX]\n    \n    # Constraint gradients (3-vectors)\n    r_oh1 = ro - rh1\n    r_oh2 = ro - rh2\n    r_h1h2 = rh1 - rh2\n    \n    # Jacobian (3x9 matrix)\n    j_matrix = np.zeros((3, 9))\n    j_matrix[0, 0:3], j_matrix[0, 3:6] = 2 * r_oh1, -2 * r_oh1\n    j_matrix[1, 0:3], j_matrix[1, 6:9] = 2 * r_oh2, -2 * r_oh2\n    j_matrix[2, 3:6], j_matrix[2, 6:9] = 2 * r_h1h2, -2 * r_h1h2\n    \n    # Inverse mass matrix M^-1 (9x9 diagonal)\n    inv_m_diag = np.array([1/M_O]*3 + [1/M_H]*3 + [1/M_H]*3)\n    m_inv = np.diag(inv_m_diag)\n    \n    # Gram Matrix G = J M^-1 J^T (3x3)\n    g_matrix = j_matrix @ m_inv @ j_matrix.T\n    \n    kappa = np.linalg.cond(g_matrix)\n    return kappa\n\ndef run_case(theta_deg, epsilon):\n    \"\"\"Runs a single test case and returns the results.\"\"\"\n    # 1. Define template and perturbed geometries\n    r0 = get_template_geometry(theta_deg, BOND_LENGTH)\n    r_prime = r0 + OFFSETS\n    \n    # 2. Define target distances from the ideal template\n    d_oh1 = BOND_LENGTH\n    d_oh2 = BOND_LENGTH\n    d_h1h2 = np.linalg.norm(r0[H1_IDX] - r0[H2_IDX])\n    target_distances = (d_oh1, d_oh2, d_h1h2)\n    \n    # 3. Analytic projection\n    r_analytic = analytic_projection(r0, r_prime, MASSES)\n    k_analytic = 1\n    \n    # 4. Iterative solver\n    k_iter = iterative_solver(r_prime, target_distances, MASSES, epsilon, K_MAX)\n    \n    # 5. Constraint conditioning analysis\n    kappa_g = compute_kappa(r_analytic, MASSES)\n    \n    return [theta_deg, epsilon, k_iter, k_analytic, kappa_g]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (104.5, 1.0e-4),\n        (160.0, 1.0e-4),\n        (175.0, 1.0e-4),\n        (175.0, 1.0e-6),\n        (179.0, 1.0e-4),\n        (104.5, 1.0e-6),\n    ]\n\n    results = []\n    for theta, eps in test_cases:\n        result = run_case(theta, eps)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # The str() representation of a list is \"[item1, item2, ...]\"\n    # Joining these with commas gives the required \"[[...],[...]]\" format.\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3442797"}, {"introduction": "在理解了基本的约束方法之后，这个练习将深入探讨高性能 LINCS 算法的稳定性。你将通过编程为几种特殊设计的分子拓扑结构构建约束耦合矩阵 $A$，并分析其谱半径 $\\rho(A)$ 如何决定算法的收敛性。这项实践提供了一种诊断 LINCS 中潜在数值不稳定性的具体方法 ([@problem_id:3442814])，将抽象的线性代数概念与实际的模拟结果联系起来。", "problem": "考虑应用于支链分子的分子动力学中的全息距离约束。每个约束的形式为 $g_k(\\mathbf{q}) = \\lVert \\mathbf{r}_b - \\mathbf{r}_a \\rVert - \\ell_k = 0$，其中 $\\mathbf{q}$ 是笛卡尔坐标，$\\mathbf{r}_a$ 和 $\\mathbf{r}_b$ 是定义第 $k$ 个受约束键的原子位置，而 $\\ell_k$ 是目标键长。约束雅可比矩阵 $J$ 的行是 $\\nabla g_k$，其非零块为 $\\partial g_k/\\partial \\mathbf{r}_a = \\mathbf{u}_k$ 和 $\\partial g_k/\\partial \\mathbf{r}_b = -\\mathbf{u}_k$，其中 $\\mathbf{u}_k = (\\mathbf{r}_b - \\mathbf{r}_a)/\\lVert \\mathbf{r}_b - \\mathbf{r}_a \\rVert$ 是沿着键方向的单位向量。设质量矩阵 $M$ 为对角矩阵，其对角元为原子 $i$ 的质量 $m_i$ 在三个笛卡尔分量上的重复。对称约束耦合矩阵 $G$ 定义为 $G = J M^{-1} J^\\top$；其矩阵元可根据定义和线性性质得出：\n- 对于连接原子 $(a,b)$ 的约束 $i$，对角元为 $G_{ii} = \\frac{1}{m_a} + \\frac{1}{m_b}$。\n- 对于约束 $i:(a,b)$ 和 $j:(c,d)$，非对角元是共享原子的贡献之和：$G_{ij} = \\sum_{k \\in \\{a,b\\} \\cap \\{c,d\\}} \\sigma_k \\frac{1}{m_k} \\mathbf{u}_i \\cdot \\mathbf{u}_j$，其中 $\\sigma_k \\in \\{+1,-1\\}$ 来自雅可比矩阵中的符号，如果原子 $k$ 在两个约束中作为相同的端点出现，则 $\\sigma_k$ 等于 $+1$；如果作为相反的端点出现，则等于 $-1$。\n\n定义归一化约束耦合矩阵 $A$（对角线元素为零），其中 $A_{ij} = \\frac{G_{ij}}{\\sqrt{G_{ii} G_{jj}}}$（$i \\neq j$）且 $A_{ii} = 0$。线性约束求解器 (LINCS) 通过一个截断的诺伊曼级数来校正约束，该级数的收敛性由 $A$ 的谱半径 $\\rho(A)$ 决定。对于 $\\rho(A)  1$，在 $p$ 阶截断的误差有一个几何级数界 $E_p \\le \\frac{\\rho(A)^{p+1}}{1 - \\rho(A)}$。如果 $\\rho(A) \\ge 1$，级数发散，该方法失效。对于 $\\rho(A)  1$，如果误差界超过用户指定的容差 $\\tau$，即 $\\frac{\\rho(A)^{p+1}}{1 - \\rho(A)}  \\tau$，则定义为在 $p$ 阶失效；否则，在该阶没有失效。\n\n任务：为每个测试案例以编程方式构建约束耦合矩阵 $A$，计算 $\\rho(A)$，并根据上述准则将失效情况映射为 LINCS 阶数的函数。\n\n使用以下支链分子测试套件，每个案例都指定了原子位置（单位为纳米）、相等的原子质量 $m_i$（单位为道尔顿，在上述无量纲公式中处理方式一致）以及作为原子索引对 $(a,b)$ 的距离约束列表。键长 $\\ell_k$ 由所提供的原子位置隐含给出；只需要单位方向。\n\n- 测试案例1（三分支，约束分离良好）：\n    - 原子位置：中心原子 0 位于 $(0,0,0)$；叶原子 1 位于 $(L,0,0)$，2 位于 $(-\\frac{L}{2}, \\frac{\\sqrt{3}}{2}L, 0)$，3 位于 $(-\\frac{L}{2}, -\\frac{\\sqrt{3}}{2}L, 0)$，其中 $L = 0.1$ nm。\n    - 质量：$m_0 = m_1 = m_2 = m_3 = 12$ 道尔顿。\n    - 约束：$(0,1)$、$(0,2)$、$(0,3)$。\n\n- 测试案例2（三分支，约束近乎共线）：\n    - 原子位置：中心原子 0 位于 $(0,0,0)$；叶原子 1 位于 $(L, 0, 0)$，2 位于 $(L, 0.1L, 0)$，3 位于 $(L, -0.1L, 0)$，其中 $L = 0.1$ nm。\n    - 质量：$m_0 = m_1 = m_2 = m_3 = 12$ 道尔顿。\n    - 约束：$(0,1)$、$(0,2)$、$(0,3)$。\n\n- 测试案例3（四分支，约束共线）：\n    - 原子位置：中心原子 0 位于 $(0,0,0)$；叶原子 1 位于 $(L,0,0)$，2 位于 $(2L,0,0)$，3 位于 $(3L,0,0)$，4 位于 $(4L,0,0)$，其中 $L = 0.1$ nm。\n    - 质量：$m_0 = m_1 = m_2 = m_3 = m_4 = 12$ 道尔顿。\n    - 约束：$(0,1)$、$(0,2)$、$(0,3)$、$(0,4)$。\n\n使用 LINCS 阶数 $p \\in \\{1,2,4,8\\}$ 和容差 $\\tau = 10^{-4}$（无量纲）。对于每个测试案例，计算谱半径 $\\rho(A)$，并根据上述规则确定每个指定阶数的失效布尔值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序将所有测试案例和阶数的结果平铺展开：对于测试案例 $k$，先附加舍入到六位小数的 $\\rho(A)$，然后是四个对应于 $p = 1,2,4,8$ 的布尔值，接着处理下一个测试案例。例如，结构为 $[\\rho_1, \\text{break}_{1}, \\text{break}_{2}, \\text{break}_{4}, \\text{break}_{8}, \\rho_2, \\dots, \\rho_3, \\dots]$。所有输出都是无量纲的；输出中不需要物理单位。", "solution": "用户提出的问题要求分析线性约束求解器 (LINCS) 算法在三种特定分子构型下的收敛特性。这涉及到构建一个记为 $A$ 的归一化约束耦合矩阵，并评估其谱半径 $\\rho(A)$。LINCS 算法的稳定性和收敛速度严重依赖于 $\\rho(A)$，该算法使用诺伊曼级数来逼近矩阵 $G$ 的逆。该问题在科学上是合理的、适定的，并提供了所有必要信息以得出一个唯一的、可验证的解。\n\n问题的核心在于矩阵 $A$ 的构建。对每个测试案例，此过程按如下方式执行：\n\n1.  **系统定义**：对于每个测试案例，我们给定一组原子位置 $\\mathbf{r}_i$、所有原子的统一质量 $m$，以及一个全息距离约束列表。每个约束 $k$ 由一对原子索引 $(a,b)$ 定义。\n\n2.  **单位向量计算**：对于原子 $a$ 和 $b$ 之间的每个约束 $k$，我们计算从原子 $a$ 指向原子 $b$ 的单位向量 $\\mathbf{u}_k$：\n    $$ \\mathbf{u}_k = \\frac{\\mathbf{r}_b - \\mathbf{r}_a}{\\lVert \\mathbf{r}_b - \\mathbf{r}_a \\rVert} $$\n    问题陈述将约束指定为有序对，我们将其解释为定义了 $\\mathbf{u}_k$ 的方向。\n\n3.  **约束耦合矩阵, $G$**：构建对称矩阵 $G = J M^{-1} J^\\top$。其元素由以下公式给出：\n    -   **对角元素**：对于连接原子 $(a,b)$ 的约束 $i$，对角元素 $G_{ii}$ 表示该约束的自耦合。它由所涉原子的质量倒数之和给出：\n        $$ G_{ii} = \\frac{1}{m_a} + \\frac{1}{m_b} $$\n    -   **非对角元素**：对于两个不同的约束，即连接 $(a,b)$ 的约束 $i$ 和连接 $(c,d)$ 的约束 $j$，非对角元素 $G_{ij}$ 代表它们的耦合。这种耦合仅通过共享原子产生。公式为：\n        $$ G_{ij} = \\sum_{k \\in \\{a,b\\} \\cap \\{c,d\\}} \\sigma_k \\frac{1}{m_k} (\\mathbf{u}_i \\cdot \\mathbf{u}_j) $$\n        如果原子 $k$ 在两个约束中都是“起始”点（例如，$k=a=c$）或都是“结束”点（例如，$k=b=d$），则符号因子 $\\sigma_k$ 为 $+1$。如果它在一个约束中是“起始”点，在另一个约束中是“结束”点（例如，$k=a=d$ 或 $k=b=c$），则为 $-1$。这正确地实现了经过适当定义的雅可bi矩阵的相应行与 $M^{-1/2}$ 后乘后的内积。\n\n4.  **归一化耦合矩阵, $A$**：我们根据 $G$ 构建矩阵 $A$，其对角线元素为零。其非对角元素通过 $G$ 的相应对角元素的几何平均值进行归一化：\n    $$ A_{ij} = \\frac{G_{ij}}{\\sqrt{G_{ii} G_{jj}}} \\quad (i \\neq j); \\quad A_{ii} = 0 $$\n    由于测试案例中所有原子质量均相等，质量值在 $A_{ij}$ 的表达式中被消去，使得最终分析与具体的质量值无关，只要质量是统一的即可。\n\n5.  **谱半径与失效分析**：LINCS 诺伊曼级数的收敛性由谱半径 $\\rho(A) = \\max_k |\\lambda_k|$ 决定，其中 $\\lambda_k$ 是 $A$ 的特征值。\n    -   如果 $\\rho(A) \\ge 1$，级数发散，则认为该方法对任何阶数都已失效。\n    -   如果 $\\rho(A)  1$，级数收敛。在 $p$ 阶截断后的误差界为 $E_p \\le \\frac{\\rho(A)^{p+1}}{1 - \\rho(A)}$。如果此误差界超过给定容差 $\\tau = 10^{-4}$，则定义为在 $p$ 阶发生失效。\n\n此程序应用于三个测试案例中的每一个，并使用指定的 LINCS 阶数 $p \\in \\{1, 2, 4, 8\\}$。\n\n-   **测试案例1**：一个中心原子与三个在平面上对称排列的原子（相隔 $120^\\circ$）成键。这种几何结构导致对于所有 $i \\neq j$ 都有点积 $\\mathbf{u}_i \\cdot \\mathbf{u}_j = -0.5$。由此产生的谱半径为 $\\rho(A) = 0.5$。\n-   **测试案例2**：一个中心原子与三个近乎共线的原子成键。微小的角度分离导致点积 $\\mathbf{u}_i \\cdot \\mathbf{u}_j$ 非常接近于 $1$。这导致谱半径 $\\rho(A)$ 接近但小于 $1$。\n-   **测试案例3**：一个中心原子与四个完全共线的原子成键。这是一个极端情况，所有单位向量都相同，因此对于所有 $i,j$ 都有 $\\mathbf{u}_i \\cdot \\mathbf{u}_j = 1$。这种构型产生的谱半径为 $\\rho(A) = 1.5$，大于 $1$。\n\n对于每个案例，计算出的谱半径用于评估每个指定阶数 $p$ 的失效条件。最终结果按要求汇总到单个列表中。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LINCS breakdown problem for the given test cases.\n    \"\"\"\n\n    def compute_case_results(positions, masses, constraints, p_orders, tau):\n        \"\"\"\n        Computes the spectral radius and breakdown booleans for a single test case.\n        \"\"\"\n        num_constraints = len(constraints)\n        if num_constraints == 0:\n            return [0.0] + [False] * len(p_orders)\n\n        # 1. Calculate unit vectors for each constraint\n        unit_vectors = []\n        for (idx_a, idx_b) in constraints:\n            r_a = positions[idx_a]\n            r_b = positions[idx_b]\n            vec = r_b - r_a\n            norm = np.linalg.norm(vec)\n            # The problem setup guarantees norm > 0\n            unit_vectors.append(vec / norm)\n\n        # 2. Construct the constraint coupling matrix G\n        G = np.zeros((num_constraints, num_constraints), dtype=float)\n\n        # Diagonal elements G_ii\n        for i in range(num_constraints):\n            idx_a, idx_b = constraints[i]\n            G[i, i] = 1.0 / masses[idx_a] + 1.0 / masses[idx_b]\n\n        # Off-diagonal elements G_ij\n        for i in range(num_constraints):\n            for j in range(i + 1, num_constraints):\n                i_start, i_end = constraints[i]\n                j_start, j_end = constraints[j]\n                \n                u_i = unit_vectors[i]\n                u_j = unit_vectors[j]\n                dot_product = np.dot(u_i, u_j)\n\n                g_ij = 0.0\n                \n                shared_atoms = set(constraints[i])  set(constraints[j])\n                for k in shared_atoms:\n                    # sigma_k is +1 if k is the same type of endpoint (start/start or end/end),\n                    # and -1 if it's a different type (start/end).\n                    is_k_start_in_i = (k == i_start)\n                    is_k_start_in_j = (k == j_start)\n                    sigma_k = 1.0 if is_k_start_in_i == is_k_start_in_j else -1.0\n                    g_ij += sigma_k * (1.0 / masses[k]) * dot_product\n                \n                G[i, j] = g_ij\n                G[j, i] = g_ij # G is symmetric\n\n        # 3. Construct the normalized constraint coupling matrix A\n        A = np.zeros_like(G)\n        for i in range(num_constraints):\n            for j in range(i + 1, num_constraints):\n                denominator = np.sqrt(G[i, i] * G[j, j])\n                if denominator > 1e-12: # Avoid division by zero\n                    A[i, j] = G[i, j] / denominator\n                    A[j, i] = A[i, j]\n\n        # 4. Calculate the spectral radius rho(A)\n        eigenvalues = np.linalg.eigvals(A)\n        rho = np.max(np.abs(eigenvalues))\n\n        # 5. Determine breakdown for each order p\n        breakdowns = []\n        for p in p_orders:\n            is_breakdown = False\n            if rho >= 1.0:\n                is_breakdown = True\n            else:\n                # Error bound is rho^(p+1) / (1-rho)\n                # Avoid potential floating point issues with rho=0\n                if rho > 1e-9:\n                    error_bound = (rho**(p + 1)) / (1.0 - rho)\n                    if error_bound > tau:\n                        is_breakdown = True\n            breakdowns.append(is_breakdown)\n\n        return [round(rho, 6)] + breakdowns\n\n    # --- Define Test Cases ---\n    \n    L = 0.1\n    m = 12.0\n    tau = 1e-4\n    p_orders = [1, 2, 4, 8]\n    \n    test_cases = [\n        # Test Case 1: threefold branch, well-separated constraints\n        {\n            \"positions\": {\n                0: np.array([0.0, 0.0, 0.0]),\n                1: np.array([L, 0.0, 0.0]),\n                2: np.array([-L/2.0, np.sqrt(3.0)/2.0 * L, 0.0]),\n                3: np.array([-L/2.0, -np.sqrt(3.0)/2.0 * L, 0.0])\n            },\n            \"masses\": {i: m for i in range(4)},\n            \"constraints\": [(0, 1), (0, 2), (0, 3)]\n        },\n        # Test Case 2: threefold branch, nearly collinear constraints\n        {\n            \"positions\": {\n                0: np.array([0.0, 0.0, 0.0]),\n                1: np.array([L, 0.0, 0.0]),\n                2: np.array([L, 0.1*L, 0.0]),\n                3: np.array([L, -0.1*L, 0.0])\n            },\n            \"masses\": {i: m for i in range(4)},\n            \"constraints\": [(0, 1), (0, 2), (0, 3)]\n        },\n        # Test Case 3: fourfold branch, collinear constraints\n        {\n            \"positions\": {\n                0: np.array([0.0, 0.0, 0.0]),\n                1: np.array([L, 0.0, 0.0]),\n                2: np.array([2.0*L, 0.0, 0.0]),\n                3: np.array([3.0*L, 0.0, 0.0]),\n                4: np.array([4.0*L, 0.0, 0.0])\n            },\n            \"masses\": {i: m for i in range(5)},\n            \"constraints\": [(0, 1), (0, 2), (0, 3), (0, 4)]\n        }\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        case_results = compute_case_results(\n            case[\"positions\"],\n            case[\"masses\"],\n            case[\"constraints\"],\n            p_orders,\n            tau\n        )\n        all_results.extend(case_results)\n    \n    # Format the final output as a comma-separated list in a single line\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3442814"}, {"introduction": "这项实践将焦点从约束算法本身转移到方向表示法中的数值精妙之处。你将分析四元数的周期性重归一化——一个为抵消数值漂移所必需的步骤——如何会给系统引入人为的能量变化。通过对此效应建模，你将推导出一个选择最佳重归一化频率的原则性标准 ([@problem_id:3442776])，从而在约束精度和长期能量守恒之间取得平衡。", "problem": "考虑一个分子动力学刚体积分器，它使用单位四元数 $q \\in \\mathbb{R}^{4}$（其中 $\\|q\\| = 1$）来表示朝向，角速度为 $\\omega \\in \\mathbb{R}^{3}$。四元数动力学遵循运动学关系 $\\dot{q} = \\tfrac{1}{2}\\,\\Omega(\\omega)\\,q$，其中 $\\Omega(\\omega)$ 是将角速度映射到四元数导数的线性算子。一种对称分裂或速度Verlet型格式以时间步长 $\\Delta t$ 推进 $q$，但由于有限精度和局部截断误差，$q$ 会偏离单位长度。一个常见的补救措施是每 $k$ 步通过投影 $q \\leftarrow q/\\|q\\|$ 进行重新归一化。势能 $U(r,q)$ 取决于构型 $r$ 和朝向 $q$；假设在短分析窗口内 $r$ 保持不变，并且关于 $q$ 的梯度在单位四元数流形附近是Lipschitz的：对于所有 $\\|q\\| \\approx 1$ 的 $q$，都有 $\\|\\nabla_{q} U(r,q)\\| \\le L$，其中 $L$ 是一个有限常数。假设 $k$ 步后累积的范数误差足够小，可以进行一阶线性化，并且该误差由两个来源产生：\n- 来自局部截断误差的确定性偏差，每步的量级为 $\\alpha\\,\\Delta t^{p}$，其中 $\\alpha0$ 且 $p \\ge 2$。\n- 零均值舍入噪声，每步的标准差为 $\\sigma0$。\n\n令 $k$ 步后的标量范数偏差为 $\\delta(k) = \\|q\\|^{2}-1$，其模型为 $|\\delta(k)| \\approx \\alpha\\,k\\,\\Delta t^{p} + \\text{noise}$，其中根据中心极限定理标度，噪声项的标准差为 $\\sigma\\,\\sqrt{k}$。对于小的 $\\delta(k)$，通过一阶展开来近似投影，得到由重新归一化引起的朝向变化，其量级为 $\\|\\Delta q\\| \\approx \\tfrac{1}{2}|\\delta(k)|$。使用功作为势能变化的基本定义 $\\Delta U \\approx \\nabla_{q} U \\cdot \\Delta q$ 和Lipschitz界，假设在每次重新归一化时 $|\\Delta U| \\lesssim L\\,\\|\\Delta q\\|$。那么，长期由重新归一化引起的能量漂移率是每次重新归一化的期望能量变化除以时间间隔 $k\\,\\Delta t$。\n\n分析重新归一化间隔 $k$ 如何影响这个长期漂移率，并确定一个有原则的准则来选择 $k$，该准则需同时满足以下两点：\n- 将由重新归一化引起的能量漂移率保持在预设的容差 $\\varepsilon_{E}0$ 以下，并且\n- 通过将期望范数偏差保持在容差 $\\delta_{\\max}0$ 以下来确保线性化仍然有效。\n\n哪个选项与上述第一性原理建模最一致，并能得出一个科学上合理的准则？\n\nA. 每一步都进行重新归一化（即 $k=1$），因为每次更新都强制 $\\|q\\|=1$ 会保持辛性，从而最小化能量漂移；更频繁的重新归一化总是能减少长期漂移。\n\nB. 对于确定性误差和随机误差，由重新归一化引起的能量漂移率都遵循 $R(k) \\propto \\tfrac{1}{k\\,\\Delta t}$ 的标度关系，因此应选择尽可能大的 $k$ 来最小化 $R(k)$，并且不需要对 $\\delta(k)$ 施加额外约束。\n\nC. 在所述误差模型下，期望漂移率满足\n$$\nR(k) \\approx \\frac{L}{2\\,k\\,\\Delta t}\\,\\mathbb{E}\\!\\left[|\\delta(k)|\\right] \\approx \\frac{L\\,\\alpha}{2}\\,\\Delta t^{p-1} + \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\sqrt{k}},\n$$\n因此确定性贡献与 $k$ 无关，而随机贡献随 $k^{-1/2}$ 减小。一个有原则的选择是选取使线性化有效且漂移低于容差的最大整数 $k$，即\n$$\n\\mathbb{E}\\!\\left[|\\delta(k)|\\right] \\le \\delta_{\\max} \\quad \\Rightarrow \\quad k \\le \\min\\!\\left(\\frac{\\delta_{\\max}}{\\alpha\\,\\Delta t^{p}},\\,\\left(\\frac{\\delta_{\\max}}{\\sigma}\\right)^{2}\\right),\n$$\n并且\n$$\nR(k) \\le \\varepsilon_{E} \\quad \\Rightarrow \\quad k \\ge \\left(\\frac{L\\,\\sigma}{2\\,\\varepsilon_{E}\\,\\Delta t}\\right)^{2},\n$$\n在这些界限下选择允许的最大值 $k$，以在遵守单位四元数约束的同时，最小化由投影引起的漂移。\n\nD. 选择一个与 $\\Delta t$、机器精度和敏感度 $L$ 无关的恒定重新归一化间隔 $k$，因为重新归一化主要影响截断误差而非舍入误差，因此能量漂移不受 $k$ 的选择影响。", "solution": "问题要求为刚体动力学模拟中的单位四元数 $q$ 提供一个选择重新归一化间隔 $k$ 的有原则的准则。$k$ 的选择必须平衡两个相互竞争的目标：将长期能量漂移率保持在容差 $\\varepsilon_{E}$ 以下，并通过将范数偏差保持在容差 $\\delta_{\\max}$ 以下来确保线性近似的有效性。\n\n首先，我们验证问题陈述。\n\n### 第1步：提取已知条件\n- 朝向由单位四元数 $q \\in \\mathbb{R}^{4}$ 表示，其中 $\\|q\\|=1$。\n- 角速度为 $\\omega \\in \\mathbb{R}^{3}$。\n- 四元数动力学由运动学关系 $\\dot{q} = \\tfrac{1}{2}\\,\\Omega(\\omega)\\,q$ 控制。\n- 积分采用时间步长为 $\\Delta t$ 的对称分裂格式。\n- 每 $k$ 步进行一次重新归一化 $q \\leftarrow q/\\|q\\|$。\n- 势能为 $U(r,q)$，其中 $r$ 固定。\n- 势能梯度有界：对于 $\\|q\\| \\approx 1$，有 $\\|\\nabla_{q} U(r,q)\\| \\le L$。\n- $k$ 步后的范数偏差为 $\\delta(k) = \\|q\\|^{2}-1$。\n- 范数误差在 $k$ 步内的累积来自两个来源：\n    1. 来自局部截断误差的确定性偏差，总大小为 $\\alpha\\,k\\,\\Delta t^{p}$，其中 $\\alpha0$ 且 $p \\ge 2$。\n    2. 零均值舍入噪声，总标准差为 $\\sigma\\,\\sqrt{k}$，其中 $\\sigma0$。\n- 总范数偏差的大小建模为 $|\\delta(k)| \\approx \\alpha\\,k\\,\\Delta t^{p} + \\text{noise}$，其中噪声项的标准差为 $\\sigma\\,\\sqrt{k}$。\n- 由重新归一化引起的朝向变化近似为 $\\|\\Delta q\\| \\approx \\tfrac{1}{2}|\\delta(k)|$。\n- 势能变化近似为 $\\Delta U \\approx \\nabla_{q} U \\cdot \\Delta q$，其大小有界于 $|\\Delta U| \\lesssim L\\,\\|\\Delta q\\|$。\n- 长期由重新归一化引起的能量漂移率是每次重新归一化的期望能量变化除以时间间隔，即 $\\mathbb{E}[|\\Delta U|] / (k\\,\\Delta t)$。\n\n### 第2步：使用提取的已知条件进行验证\n问题陈述是有科学依据的。在刚体动力学中使用四元数、运动学方程、数值积分中的范数偏差问题以及周期性重新归一化的方法，都是计算物理和力学中的标准实践。误差模型结合了线性累积的系统误差（来自截断）和类似随机游走的随机误差（来自舍入），这是数值积分器中误差传播的标准且物理上合理的模型。对于重新归一化步骤及其产生的功的一阶近似，在所假设的小偏差下是有效的。该问题是适定的、客观的且自洽的，提供了一个清晰可供分析的模型。不存在科学缺陷、矛盾或歧义。\n\n### 第3步：判断与行动\n问题有效。我们继续推导解决方案。\n\n### 推导\n长期由重新归一化引起的能量漂移率，记为 $R(k)$，定义为单位时间的期望能量变化：\n$$ R(k) = \\frac{\\mathbb{E}[|\\Delta U|]}{k\\,\\Delta t} $$\n使用给定的近似和界限，我们可以用范数偏差 $\\delta(k)$ 来表示 $|\\Delta U|$。\n由 $|\\Delta U| \\lesssim L\\,\\|\\Delta q\\|$ 和 $\\|\\Delta q\\| \\approx \\tfrac{1}{2}|\\delta(k)|$，我们有：\n$$ |\\Delta U| \\approx \\frac{L}{2} |\\delta(k)| $$\n将此代入漂移率的表达式中：\n$$ R(k) \\approx \\frac{\\mathbb{E}\\left[\\frac{L}{2}|\\delta(k)|\\right]}{k\\,\\Delta t} = \\frac{L}{2\\,k\\,\\Delta t} \\mathbb{E}[|\\delta(k)|] $$\n接下来，我们对 $\\mathbb{E}[|\\delta(k)|]$ 进行建模。偏差 $\\delta(k)$ 是确定性部分 $D(k) = \\alpha\\,k\\,\\Delta t^p$ 和随机部分 $N(k)$ 的和，后者均值为零，标准差为 $\\sigma\\,\\sqrt{k}$。问题陈述 $|\\delta(k)| \\approx \\alpha\\,k\\,\\Delta t^{p} + \\text{noise}$，我们将其解释为期望量级的模型，其中噪声的期望量级被认为与其标准差成正比。这导致了以下近似：\n$$ \\mathbb{E}[|\\delta(k)|] \\approx \\mathbb{E}[|D(k) + N(k)|] \\approx |D(k)| + \\mathbb{E}[|N(k)|] \\approx \\alpha\\,k\\,\\Delta t^{p} + C\\,\\sigma\\,\\sqrt{k} $$\n其中 $C$ 是一个常数，数量级为 $1$。为简单起见并与选项保持一致，我们取 $C=1$。\n$$ \\mathbb{E}[|\\delta(k)|] \\approx \\alpha\\,k\\,\\Delta t^{p} + \\sigma\\,\\sqrt{k} $$\n将此代入 $R(k)$ 的表达式中：\n$$ R(k) \\approx \\frac{L}{2\\,k\\,\\Delta t} \\left( \\alpha\\,k\\,\\Delta t^{p} + \\sigma\\,\\sqrt{k} \\right) = \\frac{L\\,\\alpha\\,k\\,\\Delta t^{p}}{2\\,k\\,\\Delta t} + \\frac{L\\,\\sigma\\,\\sqrt{k}}{2\\,k\\,\\Delta t} $$\n$$ R(k) \\approx \\frac{L\\,\\alpha}{2}\\Delta t^{p-1} + \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\sqrt{k}} $$\n该方程揭示了漂移率 $R(k)$ 由两个分量组成：\n1.  确定性分量 $R_{\\text{det}} = \\frac{L\\,\\alpha}{2}\\Delta t^{p-1}$，它与重新归一化频率 $k$ 无关。\n2.  随机分量 $R_{\\text{rand}}(k) = \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\sqrt{k}}$，它随着 $k$ 的增加（即重新归一化频率降低）而减小。\n\n为了最小化总漂移率 $R(k)$，应该使第二项尽可能小，这意味着选择尽可能大的 $k$ 值。\n\n现在，我们考虑对 $k$ 的两个约束。\n\n**约束1：线性化有效性**\n期望范数偏差必须低于容差 $\\delta_{\\max}$：\n$$ \\mathbb{E}[|\\delta(k)|] \\approx \\alpha\\,k\\,\\Delta t^{p} + \\sigma\\,\\sqrt{k} \\le \\delta_{\\max} $$\n为确保这一点，可以要求导致偏差的每一项都有界，例如被 $\\delta_{\\max}$ 本身（一种保守的方法）或其某个分数所限制。一个常见的策略，如某个选项所建议，是分别对每一项进行约束：\n$$ \\alpha\\,k\\,\\Delta t^{p} \\le \\delta_{\\max} \\implies k \\le \\frac{\\delta_{\\max}}{\\alpha\\,\\Delta t^p} $$\n$$ \\sigma\\,\\sqrt{k} \\le \\delta_{\\max} \\implies k \\le \\left(\\frac{\\delta_{\\max}}{\\sigma}\\right)^2 $$\n为使两者都成立，$k$ 必须小于或等于这两个上界的最小值：\n$$ k \\le \\min\\left(\\frac{\\delta_{\\max}}{\\alpha\\,\\Delta t^{p}}, \\left(\\frac{\\delta_{\\max}}{\\sigma}\\right)^2\\right) $$\n这提供了 $k$ 的一个上界。\n\n**约束2：能量漂移容差**\n总漂移率必须低于容差 $\\varepsilon_E$：\n$$ R(k) \\approx \\frac{L\\,\\alpha}{2}\\Delta t^{p-1} + \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\sqrt{k}} \\le \\varepsilon_E $$\n这意味着：\n$$ \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\sqrt{k}} \\le \\varepsilon_E - \\frac{L\\,\\alpha}{2}\\Delta t^{p-1} $$\n我们称右侧为 $\\varepsilon'_{\\text{E}}$。如果 $\\varepsilon'_{\\text{E}}  0$，我们可以重新整理以找到 $k$ 的一个下界：\n$$ \\sqrt{k} \\ge \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\varepsilon'_{\\text{E}}} \\implies k \\ge \\left( \\frac{L\\,\\sigma}{2\\,\\Delta t\\,\\left(\\varepsilon_E - \\frac{L\\,\\alpha}{2}\\Delta t^{p-1}\\right)} \\right)^2 $$\n这提供了 $k$ 的一个下界。为了控制能量漂移，$k$ 必须足够大。\n\n**$k$ 的有原则的选择**\n分析表明存在一个最优策略：由于漂移率 $R(k)$ 是 $k$ 的单调递减函数，应选择 $k$ 的允许的最大整数值。$k$ 的上限由线性化有效性约束决定。因此，有原则的选择是选取满足范数偏差约束的最大整数 $k$，同时确保这个 $k$ 也满足能量漂移约束（即大于所需的最小值）。\n\n### 逐项分析选项\n\n**A. 每一步都进行重新归一化（即 $k=1$），...**\n这个陈述是错误的。首先，投影 $q \\leftarrow q/\\|q\\|$ 是一个非哈密顿、非辛的操作，它会明确地向系统增加或移除能量。它是能量漂移的来源，而不是保持辛性的手段。其次，我们的推导表明，漂移率 $R(k)$ 有一个随 $k$ 减小的分量（标度为 $k^{-1/2}$），这意味着频率较低的重新归一化（更大的 $k$）可以减少由随机误差引起的漂移。声称更频繁的重新归一化总是能减少漂移是错误的。\n**结论：错误。**\n\n**B. 由重新归一化引起的能量漂移率标度为 ...**\n这个陈述是错误的。我们推导出的漂移率是 $R(k) \\approx C_1 + C_2\\,k^{-1/2}$，其中 $C_1$ 和 $C_2$ 是常数。确定性贡献与 $k$ 无关，随机贡献的标度为 $k^{-1/2}$，而不是 $k^{-1}$。此外，对范数偏差 $\\delta(k)$ 的约束是必不可少的。没有它，四元数可能会偏离单位球面太远，以至于旋转的物理表示和分析中使用的线性化变得无效。\n**结论：错误。**\n\n**C. 在所述误差模型下，期望漂移率满足 ...**\n这个陈述与我们的推导高度一致。它正确地确定了漂移率 $R(k)$ 的表达式及其确定性和随机分量的标度关系。它正确地将线性化有效性约束转化为 $k$ 的一个上界。从能量漂移约束推导 $k$ 的下界时，包含了一个合理的简化，即假设确定性漂移部分与容差 $\\varepsilon_E$ 相比可以忽略不计（或者说必须被限制的是漂移的可控部分），这是推导此类准则的常见步骤。最后，它推荐选择允许的最大 $k$ 值，这是最小化漂移率的正确策略。\n**结论：正确。**\n\n**D. 选择一个恒定的重新归一化间隔 $k$ ...**\n这个陈述是错误的。我们的分析表明，$k$ 的界限，以及因此 $k$ 的最优选择，明确地依赖于时间步长 $\\Delta t$、机器精度（与 $\\sigma$ 相关）和势能的敏感度 $L$。声称能量漂移不受 $k$ 选择的影响是错误的，因为漂移率的随机分量明显依赖于 $k$。\n**结论：错误。**", "answer": "$$\\boxed{C}$$", "id": "3442776"}]}