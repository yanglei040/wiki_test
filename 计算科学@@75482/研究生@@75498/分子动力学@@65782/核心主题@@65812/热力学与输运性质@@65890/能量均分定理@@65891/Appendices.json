{"hands_on_practices": [{"introduction": "我们如何确定一个分子动力学模拟已经达到了热平衡？能量均分定理为此提供了一个强有力的检验标准，即在平衡态下，每个二次型自由度的平均动能都等于 $\\frac{1}{2} k_B T$。这项练习 [@problem_id:3411252] 旨在引导您超越简单的均值比较，通过构建置信区间来考虑有限采样长度带来的统计涨落，从而对模拟速度数据进行严格的统计检验。这是验证模拟结果和评估采样效率的一项关键实践技能。", "problem": "您的任务是构建一个完整、可运行的程序，通过分析根据模拟的平衡态速度数据和质量加权的简正模投影计算出的模式分辨动能，在经典分子动力学（MD）环境中数值上验证能量均分定理。此验证应具有统计严谨性，通过将模式平均能量与热力学基准进行比较，并使用其宽度明确依赖于采样长度的置信区间来量化偏差。\n\n起点与定义：考虑一个在三维空间中由 $N$ 个点粒子组成的系统，其中粒子质量为 $m_j$，$j \\in \\{1,\\dots,N\\}$。笛卡尔坐标系中的瞬时速度向量为 $v \\in \\mathbb{R}^{3N}$，质量加权速度定义为 $u = \\mathrm{diag}(\\sqrt{m_1}, \\sqrt{m_1}, \\sqrt{m_1}, \\dots, \\sqrt{m_N}, \\sqrt{m_N}, \\sqrt{m_N}) \\, v \\in \\mathbb{R}^{3N}$。设 $E \\in \\mathbb{R}^{3N \\times M}$ 的列在质量加权空间中关于欧几里得内积是标准正交的，代表 $M$ 个简正模向量。模态速度坐标为 $a = E^\\top u \\in \\mathbb{R}^M$。模式 $i$ 中的瞬时动能定义为 $K_i = \\frac{1}{2} a_i^2$，单位为焦耳（$\\textrm{J}$）。在绝对温度 $T$ 下，每个二次自由度的热力学基准是 $k_{\\mathrm{B}} T / 2$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。温度以开尔文（$\\textrm{K}$）为单位，质量以原子质量单位（$\\textrm{amu}$）提供，必须使用 $1\\,\\textrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\textrm{kg}$ 转换为千克（$\\textrm{kg}$）。能量必须以焦耳（$\\textrm{J}$）计算。角度未出现，因此不需要角度单位。最终报告的结果必须是区间 $[0,1]$ 内的无单位小数。\n\n程序要求：\n- 对于每个测试用例，在指定的温度 $T_{\\mathrm{true}}$ 下，从平衡（正则）分布中采样生成合成的MD速度数据。此采样在时间样本上必须是独立的，具有指定的采样长度 $n$。为确保可复现性，每个测试用例使用固定的随机种子。\n- 通过生成一个随机矩阵并执行标准正交化过程，构建一个在 $\\mathbb{R}^{3N}$ 中由 $M$ 个质量加权简正模 $E$ 组成的随机标准正交集，然后选择其前 $M$ 列。\n- 对于每个模式 $i \\in \\{1,\\dots,M\\}$，计算瞬时模态动能 $K_i$ 在 $n$ 个样本上的样本均值。仅使用采样长度 $n$ 和正则系综中二次自由度的分布结构，构建真实平均模态动能的双边 $95\\%$ 置信区间。然后，判断热力学基准 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$（其中 $T_{\\mathrm{rep}}$ 是用于验证的报告温度）是否位于此置信区间内。\n- 对于每个测试用例，返回其基准 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$ 位于计算出的置信区间内的模式所占的比例（一个小数）。此比例必须在 $[0,1]$ 范围内。\n\n测试套件：\n使用以下四个测试用例，每个都有指定的随机种子 $s$：\n- 用例 1（正常路径）：$N=5$，$M=10$，每个粒子的质量为 $12\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=20000$，种子 $s=271828$。\n- 用例 2（异构质量，小样本）：$N=3$，$M=9$，每个粒子的质量为 $[1, 12, 197]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=200$，种子 $s=314159$。\n- 用例 3（不匹配的验证温度）：$N=4$，$M=12$，每个粒子的质量为 $[39.948, 1.008, 15.999, 12.011]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=600\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=5000$，种子 $s=141421$。\n- 用例 4（边界情况：单模式）：$N=1$，$M=1$，质量 $[16]\\,\\textrm{amu}$，$T_{\\mathrm{true}}=300\\,\\textrm{K}$，$T_{\\mathrm{rep}}=300\\,\\textrm{K}$，采样长度 $n=50$，种子 $s=161803$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，即 $[f_1,f_2,f_3,f_4]$，其中 $f_k$ 是测试用例 $k$ 的分数（一个小数），对应其平均动能的 $95\\%$ 置信区间包含 $k_{\\mathrm{B}} T_{\\mathrm{rep}} / 2$ 的模式所占的比例。", "solution": "该问题要求在经典分子动力学背景下对能量均分定理进行数值验证。此验证将通过生成合成速度数据，将其投影到一组简正模上，然后使用统计置信区间来检验每个模式的平均动能与理论基准是否一致来完成。\n\n### 理论基础\n\n该系统由 $N$ 个粒子组成，其质量为 $m_j$，$j \\in \\{1,\\dots,N\\}$。系统的状态由笛卡尔速度向量 $v \\in \\mathbb{R}^{3N}$ 描述。总动能 $K$ 由下式给出：\n$$ K = \\sum_{j=1}^{N} \\frac{1}{2} m_j (v_{j,x}^2 + v_{j,y}^2 + v_{j,z}^2) $$\n为简化动能表达式，通常引入质量加权速度坐标。设 $W$ 为 $3N \\times 3N$ 的质量对角矩阵，其元素为 $(m_1, m_1, m_1, \\dots, m_N, m_N, m_N)$。质量加权速度向量 $u \\in \\mathbb{R}^{3N}$ 定义为 $u = W^{1/2}v$。用 $u$ 表示，总动能变为简单的平方和：\n$$ K = \\frac{1}{2} v^\\top W v = \\frac{1}{2} (W^{-1/2}u)^\\top W (W^{-1/2}u) = \\frac{1}{2} u^\\top W^{-1/2} W W^{-1/2} u = \\frac{1}{2} u^\\top u = \\frac{1}{2} \\sum_{k=1}^{3N} u_k^2 $$\n在温度为 $T_{\\mathrm{true}}$ 的热平衡正则系综中，每个笛卡尔速度分量 $v_k$（对应质量为 $m'_k$ 的粒子）是服从均值为 $0$、方差为 $k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_k$ 的高斯分布的独立随机变量。因此，每个质量加权速度分量 $u_k = \\sqrt{m'_k} v_k$ 是一个独立同分布（i.i.d.）的随机变量，服从均值为 $E[u_k] = 0$、方差为 $\\mathrm{Var}(u_k) = (\\sqrt{m'_k})^2 \\mathrm{Var}(v_k) = m'_k (k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_k) = k_{\\mathrm{B}} T_{\\mathrm{true}}$ 的高斯分布。因此，整个向量 $u$ 服从多元正态分布：$u \\sim N(0, k_{\\mathrm{B}} T_{\\mathrm{true}} I_{3N})$，其中 $I_{3N}$ 是 $3N \\times 3N$ 的单位矩阵。\n\n问题将一组 $M$ 个简正模定义为矩阵 $E \\in \\mathbb{R}^{3N \\times M}$ 的列，这些列是标准正交的，满足 $E^\\top E = I_M$。模态速度坐标通过将 $u$ 投影到这些模式上获得：$a = E^\\top u$。由于这是高斯随机向量的线性变换，$a$ 也是一个高斯随机向量。其均值为 $E[a] = E^\\top E[u] = 0$。其协方差矩阵为：\n$$ \\mathrm{Cov}(a) = E[aa^\\top] = E[E^\\top u u^\\top E] = E^\\top E[uu^\\top] E = E^\\top (k_{\\mathrm{B}} T_{\\mathrm{true}} I_{3N}) E = k_{\\mathrm{B}} T_{\\mathrm{true}} (E^\\top E) = k_{\\mathrm{B}} T_{\\mathrm{true}} I_M $$\n这个关键结果表明，对于 $i \\in \\{1,\\dots,M\\}$，模态坐标 $a_i$ 是独立同分布的随机变量，每个都服从分布 $a_i \\sim N(0, k_{\\mathrm{B}} T_{\\mathrm{true}})$。\n\n模式 $i$ 的瞬时动能是 $K_i = \\frac{1}{2} a_i^2$。如果我们定义一个标准正态变量 $Z_i = a_i / \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}}}$，那么 $Z_i \\sim N(0,1)$。模态能量可以写成：\n$$ K_i = \\frac{1}{2} (Z_i \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}}})^2 = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} Z_i^2 $$\n标准正态变量的平方 $Z_i^2$ 服从自由度为1的卡方分布，记为 $\\chi^2(1)$。因此，模式 $i$ 的真实平均动能 $\\langle K_i \\rangle$ 是：\n$$ \\langle K_i \\rangle = E[K_i] = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} E[Z_i^2] = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} \\cdot 1 = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}} $$\n这证实了能量均分定理：每个二次模态自由度的平均能量为 $\\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}}$。\n\n### 统计验证方法\n\n任务是使用大小为 $n$ 的有限样本来数值验证这一结果。对于每个模式 $i$，我们从 $n$ 个独立样本中计算样本平均动能 $\\bar{K}_i = \\frac{1}{n} \\sum_{j=1}^{n} K_{i,j}$。然后，我们必须为真实均值 $\\langle K_i \\rangle$ 构建一个 $95\\%$ 的置信区间，并验证基准能量 $E_{\\mathrm{bench}} = \\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{rep}}$ 是否落在此区间内。\n\n问题指定置信区间的构建必须使用已知的分布结构。$n$ 个独立同分布的 $K_i$ 样本之和与一个 $\\chi^2(n)$ 分布相关。考虑量 $Y$：\n$$ Y = \\sum_{j=1}^{n} \\frac{2 K_{i,j}}{\\langle K_i \\rangle \\cdot 2} = \\sum_{j=1}^{n} \\frac{K_{i,j}}{\\frac{1}{2} k_{\\mathrm{B}} T_{\\mathrm{true}}} = \\sum_{j=1}^{n} Z_{i,j}^2 $$\n由于每个 $Z_{i,j}^2$ 是一个独立同分布的 $\\chi^2(1)$ 变量，它们的和 $Y$ 服从自由度为 $n$ 的卡方分布，$Y \\sim \\chi^2(n)$。我们可以用样本均值 $\\bar{K}_i$ 来表示 $Y$：\n$$ Y = \\frac{n \\bar{K}_i}{\\langle K_i \\rangle} $$\n对于 $95\\%$ 的置信水平（$\\alpha = 0.05$），我们从 $\\chi^2(n)$ 分布中找到下临界值和上临界值，$q_1 = \\chi^2_{\\alpha/2}(n)$ 和 $q_2 = \\chi^2_{1-\\alpha/2}(n)$，使得 $P(q_1  Y  q_2) = 1-\\alpha = 0.95$。代入 $Y$ 的表达式并整理不等式以求解 $\\langle K_i \\rangle$：\n$$ q_1  \\frac{n \\bar{K}_i}{\\langle K_i \\rangle}  q_2 \\implies \\frac{n \\bar{K}_i}{q_2}  \\langle K_i \\rangle  \\frac{n \\bar{K}_i}{q_1} $$\n这给出了真实平均模态动能的精确 $95\\%$ 置信区间：\n$$ \\mathrm{CI}_{95\\%} = \\left[ \\frac{n \\bar{K}_i}{\\chi^2_{0.975}(n)}, \\frac{n \\bar{K}_i}{\\chi^2_{0.025}(n)} \\right] $$\n然后我们检查 $E_{\\mathrm{bench}} = \\frac{1}{2}k_{\\mathrm{B}} T_{\\mathrm{rep}}$ 是否位于这个计算出的区间内。\n\n### 算法实现\n\n该解决方案实现为一个Python程序，为提高效率采用向量化方法。对于每个测试用例：\n1.  **初始化**：定义常数 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\textrm{J/K}$ 和 amu-to-kg 转换因子 $1.66053906660 \\times 10^{-27}\\,\\textrm{kg/amu}$。设置特定用例的参数（$N$、$M$、质量、温度 $T_{\\mathrm{true}}$ 和 $T_{\\mathrm{rep}}$、样本大小 $n$ 和随机种子 $s$）。使用随机种子确保可复现性。\n2.  **系统表示**：将粒子质量转换为千克，并组织成一个对应于每个笛卡尔自由度的 $3N$ 维向量。生成一个随机的 $3N \\times M$ 矩阵，并使用QR分解（`numpy.linalg.qr`）得到具有标准正交列的 $3N \\times M$ 矩阵 $E$，代表简正模。\n3.  **合成数据生成**：根据推导出的统计数据，对一批 $n$ 个速度向量 $v$ 进行采样。这是通过首先生成一个来自 $N(0,1)$ 的 $n \\times 3N$ 随机数矩阵，然后将每列 $j$ 按其对应速度分量的标准差 $\\sigma_{v_j} = \\sqrt{k_{\\mathrm{B}} T_{\\mathrm{true}} / m'_j}$ 进行缩放来完成的。然后对这些速度向量进行质量加权（$U = V \\cdot W^{1/2}$），并投影到模式上（$A = U E$），以生成一个 $n \\times M$ 的矩阵 `a_samples`，其中包含所有模态坐标的时间序列。\n4.  **能量计算与统计检验**：瞬时模态动能计算为 $K_{i,j} = \\frac{1}{2} a_{i,j}^2$。为每个模式计算样本均值 $\\bar{K}_i$。使用 $T_{\\mathrm{rep}}$ 计算基准能量 $E_{\\mathrm{bench}}$。使用 `scipy.stats.chi2.ppf` 获得分位数 $\\chi^2_{0.025}(n)$ 和 $\\chi^2_{0.975}(n)$。使用NumPy的向量操作同时计算所有 $M$ 个模式的置信区间的下界和上界。\n5.  **结果汇总**：一个布尔数组指示哪些模式的基准 $E_{\\mathrm{bench}}$ 位于置信区间内。该数组的总和给出了“成功”模式的总数。将此计数除以 $M$ 以获得该测试用例的最终分数。\n对所有测试用例重复此过程，并报告所得的分数。当 $T_{\\mathrm{true}} = T_{\\mathrm{rep}}$ 时，该分数预计将接近 $0.95$，反映了置信区间的定义。当 $T_{\\mathrm{true}} \\neq T_{\\mathrm{rep}}$ 时，样本均值将围绕一个不同于基准的值，对于足够大的样本量 $n$，窄的置信区间很可能不包含基准，导致分数接近 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # Define physical constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    AMU_TO_KG = 1.66053906660e-27  # Atomic mass unit to kg conversion\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': 5, 'M': 10, 'masses_amu': [12.0]*5, 'T_true': 300.0, 'T_rep': 300.0, 'n': 20000, 'seed': 271828},\n        # Case 2 (heterogeneous masses, small sample)\n        {'N': 3, 'M': 9, 'masses_amu': [1.0, 12.0, 197.0], 'T_true': 300.0, 'T_rep': 300.0, 'n': 200, 'seed': 314159},\n        # Case 3 (mismatched verification temperature)\n        {'N': 4, 'M': 12, 'masses_amu': [39.948, 1.008, 15.999, 12.011], 'T_true': 600.0, 'T_rep': 300.0, 'n': 5000, 'seed': 141421},\n        # Case 4 (boundary: single mode)\n        {'N': 1, 'M': 1, 'masses_amu': [16.0], 'T_true': 300.0, 'T_rep': 300.0, 'n': 50, 'seed': 161803},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case, K_B, AMU_TO_KG)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(case_params, k_b, amu_to_kg):\n    \"\"\"\n    Processes a single test case for equipartition verification.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for the test case.\n        k_b (float): Boltzmann constant.\n        amu_to_kg (float): Conversion factor from AMU to kilograms.\n        \n    Returns:\n        float: The fraction of modes for which the benchmark energy is within the 95% CI.\n    \"\"\"\n    # Unpack parameters\n    N = case_params['N']\n    M = case_params['M']\n    masses_amu = case_params['masses_amu']\n    T_true = case_params['T_true']\n    T_rep = case_params['T_rep']\n    n = case_params['n']\n    seed = case_params['seed']\n\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # 1. System Setup\n    dim = 3 * N\n    masses_kg = np.array(masses_amu) * amu_to_kg\n    # Create the 3N-dimensional vector of masses for each Cartesian component\n    mass_vec_kg = np.repeat(masses_kg, 3)\n    sqrt_mass_vec_kg = np.sqrt(mass_vec_kg)\n\n    # 2. Construct Orthonormal Modes E\n    # Generate a random matrix and use QR decomposition to get an orthonormal basis\n    A = np.random.randn(dim, M)\n    E, _ = np.linalg.qr(A, mode='reduced')\n\n    # 3. Generate Synthetic Velocity Data and Project to Modes\n    # Standard deviation for each Cartesian velocity component\n    v_scales = np.sqrt(k_b * T_true / mass_vec_kg)\n    \n    # Generate n samples of the 3N-dimensional velocity vector V\n    # This is done in a fully vectorized manner for efficiency.\n    V_samples = np.random.normal(loc=0.0, scale=v_scales, size=(n, dim))\n    \n    # Transform to mass-weighted velocities U\n    U_samples = V_samples * sqrt_mass_vec_kg # Broadcasting applies this element-wise\n    \n    # Project onto normal modes to get modal velocities a\n    a_samples = U_samples @ E  # (n, 3N) @ (3N, M) -> (n, M)\n\n    # 4. Compute Modal Energies and Sample Means\n    # Instantaneous kinetic energy for each mode at each sample\n    K_samples = 0.5 * a_samples**2  # (n, M)\n    \n    # Sample mean kinetic energy for each mode\n    K_bar_vector = np.mean(K_samples, axis=0) # (M,)\n\n    # 5. Construct Confidence Intervals and Test\n    # Calculate the thermal benchmark energy for verification\n    E_bench = 0.5 * k_b * T_rep\n\n    # Get the critical values from the chi-squared distribution for a 95% CI\n    # df = n (degrees of freedom is the sample size)\n    # alpha = 0.05\n    q1 = chi2.ppf(0.025, df=n)\n    q2 = chi2.ppf(0.975, df=n)\n\n    # Calculate the confidence interval bounds for all modes simultaneously\n    CI_lower = (n * K_bar_vector) / q2\n    CI_upper = (n * K_bar_vector) / q1\n\n    # Check for which modes the benchmark falls within the CI\n    is_inside = (CI_lower = E_bench)  (E_bench = CI_upper)\n    count = np.sum(is_inside)\n\n    # 6. Calculate and return the fraction\n    fraction = count / M\n    return fraction\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3411252"}, {"introduction": "在掌握了经典图像后，我们必须探索其适用边界。能量均分定理是一个纯粹的经典力学结论，在量子效应不可忽略时便会失效，尤其是在高频振动或低温条件下（即 $\\hbar\\omega \\gt k_B T$）。这项练习 [@problem_id:3411248] 将通过编程，直接且定量地比较一个经典（白噪声）恒温器和一个遵循量子统计的（有色噪声）恒温器，从而揭示热容等物理性质如何偏离经典预测。这项实践有助于深入理解何时必须在模拟中考虑量子效应。", "problem": "本题要求您对一组无相互作用的一维谐振子模式，形式化、推导并实现一个定量比较。该比较针对使用白噪声温控器（经典能量均分）的经典分子动力学（MD）和使用与涨落耗散原理一致的频率依赖噪声（量子有色噪声）的量子温控器。测试目标是通过检验定容热容和模式热能的温度依赖性，来探究经典均分在高频下的失效情况。您必须从基本原理出发，不得使用问题陈述中提供的任何快捷公式。\n\n考虑一个由 $N$ 个独立的一维谐振子模式组成的系统，其角频率为 $\\{\\omega_i\\}_{i=1}^N$，并与温度为 $T$ 的热环境耦合。经典温控器被建模为一个白噪声 Langevin 浴，在平衡状态下，它能对二次自由度产生经典的能量均分结果。量子温控器被建模为一个有色噪声浴，其噪声谱受到线性振子量子涨落耗散关系的约束；它应当在平衡状态下再现谐振子模式的正确量子热占据数。\n\n任务：\n- 从第一性原理和核心定义出发，推导：\n  - 对于经典温控器：一维谐振子在平衡状态下每个模式的热平均能量 $E_{\\mathrm{cl}}(\\omega,T)$，以及每个模式的定容热容 $C_{V,\\mathrm{cl}}(\\omega,T)$。\n  - 对于量子温控器：每个模式的热平均能量 $E_{\\mathrm{q}}(\\omega,T)$（不包括任何零点能贡献），以及相应的每个模式的定容热容 $C_{V,\\mathrm{q}}(\\omega,T) = \\partial E_{\\mathrm{q}}/\\partial T$。您的推导应仅使用谐振子的正则配分函数和线性响应的量子形式涨落耗散原理等基本依据，而不是任何预先给定的目标表达式。\n- 使用推导出的表达式，实现一个程序，对下述每个测试用例计算：\n  1. 总经典热容 $C_{V,\\mathrm{cl}}^{\\mathrm{tot}}(T) = \\sum_{i=1}^N C_{V,\\mathrm{cl}}(\\omega_i,T)$，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$。\n  2. 总量子热容 $C_{V,\\mathrm{q}}^{\\mathrm{tot}}(T) = \\sum_{i=1}^N C_{V,\\mathrm{q}}(\\omega_i,T)$，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$。\n  3. 平均经典模式热能 $\\overline{E}_{\\mathrm{cl}}(T) = \\frac{1}{N}\\sum_{i=1}^N E_{\\mathrm{cl}}(\\omega_i,T)$，单位为 $\\mathrm{J}$。\n  4. 平均量子模式热能 $\\overline{E}_{\\mathrm{q}}(T) = \\frac{1}{N}\\sum_{i=1}^N E_{\\mathrm{q}}(\\omega_i,T)$，单位为 $\\mathrm{J}$。\n  5. 一个失效指示器 $b(T)$，定义为以下谓词的布尔值：存在至少一个模式 $\\omega_i$，使得 $E_{\\mathrm{q}}(\\omega_i,T) \\le \\alpha\\,k_{\\mathrm{B}} T$，其中 $\\alpha = 0.5$。这里 $k_{\\mathrm{B}}$ 表示玻尔兹曼常数。\n\n您可以使用的基本依据：\n- 平衡态下二次自由度的经典能量均分定理。\n- 谐振子的正则配分函数。\n- 线性系统的经典和量子形式的涨落耗散原理。\n- 标准热力学恒等式，如 $C_V = \\left(\\partial \\langle E \\rangle/\\partial T\\right)_V$。\n- 量子谐振子不包括零点能的热能定义。\n\n常数：\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 使用 $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$。\n\n单位和数值要求：\n- 角频率 $\\omega$ 以 $\\mathrm{s}^{-1}$ 为单位。\n- 温度 $T$ 以 $\\mathrm{K}$ 为单位。\n- 能量必须以 $\\mathrm{J}$ 报告，热容以 $\\mathrm{J}\\,\\mathrm{K}^{-1}$ 报告。\n- 所有浮点数输出，四舍五入至 $8$ 位有效数字。\n\n测试套件：\n- 用例 $\\mathrm{A}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{12},\\ 1.0\\times 10^{13},\\ 1.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n- 用例 $\\mathrm{B}$：$T = 5\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{12},\\ 1.0\\times 10^{13},\\ 1.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n- 用例 $\\mathrm{C}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [1.0\\times 10^{10},\\ 2.0\\times 10^{10},\\ 5.0\\times 10^{10}]\\ \\mathrm{s}^{-1}$。\n- 用例 $\\mathrm{D}$：$T = 300\\ \\mathrm{K}$，$\\{\\omega_i\\} = [5.0\\times 10^{14}]\\ \\mathrm{s}^{-1}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个包含四个结果的列表，每个测试用例一个，按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 的顺序排列。每个结果本身必须是一个列表，其中包含恰好五个条目，顺序如上所述：$[C_{V,\\mathrm{cl}}^{\\mathrm{tot}},\\ C_{V,\\mathrm{q}}^{\\mathrm{tot}},\\ \\overline{E}_{\\mathrm{cl}},\\ \\overline{E}_{\\mathrm{q}},\\ b]$。\n- 该行必须是一个用方括号括起来的逗号分隔列表，且不得包含任何空格。例如，整体形状必须与 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ 匹配。", "solution": "我们考虑一组独立的一维谐振子模式，其角频率为 $\\{\\omega_i\\}_{i=1}^N$。坐标 $q_i$ 和动量 $p_i$ 由二次哈密顿量 $H_i = \\frac{p_i^2}{2m_i} + \\frac{1}{2} m_i \\omega_i^2 q_i^2$ 控制。我们将推导经典浴和量子浴下的热平均能量和定容热容。我们强调，对于量子情况，我们定义的热能不包括与温度无关的零点能。\n\n经典情况：\n根据经典能量均分定理，在温度 $T$ 下，每个独立的二次项对平均能量的贡献为 $\\frac{1}{2} k_{\\mathrm{B}} T$。对于一维谐振子，有两个二次项，因此每个模式的平均能量是\n$$\nE_{\\mathrm{cl}}(\\omega,T) = k_{\\mathrm{B}} T.\n$$\n由于该结果与 $\\omega$ 无关，每个模式的定容热容为\n$$\nC_{V,\\mathrm{cl}}(\\omega,T) = \\left(\\frac{\\partial E_{\\mathrm{cl}}}{\\partial T}\\right)_V = k_{\\mathrm{B}}.\n$$\n对 $N$ 个独立模式求和，得到总经典热容 $C_{V,\\mathrm{cl}}^{\\mathrm{tot}}(T) = N k_{\\mathrm{B}}$，平均模式能量仍为 $\\overline{E}_{\\mathrm{cl}}(T) = k_{\\mathrm{B}} T$。\n\n量子情况：\n有两种互补的基本方法：正则配分函数方法，以及从与遵守量子涨落耗散定理（FDT）的浴耦合的线性振子的涨落耗散角度出发。两者都能得到一致的平衡态平均值。\n\n配分函数推导：\n量子谐振子的能谱为 $\\epsilon_n = \\hbar \\omega \\left(n + \\frac{1}{2}\\right)$，其中 $n \\in \\{0,1,2,\\ldots\\}$。在逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$ 下的正则配分函数是\n$$\nZ(\\beta) = \\sum_{n=0}^\\infty e^{-\\beta \\hbar \\omega \\left(n + \\frac{1}{2}\\right)} = \\frac{e^{-\\frac{1}{2}\\beta \\hbar \\omega}}{1 - e^{-\\beta \\hbar \\omega}}.\n$$\n平均能量为 $\\langle E \\rangle = - \\frac{\\partial}{\\partial \\beta} \\ln Z(\\beta)$，得到\n$$\n\\langle E \\rangle = \\frac{1}{2} \\hbar \\omega + \\frac{\\hbar \\omega}{e^{\\beta \\hbar \\omega} - 1}.\n$$\n我们定义热能（不包括零点项）为\n$$\nE_{\\mathrm{q}}(\\omega,T) = \\langle E \\rangle - \\frac{1}{2} \\hbar \\omega = \\frac{\\hbar \\omega}{e^{\\beta \\hbar \\omega} - 1}.\n$$\n每个模式的定容热容为\n$$\nC_{V,\\mathrm{q}}(\\omega,T) = \\left(\\frac{\\partial E_{\\mathrm{q}}}{\\partial T}\\right)_V = k_{\\mathrm{B}} \\frac{(\\beta \\hbar \\omega)^2 e^{\\beta \\hbar \\omega}}{\\left(e^{\\beta \\hbar \\omega} - 1\\right)^2}.\n$$\n\n涨落耗散原理：\n对于一个质量为 $m$、角频率为 $\\omega_0$ 的线性振子，与一个具有记忆核 $\\gamma(\\omega)$ 的浴耦合，量子 FDT 将力噪声功率谱密度 $S_{FF}(\\omega)$ 与响应函数 $\\chi(\\omega)$ 的虚部联系起来，使得热涨落中包含了因子 $\\coth\\!\\left(\\frac{\\hbar \\omega}{2 k_{\\mathrm{B}} T}\\right)$。对于平衡态下的谐振子，在线性响应框架内使用此 FDT 会得到一个平稳方差，该方差对应于正则系综平均值，并且在排除零点能贡献后，得到与上述相同的热能 $E_{\\mathrm{q}}(\\omega,T)$。因此，一个正确设计的量子有色噪声温控器会再现相同的 $E_{\\mathrm{q}}(\\omega,T)$ 和 $C_{V,\\mathrm{q}}(\\omega,T)$。\n\n一致性检验与极限情况：\n- 经典极限：在高温极限下（即 $x \\equiv \\beta \\hbar \\omega \\ll 1$），量子热能 $E_{\\mathrm{q}}(\\omega,T)$ 趋于其经典极限 $k_{\\mathrm{B}} T$。类似地，热容 $C_{V,\\mathrm{q}}(\\omega,T)$ 也趋于经典值 $k_{\\mathrm{B}}$。\n- 量子高频或低温极限：对于 $x \\gg 1$，$E_{\\mathrm{q}}(\\omega,T) \\approx \\hbar \\omega e^{-x}$ 呈指数级减小，而 $C_{V,\\mathrm{q}}(\\omega,T) \\approx k_{\\mathrm{B}} x^2 e^{-x}$ 趋于零，这标志着经典均分定理的严重失效。\n\n算法设计：\n- 输入：对于每个测试用例，获取温度 $T$ 和角频率列表 $\\{\\omega_i\\}$（单位为 $\\mathrm{s}^{-1}$）。\n- 常数：使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$ 和 $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$。\n- 经典量：\n  - 每模式：$E_{\\mathrm{cl}}(\\omega_i,T) = k_{\\mathrm{B}} T$，$C_{V,\\mathrm{cl}}(\\omega_i,T) = k_{\\mathrm{B}}$。\n  - 总热容：$C_{V,\\mathrm{cl}}^{\\mathrm{tot}} = N k_{\\mathrm{B}}$。\n  - 平均能量：$\\overline{E}_{\\mathrm{cl}} = k_{\\mathrm{B}} T$。\n- 量子量：\n  - 定义 $x_i = \\frac{\\hbar \\omega_i}{k_{\\mathrm{B}} T}$。\n  - 每模式热能：$E_{\\mathrm{q}}(\\omega_i,T) = \\frac{\\hbar \\omega_i}{\\exp(x_i) - 1}$；对于小的 $x_i$，通过 $\\exp\\!-\\!1$ 进行数值稳定的计算。\n  - 每模式热容：$C_{V,\\mathrm{q}}(\\omega_i,T) = k_{\\mathrm{B}} \\frac{x_i^2 e^{x_i}}{\\left(e^{x_i} - 1\\right)^2}$；为避免小 $x_i$ 时的抵消误差，使用 $\\exp\\!-\\!1$ 计算。\n  - 总热容：$C_{V,\\mathrm{q}}^{\\mathrm{tot}} = \\sum_i C_{V,\\mathrm{q}}(\\omega_i,T)$。\n  - 平均能量：$\\overline{E}_{\\mathrm{q}} = \\frac{1}{N} \\sum_i E_{\\mathrm{q}}(\\omega_i,T)$。\n- 失效指示器：\n  - 定义 $b(T)$ 为真，如果 $\\exists i$ 使得 $E_{\\mathrm{q}}(\\omega_i,T) \\le 0.5\\,k_{\\mathrm{B}} T$。\n- 数值输出：\n  - 将所有浮点输出四舍五入到 $8$ 位有效数字。\n  - 对每个测试用例，按顺序报告 $[C_{V,\\mathrm{cl}}^{\\mathrm{tot}},\\ C_{V,\\mathrm{q}}^{\\mathrm{tot}},\\ \\overline{E}_{\\mathrm{cl}},\\ \\overline{E}_{\\mathrm{q}},\\ b]$，并将四个用例的结果按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 的顺序聚合成一个无空格的、用逗号分隔的方括号列表。\n\n该算法直接测试了能量均分定理的量子失效：在高频或低温区，量子热能和热容远小于其经典对应值，失效指示器变为真。在低频或高温区，经典和量子结果在数值容差范围内一致，失效指示器变为假。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI units)\nK_B = 1.380649e-23       # Boltzmann constant, J/K\nHBAR = 1.054571817e-34   # Reduced Planck constant, J*s\n\ndef quantum_thermal_energy(omega, T):\n    \"\"\"\n    Thermal energy (excluding zero-point) for a quantum harmonic oscillator mode.\n    E_q = ħω / (exp(ħω/(k_B T)) - 1)\n    Uses numerically stable computations via expm1.\n    \"\"\"\n    x = (HBAR * omega) / (K_B * T)\n    # Use expm1 for stability at small x; avoid division by zero by handling T>0 guaranteed in test suite.\n    denom = np.expm1(x)\n    # For very large x, expm1(x) ~ exp(x) leading to tiny energies; no special handling needed.\n    E = (HBAR * omega) / denom\n    return E\n\ndef quantum_heat_capacity(omega, T):\n    \"\"\"\n    Heat capacity for a quantum harmonic oscillator mode (thermal part).\n    C_V = k_B * (x^2 * exp(x)) / (expm1(x)^2), where x = ħω/(k_B T).\n    \"\"\"\n    x = (HBAR * omega) / (K_B * T)\n    ex = np.exp(x)\n    exm1 = np.expm1(x)\n    # Handle small x stably using exm1; for large x this is also stable enough for given test suite.\n    C = K_B * (x * x * ex) / (exm1 * exm1)\n    return C\n\ndef classical_thermal_energy(T):\n    \"\"\"\n    Classical thermal energy per 1D harmonic oscillator mode (kinetic + potential).\n    E_cl = k_B T\n    \"\"\"\n    return K_B * T\n\ndef classical_heat_capacity():\n    \"\"\"\n    Classical heat capacity per 1D harmonic oscillator mode.\n    C_V = k_B\n    \"\"\"\n    return K_B\n\ndef round_sig(x, sig=8):\n    \"\"\"\n    Round a float to a given number of significant figures.\n    \"\"\"\n    if x == 0.0 or not np.isfinite(x):\n        return float(x)\n    # Use decimal shift\n    p = int(np.floor(np.log10(abs(x))))\n    factor = 10 ** (sig - 1 - p)\n    return np.round(x * factor) / factor\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Serialize nested Python lists containing floats/booleans into a string\n    with no spaces and floats formatted to 8 significant figures.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_no_spaces(e) for e in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"True\" if obj else \"False\"\n    elif isinstance(obj, (float, np.floating, int, np.integer)):\n        if isinstance(obj, (int, np.integer)):\n            return str(int(obj))\n        # format to 8 significant figures, using scientific notation as needed\n        return \"{:.8g}\".format(obj)\n    else:\n        # Fallback to string\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T in K, list of omegas in s^-1)\n    test_cases = [\n        (300.0, [1.0e12, 1.0e13, 1.0e14]),          # Case A\n        (5.0,   [1.0e12, 1.0e13, 1.0e14]),          # Case B\n        (300.0, [1.0e10, 2.0e10, 5.0e10]),          # Case C\n        (300.0, [5.0e14]),                          # Case D\n    ]\n\n    results = []\n    alpha = 0.5  # breakdown threshold factor\n\n    for T, omega_list in test_cases:\n        omegas = np.array(omega_list, dtype=float)\n        N = len(omegas)\n\n        # Classical per-mode quantities\n        E_cl_mode = classical_thermal_energy(T)  # scalar\n        C_cl_mode = classical_heat_capacity()    # scalar\n\n        # Classical totals and averages\n        C_cl_tot = C_cl_mode * N\n        E_cl_avg = E_cl_mode  # same for each mode\n\n        # Quantum per-mode quantities\n        E_q_modes = quantum_thermal_energy(omegas, T)\n        C_q_modes = quantum_heat_capacity(omegas, T)\n\n        # Quantum totals and averages\n        C_q_tot = float(np.sum(C_q_modes))\n        E_q_avg = float(np.mean(E_q_modes))\n\n        # Breakdown indicator: exists mode with E_q = alpha * k_B T\n        breakdown = bool(np.any(E_q_modes = alpha * K_B * T))\n\n        # Rounding to 8 significant figures\n        C_cl_tot_r = round_sig(float(C_cl_tot), sig=8)\n        C_q_tot_r = round_sig(float(C_q_tot), sig=8)\n        E_cl_avg_r = round_sig(float(E_cl_avg), sig=8)\n        E_q_avg_r = round_sig(float(E_q_avg), sig=8)\n\n        results.append([C_cl_tot_r, C_q_tot_r, E_cl_avg_r, E_q_avg_r, breakdown])\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3411248"}, {"introduction": "能量均分描述了平衡态的最终分布，但系统究竟是如何达到这个状态的？这个通往平衡的“热化”过程，本身就是一个深刻的物理问题，著名的费米-帕斯塔-乌拉姆-钦戈（FPUT）悖论就凸显了其复杂性。它揭示了非线性相互作用的存在本身并不保证系统会快速、简单地达到能量均分。在这项练习 [@problem_id:3411203] 中，您将重现这一开创性的计算实验，通过追踪能量在不同简正模式间的缓慢而复杂的流动，亲身体会到热化是一个深刻且非平凡的动力学过程。", "problem": "考虑一个由 $N$ 个相同的单位质量组成的、两端固定的费米–帕斯塔–乌拉姆–秦戈 (FPUT) 链。设位置为 $\\{x_i(t)\\}_{i=1}^N$，边界条件为 $x_0(t)=0$ 和 $x_{N+1}(t)=0$。动力学遵循牛顿第二定律 $m\\,\\ddot{x}_i(t)=F_i(t)$，其中 $m=1$，并由包含线性弹簧和三次非线性的最近邻势决定。总势能为\n$$\nV(x)=\\sum_{j=0}^{N}\\left(\\frac{1}{2}\\,r_j^2+\\frac{\\alpha}{3}\\,r_j^3\\right),\n$$\n其中 $r_j=x_{j+1}-x_j$，$\\alpha$ 是一个控制非线性强度的标量参数。粒子 $i$ 上受到的力为\n$$\nF_i=\\left(r_i+\\alpha\\,r_i^2\\right)-\\left(r_{i-1}+\\alpha\\,r_{i-1}^2\\right),\\quad i=1,\\dots,N,\n$$\n其中 $r_j$ 在边界处由 $r_0=x_1-x_0=x_1$ 和 $r_N=x_{N+1}-x_N=-x_N$ 定义。所有三角表达式中使用的角度单位均为弧度。\n\n为了量化 underlying harmonic chain（底层谐振子链）的线性简正模中能量均分的趋近过程，定义标准正交离散正弦基\n$$\nS_{i,k}=\\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi k i}{N+1}\\right),\\quad i=1,\\dots,N,\\quad k=1,\\dots,N,\n$$\n和线性模频率\n$$\n\\omega_k=2\\sin\\left(\\frac{\\pi k}{2(N+1)}\\right).\n$$\n在时间 $t$ 的线性模态坐标和动量为\n$$\nQ_k(t)=\\sum_{i=1}^N x_i(t)\\,S_{i,k},\\qquad P_k(t)=\\sum_{i=1}^N \\dot{x}_i(t)\\,S_{i,k},\n$$\n线性模态能量为\n$$\nE_k(t)=\\frac{1}{2}\\left(P_k(t)^2+\\omega_k^2\\,Q_k(t)^2\\right).\n$$\n设“高频子集”为索引 $k\\in\\{ \\lfloor \\tfrac{2N}{3}\\rfloor+1,\\dots,N\\}$ 的模态集合，并定义瞬时高频能量分数\n$$\n\\phi(t)=\\frac{\\sum_{k=\\lfloor 2N/3\\rfloor+1}^N E_k(t)}{\\sum_{k=1}^N E_k(t)}.\n$$\n\n您必须编写一个程序，使用速度 Verlet 格式在自然的无量纲时间单位 $t_0=\\sqrt{m/k}$（其中 $m=1$ 且线性弹簧常数 $k=1$，因此 $t_0=1$）下对 FPUT 运动方程进行积分。使用以下数值参数：时间步长 $dt=0.02$，用于模态能量诊断评估的采样间隔为 $n_s=25$ 步，最大步数 $n_{\\max}=15000$（因此 $T_{\\max}=n_{\\max}\\,dt=300$），以及阈值分数 $\\phi_{\\mathrm{th}}=0.15$。初始条件应只激发最低的线性模态，初始速度为零，即\n$$\nx_i(0)=A\\,\\sin\\left(\\frac{\\pi i}{N+1}\\right),\\quad \\dot{x}_i(0)=0,\n$$\n其中振幅 $A$ 的选择应使模态 $k=1$ 中的初始线性能量等于 $E_0=1$，即\n$$\nE_1(0)=\\frac{1}{2}\\omega_1^2\\,Q_1(0)^2=1.\n$$\n作为解答的一部分，您需要推导并实现此约束下 $A$ 的表达式。\n\n定义“高频转移时间尺度” $t^\\ast$ 为 $\\phi(t)$ 首次超过 $\\phi_{\\mathrm{th}}$ 的最早时间。由于模态能量每 $n_s$ 步评估一次，通过在包含 $\\phi_{\\mathrm{th}}$ 的最近两个采样值 $\\phi(t)$ 之间进行线性插值来估计 $t^\\ast$。如果 $\\phi(t)$ 在 $T_{\\max}$ 之前从未超过 $\\phi_{\\mathrm{th}}$，则设 $t^\\ast=T_{\\max}$。此外，通过归一化谱熵定义 $T_{\\max}$ 时的“均分邻近指数”\n$$\nS_{\\mathrm{norm}}(T_{\\max})=\\frac{-\\sum_{k=1}^{N} p_k(T_{\\max})\\ln p_k(T_{\\max})}{\\ln N},\\quad p_k(T_{\\max})=\\frac{E_k(T_{\\max})}{\\sum_{j=1}^{N}E_j(T_{\\max})}.\n$$\n根据构造，$S_{\\mathrm{norm}}(T_{\\max})\\in[0,1]$，值越接近 $1$ 表示能量在各模态间的分布越均匀。\n\n实现您的求解器，并为以下参数对 $(N,\\alpha)$ 的测试套件计算 $\\{t^\\ast,S_{\\mathrm{norm}}(T_{\\max})\\}$：\n- 案例 1：$(N,\\alpha)=(32,0.25)$，“理想情况”，具有中等非线性和系统规模。\n- 案例 2：$(N,\\alpha)=(32,0.01)$，低非线性边界情况，转移可能非常缓慢。\n- 案例 3：$(N,\\alpha)=(48,0.25)$，在相同非线性下的更大系统规模。\n\n您的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[t^\\ast_1,S_1,t^\\ast_2,S_2,t^\\ast_3,S_3]$，其中 $t^\\ast_j$ 以无量纲时间单位 $t_0$ 表示，$S_j=S_{\\mathrm{norm}}(T_{\\max})$ 是无量纲的。输出中的每个浮点数必须四舍五入到六位小数。例如，输出格式应类似于 $[0.123456,0.987654,300.000000,0.543210,1.234567,0.876543]$。", "solution": "该问题要求对费米–帕斯塔–乌拉姆–秦戈 (FPUT) 链进行数值模拟，以研究能量均分的过程。我们的任务是积分运动方程，分析线性简正模中的能量分布，并计算两个特定的诊断量：能量转移到高频模态的时间尺度 $t^\\ast$，以及在最终模拟时间下的均分指数 $S_{\\mathrm{norm}}$。该分析将针对三组参数 $(N,\\alpha)$ 进行。\n\n首先，我们确定系统的初始状态。初始位置由最低频率简正模的形状给出，$x_i(0)=A\\,\\sin\\left(\\frac{\\pi i}{N+1}\\right)$，初始速度为零，$\\dot{x}_i(0)=0$。振幅 $A$ 由模态 $k=1$ 中的初始能量为 $E_1(0)=1$ 的约束确定。模态坐标 $Q_k(t)$ 和模态动量 $P_k(t)$ 是物理坐标和速度在简正模基 $S_{i,k}$ 上的投影。在时间 $t=0$ 时，由于所有速度 $\\dot{x}_i(0)$ 均为零，所有模态动量也为零，$P_k(0)=0$。初始模态坐标由下式给出：\n$$\nQ_k(0) = \\sum_{i=1}^N x_i(0) S_{i,k} = \\sum_{i=1}^N \\left( A\\sin\\left(\\frac{\\pi i}{N+1}\\right) \\right) \\left( \\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi k i}{N+1}\\right) \\right)\n$$\n注意到 $\\sin\\left(\\frac{\\pi i}{N+1}\\right)$ 与模态 $k=1$ 的基向量成正比，具体来说是 $S_{i,1} = \\sqrt{\\frac{2}{N+1}}\\sin\\left(\\frac{\\pi i}{N+1}\\right)$，我们可以写出 $x_i(0) = A\\sqrt{\\frac{N+1}{2}}S_{i,1}$。将此代入 $Q_k(0)$ 的表达式中：\n$$\nQ_k(0) = \\sum_{i=1}^N \\left(A\\sqrt{\\frac{N+1}{2}}S_{i,1}\\right) S_{i,k} = A\\sqrt{\\frac{N+1}{2}} \\sum_{i=1}^N S_{i,1} S_{i,k}\n$$\n由于基向量的标准正交性，$\\sum_{i=1}^N S_{i,j} S_{i,k} = \\delta_{jk}$，其中 $\\delta_{jk}$ 是克罗内克 δ 符号。因此，该和仅在 $k=1$ 时非零，得到 $Q_k(0) = A\\sqrt{\\frac{N+1}{2}}\\delta_{1k}$。这证实了初始时只有第一个模态被激发。该模态的能量为：\n$$\nE_1(0) = \\frac{1}{2} \\left( P_1(0)^2 + \\omega_1^2 Q_1(0)^2 \\right) = \\frac{1}{2} \\omega_1^2 \\left( A\\sqrt{\\frac{N+1}{2}} \\right)^2 = \\frac{1}{4} A^2 \\omega_1^2 (N+1)\n$$\n设 $E_1(0)=1$ 并解出 $A$（取振幅的正根），得到：\n$$\nA = \\frac{2}{\\omega_1 \\sqrt{N+1}}\n$$\n其中 $\\omega_1 = 2\\sin\\left(\\frac{\\pi}{2(N+1)}\\right)$，这完全确定了任何给定 $N$ 的初始条件。\n\n接下来，我们使用指定的速度 Verlet 算法对运动方程 $\\ddot{x}_i = F_i$（因为质量 $m=1$）进行积分。对于从 $1$ 到 $N$ 的每个粒子 $i$，这是一个二阶精确的格式，用于在时间步长 $dt$ 内更新位置 $x_i$ 和速度 $v_i$：\n1. 将速度更新到时间步长的中点：$v_i(t+dt/2) = v_i(t) + \\ddot{x}_i(t) \\frac{dt}{2}$。\n2. 将位置更新到时间步长的末端：$x_i(t+dt) = x_i(t) + v_i(t+dt/2) dt$。\n3. 使用新位置 $x_i(t+dt)$ 计算力 $F_i(t+dt)$。粒子 $i$ 上的力为 $F_i=(r_i+\\alpha\\,r_i^2)-(r_{i-1}+\\alpha\\,r_{i-1}^2)$，其中伸长量 $r_j=x_{j+1}-x_j$ 使用边界条件 $x_0=0$ 和 $x_{N+1}=0$ 计算。新的加速度为 $\\ddot{x}_i(t+dt) = F_i(t+dt)$。\n4. 将速度更新到时间步长的末端：$v_i(t+dt) = v_i(t+dt/2) + \\ddot{x}_i(t+dt) \\frac{dt}{2}$。\n这个过程重复 $n_{\\max}=15000$ 步，从 $t=0$ 到 $T_{\\max}=300$。\n\n诊断量每 $n_s=25$ 个时间步计算一次。在每个采样时间 $t$，我们进行简正模分析。\n首先，我们将物理位置 $x_i(t)$ 和速度 $\\dot{x}_i(t)$ 变换为模态坐标 $Q_k(t)$ 和模态动量 $P_k(t)$。这是通过与预先计算的离散正弦变换矩阵 $S_{i,k}$ 进行矩阵向量乘法实现的。设 $\\vec{x}(t)$ 和 $\\vec{v}(t)$ 分别是位置和速度的列向量，并设 $\\mathbf{S}$ 是元素为 $S_{i,k}$ 的矩阵。那么模态坐标和动量的向量为 $\\vec{Q}(t) = \\mathbf{S}^T \\vec{x}(t)$ 和 $\\vec{P}(t) = \\mathbf{S}^T \\vec{v}(t)$。\n然后，每个线性模态的能量计算为 $E_k(t)=\\frac{1}{2}(P_k(t)^2+\\omega_k^2 Q_k(t)^2)$。\n\n根据模态能量，我们计算高频能量分数 $\\phi(t)$。这是高频模态（索引 $k$ 从 $\\lfloor \\frac{2N}{3}\\rfloor+1$ 到 $N$）中的能量与总模态能量 $\\sum_{k=1}^N E_k(t)$ 的比值。\n时间尺度 $t^\\ast$ 是 $\\phi(t)$ 首次超过阈值 $\\phi_{\\mathrm{th}}=0.15$ 的时间。我们找到两个连续的采样时间 $t_{prev}$ 和 $t_{curr}$，使得 $\\phi(t_{prev}) \\le \\phi_{\\mathrm{th}}  \\phi(t_{curr})$。然后通过线性插值找到 $t^\\ast$：\n$$\nt^\\ast = t_{prev} + (t_{curr} - t_{prev}) \\frac{\\phi_{\\mathrm{th}} - \\phi(t_{prev})}{\\phi(t_{curr}) - \\phi(t_{prev})}\n$$\n如果阈值从未被超过，则将 $t^\\ast$ 设置为 $T_{\\max}=300$。如果在第一次采样之前发生穿越，则使用 $t=0$ 时的初始条件 $\\phi(0)=0$ 进行插值。\n\n最后，在模拟结束时（$t=T_{\\max}$），我们计算均分邻近指数 $S_{\\mathrm{norm}}$。这需要计算每个模态的能量份额，$p_k = E_k(T_{\\max}) / \\sum_j E_j(T_{\\max})$。然后，归一化谱熵为：\n$$\nS_{\\mathrm{norm}}(T_{\\max}) = \\frac{-\\sum_{k=1}^{N} p_k \\ln p_k}{\\ln N}\n$$\n在求和中，当 $p_k=0$ 时，该项的贡献为 $0$。$S_{\\mathrm{norm}}$ 的值接近 $1$ 表示能量均匀分布在所有模态上，接近热平衡（均分）。值接近 $0$ 表示能量集中在少数几个模态中。\n\n总体算法包括一个主函数，该函数遍历三个测试案例 $(N, \\alpha)$。对于每个案例，一个专用的模拟函数根据 $N$ 初始化系统，运行速度 Verlet 积分循环 $n_{\\max}$ 步，并以 $n_s$ 步的间隔计算诊断量，最终确定并返回 $\\{t^\\ast, S_{\\mathrm{norm}}(T_{\\max})\\}$ 对。最终结果被收集并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fput_simulation(N, alpha, dt, n_max, n_s, phi_th):\n    \"\"\"\n    Runs a single FPUT simulation for a given N and alpha.\n    \"\"\"\n    # 1. System Initialization\n    \n    # 1a. Define basis vectors and frequencies\n    k_vec = np.arange(1, N + 1)\n    i_vec = np.arange(1, N + 1)\n    \n    # S_matrix[i-1, k-1] corresponds to S_{i,k}\n    S_matrix = np.sqrt(2 / (N + 1)) * np.sin(np.pi * np.outer(i_vec, k_vec) / (N + 1))\n    \n    # omega_k[k-1] corresponds to omega_k\n    omega_k = 2 * np.sin(np.pi * k_vec / (2 * (N + 1)))\n\n    # 1b. Calculate initial amplitude A for E_1(0) = 1\n    omega_1 = omega_k[0]\n    A = 2 / (omega_1 * np.sqrt(N + 1))\n    \n    # 1c. Set initial positions and velocities\n    x = A * np.sin(np.pi * i_vec / (N + 1))  # Initial position vector\n    v = np.zeros(N)                         # Initial velocity vector\n    \n    # Helper function for force calculation\n    def calculate_forces(pos, alpha_val):\n        # Pad positions with fixed boundaries x_0=0, x_{N+1}=0\n        x_padded = np.zeros(N + 2)\n        x_padded[1:-1] = pos\n        # Stretches r_j = x_{j+1} - x_j\n        r = np.diff(x_padded)\n        # Intermediate force term\n        f_term = r + alpha_val * r**2\n        # Force F_i = f_term_i - f_term_{i-1}\n        return f_term[1:] - f_term[:-1]\n\n    # Initial acceleration (since m=1)\n    a = calculate_forces(x, alpha)\n    \n    # 2. Main Integration Loop\n    t_star = n_max * dt  # Initialize to T_max\n    found_t_star = False\n    \n    # For interpolation, store previous phi and time\n    # Initialize with t=0 values: phi(0)=0\n    phi_prev, t_prev = 0.0, 0.0\n    \n    # To hold the final modal energies needed for S_norm\n    E_k_final = np.zeros(N)\n\n    for step in range(n_max):\n        # Velocity Verlet integration step\n        v_half = v + 0.5 * dt * a\n        x = x + dt * v_half\n        a_new = calculate_forces(x, alpha)\n        v = v_half + 0.5 * dt * a_new\n        a = a_new\n        \n        current_time = (step + 1) * dt\n        \n        # 3. Diagnostics (every n_s steps)\n        if (step + 1) % n_s == 0:\n            # Transform to modal coordinates/momenta\n            Q = S_matrix.T @ x\n            P = S_matrix.T @ v\n            \n            # Calculate modal energies\n            E_k = 0.5 * (P**2 + (omega_k * Q)**2)\n            \n            # Calculate high-frequency energy fraction phi(t)\n            E_total = np.sum(E_k)\n            phi_current = 0.0\n            if E_total > 1e-12: # Avoid division by zero\n                k_high_start_idx = int(2 * N / 3) \n                E_high = np.sum(E_k[k_high_start_idx:])\n                phi_current = E_high / E_total\n\n            # Check for t_star crossing\n            if not found_t_star and phi_current > phi_th:\n                # Linearly interpolate to find t_star\n                if np.abs(phi_current - phi_prev) > 1e-12:\n                    t_star = t_prev + (current_time - t_prev) * (phi_th - phi_prev) / (phi_current - phi_prev)\n                else: # Fallback if denominator is zero\n                    t_star = current_time\n                found_t_star = True\n\n            # Update previous values for next potential interpolation\n            t_prev = current_time\n            phi_prev = phi_current\n\n            # If this is the last step, store E_k for S_norm\n            if step == n_max - 1:\n                E_k_final = E_k\n\n    # 4. Final equipartition index S_norm\n    E_total_final = np.sum(E_k_final)\n    S_norm = 0.0\n    if E_total_final > 1e-12:\n        p_k = E_k_final / E_total_final\n        # Filter p_k > 0 to avoid log(0)\n        p_k_nonzero = p_k[p_k > 0]\n        entropy = -np.sum(p_k_nonzero * np.log(p_k_nonzero))\n        S_norm = entropy / np.log(N)\n\n    return t_star, S_norm\n\ndef solve():\n    # Define the problem parameters and test cases.\n    dt = 0.02\n    n_s = 25\n    n_max = 15000\n    phi_th = 0.15\n    \n    test_cases = [\n        (32, 0.25),  # Case 1\n        (32, 0.01),  # Case 2\n        (48, 0.25),  # Case 3\n    ]\n\n    results = []\n    for N, alpha in test_cases:\n        t_star, S_norm = run_fput_simulation(N, alpha, dt, n_max, n_s, phi_th)\n        results.append(t_star)\n        results.append(S_norm)\n\n    # Format the final output as a comma-separated list of floats with 6 decimal places.\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3411203"}]}