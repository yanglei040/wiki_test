{"hands_on_practices": [{"introduction": "在相空间动力学中，除了跟踪单个粒子的轨迹，我们还需要一个强大的数学工具来描述任意物理观测量如何随时间演化。泊松括号正是为此而生的经典力学框架，它揭示了哈密顿系统中不同物理量之间的深刻联系。本练习 [@problem_id:3435414] 将引导您计算角动量各分量之间的泊松括号，从而揭示控制经典系统中旋转动力学的基本代数结构，即李代数 $\\mathfrak{so}(3)$。", "problem": "考虑一个在三维 (3D) 笛卡尔相空间中按经典分子动力学 (MD) 演化的单粒子，其正则位置坐标为 $q_{x}$、$q_{y}$、$q_{z}$，正则动量坐标为 $p_{x}$、$p_{y}$、$p_{z}$。轨道角动量分量定义为 $L_{x} = q_{y} p_{z} - q_{z} p_{y}$、$L_{y} = q_{z} p_{x} - q_{x} p_{z}$ 和 $L_{z} = q_{x} p_{y} - q_{y} p_{x}$。两个相空间函数 $A(q,p)$ 和 $B(q,p)$ 的泊松括号定义为\n$$\n\\{A,B\\} = \\sum_{i \\in \\{x,y,z\\}} \\left( \\frac{\\partial A}{\\partial q_{i}} \\frac{\\partial B}{\\partial p_{i}} - \\frac{\\partial A}{\\partial p_{i}} \\frac{\\partial B}{\\partial q_{i}} \\right),\n$$\n并且使用列维-奇维塔符号 $\\epsilon_{ijk}$ 和克罗内克 δ 符号 $\\delta_{ij}$，同时对重复指标遵循爱因斯坦求和约定。\n\n从上面泊松括号的基本定义和相空间的正则结构出发，计算角动量分量之间的泊松括号，并将一般括号的最终结果以紧凑的指标记法表示为单个解析表达式。无需进行数值计算，也无需报告单位。[@problem_id:151]", "solution": "问题要求计算在三维笛卡尔相空间中单个粒子的轨道角动量矢量各分量之间的泊松括号 $\\{L_i, L_j\\}$。最终结果需要用紧凑的指标记法表示。\n\n首先，我们用指标记法表示相关量，并对重复指标采用爱因斯坦求和约定。正则坐标为 $q_k$ 和 $p_k$（指标 $k=1,2,3$）。\n\n角动量分量 $L_i$ 可以写为：\n$$ L_i = \\epsilon_{ik\\ell} q_k p_\\ell $$\n其中 $\\epsilon_{ik\\ell}$ 是列维-奇维塔符号。例如，$L_1 = \\epsilon_{1k\\ell} q_k p_\\ell = \\epsilon_{123} q_2 p_3 + \\epsilon_{132} q_3 p_2 = q_2 p_3 - q_3 p_2$，这与给定的 $L_x$ 定义相符。\n\n泊松括号 $\\{A,B\\}$ 定义为：\n$$ \\{A,B\\} = \\sum_{s=1}^3 \\left( \\frac{\\partial A}{\\partial q_s} \\frac{\\partial B}{\\partial p_s} - \\frac{\\partial A}{\\partial p_s} \\frac{\\partial B}{\\partial q_s} \\right) $$\n我们将使用这个定义来计算 $\\{L_i, L_j\\}$。首先，计算所需的偏导数：\n$$ \\frac{\\partial L_i}{\\partial q_s} = \\frac{\\partial}{\\partial q_s} (\\epsilon_{ik\\ell} q_k p_\\ell) = \\epsilon_{ik\\ell} \\delta_{ks} p_\\ell = \\epsilon_{is\\ell} p_\\ell $$\n$$ \\frac{\\partial L_i}{\\partial p_s} = \\frac{\\partial}{\\partial p_s} (\\epsilon_{ik\\ell} q_k p_\\ell) = \\epsilon_{ik\\ell} q_k \\delta_{\\ell s} = \\epsilon_{iks} q_k $$\n类似地，对于 $L_j = \\epsilon_{jmn} q_m p_n$：\n$$ \\frac{\\partial L_j}{\\partial p_s} = \\epsilon_{jmn} q_m \\delta_{ns} = \\epsilon_{jms} q_m $$\n$$ \\frac{\\partial L_j}{\\partial q_s} = \\epsilon_{jmn} q_m \\delta_{ms} = \\epsilon_{jsn} p_n $$\n\n将这些导数代入泊松括号的定义中：\n$$ \\{L_i, L_j\\} = \\sum_{s=1}^3 \\left[ (\\epsilon_{is\\ell} p_\\ell)(\\epsilon_{jms} q_m) - (\\epsilon_{iks} q_k)(\\epsilon_{jsn} p_n) \\right] $$\n我们将分别计算这两个项，对所有哑指标（$s, k, \\ell, m, n$）求和。\n$$ \\{L_i, L_j\\} = p_\\ell q_m \\left(\\sum_s \\epsilon_{is\\ell} \\epsilon_{jms}\\right) - q_k p_n \\left(\\sum_s \\epsilon_{iks} \\epsilon_{jsn}\\right) $$\n\n对于第一项中的求和，我们使用关于两个列维-奇维塔符号乘积的恒等式 $\\sum_s \\epsilon_{abs} \\epsilon_{cds} = \\delta_{ac}\\delta_{bd} - \\delta_{ad}\\delta_{bc}$。\n$$ \\sum_s \\epsilon_{is\\ell} \\epsilon_{jms} = \\sum_s \\epsilon_{\\ell is} \\epsilon_{msj} = \\delta_{\\ell m}\\delta_{ij} - \\delta_{\\ell j}\\delta_{im} $$\n代入后，第一项变为：\n$$ p_\\ell q_m (\\delta_{\\ell m}\\delta_{ij} - \\delta_{\\ell j}\\delta_{im}) = \\delta_{ij} p_m q_m - p_j q_i $$\n\n对于第二项中的求和：\n$$ \\sum_s \\epsilon_{iks} \\epsilon_{jsn} = \\sum_s \\epsilon_{ki,s} \\epsilon_{nj,s} = \\delta_{kn}\\delta_{ij} - \\delta_{kj}\\delta_{in} $$\n代入后，第二项变为：\n$$ q_k p_n (\\delta_{kn}\\delta_{ij} - \\delta_{kj}\\delta_{in}) = \\delta_{ij} q_k p_k - q_j p_i $$\n\n现在，我们将两项组合起来，注意泊松括号定义中的减号：\n$$ \\{L_i, L_j\\} = (\\delta_{ij} p_m q_m - p_j q_i) - (\\delta_{ij} q_k p_k - q_j p_i) $$\n$$ \\{L_i, L_j\\} = \\delta_{ij} (p_m q_m) - p_j q_i - \\delta_{ij} (q_k p_k) + q_j p_i $$\n两个标量积项 $p_m q_m$ 和 $q_k p_k$ 是相同的，因此它们相互抵消：\n$$ \\{L_i, L_j\\} = q_j p_i - p_j q_i $$\n这个结果看起来不对。让我们重新检查一下。\n\n重新审视步骤，我的导数计算是正确的，恒等式也是正确的，代入也是正确的。问题出在最后一步的组合上。\n$p_j q_i$ 和 $q_j p_i$ 是不同的。\nLet's restart from combining:\n$\\{L_i, L_j\\} = (\\delta_{ij} p_m q_m - p_j q_i) - (\\delta_{ij} q_k p_k - q_j p_i)$\nThe sign on $p_j q_i$ was wrong. It should be $q_i p_j$.\nLet's retrace the first term: $p_\\ell q_m (\\delta_{\\ell j}\\delta_{im} - \\delta_{\\ell m}\\delta_{ij}) = q_i p_j - \\delta_{ij}q_m p_m$. This is correct.\nLet's retrace the second term: $q_k p_n (\\delta_{in}\\delta_{kj} - \\delta_{ij}\\delta_{kn}) = q_j p_i - \\delta_{ij}q_k p_k$. This is correct.\nSo $\\{L_i, L_j\\} = \\text{Term1} - \\text{Term2} = (q_i p_j - \\delta_{ij}(\\vec{q}\\cdot\\vec{p})) - (q_j p_i - \\delta_{ij}(\\vec{q}\\cdot\\vec{p})) = q_i p_j - q_j p_i$.\nThis intermediate result is correct.\n\n现在，我们需要将这个结果与 $L_k$ 联系起来。\n$$ \\epsilon_{ijk} L_k = \\epsilon_{ijk} (\\epsilon_{k\\ell m} q_\\ell p_m) $$\n我们使用恒等式 $\\sum_k \\epsilon_{ijk} \\epsilon_{k\\ell m} = \\delta_{i\\ell}\\delta_{jm} - \\delta_{im}\\delta_{j\\ell}$：\n$$ \\epsilon_{ijk} L_k = (\\delta_{i\\ell}\\delta_{jm} - \\delta_{im}\\delta_{j\\ell}) q_\\ell p_m $$\n对哑指标 $\\ell$ 和 $m$ 求和：\n$$ \\epsilon_{ijk} L_k = (\\delta_{i\\ell}q_\\ell)(\\delta_{jm}p_m) - (\\delta_{im}q_\\ell)(\\delta_{j\\ell}p_m) = q_i p_j - q_j p_i $$\n\n通过比较，我们发现：\n$$ \\{L_i, L_j\\} = q_i p_j - q_j p_i = \\epsilon_{ijk} L_k $$\n这是角动量分量的基本泊松括号关系。这个结果在经典力学中是基础性的，它表明角动量分量在泊松括号运算下构成一个李代数，即 $\\mathfrak{so}(3)$ 的李代数。\n一般括号的最终表达式为：\n$$ \\{L_i, L_j\\} = \\epsilon_{ijk} L_k $$", "answer": "$$\n\\boxed{\\epsilon_{ijk} L_k}\n$$", "id": "3435414"}, {"introduction": "刘维尔定理是哈密顿动力学的一个基石，它指出相空间体积在时间演化中是守恒的，这意味着相空间中的“流体”是不可压缩的。然而，我们在分子动力学模拟中使用的数值积分方法并非都能完美地保持这一几何特性，那些能够保持相空间体积的辛算法（Symplectic algorithms）因此在保证长期模拟稳定性方面至关重要。通过这个动手编程练习 [@problem_id:3435418]，您将亲手验证并比较不同积分方案（如速度 Verlet、龙格-库塔和前向欧拉）在保持相空间体积方面的表现，从而深刻理解辛积分方法在实践中的优越性。", "problem": "考虑一个用于分子动力学（MD）的哈密顿系统，其中相空间状态为 $x = (q, p) \\in \\mathbb{R}^{2N}$，包含坐标 $q \\in \\mathbb{R}^{N}$ 和动量 $p \\in \\mathbb{R}^{N}$。哈密顿量为 $H(q,p) = \\sum_{i=1}^{N} \\frac{p_i^2}{2 m_i} + V(q)$，其中质量 $m_i > 0$ 且势能 $V(q)$ 是一个光滑函数。精确的哈密顿流映射 $\\Phi_t : \\mathbb{R}^{2N} \\to \\mathbb{R}^{2N}$ 根据哈密顿方程 $\\dot{q}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i$ 演化状态 $x(t) = \\Phi_t(x(0))$。Liouville 定理指出，相空间体积在精确流下是守恒的，等价地，雅可比行列式 $J(t) = \\det(D \\Phi_t(x))$ 对于所有时间 $t$ 都满足 $J(t) = 1$。在微正则 MD（恒定能量）中，通常使用数值积分器来近似小时间步长 $\\Delta t$ 下的 $\\Phi_{\\Delta t}$。在离散化设置中，单步映射 $\\Phi_{\\Delta t}$ 是否精确保持相空间体积，取决于积分器是否是辛的。\n\n您的任务是编写一个完整的程序，在每个时间步使用中心有限差分法，数值估计当前状态 $x$ 附近的离散单步流映射的雅可比行列式 $J = \\det(D \\Phi_{\\Delta t}(x))$，然后计算在固定步数内其与 1 的最大绝对偏差 $\\max_{n} |J_n - 1|$。您必须实现三种单步积分器：速度 Verlet（辛算法）、经典的四阶 Runge–Kutta 和前向 Euler（后两者通常是非辛的）。对于下面指定的每种积分器和势能，您将模拟固定步数的离散动力学，并报告每步雅可比行列式与 1 的最大绝对偏差。\n\n在整个过程中使用无量纲单位。雅可比矩阵 $D \\Phi_{\\Delta t}(x) \\in \\mathbb{R}^{2N \\times 2N}$ 必须通过中心有限差分法进行数值估计：对于一个小的扰动大小 $\\varepsilon > 0$ 和标准基向量 $e_j \\in \\mathbb{R}^{2N}$，第 $j$ 列通过以下方式估计\n$$\n[D \\Phi_{\\Delta t}(x)]_{\\cdot j} \\approx \\frac{\\Phi_{\\Delta t}(x + \\varepsilon e_j) - \\Phi_{\\Delta t}(x - \\varepsilon e_j)}{2 \\varepsilon}.\n$$\n然后使用标准的行列式例程计算 $J = \\det(D \\Phi_{\\Delta t}(x))$。在每个时间步 $n$，记录 $|J_n - 1|$，更新状态 $x \\leftarrow \\Phi_{\\Delta t}(x)$，然后继续。\n\n系统由哈密顿方程 $\\dot{q} = p / m$ 和 $\\dot{p} = -\\nabla V(q)$ 定义，其中除法 $p/m$ 对于 $p \\in \\mathbb{R}^{N}$ 和 $m \\in \\mathbb{R}^{N}$ 是逐元素的。实现以下势能 $V(q)$ 及其梯度 $\\nabla V(q)$：\n\n- 一维谐振子：$V(q) = \\tfrac{1}{2} k q^2$，梯度为 $\\nabla V(q) = k q$。\n- 二维耦合谐振子：$V(q_1,q_2) = \\tfrac{1}{2} k (q_1^2 + q_2^2) + \\alpha q_1 q_2$，梯度为 $\\nabla V(q) = (k q_1 + \\alpha q_2, k q_2 + \\alpha q_1)$。\n- 一维四次加二次势：$V(q) = \\tfrac{1}{2} k q^2 + \\tfrac{1}{4} \\lambda q^4$，梯度为 $\\nabla V(q) = k q + \\lambda q^3$。\n\n实现以下针对状态 $x = (q,p)$ 的单步积分器：\n\n- 速度 Verlet：$p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\nabla V(q_n)$，$q_{n+1} = q_n + \\Delta t \\, p_{n+\\frac{1}{2}}/m$，$p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\nabla V(q_{n+1})$。\n- 应用于一阶系统 $\\dot{q} = p/m$、$\\dot{p} = -\\nabla V(q)$ 的经典四阶 Runge–Kutta。\n- 前向 Euler：$q_{n+1} = q_n + \\Delta t \\, p_n/m$，$p_{n+1} = p_n - \\Delta t \\, \\nabla V(q_n)$。\n\n为了数值稳定性和准确性，在估计当前状态下单步映射的雅可比矩阵时，请使用带有小步长 $\\varepsilon$ 的中心有限差分法。\n\n测试套件：\n您必须实现以下四个测试用例，并为每个用例计算单个标量输出 $\\max_{0 \\le n  N_{\\text{steps}}} |J_n - 1|$，其中 $J_n$ 是在第 $n$ 步估计的雅可比行列式。\n\n- 用例 1：$N = 1$，$m = 1$，谐振子势，其中 $k = 1$，速度 Verlet 积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 1000$，初始状态 $(q_0, p_0) = (1.0, 0.0)$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 2：$N = 1$，$m = 1$，谐振子势，其中 $k = 1$，经典四阶 Runge–Kutta 积分器，$\\Delta t = 0.05$，$N_{\\text{steps}} = 200$，初始状态 $(q_0, p_0) = (1.0, 0.0)$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 3：$N = 2$，$m = (1, 1)$，耦合谐振子势，其中 $k = 1, \\alpha = 0.1$，速度 Verlet 积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 500$，初始状态 $(q_0, p_0) = ((0.5, -0.5), (0.0, 0.0))$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 4：$N = 1$，$m = 1$，四次加二次势，其中 $k = 1, \\lambda = 0.5$，前向 Euler 积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 300$，初始状态 $(q_0, p_0) = (0.2, 0.5)$，有限差分 $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序排列。每个条目必须是一个浮点数，等于在该测试用例指定步数内，每步雅可比行列式与 1 的最大绝对偏差。例如，输出格式必须为 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是您的程序计算出的浮点数。", "solution": "该问题要求对分子动力学中使用的三种不同数值积分方案的相空间体积保持特性进行数值研究。根据哈密顿系统的 Liouville 定理，精确的时间演化流 $\\Phi_t$ 是保体积的。这意味着其雅可比矩阵的行列式 $J(t) = \\det(D\\Phi_t)$ 在所有时间 $t$ 内都恒等于 1。数值积分器提供了在小时间步长 $\\Delta t$ 上对该流的近似，即 $\\Phi_{\\Delta t}$。能精确保持此性质的积分器，即其单步映射的雅可比行列式为 1 的积分器，被称为辛积分器。此性质对于分子动力学模拟的长期稳定性和准确性至关重要，尤其是在总能量应该守恒的微正则系综中。\n\n本解答将实现指定的积分器，并在模拟的每一步数值估计其单步映射的雅可比行列式。主要关注的指标是在指定步数 $N_{\\text{steps}}$ 的轨迹上，该行列式与 1 的最大绝对偏差 $\\max_{n} |J_n - 1|$。\n\n### 状态表示与雅可比估计\n具有 $N$ 个自由度的系统状态由向量 $x = (q, p) \\in \\mathbb{R}^{2N}$ 表示，其中 $q \\in \\mathbb{R}^N$ 是广义坐标，$p \\in \\mathbb{R}^N$ 是共轭动量。在实现时，此状态存储为一个长度为 $2N$ 的一维数组。\n\n单步映射的雅可比矩阵 $D\\Phi_{\\Delta t}(x)$ 是一个 $2N \\times 2N$ 的矩阵。我们使用中心有限差分法来估计该矩阵。对于每个标准基向量 $e_j \\in \\mathbb{R}^{2N}$（其中 $e_j$ 在索引 $j$ 处为 1，其余位置为 0），雅可比矩阵的第 $j$ 列近似为：\n$$\n[D \\Phi_{\\Delta t}(x)]_{\\cdot j} \\approx \\frac{\\Phi_{\\Delta t}(x + \\varepsilon e_j) - \\Phi_{\\Delta t}(x - \\varepsilon e_j)}{2 \\varepsilon}\n$$\n此处，$\\Phi_{\\Delta t}$ 表示其中一个数值积分器在一个时间步长 $\\Delta t$ 内的作用，而 $\\varepsilon$ 是一个小的扰动参数。一旦逐列构建出完整的雅可比矩阵，其行列式 $J = \\det(D \\Phi_{\\Delta t}(x))$ 便可使用标准的数值线性代数例程计算得出。\n\n### 哈密顿系统与势能\n系统动力学由形式为 $H(q,p) = K(p) + V(q)$ 的哈密顿量控制，该哈密顿量可分离为动能项 $K(p) = \\sum_{i=1}^{N} \\frac{p_i^2}{2 m_i}$ 和势能项 $V(q)$。运动方程由哈密顿方程给出：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} \\quad \\text{和} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\nabla V(q)\n$$\n测试用例所需的具体势能及其梯度如下：\n1.  **谐振子 ($N=1$)：**\n    $V(q) = \\frac{1}{2} k q^2$\n    $\\nabla V(q) = k q$\n\n2.  **耦合谐振子 ($N=2$)：**\n    $V(q_1, q_2) = \\frac{1}{2} k (q_1^2 + q_2^2) + \\alpha q_1 q_2$\n    $\\nabla V(q) = \\begin{pmatrix} k q_1 + \\alpha q_2 \\\\ k q_2 + \\alpha q_1 \\end{pmatrix}$\n\n3.  **四次加二次势 ($N=1$)：**\n    $V(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\lambda q^4$\n    $\\nabla V(q) = k q + \\lambda q^3$\n\n### 数值积分器\n实现了三种单步积分器 $\\Phi_{\\Delta t}$，用于将状态从 $x_n = (q_n, p_n)$ 推进到 $x_{n+1} = (q_{n+1}, p_{n+1})$。\n\n1.  **速度 Verlet**：这是一种用于可分离哈密顿量的二阶辛积分器。其辛性意味着其精确映射（不考虑浮点误差）的雅可比行列式为 1。更新规则为：\n    $$\n    p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\nabla V(q_n) \\\\\n    q_{n+1} = q_n + \\Delta t \\, \\frac{p_{n+\\frac{1}{2}}}{m} \\\\\n    p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\nabla V(q_{n+1})\n    $$\n\n2.  **经典四阶 Runge–Kutta (RK4)**：这是一种通用的高阶但非辛的积分器。对于一个自治系统 $\\dot{y} = f(y)$，更新规则为：\n    $$\n    k_1 = \\Delta t \\cdot f(y_n) \\\\\n    k_2 = \\Delta t \\cdot f(y_n + \\frac{1}{2} k_1) \\\\\n    k_3 = \\Delta t \\cdot f(y_n + \\frac{1}{2} k_2) \\\\\n    k_4 = \\Delta t \\cdot f(y_n + k_3) \\\\\n    y_{n+1} = y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n    在我们的情况下，状态为 $y=x=(q,p)$，导数函数为 $f(x) = (\\frac{p}{m}, -\\nabla V(q))$。尽管 RK4 在单步计算上非常精确，但其非辛性导致雅可比行列式不等于 1。\n\n3.  **前向 Euler**：这是一种一阶、显式且非辛的积分器。它很简单，但由于其较差的稳定性和能量守恒性，通常不适用于长期的哈密顿动力学模拟。其更新规则为：\n    $$\n    q_{n+1} = q_n + \\Delta t \\, \\frac{p_n}{m} \\\\\n    p_{n+1} = p_n - \\Delta t \\, \\nabla V(q_n)\n    $$\n    预计该方法将显示出对体积守恒的显著偏离。\n\n### 模拟与分析算法\n对于四个测试用例中的每一个，执行以下步骤：\n1.  初始化状态 $x_0 = (q_0, p_0)$、模拟参数（$\\Delta t, N_{\\text{steps}}, \\varepsilon$）和系统属性（$m$、势能参数）。\n2.  选择合适的积分器 $\\Phi_{\\Delta t}$ 和梯度函数 $\\nabla V(q)$。\n3.  初始化变量 `max_deviation = 0`。\n4.  从 $n=0$ 到 $N_{\\text{steps}}-1$ 进行循环：\n    a. 在当前状态 $x_n$ 下，使用中心有限差分公式构建雅可比矩阵 $D\\Phi_{\\Delta t}(x_n)$。\n    b. 计算其行列式 $J_n = \\det(D\\Phi_{\\Delta t}(x_n))$。\n    c. 用 $\\max(\\text{max\\_deviation}, |J_n - 1|)$ 更新 `max_deviation`。\n    d. 将状态推进到下一步：$x_{n+1} = \\Phi_{\\Delta t}(x_n)$。\n5.  循环终止后，`max_deviation` 的最终值即为该测试用例的结果。\n\n预期结果是，对于辛积分器速度 Verlet（用例 1 和 3），计算出的偏差将处于机器精度的量级，这源于浮点运算和有限差分近似误差。对于非辛的 RK4 和前向 Euler 积分器（用例 2 和 4），预计偏差会显著更大，反映了这些算法固有的体积扭曲性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # numpy.linalg.det is sufficient\n\n# --- Potential Gradients ---\n\ndef harmonic_gradient(q, k):\n    \"\"\"Gradient of the 1D harmonic potential.\"\"\"\n    return k * q\n\ndef coupled_harmonic_gradient(q, k, alpha):\n    \"\"\"Gradient of the 2D coupled harmonic potential.\"\"\"\n    q1, q2 = q\n    grad1 = k * q1 + alpha * q2\n    grad2 = k * q2 + alpha * q1\n    return np.array([grad1, grad2])\n\ndef quartic_gradient(q, k, lam):\n    \"\"\"Gradient of the 1D quartic-plus-quadratic potential.\"\"\"\n    return k * q + lam * q**3\n\n# --- Numerical Integrators (One-Step Maps) ---\n\ndef velocity_verlet(x, N, dt, m, grad_V_func):\n    \"\"\"Velocity Verlet integrator for one time step.\"\"\"\n    q = x[:N]\n    p = x[N:]\n    \n    p_half = p - (dt / 2.0) * grad_V_func(q)\n    q_new = q + dt * p_half / m\n    p_new = p_half - (dt / 2.0) * grad_V_func(q_new)\n    \n    return np.concatenate((q_new, p_new))\n\ndef forward_euler(x, N, dt, m, grad_V_func):\n    \"\"\"Forward Euler integrator for one time step.\"\"\"\n    q = x[:N]\n    p = x[N:]\n    \n    q_new = q + dt * p / m\n    p_new = p - dt * grad_V_func(q)\n    \n    return np.concatenate((q_new, p_new))\n\ndef rk4(x, N, dt, m, grad_V_func):\n    \"\"\"Classical fourth-order Runge-Kutta integrator for one time step.\"\"\"\n    \n    def f(state):\n        _q = state[:N]\n        _p = state[N:]\n        return np.concatenate((_p / m, -grad_V_func(_q)))\n\n    k1 = dt * f(x)\n    k2 = dt * f(x + 0.5 * k1)\n    k3 = dt * f(x + 0.5 * k2)\n    k4 = dt * f(x + k3)\n    \n    x_new = x + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n    return x_new\n\n# --- Jacobian Estimation ---\n\ndef estimate_jacobian_determinant(one_step_map, x, N, eps):\n    \"\"\"\n    Estimates the Jacobian determinant of a one-step map using central finite differences.\n    - one_step_map: A function representing the integrator, Phi_dt(x).\n    - x: The current state vector [q, p].\n    - N: The number of spatial dimensions.\n    - eps: The finite difference perturbation size.\n    \"\"\"\n    dim = 2 * N\n    jacobian_matrix = np.zeros((dim, dim))\n    \n    for j in range(dim):\n        x_plus = x.copy()\n        x_minus = x.copy()\n        \n        x_plus[j] += eps\n        x_minus[j] -= eps\n        \n        phi_plus = one_step_map(x_plus)\n        phi_minus = one_step_map(x_minus)\n        \n        # This is the j-th column of the Jacobian\n        jacobian_matrix[:, j] = (phi_plus - phi_minus) / (2.0 * eps)\n        \n    return np.linalg.det(jacobian_matrix)\n\n# --- Simulation Runner ---\n\ndef run_simulation(case):\n    \"\"\"\n    Runs a single simulation case and computes the max Jacobian determinant deviation.\n    \"\"\"\n    N = case['N']\n    m = np.array(case['m'])\n    q0 = np.array(case['q0'])\n    p0 = np.array(case['p0'])\n    dt = case['dt']\n    n_steps = case['n_steps']\n    eps = case['eps']\n    \n    # Set up integrator function\n    integrators = {\n        'verlet': velocity_verlet,\n        'rk4': rk4,\n        'euler': forward_euler\n    }\n    integrator_func = integrators[case['integrator_name']]\n    \n    # Set up potential gradient function with its parameters\n    if case['potential_name'] == 'harmonic':\n        grad_V_func = lambda q: harmonic_gradient(q, k=case['params']['k'])\n    elif case['potential_name'] == 'coupled_harmonic':\n        grad_V_func = lambda q: coupled_harmonic_gradient(q, k=case['params']['k'], alpha=case['params']['alpha'])\n    elif case['potential_name'] == 'quartic':\n        grad_V_func = lambda q: quartic_gradient(q, k=case['params']['k'], lam=case['params']['lambda'])\n\n    # Create the one-step map as a function of state only\n    one_step_map = lambda state: integrator_func(state, N, dt, m, grad_V_func)\n\n    # Main simulation loop\n    x = np.concatenate((q0, p0))\n    max_deviation = 0.0\n    \n    for _ in range(n_steps):\n        # Estimate Jacobian determinant at the current state x\n        J_n = estimate_jacobian_determinant(one_step_map, x, N, eps)\n        \n        # Update max deviation\n        deviation = abs(J_n - 1.0)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n        # Advance the state for the next step\n        x = one_step_map(x)\n        \n    return max_deviation\n\n# --- Main Solver ---\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'harmonic', 'params': {'k': 1.0},\n            'integrator_name': 'verlet', 'dt': 0.01, 'n_steps': 1000,\n            'q0': [1.0], 'p0': [0.0], 'eps': 1e-8\n        },\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'harmonic', 'params': {'k': 1.0},\n            'integrator_name': 'rk4', 'dt': 0.05, 'n_steps': 200,\n            'q0': [1.0], 'p0': [0.0], 'eps': 1e-8\n        },\n        {\n            'N': 2, 'm': [1.0, 1.0], 'potential_name': 'coupled_harmonic', 'params': {'k': 1.0, 'alpha': 0.1},\n            'integrator_name': 'verlet', 'dt': 0.01, 'n_steps': 500,\n            'q0': [0.5, -0.5], 'p0': [0.0, 0.0], 'eps': 1e-8\n        },\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'quartic', 'params': {'k': 1.0, 'lambda': 0.5},\n            'integrator_name': 'euler', 'dt': 0.01, 'n_steps': 300,\n            'q0': [0.2], 'p0': [0.5], 'eps': 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Format the output as specified\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```", "id": "3435418"}, {"introduction": "相空间并非一个均匀的画布，它常常被分割成多个区域，每个区域对应着性质截然不同的动力学行为。分隔这些区域的边界被称为分界线（separatrix），它通常源于系统中的不稳定平衡点。本练习 [@problem_id:3435429] 将在一个经典的双势阱模型中，指导您通过解析方法确定分界线的能量，并运用数值模拟来描绘初始条件在分界线附近的微小变化如何导致截然不同的长期演化结果（被束缚于单侧势阱或在两阱之间穿梭），直观地展示了非线性系统中对初始条件的敏感性。", "problem": "考虑一个单位质量的经典粒子，在一维空间中的对称双势阱中进行哈密顿动力学运动。哈密顿量为 $H(x,p) = \\dfrac{p^2}{2} + V(x)$，其中质量 $m=1$，势能为 $V(x) = \\dfrac{(x^2 - 1)^2}{4}$。所有量均为无量纲；不使用物理单位。运动方程源自牛顿第二定律和哈密顿方程，即 $\\dot{x} = \\dfrac{\\partial H}{\\partial p}$ 和 $\\dot{p} = -\\dfrac{\\partial H}{\\partial x}$。相空间分界线将始终束缚在单个势阱中的初始条件与在两个势阱之间穿越的初始条件分开。你的目标是根据基本原理确定分界线，然后数值化地描绘出跨越此边界的轨迹作为初始条件的函数的长期演化结果。\n\n任务：\n- 从定义出发，通过 $V'(x) = 0$ 确定 $V(x)$ 的驻点，通过 $V''(x)$ 对其稳定性进行分类，并利用不稳定驻点处的哈密顿量来定义分界线能量 $E_{\\mathrm{sep}}$，从而确定相空间分界线能量。不要使用任何已知的或简化的公式；直接从 $V(x)$ 确定驻点及其性质。\n- 基于第一性原理（例如，从哈密顿方程推导出的速度-Verlet格式）实现一个辛时间积分器，以从指定的初始条件 $(x_0,p_0)$ 开始，长时间演化轨迹。使用固定的时间步长 $\\Delta t = 10^{-3}$，并积分至总时间 $T = 200$。\n- 对于每条轨迹，仅根据模拟的时间序列，按如下方式对其长期演化结果进行分类。令 $f_L$ 为 $x(t)  0$ 的步数所占的比例，$f_R$ 为 $x(t) > 0$ 的步数所占的比例，忽略 $|x(t)|$ 在分界线坐标 $x=0$ 附近的一个小缓冲区域 $\\delta_x = 10^{-3}$ 内的步数。如果轨迹保持在鞍点的极小邻域内（通过 $\\max_t |x(t)|  \\delta_x$ 和 $\\max_t |p(t)|  \\delta_p$ 检测，其中 $\\delta_p = 10^{-6}$），则将其分类为“卡在分界线上”(separatrix-stuck)。否则，如果 $f_L > 0.95$ 且 $f_R  0.05$，则分类为“困于左势阱”(left-well trapped)；如果 $f_R > 0.95$ 且 $f_L  0.05$，则分类为“困于右势阱”(right-well trapped)；否则分类为“在势阱间漫游”(roaming between wells)。\n- 将每条轨迹的分类编码为一个整数代码 $c$：“困于左势阱”为 $c=-1$，“困于右势阱”为 $c=+1$，“漫游”为 $c=0$，“卡在分界线上”为 $c=2$。\n\n测试集：\n模拟以下初始条件 $(x_0,p_0)$，表示为实数的有序对： \n$(-1.2,0.0)$, $(1.2,0.0)$, $(0.0,1.0)$, $(0.0,0.0)$, $(0.01,0.0)$, $(-0.01,0.0)$, $(0.01,0.2)$。\n这些案例共同探测了每个势阱中的一个典型束缚情况、一个越过势垒的漫游情况、精确的鞍点，以及分界线两侧的近分界线敏感性。\n\n最终输出规范：\n你的程序应生成单行输出，其中包含测试集的分类结果，顺序与上面列出的一致，形式为用方括号括起来的逗号分隔的整数列表（例如，$[c_1,c_2,\\dots]$）。不应打印任何额外文本。所有计算都应按上述说明以无量纲形式进行。所需的输出是无单位的，并且只包含整数。此问题不涉及角度。唯一可接受的输出是布尔值、整数、浮点数或它们的列表；此处，所需的输出是整数列表。", "solution": "该问题要求对粒子在一维双势阱中的运动进行分析和数值模拟。解决方案分三个阶段进行：首先，对系统的关键特征（如平衡点和分界线能量）进行分析表征；其次，构建合适的数值积分方案；第三，实现一个分类算法来确定轨迹的长期演化结果。\n\n系统由哈密顿量 $H(x,p) = \\frac{p^2}{2m} + V(x)$ 描述，其中质量 $m=1$，势能为 $V(x) = \\frac{1}{4}(x^2 - 1)^2$。所有量均为无量纲。运动方程由哈密顿方程导出：\n$$ \\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} = p $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\frac{dV}{dx} $$\n\n首先，我们必须确定相空间分界线，它由不稳定平衡点（相空间中的鞍点）的能级定义。我们通过确定势能 $V(x)$ 的驻点来找到平衡位置，在这些点上力 $F(x) = -V'(x)$ 为零。\n势能为 $V(x) = \\frac{1}{4}(x^4 - 2x^2 + 1)$。\n一阶导数为：\n$$ V'(x) = \\frac{d}{dx} \\left[ \\frac{1}{4}(x^4 - 2x^2 + 1) \\right] = \\frac{1}{4}(4x^3 - 4x) = x^3 - x $$\n令 $V'(x)=0$ 以求驻点：\n$$ x^3 - x = x(x^2 - 1) = x(x-1)(x+1) = 0 $$\n驻点位于 $x = -1$，$x = 0$ 和 $x = +1$。\n\n为对这些点的稳定性进行分类，我们考察势能的二阶导数 $V''(x)$：\n$$ V''(x) = \\frac{d}{dx}(x^3 - x) = 3x^2 - 1 $$\n我们在每个驻点处计算 $V''(x)$ 的值：\n- 在 $x = -1$ 处：$V''(-1) = 3(-1)^2 - 1 = 2 > 0$。这表示一个局域势能极小值，对应于一个稳定平衡点。\n- 在 $x = +1$ 处：$V''(+1) = 3(1)^2 - 1 = 2 > 0$。这也表示一个局域势能极小值，一个稳定平衡点。\n- 在 $x = 0$ 处：$V''(0) = 3(0)^2 - 1 = -1  0$。这表示一个局域势能极大值，对应于一个不稳定平衡点。\n\n分界线是穿过不稳定平衡点的轨迹。在相空间中，这个点是 $(x,p) = (0,0)$，因为粒子在势垒的顶峰处必须是静止的。这条轨迹的能量定义了分界线能量 $E_{\\mathrm{sep}}$：\n$$ E_{\\mathrm{sep}} = H(0,0) = \\frac{0^2}{2} + V(0) = \\frac{(0^2 - 1)^2}{4} = \\frac{1}{4} = 0.25 $$\n总能量 $E  E_{\\mathrm{sep}}$ 的轨迹被限制在某个势阱内，而能量 $E > E_{\\mathrm{sep}}$ 的轨迹可以在两个势阱之间漫游。能量 $E = E_{\\mathrm{sep}}$ 的轨迹位于分界线本身。\n\n为了模拟轨迹，我们采用一个辛积分器，特别是速度-Verlet算法，由于其良好的能量守恒特性，它非常适合哈密顿系统的长期积分。对于质量为 $m=1$ 的粒子，该算法由位置的泰勒展开推导而来，对于一个时间步长 $\\Delta t$，包含以下步骤：\n1. 更新位置：$x(t + \\Delta t) = x(t) + p(t)\\Delta t + \\frac{1}{2} F(x(t)) \\Delta t^2$。\n2. 计算新位置处的力：$F(x(t + \\Delta t)) = -V'(x(t + \\Delta t))$。\n3. 更新动量：$p(t + \\Delta t) = p(t) + \\frac{1}{2} [F(x(t)) + F(x(t + \\Delta t))] \\Delta t$。\n此处，力为 $F(x) = -V'(x) = -(x^3 - x) = x - x^3$。模拟将从 $t=0$ 运行到 $T=200$，时间步长为 $\\Delta t = 10^{-3}$。\n\n最后，必须对每条由时间序列 $\\{x(t_i), p(t_i)\\}$ 表示的模拟轨迹进行分类。分类根据一组预设规则进行。\n首先，我们检查轨迹是否“卡”在鞍点 $(0,0)$。如果整个模拟过程中的最大绝对位置和动量值都低于指定的阈值：$\\max_t |x(t)|  \\delta_x$ 且 $\\max_t |p(t)|  \\delta_p$，其中 $\\delta_x = 10^{-3}$ 且 $\\delta_p = 10^{-6}$，则轨迹被赋予代码 $c=2$。\n\n如果轨迹没有卡住，我们分析它在两个势阱中的分布。我们计算粒子在左势阱（$x(t)  0$）和右势阱（$x(t) > 0$）中花费的时间步数比例，忽略粒子在原点附近的小缓冲区域内（即 $|x(t)| \\le \\delta_x$）的任何步数。设 $N_L$ 是 $x(t)  -\\delta_x$ 的步数， $N_R$ 是 $x(t) > \\delta_x$ 的步数。相关总步数为 $N_{total} = N_L + N_R$。那么比例为 $f_L = N_L / N_{total}$ 和 $f_R = N_R / N_{total}$。\n于是分类如下：\n- 困于左势阱 ($c=-1$)：如果 $f_L > 0.95$ 且 $f_R  0.05$。\n- 困于右势阱 ($c=+1$)：如果 $f_R > 0.95$ 且 $f_L  0.05$。\n- 漫游 ($c=0$)：其他情况。\n\n以下 Python 代码实现了这整个过程，将其应用于指定的初始条件集，并生成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of classifying trajectories in a double-well potential.\n    \"\"\"\n\n    def run_simulation(x0, p0, dt, T):\n        \"\"\"\n        Integrates a trajectory using the velocity-Verlet algorithm.\n        \n        Args:\n            x0 (float): Initial position.\n            p0 (float): Initial momentum.\n            dt (float): Time step.\n            T (float): Total integration time.\n\n        Returns:\n            tuple: A tuple containing arrays for the position and momentum trajectories.\n        \"\"\"\n        num_steps = int(T / dt)\n        x = float(x0)\n        p = float(p0)\n        \n        x_traj = np.zeros(num_steps + 1)\n        p_traj = np.zeros(num_steps + 1)\n        x_traj[0] = x\n        p_traj[0] = p\n        \n        def force(pos):\n            \"\"\"Calculates the force F(x) = -V'(x) = x - x^3.\"\"\"\n            return pos - pos**3\n\n        for i in range(num_steps):\n            F_current = force(x)\n            # Update position\n            x_next = x + p * dt + 0.5 * F_current * dt**2\n            # Update force\n            F_next = force(x_next)\n            # Update momentum\n            p_next = p + 0.5 * (F_current + F_next) * dt\n            \n            x = x_next\n            p = p_next\n            \n            x_traj[i+1] = x\n            p_traj[i+1] = p\n            \n        return x_traj, p_traj\n\n    def classify_trajectory(x_traj, p_traj):\n        \"\"\"\n        Classifies a trajectory based on its long-term behavior.\n\n        Args:\n            x_traj (np.array): Array of position values over time.\n            p_traj (np.array): Array of momentum values over time.\n\n        Returns:\n            int: Classification code (-1, 1, 0, or 2).\n        \"\"\"\n        delta_x = 1e-3\n        delta_p = 1e-6\n\n        # Rule 1: Check for separatrix-stuck condition\n        if np.max(np.abs(x_traj))  delta_x and np.max(np.abs(p_traj))  delta_p:\n            return 2\n\n        # Rules 2-4: Analyze well-trapping vs. roaming\n        # Ignore points within the buffer zone |x| = delta_x\n        relevant_x_points = x_traj[np.abs(x_traj) > delta_x]\n        \n        if relevant_x_points.size == 0:\n            # Trajectory stayed entirely within the x buffer but didn't meet the 'stuck'\n            # momentum requirement. This is an edge case, but most consistent to classify\n            # as roaming, as it is neither definitively left nor right trapped.\n            return 0\n            \n        count_L = np.sum(relevant_x_points  0)\n        count_R = np.sum(relevant_x_points > 0)\n        count_total = relevant_x_points.size\n\n        f_L = count_L / count_total\n        f_R = count_R / count_total\n\n        if f_L > 0.95 and f_R  0.05:\n            return -1  # Left-well trapped\n        elif f_R > 0.95 and f_L  0.05:\n            return 1   # Right-well trapped\n        else:\n            return 0   # Roaming\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-1.2, 0.0),\n        (1.2, 0.0),\n        (0.0, 1.0),\n        (0.0, 0.0),\n        (0.01, 0.0),\n        (-0.01, 0.0),\n        (0.01, 0.2),\n    ]\n\n    # Simulation parameters\n    dt = 1e-3\n    T = 200.0\n\n    results = []\n    for x0, p0 in test_cases:\n        x_trajectory, p_trajectory = run_simulation(x0, p0, dt, T)\n        classification = classify_trajectory(x_trajectory, p_trajectory)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3435429"}]}