{"hands_on_practices": [{"introduction": "在深入研究复杂系统的自由能计算之前，通过一个简单且具有解析解的模型来验证我们的方法是至关重要的。单维谐振子系统为此提供了一个理想的“试验台”，因为它足够简单，可以直接积分得到自由能，从而为热力学积分（TI）和自由能微扰（FEP）方法提供一个精确的基准。通过这项练习[@problem_id:2642319]，您将亲手推导并验证这些基本方法，从而深刻理解它们背后的数学原理和内在联系。", "problem": "考虑一个经典一维谐振子，其势能为 $U(x;k)=\\tfrac{1}{2}k x^{2}$，其中 $k>0$ 是力常数，$x$ 是笛卡尔坐标。在正则系综中，于恒定温度 $T$ 下进行计算。假设只考虑组态贡献（动能项与 $k$ 无关，在不同 $k$ 的状态之间的自由能差中会相互抵消）。令 $k_{B}$ 表示玻尔兹曼常数，且 $\\beta \\equiv 1/(k_{B}T)$。\n\na) 从正则组态配分函数的定义 $Z_{\\mathrm{conf}}(k,T)=\\int_{-\\infty}^{\\infty}\\exp\\!\\left(-\\beta U(x;k)\\right)\\,\\mathrm{d}x$ 出发，推导精确的组态亥姆霍兹自由能 $A_{\\mathrm{conf}}(k,T)$。\n\nb) 考虑在恒定温度 $T$ 下，将力常数从 $k_{0}>0$ 变为 $k_{1}>0$。引入一个耦合参数 $\\lambda\\in[0,1]$，该参数定义了一个插值哈密顿量 $U_{\\lambda}(x)=\\tfrac{1}{2}k(\\lambda)x^{2}$，其中 $k(\\lambda)=(1-\\lambda)k_{0}+\\lambda k_{1}$。从基本系综定义出发，使用热力学积分 (TI) 推导自由能差 $\\Delta A \\equiv A_{\\mathrm{conf}}(k_{1},T)-A_{\\mathrm{conf}}(k_{0},T)$ 的表达式，其中 TI 表示热力学积分。\n\nc) 从正则配分函数之比出发，针对同一变换，推导并精确计算自由能微扰 (FEP) 估计量，其中 FEP 表示自由能微扰。也就是说，用在 $k_0$ 处的参考系综上的平均值来表示 $\\Delta A$，并解析地计算该平均值。\n\n你的最终答案应为 $\\Delta A$ 关于 $k_{0}$、$k_{1}$、$k_{B}$ 和 $T$ 的单个闭式解析表达式。无需进行数值计算。将最终结果表示为单个解析表达式。最终方框内的答案不应包含单位。", "solution": "该问题陈述经核实具有科学依据、提法恰当且客观。它基于经典统计力学的标准原理，提出了一个可通过已有方法轻松解决的典范问题。不存在逻辑矛盾、信息缺失或事实错误。该问题有效。我们开始求解。\n\n该问题要求计算当一维经典谐振子的力常数在恒定温度 $T$ 下从 $k_{0}$ 变为 $k_{1}$ 时，亥姆霍兹自由能差 $\\Delta A$ 的值。我们将按要求通过三种不同的方法推导该量。\n\n(a) 精确的组态亥姆霍兹自由能 $A_{\\mathrm{conf}}(k,T)$\n\n对于一个在温度 $T$ 下势能为 $U(x;k)$ 的系统，其组态配分函数 $Z_{\\mathrm{conf}}$ 由下式给出\n$$\nZ_{\\mathrm{conf}}(k,T) = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(x;k)) \\, \\mathrm{d}x\n$$\n其中 $\\beta = 1/(k_{B}T)$。对于谐振子，势能为 $U(x;k) = \\frac{1}{2}kx^{2}$。将此代入配分函数的定义中，得到\n$$\nZ_{\\mathrm{conf}}(k,T) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{1}{2}\\beta k x^{2}\\right) \\, \\mathrm{d}x\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2}) \\, \\mathrm{d}x = \\sqrt{\\frac{\\pi}{a}}$。在本例中，常数 $a$ 是 $\\frac{\\beta k}{2}$。因此，该积分的计算结果为\n$$\nZ_{\\mathrm{conf}}(k,T) = \\sqrt{\\frac{\\pi}{\\frac{\\beta k}{2}}} = \\sqrt{\\frac{2\\pi}{\\beta k}}\n$$\n亥姆霍兹自由能 $A$ 通过基本方程 $A = -k_{B}T \\ln Z = -\\frac{1}{\\beta} \\ln Z$ 与配分函数 $Z$ 相关联。因此，对亥姆霍兹自由能的组态贡献为\n$$\nA_{\\mathrm{conf}}(k,T) = -\\frac{1}{\\beta} \\ln Z_{\\mathrm{conf}}(k,T) = -\\frac{1}{\\beta} \\ln\\left(\\sqrt{\\frac{2\\pi}{\\beta k}}\\right)\n$$\n利用对数的性质 $\\ln(\\sqrt{y}) = \\frac{1}{2}\\ln(y)$，我们得到\n$$\nA_{\\mathrm{conf}}(k,T) = -\\frac{1}{2\\beta} \\ln\\left(\\frac{2\\pi}{\\beta k}\\right) = \\frac{1}{2\\beta} \\ln\\left(\\frac{\\beta k}{2\\pi}\\right)\n$$\n这就是一维谐振子组态亥姆霍兹自由能的精确表达式。\n\n(b) 通过热力学积分 (TI) 计算自由能差\n\n热力学积分 (TI) 提供了一种计算两个状态之间自由能差的方法，即对哈密顿量关于耦合参数 $\\lambda$ 的导数的系综平均值进行积分。自由能差由下式给出\n$$\n\\Delta A = \\int_{0}^{1} \\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, \\mathrm{d}\\lambda\n$$\n其中 $U_{\\lambda}(x)$ 是在状态 0 ($\\lambda=0$) 和状态 1 ($\\lambda=1$) 之间插值的系统势能，$\\langle \\dots \\rangle_{\\lambda}$ 表示对势能为 $U_{\\lambda}(x)$ 的系统进行的系综平均。\n\n插值势能由 $U_{\\lambda}(x) = \\frac{1}{2}k(\\lambda)x^{2}$ 给出，其中 $k(\\lambda) = (1-\\lambda)k_{0} + \\lambda k_{1}$。首先，我们计算 $U_{\\lambda}(x)$ 关于 $\\lambda$ 的偏导数：\n$$\n\\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} = \\frac{1}{2} \\frac{\\mathrm{d}k(\\lambda)}{\\mathrm{d}\\lambda} x^{2} = \\frac{1}{2} (k_{1} - k_{0}) x^{2}\n$$\n接下来，我们必须在由势能 $U_{\\lambda}(x)$ 定义的正则系综中计算这个量的系综平均值 $\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\rangle_{\\lambda}$：\n$$\n\\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\left\\langle \\frac{1}{2} (k_{1} - k_{0}) x^{2} \\right\\rangle_{\\lambda} = \\frac{1}{2} (k_{1} - k_{0}) \\langle x^{2} \\rangle_{\\lambda}\n$$\n量 $\\langle x^{2} \\rangle_{\\lambda}$ 是力常数为 $k(\\lambda)$ 的谐振子的均方位移。对于经典一维谐振子，能量均分定理指出平均势能为 $\\langle \\frac{1}{2}k(\\lambda)x^{2} \\rangle_{\\lambda} = \\frac{1}{2}k_{B}T$。由此，我们直接求得均方位移：\n$$\n\\langle x^{2} \\rangle_{\\lambda} = \\frac{k_{B}T}{k(\\lambda)} = \\frac{1}{\\beta k(\\lambda)}\n$$\n将此结果代入系综平均导数的表达式中，得到\n$$\n\\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{1}{2} (k_{1} - k_{0}) \\frac{1}{\\beta k(\\lambda)} = \\frac{k_{1} - k_{0}}{2\\beta((1-\\lambda)k_{0} + \\lambda k_{1})}\n$$\n现在我们可以对 $\\lambda$ 从 0 到 1 进行积分：\n$$\n\\Delta A = \\int_{0}^{1} \\frac{k_{1} - k_{0}}{2\\beta((1-\\lambda)k_{0} + \\lambda k_{1})} \\, \\mathrm{d}\\lambda\n$$\n令分母为 $f(\\lambda) = (1-\\lambda)k_{0} + \\lambda k_{1} = k_{0} + \\lambda(k_{1}-k_{0})$。导数为 $f'(\\lambda) = k_{1} - k_{0}$。积分为 $\\int \\frac{f'(\\lambda)}{f(\\lambda)}\\mathrm{d}\\lambda = \\ln(f(\\lambda))$ 形式。\n$$\n\\Delta A = \\frac{1}{2\\beta} \\left[ \\ln\\left((1-\\lambda)k_{0} + \\lambda k_{1}\\right) \\right]_{0}^{1} = \\frac{1}{2\\beta} (\\ln(k_{1}) - \\ln(k_{0})) = \\frac{1}{2\\beta} \\ln\\left(\\frac{k_{1}}{k_{0}}\\right)\n$$\n\n(c) 通过自由能微扰 (FEP) 计算自由能差\n\n自由能微扰 (FEP) 公式，也称为 Zwanzig 方程，用在参考态上进行的势能差的系综平均来表示自由能差。选择力常数为 $k_{0}$ 的初始态作为参考态，公式为\n$$\n\\Delta A = A_{1} - A_{0} = -\\frac{1}{\\beta} \\ln \\left\\langle \\exp\\left(-\\beta (U_{1}(x) - U_{0}(x))\\right) \\right\\rangle_{0}\n$$\n此处，$U_{0}(x) = \\frac{1}{2}k_{0}x^{2}$，$U_{1}(x) = \\frac{1}{2}k_{1}x^{2}$，且 $\\langle \\dots \\rangle_{0}$ 表示对参考态 0 的系综平均。势能差为 $\\Delta U(x) = U_{1}(x) - U_{0}(x) = \\frac{1}{2}(k_{1}-k_{0})x^{2}$。\n\n系综平均计算如下\n$$\n\\left\\langle \\exp(-\\beta \\Delta U(x)) \\right\\rangle_{0} = \\frac{\\int_{-\\infty}^{\\infty} \\exp(-\\beta \\Delta U(x)) \\exp(-\\beta U_{0}(x)) \\, \\mathrm{d}x}{\\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{0}(x)) \\, \\mathrm{d}x}\n$$\n分子中被积函数的指数部分为\n$$\n-\\beta \\Delta U(x) - \\beta U_{0}(x) = -\\beta \\left(\\frac{1}{2}(k_{1}-k_{0})x^{2} + \\frac{1}{2}k_{0}x^{2}\\right) = -\\frac{1}{2}\\beta k_{1}x^{2} = -\\beta U_1(x)\n$$\n因此，系综平均是两个配分函数之比：\n$$\n\\left\\langle \\exp(-\\beta \\Delta U(x)) \\right\\rangle_{0} = \\frac{\\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{1}(x)) \\, \\mathrm{d}x}{\\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{0}(x)) \\, \\mathrm{d}x} = \\frac{Z_{\\mathrm{conf}}(k_1, T)}{Z_{\\mathrm{conf}}(k_0, T)}\n$$\n使用 (a) 部分中 $Z_{\\mathrm{conf}}$ 的结果 $Z_{\\mathrm{conf}}(k,T) = \\sqrt{\\frac{2\\pi}{\\beta k}}$，我们有\n$$\n\\frac{Z_{\\mathrm{conf}}(k_1, T)}{Z_{\\mathrm{conf}}(k_0, T)} = \\frac{\\sqrt{\\frac{2\\pi}{\\beta k_{1}}}}{\\sqrt{\\frac{2\\pi}{\\beta k_{0}}}} = \\sqrt{\\frac{k_{0}}{k_{1}}}\n$$\n将此结果代回 $\\Delta A$ 的 FEP 公式中：\n$$\n\\Delta A = -\\frac{1}{\\beta} \\ln\\left(\\sqrt{\\frac{k_{0}}{k_{1}}}\\right) = -\\frac{1}{2\\beta} \\ln\\left(\\frac{k_{0}}{k_{1}}}\\right) = \\frac{1}{2\\beta} \\ln\\left(\\frac{k_{1}}{k_{0}}}\\right)\n$$\n所有三种方法——从 $A$ 的定义直接计算、热力学积分和自由能微扰——都得到相同的结果，这符合一致性的要求。将 $\\beta = 1/(k_{B}T)$ 代入，即可导出亥姆霍兹自由能变化的最终表达式：\n$$\n\\Delta A = \\frac{1}{2}k_{B}T \\ln\\left(\\frac{k_{1}}{k_{0}}\\right)\n$$\n这就是所要求的 $\\Delta A$ 的单个闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{1}{2} k_{B} T \\ln\\left(\\frac{k_{1}}{k_{0}}\\right)}\n$$", "id": "2642319"}, {"introduction": "从理想模型转向实际应用时，我们必须处理由粒子间相互作用（如Lennard-Jones势）在解偶联过程中引起的奇异性，即所谓的“端点问题”。这个问题会导致热力学积分的被积函数在 $\\lambda \\to 1$ 时急剧变化，使得数值积分变得困难且不可靠。本练习[@problem_id:3454192]将指导您设计和分析一个软核势方案，通过调节势函数形式来平滑被积函数的行为，这是在自由能计算中确保数值稳定性和准确性的关键一步。", "problem": "考虑一个浸入在连续介质溶剂中的单中心Lennard-Jones溶质，在约化Lennard-Jones单位下进行研究，其中$\\sigma = 1$且$\\epsilon = 1$。温度固定，使得逆热能$\\beta = 1$，距离和能量分别以$\\sigma$和$\\epsilon$为单位表示。在此设定下，我们希望分析在软核方案下将溶质与溶剂解耦的热力学积分 (TI)。TI被积函数的正则系综平均是在固定$\\lambda$下计算的哈密顿量对耦合参数导数的期望值。完全耦合态和解耦态之间的自由能差是该正则系综平均对$\\lambda$的积分。\n\n从以下基本基础出发：\n- 在逆热能为$\\beta$时，能量为$U$的构型的正则系综概率密度正比于$\\exp(-\\beta U)$。\n- 由$\\lambda$参数化的两个状态之间的自由能差，可通过对参数导数的正则期望进行积分得到：$\\Delta G = \\int_{0}^{1} \\langle \\partial U / \\partial \\lambda \\rangle_{\\lambda} \\, d\\lambda$，其中$\\langle \\cdot \\rangle_{\\lambda}$表示在固定$\\lambda$下的系综平均。\n- 在约化单位下，Lennard-Jones对相互作用由$u_{\\mathrm{LJ}}(r) = 4 \\left( r^{-12} - r^{-6} \\right)$给出，其中$r$是间距。\n\n我们采用一种软核映射，该映射在解耦过程中对排斥奇异性进行正则化。径向软核函数由一个指数$p \\geq 1$和一个软核参数$\\alpha \\geq 0$通过修正的六次方距离指定，\n$$\nr_{\\mathrm{sc}}^{6}(\\lambda) = r^{6} + \\alpha \\left(1 - \\lambda\\right)^{p} ,\n$$\n并且依赖于$\\lambda$的势能通过在$r_{\\mathrm{sc}}(\\lambda)$处评估Lennard-Jones形式，随$\\lambda$线性缩放，\n$$\nU(r;\\lambda) = 4 \\lambda \\left[ \\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-2} - \\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-1} \\right] .\n$$\n该模型在$\\lambda = 1$时再现了标准的Lennard-Jones势，并在$\\lambda = 0$时实现零相互作用。\n\n假设溶质-溶剂相互作用采用球对称的单对有效描述。在此描述中，固定$\\lambda$下间距$r$的有效径向概率密度正比于三维测度和玻尔兹曼因子，\n$$\nP(r \\mid \\lambda) \\propto r^{2} \\exp\\left( -\\beta U(r;\\lambda) \\right) ,\n$$\n作用域为$r \\in [0, r_{\\max}]$，其中$r_{\\max} = 5$。在此近似下，固定$\\lambda$的TI被积函数的正则系综平均通过使用该权重进行径向平均来计算，\n$$\n\\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{ \\int_{0}^{r_{\\max}} r^{2} \\exp\\left( -\\beta U(r;\\lambda) \\right) \\left( \\frac{\\partial U}{\\partial \\lambda}(r;\\lambda) \\right) \\, dr }{ \\int_{0}^{r_{\\max}} r^{2} \\exp\\left( -\\beta U(r;\\lambda) \\right) \\, dr } .\n$$\n\n您的任务是：\n1. 从第一性原理出发，为上述给定的软核映射推导$\\partial U / \\partial \\lambda$的显式表达式，并解释对于不同的$p$和$\\alpha$选择，当$\\lambda \\to 1$时的端点行为。\n2. 实现一个独立的、数值稳定的程序，使用上述指定的径向平均，计算在$\\lambda$的四个近端点值（$0.90$、$0.99$、$0.999$和$0.9999$）下的正则系综平均$\\left\\langle \\partial U/\\partial\\lambda \\right\\rangle_{\\lambda}$。\n3. 定义一个平滑度指数，用于量化被积函数在近端点的振荡，如下所示\n$$\nS = \\max_{j \\in \\{1,2,3\\}} \\left| I(\\lambda_{j+1}) - I(\\lambda_{j}) \\right| ,\n$$\n其中$I(\\lambda)$表示计算出的正则系综平均值，且$\\lambda_{1} = 0.90$，$\\lambda_{2} = 0.99$，$\\lambda_{3} = 0.999$，$\\lambda_{4} = 0.9999$。以能量单位$\\epsilon$报告$S$。\n\n全过程使用约化Lennard-Jones单位。能量必须以$\\epsilon$为单位，距离以$\\sigma$为单位。不涉及角度。逆热能固定为$\\beta = 1$。\n\n测试套件：\n- 案例A（正常路径）：$(\\alpha, p) = (1.0, 1)$。\n- 案例B（边界，无软核）：$(\\alpha, p) = (0.0, 1)$。\n- 案例C（更多平滑）：$(\\alpha, p) = (2.0, 1)$。\n- 案例D（端点正则化指数）：$(\\alpha, p) = (1.0, 2)$。\n\n对于每种情况，计算并返回一个包含三个浮点数的列表：$[I(0.99), I(0.999), S]$，其中$I(\\lambda)$是在指定$\\lambda$下被积函数的正则系综平均值。您的程序应生成单行输出，其中包含按A、B、C、D顺序汇总的所有测试用例的结果，结果为逗号分隔的列表并用方括号括起来。例如，输出格式必须类似于：\n\"[[I_A(0.99),I_A(0.999),S_A],[I_B(0.99),I_B(0.999),S_B],[I_C(0.99),I_C(0.999),S_C],[I_D(0.99),I_D(0.999),S_D]]\"。", "solution": "该问题是有效的，因为它在统计力学和计算化学方面有科学依据，定义了所有必要的参数和函数，问题明确且客观。我们可以着手解决。解决方案包括两个主要部分：首先，对热力学积分（TI）被积函数进行解析推导并分析其行为；其次，通过数值实现来计算所需的量。\n\n### 第1部分：解析推导与端点分析\n\n势能$U(r;\\lambda)$由下式给出\n$$\nU(r;\\lambda) = 4 \\lambda \\left[ \\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-2} - \\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-1} \\right]\n$$\n其中软核修正的六次方距离为\n$$\nr_{\\mathrm{sc}}^{6}(\\lambda) = r^{6} + \\alpha \\left(1 - \\lambda\\right)^{p}.\n$$\n为简化符号，令$g(\\lambda) \\equiv r_{\\mathrm{sc}}^{6}(\\lambda)$。TI被积函数是势能$U$关于耦合参数$\\lambda$的偏导数。我们使用乘法法则和链式法则来计算它：\n$$\n\\frac{\\partial U}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} \\left( 4 \\lambda \\left[ g(\\lambda)^{-2} - g(\\lambda)^{-1} \\right] \\right)\n$$\n$$\n\\frac{\\partial U}{\\partial \\lambda} = 4 \\left[ g(\\lambda)^{-2} - g(\\lambda)^{-1} \\right] + 4 \\lambda \\frac{d}{d g} \\left[ g^{-2} - g^{-1} \\right] \\frac{\\partial g}{\\partial \\lambda}.\n$$\n第一项就是$U(r;\\lambda)/\\lambda$。各部分的导数是：\n$$\n\\frac{d}{d g} \\left[ g^{-2} - g^{-1} \\right] = -2 g^{-3} + g^{-2}\n$$\n和\n$$\n\\frac{\\partial g}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} \\left[ r^{6} + \\alpha (1 - \\lambda)^{p} \\right] = \\alpha \\cdot p (1 - \\lambda)^{p-1} \\cdot (-1) = -\\alpha p (1 - \\lambda)^{p-1}.\n$$\n将这些代回到$\\partial U / \\partial \\lambda$的表达式中：\n$$\n\\frac{\\partial U}{\\partial \\lambda} = \\frac{U(r;\\lambda)}{\\lambda} + 4 \\lambda \\left[ g(\\lambda)^{-2} - 2g(\\lambda)^{-3} \\right] \\left[ -\\alpha p (1 - \\lambda)^{p-1} \\right]\n$$\n$$\n\\frac{\\partial U}{\\partial \\lambda} = \\frac{U(r;\\lambda)}{\\lambda} - 4 \\lambda \\alpha p (1 - \\lambda)^{p-1} \\left[ \\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-2} - 2\\left(r_{\\mathrm{sc}}^{6}(\\lambda)\\right)^{-3} \\right].\n$$\n这就是TI被积函数的显式表达式。\n\n接下来，我们分析当$\\lambda \\to 1$时的端点行为。在此极限下，软核项$\\alpha(1-\\lambda)^p \\to 0$（对于$p \\ge 1$），因此$g(\\lambda) \\to r^6$。第一项$U(r;\\lambda)/\\lambda$趋近于标准的Lennard-Jones势$u_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$。第二项的行为关键取决于通过因子$(1-\\lambda)^{p-1}$体现的指数$p$：\n\n1.  **案例B（无软核，$\\alpha=0$）：** 在这种情况下，$\\partial U / \\partial \\lambda$表达式中的第二项始终为零。势能为$U(r;\\lambda) = \\lambda u_{\\mathrm{LJ}}(r)$，其导数就是$\\partial U / \\partial \\lambda = u_{\\mathrm{LJ}}(r)$。尽管导数函数本身不依赖于$\\lambda$，但正则系综平均$\\langle u_{\\mathrm{LJ}}(r) \\rangle_{\\lambda}$通过玻尔兹曼权重$\\exp(-\\beta \\lambda u_{\\mathrm{LJ}}(r))$强烈地依赖于$\\lambda$。当$\\lambda \\to 1$时，小$r$处的排斥壁增高，急剧改变概率分布$P(r|\\lambda)$，并导致平均值的剧烈变化，这就是众所周知的TI“端点问题”。\n\n2.  **案例A和C（$p=1$）：** 对于$p=1$，第二项中的指数变为$p-1=0$。因此，当$\\lambda \\to 1$时，$(1-\\lambda)^{p-1} \\to 1$。导数$\\partial U / \\partial \\lambda$收敛到一个不同于$u_{\\mathrm{LJ}}(r)$的极限：\n    $$\n    \\lim_{\\lambda \\to 1} \\frac{\\partial U}{\\partial \\lambda} = u_{\\mathrm{LJ}}(r) - 4 \\alpha (r^{-12} - 2r^{-18}).\n    $$\n    这意味着在$\\lambda=1$处，被积函数的函数形式定义存在不连续性。因此，预期正则系综平均$\\langle \\partial U / \\partial \\lambda \\rangle_{\\lambda}$在$\\lambda$接近1时会表现出显著变化，导致一个相对较大的平滑度指数$S$。\n\n3.  **案例D（$p=2$）：** 对于$p=2$，指数变为$p-1=1 > 0$。因此，当$\\lambda \\to 1$时，因子$(1-\\lambda)^{p-1} \\to 0$。这导致$\\partial U / \\partial \\lambda$的整个第二项在端点处消失。\n    $$\n    \\lim_{\\lambda \\to 1} \\frac{\\partial U}{\\partial \\lambda} = u_{\\mathrm{LJ}}(r).\n    $$\n    在这种情况下，导数本身平滑地趋近于标准的Lennard-Jones势。可以证明，关于$\\lambda$的更高阶导数也会消失，导致正则系综平均$\\langle \\partial U / \\partial \\lambda \\rangle_{\\lambda}$在$\\lambda=1$附近具有更平坦的曲线。这种指数的选择旨在正则化端点，并显著提高整个自由能计算的数值稳定性和准确性。因此，我们预计在这种情况下，平滑度指数$S$会非常小。\n\n### 第2部分：数值计算\n\n正则系综平均$\\langle \\partial U / \\partial \\lambda \\rangle_{\\lambda}$（我们记作$I(\\lambda)$）通过数值计算两个积分的比值来得到：\n$$\nI(\\lambda) = \\frac{N(\\lambda)}{D(\\lambda)} = \\frac{ \\int_{0}^{r_{\\max}} r^{2} \\exp\\left( -\\beta U(r;\\lambda) \\right) \\left( \\frac{\\partial U}{\\partial \\lambda}(r;\\lambda) \\right) \\, dr }{ \\int_{0}^{r_{\\max}} r^{2} \\exp\\left( -\\beta U(r;\\lambda) \\right) \\, dr }.\n$$\n我们基于上面推导的表达式，实现$U(r;\\lambda)$和$\\partial U / \\partial \\lambda(r;\\lambda)$的函数。给定的问题参数是$\\beta=1$和$r_{\\max}=5$。分子$N(\\lambda)$和分母$D(\\lambda)$的积分使用数值积分计算，特别是使用Python的SciPy库中的`quad`函数。为保证稳健性，我们必须处理潜在的数值问题，例如$r=0$时的除零问题，尽管分析表明，由于$r^2$体积元和玻尔兹曼因子的快速衰减，被积函数在这一点上是良态的。\n\n计算过程如下：\n1.  对于每个测试案例$(\\alpha, p)$，我们遍历指定的lambda值：$\\lambda_1=0.90$, $\\lambda_2=0.99$, $\\lambda_3=0.999$ 和 $\\lambda_4=0.9999$。\n2.  对于每个$\\lambda$，我们通过对分子和分母从$r=0$到$r=5$进行数值积分来计算$I(\\lambda)$。\n3.  计算出$I(\\lambda_j)$的四个值后，我们计算平滑度指数$S$，即连续值之间绝对差的最大值：\n    $$\n    S = \\max \\left( |I(\\lambda_2) - I(\\lambda_1)|, |I(\\lambda_3) - I(\\lambda_2)|, |I(\\lambda_4) - I(\\lambda_3)| \\right).\n    $$\n4.  每种情况的结果被编译成一个包含三个数字的列表：$[I(0.99), I(0.999), S]$。最终输出汇总了所有测试用例的这些列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    BETA = 1.0\n    R_MAX = 5.0\n\n    test_cases = [\n        (1.0, 1),  # Case A\n        (0.0, 1),  # Case B\n        (2.0, 1),  # Case C\n        (1.0, 2),  # Case D\n    ]\n\n    def U_func(r, lam, alpha, p):\n        \"\"\"Calculates the soft-core potential U(r; lambda).\"\"\"\n        if r  1e-12:  # Avoid r=0 issues\n            if alpha > 0 and lam  1.0:\n                g = alpha * np.power(1.0 - lam, p)\n                if g == 0: return np.inf\n                return 4.0 * lam * (np.power(g, -2) - np.power(g, -1))\n            return np.inf\n\n        r6 = np.power(r, 6)\n        one_minus_lam = 1.0 - lam\n        # Handle lam very close to 1\n        if abs(one_minus_lam)  1e-15:\n            one_minus_lam = 0.0\n\n        g = r6 + alpha * np.power(one_minus_lam, p)\n        if g == 0: return np.inf\n        \n        g_inv = 1.0 / g\n        g_inv2 = g_inv * g_inv\n\n        return 4.0 * lam * (g_inv2 - g_inv)\n\n    def dU_dlam_func(r, lam, alpha, p):\n        \"\"\"Calculates the derivative dU/dlambda.\"\"\"\n        if r  1e-12: # Integrand will be zero due to r^2 term\n            return 0.0\n\n        r6 = np.power(r, 6)\n        one_minus_lam = 1.0 - lam\n        # Handle lam very close to 1\n        if abs(one_minus_lam)  1e-15:\n            one_minus_lam = 0.0\n\n        g = r6 + alpha * np.power(one_minus_lam, p)\n        if g == 0: return np.inf\n\n        g_inv = 1.0 / g\n        g_inv2 = g_inv * g_inv\n        \n        # First term: U/lambda\n        u_over_lam = 4.0 * (g_inv2 - g_inv)\n\n        if alpha == 0 or lam == 0:\n            return u_over_lam\n\n        # Second term\n        # np.power(0.0, 0.0) correctly evaluates to 1.0 for p=1, lam=1\n        one_minus_lam_pow = np.power(one_minus_lam, p - 1)\n        \n        g_inv3 = g_inv2 * g_inv\n        \n        second_term_factor = -4.0 * lam * alpha * p * one_minus_lam_pow\n        g_related_term = g_inv2 - 2.0 * g_inv3\n        \n        return u_over_lam + second_term_factor * g_related_term\n\n    def calculate_average(lam, alpha, p):\n        \"\"\"Computes the canonical average\n# NOTE FROM EDITOR: The code was truncated here in the source. \n# A complete implementation would calculate the required integrals to return the average.\n# The final numerical answer cannot be generated.\n```", "id": "3454192"}, {"introduction": "在自由能计算中，获得一个准确的结果不仅取决于势函数的设计，还取决于如何高效地分配有限的计算资源。由于在不同 $\\lambda$ 窗口处广义力的涨落（方差）不同，均匀分配计算时间通常不是最优策略。本练习[@problem_id:3454240]将引导您解决一个核心的实验设计问题：如何在固定的总计算成本下，通过优化每个窗口的采样数量来最小化最终自由能估计的统计方差，从而实现最高的计算效率。", "problem": "考虑分子动力学中的炼金术转换，其耦合参数为 $\\lambda \\in [0,1]$。两个末态之间的亥姆霍兹自由能差 $\\Delta F$ 通过热力学积分表示为系综平均值沿 $\\lambda$ 的积分。使用在 $\\{\\lambda_i\\}_{i=1}^M$ 处的固定窗口网格和确定性求积权重 $\\{w_i\\}_{i=1}^M$（例如，在等间距网格上的梯形法则），通过在每个窗口进行独立模拟来构建 $\\Delta F$ 的蒙特卡洛估计量。这些模拟在 $\\lambda_i$ 处产生广义力 $X_i=\\partial U/\\partial \\lambda$ 的样本均值。假设以下基本前提：\n- 自由能差的估计量为 $\\widehat{\\Delta F}=\\sum_{i=1}^M w_i \\overline{X}_i$，其中 $\\overline{X}_i$ 是在窗口 $i$ 处从 $n_i$ 次独立抽样中得到的 $X_i$ 的样本均值。\n- 根据中心极限定理和窗口间的独立性，该估计量的方差遵循 $\\mathrm{Var}[\\widehat{\\Delta F}]=\\sum_{i=1}^M w_i^2\\,\\mathrm{Var}[\\overline{X}_i]$，且 $\\mathrm{Var}[\\overline{X}_i] \\approx \\sigma_i^2/n_i$，其中 $\\sigma_i^2$ 表示在 $\\lambda_i$ 处 $X_i$ 的单样本方差。\n- 在窗口 $i$ 处的每次独立抽样都会产生一个正的计算成本 $c_i$（以任意但固定的成本单位计），因此消耗的总计算预算为 $\\sum_{i=1}^M c_i n_i$。\n\n您必须：\n1. 从这些基本前提出发，不使用任何其他捷径，提出并解决在固定总成本约束下最小化估计量方差的约束连续优化问题。明确推导出平稳性条件以及最优采样工作量在各窗口间的比例关系，用 $\\{w_i\\}$, $\\{\\sigma_i^2\\}$, 和 $\\{c_i\\}$ 表示。\n2. 将连续解转换为一个可实现的整数分配方案，该方案精确满足成本约束 $\\sum_{i=1}^M c_i n_i=C_{\\mathrm{tot}}$，同时对所有 $i$ 遵守 $n_i \\ge 1$。您的算法必须：\n   - 识别任何 $\\sigma_i^2=0$ 的窗口，并仅为其分配最小的 $n_i=1$，除非为满足精确的成本约束需要更多分配。\n   - 通过迭代地强制执行成本约束和最小样本约束，确定剩余活动窗口的连续解。\n   - 通过将连续分配向下取整，然后将剩余预算贪婪地分配给每单位成本能产生最大目标函数边际减少量的窗口，直到预算被完全用尽，从而生成一个整数分配方案。\n3. 使用您的整数分配方案，计算并报告预测的最小化方差 $\\sum_{i=1}^M w_i^2 \\sigma_i^2 / n_i$。\n\n测试套件。实现一个程序，解决上述问题针对以下四种情况。所有量都是无量纲的，所有成本都是抽象单位。对所有窗口使用 $n_i \\ge 1$。最终输出必须将所有测试用例的结果聚合到单行中，以列表的列表形式打印，其中每个内部列表按 $[n_1,n_2,\\dots,n_M,V_{\\min}]$ 的顺序包含整数分配，后跟最小化的预测方差（浮点数）。\n\n- 情况 A (理想路径)：\n  - $M=4$，$\\sigma_i^2 = [4,1,9,16]$，$c_i=[1,1,2,3]$，$C_{\\mathrm{tot}}=50$，均匀求积权重 $w_i=[1,1,1,1]$。\n\n- 情况 B (边界，含零方差窗口)：\n  - $M=3$，$\\sigma_i^2 = [1,0,4]$，$c_i=[2,3,1]$，$C_{\\mathrm{tot}}=20$，均匀求积权重 $w_i=[1,1,1]$。\n\n- 情况 C (非均匀求积权重，异构成本)：\n  - $M=5$，$\\sigma_i^2 = [1,9,4,16,25]$，$c_i=[1,10,1,10,1]$，$C_{\\mathrm{tot}}=100$，在 $[0,1]$ 上的等间距梯形权重：其中 $\\Delta \\lambda = 1/(M-1)$，权重为 $w_i = \\Delta \\lambda \\cdot [0.5,1,1,1,0.5]=[0.125,0.25,0.25,0.25,0.125]$。\n\n- 情况 D (最小预算等于最小可行成本)：\n  - $M=2$，$\\sigma_i^2 = [1,1]$，$c_i=[4,6]$，$C_{\\mathrm{tot}}=10$，均匀权重 $w_i=[1,1]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个以方括号括起来的、由逗号分隔的列表的列表形式的结果，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。每个内部列表必须包含该情况的整数分配，后跟根据该分配计算出的最小化预测方差，并严格按照上述测试套件的顺序排列。不读取任何输入，也不应打印任何其他文本。角度单位不适用，也不涉及任何物理单位。任何地方都不使用百分比；任何比率如果需要，必须表示为小数。", "solution": "该问题要求推导并实现一种用于热力学积分的最优采样策略，旨在最小化估计的自由能差 $\\widehat{\\Delta F}$ 的方差，同时受限于固定的总计算成本。解决方案按要求分为三部分呈现：解析推导、整数分配算法描述以及最小化方差的最终计算。\n\n### **问题验证**\n\n**步骤1：提取已知条件**\n- **目标函数（待最小化的方差）：** $V \\equiv \\mathrm{Var}[\\widehat{\\Delta F}] = \\sum_{i=1}^M \\frac{w_i^2 \\sigma_i^2}{n_i}$，其中 $n_i$ 是窗口 $i$ 的样本数。\n- **约束（总成本）：** $C = \\sum_{i=1}^M c_i n_i = C_{\\mathrm{tot}}$。\n- **约束（最小样本数）：** 对于所有 $i \\in \\{1, \\dots, M\\}$，$n_i \\ge 1$。\n- **变量：**\n    - $M$：窗口数量。\n    - $\\{\\lambda_i\\}_{i=1}^M$：耦合参数值的网格。\n    - $\\{w_i\\}_{i=1}^M$：确定性求积权重。\n    - $\\{\\overline{X}_i\\}_{i=1}^M$：在 $\\lambda_i$ 处广义力 $\\partial U/\\partial \\lambda$ 的样本均值。\n    - $\\{n_i\\}_{i=1}^M$：每个窗口待优化的样本数量。\n    - $\\{\\sigma_i^2\\}_{i=1}^M$：在 $\\lambda_i$ 处 $X_i$ 的单样本方差。\n    - $\\{c_i\\}_{i=1}^M$：窗口 $i$ 处每个样本的计算成本。\n    - $C_{\\mathrm{tot}}$：固定的总计算预算。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于统计力学和计算科学。热力学积分估计量方差的公式是标准的。在成本约束下优化样本分配以最小化方差，是蒙特卡洛模拟中一个经典且至关重要的问题。\n- **适定性：** 该问题定义了一个清晰的目标函数（关于 $n_i$ 的凸函数）和一个线性等式约束，以及边界条件（$n_i \\ge 1$）。这种结构通常会导出一个唯一、稳定且有意义的解。\n- **客观性：** 问题陈述使用了精确的数学和科学语言，没有歧义或主观看法。\n\n**步骤3：结论与行动**\n该问题是有效的。它是在相关科学背景下的一个适定的约束优化问题。\n\n### **第1部分：最优连续分配的解析推导**\n\n我们寻求最小化估计量方差 $V(\\{n_i\\}) = \\sum_{i=1}^M \\frac{w_i^2 \\sigma_i^2}{n_i}$，其约束条件为总成本固定，即 $\\sum_{i=1}^M c_i n_i = C_{\\mathrm{tot}}$。我们首先将样本数 $n_i$ 视为连续变量。这个约束优化问题非常适合使用拉格朗日乘数法。\n\n拉格朗日函数 $\\mathcal{L}$ 构建如下：\n$$\n\\mathcal{L}(\\{n_i\\}, \\mu) = \\sum_{i=1}^M \\frac{w_i^2 \\sigma_i^2}{n_i} + \\mu \\left( \\left( \\sum_{i=1}^M c_i n_i \\right) - C_{\\mathrm{tot}} \\right)\n$$\n其中 $\\mu$ 是与成本约束相关的拉格朗日乘数。\n\n对于最优分配，拉格朗日函数相对于每个 $n_k$ 的梯度必须为零。这给出了对于 $k=1, \\dots, M$ 的平稳性条件：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial n_k} = \\frac{\\partial}{\\partial n_k} \\left( \\frac{w_k^2 \\sigma_k^2}{n_k} \\right) + \\mu c_k = 0\n$$\n$$\n-\\frac{w_k^2 \\sigma_k^2}{n_k^2} + \\mu c_k = 0\n$$\n假设 $\\sigma_k  0$，我们可以重新整理此方程以求解 $n_k$：\n$$\n\\mu c_k n_k^2 = w_k^2 \\sigma_k^2 \\implies n_k^2 = \\frac{w_k^2 \\sigma_k^2}{\\mu c_k} \\implies n_k = \\frac{|w_k| \\sigma_k}{\\sqrt{\\mu c_k}}\n$$\n该方程揭示了最优采样工作量的比例关系：样本数 $n_k$ 与求积权重的大小 $|w_k|$ 和可观测量标准差 $\\sigma_k$ 的乘积成正比，与单位样本成本的平方根 $\\sqrt{c_k}$ 成反比。\n\n为了找到比例常数（其值取决于 $\\mu$），我们将 $n_k$ 的表达式代入成本约束方程中：\n$$\n\\sum_{i=1}^M c_i n_i = \\sum_{i=1}^M c_i \\left( \\frac{|w_i| \\sigma_i}{\\sqrt{\\mu c_i}} \\right) = C_{\\mathrm{tot}}\n$$\n$$\n\\frac{1}{\\sqrt{\\mu}} \\sum_{i=1}^M \\sqrt{c_i} |w_i| \\sigma_i = C_{\\mathrm{tot}}\n$$\n求解包含乘数的项：\n$$\n\\frac{1}{\\sqrt{\\mu}} = \\frac{C_{\\mathrm{tot}}}{\\sum_{j=1}^M \\sqrt{c_j} |w_j| \\sigma_j}\n$$\n最后，我们将此结果代回到 $n_k$ 的表达式中，以获得用已知量表示的最优连续分配：\n$$\nn_k^{\\mathrm{opt}} = \\frac{|w_k| \\sigma_k}{\\sqrt{c_k}} \\left( \\frac{C_{\\mathrm{tot}}}{\\sum_{j=1}^M \\sqrt{c_j} |w_j| \\sigma_j} \\right)\n$$\n该公式给出了每个窗口的最优连续样本数，前提是假设对所有 $k$，$n_k$ 没有下界且 $\\sigma_k0$。\n\n### **第2部分：整数分配算法**\n\n连续解必须转换为一个实际的整数分配方案 $\\{n_i\\}$，该方案对所有 $i$ 满足 $n_i \\ge 1$ 并且精确满足预算 $\\sum_i c_i n_i = C_{\\mathrm{tot}}$。以下算法可实现此目标。\n\n1.  **处理零方差窗口：** 对于任何方差 $\\sigma_i^2 = 0$ 的窗口 $i$，总方差中相应的项已经为零。超出最小采样量是浪费的。因此，对于每个这样的窗口 $i$，我们将其分配设置为所需的最小值 $n_i=1$。这些窗口产生的成本将从总预算 $C_{\\mathrm{tot}}$ 中扣除。然后将这些窗口从进一步的优化中移除。\n\n2.  **活动窗口的迭代连续分配：** 对于剩余的“活动”窗口（其中 $\\sigma_i  0$），我们必须找到一个遵守 $n_i \\ge 1$ 约束的连续分配。采用迭代过程：\n    a. 使用当前剩余预算和当前活动窗口集合，利用第1部分推导的公式计算最优连续分配 $\\{n_i^{\\mathrm{cont}}\\}$。\n    b. 识别任何 $n_i^{\\mathrm{cont}}  1$ 的窗口。这样的结果表明，在此模型下，该窗口的最优分配小于一个样本。由于我们必须至少抽取一个样本，因此我们将这些“欠采样”窗口的分配固定为 $n_i=1$。\n    c. 将这些新固定的窗口从活动集合中移除，并将其成本（$c_i \\cdot 1$）从剩余预算中扣除。\n    d. 使用减少后的活动集和预算重复此过程（步骤 a-c），直到找到一个所有 $n_i^{\\mathrm{cont}} \\ge 1$ 的连续分配。这就得出了剩余活动窗口的最终连续方案。\n\n3.  **整数截断与贪婪分配：** 在此阶段，我们有一个最终的（可能是混合的）分配方案：对于零方差和欠采样窗口，$n_i=1$；对于所有其他窗口，则为实数值 $n_i^{\\mathrm{cont}} \\ge 1$。\n    a. **截断：** 通过对活动窗口的连续值向下取整得到初始整数分配：$n_i^{\\mathrm{int}} = \\lfloor n_i^{\\mathrm{cont}} \\rfloor$。先前固定的窗口的分配仍为 $1$。\n    b. **预算余量：** 计算此初始整数分配的成本，并找到剩余预算 $C_{\\mathrm{rem}} = C_{\\mathrm{tot}} - \\sum_i c_i n_i^{\\mathrm{int}}$。\n    c. **贪婪分配：** 剩余预算 $C_{\\mathrm{rem}}$ 被逐单位成本地分配。在每一步中，我们确定哪个窗口能提供每单位成本最大的方差边际减少量。为窗口 $k$ 增加一个样本（从 $n_k$ 到 $n_k+1$）所带来的方差减少量为 $\\Delta V_k = \\frac{w_k^2 \\sigma_k^2}{n_k} - \\frac{w_k^2 \\sigma_k^2}{n_k+1} = \\frac{w_k^2 \\sigma_k^2}{n_k(n_k+1)}$。每单位成本的减少量为 $g_k = \\Delta V_k / c_k$。\n    算法流程如下：当 $C_{\\mathrm{rem}}  0$ 时：\n        i.  对于所有满足 $c_i \\le C_{\\mathrm{rem}}$ 的窗口 $i$，计算其边际增益 $g_i$。\n        ii. 找到具有最大增益 $g_k$ 的窗口 $k$。\n        iii. 将其样本数加一，$n_k \\leftarrow n_k + 1$。\n        iv. 将剩余预算减少，$C_{\\mathrm{rem}} \\leftarrow C_{\\mathrm{rem}} - c_k$。\n    这个贪婪过程持续进行，直到预算被完全用尽（$C_{\\mathrm{rem}}=0$）。得到的 $\\{n_i\\}$ 即为最终的整数分配方案。\n\n### **第3部分：最终方差计算**\n\n在确定了最终整数分配 $\\{n_i^{\\mathrm{final}}\\}$ 后，通过将这些值代回目标函数来计算最小化的预测方差：\n$$\nV_{\\min} = \\sum_{i=1}^M \\frac{w_i^2 \\sigma_i^2}{n_i^{\\mathrm{final}}}\n$$\n\n至此，解决方案的理论和算法描述完成。", "answer": "```python\nimport numpy as np\n\ndef solve_allocation(M, sigma_sq, c, C_tot, w):\n    \"\"\"\n    Computes the optimal integer sample allocation to minimize estimator variance\n    subject to a total cost constraint.\n    \"\"\"\n    sigma_sq = np.array(sigma_sq, dtype=float)\n    c = np.array(c, dtype=float)\n    w = np.array(w, dtype=float)\n    sigma = np.sqrt(sigma_sq)\n    \n    n_final = np.zeros(M, dtype=int)\n    is_fixed = np.zeros(M, dtype=bool)\n    C_rem = float(C_tot)\n\n    # Step 1: Handle zero-variance windows\n    zero_var_indices = np.where(sigma == 0)[0]\n    for i in zero_var_indices:\n        n_final[i] = 1\n        C_rem -= c[i]\n        is_fixed[i] = True\n\n    if C_rem  0:\n        # This case suggests the budget is insufficient even for minimal sampling.\n        # The problem constraints should prevent this. We return a placeholder\n        # for malformed inputs, though test cases won't trigger this.\n        # Here we just re-allocate to satisfy cost if possible.\n        n_final.fill(1)\n        # In a more complex scenario, might need to increase n_i on zero-var windows if others cost more.\n        # The greedy part below can handle distributing any negative remainder if needed.\n        # But for the given problem, this branch is not expected to be taken.\n        pass\n\n    # Step 2: Iterative continuous allocation for active windows\n    n_continuous = np.zeros(M)\n    while True:\n        active_indices = np.where(~is_fixed)[0]\n        if len(active_indices) == 0:\n            break\n\n        min_cost_for_active = np.sum(c[active_indices])\n        if C_rem  min_cost_for_active:\n             # If budget is not enough for n_i=1 on all remaining, we fix all to 1\n             # and let the greedy algorithm handle the (negative) remainder.\n             # This can happen if C_tot is very small.\n             n_final[active_indices] = 1\n             C_rem -= min_cost_for_active\n             is_fixed[active_indices] = True\n             break\n\n        # Calculate sum for denominator\n        S = np.sum(np.sqrt(c[active_indices]) * np.abs(w[active_indices]) * sigma[active_indices])\n\n        if S == 0: # All remaining active windows have sigma=0, already handled\n            break\n\n        # Calculate continuous allocation for current active set\n        n_cont_active = (np.abs(w[active_indices]) * sigma[active_indices] / np.sqrt(c[active_indices])) * (C_rem / S)\n        \n        # Identify under-sampled windows\n        under_sampled_mask = n_cont_active  1.0\n        under_sampled_indices = active_indices[under_sampled_mask]\n\n        if len(under_sampled_indices) == 0:\n            # All remaining windows are well-sampled, store continuous result and break\n            n_continuous[active_indices] = n_cont_active\n            break\n        else:\n            # Fix under-sampled windows to n=1 and iterate\n            for i in under_sampled_indices:\n                n_final[i] = 1\n                C_rem -= c[i]\n                is_fixed[i] = True\n                \n    # Step 3: Integer truncation and greedy distribution\n    active_indices = np.where(~is_fixed)[0]\n    if len(active_indices) > 0:\n        n_final[active_indices] = np.floor(n_continuous[active_indices]).astype(int)\n\n    C_used = np.sum(c * n_final)\n    C_leftover = C_tot - C_used\n\n    # Greedy allocation of remaining budget\n    # We use a small tolerance for floating point comparisons of the budget\n    while C_leftover > 1e-9:\n        gains = np.zeros(M)\n        eligible_mask = (c = C_leftover)  (sigma > 0) # Only consider affordable increments and non-zero sigma\n        \n        if not np.any(eligible_mask):\n            break # No affordable increments left\n\n        eligible_indices = np.where(eligible_mask)[0]\n        \n        # Calculate marginal gain per unit cost\n        current_n = n_final[eligible_indices]\n        gains[eligible_indices] = (w[eligible_indices]**2 * sigma_sq[eligible_indices]) / \\\n                                  (c[eligible_indices] * current_n * (current_n + 1))\n        \n        best_idx = np.argmax(gains)\n        \n        n_final[best_idx] += 1\n        C_leftover -= c[best_idx]\n\n    # Final variance calculation\n    # To avoid division by zero if n_final has a 0 (should not happen with n_i >= 1)\n    non_zero_n = np.maximum(n_final, 1)\n    minimized_variance = np.sum((w**2 * sigma_sq) / non_zero_n)\n    \n    result = list(n_final) + [minimized_variance]\n    return result\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'M': 4, 'sigma_sq': [4, 1, 9, 16], 'c': [1, 1, 2, 3], 'C_tot': 50, 'w': [1, 1, 1, 1]},\n        # Case B\n        {'M': 3, 'sigma_sq': [1, 0, 4], 'c': [2, 3, 1], 'C_tot': 20, 'w': [1, 1, 1]},\n        # Case C\n        {'M': 5, 'sigma_sq': [1, 9, 4, 16, 25], 'c': [1, 10, 1, 10, 1], 'C_tot': 100, \n         'w': [0.125, 0.25, 0.25, 0.25, 0.125]},\n        # Case D\n        {'M': 2, 'sigma_sq': [1, 1], 'c': [4, 6], 'C_tot': 10, 'w': [1, 1]}\n    ]\n\n    results = []\n    for case in test_cases:\n        res = solve_allocation(**case)\n        results.append(str(res))\n\n    # Format output as a list of lists string\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3454240"}]}