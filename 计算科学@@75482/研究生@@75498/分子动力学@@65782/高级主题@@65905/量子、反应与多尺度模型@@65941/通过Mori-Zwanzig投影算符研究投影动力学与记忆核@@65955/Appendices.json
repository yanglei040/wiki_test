{"hands_on_practices": [{"introduction": "广义朗之万方程（GLE）的核心是记忆核 $K(t)$，它代表了随机力的时间自相关。这个练习 [@problem_id:3438295] 提供了一个具体的数值实现，用于比较计算记忆核的两种方法：理论上精确的Mori-Zwanzig (MZ) 正交动力学方法，以及一种基于完整动力学的常用近似方法。通过这个实践，你将能更深刻地理解投影算符在分离和定义动力学过程中的关键作用，并认识到不同计算路径之间的微妙但至关重要的差异。", "problem": "考虑一个微观哈密顿系统，该系统将粗粒化的蛋白质折叠坐标模拟为高维谐波环境中的一个线性集体变量。微观位置为 $\\mathbf{x} \\in \\mathbb{R}^N$，速度为 $\\mathbf{v} \\in \\mathbb{R}^N$，质量 $m_i$ 汇集在一个对角质量矩阵 $\\mathbf{M} = \\operatorname{diag}(m_1,\\dots,m_N)$ 中，刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 是对称正定的。势能为 $U(\\mathbf{x}) = \\tfrac{1}{2} \\mathbf{x}^\\top \\mathbf{K} \\mathbf{x}$。分析集体坐标为 $Q = \\mathbf{c}^\\top \\mathbf{x}$，其中 $\\mathbf{c} \\in \\mathbb{R}^N$ 是一个固定的系数向量。微观动力学遵循牛顿定律：$\\dot{\\mathbf{x}} = \\mathbf{v}$ 和 $\\dot{\\mathbf{v}} = -\\mathbf{M}^{-1} \\mathbf{K} \\mathbf{x}$。在温度 $T$ 下的正则平衡具有与 $\\exp\\left(-\\beta H(\\mathbf{x},\\mathbf{v})\\right)$ 成正比的玻尔兹曼因子，其中 $H(\\mathbf{x},\\mathbf{v}) = \\tfrac{1}{2}\\mathbf{x}^\\top \\mathbf{K}\\mathbf{x} + \\tfrac{1}{2}\\mathbf{v}^\\top \\mathbf{M}\\mathbf{v}$ 且 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n定义相空间向量 $\\mathbf{z} = [\\mathbf{x}; \\mathbf{v}] \\in \\mathbb{R}^{2N}$ 和线性系统矩阵\n$$\n\\mathbf{A}_{\\mathrm{sys}} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & \\mathbf{0}\n\\end{bmatrix},\n$$\n以使得 $\\dot{\\mathbf{z}} = \\mathbf{A}_{\\mathrm{sys}} \\mathbf{z}$。$\\mathbf{z}$ 的正则协方差为\n$$\n\\boldsymbol{\\Sigma} = \\begin{bmatrix}\nk_{\\mathrm{B}} T\\, \\mathbf{K}^{-1} & \\mathbf{0} \\\\\n\\mathbf{0} & k_{\\mathrm{B}} T\\, \\mathbf{M}^{-1}\n\\end{bmatrix}.\n$$\n考虑线性可观测量 $Q(\\mathbf{z}) = \\mathbf{q}^\\top \\mathbf{z}$ 和 $\\dot{Q}(\\mathbf{z}) = \\mathbf{d}^\\top \\mathbf{z}$，其系数向量分别为 $\\mathbf{q} = [\\mathbf{c}; \\mathbf{0}]$ 和 $\\mathbf{d} = [\\mathbf{0}; \\mathbf{c}]$。与 $Q$ 共轭的微观广义力为 $F(\\mathbf{z}) = -\\partial U / \\partial Q = -\\mathbf{c}^\\top \\mathbf{K} \\mathbf{x}$，它也是一个线性可观测量，其系数向量为 $\\mathbf{f} = [-\\mathbf{K}\\mathbf{c}; \\mathbf{0}]$。\n\n设 $\\mathcal{V}$ 是由 $Q$ 和 $\\dot{Q}$ 张成的线性可观测量二维子空间。在平衡态下使用正则内积 $\\langle A, B \\rangle = \\mathbb{E}[A B]$，作用于可观测量系数向量的正交投影算子 $\\mathbf{P}$ 是到 $\\mathbf{q}$ 和 $\\mathbf{d}$ 的张成空间上的 $\\boldsymbol{\\Sigma}$ 加权投影算子：\n$$\n\\mathbf{P} = \\mathbf{V}\\left(\\mathbf{V}^\\top \\boldsymbol{\\Sigma} \\mathbf{V}\\right)^{-1}\\mathbf{V}^\\top \\boldsymbol{\\Sigma}, \\quad \\text{with } \\mathbf{V} = [\\mathbf{q}, \\mathbf{d}] \\in \\mathbb{R}^{2N \\times 2}.\n$$\n力的垂直分量为 $\\mathbf{f}_\\perp = (\\mathbf{I} - \\mathbf{P}) \\mathbf{f}$。\n\n实现一个程序，为每个给定的测试用例执行以下任务：\n\n1. 将 $\\mathbf{K}$ 构建为对角刚度和最近邻链拉普拉斯算子之和，以确保其为对称正定矩阵。具体来说，设链拉普拉斯算子是一个 $N \\times N$ 的三对角矩阵，其对角线元素为 $2$（端点处为 $1$），紧邻的次对角线元素为 $-1$。设 $\\mathbf{K} = k_{\\mathrm{main}} \\mathbf{I} + k_{\\mathrm{couple}} \\mathbf{L}_{\\mathrm{chain}}$，其中 $k_{\\mathrm{main}}$ 和 $k_{\\mathrm{couple}}$ 是给定的标量。所有刚度值必须以牛顿/米（$\\mathrm{N}/\\mathrm{m}$）表示。\n\n2. 如上所述构建 $\\mathbf{M}$、$\\mathbf{A}_{\\mathrm{sys}}$、$\\boldsymbol{\\Sigma}$、$\\mathbf{P}$ 和 $\\mathbf{f}_\\perp$。所有质量必须以千克（$\\mathrm{kg}$）表示，温度以开尔文（$\\mathrm{K}$）表示，时间以秒（$\\mathrm{s}$）表示。\n\n3. 正交动力学路径：使用作为系数上线性算子作用于可观测量的正交动力学生成元来演化垂直力系数，即使用矩阵 $\\mathbf{G}_{\\mathrm{OD}} = (\\mathbf{I} - \\mathbf{P}) \\mathbf{A}_{\\mathrm{sys}}^\\top$。对于时间 $t$，演化后的系数为 $\\mathbf{a}_{\\mathrm{OD}}(t) = \\exp\\left(\\mathbf{G}_{\\mathrm{OD}} t\\right)\\mathbf{f}_\\perp$。由此，使用与 $\\boldsymbol{\\Sigma}$ 的正则内积并通过 $\\beta$ 进行缩放，计算记忆核的时间序列 $K_{\\mathrm{OD}}(t)$。将 $K_{\\mathrm{OD}}(t)$ 以 $\\mathrm{N}/\\mathrm{m}$ 表示。\n\n4. 力自相关估计路径：使用 $\\mathbf{G}_{\\mathrm{full}} = \\mathbf{A}_{\\mathrm{sys}}^\\top$ 在全动力学下演化微观力系数，即 $\\mathbf{a}_{\\mathrm{full}}(t) = \\exp\\left(\\mathbf{G}_{\\mathrm{full}} t\\right)\\mathbf{f}$。将演化后的系数投影到垂直子空间上，得到 $\\mathbf{a}_{\\mathrm{FAC}}(t) = (\\mathbf{I} - \\mathbf{P}) \\mathbf{a}_{\\mathrm{full}}(t)$。由此，使用与 $\\boldsymbol{\\Sigma}$ 的正则内积并通过 $\\beta$ 进行缩放，计算时间序列 $K_{\\mathrm{FAC}}(t)$（以 $\\mathrm{N}/\\mathrm{m}$ 为单位）。\n\n5. 在具有 $N_t$ 个点的均匀时间网格 $t \\in [0, t_{\\max}]$ 上，计算整个网格上的最大绝对差：\n$$\n\\Delta = \\max_{t \\in \\{t_k\\}} \\left| K_{\\mathrm{OD}}(t) - K_{\\mathrm{FAC}}(t) \\right|.\n$$\n将 $\\Delta$ 作为以 $\\mathrm{N}/\\mathrm{m}$ 为单位的浮点数返回。\n\n您的程序必须为以下测试套件实现上述内容，并生成一行输出，其中包含按测试顺序排列的结果，格式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$：\n\n- 测试用例 $1$ (正常路径)：\n  - $N = 4$\n  - 质量 $\\mathbf{m} = [2.0 \\times 10^{-26}, 3.0 \\times 10^{-26}, 2.5 \\times 10^{-26}, 2.2 \\times 10^{-26}]$，单位 $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 5.0$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 2.0$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$，单位 $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c}$ 为均匀权重：$c_i = 1/N$ for $i = 1,\\dots,N$\n  - 时间网格：$t_{\\max} = 5.0 \\times 10^{-12}$，单位 $\\mathrm{s}$，$N_t = 51$\n\n- 测试用例 $2$ (Q与坐标轴的边界对齐)：\n  - $N = 3$\n  - 质量 $\\mathbf{m} = [2.0 \\times 10^{-26}, 2.0 \\times 10^{-26}, 2.0 \\times 10^{-26}]$，单位 $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 10.0$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 0.5$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$，单位 $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c} = [1.0, 0.0, 0.0]$\n  - 时间网格：$t_{\\max} = 5.0 \\times 10^{-12}$，单位 $\\mathrm{s}$，$N_t = 51$\n\n- 测试用例 $3$ (强耦合和异质质量的边缘情况)：\n  - $N = 5$\n  - 质量 $\\mathbf{m} = [1.5 \\times 10^{-26}, 2.0 \\times 10^{-26}, 2.5 \\times 10^{-26}, 2.8 \\times 10^{-26}, 3.0 \\times 10^{-26}]$，单位 $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 8.0$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 6.0$，单位 $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$，单位 $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c}$ 为交替符号：$c_i = (-1)^{i-1} / \\sqrt{N}$ for $i = 1,\\dots,N$\n  - 时间网格：$t_{\\max} = 5.0 \\times 10^{-12}$，单位 $\\mathrm{s}$，$N_t = 51$\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3]$），其中每个 $r_i$ 是相应测试用例的最大绝对差 $\\Delta$，以 $\\mathrm{N}/\\mathrm{m}$ 表示。", "solution": "提交审议的问题陈述是有效的。它在统计力学和分子动力学领域提出了一个适定且有科学依据的问题，特别关注于 Mori-Zwanzig 投影算子形式体系在线性系统中的数值实现。该问题要求比较计算记忆核的两种不同路径，这是一项非平凡的任务，它探究了投影方法应用中的一个关键精微之处。所有参数和定义都已提供，确保了问题的自洽性，并允许得到一个唯一的、可验证的解。因此，我们可以继续提供一个完整且合理的解决方案。\n\n问题的核心在于计算粗粒化变量 $Q$ 的广义朗之万方程的记忆核 $K(t)$。该核定义为“随机”或“正交”力的时间自相关，该力是在与分析变量正交的子空间中演化的微观力的分量。对于一个线性系统，这种形式体系可以转化为作用于线性可观测量系数向量的矩阵代数。我们将构建必要的矩阵，实现两种指定的动力学演化方案，并计算所得记忆核之间的差异。\n\n**1. 系统和相空间矩阵的构建**\n该系统由 $N$ 个处于谐波势中的粒子组成。我们首先在位形空间中构建基本矩阵。\n- 质量矩阵 $\\mathbf{M} \\in \\mathbb{R}^{N \\times N}$ 是给定粒子质量的对角矩阵，$\\mathbf{M} = \\operatorname{diag}(m_1, \\dots, m_N)$。\n- 刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 由 $\\mathbf{K} = k_{\\mathrm{main}} \\mathbf{I} + k_{\\mathrm{couple}} \\mathbf{L}_{\\mathrm{chain}}$ 给出。链拉普拉斯矩阵 $\\mathbf{L}_{\\mathrm{chain}}$ 是一个对称半正定矩阵。由于 $k_{\\mathrm{main}} > 0$ 和 $k_{\\mathrm{couple}} \\ge 0$，所得矩阵 $\\mathbf{K}$ 是对称且严格正定的，这保证了其逆矩阵 $\\mathbf{K}^{-1}$ 存在。\n\n动力学在一个 $2N$ 维相空间中被表述，其状态向量为 $\\mathbf{z} = [\\mathbf{x}; \\mathbf{v}]$。时间演化由线性常微分方程组 $\\dot{\\mathbf{z}} = \\mathbf{A}_{\\mathrm{sys}} \\mathbf{z}$ 支配，其中系统矩阵 $\\mathbf{A}_{\\mathrm{sys}} \\in \\mathbb{R}^{2N \\times 2N}$ 定义为：\n$$\n\\mathbf{A}_{\\mathrm{sys}} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & \\mathbf{0}\n\\end{bmatrix}\n$$\n相空间向量与自身外积的正则平衡系综平均定义了协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top]$。对于此谐波系统，它由以下公式给出：\n$$\n\\boldsymbol{\\Sigma} = \\begin{bmatrix}\nk_{\\mathrm{B}} T\\, \\mathbf{K}^{-1} & \\mathbf{0} \\\\\n\\mathbf{0} & k_{\\mathrm{B}} T\\, \\mathbf{M}^{-1}\n\\end{bmatrix}\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n\n**2. 投影算子形式体系**\n可观测量空间被限制在由粗粒化坐标 $Q(\\mathbf{z}) = \\mathbf{q}^\\top \\mathbf{z}$ 及其时间导数 $\\dot{Q}(\\mathbf{z}) = \\mathbf{d}^\\top \\mathbf{z}$ 张成的二维子空间内。相应的系数向量为 $\\mathbf{q} = [\\mathbf{c}; \\mathbf{0}]$ 和 $\\mathbf{d} = [\\mathbf{0}; \\mathbf{c}]$。两个线性可观测量 $A = \\mathbf{a}^\\top\\mathbf{z}$ 和 $B = \\mathbf{b}^\\top\\mathbf{z}$ 之间的正则内积为 $\\langle A, B \\rangle = \\mathbb{E}[AB] = \\mathbf{a}^\\top \\boldsymbol{\\Sigma} \\mathbf{b}$。\n\n将可观测量的系数向量投影到由 $\\mathbf{q}$ 和 $\\mathbf{d}$ 张成的子空间上的投影算子 $\\mathbf{P}$ 定义为：\n$$\n\\mathbf{P} = \\mathbf{V}\\left(\\mathbf{V}^\\top \\boldsymbol{\\Sigma} \\mathbf{V}\\right)^{-1}\\mathbf{V}^\\top \\boldsymbol{\\Sigma}, \\quad \\text{with } \\mathbf{V} = [\\mathbf{q}, \\mathbf{d}]\n$$\n在欧几里得意义上，这是一个斜投影算子，但相对于 $\\boldsymbol{\\Sigma}$ 加权内积，它是正交的（自伴的），满足 $\\mathbf{a}^\\top \\boldsymbol{\\Sigma} (\\mathbf{P}\\mathbf{b}) = (\\mathbf{P}\\mathbf{a})^\\top \\boldsymbol{\\Sigma} \\mathbf{b}$。互补正交投影算子是 $\\mathcal{Q}_{\\text{proj}} = \\mathbf{I} - \\mathbf{P}$。\n\n微观广义力 $F = -\\mathbf{c}^\\top \\mathbf{K} \\mathbf{x}$ 对应于系数向量 $\\mathbf{f} = [-\\mathbf{K}\\mathbf{c}; \\mathbf{0}]$。Mori-Zwanzig 形式体系中的“随机力”是该力与分析子空间正交的分量。其在时间 $t=0$ 时的系数向量为 $\\mathbf{f}_\\perp = (\\mathbf{I} - \\mathbf{P})\\mathbf{f}$。\n\n**3. 动力学和记忆核计算**\n在海森堡绘景中，可观测量系数向量 $\\mathbf{a}$ 的演化由 $\\mathbf{a}(t) = \\exp(\\mathbf{A}_{\\mathrm{sys}}^\\top t) \\mathbf{a}(0)$ 给出。计算记忆核的两种路径在处理动力学的方式上有所不同。记忆核定义为 $K(t) = \\beta \\mathbb{E}[R(t) R(0)]$，其中 $R(t)$ 是时间 $t$ 时的随机力，$\\beta = (k_{\\mathrm{B}}T)^{-1}$。\n\n**路径1：正交动力学 (OD)**\n这是理论上精确的 Mori-Zwanzig 公式。随机力根据由 $\\mathcal{Q}_{\\text{proj}}\\mathbf{A}_{\\mathrm{sys}}^\\top$ 生成的投影动力学进行演化。\n- 演化后的随机力系数：$\\mathbf{a}_{\\mathrm{OD}}(t) = \\exp\\left( (\\mathbf{I} - \\mathbf{P})\\mathbf{A}_{\\mathrm{sys}}^\\top t \\right) \\mathbf{f}_\\perp$。\n- 记忆核：$K_{\\mathrm{OD}}(t) = \\beta \\, \\mathbf{a}_{\\mathrm{OD}}(t)^\\top \\boldsymbol{\\Sigma} \\, \\mathbf{f}_\\perp$。\n\n**路径2：力自相关估计 (FAC)**\n该路径使用一种替代公式，通常是一种近似。全作用力在全动力学下演化，其结果在演化*之后*投影到正交子空间上。\n- 演化后的全力系数：$\\mathbf{a}_{\\mathrm{full}}(t) = \\exp(\\mathbf{A}_{\\mathrm{sys}}^\\top t) \\mathbf{f}$。\n- 投影后的系数：$\\mathbf{a}_{\\mathrm{FAC}}(t) = (\\mathbf{I} - \\mathbf{P}) \\mathbf{a}_{\\mathrm{full}}(t)$。\n- 记忆核：$K_{\\mathrm{FAC}}(t) = \\beta \\, \\mathbf{a}_{\\mathrm{FAC}}(t)^\\top \\boldsymbol{\\Sigma} \\, \\mathbf{f}_\\perp$。\n\n这两种路径在数学上并不等价，因为投影算子 $\\mathbf{P}$ 和动力学生成元 $\\mathbf{A}_{\\mathrm{sys}}^\\top$ 不对易。问题要求计算在离散时间网格上的最大绝对差 $\\Delta = \\max_t |K_{\\mathrm{OD}}(t) - K_{\\mathrm{FAC}}(t)|$。\n\n**4. 数值实现纲要**\n对于每个测试用例，算法按以下步骤进行：\n1. 根据给定参数 $N$、$\\mathbf{m}$、$k_{\\mathrm{main}}$、$k_{\\mathrm{couple}}$ 和 $T$ 构建矩阵 $\\mathbf{M}$、$\\mathbf{K}$、$\\mathbf{A}_{\\mathrm{sys}}$ 和 $\\boldsymbol{\\Sigma}$。\n2. 根据向量 $\\mathbf{c}$ 构建系数向量 $\\mathbf{q}$、$\\mathbf{d}$ 和 $\\mathbf{f}$。\n3. 构造投影算子 $\\mathbf{P}$ 和初始随机力向量 $\\mathbf{f}_\\perp$。\n4. 定义动力学生成元 $\\mathbf{G}_{\\mathrm{OD}} = (\\mathbf{I} - \\mathbf{P})\\mathbf{A}_{\\mathrm{sys}}^\\top$ 和 $\\mathbf{G}_{\\mathrm{full}} = \\mathbf{A}_{\\mathrm{sys}}^\\top$。\n5. 遍历时间网格点 $t_k \\in [0, t_{\\max}]$。在每次迭代中：\n   a. 使用稳健的数值算法（`scipy.linalg.expm`）计算矩阵指数 $\\exp(\\mathbf{G}_{\\mathrm{OD}} t_k)$ 和 $\\exp(\\mathbf{G}_{\\mathrm{full}} t_k)$。\n   b. 计算 $\\mathbf{a}_{\\mathrm{OD}}(t_k)$ 和 $\\mathbf{a}_{\\mathrm{FAC}}(t_k)$。\n   c. 计算核函数值 $K_{\\mathrm{OD}}(t_k)$ 和 $K_{\\mathrm{FAC}}(t_k)$。\n6. 确定两个计算出的核函数时间序列之间的最大绝对差。该值 $\\Delta$ 即为该测试用例的结果。\n所有计算均使用浮点运算，其值采用标准国际单位制（SI）单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"N\": 4,\n            \"m_vals\": np.array([2.0e-26, 3.0e-26, 2.5e-26, 2.2e-26]),\n            \"k_main\": 5.0,\n            \"k_couple\": 2.0,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: np.ones(N) / N,\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n        {\n            \"N\": 3,\n            \"m_vals\": np.array([2.0e-26, 2.0e-26, 2.0e-26]),\n            \"k_main\": 10.0,\n            \"k_couple\": 0.5,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: np.array([1.0] + [0.0] * (N - 1)),\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n        {\n            \"N\": 5,\n            \"m_vals\": np.array([1.5e-26, 2.0e-26, 2.5e-26, 2.8e-26, 3.0e-26]),\n            \"k_main\": 8.0,\n            \"k_couple\": 6.0,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: ((-1.0) ** np.arange(N)) / np.sqrt(N),\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta = calculate_delta(\n            case[\"N\"],\n            case[\"m_vals\"],\n            case[\"k_main\"],\n            case[\"k_couple\"],\n            case[\"T\"],\n            case[\"c_rule\"],\n            case[\"t_max\"],\n            case[\"N_t\"],\n            k_B,\n        )\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_delta(N, m_vals, k_main, k_couple, T, c_rule, t_max, N_t, k_B):\n    \"\"\"\n    Calculates the maximum absolute difference Delta for a single test case.\n    \"\"\"\n    # 1. Construct Basic and Phase-Space Matrices\n    # Mass matrix M and its inverse\n    M = np.diag(m_vals)\n    M_inv = np.diag(1.0 / m_vals)\n\n    # Stiffness matrix K\n    L_chain = (\n        np.diag(np.full(N, 2.0))\n        - np.diag(np.ones(N - 1), k=1)\n        - np.diag(np.ones(N - 1), k=-1)\n    )\n    if N > 0:\n        L_chain[0, 0] = 1.0\n    if N > 1:\n        L_chain[N - 1, N - 1] = 1.0\n    \n    K = k_main * np.identity(N) + k_couple * L_chain\n    K_inv = np.linalg.inv(K)\n\n    # Phase-space matrices A_sys and Sigma\n    dim = 2 * N\n    A_sys = np.zeros((dim, dim))\n    A_sys[:N, N:] = np.identity(N)\n    A_sys[N:, :N] = -M_inv @ K\n\n    Sigma = np.zeros((dim, dim))\n    Sigma[:N, :N] = k_B * T * K_inv\n    Sigma[N:, N:] = k_B * T * M_inv\n\n    # 2. Construct Vectors and Projector\n    c_vec = c_rule(N)\n    q = np.concatenate([c_vec, np.zeros(N)])\n    d = np.concatenate([np.zeros(N), c_vec])\n    f = np.concatenate([-K @ c_vec, np.zeros(N)])\n\n    V = np.vstack([q, d]).T  # Shape (2N, 2)\n    \n    # Gram matrix for projection\n    G_mat = V.T @ Sigma @ V\n    G_inv = np.linalg.inv(G_mat)\n\n    # Projection operator P\n    P = V @ G_inv @ V.T @ Sigma\n    Q_proj = np.identity(dim) - P\n\n    # Perpendicular force vector f_perp\n    f_perp = Q_proj @ f\n\n    # 3. Time Evolution and Kernel Calculation\n    t_grid = np.linspace(0, t_max, N_t)\n    beta = 1.0 / (k_B * T)\n\n    K_OD = np.zeros(N_t)\n    K_FAC = np.zeros(N_t)\n\n    G_full = A_sys.T\n    G_OD = Q_proj @ A_sys.T\n    \n    for i, t in enumerate(t_grid):\n        # Orthogonal Dynamics (OD) Route\n        exp_G_OD_t = linalg.expm(G_OD * t)\n        a_OD_t = exp_G_OD_t @ f_perp\n        K_OD[i] = beta * (a_OD_t.T @ Sigma @ f_perp)\n\n        # Force-Autocorrelation (FAC) Route\n        exp_G_full_t = linalg.expm(G_full * t)\n        a_full_t = exp_G_full_t @ f\n        a_FAC_t = Q_proj @ a_full_t\n        K_FAC[i] = beta * (a_FAC_t.T @ Sigma @ f_perp)\n\n    # 4. Calculate Final Difference\n    delta = np.max(np.abs(K_OD - K_FAC))\n    return delta\n\nsolve()\n```", "id": "3438295"}, {"introduction": "在掌握了如何为给定的粗粒化变量计算记忆核之后，一个自然而然的问题是：如何选择“好”的粗粒化变量？这个练习 [@problem_id:3438303] 直接探讨了这一问题，并提供了一个量化标准：一个“好”的粗粒化变量应该能有效捕捉系统的慢动力学，从而使其随机力（或称残余噪声）的影响最小化。通过为不同的变量选择计算并比较残余噪声的大小，我们将建立起关于如何构建有效粗粒化模型的直观认识。", "problem": "考虑一个描述状态向量 $x(t) \\in \\mathbb{R}^n$ 的确定性线性微观动力学，该动力学由常微分方程 $ \\dot{x}(t) = A x(t) $ 控制，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个常数矩阵。假设初始条件的平衡系综服从均值为零、协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 的高斯分布，该矩阵是对称正定的。对于定义为 $ \\xi(x) = c^\\top x $（其中 $c \\in \\mathbb{R}^n$）的标量粗粒化可观测量（反应坐标），考虑在平衡分布下关于内积 $(u,v) = \\mathbb{E}[u v]$ 的一维 Mori-Zwanzig (MZ) 投影。使用 Mori-Zwanzig 形式论以及对 $\\xi$ 的生成空间进行协方差加权的正交投影，$\\xi(t)$ 的投影动力学可以表示为一个包含记忆核 $K(t)$ 和残余（随机）力 $R(t)$ 的广义朗之万方程 (GLE)。\n\n从确定性微观定律 $ \\dot{x} = A x $ 出发，作用于线性可观测量的刘维尔算符为 $ i \\mathcal{L} \\xi = c^\\top A x = d^\\top x $，其中 $ d = A^\\top c $。设到 $\\operatorname{span}(\\xi)$ 上的投影算符为 $ \\mathcal{P} b = \\frac{(b,\\xi)}{(\\xi,\\xi)} \\xi $。对于线性可观测量 $ b(x) = u^\\top x $（其中 $ u \\in \\mathbb{R}^n $），这会导出系数空间上的投影 $ P u = c \\frac{u^\\top \\Sigma c}{c^\\top \\Sigma c} $，以及相应的正交投影算符 $ Q = I - P $。定义初始残余力系数 $ g = d - \\alpha c $，其中 $ \\alpha = \\frac{d^\\top \\Sigma c}{c^\\top \\Sigma c} $。系数的正交动力学演化遵循 $ u(t) = e^{t Q A^\\top} u(0) $。因此，残余力为 $ R(t) = u(t)^\\top x(t_0) $，其中 $ u(0) = g $，其在时间 $t$ 的平衡均方值为 $ \\mathbb{E}[R(t)^2] = u(t)^\\top \\Sigma u(t) $。标量投影动力学的记忆核为\n$$\nK(t) = \\frac{(R(0), R(t))}{(\\xi,\\xi)} = \\frac{g^\\top \\Sigma \\, e^{t Q A^\\top} g}{c^\\top \\Sigma c}。\n$$\n\n你的任务是实现一个程序，为每个指定的测试用例，计算与两个不同反应坐标 $\\xi_1(x) = c_1^\\top x$ 和 $\\xi_2(x) = c_2^\\top x$ 相对应的记忆核 $K_1(t)$ 和 $K_2(t)$，并评估哪个坐标能产生更小的经时间平均、协方差归一化的残余噪声\n$$\n\\langle R_j^2 \\rangle_T = \\frac{1}{T} \\int_0^T \\frac{u_j(t)^\\top \\Sigma \\, u_j(t)}{c_j^\\top \\Sigma c_j} \\, dt, \\quad j \\in \\{1,2\\},\n$$\n其中 $u_j(t) = e^{t Q_j A^\\top} g_j$, $g_j = d_j - \\alpha_j c_j$, $d_j = A^\\top c_j$, $\\alpha_j = \\frac{d_j^\\top \\Sigma c_j}{c_j^\\top \\Sigma c_j}$，以及 $Q_j = I - c_j \\frac{(\\Sigma c_j)^\\top}{c_j^\\top \\Sigma c_j}$。对于数值实现，使用矩阵指数 $e^{t Q_j A^\\top}$，并通过在 $[0,T]$ 上的 $N$ 个时间点进行均匀平均来近似该积分。\n\n所有量都是无量纲的（没有物理单位）。使用以下测试套件，其中每个用例指定了 $(A,\\Sigma,c_1,c_2,T,N)$：\n\n- 测试用例 1（二维慢-快耦合；混合的第二坐标）：\n$$\nA = \\begin{bmatrix}\n-0.10 & 1.00 \\\\\n-4.00 & -1.00\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}, \\quad\nT = 5.0, \\quad N = 200.\n$$\n\n- 测试用例 2（坐标相同；预期为平局）：\n$$\nA = \\begin{bmatrix}\n-0.10 & 1.00 \\\\\n-4.00 & -1.00\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nT = 5.0, \\quad N = 200.\n$$\n\n- 测试用例 3（二维，第二坐标为强快变量）：\n$$\nA = \\begin{bmatrix}\n-0.05 & 10.0 \\\\\n-0.10 & -2.0\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}, \\quad\nT = 4.0, \\quad N = 200.\n$$\n\n- 测试用例 4（三维，具有非平凡协方差）：\n$$\nA = \\begin{bmatrix}\n-0.20 & 0.80 & 0.00 \\\\\n-1.00 & -0.50 & 2.00 \\\\\n0.00 & -1.50 & -0.30\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n2.0 & 0.0 & 0.0 \\\\\n0.0 & 1.0 & 0.0 \\\\\n0.0 & 0.0 & 0.5\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.7 \\end{bmatrix}, \\quad\nT = 6.0, \\quad N = 300.\n$$\n\n对于每个测试用例，在指定的时间网格上计算 $K_1(t)$ 和 $K_2(t)$，然后使用 $N$ 个点的算术平均值计算 $\\langle R_1^2 \\rangle_T$ 和 $\\langle R_2^2 \\rangle_T$。确定哪个坐标可以最小化归一化残余噪声。如果两个平均值在 $10^{-12}$ 的数值公差范围内相等，则选择第一个坐标。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试用例所选坐标的索引，形式为方括号括起来的逗号分隔列表（例如，$[1,2,1,2]$）。", "solution": "用户希望解决一个基于 Mori-Zwanzig 形式论的投影动力学问题。\n\n### 第 1 步：提取已知信息\n问题为线性动力学系统 $\\dot{x}(t) = A x(t)$ 提供了以下数据和定义：\n-   状态向量：$x(t) \\in \\mathbb{R}^n$\n-   动力学矩阵：$A \\in \\mathbb{R}^{n \\times n}$\n-   平衡分布：均值为零、协方差为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 的高斯分布，该矩阵对称正定。\n-   标量可观测量（反应坐标）：$\\xi(x) = c^\\top x$，其中向量 $c \\in \\mathbb{R}^n$。\n-   内积：$(u,v) = \\mathbb{E}[u v]$。对于线性可观测量 $u=u^\\top x$ 和 $v=v^\\top x$，此内积为 $(u,v) = u^\\top \\Sigma v$。\n-   作用于线性可观测量的刘维尔算符：$i \\mathcal{L} \\xi = c^\\top A x = d^\\top x$，其中 $d = A^\\top c$。\n-   系数上的投影算符：$P u = c \\frac{u^\\top \\Sigma c}{c^\\top \\Sigma c}$。\n-   正交投影算符：$Q = I - P$。问题提供了矩阵形式 $Q_j = I - c_j \\frac{(\\Sigma c_j)^\\top}{c_j^\\top \\Sigma c_j}$。\n-   初始残余力系数：$g = d - \\alpha c$，其中 $\\alpha = \\frac{d^\\top \\Sigma c}{c^\\top \\Sigma c}$。\n-   系数的正交动力学：$u(t) = e^{t Q A^\\top} u(0)$。对于残余力，$u(0) = g$。\n-   经时间平均、协方差归一化的残余噪声：$\\langle R_j^2 \\rangle_T = \\frac{1}{T} \\int_0^T \\frac{u_j(t)^\\top \\Sigma \\, u_j(t)}{c_j^\\top \\Sigma c_j} \\, dt$，适用于坐标 $j \\in \\{1,2\\}$。\n-   数值近似：积分通过在区间 $[0, T]$ 上的 $N$ 个均匀间隔时间点上的算术平均来近似。\n-   决策规则：对于每个测试用例，选择使 $\\langle R_j^2 \\rangle_T$ 最小化的坐标 $j$。如果两个值在 $10^{-12}$ 的公差范围内相等，则选择坐标 1。\n-   测试用例：提供了四个测试用例，每个用例都指定了元组 $(A, \\Sigma, c_1, c_2, T, N)$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题在科学上基于已建立的 Mori-Zwanzig 投影动力学理论，这是统计力学中的一个标准课题。将其应用于具有高斯统计特性的线性系统是一个常见且易于理解的模型。所有关于投影算符、传播子和派生量的数学定义都是标准的且自洽的。\n\n问题是适定 (well-posed) 的。每个用例都提供了所有必要的输入 ($A, \\Sigma, c_1, c_2, T, N$)。这些定义导出了一个唯一的计算过程。使用对称正定协方差矩阵 $\\Sigma$ 可确保对于任何非零向量 $c$，分母如 $c^\\top \\Sigma c$ 均不为零，从而防止除以零。目标清晰明确：计算并比较两个值，并根据精确的规则做出决策。语言客观且正式。没有矛盾、信息缺失或伪科学论断。这是一个非平凡但可解的数值任务。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 算法解决方案\n问题的核心是为两个反应坐标 $\\xi_1(x) = c_1^\\top x$ 和 $\\xi_2(x) = c_2^\\top x$ 计算经时间平均的归一化残余噪声 $\\langle R_j^2 \\rangle_T$。对应于索引 $j$ 的每个坐标 $c_j$ 的过程如下：\n\n1.  **计算初步量**：\n    给定矩阵 $A$ 和 $\\Sigma$，以及向量 $c_j$：\n    -   计算可观测量时间导数的系数向量：$d_j = A^\\top c_j$。\n    -   计算归一化常数，即为可观测量 $\\xi_j$ 的方差：$\\text{var}(\\xi_j) = (\\xi_j, \\xi_j) = c_j^\\top \\Sigma c_j$。\n    -   计算频率因子 $\\alpha_j = \\frac{(i\\mathcal{L}\\xi_j, \\xi_j)}{(\\xi_j, \\xi_j)} = \\frac{d_j^\\top \\Sigma c_j}{c_j^\\top \\Sigma c_j}$。\n    -   计算正交力的初始系数：$g_j = d_j - \\alpha_j c_j$。该向量关于 $\\Sigma$ 加权内积与 $c_j$ 正交，即 $g_j^\\top \\Sigma c_j = 0$。\n\n2.  **定义正交动力学**：\n    -   构建将系数向量投影到 $c_j$ 方向的投影矩阵 $P_j$。其矩阵形式为 $P_j = \\frac{c_j c_j^\\top \\Sigma}{c_j^\\top \\Sigma c_j}$。\n    -   正交投影算符为 $Q_j = I - P_j$。\n    -   系数正交动力学的生成元是矩阵 $M_j = Q_j A^\\top$。\n\n3.  **计算时间平均噪声**：\n    -   在区间 $[0, T]$ 上定义一个包含 $N$ 个点的均匀时间网格：$t_k = k \\frac{T}{N-1}$，其中 $k=0, 1, \\dots, N-1$。\n    -   对于网格上的每个时间点 $t_k$，计算正交系数的演化：$u_j(t_k) = e^{t_k M_j} g_j$。矩阵指数 $e^{t_k M_j}$ 通过数值方法计算。\n    -   在每个时间点 $t_k$，计算归一化残余噪声平方的瞬时值：$f_j(t_k) = \\frac{u_j(t_k)^\\top \\Sigma \\, u_j(t_k)}{c_j^\\top \\Sigma c_j}$。\n    -   时间平均 $\\langle R_j^2 \\rangle_T$ 通过这些值在 $N$ 个点上的算术平均值来近似：$S_j = \\frac{1}{N} \\sum_{k=0}^{N-1} f_j(t_k)$。\n\n4.  **比较与决策**：\n    -   对计算出的两个平均值 $S_1$ 和 $S_2$ 进行比较。\n    -   遵循指定规则，如果 $S_1 - S_2 \\le 10^{-12}$，则选择索引为 1 的坐标。如果 $S_1$ 显著小于 $S_2$，或者 $S_1$ 和 $S_2$ 在给定公差范围内相等，则满足此条件。否则，选择坐标 2。\n\n对每个测试用例应用此过程以确定最优坐标。最终输出是所选索引的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef calculate_average_noise(A, Sigma, c, T, N):\n    \"\"\"\n    Calculates the time-averaged, covariance-normalized residual noise for a given reaction coordinate.\n\n    Args:\n        A (np.ndarray): The dynamics matrix.\n        Sigma (np.ndarray): The covariance matrix of the equilibrium distribution.\n        c (np.ndarray): The coefficient vector defining the reaction coordinate.\n        T (float): The total integration time.\n        N (int): The number of time points for the numerical average.\n\n    Returns:\n        float: The calculated average residual noise.\n    \"\"\"\n    n = A.shape[0]\n    Id = np.identity(n)\n    At = A.T\n\n    # 1. Compute preliminary quantities\n    d = At @ c\n    denom = c.T @ Sigma @ c\n    \n    # Handle the trivial case where c is the zero vector, though not expected from problem spec.\n    if np.isclose(denom, 0):\n        return np.inf\n\n    num_alpha = d.T @ Sigma @ c\n    alpha = num_alpha / denom\n    g = d - alpha * c\n\n    # 2. Define the orthogonal dynamics\n    # The problem specifies Q_j = I - c_j * (Sigma c_j)^T / (c_j^T Sigma c_j).\n    # Since Sigma is symmetric, (Sigma c_j)^T = c_j^T Sigma.\n    # The projection matrix P_j is c_j * (c_j^T Sigma) / (c_j^T Sigma c_j).\n    # In numpy, this is np.outer(c_j, c_j @ Sigma) / denom.\n    P = np.outer(c, c @ Sigma) / denom\n    Q = Id - P\n    \n    M = Q @ At\n\n    # 3. Compute the time-averaged noise\n    time_points = np.linspace(0.0, T, N)\n    integrand_values = []\n\n    for t in time_points:\n        # Evolve the orthogonal coefficient\n        # u(t) = exp(t * M) @ g\n        exp_tM = expm(t * M)\n        u_t = exp_tM @ g\n\n        # Calculate the instantaneous normalized squared residual noise\n        # (u(t)^T * Sigma * u(t)) / (c^T * Sigma * c)\n        numerator = u_t.T @ Sigma @ u_t\n        integrand_value = numerator / denom\n        integrand_values.append(integrand_value)\n\n    # Approximate the integral by the arithmetic mean\n    avg_noise = np.mean(integrand_values)\n    \n    return avg_noise\n\ndef solve():\n    \"\"\"\n    Solves the Mori-Zwanzig problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (\n            np.array([[-0.10, 1.00], [-4.00, -1.00]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([1.0, 0.5]),\n            5.0,\n            200\n        ),\n        # Test case 2\n        (\n            np.array([[-0.10, 1.00], [-4.00, -1.00]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([1.0, 0.0]),\n            5.0,\n            200\n        ),\n        # Test case 3\n        (\n            np.array([[-0.05, 10.0], [-0.10, -2.0]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([0.0, 1.0]),\n            4.0,\n            200\n        ),\n        # Test case 4\n        (\n            np.array([[-0.20, 0.80, 0.00], [-1.00, -0.50, 2.00], [0.00, -1.50, -0.30]]),\n            np.array([[2.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.5]]),\n            np.array([1.0, 0.2, 0.0]),\n            np.array([0.5, 0.5, 0.7]),\n            6.0,\n            300\n        )\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for A, Sigma, c1, c2, T, N in test_cases:\n        avg_noise_1 = calculate_average_noise(A, Sigma, c1, T, N)\n        avg_noise_2 = calculate_average_noise(A, Sigma, c2, T, N)\n        \n        # Decision rule: choose 1 if S1 is smaller or if they are equal within tolerance.\n        if avg_noise_1 - avg_noise_2 = tolerance:\n            results.append(1)\n        else:\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3438303"}, {"introduction": "前面的练习假设我们已知微观模型，而这个最后的实践则模拟了一个更贴近现实的场景：我们仅拥有某个集体变量的时间序列数据。这个练习 [@problem_id:3438307] 将引导你为记忆力构建一个线性模型，并使用现代的稀疏回归技术从数据中估计记忆核。这是将广义朗之万方程模型应用于复杂模拟数据的基本任务，体现了从理论到实际数据分析的跨越。", "problem": "考虑一个高维生物分子系统中的单个分析坐标 $q(t)$，该系统由 Mori-Zwanzig 投影算符形式描述，它为投影动力学导出了一个广义朗之万方程 (GLE)。在此描述中，与未解析自由度相关的摩擦记忆力由记忆核与分析速度的卷积表示。在实际计算中，对记忆核的一个常见参数化近似是将其表示为基函数的稀疏组合。你的任务是从第一性原理出发，推导该核函数系数的离散估计量，并实现一个稀疏回归程序，以从合成数据中恢复这些系数。\n\n出发点和物理背景：\n- 假设一个分析坐标 $q(t)$ 的一维 GLE，其记忆力 $F_{\\text{mem}}(t)$ 通过因果卷积依赖于分析速度 $\\dot{q}(t)$ 的历史。\n- 设记忆核近似为因果基函数的加权和。将这些基函数表示为 $\\{\\phi_i(t)\\}_{i=1}^p$，其中对于 $t0$ 时每个 $\\phi_i(t)$ 均为零，并且核近似是这些基函数与未知系数 $\\{c_i\\}$ 的线性组合。\n- 时间 $t$ 以皮秒 (ps) 为单位，坐标 $q(t)$ 以纳米 (nm) 为单位，速度 $\\dot{q}(t)$ 以 $\\text{nm}/\\text{ps}$ 为单位，记忆力 $F_{\\text{mem}}(t)$ 以皮牛 (pN) 为单位。如果涉及物理量，程序所要求的任何输出都必须符合这些单位。在此任务中，最终输出是无量纲的布尔值，因此输出不需要单位转换。\n\n推导要求：\n- 从 Mori-Zwanzig 形式所蕴含的因果结构和记忆力的卷积性质出发，推导一个离散时间表示，将 $F_{\\text{mem}}(t)$ 的采样值表示为未知系数 $\\{c_i\\}$ 和经过时间采样、基函数滤波后的速度的线性函数。使用黎曼和近似将时间积分转换为均匀网格（步长为 $\\Delta t$）上的离散和。\n- 展示这如何导出一个适合回归的线性系统，其中设计矩阵编码了每个基函数 $\\phi_i(t)$ 与采样速度 $\\dot{q}(t)$ 的卷积。\n- 构建一个基于最小绝对收缩和选择算子 (LASSO) 的稀疏回归估计量，该算子通过最小化一个凸目标函数来平衡数据保真度与系数 $\\{c_i\\}$ 上的 $\\ell_1$ 惩罚项。\n- 提供一个求解 LASSO 的算法策略，选择一种近端梯度法，如迭代软阈值算法 (ISTA)，并解释如何使用梯度的 Lipschitz 常数来选择一个稳定的步长。\n\n实现要求：\n- 实现一个程序，该程序：\n  1. 使用具有物理上合理的频率和振幅的三角函数，在指定区间内生成 $q(t)$ 和 $\\dot{q}(t)$ 的合成、确定性时间序列。\n  2. 构建一组因果基函数 $\\phi_i(t)$，并通过在均匀时间网格上将每个基函数与采样速度进行卷积来构建离散设计矩阵。\n  3. 使用已知的真实稀疏系数和设计矩阵合成 $F_{\\text{mem}}(t)$，可以选择不加噪声以分离估计精度。\n  4. 通过 ISTA 求解 LASSO 问题以估计系数，使用由设计矩阵的谱范数决定的步长。\n  5. 使用预测与真实记忆力信号之间的归一化均方根误差来评估重建质量；对于真实信号恒为零的情况，按惯例将误差视为零。报告一个布尔值，指示归一化误差是否低于指定的容差。\n\n测试套件规范：\n- 对所有测试用例使用以下通用的确定性轨迹：\n  - 时间网格：$t_n = n \\Delta t$，$n=0,1,\\dots,N-1$，其中 $\\Delta t = 0.01\\,\\text{ps}$，总时长 $T = 20\\,\\text{ps}$，因此 $N = \\lfloor T/\\Delta t \\rfloor + 1$。\n  - 坐标：$q(t) = 0.5\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.05\\,\\text{ps}^{-1}\\, t) + 0.3\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.20\\,\\text{ps}^{-1}\\, t) + 0.2\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.50\\,\\text{ps}^{-1}\\, t)$。\n  - 速度：$\\dot{q}(t)$ 是 $q(t)$ 的时间导数，根据上述表达式精确计算，单位为 $\\text{nm}/\\text{ps}$。\n- 基函数是因果指数函数，$\\phi_i(t) = e^{-t/\\tau_i}$（当 $t \\ge 0$）和 $0$（当 $t  0$），时间尺度 $\\tau_i$ 以皮秒为单位。\n- 在均匀网格上使用黎曼和因子 $\\Delta t$ 进行因果离散卷积来构建设计矩阵。\n\n定义四个测试用例，涵盖不同场景：\n1. 一般情况（稀疏，多时间尺度，良好分离）：\n   - 时间尺度：$\\tau = [0.1,\\,0.3,\\,1.0,\\,3.0,\\,7.0]\\,\\text{ps}$。\n   - 真实系数：$c = [0.0,\\,2.0,\\,-1.5,\\,0.0,\\,0.5]$（单位隐含在离散化中，使得 $F_{\\text{mem}}(t)$ 的单位为 $\\text{pN}$）。\n   - LASSO 参数：$\\lambda = 10^{-4}$。\n   - 成功容差：归一化均方根误差小于 $10^{-3}$。\n2. 边界情况（零核）：\n   - 时间尺度：$\\tau = [1.0,\\,2.0,\\,3.0,\\,4.0]\\,\\text{ps}$。\n   - 真实系数：$c = [0.0,\\,0.0,\\,0.0,\\,0.0]$。\n   - LASSO 参数：$\\lambda = 10^{-3}$。\n   - 容差：归一化误差小于 $10^{-8}$。\n3. 边缘情况（高度相关的基函数）：\n   - 时间尺度：$\\tau = [0.50,\\,0.51,\\,5.0]\\,\\text{ps}$。\n   - 真实系数：$c = [1.0,\\,0.0,\\,0.0]$。\n   - LASSO 参数：$\\lambda = 10^{-3}$。\n   - 容差：归一化误差小于 $10^{-3}$。\n4. 单基情况：\n   - 时间尺度：$\\tau = [2.0]\\,\\text{ps}$。\n   - 真实系数：$c = [3.0]$。\n   - LASSO 参数：$\\lambda = 10^{-4}$。\n   - 容差：归一化误差小于 $10^{-3}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，指示重建是否根据其容差成功（例如，\"[True,False,True,True]\"）。", "solution": "该问题要求推导并实现一种稀疏回归方法，用于估计广义朗之万方程 (GLE) 中记忆核的系数。下文将介绍问题的验证和后续解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **系统模型：** 一个由 Mori-Zwanzig 形式导出的 GLE 控制的单个分析坐标 $q(t)$。\n- **记忆力：** $F_{\\text{mem}}(t)$ 是记忆核 $K(t)$ 和分析速度 $\\dot{q}(t)$ 的因果卷积。\n- **核近似：** 记忆核近似为 $p$ 个因果基函数的稀疏线性组合，$K(t) \\approx \\sum_{i=1}^{p} c_i \\phi_i(t)$，其中当 $t  0$ 时 $\\phi_i(t) = 0$。\n- **离散化：** 使用均匀时间网格 $t_n = n \\Delta t$，积分由黎曼和近似。\n- **回归问题：** 使用最小绝对收缩和选择算子 (LASSO) 估计稀疏系数 $\\{c_i\\}$。\n- **求解器：** 使用迭代软阈值算法 (ISTA)。\n- **合成数据：**\n    - 时间网格：$\\Delta t = 0.01\\,\\text{ps}$，总时长 $T = 20\\,\\text{ps}$，$N = \\lfloor T/\\Delta t \\rfloor + 1 = 2001$。\n    - 坐标：$q(t) = 0.5\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.05\\,\\text{ps}^{-1}\\, t) + 0.3\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.20\\,\\text{ps}^{-1}\\, t) + 0.2\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.50\\,\\text{ps}^{-1}\\, t)$。\n    - 速度 $\\dot{q}(t)$：$q(t)$ 的精确时间导数。\n    - 基函数：$\\phi_i(t) = e^{-t/\\tau_i}$（当 $t \\ge 0$ 时）。\n- **测试用例：** 定义了四个具体的测试用例，它们具有不同的时间尺度集 $\\{\\tau_i\\}$、真实系数集 $\\{c_i\\}$、LASSO 参数 $\\lambda$ 和误差容差。\n- **评估指标：** 真实记忆力与重建记忆力之间的归一化均方根误差 (NRMSE)。根据 NRMSE 是否低于给定容差报告一个布尔值。对于零真实信号，误差定义为零。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础：** 该问题牢固地植根于统计力学和计算物理的既定原理。Mori-Zwanzig 形式、GLE、记忆核的概念及其使用基函数的近似，是研究复杂系统（尤其是在分子动力学中）的标准工具。使用像 LASSO 这样的稀疏回归技术从数据中识别此类模型是一个当前且有效的研究课题。\n- **适定性：** 该问题是适定的。它详细说明了一个明确的计算任务：给定一组输入（轨迹、基函数、真实系数），生成合成数据，然后应用指定算法（用于 LASSO 的 ISTA）来估计系数。LASSO 解的存在性和唯一性由其目标函数的凸性保证。\n- **客观性：** 该问题以精确、客观和量化的术语陈述。所有参数都已指定，成功的标准由一个数值容差明确定义。\n\n**步骤 3：结论与行动**\n\n问题陈述在科学上是合理的，内容是自洽的，并且是适定的。它提出了一个与分子动力学中指定主题直接相关的、非平凡但可行的计算任务。其中没有矛盾、模糊或事实错误。该问题被判定为 **有效**。我们可以继续进行求解。\n\n### 推导与算法设计\n\n**1. 从连续卷积到离散线性系统**\n\n记忆力 $F_{\\text{mem}}(t)$ 源于分析坐标与未解析自由度之间相互作用的历史。在 GLE 形式中，这表示为与记忆核 $K(t')$ 的卷积。考虑到物理相互作用的因果性，记忆核在负时间参数下为零，即当 $t'0$ 时 $K(t')=0$。因此，在时间 $t$ 的力为：\n$$ F_{\\text{mem}}(t) = \\int_{0}^{\\infty} K(\\tau) \\dot{q}(t-\\tau) d\\tau $$\n我们已知核函数由 $p$ 个基函数的线性组合近似，$K(\\tau) \\approx \\sum_{i=1}^{p} c_i \\phi_i(\\tau)$。将其代入积分并利用线性性质，我们得到：\n$$ F_{\\text{mem}}(t) = \\sum_{i=1}^{p} c_i \\left( \\int_{0}^{\\infty} \\phi_i(\\tau) \\dot{q}(t-\\tau) d\\tau \\right) $$\n括号中的每一项都是基函数 $\\phi_i$ 与速度 $\\dot{q}$ 的卷积。我们将速度记为 $v(t) = \\dot{q}(t)$，第 $i$ 个基的卷积积分记为 $X_i(t) = (\\phi_i * v)(t)$。然后表达式简化为：\n$$ F_{\\text{mem}}(t) = \\sum_{i=1}^{p} c_i X_i(t) $$\n这表明记忆力是未知系数 $\\{c_i\\}$ 的线性函数。为了将其转化为可在计算机上求解的系统，我们在时间上进行离散化。设 $t_n = n \\Delta t$，$n = 0, 1, \\dots, N-1$。我们在每个时间点 $t_n$ 对该方程求值。卷积积分由黎曼和近似：\n$$ X_i(t_n) = \\int_{0}^{t_n} \\phi_i(\\tau) v(t_n-\\tau) d\\tau \\approx \\sum_{k=0}^{n} \\phi_i(k\\Delta t) v(t_n - k\\Delta t) \\Delta t $$\n令 $F_{\\text{mem}, n} = F_{\\text{mem}}(t_n)$，$v_m = v(t_m)$，以及 $\\phi_{i, k} = \\phi_i(k\\Delta t)$。令离散卷积和的结果为 $(v * \\phi_i)_n = \\sum_{k=0}^{n} v_{n-k} \\phi_{i, k}$。那么特征的离散化表达式为 $X_{ni} = \\Delta t (v * \\phi_i)_n$。所有时间点的完整方程组可以写成矩阵形式：\n$$ \\mathbf{F}_{\\text{mem}} = \\mathbf{X} \\mathbf{c} $$\n其中 $\\mathbf{F}_{\\text{mem}}$ 是一个 $N$ 维的记忆力采样列向量 $[F_{\\text{mem}, 0}, \\dots, F_{\\text{mem}, N-1}]^T$，$\\mathbf{c}$ 是一个 $p$ 维的系数列向量 $[c_1, \\dots, c_p]^T$，而 $\\mathbf{X}$ 是一个 $N \\times p$ 的设计矩阵，其元素为 $X_{ni}$。$\\mathbf{X}$ 的每一列都是速度与其中一个基函数卷积后的时间序列。\n\n**2. 通过 LASSO 进行稀疏回归**\n\n问题指明核表示是稀疏的，意味着大多数系数 $c_i$ 为零。为了恢复这种结构，我们采用 LASSO 估计量，它通过最小化一个带惩罚的最小二乘目标函数来找到系数 $\\mathbf{c}$：\n$$ \\hat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c}} \\left\\{ \\frac{1}{2} \\| \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} \\|_2^2 + \\lambda \\|\\mathbf{c}\\|_1 \\right\\} $$\n第一项 $\\frac{1}{2} \\| \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} \\|_2^2$ 是数据保真度项，它促使解拟合观测数据。第二项 $\\lambda \\|\\mathbf{c}\\|_1 = \\lambda \\sum_{i=1}^p |c_i|$ 是 $\\ell_1$ 正则化惩罚项。该惩罚项通过将一些系数精确地驱动到零来促进稀疏性。参数 $\\lambda \\ge 0$ 控制数据保真度和稀疏性之间的权衡。\n\n**3. 迭代软阈值算法 (ISTA)**\n\nLASSO 目标函数是凸的，但由于 $\\ell_1$ 范数中的绝对值而并非处处可微。近端梯度法非常适合此类问题。ISTA 就是这样一种方法。它迭代地对目标函数的光滑部分执行梯度下降步骤，然后执行一个处理非光滑部分的“近端”步骤。\n\n目标函数为 $J(\\mathbf{c}) = f(\\mathbf{c}) + g(\\mathbf{c})$，其中 $f(\\mathbf{c}) = \\frac{1}{2} \\| \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} \\|_2^2$ 且 $g(\\mathbf{c}) = \\lambda \\|\\mathbf{c}\\|_1$。\n光滑部分的梯度为 $\\nabla f(\\mathbf{c}) = \\mathbf{X}^T (\\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}})$。\n第 $(k+1)$ 次迭代的 ISTA 更新规则为：\n$$ \\mathbf{c}^{(k+1)} = \\text{prox}_{\\alpha g}(\\mathbf{c}^{(k)} - \\alpha \\nabla f(\\mathbf{c}^{(k)})) $$\n其中 $\\alpha$ 是步长。对于按 $\\alpha\\lambda$ 缩放的 $\\ell_1$ 范数，其近端算子是逐元素的软阈值算子，$S_{\\kappa}(z) = \\text{sgn}(z) \\max(|z| - \\kappa, 0)$。\n完整的更新规则是：\n$$ \\mathbf{c}^{(k+1)} = S_{\\alpha\\lambda} \\left( \\mathbf{c}^{(k)} - \\alpha \\mathbf{X}^T (\\mathbf{X}\\mathbf{c}^{(k)} - \\mathbf{F}_{\\text{mem}}) \\right) $$\n\n为保证收敛，步长 $\\alpha$ 的选择必须满足 $0  \\alpha  2/L$，其中 $L$ 是梯度 $\\nabla f$ 的 Lipschitz 常数。该 Lipschitz 常数是 Hessian 矩阵 $\\nabla^2 f(\\mathbf{c}) = \\mathbf{X}^T\\mathbf{X}$ 的最大特征值（谱范数）。它由 $L = \\lambda_{\\max}(\\mathbf{X}^T\\mathbf{X}) = \\|\\mathbf{X}\\|_2^2$ 给出，其中 $\\|\\mathbf{X}\\|_2$ 是 $\\mathbf{X}$ 的谱范数（其最大奇异值）。一个安全且标准的选择是 $\\alpha = 1/L$。\n\n**4. 评估**\n\n从 ISTA 获得估计系数 $\\hat{\\mathbf{c}}$ 后，记忆力被重建为 $\\hat{\\mathbf{F}}_{\\text{mem}} = \\mathbf{X}\\hat{\\mathbf{c}}$。重建的质量通过归一化均方根误差 (NRMSE) 来量化：\n$$ \\text{NRMSE} = \\frac{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} (F_{\\text{mem}, n} - \\hat{F}_{\\text{mem}, n})^2}}{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} F_{\\text{mem}, n}^2}} = \\frac{\\|\\mathbf{F}_{\\text{mem}} - \\hat{\\mathbf{F}}_{\\text{mem}}\\|_2}{\\|\\mathbf{F}_{\\text{mem}}\\|_2} $$\n按照规定，如果分母为零（即 $\\mathbf{F}_{\\text{mem}} = \\mathbf{0}$），则 NRMSE 被视为零。如果一个测试用例的 NRMSE 低于指定的容差，则该用例成功。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mori-Zwanzig memory kernel reconstruction problem for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General sparse case\n        {\n            \"taus\": [0.1, 0.3, 1.0, 3.0, 7.0],\n            \"c_true\": [0.0, 2.0, -1.5, 0.0, 0.5],\n            \"lambda\": 1e-4,\n            \"tolerance\": 1e-3,\n        },\n        # Case 2: Zero kernel\n        {\n            \"taus\": [1.0, 2.0, 3.0, 4.0],\n            \"c_true\": [0.0, 0.0, 0.0, 0.0],\n            \"lambda\": 1e-3,\n            \"tolerance\": 1e-8,\n        },\n        # Case 3: Highly correlated basis functions\n        {\n            \"taus\": [0.50, 0.51, 5.0],\n            \"c_true\": [1.0, 0.0, 0.0],\n            \"lambda\": 1e-3,\n            \"tolerance\": 1e-3,\n        },\n        # Case 4: Single-basis case\n        {\n            \"taus\": [2.0],\n            \"c_true\": [3.0],\n            \"lambda\": 1e-4,\n            \"tolerance\": 1e-3,\n        },\n    ]\n\n    results = []\n\n    # Common parameters for all test cases\n    dt = 0.01  # ps\n    T = 20.0   # ps\n    N = int(T / dt) + 1\n    t = np.linspace(0, T, N)\n\n    # Generate reference trajectory q(t) and velocity v(t) = dq/dt\n    w1, w2, w3 = 2 * np.pi * 0.05, 2 * np.pi * 0.20, 2 * np.pi * 0.50\n    a1, a2, a3 = 0.5, 0.3, 0.2\n    \n    # q(t) in nm\n    q_t = a1 * np.sin(w1 * t) + a2 * np.sin(w2 * t) + a3 * np.sin(w3 * t) \n    # v(t) in nm/ps\n    v_t = a1 * w1 * np.cos(w1 * t) + a2 * w2 * np.cos(w2 * t) + a3 * w3 * np.cos(w3 * t)\n\n    def soft_threshold(z, kappa):\n        \"\"\"Soft-thresholding operator for ISTA.\"\"\"\n        return np.sign(z) * np.maximum(np.abs(z) - kappa, 0)\n\n    for case in test_cases:\n        taus = case[\"taus\"]\n        c_true = np.array(case[\"c_true\"])\n        lamb = case[\"lambda\"]\n        tolerance = case[\"tolerance\"]\n\n        p = len(taus)\n        \n        # 1. Construct the design matrix X by convolving velocity with basis functions\n        X = np.zeros((N, p))\n        for i in range(p):\n            # Causal exponential basis function\n            phi = np.exp(-t / taus[i])\n            # Discrete convolution using Riemann sum factor dt\n            # (phi * v)(t_n) approx sum_{k=0 to n} phi(k*dt)v(t_n-k*dt)dt\n            convolution_result = np.convolve(v_t, phi, mode=\"full\")[:N]\n            X[:, i] = convolution_result * dt\n\n        # 2. Synthesize the ground-truth memory force F_mem (in pN)\n        F_mem = X @ c_true\n\n        # 3. Solve for coefficients using ISTA\n        # Determine stable step size from Lipschitz constant\n        # L = ||X^T X||_2 = ||X||_2^2 (spectral norm)\n        L = np.linalg.norm(X, ord=2) ** 2\n        # A condition number check to handle the case of X being a zero matrix\n        if L == 0:\n            alpha = 1.0\n        else:\n            alpha = 1.0 / L\n\n        # ISTA implementation\n        c_est = np.zeros(p)\n        n_iterations = 10000  # Number of iterations for convergence\n        for _ in range(n_iterations):\n            gradient = X.T @ (X @ c_est - F_mem)\n            c_update = c_est - alpha * gradient\n            c_est = soft_threshold(c_update, alpha * lamb)\n            \n        # 4. Evaluate reconstruction quality\n        F_pred = X @ c_est\n        \n        # Calculate normalized root-mean-square error (NRMSE)\n        norm_F_mem = np.linalg.norm(F_mem)\n        \n        if norm_F_mem == 0:\n            # Per problem spec, if ground truth is zero, NRMSE is zero if prediction is also zero.\n            # ISTA with c_true=0 will yield c_est=0, so F_pred=0 and error is zero.\n            nrmse = 0.0\n        else:\n            error = F_pred - F_mem\n            nrmse = np.linalg.norm(error) / norm_F_mem\n            \n        # Record if the reconstruction was successful\n        results.append(nrmse  tolerance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3438307"}]}