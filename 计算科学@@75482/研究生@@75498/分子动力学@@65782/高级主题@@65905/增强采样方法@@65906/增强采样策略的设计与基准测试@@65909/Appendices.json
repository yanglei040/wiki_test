{"hands_on_practices": [{"introduction": "伞形采样是增强采样方法的基石，但成功的模拟并非偶然，而是需要精心规划以平衡精度和计算成本。本练习将带您亲手实践如何定量设计一维伞形采样模拟，迫使您在精度和计算资源之间做出权衡。通过计算实现目标不确定性所需的最小窗口数，您将掌握伞形采样设计中的核心考量因素，例如窗口间距、约束力常数和每个窗口的采样时间[@problem_id:3410749]。", "problem": "考虑在分子动力学 (MD) 模拟中使用伞形采样来估算沿集体变量 (CV) $s$ 的一维平均力势 $F(s)$。需要覆盖的 CV 域是闭区间 $[s_{\\min}, s_{\\max}]$，其中 $s_{\\min} = 0\\,\\mathrm{nm}$ 且 $s_{\\max} = 2\\,\\mathrm{nm}$。每个伞形窗采用谐波偏置 $U_{i}(s) = \\frac{1}{2} k (s - s_{i})^{2}$，其中所有窗口共用一个力常数 $k$，且窗口中心 $\\{ s_{i} \\}$ 等间距分布，间距为 $\\Delta s$。模拟在绝对温度 $T$ 下进行。\n\n假设以下具有物理动机的简化，这些简化构成了一个一致的设计基线：\n- 在任何窗口中心 $s_{i}$ 附近，无偏置自由能 $F(s)$ 相对于施加的谐波曲率变化缓慢，因此窗口 $i$ 中 $s$ 的有偏分布近似为高斯分布，其方差为 $\\sigma^{2} = k_{B} T / k$，其中 $k_{B}$ 是玻尔兹曼常数。\n- 每个窗口中的时间序列 $s(t)$ 是平稳的，其积分自相关时间 (IAT) 为 $\\tau_{\\mathrm{int}}$。对于给定窗口中持续时间为 $t_{w}$ 的轨迹，统计独立样本的有效数量为 $N_{\\mathrm{eff}} \\approx t_{w}/(2 \\tau_{\\mathrm{int}})$。\n- 设计要求相邻窗口之间有稳定的重叠。使用两个等方差高斯有偏密度之间的 Bhattacharyya 系数 $O$ 作为定量重叠度量。对于两个间隔为 $\\Delta s$ 且方差为 $\\sigma^{2}$ 的相邻窗口，其重叠为 $O(\\Delta s) = \\exp\\!\\left(-\\Delta s^{2}/(8 \\sigma^{2})\\right)$。\n- 使用 delta 方法近似处理重叠位置处无偏置自由能的统计不确定度，其中 $F(s) = -k_{B} T \\ln P(s)$，且重叠区域的有效样本数与 $N_{\\mathrm{ov}} \\approx 2 N_{\\mathrm{eff}} O(\\Delta s)$ 成比例。通过强制要求 $\\mathrm{Var}(F) \\approx (k_{B} T)^{2}/N_{\\mathrm{ov}} \\leq \\delta F^{2}$ 来设定重叠区域的最坏情况下自由能不确定度目标为 $\\delta F$。\n\n给定参数值 $T = 300\\,\\mathrm{K}$、$k = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$、$t_{w} = 60\\,\\mathrm{ns}$ 和 $\\tau_{\\mathrm{int}} = 0.15\\,\\mathrm{ns}$，并设定目标自由能不确定度为 $\\delta F = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，请根据上述设计模型，确定覆盖区间 $[s_{\\min}, s_{\\max}]$ 所需的最小整数窗口数 $M$。使用 $k_{B} = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$，并假设窗口中心从 $s_{\\min}$ 开始到 $s_{\\max}$ 结束，等间距分布，间距为 $\\Delta s$，因此 $M = \\left\\lceil \\frac{s_{\\max} - s_{\\min}}{\\Delta s} \\right\\rceil + 1$。将最终答案以无量纲整数的形式报告。如果中间步骤需要四舍五入，请保留足够的精度以确保最终整数的正确性，并报告不带任何单位的整数。\n\n计算出 $M$ 后，根据推导出的表达式和假设，简要解释窗口数 $M$、力常数 $k$ 和每个窗口的采样时间 $t_{w}$ 之间的权衡关系，无需更改您计算出的 $M$ 值。", "solution": "用户希望确定跨越集体变量 (CV) 范围 $[s_{\\min}, s_{\\max}]$ 所需的最小整数伞形窗口数 $M$，同时确保相邻窗口之间重叠点处的自由能估计值的最大统计不确定度为 $\\delta F$。\n\n该问题提供了一组具有物理动机的假设，将模拟参数与此不确定度目标联系起来。问题的核心是求解这些方程，以获得窗口中心之间的最大允许间距 $\\Delta s$，然后使用该值计算最小窗口数 $M$。\n\n首先，我们列出给定的参数和关系：\n- CV 范围：$s_{\\min} = 0\\,\\mathrm{nm}$ 到 $s_{\\max} = 2\\,\\mathrm{nm}$。总长度为 $L = s_{\\max} - s_{\\min} = 2\\,\\mathrm{nm}$。\n- 温度：$T = 300\\,\\mathrm{K}$。\n- 伞形力常数：$k = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$。\n- 每个窗口的轨迹持续时间：$t_{w} = 60\\,\\mathrm{ns}$。\n- 积分自相关时间：$\\tau_{\\mathrm{int}} = 0.15\\,\\mathrm{ns}$。\n- 目标自由能不确定度：$\\delta F = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 玻尔兹曼常数：$k_{B} = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n解题过程遵循以下步骤：\n1.  使用不确定度约束，找到相邻有偏分布之间所需的最小重叠 $O_{\\min}$。\n2.  使用重叠公式 $O(\\Delta s)$，找到与 $O_{\\min}$ 对应的最大允许窗口间距 $\\Delta s_{\\max}$。\n3.  计算以间距 $\\Delta s_{\\max}$ 覆盖总范围 $L$ 所需的最小窗口数 $M$。\n\n步骤 1：确定所需的最小重叠 $O_{\\min}$。\n自由能方差的约束条件为：\n$$\\mathrm{Var}(F) \\leq \\delta F^{2}$$\n问题给出了重叠区域方差的近似公式：\n$$\\mathrm{Var}(F) \\approx \\frac{(k_{B} T)^{2}}{N_{\\mathrm{ov}}}$$\n其中 $N_{\\mathrm{ov}} \\approx 2 N_{\\mathrm{eff}} O(\\Delta s)$ 是重叠区域中的有效样本数。\n将这些结合起来，我们得到：\n$$\\frac{(k_{B} T)^{2}}{2 N_{\\mathrm{eff}} O(\\Delta s)} \\leq \\delta F^{2}$$\n为了最小化窗口数，我们需要最大化间距 $\\Delta s$。由于 $O(\\Delta s)$ 是 $\\Delta s$ 的递减函数，最大化 $\\Delta s$ 对应于最小化重叠 $O(\\Delta s)$。因此，我们应该在此不等式的边界处满足条件，这定义了所需的最小重叠 $O_{\\min}$：\n$$O_{\\min} = \\frac{(k_{B} T)^{2}}{2 N_{\\mathrm{eff}} \\delta F^{2}}$$\n我们首先计算必要的中间量。\n热能为：\n$$k_{B} T = (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}) \\times (300\\,\\mathrm{K}) = 2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$$\n每个窗口的独立样本有效数量为：\n$$N_{\\mathrm{eff}} \\approx \\frac{t_{w}}{2 \\tau_{\\mathrm{int}}} = \\frac{60\\,\\mathrm{ns}}{2 \\times 0.15\\,\\mathrm{ns}} = \\frac{60}{0.3} = 200$$\n现在我们可以计算 $O_{\\min}$：\n$$O_{\\min} = \\frac{(2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}}{2 \\times 200 \\times (0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}} = \\frac{6.221727...}{2 \\times 200 \\times 0.0625} = \\frac{6.221727...}{25} \\approx 0.248869$$\n\n步骤 2：确定最大允许间距 $\\Delta s_{\\max}$。\n重叠由两个高斯分布的 Bhattacharyya 系数给出：\n$$O(\\Delta s) = \\exp\\left(-\\frac{\\Delta s^{2}}{8 \\sigma^{2}}\\right)$$\n其中 $\\sigma^{2} = k_{B} T / k$ 是每个窗口中有偏分布的方差。为了找到最大间距 $\\Delta s_{\\max}$，我们令 $O(\\Delta s_{\\max}) = O_{\\min}$：\n$$\\exp\\left(-\\frac{\\Delta s_{\\max}^{2}}{8 \\sigma^{2}}\\right) = O_{\\min}$$\n求解 $\\Delta s_{\\max}$：\n$$-\\frac{\\Delta s_{\\max}^{2}}{8 \\sigma^{2}} = \\ln(O_{\\min})$$\n$$\\Delta s_{\\max}^{2} = -8 \\sigma^{2} \\ln(O_{\\min}) = 8 \\sigma^{2} \\ln\\left(\\frac{1}{O_{\\min}}\\right)$$\n$$\\Delta s_{\\max} = \\sqrt{8 \\sigma^{2} \\ln\\left(\\frac{1}{O_{\\min}}\\right)}$$\n首先，我们计算方差 $\\sigma^2$：\n$$\\sigma^{2} = \\frac{k_{B} T}{k} = \\frac{2.4943387854\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}}{1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}} \\approx 0.0020786\\,\\mathrm{nm}^{2}$$\n现在，我们可以计算 $\\Delta s_{\\max}$：\n$$\\Delta s_{\\max} = \\sqrt{8 \\times (0.0020786\\,\\mathrm{nm}^{2}) \\times \\ln\\left(\\frac{1}{0.248869}\\right)} = \\sqrt{0.016629\\,\\mathrm{nm}^{2} \\times \\ln(4.018177...)}$$\n$$\\Delta s_{\\max} = \\sqrt{0.016629\\,\\mathrm{nm}^{2} \\times 1.390812} = \\sqrt{0.0231365\\,\\mathrm{nm}^{2}} \\approx 0.152107\\,\\mathrm{nm}$$\n\n步骤 3：计算最小窗口数 $M$。\n问题指定了用间距 $\\Delta s$ 覆盖范围 $L = s_{\\max} - s_{\\min} = 2\\,\\mathrm{nm}$ 所需的窗口数 $M$ 的公式：\n$$M = \\left\\lceil \\frac{s_{\\max} - s_{\\min}}{\\Delta s} \\right\\rceil + 1$$\n为了找到最小整数 $M$，我们必须使用最大可能间距 $\\Delta s_{\\max}$：\n$$M = \\left\\lceil \\frac{2\\,\\mathrm{nm}}{0.152107\\,\\mathrm{nm}} \\right\\rceil + 1$$\n$$M = \\lceil 13.1486 \\rceil + 1 = 14 + 1 = 15$$\n所需的最小整数窗口数为 15。\n\n关于权衡关系的简要说明：\n上面推导出的关系阐明了设计伞形采样模拟时的关键权衡关系。窗口数 $M$ 主要由最大允许间距 $\\Delta s_{\\max}$ 决定，$M$ 与 $\\Delta s_{\\max}$ 成反比。\n- 与力常数 $k$ 的权衡：间距由 $\\Delta s_{\\max} = \\sqrt{8(k_B T/k) \\ln(1/O_{\\min})}$ 给出，因此 $\\Delta s_{\\max} \\propto 1/\\sqrt{k}$。更强的谐波约束（更大的 $k$）导致更窄的采样分布（更小的 $\\sigma^2$）。为了保持窗口之间必要的重叠，它们必须放置得更近（更小的 $\\Delta s_{\\max}$），从而增加了总窗口数 $M$。\n- 与采样时间 $t_{w}$ 的权衡：间距通过最小重叠 $O_{\\min} = \\frac{(k_B T)^2}{2(t_w/2\\tau_{int}) \\delta F^2} \\propto 1/t_w$ 依赖于采样时间。每个窗口更长的模拟时间 $t_w$ 会增加有效样本数 $N_{\\mathrm{eff}}$，这意味着只需要较小的重叠度 $O_{\\min}$ 就足以达到目标精度 $\\delta F$。较小的 $O_{\\min}$ 允许更大的间距 $\\Delta s_{\\max}$（因为 $\\Delta s_{\\max} \\propto \\sqrt{\\ln(1/O_{\\min})}$）。因此，增加 $t_w$ 会减少所需的窗口数 $M$。这代表了一个基本的权衡：在固定的 $k$ 和 $\\delta F$ 下，可以运行更多窗口但每个窗口时间更短，或者运行更少窗口但每个窗口时间更长，以在最终的 PMF 中达到相同的整体质量。", "answer": "$$\\boxed{15}$$", "id": "3410749"}, {"introduction": "现实世界中的科学问题通常是多维的，其自由能形貌复杂且各向异性，在不同方向上具有截然不同的特征。在这种情况下，采用朴素的均匀采样网格效率极低，而根据自由能表面的局部曲率调整窗口间距，则可以显著减少所需的模拟次数。在本练习中，您将通过编程实现一种算法，构建一个高效的各向异性伞形采样网格[@problem_id:3410778]，并将其与均匀网格进行性能比较，从而具体理解智能网格设计如何节省大量的计算资源。", "problem": "设计一个完整、可运行的程序，在一个多维二次自由能形貌中构建一个伞形采样窗口的各向异性网格，使得由 Kullback–Leibler (KL) 散度衡量的相邻窗口之间的重叠度，沿每个坐标轴都均衡化至一个指定的目标值。然后，将该网格的效率与一个均匀（各向同性）网格进行基准比较，该均匀网格使用单一间距，该间距的选择是为了满足最差轴上的相同 KL 约束。所有计算都必须在无量纲的约化单位中进行表述和求解。\n\n假设一个固定温度下的正则系综，并考虑一个底层的二次势能\n$$\nU(\\mathbf{x})=\\tfrac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{C}\\,\\mathbf{x},\n$$\n其中 $\\mathbf{C}$ 是一个对角、半正定的曲率矩阵，其对角线元素为 $c_i \\ge 0$，$i \\in \\{1,\\dots,d\\}$ 且 $\\mathbf{x} \\in \\mathbb{R}^d$。一个中心位于 $\\boldsymbol{\\mu}\\in\\mathbb{R}^d$ 的伞形采样窗口施加一个谐波偏置\n$$\nW_{\\boldsymbol{\\mu}}(\\mathbf{x})=\\tfrac{1}{2}\\,(\\mathbf{x}-\\boldsymbol{\\mu})^{\\top}\\mathbf{K}\\,(\\mathbf{x}-\\boldsymbol{\\mu}),\n$$\n其中 $\\mathbf{K}$ 是对角矩阵，其元素为 $k_i>0$。在约化单位中令 $\\beta=1$，因此所有量都是无量纲的。\n\n基本和建模假设：\n- 窗口 $\\boldsymbol{\\mu}$ 中的偏置分布是高斯分布，因为二次型之和仍是二次型。其协方差为 $\\boldsymbol{\\Sigma}=(\\mathbf{C}+\\mathbf{K})^{-1}$，均值为 $\\mathbf{m}=(\\mathbf{C}+\\mathbf{K})^{-1}\\mathbf{K}\\,\\boldsymbol{\\mu}$。\n- 两个具有相同协方差 $\\boldsymbol{\\Sigma}$、均值分别为 $\\mathbf{m}_a$ 和 $\\mathbf{m}_b$ 的 $d$ 维高斯分布之间的 Kullback–Leibler (KL) 散度为\n$$\nD_{\\mathrm{KL}}=\\tfrac{1}{2}(\\mathbf{m}_a-\\mathbf{m}_b)^{\\top}\\boldsymbol{\\Sigma}^{-1}(\\mathbf{m}_a-\\mathbf{m}_b).\n$$\n\n网格设计目标：\n- 考虑一个窗口中心的张量积网格，其间距仅沿坐标轴方向。将沿轴 $i$ 的半程范围记为 $L_i>0$，因此要覆盖的区域为 $\\prod_{i=1}^d[-L_i,L_i]$。\n- 对于仅沿轴 $i$ 相差一个位移 $\\delta_i$ 的相邻窗口，将 KL 散度均衡化至一个指定的目标值 $D>0$。由于 $\\mathbf{C}$ 和 $\\mathbf{K}$ 均为对角矩阵，单轴相邻窗口的 KL 条件简化为\n$$\nD=\\tfrac{1}{2}\\,\\delta_i^2\\,\\frac{k_i^2}{c_i+k_i}.\n$$\n- 求解此约束，以获得可均衡化重叠度的各向异性每轴网格间距 $\\delta_i$：\n$$\n\\delta_i=\\sqrt{2D\\,\\frac{(c_i+k_i)}{k_i^2}}.\n$$\n\n效率基准测试：\n- 对于各向异性网格，沿轴 $i$ 的窗口数量为\n$$\nn_i=\\max\\Big(1,\\,\\left\\lfloor \\frac{2L_i}{\\delta_i}\\right\\rfloor + 1\\Big),\n$$\n总窗口数量为 $N_{\\mathrm{aniso}}=\\prod_{i=1}^d n_i$。\n- 对于一个在所有轴上使用单一间距 $\\delta_{\\mathrm{uni}}$ 的均匀（各向同性）网格，选择\n$$\n\\delta_{\\mathrm{uni}}=\\min_{i} \\delta_i\n$$\n以满足最严格轴上的 KL 约束，并计算\n$$\nn^{\\mathrm{uni}}_i=\\max\\Big(1,\\,\\left\\lfloor \\frac{2L_i}{\\delta_{\\mathrm{uni}}}\\right\\rfloor + 1\\Big),\\quad N_{\\mathrm{uni}}=\\prod_{i=1}^d n^{\\mathrm{uni}}_i.\n$$\n- 将效率比定义为\n$$\n\\mathcal{R}=\\frac{N_{\\mathrm{uni}}}{N_{\\mathrm{aniso}}}.\n$$\n\n编程任务：\n- 实现以上公式，为下面测试套件中的每个测试用例计算 $\\delta_i$、$n_i$、$N_{\\mathrm{aniso}}$、$\\delta_{\\mathrm{uni}}$、$n^{\\mathrm{uni}}_i$、$N_{\\mathrm{uni}}$ 和 $\\mathcal{R}$。\n- 对每个测试用例，返回三元组 $[N_{\\mathrm{aniso}},N_{\\mathrm{uni}},\\mathcal{R}]$，其中 $\\mathcal{R}$ 四舍五入到六位小数。\n\n测试套件：\n- 用例 $1$（一维理想情况）：$d=1$, $\\mathbf{C}=\\operatorname{diag}([1.0])$, $\\mathbf{K}=\\operatorname{diag}([9.0])$, $\\mathbf{L}=[3.0]$, $D=0.5$。\n- 用例 $2$（二维各向异性）：$d=2$, $\\mathbf{C}=\\operatorname{diag}([1.0,0.25])$, $\\mathbf{K}=\\operatorname{diag}([4.0,1.0])$, $\\mathbf{L}=[2.0,3.0]$, $D=0.5$。\n- 用例 $3$（边界情况，一个轴上的刚度极弱）：$d=2$, $\\mathbf{C}=\\operatorname{diag}([0.0,0.0])$, $\\mathbf{K}=\\operatorname{diag}([1\\times 10^{-6},100.0])$, $\\mathbf{L}=[1.0,1.0]$, $D=0.5$。\n- 用例 $4$（三维混合曲率）：$d=3$, $\\mathbf{C}=\\operatorname{diag}([2.0,0.5,0.5])$, $\\mathbf{K}=\\operatorname{diag}([3.0,3.0,0.5])$, $\\mathbf{L}=[2.0,2.0,1.0]$, $D=0.2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，格式为列表的列表，不含空格。每个内部列表的形式为 $[N_{\\mathrm{aniso}},N_{\\mathrm{uni}},\\mathcal{R}]$，且 $\\mathcal{R}$ 四舍五入到六位小数。例如，一个有效的输出行格式如下\n$$\n[[a_1,b_1,r_1],[a_2,b_2,r_2],[a_3,b_3,r_3],[a_4,b_4,r_4]]\n$$\n其中每个 $a_j$ 和 $b_j$ 为整数，每个 $r_j$ 为四舍五入到六位的小数。", "solution": "问题陈述已经过严格审查并被确定为有效。它在科学上基于统计力学和计算化学的原理，提法严谨，提供了所有必要信息，且其表述是客观的。其基础模型基于二次势和高斯分布，是分析诸如伞形采样等增强采样方法的标准且易于解析处理的框架。所有提供的公式都与此模型一致。因此，我们可以继续进行求解。\n\n目标是为一个由二次势能面描述的多维系统设计一个各向异性的伞形采样窗口网格并进行基准测试。设计准则是将由 Kullback–Leibler (KL) 散度量化的、相邻窗口沿每个坐标轴的重叠度进行均衡化。这与一个朴素的均匀网格设计进行比较。\n\n系统的底层势能由一个二次型给出：\n$$\nU(\\mathbf{x})=\\tfrac{1}{2}\\,\\mathbf{x}^{\\top}\\mathbf{C}\\,\\mathbf{x}\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^d$ 是状态向量，$\\mathbf{C}$ 是一个对角半正定矩阵，其元素为 $c_i \\ge 0$。伞形采样为每个以 $\\boldsymbol{\\mu}$ 为中心的窗口引入一个谐波偏置势：\n$$\nW_{\\boldsymbol{\\mu}}(\\mathbf{x})=\\tfrac{1}{2}\\,(\\mathbf{x}-\\boldsymbol{\\mu})^{\\top}\\mathbf{K}\\,(\\mathbf{x}-\\boldsymbol{\\mu})\n$$\n其中 $\\mathbf{K}$ 是一个对角矩阵，其正元素为 $k_i > 0$。在逆温 $\\beta=1$ 的约化单位中，一个窗口内的总势能为 $U_{\\text{biased}}(\\mathbf{x}) = U(\\mathbf{x}) + W_{\\boldsymbol{\\mu}}(\\mathbf{x})$。由于这是二次型的和，所得的平衡概率分布 $p(\\mathbf{x}) \\propto \\exp(-U_{\\text{biased}}(\\mathbf{x}))$ 是一个高斯分布。\n\n如问题陈述中所给，以 $\\boldsymbol{\\mu}$ 为中心的窗口的偏置分布是一个高斯分布，其协方差为 $\\boldsymbol{\\Sigma}=(\\mathbf{C}+\\mathbf{K})^{-1}$，均值为 $\\mathbf{m}=(\\mathbf{C}+\\mathbf{K})^{-1}\\mathbf{K}\\,\\boldsymbol{\\mu}$。位于中心 $\\boldsymbol{\\mu}_a$ 和 $\\boldsymbol{\\mu}_b$ 的两个此类分布之间的 KL 散度简化为：\n$$\nD_{\\mathrm{KL}}=\\tfrac{1}{2}(\\mathbf{m}_a-\\mathbf{m}_b)^{\\top}\\boldsymbol{\\Sigma}^{-1}(\\mathbf{m}_a-\\mathbf{m}_b)\n$$\n对于沿轴 $i$ 相邻、相隔一个位移 $\\delta_i$ 的两个窗口，这得出了每轴的约束条件：\n$$\nD=\\tfrac{1}{2}\\,\\delta_i^2\\,\\frac{k_i^2}{c_i+k_i}\n$$\n其中 $D$ 是目标 KL 散度。\n\n问题的核心在于为每个测试用例实现以下计算步骤。\n\n**1. 各向异性网格的构建**\n\n沿每个轴 $i$ 的间距 $\\delta_i$ 是通过求解关于 $\\delta_i$ 的 KL 散度约束来确定的。这确保了相邻窗口之间的统计重叠沿各自的轴是均匀的，从而使网格密度适应势能的局部刚度。\n$$\n\\delta_i=\\sqrt{2D\\,\\frac{(c_i+k_i)}{k_i^2}}\n$$\n沿轴 $i$ 待采样的区域为 $[-L_i, L_i]$，总长度为 $2L_i$。使用间距 $\\delta_i$ 覆盖此区域所需的窗口数量 $n_i$ 由区间数加一给出，最少为一个窗口。\n$$\nn_i=\\max\\Big(1,\\,\\left\\lfloor \\frac{2L_i}{\\delta_i}\\right\\rfloor + 1\\Big)\n$$\n各向异性网格的总窗口数，作为一维网格的张量积，是每轴窗口数的乘积。\n$$\nN_{\\mathrm{aniso}}=\\prod_{i=1}^d n_i\n$$\n\n**2. 均匀（各向同性）网格的构建**\n\n为了进行基准测试，构建一个均匀网格。为确保所有轴上的 KL 散度约束都得到满足或更严格（即重叠度至少与目标一样好），均匀网格的间距必须选择为所有计算出的各向异性间距中的最小值。这是因为较小的间距对应于较小的 KL 散度（即更大的重叠）。\n$$\n\\delta_{\\mathrm{uni}}=\\min_{i} \\delta_i\n$$\n然后将这个单一间距应用于所有轴。使用这个均匀间距计算沿每个轴 $i$ 的窗口数量 $n^{\\mathrm{uni}}_i$。\n$$\nn^{\\mathrm{uni}}_i=\\max\\Big(1,\\,\\left\\lfloor \\frac{2L_i}{\\delta_{\\mathrm{uni}}}\\right\\rfloor + 1\\Big)\n$$\n均匀网格的总窗口数是这些计数的乘积。\n$$\nN_{\\mathrm{uni}}=\\prod_{i=1}^d n^{\\mathrm{uni}}_i\n$$\n\n**3. 效率基准测试**\n\n各向异性网格相对于均匀网格的效率定义为总窗口数的比率。大于 1 的比率表示各向异性网格需要更少的窗口，因此计算效率更高。\n$$\n\\mathcal{R}=\\frac{N_{\\mathrm{uni}}}{N_{\\mathrm{aniso}}}\n$$\n\n这些公式将系统地应用于每个提供的测试用例。然后将包含三元组 $[N_{\\mathrm{aniso}}, N_{\\mathrm{uni}}, \\mathcal{R}]$ 的结果进行汇编。例如，对于用例 2（$d=2$, $\\mathbf{C}=\\operatorname{diag}([1.0, 0.25])$, $\\mathbf{K}=\\operatorname{diag}([4.0, 1.0])$, $\\mathbf{L}=[2.0, 3.0]$, $D=0.5$），计算过程如下：\n- 轴 1：$c_1=1.0, k_1=4.0, L_1=2.0$。间距 $\\delta_1 = \\sqrt{2(0.5)(1.0+4.0)/4.0^2} = \\sqrt{5/16} \\approx 0.559017$。窗口数 $n_1 = \\lfloor 2(2.0)/0.559017\\rfloor + 1 = 8$。\n- 轴 2：$c_2=0.25, k_2=1.0, L_2=3.0$。间距 $\\delta_2 = \\sqrt{2(0.5)(0.25+1.0)/1.0^2} = \\sqrt{1.25} \\approx 1.118034$。窗口数 $n_2 = \\lfloor 2(3.0)/1.118034\\rfloor + 1 = 6$。\n- 各向异性总窗口数：$N_{\\mathrm{aniso}} = n_1 \\times n_2 = 8 \\times 6 = 48$。\n- 均匀网格间距：$\\delta_{\\mathrm{uni}} = \\min(\\delta_1, \\delta_2) = \\delta_1 \\approx 0.559017$。\n- 均匀网格窗口数：$n^{\\mathrm{uni}}_1 = \\lfloor 2(2.0)/0.559017\\rfloor + 1 = 8$。$n^{\\mathrm{uni}}_2 = \\lfloor 2(3.0)/0.559017\\rfloor + 1 = 11$。\n- 均匀网格总窗口数：$N_{\\mathrm{uni}} = 8 \\times 11 = 88$。\n- 效率比：$\\mathcal{R} = 88 / 48 \\approx 1.833333$。\n这个过程是通用的，并将被编码以解决所有测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and benchmarks anisotropic vs. uniform umbrella sampling grids.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (d=1, C=[1.0], K=[9.0], L=[3.0], D=0.5)\n        (np.array([1.0]), np.array([9.0]), np.array([3.0]), 0.5),\n        # Case 2 (d=2, C=[1.0, 0.25], K=[4.0, 1.0], L=[2.0, 3.0], D=0.5)\n        (np.array([1.0, 0.25]), np.array([4.0, 1.0]), np.array([2.0, 3.0]), 0.5),\n        # Case 3 (d=2, C=[0.0, 0.0], K=[1e-6, 100.0], L=[1.0, 1.0], D=0.5)\n        (np.array([0.0, 0.0]), np.array([1.0e-6, 100.0]), np.array([1.0, 1.0]), 0.5),\n        # Case 4 (d=3, C=[2.0, 0.5, 0.5], K=[3.0, 3.0, 0.5], L=[2.0, 2.0, 1.0], D=0.2)\n        (np.array([2.0, 0.5, 0.5]), np.array([3.0, 3.0, 0.5]), np.array([2.0, 2.0, 1.0]), 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        c_diag, k_diag, L, D = case\n\n        # Anisotropic Grid Calculation\n        # delta_i = sqrt(2*D * (c_i + k_i) / k_i^2)\n        delta_aniso = np.sqrt(2 * D * (c_diag + k_diag) / (k_diag**2))\n        \n        # n_i = max(1, floor(2*L_i / delta_i) + 1)\n        n_aniso_per_axis = np.maximum(1, np.floor(2 * L / delta_aniso) + 1).astype(int)\n        \n        # N_aniso = product(n_i)\n        N_aniso = np.prod(n_aniso_per_axis)\n\n        # Uniform Grid Calculation\n        # delta_uni = min(delta_i)\n        delta_uni = np.min(delta_aniso)\n        \n        # n_uni_i = max(1, floor(2*L_i / delta_uni) + 1)\n        n_uni_per_axis = np.maximum(1, np.floor(2 * L / delta_uni) + 1).astype(int)\n        \n        # N_uni = product(n_uni_i)\n        N_uni = np.prod(n_uni_per_axis)\n\n        # Efficiency Ratio Calculation\n        # R = N_uni / N_aniso\n        if N_aniso == 0:\n            # Avoid division by zero, although not expected in this problem\n            R = 0.0\n        else:\n            R = N_uni / N_aniso\n        \n        # Round R to 6 decimal places as required.\n        R_rounded = round(R, 6)\n\n        results.append([int(N_aniso), int(N_uni), R_rounded])\n\n    # Format the final output string according to the specification.\n    # e.g., [[a1,b1,r1],[a2,b2,r2],...]\n    output_str_parts = []\n    for res in results:\n        # Format each inner list into \"[a,b,r]\"\n        output_str_parts.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    # Join the parts into the final string \"[part1,part2,...]\"\n    final_output = f\"[{','.join(output_str_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3410778"}, {"introduction": "除了绘制平衡态的自由能形貌，增强采样在计算稀有但重要事件（如蛋白质折叠或药物解离）的速率方面也至关重要。存在多种强大的方法来计算动力学速率，每种方法都有其独特的理论基础和实际实现方式。本练习提供了一个独特的机会，让您能够亲手实现并比较四种不同的前沿速率估算技术：过渡界面采样（TIS）、里程碑（milestoning）、稀疏元动力学（infrequent metadynamics）以及基于偏置轨迹构建的马尔可夫状态模型（MSM）[@problem_id:3410718]。通过将它们应用于相同的基准问题，您将对这些方法的内在逻辑和相对优势形成实践性的理解。", "problem": "设计并实现一个完整的、可运行的程序，该程序对用于模拟蛋白质环区开放的一个程式化双势阱过程的稀有事件动力学的四种增强采样估计器进行基准测试。这些估计器分别是过渡界面采样 (Transition Interface Sampling, TIS)、里程碑 (milestoning)、稀疏元动力学 (infrequent metadynamics, infrequent MetaD) 以及基于偏置轨迹构建的马尔可夫状态模型 (Markov State Models, MSMs)。您的程序必须计算并报告对于一小组合成测试用例，从势阱 A 到势阱 B 的估计正向速率。所有速率必须以皮秒的倒数，即 $\\mathrm{ps}^{-1}$ 表示，并且您必须打印不带单位符号的数值。将所有报告的速率四舍五入到小数点后六位。\n\n该问题必须使用基本的动力学和采样定义从第一性原理解决。以下基本原则适用：\n\n- 连续时间稀有事件动力学可以被建模为满足主方程的马尔可夫跳跃过程。对于足够小的时间步长 $\\Delta t$，在 $\\Delta t$ 时间内从状态 A到状态 B 的转移概率与连续时间速率通过生成元的指数相关。\n- 过渡界面采样 (TIS) 将通过初始界面的稳态轨迹通量与 successive interface-to-interface progressions 的条件分裂概率联系起来。稳态通量是在未受扰动的动力学中单位时间内正向穿越的预期次数。条件分裂概率是在到达当前界面的条件下，返回初始势阱之前到达下一个界面的概率。\n- 里程碑方法将连续动力学简化为里程碑之间的马尔可夫更新过程。里程碑平均首达时 (mean first-passage times, MFPTs) 满足线性更新方程，该方程将局部停留时间与里程碑到里程碑的转移概率和目标吸收边界联系起来。\n- 稀疏元动力学时间变换理论指出，对于不改变过渡态穿越动力学的偏置势，无偏置的经过时间由偏置的经过时间乘以瞬时加速因子 $e^{\\beta V}$ 给出，其中 $\\beta$ 是逆热能，$V$ 是沿轨迹的偏置。因此，可以通过将观察到的跃迁次数除以经偏置重新标定的经过时间来获得无偏置速率。\n- 基于偏置轨迹的马尔可夫状态模型 (MSM) 重加权使用重要性采样来估计无偏置的转移概率。与 $e^{\\beta V}$ 成正比的重要性权重将偏置的转移计数校正为无偏置的平均值。离散时间转移概率与连续时间速率之间的联系遵循主方程。\n\n您的程序必须基于此实现以下估计器结构：\n\n1) TIS 估计器：使用通过第一个界面的稳态通量和一系列连续的界面到界面条件分裂概率，生成一个与界面间更新过程一致的速率估计。\n\n2) 里程碑估计器：给定构成具有吸收目标里程碑的马尔可夫更新链的里程碑索引的平均停留时间和最近邻里程碑转移概率，求解源里程碑到吸收里程碑的平均首达时的线性系统，并取其倒数以获得速率。\n\n3) 稀疏 MetaD 估计器：给定长度为 $N$、时间步长为 $\\Delta t$ 的离散偏置轨迹，以及对于 $k \\in \\{1,\\dots,N\\}$ 的瞬时加速因子数组 $e^{\\beta V(t_k)}$，连同观察到的 A 到 B 的跃迁次数，构建无偏置的有效经过时间并用它来计算无偏置速率。\n\n4) 基于偏置轨迹的 MSM：给定在均匀延迟 $\\Delta t$ 内从 A 到 A 和从 A 到 B 的重要性加权转移计数，通过归一化加权计数来构建从状态 A 的重加权两态转移概率，使用两态马尔可夫链的生成元将离散转移概率与连续时间速率联系起来，并报告所得速率。\n\n测试套件和输入参数：\n\n实现您的程序，为以下三个测试用例中的每一个计算并报告四种估计器的值。\n\n用例 1 (中等稀有事件):\n- TIS 输入：稳态通量 $\\phi_0 = 0.1\\,\\mathrm{ps}^{-1}$；条件分裂概率 $\\{p_0, p_1, p_2\\} = \\{0.5, 0.4, 0.1\\}$。\n- 里程碑输入：里程碑标记为 $0$ (源)、$1$、$2$ 和 $3$ (吸收目标)。平均停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{5.0, 4.0, 3.0\\}\\,\\mathrm{ps}$。内部里程碑的最近邻转移概率：对于里程碑 $1$，向前 $p_{1,2} = 0.3$ 和向后 $p_{1,0} = 0.7$；对于里程碑 $2$，向前 $p_{2,3} = 0.2$ 和向后 $p_{2,1} = 0.8$。根据构造，从源设置 $p_{0,1} = 1$；目标里程碑 $3$ 是吸收性的。\n- 稀疏 MetaD 输入：时间步长 $\\Delta t = 1.0\\,\\mathrm{ps}$；每步的加速因子 $e^{\\beta V}$ 由列表 $\\{100.0, 200.0, 300.0, 400.0, 500.0\\}$ 给出；观察到的 A 到 B 跃迁次数 $N = 3$。\n- MSM 输入：延迟 $\\Delta t = 10.0\\,\\mathrm{ps}$；在延迟时间内源于 A 的重要性加权观察跃迁：A 到 A 权重 $\\{400.0, 300.0, 280.0\\}$ 和 A 到 B 权重 $\\{12.0, 8.0\\}$。对于正向A到B速率的计算，您可以忽略源于B的跃迁。\n\n用例 2 (近确定性进展):\n- TIS 输入：稳态通量 $\\phi_0 = 1.0\\,\\mathrm{ps}^{-1}$；条件分裂概率 $\\{p_0, p_1, p_2\\} = \\{0.9, 0.9, 0.9\\}$。\n- 里程碑输入：里程碑标记为 $0$ (源)、$1$、$2$ 和 $3$ (吸收目标)。平均停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{0.1, 0.1, 0.1\\}\\,\\mathrm{ps}$。转移概率：对于里程碑 $1$，向前 $p_{1,2} = 0.95$ 和向后 $p_{1,0} = 0.05$；对于里程碑 $2$，向前 $p_{2,3} = 0.95$ 和向后 $p_{2,1} = 0.05$。从源设置 $p_{0,1} = 1$；目标里程碑 $3$ 是吸收性的。\n- 稀疏 MetaD 输入：时间步长 $\\Delta t = 0.5\\,\\mathrm{ps}$；加速因子 $e^{\\beta V}$ 由 $\\{2.0, 3.0, 4.0, 5.0, 6.0\\}$ 给出；观察到的 A 到 B 跃迁次数 $N = 7$。\n- MSM 输入：延迟 $\\Delta t = 1.0\\,\\mathrm{ps}$；来自 A 的重要性加权跃迁：A 到 A 权重 $\\{250.0, 247.0\\}$ 和 A 到 B 权重 $\\{300.0, 203.0\\}$。\n\n用例 3 (非常稀有事件):\n- TIS 输入：稳态通量 $\\phi_0 = 0.01\\,\\mathrm{ps}^{-1}$；条件分裂概率 $\\{p_0, p_1, p_2\\} = \\{0.2, 0.5, 0.1\\}$。\n- 里程碑输入：里程碑标记为 $0$ (源)、$1$、$2$ 和 $3$ (吸收目标)。平均停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{10.0, 20.0, 20.0\\}\\,\\mathrm{ps}$。转移概率：对于里程碑 $1$，向前 $p_{1,2} = 0.2$ 和向后 $p_{1,0} = 0.8$；对于里程碑 $2$，向前 $p_{2,3} = 0.1$ 和向后 $p_{2,1} = 0.9$。从源设置 $p_{0,1} = 1$；目标里程碑 $3$ 是吸收性的。\n- 稀疏 MetaD 输入：时间步长 $\\Delta t = 2.0\\,\\mathrm{ps}$；加速因子 $e^{\\beta V}$ 由 $\\{1000.0, 900.0, 800.0, 700.0, 600.0, 500.0, 300.0, 200.0\\}$ 给出；观察到的 A 到 B 跃迁次数 $N = 1$。\n- MSM 输入：延迟 $\\Delta t = 10.0\\,\\mathrm{ps}$；来自 A 的重要性加权跃迁：A 到 A 权重 $\\{500.0, 499.0\\}$ 和 A 到 B 权重 $\\{1.0\\}$。\n\n算法要求：\n\n- 对于 TIS，从第一个界面的稳态通量和 successive splitting probabilities 的更新图像开始，并实现逻辑上 implied 的估计器。\n- 对于里程碑，构建并求解马尔可夫更新链的平均首达时 $\\{T_i\\}$ 的线性系统，其中在吸收里程碑 $K$ 处 $T_K = 0$，里程碑 $0$ 是源。仅使用所提供的最近邻转移。报告速率为 $1/T_0$。\n- 对于稀疏 MetaD，将无偏置的有效经过时间计算为 $\\Delta t \\sum_{k=1}^{N_{\\mathrm{frames}}} e^{\\beta V(t_k)}$，并将观察到的跃迁次数除以此有效时间。\n- 对于 MSM，使用重要性加权计数来估计在延迟 $\\Delta t$ 时从 A 到 B 的离散时间转移概率，并使用两态马尔可夫过程的生成元将其转换为连续时间速率。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含 $12$ 个结果，形式为方括号括起来的逗号分隔列表。顺序必须是：\n$[\\text{Case1\\_TIS}, \\text{Case1\\_Milestone}, \\text{Case1\\_MetaD}, \\text{Case1\\_MSM}, \\text{Case2\\_TIS}, \\text{Case2\\_Milestone}, \\text{Case2\\_MetaD}, \\text{Case2\\_MSM}, \\text{Case3\\_TIS}, \\text{Case3\\_Milestone}, \\text{Case3\\_MetaD}, \\text{Case3\\_MSM}]$\n每个条目以 $\\mathrm{ps}^{-1}$ 为单位，四舍五入到小数点后六位，例如 $[0.123456,0.234567,\\dots]$。不应打印任何其他文本。", "solution": "用户提供了一个定义明確的计算问题，用于对四种稀有事件动力学的增强采样估计器进行基准测试。该问题在科学上是合理的，内容是自洽的，并且算法上是明确的。我将按要求推导并实现每种估计器的解决方案。\n\n### 问题验证\n\n**第 1 步：提取给定信息**\n问题为四种增强采样方法提供了基本原理：过渡界面采样 (TIS)、里程碑 (milestoning)、稀疏元动力学 (MetaD) 和马尔可夫状态模型 (MSM)。它还提供了三个不同的测试用例，每个用例都为所有四种方法提供了具体的输入参数。要求的输出是一个逗号分隔的列表，包含 12 个计算出的速率（4 种方法 x 3 个用例），四舍五入到小数点后六位，单位为 $\\mathrm{ps}^{-1}$。\n\n**用例 1 给定信息：**\n- TIS：$\\phi_0 = 0.1\\,\\mathrm{ps}^{-1}$，$\\{p_0, p_1, p_2\\} = \\{0.5, 0.4, 0.1\\}$。\n- 里程碑：里程碑 $0, 1, 2, 3$（$0$=源，$3$=汇）。停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{5.0, 4.0, 3.0\\}\\,\\mathrm{ps}$。转移概率 $p_{0,1}=1.0$，$p_{1,2} = 0.3$，$p_{1,0} = 0.7$，$p_{2,3} = 0.2$，$p_{2,1} = 0.8$。\n- 稀疏 MetaD：$\\Delta t = 1.0\\,\\mathrm{ps}$，$e^{\\beta V}$ 列表 $\\{100.0, ..., 500.0\\}$（5 个值），$N_{AB} = 3$。\n- MSM：$\\Delta t = 10.0\\,\\mathrm{ps}$，A-A 权重 $\\{400.0, 300.0, 280.0\\}$，A-B 权重 $\\{12.0, 8.0\\}$。\n\n**用例 2 给定信息：**\n- TIS：$\\phi_0 = 1.0\\,\\mathrm{ps}^{-1}$，$\\{p_0, p_1, p_2\\} = \\{0.9, 0.9, 0.9\\}$。\n- 里程碑：里程碑 $0, 1, 2, 3$。停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{0.1, 0.1, 0.1\\}\\,\\mathrm{ps}$。转移概率 $p_{0,1}=1.0$，$p_{1,2} = 0.95$，$p_{1,0} = 0.05$，$p_{2,3} = 0.95$，$p_{2,1} = 0.05$。\n- 稀疏 MetaD：$\\Delta t = 0.5\\,\\mathrm{ps}$，$e^{\\beta V}$ 列表 $\\{2.0, ..., 6.0\\}$（5 个值），$N_{AB} = 7$。\n- MSM：$\\Delta t = 1.0\\,\\mathrm{ps}$，A-A 权重 $\\{250.0, 247.0\\}$，A-B 权重 $\\{300.0, 203.0\\}$。\n\n**用例 3 给定信息：**\n- TIS：$\\phi_0 = 0.01\\,\\mathrm{ps}^{-1}$，$\\{p_0, p_1, p_2\\} = \\{0.2, 0.5, 0.1\\}$。\n- 里程碑：里程碑 $0, 1, 2, 3$。停留时间 $\\{\\tau_0,\\tau_1,\\tau_2\\} = \\{10.0, 20.0, 20.0\\}\\,\\mathrm{ps}$。转移概率 $p_{0,1}=1.0$，$p_{1,2} = 0.2$，$p_{1,0} = 0.8$，$p_{2,3} = 0.1$，$p_{2,1} = 0.9$。\n- 稀疏 MetaD：$\\Delta t = 2.0\\,\\mathrm{ps}$，$e^{\\beta V}$ 列表 $\\{1000.0, ..., 200.0\\}$（8 个值），$N_{AB} = 1$。\n- MSM：$\\Delta t = 10.0\\,\\mathrm{ps}$，A-A 权重 $\\{500.0, 499.0\\}$，A-B 权重 $\\{1.0\\}$。\n\n**第 2 步：使用提取的给定信息进行验证**\n该问题被评估为**有效**。它在科学上基于已建立的随机过程和增强采样理论。它的表述很清晰，为每次计算提供了足够的信息以产生唯一、稳定的结果。语言客观且正式。在这个程式化的基准测试背景下，参数是一致的，没有违反物理或数学原理。\n\n**第 3 步：结论与行动**\n该问题有效。将提供完整的解决方案。\n\n### 解决方案推导\n\n**1. 过渡界面采样 (TIS) 估计器**\nTIS 速率 $k_{\\mathrm{TIS}}$ 是通过第一个界面的稳态通量 $\\phi_0$ 与从第一个界面出发的轨迹到达势阱 B 的总概率 $P(B|0)$ 的乘积。这个总概率是序列条件分裂概率 $p_i$ 的乘积，即轨迹已到达界面 $i$ 的条件下到达界面 $i+1$ 的概率。\n$$\nk_{\\mathrm{TIS}} = \\phi_0 \\cdot P(B|0) = \\phi_0 \\cdot \\prod_{i=0}^{N-1} p_i\n$$\n其中 $N$ 是势阱之间的界面数。提供的分裂概率 $\\{p_0, p_1, p_2\\}$ 就是这些条件概率。\n\n**2. 里程碑 (Milestoning) 估计器**\n里程碑方法将系统建模为离散里程碑集上的马尔可夫更新过程。速率是从源里程碑 ($i=0$) 到吸收目标里程碑 ($i=K$) 的平均首达时 (MFPT) 的倒数。从每个里程碑 $i$ 到目标的 MFPT $T_i$ 满足基于全期望定律的线性方程组：\n$$\nT_i = \\tau_i + \\sum_{j \\neq i} p_{i,j} T_j\n$$\n其中 $\\tau_i$ 是在里程碑 $i$ 的平均停留时间，$p_{i,j}$ 是从里程碑 $i$ 到 $j$ 的转移概率。边界条件是对于吸收里程碑 $K=3$，$T_K = 0$。\n给定的设置有里程碑 $0$ (源)、$1$、$2$ 和 $3$ (目标)。需要求解的 MFPT 是 $T_0, T_1, T_2$。方程组为：\n$T_0 = \\tau_0 + p_{0,1}T_1$\n$T_1 = \\tau_1 + p_{1,0}T_0 + p_{1,2}T_2$\n$T_2 = \\tau_2 + p_{2,1}T_1 + p_{2,3}T_3 = \\tau_2 + p_{2,1}T_1$ (因为 $T_3=0$)\n给定 $p_{0,1}=1$，这可以写成矩阵形式 $\\mathbf{A}\\mathbf{T} = \\boldsymbol{\\tau}$，对于 $\\mathbf{T} = [T_0, T_1, T_2]^T$：\n$$\n\\begin{pmatrix}\n1  -1  0 \\\\\n-p_{1,0}  1  -p_{1,2} \\\\\n0  -p_{2,1}  1\n\\end{pmatrix}\n\\begin{pmatrix}\nT_0 \\\\ T_1 \\\\ T_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\tau_0 \\\\ \\tau_1 \\\\ \\tau_2\n\\end{pmatrix}\n$$\n求解此线性系统得到 $\\mathbf{T}$。速率则为 $k_{\\mathrm{Milestone}} = 1/T_0$。\n\n**3. 稀疏元动力学 (MetaD) 估计器**\n稀疏元动力学方法依赖于时间重标定论证。事件的速率是发生次数除以经过的时间。在偏置模拟中，表观时间被加速了。真实的、无偏置的经过时间 $T_{\\mathrm{unbiased}}$ 通过在偏置模拟时间内对瞬时加速因子 $e^{\\beta V(t)}$ 进行积分来恢复。对于时间步长为 $\\Delta t$ 的离散轨迹，这变成一个求和：\n$$\nT_{\\mathrm{unbiased}} = \\sum_{k=1}^{N_{\\text{frames}}} \\Delta t \\cdot e^{\\beta V(t_k)} = \\Delta t \\sum_{k=1}^{N_{\\text{frames}}} e^{\\beta V(t_k)}\n$$\n给定在此轨迹期间观察到 $N_{AB}$ 次从势阱 A 到 B 的跃迁，无偏置的正向速率为：\n$$\nk_{\\mathrm{MetaD}} = \\frac{N_{AB}}{T_{\\mathrm{unbiased}}}\n$$\n\n**4. 基于偏置轨迹的马尔可夫状态模型 (MSM) 估计器**\n从偏置数据构建的 MSM 需要重加权以恢复无偏置的动力学。在延迟时间 $\\Delta t$ 内从状态 A 到 B 的无偏置转移概率 $P_{AB}(\\Delta t)$ 可以使用重要性采样来估计。轨迹段的权重与偏置势 $V$ 相关。问题提供了预先计算的重要性加权转移计数。估计的无偏置概率 $P_{AB}(\\Delta t)$ 是加权的 A 到 B 计数之和除以所有源于 A 的加权计数之和：\n$$\nC'_{IJ} = \\sum_{k \\in \\text{trans}(I \\to J)} w_k \\quad , \\quad P_{AB}(\\Delta t) = \\frac{C'_{AB}}{C'_{AA} + C'_{AB}}\n$$\n为了找到连续时间速率 $k_{AB}$，我们将其与离散时间转移概率联系起来。对于将 B 视为吸收态的两态过程（这与忽略来自 B 的跃迁是一致的），保持在状态 A 的概率是 $P_{AA}(\\Delta t) = e^{-k_{AB}\\Delta t}$。\n由此，我们推导出速率：\n$$\nk_{\\mathrm{MSM}} = -\\frac{1}{\\Delta t} \\ln\\left(P_{AA}(\\Delta t)\\right) = -\\frac{1}{\\Delta t} \\ln\\left(1 - P_{AB}(\\Delta t)\\right)\n$$\n使用估计的概率：\n$$\nk_{\\mathrm{MSM}} = -\\frac{1}{\\Delta t} \\ln\\left( \\frac{C'_{AA}}{C'_{AA} + C'_{AB}} \\right)\n$$\n该公式正确地将离散的、重加权的数据与连续时间速率常数联系起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef tis_estimator(phi0: float, p_splits: list[float]) -> float:\n    \"\"\"Computes the TIS rate constant.\"\"\"\n    p_total = np.prod(p_splits)\n    return phi0 * p_total\n\ndef milestoning_estimator(taus: list[float], p10: float, p12: float, p21: float) -> float:\n    \"\"\"Computes the Milestoning rate by solving for the MFPT.\"\"\"\n    # System of equations: A * T = taus_vec\n    # T = [T0, T1, T2]^T\n    # A = [[ 1, -1,   0 ],\n    #      [-p10, 1, -p12],\n    #      [  0, -p21,  1 ]]\n    A = np.array([\n        [1.0, -1.0, 0.0],\n        [-p10, 1.0, -p12],\n        [0.0, -p21, 1.0]\n    ])\n    taus_vec = np.array(taus)\n    \n    T = np.linalg.solve(A, taus_vec)\n    T0 = T[0]\n    \n    # The rate is the inverse of the MFPT from the source milestone (0).\n    return 1.0 / T0\n\ndef metad_estimator(dt: float, accel_factors: list[float], n_trans: int) -> float:\n    \"\"\"Computes the infrequent Metadynamics rate.\"\"\"\n    unbiased_time = dt * np.sum(accel_factors)\n    # Avoid division by zero if no time has passed.\n    if unbiased_time == 0:\n        return 0.0\n    return n_trans / unbiased_time\n\ndef msm_estimator(dt: float, w_aa: list[float], w_ab: list[float]) -> float:\n    \"\"\"Computes the MSM rate from importance-weighted counts.\"\"\"\n    C_prime_AA = np.sum(w_aa)\n    C_prime_AB = np.sum(w_ab)\n    \n    C_prime_total = C_prime_AA + C_prime_AB\n    \n    # Avoid division by zero or log(0) if no transitions occurred.\n    if C_prime_total == 0:\n        return 0.0\n        \n    P_AA = C_prime_AA / C_prime_total\n    \n    # Avoid log(0) if P_AA is 0.\n    if P_AA == 0:\n        return np.inf # Effectively infinite rate if escape is certain\n\n    rate = - (1.0 / dt) * np.log(P_AA)\n    return rate\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for all test cases and estimators.\n    \"\"\"\n    test_cases = [\n        { # Case 1 (moderately rare event)\n            \"TIS\": {\"phi0\": 0.1, \"p_splits\": [0.5, 0.4, 0.1]},\n            \"Milestone\": {\"taus\": [5.0, 4.0, 3.0], \"p10\": 0.7, \"p12\": 0.3, \"p21\": 0.8},\n            \"MetaD\": {\"dt\": 1.0, \"accel_factors\": [100.0, 200.0, 300.0, 400.0, 500.0], \"n_trans\": 3},\n            \"MSM\": {\"dt\": 10.0, \"w_aa\": [400.0, 300.0, 280.0], \"w_ab\": [12.0, 8.0]}\n        },\n        { # Case 2 (near-deterministic progression)\n            \"TIS\": {\"phi0\": 1.0, \"p_splits\": [0.9, 0.9, 0.9]},\n            \"Milestone\": {\"taus\": [0.1, 0.1, 0.1], \"p10\": 0.05, \"p12\": 0.95, \"p21\": 0.05},\n            \"MetaD\": {\"dt\": 0.5, \"accel_factors\": [2.0, 3.0, 4.0, 5.0, 6.0], \"n_trans\": 7},\n            \"MSM\": {\"dt\": 1.0, \"w_aa\": [250.0, 247.0], \"w_ab\": [300.0, 203.0]}\n        },\n        { # Case 3 (very rare event)\n            \"TIS\": {\"phi0\": 0.01, \"p_splits\": [0.2, 0.5, 0.1]},\n            \"Milestone\": {\"taus\": [10.0, 20.0, 20.0], \"p10\": 0.8, \"p12\": 0.2, \"p21\": 0.9},\n            \"MetaD\": {\"dt\": 2.0, \"accel_factors\": [1000.0, 900.0, 800.0, 700.0, 600.0, 500.0, 300.0, 200.0], \"n_trans\": 1},\n            \"MSM\": {\"dt\": 10.0, \"w_aa\": [500.0, 499.0], \"w_ab\": [1.0]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate rate for each estimator for the current case\n        rate_tis = tis_estimator(**case[\"TIS\"])\n        rate_milestone = milestoning_estimator(**case[\"Milestone\"])\n        rate_metad = metad_estimator(**case[\"MetaD\"])\n        rate_msm = msm_estimator(**case[\"MSM\"])\n        \n        results.extend([rate_tis, rate_milestone, rate_metad, rate_msm])\n\n    # Format the final output string as per requirements\n    # Each result is rounded to exactly six digits after the decimal point\n    output_str = f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3410718"}]}