{"hands_on_practices": [{"introduction": "虽然哈密顿动力学完美地描述了孤立系统的演化，但它往往不足以对整个热力学系综进行采样。本练习 [@problem_id:3403533] 将通过经典的双势阱模型，阐明一个能量守恒的确定性轨迹为何会陷入局部，无法探索所有相关的构型。我们将看到，引入模拟热浴的随机恒温器如何提供必要的能量涨落，以确保遍历性并正确地对正则系综进行采样。", "problem": "考虑一个质量为 $m$ 的单个粒子在一维空间中运动，其坐标为 $q$，动量为 $p$，遵循哈密顿动力学，其哈密顿量为 $H(q,p)=\\frac{p^{2}}{2m}+U(q)$，运动方程为 $\\dot{q}=\\frac{\\partial H}{\\partial p}=\\frac{p}{m}$ 和 $\\dot{p}=-\\frac{\\partial H}{\\partial q}=-U^{\\prime}(q)$。设位形空间为位置 $q$ 的集合，相空间为对 $(q,p)$ 的集合。假设一个双阱势 $U(q)=\\frac{\\lambda}{4}\\left(q^{2}-a^{2}\\right)^{2}$，其在 $q=\\pm a$ 处有极小值，在 $q=0$ 处有高度为 $U(0)=\\frac{\\lambda}{4}a^{4}$ 的势垒。该分子动力学（MD）模拟以满足 $0  E  U(0)$ 的初始总能量 $E$ 开始，并且不包括任何控温器。在这种情况下，采样是非遍历的，并且不符合在温度 $T$ 下的正则系综。哪个选项提供了一个正确的例子，说明了在特定情况下能量守恒的确定性动力学如何破坏遍历性，并提出了一个利用随机扰动来恢复正则采样的有效补救措施？", "solution": "问题陈述具有科学依据、提法恰当、客观且自洽。它描述了统计力学和分子动力学（MD）中的一个经典情景，即确定性的、能量守恒的动力学无法采样所需的热力学系综。哈密顿量、运动方程、势能函数和正则系综的定义都是标准且正确的。因此，该问题是有效的，我们可以继续进行解答。\n\n该问题需要分析两个不同的方面：(i) 找出一个在哈密顿MD中非遍历性采样的有效例子，以及 (ii) 找出一个正确的补救措施，该措施利用随机扰动来恢复对正则系综的采样。\n\n首先，我们来分析所描述的物理系统。我们有一个质量为 $m$ 的粒子，在一维坐标 $q$ 上运动，其势为双阱势 $U(q) = \\frac{\\lambda}{4}(q^2 - a^2)^2$。哈密顿量为 $H(q,p) = \\frac{p^2}{2m} + U(q)$。动力学由哈密顿方程决定，该方程使总能量 $E = H(q,p)$ 守恒。问题指定初始能量 $E$ 小于势垒高度，即 $0  E  U(0) = \\frac{\\lambda}{4}a^4$。\n\n哈密顿动力学的一个关键原理是能量守恒。系统的轨迹被永久限制在由 $H(q,p) = E$ 定义的相空间中的等能面上。对于给定的势，条件 $U(q) \\le E$ 决定了位形空间中的经典允许区域。由于 $E  U(0)$，粒子缺乏到达势垒顶部（$q=0$）的能量。这意味着 $q=0$ 附近的区域是经典禁区。方程 $U(q) = E$ 有四个关于 $q$ 的实根，定义了位置 $q$ 的两个不相交的允许区间：一个对应左阱，另一个对应右阱。如果粒子在一个势阱中初始化（例如，$q(0)  0$），它将在该势阱内振荡，永远无法穿越势垒进入另一个势阱。\n\n在相空间中，等能面 $H(q,p) = E$ 由两条不连通的闭合曲线（椭圆形）组成，每个势阱对应一条。从一条曲线上开始的单条确定性轨迹将永远留在那条曲线上。\n\n然而，目标是采样由概率密度 $\\rho(q,p) \\propto \\exp(-\\beta H(q,p))$ 描述的正则系综，其中 $\\beta = (k_\\mathrm{B}T)^{-1}$。这个分布对所有 $(q,p)$ 都是非零的，并为所有能量的状态分配概率。一个算法要正确采样一个分布，其基本要求是遍历性：该算法生成的轨迹必须在长时间内访问所有可及状态，且访问频率与其概率成正比。在固定低能量下的确定性MD模拟完全不满足这个要求。它只采样了相空间的一个微小的、不连通的子集，完全无法采样另一个势阱中的状态或具有不同能量的状态，而这两者在正则系综中都具有非零概率。这是一个由非遍历性导致不完全采样的经典例子。\n\n为了纠正这一点，必须修改动力学。系统必须能够与其环境（由温度为 $T$ 的概念性“热浴”所代表）交换能量。这种耦合应该引入一种使能量涨落的机制，从而使得能够穿越势垒。提示特别要求一种涉及*随机扰动*的补救措施。修改后的动力学必须使其稳态概率分布恰好是正则分布 $\\rho(q,p)$。\n\n现在我们基于这种理解来评估每个选项。\n\n**A. 例子：一个由两个非耦合的一维谐振子组成的系统，其哈密顿量为 $H=\\sum_{i=1}^{2}\\left(\\frac{p_{i}^{2}}{2m}+\\frac{k}{2}q_{i}^{2}\\right)$ 且频率可通约，其中声称具有有限链长的确定性Nosé–Hoover链(NHC)控温器能保证正则遍历性。补救措施：添加确定性的NHC变量，不带任何随机噪声。**\n\n(i) 两个非耦合谐振子的例子是关于非遍历性的一个有效例证。由于振子是非耦合的，每个振子的能量 $E_1$ 和 $E_2$ 各自守恒。该系统有两个自由度和两个独立的运动常数（$E_1$, $E_2$, $E = E_1+E_2$ 中的任意两个）。这样一个系统是可积的。其轨迹被限制在恒定总能量面内的一个低维流形（环面）上，并且在该能量面上不是遍历的，特别是当频率可通约时，轨迹会形成一个闭合回路。这部分是科学上合理的。\n\n(ii) 提议的补救措施是Nosé–Hoover链(NHC)控温器。NHC是一种*确定性*算法。它通过扩展相空间来引入模拟热浴的虚拟变量。虽然它通常很有效，但众所周知，它对某些系统会失效，包括谐振子，因为在这些系统中，控温器的自由度可能与物理系统解耦。声称它“保证”遍历性是错误的。更重要的是，它是一种确定性方法，不涉及问题陈述所要求的“随机扰动”。\n\n结论：**不正确**。该补救措施是确定性的，而不是随机的，并且其有效性不像声称的那样有保证。\n\n**B. 例子：一个在一维对称双阱势 $U(q)=\\frac{\\lambda}{4}\\left(q^{2}-a^{2}\\right)^{2}$ 中运动的粒子，其初始能量 $E$ 满足 $0  E  U(0)=\\frac{\\lambda}{4}a^{4}$。补救措施：实现一个Andersen控温器，它在每个时间步长 $\\Delta t$ 之间，以一个小的概率，从适当温度的麦克斯韦-玻尔兹曼分布中重新随机选择粒子的动量。**\n\n(i) 该例子与问题陈述中的例子完全相同。正如我们的分析所示，对于一个以 $E  U(0)$ 开始的确定性轨迹，粒子被限制在一个阱中。这构成了对非遍历性的一个完美例子，因为相空间的允许区域（正则系综所要求的）包含两个阱，但轨迹只探索了一个。\n\n(ii) 提议的补救措施是Andersen控温器。该算法通过模拟与热浴的随机碰撞来工作。在模拟过程中，粒子的动量会周期性地或随机地从与目标温度 $T$ 相对应的麦克斯韦-玻尔兹曼分布中重新抽取。这种动量的随机化有效地改变了系统的能量 $E=p^2/2m + U(q)$，从而允许能量涨落。通过适当调整碰撞频率，粒子可以获得足够的能量以越过势垒，从而探索整个构象空间。因此，Andersen控温器通过引入*随机扰动*来破坏能量守恒，并被设计用来正确采样正则系综。\n\n结论：**正确**。该例子清楚地展示了非遍历性，并且补救措施是一种有效的、基于随机扰动的算法，用于采样正则系综。\n\n**C. 例子：一个理想气体，其中所有粒子都以相同的速度向量开始。补救措施：使用Velocity Verlet积分器，因为它精确地保持相空间体积，从而确保正则系综的采样。**\n\n(i) 理想气体的例子（$U=0$）是一种特殊情况。如果所有粒子都以相同的速度开始，并且没有相互作用，它们将永远保持那个速度。在没有边界的情况下，这不会探索动量空间。这是一个有效的非遍历性例子（对于动量空间而言）。\n\n(ii) 提议的补救措施是使用Velocity Verlet积分器。Velocity Verlet是一种*辛*积分器，这意味着它在哈密顿动力学下精确地保持相空间体积。然而，它是一种*确定性*算法。它只遵循由初始条件决定的轨迹。它本身不引入任何随机性或能量交换。因此，它不会纠正初始非遍历性问题或使系统采样正则系综。它只会精确地传播非遍历轨迹。\n\n结论：**不正确**。例子是有效的，但补救措施是无效的；它无法将确定性动力学转变为正则采样。\n\n**D. 例子：一个粒子在一个通过SHAKE算法在 $r=R$ 处约束的中心力场中运动。补救措施：采用一个时间步长 $h$ 远大于系统最快振动周期的Langevin动力学，以确保数值稳定性。**\n\n(i) SHAKE算法在哈密顿动力学中实施约束。这本身并不必然导致非遍历性（在约束流形上），尽管它引入了额外的复杂性。然而，让我们关注补救措施。\n\n(ii) 补救措施是使用一个大时间步长的Langevin动力学。Langevin动力学确实是一种随机方法，可以采样正则系综。然而，要求时间步长 $h$ *远大于*最快的振动周期是错误的。数值积分的稳定性要求时间步长*远小于*系统中最快的相关时间尺度（如振动周期）。使用一个大的时间步长将导致数值积分发散，使模拟崩溃。\n\n结论：**不正确**。补救措施在物理上是错误的，并会导致数值不稳定性，而不是正确的采样。\n\n综上所述，选项B是唯一一个既提供了清晰的非遍历性例子，又提出了有效的、基于随机的补救措施来恢复正则系综采样的选项。", "answer": "$$\\boxed{B}$$", "id": "3403533"}, {"introduction": "在处理完整约束系统时，相空间采样与构型空间采样之间的区别变得尤为关键和微妙。本练习 [@problem_id:3403498] 深入探讨了“蓝月亮”采样框架，揭示了一个有趣的现象：即使在约束相空间上进行了正确的采样，其在构型空间上的投影分布仍然存在系统性偏差。我们将推导这种与约束流形几何形状相关的偏差的理论根源，并实施必要的重加权因子，以恢复沿约束流形的真实、无偏的构型概率。", "problem": "给定一个适用于二维空间中分子动力学（MD; Molecular Dynamics）的完整约束系统，其质量矩阵为单位矩阵。设广义坐标为 $q=(x,y) \\in \\mathbb{R}^2$，并考虑一个由水平集 $\\sigma(q)=0$ 隐式定义的单个光滑约束，该约束定义了一条嵌入在平面中的闭合曲线（一维流形）。哈密顿量为 $H(q,p)=\\tfrac{1}{2}p^\\top p + U(q)$，其中 $U(q)$ 是一个光滑的势能，$p$ 是动量。在逆温度 $\\beta$ 下，正则相空间密度正比于 $\\exp(-\\beta H(q,p))$。\n\n约束分子动力学方法（如 SHAKE/RATTLE）将动力学限制在流形 $\\sigma(q)=0$ 和相应的约束动量子空间 $\\dot{\\sigma}(q,p)=\\nabla \\sigma(q) \\cdot p = 0$ 上。已知当投影到位置空间时，不变的约束相空间测度会沿着 $\\sigma(q)=0$ 诱导出有偏的构象分布，这与先积分掉动量然后限制到 $\\sigma(q)=0$ 上所获得的构象空间边际分布不同。你的任务是：\n\n1) 从基本的正则原理和完整约束的定义（包括运动学约束 $\\dot{\\sigma}(q,p)=0$）出发，定量推导约束相空间测度如何根据函数 $G(q)=\\nabla \\sigma(q)^\\top \\nabla \\sigma(q)$ 对沿曲线 $\\sigma(q)=0$ 的采样产生偏倚，并证明在使用诱导曲面元 $\\mathrm{d}S$（曲线上的弧长元）时，从约束相空间诱导的构象密度在流形上正比于 $\\exp(-\\beta U(q)) \\sqrt{G(q)}$。然后，将构象空间边际分布定义为无约束构象吉布斯测度在流形上的限制，并使用诱导弧长元，其密度在流形上正比于 $\\exp(-\\beta U(q))$。最后得出结论，将在约束相空间诱导分布下计算的平均值转换为沿约束的期望构象边际分布所需的重加权因子为 $w(q)=1/\\sqrt{G(q)}$。在二维单位质量矩阵的特殊情况下，这简化为 $w(q)=1/\\lVert \\nabla \\sigma(q) \\rVert$，其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。\n\n2) 实现一个确定性的数值测试，以在一组三个闭合曲线约束上展示偏倚效应及其校正。用极角 $\\theta \\in [0,2\\pi)$（以弧度为单位）参数化曲线，通过 $\\sigma(r(\\theta)\\cos\\theta, r(\\theta)\\sin\\theta)=0$ 隐式定义径向坐标 $r(\\theta)>0$，并使用隐式微分在每个角度处获得沿曲线的 $\\mathrm{d}s/\\mathrm{d}\\theta$（弧长变化率），其中 $\\mathrm{d}s$ 是弧长微分。对于每个 $\\theta$：\n- 计算 $q(\\theta)=(x(\\theta),y(\\theta))=(r(\\theta)\\cos\\theta,r(\\theta)\\sin\\theta)$。\n- 计算 $\\lVert \\nabla \\sigma(q(\\theta)) \\rVert$。\n- 形成三个未归一化的角密度（相对于 $\\mathrm{d}\\theta$）：\n  - 沿约束的目标构象边际分布：$\\rho_{\\mathrm{conf}}(\\theta) \\propto \\exp(-\\beta U(q(\\theta))) \\, \\frac{\\mathrm{d}s}{\\mathrm{d}\\theta}$。\n  - 约束相空间诱导的边际分布：$\\rho_{\\mathrm{bm}}(\\theta) \\propto \\exp(-\\beta U(q(\\theta))) \\, \\lVert \\nabla \\sigma(q(\\theta)) \\rVert \\, \\frac{\\mathrm{d}s}{\\mathrm{d}\\theta}$。\n  - 校正后的边际分布：$\\rho_{\\mathrm{corr}}(\\theta) \\propto \\rho_{\\mathrm{bm}}(\\theta) \\, \\frac{1}{\\lVert \\nabla \\sigma(q(\\theta)) \\rVert}$。\n在 $\\theta \\in [0,2\\pi)$ 上对每个密度进行归一化，并计算归一化目标与以下两者之间的离散 $\\ell_1$ 距离：\n- 朴素的约束相空间诱导边际分布，\n- 校正后的边际分布。\n\n使用足够精细的角度离散化，以使数值误差与偏倚相比可以忽略不计。\n\n3) 将程序输出以单行形式提供，其中包含每个测试用例的两个误差，格式为浮点数列表的列表，如下方指定的确切格式。\n\n本问题中的所有量均为无量纲；角度必须以弧度为单位。测试套件必须使用以下用例和参数：\n\n- 用例1（基线，梯度幅值恒定）：约束 $\\sigma(x,y)=x^2+y^2-1$，势能 $U(x,y)=\\tfrac{1}{2}(1.0\\, x^2+1.0\\, y^2)$，逆温度 $\\beta=1.0$。\n- 用例2（各向异性椭圆）：约束 $\\sigma(x,y)=x^2+4 y^2-1$，势能 $U(x,y)=\\tfrac{1}{2}(1.5\\, x^2+0.5\\, y^2)$，逆温度 $\\beta=1.0$。\n- 用例3（非线性星形）：约束 $\\sigma(x,y)=x^4+y^2-1$，势能 $U(x,y)=\\tfrac{1}{2}(0.7\\, x^2+2.0\\, y^2)$，逆温度 $\\beta=1.0$。\n\n你的程序必须离散化 $\\theta \\in [0,2\\pi)$，求解 $\\sigma(r\\cos\\theta,r\\sin\\theta)=0$ 的唯一正根以得到 $r(\\theta)$，使用对 $\\sigma(q(\\theta))=0$ 的隐式微分计算 $\\mathrm{d}s/\\mathrm{d}\\theta$，然后按规定计算归一化的密度和 $\\ell_1$ 距离。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个逗号分隔的包含三个条目的列表，每个条目对应一个用例，其中每个条目是一个双元素列表，分别包含朴素 $\\ell_1$ 距离和校正后 $\\ell_1$ 距离。例如：\"[[e1_naive,e1_corrected],[e2_naive,e2_corrected],[e3_naive,e3_corrected]]\"。", "solution": "该问题要求对约束分子动力学中的有偏采样进行理论推导，并通过数值实现来验证该效应。\n\n### 第1部分：理论推导\n\n分析始于经典统计力学在正则系综中的原理。系统由哈密顿量 $H(q,p) = K(p) + U(q)$ 描述，其中 $q$ 是广义坐标，$p$ 是共轭动量，$K(p) = \\frac{1}{2}p^\\top M^{-1}p$ 是动能，$U(q)$ 是势能。对于本问题，质量矩阵 $M$ 是单位矩阵 ($M=I$)，因此 $K(p) = \\frac{1}{2}p^\\top p$。系统受到完整约束 $\\sigma(q)=0$ 的限制。\n\n对于无约束系统，正则相空间概率密度正比于 $\\exp(-\\beta H(q,p))$，其中 $\\beta=1/(k_B T)$ 是逆温度。相空间测度为 $\\mathrm{d}\\mu = \\exp(-\\beta H(q,p)) \\mathrm{d}q \\mathrm{d}p$。\n\n当存在约束时，动力学以及因此的平衡采样被限制在相空间的一个子流形上。完整约束 $\\sigma(q)=0$ 将构象限制在一个特定的流形上。约束的时间导数也必须为零，这对动量施加了一个条件。这就是运动学约束：\n$$\n\\dot{\\sigma}(q, \\dot{q}) = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}t} = \\nabla_q \\sigma(q) \\cdot \\dot{q} = 0\n$$\n由于动量通过 $p = M\\dot{q}$（或 $\\dot{q}=M^{-1}p$）与速度相关，并且 $M=I$，我们有 $p=\\dot{q}$。运动学约束变为：\n$$\n\\nabla\\sigma(q) \\cdot p = 0\n$$\n这将动量约束在约束流形的切空间上。约束分子动力学算法，如 SHAKE 和 RATTLE，旨在生成在此约束相空间子流形上采样正则分布的轨迹。\n\n目标是找到由这种约束相空间采样所诱导的构象 $q$ 的边际概率分布。该分布是通过在允许的动量上对约束相空间密度进行积分得到的。该诱导密度的精确形式的推导是统计力学中的一个微妙课题，其结果取决于约束曲面上测度的具体表述。问题陈述引导我们证明这将导致一个正比于 $\\exp(-\\beta U(q)) \\sqrt{G(q)}$ 的密度。这个结果与 Fixman 建立、后由 Sprik 和 Ciccotti 阐明的用于描述约束聚合物统计特性的理论框架相一致。\n\n遵循此框架，从完整相空间到约束构象流形的投影引入了一个与约束坐标的度量相关的类雅可比因子。该因子被确定为 $\\sqrt{\\det(Z(q))}$，其中 $Z(q)$ 是一个度量张量矩阵，由 $Z_{ab}(q) = (\\nabla_q \\sigma_a)^\\top M^{-1} (\\nabla_q \\sigma_b)$ 给出。对于单个约束 $\\sigma(q)=0$ 和单位质量矩阵 $M=I$，该矩阵是一个 $1 \\times 1$ 矩阵，其唯一元素是：\n$$\nG(q) = (\\nabla\\sigma(q))^\\top I^{-1} (\\nabla\\sigma(q)) = (\\nabla\\sigma(q))^\\top (\\nabla\\sigma(q)) = \\lVert \\nabla\\sigma(q) \\rVert^2\n$$\n因此，该因子为 $\\sqrt{G(q)}$。因此，由约束相空间采样诱导的构象空间概率密度，表示为关于流形 $\\sigma(q)=0$ 上的自然弧长元 $\\mathrm{d}S$，由下式给出：\n$$\n\\rho_{\\text{bm}}(q) \\propto \\exp(-\\beta U(q)) \\sqrt{G(q)}\n$$\n下标“bm”表示这种“蓝月”（blue moon）或有偏边际分布。\n\n问题接着定义了期望的或“目标”构象空间分布。这是通过考虑无约束的构象吉布斯测度 $\\exp(-\\beta U(q)) \\mathrm{d}q$ 并简单地将其限制在约束流形上得到的。这种方法对应于沿流形定义一个自由能面或平均力势。相对于相同的弧长元 $\\mathrm{d}S$，其密度为：\n$$\n\\rho_{\\text{conf}}(q) \\propto \\exp(-\\beta U(q))\n$$\n这代表了物理上直观的分布，其中流形上的每个构象仅由其玻尔兹曼因子 $\\exp(-\\beta U(q))$ 加权。\n\n从约束 MD 模拟计算出的可观测量 $A(q)$ 的平均值将收敛于 $\\langle A \\rangle_{\\text{bm}}$，即在有偏分布 $\\rho_{\\text{bm}}$ 上的平均值。为了获得在目标分布 $\\langle A \\rangle_{\\text{conf}}$ 上的正确平均值，必须应用重加权。\n$$\n\\langle A \\rangle_{\\text{conf}} = \\frac{\\int A(q) \\rho_{\\text{conf}}(q) \\mathrm{d}S}{\\int \\rho_{\\text{conf}}(q) \\mathrm{d}S}\n$$\n一个重加权恒等式表明 $\\langle A \\rangle_{\\text{conf}} = \\frac{\\langle A \\cdot w \\rangle_{\\text{bm}}}{\\langle w \\rangle_{\\text{bm}}}$，其中 $w(q)$ 是重加权因子。这要求对于任何 $A(q)$，都有 $A(q) \\rho_{\\text{conf}}(q) \\propto (A(q) w(q)) \\rho_{\\text{bm}}(q)$，可简化为 $\\rho_{\\text{conf}}(q) \\propto w(q) \\rho_{\\text{bm}}(q)$。\n代入推导出的密度形式：\n$$\n\\exp(-\\beta U(q)) \\propto w(q) \\left( \\exp(-\\beta U(q)) \\sqrt{G(q)} \\right)\n$$\n这立即意味着重加权因子 $w(q)$ 必须是：\n$$\nw(q) \\propto \\frac{1}{\\sqrt{G(q)}}\n$$\n对于二维系统且 $M=I$ 的特定情况，这变为：\n$$\nw(q) = \\frac{1}{\\sqrt{\\lVert \\nabla\\sigma(q) \\rVert^2}} = \\frac{1}{\\lVert \\nabla\\sigma(q) \\rVert}\n$$\n（不计归一化常数）。这个因子校正了将约束相空间测度投影到构象空间时引入的采样偏倚。\n\n### 第2部分：数值实现策略\n\n数值测试旨在展示这种效应。实现的核心在于用极角 $\\theta \\in [0, 2\\pi)$ 参数化约束曲线 $\\sigma(x,y)=0$。对于每个 $\\theta$，通过求解 $\\sigma(r\\cos\\theta, r\\sin\\theta)=0$ 得到半径 $r(\\theta)$，从而确定位置 $q(\\theta) = (r(\\theta)\\cos\\theta, r(\\theta)\\sin\\theta)$。\n\n这三个概率密度表示为 $\\theta$ 的函数。关于弧长 $S$ 的密度通过链式法则与关于角度 $\\theta$ 的密度相关联：$\\rho(S) \\mathrm{d}S = \\rho(S(\\theta)) \\frac{\\mathrm{d}S}{\\mathrm{d}\\theta} \\mathrm{d}\\theta$。所以，未归一化的角密度为：\n1.  **目标密度**：$\\rho_{\\text{conf}}(\\theta) \\propto \\exp(-\\beta U(q(\\theta))) \\frac{\\mathrm{d}S}{\\mathrm{d}\\theta}$\n2.  **有偏密度**：$\\rho_{\\text{bm}}(\\theta) \\propto \\exp(-\\beta U(q(\\theta))) \\lVert \\nabla\\sigma(q(\\theta)) \\rVert \\frac{\\mathrm{d}S}{\\mathrm{d}\\theta}$\n3.  **校正后密度**：$\\rho_{\\text{corr}}(\\theta) \\propto \\rho_{\\text{bm}}(\\theta) w(q(\\theta)) = \\rho_{\\text{bm}}(\\theta) \\frac{1}{\\lVert\\nabla\\sigma(q(\\theta))\\rVert} = \\rho_{\\text{conf}}(\\theta)$\n\n弧长导数 $\\frac{\\mathrm{d}S}{\\mathrm{d}\\theta}$ 可由参数化 $q(\\theta)$ 得到：\n$$\n\\frac{\\mathrm{d}S}{\\mathrm{d}\\theta} = \\left\\lVert \\frac{\\mathrm{d}q}{\\mathrm{d}\\theta} \\right\\rVert = \\sqrt{ \\left(\\frac{\\mathrm{d}x}{\\mathrm{d}\\theta}\\right)^2 + \\left(\\frac{\\mathrm{d}y}{\\mathrm{d}\\theta}\\right)^2 }\n$$\n对于 $x(\\theta)=r(\\theta)\\cos\\theta$ 和 $y(\\theta)=r(\\theta)\\sin\\theta$，这简化为 $\\frac{\\mathrm{d}S}{\\mathrm{d}\\theta} = \\sqrt{r(\\theta)^2 + (\\mathrm{d}r/\\mathrm{d}\\theta)^2}$。导数 $\\mathrm{d}r/\\mathrm{d}\\theta$ 是通过对约束方程 $\\sigma(r(\\theta)\\cos\\theta, r(\\theta)\\sin\\theta)=0$ 关于 $\\theta$ 进行隐式微分得到的。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  在 $[0, 2\\pi)$ 上为 $\\theta$ 创建一个密集的 $N$ 个点的网格。\n2.  对于每个 $\\theta_i$，求解 $r_i=r(\\theta_i)$。\n3.  在每个点计算导数 $r'_i = \\mathrm{d}r/\\mathrm{d}\\theta$。\n4.  计算几何因子：位置 $q_i$、梯度范数 $\\lVert \\nabla\\sigma(q_i) \\rVert$ 和弧长导数 $(\\mathrm{d}S/\\mathrm{d}\\theta)_i$。\n5.  计算势能 $U(q_i)$。\n6.  构建三个未归一化的角密度向量 $\\rho_{\\text{conf}}$、$\\rho_{\\text{bm}}$ 和 $\\rho_{\\text{corr}}$。\n7.  通过除以各自的总和来归一化每个密度向量（积分元 $\\Delta\\theta$ 会被抵消）。\n8.  计算归一化目标密度与归一化有偏密度之间的 $\\ell_1$ 距离（朴素误差）。\n9.  计算归一化目标密度与归一化校正后密度之间的 $\\ell_1$ 距离。根据构造，该误差应为零（在浮点精度范围内），这为实现提供了一个稳健的检验。\n\n提供的三个测试用例可以清晰地展示这一点：\n- 用例1（圆形）：在曲线上 $\\lVert\\nabla\\sigma\\rVert$ 是常数。偏倚因子是均匀的，不会导致概率分布的扭曲。朴素误差和校正后误差都应为零。\n- 用例2（椭圆）和用例3（星形）：$\\lVert\\nabla\\sigma\\rVert$ 沿曲线变化，这会引入一个不可忽略的偏倚。朴素误差将是显著的，而校正后误差将保持接近于零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics sampling bias problem.\n    \"\"\"\n    \n    # Define test cases\n    # Each case is a dictionary containing the symbolic functions and parameters.\n    test_cases = [\n        {\n            \"sigma\": lambda x, y: x**2 + y**2 - 1.0,\n            \"grad_sigma\": lambda x, y: np.array([2.0 * x, 2.0 * y]),\n            \"U\": lambda x, y: 0.5 * (1.0 * x**2 + 1.0 * y**2),\n            \"beta\": 1.0,\n            \"r_solver\": lambda c, s: 1.0,\n            \"r_prime_solver\": lambda r, c, s, r_solver_func: 0.0,\n        },\n        {\n            \"sigma\": lambda x, y: x**2 + 4.0 * y**2 - 1.0,\n            \"grad_sigma\": lambda x, y: np.array([2.0 * x, 8.0 * y]),\n            \"U\": lambda x, y: 0.5 * (1.5 * x**2 + 0.5 * y**2),\n            \"beta\": 1.0,\n            \"r_solver\": lambda c, s: 1.0 / np.sqrt(c**2 + 4.0 * s**2),\n            \"r_prime_solver\": lambda r, c, s, r_solver_func: (3.0 * r**3 * s * c) / (r**2 * c**2 + 4.0 * r**2 * s**2),\n        },\n        {\n            \"sigma\": lambda x, y: x**4 + y**2 - 1.0,\n            \"grad_sigma\": lambda x, y: np.array([4.0 * x**3, 2.0 * y]),\n            \"U\": lambda x, y: 0.5 * (0.7 * x**2 + 2.0 * y**2),\n            \"beta\": 1.0,\n            \"r_solver\": lambda c, s: np.sqrt(\n                (-s**2 + np.sqrt(s**4 + 4.0 * c**4)) / (2.0 * c**4)\n            ) if abs(c)  1e-9 else 1.0,\n            \"r_prime_solver\": lambda r, c, s, r_solver_func: \n                (r * (2*r**2 * c**3 * s - s*c)) / (2*r**2 * c**4 + s**2) if abs(c)  1e-9 else 0.0,\n        }\n    ]\n\n    all_results = []\n    N_points = 10000\n\n    for case in test_cases:\n        sigma = case[\"sigma\"]\n        grad_sigma = case[\"grad_sigma\"]\n        U = case[\"U\"]\n        beta = case[\"beta\"]\n        r_solver = case[\"r_solver\"]\n        r_prime_solver = case[\"r_prime_solver\"]\n\n        # 1. Discretize theta\n        theta = np.linspace(0, 2 * np.pi, N_points, endpoint=False)\n        c, s = np.cos(theta), np.sin(theta)\n\n        # 2. Solve for r(theta)\n        r = np.array([r_solver(ci, si) for ci, si in zip(c, s)])\n\n        # 3. Compute r'(theta) for ds/dtheta\n        r_prime = np.array([r_prime_solver(ri, ci, si, r_solver) for ri, ci, si in zip(r, c, s)])\n\n        # 4. Compute ds/dtheta\n        ds_dtheta = np.sqrt(r**2 + r_prime**2)\n\n        # 5. Compute quantities on the curve\n        x, y = r * c, r * s\n        \n        # Potential energy\n        U_vals = U(x, y)\n        \n        # Gradient norm\n        grad_sigma_vals = grad_sigma(x, y)\n        grad_sigma_norm = np.linalg.norm(grad_sigma_vals, axis=0)\n\n        # 6. Form unnormalized densities\n        boltzmann_factor = np.exp(-beta * U_vals)\n        \n        # Target configuration marginal\n        rho_conf = boltzmann_factor * ds_dtheta\n        \n        # Biased phase-space induced marginal\n        rho_bm = boltzmann_factor * grad_sigma_norm * ds_dtheta\n        \n        # Corrected marginal\n        rho_corr = rho_bm / grad_sigma_norm\n\n        # 7. Normalize densities\n        # The integration element dtheta is constant and cancels out.\n        P_conf = rho_conf / np.sum(rho_conf)\n        P_bm = rho_bm / np.sum(rho_bm)\n        P_corr = rho_corr / np.sum(rho_corr)\n        \n        # 8. Compute L1 distances\n        # The sum of absolute differences of the probability mass functions\n        error_naive = np.sum(np.abs(P_conf - P_bm))\n        error_corrected = np.sum(np.abs(P_conf - P_corr))\n\n        all_results.append([error_naive, error_corrected])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'[{e_n},{e_c}]' for e_n, e_c in all_results])}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3403498"}]}