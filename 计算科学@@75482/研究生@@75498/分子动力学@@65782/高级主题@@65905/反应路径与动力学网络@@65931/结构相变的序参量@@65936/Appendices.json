{"hands_on_practices": [{"introduction": "静态结构因子 $S(\\mathbf{k})$ 是凝聚态物理学的基石，它不仅可以通过散射实验直接测量，还能通过计算来表征系统的结构。这个练习将指导你通过编程，从原子坐标计算 $S(\\mathbf{k})$，并利用其在倒易空间中的特征来区分无序的液相和有序的晶相（如体心立方BCC和面心立方FCC）。通过这项实践，你将掌握从微观坐标到宏观结构分类的基本分析方法 [@problem_id:3430930]。", "problem": "给定一个三维周期性晶胞中的一小组原子坐标，要求您在一组离散波矢格点上计算静态结构因子，然后根据得到的峰图对相进行分类。静态结构因子是根据微观数密度定义的，必须从第一性原理计算得出。\n\n基本原理：\n- 微观数密度定义为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$，其中 $N$ 是原子数，$\\mathbf{r}_j$ 是原子的位置。\n- 其傅里叶变换为 $\\rho_{\\mathbf{k}} = \\int \\rho(\\mathbf{r}) e^{i \\mathbf{k} \\cdot \\mathbf{r}} \\, d^3r = \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$。\n- 静态结构因子定义为 $S(\\mathbf{k}) = \\frac{1}{N} \\left| \\rho_{\\mathbf{k}} \\right|^2 = \\frac{1}{N} \\left| \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2$。\n\n周期性边界条件意味着，对于一个线性尺寸为 $L_x = L_y = L_z = a$ 的立方晶胞，与周期性盒子相容的离散波矢为 $\\mathbf{k} = \\frac{2\\pi}{a} (m_x, m_y, m_z)$，其中 $m_x, m_y, m_z$ 是整数。在本问题中，使用一个均匀的整数组 $(m_x, m_y, m_z)$ 格点，其范围为 $m_\\alpha \\in \\{-M, -M+1, \\dots, M-1, M\\}$（$\\alpha \\in \\{x,y,z\\}$），并排除零矢量 $(0,0,0)$。所有位置 $\\mathbf{r}_j$ 以埃（Å）为单位表示，所有波矢分量 $k_\\alpha$ 以逆埃（Å$^{-1}$）为单位表示。\n\n相分类目标：\n- 使用计算出的 $S(\\mathbf{k})$ 值将构型分为以下三类之一，并以整数编码：\n  - $0$：无序（类液态），\n  - $1$：体心立方（BCC），\n  - $2$：面心立方（FCC）。\n- 分类必须仅基于 $S(\\mathbf{k})$ 的峰图以及从基元引起的干涉推导出的倒易点阵选择定则：\n  - 对于一个原子位于 $\\mathbf{0}$ 和 $\\frac{a}{2}(1,1,1)$ 的体心立方基元，其基元的结构因子为 $F(h,k,l) = 1 + e^{i\\pi(h+k+l)}$，因此当 $h+k+l$ 为偶数时出现非零峰。模长最小的非零峰满足 $h^2 + k^2 + l^2 = 2$（$\\{110\\}$ 晶面族）。\n  - 对于一个原子位于 $\\mathbf{0}$、$\\frac{a}{2}(0,1,1)$、$\\frac{a}{2}(1,0,1)$ 和 $\\frac{a}{2}(1,1,0)$ 的面心立方基元，其基元的结构因子为 $F(h,k,l) = 1 + e^{i\\pi(k+l)} + e^{i\\pi(h+l)} + e^{i\\pi(h+k)}$，因此当 $h,k,l$ 全为偶数或全为奇数时出现非零峰。模长最小的非零峰满足 $h^2 + k^2 + l^2 = 3$（$\\{111\\}$ 晶面族）。\n- 为区分无序态与晶态，将 $S(\\mathbf{k})$ 的最大值与 $N$ 进行比较，方法如下。定义 $R = \\frac{\\max_{\\mathbf{k}} S(\\mathbf{k})}{N}$。若 $R  \\tau$ (其中 $\\tau = 0.6$)，则分类为无序 ($0$)。否则，如果为晶态，则确定最强峰是否遵循 BCC 或 FCC 的奇偶规则，以及它们的最小非零 $h^2+k^2+l^2$ 是否分别匹配 $2$ 或 $3$。使用这些标准将其分类为 BCC ($1$) 或 FCC ($2$)。如果标准冲突，则回退到匹配大多数顶峰的奇偶规则。\n\n算法任务：\n1. 对于每个测试用例，使用上述定义在指定的格点上计算 $S(\\mathbf{k})$。使用格点范围参数 $M=3$。\n2. 对于每个用例，计算 $R = \\max_{\\mathbf{k}} S(\\mathbf{k}) / N$。如果 $R  0.6$，输出 $0$。\n3. 如果 $R \\ge 0.6$，识别顶峰集合，定义为满足 $S(\\mathbf{k}) \\ge 0.99 \\cdot \\max_{\\mathbf{k}} S(\\mathbf{k})$ 的那些 $\\mathbf{k}$。在这些顶峰中，计算：\n   - $h^2+k^2+l^2$ 的最小非零值，其中 $(h,k,l) = (m_x, m_y, m_z)$，并检查其是否等于 $2$ 或 $3$。\n   - 奇偶规则计数：$h+k+l$ 为偶数（BCC 允许）的顶峰数量，以及 $h,k,l$ 全为偶数或全为奇数（FCC 允许）的顶峰数量。\n4. 如果顶峰中的最小非零 $h^2+k^2+l^2$ 为 $2$，且大多数顶峰满足 $h+k+l$ 为偶数，则分类为 BCC ($1$)；如果顶峰中的最小非零 $h^2+k^2+l^2$ 为 $3$，且大多数顶峰满足全偶或全奇规则，则分类为 FCC ($2$)。在任何其他晶态情况下，根据具有较多计数的奇偶规则（BCC 或 FCC）来选择类别。如果两种规则都没有严格多数，则分类为无序 ($0$)。\n\n测试套件：\n使用以下四个测试用例。在所有情况下，立方盒子的边长为 $a = 3.0$ Å，波矢格点使用 $M=3$。\n- 用例 1（理想 BCC）：$N=2$ 个原子，位置为 $\\mathbf{r}_1 = (0,0,0)$ Å 和 $\\mathbf{r}_2 = \\left(\\frac{a}{2},\\frac{a}{2},\\frac{a}{2}\\right)$ Å。\n- 用例 2（理想 FCC）：$N=4$ 个原子，位置为 $\\mathbf{r}_1 = (0,0,0)$ Å、$\\mathbf{r}_2 = \\left(0,\\frac{a}{2},\\frac{a}{2}\\right)$ Å、$\\mathbf{r}_3 = \\left(\\frac{a}{2},0,\\frac{a}{2}\\right)$ Å 和 $\\mathbf{r}_4 = \\left(\\frac{a}{2},\\frac{a}{2},0\\right)$ Å。\n- 用例 3（无序）：$N=64$ 个原子，其位置是使用固定种子 $s=42$ 的伪随机数生成器，沿每个笛卡尔坐标轴从 $[0,a)$ 中独立均匀采样得到的；即 $\\mathbf{r}_j$ 的分量 $x_j, y_j, z_j \\sim \\mathrm{Uniform}(0,a)$，对于 $j=1,\\dots,64$，使用所述种子。\n- 用例 4（含噪声的 BCC）：从用例 1 的 BCC 位置开始，对每个原子的每个笛卡尔分量添加独立的、均值为零、标准差为 $\\sigma = 0.1$ Å 的高斯位移，即 $\\mathbf{r}_j \\leftarrow \\mathbf{r}_j + \\boldsymbol{\\eta}_j$，其中 $\\boldsymbol{\\eta}_j$ 的分量是从 $\\mathcal{N}(0,\\sigma^2)$ 中采样得到的，使用种子 $s=7$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用例 1 到 4 的分类结果，形式为用方括号括起来的逗号分隔的整数列表（例如，\"[1,2,0,1]\"）。不应打印任何额外的文本。整数必须按上述用例的顺序列出。", "solution": "该问题要求将原子构型分类为无序相、体心立方（BCC）相或面心立方（FCC）相。这是通过计算静态结构因子 $S(\\mathbf{k})$ 并分析其在倒易空间中的峰图来实现的。该过程基于晶体学和统计力学的基本原理。\n\n第一步是为给定的 $N$ 个原子位置集合 $\\{\\mathbf{r}_j\\}$ 计算静态结构因子 $S(\\mathbf{k})$。结构因子通过微观数密度 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$ 的傅里叶变换来定义。在给定波矢 $\\mathbf{k}$ 处的傅里叶分量 $\\rho_{\\mathbf{k}}$ 为：\n$$\n\\rho_{\\mathbf{k}} = \\int \\rho(\\mathbf{r}) e^{i \\mathbf{k} \\cdot \\mathbf{r}} \\, d^3r = \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\n静态结构因子 $S(\\mathbf{k})$ 则定义为此复数量的归一化模平方：\n$$\nS(\\mathbf{k}) = \\frac{1}{N} \\left| \\rho_{\\mathbf{k}} \\right|^2 = \\frac{1}{N} \\left| \\sum_{j=1}^{N} e^{i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2\n$$\n对于边长为 $a$ 的立方周期性晶胞内的系统，与周期性边界条件相容的波矢 $\\mathbf{k}$ 在倒易空间中形成一个离散格点：\n$$\n\\mathbf{k} = \\frac{2\\pi}{a} (m_x, m_y, m_z)\n$$\n其中 $m_x$、$m_y$ 和 $m_z$ 是整数。问题指定我们在一个格点上计算 $S(\\mathbf{k})$，其中每个整数分量 $m_\\alpha$ 的范围是从 $-M$ 到 $M$，且 $M=3$。中心点 $\\mathbf{k}=\\mathbf{0}$（对应于 $(m_x, m_y, m_z)=(0,0,0)$）被排除，因为 $S(\\mathbf{0})=N$，不携带结构信息。\n\n第二步是分类算法，该算法分析计算出的 $S(\\mathbf{k})$ 值。\n首先，区分无序（类液态）状态和有序（晶态）状态。在完美晶体中，相长干涉导致尖锐的布拉格峰，其中 $S(\\mathbf{k})$ 与 $N$ 成正比。在液体中，对于 $\\mathbf{k} \\neq \\mathbf{0}$，$S(\\mathbf{k})$ 通常为 1 的量级。我们通过计算比率 $R = \\frac{\\max_{\\mathbf{k}} S(\\mathbf{k})}{N}$ 来量化这一点。如果 $R$ 低于阈值 $\\tau=0.6$，则系统被分类为无序（类 $0$）。\n\n如果 $R \\ge 0.6$，则认为构型是晶态的，我们进而区分 BCC 和 FCC 结构。这是通过检查倒易空间中最强峰的位置来完成的。这些位置由晶体基元决定的选择定则所支配。\n- 对于 BCC 晶格，当米勒指数 $(h,k,l)$（对应于我们的整数组 $(m_x,m_y,m_z)$）之和 $h+k+l$ 为偶数时，发生相长干涉（非零峰）。模长最小的倒易点阵矢量集对应于 $\\{110\\}$ 晶面族，其中 $h^2+k^2+l^2=2$。\n- 对于 FCC 晶格，当指数 $(h,k,l)$ 全为偶数或全为奇数（奇偶性一致）时，发生相长干涉。模长最小的非零倒易点阵矢量集是 $\\{111\\}$ 晶面族，其中 $h^2+k^2+l^2=3$。\n\n该算法识别出“顶峰”集合，其中 $S(\\mathbf{k})$ 至少是全局最大值的 $99\\%$。利用这个峰集，它检查两个条件：\n1. 顶峰中 $m_x^2+m_y^2+m_z^2$ 的最小非零值。\n2. 顶峰指数对 BCC 和 FCC 奇偶性选择定则的遵守情况。\n\n最终分类遵循一个分层逻辑：\n- 如果一个构型的顶峰指数的最小模平方为 $2$，并且其大多数顶峰满足 BCC 奇偶规则（$m_x+m_y+m_z$ 为偶数），则将其分类为 BCC（类 $1$）。\n- 如果最小模平方为 $3$，并且其大多数顶峰满足 FCC 奇偶规则（所有指数均为偶数或均为奇数），则将其分类为 FCC（类 $2$）。\n- 如果这些主要条件都不满足，则使用回退机制：将结构分配给其奇偶规则被更多顶峰满足的类别（BCC 或 FCC）。\n- 如果两种奇偶规则的计数相等，则无法明确分类该结构，并将其分配为无序类 $0$。\n\n此过程应用于四个测试用例：一个理想的 BCC 基元，一个理想的 FCC 基元，一个随机生成的无序构型，以及一个添加了类热噪声的 BCC 基元。实现过程涉及生成波矢格点，为每个用例计算 $S(\\mathbf{k})$，并应用分类逻辑来确定最终的相指派。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes the static structure factor for several atomic configurations\n    and classifies them as disordered, BCC, or FCC.\n    \"\"\"\n\n    # Define common parameters from the problem statement.\n    a = 3.0  # Angstrom\n    M = 3\n    tau = 0.6\n    \n    # --- Test Case Definitions ---\n    test_cases = []\n\n    # Case 1: Ideal BCC\n    pos1 = np.array([[0.0, 0.0, 0.0], [a / 2, a / 2, a / 2]])\n    test_cases.append(pos1)\n\n    # Case 2: Ideal FCC\n    pos2 = np.array([[0.0, 0.0, 0.0], [0.0, a / 2, a / 2], [a / 2, 0.0, a / 2], [a / 2, a / 2, 0.0]])\n    test_cases.append(pos2)\n\n    # Case 3: Disordered\n    rng_disordered = np.random.default_rng(seed=42)\n    pos3 = rng_disordered.uniform(0, a, size=(64, 3))\n    test_cases.append(pos3)\n\n    # Case 4: Noisy BCC\n    rng_noisy = np.random.default_rng(seed=7)\n    pos4_ideal = np.array([[0.0, 0.0, 0.0], [a / 2, a / 2, a / 2]])\n    noise = rng_noisy.normal(loc=0.0, scale=0.1, size=pos4_ideal.shape)\n    pos4 = pos4_ideal + noise\n    test_cases.append(pos4)\n\n    results = []\n    for positions in test_cases:\n        classification = process_case(positions, a, M, tau)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(positions: np.ndarray, a: float, M: int, tau: float) -> int:\n    \"\"\"\n    Performs classification for a single set of atomic positions.\n    \"\"\"\n    N = positions.shape[0]\n    if N == 0:\n        return 0\n\n    # 1. Generate k-vector grid and compute S(k)\n    m_range = range(-M, M + 1)\n    m_triplets = [m for m in itertools.product(m_range, repeat=3) if m != (0, 0, 0)]\n    m_array = np.array(m_triplets, dtype=np.float64)\n    \n    k_vectors = (2 * np.pi / a) * m_array\n    \n    # Vectorized computation of S(k)\n    k_dot_r = k_vectors @ positions.T\n    rho_k = np.sum(np.exp(1j * k_dot_r), axis=1)\n    s_k_values = (1.0 / N) * np.abs(rho_k)**2\n\n    # 2. Compute R = max(S(k)) / N and check for disordered state\n    s_max = np.max(s_k_values)\n    R = s_max / N\n    if R  tau:\n        return 0  # Classify as disordered\n        \n    # 3. Crystalline analysis\n    # Identify top peaks\n    top_peaks_indices = np.where(s_k_values >= 0.99 * s_max)[0]\n    top_m_triplets = [m_triplets[i] for i in top_peaks_indices]\n\n    if not top_m_triplets:\n        return 0 # Should not happen, but as a safeguard\n\n    # Compute minimal non-zero h^2+k^2+l^2 for top peaks\n    hkl_sq_sums = [h**2 + k**2 + l**2 for h, k, l in top_m_triplets]\n    min_h2k2l2 = min(hkl_sq_sums)\n\n    # Count peaks satisfying BCC and FCC parity rules\n    bcc_count = 0\n    fcc_count = 0\n    for h, k, l in top_m_triplets:\n        # BCC rule: h+k+l is even\n        if (h + k + l) % 2 == 0:\n            bcc_count += 1\n        # FCC rule: h, k, l all even or all odd\n        if (h % 2 == k % 2) and (k % 2 == l % 2):\n            fcc_count += 1\n            \n    # 4. Apply hierarchical classification logic\n    num_top_peaks = len(top_m_triplets)\n    \n    # Primary classification rules\n    if min_h2k2l2 == 2 and bcc_count > num_top_peaks / 2.0:\n        return 1\n    if min_h2k2l2 == 3 and fcc_count > num_top_peaks / 2.0:\n        return 2\n\n    # Fallback rules based on larger count\n    if bcc_count > fcc_count:\n        return 1\n    if fcc_count > bcc_count:\n        return 2\n        \n    # Final tie-breaker: if counts are equal, classify as disordered\n    return 0\n\nsolve()\n```", "id": "3430930"}, {"introduction": "超越传统的傅里叶分析方法，现代结构表征越来越多地采用基于图论的工具来描述复杂和非均质系统。本练习将引导你将粒子系统定义为一个邻接图，并运用谱图理论来分析其性质。你将学习如何计算图拉普拉斯矩阵的第二个最小特征值 $\\lambda_2$（也称为代数连通度），并将其作为一个强大的序参量，用以量化系统的连通性，这对于理解逾渗、成胶和结晶成核等现象至关重要 [@problem_id:3430923]。", "problem": "给定一个序列的粒子构型，这些粒子位于一个采用最小镜像约定定义的周期性边界条件（PBC）的立方盒子中，并使用固定的邻居截断距离。目标是根据邻居图的图拉普拉斯算子定义一个谱序参数，并跟踪不同构型下最小的非零特征值，以将其与结构转变过程中的连通性变化联系起来。请实现一个程序，该程序对每个构型，构建其邻居图，形成其组合拉普拉斯算子，并返回最小的严格正特征值作为谱序参数。请使用以下基本原理来推导您的实现：通过最小镜像约定在PBC下的欧几里得距离、从截断准则导出的图邻接关系、度矩阵和组合拉普拉斯算子，以及实对称矩阵的谱。\n\n使用的定义：\n- 假设在一个边长为 $L$（单位为纳米）的立方盒子中有 $N$ 个粒子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$。PBC适用于每个坐标方向。对于任意一对粒子 $(i,j)$，经PBC调整的位移 $\\Delta \\mathbf{r}_{ij}$ 是通过对每个笛卡尔分量索引 $\\alpha$ 进行逐分量操作 $\\Delta r_{ij,\\alpha} \\leftarrow \\Delta r_{ij,\\alpha} - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta r_{ij,\\alpha}}{L}\\right)$ 得到的，其中 $\\Delta \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。PBC欧几里得距离为 $d_{ij} = \\|\\Delta \\mathbf{r}_{ij}\\|_2$。\n- 给定一个截断距离 $r_c$（单位为纳米），定义无权邻接矩阵 $A$ 为：如果 $i \\neq j$ 且 $d_{ij} \\le r_c$，则 $A_{ij} = 1$；否则 $A_{ij} = 0$。\n- 定义度矩阵 $D$ 为：$D_{ii} = \\sum_{j=1}^{N} A_{ij}$，且当 $i \\neq j$ 时 $D_{ij} = 0$。\n- 定义组合拉普拉斯算子 $L_{\\mathrm{graph}} = D - A$。\n- 设实对称矩阵 $L_{\\mathrm{graph}}$ 的特征值为 $\\{\\lambda_k\\}_{k=1}^{N}$，按非递减顺序排列。将谱序参数定义为最小的严格正特征值，记为 $\\lambda_2$，其中对于一个小的数值容差 $\\varepsilon$，所有满足 $\\lambda_k \\le \\varepsilon$ 的特征值 $\\lambda_k$ 都被认为是零。如果不存在严格正特征值（例如，对于一个完全不连通的图），则定义 $\\lambda_2 = 0.0$。将 $\\lambda_2$ 作为无量纲实数报告。\n\n在一个单一程序中实现上述逻辑，处理以下构型测试套件。距离和盒子长度的单位是纳米；返回的 $\\lambda_2$ 是无量纲单位。对所有特征值正性检查使用相同的数值容差 $\\varepsilon = 10^{-10}$。\n\n测试套件：\n- 测试用例 1（不连通构型，健全性检查）：\n  - 盒子长度 $L = 10.0$。\n  - 截断距离 $r_c = 0.5$。\n  - $N=6$ 时的位置：$(0.0,0.0)$, $(5.0,5.0)$, $(9.0,1.0)$, $(1.0,9.0)$, $(2.0,7.0)$, $(7.0,2.0)$。\n  - 预期的定性行为：没有边；$\\lambda_2$ 应为 $0.0$。\n- 测试用例 2（路径图构型，典型的连通但稀疏）：\n  - 盒子长度 $L = 3.0$。\n  - 截断距离 $r_c = 0.5$。\n  - $N=6$ 时的位置：$(0.1,1.5)$, $(0.5,1.5)$, $(0.9,1.5)$, $(1.3,1.5)$, $(1.7,1.5)$, $(2.1,1.5)$。\n  - 预期的定性行为：一个线性链，仅在最近邻之间有边；$\\lambda_2$ 应该很小但为严格正值。\n- 测试用例 3（双粒子PBC邻近，PBC边界情况）：\n  - 盒子长度 $L = 1.0$。\n  - 截断距离 $r_c = 0.2$。\n  - $N=2$ 时的位置：$(0.95,0.50)$, $(0.05,0.50)$。\n  - 预期的定性行为：通过PBC跨越边界相连；$\\lambda_2$ 应为严格正值。\n- 测试用例 4（跨越连通性转变的轨迹，帧序列）：\n  - 盒子长度 $L = 2.0$。\n  - 截断距离 $r_c = 0.35$。\n  - 每个帧有 $N=8$ 个粒子，排列成两个各含4个点的簇。簇的模式是 $\\{(0.00,0.00),(0.10,0.00),(0.00,0.10),(0.10,0.10)\\}$ 这组偏移量加到簇中心上。第一个簇的中心固定在 $(0.20,0.20)$。第二个簇的中心在不同帧之间移动：\n    - 帧 1：$(1.60,1.60)$，\n    - 帧 2：$(1.70,1.70)$，\n    - 帧 3：$(1.80,1.80)$，\n    - 帧 4：$(1.90,1.90)$，\n    - 帧 5：$(1.95,1.95)$。\n  - 预期的定性行为：最初是不连通的簇，然后随着移动的簇在PBC下靠近，出现跨簇的边；按顺序报告一个 $\\lambda_2$ 值的列表，每帧一个值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须有四个元素，分别对应四个测试用例，其中前三个元素是实数，第四个元素是对应于测试用例4中各帧的实数列表。例如，输出应具有结构形式 $[\\lambda_2^{(1)},\\lambda_2^{(2)},\\lambda_2^{(3)},[\\lambda_2^{(4,1)},\\lambda_2^{(4,2)},\\lambda_2^{(4,3)},\\lambda_2^{(4,4)},\\lambda_2^{(4,5)}]]$，其中的数值由您的程序计算得出。", "solution": "该问题是有效的，因为它在科学上是合理的、良构的且客观的。它基于计算物理学和谱图论中的既定原则，提出了一个清晰的、算法上定义的任务。\n\n目标是为几种粒子构型计算一个谱序参数，记为 $\\lambda_2$。该参数被定义为系统组合图拉普拉斯算子的最小严格正特征值。$\\lambda_2$ 的值量化了粒子系统的连通性，为结构转变提供了洞见。其方法包括构建粒子系统的图表示，计算其拉普拉斯矩阵，然后从其谱中找到所需的特征值。\n\n**1. 系统表示与周期性边界条件 (PBC)**\n\n一个包含 $N$ 个粒子的系统由它们在边长为 $L$ 的立方盒子中的位置 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ 来描述。虽然问题提到的是立方盒子，但提供的测试用例使用的是二维坐标。这通过在二维中执行所有计算来处理，实际上是模拟一个方形周期盒子中的二维系统。\n\n任意两个粒子 $i$ 和 $j$ 之间的距离必须考虑到模拟盒子的周期性。这是通过使用最小镜像约定来完成的。首先计算位移矢量 $\\Delta \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。然后，该矢量的每个笛卡尔分量 $\\Delta r_{ij, \\alpha}$ 根据规则进行调整：\n$$\n\\Delta r'_{ij, \\alpha} = \\Delta r_{ij, \\alpha} - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta r_{ij, \\alpha}}{L}\\right)\n$$\n此操作将每个位移分量映射到区间 $[-L/2, L/2]$ 中，确保我们找到连接两个粒子（或其周期性镜像）的最短矢量。经PBC调整的距离 $d_{ij}$ 则是调整后位移矢量的欧几里得范数，即 $d_{ij} = \\|\\Delta \\mathbf{r}'_{ij}\\|_2$。\n\n**2. 邻居图与邻接矩阵**\n\n基于计算出的距离，构建一个邻居图。粒子作为顶点，如果两个粒子之间的距离小于或等于指定的截断距离 $r_c$，则它们之间存在一条边。这种关系由无权邻接矩阵 $A$ 捕获，它是一个 $N \\times N$ 矩阵，定义如下：\n$$\nA_{ij} = \n\\begin{cases} \n1  \\text{if } i \\neq j \\text{ and } d_{ij} \\le r_c \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n根据定义，$A$ 是一个对角线元素为零的对称矩阵。\n\n**3. 组合图拉普拉斯算子**\n\n组合拉普拉斯算子 $L_{\\mathrm{graph}}$ 是图的一种矩阵表示，是谱图论的核心。它由邻接矩阵 $A$ 和度矩阵 $D$ 导出。\n\n度矩阵 $D$ 是一个对角矩阵，其中每个对角元素 $D_{ii}$ 表示顶点 $i$ 的度——即它拥有的邻居数量。其计算方式为：\n$$\nD_{ii} = \\sum_{j=1}^{N} A_{ij}\n$$\n组合拉普拉斯算子随后被定义为度矩阵与邻接矩阵之差：\n$$\nL_{\\mathrm{graph}} = D - A\n$$\n$L_{\\mathrm{graph}}$ 是一个实对称半正定矩阵。\n\n**4. 谱分析与序参数 $\\boldsymbol{\\lambda_2}$**\n\n$L_{\\mathrm{graph}}$ 的特征值，记为 $\\{\\lambda_k\\}_{k=1}^{N}$ 并按非递减顺序排列（$0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_N$），构成了图的谱。零特征值的数量等于图中连通分量的数量。对于任何连通图，$\\lambda_1 = 0$ 并且所有其他特征值都是严格正的。第二小的特征值 $\\lambda_2$ 被称为代数连通度，它衡量了图的连通性好坏。\n\n问题将符号 $\\lambda_2$ 重新定义为**最小的严格正特征值**。为了找到这个值，我们计算 $L_{\\mathrm{graph}}$ 的完整谱。由于 $L_{\\mathrm{graph}}$ 是实对称的，`numpy.linalg.eigh` 是一个合适且高效的数值工具。它返回按非递减顺序排序的特征值。我们遍历这个排序后的列表，并找出第一个大于给定数值容差 $\\varepsilon = 10^{-10}$ 的特征值 $\\lambda_k$。这个值就是我们的序参数。如果所有特征值都小于或等于 $\\varepsilon$（例如，对于没有边的图），则序参数定义为 $0.0$。\n\n这个过程被封装在一个 Python 函数中。然后将该函数应用于每个测试用例，包括测试用例4的多帧轨迹，以生成所需的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the spectral order parameter for each test case.\n    The order parameter is the smallest strictly positive eigenvalue of the graph Laplacian.\n    \"\"\"\n\n    # Numerical tolerance for checking if an eigenvalue is positive.\n    EPSILON = 1e-10\n\n    def calculate_lambda2(positions: np.ndarray, L: float, r_c: float) -> float:\n        \"\"\"\n        Calculates the smallest strictly positive eigenvalue of the graph Laplacian.\n\n        Args:\n            positions (np.ndarray): An (N, D) array of particle positions.\n            L (float): The length of the cubic/square box.\n            r_c (float): The neighbor cutoff distance.\n        \n        Returns:\n            float: The smallest strictly positive eigenvalue, or 0.0 if none exists.\n        \"\"\"\n        N = positions.shape[0]\n        \n        if N == 0:\n            return 0.0\n\n        # Construct the adjacency matrix A\n        A = np.zeros((N, N), dtype=int)\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Calculate displacement vector\n                delta_r = positions[j] - positions[i]\n                \n                # Apply Minimum Image Convention for Periodic Boundary Conditions\n                delta_r = delta_r - L * np.round(delta_r / L)\n                \n                # Calculate Euclidean distance\n                distance = np.linalg.norm(delta_r)\n                \n                if distance = r_c:\n                    A[i, j] = 1\n                    A[j, i] = 1\n\n        # Construct the degree matrix D\n        degrees = np.sum(A, axis=1)\n        D = np.diag(degrees)\n\n        # Construct the combinatorial Laplacian L = D - A\n        L_graph = D - A\n\n        # Calculate eigenvalues of the real symmetric Laplacian matrix\n        # numpy.linalg.eigh returns eigenvalues sorted in non-decreasing order\n        eigenvalues = np.linalg.eigh(L_graph)[0]\n\n        # Find the smallest strictly positive eigenvalue\n        smallest_positive_eigenvalue = 0.0\n        for val in eigenvalues:\n            if val > EPSILON:\n                smallest_positive_eigenvalue = float(val)\n                break\n        \n        return smallest_positive_eigenvalue\n\n    # Process test cases\n    results = []\n\n    # Test case 1\n    L1 = 10.0\n    rc1 = 0.5\n    pos1 = np.array([(0.0, 0.0), (5.0, 5.0), (9.0, 1.0), (1.0, 9.0), (2.0, 7.0), (7.0, 2.0)])\n    results.append(calculate_lambda2(pos1, L1, rc1))\n\n    # Test case 2\n    L2 = 3.0\n    rc2 = 0.5\n    pos2 = np.array([(0.1, 1.5), (0.5, 1.5), (0.9, 1.5), (1.3, 1.5), (1.7, 1.5), (2.1, 1.5)])\n    results.append(calculate_lambda2(pos2, L2, rc2))\n\n    # Test case 3\n    L3 = 1.0\n    rc3 = 0.2\n    pos3 = np.array([(0.95, 0.50), (0.05, 0.50)])\n    results.append(calculate_lambda2(pos3, L3, rc3))\n\n    # Test case 4\n    L4 = 2.0\n    rc4 = 0.35\n    cluster_offsets = np.array([(0.00, 0.00), (0.10, 0.00), (0.00, 0.10), (0.10, 0.10)])\n    cluster1_center = np.array([0.20, 0.20])\n    cluster2_centers = [\n        np.array([1.60, 1.60]),\n        np.array([1.70, 1.70]),\n        np.array([1.80, 1.80]),\n        np.array([1.90, 1.90]),\n        np.array([1.95, 1.95])\n    ]\n    \n    pos_cluster1 = cluster1_center + cluster_offsets\n    \n    lambda2_4_list = []\n    for c2_center in cluster2_centers:\n        pos_cluster2 = c2_center + cluster_offsets\n        pos4 = np.concatenate((pos_cluster1, pos_cluster2))\n        lambda2_frame = calculate_lambda2(pos4, L4, rc4)\n        lambda2_4_list.append(lambda2_frame)\n    results.append(lambda2_4_list)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3430923"}, {"introduction": "在识别了静态结构之后，下一步是理解结构之间转变的动力学过程。这个高级练习将引导你使用序参量的时间序列数据来构建马尔可夫状态模型（MSM），这是一种强大的动力学建模工具。你将学习如何通过检验查普曼-科尔莫戈罗夫（Chapman-Kolmogorov）特性来验证MSM的有效性，这是确保模型能够准确捕捉系统动力学的关键步骤，从而将静态的结构分析提升到对动态过程的定量理解 [@problem_id:3430948]。", "problem": "给定一个一维结构序参数 $q(t)$，它是从合成的分子动力学中以均匀时间间隔 $\\Delta t$ 采样的。目标是通过将 $q(t)$ 分箱到离散状态来构建马尔可夫状态模型（MSM），并检验结构转变动力学的 Chapman–Kolmogorov 属性。您的方法应基于离散时间马尔可夫链、转移概率矩阵和 Chapman–Kolmogorov 方程的基本定义。请使用以下原理：马尔可夫过程的特性是其未来演化仅取决于当前状态；如果 $X_t$ 是一个具有单步转移矩阵 $T(\\Delta t)$ 的平稳马尔可夫链，那么对于任何整数 $k \\geq 1$，其 k 步转移矩阵满足 $T(k \\Delta t) = T(\\Delta t)^k$。MSM 的构建方法是：将连续的序参数 $q(t)$ 离散化为 $M$ 个区间（bin），并估计在选定的延迟时间 $\\tau = \\ell \\Delta t$ 下各区间之间的转移概率。\n\n按以下步骤构建 MSM：\n- 使用指定的区间边界将时间序列 $q(t)$ 离散化为 $M$ 个区间，生成离散序列 $b_t \\in \\{0,1,\\dots,M-1\\}$。\n- 对于给定的延迟步长 $\\ell \\in \\mathbb{N}$（因此延迟时间为 $\\tau = \\ell \\Delta t$），估计计数矩阵 $C(\\tau)$。其元素 $C_{ij}(\\tau)$ 等于在离散序列中观测到的从 $b_t = i$ 到 $b_{t+\\ell} = j$ 的转移次数，对所有有效索引对求和。\n- 使用拉普拉斯平滑（$\\alpha = 1$）获得转移概率矩阵 $T(\\tau)$：对每一行 $i$，计算\n$$\nT_{ij}(\\tau) = \\frac{C_{ij}(\\tau) + \\alpha}{\\sum_{k=0}^{M-1} \\left(C_{ik}(\\tau) + \\alpha\\right)}.\n$$\n- 为检验 Chapman–Kolmogorov 属性，计算偏差\n$$\n\\delta(\\ell,k) = \\max_{i,j} \\left| T_{ij}(k \\tau) - \\left[T(\\tau)^k\\right]_{ij} \\right|,\n$$\n其中 $k \\in \\mathbb{N}$ 是一个乘数，$T(\\tau)^k$ 是矩阵的 $k$ 次幂。如果对于指定的阈值 $\\varepsilon > 0$，有 $\\delta(\\ell,k) \\leq \\varepsilon$，则声明该属性“成立”（holds）。\n\n假设采样间隔为 $\\Delta t = 1$ 皮秒 (ps)。所有延迟时间都应以皮秒为单位处理。不涉及角度量。此任务中没有百分比。\n\n实现一个程序，用于生成合成数据 $q(t)$，并对以下三个测试用例评估 $\\delta(\\ell,k)$。为保证可复现性，请使用提供的种子进行确定性的伪随机初始化。在每种情况下，确保状态到 $q$ 的映射使 $q(t)$ 保持在给定的分箱范围内，并且分箱操作是将 $q(t)$ 分配到包含它的唯一区间中。\n\n测试用例 1（构建良好的 MSM；预期满足 Chapman–Kolmogorov 属性）：\n- 基于 $S_t \\in \\{0,1\\}$ 的隐马尔可夫链，其转移矩阵为\n$$\nT^{(1)} = \\begin{pmatrix}\n0.999  0.001 \\\\\n0.001  0.999\n\\end{pmatrix}.\n$$\n- 长度 $N^{(1)} = 200{,}000$ 步。\n- 初始化种子 $s_1 = 123$。\n- 将状态映射到序参数：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -1.0$ 且 $\\mu_1 = +1.0$（无观测噪声）。\n- 分箱数 $M^{(1)} = 2$，边界为 $\\{-2.0, 0.0, 2.0\\}$，得到区间 $[-2.0,0.0)$ 和 $[0.0,2.0]$。\n- 延迟步长 $\\ell^{(1)} = 1$，因此 $\\tau^{(1)} = 1$ ps。\n- 乘数 $k^{(1)} = 5$。\n- 阈值 $\\varepsilon^{(1)} = 0.01$。\n\n测试用例 2（不可聚合的粗粒化；预期违反 Chapman–Kolmogorov 属性）：\n- 基于 $S_t \\in \\{0,1,2\\}$ 的隐马尔可夫链，其转移矩阵为\n$$\nT^{(2)} = \\begin{pmatrix}\n0.90  0.10  0.00 \\\\\n0.05  0.90  0.05 \\\\\n0.10  0.00  0.90\n\\end{pmatrix}.\n$$\n- 长度 $N^{(2)} = 300{,}000$ 步。\n- 初始化种子 $s_2 = 456$。\n- 将状态映射到序参数：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -1.0$，$\\mu_1 = -0.2$，$\\mu_2 = +1.0$（无观测噪声）。\n- 将状态聚合的粗粒化分箱：$M^{(2)} = 2$，边界为 $\\{-2.0, 0.0, 2.0\\}$，因此 $\\{S_t=0,1\\} \\mapsto$ 区间 0，而 $\\{S_t=2\\} \\mapsto$ 区间 1。\n- 延迟步长 $\\ell^{(2)} = 1$，因此 $\\tau^{(2)} = 1$ ps。\n- 乘数 $k^{(2)} = 5$。\n- 阈值 $\\varepsilon^{(2)} = 0.05$。\n\n测试用例 3（边界条件；单区间的平凡划分；预期满足 Chapman–Kolmogorov 属性）：\n- 基于 $S_t \\in \\{0,1\\}$ 的隐马尔可夫链，其转移矩阵为\n$$\nT^{(3)} = \\begin{pmatrix}\n0.95  0.05 \\\\\n0.10  0.90\n\\end{pmatrix}.\n$$\n- 长度 $N^{(3)} = 50{,}000$ 步。\n- 初始化种子 $s_3 = 789$。\n- 将状态映射到序参数：$q(t) = \\mu_{S_t}$，其中 $\\mu_0 = -0.5$ 且 $\\mu_1 = +0.5$（无观测噪声）。\n- 单区间：$M^{(3)} = 1$，边界为 $\\{-2.0, 2.0\\}$，因此所有样本都属于这唯一的区间。\n- 延迟步长 $\\ell^{(3)} = 10$，因此 $\\tau^{(3)} = 10$ ps。\n- 乘数 $k^{(3)} = 3$。\n- 阈值 $\\varepsilon^{(3)} = 10^{-12}$。\n\n您的程序必须：\n1. 使用给定的转移矩阵 $T^{(i)}$ 和种子 $s_i$ 模拟每个长度为 $N^{(i)}$ 的隐马尔可夫链（从状态 0 开始；较大的 $N^{(i)}$ 确保瞬态效应可以忽略不计）。\n2. 通过提供的映射转换为 $q(t)$，并根据每种情况给定的边界将其离散化到区间中。\n3. 使用 $\\alpha = 1$ 的拉普拉斯平滑估计器构建 $T(\\tau)$ 和 $T(k \\tau)$。\n4. 为每种情况计算 $\\delta(\\ell,k)$ 并与 $\\varepsilon^{(i)}$ 比较，以生成布尔值结果：如果 $\\delta(\\ell,k) \\leq \\varepsilon^{(i)}$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个布尔结果，形式为方括号内以逗号分隔的列表（例如，“[True,False,True]”）。不得打印任何其他文本。所有延迟时间和采样间隔都以皮秒（ps）为单位，但程序输出的是布尔值，而非物理量。", "solution": "该问题要求从一个合成的一维序参数时间序列 $q(t)$ 构建并验证马尔可夫状态模型 (MSM)。验证是通过检验 Chapman-Kolmogorov (CK) 属性来执行的。整个过程针对三个不同的测试用例执行，这些用例旨在探究 MSM 理论的不同方面。\n\n对于每个测试用例，求解方法遵循以下步骤顺序：\n1.  基于一个潜在的（或“隐藏的”）离散时间马尔可夫链生成合成数据集。\n2.  通过离散化（分箱）序参数时间序列来构建 MSM。\n3.  评估所构建 MSM 的 Chapman-Kolmogorov 属性。\n\n**1. 合成数据生成**\n首先，模拟一个离散时间、离散状态的隐马尔可夫链 (HMC)，以表示系统的真实潜在动力学。生成一个总步数为 $N$ 的状态轨迹 $S_t \\in \\{0, 1, \\dots\\}$。该链的演化由给定的转移概率矩阵 $T^{(\\text{hidden})}$ 控制，其中 $T_{ij}^{(\\text{hidden})}$ 是在单个时间步长 $\\Delta t$ 内从状态 $i$ 转移到状态 $j$ 的概率。根据定义，这个潜在过程是马尔可夫性的。为保证可复现性，模拟从状态 $S_0=0$ 开始，并使用以特定种子初始化的伪随机数生成器。\n\n然后，使用确定性映射 $q(t) = \\mu_{S_t}$ 将离散状态轨迹 $\\{S_t\\}$ 转换为连续的序参数时间序列 $\\{q(t)\\}$，其中每个隐藏状态 $S_t$ 被赋予一个特定值 $\\mu_{S_t}$。采样间隔给定为 $\\Delta t = 1$ ps。\n\n**2. 马尔可夫状态模型构建**\n构建 MSM 的核心过程是将连续的状态空间（由 $q(t)$ 表示）粗粒化为有限数量的离散状态。\n\n- **离散化**：时间序列 $q(t)$ 被划分为由一组区间边界定义的 $M$ 个区间（bin）。每个值 $q(t)$ 被分配到一个唯一的区间索引 $b_t \\in \\{0, 1, \\dots, M-1\\}$，从而生成一个离散轨迹 $\\{b_t\\}$。\n\n- **转移计数**：对于选定的延迟时间 $\\tau = \\ell \\Delta t$（其中 $\\ell$ 是一个整数延迟步长），我们统计在一对区间 $(i, j)$ 之间观测到的转移次数。结果是一个大小为 $M \\times M$ 的计数矩阵 $C(\\tau)$，其中元素 $C_{ij}(\\tau)$ 是在延迟时间 $\\tau$ 内观测到从区间 $i$ 转移到区间 $j$ 的总次数。即 $C_{ij}(\\tau) = \\sum_{t} \\mathbb{I}(b_t=i, b_{t+\\ell}=j)$，其中 $\\mathbb{I}$ 是指示函数。\n\n- **转移概率估计**：计数矩阵被转换为一个行随机的转移概率矩阵 $T(\\tau)$。为了处理有限数据并避免未观测到的转移概率为零，我们采用拉普拉斯平滑，其伪计数 $\\alpha=1$。转移矩阵的元素估计如下：\n$$\nT_{ij}(\\tau) = \\frac{C_{ij}(\\tau) + \\alpha}{\\sum_{k=0}^{M-1} \\left(C_{ik}(\\tau) + \\alpha\\right)}\n$$\n此公式确保每一行满足 $\\sum_{j=0}^{M-1} T_{ij}(\\tau) = 1$。\n\n**3. Chapman-Kolmogorov 测试**\n任何平稳马尔可夫过程的一个基本属性是，其在时间 $k\\tau$ 内的演化可以从其在时间 $\\tau$ 内的演化推导出来。具体来说，离散时间马尔可夫链的 Chapman-Kolmogorov 方程指出，k 步转移矩阵等于单步转移矩阵的 k 次幂。对于我们的 MSM，这意味着以下关系：\n$$\nT(k\\tau) = [T(\\tau)]^k\n$$\n该属性仅在离散化过程 $\\{b_t\\}$ 在延迟时间 $\\tau$ 上是真正的马尔可夫过程时才成立。测试通过比较该方程的两边来进行。\n\n- **等式左边 (LHS)**：矩阵 $T(k\\tau)$ 直接从数据计算。我们使用 $k\\tau = (k\\ell)\\Delta t$ 的延迟时间构建计数矩阵 $C(k\\tau)$，然后应用相同的拉普拉斯平滑估计来获得 $T(k\\tau)$。\n\n- **等式右边 (RHS)**：矩阵 $[T(\\tau)]^k$ 的计算方法是：取先前在较短延迟时间下估计的矩阵 $T(\\tau)$，并使用标准矩阵乘法将其提升到整数次幂 $k$。\n\n- **偏差度量**：两个矩阵之间的差异通过它们所有元素的最大绝对差来量化：\n$$\n\\delta(\\ell,k) = \\max_{i,j} \\left| [T(k\\tau)]_{ij} - \\left[T(\\tau)^k\\right]_{ij} \\right|\n$$\n一个小的 $\\delta(\\ell,k)$ 值表明该 MSM 是系统动力学的一个良好马尔可夫近似。如果此偏差低于指定的容差阈值，即 $\\delta(\\ell,k) \\leq \\varepsilon$，则声明该属性成立。\n\n**实现**\n该过程使用 Python 的 `numpy` 库实现。HMC 模拟使用 `numpy.random.default_rng` 进行带种子的随机数生成。离散化通过 `numpy.digitize` 完成。计数矩阵通过向量化转移对的计数来高效构建。转移矩阵使用数组算术计算，而矩阵的幂 $[T(\\tau)]^k$ 则通过 `numpy.linalg.matrix_power` 计算。该逻辑按规定应用于三个测试用例中的每一个，并记录比较 $\\delta(\\ell,k) \\leq \\varepsilon$ 的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_hmc_trace(T_hidden, N, seed):\n    \"\"\"Generates a state trajectory from a hidden Markov chain.\"\"\"\n    rng = np.random.default_rng(seed)\n    num_states = T_hidden.shape[0]\n    states = np.empty(N, dtype=int)\n    states[0] = 0  # Start from state 0 as specified.\n    for t in range(N - 1):\n        current_state = states[t]\n        probabilities = T_hidden[current_state]\n        next_state = rng.choice(num_states, p=probabilities)\n        states[t + 1] = next_state\n    return states\n\ndef build_count_matrix(binned_seq, lag, M):\n    \"\"\"Builds a transition count matrix from a binned sequence.\"\"\"\n    C = np.zeros((M, M), dtype=np.int64)\n    if M == 0:\n        return C\n    n_points = len(binned_seq)\n    if lag >= n_points:\n        return C\n    \n    # Get the indices of the start and end states for each transition\n    i_indices = binned_seq[:-lag]\n    j_indices = binned_seq[lag:]\n    \n    # Use np.add.at for efficient counting of transitions\n    np.add.at(C, (i_indices, j_indices), 1)\n    \n    return C\n\ndef counts_to_T(C, alpha):\n    \"\"\"Converts a count matrix to a transition probability matrix with Laplace smoothing.\"\"\"\n    M = C.shape[0]\n    if M == 0:\n        return np.array([[]])\n        \n    C_smoothed = C + alpha\n    row_sums = C_smoothed.sum(axis=1, keepdims=True)\n    \n    # Avoid division by zero for rows that were never visited.\n    # Laplace smoothing with alpha > 0 prevents this unless M=0.\n    if np.any(row_sums == 0):\n        T = np.zeros_like(C_smoothed, dtype=float)\n        non_zero_rows = row_sums.flatten() > 0\n        if np.any(non_zero_rows):\n            T[non_zero_rows] = C_smoothed[non_zero_rows] / row_sums[non_zero_rows]\n        \n        zero_rows = ~non_zero_rows\n        if np.any(zero_rows) and M > 0:\n            T[zero_rows] = 1.0 / M\n    else:\n        T = C_smoothed / row_sums\n        \n    return T\n\ndef run_test_case(T_hidden, N, seed, state_map, bin_edges, l, k, epsilon, alpha=1):\n    \"\"\"Runs a single test case for Chapman-Kolmogorov validation.\"\"\"\n    \n    # 1. Simulate hidden Markov chain and generate q(t)\n    states = generate_hmc_trace(T_hidden, N, seed)\n    q_t = np.array([state_map[s] for s in states])\n    \n    # 2. Discretize q(t) into bins\n    # np.digitize returns 1-based indices, so subtract 1 for 0-based binning.\n    # Bins are [edge_i, edge_{i+1})\n    binned_seq = np.digitize(q_t, bin_edges) - 1\n    M = len(bin_edges) - 1\n\n    # Define lag times in steps\n    tau = l\n    k_tau = k * l\n\n    # 3. Construct T(tau)\n    C_tau = build_count_matrix(binned_seq, tau, M)\n    T_tau = counts_to_T(C_tau, alpha)\n\n    # 4. Construct T(k*tau) directly\n    C_k_tau = build_count_matrix(binned_seq, k_tau, M)\n    T_k_tau_estimated = counts_to_T(C_k_tau, alpha)\n\n    # 5. Compute T(tau)^k\n    if M > 0:\n        T_tau_k_predicted = np.linalg.matrix_power(T_tau, k)\n    else: # Handle M=0 case\n        T_tau_k_predicted = np.array([[]])\n\n    # 6. Compute deviation and compare with threshold\n    delta = np.max(np.abs(T_k_tau_estimated - T_tau_k_predicted)) if M > 0 else 0.0\n    \n    return delta = epsilon\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test cases, and print the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Well-constructed MSM\n        {\n            \"T_hidden\": np.array([[0.999, 0.001], [0.001, 0.999]]),\n            \"N\": 200000,\n            \"seed\": 123,\n            \"state_map\": [-1.0, 1.0],\n            \"bin_edges\": [-2.0, 0.0, 2.0],\n            \"l\": 1,\n            \"k\": 5,\n            \"epsilon\": 0.01\n        },\n        # Test Case 2: Non-lumpable coarse-graining\n        {\n            \"T_hidden\": np.array([[0.90, 0.10, 0.00], [0.05, 0.90, 0.05], [0.10, 0.00, 0.90]]),\n            \"N\": 300000,\n            \"seed\": 456,\n            \"state_map\": [-1.0, -0.2, 1.0],\n            \"bin_edges\": [-2.0, 0.0, 2.0],\n            \"l\": 1,\n            \"k\": 5,\n            \"epsilon\": 0.05\n        },\n        # Test Case 3: Boundary condition (single bin)\n        {\n            \"T_hidden\": np.array([[0.95, 0.05], [0.10, 0.90]]),\n            \"N\": 50000,\n            \"seed\": 789,\n            \"state_map\": [-0.5, 0.5],\n            \"bin_edges\": [-2.0, 2.0],\n            \"l\": 10,\n            \"k\": 3,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_test_case(**case_params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n```", "id": "3430948"}]}