{"hands_on_practices": [{"introduction": "验证反应坐标 ($\\xi$) 最直接的方法是检验其是否是提交者概率 ($q$) 的唯一决定因素。一个理想的反应坐标，其等值面（即所有 $\\xi(\\mathbf{x}) = c$ 的微观状态集合）上的所有点的提交者概率都应该相同。本练习将指导您从零开始实现“打靶”(shooting)算法来计算提交者概率，并检验一个候选反应坐标是否满足这一关键性质，从而为您构建反应坐标验证的核心计算技能。[@problem_id:3402833]", "problem": "您的任务是构建一个严谨的交叉检验方法，用于验证分子动力学（MD）中提出的一维反应坐标。该方法基于分子系统的基本随机动力学，并使用提交者分析（committor analysis）。考虑一个具有坐标 $x$ 和 $y$ 的二维构型空间。系统动力学采用无量綱单位建模，由过阻尼朗之万方程（也称为 Smoluchowski 动力学）描述。对于势能 $U(x,y)$，该方程表示为：\n$$\ndx_t = -\\mu \\,\\partial_x U(x_t,y_t)\\, dt + \\sqrt{2 D \\, dt}\\, \\eta_x(t), \\quad dy_t = -\\mu \\,\\partial_y U(x_t,y_t)\\, dt + \\sqrt{2 D \\, dt}\\, \\eta_y(t),\n$$\n其中 $\\mu$ 是迁移率，$D$ 是扩散系数，$\\eta_x(t)$ 和 $\\eta_y(t)$ 是每个时间步上独立的标准正态随机变量。提交者函数（committor function） $q(x_0,y_0)$ 定义为从 $(x_0,y_0)$ 出发的轨迹在到达势阱 $B$ 之前到达势阱 $A$ 的概率。此处的势阱由 $x$ 上的阈值条件定义，具体来说，势阱 $A$ 是满足 $x \\le x_A$ 的构型集合，势阱 $B$ 是满足 $x \\ge x_B$ 的构型集合，其中 $x_A  0  x_B$。一个提出的反应坐标是一个标量函数 $\\xi(x,y)$；“等值面”是满足 $\\xi(x,y)=c$（$c$ 为常数）的点集。\n\n您的程序必须实现以下验证流程：\n1. 使用过阻尼朗之万动力学作为基本演化定律（无惯性项）。使用 Euler–Maruyama 方法，并采用指定的无量纲单位参数来积分该随机微分方程。\n2. 对于每个提出的反应坐标 $\\xi(x,y)$ 和每个指定的等值面水平 $c$，通过在对称区间内均匀改变 $y$ 并确定满足等值面条件的相应 $x$，来构建等值面 $\\xi(x,y)=c$ 上的一组初始条件。\n3. 对于等值面上的每个初始条件 $(x_0,y_0)$，通过“发射”（shooting）来近似计算提交者 $q(x_0,y_0)$：从 $(x_0,y_0)$ 发射多条独立的过阻尼朗之万轨迹，演化每条轨迹直到其到达势阱 $A$ 或势阱 $B$ 或达到最大步数，并记录是否在到达势阱 A 之前到达了势阱 B。估计的提交者 $q(x_0,y_0)$ 是首先到达势阱 $B$ 的轨迹所占的比例。\n4. 在固定的等值面水平 $c$ 下，聚合所有不同初始条件得到的集合 $\\{q(x_0,y_0)\\}$，并检验 $q$ 的经验分布是否为单峰且窄。如果对于任何测试的 $c$ 值，其固定的 $q$ 值分布未能满足单峰性或不够窄，则判定该反应坐标不充分。\n5. 单峰性必须通过估计经验 $q$ 值的平滑密度并计算不同模态的数量来评估。宽度必须通过将 $q$ 值的经验标准差与一个阈值进行比较来评估。\n\n势能指定为\n$$\nU(x,y) = (x^2 - 1)^2 + k \\, y^2,\n$$\n其梯度为\n$$\n\\partial_x U(x,y) = 4x(x^2 - 1), \\quad \\partial_y U(x,y) = 2k y.\n$$\n这在 $x$ 方向上产生一个对称双势阱，其极小值在 $x=\\pm 1$ 附近，并在 $y$ 方向上有一个弱约束的二次项。完全在无量纲单位下工作。势阱由 $x_A=-0.9$ 和 $x_B=0.9$ 定义。迁移率为 $\\mu=1$，扩散系数为 $D=0.4$，势能参数为 $k=0.1$。每条轨迹使用的时间步长为 $dt=0.005$，最大步数为 $N_{\\text{max}}=1500$。对于每个等值面和每个初始条件，使用 $N_{\\text{shoot}}=30$ 条发射轨迹。为构建等值面初始条件，在区间 $[-Y_{\\max},Y_{\\max}]$（其中 $Y_{\\max}=1$）内均匀采样 $N_{\\text{iso}}=21$ 个 $y$ 值。将到达势阱视为吸收边界：一旦轨迹满足 $x \\le x_A$ 或 $x \\ge x_B$，它即终止并被认为分别到达了 $A$ 或 $B$。如果一条轨迹在 $N_{\\text{max}}$ 步内未能到达任一势阱，则计为未到达任何一方；对于提交者估计，只有记录到的首次到达才计入比例中。如果给定初始条件的所有轨迹都未能到达任一势阱，则该初始条件的提交者估计值应根据对称性设为 $0.5$。\n\n您必须验证两个候选反应坐标：\n1. $\\xi_1(x,y) = x$.\n2. $\\xi_2(x,y) = x + \\alpha y$ 其中 $\\alpha = 1.5$.\n\n待测试的等值面水平为 $c \\in \\{-0.5, 0.0, 0.5\\}$。对于每个候选 $\\xi$ 和每个 $c$，在构建的等值面初始条件上计算提交者估计值集合 $\\{q(x_0,y_0)\\}$，然后：\n- 在 $q \\in [0,1]$ 上估计一个平滑密度，并确定是否存在最多一个模态（单峰性）。\n- 计算 $\\{q\\}$ 值的经验标准差 $\\sigma_q$，并确定其是否最多为宽度阈值 $\\sigma_{\\text{th}}=0.12$。\n\n如果对于所有测试的 $c$ 值，在固定 $c$ 值下的 $q$ 分布都是单峰且窄的，则反应坐标 $\\xi$ 被认为是“充分的”。否则，结论为“不充分的”。\n\n您的程序必须生成单行输出，其中包含分别为 $\\xi_1$ 和 $\\xi_2$ 的充分性判定结果，格式为一个以逗号分隔、用方括号括起来的 Python 布尔值列表，例如 $[{\\rm True},{\\rm False}]$。不允许有任何其他输出。\n\n需要精确实现的测试套件参数：\n- 势能参数：$k=0.1$。\n- 势阱：$x_A=-0.9$, $x_B=0.9$。\n- 动力学：$\\mu=1$, $D=0.4$, $dt=0.005$, $N_{\\text{max}}=1500$。\n- 发射：每个初始条件 $N_{\\text{shoot}}=30$ 条轨迹。\n- 等值面采样：$N_{\\text{iso}}=21$ 个点，其中 $y$ 在 $[-1,1]$ 内均匀分布，$Y_{\\max}=1$。\n- 反应坐标：$\\xi_1(x,y)=x$，$\\xi_2(x,y)=x+\\alpha y$ 其中 $\\alpha=1.5$。\n- 等值面水平：$c=-0.5, 0.0, 0.5$。\n- 单峰性检测：在 $q \\in [0,1]$ 上使用平滑密度估计并计算模态数量。\n- 宽度阈值：$\\sigma_{\\text{th}}=0.12$。\n- 单位：以无量纲单位报告和计算。\n\n您的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表，布尔值采用 Python 语法，顺序为 $[\\text{sufficient}(\\xi_1),\\text{sufficient}(\\xi_2)]$。", "solution": "用户在分子动力学和反应坐标验证领域提供了一个定义明确的计算问题。我将首先根据指定的标准验证问题陈述。\n\n### 第1步：提取已知信息\n- **势能函数**：$U(x,y) = (x^2 - 1)^2 + k \\, y^2$，其中 $k=0.1$。\n- **势能梯度**：$\\partial_x U(x,y) = 4x(x^2 - 1)$, $\\partial_y U(x,y) = 2k y$。\n- **动力学**：过阻尼朗之万方程 (Smoluchowski 动力学)，使用 Euler-Maruyama 方法积分。\n  - 迁移率 $\\mu=1$。\n  - 扩散系数 $D=0.4$。\n  - 时间步长 $dt=0.005$。\n- **势阱**：势阱 A 定义为 $x \\le x_A = -0.9$。势阱 B 定义为 $x \\ge x_B = 0.9$。\n- **轨迹终止**：轨迹在到达势阱或达到最大步数 $N_{\\text{max}}=1500$ 后终止。\n- **提交者估计**：基于每个初始点的 $N_{\\text{shoot}}=30$ 条轨迹。提交者 $q$ 是在 A 之前到达 B 的轨迹所占的比例。如果没有轨迹到达任一势阱，则设 $q$ 为 $0.5$。\n- **等值面采样**：对于每个等值面，通过在 $[-1,1]$ ($Y_{\\max}=1$) 中均匀采样 $y$ 并求解 $x$ 来生成 $N_{\\text{iso}}=21$ 个初始点。\n- **待测试的反应坐标 (RC)**：\n  1. $\\xi_1(x,y) = x$。\n  2. $\\xi_2(x,y) = x + \\alpha y$，其中 $\\alpha = 1.5$。\n- **待测试的等值面水平**：$c \\in \\{-0.5, 0.0, 0.5\\}$。\n- **验证标准**：如果对于所有测试的等值面水平 $c$，其提交者值 $\\{q\\}$ 的分布同时满足以下两点，则一个 RC 被认为是“充分的”：\n  1. **单峰**：$\\{q\\}$ 值的估计平滑概率密度最多有一个模态。\n  2. **窄**：$\\{q\\}$ 值的经验标准差 $\\sigma_q$ 小于或等于阈值 $\\sigma_{\\text{th}}=0.12$。\n- **输出格式**：一个 Python 布尔值列表，表示 $\\xi_1$ 和 $\\xi_2$ 的充分性：`[sufficient(xi_1), sufficient(xi_2)]`。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学依据充分**：该问题植根于统计力学和计算化学的基本原理。使用朗之万方程、提交者分析和等值面测试来验证反应坐标是分子模拟和稀有事件动力学领域中标准的、成熟的方法。该势能函数是用于此类研究的经典双阱模型。\n2.  **定义明确**：问题定义清晰，所有必要的参数、方程和数值程序都已指定。判断标准（“充分”与“不充分”）被客观地量化。这种结构确保了可以通过算法确定唯一的解。\n3.  **客观性**：问题以精确、无偏见的术语陈述。验证标准（单峰性、宽度）基于定量测量（KDE的模态计数、标准差阈值），消除了主观性。\n4.  **完整性和一致性**：问题陈述是自洽的。没有矛盾之处。虽然“平滑密度估计”没有具体到核函数和带宽，但使用高斯核密度估计（KDE）等标准方法，并采用默认的带宽启发式（如 `scipy.stats.gaussian_kde` 使用的 Scott 或 Silverman 法则），是一种合理且标准的解释，不会损害问题的有效性。\n5.  **可行性**：计算负载很大但可控。总模拟步数约为 $2 \\text{ (RCs)} \\times 3 \\text{ (levels)} \\times 21 \\text{ (points)} \\times 30 \\text{ (shots)} \\times 1500 \\text{ (steps)} \\approx 5.67 \\times 10^6$。这对于现代计算机单次运行来说完全在其能力范围内。\n6.  **未检测到其他缺陷**：该问题并非琐碎、隐喻性或超出科学验证的范畴。\n\n### 第3步：结论与行动\n该问题是**有效的**。我将继续构建解决方案。\n\n解决方案将作为一个单一的 Python 脚本实现。核心逻辑涉及一系列嵌套函数，用于管理模拟和分析工作流程。\n\n1.  **`solve()`**：主函数，用于协调整个过程。它将定义所有问题参数和辅助函数。它将遍历两个反应坐标，评估它们的充分性，并格式化最终输出。\n2.  **`grad_U(x, y)`**：一个辅助函数，用于计算势能梯度，该梯度决定了朗之万方程中的确定性力。\n3.  **`run_trajectory(x0, y0)`**：此函数使用 Euler-Maruyama 方法模拟从 `(x0, y0)` 开始的单条轨迹。它返回首先到达的势阱（'A' 或 'B'），如果轨迹超时则返回 'None'。\n4.  **`calculate_committor(x0, y0)`**：此函数通过从给定起点多次调用 `run_trajectory` $N_{\\text{shoot}}$ 次来执行“发射”。然后，它计算提交者估计值，即首先到达势阱 B 的轨迹所占的比例，并应用特殊规则处理没有轨迹到达任一势阱的情况。\n5.  **`count_modes(data)`**：此函数将接收一个提交者值列表，使用 `scipy.stats.gaussian_kde` 计算平滑概率密度，然后计算所得密度曲线中的模态数量。这对于单峰性测试至关重要。我的实现将计算离散密度函数中的局部最大值。为了稳健地处理各种分布形状（包括单调分布），它将检查域内部的峰值以及边界处的峰值。\n6.  **`test_rc(rc_x_generator, levels)`**：此函数整合了对单个反应坐标的验证。它遍历指定的等值面 `levels`。对于每个水平，它生成等值面上的初始条件，计算这些点的提交者值，然后检查单峰性和宽度。如果任何水平未能通过任一测试，函数将立即返回 `False`，表示该 RC 不充分。如果所有水平都通过，则返回 `True`。\n\n这种结构化的方法将问题的需求直接映射到一个计算算法中，确保所有条件和参数都得到遵守。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gaussian_kde\n\ndef solve():\n    \"\"\"\n    Main function to validate reaction coordinates using committor analysis.\n    \"\"\"\n    # Define problem parameters\n    K = 0.1\n    X_A = -0.9\n    X_B = 0.9\n    MU = 1.0\n    D = 0.4\n    DT = 0.005\n    N_MAX = 1500\n    N_SHOOT = 30\n    N_ISO = 21\n    Y_MAX = 1.0\n    ALPHA = 1.5\n    SIGMA_TH = 0.12\n    ISO_LEVELS = [-0.5, 0.0, 0.5]\n    \n    # Pre-calculate noise standard deviation for efficiency\n    NOISE_STD = np.sqrt(2 * D * DT)\n\n    def grad_U(x, y):\n        \"\"\"Computes the gradient of the potential energy U(x,y).\"\"\"\n        grad_x = 4.0 * x * (x**2 - 1.0)\n        grad_y = 2.0 * K * y\n        return grad_x, grad_y\n\n    def run_trajectory(x0, y0):\n        \"\"\"\n        Simulates a single overdamped Langevin trajectory.\n        Returns 'A' or 'B' if a basin is reached, otherwise 'None'.\n        \"\"\"\n        x, y = x0, y0\n        # Generate all random numbers at once for vectorization\n        noise_x = np.random.randn(N_MAX) * NOISE_STD\n        noise_y = np.random.randn(N_MAX) * NOISE_STD\n        \n        for i in range(N_MAX):\n            grad_x, grad_y = grad_U(x, y)\n            x += -MU * grad_x * DT + noise_x[i]\n            y += -MU * grad_y * DT + noise_y[i]\n            \n            if x = X_A:\n                return 'A'\n            if x = X_B:\n                return 'B'\n        return 'None'\n\n    def calculate_committor(x0, y0):\n        \"\"\"\n        Estimates the committor value q(x0, y0) by shooting multiple trajectories.\n        \"\"\"\n        a_hits = 0\n        b_hits = 0\n        for _ in range(N_SHOOT):\n            result = run_trajectory(x0, y0)\n            if result == 'A':\n                a_hits += 1\n            elif result == 'B':\n                b_hits += 1\n        \n        total_hits = a_hits + b_hits\n        if total_hits == 0:\n            return 0.5\n        return b_hits / total_hits\n\n    def count_modes(data, grid_size=100):\n        \"\"\"\n        Estimates the number of modes in a dataset using KDE.\n        At most one mode is considered 'unimodal'.\n        \"\"\"\n        if len(data)  2 or np.allclose(data, data[0]):\n            return 1\n\n        try:\n            # Use default bandwidth selection (Scott's rule)\n            kde = gaussian_kde(data)\n            grid = np.linspace(0, 1, grid_size)\n            density = kde.evaluate(grid)\n        except (np.linalg.LinAlgError, ValueError):\n            return 1  # Fallback for singular matrix cases\n\n        # Find local maxima to count modes\n        modes = 0\n        # Check for internal modes (peaks)\n        for i in range(1, len(density) - 1):\n            if density[i]  density[i-1] and density[i]  density[i+1]:\n                modes += 1\n        \n        # Check for modes at the boundaries\n        if density[0]  density[1]:\n            modes += 1\n        if density[-1]  density[-2]:\n            modes += 1\n            \n        # A montonic distribution will have 1 mode at a boundary.\n        # A flat distribution will have 0 modes. We consider 0 modes as passing the\n        # \"at most one mode\" test.\n        if modes == 0 and not np.allclose(density, density[0]):\n             # This means monotonic or a single very broad peak, treat as unimodal\n             return 1\n        \n        return modes\n\n    def test_rc (rc_x_generator, levels_to_test):\n        \"\"\"\n        Tests a reaction coordinate for sufficiency across specified isosurface levels.\n        \"\"\"\n        for c in levels_to_test:\n            y_values = np.linspace(-Y_MAX, Y_MAX, N_ISO)\n            initial_conditions = [(rc_x_generator(y, c), y) for y in y_values]\n            \n            q_values = [calculate_committor(x0, y0) for x0, y0 in initial_conditions]\n            \n            q_std = np.std(q_values)\n            is_narrow = (q_std = SIGMA_TH)\n            \n            num_modes = count_modes(q_values)\n            is_unimodal = (num_modes = 1)\n            \n            if not (is_unimodal and is_narrow):\n                return False  # Fails early if any level is insufficient\n        return True\n\n    # Define generators for x-coordinates on isosurfaces\n    rc1_gen = lambda y, c: c\n    rc2_gen = lambda y, c: c - ALPHA * y\n    \n    # Perform validation for both reaction coordinates\n    results = [\n        test_rc(rc1_gen, ISO_LEVELS),\n        test_rc(rc2_gen, ISO_LEVELS)\n    ]\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3402833"}, {"introduction": "在通过模拟估算出提交者概率后，我们常常希望将其拟合到一个简洁且有理论依据的函数形式上，例如逻辑斯谛函数 (logistic function)。这个练习将重点放在统计推断的层面，要求您从第一性原理出发，为给定的“打靶”实验数据推导模型参数的最大似然估计。通过本练习，您将掌握如何将理论模型与模拟结果进行定量连接的关键技能。[@problem_id:3402803]", "problem": "考虑一个高维分子动力学 (MD) 模拟中，在两个亚稳盆 $A$ 和 $B$ 之间发生的稀有事件跃迁。committor 函数 $q_{B}(\\mathbf{x})$ 定义为从构型 $\\mathbf{x}$ 开始的轨迹在到达盆 $A$ 之前先到达盆 $B$ 的概率。假设动力学过程是马尔可夫的，并遵循微观可逆性原理，且存在一个一维反应坐标 $r(\\mathbf{x})$，使得 $r=0$ 近似为分割面，并且映射 $r \\mapsto q_{B}$ 是严格单调递增的，且由于盆沿 $r$ 的对称性，满足 $q_{B}(-r)=1-q_{B}(r)$。\n\n一个标准的、科学上合理的建模选择是，假设反应坐标与 committor 函数之间存在一个逻辑斯谛联系：\n$$\nq_{B}(r)=\\frac{1}{1+\\exp\\!\\left(-\\beta r\\right)},\n$$\n其中 $\\beta$ 是一个未知的斜率参数，需要通过短轨迹“发射”实验来推断。在发射结果相互独立的假设下，每条从固定 $r$ 值开始的轨迹都会产生一个伯努利结果，其成功概率为 $q_{B}(r)$。\n\n你进行了以下实验。在 $r=+r_{0}$ 处，你发射了 $N_{+}$ 条独立的短轨迹，并观察到 $m_{+}$ 条轨迹在到达盆 $A$ 之前先到达了盆 $B$。在 $r=-r_{0}$ 处，你发射了 $N_{-}$ 条独立的短轨迹，并观察到 $m_{-}$ 条轨迹在到达盆 $A$ 之前先到达了盆 $B$。反应坐标 $r$ 是无量纲的，因此斜率 $\\beta$ 也是无量纲的。根据微观可逆性原理所蕴含的对称性 $q_{B}(-r)=1-q_{B}(r)$ 以及上述的逻辑斯谛联系，构建观测数据的似然函数，并从第一性原理出发，推导出 $\\beta$ 的最大似然估计值（用 $N_{+}$, $N_{-}$, $m_{+}$, $m_{-}$, 和 $r_{0}$ 表示）。\n\n然后，使用数值 $r_{0}=0.85$，$N_{+}=40$，$m_{+}=29$，$N_{-}=45$ 和 $m_{-}=11$，计算最大似然估计 $\\hat{\\beta}$ 的数值。将最终答案四舍五入到四位有效数字。由于 $\\beta$ 是无量纲的，报告该值时无需单位。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于统计力学和最大似然估计的原理，问题提法得当，设置完整且一致，并以客观、正式的语言表达。因此，我们可以开始解答。\n\n目标是根据两组发射实验的数据，为给定的 committor 函数的逻辑斯谛模型，找到斜率参数 $\\beta$ 的最大似然估计 (MLE)。\n\ncommittor 函数，被建模为反应坐标 $r$ 的一个逻辑斯谛函数，由下式给出：\n$$\nq_{B}(r) = \\frac{1}{1 + \\exp(-\\beta r)}\n$$\n短轨迹的结果是独立的伯努利试验。对于从反应坐标值为 $r$ 的构型发射的轨迹，到达盆 $B$ 的概率为 $p = q_{B}(r)$，到达盆 $A$ 的概率为 $1-p = 1-q_{B}(r)$。\n\n该实验包括两部分：\n1.  在 $r = +r_{0}$ 处，我们进行了 $N_{+}$ 次试验，其中有 $m_{+}$ 次成功（到达 $B$）。该结果的概率由二项概率质量函数给出：\n    $$\n    P(m_{+}|N_{+}, \\beta, r_0) = \\binom{N_{+}}{m_{+}} [q_{B}(r_{0})]^{m_{+}} [1-q_{B}(r_{0})]^{N_{+}-m_{+}}\n    $$\n2.  在 $r = -r_{0}$ 处，我们进行了 $N_{-}$ 次试验，其中有 $m_{-}$ 次成功。该结果的概率为：\n    $$\n    P(m_{-}|N_{-}, \\beta, r_0) = \\binom{N_{-}}{m_{-}} [q_{B}(-r_{0})]^{m_{-}} [1-q_{B}(-r_{0})]^{N_{-}-m_{-}}\n    $$\n\n由于两个实验是独立的，观测数据 $L(\\beta)$ 的总似然函数是这些概率的乘积：\n$$\nL(\\beta) = \\binom{N_{+}}{m_{+}} [q_{B}(r_{0})]^{m_{+}} [1-q_{B}(r_{0})]^{N_{+}-m_{+}} \\binom{N_{-}}{m_{-}} [q_{B}(-r_{0})]^{m_{-}} [1-q_{B}(-r_{0})]^{N_{-}-m_{-}}\n$$\n为了找到 MLE $\\hat\\beta$，我们对 $\\beta$ 最大化 $L(\\beta)$。更方便的做法是最大化对数似然函数 $\\ell(\\beta) = \\ln L(\\beta)$，因为对数是单调函数。二项式系数不依赖于 $\\beta$，在优化过程中可以忽略。\n$$\n\\ell(\\beta) = m_{+} \\ln(q_{B}(r_{0})) + (N_{+} - m_{+}) \\ln(1 - q_{B}(r_{0})) + m_{-} \\ln(q_{B}(-r_{0})) + (N_{-} - m_{-}) \\ln(1 - q_{B}(-r_{0})) + C\n$$\n其中 $C$ 是一个常数。我们现在代入 $q_B(r)$ 和 $1-q_B(r)$ 的表达式。\n对于 $q_B(r_0)$：\n$$\nq_{B}(r_{0}) = \\frac{1}{1+\\exp(-\\beta r_{0})} \\implies \\ln(q_{B}(r_{0})) = -\\ln(1+\\exp(-\\beta r_{0}))\n$$\n$$\n1-q_{B}(r_{0}) = \\frac{\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})} \\implies \\ln(1-q_{B}(r_{0})) = -\\beta r_{0} - \\ln(1+\\exp(-\\beta r_{0}))\n$$\n对于 $q_B(-r_0)$：\n$$\nq_{B}(-r_{0}) = \\frac{1}{1+\\exp(\\beta r_{0})} \\implies \\ln(q_{B}(-r_{0})) = -\\ln(1+\\exp(\\beta r_{0}))\n$$\n$$\n1-q_{B}(-r_{0}) = \\frac{\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})} \\implies \\ln(1-q_{B}(-r_{0})) = \\beta r_{0} - \\ln(1+\\exp(\\beta r_{0}))\n$$\n将这些代入对数似然函数：\n$$\n\\ell(\\beta) = m_{+}[-\\ln(1+\\exp(-\\beta r_{0}))] + (N_{+}-m_{+})[-\\beta r_{0} - \\ln(1+\\exp(-\\beta r_{0}))] + m_{-}[-\\ln(1+\\exp(\\beta r_{0}))] + (N_{-}-m_{-})[\\beta r_{0} - \\ln(1+\\exp(\\beta r_{0}))]\n$$\n合并同类项：\n$$\n\\ell(\\beta) = - N_{+} \\ln(1+\\exp(-\\beta r_{0})) - N_{-} \\ln(1+\\exp(\\beta r_{0})) - (N_{+}-m_{+})\\beta r_{0} + (N_{-}-m_{-})\\beta r_{0}\n$$\n为了找到最大值，我们将 $\\ell(\\beta)$ 对 $\\beta$ 求导，并令其导数为零：\n$$\n\\frac{d\\ell}{d\\beta} = -N_{+}\\left(\\frac{-r_{0}\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})}\\right) - N_{-}\\left(\\frac{r_{0}\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})}\\right) - (N_{+}-m_{+})r_{0} + (N_{-}-m_{-})r_{0} = 0\n$$\n由于 $r_0 \\neq 0$，我们可以将整个方程除以 $r_{0}$：\n$$\nN_{+}\\frac{\\exp(-\\beta r_{0})}{1+\\exp(-\\beta r_{0})} - N_{-}\\frac{\\exp(\\beta r_{0})}{1+\\exp(\\beta r_{0})} - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n注意到 $\\frac{\\exp(-\\beta r_0)}{1+\\exp(-\\beta r_0)} = 1 - q_B(r_0)$ 以及 $\\frac{\\exp(\\beta r_0)}{1+\\exp(\\beta r_0)} = 1-q_B(-r_0)$，我们可以写出：\n$$\nN_{+}(1-q_{B}(r_{0})) - N_{-}(1-q_{B}(-r_{0})) - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n$$\nN_{+} - N_{+}q_{B}(r_{0}) - N_{-} + N_{-}q_{B}(-r_{0}) - N_{+} + m_{+} + N_{-} - m_{-} = 0\n$$\n简化此表达式可得到 MLE $\\hat{\\beta}$ 的条件：\n$$\n-N_{+}q_{B}(r_{0}) + N_{-}q_{B}(-r_{0}) + m_{+} - m_{-} = 0\n$$\n$$\nm_{+} - m_{-} = N_{+}q_{B}(r_{0}) - N_{-}q_{B}(-r_{0})\n$$\n现在，我们代回逻辑斯谛形式以求解 $\\beta$：\n$$\nm_{+} - m_{-} = \\frac{N_{+}}{1+\\exp(-\\beta r_{0})} - \\frac{N_{-}}{1+\\exp(\\beta r_{0})}\n$$\n为了解此方程中的 $\\beta$，令 $x = \\exp(\\beta r_{0})$。那么 $\\exp(-\\beta r_{0}) = 1/x$。\n$$\nm_{+} - m_{-} = \\frac{N_{+}}{1+1/x} - \\frac{N_{-}}{1+x} = \\frac{N_{+}x}{x+1} - \\frac{N_{-}}{x+1} = \\frac{N_{+}x - N_{-}}{x+1}\n$$\n现在，我们用代数方法解出 $x$：\n$$\n(m_{+} - m_{-})(x+1) = N_{+}x - N_{-}\n$$\n$$\n(m_{+} - m_{-})x + (m_{+} - m_{-}) = N_{+}x - N_{-}\n$$\n$$\n(m_{+} - m_{-}) + N_{-} = N_{+}x - (m_{+} - m_{-})x\n$$\n$$\nN_{-} + m_{+} - m_{-} = (N_{+} - m_{+} + m_{-})x\n$$\n$$\nx = \\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\n$$\n代回 $x = \\exp(\\beta r_0)$，我们得到：\n$$\n\\exp(\\hat{\\beta} r_0) = \\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\n$$\n最后，通过取自然对数，解出最大似然估计 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} r_0 = \\ln\\left(\\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\\right)\n$$\n$$\n\\hat{\\beta} = \\frac{1}{r_0} \\ln\\left(\\frac{N_{-} + m_{+} - m_{-}}{N_{+} - m_{+} + m_{-}}\\right)\n$$\n这就是 $\\beta$ 的最大似然估计的解析表达式。\n\n我们现在使用给定的数据计算其数值：$r_{0}=0.85$，$N_{+}=40$，$m_{+}=29$，$N_{-}=45$ 和 $m_{-}=11$。\n\n首先，我们计算对数函数参数的分子和分母：\n分子：$N_{-} + m_{+} - m_{-} = 45 + 29 - 11 = 63$。\n分母：$N_{+} - m_{+} + m_{-} = 40 - 29 + 11 = 11 + 11 = 22$。\n\n将这些值代入 $\\hat{\\beta}$ 的表达式中：\n$$\n\\hat{\\beta} = \\frac{1}{0.85} \\ln\\left(\\frac{63}{22}\\right)\n$$\n我们计算这些值：\n$$\n\\frac{63}{22} \\approx 2.863636...\n$$\n$$\n\\ln\\left(\\frac{63}{22}\\right) \\approx \\ln(2.863636...) \\approx 1.052184...\n$$\n$$\n\\hat{\\beta} \\approx \\frac{1.052184...}{0.85} \\approx 1.237863...\n$$\n将结果四舍五入到四位有效数字，得到 $1.238$。", "answer": "$$\n\\boxed{1.238}\n$$", "id": "3402803"}, {"introduction": "在复杂系统中，一个看似合理的反应坐标可能并不“完备”，因为它可能忽略了其他同样缓慢变化的“隐藏”自由度。本高级练习将介绍一种强大的统计诊断方法，该方法使用混合模型 (mixture models) 和贝叶斯信息准则 (BIC) 来检测这种隐藏变量的存在。成功完成本练习，意味着您将能够诊断并提出改进不完备反应坐标的方案，这是对复杂系统进行深入研究的一项关键能力。[@problem_id:3402799]", "problem": "考虑一个在两个亚稳盆（表示为集合 $A$ 和集合 $B$）之间经历稀有事件跃迁的系统，其中可能存在一个由离散隐藏状态 $I \\in \\{0,1\\}$ 标记的中间亚稳子系综。提交函数 (committor function) $q(\\mathbf{x})$ 定义为从构型 $\\mathbf{x}$ 开始的轨迹在到达集合 $A$ 之前先到达集合 $B$ 的概率。一个提出的一维反应坐标 (RC) 是一个可测函数 $\\xi: \\mathbf{x} \\mapsto \\mathbb{R}$。一个理想的 RC 应使得 $q(\\mathbf{x})$ 仅依赖于 $\\xi(\\mathbf{x})$，即 $q(\\mathbf{x}) = \\tilde{q}(\\xi(\\mathbf{x}))$，而不依赖于任何隐藏变量。\n\n您需要构建一个有原则的统计检验，用于检验在给定 $\\xi(\\mathbf{x})$ 的条件下，$q(\\mathbf{x})$ 是否独立于隐藏状态 $I$。如果检测到依赖性，则需要通过一个离散潜变量来对 RC 进行增强，并验证该增强消除了隐藏的依赖性。您的程序必须是自包含的，并对模拟分子动力学 (MD) 提交函数采样的合成数据集执行以下任务。\n\n基本基础和假设：\n- 提交函数定义为 $q(\\mathbf{x}) = \\mathbb{P}_{\\mathbf{x}}(\\tau_B  \\tau_A)$，其中 $\\tau_A$ 和 $\\tau_B$ 分别是在完整状态 $\\mathbf{x}$ 下具有马尔可夫性的动力学中，首次到达集合 $A$ 和 $B$ 的时间。\n- 给定一个反应坐标 $\\xi(\\mathbf{x}) \\in \\mathbb{R}$，$\\xi$ 是一个良好 RC 的必要条件是，对于一个固定的 $\\xi$ 值，观测到的短轨迹结果（在到达 $A$ 之前到达集合 $B$ 记为 $y=1$，或在到达 $B$ 之前到达集合 $A$ 记为 $y=0$）的分布是伯努利分布，其参数仅依赖于 $\\xi$，而不依赖于任何隐藏状态 $I$。\n- 如果在固定的 $\\xi$ 值下，隐藏状态 $I$ 是相关的，那么给定 $\\xi$ 时 $y \\in \\{0,1\\}$ 的条件分布可以用伯努利分布的混合来描述，其混合权重反映了 $P(I=1|\\xi)$。\n\n合成数据生成模型：\n- 设 $\\xi \\in [-1,1]$ 是独立同分布 (i.i.d.) 的均匀采样。\n- 设 $I \\in \\{0,1\\}$ 是一个隐藏状态，其中 $\\mathbb{P}(I=1) = 1/2$。\n- 定义一个基础 logit $L_{\\text{base}}(\\xi) = \\alpha \\,\\xi + b$，其中 $\\alpha \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$。\n- 定义一个局部调制 $g(\\xi) = \\exp\\left(-\\xi^2 / (2 s^2)\\right)$，其宽度参数为 $s  0$。\n- 对于一个隐藏状态对比度 $d \\ge 0$，定义依赖于隐藏状态的 logit\n$$\nL_I(\\xi) = L_{\\text{base}}(\\xi) + (2 I - 1)\\, d\\, g(\\xi),\n$$\n以及相应的伯努利参数\n$$\nq_I(\\xi) = \\frac{1}{1 + \\exp\\left(- L_I(\\xi)\\right)}.\n$$\n- 对于每个样本，独立地生成一个结果 $y \\sim \\text{Bernoulli}(q_I(\\xi))$。\n\n检测、增强和验证协议：\n1. 将区间 $[-1,1]$ 划分为 $B$ 个等宽的区间，选择区间的边界，使得每个区间 $b$ 包含 $n_b$ 个样本，其中 $n_b$ 是 $\\xi$ 值在该区间内的观测数量。只考虑 $n_b \\ge n_{\\min}$ 的区间。\n2. 对于每个这样的区间 $b$，使用最大似然和贝叶斯信息准则 (BIC) 来检验模型 $H_0$（单分量伯努利分布）与模型 $H_1$（带有离散潜变量的双分量伯努利混合分布）。具体来说：\n   - 在 $H_0$ 下，数据 $\\{y_i\\}_{i=1}^{n_b}$ 是 i.i.d. 的 $\\text{Bernoulli}(p)$，参数为 $p \\in (0,1)$。\n   - 在 $H_1$ 下，数据是 i.i.d. 的，来自混合分布 $\\pi \\,\\text{Bernoulli}(p_1) + (1-\\pi)\\,\\text{Bernoulli}(p_0)$，参数为 $\\pi \\in (0,1)$，$p_0 \\in (0,1)$ 和 $p_1 \\in (0,1)$。\n   - 设 $\\ell_0$ 是在 $H_0$ 下的最大化对数似然，$\\ell_1$ 是在 $H_1$ 下的最大化对数似然。定义\n     $$\n     \\mathrm{BIC}_0 = -2 \\ell_0 + k_0 \\log n_b, \\quad \\mathrm{BIC}_1 = -2 \\ell_1 + k_1 \\log n_b,\n     $$\n     其中 $k_0 = 1$ 和 $k_1 = 3$。设 $\\Delta \\mathrm{BIC}_b = \\mathrm{BIC}_0 - \\mathrm{BIC}_1$。正的 $\\Delta \\mathrm{BIC}_b > 0$ 表明混合模型更受青睐。\n3. 通过取所有考虑的区间中最大的改进值 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}} = \\max_b \\Delta \\mathrm{BIC}_b$ 来汇总增强前的证据。\n4. 如果 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}} \\ge T_{\\text{pre}}$，则宣布检测到对隐藏状态的依赖性。在这种情况下，通过引入一个推断的离散潜变量标签 $\\hat{I}$ 来增强 RC，如下所示：\n   - 对于每个区间 $b$，使用期望最大化 (EM) 算法通过最大似然拟合 $H_1$ 下的混合模型，并计算该区间中每个样本的后验责任。通过最大责任分配一个硬标签 $\\hat{I} \\in \\{0,1\\}$。\n   - 考虑增强后的 RC $(\\xi, \\hat{I})$，它明确包含了潜变量的预测。\n5. 通过在每个区间 $b$ 内对每个组 $\\hat{I}=0$ 和 $\\hat{I}=1$ 分别重复 BIC 比较来验证增强。通过 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{post}} = \\max_{b,\\hat{I}} \\Delta \\mathrm{BIC}_{b,\\hat{I}}$ 汇总增强后的证据。\n6. 如果 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}} \\ge T_{\\text{pre}}$ 并且 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{post}}  T_{\\text{post}}$，则宣布增强成功地消除了对隐藏状态的依赖性。\n\n实现约束：\n- 对 $H_0$ 和 $H_1$ 都使用最大似然。对于 $H_1$，使用期望最大化 (EM) 算法并进行多次随机重启以减轻局部最大值问题。通过将伯努利参数约束在 $[\\varepsilon,1-\\varepsilon]$（其中 $\\varepsilon$ 是一个小的正数）来保持数值稳定性。\n- 使用阈值 $T_{\\text{pre}} = 6.0$，$T_{\\text{post}} = 2.0$，每个测试用例指定的区间数 $B$，以及最小区间计数 $n_{\\min} = 50$。\n\n您的程序必须：\n- 使用上述模型生成三个合成数据集，参数元组 $(N, \\alpha, b, d, s, B, \\text{seed})$ 如下：\n  1. $(N=4000, \\alpha=4.0, b=0.0, d=2.0, s=0.25, B=6, \\text{seed}=1)$,\n  2. $(N=4000, \\alpha=4.0, b=0.0, d=0.0, s=0.25, B=6, \\text{seed}=2)$,\n  3. $(N=600, \\alpha=4.0, b=0.0, d=0.5, s=0.25, B=6, \\text{seed}=3)$.\n- 对于每个数据集，使用 $T_{\\text{pre}} = 6.0$，$T_{\\text{post}} = 2.0$ 和 $n_{\\min} = 50$ 执行上述的检测、增强和验证协议。\n- 为每个数据集生成一个整数作为最终结果：\n  - 如果根据阈值在增强前检测到隐藏状态依赖性，并在增强后成功消除，则输出 $\\;1\\;$。\n  - 否则，输出 $\\;0\\;$。\n\n您的程序应该生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[$r_1,r_2,r_3$]”），其中 $r_i$ 是数据集 $i$ 的整数结果。此问题不涉及物理单位，所有概率都是 $[0,1]$ 范围内的实数，无单位。不使用角度。不得使用百分比；请使用小数。", "solution": "用户希望在分子在两个状态 $A$ 和 $B$ 之间跃迁的背景下，构建一个统计检验来验证一个提出的反应坐标 (RC) $\\xi(\\mathbf{x})$。一个好的 RC 应该能捕捉所有慢自由度，这意味着提交概率 $q(\\mathbf{x})$ 应该仅仅是 $\\xi$ 的函数。该问题假设可能存在一个隐藏的离散变量 $I$ 也影响着提交概率。任务是检测这种依赖性，如果发现，则用一个推断出的隐藏变量版本 $\\hat{I}$ 来增强 RC，并验证新的 RC $(\\xi, \\hat{I})$ 是完备的。\n\n解决方案以一个计算协议的形式实现，该协议在合成生成的数据上运行。这些数据模拟了从分子动力学模拟中进行提交函数采样的统计特性。该协议基于统计模型选择的原则。\n\n**1. 统计建模与假设检验**\n\n对于给定的 RC 值 $\\xi$，轨迹的结果（在 $A$ 或 $B$ 中结束）是二元事件。如果 $\\xi$ 是一个好的 RC，这些结果应遵循一个具有单一参数 $p(\\xi)$ 的伯努利分布。这是我们的零假设 $H_0$。\n\n如果一个隐藏变量 $I$ 也相关，那么对于一个固定的 $\\xi$，存在对应于不同 $I$ 值的不同子群体。例如，如果 $I \\in \\{0, 1\\}$，轨迹可能在 $I=0$ 时遵循参数为 $p_0(\\xi)$ 的伯努利过程，在 $I=1$ 时遵循参数为 $p_1(\\xi)$ 的伯努利过程。那么，对于固定 $\\xi$ 的总体结果分布是两个伯努利分布的混合：\n$$\n\\mathbb{P}(y=1 \\mid \\xi) = (1-\\pi(\\xi)) p_0(\\xi) + \\pi(\\xi) p_1(\\xi)\n$$\n其中 $y \\in \\{0,1\\}$ 是结果，$\\pi(\\xi) = \\mathbb{P}(I=1 \\mid \\xi)$ 是混合比例。这构成了我们的备择假设 $H_1$。\n\n为了进行统计检验，我们将连续的 RC $\\xi$ 离散化为 $B$ 个区间。在每个区间 $b$ 内，我们视 $\\xi$ 为近似恒定。然后，我们可以使用该区间中的数据 $\\{y_i\\}$ 来检验 $H_0$ 与 $H_1$。\n\n**2. 通过贝叶斯信息准则 (BIC) 进行模型选择**\n\n为了比较这两个模型，我们使用贝叶斯信息准则 (BIC)，定义为：\n$$\n\\mathrm{BIC} = -2\\ell + k \\log n_b\n$$\n其中 $\\ell$ 是模型的最大化对数似然， $k$ 是模型中的自由参数数量， $n_b$ 是区间中的数据点数量。BIC 值较低的模型更优。\n\n- 对于 $H_0$（单一伯努利分布），我们有一个参数 $p$。因此，$k_0 = 1$。最大似然估计就是样本均值 $\\hat{p} = \\frac{1}{n_b}\\sum y_i$。\n- 对于 $H_1$（双分量伯努利混合分布），我们有三个参数：混合权重 $\\pi$ 和两个伯努利参数 $p_0$ 和 $p_1$。因此，$k_1 = 3$。由于没有封闭解，我们使用期望最大化 (EM) 算法来找到这些参数的最大似然估计。\n\n支持更复杂的混合模型 $H_1$ 的证据由差值 $\\Delta\\mathrm{BIC}_b = \\mathrm{BIC}_0 - \\mathrm{BIC}_1$ 来量化。一个正的 $\\Delta\\mathrm{BIC}_b$ 表明，即使在对其额外复杂性进行惩罚之后，$H_1$ 在区间 $b$ 中也优于 $H_0$。\n\n**3. 检测、增强和验证协议**\n\n整个流程是一个三步过程：\n\n**步骤 A：检测隐藏状态依赖性**\n首先，我们分析原始的 RC $\\xi$。我们为每个（具有足够数据，$n_b \\ge n_{\\min}$ 的）区间 $b$ 计算 $\\Delta\\mathrm{BIC}_b$。所有区间的最大值 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}} = \\max_b \\Delta \\mathrm{BIC}_b$ 作为存在隐藏变量的全局证据度量。如果 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}}$ 超过一个预定义的阈值 $T_{\\text{pre}}$，我们宣布 RC $\\xi$ 是不完备的，并检测到对隐藏状态的依赖。\n\n**步骤 B：反应坐标增强**\n如果检测到依赖性，我们增强反应坐标。我们使用拟合 $H_1$ 时 EM 算法的结果。对于区间 $b$ 中的每个数据点 $i$，EM 算法提供了该点属于混合模型第二个分量的后验概率（或责任）$\\gamma_i = \\mathbb{P}(\\text{state}=1 | y_i, \\hat{\\pi}, \\hat{p_0}, \\hat{p_1})$。如果 $\\gamma_i \\ge 0.5$，我们分配一个推断标签 $\\hat{I}_i=1$，否则 $\\hat{I}_i=0$。新的、增强的 RC 是序对 $(\\xi, \\hat{I})$。\n\n**步骤 C：验证增强的 RC**\n增强的 RC $(\\xi, \\hat{I})$ 现在应该是“完备的”，这意味着对于固定的 $\\xi$ 值（即在一个区间内）和固定的推断标签 $\\hat{I}$，提交函数不应再有任何剩余的隐藏结构。为了验证这一点，我们重复 BIC 检验。对于每个区间 $b$ 和每个推断标签 $j \\in \\{0, 1\\}$，我们考虑数据子集 $\\{y_i \\mid \\xi_i \\in \\text{bin } b, \\hat{I}_i = j \\}$。我们再次为每个这样的子组计算 $\\Delta\\mathrm{BIC}_{b, j}$。任何剩余结构的新聚合证据是 $\\Delta \\mathrm{BIC}_{\\max}^{\\text{post}} = \\max_{b,j} \\Delta\\mathrm{BIC}_{b, j}$。如果该值低于第二个（通常较小的）阈值 $T_{\\text{post}}$，我们断定增强成功地消除了隐藏状态的依赖性。\n\n当且仅当首先检测到依赖性（$\\Delta \\mathrm{BIC}_{\\max}^{\\text{pre}} \\ge T_{\\text{pre}}$）然后通过增强成功地将其移除（$\\Delta \\mathrm{BIC}_{\\max}^{\\text{post}}  T_{\\text{post}}$）时，整个过程才被视为成功。\n\n提供的 Python 代码实现了这整个协议，包括合成数据生成、为保证鲁棒性而采用多次重启的 EM 算法，以及针对指定测试用例的完整检测-增强-验证工作流程。通过将参数裁剪到小的区间 $[\\varepsilon, 1-\\varepsilon]$ 内并在适当之处使用对数计算，确保了数值稳定性。", "answer": "```python\nimport numpy as np\nfrom scipy.special import expit, logsumexp\n\n# Define problem constants\nEPS = 1e-9\nN_RESTARTS = 10\nMAX_EM_ITER = 100\nEM_TOL = 1e-6\nT_PRE = 6.0\nT_POST = 2.0\nN_MIN = 50\n\ndef generate_data(N, alpha, b, d, s, rng):\n    \"\"\"Generates synthetic data based on the problem specification.\"\"\"\n    xi = rng.uniform(-1, 1, N)\n    I = rng.integers(0, 2, size=N)\n    \n    l_base = alpha * xi + b\n    g = np.exp(-xi**2 / (2 * s**2))\n    l_I = l_base + (2 * I - 1) * d * g\n    \n    q_I = expit(l_I)\n    \n    y = rng.binomial(1, q_I)\n    return xi, y\n\ndef fit_mixture_em(y_data, rng):\n    \"\"\"\n    Fits a 2-component Bernoulli mixture model using Expectation-Maximization.\n    \"\"\"\n    n = len(y_data)\n    best_log_L = -np.inf\n    best_params = (0.5, 0.25, 0.75)\n    best_responsibilities = np.full(n, 0.5)\n\n    for _ in range(N_RESTARTS):\n        # Initialize by random partition\n        perm = rng.permutation(n)\n        mid = n // 2\n        y_group0, y_group1 = y_data[perm[:mid]], y_data[perm[mid:]]\n        \n        pi = 0.5\n        p0 = np.mean(y_group0) if mid  0 else 0.5\n        p1 = np.mean(y_group1) if (n - mid)  0 else 0.5\n        \n        if p0  p1: p0, p1 = p1, p0\n        \n        pi = np.clip(pi, EPS, 1 - EPS)\n        p0 = np.clip(p0, EPS, 1 - EPS)\n        p1 = np.clip(p1, EPS, 1 - EPS)\n        if np.abs(p0 - p1)  EPS:\n            p0 = np.clip(p0 - 0.05, EPS, 1 - EPS)\n            p1 = np.clip(p1 + 0.05, EPS, 1 - EPS)\n\n        log_L = -np.inf\n        for _ in range(MAX_EM_ITER):\n            # E-step\n            log_p_y_0 = y_data * np.log(p0) + (1 - y_data) * np.log(1 - p0)\n            log_p_y_1 = y_data * np.log(p1) + (1 - y_data) * np.log(1 - p1)\n            \n            log_joints = np.array([np.log(1 - pi) + log_p_y_0, np.log(pi) + log_p_y_1])\n            log_marg_prob_y = logsumexp(log_joints, axis=0)\n            \n            gamma_1 = np.exp(log_joints[1] - log_marg_prob_y)\n            \n            # Log-Likelihood\n            new_log_L = np.sum(log_marg_prob_y)\n            if np.abs(new_log_L - log_L)  EM_TOL:\n                log_L = new_log_L\n                break\n            log_L = new_log_L\n\n            # M-step\n            gamma_sum_1 = np.sum(gamma_1)\n            gamma_sum_0 = n - gamma_sum_1\n            \n            pi = gamma_sum_1 / n\n            p0 = np.sum((1 - gamma_1) * y_data) / gamma_sum_0 if gamma_sum_0  EPS else EPS\n            p1 = np.sum(gamma_1 * y_data) / gamma_sum_1 if gamma_sum_1  EPS else 1 - EPS\n            \n            if p0  p1:\n                p0, p1 = p1, p0\n                pi = 1 - pi\n            \n            pi = np.clip(pi, EPS, 1 - EPS)\n            p0 = np.clip(p0, EPS, 1 - EPS)\n            p1 = np.clip(p1, EPS, 1 - EPS)\n\n        if log_L  best_log_L:\n            best_log_L = log_L\n            best_params = (pi, p0, p1)\n            \n            # Recalculate final responsibilities with best params\n            final_p0, final_p1 = best_params[1], best_params[2]\n            log_p_y_0_final = y_data * np.log(final_p0) + (1 - y_data) * np.log(1 - final_p0)\n            log_p_y_1_final = y_data * np.log(final_p1) + (1 - y_data) * np.log(1 - final_p1)\n            log_joints_final = np.array([np.log(1 - best_params[0]) + log_p_y_0_final, np.log(best_params[0]) + log_p_y_1_final])\n            log_marg_prob_y_final = logsumexp(log_joints_final, axis=0)\n            best_responsibilities = np.exp(log_joints_final[1] - log_marg_prob_y_final)\n\n    return best_log_L, best_params, best_responsibilities\n\ndef analyze_bin(y_data, rng):\n    \"\"\"Calculates Delta BIC and inferred labels for a bin of data.\"\"\"\n    n_b = len(y_data)\n    y_sum = np.sum(y_data)\n\n    # H0 model: single Bernoulli\n    if n_b == 0: return -np.inf, np.array([])\n    p_h0 = np.clip(y_sum / n_b, EPS, 1 - EPS)\n    log_L0 = y_sum * np.log(p_h0) + (n_b - y_sum) * np.log(1 - p_h0)\n    bic0 = -2 * log_L0 + 1 * np.log(n_b)\n    \n    # H1 model: 2-component mixture\n    if y_sum == 0 or y_sum == n_b:\n        log_L1 = log_L0\n        labels = np.zeros_like(y_data) if y_sum == 0 else np.ones_like(y_data)\n    else:\n        log_L1, _, responsibilities = fit_mixture_em(y_data, rng)\n        labels = (responsibilities = 0.5).astype(int)\n\n    bic1 = -2 * log_L1 + 3 * np.log(n_b)\n    \n    delta_bic = bic0 - bic1\n    return delta_bic, labels\n\ndef run_full_analysis(N, alpha, b, d, s, B, seed):\n    \"\"\"Performs the full detection, augmentation, and validation protocol.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    xi, y = generate_data(N, alpha, b, d, s, rng)\n\n    bin_width = 2.0 / B\n    bin_indices = np.floor((xi - (-1)) / bin_width).astype(int)\n    bin_indices = np.clip(bin_indices, 0, B - 1)\n\n    # Pre-augmentation analysis\n    delta_bic_max_pre = -np.inf\n    all_labels = np.full(N, -1, dtype=int)\n    valid_bins = []\n\n    for b_idx in range(B):\n        mask = (bin_indices == b_idx)\n        y_bin = y[mask]\n        \n        if len(y_bin)  N_MIN: continue\n        \n        valid_bins.append(b_idx)\n        delta_bic, labels = analyze_bin(y_bin, rng)\n        delta_bic_max_pre = max(delta_bic_max_pre, delta_bic)\n        all_labels[mask] = labels\n\n    # Detection check\n    if delta_bic_max_pre  T_PRE:\n        return 0\n\n    # Post-augmentation validation\n    delta_bic_max_post = -np.inf\n    for b_idx in valid_bins:\n        for i_hat in [0, 1]:\n            mask = (bin_indices == b_idx)  (all_labels == i_hat)\n            y_subgroup = y[mask]\n            \n            if len(y_subgroup)  N_MIN: continue\n            \n            delta_bic, _ = analyze_bin(y_subgroup, rng)\n            delta_bic_max_post = max(delta_bic_max_post, delta_bic)\n    \n    # If no subgroup qualified, max_post is -inf, which is  T_POST. Correct.\n\n    # Final decision\n    return 1 if delta_bic_max_post  T_POST else 0\n\ndef solve():\n    \"\"\"Main function to run the analysis for all test cases.\"\"\"\n    test_cases = [\n        (4000, 4.0, 0.0, 2.0, 0.25, 6, 1),\n        (4000, 4.0, 0.0, 0.0, 0.25, 6, 2),\n        (600, 4.0, 0.0, 0.5, 0.25, 6, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_full_analysis(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3402799"}]}