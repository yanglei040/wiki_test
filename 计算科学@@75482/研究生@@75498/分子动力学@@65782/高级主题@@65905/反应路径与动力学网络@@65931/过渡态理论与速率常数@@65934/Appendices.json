{"hands_on_practices": [{"introduction": "本练习旨在将过渡态理论的速率常数 $k_{\\mathrm{TST}}$ 与分子模拟数据联系起来，让你从实践中理解其计算方法。你将学习如何利用从伞形采样中提取的平均力势（PMF）和从约束动力学中获得的速度信息来估算反应速率。这项实践对于掌握从模拟数据（例如 $\\Delta F^\\ddagger$）出发计算化学反应速率的核心技能至关重要。[@problem_id:3458168]", "problem": "要求您设计一个完整、可运行的程序，该程序计算过渡态理论速率常数，并使用模拟伞形采样和约束速度统计的数据，对照无偏分子动力学测量结果进行验证。推导必须从适用于分子动力学和过渡态理论的统计力学和动力学的基本原理开始，且算法必须实现所推导的表达式，不得使用题目陈述中提供的简化公式。程序必须为每个测试用例实现以下步骤：从一维平均力势推断势垒高度，计算分割面处绝对速度的约束平均值，并使用平衡统计力学获得一个速率常数，然后将其与无偏动力学数据中观察到的速率进行比较。目标是通过推导基于通量的估计为何将约束速度统计和平衡势垒高度与速率常数联系起来，从而检验从第一性原理出发的推理能力。\n\n将反应坐标定义为单个无量纲坐标 $s$，其具有离散网格 $s_i$ 和以千焦耳/摩尔为单位的平均力势 $F(s_i)$。分割面位于沿 $s$ 坐标的势垒顶部。温度 $T$ 以开尔文为单位指定。分割面处的约束速度统计以在将 $s$ 维持在分割面时收集的 $\\dot{s}$ 样本形式提供，单位为秒的倒数。无偏分子动力学速率由总模拟时间（以秒为单位）内的整数跃迁计数推断得出。所有量都必须以科学上自洽的方式处理。\n\n使用普适气体常数 $R$，单位为千焦耳/摩尔/开尔文，具体值为 $R = 8.314462618 \\times 10^{-3}$，这样当 $F$ 是以千焦耳/摩尔为单位的摩尔自由能时，逆热能为 $\\beta = 1 / (R T)$。速率常数必须以秒的倒数表示。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 将分割面位置 $s^\\ddagger$ 确定为给定网格上 $F(s)$ 最大的网格点。\n- 将反应物盆地参考位置 $s_{\\mathrm{R}}$ 确定为满足 $s \\leq s_{\\mathrm{cut}}$ 的网格点中 $F(s)$ 最小的点，其中 $s_{\\mathrm{cut}}$ 是一个用于隔离反应物侧的给定阈值。\n- 计算势垒高度 $\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_{\\mathrm{R}})$，单位为千焦耳/摩尔。\n- 计算分割面处绝对速度的约束平均值 $\\langle |\\dot{s}| \\rangle^\\ddagger$，即所提供的 $\\dot{s}$ 样本（单位为秒的倒数）绝对值的算术平均值：\n$$\n\\langle |\\dot{s}| \\rangle^\\ddagger = \\frac{1}{N} \\sum_{j=1}^{N} \\left| \\dot{s}_j \\right| .\n$$\n- 利用平衡统计力学和速率跨越分割面的通量诠释，推导过渡态理论对速率常数的估计值，单位为秒的倒数。在您的程序中，仅使用上述计算出的量和基本常数来实现所得表达式，其中 $F$ 被视为摩尔自由能，且 $\\beta = 1 / (R T)$。\n- 计算无偏分子动力学速率 $k_{\\mathrm{MD}}$，单位为秒的倒数，其值为观察到的整数跃迁计数除以总模拟时间（以秒为单位）。\n- 通过检查绝对相对差异是否至多为一个以小数表示的指定容差 $\\varepsilon$，来验证过渡态理论结果与无偏分子动力学结果的一致性：\n$$\n\\left| \\frac{k_{\\mathrm{TST}} - k_{\\mathrm{MD}}}{k_{\\mathrm{MD}}} \\right| \\leq \\varepsilon .\n$$\n\n单位和输出要求：\n- 所有速率常数必须以秒的倒数为单位。\n- 所有能量必须以千焦耳/摩尔为单位。\n- 所有速度 $\\dot{s}$ 必须以秒的倒数为单位。\n- 所有时间必须以秒为单位。\n- 此问题中不涉及角度。\n- 验证容差以小数形式提供。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是按 $[k_{\\mathrm{TST}}, k_{\\mathrm{MD}}, \\text{pass}]$ 顺序排列的包含三个元素的列表。例如，输出的形状必须为 $[[x_1,y_1,b_1],[x_2,y_2,b_2],[x_3,y_3,b_3]]$，其中 $x_i$ 和 $y_i$ 为浮点数，$b_i$ 为布尔值。\n\n测试套件规范：\n- 使用 $R = 8.314462618 \\times 10^{-3}$，单位为千焦耳/摩尔/开尔文。\n- 容差 $\\varepsilon = 0.1$。\n\n测试用例 1 (正常路径，中等势垒)：\n- 温度 $T = 300$ 开尔文。\n- 反应物侧截断值 $s_{\\mathrm{cut}} = -0.5$。\n- 网格 $s$ 值：\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- 平均力势 $F(s)$，单位为千焦耳/摩尔：\n$[2.0, 1.0, 0.0, 1.5, 6.0, 10.0, 6.0, 1.5, 0.5, 0.8, 1.8]$.\n- 分割面处的约束速度样本，单位为秒的倒数：\n$[-8.0 \\times 10^{11}, 1.2 \\times 10^{12}, -5.5 \\times 10^{11}, 6.0 \\times 10^{11}, -1.0 \\times 10^{11}, 9.0 \\times 10^{11}, -1.1 \\times 10^{12}, 7.0 \\times 10^{11}, 3.0 \\times 10^{11}, -4.0 \\times 10^{11}]$.\n- 无偏分子动力学观察到的跃迁计数 $= 3463$，总模拟时间 $= 5.0 \\times 10^{-7}$ 秒。\n\n测试用例 2 (边界情况，几乎无势垒)：\n- 温度 $T = 300$ 开尔文。\n- 反应物侧截断值 $s_{\\mathrm{cut}} = -0.5$。\n- 网格 $s$ 值：\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- 平均力势 $F(s)$，单位为千焦耳/摩尔：\n$[0.2, 0.1, 0.0, 0.1, 0.3, 0.5, 0.3, 0.1, 0.05, 0.08, 0.15]$.\n- 分割面处的约束速度样本，单位为秒的倒数：\n$[-4.0 \\times 10^{11}, 6.0 \\times 10^{11}, -3.0 \\times 10^{11}, 5.5 \\times 10^{11}, -2.0 \\times 10^{11}, 5.0 \\times 10^{11}, -4.5 \\times 10^{11}, 4.0 \\times 10^{11}, 3.5 \\times 10^{11}, -3.2 \\times 10^{11}]$.\n- 无偏分子动力学观察到的跃迁计数 $= 1665$，总模拟时间 $= 1.0 \\times 10^{-8}$ 秒。\n\n测试用例 3 (边缘情况，高势垒)：\n- 温度 $T = 300$ 开尔文。\n- 反应物侧截断值 $s_{\\mathrm{cut}} = -0.5$。\n- 网格 $s$ 值：\n$[-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$.\n- 平均力势 $F(s)$，单位为千焦耳/摩尔：\n$[4.0, 2.5, 0.0, 5.0, 15.0, 25.0, 15.0, 6.0, 3.0, 2.0, 3.5]$.\n- 分割面处的约束速度样本，单位为秒的倒数：\n$[-9.0 \\times 10^{11}, 1.0 \\times 10^{12}, -7.5 \\times 10^{11}, 8.0 \\times 10^{11}, -6.0 \\times 10^{11}, 9.0 \\times 10^{11}, -1.1 \\times 10^{12}, 7.0 \\times 10^{11}, 5.0 \\times 10^{11}, -8.0 \\times 10^{11}]$.\n- 无偏分子动力学观察到的跃迁计数 $= 179$，总模拟时间 $= 1.0 \\times 10^{-5}$ 秒。\n\n您的程序应为这三个测试用例生成一行输出，其中包含一个结果列表，格式完全如下：\n$[[k_{\\mathrm{TST}}^{(1)}, k_{\\mathrm{MD}}^{(1)}, \\text{pass}^{(1)}],[k_{\\mathrm{TST}}^{(2)}, k_{\\mathrm{MD}}^{(2)}, \\text{pass}^{(2)}],[k_{\\mathrm{TST}}^{(3)}, k_{\\mathrm{MD}}^{(3)}, \\text{pass}^{(3)}]]$，\n其中每个 $k$ 是一个以秒的倒数为单位的浮点数，每个 $\\text{pass}$ 是一个布尔值。", "solution": "该问题要求使用分子模拟提供的数据，推导并实现过渡态理论 (TST) 速率常数 $k_{\\mathrm{TST}}$ 的公式，并对照直接的分子动力学 (MD) 速率 $k_{\\mathrm{MD}}$ 进行验证。推导必须基于统计力学和动力学的基本原理。\n\n反应的 TST 速率常数描述了布居从反应物态到产物态的流动速率。在其常见表述中，它表示为由反应物形成过渡态的平衡常数 $K^\\ddagger$ 与表征越过过渡态势垒速率的频率因子 $\\nu$ 的乘积。\n$$\nk_{\\mathrm{TST}} = \\nu K^\\ddagger\n$$\n该表达式将问题分解为一个平衡部分（统计力学）和一个动力学部分（动力学）。\n\n首先，我们处理平衡常数 $K^\\ddagger$。在统计力学中，对于反应 $R \\rightleftharpoons TS$（其中 $TS$ 代表过渡态），平衡常数与标准吉布斯自由能的变化 $\\Delta G^\\ddagger$ 相关，或者在此情境下，与平均力势 (PMF) 的变化 $\\Delta F^\\ddagger$ 相关。PMF，$F(s)$，代表系统自由能作为反应坐标 $s$ 的函数。平衡常数由下式给出：\n$$\nK^\\ddagger = \\frac{[TS]}{[R]} = e^{-\\Delta F^\\ddagger / (RT)} = e^{-\\beta \\Delta F^\\ddagger}\n$$\n此处，$[TS]$ 和 $[R]$ 分别是过渡态和反应物态的布居或配分函数。$\\Delta F^\\ddagger$ 项是自由能垒，计算为过渡态（分割面，$s^\\ddagger$）处的 PMF 与反应物态最低点（$s_R$）处的 PMF 之差。问题提供了直接计算此值的方法。\n$$\n\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_R)\n$$\n$s^\\ddagger$ 值是 $F(s)$ 最大值的位置，$s_R$ 是反应物盆地中 $F(s)$ 最小值的位置。逆热能为 $\\beta = 1/(RT)$，其中 $R$ 是摩尔气体常数，这与 $F(s)$ 是以 $\\text{kJ/mol}$ 为单位的摩尔自由能相一致。\n\n接下来，我们必须确定频率因子 $\\nu$，它代表已达到过渡态的系统穿过分割面的速率。问题在分割面 $s^\\ddagger$ 处提供了约束速度样本 $\\dot{s}_j$。反应坐标 $s$ 是无量纲的，因此其时间导数 $\\dot{s}$ 的单位是时间的倒数 ($s^{-1}$)，即频率。从反应物到产物的单向通量取决于沿正向运动（$\\dot{s}  0$）的系统的平均速度。这个平均正向速度表示为 $\\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger$。这个量可以解释为处于过渡态的系统成功进入产物盆地的特征频率。因此，我们确定 $\\nu = \\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger$。\n\n问题提供了在 $s^\\ddagger$ 处的 $\\dot{s}$ 样本，我们可以从中计算绝对速度的约束平均值 $\\langle |\\dot{s}| \\rangle^\\ddagger$。在过渡态，这是一个不稳定的平衡点，我们假设没有净通量，这意味着速度分布关于 $\\dot{s}=0$ 是对称的。因此，平均正向速度是平均速率的一半：\n$$\n\\langle \\dot{s} \\rangle_{\\dot{s}0}^\\ddagger = \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger\n$$\n其中 $\\langle |\\dot{s}| \\rangle^\\ddagger$ 计算为速度样本绝对值的算术平均值：\n$$\n\\langle |\\dot{s}| \\rangle^\\ddagger = \\frac{1}{N} \\sum_{j=1}^{N} \\left| \\dot{s}_j \\right|\n$$\n\n通过组合这些部分，我们得出了 TST 速率常数的最终表达式，该表达式按要求将所提供的平衡和动力学量联系起来：\n$$\nk_{\\mathrm{TST}} = \\nu K^\\ddagger = \\left( \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger \\right) e^{-\\beta \\Delta F^\\ddagger}\n$$\n该公式在量纲上是一致的，$k_{\\mathrm{TST}}$ 的单位为 $s^{-1}$，并且它完全利用了从问题输入数据中导出的量：势垒高度 $\\Delta F^\\ddagger$ 和分割面上的平均绝对速度 $\\langle |\\dot{s}| \\rangle^\\ddagger$。\n\n程序中实现的算法对每个测试用例按以下步骤进行：\n1.  使用给定的温度 $T$ 和气体常数 $R$ 计算 $\\beta = 1/(RT)$ 的值。\n2.  扫描平均力势网格 $F(s)$ 以找到其最大值。将相应的坐标和能量确定为 $s^\\ddagger$ 和 $F(s^\\ddagger)$。\n3.  扫描网格的反应物部分 ($s \\leq s_{\\mathrm{cut}}$) 以找到 $F(s)$ 的最小值。这定义了坐标为 $s_R$、能量为 $F(s_R)$ 的反应物参考态。\n4.  计算自由能垒为 $\\Delta F^\\ddagger = F(s^\\ddagger) - F(s_R)$。\n5.  从提供的速度样本中计算约束平均绝对速度 $\\langle |\\dot{s}| \\rangle^\\ddagger$。\n6.  使用推导出的公式计算 TST 速率常数 $k_{\\mathrm{TST}}$：$k_{\\mathrm{TST}} = \\frac{1}{2} \\langle |\\dot{s}| \\rangle^\\ddagger e^{-\\beta \\Delta F^\\ddagger}$。\n7.  计算无偏分子动力学速率 $k_{\\mathrm{MD}}$，其值为观察到的总跃迁数除以总模拟时间。\n8.  最后，通过检查绝对相对差异是否在容差 $\\varepsilon=0.1$ 范围内来验证 TST 速率与 MD 速率的一致性：$|\\frac{k_{\\mathrm{TST}} - k_{\\mathrm{MD}}}{k_{\\mathrm{MD}}}| \\leq \\varepsilon$。\n将包含 $k_{\\mathrm{TST}}$、$k_{\\mathrm{MD}}$ 和一个指示验证结果的布尔值的结果收集起来，用于所有测试用例，并格式化为所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates TST rate constants against MD measurements.\n    \"\"\"\n    # Universal gas constant in kJ/(mol·K)\n    R = 8.314462618e-3\n    # Validation tolerance\n    TOLERANCE = 0.1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 300,  # Kelvin\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [2.0, 1.0, 0.0, 1.5, 6.0, 10.0, 6.0, 1.5, 0.5, 0.8, 1.8],  # kJ/mol\n            \"s_dot_samples\": [-8.0e11, 1.2e12, -5.5e11, 6.0e11, -1.0e11, 9.0e11, -1.1e12, 7.0e11, 3.0e11, -4.0e11],  # s^-1\n            \"md_transitions\": 3463,\n            \"md_time\": 5.0e-7  # seconds\n        },\n        {\n            \"T\": 300,\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [0.2, 0.1, 0.0, 0.1, 0.3, 0.5, 0.3, 0.1, 0.05, 0.08, 0.15],\n            \"s_dot_samples\": [-4.0e11, 6.0e11, -3.0e11, 5.5e11, -2.0e11, 5.0e11, -4.5e11, 4.0e11, 3.5e11, -3.2e11],\n            \"md_transitions\": 1665,\n            \"md_time\": 1.0e-8\n        },\n        {\n            \"T\": 300,\n            \"s_cut\": -0.5,\n            \"s_grid\": [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"F_s\": [4.0, 2.5, 0.0, 5.0, 15.0, 25.0, 15.0, 6.0, 3.0, 2.0, 3.5],\n            \"s_dot_samples\": [-9.0e11, 1.0e12, -7.5e11, 8.0e11, -6.0e11, 9.0e11, -1.1e12, 7.0e11, 5.0e11, -8.0e11],\n            \"md_transitions\": 179,\n            \"md_time\": 1.0e-5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract data for the current case\n        T = case[\"T\"]\n        s_cut = case[\"s_cut\"]\n        s_grid = np.array(case[\"s_grid\"])\n        F_s = np.array(case[\"F_s\"])\n        s_dot_samples = np.array(case[\"s_dot_samples\"])\n        md_transitions = case[\"md_transitions\"]\n        md_time = case[\"md_time\"]\n\n        # Step 1: Compute inverse thermal energy\n        beta = 1.0 / (R * T)  # (mol/kJ)\n\n        # Step 2: Identify dividing surface (transition state)\n        idx_ts = np.argmax(F_s)\n        F_ts = F_s[idx_ts]\n\n        # Step 3: Identify reactant basin reference\n        reactant_mask = s_grid = s_cut\n        F_s_reactant_side = F_s[reactant_mask]\n        idx_r_local = np.argmin(F_s_reactant_side)\n        F_r = F_s_reactant_side[idx_r_local]\n        \n        # Step 4: Compute the barrier height\n        delta_F_ddagger = F_ts - F_r  # kJ/mol\n\n        # Step 5: Compute the constrained average of the absolute velocity\n        avg_abs_s_dot_ddagger = np.mean(np.abs(s_dot_samples))  # s^-1\n\n        # Step 6: Compute the TST rate constant\n        # k_TST = (1/2) * |s_dot|` * exp(-beta * dF`)\n        k_tst = 0.5 * avg_abs_s_dot_ddagger * np.exp(-beta * delta_F_ddagger)\n\n        # Step 7: Compute the unbiased molecular dynamics rate\n        k_md = md_transitions / md_time\n\n        # Step 8: Validate TST result against MD result\n        if k_md == 0:\n            # Avoid division by zero, though not expected for these test cases.\n            # If MD rate is zero, TST rate should also be zero for a match.\n            validation_passed = (k_tst == 0)\n        else:\n            rel_diff = np.abs((k_tst - k_md) / k_md)\n            validation_passed = rel_diff = TOLERANCE\n            \n        results.append([k_tst, k_md, validation_passed])\n\n    # Final print statement in the exact required format.\n    # The format [[x1,y1,b1],[x2,y2,b2],...] requires converting Python list to string.\n    # Python's default str() for lists and booleans matches the requirement.\n    print(str(results).replace(\"'\", \"\"))\n\nsolve()\n\n```", "id": "3458168"}, {"introduction": "这个练习将深入剖析过渡态理论速率常数，以探索其各组成部分的物理起源。通过研究原子质量对动力学预因子的影响，我们将验证 $k_{\\mathrm{TST}} \\propto 1/\\sqrt{m_{\\mathrm{eff}}}$ 这一关键理论预测。同时，本练习也将证实自由能垒 $\\Delta F^\\ddagger$ 在理论上与质量无关，从而加深对 TST 公式中动力学与构型贡献分离的理解。[@problem_id:3458183]", "problem": "考虑一个经典系统，其 $n=4$ 个笛卡尔坐标汇集在向量 $\\mathbf{q}\\in\\mathbb{R}^4$ 中。定义一个线性反应坐标 $s=\\hat{\\mathbf{a}}^\\top \\mathbf{q}$，其中 $\\hat{\\mathbf{a}}=\\mathbf{a}/\\lVert \\mathbf{a}\\rVert$ 且 $\\mathbf{a}=(1.0,-2.0,0.5,0.25)$。将 $\\hat{\\mathbf{a}}$ 补充为 $\\mathbb{R}^4$ 的一个标准正交基，以定义横向坐标 $\\mathbf{y}\\in\\mathbb{R}^3$，使得正交变量变换 $\\mathbf{q}\\mapsto (s,\\mathbf{y})$ 的雅可比行列式为单位值。假定势能函数在这些坐标中是可分的，并由下式给出\n$$\nU(s,\\mathbf{y})=\\frac{1}{2}k_R\\,(s+s_0)^2+\\frac{1}{2}\\kappa_\\perp \\sum_{i=1}^{3} y_i^2,\n$$\n参数为 $k_R=5.0$，$s_0=1.0$ 和 $\\kappa_\\perp=3.0$。反应物区域由指示函数 $h_R=\\Theta(-s)$ 定义，分割面由 $s=0$ 定义，其中 $\\Theta(\\cdot)$ 是 Heaviside 阶跃函数。该系统与一个绝对温度为 $T=0.7$ 的热浴耦合，单位为约化单位，其中玻尔兹曼常数 $k_B=1$（即，能量与 $k_B T$ 具有相同的约化单位）。笛卡尔坐标系中的质量矩阵是对角的，$\\mathbf{M}=\\mathrm{diag}(m_1,m_2,m_3,m_4)$，其基础质量集为 $\\mathbf{m}^{(0)}=(1.0,2.0,3.0,4.0)$。\n\n你的任务是编写一个完整的程序，从过渡态理论 (Transition State Theory, TST) 中速率常数作为相空间平均的正则定义出发，并基于速度的麦克斯韦-玻尔兹曼统计，执行以下步骤：\n\n- 推导沿反应坐标的有效质量 $m_{\\mathrm{eff}}$ 的表达式，该表达式是质量矩阵 $\\mathbf{M}$ 和单位向量 $\\hat{\\mathbf{a}}$ 的函数。\n- 从带有分割面上 delta 函数约束和反应物区域特征函数的正则 TST 定义出发，为给定的谐波形式 $U(s,\\mathbf{y})$ 推导 TST 速率常数 $k_{\\mathrm{TST}}$ 的闭合形式表达式。\n- 使用这些推导来计算 $k_{\\mathrm{TST}}$ 和由下式定义的势垒自由能 $\\Delta F^\\ddagger$\n$$\n\\Delta F^\\ddagger = -T \\ln\\left(\\frac{\\int d\\mathbf{y}\\,e^{-U(0,\\mathbf{y})/T}}{\\int_{s0} ds\\, d\\mathbf{y}\\,e^{-U(s,\\mathbf{y})/T}}\\right),\n$$\n针对下述多种质量缩放情景。\n\n科学约束和要求：\n- 将动量和坐标分布的正则系综因子分解视为基本原理，并且除了从此因子分解和基本高斯积分得出的结果外，不要假设任何关于 $k_{\\mathrm{TST}}$ 的结论。\n- 程序必须对每种质量缩放情况验证两个性质：(i) $k_{\\mathrm{TST}}$ 的指前因子与沿 $s$ 的有效质量的平方根倒数成比例（即，在势和温度固定的情况下，$k_{\\mathrm{TST}}\\propto \\sqrt{T/m_{\\mathrm{eff}}}$），以及 (ii) 当势 $U$ 不变时，自由能垒 $\\Delta F^\\ddagger$ 在质量重缩放下是不变的。\n\n使用以下质量缩放案例的测试套件，每个案例都从基础质量向量 $\\mathbf{m}^{(0)}$ 开始：\n- 情况 A（均匀缩放）：将所有质量乘以 $\\alpha_A=0.5$。\n- 情况 B（单坐标缩放）：仅将第二个质量乘以 $\\alpha_B=4.0$，其余保持不变。\n- 情况 C（均匀极端缩放）：将所有质量乘以 $\\alpha_C=10^6$。\n- 情况 D（均匀极端缩放）：将所有质量乘以 $\\alpha_D=10^{-6}$。\n\n对于每种情况 $X\\in\\{A,B,C,D\\}$：\n- 计算有效质量 $m_{\\mathrm{eff}}^{(0)}$（基础）和 $m_{\\mathrm{eff}}^{(X)}$（缩放后），以及相应的 TST 速率 $k_{\\mathrm{TST}}^{(0)}$ 和 $k_{\\mathrm{TST}}^{(X)}$，还有 $\\Delta F^{\\ddagger(0)}$ 和 $\\Delta F^{\\ddagger(X)}$。\n- 定义一个数值容差 $\\varepsilon=10^{-10}$。\n- 通过验证\n$$\n\\left|\\frac{k_{\\mathrm{TST}}^{(X)}}{k_{\\mathrm{TST}}^{(0)}}-\\sqrt{\\frac{m_{\\mathrm{eff}}^{(0)}}{m_{\\mathrm{eff}}^{(X)}}}\\right|\\le \\varepsilon,\n$$\n来检查指前因子缩放的陈述，并为此检查输出一个布尔值。\n- 通过验证\n$$\n\\left|\\Delta F^{\\ddagger(X)}-\\Delta F^{\\ddagger(0)}\\right|\\le \\varepsilon,\n$$\n来检查势垒的质量不变性，并为此检查输出一个布尔值。\n\n不涉及角度单位。所有内部计算都在上述约化单位系统中进行。输出必须仅包含布尔值，这些值是无量纲的。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n[\\text{prefactor\\_ok}^{(A)},\\text{barrier\\_ok}^{(A)},\\text{prefactor\\_ok}^{(B)},\\text{barrier\\_ok}^{(B)},\\text{prefactor\\_ok}^{(C)},\\text{barrier\\_ok}^{(C)},\\text{prefactor\\_ok}^{(D)},\\text{barrier\\_ok}^{(D)}].\n$$", "solution": "问题要求对给定经典系统推导并计算过渡态理论 (TST) 速率常数 $k_{\\mathrm{TST}}$ 及相关的自由能垒 $\\Delta F^\\ddagger$。解决方案包括三个主要的理论步骤，随后是数值计算和验证。\n\n### 理论推导\n\n#### 1. TST 速率常数的一般表达式\n\n正则 TST 速率常数 $k_{\\mathrm{TST}}$ 定义为通过分割面 $s=0$ 的正向通量，并由反应物布居数归一化。\n$$\nk_{\\mathrm{TST}} = \\frac{\\text{Flux}_{\\text{forward}}(s=0)}{\\text{Population}_{\\text{reactants}}} = \\frac{\\langle \\delta(s) \\dot{s} \\Theta(\\dot{s}) \\rangle}{\\langle h_R \\rangle}\n$$\n其中 $\\langle \\cdot \\rangle$ 表示正则系综平均，$s=\\hat{\\mathbf{a}}^\\top \\mathbf{q}$ 是反应坐标，$\\dot{s}$ 是其时间导数，$\\delta(\\cdot)$ 是 Dirac delta 函数，$\\Theta(\\cdot)$ 是强制正向通量（$\\dot{s}>0$）的 Heaviside 阶跃函数，$h_R = \\Theta(-s)$ 是反应物区域（$s0$）的指示函数。\n\n哈密顿量是可分的，$H(\\mathbf{q}, \\mathbf{p}) = K(\\mathbf{p}) + U(\\mathbf{q})$，其中 $K(\\mathbf{p}) = \\frac{1}{2}\\mathbf{p}^\\top\\mathbf{M}^{-1}\\mathbf{p}$。因此，系综平均可分解为动量和坐标两部分。\n$$\nk_{\\mathrm{TST}} = \\frac{\\frac{1}{Z_p Z_q} \\left( \\int d\\mathbf{p} \\, \\dot{s} \\Theta(\\dot{s}) e^{-K(\\mathbf{p})/T} \\right) \\left( \\int d\\mathbf{q} \\, \\delta(s) e^{-U(\\mathbf{q})/T} \\right)}{\\frac{1}{Z_p Z_q} \\left( \\int d\\mathbf{p} \\, e^{-K(\\mathbf{p})/T} \\right) \\left( \\int d\\mathbf{q} \\, \\Theta(-s) e^{-U(\\mathbf{q})/T} \\right)}\n$$\n其中 $Z_p$ 和 $Z_q$ 分别是动量和构型配分函数，温度 $T$ 的单位使得 $k_B=1$。这可以简化为一个动能指前因子和一个构型比率的乘积：\n$$\nk_{\\mathrm{TST}} = \\left( \\frac{\\int d\\mathbf{p} \\, \\dot{s} \\Theta(\\dot{s}) e^{-K(\\mathbf{p})/T}}{\\int d\\mathbf{p} \\, e^{-K(\\mathbf{p})/T}} \\right) \\times \\left( \\frac{\\int d\\mathbf{q} \\, \\delta(s) e^{-U(\\mathbf{q})/T}}{\\int d\\mathbf{q} \\, \\Theta(-s) e^{-U(\\mathbf{q})/T}} \\right) = \\nu_{\\mathrm{kin}} \\times K_{\\mathrm{conf}}\n$$\n\n#### 2. 动能指前因子 ($\\nu_{\\mathrm{kin}}$) 和有效质量 ($m_{\\mathrm{eff}}$)\n\n沿反应坐标的速度为 $\\dot{s} = \\hat{\\mathbf{a}}^\\top\\dot{\\mathbf{q}} = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\mathbf{p}$。笛卡尔动量 $p_i$ 是独立的变量，服从均值为 0、方差为 $\\langle p_i^2 \\rangle = m_i T$ 的高斯分布。因此，$\\dot{s}$ 是一个高斯随机变量，其均值为 $\\langle \\dot{s} \\rangle = 0$，方差为：\n$$\n\\sigma_{\\dot{s}}^2 = \\langle \\dot{s}^2 \\rangle = \\langle (\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\mathbf{p})(\\mathbf{p}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}) \\rangle = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\langle \\mathbf{p}\\mathbf{p}^\\top \\rangle \\mathbf{M}^{-1}\\hat{\\mathbf{a}}\n$$\n由于 $\\langle \\mathbf{p}\\mathbf{p}^\\top \\rangle = T\\mathbf{M}$，方差为：\n$$\n\\sigma_{\\dot{s}}^2 = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}(T\\mathbf{M})\\mathbf{M}^{-1}\\hat{\\mathbf{a}} = T(\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}})\n$$\n动能指前因子 $\\nu_{\\mathrm{kin}} = \\langle \\dot{s} \\Theta(\\dot{s}) \\rangle_p$ 是正向速度的平均值：\n$$\n\\nu_{\\mathrm{kin}} = \\int_0^\\infty \\dot{s} \\frac{1}{\\sqrt{2\\pi\\sigma_{\\dot{s}}^2}} e^{-\\dot{s}^2/(2\\sigma_{\\dot{s}}^2)} d\\dot{s} = \\frac{\\sigma_{\\dot{s}}}{\\sqrt{2\\pi}} = \\sqrt{\\frac{T}{2\\pi}} \\sqrt{\\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}}\n$$\n问题要求验证 $k_{\\mathrm{TST}} \\propto \\sqrt{T/m_{\\mathrm{eff}}}$。由于 $\\nu_{\\mathrm{kin}}$ 是 $k_{\\mathrm{TST}}$ 中唯一与质量相关的因子，我们确定有效质量 $m_{\\mathrm{eff}}$ 使得 $\\nu_{\\mathrm{kin}} = \\sqrt{T/(2\\pi m_{\\mathrm{eff}})}$。这意味着 $1/m_{\\mathrm{eff}} = \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}}$。因此，有效质量的表达式为：\n$$\nm_{\\mathrm{eff}} = \\left( \\hat{\\mathbf{a}}^\\top\\mathbf{M}^{-1}\\hat{\\mathbf{a}} \\right)^{-1} = \\left( \\sum_{i=1}^4 \\frac{\\hat{a}_i^2}{m_i} \\right)^{-1}\n$$\n其中 $\\hat{\\mathbf{a}} = \\mathbf{a}/\\lVert\\mathbf{a}\\rVert$ 且 $\\mathbf{M}=\\mathrm{diag}(m_1,m_2,m_3,m_4)$。\n\n#### 3. 构型比率 ($K_{\\mathrm{conf}}$) 和自由能垒 ($\\Delta F^\\ddagger$)\n\n我们使用问题中指定的具有单位雅可比行列式的正交坐标变换 $\\mathbf{q} \\to (s, \\mathbf{y})$，因此 $d\\mathbf{q} = ds\\,d\\mathbf{y}$。势能是可分的：$U(s,\\mathbf{y})=U_s(s)+U_y(\\mathbf{y})$，其中 $U_s(s)=\\frac{1}{2}k_R(s+s_0)^2$ 和 $U_y(\\mathbf{y})=\\frac{1}{2}\\kappa_\\perp\\sum_{i=1}^3 y_i^2$。\n\n构型比率 $K_{\\mathrm{conf}}$ 变为：\n$$\nK_{\\mathrm{conf}} = \\frac{\\int ds\\,d\\mathbf{y}\\,\\delta(s) e^{-(U_s(s)+U_y(\\mathbf{y}))/T}}{\\int ds\\,d\\mathbf{y}\\,\\Theta(-s) e^{-(U_s(s)+U_y(\\mathbf{y}))/T}} = \\frac{e^{-U_s(0)/T} \\int d\\mathbf{y}\\,e^{-U_y(\\mathbf{y})/T}}{(\\int_{-\\infty}^0 ds\\,e^{-U_s(s)/T}) (\\int d\\mathbf{y}\\,e^{-U_y(\\mathbf{y})/T})} = \\frac{e^{-U_s(0)/T}}{\\int_{-\\infty}^0 ds\\,e^{-U_s(s)/T}}\n$$\n代入 $U_s(s)$，我们得到 $U_s(0) = \\frac{1}{2}k_R s_0^2$。分母中的积分是一个截断的高斯积分：\n$$\n\\int_{-\\infty}^0 e^{-\\frac{k_R}{2T}(s+s_0)^2} ds = \\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]\n$$\n问题将自由能垒定义为：\n$$\n\\Delta F^\\ddagger = -T \\ln\\left(\\frac{\\int d\\mathbf{y}\\,e^{-U(0,\\mathbf{y})/T}}{\\int_{s0} ds\\, d\\mathbf{y}\\,e^{-U(s,\\mathbf{y})/T}}\\right)\n$$\n这恰好是 $-T \\ln(K_{\\mathrm{conf}})$。因此，$\\Delta F^\\ddagger$ 纯粹依赖于势能函数和温度，而与质量无关。这证实了质量不变性的预期。\n$$\n\\Delta F^\\ddagger = -T \\ln \\left( \\frac{e^{-k_R s_0^2 / (2T)}}{\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]} \\right) = \\frac{k_R s_0^2}{2} + T \\ln\\left(\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]\\right)\n$$\n\n### $k_{\\mathrm{TST}}$ 的最终表达式\n\n结合动能和构型部分：\n$$\nk_{\\mathrm{TST}} = \\sqrt{\\frac{T}{2\\pi m_{\\mathrm{eff}}}} \\frac{e^{-k_R s_0^2 / (2T)}}{\\sqrt{\\frac{2\\pi T}{k_R}} \\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]}\n$$\n简化此表达式可得：\n$$\nk_{\\mathrm{TST}} = \\frac{1}{2\\pi} \\sqrt{\\frac{k_R}{m_{\\mathrm{eff}}}} \\frac{e^{-k_R s_0^2 / (2T)}}{\\frac{1}{2} \\left[1 + \\mathrm{erf}\\left(s_0\\sqrt{\\frac{k_R}{2T}}\\right)\\right]}\n$$\n这个表达式明确显示 $k_{\\mathrm{TST}} \\propto 1/\\sqrt{m_{\\mathrm{eff}}}$，从而证实了待检验的缩放关系。\n\n这些推导出的公式将被用于实现计算，以求得指定质量缩放情景下的所需量，并验证理论预测。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the transition state theory problem by deriving and computing\n    the rate constant and free energy barrier for various mass-scaling scenarios.\n    \"\"\"\n\n    #\n    # Step 1: Define givens from the problem statement\n    #\n    a_vec = np.array([1.0, -2.0, 0.5, 0.25])\n    k_R = 5.0\n    s_0 = 1.0\n    # kappa_perp is only needed for the derivation, not the final formulas for k_TST and delta_F\n    # kappa_perp = 3.0\n    T = 0.7\n    m0 = np.array([1.0, 2.0, 3.0, 4.0])\n    epsilon = 1e-10\n\n    # Define mass-scaling test cases\n    test_cases = [\n        ('A', lambda m: m * 0.5),         # Uniform scaling\n        ('B', lambda m: np.array([m[0], m[1] * 4.0, m[2], m[3]])), # Single-coordinate scaling\n        ('C', lambda m: m * 1e6),         # Uniform extreme scaling (large)\n        ('D', lambda m: m * 1e-6),        # Uniform extreme scaling (small)\n    ]\n\n    #\n    # Step 2: Implement the derived formulas\n    #\n\n    # Pre-calculate components that do not depend on mass\n    a_norm_sq = np.dot(a_vec, a_vec)\n    a_hat_sq_components = a_vec**2 / a_norm_sq\n    \n    s0_sqrt_arg = s_0 * np.sqrt(k_R / (2.0 * T))\n    erf_term_val = 0.5 * (1.0 + erf(s0_sqrt_arg))\n    exp_term_val = np.exp(-k_R * s_0**2 / (2.0 * T))\n\n    def calc_m_eff(m, a_hat_sq_comps):\n        \"\"\"Calculates the effective mass along the reaction coordinate.\"\"\"\n        m_eff_inv = np.sum(a_hat_sq_comps / m)\n        return 1.0 / m_eff_inv\n\n    def calc_k_tst(m_eff, k_R, exp_term, erf_term):\n        \"\"\"Calculates the TST rate constant.\"\"\"\n        prefactor = (1.0 / (2.0 * np.pi)) * np.sqrt(k_R / m_eff)\n        rate = prefactor * exp_term / erf_term\n        return rate\n\n    def calc_delta_F(k_R, s_0, T, erf_term):\n        \"\"\"Calculates the free energy barrier.\"\"\"\n        E_b = 0.5 * k_R * s_0**2\n        log_arg = np.sqrt(2.0 * np.pi * T / k_R) * erf_term\n        delta_F = E_b + T * np.log(log_arg)\n        return delta_F\n\n    #\n    # Step 3: Perform calculations for base case and test cases\n    #\n\n    # Calculate base case (0) values\n    m_eff_0 = calc_m_eff(m0, a_hat_sq_components)\n    k_tst_0 = calc_k_tst(m_eff_0, k_R, exp_term_val, erf_term_val)\n    delta_F_0 = calc_delta_F(k_R, s_0, T, erf_term_val)\n\n    results = []\n    for _name, scaling_func in test_cases:\n        # Apply mass scaling for the current case\n        m_X = scaling_func(m0)\n        \n        # Calculate quantities for the scaled case\n        m_eff_X = calc_m_eff(m_X, a_hat_sq_components)\n        k_tst_X = calc_k_tst(m_eff_X, k_R, exp_term_val, erf_term_val)\n        delta_F_X = calc_delta_F(k_R, s_0, T, erf_term_val)\n\n        #\n        # Step 4: Verify the scientific constraints\n        #\n\n        # Check 1: Prefactor scaling (k_TST proportional to 1/sqrt(m_eff))\n        ratio_k = k_tst_X / k_tst_0\n        ratio_m_sqrt = np.sqrt(m_eff_0 / m_eff_X)\n        prefactor_ok = np.abs(ratio_k - ratio_m_sqrt) = epsilon\n        results.append(prefactor_ok)\n\n        # Check 2: Mass invariance of the free energy barrier\n        barrier_ok = np.abs(delta_F_X - delta_F_0) = epsilon\n        results.append(barrier_ok)\n        \n    #\n    # Step 5: Format and print the final output\n    #\n    output_str = f\"[{','.join(map(str, results))}]\"\n    # Convert Python booleans to lowercase for the final output string.\n    print(output_str.lower())\n\nsolve()\n```", "id": "3458183"}, {"introduction": "简单的阿伦尼乌斯方程通常不足以描述复杂的化学反应，而过渡态理论为此提供了更精确的框架。本练习通过分析阿伦尼乌斯图（$\\ln k$ vs $1/T$）的曲率，将其与活化热容 $\\Delta C_p^\\ddagger$ 等潜在的热力学量联系起来。这提供了一个更精细的视角，帮助我们理解温度如何通过影响活化焓和活化熵来调节反应速率。[@problem_id:3458151]", "problem": "考虑一个一维阿伦尼乌斯图，即速率常数 $ \\ln k $ 的自然对数与逆温 $ x = 1/T $ 的关系图。在过渡态理论 (TST) 的框架内，速率常数的温度依赖性由一个动力学指前因子和一个跨越自由能垒的玻尔兹曼因子的乘积来建模。具体来说，假设基本模型为\n$$\nk(T) = \\nu(T)\\,\\exp\\!\\left[-\\beta\\,\\Delta F^\\ddagger(T)\\right],\n$$\n其中 $ \\beta = 1/(k_B T) $，$ k_B $ 是玻尔兹曼常数，$ \\nu(T) $ 是动力学指前因子，$ \\Delta F^\\ddagger(T) $ 是活化自由能。活化自由能分解为\n$$\n\\Delta F^\\ddagger(T) = \\Delta H^\\ddagger(T) - T\\,\\Delta S^\\ddagger(T),\n$$\n其中 $ \\Delta H^\\ddagger(T) $ 和 $ \\Delta S^\\ddagger(T) $ 分别是活化焓和活化熵。\n\n假设活化热容 $ \\Delta C_p^\\ddagger $ 为常数，使得\n$$\n\\Delta H^\\ddagger(T) = \\Delta H^\\ddagger(T_0) + \\Delta C_p^\\ddagger\\,(T - T_0),\n\\qquad\n\\Delta S^\\ddagger(T) = \\Delta S^\\ddagger(T_0) + \\Delta C_p^\\ddagger \\,\\ln\\!\\left(\\frac{T}{T_0}\\right),\n$$\n其中 $ T_0 $ 是参考温度。由于动力学效应，指前因子本身可能具有温度依赖性；你将分析两种指前因子模型：\n- 幂律指前因子：$ \\nu(T) = \\nu_0\\,T^\\alpha $，其中指数为 $ \\alpha $，常数为 $ \\nu_0 $。\n- 指数指前因子：$ \\nu(T) = \\nu_0 \\exp\\!\\left(\\frac{a}{T} + b T\\right) $，其中参数为 $ a $ 和 $ b $。\n\n你的任务：\n1. 仅从上述基本定义和链式法则出发，推导阿伦尼乌斯图 $ \\ln k $ 作为 $ x = 1/T $ 的函数的曲率的精确表达式，即二阶导数 $ \\frac{d^2}{dx^2}\\ln k $。你的结果应完全用 $ T $、$ \\ln \\nu(T) $ 对 $ T $ 的导数以及 $ \\Delta F^\\ddagger(T) $ 对 $ T $ 的导数来表示。除了基本定义外，不要引入任何未经证明的公式，并从第一性原理出发证明每个微分步骤。\n2. 使用上面给出的 $ \\Delta H^\\ddagger(T) $ 和 $ \\Delta S^\\ddagger(T) $ 的恒定活化热容假设，将你的通用表达式简化为一个简化的曲率公式。强调与温度相关的活化熵 $ \\Delta S^\\ddagger(T) $ 如何在阿伦尼乌斯图中产生曲率。\n3. 实现一个程序，使用简化表达式对以下参数值的测试套件进行曲率评估。在所有情况下，使用 $ k_B = 1.380649 \\times 10^{-23} \\,\\text{J/K} $。对于每种情况，计算在指定温度下的曲率 $ \\frac{d^2}{dx^2}\\ln k $。最终数值答案以 $ \\text{K}^2 $ 为单位表示。\n\n测试套件参数（所有温度单位为 $ \\text{K} $，热容单位为 $ \\text{J/K} $，$ a $ 的单位为 $ \\text{K} $，$ b $ 的单位为 $ \\text{K}^{-1} $）：\n- 情况1（幂律指前因子）：$ T = 300 $，$ \\alpha = 0 $，$ \\Delta C_p^\\ddagger = 0 $。\n- 情况2（幂律指前因子）：$ T = 300 $，$ \\alpha = 1 $，$ \\Delta C_p^\\ddagger = 0 $。\n- 情况3（幂律指前因子）：$ T = 300 $，$ \\alpha = 0 $，$ \\Delta C_p^\\ddagger = 2\\,k_B $。\n- 情况4（幂律指前因子）：$ T = 500 $，$ \\alpha = -0.5 $，$ \\Delta C_p^\\ddagger = 1\\,k_B $。\n- 情况5（指数指前因子）：$ T = 250 $，$ a = 1000 $，$ b = 10^{-3} $，$ \\Delta C_p^\\ddagger = -1\\,k_B $。\n\n程序输出规范：\n- 你的程序应生成单行输出，其中包含情况1到情况5的曲率值，按此精确顺序排列，形式为方括号括起来的逗号分隔列表，每个值四舍五入到三位小数，例如 $ [c_1,c_2,c_3,c_4,c_5] $。\n- 每个报告的曲率必须以 $ \\text{K}^2 $ 为单位。", "solution": "该问题要求推导和计算阿伦尼乌斯图的曲率，该图定义为 $ \\ln k $ 对 $ x = 1/T $ 的图像。曲率是二阶导数 $ \\frac{d^2}{dx^2}\\ln k $。推导将基于过渡态理论 (TST) 框架内给定的速率常数 $ k(T) $ 模型，从第一性原理进行。\n\n速率常数由下式给出：\n$$\nk(T) = \\nu(T)\\,\\exp\\!\\left[-\\beta\\,\\Delta F^\\ddagger(T)\\right]\n$$\n取自然对数，并代入 $ \\beta = 1/(k_B T) $，我们得到：\n$$\n\\ln k(T) = \\ln \\nu(T) - \\frac{\\Delta F^\\ddagger(T)}{k_B T}\n$$\n我们的目标是计算此表达式关于 $ x = 1/T $ 的二阶导数。我们必须使用链式法则，因为 $ \\ln k $ 是作为温度 $ T $ 的函数给出的。微分之间的关系是：\n$$\n\\frac{d}{dx} = \\frac{dT}{dx} \\frac{d}{dT}\n$$\n由于 $ x = 1/T $，我们有 $ T = 1/x $，因此 $ \\frac{dT}{dx} = -1/x^2 = -T^2 $。于是，微分算子变为：\n$$\n\\frac{d}{dx} = -T^2 \\frac{d}{dT}\n$$\n\n### 任务1：通用曲率表达式\n首先，我们计算 $ \\ln k $ 关于 $ x $ 的一阶导数。\n$$\n\\frac{d}{dx}\\ln k = -T^2 \\frac{d}{dT} \\left( \\ln \\nu(T) - \\frac{\\Delta F^\\ddagger(T)}{k_B T} \\right) = -T^2 \\frac{d\\ln\\nu}{dT} + \\frac{T^2}{k_B} \\frac{d}{dT}\\left(\\frac{\\Delta F^\\ddagger(T)}{T}\\right)\n$$\n$ \\Delta F^\\ddagger(T)/T $ 的导数可以使用吉布斯-亥姆霍兹方程来计算。根据定义 $ \\Delta F^\\ddagger = \\Delta H^\\ddagger - T\\Delta S^\\ddagger $ 和热力学关系 $ \\frac{d\\Delta F^\\ddagger}{dT} = -\\Delta S^\\ddagger $，我们有：\n$$\n\\frac{d}{dT}\\left(\\frac{\\Delta F^\\ddagger}{T}\\right) = \\frac{T\\frac{d\\Delta F^\\ddagger}{dT} - \\Delta F^\\ddagger}{T^2} = \\frac{T(-\\Delta S^\\ddagger) - (\\Delta H^\\ddagger - T\\Delta S^\\ddagger)}{T^2} = -\\frac{\\Delta H^\\ddagger}{T^2}\n$$\n将此代入一阶导数的表达式中得到：\n$$\n\\frac{d}{dx}\\ln k = -T^2 \\frac{d\\ln\\nu}{dT} - \\frac{\\Delta H^\\ddagger(T)}{k_B}\n$$\n该量与表观活化能成正比。现在，我们再次应用算子 $ \\frac{d}{dx} = -T^2 \\frac{d}{dT} $ 来计算二阶导数，即曲率：\n$$\n\\frac{d^2}{dx^2}\\ln k = -T^2 \\frac{d}{dT} \\left( -T^2 \\frac{d\\ln\\nu}{dT} - \\frac{\\Delta H^\\ddagger(T)}{k_B} \\right) = T^2 \\frac{d}{dT} \\left( T^2 \\frac{d\\ln\\nu}{dT} \\right) + \\frac{T^2}{k_B} \\frac{d\\Delta H^\\ddagger}{dT}\n$$\n对第一项使用乘积法则：$ \\frac{d}{dT}\\left(T^2 \\frac{d\\ln\\nu}{dT}\\right) = 2T\\frac{d\\ln\\nu}{dT} + T^2\\frac{d^2\\ln\\nu}{dT^2} $。第二项涉及活化焓的导数，即活化热容，$ \\frac{d\\Delta H^\\ddagger}{dT} = \\Delta C_p^\\ddagger(T) $。\n因此，中间表达式为：\n$$\n\\frac{d^2}{dx^2}\\ln k = T^2 \\left( 2T\\frac{d\\ln\\nu}{dT} + T^2\\frac{d^2\\ln\\nu}{dT^2} \\right) + \\frac{T^2}{k_B} \\Delta C_p^\\ddagger(T)\n$$\n为了完全用 $ \\Delta F^\\ddagger $ 的导数表示，我们使用热力学恒等式 $ \\Delta C_p^\\ddagger = -T\\frac{d^2\\Delta F^\\ddagger}{dT^2} $。此恒等式是通过对 $ \\Delta H^\\ddagger = \\Delta F^\\ddagger - T\\frac{d\\Delta F^\\ddagger}{dT} $ 关于 $ T $ 求导得出的。\n将此代入我们的表达式，得到最终的通用曲率公式：\n$$\n\\frac{d^2}{dx^2}\\ln k = 2T^3\\frac{d\\ln\\nu}{dT} + T^4\\frac{d^2\\ln\\nu}{dT^2} - \\frac{T^3}{k_B}\\frac{d^2\\Delta F^\\ddagger}{dT^2}\n$$\n\n### 任务2：简化的曲率公式\n问题要求假设活化热容为常数，$ \\Delta C_p^\\ddagger $。这简化了活化焓和熵的温度依赖性，如下所示：\n$$\n\\Delta H^\\ddagger(T) = \\Delta H^\\ddagger(T_0) + \\Delta C_p^\\ddagger\\,(T - T_0)\n$$\n由此直接得出 $ \\frac{d\\Delta H^\\ddagger}{dT} = \\Delta C_p^\\ddagger $，其中 $ \\Delta C_p^\\ddagger $ 是一个常数。我们可以将此代入我们的中间曲率表达式中：\n$$\n\\frac{d^2}{dx^2}\\ln k = T^2 \\left( 2T\\frac{d\\ln\\nu}{dT} + T^2\\frac{d^2\\ln\\nu}{dT^2} \\right) + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B}\n$$\n这是在 $ \\Delta C_p^\\ddagger $ 为常数的假设下的简化曲率公式。\n\n问题要求强调与温度相关的活化熵的作用。给定的 $ \\Delta S^\\ddagger(T) $ 模型是 $ \\Delta S^\\ddagger(T) = \\Delta S^\\ddagger(T_0) + \\Delta C_p^\\ddagger \\ln(T/T_0) $。对此关于 $ T $ 求导得到 $ \\frac{d\\Delta S^\\ddagger}{dT} = \\frac{\\Delta C_p^\\ddagger}{T} $。这与通用热力学关系 $ \\Delta C_p^\\ddagger = T \\frac{d\\Delta S^\\ddagger}{dT} $ 一致。因此，与温度相关的活化熵（即 $ \\frac{d\\Delta S^\\ddagger}{dT} \\neq 0 $）意味着非零的活化热容 $ \\Delta C_p^\\ddagger \\neq 0 $。在我们的简化公式中，项 $ \\frac{T^2 \\Delta C_p^\\ddagger}{k_B} $ 是对曲率的直接贡献。因此，活化熵的温度依赖性是阿伦尼乌斯图中曲率的直接物理原因，导致所谓的非阿伦尼乌斯行为。\n\n### 任务3：应用于特定模型\n我们现在将简化的曲率公式应用于两种指定的指前因子模型。\n\n**幂律指前因子：** $ \\nu(T) = \\nu_0\\,T^\\alpha $\n首先，我们求 $ \\ln \\nu(T) = \\ln \\nu_0 + \\alpha \\ln T $ 的导数：\n$$\n\\frac{d\\ln\\nu}{dT} = \\frac{\\alpha}{T} \\qquad \\text{和} \\qquad \\frac{d^2\\ln\\nu}{dT^2} = -\\frac{\\alpha}{T^2}\n$$\n将这些代入简化的曲率公式：\n$$\n\\frac{d^2}{dx^2}\\ln k = T^2 \\left( 2T\\left(\\frac{\\alpha}{T}\\right) + T^2\\left(-\\frac{\\alpha}{T^2}\\right) \\right) + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B} = T^2 (2\\alpha - \\alpha) + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B}\n$$\n这给出了幂律情况下的最终表达式：\n$$\n\\frac{d^2}{dx^2}\\ln k = T^2 \\left( \\alpha + \\frac{\\Delta C_p^\\ddagger}{k_B} \\right)\n$$\n\n**指数指前因子：** $ \\nu(T) = \\nu_0 \\exp\\!\\left(\\frac{a}{T} + b T\\right) $\n$ \\ln \\nu(T) = \\ln \\nu_0 + a/T + bT $ 的导数是：\n$$\n\\frac{d\\ln\\nu}{dT} = -\\frac{a}{T^2} + b \\qquad \\text{和} \\qquad \\frac{d^2\\ln\\nu}{dT^2} = \\frac{2a}{T^3}\n$$\n将这些代入简化的曲率公式：\n$$\n\\frac{d^2}{dx^2}\\ln k = T^2 \\left( 2T\\left(-\\frac{a}{T^2} + b\\right) + T^2\\left(\\frac{2a}{T^3}\\right) \\right) + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B} = T^2 \\left( -\\frac{2a}{T} + 2bT + \\frac{2a}{T} \\right) + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B}\n$$\n这给出了指数情况下的最终表达式：\n$$\n\\frac{d^2}{dx^2}\\ln k = 2bT^3 + \\frac{T^2 \\Delta C_p^\\ddagger}{k_B}\n$$\n下面将实现这两个推导出的表达式，以计算指定测试套件的曲率。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the curvature of an Arrhenius plot for several test cases based on\n    Transition State Theory (TST) models.\n    \"\"\"\n    # Define physical constants\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    # Define the test cases from the problem statement.\n    # dCp represents the constant activation heat capacity ΔC_p^‡.\n    test_cases = [\n        # Case 1: power-law prefactor\n        {'model': 'power', 'T': 300, 'params': {'alpha': 0}, 'dCp': 0},\n        # Case 2: power-law prefactor\n        {'model': 'power', 'T': 300, 'params': {'alpha': 1}, 'dCp': 0},\n        # Case 3: power-law prefactor\n        {'model': 'power', 'T': 300, 'params': {'alpha': 0}, 'dCp': 2 * k_B},\n        # Case 4: power-law prefactor\n        {'model': 'power', 'T': 500, 'params': {'alpha': -0.5}, 'dCp': 1 * k_B},\n        # Case 5: exponential prefactor\n        {'model': 'exp', 'T': 250, 'params': {'a': 1000, 'b': 1e-3}, 'dCp': -1 * k_B}\n    ]\n\n    results = []\n    for case in test_cases:\n        T = case['T']\n        dCp = case['dCp']\n        model_type = case['model']\n        params = case['params']\n        \n        curvature = 0.0\n        \n        if model_type == 'power':\n            # Curvature formula for power-law prefactor: C = T^2 * (α + ΔC_p^‡ / k_B)\n            alpha = params['alpha']\n            curvature = T**2 * (alpha + dCp / k_B)\n        elif model_type == 'exp':\n            # Curvature formula for exponential prefactor: C = 2*b*T^3 + T^2 * ΔC_p^‡ / k_B\n            b = params['b']\n            curvature = 2 * b * T**3 + T**2 * (dCp / k_B)\n        \n        results.append(curvature)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3458151"}]}