{"hands_on_practices": [{"introduction": "理论的基石是能够从第一性原理出发进行推导。本练习将引导你从细致平衡条件这一基本要求出发，推导出通用的Metropolis-Hastings接受准则[@problem_id:3407505]。通过纠正一个在非对称提议分布下误用对称Metropolis准则的常见错误，你将深刻理解为何细致平衡是保证马尔可夫链蒙特卡洛（MCMC）方法正确抽样的核心。", "problem": "一位从业者正在使用嵌入在分子动力学工作流程中的马尔可夫链蒙特卡洛 (MCMC) 移动来对温度为 $T$ 的系统进行正则系综抽样。令 $E_i$ 表示状态 $i$ 的能量，令 $\\beta = 1/(k_B T)$ 为逆热能，其中 $k_B$ 是玻尔兹曼常数。定义约化能量 $u_i = \\beta E_i$，因此目标平衡分布为 $\\pi(i) \\propto \\exp(-u_i)$。\n\n该从业者采用一种依赖于状态的提议机制 $Q(i \\to j)$ 来生成从状态 $i$ 到状态 $j$ 的尝试移动，然后是一个接受步骤 $A(i \\to j)$，从而得到单步转移概率 $W(i \\to j) = Q(i \\to j) A(i \\to j)$。目前，使用的接受准则是对称Metropolis形式 $A_{\\mathrm{sym}}(i \\to j) = \\min\\{1, \\exp[-(u_j - u_i)]\\}$，该形式假设提议是对称的。然而，实际的提议概率是非对称的。\n\n考虑两个状态，其约化能量为 $u_1 = 0$ 和 $u_2 = 1.3$。提议概率为 $Q(1 \\to 2) = 0.80$ 和 $Q(2 \\to 1) = 0.20$。目标是诊断细致平衡条件的违背情况，并构建一个修正的接受准则，以恢复相对于目标分布 $\\pi(i) \\propto \\exp(-u_i)$ 的细致平衡。\n\n从正则系综的第一性原理和马尔可夫链的细致平衡定义出发，推导对非对称提议强制执行细致平衡的接受准则，并使用给定的 $u_1$、$u_2$、$Q(1 \\to 2)$ 和 $Q(2 \\to 1)$ 计算从状态1到状态2转移的修正后接受概率 $A^{\\star}(1 \\to 2)$。\n\n将 $A^{\\star}(1 \\to 2)$ 的最终数值答案四舍五入到四位有效数字。接受概率是无量纲的；不要包含单位。", "solution": "该问题要求为马尔可夫链蒙特卡洛（MCMC）模拟推导一个修正的接受准则，以恢复非对称提议机制下的细致平衡，并计算一个特定的接受概率。\n\n首先，我们建立基本原理。要使马尔可夫链从目标平衡分布 $\\pi(i)$ 中抽样，一个充分条件是转移概率 $W(i \\to j)$ 满足细致平衡条件。该条件确保在平衡状态下，从任何状态 $i$ 到任何状态 $j$ 的总概率通量等于从 $j$ 到 $i$ 的通量。数学上，这表示为：\n$$ \\pi(i) W(i \\to j) = \\pi(j) W(j \\to i) $$\n对于所有状态对 $(i, j)$。\n\n在本问题的背景下，单步转移概率 $W(i \\to j)$ 由两部分组成：概率为 $Q(i \\to j)$ 的提议步骤和概率为 $A(i \\to j)$ 的接受步骤。对于 $i \\neq j$，复合概率为 $W(i \\to j) = Q(i \\to j) A(i \\to j)$。将此代入细致平衡方程，得到：\n$$ \\pi(i) Q(i \\to j) A(i \\to j) = \\pi(j) Q(j \\to i) A(j \\to i) $$\n该方程是任何有效的接受准则必须满足的核心约束。\n\n问题指出，实践者正在使用对称Metropolis接受准则 $A_{\\mathrm{sym}}(i \\to j) = \\min\\{1, \\exp[-(u_j - u_i)]\\}$。该准则是在对称提议的假设下推导出来的，即 $Q(i \\to j) = Q(j \\to i)$。如果我们做出这个假设，提议概率在细致平衡约束中会相互抵消，剩下 $\\pi(i) A(i \\to j) = \\pi(j) A(j \\to i)$。对称Metropolis准则满足这个简化条件。然而，问题明确指出提议概率是非对称的，其中 $Q(1 \\to 2) = 0.80$ 且 $Q(2 \\to 1) = 0.20$。当提议是非对称时，使用一个假设对称性的接受准则会违背细致平衡条件，马尔可夫链将不会收敛到正确的目标分布 $\\pi(i)$。这就是该实践者当前方法的缺陷。\n\n为了推导正确的接受准则，我们必须重新整理完整的细致平衡约束，以求解接受概率的比率：\n$$ \\frac{A(i \\to j)}{A(j \\to i)} = \\frac{\\pi(j)}{\\pi(i)} \\frac{Q(j \\to i)}{Q(i \\to j)} $$\n目标分布是正则系综分布 $\\pi(i) \\propto \\exp(-\\beta E_i)$，其中 $E_i$ 是状态 $i$ 的能量。使用给定的约化能量 $u_i = \\beta E_i$，分布为 $\\pi(i) \\propto \\exp(-u_i)$。因此，两个状态的概率之比为：\n$$ \\frac{\\pi(j)}{\\pi(i)} = \\frac{\\exp(-u_j)}{\\exp(-u_i)} = \\exp(-u_j + u_i) = \\exp[-(u_j - u_i)] $$\n将此代入接受概率比率方程，得到：\n$$ \\frac{A(i \\to j)}{A(j \\to i)} = \\exp[-(u_j - u_i)] \\frac{Q(j \\to i)}{Q(i \\to j)} $$\n这是接受准则对于非对称提议必须满足的一般约束。满足此比率同时最大化接受率（从而提高抽样效率）的最常见接受概率选择是Metropolis-Hastings接受准则。令约束的右侧由 $\\rho_{ij}$ 表示：\n$$ \\rho_{ij} = \\exp[-(u_j - u_i)] \\frac{Q(j \\to i)}{Q(i \\to j)} $$\n那么Metropolis-Hastings接受概率由下式给出：\n$$ A^{\\star}(i \\to j) = \\min\\{1, \\rho_{ij}\\} $$\n这就是对任何提议机制 $Q(i \\to j)$（无论对称与否）强制执行细致平衡的修正后接受准则。\n\n现在，我们应用这个推导出的准则来计算从状态1到状态2转移的特定接受概率 $A^{\\star}(1 \\to 2)$。给定的值为：\n- 状态1的约化能量：$u_1 = 0$\n- 状态2的约化能量：$u_2 = 1.3$\n- 从1到2的提议概率：$Q(1 \\to 2) = 0.80$\n- 从2到1的提议概率：$Q(2 \\to 1) = 0.20$\n\n我们确定 $i=1$ 和 $j=2$。修正后的接受概率 $A^{\\star}(1 \\to 2)$ 是：\n$$ A^{\\star}(1 \\to 2) = \\min\\left\\{1, \\exp[-(u_2 - u_1)] \\frac{Q(2 \\to 1)}{Q(1 \\to 2)}\\right\\} $$\n首先，我们计算 $\\min$ 函数的参数。能量差项为：\n$$ \\exp[-(u_2 - u_1)] = \\exp[-(1.3 - 0)] = \\exp(-1.3) $$\n提议概率的比率为：\n$$ \\frac{Q(2 \\to 1)}{Q(1 \\to 2)} = \\frac{0.20}{0.80} = 0.25 $$\n结合这些项，我们求得 $\\rho_{12}$：\n$$ \\rho_{12} = \\exp(-1.3) \\times 0.25 $$\n$\\exp(-1.3)$ 的值约等于 $0.27253179...$。因此：\n$$ \\rho_{12} \\approx 0.27253179 \\times 0.25 = 0.06813295 $$\n由于 $\\rho_{12}$ 小于 1，接受概率等于 $\\rho_{12}$：\n$$ A^{\\star}(1 \\to 2) = \\min\\{1, 0.06813295\\} = 0.06813295 $$\n问题要求将最终答案四舍五入到四位有效数字。将 $0.06813295$ 四舍五入到四位有效数字得到 $0.06813$。", "answer": "$$\\boxed{0.06813}$$", "id": "3407505"}, {"introduction": "在分子动力学中，我们通常处理连续时间的随机过程，而不是离散的蒙特卡洛步骤。本练习将探讨一个前沿问题：当哈密顿动力学中的力存在噪声时（例如，在使用随机梯度时），系统将如何演化[@problem_id:3407518]。通过分析其福克-普朗克方程，你将证明仅有噪声会破坏平衡态，并进而推导出必须引入恰当的耗散项（摩擦）来恢复细致平衡，这正是涨落-耗散定理的体现。", "problem": "考虑一个质量为 $m$ 的单个粒子，在一维空间中运动，其坐标为 $x$，动量为 $p$，处于势能 $U(x)$ 和热力学温度 $T$ 的环境中。目标平衡相空间密度为 Boltzmann 分布 $\\pi(x,p) \\propto \\exp\\!\\big(-\\beta H(x,p)\\big)$，其中逆温度 $\\beta = 1/(k_B T)$，$k_B$ 是 Boltzmann 常数，Hamiltonian 为 $H(x,p) = U(x) + p^2/(2m)$。Hamiltonian Monte Carlo (HMC) 通过使用辛、可逆的格式对 Hamilton 方程进行积分来提出移动，这种格式能够保持相空间体积，并（通过 Metropolis 接受/拒绝机制）相对于 $\\pi(x,p)$ 保持细致平衡。\n\n假设在积分过程中，力 $-\\partial U/\\partial x$ 由一个随机估计量近似，其误差在小时间步长极限下被建模为动量方程中的加性高斯白噪声。具体来说，考虑以下随机微分方程 (SDE)：\n$$\n\\mathrm{d}x = \\frac{p}{m}\\,\\mathrm{d}t, \n\\qquad\n\\mathrm{d}p = -\\frac{\\partial U}{\\partial x}(x)\\,\\mathrm{d}t + \\sqrt{2\\,b}\\,\\mathrm{d}W_t,\n$$\n其中 $b > 0$ 是一个设定力噪声强度的常数，$W_t$ 是一个标准 Wiener 过程。\n\n从第一性原理出发：\n1. 推导概率密度 $\\rho(x,p,t)$ 的相关 Fokker–Planck 方程，并通过直接代入来证明 Boltzmann 密度 $\\pi(x,p)$ 是否为其稳态解。解释在此背景下，这种噪声驱动力如何影响相空间体积守恒和细致平衡。\n2. 为了恢复平衡，考虑通过增加一个线性摩擦项和一个恒温器（Ornstein–Uhlenbeck 类型）噪声来增强动量动力学，\n$$\n\\mathrm{d}p = -\\frac{\\partial U}{\\partial x}(x)\\,\\mathrm{d}t - \\gamma\\,p\\,\\mathrm{d}t + \\sqrt{2\\,\\alpha_{\\mathrm{th}}}\\,\\mathrm{d}B_t + \\sqrt{2\\,b}\\,\\mathrm{d}W_t,\n$$\n其中 $\\gamma \\ge 0$ 是一个常数摩擦系数，$\\alpha_{\\mathrm{th}} \\ge 0$ 是一个常数恒温器扩散系数，$B_t$ 是一个独立的标准 Wiener 过程。根据 $\\pi(x,p)$ 是稳态的并且相对于 $\\pi(x,p)$ 满足细致平衡的要求，推导出一个关于 $\\gamma$、$\\alpha_{\\mathrm{th}}$ 以及物理参数 $m$、$k_B$ 和 $T$ 之间的关系。\n\n最后，确定最小摩擦系数 $\\gamma_{\\min}$，使得可以选择一个非负的 $\\alpha_{\\mathrm{th}}$ 来满足稳态性和细致平衡条件。您的最终答案必须是关于 $b$、$m$、$k_B$ 和 $T$ 的单一闭式解析表达式。以 $\\mathrm{s}^{-1}$ 为单位表示 $\\gamma_{\\min}$ 的值。不需要进行数值计算或四舍五入。", "solution": "### 第 1 部分：含噪 Hamiltonian 系统的分析\n\n该系统由以下 SDE 描述：\n$\\mathrm{d}x = \\frac{p}{m}\\,\\mathrm{d}t$\n$\\mathrm{d}p = -\\frac{\\partial U}{\\partial x}(x)\\,\\mathrm{d}t + \\sqrt{2\\,b}\\,\\mathrm{d}W_t$\n\n这对应于一个矢量 SDE $\\mathrm{d}\\mathbf{X}_t = \\mathbf{A}(\\mathbf{X}_t)\\,\\mathrm{d}t + \\mathbf{B}\\,\\mathrm{d}W_t$，其状态向量为 $\\mathbf{X} = (x, p)^T$，漂移向量为 $\\mathbf{A} = (\\frac{p}{m}, -\\frac{\\partial U}{\\partial x})^T$，扩散矩阵为 $\\mathbf{B} = (0, \\sqrt{2b})^T$。\n\n相关的概率密度 $\\rho(x,p,t)$ 的 Fokker-Planck 方程由下式给出：\n$$\n\\frac{\\partial \\rho}{\\partial t} = -\\sum_i \\frac{\\partial}{\\partial X_i} (A_i \\rho) + \\frac{1}{2} \\sum_{i,j} \\frac{\\partial^2}{\\partial X_i \\partial X_j} (D_{ij} \\rho)\n$$\n其中 $\\mathbf{D} = \\mathbf{B}\\mathbf{B}^T$ 是扩散张量。在我们的例子中：\n$$\n\\mathbf{D} = \\begin{pmatrix} 0 \\\\ \\sqrt{2b} \\end{pmatrix} \\begin{pmatrix} 0 & \\sqrt{2b} \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\\\ 0 & 2b \\end{pmatrix}\n$$\n因此，Fokker-Planck 方程为：\n$$\n\\frac{\\partial \\rho}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(\\frac{p}{m}\\rho\\right) - \\frac{\\partial}{\\partial p}\\left(-\\frac{\\partial U}{\\partial x}\\rho\\right) + \\frac{1}{2}\\frac{\\partial^2}{\\partial p^2}(2b\\rho)\n$$\n$$\n\\frac{\\partial \\rho}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(\\frac{p}{m}\\rho\\right) + \\frac{\\partial}{\\partial p}\\left(\\frac{\\partial U}{\\partial x}\\rho\\right) + b\\frac{\\partial^2 \\rho}{\\partial p^2}\n$$\n为了检查 Boltzmann 密度 $\\pi(x,p) = N \\exp(-\\beta H(x,p))$ 是否为稳态解，我们令 $\\rho = \\pi$ 并检查是否有 $\\frac{\\partial \\pi}{\\partial t} = 0$。$\\pi$ 的偏导数为：\n$$\n\\frac{\\partial \\pi}{\\partial x} = -\\beta \\frac{\\partial U}{\\partial x} \\pi, \\quad \\frac{\\partial \\pi}{\\partial p} = -\\beta \\frac{p}{m} \\pi\n$$\n将 $\\pi$ 代入稳态 Fokker-Planck 方程：\n$$\n0 \\stackrel{?}{=} -\\frac{\\partial}{\\partial x}\\left(\\frac{p}{m}\\pi\\right) + \\frac{\\partial}{\\partial p}\\left(\\frac{\\partial U}{\\partial x}\\pi\\right) + b\\frac{\\partial^2 \\pi}{\\partial p^2}\n$$\n各项计算结果为：\n$$\n-\\frac{\\partial}{\\partial x}\\left(\\frac{p}{m}\\pi\\right) = -\\frac{p}{m}\\frac{\\partial \\pi}{\\partial x} = -\\frac{p}{m}\\left(-\\beta \\frac{\\partial U}{\\partial x}\\pi\\right) = \\beta \\frac{p}{m}\\frac{\\partial U}{\\partial x}\\pi\n$$\n$$\n\\frac{\\partial}{\\partial p}\\left(\\frac{\\partial U}{\\partial x}\\pi\\right) = \\frac{\\partial U}{\\partial x}\\frac{\\partial \\pi}{\\partial p} = \\frac{\\partial U}{\\partial x}\\left(-\\beta \\frac{p}{m}\\pi\\right) = -\\beta \\frac{p}{m}\\frac{\\partial U}{\\partial x}\\pi\n$$\n$$\n\\frac{\\partial^2 \\pi}{\\partial p^2} = \\frac{\\partial}{\\partial p}\\left(-\\beta \\frac{p}{m}\\pi\\right) = -\\frac{\\beta}{m}\\pi - \\beta\\frac{p}{m}\\frac{\\partial \\pi}{\\partial p} = -\\frac{\\beta}{m}\\pi - \\beta\\frac{p}{m}\\left(-\\beta \\frac{p}{m}\\pi\\right) = \\left(-\\frac{\\beta}{m} + \\frac{\\beta^2 p^2}{m^2}\\right)\\pi\n$$\n将各项相加：\n$$\n0 \\stackrel{?}{=} \\left(\\beta \\frac{p}{m}\\frac{\\partial U}{\\partial x}\\pi\\right) + \\left(-\\beta \\frac{p}{m}\\frac{\\partial U}{\\partial x}\\pi\\right) + b\\left(-\\frac{\\beta}{m} + \\frac{\\beta^2 p^2}{m^2}\\right)\\pi\n$$\n$$\n0 \\stackrel{?}{=} b\\left(-\\frac{\\beta}{m} + \\frac{\\beta^2 p^2}{m^2}\\right)\\pi\n$$\n由于 $b > 0$，此等式并非对所有 $p$ 都成立。因此，$\\pi(x,p)$ 不是一个稳态解。\n\n噪声驱动力影响相空间体积和细致平衡。\n纯 Hamiltonian 动力学保持相空间体积，这由 Liouville 定理表达，因为 Hamiltonian 向量场的散度为零：$\\frac{\\partial}{\\partial x}(\\frac{p}{m}) + \\frac{\\partial}{\\partial p}(-\\frac{\\partial U}{\\partial x}) = 0$。随机动力学在 Fokker-Planck 方程中包含一个扩散项 $\\frac{\\partial^2}{\\partial p^2}(b \\rho)$，这导致概率密度在动量方向上扩散。此扩散过程不保持相空间中某个区域的体积。\n对于 Boltzmann 分布 $\\pi$ 的细致平衡要求状态之间的净概率流为零。稳态概率流为 $\\mathbf{J} = \\mathbf{A}\\pi - \\frac{1}{2}\\nabla \\cdot (\\mathbf{D}\\pi)$。由于 $\\pi$ 不是稳态的，因此不满足细致平衡。随机项通过增加动量持续向系统注入能量，充当一个有效的“加热”源，而没有任何耗散机制来平衡它，从而阻止系统达到 Boltzmann 分布的平衡状态。\n\n### 第 2 部分：增强系统的分析\n\n增强的 SDE 为：\n$$\n\\mathrm{d}x = \\frac{p}{m}\\,\\mathrm{d}t, \n\\qquad\n\\mathrm{d}p = \\left(-\\frac{\\partial U}{\\partial x} - \\gamma p\\right)\\,\\mathrm{d}t + \\sqrt{2\\,\\alpha_{\\mathrm{th}}}\\,\\mathrm{d}B_t + \\sqrt{2\\,b}\\,\\mathrm{d}W_t\n$$\n漂移向量为 $\\mathbf{A'} = (\\frac{p}{m}, -\\frac{\\partial U}{\\partial x} - \\gamma p)^T$。由于 $B_t$ 和 $W_t$ 是独立的，噪声项的方差相加。$p$ 方向上的总扩散系数为 $\\alpha_{\\mathrm{th}} + b$。扩散张量为 $\\mathbf{D'} = \\begin{pmatrix} 0 & 0 \\\\ 0 & 2(\\alpha_{\\mathrm{th}} + b) \\end{pmatrix}$。\n\nFokker-Planck 方程变为：\n$$\n\\frac{\\partial \\rho}{\\partial t} = -\\frac{\\partial}{\\partial x}\\left(\\frac{p}{m}\\rho\\right) - \\frac{\\partial}{\\partial p}\\left(\\left[-\\frac{\\partial U}{\\partial x} - \\gamma p\\right]\\rho\\right) + (\\alpha_{\\mathrm{th}} + b)\\frac{\\partial^2 \\rho}{\\partial p^2}\n$$\n我们要求 $\\pi(x,p)$ 是一个稳态和满足细致平衡的解。Fokker-Planck 算子可以分解为一个 Hamiltonian 部分和一个恒温器部分：\n$$\n\\frac{\\partial \\rho}{\\partial t} = \\left[-\\frac{p}{m}\\frac{\\partial \\rho}{\\partial x} + \\frac{\\partial U}{\\partial x}\\frac{\\partial \\rho}{\\partial p}\\right] + \\frac{\\partial}{\\partial p}\\left(\\gamma p \\rho + (\\alpha_{\\mathrm{th}} + b)\\frac{\\partial \\rho}{\\partial p}\\right)\n$$\n方括号中的项是 Liouville 算子，$L_H \\rho = -\\{H, \\rho\\}$。对于 $\\rho = \\pi$（它是 $H$ 的函数），我们有 $\\{H, \\pi\\} = 0$。因此，要使 $\\pi$ 成为一个稳态解，第二项也必须为零：\n$$\n\\frac{\\partial}{\\partial p}\\left(\\gamma p \\pi + (\\alpha_{\\mathrm{th}} + b)\\frac{\\partial \\pi}{\\partial p}\\right) = 0\n$$\n对 $p$ 进行积分，并使用当 $p \\to \\pm \\infty$ 时概率流消失的边界条件，我们发现括号中的项对于所有 $p$ 都必须为零：\n$$\n\\gamma p \\pi + (\\alpha_{\\mathrm{th}} + b)\\frac{\\partial \\pi}{\\partial p} = 0\n$$\n代入 $\\frac{\\partial \\pi}{\\partial p} = -\\beta \\frac{p}{m} \\pi$：\n$$\n\\gamma p \\pi + (\\alpha_{\\mathrm{th}} + b)\\left(-\\beta \\frac{p}{m} \\pi\\right) = 0\n$$\n为使此式对任何 $p \\neq 0$ 都成立，括号中的项必须为零：\n$$\n\\gamma - \\frac{\\beta}{m}(\\alpha_{\\mathrm{th}} + b) = 0\n$$\n这个条件确保了稳态性。可以证明，它也确保了细致平衡。这就是该系统的涨落-耗散关系，它将摩擦 $\\gamma$（耗散）与总噪声强度 $\\alpha_{\\mathrm{th}} + b$（涨落）以及温度 $T = 1/(k_B \\beta)$ 联系起来。该关系式为：\n$$\n\\gamma = \\frac{\\alpha_{\\mathrm{th}} + b}{m k_B T}\n$$\n\n### 最小摩擦系数 $\\gamma_{\\min}$\n\n问题指出，恒温器扩散系数必须为非负，即 $\\alpha_{\\mathrm{th}} \\ge 0$。我们需要找到能满足此条件的最小摩擦系数 $\\gamma_{\\min}$。重排该关系式以解出 $\\alpha_{\\mathrm{th}}$：\n$$\n\\alpha_{\\mathrm{th}} = \\gamma m k_B T - b\n$$\n条件 $\\alpha_{\\mathrm{th}} \\ge 0$ 意味着：\n$$\n\\gamma m k_B T - b \\ge 0\n$$\n解出 $\\gamma$：\n$$\n\\gamma \\ge \\frac{b}{m k_B T}\n$$\n因此，允许选择一个非负 $\\alpha_{\\mathrm{th}}$ 的摩擦系数 $\\gamma$ 的最小值为：\n$$\n\\gamma_{\\min} = \\frac{b}{m k_B T}\n$$\n该表达式的单位确实是 $\\mathrm{s}^{-1}$。这是为了耗散由强度为 $b$ 的随机力噪声注入的能量，以维持目标温度 $T$ 所需的最小摩擦。低于此值的摩擦将导致系统比目标温度“更热”，这种情况无法通过恒温器增加更多噪声来补救（因为 $\\alpha_{\\mathrm{th}}$ 不能为负）。", "answer": "$$\\boxed{\\frac{b}{m k_B T}}$$", "id": "3407518"}, {"introduction": "理论的价值最终体现在对实际数据的分析能力上。本练习提供了一个从模拟轨迹数据中诊断细致平衡破坏程度的实用计算方法[@problem_id:3407510]。你将学习如何通过计算状态空间中“环路亲和势”来量化非平衡定常态下的净概率流，从而将细致平衡这一抽象概念转化为一个具体的、可测量的诊断工具，用以评估你的模拟是否达到了真正的热力学平衡。", "problem": "考虑已被离散化为有限状态空间的分子动力学（MD）轨迹。我们观察状态之间的一个长跃迁序列，并记录经验跃迁计数。从这些计数中，构建一个基于这些状态的经验性时间齐次离散时间马尔可夫链。马尔可夫链中的细致平衡概念将状态间的平衡流与对称性联系起来；当细致平衡精确成立时，状态图中任何环路周围都没有净流。当细致平衡被违背时，存在非零的净流和非零的环路亲和势。你的任务是实现一个程序，对于一组在不同采样时间步长下的经验跃迁计数矩阵，通过计算由观测到的跃迁所导出的有向图上的最大环路亲和势的绝对值，来测量细致平衡被违背的程度。\n\n从以下概念基础出发：\n- 使用离散时间马尔可夫链的定义，其转移矩阵为 $P$，稳态分布向量为 $\\pi$，满足 $ \\pi^{\\top} P = \\pi^{\\top} $，且有 $ \\sum_i \\pi_i = 1 $ 和 $ \\pi_i \\ge 0 $。\n- 细致平衡要求对于所有具有非零概率的有向边 $ i \\to j $，都有 $ \\pi_i P_{ij} = \\pi_j P_{ji} $。\n- 净流和环路亲和势是用于检测和量化细致平衡违背的适当构造。特别是，边上的净流和环路上的亲和势应从上述定义出发，纯粹从第一性原理推导得出，而不使用任何预先提供的快捷公式。\n\n程序要求：\n1. 对于每个提供的测试用例，你必须：\n   - 将经验跃迁计数矩阵 $C$ 转换为行随机的转移概率矩阵 $P$，方法是将每一行归一化，使其总和为 $1$。\n   - 使用一种能够收敛到合法稳态分布的数值稳定方法，估计满足 $ \\pi^{\\top} P = \\pi^{\\top} $ 的稳态分布 $ \\pi $。\n   - 使用边 $ i \\to j $ 构建状态上的有向图，其中经验计数 $ C_{ij} $ 严格为正且 $ i \\ne j $。\n   - 在此图中枚举所有长度至少为 $3$ 的简单有向环。一个简单有向环是一系列不同的节点 $ (v_0, v_1, \\dots, v_{k-1}) $（其中 $k \\ge 3$），使得有向边 $ v_0 \\to v_1, v_1 \\to v_2, \\dots, v_{k-1} \\to v_0 $ 全部存在，并且序列中没有节点重复。\n   - 对于每个这样的环路，计算其环路亲和势，即沿定向环路的边亲和势的带符号和。为了在经验观测到的反向转移概率为零时确保科学真实性，通过在分子和分母项中添加一个小的正伪计数来对计算进行正则化；使用一个固定的伪计数 $ \\varepsilon = 10^{-12} $。\n   - 取每个环路亲和势的大小（绝对值），并返回为该测试用例找到的最大值，作为一个无量纲浮点数。\n2. 你的程序必须为每个测试用例独立实现上述步骤，无需外部输入或文件访问。\n3. 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[x_1,x_2,x_3]”），每个条目是相应测试用例的最大环路亲和势大小，表示为四舍五入到六位小数的浮点数。\n\n测试套件：\n使用以下四个测试用例，每个用例由一个采样时间步长 $ \\Delta t $ 和一个在状态 $ \\{0,1,2,3\\} $ 上的 $4 \\times 4$ 经验跃迁计数矩阵 $ C $ 定义。所有计数都是无量纲的。\n\n- 案例A（接近细致平衡；小时间步长）：\n  - $ \\Delta t = 0.01 $\n  - $ C $ 的行，顺序为 $0,1,2,3$：\n    - 状态 $0$ 的行：到 $0$ 是 $50$，到 $1$ 是 $2500$，到 $2$ 是 $50$，到 $3$ 是 $2500$。\n    - 状态 $1$ 的行：到 $0$ 是 $2500$，到 $1$ 是 $50$，到 $2$ 是 $2500$，到 $3$ 是 $50$。\n    - 状态 $2$ 的行：到 $0$ 是 $50$，到 $1$ 是 $2500$，到 $2$ 是 $50$，到 $3$ 是 $2500$。\n    - 状态 $3$ 的行：到 $0$ 是 $2500$，到 $1$ 是 $50$，到 $2$ 是 $2500$，到 $3$ 是 $50$。\n\n- 案例B（轻微正向环偏差；中等时间步长）：\n  - $ \\Delta t = 0.1 $\n  - $ C $ 的行：\n    - 状态 $0$ 的行：到 $0$ 是 $50$，到 $1$ 是 $2600$，到 $2$ 是 $50$，到 $3$ 是 $2400$。\n    - 状态 $1$ 的行：到 $0$ 是 $2400$，到 $1$ 是 $50$，到 $2$ 是 $2600$，到 $3$ 是 $50$。\n    - 状态 $2$ 的行：到 $0$ 是 $50$，到 $1$ 是 $2400$，到 $2$ 是 $50$，到 $3$ 是 $2600$。\n    - 状态 $3$ 的行：到 $0$ 是 $2600$，到 $1$ 是 $50$，到 $2$ 是 $2400$，到 $3$ 是 $50$。\n\n- 案例C（强正向环偏差；较大时间步长）：\n  - $ \\Delta t = 0.5 $\n  - $ C $ 的行：\n    - 状态 $0$ 的行：到 $0$ 是 $50$，到 $1$ 是 $3000$，到 $2$ 是 $50$，到 $3$ 是 $2000$。\n    - 状态 $1$ 的行：到 $0$ 是 $2000$，到 $1$ 是 $50$，到 $2$ 是 $3000$，到 $3$ 是 $50$。\n    - 状态 $2$ 的行：到 $0$ 是 $50$，到 $1$ 是 $2000$，到 $2$ 是 $50$，到 $3$ 是 $3000$。\n    - 状态 $3$ 的行：到 $0$ 是 $3000$，到 $1$ 是 $50$，到 $2$ 是 $2000$，到 $3$ 是 $50$。\n\n- 案例D（缺失反向跃迁的极端粗略采样；最大违背）：\n  - $ \\Delta t = 1.0 $\n  - $ C $ 的行：\n    - 状态 $0$ 的行：到 $0$ 是 $50$，到 $1$ 是 $4000$，到 $2$ 是 $50$，到 $3$ 是 $0$。\n    - 状态 $1$ 的行：到 $0$ 是 $0$，到 $1$ 是 $50$，到 $2$ 是 $4000$，到 $3$ 是 $50$。\n    - 状态 $2$ 的行：到 $0$ 是 $50$，到 $1$ 是 $0$，到 $2$ 是 $50$，到 $3$ 是 $4000$。\n    - 状态 $3$ 的行：到 $0$ 是 $4000$，到 $1$ 是 $50$，到 $2$ 是 $0$，到 $3$ 是 $50$。\n\n覆盖范围基本原理：\n- 案例A是“理想路径”，其中细致平衡几乎完全成立；最大环路亲和势应接近于 $0$。\n- 案例B引入了轻微的正向偏差；最大环路亲和势应该很小但明显非零。\n- 案例C增加了偏差；最大环路亲和势应该明显更大。\n- 案例D是一个边缘情况，反向跃迁计数中存在零；伪计数正则化至关重要，最大环路亲和势应显著大于案例C。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[A,B,C,D]$，其中每个条目分别是案例A、B、C和D的最大环路亲和势大小，四舍五入到六位小数（无量纲）。", "solution": "该问题要求对从经验跃迁计数导出的离散时间马尔可夫链中的细致平衡违背进行量化。这是通过计算状态转移图上环路亲和势的最大绝对值来完成的。解决方案首先建立理论框架，然后详细说明算法实现。\n\n**1. 理论框架**\n\n设离散化状态的有限集为 $S = \\{0, 1, \\dots, N-1\\}$。经验数据以跃迁计数矩阵 $C$ 的形式给出，其中 $C_{ij}$ 是从状态 $i$ 到状态 $j$ 观测到的跃迁次数。\n\n**1.1. 转移概率矩阵**\n从这些计数构造一个时间齐次的离散时间马尔可夫链。从状态 $i$ 到状态 $j$ 的转移概率 $P_{ij}$ 通过对每行的计数进行归一化来估计：\n$$P_{ij} = \\frac{C_{ij}}{\\sum_{k=0}^{N-1} C_{ik}}$$\n这确保了 $P$ 是一个行随机矩阵，即对于所有 $i$，都有 $\\sum_j P_{ij} = 1$。\n\n**1.2. 稳态分布**\n稳态分布 $\\pi$ 是一个概率向量，表示占据每个状态的平衡概率。它的定义是，经过马尔可夫链的一步演化后保持不变，这在数学上对应于它是 $P$ 的特征值为 $1$ 的左特征向量：\n$$\\pi^{\\top} P = \\pi^{\\top}$$\n此外，它必须是一个有效的概率分布：$\\sum_{i=0}^{N-1} \\pi_i = 1$ 且对于所有 $i$ 都有 $\\pi_i \\ge 0$。对于一个不可约且非周期的马尔可夫链，这个分布是唯一的。我们通过计算转置矩阵 $P^{\\top}$ 对应于特征值 $1$ 的右特征向量来找到 $\\pi$。\n\n**1.3. 细致平衡与亲和势**\n在热平衡状态下，系统应满足细致平衡原理。对于马尔可夫链，此条件表明从状态 $i$ 到状态 $j$ 的平衡通量等于从 $j$ 到 $i$ 的通量：\n$$\\pi_i P_{ij} = \\pi_j P_{ji}$$\n当此条件被违背时，状态之间存在净概率流。对于一条边 $i \\to j$，这种违背的程度可以通过边亲和势 $a_{ij}$ 来量化，其定义为前向通量与后向通量之比的对数：\n$$a_{ij} = \\ln \\left( \\frac{\\pi_i P_{ij}}{\\pi_j P_{ji}} \\right)$$\n\n**1.4. 环路亲和势**\n对于一个由状态 $(v_0, v_1, \\dots, v_{k-1})$ 构成的简单有向环（其中 $k \\ge 3$），环路亲和势 $\\mathcal{A}_{\\text{cycle}}$ 是沿环路的边亲和势之和：\n$$\\mathcal{A}_{\\text{cycle}} = \\sum_{l=0}^{k-1} a_{v_l, v_{l+1 \\pmod k}} = \\sum_{l=0}^{k-1} \\ln \\left( \\frac{\\pi_{v_l} P_{v_l, v_{l+1 \\pmod k}}}{\\pi_{v_{l+1 \\pmod k}} P_{v_{l+1 \\pmod k}, v_l}} \\right)$$\n利用对数的性质，这个和可以简化。涉及 $\\pi$ 的项形成一个求值为零的裂项和：$\\sum_{l=0}^{k-1} (\\ln \\pi_{v_l} - \\ln \\pi_{v_{l+1 \\pmod k}}) = 0$。这就得到了环路亲和势的基本定义：\n$$\\mathcal{A}_{\\text{cycle}} = \\ln \\left( \\prod_{l=0}^{k-1} \\frac{P_{v_l, v_{l+1 \\pmod k}}}{P_{v_{l+1 \\pmod k}, v_l}} \\right)$$\n该表达式表示沿环路正向遍历与反向遍历的概率的对数比。如果环路中所有边都满足细致平衡，则亲和势为零。非零的亲和势表示环路周围存在净环流或净流，这是非平衡动力学的一个明确标志。\n\n**1.5. 正则化**\n经验数据可能会导致某些跃迁的计数为零，即 $C_{ji}=0$，从而导致 $P_{ji}=0$。这会使亲和势的计算发散。为确保数值稳定性并真实地处理这种情况，我们对通量项进行正则化。按照规定，在取对数之前，我们为每个通量项添加一个小的伪计数 $\\varepsilon = 10^{-12}$。正则化后的边亲和势为：\n$$a_{ij} = \\ln \\left( \\frac{\\pi_i P_{ij} + \\varepsilon}{\\pi_j P_{ji} + \\varepsilon} \\right)$$\n环路亲和势就是这些正则化边亲和势的和。采取这种方法是因为它直接遵循了对“边亲和势”求和的指令。\n\n**2. 算法实现**\n\n每个测试用例的总体算法流程如下：\n\n1.  **矩阵归一化**：将输入的计数矩阵 $C$ 转换为行随机的转移矩阵 $P$。\n\n2.  **稳态分布计算**：通过使用数值库函数（`numpy.linalg.eig`）计算 $P^{\\top}$ 的特征向量来找到稳态分布 $\\pi$。选择与特征值最接近 $1$ 的特征向量。取其实部并进行归一化，使其总和为 $1$。\n\n3.  **图的构建**：根据状态构建一个有向图，如果 $C_{ij} > 0$ 且 $i \\neq j$，则存在一条边 $i \\to j$。邻接表是一种合适的表示方法。\n\n4.  **环路枚举**：使用回溯深度优先搜索（DFS）算法枚举所有长度为 $3$ 或更大的简单有向环。搜索从每个节点开始并探索路径，标记已访问的节点以确保环路的简单性。当路径返回其起始节点时，就检测到一个环路。为避免处理重复的环路（例如 $0 \\to 1 \\to 2 \\to 0$ 和 $1 \\to 2 \\to 0 \\to 1$），发现的环路会被归一化（例如，通过旋转并存储在集合中）以获得唯一的集合。\n\n5.  **亲和势计算**：对于每个唯一的环路，通过对上述定义的正则化边亲和势求和来计算其亲和势。\n\n6.  **最大亲和势大小**：计算每个环路亲和势的绝对值，并保留所有环路中的最大值。如果没有找到环路，则结果为 $0.0$。这个最终值作为给定系统细致平衡总体违背程度的度量标准。", "answer": "```python\nimport numpy as np\n\ndef _dfs_find_cycles(start_node, current_node, path, visited, adj, cycles):\n    \"\"\"\n    A helper recursive function for finding simple cycles using DFS.\n    \"\"\"\n    for neighbor in adj.get(current_node, []):\n        if neighbor == start_node:\n            # A cycle is found if the path returns to the start node.\n            # a simple cycle has k distinct nodes (k >= 3).\n            # The path has k nodes, and the cycle length is k.\n            if len(path) >= 3:\n                cycles.append(list(path))\n        elif neighbor not in visited:\n            visited.add(neighbor)\n            path.append(neighbor)\n            _dfs_find_cycles(start_node, neighbor, path, visited, adj, cycles)\n            path.pop()\n            visited.remove(neighbor)\n\ndef find_all_simple_cycles(adj):\n    \"\"\"\n    Finds all simple cycles of length >= 3 in a directed graph.\n    \"\"\"\n    all_cycles = []\n    nodes = list(adj.keys())\n    for node in nodes:\n        path = [node]\n        visited = {node}\n        _dfs_find_cycles(node, node, path, visited, adj, all_cycles)\n    \n    # Normalize cycles to get a unique set. A cycle (v0, v1, ..., vk-1)\n    # is normalized by rotating it so the smallest node index is first.\n    unique_cycles = set()\n    for cycle in all_cycles:\n        min_node_idx = cycle.index(min(cycle))\n        normalized_cycle = tuple(cycle[min_node_idx:] + cycle[:min_node_idx])\n        unique_cycles.add(normalized_cycle)\n        \n    return list(unique_cycles)\n\ndef calculate_max_cycle_affinity(C, epsilon=1e-12):\n    \"\"\"\n    Calculates the largest cycle affinity magnitude for a given count matrix.\n    \"\"\"\n    num_states = C.shape[0]\n\n    # Step 1: Convert count matrix C to transition probability matrix P.\n    row_sums = C.sum(axis=1, keepdims=True)\n    P = np.divide(C, row_sums, out=np.zeros_like(C, dtype=float), where=row_sums != 0)\n\n    # Step 2: Estimate stationary distribution pi.\n    # pi is the left eigenvector of P for eigenvalue 1.\n    # This is equivalent to the right eigenvector of P.T for eigenvalue 1.\n    eigenvalues, eigenvectors = np.linalg.eig(P.T)\n    idx = np.argmin(np.abs(eigenvalues - 1.0))\n    pi_unnormalized = np.real(eigenvectors[:, idx])\n    pi = pi_unnormalized / np.sum(pi_unnormalized)\n\n    # Step 3: Construct the directed graph.\n    adj = {i: [] for i in range(num_states)}\n    for i in range(num_states):\n        for j in range(num_states):\n            if i != j and C[i, j] > 0:\n                adj[i].append(j)\n\n    # Step 4: Enumerate all simple directed cycles.\n    cycles = find_all_simple_cycles(adj)\n    \n    if not cycles:\n        return 0.0\n\n    # Step 5  6: Compute cycle affinities and find the max magnitude.\n    max_affinity_magnitude = 0.0\n    for cycle in cycles:\n        cycle_affinity = 0.0\n        path = list(cycle) + [cycle[0]]  # Close the loop\n        for i in range(len(cycle)):\n            u, v = path[i], path[i+1]\n            \n            # Regularized edge affinity: log( (pi_u * P_uv + eps) / (pi_v * P_vu + eps) )\n            forward_flux = pi[u] * P[u, v] + epsilon\n            backward_flux = pi[v] * P[v, u] + epsilon\n            \n            edge_affinity = np.log(forward_flux / backward_flux)\n            cycle_affinity += edge_affinity\n        \n        max_affinity_magnitude = max(max_affinity_magnitude, abs(cycle_affinity))\n\n    return max_affinity_magnitude\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        np.array([\n            [50, 2500, 50, 2500],\n            [2500, 50, 2500, 50],\n            [50, 2500, 50, 2500],\n            [2500, 50, 2500, 50]\n        ]),\n        # Case B\n        np.array([\n            [50, 2600, 50, 2400],\n            [2400, 50, 2600, 50],\n            [50, 2400, 50, 2600],\n            [2600, 50, 2400, 50]\n        ]),\n        # Case C\n        np.array([\n            [50, 3000, 50, 2000],\n            [2000, 50, 3000, 50],\n            [50, 2000, 50, 3000],\n            [3000, 50, 2000, 50]\n        ]),\n        # Case D\n        np.array([\n            [50, 4000, 50, 0],\n            [0, 50, 4000, 50],\n            [50, 0, 50, 4000],\n            [4000, 50, 0, 50]\n        ])\n    ]\n\n    results = []\n    for C in test_cases:\n        result = calculate_max_cycle_affinity(C)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3407510"}]}