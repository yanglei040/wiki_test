{"hands_on_practices": [{"introduction": "在高性能计算中，理解核心计算内核的性能极限是优化的第一步。Roofline模型是进行此类分析的强大工具，它揭示了计算是受限于处理器的计算速度还是内存带宽。这个练习 [@problem_id:3329287] 提供了将Roofline模型应用于稀疏矩阵向量乘法（CFD中常见的操作）的实践，让你亲手判断一个典型内核的性能瓶颈。", "problem": "考虑在计算流体动力学（CFD）求解器中，使用压缩稀疏行（CSR）数据结构进行矩阵向量乘积，以应用七点模板对三维泊松算子进行有限体积离散化。该稀疏矩阵的每一行恰好有 $z=7$ 个非零元。CSR 表示法使用双精度值和向量（每个存储为 $8$ 字节），并使用 $32$ 位整数作为列索引和行指针数组（每个存储为 $4$ 字节）。该操作是稀疏矩阵向量乘法（SpMV），$y = A x$，在一个中央处理器（CPU）节点上执行，该节点维持的主内存带宽为每秒 $200$ 吉字节，双精度峰值性能为每秒 $1.6 \\times 10^{12}$ 次浮点运算。对于带宽，将 $1$ 吉字节解释为 $10^{9}$ 字节。\n\n假设一个实现对 CSR 数组进行流式访问，其中每个非零元为一个输出项的累加贡献一次乘法和一次加法，累加完全在寄存器中进行，并且输出项 $y_{i}$ 每行只写入一次。由于问题规模和访问模式的组合，假设输入向量项 $x_{j}$ 在各行之间没有复用，并计算每行界定非零元区间所需的两个行指针项（一个用于行的开始，一个用于行的结束）。\n\n从 CSR 内存访问模式和 Roofline 模型的定义出发，确定每行移动的总字节数和浮点运算次数，计算此 SpMV 的运算强度，然后确定 Roofline 性能界限。以每秒十亿次浮点运算（GFLOP/s）为单位表示最终性能界限。将最终答案四舍五入到三位有效数字。[@problem_id:15]", "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第1步：提取已知条件\n- 操作：稀疏矩阵向量乘法 (SpMV)，$y = A x$。\n- 求解器背景：计算流体动力学 (CFD)。\n- 离散化：有限体积法，三维泊松算子，七点模板。\n- 矩阵结构：稀疏，每行恰好有 $z=7$ 个非零元。\n- 数据结构：压缩稀疏行 (CSR)。\n- 数据类型：\n    - 矩阵值 (`A_vals`) 和向量项 ($x, y$)：双精度，每个元素8字节。\n    - 列索引 (`A_cols`) 和行指针 (`A_row_ptr`)：32位整数，每个元素4字节。\n- 硬件规格：\n    - 主内存带宽 ($\\beta$)：200 GB/s ($200 \\times 10^{9}$ 字节/秒)。\n    - 峰值双精度性能 ($\\pi_{peak}$)：$1.6 \\times 10^{12}$ 次浮点运算/秒 (FLOP/s)。\n- 实现假设：\n    - 每个非零元的浮点运算：1次乘法和1次加法。\n    - 输出项 $y_i$ 的累加完全在寄存器中进行。\n    - 输出项 $y_i$ 每行写入内存一次。\n    - 内存访问是流式的，输入向量项 ($x_j$) 在各行之间没有缓存复用。\n    - 每行读取两个行指针项来界定非零元。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准评估该问题。\n- **科学依据**：该问题很好地基于高性能计算、数值线性代数和计算流体动力学的既定原理。CSR格式、SpMV操作和Roofline性能模型是该领域的标准主题。用于三维泊松方程的七点模板是一个经典的例子。\n- **适定性**：该问题是适定的。它提供了计算运算强度和应用Roofline模型以找到唯一性能界限所需的所有必要参数和一组清晰、明确的假设（例如，数据大小、每个非零元的操作、内存访问模式）。\n- **客观性**：该问题使用精确、客观和技术性的语言陈述，没有歧义或主观声明。\n- **缺陷检查**：\n    1.  **科学或事实不健全**：无。概念及其应用均属标准。提供的硬件性能数值对于现代CPU节点而言是现实的。\n    2.  **不可形式化或不相关**：无。问题完全可以形式化，并且与科学计算中数值核心的性能分析直接相关。\n    3.  **不完整或矛盾的设置**：无。问题是自包含的，并提供了所有必要的信息。每行非零元数量恒定（$z=7$）的假设是一种简化，但已明确说明，并非矛盾。\n    4.  **不切实际或不可行**：无。这些条件在物理上是合理的，并且在性能建模练习中很常见。\n    5.  **不适定或结构不良**：无。问题结构从第一性原理（FLOP和字节计数）逻辑地引导用户到Roofline模型的最终应用。\n    6.  **伪深刻、琐碎或同义反复**：无。该问题需要正确且不平凡地应用Roofline模型，这是性能工程中的一个关键概念。\n    7.  **超出科学可验证性范围**：无。整个计算基于可验证的数学定义和模型。\n\n### 第3步：结论与行动\n问题是**有效的**。将推导解答。\n\n### 解答推导\n解答过程首先计算矩阵向量乘积单行所需的浮点运算次数（FLOPs）以及与主内存之间传输的总字节数。然后用这些值计算运算强度，这是Roofline模型中的一个关键参数。最后，应用Roofline模型来确定性能界限。\n\n**1. 每行浮点运算次数**\n问题陈述，矩阵的每个非零元贡献一次乘法和一次加法。由于每行有 $z=7$ 个非零元，因此每行的总FLOPs数为：\n$$\n\\text{每行FLOPs} = 2 \\times z = 2 \\times 7 = 14 \\text{ FLOPs}\n$$\n\n**2. 每行内存流量**\n总内存流量（移动的字节数）是为计算一行而从主内存读取和写入主内存的所有数据的总和。我们考虑了CSR数据结构组件以及输入/输出向量。\n\n- **CSR `values` 数组**：对于 $z=7$ 个非零元中的每一个，读取一个双精度值。一个双精度浮点数是 $8$ 字节。\n$$\n\\text{字节数}_{\\text{values}} = z \\times (\\text{双精度大小}) = 7 \\times 8 = 56 \\text{ 字节}\n$$\n- **CSR `col_ind` 数组**：对于 $z=7$ 个非零元中的每一个，读取一个 $32$ 位整型列索引。一个 $32$ 位整数是 $4$ 字节。\n$$\n\\text{字节数}_{\\text{col\\_ind}} = z \\times (\\text{int32大小}) = 7 \\times 4 = 28 \\text{ 字节}\n$$\n- **CSR `row_ptr` 数组**：为识别第 $i$ 行的非零元，需读取 `row_ptr[i]` 和 `row_ptr[i+1]` 这两项。这是两个 $32$ 位整数。\n$$\n\\text{字节数}_{\\text{row\\_ptr}} = 2 \\times (\\text{int32大小}) = 2 \\times 4 = 8 \\text{ 字节}\n$$\n- **输入向量 `x`**：对于 $z=7$ 个非零元 $A_{ij}$ 中的每一个，读取对应的元素 $x_j$。问题陈述假设没有缓存复用，因此这 $z=7$ 次访问中的每一次都会导致从主内存读取。向量元素是双精度的。\n$$\n\\text{字节数}_{x} = z \\times (\\text{双精度大小}) = 7 \\times 8 = 56 \\text{ 字节}\n$$\n- **输出向量 `y`**：每行将单个结果元素 $y_i$写入内存一次。这是一个双精度值。\n$$\n\\text{字节数}_{y} = 1 \\times (\\text{双精度大小}) = 1 \\times 8 = 8 \\text{ 字节}\n$$\n每行移动的总字节数是这些分量的总和：\n$$\n\\text{每行总字节数} = \\text{字节数}_{\\text{values}} + \\text{字节数}_{\\text{col\\_ind}} + \\text{字节数}_{\\text{row\\_ptr}} + \\text{字节数}_{x} + \\text{字节数}_{y}\n$$\n$$\n\\text{每行总字节数} = 56 + 28 + 8 + 56 + 8 = 156 \\text{ 字节}\n$$\n\n**3. 运算强度**\n运算强度 ($I$) 是浮点运算次数与处理器和主内存之间移动的数据字节数之比。\n$$\nI = \\frac{\\text{每行FLOPs}}{\\text{每行总字节数}} = \\frac{14}{156} \\text{ FLOPs/字节}\n$$\n化简得 $I = \\frac{7}{78}$ FLOPs/字节。\n\n**4. Roofline性能界限**\nRoofline模型给出了性能上限 $P$，即峰值计算性能 $\\pi_{peak}$ 和内存带宽可支持的峰值性能 $P_{mem} = I \\times \\beta$ 中的较小值。\n$$\nP = \\min(\\pi_{peak}, I \\times \\beta)\n$$\n给定值为：\n- $\\pi_{peak} = 1.6 \\times 10^{12}$ FLOP/s\n- $\\beta = 200 \\times 10^9$ 字节/秒\n\n首先，我们计算受内存带宽限制的性能：\n$$\nP_{mem} = I \\times \\beta = \\left(\\frac{14}{156}\\right) \\frac{\\text{FLOPs}}{\\text{字节}} \\times (200 \\times 10^9) \\frac{\\text{字节}}{\\text{秒}}\n$$\n$$\nP_{mem} = \\frac{14 \\times 200 \\times 10^9}{156} \\frac{\\text{FLOPs}}{\\text{s}} = \\frac{2800}{156} \\times 10^9 \\text{ FLOP/s}\n$$\n$$\nP_{mem} \\approx 17.9487179... \\times 10^9 \\text{ FLOP/s}\n$$\n这大约是 $17.95$ GFLOP/s。\n\n现在，我们将其与峰值计算性能进行比较：\n$$\n\\pi_{peak} = 1.6 \\times 10^{12} \\text{ FLOP/s} = 1600 \\times 10^9 \\text{ FLOP/s} = 1600 \\text{ GFLOP/s}\n$$\nRoofline性能界限为：\n$$\nP = \\min(1600 \\times 10^9 \\text{ FLOP/s}, 17.9487... \\times 10^9 \\text{ FLOP/s})\n$$\n由于 $17.9487... \\times 10^9 \\ll 1600 \\times 10^9$，性能受内存带宽限制。\n$$\nP \\approx 17.9487... \\times 10^9 \\text{ FLOP/s}\n$$\n问题要求结果以GFLOP/s为单位，并四舍五入到三位有效数字。\n$$\nP \\approx 17.9 \\text{ GFLOP/s}\n$$", "answer": "$$\n\\boxed{17.9}\n$$", "id": "3329287"}, {"introduction": "在分析了单节点性能之后，下一个挑战是理解并行化带来的开销。这个练习 [@problem_id:3329344] 探讨了区域分解求解器中的通信开销，重点是“光环”交换（halo exchange）机制。通过推导周期性边界条件引入的额外通信成本，你将对并行拓扑和边界处理如何直接影响整体性能有一个具体的认识。", "problem": "考虑一个三维均匀笛卡尔有限体积计算流体动力学 (CFD) 求解器，该求解器在结构化网格上对一个标量守恒律系统进行显式时间推进。计算域被分解为一个逻辑笛卡尔块拓扑结构，包含 $P_x \\times P_y \\times P_z$ 个消息传递接口 (MPI) 进程，其中每个进程拥有一个由 $n_x \\times n_y \\times n_z$ 个内部控制体组成的子域（块）。该数值格式使用一种紧致模板，需要在六个面中的每一个面上设置 $s \\in \\mathbb{N}$ 层幽灵单元（光环宽度），以便在每个时间步更新所有内部单元。求解器执行仅面光环交换：在每个坐标方向上，每个时间步只发起一次最近邻交换，每个面发送 $s$ 个连续的幽灵数据平面；不存在直接的边或角消息。\n\n每个全局坐标方向可以是周期性的或非周期性的。引入指示变量 $\\chi_x, \\chi_y, \\chi_z \\in \\{0,1\\}$，其中如果方向 $d \\in \\{x,y,z\\}$ 是周期性的，则 $\\chi_d = 1$，否则 $\\chi_d = 0$。在任何非周期性方向上，全局低侧面是入口边界，其幽灵单元由给定的狄利克雷数据设置；全局高侧面是出口边界，其幽灵单元通过单侧零梯度外推设置。入口和出口边界条件都在本地应用，无需进程间通信。在任何周期性方向上，全局低侧面的幽灵单元由来自全局高侧面邻居的数据环绕填充，反之亦然。这通过周期性笛卡尔通信子中的 MPI 点对点通信实现。\n\n在此分解和交换模型下，请用文字精确定义入口、出口和周期性面的幽灵单元填充的并行处理方式。然后，将单次光环交换发送视为一个进程向其在该方向上的邻居传输一个面上的所有 $s$ 个幽灵平面的过程，推导出一个闭式解析表达式，用于表示与所有物理边界幽灵单元都在本地应用的非周期性情况相比，仅由周期性导致的、每个时间步跨网络发送的额外标量幽灵单元值的总数。你的答案必须是一个单一的闭式表达式，用 $(P_x,P_y,P_z)$、$(n_x,n_y,n_z)$、$s$ 和 $(\\chi_x,\\chi_y,\\chi_z)$ 表示。不要引入任何其他参数。将最终答案表示为标量值的纯计数（无物理单位）。", "solution": "问题陈述描述了在结构化网格上使用区域分解的有限体积求解器的标准并行编程模型。包括 MPI、幽灵单元（光环）以及周期性和非周期性边界条件处理在内的各个组成部分，都是高性能科学计算中的标准概念。该问题具有科学依据、是适定的、客观的，并包含了进行严格推导所需的所有必要信息。因此，该问题被认为是有效的。\n\n解决方案按要求分为两部分呈现：首先，对幽灵单元填充机制进行定性描述；其次，对由周期性引起的额外通信成本进行定量推导。\n\n### 第一部分：幽灵单元填充的并行处理\n\n每个子域的 $s$ 层幽灵单元的填充取决于给定面是内部（进程间）边界还是物理（全局域）边界。对于物理边界，处理方式进一步取决于边界条件的类型。\n\n1.  **入口边界条件**：如果对应方向 $d \\in \\{x,y,z\\}$ 是非周期性的 ($\\chi_d=0$)，则此条件应用于全局低侧面。子域中有一个面与此全局边界重合的进程必须填充其 $s$ 个外部幽灵单元层。问题规定这些幽灵单元由给定的狄利克雷数据设置。此操作在“本地”执行，意味着该边界上的每个进程都独立地计算或查找其自身幽灵单元所需的值，而无需与其他进程进行任何 MPI 通信。数据由问题的物理特性决定，并非源自另一个进程的计算域。\n\n2.  **出口边界条件**：如果对应方向 $d \\in \\{x,y,z\\}$ 是非周期性的 ($\\chi_d=0$)，则此条件应用于全局高侧面。子域中有一个面位于此全局边界的进程使用单侧零梯度外推来填充其 $s$ 个外部幽灵单元层。这意味着幽灵单元中的值被设置为该进程最近的内部单元的值。此操作也在“本地”执行，并且不需要进程间的 MPI 通信。\n\n3.  **周期性边界条件**：如果一个方向 $d \\in \\{x,y,z\\}$ 是周期性的 ($\\chi_d=1$)，则应用此条件。在这种情况下，全局域在该方向上“环绕”自身。区域分解中全局低侧面上的进程被视为全局高侧面上进程的邻居。例如，在 $x$ 方向上，MPI 索引为 $i_x=0$ 的进程其低-$x$面是一个全局边界，而索引为 $i_x=P_x-1$ 的进程其高-$x$面是一个全局边界。为了填充 $i_x=0$ 进程的低-$x$面的幽灵单元，它必须从其周期性邻居 $i_x=P_x-1$ 的内部接收 $s$ 个数据平面。反之，为了填充 $i_x=P_x-1$ 进程的高-$x$面的幽灵单元，它必须从其周期性邻居 $i_x=0$ 接收 $s$ 个数据平面。这种数据交换通过 MPI 点对点通信完成，通常由一个能自动识别周期性邻居的 MPI 笛卡尔通信子管理。与非周期性情况不同，这种边界处理本质上是受通信限制的。\n\n### 第二部分：额外通信成本的推导\n\n目标是找出仅由周期性引起的、每个时间步跨网络发送的*额外*标量幽灵单元值的总数。这是指一般情况（具有指定的周期性）与所有三个方向均为非周期性（$\\chi_x=\\chi_y=\\chi_z=0$）的基准情况之间的通信量差异。\n\n在基准的非周期性情况下，通信仅发生在内部边界的 MPI 进程之间。物理边界在本地处理，无需 MPI 通信。当一个方向变为周期性时，该方向上两个全局面上的本地边界条件应用被这两个面之间的 MPI 通信所取代。因此，额外的通信成本恰好是跨越这些新建立的周期性连接的通信量。\n\n我们为每个笛卡尔方向计算这个额外的通信量，然后将结果相加。\n\n**$x$方向周期性的贡献：**\n该贡献仅在 $x$ 方向是周期性时存在，即当 $\\chi_x=1$ 时。如果 $\\chi_x=0$，则贡献为 $0$。\n当 $\\chi_x=1$ 时，MPI 通信发生在全局低-$x$面（MPI 索引 $i_x=0$）和全局高-$x$面（MPI 索引 $i_x=P_x-1$）上的进程之间。\n这样一个全局面上的进程数量是另外两个方向上进程数量的乘积：$P_y P_z$。\n对于这 $P_y P_z$ 对通信进程中的每一对，每个时间步执行两次发送：\n1.  位于 $i_x=0$ 的进程向其位于 $i_x=P_x-1$ 的周期性邻居发送数据。\n2.  位于 $i_x=P_x-1$ 的进程向其位于 $i_x=0$ 的周期性邻居发送数据。\n因此，在 $x$ 方向上跨越周期性接缝的总发送次数为 $2 P_y P_z$。\n每次发送传输 $s$ 个幽灵平面的数据。一个垂直于 $x$ 方向的平面，其维度对应于另外两个方向上内部单元的数量，即 $n_y \\times n_z$。\n因此，单次发送中的标量值的数量是 $s \\cdot n_y \\cdot n_z$。\n由于 $x$ 方向的周期性而发送的额外标量值的总数 $N_{add,x}$，是发送次数和每次发送的值数量的乘积，再乘以指示变量 $\\chi_x$：\n$$N_{add,x} = \\chi_x \\cdot (2 P_y P_z) \\cdot (s n_y n_z) = 2s \\chi_x n_y n_z P_y P_z$$\n\n**$y$方向周期性的贡献：**\n根据对称性，逻辑是相同的。该贡献仅在 $\\chi_y=1$ 时非零。全局面是由进程组成的 $xz$ 平面，因此每个面上有 $P_x P_z$ 个进程。数据平面垂直于 $y$ 方向，大小为 $n_x \\times n_z$。\n发送次数为 $2 P_x P_z$。\n每次发送的值数量为 $s n_x n_z$。\n发送的额外值的总数为：\n$$N_{add,y} = \\chi_y \\cdot (2 P_x P_z) \\cdot (s n_x n_z) = 2s \\chi_y n_x n_z P_x P_z$$\n\n**$z$方向周期性的贡献：**\n类似地，对于 $z$ 方向，该贡献要求 $\\chi_z=1$。全局面是由进程组成的 $xy$ 平面（每个面有 $P_x P_y$ 个进程）。数据平面垂直于 $z$ 方向，大小为 $n_x \\times n_y$。\n发送次数为 $2 P_x P_y$。\n每次发送的值数量为 $s n_x n_y$。\n发送的额外值的总数为：\n$$N_{add,z} = \\chi_z \\cdot (2 P_x P_y) \\cdot (s n_x n_y) = 2s \\chi_z n_x n_y P_x P_y$$\n\n**总额外通信成本：**\n每个时间步发送的额外标量值的总数 $N_{add}$ 是来自每个方向贡献的总和。\n$$N_{add} = N_{add,x} + N_{add,y} + N_{add,z}$$\n$$N_{add} = 2s \\chi_x n_y n_z P_y P_z + 2s \\chi_y n_x n_z P_x P_z + 2s \\chi_z n_x n_y P_x P_y$$\n提出公因子 $2s$ 得到最终的闭式表达式：\n$$N_{add} = 2s (\\chi_x n_y n_z P_y P_z + \\chi_y n_x n_z P_x P_z + \\chi_z n_x n_y P_x P_y)$$\n\n这个表达式正确地计算了，相对于所有全局边界都在本地处理的基准情况，仅因周期性边界条件而存在的所有 MPI 通道上所传输的标量值的总数。", "answer": "$$\n\\boxed{2s(\\chi_x n_y n_z P_y P_z + \\chi_y n_x n_z P_x P_z + \\chi_z n_x n_y P_x P_y)}\n$$", "id": "3329344"}, {"introduction": "在超大规模并行计算中，确保结果的“位可重现性”对于代码验证和调试至关重要，但这由于浮点运算的非结合律而充满挑战。这个高级练习 [@problem_id:3329343] 旨在解决这一问题，要求你分析和比较一个标准的、非确定性的并行规约算法与一个可重现的确定性算法。这项实践将揭示数值保真度与计算性能之间的权衡，这是现代科学软件工程中的一个核心考量。", "problem": "考虑在分布式内存环境中使用消息传递接口（MPI）计算可压缩Navier–Stokes求解器在每个非线性迭代步的残差二范数。全局残差向量被平均分配到 $P$ 个进程上；进程 $p$ 持有 $n$ 个双精度浮点数 $\\{r_{i}^{(p)}\\}_{i=1}^{n}$。残差二范数为 $\\|r\\|_{2} = \\sqrt{\\sum_{p=0}^{P-1}\\sum_{i=1}^{n} \\left(r_{i}^{(p)}\\right)^{2}}$。\n\n要求您为平方和提出一种确定性的并行归约方案，该方案能保证在相同硬件和软件配置下的多次运行中结果是按位可复现的，然后量化其相对于非确定性归约的性能开销。\n\n使用以下具有科学依据的出发点作为您的基础：\n1. 由电气和电子工程师协会（IEEE）$754$标准指定的有限精度算术不满足结合律，因此具有不同求值顺序的并行归约在多次运行中可能产生不同的舍入误差实现。\n2. 预先固定的归约顺序（例如，进程内固定的成对求和顺序以及具有指定父子调度关系的固定进程间归约树）在相同的执行条件下，能够产生按位可复现的跨运行结果。\n3. 用于通信时间的Hockney延迟-带宽模型 $T(m) = \\alpha + \\beta\\, m$ 是一个经过充分检验的点对点通信模型，其中 $\\alpha$ 是每条消息的延迟，$\\beta$ 是每字节的传输时间；一个二项树归约后跟广播会产生 $2\\log_{2} P$ 个阶段，每个阶段携带大小为 $m$ 字节的消息。\n4. 处理流数据的单节点时间可以通过一个roofline风格的计算时间和内存时间的最大值来建模：$T_{\\text{local}} = \\max\\{T_{\\text{mem}}, T_{\\text{comp}}\\}$，其中 $T_{\\text{mem}} = V/B$，$V$ 是内存量，$B$ 是可持续带宽；$T_{\\text{comp}} = \\text{flops}/F$，$flops$ 是浮点运算次数，$F$ 是可持续浮点运算速率。\n\n精确定义这两种方案如下。\nA. 非确定性基准方案。在每个进程上，使用朴素累加法按数组的自然存储顺序计算本地平方和，对每个元素执行一次浮点乘法和一次浮点加法。在进程间，使用一个标准的MPI all-reduce，该操作通过一个到根节点的二项树归约后跟广播实现，除了满足 $2\\log_{2} P$ 阶段的特性外，对所选树的形状没有其他约束。\nB. 确定性方案。在每个进程上，使用固定顺序的成对求和，并在每次成对合并中使用Kahan补偿求和，这样对每个元素，其平方值的累加需要一次浮点乘法和三次浮点加法/减法。在进程间，使用一个显式构造的二项树归约，其父子关系由递增的进程号确定，并为 $2\\log_{2} P$ 个阶段制定固定的调度，之后从进程0进行确定性广播；这施加了一个固定的进程间操作顺序。\n\n假设以下参数在所有进程上都是恒定的：\n- 每个进程的元素数 $n = 5 \\times 10^{7}$。\n- 进程数 $P = 256$。\n- 每个进程的可持续浮点运算速率 $F = 2.5 \\times 10^{9}$ flops/秒。\n- 每个进程的可持续内存带宽 $B = 2.0 \\times 10^{10}$ 字节/秒。\n- 通信延迟 $\\alpha = 3.0 \\times 10^{-6}$ 秒。\n- 每字节传输时间 $\\beta = 5.0 \\times 10^{-10}$ 秒。\n- 每个归约消息携带 $m = 8$ 字节（一个双精度部分和）。\n- 最终的平方根在根进程上计算，其成本与其他项相比可以忽略不计。\n\n仅使用上述基础和定义，不调用任何其他专门的公式，推导每种方案总时间的表达式，并计算开销比 $\\mathcal{R} = T_{\\text{det}}/T_{\\text{nd}}$。将您的答案四舍五入到四位有效数字。将该比率表示为一个无单位的无量纲数。", "solution": "我们从IEEE $754$标准中浮点加法不满足结合律的观察出发，因此变化的求值顺序会产生不同的舍入误差。通过固定操作顺序，可以实现跨运行的按位可复现性。在一个进程内部，我们可以对 $n$ 个元素强制执行一个固定的成对求和树，按预定顺序访问索引，并在每次合并中使用Kahan补偿求和来进一步稳定舍入轨迹。在进程之间，一个具有固定父子调度（例如，按进程号升序）的二项树，用于 $2\\log_{2} P$ 个阶段，产生了一个确定性的进程间顺序。因此，本地和全局的顺序都被固定下来，总和在多次运行中是可复现的。\n\n为了分析开销，我们将时间建模为本地处理时间和通信时间之和。两种方案的本地处理时间都由一个roofline风格的计算时间和内存时间的最大值决定，因为内核需要一次性流式处理 $n$ 个元素来计算平方和。\n\n对于非确定性基准方案：\n- 对每个元素，我们执行1次乘法和1次加法，共计2次浮点运算。因此，每个进程的总浮点工作量为\n$$\n\\text{flops}_{\\text{nd}} = 2 n.\n$$\n- 每个进程的计算时间为\n$$\nT_{\\text{comp,nd}} = \\frac{\\text{flops}_{\\text{nd}}}{F} = \\frac{2 n}{F}.\n$$\n- 每个进程的内存量是加载 $n$ 个双精度浮点数，即\n$$\nV = 8 n \\ \\text{字节},\n$$\n所以每个进程的内存时间为\n$$\nT_{\\text{mem}} = \\frac{V}{B} = \\frac{8 n}{B}.\n$$\n- 每个进程的本地时间为\n$$\nT_{\\text{local,nd}} = \\max\\!\\left\\{\\frac{8 n}{B}, \\frac{2 n}{F}\\right\\}.\n$$\n- 对于通信，归约加广播构成 $2 \\log_{2} P$ 个阶段，每个阶段发送 $m=8$ 字节。使用Hockney模型，总通信时间为\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right).\n$$\n因此，总的非确定性时间为\n$$\nT_{\\text{nd}} = T_{\\text{local,nd}} + T_{\\text{comm}}.\n$$\n\n对于确定性方案：\n- 对每个元素，在Kahan补偿下，我们执行1次乘法和3次加法/减法，共计4次浮点运算。每个进程的总浮点工作量为\n$$\n\\text{flops}_{\\text{det}} = 4 n,\n$$\n每个进程的计算时间为\n$$\nT_{\\text{comp,det}} = \\frac{\\text{flops}_{\\text{det}}}{F} = \\frac{4 n}{F}.\n$$\n- 每个进程的内存量和内存时间与上述相同，$T_{\\text{mem}} = \\dfrac{8 n}{B}$，因为两种方案都只流式处理数组一次。\n- 每个进程的本地时间为\n$$\nT_{\\text{local,det}} = \\max\\!\\left\\{\\frac{8 n}{B}, \\frac{4 n}{F}\\right\\}.\n$$\n- 通信使用相同的二项树深度和消息大小，但有固定的调度；在Hockney模型下的成本保持不变\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right).\n$$\n因此，总的确定性时间为\n$$\nT_{\\text{det}} = T_{\\text{local,det}} + T_{\\text{comm}}.\n$$\n\n我们现在用给定的参数来评估这些表达式。首先计算本地时间。使用 $n = 5 \\times 10^{7}$，$F = 2.5 \\times 10^{9}$ flops/秒，以及 $B = 2.0 \\times 10^{10}$ 字节/秒，我们得到\n$$\nT_{\\text{comp,nd}} = \\frac{2 n}{F} = \\frac{2 \\cdot \\left(5 \\times 10^{7}\\right)}{2.5 \\times 10^{9}} = \\frac{10 \\times 10^{7}}{2.5 \\times 10^{9}} = \\frac{10}{2.5} \\times 10^{-2} = 4.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{comp,det}} = \\frac{4 n}{F} = \\frac{4 \\cdot \\left(5 \\times 10^{7}\\right)}{2.5 \\times 10^{9}} = \\frac{20 \\times 10^{7}}{2.5 \\times 10^{9}} = \\frac{20}{2.5} \\times 10^{-2} = 8.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{mem}} = \\frac{8 n}{B} = \\frac{8 \\cdot \\left(5 \\times 10^{7}\\right)}{2.0 \\times 10^{10}} = \\frac{40 \\times 10^{7}}{2.0 \\times 10^{10}} = \\frac{40}{2.0} \\times 10^{-3} = 2.0 \\times 10^{-2} \\ \\text{s}.\n$$\n因此，\n$$\nT_{\\text{local,nd}} = \\max\\!\\left\\{2.0 \\times 10^{-2}, \\ 4.0 \\times 10^{-2}\\right\\} = 4.0 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{local,det}} = \\max\\!\\left\\{2.0 \\times 10^{-2}, \\ 8.0 \\times 10^{-2}\\right\\} = 8.0 \\times 10^{-2} \\ \\text{s}.\n$$\n\n接下来，计算通信时间，使用 $P = 256$ 使得 $\\log_{2} P = 8$，$\\alpha = 3.0 \\times 10^{-6}$ 秒，$\\beta = 5.0 \\times 10^{-10}$ 秒/字节，以及 $m = 8$ 字节：\n$$\nT_{\\text{comm}} = \\left(2 \\log_{2} P\\right)\\left(\\alpha + \\beta m\\right) = \\left(2 \\cdot 8\\right)\\left(3.0 \\times 10^{-6} + 5.0 \\times 10^{-10} \\cdot 8\\right).\n$$\n计算每个阶段的项：\n$$\n\\alpha + \\beta m = 3.0 \\times 10^{-6} + 4.0 \\times 10^{-9} = 3.004 \\times 10^{-6} \\ \\text{s}.\n$$\n乘以阶段数：\n$$\nT_{\\text{comm}} = 16 \\cdot \\left(3.004 \\times 10^{-6}\\right) = 48.064 \\times 10^{-6} \\ \\text{s} = 4.8064 \\times 10^{-5} \\ \\text{s}.\n$$\n\n汇总总时间：\n$$\nT_{\\text{nd}} = T_{\\text{local,nd}} + T_{\\text{comm}} = \\left(4.0 \\times 10^{-2}\\right) + \\left(4.8064 \\times 10^{-5}\\right) = 4.0048064 \\times 10^{-2} \\ \\text{s},\n$$\n$$\nT_{\\text{det}} = T_{\\text{local,det}} + T_{\\text{comm}} = \\left(8.0 \\times 10^{-2}\\right) + \\left(4.8064 \\times 10^{-5}\\right) = 8.0048064 \\times 10^{-2} \\ \\text{s}.\n$$\n最后，开销比为\n$$\n\\mathcal{R} = \\frac{T_{\\text{det}}}{T_{\\text{nd}}} = \\frac{8.0048064 \\times 10^{-2}}{4.0048064 \\times 10^{-2}} = \\frac{0.080048064}{0.040048064}.\n$$\n计算得，\n$$\n\\mathcal{R} \\approx 1.998799842\\ldots\n$$\n四舍五入到四位有效数字，得到\n$$\n\\mathcal{R} = 1.999.\n$$\n\n这个比率反映了，在给定参数下，两种方案都由计算（而非通信）主导，并且确定性方案使用的Kahan补偿求和相对于朴素求和，浮点工作量大约增加了一倍，而公共通信项的摊销效应可以忽略不计。在Hockney模型下对于标量消息，固定顺序的二项树与基准方案的二项all-reduce相比，不改变渐进通信成本。", "answer": "$$\\boxed{1.999}$$", "id": "3329343"}]}