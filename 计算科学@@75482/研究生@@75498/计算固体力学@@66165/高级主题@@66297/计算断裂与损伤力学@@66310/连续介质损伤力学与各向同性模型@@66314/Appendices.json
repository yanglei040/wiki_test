{"hands_on_practices": [{"introduction": "掌握连续介质损伤力学的关键在于能够将理论模型转化为可执行的计算算法。本练习将指导您为一种率无关的各向同性损伤模型构建一个隐式时间积分方案 [@problem_id:3554745]。通过推导并实现一个基于能量释放率和一致性条件的返回映射算法，您将深入理解损伤演化的预测-校正逻辑，这是计算固体力学中的一项核心技能。", "problem": "您需要为一个一维各向同性率无关连续介质损伤模型构建并实现一个隐式时间积分算法，然后将其应用于一组给定的应变历史。该算法必须在每个时间步强制执行一致性条件，并为一套参数集测试套件生成量化输出。\n\n假设基底材料为线性弹性材料，其特征为模量 $E$ 和一个标量各向同性损伤变量 $d \\in [0,1)$，该变量会均匀地降低刚度。本构应力-应变关系为 $\\sigma = (1 - d) E \\varepsilon$。单位体积的亥姆霍兹自由能假定为\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2,\n$$\n其中 $H$ 是一个正常数模量，用于正则化损伤演化并提供一个良定的驱动力。与损伤变量共轭的热力学力是损伤能量释放率\n$$\nY(\\varepsilon, d) = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d.\n$$\n率无关损伤激活由一个阈值 $Y_0 > 0$ 通过屈服函数控制\n$$\nf(\\varepsilon, d) = Y(\\varepsilon, d) - Y_0,\n$$\n并由 Karush-Kuhn-Tucker (KKT) 条件强制执行\n$$\n\\dot{d} \\ge 0,\\quad f(\\varepsilon, d) \\le 0,\\quad \\dot{d}\\, f(\\varepsilon, d) = 0.\n$$\n在每个离散时间步 $t_{n+1}$，给定前一步的损伤 $d_n$ 和给定的应变 $\\varepsilon_{n+1}$，为 $d_{n+1}$ 构建一个隐式更新，当损伤机制被激活时，该更新强制执行一致性条件。从这些基本定义和定律出发，推导出算法，该算法根据 $f(\\varepsilon_{n+1}, d_n)$ 决定损伤是增长还是保持不变，并且在激活时，在 $t_{n+1}$ 强制执行一致性条件，以使更新后的状态满足适当的约束。使用本构应力关系 $\\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1}$ 来计算应力响应。\n\n数值实现要求：\n- 在 KKT 条件的不等式检查中，使用一个小的非负容差 $\\tau$（例如，$\\tau = 10^{-12}$ 帕斯卡），以考虑浮点舍入误差。\n- 施加一个上限 $d_{\\max} = 0.999$，以避免数值更新中的奇异刚度，并强制 $d_{n+1} \\in [0, d_{\\max}]$。\n- 强制执行不可逆性约束 $d_{n+1} \\ge d_n$。\n- 无论加载或卸载，算法必须是隐式的，即所有更新量都在 $t_{n+1}$ 计算。\n\n物理单位和输出规格：\n- 所有模量 $E$、$H$、阈值 $Y_0$ 和应力 $\\sigma$ 必须以帕斯卡为单位处理和报告。\n- 应变 $\\varepsilon$ 是无量纲的。\n- 对于每个测试案例，程序必须报告一个包含三个值的列表：最终损伤 $d_{\\text{end}}$ (无量纲)，最终应力 $\\sigma_{\\text{end}}$ (单位：帕斯卡)，以及一致性条件被激活的时间步数的整数计数(即，在强制约束下更新损伤的次数)。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果 (例如, $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$)，其中每个 $\\text{result}_i$ 本身是对应测试案例的列表 $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$。\n\n测试套件：\n- 案例 1 (应变增加，发生激活)：\n  - $E = 200 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 800\\ \\text{Pa}$, $d_0 = 0.0$, 应变序列 $\\{ \\varepsilon_k \\} = [\\, 0.0,\\ 8 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 1.2 \\times 10^{-4},\\ 2 \\times 10^{-4} \\,]$。\n- 案例 2 (边界阈值和轻微卸载)：\n  - $E = 70 \\times 10^{9}\\ \\text{Pa}$, $H = 2 \\times 10^{4}\\ \\text{Pa}$, $Y_0 = 350\\ \\text{Pa}$, $d_0 = 0.0$, 应变序列 $\\{ \\varepsilon_k \\} = [\\, 5 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 9 \\times 10^{-5} \\,]$。\n- 案例 3 (由于 $H$ 值小而快速饱和)：\n  - $E = 30 \\times 10^{9}\\ \\text{Pa}$, $H = 500\\ \\text{Pa}$, $Y_0 = 100\\ \\text{Pa}$, $d_0 = 0.0$, 应变序列 $\\{ \\varepsilon_k \\} = [\\, 2 \\times 10^{-4},\\ 3 \\times 10^{-4},\\ 5 \\times 10^{-4} \\,]$。\n- 案例 4 (加载然后卸载)：\n  - $E = 100 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 1000\\ \\text{Pa}$, $d_0 = 0.0$, 应变序列 $\\{ \\varepsilon_k \\} = [\\, 1.5 \\times 10^{-4},\\ 2 \\times 10^{-4},\\ 1 \\times 10^{-4} \\,]$。\n\n您的程序必须实现从基本定义推导出的隐式算法，并以单行形式输出这四个案例的聚合列表 $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$，格式需严格遵守上述规定，应力单位为帕斯卡，损伤为无量纲。", "solution": "该问题陈述被评估为有效。它在科学上基于连续介质损伤力学原理，内部一致，并提供了构建唯一且有意义解所需的所有必要数据和约束。该问题是计算固体力学中的一个标准练习，要求推导并实现一个针对率无关材料模型的返回映射算法。\n\n问题的核心是为标量损伤变量 $d$ 设计一个时间离散的更新法则，在给定前一步 $t_n$ 的状态和一个给定的应变 $\\varepsilon_{n+1}$ 的情况下，计算时间步 $t_{n+1}$ 的值。此更新必须与率无关不可逆热力学原理一致，正如 Karush-Kuhn-Tucker (KKT) 条件所规定的那样。\n\n系统状态由应变 $\\varepsilon$ 和内损伤变量 $d$ 描述。该模型由以下方程定义：\n亥姆霍茲自由能密度：\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2\n$$\n应力的本构律：\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = (1 - d) E \\varepsilon\n$$\n与损伤共轭的热力学力，称为损伤能量释放率：\n$$\nY = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d\n$$\n损伤演化由屈服函数 $f$ 和一组 KKT 条件控制：\n$$\nf(Y) = Y - Y_0 \\le 0\n$$\n$$\n\\dot{d} \\ge 0 \\quad (\\text{不可逆性})\n$$\n$$\n\\dot{d} f(Y) = 0 \\quad (\\text{一致性})\n$$\n这些条件定义了一个弹性域，其中 $f  0$ 且 $\\dot{d}=0$，以及一个加载条件，其中 $f=0$ 且 $\\dot{d} \\ge 0$。\n\n对于数值实现，我们在时间上进行离散化。给定时间 $t_n$ 的状态 $d_n$ 和时间 $t_{n+1}$ 的给定应变 $\\varepsilon_{n+1}$，我们旨在找到 $d_{n+1}$ 和 $\\sigma_{n+1}$。算法结构遵循标准的弹性预测/损伤修正格式，该格式是隐式的，因为它在时间步结束时 $t_{n+1}$ 强制执行条件。\n\n**步骤 1：弹性预测**\n首先，我们做一个试探性假设，即该步是纯弹性的，意味着没有损伤演化。\n$$\nd_{n+1}^{\\text{trial}} = d_n\n$$\n\n**步骤 2：检查损伤激活**\n我们使用已知的应变 $\\varepsilon_{n+1}$ 和试探损伤 $d_{n+1}^{\\text{trial}}$ 在试探状态下评估屈服函数。让我们将试探损伤能量释放率定义为：\n$$\nY^{\\text{trial}} = Y(\\varepsilon_{n+1}, d_{n+1}^{\\text{trial}}) = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n\n$$\n那么试探屈服函数为：\n$$\nf^{\\text{trial}} = Y^{\\text{trial}} - Y_0 = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0\n$$\n现在我们将此值与弹性域要求进行比较，同时考虑一个小的数值容差 $\\tau > 0$：\n- 如果 $f^{\\text{trial}} \\le \\tau$，则试探状态是可接受的。弹性假设成立，没有损伤演化发生。KKT 条件在 $\\dot{d}=0$ (或者更准确地说，$\\Delta d = d_{n+1} - d_n = 0$) 的情况下得到满足。因此，我们接受试探状态：\n  $$\n  d_{n+1} = d_n\n  $$\n- 如果 $f^{\\text{trial}} > \\tau$，则试探状态是不可接受的，因为它位于弹性域之外。这表明在该步中必须发生损伤。KKT 条件要求系统状态返回到屈服面。这就是**一致性条件**，必须在时间步 $t_{n+1}$ 结束时强制执行：\n  $$\n  f(\\varepsilon_{n+1}, d_{n+1}) = 0\n  $$\n\n**步骤 3：损伤修正**\n当一致性条件被激活时，我们求解更新后的损伤值 $d_{n+1}$。\n$$\nf(\\varepsilon_{n+1}, d_{n+1}) = Y(\\varepsilon_{n+1}, d_{n+1}) - Y_0 = 0\n$$\n代入 $Y$ 的定义：\n$$\n\\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_{n+1} - Y_0 = 0\n$$\n求解这个关于 $d_{n+1}$ 的线性方程，得到更新后的损伤：\n$$\nd_{n+1} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\n这是算法的“返回映射”部分，因为它将不可接受的试探状态映射回屈服面。\n\n**步骤 4：施加约束**\n问题规定了对损伤变量的两个额外约束：不可逆性和一个最大值。\n- **不可逆性**: 损伤只能增加或保持不变，因此 $d_{n+1} \\ge d_n$。\n- **饱和**: 损伤不能达到 $1$，因此施加一个数值上限：$d_{n+1} \\le d_{\\max}$。\n\n当应用损伤修正器时，计算出的 $d_{n+1}$ 值必须遵守这些约束。我们可以将更新合并到一个表达式中。令 $d_{\\text{candidate}}$ 为从一致性条件得到的值：\n$$\nd_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\n然后，通过确保 $d_{n+1}$ 不小于前一值 $d_n$ 且不大于上限 $d_{\\max}$ 来获得其最终值。注意，如果修正步被激活 ($f^{\\text{trial}} > 0$)，则 $d_{\\text{candidate}} - d_n = \\frac{1}{H}(\\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 - H d_n) = \\frac{1}{H}f^{\\text{trial}} > 0$，所以 $d_{\\text{candidate}} > d_n$ 会自动满足。因此，不可逆性约束 $d_{n+1} \\ge d_n$ 由返回映射的逻辑内在满足。在这种情况下，唯一需要明确强制执行的约束是上限。\n\n$d_{n+1}$ 的完整算法更新如下：\n1.  计算 $f^{\\text{trial}} = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0$。\n2.  如果 $f^{\\text{trial}} \\le \\tau$:\n    $d_{n+1} = d_n$。\n3.  否则 (如果 $f^{\\text{trial}} > \\tau$):\n    $d_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)$。\n    $d_{n+1} = \\min(d_{\\text{candidate}}, d_{\\max})$。\n\n该算法隐式地维持了不可逆性约束。$f^{\\text{trial}} > \\tau$ 的情况对应于一个激活的一致性条件，因此我们为此类步骤增加一个计数器。\n\n**步骤 5：应力更新**\n一旦确定了该步的最终损伤值 $d_{n+1}$，就使用本构律计算时间 $t_{n+1}$ 的应力：\n$$\n\\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1}\n$$\n\n对给定的应变历史中的每一步重复此过程，以找到最终损伤 $d_{\\text{end}}$、最终应力 $\\sigma_{\\text{end}}$ 和损伤激活步的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem for a suite of test cases.\n    \"\"\"\n\n    # Numerical parameters specified in the problem statement.\n    tolerance = 1e-12  # Small tolerance for inequality checks.\n    d_max = 0.999      # Maximum allowable damage value.\n\n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case 1 (increasing strain, activation occurs)\n        {\n            \"E\": 200e9, \"H\": 1e4, \"Y0\": 800, \"d0\": 0.0,\n            \"strains\": [0.0, 8e-5, 1e-4, 1.2e-4, 2e-4]\n        },\n        # Case 2 (boundary threshold and slight unloading)\n        {\n            \"E\": 70e9, \"H\": 2e4, \"Y0\": 350, \"d0\": 0.0,\n            \"strains\": [5e-5, 1e-4, 9e-5]\n        },\n        # Case 3 (rapid saturation due to small H)\n        {\n            \"E\": 30e9, \"H\": 500, \"Y0\": 100, \"d0\": 0.0,\n            \"strains\": [2e-4, 3e-4, 5e-4]\n        },\n        # Case 4 (loading then unloading)\n        {\n            \"E\": 100e9, \"H\": 1e4, \"Y0\": 1000, \"d0\": 0.0,\n            \"strains\": [1.5e-4, 2e-4, 1e-4]\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E = case[\"E\"]\n        H = case[\"H\"]\n        Y0 = case[\"Y0\"]\n        \n        d_n = case[\"d0\"]\n        strains = case[\"strains\"]\n        \n        active_count = 0\n\n        # Iterate through the prescribed strain history.\n        for eps_np1 in strains:\n            # Calculate the trial yield function value.\n            # f_trial = Y_trial - Y0 = (0.5 * E * eps_np1^2 - H * d_n) - Y0\n            f_trial = 0.5 * E * eps_np1**2 - H * d_n - Y0\n\n            # Elastic predictor/damage corrector logic\n            if f_trial = tolerance:\n                # Elastic step: damage does not evolve.\n                d_np1 = d_n\n            else:\n                # Damage step: enforce consistency condition f(eps_{n+1}, d_{n+1}) = 0.\n                active_count += 1\n                \n                # Solve for d_{n+1} from the consistency condition:\n                # 0.5 * E * eps_{n+1}^2 - H * d_{n+1} - Y0 = 0\n                d_candidate = (0.5 * E * eps_np1**2 - Y0) / H\n                \n                # Enforce the maximum damage constraint. The irreversibility\n                # d_{n+1} = d_n is naturally satisfied since f_trial  0 implies\n                # d_candidate  d_n.\n                d_np1 = min(d_candidate, d_max)\n\n            # Update the damage variable for the next step.\n            d_n = d_np1\n            \n        # After the loop, d_n holds the final damage value.\n        d_end = d_n\n        \n        # Calculate the final stress using the final strain and final damage.\n        eps_end = strains[-1] if strains else 0.0\n        sigma_end = (1 - d_end) * E * eps_end\n        \n        results.append([d_end, sigma_end, active_count])\n\n    # Format the output as a single-line string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3554745"}, {"introduction": "在数值模拟中，理论上完美的算法在面对有限精度计算时可能表现出不稳定的行为。本练习聚焦于算子分裂法中一个常见但关键的细节：历史变量更新的数值鲁棒性 [@problem_id:3554716]。通过对比一个“朴素”的更新规则和一个考虑了公差的“鲁棒”规则，您将探索浮点数舍入误差如何影响模型的预测，并学会构建更可靠的本构模型更新程序。", "problem": "考虑一个通过算子分裂进行时间积分的标量、一维、各向同性损伤模型。其运动学由小应变变量 $\\,\\varepsilon\\,$、必须单调非减的标量内历史变量 $\\,\\kappa\\,$ 以及标量损伤变量 $\\,d\\in[0,1)\\,$ 表征。自由能密度假定为\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2,\n$$\n其中 $\\,E\\,$ 是杨氏模量。与 $\\,d\\,$ 共轭的热力学力是能量释放率\n$$\nY(\\varepsilon) = -\\frac{\\partial \\psi}{\\partial d} = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 \\ge 0.\n$$\n损伤由一个单调非减的历史变量 $\\,\\kappa\\,$ 通过本构映射 $\\,d=g(\\kappa)\\,$ 驱动。令\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big),\n$$\n其中参数 $\\,\\kappa_00\\,$ 且 $\\,m\\ge 1\\,$。一维柯西应力为\n$$\n\\sigma(\\varepsilon,\\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon.\n$$\n历史变量的更新被表述为单边约束\n$$\n\\kappa_{n+1} = \\max\\big(\\kappa_{n},\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big), \\quad \\text{with} \\quad \\tilde{\\kappa}(\\varepsilon) = |\\varepsilon|.\n$$\n这实现了损伤萌生与演化的互补（Kuhn–Tucker (KT)）条件的离散形式：$\\,\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1} \\le 0\\,$，$\\,\\kappa_{n+1} - \\kappa_{n} \\ge 0\\,$，以及 $\\,(\\kappa_{n+1}-\\kappa_{n})\\big(\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1}\\big)=0\\,$。在接近峰值强度时，浮点舍入可能使 $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$ 在数值上与 $\\,\\kappa_n\\,$ 无法区分，这可能导致不一致的分支决策，除非使用稳健的平局打破规则。\n\n仅从这些原理和定义出发（不得假定任何其他公式），为一个增量步 $\\,n\\to n+1\\,$ 实现两种离散时间步更新：\n\n- 一种使用精确最大值的朴素更新，\n$$\n\\kappa_{n+1}^{\\text{naive}} = \\max\\big(\\kappa_n,\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big).\n$$\n\n- 一种稳健更新，它用一个考虑容差的平局打破规则取代精确比较：对于用户指定的 $\\,a_{\\mathrm{tol}}\\ge 0\\,$ 和 $\\,r_{\\mathrm{tol}}\\ge 0\\,$，定义\n$$\n\\mathrm{tol}(\\kappa_n,\\tilde{\\kappa}) = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max\\big(|\\kappa_n|,\\,|\\tilde{\\kappa}|\\big).\n$$\n然后设置\n$$\n\\kappa_{n+1}^{\\text{rob}} =\n\\begin{cases}\n\\tilde{\\kappa},  \\text{if } \\tilde{\\kappa} \\ge \\kappa_n + \\mathrm{tol},\\\\\n\\kappa_n,  \\text{if } \\tilde{\\kappa} \\le \\kappa_n - \\mathrm{tol},\\\\\n\\kappa_n,  \\text{otherwise (tie region).}\n\\end{cases}\n$$\n这种平局打破规则倾向于在模糊带内保持不变以避免震颤，同时保持单调性。强制施加单调性钳制 $\\,\\kappa_{n+1}^{\\text{rob}} \\leftarrow \\max(\\kappa_n,\\kappa_{n+1}^{\\text{rob}})\\,$ 以保证 $\\,\\kappa\\,$ 不会减小。\n\n对于每种更新规则，在步骤 $\\,n+1\\,$ 计算应力 $\\,\\sigma_{n+1}\\,$ 和离散损伤耗散增量\n$$\n\\Delta \\mathcal{D} \\approx Y_{n+\\theta}\\,\\Delta d, \\quad \\Delta d = d(\\kappa_{n+1})-d(\\kappa_n), \\quad Y_{n+\\theta} = \\tfrac{1}{2}\\,E\\,\\varepsilon_{n+1}^2,\n$$\n其中 $\\,\\theta=1\\,$（此处不需要中点；取在 $\\,n+1\\,$ 处计算的 $\\,Y\\,$ 值进行保守的非负性检查，因为 $\\,Y\\ge 0\\,$ 和 $\\,\\Delta d\\ge 0\\,$ 应意味着 $\\,\\Delta \\mathcal{D}\\ge 0\\,$）。通过检查 $\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$，在损伤容差 $\\,t_{\\mathrm{diss}}\\,$ 范围内对 $\\,\\Delta d \\ge 0\\,$ 进行数值验证。\n\n峰值强度敏感性。对于给定的 $\\,d(\\kappa)\\,$ 和在单调拉伸下的 $\\,\\kappa=\\tilde{\\kappa}(\\varepsilon)=|\\varepsilon|\\,$，应力-应变关系为\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\varepsilon}{\\kappa_0}\\big)^m\\Big),\n$$\n其峰值出现在\n$$\n\\varepsilon_{\\mathrm{p}} = \\kappa_0\\,m^{-1/m}.\n$$\n提供一项数值研究，其中包含 $\\,\\varepsilon_{n+1}\\,$ 非常接近 $\\,\\varepsilon_{\\mathrm{p}}\\,$ 的情况，以致浮点舍入可能翻转比较结果。通过报告两种更新规则下的离散应力增量 $\\,\\Delta \\sigma = \\sigma_{n+1}-\\sigma_{n}\\,$ 来量化其影响。\n\n实现要求。\n\n- 使用算子分裂算法：给定 $\\,(\\varepsilon_n,\\kappa_n)\\,$，计算 $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$，用每种规则更新 $\\,\\kappa_{n+1}\\,$，然后计算 $\\,d_{n+1}=d(\\kappa_{n+1})\\,$ 和 $\\,\\sigma_{n+1}\\,$。\n- 使用材料参数 $\\,E=\\,$$\\,2.10\\times 10^{5}\\,$ 帕斯卡，$\\,\\kappa_0=\\,$$\\,2.0\\times 10^{-2}\\,$，以及 $\\,m=\\,$$\\,2.0\\,$。\n- 使用稳健性容差 $\\,a_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-12}\\,$，$\\,r_{\\mathrm{tol}}=\\,$$\\,1.0\\times 10^{-8}\\,$，以及损伤正性容差 $\\,t_{\\mathrm{diss}}=\\,$$\\,1.0\\times 10^{-14}\\,$。\n- 将应变视为无量纲，所有应力均以帕斯卡（pascals）表示；在输出中报告 $\\,\\Delta \\sigma\\,$（以帕斯卡为单位），不带任何单位。\n\n测试套件。对于每个案例 $\\,i\\,$，输入为 $\\,(\\varepsilon_n^{(i)},\\kappa_n^{(i)},\\varepsilon_{n+1}^{(i)})\\,$，需要产生的输出为\n$$\n\\big[\\kappa_{n+1}^{\\text{naive}},\\ \\kappa_{n+1}^{\\text{rob}},\\ \\Delta \\sigma^{\\text{naive}},\\ \\Delta \\sigma^{\\text{rob}},\\ \\mathrm{mon}^{\\text{naive}},\\ \\mathrm{mon}^{\\text{rob}},\\ \\mathrm{diss}^{\\text{naive}},\\ \\mathrm{diss}^{\\text{rob}}\\big],\n$$\n其中 $\\,\\mathrm{mon}\\,$ 和 $\\,\\mathrm{diss}\\,$ 分别是单调性（$\\,\\kappa_{n+1}\\ge \\kappa_n\\,$）和离散损伤正性（$\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$）的布尔标志。使用以下案例：\n\n- 案例 $\\,1\\,$（理想路径，明确增加）：$\\ \\varepsilon_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\times 10^{-2}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.2\\times 10^{-2}\\,$.\n- 案例 $\\,2\\,$（接近峰值，微小向上差异低于容差）：令 $\\,\\varepsilon_{\\mathrm{p}}=\\kappa_0\\,m^{-1/m}\\,$。使用 $\\ \\varepsilon_n=\\,$$\\,1.414213561\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213563\\times 10^{-2}\\,$.\n- 案例 $\\,3\\,$（接近峰值，微小向下差异）：$\\ \\varepsilon_n=\\,$$\\,1.414213563\\times 10^{-2}\\,$, $\\ \\kappa_n=\\varepsilon_n\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.414213561\\times 10^{-2}\\,$.\n- 案例 $\\,4\\,$（边缘情况，接近零）：$\\ \\varepsilon_n=\\,$$\\,0.0\\,$, $\\ \\kappa_n=\\,$$\\,0.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.0\\times 10^{-16}\\,$.\n- 案例 $\\,5\\,$（大数值，相对容差主导）：$\\ \\varepsilon_n=\\,$$\\,1.0\\,$, $\\ \\kappa_n=\\,$$\\,1.0\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,1.000000005\\,$.\n- 案例 $\\,6\\,$（强劲增长）：$\\ \\varepsilon_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\kappa_n=\\,$$\\,5.0\\times 10^{-1}\\,$, $\\ \\varepsilon_{n+1}=\\,$$\\,6.0\\times 10^{-1}\\,$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是按上述顺序排列的八个条目的列表。例如，输出应如下所示\n$$\n[\\,[\\cdots 8\\ \\text{entries}\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\,].\n$$\n所有应力必须以帕斯卡表示，所有布尔值必须以编程语言的布尔字面量形式出现。", "solution": "该问题是适定的且具有科学依据。它提出了一个计算损伤力学中的标准问题，提供了执行关于历史变量更新稳健性的数值研究所需的所有本构方程、参数和算法。所有提供的信息都是自洽且一致的。\n\n任务是在一维各向同性损伤模型中，实现并比较标量历史变量 $\\kappa$ 的两种不同更新方案。该模型在连续介质力学框架内定义，使用算子分裂方法对内变量进行时间积分。\n\n材料在时间步 $n$ 的状态由应变 $\\varepsilon_n$ 和历史变量 $\\kappa_n$ 描述。历史变量 $\\kappa$ 是材料所经历的最大应变幅值的度量，并且在本构上要求是单调非减的，即 $\\kappa_{n+1} \\ge \\kappa_n$。\n\n核心本构关系如下：\n亥姆霍兹自由能密度 $\\psi$ 由下式给出：\n$$\n\\psi(\\varepsilon, d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2\n$$\n其中 $E$ 是杨氏模量，$d$ 是标量损伤变量，$d \\in [0, 1)$。\n\n损伤变量 $d$ 是历史变量 $\\kappa$ 的函数：\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n其中材料参数 $\\kappa_0  0$ 且 $m \\ge 1$。\n\n柯西应力 $\\sigma$ 从自由能导出，$\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon}$：\n$$\n\\sigma(\\varepsilon, \\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n\n损伤的演化由 $\\kappa$ 的更新控制。在时间步 $n+1$ 的历史变量试探值基于新应变 $\\varepsilon_{n+1}$ 定义：\n$$\n\\tilde{\\kappa}(\\varepsilon_{n+1}) = |\\varepsilon_{n+1}|\n$$\n然后，使用该试探值从上一步的值 $\\kappa_n$ 来更新 $\\kappa$。演化必须满足 Kuhn-Tucker 条件，其离散形式意味着 $\\kappa_{n+1} = \\max(\\kappa_n, \\tilde{\\kappa}(\\varepsilon_{n+1}))$。该问题要求将此更新的朴素实现与一个基于容差的稳健版本进行比较。\n\n从 $n$ 到 $n+1$ 的单个时间增量步的算法流程如下：\n1.  给定状态 $(\\varepsilon_n, \\kappa_n)$ 和新应变 $\\varepsilon_{n+1}$。\n2.  计算增量步开始时的应力：$\\sigma_n = \\sigma(\\varepsilon_n, \\kappa_n)$。\n3.  计算历史变量试探值：$\\tilde{\\kappa}_{n+1} = |\\varepsilon_{n+1}|$。\n4.  使用两种不同的规则将历史变量更新为 $\\kappa_{n+1}$：\n\n    a.  **朴素更新规则**：此规则直接实现 `max` 函数，当 $\\tilde{\\kappa}_{n+1}$ 非常接近 $\\kappa_n$ 时，容易受到浮点误差的影响。\n        $$\n        \\kappa_{n+1}^{\\text{naive}} = \\max(\\kappa_n, \\tilde{\\kappa}_{n+1})\n        $$\n\n    b.  **稳健更新规则**：此规则在 $\\kappa_n$ 周围引入一个容差带，以处理 $\\tilde{\\kappa}_{n+1} \\approx \\kappa_n$ 的模糊情况。如果试探值没有比当前历史值大得足够多，它会阻止损伤演化。容差定义为：\n        $$\n        \\mathrm{tol} = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max(|\\kappa_n|, |\\tilde{\\kappa}_{n+1}|)\n        $$\n        其中 $a_{\\text{tol}}$ 是绝对容差，$r_{\\text{tol}}$ 是相对容差。更新逻辑指定为：\n        $$\n        \\kappa'_{n+1} =\n        \\begin{cases}\n        \\tilde{\\kappa}_{n+1},  \\text{if } \\tilde{\\kappa}_{n+1} \\ge \\kappa_n + \\mathrm{tol} \\\\\n        \\kappa_n,            \\text{otherwise}\n        \\end{cases}\n        $$\n        根据要求应用最终的单调性钳制，尽管对于非负的 $\\kappa$ 和 $\\tilde{\\kappa}$，所定义的规则已经确保了这一点：\n        $$\n        \\kappa_{n+1}^{\\text{rob}} = \\max(\\kappa_n, \\kappa'_{n+1})\n        $$\n\n5.  对于每个得到的历史变量（$\\kappa_{n+1}^{\\text{naive}}$ 和 $\\kappa_{n+1}^{\\text{rob}}$），计算在步骤 $n+1$ 对应的量：\n    -   损伤：$d_{n+1} = d(\\kappa_{n+1})$。\n    -   应力：$\\sigma_{n+1} = \\sigma(\\varepsilon_{n+1}, \\kappa_{n+1})$。\n    -   应力增量：$\\Delta\\sigma = \\sigma_{n+1} - \\sigma_n$。\n\n6.  最后，对每个更新规则执行验证检查：\n    -   **$\\kappa$ 的单调性**：检查是否 $\\kappa_{n+1} \\ge \\kappa_n$。根据构造，预计两条规则都应为真。\n    -   **耗散的正性**：损伤增量 $\\Delta d = d_{n+1} - d_n$ 必须为非负。为考虑浮点不精确性，使用容差 $t_{\\text{diss}}$ 进行检查：$\\Delta d \\ge -t_{\\text{diss}}$。由于 $d(\\kappa)$ 是一个单调递增函数且 $\\kappa_{n+1} \\ge \\kappa_n$，这也应为真。\n\n实现将对提供的每个测试案例应用此程序，使用指定的材料参数（$E = 2.1 \\times 10^5$, $\\kappa_0 = 2.0 \\times 10^{-2}$, $m = 2.0$）和容差（$a_{\\text{tol}} = 1.0 \\times 10^{-12}$, $r_{\\text{tol}} = 1.0 \\times 10^{-8}$, $t_{\\text{diss}} = 1.0 \\times 10^{-14}$）。将为每个案例计算八个指定的输出值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem by implementing and\n    comparing naive and robust update rules for the history variable.\n    \"\"\"\n    # Material and tolerance parameters from the problem statement\n    E = 2.10e5\n    kappa_0 = 2.0e-2\n    m = 2.0\n    a_tol = 1.0e-12\n    r_tol = 1.0e-8\n    t_diss = 1.0e-14\n\n    # --- Constitutive Functions ---\n    def damage_func(kappa):\n        if kappa  0: # kappa must be non-negative\n            return 0.0\n        return 1.0 - np.exp(-((kappa / kappa_0)**m))\n\n    def stress_func(epsilon, kappa):\n        d = damage_func(kappa)\n        return (1.0 - d) * E * epsilon\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (epsilon_n, kappa_n, epsilon_n+1)\n        (1.0e-2, 1.0e-2, 1.2e-2),\n        (1.414213561e-2, 1.414213561e-2, 1.414213563e-2),\n        (1.414213563e-2, 1.414213563e-2, 1.414213561e-2),\n        (0.0, 0.0, 1.0e-16),\n        (1.0, 1.0, 1.000000005),\n        (5.0e-1, 5.0e-1, 6.0e-1),\n    ]\n\n    results = []\n    \n    for eps_n, kappa_n, eps_n1 in test_cases:\n        \n        # --- Common calculations for the step ---\n        sigma_n = stress_func(eps_n, kappa_n)\n        d_n = damage_func(kappa_n)\n        tilde_kappa_n1 = abs(eps_n1)\n\n        # --- Naive Update ---\n        kappa_n1_naive = max(kappa_n, tilde_kappa_n1)\n        sigma_n1_naive = stress_func(eps_n1, kappa_n1_naive)\n        d_n1_naive = damage_func(kappa_n1_naive)\n        \n        delta_sigma_naive = sigma_n1_naive - sigma_n\n        mon_naive = kappa_n1_naive >= kappa_n\n        delta_d_naive = d_n1_naive - d_n\n        diss_naive = delta_d_naive >= -t_diss\n\n        # --- Robust Update ---\n        tol = a_tol + r_tol * max(abs(kappa_n), abs(tilde_kappa_n1))\n        \n        if tilde_kappa_n1 >= kappa_n + tol:\n            kappa_n1_rob_intermediate = tilde_kappa_n1\n        # The problem statement has a three-way condition, but the `otherwise`\n        # branch handles both the tie-region and the case where tilde_kappa  kappa_n.\n        # This simplification is equivalent to the problem statement logic.\n        else:\n            kappa_n1_rob_intermediate = kappa_n\n\n        # Apply monotonicity clamp as requested\n        kappa_n1_rob = max(kappa_n, kappa_n1_rob_intermediate)\n        \n        sigma_n1_rob = stress_func(eps_n1, kappa_n1_rob)\n        d_n1_rob = damage_func(kappa_n1_rob)\n        \n        delta_sigma_rob = sigma_n1_rob - sigma_n\n        mon_rob = kappa_n1_rob >= kappa_n\n        delta_d_rob = d_n1_rob - d_n\n        diss_rob = delta_d_rob >= -t_diss\n\n        # --- Assemble results for the current case ---\n        case_result = [\n            kappa_n1_naive,\n            kappa_n1_rob,\n            delta_sigma_naive,\n            delta_sigma_rob,\n            mon_naive,\n            mon_rob,\n            diss_naive,\n            diss_rob\n        ]\n        results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Create the string representation manually to match the required format\n    # `repr()` is used to get a standard string for floats and booleans.\n    outer_parts = []\n    for res_list in results:\n        inner_parts = [repr(x) for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3554716"}, {"introduction": "为了防止有限元模拟中的刚度矩阵出现奇异性，在实践中通常会将损伤变量 $d$ 的值限制在一个小于1的上限 $d_{\\max}$ 内。本练习将引导您从能量耗散的角度，定量分析这种损伤上限设置所带来的影响 [@problem_id:3554731]。通过推导截断损伤值与所允许的相对能量误差 $\\alpha$ 之间的解析关系，您将学会如何基于物理原则来理性地选择数值参数。", "problem": "考虑一个各向同性可损伤线弹性固体的一维代表性体积单元 (RVE)，其标量损伤变量为 $d \\in [0,1]$。弹性刚度因施加在完好模量 $E>0$ 上的光滑退化函数 $g(d)$ 而降低，其亥姆霍兹自由能密度为\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,g(d)\\,E\\,\\varepsilon^{2},\n$$\n其中 $\\varepsilon$ 是小应变。假设为等温、准静态、速率无关的演化，并采用与损伤共轭的热力学力（能量释放率）的标准定义，\n$$\nY(\\varepsilon,d) := -\\frac{\\partial \\psi}{\\partial d}\\Big|_{\\varepsilon}.\n$$\n采用广泛使用的各向同性退化函数 $g(d) = (1-d)^{2}$，并考虑一个应变控制过程，在该过程中，总应变被施加并固定在水平 $\\bar{\\varepsilon}$，同时损伤不断发展。在极限 $d \\to 1^{-}$ 时，刚度 $g(d)E \\to 0$，这会导致有限元计算中出现椭圆性丧失和近奇异刚度矩阵。为防止这种情况，数值实现中将损伤变量限制在截断值 $d_{\\max}  1$，从而强制保留一个残余刚度分数 $g(d_{\\max}) > 0$。\n\n将因损伤接近1时被截断而产生的能量误差定义为损失的耗散能量密度\n$$\n\\Delta \\mathcal{D} = \\int_{d_{\\max}}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d,\n$$\n并将完全损伤（如果允许达到 $d=1$）的总耗散能量密度定义为\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\int_{0}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d.\n$$\n引入用户规定的容许相对能量误差 $0  \\alpha  1$，并要求选择截断值 $d_{\\max}$，以使相对误差满足 $\\Delta \\mathcal{D}/\\mathcal{D}_{\\mathrm{tot}} \\le \\alpha$。\n\n仅根据上述陈述，推导出一个显式闭式表达式 $d_{\\max}(\\alpha)$，该表达式在给定假设下强制满足等式 $\\Delta \\mathcal{D}/\\mathcal{D}_{\\mathrm{tot}} = \\alpha$。您的最终答案必须是仅含 $\\alpha$ 的单个解析表达式。不需要四舍五入，最终表达式中也不应包含单位。", "solution": "该问题要求推导损伤截断值 $d_{\\max}$ 作为容许相对能量误差 $\\alpha$ 的函数的显式闭式表达式。推导过程首先从形式化问题陈述中定义的量开始。\n\n亥姆霍兹自由能密度由 $\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,g(d)\\,E\\,\\varepsilon^{2}$ 给出。使用特定的各向同性退化函数 $g(d) = (1-d)^{2}$，自由能密度为：\n$$\n\\psi(\\varepsilon,d) = \\frac{1}{2}\\,(1-d)^{2}\\,E\\,\\varepsilon^{2}\n$$\n其中 $\\varepsilon$ 是应变，$d$ 是标量损伤变量，$E>0$ 是完好的杨氏模量。\n\n与损伤共轭的热力学力，也称为能量释放率，定义为 $Y(\\varepsilon,d) := -\\frac{\\partial \\psi}{\\partial d}\\Big|_{\\varepsilon}$。我们对给定的自由能表达式计算该导数：\n$$\nY(\\varepsilon,d) = -\\frac{\\partial}{\\partial d} \\left( \\frac{1}{2}\\,(1-d)^{2}\\,E\\,\\varepsilon^{2} \\right)\n$$\n将 $E$ 和 $\\varepsilon$ 视为关于 $d$ 的常数，我们使用链式法则进行微分：\n$$\nY(\\varepsilon,d) = - \\left( \\frac{1}{2}\\,E\\,\\varepsilon^{2} \\right) \\left( 2\\,(1-d) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}d}(1-d) \\right) = - \\left( \\frac{1}{2}\\,E\\,\\varepsilon^{2} \\right) \\left( 2\\,(1-d) \\cdot (-1) \\right)\n$$\n简化后得到：\n$$\nY(\\varepsilon,d) = E\\,\\varepsilon^{2}\\,(1-d)\n$$\n问题指定了一个应变控制过程，其中应变固定在水平 $\\bar{\\varepsilon}$。因此，在此过程中的能量释放率为：\n$$\nY(\\bar{\\varepsilon},d) = E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\n$$\n\n接下来，我们计算总耗散能量密度 $\\mathcal{D}_{\\mathrm{tot}}$，它是能量释放率在从 $d=0$ 到 $d=1$ 的整个损伤范围内的积分。\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\int_{0}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d = \\int_{0}^{1} E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\\,\\mathrm{d}d\n$$\n由于 $E\\,\\bar{\\varepsilon}^{2}$ 相对于积分变量 $d$ 是常数，可以将其移到积分号外：\n$$\n\\mathcal{D}_{\\mathrm{tot}} = E\\,\\bar{\\varepsilon}^{2} \\int_{0}^{1} (1-d)\\,\\mathrm{d}d = E\\,\\bar{\\varepsilon}^{2} \\left[ d - \\frac{d^2}{2} \\right]_{0}^{1}\n$$\n计算该定积分的上下限值：\n$$\n\\mathcal{D}_{\\mathrm{tot}} = E\\,\\bar{\\varepsilon}^{2} \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(0 - \\frac{0^2}{2}\\right) \\right) = E\\,\\bar{\\varepsilon}^{2} \\left( \\frac{1}{2} \\right) = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}\n$$\n该结果对应于完好固体在应变 $\\bar{\\varepsilon}$ 下储存的总应变能密度。\n\n现在，我们计算损失的耗散能量密度 $\\Delta \\mathcal{D}$，这是由于损伤变量被截断在 $d_{\\max}$ 而未耗散的能量。这是能量释放率从 $d=d_{\\max}$ 到 $d=1$ 的积分。\n$$\n\\Delta \\mathcal{D} = \\int_{d_{\\max}}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d = \\int_{d_{\\max}}^{1} E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\\,\\mathrm{d}d\n$$\n同样，我们提出常数项并进行积分：\n$$\n\\Delta \\mathcal{D} = E\\,\\bar{\\varepsilon}^{2} \\int_{d_{\\max}}^{1} (1-d)\\,\\mathrm{d}d = E\\,\\bar{\\varepsilon}^{2} \\left[ d - \\frac{d^2}{2} \\right]_{d_{\\max}}^{1}\n$$\n计算该定积分：\n$$\n\\Delta \\mathcal{D} = E\\,\\bar{\\varepsilon}^{2} \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(d_{\\max} - \\frac{d_{\\max}^2}{2}\\right) \\right) = E\\,\\bar{\\varepsilon}^{2} \\left( \\frac{1}{2} - d_{\\max} + \\frac{d_{\\max}^2}{2} \\right)\n$$\n该表达式可以通过提出因子 $\\frac{1}{2}$ 来重写：\n$$\n\\Delta \\mathcal{D} = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} \\left( 1 - 2d_{\\max} + d_{\\max}^2 \\right) = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} (1-d_{\\max})^2\n$$\n\n最后，我们强制执行相对能量误差等于规定值 $\\alpha$ 的条件：\n$$\n\\frac{\\Delta \\mathcal{D}}{\\mathcal{D}_{\\mathrm{tot}}} = \\alpha\n$$\n代入为 $\\Delta \\mathcal{D}$ 和 $\\mathcal{D}_{\\mathrm{tot}}$ 推导出的表达式：\n$$\n\\frac{\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} (1-d_{\\max})^2}{\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}} = \\alpha\n$$\n项 $\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}$ 被消去，表明该关系与材料模量和施加的应变水平无关。这留下了一个连接 $d_{\\max}$ 和 $\\alpha$ 的简单代数方程：\n$$\n(1-d_{\\max})^2 = \\alpha\n$$\n为了求解 $d_{\\max}$，我们对两边取平方根：\n$$\n1 - d_{\\max} = \\pm\\sqrt{\\alpha}\n$$\n重新整理方程求解 $d_{\\max}$，得到两个可能的解：\n$$\nd_{\\max} = 1 - \\sqrt{\\alpha} \\quad \\text{或} \\quad d_{\\max} = 1 + \\sqrt{\\alpha}\n$$\n我们利用问题的约束条件来确定物理上有效的解。损伤截断值 $d_{\\max}$ 必须小于 $1$，并且误差容限 $\\alpha$ 的范围是 $0  \\alpha  1$。对于此范围内的 $\\alpha$，其平方根 $\\sqrt{\\alpha}$ 也是一个介于 $0$ 和 $1$ 之间的正实数。\n1. 解 $d_{\\max} = 1 + \\sqrt{\\alpha}$ 会导致 $d_{\\max} > 1$，这在物理上是不可接受的，因为损伤变量不能超过 $1$。\n2. 解 $d_{\\max} = 1 - \\sqrt{\\alpha}$ 得到的 $d_{\\max}$ 值满足 $0  d_{\\max}  1$，这与问题的所有物理约束相符。\n\n因此，唯一有效的表达式是 $d_{\\max}(\\alpha) = 1 - \\sqrt{\\alpha}$。", "answer": "$$\n\\boxed{1 - \\sqrt{\\alpha}}\n$$", "id": "3554731"}]}