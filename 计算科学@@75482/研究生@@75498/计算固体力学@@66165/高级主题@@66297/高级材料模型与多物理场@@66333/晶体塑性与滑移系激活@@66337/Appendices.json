{"hands_on_practices": [{"introduction": "任何晶体塑性模型的核心是本构“流动法则”（flow rule），它规定了在特定应力作用下，每个滑移系上会发生多大的滑移。本实践将指导您动手实现应用广泛的率相关幂律模型。通过根据分解剪应力计算滑移速率，您将构建驱动晶体材料塑性变形的基本引擎。[@problem_id:3556441]", "problem": "在晶体塑性 (CP) 的背景下，给定一组由 $\\alpha$ 索引的滑移系。每个滑移系都由分解剪应力 $\\tau^\\alpha$ 和滑移抗力（也称为临界分解剪应力）$g^\\alpha$ 来表征，二者单位均为应力单位。该材料是率相关的，具有率敏感性参数 $m$（无量纲）和参考滑移率 $\\dot{\\gamma}_0$（单位为 $\\mathrm{s}^{-1}$）。力学耗散定义为 $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$，并假设存在一个凸耗散势以生成关联流动法则。目标是基于此原理计算每个滑移系的滑移率 $\\dot{\\gamma}^\\alpha$，然后使用阈值算法确定激活集。如果一个滑移系的过应力比 $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$ 高于指定的比率阈值，且其滑移率大小高于规定的容差，则该滑移系被认为是激活的。\n\n推导和实现的基本依据：\n- 率相关本构描述源于一个凸耗散伪势的假设，该势函数取决于滑移率的大小和滑移抗力。\n- 通过强制要求分解剪应力是耗散势相对于滑移率的次微分，从而得到与热力学第二定律一致的关联流动法则。\n\n您必须编写一个完整的程序，针对下面指定的每个测试用例，计算：\n1. 所有滑移系的滑移率 $\\dot{\\gamma}^\\alpha$（单位为 $\\mathrm{s}^{-1}$）。\n2. 由以下定义的阈值算法确定的激活集标志 $A^\\alpha \\in \\{\\text{True}, \\text{False}\\}$：\n   - 计算过应力比 $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$（无量纲）。\n   - 如果 $r^\\alpha \\ge r_{\\mathrm{thr}}$ 和 $\\left|\\dot{\\gamma}^\\alpha\\right| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$ 同时满足，则滑移系被激活。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，结果为方括号括起来的逗号分隔列表。每个测试用例的结果必须表示为一个列表，其中包含两个列表：第一个是滑移率列表（单位为 $\\mathrm{s}^{-1}$），第二个是激活集的布尔值列表。例如：$[\\,[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,],\\ldots\\,]$。\n\n请使用以下测试套件。所有应力 $\\tau^\\alpha$ 和 $g^\\alpha$ 的单位应解释为 $\\mathrm{MPa}$，滑移率单位为 $\\mathrm{s}^{-1}$，本问题不使用角度。\n\n- 测试用例 1（一般情况，混合符号和零应力）：\n  - $\\boldsymbol{\\tau} = [\\,120,\\,80,\\,-110,\\,20,\\,0,\\,95\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,100,\\,100,\\,100\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.05$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.98$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-6}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 2（边界条件，包括 $\\left|\\tau^\\alpha\\right| = g^\\alpha$ 和零应力）：\n  - $\\boldsymbol{\\tau} = [\\,100,\\,100,\\,-100,\\,50,\\,-50,\\,0\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,120,\\,100,\\,60,\\,50,\\,80\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.2$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 1.0$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 5\\times 10^{-6}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 3（低过应力比，中等率敏感性）：\n  - $\\boldsymbol{\\tau} = [\\,30,\\,-45,\\,70,\\,-10,\\,5,\\,15\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,150,\\,150,\\,200,\\,200,\\,180,\\,160\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.5$，\n  - $\\dot{\\gamma}_0 = 10^{-2}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.9$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-4}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 4（接近零的应力以探测数值稳定性）：\n  - $\\boldsymbol{\\tau} = [\\,0.1,\\,-0.2,\\,0.0,\\,0.05,\\,-0.05,\\,0.01\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,120,\\,120,\\,150\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.05$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.95$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-8}\\,\\mathrm{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，形式为 $[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,]$。所有滑移率必须以 $\\mathrm{s}^{-1}$ 为单位表示。", "solution": "所述问题是有效的。它在科学上植根于连续介质力学和材料科学的原理，特别是在率相关晶体塑性领域。该问题是适定的、客观的，并包含推导唯一且有意义解所需的所有必要信息。该公式是该领域的标准公式，依赖于分解剪应力与滑移率之间的幂律关系，该关系可从凸耗散势推导得出。\n\n晶体塑性的热力学框架假设存在一个耗散势 $\\Psi$，它是滑移率 $\\dot{\\gamma}^\\alpha$ 的凸函数。然后，通过关联流动法则，从该势函数推导出每个滑移系 $\\alpha$ 上的分解剪应力 $\\tau^\\alpha$，确保耗散 $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$ 为非负值。这表示为：\n$$\n\\tau^\\alpha = \\frac{\\partial \\Psi}{\\partial \\dot{\\gamma}^\\alpha}\n$$\n耗散势的一种常用形式是，它能导出指定的幂律粘塑性模型：\n$$\n\\Psi(\\{\\dot{\\gamma}^\\beta\\}; \\{g^\\beta\\}) = \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\n其中 $g^\\beta$ 是滑移系 $\\beta$ 的滑移抗力，$\\dot{\\gamma}_0$ 是参考滑移率，$m$ 是率敏感性参数。所有这些量均在问题陈述中给出。\n\n应用关联流动法则，我们将势函数 $\\Psi$ 对特定的滑移率 $\\dot{\\gamma}^\\alpha$ 求导：\n$$\n\\tau^\\alpha = \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left[ \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1} \\right]\n$$\n由于在势函数中滑移系是解耦的，对于 $\\beta \\neq \\alpha$ 的导数为零。我们得到：\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\n使用链式法则，并注意到 $\\frac{d|x|}{dx} = \\mathrm{sgn}(x)$，我们得到：\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} (m+1) \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m} \\frac{1}{\\dot{\\gamma}_0} \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\n简化此表达式可得出分解剪应力与滑移率之间的关系：\n$$\n\\tau^\\alpha = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\n为确保非负耗散（$\\tau^\\alpha \\dot{\\gamma}^\\alpha \\ge 0$），$\\tau^\\alpha$ 和 $\\dot{\\gamma}^\\alpha$ 的符号必须相同，因此 $\\mathrm{sgn}(\\tau^\\alpha) = \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)$。对两边取绝对值：\n$$\n|\\tau^\\alpha| = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m\n$$\n现在我们可以求解滑移率的大小 $|\\dot{\\gamma}^\\alpha|$：\n$$\n\\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right) = \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\implies \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} = \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\implies |\\dot{\\gamma}^\\alpha| = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m}\n$$\n重新引入符号，我们得到滑移系 $\\alpha$ 上滑移率的最终本构方程：\n$$\n\\dot{\\gamma}^\\alpha = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} \\mathrm{sgn}(\\tau^\\alpha)\n$$\n该方程提供了一种直接计算滑移率 $\\dot{\\gamma}^\\alpha$ 的方法，只需给定分解剪应力 $\\tau^\\alpha$、当前滑移抗力 $g^\\alpha$、参考滑移率 $\\dot{\\gamma}_0$ 以及率敏感性指数 $m$。需要注意的是，如果 $\\tau^\\alpha = 0$，则 $\\dot{\\gamma}^\\alpha = 0$，这在物理上和数学上都是一致的。所有提供的滑移抗力 $g^\\alpha$ 都是严格正数，从而避免了任何除以零的情况。\n\n问题的第二部分要求确定滑移系的激活集。如果同时满足两个条件，则滑移系 $\\alpha$ 被定义为激活的：\n1.  过应力比 $r^\\alpha = \\frac{|\\tau^\\alpha|}{g^\\alpha}$ 必须大于或等于指定的阈值 $r_{\\mathrm{thr}}$。\n2.  滑移率的大小 $|\\dot{\\gamma}^\\alpha|$ 必须大于或等于指定的容差 $\\dot{\\gamma}_{\\mathrm{tol}}$。\n\n因此，每个滑移系的激活标志 $A^\\alpha$ 由逻辑表达式确定：\n$$\nA^\\alpha = (r^\\alpha \\ge r_{\\mathrm{thr}}) \\land (|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}})\n$$\n其中 $\\land$ 代表逻辑与运算符。\n\n每个测试用例的计算过程如下：\n1.  对于从 $1$ 到 $N$ 的每个滑移系 $\\alpha$，其中 $N$ 是给定测试用例中的滑移系数量：\n    a.  获取 $\\tau^\\alpha$、$g^\\alpha$、$m$ 和 $\\dot{\\gamma}_0$ 的值。\n    b.  使用推导的幂律方程计算滑移率 $\\dot{\\gamma}^\\alpha$。\n    c.  计算过应力比 $r^\\alpha = |\\tau^\\alpha| / g^\\alpha$。\n    d.  通过检查 $r^\\alpha \\ge r_{\\mathrm{thr}}$ 和 $|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$ 是否都为 `True` 来评估激活标志 $A^\\alpha$。\n2.  将计算出的滑移率收集到一个列表中 $[\\dot{\\gamma}^1, \\dot{\\gamma}^2, \\ldots, \\dot{\\gamma}^N]$。\n3.  将激活标志收集到一个列表中 $[A^1, A^2, \\ldots, A^N]$。\n4.  将这两个列表组合成测试用例的最终结构：$[[\\dot{\\gamma}^1, \\ldots], [A^1, \\ldots]]$。\n对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes slip rates and active sets for crystal plasticity problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, g, m, gamma0_dot, r_thr, gamma_tol_dot)\n    # Stresses are in MPa, slip rates in s^-1.\n    test_cases = [\n        (\n            np.array([120.0, 80.0, -110.0, 20.0, 0.0, 95.0]),  # tau (MPa)\n            np.array([100.0, 100.0, 100.0, 100.0, 100.0, 100.0]),  # g (MPa)\n            0.05,  # m\n            1e-3,  # gamma0_dot (s^-1)\n            0.98,  # r_thr\n            1e-6   # gamma_tol_dot (s^-1)\n        ),\n        (\n            np.array([100.0, 100.0, -100.0, 50.0, -50.0, 0.0]),\n            np.array([100.0, 120.0, 100.0, 60.0, 50.0, 80.0]),\n            0.2,\n            1e-3,\n            1.0,\n            5e-6\n        ),\n        (\n            np.array([30.0, -45.0, 70.0, -10.0, 5.0, 15.0]),\n            np.array([150.0, 150.0, 200.0, 200.0, 180.0, 160.0]),\n            0.5,\n            1e-2,\n            0.9,\n            1e-4\n        ),\n        (\n            np.array([0.1, -0.2, 0.0, 0.05, -0.05, 0.01]),\n            np.array([100.0, 100.0, 100.0, 120.0, 120.0, 150.0]),\n            0.05,\n            1e-3,\n            0.95,\n            1e-8\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, g, m, gamma0_dot, r_thr, gamma_tol_dot = case\n\n        # Ensure g is not zero to avoid division by zero, though not present in test data.\n        # Create a mask for non-zero g for safe division.\n        g_is_zero = (g == 0)\n        overstress_ratio = np.full_like(tau, 0.0)\n        \n        # Calculate overstress ratio only where g is not zero\n        # Where g is zero, overstress is infinite if tau is non-zero, handled implicitly\n        # since gamma_dot would be infinite. In this problem, all g > 0.\n        overstress_ratio = np.abs(tau) / g\n\n        # Calculate slip rates using the power-law constitutive equation.\n        # np.power(0, positive_number) is 0, correctly handling tau=0.\n        # np.sign(0) is 0, also handled correctly.\n        exponent = 1.0 / m\n        gamma_dot = gamma0_dot * np.power(overstress_ratio, exponent) * np.sign(tau)\n\n        # Determine the active set based on the two conditions.\n        # 1. Overstress ratio threshold\n        # 2. Slip rate magnitude tolerance\n        active_set_flags = (overstress_ratio >= r_thr)  (np.abs(gamma_dot) = gamma_tol_dot)\n\n        # Format results for the current case as required\n        gamma_dot_list = gamma_dot.tolist()\n        active_set_list = active_set_flags.tolist()\n        \n        results.append([gamma_dot_list, active_set_list])\n\n    # Convert the list of results to the required string format.\n    # The default str() representation for lists includes spaces after commas,\n    # which is consistent with the visual spacing in the problem's LaTeX example.\n    result_strings = [str(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```", "id": "3556441"}, {"introduction": "知道了滑移速率是第一步，接下来需要更新累积的塑性变形。在有限应变框架下，这通过塑性变形梯度 $F^p$ 的演化来描述。本练习要求您实现并比较两种常见的流动法则 $\\dot{F}^p = L^p F^p$ 的数值积分方案，从而阐明计算简便性与数值精度之间的权衡，尤其是在大变形步长的情况下。[@problem_id:3556395]", "problem": "考虑有限应变晶体塑性运动学，其中总变形梯度被乘法分解为 $F = F^e F^p$，$F^e$ 是弹性变形梯度，$F^p$ 是塑性变形梯度。塑性流动由常微分方程 (ODE) $\\dot{F}^p = L^p F^p$ 控制，其中 $L^p$ 是塑性速度梯度。对于一组由 $\\alpha$ 索引的晶体滑移系，塑性速度梯度定义为总和 $L^p = \\sum_{\\alpha} \\dot{\\gamma}_\\alpha \\, s_\\alpha \\otimes m_\\alpha$。此处，$s_\\alpha$ 是单位滑移方向矢量，$m_\\alpha$ 是单位滑移面法向矢量，$\\dot{\\gamma}_\\alpha$ 是滑移系 $\\alpha$ 上的滑移速率，$\\otimes$ 表示并矢积。\n\n滑移系的激活由每个滑移系上的分解剪应力驱动，其定义为 $\\tau_\\alpha = s_\\alpha \\cdot \\sigma \\cdot m_\\alpha$，其中 $\\sigma$ 是柯西应力张量（对称），$\\cdot$ 表示适当的张量缩并。使用带阈值的过应力幂律来确定滑移速率：\n$$\n\\dot{\\gamma}_\\alpha = \\gamma_0 \\left( \\frac{\\langle |\\tau_\\alpha| - \\tau_c \\rangle_+}{\\tau_c} \\right)^n \\operatorname{sign}(\\tau_\\alpha),\n$$\n其中 $\\gamma_0$ 是参考滑移速率（单位为 $\\mathrm{s}^{-1}$），$\\tau_c$ 是临界分解剪应力（单位为 $\\mathrm{MPa}$），$n$ 是速率敏感性指数（无量纲），$\\langle x \\rangle_+ = \\max(x,0)$ 是麦考利括号，$\\operatorname{sign}(\\cdot)$ 是符号函数。\n\n从 $F^p_n = I$ 开始，$I$ 是单位张量，为从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的更新实现两种时间积分方案：\n1. 指数映射更新，基于分段常数 $L^p_n$ 下 ODE 的精确解：$F^p_{n+1} = \\exp(\\Delta t \\, L^p_n) F^p_n$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n2. 一阶显式欧拉更新：$F^p_{n+1} \\approx (I + \\Delta t \\, L^p_n) F^p_n$。\n\n您的程序必须：\n- 构建指定的滑移系和应力。\n- 为每个滑移系计算 $\\tau_\\alpha$，使用给定的激活法则确定 $\\dot{\\gamma}_\\alpha$，组装 $L^p$，然后通过指数映射和一阶更新计算 $F^p_{n+1}$。\n- 通过计算弗罗贝尼乌斯范数误差 $e = \\| F^p_{\\text{Euler}} - F^p_{\\text{exp}} \\|_F$ 来量化一阶更新的精度，其中 $\\| \\cdot \\|_F$ 表示弗罗贝尼乌斯范数。此误差无量纲；请以浮点数形式报告。\n\n在面心立方晶体中使用以下两个滑移系：\n- 滑移系 $1$：$m_1 = \\frac{1}{\\sqrt{3}}[1,\\,1,\\,1]$，$s_1 = \\frac{1}{\\sqrt{2}}[0,\\,1,\\,-1]$。\n- 滑移系 $2$：$m_2 = \\frac{1}{\\sqrt{3}}[1,\\,-1,\\,1]$，$s_2 = \\frac{1}{\\sqrt{2}}[1,\\,1,\\,0]$。\n\n令柯西应力为两个剪切分量 $\\sigma_{xy} = A$ 和 $\\sigma_{xz} = B$（单位为 $\\mathrm{MPa}$）的组合，所有其他分量为零，即\n$$\n\\sigma = \\begin{bmatrix}\n0  A  B \\\\\nA  0  0 \\\\\nB  0  0\n\\end{bmatrix}.\n$$\n\n所有测试用例使用以下材料参数：$\\gamma_0 = 0.1$ $\\mathrm{s}^{-1}$，$\\tau_c = 100$ $\\mathrm{MPa}$，$n = 10$（无量纲）。初始塑性变形梯度为 $F^p_n = I$。\n\n测试套件：\n- 情况 $1$（一般情况，小步长）：$A = 750$ $\\mathrm{MPa}$，$B = 450$ $\\mathrm{MPa}$，$\\Delta t = 0.001$ $\\mathrm{s}$。\n- 情况 $2$（大剪切步长）：$A = 750$ $\\mathrm{MPa}$，$B = 450$ $\\mathrm{MPa}$，$\\Delta t = 0.1$ $\\mathrm{s}$。\n- 情况 $3$（单滑移激活边界）：$A = 600$ $\\mathrm{MPa}$，$B = 0$ $\\mathrm{MPa}$，$\\Delta t = 0.05$ $\\mathrm{s}$。\n\n您的程序应生成一行输出，其中包含每个测试用例的弗罗贝尼乌斯范数误差，形式为用方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3]$）。所有输出都必须是浮点数。没有角度量，因此不需要角度单位。所有带单位的量都已指定；请将最终误差报告为无量纲浮点数。", "solution": "该问题要求在有限应变晶体塑性框架内，对塑性变形梯度 $F^p$ 演化的两种数值积分方案进行比较分析。我们被要求计算一阶显式欧拉方案相对于更精确的指数映射更新的误差，后者在分段常数塑性速度梯度的假设下作为参考解。\n\n其运动学基础是总变形梯度 $F$ 分解为弹性和塑性部分的乘法形式：\n$$F = F^e F^p$$\n塑性部分的演化由流动法则控制，这是一个一阶常微分方程：\n$$\\dot{F}^p = L^p F^p$$\n其中 $L^p$ 是塑性速度梯度。对于具有一组由 $\\alpha$ 索引的滑移系的晶体，$L^p$ 被构造为预先已知的晶体学方向上的总和：\n$$L^p = \\sum_{\\alpha} \\dot{\\gamma}_\\alpha \\, s_\\alpha \\otimes m_\\alpha$$\n这里，$\\dot{\\gamma}_\\alpha$ 是标量滑移速率，$s_\\alpha$ 和 $m_\\alpha$ 分别是定义滑移方向和滑移面法向的单位矢量。并矢积 $s_\\alpha \\otimes m_\\alpha$ 通常被称为滑移系 $\\alpha$ 的施密特张量。\n\n塑性滑移的驱动力是分解剪应力 $\\tau_\\alpha$，它表示柯西应力张量 $\\sigma$ 在滑移系上的投影：\n$$\\tau_\\alpha = s_\\alpha \\cdot (\\sigma m_\\alpha) = s_\\alpha^T \\sigma m_\\alpha$$\n滑移速率 $\\dot{\\gamma}_\\alpha$ 由一个唯象本构关系确定。在本问题中，指定了一个具有阈值的速率相关幂律：\n$$\n\\dot{\\gamma}_\\alpha = \\gamma_0 \\left( \\frac{\\langle |\\tau_\\alpha| - \\tau_c \\rangle_+}{\\tau_c} \\right)^n \\operatorname{sign}(\\tau_\\alpha)\n$$\n其中 $\\langle x \\rangle_+ = \\max(x,0)$ 是麦考利括号。此函数表明，只有当分解剪应力的大小 $|\\tau_\\alpha|$ 超过临界值 $\\tau_c$ 时，才会发生滑移。参数 $\\gamma_0$ 和 $n$ 分别控制参考滑移速率和材料的速率敏感性。\n\n该问题要求将塑性变形梯度从时间 $t_n$ 的初始状态 $F^p_n = I$ 更新到时间 $t_{n+1} = t_n + \\Delta t$ 的最终状态 $F^p_{n+1}$。假定应力 $\\sigma$ 和材料参数在此时间步内保持不变，这意味着 $\\tau_\\alpha$、$\\dot{\\gamma}_\\alpha$ 以及因此的 $L^p$ 也都是常数。我们将此常数塑性速度梯度表示为 $L^p_n$。\n\n需要比较的两种积分方案是：\n$1$. 指数映射更新：这是常数 $L^p_n$下 ODE $\\dot{F}^p = L^p_n F^p$ 的精确解。给定 $F^p(t_n) = F^p_n$，在 $t_{n+1}$ 的解为：\n$$F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n) F^p_n$$\n由于初始条件是 $F^p_n = I$，这简化为 $F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n)$。\n\n$2$. 一阶显式欧拉更新：这是指数映射的一阶泰勒近似。\n$$F^p_{n+1, \\text{Euler}} \\approx (I + \\Delta t \\, L^p_n) F^p_n$$\n当 $F^p_n = I$ 时，这变为 $F^p_{n+1, \\text{Euler}} = I + \\Delta t \\, L^p_n$。\n\n欧拉方案的精度由两个结果之间差异的弗罗贝尼乌斯范数来量化：\n$$e = \\| F^p_{n+1, \\text{Euler}} - F^p_{n+1, \\text{exp}} \\|_F$$\n\n每个测试用例的计算过程如下：\n\n$1$. **定义常数和输入：**\n材料参数：$\\gamma_0 = 0.1 \\, \\mathrm{s}^{-1}$，$\\tau_c = 100 \\, \\mathrm{MPa}$，$n = 10$。\n滑移系：\n-   滑移系 $\\alpha = 1$：$m_1 = \\frac{1}{\\sqrt{3}}[1, 1, 1]^T$ 和 $s_1 = \\frac{1}{\\sqrt{2}}[0, 1, -1]^T$。\n-   滑移系 $\\alpha = 2$：$m_2 = \\frac{1}{\\sqrt{3}}[1, -1, 1]^T$ 和 $s_2 = \\frac{1}{\\sqrt{2}}[1, 1, 0]^T$。\n特定于用例的输入：$A$、$B$ 和 $\\Delta t$。\n\n$2$. **构建柯西应力张量 $\\sigma$**：\n$$\n\\sigma = \\begin{bmatrix}\n0  A  B \\\\\nA  0  0 \\\\\nB  0  0\n\\end{bmatrix}\n$$\n所有值均以 $\\mathrm{MPa}$ 为单位。\n\n$3$. **计算分解剪应力 $\\tau_\\alpha$**：\n对于每个滑移系 $\\alpha \\in \\{1, 2\\}$，计算 $\\tau_\\alpha = s_\\alpha^T \\sigma m_\\alpha$。\n\n$4$. **计算滑移速率 $\\dot{\\gamma}_\\alpha$**：\n使用计算出的 $\\tau_\\alpha$ 和给定的幂律，确定 $\\dot{\\gamma}_\\alpha$。如果 $|\\tau_\\alpha| \\le \\tau_c$，则 $\\dot{\\gamma}_\\alpha = 0$。\n\n$5$. **组装塑性速度梯度 $L^p_n$**：\n首先，计算施密特张量 $P_\\alpha = s_\\alpha m_\\alpha^T$。然后，计算总和 $L^p_n = \\sum_{\\alpha=1}^2 \\dot{\\gamma}_\\alpha P_\\alpha$。\n\n$6$. **计算更新后的塑性变形梯度**：\n-   $F^p_{n+1, \\text{exp}} = \\exp(\\Delta t \\, L^p_n)$，使用矩阵指数函数计算。\n-   $F^p_{n+1, \\text{Euler}} = I + \\Delta t \\, L^p_n$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n\n$7$. **计算弗罗贝尼乌斯范数误差 $e$**：\n-   计算差分矩阵 $D = F^p_{n+1, \\text{Euler}} - F^p_{n+1, \\text{exp}}$。\n-   计算误差 $e = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 D_{ij}^2}$。\n\n此过程系统地应用于问题陈述中提供的三个测试用例。误差 $e$ 预计会随着 $\\Delta t \\, L^p_n$ 的量级增加而增长。具体来说，由于欧拉方法是一阶近似，局部截断误差的阶数为 $(\\Delta t)^2$。这意味着对于固定的 $L^p_n$，将 $\\Delta t$ 增加 $100$ 倍（从情况 $1$ 到情况 $2$），误差 $e$ 应该增加大约 $100^2 = 10000$ 倍。情况 $3$ 探讨了单滑移的情景，其中一个滑移系处于非激活状态。应用相同的计算步骤。Python 实现将利用 `numpy` 库进行矢量和矩阵运算，并使用 `scipy.linalg.expm` 进行矩阵指数运算，这是一个用于此目的的稳健算法。最终输出是三个案例计算出的无量纲误差列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the crystal plasticity problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A [MPa], B [MPa], dt [s])\n        (750.0, 450.0, 0.001),  # Case 1\n        (750.0, 450.0, 0.1),    # Case 2\n        (600.0, 0.0, 0.05),     # Case 3\n    ]\n\n    # Material parameters\n    gamma0 = 0.1  # s^-1\n    tau_c = 100.0   # MPa\n    n = 10.0      # dimensionless\n\n    # Slip systems for FCC\n    # System 1\n    m1 = (1.0 / np.sqrt(3.0)) * np.array([1.0, 1.0, 1.0])\n    s1 = (1.0 / np.sqrt(2.0)) * np.array([0.0, 1.0, -1.0])\n    # System 2\n    m2 = (1.0 / np.sqrt(3.0)) * np.array([1.0, -1.0, 1.0])\n    s2 = (1.0 / np.sqrt(2.0)) * np.array([1.0, 1.0, 0.0])\n    \n    slip_systems = [(s1, m1), (s2, m2)]\n\n    results = []\n    for case in test_cases:\n        A, B, dt = case\n\n        # Construct Cauchy stress tensor\n        sigma = np.array([\n            [0.0, A, B],\n            [A, 0.0, 0.0],\n            [B, 0.0, 0.0]\n        ])\n\n        # Initialize plastic velocity gradient\n        Lp = np.zeros((3, 3))\n        \n        # Loop over slip systems to calculate slip rates and assemble Lp\n        for s, m in slip_systems:\n            # Calculate resolved shear stress (tau)\n            # tau = s . (sigma . m)\n            tau = np.dot(s, np.dot(sigma, m))\n            \n            # Calculate slip rate (dgamma) using the overstress power law\n            if abs(tau)  tau_c:\n                # Macaulay bracket is handled by the condition\n                # |tau| - tau_c+ = |tau| - tau_c\n                dgamma = gamma0 * ((abs(tau) - tau_c) / tau_c)**n * np.sign(tau)\n            else:\n                dgamma = 0.0\n\n            # Add contribution to the plastic velocity gradient\n            # Lp += dgamma * (s dyadic m)\n            Lp += dgamma * np.outer(s, m)\n            \n        # Initial plastic deformation gradient is identity\n        # Fp_n = np.identity(3)\n\n        # 1. Exponential map update (exact solution for constant Lp)\n        # Fp_{n+1} = exp(dt * Lp) * Fp_n\n        Fp_exp = expm(dt * Lp)\n\n        # 2. First-order explicit Euler update\n        # Fp_{n+1} = (I + dt * Lp) * Fp_n\n        Fp_euler = np.identity(3) + dt * Lp\n        \n        # Quantify error using Frobenius norm\n        error = np.linalg.norm(Fp_euler - Fp_exp, 'fro')\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3556395"}, {"introduction": "一个完备的有限应变晶体塑性理论建立在能够正确描述晶体学特征如何随变形演化的严谨运动学框架之上。本实践将深入探讨这些基本的运动学原理，指导您实现滑移系的推前 (push-forward) 和拉回 (pull-back) 操作。然后，您将利用此框架来数值验证客观性原理（principle of objectivity），这是确保模型物理预测与观察者的刚体运动无关的一块基石。[@problem_id:3556393]", "problem": "实现一个程序，针对有限应变晶体塑性运动学，在参考构型、中间构型和当前构型之间执行滑移系的前推和拉回操作，并验证在叠加刚体转动下分解剪切应力激活准则的标架无关性（客观性）。所有量均为无量纲。仅使用下面列举的数学基础，并且不要假设超出这些基础的任何快捷公式。\n\n基本定义和事实：\n- 令总变形梯度为 $F \\in \\mathbb{R}^{3 \\times 3}$，其乘法分解为 $F = F^e F^p$，其中 $F^e$ 是弹性部分，$F^p$ 是塑性部分。\n- 矢量通过 $A$ 前推为 $v \\mapsto A v$。余矢量（如平面法线）通过 $A^{-T}$ 前推为 $n \\mapsto A^{-T} n$。这些法则在以下意义上保持对偶性：$n \\cdot v$ 在相应的配对变换下保持不变。\n- $F^e$ 的右极分解存在且给定为 $F^e = R^e U^e$，其中 $R^e \\in \\mathrm{SO}(3)$ 是一个真正交转动，$U^e$ 是一个对称正定伸长张量。转动为 $R^e = F^e (U^e)^{-1}$，$U^e$ 是 $C^e = (F^e)^T F^e$ 唯一的正定平方根。\n- 对于可压缩 Neo-Hookean 弹性响应，Kirchhoff 应力为 $\\tau = \\mu (B^e - I) + \\kappa \\ln J \\, I$，其中 $B^e = F^e (F^e)^T$，$J = \\det(F^e)$，$I$ 是单位矩阵，$\\mu$ 是剪切模量，$\\kappa$ 是体积模量。Cauchy 应力为 $\\sigma = \\tau / J$。\n- 对于当前构型中滑移方向为 $s$、滑移面法线为 $m$ 的滑移系，其 Schmid 张量为 $P = \\tfrac{1}{2} (s \\otimes m + m \\otimes s)$。对于对称的 Cauchy 应力 $\\sigma$，分解剪切应力等于 $\\tau_{\\mathrm{rss}} = \\sigma : P = s \\cdot (\\sigma m)$。\n\n需要实现的任务：\n1. 将滑移系 $(s_0, m_0)$ 从参考构型通过 $F^p$ 前推映射到中间构型，将 $s_0$ 视为矢量，$m_0$ 视为余矢量，然后将两者归一化，再通过 $R^e$ 旋转到当前构型。具体来说，分别计算在 $F^p$ 和 $(F^p)^{-T}$ 作用下的归一化像，作为中间滑移方向和法线，然后通过与 $R^e$ 的旋转计算当前滑移方向和法线。确保在当前构型中强制满足正交性 $s \\cdot m = 0$ 和单位范数。\n2. 将滑移系 $(s, m)$ 从当前构型拉回映射到参考构型，首先撤销旋转 $R^e$，然后恰当地使用 $F^p$ 的逆（矢量通过 $(F^p)^{-1}$ 拉回，余矢量通过 $(F^p)^T$ 拉回），并在每个阶段进行歸一化。验证从参考构型到当前构型再返回的往返过程能够恢复原始方向（最多可能相差一个符号），这不应影响物理滑移系。\n3. 使用可压缩 Neo-Hookean 模型，根据给定的 $F^e$ 和 $(\\mu, \\kappa)$ 计算 Cauchy 应力 $\\sigma$，然后计算当前构型中每个滑移系的分解剪切应力 $\\tau_{\\mathrm{rss}}$。\n4. 验证客观性：在当前构型上叠加一个刚体转动 $Q \\in \\mathrm{SO}(3)$，这会使 $F^e$ 变为 $F^{e\\star} = Q F^e$。在此条件下，重新计算当前滑移系和 Cauchy 应力，并评估分解剪切应力 $\\tau_{\\mathrm{rss}}^\\star$。数值上证明 $\\tau_{\\mathrm{rss}}^\\star = \\tau_{\\mathrm{rss}}$ 在指定容差范围内。\n\n测试套件和参数：\n- 使用以下三个测试用例。对于每个用例，使用给定的 $F^p$、$F^e$、参考滑移系 $(s_0, m_0)$、刚体转动 $Q$ 和弹性参数 $(\\mu, \\kappa)$。所有矩阵和矢量都必须严格按照规定使用。\n\n用例 A:\n- $F^p = \\begin{bmatrix} 1  0.3  0 \\\\ 0  1  0.2 \\\\ 0  0  1 \\end{bmatrix}$，$F^e = \\begin{bmatrix} 1.1  0.2  0 \\\\ 0  0.9  0.1 \\\\ 0  0  1.05 \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\right)$。\n- $Q = \\begin{bmatrix} 0.5  -0.8660254037844386  0 \\\\ 0.8660254037844386  0.5  0 \\\\ 0  0  1 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n用例 B:\n- $F^p = \\mathrm{diag}(0.9, 1.3, 0.8547008547008547)$，$F^e = \\begin{bmatrix} 1  0  0 \\\\ 0  \\tfrac{\\sqrt{2}}{2}  -\\tfrac{\\sqrt{2}}{2} \\\\ 0  \\tfrac{\\sqrt{2}}{2}  \\tfrac{\\sqrt{2}}{2} \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\right)$。\n- $Q = I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n用例 C:\n- $F^p = \\mathrm{diag}(1.2, 0.9, 0.9259259259)$，$F^e = \\begin{bmatrix} 1  0.15  0 \\\\ 0  1  0.2 \\\\ 0.05  0  1 \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\dfrac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix} \\right)$。\n- $Q = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n每个用例需要计算和验证的内容：\n- 通过前推计算当前滑移系 $(s, m)$，并通过从 $(s, m)$ 拉回恢复参考滑移系 $(\\tilde{s}_0, \\tilde{m}_0)$。在每一步都强制归一化。数值上验证 $(s, m)$ 的正交性和单位范数，并通过检查 $\\left| \\tilde{s}_0 \\cdot s_0 \\right|$ 和 $\\left| \\tilde{m}_0 \\cdot m_0 \\right|$ 是否接近于 $1$ 来验证 $(s_0, m_0)$ 的往返恢复（允许符号差异）。\n- 根据 $F^e$ 和 $(\\mu, \\kappa)$ 计算 $\\sigma$ 和分解剪切应力 $\\tau_{\\mathrm{rss}}$。然后，使用 $F^{e\\star} = Q F^e$ 重新计算 $\\sigma^\\star$ 和 $\\tau_{\\mathrm{rss}}^\\star$。通过检查 $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right|$ 是否在容差范围内来验证客观性。\n\n数值容差和通过标准：\n- 正交性和单位范数检查使用容差 $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$，方向的往返检查使用容差 $\\varepsilon_{\\mathrm{round}} = 10^{-10}$，分解剪切应力的客观性检查使用容差 $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$。\n- 一个用例当且仅当所有三个条件都满足时才算通过：(i) $\\left| s \\cdot m \\right| \\le \\varepsilon_{\\mathrm{orth}}$ 且 $\\left| \\lVert s \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$ 且 $\\left| \\lVert m \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$；(ii) $\\left| \\tilde{s}_0 \\cdot s_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ 且 $\\left| \\tilde{m}_0 \\cdot m_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$；(iii) $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right| \\le \\varepsilon_{\\mathrm{obj}}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用例 A、B 和 C 的通过或失败结果，格式为一个用方括号括起来的逗号分隔列表（例如，$\\left[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True} \\right]$ 应打印为“[True,False,True]”）。", "solution": "该问题是有效的，因为它科学地基于连续介质力学和晶体塑性原理，问题陈述良定，提供了所有必要信息，并且以客观、正式的方式表述。任务涉及实现计算固体力学中常见的标准（尽管具体）的运动学变换和本构关系。我们通过执行所需的步骤来解决该问题。\n\n根据问题描述，对每个测试用例的分析分为四个主要部分：(1) 将滑移系从参考构型到当前构型的前推映射，(2) 验证运动学往返过程的拉回映射，(3) 应力和分解剪切应力的计算，以及 (4) 在叠加刚体转动下验证分解剪切應力的标架无关性（客观性）。\n\n**1. 滑移系的运动学前推**\n\n晶体塑性运动学关联三个构型：参考（或未变形）构型 $\\mathcal{B}_0$、当前（或变形）构型 $\\mathcal{B}$ 和一个概念性的中间构型 $\\mathcal{B}_p$。总变形梯度 $F$ 被乘法分解为 $F = F^e F^p$，其中 $F^p$ 从 $\\mathcal{B}_0$ 映射到 $\\mathcal{B}_p$，$F^e$ 从 $\\mathcal{B}_p$ 映射到 $\\mathcal{B}$。\n\n一个滑移系由一个滑移方向矢量和一个滑移面法向余矢量定义。在参考构型中，它们表示为 $(s_0, m_0)$，给定为正交单位矢量。\n\n从 $\\mathcal{B}_0$到 $\\mathcal{B}_p$ 的前推由 $F^p$ 控制。矢量变换为 $v \\mapsto F^p v$，余矢量（法线）变换为 $n \\mapsto (F^p)^{-T} n$。该变换法则确保矢量和余矢量在其未归一化的像之间的点积（对偶配对）得以保持，即 $((F^p)^{-T} m_0) \\cdot (F^p s_0) = m_0 \\cdot s_0$。中间构型中的滑移系 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 通过归一化这些变换后的矢量获得：\n$$s_{\\mathrm{int}} = \\frac{F^p s_0}{\\|F^p s_0\\|}, \\quad m_{\\mathrm{int}} = \\frac{(F^p)^{-T} m_0}{\\| (F^p)^{-T} m_0 \\|}$$\n由于 $s_0 \\cdot m_0 = 0$，因此有 $s_{\\mathrm{int}} \\cdot m_{\\mathrm{int}} = 0$。\n\n从 $\\mathcal{B}_p$ 到 $\\mathcal{B}$ 的映射由弹性变形梯度 $F^e$ 控制。问题为此步骤指定了一个特定的运动学假设。首先，通过右极分解将 $F^e$ 分解为一个真正交转动 $R^e \\in \\mathrm{SO}(3)$ 和一个对称正定右伸长张量 $U^e$，使得 $F^e = R^e U^e$。伸长张量 $U^e$ 被计算为右 Cauchy-Green 张量 $C^e = (F^e)^T F^e$ 的唯一正定平方根。然后转动通过 $R^e = F^e (U^e)^{-1}$ 求得。\n\n问题指出，中间构型中的滑移系矢量通过与 $R^e$ 的旋转映射到当前构型。这意味着滑移系被认为嵌入到一个只发生弹性旋转而未拉伸的晶格中。\n$$s = R^e s_{\\mathrm{int}}, \\quad m = R^e m_{\\mathrm{int}}$$\n由于 $R^e$ 是一个转动且 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 是标准正交的，因此得到的当前滑移系 $(s, m)$ 也将由标准正交矢量组成。这一点会根据容差 $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$ 进行数值验证。\n\n**2. 拉回运动学和往返验证**\n\n为了验证运动学映射的一致性，执行从当前构型返回到参考构型的往返过程。此拉回操作是前推的逆操作。\n\n从当前滑移系 $(s, m)$ 开始，我们首先通过撤销旋转 $R^e$ 将其拉回到中间构型：\n$$s_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} s = (R^e)^T s, \\quad m_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} m = (R^e)^T m$$\n接下来，我们从 $\\mathcal{B}_p$ 拉回到 $\\mathcal{B}_0$。矢量通过 $(F^p)^{-1}$ 拉回，余矢量通过 $(F^p)^T$ 拉回。未归一化的参考矢量是：\n$$s_0' = (F^p)^{-1} s_{\\mathrm{int}}^{\\mathrm{rec}}, \\quad m_0' = (F^p)^T m_{\\mathrm{int}}^{\\mathrm{rec}}$$\n最后，我们归一化这些矢量以获得恢复的参考滑移系 $(\\tilde{s}_0, \\tilde{m}_0)$：\n$$\\tilde{s}_0 = \\frac{s_0'}{\\|s_0'\\|}, \\quad \\tilde{m}_0 = \\frac{m_0'}{\\|m_0'\\|}$$\n如果恢复的滑移系 $(\\tilde{s}_0, \\tilde{m}_0)$ 与原始滑移系 $(s_0, m_0)$ 等效，则认为往返过程成功。由于滑移系的物理意义与其方向或法线矢量的符号无关，我们通过检查它们各自的点积绝对值是否接近于 $1$ 来验证成功：$|\\tilde{s}_0 \\cdot s_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ 且 $|\\tilde{m}_0 \\cdot m_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$，其中 $\\varepsilon_{\\mathrm{round}} = 10^{-10}$。\n\n**3. 应力与分解剪切应力计算**\n\n滑移的驱动力是分解剪切应力 $\\tau_{\\mathrm{rss}}$，它取决于 Cauchy 应力 $\\sigma$ 和当前滑移系 $(s, m)$。问题指定了一个可压缩 Neo-Hookean 材料模型。首先根据弹性变形计算 Kirchhoff 应力 $\\tau$。其公式为：\n$$\\tau = \\mu (B^e - I) + \\kappa \\ln(J) I$$\n其中 $B^e = F^e (F^e)^T$ 是弹性变形的左 Cauchy-Green（或 Finger）张量，$J = \\det(F^e)$ 是弹性体积变化，$I$ 是 $3 \\times 3$ 单位矩阵，$(\\mu, \\kappa)$ 是剪切和体积模量。\n\nCauchy 应力 $\\sigma$ 与 Kirchhoff 应力 $\\tau$ 的关系为 $\\sigma = \\tau / J$。\n\n滑移系 $(s, m)$ 的分解剪切应力 $\\tau_{\\mathrm{rss}}$ 是滑移面上的牵引力 $(\\sigma m)$ 在滑移方向 $s$ 上的投影：\n$$\\tau_{\\mathrm{rss}} = s \\cdot (\\sigma m)$$\n对于对称的 Cauchy 应力，这等效于双点积 $\\sigma : P$，其中 $P = \\frac{1}{2}(s \\otimes m + m \\otimes s)$ 是 Schmid 张量。\n\n**4. 客观性验证**\n\n连续介质力学的一个基本原理是标架无关性或客观性，它要求材料响应与观察者无关（即与叠加的刚体运动无关）。我们针对分解剪切应力验证这一原理。\n\n一个刚体转动被施加到当前构型上，由一个真正交矩阵 $Q \\in \\mathrm{SO}(3)$ 表示。这将弹性变形梯度转换为 $F^{e\\star} = Q F^e$。所有其他量都必须基于这个新的变形重新计算。\n\n新的极分解为 $F^{e\\star} = R^{e\\star} U^{e\\star}$。我们发现 $U^{e\\star} = U^e$ 且 $R^{e\\star} = Q R^e$。中间构型及其滑移系 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 不受影响，因为它们仅依赖于 $F^p$。新的当前滑移系为：\n$$s^\\star = R^{e\\star} s_{\\mathrm{int}} = (Q R^e) s_{\\mathrm{int}} = Q s, \\quad m^\\star = R^{e\\star} m_{\\mathrm{int}} = (Q R^e) m_{\\mathrm{int}} = Q m$$\n新的应力张量 $\\sigma^\\star$ 根据 $F^{e\\star}$ 计算。变换后的左 Cauchy-Green 张量为 $B^{e\\star} = Q B^e Q^T$，行列式不变，$J^\\star = J$。得到的 Kirchhoff 和 Cauchy 应力作为客观二阶张量进行变换：\n$$\\tau^\\star = Q \\tau Q^T, \\quad \\sigma^\\star = Q \\sigma Q^T$$\n新的分解剪切应力 $\\tau_{\\mathrm{rss}}^\\star$ 为：\n$$\\tau_{\\mathrm{rss}}^\\star = s^\\star \\cdot (\\sigma^\\star m^\\star) = (Qs) \\cdot ((Q \\sigma Q^T) (Qm)) = s^T Q^T Q \\sigma Q^T Q m = s^T \\sigma m = \\tau_{\\mathrm{rss}}$$\n分解剪切应力必须是不变的。我们通过检查 $|\\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}}| \\le \\varepsilon_{\\mathrm{obj}}$（其中 $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$）来数值验证此计算。一个用例当且仅当所有三个验证标准（标准正交性、往返和客观性）都满足时才算通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv, det, sqrtm\n\ndef solve():\n    \"\"\"\n    Main function to run the crystal plasticity kinematics validation\n    for all specified test cases.\n    \"\"\"\n\n    class CrystalPlasticityKinematics:\n        \"\"\"\n        A class to encapsulate the computations and state for a single\n        crystal plasticity test case.\n        \"\"\"\n\n        def __init__(self, Fp, Fe, s0, m0, Q, mu_kappa):\n            \"\"\"\n            Initializes the state with the given parameters for one test case.\n            \"\"\"\n            self.Fp = np.asarray(Fp, dtype=float)\n            self.Fe = np.asarray(Fe, dtype=float)\n            self.s0 = np.asarray(s0, dtype=float) / np.linalg.norm(s0)\n            self.m0 = np.asarray(m0, dtype=float) / np.linalg.norm(m0)\n            self.Q = np.asarray(Q, dtype=float)\n            self.mu, self.kappa = mu_kappa\n\n            # Intermediate and current quantities to be computed\n            self.s_int, self.m_int = None, None\n            self.Re, self.Ue = None, None\n            self.s, self.m = None, None\n            self.sigma, self.tau_rss = None, None\n            self.s_star, self.m_star = None, None\n            self.sigma_star, self.tau_rss_star = None, None\n            \n            # Recovered quantities\n            self.s0_tilde, self.m0_tilde = None, None\n\n        def _perform_polar_decomposition(self, F):\n            \"\"\"Computes the right polar decomposition F = R U.\"\"\"\n            C = F.T @ F\n            U = sqrtm(C)\n            # Ensure U is real, although it should be for positive semi-definite C\n            if np.iscomplexobj(U): U = U.real\n            R = F @ inv(U)\n            return R, U\n\n        def _perform_push_forward(self):\n            \"\"\"Task 1: Pushes the slip system from reference to current config.\"\"\"\n            # Map from reference to intermediate configuration\n            Fp_inv_T = inv(self.Fp).T\n            s_int_prime = self.Fp @ self.s0\n            m_int_prime = Fp_inv_T @ self.m0\n            \n            self.s_int = s_int_prime / np.linalg.norm(s_int_prime)\n            self.m_int = m_int_prime / np.linalg.norm(m_int_prime)\n\n            # Polar decomposition of elastic deformation\n            self.Re, self.Ue = self._perform_polar_decomposition(self.Fe)\n\n            # Map from intermediate to current configuration\n            self.s = self.Re @ self.s_int\n            self.m = self.Re @ self.m_int\n\n        def _perform_pull_back(self):\n            \"\"\"Task 2: Pulls the slip system from current back to reference.\"\"\"\n            # From current to intermediate\n            s_int_rec = self.Re.T @ self.s\n            m_int_rec = self.Re.T @ self.m\n            \n            # From intermediate to reference\n            s0_prime_rec = inv(self.Fp) @ s_int_rec\n            m0_prime_rec = self.Fp.T @ m_int_rec\n            \n            self.s0_tilde = s0_prime_rec / np.linalg.norm(s0_prime_rec)\n            self.m0_tilde = m0_prime_rec / np.linalg.norm(m0_prime_rec)\n\n        def _compute_stress_and_rss(self, F, s, m):\n            \"\"\"Task 3: Computes stress and resolved shear stress.\"\"\"\n            J = det(F)\n            if J = 0: raise ValueError(\"Non-positive determinant.\")\n            Be = F @ F.T\n            I = np.identity(3)\n            tau = self.mu * (Be - I) + self.kappa * np.log(J) * I\n            sigma = tau / J\n            tau_rss = s.dot(sigma @ m)\n            return sigma, tau_rss\n\n        def _compute_rotated_quantities(self):\n            \"\"\"Task 4: Re-computes quantities under superposed rotation.\"\"\"\n            # New elastic deformation gradient\n            Fe_star = self.Q @ self.Fe\n            \n            # New polar decomposition and current slip system\n            Re_star, _ = self._perform_polar_decomposition(Fe_star)\n            self.s_star = Re_star @ self.s_int\n            self.m_star = Re_star @ self.m_int\n\n            # New stress and RSS\n            self.sigma_star, self.tau_rss_star = self._compute_stress_and_rss(\n                Fe_star, self.s_star, self.m_star\n            )\n\n        def run_verifications(self, tolerances):\n            \"\"\"\n            Executes all computational tasks and performs verifications.\n            Returns True if all checks pass, False otherwise.\n            \"\"\"\n            eps_orth, eps_round, eps_obj = tolerances\n\n            # Perform all computations\n            self._perform_push_forward()\n            self._perform_pull_back()\n            self.sigma, self.tau_rss = self._compute_stress_and_rss(self.Fe, self.s, self.m)\n            self._compute_rotated_quantities()\n\n            # Verification (i): Orthonormality in current configuration\n            pass_ortho = (abs(self.s.dot(self.m)) = eps_orth and\n                          abs(np.linalg.norm(self.s) - 1) = eps_orth and\n                          abs(np.linalg.norm(self.m) - 1) = eps_orth)\n\n            # Verification (ii): Round-trip recovery\n            pass_round_trip = (abs(self.s0_tilde.dot(self.s0)) = 1 - eps_round and\n                               abs(self.m0_tilde.dot(self.m0)) = 1 - eps_round)\n\n            # Verification (iii): Objectivity of resolved shear stress\n            pass_objectivity = abs(self.tau_rss_star - self.tau_rss) = eps_obj\n\n            return pass_ortho and pass_round_trip and pass_objectivity\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (np.array([[1, 0.3, 0], [0, 1, 0.2], [0, 0, 1]]),\n         np.array([[1.1, 0.2, 0], [0, 0.9, 0.1], [0, 0, 1.05]]),\n         np.array([1, 0, 0]),\n         np.array([0, 1, 0]),\n         np.array([[0.5, -0.8660254037844386, 0], [0.8660254037844386, 0.5, 0], [0, 0, 1]]),\n         (50, 100)),\n        # Case B\n        (np.diag([0.9, 1.3, 0.8547008547008547]),\n         np.array([[1, 0, 0], [0, np.sqrt(2)/2, -np.sqrt(2)/2], [0, np.sqrt(2)/2, np.sqrt(2)/2]]),\n         np.array([0, 1, 0]),\n         np.array([1, 0, 0]),\n         np.identity(3),\n         (50, 100)),\n        # Case C\n        (np.diag([1.2, 0.9, 0.9259259259]),\n         np.array([[1, 0.15, 0], [0, 1, 0.2], [0.05, 0, 1]]),\n         np.array([1/np.sqrt(2), 1/np.sqrt(2), 0]),\n         np.array([0, 0, 1]),\n         np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]),\n         (50, 100))\n    ]\n\n    tolerances = (1e-12, 1e-10, 1e-10) # (eps_orth, eps_round, eps_obj)\n    results = []\n\n    for case_params in test_cases:\n        Fp, Fe, s0, m0, Q, mu_kappa = case_params\n        \n        try:\n            case_runner = CrystalPlasticityKinematics(Fp, Fe, s0, m0, Q, mu_kappa)\n            result = case_runner.run_verifications(tolerances)\n            results.append(result)\n        except (np.linalg.LinAlgError, ValueError) as e:\n            # In case of singular matrices or other numerical issues\n            print(f\"Error processing a case: {e}\")\n            results.append(False)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3556393"}]}