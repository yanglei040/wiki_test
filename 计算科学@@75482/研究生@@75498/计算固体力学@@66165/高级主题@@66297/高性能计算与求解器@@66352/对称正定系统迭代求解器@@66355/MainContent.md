## 引言
在计算科学与工程的广阔领域中，求解形如 $A x = b$ 的大规模线性方程组是一项无处不在的核心计算任务。特别是在固体力学、热传导和许多其他物理问题的有限元分析中，系数矩阵 $A$ 往往呈现出对称正定 (Symmetric Positive Definite, SPD) 的优良性质。然而，随着模型规模和复杂度的急剧增长，传统的高斯消元等直接法因其高昂的计算和存储成本而变得不切实际。这使得[迭代求解器](@entry_id:136910)成为必然选择，但一个核心挑战随之而来：如何高效、稳健地求解由精细网格或复杂物理导致的严重[病态系统](@entry_id:137611)，因为基础的迭代方法在此类问题上收敛极其缓慢甚至失败。

本文旨在系统性地解决这一知识缺口，为读者构建一个关于现代SPD系统迭代求解器的完整知识框架。我们将从第一性原理出发，逐步深入。在“原理与机制”一章中，您将掌握将线性系统求解转化为[优化问题](@entry_id:266749)的思想，并理解[共轭梯度法](@entry_id:143436)相较于最速下降法的革命性优势，以及预条件技术为何是加速收敛的关键。接着，在“应用与跨学科连接”一章中，我们将展示这些算法如何在[偏微分方程](@entry_id:141332)求解、高性能计算、机器学习等前沿领域中发挥作用。最后，通过“动手实践”环节，您将有机会亲手实现并验证这些强大的数值工具。让我们首先深入这些方法的数学核心，探索其精妙的原理与机制。

## 原理与机制

在[计算力学](@entry_id:174464)中，由有限元法等[离散化方法](@entry_id:272547)产生的线性方程组 $A x = b$ 的求解是核心计算任务之一。当问题涉及线弹性、热传导等物理现象时，[系数矩阵](@entry_id:151473) $A$ 通常是**对称正定 (Symmetric Positive Definite, SPD)** 的。本章将深入探讨专为求解此类SPD系统而设计的迭代方法的原理与机制，从最基础的思想到先进的预条件技术，再到实际应用中的关键考量。

### 将线性系统求解转化为[优化问题](@entry_id:266749)

对于一个SPD矩阵 $A$，[求解线性系统](@entry_id:146035) $A x = b$ 的问题，可以等价地视为寻找一个二次能量泛函 $\Pi(x)$ 的最小值点。这个泛函在力学中通常具有明确的物理意义，例如在弹性力学中代表系统的总[势能](@entry_id:748988)。其数学形式为：

$$
\Pi(x) = \frac{1}{2} x^{\mathsf{T}} A x - b^{\mathsf{T}} x
$$

我们可以通过考察该泛函的梯度来验证这一等价性。泛函 $\Pi(x)$ 对向量 $x$ 的梯度为：

$$
\nabla \Pi(x) = A x - b
$$

在泛函的极小值点，其梯度必须为零，即 $\nabla \Pi(x) = 0$，这直接导出了我们希望求解的原始线性方程组 $A x = b$。由于矩阵 $A$ 是SPD的，其Hessian矩阵（即 $A$ 本身）是正定的，这保证了 $\Pi(x)$ 存在唯一的[全局最小值](@entry_id:165977)点。

这种将线性代数问题转化为[多变量函数](@entry_id:145643)[优化问题](@entry_id:266749)的视角，为迭代求解提供了理论基础。所有基于梯度的迭代方法，其本质都是从一个初始猜测值 $x_0$ 出发，沿着一系列精心选择的方向，逐步逼近能量泛函 $\Pi(x)$ 的最低点，也就是[方程组](@entry_id:193238)的精确解 $x^{\star}$。

### [最速下降法](@entry_id:140448)：一个基础的起点

最直观的[下降方向](@entry_id:637058)是什么？自然是函数值下降最快的方向，也就是负梯度方向。**[最速下降法](@entry_id:140448) (Steepest Descent Method)** 正是基于这一简单思想。从一个初始点 $x_k$ 开始，我们沿着该点的负梯度方向进行移动，以期找到下一个近似解 $x_{k+1}$。

$$
x_{k+1} = x_k + \alpha_k p_k
$$

在这里，搜索方向 $p_k$ 被取为 $x_k$ 处的负梯度方向：

$$
p_k = - \nabla \Pi(x_k) = b - A x_k
$$

这个方向 $p_k$ 正是当前近似解 $x_k$ 所对应的**残差 (residual)**，记为 $r_k$。残差的大小直观地反映了当前解距离精确解的“远近”。

接下来的关键问题是：沿着这个方向应该走多远？步长 $\alpha_k$ 的选择至关重要。一个理想的步长应该使新的近似解 $x_{k+1}$ 对应的[能量泛函](@entry_id:170311) $\Pi(x_{k+1})$ 最小化。这被称为**[精确线搜索](@entry_id:170557) (exact line search)**。我们可以通过最小化关于 $\alpha$ 的一元函数 $\phi(\alpha) = \Pi(x_k + \alpha r_k)$ 来推导[最优步长](@entry_id:143372)。如 [@problem_id:3576560] 中所示，通过对 $\phi(\alpha)$ 求导并令其为零，可以得到[最优步长](@entry_id:143372)的表达式：

$$
\alpha_k = \frac{r_k^{\mathsf{T}} r_k}{r_k^{\mathsf{T}} A r_k}
$$

最速下降法非常简单且易于实现，但它的收敛性能往往不尽如人意。对于**病态 (ill-conditioned)** 系统（即矩阵 $A$ 的最大[特征值](@entry_id:154894)与[最小特征值](@entry_id:177333)之比，即条件数，非常大），能量泛函的[等值面](@entry_id:196027)会呈现出狭长的椭球形状。在这种情况下，负梯度方向几乎总是指向椭球的长轴方向，而不是直接指向中心（[最小值点](@entry_id:634980)）。这导致算法的收敛路径呈现出效率低下的“之”字形（zigzagging），需要大量迭代才能达到满意的精度。这一缺陷促使研究者们寻求更高效的搜索方向，从而引出了共轭梯度法。

### [共轭梯度法](@entry_id:143436)：A-正交方向的核心思想

[最速下降法](@entry_id:140448)的主要问题在于，每一步的优化都是“局部最优”的，新的搜索方向（残差）通常会破坏前一步已经达成的优化效果。例如，在第 $k$ 步沿 $p_k$ 方向优化后，在第 $k+1$ 步沿 $p_{k+1}$ 方向的移动可能会引入一个分量，使得解在 $p_k$ 方向上不再是最优的。

**[共轭梯度法](@entry_id:143436) (Conjugate Gradient, CG)** 的核心思想是通过构造一组“共轭”的搜索方向来克服这一缺陷。对于一个SPD矩阵 $A$，如果一组非[零向量](@entry_id:156189) $\\{p_0, p_1, \dots, p_{n-1}\\}$ 满足：

$$
p_i^{\mathsf{T}} A p_j = 0, \quad \forall i \ne j
$$

则称这组向量是 **A-正交 (A-orthogonal)** 或 **[A-共轭](@entry_id:746179) (A-conjugate)** 的。[A-正交性](@entry_id:139219)是一个关键性质，它保证了在沿新方向 $p_k$ 进行[线搜索](@entry_id:141607)最小化时，不会破坏在先前所有方向 $\\{p_0, \dots, p_{k-1}\\}$ 上已经达成的最优性。这意味着，如果在第 $k$ 步之后，误差已经与 $\text{span}\\{p_0, \dots, p_k\\}$ 中的所有向量 A-正交，那么经过 $n$ 次迭代后，算法将在整个空间 $\mathbb{R}^n$ 中找到精确解（在精确算术下）。

CG方法通过一个巧妙的[递推关系式](@entry_id:274285)来生成这样一组 A-正交的搜索方向，同时保持残差的相互正交 ($r_i^{\mathsf{T}} r_j=0, \forall i \ne j$)。其标准算法流程如下：

1. 初始化：$x_0$, $r_0 = b - A x_0$, $p_0 = r_0$
2. 迭代 $k = 0, 1, 2, \dots$ 直至收敛：
   * 计算步长：$\alpha_k = \frac{r_k^{\mathsf{T}} r_k}{p_k^{\mathsf{T}} A p_k}$
   * 更新解：$x_{k+1} = x_k + \alpha_k p_k$
   * 更新残差：$r_{k+1} = r_k - \alpha_k A p_k$
   * 计算系数：$\beta_k = \frac{r_{k+1}^{\mathsf{T}} r_{k+1}}{r_k^{\mathsf{T}} r_k}$
   * 更新搜索方向：$p_{k+1} = r_{k+1} + \beta_k p_k$

与[最速下降法](@entry_id:140448)相比，CG方法在每一步仅增加了一些[向量加法](@entry_id:155045)和数乘操作，但其收敛性能却得到了质的飞跃。

### 理解共轭梯度法的收敛性

CG方法的卓越性能源于其深刻的数学内涵。在第 $k$ 次迭代时，CG方法在由初始残差及其与矩阵 $A$ 的乘积所张成的**克里洛夫[子空间](@entry_id:150286) (Krylov subspace)** 中寻找最优解：

$$
\mathcal{K}_k(A, r_0) = \text{span}\\{r_0, A r_0, A^2 r_0, \dots, A^{k-1} r_0\\}
$$

CG方法找到的近似解 $x_k$ 是在仿射[子空间](@entry_id:150286) $x_0 + \mathcal{K}_k(A, r_0)$ 中，使**[能量范数](@entry_id:274966)** $\|e_k\|_A = \sqrt{e_k^{\mathsf{T}} A e_k}$ 最小的那个解，其中 $e_k = x^{\star} - x_k$ 是误差。

这等价于一个[多项式逼近](@entry_id:137391)问题 [@problem_id:3576553]。误差向量可以表示为 $e_k = P_k(A) e_0$，其中 $P_k$ 是一个最高次数为 $k$ 的多项式，且满足 $P_k(0)=1$。CG方法隐式地找到了那个使得某种范数 $\|P_k(A)e_0\|_A$ 最小的多项式。这可以进一步导出经典的收敛性[上界](@entry_id:274738)：

$$
\frac{\|e_k\|_A}{\|e_0\|_A} \le 2 \left( \frac{\sqrt{\kappa(A)}-1}{\sqrt{\kappa(A)}+1} \right)^k
$$

其中 $\kappa(A) = \lambda_{\max}(A) / \lambda_{\min}(A)$ 是矩阵 $A$ 的谱条件数。这个不等式清晰地表明，CG的收敛速度主要由条件数 $\kappa(A)$ 控制。[条件数](@entry_id:145150)越接近1，收敛越快；[条件数](@entry_id:145150)越大，收敛越慢。

### [超线性收敛](@entry_id:141654)：[Ritz值](@entry_id:145862)与[特征值聚类](@entry_id:175991)的角色

上述收敛界给出了一个“最坏情况”的[线性收敛](@entry_id:163614)速率。然而在实践中，CG的[收敛速度](@entry_id:636873)往往会随着迭代的进行而加快，这种现象被称为**[超线性收敛](@entry_id:141654) (superlinear convergence)**。其背后的机制与CG和**[Lanczos过程](@entry_id:751124)**的内在联系有关 [@problem_id:3576508]。

CG的迭代过程可以看作是隐式地执行了[Lanczos算法](@entry_id:148448)，该算法为矩阵 $A$ 在克里洛夫[子空间](@entry_id:150286) $\mathcal{K}_k(A, r_0)$ 上的投影构建了一个[正交基](@entry_id:264024)。这个[投影矩阵](@entry_id:154479) $T_k$ 是一个 $k \times k$ 的三对角矩阵，其[特征值](@entry_id:154894)被称为**[Ritz值](@entry_id:145862)** ($\theta_i^{(k)}$)。这些[Ritz值](@entry_id:145862)是原矩阵 $A$ 的真实[特征值](@entry_id:154894)在[子空间](@entry_id:150286) $\mathcal{K}_k$ 中的最佳近似。

一个关键的性质是，[Ritz值](@entry_id:145862)会优先收敛到 $A$ 的谱的极端部分，即最大和最小的[特征值](@entry_id:154894) [@problem_id:3576508]。随着迭代次数 $k$ 的增加，最大的[Ritz值](@entry_id:145862)会单调递增地逼近 $\lambda_{\max}(A)$，而最小的[Ritz值](@entry_id:145862)会单调递减地逼近 $\lambda_{\min}(A)$。

一旦某些[Ritz值](@entry_id:145862)非常接近 $A$ 的一些[特征值](@entry_id:154894)（特别是那些远离谱中心的孤立[特征值](@entry_id:154894)或[特征值](@entry_id:154894)簇），CG方法构造的误差多项式 $P_k(\lambda)$ 就会在这些[特征值](@entry_id:154894)附近产生根。这相当于在误差中“消除”或“放缩”了与这些[特征向量](@entry_id:151813)相关的分量。之后，算法的收敛行为就如同在作用于一个“有效谱”更小的矩阵上，其“有效条件数”也随之减小，从而导致[收敛加速](@entry_id:165787) [@problem_id:3576508]。

当矩阵 $A$ 的[特征值](@entry_id:154894)出现**[聚类](@entry_id:266727) (clustering)** 现象时，这种[超线性收敛](@entry_id:141654)效应尤为显著。例如，在一个由不同材料组成的结构中，如果某些部分的材料属性相同，或者存在重复的几何单元，其[全局刚度矩阵](@entry_id:138630)的特征谱就会呈现出簇状[分布](@entry_id:182848) [@problem_id:3576553]。CG方法可以在相对较少的迭代次数内有效地“锁定”并“消除”整个[特征值](@entry_id:154894)簇，而不是逐个处理簇内的每个[特征值](@entry_id:154894)。例如，如果谱中有一个 $p$ 重的[特征值](@entry_id:154894) $\alpha$，CG大约在 $p$ 次迭代后就能显著降低与该[特征值](@entry_id:154894)对应的所有误差分量，后续收敛将由剩余的谱决定 [@problem_id:3576553]。这使得实际[收敛速度](@entry_id:636873)远快于仅由全局[条件数](@entry_id:145150) $\kappa(A)$ 预测的速率。

### 预条件技术：加速收敛的关键

尽管CG方法很强大，但当矩阵 $A$ 的[条件数](@entry_id:145150)很大时，其收敛速度仍然可能很慢。**预条件 (Preconditioning)** 技术旨在通过变换原[线性系统](@entry_id:147850)来改善其谱特性，从而加速CG方法的收敛。其基本思想是将原始系统 $A x = b$ 转化为一个等价且更易求解的系统。

一个好的预条件子 $M$ 应该具备两个核心性质：
1.  $M$ 在某种意义上是 $A$ 的一个良好近似，使得预条件后的矩阵（如 $M^{-1}A$）的[条件数](@entry_id:145150)远小于 $\kappa(A)$，理想情况下接近1。
2.  求解形如 $M z = r$ 的线性系统应该是计算高效的，其成本远低于直接求解 $A x = b$。

将预条件技术与CG方法结合，便得到了**预条件[共轭梯度法](@entry_id:143436) (Preconditioned Conjugate Gradient, PCG)**。为了保证PCG的适用性，预条件后的算子必须在某个[内积](@entry_id:158127)下保持[对称正定](@entry_id:145886)性。这引出了三种标准的预条件形式 [@problem_id:3576544]：

*   **左预条件 (Left Preconditioning)**：求解 $M^{-1}A x = M^{-1} b$。此时，算子 $M^{-1}A$ 通常不是对称的，但如果 $M$ 是SPD的，它在 **$M$-[内积](@entry_id:158127)** ($\langle u, v \rangle_M = u^{\mathsf{T}} M v$) 下是对称正定的。
*   **右预条件 (Right Preconditioning)**：求解 $A M^{-1} y = b$，然后令 $x = M^{-1} y$。算子 $A M^{-1}$ 同样通常不是对称的，但它在 **$M^{-1}$-[内积](@entry_id:158127)**下是对称正定的。
*   **分裂预条件 (Split Preconditioning)**：将预条件子分解为 $M = S S^{\mathsf{T}}$，然后求解 $S^{-1} A S^{-\mathsf{T}} z = S^{-1} b$，最后令 $x = S^{-\mathsf{T}} z$。此时，算子 $S^{-1} A S^{-\mathsf{T}}$ 在标准的欧几里得[内积](@entry_id:158127)下是[对称正定](@entry_id:145886)的。

在PCG中，[收敛速度](@entry_id:636873)由预条件后的系统[条件数](@entry_id:145150) $\kappa(M^{-1}A)$ 决定。收敛性[上界](@entry_id:274738)变为：

$$
\frac{\|e_m\|_A}{\|e_0\|_A} \le 2 \left( \frac{\sqrt{\kappa(M^{-1}A)}-1}{\sqrt{\kappa(M^{-1}A)}+1} \right)^m
$$

我们可以利用这个公式来估算达到给定精度 $\varepsilon$ 所需的迭代次数 $m$ [@problem_id:3576528]：

$$
m \approx \frac{1}{2}\sqrt{\kappa(M^{-1}A)} \ln(\frac{2}{\varepsilon})
$$

这个公式在实践中非常有用。例如，在处理非均匀材料的弹性力学问题时，材料属性（如杨氏模量 $E$）的巨大差异会导致[刚度矩阵](@entry_id:178659) $A$ 的[条件数](@entry_id:145150)非常大。如果我们选择一个基于某种参考均质材料（$E_{\text{ref}}$）的刚度矩阵作为预条件子 $M$，则预条件系统的条件数可以被有效地控制在 $\kappa(M^{-1}A) \approx E_{\max}/E_{\min}$，这与网格尺寸无关，从而大大提高了求解效率 [@problem_id:3576528]。

### 实用的预条件方法

选择一个高效的预条件子是成功应用PCG的关键。以下是几种在计算力学中广泛应用的预条件方法。

#### [不完全Cholesky分解](@entry_id:750589) (Incomplete Cholesky Factorization)

对于[SPD矩阵](@entry_id:136714) $A$，存在唯一的[Cholesky分解](@entry_id:147066) $A = \tilde{L}\tilde{L}^{\mathsf{T}}$，其中 $\tilde{L}$ 是一个下[三角矩阵](@entry_id:636278)。如果能求出 $\tilde{L}$，那么求解 $A x=b$ 就等价于两次三角系统求解，非常高效。然而，对于由[偏微分方程离散化](@entry_id:175821)得到的[大型稀疏矩阵](@entry_id:144372) $A$，其精确Cholesky因子 $\tilde{L}$ 通常会包含大量非零元（称为**填充 (fill-in)**），导致计算和存储成本过高。

**[不完全Cholesky分解](@entry_id:750589) (IC)** 的思想是在分解过程中，通过某种策略主动丢弃一部分填充元素，从而得到一个稀疏的近似因子 $L$，使得 $A \approx L L^{\mathsf{T}}$。然后，我们将 $M = L L^{\mathsf{T}}$ 作为[预条件子](@entry_id:753679)。

然而，IC分解有一个重要的理论难点。与精确[Cholesky分解](@entry_id:147066)不同，对于一般的SPD矩阵（例如来自线弹性问题的[刚度矩阵](@entry_id:178659)），IC分解过程可能会因为出现非正的对角元而失败 [@problem_id:3576558]。只有对具有更强性质的矩阵（如[M-矩阵](@entry_id:189121)），简单的IC分解才能保证成功。为了提高IC分解的**鲁棒性 (robustness)**，必须采用一些改进策略：
*   **基于填充等级的策略 (Level-of-fill, IC(k))**：允许一定“等级”的填充。等级$k$越高，因子$L$越稠密，预条件效果越好，但计算和存储成本也越高 [@problem_id:3576558]。
*   **基于阈值的策略 (Drop tolerance, ICT)**：在分解过程中丢弃所有[绝对值](@entry_id:147688)小于给定阈值 $\tau$ 的元素。
*   **对角修正 (Diagonal modification)**：为了防止分解失败，可以人为地增大对角元，例如，将在某一行被丢弃的元素之和（或其[绝对值](@entry_id:147688)之和）加回到该行的对角元上。这种**[修正不完全Cholesky分解](@entry_id:752095) (MIC)** 显著增强了算法的鲁棒性。

#### [区域分解法](@entry_id:165176) (Domain Decomposition Methods)

[区域分解法](@entry_id:165176)是一类强大的并行预条件技术，其基本思想是“[分而治之](@entry_id:273215)”。它将整个计算区域分解成多个（可能重叠的）子区域，然后在每个子区域上求解一个规模较小的局部问题，最后将这些局部解组合起来，形成对[全局解](@entry_id:180992)的一个近似。

**加性Schwarz法 (Additive Schwarz Method)** 是其中的典型代表 [@problem_id:3576523]。其预条件子的逆可以表示为所有子区域“修正量”之和：

$$
M^{-1} = \sum_{i=1}^N R_i^{\mathsf{T}} A_i^{-1} R_i
$$

这里，$R_i$ 是将全局向量分量“限制”到子区域 $i$ 的算子，$A_i$ 是子区域 $i$ 上的局部[刚度矩阵](@entry_id:178659)（通常在人工边界上施加[Dirichlet条件](@entry_id:137096)）。由于每个 $A_i$ 都是SPD的，其逆 $A_i^{-1}$ 也是SPD的。因此，作为[SPD矩阵](@entry_id:136714)之和的 $M^{-1}$ 自然也是SPD的，这保证了其作为PCG[预条件子](@entry_id:753679)的合法性 [@problem_id:3576523]。

子区域之间的**重叠 (overlap)** 对[Schwarz方法](@entry_id:176806)的性能至关重要。增加重叠区域的宽度 $\delta$ 可以加强子区域之间的信息交换，更有效地处理交界面附近的误差模式。理论和实践都表明，增加重叠通常会显著降低预条件系统的[条件数](@entry_id:145150)（例如，$\kappa(M^{-1}A)$ 与 $1/\delta$ 成正比），从而加速收敛 [@problem_id:3576523]。

#### 多重网格法 (Multigrid Methods)

[多重网格法](@entry_id:146386)是求解椭圆型[偏微分方程](@entry_id:141332)离散系统最快的方法之一，其[收敛速度](@entry_id:636873)甚至可以做到与网格尺寸无关。当作为[预条件子](@entry_id:753679)使用时，它同样表现出极高的效率。

多重网格的核心思想是利用不同尺度的网格来消除不同频率的误差分量 [@problem_id:3576566]。它基于两个互补的原理：
1.  **光滑 (Smoothing)**：简单的迭代法（如加权的[Jacobi法](@entry_id:147508)或[Gauss-Seidel法](@entry_id:145727)），虽然作为求解器效率低下，但它们非常擅长快速衰减误差中的**高频（[振荡](@entry_id:267781)）分量**。经过几步“光滑”操作后，剩余的误差会变得“光滑”（主要由低频分量构成）。
2.  **[粗网格校正](@entry_id:177637) (Coarse-grid correction)**：光滑的误差分量可以在更粗的网格上被准确地表示。因此，我们将残差方程投影到粗网格上，求解一个规模小得多的粗网格问题，然后将得到的校正量插值回细网格，以消除误差中的**低频（长波）分量**。

一个对称的**两重网格 (two-grid)** 预条件循环通常包含一次预光滑、一次[粗网格校正](@entry_id:177637)和一次后光滑。为了保证整个预条件算子 $M_{\text{TG}}^{-1}$ 是对称的，必须满足几个条件 [@problem_id:3576566]：
*   [限制算子](@entry_id:754316) $R$ 必须是[延拓算子](@entry_id:749192) $P$ 的[转置](@entry_id:142115)，即 $R = P^{\mathsf{T}}$。
*   [粗网格算子](@entry_id:747426) $A_c$ 必须通过**[Galerkin投影](@entry_id:145611)**定义：$A_c = R A P = P^{\mathsf{T}} A P$。这保证了如果 $A$ 是SPD的，那么 $A_c$ 也是SPD的。
*   光滑算子本身应该是对称的（或前后对称地使用）。

满足这些条件的V-循环[多重网格法](@entry_id:146386)可以构造出一个对称正定的预条件子，与PCG完美结合。

### 高级与实践性考量

在实际应用中，我们还会遇到一些特殊情况和挑战。

#### [奇异系统](@entry_id:140614)（纯[Neumann问题](@entry_id:176713)）

当弹性体没有施加足够的[位移边界条件](@entry_id:203261)来完全限制其运动时（例如，在纯[Neumann问题](@entry_id:176713)中），其[全局刚度矩阵](@entry_id:138630) $A$ 将是**对称半正定 (SPSD)** 的，而非正定。此时，$A$ 是奇异的，其核（nullspace）由物理上的**刚体位移 (rigid body modes)** 构成 [@problem_id:3576555]。在二维空间，这包括2个平移和1个转动（共3个模态）；在三维空间，包括3个平移和3个转动（共6个模态）。

对于[奇异系统](@entry_id:140614) $A u = b$，解存在的必要条件是[载荷向量](@entry_id:635284) $b$ 与 $A$ 的核空间正交，即载荷必须是自平衡的。即使存在解，解也不是唯一的，因为任意刚体位移都可以叠加到解上。

为了得到一个物理上有意义的唯一解，我们通常寻求那个与所有刚体位移正交的解。这可以通过**投影[共轭梯度法](@entry_id:143436) (Projected CG)** 实现。设 $Z$ 是一个矩阵，其列向量构成了核空间（刚体位移模态）的一组基。我们可以构造一个投影算子 $P$，它能将任意[向量投影](@entry_id:147046)到与核空间**M-正交**的[子空间](@entry_id:150286)上（其中 $M$ 是[质量矩阵](@entry_id:177093)，定义了物理上自然的 $L^2$ [内积](@entry_id:158127)）：

$$
P = I - Z (Z^{\mathsf{T}} M Z)^{-1} Z^{\mathsf{T}} M
$$

在CG迭代的每一步，通过将残差或搜索方向用 $P$ 进行投影，可以确保所有迭代过程都在这个受约束的[子空间](@entry_id:150286)内进行，从而收敛到唯一的、与刚体位移M-正交的解 [@problem_id:3576555]。

#### [有限精度效应](@entry_id:193932)

CG算法的许多优美性质，如残差的正交性和搜索方向的[A-正交性](@entry_id:139219)，都是在精确算术下才成立的。在计算机的**有限精度（[浮点](@entry_id:749453)）算术**中，[舍入误差](@entry_id:162651)会逐渐累积，破坏这些理论性质 [@problem_id:3576562]。

问题的根源在于残差的递推更新公式 $r_{k+1} = r_k - \alpha_k A p_k$。虽然这个公式[计算效率](@entry_id:270255)高（避免了矩阵-向量乘法），但每一步的微小[舍入误差](@entry_id:162651)会不断累积。这导致递推更新得到的“代理”残差 $\hat{r}_k$ 与根据定义计算的“真实”残差 $r_k = b - A x_k$ 之间产生偏差。这个偏差会污染系数 $\alpha_k$ 和 $\beta_k$ 的计算，进而破坏正交性。其后果是，CG的收敛可能会停滞，甚至[误差范数](@entry_id:176398)出现增大的情况，即便代理残差的范数仍在下降。

一种简单而有效的缓解策略是**周期性残差重计算 (periodic residual recomputation)**。即每隔一定步数（例如50步），强制通过 $r_k \leftarrow b - A x_k$ 重新计算一次残差。这样做的好处是“重置”了累积的舍入误差，让后续的迭代能够在一个更准确的基础上进行。然而，这种策略也有其代价和局限性 [@problem_id:3576562]：
*   **代价**：每次重计算都需要额外的一次稀疏矩阵-向量乘法，这会增加计算成本。
*   **局限性**：它只能防止误差的进一步恶化，但无法“追溯”修复已经产生的搜索方向之间的[A-正交性](@entry_id:139219)损失。

尽管如此，周期性残差重计算是实现一个鲁棒的CG求解器不可或缺的实践技巧。