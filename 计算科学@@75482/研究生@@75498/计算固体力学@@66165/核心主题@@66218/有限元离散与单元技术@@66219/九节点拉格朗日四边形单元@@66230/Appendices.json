{"hands_on_practices": [{"introduction": "在求解实际力学问题时，首要步骤之一是在有限元模型中准确地表示外加载荷。本练习将引导你运用虚功原理，将连续分布的表面力转化为等效的“一致”节点力 [@problem_id:3583980]。通过这个过程，你将加深对单元形函数如何作为权函数以物理上合理的方式分配载荷的理解。", "problem": "考虑一个用于计算固体力学的有限元法（FEM）中的二维等参九节点拉格朗日四边形单元（通常表示为 Q9 单元）。设自然坐标为 $\\xi$ 和 $\\eta$，其通常的方形参考域为 $[-1,1] \\times [-1,1]$。假设该单元映射到物理空间中的一个直边矩形，使得右边对应于 $\\xi=1$ 且物理长度为 $L$，该边上的三个节点位于 $\\eta=-1$、$\\eta=0$ 和 $\\eta=1$。该单元具有恒定厚度 $b$。\n\n一个面力沿着右边 $\\xi=1$ 施加，纯粹作用在 $x$ 方向上，并由关于边自然坐标 $\\eta$ 的二次函数给出：\n$$\nt_{x}(\\eta) = \\alpha + \\beta \\,\\eta + \\gamma \\,\\eta^{2},\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是常数。使用虚功原理中的基本边界项，推导该边上三个节点在 $x$ 方向上的一致性边节点力，仅用 $\\alpha$、$\\beta$、$\\gamma$、$b$ 和 $L$ 表示。从第一性原理出发，直接根据与点 $\\eta=-1$、$\\eta=0$ 和 $\\eta=1$ 相关的一维二次拉格朗日形函数的定义来构造边上所需的插值；不要引用任何已有的有限元公式。\n\n然后，验证使用保证精确性所需的最少点数的一维高斯-勒让德求积法则能够精确计算这些积分。您必须根据被积函数在该边上的多项式阶数以及高斯-勒让德法则的精确性性质来证明所选点数的合理性。\n\n将您的最终答案表示为对应于 $\\eta=-1$、$\\eta=0$ 和 $\\eta=1$ 的三个 $x$ 方向节点力的行向量，形式为闭式解析表达式。无需进行数值代入，答案框中的最终表达式不应包含任何单位。", "solution": "该问题被认为是有效的，因为其科学依据充分、提法得当、客观，并包含获得唯一解所需的所有必要信息。\n\n一致性节点力的推导始于虚功原理。由面力向量 $\\mathbf{t}$ 在表面 $S_t$ 上所做的外虚功 $\\delta W_{\\text{ext}}$，由面力与虚位移向量 $\\delta\\mathbf{u}$ 的点积的积分给出：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_t} \\delta\\mathbf{u}^T \\mathbf{t} \\, dS\n$$\n在这个二维问题中，面力施加在 $\\xi=1$ 的边上，并且仅在 $x$ 方向上作用，$t_x(\\eta) = \\alpha + \\beta\\eta + \\gamma\\eta^2$。$x$ 方向上的虚位移是 $\\delta u_x$。面元为 $dS = b \\, ds$，其中 $b$ 是恒定厚度，$ds$ 是沿边的弧长微分。虚功表达式简化为：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\delta u_x(\\eta) t_x(\\eta) b \\, ds\n$$\n在有限元框架内，沿该边的位移场 $u_x$ 是使用形函数从节点位移插值得到的。所讨论的边有三个节点，对应于 $\\eta = -1$、$\\eta = 0$ 和 $\\eta = 1$。设它们的 $x$ 方向节点位移为 $d_{x1}$、$d_{x2}$ 和 $d_{x3}$，相应的一维形函数为 $N_1(\\eta)$、$N_2(\\eta)$ 和 $N_3(\\eta)$。沿该边的位移 $u_x$ 和虚位移 $\\delta u_x$ 为：\n$$\nu_x(\\eta) = N_1(\\eta)d_{x1} + N_2(\\eta)d_{x2} + N_3(\\eta)d_{x3} = \\sum_{i=1}^3 N_i(\\eta) d_{xi}\n$$\n$$\n\\delta u_x(\\eta) = N_1(\\eta)\\delta d_{x1} + N_2(\\eta)\\delta d_{x2} + N_3(\\eta)\\delta d_{x3} = \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi}\n$$\n将 $\\delta u_x$ 代入虚功表达式：\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\left( \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi} \\right) t_x(\\eta) b \\, ds\n$$\n由于虚节点位移 $\\delta d_{xi}$ 是任意的，并且相对于积分是常数，我们可以写出：\n$$\n\\delta W_{\\text{ext}} = \\sum_{i=1}^3 \\delta d_{xi} \\left( \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds \\right)\n$$\n外虚功也定义为一致性节点力 $F_{xi}$ 与相应虚节点位移 $\\delta d_{xi}$ 的乘积之和：\n$$\n\\delta W_{\\text{ext}} = \\sum_{i=1}^3 F_{xi} \\delta d_{xi}\n$$\n通过比较 $\\delta W_{\\text{ext}}$ 的两个表达式，节点 $i$ 的一致性节点力为：\n$$\nF_{xi} = \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds\n$$\n问题陈述物理边是一条长度为 $L$ 的直线，对应于自然坐标 $\\eta$ 从 $-1$ 变化到 $1$。物理微分长度 $ds$ 与自然坐标微分 $d\\eta$ 之间的关系通过一维映射的雅可比行列式 $J_s = ds/d\\eta$ 找到。对于从 $[-1, 1]$ 到 $[0, L]$ 的线性映射，我们有 $s(\\eta) = \\frac{L}{2}(\\eta+1)$，因此 $J_s = ds/d\\eta = L/2$。积分变为：\n$$\nF_{xi} = \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) b \\left( \\frac{L}{2} \\right) d\\eta = \\frac{bL}{2} \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) \\, d\\eta\n$$\n接下来，我们为位于 $\\eta_1=-1$、$\\eta_2=0$ 和 $\\eta_3=1$ 的节点构造一维二次拉格朗日形函数。\n对于 $N_1(\\eta)$ (节点位于 $\\eta=-1$ 处)，它在 $\\eta=0$ 和 $\\eta=1$ 处必须为零。因此，$N_1(\\eta) = C_1(\\eta-0)(\\eta-1)$。应用条件 $N_1(-1)=1$ 可得 $C_1(-1)(-2)=1 \\implies C_1=1/2$。\n$$ N_1(\\eta) = \\frac{1}{2}\\eta(\\eta-1) = \\frac{1}{2}(\\eta^2-\\eta) $$\n对于 $N_2(\\eta)$ (节点位于 $\\eta=0$ 处)，它在 $\\eta=-1$ 和 $\\eta=1$ 处必须为零。因此，$N_2(\\eta) = C_2(\\eta+1)(\\eta-1)$。应用条件 $N_2(0)=1$ 可得 $C_2(1)(-1)=1 \\implies C_2=-1$。\n$$ N_2(\\eta) = -(\\eta^2-1) = 1-\\eta^2 $$\n对于 $N_3(\\eta)$ (节点位于 $\\eta=1$ 处)，它在 $\\eta=-1$ 和 $\\eta=0$ 处必须为零。因此，$N_3(\\eta) = C_3(\\eta+1)(\\eta-0)$。应用条件 $N_3(1)=1$ 可得 $C_3(2)(1)=1 \\implies C_3=1/2$。\n$$ N_3(\\eta) = \\frac{1}{2}\\eta(\\eta+1) = \\frac{1}{2}(\\eta^2+\\eta) $$\n现在我们计算每个节点力的积分。\n对于 $F_{x1}$：\n$$ F_{x1} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2-\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta-\\gamma)\\eta^3 + (\\alpha-\\beta)\\eta^2 - \\alpha\\eta) \\, d\\eta $$\n在对称区间 $[-1, 1]$ 上，奇次幂项（$\\eta^3$, $\\eta$）的积分为零。\n$$ F_{x1} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha-\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha-\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha-\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha - 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma) $$\n对于 $F_{x2}$：\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (1-\\eta^2)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 - \\beta\\eta^3 + (\\gamma-\\alpha)\\eta^2 + \\beta\\eta + \\alpha) \\, d\\eta $$\n同样，奇次幂项的积分为零。\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 + (\\gamma-\\alpha)\\eta^2 + \\alpha) \\, d\\eta = \\frac{bL}{2} \\left[ -\\gamma\\frac{\\eta^5}{5} + (\\gamma-\\alpha)\\frac{\\eta^3}{3} + \\alpha\\eta \\right]_{-1}^{1} = \\frac{bL}{2} \\left( -2\\frac{\\gamma}{5} + 2\\frac{\\gamma-\\alpha}{3} + 2\\alpha \\right) = bL \\left( -\\frac{\\gamma}{5} + \\frac{\\gamma-\\alpha}{3} + \\alpha \\right) $$\n$$ F_{x2} = bL \\left( \\frac{-3\\gamma + 5\\gamma - 5\\alpha + 15\\alpha}{15} \\right) = bL \\left( \\frac{10\\alpha + 2\\gamma}{15} \\right) = \\frac{bL}{30}(20\\alpha + 4\\gamma) $$\n对于 $F_{x3}$：\n$$ F_{x3} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2+\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta+\\gamma)\\eta^3 + (\\alpha+\\beta)\\eta^2 + \\alpha\\eta) \\, d\\eta $$\n奇次幂项的积分为零。\n$$ F_{x3} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha+\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha+\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha+\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha + 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma) $$\n这三个节点力是：\n$F_{x1} = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$\n$F_{x2} = \\frac{bL}{30}(20\\alpha + 4\\gamma)$\n$F_{x3} = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$\n\n现在我们必须验证，使用最少点数的高斯-勒让德求积法则可以精确计算这些积分。积分的一般形式是 $\\int_{-1}^1 f(\\eta) d\\eta$，其中被积函数是 $f(\\eta) = N_i(\\eta)t_x(\\eta)$。\n形函数 $N_i(\\eta)$ 是2次多项式。面力函数 $t_x(\\eta)$ 也是一个2次多项式。因此，这两者的乘积 $f(\\eta) = N_i(\\eta)t_x(\\eta)$ 是一个阶数为 $p = 2+2=4$ 的多项式。\n一个 $n$ 点的高斯-勒让德求积法则可以精确积分最高为 $2n-1$ 阶的多项式。为了确保我们的4阶多项式能够被精确积分，必须满足以下条件：\n$2n - 1 \\ge 4$\n$2n \\ge 5$\n$n \\ge 2.5$\n由于求积点数 $n$ 必须是整数，因此保证精确性所需的最小点数是 $n=3$。因此，一个3点的高斯-勒让德求积法则是能够精确计算一致性节点力积分的最低阶法则。验证至此完成。\n\n最终答案是这三个节点力的行向量。我们可以提出公因式 $\\frac{bL}{30}$。\n这三个力是 $\\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$、$\\frac{bL}{30}(20\\alpha + 4\\gamma)$ 和 $\\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$。", "answer": "$$\n\\boxed{\\frac{bL}{30} \\begin{pmatrix} 5\\alpha - 5\\beta + 3\\gamma & 20\\alpha + 4\\gamma & 5\\alpha + 5\\beta + 3\\gamma \\end{pmatrix}}\n$$", "id": "3583980"}, {"introduction": "一个可靠的有限元不仅需要给出解答，更要能证明其精度随着网格的加密而可预见地提高。本练习将通过“制造解”这一有限元方法中基本的验证技术，引导你对 Q9 单元进行收敛性研究 [@problem_id:3583965]。你将把数值模拟得到的收敛率与能量范数和 $L^2$ 范数下的理论预测值进行比较，从而验证单元的性能。", "problem": "考虑单位正方形域 $[0,1] \\times [0,1]$ 上由泊松方程控制的标量反平面剪切模型。设 $u:[0,1] \\times [0,1] \\to \\mathbb{R}$ 为标量位移场。其强形式为\n$$\n-\\nabla \\cdot (\\nabla u) = f \\text{ in } \\Omega = [0,1]^2, \\quad u = g \\text{ on } \\partial \\Omega.\n$$\n您将使用一个制造解 $u_{\\text{ex}}(x,y)$，因此 $f$ 和 $g$ 由 $u_{\\text{ex}}$ 通过强形式导出。使用以下制造解：\n$$\nu_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n利用强形式，从 $u_{\\text{ex}}(x,y)$ 一致地定义 $f(x,y)$ 和 $g(x,y)$。\n\n您的任务是：\n- 从在 Sobolev 空间 $H^1_0(\\Omega)$ 中建立的弱形式和 Galerkin 方法出发，推导当试验空间为协调九节点拉格朗日四边形单元空间（常称为张量积二次族）时，在 $H^1$-半范数（能量范数）和 $L^2$-范数下的理论预期收敛阶。推导必须仅从变分形式和张量积二次插值的一般逼近性质开始，不得使用任何预先引用的目标阶数。清楚地陈述得出收敛速率结论时对解的正则性和网格正则性的假设。\n- 在单位正方形 $\\Omega$ 的一系列均匀网格上，使用九节点拉格朗日四边形单元实现一个协调有限元求解器，其中每个坐标方向上的单元数为 $N \\in \\{2,4,8\\}$。对于每边有 $N$ 个单元的均匀张量网格，单元尺寸为 $h = 1/N$。\n- 在双单位参考正方形 $[-1,1]^2$ 上，通过与节点 $\\xi \\in \\{-1,0,1\\}$ 和 $\\eta \\in \\{-1,0,1\\}$ 相关联的一维二次拉格朗日多项式的张量积，构造九节点形函数。使用从参考正方形到每个物理矩形单元的等参仿射映射（这在均匀矩形网格上是有效的）。使用足够高阶的 Gauss-Legendre 求积法来组装全局刚度矩阵和载荷向量，以对所选的制造数据达到组装精度。\n- 通过在所有边界节点上指定 $u_{\\text{ex}}$ 的精确值来强施加 Dirichlet 边界条件，并求解内部节点的值。\n- 在每个单元上使用足够高阶的 Gauss-Legendre 求积法计算 $H^1$-半范数误差\n$$\n\\lvert u_{\\text{ex}} - u_h \\rvert_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\, d\\Omega \\right)^{1/2}\n$$\n和 $L^2$-范数误差\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} (u_{\\text{ex}} - u_h)^2 \\, d\\Omega \\right)^{1/2}\n$$\n。\n- 对于 $N \\in \\{2,4,8\\}$ 的网格序列，计算每个范数在连续网格加密之间的观测收敛速率。如果 $e(h)$ 表示网格尺寸为 $h$ 时的误差，则将 $h$ 和 $h/2$ 之间的观测速率定义为\n$$\n\\text{rate} = \\frac{\\log(e(h)/e(h/2))}{\\log(2)}.\n$$\n\n您可以使用的基础材料：\n- 在 $H^1_0(\\Omega)$ 上建立的变分形式和标准 Galerkin 框架。\n- 具有齐次 Dirichlet 边界条件的泊松算子变分问题的适定性。\n- 将 Galerkin 误差与试验空间中的最佳逼近误差联系起来的 Céa 引理。\n- 存在一个到张量积二次空间中的有界插值算子，以及在形状规则、拟均匀网格上对足够光滑函数的一般插值误差估计。\n- 在适当的椭圆正则性下，用于从能量范数估计改进 $L^2$-范数估计的 Aubin–Nitsche 对偶论证。\n\n需要实现的数值细节：\n- 使用精确的制造解 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$、其梯度 $\\nabla u_{\\text{ex}}(x,y)$ 以及由强形式导出的相应右端项 $f(x,y)$。\n- 在每个方向上使用至少 4 阶的 Gauss-Legendre 求积法进行刚度/载荷组装，以及在每个方向上使用至少 6 阶的求积法进行误差评估。\n- 使用与节点 $\\{-1,0,1\\}$ 相关的一维多项式构成的张量积二次基底来处理参考单元 $[-1,1]^2$。二维基底通过张量积获得，导数通过乘积法则获得。\n\n测试套件：\n- 使用三种网格，每边分别有 $N \\in \\{2,4,8\\}$ 个单元。\n- 对每个 $N$，计算误差对 $(\\lvert \\cdot \\rvert_{H^1}, \\|\\cdot\\|_{L^2})$。\n- 计算 $N=2$ 到 $N=4$ 以及 $N=4$ 到 $N=8$ 之间两种范数的观测速率。此外，报告四个布尔检查，验证 $H^1$-半范数的观测速率在两个加密步骤中是否都超过 $1.9$，以及 $L^2$-范数的观测速率在两个加密步骤中是否都超过 $2.8$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须严格按以下顺序包含：\n    - $N=2$ 时的 $H^1$-半范数误差，\n    - $N=2$ 时的 $L^2$-范数误差，\n    - $N=4$ 时的 $H^1$-半范数误差，\n    - $N=4$ 时的 $L^2$-范数误差，\n    - $N=8$ 时的 $H^1$-半范数误差，\n    - $N=8$ 时的 $L^2$-范数误差，\n    - 从 $N=2$ 到 $N=4$ 的观测 $H^1$-半范数速率，\n    - 从 $N=4$ 到 $N=8$ 的观测 $H^1$-半范数速率，\n    - 从 $N=2$ 到 $N=4$ 的观测 $L^2$-范数速率，\n    - 从 $N=4$ 到 $N=8$ 的观测 $L^2$-范数速率，\n    - 一个布尔值，指示两次加密的 $H^1$ 速率是否都超过 $1.9$，\n    - 一个布尔值，指示两次加密的 $L^2$ 速率是否都超过 $2.8$，\n    - 一个布尔值，指示从 $N=2$ 到 $N=4$ 的 $H^1$ 速率是否超过 $1.9$，\n    - 一个布尔值，指示从 $N=2$ 到 $N=4$ 的 $L^2$ 速率是否超过 $2.8$。\n- 所有浮点数必须以定点格式打印，小数点后精确到 $8$ 位。\n- 输出必须类似于\n$$\n[\\text{eH1\\_N2},\\text{eL2\\_N2},\\text{eH1\\_N4},\\text{eL2\\_N4},\\text{eH1\\_N8},\\text{eL2\\_N8},\\text{rateH1\\_24},\\text{rateH1\\_48},\\text{rateL2\\_24},\\text{rateL2\\_48},\\text{boolH1All},\\text{boolL2All},\\text{boolH1\\_24},\\text{boolL2\\_24}]\n$$\n其中逗号分隔的值遵循上述顺序，布尔值打印为 True 或 False。此问题不涉及单位，也没有出现角度。", "solution": "该问题要求推导泊松方程的九节点拉格朗日四边形有限元离散化的理论收敛速率，然后使用制造解对这些速率进行数值验证。\n\n### 第 1 部分：问题表述与理论分析\n\n**1.1. 强形式与弱形式**\n\n该问题由单位正方形域 $\\Omega = [0,1]^2$ 上的泊松方程控制：\n$$\n-\\nabla^2 u = f \\quad \\text{in } \\Omega,\n$$\n边界 $\\partial\\Omega$ 上具有 Dirichlet 边界条件 $u=g$。\n\n制造解由 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 给出。我们从 $u_{\\text{ex}}$ 导出源项 $f$ 和边界数据 $g$。\n梯度为 $\\nabla u_{\\text{ex}} = (\\pi \\cos(\\pi x)\\sin(\\pi y), \\pi \\sin(\\pi x)\\cos(\\pi y))$。\n拉普拉斯算子为 $\\nabla^2 u_{\\text{ex}} = \\frac{\\partial^2 u_{\\text{ex}}}{\\partial x^2} + \\frac{\\partial^2 u_{\\text{ex}}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) - \\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_{\\text{ex}}$。\n因此，源项为 $f(x,y) = -\\nabla^2 u_{\\text{ex}} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。\n\n对于边界数据 $g$，我们在 $\\partial\\Omega$ 上计算 $u_{\\text{ex}}$。由于 $\\sin(0) = 0$ 且 $\\sin(\\pi) = 0$，$u_{\\text{ex}}(x,y)$ 在单位正方形的所有四条边上均为零。因此，在 $\\partial\\Omega$ 上 $g(x,y) = 0$。该问题是齐次的。\n\n相应的弱（变分）形式是在 Sobolev 空间 $H^1_0(\\Omega) = \\{ v \\in H^1(\\Omega) : v|_{\\partial\\Omega} = 0 \\}$ 中找到一个解 $u$，使得：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f v \\, d\\Omega \\quad \\forall v \\in H^1_0(\\Omega).\n$$\n这可以写成抽象形式：找到 $u \\in H^1_0(\\Omega)$，使得对于所有 $v \\in H^1_0(\\Omega)$ 都有 $a(u,v) = L(v)$，其中双线性形式 $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega$ 在 $H^1_0(\\Omega)$ 上定义了一个内积，并诱导出能量范数 $|v|_{H^1(\\Omega)} = \\sqrt{a(v,v)}$。线性泛函为 $L(v) = \\int_{\\Omega} f v \\, d\\Omega$。\n\n**1.2. Galerkin 方法与收敛速率**\n\n有限元法是一种 Galerkin 方法，我们在有限维子空间 $V_h \\subset H^1_0(\\Omega)$ 中寻找近似解 $u_h$。空间 $V_h$ 由定义在四边形单元网格上的连续分片双二次多项式组成，这些多项式在 $\\partial\\Omega$ 上为零。Galerkin 问题是找到 $u_h \\in V_h$，使得：\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h.\n$$\n\n**$H^1$-半范数收敛性：**\n分析始于 Céa 引理，对于此问题，该引理指出 Galerkin 解的误差受子空间 $V_h$ 中的最佳逼近误差的限制：\n$$\n|u - u_h|_{H^1(\\Omega)} \\leq \\inf_{v_h \\in V_h} |u - v_h|_{H^1(\\Omega)}.\n$$\n最佳逼近误差可以通过 $V_h$ 中特定插值子的误差来界定。设 $\\mathcal{I}_h u$ 为 $u$ 在 $V_h$ 中的标准双二次拉格朗日插值。标准插值理论为插值误差提供了一个估计，前提是解 $u$ 具有足够的正则性且网格是拟均匀的。对于一个多项式次数为 $p$ 的有限元，其估计为：\n$$\n|u - \\mathcal{I}_h u|_{H^1(\\Omega)} \\leq C h^p |u|_{H^{p+1}(\\Omega)},\n$$\n其中 $h$ 是特征网格尺寸，$C$ 是一个与 $h$ 无关的常数。\n九节点拉格朗日单元是张量积二次单元，因此其多项式次数为 $p=2$。该估计要求解属于 Sobolev 空间 $H^{p+1}(\\Omega) = H^3(\\Omega)$。我们的制造解 $u_{\\text{ex}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 是无限可微的（$C^\\infty$），因此它属于任何 $k$ 阶的 $H^k(\\Omega)$，包括 $H^3(\\Omega)$。\n综合这些结果，$H^1$-半范数误差的理论收敛速率为：\n$$\n|u_{\\text{ex}} - u_h|_{H^1(\\Omega)} = O(h^p) = O(h^2).\n$$\n预期的收敛阶为 $2$。\n\n**$L^2$-范数收敛性：**\n为了获得 $L^2$-范数更高的收敛速率，我们使用 Aubin-Nitsche 对偶论证。该论证要求泊松问题具有 $H^2$ 椭圆正则性，这对于像单位正方形这样的凸域是成立的。这意味着对于辅助问题 $-\\nabla^2 \\phi = \\psi$（在 $\\Omega$ 中，且在 $\\partial\\Omega$ 上 $\\phi=0$），对于任何 $\\psi \\in L^2(\\Omega)$，解都满足 $\\|\\phi\\|_{H^2(\\Omega)} \\leq C_{\\text{reg}} \\|\\psi\\|_{L^2(\\Omega)}$。\nAubin-Nitsche 论证得出以下估计：\n$$\n\\|u - u_h\\|_{L^2(\\Omega)} \\leq C h |u - u_h|_{H^1(\\Omega)}.\n$$\n代入先前推导的 $H^1$-半范数误差率：\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} \\leq C h \\cdot O(h^p) = O(h^{p+1}).\n$$\n对于我们的双二次单元（$p=2$），$L^2$-范数误差的理论收敛速率为：\n$$\n\\|u_{\\text{ex}} - u_h\\|_{L^2(\\Omega)} = O(h^{p+1}) = O(h^3).\n$$\n预期的收敛阶为 $3$。\n\n### 第 2 部分：有限元实现细节\n\n**2.1. 离散化与形函数**\n区域 $\\Omega=[0,1]^2$ 被离散化为 $N \\times N$ 个边长为 $h=1/N$ 的正方形单元的均匀网格。使用九节点（双二次）拉格朗日单元。参考单元 $[-1,1]^2$ 上的形函数 $N_i(\\xi, \\eta)$ 由与节点 $s \\in \\{-1,0,1\\}$ 相关联的一维二次拉格朗日多项式 $L_k(s)$ 的张量积构造而成：\n$L_0(s) = \\frac{1}{2}s(s-1)$, $L_1(s) = 1-s^2$, $L_2(s) = \\frac{1}{2}s(s+1)$。\n九个二维形函数 $N_k(\\xi, \\eta)$（$k=0, \\dots, 8$）为 $N_{ij}(\\xi, \\eta) = L_i(\\xi)L_j(\\eta)$，其中 $i,j \\in \\{0,1,2\\}$。\n\n**2.2. 等参映射与数值求积**\n一个仿射等参映射 $x(\\xi, \\eta)$ 将参考单元变换到每个物理单元 $K_e$。对于中心为 $(x_c, y_c)$、边长为 $h$ 的正方形单元，此映射为 $x = x_c + \\frac{h}{2}\\xi$，$y = y_c + \\frac{h}{2}\\eta$。雅可比行列式为常数：$\\det(J) = h^2/4$。\n\n通过将积分变换到参考单元并使用 Gauss-Legendre 求积法进行数值计算，来计算单元刚度矩阵 $k^e$ 和载荷向量 $f^e$。\n$$\nk^e_{ij} = \\int_{-1}^1 \\int_{-1}^1 \\left(\\nabla N_i(\\xi, \\eta)\\right)^T (J^{-T} J^{-1}) \\left(\\nabla N_j(\\xi, \\eta)\\right) \\det(J) \\,d\\xi d\\eta\n$$\n$$\nf^e_i = \\int_{-1}^1 \\int_{-1}^1 f(x(\\xi,\\eta), y(\\xi,\\eta)) N_i(\\xi, \\eta) \\det(J) \\,d\\xi d\\eta\n$$\n$k^e$ 的被积函数是多项式。对于双二次单元和仿射映射，其在每个变量上的次数最多为 $4$。一个 3 点高斯法则将是精确的，但问题指定每个方向至少 4 个点；我们使用 $4 \\times 4$ 法则。$f^e$ 的被积函数是非多项式，因此高阶法则可以提高精度。\n单元贡献被组装成全局刚度矩阵 $K$ 和载荷向量 $F$。\n\n**2.3. 边界条件与求解**\n齐次 Dirichlet 边界条件（$u=0$）被强施加。这是通过将全局方程组划分为内部未知数和边界未知数来实现的。求解系统 $K_{II}U_I = F_I - K_{IB}U_B$ 以获得内部节点值 $U_I$。由于边界值 $U_B$ 均为零，这简化为求解 $K_{II} U_I = F_I$。\n\n**2.4. 误差计算**\n误差 $e = u_{\\text{ex}} - u_h$ 的 $H^1$-半范数和 $L^2$-范数是通过对每个单元的贡献求和来计算的，为保证精度，使用高阶（$6 \\times 6$）Gauss-Legendre 求积法进行评估。\n$$\n|e|_{H^1(\\Omega)}^2 = \\sum_{e} \\int_{K_e} \\|\\nabla u_{\\text{ex}} - \\nabla u_h\\|^2 \\,d\\Omega \\quad \\text{and} \\quad \\|e\\|_{L^2(\\Omega)}^2 = \\sum_{e} \\int_{K_e} (u_{\\text{ex}} - u_h)^2 \\,d\\Omega.\n$$\n\n**2.5. 速率计算**\n对于每个范数，在尺寸为 $h_1$ 和 $h_2=h_1/2$ 的网格之间的观测收敛速率计算为 $\\text{rate} = \\log(e_1/e_2) / \\log(2)$。这对从 $N=2$ 到 $N=4$ 以及从 $N=4$ 到 $N=8$ 的加密过程进行计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 9-node quadrilateral FEM solver for the Poisson equation\n    and performs a convergence study.\n    \"\"\"\n\n    def get_gauss_points(order):\n        return np.polynomial.legendre.leggauss(order)\n\n    # 1D quadratic shape functions and their derivatives\n    L = [\n        lambda s: 0.5 * s * (s - 1),\n        lambda s: 1 - s**2,\n        lambda s: 0.5 * s * (s + 1),\n    ]\n    dL = [\n        lambda s: s - 0.5,\n        lambda s: -2 * s,\n        lambda s: s + 0.5,\n    ]\n\n    def shape_functions(xi, eta):\n        N = np.zeros(9)\n        for j in range(3):\n            for i in range(3):\n                N[j * 3 + i] = L[i](xi) * L[j](eta)\n        return N\n\n    def shape_function_derivatives(xi, eta):\n        dN = np.zeros((9, 2))\n        for j in range(3):\n            for i in range(3):\n                dN[j * 3 + i, 0] = dL[i](xi) * L[j](eta)  # d/d(xi)\n                dN[j * 3 + i, 1] = L[i](xi) * dL[j](eta)  # d/d(eta)\n        return dN\n\n    # Manufactured solution and its derivatives\n    u_ex = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    grad_u_ex = lambda x, y: np.array([\n        np.pi * np.cos(np.pi * x) * np.sin(np.pi * y),\n        np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n    ])\n    f_source = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    mesh_sizes = [2, 4, 8]\n    errors = []\n\n    GQ_ORDER_ASSEMBLY = 4\n    GQ_ORDER_ERROR = 6\n    gp_assembly, gw_assembly = get_gauss_points(GQ_ORDER_ASSEMBLY)\n    gp_error, gw_error = get_gauss_points(GQ_ORDER_ERROR)\n\n    for N in mesh_sizes:\n        h = 1.0 / N\n        num_nodes_1d = 2 * N + 1\n        num_nodes = num_nodes_1d**2\n        \n        nodes = np.zeros((num_nodes, 2))\n        for j in range(num_nodes_1d):\n            for i in range(num_nodes_1d):\n                nodes[j * num_nodes_1d + i] = [i * h / 2.0, j * h / 2.0]\n\n        elements = []\n        for j in range(N):\n            for i in range(N):\n                el_nodes = np.zeros(9, dtype=int)\n                for row in range(3):\n                    for col in range(3):\n                        node_x_idx = 2 * i + col\n                        node_y_idx = 2 * j + row\n                        el_nodes[row * 3 + col] = node_y_idx * num_nodes_1d + node_x_idx\n                elements.append(el_nodes)\n        \n        K_global = np.zeros((num_nodes, num_nodes))\n        F_global = np.zeros(num_nodes)\n        \n        for el_nodes in elements:\n            k_elem = np.zeros((9, 9))\n            f_elem = np.zeros(9)\n            \n            x_nodes = nodes[el_nodes]\n            x_c = np.mean(x_nodes, axis=0) # Center of the element\n            \n            # Jacobian for affine map from [-1,1]^2 to [x-h/2,x+h/2]x[y-h/2,y+h/2]\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n\n            for i in range(GQ_ORDER_ASSEMBLY):\n                for j in range(GQ_ORDER_ASSEMBLY):\n                    xi, eta = gp_assembly[i], gp_assembly[j]\n                    weight = gw_assembly[i] * gw_assembly[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    \n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    B = dN_dx_dy.T\n                    k_elem += (B.T @ B) * weight * det_J\n                    \n                    f_val = f_source(x_phys, y_phys)\n                    f_elem += f_val * N_vals * weight * det_J\n            \n            for i in range(9):\n                for j in range(9):\n                    K_global[el_nodes[i], el_nodes[j]] += k_elem[i, j]\n                F_global[el_nodes[i]] += f_elem[i]\n\n        boundary_nodes = [i for i in range(num_nodes) if (np.isclose(nodes[i,0],0) or np.isclose(nodes[i,0],1) or np.isclose(nodes[i,1],0) or np.isclose(nodes[i,1],1))]\n        interior_nodes = list(set(range(num_nodes)) - set(boundary_nodes))\n\n        K_interior = K_global[np.ix_(interior_nodes, interior_nodes)]\n        F_interior = F_global[interior_nodes]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        \n        U_global = np.zeros(num_nodes)\n        U_global[interior_nodes] = U_interior\n        \n        err_H1_sq = 0.0\n        err_L2_sq = 0.0\n\n        for el_nodes in elements:\n            x_nodes = nodes[el_nodes]\n            u_elem = U_global[el_nodes]\n            x_c = np.mean(x_nodes, axis=0)\n            det_J = (h / 2.0)**2\n            inv_J_T = np.array([[2.0 / h, 0], [0, 2.0 / h]])\n            \n            for i in range(GQ_ORDER_ERROR):\n                for j in range(GQ_ORDER_ERROR):\n                    xi, eta = gp_error[i], gp_error[j]\n                    weight = gw_error[i] * gw_error[j]\n                    \n                    x_phys = x_c[0] + xi * h / 2.0\n                    y_phys = x_c[1] + eta * h / 2.0\n                    \n                    N_vals = shape_functions(xi, eta)\n                    dN_dxi_eta = shape_function_derivatives(xi, eta)\n                    dN_dx_dy = dN_dxi_eta @ inv_J_T\n                    \n                    u_h = np.dot(N_vals, u_elem)\n                    grad_u_h = u_elem @ dN_dx_dy\n                    \n                    u_exact_val = u_ex(x_phys, y_phys)\n                    grad_u_exact_val = grad_u_ex(x_phys, y_phys)\n                    \n                    err_L2_sq += (u_exact_val - u_h)**2 * weight * det_J\n                    err_H1_sq += np.sum((grad_u_exact_val - grad_u_h)**2) * weight * det_J\n\n        errors.append((np.sqrt(err_H1_sq), np.sqrt(err_L2_sq)))\n\n    eH1_N2, eL2_N2 = errors[0]\n    eH1_N4, eL2_N4 = errors[1]\n    eH1_N8, eL2_N8 = errors[2]\n\n    rateH1_24 = np.log(eH1_N2 / eH1_N4) / np.log(2)\n    rateH1_48 = np.log(eH1_N4 / eH1_N8) / np.log(2)\n    rateL2_24 = np.log(eL2_N2 / eL2_N4) / np.log(2)\n    rateL2_48 = np.log(eL2_N4 / eL2_N8) / np.log(2)\n\n    boolH1_24 = rateH1_24 > 1.9\n    boolL2_24 = rateL2_24 > 2.8\n    boolH1All = (rateH1_24 > 1.9) and (rateH1_48 > 1.9)\n    boolL2All = (rateL2_24 > 2.8) and (rateL2_48 > 2.8)\n\n    output = [\n        f\"{eH1_N2:.8f}\", f\"{eL2_N2:.8f}\",\n        f\"{eH1_N4:.8f}\", f\"{eL2_N4:.8f}\",\n        f\"{eH1_N8:.8f}\", f\"{eL2_N8:.8f}\",\n        f\"{rateH1_24:.8f}\", f\"{rateH1_48:.8f}\",\n        f\"{rateL2_24:.8f}\", f\"{rateL2_48:.8f}\",\n        str(boolH1All), str(boolL2All),\n        str(boolH1_24), str(boolL2_24)\n    ]\n    \n    print(f\"[{','.join(output)}]\")\n\nsolve()\n\n```", "id": "3583965"}, {"introduction": "尽管功能强大，但在模拟近不可压缩材料时，像 Q9 这样的高阶单元可能会表现出“体积锁定”等病态行为，导致结果过于刚硬且不准确。这个动手练习将深入探讨这一关键问题，让你亲手实现并比较标准的全积分方案与旨在缓解锁定的“选择性积分”方案 [@problem_id:3584031]。这将为你提供关于单元实际性能和高级列式技巧的宝贵见解。", "problem": "基于基本原理，实现针对单个九节点拉格朗日四边形单元（通常缩写为 Q9）的小应变二维等参有限元法（FEM），以研究选择性积分对体积锁定的影响。考虑平面应变条件下的线性各向同性弹性问题，其中 Lamé 参数 $\\lambda$ 和 $\\mu$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 定义为 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\dfrac{E}{2(1+\\nu)}$。在无体力的情况下，控制方程源于准静态线性动量平衡 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$，其中线性本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$，小应变张量为 $\\boldsymbol{\\varepsilon} = \\text{sym}(\\nabla \\boldsymbol{u})$。在平面应变条件下，对于 Voigt 记法下的应变 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$，其弹性（本构）矩阵为\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}.\n$$\n使用等参映射，在母单元正方形 $(\\xi,\\eta)\\in[-1,1]^2$ 上采用双二次拉格朗日形函数，并通过高斯求积（GQ）执行数值积分。单元刚度矩阵为\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega,\n$$\n其中 $\\mathbf{B}$ 是由形函数的空间导数构建的标准应变-位移矩阵。在单元的右边界 $\\Gamma_t$ 上施加均匀面力 $\\boldsymbol{t} = [p, 0]^T$，并组集一致节点力向量\n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma,\n$$\n其中 $\\mathbf{N}$ 集合了标量形函数，线积分通过在该边界上的一维高斯求积进行计算。\n\n您的任务是为同一个 Q9 单元实现两种积分策略：\n- 完全积分：对 $\\mathbf{K}_e$ 中的域积分使用 $3\\times 3$ 高斯求积，不对 $\\mathbf{B}$ 进行修改。\n- 通过 $\\bar{\\mathbf{B}}$ 型修正实现的选择性积分：在每个 $3\\times 3$ 高斯点上构造一个修正后的 $\\bar{\\mathbf{B}}$ 矩阵，方法是仅将应变的体积（膨胀）部分替换为其单元平均值，该平均值通过单元中心处的单个 $1\\times 1$ 高斯点近似得到。设 $\\frac{\\partial N_i}{\\partial x}$ 和 $\\frac{\\partial N_i}{\\partial y}$ 表示在给定求积点处第 $i$ 个形函数的空间导数，设 $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ 和 $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$ 表示使用中心 $1\\times 1$ 求积计算出的它们的单元平均值。为使体胀 $\\varepsilon_{xx} + \\varepsilon_{yy}$ 等于其单元平均值，同时保持剪切部分不变，按如下方式修改 $\\mathbf{B}$ 的前两行：对于每个节点 $i$，其节点位移向量为包含 $(u_i, v_i)$ 的 $2\\times 1$ 向量，\n- 定义 $\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ 和 $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$，\n- 将 $\\tfrac{1}{2}\\Delta_i^x$ 加到 $(\\varepsilon_{xx}, u_i)$ 对应的项，将 $\\tfrac{1}{2}\\Delta_i^y$ 加到 $(\\varepsilon_{xx}, v_i)$ 对应的项，\n- 将 $\\tfrac{1}{2}\\Delta_i^x$ 加到 $(\\varepsilon_{yy}, u_i)$ 对应的项，将 $\\tfrac{1}{2}\\Delta_i^y$ 加到 $(\\varepsilon_{yy}, v_i)$ 对应的项，\n- 保持剪切行（对应 $\\gamma_{xy}$）不变。\n这强制使得 $\\varepsilon_{xx}+\\varepsilon_{yy}$ 被其单元平均值替换，同时保留了偏量和剪切内容，从而减轻了体积锁定。\n\n几何、材料和载荷：\n- 单个 Q9 单元覆盖单位正方形，物理坐标 $(x,y)\\in[0,1]\\times[0,1]$（单位：米），通过 $x=\\frac{\\xi+1}{2}$ 和 $y=\\frac{\\eta+1}{2}$ 将标准 Q9 母单元节点 $(\\xi,\\eta)\\in\\{(-1,-1),(1,-1),(1,1),(-1,1),(0,-1),(1,0),(0,1),(-1,0),(0,0)\\}$ 映射得到。\n- 厚度 $t = 1$ 米（平面应变）。\n- 杨氏模量 $E = 1000$ 帕斯卡。\n- 右边界上的面力大小 $p = 1$ 牛顿每米，作用于 x 轴正方向。\n- 本质边界条件：在左边界 $x=0$ 上固定两个位移分量 $u=v=0$（所有位于 $x=0$ 上的节点）。\n\n关注量：\n- 对于每种情况，计算右边界中点节点（即位于 $(x,y)=(1,0.5)$ 的节点，在标准 Q9 排序中为 6 号节点）的水平位移 $u_x$，单位为米。\n\n测试组：\n- 三个泊松比 $\\nu \\in \\{0.0, 0.3, 0.49\\}$（无量綱）。\n- 对于每个 $\\nu$，计算两个值：完全积分结果 $u_x^{\\text{full}}$ 和选择性积分结果 $u_x^{\\text{sel}}$，两者均以米为单位，表示为浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个扁平的、逗号分隔的六个数字列表，对应于 $[u_x^{\\text{full}}(\\nu=0.0), u_x^{\\text{sel}}(\\nu=0.0), u_x^{\\text{full}}(\\nu=0.3), u_x^{\\text{sel}}(\\nu=0.3), u_x^{\\text{full}}(\\nu=0.49), u_x^{\\text{sel}}(\\nu=0.49)]$，以米为单位，每个数值四舍五入到六位小数。\n- 所需格式模式示例（仅为例示）：\"[0.001234,0.001567,0.000890,0.001234,0.000100,0.001200]\"。\n\n科学和数值约束：\n- 使用线性弹性的基本弱形式、小应变运动学和标准等参 Q9 插值。\n- 在两种策略中，对域积分均使用 $3\\times 3$ 高斯求积；在选择性策略中，仅使用中心 $1\\times 1$ 求积来计算定义 $\\bar{\\mathbf{B}}$ 修正所需的单元平均导数。\n- 对右边界上的面力积分使用 3 点高斯求积。\n- 必须一致地使用平面应变假设。\n- 所有物理量在内部计算时，位移必须以米为单位，刚度相关量以帕斯卡为单位，但最终输出行中仅按规定打印位移。", "solution": "用户提供的问题是计算固体力学中一个有效的、适定的练习。它在科学上基于线性弹性理论和有限元法（FEM）的原理，包含了获得唯一解所需的所有数据，并以客观、精确的语言表述。任务是实现针对单个九节点拉格朗日四边形（Q9）单元的二维、小应变、等参有限元分析，以比较完全积分和选择性数值积分对体积锁定的影响。\n\n求解过程如下：首先，我们建立理论框架，包括控制方程、等参 Q9 单元公式和材料模型。其次，我们详细说明两种数值积分策略：标准完全积分和使用 $\\bar{\\mathbf{B}}$ 方法的选择性积分方案。最后，我们概述组集方程组、施加边界条件和求解节点位移的步骤。\n\n### 1. 理论公式\n\n该问题由准静态线性动量平衡控制，在无体力的情况下为 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量。对于小应变，应变张量为 $\\boldsymbol{\\varepsilon} = \\text{sym}(\\nabla \\boldsymbol{u})$，其中 $\\boldsymbol{u}$ 是位移场。材料是线性的、弹性的和各向同性的，遵循本构关系 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。\n\n作为有限元法基础的控制方程的弱形式，导出单元级矩阵方程：\n$$\n\\mathbf{K}_e \\mathbf{d}_e = \\mathbf{f}_e\n$$\n其中 $\\mathbf{d}_e$ 是单元的节点位移向量，$\\mathbf{K}_e$ 是单元刚度矩阵，$\\mathbf{f}_e$ 是单元节点力向量。\n\n单元刚度矩阵由单元域 $\\Omega_e$ 上的积分给出：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega\n$$\n应变-位移矩阵 $\\mathbf{B}$ 将节点位移与应变分量关联起来：$\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$。\n\n### 2. 等参九节点四边形（Q9）单元\n\n我们使用定义在母单元正方形域 $(\\xi, \\eta) \\in [-1, 1]^2$ 上的 Q9 单元。该单元有九个节点，位于 $\\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$ 的网格点上。物理坐标 $(x, y)$ 使用与插值位移场相同的形函数从母单元坐标 $(\\xi, \\eta)$ 映射而来（等参概念）：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) y_i\n$$\n其中 $(x_i, y_i)$ 是节点 $i$ 的物理坐标。对于指定的单位正方形几何形状 $(x,y)\\in[0,1]^2$，映射关系为 $x = (\\xi+1)/2$ 和 $y = (\\eta+1)/2$。\n\n双二次拉格朗日形函数 $N_i(\\xi, \\eta)$ 是一维二次拉格朗日多项式的乘积。对于位于母单元坐标 $(\\xi_i, \\eta_i)$ 的节点 $i$：\n$N_i(\\xi, \\eta) = L(\\xi, \\xi_i) L(\\eta, \\eta_i)$，其中\n$$\nL(t, t_i) = \n\\begin{cases}\n    \\frac{1}{2} t(t-1) & \\text{if } t_i = -1 \\\\\n    1 - t^2 & \\text{if } t_i = 0 \\\\\n    \\frac{1}{2} t(t+1) & \\text{if } t_i = 1\n\\end{cases}\n$$\n链式法则将空间导数与母单元域中的导数关联起来：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\n其中 $\\mathbf{J}$ 是坐标变换的雅可比矩阵。对于给定的映射，$\\mathbf{J}$ 是常数：$\\mathbf{J} = \\begin{bmatrix} 1/2 & 0 \\\\ 0 & 1/2 \\end{bmatrix}$，因此 $\\det(\\mathbf{J})=1/4$。\n\n对于二维问题，应变-位移矩阵 $\\mathbf{B}$ 是一个 $3 \\times 18$ 的矩阵，由 9 个节点的每一个对应的 $3 \\times 2$ 块组成：\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\dots, \\mathbf{B}_9], \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n\n### 3. 材料本构模型：平面应变\n\n在平面应变假设（$\\varepsilon_{zz}=0$）下，本构矩阵 $\\mathbf{D}$ 通过 Lamé 参数 $\\lambda$ 和 $\\mu$ 关联平面内的应力和应变分量（$\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$）：\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}\n$$\n这些参数由杨氏模量 $E$ 和泊松比 $\\nu$ 定义为：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n当 $\\nu \\to 0.5$（不可压缩极限）时，$\\lambda \\to \\infty$，这可能导致称为体积锁定的数值不稳定性。\n\n### 4. 积分方案\n\n刚度积分使用高斯求积（GQ）进行数值计算：\n$$\n\\mathbf{K}_e = \\int_{-1}^1 \\int_{-1}^1 \\mathbf{B}^T(\\xi, \\eta) \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{n_{gp}} \\sum_{k=1}^{n_{gp}} w_j w_k \\left[ \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\det(\\mathbf{J}) \\right]_{(\\xi_j, \\eta_k)}\n$$\n\n**完全积分：**\n该方法使用 $3 \\times 3$ 的高斯点网格（$n_{gp}=3$），这足以精确积分矩形 Q9 单元的刚度矩阵。然而，对于近不可压缩材料，它容易出现体积锁定。\n\n**选择性积分（$\\bar{\\mathbf{B}}$ 方法）：**\n该方法通过修改应变-位移矩阵来强制单元内的体积应变为常数，从而减轻锁定。单元刚度仍使用 $3 \\times 3$ GQ 计算，但在每个求积点 $(\\xi_{gp}, \\eta_{gp})$ 处，使用一个修正后的矩阵 $\\bar{\\mathbf{B}}$。修正步骤如下：\n\n1.  在当前的 $3 \\times 3$ 求积点上计算标准空间导数 $\\frac{\\partial N_i}{\\partial x}$ 和 $\\frac{\\partial N_i}{\\partial y}$。\n2.  通过在单元中心 $(\\xi=0, \\eta=0)$（对应于 $1 \\times 1$ GQ 法则）求值，计算单元平均空间导数 $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ 和 $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$。\n3.  对于每个节点 $i$，定义偏差项：$\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ 和 $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$。\n4.  通过调整标准矩阵 $\\mathbf{B}$ 的块 $\\mathbf{B}_i$ 来构造修正矩阵 $\\bar{\\mathbf{B}}$：\n    $$\n    \\bar{\\mathbf{B}}_i = \\begin{bmatrix}\n    \\frac{\\partial N_i}{\\partial x} + \\frac{1}{2}\\Delta_i^x & \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{1}{2}\\Delta_i^x & \\frac{\\partial N_i}{\\partial y} + \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x}\n    \\end{bmatrix}\n    $$\n这种修正确保计算出的体积应变 $\\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy}$ 被其单元平均值 $\\langle \\varepsilon_v \\rangle$ 替换，从而有效地将体积响应与高阶变形模式解耦，防止锁定。\n\n### 5. 力向量、边界条件和求解\n\n外部载荷是在右边界（$x=1$，或 $\\xi=1$）上的均匀面力 $\\boldsymbol{t} = [p, 0]^T$。一致节点力向量通过线积分计算，使用 3 点一维 GQ 进行求值：\n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma = \\int_{-1}^1 \\mathbf{N}(\\xi=1, \\eta)^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} |\\frac{d\\mathbf{x}}{d\\eta}| d\\eta \\approx \\sum_{k=1}^{3} w_k \\left[ \\mathbf{N}^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} \\frac{1}{2} \\right]_{(\\xi=1, \\eta_k)}\n$$\n其中 $|d\\mathbf{x}/d\\eta|=1/2$ 是边界上微分线元的长度。\n\n在左边界（$x=0$）上施加本质边界条件 $u=v=0$，固定与节点 1、4 和 8 相关的自由度（DOFs）。系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$被划分为自由和指定自由度，然后求解簡化后的系统 $\\mathbf{K}_{ff} \\mathbf{d}_f = \\mathbf{f}_f$ 以获得未知位移 $\\mathbf{d}_f$。接着，从解向量中提取右边界中点节点（6 号节点）的水平位移 $u_x$。\n对每个指定的泊松比 $\\nu$ 值和两种积分方案重复此过程。结果表明，当 $\\nu$ 趋近于 0.5 时，完全积分方案产生过刚响应（位移很小），这是体积锁定的典型迹象，而选择性积分方案则得出物理上更合理的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem, numpy.polynomial is sufficient\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements a 2D FEM analysis for a single Q9 element to study volumetric locking.\n    \"\"\"\n    \n    def get_q9_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Calculates the shape functions and their derivatives for a Q9 element \n        at a given point (xi, eta) in the parent domain.\n\n        The problem uses a standard counter-clockwise order:\n        1(-1,-1), 2(1,-1), 3(1,1), 4(-1,1), 5(0,-1), 6(1,0), 7(0,1), 8(-1,0), 9(0,0)\n        \"\"\"\n        # Nodal coordinates in parent domain [-1, 1] x [-1, 1]\n        xis = [-1, 1, 1, -1, 0, 1, 0, -1, 0]\n        etas = [-1, -1, 1, 1, -1, 0, 1, 0, 0]\n        \n        N = np.zeros(9)\n        dN_dxi = np.zeros(9)\n        dN_deta = np.zeros(9)\n\n        def get_1d_poly_and_deriv(t, t_node):\n            if t_node == -1:\n                L = 0.5 * t * (t - 1)\n                dL_dt = t - 0.5\n            elif t_node == 0:\n                L = 1 - t**2\n                dL_dt = -2 * t\n            elif t_node == 1:\n                L = 0.5 * t * (t + 1)\n                dL_dt = t + 0.5\n            else:\n                raise ValueError(\"Invalid nodal coordinate\")\n            \n            L_val = 1.0\n            dL_val = 1.0\n            \n            # This is not general, but works for the tensor product structure\n            # where one node coordinate is xi_i and the other is eta_i\n            # This logic is flawed. Let's fix it.\n            # The original logic was to find shape functions for a single node.\n            # Let's fix the logic for tensor products.\n\n            return L, dL_dt\n\n\n        for i in range(9):\n            xi_i, eta_i = xis[i], etas[i]\n            \n            # 1D functions for xi direction\n            if xi_i == -1: L_xi, dL_dxi_val = 0.5 * xi * (xi - 1), xi - 0.5\n            elif xi_i == 0: L_xi, dL_dxi_val = 1 - xi**2, -2 * xi\n            else: L_xi, dL_dxi_val = 0.5 * xi * (xi + 1), xi + 0.5\n                \n            # 1D functions for eta direction\n            if eta_i == -1: L_eta, dL_deta_val = 0.5 * eta * (eta - 1), eta - 0.5\n            elif eta_i == 0: L_eta, dL_deta_val = 1 - eta**2, -2 * eta\n            else: L_eta, dL_deta_val = 0.5 * eta * (eta + 1), eta + 0.5\n            \n            N[i] = L_xi * L_eta\n            dN_dxi[i] = dL_dxi_val * L_eta\n            dN_deta[i] = L_xi * dL_deta_val\n            \n        return N, dN_dxi, dN_deta\n\n    def get_fem_solution(E, nu, integration_type):\n        \"\"\"\n        Calculates the displacement for a given material and integration type.\n        \"\"\"\n        # Material parameters\n        if nu == 0.5: \n            # This should not happen with nu=0.49, but as a safeguard.\n            # A very large number to simulate incompressibility.\n            lambda_ = E * 1.0e8\n        else:\n            lambda_ = E * nu / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n\n        D = np.array([\n            [lambda_ + 2 * mu, lambda_, 0],\n            [lambda_, lambda_ + 2 * mu, 0],\n            [0, 0, mu]\n        ])\n\n        # Isoparametric mapping and Jacobian\n        J = np.array([[0.5, 0.0], [0.0, 0.5]])\n        detJ = np.linalg.det(J)\n        J_inv = np.linalg.inv(J)\n\n        # Stiffness Matrix K_e (18x18)\n        K_e = np.zeros((18, 18))\n        \n        # Gaussian quadrature for domain integral\n        gp_3, w_3 = leggauss(3)\n        \n        # Element-mean derivatives for B-bar method\n        if integration_type == 'selective':\n            _, dN_dxi_mean, dN_deta_mean = get_q9_shape_functions_and_derivs(0, 0)\n            dN_dx_mean = J_inv[0, 0] * dN_dxi_mean + J_inv[0, 1] * dN_deta_mean\n            dN_dy_mean = J_inv[1, 0] * dN_dxi_mean + J_inv[1, 1] * dN_deta_mean\n\n        for i in range(3):\n            for j in range(3):\n                xi, eta = gp_3[i], gp_3[j]\n                weight = w_3[i] * w_3[j]\n                \n                _, dN_dxi, dN_deta = get_q9_shape_functions_and_derivs(xi, eta)\n                \n                # Spatial derivatives dN/dx, dN/dy\n                dN_dx = J_inv[0, 0] * dN_dxi + J_inv[0, 1] * dN_deta\n                dN_dy = J_inv[1, 0] * dN_dxi + J_inv[1, 1] * dN_deta\n\n                # Strain-displacement matrix B (3x18)\n                B = np.zeros((3, 18))\n                for k in range(9):\n                    B[0, 2*k] = dN_dx[k]\n                    B[1, 2*k+1] = dN_dy[k]\n                    B[2, 2*k] = dN_dy[k]\n                    B[2, 2*k+1] = dN_dx[k]\n\n                # B-bar modification for selective integration\n                if integration_type == 'selective':\n                    B_to_use = np.copy(B)\n                    for k in range(9):\n                        delta_x = dN_dx_mean[k] - dN_dx[k]\n                        delta_y = dN_dy_mean[k] - dN_dy[k]\n                        B_to_use[0, 2*k] += 0.5 * delta_x\n                        B_to_use[0, 2*k+1] += 0.5 * delta_y\n                        B_to_use[1, 2*k] += 0.5 * delta_x\n                        B_to_use[1, 2*k+1] += 0.5 * delta_y\n                else: # full integration\n                    B_to_use = B\n\n                K_e += B_to_use.T @ D @ B_to_use * detJ * weight\n\n        # Force vector F_t (18x1)\n        F_t = np.zeros(18)\n        p = 1.0  # Traction magnitude N/m\n        \n        # 1D GQ for line integral on right edge (xi=1)\n        gp_3_1d, w_3_1d = leggauss(3)\n        dl_deta = 0.5  # |dy/deta| on edge xi=1\n        \n        for i in range(3):\n            eta = gp_3_1d[i]\n            weight = w_3_1d[i]\n            \n            N, _, _ = get_q9_shape_functions_and_derivs(1, eta)\n            \n            for k in range(9):\n                F_t[2*k] += N[k] * p * dl_deta * weight\n                \n        # Apply boundary conditions\n        # Fix nodes 1, 8, 4 (left edge, x=0)\n        # 0-indexed nodes: 0, 7, 3\n        # 0-indexed DOFs to fix: 0,1 (node 1), 14,15 (node 8), 6,7 (node 4)\n        fixed_dofs = [0, 1, 14, 15, 6, 7]\n        all_dofs = list(range(18))\n        free_dofs = [dof for dof in all_dofs if dof not in fixed_dofs]\n\n        K_ff = K_e[np.ix_(free_dofs, free_dofs)]\n        F_f = F_t[free_dofs]\n\n        # Solve for free displacements\n        U_f = np.linalg.solve(K_ff, F_f)\n        \n        # DOF of interest: u_x at node 6\n        # Node 6 has DOFs 10 (u) and 11 (v) (0-indexed)\n        target_dof = 10 # u_x for node 6\n        target_idx_in_Uf = free_dofs.index(target_dof)\n        \n        return U_f[target_idx_in_Uf]\n\n    # --- Main execution ---\n    test_cases = [\n        0.0,\n        0.3,\n        0.49\n    ]\n    E = 1000.0  # Pascals\n    \n    results = []\n    \n    for nu in test_cases:\n        # Full integration\n        ux_full = get_fem_solution(E, nu, integration_type='full')\n        results.append(ux_full)\n        \n        # Selective integration\n        ux_sel = get_fem_solution(E, nu, integration_type='selective')\n        results.append(ux_sel)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3584031"}]}