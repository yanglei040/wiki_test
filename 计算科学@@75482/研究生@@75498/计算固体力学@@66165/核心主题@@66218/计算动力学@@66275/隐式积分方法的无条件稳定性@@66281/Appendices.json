{"hands_on_practices": [{"introduction": "第一个实践练习将无条件稳定性这一抽象概念置于一个具体的物理问题中。通过分析一个粘弹性材料模型，你将为广义中点法推导出其稳定性函数，并发现实现 L-稳定性的精确条件。这个过程将帮助你理解该特性如何抑制刚性系统中的非物理振荡。[@problem_id:3608579]", "problem": "考虑一个由松弛型本构常微分方程 (ODE) 控制的小应变线性粘弹性固体\n$$\n\\dot{\\boldsymbol{\\sigma}}(t) + \\frac{1}{\\tau}\\,\\boldsymbol{\\sigma}(t) = \\frac{E}{\\tau}\\,\\boldsymbol{\\varepsilon}(t),\n$$\n其中 $\\boldsymbol{\\sigma}(t)$ 是 Cauchy 应力张量，$\\boldsymbol{\\varepsilon}(t)$ 是应变张量，$E>0$ 是弹性模量，$\\tau>0$ 是松弛时间。该 ODE 表示 $\\boldsymbol{\\sigma}(t)$ 向瞬时弹性应力 $E\\,\\boldsymbol{\\varepsilon}(t)$ 的指数松弛。\n\n你将分析一种隐式单参数时间积分器（广义中点法或 $\\theta$ 法）在大小为 $\\Delta t = t_{n+1}-t_n$ 的单个时间步 $[t_n, t_{n+1}]$ 上推进应力的无条件稳定性。该方法在凸组合 $t_{n+\\theta} = t_n + \\theta\\,\\Delta t$（其中 $0 \\le \\theta \\le 1$）处计算右侧项，并使用\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_n + \\Delta t\\left(-\\frac{1}{\\tau}\\,\\boldsymbol{\\sigma}_{n+\\theta} + \\frac{E}{\\tau}\\,\\boldsymbol{\\varepsilon}_{n+\\theta}\\right),\n$$\n其中 $\\boldsymbol{\\sigma}_{n+\\theta} = (1-\\theta)\\,\\boldsymbol{\\sigma}_n + \\theta\\,\\boldsymbol{\\sigma}_{n+1}$ 且 $\\boldsymbol{\\varepsilon}_{n+\\theta} = (1-\\theta)\\,\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}$。\n\n从给定的 ODE 和此隐式离散化出发，执行以下步骤：\n\n1. 推导将 $\\boldsymbol{\\sigma}_{n+1}$ 与 $\\boldsymbol{\\sigma}_n$、$\\boldsymbol{\\varepsilon}_n$ 和 $\\boldsymbol{\\varepsilon}_{n+1}$ 相关联的闭式更新，然后减去瞬时弹性应力，以获得关于松弛残差 $\\boldsymbol{r}_n := \\boldsymbol{\\sigma}_n - E\\,\\boldsymbol{\\varepsilon}_n$ 的齐次递推关系。\n\n2. 证明当应变在该步内保持恒定时，残差服从 $\\boldsymbol{r}_{n+1} = R_{\\theta}(z)\\,\\boldsymbol{r}_n$ 形式的线性单步关系，其中 $z := \\Delta t/\\tau$，$R_{\\theta}(z)$ 是刚性衰减模式的标量稳定性函数。\n\n3. 使用绝对稳定性 (A-stability) 的定义，以及极限稳定性 (L-stability) 的判据，即当 $z \\to \\infty$ 时 $R_{\\theta}(z) \\to 0$，确定使该方法 L-稳定的 $\\theta \\in [0,1]$ 的唯一值。你的最终答案必须是这个 $\\theta$ 值，以单个实数形式给出。无需四舍五入，也不应报告单位。\n\n整个分析过程中假设小应变和线性材料行为，并假设对于稳定性函数的这种标量分析，所有张量分量都是解耦的。如上文所示，在首次使用时定义常微分方程 (ODE) 和绝对稳定性 (A-stability)；将极限稳定性 (L-stability) 解释为在无限刚度极限 $z\\to\\infty$ 下稳定性函数趋于零的性质。", "solution": "该问题被验证为具有科学依据、良定且客观。它基于计算固体力学和数值分析的标准原理。所有必要信息都已提供，任务是使用一个明确定义的过程推导出一个具体的结果。\n\n解答过程按照问题陈述的要求分三步进行。\n\n**步骤 1：松弛残差的齐次递推关系推导。**\n\n使用广义中点法（或 $\\theta$ 法）的本构常微分方程 (ODE) 的时间离散化形式如下：\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_n + \\Delta t\\left(-\\frac{1}{\\tau}\\,\\boldsymbol{\\sigma}_{n+\\theta} + \\frac{E}{\\tau}\\,\\boldsymbol{\\varepsilon}_{n+\\theta}\\right)\n$$\n其中 $\\boldsymbol{\\sigma}_{n+\\theta} = (1-\\theta)\\,\\boldsymbol{\\sigma}_n + \\theta\\,\\boldsymbol{\\sigma}_{n+1}$ 且 $\\boldsymbol{\\varepsilon}_{n+\\theta} = (1-\\theta)\\,\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}$。参数 $\\theta$ 的范围是 $0 \\le \\theta \\le 1$。\n\n首先，我们将 $\\boldsymbol{\\sigma}_{n+\\theta}$ 的表达式代入积分器方程，得到关于 $\\boldsymbol{\\sigma}_{n+1}$ 的隐式方程：\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_n - \\frac{\\Delta t}{\\tau} \\left[ (1-\\theta)\\boldsymbol{\\sigma}_n + \\theta \\boldsymbol{\\sigma}_{n+1} \\right] + \\frac{E \\Delta t}{\\tau} \\boldsymbol{\\varepsilon}_{n+\\theta}\n$$\n我们重新排列各项以求解 $\\boldsymbol{\\sigma}_{n+1}$，将所有 $\\boldsymbol{\\sigma}_{n+1}$ 项归到左侧：\n$$\n\\boldsymbol{\\sigma}_{n+1} + \\frac{\\theta \\Delta t}{\\tau} \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_n - \\frac{(1-\\theta) \\Delta t}{\\tau} \\boldsymbol{\\sigma}_n + \\frac{E \\Delta t}{\\tau} \\boldsymbol{\\varepsilon}_{n+\\theta}\n$$\n在左边提取公因式 $\\boldsymbol{\\sigma}_{n+1}$，在右边提取公因式 $\\boldsymbol{\\sigma}_n$，我们得到：\n$$\n\\left(1 + \\frac{\\theta \\Delta t}{\\tau}\\right) \\boldsymbol{\\sigma}_{n+1} = \\left(1 - \\frac{(1-\\theta) \\Delta t}{\\tau}\\right) \\boldsymbol{\\sigma}_n + \\frac{E \\Delta t}{\\tau} \\boldsymbol{\\varepsilon}_{n+\\theta}\n$$\n让我们引入无量纲时间步长 $z := \\Delta t / \\tau$。方程变为：\n$$\n(1 + \\theta z) \\boldsymbol{\\sigma}_{n+1} = (1 - (1-\\theta) z) \\boldsymbol{\\sigma}_n + E z \\left[(1-\\theta)\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}\\right]\n$$\n求解 $\\boldsymbol{\\sigma}_{n+1}$ 得到闭式更新：\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\frac{1 - (1-\\theta) z}{1 + \\theta z} \\boldsymbol{\\sigma}_n + \\frac{E z}{1 + \\theta z} \\left[(1-\\theta)\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}\\right]\n$$\n接下来，我们引入松弛残差 $\\boldsymbol{r}_n := \\boldsymbol{\\sigma}_n - E\\,\\boldsymbol{\\varepsilon}_n$。根据这个定义，我们有 $\\boldsymbol{\\sigma}_n = \\boldsymbol{r}_n + E\\,\\boldsymbol{\\varepsilon}_n$ 和 $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{r}_{n+1} + E\\,\\boldsymbol{\\varepsilon}_{n+1}$。将它们代入 $\\boldsymbol{\\sigma}_{n+1}$ 的更新法则中：\n$$\n\\boldsymbol{r}_{n+1} + E\\,\\boldsymbol{\\varepsilon}_{n+1} = \\frac{1 - (1-\\theta) z}{1 + \\theta z} (\\boldsymbol{r}_n + E\\,\\boldsymbol{\\varepsilon}_n) + \\frac{E z}{1 + \\theta z} \\left[(1-\\theta)\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}\\right]\n$$\n分离出 $\\boldsymbol{r}_{n+1}$ 得到：\n$$\n\\boldsymbol{r}_{n+1} = \\frac{1 - (1-\\theta) z}{1 + \\theta z} \\boldsymbol{r}_n + \\frac{1 - (1-\\theta) z}{1 + \\theta z} E\\,\\boldsymbol{\\varepsilon}_n + \\frac{E z \\left[(1-\\theta)\\boldsymbol{\\varepsilon}_n + \\theta\\,\\boldsymbol{\\varepsilon}_{n+1}\\right]}{1 + \\theta z} - E\\,\\boldsymbol{\\varepsilon}_{n+1}\n$$\n我们收集乘以 $E$ 的项，并将它们放在公分母 $1 + \\theta z$ 上：\n$$\n\\boldsymbol{r}_{n+1} = \\frac{1 - (1-\\theta) z}{1 + \\theta z} \\boldsymbol{r}_n + \\frac{E}{1 + \\theta z} \\left\\{ [1 - (1-\\theta)z]\\boldsymbol{\\varepsilon}_n + z[(1-\\theta)\\boldsymbol{\\varepsilon}_n + \\theta\\boldsymbol{\\varepsilon}_{n+1}] - (1+\\theta z)\\boldsymbol{\\varepsilon}_{n+1} \\right\\}\n$$\n现在，我们通过对含 $\\boldsymbol{\\varepsilon}_n$ 和 $\\boldsymbol{\\varepsilon}_{n+1}$ 的项进行分组，来简化花括号内的表达式：\n$$\n\\{ [1 - z + \\theta z + z - \\theta z]\\boldsymbol{\\varepsilon}_n + [\\theta z - (1 + \\theta z)]\\boldsymbol{\\varepsilon}_{n+1} \\} = \\{ (1)\\boldsymbol{\\varepsilon}_n + (\\theta z - 1 - \\theta z)\\boldsymbol{\\varepsilon}_{n+1} \\} = \\boldsymbol{\\varepsilon}_n - \\boldsymbol{\\varepsilon}_{n+1}\n$$\n因此，残差的递推关系为：\n$$\n\\boldsymbol{r}_{n+1} = \\frac{1 - (1-\\theta) z}{1 + \\theta z} \\boldsymbol{r}_n + \\frac{E}{1 + \\theta z} (\\boldsymbol{\\varepsilon}_n - \\boldsymbol{\\varepsilon}_{n+1})\n$$\n\n**步骤 2：稳定性函数的推导。**\n\n为了分析衰减模式的稳定性，我们考虑应变在时间步内保持不变的情况，即 $\\boldsymbol{\\varepsilon}_n = \\boldsymbol{\\varepsilon}_{n+1}$。在这种情况下，强迫项 $\\frac{E}{1 + \\theta z} (\\boldsymbol{\\varepsilon}_n - \\boldsymbol{\\varepsilon}_{n+1})$ 变为零。残差 $\\boldsymbol{r}_n$ 的递推关系变为齐次的：\n$$\n\\boldsymbol{r}_{n+1} = \\left( \\frac{1 - (1-\\theta) z}{1 + \\theta z} \\right) \\boldsymbol{r}_n\n$$\n其形式为 $\\boldsymbol{r}_{n+1} = R_{\\theta}(z)\\,\\boldsymbol{r}_n$，其中 $R_{\\theta}(z)$ 是标量稳定性函数：\n$$\nR_{\\theta}(z) = \\frac{1 - (1-\\theta) z}{1 + \\theta z}\n$$\n\n**步骤 3：确定 L-稳定性的 $\\theta$ 值。**\n\n如果对所有 $z \\ge 0$ 都有 $|R_{\\theta}(z)| \\le 1$，则该方法被定义为 A-稳定 (absolute stability)。这个条件确保了对于一个稳定的物理系统，无论时间步长大小如何，数值解都不会增长。应用于此问题的 $\\theta$ 法在 $\\theta \\in [1/2, 1]$ 时是 A-稳定的。\n\n一个更强的条件是 L-稳定性 (limit-stability)，它要求在无限刚性系统（即无限衰减率或 $z = \\Delta t/\\tau \\to \\infty$）的极限下，数值放大因子消失。这是一个理想的性质，因为它确保了非常快速的刚性动力学在单个大时间步内被完全阻尼掉。其数学条件是：\n$$\n\\lim_{z \\to \\infty} R_{\\theta}(z) = 0\n$$\n我们为推导出的稳定性函数计算这个极限：\n$$\n\\lim_{z \\to \\infty} R_{\\theta}(z) = \\lim_{z \\to \\infty} \\frac{1 - (1-\\theta) z}{1 + \\theta z}\n$$\n为了计算这个关于 $z$ 的有理函数的极限，我们将分子和分母同时除以 $z$ 的最高次幂，即 $z^1$：\n$$\n\\lim_{z \\to \\infty} \\frac{\\frac{1}{z} - (1-\\theta)}{\\frac{1}{z} + \\theta}\n$$\n当 $z \\to \\infty$ 时，$1/z$ 项趋近于 $0$。极限变为：\n$$\n\\frac{0 - (1-\\theta)}{0 + \\theta} = \\frac{-(1-\\theta)}{\\theta} = \\frac{\\theta - 1}{\\theta}\n$$\n为了满足 L-稳定性，这个极限必须等于 $0$：\n$$\n\\frac{\\theta - 1}{\\theta} = 0\n$$\n该方程成立的充要条件是分子为零，即 $\\theta - 1 = 0$。这给出了唯一解 $\\theta=1$。这个值在指定的范围 $\\theta \\in [0, 1]$ 内。$\\theta=1$ 的选择对应于后向欧拉积分格式，该格式已知是 L-稳定的。", "answer": "$$\n\\boxed{1}\n$$", "id": "3608579"}, {"introduction": "A-稳定性保证了长期有界性，但它是否能防止暂时的、非物理的能量增长？本练习通过分析 A-稳定的梯形法则来挑战这一假设，揭示了对于特定的范数和时间步长，可能会发生瞬态的能量放大。这个实践对于培养超越形式化定义的、对数值稳定性的精细理解至关重要。[@problem_id:3608634]", "problem": "一个具有粘性阻尼的单自由度线性弹性振子，代表了小应变线性固体，满足牛顿第二定律\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) = 0,\n$$\n其中位移为$x(t)$，速度为$v(t) = \\dot{x}(t)$，质量$m>0$，阻尼$c \\ge 0$，刚度$k>0$。引入一阶状态$y(t) = \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix}$，因此\n$$\n\\dot{y}(t) = A\\,y(t), \\quad A = \\begin{pmatrix} 0  1 \\\\ -\\frac{k}{m}  -\\frac{c}{m} \\end{pmatrix}.\n$$\n考虑时间步长为$\\Delta t > 0$的梯形法则（对于线性系统，也称为Crank–Nicolson方法或隐式中点法则），\n$$\ny^{n+1} = y^{n} + \\frac{\\Delta t}{2}\\left(A\\,y^{n} + A\\,y^{n+1}\\right),\n$$\n该法则通过以下方式定义了单步放大矩阵$G(\\Delta t)$\n$$\ny^{n+1} = G(\\Delta t)\\,y^{n}, \\quad G(\\Delta t) = \\left(I - \\frac{\\Delta t}{2}A\\right)^{-1}\\left(I + \\frac{\\Delta t}{2}A\\right).\n$$\n根据$A$-稳定性（绝对稳定性）的定义，一个众所周知的结果是梯形法则是$A$-稳定的，这意味着其标量稳定性函数将开放的左半复平面映射到闭合的单位圆盘内。\n\n尽管具有$A$-稳定性，但在给定范数（或“类能量”二次泛函）下的单调衰减对于离散轨迹并不得到保证。为了展示这一点，考虑参数为$m = 1$，$c = 10$，$k = 100$以及时间步长$\\Delta t = 0.3$的振子。定义二次类能量泛函\n$$\nE_{\\mathrm{euc}}(y) = \\frac{1}{2}\\,y^{\\top} y,\n$$\n它对应于欧几里得范数的平方。\n\n仅从控制方程、状态空间形式和梯形法则定义出发，推导给定参数下的$G(\\Delta t)$，然后计算在梯形更新下$E_{\\mathrm{euc}}$的最大单步放大因子，即\n$$\n\\alpha_{\\max} = \\max_{y \\neq 0}\\frac{E_{\\mathrm{euc}}(y^{n+1})}{E_{\\mathrm{euc}}(y^{n})}.\n$$\n你的推导必须从这些基本原理出发，并且不得假定任何预先制表的能量估计。将最终答案表示为一个无量纲数。将你的答案四舍五入到四位有效数字。", "solution": "问题要求计算由梯形法则离散化的线性振子的二次泛函$E_{\\mathrm{euc}}(y) = \\frac{1}{2}y^{\\top}y$的最大单步放大因子$\\alpha_{\\max}$。给定的参数为质量$m = 1$，阻尼$c = 10$，刚度$k = 100$，时间步长$\\Delta t = 0.3$。\n\n单步更新由$y^{n+1} = G(\\Delta t)y^{n}$给出。连续步骤之间类能量泛函的比率为\n$$\n\\frac{E_{\\mathrm{euc}}(y^{n+1})}{E_{\\mathrm{euc}}(y^{n})} = \\frac{\\frac{1}{2}(y^{n+1})^{\\top}y^{n+1}}{\\frac{1}{2}(y^{n})^{\\top}y^{n}} = \\frac{(G y^{n})^{\\top}(G y^{n})}{(y^{n})^{\\top}y^{n}} = \\frac{(y^{n})^{\\top}G^{\\top}G y^{n}}{(y^{n})^{\\top}y^{n}}.\n$$\n待计算的量$\\alpha_{\\max}$是该比率在所有非零状态向量$y^{n}$上的最大值。这个最大值对应于矩阵$G^{\\top}G$的瑞利商的最大值。瑞利商的最大值是该矩阵的最大特征值。因此，\n$$\n\\alpha_{\\max} = \\lambda_{\\max}(G^{\\top}G).\n$$\n$2 \\times 2$矩阵$H = G^{\\top}G$的特征值$\\lambda$是其特征方程的根：\n$$\n\\lambda^2 - \\mathrm{tr}(H)\\lambda + \\det(H) = 0.\n$$\n我们的策略是首先计算放大矩阵$G$，然后求出$H=G^{\\top}G$的行列式和迹，以求解其特征值。\n\n首先，我们用给定的参数$m=1$，$c=10$和$k=100$构建状态矩阵$A$：\n$$\nA = \\begin{pmatrix} 0  1 \\\\ -\\frac{k}{m}  -\\frac{c}{m} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -100  -10 \\end{pmatrix}.\n$$\n时间步长为$\\Delta t = 0.3$，所以$\\frac{\\Delta t}{2} = 0.15$。放大矩阵$G$由下式给出\n$$\nG = \\left(I - \\frac{\\Delta t}{2}A\\right)^{-1}\\left(I + \\frac{\\Delta t}{2}A\\right).\n$$\n我们定义$B_{-} = I - \\frac{\\Delta t}{2}A$和$B_{+} = I + \\frac{\\Delta t}{2}A$。\n$$\n\\frac{\\Delta t}{2}A = 0.15 \\begin{pmatrix} 0  1 \\\\ -100  -10 \\end{pmatrix} = \\begin{pmatrix} 0  0.15 \\\\ -15  -1.5 \\end{pmatrix}.\n$$\n所以，\n$$\nB_{+} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + \\begin{pmatrix} 0  0.15 \\\\ -15  -1.5 \\end{pmatrix} = \\begin{pmatrix} 1  0.15 \\\\ -15  -0.5 \\end{pmatrix}.\n$$\n$$\nB_{-} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} - \\begin{pmatrix} 0  0.15 \\\\ -15  -1.5 \\end{pmatrix} = \\begin{pmatrix} 1  -0.15 \\\\ 15  2.5 \\end{pmatrix}.\n$$\n为了求$H = G^{\\top}G$的行列式，我们使用性质$\\det(H) = \\det(G^{\\top})\\det(G) = (\\det(G))^2$。\n$$\n\\det(G) = \\det(B_{-}^{-1}B_{+}) = \\frac{\\det(B_{+})}{\\det(B_{-})}.\n$$\n$B_{+}$和$B_{-}$的行列式为：\n$$\n\\det(B_{+}) = (1)(-0.5) - (0.15)(-15) = -0.5 + 2.25 = 1.75 = \\frac{7}{4}.\n$$\n$$\n\\det(B_{-}) = (1)(2.5) - (-0.15)(15) = 2.5 + 2.25 = 4.75 = \\frac{19}{4}.\n$$\n因此，$G$的行列式为：\n$$\n\\det(G) = \\frac{7/4}{19/4} = \\frac{7}{19}.\n$$\n而$H = G^{\\top}G$的行列式为：\n$$\n\\det(H) = \\left(\\frac{7}{19}\\right)^2 = \\frac{49}{361}.\n$$\n接下来，我们计算$H$的迹。$G^{\\top}G$的迹等于$G$的弗罗贝尼乌斯范数的平方，即$\\mathrm{tr}(G^{\\top}G) = \\|G\\|_{\\mathrm{F}}^2 = \\sum_{i,j} G_{ij}^2$。为此，我们必须首先计算矩阵$G$。\n我们需要$B_{-}$的逆矩阵：\n$$\nB_{-}^{-1} = \\frac{1}{\\det(B_{-})} \\begin{pmatrix} 2.5  0.15 \\\\ -15  1 \\end{pmatrix} = \\frac{1}{4.75} \\begin{pmatrix} 2.5  0.15 \\\\ -15  1 \\end{pmatrix} = \\frac{4}{19} \\begin{pmatrix} 2.5  0.15 \\\\ -15  1 \\end{pmatrix}.\n$$\n现在我们计算$G = B_{-}^{-1}B_{+}$：\n$$\nG = \\frac{4}{19} \\begin{pmatrix} 2.5  0.15 \\\\ -15  1 \\end{pmatrix} \\begin{pmatrix} 1  0.15 \\\\ -15  -0.5 \\end{pmatrix} = \\frac{4}{19} \\begin{pmatrix} (2.5)(1)+(0.15)(-15)  & (2.5)(0.15)+(0.15)(-0.5) \\\\ (-15)(1)+(1)(-15)  & (-15)(0.15)+(1)(-0.5) \\end{pmatrix}\n$$\n$$\nG = \\frac{4}{19} \\begin{pmatrix} 2.5 - 2.25  & 0.375 - 0.075 \\\\ -15 - 15  & -2.25 - 0.5 \\end{pmatrix} = \\frac{4}{19} \\begin{pmatrix} 0.25  & 0.3 \\\\ -30  & -2.75 \\end{pmatrix}.\n$$\n为了便于精确计算，我们将小数转换为分数：$0.25=\\frac{1}{4}$，$0.3=\\frac{3}{10}$，$-2.75=-\\frac{11}{4}$。\n$$\nG = \\frac{4}{19} \\begin{pmatrix} \\frac{1}{4}  & \\frac{3}{10} \\\\ -30  & -\\frac{11}{4} \\end{pmatrix} = \\begin{pmatrix} \\frac{4}{19}\\frac{1}{4}  & \\frac{4}{19}\\frac{3}{10} \\\\ \\frac{4}{19}(-30)  & \\frac{4}{19}(-\\frac{11}{4}) \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{19}  & \\frac{6}{95} \\\\ -\\frac{120}{19}  & -\\frac{11}{19} \\end{pmatrix}.\n$$\n现在我们计算$\\mathrm{tr}(H) = \\|G\\|_{\\mathrm{F}}^2$：\n$$\n\\mathrm{tr}(H) = \\left(\\frac{1}{19}\\right)^2 + \\left(\\frac{6}{95}\\right)^2 + \\left(-\\frac{120}{19}\\right)^2 + \\left(-\\frac{11}{19}\\right)^2.\n$$\n由于$95 = 5 \\times 19$，我们有$95^2 = 25 \\times 19^2 = 25 \\times 361 = 9025$。\n$$\n\\mathrm{tr}(H) = \\frac{1}{361} + \\frac{36}{9025} + \\frac{14400}{361} + \\frac{121}{361} = \\frac{1+14400+121}{361} + \\frac{36}{9025}\n$$\n$$\n\\mathrm{tr}(H) = \\frac{14522}{361} + \\frac{36}{9025} = \\frac{14522 \\times 25}{361 \\times 25} + \\frac{36}{9025} = \\frac{363050}{9025} + \\frac{36}{9025} = \\frac{363086}{9025}.\n$$\n$H$的特征值$\\lambda$满足$\\lambda^2 - \\mathrm{tr}(H)\\lambda + \\det(H) = 0$：\n$$\n\\lambda^2 - \\frac{363086}{9025}\\lambda + \\frac{49}{361} = 0.\n$$\n使用二次公式，$\\lambda = \\frac{-\\beta \\pm \\sqrt{\\beta^2 - 4\\gamma}}{2}$，其中$\\beta = -\\frac{363086}{9025}$，$\\gamma = \\frac{49}{361}$：\n$$\n\\lambda = \\frac{1}{2} \\left(\\frac{363086}{9025} \\pm \\sqrt{\\left(\\frac{363086}{9025}\\right)^2 - 4\\left(\\frac{49}{361}\\right)}\\right).\n$$\n数值计算各项：\n$\\mathrm{tr}(H) = \\frac{363086}{9025} \\approx 40.23113573$\n$\\det(H) = \\frac{49}{361} \\approx 0.13573407$\n$$\n\\lambda = \\frac{1}{2} \\left(40.23113573 \\pm \\sqrt{(40.23113573)^2 - 4(0.13573407)}\\right)\n$$\n$$\n\\lambda = \\frac{1}{2} \\left(40.23113573 \\pm \\sqrt{1618.544257 - 0.542936}\\right)\n$$\n$$\n\\lambda = \\frac{1}{2} \\left(40.23113573 \\pm \\sqrt{1618.001321}\\right)\n$$\n$$\n\\lambda = \\frac{1}{2} \\left(40.23113573 \\pm 40.22438708\\right).\n$$\n两个特征值为：\n$$\n\\lambda_1 = \\frac{1}{2} (40.23113573 + 40.22438708) = \\frac{80.45552281}{2} = 40.227761405.\n$$\n$$\n\\lambda_2 = \\frac{1}{2} (40.23113573 - 40.22438708) = \\frac{0.00674865}{2} = 0.003374325.\n$$\n最大单步放大因子是较大的特征值，$\\alpha_{\\max} = \\lambda_{\\max}(G^{\\top}G) = \\lambda_1$。\n$$\n\\alpha_{\\max} \\approx 40.227761405.\n$$\n四舍五入到四位有效数字，我们得到$40.23$。\n这个结果远大于$1$，表明尽管梯形法则是$A$-稳定的（$G$的谱半径为$\\rho(G)=\\sqrt{7/19} < 1$），但对于这个时间步长的选择，它在欧几里得范数下不是严格收缩的，并且可以瞬时放大类能量泛函$E_{\\mathrm{euc}}$。", "answer": "$$\\boxed{40.23}$$", "id": "3608634"}, {"introduction": "最后的这个实践练习将从解析推导转向计算实现，这是计算力学领域的一项核心技能。你将实现并比较一个保能量的积分器（隐式中点法）和一个耗散的积分器（后向欧拉法），观察它们在线性和几何非线性系统上的不同行为。通过在模拟环境中展示其在实践中的效果，本练习将巩固相关的理论概念。[@problem_id:3608605]", "problem": "考虑一维空间中的弹性动力学，并假设没有外力和阻尼。其基本依据是牛顿第二定律和机械能的定义。设广义位移为 $q(t)$，速度为 $v(t) = \\dot{q}(t)$，质量为 $m \\gt 0$。运动方程为\n$$\nm \\, \\ddot{q}(t) + \\nabla V(q(t)) = 0,\n$$\n总机械能为\n$$\nE(t) = \\tfrac{1}{2} m \\, v(t)^2 + V(q(t)).\n$$\n你将比较由两种隐式时间积分器应用于两个系统（一个线性保守系统和一个源于有限应变的几何非线性系统）所产生的离散能量演化 $E^{n+1} - E^n$。\n\n待实现的时间积分器：\n- 后向欧拉法（完全隐式），应用于 $[q, v]$ 的一阶系统：\n  - 步长为 $\\Delta t$ 的离散方程：\n    - 位置更新约束使用前一步的速度 $v^{n+1}$。\n    - 动量平衡使用在 $q^{n+1}$ 处计算的内力。\n- 隐式中点法（也称为两阶段 Gauss–Legendre 方法）：\n  - 步长为 $\\Delta t$ 的离散方程：\n    - 位置更新使用中点速度。\n    - 动量平衡使用在中点构型处计算的内力。\n\n当力为非线性时，两种格式在每一步都必须通过一个一致的非线性求解器来求解。你必须实现一个带有解析推导雅可比矩阵的 Newton–Raphson 方法。雅可比矩阵必须通过对离散残差相对于新时间步的未知数求导得出。当残差的欧几里得范数小于 $10^{-14}$ 或达到 $50$ 次迭代时停止牛顿迭代，以先到者为准。如果牛顿法未能收敛，你的代码仍应使用最后一次迭代的结果返回一个值，以确保程序始终能运行到完成。全程使用无量纲单位；不应报告任何物理单位。\n\n待模拟的系统：\n- 线性弹性振子：\n  - 势能 $V(q) = \\tfrac{1}{2} k q^2$，刚度 $k \\gt 0$。\n  - 内力 $\\nabla V(q) = k q$。\n  - 这是一个线性保守系统。\n- 几何非线性有限应变杆（均匀拉伸下的一维可压缩 neo-Hookean 模型）：\n  - 设参考长度为 $L_0 \\gt 0$，拉伸比为 $\\lambda = 1 + q/L_0$，应变能密度为\n    $$\n    \\Psi(\\lambda) = \\tfrac{1}{2} \\mu \\left(\\lambda^2 - 2 \\ln \\lambda - 1\\right) + \\tfrac{1}{2} \\kappa (\\ln \\lambda)^2,\n    $$\n    其中剪切模量 $\\mu \\gt 0$，体积模量 $\\kappa \\gt 0$。\n  - 设横截面积为 $A = 1$，定义总势能为 $V(q) = A L_0 \\Psi(\\lambda)$。\n  - 内力为 $\\nabla V(q) = A \\, \\Psi'(\\lambda)$，切线刚度为 $\\nabla^2 V(q) = A \\, \\Psi''(\\lambda) / L_0$，其中\n    $$\n    \\Psi'(\\lambda) = \\mu \\left(\\lambda - \\lambda^{-1}\\right) + \\kappa \\, \\frac{\\ln \\lambda}{\\lambda}, \\quad\n    \\Psi''(\\lambda) = \\mu \\left(1 + \\lambda^{-2}\\right) + \\kappa \\, \\frac{1 - \\ln \\lambda}{\\lambda^2}.\n    $$\n  - 仅限于 $\\lambda \\gt 0$ 的构型。\n\n初始条件和能量计算：\n- 对于每次模拟，使用给定的 $(q^0, v^0)$ 进行初始化。\n- 在每个时间步，计算出 $(q^{n+1}, v^{n+1})$ 后，计算离散能量差 $\\Delta E^n = E^{n+1} - E^n$。\n- 为评估守恒性或耗散性，对计算出的 $\\Delta E^n$ 序列进行统计评估。\n\n测试套件：\n实现以下四个测试用例。所有参数均为无量纲。\n\n- 测试 $1$（线性，隐式中点法）：\n  - 参数：$m = 1$，$k = 10$，$\\Delta t = 0.5$，步数 $N = 40$，初始条件 $q^0 = 0.3$，$v^0 = -0.1$。\n  - 计算最大绝对步长能量变化 $\\max_n |\\Delta E^n|$。\n  - 输出布尔值 $\\mathrm{T}_1$：如果 $\\max_n |\\Delta E^n| \\le 10^{-10}$ 则为 True，否则为 False。\n\n- 测试 $2$（线性，后向欧拉法）：\n  - 参数：$m = 1$，$k = 10$，$\\Delta t = 2.0$，步数 $N = 25$，初始条件 $q^0 = 0.3$，$v^0 = -0.1$。\n  - 计算最大步长能量增量 $\\max_n \\Delta E^n$。\n  - 输出布尔值 $\\mathrm{T}_2$：如果 $\\max_n \\Delta E^n \\le 10^{-12}$ 则为 True，否则为 False。\n\n- 测试 $3$（几何非线性，隐式中点法）：\n  - 参数：$m = 1$，$\\mu = 2$，$\\kappa = 100$，$L_0 = 1$，$\\Delta t = 0.1$，步数 $N = 60$，初始条件 $q^0 = 0.2$，$v^0 = 0.0$。\n  - 计算 $\\max_n |\\Delta E^n|$。\n  - 输出布尔值 $\\mathrm{T}_3$：如果 $\\max_n |\\Delta E^n| \\gt 10^{-12}$（即，非精确能量守恒）则为 True，否则为 False。\n\n- 测试 $4$（几何非线性，后向欧拉法）：\n  - 参数：$m = 1$，$\\mu = 2$，$\\kappa = 100$，$L_0 = 1$，$\\Delta t = 0.3$，$N = 50$，初始条件 $q^0 = 0.2$，$v^0 = 0.0$。\n  - 计算 $\\max_n \\Delta E^n$。\n  - 输出布尔值 $\\mathrm{T}_4$：如果 $\\max_n \\Delta E^n \\le 10^{-12}$ 则为 True，否则为 False。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含四个布尔结果，以逗号分隔并用方括号括起来，顺序为 $[\\mathrm{T}_1,\\mathrm{T}_2,\\mathrm{T}_3,\\mathrm{T}_4]$。例如，输出可能看起来像 \"[True,True,False,True]\"。\n- 所有计算必须以无量纲单位进行；不打印任何物理单位。", "solution": "我们从单自由度质量为 $m \\gt 0$ 的牛顿第二定律开始：\n$$\nm \\, \\ddot{q}(t) + \\nabla V(q(t)) = 0.\n$$\n定义状态向量 $y(t) = \\begin{bmatrix} q(t) \\\\ v(t) \\end{bmatrix}$，其中 $v(t) = \\dot{q}(t)$。那么一阶系统是\n$$\n\\dot{y}(t) = f(y(t)) = \\begin{bmatrix} v(t) \\\\ -\\frac{1}{m} \\, \\nabla V(q(t)) \\end{bmatrix}.\n$$\n机械能为\n$$\nE(t) = \\tfrac{1}{2} m \\, v(t)^2 + V(q(t)).\n$$\n我们考虑两种时间积分器。\n\n隐式中点法：\n从 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$ 的隐式中点法规则是\n$$\ny^{n+1} = y^n + \\Delta t \\, f\\Big(\\tfrac{1}{2}\\big(y^n + y^{n+1}\\big)\\Big).\n$$\n写出分量形式得到耦合方程组\n$$\nq^{n+1} - q^n - \\Delta t \\, \\tfrac{1}{2}\\big(v^n + v^{n+1}\\big) = 0,\n$$\n$$\nv^{n+1} - v^n + \\Delta t \\, \\frac{1}{m} \\, \\nabla V\\Big(\\tfrac{1}{2}\\big(q^n + q^{n+1}\\big)\\Big) = 0.\n$$\n对于非线性的 $\\nabla V$，我们通过 Newton–Raphson 方法求解 $\\big(q^{n+1}, v^{n+1}\\big)$。定义残差\n$$\nR(q^{n+1}, v^{n+1}) =\n\\begin{bmatrix}\nq^{n+1} - q^n - \\Delta t \\, \\tfrac{1}{2}\\big(v^n + v^{n+1}\\big) \\\\\nv^{n+1} - v^n + \\Delta t \\, \\tfrac{1}{m} \\, \\nabla V\\big(q^{\\mathrm{mid}}\\big)\n\\end{bmatrix}, \\quad\nq^{\\mathrm{mid}} = \\tfrac{1}{2}\\big(q^n + q^{n+1}\\big).\n$$\n雅可比矩阵为\n$$\nJ = \\frac{\\partial R}{\\partial (q^{n+1}, v^{n+1})} =\n\\begin{bmatrix}\n1 & -\\tfrac{1}{2}\\Delta t \\\\\n\\tfrac{1}{2}\\Delta t \\, \\tfrac{1}{m} \\, \\nabla^2 V\\big(q^{\\mathrm{mid}}\\big) & 1\n\\end{bmatrix}.\n$$\n牛顿更新求解 $J \\, \\delta = -R$ 并设置 $(q^{n+1}, v^{n+1}) \\leftarrow (q^{n+1}, v^{n+1}) + \\delta$ 直至收敛。\n\n后向欧拉法：\n后向欧拉法是\n$$\ny^{n+1} = y^n + \\Delta t \\, f(y^{n+1}),\n$$\n其分量形式为\n$$\nq^{n+1} - q^n - \\Delta t \\, v^{n+1} = 0,\n$$\n$$\nv^{n+1} - v^n + \\Delta t \\, \\frac{1}{m} \\, \\nabla V(q^{n+1}) = 0.\n$$\n定义残差\n$$\nR(q^{n+1}, v^{n+1}) =\n\\begin{bmatrix}\nq^{n+1} - q^n - \\Delta t \\, v^{n+1} \\\\\nv^{n+1} - v^n + \\Delta t \\, \\tfrac{1}{m} \\, \\nabla V(q^{n+1})\n\\end{bmatrix},\n$$\n其雅可比矩阵为\n$$\nJ =\n\\begin{bmatrix}\n1 & -\\Delta t \\\\\n\\Delta t \\, \\tfrac{1}{m} \\, \\nabla^2 V(q^{n+1}) & 1\n\\end{bmatrix}.\n$$\n同样，我们求解 $J \\, \\delta = -R$ 进行牛顿更新。\n\n线性保守情况下的能量特性：\n设 $V(q) = \\tfrac{1}{2} k q^2$，则 $\\nabla V(q) = k q$ 且 $\\nabla^2 V(q) = k$。写成一阶形式\n$$\n\\dot{y} = A y, \\quad A = \\begin{bmatrix} 0 & 1 \\\\ -\\tfrac{k}{m} & 0 \\end{bmatrix}.\n$$\n隐式中点法步进变为\n$$\n\\big(I - \\tfrac{\\Delta t}{2} A\\big) y^{n+1} = \\big(I + \\tfrac{\\Delta t}{2} A\\big) y^n,\n$$\n即 $y^{n+1} = M y^n$，其中 $M = \\big(I - \\tfrac{\\Delta t}{2} A\\big)^{-1}\\big(I + \\tfrac{\\Delta t}{2} A\\big)$ 为 Cayley 变换。能量可以写成二次型 $E = \\tfrac{1}{2} y^\\top H y$，其中\n$$\nH = \\begin{bmatrix} k & 0 \\\\ 0 & m \\end{bmatrix}.\n$$\n可以验证 $A$ 是 $H$-斜对称的，即 $A^\\top H + H A = 0$。这意味着 $M^\\top H M = H$，因此\n$$\nE^{n+1} = \\tfrac{1}{2} (y^{n})^\\top M^\\top H M y^n = \\tfrac{1}{2} (y^{n})^\\top H y^n = E^n,\n$$\n所以隐式中点法对于任意 $\\Delta t$ 都精确地守恒二次能量。在浮点运算中，偏差处于舍入误差水平。\n\n对于后向欧拉法，步进为 $(I - \\Delta t A) y^{n+1} = y^n$，或 $y^{n+1} = B y^n$，其中 $B = (I - \\Delta t A)^{-1}$。直接计算表明\n$$\nE^{n+1} - E^n = - \\tfrac{1}{2} \\Delta t \\, (y^{n+1} + y^n)^\\top (A^\\top H + H A) (y^{n+1} - y^n) - \\tfrac{1}{2} \\Delta t^2 \\, (y^{n+1})^\\top A^\\top H A \\, y^{n+1}.\n$$\n使用 $A^\\top H + H A = 0$ 且对于 $k, m \\gt 0$，$A^\\top H A$ 是正定的，可以得到\n$$\nE^{n+1} - E^n = - \\tfrac{1}{2} \\Delta t^2 \\, (y^{n+1})^\\top A^\\top H A \\, y^{n+1} \\le 0,\n$$\n仅在平凡状态下等式成立。因此，后向欧拉法在线性保守振子上是无条件耗散的：对于任何 $\\Delta t \\gt 0$，能量单调递减。\n\n几何非线性：\n对于可压缩 neo-Hookean 杆，设 $\\lambda = 1 + q/L_0$ 且\n$$\n\\Psi(\\lambda) = \\tfrac{1}{2} \\mu \\left(\\lambda^2 - 2 \\ln \\lambda - 1\\right) + \\tfrac{1}{2} \\kappa (\\ln \\lambda)^2,\n$$\n所以 $V(q) = A L_0 \\Psi(\\lambda)$，其中 $A = 1$，且\n$$\n\\nabla V(q) = \\Psi'(\\lambda), \\quad \\nabla^2 V(q) = \\frac{\\Psi''(\\lambda)}{L_0},\n$$\n其中\n$$\n\\Psi'(\\lambda) = \\mu \\left(\\lambda - \\lambda^{-1}\\right) + \\kappa \\, \\frac{\\ln \\lambda}{\\lambda}, \\quad\n\\Psi''(\\lambda) = \\mu \\left(1 + \\lambda^{-2}\\right) + \\kappa \\, \\frac{1 - \\ln \\lambda}{\\lambda^2}.\n$$\n对于这个非线性保守系统，隐式中点法是辛的，并能精确保持所有二次不变量，但除非 $V$ 是二次的，否则它不能保持真正的非线性能量 $E$。因此，可以预期每步在 $E^{n+1} - E^n$ 中存在阶为 $\\mathcal{O}(\\Delta t^3)$ 的有界振荡偏差，并且在长时间内存在阶为 $\\mathcal{O}(\\Delta t^2)$ 的有界能量误差，而不是精确守恒。后向欧拉法仍然是一种强耗散方法，对于这些参数通常会得到 $E^{n+1} - E^n \\le 0$，尽管对于一般的非线性哈密顿系统，严格的每步单调递减并不能由一个普适的不变量来保证，但在这里可以观察到，这是由于完全隐式更新引入的数值粘性以及 $V$ 在工作范围附近的凸性。\n\n算法设计：\n- 将势能实现为提供 $V(q)$、$\\nabla V(q)$ 和 $\\nabla^2 V(q)$ 的对象。\n- 为隐式中点法和后向欧拉法，使用上述残差和雅可比矩阵为每个时间步实现一个 Newton–Raphson 求解器。\n- 对于每次模拟，累积 $E^n$ 和 $\\Delta E^n = E^{n+1} - E^n$。\n- 对于线性中点法测试，计算 $\\max_n |\\Delta E^n|$ 并与 $10^{-10}$ 比较。\n- 对于线性后向欧拉法测试，计算 $\\max_n \\Delta E^n$ 并断言其 $\\le 10^{-12}$。\n- 对于非线性中点法测试，检查 $\\max_n |\\Delta E^n| \\gt 10^{-12}$ 以确认在几何非线性下精确守恒性不再保持。\n- 对于非线性后向欧拉法测试，计算 $\\max_n \\Delta E^n$ 并断言其 $\\le 10^{-12}$。\n\n测试套件参数：\n- 测试 $1$：$m = 1$，$k = 10$，$\\Delta t = 0.5$，$N = 40$，$q^0 = 0.3$，$v^0 = -0.1$。\n- 测试 $2$：$m = 1$，$k = 10$，$\\Delta t = 2.0$，$N = 25$，$q^0 = 0.3$，$v^0 = -0.1$。\n- 测试 $3$：$m = 1$，$\\mu = 2$，$\\kappa = 100$，$L_0 = 1$，$\\Delta t = 0.1$，$N = 60$，$q^0 = 0.2$，$v0 = 0.0$。\n- 测试 $4$：$m = 1$，$\\mu = 2$，$\\kappa = 100$，$L_0 = 1$，$\\Delta t = 0.3$，$N = 50$，$q^0 = 0.2$，$v0 = 0.0$。\n\n最终输出：\n- 生成一行包含 $[\\mathrm{T}_1,\\mathrm{T}_2,\\mathrm{T}_3,\\mathrm{T}_4]$ 布尔值的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Potentials with energy, gradient, and Hessian\nclass LinearPotential:\n    def __init__(self, k: float):\n        self.k = float(k)\n\n    def energy(self, q: float) -> float:\n        return 0.5 * self.k * q * q\n\n    def grad(self, q: float) -> float:\n        return self.k * q\n\n    def hess(self, q: float) -> float:\n        return self.k\n\n\nclass NeoHookean1D:\n    def __init__(self, mu: float, kappa: float, L0: float):\n        self.mu = float(mu)\n        self.kappa = float(kappa)\n        self.L0 = float(L0)\n\n    def _lambda(self, q: float) -> float:\n        return 1.0 + q / self.L0\n\n    def energy(self, q: float) -> float:\n        lam = self._lambda(q)\n        if lam = 0.0:\n            # Penalize non-physical states; return large energy to discourage\n            return np.inf\n        # A = 1, total V = A * L0 * Psi(lam) = L0 * Psi(lam)\n        psi = 0.5 * self.mu * (lam * lam - 2.0 * np.log(lam) - 1.0) + 0.5 * self.kappa * (np.log(lam) ** 2)\n        return self.L0 * psi\n\n    def grad(self, q: float) -> float:\n        lam = self._lambda(q)\n        if lam = 0.0:\n            # Large force driving back to admissible region\n            return np.sign(q) * np.inf\n        # dV/dq = A * Psi'(lam) = Psi'(lam) since A=1\n        psi_p = self.mu * (lam - 1.0 / lam) + self.kappa * (np.log(lam) / lam)\n        return psi_p\n\n    def hess(self, q: float) -> float:\n        lam = self._lambda(q)\n        if lam = 0.0:\n            return np.inf\n        # d2V/dq2 = A * Psi''(lam) / L0 = Psi''(lam) / L0\n        psi_pp = self.mu * (1.0 + 1.0 / (lam * lam)) + self.kappa * ((1.0 - np.log(lam)) / (lam * lam))\n        return psi_pp / self.L0\n\n\ndef newton_solve_midpoint(qn, vn, dt, m, potential, tol=1e-14, maxit=50):\n    # Unknowns: q1, v1\n    q1 = qn\n    v1 = vn\n    for _ in range(maxit):\n        qmid = 0.5 * (qn + q1)\n        vmid = 0.5 * (vn + v1)\n        # Residual\n        r1 = q1 - qn - dt * vmid\n        gmid = potential.grad(qmid)\n        hmid = potential.hess(qmid)\n        r2 = v1 - vn + dt * (gmid / m)\n        # Check convergence\n        resn = np.sqrt(r1 * r1 + r2 * r2)\n        if not np.isfinite(resn):\n            break\n        if resn  tol:\n            break\n        # Jacobian\n        # dr1/dq1 = 1, dr1/dv1 = -0.5*dt\n        # dr2/dq1 = dt * (0.5 * hmid / m), dr2/dv1 = 1\n        a11 = 1.0\n        a12 = -0.5 * dt\n        a21 = dt * (0.5 * hmid / m)\n        a22 = 1.0\n        # Solve 2x2 linear system J * dx = -r\n        det = a11 * a22 - a12 * a21\n        if det == 0 or not np.isfinite(det):\n            break\n        inv11 = a22 / det\n        inv12 = -a12 / det\n        inv21 = -a21 / det\n        inv22 = a11 / det\n        dx1 = -(inv11 * r1 + inv12 * r2)\n        dx2 = -(inv21 * r1 + inv22 * r2)\n        q1 += dx1\n        v1 += dx2\n        # safeguard: stay in admissible region for neo-Hookean\n        # if lambda = 0, backtrack a bit\n        if isinstance(potential, NeoHookean1D):\n            lam = potential._lambda(q1)\n            if lam = 0.0 or not np.isfinite(lam):\n                # simple backtracking\n                q1 = 0.5 * (q1 + qn)\n    return q1, v1\n\n\ndef newton_solve_backward_euler(qn, vn, dt, m, potential, tol=1e-14, maxit=50):\n    q1 = qn\n    v1 = vn\n    for _ in range(maxit):\n        g1 = potential.grad(q1)\n        h1 = potential.hess(q1)\n        r1 = q1 - qn - dt * v1\n        r2 = v1 - vn + dt * (g1 / m)\n        resn = np.sqrt(r1 * r1 + r2 * r2)\n        if not np.isfinite(resn):\n            break\n        if resn  tol:\n            break\n        # Jacobian\n        # dr1/dq1 = 1, dr1/dv1 = -dt\n        # dr2/dq1 = dt * (h1 / m), dr2/dv1 = 1\n        a11 = 1.0\n        a12 = -dt\n        a21 = dt * (h1 / m)\n        a22 = 1.0\n        det = a11 * a22 - a12 * a21\n        if det == 0 or not np.isfinite(det):\n            break\n        inv11 = a22 / det\n        inv12 = -a12 / det\n        inv21 = -a21 / det\n        inv22 = a11 / det\n        dx1 = -(inv11 * r1 + inv12 * r2)\n        dx2 = -(inv21 * r1 + inv22 * r2)\n        q1 += dx1\n        v1 += dx2\n        if isinstance(potential, NeoHookean1D):\n            lam = potential._lambda(q1)\n            if lam = 0.0 or not np.isfinite(lam):\n                q1 = 0.5 * (q1 + qn)\n    return q1, v1\n\n\ndef simulate(method, potential, m, dt, N, q0, v0):\n    q = q0\n    v = v0\n    E_hist = []\n    dE_hist = []\n    # initial energy\n    E = 0.5 * m * v * v + potential.energy(q)\n    E_hist.append(E)\n    for _ in range(N):\n        if method == \"midpoint\":\n            q_new, v_new = newton_solve_midpoint(q, v, dt, m, potential)\n        elif method == \"backward_euler\":\n            q_new, v_new = newton_solve_backward_euler(q, v, dt, m, potential)\n        else:\n            raise ValueError(\"Unknown method\")\n        E_new = 0.5 * m * v_new * v_new + potential.energy(q_new)\n        dE = E_new - E\n        dE_hist.append(dE)\n        q, v, E = q_new, v_new, E_new\n        E_hist.append(E)\n    return np.array(E_hist), np.array(dE_hist)\n\n\ndef solve():\n    results = []\n\n    # Tolerances\n    tol_conserve = 1e-10\n    tol_dissip = 1e-12\n    tol_exact_conserve = 1e-12\n\n    # Test 1: Linear, implicit midpoint\n    m = 1.0\n    k = 10.0\n    dt = 0.5\n    N = 40\n    q0 = 0.3\n    v0 = -0.1\n    pot_lin = LinearPotential(k)\n    _, dE = simulate(\"midpoint\", pot_lin, m, dt, N, q0, v0)\n    T1 = np.max(np.abs(dE)) = tol_conserve\n    results.append(bool(T1))\n\n    # Test 2: Linear, backward Euler\n    dt2 = 2.0\n    N2 = 25\n    _, dE2 = simulate(\"backward_euler\", pot_lin, m, dt2, N2, q0, v0)\n    T2 = np.max(dE2) = tol_dissip\n    results.append(bool(T2))\n\n    # Test 3: Nonlinear, implicit midpoint\n    mu = 2.0\n    kappa = 100.0\n    L0 = 1.0\n    pot_nl = NeoHookean1D(mu, kappa, L0)\n    dt3 = 0.1\n    N3 = 60\n    q0_nl = 0.2\n    v0_nl = 0.0\n    _, dE3 = simulate(\"midpoint\", pot_nl, m, dt3, N3, q0_nl, v0_nl)\n    T3 = np.max(np.abs(dE3)) > tol_exact_conserve\n    results.append(bool(T3))\n\n    # Test 4: Nonlinear, backward Euler\n    dt4 = 0.3\n    N4 = 50\n    _, dE4 = simulate(\"backward_euler\", pot_nl, m, dt4, N4, q0_nl, v0_nl)\n    T4 = np.max(dE4) = tol_dissip\n    results.append(bool(T4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3608605"}]}