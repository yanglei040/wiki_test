{"hands_on_practices": [{"introduction": "特征函数的一个基本应用是恢复随机变量的概率分布。对于取整数值的离散随机变量，其特征函数在推导和计算上都表现出与傅里叶级数深刻的类比关系。本练习将指导您从第一性原理出发，推导离散变量的概率质量函数（PMF）的反演公式，并深入探讨当使用快速傅里叶变换（FFT）进行数值计算时所面临的核心挑战——混叠效应（aliasing）[@problem_id:3293797]。通过亲手实现并对比几种不同尾部行为的分布，您将直观地理解数值反演的精度如何依赖于您对分布支撑集和网格尺寸的判断。", "problem": "考虑一个支撑集为整数的实值随机变量 $X$，其概率质量函数为 $p_k = \\mathbb{P}\\{X = k\\}$（其中 $k \\in \\mathbb{Z}$），特征函数为 $\\varphi_X(t) = \\mathbb{E}\\left[e^{\\mathrm{i} t X}\\right]$。从特征函数的基本定义以及复指数在单个周期上的正交性出发，推导出一个用 $\\varphi_X(t)$ 表示 $p_k$ 的显式积分表达式，积分区间为一个长度为 $2\\pi$ 的周期（角度以弧度为单位）。推导过程必须从第一性原理出发：期望的线性性质、$\\sum_{k \\in \\mathbb{Z}} p_k e^{\\mathrm{i} t k}$ 对所有实数 $t$ 的绝对收敛性，以及复指数基在有限区间上的正交性。\n\n然后，分析在一个包含 $N$ 个点的均匀网格上，使用梯形法则近似该反演积分所带来的影响。通过仅使用离散求和与 $\\varphi_X(t)$ 的周期性进行代数变换，证明所得到的数值反演与逆离散傅里叶变换一致，并产生一个模 $N$ 的概率质量函数的周期化版本。解释为什么这会导致混叠，并当 $X$ 的支撑集无界时，明确地刻画出数值反演中哪些 $p_k$ 的值被叠加在一起，从而描述混叠现象。\n\n实现任务。编写一个完整的、可运行的程序，该程序：\n- 在一个等距网格 $t_j = \\frac{2\\pi j}{N}$（其中 $j \\in \\{0,1,\\dots,N-1\\}$，角度以弧度为单位）上对 $\\varphi_X(t)$ 进行采样。\n- 通过梯形法则所引出的逆离散傅里叶变换进行数值反演，得到 $k \\in \\{0,1,\\dots,N-1\\}$ 范围内的估计值 $\\widehat{p}_k$，并通过对离散谱进行标准平移实现中心化，以得到对称整数范围内的估计值。\n- 对于每个测试分布，在与数值反演相同的索引范围内，使用闭式公式和经过充分测试的特殊函数计算真实的 $p_k$。\n- 对每个测试用例，报告一个定义为在比较的索引范围内的最大绝对差 $\\max_k \\left|\\widehat{p}_k - p_k\\right|$ 的混叠误差度量。\n\n使用以下参数值的测试套件，以确保覆盖紧支撑、轻尾、重尾和双向无限支撑的情况：\n- 测试 1（理想情况，紧支撑）：参数为 $n = 20$ 和 $p = 0.3$ 的二项分布，网格大小 $N = 64$。此处，当 $k \\in \\{0,1,\\dots,n\\}$ 时，$p_k = \\binom{n}{k} p^k (1-p)^{n-k}$，否则 $p_k = 0$；$\\varphi_X(t)$ 对应于二项分布的特征函数。\n- 测试 2（轻尾无限支撑）：参数为 $\\lambda = 8$ 的泊松分布，网格大小 $N = 64$。此处，当 $k \\in \\mathbb{Z}_{\\ge 0}$ 时，$p_k = e^{-\\lambda} \\frac{\\lambda^k}{k!}$，否则 $p_k = 0$；$\\varphi_X(t)$ 对应于泊松分布的特征函数。\n- 测试 3（导致混叠的重尾无限支撑）：参数为 $\\lambda = 30$ 的泊松分布，网格大小 $N = 64$。\n- 测试 4（在小网格上出现混叠的双向无限支撑）：参数为 $\\lambda_1 = 20$ 和 $\\lambda_2 = 10$ 的斯凯勒姆分布，网格大小 $N = 64$。此处，对于 $k \\in \\mathbb{Z}$，$p_k = e^{-(\\lambda_1+\\lambda_2)} \\left(\\frac{\\lambda_1}{\\lambda_2}\\right)^{k/2} I_{|k|}\\!\\left(2\\sqrt{\\lambda_1 \\lambda_2}\\right)$，其中 $I_\\nu(\\cdot)$ 是第一类修正贝塞尔函数；$\\varphi_X(t)$ 对应于斯凯勒姆分布的特征函数。\n- 测试 5（相同的双向无限支撑，使用更大网格以减少混叠）：参数为 $\\lambda_1 = 20$ 和 $\\lambda_2 = 10$ 的斯凯勒姆分布，网格大小 $N = 512$。\n\n对于测试 1-3，在索引范围 $k \\in \\{0,1,\\dots,N-1\\}$ 上进行比较；对于测试 4-5，在中心化的索引范围 $k \\in \\{-\\frac{N}{2}, -\\frac{N}{2}+1, \\dots, \\frac{N}{2}-1\\}$ 上进行比较。\n\n您的程序应生成单行输出，其中包含测试 1-5 的混叠误差度量，格式为一个用方括号括起来的逗号分隔的浮点数列表，例如 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_i$ 是如上定义的最大绝对差。不允许有其他输出。", "solution": "用户提供的问题是在概率论和数值方法领域中一个表述清晰且科学严谨的练习。它要求对离散随机变量的特征函数反演公式进行理论推导，分析其数值近似，并实现一个程序来量化几种标准分布下所产生的混叠误差。该问题是自洽的，没有矛盾或歧义。\n\n### 第1部分：反演公式的推导\n\n设 $X$ 是一个在整数集 $\\mathbb{Z}$ 上取值的随机变量，其概率质量函数（PMF）为 $p_k = \\mathbb{P}\\{X=k\\}$（其中 $k \\in \\mathbb{Z}$）。$X$ 的特征函数（CF），记为 $\\varphi_X(t)$，定义为 $e^{\\mathrm{i}tX}$ 的期望值：\n$$\n\\varphi_X(t) = \\mathbb{E}\\left[e^{\\mathrm{i}tX}\\right]\n$$\n根据无意识统计学家法则，对于离散随机变量，这变成了一个对其所有可能值按概率加权的求和：\n$$\n\\varphi_X(t) = \\sum_{m \\in \\mathbb{Z}} p_m e^{\\mathrm{i}tm}\n$$\n问题指出，该级数对所有实数 $t$ 绝对收敛，这是有保证的，因为 $|p_m e^{\\mathrm{i}tm}| = p_m$ 且 $\\sum_{m \\in \\mathbb{Z}} p_m = 1$。函数 $\\varphi_X(t)$ 是周期为 $2\\pi$ 的函数，因为 $e^{\\mathrm{i}(t+2\\pi)m} = e^{\\mathrm{i}tm}e^{\\mathrm{i}2\\pi m} = e^{\\mathrm{i}tm}$，其中 $m$ 是整数。\n\n我们的目标是通过反演这个关系来推导特定概率 $p_k$ 的显式表示。这可以通过利用复指数基函数 $\\{e^{\\mathrm{i}nt}\\}_{n \\in \\mathbb{Z}}$ 在任何长度为 $2\\pi$ 的区间（如 $[-\\pi, \\pi]$）上的正交性来实现。让我们考虑 $\\varphi_X(t)e^{-\\mathrm{i}tk}$ 在此区间上的积分，并乘以 $\\frac{1}{2\\pi}$：\n$$\n\\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} \\varphi_X(t) e^{-\\mathrm{i}tk} dt\n$$\n将 $\\varphi_X(t)$ 的级数定义代入积分中：\n$$\n\\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} \\left( \\sum_{m \\in \\mathbb{Z}} p_m e^{\\mathrm{i}tm} \\right) e^{-\\mathrm{i}tk} dt\n$$\n由于级数 $\\sum p_m e^{\\mathrm{i}tm}$ 绝对且一致收敛，我们可以交换积分和求和的顺序（根据富比尼-托内利定理或控制收敛定理）：\n$$\n\\sum_{m \\in \\mathbb{Z}} p_m \\left( \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} e^{\\mathrm{i}t(m-k)} dt \\right)\n$$\n求和内的积分是关键部分。设 $n = m-k$，它是一个整数。我们计算积分 $\\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} e^{\\mathrm{i}tn} dt$。\n- 如果 $n = 0$（即 $m=k$），被积函数为 $e^0 = 1$。积分为 $\\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} 1 \\, dt = \\frac{1}{2\\pi} (2\\pi) = 1$。\n- 如果 $n \\neq 0$，积分为 $\\frac{1}{2\\pi} \\left[ \\frac{e^{\\mathrm{i}tn}}{\\mathrm{i}n} \\right]_{-\\pi}^{\\pi} = \\frac{1}{2\\pi\\mathrm{i}n} (e^{\\mathrm{i}\\pi n} - e^{-\\mathrm{i}\\pi n})$。使用欧拉公式 $e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta} = 2\\mathrm{i}\\sin(\\theta)$，上式变为 $\\frac{2\\mathrm{i}\\sin(\\pi n)}{2\\pi\\mathrm{i}n} = \\frac{\\sin(\\pi n)}{\\pi n}$。由于 $n$ 是非零整数，$\\sin(\\pi n) = 0$，因此积分为 $0$。\n\n括号内的项是克罗内克δ函数，$\\delta_{mk}$。因此，该求和会坍缩，因为只有 $m=k$ 的项会保留下来：\n$$\n\\sum_{m \\in \\mathbb{Z}} p_m \\delta_{mk} = p_k \\cdot 1 + \\sum_{m \\neq k} p_m \\cdot 0 = p_k\n$$\n推导到此完成。概率质量函数的反演公式为：\n$$\np_k = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} \\varphi_X(t) e^{-\\mathrm{i}tk} dt\n$$\n由于被积函数具有 $2\\pi$ 周期性，积分可以在任何长度为 $2\\pi$ 的区间上进行，例如 $[0, 2\\pi]$。\n\n### 第2部分：数值反演与混叠\n\n我们现在分析使用梯形法则对反演积分进行近似的情况。我们使用区间 $[0, 2\\pi]$ 和一个包含 $N$ 个点的均匀网格 $t_j = \\frac{2\\pi j}{N}$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）。步长为 $\\Delta t = \\frac{2\\pi}{N}$。\n\n对于一个周期函数在一个周期上的积分，梯形法则简化为一个简单的矩形法则求和：\n$$\n\\int_{0}^{2\\pi} f(t) dt \\approx \\sum_{j=0}^{N-1} f(t_j) \\Delta t\n$$\n将此应用于 $p_k$ 的反演积分：\n$$\np_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\varphi_X(t) e^{-\\mathrm{i}tk} dt \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} \\varphi_X(t_j) e^{-\\mathrm{i}t_j k} \\Delta t\n$$\n我们用 $\\widehat{p}_k$ 表示数值估计值。代入 $\\Delta t = \\frac{2\\pi}{N}$ 和 $t_j = \\frac{2\\pi j}{N}$：\n$$\n\\widehat{p}_k = \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} \\varphi_X\\left(\\frac{2\\pi j}{N}\\right) e^{-\\mathrm{i}k \\frac{2\\pi j}{N}} \\left(\\frac{2\\pi}{N}\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} \\varphi_X\\left(t_j\\right) e^{-\\mathrm{i}\\frac{2\\pi jk}{N}}\n$$\n令 $\\Phi_j = \\varphi_X(t_j)$ 为特征函数的样本。数值估计值 $\\widehat{p}_k$ 的公式为：\n$$\n\\widehat{p}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} \\Phi_j e^{-\\mathrm{i}\\frac{2\\pi jk}{N}}\n$$\n该表达式与序列 $\\{\\Phi_j\\}$ 的离散傅里叶变换（DFT）成正比。具体来说，如果 DFT 定义为 $Y_k = \\sum_{j=0}^{N-1} y_j e^{-\\mathrm{i}2\\pi jk / N}$，则 $\\widehat{p}_k = \\frac{1}{N} \\text{DFT}(\\{\\Phi_j\\})_k$。这种结构通常在快速傅里叶变换（FFT）算法中实现。\n\n为了理解这种近似中的误差，我们将 $\\varphi_X(t_j)$ 的定义代回到 $\\widehat{p}_k$ 的公式中：\n$$\n\\widehat{p}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} \\left( \\sum_{m \\in \\mathbb{Z}} p_m e^{\\mathrm{i}t_j m} \\right) e^{-\\mathrm{i}t_j k} = \\frac{1}{N} \\sum_{j=0}^{N-1} \\sum_{m \\in \\mathbb{Z}} p_m e^{\\mathrm{i}\\frac{2\\pi j(m-k)}{N}}\n$$\n交换有限和与无限和的顺序：\n$$\n\\widehat{p}_k = \\sum_{m \\in \\mathbb{Z}} p_m \\left( \\frac{1}{N} \\sum_{j=0}^{N-1} e^{\\mathrm{i}\\frac{2\\pi j(m-k)}{N}} \\right)\n$$\n内部的和是一个单位根的几何级数。如果 $m-k$ 是 $N$ 的整数倍（即，对于某个整数 $q$，$m-k = qN$，或 $m \\equiv k \\pmod N$），则和为 $N$；否则为 $0$。因此，括号内的项在 $m \\equiv k \\pmod N$ 时为 $1$，否则为 $0$。对外层关于所有整数 $m$ 的求和，只有那些与 $k$ 模 $N$ 同余的 $m$ 才会产生贡献：\n$$\n\\widehat{p}_k = \\sum_{m \\in \\mathbb{Z} : m \\equiv k \\pmod N} p_m = \\sum_{q \\in \\mathbb{Z}} p_{k+qN}\n$$\n这就是对混叠误差的刻画。数值估计值 $\\widehat{p}_k$ 不等于 $p_k$，而是 $p_k$ 与其在索引 $k \\pm N$、$k \\pm 2N$ 等位置的所有“混叠副本”的概率之和。这种效应被称为周期化。\n$$\n\\widehat{p}_k = \\dots + p_{k-2N} + p_{k-N} + p_k + p_{k+N} + p_{k+2N} + \\dots\n$$\n混叠误差恰好是这些混叠项的总和：$\\widehat{p}_k - p_k = \\sum_{q \\in \\mathbb{Z}, q\\neq 0} p_{k+qN}$。对于一个支撑集为 $\\{0, 1, \\dots, n\\}$ 的紧支撑分布，如果我们选择 $N  n$，那么对于任何 $k \\in \\{0, \\dots, n\\}$，所有 $q \\neq 0$ 的项 $p_{k+qN}$ 均为零，因此没有混叠误差，$\\widehat{p}_k=p_k$。对于无限支撑的分布（例如泊松分布、斯凯勒姆分布），总会存在一些混叠。误差的大小取决于概率质量函数尾部的衰减速度。增加 $N$ 会使得混叠的副本 $p_{k \\pm N}, \\dots$ 距离更远，并且由于尾部概率更小，混叠误差会减小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import binom, gammaln, iv\nfrom scipy.stats import binom as binom_dist, poisson as poisson_dist\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating aliasing errors for five test cases.\n    \"\"\"\n\n    # Define characteristic function implementations\n    def cf_binomial(t, n, p):\n        return (1 - p + p * np.exp(1j * t))**n\n\n    def cf_poisson(t, lam):\n        return np.exp(lam * (np.exp(1j * t) - 1))\n\n    def cf_skellam(t, lam1, lam2):\n        return np.exp(lam1 * (np.exp(1j * t) - 1) + lam2 * (np.exp(-1j * t) - 1))\n\n    # Define probability mass function implementations\n    def pmf_binomial(k, n, p):\n        # Use scipy.stats for a robust implementation handling k out of support\n        return binom_dist.pmf(k, n, p)\n\n    def pmf_poisson(k, lam):\n        # Use scipy.stats for a robust implementation\n        # For k  0, pmf is 0. poisson_dist.pmf handles this.\n        return poisson_dist.pmf(k, lam)\n    \n    def pmf_skellam(k, lam1, lam2):\n        # Use log-domain calculations for numerical stability, though direct\n        # computation is fine for these parameters.\n        # I_v(z) can grow very large, but the exponential term keeps it in check.\n        term1 = -(lam1 + lam2)\n        term2 = (k / 2.0) * (np.log(lam1) - np.log(lam2))\n        # Use scipy.special.iv for the modified Bessel function of the first kind\n        bessel_term = iv(np.abs(k), 2 * np.sqrt(lam1 * lam2))\n        \n        # Combine terms, handling potential log(0) for bessel_term\n        # Since bessel_term is always non-negative, we can safely take log\n        # if we handle the case where it is zero. \n        # For integer order, iv(v,z) is zero only if z=0, which is not the case here.\n        log_bessel = np.log(bessel_term)\n        return np.exp(term1 + term2 + log_bessel)\n\n    def calculate_aliasing_error(dist_params):\n        \"\"\"\n        Calculates the max absolute aliasing error for a given distribution and parameters.\n        \"\"\"\n        dist_name = dist_params['name']\n        params = dist_params['params']\n        N = dist_params['N']\n        k_range_type = dist_params['k_range_type']\n\n        # Step 1: Set up grids\n        t_grid = 2 * np.pi * np.arange(N) / N\n        \n        if k_range_type == 'non-negative':\n            k_indices = np.arange(N)\n        elif k_range_type == 'centered':\n            k_indices = np.arange(-N // 2, N // 2)\n        else:\n            raise ValueError(\"Invalid k_range_type\")\n\n        # Step 2: Sample the characteristic function\n        if dist_name == 'binomial':\n            cf_samples = cf_binomial(t_grid, n=params['n'], p=params['p'])\n        elif dist_name == 'poisson':\n            cf_samples = cf_poisson(t_grid, lam=params['lambda'])\n        elif dist_name == 'skellam':\n            cf_samples = cf_skellam(t_grid, lam1=params['lambda1'], lam2=params['lambda2'])\n        \n        # Step 3: Compute numerical inversion via FFT\n        # The derived formula is p_hat_k = (1/N) * IDFT(phi), where IDFT has e^(+i...).\n        # np.fft.ifft computes (1/N) * sum(a * exp(2j * pi * k * n / N)).\n        # The required formula is p_hat_k = (1/N) * sum(phi * exp(-2j * pi * k * n / N)).\n        # This is (1/N) * conj(IDFT(conj(phi))). Or, more simply, it is (1/N) * FFT(phi) where FFT uses exp(-i...).\n        # numpy.fft.fft uses e^(-i...). So p_hat_k = (1/N) * np.fft.fft(phi_samples).\n        p_hat_raw = (1 / N) * np.fft.fft(cf_samples)\n        \n        # Adjust indices for centered range\n        if k_range_type == 'centered':\n            # The FFT output corresponds to k=0, 1, ..., N-1.\n            # To match k = -N/2, ..., N/2-1, we need to shift the output.\n            # k=0,...,N/2-1 corresponds to positive freqs.\n            # k=N/2,...,N-1 corresponds to negative freqs -N/2, ..., -1.\n            p_hat_k = np.fft.fftshift(p_hat_raw)\n        else:\n            p_hat_k = p_hat_raw\n            \n        # The result should be real; take the real part to discard numerical noise.\n        p_hat_k = np.real(p_hat_k)\n        \n        # Step 4: Compute the true PMF\n        if dist_name == 'binomial':\n            p_k = pmf_binomial(k_indices, n=params['n'], p=params['p'])\n        elif dist_name == 'poisson':\n            p_k = pmf_poisson(k_indices, lam=params['lambda'])\n        elif dist_name == 'skellam':\n            p_k = pmf_skellam(k_indices, lam1=params['lambda1'], lam2=params['lambda2'])\n\n        # Step 5: Compute the aliasing error metric\n        max_abs_diff = np.max(np.abs(p_hat_k - p_k))\n        return max_abs_diff\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Binomial (compact support, no aliasing)\n        {'name': 'binomial', 'params': {'n': 20, 'p': 0.3}, 'N': 64, 'k_range_type': 'non-negative'},\n        # Test 2: Poisson (light tails, low aliasing)\n        {'name': 'poisson', 'params': {'lambda': 8}, 'N': 64, 'k_range_type': 'non-negative'},\n        # Test 3: Poisson (heavier tails, more aliasing)\n        {'name': 'poisson', 'params': {'lambda': 30}, 'N': 64, 'k_range_type': 'non-negative'},\n        # Test 4: Skellam (bidirectional, aliasing on small grid)\n        {'name': 'skellam', 'params': {'lambda1': 20, 'lambda2': 10}, 'N': 64, 'k_range_type': 'centered'},\n        # Test 5: Skellam (bidirectional, reduced aliasing on large grid)\n        {'name': 'skellam', 'params': {'lambda1': 20, 'lambda2': 10}, 'N': 512, 'k_range_type': 'centered'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_aliasing_error(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3293797"}, {"introduction": "将反演思想从离散变量推广到连续变量，需要我们从傅里叶级数转向傅里叶变换，这也带来了新的数值挑战。直接截断无限的傅里叶积分会引入不必要的振荡，即吉布斯现象（Gibbs phenomenon），也称为谱泄漏（spectral leakage）。本练习旨在让您掌握使用FFT对连续分布的特征函数进行数值反演的完整流程，并通过引入窗函数（window function）来处理谱泄漏问题[@problem_id:3293843]。您将通过比较矩形窗（即无窗）和布莱克曼窗（Blackman window）的效果，深刻体会到在减少泄漏和引入平滑偏差之间的权衡，这是信号处理和计算统计中一个无处不在的主题。", "problem": "您的任务是设计一个计算程序，使用快速傅里叶变换（FFT）数值化地反演特征函数，分析由周期性延拓引起的混叠，并提出和实现加窗以减少频谱泄漏。您的程序必须是一个完整的、可运行的实现，对于一组给定的测试用例，它能够构建用于反演的FFT网格，从特征函数计算概率密度函数的近似值，并报告量化的误差指标。\n\n应使用的基本原理如下：\n- 一个实值随机变量的特征函数定义为 $\\varphi_{X}(t) = \\mathbb{E}[e^{i t X}]$。\n- 当一个分布存在概率密度函数 $f_{X}(x)$ 时，反演关系（傅里叶反演）以 $f_{X}(x) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-i t x} \\varphi_{X}(t) \\, dt$ 的形式成立，其中需要理解的是，必要时该积分应在适当的意义下进行。\n- 当使用一致的反演积分离散化时，离散傅里叶变换（DFT）与常规网格配对，遵循采样关系，即对于一个 $N$ 点的FFT，空间间距 $\\Delta x$ 和频率间距 $\\Delta t$ 通过 $\\Delta x \\, \\Delta t = \\frac{2\\pi}{N}$ 相关联。\n- 将傅里叶积分截断到有限的频带并在有限的速率下采样，意味着在空间域中恢复的密度会发生周期性延拓，周期为 $L = N \\Delta x$，导致区间外的质量混叠回基本单元内。将采样后的特征函数乘以一个在两端逐渐变细的平滑窗，可以减少到空间域的频谱泄漏，但会引入平滑偏差。\n\n您的算法设计必须：\n1. 构建一个长度为 $L = N \\Delta x$ 的均匀间隔的空间网格 $\\{x_{j}\\}_{j=0}^{N-1}$，中心化使得 $x_{0} = -L/2$ 且 $x_{j} = x_{0} + j \\Delta x$；以及一个对偶的频率网格 $\\{t_{k}\\}_{k=0}^{N-1}$，其间距为 $\\Delta t = \\frac{2\\pi}{L}$，且 $t_{k} = (k - N/2)\\Delta t$。\n2. 通过与DFT匹配的黎曼和来近似反演积分，这样您就可以使用一个 $N$ 点的FFT来计算\n$$\nf_{X}(x_{j}) \\approx \\frac{\\Delta t}{2\\pi} \\sum_{k=0}^{N-1} \\varphi_{X}(t_{k}) \\, e^{-i t_{k} x_{j}}.\n$$\n3. 分析并反映由离散变换引起的 $L$-周期性延拓所导致的混叠，即恢复的 $f_{X}$ 实际上是与一个狄利克雷核进行卷积并以周期 $L$ 进行周期化。通过为目标分布选择足够大的 $L$ 以及在频域中应用一个锥削（窗）$w_{k}$ 来减少来自有限频带的泄漏，从而控制混叠。\n4. 在频域中实现至少两种窗：矩形窗 $w_{k} \\equiv 1$（无锥削）和一个平滑的锥削窗，如布莱克曼窗。在进行FFT之前，该窗函数会乘以采样后的特征函数。\n5. 将恢复的密度与严格位于基本单元内部的指定评估区间上的精确解析密度进行比较，以量化最大绝对误差。\n\n用于测试用例的分布及其特征函数和密度：\n- 均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布：$\\varphi(t) = \\exp\\!\\left(i \\mu t - \\frac{1}{2}\\sigma^{2} t^{2}\\right)$ 和 $f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-\\mu)^{2}}{2 \\sigma^{2}}\\right)$。\n- 位置为 $\\mu$、尺度为 $b$ 的拉普拉斯（双指数）分布：$\\varphi(t) = \\frac{e^{i \\mu t}}{1 + b^{2} t^{2}}$ 和 $f(x) = \\frac{1}{2b} \\exp\\!\\left(-\\frac{|x - \\mu|}{b}\\right)$。\n- 位置为 $\\mu$、尺度为 $\\gamma$ 的柯西分布：$\\varphi(t) = \\exp\\!\\left(i \\mu t - \\gamma |t|\\right)$ 和 $f(x) = \\frac{1}{\\pi} \\frac{\\gamma}{\\gamma^{2} + (x - \\mu)^{2}}$。\n\n测试套件：\n对于每个测试用例，使用给定的参数构建FFT反演，在网格上恢复近似密度，并报告在评估集 $\\{x \\in [-x_{\\mathrm{eval}}, x_{\\mathrm{eval}}]\\}$ 上，近似密度与精确密度之间的最大绝对误差，其中 $x_{\\mathrm{eval}}$ 按情况给出。\n\n为以下每个参数集提供结果：\n- 情况1（理想情况，轻尾，大网格）：正态分布，$\\mu = 0$, $\\sigma = 1$, $N = 4096$, $L = 50$，矩形窗，在 $[-6, 6]$ 上评估。\n- 情况2（粗糙网格，混叠/泄漏更明显）：正态分布，$\\mu = 0$, $\\sigma = 1$, $N = 512$, $L = 20$，矩形窗，在 $[-6, 6]$ 上评估。\n- 情况3（与情况2相同，但带加窗）：正态分布，$\\mu = 0$, $\\sigma = 1$, $N = 512$, $L = 20$，布莱克曼窗，在 $[-6, 6]$ 上评估。\n- 情况4（比正态分布更重的尾部，中等网格）：拉普拉斯分布，$\\mu = 0$, $b = 1$, $N = 1024$, $L = 20$，矩形窗，在 $[-6, 6]$ 上评估。\n- 情况5（带加窗的拉普拉斯分布）：拉普拉斯分布，$\\mu = 0$, $b = 1$, $N = 1024$, $L = 20$，布莱克曼窗，在 $[-6, 6]$ 上评估。\n- 情况6（重尾，混叠挑战）：柯西分布，$\\mu = 0$, $\\gamma = 1$, $N = 2048$, $L = 40$，矩形窗，在 $[-6, 6]$ 上评估。\n- 情况7（带加窗的柯西分布）：柯西分布，$\\mu = 0$, $\\gamma = 1$, $N = 2048$, $L = 40$，布莱克曼窗，在 $[-6, 6]$ 上评估。\n- 情况8（边界敏感性检查，非常小的域）：正态分布，$\\mu = 0$, $\\sigma = 1$, $N = 256$, $L = 8$，矩形窗，在 $[-3, 3]$ 上评估。\n\n所有角度均以弧度为单位。不涉及任何物理单位。对于每种情况，程序必须计算并返回一个实数：在指定评估区间上，数值恢复的密度与精确密度之间的最大绝对误差。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,...,result8]”）。每个结果必须是您的程序为上面给出的相应情况计算的浮点数。不应打印任何额外的文本。", "solution": "问题 R-0391 具有科学依据、问题明确且客观。所有必要的参数、公式和评估标准都已提供。该问题是数值傅里叶分析应用于概率论的一个标准练习，没有任何科学或逻辑上的缺陷。任务是使用快速傅里叶变换（FFT）对特征函数进行数值反演，这是一种公认的技术。因此，该问题被认为是**有效的**。\n\n该问题的解决方案涉及对傅里叶反演积分进行数值近似，该积分从特征函数（CF）$\\varphi_X(t)$ 中恢复概率密度函数（PDF）$f_X(x)$。核心原理是将积分离散化，并将得到的和映射到计算效率高的离散傅里叶变换（DFT），通过快速傅里叶变换（FFT）算法实现。\n\nPDF 和 CF 之间的关系由傅里叶反演定理给出：\n$$\nf_X(x) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-i t x} \\varphi_X(t) \\, dt\n$$\n为了对其进行数值计算，我们将积分截断到一个有限域 $[t_{\\min}, t_{\\max}]$，并用频率离散网格上的黎曼和来近似它。问题指定了一个频率网格 $\\{t_k\\}_{k=0}^{N-1}$ 和一个对应的空间网格 $\\{x_j\\}_{j=0}^{N-1}$。\n\n网格定义如下：\n- 空间域长度为 $L$。网格间距为 $\\Delta x = L/N$。网格点为 $x_j = -L/2 + j \\Delta x$，其中 $j \\in \\{0, 1, \\dots, N-1\\}$。\n- 频率域间距由 DFT 采样关系联系起来，$\\Delta t = 2\\pi / L = 2\\pi / (N \\Delta x)$。网格点为 $t_k = (k - N/2) \\Delta t$，其中 $k \\in \\{0, 1, \\dots, N-1\\}$。\n\n使用这些网格，反演积分通过以下和式进行近似：\n$$\nf_X(x_j) \\approx \\frac{\\Delta t}{2\\pi} \\sum_{k=0}^{N-1} \\varphi_X(t_k) \\, e^{-i t_k x_j}\n$$\n主要挑战是为所有 $j=0, \\dots, N-1$ 高效地计算这个和。直接求和的复杂度为 $O(N^2)$，对于大的 $N$ 来说效率低下。然而，这个和的结构适合使用 FFT 算法，其复杂度为 $O(N \\log N)$。\n\n为了将这个和映射到 DFT 的标准定义 $G_j = \\sum_{k=0}^{N-1} g_k e^{-i 2\\pi jk/N}$，我们必须分析相位项 $e^{-i t_k x_j}$。代入网格定义：\n$$\nt_k x_j = \\left(k - \\frac{N}{2}\\right)\\Delta t \\left(j \\Delta x - \\frac{L}{2}\\right)\n$$\n使用 $\\Delta x = L/N$ 和 $\\Delta t = 2\\pi/L$：\n$$\n\\begin{align*}\nt_k x_j = \\left(k - \\frac{N}{2}\\right)\\frac{2\\pi}{L} \\left(j \\frac{L}{N} - \\frac{L}{2}\\right) \\\\\n= \\left(k - \\frac{N}{2}\\right)\\frac{2\\pi}{N} \\left(j - \\frac{N}{2}\\right) \\\\\n= \\frac{2\\pi}{N} \\left(kj - \\frac{kN}{2} - \\frac{jN}{2} + \\frac{N^2}{4}\\right) \\\\\n= \\frac{2\\pi kj}{N} - k\\pi - j\\pi + \\frac{N\\pi}{2}\n\\end{align*}\n$$\n因此，相位项的指数为：\n$$\ne^{-i t_k x_j} = e^{-i (2\\pi kj/N - k\\pi - j\\pi + N\\pi/2)} = e^{-i 2\\pi kj/N} e^{ik\\pi} e^{ij\\pi} e^{-iN\\pi/2}\n$$\n由于 $e^{i\\pi} = -1$，这可以简化为：\n$$\ne^{-i t_k x_j} = (-1)^k (-1)^j e^{-iN\\pi/2} e^{-i 2\\pi kj/N}\n$$\n测试用例使用的 $N$ 值是 2 的幂，因此是 4 的倍数（例如，$256, 512, \\dots, 4096$）。对于这样的 $N$，$N/2$ 是一个偶数，所以 $e^{-iN\\pi/2} = \\cos(-N\\pi/2) + i\\sin(-N\\pi/2) = 1$。相位项进一步简化为 $e^{-i t_k x_j} = (-1)^k (-1)^j e^{-i 2\\pi kj/N}$。\n\n将此代入和式中，我们得到：\n$$\nf_X(x_j) \\approx \\frac{\\Delta t}{2\\pi} \\sum_{k=0}^{N-1} \\varphi_X(t_k) \\, (-1)^k (-1)^j e^{-i 2\\pi kj/N}\n$$\n项 $(-1)^j$ 可以移到求和符号外面。定义一个新序列 $Y_k = (-1)^k \\varphi_X(t_k)$，和式变为：\n$$\nf_X(x_j) \\approx \\frac{\\Delta t}{2\\pi} (-1)^j \\sum_{k=0}^{N-1} Y_k \\, e^{-i 2\\pi kj/N} = \\frac{1}{L} (-1)^j \\cdot \\text{FFT}(Y)_j\n$$\n这提供了一个高效的算法：\n1. 构建频率网格 $\\{t_k\\}$。\n2. 在此网格上评估特征函数 $\\varphi_X(t_k)$。\n3. 如果需要，应用窗函数 $w_k$：$\\varphi_{X,w}(t_k) = w_k \\varphi_X(t_k)$。\n4. 创建用于 FFT 的序列：$Y_k = (-1)^k \\varphi_{X,w}(t_k)$。\n5. 计算 $Y_k$ 的 FFT 得到 $\\hat{Y}_j = \\text{FFT}(Y)_j$。\n6. 计算最终的近似值 $f_X(x_j) \\approx \\frac{1}{L} \\text{Re}[(-1)^j \\hat{Y}_j]$。我们取实部，因为 PDF 是实值的，任何残余的虚部都是由数值近似误差引起的。\n\n离散化过程引入了两种主要类型的误差。首先，将积分截断到有限频域 $[-t_{\\max}, t_{\\max}]$（其中 $t_{\\max} \\approx N/2 \\cdot \\Delta t$），等价于将真实的 PDF 与一个类 sinc 核进行卷积，导致振铃伪影（吉布斯现象或频谱泄漏）。应用一个平滑的窗函数，如布莱克曼窗，可以在截断边界处使被积函数 $\\varphi_X(t)$ 平滑地衰减到零。这显著减少了泄漏，但代价是轻微加宽了恢复的 PDF 的主要特征（一种偏差-平滑的权衡）。\n\n其次，以有限速率 $\\Delta t$ 对频域进行采样，导致恢复的空间函数以周期 $L=2\\pi/\\Delta t$ 呈周期性。如果真实的 PDF $f_X(x)$ 在区间 $[-L/2, L/2]$ 之外有显著的质量，这个区间外的质量会“混叠”回该区间，从而扭曲近似值。这种混叠误差通过选择足够大的域长度 $L$ 来控制。\n\n实现将对每个测试用例执行此算法，将得到的近似 PDF 在指定的评估区间上与已知的解析 PDF 进行比较，以计算最大绝对误差。", "answer": "```python\nimport numpy as np\n\ndef char_func_normal(t, mu, sigma):\n    \"\"\"Characteristic function of a Normal distribution.\"\"\"\n    return np.exp(1j * mu * t - 0.5 * (sigma**2) * (t**2))\n\ndef pdf_normal(x, mu, sigma):\n    \"\"\"Probability density function of a Normal distribution.\"\"\"\n    return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma)**2)\n\ndef char_func_laplace(t, mu, b):\n    \"\"\"Characteristic function of a Laplace distribution.\"\"\"\n    return np.exp(1j * mu * t) / (1 + (b**2) * (t**2))\n\ndef pdf_laplace(x, mu, b):\n    \"\"\"Probability density function of a Laplace distribution.\"\"\"\n    return (1 / (2 * b)) * np.exp(-np.abs(x - mu) / b)\n\ndef char_func_cauchy(t, mu, gamma):\n    \"\"\"Characteristic function of a Cauchy distribution.\"\"\"\n    return np.exp(1j * mu * t - gamma * np.abs(t))\n\ndef pdf_cauchy(x, mu, gamma):\n    \"\"\"Probability density function of a Cauchy distribution.\"\"\"\n    return (1 / np.pi) * (gamma / (gamma**2 + (x - mu)**2))\n\ndef compute_pdf_error(dist_name, dist_params, N, L, window_type, x_eval):\n    \"\"\"\n    Computes the max absolute error of the FFT-recovered PDF for a given case.\n    \"\"\"\n    # 1. Select the appropriate characteristic and density functions\n    if dist_name == 'normal':\n        char_func = char_func_normal\n        pdf_exact = pdf_normal\n    elif dist_name == 'laplace':\n        char_func = char_func_laplace\n        pdf_exact = pdf_laplace\n    elif dist_name == 'cauchy':\n        char_func = char_func_cauchy\n        pdf_exact = pdf_cauchy\n    else:\n        raise ValueError(f\"Unknown distribution: {dist_name}\")\n\n    # 2. Construct spatial and frequency grids\n    dx = L / N\n    x_grid = -L / 2 + np.arange(N) * dx\n    \n    dt = 2 * np.pi / L\n    t_grid = (np.arange(N) - N / 2) * dt\n\n    # 3. Sample the characteristic function\n    phi_t = char_func(t_grid, **dist_params)\n\n    # 4. Apply windowing in the frequency domain\n    if window_type == 'rectangular':\n        window = np.ones(N)\n    elif window_type == 'blackman':\n        # The Blackman window is naturally defined for indices 0 to N-1.\n        # np.fft.fftshift is needed to align its center with t=0 (which is at index N/2).\n        window = np.fft.fftshift(np.blackman(N))\n    else:\n        raise ValueError(f\"Unknown window type: {window_type}\")\n\n    phi_windowed = phi_t * window\n    \n    # 5. Perform FFT-based inversion\n    # The derivation f(x_j) approx (1/L) * (-1)^j * FFT[(-1)^k * phi(t_k)]\n    # requires careful index handling.\n    # The grid t_k is already centered. A simpler FFT formulation is often used:\n    # f(x_j) approx (dt/2pi) * FFT_SHIFT(FFT(FFT_SHIFT(phi(t_k)))) * (-1)^j\n    # Let's stick to the derived formula which is more direct.\n    \n    arange_N = np.arange(N)\n    phase_shift_j = (-1)**arange_N\n    \n    # The term (-1)^k needs to apply to the centered grid t_k.\n    # We can apply it by shifting the phase_shift_j sequence.\n    phase_shift_k = np.fft.fftshift(phase_shift_j)\n\n    Y_k = phase_shift_k * phi_windowed\n    \n    # The standard FFT calculates sum(Y_k * exp(-2*pi*i*j*k/N)). We need this.\n    Y_hat_j = np.fft.fft(Y_k)\n    \n    f_approx_complex = (1 / L) * phase_shift_j * Y_hat_j\n    \n    # The resulting PDF must be real; imaginary part is numerical error.\n    f_approx = np.real(f_approx_complex)\n\n    # 6. Calculate maximum absolute error on the evaluation interval\n    eval_mask = (x_grid >= -x_eval)  (x_grid = x_eval)\n    x_compare = x_grid[eval_mask]\n    \n    if len(x_compare) == 0:\n        # This case would indicate the evaluation interval is outside the grid,\n        # which shouldn't happen with the given test cases.\n        return np.inf\n\n    f_approx_compare = f_approx[eval_mask]\n    f_exact_compare = pdf_exact(x_compare, **dist_params)\n    \n    max_abs_error = np.max(np.abs(f_approx_compare - f_exact_compare))\n    \n    return max_abs_error\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ('normal', {'mu': 0, 'sigma': 1}, 4096, 50, 'rectangular', 6),\n        # Case 2\n        ('normal', {'mu': 0, 'sigma': 1}, 512, 20, 'rectangular', 6),\n        # Case 3\n        ('normal', {'mu': 0, 'sigma': 1}, 512, 20, 'blackman', 6),\n        # Case 4\n        ('laplace', {'mu': 0, 'b': 1}, 1024, 20, 'rectangular', 6),\n        # Case 5\n        ('laplace', {'mu': 0, 'b': 1}, 1024, 20, 'blackman', 6),\n        # Case 6\n        ('cauchy', {'mu': 0, 'gamma': 1}, 2048, 40, 'rectangular', 6),\n        # Case 7\n        ('cauchy', {'mu': 0, 'gamma': 1}, 2048, 40, 'blackman', 6),\n        # Case 8\n        ('normal', {'mu': 0, 'sigma': 1}, 256, 8, 'rectangular', 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        dist_name, dist_params, N, L, window_type, x_eval = case\n        error = compute_pdf_error(dist_name, dist_params, N, L, window_type, x_eval)\n        results.append(error)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3293843"}, {"introduction": "除了作为完整分布的“指纹”，特征函数在原点附近的局部性质（由其各阶导数决定）同样蕴含着丰富的宝藏。这些导数与分布的矩和累积量（cumulant）直接相关，后者简洁地描述了分布的偏度、峰度等重要形状特征。本练习将引导您探索一个更高级的应用：利用特征函数导出的累积量来构建一个分布的近似，即格兰-查理级数（Gram-Charlier series）[@problem_id:3293821]。您将亲手实现这一近似方法，并将其结果与通过吉尔-佩拉兹（Gil-Pelaez）反演公式得到的更精确的数值积分结果进行比较，从而对不同数值方法的优劣和适用场景建立起批判性的认识。", "problem": "构建一个完整、可运行的程序，该程序使用最高四阶的累积量来评估基于正态基线的 Gram–Charlier 校正的准确性，并将其与通过特征函数 (CF) 反演计算的尾部概率进行比较。该程序必须实现以下内容。\n\n考虑一个标准化随机变量族，其定义如下。设 $Z$ 为一个标准正态随机变量，其特征函数 (CF) 为 $\\varphi_Z(t) = \\exp(-t^2/2)$。设 $E_1$ 为一个率（rate）为 $1$ 的指数随机变量，其特征函数为 $\\varphi_{E_1}(t) = \\frac{1}{1 - i t}$。定义 $U = E_1 - 1$，因此 $\\mathbb{E}[U] = 0$ 且 $\\varphi_U(t) = \\exp(-i t) \\varphi_{E_1}(t) = \\frac{\\exp(-i t)}{1 - i t}$。对于给定的实数参数 $\\alpha \\ge 0$，定义 $Y = Z + \\alpha U$，以及标准化变量 $X = Y / s$，其中 $s = \\sqrt{1 + \\alpha^2}$。这种构造确保了 $\\mathbb{E}[X] = 0$ 和 $\\mathrm{Var}(X) = 1$。\n\n$X$ 的特征函数由 $\\varphi_X(t) = \\varphi_Y(t/s)$ 给出，其中 $\\varphi_Y(u) = \\varphi_Z(u)\\,\\varphi_{\\alpha U}(u)$ 且 $\\varphi_{\\alpha U}(u) = \\varphi_U(\\alpha u)$。独立和的累积量相加，并且在缩放变换下，累积量按幂次缩放：如果 $W = c V$，则 $\\kappa_r(W) = c^r \\kappa_r(V)$。率（rate）为 $1$ 的指数分布的累积量对于所有整数 $r \\ge 1$ 均为 $\\kappa_r(E_1) = (r-1)!$；因此 $U = E_1 - 1$ 满足 $\\kappa_1(U) = 0$ 且对于所有整数 $r \\ge 2$ 均有 $\\kappa_r(U) = (r-1)!$。仅使用这些基本事实，结合特征函数 (CF) 的定义 $\\varphi_X(t) = \\mathbb{E}[e^{i t X}]$ 和通过 CF 的对数定义的累积量，来推导 $X$ 的最高四阶的标准化累积量，并用它们来构建针对正态基线的 Gram–Charlier 校正。\n\n程序中要实现的任务：\n\n1. 仅使用上述基本事实，为给定的 $X$ 推导并实现其特征函数 (CF) $\\varphi_X(t)$。然后，使用一个对累积分布函数有效的特征函数反演方法，计算生存概率 $\\mathbb{P}(X > x)$。该反演必须通过数值积分实现，并具有足够严格的容差，以分辨 $10^{-8}$ 或更小量级的误差。\n\n2. 使用 $X$ 的最高四阶累积量，构建对标准正态基线的 Gram–Charlier A 级数校正，截断该级数以仅包含依赖于三阶和四阶累积量的项。从此截断级数中，推导出累积分布函数 $F_{\\mathrm{GC}}(x)$ 的相应近似，并由此计算近似的生存概率 $1 - F_{\\mathrm{GC}}(x)$。\n\n3. 对于下面指定的每个测试用例，计算 Gram–Charlier 生存概率与特征函数反演生存概率之间的绝对误差，即计算 $\\left| \\left(1 - F_{\\mathrm{GC}}(x)\\right) - \\mathbb{P}(X > x) \\right|$。\n\n用于评估的测试套件：\n- $(\\alpha, x) = (0.0, 1.0)$\n- $(\\alpha, x) = (0.5, 1.0)$\n- $(\\alpha, x) = (0.5, 2.0)$\n- $(\\alpha, x) = (1.0, 1.0)$\n- $(\\alpha, x) = (1.5, 0.0)$\n- $(\\alpha, x) = (1.5, 2.0)$\n\n所有计算都是纯数学的，无单位。复指数中使用的角度以弧度为单位。\n\n您的程序应生成单行输出，其中包含上述测试用例的绝对误差。输出形式为一个用方括号括起来的逗号分隔列表，每个浮点数采用小数点后八位的科学记数法格式。例如，输出格式必须类似于`[1.23456789e-04,2.34567891e-06,...]`，但没有空格，即`[1.23456789e-04,2.34567891e-06,...]`。", "solution": "用户提供的问题是一个定义明确的计算概率练习，经过全面审查后被认为是有效的。所有提供的信息在科学上是可靠的、自洽的，并且在数学上是一致的。该问题要求实现和比较两种近似生存概率的方法：一种基于特征函数 (CF) 的数值反演，另一种使用 Gram-Charlier A 级数展开。\n\n我们首先按照问题陈述中概述的步骤，系统地推导必要的数学公式。\n\n### 1. $X$ 的特征函数的推导\n\n随机变量 $X$ 是通过几个步骤构建的。我们遵循这个构建过程来推导其特征函数 $\\varphi_X(t) = \\mathbb{E}[e^{itX}]$。\n\n-   变量 $U$ 定义为 $U = E_1 - 1$，其中 $E_1$ 是率（rate）为 $1$ 的指数随机变量。其特征函数为 $\\varphi_{E_1}(t) = \\frac{1}{1 - it}$。$U$ 的特征函数是：\n    $$ \\varphi_U(t) = \\mathbb{E}[e^{it(E_1-1)}] = e^{-it}\\mathbb{E}[e^{itE_1}] = e^{-it}\\varphi_{E_1}(t) = \\frac{e^{-it}}{1 - it} $$\n-   变量 $Y$ 是一个标准正态变量 $Z$ 和一个缩放版 $U$ 的和，即 $Y = Z + \\alpha U$。由于 $Z$ 和 $U$ 是由独立来源构建的（由问题的设置所暗示），它们的和的特征函数是它们各自特征函数的乘积。$\\alpha U$ 的特征函数是 $\\varphi_{\\alpha U}(t) = \\varphi_U(\\alpha t)$。\n    $$ \\varphi_Y(t) = \\varphi_Z(t) \\cdot \\varphi_{\\alpha U}(t) = \\varphi_Z(t) \\cdot \\varphi_U(\\alpha t) $$\n    代入已知的特征函数：\n    $$ \\varphi_Y(t) = \\exp\\left(-\\frac{t^2}{2}\\right) \\cdot \\frac{e^{-i\\alpha t}}{1 - i\\alpha t} $$\n-   最后，$X$ 是 $Y$ 的标准化版本，由 $X = Y/s$ 给出，其中 $s = \\sqrt{1 + \\alpha^2}$。一个缩放变量 $aW$ 的特征函数是 $\\varphi_W(at)$。因此，$X$ 的特征函数是：\n    $$ \\varphi_X(t) = \\varphi_Y(t/s) = \\exp\\left(-\\frac{(t/s)^2}{2}\\right) \\frac{\\exp(-i\\alpha (t/s))}{1 - i\\alpha (t/s)} $$\n    代入 $s = \\sqrt{1+\\alpha^2}$，我们得到 $X$ 的特征函数的最终表达式：\n    $$ \\varphi_X(t) = \\exp\\left(-\\frac{t^2}{2(1+\\alpha^2)}\\right) \\frac{\\exp\\left(-\\frac{i\\alpha t}{\\sqrt{1+\\alpha^2}}\\right)}{1 - \\frac{i\\alpha t}{\\sqrt{1+\\alpha^2}}} $$\n\n### 2. 通过特征函数反演计算生存概率\n\n累积分布函数 (CDF) $F_X(x) = \\mathbb{P}(X \\le x)$ 可以使用 Gil-Pelaez 反演公式从其特征函数 $\\varphi_X(t)$ 中恢复：\n$$ F_X(x) = \\frac{1}{2} - \\frac{1}{\\pi} \\int_0^\\infty \\text{Im}\\left( e^{-itx} \\varphi_X(t) \\right) \\frac{dt}{t} $$\n生存概率为 $\\mathbb{P}(X > x) = 1 - F_X(x)$。代入 $F_X(x)$ 的公式：\n$$ \\mathbb{P}(X > x) = 1 - \\left( \\frac{1}{2} - \\frac{1}{\\pi} \\int_0^\\infty \\text{Im}\\left( e^{-itx} \\varphi_X(t) \\right) \\frac{dt}{t} \\right) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Im}\\left( e^{-itx} \\varphi_X(t) \\right) \\frac{dt}{t} $$\n被积函数，我们称之为 $I(t,x,\\alpha)$，必须进行数值计算。虚部算子内部的表达式为：\n$$ e^{-itx} \\varphi_X(t) = \\exp(-itx) \\exp\\left(-\\frac{t^2}{2s^2}\\right) \\frac{\\exp(-i \\alpha t/s)}{1 - i \\alpha t/s} = \\exp\\left(-\\frac{t^2}{2s^2} - it\\left(x + \\frac{\\alpha}{s}\\right)\\right) \\frac{1}{1 - i \\alpha t/s} $$\n对于每个 $t$，此表达式被计算为一个复数，取其虚部，除以 $t$，然后从 $t=0$ 到 $t=\\infty$ 进行积分。该积分将使用数值积分法进行评估，`scipy.integrate.quad` 函数对此非常适用。高斯衰减项 $\\exp(-t^2/(2s^2))$ 确保被积函数快速收敛，使得数值积分稳定且高效。\n\n### 3. $X$ 的累积量的推导\n\n问题提供了累积量 $\\kappa_r$ 的必要性质。\n-   对于 $r \\ge 1$，$ \\kappa_r(E_1) = (r-1)!$。\n-   对于 $U = E_1 - 1$，我们有 $\\kappa_1(U) = \\kappa_1(E_1) - 1 = (1-1)! - 1 = 0$，且对于 $r \\ge 2$，$\\kappa_r(U) = \\kappa_r(E_1) = (r-1)!$。\n-   对于 $Y = Z + \\alpha U$，使用独立变量累积量的可加性和缩放性质：\n    $$ \\kappa_r(Y) = \\kappa_r(Z) + \\kappa_r(\\alpha U) = \\kappa_r(Z) + \\alpha^r \\kappa_r(U) $$\n    标准正态变量 $Z$ 的累积量为 $\\kappa_1(Z) = 0$，$\\kappa_2(Z) = 1$，且对于 $r \\ge 3$，$\\kappa_r(Z) = 0$。\n    -   $\\kappa_1(Y) = 0 + \\alpha^1 \\cdot 0 = 0$。\n    -   $\\kappa_2(Y) = 1 + \\alpha^2 \\kappa_2(U) = 1 + \\alpha^2 (2-1)! = 1 + \\alpha^2$。\n    -   $\\kappa_3(Y) = 0 + \\alpha^3 \\kappa_3(U) = \\alpha^3 (3-1)! = 2\\alpha^3$。\n    -   $\\kappa_4(Y) = 0 + \\alpha^4 \\kappa_4(U) = \\alpha^4 (4-1)! = 6\\alpha^4$。\n-   对于 $X = Y/s$ 且 $s = \\sqrt{\\kappa_2(Y)} = \\sqrt{1+\\alpha^2}$，累积量按 $s^{-r}$ 缩放：\n    -   $\\kappa_1(X) = \\kappa_1(Y)/s = 0$。\n    -   $\\kappa_2(X) = \\kappa_2(Y)/s^2 = (1+\\alpha^2)/(1+\\alpha^2) = 1$。\n    -   $\\kappa_3(X) = \\kappa_3(Y)/s^3 = \\frac{2\\alpha^3}{(1+\\alpha^2)^{3/2}}$。（标准化偏度）\n    -   $\\kappa_4(X) = \\kappa_4(Y)/s^4 = \\frac{6\\alpha^4}{(1+\\alpha^2)^2}$。（标准化超额峰度）\n\n### 4. Gram-Charlier 生存概率\n\nGram-Charlier A 级数用标准正态概率密度函数 (PDF) $\\phi(x)$ 及其导数（与 Hermite 多项式相关）来为随机变量的概率密度函数提供近似。使用最高四阶累积量的 PDF $f_X(x)$ 的截断级数为：\n$$ f_{\\mathrm{GC}}(x) = \\phi(x) \\left[ 1 + \\frac{\\kappa_3(X)}{3!} H_3(x) + \\frac{\\kappa_4(X)}{4!} H_4(x) \\right] $$\n其中 $H_k(x)$ 是概率论者的 Hermite 多项式，例如 $H_2(x) = x^2-1$, $H_3(x) = x^3 - 3x$。\n\n为了找到 CDF 近似 $F_{\\mathrm{GC}}(x)$，我们将 $f_{\\mathrm{GC}}(u)$ 从 $-\\infty$ 积分到 $x$。使用性质 $\\int_{-\\infty}^x \\phi(u) H_k(u) du = -\\phi(x) H_{k-1}(x)$，我们得到：\n$$ F_{\\mathrm{GC}}(x) = \\Phi(x) - \\phi(x) \\left[ \\frac{\\kappa_3(X)}{6} H_2(x) + \\frac{\\kappa_4(X)}{24} H_3(x) \\right] $$\n其中 $\\Phi(x)$ 是标准正态 CDF。\n因此，近似的生存概率 $1 - F_{\\mathrm{GC}}(x)$ 为：\n$$ 1 - F_{\\mathrm{GC}}(x) = (1 - \\Phi(x)) + \\phi(x) \\left[ \\frac{\\kappa_3(X)}{6} (x^2 - 1) + \\frac{\\kappa_4(X)}{24} (x^3 - 3x) \\right] $$\n其中 $1 - \\Phi(x)$ 是标准正态生存函数。\n\n### 5. 算法实现\n\n程序将为每个测试用例 $(\\alpha, x)$ 实现这些推导出的公式。\n1.  对于给定的 $(\\alpha, x)$，计算 $s = \\sqrt{1+\\alpha^2}$ 的值。\n2.  定义一个基于 CF 反演公式的被积函数。使用 `scipy.integrate.quad` 计算积分，从而得到“真实”的生存概率 $\\mathbb{P}(X > x)$。\n3.  计算累积量 $\\kappa_3(X)$ 和 $\\kappa_4(X)$。\n4.  使用第 4 步的公式计算 Gram-Charlier 生存概率近似值，其中 $\\phi(x)$ 和 $1-\\Phi(x)$ 由 `scipy.stats.norm` 提供。\n5.  计算并存储两种概率之间的绝对误差。\n6.  处理 $\\alpha=0$ 的特殊情况，此时 $X$ 精确为标准正态分布。在这种情况下，Gram-Charlier 校正项为零，两种方法都应产生标准正态生存函数。因此，理论误差为零。\n7.  按照规定格式化并打印最终的误差列表。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between Gram-Charlier and CF-inversion\n    approximations for the survival probability of a defined random variable.\n    \"\"\"\n    \n    test_cases = [\n        (0.0, 1.0),\n        (0.5, 1.0),\n        (0.5, 2.0),\n        (1.0, 1.0),\n        (1.5, 0.0),\n        (1.5, 2.0)\n    ]\n\n    results = []\n\n    # Set a tight tolerance for numerical integration to meet problem requirements.\n    QUAD_TOL = 1e-12\n\n    for alpha, x in test_cases:\n        # Case 1: alpha = 0. The variable X is standard normal.\n        if alpha == 0.0:\n            # k3 and k4 are 0, so GC approx is just norm.sf(x).\n            # CF inversion also yields norm.sf(x).\n            # The theoretical error is 0.\n            results.append(0.0)\n            continue\n            \n        # For alpha > 0, proceed with the full calculation.\n        s = np.sqrt(1.0 + alpha**2)\n\n        # ---- Task 1: Survival probability from CF inversion ----\n        \n        def char_func_x(t, local_alpha, local_s):\n            \"\"\"Characteristic function of the standardized variable X.\"\"\"\n            if t == 0:\n                return complex(1.0, 0.0)\n            \n            term1 = np.exp(- (t**2) / (2.0 * local_s**2))\n            \n            common_arg = local_alpha * t / local_s\n            numerator = np.exp(-1j * common_arg)\n            denominator = 1.0 - 1j * common_arg\n            \n            term2 = numerator / denominator\n            \n            return term1 * term2\n\n        def inversion_integrand(t, local_alpha, local_s, local_x):\n            \"\"\"Integrand for the Gil-Pelaez inversion formula.\"\"\"\n            if t == 0:\n                # The limit of Im(exp(-itx)phi(t))/t as t->0 is finite.\n                # However, for numerical stability, we can return 0 here\n                # because quad handles singularities at the boundary.\n                return 0.0\n            \n            phi_t = char_func_x(t, local_alpha, local_s)\n            val = np.exp(-1j * t * local_x) * phi_t\n            return val.imag / t\n        \n        # Integrate from 0 to infinity\n        integral_val, _ = integrate.quad(\n            inversion_integrand, 0, np.inf, args=(alpha, s, x),\n            epsabs=QUAD_TOL, epsrel=QUAD_TOL\n        )\n        \n        prob_cf = 0.5 + integral_val / np.pi\n\n        # ---- Task 2: Survival probability from Gram-Charlier series ----\n\n        # Calculate standardized cumulants k3 and k4\n        s_cubed = s**3\n        s_fourth = s**4\n        alpha_cubed = alpha**3\n        alpha_fourth = alpha**4\n\n        k3 = (2.0 * alpha_cubed) / s_cubed\n        k4 = (6.0 * alpha_fourth) / s_fourth\n        \n        # Hermite polynomials related terms\n        h2_term = x**2 - 1.0\n        h3_term = x**3 - 3.0 * x\n\n        # Gram-Charlier correction term\n        gc_correction = norm.pdf(x) * (k3 / 6.0 * h2_term + k4 / 24.0 * h3_term)\n        \n        prob_gc = norm.sf(x) + gc_correction\n        \n        # ---- Task 3: Compute absolute error ----\n        \n        absolute_error = abs(prob_gc - prob_cf)\n        results.append(absolute_error)\n\n    # Format and print the final output as specified.\n    output_str = \",\".join([f\"{res:.8e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3293821"}]}