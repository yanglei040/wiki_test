{"hands_on_practices": [{"introduction": "在我们能够运用金字塔算法生成随机数之前，我们必须首先构建“金字塔”结构本身。这涉及一个至关重要的预计算步骤：将目标概率密度函数下的区域划分为一系列面积相等的水平层。本练习将引导您使用数值方法——特别是数值积分和求根算法——来计算定义这些层的坐标 ($x_i, y_i$)，从而构建算法运行所必需的查找表。[@problem_id:3356972]", "problem": "考虑一个在非负实数轴 $[0,\\infty)$ 上的非负、可积、单调非增的概率密度函数 $f$，其总质量为 $$S = \\int_{0}^{\\infty} f(x)\\,dx.$$ Ziggurat 方法构造了一组堆叠的矩形，通过将其质量划分为等目标面积的层，来支持对 $f$ 进行接受-拒绝采样。一种对此类层进行参数化的严谨方法是采用等面积垂直划分：对于给定的整数 $n \\ge 1$，定义一个横坐标序列 $0 = x_0  x_1  \\dots  x_{n-1}  x_n$ 和相应的纵坐标序列 $y_i = f(x_i)\\quad \\text{for}\\quad i=0,1,\\dots,n,$ 使得等面积条件 $$\\int_{x_{i-1}}^{x_i} f(x)\\,dx = A \\quad \\text{for all}\\quad i=1,2,\\dots,n$$ 成立，其中 $$A = \\frac{S}{n}.$$ 因为 $f$ 是可积且非增的，所以其累积积分 $$F(x) = \\int_{0}^{x} f(u)\\,du$$ 是连续的，在 $f>0$ 的区间上严格递增，并且满足 $\\lim_{x\\to\\infty}F(x)=S$。因此，对于 $i=1,2,\\dots,n-1$，方程 $F(x_i) - F(x_{i-1}) = A$ 有一个唯一的有限解 $x_i$。对于末端索引 $i=n$，在精确数学中，解为 $x_n = +\\infty$；在数值计算中，必须用一个达到指定尾部容差的有限替代值来近似 $x_n$。\n\n你的任务是设计并实现一个构造性算法，该算法使用 $f$ 的数值求根和数值积分，来预计算满足上述属性的数组 $\\{x_i\\}_{i=0}^{n}$ 和 $\\{y_i\\}_{i=0}^{n}$。你的算法必须：\n\n- 通过对 $f$ 在 $[0,\\infty)$ 上进行数值积分来计算 $S$。\n- 设置 $A = S/n$。\n- 初始化 $x_0 = 0$，$y_0 = f(0)$。\n- 对于 $i=1,\\dots,n-1$，通过有界求根法求解 $F(x_i) - F(x_{i-1}) - A = 0$ 得到 $x_i$，其中 $F(x) = \\int_{0}^{x} f(u)\\,du,$ 然后设置 $y_i = f(x_i)$。\n- 对于末端索引 $i=n$，通过求解 $F(x_n) = S - \\varepsilon$ 来数值近似 $x_n$，其中 $\\varepsilon > 0$ 是一个指定的容差，然后设置 $y_n = f(x_n)$。\n- 通过计算 $E = \\max_{1\\le i\\le n}\\left|\\int_{x_{i-1}}^{x_i} f(x)\\,dx - A\\right|$ 来数值验证等面积条件在小的数值误差范围内成立。\n\n该算法必须为满足上述假设的任何 $f$ 通用实现，并且必须使用数值积分进行积分运算，使用有界求根法进行求逆任务。\n\n测试套件：\n为以下测试用例实现并运行你的算法。在每种情况下，最终要报告的量是上面定义的实数 $E$。\n\n- 情况 1（理想情况）：$f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\big(-\\frac{x^2}{2}\\big)$ 对于 $x\\ge 0$（限制在 $[0,\\infty)$ 上的标准正态密度），其中 $n=8$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 情况 2（平滑指数）：$f(x) = e^{-x}$ 对于 $x\\ge 0$（速率为 $1$ 的指数密度），其中 $n=64$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 情况 3（边界条件）：$f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\big(-\\frac{x^2}{2}\\big)$ 对于 $x\\ge 0$，其中 $n=1$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 情况 4（大 $n$ 压力测试）：$f(x) = e^{-x}$ 对于 $x\\ge 0$，其中 $n=256$，尾部容差 $\\varepsilon = 10^{-12}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果按上述用例的顺序列出。准确地说，打印的行必须是以下形式\n$$[E_1,E_2,E_3,E_4],$$\n其中 $E_k$ 是为第 $k$ 个用例计算出的实数。不应打印任何其他文本。", "solution": "用户提供了一个来自随机模拟数值方法领域的提法良好的问题陈述。任务是实现并测试一个用于预计算等面积垂直划分参数的构造性算法，这是 Ziggurat 随机变量生成方法的核心组成部分。该问题具有科学依据、形式化规定且内部一致。因此，它被认为是有效的。\n\n问题要求为定义在 $[0, \\infty)$ 上的一个给定的非负、可积且单调非增的函数 $f(x)$ 构造一个横坐标序列 $0 = x_0  x_1  \\dots  x_n$ 和相应的纵坐标序列 $y_i = f(x_i)$。该构造必须满足 $n$ 个垂直条带的等面积条件。\n\n该算法流程如下：\n\n**1. 总质量和目标面积的计算**\n首先，使用数值积分计算函数 $f$ 在其定义域 $[0, \\infty)$ 上的总质量（积分）：\n$$\nS = \\int_{0}^{\\infty} f(x)\\,dx\n$$\n定义域被划分为 $n$ 个部分，每个部分旨在包含总质量的相等份额。因此，每个部分的目标面积是：\n$$\nA = \\frac{S}{n}\n$$\n\n**2. 累积积分函数**\n构造的核心依赖于累积积分函数 $F(x)$，其定义为：\n$$\nF(x) = \\int_{0}^{x} f(u)\\,du\n$$\n由于 $f(x) \\ge 0$，$F(x)$ 是一个单调非减函数。又因为 $f$ 也被指定为非增函数，所以 $F(x)$ 是一个凹函数。在 $f(x) > 0$ 的区间上，$F(x)$ 的严格单调性保证了其反函数是良定义的，这对于找到横坐标 $x_i$ 至关重要。在此实现中，$F(x)$ 将在任何给定的 $x$ 处使用数值积分进行评估。\n\n**3. 横坐标的迭代构造**\n横坐标 $x_i$ 是按顺序确定的。\n\n- **初始化**：序列从原点的边界条件开始：\n  $$\n  x_0 = 0, \\quad y_0 = f(0)\n  $$\n\n- **内部横坐标 ($i = 1, \\dots, n-1$)**：对于每个内部索引 $i$，横坐标 $x_i$ 由等面积条件定义。理想情况下，直到 $x_i$ 的累积面积应为 $i \\cdot A$。这引出方程：\n  $$\n  F(x_i) = \\int_{0}^{x_i} f(u)\\,du = i \\cdot A\n  $$\n  必须求解这个方程以得到 $x_i$。我们可以定义一个函数 $g_i(x) = F(x) - iA$ 并找到它的根。由于 $F(x)$ 是单调的，存在唯一的根。我们采用一种有界求根算法，例如 Brent 方法，它既稳健又高效。为了找到 $g_i(x) = 0$ 的根，我们必须提供一个区间 $[a, b]$ 使得 $g_i(a) \\cdot g_i(b)  0$。\n    - 一个自然的下界是 $a = x_{i-1}$，因为 $x_i$ 序列必须是严格递增的。在这一点，$F(x_{i-1}) \\approx (i-1)A$，这意味着 $g_i(x_{i-1}) = F(x_{i-1}) - iA \\approx (i-1)A - iA = -A  0$。\n    - 可以通过扩展搜索找到一个上界 $b > x_{i-1}$，直到 $g_i(b) > 0$。\n  一旦数值上确定了 $x_i$，相应的纵坐标就是 $y_i = f(x_i)$。\n\n- **末端横坐标 ($i=n$)**：在精确数学中，$x_n = \\infty$ 将确保最后一部分包含剩余的面积 $A$。对于数值计算，$x_n$ 用一个有限值来近似，该值捕获了分布尾部几乎所有剩余的质量，只留下一个小的、指定的剩余面积 $\\varepsilon$。条件是：\n  $$\n  \\int_{x_n}^{\\infty} f(x)\\,dx = \\varepsilon\n  $$\n  这等价于找到 $x_n$ 使得 $F(x_n) = S - \\varepsilon$。我们通过找到函数 $h(x) = F(x) - (S - \\varepsilon)$ 的根来求解 $x_n$。区间限定和求根过程与用于内部横坐标的过程类似，使用 $x_{n-1}$ 作为搜索的下界。最后，$y_n = f(x_n)$。\n\n**4. 数值验证**\n最后一步是通过计算最大绝对误差 $E$ 来验证构造的准确性。对于每个部分 $i \\in \\{1, \\dots, n\\}$，曲线下的实际面积通过数值积分计算：\n$$\nA_i = \\int_{x_{i-1}}^{x_i} f(x)\\,dx\n$$\n每个部分的误差是 $|A_i - A|$。总误差度量 $E$ 是这些单个误差的最大值：\n$$\nE = \\max_{1 \\le i \\le n} |A_i - A|\n$$\n由于 $x_n$ 的定义，最后一部分的面积 $A_n = F(x_n) - F(x_{n-1})$ 将大约是 $(S-\\varepsilon) - (n-1)A = (nA-\\varepsilon) - (n-1)A = A-\\varepsilon$。因此，它对误差的贡献是 $| (A-\\varepsilon) - A | = \\varepsilon$。因此，如果其他部分的积分和求根的数值误差较小，总误差 $E$ 预计至少为 $\\varepsilon$，并将主要由 $\\varepsilon$ 决定。为确保这一点，数值积分程序的容差设置必须比 $\\varepsilon$ 更严格。\n\n这个过程是使用 `scipy` 库实现的，特别是使用 `scipy.integrate.quad` 进行所有数值积分，并使用 `scipy.optimize.brentq` 进行有界求根。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\nfrom typing import Callable\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def compute_ziggurat_params(f: Callable[[float], float], n: int, epsilon: float) -> float:\n        \"\"\"\n        Constructs the Ziggurat partitions and computes the maximum area error.\n\n        Args:\n            f: The probability density function on [0, inf).\n            n: The number of partitions.\n            epsilon: The tail tolerance for the last partition.\n\n        Returns:\n            The maximum error E.\n        \"\"\"\n        # Define high-precision quadrature options to ensure numerical errors\n        # do not dominate the prescribed tolerance epsilon.\n        quad_opts = {'epsabs': 1e-14, 'epsrel': 1e-14}\n        \n        # Step 1: Compute the total mass S.\n        S, _ = quad(f, 0, np.inf, **quad_opts)\n\n        # Step 2: Compute the target area A.\n        A = S / n\n\n        # Initialize arrays for abscissae and ordinates.\n        x = np.zeros(n + 1)\n        y = np.zeros(n + 1)\n\n        # Step 3: Initialize x_0 and y_0.\n        x[0] = 0.0\n        y[0] = f(x[0])\n\n        memoized_F = {}\n        def F(val: float) -> float:\n            \"\"\"Cumulative integral F(x) with memoization for performance.\"\"\"\n            if val in memoized_F:\n                return memoized_F[val]\n            if val == 0:\n                return 0.0\n            res, _ = quad(f, 0, val, **quad_opts)\n            memoized_F[val] = res\n            return res\n\n        # Step 4: Compute interior abscissae x_i for i = 1, ..., n-1.\n        if n > 1:\n            for i in range(1, n):\n                target_F = i * A\n                \n                # Define the function whose root we need to find.\n                g = lambda val: F(val) - target_F\n                \n                # Bracket the root. The lower bound is the previous abscissa.\n                a = x[i-1]\n                \n                # The value at the lower bound should be negative.\n                # g(a) = F(x_{i-1}) - i*A ≈ (i-1)*A - i*A = -A\n                \n                # Perform an expanding search for the upper bound.\n                b = a + 1.0 \n                # In the rare case of starting at a root...\n                if g(a) == 0:\n                    a -= 1e-9 \n                \n                while g(b)  0:\n                    a = b\n                    b *= 1.5\n                \n                # Solve for x_i using Brent's method.\n                x[i] = brentq(g, a, b)\n                y[i] = f(x[i])\n\n        # Step 5: Compute the terminal abscissa x_n.\n        target_F_n = S - epsilon\n        \n        # Define the function for the terminal root-finding problem.\n        h = lambda val: F(val) - target_F_n\n        \n        # Bracket the root for x_n. Lower bound is x_{n-1}.\n        a_n = x[n-1]\n        \n        # Expanding search for the upper bound.\n        b_n = a_n + 1.0\n        # h(a_n) = F(x_{n-1}) - (S - epsilon) ≈ (n-1)*A - S + epsilon = -A + epsilon  0\n        if h(a_n) >= 0: # Handle edge case where n=1 and S-epsilon is very small\n            b_n = a_n\n            a_n -= 1.0\n            while h(a_n) >= 0: a_n -= 1.0\n\n        while h(b_n)  0:\n            a_n = b_n\n            b_n *= 1.5\n\n        # Solve for x_n.\n        x[n] = brentq(h, a_n, b_n)\n        y[n] = f(x[n])\n\n        # Step 6: Verify the equal-area condition numerically.\n        errors = []\n        for i in range(1, n + 1):\n            slice_area, _ = quad(f, x[i-1], x[i], **quad_opts)\n            errors.append(abs(slice_area - A))\n            \n        E = max(errors)\n        return E\n\n    # Test Suite\n    # Case 1: Standard normal density (half-normal)\n    f_normal = lambda x: (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-x**2 / 2.0)\n    \n    # Case 2: Standard exponential density\n    f_exp = lambda x: np.exp(-x)\n\n    test_cases = [\n        {'f': f_normal, 'n': 8, 'epsilon': 1e-12},\n        {'f': f_exp, 'n': 64, 'epsilon': 1e-12},\n        {'f': f_normal, 'n': 1, 'epsilon': 1e-12},\n        {'f': f_exp, 'n': 256, 'epsilon': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        E = compute_ziggurat_params(case['f'], case['n'], case['epsilon'])\n        results.append(E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3356972"}, {"introduction": "金字塔算法卓越效率的核心在于其能够在核心采样循环中用快速的整数运算替代高成本的浮点运算。本练习将深入探讨这一关键优化，要求您设计一个仅使用位运算的映射，将单个均匀分布的整数转换为层索引和矩形内坐标，并证明其正确性。掌握这一概念是理解金字塔算法为何能成为当前最先进的随机变量生成技术的关键。[@problem_id:3357000]", "problem": "您正在实现 Ziggurat 方法中使用的核心纯整数映射原语，该原语用于将均匀分布的 $32$ 位整数转换为包含层索引和矩形内坐标的元组。请考虑以下一般要求。您必须设计一个映射，将一个 $32$ 位均匀分布整数 $R \\in \\{0,1,\\dots,2^{32}-1\\}$ 映射到一个三元组 $(i,u,v)$，其中 $i$ 是层索引，$(u,v)$ 是单位正方形内的坐标，这些坐标稍后将根据所选层的矩形宽度和高度进行缩放。该映射必须满足以下约束条件。\n\n1. 位切片设计：\n   - 选择非负整数 $b,m,n$，使得 $b + m + n = 32$。\n   - 该映射必须仅依赖于位切片、整数移位、掩码和比较。具体来说，在从 $R$ 中提取 $i,u,v$ 时，不得使用浮点乘法。\n   - 将 $(u,v)$ 解释为定点分数，即形式为 $u = U / 2^m$ 和 $v = V / 2^n$ 的有理数，其中整数 $U \\in \\{0,1,\\dots,2^m-1\\}$ 和 $V \\in \\{0,1,\\dots,2^n-1\\}$。\n\n2. 层数支持：\n   - 对于层数 $K = 2^b$ 的情况，该映射必须是 $\\{0,1,\\dots,2^{32}-1\\}$ 到 $\\{0,1,\\dots,K-1\\} \\times \\{0,1,\\dots,2^m-1\\} \\times \\{0,1,\\dots,2^n-1\\}$ 的一个双射（在上述定点解释下），并且必须能导出 $i$、$u$ 和 $v$ 之间的独立性。\n   - 对于层数 $K \\le 2^b$ 且不为 2 的幂的情况，必须通过对层索引进行拒绝采样来扩展映射，使得 $i$ 在 $\\{0,1,\\dots,K-1\\}$ 上精确均匀分布，同时仍然只使用整数运算，并保持被接受的 $i$ 与定点坐标 $(u,v)$ 之间的独立性。拒绝采样必须仅基于切片出的索引位。\n\n3. 证明义务：\n   - 从一个 $32$ 位均匀整数在其状态空间上是均匀的，并且不同位是参数为 $1/2$ 的独立伯努利分布这一基本事实出发，证明您的映射在 $i$ 和 $(u,v)$ 各自的离散网格上产生了边缘均匀性，并证明在 $K = 2^b$ 的情况和 $K \\le 2^b$ 的拒绝采样情况下的独立性属性。\n\n4. 程序要求：\n   - 为两种场景实现您的映射：\n     (a) $K = 2^b$，其中 $(b,m,n) = (8,12,12)$。\n     (b) $K = 250 \\le 2^8$，其中 $(b,m,n) = (8,12,12)$，并且仅对最高的 $b$ 位使用拒绝采样。\n   - 为了测试，您将使用固定种子的蒙特卡洛模拟。所有随机性都来自对 $32$ 位均匀整数的独立抽取。\n\n5. 统计测试套件和输出：\n   实现以下测试。每个测试必须根据指定的统计决策规则生成一个布尔值。使用显著性水平 $\\alpha = 0.01$。当需要进行卡方检验时，请使用标准的卡方拟合优度检验或卡方独立性检验，不使用 Yates 连续性校正。\n\n   测试集 A（2的幂次方情况）：\n   - 参数：$K = 2^8$，$b = 8$，$m = 12$，$n = 12$，样本量 $N_A = 400000$。\n   - A1: 通过具有相等期望计数的卡方拟合优度检验，测试层索引 $i$ 在 $\\{0,1,\\dots,255\\}$ 上的均匀性。输出布尔值 $T_{A1}$，表示在水平 $\\alpha$ 下原假设是否未被拒绝。\n   - A2: 通过具有相等期望计数的卡方拟合优度检验，测试水平定点坐标 $U \\in \\{0,1,\\dots,4095\\}$ 的均匀性。输出布尔值 $T_{A2}$。\n   - A3: 通过对 $256 \\times 16$ 列联表进行卡方独立性检验，测试 $i$ 与一个粗化水平坐标 $U_{\\mathrm{coarse}} \\in \\{0,1,\\dots,15\\}$ 之间的独立性，该坐标由 $U$ 的最高 4 位定义。输出布尔值 $T_{A3}$。\n\n   测试集 B（2的幂次方情况下位切片的边界确定性）：\n   - 参数：$K = 2^8$，$b = 8$，$m = 12$，$n = 12$。\n   - B1: 对于 $R = 0$，验证 $(i,U,V) = (0,0,0)$。输出布尔值 $T_{B1}$。\n   - B2: 对于 $R = 2^{32}-1$，验证 $(i,U,V) = (255,4095,4095)$。输出布尔值 $T_{B2}$。\n\n   测试集 C（非2的幂次方情况，对索引位进行拒绝采样）：\n   - 参数：$K = 250$，$b = 8$，$m = 12$，$n = 12$，样本量 $N_C = 300000$。\n   - C1: 仅使用对索引位的拒绝采样，通过具有相等期望计数的卡方拟合优度检验，测试 $i$ 在 $\\{0,1,\\dots,249\\}$ 上的均匀性。输出布尔值 $T_{C1}$。\n   - C2: 通过具有相等期望计数的卡方拟合优度检验，测试 $U \\in \\{0,1,\\dots,4095\\}$ 的均匀性。输出布尔值 $T_{C2}$。\n   - C3: 通过对 $250 \\times 16$ 列联表进行卡方独立性检验，测试 $i$ 与 $U_{\\mathrm{coarse}} \\in \\{0,1,\\dots,15\\}$ 之间的独立性。输出布尔值 $T_{C3}$。\n\n6. 最终输出格式：\n   您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[true1,true2,...]”），结果按以下顺序排列：\n   - $[T_{A1}, T_{A2}, T_{A3}, T_{B1}, T_{B2}, T_{C1}, T_{C2}, T_{C3}]$。\n\n所有角度都是无量纲的，不涉及物理单位。所有答案必须是布尔值，打印为 Python 字面量 `true` 或 `false`。整个程序必须在没有输入的情况下运行，使用其内部测试套件和固定的随机种子以保证可复现性。确保所有与映射相关的计算仅使用整数位切片、移位、掩码、比较和整数算術。浮点运算只能用于统计测试，且不影响映射设计本身。", "solution": "我们从离散均匀随机变量在二进制表示上的基本事实开始。设 $R$ 在 $\\{0,1,\\dots,2^{32}-1\\}$ 上均匀分布。那么：\n\n1. 从 $R$ 到其位向量 $(B_{31},B_{30},\\dots,B_{0}) \\in \\{0,1\\}^{32}$ 的映射（其中 $R = \\sum_{j=0}^{31} B_j 2^j$）是 $\\{0,1,\\dots,2^{32}-1\\}$ 和 $\\{0,1\\}^{32}$ 之间的一个双射。因此，$R$ 的均匀分布意味着位向量在 $\\{0,1\\}^{32}$ 上是均匀分布的。\n\n2. 不同位位置的独立性：对于任意子集 $S \\subset \\{0,1,\\dots,31\\}$，位 $(B_j)_{j \\in S}$ 是独立的，并且每个边缘分布 $B_j$ 是参数为 $1/2$ 的伯努利分布。这是由位向量在笛卡尔积 $\\{0,1\\}^{32}$ 上的均匀性得出的。\n\n利用这些事实，我们通过位切片设计一个从 $R$ 到 $(i,u,v)$ 的纯整数映射。选择非负整数 $b,m,n$ 使得 $b+m+n=32$，并定义整数值坐标\n$$\nI(R) \\equiv \\left\\lfloor \\frac{R}{2^{32-b}} \\right\\rfloor, \\quad\nU(R) \\equiv \\left\\lfloor \\frac{R \\bmod 2^{32-b}}{2^n} \\right\\rfloor, \\quad\nV(R) \\equiv R \\bmod 2^n.\n$$\n等价地，使用移位和掩码：\n`I(R) = R >> (32-b)`\n`U(R) = (R >> n)  ((1  m) - 1)`\n`V(R) = R  ((1  n) - 1)`\n其中 `>>` 是无符号整数的算术右移，`` 是按位与，`` 是按位左移。定点坐标为 $u(R) = U(R)/2^m$ 和 $v(R) = V(R)/2^n$。\n\n情况 1：层数为 2 的幂，$K = 2^b$。\n我们断言映射\n$$\n\\Phi: \\{0,1,\\dots,2^{32}-1\\} \\to \\{0,1,\\dots,2^b-1\\} \\times \\{0,1,\\dots,2^m-1\\} \\times \\{0,1,\\dots,2^n-1\\},\n$$\n由 $\\Phi(R) = \\big(I(R), U(R), V(R)\\big)$ 给出，是一个双射。这是因为位切片将 $32$ 位划分为三个长度分别为 $b,m,n$ 的不相交块；每个三元组 $(i,u,v)$ 都精确对应一个在那些位置具有那些位的 $R$。因此：\n- $I$ 的均匀性：由于 $\\Phi$ 是一个双射且 $R$ 在大小为 $2^{32}$ 的集合上是均匀的，所以 $I$ 的边缘分布在 $\\{0,\\dots,2^b-1\\}$ 上是均匀的，因为每个 $i$ 都出现在恰好 $2^{m+n} = 2^{32-b}$ 个原像中。\n- $U$ 和 $V$ 的均匀性：类似地，每个 $u$ 和每个 $v$ 分别出现在恰好 $2^{b+n}$ 和 $2^{b+m}$ 个原像中，从而在其离散网格上产生均匀的离散分布。\n- 独立性：因为位块是不相交的，并且位向量在 $\\{0,1\\}^{32}$ 上是均匀分布的，所以三元组 $(I,U,V)$ 可以分解为独立坐标的笛卡尔积。更明确地说，对于任何 $(i,u,v)$，\n$$\n\\mathbb{P}(I=i, U=u, V=v) = \\frac{1}{2^{32}} = \\frac{1}{2^b} \\cdot \\frac{1}{2^m} \\cdot \\frac{1}{2^n} = \\mathbb{P}(I=i)\\, \\mathbb{P}(U=u)\\, \\mathbb{P}(V=v).\n$$\n因此 $I$、$U$ 和 $V$ 是相互独立的，定点分数 $u = U/2^m$ 和 $v = V/2^n$ 继承了这些性质。\n\n情况 2：层数不为 2 的幂，$K \\le 2^b$，对索引位进行拒绝采样。\n像之前一样定义 $I^\\ast(R) = \\left\\lfloor R/2^{32-b} \\right\\rfloor$，但现在仅当 $I^\\ast(R) \\in \\{0,1,\\dots,K-1\\}$ 时才接受这次抽取；否则，独立地重新抽取一个新的 $R$ 并重复该过程。一旦接受，就使用同一个被接受的 $R$ 的较低 $m$ 位和 $n$ 位来定义 $U(R)$ 和 $V(R)$。\n\n我们现在证明：\n- 被接受的索引 $I$ 在 $\\{0,1,\\dots,K-1\\}$ 上是均匀分布的。确实，对于每个 $i \\in \\{0,\\dots,K-1\\}$，接受事件是 $\\{I^\\ast(R) = i\\}$，其概率为 $2^{32-b}/2^{32} = 2^{-b}$。在接受的条件下， $I=i$ 的概率是 $\\frac{2^{-b}}{K \\cdot 2^{-b}} = 1/K$。\n- $(U,V)$与$I$之间的独立性：接受与否的决定仅取决于最高的 $b$ 位。由于不相交位块的独立性，较低的 $m+n$ 位独立于最高的 $b$ 位。以接受事件（它仅是最高位的函数）为条件，并不会改变较低位的分布；因此 $(U,V)$ 仍然独立于接受指示符和实现的 $I$。特别地，$\\mathbb{P}(U=u, V=v \\mid I=i) = 2^{-(m+n)}$，所以 $(U,V)$ 在其网格上是均匀分布的并且独立于 $I$。\n- $U$ 和 $V$ 的均匀性：直接由上述独立性论证得出。\n\n因此，这种拒绝采样方案保留了所需的均匀性和独立性，同时仅使用整数移位、掩码和比较。映射本身不使用浮点乘法；仅在解释定点分数时可能需要除以 $2^m$ 或 $2^n$，但这对于映射的正确性不是必需的，并且如果保留整数定点坐标，则可以避免。\n\n统计验证设计。\n为了凭经验验证该映射，我们在显著性水平 $\\alpha = 0.01$ 下执行用于均匀性检验的卡方拟合优度检验和用于独立性检验的卡方检验。我们使用：\n- 测试集 A，用于 $K=2^8$，$(b,m,n)=(8,12,12)$ 和样本量 $N_A = 400000$，检查 $I$ 的均匀性、$U$ 的均匀性以及 $I$ 和一个由 $U$ 的最高 4 位形成的粗化 $U_{\\mathrm{coarse}}$ 之间的独立性。\n- 测试集 B，用于确定性边界 $R=0$ 和 $R=2^{32}-1$，验证精确的位切片输出。\n- 测试集 C，用于 $K=250 \\le 2^8$ 的拒绝采样情况，$(b,m,n)=(8,12,12)$ 和样本量 $N_C = 300000$，检查 $I$ 的均匀性、$U$ 的均匀性以及 $I$ 和 $U_{\\mathrm{coarse}}$ 之间的独立性。\n\n我们固定伪随机数生成器的种子以确保可复现性。预期的结果是布尔值：\n- 如果映射产生的分布在水平 $\\alpha$ 下与均匀性和独立性一致，则 $T_{A1}, T_{A2}, T_{A3}$ 应为真。\n- 如果边界位切片实现正确，则 $T_{B1}, T_{B2}$ 应均为真。\n- 对于基于拒绝采样的映射，$T_{C1}, T_{C2}, T_{C3}$ 应为真。\n\n所有映射计算仅使用整数位切片。浮点算术仅出现在统计测试函数内部，不影响映射的均匀性属性。最终程序按指定顺序汇总这八个布尔值，并按要求将它们打印在单行上。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chisquare, chi2_contingency\n\n# Mapping functions using integer-only bit slicing.\n\ndef slice_bits_power_of_two(R_uint32, b, m, n):\n    \"\"\"\n    Vectorized bit-slicing mapping for K = 2^b.\n    Input:\n        R_uint32: np.ndarray of dtype np.uint32\n        b, m, n: nonnegative integers with b+m+n = 32\n    Output:\n        i: np.ndarray of indices in [0, 2^b-1]\n        U: np.ndarray of ints in [0, 2^m-1] (fixed-point horizontal coordinate)\n        V: np.ndarray of ints in [0, 2^n-1] (fixed-point vertical coordinate)\n    \"\"\"\n    assert b + m + n == 32\n    R = R_uint32.astype(np.uint32)\n    if b == 0:\n        i = np.zeros_like(R, dtype=np.uint32)\n    else:\n        i = (R >> np.uint32(32 - b)).astype(np.uint32)\n    if n == 0:\n        V = np.zeros_like(R, dtype=np.uint32)\n        U = R  ((np.uint32(1)  np.uint32(m)) - np.uint32(1))\n    else:\n        V = (R  ((np.uint32(1)  np.uint32(n)) - np.uint32(1))).astype(np.uint32)\n        if m == 0:\n            U = np.zeros_like(R, dtype=np.uint32)\n        else:\n            U = ((R >> np.uint32(n))  ((np.uint32(1)  np.uint32(m)) - np.uint32(1))).astype(np.uint32)\n    return i, U, V\n\ndef slice_bits_with_rejection_K_le_2b(size, K, b, m, n, rng):\n    \"\"\"\n    Vectorized rejection scheme on the index bits only for K = 2^b.\n    Returns exactly 'size' accepted samples of (i, U, V).\n    \"\"\"\n    assert b + m + n == 32\n    assert 1 = K = (1  b)\n    i_out = np.empty(size, dtype=np.uint32)\n    U_out = np.empty(size, dtype=np.uint32)\n    V_out = np.empty(size, dtype=np.uint32)\n    filled = 0\n    # Use batches to reduce overhead; batch size chosen adaptively.\n    # Expected acceptance probability is K / 2^b.\n    acc_prob = K / (1  b)\n    # Choose a batch size that likely yields enough acceptances per batch.\n    base_batch = max(10000, int(1.5 * size / max(acc_prob, 1e-6)))\n    # Cap the batch size to keep memory reasonable\n    base_batch = min(base_batch, 1_000_000)\n\n    while filled  size:\n        batch = min(base_batch, size - filled)\n        R = rng.integers(0, 1  32, size=batch, dtype=np.uint32)\n        i, U, V = slice_bits_power_of_two(R, b, m, n)\n        mask = (i  K)\n        num_acc = int(mask.sum())\n        if num_acc > 0:\n            end_fill = filled + num_acc\n            if end_fill > size:\n                num_acc = size - filled\n                end_fill = size\n            i_out[filled:end_fill] = i[mask][:num_acc]\n            U_out[filled:end_fill] = U[mask][:num_acc]\n            V_out[filled:end_fill] = V[mask][:num_acc]\n            filled += num_acc\n    return i_out, U_out, V_out\n\n# Statistical tests.\n\ndef test_uniform_counts(values, num_categories, alpha=0.01):\n    \"\"\"\n    Chi-square goodness-of-fit test for uniformity over num_categories.\n    values: np.ndarray of nonnegative integers expected in [0, num_categories-1]\n    Returns True if p-value > alpha, else False.\n    \"\"\"\n    counts = np.bincount(values, minlength=num_categories).astype(np.int64)\n    # Ensure we restrict to exact length\n    counts = counts[:num_categories]\n    expected = np.full(num_categories, counts.sum() / num_categories)\n    stat, p = chisquare(counts, f_exp=expected)\n    return bool(p > alpha)\n\ndef test_independence(x, x_categories, y, y_categories, alpha=0.01):\n    \"\"\"\n    Chi-square test of independence on the contingency table formed by (x,y).\n    Returns True if p-value > alpha else False.\n    \"\"\"\n    # Build contingency table via flat indexing\n    flat = (x.astype(np.int64) * y_categories + y.astype(np.int64))\n    counts = np.bincount(flat, minlength=x_categories * y_categories).astype(np.int64)\n    table = counts.reshape((x_categories, y_categories))\n    chi2, p, dof, expected = chi2_contingency(table, correction=False)\n    return bool(p > alpha)\n\ndef main():\n    rng = np.random.default_rng(20250110)\n\n    # Test set A: K=2^8, (b,m,n)=(8,12,12), N_A=400000\n    b = 8\n    m = 12\n    n = 12\n    K_pow2 = 1  b\n    N_A = 400_000\n    R_A = rng.integers(0, 1  32, size=N_A, dtype=np.uint32)\n    i_A, U_A, V_A = slice_bits_power_of_two(R_A, b, m, n)\n\n    T_A1 = test_uniform_counts(i_A, K_pow2, alpha=0.01)\n    T_A2 = test_uniform_counts(U_A, 1  m, alpha=0.01)\n    # Coarse U: top 4 bits of U\n    U_A_coarse = (U_A >> np.uint32(m - 4)).astype(np.uint32)\n    T_A3 = test_independence(i_A, K_pow2, U_A_coarse, 1  4, alpha=0.01)\n\n    # Test set B: Boundary determinism for power-of-two case\n    R_low = np.uint32(0)\n    i_low, U_low, V_low = slice_bits_power_of_two(np.array([R_low], dtype=np.uint32), b, m, n)\n    T_B1 = bool((i_low[0] == 0) and (U_low[0] == 0) and (V_low[0] == 0))\n\n    R_high = np.uint32((1  32) - 1)\n    i_high, U_high, V_high = slice_bits_power_of_two(np.array([R_high], dtype=np.uint32), b, m, n)\n    T_B2 = bool((i_high[0] == (K_pow2 - 1)) and (U_high[0] == ((1  m) - 1)) and (V_high[0] == ((1  n) - 1)))\n\n    # Test set C: K=250 = 2^8, rejection on index bits only, N_C=300000\n    K_nonpow = 250\n    N_C = 300_000\n    i_C, U_C, V_C = slice_bits_with_rejection_K_le_2b(N_C, K_nonpow, b, m, n, rng)\n\n    T_C1 = test_uniform_counts(i_C, K_nonpow, alpha=0.01)\n    T_C2 = test_uniform_counts(U_C, 1  m, alpha=0.01)\n    U_C_coarse = (U_C >> np.uint32(m - 4)).astype(np.uint32)\n    T_C3 = test_independence(i_C, K_nonpow, U_C_coarse, 1  4, alpha=0.01)\n\n    results = [T_A1, T_A2, T_A3, T_B1, T_B2, T_C1, T_C2, T_C3]\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3357000"}, {"introduction": "衡量任何拒绝采样算法性能的一个关键指标是其接受率，因为它直接关系到计算效率。本练习将聚焦于量化金字塔采样器的性能，通过计算每成功生成一个样本所期望的拒绝次数。您将使用假设但符合实际的各层接受概率，并运用基础概率论原理来推导一个关键的性能指标，从而突显金字塔算法固有的高效率特性。[@problem_id:3357060]", "problem": "考虑使用 Ziggurat 方法，通过均匀选择层的方式，从标准正态概率密度函数 (PDF) $f(x) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{x^{2}}{2}\\right)$ 中进行抽样，其中层数为 $n=256$。设一次尝试表示 Ziggurat 过程中的单次抽取（即随机均匀地选择一个层并执行相应的接受性测试）。假设每次尝试都是独立的。为了进行性能分析，接受概率已被制成表格，并按每 16 个连续层组成的块进行平均。分块接受概率 $\\bar{p}_{g}$（每个值代表 16 个层的平均接受概率）如下：\n- 块 1：$\\bar{p}_{1} = 0.9996$\n- 块 2：$\\bar{p}_{2} = 0.9995$\n- 块 3：$\\bar{p}_{3} = 0.9994$\n- 块 4：$\\bar{p}_{4} = 0.9993$\n- 块 5：$\\bar{p}_{5} = 0.9992$\n- 块 6：$\\bar{p}_{6} = 0.9990$\n- 块 7：$\\bar{p}_{7} = 0.9989$\n- 块 8：$\\bar{p}_{8} = 0.9987$\n- 块 9：$\\bar{p}_{9} = 0.9985$\n- 块 10：$\\bar{p}_{10} = 0.9982$\n- 块 11：$\\bar{p}_{11} = 0.9980$\n- 块 12：$\\bar{p}_{12} = 0.9975$\n- 块 13：$\\bar{p}_{13} = 0.9970$\n- 块 14：$\\bar{p}_{14} = 0.9962$\n- 块 15：$\\bar{p}_{15} = 0.9950$\n- 块 16：$\\bar{p}_{16} = 0.9900$\n\n从第一性原理出发，推导每个接受样本对应的期望拒绝步骤数的表达式，并使用所提供的表格化接受概率计算其值。将最终数值答案四舍五入至三位有效数字。无需单位。", "solution": "要找到生成一个接受样本所需的期望拒绝步骤数，我们首先需要确定在 Ziggurat 过程中的单次尝试的总体接受概率。\n\n设 $p$ 为单次尝试的总体接受概率。一次尝试包括从 $n=256$ 个层中均匀选择一个，并执行相应的接受性测试。设 $p_i$ 为第 $i$ 层的接受概率，其中 $i \\in \\{1, 2, \\dots, 256\\}$。由于层的选择是均匀的，选择任何给定层 $i$ 的概率是 $\\frac{1}{n}$。\n\n根据全概率定律，总体接受概率 $p$ 是各个层概率的平均值：\n$$p = \\sum_{i=1}^{n} P(\\text{accept} | \\text{layer } i) P(\\text{layer } i) = \\sum_{i=1}^{n} p_i \\left(\\frac{1}{n}\\right) = \\frac{1}{n} \\sum_{i=1}^{n} p_i$$\n\n问题给出了 $N_b=16$ 个块的平均接受概率 $\\bar{p}_g$，每个块包含 $m=16$ 个层。对于给定的块 $g$，这个平均值定义为：\n$$\\bar{p}_g = \\frac{1}{m} \\sum_{i \\in \\text{Block } g} p_i$$\n\n各个层概率的总和可以表示为所有块上概率之和：\n$$\\sum_{i=1}^{n} p_i = \\sum_{g=1}^{N_b} \\left( \\sum_{i \\in \\text{Block } g} p_i \\right) = \\sum_{g=1}^{N_b} (m \\cdot \\bar{p}_g)$$\n\n将此代入 $p$ 的表达式中，并注意 $n = N_b \\cdot m$：\n$$p = \\frac{1}{n} \\sum_{g=1}^{N_b} (m \\cdot \\bar{p}_g) = \\frac{m}{n} \\sum_{g=1}^{N_b} \\bar{p}_g = \\frac{m}{N_b \\cdot m} \\sum_{g=1}^{N_b} \\bar{p}_g = \\frac{1}{N_b} \\sum_{g=1}^{N_b} \\bar{p}_g$$\n这表明总体接受概率 $p$ 是所提供的分块平均概率的算术平均值。\n\n现在我们对生成一个接受样本的过程进行建模。每次尝试都是一个独立的伯努利试验，成功概率为 $p$。设 $K$ 为获得第一次接受所需的尝试次数的随机变量。$K$ 服从参数为 $p$ 的几何分布：\n$$P(K=k) = (1-p)^{k-1}p, \\quad \\text{for } k=1, 2, 3, \\dots$$\n获得一个接受样本的期望尝试次数是该分布的均值：\n$$E[K] = \\frac{1}{p}$$\n如果需要 $K$ 次尝试才能获得一次接受，那么之前有 $K-1$ 次拒绝。问题要求的是每个接受样本的期望拒绝步骤数，即 $E[K-1]$。利用期望的线性性质：\n$$E[K-1] = E[K] - 1 = \\frac{1}{p} - 1$$\n这可以简化为：\n$$E[\\text{rejections per acceptance}] = \\frac{1-p}{p}$$\n\n现在，我们使用给定的数据来计算这个表达式的值。首先，我们通过对 $N_b=16$ 个分块概率求平均来计算 $p$：\n$$p = \\frac{1}{16} \\sum_{g=1}^{16} \\bar{p}_g$$\n给定概率的总和是：\n$$ \\sum_{g=1}^{16} \\bar{p}_g = 0.9996 + 0.9995 + 0.9994 + 0.9993 + 0.9992 + 0.9990 + 0.9989 + 0.9987 + 0.9985 + 0.9982 + 0.9980 + 0.9975 + 0.9970 + 0.9962 + 0.9950 + 0.9900 = 15.964 $$\n现在，我们求出总体接受概率 $p$：\n$$p = \\frac{15.964}{16} = 0.99775$$\n拒绝的概率是 $1-p$：\n$$1-p = 1 - 0.99775 = 0.00225$$\n最后，我们计算每个接受样本的期望拒绝次数：\n$$E[\\text{rejections per acceptance}] = \\frac{1-p}{p} = \\frac{0.00225}{0.99775} \\approx 0.002255150388$$\n问题要求答案四舍五入到三位有效数字。前三位有效数字是 $2$、$2$ 和 $5$。第四位有效数字是 $5$，所以我们将第三位数字向上取整。\n$$0.00225515... \\approx 0.00226$$\n因此，每个接受样本的期望拒绝步骤数约为 $0.00226$。", "answer": "$$\\boxed{0.00226}$$", "id": "3357060"}]}