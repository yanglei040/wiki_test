{"hands_on_practices": [{"introduction": "掌握一种新方法通常始于将其应用于一个基础分布，例如高斯分布。本练习将引导你从零开始，为这个重要的例子推导均匀比法的所有关键组成部分，包括可接受集 $A$ 的几何形状、最优边界矩形以及最终的接受率。通过这种方式，你可以对该方法的工作原理和效率建立起扎实的直觉。[@problem_id:3356654]", "problem": "考虑均匀比值法（ratio-of-uniforms）构造，用于从实线上由 $f(x)\\propto \\exp(-x^{2}/2)$ 给出的未归一化目标概率密度函数（PDF）中进行抽样。在均匀比值法中，我们在 $(u,v)$-平面上的一个集合 $A$ 内进行均匀抽样，并返回 $x=v/u$（其中 $u>0$）。仅从定义的变量变换 $(x,u)\\mapsto (u,v)=(u,ux)$（其中 $u>0$）以及确保目标密度与 $x$ 的边缘密度成正比的可接纳条件出发，完成以下任务：\n\n1. 推导描述此目标在 $(u,v)$-平面上的可接納集合 $A$ 的精确解析不等式。\n2. 通过计算 $\\max u$ 和 $\\max|v|$，确定 $A$ 的紧致轴对齐边界矩形。\n3. 计算一个算法的精确接受概率，该算法在此边界矩形上进行均匀提议，并且当且仅当提议的点位于 $A$ 中时才接受。\n4. 在使用方差参数为 $\\sigma^{2}>0$ 的高斯提议 $q_{\\sigma}(x)=(2\\pi\\sigma^{2})^{-1/2}\\exp(-x^{2}/(2\\sigma^{2}))$ 的经典拒绝抽样中，找到能够最小化相同未归一化目标 $f(x)\\propto \\exp(-x^{2}/2)$ 的拒绝界限的 $\\sigma$ 的选择和最小控制常数 $M$，并计算相应的接受概率。\n\n将您的最终答案以单行矩阵（使用圆括号表示法）的形式给出，按顺序包含：$A$ 的解析描述、$\\max u$、$\\max|v|$、来自均匀比值法边界矩形方案的接受概率，以及最优高斯提议拒绝抽样法的接受概率。给出精确表达式，不要进行数值近似。不需要四舍五入，也不涉及物理单位。如有角度，请以弧度表示。", "solution": "该问题是适定的，有科学依据，并包含唯一解所需的所有信息。我们将按顺序解决四个部分。未归一化的目标概率密度函数由 $f(x) \\propto \\exp(-x^2/2)$ 给出。为了确定性且不失均匀比值法的一般性，我们选择具体代表 $h(x) = \\exp(-x^2/2)$。\n\n首先，我们推导可接纳集合 $A$ 的解析描述。均匀比值法从 $(u,v)$-平面中由下式定义的集合 $A$ 中均匀抽样点 $(u,v)$：\n$$ A = \\left\\{ (u, v) \\in \\mathbb{R}^2 \\mid 0  u \\le \\sqrt{h(v/u)} \\right\\} $$\n代入我们为 $h(x)$ 选择的表达式，我们得到：\n$$ 0  u \\le \\sqrt{\\exp\\left(-\\frac{(v/u)^2}{2}\\right)} $$\n这可以简化为：\n$$ 0  u \\le \\exp\\left(-\\frac{v^2}{4u^2}\\right) $$\n由于 $u > 0$，我们可以对不等式 $u \\le \\exp(-v^2/(4u^2))$ 两边取自然对数：\n$$ \\ln(u) \\le -\\frac{v^2}{4u^2} $$\n两边乘以 $-4u^2$（这是一个負数，所以必须反转不等号）不是最好的方法。相反，让我们重新整理以分离 $v^2$：\n$$ 4u^2 \\ln(u) \\le -v^2 $$\n$$ v^2 \\le -4u^2 \\ln(u) $$\n为了使这个不等式对于 $v \\in \\mathbb{R}$ 有解，右侧必须是非负的。由于 $u^2 > 0$，我们需要 $-4\\ln(u) \\ge 0$，这意味着 $\\ln(u) \\le 0$。这对 $u \\in (0, 1]$ 成立。因此，集合 $A$ 由以下条件描述：\n$$ 0  u \\le 1 \\quad \\text{and} \\quad v^2 \\le -4u^2 \\ln(u) $$\n\n其次，我们确定 $A$ 的紧致轴对齐边界矩形。这需要找到集合 $A$ 上 $u$ 和 $|v|$ 的最大值。\n根据上面的推导，$u$ 的范围是 $(0, 1]$，所以 $u$ 的最大值是：\n$$ \\max u = 1 $$\n为了找到 $|v|$ 的最大值，我们需要在区间 $u \\in (0, 1]$ 上最大化表达式 $\\sqrt{-4u^2 \\ln(u)}$。这等价于最大化它的平方，即函数 $g(u) = -4u^2 \\ln(u)$。我们通过对 $u$ 求导并令其为零来找到最大值：\n$$ g'(u) = \\frac{d}{du}\\left(-4u^2 \\ln(u)\\right) = -4\\left(2u\\ln(u) + u^2\\frac{1}{u}\\right) = -4u(2\\ln(u) + 1) $$\n对于 $u \\in (0, 1]$，令 $g'(u) = 0$ 意味着 $2\\ln(u) + 1 = 0$，这给出 $\\ln(u) = -1/2$，所以 $u = \\exp(-1/2)$。\n为确认这是一个最大值，我们可以检查二阶导数，或者注意到当 $u  \\exp(-1/2)$ 时 $g'(u) > 0$，当 $u > \\exp(-1/2)$ 时 $g'(u)  0$。函数 $g(u)$ 在端点 $u \\to 0^+$ 和 $u=1$ 处的值为 $0$。因此，全局最大值出现在 $u = \\exp(-1/2)$。\n$g(u)$ 的最大值是：\n$$ g(\\exp(-1/2)) = -4(\\exp(-1/2))^2 \\ln(\\exp(-1/2)) = -4\\exp(-1)\\left(-\\frac{1}{2}\\right) = 2\\exp(-1) $$\n这是 $v^2$ 的最大值。因此，$|v|$ 的最大值是：\n$$ \\max|v| = \\sqrt{2\\exp(-1)} $$\n边界矩形为 $R = [0, 1] \\times [-\\sqrt{2\\exp(-1)}, \\sqrt{2\\exp(-1)}]$。\n\n第三，我们计算算法的接受概率。这是集合 $A$ 的面积与边界矩形 $R$ 的面积之比。\n边界矩形的面积是：\n$$ \\text{Area}(R) = (\\max u) \\times (2 \\max|v|) = 1 \\cdot 2\\sqrt{2\\exp(-1)} = 2\\sqrt{2\\exp(-1)} $$\n集合 $A$ 的面积由以下积分给出：\n$$ \\text{Area}(A) = \\iint_A du\\,dv = \\int_0^1 \\left( \\int_{-\\sqrt{-4u^2\\ln(u)}}^{\\sqrt{-4u^2\\ln(u)}} dv \\right) du = \\int_0^1 2\\sqrt{-4u^2\\ln(u)} \\,du = \\int_0^1 4u\\sqrt{-\\ln(u)} \\,du $$\n为了计算这个积分，我们使用换元法 $t = -\\ln(u)$，这意味着 $u = \\exp(-t)$ 且 $du = -\\exp(-t)dt$。积分上下限从 $u \\in (0, 1]$ 变为 $t \\in [\\infty, 0)$。\n$$ \\text{Area}(A) = \\int_\\infty^0 4\\exp(-t)\\sqrt{t} (-\\exp(-t)dt) = \\int_0^\\infty 4\\sqrt{t} \\exp(-2t) dt $$\n我们进行另一次换元，$s=2t$，所以 $t=s/2$ 且 $dt=ds/2$。\n$$ \\text{Area}(A) = \\int_0^\\infty 4\\sqrt{s/2} \\exp(-s) \\frac{ds}{2} = \\frac{4}{\\sqrt{2} \\cdot 2} \\int_0^\\infty s^{1/2} \\exp(-s) ds = \\sqrt{2} \\int_0^\\infty s^{3/2 - 1} \\exp(-s) ds $$\n该积分为 Gamma 函数 $\\Gamma(3/2)$。使用 $\\Gamma(z+1)=z\\Gamma(z)$ 和 $\\Gamma(1/2)=\\sqrt{\\pi}$，我们有 $\\Gamma(3/2) = \\frac{1}{2}\\Gamma(1/2) = \\frac{\\sqrt{\\pi}}{2}$。\n$$ \\text{Area}(A) = \\sqrt{2} \\cdot \\frac{\\sqrt{\\pi}}{2} = \\frac{\\sqrt{2\\pi}}{2} $$\n接受概率 $P_{\\text{acc, RoU}}$ 是：\n$$ P_{\\text{acc, RoU}} = \\frac{\\text{Area}(A)}{\\text{Area}(R)} = \\frac{\\sqrt{2\\pi}/2}{2\\sqrt{2\\exp(-1)}} = \\frac{\\sqrt{2\\pi}}{4\\sqrt{2}\\sqrt{\\exp(-1)}} = \\frac{\\sqrt{\\pi}}{4}\\sqrt{\\exp(1)} = \\frac{\\sqrt{\\pi \\exp(1)}}{4} $$\n\n第四，我们分析拒绝抽样方案。未归一化的目标是 $p^*(x) = \\exp(-x^2/2)$。提议是归一化的高斯密度 $q_{\\sigma}(x) = (2\\pi\\sigma^2)^{-1/2}\\exp(-x^2/(2\\sigma^2))$，其中 $\\sigma^2>0$。拒绝抽样需要找到一个常数 $M$，使得对所有 $x$ 都有 $p^*(x) \\le Mq_{\\sigma}(x)$。为了最大化接受率，我们必须找到最小的这样的 $M$。\n$$ M = \\sup_{x \\in \\mathbb{R}} \\frac{p^*(x)}{q_{\\sigma}(x)} = \\sup_{x \\in \\mathbb{R}} \\frac{\\exp(-x^2/2)}{(2\\pi\\sigma^2)^{-1/2}\\exp(-x^2/(2\\sigma^2))} = \\sup_{x \\in \\mathbb{R}} \\sqrt{2\\pi\\sigma^2} \\exp\\left(x^2\\left(\\frac{1}{2\\sigma^2} - \\frac{1}{2}\\right)\\right) $$\n为了使 $M$ 为有限值，指数项必须为非正数，即 $\\frac{1}{2\\sigma^2} - \\frac{1}{2} \\le 0$，简化后为 $\\sigma^2 \\ge 1$。\n如果 $\\sigma^2 > 1$，指数为负，表达式的上确界在 $x=0$ 处取得，得到 $M(\\sigma^2) = \\sqrt{2\\pi\\sigma^2}$。\n如果 $\\sigma^2 = 1$，指数为零，表达式为常数，$M(1) = \\sqrt{2\\pi}$。\n我们想要找到使 $M$ 最小化的 $\\sigma$ 的选择。对于 $\\sigma^2 \\ge 1$，函数 $M(\\sigma^2) = \\sqrt{2\\pi\\sigma^2}$ 是关于 $\\sigma^2$ 的增函数。因此，其最小值在可能的最低值 $\\sigma^2=1$ 处取得。\n最优选择是 $\\sigma=1$，这得到最小控制常数 $M = \\sqrt{2\\pi}$。\n拒绝抽样的接受概率由公式 $P_{\\text{acc, RS}} = \\frac{\\int_{-\\infty}^{\\infty} p^*(x) dx}{M}$ 给出。\n未归一化目标的积分是一个标准的高斯积分：\n$$ \\int_{-\\infty}^{\\infty} p^*(x) dx = \\int_{-\\infty}^{\\infty} \\exp(-x^2/2) dx = \\sqrt{2\\pi} $$\n因此，最优接受概率为：\n$$ P_{\\text{acc, RS}} = \\frac{\\sqrt{2\\pi}}{M} = \\frac{\\sqrt{2\\pi}}{\\sqrt{2\\pi}} = 1 $$\n这个结果是意料之中的，因为选择 $\\sigma=1$ 意味着提议分布与归一化目标分布完全相同，从而将拒绝抽样变成了直接抽样。\n\n收集五个所求量作为最终答案。\n1. $A$的解析描述：$0  u \\le 1 \\land v^2 \\le -4u^2\\ln(u)$\n2. $\\max u$：$1$\n3. $\\max|v|$：$\\sqrt{2\\exp(-1)}$\n4. 接受概率（均匀比值法）：$\\frac{\\sqrt{\\pi \\exp(1)}}{4}$\n5. 接受概率（拒绝抽样）：$1$", "answer": "$$ \\boxed{ \\pmatrix{ 0  u \\le 1 \\land v^2 \\le -4u^2\\ln(u)  1  \\sqrt{2\\exp(-1)}  \\frac{\\sqrt{\\pi \\exp(1)}}{4}  1 } } $$", "id": "3356654"}, {"introduction": "在许多实际问题中，前一个练习中的解析计算是不可行的。本练习旨在解决一个关键任务：当我们只能通过“神谕”（oracle）访问对数密度及其梯度时，如何以数值方式计算边界矩形的常数——这在计算统计学中是一种常见情景。你将学习如何构建一个稳健的数值方案，从算法层面将该方法付诸实践。[@problem_id:3356655]", "problem": "考虑实线上的一个一维、严格为正、可积的目标密度，该密度仅通过一个返回其未归一化对数密度及其梯度的预言机（oracle）来描述。形式上，令 $g(x) \\propto f(x)$ 表示该密度的一个未归一化版本，并记 $\\ell(x) = \\log g(x)$。给定对 $\\ell(x)$ 和 $\\ell'(x)$ 的预言机访问权限，以及一个常数 $L \\in (0,\\infty)$，使得 $\\ell'(x)$ 是 $L$-利普希茨（$L$-Lipschitz）的，即对于所有 $x,y \\in \\mathbb{R}$，有 $\\lvert \\ell'(x) - \\ell'(y) \\rvert \\le L \\lvert x-y \\rvert$。在整个问题中，假设 $\\ell$ 是凹的（对数凹目标），在 $\\mathbb{R}$ 上二阶连续可微，并且 $g$ 在 $\\mathbb{R}$ 上可积，因此对数密度有唯一的最大值点。\n\n一维模拟的比率均匀法（ratio-of-uniforms）构造要求用一个简单的矩形来界定可接受点对的集合。这个矩形可以使用以下量来选择：\n- $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$，\n- $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$。\n\n您的任务是推导、证明并实现一个稳健的数值方案，该方案仅使用 $\\ell$ 和 $\\ell'$ 以及利普希茨常数 $L$ 来高精度地计算 $S_0$ 和 $S_1$。您的推导必须从 $\\ell$ 的凹性和 $\\ell'$ 的利普希茨连续性出发，必须证明最大值点的存在性和唯一性，并为该数值方案提供非渐近误差保证。\n\n具体来说，请完成以下任务：\n1. 推导一个有原则的全局区间套（bracketing）和二分法（bisection）方案来定位：\n   - $\\ell(x)$ 的唯一最大值点 $x_\\star$，以及\n   - 函数 $r(x) = \\ell(x) + 2 \\log \\lvert x \\rvert$ 在区间 $(0,\\infty)$ 和 $(-\\infty,0)$ 上位于原点两侧的唯一最大值点。\n   您的推导必须证明在给定假设下，$x_\\star$ 是良定义且唯一的，并且 $r$ 在 $(0,\\infty)$ 和 $(-\\infty,0)$ 上的最大值点是良定义且唯一的。\n2. 从区间套和二分法方案中，推导目标值的显式误差界：\n   - 证明如果 $x_\\star$ 的区间宽度为 $\\delta_x$，那么在二分点处目标 $\\ell$ 的误差受一个取决于 $L$ 和 $\\delta_x$ 的量所界定。\n   - 证明如果 $r$ 的最大值点的区间不跨越原点，宽度为 $\\delta_x$，且与原点的最小绝对距离为 $a = \\min_{x \\text{ in bracket}} \\lvert x \\rvert$，那么在二分点处目标 $r$ 的误差受一个取决于 $L$、$a$ 和 $\\delta_x$ 的量所界定。\n   使用这些界，为 $S_0 = \\exp(\\tfrac{1}{2}\\sup_x \\ell(x))$ 和 $S_1 = \\exp(\\tfrac{1}{2}\\sup_x r(x))$ 的乘性误差提供保证。\n3. 在一个单一程序中实现您的方案，该程序仅使用预言机 $\\ell$ 和 $\\ell'$ 以及 $L$ 来计算 $S_0$ 和 $S_1$ 的数值近似值。\n\n测试套件。您的程序必须为以下三个由预言机定义的对数凹目标计算 $S_0$ 和 $S_1$（每种情况都指定了 $\\ell$、$\\ell'$ 和 $L$）：\n\n- 情况 A（标准正态分布，未归一化）：\n  - $\\ell(x) = -\\tfrac{1}{2} x^2$，\n  - $\\ell'(x) = -x$，\n  - $L = 1$。\n- 情况 B（逻辑斯谛分布，已归一化）：\n  - $\\ell(x) = -x - 2 \\log\\!\\bigl(1 + e^{-x}\\bigr)$，\n  - $\\ell'(x) = -1 + \\dfrac{2}{1 + e^{x}}$，\n  - $L = \\tfrac{1}{2}$。\n- 情况 C（均值为 $\\mu = 1.5$、标准差为 $\\sigma = 0.5$ 的正态分布，未归一化）：\n  - $\\ell(x) = -\\dfrac{(x - \\mu)^2}{2 \\sigma^2} = -\\dfrac{(x - 1.5)^2}{0.5}$，\n  - $\\ell'(x) = -\\dfrac{x - \\mu}{\\sigma^2} = -\\dfrac{x - 1.5}{0.25} = -4(x-1.5)$，\n  - $L = \\dfrac{1}{\\sigma^2} = 4$。\n\n数值要求与保证：\n- 您的方案必须对一阶导数采用全局有效的区间套和二分法来定位唯一的临界点，利用凹性保证唯一性，并利用利普希茨连续性获得目标误差界。\n- 在求根时，使用 $x$ 的二分法容差为 $\\delta_x = 10^{-12}$。使用您推导的基于曲率的目标误差界来验证所计算点上 $\\ell$ 和 $r$ 的目标误差，并将这些误差传播到 $S_0$ 和 $S_1$ 的乘性误差界。您不需要打印误差界，但您的代码必须遵守确保这些目标误差保证的停止规则。\n\n最终输出格式：\n- 对于情况 A、B、C 中的每一种，使用您的方案计算点对 $(S_0, S_1)$。\n- 您的程序应生成单行输出，包含六个浮点数结果，顺序如下：$[S_{0,\\mathrm{A}}, S_{1,\\mathrm{A}}, S_{0,\\mathrm{B}}, S_{1,\\mathrm{B}}, S_{0,\\mathrm{C}}, S_{1,\\mathrm{C}}]$。该行必须是方括号内由逗号分隔的列表，不得包含任何额外文本。没有物理单位。不涉及角度。请勿使用百分号；所有数字都必须打印为十进制浮点值。", "solution": "本问题要求我们设计并实现一个数值方案，用于计算一维比率均匀法（ratio-of-uniforms）采样方法所需的边界常数 $S_0$ 和 $S_1$。这些常数定义为 $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$ 和 $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$，其中 $g(x)$ 是一个未归一化、严格为正、可积的目标密度。我们被提供了对对数密度 $\\ell(x) = \\log g(x)$ 及其导数 $\\ell'(x)$ 的预言机访问权限。关键假设是 $\\ell(x)$ 是凹函数且二阶连续可微，其导数 $\\ell'(x)$ 对于一个已知的常数 $L > 0$ 是 $L$-利普希茨连续的。\n\n我们的推导和实现将分三个阶段进行：首先，我们分析用于计算 $S_0$ 和 $S_1$ 的优化问题的结构，并证明相关最大值点的存在性和唯一性。其次，我们基于这些性质开发一个稳健的数值算法。第三，我们为该算法推导非渐近误差界。\n\n**1. 最大化问题分析**\n\n计算 $S_0$ 和 $S_1$ 等价于找到从 $\\ell(x)$ 派生的某些函数的上确界。\n\n**1.1. $S_0$ 的最大值点**\n常数 $S_0$ 定义为 $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$。这等价于找到 $g(x)$ 的最大值，或者更方便地，找到 $\\ell(x) = \\log g(x)$ 的最大值，因为对数函数是严格递增的。令 $x_\\star$ 为 $\\ell(x)$ 的最大值点。那么 $S_0 = \\sqrt{g(x_\\star)} = \\exp(\\frac{1}{2}\\ell(x_\\star))$。\n\n为了找到 $x_\\star$，我们通过求解 $\\ell'(x_\\star)=0$ 来寻找一个临界点。\n*   **存在性与唯一性**：函数 $\\ell(x)$ 是凹的，这意味着其二阶导数满足 $\\ell''(x) \\le 0$。$g(x) = \\exp(\\ell(x))$ 在 $\\mathbb{R}$ 上可积的附加假设意味着当 $\\lvert x \\rvert \\to \\infty$ 时，$\\ell(x) \\to -\\infty$。一个在 $\\mathbb{R}$ 上连续且在其极值处趋于 $-\\infty$ 的函数必定达到全局最大值。由于 $\\ell(x)$ 是可微的，这个最大值必须出现在一个临界点处，该点满足 $\\ell'(x)=0$。\n    为了证明唯一性，考虑导数 $\\ell'(x)$。其导数为 $\\ell''(x) \\le 0$。由于 $g(x)$ 必须是一个（在归一化意义上）正常的密度函数，而不是在无限区间上的常数函数，所以 $\\ell''(x)$ 不可能处处为零。因此，$\\ell'(x)$ 是一个严格递减函数。一个严格递减的连续函数最多只能穿过零轴一次。因此，$\\ell'(x_\\star)=0$ 的解 $x_\\star$ 是唯一的。\n\n**1.2. $S_1$ 的最大值点**\n常数 $S_1$ 定义为 $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$。这等价于最大化函数 $h(x) = (\\lvert x \\rvert \\sqrt{g(x)})^2 = x^2 g(x)$。最大化 $h(x)$ 等价于最大化其对数 $r(x) = \\log(x^2 g(x)) = \\log(x^2) + \\log(g(x)) = 2\\log\\lvert x \\rvert + \\ell(x)$。函数 $r(x)$ 定义在 $\\mathbb{R} \\setminus \\{0\\}$ 上。我们分别在区间 $(-\\infty, 0)$ 和 $(0, \\infty)$ 上对其进行分析。\n\n$r(x)$ 的临界点通过求解 $r'(x)=0$ 得到。其导数为 $r'(x) = \\frac{2}{x} + \\ell'(x)$。\n*   **最大值点的存在性与唯一性**：我们来分析函数 $q(x) = r'(x) = \\ell'(x) + \\frac{2}{x}$。我们需要找到它的根。$q(x)$ 的导数是 $q'(x) = \\ell''(x) - \\frac{2}{x^2}$。由于 $\\ell''(x) \\le 0$，立即可以得出对于所有 $x \\neq 0$ 都有 $q'(x)  0$。因此，$q(x)$ 在 $(-\\infty, 0)$ 和 $(0, \\infty)$ 上都是严格递减的。这保证了 $q(x)$ 在这两个区间中各自最多只有一个根。\n\n    我们来验证这些根的存在性。\n    *   在 $(0, \\infty)$ 上：当 $x \\to 0^+$ 时，$\\frac{2}{x} \\to \\infty$。由于 $\\ell'(x)$ 是连续的，$\\ell'(x)$ 在 $x=0$ 附近有界，所以 $q(x) \\to \\infty$。当 $x \\to \\infty$ 时，我们有 $\\frac{2}{x} \\to 0$。由于 $\\exp(\\ell(x))$ 是可积的，为了使其积分（方差）有限，$x^2 \\exp(\\ell(x))$ 在 $x \\to \\infty$ 时必须趋于 $0$，这对于密度函数来说是一个合理的物理假设。这意味着 $r(x) = \\ell(x) + 2\\log x \\to -\\infty$。一个在 $(0, \\infty)$ 上连续，当 $x \\to \\infty$ 时趋于 $-\\infty$，且当 $x \\to 0^{+}$ 时 $r(x) \\to -\\infty$ 的函数，必定会达到一个最大值。在这个最大值点 $x_+$ 处，必须有 $r'(x_+)=0$。因此，在 $(0, \\infty)$ 中存在 $q(x)$ 的一个唯一根。\n    *   在 $(-\\infty, 0)$ 上：对称的论证同样成立。当 $x \\to 0^-$ 时，$\\frac{2}{x} \\to -\\infty$，所以 $q(x) \\to -\\infty$。当 $x \\to -\\infty$ 时，$r(x) = \\ell(x) + 2\\log(-x) \\to -\\infty$。通过类似的推理，必须存在一个唯一最大值点 $x_-$，在该点处 $r'(x_-)=0$。\n\n于是 $\\sup_x r(x)$ 的值为 $\\max(r(x_+), r(x_-))$，并且 $S_1 = \\exp(\\frac{1}{2} \\max(r(x_+), r(x_-)))$。\n\n**2. 数值方案：区间套与二分法**\n\n$\\ell'(x)=0$ 和 $r'(x)=0$ 在各自定义域上的根的唯一性，使其成为通过区间套方法（如二分法）进行求根的理想对象。\n\n*   **区间套（Bracketing）**：对于一个有唯一根的函数 $f(x)$，我们需要找到一个区间 $[a, b]$，使得 $f(a)$ 和 $f(b)$ 符号相反。\n    *   对于 $\\ell'(x)$：我们检查 $\\ell'(0)$。如果 $\\ell'(0) > 0$，根 $x_\\star$ 为正。我们设 $a=0$ 并找到一个 $b>0$ 使得 $\\ell'(b)0$。如果 $\\ell'(0)  0$，$x_\\star$ 为负。我们设 $b=0$ 并找到一个 $a0$ 使得 $\\ell'(a)>0$。扩展搜索（例如，尝试点 $1, 2, 4, ...$ 或 $-1, -2, -4, ...$）保证能找到这样的点，因为当 $\\lvert x \\rvert \\to \\infty$ 时 $\\ell(x) \\to -\\infty$。\n    *   对于 $(0, \\infty)$ 上的 $r'(x)$：我们知道当 $x \\to 0^+$ 时 $r'(x) \\to \\infty$，并且 $r'(x)$ 最终会变为负值。我们可以从一个小的正数 $a > 0$（例如 $10^{-8}$）开始，以确保 $r'(a) > 0$，然后用扩展搜索找到一个 $b$ 使得 $r'(b)  0$。\n    *   对于 $(-\\infty, 0)$ 上的 $r'(x)$：我们知道当 $x \\to 0^-$ 时 $r'(x) \\to -\\infty$，并且 $r'(x)$ 最终会变为正值。我们从一个小的负数 $b  0$（例如 $-10^{-8}$）开始，以确保 $r'(b)  0$，然后用扩展搜索找到一个 $a$ 使得 $r'(a) > 0$。\n\n*   **二分法（Bisection）**：一旦为函数 $f$ 的根确定了区间 $[a,b]$，二分法算法会迭代地将区间减半，同时保持根被套在区间内。经过 $k$ 次迭代后，区间的宽度为 $(b-a)/2^k$。我们持续这个过程，直到区间宽度小于预设的容差 $\\delta_x$。最终区间的中点被作为根的估计值。\n\n**3. 误差分析**\n\n现在我们根据二分法求根器的容差 $\\delta_x$ 来推导函数值的界。\n\n*   **$\\ell(x)$ 中的误差**：令 $x_\\star$ 为真实的最大值点，$\\hat{x}$ 为我们通过对 $\\ell'(x)=0$ 使用二分法得到的数值估计值。宽度为 $\\delta_x$ 的最终区间包含 $x_\\star$。如果我们取 $\\hat{x}$ 为中点，则 $\\lvert \\hat{x} - x_\\star \\rvert \\le \\frac{\\delta_x}{2}$。根据泰勒定理，对于某个介于 $\\hat{x}$ 和 $x_\\star$ 之间的 $\\xi$：\n    $\\ell(\\hat{x}) = \\ell(x_\\star) + \\ell'(x_\\star)(\\hat{x} - x_\\star) + \\frac{1}{2}\\ell''(\\xi)(\\hat{x} - x_\\star)^2$。\n    由于 $\\ell'(x_\\star)=0$，目标函数中的误差为 $\\ell(x_\\star) - \\ell(\\hat{x}) = -\\frac{1}{2}\\ell''(\\xi)(\\hat{x} - x_\\star)^2$。\n    问题陈述 $\\ell'(x)$ 是 $L$-利普希茨的，且 $\\ell(x)$ 是凹的。这意味着对所有 $x$ 都有 $-L \\le \\ell''(x) \\le 0$。因此，$0 \\le -\\ell''(\\xi) \\le L$。误差被界定为：\n    $$0 \\le \\ell(x_\\star) - \\ell(\\hat{x}) \\le \\frac{L}{2}(\\hat{x} - x_\\star)^2 \\le \\frac{L}{2} \\left(\\frac{\\delta_x}{2}\\right)^2 = \\frac{L \\delta_x^2}{8}$$\n    对于估计值 $\\hat{S}_0 = \\exp(\\frac{1}{2}\\ell(\\hat{x}))$ 的乘性误差为 $\\frac{S_0}{\\hat{S}_0} = \\exp(\\frac{1}{2}(\\ell(x_\\star) - \\ell(\\hat{x})))$，其界为：\n    $$1 \\le \\frac{S_0}{\\hat{S}_0} \\le \\exp\\left(\\frac{L \\delta_x^2}{16}\\right)$$\n\n*   **$r(x)$ 中的误差**：令 $x_r$ 为 $r(x)$ 的一个真实最大值点（即 $x_+$ 或 $x_-$），$\\hat{x}_r$ 为其数值估计值。误差为 $r(x_r) - r(\\hat{x}_r) = -\\frac{1}{2}r''(\\xi)(\\hat{x}_r - x_r)^2$。\n    二阶导数为 $r''(x) = \\ell''(x) - \\frac{2}{x^2}$。由于 $-L \\le \\ell''(x) \\le 0$，我们有 $-L - \\frac{2}{x^2} \\le r''(x) \\le -\\frac{2}{x^2}  0$。\n    其大小为 $\\lvert r''(x) \\rvert = -\\ell''(x) + \\frac{2}{x^2} \\le L + \\frac{2}{x^2}$。\n    令 $x_r$ 的最终二分区间为 $[u, v]$，该区间不包含 $0$。令 $a = \\min_{x \\in [u,v]} \\lvert x \\rvert > 0$。对于此区间中的任何 $\\xi$，我们有 $\\lvert r''(\\xi) \\rvert \\le L + \\frac{2}{a^2}$。因此误差被界定为：\n    $$0 \\le r(x_r) - r(\\hat{x}_r) \\le \\frac{1}{2}\\left(L + \\frac{2}{a^2}\\right)(\\hat{x}_r - x_r)^2 \\le \\frac{(L + 2/a^2)\\delta_x^2}{8}$$\n    对于 $\\hat{S}_1 = \\exp(\\frac{1}{2}\\sup r(\\hat{x}_r))$ 的乘性误差由一个类似的表达式界定，该表达式使用正负分支误差界的最大值。对于 $\\delta_x = 10^{-12}$ 的容差，这些误差在实际应用中可以忽略不计，从而证实了该方案的高精度。\n\n至此，完成了该数值方法的推导和证明。下面的实现将这个有原则的方法编纂成代码。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute S0 and S1 for the given test cases.\n    \"\"\"\n\n    def find_bracket(f, domain):\n        \"\"\"\n        Finds a bracketing interval [a, b] for a root of f.\n        \n        Args:\n            f: The function for which to find a root.\n            domain: A string, either 'R' (for ell'), 'pos' (for r' on (0, inf)),\n                    or 'neg' (for r' on (-inf, 0)).\n        \n        Returns:\n            A tuple (a, b) such that f(a) * f(b) = 0.\n        \"\"\"\n        if domain == 'R':\n            # For ell_prime'(x)\n            f0 = f(0.0)\n            if np.isclose(f0, 0.0):\n                return 0.0, 0.0\n            if f0 > 0:\n                # Root is positive\n                a, b = 0.0, 1.0\n                while f(b) > 0:\n                    b *= 2.0\n                return a, b\n            else:\n                # Root is negative\n                a, b = -1.0, 0.0\n                while f(a)  0:\n                    a *= 2.0\n                return a, b\n        elif domain == 'pos':\n            # For r_prime(x) on (0, inf), f(x) -> +inf as x -> 0+\n            a, b = 1e-8, 1.0\n            if f(a)  0: # a is already on the other side of the root\n                return 0, a\n            while f(b) > 0:\n                b *= 2.0\n            return a, b\n        elif domain == 'neg':\n            # For r_prime(x) on (-inf, 0), f(x) -> -inf as x -> 0-\n            a, b = -1.0, -1e-8\n            if f(b) > 0: # b is already on the other side of the root\n                return b, 0\n            while f(a)  0:\n                a *= 2.0\n            return a, b\n\n    def bisection(f, a, b, tol=1e-12):\n        \"\"\"\n        Simple bisection algorithm to find a root of f in [a, b].\n        \"\"\"\n        if a > b:\n            a, b = b, a\n        fa, fb = f(a), f(b)\n        if fa * fb > 0:\n            raise ValueError(\"Root not bracketed or multiple roots exist.\")\n        if np.isclose(fa, 0.0):\n            return a\n        if np.isclose(fb, 0.0):\n            return b\n\n        while (b - a) > tol:\n            c = a + (b - a) / 2.0\n            fc = f(c)\n            if np.isclose(fc, 0.0):\n                return c\n            if fa * fc  0:\n                b = c\n            else:\n                a = c\n                fa = fc\n        return a + (b - a) / 2.0\n\n    def compute_bounds(ell, ell_prime, L):\n        \"\"\"\n        Computes S0 and S1 for a given log-density oracle.\n        \"\"\"\n        tol = 1e-12\n\n        # --- Compute S0 ---\n        # Find maximizer of ell(x) by finding root of ell_prime(x)\n        f0 = ell_prime\n        bracket_x_star = find_bracket(f0, 'R')\n        x_star = bisection(f0, bracket_x_star[0], bracket_x_star[1], tol)\n        ell_max = ell(x_star)\n        s0 = np.exp(0.5 * ell_max)\n\n        # --- Compute S1 ---\n        # Find maximizers of r(x) = ell(x) + 2*log|x|\n        # This is done by finding roots of r'(x) = ell_prime(x) + 2.0 / x\n        f1 = lambda x: ell_prime(x) + 2.0 / x\n\n        # Positive maximizer x_+\n        bracket_x_plus = find_bracket(f1, 'pos')\n        x_plus = bisection(f1, bracket_x_plus[0], bracket_x_plus[1], tol)\n        r_plus = ell(x_plus) + 2.0 * np.log(x_plus)\n        \n        # Negative maximizer x_-\n        bracket_x_minus = find_bracket(f1, 'neg')\n        x_minus = bisection(f1, bracket_x_minus[0], bracket_x_minus[1], tol)\n        r_minus = ell(x_minus) + 2.0 * np.log(np.abs(x_minus))\n\n        r_max = max(r_plus, r_minus)\n        s1 = np.exp(0.5 * r_max)\n\n        return s0, s1\n\n    # Test cases\n    # Case A: Standard Normal\n    ell_A = lambda x: -0.5 * x**2\n    ell_prime_A = lambda x: -x\n    L_A = 1.0\n\n    # Case B: Logistic\n    ell_B = lambda x: -x - 2.0 * np.log(1.0 + np.exp(-x))\n    ell_prime_B = lambda x: -1.0 + 2.0 / (1.0 + np.exp(x))\n    L_B = 0.5\n    \n    # Case C: Normal(mu=1.5, sigma=0.5)\n    mu_C, sigma_C = 1.5, 0.5\n    ell_C = lambda x: -((x - mu_C)**2) / (2.0 * sigma_C**2)\n    ell_prime_C = lambda x: -(x - mu_C) / (sigma_C**2)\n    L_C = 1.0 / (sigma_C**2)\n    \n    test_cases = [\n        (ell_A, ell_prime_A, L_A),\n        (ell_B, ell_prime_B, L_B),\n        (ell_C, ell_prime_C, L_C),\n    ]\n\n    results = []\n    for ell, ell_prime, L in test_cases:\n        s0, s1 = compute_bounds(ell, ell_prime, L)\n        results.extend([s0, s1])\n    \n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3356655"}]}