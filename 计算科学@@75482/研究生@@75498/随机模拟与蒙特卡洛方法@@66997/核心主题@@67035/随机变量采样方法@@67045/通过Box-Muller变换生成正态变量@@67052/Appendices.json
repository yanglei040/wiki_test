{"hands_on_practices": [{"introduction": "Box-Muller变换每次会同时生成两个独立的标准正态分布随机数。但在实际应用中，我们常常需要一个每次只返回一个随机数的生成器。这个练习将探讨一种常见的实现策略——缓存第二个随机数以供下次调用，并分析其对生成器吞吐量和性能的影响。通过这个练习，你将学会如何权衡计算成本（如超越函数的计算）与系统开销（如分支预测和内存访问），从而在理论算法和实际硬件性能之间做出明智的工程决策。[@problem_id:3323992]", "problem": "在 Box–Muller 变换中，独立同分布的 Uniform$(0,1)$ 随机变量 $U_1$ 和 $U_2$ 通过极坐标变换被映射为独立同分布的标准正态随机变量 $Z_1$ 和 $Z_2$。考虑一个标量随机数生成器函数 $\\texttt{next\\_normal}()$，该函数每次调用必须正好返回 $1$ 个标准正态样本。比较了两种实现策略：\n- 策略 $\\mathcal{N}$（非缓存）：每次调用时，抽取新的 $U_1, U_2 \\sim \\text{Uniform}(0,1)$，计算一个 Box–Muller 对 $(Z_1,Z_2)$，返回 $Z_1$ 并丢弃 $Z_2$。\n- 策略 $\\mathcal{C}$（缓存）：维护一个由一个标志位和一个已存储的正态变量组成的内部状态。如果标志位指示有一个已存储的 $Z_2$ 可用，则返回它并清除标志位；否则，抽取新的 $U_1, U_2$，计算 $(Z_1,Z_2)$，立即返回 $Z_1$ 并为下一次调用存储 $Z_2$，同时设置标志位。\n\n为进行分析，假设以下经过充分检验的事实和成本模型：\n- Box–Muller 变换使用独立同分布的 $U_1, U_2 \\sim \\text{Uniform}(0,1)$，并通过 $R=\\sqrt{-2\\ln U_1}$ 和 $\\Theta=2\\pi U_2$ 将它们映射为 $Z_1=R\\cos\\Theta$ 和 $Z_2=R\\sin\\Theta$，从而产生独立同分布的 $\\mathcal{N}(0,1)$ 输出 $Z_1$ 和 $Z_2$。\n- 从 $(U_1,U_2)$ 计算 $(Z_1,Z_2)$ 的总成本主要取决于对每对变量计算一次 $\\ln(\\cdot)$、$\\sqrt{\\cdot}$、$\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 的成本（记为 $c_t>0$），外加生成 $2$ 个均匀分布随机数的成本（记为 $c_u>0$，对应底层均匀分布生成器的 $2$ 次调用）。\n- 在策略 $\\mathcal{C}$ 中，每次调用都包含一个对缓存标志位的条件分支，该分支可能以概率 $p \\in [0,1]$ 发生预测错误，从而产生 $c_b \\ge 0$ 的开销。在稳态标量使用情况下，调用在“填充缓存并返回 $Z_1$”和“返回缓存的 $Z_2$”之间交替进行，假设预测错误以某个固定的概率 $p$ 发生，该概率由调用者的访问模式和处理器的预测器决定。\n- 读/写缓存的 $Z_2$ 和标志位会触及通常驻留在一级数据缓存中的状态；在策略 $\\mathcal{C}$ 下，将此抽象为每个输出的平均额外内存成本 $c_m \\ge 0$，在典型的中央处理器（CPU）微架构上，$c_m \\ll c_t$。\n\n同时考虑两种使用模式：\n- 模式 $\\mathsf{S}$（标量流式）：应用程序重复调用 $\\texttt{next\\_normal}()$ 以获得一长串独立同分布的标准正态随机数，并逐个使用生成的随机数。\n- 模式 $\\mathsf{V}$（向量化批量）：应用程序通过在紧凑循环内重复调用 $\\texttt{next\\_normal}()$ 来请求一个长度为 $n$（其中 $n \\gg 1$）的数组。该代码在其他方面适合单指令多数据（SIMD）向量化。你可以假设 $n$ 是任意的（不一定是偶数）。\n\n选择下面所有正确的陈述，并根据变换的基本原理和成本模型证明你的选择。\n\nA. 在模式 $\\mathsf{S}$ 下，如果 $U_1$ 和 $U_2$ 是独立同分布的，并且底层生成器的状态在各次调用之间是独立的，那么策略 $\\mathcal{C}$ 产生的输出序列是独立同分布的 $\\mathcal{N}(0,1)$；缓存 $Z_2$ 不会引入序列相关性，无论缓存值何时被使用。\n\nB. 在模式 $\\mathsf{S}$ 下，相对于策略 $\\mathcal{N}$，策略 $\\mathcal{C}$ 将每个正态输出消耗的均匀分布随机变量数量和每个正态输出进行的高开销超越函数求值次数都减少了大约一半，从而使得每个样本的期望成本接近 $\\tfrac{1}{2}(c_t+c_u)$，此外还有附加的分支和内存成本 $pc_b + c_m$。\n\nC. 由于在策略 $\\mathcal{C}$ 中对缓存标志位的分支是不可避免的，因此在具有分支预测功能的现代超标量CPU上，缓存必然会降低吞吐量，使得对于任何实际参数，$\\mathcal{C}$ 都比 $\\mathcal{N}$ 慢。\n\nD. 在模式 $\\mathsf{V}$ 下且 $n \\gg 1$ 时，缓存会因阻碍完全的SIMD向量化和引入额外的控制流而降低吞吐量；一种更高吞吐量的设计是在批量循环内部成对生成输出而不进行缓存，并单独处理长度为 $1$ 的奇数尾部。\n\nE. 如果多个线程共享一个带有单个缓存槽的 $\\texttt{next\\_normal}()$ 实例，策略 $\\mathcal{C}$ 可能会在持有标志位和缓存值的共享缓存行上产生争用和伪共享，除非状态是线程本地的或受同步机制保护，否则会损害吞吐量。\n\nF. 即使 $U_1$ 和 $U_2$ 是独立同分布的，缓存 $Z_2$ 也会使偶数次调用的输出分布偏向于更大的量级，因为一对输出共享相同的半径 $R=\\sqrt{-2\\ln U_1}$，所以第二个输出的 $|Z|$ 在随机意义上倾向于比第一个大。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n\n-   **变换**：Box–Muller 变换将独立同分布（i.i.d.）的随机变量 $U_1, U_2 \\sim \\text{Uniform}(0,1)$ 映射为独立同分布的标准正态随机变量 $Z_1, Z_2 \\sim \\mathcal{N}(0,1)$。\n-   **函数**：一个标量生成器 `next_normal()` 每次调用需返回恰好 $1$ 个标准正态样本。\n-   **策略 $\\mathcal{N}$（非缓存）**：每次调用时，抽取新的 $U_1, U_2$；计算对 $(Z_1, Z_2)$；返回 $Z_1$ 并丢弃 $Z_2$。\n-   **策略 $\\mathcal{C}$（缓存）**：利用内部状态（一个标志位和一个已存储的正态变量）。如果一个值被缓存，则返回它。否则，从新的 $U_1, U_2$ 生成一对新的 $(Z_1, Z_2)$；返回 $Z_1$ 并为下一次调用缓存 $Z_2$。\n-   **公式**：$R=\\sqrt{-2\\ln U_1}$，$\\Theta=2\\pi U_2$，产生 $Z_1=R\\cos\\Theta$ 和 $Z_2=R\\sin\\Theta$。\n-   **成本模型**：\n    -   生成一对 $(Z_1, Z_2)$ 的成本是 $c_t + c_u$，其中 $c_t>0$ 是分别计算一次 $\\ln(\\cdot), \\sqrt{\\cdot}, \\sin(\\cdot), \\cos(\\cdot)$ 的成本，而 $c_u>0$ 是生成两个均匀分布随机变量的成本。\n    -   对于策略 $\\mathcal{C}$，每次调用都有来自条件分支的额外成本，其预测错误概率为 $p \\in [0,1]$，开销为 $c_b \\ge 0$。\n    -   对于策略 $\\mathcal{C}$，每个输出有额外的平均内存访问成本 $c_m \\ge 0$，其中 $c_m \\ll c_t$。\n    -   在稳态标量使用中，对 $\\mathcal{C}$ 的调用在生成新对和返回缓存值之间交替进行。\n-   **使用模式**：\n    -   **模式 $\\mathsf{S}$（标量流式）**：对 `next_normal()` 的一长串串行调用。\n    -   **模式 $\\mathsf{V}$（向量化批量）**：在紧凑循环中调用 `next_normal()` 来填充一个长度为 $n \\gg 1$ 的数组。周围的代码适合 SIMD 向量化。$n$ 可以是奇数或偶数。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据充分**：问题陈述准确描述了 Box-Muller 变换，这是一种用于生成正态变量的标准且被充分理解的方法。该变换产生独立同分布的 $\\mathcal{N}(0,1)$ 变量这一陈述是该方法的基础。成本模型是在性能分析中常用的一种合理抽象，它考虑了超越函数的成本、分支预测开销和内存层次结构的影响。\n-   **提法明确**：问题提法明确。它定义了两种不同且清晰的算法（$\\mathcal{N}$ 和 $\\mathcal{C}$）、一个带有明确参数的成本模型，以及特定的使用情境（$\\mathsf{S}$ 和 $\\mathsf{V}$）。任务是基于这个框架评估一组陈述，这是一个标准的分析问题。\n-   **客观**：语言是正式的、技术性的，没有主观或含糊的术语。\n-   **完整且一致**：问题提供了进行所需分析的所有必要定义和假设。没有内部矛盾。例如，算法的描述、成本组成部分和使用模式都是自洽的。\n\n### 步骤 3：结论与行动\n\n问题陈述是有效的。它科学上合理、提法明确、客观，并为分析提供了一个完整、一致的基础。现在将开始分析所提供的选项。\n\n### 对所提供选项的分析\n\n**A. 在模式 $\\mathsf{S}$ 下，如果 $U_1$ 和 $U_2$ 是独立同分布的，并且底层生成器的状态在各次调用之间是独立的，那么策略 $\\mathcal{C}$ 产生的输出序列是独立同分布的 $\\mathcal{N}(0,1)$；缓存 $Z_2$ 不会引入序列相关性，无论缓存值何时被使用。**\n\n令生成的均匀分布随机变量对的序列为 $(U_{1}^{(k)}, U_{2}^{(k)})$，其中 $k=1, 2, 3, \\ldots$。根据假设，这些对是独立同分布的。\n对应的正态随机变量对是 $(Z_{1}^{(k)}, Z_{2}^{(k)})$，其中 $Z_{1}^{(k)}$ 和 $Z_{2}^{(k)}$ 是 $(U_{1}^{(k)}, U_{2}^{(k)})$ 的函数。\nBox-Muller 变换的一个基本结果是，对于给定的 $k$，$Z_{1}^{(k)}$ 和 $Z_{2}^{(k)}$ 是独立同分布的 $\\mathcal{N}(0,1)$ 变量。\n由于均匀分布随机变量对在不同的 $k$ 之间是独立的，因此正态随机变量对 $(Z_{1}^{(k)}, Z_{2}^{(k)})$ 与 $(Z_{1}^{(j)}, Z_{2}^{(j)})$ 在 $k \\neq j$ 时是独立的。\n这意味着整个随机变量集合 $\\{Z_{1}^{(1)}, Z_{2}^{(1)}, Z_{1}^{(2)}, Z_{2}^{(2)}, \\ldots\\}$ 是一组相互独立、同分布的 $\\mathcal{N}(0,1)$ 变量。\n策略 $\\mathcal{C}$ 产生的输出序列是 $Z_{1}^{(1)}, Z_{2}^{(1)}, Z_{1}^{(2)}, Z_{2}^{(2)}, \\ldots$。由于这只是一组独立同分布随机变量的特定排序，因此得到的序列也是独立同分布的。\n独立同分布的性质对于排列是不变的。因此，该序列是独立同分布的 $\\mathcal{N}(0,1)$。关于缓存不会引入序列相关性的说法是正确的。\n\n结论：**正确**。\n\n**B. 在模式 $\\mathsf{S}$ 下，相对于策略 $\\mathcal{N}$，策略 $\\mathcal{C}$ 将每个正态输出消耗的均匀分布随机变量数量和每个正态输出进行的高开销超越函数求值次数都减少了大约一半，从而使得每个样本的期望成本接近 $\\tfrac{1}{2}(c_t+c_u)$，此外还有附加的分支和内存成本 $pc_b + c_m$。**\n\n让我们分析每种策略下生成单个正态样本的成本。\n-   **策略 $\\mathcal{N}$**：为了生成一个正态样本，我们必须执行一次完整的 Box-Muller 变换。这需要 $2$ 个均匀分布随机变量和一组 $\\ln, \\sqrt, \\sin, \\cos$ 的计算。每个样本的成本是 $C_{\\mathcal{N}} = c_t + c_u$。\n-   **策略 $\\mathcal{C}$**：在稳态下，策略 $\\mathcal{C}$ 服务两次调用以生成两个正态样本。\n    -   第一次调用（例如，奇数次调用）生成一对新的 $(Z_1, Z_2)$。它产生的成本是 $c_t + c_u$。它返回 $Z_1$。\n    -   第二次调用（例如，偶数次调用）返回缓存的 $Z_2$。它只产生开销成本。\n    -   因此，为了生成 $2$ 个正态样本，我们使用 $2$ 个均匀分布随机变量并执行一组高开销的函数求值。\n    -   每个正态样本平均消耗的均匀分布随机变量数量为 $2/2 = 1$。与策略 $\\mathcal{N}$ 每个样本消耗 $2$ 个均匀变量相比，减少了一半。\n    -   每个正态样本平均进行的高开销变换次数为 $1/2$。与策略 $\\mathcal{N}$ 每个样本进行 $1$ 次变换相比，减少了一半。\n    -   因此，每个样本的平均基本成本为 $\\frac{1}{2}(c_t + c_u)$。\n    -   在这个基本成本之上，我们必须加上开销。在策略 $\\mathcal{C}$ 下，每次调用 `next_normal()` 都涉及一个分支，产生期望成本 $p c_b$，以及平均内存成本 $c_m$。因此，每个样本的总期望成本是 $C_{\\mathcal{C}} = \\frac{1}{2}(c_t + c_u) + p c_b + c_m$。\n-   该陈述准确地反映了这一分析。它正确地指出了主要成本减少了一半，并正确地描述了最终的平均成本，包括附加的开销。\n\n结论：**正确**。\n\n**C. 由于在策略 $\\mathcal{C}$ 中对缓存标志位的分支是不可避免的，因此在具有分支预测功能的现代超标量CPU上，缓存必然会降低吞吐量，使得对于任何实际参数，$\\mathcal{C}$ 都比 $\\mathcal{N}$ 慢。**\n\n这个陈述声称对于任何实际参数都有 $C_{\\mathcal{C}} > C_{\\mathcal{N}}$。\n使用在 B 中推导的成本：\n$ \\frac{1}{2}(c_t + c_u) + p c_b + c_m > c_t + c_u $\n$ p c_b + c_m > \\frac{1}{2}(c_t + c_u) $\n让我们用实际的数值来评估这个不等式。超越函数（如 $c_t$）的成本在现代 CPU 上通常非常高（例如，几十到几百个时钟周期）。分支预测错误的成本 $c_b$ 也很显著，但较小（例如，$15-25$ 个周期）。一级缓存访问成本 $c_m$ 很小（例如，几个周期）。对于一个完全交替的模式，分支预测错误率 $p$ 在能够学习简单 `...1,0,1,0...` 模式的现代分支预测器上可以低至 $p=0$。即使使用一个简单的预测器，$p \\approx 0.5$。\n鉴于 $c_t$ 远大于所有其他成本，并且问题本身也说明 $c_m \\ll c_t$，这个不等式极不可能成立。例如，如果 $c_t = 100$, $c_u=10$, $c_b=20$, $c_m=5$，并且我们取一个悲观的 $p=0.5$，不等式变为：\n$ (0.5)(20) + 5 > \\frac{1}{2}(100 + 10) \\implies 15 > 55 $，这是错误的。\n将 $\\frac{1}{2}(c_t+c_u)$ 项减半所带来的巨大节省几乎总是会超过小的附加开销 $p c_b + c_m$。因此，该陈述在事实上是不正确的。策略 $\\mathcal{C}$ 的设计初衷恰恰是因为它在标量情境下比 $\\mathcal{N}$ 快得多。\n\n结论：**错误**。\n\n**D. 在模式 $\\mathsf{V}$ 下且 $n \\gg 1$ 时，缓存会因阻碍完全的SIMD向量化和引入额外的控制流而降低吞吐量；一种更高吞吐量的设计是在批量循环内部成对生成输出而不进行缓存，并单独处理长度为 $1$ 的奇数尾部。**\n\n模式 $\\mathsf{V}$ 涉及填充一个大数组，这是一项非常适合 SIMD（单指令多数据）向量化的任务。SIMD 依赖于并行地对多个数据元素执行相同的操作。一个 `for (i=0; i", "answer": "$$\\boxed{ABDE}$$", "id": "3323992"}, {"introduction": "尽管Box-Muller变换在数学上很优美，但其涉及的三角函数计算在一些性能敏感的应用中可能成为瓶颈。Marsaglia极坐标法是一种巧妙的替代方案，它通过拒绝采样方法避免了直接计算三角函数。本练习将引导你分析该方法的效率，包括计算其接受概率、获得一对有效随机数所需的期望迭代次数及其方差。通过这个过程，你将加深对拒绝采样这一蒙特卡洛核心技术的理解，并学会如何定量评估算法的性能。[@problem_id:3324024]", "problem": "考虑Marsaglia极坐标法，这是一种基于拒绝采样的Box–Muller变换的变体，用于生成标准正态分布的随机变量。在每次迭代中，从区间$[-1,1]$上均匀抽取两个独立同分布（i.i.d.）的随机变量$U$和$V$。定义$S = U^{2} + V^{2}$。如果$0 < S < 1$，则本次迭代接受该点对$(U,V)$，否则拒绝；一旦接受，该点对通过一个径向映射转换为一对独立的标准正态分布随机变量。假设连续的迭代是独立的，并且在接受时应用的变换对于$0 < S < 1$是可测且良定义的。\n\n仅使用基础的测度论和概率论概念——即有界集上均匀分布的定义、独立性的概念以及期望的级数恒等式——执行以下操作：\n\n1. 通过在接受域上对$(U,V)$的联合概率密度函数（PDF）进行积分，推导接受概率$p$。\n2. 将直到第一个被接受的点对所需的迭代次数$N$建模为一个以正整数为支撑的离散随机变量，并从第一性原理出发，推导迭代次数的期望值$\\mathbb{E}[N]$和方差$\\mathrm{Var}(N)$的闭式表达式。\n3. 以$\\pi$的精确解析表达式给出你的最终答案。不要进行四舍五入。\n\n你的最终答案必须是一个单行矩阵，按顺序包含接受概率$p$、期望迭代次数$\\mathbb{E}[N]$和迭代次数的方差$\\mathrm{Var}(N)$。不允许进行数值近似或四舍五入。", "solution": "该问题是有效的，因为它在随机模拟和概率论领域内构成了一个适定、有科学依据的问题。它没有歧义、矛盾和事实错误。我们进行形式化推导。\n\n**第1部分：接受概率 $p$ 的推导**\n\n问题指定了两个独立同分布（i.i.d.）的随机变量$U$和$V$，它们从区间$[-1, 1]$上的均匀分布中抽取。一个在区间$[a, b]$上均匀分布的随机变量$X$的概率密度函数（PDF）为$f_X(x) = \\frac{1}{b-a}$（当$x \\in [a, b]$时），否则$f_X(x)=0$。对于$U$和$V$，当$a = -1$和$b = 1$时，各自的PDF为：\n$$f_U(u) = \\frac{1}{1 - (-1)} = \\frac{1}{2}, \\quad \\text{for } u \\in [-1, 1]$$\n$$f_V(v) = \\frac{1}{1 - (-1)} = \\frac{1}{2}, \\quad \\text{for } v \\in [-1, 1]$$\n由于独立性，点对$(U, V)$的联合PDF是它们边际PDF的乘积：\n$$f_{U,V}(u,v) = f_U(u) f_V(v) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4}$$\n这个联合PDF在方形区域$\\mathcal{S} = \\{(u, v) \\in \\mathbb{R}^2 \\mid -1 \\le u \\le 1, -1 \\le v \\le 1\\}$上是常数。该方形区域的面积是$(2) \\times (2) = 4$。\n\n如果$0 < S < 1$（其中$S = U^2 + V^2$），则迭代被接受。这对应于点$(U, V)$落在区域$\\mathcal{A} = \\{(u, v) \\in \\mathbb{R}^2 \\mid 0 < u^2 + v^2 < 1\\}$内的事件。该区域是位于原点的单位圆的内部，且不包括原点$(0,0)$。整个接受域$\\mathcal{A}$都包含在方形区域$\\mathcal{S}$内。\n\n接受概率（记为$p$）是生成的点对$(U, V)$落入$\\mathcal{A}$的概率。这可以通过在接受域上对联合PDF进行积分得到：\n$$p = \\mathbb{P}((U, V) \\in \\mathcal{A}) = \\iint_{\\mathcal{A}} f_{U,V}(u,v) \\,du\\,dv$$\n由于点$(0,0)$在$\\mathbb{R}^2$中是零测集，对于连续的联合分布，条件$S > 0$不影响积分的值。因此，我们可以在开单位圆盘$\\mathcal{D} = \\{(u, v) \\in \\mathbb{R}^2 \\mid u^2+v^2 < 1\\}$上进行积分。\n$$p = \\iint_{u^2 + v^2 < 1} \\frac{1}{4} \\,du\\,dv$$\n由于被积函数是常数，积分的值是该常数乘以积分区域的面积。该区域是半径为$r=1$的圆盘，其面积为$\\pi r^2 = \\pi$。\n$$p = \\frac{1}{4} \\cdot (\\text{单位圆盘的面积}) = \\frac{1}{4} \\pi = \\frac{\\pi}{4}$$\n\n**第2部分：$\\mathbb{E}[N]$ 和 $\\mathrm{Var}(N)$ 的推导**\n\n随机变量$N$是获得第一次接受所需的迭代次数。每次迭代都是一次独立的伯努利试验，成功概率为$p = \\frac{\\pi}{4}$。因此，$N$服从参数为$p$的几何分布。其概率质量函数（PMF）为：\n$$\\mathbb{P}(N=k) = (1-p)^{k-1}p, \\quad k \\in \\{1, 2, 3, \\ldots\\}$$\n我们按照要求从第一性原理推导期望和方差。令$q = 1-p$。\n\n期望值$\\mathbb{E}[N]$由下式给出：\n$$\\mathbb{E}[N] = \\sum_{k=1}^{\\infty} k \\cdot \\mathbb{P}(N=k) = \\sum_{k=1}^{\\infty} k q^{k-1} p = p \\sum_{k=1}^{\\infty} k q^{k-1}$$\n对于$|q|<1$，几何级数为$\\sum_{k=0}^{\\infty} q^k = \\frac{1}{1-q}$。对$q$求导得到：\n$$\\frac{d}{dq} \\left( \\sum_{k=0}^{\\infty} q^k \\right) = \\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{d}{dq} \\left( \\frac{1}{1-q} \\right) = \\frac{1}{(1-q)^2}$$\n将此结果代入期望的表达式中：\n$$\\mathbb{E}[N] = p \\cdot \\frac{1}{(1-q)^2} = p \\cdot \\frac{1}{(1-(1-p))^2} = p \\cdot \\frac{1}{p^2} = \\frac{1}{p}$$\n当$p = \\frac{\\pi}{4}$时，期望迭代次数为：\n$$\\mathbb{E}[N] = \\frac{1}{\\pi/4} = \\frac{4}{\\pi}$$\n\n方差$\\mathrm{Var}(N)$由$\\mathrm{Var}(N) = \\mathbb{E}[N^2] - (\\mathbb{E}[N])^2$给出。我们首先计算$\\mathbb{E}[N^2]$。\n$$\\mathbb{E}[N^2] = \\sum_{k=1}^{\\infty} k^2 \\mathbb{P}(N=k) = p \\sum_{k=1}^{\\infty} k^2 q^{k-1}$$\n为了求和，我们从恒等式$\\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{1}{(1-q)^2}$开始。两边乘以$q$得到$\\sum_{k=1}^{\\infty} k q^k = \\frac{q}{(1-q)^2}$。对此式关于$q$求导：\n$$\\frac{d}{dq} \\left( \\sum_{k=1}^{\\infty} k q^k \\right) = \\sum_{k=1}^{\\infty} k^2 q^{k-1} = \\frac{d}{dq} \\left( \\frac{q}{(1-q)^2} \\right)$$\n使用商法则求导：\n$$\\frac{(1)(1-q)^2 - q(2(1-q)(-1))}{(1-q)^4} = \\frac{(1-q)^2 + 2q(1-q)}{(1-q)^4} = \\frac{(1-q) + 2q}{(1-q)^3} = \\frac{1+q}{(1-q)^3}$$\n将此结果代入$\\mathbb{E}[N^2]$的表达式中：\n$$\\mathbb{E}[N^2] = p \\cdot \\frac{1+q}{(1-q)^3} = p \\cdot \\frac{1+(1-p)}{(1-(1-p))^3} = p \\cdot \\frac{2-p}{p^3} = \\frac{2-p}{p^2}$$\n现在，我们可以计算方差：\n$$\\mathrm{Var}(N) = \\mathbb{E}[N^2] - (\\mathbb{E}[N])^2 = \\frac{2-p}{p^2} - \\left(\\frac{1}{p}\\right)^2 = \\frac{2-p-1}{p^2} = \\frac{1-p}{p^2}$$\n代入$p = \\frac{\\pi}{4}$：\n$$\\mathrm{Var}(N) = \\frac{1 - \\frac{\\pi}{4}}{(\\frac{\\pi}{4})^2} = \\frac{\\frac{4-\\pi}{4}}{\\frac{\\pi^2}{16}} = \\frac{4-\\pi}{4} \\cdot \\frac{16}{\\pi^2} = \\frac{4(4-\\pi)}{\\pi^2} = \\frac{16 - 4\\pi}{\\pi^2}$$\n\n**第3部分：最终答案**\n\n所要求的量是接受概率$p$、期望迭代次数$\\mathbb{E}[N]$和迭代次数的方差$\\mathrm{Var}(N)$。\n$p = \\frac{\\pi}{4}$\n$\\mathbb{E}[N] = \\frac{4}{\\pi}$\n$\\mathrm{Var}(N) = \\frac{16 - 4\\pi}{\\pi^2}$\n这些结果以行矩阵的形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{4} & \\frac{4}{\\pi} & \\frac{16 - 4\\pi}{\\pi^2}\n\\end{pmatrix}\n}\n$$", "id": "3324024"}, {"introduction": "实现一个随机数生成器只是第一步，更关键的是如何验证其输出的正确性。本练习将指导你编写一个全面的统计验证程序，不仅使用拟合优度检验来检查生成器输出的边缘分布是否符合标准正态分布，还通过检验其联合分布的关键特性（如半径和角度的分布）来揭示仅测试边缘分布的局限性。此练习通过一个巧妙的反例，深刻地说明了为何“边缘正确”不等于“联合正确”，这对于任何从事模拟工作的人来说都是至关重要的一课。[@problem_id:3323985]", "problem": "考虑通过对区间 $(0,1)$ 上的独立均匀随机变量进行变换来生成独立的标准正态随机变量。其基本原理如下：当 $(Z_1,Z_2)$ 是一对独立的标准正态随机变量时，通过 $R = \\sqrt{Z_1^2 + Z_2^2}$ 和 $\\Theta = \\operatorname{atan2}(Z_2,Z_1)$ 定义的到极坐标 $(R,\\Theta)$ 的变换，会产生一个尺度为 $1$ 的瑞利 (Rayleigh) 分布的半径 $R$ 和一个在 $[0,2\\pi)$ 上（以弧度为单位）均匀分布的角度 $\\Theta$，并且 $R$ 和 $\\Theta$ 是独立的。反之，对 $(0,1)$ 上的独立均匀随机变量进行正确的变换，可以生成这样一对 $(Z_1,Z_2)$。Kolmogorov–Smirnov 检验（用于比较经验分布函数与指定的连续累积分布函数）和 Anderson–Darling 检验（对尾部偏差加权更重）可以应用于一维边缘分布，以评估 $Z_1$ 和 $Z_2$ 是否各自服从标准正态分布。然而，这些检验不能直接评估二维联合分布或独立性。\n\n你的任务是编写一个完整的程序，该程序：\n\n1. 通过对 $(0,1)$ 上的独立均匀随机变量进行极坐标变换（通常称为 Box–Muller 变换），实现一个生成器，用于生成旨在成为独立标准正态随机变量的配对 $(Z_1,Z_2)$，并通过确保所有均匀抽样值都严格为正来避免退化输入。\n\n2. 对每个边缘分布 $Z_1$ 和 $Z_2$ 应用一维拟合优度检验：\n   - 在显著性水平 $0.05$ 下执行 Anderson–Darling 正态性检验（即，如果检验统计量严格小于对应 $5\\%$ 的表格临界值，则接受）。\n   - 在显著性水平 $0.05$ 下，针对均值为 $0$、方差为 $1$ 的标准正态分布执行 Kolmogorov–Smirnov 检验（即，如果 $p$ 值至少为 $0.05$，则接受）。\n   当且仅当所有四个检验（对 $Z_1$ 和 $Z_2$ 分别进行的 Anderson–Darling 和 Kolmogorov–Smirnov 检验）都接受时，将布尔值 $marginals\\_ok$ 定义为真。\n\n3. 通过增加从基本原理推导出的联合结构检查，来解决一维检验无法评估二维联合分布的局限性：\n   - 使用双参数反正切从 $(Z_1,Z_2)$ 计算角度 $\\Theta \\in [0,2\\pi)$，并通过 Kolmogorov–Smirnov 检验在显著性水平 $0.05$ 下检验其在 $[0,2\\pi)$（以弧度为单位）上的均匀性。\n   - 计算半径 $R = \\sqrt{Z_1^2 + Z_2^2}$，并通过 Kolmogorov–Smirnov 检验在显著性水平 $0.05$ 下检验其是否服从尺度为 $1$ 的瑞利 (Rayleigh) 分布。\n   - 计算 $Z_1$ 和 $Z_2$ 之间的样本 Pearson 相关系数，如果相关系数的绝对值严格小于 $0.05$ 并且 Pearson 相关性检验的双边 $p$ 值至少为 $0.05$，则接受该独立性代理指标。\n   当且仅当所有三个联合检查都接受时，将布尔值 $joint\\_ok$ 定义为真。\n\n4. 使用以下参数值测试套件，其中每个套件指定了随机数生成器的种子、样本大小和方法：\n   - 测试用例 1（理想路径）：种子 $12345$，样本大小 $20000$，方法 “box\\_muller” 使用独立均匀输入。\n   - 测试用例 2（中等大小）：种子 $2024$，样本大小 $500$，方法 “box\\_muller” 使用独立均匀输入。\n   - 测试用例 3（展示局限性的边缘案例）：种子 $42$，样本大小 $8000$，方法 “fake\\_pair\\_equal” 从一个原本有效的“box\\_muller”生成器构造出 $Z_2 = Z_1$，因此边缘分布保持为标准正态，但联合分布是退化的。\n   - 测试用例 4（非均匀输入失真）：种子 $777$，样本大小 $10000$，方法 “box\\_muller” 的输入 $U_1$ 从非均匀定律 $U_1 = V^2$（其中 $V \\sim \\operatorname{Uniform}(0,1)$）中抽取，而 $U_2 \\sim \\operatorname{Uniform}(0,1)$，以此来故意破坏径向定律而不改变角度定律。\n\n对于每个测试用例，你的程序必须生成一个包含以下内容的列表：\n- 布尔值 $marginals\\_ok$，\n- 布尔值 $joint\\_ok$，\n- $Z_1$ 和 $Z_2$ 之间样本 Pearson 相关系数绝对值的浮点值。\n\n程序的最终输出必须是单行文本，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，而每个测试结果本身也是一个用方括号括起来的逗号分隔列表。例如：“[ [true,false,0.01234], [true,true,0.00321], ... ]”。整个过程中角度必须以弧度处理。本问题不涉及任何物理单位。所有数值答案必须严格按照指定的最终输出格式返回。如上所述，所有检验的接受标准均为显著性水平 $0.05$。", "solution": "该问题要求基于 Box-Muller 变换，实现一个用于生成独立标准正态随机变量 $\\mathcal{N}(0,1)$ 的生成器，并对其进行统计验证。验证过程涉及一整套全面的检验，用于评估所生成变量的边缘分布及其联合结构。\n\n### 1. Box-Muller 变换：原理与实现\n\nBox-Muller 变换是蒙特卡洛模拟中一种从均匀分布变量生成标准正态变量的基础方法。它源于这样一种观察：如果 $(Z_1, Z_2)$ 是两个独立的标准正态随机变量，它们在极坐标 $(R, \\Theta)$ 中的表示（其中 $Z_1 = R \\cos \\Theta$ 和 $Z_2 = R \\sin \\Theta$）会得到一个独立的半径 $R$ 和角度 $\\Theta$。具体来说，半径的平方 $R^2 = Z_1^2 + Z_2^2$ 服从率 $\\lambda = 1/2$ 的指数分布，而角度 $\\Theta = \\operatorname{atan2}(Z_2, Z_1)$ 服从 $[0, 2\\pi)$ 上的均匀分布。\n\n该变换反向利用了这一性质。通过从各自的分布中生成 $R$ 和 $\\Theta$，然后转换回笛卡尔坐标，我们就可以生成所需的配对 $(Z_1, Z_2)$。\n生成过程如下：\n1.  从 $(0,1)$ 上的均匀分布中生成两个独立的随机变量 $U_1, U_2$，即 $U_1, U_2 \\sim \\operatorname{Uniform}(0,1)$。\n2.  为了从累积分布函数为 $F(x) = 1 - e^{-x/2}$ 的指数分布中生成半径的平方 $R^2$，我们使用逆变换采样法。令 $U_1 = F(R^2) = 1 - e^{-R^2/2}$。解出 $R^2$ 得 $R^2 = -2 \\ln(1 - U_1)$。由于 $1-U_1$ 也服从 $\\operatorname{Uniform}(0,1)$ 分布，我们可以将其简化为 $R^2 = -2 \\ln U_1$。由此得到半径为 $R = \\sqrt{-2 \\ln U_1}$。\n3.  为了从 $[0, 2\\pi)$ 均匀生成角度 $\\Theta$，我们只需对 $U_2$ 进行缩放：$\\Theta = 2\\pi U_2$。\n4.  最后，我们变换回笛卡尔坐标，以获得两个独立的标准正态变量：\n    $$Z_1 = R \\cos \\Theta = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2)$$\n    $$Z_2 = R \\sin \\Theta = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2)$$\n一个关键的实现细节是 $U_1$ 必须严格为正，以确保 $\\ln U_1$ 有定义。我们的实现将用一个非常小的正数，即机器ε (machine epsilon)，来替换任何出现的 $U_1=0$，以防止数值错误。\n\n### 2. 统计验证框架\n\n一项稳健的验证需要检查 $Z_1$ 和 $Z_2$ 的单个（边缘）分布以及它们的联合行为。\n\n#### 2.1. 边缘分布检验\n我们必须验证 $Z_1$ 和 $Z_2$ 是否各自服从标准正态分布。这是通过在显著性水平 $\\alpha=0.05$ 下使用两种标准的拟合优度检验来完成的。\n\n1.  **Anderson-Darling (AD) 检验**：该检验在检测与正态性的差异方面非常有效。计算检验统计量并与临界值进行比较。如果检验统计量严格小于 $5\\%$ 显著性水平的临界值，则接受原假设（即数据是正态的）。\n2.  **Kolmogorov-Smirnov (KS) 检验**：该检验将样本的经验累积分布函数 (ECDF) 与标准正态分布的理论累积分布函数 (CDF) 进行比较。如果检验的 $p$ 值大于或等于显著性水平，即 $p \\ge 0.05$，则接受原假设。\n\n当且仅当所有四个检验（对 $Z_1$ 的 AD 和 KS 检验；对 $Z_2$ 的 AD 和 KS 检验）都通过时，布尔变量 $marginals\\_ok$ 为真。\n\n#### 2.2. 联合结构检验\n对于一对随机变量而言，边缘正态性是其*独立*且服从标准正态分布的必要但不充分条件。联合检验旨在探查其二维结构。\n\n1.  **角度均匀性检验**：我们将生成的配对 $(Z_1, Z_2)$ 逆变换回极坐标，以获得角度 $\\Theta = \\operatorname{atan2}(Z_2, Z_1)$。根据基础理论，这些角度应在长度为 $2\\pi$ 的区间（例如 $[0, 2\\pi)$）上均匀分布。我们使用 KS 检验针对 $[0, 2\\pi)$ 上的均匀分布来检验这一假设。如果 $p$ 值至少为 $0.05$，则检验通过。\n2.  **半径分布检验**：类似地，我们计算半径 $R = \\sqrt{Z_1^2 + Z_2^2}$。这些半径应服从尺度参数 $\\sigma=1$ 的瑞利 (Rayleigh) 分布。这通过 KS 检验进行测试，如果 $p$ 值至少为 $0.05$，则检验通过。\n3.  **独立性检验（通过相关性）**：检验真正的独立性很困难。正态变量独立的一个常见且必要（但不充分）的条件是它们不相关。我们计算 $Z_1$ 和 $Z_2$ 之间的样本 Pearson 相关系数 $\\rho$。我们采用双重检查：系数的绝对值必须很小（$|\\rho| < 0.05$），并且非零相关性检验的 $p$ 值必须不显著（$p \\ge 0.05$）。\n\n当且仅当这三个联合检查都通过时，布尔变量 $joint\\_ok$ 为真。\n\n### 3. 测试用例分析\n\n所提供的测试套件旨在展示该验证框架的功效和局限性。\n\n-   **案例 1 和 2（标准 Box-Muller）**：这些案例使用正确的 \"box_muller\" 方法，分别采用大样本量（$N=20000$）和中等样本量（$N=500$）。由于生成器实现正确，我们预期 $marginals\\_ok$ 和 $joint\\_ok$ 都为真。种子确保了结果的确定性。\n-   **案例 3（退化的联合分布, $Z_2=Z_1$）**：此案例旨在“欺骗”边缘分布检验。首先正确生成一组标准正态变量 $Z_1$，然后将 $Z_2$ 设置为等于 $Z_1$。根据构造， $Z_1$ 和 $Z_2$ 的边缘分布都是标准正态分布。因此，我们预期 $marginals\\_ok$ 为真。然而，其联合结构是完全退化的。相关系数为 $\\rho=1$，半径 $R = \\sqrt{2Z_1^2} = \\sqrt{2}|Z_1|$ 不服从瑞利分布，角度 $\\Theta = \\operatorname{atan2}(Z_1, Z_1)$ 集中在 $\\pi/4$ 和 $-3\\pi/4$。所有联合检验都应该失败，从而导致 $joint\\_ok$ 为假。\n-   **案例 4（失真的输入）**：此处，输入均匀变量 $U_1$ 是从一个非均匀定律 $U_1 = V^2$（其中 $V \\sim \\operatorname{Uniform}(0,1)$）生成的。这个 $U_1$ 的概率密度函数 (PDF) 是 $f(u) = 1/(2\\sqrt{u})$，它偏向于 $0$。这直接破坏了半径 $R=\\sqrt{-2\\ln U_1}$ 的分布。因此，联合检验中的半径检验将会失败。$R$ 的这种失真也会使 $Z_1 = R\\cos\\Theta$ 和 $Z_2 = R\\sin\\Theta$ 的边缘分布非正态，所以边缘检验也应该失败。由于 $U_2$ 仍然是均匀的，角度 $\\Theta=2\\pi U_2$ 不受影响，因此角度检验可能会通过。相关性结构在线性意义上没有明显被破坏，但基本的分布属性是错误的。我们预期 $marginals\\_ok$ 和 $joint\\_ok$ 都为假。\n\n实现将遵循这些原则，使用 `numpy` 进行数值运算，使用 `scipy.stats` 进行统计检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Implements and validates a standard normal random variate generator\n    based on the Box-Muller transform, using a suite of statistical tests.\n    \"\"\"\n    test_cases = [\n        {\"seed\": 12345, \"sample_size\": 20000, \"method\": \"box_muller\"},\n        {\"seed\": 2024, \"sample_size\": 500, \"method\": \"box_muller\"},\n        {\"seed\": 42, \"sample_size\": 8000, \"method\": \"fake_pair_equal\"},\n        {\"seed\": 777, \"sample_size\": 10000, \"method\": \"box_muller_distorted\"},\n    ]\n\n    results = []\n    \n    # Significance level for all tests\n    alpha = 0.05\n    \n    # Critical value for Anderson-Darling test at 5% significance\n    # scipy.stats.anderson returns critical values for [15%, 10%, 5%, 2.5%, 1%]\n    ad_crit_val_idx = 2\n\n    for case in test_cases:\n        seed = case[\"seed\"]\n        n = case[\"sample_size\"]\n        method = case[\"method\"]\n        \n        rng = np.random.default_rng(seed)\n\n        z1, z2 = None, None\n\n        if method == \"box_muller\":\n            u1 = rng.uniform(size=n)\n            # Ensure u1 is strictly positive for log calculation\n            u1[u1 == 0.0] = np.finfo(float).eps\n            u2 = rng.uniform(size=n)\n            \n            r = np.sqrt(-2 * np.log(u1))\n            theta_gen = 2 * np.pi * u2\n            \n            z1 = r * np.cos(theta_gen)\n            z2 = r * np.sin(theta_gen)\n\n        elif method == \"fake_pair_equal\":\n            # Generate one set of normal variates and set the other equal\n            # Need n/2 pairs of uniforms to make n variates\n            num_pairs = (n + 1) // 2 \n            u1 = rng.uniform(size=num_pairs)\n            u1[u1 == 0.0] = np.finfo(float).eps\n            u2 = rng.uniform(size=num_pairs)\n            \n            r = np.sqrt(-2 * np.log(u1))\n            theta_gen = 2 * np.pi * u2\n            \n            temp_z1 = r * np.cos(theta_gen)\n            temp_z2 = r * np.sin(theta_gen)\n            \n            z_full = np.concatenate([temp_z1, temp_z2])\n            z1 = z_full[:n]\n            z2 = np.copy(z1)\n\n        elif method == \"box_muller_distorted\":\n            # U1 is from a non-uniform law U1 = V^2\n            v = rng.uniform(size=n)\n            u1 = v**2\n            # Ensure u1 is strictly positive for log calculation\n            u1[u1 == 0.0] = np.finfo(float).eps\n            u2 = rng.uniform(size=n)\n\n            r = np.sqrt(-2 * np.log(u1))\n            theta_gen = 2 * np.pi * u2\n            \n            z1 = r * np.cos(theta_gen)\n            z2 = r * np.sin(theta_gen)\n\n        # 2. Perform marginal tests\n        ad_z1 = stats.anderson(z1, dist='norm')\n        ks_z1 = stats.kstest(z1, 'norm')\n        \n        ad_z2 = stats.anderson(z2, dist='norm')\n        ks_z2 = stats.kstest(z2, 'norm')\n\n        ad1_ok = ad_z1.statistic  ad_z1.critical_values[ad_crit_val_idx]\n        ks1_ok = ks_z1.pvalue >= alpha\n        ad2_ok = ad_z2.statistic  ad_z2.critical_values[ad_crit_val_idx]\n        ks2_ok = ks_z2.pvalue >= alpha\n        \n        marginals_ok = all([ad1_ok, ks1_ok, ad2_ok, ks2_ok])\n\n        # 3. Perform joint structure tests\n        # Angle uniformity\n        thetas = (np.arctan2(z2, z1) + 2 * np.pi) % (2 * np.pi)\n        # Normalize to [0,1) for testing against uniform(0,1)\n        thetas_norm = thetas / (2 * np.pi)\n        ks_theta = stats.kstest(thetas_norm, 'uniform')\n        theta_ok = ks_theta.pvalue >= alpha\n        \n        # Radius Rayleigh distribution\n        radii = np.sqrt(z1**2 + z2**2)\n        ks_radii = stats.kstest(radii, 'rayleigh') # scale=1 is default\n        radii_ok = ks_radii.pvalue >= alpha\n        \n        # Independence via Pearson correlation\n        corr_res = stats.pearsonr(z1, z2)\n        corr_coeff, corr_pvalue = corr_res.statistic, corr_res.pvalue\n        corr_ok = (abs(corr_coeff)  0.05) and (corr_pvalue >= alpha)\n        \n        joint_ok = all([theta_ok, radii_ok, corr_ok])\n\n        # Store results\n        results.append([marginals_ok, joint_ok, abs(corr_coeff)])\n\n    # Format the final output string\n    result_strings = []\n    for res in results:\n        # Convert booleans to lowercase 'true'/'false'\n        formatted_res = [str(v).lower() for v in res[:-1]] + [f\"{res[-1]:.10f}\"]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3323985"}]}