{"hands_on_practices": [{"introduction": "帕累托分布是重尾分布的经典范例，对于模拟极端事件（如财富分配、保险索赔）至关重要。此练习将引导你完成逆变换采样的基本步骤：从概率密度函数（PDF）推导累积分布函数（CDF），然后反转CDF以获得分位数函数[@problem_id:3314460]。通过分析最终的分位数函数，你将直接洞察到从重尾分布中采样的极端值如何随样本量的增加而变化，这是风险分析和极值理论中的一个核心概念。", "problem": "考虑一个尺度参数为 $x_m > 0$ 且形状参数为 $\\alpha > 0$ 的帕累托分布。令 $X$ 为一个连续随机变量，其概率密度函数为：当 $x \\ge x_m$ 时，$f_X(x)=\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$；当 $x  x_m$ 时，$f_X(x)=0$。\n\n(a) 推导该分布的分位数函数 $Q(u)$ 的显式闭式表达式。\n(b) 对于大小为 $n \\in \\mathbb{N}$ 的样本，定义高分位数阈值 $\\tau_n$ 为满足 $\\mathbb{P}(X > \\tau_n) = 1/n$ 的值。请找到 $\\tau_n$ 的闭式表达式。", "solution": "所述问题需要经过验证。\n\n**步骤 1：提取已知条件**\n- **分布：** 帕累托分布。\n- **尺度参数：** $x_m > 0$。\n- **形状参数：** $\\alpha > 0$。\n- **随机变量：** $X$。\n- **概率密度函数 (PDF)：** 当 $x \\ge x_m$ 时，$f_X(x) = \\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$；当 $x  x_m$ 时，$f_X(x) = 0$。\n- **累积分布函数 (CDF)：** $F_X(x) = \\mathbb{P}(X \\le x)$。\n- **分位数函数：** 对于 $u \\in (0, 1)$，$Q(u) = F_X^{-1}(u) = \\inf\\{x \\in \\mathbb{R}: F_X(x) \\ge u\\}$。\n- **(a) 部分：** 推导 $Q(u)$ 的显式闭式表达式。\n- **(b) 部分：** 在一个模拟中，通过 $X^{\\star} = Q(U)$（其中 $U \\sim \\mathrm{Uniform}(0, 1)$）生成一个随机变量值。对于样本量 $n \\in \\mathbb{N}$，高分位数阈值 $\\tau_n$ 由关系 $\\mathbb{P}(X^{\\star} > \\tau_n) = 1/n$ 定义。任务是找到 $\\tau_n$ 的一个闭式表达式。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，是概率论和随机模拟中的一个标准练习题。它涉及良定义的帕累托分布和已确立的逆变换采样方法。该问题是适定的，因为所有必要的参数（$x_m, \\alpha$）、定义（PDF、CDF、分位数函数）和条件都已提供，可以得到唯一解。这些定义是标准的，语言客观而精确。所提供的 PDF 在给定的参数约束下是正确归一化的，因为 $\\int_{x_m}^{\\infty} \\alpha x_m^{\\alpha} x^{-(\\alpha+1)} \\, dx = \\alpha x_m^{\\alpha} [-\\frac{1}{\\alpha}x^{-\\alpha}]_{x_m}^{\\infty} = -x_m^{\\alpha}(0 - x_m^{-\\alpha}) = 1$。问题的设定是自洽的，且逻辑上一致。\n\n**步骤 3：结论与行动**\n该问题有效。将提供完整解答。\n\n**(a) 部分：分位数函数 $Q(u)$ 的推导**\n\n累积分布函数 (CDF) $F_X(x)$ 定义为概率密度函数 (PDF) $f_X(t)$ 从 $-\\infty$ 到 $x$ 的积分。帕累托分布的支撑集是 $[x_m, \\infty)$，所以对于任何 $x  x_m$，其 PDF 为 $f_X(x) = 0$，这意味着 $F_X(x) = 0$。\n\n对于 $x \\ge x_m$，CDF 的计算如下：\n$$F_X(x) = \\int_{-\\infty}^{x} f_X(t) \\, dt = \\int_{x_m}^{x} \\alpha x_m^{\\alpha} t^{-(\\alpha+1)} \\, dt$$\n我们可以将常数项提取出来并进行积分：\n$$F_X(x) = \\alpha x_m^{\\alpha} \\int_{x_m}^{x} t^{-(\\alpha+1)} \\, dt$$\n$t^k$ 的积分是 $\\frac{t^{k+1}}{k+1}$。这里，$k = -(\\alpha+1)$，所以 $k+1 = -\\alpha$。\n$$F_X(x) = \\alpha x_m^{\\alpha} \\left[ \\frac{t^{-\\alpha}}{-\\alpha} \\right]_{x_m}^{x}$$\n$$F_X(x) = -x_m^{\\alpha} \\left[ t^{-\\alpha} \\right]_{x_m}^{x}$$\n$$F_X(x) = -x_m^{\\alpha} (x^{-\\alpha} - x_m^{-\\alpha})$$\n$$F_X(x) = -x_m^{\\alpha} x^{-\\alpha} + x_m^{\\alpha} x_m^{-\\alpha}$$\n$$F_X(x) = 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}$$\n所以，完整的 CDF 是：\n$$F_X(x) = \\begin{cases} 0  \\text{for } x  x_m \\\\ 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}  \\text{for } x \\ge x_m \\end{cases}$$\n分位数函数 $Q(u)$ 是 CDF 的逆函数 $F_X^{-1}(u)$。由于 $F_X(x)$ 在其支撑集上是连续且严格递增的，我们可以通过设定 $u = F_X(x)$（对于 $u \\in (0, 1)$）并解出 $x$ 来求得其逆函数。这对应于 $x \\ge x_m$ 的情况。\n$$u = 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}$$\n重新整理各项以解出 $x$：\n$$\\left(\\frac{x_m}{x}\\right)^{\\alpha} = 1 - u$$\n对两边取 $1/\\alpha$ 次幂：\n$$\\frac{x_m}{x} = (1 - u)^{1/\\alpha}$$\n最后，分离出 $x$：\n$$x = \\frac{x_m}{(1-u)^{1/\\alpha}} = x_m (1 - u)^{-1/\\alpha}$$\n因此，帕累托分布的分位数函数是：\n$$Q(u) = x_m (1 - u)^{-1/\\alpha}, \\quad u \\in (0, 1)$$\n\n**(b) 部分：高分位数阈值 $\\tau_n$ 的推导**\n\n我们已知定义高分位数阈值 $\\tau_n$ 的条件：\n$$\\mathbb{P}(X > \\tau_n) = \\frac{1}{n}$$\n在逆变换采样中，随机变量值 $X$ 是通过使用 (a) 部分推导出的分位数函数对一个标准均匀分布随机变量 $U \\sim \\mathrm{Uniform}(0, 1)$进行变换生成的，即 $X = Q(U)$。将此代入概率表达式中：\n$$\\mathbb{P}(Q(U) > \\tau_n) = \\frac{1}{n}$$\n分位数函数 $Q(u)$ 对于 $u \\in (0,1)$ 是一个严格递增函数。因此，我们可以将其逆函数，即 CDF $F_X$，应用于概率内部不等式的两侧，而不会改变不等式的方向：\n$$Q(U) > \\tau_n \\iff U > F_X(\\tau_n)$$\n概率表达式变为：\n$$\\mathbb{P}(U > F_X(\\tau_n)) = \\frac{1}{n}$$\n对于一个标准均匀分布随机变量 $U$，对于任何 $p \\in [0, 1]$，概率 $\\mathbb{P}(U > p)$ 等于 $1 - p$。令 $p = F_X(\\tau_n)$。那么：\n$$1 - F_X(\\tau_n) = \\frac{1}{n}$$\n这意味着：\n$$F_X(\\tau_n) = 1 - \\frac{1}{n}$$\n这个方程说明 $\\tau_n$ 是分布 $X$ 对应于概率水平 $1 - 1/n$ 的分位数。根据分位数函数的定义，这意味着 $\\tau_n = Q(1 - 1/n)$。\n\n现在我们可以使用在 (a) 部分推导出的 $Q(u)$ 的显式公式，代入 $u = 1 - 1/n$：\n$$\\tau_n = Q\\left(1 - \\frac{1}{n}\\right) = x_m \\left(1 - \\left(1 - \\frac{1}{n}\\right)\\right)^{-1/\\alpha}$$\n化简括号内的表达式：\n$$\\tau_n = x_m \\left(\\frac{1}{n}\\right)^{-1/\\alpha}$$\n使用指数性质 $(a^b)^c = a^{bc}$：\n$$\\tau_n = x_m (n^{-1})^{-1/\\alpha} = x_m n^{(-1)(-1/\\alpha)}$$\n$$\\tau_n = x_m n^{1/\\alpha}$$\n这就是高分位数阈值 $\\tau_n$ 的闭式解析表达式。\n\n这个表达式揭示了从帕累托分布中抽取的极值如何随样本量 $n$ 而变化。阈值 $\\tau_n$，即在大小为 $n$ 的样本中平均被超过一次的期望值，随 $n$ 呈幂律增长，其指数是尾指数的倒数 $1/\\alpha$。这种多项式增长是重尾分布的一个特征。较小的 $\\alpha$（更重的尾部）导致较大的指数 $1/\\alpha$，这表明与具有较大 $\\alpha$（较轻的尾部）的分布相比，极值随样本量的增长更快。这与轻尾分布（例如指数分布、正态分布）形成鲜明对比，在轻尾分布中，分位数通常增长得慢得多，通常是随 $n$ 呈对数增长。", "answer": "$$\\boxed{x_m n^{1/\\alpha}}$$", "id": "3314460"}, {"introduction": "在许多实际应用中，我们需要从一个标准分布中抽样，但仅限于一个特定的区间，这被称为从截断分布中抽样。此练习展示了如何为这种情况调整逆变换方法，它引导你推导截断分布的分位数函数，该函数巧妙地结合了原始CDF和截断边界[@problem_id:3314454]。这是一个动手实践的编程练习，旨在构建一个通用工具，同时让你直面一个常见的现实挑战：当不存在封闭形式的逆CDF时，需要使用数值求根方法来解决问题。", "problem": "要求您为截断连续分布设计并实现一个逆变换采样器。从基本定义开始：如果一个连续随机变量 $X$ 的累积分布函数 (CDF) 为 $F(x)$，那么对于一个 $\\text{Uniform}(0,1)$ 变量 $U$，随机变量 $X = F^{-1}(U)$ 的 CDF 就是 $F(x)$。对于一个截断区间 $[a,b]$（其中 $-\\infty  a  b  \\infty$）且 $F$ 在 $[a,b]$ 上严格递增，截断累积分布函数的定义为\n$$\nF_T(x) = \\frac{F(x) - F(a)}{F(b) - F(a)}, \\quad x \\in [a,b].\n$$\n相应的截断分位数函数通过求解 $F_T(x) = u$ 关于 $x$ 的方程得到，其表达式为\n$$\nQ_T(u) = F^{-1}\\Big(F(a) + u\\big(F(b)-F(a)\\big)\\Big), \\quad u \\in [0,1].\n$$\n您的任务是：\n- 基于上述定义，从第一性原理出发推导截断 CDF 和截断分位数函数，并清晰阐述其推理过程。\n- 实现一个通用的截断连续分布逆变换采样器。该采样器在给定基础 $F$、其逆函数 $F^{-1}$（如果可用）以及截断边界 $a$ 和 $b$ 的情况下，为请求的 $u$ 值计算 $Q_T(u)$。当 $F^{-1}$ 的闭式解或库实现不可用时，通过在区间 $[a,b]$ 上使用稳健的求根方法求解 $F(x) = p$ 来对 $x$ 进行数值反演，其中 $p = F(a) + u\\big(F(b)-F(a)\\big)$。\n- 确保实现能精确处理边界情况 $u=0$ 和 $u=1$，即 $Q_T(0)=a$ 和 $Q_T(1)=b$。\n\n请使用以下测试套件。对于每种情况，为指定的 $u$ 值计算截断分位数列表 $[Q_T(u_1), Q_T(u_2), \\dots]$。\n\n- 测试用例 1（具有闭式解逆函数的理想路径）：基础分布为率 $\\lambda = 0.7$ 的指数分布，其基础 CDF 在 $[0,\\infty)$ 上为 $F(x) = 1 - e^{-\\lambda x}$。截断到 $[a,b]=[0.2,1.5]$。在 $u \\in \\{0,\\,0.3,\\,0.6,\\,1\\}$ 处进行评估。\n- 测试用例 2（使用库逆函数，非对称截断）：基础分布为标准正态分布 $\\mathcal{N}(0,1)$，其基础 CDF 为 $F(x)$，截断到 $[a,b]=[-0.5,\\,1.0]$。在 $u \\in \\{0,\\,0.5,\\,1\\}$ 处进行评估。\n- 测试用例 3（解析多项式 CDF）：基础概率密度函数 (PDF) 在 $[0,1]$ 上为 $f(x)=3x^2$，因此基础 CDF 为 $F(x)=x^3$。截断到 $[a,b]=[0.2,\\,0.8]$。在 $u \\in \\{0,\\,0.25,\\,0.5,\\,0.75,\\,1\\}$ 处进行评估。\n- 测试用例 4（仅数值反演）：基础 PDF 在 $[0,1]$ 上正比于 $e^{-x^3}$，其基础 CDF 为\n$$\nF(x) = \\frac{\\int_0^x e^{-t^3}\\,dt}{\\int_0^1 e^{-t^3}\\,dt}.\n$$\n等价地，使用下不完全伽玛函数 $\\gamma(s,z)$，$F(x) = \\frac{\\gamma\\!\\left(\\frac{1}{3},\\,x^3\\right)}{\\gamma\\!\\left(\\frac{1}{3},\\,1\\right)}$。截断到 $[a,b]=[0.1,\\,0.9]$。在 $u \\in \\{0,\\,0.5,\\,1\\}$ 处进行评估。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表用方括号括起来，每个测试用例对应一个内部的浮点数列表。确切格式为：\n- 按顺序为四个测试用例打印单行：\n$$\n\\big[ [Q_{T,1}(u_1),\\dots], [Q_{T,2}(u_1),\\dots], [Q_{T,3}(u_1),\\dots], [Q_{T,4}(u_1),\\dots] \\big]\n$$\n不含多余的空格或文本。例如，一个有效的结构格式是\n$$\n[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32},x_{33}],[x_{41},x_{42}]]\n$$\n其中每个 $x_{ij}$ 都是一个浮点数。", "solution": "出发点是连续随机变量 $X$ 的累积分布函数 (CDF) $F(x)$ 的定义，即 $F(x) = \\mathbb{P}(X \\le x)$。逆变换采样原理指出，如果 $U \\sim \\text{Uniform}(0,1)$，则 $X = F^{-1}(U)$ 的 CDF 为 $F(x)$。这是由单调性得出的：对于任意 $x$，$\\mathbb{P}(X \\le x) = \\mathbb{P}(F^{-1}(U) \\le x) = \\mathbb{P}(U \\le F(x)) = F(x)$。\n\n当将一个具有 CDF $F$ 的基础分布截断到区间 $[a,b]$ 时，我们考虑的是条件分布 $\\mathcal{L}(X \\mid a \\le X \\le b)$。对于任意 $x \\in [a,b]$，根据条件概率的定义，\n$$\nF_T(x) = \\mathbbP(X \\le x \\mid a \\le X \\le b) = \\frac{\\mathbb{P}(a \\le X \\le x)}{\\mathbb{P}(a \\le X \\le b)} = \\frac{F(x) - F(a)}{F(b) - F(a)}.\n$$\n这证明了截断 CDF 的公式，并确保了 $F_T(a)=0$ 和 $F_T(b)=1$。为获得截断分位数函数，我们令 $F_T(x) = u$ 并求解 $x$：\n$$\nu = \\frac{F(x) - F(a)}{F(b) - F(a)} \\quad \\Longrightarrow \\quad F(x) = F(a) + u\\big(F(b) - F(a)\\big).\n$$\n由于 $F$ 在 $[a,b]$ 上是严格递增的，我们可以对其求逆得到\n$$\nQ_T(u) = F^{-1}\\Big(F(a) + u\\big(F(b)-F(a)\\big)\\Big), \\quad u \\in [0,1].\n$$\n这个表达式可以直接恢复边界情况：对于 $u=0$，$Q_T(0) = F^{-1}(F(a)) = a$；对于 $u=1$，$Q_T(1) = F^{-1}(F(b)) = b$。\n\n实现的算法设计：\n- 输入：基础 CDF $F$，可选的基础分位数函数 $F^{-1}$（如果可用），截断边界 $a$ 和 $b$。\n- 计算 $F(a)$ 和 $F(b)$。\n- 对于每个输入 $u \\in [0,1]$：\n    - 如果 $u=0$，返回 $a$。如果 $u=1$，返回 $b$。\n    - 计算目标概率 $p = F(a) + u(F(b)-F(a))$。\n    - 如果 $F^{-1}$ 可用，则计算 $x = F^{-1}(p)$ 并返回。\n    - 如果 $F^{-1}$ 不可用，则在区间 $[a,b]$ 上对函数 $g(x) = F(x) - p$ 使用数值求根算法（例如Brent方法）求解 $g(x)=0$。返回找到的根。\n\n该算法对于所有四种测试情况都是通用的，并在需要时优雅地回退到数值反演。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.optimize import brentq\nfrom scipy.special import gammainc\n\ndef truncated_quantiles(F, Finv_or_none, a, b, u_values):\n    \"\"\"\n    Compute truncated quantiles Q_T(u) = F^{-1}(F(a) + u*(F(b)-F(a))) for u in u_values.\n    If Finv_or_none is None, perform numerical inversion on [a,b].\n    \"\"\"\n    Fa = F(a)\n    Fb = F(b)\n    results = []\n    for u in u_values:\n        # Handle exact endpoints\n        if u == 0.0:\n            results.append(float(a))\n            continue\n        if u == 1.0:\n            results.append(float(b))\n            continue\n        p = Fa + u * (Fb - Fa)\n        if Finv_or_none is not None:\n            x = Finv_or_none(p)\n        else:\n            # Numerically invert F(x) = p on [a,b] via Brent's method\n            # F is strictly increasing on [a,b], so a unique root exists.\n            func = lambda x: F(x) - p\n            # If func(a) == 0 or func(b) == 0, brentq will handle it, but we guarded above.\n            x = brentq(func, a, b, maxiter=100, rtol=1e-12)\n        results.append(float(x))\n    return results\n\ndef format_nested_list(nested):\n    \"\"\"\n    Format nested list of floats without spaces: [[a,b],[c,d,e],...]\n    \"\"\"\n    def fmt_float(x):\n        # Use repr to avoid trailing spaces and ensure a precise representation.\n        return repr(float(x))\n    inner_strs = []\n    for inner in nested:\n        inner_str = \"[\" + \",\".join(fmt_float(x) for x in inner) + \"]\"\n        inner_strs.append(inner_str)\n    return \"[\" + \",\".join(inner_strs) + \"]\"\n\ndef solve():\n    # Test Case 1: Exponential with rate lambda=0.7, truncated [0.2, 1.5], u in {0,0.3,0.6,1}\n    lam = 0.7\n    F_exp = lambda x: 1.0 - np.exp(-lam * x)\n    Finv_exp = lambda p: -np.log(1.0 - p) / lam\n    a1, b1 = 0.2, 1.5\n    u1 = [0.0, 0.3, 0.6, 1.0]\n    res1 = truncated_quantiles(F_exp, Finv_exp, a1, b1, u1)\n\n    # Test Case 2: Standard Normal, truncated [-0.5, 1.0], u in {0,0.5,1}\n    F_norm = lambda x: norm.cdf(x)\n    Finv_norm = lambda p: norm.ppf(p)\n    a2, b2 = -0.5, 1.0\n    u2 = [0.0, 0.5, 1.0]\n    res2 = truncated_quantiles(F_norm, Finv_norm, a2, b2, u2)\n\n    # Test Case 3: Polynomial base f(x)=3x^2 on [0,1], F(x)=x^3, truncated [0.2,0.8], u in {0,0.25,0.5,0.75,1}\n    F_poly = lambda x: x**3\n    Finv_poly = lambda p: p**(1.0/3.0)\n    a3, b3 = 0.2, 0.8\n    u3 = [0.0, 0.25, 0.5, 0.75, 1.0]\n    res3 = truncated_quantiles(F_poly, Finv_poly, a3, b3, u3)\n\n    # Test Case 4: Base PDF ∝ exp(-x^3) on [0,1], F(x) = gammainc(1/3, x^3) / gammainc(1/3, 1), truncated [0.1,0.9], u in {0,0.5,1}\n    denom = gammainc(1.0/3.0, 1.0)  # gammainc is the regularized lower incomplete gamma; denom is P(1/3,1)\n    F_expnegx3 = lambda x: gammainc(1.0/3.0, x**3) / denom\n    a4, b4 = 0.1, 0.9\n    u4 = [0.0, 0.5, 1.0]\n    # No closed-form inverse; use numerical inversion on [a,b]\n    res4 = truncated_quantiles(F_expnegx3, None, a4, b4, u4)\n\n    results = [res1, res2, res3, res4]\n\n    # Final print statement in the exact required format.\n    print(format_nested_list(results))\n\nsolve()\n```", "id": "3314454"}, {"introduction": "虽然理论上的分位数函数总是单调不减的，但其数值实现可能会受到浮点误差或算法缺陷的影响，从而违反这一关键属性。此练习介绍了一种系统性方法，用于测试数值分位数函数的单调性，并通过测量生成分布与目标分布之间的总变差距离，将任何违规行为与采样偏差直接联系起来[@problem_id:3314471]。这项实践超越了简单的实现，进入了数值验证的关键领域，为你提供了一个用于仿真软件质量保证的具体框架，并加深了你对微小数值缺陷如何导致显著统计错误的理解。", "problem": "您的任务是评估一个为连续分布而设的数值实现的分位数函数是否为非递减函数，并量化当使用逆变换采样时，与非递减行为的偏差如何引发抽样偏差。\n\n假设目标分布的支撑集在区间 $[0,1]$ 上，其累积分布函数为 $F(x) = x^{\\alpha}$ (对于 $x \\in [0,1]$)，形状参数 $\\alpha = 2$。相应的精确分位数函数为 $Q^{\\star}(u) = u^{1/\\alpha}$ (对于 $u \\in [0,1]$)。逆变换采样的定义是，生成 $U \\sim \\mathrm{Uniform}(0,1)$，并为一个分位数函数 $Q$ 设置 $X = Q(U)$。如果 $Q$ 是一个相对于 $F$ 满足广义逆性质的右连续、非递减函数，那么 $X$ 的分布与目标分布一致。如果 $Q$ 不是非递减的，那么 $U$ 在 $Q$ 下的前推分布会偏离目标分布，从而导致抽样偏差。\n\n设计并实现一个程序来执行以下操作：\n\n1. 对于一个 $u$ 值的网格，通过检查离散前向差分是否为非负来验证给定数值分位数函数 $Q(u)$ 的单调性。具体来说，对于一个网格 $\\{u_i\\}_{i=0}^{N-1}$，其中 $u_0 = 0$，$u_{N-1} = 1$，且 $u_i$ 均匀间隔，计算 $\\Delta_i = Q(u_{i+1}) - Q(u_i)$ (对于 $i = 0, \\dots, N-2$)，并定义一个带有容差 $\\tau$ 的非递减检验，如下所示：\n   - 当且仅当对所有 $i$ 都有 $\\Delta_i \\ge -\\tau$ 时，函数通过单调性检验。\n   - 定义违规计数为满足 $\\Delta_i  -\\tau$ 的索引 $i$ 的数量。\n   - 定义违规幅度为 $\\sum_{\\{i: \\Delta_i  -\\tau\\}} (-\\Delta_i)$。\n\n2. 量化使用 $Q(u)$ 进行逆变换采样所引起的抽样偏差，该偏差通过在 $x$ 空间中指定的一组直方图箱上，导出分布与目标分布之间的总变差距离来衡量。设直方图由 $B$ 个箱组成，其边界为 $\\{b_j\\}_{j=0}^{B}$，覆盖区间 $[x_{\\min}, x_{\\max}]$，其中 $x_{\\min} \\le 0$ 且 $x_{\\max} \\ge 1$。定义目标箱概率为\n   $$p^{\\text{true}}_j = F(\\min\\{1, b_{j+1}\\}) - F(\\max\\{0, b_j\\}), \\quad j = 0, \\dots, B-1,$$\n   约定 $F(x) = 0$ (对于 $x \\le 0$) 且 $F(x) = 1$ (对于 $x \\ge 1$)。这将 $[0,1]$ 之外的质量赋为零。通过将 $u$ 空间中的均匀网格通过 $Q(u)$ 映射到 $x$ 空间，并计算落入每个箱中的比例（如果 $Q(u)$ 产生此类值，则包括 $[0,1]$ 之外的任何质量），来定义导出箱概率。计算总变差距离\n   $$\\mathrm{TV} = \\frac{1}{2} \\sum_{j=0}^{B-1} \\left| p^{\\text{gen}}_j - p^{\\text{true}}_j \\right|,$$\n   其中 $p^{\\text{gen}}_j$ 是导出箱概率。\n\n3. 针对上述检验，评估三种数值分位数实现 $Q(u)$，均在 $\\alpha = 2$ 的同一目标分布内：\n   - 情况 A (基准，精确)：$Q_{\\mathrm{A}}(u) = u^{1/2}$。\n   - 情况 B (振荡扰动)：$Q_{\\mathrm{B}}(u) = u^{1/2} + \\varepsilon \\sin(2\\pi k u)$，其中 $\\varepsilon = 0.02$ 且 $k = 5$。\n   - 情况 C (分段反转)：对于参数 $a = 0.3$ 和 $b = 0.5$，定义\n     $$Q_{\\mathrm{C}}(u) = \\begin{cases}\n     u^{1/2},  u \\notin [a,b], \\\\\n     \\left(a + b - u\\right)^{1/2},  u \\in [a,b].\n     \\end{cases}$$\n     这在 $[a,b]$ 上引入了一个严格递减的段，同时保持了连续性。\n\n使用以下固定参数来构成测试套件：\n- 单调性网格：在 $[0,1]$ 上的 $N = 200001$ 个均匀间隔点，容差 $\\tau = 10^{-12}$。\n- 偏差评估：\n  - 通过 $Q(u)$ 映射，使用 $[0,1]$ 上的 $M = 200000$ 个均匀间隔点作为大型逆变换样本的代理，以消除随机性。\n  - 直方图规格：$B = 400$ 个箱，其边界在 $[x_{\\min}, x_{\\max}]$ 上均匀间隔，其中 $x_{\\min} = -0.05$，$x_{\\max} = 1.05$。\n\n您的程序必须为三种情况 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 中的每一种计算以下四个输出：\n- 一个单调性标志，如果非递减检验通过则为 $1$，否则为 $0$。\n- 违规计数，为一个整数。\n- 违规幅度，为一个浮点数。\n- 总变差距离 $\\mathrm{TV}$，为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由三个列表组成的列表，每个内部列表对应一种情况（按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 的顺序），形式为 $[\\text{flag}, \\text{count}, \\text{violation\\_magnitude}, \\text{TV}]$。整个输出必须是格式为\n`[ [.,.,.,.], [.,.,.,.], [.,.,.,.] ]`\n的单行，数值条目以标准十进制字符串打印。", "solution": "目标是验证一个连续概率分布的三种数值实现的分位数函数（表示为 $Q(u)$），并量化当这些函数非递减时引入的抽样偏差。此评估对于逆变换采样方法的可靠应用至关重要，而该方法是蒙特卡洛模拟的基石。\n\n该问题的理论基础是概率积分变换及其逆变换。对于一个具有严格递增累积分布函数（CDF）$F(x)$ 的连续随机变量 $X$，随机变量 $U = F(X)$ 在 $[0,1]$ 上均匀分布。逆变换采样方法利用了其逆过程：如果 $U$ 从均匀分布 $\\mathrm{Uniform}(0,1)$ 中抽取，则随机变量 $X = F^{-1}(U)$ 将具有 CDF $F(x)$。函数 $F^{-1}(u)$ 即为分位数函数 $Q(u)$。该方法有效性的一个关键属性是分位数函数 $Q(u)$ 必须是非递减的。如果违反此条件，从 $U$ 到 $X$ 的映射将无法正确保持概率测度，生成的样本 $X$ 的分布将偏离目标分布 $F(x)$。\n\n此分析的目标分布由 CDF $F(x) = x^{\\alpha}$ 定义，其中 $x \\in [0,1]$，参数 $\\alpha=2$。该分布的支撑集为区间 $[0,1]$。CDF 定义为当 $x \\le 0$ 时 $F(x)=0$，当 $x \\ge 1$ 时 $F(x)=1$。相应的精确分位数函数为 $Q^{\\star}(u) = F^{-1}(u) = u^{1/\\alpha} = u^{1/2}$，其中 $u \\in [0,1]$。\n\n对于所提供的三种分位数函数实现中的每一种，分析分两个主要步骤进行。\n\n**步骤 1：单调性验证**\n\n如果对于任何 $u_1  u_2$，都有 $Q(u_1) \\le Q(u_2)$ 成立，则函数 $Q(u)$ 是非递减的。为在数值上验证此属性，我们将域 $[0,1]$ 离散化为一个由 $N=200001$ 个点组成的精细、均匀的网格 $\\{u_i\\}_{i=0}^{N-1}$，其中 $u_i = i/(N-1)$。然后，我们计算前向差分序列 $\\Delta_i = Q(u_{i+1}) - Q(u_i)$，其中 $i=0, \\dots, N-2$。理论上，所有 $\\Delta_i$ 都必须是非负的。然而，为了适应有限精度浮点运算，我们引入了一个小容差 $\\tau = 10^{-12}$。当且仅当对于所有 $i$，都有 $\\Delta_i \\ge -\\tau$ 时，函数 $Q(u)$ 才被认为通过了单调性检验。\n\n从此检验中，我们导出三个度量指标：\n1.  一个二元单调性标志：如果检验通过（所有 $\\Delta_i \\ge -\\tau$），则为 $1$；否则为 $0$。\n2.  违规计数：一个整数，表示条件不满足（即 $\\Delta_i  -\\tau$）的索引 $i$ 的总数。\n3.  违规幅度：一个浮点数，量化递减的总程度，计算为总和 $\\sum_{\\{i: \\Delta_i  -\\tau\\}} (-\\Delta_i)$。\n\n**步骤 2：抽样偏差量化**\n\n当分位数函数 $Q(u)$ 不是非递减时，将其用于逆变换采样会引入偏差。我们通过测量由 $Q(u)$ 导出的分布与真实目标分布之间的统计距离来量化此偏差。使用的度量是总变差（TV）距离，定义为：\n$$\n\\mathrm{TV} = \\frac{1}{2} \\sum_{j=0}^{B-1} | p^{\\text{gen}}_j - p^{\\text{true}}_j |\n$$\n其中 $\\{p^{\\text{gen}}_j\\}$ 和 $\\{p^{\\text{true}}_j\\}$ 是分配给指定范围内 $B$ 个直方图箱的概率。\n\n箱概率计算如下：\n-   **目标概率 ($p^{\\text{true}}$)**：这些概率从精确的 CDF $F(x)$ 解析计算得出。对于一组在 $[x_{\\min}, x_{\\max}] = [-0.05, 1.05]$ 上均匀间隔的 $B=400$ 个直方图箱，其边界为 $\\{b_j\\}_{j=0}^{B}$，第 $j$ 个箱中的真实概率为 $p^{\\text{true}}_j = F(b_{j+1}) - F(b_j)$。问题中关于 $F(x)$ 在 $[0,1]$ 之外的规范，由 $p^{\\text{true}}_j = F(\\min\\{1, b_{j+1}\\}) - F(\\max\\{0, b_j\\})$ 捕获，正确地将所有概率质量分配到区间 $[0,1]$。\n-   **生成概率 ($p^{\\text{gen}}$)**：通过将 $[0,1]$ 上的一个确定性的、均匀的 $M=200000$ 个点的网格 $\\{u_k\\}$ 通过数值分位数函数 $Q(u)$ 映射，以获得一组生成值 $\\{x_k = Q(u_k)\\}$ 来确定这些概率。概率 $p^{\\text{gen}}_j$ 是这 $M$ 个点落入每个直方图箱 $j$ 的比例。这种确定性过程将函数 $Q(u)$ 的结构性偏差与随机抽样的随机性分离开来。\n\n**分位数函数案例分析**\n\n该程序应用于三个不同的函数：\n\n1.  **情况 A: $Q_{\\mathrm{A}}(u) = u^{1/2}$**。这是精确的、正确的分位数函数。它在 $(0,1]$ 上是严格递增的，因此我们期望它能通过单调性检验（标志=1，计数=0，幅度=0.0），并表现出非零但非常小的 TV 距离，这完全归因于数值离散化和分箱效应。\n\n2.  **情况 B: $Q_{\\mathrm{B}}(u) = u^{1/2} + \\varepsilon \\sin(2\\pi k u)$**，其中 $\\varepsilon = 0.02$，$k=5$。此函数在真实分位数函数上增加了一个小的、高频的振荡。其导数为 $Q'_{\\mathrm{B}}(u) = \\frac{1}{2}u^{-1/2} + 2\\pi k \\varepsilon \\cos(2\\pi k u)$。第二项可能为负，并且对于某些 $u$ 值，它可能超过第一项，导致 $Q'_{\\mathrm{B}}(u)  0$。因此，我们期望此函数无法通过单调性检验，从而产生非零的违规计数和幅度，以及相应的非零 TV 距离。\n\n3.  **情况 C: $Q_{\\mathrm{C}}(u)$**，对于 $u \\notin [0.3, 0.5]$ 为 $u^{1/2}$，对于 $u \\in [0.3, 0.5]$ 为 $(0.3 + 0.5 - u)^{1/2}$。此函数用一个反向映射区间 $[0.3, 0.5]$ 的段替换了正确分位数函数的一部分。在此区间上，$Q_{\\mathrm{C}}(u) = (0.8 - u)^{1/2}$，其导数严格为负。这代表了对非递减属性的重大、结构性违规。我们预计会有大的违规计数和幅度，以及显著的 TV 距离，反映出严重的抽样偏差。\n\n以下程序实现了这整个验证和量化过程。它定义了三个分位数函数，为每个函数计算了四个指定的度量指标，并以要求的格式呈现结果。使用 `NumPy` 是因为它强大而高效的数组操作，这对于处理问题规范所要求的大型点网格至关重要。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs monotonicity and bias analysis on three numerical quantile functions.\n    \"\"\"\n    # Problem parameters\n    ALPHA = 2.0\n    # Case B parameters\n    EPSILON = 0.02\n    K = 5\n    # Case C parameters\n    A = 0.3\n    B = 0.5\n    # Monotonicity test parameters\n    N_MONO = 200001\n    TAU = 1e-12\n    # Bias evaluation parameters\n    M_BIAS = 200000\n    B_HIST = 400\n    X_MIN = -0.05\n    X_MAX = 1.05\n\n    # --- Define Quantile Functions ---\n    def Q_A(u):\n        # Case A: Exact quantile function\n        return np.sqrt(u)\n\n    def Q_B(u):\n        # Case B: Oscillatory perturbation\n        return np.sqrt(u) + EPSILON * np.sin(2 * np.pi * K * u)\n\n    def Q_C(u):\n        # Case C: Segment reversal\n        res = np.sqrt(u)\n        mask = (u >= A)  (u = B)\n        res[mask] = np.sqrt(A + B - u[mask])\n        return res\n\n    # --- Define Target CDF ---\n    def F_target(x):\n        # Target CDF: F(x) = x^alpha on [0,1], 0 below, 1 above.\n        # np.clip handles the domain correctly.\n        x_clipped = np.clip(x, 0, 1)\n        return x_clipped**ALPHA\n\n    def evaluate_quantile_function(Q_func):\n        \"\"\"\n        Runs the full analysis for a given quantile function Q.\n        \n        Returns:\n            list: [monotonicity_flag, violation_count, violation_magnitude, tv_distance]\n        \"\"\"\n        # --- 1. Monotonicity Test ---\n        u_mono = np.linspace(0.0, 1.0, N_MONO)\n        x_vals_mono = Q_func(u_mono)\n        \n        # Compute forward differences\n        deltas = np.diff(x_vals_mono)\n        \n        # Find violations\n        violations_mask = deltas  -TAU\n        violation_count = int(np.sum(violations_mask))\n        \n        monotonicity_flag = 1 if violation_count == 0 else 0\n        \n        # Sum of magnitudes of violations\n        if violation_count > 0:\n            violation_magnitude = float(-np.sum(deltas[violations_mask]))\n        else:\n            violation_magnitude = 0.0\n\n        # --- 2. Bias Evaluation ---\n        # Define histogram bins\n        bin_edges = np.linspace(X_MIN, X_MAX, B_HIST + 1)\n\n        # Calculate target bin probabilities (p_true)\n        # The problem defines F(min{1,b_{j+1}})-F(max{0,b_j}). Our F_target does this.\n        # F_target applies np.clip internally.\n        p_true = F_target(bin_edges[1:]) - F_target(bin_edges[:-1])\n\n        # Calculate generated bin probabilities (p_gen)\n        # Use a deterministic grid for u as a proxy for a large sample\n        u_bias = np.linspace(0.0, 1.0, M_BIAS)\n        x_generated = Q_func(u_bias)\n        \n        # Histogram the generated values\n        counts, _ = np.histogram(x_generated, bins=bin_edges)\n        p_gen = counts / M_BIAS\n\n        # Calculate Total Variation Distance\n        tv_distance = float(0.5 * np.sum(np.abs(p_gen - p_true)))\n\n        return [monotonicity_flag, violation_count, violation_magnitude, tv_distance]\n\n    # --- Run Analysis for All Cases ---\n    results = []\n    for Q_func in [Q_A, Q_B, Q_C]:\n        result_vector = evaluate_quantile_function(Q_func)\n        results.append(result_vector)\n        \n    # --- Format and Print Output ---\n    # The output must be a single line in the specified format.\n    # Ex: [[1,0,0.0,1.2e-5],[0,3,0.1,0.2],[...]]\n    output_str = \",\".join(f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3314471"}]}