{"hands_on_practices": [{"introduction": "几何布朗运动的许多有趣特性都源于其基础构件——维纳过程（或布朗运动）。其中一个核心特性是标度不变性，即在时间上缩放的布朗运动在分布上等同于在空间上缩放的布朗运动。这个练习旨在通过数值模拟来亲手验证这一性质如何传递到几何布朗运动中，从而加深对理论与实践之间联系的理解 [@problem_id:3342027]。", "problem": "考虑一个由随机微分方程 (SDE) $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$ 定义的几何布朗运动，其中 $W_t$ 是一个维纳过程（布朗运动），$S_t$ 是在时间 $t$ 的资产价格，$\\mu$ 是漂移率，$\\sigma$ 是波动率。布朗运动的一个基本性质是其分布上的尺度不变性：对于任何 $c > 0$，有 $W_{ct} \\stackrel{d}{=} \\sqrt{c}\\, W_t$。从这些基本定义出发，您将验证在重标定时间 $ct$ 下导出的几何布朗运动的尺度不变性，并评估对于形式为 $E[g(S_{ct})]$（其中对于给定的实数指数 $p$，有 $g(x) = x^p$）的泛函期望的蒙特卡洛 (MC) 估计量的一致性。您不得使用本问题陈述中提供的任何捷径公式；相反，必须依赖于这些基本原理，并在您的解法中推导出任何需要的内容。\n\n您的程序必须：\n- 实现两种模拟路径来估计 $E[g(S_{ct})]$：\n  1. 直接路径，使用方差为 $ct$ 的高斯随机变量作为 $W_{ct}$ 的样本来模拟 $S_{ct}$。\n  2. 尺度变换路径，使用方差为 $t$ 的高斯随机变量作为 $W_t$ 的样本，然后构造 $\\sqrt{c}\\, W_t$ 来模拟 $S_{ct}$。\n- 对每个测试用例使用指定的 $p$ 构成的 $g(x) = x^p$。\n- 对每个测试用例，计算：\n  - 一个布尔值，表示两种 MC 估计量（来自直接路径和尺度变换路径）是否在由三倍标准误准则定义的规定容差内一致，即 $|\\hat{m}_1 - \\hat{m}_2| \\leq 3 \\sqrt{\\mathrm{SE}_1^2 + \\mathrm{SE}_2^2}$ 是否成立，其中 $\\hat{m}_i$ 是路径 $i$ 的样本均值，$\\mathrm{SE}_i$ 是其估计的标准误。\n  - 一个布尔值，表示尺度变换路径的 MC 估计量是否与解析推导的基准值 $E[g(S_{ct})]$（将在您的解法中推导）在同样的三倍标准误准则下一致。在 $c=0$ 的边界情况下，请注意 $S_{0} = S_0$ 且 $W_0 = 0$，因此两条路径都是确定性的，并且理应不言而喻地通过两项测试。\n\n您的程序必须对所有测试用例使用固定的随机种子 $123456$ 和共同的样本量 $N = 100000$。不涉及物理单位或角度单位。所有输出必须是数值布尔值。\n\n测试套件：\n- 用例 A (正常路径)：$S_0 = 100$, $\\mu = 0.05$, $\\sigma = 0.2$, $t = 1.0$, $c = 1.0$, $p = 1.0$。\n- 用例 B (中等尺度变换、负漂移率、较高波动率)：$S_0 = 50$, $\\mu = -0.02$, $\\sigma = 0.5$, $t = 1.0$, $c = 0.5$, $p = 2.0$。\n- 用例 C (到单位时间的大尺度变换、零漂移率)：$S_0 = 120$, $\\mu = 0.0$, $\\sigma = 1.0$, $t = 0.5$, $c = 2.0$, $p = 1.0$。\n- 用例 D (边界情况)：$S_0 = 80$, $\\mu = 0.03$, $\\sigma = 0.4$, $t = 1.0$, $c = 0.0$, $p = 1.5$。\n- 用例 E (接近零的时间范围)：$S_0 = 100$, $\\mu = 0.01$, $\\sigma = 0.6$, $t = 1.0$, $c = 10^{-6}$, $p = 1.0$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素本身是对应一个测试用例的包含两个布尔值的列表，顺序如上所述。例如：$[[b_{A,1}, b_{A,2}], [b_{B,1}, b_{B,2}], \\ldots]$，其中 $b_{X,1}$ 是用例 $X$ 的尺度不变性一致性布尔值，$b_{X,2}$ 是用例 $X$ 的一致性布尔值。", "solution": "该问题要求通过蒙特卡洛模拟来验证几何布朗运动 (GBM) 的尺度不变性属性，并与解析推导的期望值进行比较。解法分三个阶段进行：首先，推导 GBM 随机微分方程 (SDE) 的精确解；其次，推导指定泛函的解析期望；第三，设计数值模拟和统计检验。\n\n**1. 几何布朗运动 SDE 的解**\n\n过程 $S_t$ 由 SDE 定义：\n$$dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$$\n其中 $\\mu$ 是漂移率，$\\sigma$ 是波动率，而 $W_t$ 是一个标准维纳过程。为了找到 $S_t$ 的显式解，我们将 Itô 引理应用于函数 $f(S_t) = \\ln(S_t)$。$f$ 的偏导数是：\n$$ \\frac{\\partial f}{\\partial S} = \\frac{1}{S_t}, \\quad \\frac{\\partial^2 f}{\\partial S^2} = -\\frac{1}{S_t^2}, \\quad \\frac{\\partial f}{\\partial t} = 0 $$\n根据 Itô 引理，$f(S_t)$ 的微分由下式给出：\n$$ d(\\ln S_t) = \\left( \\frac{\\partial f}{\\partial t} + \\mu S_t \\frac{\\partial f}{\\partial S} + \\frac{1}{2} \\sigma^2 S_t^2 \\frac{\\partial^2 f}{\\partial S^2} \\right) dt + \\sigma S_t \\frac{\\partial f}{\\partial S} dW_t $$\n代入这些导数，我们得到：\n$$ d(\\ln S_t) = \\left( 0 + \\mu S_t \\cdot \\frac{1}{S_t} + \\frac{1}{2} \\sigma^2 S_t^2 \\cdot \\left(-\\frac{1}{S_t^2}\\right) \\right) dt + \\sigma S_t \\cdot \\frac{1}{S_t} dW_t $$\n$$ d(\\ln S_t) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) dt + \\sigma dW_t $$\n对两边从时间 $0$ 到 $t$ 积分：\n$$ \\int_0^t d(\\ln S_u) = \\int_0^t \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) du + \\int_0^t \\sigma dW_u $$\n$$ \\ln S_t - \\ln S_0 = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)t + \\sigma (W_t - W_0) $$\n鉴于 $W_0 = 0$，我们可以重新整理以解出 $S_t$：\n$$ S_t = S_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)t + \\sigma W_t \\right) $$\n这是 GBM 下资产价格的众所周知的解。为了求得重标定时间 $ct$ 的价格，我们只需用 $ct$ 替换 $t$：\n$$ S_{ct} = S_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)ct + \\sigma W_{ct} \\right) $$\n\n**2. 模拟路径与尺度不变性的合理性说明**\n\n问题要求通过两条路径模拟 $S_{ct}$，利用维纳过程的尺度变换性质，$W_{ct} \\stackrel{d}{=} \\sqrt{c}\\, W_t$（对于 $c>0$），其中 $\\stackrel{d}{=}$ 表示分布相等。\n\n在时间间隔 $\\tau$ 内的维纳过程增量 $W_\\tau$ 是一个均值为 $0$、方差为 $\\tau$ 的正态分布随机变量。即 $W_\\tau \\sim N(0, \\tau)$。这可以表示为 $W_\\tau = \\sqrt{\\tau} Z$，其中 $Z \\sim N(0, 1)$ 是一个标准正态随机变量。\n\n*   **路径 1 (直接)**：此路径使用 $W_{ct}$ 的样本来模拟 $S_{ct}$。根据上述性质，$W_{ct} \\sim N(0, ct)$。我们从标准正态分布中生成 $N$ 个样本 $\\{Z_i\\}_{i=1}^N$，并将随机项构造为 $\\sigma W_{ct}^{(i)} = \\sigma \\sqrt{ct} Z_i$。\n\n*   **路径 2 (尺度变换)**：此路径首先考虑 $W_t$，其中 $W_t \\sim N(0, t)$，然后应用尺度变换性质。$W_t$ 的一个样本构造为 $W_t^{(i)} = \\sqrt{t} Z_i$。尺度变换后的过程则为 $\\sqrt{c} W_t^{(i)} = \\sqrt{c} (\\sqrt{t} Z_i) = \\sqrt{ct} Z_i$。用于模拟 $S_{ct}$ 的随机项是 $\\sigma \\left( \\sqrt{c} W_t^{(i)} \\right) = \\sigma \\sqrt{ct} Z_i$。\n\n两条路径都得到了随机变量 $S_{ct}$ 的相同表达式：\n$$ S_{ct}^{(i)} = S_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)ct + \\sigma \\sqrt{ct} Z_i \\right) $$\n这证实了维纳过程的尺度变换性质在 GBM 过程中导出了相应且一致的尺度变换性质。问题的数值部分通过比较来自两个独立随机数集的估计值来检验这种统计等价性。\n\n**3. 解析期望的推导**\n\n我们的任务是计算 $E[g(S_{ct})]$ 的解析基准，其中 $g(x) = x^p$。\n$$ E[g(S_{ct})] = E[(S_{ct})^p] = E\\left[ \\left( S_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)ct + \\sigma W_{ct} \\right) \\right)^p \\right] $$\n$$ E[(S_{ct})^p] = S_0^p E\\left[ \\exp\\left( p\\left(\\mu - \\frac{1}{2}\\sigma^2\\right)ct + p\\sigma W_{ct} \\right) \\right] $$\n非随机部分可以移到期望符号之外：\n$$ E[(S_{ct})^p] = S_0^p \\exp\\left( p\\left(\\mu - \\frac{1}{2}\\sigma^2\\right)ct \\right) E\\left[ \\exp(p\\sigma W_{ct}) \\right] $$\n剩下的期望是正态随机变量 $W_{ct}$ 的矩生成函数 (MGF)。设 $X = W_{ct}$。我们知道 $X \\sim N(0, ct)$。一个一般正态随机变量 $Y \\sim N(\\nu, \\tau^2)$ 的 MGF 是 $M_Y(k) = E[e^{kY}] = \\exp(k\\nu + \\frac{1}{2}k^2\\tau^2)$。在我们的例子中，$Y=X$，$\\nu=0$，$\\tau^2 = ct$，并且 MGF 在 $k = p\\sigma$ 处取值。\n$$ E\\left[ \\exp(p\\sigma W_{ct}) \\right] = \\exp\\left( (p\\sigma) \\cdot 0 + \\frac{1}{2}(p\\sigma)^2 (ct) \\right) = \\exp\\left( \\frac{1}{2}p^2\\sigma^2 ct \\right) $$\n将此代回期望的表达式中：\n$$ E[(S_{ct})^p] = S_0^p \\exp\\left( p\\mu ct - \\frac{1}{2}p\\sigma^2 ct \\right) \\exp\\left( \\frac{1}{2}p^2\\sigma^2 ct \\right) $$\n合并指数项，得到最终的解析公式：\n$$ E[(S_{ct})^p] = S_0^p \\exp\\left( p\\mu ct + \\frac{1}{2}(p^2 - p)\\sigma^2 ct \\right) = S_0^p \\exp\\left( ct \\left[ p\\mu + \\frac{1}{2}p(p-1)\\sigma^2 \\right] \\right) $$\n\n**4. 蒙特卡洛模拟与统计检验**\n\n将对每个测试用例进行模拟，样本量为 $N=100000$。固定的随机种子确保了可复现性。对于每种情况，我们计算两个蒙特卡洛估计并进行比较。\n\n设 $\\{g_i\\}_{i=1}^N$ 是 $g(S_{ct})$ 的 $N$ 个样本值。样本均值为 $\\hat{m} = \\frac{1}{N} \\sum_{i=1}^N g_i$，样本标准差为 $\\hat{s} = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (g_i - \\hat{m})^2}$。均值的标准误为 $\\mathrm{SE} = \\hat{s} / \\sqrt{N}$。\n\n*   **一致性检验**：我们分别使用独立的随机数集，为直接路径和尺度变换路径计算均值 $\\hat{m}_1, \\hat{m}_2$ 和标准误 $\\mathrm{SE}_1, \\mathrm{SE}_2$。一致性检验是判断均值之差是否在统计上不显著，由以下准则定义：\n$$ |\\hat{m}_1 - \\hat{m}_2| \\leq 3 \\sqrt{\\mathrm{SE}_1^2 + \\mathrm{SE}_2^2} $$\n右侧项是两个独立样本均值之差的标准误的 $3$ 倍。\n\n*   **相符性检验**：我们将来自尺度变换路径的估计值 $\\hat{m}_2$ 与解析推导值 $E_{an} = E[(S_{ct})^p]$ 进行比较。如果估计值落在真实值的 $3$ 倍标准误置信区间内，则该估计量是相符的：\n$$ |\\hat{m}_2 - E_{an}| \\leq 3 \\cdot \\mathrm{SE}_2 $$\n\n对于 $c=0$ 的边界情况，时间范围 $ct$ 为 $0$。因此，$S_{ct} = S_0$ 是确定性的。两条模拟路径都将产生恒定值 $S_0$，因此样本将是 $g(S_0)=(S_0)^p$。因此，$\\hat{m}_1 = \\hat{m}_2 = E_{an} = (S_0)^p$，样本方差（和标准误）为 $0$。两个检验不等式都变为 $0 \\le 0$，这是成立的。\n\n对于问题陈述中提供的每个测试用例，实现将遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying scaling invariance of geometric Brownian motion\n    and assessing the consistency of Monte Carlo estimators.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        (100.0, 0.05, 0.2, 1.0, 1.0, 1.0),\n        # Case B (moderate scaling, negative drift, higher volatility)\n        (50.0, -0.02, 0.5, 1.0, 0.5, 2.0),\n        # Case C (large scaling to unit horizon with zero drift)\n        (120.0, 0.0, 1.0, 0.5, 2.0, 1.0),\n        # Case D (boundary case)\n        (80.0, 0.03, 0.4, 1.0, 0.0, 1.5),\n        # Case E (near-zero horizon)\n        (100.0, 0.01, 0.6, 1.0, 1.0e-6, 1.0),\n    ]\n\n    # Constants from the problem statement\n    N = 100000\n    SEED = 123456\n    rng = np.random.default_rng(SEED)\n\n    results = []\n    for case in test_cases:\n        S0, mu, sigma, t, c, p = case\n        \n        T = c * t\n\n        # Special handling for the deterministic boundary case c=0\n        if c == 0.0:\n            m1 = S0**p\n            se1 = 0.0\n            m2 = S0**p\n            se2 = 0.0\n            E_analytical = S0**p\n        else:\n            # Route 1: Direct simulation using W_ct ~ N(0, ct)\n            Z1 = rng.standard_normal(N)\n            S_ct1 = S0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * np.sqrt(T) * Z1)\n            g_S1 = S_ct1**p\n            m1 = np.mean(g_S1)\n            se1 = np.std(g_S1, ddof=1) / np.sqrt(N)\n\n            # Route 2: Scaling simulation using sqrt(c) * W_t, where W_t ~ N(0, t)\n            # A new set of random numbers is drawn to ensure statistical independence\n            Z2 = rng.standard_normal(N)\n            scaled_W_t = np.sqrt(c) * (np.sqrt(t) * Z2)\n            S_ct2 = S0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * scaled_W_t)\n            g_S2 = S_ct2**p\n            m2 = np.mean(g_S2)\n            se2 = np.std(g_S2, ddof=1) / np.sqrt(N)\n\n            # Analytical benchmark\n            exponent_term = T * (p * mu + 0.5 * p * (p - 1) * sigma**2)\n            E_analytical = S0**p * np.exp(exponent_term)\n\n        # Perform the two statistical tests\n\n        # 1. Agreement between the two MC estimators\n        # Test: |m1 - m2| = 3 * sqrt(SE1^2 + SE2^2)\n        agreement_threshold = 3.0 * np.sqrt(se1**2 + se2**2)\n        agreement_bool = np.abs(m1 - m2) = agreement_threshold\n\n        # 2. Consistency of the scaling-route estimator with the analytical benchmark\n        # Test: |m2 - E_analytical| = 3 * SE2\n        consistency_threshold = 3.0 * se2\n        # Handle case where standard error is zero (deterministic case)\n        if se2 == 0.0:\n             consistency_bool = np.isclose(m2, E_analytical)\n        else:\n             consistency_bool = np.abs(m2 - E_analytical) = consistency_threshold\n             \n        results.append([bool(agreement_bool), bool(consistency_bool)])\n\n    # Format and print the final results to match the required single-line format.\n    # str(results) produces a string like \"[[True, True], [True, False]]\".\n    # Removing spaces results in a compact representation \"[[True,True],[True,False]]\".\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3342027"}, {"introduction": "在掌握了模拟的基本方法之后，一个自然而然的步骤是将其应用于解决金融工程中的实际问题，例如为金融衍生品定价。本练习将引导您完成一项经典任务：估算两种不同执行价格的欧式看涨期权价格之差 [@problem_id:3341965]。更重要的是，您将学习并应用一种强大的方差缩减技术——“共同随机数” (Common Random Numbers, CRN)，通过利用两种期权收益之间的正相关性来显著提高蒙特卡洛估计的效率。", "problem": "本题要求您设计、分析并实现一个蒙特卡罗估计量，用于在几何布朗运动 (GBM) 模型下估算两个欧式看涨期权的价格差异，并使用公共随机数 (CRN) 方法来缩减方差。标的资产价格过程被建模为几何布朗运动 (GBM)，其随机微分方程 (SDE) 如下：\n$$\ndS_t = \\mu S_t \\, dt + \\sigma S_t \\, dB_t,\n$$\n其中，$S_t$ 是时间 $t$ 的资产价格，$\\mu$ 是漂移率，$\\sigma$ 是波动率，$B_t$ 是标准维纳过程。目标量是在固定时间 horizon $T$ 的期望收益之差，即：\n$$\n\\Delta P = \\mathbb{E}\\big[(S_T - K_1)^+\\big] - \\mathbb{E}\\big[(S_T - K_2)^+\\big],\n$$\n针对两个行权价 $K_1$ 和 $K_2$，其中 $(x)^+ = \\max\\{x,0\\}$。\n\n从 SDE 定义和维纳过程的性质出发，推导出一个不依赖时间离散化的 $S_T$ 的正确精确时间模拟方案。然后，设计一个使用公共随机数 (CRN) 的蒙特卡罗 (MC) 估计量来估算 $\\Delta P$，这意味着对于每个模拟的终端抽取，您必须使用相同的底层随机性来评估两个收益 $(S_T - K_1)^+$ 和 $(S_T - K_2)^+$。从第一性原理以及方差和协方差的性质出发，推导 CRN 方法下和基准“独立流”方法下估计量的方差形式。在独立流方法中，两个期权收益是独立模拟的，但总的收益评估次数相同。利用此结果获得方差缩减因子的经验估计。\n\n您的程序必须：\n- 实现 GBM 下 $S_T$ 的精确模拟。\n- 对每个测试用例，构建：\n  - 一个 $\\Delta P$ 的 CRN 估计量，使用 $n$ 次独立的终端冲击抽样，并在每次抽样上评估两个收益。\n  - CRN 下每条路径方差的经验估计，$\\widehat{\\mathrm{Var}}_{\\mathrm{CRN}} = \\widehat{\\mathrm{Var}}\\big((S_T - K_1)^+ - (S_T - K_2)^+\\big)$。\n  - 独立流下每条路径方差的经验估计，$\\widehat{\\mathrm{Var}}_{\\mathrm{ind}} = \\widehat{\\mathrm{Var}}\\big((S_T - K_1)^+\\big) + \\widehat{\\mathrm{Var}}\\big((S_T - K_2)^+\\big)$，该估计使用相同的模拟终端值计算，以保证总收益评估次数匹配。\n  - 经验方差缩减因子 $R = \\widehat{\\mathrm{Var}}_{\\mathrm{ind}} / \\widehat{\\mathrm{Var}}_{\\mathrm{CRN}}$。\n  - 两个收益之间的经验相关系数 $\\widehat{\\rho} \\in [-1,1]$。\n- 在每个测试用例中为伪随机数生成器使用固定的种子以确保可复现性。\n\n测试套件：\n- 用例 1：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.2$, $T = 1$, $K_1 = 90$, $K_2 = 110$, $n = 200000$, 种子 $= 1729$。\n- 用例 2：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.2$, $T = 1$, $K_1 = 100$, $K_2 = 100.001$, $n = 300000$, 种子 $= 2029$。\n- 用例 3：$S_0 = 100$, $\\mu = 0.0$, $\\sigma = 0.8$, $T = 1$, $K_1 = 100$, $K_2 = 120$, $n = 250000$, 种子 $= 2222$。\n- 用例 4：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.4$, $T = 0.05$, $K_1 = 95$, $K_2 = 105$, $n = 300000$, 种子 $= 3333$。\n\n所有参数均为无量纲标量。没有物理单位，也没有角度。所有报告的数值结果必须是实数。对于每个测试用例，您的程序必须输出一个包含三个浮点数的列表：\n- $\\Delta P$ 的 CRN 估计值，\n- 方差缩减因子 $R$，\n- 收益相关性估计 $\\widehat{\\rho}$，\n\n每个都四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目；每个条目本身应是按上述顺序排列的三元素列表。\n- 例如，整体打印的对象应如下所示：\n$$\n[\\,[\\delta_1, R_1, \\rho_1], [\\delta_2, R_2, \\rho_2], [\\delta_3, R_3, \\rho_3], [\\delta_4, R_4, \\rho_4]\\,],\n$$\n其中每个 $\\delta_i$、$R_i$ 和 $\\rho_i$ 都打印到 $6$ 位小数。", "solution": "用户提供了一个计算金融领域中定义明确的问题。我将首先验证问题陈述，然后提供一个完整的解决方案。\n\n### 步骤 1：提取已知条件\n- **模型**：标的资产价格 $S_t$ 服从几何布朗运动 (GBM)，其随机微分方程 (SDE) 为：\n$$\ndS_t = \\mu S_t \\, dt + \\sigma S_t \\, dB_t\n$$\n- **目标量**：两个欧式看涨期权的价格差异，$\\Delta P = \\mathbb{E}\\big[(S_T - K_1)^+\\big] - \\mathbb{E}\\big[(S_T - K_2)^+\\big]$，其中 $(x)^+ = \\max\\{x,0\\}$，$T$ 是到期时间，$K_1$、$K_2$ 是行权价。\n- **方法论**：使用公共随机数 (CRN) 进行方差缩减的蒙特卡罗估计量。\n- **要求推导**：\n    1. $S_T$ 的精确时间模拟方案。\n    2. CRN 和独立流下估计量方差的形式。\n- **每个测试用例的必需输出**：\n    1. $\\Delta P$ 的 CRN 估计值。\n    2. 经验方差缩减因子 $R = \\widehat{\\mathrm{Var}}_{\\mathrm{ind}} / \\widehat{\\mathrm{Var}}_{\\mathrm{CRN}}$。\n    3. 收益之间的经验相关系数 $\\widehat{\\rho}$。\n- **经验估计的定义**：\n    - $\\widehat{\\mathrm{Var}}_{\\mathrm{CRN}} = \\widehat{\\mathrm{Var}}\\big((S_T - K_1)^+ - (S_T - K_2)^+\\big)$.\n    - $\\widehat{\\mathrm{Var}}_{\\mathrm{ind}} = \\widehat{\\mathrm{Var}}\\big((S_T - K_1)^+\\big) + \\widehat{\\mathrm{Var}}\\big((S_T - K_2)^+\\big)$.\n- **测试套件**：\n    - 用例 1：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.2$, $T = 1$, $K_1 = 90$, $K_2 = 110$, $n = 200000$, 种子 $= 1729$。\n    - 用例 2：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.2$, $T = 1$, $K_1 = 100$, $K_2 = 100.001$, $n = 300000$, 种子 $= 2029$。\n    - 用例 3：$S_0 = 100$, $\\mu = 0.0$, $\\sigma = 0.8$, $T = 1$, $K_1 = 100$, $K_2 = 120$, $n = 250000$, 种子 $= 2222$。\n    - 用例 4：$S_0 = 100$, $\\mu = 0.03$, $\\sigma = 0.4$, $T = 0.05$, $K_1 = 95$, $K_2 = 105$, $n = 300000$, 种子 $= 3333$。\n- **输出格式**：一个单行的列表，其中每个元素是另一个列表，格式为 `[[delta_1, R_1, rho_1], [delta_2, R_2, rho_2], ...]`，每个数字打印到 6 位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于金融数学中的标准 GBM 模型，并采用标准的蒙特卡罗模拟技术 (CRN)。所有概念都牢固地植根于随机微积分和统计学。\n- **定义明确**：为每个测试用例提供了所有必需的参数（$S_0, \\mu, \\sigma, T, K_1, K_2, n$, seed）。目标函数和待计算量都已精确定义。可以计算出唯一的数值解。\n- **客观性**：问题使用精确、客观的数学语言陈述。\n- **结论**：问题有效。它在科学上是合理的，定义明确，客观，完整且不简单。\n\n### 步骤 3：结论与行动\n问题有效。我将继续进行解答。\n\n### 基于原理的设计与推导\n\n#### 1. 几何布朗运动的精确模拟方案\n价格过程 $S_t$ 由以下 SDE 控制：\n$$\ndS_t = \\mu S_t \\, dt + \\sigma S_t \\, dB_t\n$$\n为找到 $S_T$ 的精确解，我们考虑 $\\ln S_t$ 的过程。设 $f(x) = \\ln x$。其一阶和二阶导数分别为 $f'(x) = 1/x$ 和 $f''(x) = -1/x^2$。根据 Itô 引理，$f(S_t) = \\ln S_t$ 的动态过程由下式给出：\n$$\nd(\\ln S_t) = f'(S_t) dS_t + \\frac{1}{2} f''(S_t) (dS_t)^2\n$$\n根据 Itô 微积分法则，$(dS_t)^2 = (\\mu S_t dt + \\sigma S_t dB_t)^2 = \\sigma^2 S_t^2 dt$，因为包含 $dt^2$ 和 $dt \\, dB_t$ 的项为零。代入导数和 $(dS_t)^2$：\n$$\nd(\\ln S_t) = \\frac{1}{S_t} (\\mu S_t dt + \\sigma S_t dB_t) + \\frac{1}{2} \\left(-\\frac{1}{S_t^2}\\right) (\\sigma^2 S_t^2 dt)\n$$\n$$\nd(\\ln S_t) = (\\mu dt + \\sigma dB_t) - \\frac{1}{2} \\sigma^2 dt = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) dt + \\sigma dB_t\n$$\n这是一个系数恒定的 SDE。我们可以将其从 $t=0$ 积分到 $t=T$：\n$$\n\\int_0^T d(\\ln S_t) = \\int_0^T \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) dt + \\int_0^T \\sigma dB_t\n$$\n$$\n\\ln S_T - \\ln S_0 = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) T + \\sigma (B_T - B_0)\n$$\n鉴于 $B_0=0$，增量 $B_T$ 是一个随机变量，服从均值为 $0$、方差为 $T$ 的正态分布，即 $B_T \\sim \\mathcal{N}(0, T)$。我们可以写成 $B_T = \\sqrt{T} Z$，其中 $Z \\sim \\mathcal{N}(0, 1)$ 是一个标准正态随机变量。\n对两边取指数，得到 $S_T$ 的精确解：\n$$\nS_T = S_0 \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) T + \\sigma \\sqrt{T} Z \\right)\n$$\n此公式提供了一个“精确时间”模拟方案，因为它允许我们直接从 $S_T$ 的已知分布中抽取其终端价格的样本，而无需对时间区间 $[0, T]$ 进行离散化。\n\n#### 2. 蒙特卡罗估计与方差缩减\n设 $Y_1 = (S_T - K_1)^+$ 和 $Y_2 = (S_T - K_2)^+$ 是两个看涨期权的收益。我们感兴趣的量是 $\\Delta P = \\mathbb{E}[Y_1] - \\mathbb{E}[Y_2] = \\mathbb{E}[Y_1 - Y_2]$。\n\n**公共随机数 (CRN) 估计量**\nCRN 技术涉及使用相同的随机数流来模拟要比较的两个量。对于 $n$ 次蒙特卡罗试验中的每一次，我们生成一个独立的标准正态随机变量 $Z_i$（$i=1, \\dots, n$）。然后我们使用上面推导的方案计算单个终端价格 $S_{T,i}$。基于这单个 $S_{T,i}$，我们评估两个收益，$Y_{1,i} = (S_{T,i} - K_1)^+$ 和 $Y_{2,i} = (S_{T,i} - K_2)^+$。$\\Delta P$ 的 CRN 估计量是这些差值的样本均值：\n$$\n\\widehat{\\Delta P}_{\\mathrm{CRN}} = \\frac{1}{n} \\sum_{i=1}^n (Y_{1,i} - Y_{2,i})\n$$\n该估计量的方差由下式给出：\n$$\n\\mathrm{Var}(\\widehat{\\Delta P}_{\\mathrm{CRN}}) = \\frac{1}{n} \\mathrm{Var}(Y_1 - Y_2)\n$$\n项 $\\mathrm{Var}_{\\mathrm{CRN}} \\equiv \\mathrm{Var}(Y_1 - Y_2)$ 是 CRN 下的每路径方差。\n\n**基准独立流估计量**\n作为比较，考虑一个独立估计 $\\mathbb{E}[Y_1]$ 和 $\\mathbb{E}[Y_2]$ 的估计量。为了匹配 CRN 方法中使用的 $2n$ 次总收益评估次数，我们将为 $Y_1$ 使用 $n$ 条独立路径，为 $Y_2$ 使用另外 $n$ 条独立路径。该估计量将是 $\\widehat{\\Delta P}_{\\mathrm{ind}} = \\frac{1}{n}\\sum_{i=1}^n Y_{1,i} - \\frac{1}{n}\\sum_{j=1}^n Y'_{2,j}$，其中 $Y'$ 基于独立的模拟。该估计量的方差为：\n$$\n\\mathrm{Var}(\\widehat{\\Delta P}_{\\mathrm{ind}}) = \\mathrm{Var}\\left(\\frac{1}{n}\\sum_{i=1}^n Y_{1,i}\\right) + \\mathrm{Var}\\left(\\frac{1}{n}\\sum_{j=1}^n Y'_{2,j}\\right) = \\frac{1}{n}\\mathrm{Var}(Y_1) + \\frac{1}{n}\\mathrm{Var}(Y_2)\n$$\n相应的每路径方差是 $\\mathrm{Var}_{\\mathrm{ind}} \\equiv \\mathrm{Var}(Y_1) + \\mathrm{Var}(Y_2)$。\n\n**方差分析与缩减因子**\n使用属性 $\\mathrm{Var}(X-Y) = \\mathrm{Var}(X) + \\mathrm{Var}(Y) - 2\\mathrm{Cov}(X,Y)$，我们可以关联这两个方差：\n$$\n\\mathrm{Var}_{\\mathrm{CRN}} = \\mathrm{Var}_{\\mathrm{ind}} - 2\\mathrm{Cov}(Y_1, Y_2)\n$$\n收益函数 $Y_1 = \\max(S_T - K_1, 0)$ 和 $Y_2 = \\max(S_T - K_2, 0)$ 都是同一底层随机变量 $S_T$ 的非递减函数。因此，$Y_1$ 和 $Y_2$ 是正相关的，即 $\\mathrm{Cov}(Y_1, Y_2)  0$。这意味着 $\\mathrm{Var}_{\\mathrm{CRN}}  \\mathrm{Var}_{\\mathrm{ind}}$，所以 CRN 实现了方差缩减。\n\n方差缩减因子是每路径方差的比率：\n$$\nR = \\frac{\\mathrm{Var}_{\\mathrm{ind}}}{\\mathrm{Var}_{\\mathrm{CRN}}} = \\frac{\\mathrm{Var}(Y_1) + \\mathrm{Var}(Y_2)}{\\mathrm{Var}(Y_1 - Y_2)}\n$$\n$R  1$ 的值表示 CRN 是有效的。\n\n**经验量**\n在实践中，我们从模拟样本中计算经验估计。给定使用 CRN 生成的 $n$ 对收益 $\\{(Y_{1,i}, Y_{2,i})\\}_{i=1}^n$：\n- $\\Delta P$ 的估计值为 $\\widehat{\\Delta P} = \\bar{Y}_1 - \\bar{Y}_2$，其中 $\\bar{Y}_k = \\frac{1}{n}\\sum_{i=1}^n Y_{k,i}$。\n- 经验每路径 CRN 方差是差值的样本方差：$\\widehat{\\mathrm{Var}}_{\\mathrm{CRN}} = \\widehat{\\mathrm{Var}}(Y_1 - Y_2) = \\frac{1}{n-1}\\sum_{i=1}^n \\left( (Y_{1,i}-Y_{2,i}) - (\\bar{Y}_1 - \\bar{Y}_2) \\right)^2$。\n- 经验每路径独立方差是各单个样本方差之和：$\\widehat{\\mathrm{Var}}_{\\mathrm{ind}} = \\widehat{\\mathrm{Var}}(Y_1) + \\widehat{\\mathrm{Var}}(Y_2)$，其中 $\\widehat{\\mathrm{Var}}(Y_k) = \\frac{1}{n-1}\\sum_{i=1}^n (Y_{k,i} - \\bar{Y}_k)^2$。\n- 经验方差缩减因子是 $R = \\widehat{\\mathrm{Var}}_{\\mathrm{ind}} / \\widehat{\\mathrm{Var}}_{\\mathrm{CRN}}$。\n- 经验相关系数计算如下：\n$$\n\\widehat{\\rho} = \\frac{\\widehat{\\mathrm{Cov}}(Y_1, Y_2)}{\\sqrt{\\widehat{\\mathrm{Var}}(Y_1) \\widehat{\\mathrm{Var}}(Y_2)}}\n$$\n其中 $\\widehat{\\mathrm{Cov}}(Y_1, Y_2) = \\frac{1}{n-1}\\sum_{i=1}^n (Y_{1,i} - \\bar{Y}_1)(Y_{2,i} - \\bar{Y}_2)$。\n\n#### 3. 算法实现\n对于每个具有参数 $S_0, \\mu, \\sigma, T, K_1, K_2, n, \\text{seed}$ 的测试用例：\n1. 使用指定的种子初始化一个伪随机数生成器。\n2. 生成一个包含 $n$ 个独立标准正态随机变量 $Z_i \\sim \\mathcal{N}(0, 1)$ 的向量。\n3. 使用精确公式计算一个包含 $n$ 个终端股票价格 $S_{T,i}$ 的向量：$S_{T,i} = S_0 \\exp\\left( (\\mu - 0.5\\sigma^2)T + \\sigma\\sqrt{T}Z_i \\right)$。\n4. 计算两个收益向量，$Y_{1,i} = \\max(S_{T,i} - K_1, 0)$ 和 $Y_{2,i} = \\max(S_{T,i} - K_2, 0)$。\n5. 计算收益差向量 $\\Delta_i = Y_{1,i} - Y_{2,i}$。\n6. 计算价格差异的 CRN 估计值：$\\widehat{\\Delta P} = \\mathrm{mean}(\\Delta_i)$。\n7. 计算经验方差：\n    - $\\widehat{\\mathrm{Var}}_{\\mathrm{CRN}} = \\mathrm{var}(\\Delta_i, \\text{ddof}=1)$。\n    - $\\widehat{\\mathrm{Var}}(Y_1) = \\mathrm{var}(Y_{1,i}, \\text{ddof}=1)$。\n    - $\\widehat{\\mathrm{Var}}(Y_2) = \\mathrm{var}(Y_{2,i}, \\text{ddof}=1)$。\n    - $\\widehat{\\mathrm{Var}}_{\\mathrm{ind}} = \\widehat{\\mathrm{Var}}(Y_1) + \\widehat{\\mathrm{Var}}(Y_2)$。\n8. 计算经验方差缩减因子 $R = \\widehat{\\mathrm{Var}}_{\\mathrm{ind}} / \\widehat{\\mathrm{Var}}_{\\mathrm{CRN}}$。\n9. 计算经验相关系数 $\\widehat{\\rho} = \\mathrm{corrcoef}(Y_{1,i}, Y_{2,i})$。\n10. 存储当前测试用例的结果 $[\\widehat{\\Delta P}, R, \\widehat{\\rho}]$。\n11. 处理完所有用例后，按指定格式格式化并打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, analyzes, and implements a Monte Carlo estimator for the price\n    difference of two European call options under a Geometric Brownian Motion\n    (GBM) model, using Common Random Numbers (CRN) to reduce variance.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, mu, sigma, T, K1, K2, n, seed)\n        (100, 0.03, 0.2, 1, 90, 110, 200000, 1729),\n        (100, 0.03, 0.2, 1, 100, 100.001, 300000, 2029),\n        (100, 0.0, 0.8, 1, 100, 120, 250000, 2222),\n        (100, 0.03, 0.4, 0.05, 95, 105, 300000, 3333),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        S0, mu, sigma, T, K1, K2, n, seed = case\n\n        # 1. Initialize a pseudorandom number generator with the specified seed.\n        # Use default_rng for modern, best-practice random number generation.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate a vector of n independent standard normal random variates.\n        Z = rng.standard_normal(n)\n\n        # 3. Compute a vector of n terminal stock prices using the exact formula.\n        drift = (mu - 0.5 * sigma**2) * T\n        diffusion = sigma * np.sqrt(T) * Z\n        S_T = S0 * np.exp(drift + diffusion)\n\n        # 4. Compute two vectors of payoffs.\n        Y1 = np.maximum(S_T - K1, 0)\n        Y2 = np.maximum(S_T - K2, 0)\n\n        # 5. Calculate the vector of payoff differences.\n        delta_payoffs = Y1 - Y2\n\n        # 6. Calculate the CRN estimate of the price difference.\n        delta_p_crn = np.mean(delta_payoffs)\n\n        # 7. Calculate the empirical variances. ddof=1 for sample variance.\n        # Per-path variance under CRN\n        var_crn = np.var(delta_payoffs, ddof=1)\n        \n        # Individual payoff variances\n        var_y1 = np.var(Y1, ddof=1)\n        var_y2 = np.var(Y2, ddof=1)\n        \n        # Per-path variance under hypothetical independent streams\n        var_ind = var_y1 + var_y2\n\n        # 8. Calculate the empirical variance reduction factor R.\n        # Check for division by zero, though highly unlikely here.\n        if var_crn > 0:\n            R = var_ind / var_crn\n        else:\n            # This case happens if all payoff differences are identical,\n            # indicating perfect correlation and infinite reduction.\n            # R can be set to infinity or a large number.\n            # For this problem, it's safe to assume var_crn will be positive.\n            R = np.inf\n\n\n        # 9. Calculate the empirical correlation coefficient.\n        # np.corrcoef returns a 2x2 matrix. The off-diagonal element is the correlation.\n        # A check is needed for cases where one variance is zero.\n        if var_y1 > 0 and var_y2 > 0:\n            rho = np.corrcoef(Y1, Y2)[0, 1]\n        else:\n            # If one variance is zero, the payoff is constant (likely 0),\n            # and correlation is undefined. Set to 1 as it's the limit.\n            rho = 1.0\n\n        # 10. Store the results for the current test case.\n        all_results.append([delta_p_crn, R, rho])\n\n    # 11. After processing all cases, format and print the results as specified.\n    # The output format requires printing each number to 6 decimal places.\n    # This must be done via string formatting.\n    output_parts = []\n    for result_group in all_results:\n        # result_group is like [delta, R, rho]\n        formatted_group = [f'{val:.6f}' for val in result_group]\n        output_parts.append(f\"[{', '.join(formatted_group)}]\")\n\n    final_output = f\"[{', '.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3341965"}, {"introduction": "模拟不仅可以用于从给定的模型和参数生成数据路径（正向问题），还能作为一个强大的工具来分析从数据中估计模型参数的过程（反向问题）。本练习将带您探讨如何从离散观测的资产价格中估计几何布朗运动模型的波动率参数 $\\sigma$ [@problem_id:3341959]。您将推导最大似然估计量 (MLE)，并通过蒙特卡洛研究来评估其在有限样本下的统计特性（如偏差和方差），并将其与基于费雪信息理论的渐近结果进行比较。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用蒙特卡洛模拟，从离散时间观测中研究几何布朗运动（GBM）模型下波动率参数的最大似然估计（MLE），并将估计量的有限样本方差与从相应对数价格过程中计算出的费雪信息（Fisher information）的逆进行比较。该问题必须从随机微积分和统计推断的基本原理出发解决，不能以封闭形式的估计量作为起点。您可以假定的基本基础包括：GBM 的随机微分方程定义、布朗运动的性质、伊藤引理（Itô’s lemma）、正态分布增量的分布以及多元正态样本的对数似然的一般形式。\n\n从以下基础开始。一个严格为正的过程 $S_t$ 的几何布朗运动满足随机微分方程\n$$\n\\mathrm{d}S_t = \\mu S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中 $W_t$ 是标准布朗运动，$\\mu$ 是漂移率，$\\sigma$ 是波动率。定义对数价格 $X_t = \\log S_t$。根据伊藤引理和布朗运动的标准性质，在等间隔时间 $t_i = i \\Delta$（其中 $i \\in \\{1,\\dots,n\\}$）上的离散增量 $R_i = X_{t_i} - X_{t_{i-1}}$ 是独立且服从正态分布的：\n$$\nR_i \\sim \\mathcal{N}\\!\\big(\\Delta(\\mu - \\tfrac{1}{2}\\sigma^2),\\, \\sigma^2 \\Delta\\big).\n$$\n仅使用此基础来推导当漂移率参数未知时 $\\sigma$ 的最大似然估计。然后，实施蒙特卡洛（MC）研究，以评估所得估计量的有限样本偏差和方差，并将经验方差与根据对数价格模型计算的费雪信息所预测的渐近方差进行比较。\n\n您的程序必须对下面的每个测试用例执行以下操作：\n1. 在给定参数 $(\\mu,\\sigma,\\Delta)$ 下，根据上述精确的正态转移定律，模拟 $M$ 个独立的、长度为 $n$ 的对数回报率样本 $R_1,\\dots,R_n$。\n2. 对每个样本，根据 $S_{t_i}$ 的离散观测值计算 $\\sigma$ 的最大似然估计，这些观测值等价地由 $R_i = \\log S_{t_i} - \\log S_{t_{i-1}}$ 概括。\n3. 将估计量的有限样本偏差的蒙特卡洛估计计算为 $\\widehat{\\sigma}$ 的样本均值减去真实值 $\\sigma$。\n4. 将估计量的有限样本方差的蒙特卡洛估计计算为 $M$ 次重复中 $\\widehat{\\sigma}$ 的经验方差。\n5. 根据对数价格模型，计算由费雪信息预测的 $\\sigma$ 的渐近方差。\n6. 将所有测试用例的结果汇总到单行输出中。\n\n所有计算必须以纯数学术语表示，不带物理单位。此问题不涉及角度。百分比（若有）必须以小数表示。\n\n测试套件。使用以下三个测试用例，每个用例由一个元组 $(n,\\Delta,\\mu,\\sigma,M,\\text{seed})$ 指定：\n- 案例 A（一般情况，每日间隔的一个交易年）：$(n,\\Delta,\\mu,\\sigma,M,\\text{seed}) = (\\,252,\\, 1/252,\\, 0.08,\\, 0.25,\\, 20000,\\, 12345\\,)$。\n- 案例 B（小样本，粗略间隔）：$(n,\\Delta,\\mu,\\sigma,M,\\text{seed}) = (\\,5,\\, 1,\\, 0.00,\\, 0.50,\\, 200000,\\, 67890\\,)$。\n- 案例 C（长样本，精细间隔）：$(n,\\Delta,\\mu,\\sigma,M,\\text{seed}) = (\\,1000,\\, 1/252,\\, 0.02,\\, 0.20,\\, 5000,\\, 54321\\,)$。\n\n对于每个案例，您的程序必须按此顺序输出一个三元组 $[\\text{bias}, \\text{variance}, \\text{asymptotic\\_variance}]$，其中：\n- $\\text{bias}$ 是 $E[\\widehat{\\sigma}] - \\sigma$ 的蒙特卡洛估计，\n- $\\text{variance}$ 是使用除数 $M$ 的经验方差计算的 $\\mathrm{Var}(\\widehat{\\sigma})$ 的蒙特卡洛估计，\n- $\\text{asymptotic\\_variance}$ 是从大小为 $n$ 的单个样本的对数价格模型推导出的 $\\sigma$ 的费雪信息的逆，表示为 $\\sigma$ 和 $n$ 的函数。\n\n最终输出格式。您的程序应生成单行输出，其中包含案例 A、B 和 C 的三个三元组的列表（按此顺序），格式为以逗号分隔的列表，并用方括号括起，例如：\n\"[ [bias_A,variance_A,asymptotic_variance_A] , [bias_B,variance_B,asymptotic_variance_B] , [bias_C,variance_C,asymptotic_variance_C] ]\"\n您的程序必须是自包含的，并且不能要求任何输入。它必须使用上面确切的参数值和为可复现性提供的随机种子。最终输出必须只打印一次，并且只包含所述列表，不含任何额外文本。", "solution": "该问题要求推导几何布朗运动（GBM）过程中波动率参数 $\\sigma$ 的最大似然估计（MLE），通过费雪信息推导其渐近方差，并实施蒙特卡洛模拟以评估该估计量的有限样本性质。\n\n设股价过程 $S_t$ 服从几何布朗运动：\n$$\n\\mathrm{d}S_t = \\mu S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t\n$$\n其中 $\\mu$ 是漂移率，$\\sigma  0$ 是波动率，$W_t$ 是标准布朗运动。对数价格过程为 $X_t = \\log S_t$。对 $f(S_t) = \\log S_t$ 应用伊藤引理，我们发现 $X_t$ 服从算术布朗运动：\n$$\n\\mathrm{d}X_t = (\\mu - \\tfrac{1}{2}\\sigma^2) \\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}W_t\n$$\n对于长度为 $\\Delta$ 的离散、等间隔时间段，对数回报率 $R_i = X_{t_i} - X_{t_{i-1}}$（其中 $t_i = i\\Delta$）是独立同分布（i.i.d.）的正态随机变量：\n$$\nR_i \\sim \\mathcal{N}\\!\\left(\\nu, \\tau^2\\right)\n$$\n其中均值为 $\\nu = \\Delta(\\mu - \\tfrac{1}{2}\\sigma^2)$，方差为 $\\tau^2 = \\sigma^2 \\Delta$。\n\n### 1. 最大似然估计（MLE）的推导\n\n我们的目标是基于 $n$ 个对数回报率样本 $R_1, \\dots, R_n$，在 $\\mu$ 未知的情况下，求出 $\\sigma$ 的最大似然估计。模型的参数是 $(\\mu, \\sigma)$。样本的对数似然函数为：\n$$\n\\ell(\\mu, \\sigma; R_1, \\dots, R_n) = \\sum_{i=1}^n \\log f(R_i; \\mu, \\sigma)\n$$\n其中 $f(R_i; \\mu, \\sigma)$ 是均值为 $\\nu = \\Delta(\\mu - \\frac{1}{2}\\sigma^2)$、方差为 $\\sigma^2\\Delta$ 的正态分布的概率密度函数。对数似然函数可以写成：\n$$\n\\ell(\\mu, \\sigma) = \\sum_{i=1}^n \\left( -\\frac{1}{2}\\log(2\\pi) - \\frac{1}{2}\\log(\\sigma^2 \\Delta) - \\frac{(R_i - \\Delta(\\mu - \\frac{1}{2}\\sigma^2))^2}{2\\sigma^2 \\Delta} \\right)\n$$\n$$\n\\ell(\\mu, \\sigma) = -\\frac{n}{2}\\log(2\\pi\\Delta) - n\\log(\\sigma) - \\frac{1}{2\\sigma^2 \\Delta} \\sum_{i=1}^n \\left(R_i - \\Delta\\mu + \\frac{1}{2}\\Delta\\sigma^2\\right)^2\n$$\n为求最大似然估计 $(\\widehat{\\mu}, \\widehat{\\sigma})$，我们将 $\\ell$ 分别对 $\\mu$ 和 $\\sigma$ 求偏导数，并令其为零。\n\n关于 $\\mu$ 的偏导数为：\n$$\n\\frac{\\partial\\ell}{\\partial\\mu} = -\\frac{1}{2\\sigma^2 \\Delta} \\sum_{i=1}^n 2\\left(R_i - \\Delta\\mu + \\frac{1}{2}\\Delta\\sigma^2\\right)(-\\Delta) = \\frac{1}{\\sigma^2} \\sum_{i=1}^n \\left(R_i - \\Delta\\mu + \\frac{1}{2}\\Delta\\sigma^2\\right)\n$$\n令 $\\frac{\\partial\\ell}{\\partial\\mu} = 0$ 意味着 $\\sum (R_i - \\widehat{\\nu}) = 0$，其中 $\\widehat{\\nu}$ 是回报率均值的最大似然估计。由此得出 $\\widehat{\\nu} = \\frac{1}{n} \\sum R_i = \\bar{R}$。因此，在最大值处，参数必须满足：\n$$\n\\Delta(\\widehat{\\mu} - \\tfrac{1}{2}\\widehat{\\sigma}^2) = \\bar{R}\n$$\n这建立了 $\\widehat{\\mu}$ 和 $\\widehat{\\sigma}$ 之间的一个关系。现在我们可以通过用 $\\bar{R}$ 替代均值参数 $\\nu$ 来剖析似然函数。直接处理参数 $\\sigma^2$ 更为简便。关于 $\\sigma^2$ 的偏导数为：\n$$\n\\frac{\\partial\\ell}{\\partial(\\sigma^2)} = -\\frac{n}{2\\sigma^2} + \\frac{1}{2(\\sigma^2)^2 \\Delta} \\sum_{i=1}^n \\left(R_i - \\nu\\right)^2\n$$\n将其设为零并代入 $\\widehat{\\nu} = \\bar{R}$，我们得到：\n$$\n\\frac{n}{2\\widehat{\\sigma}^2} = \\frac{1}{2(\\widehat{\\sigma}^2)^2 \\Delta} \\sum_{i=1}^n (R_i - \\bar{R})^2 \\implies \\widehat{\\sigma}^2 = \\frac{1}{n\\Delta} \\sum_{i=1}^n (R_i - \\bar{R})^2\n$$\n根据最大似然估计的不变性，$\\sigma$ 的最大似然估计是 $\\sigma^2$ 的最大似然估计的平方根：\n$$\n\\widehat{\\sigma} = \\sqrt{\\frac{1}{n\\Delta} \\sum_{i=1}^n (R_i - \\bar{R})^2}\n$$\n该估计量将在模拟中使用。注意 $E[\\widehat{\\sigma}^2] = \\frac{n-1}{n}\\sigma^2$，因此 $\\widehat{\\sigma}^2$ 是 $\\sigma^2$ 的有偏估计量。因此，$\\widehat{\\sigma}$ 也是 $\\sigma$ 的有偏估计量。\n\n### 2. 渐近方差的推导\n$\\widehat{\\sigma}$ 的渐近方差由总费雪信息矩阵的逆的相应对角元素给出。对于 $n$ 个独立同分布的观测值，总费雪信息为 $I_n(\\mu, \\sigma) = n I(\\mu, \\sigma)$，其中 $I(\\mu, \\sigma)$ 是单个观测值的费雪信息。\n\n为简化计算，我们使用参数重整。令 $\\theta_1 = \\nu = \\Delta(\\mu - \\frac{1}{2}\\sigma^2)$ 且 $\\theta_2 = \\tau^2 = \\sigma^2 \\Delta$。单个观测值 $R_i$ 的对数似然为 $\\ell_i(\\theta_1, \\theta_2) = C - \\frac{1}{2}\\log(\\theta_2) - \\frac{(R_i - \\theta_1)^2}{2\\theta_2}$。$(\\theta_1, \\theta_2)$ 的费雪信息矩阵是对角的：\n$$\nI(\\theta_1, \\theta_2) = \\begin{pmatrix} -E[\\frac{\\partial^2 \\ell_i}{\\partial \\theta_1^2}]  0 \\\\ 0  -E[\\frac{\\partial^2 \\ell_i}{\\partial \\theta_2^2}] \\end{pmatrix} = \\begin{pmatrix} 1/\\theta_2  0 \\\\ 0  1/(2\\theta_2^2) \\end{pmatrix} = \\begin{pmatrix} 1/(\\sigma^2\\Delta)  0 \\\\ 0  1/(2\\sigma^4\\Delta^2) \\end{pmatrix}\n$$\n从 $(\\mu, \\sigma)$ 到 $(\\theta_1, \\sigma^2 \\Delta)$ 的变换具有雅可比矩阵 $J$：\n$$\nJ = \\frac{\\partial(\\theta_1, \\theta_2)}{\\partial(\\mu, \\sigma)} = \\begin{pmatrix} \\partial\\theta_1/\\partial\\mu  \\partial\\theta_1/\\partial\\sigma \\\\ \\partial\\theta_2/\\partial\\mu  \\partial\\theta_2/\\partial\\sigma \\end{pmatrix} = \\begin{pmatrix} \\Delta  -\\Delta\\sigma \\\\ 0  2\\sigma\\Delta \\end{pmatrix}\n$$\n$(\\mu, \\sigma)$ 的费雪信息矩阵为 $I(\\mu, \\sigma) = J^T I(\\theta_1, \\theta_2) J$：\n$$\nI(\\mu, \\sigma) = \\begin{pmatrix} \\Delta  0 \\\\ -\\Delta\\sigma  2\\sigma\\Delta \\end{pmatrix} \\begin{pmatrix} 1/(\\sigma^2\\Delta)  0 \\\\ 0  1/(2\\sigma^4\\Delta^2) \\end{pmatrix} \\begin{pmatrix} \\Delta  -\\Delta\\sigma \\\\ 0  2\\sigma\\Delta \\end{pmatrix} = \\begin{pmatrix} \\Delta/\\sigma^2  -\\Delta/\\sigma \\\\ -\\Delta/\\sigma  \\Delta + 2/\\sigma^2 \\end{pmatrix}\n$$\n该矩阵的行列式为 $\\det(I) = (\\Delta/\\sigma^2)(\\Delta + 2/\\sigma^2) - (-\\Delta/\\sigma)^2 = 2\\Delta/\\sigma^4$。其逆矩阵为：\n$$\n[I(\\mu, \\sigma)]^{-1} = \\frac{\\sigma^4}{2\\Delta} \\begin{pmatrix} \\Delta + 2/\\sigma^2  \\Delta/\\sigma \\\\ \\Delta/\\sigma  \\Delta/\\sigma^2 \\end{pmatrix} = \\begin{pmatrix} \\sigma^4/2 + \\sigma^2/\\Delta  \\sigma^3/2 \\\\ \\sigma^3/2  \\sigma^2/2 \\end{pmatrix}\n$$\n$(\\widehat{\\mu}, \\widehat{\\sigma})$ 的渐近方差-协方差矩阵是 $[n I(\\mu, \\sigma)]^{-1}$。$\\widehat{\\sigma}$ 的渐近方差是该矩阵的 $(2,2)$ 元素：\n$$\n\\text{Asymptotic Var}(\\widehat{\\sigma}) = \\frac{\\sigma^2}{2n}\n$$\n此结果与 $\\mu$ 和 $\\Delta$ 无关，仅取决于真实波动率 $\\sigma$ 和样本大小 $n$。\n\n### 3. 蒙特卡洛模拟设计\n对于每个测试用例 $(n, \\Delta, \\mu, \\sigma, M, \\text{seed})$，模拟过程如下：\n1.  使用给定的 `seed` 初始化随机数生成器。\n2.  重复 $M$ 次：\n    a. 从分布 $\\mathcal{N}(\\Delta(\\mu - \\frac{1}{2}\\sigma^2), \\sigma^2 \\Delta)$ 中生成一个包含 $n$ 个对数回报率的样本 $\\{R_i\\}_{i=1}^n$。\n    b. 使用公式 $\\widehat{\\sigma} = \\sqrt{\\frac{1}{n\\Delta} \\sum_{i=1}^n (R_i - \\bar{R})^2}$ 计算最大似然估计 $\\widehat{\\sigma}$。\n    c. 存储计算出的 $\\widehat{\\sigma}$ 值。\n3.  经过 $M$ 次重复后，我们得到一个估计值样本 $\\{\\widehat{\\sigma}_j\\}_{j=1}^M$。\n4.  将偏差估计为估计误差的样本均值：$\\text{bias} = \\left(\\frac{1}{M} \\sum_{j=1}^M \\widehat{\\sigma}_j\\right) - \\sigma$。\n5.  将方差估计为估计值的经验方差，按规定使用除数 $M$：$\\text{variance} = \\frac{1}{M} \\sum_{j=1}^M (\\widehat{\\sigma}_j - \\overline{\\widehat{\\sigma}})^2$，其中 $\\overline{\\widehat{\\sigma}} = \\frac{1}{M}\\sum_j \\widehat{\\sigma}_j$。\n6.  计算理论渐近方差：$\\text{asymptotic\\_variance} = \\sigma^2 / (2n)$。\n7.  每个案例的最终输出是三元组 $[\\text{bias}, \\text{variance}, \\text{asymptotic\\_variance}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(n, delta, mu, sigma, M, seed):\n    \"\"\"\n    Runs the Monte Carlo simulation for a single test case to assess the\n    properties of the MLE for volatility in a GBM model.\n\n    Args:\n        n (int): Number of observations in each sample path.\n        delta (float): Time step between observations.\n        mu (float): Drift parameter of the GBM.\n        sigma (float): Volatility parameter of the GBM.\n        M (int): Number of Monte Carlo replications.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing [bias, variance, asymptotic_variance].\n    \"\"\"\n    # Use the modern recommended way to manage random state\n    rng = np.random.default_rng(seed)\n\n    # Pre-calculate true parameters of the normal distribution for log-returns\n    # R_i ~ N(nu, sd_R^2)\n    nu = delta * (mu - 0.5 * sigma**2)\n    sd_R = sigma * np.sqrt(delta)\n\n    # Array to store the M estimates of sigma\n    sigma_hats = np.zeros(M)\n    \n    # Generate all random numbers at once for efficiency\n    all_R = rng.normal(loc=nu, scale=sd_R, size=(M, n))\n\n    # Perform calculations for each of the M samples\n    for i in range(M):\n        R = all_R[i, :]\n        \n        # The MLE for the variance of returns, var(R) = (1/n) * sum((R_i - R_bar)^2)\n        # using ddof=0 for the MLE (divisor n)\n        var_R_mle = np.var(R, ddof=0)\n        \n        # The MLE for sigma^2 is derived from var_R_mle = sigma_hat^2 * delta\n        sigma_sq_hat = var_R_mle / delta\n        \n        # By invariance property of MLEs, hat(sigma) = sqrt(hat(sigma^2))\n        sigma_hats[i] = np.sqrt(sigma_sq_hat)\n\n    # 3. Compute the Monte Carlo estimate of the bias\n    bias = np.mean(sigma_hats) - sigma\n\n    # 4. Compute the Monte Carlo estimate of the variance\n    # The problem specifies using divisor M, which corresponds to ddof=0\n    variance = np.var(sigma_hats, ddof=0)\n\n    # 5. Compute the theoretical asymptotic variance from Fisher Information\n    # Asymptotic Var(hat(sigma)) = sigma^2 / (2*n)\n    asymptotic_variance = sigma**2 / (2 * n)\n    \n    return [bias, variance, asymptotic_variance]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, Delta, mu, sigma, M, seed)\n        (252, 1/252.0, 0.08, 0.25, 20000, 12345),  # Case A\n        (5, 1.0, 0.00, 0.50, 200000, 67890),    # Case B\n        (1000, 1/252.0, 0.02, 0.20, 5000, 54321), # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        n, delta, mu, sigma, M, seed = case\n        result = run_simulation(n, delta, mu, sigma, M, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list is '[item1, item2, ...]', which matches the required format.\n    # We join these string representations with a comma and wrap with brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3341959"}]}