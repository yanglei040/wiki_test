{"hands_on_practices": [{"introduction": "在我们能够模拟动力学之前，我们需要一个有效的模型。本练习聚焦于动力学蒙特卡洛（KMC）方法的基石：生成元矩阵或速率矩阵。此练习探讨了细致平衡这一至关重要的物理约束，并演示了如何从可能不一致的物理建议中构建一个有效的速率矩阵，从而确保模拟最终能够对正确的平衡分布进行采样[@problem_id:3358266]。", "problem": "考虑一个定义在一维周期性晶格上的连续时间马尔可夫链，该晶格有 $N$ 个位点，标记为 $i \\in \\{0,1,\\dots,N-1\\}$，并具有最近邻连接。连续时间马尔可夫链的生成元矩阵 $Q$ 满足：对于每个 $i$，$q_{ii} = -\\sum_{j \\neq i} q_{ij}$，且当 $j \\neq i$ 时，$q_{ij} \\ge 0$。非对角元 $q_{ij}$ 是转移速率 $k_{ij}$。\n\n假设动力学由具有阿伦尼乌斯形式的过渡态理论（TST）控制，其中从状态 $i$ 到状态 $j$ 的速率由 $k_{ij} = \\nu_{ij} \\exp\\left(-\\frac{E^{\\ddagger}_{ij} - E_i}{k_{\\mathrm{B}} T}\\right)$ 给出，$E_i$ 是状态 $i$ 的能量，$E^{\\ddagger}_{ij}$ 是 $i \\to j$ 转移的过渡鞍点能量，$\\nu_{ij}$ 是尝试频率，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。微观可逆性要求对于任何一对相邻状态 $(i,j)$，相同的鞍点能量控制两个方向，即 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$。\n\n相对于玻尔兹曼分布的细致平衡要求存在一个平衡分布 $\\pi$，其满足 $\\pi_i \\propto \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$，使得对于所有状态对 $(i,j)$，都有 $\\pi_i k_{ij} = \\pi_j k_{ji}$。从上述基本定义出发，构建一个生成元 $Q$，该生成元对于给定的势垒建议值和尝试频率强制满足微观可逆性，并数值上验证细致平衡。\n\n对于下面的每个测试用例，您将获得：\n- 晶格大小 $N$ 以及 $i$ 和 $(i+1) \\bmod N$ 之间的周期性最近邻连接。\n- 以电子伏特（$\\mathrm{eV}$）为单位的状态能量 $E_i$。\n- 正向转移 $i \\to (i+1) \\bmod N$ 的势垒建议值 $b^{\\mathrm{fwd}}_i$，和反向转移 $(i+1) \\bmod N \\to i$ 的势垒建议值 $b^{\\mathrm{bwd}}_i$，单位均为 $\\mathrm{eV}$。\n- 以 $\\mathrm{s}^{-1}$ 为单位的尝试频率 $\\nu^{\\mathrm{fwd}}_i$ 和 $\\nu^{\\mathrm{bwd}}_i$。\n- 以开尔文（$\\mathrm{K}$）为单位的温度 $T$。\n使用玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ $\\mathrm{eV}/\\mathrm{K}$。\n\n每个测试用例的任务：\n1. 根据提供的 $E$、$b^{\\mathrm{fwd}}$、$b^{\\mathrm{bwd}}$、$\\nu^{\\mathrm{fwd}}$ 和 $\\nu^{\\mathrm{bwd}}$，为环状结构构建转移速率 $k_{ij}$，使其满足微观可逆性，并产生一个在温度 $T$ 下相对于玻尔兹曼分布可逆的生成元 $Q$。构建过程必须从提供的基本定义开始，不得假设任何非派生的快捷公式。\n2. 形成生成元 $Q$，其中当 $j \\neq i$ 时 $q_{ij} = k_{ij}$，且 $q_{ii} = -\\sum_{j \\neq i} k_{ij}$。\n3. 计算玻尔兹曼平衡权重 $\\pi_i \\propto \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$，并将其归一化，使得 $\\sum_i \\pi_i = 1$。\n4. 计算所有最近邻对上的最大绝对细致平衡残差，\n$$\nr_{\\max} = \\max_{i} \\left| \\pi_i k_{i,(i+1)\\bmod N} - \\pi_{(i+1)\\bmod N} k_{(i+1)\\bmod N,i} \\right|.\n$$\n报告每个测试用例的 $r_{\\max}$ 值，单位为 $\\mathrm{s}^{-1}$。\n\n测试套件：\n- 用例 $1$（理想情况，对称的尝试频率和一致的势垒）：\n    - $N = 4$，\n    - $E = [\\,0.00,\\,0.05,\\,0.10,\\,0.20\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.40,\\,0.45,\\,0.50,\\,0.60\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.40,\\,0.45,\\,0.50,\\,0.60\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 300.0$ $\\mathrm{K}$。\n- 用例 $2$（非对称的尝试频率和非对称的势垒建议值）：\n    - $N = 5$，\n    - $E = [\\,0.00,\\,0.02,\\,0.08,\\,0.04,\\,0.10\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.35,\\,0.37,\\,0.42,\\,0.40,\\,0.45\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.33,\\,0.39,\\,0.41,\\,0.43,\\,0.44\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,2.0 \\times 10^{13},\\,0.5 \\times 10^{13},\\,1.5 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,0.8 \\times 10^{13},\\,1.8 \\times 10^{13},\\,0.7 \\times 10^{13},\\,1.2 \\times 10^{13},\\,0.9 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 350.0$ $\\mathrm{K}$。\n- 用例 $3$（高势垒，慢动力学）：\n    - $N = 3$，\n    - $E = [\\,0.00,\\,0.10,\\,0.20\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,1.00,\\,0.90,\\,1.10\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,1.00,\\,0.90,\\,1.10\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.0 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 300.0$ $\\mathrm{K}$。\n- 用例 $4$（简并能量，异构的尝试频率和势垒建议值）：\n    - $N = 4$，\n    - $E = [\\,0.05,\\,0.05,\\,0.05,\\,0.05\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{fwd}} = [\\,0.25,\\,0.30,\\,0.28,\\,0.27\\,]$ $\\mathrm{eV}$，\n    - $b^{\\mathrm{bwd}} = [\\,0.26,\\,0.29,\\,0.31,\\,0.24\\,]$ $\\mathrm{eV}$，\n    - $\\nu^{\\mathrm{fwd}} = [\\,1.0 \\times 10^{13},\\,1.2 \\times 10^{13},\\,0.9 \\times 10^{13},\\,1.1 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $\\nu^{\\mathrm{bwd}} = [\\,0.8 \\times 10^{13},\\,1.3 \\times 10^{13},\\,1.0 \\times 10^{13},\\,1.2 \\times 10^{13}\\,]$ $\\mathrm{s}^{-1}$，\n    - $T = 400.0$ $\\mathrm{K}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个 $r_{\\max}$ 值的列表，单位为 $\\mathrm{s}^{-1}$，格式为逗号分隔的 Python 风格列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 按相同顺序对应于第 $i$ 个用例。不应打印任何额外文本。", "solution": "问题陈述被评估为有效。它在科学上基于统计力学和随机过程理论，是良定的、客观的，并包含了构建唯一且有意义的解所需的所有信息。问题的核心在于从可能不一致的输入建议值中构建一个物理上一致的速率模型，这是计算物理和计算化学中的一个标准且非平凡的任务。\n\n解决方案首先建立理论框架，然后详细说明转移速率的构建以及随后的细致平衡残差的计算。\n\n该系统是一个在一维周期性晶格上的连续时间马尔可夫链，晶格有 $N$ 个位点，由 $i \\in \\{0, 1, \\dots, N-1\\}$ 索引。转移仅限于最近邻之间。从状态 $i$ 到状态 $j$ 的转移速率 $k_{ij}$ 由过渡态理论推导出的阿伦尼乌斯形式给出：\n$$\nk_{ij} = \\nu_{ij} \\exp\\left(-\\frac{E^{\\ddagger}_{ij} - E_i}{k_{\\mathrm{B}} T}\\right)\n$$\n其中 $E_i$ 是状态 $i$ 的能量，$E^{\\ddagger}_{ij}$ 是 $i$ 和 $j$ 之间的过渡态（鞍点）能量，$\\nu_{ij}$ 是尝试频率，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n动力学必须满足两个基本原则：微观可逆性和细致平衡。\n\n1.  **微观可逆性**：问题将此原则定义为要求两个状态 $i$ 和 $j$ 之间的转移路径与方向无关。这意味着对于任何连接对 $(i,j)$，存在一个单一的、共享的鞍点能量，即 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$。\n\n2.  **细致平衡**：对于处于热平衡的系统，任何两个状态之间的净通量必须为零。这由细致平衡条件表达：\n    $$\n    \\pi_i k_{ij} = \\pi_j k_{ji}\n    $$\n    其中 $\\pi$ 是平衡分布。对于与热库接触的系统，这是玻尔兹曼分布：\n    $$\n    \\pi_i = \\frac{1}{Z} \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)\n    $$\n    其中 $Z = \\sum_k \\exp(-\\frac{E_k}{k_{\\mathrm{B}} T})$ 是配分函数。\n\n让我们将速率的阿伦尼乌斯表达式代入细致平衡方程。令 $\\beta = 1/(k_{\\mathrm{B}}T)$。\n$$\n\\frac{e^{-\\beta E_i}}{Z} \\left( \\nu_{ij} e^{-\\beta(E^{\\ddagger}_{ij} - E_i)} \\right) = \\frac{e^{-\\beta E_j}}{Z} \\left( \\nu_{ji} e^{-\\beta(E^{\\ddagger}_{ji} - E_j)} \\right)\n$$\n化简指数项得到：\n$$\n\\nu_{ij} e^{-\\beta E^{\\ddagger}_{ij}} = \\nu_{ji} e^{-\\beta E^{\\ddagger}_{ji}}\n$$\n这个方程是细致平衡对 TST 参数施加的基本约束。如果我们现在强制执行微观可逆性原则，$E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$，指数项会消去，留下对尝试频率的约束：\n$$\n\\nu_{ij} = \\nu_{ji}\n$$\n因此，要构建一个同时满足这两个原则的物理有效模型，我们必须确保对于每一对连接的状态 $(i,j)$，存在单一的鞍点能量 $E^{\\ddagger}_{ij}=E^{\\ddagger}_{ji}$ 和单一的尝试频率 $\\nu_{ij}=\\nu_{ji}$。\n\n问题从正向和反向的角度为这些参数提供了可能不一致的“建议值”。任务是从这些建议值中构建一组一致的参数。对于每个最近邻对 $(i, j=(i+1)\\bmod N)$：\n\n-   **鞍点能量构建**：问题提供了一个正向势垒建议值 $b^{\\mathrm{fwd}}_i$ 和一个反向势垒建议值 $b^{\\mathrm{bwd}}_i$。这对应于两个关于绝对鞍点能量的建议值：\n    -   正向建议值：$E^{\\ddagger, \\mathrm{fwd}}_{ij} = E_i + b^{\\mathrm{fwd}}_i$\n    -   反向建议值：$E^{\\ddagger, \\mathrm{bwd}}_{ji} = E_j + b^{\\mathrm{bwd}}_i$\n    为了满足 $E^{\\ddagger}_{ij} = E^{\\ddagger}_{ji}$，我们必须协调这两个值。一个物理上对称且稳健的选择是两个建议绝对能量的算术平均值。让我们将状态对 $(i,j)$ 的单一鞍点表示为 $E^{\\ddagger}_{i,(i+1)\\%N}$：\n    $$\n    E^{\\ddagger}_{i,(i+1)\\%N} = \\frac{1}{2} \\left[ (E_i + b^{\\mathrm{fwd}}_i) + (E_{(i+1)\\%N} + b^{\\mathrm{bwd}}_i) \\right]\n    $$\n\n-   **尝试频率构建**：问题提供了一个正向尝试频率建议值 $\\nu^{\\mathrm{fwd}}_i$ 和一个反向建议值 $\\nu^{\\mathrm{bwd}}_i$。为了满足 $\\nu_{ij}=\\nu_{ji}$，我们必须再次协调这两个值。对于在底层统计理论中以乘法方式组合的速率和频率，几何平均值是合适的平均选择。我们将状态对 $(i,j)$ 的单一尝试频率定义为：\n    $$\n    \\nu_{i,(i+1)\\%N} = \\sqrt{\\nu^{\\mathrm{fwd}}_i \\nu^{\\mathrm{bwd}}_i}\n    $$\n\n有了这些构建的对称参数，我们可以为每对 $(i, j=(i+1)\\bmod N)$ 定义最终一致的正向和反向速率：\n-   正向速率：$k_{i,j} = \\nu_{i,j} \\exp\\left( - \\frac{E^{\\ddagger}_{i,j} - E_i}{k_{\\mathrm{B}} T} \\right)$\n-   反向速率：$k_{j,i} = \\nu_{i,j} \\exp\\left( - \\frac{E^{\\ddagger}_{i,j} - E_j}{k_{\\mathrm{B}} T} \\right)$\n根据构建方法，这些速率将满足细致平衡条件。数值任务是为每对状态计算残差 $|\\pi_i k_{i,j} - \\pi_j k_{j,i}|$，该值在浮点精度范围内应为零，并报告其最大值。\n\n每个测试用例的算法如下：\n1.  定义常数 $k_{\\mathrm{B}}$ 并计算 $\\beta = 1/(k_{\\mathrm{B}}T)$。\n2.  为速率 $k_{ij}$ 初始化一个空矩阵。\n3.  对于从 $0$ 到 $N-1$ 的每个位点 $i$：\n    a. 确定邻居 $j = (i+1) \\bmod N$。\n    b. 使用建议值的算术平均值构建对称的鞍点能量 $E^{\\ddagger}_{i,j}$。\n    c. 使用建议值的几何平均值构建对称的尝试频率 $\\nu_{i,j}$。\n    d. 使用这些构建的参数计算正向速率 $k_{ij}$ 和反向速率 $k_{ji}$，并存储它们。\n4.  计算归一化的玻尔兹曼分布 $\\pi_i = \\exp(-\\beta E_i) / \\sum_k \\exp(-\\beta E_k)$。\n5.  初始化 $r_{\\max} = 0$。\n6.  对于从 $0$ 到 $N-1$ 的每个位点 $i$：\n    a. 确定邻居 $j=(i+1)\\bmod N$。\n    b. 计算残差 $r = |\\pi_i k_{ij} - \\pi_j k_{ji}|$。\n    c. 更新 $r_{\\max} = \\max(r_{\\max}, r)$。\n7.  该用例的最终结果是 $r_{\\max}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing a consistent Markov chain generator\n    and verifying detailed balance numerically for several test cases.\n    \"\"\"\n    \n    # Define the Boltzmann constant in eV/K.\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 4,\n            \"E\": np.array([0.00, 0.05, 0.10, 0.20]),\n            \"b_fwd\": np.array([0.40, 0.45, 0.50, 0.60]),\n            \"b_bwd\": np.array([0.40, 0.45, 0.50, 0.60]),\n            \"nu_fwd\": np.array([1.0e13, 1.0e13, 1.0e13, 1.0e13]),\n            \"nu_bwd\": np.array([1.0e13, 1.0e13, 1.0e13, 1.0e13]),\n            \"T\": 300.0\n        },\n        # Case 2\n        {\n            \"N\": 5,\n            \"E\": np.array([0.00, 0.02, 0.08, 0.04, 0.10]),\n            \"b_fwd\": np.array([0.35, 0.37, 0.42, 0.40, 0.45]),\n            \"b_bwd\": np.array([0.33, 0.39, 0.41, 0.43, 0.44]),\n            \"nu_fwd\": np.array([1.0e13, 2.0e13, 0.5e13, 1.5e13, 1.0e13]),\n            \"nu_bwd\": np.array([0.8e13, 1.8e13, 0.7e13, 1.2e13, 0.9e13]),\n            \"T\": 350.0\n        },\n        # Case 3\n        {\n            \"N\": 3,\n            \"E\": np.array([0.00, 0.10, 0.20]),\n            \"b_fwd\": np.array([1.00, 0.90, 1.10]),\n            \"b_bwd\": np.array([1.00, 0.90, 1.10]),\n            \"nu_fwd\": np.array([1.0e13, 1.0e13, 1.0e13]),\n            \"nu_bwd\": np.array([1.0e13, 1.0e13, 1.0e13]),\n            \"T\": 300.0\n        },\n        # Case 4\n        {\n            \"N\": 4,\n            \"E\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"b_fwd\": np.array([0.25, 0.30, 0.28, 0.27]),\n            \"b_bwd\": np.array([0.26, 0.29, 0.31, 0.24]),\n            \"nu_fwd\": np.array([1.0e13, 1.2e13, 0.9e13, 1.1e13]),\n            \"nu_bwd\": np.array([0.8e13, 1.3e13, 1.0e13, 1.2e13]),\n            \"T\": 400.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        E = case[\"E\"]\n        b_fwd = case[\"b_fwd\"]\n        b_bwd = case[\"b_bwd\"]\n        nu_fwd = case[\"nu_fwd\"]\n        nu_bwd = case[\"nu_bwd\"]\n        T = case[\"T\"]\n\n        # Calculate thermal energy in eV\n        kT = k_B * T\n\n        # The rate matrix k_matrix will store the off-diagonal elements of the generator Q.\n        k_matrix = np.zeros((N, N))\n\n        for i in range(N):\n            j = (i + 1) % N\n\n            # Construct the single, symmetric saddle energy E_saddle for the pair (i,j)\n            # by taking the arithmetic mean of the suggested absolute saddle energies.\n            suggested_fwd_saddle = E[i] + b_fwd[i]\n            suggested_bwd_saddle = E[j] + b_bwd[i]\n            E_saddle = 0.5 * (suggested_fwd_saddle + suggested_bwd_saddle)\n\n            # Construct the single, symmetric attempt frequency nu_sym for the pair (i,j)\n            # by taking the geometric mean of the suggested frequencies.\n            nu_sym = np.sqrt(nu_fwd[i] * nu_bwd[i])\n\n            # Calculate the forward rate k_ij (i -> j)\n            activation_energy_fwd = E_saddle - E[i]\n            k_ij = nu_sym * np.exp(-activation_energy_fwd / kT)\n            \n            # Calculate the backward rate k_ji (j -> i)\n            activation_energy_bwd = E_saddle - E[j]\n            k_ji = nu_sym * np.exp(-activation_energy_bwd / kT)\n\n            k_matrix[i, j] = k_ij\n            k_matrix[j, i] = k_ji\n        \n        # Calculate the normalized Boltzmann equilibrium distribution pi.\n        pi_unnorm = np.exp(-E / kT)\n        partition_func = np.sum(pi_unnorm)\n        pi = pi_unnorm / partition_func\n\n        # Calculate the maximum absolute detailed-balance residual.\n        max_residual = 0.0\n        for i in range(N):\n            j = (i + 1) % N\n            residual = np.abs(pi[i] * k_matrix[i, j] - pi[j] * k_matrix[j, i])\n            if residual > max_residual:\n                max_residual = residual\n        \n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    # The results should be nearly zero due to the construction method.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3358266"}, {"introduction": "现在，我们从离散状态空间的KMC方法过渡到像过渡路径采样（TPS）这样的连续路径空间方法。KMC非常适合模拟长时标动力学，而TPS则专门设计用于聚焦于稀有的过渡事件本身。本练习深入探讨了TPS算法的核心：“打靶移动”（shooting move）[@problem_id:3358213]。您将为一个连续系统实现这一移动并计算其接受概率，从而深入理解如何生成和接受新的反应路径。", "problem": "本题要求您实现一个完整的、确定性的计算，用于计算在一维过阻尼朗之万过程中，过渡路径采样（TPS）中的单次打靶移动的接受概率。其目标是，通过算法计算由引导打靶移动生成的提议路径的 Metropolis 接受概率。该移动会扰动一个时间片，并重用原始离散路径的高斯噪声增量。\n\n其物理和概率基础是过阻尼朗之万随机微分方程（SDE），其势能函数为 $U(x)$，扩散系数为 $D$，逆温度 $\\beta$ 指定为 $1$：\n- 该 SDE 为 $dx_t = b(x_t)\\,dt + \\sqrt{2D}\\,dW_t$，其中 $b(x) = -D\\,\\beta\\,U'(x)$。\n- 该过程通过时间步长为 $dt$ 的欧拉-丸山（Euler–Maruyama）格式进行离散化，因此对于一条路径 $\\{x_0, x_1, \\dots, x_T\\}$，\n  $$x_{t+1} = x_t + b(x_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t,$$\n  其中每个 $w_t$ 都是一个标准正态变量。\n\n在路径系综中，路径概率密度（相对于维纳测度）可以用离散的 Onsager–Machlup 泛函表示，\n$$\\mathcal{S}[x_0,\\dots,x_T] = \\sum_{t=0}^{T-1}\\left[\\frac{\\left(x_{t+1}-x_t-b(x_t)\\,dt\\right)^2}{4D\\,dt} + \\frac{1}{2}\\,b'(x_t)\\,dt\\right],$$\n其中 $b'(x) = \\frac{db(x)}{dx}$。对于提议的新路径，其 Metropolis–Hastings 接受概率由路径空间中相对于此权重的细致平衡条件确定。\n\n请实现以下引导打靶移动，并根据 Metropolis 规则计算其接受概率：\n- 给定一条原始离散路径 $\\{x_0,\\dots,x_T\\}$、一个微扰幅度 $\\sigma$、一个打靶时间索引 $s\\in\\{0,1,\\dots,T\\}$ 以及一个定义踢动 $\\delta = \\sigma\\,z$ 的标量 $z$，通过以下步骤生成一条提议路径 $\\{x'_0,\\dots,x'_T\\}$：\n  1. 使用公式从原始路径计算高斯噪声增量\n     $$w_t = \\frac{x_{t+1}-x_t-b(x_t)\\,dt}{\\sqrt{2D\\,dt}},\\quad t=0,\\dots,T-1.$$\n  2. 在打靶索引处施加踢动：$x'_s = x_s + \\delta$。\n  3. 对于 $t=s,\\dots,T-1$，使用相同的 $w_t$ 向前传播：\n     $$x'_{t+1} = x'_t + b(x'_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t.$$\n  4. 对于 $t=s-1,\\dots,0$，通过求解方程中的 $x'_t$ 来向后传播：\n     $$x'_{t+1} = x'_t + b(x'_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t.$$\n     对于每个 $t$，这是一个一维非线性方程，必须通过数值方法高精度求解。您可以假设函数 $f(x) = x + b(x)\\,dt + \\sqrt{2D\\,dt}\\,w_t - x'_{t+1}$ 是光滑的，其导数为 $f'(x) = 1 + b'(x)\\,dt$，并且可以通过稳健的求根方法（如带线搜索的牛顿法）求解。\n\n- 定义过渡路径端点的区域是实线上的集合 $A$ 和 $B$。对于本问题，取 $A = \\{x \\mid x \\le -1\\}$ 和 $B = \\{x \\mid x \\ge 1\\}$。一条有效的过渡路径必须满足 $x_0 \\in A$ 和 $x_T \\in B$。如果提议的路径违反了这些端点约束，其接受概率为 $0$。\n\n- 接受概率必须使用 Metropolis–Hastings 规则计算，该规则在上述引导提议和 Onsager–Machlup 泛函 $\\mathcal{S}[\\cdot]$ 下与路径空间中的细致平衡相一致。您必须考虑到提议在 $\\delta$ 上是对称的，并且使用与原始路径相同的高斯噪声 $w_t$。\n\n势和漂移：\n- 使用双阱势\n  $$U(x) = \\frac{x^4}{4}-\\frac{x^2}{2},\\quad U'(x)=x^3-x.$$\n- 使用 $\\beta = 1$，并将漂移及其导数定义为\n  $$b(x) = -D\\,U'(x) = D\\,(x - x^3),\\quad b'(x) = D\\,(1-3x^2).$$\n\n数值和算法要求：\n- 所有计算都必须使用浮点运算完成。\n- 对于向后传播，使用稳健的求根方法，根条件的收敛容差（绝对值）不弱于 $10^{-10}$。\n- 如果在合理的迭代次数上限内根不收敛，您可以将此移动视为被拒绝（接受概率为 $0$），或者实现一个带保护的牛顿法；您的实现必须是确定性的，并且不得依赖任何随机数生成。\n- 输出不需要物理单位。\n- 不使用角度。\n- 不使用百分比。\n\n测试套件：\n- 程序必须按顺序计算以下四种情况的接受概率。每种情况都指定了路径、扩散系数、时间步长、打靶索引、微扰幅度以及标量 $z$。\n\n  情况1（顺利路径）：\n  - 路径：$[-1.5,\\,-0.7175,\\,0.1448,\\,0.7629,\\,1.1609,\\,1.2029]$\n  - $D = 0.5$, $dt = 0.05$\n  - 打靶索引 $s = 2$\n  - $\\sigma = 0.2$, $z = 1.0$\n\n  情况2（预期违反约束）：\n  - 路径：$[-1.5,\\,-0.7175,\\,0.1448,\\,0.7629,\\,1.1609,\\,1.2029]$\n  - $D = 0.5$, $dt = 0.05$\n  - 打靶索引 $s = 3$\n  - $\\sigma = 1.0$, $z = 5.0$\n\n  情况3（零微扰边界情况）：\n  - 路径：$[-1.5,\\,-0.7175,\\,0.1448,\\,0.7629,\\,1.1609,\\,1.2029]$\n  - $D = 0.5$, $dt = 0.05$\n  - 打靶索引 $s = 1$\n  - $\\sigma = 0.0$, $z = 0.0$\n\n  情况4（内部打靶的短路径）：\n  - 路径：$[-1.2,\\,-0.6,\\,1.0]$\n  - $D = 0.5$, $dt = 0.05$\n  - 打靶索引 $s = 1$\n  - $\\sigma = 0.05$, $z = 1.0$\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含四个接受概率，顺序与测试用例相同，格式为方括号括起来的逗号分隔列表。每个概率必须打印为小数点后保留八位的小数。例如，输出可能如下所示\n  $$[0.73123456,0.00000000,1.00000000,0.84561234].$$", "solution": "该问题要求计算应用于一维过阻尼朗之万过程的过渡路径采样（TPS）中，引导打靶移动的 Metropolis 接受概率。解决方案包括从第一性原理推导接受概率，然后实现确定性算法为给定的测试用例计算该概率。\n\n系统的状态是一条离散化路径 $x = \\{x_0, x_1, \\dots, x_T\\}$，根据欧拉-丸山（Euler-Maruyama）格式演化：\n$$x_{t+1} = x_t + b(x_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t$$\n其中 $b(x) = -D\\beta U'(x)$ 是漂移，$D$ 是扩散系数，$dt$ 是时间步长，$w_t \\sim \\mathcal{N}(0,1)$ 是独立的标准正态变量。对于本问题，$\\beta=1$。\n\n系综中一条路径的概率密度与 $\\exp(-\\mathcal{S}[x])$ 成正比，其中 $\\mathcal{S}[x]$ 是离散的 Onsager–Machlup 作用量：\n$$\\mathcal{S}[x] = \\sum_{t=0}^{T-1}\\left[\\frac{\\left(x_{t+1}-x_t-b(x_t)\\,dt\\right)^2}{4D\\,dt} + \\frac{1}{2}\\,b'(x_t)\\,dt\\right]$$\n第一项可以使用噪声增量 $w_t = \\frac{x_{t+1}-x_t-b(x_t)\\,dt}{\\sqrt{2D\\,dt}}$ 重写，得到 $\\frac{w_t^2}{2}$。第二项 $\\frac{1}{2}b'(x_t)dt$ 是 Itô-Stratonovich 校正项（从噪声坐标到路径坐标的变量变换产生的雅可比项），确保路径概率被正确加权。\n\n从旧路径 $x$ 到新路径 $x'$ 的移动的 Metropolis-Hastings 接受概率为：\n$$ P_{\\text{acc}}(x \\to x') = \\min\\left(1, \\frac{\\pi(x') g(x' \\to x)}{\\pi(x) g(x \\to x')}\\right) $$\n其中 $\\pi(x) \\propto \\exp(-\\mathcal{S}[x])$ 是目标概率，$g$ 是提议概率。\n\n具体的“引导”打靶移动定义如下：\n1. 选择一个打靶点 $s \\in \\{0, \\dots, T\\}$ 和一个微扰 $\\delta$。\n2. 从旧路径 $x$ 计算噪声增量 $\\{w_t\\}$。\n3. 通过设置 $x'_s = x_s + \\delta$ 并使用*相同*的噪声序列 $\\{w_t\\}$ 从该点向前和向后传播来生成新路径 $x'$。传播规则是：\n   - 向前 ($t \\ge s$): $x'_{t+1} = x'_t + b(x'_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t$\n   - 向后 ($t  s$): $x'_{t+1} = x'_t + b(x'_t)\\,dt + \\sqrt{2D\\,dt}\\,w_t$\n\n此提议的一个关键特性是，新路径的噪声序列 $w'_t = \\frac{x'_{t+1}-x'_t-b(x'_t)\\,dt}{\\sqrt{2D\\,dt}}$ 与原始噪声序列 $w_t$ 相同。这意味着从 $x'$ 到 $x$ 的逆向移动，将需要在相同的打靶点 $s$ 施加一个 $-\\delta$ 的踢动，并会使用 $x'$ 的噪声序列，即 $\\{w_t\\}$。如果选择踢动 $\\delta$ 的概率与选择 $-\\delta$ 的概率相同（如问题所暗示的，是一个对称分布），那么提议机制就是对称的：$g(x \\to x') = g(x' \\to x)$。接受概率则简化为 Metropolis 形式：\n$$ P_{\\text{acc}}(x \\to x') = \\min\\left(1, \\frac{\\pi(x')}{\\pi(x)}\\right) = \\min\\left(1, e^{-(\\mathcal{S}[x'] - \\mathcal{S}[x])}\\right) = \\min\\left(1, e^{-\\Delta\\mathcal{S}}\\right) $$\n\n现在，我们来计算作用量的变化，$\\Delta\\mathcal{S} = \\mathcal{S}[x'] - \\mathcal{S}[x]$：\n$$ \\Delta\\mathcal{S} = \\sum_{t=0}^{T-1}\\left[\\frac{(w'_t)^2 - w_t^2}{2} + \\frac{1}{2}(b'(x'_t) - b'(x_t))dt\\right] $$\n由于根据构造，对于所有 $t$ 都有 $w'_t = w_t$，所以和式中的第一项为零。这只留下来自雅可比项的贡献：\n$$ \\Delta\\mathcal{S} = \\frac{dt}{2} \\sum_{t=0}^{T-1} (b'(x'_t) - b'(x_t)) $$\n这个简化的表达式就是我们需要计算的。\n\n总体算法如下：\n1.  给定一条旧路径 $x=\\{x_0, ..., x_T\\}$ 以及参数 $D$、$dt$、$s$、$\\sigma$、$z$。势为 $U(x) = \\frac{x^4}{4}-\\frac{x^2}{2}$，因此漂移为 $b(x) = D(x-x^3)$，其导数为 $b'(x) = D(1-3x^2)$。\n2.  使用公式 $w_t = (x_{t+1} - x_t - b(x_t) dt) / \\sqrt{2Ddt}$ 从旧路径 $x$ 计算噪声序列 $\\{w_t\\}_{t=0}^{T-1}$。\n3.  生成新路径 $x'$。为 $x'$ 初始化一个数组。\n    a. 施加踢动：$\\delta = \\sigma z$，所以 $x'_s = x_s + \\delta$。\n    b. 向前传播，对于 $t = s, \\dots, T-1$：$x'_{t+1} = x'_t + b(x'_t) dt + \\sqrt{2Ddt} w_t$。\n    c. 向后传播，对于 $t = s-1, \\dots, 0$。对于每个 $t$，求解非线性方程以得到 $x'_t$：\n       $$x'_{t+1} = x'_t + b(x'_t) dt + \\sqrt{2Ddt} w_t$$\n       这是一个针对函数 $f(\\xi) = \\xi + b(\\xi)dt + \\sqrt{2Ddt}w_t - x'_{t+1} = 0$ 的求根问题。我们使用牛顿法，初始猜测为 $\\xi_0 = x_t$。更新规则是 $\\xi_{k+1} = \\xi_k - f(\\xi_k)/f'(\\xi_k)$，其中 $f'(\\xi) = 1 + b'(\\xi)dt$。迭代直到 $|f(\\xi)|  10^{-10}$。如果收敛失败，则拒绝该移动（$P_{\\text{acc}} = 0$）。\n4.  检查端点约束。一条有效的过渡路径必须从区域 $A=\\{x \\mid x \\le -1\\}$ 开始，在区域 $B=\\{x \\mid x \\ge 1\\}$ 结束。如果 $x'_0 > -1$ 或 $x'_T  1$，则提议的路径无效，且 $P_{\\text{acc}} = 0$。\n5.  如果新路径有效，计算作用量的变化 $\\Delta\\mathcal{S} = \\frac{dt}{2} \\sum_{t=0}^{T-1} (b'(x'_t) - b'(x_t))$。\n6.  接受概率为 $P_{\\text{acc}} = \\min(1, \\exp(-\\Delta\\mathcal{S}))$。对于 $\\delta=0$ 的情况，$x'=x$，$\\Delta\\mathcal{S}=0$，且 $P_{\\text{acc}}=1$。\n\n对每个测试用例实施这个确定性过程，以获得所需的接受概率。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all given test cases.\n    \"\"\"\n\n    def b(x, D):\n        \"\"\"Calculates the drift term b(x) = D*(x - x^3).\"\"\"\n        return D * (x - x**3)\n\n    def b_prime(x, D):\n        \"\"\"Calculates the derivative of the drift term b'(x) = D*(1 - 3*x^2).\"\"\"\n        return D * (1 - 3 * x**2)\n\n    def compute_acceptance_probability(path_arr, D, dt, s, sigma, z):\n        \"\"\"\n        Computes the acceptance probability for a single shooting move.\n        \"\"\"\n        path = np.array(path_arr, dtype=float)\n        T = len(path) - 1\n\n        # Step 1: Recover the noise sequence from the original path.\n        w = np.zeros(T)\n        sqrt_2Ddt = np.sqrt(2 * D * dt)\n        if sqrt_2Ddt == 0:\n            return 0.0 # Avoid division by zero in deterministic case\n\n        for t in range(T):\n            w[t] = (path[t+1] - path[t] - b(path[t], D) * dt) / sqrt_2Ddt\n\n        # Step 2: Generate the proposed new path.\n        delta = sigma * z\n        new_path = np.zeros(T + 1)\n        \n        if not (0 = s = T):\n            # This case shouldn't occur with valid problem inputs.\n            return 0.0\n            \n        new_path[s] = path[s] + delta\n\n        # Step 2a: Forward propagation from the shooting point.\n        for t in range(s, T):\n            new_path[t+1] = new_path[t] + b(new_path[t], D) * dt + sqrt_2Ddt * w[t]\n\n        # Step 2b: Backward propagation from the shooting point.\n        try:\n            for t in range(s - 1, -1, -1):\n                x_tp1_prime = new_path[t+1]\n                const_term = sqrt_2Ddt * w[t]\n\n                # We need to find the root of f(xi) = 0, where:\n                # f(xi) = xi + b(xi)*dt + const_term - x_tp1_prime\n                f = lambda xi: xi + b(xi, D) * dt + const_term - x_tp1_prime\n                fprime = lambda xi: 1 + b_prime(xi, D) * dt\n                \n                # Use Newton's method for root-finding.\n                # Initial guess is the point from the original path.\n                x0_guess = path[t]\n                root = newton(f, x0_guess, fprime=fprime, tol=1e-12, maxiter=100, rtol=1e-12)\n\n                # Verify root condition as per problem statement\n                if abs(f(root)) > 1e-10:\n                    return 0.0 # Convergence did not meet root condition\n\n                new_path[t] = root\n        except RuntimeError:\n            # newton solver failed to converge. Reject the move.\n            return 0.0\n\n        # Step 3: Check endpoint constraints for the new path.\n        # A = {x | x = -1}, B = {x | x >= 1}\n        if not (new_path[0] = -1.0 and new_path[T] >= 1.0):\n            return 0.0\n\n        # Step 4: Calculate the change in the Onsager-Machlup action.\n        delta_S = 0.0\n        # The sum is over time slices t=0,...,T-1.\n        for t in range(T):\n            delta_S += b_prime(new_path[t], D) - b_prime(path[t], D)\n        delta_S *= (dt / 2.0)\n\n        # Step 5: Compute the final acceptance probability.\n        prob = min(1.0, np.exp(-delta_S))\n        \n        return prob\n\n    test_cases = [\n        # Case 1: Standard 'happy path' case\n        {'path_arr': [-1.5, -0.7175, 0.1448, 0.7629, 1.1609, 1.2029], 'D': 0.5, 'dt': 0.05, 's': 2, 'sigma': 0.2, 'z': 1.0},\n        # Case 2: Large perturbation, likely to violate constraints\n        {'path_arr': [-1.5, -0.7175, 0.1448, 0.7629, 1.1609, 1.2029], 'D': 0.5, 'dt': 0.05, 's': 3, 'sigma': 1.0, 'z': 5.0},\n        # Case 3: Zero perturbation, should yield acceptance probability of 1\n        {'path_arr': [-1.5, -0.7175, 0.1448, 0.7629, 1.1609, 1.2029], 'D': 0.5, 'dt': 0.05, 's': 1, 'sigma': 0.0, 'z': 0.0},\n        # Case 4: Short path with an interior shooting point\n        {'path_arr': [-1.2, -0.6, 1.0], 'D': 0.5, 'dt': 0.05, 's': 1, 'sigma': 0.05, 'z': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        probability = compute_acceptance_probability(**case)\n        results.append(f\"{probability:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3358213"}, {"introduction": "本练习旨在弥合“仅采样路径”与“计算物理可观测量（如反应速率）”之间的差距，并引入了“提交者概率”（committor probability）作为反应速率理论中的一个核心概念。这项高级练习展示了一种强大的协同作用：使用简短、快速的KMC模拟来估计提交者概率，然后将该估计值用作“控制变量”，从而显著减少更复杂的基于TPS的速率计算中的统计误差[@problem_id:3358229]。", "problem": "考虑一个一维生灭马尔可夫链，其离散状态为 $i \\in \\{0,1,\\dots,N\\}$，其演化过程中的前向和后向跃迁速率满足关于指定双阱势的细致平衡条件。设左亚稳盆为 $A = \\{0,1,\\dots,a\\}$，右亚稳盆为 $B = \\{b,b+1,\\dots,N\\}$，其中 $0  a  b  N$。定义分隔面为从状态 $a$ 到状态 $a+1$ 的单步跨越。能量景观是由一个以两个极小值点 $i_{\\mathrm{L}}$ 和 $i_{\\mathrm{R}}$ 为中心的四次多项式构成的双阱，其幅度由一个正常数 $\\alpha$ 控制。状态 $i$ 的势能为\n$$\nU(i) = \\alpha \\left(i - i_{\\mathrm{L}}\\right)^2 \\left(i - i_{\\mathrm{R}}\\right)^2,\n$$\n跃迁速率的构造旨在强制满足关于玻尔兹曼分布的细致平衡，其中无量纲逆温度被吸收到 $\\alpha$ 中，采用对称选择\n$$\nr_i^{+} = \\exp\\left(-\\frac{U(i+1) - U(i)}{2}\\right), \\quad r_i^{-} = \\exp\\left(-\\frac{U(i-1) - U(i)}{2}\\right),\n$$\n对于 $1 \\le i \\le N-1$，并设 $r_0^{-} = 0$ 和 $r_N^{+} = 0$。稳态分布为\n$$\n\\pi(i) = \\frac{\\exp\\left(-U(i)\\right)}{\\sum_{j=0}^{N} \\exp\\left(-U(j)\\right)}.\n$$\n定义提交函数 $q(i)$ 为从状态 $i$ 出发，动力学过程在到达盆 $A$ 之前先到达盆 $B$ 的概率。对于 $a  i  b$，提交函数满足后向方程\n$$\nr_i^{-} \\left[q(i-1) - q(i)\\right] + r_i^{+} \\left[q(i+1) - q(i)\\right] = 0,\n$$\n边界条件为 $q(i) = 0$ (对于 $i \\le a$) 和 $q(i) = 1$ (对于 $i \\ge b$)。\n\n过渡路径采样 (Transition Path Sampling, TPS) 生成从 $A$ 到 $B$ 的反应轨迹。一个常用的从 $A$ 到 $B$ 的反应速率常数估计量基于将速率分解为跨越分隔面的通量与给定出射穿越后提交到 $B$ 的概率的平均乘积。您的任务是使用一个控制变量来构造此反应速率的方差缩减估计量，该控制变量源于估计出射点提交函数的短动力学蒙特卡洛 (kMC) 脉冲。这里的 kMC 动力学简化为最近邻跳跃的随机行走，在状态 $i$ 时，跳到 $i+1$ 的概率为\n$$\np_i^{+} = \\frac{r_i^{+}}{r_i^{+} + r_i^{-}}, \\quad p_i^{-} = 1 - p_i^{+}.\n$$\n\n您必须从第一性原理出发：\n\n- 使用提交函数的定义和可逆马尔可夫链的性质，推导出反应速率常数关于跨越分隔面的稳态通量和在刚离开 $A$ 的状态下评估的提交函数的表达式。不要从任何现成的速率公式开始；从通量和首次通过概率的定义进行推导。\n- 设计一个基于 TPS 的估计量，其中每条路径通过从出射点 $i = a+1$ 开始并演化 kMC 动力学直到在 $A$ 或 $B$ 中被吸收来生成。令 $X$ 为采样的轨迹在到达 $A$ 之前先到达 $B$ 的指示函数。\n- 使用 $K$ 个独立的、从 $i = a+1$ 开始的短 kMC 脉冲来估计 $i = a+1$ 处的提交函数，这些脉冲运行直到它们到达 $A$ 或 $B$，从而得到无偏蒙特卡洛估计量 $Y$ 作为到达 $B$ 的脉冲所占的比例。将 $Y$ 作为控制变量嵌入到反应速率的 TPS 估计量中。使用控制变量形式 $X_{\\mathrm{cv}} = X - c\\,(Y - \\mu)$，其中系数 $c$ 通过在固定无偏性下最小化方差来优化选择，并且 $\\mu = \\mathbb{E}[Y]$ 必须等于在所选的 $i=a+1$ 初始状态分布下 $Y$ 的精确均值。\n- 通过求解后向方程得到精确的提交函数 $q(i)$，并计算其在 $i = a+1$ 处的值来计算 $\\mu$，然后根据单一出射点的选择进行适当的平均。使用此 $\\mu$ 来保证控制变量的无偏性。\n- 对于下面的每个测试用例，生成 $M$ 条 TPS 路径和相关的控制变量，计算普通和控制变量反应速率估计值，并报告它们的样本方差。所有量都是无单位的浮点数。每个测试用例中给定的随机种子必须能复现最终答案。\n\n测试套件包含三组参数。对于每种情况，系统参数由元组 $(N, i_{\\mathrm{L}}, i_{\\mathrm{R}}, \\alpha, a, b, M, K, \\text{seed})$ 给出。使用以下值：\n\n- 案例1（中等势垒，理想路径）：$(50, 10, 40, 2 \\times 10^{-5}, 12, 38, 8000, 8, 123)$。\n- 案例2（较高势垒，更稀有事件）：$(50, 10, 40, 4 \\times 10^{-5}, 12, 38, 12000, 8, 456)$。\n- 案例3（较低势垒，接近对称的提交概率）：$(50, 10, 40, 1 \\times 10^{-5}, 12, 38, 8000, 8, 789)$。\n\n对于每个测试用例：\n\n- 从第一性原理推导并计算在边缘 $i = a \\rightarrow i = a+1$ 处离开 $A$ 跨越分隔面的稳态通量。\n- 计算处于盆 $A$ 中的稳态概率，并与通量和提交函数结合以获得反应速率估计。\n- 从 $i = a+1$ 开始生成 $M$ 条 TPS 路径，并记录 $X$ 作为在到达 $A$ 之前先到达 $B$ 的指示函数。使用普通估计量估计反应速率并计算其均值的样本方差。\n- 对于每条采样路径，独立生成 $K$ 个从 $i = a+1$ 开始的 kMC 脉冲，以计算经验提交函数估计量 $Y$。计算 $i = a+1$ 处的精确提交函数并设 $\\mu$ 为此值。用根据联合样本凭经验确定的最优 $c$ 构建控制变量估计量，并计算其均值的样本方差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表应为每个测试用例包含一个子列表，每个子列表必须为 $[k_{\\mathrm{plain}}, k_{\\mathrm{cv}}, \\sigma^2_{\\mathrm{plain}}, \\sigma^2_{\\mathrm{cv}}]$ 的形式，其中 $k_{\\mathrm{plain}}$ 和 $k_{\\mathrm{cv}}$ 分别是普通和控制变量反应速率估计值，$\\sigma^2_{\\mathrm{plain}}$ 和 $\\sigma^2_{\\mathrm{cv}}$ 是它们对应的均值的样本方差。例如，您的输出必须类似于 $[[k_1^{\\mathrm{plain}},k_1^{\\mathrm{cv}},\\sigma^2_{1,\\mathrm{plain}},\\sigma^2_{1,\\mathrm{cv}}],[k_2^{\\mathrm{plain}},k_2^{\\mathrm{cv}},\\sigma^2_{2,\\mathrm{plain}},\\sigma^2_{2,\\mathrm{cv}}],[k_3^{\\mathrm{plain}},k_3^{\\mathrm{cv}},\\sigma^2_{3,\\mathrm{plain}},\\sigma^2_{3,\\mathrm{cv}}]]$，所有条目均为无单位的浮点数。不应打印其他文本。", "solution": "用户提供了有效的问题陈述。\n\n该问题要求估算一个双阱势上一维生灭过程的反应速率常数。估算将使用普通的蒙特卡洛方法和一种更高级的用于方差缩减的控制变量方法来执行。解决方案结合了解析推导、线性系统数值解和蒙特卡洛模拟。\n\n### 1. 反应速率常数的推导\n\n反应速率常数 $k_{A \\to B}$ 量化了从亚稳反应物盆 $A$ 到产物盆 $B$ 的跃迁速率。我们基于稳态通量的概念，从第一性原理推导其表达式。\n\n设系统处于由分布 $\\pi(i) = C \\exp(-U(i))$ 描述的稳态，其中 $C$ 是归一化常数。系统处于反应物盆 $A = \\{0, 1, \\dots, a\\}$ 的总概率为 $P_A = \\sum_{i=0}^{a} \\pi(i)$。\n\n反应事件（定义为从 $A$ 到 $B$ 且不返回 $A$ 的跃迁）的速率可以表示为离开 $A$ 的总轨迹通量与这些离开的轨迹提交到 $B$ 的概率的乘积。\n\n在这个一维系统中，离开盆 $A$ 的唯一出口是从状态 $i=a$到 $i=a+1$ 的跃迁。产生这种跃迁的稳态轨迹通量由处于状态 $a$ 的稳态概率与从 $a$ 出发的前向速率的乘积给出：\n$$\n\\Phi_{A \\to A^c} = \\pi(a) r_a^{+}\n$$\n其中 $A^c$ 是 $A$ 的补集。这里，$r_a^{+}$ 是从状态 $a$ 出发的前向跃迁速率。\n\n一旦轨迹穿过分隔面并到达状态 $a+1$，它可能会继续前往盆 $B$ 或返回盆 $A$。从状态 $i$ 开始的轨迹在返回 $A$ 之前到达盆 $B$ 的概率由提交函数 $q(i)$ 给出。因此，刚离开 $A$ 处于状态 $a+1$ 的轨迹发生反应并到达 $B$ 的概率是 $q(a+1)$。\n\n反应通量 $J_{A \\to B}$ 是离开 $A$ 的总通量乘以这个提交概率：\n$$\nJ_{A \\to B} = \\Phi_{A \\to A^c} \\cdot q(a+1) = \\pi(a) r_a^{+} q(a+1)\n$$\n速率常数 $k_{A \\to B}$ 定义为每个反应物状态 $A$ 中单位布居的反应通量。因此，\n$$\nk_{A \\to B} = \\frac{J_{A \\to B}}{P_A} = \\frac{\\pi(a) r_a^{+} q(a+1)}{\\sum_{i=0}^{a} \\pi(i)}\n$$\n此表达式构成了我们估计量的基础。量 $\\pi(i)$ 和 $r_a^{+}$ 仅依赖于势能 $U(i)$，可以直接计算。需要通过模拟估算的关键量是提交函数 $q(a+1)$。\n\n### 2. 精确提交函数的计算\n\n提交函数 $q(i)$ 可以通过求解其对中间状态 $i \\in \\{a+1, \\dots, b-1\\}$ 的后向主方程来精确确定。该方程反映了这样一个事实：从 $i$ 开始的轨迹，经过一步后将处于 $i-1$ 或 $i+1$，而 $i$ 处的提交函数值是这些相邻状态提交函数值的加权平均。对于连续时间马尔可夫链，这导致：\n$$\nr_i^{-} \\left[q(i-1) - q(i)\\right] + r_i^{+} \\left[q(i+1) - q(i)\\right] = 0\n$$\n这可以改写为：\n$$\nr_i^{-} q(i-1) - (r_i^{-} + r_i^{+}) q(i) + r_i^{+} q(i+1) = 0\n$$\n边界条件由盆地定义：任何始于 $A$ 的轨迹都已返回 $A$（因此其首先到达 $B$ 的概率为 $0$），任何始于 $B$ 的轨迹都已到达 $B$。\n$$\nq(i) = 0 \\quad \\text{for } i \\le a\n$$\n$$\nq(i) = 1 \\quad \\text{for } i \\ge b\n$$\n对于 $i = a+1, \\dots, b-1$ 的方程组构成了一个关于未知向量 $\\mathbf{q} = [q(a+1), \\dots, q(b-1)]^T$ 的三对角线性方程组。\n对于 $i = a+1$，方程为 $-(r_{a+1}^{-} + r_{a+1}^{+}) q(a+1) + r_{a+1}^{+} q(a+2) = 0$。\n对于 $i = b-1$，方程为 $r_{b-1}^{-} q(b-2) - (r_{b-1}^{-} + r_{b-1}^{+}) q(b-1) = -r_{b-1}^{+}$。\n这个系统可以被高效求解，以找到所有中间状态的提交函数的精确值，包括关键值 $q(a+1)$，我们将其表示为 $\\mu_q \\equiv q(a+1)$。\n\n### 3. 蒙特卡洛估算方案\n\n我们使用蒙特卡洛模拟来估算 $q(a+1)$。问题中描述的“TPS”方法涉及生成从出射点 $i=a+1$ 开始并根据 kMC 动力学演化的轨迹，直到它们被盆 $A$ 或 $B$ 吸收。\n\nkMC 动力学简化为一个离散时间随机行走，其中从状态 $i$ 出发，移动到 $i+1$ 的概率为 $p_i^{+} = r_i^{+} / (r_i^{+} + r_i^{-})$，移动到 $i-1$ 的概率为 $p_i^{-} = 1 - p_i^{+}$。\n\n对于从 $i=a+1$ 开始的 $M$ 条模拟路径中的每一条，我们记录一个指示变量 $X_m$：\n$$\nX_m = \\begin{cases} 1  \\text{如果路径 } m \\text{ 在 } A \\text{ 之前到达 } B \\\\ 0  \\text{如果路径 } m \\text{ 在 } B \\text{ 之前到达 } A \\end{cases}\n$$\n$X_m$ 的期望值恰好是起始点的提交函数，即 $\\mathbb{E}[X_m] = q(a+1)$。\n\n#### 3.1. 普通蒙特卡洛估计量\n\n$q(a+1)$ 的普通蒙特卡洛估计量是 $M$ 个路径结果的样本均值：\n$$\n\\hat{q}_{\\text{plain}} = \\frac{1}{M} \\sum_{m=1}^{M} X_m\n$$\n相应的速率常数估计为：\n$$\nk_{\\text{plain}} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)} \\cdot \\hat{q}_{\\text{plain}}\n$$\n\n#### 3.2. 控制变量估计量\n\n为了减少估计的方差，我们引入一个控制变量。对于每个主路径 $m$（它给了我们 $X_m$），我们生成 $K$ 个额外的独立短 kMC 脉冲。每个脉冲从 $i=a+1$ 开始并运行至吸收，产生结果 $Y_{m,k} \\in \\{0, 1\\}$。我们构成一个辅助变量 $Y_m$：\n$$\nY_m = \\frac{1}{K} \\sum_{k=1}^{K} Y_{m,k}\n$$\n$Y_m$ 是 $q(a+1)$ 的另一个独立估计量。其期望值为 $\\mathbb{E}[Y_m] = q(a+1)$。我们使用从后向方程计算出的精确值 $\\mu_q = q(a+1)$。\n\n$q(a+1)$ 的控制变量估计量构造如下：\n$$\n\\hat{q}_{\\mathrm{cv}} = \\frac{1}{M} \\sum_{m=1}^{M} \\left[ X_m - c(Y_m - \\mu_q) \\right]\n$$\n对于任何 $c$ 的选择，这个估计量都是无偏的，因为 $\\mathbb{E}[Y_m - \\mu_q] = 0$。通过选择最优系数可以最小化方差：\n$$\nc^* = \\frac{\\mathrm{Cov}(X, Y)}{\\mathrm{Var}(Y)}\n$$\n在实践中，$c^*$ 从样本中估计：\n$$\n\\hat{c}^* = \\frac{\\sum_{m=1}^{M} (X_m - \\bar{X})(Y_m - \\bar{Y})}{\\sum_{m=1}^{M} (Y_m - \\bar{Y})^2}\n$$\n其中 $\\bar{X}$ 和 $\\bar{Y}$ 是样本均值。由此，$q(a+1)$ 的最终控制变量估计量为：\n$$\n\\hat{q}_{\\mathrm{cv}} = \\bar{X} - \\hat{c}^*(\\bar{Y} - \\mu_q)\n$$\n相应的速率常数估计为：\n$$\nk_{\\mathrm{cv}} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)} \\cdot \\hat{q}_{\\mathrm{cv}}\n$$\n\n### 4. 均值的方差\n\n通过估计量的均值的样本方差来比较它们的性能。对于基于 $M$ 个样本 $Z_m$ 的估计量 $\\hat{\\theta}$，均值的方差估计为：\n$$\n\\sigma^2_{\\hat{\\theta}} = \\frac{s_Z^2}{M} = \\frac{1}{M(M-1)}\\sum_{m=1}^{M}(Z_m - \\bar{Z})^2\n$$\n对于普通估计量，样本为 $Z_m = X_m$。对于控制变量估计量，样本为 $Z_m = X_m - \\hat{c}^*(Y_m - \\mu_q)$。速率常数估计的方差 $\\sigma^2_{\\text{plain}}$ 和 $\\sigma^2_{\\text{cv}}$ 是通过将 $\\hat{q}_{\\text{plain}}$ 和 $\\hat{q}_{\\text{cv}}$ 的方差乘以预因子 $\\mathcal{F} = \\frac{\\pi(a) r_a^{+}}{\\sum_{i=0}^{a} \\pi(i)}$ 的平方得到的。如果 $\\sigma^2_{\\mathrm{cv}}  \\sigma^2_{\\mathrm{plain}}$，则控制变量方法是有效的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, calculating reactive rate constants\n    and their variances using plain Monte Carlo and a control variate method.\n    \"\"\"\n    test_cases = [\n        # (N, i_L, i_R, alpha, a, b, M, K, seed)\n        (50, 10, 40, 2e-5, 12, 38, 8000, 8, 123),\n        (50, 10, 40, 4e-5, 12, 38, 12000, 8, 456),\n        (50, 10, 40, 1e-5, 12, 38, 8000, 8, 789),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, iL, iR, alpha, a, b, M, K, seed = case\n        \n        # 1. System setup\n        states = np.arange(N + 1)\n        # Potential energy U(i)\n        U = alpha * ((states - iL)**2) * ((states - iR)**2)\n        \n        # Transition rates r_i^+, r_i^-\n        # Note: rates_fwd[i] = r_i^+, rates_bwd[i] = r_i^-\n        rates_fwd = np.zeros(N + 1)\n        rates_bwd = np.zeros(N + 1)\n        \n        # Symmetric choice for rates\n        rates_fwd[:N] = np.exp(-(U[1:] - U[:-1]) / 2.0)\n        rates_bwd[1:] = np.exp(-(U[:-1] - U[1:]) / 2.0)\n        \n        # Stationary distribution pi(i)\n        # Numerical stability by shifting potential\n        U_shifted = U - np.min(U)\n        pi_unnormalized = np.exp(-U_shifted)\n        pi = pi_unnormalized / np.sum(pi_unnormalized)\n\n        # 2. Exact committor q(i)\n        # Solve the tridiagonal system for q(i) for i in {a+1, ..., b-1}\n        num_unknowns = b - a - 1\n        # Scipy's solve_banded expects matrix in a special format (l, u)\n        # l=1 (sub-diagonal), u=1 (super-diagonal)\n        ab = np.zeros((3, num_unknowns))\n        d = np.zeros(num_unknowns)\n        \n        # Main diagonal\n        ab[1, :] = -(rates_bwd[a+1:b] + rates_fwd[a+1:b])\n        # Super-diagonal (upper)\n        ab[0, 1:] = rates_fwd[a+1:b-1]\n        # Sub-diagonal (lower)\n        ab[2, :-1] = rates_bwd[a+2:b]\n        \n        # RHS vector for boundary conditions\n        # q(a)=0 contributes nothing\n        # q(b)=1 contributes at i=b-1\n        d[-1] = -rates_fwd[b-1] # from r_{b-1}^+ * q(b)\n        \n        q_intermediate = solve_banded((1, 1), ab, d)\n        \n        q = np.zeros(N + 1)\n        q[b:] = 1.0\n        q[a+1:b] = q_intermediate\n        \n        mu_q = q[a+1]\n\n        # 3. Rate prefactor F\n        flux_A_out = pi[a] * rates_fwd[a]\n        pop_A = np.sum(pi[:a+1])\n        F_prefactor = flux_A_out / pop_A\n\n        # 4. Monte Carlo simulation\n        rng = np.random.default_rng(seed)\n        \n        # Pre-calculate jump probabilities\n        p_plus = np.zeros(N + 1)\n        # Denominator can be zero at boundaries if a rate is zero. Handle safely.\n        rate_sum = rates_fwd + rates_bwd\n        # Only interior states are visited in the sim\n        valid_idx = (rate_sum > 0)  (np.arange(N + 1) > a)  (np.arange(N + 1)  b)\n        p_plus[valid_idx] = rates_fwd[valid_idx] / rate_sum[valid_idx]\n\n        def run_kmc_path(start_i):\n            i = start_i\n            while a  i  b:\n                if rng.random()  p_plus[i]:\n                    i += 1\n                else:\n                    i -= 1\n            return 1 if i >= b else 0\n\n        X_samples = np.zeros(M)\n        Y_samples = np.zeros(M)\n\n        for m in range(M):\n            # Main path for estimator X\n            X_samples[m] = run_kmc_path(a + 1)\n            \n            # K bursts for control variate Y\n            Y_m_bursts = np.zeros(K)\n            for k in range(K):\n                Y_m_bursts[k] = run_kmc_path(a + 1)\n            Y_samples[m] = np.mean(Y_m_bursts)\n\n        # 5. Analysis\n        # Plain estimator\n        q_hat_plain = np.mean(X_samples)\n        k_plain = F_prefactor * q_hat_plain\n        # Variance of the mean\n        var_q_plain = np.var(X_samples, ddof=1) / M\n        sigma2_plain = (F_prefactor**2) * var_q_plain\n\n        # Control variate estimator\n        var_Y = np.var(Y_samples, ddof=1)\n        if var_Y > 1e-12:\n            cov_XY = np.cov(X_samples, Y_samples, ddof=1)[0, 1]\n            c_hat = cov_XY / var_Y\n        else: # Handle case of zero variance in Y\n            c_hat = 0.0\n\n        q_hat_cv = q_hat_plain - c_hat * (np.mean(Y_samples) - mu_q)\n        k_cv = F_prefactor * q_hat_cv\n        \n        # Calculate samples for CV estimator to find its variance\n        Z_samples = X_samples - c_hat * (Y_samples - mu_q)\n        var_q_cv = np.var(Z_samples, ddof=1) / M\n        sigma2_cv = (F_prefactor**2) * var_q_cv\n\n        results.append([k_plain, k_cv, sigma2_plain, sigma2_cv])\n\n    # Format the output as specified\n    sub_lists = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(sub_lists)}]\")\n\nsolve()\n```", "id": "3358229"}]}