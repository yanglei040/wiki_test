{"hands_on_practices": [{"introduction": "编译优化并非总能带来纯粹的收益，它们常常涉及一种成本与另一种成本之间的权衡。这个练习 [@problem_id:3674633] 提供了一个具体的数学模型，让你量化一个经典的权衡：循环展开（loop unrolling）带来的好处（减少控制开销）与其主要代价（增加寄存器压力）。通过计算“盈亏平衡点”，你将学会编译器如何基于数据做出决策，以选择最佳的优化策略。", "problem": "考虑一个计算数组线性变换的简单循环，编译器的作用包括选择变换（例如循环展开）和管理寄存器分配以最小化执行时间。每个原始迭代的循环体需要一定数量的活动临时变量，而机器的寄存器文件是有限的。当编译器以因子 $u$ 展开循环时，一些临时变量在 $u$ 个融合的迭代中共享，而另一些则是每次迭代独有的。如果同时活动值的总数超过可用寄存器 $R$ 的数量，编译器的寄存器分配器必须生成到内存的溢出（spill），每次溢出都会产生额外的周期成本 $s$。\n\n使用以下科学上合理且自洽的模型和参数：\n\n- 每个原始迭代的基本计算成本为 $c$ 个周期。在此场景中，$c = 20$。\n- 每个原始迭代的控制和地址更新开销为 $h$ 个周期。在此场景中，$h = 30$。\n- 可用寄存器数量为 $R = 13$。\n- 在一个 $u$ 倍展开块中共享的即时活动临时变量为 $L_{\\text{shared}} = 5$（例如，循环索引、$A$、$B$、$C$ 的基指针，以及一个循环不变量标量）。\n- 每个原始迭代独有的即时活动临时变量为 $L_{\\text{iter}} = 3$（例如，从 $B[i]$ 和 $C[i]$ 加载的值，以及一个中间乘积 $C[i]\\times D$）。\n- 展开块峰值时同时活动的临时变量总数建模为 $L(u) = L_{\\text{shared}} + u\\,L_{\\text{iter}}$。\n- 如果 $L(u) > R$，则溢出值的数量为 $S(u) = L(u) - R$，否则 $S(u) = 0$。\n- 溢出成本参数 $s$ 表示每个溢出值在每个 $u$ 次迭代块中的总周期惩罚（例如，该溢出值的一次加载和一次存储的组合）。那么，每个原始迭代的溢出惩罚为 $\\frac{s\\,S(u)}{u}$。\n- 在展开因子 $u$ 下，每个原始迭代的平均周期数建模为\n$$\nC(u) \\;=\\; c \\;+\\; \\frac{h}{u} \\;+\\; \\frac{s\\,S(u)}{u}.\n$$\n\n在此设置下，展开因子 $u=2$ 产生 $L(2) = 5 + 2\\cdot 3 = 11 \\leq 13$，因此 $S(2)=0$。展开因子 $u=3$ 产生 $L(3) = 5 + 3\\cdot 3 = 14  13$，因此 $S(3)=14-13=1$。\n\n使用上述模型，确定使编译器在展开因子 $u=2$（无溢出）和展开因子 $u=3$（每块有一次溢出）之间无差异的盈亏平衡溢出成本 $s^{\\star}$（以周期为单位），即满足 $C(2)=C(3)$ 的 $s$ 值。最终答案以周期表示。无需四舍五入。", "solution": "编译器的作用包括将源程序转换为目标机器代码，同时在机器约束下优化性能。两个相关的基本事实是：\n\n- 循环展开通过将分支和索引更新工作分摊到 $u$ 次迭代中来减少控制流开销，从而为每个原始迭代的成本贡献了 $\\frac{h}{u}$ 这一项。\n- 寄存器分配受限于大小为 $R$ 的有限寄存器文件。如果同时活动的临时变量的峰值数量 $L(u)$ 超过 $R$，则超出部分 $S(u)=\\max(0,L(u)-R)$ 必须溢出到内存中，每个溢出的值都会带来额外的周期惩罚。在所述模型下，每个原始迭代的溢出惩罚为 $\\frac{s\\,S(u)}{u}$，因为 $s$ 是针对每个包含 $u$ 次迭代的块的。\n\n从第一性原理出发，结合这些因素，我们得到每个原始迭代的成本模型\n$$\nC(u) \\;=\\; c \\;+\\; \\frac{h}{u} \\;+\\; \\frac{s\\,S(u)}{u},\n$$\n其中 $c$ 是每个原始迭代的基本计算成本，$h$ 是每次迭代的控制和地址更新开销，$s$ 是每个 $u$ 次迭代块中每个溢出值的溢出成本。\n\n我们已知：\n- $c = 20$,\n- $h = 30$,\n- $R = 13$,\n- $L_{\\text{shared}} = 5$,\n- $L_{\\text{iter}} = 3$,\n- $L(u) = L_{\\text{shared}} + u\\,L_{\\text{iter}}$,\n- $S(u) = \\max\\big(0,\\,L(u) - R\\big)$.\n\n计算特定展开因子的活动变量数和溢出数：\n- 对于 $u=2$，\n$$\nL(2) \\;=\\; 5 + 2\\cdot 3 \\;=\\; 11,\n$$\n并且由于 $11 \\leq 13$，\n$$\nS(2) \\;=\\; 0.\n$$\n因此，\n$$\nC(2) \\;=\\; c + \\frac{h}{2} + \\frac{s\\,S(2)}{2} \\;=\\; 20 + \\frac{30}{2} + \\frac{s\\cdot 0}{2} \\;=\\; 20 + 15 \\;=\\; 35.\n$$\n\n- 对于 $u=3$，\n$$\nL(3) \\;=\\; 5 + 3\\cdot 3 \\;=\\; 14,\n$$\n并且由于 $14  13$，\n$$\nS(3) \\;=\\; 14 - 13 \\;=\\; 1.\n$$\n因此，\n$$\nC(3) \\;=\\; c + \\frac{h}{3} + \\frac{s\\,S(3)}{3} \\;=\\; 20 + \\frac{30}{3} + \\frac{s\\cdot 1}{3} \\;=\\; 20 + 10 + \\frac{s}{3} \\;=\\; 30 + \\frac{s}{3}.\n$$\n\n我们寻求盈亏平衡溢出成本 $s^{\\star}$，使得 $C(2) = C(3)$。令两个表达式相等并求解 $s$：\n$$\n35 \\;=\\; 30 + \\frac{s}{3} \\;\\;\\Longrightarrow\\;\\; \\frac{s}{3} \\;=\\; 5 \\;\\;\\Longrightarrow\\;\\; s \\;=\\; 15.\n$$\n\n因此，盈亏平衡溢出成本为 $s^{\\star} = 15$ 个周期：如果 $s  15$ 个周期，则展开到 $u=3$ 是有利的；如果 $s > 15$ 个周期，则在此模型下展开到 $u=2$（避免溢出）更好。这量化了编译器必须在减少的控制开销和因循环展开而增加的寄存器压力之间进行权衡取舍。", "answer": "$$\\boxed{15}$$", "id": "3674633"}, {"introduction": "编译器的后端负责将抽象的中间表示（IR）转换为具体的目标机器指令，而指令的选择本身就是一种精妙的优化。这个问题 [@problem_id:3674621] 深入探讨了指令选择过程，展示了利用处理器复杂的寻址模式是一种多么强大的技术。你将分析如何将地址计算折叠进单个内存访问指令中，从而减少寄存器压力，并可能避免代价高昂的寄存器溢出（spill）。", "problem": "编译器后端必须将一个中间表示 (IR) 映射到一个目标指令集架构 (ISA)。考虑一个目标机器，它支持一种形式为“基址加变址带移位加偏移量”的复杂寻址模式的内存操作数，我们将其表示为 $[\\mathrm{B} + \\mathrm{I} \\ll s + d]$，其中 $\\mathrm{B}$ 是一个基址寄存器，$\\mathrm{I}$ 是一个变址寄存器，$s$ 是一个小的非负移位量，$d$ 是一个小的偏移量。该机器还支持形式为 $[\\mathrm{B}]^{+}$ 的后增量寻址，它在内存访问后用一个小的步长更新 $\\mathrm{B}$。假设编译器的后端在寄存器分配之前执行指令选择，但可能使用一个在选择期间估计寄存器压力的成本模型。寄存器压力定义为在所有程序点上同时活跃的临时变量数量的最大值，即 $\\max_{t} \\left|L(t)\\right|$，其中 $L(t)$ 是在程序点 $t$ 活跃的IR临时变量集合。\n\n考虑一种高级语言中的以下循环，前端已将其降级为静态单赋值 (SSA) 形式的三地址IR：\n有数组 $A$ 和 $B$，一个循环索引 $i$，一个循环边界 $N$，以及一个初始值为 $0$ 的标量累加器 $s$。循环体计算 $s \\leftarrow s + A[i] + B[2 \\cdot i + c]$，然后将 $i$ 增加 $1$，直到 $i = N$。这里 $c$ 是一个编译时常量。$A$ 和 $B$ 的基地址位于专用的临时变量 $\\mathrm{baseA}$ 和 $\\mathrm{baseB}$ 中，元素大小使得移位 $s$ 可以编码 $i$ 的比例因子。\n\n在一个热循环的头部，由于应用程序二进制接口 (ABI) 的约束和共存值，循环体只有 $4$ 个可分配的通用寄存器可用。对于每次数组访问，后端必须选择以下之一：\n- 在一个单独的临时变量中具象化有效地址（例如，使用算术指令计算 $\\mathrm{addr} \\leftarrow \\mathrm{baseB} + (i \\ll s) + d$，然后从 $[\\mathrm{addr}]$ 加载），或者\n- 通过使用复杂寻址模式 $[\\mathrm{baseB} + i \\ll s + d]$ 将地址计算折叠到内存操作中，或者\n- 在合法的情况下，使用后增量形式在访问后更新基址，以避免显式的归纳变量更新。\n\n选择所有关于精心设计的后端如何根据寻址模式选择指令形式，以及关于复杂寻址降低寄存器压力的场景的正确陈述。\n\nA. 一个结合了估计周期成本和寄存器压力项的成本模型可能会偏爱复杂寻址形式，因为将 $[\\mathrm{baseB} + i \\ll s + d]$ 折叠到加载操作中，会移除原本用于保存有效地址的临时变量，从而减少同时活跃的临时变量的最大数量，并可能在只有 $4$ 个寄存器可分配时避免溢出。\n\nB. 复杂寻址总是减少动态指令数，因此无论微架构成本或寄存器压力效应如何，它总是首选。\n\nC. 在一个线性遍历 $A$ 的循环中（例如，每次迭代加载 $A[i]$），对 $A$ 使用后增量寻址模式可以通过将演进的指针保存在单个物理寄存器中，并消除一个单独的加法指令及其为更新后的指针创建的活跃临时变量，从而降低寄存器压力。\n\nD. 折叠和具象化有效地址之间的决策必须在寄存器分配之后才能做出，因为只有最终的物理寄存器分配才能揭示溢出；因此，指令选择必须推迟到寄存器分配之后。\n\nE. 如果目标机缺乏对 $B[2 \\cdot i + c]$ 的基址加变址折叠功能，但有一个可以在没有内存流量的情况下计算地址的加载有效地址指令，后端应该优先选择在单独的临时变量中具象化地址以增加指令级并行性，即使这将使活跃的临时变量超过 $4$ 个可用寄存器并强制溢出，因为增加的并行性通常优于溢出成本。", "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **目标机器架构：**\n    - 支持一种复杂寻址模式：$[\\mathrm{B} + \\mathrm{I} \\ll s + d]$，其中 $\\mathrm{B}$ 是基址寄存器，$\\mathrm{I}$ 是变址寄存器，$s$ 是一个小的非负移位量，$d$ 是一个小的偏移量。\n    - 支持后增量寻址：$[\\mathrm{B}]^{+}$，它在内存访问后用一个小的步长更新 $\\mathrm{B}$。\n- **编译器后端结构：**\n    - 在寄存器分配之前执行指令选择。\n    - 可能使用一个在选择期间估计寄存器压力的成本模型。\n    - 寄存器压力定义为同时活跃的临时变量的最大数量：$\\max_{t} \\left|L(t)\\right|$，其中 $L(t)$ 是在程序点 $t$ 活跃的IR临时变量集合。\n- **问题背景：**\n    - 一个高级语言循环被降级为静态单赋值 (SSA) 形式的三地址中间表示 (IR)。\n    - 该循环涉及数组 $A$ 和 $B$，一个循环索引 $i$，一个循环边界 $N$，以及一个初始化为 $0$ 的标量累加器 $s$。\n    - 循环体计算 $s \\leftarrow s + A[i] + B[2 \\cdot i + c]$。\n    - 循环索引 $i$ 增加 $1$，直到 $i = N$。\n    - $c$ 是一个编译时常量。\n    - $A$ 和 $B$ 的基地址位于临时变量 $\\mathrm{baseA}$ 和 $\\mathrm{baseB}$ 中。\n    - 元素大小使得移位 $s$ 可以编码索引 $i$ 的比例因子。\n- **约束与选择：**\n    - 在一个热循环的头部，只有 $4$ 个可分配的通用寄存器可用。\n    - 对于每次数组访问，后端必须选择：\n        1. 在一个单独的临时变量中具象化有效地址。\n        2. 使用复杂寻址模式将地址计算折叠到内存操作中。\n        3. 在合法的情况下使用后增量形式。\n- **问题：**\n    - 选择所有关于精心设计的后端如何根据这些寻址模式选择指令形式，以及复杂寻址如何降低寄存器压力的正确陈述。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述是有科学依据的、定义明确的且客观的。\n- **科学依据：** 所提出的概念——例如指令集架构 (ISA)、复杂寻址模式、编译器阶段（指令选择、寄存器分配）、中间表示 (IR)、静态单赋值 (SSA)、寄存器压力和成本模型——都是编译器设计和计算机体系结构领域的基础和标准课题。该场景是现实的，并代表了编译器后端面临的挑战。\n- **定义明确性：** 问题提供了清晰的背景，定义了关键术语（寄存器压力），概述了约束条件（4个寄存器），并呈现了编译器可用的选择。任务是基于此设置评估一组陈述，这是一个定义明确的问题，可以得出一套确定的正确原则。\n- **客观性：** 问题陈述使用精确的技术语言表达。待评估的陈述虽然提出了主张，但可以根据既定的编译器优化原则进行客观分析。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。这是一个编译器理论中形式良好的问题，需要理解代码生成中的权衡。\n\n## 解答推导\n\n这个问题的核心是编译器指令选择阶段执行的权衡分析。成本模型中的主要因素通常是指令延迟/吞吐量（性能）和寄存器压力（资源利用）。高寄存器压力会增加溢出（将临时变量存储到内存/从内存重新加载）的可能性，这会带来显著的性能损失，尤其是在热循环内部。我们将根据这些原则评估每个陈述。\n\n考虑循环体中的两次内存访问：$A[i]$ 和 $B[2 \\cdot i + c]$。\n假设两个数组的元素大小均为 $4$ 字节，所以缩放移位为 $s=2$。\n$A[i]$ 的地址是 $\\mathrm{baseA} + i \\times 4$。这可以表示为 $\\mathrm{baseA} + (i \\ll 2)$，符合寻址模式 $[\\mathrm{B} + \\mathrm{I} \\ll s + 0]$。\n$B[2 \\cdot i + c]$ 的地址是 $\\mathrm{baseB} + (2 \\cdot i + c) \\times 4 = \\mathrm{baseB} + 8 \\cdot i + 4 \\cdot c$。这可以表示为 $\\mathrm{baseB} + (i \\ll 3) + 4c$。这也符合寻址模式 $[\\mathrm{B} + \\mathrm{I} \\ll s + d]$，其中基址 $\\mathrm{B}=\\mathrm{baseB}$，变址 $\\mathrm{I}=i$，移位 $s=3$，偏移量 $d=4c$。\n\n- **具象化地址**，例如对于 $B[2 \\cdot i + c]$，将需要类似下面的一系列指令：\n  1. `t1 - i  3`\n  2. `t2 - baseB + t1`\n  3. `t3 - t2 + 4c`\n  4. `valB - load [t3]` (简单寻址)\n  这个序列引入了新的临时变量 ($t1, t2, t3$)，它们必须同时活跃，从而增加了寄存器压力。例如，在指令3之后，临时变量 `t3` (完整地址)被创建，并且必须保持活跃直到被指令4消耗。\n\n- **折叠地址**计算使用一条指令：\n  1. `valB - load [baseB + i  3 + 4c]` (复杂寻址)\n  这条单一指令实现了相同的结果，而没有为地址分量创建任何中间临时变量。因此，并发活跃的临时变量的最大数量减少了。\n\n### 逐项分析\n\n**A. 一个结合了估计周期成本和寄存器压力项的成本模型可能会偏爱复杂寻址形式，因为将 $[\\mathrm{baseB} + i \\ll s + d]$ 折叠到加载操作中，会移除原本用于保存有效地址的临时变量，从而减少同时活跃的临时变量的最大数量，并可能在只有 $4$ 个寄存器可分配时避免溢出。**\n\n如上述分析所示，显式地具象化一个地址会创建一个新的临时变量（例如 `addr`）来保存计算出的地址。这个 `addr` 临时变量从其定义点到其最后一次使用点（在 `load` 指令中）都是活跃的。通过使用复杂寻址模式将地址计算折叠到 `load` 指令中，就不再需要这个显式的 `addr` 临时变量。这直接减小了地址计算和加载之间程序点上的活跃集 $L(t)$ 的大小，从而降低了整体的寄存器压力 $\\max_{t} \\left|L(t)\\right|$。在只有 $4$ 个寄存器的紧张预算下，将活跃临时变量的峰值数量从（例如）$5$ 减少到 $4$，就意味着可以避免代价高昂的内存溢出，而将所有值都放入寄存器中。一个精心设计的成本模型会非常倾向于这种寄存器压力的降低。\n\n**结论：正确。**\n\n**B. 复杂寻址总是减少动态指令数，因此无论微架构成本或寄存器压力效应如何，它总是首选。**\n\n这个陈述做出了一个绝对的论断：“总是首选”。虽然使用复杂寻址模式确实减少了动态指令数（例如，一个 `load` 指令对比多个算术指令加一个 `load` 指令），但它并不总是最佳选择。在某些处理器上，具有复杂寻址模式的指令可能比一系列更简单的指令有更高的延迟或更低的吞吐量。例如，地址生成单元 (AGU) 可能需要几个周期，可能会阻塞流水线，而一系列简单的算术操作可能在超标量、乱序执行的机器上更高效地执行。一个成熟的编译器成本模型必须考虑这些微架构的细节。“无论微架构成本如何”这个短语是该陈述的一个关键缺陷。性能是以时间（周期）来衡量的，而不仅仅是指令数。\n\n**结论：错误。**\n\n**C. 在一个线性遍历 $A$ 的循环中（例如，每次迭代加载 $A[i]$），对 $A$ 使用后增量寻址模式可以通过将演进的指针保存在单个物理寄存器中，并消除一个单独的加法指令及其为更新后的指针创建的活跃临时变量，从而降低寄存器压力。**\n\n编译器可以执行强度削减，将访问转换为指针追逐模式，而不是使用变化的索引 `i` 从固定的基址 `baseA` 进行变址。代码将使用一个指针，比如 `$ptrA = \\[i]$`，并在每次迭代中计算 `$ptrA_{\\text{next}} = ptrA + \\text{element\\_size}$`。这个 `add` 指令创建了一个新的临时变量 `$ptrA_{\\text{next}}$`。在 SSA 形式下，这将是 `$ptrA_{k+1} = ptrA_k + \\text{stride}$`。`$ptrA_k$` 和 `$ptrA_{k+1}$` 的活跃范围是不同的，在 `add` 指令处，如果 `$ptrA_k$` 还有其他用途，两者可能都需要保存在寄存器中。而后增量寻址模式，`load [ptrA]^+`，将 `load` 和指针更新合并为一条指令。该指令读取持有 `ptrA` 的寄存器以获取地址，然后将更新后的值写回*同一个*寄存器。这消除了单独的 `add` 指令，并且关键地，避免了为更新后的指针值创建单独临时变量的需要。活跃临时变量的数量减少了，从而降低了寄存器压力。\n\n**结论：正确。**\n\n**D. 折叠和具象化有效地址之间的决策必须在寄存器分配之后才能做出，因为只有最终的物理寄存器分配才能揭示溢出；因此，指令选择必须推迟到寄存器分配之后。**\n\n该陈述建议了一种颠倒的阶段顺序：先进行寄存器分配，再进行指令选择。虽然有些编译器探索过这种方法，但现代编译器（如 GCC, LLVM）中的主流方法是首先执行指令选择，生成使用无限“虚拟”寄存器集合的代码，然后是寄存器分配阶段，将这些虚拟寄存器映射到有限的物理寄存器集合。问题陈述本身就指明了“在寄存器分配之前执行指令选择”。此外，该论点的论据很薄弱。指令选择不必盲目操作；它使用一个*估计*寄存器压力和可能溢出成本的成本模型。通过分析数据流图，它可以很好地估计 $\\max_{t} \\left|L(t)\\right|$，并倾向于选择那些能将此数值保持在物理寄存器数量以下的指令。推迟选择会产生其他重大问题，例如寄存器分配器做出的分配可能与复杂指令的操作数约束不兼容。\n\n**结论：错误。**\n\n**E. 如果目标机缺乏对 $B[2 \\cdot i + c]$ 的基址加变址折叠功能，但有一个可以在没有内存流量的情况下计算地址的加载有效地址指令，后端应该优先选择在单独的临时变量中具象化地址以增加指令级并行性，即使这将使活跃的临时变量超过 $4$ 个可用寄存器并强制溢出，因为增加的并行性通常优于溢出成本。**\n\n该陈述主张使用像 `LEA` (加载有效地址) 这样的指令来具象化地址，以增加指令级并行性 (ILP)，即使这会导致寄存器溢出。虽然将地址计算 (`LEA`) 与内存访问 (`load`) 分开可以为乱序处理器暴露更多的 ILP，但声称这种好处“通常优于溢出成本”是错误的。一次寄存器溢出涉及内存操作（一次存储到堆栈，然后一次从堆栈加载）。这些内存操作的延迟，特别是如果它们未命中L1缓存，可能是几十到几百个周期。通过分离 `LEA` 和 `load` 所获得的 ILP 增益通常最多只有几个周期。在一个“热循环”中，为了获得微小的 ILP 优势而在每次迭代中增加溢出/重载的巨大开销，是一种灾难性的性能权衡。一个精心设计的后端会有一个成本模型，为溢出分配非常高的成本，使得导致溢出的选择变得非常不可取。\n\n**结论：错误。**", "answer": "$$\\boxed{AC}$$", "id": "3674621"}]}