{"hands_on_practices": [{"introduction": "语法转换（如消除左递归）是解析中的常见步骤，但它会深刻影响属性的求值顺序。本练习将通过对比左递归语法和其非左递归等价形式，揭示这种转换如何迫使我们从简单的自下而上综合属性（S-属性定义）转向更复杂的、包含继承属性的求值策略（L-属性定义）。通过追踪两种情况下的属性依赖关系，你将亲身体验求值流程的根本性转变。[@problem_id:3641106]", "problem": "考虑两个用于加法表达式求值的语法导向定义 (SDD)，它们唯一的区别在于表达式文法是使用左递归还是其非左递归的等价形式。您将比较在消除左递归前后，在相同输入上属性的求值顺序，并确定哪些提议的调度是有效的。\n\n基本出发点：\n- 一个语法导向的定义 (SDD) 将属性和语义规则与一个上下文无关文法相关联。一个属性实例只有在它所依赖的所有属性都已被计算出来后才能被求值。任何正确的求值顺序都是给定语法分析树的属性依赖图的一个拓扑序。\n- 一个节点的综合属性由其子节点的属性计算得出。一个节点的继承属性由其父节点和/或兄弟节点的属性计算得出。\n- 从文法中消除左递归会将一个左递归规则转换为一个等价的右递归或迭代形式，这通常需要将一个纯综合属性的SDD转换为一个带有继承属性的L-属性SDD，以保持从左到右的求值顺序。\n\n文法和SDD：\n1) 左递归文法和S-属性SDD：\n- 文法 $G_1$：\n  - $E \\to E \\; \\texttt{+} \\; T \\mid T$\n  - $T \\to \\texttt{n}$，其中 `n` 是一个数字记号，其词法值为 $n.lexval$。\n- 属性和规则：\n  - 对于 $E \\to E_1 \\; \\texttt{+} \\; T$：$E.val = E_1.val + T.val$。\n  - 对于 $E \\to T$：$E.val = T.val$。\n  - 对于 $T \\to \\texttt{n}$：$T.val = n.lexval$。\n  所有属性都是综合属性。\n\n2) 非左递归文法和L-属性SDD：\n- 文法 $G_2$ (消除左递归后)：\n  - $E \\to T \\; E'$\n  - $E' \\to \\texttt{+} \\; T \\; E' \\mid \\varepsilon$\n  - $T \\to \\texttt{n}$\n- 属性和规则：\n  - 对于 $E \\to T \\; E'$：$E'.inh = T.val$，$E.val = E'.syn$。\n  - 对于 $E' \\to \\texttt{+} \\; T \\; E'_1$：$E'_1.inh = E'.inh + T.val$，$E'.syn = E'_1.syn$。\n  - 对于 $E' \\to \\varepsilon$：$E'.syn = E'.inh$。\n  - 对于 $T \\to \\texttt{n}$：$T.val = n.lexval$。\n  这里 $E'.inh$ 是一个携带运行总和的继承属性，而 $E'.syn$ 是一个综合属性，将最终结果传回给 $E$。\n\n输入和语法分析树形状约定：\n- 考虑输入 $n_1 + n_2 + n_3$。对于 $G_1$，最左推导产生语法分析树 $E_3 \\Rightarrow E_2 + T_3 \\Rightarrow (E_1 + T_2) + T_3 \\Rightarrow (T_1 + T_2) + T_3$。将三个 $T$-节点从左到右命名为 $T_1, T_2, T_3$，将三个 $E$-节点从底向上命名为 $E_1$（对于 $E \\to T$）、$E_2$（对于第一个 $+$）和 $E_3$（根节点）。\n- 对于 $G_2$，语法分析过程展开为 $E \\to T_1 \\; E'_0$，然后 $E'_0 \\to + \\; T_2 \\; E'_1$，然后 $E'_1 \\to + \\; T_3 \\; E'_2$，然后 $E'_2 \\to \\varepsilon$。将 $E'$-链上的节点命名为 $E'_0, E'_1, E'_2$。\n\n目标：\n- 仅使用上述SDD规则和“有效调度必须是依赖图的拓扑序”这一原则，确定哪个选项列出了在输入 $n_1 + n_2 + n_3$ 上对 $G_1$ 和 $G_2$ 都有效的求值顺序。在下面的所有序列中，每一项都指定了在该点要计算的单个属性实例。假设读取 $n_i.lexval$ 是计算 $T_i.val$ 的一部分。\n\n选项：\nA) \n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$。\n- 对于 $G_2$：$T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$。\n\nB)\n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$。\n- 对于 $G_2$：$T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$。\n\nC)\n- 对于 $G_1$：$T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$。\n- 对于 $G_2$：$E'_0.inh,\\; T_1.val,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$。\n\nD)\n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$。\n- 对于 $G_2$：$T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$。\n\n选择正确的选项。至少有一个正确选项。仅当一个选项列出的两个调度对于相应的SDD都是有效的拓扑序时，才选择该选项。", "solution": "我们从属性求值顺序的指导原则开始：\n- 对于任何语法导向的定义 (SDD)，语法分析树上每个节点的属性和方程都会导出一个属性依赖的有向无环图。一个属性实例只有在它所依赖的所有属性都可用之后才能被求值。因此，任何有效的求值顺序都是该依赖图的一个拓扑排序。\n- 对于综合属性，节点的属性依赖于其子节点的属性。对于继承属性，节点的属性依赖于其父节点和/或在推导中位于其左侧的兄弟节点的属性。\n- 从 $E \\to E + T \\mid T$ 消除左递归得到 $E \\to T E'$，$E' \\to + T E' \\mid \\varepsilon$。为了在L-属性SDD下保持左结合求值，我们使用一个继承属性 $E'.inh$ 来携带运行总和，并使用一个综合属性 $E'.syn$ 将最终值传回给 $E$。\n\n我们现在为给定输入 $n_1 + n_2 + n_3$ 明确依赖关系。\n\n对于带有S-属性规则的 $G_1$：\n- 树形结构：$E_3 \\to E_2 + T_3$，$E_2 \\to E_1 + T_2$，$E_1 \\to T_1$，以及对于 $i \\in \\{1,2,3\\}$ 有 $T_i \\to n_i$。\n- 属性方程：\n  - $T_i.val = n_i.lexval$。\n  - $E_1.val = T_1.val$。\n  - $E_2.val = E_1.val + T_2.val$。\n  - $E_3.val = E_2.val + T_3.val$。\n- 依赖关系：\n  - $E_1.val$ 依赖于 $T_1.val$。\n  - $E_2.val$ 依赖于 $E_1.val$ 和 $T_2.val$。\n  - $E_3.val$ 依赖于 $E_2.val$ 和 $T_3.val$。\n  - 每个 $T_i.val$ 仅依赖于 $n_i.lexval$，我们将其视为在计算 $T_i.val$ 时是可用的。\n- 任何有效的调度都必须遵守这些依赖关系：$T_1.val$ 在 $E_1.val$ 之前；$E_1.val$ 和 $T_2.val$ 都在 $E_2.val$ 之前；$E_2.val$ 和 $T_3.val$ 都在 $E_3.val$ 之前。\n\n对于带有L-属性规则的 $G_2$：\n- 推导：$E \\to T_1 \\; E'_0$，$E'_0 \\to + \\; T_2 \\; E'_1$，$E'_1 \\to + \\; T_3 \\; E'_2$，$E'_2 \\to \\varepsilon$。\n- 沿链实例化的属性方程：\n  - 对于 $i \\in \\{1,2,3\\}$ 有 $T_i.val = n_i.lexval$。\n  - 由 $E \\to T_1 \\; E'_0$ 得：$E'_0.inh = T_1.val$，$E.val = E'_0.syn$。\n  - 由 $E'_0 \\to + \\; T_2 \\; E'_1$ 得：$E'_1.inh = E'_0.inh + T_2.val$，$E'_0.syn = E'_1.syn$。\n  - 由 $E'_1 \\to + \\; T_3 \\; E'_2$ 得：$E'_2.inh = E'_1.inh + T_3.val$，$E'_1.syn = E'_2.syn$。\n  - 由 $E'_2 \\to \\varepsilon$ 得：$E'_2.syn = E'_2.inh$。\n- 依赖关系：\n  - $E'_0.inh$ 依赖于 $T_1.val$。\n  - $E'_1.inh$ 依赖于 $E'_0.inh$ 和 $T_2.val$。\n  - $E'_2.inh$ 依赖于 $E'_1.inh$ 和 $T_3.val$。\n  - $E'_2.syn$ 依赖于 $E'_2.inh$。\n  - $E'_1.syn$ 依赖于 $E'_2.syn$。\n  - $E'_0.syn$ 依赖于 $E'_1.syn$。\n  - $E.val$ 依赖于 $E'_0.syn$。\n- 任何有效的调度都必须在继承属性的先决条件可用时计算它们，并且必须推迟综合属性的计算，直到它们的依赖关系得到满足。\n\n我们现在根据这些依赖约束来评估每个选项。\n\n选项A：\n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; T_2.val,\\; E_2.val,\\; T_3.val,\\; E_3.val$。\n  - 检查：$T_1.val$ 在 $E_1.val$ 之前 — 满足。$E_2.val$ 在 $E_1.val$ 和 $T_2.val$ 之后调度 — 满足。$E_3.val$ 在 $E_2.val$ 和 $T_3.val$ 之后 — 满足。这是一个有效的拓扑序。\n- 对于 $G_2$：$T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn,\\; E.val$。\n  - 检查：$E'_0.inh$ 在 $T_1.val$ 之后 — 满足。$E'_1.inh$ 在 $E'_0.inh$ 和 $T_2.val$ 之后 — 满足。$E'_2.inh$ 在 $E'_1.inh$ 和 $T_3.val$ 之后 — 满足。然后综合属性链 $E'_2.syn \\to E'_1.syn \\to E'_0.syn \\to E.val$ 的顺序正确。这是一个有效的拓扑序。\n结论：正确。\n\n选项B：\n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; E_2.val,\\; T_2.val,\\; T_3.val,\\; E_3.val$。\n  - 检查：$E_2.val$ 出现在 $T_2.val$ 之前，但 $E_2.val$ 依赖于 $T_2.val$。这违反了依赖关系 $T_2.val \\to E_2.val$。无效。\n- 对于 $G_2$：所示的 $G_2$ 调度与选项A中的相匹配并且是有效的，但该选项要求两个调度都有效。\n结论：不正确，因为 $G_1$ 的调度违反了依赖关系。\n\n选项C：\n- 对于 $G_1$：$T_1.val,\\; T_2.val,\\; E_2.val,\\; E_1.val,\\; T_3.val,\\; E_3.val$。\n  - 检查：$E_2.val$ 在 $E_1.val$ 之前调度，但 $E_2.val$ 依赖于 $E_1.val$。这违反了依赖关系 $E_1.val \\to E_2.val$。无效。\n- 对于 $G_2$：$E'_0.inh$ 在 $T_1.val$ 之前调度，但 $E'_0.inh$ 依赖于 $T_1.val$。这违反了依赖关系 $T_1.val \\to E'_0.inh$。无效。\n结论：不正确。\n\n选项D：\n- 对于 $G_1$：$T_1.val,\\; E_1.val,\\; T_2.val,\\; T_3.val,\\; E_2.val,\\; E_3.val$。\n  - 检查：$E_2.val$ 在 $E_1.val$ 和 $T_2.val$ 之后 — 满足。$E_3.val$ 在 $E_2.val$ 和 $T_3.val$ 之后 — 满足。$G_1$ 的调度是有效的。\n- 对于 $G_2$：$T_1.val,\\; E'_0.inh,\\; T_2.val,\\; E'_1.inh,\\; E.val,\\; T_3.val,\\; E'_2.inh,\\; E'_2.syn,\\; E'_1.syn,\\; E'_0.syn$。\n  - 检查：$E.val$ 在 $E'_0.syn$ 之前调度，但 $E.val$ 依赖于 $E'_0.syn$。这违反了依赖关系 $E'_0.syn \\to E.val$。此外，综合属性链 $E'_2.syn \\to E'_1.syn \\to E'_0.syn$ 被放在 $E.val$ 之后，进一步违反了依赖关系。无效。\n结论：不正确。\n\n结论：只有选项A为两个SDD都提供了有效的拓扑序。它还说明了消除左递归后求值过程的结构性变化：S-属性的 $G_1$ 调度是在左递归树上对综合属性进行纯粹的自底向上求值，而L-属性的 $G_2$ 调度则将 $T_i.val$ 的即时计算与继承属性 $E'_i.inh$ 的传播交错进行，然后通过 $E'_i.syn$ 将综合结果回传。这种差异直接源于在非左递归文法中引入继承属性来携带运行总和。", "answer": "$$\\boxed{A}$$", "id": "3641106"}, {"introduction": "属性求值的顺序不仅仅是一个理论问题，它对编译器的实际行为有着直接影响。本练习通过一个关于常量折叠和算术溢出的思想实验，探讨了不同求值策略的后果。通过比较“类型优先”和“常量优先”这两种不同的求值顺序，你将看到求值顺序的选择如何决定编译器何时以及何处能检测到错误，从而理解其在编译器健壮性设计中的重要性。[@problem_id:3641104]", "problem": "考虑一个用于整数算术的简单表达式文法：\n- $\\text{E} \\rightarrow \\text{E} \\; \\texttt{+} \\; \\text{T} \\; \\mid \\; \\text{T}$\n- $\\text{T} \\rightarrow \\text{T} \\; \\texttt{*} \\; \\text{F} \\; \\mid \\; \\text{F}$\n- $\\text{F} \\rightarrow ( \\text{E} ) \\; \\mid \\; \\text{NUM}$\n\n假设我们使用一个语法导向定义（SDD；Syntax-Directed Definition）来执行常量折叠，该定义在每个节点上跟踪以下属性：\n- 一个综合属性值 $\\text{.val}$，\n- 一个类型 $\\text{.type}$（从上下文中继承或在局部确定），\n- 一个溢出标志 $\\text{.ovf}$，指示子表达式是否无法用所选的机器类型表示。\n\n我们的目标是一个范围为 $[-2^{31}, 2^{31}-1]$ 的 $32$ 位有符号整数类型，记为 `Int32`。溢出定义为任何无法在 `Int32` 中表示的中间或最终结果，或字面量。\n\n为常量折叠定义两种仅在求值顺序和依赖结构上有所不同的SDD：\n\n- SDD-$\\alpha$（类型优先，然后常量）：类型在值计算之前传播。对于 $\\text{E} \\rightarrow \\text{E}_1 \\texttt{+} \\text{T}$，继承的类型自顶向下流动：$\\text{E}_1.\\text{type} = \\text{E}.\\text{type}$ 和 $\\text{T}.\\text{type} = \\text{E}.\\text{type}$；类似地，对于 $\\text{T} \\rightarrow \\text{T}_1 \\texttt{*} \\text{F}$，设置 $\\text{T}_1.\\text{type} = \\text{T}.\\text{type}$ 和 $\\text{F}.\\text{type} = \\text{T}.\\text{type}$。叶子节点的字面量会立即检查其可表示性：对于 $\\text{F} \\rightarrow \\text{NUM}$，如果 $\\text{NUM}$ 超出 $[-2^{31}, 2^{31}-1]$ 的范围，则将 $\\text{F}.\\text{ovf}$ 设置为 true。在内部节点，值是使用在 $\\text{.type}$ 下的有界算术计算的，并且如果任一操作数溢出或有界操作在 $\\text{.type}$ 下溢出，则设置 $\\text{.ovf}$。\n\n- SDD-$\\beta$（常量优先，然后类型）：值在内部节点使用无界整数自底向上计算，不考虑机器类型，并且在内部节点不设置 $\\text{.ovf}$。只有在完整子表达式的 $\\text{.val}$ 被综合之后，才在其外围上下文中应用类型：在父节点将 $\\text{.val}$ 转换为 `Int32` 会触发溢出检查，即当且仅当最终的 $\\text{.val}$ 超出 $[-2^{31}, 2^{31}-1]$ 的范围时，$\\text{.ovf}$ 才变为 true。对于 $\\text{F} \\rightarrow \\text{NUM}$，字面量被保留为无界整数，不进行立即的可表示性检查。\n\n假设上下文声明 $\\text{E}.\\text{type} = \\mathrm{Int32}$，并考虑具体表达式\n$$\n(300000 * 300000) + 7.\n$$\n在 `Int32` 类型下，每个字面量 $300000$ 都是可表示的，但它们的乘积 $300000 \\times 300000 = 90000000000$ 超过了 $2^{31}-1 = 2147483647$。\n\n关于这两种 SDD 最早在哪一步检测到溢出，以下哪个陈述是正确的？\n\nA. 在 SDD-$\\alpha$ 下，一旦应用 `Int32` 类型并使用有界算术，溢出就会在乘法节点处被检测到；在 SDD-$\\beta$ 下，溢出仅在稍后当外围上下文尝试将无界结果转换为 `Int32` 时才被检测到。因此，SDD-$\\alpha$ 更早地检测到溢出。\n\nB. 在 SDD-$\\beta$ 下，溢出被更早地检测到，因为无界乘积 $90000000000$ 在加法之前自底向上计算，所以乘法节点比 SDD-$\\alpha$ 更早报告溢出。\n\nC. SDD-$\\alpha$ 和 SDD-$\\beta$ 都在同一时间检测到溢出，因为溢出完全由最终对 `Int32` 的赋值决定。\n\nD. SDD-$\\alpha$ 和 SDD-$\\beta$ 都不能影响溢出检测的时机；在声明式规范中，SDD 的求值顺序不影响错误检测的时机。", "solution": "该问题探讨了属性求值顺序对编译器错误检测行为的实际影响，特别是关于算术溢出。我们来分析两种策略：\n\n- **SDD-$\\alpha$（类型优先）**：该策略是“急切”的。它首先通过继承属性自顶向下地将目标类型（`Int32`）传播到树的每个节点。因此，在计算任何值之前，每个算术运算（如乘法）都已知道它必须在 `Int32` 的有界范围内执行。对于表达式 `(300000 * 300000) + 7`，当编译器自底向上计算到乘法节点 `T * F` 时，它会尝试计算 `300000 * 300000`。由于该节点已经继承了 `Int32` 类型，它将使用32位有符号整数算术来执行此操作。乘积 `90,000,000,000` 远远超出了 `Int32` 的最大值（`2,147,483,647`），因此在此乘法节点处会立即发生溢出。编译器会将该节点的 `.ovf` 标志设置为 `true`，从而在求值过程的早期阶段就检测到并标记了错误。\n\n- **SDD-$\\beta$（常量优先）**：该策略是“懒惰”的。它首先使用精度不受限制的整数（如大整数库）自底向上地计算表达式的值。在乘法节点，计算 `300000 * 300000` 得到无界整数结果 `90,000,000,000`。此时，不进行溢出检查，因为还没有应用类型约束。这个巨大的数值被传递到加法节点，计算 `90,000,000,000 + 7`，得到 `90,000,000,007`。这个最终的无界结果被综合到根表达式节点。只有在这一最后阶段，当编译器试图将此最终值 `90,000,000,007` 放入一个需要 `Int32` 类型的上下文中时（例如，赋值给一个 `Int32` 变量或作为 `Int32` 函数的参数），才会进行类型检查和转换。此时，编译器发现该值无法用 `Int32` 表示，并报告溢出。\n\n**比较：**\nSDD-$\\alpha$ 在乘法节点处检测到溢出。\nSDD-$\\beta$ 在整个表达式树的根部或之后才检测到溢出。\n因此，SDD-$\\alpha$ 策略能更早、更精确地定位溢出发生的位置。这通常是更可取的编译器行为，因为它能为开发者提供更准确的诊断信息（例如，指出是乘法本身导致了溢出，而不是整个表达式）。\n\n选项A准确地描述了这一差异。", "answer": "$$\\boxed{A}$$", "id": "3641104"}, {"introduction": "在确定了属性间的依赖关系图之后，我们需要一种系统性的方法来找出一个合法的求值序列。本练习为你提供了一个绝佳的动手实践机会，你将应用拓扑排序的标准算法——Kahn算法。通过在一个具体的语法分析树上手动执行该算法，你将具体地理解编译器是如何为属性求值制定一个可行的、循序渐进的执行计划的。[@problem_id:3641188]", "problem": "您正在学习编译原理中的语法制导定义（SDD）的求值顺序。对于一个良定义的SDD，其属性实例的求值顺序是其属性依赖图的任意一个拓扑序。在没有循环依赖的假设下，该属性依赖图是一个有向无环图（DAG）。\n\n拓扑排序的一个标准算法是Kahn算法，该算法重复地移除入度为零的节点并删除其出边，然后将新释放的节点添加到一个就绪集中。\n\n考虑以下基于列表文法的SDD。文法如下：\n- $L \\to L \\texttt{,} E$\n- $L \\to E$\n- $E \\to \\texttt{id}$\n\n属性：\n- 非终结符 $L$ 有一个继承属性 $L.n$ 和一个综合属性 $L.\\mathrm{len}$。\n- 非终结符 $E$ 有一个继承属性 $E.n$ 和一个综合属性 $E.\\mathrm{pos}$。\n\n语义规则：\n- 对于产生式 $L \\to L_{1} \\texttt{,} E_{r}$：\n  - $L_{1}.n = L.n$\n  - $E_{r}.n = L_{1}.n + L_{1}.\\mathrm{len}$\n  - $L.\\mathrm{len} = L_{1}.\\mathrm{len} + 1$\n- 对于产生式 $L \\to E_{x}$：\n  - $E_{x}.n = L.n$\n  - $L.\\mathrm{len} = 1$\n- 对于产生式 $E \\to \\texttt{id}$：\n  - $E.\\mathrm{pos} = E.n$\n\n对于输入 $\\mathrm{id} , \\mathrm{id} , \\mathrm{id}$ 的语法分析树：\n- 根节点是 $L_{0}$，使用产生式 $L \\to L , E$，其左子节点为 $L_{1}$，右子节点为 $E_{2}$。\n- 节点 $L_{1}$ 使用产生式 $L \\to L , E$，其左子节点为 $L_{2}$，右子节点为 $E_{1}$。\n- 节点 $L_{2}$ 使用产生式 $L \\to E$，其子节点为 $E_{0}$。\n- 每个 $E_{i}$ 都推导出 $\\texttt{id}$。\n\n假设根节点的继承属性是固定的：$L_{0}.n = 1$。此外，对于产生式 $L \\to E$，我们有 $L.\\mathrm{len} = 1$，所以 $L_{2}.\\mathrm{len} = 1$。\n\n将属性实例及其数字标识符定义如下：\n- $1$: $L_{0}.n$\n- $2$: $L_{0}.\\mathrm{len}$\n- $3$: $L_{1}.n$\n- $4$: $L_{1}.\\mathrm{len}$\n- $5$: $L_{2}.n$\n- $6$: $L_{2}.\\mathrm{len}$\n- $7$: $E_{0}.n$\n- $8$: $E_{0}.\\mathrm{pos}$\n- $9$: $E_{1}.n$\n- $10$: $E_{1}.\\mathrm{pos}$\n- $11$: $E_{2}.n$\n- $12$: $E_{2}.\\mathrm{pos}$\n\n任务：\n- 根据在此语法分析树上实例化的语义规则，构造属性依赖边。每条边从一个源实例指向一个依赖于它的目标实例。最终得到的图是一个有向无环图（DAG）。\n- 在此DAG上运行Kahn算法，以获得这 $12$ 个属性实例的一个拓扑求值顺序。使用以下决胜规则：当就绪集中有多个入度为零的实例时，选择数字标识符最小的那个。\n- 设 $(v_{1}, v_{2}, \\ldots, v_{12})$ 是得到的有序实例序列，并设 $\\mathrm{id}(v_{i})$ 表示上面给出的 $v_{i}$ 的数字标识符。计算以下值\n$$ S = \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i}). $$\n\n您的最终答案必须是 $S$ 的精确值，以单个数字表示。无需四舍五入。", "solution": "### 步骤1：问题验证\n该问题是编译理论中的一个标准练习，具体涉及语法制导定义（SDD）中属性的求值。它要求为给定的语法分析树构建属性依赖图，然后使用带决胜规则的Kahn算法找到该图的一个特定拓扑排序。最终答案是从这个拓扑序导出的加权和。\n\n- **给定条件**：问题提供了文法、属性定义、语义规则、一个特定的语法分析树以及所有属性实例的数字标识符。它还为根节点的继承属性提供了一个初始值 $L_{0}.n = 1$。\n- **科学依据**：SDD、属性依赖图和拓扑排序（Kahn算法）等概念在编译器设计领域是基础且成熟的。\n- **良定性**：该问题是良定的。语法分析树是无歧义的，语义规则是明确的，并且Kahn算法的决胜规则确保了拓扑序的唯一性。任务定义清晰。\n- **客观性**：问题以精确、客观的语言陈述。\n\n该问题是有效的，因为它具有科学依据、良定、客观且自洽。\n\n### 步骤2：构造属性依赖图\n我们将语义规则实例化到给定的语法分析树上，以确定属性实例之间的依赖关系。这些实例由数字 $1$ 到 $12$ 标识。从节点 $u$到节点 $v$ 的一条边（记作 $u \\to v$）意味着对应于 $v$ 的属性依赖于对应于 $u$ 的属性。\n\n该语法分析树包含以下产生式：\n- 根节点 $L_0$：$L_0 \\to L_1, E_2$\n- 节点 $L_1$：$L_1 \\to L_2, E_1$\n- 节点 $L_2$：$L_2 \\to E_0$\n- 节点 $E_0, E_1, E_2$：$E \\to \\texttt{id}$\n\n依赖关系推导如下：\n- **在节点 $L_0$ 处 ($L_0 \\to L_1, E_2$):**\n  - $L_1.n = L_0.n \\implies L_0.n \\to L_1.n \\implies 1 \\to 3$\n  - $E_2.n = L_1.n + L_1.\\mathrm{len} \\implies L_1.n \\to E_2.n$ 且 $L_1.\\mathrm{len} \\to E_2.n \\implies 3 \\to 11$ 且 $4 \\to 11$\n  - $L_0.\\mathrm{len} = L_1.\\mathrm{len} + 1 \\implies L_1.\\mathrm{len} \\to L_0.\\mathrm{len} \\implies 4 \\to 2$\n- **在节点 $L_1$ 处 ($L_1 \\to L_2, E_1$):**\n  - $L_2.n = L_1.n \\implies L_1.n \\to L_2.n \\implies 3 \\to 5$\n  - $E_1.n = L_2.n + L_2.\\mathrm{len} \\implies L_2.n \\to E_1.n$ 且 $L_2.\\mathrm{len} \\to E_1.n \\implies 5 \\to 9$ 且 $6 \\to 9$\n  - $L_1.\\mathrm{len} = L_2.\\mathrm{len} + 1 \\implies L_2.\\mathrm{len} \\to L_1.\\mathrm{len} \\implies 6 \\to 4$\n- **在节点 $L_2$ 处 ($L_2 \\to E_0$):**\n  - $E_0.n = L_2.n \\implies L_2.n \\to E_0.n \\implies 5 \\to 7$\n  - $L_2.\\mathrm{len} = 1 \\implies L_2.\\mathrm{len}$ 没有任何依赖。\n- **在节点 $E_0, E_1, E_2$ 处 ($E \\to \\texttt{id}$):**\n  - $E_0.\\mathrm{pos} = E_0.n \\implies E_0.n \\to E_0.\\mathrm{pos} \\implies 7 \\to 8$\n  - $E_1.\\mathrm{pos} = E_1.n \\implies E_1.n \\to E_1.\\mathrm{pos} \\implies 9 \\to 10$\n  - $E_2.\\mathrm{pos} = E_2.n \\implies E_2.n \\to E_2.\\mathrm{pos} \\implies 11 \\to 12$\n\n初始条件 $L_0.n = 1$ 意味着属性实例 $1$ 没有任何依赖。\n\n所有依赖边的集合是：\n$\\{1 \\to 3, 3 \\to 5, 3 \\to 11, 4 \\to 2, 4 \\to 11, 5 \\to 7, 5 \\to 9, 6 \\to 4, 6 \\to 9, 7 \\to 8, 9 \\to 10, 11 \\to 12\\}$。\n\n### 步骤3：使用Kahn算法进行拓扑排序\n我们首先计算每个节点的初始入度：\n- 入度($1$): $0$ (来自 $L_0.n = 1$)\n- 入度($2$): $1$ (来自 $4$)\n- 入度($3$): $1$ (来自 $1$)\n- 入度($4$): $1$ (来自 $6$)\n- 入度($5$): $1$ (来自 $3$)\n- 入度($6$): $0$ (来自 $L_2.\\mathrm{len} = 1$)\n- 入度($7$): $1$ (来自 $5$)\n- 入度($8$): $1$ (来自 $7$)\n- 入度($9$): $2$ (来自 $5, 6$)\n- 入度($10$): $1$ (来自 $9$)\n- 入度($11$): $2$ (来自 $3, 4$)\n- 入度($12$): $1$ (来自 $11$)\n\n设 $R$ 为入度为 $0$ 的节点的就绪集， $T$ 为最终的拓扑序。\n\n1.  **初始状态**: $R = \\{1, 6\\}$。$T = ()$。\n2.  **选择 $v_1$**: 从 $R$ 中选择 $1$ (ID最小)。$T = (1)$。移除边 $1 \\to 3$。$3$ 的入度变为 $0$。将 $3$ 加入 $R$。$R = \\{3, 6\\}$。\n3.  **选择 $v_2$**: 从 $R$ 中选择 $3$ (ID最小)。$T = (1, 3)$。移除边 $3 \\to 5$ 和 $3 \\to 11$。$5$ 的入度变为 $0$。$11$ 的入度变为 $1$。将 $5$ 加入 $R$。$R = \\{5, 6\\}$。\n4.  **选择 $v_3$**: 从 $R$ 中选择 $5$ (ID最小)。$T = (1, 3, 5)$。移除边 $5 \\to 7$ 和 $5 \\to 9$。$7$ 的入度变为 $0$。$9$ 的入度变为 $1$。将 $7$ 加入 $R$。$R = \\{6, 7\\}$。\n5.  **选择 $v_4$**: 从 $R$ 中选择 $6$ (ID最小)。$T = (1, 3, 5, 6)$。移除边 $6 \\to 4$ 和 $6 \\to 9$。$4$ 的入度变为 $0$。$9$ 的入度变为 $0$。将 $4$ 和 $9$ 加入 $R$。$R = \\{4, 7, 9\\}$。\n6.  **选择 $v_5$**: 从 $R$ 中选择 $4$ (ID最小)。$T = (1, 3, 5, 6, 4)$。移除边 $4 \\to 2$ 和 $4 \\to 11$。$2$ 的入度变为 $0$。$11$ 的入度变为 $0$。将 $2$ 和 $11$ 加入 $R$。$R = \\{2, 7, 9, 11\\}$。\n7.  **选择 $v_6$**: 从 $R$ 中选择 $2$ (ID最小)。$T = (1, 3, 5, 6, 4, 2)$。$R = \\{7, 9, 11\\}$。\n8.  **选择 $v_7$**: 从 $R$ 中选择 $7$ (ID最小)。$T = (1, 3, 5, 6, 4, 2, 7)$。移除边 $7 \\to 8$。$8$ 的入度变为 $0$。将 $8$ 加入 $R$。$R = \\{8, 9, 11\\}$。\n9.  **选择 $v_8$**: 从 $R$ 中选择 $8$ (ID最小)。$T = (1, 3, 5, 6, 4, 2, 7, 8)$。$R = \\{9, 11\\}$。\n10. **选择 $v_9$**: 从 $R$ 中选择 $9$ (ID最小)。$T = (1, 3, 5, 6, 4, 2, 7, 8, 9)$。移除边 $9 \\to 10$。$10$ 的入度变为 $0$。将 $10$ 加入 $R$。$R = \\{10, 11\\}$。\n11. **选择 $v_{10}$**: 从 $R$ 中选择 $10$ (ID最小)。$T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10)$。$R = \\{11\\}$。\n12. **选择 $v_{11}$**: 从 $R$ 中选择 $11$。$T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11)$。移除边 $11 \\to 12$。$12$ 的入度变为 $0$。将 $12$ 加入 $R$。$R = \\{12\\}$。\n13. **选择 $v_{12}$**: 从 $R$ 中选择 $12$。$T = (1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$。$R = \\{\\}$。\n\n最终拓扑排序的属性标识符序列为 $\\mathrm{id}(v_i)$：\n$$(1, 3, 5, 6, 4, 2, 7, 8, 9, 10, 11, 12)$$\n\n### 步骤4：计算总和S\n值 $S$ 按公式 $S = \\sum_{i=1}^{12} i \\cdot \\mathrm{id}(v_{i})$ 计算。\n$$\n\\begin{align*}\nS = (1 \\cdot 1) + (2 \\cdot 3) + (3 \\cdot 5) + (4 \\cdot 6) + (5 \\cdot 4) + (6 \\cdot 2) \\\\\n  \\quad + (7 \\cdot 7) + (8 \\cdot 8) + (9 \\cdot 9) + (10 \\cdot 10) + (11 \\cdot 11) + (12 \\cdot 12) \\\\\n= 1 + 6 + 15 + 24 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 7 + 15 + 24 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 22 + 24 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 46 + 20 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 66 + 12 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 78 + 49 + 64 + 81 + 100 + 121 + 144 \\\\\n= 127 + 64 + 81 + 100 + 121 + 144 \\\\\n= 191 + 81 + 100 + 121 + 144 \\\\\n= 272 + 100 + 121 + 144 \\\\\n= 372 + 121 + 144 \\\\\n= 493 + 144 \\\\\n= 637\n\\end{align*}\n$$\n$S$ 的值为 $637$。", "answer": "$$\\boxed{637}$$", "id": "3641188"}]}