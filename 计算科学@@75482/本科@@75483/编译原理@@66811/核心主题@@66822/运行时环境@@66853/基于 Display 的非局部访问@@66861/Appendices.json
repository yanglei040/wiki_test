{"hands_on_practices": [{"introduction": "为了正确地实现 display 机制，我们必须首先理解其根本目的。是每一个词法块都应该在 display 中占有一席之地，还是只有特定类型的作用域才需要？此练习将挑战你批判性地思考 display 条目与活动记录之间的关系，这是设计一个正确且高效的非局部访问机制的关键。[@problem_id:3638219]", "problem": "一种静态作用域语言支持嵌套函数声明和块语句。一次函数激活会在运行时栈上精确分配$1$个激活记录，该记录在函数调用的整个动态范围内持续存在。函数内部的内嵌块不分配独立的激活记录；相反，它们的局部变量在编译时被布局在与外层函数相同的激活记录中，并在进入块时创建，在退出块时销毁。允许递归。编译器必须使用display来实现非局部变量的访问。\n\n需要假定的基本前提：\n- 词法（静态）作用域：引用的声明绑定由程序文本中最近的包围声明决定，而不是由运行时的调用链决定。\n- 激活记录：栈上的一个记录，用于存放局部变量、保存的机器状态以及可能的簿记信息。在给定模型下，每次函数激活只对应$1$个激活记录，每个块没有独立的激活记录。\n- Display：一个以词法深度为索引的数组 $\\mathrm{display}$，使得 $\\mathrm{display}[k]$ 持有指向词法深度为 $k$ 的最新激活记录的指针。对在词法深度 $d_x$ 声明的变量 $x$ 的非局部引用，通过取 $\\mathrm{display}[d_x]$ 作为基地址，并加上 $x$ 在该激活记录内编译时已知的偏移量来解析。\n\n你的任务是决定块是否应该拥有自己的display条目，提出一个将词法深度映射到display索引的方案，并论证其影响。请考虑以下候选方案：\n\nA. 仅为函数的词法深度分配display条目。如果一个函数的词法深度为 $d_f$，那么它占据 $\\mathrm{display}$ 中的索引 $d_f$。该函数内所有嵌套的块共享相同的索引 $d_f$，并且不会引起对 $\\mathrm{display}$ 的更新。对在外层函数（深度 $d_x \\le d_f$）中声明的变量 $x$ 的引用，使用基地址 $\\mathrm{display}[d_x]$ 和一个编译时偏移量。在当前函数的内嵌块中声明的变量，相对于当前激活记录进行寻址，而无需查询display。\n\nB. 为函数和块都分配display条目。设引用点包含块在内的总词法深度为 $d_{\\text{total}}$。在进入任何块或函数时，将 $\\mathrm{display}[d_{\\text{total}}]$ 设置为当前激活记录指针；退出时，恢复之前的值。对在外层作用域（深度 $d_x \\le d_{\\text{total}}$）中声明的变量 $x$ 的引用，使用基地址 $\\mathrm{display}[d_x]$。\n\nC. 维护一个单槽display，始终指向当前（最深的）激活记录。对于跨越多个词法深度的非局部访问，沿着存储在激活记录中的静态链进行 $h$ 次跳转，直到到达所需的环境，其中 $h$ 是词法距离。在进入块时，不发生display更新。\n\nD. 按动态（运行时）嵌套深度而非词法深度来索引display。每次进入一个块或函数时，增加一个动态深度计数器 $k$，并将 $\\mathrm{display}[k]$ 设置为当前激活记录指针。在非局部访问变量 $x$ 时，使用 $\\mathrm{display}[k - \\delta]$，其中 $\\delta$ 是根据语法嵌套差异计算得出的，而不考虑其间的动态调用。\n\n问题：在所述的激活记录模型以及非局部变量访问必须通过display实现的条件下，哪个（些）选项既能正确实现静态作用域解析，又避免了多余的display更新？选择所有适用的选项。", "solution": "问题陈述在编译器设计领域内是内部一致且定义明确的。它描述了一种具有特定运行时模型的静态作用域语言，并要求分析使用display实现非局部变量访问的不同方案。该问题是有效的，并且可以按所述方式解决。\n\n核心问题是，在一个函数创建激活记录而嵌套块不创建激活记录的语言中，如何管理display（一个指向激活记录的指针数组）。display的目的是为词法上外层作用域的激活记录提供快速访问。根据问题描述，`$\\mathrm{display}[k]$` 应该指向词法深度为 `$k$` 的最新的、当前活动的函数的激活记录。由于只有函数拥有激活记录，因此display条目理应对应于函数的词法深度。任何变量，无论是在函数级别声明还是在嵌套块中声明，都存在于其外层函数的激活记录中。访问当前函数激活记录内的变量（包括其嵌套块的变量）被视为局部访问，可以相对于当前帧指针进行解析，而无需使用display。只有在访问*外层函数*的激活记录中的变量时，才需要display。\n\n确立了这一原则后，我们可以评估每个选项。\n\n**A. 仅为函数的词法深度分配display条目。如果一个函数的词法深度为 $d_f$，那么它占据 $\\mathrm{display}$ 中的索引 $d_f$。该函数内所有嵌套的块共享相同的索引 $d_f$ 和不引起对 $\\mathrm{display}$ 的更新。对在外层函数（深度 $d_x \\le d_f$）中声明的变量 $x$ 的引用，使用基地址 $\\mathrm{display}[d_x]$ 和一个编译时偏移量。在当前函数的内嵌块中声明的变量，相对于当前激活记录进行寻址，而无需查询display。**\n\n该方案正确地认识到display的作用是定位激活记录，而激活记录只与函数相关联。\n- **正确性：** 让我们考虑从深度为 `$d_f$` 的函数 `$f$` 内部访问一个在词法上外层的、深度为 `$d_g  d_f$` 的函数 `$g$` 中声明的变量 `$x$`。在进入 `$f$` 时，`$\\mathrm{display}[d_f]$` 被设置为指向 `$f$` 的新激活记录，而条目 `$\\mathrm{display}[0], \\dots, \\mathrm{display}[d_f-1]$` 也被正确配置以指向外层函数的激活记录。对 `$x$` 的访问将使用 `$\\mathrm{display}[d_g]$`，它正确地指向 `$g$` 的激活记录。这正确地实现了静态作用域。对 `$f$` 激活记录内变量（包括 `$f$` 的局部变量及其所有内嵌块的局部变量）的访问，是相对于当前帧指针处理的，这也是正确且高效的。\n- **效率：** display仅在函数进入和退出时更新。进入或退出一个块不会改变可见的激活记录集合，因此不需要更新display。所以，该方案避免了多余的更新。\n\n该选项既正确又高效，满足了问题的两个条件。\n**结论：正确**\n\n**B. 为函数和块都分配display条目。设引用点包含块在内的总词法深度为 $d_{\\text{total}}$。在进入任何块或函数时，将 $\\mathrm{display}[d_{\\text{total}}]$ 设置为当前激活记录指针；退出时，恢复之前的值。对在外层作用域（深度 $d_x \\le d_{\\text{total}}$）中声明的变量 $x$ 的引用，使用基地址 $\\mathrm{display}[d_x]$。**\n\n该方案为块分配了display条目，即使它们没有自己的激活记录。\n- **正确性：** 该方案在技术上是正确的。如果一个块 `$B$` 位于深度为 `$d_F$` 的函数 `$F$` 内部，总词法深度为 `$d_B$`，那么进入 `$B$` 将导致 `$\\mathrm{display}[d_B]$` 被设置为指向当前激活记录（即 `$F$` 的激活记录）。访问外层作用域（深度为 `$d_x$`）中的变量时，将使用 `$\\mathrm{display}[d_x]$`，它会指向正确的激活记录。因此，变量解析是正确的。\n- **效率：** 该方案效率低下。每次进入和退出一个块时，它都会对一个display槽位执行保存、更新和恢复操作。由于块不引入新的激活记录，这种更新是多余的。所存储的信息（指向外层函数激活记录的指针）已经在外层函数的display槽位中可用（即 `$\\mathrm{display}[d_F]$`）。因此，这些更新是多余的。\n\n因为该选项包含多余的更新，所以它不满足问题的第二个条件。\n**结论：不正确**\n\n**C. 维护一个单槽display，始终指向当前（最深的）激活记录。对于跨越多个词法深度的非局部访问，沿着存储在激活记录中的静态链进行 $h$ 次跳转，直到到达所需的环境，其中 $h$ 是词法距离。在进入块时，不发生display更新。**\n\n该选项提出了一种不同的非局部访问机制。\n- **正确性：** 问题陈述强制要求“编译器必须使用display来实现非局部变量的访问”，并将display定义为一个按词法深度索引的数组。此处描述的机制是*静态链*（或访问链）方法，而不是display方法。在静态链方法中，每个激活记录包含一个指向其词法上外层函数的激活记录的指针（即静态链）。非局部访问需要遍历由 `$h$` 个这样的链接组成的链。虽然这是实现静态作用域的一种有效方法，但它不是问题所要求的display方法。\n\n该选项违反了使用所定义的display的基本约束。\n**结论：不正确**\n\n**D. 按动态（运行时）嵌套深度而非词法深度来索引display。每次进入一个块或函数时，增加一个动态深度计数器 $k$，并将 $\\mathrm{display}[k]$ 设置为当前激活记录指针。在非局部访问变量 $x$ 时，使用 $\\mathrm{display}[k - \\delta]$，其中 $\\delta$ 是根据语法嵌套差异计算得出的，而不考虑其间的动态调用。**\n\n该选项混淆了动态深度和词法深度的作用。\n- **正确性：** “基本前提”部分明确指出“词法（静态）作用域：引用的声明绑定由程序文本中最近的包围声明决定，而不是由运行时的调用链决定。” 按动态深度索引的display是实现*动态作用域*的机制。它在调用栈上寻找最近的、包含给定变量声明的激活记录，这正是动态作用域的定义。这直接与实现静态作用域的要求相矛盾。例如，如果函数 `$f$` 调用函数 `$g$`（`$g$` 在词法上并未嵌套在 `$f$` 中），而 `$g$` 引用了一个变量 `$x$`，动态作用域规则可能会将 `$x$` 解析为 `$f$` 中的一个变量。而静态作用域规则绝不会这样做；`$x$` 必须在 `$g$` 自身的词法环境中解析。\n\n该选项实现了错误的作用域规则。\n**结论：不正确**\n\n总之，只有选项A正确地使用所定义的display实现了静态作用域，并且通过避免与没有自身激活记录的块级作用域相关的多余更新，高效地做到了这一点。", "answer": "$$\\boxed{A}$$", "id": "3638219"}, {"introduction": "一旦我们理解了 display 在运行时的作用，下一个问题便是：编译器如何生成正确的代码？本练习将深入探讨编译期的处理过程，要求你设计一个遍历抽象语法树（AST）的算法，以计算非局部变量访问所需的静态嵌套层级。这是将源代码转换为可执行指令的核心任务之一。[@problem_id:3638316]", "problem": "一种静态作用域语言支持嵌套过程声明和词法块。编译器使用抽象语法树 (AST) 来表示程序，并使用一种基于 display 的机制进行非局部访问，其中 display $D$ 是一个指向当前活动记录 (AR) 的指针数组，通过相应作用域的静态嵌套层级进行索引。作用域的静态嵌套层级是指从根环境到该作用域的词法嵌套步数。编译器必须为每个标识符的出现确定一个词法深度 $h$，该深度量化了从使用点到找到其声明点需要向外移动多少静态嵌套结构。目标是通过遍历 AST 来计算 $h$，然后在编译时生成代码，使用 $D$ 来定位标识符的基地址。\n\n考虑以下带有嵌套过程的程序（假设一个单一的全局环境包含了所有顶层声明）。该程序的词法结构是：\n\n- 一个顶层过程 P，声明了一个变量 a。\n- 在 P 内部，一个嵌套过程 Q，声明了一个变量 b。\n- 在 Q 内部，一个嵌套过程 R，包含两次使用：a 和 b。\n- 在 Q 内部（但在 R 外部），一次对 a 的使用。\n- 在 P 内部（在 Q 外部），一次对 a 的使用。\n\n假设全局环境的静态嵌套层级为 $0$，过程 P 的静态嵌套层级为 $1$，过程 Q 的静态嵌套层级为 $2$，过程 R 的静态嵌套层级为 $3$。对于上述描述的每个标识符使用，编译器应计算相应的词法深度 $h$ 和 display $D$ 的索引，该索引将在生成的该标识符的地址计算中使用（基址 $=$ $D[\\text{index}]$ 加上标识符在其 AR 内的偏移量）。\n\n哪个选项正确地指定了一个 AST 遍历算法，用于为每个标识符使用计算 $h$，以及针对该示例程序的相应编译时到 $D$ 索引的映射？\n\nA. 遍历 AST，同时维护一个当前静态层级 $L$，从全局环境的 $0$ 开始，每进入一个新的词法作用域就加 $1$。首次遇到每个声明时，记录其层级 $L_d$。对于在层级为 $L_u$ 的作用域中的一次使用，找到最近的词法外圍声明，并将 $h$ 设置为 $L_u - L_d$。生成使用 $D[L_u - h]$ 作为标识符基址的代码。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$ 和基址 $D[1]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$ 和基址 $D[2]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$ 和基址 $D[1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[1]$。\n\nB. 遍历 AST，同时维护一个当前静态层级 $L$，从 $1$ 开始，每进入一个新的作用域就加 $1$。对于在层级 $L_u$ 的一次使用，将 $h$ 设置为 $L_u - L_d$，并使用 $D[L_d + 1]$ 作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$ 和基址 $D[2]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$ 和基址 $D[3]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$ 和基址 $D[2]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[2]$。\n\nC. 遍历 AST，并为每个声明记录其层级 $L_d$。对于在层级 $L_u$ 的一次使用，计算 $h$ 为 $L_d - L_u$ 并使用 $D[h]$ 作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 1 - 3 = -2$ 和基址 $D[-2]$；在 R 中，使用 b 得到 $h = 2 - 3 = -1$ 和基址 $D[-1]$；在 Q 中，使用 a 得到 $h = 1 - 2 = -1$ 和基址 $D[-1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[0]$。\n\nD. 不遍历 AST 来确定静态层级；而是在每次使用点根据动态调用栈深度计算 $h$。对所有在层级 $L_u$ 使用的标识符，使用 $D[L_u]$ 作为基址。应用于该程序：在 R 中，使用 a 和 b 的基址均为 $D[3]$；在 Q 中，使用 a 的基址为 $D[2]$；在 P 中，使用 a 的基址为 $D[1]$。\n\nE. 遍历 AST 并将 $h$ 计算为 AST 中使用节点和声明节点之间唯一路径上的边数。使用 $D[h]$作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 2$ 和基址 $D[2]$；在 R 中，使用 b 得到 $h = 1$ 和基址 $D[1]$；在 Q 中，使用 a 得到 $h = 1$ 和基址 $D[1]$；在 P 中，使用 a 得到 $h = 0$ 和基址 $D[0]$。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n\n-   **语言模型**：静态作用域，支持嵌套过程声明和词法块。\n-   **编译器数据结构**：抽象语法树 (AST)，Display `D` (指向活动记录 AR 的指针数组)。\n-   **Display 索引**：`D` 按作用域的静态嵌套层级索引。\n-   **静态嵌套层级定义**：从根环境到某个作用域的词法嵌套步数。\n-   **词法深度 `h` 定义**：从使用点到声明点在静态嵌套结构中向外移动的步数。\n-   **目标**：找到一个算法来计算 `h` 以及地址计算对应的 display 索引 (`基址 = D[index] + 偏移量`)。\n-   **程序结构和层级**：\n    -   全局环境：静态嵌套层级 $0$。\n    -   过程 P：静态嵌套层级 $1$，声明变量 `a`。\n    -   过程 Q (嵌套在 P 中)：静态嵌套层级 $2$，声明变量 `b`。\n    -   过程 R (嵌套在 Q 中)：静态嵌套层级 $3$。\n-   **待分析的标识符使用**：\n    1.  R 中对 `a` 的使用。\n    2.  R 中对 `b` 的使用。\n    3.  Q 中 (R 之外) 对 `a` 的使用。\n    4.  P 中 (Q 之外) 对 `a` 的使用。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题牢固地植根于为块结构、静态作用域语言进行编译器设计的既定原则。静态嵌套、活动记录和用于处理非局部变量访问的 display 机制等概念是计算机科学中的经典主题。该问题在科学上是合理的。\n-   **良构性**：该问题是良构的。它为所有术语（静态层级、词法深度）提供了清晰的定义，一个具体的程序结构，以及一个需要回答的特定问题。基于标准的编译器算法，存在一个唯一且稳定的解。\n-   **客观性**：该问题使用了编译器构造领域常见的精确、客观和技术性的术语来陈述。它没有歧义或主观断言。\n-   **完整性和一致性**：该问题是自洽的。所有关于语言语义、编译器数据结构和示例程序的必要信息都已提供。没有内部矛盾。\n\n### 步骤 3：结论和行动\n\n问题陈述有效。它提出了一个编译器理论中的标准、定义明确的问题。可以继续求解过程。\n\n### 基于原则的推导\n\n在具有嵌套过程的静态作用域语言中，编译器必须根据程序的词法结构来解析标识符引用。display 机制是对此的一种运行时优化。\n\n1.  **静态嵌套层级**：设 $L(\\text{scope})$ 表示给定作用域的静态嵌套层级。根据问题：\n    -   $L(\\text{global}) = 0$\n    -   $L(P) = 1$\n    -   $L(Q) = 2$\n    -   $L(R) = 3$\n\n2.  **符号表和 AST 遍历**：编译器通常对 AST 执行深度优先遍历。它维护一个符号表栈，对应于词法外围作用域链。当进入一个层级为 $L(S)$ 的作用域 `S` 时，会为 `S` 创建一个新的符号表。当声明一个变量 `x` 时，它被录入当前作用域的符号表，并且其声明层级 $L_d$ 被记录为当前层级。\n\n3.  **解析标识符使用**：当在一个层级为 $L_u = L(U)$ 的作用域 `U` 中遇到对标识符 `x` 的使用时，编译器会搜索其声明。静态作用域规则规定，搜索从 `U` 的符号表开始，如果未找到，则继续到其词法外围作用域的符号表，依此类推，直到在某个作用域 `S_d` 中找到声明。设声明层级为 $L_d = L(S_d)$。\n\n4.  **计算词法深度 `h`**：问题将 `h` 定义为从使用点到声明点向外移动的步数。这恰好是使用作用域和声明作用域的静态嵌套层级之差。\n    $$h = L_u - L_d$$\n    局部变量的 $h=0$，因为 $L_u = L_d$。非局部变量的 $h  0$。\n\n5.  **使用 Display `D`**：display `$D$` 是一个指针数组。在运行时，当作用域 `U` 内的代码正在执行时，`$D[i]$` 持有指向最近调用的、静态嵌套层级为 $i$ 的过程的活动记录 (AR) 的指针。要访问在层级 $L_d$ 声明的变量 `x`，程序必须找到 `x` 所在作用域的 AR 的基地址。此 AR 对应于静态层级 $L_d$。因此，正确的指针存储在 `$D[L_d]$` 中。display 的索引就是声明层级 $L_d$。\n\n6.  **关联 Display 索引与 `h`**：我们有两个关键方程：\n    -   $h = L_u - L_d$\n    -   $\\text{index} = L_d$\n    我们可以用 $L_u$ 和 $h$ 来表示索引。从第一个方程，得到 $L_d = L_u - h$。将此代入第二个方程得到：\n    $$\\text{index} = L_u - h$$\n    所以，对于一个在层级 $L_u$ 使用、词法深度为 $h$ 的变量，其地址计算为 `基址 = D[L_u - h] + 偏移量`。\n\n### 应用于示例程序\n\n让我们将这些原则应用于给定的使用情况。\n\n-   `a` 的声明在 P 中, 所以 $L_d(a) = 1$。\n-   `b` 的声明在 Q 中, 所以 $L_d(b) = 2$。\n\n1.  **R 中对 `a` 的使用**：\n    -   使用层级 $L_u = 3$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 3 - 1 = 2$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 3 - 2 = 1$）。\n    -   基址访问：`$D[1]$`。\n\n2.  **R 中对 `b` 的使用**：\n    -   使用层级 $L_u = 3$。声明层级 $L_d = 2$。\n    -   词法深度 $h = L_u - L_d = 3 - 2 = 1$。\n    -   Display 索引 = $L_d = 2$。（验证：$L_u - h = 3 - 1 = 2$）。\n    -   基址访问：`$D[2]$`。\n\n3.  **Q 中对 `a` 的使用**：\n    -   使用层级 $L_u = 2$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 2 - 1 = 1$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 2 - 1 = 1$）。\n    -   基址访问：`$D[1]$`。\n\n4.  **P 中对 `a` 的使用**：\n    -   使用层级 $L_u = 1$。声明层级 $L_d = 1$。\n    -   词法深度 $h = L_u - L_d = 1 - 1 = 0$。\n    -   Display 索引 = $L_d = 1$。（验证：$L_u - h = 1 - 0 = 1$）。\n    -   基址访问：`$D[1]$`。\n\n### 逐个选项分析\n\n**A. 遍历 AST，同时维护一个当前静态层级 $L$，从全局环境的 $0$ 开始，每进入一个新的词法作用域就加 $1$。首次遇到每个声明时，记录其层级 $L_d$。对于在层级为 $L_u$ 的作用域中的一次使用，找到最近的词法外圍声明，并将 $h$ 设置为 $L_u - L_d$。生成使用 $D[L_u - h]$ 作为标识符基址的代码。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$ 和基址 $D[1]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$ 和基址 $D[2]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$ 和基址 $D[1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[1]$。**\n\n-   **算法**：所描述的计算 $h$ 为 $L_u - L_d$ 并使用 display 索引 $L_u - h$ 的算法，与我们的推導完全一致。\n-   **应用**：\n    -   R 中使用 `a`：$h=3-1=2$，索引=$3-2=1$。基址 `$D[1]$`。与我们的计算相符。\n    -   R 中使用 `b`：$h=3-2=1$，索引=$3-1=2$。基址 `$D[2]$`。与我们的计算相符。\n    -   Q 中使用 `a`：$h=2-1=1$，索引=$2-1=1$。基址 `$D[1]$`。与我们的计算相符。\n    -   P 中使用 `a`：$h=1-1=0$，索引=$1-0=1$。基址 `$D[1]$`。与我们的计算相符。\n-   **结论**：**正确**。\n\n**B. 遍历 AST，同时维护一个当前静态层级 $L$，从 $1$ 开始，每进入一个新的作用域就加 $1$。对于在层级 $L_u$ 的一次使用，将 $h$ 设置为 $L_u - L_d$，并使用 $D[L_d + 1]$ 作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 3 - 1 = 2$ 和基址 $D[2]$；在 R 中，使用 b 得到 $h = 3 - 2 = 1$ 和基址 $D[3]$；在 Q 中，使用 a 得到 $h = 2 - 1 = 1$ 和基址 $D[2]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[2]$。**\n\n-   **算法**：display 索引的公式 `$D[L_d + 1]$` 是错误的。display 是直接由声明的静态嵌套层级 $L_d$ 索引的。`$+\\ 1$` 这一项没有根据。\n-   **应用**：对于 R 中 `a` 的使用，$L_d=1$。基址将是 `$D[1+1] = D[2]$`。我们正确的计算给出 `$D[1]$`。因此，该应用是错误的。\n-   **结论**：**错误**。\n\n**C. 遍历 AST，并为每个声明记录其层级 $L_d$。对于在层级 $L_u$ 的一次使用，计算 $h$ 为 $L_d - L_u$ 并使用 $D[h]$ 作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 1 - 3 = -2$ 和基址 $D[-2]$；在 R 中，使用 b 得到 $h = 2 - 3 = -1$ 和基址 $D[-1]$；在 Q 中，使用 a 得到 $h = 1 - 2 = -1$ 和基址 $D[-1]$；在 P 中，使用 a 得到 $h = 1 - 1 = 0$ 和基址 $D[0]$。**\n\n-   **算法**：`h` 定义为 $L_d - L_u$ 是反了。词法深度是外围作用域的非负计数。这个公式对于非局部访问会产生负值。使用负值 `h` 作为数组索引，例如 `$D[-2]$`，是无效的。\n-   **应用**：示例计算证实了这个缺陷，得出了负数索引。\n-   **结论**：**错误**。\n\n**D. 不遍历 AST 来确定静态层级；而是在每次使用点根据动态调用栈深度计算 $h$。对所有在层级 $L_u$ 使用的标识符，使用 $D[L_u]$ 作为基址。应用于该程序：在 R 中，使用 a 和 b 的基址均为 $D[3]$；在 Q 中，使用 a 的基址为 $D[2]$；在 P 中，使用 a 的基址为 $D[1]$。**\n\n-   **算法**：这描述了动态作用域（`根据动态调用栈深度计算 h`），直接与问题的静态作用域前提相矛盾。此外，使用 `$D[L_u]$` 作为所有变量的基址意味着所有变量都是当前作用域的局部变量，这违背了非局部访问的目的。\n-   **应用**：对于静态作用域语言，所提议的逻辑在根本上是错误的。\n-   **结论**：**错误**。\n\n**E. 遍历 AST 并将 $h$ 计算为 AST 中使用节点和声明节点之间唯一路径上的边数。使用 $D[h]$作为基址。应用于该程序：在 R 中，使用 a 得到 $h = 2$ 和基址 $D[2]$；在 R 中，使用 b 得到 $h = 1$ 和基址 $D[1]$；在 Q 中，使用 a 得到 $h = 1$ 和基址 $D[1]$；在 P 中，使用 a 得到 $h = 0$ 和基址 $D[0]$。**\n\n-   **算法**：display `$D$` 是按绝对静态嵌套层级索引的，而不是按相对词法深度 `h` 索引的。使用 `$D[h]$` 是一个根本性的误解。对于局部变量，$h=0$，该算法将使用 `$D[0]$`（全局 AR），这是不正确的。局部变量位于当前的 AR 中，由 `$D[L_u]$` 指向。\n-   **应用**：让我们检查 P 中 `a` 的使用。这是一个局部变量，所以 $h=0$。该选项声称基址是 `$D[0]`。这是错误的。变量 `a` 在 P (层级 $1$) 中声明，所以其数据在 P 的 AR 中，由 `$D[1]$` 指向。\n-   **结论**：**错误**。", "answer": "$$\\boxed{A}$$", "id": "3638316"}, {"introduction": "一个正确的实现固然很好，但一个高性能的实现更佳。此问题将带你进入优化领域，探讨一个经典的工程权衡。通过在高速寄存器中缓存 display 条目，我们可以加速非局部访问，但这会增加寄存器文件的压力。你将建立一个成本模型来分析这一权衡，并确定用于 display 的最佳寄存器数量，从而将编译器理论与计算机体系结构的知识联系起来。[@problem_id:3638307]", "problem": "在静态作用域语言中，非局部变量通过活动记录的 display 进行访问。display 是一个指向词法嵌套过程的帧指针数组，其中词法深度为 $\\ell$ 的条目允许以常数时间访问该深度的变量。一个面向具有 $R$ 个架构寄存器的机器的编译器，可以选择性地保留一些寄存器来存放 display 条目，以减少非局部访问延迟，但代价是增加了通用值的寄存器压力。当同时活跃的通用值的平均数量超过可用寄存器的数量时，就会发生寄存器溢出；每单位的溢出会产生一个预期的每指令代价。\n\n考虑一个 display 深度较小（$d = 3$）的程序。你可以为 display 条目保留整数个寄存器 $k$（$0 \\leq k \\leq d$），其中始终存放 $k$ 个最常需要的 display 条目（假设是 $k$ 个最顶层的词法层级）。该机器有 $R = 16$ 个寄存器。程序对通用活跃值的平均需求为每条指令 $W = 14$ 个寄存器。每条指令上每单位的寄存器短缺会产生 $c_s = 3$ 个周期的预期溢出代价。非局部变量访问以每条指令 $f = 0.2$ 的频率发生，且非局部访问的词法深度在 $d$ 个可能的层级上均匀分布。如果所需的 display 条目位于保留寄存器中，其成本可以忽略不计；否则，从内存加载 display 条目需要 $M = 25$ 个周期。\n\n假设使用以下简单模型：\n- 每条指令的预期非局部访问成本是 $f$ 乘以在均匀深度和 $k$ 个保留 display 条目下，单次非局部访问的预期成本。\n- 每条指令的溢出代价是 $c_s$ 乘以短缺量，其中短缺量为 $\\max\\{0,\\, W - (R - k)\\}$。\n- 在稳态下，所有事件在指令间是相互独立的。\n\n请从第一性原理出发，推导每条指令的预期周期数作为 $k$ 的函数表达式，并确定能使该预期成本最小化的整数 $k \\in \\{0,1,2,3\\}$。只需报告最优的 $k$ 作为你的最终答案。无需四舍五入。", "solution": "用户希望我解决这个问题。我必须先验证它。\n\n### 步骤 1：提取已知条件\n- Display 深度: $d = 3$\n- 为 display 条目保留的寄存器数量：$k$，一个整数，满足 $0 \\leq k \\leq d$\n- 总架构寄存器数量: $R = 16$\n- 每条指令的平均通用活跃值需求: $W = 14$\n- 每条指令上每单位寄存器短缺的溢出代价: $c_s = 3$ 周期\n- 每条指令的非局部变量访问频率: $f = 0.2$\n- 从内存加载 display 条目的成本: $M = 25$ 周期\n- 非局部访问的词法深度在 $d$ 个可能的层级上均匀分布。\n- $k$ 个保留寄存器存放 $k$ 个最顶层词法层级的条目。\n- 每条指令的预期非局部访问成本是 $f$ 乘以单次非局部访问的预期成本。\n- 每条指令的溢出代价是 $c_s$ 乘以短缺量，其中短缺量为 $\\max\\{0, W - (R - k)\\}$。\n\n### 步骤 2：使用提取的条件进行验证\n1.  **科学基础：** 问题描述了编译器设计中一个经典的权衡问题，即为特殊用途的数据结构（如 display）分配寄存器与为通用值分配寄存器之间的权衡。该模型虽然简化，但基于静态作用域、活动记录和寄存器压力的既定原则。寄存器溢出成本和内存访问延迟的概念是编译代码性能分析的基础。该问题具有科学合理性。\n2.  **适定性：** 问题要求在一个有限集合 $\\{0, 1, 2, 3\\}$ 中找到整数 $k$ 的值，以最小化一个明确定义的成本函数。由于定义域是有限的，最小值的存在得到保证。构建和评估成本函数所需的所有参数都已提供，确保可以确定唯一解。\n3.  **客观性：** 问题使用精确的定量语言陳述。所有用于计算成本的模型都已明确给出，没有主观解释的余地。\n4.  **不完整或矛盾的设置：** 问题是自洽的，提供了所有必要的数据和定义，没有矛盾之处。\n5.  **不切实际或不可行：** 所提供的数值（$R=16$，$W=14$ 等）对于一个真实处理器和程序的简化模型来说，处于一个合理的范围内。\n6 thorny_question **不适定或结构不良：** 问题结构清晰，要求进行特定的优化，逻辑直截了当。\n7.  **伪深刻、琐碎或同义反复：** 问题需要仔细推导和比较成本，是一个真正的优化问题，而非简单的练习。\n8.  **超出科学可验证性：** 结果可通过数学计算推导得出，因此是可验证的。\n\n### 步骤 3：结论与行动\n问题有效。我将继续进行求解。\n\n目标是找到整数 $k \\in \\{0, 1, 2, 3\\}$，使得每条指令的总预期成本 $C(k)$ 最小。该总成本是每条指令的预期溢出代价 $C_{\\text{spill}}(k)$ 与每条指令的预期非局部访问成本 $C_{\\text{nonlocal}}(k)$ 之和。\n$$C(k) = C_{\\text{spill}}(k) + C_{\\text{nonlocal}}(k)$$\n\n首先，我们来推导溢出代价的表达式 $C_{\\text{spill}}(k)$。\n架构寄存器的总数是 $R = 16$。如果为 display 保留了 $k$ 个寄存器，则可用于通用值的寄存器数量为 $R - k$。\n对通用寄存器的平均需求是 $W = 14$。如果此需求超过可用供应，则会发生寄存器短缺。\n短缺量 $S(k)$ 定义为：\n$$S(k) = \\max\\{0, W - (R - k)\\}$$\n代入给定值 $W = 14$ 和 $R = 16$：\n$$S(k) = \\max\\{0, 14 - (16 - k)\\} = \\max\\{0, 14 - 16 + k\\} = \\max\\{0, k - 2\\}$$\n每条指令的溢出代价是短缺量乘以单位短缺成本 $c_s = 3$。\n$$C_{\\text{spill}}(k) = c_s \\cdot S(k) = 3 \\cdot \\max\\{0, k - 2\\}$$\n\n接下来，我们推导非局部访问成本的表达式 $C_{\\text{nonlocal}}(k)$。\n非局部访问以每条指令 $f = 0.2$ 的频率发生。此类访问的成本取决于所需的 display 条目是在寄存器中还是在内存中。\nDisplay 深度为 $d = 3$。非局部访问的词法深度在 $d$ 个层级上均匀分布。访问任何特定层级的概率为 $\\frac{1}{d} = \\frac{1}{3}$。\n$k$ 个保留寄存器存放 $k$ 个最顶层词法层级（层级 $1, 2, \\dots, k$）的 display 条目。访问这些层级之一的成本为 $0$。\n剩下的 $d-k$ 个层级不在寄存器中。访问这些层级之一（层级 $k+1, \\dots, d$）需要从内存加载 display 条目，成本为 $M = 25$ 个周期。\n给定一次非局部访问，其条目在寄存器中的概率为 $\\frac{k}{d}$。\n给定一次非局部访问，其条目在内存中的概率为 $\\frac{d-k}{d}$。\n单次非局部访问的预期成本 $E_{\\text{access}}(k)$ 为：\n$$E_{\\text{access}}(k) = \\left(\\frac{k}{d}\\right) \\cdot 0 + \\left(\\frac{d-k}{d}\\right) \\cdot M = \\frac{d-k}{d} M$$\n每条指令的预期非局部访问成本是该值乘以非局部访问的频率 $f$。\n$$C_{\\text{nonlocal}}(k) = f \\cdot E_{\\text{access}}(k) = f \\cdot M \\cdot \\frac{d-k}{d}$$\n代入给定值 $f = 0.2$、$M = 25$ 和 $d = 3$：\n$$C_{\\text{nonlocal}}(k) = 0.2 \\cdot 25 \\cdot \\frac{3-k}{3} = 5 \\cdot \\frac{3-k}{3}$$\n\n现在我们可以写出总成本函数 $C(k)$：\n$$C(k) = 3 \\cdot \\max\\{0, k - 2\\} + 5 \\cdot \\frac{3-k}{3}$$\n我们必须对定义域 $\\{0, 1, 2, 3\\}$ 中每个可能的整数 $k$ 值评估此函数。\n\n对于 $k = 0$：\n$$C(0) = 3 \\cdot \\max\\{0, 0 - 2\\} + 5 \\cdot \\frac{3-0}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{3}{3} = 0 + 5 = 5$$\n\n对于 $k = 1$：\n$$C(1) = 3 \\cdot \\max\\{0, 1 - 2\\} + 5 \\cdot \\frac{3-1}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{2}{3} = 0 + \\frac{10}{3} \\approx 3.33$$\n\n对于 $k = 2$：\n$$C(2) = 3 \\cdot \\max\\{0, 2 - 2\\} + 5 \\cdot \\frac{3-2}{3} = 3 \\cdot 0 + 5 \\cdot \\frac{1}{3} = 0 + \\frac{5}{3} \\approx 1.67$$\n\n对于 $k = 3$：\n$$C(3) = 3 \\cdot \\max\\{0, 3 - 2\\} + 5 \\cdot \\frac{3-3}{3} = 3 \\cdot 1 + 5 \\cdot \\frac{0}{3} = 3 + 0 = 3$$\n\n我们比较每个 $k$ 值的总成本：\n$C(0) = 5 = \\frac{15}{3}$\n$C(1) = \\frac{10}{3}$\n$C(2) = \\frac{5}{3}$\n$C(3) = 3 = \\frac{9}{3}$\n\n最小成本为 $\\frac{5}{3}$，出现在 $k=2$ 时。因此，为 display 保留 $k=2$ 个寄存器可以最小化每条指令的总预期周期数。", "answer": "$$\\boxed{2}$$", "id": "3638307"}]}