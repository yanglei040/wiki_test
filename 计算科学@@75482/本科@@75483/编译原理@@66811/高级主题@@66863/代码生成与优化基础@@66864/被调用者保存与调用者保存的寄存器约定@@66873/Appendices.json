{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的第一个练习将带你深入调用约定的核心权衡。我们将分析一个具体的场景：两个相互频繁调用的函数，你需要为每个寄存器独立选择是作为“调用者保存”还是“被调用者保存”，以最小化整个程序的寄存器保存和恢复开销。这个练习旨在让你亲手计算和比较不同策略的成本，从而将抽象的定义转化为具体的性能考量 [@problem_id:3626228]。", "problem": "两个相互递归的函数 $A$ 和 $B$ 在一个自定义的应用二进制接口 (ABI) 下执行，其中每个寄存器的调用约定（指定寄存器为被调用者保存或调用者保存）都可以选择。该架构提供了一个统一的成本模型：每次将寄存器保存到栈或从栈中恢复的成本为 $\\sigma$ 个周期，其中 $\\sigma = 5$ 个周期。每次保存都与一次相应的恢复配对，因此一次保存-恢复对的成本为 $2\\sigma$ 个周期。假设没有优化会消除冗余的保存或恢复操作，并且所选约定要求的所有保存和恢复都会被执行。\n\n在一次有限的运行中，测得的动态计数如下：进入函数 $A$ 的次数为 $N_A = 310$，进入函数 $B$ 的次数为 $N_B = 300$，从 $A$ 调用 $B$ 的次数为 $C_{AB} = 300$，从 $B$ 调用 $A$ 的次数为 $C_{BA} = 300$。对于函数 $A$，跨调用活跃（并在函数内部使用）的寄存器集合为 $L_A = \\{r_1, r_2, r_5\\}$；对于函数 $B$，该集合为 $L_B = \\{r_2, r_3, r_5\\}$。相关的通用寄存器全集为 $R = \\{r_1, r_2, r_3, r_4, r_5, r_6\\}$，但在这次运行中，只有并集 $U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$ 出现在活跃集合中。\n\n根据调用约定的基本定义：\n- 如果一个寄存器 $r$ 被指定为被调用者保存，并且函数 $F$ 使用了 $r$，那么每次进入 $F$ 时，该函数必须保存 $r$，并在退出时恢复 $r$，每次进入 $F$ 会产生 $2\\sigma$ 个周期的成本。\n- 如果一个寄存器 $r$ 被指定为调用者保存，并且在调用点它在调用者中是活跃的，那么调用者必须在调用前保存 $r$，并在调用后恢复 $r$，每次此类调用会产生 $2\\sigma$ 个周期的成本。\n\n你可以为 $U$ 中的每个寄存器独立地指定其为被调用者保存还是调用者保存。在这些规则和给定的动态计数下，确定整个运行过程中可能的最小总动态保存/恢复开销，以周期为单位。提供一个单一的数值答案；无需四舍五入。最终答案以周期表示。", "solution": "用户希望我按照以下步骤解决问题：\n1.  **提取已知条件**：我将列出所有提供的数据、变量、常数和条件。\n2.  **验证**：我将检查问题的科学合理性、自洽性和良构性。\n3.  **求解**：如果问题有效，我将提供分步解答。\n\n### 第1步：提取已知条件\n- 单次寄存器保存或恢复操作的成本：$\\sigma = 5$ 个周期。\n- 一次保存-恢复对的成本：$2\\sigma = 10$ 个周期。\n- 进入函数 $A$ 的次数：$N_A = 310$。\n- 进入函数 $B$ 的次数：$N_B = 300$。\n- 从 $A$ 调用 $B$ 的次数：$C_{AB} = 300$。\n- 从 $B$ 调用 $A$ 的次数：$C_{BA} = 300$。\n- 函数 $A$ 中跨调用活跃的寄存器集合：$L_A = \\{r_1, r_2, r_5\\}$。\n- 函数 $B$ 中跨调用活跃的寄存器集合：$L_B = \\{r_2, r_3, r_5\\}$。\n- 相关的寄存器全集：$U = L_A \\cup L_B = \\{r_1, r_2, r_3, r_5\\}$。\n\n### 第2步：使用已知条件进行验证\n- **科学依据**：该问题基于计算机体系结构和编译器设计的原理，特别是关于调用约定和寄存器分配。被调用者保存和调用者保存寄存器、函数调用开销以及活跃性分析等概念都是标准且明确定义的。\n- **良构性**：该问题要求计算可能的最小开销，这是一个明确定义的优化问题。计算开销的规则是明确且无歧义的。所提供的数据足以计算每种可能的寄存器约定分配的成本。\n- **一致性**：动态计数是一致的。函数 $A$ 的进入次数为 $N_A = 310$ 次，从 $B$ 到 $A$ 的调用次数为 $C_{BA} = 300$ 次，这意味着有 $N_A - C_{BA} = 310 - 300 = 10$ 次是从外部上下文对 $A$ 的初始进入。函数 $B$ 的进入次数为 $N_B = 300$ 次，从 $A$ 到 $B$ 的调用次数为 $C_{AB} = 300$ 次，这意味着所有对 $B$ 的进入都源于 $A$。这描述了一个有效的执行轨迹。\n- **客观性**：该问题使用客观的、定量的数据和形式化定义进行陈述。\n\n该问题是有效的。\n\n### 第3步：求解\n目标是为集合 $U = \\{r_1, r_2, r_3, r_5\\}$ 中的每个寄存器确定一个调用约定，以最小化总的动态保存/恢复开销。每个寄存器的选择（被调用者保存 vs. 调用者保存）是独立的。因此，我们可以为每个寄存器单独最小化开销，然后将结果相加得到总的最小开销。\n\n对于任何寄存器 $r$，我们必须比较将其指定为被调用者保存与调用者保存的成本。一次保存-恢复对的成本是 $2\\sigma = 2 \\times 5 = 10$ 个周期。\n\n**被调用者保存约定的成本**\n如果一个寄存器 $r$ 被指定为被调用者保存，那么如果被调用的函数自身使用了该寄存器，它必须在进入时保存它，在退出时恢复它。问题陈述一个函数 $F$ “使用”寄存器 $r$ 是指 $r$ 在其活跃集合 $L_F$ 中。\n对于一个被调用者保存的寄存器 $r$，其总成本是使用它的每个函数所产生的成本之和。\n- 如果函数 $A$ 使用 $r$（即 $r \\in L_A$），由于 $A$ 被进入了 $N_A$ 次，产生的成本为 $N_A \\times 2\\sigma$。\n- 如果函数 $B$ 使用 $r$（即 $r \\in L_B$），由于 $B$ 被进入了 $N_B$ 次，产生的成本为 $N_B \\times 2\\sigma$。\n\n一个被调用者保存的寄存器 $r$ 的总成本为：\n$$Cost_{callee}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot N_A + \\mathbb{I}(r \\in L_B) \\cdot N_B)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，如果条件为真则为 $1$，否则为 $0$。\n\n**调用者保存约定的成本**\n如果一个寄存器 $r$ 被指定为调用者保存，那么如果该寄存器的值在调用者中是活跃的，调用者函数必须在调用前保存它，并在调用后恢复它。\n- 函数 $A$ 对 $B$ 进行了 $C_{AB}$ 次调用。如果 $r$ 在 $A$ 中是活跃的（即 $r \\in L_A$），则每次调用都需要进行一次保存/恢复。成本为 $C_{AB} \\times 2\\sigma$。\n- 函数 $B$ 对 $A$ 进行了 $C_{BA}$ 次调用。如果 $r$ 在 $B$ 中是活跃的（即 $r \\in L_B$），则每次调用都需要进行一次保存/恢复。成本为 $C_{BA} \\times 2\\sigma$。\n\n一个调用者保存的寄存器 $r$ 的总成本为：\n$$Cost_{caller}(r) = 2\\sigma \\times (\\mathbb{I}(r \\in L_A) \\cdot C_{AB} + \\mathbb{I}(r \\in L_B) \\cdot C_{BA})$$\n\n现在，我们计算 $U$ 中每个寄存器的最小成本。\n\n**对于寄存器 $r_1$：**\n$r_1 \\in L_A$ 且 $r_1 \\notin L_B$。\n- $Cost_{callee}(r_1) = 2\\sigma \\times (1 \\cdot N_A + 0 \\cdot N_B) = 10 \\times 310 = 3100$ 个周期。\n- $Cost_{caller}(r_1) = 2\\sigma \\times (1 \\cdot C_{AB} + 0 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 个周期。\n$r_1$ 的最小成本是 $\\min(3100, 3000) = 3000$ 个周期。这是通过将 $r_1$ 设为调用者保存来实现的。\n\n**对于寄存器 $r_2$：**\n$r_2 \\in L_A$ 且 $r_2 \\in L_B$。\n- $Cost_{callee}(r_2) = 2\\sigma \\times (1 \\cdot N_A + 1 \\cdot N_B) = 10 \\times (310 + 300) = 10 \\times 610 = 6100$ 个周期。\n- $Cost_{caller}(r_2) = 2\\sigma \\times (1 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times (300 + 300) = 10 \\times 600 = 6000$ 个周期。\n$r_2$ 的最小成本是 $\\min(6100, 6000) = 6000$ 个周期。这是通过将 $r_2$ 设为调用者保存来实现的。\n\n**对于寄存器 $r_3$：**\n$r_3 \\notin L_A$ 且 $r_3 \\in L_B$。\n- $Cost_{callee}(r_3) = 2\\sigma \\times (0 \\cdot N_A + 1 \\cdot N_B) = 10 \\times 300 = 3000$ 个周期。\n- $Cost_{caller}(r_3) = 2\\sigma \\times (0 \\cdot C_{AB} + 1 \\cdot C_{BA}) = 10 \\times 300 = 3000$ 个周期。\n$r_3$ 的最小成本是 $\\min(3000, 3000) = 3000$ 个周期。无论采用哪种约定，成本都相同。\n\n**对于寄存器 $r_5$：**\n$r_5 \\in L_A$ 且 $r_5 \\in L_B$。这种情况与 $r_2$ 相同。\n- $Cost_{callee}(r_5) = 10 \\times (310 + 300) = 6100$ 个周期。\n- $Cost_{caller}(r_5) = 10 \\times (300 + 300) = 6000$ 个周期。\n$r_5$ 的最小成本是 $\\min(6100, 6000) = 6000$ 个周期。这是通过将 $r_5$ 设为调用者保存来实现的。\n\n**最小总开销**\n最小总开销是 $U$ 中每个寄存器的最小成本之和。$U$ 之外的寄存器（即 $r_4$ 和 $r_6$）在 $A$ 或 $B$ 的任何调用中都不是活跃的，因此它们不会产生保存/恢复开销。\n$$Cost_{total} = \\min Cost(r_1) + \\min Cost(r_2) + \\min Cost(r_3) + \\min Cost(r_5)$$\n$$Cost_{total} = 3000 + 6000 + 3000 + 6000 = 18000$$\n\n整个运行过程中可能的最小总动态保存/恢复开销为 $18000$ 个周期。", "answer": "$$\\boxed{18000}$$", "id": "3626228"}, {"introduction": "在掌握了针对特定场景的成本分析之后，我们现在将视角提升到更宏观的层面：如何为整个系统设计调用约定。这个练习要求你构建一个简化的概率模型，根据程序中叶函数（不进行任何其他调用的函数）和非叶函数调用的比例，来推导出一个决定性的阈值。通过这个练习，你将学会如何运用数学模型来指导应用程序二进制接口（ABI）的设计，这对于编译器和操作系统开发者来说是一项至关重要的技能 [@problem_id:3626283]。", "problem": "编译器后端必须为一组 $n$ 个可分配的通用寄存器 (GPR) 选择一种调用约定。在调用者保存约定下，调用者必须保存并在之后重新加载任何位于这 $n$ 个寄存器中且跨调用活跃的值，因为被调用者可能会破坏它们。在被调用者保存约定下，如果被调用者使用了这 $n$ 个寄存器，它必须在其执行期间保护这些寄存器的内容（通过在其函数序言中保存并在函数结语中恢复）。考虑一个应用程序二进制接口 (ABI) 的设计决策，其中程序中的调用有 $p$ 的概率是调用叶函数，有 $1-p$ 的概率是调用非叶函数，其中叶函数是指不进行任何进一步调用的函数。\n\n假设采用以下简化且科学合理的模型：\n- 在一个调用点，调用者平均有一个大小为 $\\ell$ 的跨调用活跃值集合。只有当前位于所讨论的 $n$ 个寄存器中的活跃值才有被破坏的风险；超出这 $n$ 个寄存器的值已经被放置在内存中，因此不会因该约定而产生额外的保存操作。每次保存和每次重新加载都计为一次内存操作。\n- 在调用者保存约定下，调用者在调用前保存、并在调用后重新加载占据这 $n$ 个寄存器的 $\\min(\\ell,n)$ 个活跃值中的每一个，每次调用导致 $2\\min(\\ell,n)$ 次内存操作。\n- 在被调用者保存约定下，一个叶被调用函数可以被编译为不使用这 $n$ 个寄存器中的任何一个（它可以将其临时变量限制在调用者保存的资源中），从而产生 $0$ 次保存和 $0$ 次重新加载。一个非叶被调用函数在其执行过程中最终会使用所有这 $n$ 个寄存器，导致它保存和重新加载所有 $n$ 个寄存器，总共产生 $2n$ 次内存操作。因此，在被调用者保存约定下，每次调用的期望内存操作数为 $2\\big(p\\cdot 0 + (1-p)\\cdot n\\big) = 2(1-p)n$。\n\n使用这些假设和期望的线性性质，推导出精确阈值 $p^{*}$ 的一个关于 $n$ 和 $\\ell$ 的闭式解析表达式，使得当 $p  p^{*}$ 时，调用者保存约定的期望溢出-重载成本严格低于被调用者保存约定。仅提供 $p^{*}$ 的表达式；不要计算任何数值，也不要四舍五入。你的最终答案必须是 $p^{*}$ 的单个解析表达式。", "solution": "核心是比较调用者保存约定下每次调用的期望溢出-重载成本与被调用者保存约定下每次调用的期望溢出-重载成本。\n\n根据调用者保存的定义，任何位于指定的 $n$ 个寄存器中且跨调用活跃的值都必须在调用前保存并在调用后重新加载，因为被调用者可能会破坏它们。在所述模型下，在一个调用点，这类值的数量是 $\\min(\\ell,n)$。每次保存和每次重新加载都计为一次内存操作。因此，每次调用的成本是\n$$\nC_{\\text{caller}} \\;=\\; 2\\,\\min(\\ell,n).\n$$\n\n根据被调用者保存的定义，如果被调用者在其执行过程中使用了指定的 $n$ 个寄存器，它就必须保护这些寄存器的内容，这是通过在函数序言中保存它们并在函数结语中恢复它们来实现的。在该模型下：\n- 以概率 $p$，被调用者是叶函数。一个叶被调用函数可以被编译为完全不使用这 $n$ 个寄存器（它将其临时变量限制在调用者保存的资源中），产生 $0$ 次保存和 $0$ 次重新加载，即 $0$ 次内存操作。\n- 以概率 $1-p$，被调用者是非叶函数。一个非叶被调用函数最终会使用所有这 $n$ 个寄存器，并且必须保存和重新加载所有这 $n$ 个寄存器，即 $2n$ 次内存操作。\n\n那么，被调用者保存约定下的期望成本是\n$$\nC_{\\text{callee}} \\;=\\; \\mathbb{E}[\\text{memory ops}] \\;=\\; 2\\big(p\\cdot 0 + (1-p)\\cdot n\\big) \\;=\\; 2(1-p)\\,n,\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示期望，并使用了期望的线性性质。\n\n当以下条件成立时，调用者保存约定具有严格更低的期望成本：\n$$\nC_{\\text{caller}} \\; \\; C_{\\text{callee}}\n\\quad\\Longleftrightarrow\\quad\n2\\,\\min(\\ell,n) \\; \\; 2(1-p)\\,n.\n$$\n两边同除以 $2$ 得到\n$$\n\\min(\\ell,n) \\; \\; (1-p)\\,n.\n$$\n解出 $p$：\n$$\n1-p \\;\\; \\frac{\\min(\\ell,n)}{n}\n\\quad\\Longleftrightarrow\\quad\np \\; \\; 1 \\;-\\; \\frac{\\min(\\ell,n)}{n}.\n$$\n因此，调用者保存约定从有优势变为没有优势的阈值 $p^{*}$（即，调用者保存约定仍然有优势的最大 $p$ 值）是\n$$\np^{*} \\;=\\; 1 \\;-\\; \\frac{\\min(\\ell,n)}{n}.\n$$\n\n这个表达式是良定义的，因为 $\\min(\\ell,n)$ 介于 $0$ 和 $n$ 之间，所以 $\\frac{\\min(\\ell,n)}{n}$ 位于 $[0,1]$ 区间内，这意味着 $p^{*}\\in[0,1]$。两个极限情况可以说明其解释：\n- 如果 $\\ell \\ge n$，那么 $\\min(\\ell,n)=n$ 且 $p^{*}=0$，这意味着除非 $p=0$（所有调用都是非叶调用），否则调用者保存约定永远不会有更低的期望成本，这与 $C_{\\text{caller}}=2n$ 对比 $C_{\\text{callee}}=2(1-p)n$ 的情况是一致的。\n- 如果 $\\ell$ 相对于 $n$ 很小，那么 $p^{*}$ 接近 $1$，表明对于低于该阈值的广泛 $p$ 值范围，调用者保存约定有优势；而当大多数调用是叶调用时（即 $p$ 很大），被调用者保存约定有优势，这与模型的直觉相符。", "answer": "$$\\boxed{1-\\frac{\\min(\\ell,n)}{n}}$$", "id": "3626283"}, {"introduction": "性能优化固然重要，但程序的正确性是不可动摇的基石。编译器与代码之间关于调用约定的“承诺”是一个关键的系统契约，一旦被破坏，可能导致难以察觉的数据损坏。本练习将让你扮演一位测试工程师的角色，你的任务是设计一个可靠的自动化测试方案，以验证编译器是否正确遵守了“被调用者保存”的约定。通过分析不同的测试策略，你将深入理解在复杂的系统环境中确保软件正确性的挑战与方法 [@problem_id:3626201]。", "problem": "您正在评估一个编译器的代码生成器是否正确实现了关于被调用者保存（callee-saved）和调用者保存（caller-saved）寄存器约定的应用程序二进制接口（ABI）。假设机器有一组有限的通用寄存器，记为 $R$，它被划分为一个被调用者保存的子集 $R_c$ 和一个调用者保存的子集 $R_{k}$，使得 $R = R_c \\cup R_{k}$ 且 $R_c \\cap R_{k} = \\varnothing$。根据 ABI 和调用约定的定义，对于任何函数 $f$，如果 $f$ 在一个遵守 ABI 的上下文中被调用，那么在正常返回时，所有 $R_c$ 中寄存器的内容必须与调用入口时的内容完全相同；调用者负责保存在 $R_k$ 中任何需要的值。假设是单线程执行，并且您可以根据需要发出内联汇编和原始汇编，但优化编译器可能会重排指令，除非被适当的屏障所阻止。您想构建一个自动化测试工具，它能生成声称遵循该约定的随机函数 $\\{f_i\\}_{i=1}^{N}$，然后通过在调用入口处将“金丝雀”值（canary values）放入 $R_c$ 中，让 $f_i$ 执行，并在返回时检查这些金丝雀值是否保持不变，从而验证其合规性。\n\n在不引入可避免的假阳性（false positives）或假阴性（false negatives）的情况下，以下哪个测试计划最能可靠地检测出对 $R_c$ 中被调用者保存约定的违反？选择所有适用的选项。\n\nA. 构建一个小型汇编测试工具，在调用被测函数 $f_i$ 之前，执行以下步骤：使用显式的、针对特定寄存器的移动指令，将不同的金丝雀值加载到 $R_c$ 中的每个寄存器；将 $R_k$ 中的所有调用者保存的寄存器保存到一个私有的、对齐的栈上暂存区；发出一个编译器屏障，该屏障对高级编译器而言会破坏（clobbers）内存和所有 $R$ 中的寄存器，以防止跨调用点的重排；通过一个位于单独编译且禁用内联的翻译单元中的函数指针间接调用 $f_i$；返回后，首先从暂存区恢复 $R_k$，然后将 $R_c$ 中所有寄存器的当前内容与原始金丝雀值进行比较。生成的 $f_i$ 可能包含嵌套调用和任意的寄存器压力，但必须正常返回。$R_c$ 中的任何不匹配都被报告为违规。\n\nB. 编写一个高级语言测试工具，将金丝雀常量存储在 volatile 局部变量中，并依赖优化编译器将这些变量分配到 $R_c$ 中。然后它直接调用 $f_i$，返回后，将这些 volatile 变量与常量进行比较。如果匹配，则认为 $f_i$ 合规；否则，不合规。不使用特殊的编译器屏障或反内联措施。\n\nC. 对每个生成的函数 $f_i$ 进行插桩（instrument），在其入口处注入将 $R_c$ 中所有寄存器存储到其栈帧的操作，并在每个返回点注入将相同 $R_c$ 位置的值加载回寄存器的操作，然后如果注入的加载与注入的存储相匹配，则报告成功。不要在调用者中放置金丝雀值，也不要在调用边界检查 $R_c$。\n\nD. 使用一个汇编测试工具，将金丝雀值写入 $R_c$，调用 $f_i$，并在返回时检查 $R_c$。为了增加覆盖率，启用随机异步信号传递，其处理程序在调用期间执行可能触及通用寄存器的任意代码。$R_c$ 中的任何不匹配都归因于 $f_i$ 并报告为违规。\n\nE. 使用一个汇编测试工具，将金丝雀值放入 $R_c$，并立即调用以积极优化和启用内联方式编译的 $f_i$。不阻止内联或尾调用优化，也不保存 $R_k$。调用后，检查 $R_c$ 是否与金丝雀值相等；如果不等，则报告违规。\n\n假设在所有使用汇编的选项中，测试工具都遵守栈对齐、阴影空间（shadow space）和任何强制的红色区域（red zones）。您也可以假设金丝雀值是从 $w$ 位字长空间上的一个分布中抽取的，其中 $w$ 是机器字长，并且测试工具会记录其写入的确切金丝雀值以供后续比较。根据上述 ABI 定义，选择方法论上合理的一个或多个选项。", "solution": "问题要求设计一个可靠的测试工具，以验证编译器是否遵守由应用程序二进制接口（ABI）定义的被调用者保存寄存器约定。一个可靠的测试必须能准确地检测违规（真阳性），同时避免误报（假阳性）和漏报（假阴性）。要测试的核心原则是，对于任何函数 $f$，在其返回时，被调用者保存寄存器集合 $R_c$ 中的值必须与调用时刻的值完全相同。\n\n让我们分析每个提议的测试计划。\n\n**A. 构建一个小型汇编测试工具，在调用被测函数 $f_i$ 之前，执行以下步骤：使用显式的、针对特定寄存器的移动指令，将不同的金丝雀值加载到 $R_c$ 中的每个寄存器；将 $R_k$ 中的所有调用者保存的寄存器保存到一个私有的、对齐的栈上暂存区；发出一个编译器屏障，该屏障对高级编译器而言会破坏（clobbers）内存和所有 $R$ 中的寄存器，以防止跨调用点的重排；通过一个位于单独编译且禁用内联的翻译单元中的函数指针间接调用 $f_i$；返回后，首先从暂存区恢复 $R_k$，然后将 $R_c$ 中所有寄存器的当前内容与原始金丝雀值进行比较。生成的 $f_i$ 可能包含嵌套调用和任意的寄存器压力，但必须正常返回。$R_c$ 中的任何不匹配都被报告为违规。**\n\n此选项描述了一种方法论上合理且稳健的测试策略。\n1.  **汇编测试工具：** 使用汇编测试工具可以对 CPU 状态进行直接的底层控制，这对于将金丝雀值放入特定寄存器（$R_c$）并进行检查至关重要。这绕过了高级语言到寄存器映射的模糊性。\n2.  **保存 $R_k$：** 测试工具作为调用者，可能会使用 $R_k$ 中的寄存器进行自身操作（例如，循环计数器、检查阶段的指针）。根据 ABI，如果调用者需要这些值在调用后仍然有效，则有责任保存它们。这样做使测试工具本身变得稳健且符合 ABI，防止其自身逻辑因 $f_i$（预期中地）破坏 $R_k$ 而失败。\n3.  **编译器屏障：** `clobber` 屏障至关重要。它通知编译器，其对寄存器和内存状态的认知因调用 $f_i$ 而失效。这可以防止可能正在编译测试工具代码的优化编译器对金丝雀值设置、函数调用和金丝雀值检查进行重排。如果没有这个屏障，优化器可能会将检查移到调用之前，或将设置移到调用之后，从而使测试毫无意义并导致假阴性。\n4.  **间接调用与禁止内联：** 通过函数指针间接调用 $f_i$，并确保它位于一个单独编译且禁用内联的单元中，这一点至关重要。这会强制生成一个真正的 `call` 指令，并将 $f_i$ 视为一个只能通过 ABI 进行通信的黑盒。如果 $f_i$ 被内联，编译器可以执行过程间优化，可能会“优化掉”我们试图检测的违规行为，从而导致假阴性。\n5.  **关于A的结论：** 该计划正确地隔离了被测单元（$f_i$），并确保了测试的设置和验证步骤不受编译器优化的影响。它在机器级别直接测试了 ABI 合约。因此，这是一种检测违规的可靠方法，产生假阳性或假阴性的概率很低。\n\n**结论：正确**\n\n**B. 编写一个高级语言测试工具，将金丝雀常量存储在 volatile 局部变量中，并依赖优化编译器将这些变量分配到 $R_c$ 中。然后它直接调用 $f_i$，返回后，将这些 volatile 变量与常量进行比较。如果匹配，则认为 $f_i$ 合规；否则，不合规。不使用特殊的编译器屏障或反内联措施。**\n\n这种方法存在根本性缺陷且不可靠。\n1.  **寄存器分配：** 在 C 或 C++ 等语言中，没有标准机制可以强制将局部变量放入特定寄存器，更不用说放入被调用者保存寄存器集合 $R_c$ 中的寄存器了。编译器可以自由地将变量存储在栈上或其选择的任何寄存器中（来自 $R_c$ 或 $R_k$）。`volatile` 关键字可以防止优化器省略对该变量内存位置的读/写，但它不影响寄存器分配。因此，测试甚至可能不会将金丝雀值放入 $R_c$ 中，从而导致大量的假阴性。\n2.  **直接调用和内联：** 直接调用 $f_i$ 而不采取措施防止内联，会让编译器在函数调用边界上进行优化。如选项 A 的解释所述，这可能会掩盖或消除违规，导致假阴性。\n3.  **无屏障：** 缺少编译器屏障允许优化器重排测试逻辑，从而使测试的前提失效。\n\n**结论：错误**\n\n**C. 对每个生成的函数 $f_i$ 进行插桩（instrument），在其入口处注入将 $R_c$ 中所有寄存器存储到其栈帧的操作，并在每个返回点注入将相同 $R_c$ 位置的值加载回寄存器的操作，然后如果注入的加载与注入的存储相匹配，则报告成功。不要在调用者中放置金丝雀值，也不要在调用边界检查 $R_c$。**\n\n这个计划测试了错误的对象。\n1.  **修改测试主体：** 所述的插桩将待测函数 $f_i$ 修改为一个新函数 $f_i'$。注入的代码（用于保存/恢复 $R_c$ 的标准函数序言/尾声）实际上*修正*了原始 $f_i$ 可能存在的任何被调用者保存寄存器的违规行为。\n2.  **保证成功：** 从其调用者的角度来看，经过插桩的函数 $f_i'$ 根据其构造将始终保留 $R_c$ 中的寄存器。内部检查（匹配注入的加载和存储）仅仅是验证插桩本身是否正常工作，而不是原始 $f_i$ 的代码是否合规。这将对任何不合规的函数导致 100% 的假阴性率。\n\n**结论：错误**\n\n**D. 使用一个汇编测试工具，将金丝雀值写入 $R_c$，调用 $f_i$，并在返回时检查 $R_c$。为了增加覆盖率，启用随机异步信号传递，其处理程序在调用期间执行可能触及通用寄存器的任意代码。$R_c$ 中的任何不匹配都归因于 $f_i$ 并报告为违规。**\n\n这种方法引入了混杂变量，使其变得不可靠。\n1.  **混淆问题：** 函数调用的 ABI 与处理异步信号或中断的 ABI 及系统级协议是不同的。当一个信号被传递时，操作系统负责保存被中断线程的完整上下文（包括 $R_c$ 和 $R_k$ 中的所有寄存器），运行信号处理程序，然后恢复该上下文。\n2.  **假阳性的来源：** 如果 $R_c$ 中某个寄存器的金丝雀值被破坏，该计划会将错误归咎于 $f_i$。然而，这种破坏可能是由于操作系统用于信号处理的上下文切换代码中的错误造成的。该测试不再是独立地测试 $f_i$；它同时也在测试操作系统。这违反了特定单元测试的原则，是潜在假阳性的直接原因。\n3.  **违反上下文：** 问题明确指出分析是在单线程执行的假设下进行的。异步信号引入了一种抢占和并发执行的形式（处理程序中断主线程），这使得为 ABI 定义的清晰的单线程模型变得复杂。\n\n**结论：错误**\n\n**E. 使用一个汇编测试工具，将金丝雀值放入 $R_c$，并立即调用以积极优化和启用内联方式编译的 $f_i$。不阻止内联或尾调用优化，也不保存 $R_k$。调用后，检查 $R_c$ 是否与金丝雀值相等；如果不等，则报告违规。**\n\n这个计划包含多个严重的方法论缺陷。\n1.  **内联和 TCO：** 与选项 B 一样，允许内联和尾调用优化（TCO）对测试的可靠性是致命的。内联允许编译器对测试工具和 $f_i$ 的组合代码进行推理，可能隐藏违规行为（假阴性）。TCO 将 `call`/`ret` 序列替换为 `jmp`，这打破了 ABI 所约束的函数调用的基本模型。对 $f_i$ 的测试可能会变成对 $f_i$ 尾调用的另一个函数的测试。\n2.  **不保存 $R_k$：** 测试工具本身就是一个程序。如果在调用 $f_i$ 之后的检查逻辑依赖于它在调用前保存在调用者保存寄存器（$R_k$）中的值，那么不保存这些值将导致测试工具自身的失败。ABI 明确允许函数 $f_i$ 修改 $R_k$。这使得测试工具本身存在错误且不可靠。任何失败都可能是由于测试工具破坏了自身的状态，而不是 $f_i$ 中的违规行为。\n\n**结论：错误**\n\n**总结：**\n\n只有选项 A 提供了一个完整且方法论上严谨的框架来测试被调用者保存寄存器约定。它正确地使用了底层控制，隔离了测试对象，并保护了测试的完整性免受编译器优化的影响，从而最大限度地降低了假阳性和假阴性的风险。", "answer": "$$\\boxed{A}$$", "id": "3626201"}]}