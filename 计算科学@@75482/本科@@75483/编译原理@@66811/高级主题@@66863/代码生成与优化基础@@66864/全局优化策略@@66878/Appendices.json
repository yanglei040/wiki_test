{"hands_on_practices": [{"introduction": "全局优化的核心目标之一是识别并消除冗余计算。循环不变代码外提（Loop-Invariant Code Motion, LICM）是一种经典技术，它将循环内部每次迭代都产生相同结果的计算移动到循环之前。本练习 [@problem_id:3644311] 将带你深入实践该技术，你不仅需要通过范围分析来保证代码变换的安全性，还需要建立一个精确的成本模型来量化优化所带来的预期性能提升。", "problem": "一种具有强制性数组边界检查的语言的编译器，通过在可靠的范围分析能够保证安全性的情况下，将循环不变的边界检查提出循环来进行全局优化，并插入循环前守卫以保持程序语义。考虑逻辑长度分别为 $L_A$ 和 $L_B$ 的数组 $A$ 和 $B$，以及以下对归纳变量 $i$ 的循环：\n循环体为所有满足 $0 \\le i  n$ 的迭代计算一个标量累加 $s := s + A[i] \\cdot B[i+1]$。在未优化的基线版本中，编译器在每次迭代中插入动态检查，以确保 $A[i]$ 和 $B[i+1]$ 都在边界内。\n\n你需要使用从 $0 \\le i  n$ 推导出的范围分析，通过添加可靠的循环前守卫来将边界检查提出循环。然后，推导一个考虑了该全局转换的成本模型，并计算提出检查后的版本相对于基线版本的期望加速比。\n\n假设如下：\n- 对 $A[k]$ 的访问，其基本内存安全要求是 $0 \\le k \\le L_A - 1$，对 $B[k]$ 的访问也类似，要求是 $0 \\le k \\le L_B - 1$。\n- 循环精确执行 $n$ 次迭代，$i$ 的范围是 $0 \\le i  n$。\n- 不包括边界检查的每次迭代的基线成本是 $c_{\\ell}$ 个周期，用于算术和内存操作。\n- 在基线版本中，每次动态边界检查的成本为 $c_b$ 个周期，并且每次迭代执行两次（一次用于 $A[i]$，一次用于 $B[i+1]$）。\n- 在优化版本中，插入了两个循环前守卫，每个守卫评估的成本为 $c_g$ 个周期。如果守卫成功，循环执行时将不进行每次迭代的边界检查。如果任一守卫失败，执行将回退到带有每次迭代检查的基线版本。在进入循环前，守卫总会被评估一次，无论成功与否，其成本都会产生。\n- 在某次运行中，两个守卫都成功的概率是 $p$，它们失败（导致回退）的概率是 $1-p$。\n\n仅使用给定的定义和事实，首先使用范围分析和安全要求推导出必要的守卫条件，然后推导优化版本的期望运行时间。最后，对于具体参数 $n = 10^{6}$、$c_b = 7$、$c_{\\ell} = 6$、$c_g = 12$ 和 $p = 0.99$，计算期望加速比，即基线运行时间与期望优化运行时间的比值。\n\n将你的最终答案四舍五入到四位有效数字。最终答案必须是一个没有单位的实数值。", "solution": "问题陈述被评估为有效。它在科学上是可靠的、良构的、客观的和自洽的，代表了编译器优化分析中的一个标准问题。所有推导唯一解所需的常量、变量和条件均已提供。\n\n解决方案分三个阶段进行：首先，使用范围分析推导必要的循环前守卫条件；其次，为基线版本和优化版本建立成本模型，以推导出期望加速比的表达式；第三，代入给定的数值以计算最终答案。\n\n**1. 循环前守卫条件的推导**\n\n循环通过归纳变量 $i$ 在范围 $0 \\le i  n$ 上迭代。为使优化可靠，必须证明循环内的每一次数组访问对于 $i$ 的整个范围都是安全的。对于访问逻辑长度为 $L$ 的数组中索引为 $k$ 的元素，其安全要求是 $0 \\le k \\le L - 1$。\n\n- **对数组A的分析**：访问是 $A[i]$。索引变量是 $k = i$。\n  给定循环范围 $0 \\le i  n$，索引 $k$ 的最小值是 $0$，最大值是 $n-1$。\n  安全条件 $0 \\le k \\le L_A - 1$ 必须对 $[0, n-1]$ 中的所有 $k$ 值都成立。\n  - 下界检查 $0 \\le 0$ 恒成立。\n  - 上界检查要求最大索引 $n-1$ 在有效范围内：$n-1 \\le L_A - 1$。\n  此不等式化简为 $n \\le L_A$。因此，第一个守卫条件是 $n \\le L_A$。这个检查仅在 $n>0$ 时是必要的；如果 $n=0$，循环不执行，不会发生访问。\n\n- **对数组B的分析**：访问是 $B[i+1]$。索引是 $k = i+1$。\n  给定循环范围 $0 \\le i  n$，索引 $k$ 的范围是 $0+1 \\le i+1  n-1+1$，即 $1 \\le k  n$。索引 $k$ 的最小值是 $1$，最大值是 $n$。\n  安全条件 $0 \\le k \\le L_B - 1$ 必须对 $[1, n]$ 中的所有 $k$ 值都成立。\n  - 下界检查 $0 \\le 1$ 恒成立。\n  - 上界检查要求最大索引 $n$ 在有效范围内：$n \\le L_B - 1$。\n  此不等式也可以写成 $n+1 \\le L_B$。因此，第二个守卫条件是 $n+1 \\le L_B$。\n\n因此，两个可靠的循环前守卫是 ($1$) $n \\le L_A$ 和 ($2$) $n+1 \\le L_B$。\n\n**2. 成本模型和期望加速比的推导**\n\n- **基线运行时间 ($T_{base}$)**：在未优化的基线版本中，$n$ 次迭代中的每一次都会产生算术成本 ($c_{\\ell}$) 和两次边界检查的成本 ($2 \\cdot c_b$)。\n$$T_{base} = n \\cdot (c_{\\ell} + 2 c_b)$$\n\n- **期望优化运行时间 ($E[T_{opt}]$)**：优化版本的成本是概率性的。两个守卫评估总是会执行，产生 $2 c_g$ 的成本。\n  - 以概率 $p$，守卫成功。循环执行 $n$ 次，每次迭代只有算术成本 $c_{\\ell}$。这种情况下的总成本是 $T_{succ} = 2 c_g + n c_{\\ell}$。\n  - 以概率 $1-p$，至少一个守卫失败。执行回退到基线版本。总成本是守卫评估成本加上完整的基线成本：$T_{fail} = 2 c_g + T_{base} = 2 c_g + n(c_{\\ell} + 2 c_b)$。\n\n期望运行时间是这两种结果的加权平均值：\n$$E[T_{opt}] = p \\cdot T_{succ} + (1-p) \\cdot T_{fail}$$\n$$E[T_{opt}] = p(2 c_g + n c_{\\ell}) + (1-p)(2 c_g + n(c_{\\ell} + 2 c_b))$$\n我们可以简化这个表达式：\n$$E[T_{opt}] = p \\cdot 2 c_g + (1-p) \\cdot 2 c_g + p \\cdot n c_{\\ell} + (1-p) \\cdot n c_{\\ell} + (1-p) \\cdot n \\cdot 2 c_b$$\n$$E[T_{opt}] = (p + 1-p) \\cdot 2 c_g + (p + 1-p) \\cdot n c_{\\ell} + (1-p) \\cdot 2 n c_b$$\n$$E[T_{opt}] = 2 c_g + n c_{\\ell} + 2 n c_b (1-p)$$\n\n- **期望加速比 ($S$)**：加速比是基线运行时间与期望优化运行时间的比值。\n$$S = \\frac{T_{base}}{E[T_{opt}]} = \\frac{n(c_{\\ell} + 2 c_b)}{2 c_g + n c_{\\ell} + 2 n c_b (1-p)}$$\n\n**3. 数值计算**\n\n我们已知以下参数：\n- $n = 10^6$\n- $c_b = 7$\n- $c_{\\ell} = 6$\n- $c_g = 12$\n- $p = 0.99$\n\n首先，我们计算分子 $T_{base}$：\n$$T_{base} = 10^6 \\cdot (6 + 2 \\cdot 7) = 10^6 \\cdot (6 + 14) = 10^6 \\cdot 20 = 20,000,000$$\n\n接下来，我们计算分母 $E[T_{opt}]$：\n$$E[T_{opt}] = 2 \\cdot 12 + 10^6 \\cdot 6 + 2 \\cdot 10^6 \\cdot 7 \\cdot (1 - 0.99)$$\n$$E[T_{opt}] = 24 + 6,000,000 + 14 \\cdot 10^6 \\cdot 0.01$$\n$$E[T_{opt}] = 24 + 6,000,000 + 140,000$$\n$$E[T_{opt}] = 6,140,024$$\n\n最后，我们计算期望加速比 $S$：\n$$S = \\frac{20,000,000}{6,140,024} \\approx 3.2573136...$$\n\n将结果四舍五入到四位有效数字，得到 $3.257$。", "answer": "$$\\boxed{3.257}$$", "id": "3644311"}, {"introduction": "编译器的优化过程并非一系列孤立的步骤，一项优化决策可能会对后续阶段产生深远影响。这个练习 [@problem_id:3644344] 揭示了一个重要的权衡：循环不变代码外提虽然减少了重复计算，但可能因延长变量的生命周期而增加寄存器压力。当寄存器压力过大导致“溢出”（spilling）到内存时，其代价可能完全抵消甚至超过优化本身带来的好处。", "problem": "一个优化编译器考虑对一个内层循环应用循环不变代码外提 (Loop-Invariant Code Motion, LICM)。候选表达式是一个纯算术计算 $E$，其值在多次迭代中保持不变。该编译器面向一个顺序执行的中央处理器 (CPU)，并采用以下代价模型：\n- 每个非乘法的整数算术指令代价为 $1$ 个周期，一次乘法代价为 $6$ 个周期。\n- 每次内存加载或存储的代价为 $4$ 个周期。\n- 内存与计算之间没有重叠；代价线性相加。\n\n寄存器分配在循环体中使用线性扫描策略，有 $R$ 个可分配的整数寄存器。当同时活跃的临时变量数量超过 $R$ 时，恰好超出数量的临时变量会被溢出。一个每次迭代有 $u$ 次使用和 $1$ 次定义的溢出临时变量，会引发每次迭代 $u$ 次加载和 $1$ 次存储。根据标准的数据流活跃性定义，一个变量在某个程序点是活跃的，当且仅当其当前值可能在被覆盖之前沿某条路径被使用。\n\n对于此目标上的一个特定循环：\n- 一项活跃性分析显示，在应用 LICM 之前，循环中临时变量的峰值同时活跃数为 $L_0 = 8$，此峰值在循环体内的两个不同程序点 $P$ 和 $Q$ 达到。在 $Q$ 点，候选表达式 $E$ 被计算且其结果是活跃的；在 $P$ 点，候选表达式 $E$ 尚未计算且不活跃。\n- 分配器在循环体中有 $R = 8$ 个寄存器可用于这些临时变量，因此未优化的循环在分配时没有溢出。\n- 表达式 $E$ 是一个乘法，在循环内部计算时，其每次求值的代价为 $c_E = 6$ 个周期。\n- 如果应用 LICM，$E$ 在循环预处理器中计算一次，其结果在整个循环体中保持活跃。应用 LICM 后，在 $Q$ 点，$E$ 的长生命周期结果取代了迭代局部的临时变量，因此 $Q$ 点的活跃数保持为 $L_0$。在 $P$ 点，$E$ 的结果在基线活跃集之外也变为活跃，因此 $P$ 点的活跃数增加到 $L_0 + 1 = 9$，比 $R$ 多出 $1$，从而迫使整个循环中恰好有一个临时变量被溢出。\n- 所述的溢出临时变量每次迭代有 $u = 2$ 次使用和 $1$ 次定义，因此在此分配器下每次迭代会产生 $u + 1 = 3$ 次内存操作。每次内存操作的代价为 $c_{\\text{mem}} = 4$ 个周期。\n\n设循环执行次数为 $N \\ge 1$，并假设循环的所有其他部分在不同版本之间是相同的。\n\n在这些条件下，哪种说法最能描述将 $E$ 从循环中提出的端到端运行时影响？\n\nA. 对于所有 $N \\ge 1$，提出 $E$ 会减少总运行时，因为节省 $N$ 次乘法所带来的收益总是超过任何溢出代价。\n\nB. 对于所有 $N \\ge 1$，提出 $E$ 会增加总运行时，因为由寄存器压力增加而触发的每次迭代的溢出代价超过了节省的每次迭代计算 $E$ 的代价。\n\nC. 对于任何 $N \\ge 1$，提出 $E$ 对总运行时没有影响，因为 $Q$ 点的活跃数未改变且没有发生溢出。\n\nD. 提出 $E$ 仅在循环次数超过某个阈值 $N^\\star$（其中 $N^\\star$ 是某个正整数）后才是有利的，因为即使发生溢出，一次性的预处理器代价也必须在多次迭代中被分摊。", "solution": "用户想要在一个特定的代价模型下确定应用循环不变代码外提 (LICM) 的运行时影响，在该模型中，此优化会增加寄存器压力并导致溢出。为此，我们必须正式地计算优化和未优化情况下循环的总执行代价，并将其表示为循环执行次数 $N$ 的函数。\n\n设 $T_{unopt}(N)$ 为未优化的循环执行 $N$ 次迭代的总周期代价，而 $T_{opt}(N)$ 为优化后循环的代价。总代价是循环预处理器代价与循环体代价乘以迭代次数之和。设 $C_{other}$ 为循环体中不受优化影响部分的执行周期代价。设 $C_{pre,base}$ 为预处理器的基线代价。\n\n根据问题陈述，我们有以下参数：\n- 计算表达式 $E$（一次乘法）的代价：$c_E = 6$ 个周期。\n- 一次内存操作（加载或存储）的代价：$c_{\\text{mem}} = 4$ 个周期。\n- 可用寄存器数量：$R = 8$。\n- 循环执行次数：$N \\ge 1$。\n\n**未优化循环的分析**\n\n在未优化的版本中，表达式 $E$ 在每次迭代中都会被计算。\n- **预处理器代价：** 预处理器的基线代价为 $C_{pre,base}$。\n- **每次迭代的循环体代价：**\n  - 计算 $E$ 的代价是 $c_E = 6$。\n  - 问题陈述指出临时变量的峰值活跃数为 $L_0 = 8$。由于可用寄存器数量为 $R = 8$，且 $L_0 \\le R$，因此没有溢出。溢出代价为 $0$。\n  - 每次迭代的总代价是计算 $E$ 的代价与其他代价之和：$C_{body,unopt} = c_E + C_{other} = 6 + C_{other}$。\n- **总代价：**\n  $$T_{unopt}(N) = C_{pre,base} + N \\times C_{body,unopt} = C_{pre,base} + N(6 + C_{other})$$\n\n**优化后循环的分析 (使用 LICM)**\n\n应用 LICM 后，表达式 $E$ 在预处理器中计算一次，其结果在整个循环执行期间都保存在一个寄存器中。\n- **预处理器代价：** $E$ 的计算被移动到预处理器，增加了其代价。\n  $C_{pre,opt} = C_{pre,base} + c_E = C_{pre,base} + 6$。\n- **每次迭代的循环体代价：**\n  - $E$ 的计算不再在循环内部执行。\n  - 由于 $E$ 的结果在整个循环中都是活跃的，程序点 $P$ 的峰值活跃数增加到 $9$。\n  - 由于新的峰值活跃数 ($9$) 超过了可用寄存器数 ($R=8$) 1个，因此必须将一个临时变量溢出到内存。\n  - 被溢出的临时变量每次迭代有 $u = 2$ 次使用和 $1$ 次定义。这导致每次迭代 $u$ 次加载和 $1$ 次存储，总共 $u+1 = 2+1 = 3$ 次内存操作。\n  - 这些内存操作的代价就是每次迭代的溢出代价：$C_{spill} = (u+1) \\times c_{\\text{mem}} = 3 \\times 4 = 12$ 个周期。\n  - 每次迭代的总代价是溢出代价与其他代价之和：$C_{body,opt} = C_{spill} + C_{other} = 12 + C_{other}$。\n- **总代价：**\n  $$T_{opt}(N) = C_{pre,opt} + N \\times C_{body,opt} = (C_{pre,base} + 6) + N(12 + C_{other})$$\n\n**运行时比较**\n\n为了确定优化的影响，我们计算总运行时的差异 $\\Delta T(N) = T_{opt}(N) - T_{unopt}(N)$。正值表示该“优化”反而增加了运行时。\n\n$$ \\Delta T(N) = \\left[ (C_{pre,base} + 6) + N(12 + C_{other}) \\right] - \\left[ C_{pre,base} + N(6 + C_{other}) \\right] $$\n$$ \\Delta T(N) = (C_{pre,base} + 6 - C_{pre,base}) + N(12 + C_{other} - 6 - C_{other}) $$\n$$ \\Delta T(N) = 6 + N(12 - 6) $$\n$$ \\Delta T(N) = 6 + 6N $$\n\n由于循环执行次数 $N \\ge 1$，$\\Delta T(N)$ 的值总是正的。当 $N=1$ 时, $\\Delta T(1) = 6+6 = 12$。当 $N=2$ 时, $\\Delta T(2) = 6+12=18$。差值随 $N$ 线性增长。\n这个结果表明，提出表达式 $E$ 是有害的；它对所有可能的循环执行次数 $N \\ge 1$ 都增加了总运行时。性能下降的原因在于，每次迭代节省的代价小于因溢出而产生的每次迭代的代价惩罚。\n- 每次迭代因不计算 $E$ 而节省的代价：$c_E = 6$ 个周期。\n- 每次迭代因溢出而产生的代价惩罚：$C_{spill} = 12$ 个周期。\n对循环体的净效应是每次迭代代价增加了 $12 - 6 = 6$ 个周期。\n\n现在我们基于此推导来评估每个选项。\n\n**A. 提出 E 会为所有 $N \\ge 1$ 减少总运行时，因为节省 $N$ 次乘法总是超过任何溢出代价。**\n我们的分析表明 $\\Delta T(N) = 6 + 6N > 0$，意味着总运行时*增加*而非减少。其给出的理由也是错误的；在这种情况下，每次迭代 12 个周期的溢出代价大于节省的 6 个周期的乘法代价，因此溢出代价占主导。\n结论：**错误**。\n\n**B. 提出 E 会为所有 $N \\ge 1$ 增加总运行时，因为由寄存器压力增加而触发的每次迭代的溢出代价超过了节省的每次迭代计算 E 的代价。**\n我们的分析结论是，对于所有 $N \\ge 1$，$T_{opt}(N) > T_{unopt}(N)$，这意味着提出操作增加了总运行时。其给出的理由是每次迭代的溢出代价（$C_{spill} = 12$ 个周期）超过了节省的每次迭代的计算代价（$c_E = 6$ 个周期）。这与我们分析的结果（$12 > 6$）完全一致。\n结论：**正确**。\n\n**C. 提出 E 对任何 $N \\ge 1$ 的总运行时没有影响，因为 Q 点的活跃数未改变且没有发生溢出。**\n根据问题描述，这个说法在事实上是错误的。问题明确指出，提出 $E$ 会使 P 点的活跃数增加到 9，这“迫使恰好一个临时变量被溢出”。因此，溢出确实发生了，并且它们有显著的代价。\n结论：**错误**。\n\n**D. 提出 E 仅在超过某个阈值 $N^\\star$（其中 $N^\\star$ 是某个正整数）后才是有利的，因为即使发生溢出，一次性的预处理器代价也必须在多次迭代中被分摊。**\n这描述了一种常见的情况，即一次性的设置成本通过每次迭代的节省来分摊。如果 $T_{opt}(N)  T_{unopt}(N)$，即 $\\Delta T(N)  0$，则优化是有利的。在我们的案例中，这将要求 $6 + 6N  0$。由于 $N \\ge 1$，$6 + 6N$ 始终是一个正整数，因此该条件永远不会满足。这种类型的阈值只在优化使循环体更快（即 $C_{body,opt}  C_{body,unopt}$）时才存在。在这里，循环体变得更慢了（$C_{body,opt} > C_{body,unopt}$）。\n结论：**错误**。", "answer": "$$\\boxed{B}$$", "id": "3644344"}, {"introduction": "继前一个练习中寄存器压力的挑战之后，我们现在深入探讨编译器如何应对这一全局性难题：寄存器分配。现代编译器常将此问题建模为图着色问题，其中程序的临时变量是图的节点，相互冲突的变量之间连有边。在本练习 [@problem_id:3644353] 中，你将亲手执行一个经典的基于图着色的寄存器分配算法，通过简化和溢出决策，为给定的冲突图在有限的寄存器数量下寻找最优解。", "problem": "一个编译器后端将寄存器分配建模为一个全局优化问题：给定一个捕捉了临时变量之间活跃范围冲突的干涉图，分配至多 $k$ 个物理寄存器，使得任意两个相互干涉的临时变量不共享同一个寄存器。如果干涉图不是 $k$-可着色的，一些临时变量就必须溢出到内存中，这会产生估算的成本。\n\n考虑干涉图 $G=(V,E)$，其顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，无向边集为\n$$\nE=\\big\\{\\{v_1,v_2\\},\\{v_1,v_3\\},\\{v_1,v_4\\},\\{v_2,v_3\\},\\{v_2,v_4\\},\\{v_3,v_4\\},\\{v_5,v_1\\},\\{v_5,v_2\\},\\{v_6,v_3\\}\\big\\}.\n$$\n假设有 $k=3$ 个可用寄存器。每个顶点 $v_i$ 有一个估算的溢出成本 $w_i$，由下式给出\n$$\nw_1=9,\\quad w_2=4,\\quad w_3=7,\\quad w_4=12,\\quad w_5=8,\\quad w_6=3.\n$$\n\n应用标准的基于简化的全局寄存器分配策略，仅使用以下公认的原则，且不进行合并：\n- 如果存在度 $\\deg(v)  k$ 的顶点 $v$，则简化该图。将所有此类候选顶点中索引最小的那个压入栈中以备着色，并从图中移除它。重复此步骤直到图中没有度小于 $k$ 的顶点。\n- 如果图中所有顶点的度都 $\\ge k$，则必须选择一个顶点进行溢出。选择一个顶点 $v$ 使其溢出优先级 $p(v) = w(v)/\\deg(v)$ 最小化。将此顶点从图中永久移除，并将其成本 $w(v)$ 计入总溢出成本。如果有多个顶点具有相同的最低优先级，则选择其中索引最小的那个。然后，返回第一步（简化）。\n- 当图为空时，移除阶段结束。\n\n计算按此策略选择的所有溢出顶点的总溢出成本。", "solution": "此问题是有效的，因为它是编译器理论中一个标准算法的明确应用。我们将对给定的干涉图 $G=(V, E)$ 应用指定的基于简化的寄存器分配策略。可用寄存器数量为 $k=3$。\n\n该过程包括通过简化或溢出，从图中顺序移除顶点。每一步的状态包括当前图、当前图中每个顶点的度、一个用于存放简化顶点的栈，以及一个溢出顶点集。\n\n**步骤 0：初始状态**\n初始图 $G_0$ 的顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，边集如题所述。溢出成本为 $w_1=9, w_2=4, w_3=7, w_4=12, w_5=8, w_6=3$。我们首先计算 $G_0$ 中所有顶点的初始度：\n- $\\deg_{G_0}(v_1) = 4$ (邻居: $v_2, v_3, v_4, v_5$)\n- $\\deg_{G_0}(v_2) = 4$ (邻居: $v_1, v_3, v_4, v_5$)\n- $\\deg_{G_0}(v_3) = 4$ (邻居: $v_1, v_2, v_4, v_6$)\n- $\\deg_{G_0}(v_4) = 3$ (邻居: $v_1, v_2, v_3$)\n- $\\deg_{G_0}(v_5) = 2$ (邻居: $v_1, v_2$)\n- $\\deg_{G_0}(v_6) = 1$ (邻居: $v_3$)\n简化节点的栈和溢出节点的集合最初都是空的。\n\n**步骤 1：简化 $v_5$**\n我们检查是否存在度 $\\deg(v)  k=3$ 的节点 $v$。我们找到了两个这样的节点：$\\deg(v_5)=2$ 的 $v_5$ 和 $\\deg(v_6)=1$ 的 $v_6$。根据打破僵局的规则，我们选择索引最小的节点，即 $v_5$。我们通过从图中移除 $v_5$ 并将其压入栈中来简化它。图变为 $G_1 = G_0 \\setminus \\{v_5\\}$。其邻居 $v_1$ 和 $v_2$ 的度被减一。\n- 栈: $[v_5]$\n- 在 $G_1$ 中的当前度: $\\deg(v_1)=3$, $\\deg(v_2)=3$, $\\deg(v_3)=4$, $\\deg(v_4)=3$, $\\deg(v_6)=1$。\n\n**步骤 2：简化 $v_6$**\n在当前图 $G_1$ 中，我们再次寻找度小于 $3$ 的节点。只有 $v_6$ 符合条件，其 $\\deg(v_6)=1$。我们简化 $v_6$，将其压入栈中并从图中移除，得到 $G_2 = G_1 \\setminus \\{v_6\\}$。其邻居 $v_3$ 的度被减一。\n- 栈: $[v_5, v_6]$\n- 在 $G_2$ 中的当前度: $\\deg(v_1)=3$, $\\deg(v_2)=3$, $\\deg(v_3)=3$, $\\deg(v_4)=3$。\n剩余的顶点是 $\\{v_1, v_2, v_3, v_4\\}$，它们构成一个完全子图 ($K_4$)，因为它们都相互邻接。\n\n**步骤 3：溢出 $v_2$**\n在图 $G_2$ 中，没有节点的度小于 $k=3$。所有四个剩余顶点的度都为 $3$。因此，我们必须选择一个顶点进行溢出。溢出候选是最小化优先级 $p(v) = w(v)/\\deg(v)$ 的那个。\n- $p(v_1) = \\frac{w_1}{\\deg(v_1)} = \\frac{9}{3} = 3$\n- $p(v_2) = \\frac{w_2}{\\deg(v_2)} = \\frac{4}{3} \\approx 1.33$\n- $p(v_3) = \\frac{w_3}{\\deg(v_3)} = \\frac{7}{3} \\approx 2.33$\n- $p(v_4) = \\frac{w_4}{\\deg(v_4)} = \\frac{12}{3} = 4$\n最低的优先级是 $p(v_2)=4/3$。因此，$v_2$ 被选为溢出候选。我们将 $v_2$ 记录为已溢出，并从图中永久移除它，生成 $G_3 = G_2 \\setminus \\{v_2\\}$。其邻居（$v_1, v_3, v_4$）的度被减一。\n- 溢出集: $\\{v_2\\}$, 成本: $w_2=4$。\n- 在 $G_3$ 中的当前度: $\\deg(v_1)=2$, $\\deg(v_3)=2$, $\\deg(v_4)=2$。\n\n**步骤 4：简化 $v_1$**\n在图 $G_3$ 中，所有剩余顶点 $\\{v_1, v_3, v_4\\}$ 的度都为 $2$，小于 $k=3$。它们都是简化的候选。使用打破僵局的规则，我们选择索引最小的那个，即 $v_1$。我们简化 $v_1$，将其压入栈中，并生成 $G_4 = G_3 \\setminus \\{v_1\\}$。其邻居 $v_3$ 和 $v_4$ 的度被减一。\n- 栈: $[v_5, v_6, v_1]$\n- 在 $G_4$ 中的当前度: $\\deg(v_3)=1$, $\\deg(v_4)=1$。\n\n**步骤 5：简化 $v_3$**\n在图 $G_4$ 中，剩余的两个顶点 $v_3$ 和 $v_4$ 的度都小于 $3$。打破僵局的规则选择 $v_3$（索引 $3  4$）。我们简化 $v_3$，将其压入栈，并形成 $G_5 = G_4 \\setminus \\{v_3\\}$。其邻居 $v_4$ 的度被减一。\n- 栈: $[v_5, v_6, v_1, v_3]$\n- 在 $G_5$ 中的当前度: $\\deg(v_4)=0$。\n\n**步骤 6：简化 $v_4$**\n最后一个顶点 $v_4$ 的度为 $0  3$。我们简化它，将其压入栈，图变为空。\n- 栈: $[v_5, v_6, v_1, v_3, v_4]$\n- 图现在为空，移除阶段完成。\n\n**结论**\n在此过程中被选择溢出的顶点集合是 $\\{v_2\\}$。问题要求计算所有溢出顶点的溢出成本之和。由于只有一个顶点被溢出，所以总和就是该顶点的成本。\n溢出成本之和 = $w_2 = 4$。\n着色阶段会通过从栈中弹出节点（$v_4, v_3, v_1, v_6, v_5$）来继续进行，但这不是问题所要求的。", "answer": "$$\n\\boxed{4}\n$$", "id": "3644353"}]}