{"hands_on_practices": [{"introduction": "要想真正理解虚拟调度的原理，我们必须首先深入其底层，探究对象的内存布局。本练习 [@problem_id:3659769] 将挑战你精确计算一个虚拟指针（vptr）的内存偏移量，其中需要考虑数据对齐、填充和位域等棘手的现实因素。掌握这些底层细节是理解面向对象程序性能与行为的第一步。", "problem": "考虑一个具有 $64$ 位应用程序二进制接口 (ABI) 的目标机器，其中以下经过充分测试的数据布局事实成立：\n- 一个 $unsigned\\ char$ 的大小和自然对齐分别是 $1$ 字节和 $1$ 字节。\n- 一个 $unsigned\\ short$ 的大小和自然对齐分别是 $2$ 字节和 $2$ 字节。\n- 一个 $unsigned\\ int$ 的大小和自然对齐分别是 $4$ 字节和 $4$ 字节。\n- 一个指针的大小和自然对齐分别是 $8$ 字节和 $8$ 字节。\n\n假设一个类 $C$ 至少有一个虚方法，因此它包含一个虚方法表 (vtable) 和一个虚表指针 (vptr)，该指针位于 $C$ 类型子对象的偏移量 $0$ 处。$C$ 类型对象的自然对齐等于其成员的最大对齐值；对于此目标，由于存在指针，该值为 $8$ 字节。\n\n现在考虑一个在 packing factor 为 $4$ 的条件下声明的外部结构体 $S$（也就是说，$S$ 中所有成员的对齐都减小为其自然对齐和 $4$ 之间的最小值）。$S$ 中声明的字段按顺序如下：\n1. 一个普通的 $unsigned\\ char$ 字段 $a$。\n2. 一个零宽度的 $unsigned\\ int$ 位域（它会终止当前的位域分配单元，并强制下一个位域从下一个 $unsigned\\ int$ 对齐边界开始）。\n3. 两个连续的 $unsigned\\ int$ 位域 $b:5$ 和 $c:12$。\n4. 一个普通的 $unsigned\\ short$ 字段 $d$。\n5. 一个类型为 $C$ 的子对象 $o$。\n\n使用以下基本布局原则：\n- 每个非位域成员被放置在是其在 $S$ 中有效对齐（有效对齐是成员的自然对齐和 packing factor 的最小值）倍数的最小偏移处。\n- 相同基础类型的位域共享一个分配单元，其大小等于该基础类型的大小；它们从左到右填充到该单元中。如果遇到类型为 $T$ 的零宽度位域，它会结束当前单元，并且下一个类型为 $T$ 的位域从 $T$ 的下一个对齐边界开始。\n- 当一个位域序列结束时，该分配单元会被完全保留直到其末尾；下一个成员在该单元之后开始。\n- $C$ 类型的子对象 $o$ 在其内部偏移量为 $0$ 的位置包含其虚表指针 (vptr)。\n\n从这些原则出发，推导 $o$ 的 vptr 在 $S$ 中的确切字节偏移量，并计算由位域和 packing 引入的、导致 vptr 被移动到下一个对齐边界的任何填充。将您的最终答案以字节为单位表示为单个整数。无需四舍五入。", "solution": "我们从给定的数据布局规则和 packing factor 开始。packing factor 为 $4$ 将 $S$ 中每个成员的有效对齐减小为其自然对齐和 $4$ 之间的最小值。\n\n步骤 $1$：放置 $unsigned\\ char$ 字段 $a$。\n- $a$ 的有效对齐是 $\\min(1,4)=1$。\n- 它被放置在偏移量 $0$ 处。\n- 它占用 $1$ 个字节，因此下一个可用偏移量是 $0+1=1$。\n\n步骤 $2$：应用零宽度的 $unsigned\\ int$ 位域。\n- 一个基础类型为 $unsigned\\ int$ 的零宽度位域会结束当前的分配单元，并强制下一个 $unsigned\\ int$ 位域从与 $unsigned\\ int$ 的有效对齐对齐的下一个边界开始。\n- $S$ 中 $unsigned\\ int$ 的有效对齐是 $\\min(4,4)=4$。\n- 当前偏移量是 $1$。我们必须前进到下一个 $4$ 的倍数。\n- 插入的填充是\n$$\n\\operatorname{pad}_{1} = (4 - (1 \\bmod 4)) \\bmod 4 = (4 - 1) \\bmod 4 = 3.\n$$\n- 下一个对齐后的偏移量是 $1+3=4$。\n\n步骤 $3$：放置两个 $unsigned\\ int$ 位域 $b:5$ 和 $c:12$。\n- 类型为 $unsigned\\ int$ 的位域被打包在从偏移量 $4$ 开始的单个 $4$ 字节分配单元内。\n- 该分配单元跨越偏移量 $4$ 到 $7$（含）。\n- $b$ 使用了 $5$ 位，$c$ 使用了 $12$ 位，总共 $5+12=17$ 位。无论剩余多少位，这个 $4$ 字节的分配单元都完全为位域保留。\n- 在位域之后，下一个可用的偏移量是该单元的末尾：$4+4=8$。\n\n步骤 $4$：放置普通的 $unsigned\\ short$ 字段 $d$。\n- $d$ 的有效对齐是 $\\min(2,4)=2$。\n- 当前偏移量是 $8$，它已经是 $2$ 的倍数，所以不需要填充。\n- $d$ 占用 $2$ 个字节，所以下一个可用偏移量是 $8+2=10$。\n\n步骤 $5$：放置 $C$ 类型的子对象 $o$。\n- $o$ 的自然对齐是其成员的最大对齐值，由于其内部有指针，所以是 $8$ 字节。在 packing factor 为 $4$ 的情况下，$o$ 在 $S$ 中的有效对齐是 $\\min(8,4)=4$。\n- 当前偏移量是 $10$。我们必须对齐到下一个 $4$ 的倍数。\n- 插入的填充是\n$$\n\\operatorname{pad}_{2} = (4 - (10 \\bmod 4)) \\bmod 4 = (4 - 2) \\bmod 4 = 2.\n$$\n- 因此，$o$ 的放置偏移量是 $10+2=12$。\n\n在子对象 $o$ 内部，虚表指针 (vptr) 相对于 $o$ 的偏移量为 $0$。因此，vptr 在 $S$ 中的偏移量等于 $o$ 的放置偏移量，即从 $S$ 的起始位置算起的 $12$ 字节。\n\n为完整起见，导致 vptr 移动到其对齐边界的总填充量是零宽度位域引入的填充和 $o$ 之前的填充之和：\n$$\n\\operatorname{pad}_{\\text{total}} = \\operatorname{pad}_{1} + \\operatorname{pad}_{2} = 3 + 2 = 5.\n$$\n然而，题目要求的是 vptr 在 $S$ 中的字节偏移量，我们已经推导出其值为 $12$ 字节。\n\n因此，$o$ 的 vptr 在 $S$ 中的确切字节偏移量是 $12$。", "answer": "$$\\boxed{12}$$", "id": "3659769"}, {"introduction": "在单个对象布局的基础上，我们现在来探讨更复杂的多重继承场景。当一个类继承自多个基类时，编译器如何组织它们各自的虚函数表（vtable）？本练习 [@problem_id:3659745] 将深入探讨编译器在vtable复用与布局方面的策略，要求你分析派生类中不同的方法覆写模式如何影响最终的vtable结构。", "problem": "一种编程语言通过虚方法表 (Virtual Method Table, VMT) 来实现动态派发。对于每个多态类，VMT 被建模为一个函数标识符数组，每个虚方法对应一个条目，顺序与类中虚方法的从左到右声明顺序一致。以下核心定义和经过充分检验的事实被假定为基本依据：\n\n- 在单继承中，当派生类没有覆盖基类索引为 $i$ 的方法时，派生类将不变地继承基类在索引 $i$ 处的 VMT 条目；当它覆盖该方法时，它会替换该索引处的条目。在类中新声明的虚方法会被追加到该类 VMT 的末尾。\n- 在多重继承中，一个基类被指定为主基类。主基类子对象位于最终派生对象的偏移量 $0$ 处，因此通过该子对象 VMT 进行的调用不需要对接收者对象指针进行隐式调整。任何非主基类（次基类）子对象通常位于非零偏移量处，因此通过该子对象 VMT 进行的调用需要一个非零的隐式“this 指针”调整；这被建模为即使没有覆盖也需要不同的函数指针（“thunks”）。\n- VMT 之间的最长共享前缀被定义为最大的连续前导索引范围 $[0, L-1]$，在此范围内，被比较的 VMT 中的所有条目都相同。对于一个都继承自同一基类的派生类家族，该家族中基类子对象 VMT 的共享前缀长度是最大的 $L$，使得所有派生类都没有覆盖基类在索引 $0, 1, \\dots, L-1$ 处的虚方法。\n- 每个子对象的 VMT 生成策略：一个最终派生类当且仅当其基类子对象的至少一个条目与基类自身的 VMT 条目不同时，才必须为该基类子对象生成一个新的 VMT。在上述模型下，这意味着：对于主基类子对象，当且仅当某个基类方法被覆盖时，才生成新的 VMT；对于次基类子对象，总是生成新的 VMT，因为非零的“this 指针”调整即使在没有覆盖的情况下也会改变函数指针。\n\n考虑两个基类：\n\n- 类 $A$ 按顺序声明了 $8$ 个虚方法 $a_0, a_1, \\dots, a_7$。\n- 类 $B$ 按顺序声明了 $6$ 个虚方法 $b_0, b_1, \\dots, b_5$。\n\n定义了三个最终派生类 $D_1, D_2, D_3$，每个都使用多重继承，其中 $A$ 是主基类，$B$ 是次基类。覆盖模式如下：\n\n- $D_1$ 覆盖了 $a_2, a_5$ 和 $b_2, b_4$，并引入了 $1$ 个自己的新虚方法。\n- $D_2$ 覆盖了 $a_4, a_7$ 和 $b_3$，并引入了 $2$ 个自己的新虚方法。\n- $D_3$ 覆盖了 $a_3$ 和 $b_5$，并且没有引入自己的新虚方法。\n\n定义 $L_A$ 为 $D_1, D_2, D_3$ 的 $A$-子对象 VMT 的共享前缀长度，定义 $L_B$ 为 $D_1, D_2, D_3$ 的 $B$-子对象 VMT 的共享前缀长度，两者都相对于它们各自的基类 VMT。令 $P = L_A + L_B$。\n\n令 $E_{\\text{total}}$ 为根据上述生成策略，在所有三个最终派生类中，两个子对象合计必须生成的新的子对象 VMT 的总数。\n\n计算单个标量值 $S = P + E_{\\text{total}}$。无需四舍五入。最终答案必须是单个实数值。", "solution": "问题要求计算标量值 $S = P + E_{\\text{total}}$。该值由三个派生类 $D_1$、$D_2$ 和 $D_3$ 的虚方法表 (VMT) 的属性推导得出，这三个类继承自两个基类 $A$ 和 $B$。我们将根据问题陈述中提供的规则，系统地计算分量 $P$ 和 $E_{\\text{total}}$。\n\n首先，我们确定 $P$ 的值，其定义为 $P = L_A + L_B$。此处，$L_A$ 和 $L_B$ 分别是派生类家族 $\\{D_1, D_2, D_3\\}$ 中 $A$-子对象和 $B$-子对象 VMT 的共享前缀长度。\n\n问题将继承自同一基类的派生类家族的共享前缀长度定义为“最大的 $L$，使得所有派生类都没有覆盖基类在索引 $0, 1, \\dots, L-1$ 处的虚方法”。这意味着共享前缀长度等于任何派生类引入覆盖的最低索引。\n\n为了计算 $L_A$，我们考虑类 $A$ 的虚方法，即 $a_0, a_1, \\dots, a_7$，对应索引 $0, 1, \\dots, 7$。这些方法的覆盖模式是：\n-   $D_1$ 覆盖了 $a_2$ (索引 $2$) 和 $a_5$ (索引 $5$)。\n-   $D_2$ 覆盖了 $a_4$ (索引 $4$) 和 $a_7$ (索引 $7$)。\n-   $D_3$ 覆盖了 $a_3$ (索引 $3$)。\n基类 $A$ 中被覆盖方法的所有索引的集合是每个派生类所覆盖索引的并集：$\\{2, 5\\} \\cup \\{4, 7\\} \\cup \\{3\\} = \\{2, 3, 4, 5, 7\\}$。\n该集合中的最小索引是 $2$。\n因此，索引 $0$ 和 $1$ 处的方法没有被任何派生类覆盖。共享前缀覆盖了索引 $[0, 2-1]$，因此其长度为 $L_A = 2$。\n\n为了计算 $L_B$，我们考虑类 $B$ 的虚方法，即 $b_0, b_1, \\dots, b_5$，对应索引 $0, 1, \\dots, 5$。覆盖模式如下：\n-   $D_1$ 覆盖了 $b_2$ (索引 $2$) 和 $b_4$ (索引 $4$)。\n-   $D_2$ 覆盖了 $b_3$ (索引 $3$)。\n-   $D_3$ 覆盖了 $b_5$ (索引 $5$)。\n基类 $B$ 中被覆盖方法的所有索引的集合是 $\\{2, 4\\} \\cup \\{3\\} \\cup \\{5\\} = \\{2, 3, 4, 5\\}$。\n该集合中的最小索引是 $2$。\n因此，索引 $0$ 和 $1$ 处的方法没有被任何派生类覆盖。$B$-子对象 VMT 的共享前缀长度为 $L_B = 2$。\n\n在确定了 $L_A$ 和 $L_B$ 后，我们可以计算 $P$：\n$$P = L_A + L_B = 2 + 2 = 4$$\n\n接下来，我们计算 $E_{\\text{total}}$，即所有三个派生类必须生成的新的子对象 VMT 的总数。VMT 生成策略如下：\n1.  对于主基类子对象，当且仅当至少有一个基类方法被覆盖时，才生成新的 VMT。\n2.  对于次基类子对象，总是生成新的 VMT。\n\n在指定的多重继承场景中，$A$ 是所有三个派生类 $D_1, D_2, D_3$ 的主基类，$B$ 是次基类。我们分析每个派生类的 VMT 生成情况：\n-   对于类 $D_1$：\n    -   $A$-子对象：$D_1$ 覆盖了 $A$ 的方法。根据主基类的策略，必须生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $B$-子对象：$B$ 是次基类。根据策略，总是生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $D_1$ 总计：$1 + 1 = 2$ 个新 VMT。\n\n-   对于类 $D_2$：\n    -   $A$-子对象：$D_2$ 覆盖了 $A$ 的方法。为主基类子对象生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $B$-子对象：$B$ 是次基类，因此生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $D_2$ 总计：$1 + 1 = 2$ 个新 VMT。\n\n-   对于类 $D_3$：\n    -   $A$-子对象：$D_3$ 覆盖了 $A$ 的一个方法。为主基类子对象生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $B$-子对象：$B$ 是次基类，因此生成一个新的 VMT。这对总数贡献了 $1$。\n    -   $D_3$ 总计：$1 + 1 = 2$ 个新 VMT。\n\n新 VMT 的总数 $E_{\\text{total}}$ 是为每个派生类生成的新 VMT 的总和。\n$$E_{\\text{total}} = 2 (\\text{for } D_1) + 2 (\\text{for } D_2) + 2 (\\text{for } D_3) = 6$$\n\n最后，我们计算所需的标量值 $S$：\n$$S = P + E_{\\text{total}} = 4 + 6 = 10$$\n最终结果是一个整数。", "answer": "$$\\boxed{10}$$", "id": "3659745"}, {"introduction": "对象和vtable的特定内存布局并不仅仅是理论上的探讨，它对程序行为有着深远的影响，有时甚至会导致一些隐蔽的错误。本练习 [@problem_id:3659777] 将剖析一个在C++等语言中被称为“对象切片”（object slicing）的经典陷阱，它发生在派生类对象被按值传递并被当作基类对象处理时。通过分析其导致虚函数调用错误的原因，你将学会如何识别并预防这一面向对象编程中的常见错误源。", "problem": "一种语言使用虚方法表 (VMT) 来实现单继承和动态分派。按照惯例，每个对象的起始位置（字节偏移量为 $0$）都有一个虚指针 (VPTR) 字段，该字段指向其类的 VMT。在地址为 $o$ 的对象上调用槽索引为 $k$ 的虚方法时，会被编译为以下序列：从偏移量 $0$ 加载 VPTR $p \\leftarrow *o$，然后加载函数指针 $f \\leftarrow p[k]$，接着对 $f(o,\\ldots)$ 执行间接调用。\n\n考虑两个类：一个基类 $B$，它有一个虚方法 $m$；一个派生类 $D$，它扩展了 $B$ 并重写了 $m$。假设存在以下与广泛使用的对象模型一致的具体场景：\n- 静态类型为 $B$ 的对象的布局是 $[\\;vptr_B\\;;\\;\\text{基类字段}\\;]$，其中 VPTR 字段指向 $B$ 的 VMT。\n- 静态类型为 $D$ 的对象的布局是 $[\\;vptr_D\\;;\\;\\text{基类字段}\\;;\\;\\text{派生类字段}\\;]$。这里，$vptr_D$ 指向 $D$ 的 VMT，并且一个 $D$ 对象的前 $\\lvert B\\rvert$ 字节构成了它的 $B$ 子对象。\n\n假设一个函数声明为 $process(B\\ b)$，并包含调用 $b.m()$。又假设该语言的值参数传递语义在将一个 $D$ 类型的实参绑定到形参 $b$ 时，只拷贝 $B$ 子对象（即，将 $\\lvert B\\rvert$ 字节拷贝到一个新的 $B$ 对象中）。除了 VPTR 之外，不使用任何运行时类型标签。\n\n从基于 VMT 的分派和所描述的拷贝语义的基本原理出发，推断当用一个 $D$ 的实例调用 $process$ 时，$b.m()$ 将调用的动态目标。然后，选择下面所有关于分派结果以及能在此类语言中可靠地防止此类对象切片的编译时技术的正确陈述。\n\n选项：\n- A. 在 $process$ 内部，调用 $b.m()$ 将会调用在 $B$ 中定义的主体（而非在 $D$ 中的重写版本），因为切片对象的 VPTR 现在指向 $B$ 的 VMT，所以在槽 $k$ 处的 VMT 查找会得到 $B::m$。\n\n- B. 将 $B$ 的拷贝构造函数声明为删除的（或以其他方式使 $B$ 的按值拷贝变为非法的），可以在编译时防止切片，因为将动态类型为 $D$ 的实参绑定到静态类型为 $B$ 的按值传递的形参，正需要这样一次 $B$ 的拷贝。\n\n- C. 如果编译器对于任何带有 VMT 的类型（例如，任何声明了至少一个虚方法的类）的按值传递的参数或变量，进行拒绝或发出警告，那么这是一种可靠的防止切片的编译时检查；调用者可以改用引用或指针，从而保留原始的 VPTR 并实现正确的分派。\n\n- D. 将 $B$ 的拷贝构造函数设为虚函数，可以确保按值拷贝会保留派生对象的 VPTR，因此即使在拷贝之后，$process$ 内部的 $b.m()$ 也会动态分派到 $D::m$。\n\n- E. 重排布局，将 $B$ 的 VPTR 字段置于其非虚数据字段之后，可以确保从一个 $D$ 实例向一个 $B$ 实例进行的 $\\lvert B\\rvert$ 字节拷贝会保留派生的 VPTR，从而防止不正确的分派。\n\n- F. 添加运行时类型信息 (RTTI) 并在调用点检查动态类型，可以在按值拷贝后通过为 $b$ 重构正确的 VPTR 来修复对切片副本的分派。\n\n选择所有适用项。", "solution": "该问题陈述描述了一个在 C++ 这类使用虚方法表 (VMT) 实现多态性的编程语言背景下的场景。我们必须分析在一个“被切片”的对象上进行虚方法调用的行为，并评估关于此现象及其预防措施的陈述。\n\n### 问题验证\n\n问题陈述已经过验证且是合理的。它描述了一个标准的面向对象编程模型和一个被称为对象切片的经典问题。已知条件如下：\n- 一个基类 $B$，拥有一个虚方法 $m$。\n- 一个派生类 $D$，它继承 $B$ 并重写 $m$。\n- 对象布局：一个对象在偏移量 $0$ 处以 VPTR 开始。一个 $D$ 对象包含一个 $B$ 子对象。\n- 在槽 $k$ 处的虚调用 `o.m()`：$p \\leftarrow *o$; $f \\leftarrow p[k]$; 调用 $f(o, \\ldots)$。\n- 一个函数 `process(B b)` 按值接受一个 $B$ 类型的参数。\n- 当一个 $D$ 对象被传递给 `process` 时，一次 $|\\!B\\!|$ 字节的拷贝创建了参数 $b$。这就是对象切片。\n\n### 从基本原理推导\n\n让我们追踪当类 $D$ 的一个实例（比如 $d_{obj}$）被传递给函数 `process(B b)` 时的执行过程。\n\n1.  **原始对象状态**：类型为 $D$ 的对象 $d_{obj}$ 的内存布局为 $[\\;vptr_D\\;;\\;\\text{基类字段}\\;;\\;\\text{派生类字段}\\;]$。它的 VPTR，即 $vptr_D$，位于偏移量 $0$ 处，并指向类 $D$ 的 VMT（$VMT_D$）。$VMT_D$ 在相应的槽位（比如索引 $k$）包含一个指向实现 $D::m$ 的指针。\n\n2.  **参数传递（对象切片）**：函数 `process` 以 $d_{obj}$ 为参数被调用。由于参数 $b$ 是按值传递的（`process(B b)`），一个新的静态类型为 $B$ 的对象 $b$ 会在 `process` 的调用栈上被构造。语言语义规定通过从实参拷贝来初始化该形参。\n    - 创建一个静态类型为 $B$ 的对象涉及到调用 $B$ 的一个构造函数，通常是拷贝构造函数 `B::B(const B)`，其中实参 $d_{obj}$ 被向上转型为其 $B$ 子对象的引用。\n    - 构造函数的基本职责是初始化其类的对象。对于有虚函数的类，这包括设置对象的 VPTR 指向该特定类的 VMT。\n    - 因此，$B$ 的构造函数会将新对象 $b$ 的 VPTR 初始化为指向 $VMT_B$。\n    - 随后，$d_{obj}$ 内部 $B$ 子对象的数据成员（“基类字段”）被拷贝到 $b$ 的相应字段中。\n    - 最终的对象 $b$ 的布局为 $[\\;vptr_B\\;;\\;\\text{拷贝的基类字段}\\;]$。它是一个类型为 $B$ 的完整形式的对象。所有源于 $D$ 对象的信息，包括 `derived fields` 和原始的 $vptr_D$，都已丢失。这就是对象切片的本质。\n\n3.  **虚方法分派**：在 `process` 内部，调用 `b.m()` 被执行。设对象 $b$ 的地址为 $o_{b}$。\n    - 分派机制开始：加载 VPTR $p \\leftarrow *o_{b}$。由于 $b$ 的 VPTR 指向 $VMT_B$，我们得到 $p = VMT_B$。\n    - 接着，从 VMT 加载函数指针：$f \\leftarrow p[k]$。基类 $B$ 的 VMT 包含指向 $B$ 的方法的指针。因此，$VMT_B[k]$ 持有函数 $B::m$ 的地址。所以，$f$ 是一个指向 $B::m$ 的指针。\n    - 最后，执行间接调用：$f(o_{b}, \\ldots)$。这将调用 $B::m$，并将被切片的对象 $b$ 的地址作为 `this` 指针传递。\n\n动态分派机制按规定工作，但是作用在一个类型标识为基类 $B$ 的被切片的对象上。多态性被破坏了，基类实现 $B::m$ 被调用，而不是派生类的重写版本 $D::m$。\n\n### 逐项分析\n\n- **A. 在 $process$ 内部，调用 $b.m()$ 将会调用在 $B$ 中定义的主体（而非在 $D$ 中的重写版本），因为切片对象的 VPTR 现在指向 $B$ 的 VMT，所以在槽 $k$ 处的 VMT 查找会得到 $B::m$。**\n  该陈述准确地总结了从基本原理推导出的结果。切片行为创建了一个基类类型的新对象，这涉及到其构造函数将其 VPTR 设置为指向基类的 VMT（$VMT_B$）。因此，对这个被切片的对象进行的任何虚调用都将解析为基类的方法。\n  **结论：正确。**\n\n- **B. 将 $B$ 的拷贝构造函数声明为删除的（或以其他方式使 $B$ 的按值拷贝变为非法的），可以在编译时防止切片，因为将动态类型为 $D$ 的实参绑定到静态类型为 $B$ 的按值传递的形参，正需要这样一次 $B$ 的拷贝。**\n  按值传递参数要求对象是可拷贝构造的。在我们的场景中，从实参 `d_obj` 构造形参 `b` 需要调用拷贝构造函数 `B::B(const B)`。如果这个构造函数被声明为删除的（例如，在 C++ 中使用 `= delete`）或者是私有且不可访问的，编译器将无法为按值传递参数生成代码。这会导致编译时错误，从而有效且可靠地防止了对象切片。这是使多态基类不可拷贝的标准用法。\n  **结论：正确。**\n\n- **C. 如果编译器对于任何带有 VMT 的类型（例如，任何声明了至少一个虚方法的类）的按值传递的参数或变量，进行拒绝或发出警告，那么这是一种可靠的防止切片的编译时检查；调用者可以改用引用或指针，从而保留原始的 VPTR 并实现正确的分派。**\n  这描述了一种稳健的、基于静态分析的方法来防止切片。带有 VMT 的类型旨在用于多态行为。按值传递此类类型是切片的主要原因。因此，编译器或静态分析工具可以针对此模式发出诊断信息。建议的替代方案，即按指针传递（例如 `process(B* b)`）或按引用传递（例如 `process(B b)`），不会创建新对象。它们传递的是原始对象的地址或引用。通过这样的指针或引用进行的虚调用将访问原始对象（$D$ 实例）的 VPTR，从而正确地分派到 $D::m$。这是一种可靠的预防策略。\n  **结论：正确。**\n\n- **D. 将 $B$ 的拷贝构造函数设为虚函数，可以确保按值拷贝会保留派生对象的 VPTR，因此即使在拷贝之后，$process$ 内部的 $b.m()$ 也会动态分派到 $D::m$。**\n  这个陈述基于一个错误的前提。构造函数不能被声明为 `virtual`。虚调用要求一个对象的 VPTR 已经初始化并指向正确的 VMT。而构造函数的任务恰恰是执行此初始化。因此，在调用构造函数时，该对象的虚分派机制尚不可用。编译器必须根据正在创建的对象的静态类型（本例中为 `B`）来静态解析要调用哪个构造函数。“虚构造函数”的概念在标准对象模型中是一个逻辑矛盾。\n  **结论：错误。**\n\n- **E. 重排布局，将 $B$ 的 VPTR 字段置于其非虚数据字段之后，可以确保从一个 $D$ 实例向一个 $B$ 实例进行的 $\\lvert B\\rvert$ 字节拷贝会保留派生的 VPTR，从而防止不正确的分派。**\n  这个提议是有缺陷的，因为它错误地表述了对象构造的工作方式。形参 `b` 的创建不是一次盲目的、逐字节的内存拷贝（`memcpy`）。它是一个由 `b` 的静态类型（即 $B$）决定的构造过程。$B$ 的构造函数将会执行，并负责初始化 $B$ 对象的所有成员，包括其 VPTR。无论 VPTR 字段位于对象布局的何处，$B$ 的构造函数总是会将 VPTR 设置为指向 $VMT_B$。改变字段顺序对于调用哪个构造函数或该构造函数如何初始化 VPTR 没有任何影响。\n  **结论：错误。**\n\n- **F. 添加运行时类型信息 (RTTI) 并在调用点检查动态类型，可以在按值拷贝后通过为 $b$ 重构正确的 VPTR 来修复对切片副本的分派。**\n  这从根本上是错误的，原因有二。首先，一旦对象 $b$ 通过切片被创建，它就是一个类型为 $B$ 的合法对象。对 $b$ 进行的任何 RTTI 查询（例如在 C++ 中的 `typeid(b)`）都将正确地报告其动态类型为 $B$。它是由一个 $D$ 对象切片而来的信息已完全丢失；RTTI 没有任何东西可以发现。其次，即使能够神奇地知道 $b$ 是从 $D$ 切片而来，并强行将其 VPTR 覆盖为指向 $VMT_D$，这也将是灾难性的。对象 $b$ 的大小为 $|\\!B\\!|$，并且缺少 $D$ 对象的 `derived fields`。在这样一个不完整的对象上调用 $D::m$ 几乎肯定会导致尝试访问这些缺失的字段，从而引发内存损坏和未定义行为。\n  **结论：错误。**", "answer": "$$\n\\boxed{ABC}\n$$", "id": "3659777"}]}