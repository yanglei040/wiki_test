{"hands_on_practices": [{"introduction": "提前（AOT）编译器的一个核心任务是在多种实现策略之间做出权衡，以平衡代码大小和执行速度。本练习以一个经典的例子——`switch` 语句的降级——为例，指导你如何通过建立一个正式的成本模型来量化这一决策。通过这个实践，你将学会如何基于静态分析和编译策略来决定是使用空间效率高但可能较慢的二分搜索，还是时间效率高但可能占用更多空间的跳转表 [@problem_id:3620661]。", "problem": "一个提前（AOT）编译器需要将一个具有 $k$ 个不同 case 标签的多路分支（基于整数的 switch 语句）进行降级，这些标签的数值分布在一个宽度为 $W$ 的整数区间内。将密度定义为 $\\delta = \\frac{k}{W}$，其中 $0  \\delta \\leq 1$。考虑以下两种典型的降级策略：\n\n- 跳转表：一个包含 $W$ 个条目的表，直接索引到目标代码块（landing pads）。该策略需要固定的控制流开销和与 $W$ 个条目成正比的数据足迹。\n- 基于已排序 case 标签的平衡二叉搜索决策树：该策略需要的控制流深度与 $\\log_{2}(k)$ 成正比，且静态代码大小与所需决策节点的数量成正比。\n\n假设以下成本模型，该模型基于关于这些策略的核心事实：\n\n1. 代码大小成本以字节为单位衡量，执行时间成本以时钟周期为单位衡量。编译器优化一个加权总成本\n$$\nC \\;=\\; \\lambda \\cdot S \\;+\\; (1 - \\lambda) \\cdot T,\n$$\n其中 $S$ 是代码大小，$T$ 是一次分派的执行时间，$0  \\lambda  1$ 是用于在代码大小和时间之间进行权衡的策略权重。\n\n2. 对于跳转表：\n   - 设 $s_{\\mathrm{jt}}$ 为生成跳转表分派逻辑的固定开销（以字节为单位）。\n   - 设 $p$ 为表中每个条目的字节成本，因此该表贡献了 $p \\cdot W$ 字节。\n   - 设 $r$ 为每个目标代码块的字节成本，因此目标代码块贡献了 $r \\cdot k$ 字节。\n   - 设 $t_{\\mathrm{jt}}$ 是通过跳转表进行一次分派的恒定时钟周期成本，假设表查找是 $O(1)$ 操作，并且间接分支解析的成本平均为常数。\n\n3. 对于平衡二叉搜索决策树：\n   - 设 $s_{\\mathrm{bs}}$ 为生成决策树分派逻辑的固定开销（以字节为单位）。\n   - 设 $b$ 为每个决策节点的字节成本。一个覆盖 $k$ 个标签的平衡树使用 $k-1$ 个内部决策节点，因此决策代码贡献了 $b \\cdot (k - 1)$ 字节。\n   - 目标代码块仍然贡献 $r \\cdot k$ 字节。\n   - 设 $t_{\\mathrm{lvl}}$ 为每个决策级别的时钟周期成本，因此分派时间按 $t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$ 的比例缩放。\n\n采用上述模型，并使用 $\\delta = \\frac{k}{W}$ 将跳转表的数据足迹与密度关联起来。推导出密度阈值 $\\delta^{*}(k)$，在该阈值下，跳转表的加权总成本等于二叉搜索决策树的加权总成本。你的最终表达式必须是 $\\delta^{*}(k)$ 关于 $k$, $\\lambda$, $p$, $b$, $s_{\\mathrm{jt}}$, $s_{\\mathrm{bs}}$, $t_{\\mathrm{jt}}$, 和 $t_{\\mathrm{lvl}}$ 的封闭形式解析表达式。如果不需要四舍五入，请提供精确表达式。在最终答案中不要说明单位。", "solution": "问题要求推导密度阈值，记为 $\\delta^{*}(k)$，在该阈值下，使用跳转表实现多路分支的加权总成本等于使用平衡二叉搜索决策树的加权总成本。总成本 $C$ 是代码大小成本 $S$ 和执行时间成本 $T$ 的加权和，由策略 $C = \\lambda \\cdot S + (1 - \\lambda) \\cdot T$ 给出。\n\n首先，我们根据问题陈述中提供的参数，为这两种策略分别构建总成本公式。\n\n对于跳转表策略，代码大小成本 $S_{\\mathrm{jt}}$ 是固定开销 $s_{\\mathrm{jt}}$、表大小成本 $p \\cdot W$ 和目标代码块代码大小 $r \\cdot k$ 的总和。\n$$S_{\\mathrm{jt}} = s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k$$\n执行时间成本 $T_{\\mathrm{jt}}$ 是一个恒定值 $t_{\\mathrm{jt}}$。\n$$T_{\\mathrm{jt}} = t_{\\mathrm{jt}}$$\n因此，跳转表的总成本 $C_{\\mathrm{jt}}$ 是：\n$$C_{\\mathrm{jt}} = \\lambda \\cdot S_{\\mathrm{jt}} + (1 - \\lambda) \\cdot T_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}}$$\n\n对于平衡二叉搜索策略，代码大小成本 $S_{\\mathrm{bs}}$ 是固定开销 $s_{\\mathrm{bs}}$、决策节点代码大小 $b \\cdot (k - 1)$ 和相同的目标代码块代码大小 $r \\cdot k$ 的总和。\n$$S_{\\mathrm{bs}} = s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k$$\n执行时间成本 $T_{\\mathrm{bs}}$ 与树的深度成正比，给出为 $t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$。\n$$T_{\\mathrm{bs}} = t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$$\n因此，二叉搜索树的总成本 $C_{\\mathrm{bs}}$ 是：\n$$C_{\\mathrm{bs}} = \\lambda \\cdot S_{\\mathrm{bs}} + (1 - \\lambda) \\cdot T_{\\mathrm{bs}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k)$$\n\n密度阈值 $\\delta^{*}(k)$ 是使得两种成本相等的密度 $\\delta$ 的值，即 $C_{\\mathrm{jt}} = C_{\\mathrm{bs}}$。我们建立等式：\n$$ \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1) + r \\cdot k) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\n项 $\\lambda \\cdot r \\cdot k$ 代表目标代码块的代码大小成本，出现在等式两边。这是两种策略的共同成本，因此不影响决策阈值。我们可以从两边消去这一项：\n$$ \\lambda \\cdot (s_{\\mathrm{jt}} + p \\cdot W) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1)) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\n问题将密度 $\\delta$ 定义为 $\\delta = \\frac{k}{W}$。我们需要求解 $\\delta$。为此，我们首先用 $\\delta$ 和 $k$ 表示 $W$：$W = \\frac{k}{\\delta}$。我们将其代入等式：\n$$ \\lambda \\cdot \\left(s_{\\mathrm{jt}} + p \\cdot \\frac{k}{\\delta}\\right) + (1 - \\lambda) \\cdot t_{\\mathrm{jt}} = \\lambda \\cdot (s_{\\mathrm{bs}} + b \\cdot (k - 1)) + (1 - \\lambda) \\cdot t_{\\mathrm{lvl}} \\cdot \\log_{2}(k) $$\n展开包含 $\\lambda$ 的项：\n$$ \\lambda s_{\\mathrm{jt}} + \\frac{\\lambda p k}{\\delta} + (1 - \\lambda) t_{\\mathrm{jt}} = \\lambda s_{\\mathrm{bs}} + \\lambda b (k - 1) + (1 - \\lambda) t_{\\mathrm{lvl}} \\log_{2}(k) $$\n我们的目标是分离出 $\\delta$。我们首先分离出包含 $\\delta$ 的项：\n$$ \\frac{\\lambda p k}{\\delta} = \\lambda s_{\\mathrm{bs}} + \\lambda b (k - 1) + (1 - \\lambda) t_{\\mathrm{lvl}} \\log_{2}(k) - \\lambda s_{\\mathrm{jt}} - (1 - \\lambda) t_{\\mathrm{jt}} $$\n我们可以按权重因子 $\\lambda$ 对右侧的项进行分组：\n$$ \\frac{\\lambda p k}{\\delta} = \\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}}) $$\n为了求解 $\\delta$，我们可以先求解其倒数 $\\frac{1}{\\delta}$，方法是将等式两边同时除以 $\\lambda p k$。这是允许的，因为 $\\lambda > 0$，$p$（字节成本）必须为正，而 $k$（标签数量）必须至少为 1。\n$$ \\frac{1}{\\delta} = \\frac{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})}{\\lambda p k} $$\n最后，我们对两边取倒数，得到密度阈值 $\\delta^{*}(k)$ 的表达式：\n$$ \\delta^{*}(k) = \\frac{\\lambda p k}{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})} $$\n这就是密度阈值 $\\delta^{*}(k)$ 关于给定参数的封闭形式解析表达式。如果实际密度 $\\delta$ 大于此阈值 $\\delta^{*}(k)$，编译器将选择跳转表策略，如果小于此阈值，则选择二叉搜索策略，前提是分母为正。", "answer": "$$ \\boxed{ \\frac{\\lambda p k}{\\lambda (s_{\\mathrm{bs}} - s_{\\mathrm{jt}} + b(k - 1)) + (1 - \\lambda) (t_{\\mathrm{lvl}} \\log_{2}(k) - t_{\\mathrm{jt}})} } $$", "id": "3620661"}, {"introduction": "编译优化并非总能带来确定的性能提升，其效果常常依赖于运行时的具体条件。这个练习将带你进入一个更真实的场景，学习如何使用概率论中的期望值来分析一项优化的平均收益。你将为一个 `printf` 格式化字符串折叠的优化构建一个性能模型，该模型考虑了运行时环境（如“区域设置”）的不确定性，从而学会如何进行基于数据的、更为精准的性能预测 [@problem_id:3620675]。", "problem": "考虑一个提前（AOT）编译过程，该过程将C标准输入/输出函数 $printf$ 在其格式化字符串和参数均为编译时常量的情况下的调用，转换为直接输出一个预计算好的常量字符串。例如，调用 $printf(\"x=%d\", 3)$ 可以在运行时被替换为输出常量字符串 $\"x=3\"$。该转换的基本依据是：(i) 编译器中常量折叠的定义，它允许在编译时对纯计算进行求值，同时保持程序行为的观测等价性；以及 (ii) 任何此类转换都必须在所有与其规范一致的运行时环境下，保持程序的可观测输出不变的要求。此外，概率论中的期望值模型被用来量化不确定部署条件下的性能。\n\n假设AOT编译过程插入了一个运行时守卫，用于检查进程是否在“C”区域设置（locale）下执行。如果区域设置是“C”区域设置，该过程会输出预计算的常量字符串；否则，它会回退到调用 $printf$，以保留区域设置敏感的行为（例如，数字格式化或消息国际化选择）。设区域设置守卫的成本对于每次转换的实例都是一个常数时间 $ \\gamma $，且与分支结果无关。假设运行时的成本模型如下：\n- 一次带单个整数转换的 $printf(\"x=%d\", k)$ 调用运行时间为 $ t_{\\mathrm{printf}} $。\n- 通过一个轻量级函数（例如 $puts$）输出一个常量字符串的运行时间为 $ t_{\\mathrm{const}} $。\n- 区域设置守卫对于每次转换的实例成本为 $ \\gamma $ 时间。\n- 在比例为 $ p $ 的运行中，区域设置不是“C”区域设置，并且每次转换的实例都采用回退到 $printf$ 的路径；在比例为 $ 1 - p $ 的运行中，使用“C”区域设置，并且每次转换的实例都采用输出常量字符串的路径。\n\n考虑一个程序，其中有 $ n $ 个此模式的静态转换实例，并且每个这样的实例在每次运行时都精确执行 $ k $ 次。仅使用这些假设和期望值原理，从第一性原理出发，推导该AOT编译过程每次运行所节省的期望总运行时间，并以 $ n $、$ k $、$ t_{\\mathrm{printf}} $、$ t_{\\mathrm{const}} $、$ \\gamma $ 和 $ p $ 的封闭形式表达式表示。然后，对于给定的具体参数值\n$$\nn = 800, \\quad k = 25{,}000, \\quad t_{\\mathrm{printf}} = 800 \\text{ ns}, \\quad t_{\\mathrm{const}} = 120 \\text{ ns}, \\quad \\gamma = 20 \\text{ ns}, \\quad p = 0.15,\n$$\n对表达式进行数值计算，并将每次运行的最终期望总节省时间以秒为单位表示。将你的答案四舍五入到四位有效数字，并以秒为单位表示最终时间。", "solution": "目标是推导由一个转换特定 `printf` 调用的提前（AOT）编译过程所带来的每次运行的期望总运行时间节省的表达式。首先，我们建立有转换和无转换两种情况下程序行为的成本模型。\n\n设 $n$ 是被转换模式的静态实例数量，设 $k$ 是每个实例在每次运行中的执行次数。因此，被转换代码块的总动态执行次数 $N$ 为：\n$$ N = n \\times k $$\n\n没有AOT转换时的运行时成本很简单。$N$ 次动态执行中的每一次都涉及一次对 `printf` 的调用。总运行时间 $T_{\\mathrm{original}}$ 为：\n$$ T_{\\mathrm{original}} = N \\times t_{\\mathrm{printf}} = n \\times k \\times t_{\\mathrm{printf}} $$\n\n经过AOT转换后，引入了一个运行时守卫。执行路径取决于程序的区域设置。让我们分析程序单次运行的两种可能情况。\n\n情况1：区域设置不是“C”区域设置。\n该事件发生的概率为 $p$。在这种情况下，程序必须回退到原始的 `printf` 调用以确保正确性（例如，区域设置特定的数字格式化）。对于 $N$ 次动态执行中的每一次，成本包括区域设置守卫检查的成本 $\\gamma$ 和随后的 `printf` 调用本身的成本 $t_{\\mathrm{printf}}$。在此情况下，一次运行的总运行时间 $T_{\\mathrm{fallback}}$ 为：\n$$ T_{\\mathrm{fallback}} = N \\times (\\gamma + t_{\\mathrm{printf}}) = n \\times k \\times (\\gamma + t_{\\mathrm{printf}}) $$\n\n情况2：区域设置是“C”区域设置。\n该事件发生的概率为 $1 - p$。在这种情况下，将采用优化路径。对于 $N$ 次动态执行中的每一次，成本包括区域设置守卫检查的成本 $\\gamma$ 和随后的预计算常量字符串输出的成本 $t_{\\mathrm{const}}$。在此情况下，一次运行的总运行时间 $T_{\\mathrm{fast}}$ 为：\n$$ T_{\\mathrm{fast}} = N \\times (\\gamma + t_{\\mathrm{const}}) = n \\times k \\times (\\gamma + t_{\\mathrm{const}}) $$\n\n使用期望值原理，转换后的期望总运行时间 $E[T_{\\mathrm{transformed}}]$ 是每种情况的运行时间乘以其各自概率的加权和：\n$$ E[T_{\\mathrm{transformed}}] = T_{\\mathrm{fallback}} \\times p + T_{\\mathrm{fast}} \\times (1 - p) $$\n代入 $T_{\\mathrm{fallback}}$ 和 $T_{\\mathrm{fast}}$ 的表达式：\n$$ E[T_{\\mathrm{transformed}}] = [n \\times k \\times (\\gamma + t_{\\mathrm{printf}})] \\times p + [n \\times k \\times (\\gamma + t_{\\mathrm{const}})] \\times (1 - p) $$\n我们可以提出公因式 $n \\times k$：\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [p(\\gamma + t_{\\mathrm{printf}}) + (1 - p)(\\gamma + t_{\\mathrm{const}})] $$\n展开括号内的项：\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [p\\gamma + p \\cdot t_{\\mathrm{printf}} + \\gamma - p\\gamma + t_{\\mathrm{const}} - p \\cdot t_{\\mathrm{const}}] $$\n$$ E[T_{\\mathrm{transformed}}] = n \\times k \\times [\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}}] $$\n\n期望总节省运行时间 $E[T_{\\mathrm{saved}}]$ 是原始运行时间与期望转换后运行时间之差：\n$$ E[T_{\\mathrm{saved}}] = T_{\\mathrm{original}} - E[T_{\\mathrm{transformed}}] $$\n$$ E[T_{\\mathrm{saved}}] = (n \\times k \\times t_{\\mathrm{printf}}) - (n \\times k \\times [\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}}]) $$\n再次提出公因式 $n \\times k$：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [t_{\\mathrm{printf}} - (\\gamma + p \\cdot t_{\\mathrm{printf}} + (1 - p)t_{\\mathrm{const}})] $$\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [t_{\\mathrm{printf}} - \\gamma - p \\cdot t_{\\mathrm{printf}} - (1 - p)t_{\\mathrm{const}}] $$\n合并 $t_{\\mathrm{printf}}$ 项：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [(1 - p)t_{\\mathrm{printf}} - (1 - p)t_{\\mathrm{const}} - \\gamma] $$\n最后，提出公因式 $(1 - p)$，得到期望总节省时间的封闭形式表达式：\n$$ E[T_{\\mathrm{saved}}] = n \\times k \\times [(1 - p)(t_{\\mathrm{printf}} - t_{\\mathrm{const}}) - \\gamma] $$\n\n现在，我们使用给定的数值参数来计算这个表达式：\n$n = 800$, $k = 25{,}000$, $t_{\\mathrm{printf}} = 800 \\text{ ns}$, $t_{\\mathrm{const}} = 120 \\text{ ns}$, $\\gamma = 20 \\text{ ns}$，以及 $p = 0.15$。\n\n首先，计算总动态执行次数 $N$：\n$$ N = n \\times k = 800 \\times 25{,}000 = 20{,}000{,}000 = 2 \\times 10^7 $$\n接下来，计算每次执行的期望节省表达式的各个组成部分：\n$$ 1 - p = 1 - 0.15 = 0.85 $$\n$$ t_{\\mathrm{printf}} - t_{\\mathrm{const}} = 800 \\text{ ns} - 120 \\text{ ns} = 680 \\text{ ns} $$\n每次执行的期望节省为：\n$$ (1 - p)(t_{\\mathrm{printf}} - t_{\\mathrm{const}}) - \\gamma = (0.85)(680 \\text{ ns}) - 20 \\text{ ns} $$\n$$ = 578 \\text{ ns} - 20 \\text{ ns} = 558 \\text{ ns} $$\n总期望节省是动态执行次数与每次执行的期望节省的乘积：\n$$ E[T_{\\mathrm{saved}}] = (2 \\times 10^7) \\times (558 \\text{ ns}) = 1{,}116 \\times 10^7 \\text{ ns} = 1.116 \\times 10^{10} \\text{ ns} $$\n为了将此值以秒表示，我们使用转换关系 $1 \\text{ s} = 10^9 \\text{ ns}$：\n$$ E[T_{\\mathrm{saved}}] = \\frac{1.116 \\times 10^{10} \\text{ ns}}{10^9 \\text{ ns/s}} = 1.116 \\times 10^1 \\text{ s} = 11.16 \\text{ s} $$\n结果 $11.16$ 有四位有效数字，符合题目要求。", "answer": "$$\\boxed{11.16}$$", "id": "3620675"}, {"introduction": "优化的首要原则是正确性——即不能改变程序的合法行为。本练习探讨了AOT编译中最具挑战性的问题之一：在存在未定义行为（Undefined Behavior, UB）时如何安全地进行常量折叠。你将接触到一种用于保证编译安全的严格形式化方法，通过一个包含 `poison` 值的语义模型，来判断哪些看似无害的优化规则在面对依赖于输入的UB时实际上是危险的，从而深刻理解编译器设计的严谨性 [@problem_id:3620671]。", "problem": "一个提前（Ahead-of-Time, AOT）编译器在程序输入未知之前，对中间表示（Intermediate Representation, IR）应用常量折叠。考虑一个IR的直线代码子集，其中的表达式由整型变量和常量通过整数加法 $+$、乘法 $\\times$、按位与 $\\wedge$ 和整数除法 $\\div$ 构成。我们使用一种感知 poison 的指称语义来为潜在的未定义行为（Undefined Behavior, UB）建模，以在优化过程中保持健全性约束。\n\n基础：设值域为 $V = \\mathbb{Z} \\cup \\{\\mathsf{poison}\\}$。求值函数 $\\llbracket e \\rrbracket : \\mathbb{Z}^{k} \\to V$ 将一个带有 $k$ 个自由整型变量的表达式 $e$ 映射为一个整数或 $\\mathsf{poison}$。该语义由以下经过充分检验的规则定义：\n- Poison 的纯粹传播：对于任意二元运算符 $\\circ \\in \\{+, \\times, \\wedge, \\div\\}$ 和操作数 $v_1, v_2 \\in V$，如果 $v_1 = \\mathsf{poison}$ 或 $v_2 = \\mathsf{poison}$，则 $v_1 \\circ v_2 = \\mathsf{poison}$。\n- 整数除法：对于 $a, b \\in \\mathbb{Z}$，如果 $b = 0$，则 $a \\div b = \\mathsf{poison}$；否则 $a \\div b$ 是数学上的整数商；当两个操作数都在 $\\mathbb{Z}$ 中时，按位与及其他运算符在 $\\mathbb{Z}$ 上的行为符合标准。\n- 可观察性：返回 $\\mathsf{poison}$（或在控制流中使用它）在运行时构成 UB；$\\mathbb{Z}$ 中的整数结果是已定义行为。\n\n在保持 poison 的语义下，如果对于所有为 $e$ 的自由变量赋予整数值的环境 $\\rho \\in \\mathbb{Z}^{k}$，一个局部重写 $e \\Rightarrow e'$ 被称为 AOT 健全的（AOT-sound），\n- 如果 $\\llbracket e \\rrbracket(\\rho) \\in \\mathbb{Z}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\llbracket e \\rrbracket(\\rho)$（对已定义行为没有改变），并且\n- 如果 $\\llbracket e \\rrbracket(\\rho) = \\mathsf{poison}$，则 $\\llbracket e' \\rrbracket(\\rho) = \\mathsf{poison}$（poison 被保留而不是被静默消除）。\n\n这个语义捕捉了 AOT 编译器不能折叠掉依赖于输入的 UB 这一要求。\n\n考虑以下候选常量折叠规则，每条规则都意图在不求值子表达式、不窥视运行时输入的情况下局部应用：\n- A. 对于所有表达式 $e$，重写 $0 \\times e \\Rightarrow 0$。\n- B. 对于所有变量 $x$，重写 $x \\div x \\Rightarrow 1$。\n- C. 对于所有变量 $x$，重写 $x + 0 \\Rightarrow x$。\n- D. 对于所有表达式 $e$，重写 $e \\wedge 0 \\Rightarrow 0$。\n- E. 对于所有变量 $x$，在程序点上存在一个已被证明的静态前置条件 $x \\neq 0$ 的情况下，重写 $x \\div x \\Rightarrow 1$。\n\n在上述定义的保持 poison 的语义下，以上哪些规则是 AOT 健全的？选择所有适用的选项。", "solution": "要确定一个重写规则 $e \\Rightarrow e'$ 是否是 AOT 健全的，我们必须根据问题中定义的保持 poison 的语义，对所有可能的环境 $\\rho$（即为表达式中的自由变量赋予整数值的映射）进行检验。一个规则是健全的，当且仅当它同时满足以下两个条件：\n\n1.  **保持已定义行为**: 如果原始表达式 $\\llbracket e \\rrbracket(\\rho)$ 的求值结果是一个整数（即行为已定义），那么重写后的表达式 $\\llbracket e' \\rrbracket(\\rho)$ 的求值结果必须是同一个整数。\n2.  **保持未定义行为**: 如果原始表达式 $\\llbracket e \\rrbracket(\\rho)$ 的求值结果是 $\\mathsf{poison}$（即行为未定义），那么重写后的表达式 $\\llbracket e' \\rrbracket(\\rho)$ 的求值结果也必须是 $\\mathsf{poison}$。\n\n我们将逐一分析每个候选规则：\n\n**A. 对于所有表达式 $e$，重写 $0 \\times e \\Rightarrow 0$。**\n此规则不健全。考虑一个表达式 $e$，其求值结果为 $\\mathsf{poison}$，例如 $e = x \\div 0$。根据 poison 传播规则，左侧表达式 $0 \\times e$ 的求值结果是 $0 \\times \\mathsf{poison} = \\mathsf{poison}$。然而，右侧表达式 $0$ 的求值结果是整数 $0$。该重写将一个未定义行为（poison）转变为一个已定义行为（0），违反了第二个条件。\n\n**B. 对于所有变量 $x$，重写 $x \\div x \\Rightarrow 1$。**\n此规则不健全。考虑当变量 $x$ 的值为 $0$ 时的环境。左侧表达式 $x \\div x$ 的求值结果是 $0 \\div 0 = \\mathsf{poison}$。然而，右侧表达式 $1$ 的求值结果是整数 $1$。该重写将一个由除以零引起的未定义行为转变为一个已定义行为，违反了第二个条件。\n\n**C. 对于所有变量 $x$，重写 $x + 0 \\Rightarrow x$。**\n此规则是健全的。根据定义，变量 $x$ 在任何环境中都代表一个整数值。因此，左侧表达式 $x+0$ 的求值结果总是等于 $x$ 的整数值，绝不会是 $\\mathsf{poison}$。右侧表达式 $x$ 的求值结果也是同一个整数值。因此，对于所有已定义的行为，值都保持不变。由于左侧表达式永远不会产生 $\\mathsf{poison}$，第二个条件（保持未定义行为）是空真（vacuously true）的。两个条件都满足。\n\n**D. 对于所有表达式 $e$，重写 $e \\wedge 0 \\Rightarrow 0$。**\n此规则不健全。其逻辑与规则 A 相同。如果表达式 $e$ 的求值结果为 $\\mathsf{poison}$，那么左侧 $e \\wedge 0$ 的结果也是 $\\mathsf{poison}$。而右侧的结果是 $0$。该重写同样将未定义行为转变为已定义行为。\n\n**E. 对于所有变量 $x$，在程序点上存在一个已被证明的静态前置条件 $x \\neq 0$ 的情况下，重写 $x \\div x \\Rightarrow 1$。**\n此规则是健全的。静态前置条件 $x \\neq 0$ 明确排除了导致规则 B 不健全的唯一情况（即 $x=0$）。在此前置条件下，左侧表达式 $x \\div x$ 对于任何非零整数 $x$ 的求值结果总是 $1$。它永远不会是 $\\mathsf{poison}$。右侧表达式的求值结果也是 $1$。与规则 C 类似，已定义行为的值被保持，而未定义行为的条件永远不会触发，因此第二个条件空真。", "answer": "$$\\boxed{CE}$$", "id": "3620671"}]}