{"hands_on_practices": [{"introduction": "理解按名调用（call-by-name）的关键在于追踪参数的每一次使用，因为每次使用都会触发一次重新求值。这个练习 [@problem_id:3675795] 旨在训练你手动追踪一个程序在按名调用语义下的执行流程。通过精确计算一个 thunk 被“强制”求值的次数，你将为这种需求驱动的求值策略建立一个具体的、可操作的心理模型。", "problem": "在编译器原理的背景下，考虑一个通过 thunk 实现的一阶传名调用求值策略。Thunk 是一种延迟计算，表现为一个闭包，它捕获一个表达式及其环境，并且仅在其值被需要（强制求值）时才执行。在传名调用中，没有记忆化：每次使用形式参数都会从头开始重新对 thunk 求值。假设基本操作遵循确定的从左到右的求值顺序：对于加法运算符，先对左操作数求值，再对右操作数求值；对于条件表达式，先对条件求值，再对所选分支求值；对于词法绑定，$\\text{let}$ 按名称绑定（非严格），并且绑定的表达式直到绑定的名称被使用时才求值。\n\n设实际参数为表达式 $x_{n} = \\sum_{i=1}^{n} i$，其中 $n$ 是一个整数且 $n \\geq 1$，形式参数为 $a$。该参数作为一个 thunk $\\theta_{a}$ 传递给函数 $f$，每次引用 $a$ 时，$\\theta_{a}$ 都会重新计算 $x_{n}$。对运行时进行插桩，使得每次 $\\theta_{a}$ 被强制求值时，全局计数器 $F$ 增加 $1$。我们忽略任何其他成本，只计算 $\\theta_{a}$ 被强制求值的次数。\n\n定义函数 $f$ 如下，其中 $k$ 是一个非负整数参数：\n1. 辅助的复制函数定义为\n$$\\operatorname{rep}_{k}(a) = \\begin{cases}\n0,  \\text{if } k = 0, \\\\\na + \\operatorname{rep}_{k-1}(a),  \\text{if } k > 0,\n\\end{cases}$$\n加法从左到右求值。\n2. 函数 $f$ 定义为\n$$\nf(a, k) = \\text{if } a > 0 \\text{ then } \n\\Big(\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a)\n\\Big)\n\\text{ else } 0.\n$$\n\n在上述使用非记忆化 thunk 的传名调用语义下，并且 $n \\geq 1$ 的情况下，当实际参数是 $x_{n}$ 的 thunk $\\theta_{a}$ 时，请确定在 $f(a, k)$ 的求值过程中 $\\theta_{a}$ 被强制求值的总次数，并给出一个关于 $k$ 的封闭形式表达式。将你的最终答案表示为单个解析表达式。无需四舍五入。", "solution": "此推导的基本依据是带 thunk 的传名调用的定义：形式参数 $a$ 表示一个 thunk $\\theta_{a}$，当其被强制求值时，会在其捕获的环境中重新计算其关联的表达式。在没有记忆化的传名调用下，执行代码中 $a$ 的每一次语法出现都会导致 $\\theta_{a}$ 的一次单独的强制求值。我们还使用指定的基本操作从左到右的求值顺序以及将求值延迟到使用时的非严格 $\\text{let}$ 绑定。\n\n我们通过分析 $f(a, k)$ 求值过程中 $\\theta_{a}$ 的需求驱动的强制求值行为来继续，计算 $a$ 被引用的次数，从而得出 $\\theta_{a}$ 被强制求值的次数。我们假设 $n \\geq 1$，因此 $x_{n} = \\sum_{i=1}^{n} i$ 为正，所以 $a > 0$ 成立。因此，将执行 $\\text{then}$ 分支，而 $\\text{else}$ 分支不会被求值。\n\n步骤 1：对条件守卫 $a > 0$ 求值。\n- 条件引用了 $a$ 一次。\n- 这会强制求值 $\\theta_{a}$ 恰好一次。\n- 对 $F$ 的贡献：$1$。\n\n步骤 2：进入 $\\text{then}$ 分支并处理嵌套的 $\\text{let}$ 绑定。因为 $\\text{let}$ 是按名称绑定，所以右侧表达式在绑定时不会被求值，而只在它们绑定的名称被使用时才求值。\n\n$\\text{then}$ 分支的主体是：\n$$\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a).\n$$\n\n我们从左到右对最终表达式 $c + d + \\operatorname{rep}_{k}(a)$ 求值。\n\n步骤 2a：强制求值 $c$。\n- $c$ 定义为 $a + b$，从左到右求值。\n- 首先，对 $a + b$ 中的 $a$ 求值：这会强制求值 $\\theta_{a}$ 一次。\n- 接下来，对 $a + b$ 中的 $b$ 求值：这会强制求值 $b$。\n- 强制求值 $b$ 会对 $a + a$ 从左到右求值：\n  - 对左边的 $a$ 求值：强制求值 $\\theta_{a}$ 一次。\n  - 对右边的 $a$ 求值：强制求值 $\\theta_{a}$ 一次。\n- 由于 $c$ 导致的 $\\theta_{a}$ 总强制求值次数：$1$（对于 $a+b$ 中的 $a$）$+ 2$（对于 $b$ 中的两个 $a$）$= 3$。\n- 对 $F$ 的贡献：$3$。\n\n步骤 2b：强制求值 $d$。\n- $d$ 定义为 $b + b$，从左到右求值。\n- 对左边的 $b$ 求值：强制求值 $b$ 会对 $a + a$ 求值，这会强制求值 $\\theta_{a}$ 两次（左边的 $a$ 和右边的 $a$）。\n- 对右边的 $b$ 求值：再次强制求值 $b$ 会对 $a + a$ 求值，这会再强制求值 $\\theta_{a}$ 两次。\n- 由于 $d$ 导致的 $\\theta_{a}$ 总强制求值次数：$2 + 2 = 4$。\n- 对 $F$ 的贡献：$4$。\n\n步骤 2c：强制求值 $\\operatorname{rep}_{k}(a)$。\n- 定义为 $\\operatorname{rep}_{k}(a) = 0$（如果 $k=0$），否则为 $a + \\operatorname{rep}_{k-1}(a)$。\n- 对于 $k > 0$，每个递归步骤首先对 $a$ 求值（从左到右的加法），然后对 $\\operatorname{rep}_{k-1}(a)$ 进行递归。\n- 因此，对于 $k$ 个步骤中的每一个， $a$ 都被精确地引用一次，从而 $\\theta_{a}$ 在每个步骤中被强制求值一次。\n- 由于 $\\operatorname{rep}_{k}(a)$ 导致的 $\\theta_{a}$ 总强制求值次数：$k$。\n- 对 $F$ 的贡献：$k$。\n\n步骤 3：对所有贡献求和。\n- 来自条件守卫：$1$。\n- 来自强制求值 $c$：$3$。\n- 来自强制求值 $d$：$4$。\n- 来自强制求值 $\\operatorname{rep}_{k}(a)$：$k$。\n\n因此，在 $f(a, k)$ 的求值过程中，$\\theta_{a}$ 被强制求值的总次数是\n$$k + 1 + 3 + 4 = k + 8.$$\n\n这个计数仅取决于语法出现次数和指定的求值顺序；对于 $n \\geq 1$，$x_{n}$ 的值正确地保证了会执行 $\\text{then}$ 分支，但没有进一步的分支依赖于 $a$。因此，总强制求值次数的封闭形式表达式是 $k + 8$。", "answer": "$$\\boxed{k+8}$$", "id": "3675795"}, {"introduction": "按名调用固有的重复求值特性会对性能产生显著影响，因此理解其成本至关重要。这个练习 [@problem_id:3675854] 将带领你从简单的执行追踪转向成本分析，通过应用一个形式化的成本模型，你将学会量化重复 thunk 求值带来的性能开销。此外，你还将探索一种通过共享计算结果来模拟按需调用（call-by-need）的优化策略，从而为在实际编译器设计中做出明智的性能决策打下基础。", "problem": "一个严格一阶算术语言的编译器通过 thunk 实现传名调用（call-by-name）。Thunk 是一个闭包，它存储了一个未求值的参数表达式及其环境。强制求值一个 thunk 会在捕获的环境中触发该表达式的求值。在纯粹的传名调用下，每次强制求值都会重新对表达式进行求值。考虑函数体 $f(x,y) = x + y + x$，并假设加法是对其两个操作数都严格的基本运算符。\n\n假设使用以下成本模型，其中所有成本都是可相加的：\n- 强制求值任意 thunk 一次，会产生固定的开销成本 $h$。\n- 求值 $x$ 的表达式（不包括 thunk 开销）的成本为 $c_{x}$。\n- 求值 $y$ 的表达式（不包括 thunk 开销）的成本为 $c_{y}$。\n- 每次基本加法 $+$ 的成本为 $a$。\n- 作为一种可选的转换，编译器可以引入一个局部绑定，在 $x$ 的多次使用中共享其值（仅对 $x$ 模拟传需调用 (call-by-need)）：以成本 $m$ 分配一次单元，以成本 $s$ 存储一次首次求值的结果，并通过以成本 $r$ 从该单元中获取值来满足 $x$ 的每次后续使用，而无需重新求值 $x$ 表达式。$x$ 的第一次使用仍然会强制求值 thunk 并进行求值，产生 $h + c_{x}$ 的成本。\n\n从传名调用 thunk 和 $+$ 的严格求值的基本定义出发，进行以下推理：\n- 确定函数体 $f(x,y) = x + y + x$ 中每个参数 $x$ 和 $y$ 的动态强制求值乘数。\n- 根据成本模型的第一性原理和确定的乘数，推导出在纯粹的传名调用（无共享）下求值 $f(x,y)$ 的总执行成本。\n- 如果编译器仅对 $x$ 应用共享转换（不共享 $y$），推导出总执行成本。\n- 讨论使用结合律和交换律重排加数（例如，$(x + x) + y$ 或 $y + x + x$）是否会改变任一机制下的总成本，并选择使总成本最小化的方案（纯粹的传名调用 vs. 共享 $x$）和顺序。\n- 使用参数值 $h = 3$, $c_{x} = 40$, $c_{y} = 10$, $a = 1$, $m = 2$, $s = 1$ 和 $r = 1$，计算在最优方案和顺序下求值 $f(x,y)$ 的最小总成本。\n\n将您的最终答案表示为一个不带单位的实数值。无需进行四舍五入。", "solution": "首先进行问题验证。\n\n**步骤 1：提取已知条件**\n- 函数体：$f(x,y) = x + y + x$\n- 求值策略：通过 thunk 的传名调用\n- 基本运算符：$+$ 对其两个操作数都是严格的\n- 成本模型参数（均可相加）：\n  - Thunk 强制求值开销：$h$\n  - $x$ 表达式的求值成本：$c_{x}$\n  - $y$ 表达式的求值成本：$c_{y}$\n  - 基本加法成本：$a$\n- 仅对 $x$ 的共享转换：\n  - 分配成本：$m$（一次）\n  - 存储成本：$s$（在首次求值时）\n  - 检索成本：$r$（在后续使用时）\n- 共享 $x$ 的第一次使用仍然产生强制求值和表达式求值的成本，因此其总成本为 $h + c_{x} + s$。\n- 用于最终计算的参数值：$h=3$, $c_x=40$, $c_y=10$, $a=1$, $m=2$, $s=1$, $r=1$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确，且客观。这是编译器设计和程序语言理论领域一个标准的、可形式化的问题。成本模型有明确定义，并且所有必要的参数都已提供。不存在矛盾、歧义或事实上的不健全之处。问题有效。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n**推理过程**\n\n**1. 动态强制求值乘数**\n函数体为 $f(x,y) = x + y + x$。假设 $+$ 运算符具有标准的从左到右的结合性，则该表达式的求值顺序为 $(x+y)+x$。$+$ 运算符是严格的，这意味着它必须对其两个操作数都进行求值才能产生结果。\n- 为了求值外层的 $+$，运行时系统必须首先求值其左操作数 $(x+y)$ 和其右操作数 $x$。\n- 为了求值子表达式 $(x+y)$，运行时必须求值其操作数 $x$ 和 $y$。这需要强制求值 $x$ 的 thunk（第一次）和强制求值 $y$ 的 thunk（第一次）。\n- 在计算出 $(x+y)$ 的值后，主表达式的求值继续。运行时现在求值外层 $+$ 的右操作数，即 $x$。这需要第二次强制求值 $x$ 的 thunk。\n因此，$x$ 的动态强制求值乘数为 $2$，$y$ 的动态强制求值乘数为 $1$。\n\n**2. 纯粹传名调用（CBN）下的总成本**\n在纯粹的传名调用机制下，每次强制求值一个参数的 thunk 时，其对应的表达式都会被重新求值。\n求值一次 $x$ 的成本是 thunk 开销 $h$ 和表达式求值成本 $c_x$ 的总和，共计 $h+c_x$。\n求值一次 $y$ 的成本是 $h+c_y$。\n该表达式有两个加法运算，总共贡献成本 $2a$。\n总成本 $C_{CBN}$ 是两次求值 $x$、一次求值 $y$ 和两次加法成本的总和。\n$$C_{CBN} = 2(h + c_x) + 1(h + c_y) + 2a$$\n$$C_{CBN} = 2h + 2c_x + h + c_y + 2a = 3h + 2c_x + c_y + 2a$$\n\n**3. 对 $x$ 进行共享转换的总成本**\n通过这种转换，$x$ 的值只计算一次并被存储起来。\n- 产生一次性成本 $m$ 用于为 $x$ 的值分配一个单元。\n- 第一次需要 $x$ 时，其 thunk 被强制求值（成本 $h$），其表达式被求值（成本 $c_x$），并且结果被存储（成本 $s$）。这第一次使用的成本是 $h + c_x + s$。\n- 第二次（以及任何后续）需要 $x$ 时，从单元中检索其值的成本为 $r$。\n- 参数 $y$ 不被共享，因此其单次使用的成本为 $h+c_y$。\n- 两次加法仍然贡献成本 $2a$。\n总成本 $C_{share-x}$ 是这些单个成本的总和。\n$$C_{share-x} = m + (h+c_x+s) + r + (h+c_y) + 2a$$\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n\n**4. 最优方案和顺序**\n问题要求考虑重排加数，例如改为 $(x+x)+y$。由于加法是严格的，每个操作数必须被求值的总次数由其在表达式中出现的次数决定，而与组合方式无关。在 $x+y+x$ 中，$x$ 出现两次，$y$ 出现一次。任何重排，如 $(x+x)+y$ 或 $y+(x+x)$，都保留了这个计数。因此，纯粹 CBN 和共享机制的总成本都与求值顺序无关。所以顺序不是影响最小成本的因素。\n\n通过比较 $C_{CBN}$ 和 $C_{share-x}$ 来找到最优方案。如果 $C_{share-x}  C_{CBN}$，则共享方案更优。\n$$m + s + r + 2h + c_x + c_y + 2a  3h + 2c_x + c_y + 2a$$\n从两侧减去公共项（$2h + c_x + c_y + 2a$），我们将不等式简化为：\n$$m + s + r  h + c_x$$\n这个不等式表明，如果共享的总开销（$m+s+r$）小于它所节省的重新求值成本（$h+c_x$），那么共享是有利的。\n\n**5. 最小总成本计算**\n我们使用给定的参数值：$h=3$, $c_x=40$, $c_y=10$, $a=1$, $m=2$, $s=1$, $r=1$。\n首先，我们检查条件以确定最优方案：\n$$m + s + r  h + c_x$$\n$$2 + 1 + 1  3 + 40$$\n$$4  43$$\n该条件成立，因此最优方案是对 $x$ 使用共享转换。最小成本是 $C_{share-x}$。\n我们现在计算这个成本：\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n$$C_{share-x} = 2 + 1 + 1 + 2(3) + 40 + 10 + 2(1)$$\n$$C_{share-x} = 4 + 6 + 40 + 10 + 2$$\n$$C_{share-x} = 62$$\n为完整起见，纯粹 CBN 下的成本将是：\n$$C_{CBN} = 3h + 2c_x + c_y + 2a = 3(3) + 2(40) + 10 + 2(1) = 9 + 80 + 10 + 2 = 101$$\n正如预期的那样，$62  101$。最小成本是 $62$。", "answer": "$$\\boxed{62}$$", "id": "3675854"}, {"introduction": "真正理解一种求值策略的最佳方式是亲手实现它。这个顶石练习 [@problem_id:3675780] 将指导你构建一个最小化的求值器来模拟和检测 thunk 的强制执行。通过编写一个能够为求值事件添加时间戳的工具，你不仅能直观地看到重复计算在不同代码结构（如循环）中的具体影响，还能将抽象的理论转化为具体、可运行的代码，从而深化你的理解。", "problem": "你需要构建一个最小求值器，该求值器使用“thunk”来模拟“传名调用 (call-by-name)”，并记录当一个变量在不同句法上下文中使用时，其重计算的次数和时间。在传名调用中，参数在调用点不会被求值；而是在被调用者（callee）内部，每次使用该参数都会重新触发求值。一个标准的编译器实现使用一个“thunk”来表示未求值的表达式及其环境，并使用一个“强制 (force)”操作来对该thunk进行求值。你必须记录每一次 `force` 的调用，以便为每个强制事件附加一个单调递增的逻辑时间戳。\n\n从一个基本点开始：在传名调用下，一个参数被建模为一个thunk（我们用 $\\theta$ 表示），它由一个计算函数和一个环境组成，并且操作 $force(\\theta)$ 会触发对所包含表达式的求值。这遵循了 lambda 演算中经过充分检验的求值策略和标准的编译器构造原则。设 $x$ 是一个绑定到thunk的参数。在一个使用 $x$ 的循环中，每次使用都会强制对该thunk求值，从而导致重计算。在循环之外，单次使用仅导致一次重计算。\n\n你必须实现一个程序，该程序：\n- 用一个计算函数 $f$ 和一个环境 $E$ 来表示一个 thunk $\\theta$。\n- 实现 $force(\\theta)$，该操作执行以下步骤：\n  1. 将逻辑时间计数器 $t$ 增加 $1$。\n  2. 将当前时间戳 $\\tau_t$ 记录到一个可增长的列表中。\n  3. 执行 $f(E)$ 以产生一个值（你可以丢弃该值；重点在于时间戳）。\n- 执行一组场景，在这些场景中，变量 $x$ 在循环内部和外部被使用，从而生成不同的 $\\tau_i$ 模式。\n\n定义以下测试套件，其参数涵盖了典型情况和边界情况：\n1. 情况 A（仅在外部使用）：基值 $b_A = 3$，外部使用次数 $U_A = 1$，无循环使用（$O_A=0$, $I_A=0$）。预期得到一个包含单个时间戳的列表，因为 $x$ 在任何循环之外仅使用一次。\n2. 情况 B（单层循环）：基值 $b_B = 5$，外部使用次数 $U_B = 0$，单层循环，迭代次数 $O_B = 8$，$I_B = 1$。预期得到 8 个时间戳，对应于循环内的使用。\n3. 情况 C（嵌套循环）：基值 $b_C = 7$，外部使用次数 $U_C = 0$，嵌套循环，外层迭代 $O_C = 3$ 次，内层迭代 $I_C = 4$ 次。预期得到 12 个时间戳，对应于 $O_C \\times I_C$ 次使用。\n4. 情况 D（边界零迭代循环）：基值 $b_D = 11$，外部使用次数 $U_D = 0$，无循环使用（$O_D = 0$, $I_D = 0$）。预期得到一个空的时间戳列表，因为 $x$ 从未使用过。\n\n对于每种情况，将逻辑时间计数器 $t$ 重置为 $0$ 开始，并收集时间戳序列 $\\{\\tau_1, \\tau_2, \\ldots, \\tau_n\\}$，其中每个 $\\tau_i$ 是第 $i$ 次强制事件时的逻辑时间。你的程序应为每个测试用例生成整数列表形式的时间戳序列。不涉及物理单位，也没有角度。此任务中不含百分比。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表，列表中的每个元素本身是对应一个情况的时间戳列表。确切格式必须是：\n$[[\\tau^{(A)}_1,\\ldots,\\tau^{(A)}_{n_A}],[\\tau^{(B)}_1,\\ldots,\\tau^{(B)}_{n_B}],[\\tau^{(C)}_1,\\ldots,\\tau^{(C)}_{n_C}],[\\tau^{(D)}_1,\\ldots,\\tau^{(D)}_{n_D}]]$。\n例如，如果一个情况产生的时间戳为 $\\{1,2\\}$，则在外层列表中应打印为 $[1,2]$。最后一行必须是这种聚合格式，不得包含任何额外文本。\n\n该场景纯粹是根据求值策略和记录的数学与逻辑术语来制定的。不需要使用抽象语法树（AST）或中间表示（IR）；你可以直接使用循环和函数调用来模拟求值上下文。\n\n为覆盖率设计：\n- 情况 A 是一般的“理想路径”循环外使用情况。\n- 情况 B 演示了单层循环内的重复重计算。\n- 情况 C 通过嵌套循环放大了重计算。\n- 情况 D 是零迭代和零使用的边界条件。\n\n每个测试用例的答案是按规定格式的整数时间戳列表。", "solution": "该问题已经过验证，被确定为一项在编译器原理和程序设计语言理论方面定义明确且具有科学依据的练习。它要求使用 thunk 来模拟传名调用 (call-by-name) 求值策略，并记录求值事件。给定的条件是完整的、一致的，并且足以推导出唯一的解决方案。\n\n这个问题的核心在于对传名调用求值行为的建模。传名调用是一种参数传递机制，其中参数表达式在函数调用前不被求值，而是作为未求值的计算传递。这些计算在函数体内每次访问相应参数时都会被重新求值。对此，一种标准且高效的实现技术是使用**thunk**。\n\n一个thunk（我们用 $\\theta$ 表示）是一个数据结构，它封装了一个表达式以及该表达式应在其中求值的环境。它可以被形式化地表示为一个对偶 $\\theta = (f, E)$，其中 $f$ 是表示表达式计算的函数，$E$ 是包含该表达式中任何自由变量值的词法环境。表达式的求值被推迟，直到通过 `force` 操作显式请求。\n\n`force(\\theta)` 操作通过将函数应用于其环境（即计算 $f(E)$）来触发求值。问题要求我们记录此操作。为此，我们引入一个全局逻辑时钟，由一个计数器 $t$ 表示，该计数器在每个模拟场景中初始化为 $0$。被记录的 `force` 操作遵循以下步骤：\n1. 增加逻辑时钟：$t \\leftarrow t + 1$。\n2. 将 $t$ 的新值记录为时间戳 $\\tau$。对于一个给定场景，时间戳序列将是 $\\{\\tau_1, \\tau_2, \\ldots, \\tau_n\\}$。\n3. 执行thunk的计算 $f(E)$。\n\n模拟将用 C 语言实现。thunk $\\theta$ 使用一个 `struct` 建模，该结构体包含一个用于 $f$ 的函数指针和一个用于环境 $E$ 的 `void*` 指针。环境本身是另一个 `struct`，持有每个测试用例 $k$ 的基值 $b_k$。一个专用的 `Instrumentation` 结构将管理逻辑时间 $t$ 和一个用于存储所收集时间戳的动态大小数组。\n\n模拟逻辑的步骤是：为一个变量 $x$ 设置一个thunk，然后在测试用例参数定义的上下文中使用 $x$。每次“使用” $x$ 都直接转化为对 `force` 函数的调用。外部使用次数由 $U_k$ 给出，循环内的使用次数由外层循环迭代次数 $O_k$ 和内层循环迭代次数 $I_k$ 的乘积给出。因此，对于给定的测试用例 $k$，`force` 操作的总次数（也就是生成的时间戳总数）是 $N_k = U_k + O_k \\times I_k$。\n\n对于每个测试用例，逻辑时钟 $t$ 从 $0$ 开始。第一次 `force` 调用将 $t$ 增加到 $1$ 并记录 $\\tau_1=1$。第二次 `force` 调用将 $t$ 增加到 $2$ 并记录 $\\tau_2=2$，依此类推。情况 $k$ 的最终时间戳序列将是 $\\{1, 2, \\ldots, N_k\\}$。\n\n我们现在将此模型应用于指定的测试用例：\n1.  **情况 A**：参数为 $b_A = 3$, $U_A = 1$, $O_A=0$, $I_A=0$。总使用次数 $N_A = 1 + 0 \\times 0 = 1$。时钟重置为 $t=0$。执行一次 `force` 操作。时钟增加到 $t=1$。最终的时间戳列表是 $[1]$。\n2.  **情况 B**：参数为 $b_B = 5$, $U_B = 0$, $O_B=8$, $I_B=1$。总使用次数 $N_B = 0 + 8 \\times 1 = 8$。时钟重置为 $t=0$。执行八次 `force` 操作。时钟从 $1$ 顺序增加到 $8$。最终的时间戳列表是 $[1, 2, 3, 4, 5, 6, 7, 8]$。\n3.  **情况 C**：参数为 $b_C = 7$, $U_C = 0$, $O_C=3$, $I_C=4$。总使用次数 $N_C = 0 + 3 \\times 4 = 12$。时钟重置为 $t=0$。执行十二次 `force` 操作。时钟从 $1$ 增加到 $12$。最终的时间戳列表是 $[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$。\n4.  **情况 D**：参数为 $b_D = 11$, $U_D = 0$, $O_D=0$, $I_D=0$。总使用次数 $N_D = 0 + 0 \\times 0 = 0$。时钟重置为 $t=0$。执行零次 `force` 操作。时钟从未增加。最终的时间戳列表是空的，表示为 $[\\ ]$。\n\n最终的 C 程序将系统地执行这些模拟，并将收集到的时间戳列表格式化为指定的精确输出字符串。", "answer": "[[1],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9,10,11,12],[]]", "id": "3675780"}]}