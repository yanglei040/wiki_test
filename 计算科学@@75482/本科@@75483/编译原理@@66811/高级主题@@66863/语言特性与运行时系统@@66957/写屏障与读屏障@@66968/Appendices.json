{"hands_on_practices": [{"introduction": "卡片标记（Card marking）是分代垃圾回收器中实现写屏障的一种广泛应用的技术。该技术的效率取决于多种因素，包括对象布局、指针大小以及卡片表的粒度。这项练习 [@problem_id:3683420] 旨在挑战你从第一性原理出发，推导出一个精确的数学模型，从而量化写屏障的开销，并理解架构参数如何影响其性能。", "problem": "一个受管理的运行时使用分代垃圾回收（GC），其写屏障在堆上维护一个卡表。堆是字节可寻址的，并被划分为大小相等的连续区域，称为卡。一个卡的大小为 $C$ 字节，其整数索引定义为目标地址除以 $C$ 的向下取整。当一个指向年轻代对象的指针被存入一个老年代对象时，写屏障会标记包含目标地址的卡。\n\n考虑一个老年代对象，其基地址 $b$ 按 $A$ 字节对齐，即 $b \\equiv 0 \\pmod{A}$。该对象包含一个连续排列的指针字段数组，其中第 $i$ 个指针字段的起始地址为 $b + i s$，其中 $s$ 是指针的大小（以字节为单位），且 $i \\in \\{0, 1, \\dots, n\\}$。假设循环\n\nfor $i = 0..n$:\n- store a pointer to a younger-generation object into the field at offset $b + i s$\n\n被执行，并且对于每次存储操作，写屏障都会标记相应的卡。假设每次存储只标记包含目标字段第一个字节的卡。\n\n仅使用上述定义，从第一性原理推导出一个闭式表达式，用于表示在整个循环中可能被标记的不同卡表条目的最小可能数量。该表达式是 $n$、$s$、$C$ 和 $A$ 的函数，并考虑到约束条件，即 $b$ 必须满足 $b \\equiv 0 \\pmod{A}$，但可以在所有此类对齐地址上变化。然后，对于具体参数 $n = 4095$，$s = 8$ 字节，$C = 128$ 字节，以及 $A = 16$ 字节，计算这个最小数量。最终数值答案需精确表示，无需四舍五入。", "solution": "题目要求计算在一个循环中，当写屏障将指针存入老年代对象内的数组时，所标记的不同卡表条目的最小可能数量。\n\n设给定条件如下：\n- 每个卡的大小 $C$。\n- 指针的大小 $s$。\n- 数组中指针字段的数量为 $n+1$，索引为 $i \\in \\{0, 1, \\dots, n\\}$。\n- 对象的基地址 $b$ 按 $A$ 字节对齐，即 $b \\equiv 0 \\pmod{A}$。\n- 第 $i$ 个指针字段的地址是 $b + i s$。\n- 地址 `addr` 的卡索引是 $\\lfloor \\text{addr} / C \\rfloor$。\n- 写屏障标记被写入字段的第一个字节对应的卡，因此对于第 $i$ 次存储，被标记的卡索引是 $k_i(b) = \\lfloor \\frac{b+is}{C} \\rfloor$。\n\n对于给定的基地址 $b$，在整个循环中标记的不同卡的总数是生成的唯一卡索引集合的大小：\n$$N(b) = \\left| \\left\\{ \\lfloor \\frac{b+is}{C} \\rfloor \\mid i \\in \\{0, 1, \\dots, n\\} \\right\\} \\right|$$\n我们需要在所有可能的有效基地址 $b$（其中 $b$ 必须是 $A$ 的倍数）上找到 $N(b)$ 的最小值。设这个最小值为 $N_{min}$。\n$$N_{min} = \\min_{b: b \\equiv 0 \\pmod{A}} N(b)$$\n\n为了分析 $N(b)$，我们来考察连续两次存储的卡索引之差：\n$$k_{i+1}(b) - k_i(b) = \\left\\lfloor \\frac{b+(i+1)s}{C} \\right\\rfloor - \\left\\lfloor \\frac{b+is}{C} \\right\\rfloor$$\n令 $x = \\frac{b+is}{C}$ 且 $y = \\frac{s}{C}$。该差值为 $\\lfloor x+y \\rfloor - \\lfloor x \\rfloor$。根据向下取整函数的性质，我们知道对于任意实数 $x, y$，$\\lfloor x+y \\rfloor - \\lfloor x \\rfloor$ 的值要么是 $\\lfloor y \\rfloor$，要么是 $\\lfloor y \\rfloor + 1$。\n因此，差值 $k_{i+1}(b) - k_i(b)$ 只能取两个值之一：$\\lfloor s/C \\rfloor$ 或 $\\lfloor s/C \\rfloor + 1$。这一观察是推导的关键，并且与 $b$ 和 $i$ 无关。\n\n我们根据指针大小 $s$ 和卡大小 $C$ 之间的关系考虑两种情况。\n\n情况1：$s \\ge C$\n在这种情况下，$\\lfloor s/C \\rfloor \\ge 1$。\n因此，连续卡索引之间的差值为：\n$$k_{i+1}(b) - k_i(b) \\ge \\lfloor s/C \\rfloor \\ge 1$$\n这表明对于 $i \\in \\{0, 1, \\dots, n\\}$，$k_i(b)$ 是一个严格递增的序列。\n$$k_0(b)  k_1(b)  k_2(b)  \\dots  k_n(b)$$\n由于所有卡索引都是不同的，被标记的不同卡的总数等于总存储次数，即 $n+1$。这个结果对于任何有效的基地址 $b$ 都成立。\n因此，如果 $s \\ge C$，被标记的卡的最小数量是 $N_{min} = n+1$。\n\n情况2：$s  C$\n在这种情况下，$\\lfloor s/C \\rfloor = 0$。\n连续卡索引之间的差值为：\n$$k_{i+1}(b) - k_i(b) \\in \\{0, 1\\}$$\n这意味着卡索引序列 $k_i(b)$ 是非递减的，并且每一步最多增加1。因此，被标记的卡索引集合 $\\{k_0(b), k_1(b), \\dots, k_n(b)\\}$ 构成一个从最小索引 $k_0(b)$ 到最大索引 $k_n(b)$ 的连续整数范围。\n这个连续范围中不同元素的数量是：\n$$N(b) = k_n(b) - k_0(b) + 1 = \\left\\lfloor \\frac{b+ns}{C} \\right\\rfloor - \\left\\lfloor \\frac{b}{C} \\right\\rfloor + 1$$\n使用恒等式 $\\lfloor x+y \\rfloor - \\lfloor x \\rfloor = \\lfloor y \\rfloor + \\lfloor \\{x\\} + \\{y\\} \\rfloor$，我们可以将其重写为 $\\lfloor \\frac{ns}{C} + \\frac{b \\pmod C}{C} \\rfloor + 1$。更直接地，使用 $\\lfloor x+y \\rfloor$ 的属性，我们可以写成：\n$$N(b) = \\left\\lfloor \\frac{b}{C} + \\frac{ns}{C} \\right\\rfloor - \\left\\lfloor \\frac{b}{C} \\right\\rfloor + 1$$\n令 $x = b/C$。表达式为 $\\lfloor x + ns/C \\rfloor - \\lfloor x \\rfloor + 1$。这等于 $\\lfloor ns/C \\rfloor$ 或 $\\lfloor ns/C \\rfloor + 1$，取决于 $b \\pmod C$。\n为了最小化 $N(b)$，我们必须通过选择一个满足对齐约束 $b \\equiv 0 \\pmod A$ 的最优基地址 $b$ 来最小化 $b \\pmod C$ 这一项。\n$$N(b) = \\left\\lfloor \\frac{(b \\pmod C) + ns}{C} \\right\\rfloor + 1$$\n约束条件 $b \\equiv 0 \\pmod A$ 意味着 $b$ 是 $A$ 的倍数，即对于某个整数 $k$，$b=kA$。我们需要找到 $(kA) \\pmod C$ 的最小非负值。集合 $\\{ (kA) \\pmod C \\mid k \\in \\mathbb{Z} \\}$ 正是 $A$ 和 $C$ 的最大公约数的所有非负倍数的集合，即 $\\{ m \\cdot \\gcd(A, C) \\mid m \\in \\mathbb{Z}, m \\ge 0 \\}$。该集合中的最小值为 $0$。\n当 $b$ 同时是 $A$ 和 $C$ 的倍数时，可以得到 $b \\pmod C$ 的这个最小值。这样的 $b$ 是存在的；例如，我们可以选择 $b$ 为 $A$ 和 $C$ 的最小公倍数的任意倍数，例如 $b = \\text{lcm}(A, C)$。这个选择满足 $b \\equiv 0 \\pmod A$ 且 $b \\pmod C = 0$。\n设置 $b \\pmod C = 0$ 可以使 $N(b)$ 最小化。被标记的卡的最小数量是：\n$$N_{min} = \\left\\lfloor \\frac{0 + ns}{C} \\right\\rfloor + 1 = \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1$$\n\n结合两种情况，被标记的卡的最小数量的闭式表达式为：\n$$ N_{min} = \\begin{cases} \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1  \\text{if } s  C \\\\ n+1  \\text{if } s \\ge C \\end{cases} $$\n\n现在，我们使用具体参数 $n = 4095$，$s = 8$ 字节，$C = 128$ 字节，以及 $A = 16$ 字节来计算这个最小数量。\n\n首先，我们比较 $s$ 和 $C$：\n$s = 8$ 且 $C = 128$。\n因为 $8  128$，所以我们有 $s  C$。因此我们使用情况2的公式。\n$$N_{min} = \\left\\lfloor \\frac{ns}{C} \\right\\rfloor + 1$$\n代入给定值：\n$$N_{min} = \\left\\lfloor \\frac{4095 \\times 8}{128} \\right\\rfloor + 1$$\n我们简化分数：\n$$\\frac{4095 \\times 8}{128} = \\frac{4095}{16}$$\n现在我们进行除法运算：\n$$4095 = 16 \\times 255 + 15$$\n所以，分数为：\n$$\\frac{4095}{16} = 255 + \\frac{15}{16} = 255.9375$$\n对该值向下取整：\n$$\\left\\lfloor \\frac{4095}{16} \\right\\rfloor = \\lfloor 255.9375 \\rfloor = 255$$\n最后，我们加 $1$ 得到被标记的卡的最小数量：\n$$N_{min} = 255 + 1 = 256$$\n可以被标记的不同卡表条目的最小数量是 $256$。", "answer": "$$\n\\boxed{256}\n$$", "id": "3683420"}, {"introduction": "写屏障对于保证垃圾回收的正确性至关重要，但它们也带来了运行时开销。一个智能的编译器可以消除冗余的写屏障，从而提升程序性能。这项实践 [@problem_id:3683370] 探讨了可以安全移除写屏障的条件，重点关注死代码消除等编译器优化与垃圾回收器内存视图之间的相互作用，后者仅在安全点（safepoints）更新。通过分析这些场景，你将加深对记忆集（remembered set）不变量以及相对于垃圾回收的原子性概念的理解。", "problem": "考虑一个使用分代垃圾回收 (GC) 的语言运行时，它通过写屏障 (write barrier) 维护一个记录了从老年代到新生代引用的记忆集 (remembered set)。令 $O$ 表示老年代对象的集合，$Y$ 表示新生代对象的集合。在时间 $t$ 进行一次新生代回收 (minor collection) 时，记忆集不变性 (remembered set invariant) 为：对于每个 $o \\in O$ 和字段 $g$，如果在回收开始时指针值 $o.g(t) \\in Y$，那么包含 $o$ 的卡页 (card) 必须被记录在记忆集中，以便回收器扫描它。\n\n假设一个编译器正在考虑对一个对象 $x$ 的同一字段进行的两次连续指针写入进行死存储消除 (dead store elimination)：\n- 首先在时间 $t_0$ 执行 $x.f := p$，紧接着\n- 在时间 $t_1$ 执行 $x.f := q$，其中 $t_0  t_1$，\n并且第一次写入 $x.f := p$ 当前有关联的写屏障。\n\n假设：\n- 新生代回收只能在线程安全点 (thread safepoint) 开始（例如，在 $t_s$ 时刻），\n- 写屏障用于维护从老年代到新生代引用的记忆集信息，\n- 不同的屏障实现可能是值条件性的 (value-conditional)（仅当存入的值在 $Y$ 中时才记录）或无条件卡页标记 (unconditional card marking)（对老年代对象的任何指针存储都标记其卡页）。\n\n在下列哪些条件下，编译器可以移除与第一次存储 $x.f := p$ 相关联的写屏障，而不会违反记忆集不变性？选择所有适用的选项。\n\nA. $x \\in Y$（即，$x$ 在新生代中分配），不论 $p$ 和 $q$ 的年龄以及调度如何。\n\nB. 在 $t_0$ 和 $t_1$ 之间没有安全点（因此在 $(t_0, t_1)$ 期间没有新生代 GC 可以开始），不论屏障是值条件性的还是无条件的。\n\nC. $p \\notin Y$（例如，$p$ 是 $\\text{null}$ 或已晋升到老年代），与 $x$ 和 $q$ 的年龄以及调度无关。\n\nD. 运行时采用读屏障 (read barrier) 来维护记忆集，因此可以省略存储操作上的写屏障。", "solution": "任务是确定在哪些条件下，编译器可以安全地移除两次连续写入中第一次写入 $x.f := p$ 所关联的写屏障，而不会违反垃圾回收器的记忆集不变性。\n\n问题陈述定义了系统和不变性：\n- 系统使用分代垃圾回收器 (GC)，有一个老年代 ($O$) 和一个新生代 ($Y$)。\n- 系统维护一个记忆集来跟踪从 $O$ 中对象到 $Y$ 中对象的指针。这是通过写屏障实现的。\n- 在时间 $t$ 进行新生代回收时，记忆集不变性为：对于每个字段为 $g$ 的对象 $o \\in O$，如果指针值 $o.g(t)$ 是 $Y$ 中的一个对象，那么包含 $o$ 的卡页必须在记忆集中。\n- 所考虑的代码序列是在时间 $t_0$ 执行 $x.f := p$，紧接着在时间 $t_1$ 执行 $x.f := q$。\n- 我们正在考虑消除与第一次存储 $x.f := p$ 相关的写屏障。\n- GC 只能在线程安全点发生。\n\n仅当一次 `object.field := value` 的存储操作可能创建一个能被垃圾回收器观察到的从老年代到新生代的指针（即 `object` $\\in O$ 且 `value` $\\in Y$），并且这一事实没有通过其他方式记录时，与该存储操作关联的写屏障才是必要的。如果第一次写入的屏障被移除，系统的正确性将依赖于第二次写入的屏障，以及中间状态（$x.f = p$）要么不是一个从老年代到新生代的指针，要么对 GC 不可见的条件。\n\n让我们逐一评估每个选项：\n\n**A. $x \\in Y$（即，$x$ 在新生代中分配），不论 $p$ 和 $q$ 的年龄以及调度如何。**\n\n记忆集不变性专门适用于源自老年代 $O$ 中对象的指针。该不变性被表述为“对于每个 $o \\in O$...”。如果其字段被修改的对象 $x$ 本身就在新生代中（$x \\in Y$），那么 $x \\notin O$。因此，存储在 $x$ 的字段中的任何指针（即 $x.f := p$）都不会创建一个从老年代到新生代的指针。它可能创建从新生代到新生代或从新生代到老年代的指针，这两种指针都不会被用于新生代回收的记忆集所跟踪。由于不变性的基本前提（源对象在 $O$ 中）未被满足，因此对 $x$ 的任何字段的任何存储都不需要写屏障。因此，编译器可以安全地移除 $x.f := p$ 的屏障。\n\n结论：**正确**。\n\n**B. 在 $t_0$ 和 $t_1$ 之间没有安全点（因此在 $(t_0, t_1)$ 期间没有新生代 GC 可以开始），不论屏障是值条件性的还是无条件的。**\n\n垃圾回收被限制为只能在线程执行的静止点（称为安全点）发生。该条件指出，在时间 $t_0$ 的第一次写入和时间 $t_1$ 的第二次写入的执行之间不存在安全点。这意味着这两次写入的序列相对于垃圾回收器是原子的。\n\n因此，任何 GC 只能观察到时间 $t_0$ 之前的堆状态，或时间 $t_1$ 或之后的状态。\n- 在 $t_0$ 之前发生的 GC 不受这些写入的影响。\n- 在 $t_1$ 或之后发生的 GC 将观察到 $x.f$ 持有值 $q$ 的状态。$x.f$ 持有值 $p$ 的中间状态是瞬时的，永远不会被 GC 看到。\n\n因此，对于不变性而言，唯一重要的状态是最终状态 $x.f = q$。如果 $x \\in O$ 且 $q \\in Y$，第二次写入 $x.f := q$ 的写屏障（假设它存在，因为问题只问及省略第一个屏障）足以维持不变性。第一次写入 $x.f := p$ 上的写屏障是多余的，因为它将记录的状态永远不会被 GC 观察到。编译器可以安全地移除它。\n\n结论：**正确**。\n\n**C. $p \\notin Y$（例如，$p$ 是 $\\text{null}$ 或已晋升到老年代），与 $x$ 和 $q$ 的年龄以及调度无关。**\n\n这个条件规定，第一次写入所存储的值 $p$ 不是指向新生代中对象的指针。\n\n写屏障的目的是确保记忆集不变性得到维护。不变性要求如果一个对象 $o \\in O$ 指向 $Y$ 中的一个对象，则需要记录该对象 $o$。写入操作 $x.f := p$ 创建的指针仅在 $x \\in O$ 且 $p \\in Y$ 时才与该不变性相关。由于条件明确指出 $p \\notin Y$，这次写入不能创建一个从老年代到新生代的指针。\n\n让我们分析在任何可能的安全点时间 $t_s \\ge t_0$ 的状态：\n- 如果 GC 在 $t_s$ 时刻开始，其中 $t_0 \\le t_s  t_1$，则状态为 $x.f = p$。由于 $p \\notin Y$，即使 $x \\in O$，不变性也不要求因为这个指针而将 $x$ 放入记忆集中。因此，不需要为这次写入设置屏障来处理此状态。\n- 如果 GC 在 $t_s \\ge t_1$ 时刻开始，则状态为 $x.f = q$。此状态的正确性由第二次存储 $x.f := q$ 上的写屏障来保证。\n\n这对于提到的两种屏障类型都成立：\n- 一个*值条件性*的屏障会检查 $p \\in Y$ 是否成立，发现其为假，因此不执行任何操作。因此移除该屏障是安全的。\n- 一个*无条件卡页标记*的屏障可能会在 $x \\in O$ 时标记 $x$ 的卡页。然而，从技术上讲，这个标记是不必要的，因为回收器随后的扫描不会从这次赋值中发现新的从老年代到新生代的指针。移除该屏障是一个保持正确性的有效优化。\n\n因此，由于写入 $x.f := p$ 不会创建不变性所关心的特定类型的指针，其关联的写屏障可以被安全地移除。\n\n结论：**正确**。\n\n**D. 运行时采用读屏障 (read barrier) 来维护记忆集，因此可以省略存储操作上的写屏障。**\n\n这个选项引入了一个与问题设定直接矛盾的前提。问题明确指出，该语言运行时“通过**写屏障**维护一个记录了从老年代到新生代引用的记忆集”。问题的答案必须是在所描述系统内有效的条件。提议改变基本的 GC 机制（从写屏障变为读屏障）并没有在问题陈述的背景下为优化提供一个有效的条件。它实质上是改变了问题，而不是解决问题。\n\n结论：**不正确**。", "answer": "$$\n\\boxed{ABC}\n$$", "id": "3683370"}, {"introduction": "写屏障的实现策略——是在每个存储点内联展开，还是置于一个共享函数中——对性能有重大影响。这项练习 [@problem_id:3683412] 要求你对这两种策略进行建模和比较，同时考虑关键的微架构细节，如分支预测和函数调用开销。这个动手建模任务将高层运行时概念与底层 CPU 性能联系起来，是任何系统级工程师都应具备的关键技能。", "problem": "您将处理一个基于编译器原理和垃圾回收屏障设计的计算建模任务。写屏障（write barrier, wb）是编译器发出或注入的一小段代码，用于在垃圾回收的运行时环境中维护分代不变量：每次指针存储时，屏障会检查一个条件，并可选地执行一个慢路径操作（例如，在记忆集（remembered set）中记录该指针存储）。两种实现策略很常见：内联屏障（在每个存储点发出屏障体）和外联屏障（调用一个共享的屏障函数）。\n\n为一个屏障建模，该屏障为快路径决策执行单个条件分支。设快路径被选中的概率为 $p_{\\text{fast}} \\in [0,1]$，慢路径的概率为 $p_{\\text{slow}} = 1 - p_{\\text{fast}}$。假设每次屏障调用的分支结果都是具有上述概率的独立伯努利试验。假设处理器对该条件分支使用一个简单的一位最后结果分支预测器：它对下一次调用的预测等于同一静态分支上一次调用的结果。设基准分支执行成本为 $c_{\\text{branch}}$ 个周期，分支预测错误的惩罚为 $c_{\\text{misp}}$ 个周期，慢路径工作成本为 $c_{\\text{slow}}$ 个周期。对于外联屏障，每次调用需要包含 $c_{\\text{callret}}$ 个周期的额外调用/返回开销。对于内联屏障，调用/返回开销为 $0$ 个周期。\n\n您的任务是：\n- 从第一性原理出发，推导在独立伯noulli模型下，一位最后结果预测器的期望分支预测命中率 $h$。\n- 推导内联实现（表示为 $E_{\\text{inline}}$）和外联实现（表示为 $E_{\\text{out}}$）每次屏障调用的期望周期数，使用 $p_{\\text{fast}}$、$c_{\\text{branch}}$、$c_{\\text{misp}}$、$c_{\\text{slow}}$ 和 $c_{\\text{callret}}$ 表示。\n- 实现一个程序，为提供的测试套件评估 $h$、$E_{\\text{inline}}$ 和 $E_{\\text{out}}$。\n\n使用以下测试套件，所有成本以周期表示，概率以小数表示：\n1. $p_{\\text{fast}} = 0.999$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n2. $p_{\\text{fast}} = 0.990$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n3. $p_{\\text{fast}} = 1.000$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 4$。\n4. $p_{\\text{fast}} = 0.995$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 15$, $c_{\\text{slow}} = 30$, $c_{\\text{callret}} = 0$。\n5. $p_{\\text{fast}} = 0.999$, $c_{\\text{branch}} = 1$, $c_{\\text{misp}} = 30$, $c_{\\text{slow}} = 60$, $c_{\\text{callret}} = 8$。\n\n您的程序应生成单行输出，包含一个由逗号分隔的五个子列表组成的列表，每个子列表按顺序包含三个浮点数 $[E_{\\text{inline}}, E_{\\text{out}}, h]$，所有数值四舍五入到六位小数，整个集合用方括号括起来。例如：\n\"[[e1_inline,e1_out,h1],[e2_inline,e2_out,h2],[e3_inline,e3_out,h3],[e4_inline,e4_out,h4],[e5_inline,e5_out,h5]]\"\n\n注意：垃圾回收（Garbage Collection, GC）是写屏障支持的自动内存管理技术；此处指定的一位预测器是一个简化的、为教学目的明确定义的模型。除了周期之外，不使用任何物理单位；概率必须是小数，不带百分号。该问题普遍适用，仅需要纯粹的数学推理和计算，无需任何特定于硬件的测量。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于计算机体系结构和编译器设计的原理，问题定义明确，并以客观、正式的语言表达。为获得唯一解所需的所有参数和定义均已提供，且内部没有矛盾。因此，我们可以进行形式化推导和求解。\n\n目标是推导分支预测命中率和写屏障期望执行成本的表达式，然后为一组给定的参数计算这些值。\n\n### 1. 期望分支预测命中率（$h$）的推导\n\n问题指定了一个一位最后结果分支预测器。该预测器对下一个分支的状态就是当前分支的结果。如果下一个分支的结果与当前分支的结果相同，则预测正确（一次“命中”）。\n\n设在第 $n$ 次调用时，屏障条件分支的结果为随机变量 $O_n$。结果可以是“快路径”（我们用 $F$ 表示）或“慢路径”（用 $S$ 表示）。问题陈述每个调用都是一个具有以下概率的独立伯努利试验：\n$P(O_n = F) = p_{\\text{fast}}$\n$P(O_n = S) = p_{\\text{slow}} = 1 - p_{\\text{fast}}$\n\n对第 $n+1$ 次调用的分支预测，记为 $P_{n+1}$，是第 $n$ 次调用时分支的结果。因此，$P_{n+1} = O_n$。\n\n如果在第 $n+1$ 次调用时预测与结果匹配，即 $P_{n+1} = O_{n+1}$，则发生一次分支预测命中。代入预测器的逻辑，如果 $O_n = O_{n+1}$，则发生命中。\n\n期望预测命中率 $h$ 是此事件的概率：\n$h = P(\\text{发生命中}) = P(O_{n+1} = O_n)$\n\n我们可以通过考虑发生命中的两种互斥方式来计算这个概率：要么两个连续的结果都是快路径，要么都是慢路径。根据全概率定律：\n$h = P(O_{n+1} = F \\text{ and } O_n = F) + P(O_{n+1} = S \\text{ and } O_n = S)$\n\n由于分支结果是独立事件，联合概率是各自概率的乘积：\n$h = P(O_{n+1} = F) \\cdot P(O_n = F) + P(O_{n+1} = S) \\cdot P(O_n = S)$\n\n给定每次试验的平稳概率：\n$$h = p_{\\text{fast}}^2 + p_{\\text{slow}}^2$$\n代入 $p_{\\text{slow}} = 1 - p_{\\text{fast}}$：\n$h = p_{\\text{fast}}^2 + (1 - p_{\\text{fast}})^2 = p_{\\text{fast}}^2 + (1 - 2p_{\\text{fast}} + p_{\\text{fast}}^2) = 2p_{\\text{fast}}^2 - 2p_{\\text{fast}} + 1$。\n\n因此，预测错误的概率是 $1 - h$：\n$1 - h = 1 - (p_{\\text{fast}}^2 + p_{\\text{slow}}^2) = 2p_{\\text{fast}}(1 - p_{\\text{fast}}) = 2p_{\\text{fast}}p_{\\text{slow}}$。\n\n### 2. 每次调用的期望周期数（$E_{\\text{inline}}$ 和 $E_{\\text{out}}$）的推导\n\n根据期望的线性性质，每次屏障调用的总期望成本是其组成操作的期望成本之和。\n\n任何一次屏障调用的成本组成部分如下：\n1.  **基准分支成本：** 此成本 $c_{\\text{branch}}$ 在每次调用时都会产生。其期望值就是 $c_{\\text{branch}}$。\n2.  **分支预测错误惩罚：** 此成本 $c_{\\text{misp}}$ 仅在预测错误时产生。预测错误的概率是 $1 - h$。期望成本为 $c_{\\text{misp}} \\cdot P(\\text{预测错误}) = c_{\\text{misp}}(1 - h)$。\n3.  **慢路径工作成本：** 此成本 $c_{\\text{slow}}$ 仅在走慢路径时产生。其概率为 $p_{\\text{slow}}$。期望成本为 $c_{\\text{slow}} \\cdot p_{\\text{slow}}$。\n4.  **调用/返回开销成本：** 此成本 $c_{\\text{callret}}$ 取决于实现方式。对于内联屏障，此成本为 $0$。对于外联屏障，此成本为 $c_{\\text{callret}}$，并且每次调用都会产生。\n\n**内联屏障的期望成本（$E_{\\text{inline}}$）：**\n内联实现的总期望成本是分支、预测错误惩罚和慢路径工作的期望成本之和。\n$E_{\\text{inline}} = (\\text{期望分支成本}) + (\\text{期望预测错误惩罚}) + (\\text{期望慢路径工作成本})$\n$$E_{\\text{inline}} = c_{\\text{branch}} + c_{\\text{misp}}(1 - h) + c_{\\text{slow}}p_{\\text{slow}}$$\n代入 $1-h$ 的表达式：\n$$E_{\\text{inline}} = c_{\\text{branch}} + c_{\\text{misp}}(2p_{\\text{fast}}p_{\\text{slow}}) + c_{\\text{slow}}p_{\\text{slow}}$$\n\n**外联屏障的期望成本（$E_{\\text{out}}$）：**\n外联实现会产生与内联版本相同的所有成本，此外每次调用还会增加一个恒定的调用/返回开销 $c_{\\text{callret}}$。\n$E_{\\text{out}} = E_{\\text{inline}} + c_{\\text{callret}}$\n$$E_{\\text{out}} = c_{\\text{branch}} + c_{\\text{misp}}(1 - h) + c_{\\text{slow}}p_{\\text{slow}} + c_{\\text{callret}}$$\n代入 $1-h$ 的表达式：\n$$E_{\\text{out}} = c_{\\text{branch}} + c_{\\text{misp}}(2p_{\\text{fast}}p_{\\text{slow}}) + c_{\\text{slow}}p_{\\text{slow}} + c_{\\text{callret}}$$\n\n这些公式提供了计算测试套件所需值的必要关系。", "answer": "```\n[[1.059970, 5.059970, 0.998002],[1.597000, 5.597000, 0.980200],[1.000000, 5.000000, 1.000000],[1.299250, 1.299250, 0.990050],[1.119940, 9.119940, 0.998002]]\n```", "id": "3683412"}]}