{"hands_on_practices": [{"introduction": "“标记-整理”算法的效率不仅取决于回收了多少垃圾，还取决于整理存活对象所付出的代价。这个练习旨在通过量化分析来加深你对这一点的理解。我们将比较两种截然不同的堆内存布局——一种由许多小对象组成的链表，另一种由少数大数组构成——并计算它们的整理效率，从而揭示对象图的形状如何深远地影响垃圾回收的性能 [@problem_id:3657487]。", "problem": "一个托管运行时使用一种基于标记-紧凑（Mark-Compact, MC）算法的精确垃圾回收（Garbage Collection, GC）方案。在MC算法中，收集器首先标记所有从根（roots）可达的对象，然后通过重定位存活对象来消除碎片以进行紧凑，最后修复所有存活对象和根中的引用，使其指向新的位置。对于一个指针字段，只有当该字段位于一个存活对象（或根）中，并且其值指向一个被移动的存活对象时，才会执行修复（fix-up）。\n\n考虑两种堆模式，它们仅在可达对象图的形状和MC周期发生时死亡对象的分布上有所不同。假设使用一台$64$位机器，因此每个指针字段占用$8$字节。以下所有大小均为精确的字节数。\n\n模式 A（许多小节点，cons风格的列表）：\n- 有$100$个独立的单向链表，每个链表最初的长度为$100$个节点，但在收集时，每个链表仅能通过一个根指针从其第一个存活节点开始访问。在每个链表中，恰好后缀的$50$个节点是存活的，而前缀的$50$个节点是死亡的。\n- 每个链表节点有一个标记为$next$的指针字段和$16$字节的有效载荷；因此节点大小为$24$字节。\n- 存活节点的$next$字段指向列表中的下一个存活节点，但最后一个节点的$next$为$\\text{null}$。所有死亡节点都是不可达的，并且不包含任何会被扫描的指针（它们在紧凑过程中不会被访问或修复）。\n- 每个链表都通过一个指向该链表第一个存活节点的根指针可达。\n\n模式 B（少量大型引用数组）：\n- 有$10$个数组，每个数组都是存活的，并且通过一个根指针直接可达。每个数组有$1,000$个槽位，数组对象本身由一个$16$字节的头部和紧随其后的$1,000$个各占$8$字节的指针槽位组成。\n- 在程序的生命周期内，每个数组都分配了$1,000$个大小统一的记录对象；在收集时，每个数组中只有$200$个对象仍然可达。每个数组的$200$个可达记录都由不同的非$\\text{null}$数组槽位指向；每个数组剩余的$800$个记录对象是死亡的（不可达），并且没有被任何存活的数组槽位引用。\n- 每个记录对象没有指针字段，占用$32$字节。\n- 每个存活的数组槽位恰好指向一个存活的记录对象；没有存活的记录对象被多于一个槽位引用；所有死亡的记录对象都是不可达且不会被扫描的。\n\n将给定模式下一次MC周期的紧凑效率 $\\mathcal{E}$ 定义为比率\n$$\n\\mathcal{E} = \\frac{\\text{total bytes of dead objects reclaimed}}{\\text{total number of pointer fix-ups performed}},\n$$\n其中分母计算的是所有位于存活对象和根中、因其指向的目标在紧凑过程中被移动而更新了值的指针字段的总数。\n\n在这些假设下，计算比率\n$$\nR \\;=\\; \\frac{\\mathcal{E}_{\\text{Pattern B}}}{\\mathcal{E}_{\\text{Pattern A}}}.\n$$\n请以精确的、无单位、不进行四舍五入的最简分数形式提供最终答案。", "solution": "目标是计算比率 $R = \\frac{\\mathcal{E}_{\\text{Pattern B}}}{\\mathcal{E}_{\\text{Pattern A}}}$，其中紧凑效率 $\\mathcal{E}$ 定义为：\n$$\n\\mathcal{E} = \\frac{\\text{total bytes of dead objects reclaimed}}{\\text{total number of pointer fix-ups performed}}\n$$\n如果一个指针字段位于一个存活对象或根中，并且其目标（一个存活对象）在紧凑过程中被重定位，那么这个指针字段就需要进行修复。在一个标准的标记-紧凑方案中，所有存活对象都会被重定位。因此，任何从一个存活对象或根指向另一个存活对象的非空指针都必须被修复。\n\n首先，我们分析模式A以确定 $\\mathcal{E}_{\\text{Pattern A}}$。\n\n在模式A中，我们有$100$个独立的链表。对于每个链表：\n- 前$50$个节点是死亡且不可达的。\n- 后$50$个节点是存活且可达的。\n- 每个节点的大小是$8$字节（指针）+ $16$字节（有效载荷）= $24$字节。\n\n模式A中回收的死亡对象总字节数是所有死亡节点的总大小。\n$$\n\\text{Bytes}_{\\text{dead, A}} = (\\text{number of lists}) \\times (\\text{dead nodes per list}) \\times (\\text{size per node})\n$$\n$$\n\\text{Bytes}_{\\text{dead, A}} = 100 \\times 50 \\times 24 = 120,000 \\text{ 字节}\n$$\n接下来，我们计算模式A的指针修复总数。修复发生在根中的指针和存活对象中指向其他（被移动的）存活对象的指针。\n1.  **根指针**：有$100$个链表，每个都通过一个根指针可达。每个根指针指向其对应链表的第一个存活节点。由于所有存活节点在紧凑过程中都会被移动，因此所有$100$个根指针都必须被修复。\n    $$\n    \\text{Fix-ups}_{\\text{roots, A}} = 100\n    $$\n2.  **存活对象中的指针**：存活对象是$100$个链表中各自的$50$个存活节点。每个节点有一个指针字段，$next$。在一个包含$50$个存活节点的链表中，前$49$个节点的$next$字段指向列表中的下一个存活节点。最后一个存活节点的$next$字段为$\\text{null}$。指向存活对象的指针需要修复，而$\\text{null}$指针则不需要。因此，每个链表的存活节点内需要$49$次修复。\n    $$\n    \\text{Fix-ups}_{\\text{live obj, A}} = (\\text{number of lists}) \\times (\\text{fix-ups per list}) = 100 \\times 49 = 4,900\n    $$\n模式A的指针修复总数是这两个部分的总和。\n$$\n\\text{Total Fix-ups}_{\\text{A}} = \\text{Fix-ups}_{\\text{roots, A}} + \\text{Fix-ups}_{\\text{live obj, A}} = 100 + 4,900 = 5,000\n$$\n现在我们可以计算模式A的效率。\n$$\n\\mathcal{E}_{\\text{Pattern A}} = \\frac{\\text{Bytes}_{\\text{dead, A}}}{\\text{Total Fix-ups}_{\\text{A}}} = \\frac{120,000}{5,000} = 24\n$$\n\n其次，我们分析模式B以确定 $\\mathcal{E}_{\\text{Pattern B}}$。\n\n在模式B中，我们有$10$个存活的数组。对于每个数组：\n- 分配了$1,000$个记录对象。\n- 其中$200$个记录对象是存活的，由数组中的槽位指向。\n- 剩余的$1,000 - 200 = 800$个记录对象是死亡的。\n- 每个记录对象大小为$32$字节，不包含指针。\n\n模式B中回收的死亡对象总字节数是所有死亡记录对象的总大小。\n$$\n\\text{Bytes}_{\\text{dead, B}} = (\\text{number of arrays}) \\times (\\text{dead records per array}) \\times (\\text{size per record})\n$$\n$$\n\\text{Bytes}_{\\text{dead, B}} = 10 \\times 800 \\times 32 = 256,000 \\text{ 字节}\n$$\n接下来，我们计算模式B的指针修复总数。\n1.  **根指针**：有$10$个数组，每个都是存活的，并能通过一个根指针访问。由于数组是将被移动的存活对象，因此所有$10$个根指针都必须被修复。\n    $$\n    \\text{Fix-ups}_{\\text{roots, B}} = 10\n    $$\n2.  **存活对象中的指针**：包含指针的存活对象是这$10$个数组。记录对象是存活的，但不包含指针。每个数组有$1,000$个指针槽位。其中，$200$个槽位指向$200$个存活的记录对象。由于存活的记录在紧凑过程中会被移动，因此每个数组中的这$200$个指针都必须被修复。另外$800$个槽位不指向存活对象（它们是$\\text{null}$或指向死亡对象），所以它们不需要修复。\n    $$\n    \\text{Fix-ups}_{\\text{live obj, B}} = (\\text{number of arrays}) \\times (\\text{live pointers per array}) = 10 \\times 200 = 2,000\n    $$\n模式B的指针修复总数是两部分之和。\n$$\n\\text{Total Fix-ups}_{\\text{B}} = \\text{Fix-ups}_{\\text{roots, B}} + \\text{Fix-ups}_{\\text{live obj, B}} = 10 + 2,000 = 2,010\n$$\n现在我们可以计算模式B的效率。\n$$\n\\mathcal{E}_{\\text{Pattern B}} = \\frac{\\text{Bytes}_{\\text{dead, B}}}{\\text{Total Fix-ups}_{\\text{B}}} = \\frac{256,000}{2,010} = \\frac{25,600}{201}\n$$\n\n最后，我们计算所需的比率$R$。\n$$\nR = \\frac{\\mathcal{E}_{\\text{Pattern B}}}{\\mathcal{E}_{\\text{Pattern A}}} = \\frac{\\frac{25,600}{201}}{24} = \\frac{25,600}{201 \\times 24}\n$$\n为了简化这个分数，我们可以将分子和分母除以它们的最大公约数。我们可以看到$24$和$25,600$都能被$8$整除。\n$$\n25,600 \\div 8 = 3,200\n$$\n$$\n24 \\div 8 = 3\n$$\n将这些值代回$R$的表达式中：\n$$\nR = \\frac{3,200}{201 \\times 3} = \\frac{3,200}{603}\n$$\n为确认此分数已完全化简，我们找出分子和分母的质因数分解。\n- 分子：$3,200 = 32 \\times 100 = 2^5 \\times 10^2 = 2^5 \\times (2 \\times 5)^2 = 2^7 \\times 5^2$。\n- 分母：$603 = 3 \\times 201 = 3 \\times (3 \\times 67) = 3^2 \\times 67$。\n分子的质因数是$2$和$5$，而分母的质因数是$3$和$67$。它们没有共同的质因数，所以这个分数处于最简形式。", "answer": "$$\\boxed{\\frac{3200}{603}}$$", "id": "3657487"}, {"introduction": "在整理阶段，垃圾回收器不仅要移动对象，还必须遵守硬件的内存对齐规则，这往往会引入额外的开销。本练习将引导你探讨一个实际的工程问题：对象对齐所导致的内存碎片。通过对一个给定的对象大小分布进行概率分析，你将计算出平均每个对象需要多少字节的填充才能满足对齐要求 [@problem_id:3657450]。", "problem": "一个托管运行时采用标记-整理垃圾回收（Mark-Compact Garbage Collection, MCGC），这是一种垃圾回收（Garbage Collection, GC）的形式。在这种形式中，标记完存活对象后，所有存活对象都会被移动，从一个16字节对齐的基地址开始连续排列。整理阶段强制要求每个对象的起始地址都是$16$的倍数，这是通过在连续对象之间根据需要插入内部填充来实现的。最后一个对象之后不会插入填充，因为没有后续对象需要对齐。\n\n假设每个存活对象的总大小 $s$（包括一个$16$字节的固定头部及其载荷）是一个独立同分布的离散随机变量，由以下以字节为单位的载荷大小分布确定：\n- 载荷大小 $x \\in \\{0, 6, 11, 17, 24, 33, 46\\}$ 出现的概率分别为 $\\{0.10, 0.20, 0.15, 0.25, 0.10, 0.10, 0.10\\}$。\n因此，$s = 16 + x \\in \\{16, 22, 27, 33, 40, 49, 62\\}$。\n\n使用所述的对齐基本原则和整理策略，推导出每个对象插入的内部填充的期望值。最终答案以字节为单位表示。如果在中间步骤需要任何数值近似，请以符号形式进行，直到最终计算；最终答案无需四舍五入。", "solution": "目标是计算在垃圾回收的整理阶段，每个对象插入的内部填充的期望量。对齐约束规定每个对象的起始地址必须是16字节的倍数。\n\n让我们形式化描述单个对象后所需的填充量。考虑一个总大小为 $s$ 的对象。设其起始地址为 $A_{start}$。根据问题的约束，$A_{start}$ 必须是16的倍数。该对象占用的内存从地址 $A_{start}$ 到 $A_{start} + s - 1$。下一个可用字节的地址是 $A_{start} + s$。\n\n后续对象必须放置在一个起始地址 $A'_{start}$，该地址是满足 $A'_{start} \\ge A_{start} + s$ 的最小的16的倍数。一个大小为 $s$ 的对象之后所需的填充量 $p(s)$ 可以使用模运算符方便地表示：\n$$\np(s) = (16 - (s \\pmod{16})) \\pmod{16}\n$$\n如果 $s$ 是16的倍数，则 $s \\pmod{16} = 0$，所以 $p(s) = (16-0) \\pmod{16} = 0$。如果 $s$ 不是16的倍数，设 $s \\pmod{16} = r$，其中 $1 \\le r  16$。那么 $p(s) = (16 - r) \\pmod{16} = 16 - r$。这个公式正确地描述了所需的填充。\n\n问题要求“每个对象插入的内部填充的期望值”。尽管在最后一个对象之后不添加填充，但对于大量的对象 $N$，有 $N-1$ 次填充机会。当 $N$ 变得很大时，每个对象的平均填充量趋近于 $p(s)$ 的期望值。因此，我们计算期望值 $E[p(s)]$。\n\n对象总大小 $s$ 是一个依赖于载荷大小 $x$ 的随机变量。首先，我们列出所有可能的对象大小 $s_i$ 及其概率 $P(s=s_i)$，这些概率继承自 $x$ 的分布。\n载荷大小为 $x_i \\in \\{0, 6, 11, 17, 24, 33, 46\\}$，其概率为 $P_i \\in \\{0.10, 0.20, 0.15, 0.25, 0.10, 0.10, 0.10\\}$。\n对象总大小为 $s_i = 16 + x_i$：\n- $s_1 = 16 + 0 = 16$\n- $s_2 = 16 + 6 = 22$\n- $s_3 = 16 + 11 = 27$\n- $s_4 = 16 + 17 = 33$\n- $s_5 = 16 + 24 = 40$\n- $s_6 = 16 + 33 = 49$\n- $s_7 = 16 + 46 = 62$\n\n接下来，我们使用公式 $p(s) = (16 - (s \\pmod{16})) \\pmod{16}$ 计算每个可能对象大小 $s_i$ 的填充量 $p(s_i)$：\n- $p(s_1) = p(16) = (16 - (16 \\pmod{16})) \\pmod{16} = (16 - 0) \\pmod{16} = 0$\n- $p(s_2) = p(22) = (16 - (22 \\pmod{16})) \\pmod{16} = (16 - 6) \\pmod{16} = 10$\n- $p(s_3) = p(27) = (16 - (27 \\pmod{16})) \\pmod{16} = (16 - 11) \\pmod{16} = 5$\n- $p(s_4) = p(33) = (16 - (33 \\pmod{16})) \\pmod{16} = (16 - 1) \\pmod{16} = 15$\n- $p(s_5) = p(40) = (16 - (40 \\pmod{16})) \\pmod{16} = (16 - 8) \\pmod{16} = 8$\n- $p(s_6) = p(49) = (16 - (49 \\pmod{16})) \\pmod{16} = (16 - 1) \\pmod{16} = 15$\n- $p(s_7) = p(62) = (16 - (62 \\pmod{16})) \\pmod{16} = (16 - 14) \\pmod{16} = 2$\n\n期望填充 $E[p(s)]$ 是每个填充量与其相应概率相乘的总和：\n$$\nE[p(s)] = \\sum_{i=1}^{7} p(s_i) P(s=s_i)\n$$\n代入计算出的值和给定的概率：\n$$\nE[p(s)] = (0 \\times 0.10) + (10 \\times 0.20) + (5 \\times 0.15) + (15 \\times 0.25) + (8 \\times 0.10) + (15 \\times 0.10) + (2 \\times 0.10)\n$$\n对每一项进行乘法运算：\n$$\nE[p(s)] = 0.0 + 2.0 + 0.75 + 3.75 + 0.8 + 1.5 + 0.2\n$$\n将各项相加得出最终的期望值：\n$$\nE[p(s)] = 9.0\n$$\n每个对象插入的内部填充的期望值为9.0字节。", "answer": "$$\n\\boxed{9.0}\n$$", "id": "3657450"}, {"introduction": "精确式垃圾回收器的正确性高度依赖于编译器（或JIT）提供的运行时信息，特别是关于栈上哪些是引用的“栈图”（stack map）。这个练习将带你进入一个典型的系统级调试场景，分析一个错误的栈图如何导致灾难性的对象丢失。通过这个思想实验，你将理解垃圾回收器与编译器之间接口的脆弱性，并思考如何设计健壮的运行时验证机制来捕捉此类错误 [@problem_id:3657457]。", "problem": "一个运行时系统使用即时 (JIT) 编译技术，为一门托管语言实现了精确的标记-紧缩垃圾回收 (GC)。在每个 GC 安全点，JIT 会为当前活动记录关联一个栈图（stack map）位向量，该向量为帧中的每个机器字大小的槽位标示其是否持有一个指向堆的活指针。位值为 $1$ 标记的槽位将被作为根进行扫描；位值为 $0$ 标记的槽位则被跳过。\n\n考虑一个函数 $\\mathsf{f}$，它有局部变量 $\\mathsf{p}$ 和 $\\mathsf{t}$，其高层行为如下：$\\mathsf{p} \\gets \\mathsf{new\\_Object}()$；$\\mathsf{t} \\gets \\mathsf{compute}()$；调用 $\\mathsf{maybe\\_gc}()$；然后使用 $\\mathsf{p}$。对 $\\mathsf{maybe\\_gc}$ 的调用是一个 GC 安全点。在该安全点，帧布局被抽象为一个固定的槽位序列 $\\langle s_0, s_1, s_2 \\rangle$，其真实内容为：$s_0$ 持有 $\\mathsf{p}$（一个指向堆的指针），$s_1$ 持有 $\\mathsf{t}$（一个非指针值），以及 $s_2$ 持有一个调用保存的非指针值。因此，在一个正确的栈图中，对于 $\\langle s_0, s_1, s_2 \\rangle$ 的位向量应该是 $\\langle 1, 0, 0 \\rangle$。\n\n标记-紧缩算法按以下步骤进行：首先从栈图和全局根中识别出根集合 $R$，标记所有从 $R$ 可传递到达的堆对象，为所有已标记对象计算新的紧缩后位置，安装转发信息，更新所有的根和堆内引用使其指向新位置，最后滑动活对象以消除碎片。\n\n假设一个 JIT 错误在 $\\mathsf{f}$ 内部的安全点处产生了一个错误的栈图，该栈图遗漏了一个活指针。你的任务是从根、可达性以及标记-紧缩 GC 的各个阶段等基本原理出发进行推理，以确定这样的栈图如何导致对象丢失或损坏，并提出一种运行时调试插桩，用以在测试期间验证栈图并防止静默的数据丢失。\n\n以下哪个选项同时：\n(i) 为给定帧构建了一个具体的、自洽的错误编译栈图，\n(ii) 逐步解释了标记-紧缩算法会因该栈图而出错的过程（导致 $\\mathsf{p}$ 引用的对象丢失或产生悬垂引用），并且\n(iii) 提出了一种可靠的运行时插桩，它可以在测试期间于安全点检测此类栈图错误，并防止静默的数据丢失？\n\nA. 错误编译的栈图：对于 $\\langle s_0, s_1, s_2 \\rangle$ 为 $\\langle 0, 1, 0 \\rangle$，错误地将 $\\mathsf{t}$ 视作指针并遗漏了 $\\mathsf{p}$。后果：根据该栈图计算出的根集合 $R$，分配给 $\\mathsf{p}$ 的对象不会被标记，因为 $\\mathsf{p}$ 没有被扫描。在紧缩阶段，不会为该对象安装转发指针；当其他对象被滑动时，其内存被回收或覆盖。安全点之后，$\\mathsf{p}$ 仍然持有旧地址，从而产生一个指向已释放空间的悬垂指针，或一个指向不相关数据的别名。插桩：添加一个验证器模式，在每个安全点执行一次保守的栈扫描，以构建一个超集根集合 $R_c$，并将其与栈图所蕴含的精确集合 $R_p$ 进行比较，检查 $R_p \\subseteq R_c$ 并标记出 $R_c \\setminus R_p$ 中任何指向堆的值。隔离所有从 $R_c \\setminus R_p$ 可达的对象以防止它们被回收，并且插入一个读屏障，断言在紧缩之后从根读取的每个指针都有一个有效的转发地址。这些检查能够识别出“遗漏活指针”的错误，并在测试期间防止静默的数据丢失。\n\nB. 错误编译的栈图：$\\langle 1, 1, 1 \\rangle$，“为了安全”将每个槽位都标记为指针。后果：回收器会“双重转发”$\\mathsf{p}$ 中的对象，因为有多个根指向它，导致其被移动两次并最终丢失。插桩：将“停止世界”的回收频率加倍，以减小此类错误发生的时间窗口，并记录总堆大小。这样可以检测并纠正问题。\n\nC. 错误编译的栈图：$\\langle 1, 0, 1 \\rangle$，该栈图将 $\\mathsf{p}$ 和一个额外的非指针槽位 $s_2$ 作为根。后果：因为存在一个额外的根，紧缩器会两次将 $\\mathsf{p}$ 更新到两个不同的地址，从而导致状态不一致并丢弃该对象。插桩：在每个安全点打印栈图位向量，并将其与一个编译时列表进行比较；如果相等则继续，如果不等则中止。这保证了没有对象丢失。\n\nD. 错误编译的栈图：$\\langle 0, 0, 0 \\rangle$，但仅存在于一个内部的非安全点区域，所以没有影响。后果：不会发生对象丢失，因为 GC 从不在非安全点运行。插桩：仅依靠静态数据流存活性分析来证明所有在安全点的栈图都是正确的；运行时检查是不必要的，并且是不可靠的，因为保守扫描会引入可能“隐藏”真正错误的假阳性。\n\n选择在所有三个方面（(i)–(iii)）都完全正确的选项。", "solution": "问题的核心是一个 JIT 错误，它导致栈图“遗漏一个活指针”。鉴于 $\\langle s_0, s_1, s_2 \\rangle$ 的正确栈图是 $\\langle 1, 0, 0 \\rangle$，其中 $s_0$ 包含活指针 $\\mathsf{p}$，那么一个遗漏此指针的栈图在第一个位置上必须是 $0$。当GC发生时：\n\n1.  **识别根**：GC 查阅有错误的栈图。由于槽位 $s_0$ 的比特位是 $0$，其包含的值（指针 $\\mathsf{p}$）**不会**被识别为根。\n2.  **标记**：标记阶段从根集合开始遍历。假设由 $\\mathsf{p}$ 引用的对象无法从任何其他根到达，它将**不会**被标记为活对象，并被视为垃圾。\n3.  **整理**：在整理阶段，未被标记的对象所占用的内存会被回收。由于 $\\mathsf{p}$ 引用的对象被视为垃圾，它不会被移动，也不会为其安装转发地址。它的内存区域可能会被其他移动过来的活对象覆盖。\n4.  **指针修复**：由于 $\\mathsf{p}$ 从未被识别为根，GC 不会更新它的值。\n\nGC 结束后，变量 $\\mathsf{p}$ 仍然持有其原始内存地址，但该地址现在指向已回收或被覆盖的内存。这会产生一个**悬垂指针**，在后续对 $\\mathsf{p}$ 的使用中导致数据损坏或程序崩溃。\n\n为了在测试中检测此类错误，一种可靠的方法是将精确GC（使用JIT提供的栈图）与保守GC（将栈上所有看起来像指针的值都当作指针）的结果进行比较。一个可靠的插桩会在每个安全点执行一次保守的栈扫描，构建一个根的超集 $R_c$，并将其与由精确栈图生成的根集合 $R_p$ 进行比较。如果发现一个指针存在于 $R_c$ 中但不存在于 $R_p$ 中，就表明JIT可能遗漏了一个活指针。\n\n### 选项分析\n\n*   **A**:\n    *   **(i) 错误栈图**: $\\langle 0, 1, 0 \\rangle$。这正确地遗漏了 $s_0$ 中的指针 $\\mathsf{p}$，符合问题前提。\n    *   **(ii) 后果**: 对后果的解释完全正确。它准确地描述了对象如何因未被标记而丢失，以及 $\\mathsf{p}$ 如何变成悬垂指针。\n    *   **(iii) 插桩**: 提议的插桩是健全且实用的。使用保守扫描来验证精确栈图，并查找在 $R_c$ 中但不在 $R_p$ 中的指针，是检测“遗漏活指针”的正确方法。\n*   **B**: 提出的栈图 $\\langle 1, 1, 1 \\rangle$ 并没有遗漏指针，而是错误地增加了指针，这与问题前提不符。其对后果（“双重转发”）的解释在技术上是不正确的，并且插桩方案也毫无意义。\n*   **C**: 提出的栈图 $\\langle 1, 0, 1 \\rangle$ 同样没有遗漏指针。其对后果的解释（“两次更新到不同地址”）也是基于对GC算法的误解。\n*   **D**: 此选项通过声称错误发生在非安全点来回避问题，这直接与问题陈述相矛盾。其插桩逻辑是错误的，因为它建议信任导致错误的静态分析，并错误地否定了运行时检查的价值。\n\n因此，选项 A 是唯一在所有三个方面都完全正确的选项。", "answer": "$$\\boxed{A}$$", "id": "3657457"}]}