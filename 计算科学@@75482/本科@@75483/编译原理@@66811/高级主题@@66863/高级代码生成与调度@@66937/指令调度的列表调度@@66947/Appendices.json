{"hands_on_practices": [{"introduction": "在真实的处理器中，性能瓶颈可能来自资源限制，也可能来自数据依赖。这个练习模拟了一个场景：通过增加一个算术逻辑单元（ALU）来升级处理器。你的任务是分析这种升级带来的实际性能提升，并揭示为何增加硬件资源并不总能带来预期的加速效果，从而理解关键路径依赖在性能优化中的决定性作用。[@problem_id:3650798]", "problem": "考虑一个基本块，其数据依赖关系由以下有向无环图（DAG）表示。存在一个由内存派生出的单链，包含 $6$ 次迭代；在第 $i$ 次迭代（$i \\in \\{1,\\dots,6\\}$）中，一条算术逻辑单元（ALU）指令 $A_i$ 根据前一个加载指令产生的值计算一个地址，然后一条加载指令 $L_i$ 从该地址读取数据。具体来说，$A_1$ 依赖于一个在时间 $0$ 可用的初始值 $V_0$，$L_1$ 依赖于 $A_1$，$A_2$ 依赖于 $L_1$，$L_2$ 依赖于 $A_2$，以此类推，直到 $L_6$ 依赖于 $A_6$。除了这条链之外，还有 $20$ 条独立的纯 ALU 指令 $X_1,\\dots,X_{20}$，它们都在时间 $0$ 就绪，并且不在这条内存派生链上；它们的结果仅在基本块的末尾才需要。\n\n机器模型与约束：\n- 该机器是一个双发射处理器：每个周期最多可以发射 $W=2$ 条指令。\n- 有一个容量为 $R_M=1$ 的全流水线内存单元用于加载，每次加载的延迟为 $L_M=3$ 个周期（在周期 $t$ 发射的加载指令在周期 $t+3$ 产生其结果）。\n- 有 $R_A$ 个全流水线 ALU 单元。每条 ALU 指令的延迟为 $L_A=1$ 个周期（在周期 $t$ 发射的 ALU 指令在周期 $t+1$ 产生其结果）。\n- 如果发射宽度允许且操作数就绪，不同的功能单元可以在同一周期内使用。一条指令只有在其所有操作数都可用时才能发射。结果在指定的延迟之后立即可用。\n- 所有资源在发射时是独占使用的：在一个周期内被一条指令用于发射的资源，不能被同一类型的另一条指令在该周期内使用。\n\n假设采用标准的贪心列表调度启发式算法，该算法始终遵守数据依赖和资源容量限制。您将分析两种配置：基线配置（$R_A=1$ 个 ALU）和升级配置（$R_A=2$ 个 ALU）。仅使用上述定义和就绪/延迟语义来确定每种配置下的完工时间（makespan）；不要假设任何未说明的优化。\n\n任务：\n- 计算加速比 $S$，定义为基线配置（$R_A=1$）下的完工时间与升级配置（$R_A=2$）下的完工时间之比。将 $S$ 以单个最简分数的形式给出。无需四舍五入。\n- 在您的推理中，量化此示例中调度长度对 ALU 资源的敏感性，并确定限制实际加速比的真正瓶颈，但最终报告的结果必须是按上述规定给出的单个数值 $S$。", "solution": "用户要求我解决一个指令调度问题，并计算增加一个 ALU 所带来的加速比。\n\n### 问题验证\n\n我分析了问题陈述及其约束。\n\n*   **给定条件**：\n    *   指令链：一个由 $6$ 条 ALU 指令 ($A_i$) 和 $6$ 条加载指令 ($L_i$) 组成的序列，其依赖关系为 $A_1 \\leftarrow V_0$，$L_1 \\leftarrow A_1$，$A_2 \\leftarrow L_1$，...，$L_6 \\leftarrow A_6$。$V_0$ 在时间 $0$ 可用。\n    *   独立指令：$20$ 条纯 ALU 指令 ($X_j$) 在时间 $0$ 就绪。\n    *   机器模型：\n        *   发射宽度：$W=2$。\n        *   内存单元：$R_M=1$，全流水线，延迟 $L_M=3$ 个周期。\n        *   ALU 单元：$R_A \\in \\{1, 2\\}$，全流水线，延迟 $L_A=1$ 个周期。\n    *   调度规则：贪心列表调度，遵守数据和资源依赖。一条延迟为 $L$ 的指令在周期 $t$ 发射，其结果在周期 $t+L$ 或之后对后续指令可用。完工时间是最后一条指令完成执行的周期数。如果一条指令在周期 $t$ 发射，延迟为 $L$，它将在周期 $t, t+1, \\ldots, t+L-1$ 期间执行，并在周期 $t+L-1$ 结束时完成。\n\n*   **验证**：\n    *   该问题在编译器设计和计算机体系结构领域具有科学依据。\n    *   该问题定义明确，所有必要参数（指令依赖、延迟、资源约束）均已指定。\n    *   语言客观、精确。\n    *   所有定义对于此类学术问题都是标准的。\n\n*   **结论**：问题有效。\n\n### 解法\n\n设 $T_{issue}(I)$ 为指令 $I$ 的发射周期。$I$ 的结果从周期 $T_{issue}(I) + \\text{latency}(I)$ 开始对依赖指令可用。一条指令在周期 $T_{issue}(I) + \\text{latency}(I) - 1$ 的末尾完成执行。完工时间是所有指令中最大的完成周期。\n\n该问题要求使用贪心列表调度器。我们假设关键路径上的指令（即 $A_i \\rightarrow L_i$ 链）被优先调度。\n\n#### 情况 1：基线配置（$R_A=1$）\n\n在此配置中，我们有 $R_A=1$ 个 ALU，$R_M=1$ 个 MEM 单元，以及 $W=2$ 的发射宽度。单个 ALU 每个周期只能发射一条 ALU 指令。\n\n让我们逐周期地调度指令，优先处理关键路径。\n\n*   **周期 $t=1$**：\n    *   就绪指令：$\\{A_1, X_1, \\ldots, X_{20}\\}$。\n    *   $A_1$（关键路径）被发射。它使用唯一的 ALU。没有其他 ALU 指令可以发射。没有就绪的 MEM 指令。\n    *   已发射：$\\{A_1\\}$。\n    *   $A_1$ 的结果在周期 $1+L_A = 2$ 就绪。它在周期 $1+1-1=1$ 的末尾完成。\n\n*   **周期 $t=2$**：\n    *   就绪：$\\{L_1, X_1, \\ldots, X_{20}\\}$（$L_1$ 因 $A_1$ 完成而就绪）。\n    *   $L_1$ 被发射（使用 MEM 单元）。一条独立的 ALU 操作 $X_1$ 可以被共同发射（使用 ALU 单元）。\n    *   已发射：$\\{L_1, X_1\\}$。\n    *   $L_1$ 的结果在周期 $2+L_M = 5$ 就绪。它在周期 $2+3-1=4$ 的末尾完成。\n\n关键路径指令的调度由数据依赖和资源可用性决定。让我们确定 $A_i \\rightarrow L_i$ 链的发射时间模式。\n*   $T_{issue}(A_1) = 1$。结果在周期 $1+1=2$ 就绪。\n*   $T_{issue}(L_1) = 2$。结果在周期 $2+3=5$ 就绪。\n*   $A_2$ 依赖于 $L_1$，因此它可以在周期 $5$ 或之后发射。在 $t=5$ 时，需要一个 ALU。在 $t=2$ 和 $t=5$ 之间，ALU 被独立的 $X_j$ 指令使用。贪心调度器会优先处理关键路径，所以 $A_2$ 将在周期 $5$ 获得 ALU。\n*   $T_{issue}(A_2) = 5$。结果在周期 $5+1=6$ 就绪。\n*   $T_{issue}(L_2) = 6$。结果在周期 $6+3=9$ 就绪。\n\n这形成了一个模式。$A_i$ 的发射时间由 $L_{i-1}$ 结果的就绪时间决定。$L_i$ 的发射时间由 $A_i$ 结果的就绪时间决定。\n$T_{issue}(A_i) = T_{issue}(L_{i-1}) + L_M$。\n$T_{issue}(L_i) = T_{issue}(A_i) + L_A$。\n将它们结合起来得到 $T_{issue}(A_i) = T_{issue}(A_{i-1}) + L_A + L_M = T_{issue}(A_{i-1}) + 4$。\n$A_i$ 的发射时间形成一个等差数列：$1, 5, 9, 13, 17, 21$。\n$L_i$ 的发射时间是：$2, 6, 10, 14, 18, 22$。\n链上的最后一条指令 $L_6$ 在 $T_{issue}(L_6)=22$ 发射。它在周期 $22+L_M-1 = 24$ 的末尾完成。\n\n现在，我们必须考虑 $20$ 条独立的 $X_j$ 指令。ALU 指令的总数是 $6$ ($A_i$) $+ 20$ ($X_j$) $= 26$。对于单个 ALU（$R_A=1$），至少需要 $26$ 个周期来发射所有这些指令。这是一个基于资源的完工时间下界。\n\n让我们计算一下到周期 $22$ 为止发射了多少条 $X_j$ 指令：\n*   有 $6$ 个周期发射了 $A_i$ 指令（$1, 5, \\ldots, 21$）。单个 ALU 处于繁忙状态，因此发射了 $0$ 条 $X_j$。\n*   有 $6$ 个周期发射了 $L_i$ 指令（$2, 6, \\ldots, 22$）。ALU 空闲，因此共同发射了 $1$ 条 $X_j$。总计：$6$ 条 $X_j$。\n*   在 $L_i$ 完成和 $A_{i+1}$ 开始之间的间隔中，ALU 是空闲的。例如，在 $t=2$（$L_1$ 发射）和 $t=5$（$A_2$ 发射）之间，我们有周期 $3$ 和 $4$。在这 $L_M-L_A = 3-1=2$ 个周期内，可以发射一条 $X_j$。这种模式重复 $5$ 次（对于 $L_1$ 到 $L_5$）。总计：$5 \\times 2 = 10$ 条 $X_j$。\n*   到周期 $22$ 为止发射的 $X_j$ 总数：$6 + 10 = 16$。\n\n我们还剩下 $20 - 16 = 4$ 条 $X_j$ 指令。在周期 $22$ 之后，关键路径上的指令都已发射。ALU 是空闲的。\n*   $t=23$：发射 $X_{17}$（在周期 23 末尾完成）。\n*   $t=24$：发射 $X_{18}$（在周期 24 末尾完成）。\n*   $t=25$：发射 $X_{19}$（在周期 25 末尾完成）。\n*   $t=26$：发射 $X_{20}$（在周期 26 末尾完成）。\n\n最后一条链指令 $L_6$ 在周期 $24$ 末尾完成。最后一条独立指令 $X_{20}$ 在周期 $26$ 末尾完成。完工时间是这些完成时间的最大值。\n$T_1 = \\max(24, 26) = 26$。\n\n在这种情况下，瓶颈是 ALU 资源。26 个周期的完工时间恰好与 $\\lceil N_{ALU} / R_A \\rceil = \\lceil 26/1 \\rceil = 26$ 个周期的下界相匹配。\n\n#### 情况 2：升级配置（$R_A=2$）\n\n这里，$R_A=2$。机器每个周期可以发射两条 ALU 指令，或者一条 ALU 和一条 MEM 指令，最多不超过 $W=2$ 的发射宽度。\n\n首先，我们分析关键路径。依赖链 $A_i \\rightarrow L_i$ 在 ALU 和 MEM 资源之间交替。增加第二个 ALU 并不能让 $A_i$ 和 $A_{i+1}$ 并行执行，因为中间有 $L_i$ 的数据依赖。现在可以将独立的 $X_j$ 与 $A_i$ 或 $L_i$ 共同发射而不会拖延其他指令。关键路径指令的发射调度保持不变，因为它受数据依赖延迟的限制，而不是 ALU 资源的限制。\n$T_{issue}(L_6) = 22$。\n$L_6$ 在周期 $22+L_M-1=24$ 的末尾完成。\n从头到尾执行关键路径的最短时间是 $24$ 个周期。这是完工时间的关键路径下界。\n\n现在，我们调度这 $20$ 条 $X_j$ 指令。\n*   发射 $A_i$ 的周期（$1, 5, \\ldots$）：我们发射 $\\{A_i, X_j\\}$。\n*   发射 $L_i$ 的周期（$2, 6, \\ldots$）：我们发射 $\\{L_i, X_j\\}$。\n*   在间隙周期中（例如 $3, 4, 7, 8, \\ldots$）：我们可以发射 $\\{X_j, X_{j+1}\\}$。\n\n让我们找出最后一条 $X_j$ 是何时发射的：\n*   $t=1$：发射 $\\{A_1, X_1\\}$。（已发射 1 条 $X_j$）\n*   $t=2$：发射 $\\{L_1, X_2\\}$。（已发射 2 条 $X_j$）\n*   $t=3$：发射 $\\{X_3, X_4\\}$。（已发射 4 条 $X_j$）\n*   $t=4$：发射 $\\{X_5, X_6\\}$。（已发射 6 条 $X_j$）\n*   $t=5$：发射 $\\{A_2, X_7\\}$。（已发射 7 条 $X_j$）\n*   $t=6$：发射 $\\{L_2, X_8\\}$。（已发射 8 条 $X_j$）\n*   $t=7, 8$：再发射 4 条 $X_j$。（已发射 12 条 $X_j$）\n*   $t=9$：发射 $\\{A_3, X_{13}\\}$。（已发射 13 条 $X_j$）\n*   $t=10$：发射 $\\{L_3, X_{14}\\}$。（已发射 14 条 $X_j$）\n*   $t=11, 12$：再发射 4 条 $X_j$。（已发射 18 条 $X_j$）\n*   $t=13$：发射 $\\{A_4, X_{19}\\}$。（已发射 19 条 $X_j$）\n*   $t=14$：发射 $\\{L_4, X_{20}\\}$。（已发射 20 条 $X_j$）\n\n最后一条独立指令 $X_{20}$ 在 $t=14$ 发射。它在周期 $14+L_A-1=14$ 的末尾完成。\n所有 $X_j$ 指令在周期 $14$ 的末尾完成。关键路径的执行继续进行，直到 $L_6$ 在周期 $24$ 的末尾完成。\n完工时间是最大的完成时间。\n$T_2 = \\max(14, 24) = 24$。\n\n在这种情况下，瓶颈从 ALU 资源转移到了 $A_i \\rightarrow L_i$ 链的数据依赖关键路径上。24 个周期的完工时间与关键路径长度相匹配。\n\n#### 加速比计算\n\n加速比 $S$ 是基线配置完工时间与升级配置完工时间之比。\n$S = \\frac{T_1}{T_2} = \\frac{26}{24}$\n化简分数为：\n$S = \\frac{13}{12}$\n\n加速比有限的原因是，性能最初受单个 ALU 的限制，在升级后转而受内存链的数据依赖延迟的限制。额外的 ALU 资源成功地隐藏了独立指令的延迟，但无法缩短依赖指令链的基本关键路径。", "answer": "$$\\boxed{\\frac{13}{12}}$$", "id": "3650798"}, {"introduction": "指令调度并非孤立存在，它严重依赖于编译器其他分析阶段提供的信息，尤其是内存别名分析。这个练习探讨了当编译器无法确定两个内存指针是否指向同一地址（即“可能别名”）时所面临的困境。你将分别在乐观和悲观的别名假设下进行调度，并量化这两种策略对调度结果和处理器停顿周期的具体影响。[@problem_id:3650816]", "problem": "一个编译器后端的目标是一个静态调度的超长指令字 (VLIW) 架构，但为了简化分析，它会生成一个单发射调度。对于一个单一的基本块，请考虑以下的指令序列和机器模型。目标是执行两次列表调度，第一次在乐观内存别名假设下，第二次在悲观内存别名假设下，然后量化这些假设如何改变调度。最后，计算这些调度之间差异的标量摘要。\n\n机器模型和调度策略：\n- 处理器每个周期可以精确发射一条指令。每条发射的指令在其开始周期占据唯一的发射槽；在其结果延迟期间，处理器可以在后续周期发射其他就绪的指令。\n- 功能单元的延迟是固定的：加载 (load) 延迟为 $3$，存储 (store) 延迟为 $2$，乘法 (multiply) 延迟为 $3$，加法 (add) 延迟为 $1$。\n- 消费指令必须等到其所有生产指令的结果都可用后才能发射；也就是说，一条带操作数的指令只有在每个所需的操作数都已生成且相应的延迟已经过去后，才变为就绪状态。\n- 使用列表调度，其优先级等于到出口的最长加权路径（关键路径长度），计算方法为节点延迟加上其后继节点优先级的最大值。当多个就绪指令具有相同优先级时，按较早的程序顺序打破平局。\n- 只有一个内存单元；然而，由于机器是单发射的，资源冲突被发射宽度的限制所涵盖。\n\n程序和依赖关系：\n- 程序顺序（从先到后）：$L_{A}$、$L_{B}$、$M_{1}$、$S_{P}$、$L_{C}$、$M_{2}$、$A$。\n- 语义：\n  - $L_{A}$：加载 $a \\leftarrow *p$。\n  - $L_{B}$：加载 $b \\leftarrow *q$。\n  - $M_{1}$：乘法 $x \\leftarrow a \\times b$。\n  - $S_{P}$：存储 $*p \\leftarrow x$。\n  - $L_{C}$：加载 $c \\leftarrow *r$。\n  - $M_{2}$：乘法 $y \\leftarrow c \\times x$。\n  - $A$：加法 $z \\leftarrow y + b$。\n- 来自别名分析的已证实和未知的别名事实：\n  - $q$ 已被证实不与 $p$ 或 $r$ 别名。\n  - $p$ 可能与 $r$ 别名（未知的别名关系）。\n- 真数据依赖：\n  - $L_{A} \\rightarrow M_{1}$、$L_{B} \\rightarrow M_{1}$、$M_{1} \\rightarrow S_{P}$、$L_{C} \\rightarrow M_{2}$、$M_{1} \\rightarrow M_{2}$、$M_{2} \\rightarrow A$、$L_{B} \\rightarrow A$。\n- 两种别名假设下的内存排序依赖：\n  - 乐观假设：除了已证实的依赖外，不引入额外的依赖；特别地，不约束 $S_{P}$ 和 $L_{C}$，因为 $p$ 是否可能与 $r$ 别名是未知的。\n  - 悲观假设：由于 $p$ 和 $r$ 之间可能存在别名，引入一个写后读依赖 $S_{P} \\rightarrow L_{C}$。将此依赖视为要求存储操作在加载操作可以发射之前完成。\n\n任务：\n1. 使用给定的延迟和依赖关系，在乐观和悲观两种别名假设下，为每条指令计算列表调度优先级（到出口的关键路径长度）。然后，为每种情况构建单发射调度，方法是从周期 $0$ 开始，在每个周期选择优先级最高的就绪指令（按较早的程序顺序打破平局），每发射一条指令时间推进 $1$。一条指令在其延迟结束后产生结果。\n2. 对于每个调度，记录每条指令的开始周期和最后一条指令的完成周期。将停顿周期定义为因没有指令就绪而未发射任何指令的任何周期。\n3. 定义调度差异 $D$ 为所有指令在乐观和悲观调度下开始周期的绝对差之和。定义停顿传播差异 $\\Delta S$ 为悲观调度和乐观调度中停顿周期数的差值。\n4. 计算由 $\\Gamma = \\frac{D}{\\Delta S}$ 定义的标量摘要 $\\Gamma$。将你的答案四舍五入到四位有效数字。", "solution": "该问题要求在乐观和悲观两种不同的内存别名假设下，对列表调度进行详细分析。我们必须首先验证问题，然后计算调度，最后计算指定的指标 $D$、$\\Delta S$ 和 $\\Gamma$。\n\n**问题验证**\n该问题是有效的。它在科学上植根于编译器设计和计算机体系结构的原理，特别是指令调度。问题提法得当（well-posed），提供了一套完整的指令、它们的延迟、一个清晰的调度算法（列表调度）、一个优先级启发式算法（关键路径长度）、一个平局打破规则（程序顺序），以及对两种场景（乐观和悲观别名）的精确定义。整个设置是自洽、一致且客观的，允许存在一个唯一的、可验证的解决方案。其中没有矛盾、歧义或不切实际的条件。\n\n**指令和延迟数据**\n指令表示为 $L_A, L_B, M_1, S_P, L_C, M_2, A$。它们各自的延迟如下：\n- 加载 ($L_A, L_B, L_C$): $3$ 个周期\n- 存储 ($S_P$): $2$ 个周期\n- 乘法 ($M_1, M_2$): $3$ 个周期\n- 加法 ($A$): $1$ 个周期\n\n**第1部分：乐观调度**\n\n**依赖图和优先级（乐观情况）**\n在乐观假设下，我们只考虑真数据依赖。我们构建数据依赖图（DDG）并为每条指令计算优先级。优先级 $P(I)$ 是指令 $I$ 的延迟加上其后继节点优先级的最大值。图的叶节点（没有后继节点的节点）的优先级等于其延迟。\n\n每条指令的后继节点如下：\n- $A$: 无（叶节点）\n- $S_P$: 无（叶节点）\n- $M_2$: 后继节点为 $A$。\n- $L_C$: 后继节点为 $M_2$。\n- $M_1$: 后继节点为 $S_P$ 和 $M_2$。\n- $L_B$: 后继节点为 $M_1$ 和 $A$。\n- $L_A$: 后继节点为 $M_1$。\n\n我们通过从叶节点向后遍历图来计算优先级：\n- $P(A) = \\text{latency}(A) = 1$\n- $P(S_P) = \\text{latency}(S_P) = 2$\n- $P(M_2) = \\text{latency}(M_2) + P(A) = 3 + 1 = 4$\n- $P(M_1) = \\text{latency}(M_1) + \\max(P(S_P), P(M_2)) = 3 + \\max(2, 4) = 7$\n- $P(L_C) = \\text{latency}(L_C) + P(M_2) = 3 + 4 = 7$\n- $P(L_B) = \\text{latency}(L_B) + \\max(P(M_1), P(A)) = 3 + \\max(7, 1) = 10$\n- $P(L_A) = \\text{latency}(L_A) + P(M_1) = 3 + 7 = 10$\n\n乐观情况下的优先级为：$P(L_A)=10$, $P(L_B)=10$, $P(L_C)=7$, $P(M_1)=7$, $P(M_2)=4$, $P(S_P)=2$, $P(A)=1$。\n\n**列表调度（乐观情况）**\n我们从周期 $0$ 开始逐周期地调度指令。在每个周期，我们选择优先级最高的就绪指令。平局由原始程序顺序打破：$L_A, L_B, M_1, S_P, L_C, M_2, A$。当一条指令的所有生产者都完成后，该指令就绪。一条在周期 $C$ 开始、延迟为 $L$ 的指令在周期 $C+L$ 完成。\n\n- 周期 $0$: 就绪集 {$L_A, L_B, L_C$}。优先级为 $P(L_A)=10, P(L_B)=10, P(L_C)=7$。$L_A$ 和 $L_B$ 的优先级最高。根据程序顺序，选择 $L_A$。\n  - 发射 $L_A$。开始: $0$。完成: $0+3=3$。\n- 周期 $1$: 就绪集 {$L_B, L_C$}。优先级 $P(L_B)=10, P(L_C)=7$。选择 $L_B$。\n  - 发射 $L_B$。开始: $1$。完成: $1+3=4$。\n- 周期 $2$: 就绪集 {$L_C$}。优先级 $P(L_C)=7$。选择 $L_C$。\n  - 发射 $L_C$。开始: $2$。完成: $2+3=5$。\n- 周期 $3$: 没有指令就绪。$M_1$ 需要 $L_A$ (在周期 3 完成) 和 $L_B$ (在周期 4 完成)。**停顿**。\n- 周期 $4$: $L_B$ 已完成。$M_1$ 现在就绪。就绪集 {$M_1$}。优先级 $P(M_1)=7$。\n  - 发射 $M_1$。开始: $4$。完成: $4+3=7$。\n- 周期 $5$: 没有指令就绪。$L_C$ 完成，但 $M_2$ 还需要 $M_1$ (在周期 7 完成)。**停顿**。\n- 周期 $6$: 没有指令就绪。**停顿**。\n- 周期 $7$: $M_1$ 已完成。$S_P$ (需要 $M_1$) 和 $M_2$ (需要 $M_1, L_C$) 就绪。就绪集 {$S_P, M_2$}。优先级 $P(S_P)=2, P(M_2)=4$。选择 $M_2$。\n  - 发射 $M_2$。开始: $7$。完成: $7+3=10$。\n- 周期 $8$: 就绪集 {$S_P$}。优先级 $P(S_P)=2$。\n  - 发射 $S_P$。开始: $8$。完成: $8+2=10$。\n- 周期 $9$: 没有指令就绪。$A$ 需要 $M_2$ (在周期 10 完成)。**停顿**。\n- 周期 $10$: $M_2$ 和 $S_P$ 已完成。$A$ (需要 $M_2, L_B$) 就绪。就绪集 {$A$}。优先级 $P(A)=1$。\n  - 发射 $A$。开始: $10$。完成: $10+1=11$。\n\n调度在周期 11 完成。总周期数为 11。\n乐观情况下的开始时间 ($S_{opt}$): $L_A(0), L_B(1), L_C(2), M_1(4), M_2(7), S_P(8), A(10)$。\n停顿周期数：$11$ 个总周期 - $7$ 条指令 = $4$。\n\n**第2部分：悲观调度**\n\n**依赖图和优先级（悲观情况）**\n悲观假设由于 $p$ 和 $r$ 指向的内存位置之间可能存在别名，增加了一个写后读依赖 $S_P \\rightarrow L_C$。DDG 现在包含这条边。这深刻地改变了图的结构和优先级。\n\n新的后继节点集合如下：\n- $A$: 无（叶节点）\n- $M_2$: 后继节点为 $A$。\n- $L_C$: 后继节点为 $M_2$。\n- $S_P$: 后继节点为 $L_C$。\n- $M_1$: 后继节点为 $S_P$ 和 $M_2$。\n- $L_B$: 后继节点为 $M_1$ 和 $A$。\n- $L_A$: 后继节点为 $M_1$。\n\n我们重新计算优先级：\n- $P(A) = 1$\n- $P(M_2) = \\text{latency}(M_2) + P(A) = 3 + 1 = 4$\n- $P(L_C) = \\text{latency}(L_C) + P(M_2) = 3 + 4 = 7$\n- $P(S_P) = \\text{latency}(S_P) + P(L_C) = 2 + 7 = 9$\n- $P(M_1) = \\text{latency}(M_1) + \\max(P(S_P), P(M_2)) = 3 + \\max(9, 4) = 12$\n- $P(L_B) = \\text{latency}(L_B) + \\max(P(M_1), P(A)) = 3 + \\max(12, 1) = 15$\n- $P(L_A) = \\text{latency}(L_A) + P(M_1) = 3 + 12 = 15$\n\n悲观情况下的优先级为：$P(L_A)=15$, $P(L_B)=15$, $P(M_1)=12$, $P(S_P)=9$, $P(L_C)=7$, $P(M_2)=4$, $P(A)=1$。\n\n**列表调度（悲观情况）**\n我们使用新的优先级和依赖关系重复调度过程。\n\n- 周期 $0$: 就绪集 {$L_A, L_B$}。$L_C$ 未就绪，因为它依赖于 $S_P$。优先级为 $P(L_A)=15, P(L_B)=15$。根据程序顺序，选择 $L_A$。\n  - 发射 $L_A$。开始: $0$。完成: $0+3=3$。\n- 周期 $1$: 就绪集 {$L_B$}。优先级 $P(L_B)=15$。\n  - 发射 $L_B$。开始: $1$。完成: $1+3=4$。\n- 周期 $2$: 没有指令就绪。**停顿**。\n- 周期 $3$: 没有指令就绪。$L_A$ 完成，但 $M_1$ 需要 $L_B$ (在周期 4 完成)。**停顿**。\n- 周期 $4$: $L_B$ 已完成。$M_1$ 就绪。就绪集 {$M_1$}。优先级 $P(M_1)=12$。\n  - 发射 $M_1$。开始: $4$。完成: $4+3=7$。\n- 周期 $5$: 没有指令就绪。**停顿**。\n- 周期 $6$: 没有指令就绪。**停顿**。\n- 周期 $7$: $M_1$ 已完成。$S_P$ 就绪。就绪集 {$S_P$}。优先级 $P(S_P)=9$。\n  - 发射 $S_P$。开始: $7$。完成: $7+2=9$。\n- 周期 $8$: 没有指令就绪。**停顿**。\n- 周期 $9$: $S_P$ 已完成。$L_C$ 就绪。就绪集 {$L_C$}。优先级 $P(L_C)=7$。\n  - 发射 $L_C$。开始: $9$。完成: $9+3=12$。\n- 周期 $10$: 没有指令就绪。**停顿**。\n- 周期 $11$: 没有指令就绪。**停顿**。\n- 周期 $12$: $L_C$ 已完成。$M_2$ 就绪。就绪集 {$M_2$}。优先级 $P(M_2)=4$。\n  - 发射 $M_2$。开始: $12$。完成: $12+3=15$。\n- 周期 $13$: 没有指令就绪。**停顿**。\n- 周期 $14$: 没有指令就绪。**停顿**。\n- 周期 $15$: $M_2$ 已完成。$A$ 就绪。就绪集 {$A$}。优先级 $P(A)=1$。\n  - 发射 $A$。开始: $15$。完成: $15+1=16$。\n\n调度在周期 16 完成。总周期数为 16。\n悲观情况下的开始时间 ($S_{pess}$): $L_A(0), L_B(1), M_1(4), S_P(7), L_C(9), M_2(12), A(15)$。\n停顿周期数：$16$ 个总周期 - $7$ 条指令 = $9$。\n\n**第3部分：调度差异和停顿差**\n\n**调度差异， $D$**\n$D$ 是两条调度中每条指令开始周期的绝对差之和。\n$D = |S_{opt}(L_A) - S_{pess}(L_A)| + |S_{opt}(L_B) - S_{pess}(L_B)| + \\dots + |S_{opt}(A) - S_{pess}(A)|$\n$D = |0-0| + |1-1| + |4-4| + |8-7| + |2-9| + |7-12| + |10-15|$\n$D = 0 + 0 + 0 + 1 + 7 + 5 + 5 = 18$\n\n**停顿传播差异， $\\Delta S$**\n$\\Delta S$ 是悲观调度和乐观调度中停顿周期数的差值。\n- 乐观调度中的停顿数，$stalls_{opt} = 4$。\n- 悲观调度中的停顿数，$stalls_{pess} = 9$。\n$\\Delta S = stalls_{pess} - stalls_{opt} = 9 - 4 = 5$。\n\n**第4部分：标量摘要 $\\Gamma$**\n标量摘要 $\\Gamma$ 定义为调度差异与停顿传播差异的比率。\n$$\n\\Gamma = \\frac{D}{\\Delta S} = \\frac{18}{5} = 3.6\n$$\n四舍五入到四位有效数字，我们得到 $3.600$。", "answer": "$$\n\\boxed{3.600}\n$$", "id": "3650816"}]}