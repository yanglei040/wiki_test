{"hands_on_practices": [{"introduction": "全局公共子表达式消除的第一步是定义表达式的“等价性”，而这不仅仅是语法上的相同。本练习旨在探讨如何利用交换律和结合律等代数性质为表达式创建“规范形式” ([@problem_id:3644049])。通过此练习，你将亲手实践如何根据不同的规范化策略对表达式进行分类，从而理解编译器如何发现更深层次的等价关系，为优化奠定基础。", "problem": "考虑一个三地址中间表示 (IR) 中的程序直线代码片段，该程序带有一个控制流图 (CFG)，其中变量 $a$、$b$、$c$ 和 $d$ 是在过程入口处定义的参数，并且从未被重新赋值。该 CFG 由四个基本块 $B_0$、$B_1$、$B_2$ 和 $B_3$ 组成，连接如下：$B_0$ 是唯一的入口，并分支到 $B_1$ 和 $B_2$；$B_1$ 和 $B_2$ 都汇入 $B_3$。所有计算都是纯计算，运算符 $+$ 是整数加法。IR 语句如下：\n\n在 $B_1$ 中：\n- $e_1 \\leftarrow a + (b + c)$\n- $e_2 \\leftarrow (a + b) + c$\n\n在 $B_2$ 中：\n- $e_3 \\leftarrow (b + c) + a$\n- $e_4 \\leftarrow (c + a) + b$\n\n在 $B_3$ 中：\n- $e_5 \\leftarrow a + (c + b)$\n- $e_6 \\leftarrow (a + c) + b$\n- $e_7 \\leftarrow a + (b + d)$\n- $e_8 \\leftarrow (a + b) + c$\n- $e_9 \\leftarrow a + (b + c)$\n\n假设使用全局值编号在整个 CFG 上执行全局公共子表达式消除 (GCSE)，并且语言语义允许根据所选策略对加法进行代数规范化。您将比较值编号所使用的两种规范化策略：\n\n- 策略 $\\mathcal{C}$：仅独立地对每个二元 $+$ 节点的交换律进行规范化（对于任何 $x$ 和 $y$，$x + y$ 规范地表示为一个排序的操作数对），而不使用跨越不同 $+$ 节点的结合律。\n- 策略 $\\mathcal{AC}$：通过首先将嵌套的加法扁平化成一个操作数的多重集，然后对该多重集进行排序，来对 $+$ 的结合律和交换律进行规范化。\n\n从以下基本定义出发：(i) 一个同余类将在所选的规范化和程序语义下可证明相等的 IR 表达式组合在一起，以及 (ii) 全局值编号必须为同余类的所有成员分配相同的值编号，无论它们位于哪个基本块中。请对出现在 $B_1$、$B_2$ 和 $B_3$ 中的所有九个右侧表达式的集合 $E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$ 进行确定：\n\n- $K_{\\mathcal{C}}$：策略 $\\mathcal{C}$ 下不同同余类的数量，\n- $K_{\\mathcal{AC}}$：策略 $\\mathcal{AC}$ 下不同同余类的数量。\n\n计算单一量 $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$。以精确整数形式提供您的最终答案。无需四舍五入。", "solution": "这个问题提取得当，科学上基于编译器理论的原理，并提供了一套完整且一致的已知条件。因此，该问题被认为是有效的，可以推导出解决方案。\n\n问题要求我们确定在两种不同的规范化策略 $\\mathcal{C}$ 和 $\\mathcal{AC}$ 下，给定的一组九个表达式有多少个不同的同余类。一个同余类组合了被证明是等价的表达式。这类别的数量是在给定策略下，表达式可以被归约到的唯一规范形式的数量。这九个右侧表达式的集合，记为 $E$，是：\n$E = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d), (a + b) + c, a + (b + c)\\}$.\n同余类的数量取决于 $E$ 中唯一表达式的集合。设 $S$ 为 $E$ 中语法上不同的表达式的集合。\n$S = \\{a + (b + c), (a + b) + c, (b + c) + a, (c + a) + b, a + (c + b), (a + c) + b, a + (b + d)\\}$.\n我们将根据每种策略对集合 $S$ 进行划分。\n\n**在策略 $\\mathcal{C}$ (仅交换律)下的分析**\n\n策略 $\\mathcal{C}$ 允许基于表达式语法树中每个节点的加法运算符 `+` 的交换律进行规范化，但不包括结合律。这意味着对于任何子表达式 $x+y$，其规范形式通过对其操作数进行排序来确定。我们假设变量按字母顺序排序，即 $a  b  c  d$。一个涉及子表达式的表达式，例如 $a + (b+c)$，被视为原子 $a$ 与由 $(b+c)$ 表示的值之间的运算。\n\n让我们为 $S$ 中的每个唯一表达式推导其规范形式：\n1.  对于 $a + (b + c)$：内部子表达式是 $b+c$。其规范形式是 $b+c$。外部表达式是 $a$ 加上内部表达式的结果。所以整个表达式的规范形式是 $a + (b+c)$。\n\n2.  对于 $(a + b) + c$：内部子表达式是 $a+b$。其规范形式是 $a+b$。外部表达式将 $c$ 加到这个结果上。规范形式是 $(a+b) + c$。这个结构形式与前一个不同。\n\n3.  对于 $(b + c) + a$：内部子表达式 $b+c$ 是规范的。外部表达式是 $(b+c$ 的结果$) + a$。应用交换律，我们对操作数排序得到 $a + (b+c)$，这与第一个表达式的规范形式相同。\n\n4.  对于 $(c + a) + b$：内部子表达式 $c+a$ 规范化为 $a+c$。整个表达式的规范形式是 $(a+c)+b$。这是一个新的结构形式。\n\n5.  对于 $a + (c + b)$：内部子表达式 $c+b$ 规范化为 $b+c$。整个表达式的规范形式是 $a + (b+c)$，与第一个表达式相同。\n\n6.  对于 $(a + c) + b$：内部子表达式 $a+c$ 是规范的。整个表达式的规范形式是 $(a+c)+b$，与第四个表达式相同。\n\n7.  对于 $a + (b + d)$：内部子表达式 $b+d$ 是规范的。整个表达式的规范形式是 $a+(b+d)$。这是一个新的形式，因为它涉及变量 $d$。\n\n在策略 $\\mathcal{C}$ 下，我们确定了以下不同的规范形式：\n- 第1类：$a + (b+c)$，代表 $\\{a + (b + c), (b + c) + a, a + (c + b)\\}$。\n- 第2类：$(a+b)+c$，代表 $\\{(a + b) + c\\}$。\n- 第3类：$(a+c)+b$，代表 $\\{(c + a) + b, (a + c) + b\\}$。\n- 第4类：$a+(b+d)$，代表 $\\{a + (b + d)\\}$。\n\n共有 $4$ 个不同的同余类。因此，$K_{\\mathcal{C}} = 4$。\n\n**在策略 $\\mathcal{AC}$ (结合律和交换律)下的分析**\n\n策略 $\\mathcal{AC}$ 将嵌套的加法视为单个 $n$ 元运算。其规范形式通过将表达式扁平化为其基本变量操作数的多重集，然后对此多重集进行排序来推导。\n\n让我们将此策略应用于 $S$ 中的表达式：\n1.  对于 $a + (b + c)$：扁平化得到多重集 $\\{a, b, c\\}$。排序后的操作数列表是 $(a, b, c)$。\n2.  对于 $(a + b) + c$：扁平化得到 $\\{a, b, c\\}$。排序后的列表是 $(a, b, c)$。\n3.  对于 $(b + c) + a$：扁平化得到 $\\{b, c, a\\}$。排序后的列表是 $(a, b, c)$。\n4.  对于 $(c + a) + b$：扁平化得到 $\\{c, a, b\\}$。排序后的列表是 $(a, b, c)$。\n5.  对于 $a + (c + b)$：扁平化得到 $\\{a, c, b\\}$。排序后的列表是 $(a, b, c)$。\n6.  对于 $(a + c) + b$：扁平化得到 $\\{a, c, b\\}$。排序后的列表是 $(a, b, c)$。\n\n上述六个表达式在策略 $\\mathcal{AC}$ 下是等价的，因为它们都归约到由排序的操作数列表 $(a, b, c)$ 表示的规范形式。\n\n7.  对于 $a + (b + d)$：扁平化得到多重集 $\\{a, b, d\\}$。排序后的操作数列表是 $(a, b, d)$。这是一个不同的规范形式，因为它包含 $d$ 而不是 $c$。\n\n在策略 $\\mathcal{AC}$ 下，我们确定了两个不同的规范形式：\n- 第1类：由 $(a, b, c)$ 表示，包括 $S$ 中除了 $a+(b+d)$ 之外的所有表达式。\n- 第2类：由 $(a, b, d)$ 表示，对应于表达式 $a+(b+d)$。\n\n共有 $2$ 个不同的同余类。因此，$K_{\\mathcal{AC}} = 2$。\n\n**最终计算**\n\n问题要求计算 $K_{\\mathcal{C}} - K_{\\mathcal{AC}}$ 的值。根据我们的分析：\n$K_{\\mathcal{C}} = 4$\n$K_{\\mathcal{AC}} = 2$\n\n最终结果是 $K_{\\mathcal{C}} - K_{\\mathcal{AC}} = 4 - 2 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3644049"}, {"introduction": "即便我们识别出了一个冗余计算，程序的控制流也可能阻碍我们安全地消除它。本练习将展示一个“关键边”(critical edge)如何阻碍一个简单的优化，并引导你使用编译器中的标准技术——边分裂 (edge splitting)，来创造一个安全的插入点，从而为后续的全局公共子表达式消除铺平道路 ([@problem_id:3644037])。这个过程体现了优化与程序图结构之间的密切联系。", "problem": "考虑一个以三地址码形式表示的函数，该函数由一个控制流图（CFG）表示。控制流图（CFG）是一个有向图，其节点是基本块，边代表块之间可能的控制转移。如果从入口到节点 $B_y$ 的每条路径都经过节点 $B_x$，则称节点 $B_x$ 支配节点 $B_y$。如果 $B_p$ 有两个或更多后继，并且 $B_s$ 有两个或更多前驱，则边 $(B_p,B_s)$ 是一条关键边。在静态单赋值（SSA）形式中，每个变量只被赋值一次，并在汇合点使用 $\\phi$-函数来合并来自不同前驱的值。\n\n给定以下包含基本块和语句的CFG结构，其中 $+$ 表示整数加法，根据源语言语义，该操作可能引发溢出异常。因此，不允许在最初未执行 $+$ 操作的路径上对其进行推测执行。假设 $a$ 和 $b$ 在一个唯一的支配性入口块 $B_0$ 中定义，在 $B_1$、$B_2$、$B_3$、$B_5$ 和 $B_4$ 中都未被重新定义，并且 $a$ 和 $b$ 都能到达所有的使用点。除了在此转换中引入 $\\phi$-函数的地方，所有变量都处于SSA形式。\n\nCFG骨架：\n- $B_0$：定义 $a$ 和 $b$，然后跳转到 $B_1$。\n- $B_1$：评估谓词 $cond$，如果为真则跳转到 $B_2$，如果为假则跳转到 $B_3$。\n- $B_2$：计算 $t_1 := a + b$，然后无条件跳转到 $B_4$。\n- $B_3$：不重新定义 $a$ 或 $b$，评估谓词 $cond_2$，如果为真则跳转到 $B_4$，如果为假则跳转到 $B_5$。\n- $B_5$：不重新定义 $a$ 或 $b$，然后无条件跳转到 $B_4$。\n- $B_4$：计算 $t_2 := a + b$，然后使用 $t_2$。\n\n注意到 $B_4$ 中的 $t_2 := a + b$ 重复了在 $B_2$ 中执行的计算，但该计算结果仅在通过 $B_2$ 的路径上可用。因为 $+$ 可能陷入（trap），所以你不能将 $a + b$ 移动到它最初未被执行的块中。你的任务是通过合法的插入操作，在不改变程序可观察行为的前提下，使得 $a+b$ 在所有通往 $B_4$ 的路径上都可用，从而在 $B_4$ 处启用对 $t_2 := a + b$ 的全局公共子表达式消除（GCSE）。如果边是关键边，在边上插入操作需要进行边分裂。\n\n在上述约束条件下，以下哪种转换是最小的、能保持语义的更改，并且可以通过一个 $\\phi$-合并值来消除 $B_4$ 中的重算 $t_2 := a + b$？\n\nA. 分裂关键边 $(B_3,B_4)$，在该边上创建一个新块 $S_{34}$。在 $S_{34}$ 中，插入 $t_3 := a + b$ 并跳转到 $B_4$。同时，在 $B_5$ 的末尾（跳转到 $B_4$ 之前）插入 $t_4 := a + b$。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(B_2 \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ B_5 \\mapsto t_4)$ 并使用 $t$。\n\nB. 仅分裂边 $(B_2,B_4)$，在该边上创建一个新块 $S_{24}$，并将 $t_1 := a + b$ 从 $B_2$ 移入 $S_{24}$。保持 $(B_3,B_4)$ 和 $(B_5,B_4)$ 不变。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1,\\ B_3 \\mapsto \\bot,\\ B_5 \\mapsto \\bot)$ 并使用 $t$，其中 $\\bot$ 表示无可用值。\n\nC. 不分裂任何边，通过在 $B_1$ 的末尾插入 $t_h := a + b$ 将 $a + b$ 从 $B_2$ 提升到 $B_1$。从 $B_2$ 中移除 $t_1 := a + b$，并在 $B_4$ 中用已经计算好的 $t_h$ 替换 $t_2 := a + b$。\n\nD. 同时分裂 $(B_3,B_4)$ 和 $(B_5,B_4)$，在这些边上创建新块 $S_{34}$ 和 $S_{54}$。在 $S_{34}$ 中插入 $t_3 := a + b$，在 $S_{54}$ 中插入 $t_4 := a + b$。同时，将 $t_1 := a + b$ 从 $B_2$ 移动到在 $(B_2,B_4)$ 上新建的分裂块 $S_{24}$ 中。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ S_{54} \\mapsto t_4)$ 并使用 $t$。\n\n选择最佳选项。", "solution": "问题陈述已经过验证且是合理的。它提出了一个编译器优化理论中的标准问题，涉及在特定约束下的全局公共子表达式消除（GCSE）。\n\n目标是通过确保在从所有前驱路径进入 $B_4$ 时 $a+b$ 的值都可用，来消除基本块 $B_4$ 中的冗余计算 $t_2 := a + b$。这需要一个既能保持语义又最小化的转换。\n\n首先，我们分析控制流图（CFG）的结构以及通往 $B_4$ 的路径。\n基本块及其控制流如下：\n- $B_0 \\to B_1$\n- $B_1 \\to B_2$（如果 $cond$ 为真），$B_1 \\to B_3$（如果 $cond$ 为假）\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$（如果 $cond_2$ 为真），$B_3 \\to B_5$（如果 $cond_2$ 为假）\n- $B_5 \\to B_4$\n$B_4$ 的前驱是 $\\{B_2, B_3, B_5\\}$。计算 $a+b$ 存在于 $B_2$ 中（作为 $t_1$），并在 $B_4$ 中被重算（作为 $t_2$）。为了消除重算，必须使 $a+b$ 的值在所有三条进入 $B_4$ 的路径上都可用。\n1. 路径 $... \\to B_2 \\to B_4$：表达式 $a+b$ 在 $B_2$ 中计算为 $t_1$。该值可用。\n2. 路径 $... \\to B_3 \\to B_4$：表达式 $a+b$ 未被计算。我们必须在此路径上插入一个计算 $t_3 := a+b$。\n3. 路径 $... \\to B_5 \\to B_4$：表达式 $a+b$ 未被计算。我们必须在此路径上插入一个计算 $t_4 := a+b$。\n\n接下来，我们考虑约束条件。\n- **禁止推测执行**：操作 `+` 可能陷入。因此，我们不能将计算 $a+b$ 移动到它会在一个最初不包含它的路径上执行的块中。例如，将 $a+b$ 提升到 $B_1$ 是非法的，因为它会在控制流路径 $B_1 \\to B_3 \\to ...$ 上被推测执行，而它最初并不在该路径上。这排除了简单的提升操作。\n- **在边上放置代码**：在“边上”插入计算是正确的方法。问题规定，如果 $B_p$ 有两个或更多后继，且 $B_s$ 有两个或更多前驱，则边 $(B_p, B_s)$ 是关键边。在关键边上插入代码需要进行*边分裂*：在该边上创建一个新的基本块来容纳插入的代码。\n\n让我们识别进入 $B_4$ 的关键边：\n- $B_4$ 的前驱：$\\{B_2, B_3, B_5\\}$。因此，$B_4$ 有3个前驱。\n- $B_2$ 的后继：$\\{B_4\\}$。$B_2$ 有1个后继。边 $(B_2, B_4)$ **不是**关键边。\n- $B_3$ 的后继：$\\{B_4, B_5\\}$。$B_3$ 有2个后继。边 $(B_3, B_4)$ 是**关键边**。\n- $B_5$ 的后继：$\\{B_4\\}$。$B_5$ 有1个后继。边 $(B_5, B_4)$ **不是**关键边。\n\n基于此分析，所需的插入操作如下：\n- 对于从 $B_3$ 到 $B_4$ 的路径：必须在边 $(B_3, B_4)$ 上插入一个计算。由于该边是关键边，必须对其进行分裂。创建一个新块，例如 $S_{34}$。边 $(B_3, B_4)$ 被替换为两条边 $(B_3, S_{34})$ 和 $(S_{34}, B_4)$。计算 $t_3 := a+b$ 被放置在 $S_{34}$ 中。\n- 对于从 $B_5$ 到 $B_4$ 的路径：必须在边 $(B_5, B_4)$ 上插入一个计算。由于该边不是关键边，我们不需要分裂它。计算 $t_4 := a+b$ 可以放置在块 $B_5$ 的末尾，紧邻跳转到 $B_4$ 之前。\n\n经过这些转换后，表达式 $a+b$ 在所有通往 $B_4$ 的路径上都可用。块 $B_4$ 现在的前驱是 $\\{B_2, S_{34}, B_5\\}$。冗余计算可以被一个合并这些值的 $\\phi$-函数所取代：\n在 $B_4$ 中：用 $t := \\phi(B_2 \\mapsto t_1, S_{34} \\mapsto t_3, B_5 \\mapsto t_4)$ 替换 $t_2 := a+b$。\n\n这组变更是最小的，因为根据规则必须分裂关键边，并且为了使表达式完全可用，必须添加计算来覆盖缺失的路径。\n\n现在，我们评估给定的选项。\n\n**A. 分裂关键边 $(B_3,B_4)$，在该边上创建一个新块 $S_{34}$。在 $S_{34}$ 中，插入 $t_3 := a + b$ 并跳转到 $B_4$。同时，在 $B_5$ 的末尾（跳转到 $B_4$ 之前）插入 $t_4 := a + b$。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(B_2 \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ B_5 \\mapsto t_4)$ 并使用 $t$。**\n该选项与我们推导出的最小且正确的转换完全匹配。它正确地识别了关键边 $(B_3, B_4)$，对其进行分裂，并在新块 $S_{34}$ 中插入计算。它通过在 $B_5$ 中插入计算来正确处理来自 $B_5$ 的非关键路径。最后，它使用现在有效的前驱在 $B_4$ 中构造了正确的 $\\phi$-函数。\n**结论：正确。**\n\n**B. 仅分裂边 $(B_2,B_4)$，在该边上创建一个新块 $S_{24}$，并将 $t_1 := a + b$ 从 $B_2$ 移入 $S_{24}$。保持 $(B_3,B_4)$ 和 $(B_5,B_4)$ 不变。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1,\\ B_3 \\mapsto \\bot,\\ B_5 \\mapsto \\bot)$ 并使用 $t$，其中 $\\bot$ 表示无可用值。**\n这个转换是有缺陷的。它未能使表达式 $a+b$ 在来自 $B_3$ 和 $B_5$ 的路径上可用。标准SSA形式中的 $\\phi$-函数要求每个前驱路径都有一个有效的变量。使用 $\\bot$ 表示值不可用，这意味着公共子表达式无法被消除。转换的目标没有实现。\n**结论：不正确。**\n\n**C. 不分裂任何边，通过在 $B_1$ 的末尾插入 $t_h := a + b$ 将 $a + b$ 从 $B_2$ 提升到 $B_1$。从 $B_2$ 中移除 $t_1 := a + b$，并在 $B_4$ 中用已经计算好的 $t_h$ 替换 $t_2 := a + b$。**\n这个转换违反了禁止推测执行的约束。将 $t_h := a+b$ 放置在 $B_1$ 中会导致它在路径 $B_1 \\to B_3$ 上执行，而它最初并未在该路径上执行。由于 `+` 操作可能陷入，如果在该路径上发生溢出，这将改变程序的可观察行为。\n**结论：不正确。**\n\n**D. 同时分裂 $(B_3,B_4)$ 和 $(B_5,B_4)$，在这些边上创建新块 $S_{34}$ 和 $S_{54}$。在 $S_{34}$ 中插入 $t_3 := a + b$，在 $S_{54}$ 中插入 $t_4 := a + b$。同时，将 $t_1 := a + b$ 从 $B_2$ 移动到在 $(B_2,B_4)$ 上新建的分裂块 $S_{24}$ 中。在 $B_4$ 中，将 $t_2 := a + b$ 替换为 $t := \\phi(S_{24} \\mapsto t_1,\\ S_{34} \\mapsto t_3,\\ S_{54} \\mapsto t_4)$ 并使用 $t$。**\n这个转换是保持语义的，并且实现了启用GCSE的目标。然而，它不是最小的。它不必要地分裂了非关键边 $(B_2, B_4)$ 和 $(B_5, B_4)$。如前所述，代码可以放置在 $B_5$ 的末尾而无需分裂边，并且 $B_2$ 中的计算根本不需要移动。此选项创建了3个新块，而选项A只创建了1个。因此，这个解决方案不是最小的。\n**结论：不正确。**\n\n根据分析，选项A是唯一描述了正确、保持语义且最小的转换的选项。", "answer": "$$\\boxed{A}$$", "id": "3644037"}, {"introduction": "在真实的程序中，涉及内存访问的表达式（如全局变量或指针解引用）为优化带来了极大的复杂性。本练习挑战你站在编译器的视角，对内存别名和函数调用可能产生的副作用做出安全的、保守的判断 ([@problem_id:3643954])。通过分析不同情境下优化是否安全，你将深刻理解为什么别名分析 (alias analysis) 和过程间分析 (interprocedural analysis) 对于现代编译器实现有效的全局优化至关重要。", "problem": "考虑以下在一个具有头等函数和指针的语言中的直线型代码片段。变量 $a$ 和 $b$ 表示存储在内存中的整数（例如，全局变量或堆上分配的变量），而 $t_1$ 和 $t_2$ 是临时变量。函数调用 callee 可能有内存副作用。\n\n代码：\n- $S_1$: $t_1 \\leftarrow a * b$\n- $C$: call callee$(q)$\n- $S_2$: $t_2 \\leftarrow a * b$\n- use$(t_1)$; use$(t_2)$\n\n假设：\n- 指针 $q$ 可能指向也可能不指向 $a$ 或 $b$ 的存储位置；这取决于别名信息。\n- 函数 callee 可以写入从 $q$ 可达的内存，并且只有在特别指定的情况下，才可能有其他不涉及 $q$ 的副作用。\n- 不会发生未定义行为。\n- 目标是执行全局公共子表达式消除（Global Common Subexpression Elimination, GCSE），使用标准的数据流概念：如果沿着所有通往程序点 $p$ 的路径，表达式 $e$ 都已被计算且未失效，则该表达式在 $p$ 点是可用的；如果一个语句不修改表达式 $e$ 的任何操作数或这些操作数所依赖的任何内存位置，则该语句相对于 $e$ 是透明的。\n\n您可以使用的基本定义：\n- 如果一个程序点的语句可能修改 $x$ 或 $y$ 的值（包括通过内存效应），则表达式 $x * y$ 在该点被杀死（killed）。\n- 在缺乏精确别名信息的情况下，对于一个可能通过可能与操作数存储位置别名化的指针进行写入的调用，必须保守地假设它会修改该操作数。\n- 静态单赋值（Static Single Assignment, SSA）形式对标量变量的定义进行了重命名，但其本身并不捕捉内存别名或副作用；内存效应需要单独建模（例如，内存 SSA 或 mod/ref 分析）。\n\n在此代码中，根据所指示的别名假设，选择所有关于表达式 $a * b$ 的安全 GCSE 放置的正确陈述。\n\nA. 在一个保守的 may-alias 模型中，$q$ 可能指向 $a$ 或 $b$ 的存储位置，因此调用 $C$ 对 $a * b$ 不是透明的，所以 $a * b$ 在 $C$ 之后是不可用的。消除 $S_2$ 或将其移到 $C$ 之上是不安全的。\n\nB. 如果过程间 mod/ref 和别名分析证明 callee 既不写入 $a$ 的存储位置也不写入 $b$ 的存储位置（并且没有其他影响它们的副作用），那么调用 $C$ 对 $a * b$ 是透明的，GCSE 可以在 $C$ 之前计算一次 $a * b$ 并在 $C$ 之后重用该值。\n\nC. 即使当 $q$ 可能与 $a$ 或 $b$ 别名时，在 $S_1$ 处将调用前 $a * b$ 的值保存到临时变量中并在 $C$ 之后重用它也总是安全的，因为临时变量不受别名影响。\n\nD. 将代码转换为静态单赋值（SSA）形式并应用全局值编号（GVN）足以在没有别名信息的情况下，在 $C$ 之后重用调用前 $a * b$ 的值。\n\nE. 当别名未知时，一种安全的保守近似方法是，对于 GCSE，将 callee 视为相对于 $a$ 和 $b$ 是只读的，从而允许通过在 $C$ 之后重用 $S_1$ 的值来消除 $S_2$。", "solution": "在进行解答之前，首先对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n\n所提供的信息包括：\n- **代码片段：**\n  - $S_1$: $t_1 \\leftarrow a * b$\n  - $C$: call callee$(q)$\n  - $S_2$: $t_2 \\leftarrow a * b$\n  - use$(t_1)$; use$(t_2)$\n- **变量和函数描述：**\n  - $a, b$：存储在内存中的整数（例如，全局变量或堆分配的变量）。\n  - $t_1, t_2$：临时变量。\n  - $q$：一个指针。\n  - callee：一个可能有内存副作用的函数。\n- **假设和定义：**\n  - **别名信息：** 指针 $q$ 可能指向也可能不指向 $a$ 或 $b$ 的存储位置。\n  - **函数副作用：** 函数 `callee` 可能写入从 $q$ 可达的内存。\n  - **行为：** 不会发生未定义行为。\n  - **优化目标：** 对表达式 $a * b$ 执行全局公共子表达式消除（GCSE）。\n  - **可用性：** 如果沿着所有通往程序点 $p$ 的路径，表达式 $e$ 都已被计算且未失效，则该表达式在 $p$ 点是可用的。\n  - **透明性：** 如果一个语句不修改表达式 $e$ 的任何操作数或这些操作数所依赖的任何内存位置，则该语句相对于表达式 $e$ 是透明的。\n  - **杀死表达式：** 如果一个语句可能修改 $x$ 或 $y$ 的值（包括通过内存效应），则表达式 $x * y$ 被杀死。\n  - **保守假设：** 在缺乏精确别名信息的情况下，对于一个可能通过可能与操作数存储位置别名化的指针进行写入的调用，必须假设它会修改该操作数。\n  - **SSA 形式：** 静态单赋值（SSA）形式对标量变量的定义进行了重命名，但其本身并不捕捉内存别名或副作用。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n评估问题陈述的有效性。\n- **科学依据：** 该问题牢固地植根于编译器理论的原理，特别是用于程序优化的数据流分析。全局公共子表达式消除（GCSE）、别名、mod/ref 分析和静态单赋值（SSA）等概念是计算机科学中标准且成熟的概念。该问题在科学上是合理的。\n- **良构性：** 该问题是良构的。它提出了一个特定的代码片段和一个明确的目标：在关于别名分析的各种假设下，评估几个关于应用 GCSE 的陈述的正确性。所提供的定义足以对每个陈述进行推理并得出明确的结论。\n- **客观性：** 该问题以精确、客观、技术性的语言陈述，没有主观性或歧义。\n\n该问题没有表现出任何列举的缺陷（例如，事实不健全、非形式化、不完整等）。这个设置是一个典型的例子，用于教授在存在指针和函数调用的情况下进行优化的挑战。\n\n### 步骤 3：结论和行动\n\n问题陈述是**有效的**。将推导出解决方案。\n\n### 解决方案推导\n\n核心问题是公共子表达式 $a * b$ 是否可以被消除。第二个计算 $S_2: t_2 \\leftarrow a * b$ 仅当表达式 $a * b$ 在 $S_2$ 之前是*可用的*（available）时，才能被替换为 $t_2 \\leftarrow t_1$。根据提供的定义，如果一个表达式已经被计算，并且自计算以来其操作数未被修改，则该表达式是可用的。\n\n在这里，$a * b$ 在 $S_1$ 处计算。唯一的中间语句是函数调用 $C$: call callee$(q)$。因此，优化的安全性完全取决于对 `callee` 的调用是否会修改操作数 $a$ 或 $b$ 的值。由于 $a$ 和 $b$ 存储在内存中，这是一个关于内存副作用和别名的问题。\n\n- 表达式 $a * b$ 在语句 $S_1$ 处被*生成*（generated）。\n- 为了在 $S_2$ 之前可用，该表达式决不能被 $C$ 处的调用*杀死*（killed）。\n- 如果 `callee` 可能修改 $a$ 的内存位置或 $b$ 的内存位置，则表达式 $a * b$ 会被 $C$ 处的调用杀死。\n\n在此框架下，对每个选项进行评估。\n\n**A. 在一个保守的 may-alias 模型中，$q$ 可能指向 $a$ 或 $b$ 的存储位置，因此调用 $C$ 对 $a * b$ 不是透明的，所以 $a * b$ 在 $C$ 之后是不可用的。消除 $S_2$ 或将其移到 $C$ 之上是不安全的。**\n\n这个陈述描述了编译器优化的标准保守方法。在没有相反的明确信息（即“无别名”证明）的情况下，“可能别名”（may-alias）的情况要求编译器为了安全而假设最坏情况。\n- **假设：** `callee` 可能通过指针 $q$ 写入内存，且 $q$ 可能与 $a$ 或 $b$ 别名。\n- **推论：** 必须假设在 $C$ 处的调用可能会修改 $a$ 和/或 $b$ 的值。\n- **后果：** 如果操作数 $a$ 或 $b$ 被修改，表达式 $a * b$ 就会被该调用杀死。因此，该调用对于 $a * b$ 不是透明的。因此，在 $S_1$ 计算的值不保证等同于在 $S_2$ 将计算的值。该表达式在 $C$ 之后是不可用的。\n- **安全性：** 消除 $S_2$ 并改用 $t_1$ 将是一个不安全的优化，因为它可能导致使用一个过时的值，从而改变程序的语义。该陈述是保守数据流分析原则的正确应用。\n\n**关于 A 的结论：正确**\n\n**B. 如果过程间 mod/ref 和别名分析证明 callee 既不写入 $a$ 的存储位置也不写入 $b$ 的存储位置（并且没有其他影响它们的副作用），那么调用 $C$ 对 $a * b$ 是透明的，GCSE 可以在 $C$ 之前计算一次 $a * b$ 并在 $C$ 之后重用该值。**\n\n这个陈述描述了一个具有更精确、更强大的程序分析的场景。\n- **假设：** 一个可靠的分析已经证明 `callee` 不会修改 $a$ 和 $b$ 的内存位置。这正是“mod/ref”（修改/引用）分析的目标。\n- **推论：** 在 $C$ 处的调用不修改表达式 $a * b$ 的操作数。\n- **后果：** 该调用对于表达式 $a * b$ 是透明的。该表达式不会被调用杀死。\n- **安全性：** 由于在 $S_1$ 计算的表达式未被调用失效，它在 $S_2$ 点仍然可用。因此，GCSE 是安全的。在 $S_2$ 的计算是冗余的，可以通过重用 $S_1$ 的结果来消除。这是执行昂贵的过程间分析的主要动机。\n\n**关于 B 的结论：正确**\n\n**C. 即使当 $q$ 可能与 $a$ 或 $b$ 别名时，在 $S_1$ 处将调用前 $a * b$ 的值保存到临时变量中并在 $C$ 之后重用它也总是安全的，因为临时变量不受别名影响。**\n\n这个陈述误解了 GCSE 的目标。优化的目的不仅是重用一个值，而是在保留程序语义的同时重用*正确*的值。\n- **逻辑：** 该陈述正确地观察到临时变量 $t_1$ 很可能不被 $q$ 别名。因此，*在* $t_1$ 中的值不会被调用直接改变。\n- **缺陷：** 然而，GCSE 旨在用 $S_1$ 的结果替换计算 $t_2 \\leftarrow a * b$（在调用之后，这将使用可能已修改的 $a$ 和 $b$ 的值）。如果 `callee` 将 $a$ 修改为 $a'$，那么 $t_2$ 的正确值应该是 $a' * b$。而 $t_1$ 中的值是 $a * b$。重用 $t_1$ 来代替 $t_2$ 在语义上是不正确的。只有当操作数的值未改变时，这种转换才是安全的，而在所述条件下这无法保证。该陈述混淆了临时变量存储的安全性与其所持值的语义有效性。\n\n**关于 C 的结论：不正确**\n\n**D. 将代码转换为静态单赋值（SSA）形式并应用全局值编号（GVN）足以在没有别名信息的情况下，在 $C$ 之后重用调用前 $a * b$ 的值。**\n\n这个陈述夸大了标准 SSA 和 GVN 的能力。\n- **SSA 用于标量：** 标准 SSA 形式为*标量*变量的每个定义提供唯一的名称。它本身不模型化内存。变量 $a$ 和 $b$明确指出在内存中。一个将它们视为标量的幼稚 SSA 转换是不健全的。\n- **内存建模：** 为了正确处理内存，必须扩展 SSA（例如，使用内存 SSA）。在这样的模型中，内存状态像一个变量一样在程序中传递。在 $C$ 处的调用将被建模为取调用前的内存状态（$Mem_{in}$）并产生一个调用后的内存状态（$Mem_{out}$）。$S_1$ 处的表达式依赖于从 $Mem_{in}$ 的加载，而 $S_2$ 处的表达式依赖于从 $Mem_{out}$ 的加载。没有别名信息，编译器无法证明从 $Mem_{in}$ 加载 $a$ 等同于从 $Mem_{out}$ 加载 $a$。因此，GVN 将为这两个表达式分配不同的值编号。因此，没有别名分析的标准 SSA/GVN 是不足够的。\n\n**关于 D 的结论：不正确**\n\n**E. 当别名未知时，一种安全的保守近似方法是，对于 GCSE，将 callee 视为相对于 $a$ 和 $b$ 是只读的，从而允许通过在 $C$ 之后重用 $S_1$ 的值来消除 $S_2$。**\n\n这个陈述错误地定义了“保守近似”。\n- **保守与乐观：** 在优化中，保守近似必须假设最坏情况以保证正确性。对于可能产生副作用的操作（如调用 `callee`），最坏情况是它*确实*有副作用，使后续计算失效。假设调用是只读的（即，对 $a$ 和 $b$ 没有副作用）是一种*乐观*的假设。\n- **安全性：** 在信息不足时做出乐观假设本质上是不安全的。如果一个编译器这样做，它将为任何 `callee` 实际上确实修改了 $a$ 或 $b$ 的程序生成不正确的代码。正确的保守方法是假设调用杀死了表达式，如选项 A 所述。\n\n**关于 E 的结论：不正确**\n\n总而言之，陈述 A 和 B 分别正确地描述了在保守分析和精确分析下编译器安全的条件。陈述 C、D 和 E 包含了关于优化安全性、临时变量的语义、SSA 的局限性以及保守近似定义的根本性误解。", "answer": "$$\\boxed{AB}$$", "id": "3643954"}]}