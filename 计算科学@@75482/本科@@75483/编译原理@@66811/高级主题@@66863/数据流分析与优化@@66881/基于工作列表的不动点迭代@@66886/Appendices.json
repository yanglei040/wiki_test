{"hands_on_practices": [{"introduction": "工作列表不动点迭代算法的核心思想是系统性地传播信息直至稳定。一个直观的例子是计算非确定性有限自动机（NFA）中的 $\\epsilon$-闭包，这本质上是一个图的可达性问题。通过这个练习 [@problem_id:3683091]，你可以将该算法应用于寻找从一组初始状态出发，通过任意数量的 $\\epsilon$-转移所能到达的所有状态，从而在熟悉的应用场景中加深对不动点概念的理解。", "problem": "编译器前端将词法识别器建模为嵌入在编译器中间表示 (IR) 中的非确定性有限自动机 (NFA)。IR 节点是与 NFA 状态对应的基本块。在控制流边中，一些是不消耗输入的特殊 $\\epsilon$-转换。一个状态集的 $\\epsilon$-闭包被定义为包含该状态集，并且对于通过零次或多次 $\\epsilon$-转换的可达性是封闭的最小状态集。您将通过将问题视为有限格上的单调数据流分析，并使用基于工作列表的不动点迭代来计算一个 $\\epsilon$-闭包的大小。\n\n设状态集为 $Q=\\{q_0,q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_9,q_{10},q_{11}\\}$。$\\epsilon$-转换（且仅有这些转换）如下：\n- $q_0 \\to q_1$, $q_0 \\to q_2$.\n- $q_1 \\to q_3$.\n- $q_2 \\to q_3$, $q_2 \\to q_4$.\n- $q_3 \\to q_5$.\n- $q_4 \\to q_2$, $q_4 \\to q_6$.\n- $q_5 \\to q_7$.\n- $q_6 \\to q_7$.\n- $q_7 \\to q_8$, $q_7 \\to q_9$.\n- $q_8 \\to q_{10}$.\n- $q_9 \\to q_{10}$, $q_9 \\to q_{11}$.\n- $q_{10}$ 没有出向 $\\epsilon$-转换。\n- $q_{11} \\to q_6$.\n\n此外，还存在一些非-$\\epsilon$的符号标记转换（例如，$q_1 \\xrightarrow{a} q_2$，$q_2 \\xrightarrow{b} q_9$，$q_6 \\xrightarrow{c} q_3$，$q_7 \\xrightarrow{d} q_0$，$q_{10} \\xrightarrow{e} q_4$），但它们不参与 $\\epsilon$-闭包的计算，在下面的计算中必须忽略。\n\n定义初始状态集为 $S_0=\\{q_0,q_4,q_9\\}$。考虑以集合并集为最小上界的幂集格 $\\langle 2^{Q}, \\subseteq \\rangle$。将 $\\epsilon$-闭包计算建模为此格上单调函数的最小不动点，并通过工作列表在概念上实现计算：从包含 $S_0$ 中所有元素的工作列表开始，维护一个初始化为 $S_0$ 的已访问集合，重复地从工作列表中弹出一个状态，对于每个尚未在已访问集合中的出向 $\\epsilon$-后继状态，将其添加到已访问集合并推入工作列表；当工作列表变空时终止。终止时的已访问集合即为 $S_0$ 的 $\\epsilon$-闭包。\n\n使用此公式且仅使用上面列出的 $\\epsilon$-转换， $S_0$ 的 $\\epsilon$-闭包的精确基数是多少？请用一个整数表示您的最终答案。不允许进行四舍五入，也不涉及任何物理单位。", "solution": "问题要求计算给定非确定性有限自动机 (NFA) 中初始状态集 $S_0$ 的 $\\epsilon$-闭包的基数。如上所述，计算将使用基于工作列表的不动点迭代算法来执行。\n\n首先，我们确定问题的形式化组成部分。\n所有状态的集合是 $Q=\\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$。状态总数为 $|Q| = 12$。\n需要计算其闭包的初始状态集是 $S_0 = \\{q_0, q_4, q_9\\}$。\n$\\epsilon$-转换定义了一个有向图 $G=(Q, E)$，其中如果存在从状态 $u$ 到状态 $v$ 的 $\\epsilon$-转换，则存在一条边 $(u, v) \\in E$。边集 $E$ 由以下给出：\n$E = \\{$\n$(q_0, q_1), (q_0, q_2),$\n$(q_1, q_3),$\n$(q_2, q_3), (q_2, q_4),$\n$(q_3, q_5),$\n$(q_4, q_2), (q_4, q_6),$\n$(q_5, q_7),$\n$(q_6, q_7),$\n$(q_7, q_8), (q_7, q_9),$\n$(q_8, q_{10}),$\n$(q_9, q_{10}), (q_9, q_{11}),$\n$(q_{11}, q_6)$\n$\\}$\n非-$\\epsilon$ 转换被明确说明在此计算中应被忽略。\n\n$S_0$ 的 $\\epsilon$-闭包，记作 $\\epsilon\\text{-closure}(S_0)$，是从 $S_0$ 中任意状态出发，通过零次或多次 $\\epsilon$-转换可以到达的所有状态的集合。问题指定了一个工作列表算法来计算这个集合。设 $V$ 为已访问状态的集合（它将成为闭包集），$W$ 为工作列表。\n\n算法流程如下：\n1. 用初始状态集 $S_0$ 初始化已访问集合 $V$ 和工作列表 $W$。\n2. 当工作列表 $W$ 不为空时：\n   a. 从 $W$ 中移除一个状态 $u$。\n   b. 对于每个状态 $v$，若存在从 $u$ 到 $v$ 的 $\\epsilon$-转换：\n      i. 如果 $v$ 不在 $V$ 中：\n         - 将 $v$ 添加到 $V$。\n         - 将 $v$ 添加到 $W$。\n3. 最终的集合 $V$ 就是 $S_0$ 的 $\\epsilon$-闭包。\n\n我们现在追踪该算法的执行过程。从工作列表中处理元素的顺序不影响最终结果，只影响中间步骤的顺序。为了系统地遍历，我们将工作列表视为一个队列（先进先出）。\n\n**初始化：**\n- 已访问集合：$V = \\{q_0, q_4, q_9\\}$\n- 工作列表：$W = [q_0, q_4, q_9]$\n\n**迭代 1：** 从 $W$ 中弹出 $q_0$。\n- $q_0$ 的后继是 $q_1$ 和 $q_2$。\n- $q_1 \\notin V$。将 $q_1$ 添加到 $V$ 和 $W$。\n- $q_2 \\notin V$。将 $q_2$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_9\\}$\n- $W = [q_4, q_9, q_1, q_2]$\n\n**迭代 2：** 从 $W$ 中弹出 $q_4$。\n- $q_4$ 的后继是 $q_2$ 和 $q_6$。\n- $q_2 \\in V$。无操作。\n- $q_6 \\notin V$。将 $q_6$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9\\}$\n- $W = [q_9, q_1, q_2, q_6]$\n\n**迭代 3：** 从 $W$ 中弹出 $q_9$。\n- $q_9$ 的后继是 $q_{10}$ 和 $q_{11}$。\n- $q_{10} \\notin V$。将 $q_{10}$ 添加到 $V$ 和 $W$。\n- $q_{11} \\notin V$。将 $q_{11}$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_1, q_2, q_6, q_{10}, q_{11}]$\n\n**迭代 4：** 从 $W$ 中弹出 $q_1$。\n- $q_1$ 的后继是 $q_3$。\n- $q_3 \\notin V$。将 $q_3$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_9, q_{10}, q_{11}\\}$\n- $W = [q_2, q_6, q_{10}, q_{11}, q_3]$\n\n**迭代 5：** 从 $W$ 中弹出 $q_2$。\n- $q_2$ 的后继是 $q_3$ 和 $q_4$。\n- $q_3 \\in V$。无操作。\n- $q_4 \\in V$。无操作。\n- $W = [q_6, q_{10}, q_{11}, q_3]$\n\n**迭代 6：** 从 $W$ 中弹出 $q_6$。\n- $q_6$ 的后继是 $q_7$。\n- $q_7 \\notin V$。将 $q_7$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_{10}, q_{11}, q_3, q_7]$\n\n**迭代 7：** 从 $W$ 中弹出 $q_{10}$。\n- $q_{10}$ 没有出向 $\\epsilon$-转换。\n- $W = [q_{11}, q_3, q_7]$\n\n**迭代 8：** 从 $W$ 中弹出 $q_{11}$。\n- $q_{11}$ 的后继是 $q_6$。\n- $q_6 \\in V$。无操作。\n- $W = [q_3, q_7]$\n\n**迭代 9：** 从 $W$ 中弹出 $q_3$。\n- $q_3$ 的后继是 $q_5$。\n- $q_5 \\notin V$。将 $q_5$ 添加到 $V$ 和 $W$。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_9, q_{10}, q_{11}\\}$\n- $W = [q_7, q_5]$\n\n**迭代 10：** 从 $W$ 中弹出 $q_7$。\n- $q_7$ 的后继是 $q_8$ 和 $q_9$。\n- $q_8 \\notin V$。将 $q_8$ 添加到 $V$ 和 $W$。\n- $q_9 \\in V$。无操作。\n- $V = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$\n- $W = [q_5, q_8]$\n\n此时，已访问集合 $V$ 包含从 $q_0$ 到 $q_{11}$ 的所有 $12$ 个状态。算法继续执行直到工作列表为空，但没有新状态可以添加到 $V$ 中。\n\n**迭代 11：** 从 $W$ 中弹出 $q_5$。\n- $q_5$ 的后继是 $q_7$。\n- $q_7 \\in V$。无操作。\n- $W = [q_8]$\n\n**迭代 12：** 从 $W$ 中弹出 $q_8$。\n- $q_8$ 的后继是 $q_{10}$。\n- $q_{10} \\in V$。无操作。\n- $W = []$\n\n**终止：**\n工作列表 $W$ 现在为空。算法终止。最终的已访问集合就是 $S_0$ 的 $\\epsilon$-闭包。\n$\\epsilon\\text{-closure}(S_0) = V_{final} = \\{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_8, q_9, q_{10}, q_{11}\\}$。\n这是完整的状态集 $Q$。\n\n问题要求计算该集合的基数。\n$|\\epsilon\\text{-closure}(S_0)| = |Q| = 12$。\n\n或者，我们可以更直接地从可达性角度进行推理。$S_0$ 的 $\\epsilon$-闭包是其单个元素闭包的并集：$\\epsilon\\text{-closure}(S_0) = \\bigcup_{s \\in S_0} \\epsilon\\text{-closure}(\\{s\\})$。我们只需要在 $S_0$ 中找到一个可以到达所有状态的元素。\n我们来分析从 $q_0 \\in S_0$ 出发的可达性：\n- $q_0 \\to \\{q_1, q_2\\}$\n- 从 $\\{q_1, q_2\\} \\to \\{q_3, q_4\\}$\n- 从 $\\{q_3, q_4\\} \\to \\{q_5, q_2, q_6\\}$\n- 从 $\\{q_5, q_6\\} \\to \\{q_7\\}$\n- 从 $\\{q_7\\} \\to \\{q_8, q_9\\}$\n- 从 $\\{q_8, q_9\\} \\to \\{q_{10}, q_{11}\\}$\n- 从 $\\{q_{11}\\} \\to \\{q_6\\}$\n通过这些路径，很明显所有状态 $q_1, \\dots, q_{11}$ 都可以从 $q_0$ 到达。根据定义，$\\{q_0\\}$ 的闭包包含 $q_0$ 本身，因此 $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$。\n因为 $\\epsilon\\text{-closure}(S_0) = \\epsilon\\text{-closure}(\\{q_0\\}) \\cup \\epsilon\\text{-closure}(\\{q_4\\}) \\cup \\epsilon\\text{-closure}(\\{q_9\\})$，并且 $\\epsilon\\text{-closure}(\\{q_0\\}) = Q$，所以其并集结果也必定是 $Q$。\n因此，$S_0$ 的 $\\epsilon$-闭包的基数就是 $Q$ 的基数，即 $12$。", "answer": "$$\n\\boxed{12}\n$$", "id": "3683091"}, {"introduction": "不动点迭代不仅限于传播已知值，它还能用于解决复杂的程序分析问题，例如指针分析。在处理函数指针等间接调用时，我们需要确定指针可能指向的目标函数集合，以构建精确的控制流图（CFG）。这个练习 [@problem_id:3683055] 将指导你使用工作列表算法，通过求解一组流不敏感的约束，来计算指针的指向集，并最终精确化CFG中的调用边。", "problem": "考虑一个程序的控制流图（CFG）的静态构建，该程序包含通过函数指针进行的间接调用。为在任何分析前确保健全性，首先将从每个间接调用点到已知函数全集中的所有函数的动态边物化为顶边（top edges）。然后，通过在指向关系格（points-to lattice）上进行基于工作列表（worklist）的不动点迭代来精化这些边。\n\n设可能的目标函数全集为有限集 $U = \\{ f_{1}, f_{2}, f_{3}, f_{4}, f_{5}, f_{6} \\}$。该程序使用三个指针变量 $p$、$q$ 和 $r$，并具有以下全程序、流不敏感（flow-insensitive）的约束（即，赋值可能发生在任何控制流路径上，并且所有赋值都会被累积）：\n- $p := f_1$\n- $q := f_2$\n- $r := f_3$\n- $q := r$\n- $p := q$\n\n程序中恰好有两个间接调用点：\n- $c_{p}$：通过 $p$ 进行的间接调用（表示为 $(*p)()$）。\n- $c_{q}$：通过 $q$ 进行的间接调用（表示为 $(*q)()$）。\n\n使用由 $\\subseteq$ 排序的幂集格 $\\mathcal{P}(U)$ 来建模指向信息，其底（bottom）为 $\\varnothing$，顶（top）为 $U$。每个赋值在该格上引发一个单调传递：\n- 对于 $v := f_i$，约束为 $\\mathrm{PTS}(v) \\supseteq \\{ f_i \\}$。\n- 对于 $v := w$，约束为 $\\mathrm{PTS}(v) \\supseteq \\mathrm{PTS}(w)$。\n\n工作列表算法将所有 $\\mathrm{PTS}(v)$ 初始化为 $\\varnothing$，并迭代地应用这些单调传递，直到达到不动点。独立地，每个间接调用点开始时都具有到 $U$ 中所有目标的顶边，然后丢弃到任何不在该调用点收敛的 $\\mathrm{PTS}$ 集合中的函数 $f \\in U$ 的边。\n\n基于以上定义和事实：\n- 关于完备格上单调函数的 Tarski 不动点定理。\n- 用于有限格上数据流分析的标准工作列表算法。\n- 上文给出的传递函数的语义。\n\n推导出收敛后的指向集 $\\mathrm{PTS}(p)$ 和 $\\mathrm{PTS}(q)$，然后计算精化后的控制流图中存在的精确间接调用边的总数。按调用点计数边，即，如果一个函数 $f$ 同时是 $c_{p}$ 和 $c_{q}$ 的目标，它对总数贡献 2 条边。\n\n将最终答案表示为一个不带单位的整数。无需四舍五入。", "solution": "问题要求我们确定在一个流不敏感的指向分析收敛后，从两个间接调用点出发的控制流边的总数。该分析通过在幂集格上进行基于工作列表的不动点迭代来执行。\n\n首先，我们对问题进行形式化。函数全集为集合 $U = \\{ f_1, f_2, f_3, f_4, f_5, f_6 \\}$。分析在完备格 $(\\mathcal{P}(U), \\subseteq)$ 上进行，其中 $\\mathcal{P}(U)$ 是 $U$ 的幂集，$\\subseteq$ 是子集包含运算符。该格的底元素是空集 $\\varnothing$，顶元素是集合 $U$。需要跟踪指向信息的变量是 $p$、$q$ 和 $r$。它们的指向集分别表示为 $\\mathrm{PTS}(p)$、$\\mathrm{PTS}(q)$ 和 $\\mathrm{PTS}(r)$。\n\n程序的约束是流不敏感的，可以建模为一个在不动点处必须成立的集合包含方程组。问题陈述中给出的传递函数将程序的赋值语句转换为以下约束：\n1.  从 $p := f_1$，我们推导出约束：$\\mathrm{PTS}(p) \\supseteq \\{ f_1 \\}$。\n2.  从 $q := f_2$，我们推导出约束：$\\mathrm{PTS}(q) \\supseteq \\{ f_2 \\}$。\n3.  从 $r := f_3$，我们推导出约束：$\\mathrm{PTS}(r) \\supseteq \\{ f_3 \\}$。\n4.  从 $q := r$，我们推导出约束：$\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r)$。\n5.  从 $p := q$，我们推导出约束：$\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q)$。\n\n工作列表算法从最小解开始，其中所有指向集都初始化为格的底元素 $\\varnothing$：\n$\\mathrm{PTS}(p) = \\varnothing$\n$\\mathrm{PTS}(q) = \\varnothing$\n$\\mathrm{PTS}(r) = \\varnothing$\n\n然后，算法迭代地应用这些约束（对应于格上的单调函数），直到没有指向集可以被进一步扩大。由于格是有限的且函数是单调的，这个过程保证会终止并找到最小不動点。让我们追踪满足所有五个约束的最小解的迭代计算过程。\n\n我们可以通过迭代传播信息来求解这个系统，直到达到一个稳定状态（不动点）。\n\n初始时：\n$\\mathrm{PTS}(p) = \\varnothing$\n$\\mathrm{PTS}(q) = \\varnothing$\n$\\mathrm{PTS}(r) = \\varnothing$\n\n应用‘取地址’约束（1、2、3），它们构成了分析的基础：\n$\\mathrm{PTS}(p) = \\{f_1\\}$\n$\\mathrm{PTS}(q) = \\{f_2\\}$\n$\\mathrm{PTS}(r) = \\{f_3\\}$\n\n现在，我们根据复制约束（4、5）来传播这些集合。\n应用约束 4：$\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r)$。\n当前的 $\\mathrm{PTS}(q)$ 必须更新以包含当前 $\\mathrm{PTS}(r)$ 中的元素。\n新的 $\\mathrm{PTS}(q) = \\mathrm{PTS}(q) \\cup \\mathrm{PTS}(r) = \\{ f_2 \\} \\cup \\{ f_3 \\} = \\{ f_2, f_3 \\}$。\n此时集合为：\n$\\mathrm{PTS}(p) = \\{ f_1 \\}$\n$\\mathrm{PTS}(q) = \\{ f_2, f_3 \\}$\n$\\mathrm{PTS}(r) = \\{ f_3 \\}$\n\n应用约束 5：$\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q)$。\n当前的 $\\mathrm{PTS}(p)$ 必须更新以包含当前 $\\mathrm{PTS}(q)$ 中的元素。\n新的 $\\mathrm{PTS}(p) = \\mathrm{PTS}(p) \\cup \\mathrm{PTS}(q) = \\{ f_1 \\} \\cup \\{ f_2, f_3 \\} = \\{ f_1, f_2, f_3 \\}$。\n此时集合为：\n$\\mathrm{PTS}(p) = \\{ f_1, f_2, f_3 \\}$\n$\\mathrm{PTS}(q) = \\{ f_2, f_3 \\}$\n$\\mathrm{PTS}(r) = \\{ f_3 \\}$\n\n此时，我们必须检查进一步的迭代是否会改变任何集合。\n- 约束 1：$\\mathrm{PTS}(p) = \\{ f_1, f_2, f_3 \\} \\supseteq \\{ f_1 \\}$。（满足）\n- 约束 2：$\\mathrm{PTS}(q) = \\{ f_2, f_3 \\} \\supseteq \\{ f_2 \\}$。（满足）\n- 约束 3：$\\mathrm{PTS}(r) = \\{ f_3 \\} \\supseteq \\{ f_3 \\}$。（满足）\n- 约束 4：$\\mathrm{PTS}(q) \\supseteq \\mathrm{PTS}(r) \\implies \\{ f_2, f_3 \\} \\supseteq \\{ f_3 \\}$。（满足）\n- 约束 5：$\\mathrm{PTS}(p) \\supseteq \\mathrm{PTS}(q) \\implies \\{ f_1, f_2, f_3 \\} \\supseteq \\{ f_2, f_3 \\}$。（满足）\n\n由于所有约束都已满足，并且在满足‘取地址’约束的同时，没有集合可以变得更小，因此这些是满足该系统的最小集合。因此，我们已经达到了最小不动点。收敛后的指向集为：\n- $\\mathrm{PTS}(p) = \\{ f_1, f_2, f_3 \\}$\n- $\\mathrm{PTS}(q) = \\{ f_2, f_3 \\}$\n\n问题的第二部分是计算精化后的控制流图（CFG）中的边数。精化规则指出，对于通过指针 $v$ 的间接调用点，最终的调用边集包含一条指向收敛集 $\\mathrm{PTS}(v)$ 中每个函数 $f$ 的边。\n\n程序包含两个间接调用点：\n1.  $c_{p}$：通过指针 $p$ 的间接调用。此调用的目标是 $\\mathrm{PTS}(p)$ 中的函数。从此调用点出发的边数为 $|\\mathrm{PTS}(p)|$。\n2.  $c_{q}$：通过指针 $q$ 的间接调用。此调用的目标是 $\\mathrm{PTS}(q)$ 中的函数。从此调用点出发的边数为 $|\\mathrm{PTS}(q)|$。\n\n使用我们推导出的收敛集：\n- 从 $c_{p}$ 出发的边数 = $|\\mathrm{PTS}(p)| = |\\{ f_1, f_2, f_3 \\}| = 3$。\n- 从 $c_{q}$ 出发的边数 = $|\\mathrm{PTS}(q)| = |\\{ f_2, f_3 \\}| = 2$。\n\n精确间接调用边的总数是每个调用点边数的总和。\n总边数 = $|\\mathrm{PTS}(p)| + |\\mathrm{PTS}(q)| = 3 + 2 = 5$。", "answer": "$$\\boxed{5}$$", "id": "3683055"}, {"introduction": "常量传播是编译器优化中的一项核心技术，而基于工作列表的不动点迭代是实现它的经典方法。此练习 [@problem_id:3683107] 提供了一个在静态单赋值（SSA）形式上进行常量传播的场景，你需要在一个三层格（$\\bot$, 整数, $\\top$）上，通过细致地追踪先进先出（FIFO）工作列表的每一步操作，来模拟值的传播与汇聚过程。这个过程将让你深刻体会到算法在处理不同类型指令（如常量定义、算术运算和 $\\phi$ 函数）时的具体行为和最终的收敛状态。", "problem": "考虑将前向常量传播形式化为对每个静态单赋值 (SSA) 名称的三层格上的单调数据流分析。每个 SSA 值 $V$ 的格为 $L = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其偏序关系为：对于任意整数 $n \\in \\mathbb{Z}$，有 $\\bot \\leq n \\leq \\top$，且不同的整数除了通过 $\\top$ 之外是不可比较的。并运算符 $\\sqcup$ 满足：对于任意 $x \\in L$，有 $x \\sqcup \\bot = x$；对于任意整数 $m, n \\in \\mathbb{Z}$，如果 $m = n$，则 $m \\sqcup n = m$，如果 $m \\neq n$，则 $m \\sqcup n = \\top$；对于任意 $x \\in L$，有 $x \\sqcup \\top = \\top$。转换函数对于此格是单调的，并定义如下：\n- 对于常量定义 $v := \\text{Const}(k)$，其中 $k \\in \\mathbb{Z}$，转换结果为 $k$。\n- 对于加法 $v := \\text{add}(u, w)$，如果 $Val[u]$ 和 $Val[w]$ 都是整数，则转换结果为 $Val[u] + Val[w]$；如果 $Val[u] = \\bot$ 或 $Val[w] = \\bot$，则转换结果为 $\\bot$；否则，结果为 $\\top$。\n- 对于 phi 节点 $v := \\phi(u, w)$，转换结果为 $Val[u] \\sqcup Val[w]$。\n\n使用标准的先进先出 (FIFO) 工作列表算法。初始时，对于每个 SSA 名称 $v$，$Val[v] = \\bot$。工作列表按照下面给出的确切顺序使用 SSA 定义进行初始化。当一个 SSA 名称 $n$ 出队时，使用当前的 $Val[\\cdot]$ 对其右侧进行求值，以产生一个候选值 $new$。如果 $new \\neq Val[n]$，则设置 $Val[n] := new$，并将 $n$ 的所有使用者按照下面“使用者”映射中列出的顺序加入工作列表的末尾（允许重复）。当工作列表为空时，算法终止。\n\nSSA 片段及其定义-使用关系如下：\n- 定义 (每个定义一个唯一的 SSA 名称)：\n  1. $c := \\text{Const}(4)$\n  2. $d := \\text{Const}(9)$\n  3. $e := \\text{add}(c, c)$\n  4. $y := \\phi(c, c)$\n  5. $b := \\phi(e, d)$\n  6. $a := \\phi(c, b)$\n  7. $x := \\phi(y, d)$\n  8. $f := \\text{add}(x, a)$\n- 使用者映射 (对于每个 SSA 名称，当其更新时需要入队的使用者列表，顺序完全如下)：\n  - $c$：使用者 $e, y, a$\n  - $d$：使用者 $b, x$\n  - $e$：使用者 $b$\n  - $y$：使用者 $x$\n  - $b$：使用者 $a$\n  - $a$：使用者 $f$\n  - $x$：使用者 $f$\n  - $f$：无使用者\n- 初始工作列表顺序 (从前到后)：$[x, a, b, y, e, f, c, d]$。\n\n从所有 SSA 名称的 $Val[\\cdot] = \\bot$ 开始，使用上述转换函数运行基于 FIFO 工作列表的不动点迭代。计算直到算法达到不动点且工作列表变为空时所执行的出队（工作列表弹出操作）总次数。以单个整数形式给出你的答案，不带单位。无需四舍五入。", "solution": "### 解答\n\n我们追踪 FIFO 工作列表算法的执行过程。设 $W$ 为工作列表，$D$ 为出队计数。状态维护在映射 $Val[\\cdot]$ 中。初始时，对于所有 SSA 名称 $v \\in \\{a, b, c, d, e, f, x, y\\}$，有 $Val[v] = \\bot$，$D=0$，且 $W = [x, a, b, y, e, f, c, d]$。\n\n1.  将 $x$ 出队。$D=1$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[x] = \\bot$。无更新。$W = [a, b, y, e, f, c, d]$。\n2.  将 $a$ 出队。$D=2$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[a] = \\bot$。无更新。$W = [b, y, e, f, c, d]$。\n3.  将 $b$ 出队。$D=3$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[b] = \\bot$。无更新。$W = [y, e, f, c, d]$。\n4.  将 $y$ 出队。$D=4$。$y := \\phi(c, c)$。我们计算 $Val[c] \\sqcup Val[c] = \\bot \\sqcup \\bot = \\bot$。这等于当前的 $Val[y] = \\bot$。无更新。$W = [e, f, c, d]$。\n5.  将 $e$ 出队。$D=5$。$e := \\text{add}(c, c)$。由于 $Val[c]=\\bot$，转换函数的结果为 $\\bot$。这等于当前的 $Val[e] = \\bot$。无更新。$W = [f, c, d]$。\n6.  将 $f$ 出队。$D=6$。$f := \\text{add}(x, a)$。由于 $Val[x]=\\bot$ (或 $Val[a]=\\bot$)，转换函数的结果为 $\\bot$。这等于当前的 $Val[f] = \\bot$。无更新。$W = [c, d]$。\n7.  将 $c$ 出队。$D=7$。$c := \\text{Const}(4)$。新值为 $4$。这不同于 $Val[c] = \\bot$。更新 $Val[c] := 4$。将 $c$ 的使用者入队：$e, y, a$。$W = [d, e, y, a]$。\n8.  将 $d$ 出队。$D=8$。$d := \\text{Const}(9)$。新值为 $9$。这不同于 $Val[d] = \\bot$。更新 $Val[d] := 9$。将 $d$ 的使用者入队：$b, x$。$W = [e, y, a, b, x]$。\n9.  将 $e$ 出队。$D=9$。$e := \\text{add}(c, c)$。我们计算 $Val[c] + Val[c] = 4 + 4 = 8$。这不同于 $Val[e] = \\bot$。更新 $Val[e] := 8$。将 $e$ 的使用者入队：$b$。$W = [y, a, b, x, b]$。\n10. 将 $y$ 出队。$D=10$。$y := \\phi(c, c)$。我们计算 $Val[c] \\sqcup Val[c] = 4 \\sqcup 4 = 4$。这不同于 $Val[y] = \\bot$。更新 $Val[y] := 4$。将 $y$ 的使用者入队：$x$。$W = [a, b, x, b, x]$。\n11. 将 $a$ 出队。$D=11$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = 4 \\sqcup \\bot = 4$。这不同于 $Val[a] = \\bot$。更新 $Val[a] := 4$。将 $a$ 的使用者入队：$f$。$W = [b, x, b, x, f]$。\n12. 将 $b$ 出队。$D=12$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$（因为 $8 \\neq 9$）。这不同于 $Val[b] = \\bot$。更新 $Val[b] := \\top$。将 $b$ 的使用者入队：$a$。$W = [x, b, x, f, a]$。\n13. 将 $x$ 出队。$D=13$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$（因为 $4 \\neq 9$）。这不同于 $Val[x] = \\bot$。更新 $Val[x] := \\top$。将 $x$ 的使用者入队：$f$。$W = [b, x, f, a, f]$。\n14. 将 $b$ 出队。$D=14$。$b := \\phi(e, d)$。我们计算 $Val[e] \\sqcup Val[d] = 8 \\sqcup 9 = \\top$。这等于当前的 $Val[b] = \\top$。无更新。$W = [x, f, a, f]$。\n15. 将 $x$ 出队。$D=15$。$x := \\phi(y, d)$。我们计算 $Val[y] \\sqcup Val[d] = 4 \\sqcup 9 = \\top$。这等于当前的 $Val[x] = \\top$。无更新。$W = [f, a, f]$。\n16. 将 $f$ 出队。$D=16$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=4$。由于 $Val[x]$ 不是整数，转换函数的结果为 $\\top$。这不同于 $Val[f] = \\bot$。更新 $Val[f] := \\top$。没有 $f$ 的使用者需要入队。$W = [a, f]$。\n17. 将 $a$ 出队。$D=17$。$a := \\phi(c, b)$。我们计算 $Val[c] \\sqcup Val[b] = 4 \\sqcup \\top = \\top$。这不同于 $Val[a] = 4$。更新 $Val[a] := \\top$。将 $a$ 的使用者入队：$f$。$W = [f, f]$。\n18. 将 $f$ 出队。$D=18$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=\\top$。由于一个或两个输入不是整数，转换函数的结果为 $\\top$。这等于当前的 $Val[f] = \\top$。无更新。$W = [f]$。\n19. 将 $f$ 出队。$D=19$。$f := \\text{add}(x, a)$。当前值为 $Val[x]=\\top$ 和 $Val[a]=\\top$。转换函数的结果为 $\\top$。这等于当前的 $Val[f] = \\top$。无更新。$W = []$。\n\n工作列表现在为空。算法终止。出队总数为 $19$。\n最终状态是：\n$Val[a] = \\top$\n$Val[b] = \\top$\n$Val[c] = 4$\n$Val[d] = 9$\n$Val[e] = 8$\n$Val[f] = \\top$\n$Val[x] = \\top$\n$Val[y] = 4$\n\n问题要求执行的出队总次数。根据追踪过程，这个数字是 $19$。", "answer": "$$\n\\boxed{19}\n$$", "id": "3683107"}]}