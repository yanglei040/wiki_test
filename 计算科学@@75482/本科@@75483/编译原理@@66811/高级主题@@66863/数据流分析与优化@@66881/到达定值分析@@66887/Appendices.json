{"hands_on_practices": [{"introduction": "任何数据流分析都始于对单个基本块的分析，而这又依赖于精确定义 $GEN$ 和 $KILL$ 集合。这个练习通过一个看似简单的自赋值语句 $x = x$，挑战我们对“定值”和“杀死”这两个核心概念的理解，为后续更复杂的分析打下坚实的基础。[@problem_id:3665861]", "problem": "在经典的、用于无指针或别名的指令式程序的到达定值正向位向量数据流问题中，一个定值是对变量的任何赋值。考虑以下带有标记赋值点的程序片段，其中每个标记表示一个唯一的定值点：\n- $d_{1}$: $x = 1$\n- $d_{2}$: $y = x$\n- $d_{3}$: $x = y$\n- $d_{4}$: $z = 0$\n- $d_{5}$: $x = x$\n- $d_{6}$: $x = z$\n- $d_{7}$: $w = x$\n- $d_{8}$: $x = 3$\n\n设 $B$ 是一个基本块，它仅包含语句 $d_{5}$（即自赋值 $x = x$）。使用在按变量名杀死语义（无别名且无间接引用）下到达定值的生成集 $\\mathrm{GEN}[B]$ 和杀死集 $\\mathrm{KILL}[B]$ 的标准定义，确定自赋值 $x = x$ 是否杀死了先前对 $x$ 的定值，以及它是否为 $x$ 生成了一个新的定值点。然后，计算基数\n$$\\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right|$$\n的值。\n\n请以单个整数形式提供最终答案。无需四舍五入，也不涉及物理单位。", "solution": "该问题是有效的。在编译原理中数据流分析的既定形式框架内，这是一个定义明确的问题。所有术语都是标准的且定义清晰，前提条件是一致的。\n\n该问题要求我们在到达定值分析的背景下，确定特定基本块 $B$ 的生成集 $\\mathrm{GEN}[B]$ 和杀死集 $\\mathrm{KILL}[B]$。到达定值是一个正向数据流问题，它旨在确定在程序的每个点上，哪些定值（即对变量的赋值）可能是最后一个定义该变量值的定值。\n\n首先，我们形式化基本块 $B$ 的 $\\mathrm{GEN}$ 集和 $\\mathrm{KILL}$ 集的定义。设 $D$ 是整个程序中所有定值点的集合。\n- 生成集 $\\mathrm{GEN}[B]$ 是基本块 $B$ 内部到达 $B$ 末尾的定值的集合。如果 $B$ 内部的定值 $d: v = \\dots$ 之后没有对同一变量 $v$ 的后续定值，则该定值到达 $B$ 的末尾。\n- 杀死集 $\\mathrm{KILL}[B]$ 是整个程序中（但在 $B$ 之外）被 $B$ 内部一个或多个定值杀死的定值的集合。如果定值 $d': v = \\dots$ 和定值 $d: v = \\dots$ 都对同一变量 $v$ 赋值，则前者被后者杀死。\n\n问题给出了程序中 8 个唯一的定值点集合：\n$D = \\{d_{1}, d_{2}, d_{3}, d_{4}, d_{5}, d_{6}, d_{7}, d_{8}\\}$。\n这些定值是：\n- $d_{1}: x = 1$\n- $d_{2}: y = x$\n- $d_{3}: x = y$\n- $d_{4}: z = 0$\n- $d_{5}: x = x$\n- $d_{6}: x = z$\n- $d_{7}: w = x$\n- $d_{8}: x = 3$\n\n基本块 $B$ 由单个语句 $d_{5}: x = x$ 组成。\n\n我们现在计算 $\\mathrm{GEN}[B]$。\n基本块 $B$ 只包含一个定值 $d_{5}$。由于 $B$ 中没有后续语句，这个定值在块内不会被取代。因此，定值 $d_{5}$ 到达基本块 $B$ 的末尾。这意味着 $d_{5}$ 由 $B$ 生成。\n因此，生成集为：\n$$ \\mathrm{GEN}[B] = \\{d_{5}\\} $$\n自赋值 $d_{5}: x=x$ 确实为 $x$ 生成了一个新的定值点。赋的值无关紧要；对变量 $x$ 进行赋值的行为本身就创建了一个新的定值。\n\n接下来，我们计算 $\\mathrm{KILL}[B]$。\n基本块 $B$ 中的定值 $d_{5}$ 是对变量 $x$ 的赋值。根据“按变量名杀死”的语义，这个定值会杀死程序中所有其他对变量 $x$ 的定值。\n首先，我们必须识别出整个程序中所有对变量 $x$ 的定值。它们是：\n- $d_{1}: x = 1$\n- $d_{3}: x = y$\n- $d_{5}: x = x$\n- $d_{6}: x = z$\n- $d_{8}: x = 3$\n$x$ 的所有定值的集合是 $\\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\}$。\n基本块 $B$ 中的定值 $d_{5}$ 杀死了所有其他对 $x$ 的定值。对 $x$ 的其他定值是 $\\{d_{1}, d_{3}, d_{6}, d_{8}\\}$。这些定值是在所有程序定值 $D$ 的集合中，但不是 $d_{5}$ 本身。根据定义，$\\mathrm{KILL}[B]$ 集包含来自 $B$ *外部*的定值。由于 $d_{5}$ 是 $B$ 内部唯一的定值，被 $B$ 杀死的定值集恰好就是这个对 $x$ 的其他定值的集合。一个定值不会杀死自己（即不会出现在 KILL 集中）。\n因此，杀死集为：\n$$ \\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{6}, d_{8}\\} $$\n这证实了赋值 $d_5: x=x$ 杀死了先前对 $x$ 的定值。\n\n问题要求计算这两个集合的并集的基数：$|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]|$。\n我们有：\n- $\\mathrm{GEN}[B] = \\{d_{5}\\}$\n- $\\mathrm{KILL}[B] = \\{d_{1}, d_{3}, d_{6}, d_{8}\\}$\n\n根据它们的定义，$\\mathrm{GEN}[B]$ 包含来自基本块 $B$ 内部的定值，而 $\\mathrm{KILL}[B]$ 包含来自基本块 $B$ 外部的定值。因此，这两个集合是不相交的：\n$$ \\mathrm{GEN}[B] \\cap \\mathrm{KILL}[B] = \\emptyset $$\n\n这两个集合的并集是：\n$$ \\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B] = \\{d_{5}\\} \\cup \\{d_{1}, d_{3}, d_{6}, d_{8}\\} = \\{d_{1}, d_{3}, d_{5}, d_{6}, d_{8}\\} $$\n\n一个集合的基数是它所包含元素的数量。由于这两个集合不相交，并集的基数是各个集合基数的和：\n$$ \\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right| = |\\mathrm{GEN}[B]| + |\\mathrm{KILL}[B]| $$\n各个集合的基数是：\n- $|\\mathrm{GEN}[B]| = 1$\n- $|\\mathrm{KILL}[B]| = 4$\n\n因此，并集的基数是：\n$$ \\left|\\mathrm{GEN}[B] \\cup \\mathrm{KILL}[B]\\right| = 1 + 4 = 5 $$\n最终值为 $5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3665861"}, {"introduction": "在掌握了基本块的分析后，我们将目光投向完整的控制流图。这个练习要求我们应用迭代算法，在一个包含循环的程序中计算到达定值，直到达到不动点。通过移除一条边使得部分代码不可达，本题进一步揭示了数据流分析如何精确反映程序执行路径的变化。[@problem_id:3665885]", "problem": "考虑以下一个小型控制流图（CFG），它用于一个单过程程序，该程序操作单个变量 $x$。变量 $x$ 在循环头中用于控制迭代。基本块标记为 $B_0$ 到 $B_6$，边被明确列出。所有对 $x$ 的赋值都是不同的定义。每个基本块的伪代码如下：\n- $B_0$：入口；无条件跳转到 $B_1$。\n- $B_1$：如果 $c_1$ 则跳转到 $B_2$，否则跳转到 $B_5$。\n- $B_2$：$x := 10$；跳转到 $B_3$。\n- $B_3$：当 $(x  n)$ 时跳转到 $B_4$，否则跳转到 $B_6$；这是使用 $x$ 的循环头。\n- $B_4$：$x := x + 1$；跳转到 $B_3$。\n- $B_5$：$x := 20$；跳转到 $B_3$。\n- $B_6$：出口。\n\n设 $x$ 的三个不同定义分别表示为 $B_2$ 处的 $d_2$，$B_4$ 处的 $d_4$，以及 $B_5$ 处的 $d_5$。假设在此控制流图上进行标准的向前、may（集合并集）到达定值分析，并采用通常的解释：如果从一个定义点到某个程序点存在一条路径，且在该路径上该变量未被重新定义，则该定义到达该程序点。使用常规的块局部集合 $GEN[b]$ 和 $KILL[b]$ 以及到达定值分析的标准数据流方程，并假设对于 $x$ 的一个定义，其 $KILL$ 集合包含程序中所有其他对 $x$ 的定义（无论可达性如何）。假设 $IN[B_0] = \\varnothing$。\n\n任务：\n- 首先，分析上述原始控制流图，并确定在稳态（不动点）下，$d_2$、$d_4$ 和 $d_5$ 中有哪些到达循环头 $B_3$。\n- 接下来，通过删除从 $B_1$ 到 $B_5$ 的边使得 $B_5$ 不可达（这样 $B_1$ 现在只有到 $B_2$ 的边），并保持所有其他块和边不变。在此修改后的控制流图中，重新进行到达定值分析，并确定在稳态下，$d_2$、$d_4$ 和 $d_5$ 中有哪些到达循环头 $B_3$。\n- 令 $\\kappa$ 表示在修改后的控制流图中（在 $B_5$ 变得不可达之后）集合 $IN[B_3]$ 的基数。将 $\\kappa$ 作为最终答案报告。无需四舍五入。请以精确整数形式表示您的答案。", "solution": "该问题要求对给定的控制流图（CFG）及其修改版本执行到达定值分析。这是编译器理论中一个标准的前向、“may”分析问题。其目标是确定对于一个给定的程序点，可能到达该点的定义的集合。\n\n到达定值分析的数据流方程如下：\n$$IN[b] = \\bigcup_{p \\in pred(b)} OUT[p]$$\n$$OUT[b] = GEN[b] \\cup (IN[b] \\setminus KILL[b])$$\n其中 $IN[b]$ 是到达基本块 $b$ 入口的定义集合，$OUT[b]$ 是到达 $b$ 出口的定义集合，$pred(b)$ 是 $b$ 的前驱节点集合，$GEN[b]$ 是在 $b$ 内部生成的定义集合，$KILL[b]$ 是程序中被 $b$ 内部的定义所杀死的定义集合。分析过程通过迭代应用这些方程直到达到不动点（即 $IN$ 和 $OUT$ 集合不再变化）。\n\n程序中所有定义的集合是 $D = \\{d_2, d_4, d_5\\}$，分别对应于块 $B_2$、$B_4$ 和 $B_5$ 中对变量 $x$ 的赋值。\n\n首先，我们为每个基本块建立 $GEN$ 和 $KILL$ 集合。一个包含 $x$ 定义的块 $b$ 会生成该定义。这一定义会杀死程序中所有其他对 $x$ 的定义。\n- $B_0$：无定义。$GEN[B_0] = \\varnothing$，$KILL[B_0] = \\varnothing$。\n- $B_1$：无定义。$GEN[B_1] = \\varnothing$，$KILL[B_1] = \\varnothing$。\n- $B_2$：包含定义 $d_2$ ($x := 10$)。$GEN[B_2] = \\{d_2\\}$，$KILL[B_2] = D \\setminus \\{d_2\\} = \\{d_4, d_5\\}$。\n- $B_3$：无定义（仅有使用）。$GEN[B_3] = \\varnothing$，$KILL[B_3] = \\varnothing$。\n- $B_4$：包含定义 $d_4$ ($x := x + 1$)。$GEN[B_4] = \\{d_4\\}$，$KILL[B_4] = D \\setminus \\{d_4\\} = \\{d_2, d_5\\}$。\n- $B_5$：包含定义 $d_5$ ($x := 20$)。$GEN[B_5] = \\{d_5\\}$，$KILL[B_5] = D \\setminus \\{d_5\\} = \\{d_2, d_4\\}$。\n- $B_6$：无定义。$GEN[B_6] = \\varnothing$，$KILL[B_6] = \\varnothing$。\n\n**原始控制流图分析**\n\n在原始CFG中，循环头 $B_3$ 有三个前驱节点：$B_2$、$B_4$ 和 $B_5$。因此，$IN[B_3] = OUT[B_2] \\cup OUT[B_4] \\cup OUT[B_5]$。我们寻求该集合的稳态值。\n\n1.  存在路径 $B_0 \\to B_1 \\to B_2 \\to B_3$。定义 $d_2$ 在 $B_2$ 中生成，并且在边 $B_2 \\to B_3$ 上未被杀死。因此，$d_2$ 到达 $B_3$ 的入口。在稳态下，$\\{d_2\\} \\subseteq OUT[B_2]$。\n2.  存在路径 $B_0 \\to B_1 \\to B_5 \\to B_3$。定义 $d_5$ 在 $B_5$ 中生成，并且在边 $B_5 \\to B_3$ 上未被杀死。因此，$d_5$ 到达 $B_3$ 的入口。在稳态下，$\\{d_5\\} \\subseteq OUT[B_5]$。\n3.  循环创建了一条路径 $B_3 \\to B_4 \\to B_3$。任何到达 $B_3$ 入口的定义（即在 $IN[B_3]$ 中）都会通过并到达其出口（因为 $KILL[B_3] = \\varnothing$），从而到达 $B_4$ 的入口。在 $B_4$ 中，定义 $d_4$ 被生成，所有其他定义（$d_2, d_5$）被杀死。因此，$OUT[B_4]$ 将包含 $d_4$。这个定义沿着边 $B_4 \\to B_3$ 流回 $B_3$ 的入口。\n\n综合这些，到达 $B_3$ 入口的定义集合是其所有前驱节点到达定义的并集。在不动点处，我们有：\n- $OUT[B_2]$ 包含 $d_2$。\n- $OUT[B_5]$ 包含 $d_5$。\n- $OUT[B_4]$ 包含 $d_4$。\n因此，对于原始CFG，$IN[B_3] = \\{d_2, d_4, d_5\\}$。\n\n**修改后控制流图的分析**\n\n通过删除从 $B_1$ 到 $B_5$ 的边来修改CFG。我们必须重新评估到达循环头 $B_3$ 的定义。\n\n此修改的关键后果是块 $B_5$ 变得不可达。不再有从入口块 $B_0$ 到 $B_5$ 的路径。到达定值的基本定义指出：“如果从一个定义点到某个程序点存在一条路径，则该定义到达该程序点”。这意味着定义本身必须位于从程序入口开始的可执行路径上。由于 $B_5$ 不可达，其中包含的定义 $d_5$ 在程序执行期间永远不会被创建。因此，$d_5$ 无法到达程序中的任何点。\n\n虽然在图结构上盲目应用数据流方程可能会表明 $d_5$ 从孤立的 $B_5$ 块传播出来，但这将是一种误解。分析必须反映程序执行的语义。因此，我们可以有效地从分析中剪除不可达的块 $B_5$ 及其出边 $B_5 \\to B_3$。\n\n在修改并剪枝后的CFG中，$B_3$ 的前驱节点现在是 $pred(B_3) = \\{B_2, B_4\\}$。活跃定义的集合减少到 $\\{d_2, d_4\\}$。分析过程如下：\n- 路径 $B_0 \\to B_1 \\to B_2 \\to B_3$ 不受影响。来自 $B_2$ 的定义 $d_2$ 到达 $B_3$ 的入口。\n- 循环路径 $B_3 \\to B_4 \\to B_3$ 也不受影响。来自 $B_4$ 的定义 $d_4$ 到达 $B_3$ 的入口。\n- 来自 $B_5$ 的路径不再存在。\n\n因此，到达 $B_3$ 入口的定义集合是来自可达前驱节点 $B_2$ 和 $B_4$ 的定义的并集。\n$$IN[B_3] = OUT[B_2] \\cup OUT[B_4]$$\n在不动点处，这解析为：\n$$IN[B_3] = \\{d_2\\} \\cup \\{d_4\\} = \\{d_2, d_4\\}$$\n\n**最终计算**\n\n问题要求计算 $\\kappa$ 的值，它被定义为修改后控制流图中集合 $IN[B_3]$ 的基数。\n$$\\kappa = |IN[B_3]| = |\\{d_2, d_4\\}|$$\n$$\\kappa = 2$$", "answer": "$$\\boxed{2}$$", "id": "3665885"}, {"introduction": "理论模型最终要应用于解决真实代码中的问题。这个练习模拟了 C 语言风格的 $switch-case$ 结构，其特有的“穿透”（fallthrough）行为会产生复杂的控制流路径。我们需要仔细追踪所有可能性，并在汇合点正确地合并数据流信息，从而检验我们在复杂场景下的分析能力。[@problem_id:3665852]", "problem": "给定一个类C语言的代码片段，其中包含一个多路分支，该分支在标记的块之间存在隐式贯穿（fallthrough）。所有变量均为整型。只考虑单一变量 $x$ 的定义（赋值）。代码如下：\n\nint $x$ = $-1$; /* $D_1$ */\nswitch ($s$) {\n  case $0$:\n    if ($u$) { $x$ = $0$; } /* $D_2$ */\n    /* fallthrough */\n  case $1$:\n    $y$ = $x$ + $1$;\n    break;\n  case $2$:\n    $x$ = $20$; /* $D_3$ */\n    /* fallthrough */\n  case $3$:\n    $a$ = $3$;\n    /* fallthrough */\n  case $4$:\n    $x$ = $40$; /* $D_4$ */\n    break;\n  default:\n    if ($v$) { $x$ = $50$; } /* $D_5$ */\n    /* else: no definition of $x$ */\n    /* no break: falls out of the switch */\n}\n$w$ = $x$;\n\n假设使用标准的类C语言的 $switch$ 语义：控制流转移到第一个匹配的标签，在没有 $break$ 的情况下，会顺序执行后续的标签块（如果 $default$ 块在后面，也包括在内），而 $break$ 会退出 $switch$ 语句。谓词 $u$ 和 $v$ 是不确定的布尔值，分析必须在这些语义下保守地考虑所有可行的路径。在紧跟 $switch$ 语句之后的位置（即赋值语句 $w = x$ 之前），对单一变量 $x$ 执行经典的前向“可能到达”定义分析（forward may-reaching-definitions analysis）。\n\n将 $x$ 的五个不同定义按其在程序文本中出现的顺序标识为 $D_1, D_2, D_3, D_4, D_5$，如上面的注释所示。将 $switch$ 出口处 $x$ 的到达定义集编码为一个长度为 $5$ 的位向量，其中第 $i$ 位对应 $D_i$，$D_1$ 映射到最低有效位（权重为 $2^{0}$），$D_5$ 映射到最高有效位（权重为 $2^{4}$）。将此位向量解释为一个以 $2$ 为基数的非负整数。\n\n这个整数是多少？请提供一个精确的整数。无需四舍五入。", "solution": "该问题是有效的，因为它是经典数据流分析中一个定义明确的练习，而数据流分析是编译器理论的核心主题。该问题具有科学依据、客观性，并包含获得唯一解所需的所有信息。\n\n目标是为变量 $x$ 执行前向“可能”到达定义分析。如果从紧随变量 $x$ 的定义 $D$ 之后的位置到程序点 $P$ 存在至少一条控制流路径，并且在这条路径上 $x$ 未被重新定义，那么我们称定义 $D$ 到达了程序点 $P$。我们关心的是到达 `switch` 语句之后那个点的所有此类定义的集合。\n\n设 $x$ 的所有定义的集合为 $\\mathcal{D} = \\{D_1, D_2, D_3, D_4, D_5\\}$。分析通过跟踪程序控制流图中的到达定义集 $RD$ 来进行。\n\n1.  **初始状态**：在 `switch` 语句之前，出现了第一个定义 $D_1: x = -1$。因此，在 `switch` 语句入口处的到达定义集是 $RD_{entry} = \\{D_1\\}$。\n\n2.  **通过 `switch` 的路径分析**：我们必须考虑所有可能的路径，这些路径由 `switch` 变量 $s$ 的值以及不确定的谓词 $u$ 和 $v$ 决定。\n\n    *   **$s=0$ 的路径**：\n        控制流转移到 `case 0`。传入的 $RD$ 集是 $\\{D_1\\}$。\n        程序遇到 `if ($u$) { $x = 0$; }`，即定义 $D_2$。\n        - 如果 $u$ 为真，$D_2$ 被执行。$D_2$ 清除（kill）了 $D_1$（以及 $x$ 的所有其他定义）。$RD$ 集变为 $\\{D_2\\}$。\n        - 如果 $u$ 为假，则跳过 `if` 块，$RD$ 集保持为 $\\{D_1\\}$。\n        由于这是“可能”分析，我们取两个分支结果的并集。在 `if` 语句之后的位置，$RD = \\{D_1\\} \\cup \\{D_2\\} = \\{D_1, D_2\\}$。\n        然后控制流贯穿到 `case 1`。语句 `y = x + 1;` 使用了 $x$ 但没有重新定义它，所以 $RD$ 集不变。\n        `break` 语句被执行，控制流退出 `switch`。\n        因此，通过此路径到达出口的定义集是 $\\{D_1, D_2\\}$。\n\n    *   **$s=1$ 的路径**：\n        控制流转移到 `case 1`。传入的 $RD$ 集是 $\\{D_1\\}$。\n        语句 `y = x + 1;` 没有重新定义 $x$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集是 $\\{D_1\\}$。\n\n    *   **$s=2$ 的路径**：\n        控制流转移到 `case 2`。传入的 $RD$ 集是 $\\{D_1\\}$。\n        定义 $D_3: x = 20$ 被执行，清除了 $D_1$。$RD$ 集变为 $\\{D_3\\}$。\n        控制流贯穿到 `case 3`。语句 `a = 3;` 不影响 $x$，所以 $RD$ 集仍为 $\\{D_3\\}$。\n        控制流贯穿到 `case 4`。定义 $D_4: x = 40$ 被执行，清除了 $D_3$。$RD$ 集变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集是 $\\{D_4\\}$。\n\n    *   **$s=3$ 的路径**：\n        控制流转移到 `case 3`。传入的 $RD$ 集是 $\\{D_1\\}$。\n        语句 `a = 3;` 不影响 $x$。\n        控制流贯穿到 `case 4`。定义 $D_4: x = 40$ 被执行，清除了 $D_1$。$RD$ 集变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集是 $\\{D_4\\}$。\n\n    *   **$s=4$ 的路径**：\n        控制流转移到 `case 4`。传入的 $RD$ 集是 $\\{D_1\\}$。\n        定义 $D_4: x = 40$ 被执行，清除了 $D_1$。$RD$ 集变为 $\\{D_4\\}$。\n        `break` 语句退出 `switch`。\n        因此，通过此路径到达出口的定义集是 $\\{D_4\\}$。\n\n    *   **`default` 的路径**：\n        对于 $s$ 的任何其他值，控制流转移到 `default` 块。传入的 $RD$ 集是 $\\{D_1\\}$。\n        程序遇到 `if ($v$) { $x = 50$; }`，即定义 $D_5$。\n        - 如果 $v$ 为真，$D_5$ 被执行，清除了 $D_1$。$RD$ 集变为 $\\{D_5\\}$。\n        - 如果 $v$ 为假，则跳过 `if` 块，$RD$ 集保持为 $\\{D_1\\}$。\n        在 `if` 之后的合并点，并集为 $RD = \\{D_1\\} \\cup \\{D_5\\} = \\{D_1, D_5\\}$。\n        没有 `break`，所以控制流从 `switch` 中掉出。\n        因此，通过此路径到达出口的定义集是 $\\{D_1, D_5\\}$。\n\n3.  **最终到达定义集**：所有“可能”到达 `switch` 之后程序点的定义的集合是来自 `switch` 语句所有可能入口点的集合的并集。\n    $RD_{exit} = \\underbrace{\\{D_1, D_2\\}}_{s=0} \\cup \\underbrace{\\{D_1\\}}_{s=1} \\cup \\underbrace{\\{D_4\\}}_{s=2} \\cup \\underbrace{\\{D_4\\}}_{s=3} \\cup \\underbrace{\\{D_4\\}}_{s=4} \\cup \\underbrace{\\{D_1, D_5\\}}_{\\text{默认}}$\n    $RD_{exit} = \\{D_1, D_2, D_4, D_5\\}$。\n    注意，定义 $D_3$ 不会到达出口。任何执行 $D_3$ 的路径都必须贯穿到 `case 4`，在那里 $D_4$ 被执行，从而在路径退出 `switch` 之前清除了 $D_3$。\n\n4.  **位向量编码**：题目要求将此集合编码为一个整数。该位向量有 $5$ 位，其中第 $i$ 位（从1开始索引）对应于定义 $D_i$。$D_1$ 是最低有效位（LSB，位置 $0$，权重 $2^0$），$D_5$ 是最高有效位（MSB，位置 $4$，权重 $2^4$）。\n位向量为 $(b_4, b_3, b_2, b_1, b_0)$，其中如果 $D_i \\in RD_{exit}$，则 $b_{i-1}=1$，否则 $b_{i-1}=0$。\n- $D_1 \\in RD_{exit} \\implies b_0 = 1$\n- $D_2 \\in RD_{exit} \\implies b_1 = 1$\n- $D_3 \\notin RD_{exit} \\implies b_2 = 0$\n- $D_4 \\in RD_{exit} \\implies b_3 = 1$\n- $D_5 \\in RD_{exit} \\implies b_4 = 1$\n得到的二进制数为 $11011_2$。\n\n5.  **整数转换**：我们将二进制数转换为其十进制整数表示。\n    值 $= 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$\n    值 $= 16 + 8 + 0 + 2 + 1 = 27$。", "answer": "$$\n\\boxed{27}\n$$", "id": "3665852"}]}