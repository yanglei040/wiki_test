{"hands_on_practices": [{"introduction": "本练习将指导你手动执行一个完整的可用表达式分析。通过在一个给定的控制流图上逐步计算，你将亲身体验数据流信息如何传播直至达到不动点。[@problem_id:3622931] 这个过程是理解任何数据流分析算法如何工作的基础，并能有效锻炼你对$GEN$、$KILL$、$IN$和$OUT$集之间关系的精确把握。", "problem": "考虑对以下具有基本块 $B_1$ 到 $B_7$ 的控制流图 (CFG) 进行可用表达式的前向数据流分析。唯一关注的表达式是 $e = a \\times b$。该程序以三地址码形式表示，并按如下方式划分为基本块（每个项目符号按程序顺序列出一个基本块中的语句）：\n\n- $B_1$: $t_1 := a \\times b$, if $p$ then goto $B_2$ else goto $B_3$.\n- $B_2$: $a := a + 1$, goto $B_4$.\n- $B_3$: $t_2 := a \\times b$, goto $B_4$.\n- $B_4$: if $q$ then goto $B_5$ else goto $B_6$.\n- $B_5$: $b := b + 1$, goto $B_7$.\n- $B_6$: $t_3 := a \\times b$, goto $B_7$.\n- $B_7$: return.\n\n使用可用表达式分析 (AEA) 的标准框架，这是一种前向必达分析，其交汇操作为集合交集。设表达式全集为 $U = \\{ e \\}$，其中 $e$ 是 $a \\times b$ 的缩写。对每个基本块 $B$，定义：\n- 如果 $B$ 计算了 $a \\times b$ 且在 $B$ 内部该计算之后没有对 $a$ 或 $b$ 的赋值，则 $\\mathrm{GEN}_B = \\{ e \\}$；否则 $\\mathrm{GEN}_B = \\varnothing$。\n- 如果 $B$ 在其内部任何位置对 $a$ 或 $b$ 进行了赋值，则 $\\mathrm{KILL}_B = \\{ e \\}$；否则 $\\mathrm{KILL}_B = \\varnothing$。\n\n使用规范的前向传递函数和交汇操作：\n- 对每个基本块 $B$，$ \\mathrm{OUT}[B] = \\mathrm{GEN}_B \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}_B) $。\n- 对每个有前驱节点 $\\mathrm{pred}(B)$ 的基本块 $B$，$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $。\n\n初始化：\n- $ \\mathrm{IN}[B_1] = \\varnothing $。\n- 对于所有 $B \\neq B_1$，$ \\mathrm{IN}[B] = U $。\n\n计算上述方程组在此 CFG 上的最大不动点。令 $N$ 为在不动点处满足 $e \\in \\mathrm{IN}[B]$ 的基本块 $B$ 的数量。将 $N$ 的值以单个整数形式报告。无需四舍五入。", "solution": "该问题定义明确、内容完整，并且在科学上基于编译原理，特别是数据流分析的原则。它提供了控制流图 (CFG)、数据流框架（可用表达式分析）、传递函数、交汇操作和初始化条件的完整说明。因此，该问题是有效的，并且可以推导出解。\n\n任务是为给定 CFG 中的每个基本块 $B$ 计算可用表达式集合 $\\mathrm{IN}[B]$ 和 $\\mathrm{OUT}[B]$ 的最大不动点。关注的表达式是 $e = a \\times b$。表达式全集是 $U = \\{e\\}$。我们将使用迭代算法来求解数据流方程，直到达到不动点。\n\n首先，我们通过识别每个基本块的前驱节点来确定 CFG 的结构：\n- $\\mathrm{pred}(B_1) = \\varnothing$\n- $\\mathrm{pred}(B_2) = \\{B_1\\}$\n- $\\mathrm{pred}(B_3) = \\{B_1\\}$\n- $\\mathrm{pred}(B_4) = \\{B_2, B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_4\\}$\n- $\\mathrm{pred}(B_6) = \\{B_4\\}$\n- $\\mathrm{pred}(B_7) = \\{B_5, B_6\\}$\n\n接下来，我们根据所提供的定义为每个基本块 $B$ 计算 $\\mathrm{GEN}_B$ 和 $\\mathrm{KILL}_B$ 集合。\n- $B_1$: $t_1 := a \\times b$, ...\n  这个块计算 $a \\times b$ 并且之后不修改 $a$ 或 $b$。\n  $\\mathrm{GEN}_{B_1} = \\{e\\}$, $\\mathrm{KILL}_{B_1} = \\varnothing$。\n- $B_2$: $a := a + 1$, ...\n  这个块对 $a$ 进行赋值，而 $a$ 是 $e$ 的一部分。\n  $\\mathrm{GEN}_{B_2} = \\varnothing$, $\\mathrm{KILL}_{B_2} = \\{e\\}$。\n- $B_3$: $t_2 := a \\times b$, ...\n  这个块计算 $a \\times b$ 并且之后不修改 $a$ 或 $b$。\n  $\\mathrm{GEN}_{B_3} = \\{e\\}$, $\\mathrm{KILL}_{B_3} = \\varnothing$。\n- $B_4$: if $q$ ...\n  这个块不包含相关的计算或赋值。\n  $\\mathrm{GEN}_{B_4} = \\varnothing$, $\\mathrm{KILL}_{B_4} = \\varnothing$。\n- $B_5$: $b := b + 1$, ...\n  这个块对 $b$ 进行赋值，而 $b$ 是 $e$ 的一部分。\n  $\\mathrm{GEN}_{B_5} = \\varnothing$, $\\mathrm{KILL}_{B_5} = \\{e\\}$。\n- $B_6$: $t_3 := a \\times b$, ...\n  这个块计算 $a \\times b$ 并且之后不修改 $a$ 或 $b$。\n  $\\mathrm{GEN}_{B_6} = \\{e\\}$, $\\mathrm{KILL}_{B_6} = \\varnothing$。\n- $B_7$: return.\n  这个块没有相关语句。\n  $\\mathrm{GEN}_{B_7} = \\varnothing$, $\\mathrm{KILL}_{B_7} = \\varnothing$。\n\n现在我们应用迭代算法来寻找不动点。数据流方程如下：\n$$ \\mathrm{IN}[B] = \\bigcap_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n$$ \\mathrm{OUT}[B] = \\mathrm{GEN}_B \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}_B) $$\n\n初始化：\n- $\\mathrm{IN}[B_1] = \\varnothing$\n- 对于 $B \\in \\{B_2, B_3, B_4, B_5, B_6, B_7\\}$，$\\mathrm{IN}[B] = U = \\{e\\}$。\n- 所有 $\\mathrm{OUT}$ 集合都隐式为空，或将在第一轮迭代中计算。\n\n**第一轮迭代：**\n我们计算每个块的 $\\mathrm{OUT}$ 集合，然后为下一轮迭代更新 $\\mathrm{IN}$ 集合。\n- $\\mathrm{OUT}[B_1] = \\mathrm{GEN}_{B_1} \\cup (\\mathrm{IN}[B_1] \\setminus \\mathrm{KILL}_{B_1}) = \\{e\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e\\}$\n- $\\mathrm{IN}[B_2]$ 可以立即更新：$\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{e\\}$。这与初始值相同。\n- $\\mathrm{OUT}[B_2] = \\mathrm{GEN}_{B_2} \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}_{B_2}) = \\varnothing \\cup (\\{e\\} \\setminus \\{e\\}) = \\varnothing$\n- $\\mathrm{IN}[B_3]$ 也可以更新：$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] = \\{e\\}$。这与初始值相同。\n- $\\mathrm{OUT}[B_3] = \\mathrm{GEN}_{B_3} \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}_{B_3}) = \\{e\\} \\cup (\\{e\\} \\setminus \\varnothing) = \\{e\\}$\n- 现在我们计算 $B_4$ 的 $\\mathrm{IN}$ 集合：\n  $\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_3] = \\varnothing \\cap \\{e\\} = \\varnothing$。初始值 $\\{e\\}$ 变为 $\\varnothing$。\n- $\\mathrm{OUT}[B_4] = \\mathrm{GEN}_{B_4} \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}_{B_4}) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_4] = \\varnothing$。初始值 $\\{e\\}$ 变为 $\\varnothing$。\n- $\\mathrm{OUT}[B_5] = \\mathrm{GEN}_{B_5} \\cup (\\mathrm{IN}[B_5] \\setminus \\mathrm{KILL}_{B_5}) = \\varnothing \\cup (\\varnothing \\setminus \\{e\\}) = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\mathrm{OUT}[B_4] = \\varnothing$。初始值 $\\{e\\}$ 变为 $\\varnothing$。\n- $\\mathrm{OUT}[B_6] = \\mathrm{GEN}_{B_6} \\cup (\\mathrm{IN}[B_6] \\setminus \\mathrm{KILL}_{B_6}) = \\{e\\} \\cup (\\varnothing \\setminus \\varnothing) = \\{e\\}$\n- $\\mathrm{IN}[B_7] = \\mathrm{OUT}[B_5] \\cap \\mathrm{OUT}[B_6] = \\varnothing \\cap \\{e\\} = \\varnothing$。初始值 $\\{e\\}$ 变为 $\\varnothing$。\n- $\\mathrm{OUT}[B_7] = \\mathrm{GEN}_{B_7} \\cup (\\mathrm{IN}[B_7] \\setminus \\mathrm{KILL}_{B_7}) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$\n\n第一次完整迭代后的状态是：\n- $\\mathrm{IN}[B_1] = \\varnothing$, $\\mathrm{OUT}[B_1] = \\{e\\}$\n- $\\mathrm{IN}[B_2] = \\{e\\}$, $\\mathrm{OUT}[B_2] = \\varnothing$\n- $\\mathrm{IN}[B_3] = \\{e\\}$, $\\mathrm{OUT}[B_3] = \\{e\\}$\n- $\\mathrm{IN}[B_4] = \\varnothing$, $\\mathrm{OUT}[B_4] = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\varnothing$, $\\mathrm{OUT}[B_5] = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\varnothing$, $\\mathrm{OUT}[B_6] = \\{e\\}$\n- $\\mathrm{IN}[B_7] = \\varnothing$, $\\mathrm{OUT}[B_7] = \\varnothing$\n\n**第二轮迭代：**\n我们重新计算所有值以检查是否有变化。\n- $\\mathrm{OUT}[B_1]$ 依赖于 $\\mathrm{IN}[B_1]$，而后者未变。所以 $\\mathrm{OUT}[B_1] = \\{e\\}$（无变化）。\n- $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{e\\}$（无变化）。\n- $\\mathrm{OUT}[B_2]$ 依赖于 $\\mathrm{IN}[B_2]$，而后者未变。所以 $\\mathrm{OUT}[B_2] = \\varnothing$（无变化）。\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] = \\{e\\}$（无变化）。\n- $\\mathrm{OUT}[B_3]$ 依赖于 $\\mathrm{IN}[B_3]$，而后者未变。所以 $\\mathrm{OUT}[B_3] = \\{e\\}$（无变化）。\n- $\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] \\cap \\mathrm{OUT}[B_3] = \\varnothing \\cap \\{e\\} = \\varnothing$（无变化）。\n- $\\mathrm{OUT}[B_4]$ 依赖于 $\\mathrm{IN}[B_4]$，而后者未变。所以 $\\mathrm{OUT}[B_4] = \\varnothing$（无变化）。\n- $\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_4] = \\varnothing$（无变化）。\n- $\\mathrm{OUT}[B_5]$ 依赖于 $\\mathrm{IN}[B_5]$，而后者未变。所以 $\\mathrm{OUT}[B_5] = \\varnothing$（无变化）。\n- $\\mathrm{IN}[B_6] = \\mathrm{OUT}[B_4] = \\varnothing$（无变化）。\n- $\\mathrm{OUT}[B_6]$ 依赖于 $\\mathrm{IN}[B_6]$，而后者未变。所以 $\\mathrm{OUT}[B_6] = \\{e\\}$（无变化）。\n- $\\mathrm{IN}[B_7] = \\mathrm{OUT}[B_5] \\cap \\mathrm{OUT}[B_6] = \\varnothing \\cap \\{e\\} = \\varnothing$（无变化）。\n- $\\mathrm{OUT}[B_7]$ 依赖于 $\\mathrm{IN}[B_7]$，而后者未变。所以 $\\mathrm{OUT}[B_7] = \\varnothing$（无变化）。\n\n由于在第二轮迭代期间没有 $\\mathrm{IN}$ 或 $\\mathrm{OUT}$ 集合发生变化，算法已经收敛，我们达到了最大不动点。\n\n最终的 $\\mathrm{IN}$ 集合是：\n- $\\mathrm{IN}[B_1] = \\varnothing$\n- $\\mathrm{IN}[B_2] = \\{e\\}$\n- $\\mathrm{IN}[B_3] = \\{e\\}$\n- $\\mathrm{IN}[B_4] = \\varnothing$\n- $\\mathrm{IN}[B_5] = \\varnothing$\n- $\\mathrm{IN}[B_6] = \\varnothing$\n- $\\mathrm{IN}[B_7] = \\varnothing$\n\n问题要求的是在不动点处满足 $e \\in \\mathrm{IN}[B]$ 的基本块 $B$ 的数量 $N$。我们检查最终的 $\\mathrm{IN}$ 集合：\n- 对于 $B_1$，$e \\notin \\mathrm{IN}[B_1]$。\n- 对于 $B_2$，$e \\in \\mathrm{IN}[B_2]$。\n- 对于 $B_3$，$e \\in \\mathrm{IN}[B_3]$。\n- 对于 $B_4$，$e \\notin \\mathrm{IN}[B_4]$。\n- 对于 $B_5$，$e \\notin \\mathrm{IN}[B_5]$。\n- 对于 $B_6$，$e \\notin \\mathrm{IN}[B_6]$。\n- 对于 $B_7$，$e \\notin \\mathrm{IN}[B_7]$。\n\n条件 $e \\in \\mathrm{IN}[B]$ 对两个基本块成立：$B_2$ 和 $B_3$。\n因此，$N$ 的值为 $2$。", "answer": "$$ \\boxed{2} $$", "id": "3622931"}, {"introduction": "在处理像C或C++这样包含指针的语言时，编译器优化面临着别名分析的挑战。本练习聚焦于指针赋值如何影响可用表达式分析中的$KILL$集。[@problem_id:3622890] 通过这个思想实验，你将理解“可能指向”集（may-point-to set）的保守性质是如何直接传递给数据流分析的，并学会如何精确量化这种不确定性对可用表达式集合的影响。", "problem": "考虑一个基本块中的可用表达式前向数据流分析。从标准语义开始：如果到达某个程序点的每条路径都计算了该表达式，并且其组成内存位置之后没有被修改，则该表达式在该程序点是可用的。对于一个标量变量的直接赋值，任何包含该变量的表达式在赋值后都不再保证可用。对于通过指针的存储操作，可能被修改的变量集由别名分析计算出的“可能指向集”给出；任何包含这些变量中任意一个的表达式都不再保证可用。对于语法相等性，不假设任何代数恒等式（如交换律），因此，例如，$a+b$ 和 $b+a$ 被认为是不同的表达式。\n\n给定以下位于单个基本块中的程序片段（源代码级伪代码），其中所有变量表示标量整数位置，运算符符号表示对这些位置的标准算术运算：\n\n1. $r_1 := a + b$\n\n2. $r_2 := x \\times y$\n\n3. $r_3 := y + a$\n\n4. $r_4 := x + y$\n\n5. $r_5 := z + a$\n\n6. $r_6 := z \\times y$\n\n7. $r_7 := a \\times y$\n\n8. $r_8 := b + a$\n\n9. $r_9 := x + a$\n\n10. $*p := 3$\n\n设可用表达式分析的候选表达式全集是上述代码片段中语法上出现的所有右侧算术表达式的集合：\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}.\n$$\n一个流不敏感的别名分析报告指针 $p$ 的“可能指向集”为\n$$\n\\mathrm{pts}(p) = \\{\\, x,\\; z \\,\\},\n$$\n并且 $p$ 不与 $a$、$b$ 或 $y$ 中的任何一个可能别名。在保守的可用表达式分析下，确定语句 $10$ 相对于全集 $\\mathcal{E}$ 的 $KILL$ 集合的基数，其中 $KILL$ 集合收集了所有因 $*p := 3$ 的潜在修改而在语句 $10$ 之后立即不再保证可用的 $\\mathcal{E}$ 中的表达式。\n\n请以单个整数的形式提供您的最终答案。无需四舍五入。", "solution": "如果一个表达式先前已被计算，并且其组成变量此后未被修改，则该表达式是可用的。本题要求我们确定语句 $10$，$*p := 3$ 的 $KILL$ 集合。在可用表达式分析中，一个语句的 $KILL$ 集合包含所有来自目标全集、并被该语句置为无效的表达式。如果一个语句修改了表达式的一个或多个组成变量，则该表达式被置为无效，或称被“杀死”。\n\n所讨论的语句 `$*p := 3$` 是通过指针 `$p$` 的一次存储操作。为确定哪些变量被修改，我们必须参考别名分析的结果。题目给出了指针 `$p$` 的“可能指向集”为 $\\mathrm{pts}(p) = \\{x, z\\}$。这意味着指针 `$p$` 可能是变量 `$x$` 或变量 `$z$` 的别名（即，可能指向 `$x$` 或 `$z$` 的内存位置）。\n\n保守的数据流分析必须考虑所有可能性。因此，语句 `$*p := 3$` 必须被视为可能修改“可能指向集”中的任何变量。由语句 $10$ 潜在修改的变量集是 $\\{x, z\\}$。因此，任何包含 `$x$` 或 `$z$` 作为操作数的表达式都会被此语句杀死。题目还指出，$p$ 不与 $a$、$b$ 或 $y$ 可能别名，这确认了这些变量不受此赋值影响。\n\n我们所考虑的表达式全集如下：\n$$\n\\mathcal{E} = \\{\\, a+b,\\; x\\times y,\\; y+a,\\; x+y,\\; z+a,\\; z\\times y,\\; a\\times y,\\; b+a,\\; x+a \\,\\}\n$$\n现在我们将检查 $\\mathcal{E}$ 中的每个表达式，以确定它是否因 $x$ 或 $z$ 的潜在修改而被杀死。设 $\\mathrm{vars}(e)$ 表示表达式 $e$ 中的变量集合。如果 $\\mathrm{vars}(e) \\cap \\{x, z\\} \\neq \\emptyset$，则表达式 $e$ 属于语句 $10$ 的 $KILL$ 集合。\n\n1.  $a+b$: $\\mathrm{vars}(a+b) = \\{a, b\\}$。与 $\\{x, z\\}$ 的交集是 $\\emptyset$。此表达式不被杀死。\n2.  $x\\times y$: $\\mathrm{vars}(x\\times y) = \\{x, y\\}$。与 $\\{x, z\\}$ 的交集是 $\\{x\\}$。此表达式被杀死。\n3.  $y+a$: $\\mathrm{vars}(y+a) = \\{y, a\\}$。与 $\\{x, z\\}$ 的交集是 $\\emptyset$。此表达式不被杀死。\n4.  $x+y$: $\\mathrm{vars}(x+y) = \\{x, y\\}$。与 $\\{x, z\\}$ 的交集是 $\\{x\\}$。此表达式被杀死。\n5.  $z+a$: $\\mathrm{vars}(z+a) = \\{z, a\\}$。与 $\\{x, z\\}$ 的交集是 $\\{z\\}$。此表达式被杀死。\n6.  $z\\times y$: $\\mathrm{vars}(z\\times y) = \\{z, y\\}$。与 $\\{x, z\\}$ 的交集是 $\\{z\\}$。此表达式被杀死。\n7.  $a\\times y$: $\\mathrm{vars}(a\\times y) = \\{a, y\\}$。与 $\\{x, z\\}$ 的交集是 $\\emptyset$。此表达式不被杀死。\n8.  $b+a$: $\\mathrm{vars}(b+a) = \\{b, a\\}$。与 $\\{x, z\\}$ 的交集是 $\\emptyset$。此表达式不被杀死。\n9.  $x+a$: $\\mathrm{vars}(x+a) = \\{x, a\\}$。与 $\\{x, z\\}$ 的交集是 $\\{x\\}$。此表达式被杀死。\n\n基于此分析，语句 $10$ 的 $KILL$ 集合是：\n$$\n\\mathrm{KILL}_{10} = \\{\\, x\\times y,\\; x+y,\\; z+a,\\; z\\times y,\\; x+a \\,\\}\n$$\n题目要求该集合的基数。通过计算元素数量，我们得到：\n$$\n|\\mathrm{KILL}_{10}| = 5\n$$", "answer": "$$\n\\boxed{5}\n$$", "id": "3622890"}, {"introduction": "现代编程语言引入了结构化异常处理等复杂的控制流结构，而数据流分析框架必须能够适应它们。本练习将可用表达式分析扩展到一个包含`try-catch`块的场景中。[@problem_id:3622911] 通过区分正常执行路径和异常跳转路径，你将学会如何将“所有路径汇合”（meet-over-all-paths）原则应用于非结构化的控制流，并理解异常处理如何影响代码优化决策。", "problem": "考虑一种具有结构化异常处理的高级语言。一个 try-catch 结构被编译成一个控制流图 (CFG)，其中正常边按直线顺序连接基本块，而异常边则从可能抛出异常的操作直接跳转到 catch 处理器入口。可用表达式分析是一种前向、全路径交汇、必须 (must) 分析，它作用于由候选表达式构成的格上。该格通过集合包含关系进行排序，并以交集作为交汇 (meet) 运算。如果一个表达式在通往某个程序点的所有路径上都已被计算，并且自沿这些路径的最后一次计算以来其操作数均未被重新赋值，则该表达式在该程序点是可用的。\n\n设候选表达式集合仅限于单个表达式，记为 $E$，其中 $E$ 是 $x \\times y$。考虑以下代码，其基本块标记为 $B_{1}$ 到 $B_{5}$，以及一个处理器块 $H$：\n\n- $B_{1}$: $e := x \\times y$。\n- $B_{2}$: $t := f(y)$，其中对 $f$ 的调用可能抛出类型为 $\\mathsf{Ex}$ 的异常，并且对 $x$ 或 $y$ 没有副作用。\n- $B_{3}$: $k := y$。\n- 正常边: $B_{1} \\rightarrow B_{2} \\rightarrow B_{3} \\rightarrow B_{5}$。\n- 异常边: $B_{2} \\dashrightarrow H$。\n- $H$: $x := x + 1$，后跟 $m := y$，然后是一条正常边 $H \\rightarrow B_{5}$。\n- $B_{5}$: try-catch 结构结束（无后续计算）。\n\n假设：\n- $B_{1}$ 中的乘法不会抛出异常。\n- 只有 $B_{2}$ 可能抛出异常。\n- 除了 $H$ 中对 $x$ 的赋值语句外，没有其他语句会修改 $x$ 或 $y$。\n\n使用可用表达式分析的标准定义（前向、必须、对前驱节点取交集，其中 $GEN$ 表示在一个块中计算的表达式，$KILL$ 表示因操作数被赋值而失效的表达式），确定 $E$ 在以下位置的可用性：\n1. 处理器块 $H$ 的入口。\n2. 基本块 $B_{5}$ 的入口（即 try-catch 结构的出口）。\n\n将可用性编码为 $1$（表示“可用”）和 $0$（表示“不可用”）。以单行矩阵 $\\begin{pmatrix} a  b \\end{pmatrix}$ 的形式提供最终答案，其中 $a$ 对应于处理器入口的可用性，$b$ 对应于出口的可用性。无需四舍五入，也无需报告单位。", "solution": "该问题要求我们对一个给定的、包含异常控制流的控制流图 (CFG) 进行可用表达式分析。这是一种前向、必须 (must) 分析，意味着我们沿控制流方向传播信息，并且一个表达式仅在通往某个程序点的所有路径上都可用时，才被认为是可用的。此分析的交汇 (meet) 运算符是集合交集。\n\n我们关心的表达式是 $E = x \\times y$。我们需要确定它在处理器块 $H$ 的入口和基本块 $B_5$ 的入口处的可用性。我们分别用 $IN[B]$ 和 $OUT[B]$ 表示在基本块 $B$ 入口和出口处的可用表达式集合。支配此分析的数据流方程如下：\n$$OUT[B] = GEN[B] \\cup (IN[B] - KILL[B])$$\n$$IN[B] = \\bigcap_{P \\in pred(B)} OUT[P]$$\n其中 $pred(B)$ 是基本块 $B$ 的所有前驱节点的集合。分析初始化时，$IN[B_{entry}] = \\emptyset$，所有其他的 $IN$ 集合等于所有候选表达式的集合，在本例中为 $\\{E\\}$。这些方程被迭代应用，直到达到不动点。\n\n首先，我们确定每个基本块相对于表达式 $E = x \\times y$ 的 $GEN$ 和 $KILL$ 集合。\n- **基本块 $B_1$ ($e := x \\times y$)：** 此块计算表达式 $E$。它不重新赋值 $x$ 或 $y$。因此，$GEN[B_1] = \\{E\\}$ 且 $KILL[B_1] = \\emptyset$。\n- **基本块 $B_2$ ($t := f(y)$)：** 此块不计算 $E$。问题陈述中说明调用 $f(y)$ 对 $x$ 或 $y$ 没有副作用。因此，$GEN[B_2] = \\emptyset$ 且 $KILL[B_2] = \\emptyset$。\n- **基本块 $B_3$ ($k := y$)：** 此块不计算 $E$，也不修改其操作数 $x$ 或 $y$。因此，$GEN[B_3] = \\emptyset$ 且 $KILL[B_3] = \\emptyset$。\n- **基本块 $H$ ($x := x + 1; m := y$)：** 此块修改变量 $x$，它是 $E$ 的一个操作数。这会使表达式 $E$ 失效（kill）。该块不计算 $E$。因此，$GEN[H] = \\emptyset$ 且 $KILL[H] = \\{E\\}$。\n- **基本块 $B_5$ (结束)：** 此块不执行与 $E$ 相关的计算或赋值。因此，$GEN[B_5] = \\emptyset$ 且 $KILL[B_5] = \\emptyset$。\n\n该 CFG 具有以下前驱关系：\n- $pred(B_2) = \\{B_1\\}$\n- $pred(B_3) = \\{B_2\\}$ (正常路径)\n- $pred(H) = \\{B_2\\}$ (异常路径)\n- $pred(B_5) = \\{B_3, H\\}$\n\n我们现在执行迭代式数据流分析。设 $U = \\{E\\}$ 为全表达式集合。\n**初始化：**\n- $IN[B_1] = \\emptyset$ (相关代码片段的入口点)。\n- 对于所有其他块 $B$，我们初始化 $IN[B] = U = \\{E\\}$。\n- 我们将所有 $OUT$ 集合初始化为 $U = \\{E\\}$ 以开始迭代，除了真正的程序入口块的出口应为 $\\emptyset$。首次计算出的 $OUT$ 集合将很快修正这一点。\n\n**迭代 1：**\n我们根据每个块的 $IN$ 集合计算其 $OUT$ 集合，然后根据其前驱节点的 $OUT$ 集合更新每个块的 $IN$ 集合。\n1.  $IN[B_1] = \\emptyset$。\n    $OUT[B_1] = GEN[B_1] \\cup (IN[B_1] - KILL[B_1]) = \\{E\\} \\cup (\\emptyset - \\emptyset) = \\{E\\}$。\n\n2.  $IN[B_2] = OUT[B_1] = \\{E\\}$。\n    $OUT[B_2] = GEN[B_2] \\cup (IN[B_2] - KILL[B_2]) = \\emptyset \\cup (\\{E\\} - \\emptyset) = \\{E\\}$。\n\n3.  $B_3$ 和 $H$ 的前驱节点都只有 $B_2$。\n    $IN[B_3] = OUT[B_2] = \\{E\\}$。\n    $OUT[B_3] = GEN[B_3] \\cup (IN[B_3] - KILL[B_3]) = \\emptyset \\cup (\\{E\\} - \\emptyset) = \\{E\\}$。\n\n    $IN[H] = OUT[B_2] = \\{E\\}$。\n    $OUT[H] = GEN[H] \\cup (IN[H] - KILL[H]) = \\emptyset \\cup (\\{E\\} - \\{E\\}) = \\emptyset$。\n\n4.  $B_5$ 是正常路径和异常路径的汇合点。\n    $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。\n    $OUT[B_5] = GEN[B_5] \\cup (IN[B_5] - KILL[B_5]) = \\emptyset \\cup (\\emptyset - \\emptyset) = \\emptyset$。\n\n**迭代 2：**\n我们使用迭代 1 结束时的值重复此过程。\n1.  $IN[B_1]$ 固定为 $\\emptyset$，$OUT[B_1]$ 保持为 $\\{E\\}$。\n2.  $IN[B_2] = OUT[B_1] = \\{E\\}$。无变化。$OUT[B_2]$ 保持为 $\\{E\\}$。\n3.  $IN[B_3] = OUT[B_2] = \\{E\\}$。无变化。$OUT[B_3]$ 保持为 $\\{E\\}$。\n4.  $IN[H] = OUT[B_2] = \\{E\\}$。无变化。$OUT[H]$ 保持为 $\\emptyset$。\n5.  $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。无变化。$OUT[B_5]$ 保持为 $\\emptyset$。\n\n由于在第二次迭代期间没有 $IN$ 或 $OUT$ 集合发生变化，算法已达到不动点。最终的稳定状态是：\n- $IN[H] = \\{E\\}$\n- $IN[B_5] = \\emptyset$\n\n我们现在可以回答问题提出的两个问题了。\n\n**1. 表达式 $E$ 在处理器块 $H$ 入口处的可用性。**\n$H$ 入口处的可用性由集合 $IN[H]$ 给出。我们的分析结论是 $IN[H] = \\{E\\}$。这意味着表达式 $E$ 在此点是可用的。\n逻辑路径如下：到达处理器 $H$ 的唯一方式是通过来自 $B_2$ 的异常边。要确定在 $H$ 入口处什么是可用的，我们查看在 $B_2$ 出口处什么是可用的。表达式 $E$ 在 $B_1$ 中生成，并且在 $B_2$ 中没有被“杀死”(killed)。因此，$OUT[B_2] = \\{E\\}$。因为这是通往 $H$ 的唯一路径，所以 $IN[H] = OUT[B_2] = \\{E\\}$。可用性编码为 $1$。\n\n**2. 表达式 $E$ 在基本块 $B_5$ 入口处的可用性。**\n$B_5$ 入口处的可用性由 $IN[B_5]$ 给出。我们的分析结论是 $IN[B_5] = \\emptyset$。这意味着表达式 $E$ 是不可用的。\n逻辑如下：$B_5$ 是一个汇合点，有两个前驱节点，$B_3$ 和 $H$。对于“必须”(must)分析，一个表达式要在汇合点可用，它必须在所有传入路径上都可用。\n- **经由 $B_3$ 的路径**：$E$ 在 $B_3$ 的出口处是可用的，因此 $OUT[B_3] = \\{E\\}$。\n- **经由 $H$ 的路径**：$E$ 在 $H$ 的入口处是可用的，但在 $H$ 内部被对 $x$ 的赋值“杀死”(killed)了。因此，$E$ 在 $H$ 的出口处是不可用的，所以 $OUT[H] = \\emptyset$。\n由于 $IN[B_5]$ 是其前驱节点的 $OUT$ 集合的交集，所以 $IN[B_5] = OUT[B_3] \\cap OUT[H] = \\{E\\} \\cap \\emptyset = \\emptyset$。因为 $E$ 在异常路径上不可用，所以它不能被认为在 $B_5$ 的入口处可用。可用性编码为 $0$。\n\n最终答案是一个行矩阵，包含处理器入口（$1$）和 try-catch 出口（$0$）的可用性代码。", "answer": "$$\\boxed{\\begin{pmatrix} 1  0 \\end{pmatrix}}$$", "id": "3622911"}]}