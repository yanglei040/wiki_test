{"hands_on_practices": [{"introduction": "本练习 [@problem_id:3684217] 将引导你处理一个包含循环和嵌套条件的复杂控制流图。通过手动计算变量 $best$ 的 $\\phi$-函数位置，你将深入理解迭代支配边界算法如何处理不同控制结构之间的交互，这是分析真实代码时一项至关重要的技能。", "problem": "请考虑以下程序片段及其相关的控制流图（CFG）。静态单赋值（SSA）形式要求每个变量仅被赋值一次，在合并点，使用以希腊字母phi(φ)表示的函数来合并值。您将使用支配和支配边界的概念来分析变量 $best$ 的 $\\phi$ 函数的放置位置。\n\n以基本块表示的程序片段：\n- 块 $B_{E}$ (入口): 直接进入前置首部。\n- 块 $B_{S}$ (前置首部): 通过 $best \\leftarrow s$ 初始化 $best$，然后将控制权转移到循环首部。\n- 块 $B_{H}$ (循环首部): 测试循环条件 $i  n$；如果为真，控制流进入循环体；如果为假，控制流转到出口。\n- 块 $B_{B}$ (循环体设置): 计算一个候选值 $a$ 并将控制权转移到一个条件块。\n- 块 $B_{C}$ (条件块): 测试一个谓词 $p$；如果为真，转到 $B_{T}$；如果为假，转到 $B_{F}$。\n- 块 $B_{T}$ (then-分支): 通过 $best \\leftarrow f_{1}(a)$ 更新 $best$，然后转到汇合点 $B_{J}$。\n- 块 $B_{F}$ (带有嵌套条件的else-分支): 测试另一个谓词 $q$；如果为真，转到 $B_{F\\_T}$；如果为假，转到 $B_{F\\_F}$。\n- 块 $B_{F\\_T}$ (嵌套的then): 通过 $best \\leftarrow f_{2}(a)$ 更新 $best$，然后转到汇合点 $B_{J}$。\n- 块 $B_{F\\_F}$ (嵌套的else): 保持 $best$ 不变，然后转到汇合点 $B_{J}$。\n- 块 $B_{J}$ (条件的汇合点): 从 $B_{T}$、$B_{F\\_T}$ 和 $B_{F\\_F}$ 接收控制权；然后转到循环闩锁。\n- 块 $B_{L}$ (循环闩锁): 递增 $i$ 并分支返回到 $B_{H}$，形成循环的后向边。\n- 块 $B_{X}$ (出口): 当 $B_{H}$ 将循环条件评估为假时到达。\n\n边如下：\n- $B_{E} \\rightarrow B_{S}$\n- $B_{S} \\rightarrow B_{H}$\n- $B_{H} \\rightarrow B_{B}$ 为真时，以及 $B_{H} \\rightarrow B_{X}$ 为假时\n- $B_{B} \\rightarrow B_{C}$\n- $B_{C} \\rightarrow B_{T}$ 为真时，以及 $B_{C} \\rightarrow B_{F}$ 为假时\n- $B_{F} \\rightarrow B_{F\\_T}$ 为真时，以及 $B_{F} \\rightarrow B_{F\\_F}$ 为假时\n- $B_{T} \\rightarrow B_{J}$, $B_{F\\_T} \\rightarrow B_{J}$, $B_{F\\_F} \\rightarrow B_{J}$\n- $B_{J} \\rightarrow B_{L}$\n- $B_{L} \\rightarrow B_{H}$\n\n假设是标准的结构化控制流，因此循环首部 $B_{H}$ 支配循环体中的所有块（$B_{B}$, $B_{C}$, $B_{T}$, $B_{F}$, $B_{F\\_T}$, $B_{F\\_F}$, $B_{J}$, $B_{L}$），并且 $B_{S}$ 支配 $B_{H}$。变量 $best$ 在 $B_{S}$ 中定义，并可能在 $B_{T}$ 和 $B_{F\\_T}$ 中重新定义，而在 $B_{F\\_F}$ 中保持不变。\n\n使用核心定义：\n- 如果从入口到块 $Y$ 的每条路径都经过块 $X$，则称块 $X$ 支配块 $Y$。\n- 块 $X$ 的支配边界，记作 $\\mathrm{DF}(X)$，是这样一组块 $Y$ 的集合：$X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。\n- 变量的最小 $\\phi$ 函数放置是通过在其定义块集合的迭代支配边界处插入 $\\phi$ 函数来获得的。\n\n将这些定义应用于变量 $best$，并确定在最小 SSA 放置下，必须在循环首部 $B_{H}$ 和汇合点 $B_{J}$ 为 $best$ 插入的 $\\phi$ 函数总数。用一个整数表示您的最终答案。不需要四舍五入，也不需要单位。只需提供在 $B_{H}$ 和 $B_{J}$ 处为 $best$ 插入的 $\\phi$ 函数的总数。", "solution": "用户希望根据静态单赋值（SSA）形式的原则，确定变量 `best` 在特定位置（即循环首部 $B_{H}$ 和汇合块 $B_{J}$）所需的 $\\phi$ 函数总数。最小化 $\\phi$ 函数放置的标准算法涉及计算包含变量定义的所有基本块集合的迭代支配边界。\n\n首先，我们确定变量 `best` 被赋值的块的集合，我们称之为 $S_{defs}$。根据问题描述，`best` 在 $B_{S}$ 中初始化，并在 $B_{T}$ 和 $B_{F\\_T}$ 中重新定义。\n因此，定义块的集合是：\n$$S_{defs} = \\{B_{S}, B_{T}, B_{F\\_T}\\}$$\n\n需要 $\\phi$ 函数的最小块集合，记作 $\\Phi$，是 $S_{defs}$ 的迭代支配边界，写作 $\\mathrm{DF}^{+}(S_{defs})$。我们使用一个迭代的工作列表算法来计算这个集合。\n\n设 $\\Phi$ 是需要 $\\phi$ 函数的块的集合，设 $W$ 是一个工作列表，其中包含其支配边界需要处理的块。\n\n1.  **初始化：**\n    *   $\\Phi = \\emptyset$\n    *   $W = S_{defs} = \\{B_{S}, B_{T}, B_{F\\_T}\\}$\n\n该算法通过从工作列表 $W$ 中重复取出一个块 $X$，并将其支配边界 $\\mathrm{DF}(X)$ 中的块添加到 $\\Phi$ 中来进行。任何被添加到 $\\Phi$ 中但原先不存在的块，也需要被添加到工作列表 $W$ 中。当 $W$ 为空时，过程终止。\n\n为了执行这个算法，我们必须首先计算相关块的支配边界。一个块 $X$ 的支配边界 $\\mathrm{DF}(X)$ 是所有满足以下条件的块 $Y$ 的集合：$X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。\n\n让我们分析初始工作列表中各块的支配边界：\n\n*   **$\\mathrm{DF}(B_{S})$**: 块 $B_S$ 是循环的前置首部。它支配循环内的所有块以及循环出口块。从 $B_S$ 开始的路径只在循环首部 $B_H$ 与其他路径合并。然而，在 $B_H$ 的合并发生在从 $B_S$ 来的路径和从 $B_L$ 来的后向边之间。在 $B_H$ 处需要 $\\phi$ 函数是由于循环内部的定义引起的，这被循环内部块（特别是 $B_L$ 或通过传播的 $B_J$）的支配边界所捕获。对于 $B_S$ 本身的定义，它有一条“无阻碍”的支配路径。形式上，对于任何被 $B_S$ 支配的块 $P$ 的后继 $Y$，$B_S$ 也严格支配 $Y$。因此，它的支配边界是空的。$\\mathrm{DF}(B_{S}) = \\emptyset$。\n\n*   **$\\mathrm{DF}(B_{T})$**: 块 $B_{T}$ 有一个后继，$B_{J}$。$B_J$ 是一个汇合点，来自 $B_T$、$B_{F\\_T}$ 和 $B_{F\\_F}$ 的控制流在此合并。在 $B_{T}$ 中的定义需要在该合并点处放置一个 $\\phi$ 函数。形式上，$B_T$ 支配其自身（$B_J$ 的一个前驱），但 $B_T$ 并不严格支配 $B_J$（因为存在不经过 $B_T$ 到达 $B_J$ 的路径）。因此，$B_{J} \\in \\mathrm{DF}(B_{T})$。由于 $B_J$ 是唯一的后继，所以 $\\mathrm{DF}(B_{T}) = \\{B_{J}\\}$。\n\n*   **$\\mathrm{DF}(B_{F\\_T})$**: 与 $B_T$ 类似，块 $B_{F\\_T}$ 的后继是 $B_J$。$B_{F\\_T}$ 支配其自身，但并不严格支配汇合块 $B_{J}$。因此，$B_{J} \\in \\mathrm{DF}(B_{F\\_T})$，且 $\\mathrm{DF}(B_{F\\_T}) = \\{B_{J}\\}$。\n\n现在，我们执行 $\\mathrm{DF}^{+}(S_{defs})$ 的迭代计算：\n\n**初始状态：** $\\Phi = \\emptyset$, $W = \\{B_{S}, B_{T}, B_{F\\_T}\\}$\n\n**步骤 1：** 从 $W$ 中出队 $B_S$。\n*   $W = \\{B_{T}, B_{F\\_T}\\}$。\n*   $\\mathrm{DF}(B_{S}) = \\emptyset$。$\\Phi$ 或 $W$ 没有变化。\n\n**步骤 2：** 从 $W$ 中出队 $B_T$。\n*   $W = \\{B_{F\\_T}\\}$。\n*   $\\mathrm{DF}(B_{T}) = \\{B_{J}\\}$。\n*   $B_{J}$ 不在 $\\Phi$ 中。我们更新 $\\Phi = \\Phi \\cup \\{B_{J}\\} = \\{B_{J}\\}$。\n*   我们将 $B_{J}$ 添加到工作列表：$W = W \\cup \\{B_{J}\\} = \\{B_{F\\_T}, B_{J}\\}$。\n\n**步骤 3：** 从 $W$ 中出队 $B_{F\\_T}$。\n*   $W = \\{B_{J}\\}$。\n*   $\\mathrm{DF}(B_{F\\_T}) = \\{B_{J}\\}$。\n*   $B_{J}$ 已经在 $\\Phi$ 中。没有变化。\n\n**步骤 4：** 从 $W$ 中出队 $B_{J}$。\n*   $W = \\emptyset$。\n*   在 $B_J$ 处放置 $\\phi$ 函数实际上在 $B_J$ 处创建了一个 `best` 的新定义。我们现在必须通过计算 $\\mathrm{DF}(B_{J})$ 来找出这个新定义在何处需要更多的 $\\phi$ 函数。\n*   块 $B_J$ 之后是循环闩锁 $B_L$，它有一条后向边指向循环首部 $B_H$。在 $B_J$ 定义的值通过 $B_L$ 保持活跃并到达 $B_H$。在 $B_H$ 处，这条路径与来自前置首部 $B_S$ 的路径合并。因此，$B_H$ 位于一个从循环内部传播值的块的支配边界中。形式上，$\\mathrm{DF}(B_J) = \\{B_H\\}$。\n*   $B_{H}$ 不在 $\\Phi$ 中。我们更新 $\\Phi = \\Phi \\cup \\{B_{H}\\} = \\{B_{J}, B_{H}\\}$。\n*   我们将 $B_{H}$ 添加到工作列表：$W = W \\cup \\{B_{H}\\} = \\{B_{H}\\}$。\n\n**步骤 5：** 从 $W$ 中出队 $B_{H}$。\n*   $W = \\emptyset$。\n*   我们需要计算 $\\mathrm{DF}(B_{H})$。由于 $B_H$ 是一个循环首部，在 $B_H$ 的一个定义（例如它自己的 $\\phi$ 函数）会绕循环一圈并与自身重新合并。这意味着 $B_H$ 在其自身的支配边界内。所以，$\\mathrm{DF}(B_{H}) = \\{B_{H}\\}$。\n*   $B_{H}$ 已经在 $\\Phi$ 中。没有变化。\n\n工作列表 $W$ 现已为空，算法终止。变量 `best` 需要 $\\phi$ 函数的最终块集合是 $\\Phi = \\{B_{J}, B_{H}\\}$。\n\n问题要求在块 $B_{H}$ 和 $B_{J}$ 处为 `best` 插入的 $\\phi$ 函数的总数。根据我们的结果，一个 $\\phi$ 函数放置在 $B_J$，一个放置在 $B_H$。\n\n因此，总数是 $1 + 1 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3684217"}, {"introduction": "本练习 [@problem_id:3684224] 旨在揭示SSA形式的一个核心特性：$\\phi$-函数本身会为变量创建一个全新的、统一的定义。通过分析一个具有多个控制流汇合点的图，你将看到一个$\\phi$-函数的放置如何能避免在下游需要放置更多的$\\phi$-函数，这清晰地展示了SSA表示法的简洁与高效。", "problem": "考虑以下控制流图（CFG），它描述了一个操作单个标量变量 $x$ 并在过程末尾使用 $x$ 的过程。节点是基本块 $B_0, B_1, B_2, B_3, B_4, B_5, B_6, B_7$，边表示控制流。控制流和赋值如下：\n\n- $B_0$：入口；为 $x$ 赋一个初始值（视为一个定义），然后跳转到 $B_1$。\n- $B_1$：一个条件分支，分裂成两个互斥的后继节点 $B_2$ 和 $B_3$。\n- $B_2$：赋值 $x := 1$，然后跳转到 $B_4$。\n- $B_3$：不对 $x$ 进行赋值，然后跳转到 $B_4$。\n- $B_4$：来自 $B_2$ 和 $B_3$ 的路径的第一个汇合点；然后第二个条件分支分裂成互斥的 $B_5$ 和 $B_6$。\n- $B_5$：不对 $x$ 进行赋值，然后跳转到 $B_7$。\n- $B_6$：不对 $x$ 进行赋值，然后跳转到 $B_7$。\n- $B_7$：来自 $B_5$ 和 $B_6$ 的路径的第二个汇合点；$B_7$ 中包含对 $x$ 的一次使用（因此 $x$ 在进入 $B_7$ 的两条边上都是活跃的），然后过程退出。\n\n假设目标是使用标准的基于支配关系和支配边界的放置策略，为变量 $x$ 构建一个最小化的、经过剪枝的静态单赋值（SSA）形式。回顾核心定义：\n\n- 支配关系：如果从入口到节点 $n$ 的每一条路径都经过节点 $d$，则称 $d$ 支配 $n$。严格支配排除了 $d = n$ 的情况。\n- 节点 $d$ 的支配边界：所有节点 $n$ 的集合，其中 $d$ 支配 $n$ 的一个前驱节点，但 $d$ 并不严格支配 $n$。\n- 最小化 SSA 的 $\\phi$-函数放置（剪枝版）：对于每个变量，在其定义位置的迭代支配边界上放置 $\\phi$-函数，但仅当该变量在该位置是入口活跃（live-in）时才放置。\n\n仅基于这些基础，变量 $x$ 的 $\\phi$-函数需要在哪里放置？\n\nA. 仅在 $B_4$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_7$ 处不需要为 $x$ 放置 $\\phi$-函数。\n\nB. 在 $B_4$ 和 $B_7$ 处都为 $x$ 放置 $\\phi$-函数。\n\nC. 仅在 $B_7$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_4$ 处不需要为 $x$ 放置 $\\phi$-函数。\n\nD. 在任何块中都不需要为 $x$ 放置 $\\phi$-函数，因为在每个分支点，都有一个分支不对 $x$ 进行赋值。", "solution": "### 步骤1：提取已知信息\n题目提供了关于一个控制流图（CFG）和标量变量 $x$ 的以下信息：\n1.  **节点（基本块）**：$B_0, B_1, B_2, B_3, B_4, B_5, B_6, B_7$。\n2.  **控制流**：\n    - $B_0$ 是入口块，只有一个后继节点 $B_1$。\n    - $B_1$ 是一个条件分支，有两个后继节点 $B_2$ 和 $B_3$。\n    - $B_2$ 只有一个后继节点 $B_4$。\n    - $B_3$ 只有一个后继节点 $B_4$。\n    - $B_4$ 是一个条件分支，有两个后继节点 $B_5$ 和 $B_6$。\n    - $B_5$ 只有一个后继节点 $B_7$。\n    - $B_6$ 只有一个后继节点 $B_7$。\n    - $B_7$ 是出口块。\n3.  **对 $x$ 的赋值（定义）**：\n    - $B_0$ 包含一个对 $x$ 的定义。\n    - $B_2$ 包含一个对 $x$ 的定义（具体为 $x := 1$）。\n    - $B_3, B_5, B_6$ 不包含对 $x$ 的定义。\n4.  **对 $x$ 的使用**：\n    - $B_7$ 包含一次对 $x$ 的使用。\n5.  **SSA 构建规则**：\n    - **支配关系**：如果从入口到节点 $n$ 的每一条路径都经过节点 $d$，则称 $d$ 支配 $n$。严格支配意味着 $d \\neq n$。\n    - **支配边界（DF）**：节点 $d$ 的支配边界 $DF(d)$ 是所有节点 $n$ 的集合，其中 $d$ 支配 $n$ 的一个前驱节点，但 $d$ 并不严格支配 $n$。\n    - **放置规则**：在变量定义位置的迭代支配边界（$IDF$）上放置 $\\phi$-函数。\n    - **剪枝规则**：仅当变量在该块是入口活跃（live-in）时，才放置 $\\phi$-函数。\n\n### 步骤2：使用提取的信息进行验证\n问题描述了编译器优化中的一个标准场景，特别是静态单赋值（SSA）形式的构建。\n-   **科学性**：控制流图、支配关系、支配边界、活跃性分析和 $\\phi$-函数等概念是编译原理中基础且成熟的原则。该问题在科学上是合理的。\n-   **良构性**：CFG 得到了完整描述，定义和使用位置已指定，$\\phi$-函数的放置算法也已明确定义。这种结构允许推导出唯一的解决方案。\n-   **客观性**：问题使用精确的、来自计算机科学的形式化语言术语进行陈述，没有歧义或主观陈述。\n\n该问题是自洽的、逻辑一致的，并基于既定的计算机科学原理。它不违反任何无效性标准。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。将推导解决方案。\n\n### 解题推导\n\n任务是通过计算变量 $x$ 定义位置的剪枝后迭代支配边界，来找到 $\\phi$-函数的放置位置。\n\n**1. 识别定义位置**\n问题指出变量 $x$ 在块 $B_0$ 和 $B_2$ 中被定义。设 $S$ 为 $x$ 的定义块集合。\n$$S = \\{B_0, B_2\\}$$\n\n**2. 分析CFG并计算支配节点**\nCFG结构如下：\n- $B_0$ (入口) $\\to B_1$\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$  ($B_4$ 是一个汇合点)\n- $B_4 \\to B_5$, $B_4 \\to B_6$\n- $B_5 \\to B_7$\n- $B_6 \\to B_7$  ($B_7$ 是一个汇合点)\n- $B_7$ 是出口。\n\n我们确定每个块的支配节点集。如果从入口到 $n$ 的所有路径都包含 $d$，则节点 $d$ 支配 $n$，记为 $d \\text{ dom } n$。\n- $\\text{dom}(B_0) = \\{B_0\\}$\n- $\\text{dom}(B_1) = \\{B_0, B_1\\}$\n- $\\text{dom}(B_2) = \\{B_0, B_1, B_2\\}$\n- $\\text{dom}(B_3) = \\{B_0, B_1, B_3\\}$\n- $\\text{dom}(B_4) = \\{B_0, B_1, B_4\\}$（直接支配节点是 $B_1$）\n- $\\text{dom}(B_5) = \\{B_0, B_1, B_4, B_5\\}$（直接支配节点是 $B_4$）\n- $\\text{dom}(B_6) = \\{B_0, B_1, B_4, B_6\\}$（直接支配节点是 $B_4$）\n- $\\text{dom}(B_7) = \\{B_0, B_1, B_4, B_7\\}$（直接支配节点是 $B_4$）\n\n**3. 计算支配边界（DF）**\n节点 $d$ 的支配边界 $DF(d)$ 是所有节点 $n$ 的集合，其中 $d$ 支配 $n$ 的一个前驱节点，但 $d$ 并不严格支配 $n$。我们需要计算定义集 $S=\\{B_0, B_2\\}$ 中节点的支配边界。\n\n- **$DF(B_0)$**：入口节点 $B_0$ 严格支配它所支配的每个节点（除了它自己）。它没有前驱节点。其支配边界为空。\n$$DF(B_0) = \\emptyset$$\n\n- **$DF(B_2)$**：我们寻找满足以下条件的节点 $n$：$B_2$ 支配 $n$ 的一个前驱节点，但并不严格支配 $n$。\n    - $B_2$ 支配的唯一节点是 $B_2$ 本身。因此我们只需要检查 $B_2$ 的后继节点。\n    - $B_2$ 的后继节点是 $n=B_4$。$B_4$ 的一个前驱节点是 $p=B_2$。\n    - $B_2$ 是否支配 $p=B_2$？是的，这是平凡的。\n    - $B_2$ 是否严格支配 $n=B_4$？不是，因为 $B_2$ 不在 $\\text{dom}(B_4) = \\{B_0, B_1, B_4\\}$ 中。\n    - 因此，$B_4$ 位于 $B_2$ 的支配边界中。\n$$DF(B_2) = \\{B_4\\}$$\n\n**4. 计算迭代支配边界（IDF）**\n$\\phi$-函数的候补节点集是定义位置的迭代支配边界 $IDF(S)$。我们从初始定义位置的支配边界开始，迭代地添加新加入节点的支配边界，直到达到一个不动点。\n设 $W_0 = S = \\{B_0, B_2\\}$。\n设 $\\Phi_0 = \\emptyset$。\n该算法计算 $\\Phi = IDF(S)$。\n\n迭代1：\n- 计算 $DF(S) = DF(B_0) \\cup DF(B_2) = \\emptyset \\cup \\{B_4\\} = \\{B_4\\}$。\n- 需要 $\\phi$-函数的新节点集是 $\\Phi_1 = \\{B_4\\}$。这些是新的“定义”。\n- 我们需要检查在 $B_4$ 放置 $\\phi$-函数是否会强制在别处放置另一个 $\\phi$-函数。我们计算 $\\Phi_1$ 中节点的DF。\n\n迭代2：\n- 计算 $DF(B_4)$：我们寻找满足以下条件的节点 $n$：$B_4$ 支配 $n$ 的一个前驱节点，但并不严格支配 $n$。\n    - 唯一的潜在候补是汇合点 $B_7$，因为它是其前驱节点（$B_5, B_6$）被 $B_4$ 支配的唯一汇合点。\n    - 让我们检查 $n=B_7$。它的前驱节点是 $p_1=B_5$ 和 $p_2=B_6$。\n    - $B_4$ 是否支配 $p_1=B_5$？是的，$\\text{dom}(B_5) = \\{B_0, B_1, B_4, B_5\\}$。\n    - $B_4$ 是否严格支配 $n=B_7$？是的，因为 $B_4 \\in \\text{dom}(B_7)$ 且 $B_4 \\neq B_7$。\n    - 位于支配边界的条件是“$d$ 不严格支配 $n$”。这个条件不成立。\n    - 所以，$B_7$ 不在 $DF(B_4)$ 中。同样的逻辑也适用于经过 $B_6$ 的路径。\n    - 没有其他节点需要检查。因此，$DF(B_4)$ 是空的。\n$$DF(B_4) = \\emptyset$$\n- 下一个节点集是 $\\Phi_2 = \\Phi_1 \\cup DF(B_4) = \\{B_4\\} \\cup \\emptyset = \\{B_4\\}$。\n- 由于 $\\Phi_2 = \\Phi_1$，迭代已经收敛。\n\n最小化SSA算法建议在集合 $IDF(S) = \\{B_4\\}$ 中的节点处放置 $\\phi$-函数。\n\n**5. 基于活跃性进行剪枝**\n问题指定了剪枝后的SSA形式。仅当变量 $x$ 在块 $B$ 是入口活跃（live-in）时，才需要为它在 $B$ 处放置 $\\phi$-函数。如果从一个块的入口到该变量的一次使用存在一条路径，并且路径上没有对该变量的重定义，那么该变量在该块就是入口活跃的。\n\n- 我们有一个 $\\phi$-函数的候补块：$B_4$。\n- 我们必须检查 $x$ 在 $B_4$ 是否是入口活跃的。\n- 问题指出在 $B_7$ 中有一次对 $x$ 的使用。\n- 从 $B_4$ 的入口到 $B_7$ 中的使用有两条路径：\n    - 路径 1: $B_4 \\to B_5 \\to B_7$。\n    - 路径 2: $B_4 \\to B_6 \\to B_7$。\n- 这些路径上的块（$B_5, B_6$）没有重定义 $x$。\n- 因此，从 $B_4$ 的入口到 $x$ 的一次使用存在一条无定义的路径，这意味着 $x$ 在 $B_4$ 的入口处是活跃的。\n- $B_4$ 处的 $\\phi$-函数不会被剪枝。\n\n**结论**\n最终需要为 $x$ 放置 $\\phi$-函数的块集合是 $\\{B_4\\}$。在 $B_7$ 处不需要 $\\phi$-函数，因为它不在原始定义位置的迭代支配边界中。直观上，任何进入 $B_4$ 的 $x$ 的值（这将是一个单一版本 $x' = \\phi(x_{from\\_B2}, x_{from\\_B3})$）都会在没有被重定义的情况下通过两个分支（$B_4 \\to B_5$ 和 $B_4 \\to B_6$）。因此，相同版本的 $x$（即 $x'$）会沿着两条入边到达 $B_7$，这使得在 $B_7$ 放置 $\\phi$-函数是冗余的。\n\n### 逐项分析\n\n**A. 仅在 $B_4$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_7$ 处不需要为 $x$ 放置 $\\phi$-函数。**\n这与我们推导出的结果完全一致。迭代支配边界的计算在 $B_4$ 处放置了一个 $\\phi$-函数。活跃性分析确认了这是必要的。计算也表明 $B_7$ 不在定义位置的IDF中，所以不在那里放置 $\\phi$-函数。\n**结论：正确。**\n\n**B. 在 $B_4$ 和 $B_7$ 处都为 $x$ 放置 $\\phi$-函数。**\n这是不正确的。如推导所示，$B_7$ 不在定义位置 $\\{B_0, B_2\\}$ 的迭代支配边界中。具体来说，$DF(B_4)$ 是空的，因为 $B_4$ 严格支配 $B_7$。因此，标准算法不会在 $B_7$ 处放置 $\\phi$-函数。\n**结论：不正确。**\n\n**C. 仅在 $B_7$ 处为 $x$ 放置一个 $\\phi$-函数；在 $B_4$ 处不需要为 $x$ 放置 $\\phi$-函数。**\n这是不正确的。在 $B_4$ 处需要一个 $\\phi$-函数，因为它是来自两个不同 $x$ 定义的控制流路径合并的第一个块。通过 $B_2$ 的路径携带了 $x$ 的新值，而通过 $B_3$ 的路径携带了来自 $B_0$ 的旧值。一个 $\\phi$-函数对于合并这些版本至关重要。我们的计算证实了这一点（$B_4 \\in DF(B_2)$）。\n**结论：不正确。**\n\n**D. 在任何块中都不需要为 $x$ 放置 $\\phi$-函数，因为在每个分支点，都有一个分支不对 $x$ 进行赋值。**\n这个推理是错误的。当一个条件分支重定义了一个变量而另一个分支没有时，几乎总是在汇合点需要一个 $\\phi$-函数。没有重定义变量的分支只是传播了该变量的一个旧版本，这个旧版本必须与来自另一个分支的新版本合并。这正是汇合点 $B_4$ 的情况。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3684224"}]}