{"hands_on_practices": [{"introduction": "静态分析常常为了效率而牺牲精度，这个思维实验 [@problem_id:3647942] 探讨了这种权衡的一个经典后果。你将分析一个程序，其中上下文不敏感的分析由于未能将函数返回与其相应的调用匹配，从而产生了一条虚假的数据流路径。这个练习揭示了这种不精确性如何导致污点分析中的误报（false positives），这是安全和缺陷检测中的一个关键概念。", "problem": "考虑以下具有显式源和返回值的程序骨架。变量名、函数名和常量都是数学实体，并以 LaTeX 格式书写。\n\n函数 $id$ 接受两个参数 $x$ 和 $d$，其定义如下：\n- 如果 $d = 0$，返回 $x$。\n- 否则，返回 $id(x, d - 1)$。\n\n过程 $callerTainted$：\n- $a := \\text{source}()$，它返回一个污点整数，\n- $r_1 := id(a, 1)$，\n- $\\text{sinkTainted}(r_1)$。\n\n过程 $callerClean$：\n- $b := 0$，\n- $r_2 := id(b, 1)$，\n- $y := r_2$。\n\n过程 $main$：\n- 调用 $callerTainted$，\n- 调用 $callerClean$。\n\n假设一个标准的过程序控制流图（Interprocedural Control Flow Graph, ICFG）模型，其中调用边将调用点连接到被调用者的入口，返回边将被调用者的出口连接回调用者的返回点。一条有效的过程间路径遵循匹配的调用-返回规则：每次返回都必须回到发出最近未匹配调用的动态调用者（即，对应于下推系统的括号良匹配条件）。\n\n现在考虑一种过程间污点分析，在存在递归的情况下，它在ICFG上执行图可达性分析，但忽略了返回到调用者的匹配约束，实际上将返回边视为可以连接到同一函数的任何调用后站点的普通边（对返回的调用点不敏感）。污点源是 $callerTainted$ 中的 $\\text{source}()$。根据上述定义，$id$ 函数返回其参数，因此污点会沿着定义-使用链和 $id$ 的返回值进行传播。\n\n在“忽略返回到调用者匹配”这种近似下，哪个陈述正确地描述了分析结果？\n\nA. 只有 $r_1$ 是污点；在健全和不健全的分析下 $y$ 都保持非污点，因为递归不影响返回值的传播。\n\nB. $y$ 会被虚假地标记为污点：一条从 $callerTainted$ 中 $id$ 的递归调用产生的失配返回路径，可以流向 $callerClean$ 中的调用后站点，从而过度污染 $r_2$ 并因此污染 $y$。\n\nC. 即使在有正确匹配返回的情况下，$r_1$ 和 $r_2$ 也都是合法污点；递归导致 $id$ 在所有上下文中都返回一个污点值。\n\nD. 在任何过程间分析下都没有变量被污染，因为返回值不会跨过程边界传播污点。", "solution": "该问题陈述在科学上是有根据的、定义明确且客观的。它描述了静态程序分析中的一个标准场景，特别是过程间污点分析，并探讨了一种常见的精度-性能权衡所带来的后果。\n\n问题的核心在于理解一种使用简化函数返回模型的过程间污点分析的行为。该分析在过程序控制流图（ICFG）上执行图可达性分析，但它“忽略了返回到调用者的匹配约束”。这意味着当一个函数（比如 $f$）返回时，分析假设控制流（和数据流）可以继续到程序中*任何*对 $f$ 的调用之后的语句，而不仅仅是启动当前 $f$ 执行的那个调用。这是一种上下文不敏感的形式。\n\n让我们逐步跟踪分析过程。\n\n程序执行始于 `main`，它首先调用 `callerTainted`，然后调用 `callerClean`。\n\n1.  **对 `callerTainted` 的分析：**\n    *   语句 $a := \\text{source}()$ 被执行。根据定义，赋给 $a$ 的值是污点。\n    *   通过 $r_1 := id(a, 1)$ 调用函数 $id$。由于 $a$ 是污点，$id$ 的第一个参数（我们称之为 $x$）变为污点。第二个参数 $d$ 是 $1$。\n    *   在 $id(x, 1)$ 内部，条件 $d = 0$ 为假。函数递归调用自身：$id(x, d - 1)$，即 $id(x, 0)$。$x$ 的污点值被传递给这个递归调用。\n    *   在 $id(x, 0)$ 内部，条件 $d = 0$ 为真。函数返回其参数 $x$。由于 $x$ 是污点，$id$ 的返回值也是污点。\n    *   这个污点值从递归调用返回给外层的 $id(x, 1)$，后者随即也返回该值。\n    *   在顶层调用 $id(a, 1)$ 的出口点，返回一个污点值。\n\n2.  **返回流和 `callerClean` 的分析：**\n    *   一个健全的分析会尊重匹配的调用-返回对，它只会将这个污点返回值传播到 `callerTainted` 中其对应的调用点。这将污染 $r_1$，对 `callerTainted` 的分析到此结束。随后对 `callerClean` 的分析将从没有污点数据开始。\n    *   然而，问题指定了一种**忽略返回到调用者匹配约束**的分析。该分析模型将 $id$ 的出口连接到所有可能的返回点。\n    *   程序包含两个对 $id$ 的顶层调用点：\n        1.  在 `callerTainted` 中：$r_1 := id(a, 1)$。设其返回点为 $RS_1$。\n        2.  在 `callerClean` 中：$r_2 := id(b, 1)$。设其返回点为 $RS_2$。\n    *   当在 $id$ 的出口产生污点值时（源自 `callerTainted` 中的调用），不健全的分析会创建通往 $RS_1$ 和 $RS_2$ 的数据流路径。\n    *   通往 $RS_1$ 的路径是合法的。它导致 $r_1$ 被赋予污点值。\n    *   通往 $RS_2$ 的路径是虚假的。它创建了一个“串扰”或“不可实现路径”，其中一个函数调用（$id(a, 1)$）的结果看起来像是另一个完全不同的调用（$id(b, 1)$）的结果。\n    *   由于这条虚假路径，分析得出结论，`callerClean` 中的调用 $id(b, 1)$ 可以返回一个污点值。\n    *   因此，变量 $r_2$ 被标记为污点。\n    *   下一条语句是 $y := r_2$。由于这个定义-使用关系，污点从 $r_2$ 传播到 $y$。\n    *   因此，在这种分析下 $y$ 变为污点。这是一个假阳性（false positive），因为程序的任何实际执行都不会导致 $y$ 持有污点值。\n\n总而言之，指定的分析正确地识别出 $r_1$ 是污点，但由于无法区分函数 $id$ 的不同调用上下文，它虚假地将 $r_2$ 和 $y$ 识别为污点。\n\n现在，我们来评估每个选项：\n\n**A. 只有 $r_1$ 是污点；在健全和不健全的分析下 $y$ 都保持非污点，因为递归不影响返回值的传播。**\n这个陈述是 **不正确的**。虽然在健全分析下 $y$ 会保持非污点，但问题明确描述了一种允许失配返回的不健全分析。如上所述，这种特定的不健全性导致 $y$ 被虚假地标记为污点。其给出的理由也是有缺陷的；递归与一个从不同上下文调用的共享函数的组合，恰恰暴露了该分析模型的不精确性。\n\n**B. $y$ 会被虚假地标记为污点：一条从 $callerTainted$ 中 $id$ 的递归调用产生的失配返回路径，可以流向 $callerClean$ 中的调用后站点，从而过度污染 $r_2$ 并因此污染 $y$。**\n这个陈述是 **正确的**。它准确地描述了结果（$y$ 被虚假地标记为污点）及其导致的确切机制。分析创建了一条从 `callerTainted` 中发起的调用链到 `callerClean` 中返回点的“失配返回路径”。这导致了 $r_2$ 以及随后的 $y$ 被污染。这与我们的推导完全一致。\n\n**C. 即使在有正确匹配返回的情况下，$r_1$ 和 $r_2$ 也都是合法污点；递归导致 $id$ 在所有上下文中都返回一个污点值。**\n这个陈述是 **不正确的**。对 $r_2$（以及 $y$）的污染不是合法的；它是分析不精确性导致的假陽性。一个具有“正确匹配返回”的分析（一种健全的、上下文敏感的分析）会发现 `callerClean` 中的调用 $id(b, 1)$ 仅对干净数据（$b=0$）进行操作，因此其返回值是干净的。递归不会导致一个函数在所有上下文中都被污染，只会在其输入是污点的上下文中被污染。\n\n**D. 在任何过程间分析下都没有变量被污染，因为返回值不会跨过程边界传播污点。**\n这个陈述是 **不正确的**。它做出的事实性声明与问题陈述中给出的一个前提相矛盾。问题明确指出“污点会沿着定义-使用链和 $id$ 的返回值进行传播”。函数 $id$ 是其第一个参数的恒等函数，因此它是一个精确地将数据（以及污点）从其参数传播到其返回值，跨越过程边界的典型例子。因此，$r_1$ 必须是污点。", "answer": "$$\\boxed{B}$$", "id": "3647942"}, {"introduction": "这项实践 [@problem_id:3647964] 将你从识别副作用引导至验证正确的API用法，通过实现一个简单的类型状态分析来完成。你将为每个函数定义“转换器”摘要，描述它们如何改变资源的状态，然后利用这些摘要来检测更大程序中的协议违规行为。这项动手任务展示了过程间数据流分析如何成为一个强大的自动化缺陷发现工具。", "problem": "给定一个针对单个资源的简单类型状态协议，其状态和操作定义如下。资源类型状态由有限集 $\\{U,O,X,E\\}$ 建模，其中 $U$ 表示未打开，$O$ 表示已打开，$X$ 表示已关闭，$E$ 是一个错误汇集状态。预期的协议是在未打开的资源上调用一次 open 进入状态 $O$，在状态 $O$ 时调用任意次 write，以及从状态 $O$ 调用一次 close 进入状态 $X$。在不允许的状态下应用的任何操作都会立即将抽象状态转换为 $E$，这是一种误用。一旦进入 $E$，在任何操作下，抽象状态都保持为 $E$，并且对 $E$ 的操作不会产生额外的误用报告。基本操作对单例状态具有逐点效应：\n- $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n- $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n- $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n\n考虑以下伪代码程序，其中 $b_1$ 和 $b_2$ 是非确定性布尔值（两个分支都被认为是可能的），并且调用是对单个共享资源 $r$ 的引用传递：\n\nproc h(r):\n  write(r)\n\nproc k(r):\n  if b2? then close(r) else write(r)\n\nproc f(r):\n  if b1? then open(r)\n  h(r)\n\nproc g(r):\n  f(r)\n  k(r)\n\nmain:\n  r := new Resource()  // initial state is U\n  g(r)\n  close(r)\n\n我们在单调数据流分析的框架下，执行一个前向、流敏感、上下文不敏感的 may 分析。抽象域为 $D=\\mathcal{P}(\\{U,O,X,E\\})$，并对单状态转移函数进行逐点提升，因此对于 $S \\subseteq \\{U,O,X,E\\}$，有 $T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$。在过程中，控制流连接由 $D$ 上的并集建模。在调用点，使用过程间摘要：每个过程 $p \\in \\{h,k,f,g\\}$ 都由一个单调转换器 $\\tau_p:D \\to D$ 进行摘要，该转换器将调用入口处的抽象输入状态映射到返回时的抽象输出状态。如果在某个特定操作点，存在一个可达的非错误抽象状态 $s \\in \\{U,O,X\\}$，而协议不允许从该状态执行此操作，则该操作点会被标记为误用。在状态 $E$ 时执行的操作不会产生新的误用标记。\n\n从 main 入口处的初始抽象状态 $\\{U\\}$ 开始，根据单调数据流框架和过程间摘要的第一性原理，推导出摘要 $\\tau_h$、$\\tau_k$、$\\tau_f$ 和 $\\tau_g$，然后计算 main 最终 close 点的抽象状态。利用这些结果，确定在整个程序中被此分析标记为误用的不同操作点的集合。作为最终答案，报告被标记的不同操作点的数量。你的答案必须是一个不带单位的整数。如果你选择用文字书写数字，也请在括号中包含数字。无需四舍五入。", "solution": "问题要求我们对给定程序执行前向、流敏感、上下文不敏感的 may 数据流分析，以识别类型状态协议的误用。我们必须首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **类型状态模型**：状态集为 $\\{U, O, X, E\\}$，其中 $U$ 是未打开，$O$ 是已打开，$X$ 是已关闭，$E$ 是一个错误汇集状态。\n- **状态转移函数**：基本操作对单例状态 $s$ 引起以下状态转移：\n  - $T_{\\mathrm{open}}(U)=O$, $T_{\\mathrm{open}}(O)=E$, $T_{\\mathrm{open}}(X)=E$, $T_{\\mathrm{open}}(E)=E$.\n  - $T_{\\mathrm{write}}(O)=O$, $T_{\\mathrm{write}}(U)=E$, $T_{\\mathrm{write}}(X)=E$, $T_{\\mathrm{write}}(E)=E$.\n  - $T_{\\mathrm{close}}(O)=X$, $T_{\\mathrm{close}}(U)=E$, $T_{\\mathrm{close}}(X)=E$, $T_{\\mathrm{close}}(E)=E$.\n- **程序伪代码**：\n  ```\n  proc h(r):\n    write(r)\n  \n  proc k(r):\n    if b2? then close(r) else write(r)\n  \n  proc f(r):\n    if b1? then open(r)\n    h(r)\n  \n  proc g(r):\n    f(r)\n    k(r)\n  \n  main:\n    r := new Resource()  // initial state is U\n    g(r)\n    close(r)\n  ```\n  $b_1$ 和 $b_2$ 是非确定性布尔值。资源 $r$ 通过引用共享。\n- **数据流分析框架**：\n  - **方向**：前向。\n  - **敏感性**：流敏感、上下文不敏感。\n  - **分析类型**：May 分析。\n  - **抽象域**：$D=\\mathcal{P}(\\{U,O,X,E\\})$，即状态的幂集。\n  - **连接操作符**：在控制流连接处使用并集 ($\\cup$）。\n  - **转移函数提升**：对于 $S \\in D$，有 $T_{\\mathrm{op}}(S)=\\bigcup_{s \\in S} \\{T_{\\mathrm{op}}(s)\\}$。\n  - **过程间策略**：摘要。每个过程 $p$ 由一个单调转换器 $\\tau_p:D \\to D$ 进行摘要。\n- **误用定义**：如果在某个操作点的入口处，抽象状态 $S$ 包含一个非错误状态 $s \\in \\{U,O,X\\}$，而该操作对该状态是不允许的，则该操作点被标记为误用。从状态 $E$ 执行的操作不会产生新的误用标记。\n- **初始条件**：在 `main` 中，资源 $r$ 的初始状态为 $\\{U\\}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于静态程序分析和编译器理论的既定原则。它使用了标准术语（流敏感性、上下文不敏感性、may 分析、单调数据流框架）。设置完整且内部一致。目标明确定义。语言客观而精确。问题是适定的；通过系统地应用定义的分析规则可以推导出唯一的解。没有违反验证标准。\n\n### 步骤 3：结论与行动\n问题有效。我们继续进行解答。\n\n### 详细解答\n\n分析过程首先根据调用图以自底向上的方式为每个过程推导摘要转换器，然后对 `main` 过程执行自顶向下的分析以查找误用。\n\n**形式化准备**\n抽象域是格 $(D, \\subseteq)$，其中 $D = \\mathcal{P}(\\{U, O, X, E\\})$。连接操作符是 $\\cup$。操作的转移函数按定义提升到集合上。\n对于前置状态为 $S$ 的操作 `op`，其误用条件是：\n- `open(r)`：如果 $S \\cap \\{O, X\\} \\neq \\emptyset$，则为误用。\n- `write(r)`：如果 $S \\cap \\{U, X\\} \\neq \\emptyset$，则为误用。\n- `close(r)`：如果 $S \\cap \\{U, X\\} \\neq \\emptyset$，则为误用。\n\n**过程摘要的推导**\n设 $S_{in} \\in D$ 为过程入口处的抽象状态。\n\n1.  **`proc h(r)` 的摘要：**\n    该过程包含单个操作 `write(r)`。输出状态是将 `write` 转移函数应用于输入状态的结果。\n    $$ \\tau_h(S_{in}) = T_{\\mathrm{write}}(S_{in}) $$\n\n2.  **`proc k(r)` 的摘要：**\n    该过程有一个非确定性分支。对于 may 分析，我们考虑两条路径并将其结果合并。\n    - `then` 分支：`close(r)`。状态变为 $T_{\\mathrm{close}}(S_{in})$。\n    - `else` 分支：`write(r)`。状态变为 $T_{\\mathrm{write}}(S_{in})$。\n    摘要是两个分支结果的并集。\n    $$ \\tau_k(S_{in}) = T_{\\mathrm{close}}(S_{in}) \\cup T_{\\mathrm{write}}(S_{in}) $$\n\n3.  **`proc f(r)` 的摘要：**\n    该过程也包含一个非确定性分支，其后是对 `h` 的调用。\n    - `then` 分支：`open(r)`。状态变为 $T_{\\mathrm{open}}(S_{in})$。\n    - `else` 分支：状态保持为 $S_{in}$。\n    调用 `h(r)` 之前的状态是 `if-else` 结构中状态的连接：$S_{before\\_h} = S_{in} \\cup T_{\\mathrm{open}}(S_{in})$。\n    `f` 的输出是将摘要 $\\tau_h$ 应用于此状态的结果。\n    $$ \\tau_f(S_{in}) = \\tau_h(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) = T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in})) $$\n\n4.  **`proc g(r)` 的摘要：**\n    该过程由对 `f` 和 `k` 的一系列调用组成。\n    - 首先，调用 `f(r)`。此调用后的状态是 $S_{after\\_f} = \\tau_f(S_{in})$。\n    - 然后，以 $S_{after\\_f}$ 作为输入调用 `k(r)`。最终状态是 $\\tau_k(S_{after\\_f})$。\n    `g` 的摘要是 `f` 和 `k` 摘要的复合。\n    $$ \\tau_g(S_{in}) = \\tau_k(\\tau_f(S_{in})) = \\tau_k(T_{\\mathrm{write}}(S_{in} \\cup T_{\\mathrm{open}}(S_{in}))) $$\n\n**`main` 的前向分析**\n我们现在从 `main` 的入口开始追踪执行。\n\n1.  `r := new Resource()`：$r$ 的抽象状态变为 $S_0 = \\{U\\}$。\n\n2.  调用 `g(r)`：以输入状态 $S_{g,in} = S_0 = \\{U\\}$ 对 `g` 进行分析。\n    - 以输入 $S_{f,in} = \\{U\\}$ 调用 `f(r)`。\n        - 在 `f` 内部：有一个非确定性选择。\n            - `then` 分支（在 `f1` 点的 `open(r)`）：\n                - 前置状态：$\\{U\\}$。误用检查：$\\{U\\} \\cap \\{O, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{open}}(\\{U\\}) = \\{O\\}$。\n            - `else` 分支：状态保持为 $\\{U\\}$。\n        - 调用 `h(r)` 之前的状态是连接后的结果：$S_{h,in} = \\{O\\} \\cup \\{U\\} = \\{U, O\\}$。\n        - 以输入 $S_{h,in} = \\{U, O\\}$ 调用 `h(r)`。\n            - 在 `h` 内部，在 `write(r)` 处（`h1` 点）：\n                - 前置状态：$\\{U, O\\}$。误用检查：$\\{U, O\\} \\cap \\{U, X\\} = \\{U\\} \\neq \\emptyset$。**在 `h1` 处标记误用**。\n                - 后置状态：$T_{\\mathrm{write}}(\\{U, O\\}) = T_{\\mathrm{write}}(\\{U\\}) \\cup T_{\\mathrm{write}}(\\{O\\}) = \\{E\\} \\cup \\{O\\} = \\{O, E\\}$。\n        - 从 `h` 返回到 `f` 的状态是 $\\{O, E\\}$。这也是 `f` 的退出状态，因此 $\\tau_f(\\{U\\}) = \\{O, E\\}$。\n    - `f(r)` 返回后，`g` 中的状态是 $S_{g,mid} = \\{O, E\\}$。\n    - 以输入 $S_{k,in} = \\{O, E\\}$ 调用 `k(r)`。\n        - 在 `k` 内部：有一个非确定性选择。\n            - `then` 分支（在 `k1` 点的 `close(r)`）：\n                - 前置状态：$\\{O, E\\}$。误用检查：$\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{close}}(\\{O, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} = \\{X, E\\}$。\n            - `else` 分支（在 `k2` 点的 `write(r)`）：\n                - 前置状态：$\\{O, E\\}$。误用检查：$\\{O, E\\} \\cap \\{U, X\\} = \\emptyset$。**没有误用**。\n                - 后置状态：$T_{\\mathrm{write}}(\\{O, E\\}) = T_{\\mathrm{write}}(\\{O\\}) \\cup T_{\\mathrm{write}}(\\{E\\}) = \\{O\\} \\cup \\{E\\} = \\{O, E\\}$。\n        - `k` 退出时的状态是连接后的结果：$\\{X, E\\} \\cup \\{O, E\\} = \\{O, X, E\\}$。因此，$\\tau_k(\\{O, E\\}) = \\{O, X, E\\}$。\n    - 从 `k` 返回到 `g`（并因此退出 `g`）的状态是 $\\{O, X, E\\}$。所以，$\\tau_g(\\{U\\}) = \\{O, X, E\\}$。\n\n3.  `g(r)` 返回后，`main` 中的抽象状态是 $S_1 = \\{O, X, E\\}$。这是一个必需的中间结果：`main` 最终 `close` 点的抽象状态。\n\n4.  执行 `close(r)`（在 `main` 中的 `m2` 点）：\n    - 前置状态：$\\{O, X, E\\}$。\n    - 误用检查：$\\{O, X, E\\} \\cap \\{U, X\\} = \\{X\\} \\neq \\emptyset$。**在 `m2` 处标记误用**。\n    - 后置状态：$T_{\\mathrm{close}}(\\{O, X, E\\}) = T_{\\mathrm{close}}(\\{O\\}) \\cup T_{\\mathrm{close}}(\\{X\\}) \\cup T_{\\mathrm{close}}(\\{E\\}) = \\{X\\} \\cup \\{E\\} \\cup \\{E\\} = \\{X, E\\}$。\n\n**结论**\n分析揭示了在两个不同的操作点存在误用：\n1.  过程 `h` 中的 `write(r)` 操作（`h1` 点）。\n2.  `main` 中的最终 `close(r)` 操作（`m2` 点）。\n\n被标记的不同操作点的总数是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3647964"}]}