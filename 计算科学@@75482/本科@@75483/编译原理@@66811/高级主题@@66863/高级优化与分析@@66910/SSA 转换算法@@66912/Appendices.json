{"hands_on_practices": [{"introduction": "本练习将指导你完成将代码转换为静态单赋值（SSA）形式的核心算法。你将把支配树和支配边界的概念应用于给定的控制流图（CFG），以系统地确定 $\\phi$函数的最小化放置位置，这是编译器构造中的一项基本技能。[@problem_id:3670674]", "problem": "考虑以下一个过程的控制流图 (CFG)，其入口块为 $B_1$，出口块为 $B_8$。基本块之间的有向边如下：\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$, $B_3 \\to B_5$\n- $B_4 \\to B_6$\n- $B_5 \\to B_6$\n- $B_6 \\to B_2$, $B_6 \\to B_7$\n- $B_7 \\to B_8$\n\n每个块包含如下所示的线性代码，其中涉及对变量 $x$ 和 $z$ 的赋值：\n- $B_1$: $x := 0$; $z := 0$\n- $B_2$: $x := x + 1$\n- $B_3$: $z := 1$\n- $B_4$: (无对 $x$ 或 $z$ 的定义)\n- $B_5$: $x := 2$\n- $B_6$: $z := z + x$\n- $B_7$: (无对 $x$ 或 $z$ 的定义)\n- $B_8$: (无对 $x$ 或 $z$ 的定义)\n\n任务：\n- 构建以 $B_1$ 为根的 CFG 的支配树。\n- 对每个块 $B_i$（$i \\in \\{1,2,3,4,5,6,7,8\\}$），计算其支配边界 $\\mathrm{DF}(B_i)$。\n- 使用经典的最小静态单赋值 (SSA) 形式构建方法（Cytron 等人），基于迭代支配边界，推导出变量 $x$ 和 $z$ 的最小$\\phi$函数放置。假设遵循以下约定：不执行基于活跃度的剪枝，并且不在已经包含某个变量定义的块中为该变量插入 $\\phi$函数。\n\n最后，报告一个单一的量：为变量 $x$ 和 $z$ 插入的 $\\phi$函数总数。以整数形式提供您的答案。无需四舍五入，也无需单位。", "solution": "求解过程需要三个主要步骤：\n1. 构建支配树。\n2. 计算所有基本块的支配边界。\n3. 应用迭代支配边界算法来确定 $\\phi$函数的放置位置。\n\n### 步骤 1：支配树构建\n\n如果从入口块到块 $N$ 的每条路径都必须经过块 $D$，那么块 $D$ 支配块 $N$。块 $N$ 的直接支配者，记作 $\\mathrm{idom}(N)$，是 $N$ 的唯一支配者，且它不支配 $N$ 的任何其他支配者。支配树由除入口块外的所有块 $N$ 的边 $(\\mathrm{idom}(N), N)$ 构成。入口块是 $B_1$。\n\n通过分析给定 CFG 中的路径：\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$。\n- 任何到 $B_2$ 的路径都必须经过 $B_1$。路径可以是 $B_1 \\to B_2$ 或通过循环 $B_1 \\to \\dots \\to B_6 \\to B_2$。所有从入口到 $B_2$ 的路径都必须以 $B_1$ 开始。因此，$\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$，且 $\\mathrm{idom}(B_2) = B_1$。\n- 任何到 $B_3$ 的路径都必须是 $B_1 \\to B_3$。因此，$\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$，且 $\\mathrm{idom}(B_3) = B_1$。\n- 到 $B_4$ 的路径有 $B_1 \\to B_2 \\to B_4$ 和 $B_1 \\to B_3 \\to B_4$。所有到 $B_4$ 的路径上，除 $B_4$ 自身外唯一的公共块是 $B_1$。因此，$\\mathrm{dom}(B_4) = \\{B_1, B_4\\}$，且 $\\mathrm{idom}(B_4) = B_1$。\n- 任何到 $B_5$ 的路径都必须经过 $B_3$ ($B_1 \\to B_3 \\to B_5$)。因此，$\\mathrm{dom}(B_5) = \\{B_1, B_3, B_5\\}$，且 $\\mathrm{idom}(B_5) = B_3$。\n- 到 $B_6$ 的路径可以来自 $B_4$ 或 $B_5$。示例路径有 $B_1 \\to B_2 \\to B_4 \\to B_6$ 和 $B_1 \\to B_3 \\to B_5 \\to B_6$。所有从入口到 $B_6$ 的路径上唯一的公共块是 $B_1$。因此，$\\mathrm{dom}(B_6) = \\{B_1, B_6\\}$，且 $\\mathrm{idom}(B_6) = B_1$。\n- 任何到 $B_7$ 的路径都必须来自 $B_6$。因此，$B_6$ 支配 $B_7$。由于 $B_1$ 支配 $B_6$，所以 $B_1$ 也支配 $B_7$。因此，$\\mathrm{dom}(B_7) = \\{B_1, B_6, B_7\\}$，且 $\\mathrm{idom}(B_7) = B_6$。\n- 任何到 $B_8$ 的路径都必须来自 $B_7$。因此，$B_7$ 支配 $B_8$。根据传递性，$B_6$ 和 $B_1$ 也支配 $B_8$。因此，$\\mathrm{dom}(B_8) = \\{B_1, B_6, B_7, B_8\\}$，且 $\\mathrm{idom}(B_8) = B_7$。\n\n以 $B_1$ 为根的支配树由以下直接支配关系定义：\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_1$\n- $\\mathrm{idom}(B_7) = B_6$\n- $\\mathrm{idom}(B_8) = B_7$\n\n### 步骤 2：支配边界计算\n\n一个块 $X$ 的支配边界，记作 $\\mathrm{DF}(X)$，是所有满足以下条件的块 $Y$ 的集合：$X$ 支配 $Y$ 的一个前驱，但 $X$ 并不严格支配 $Y$。如果 $X$ 支配 $Y$ 且 $X \\neq Y$，则块 $X$ 严格支配 $Y$。\n\n- $\\mathrm{DF}(B_1)$：$B_1$ 严格支配它所支配的每一个块（除了它自己）。不存在一个块 $Y$ 使得 $B_1$ 不严格支配它（除了 $Y=B_1$，它没有前驱）。因此，$\\mathrm{DF}(B_1) = \\emptyset$。\n- $\\mathrm{DF}(B_2)$：$B_2$ 支配 $B_4$ 的一个前驱 $B_2$。然而，$B_2$ 并不严格支配 $B_4$（因为 $\\mathrm{idom}(B_4)=B_1$）。因此，$B_4 \\in \\mathrm{DF}(B_2)$。不存在其他这样的块。$\\mathrm{DF}(B_2) = \\{B_4\\}$。\n- $\\mathrm{DF}(B_3)$：\n    - 对于 $Y=B_4$，$B_3 \\in \\mathrm{pred}(B_4)$，且 $B_3$ 支配其自身。$B_3$ 不严格支配 $B_4$。因此，$B_4 \\in \\mathrm{DF}(B_3)$。\n    - 对于 $Y=B_6$，$B_5 \\in \\mathrm{pred}(B_6)$。$B_3$ 支配 $B_5$。$B_3$ 不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_3)$。\n    - $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$。\n- $\\mathrm{DF}(B_4)$：$B_4 \\in \\mathrm{pred}(B_6)$。$B_4$ 支配其自身。$B_4$ 不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_4)$。$\\mathrm{DF}(B_4) = \\{B_6\\}$。\n- $\\mathrm{DF}(B_5)$：$B_5 \\in \\mathrm{pred}(B_6)$。$B_5$ 支配其自身。$B_5$ 不严格支配 $B_6$。因此，$B_6 \\in \\mathrm{DF}(B_5)$。$\\mathrm{DF}(B_5) = \\{B_6\\}$。\n- $\\mathrm{DF}(B_6)$：由于存在回边，$B_6 \\in \\mathrm{pred}(B_2)$。$B_6$ 支配其自身。$B_6$ 不严格支配 $B_2$。因此，$B_2 \\in \\mathrm{DF}(B_6)$。$B_6$ 严格支配其另一个后继 $B_7$。$\\mathrm{DF}(B_6) = \\{B_2\\}$。\n- $\\mathrm{DF}(B_7)$：$B_7$ 的唯一后继是 $B_8$，且 $B_7$ 严格支配 $B_8$。因此，$\\mathrm{DF}(B_7) = \\emptyset$。\n- $\\mathrm{DF}(B_8)$：该块没有后继。因此，$\\mathrm{DF}(B_8) = \\emptyset$。\n\n支配边界总结：\n- $\\mathrm{DF}(B_1) = \\emptyset$\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$\n- $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$\n- $\\mathrm{DF}(B_4) = \\{B_6\\}$\n- $\\mathrm{DF}(B_5) = \\{B_6\\}$\n- $\\mathrm{DF}(B_6) = \\{B_2\\}$\n- $\\mathrm{DF}(B_7) = \\emptyset$\n- $\\mathrm{DF}(B_8) = \\emptyset$\n\n### 步骤 3：最小$\\phi$函数放置\n\n我们使用迭代支配边界 (IDF) 算法。对每个变量 $v$，我们计算需要 $\\phi$函数的块的集合 $\\Phi_v$。算法如下：\n1. 初始化一个集合 $\\Phi_v = \\emptyset$ 和一个工作列表 $W$，其中包含变量 $v$ 初始定义的所有块。令这个块的集合为 $\\mathrm{Defs}_v$。\n2. 当 $W$ 非空时，从 $W$ 中取出一个块 $N$。\n3. 对于每个块 $Y \\in \\mathrm{DF}(N)$：\n   如果 $Y \\notin \\Phi_v$，并且根据题目约束，$Y \\notin \\mathrm{Defs}_v$，则将 $Y$ 添加到 $\\Phi_v$ 和工作列表 $W$ 中。\n\n**变量 $x$**：\n- 包含初始定义的块集合为 $\\mathrm{Defs}_x = \\{B_1, B_2, B_5\\}$。\n- 初始化：$\\Phi_x = \\emptyset$，$W = \\{B_1, B_2, B_5\\}$。\n- 弹出 $B_1$：$\\mathrm{DF}(B_1) = \\emptyset$。$W = \\{B_2, B_5\\}$。\n- 弹出 $B_2$：$\\mathrm{DF}(B_2) = \\{B_4\\}$。$B_4 \\notin \\mathrm{Defs}_x$ 且 $B_4 \\notin \\Phi_x$。将 $B_4$ 加入 $\\Phi_x$ 和 $W$。$\\Phi_x = \\{B_4\\}$，$W = \\{B_5, B_4\\}$。\n- 弹出 $B_5$：$\\mathrm{DF}(B_5) = \\{B_6\\}$。$B_6 \\notin \\mathrm{Defs}_x$ 且 $B_6 \\notin \\Phi_x$。将 $B_6$ 加入 $\\Phi_x$ 和 $W$。$\\Phi_x = \\{B_4, B_6\\}$，$W = \\{B_4, B_6\\}$。\n- 弹出 $B_4$：$\\mathrm{DF}(B_4) = \\{B_6\\}$。$B_6 \\in \\Phi_x$。无变化。$W = \\{B_6\\}$。\n- 弹出 $B_6$：$\\mathrm{DF}(B_6) = \\{B_2\\}$。$B_2 \\in \\mathrm{Defs}_x$。根据题目约束，不添加 $\\phi$函数。无变化。$W = \\emptyset$。\n- 工作列表为空。变量 $x$ 的最终放置集合是 $\\Phi_x = \\{B_4, B_6\\}$。\n- 变量 $x$ 的$\\phi$函数数量：$|\\Phi_x| = 2$。\n\n**变量 $z$**：\n- 包含初始定义的块集合为 $\\mathrm{Defs}_z = \\{B_1, B_3, B_6\\}$。\n- 初始化：$\\Phi_z = \\emptyset$，$W = \\{B_1, B_3, B_6\\}$。\n- 弹出 $B_1$：$\\mathrm{DF}(B_1) = \\emptyset$。$W = \\{B_3, B_6\\}$。\n- 弹出 $B_3$：$\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$。\n    - 对于 $B_4$：$B_4 \\notin \\mathrm{Defs}_z$ 且 $B_4 \\notin \\Phi_z$。将 $B_4$ 加入 $\\Phi_z$ 和 $W$。$\\Phi_z = \\{B_4\\}$，$W = \\{B_6, B_4\\}$。\n    - 对于 $B_6$：$B_6 \\in \\mathrm{Defs}_z$。不添加 $\\phi$函数。\n- 弹出 $B_6$：$\\mathrm{DF}(B_6) = \\{B_2\\}$。$B_2 \\notin \\mathrm{Defs}_z$ 且 $B_2 \\notin \\Phi_z$。将 $B_2$ 加入 $\\Phi_z$ 和 $W$。$\\Phi_z = \\{B_4, B_2\\}$，$W = \\{B_4, B_2\\}$。\n- 弹出 $B_4$：$\\mathrm{DF}(B_4) = \\{B_6\\}$。$B_6 \\in \\mathrm{Defs}_z$。不添加 $\\phi$函数。$W = \\{B_2\\}$。\n- 弹出 $B_2$：$\\mathrm{DF}(B_2) = \\{B_4\\}$。$B_4 \\in \\Phi_z$。无变化。$W = \\emptyset$。\n- 工作列表为空。变量 $z$ 的最终放置集合是 $\\Phi_z = \\{B_2, B_4\\}$。\n- 变量 $z$ 的$\\phi$函数数量：$|\\Phi_z| = 2$。\n\n### 步骤 4：最终计算\n\n插入的$\\phi$函数总数是每个变量计数之和。\n总$\\phi$函数 = ($x$ 的数量) + ($z$ 的数量) = $2 + 2 = 4$。\n所需的$\\phi$函数是：\n- 对于 $x$：在 $B_4$ 和 $B_6$ 中。\n- 对于 $z$：在 $B_2$ 和 $B_4$ 中。\n\n总数为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3670674"}, {"introduction": "在 SSA 表示上执行优化后，程序必须被转换回线性的指令序列。本练习聚焦于消除 $\\phi$函数的关键步骤，通过将其并行赋值语义转换为最小系列的顺序 `mov` 指令，来解决寄存器分配和代码生成中的一个常见挑战。[@problem_id:3670685]", "problem": "给定一个控制流图，其中有三个前驱块 $B_1$、$B_2$、$B_3$ 汇合于一个汇合块 $J$。该程序处于静态单赋值（SSA）形式，且 $J$ 包含四个定义了 $a_4$、$b_4$、$c_4$ 和 $d_4$ 的 $\\phi$函数。寄存器分配后，以下寄存器分配关系成立：\n\n- 在 $J$ 的入口处，目标变量分配如下：$a_4$ 在 $r_1$ 中，$b_4$ 在 $r_2$ 中，$c_4$ 在 $r_3$ 中，$d_4$ 在 $r_4$ 中。\n- 在 $B_1$ 的出口处，活跃的 SSA 名称位于寄存器中：$a_1$ 在 $r_2$ 中，$b_1$ 在 $r_3$ 中，$c_1$ 在 $r_4$ 中，$d_1$ 在 $r_1$ 中。\n- 在 $B_2$ 的出口处，活跃的 SSA 名称位于寄存器中：$a_2$ 在 $r_1$ 中，$b_2$ 在 $r_4$ 中，$c_2$ 在 $r_2$ 中，$d_2$ 在 $r_3$ 中。\n- 在 $B_3$ 的出口处，活跃的 SSA 名称位于寄存器中：$a_3$ 在 $r_3$ 中，$b_3$ 在 $r_2$ 中，$c_3$ 在 $r_1$ 中，$d_3$ 在 $r_4$ 中。\n\n$J$ 中的 $\\phi$函数如下：\n- $a_4 := \\phi(B_1: a_1, B_2: a_2, B_3: a_3)$\n- $b_4 := \\phi(B_1: b_1, B_2: b_2, B_3: b_3)$\n- $c_4 := \\phi(B_1: c_1, B_2: c_2, B_3: c_3)$\n- $d_4 := \\phi(B_1: d_1, B_2: d_2, B_3: d_3)$\n\n为了转换出 SSA 形式，您必须在每个前驱块的末尾插入一个单一的并行复制（parallel copy），以实现所有去往 $J$ 的 $\\phi$ 参数。并行复制是一组必须表现得如同同时发生的赋值。\n\n您需要通过将每个并行复制替换为一系列形式为 mov dest, src 的寄存器到寄存器移动指令来重构非 SSA 代码，同时保留并行复制的语义。每条边最多可以使用一个临时寄存器 $t$（不同于 $r_1$、$r_2$、$r_3$、$r_4$），并且不得插入任何不必要的移动指令。一个恒等赋值（例如，$r_2 := r_2$）不应作为移动指令发出。\n\n假设没有其他约束（例如，没有内存溢出，并且在边结尾部分（edge epilogue）内有无限的指令调度自由度），在所有三条边 $B_1 \\to J$、$B_2 \\to J$ 和 $B_3 \\to J$ 上必须插入的移动指令的最小总数是多少？请用一个整数表示您的答案。", "solution": "解决并行复制 `(d_1, d_2, ..., d_n) := (s_1, s_2, ..., s_n)` 的通用方法是将其建模为一个有向图，其中 `$d_i$` 是目标寄存器，`$s_i$` 是源寄存器。图的节点是寄存器，一条从 `$u$` 到 `$v$` 的有向边（`$u \\to v$`）代表赋值 `$v := u$`。该图可以被划分为不相交的路径和环。\n- 一个恒等赋值（`$d_i := d_i$`）对应一个自环（`$r \\to r$`），需要 `$0$` 条移动指令。\n- 一组形成路径的赋值可以通过与赋值数量相等的移动指令数来解决。\n- 一组形成长度为 `$k > 1$` 的环的赋值需要一个临时寄存器来打破该环。解决这样一个环所需的最少移动指令数是 `$k+1$`。\n\n我们将分析三个前驱块 `$B_1, B_2, B_3$` 中每一个所需的并行复制。\n\n### 边 $B_1 \\to J$\n\n汇合块 `$J$` 处的 $\\phi$函数指定了来自 `$B_1$` 的哪些 SSA 名称为新的 SSA 名称 `$a_4, b_4, c_4, d_4$` 提供值。`$J$` 入口处和 `$B_1$` 出口处的寄存器分配定义了所需的寄存器到寄存器的传输。\n\n- 在 `$J$` 的入口处：`$a_4$` 在 `$r_1$` 中，`$b_4$` 在 `$r_2$` 中，`$c_4$` 在 `$r_3$` 中，`$d_4$` 在 `$r_4$` 中。\n- 从 `$B_1$` 的 $\\phi$函数可知：`$a_4 \\leftarrow a_1, b_4 \\leftarrow b_1, c_4 \\leftarrow c_1, d_4 \\leftarrow d_1$`。\n- 在 `$B_1$` 的出口处：`$a_1$` 在 `$r_2$` 中，`$b_1$` 在 `$r_3$` 中，`$c_1$` 在 `$r_4$` 中，`$d_1$` 在 `$r_1$` 中。\n\n综合这些信息，我们得出在边 `$B_1 \\to J$` 上所需的并行复制：\n- 为了将 `$a_1$` 放入 `$r_1$`（`$a_4$` 必须在的位置），我们需要 `$r_1 := r_2$`。\n- 为了将 `$b_1$` 放入 `$r_2$`（`$b_4$` 必须在的位置），我们需要 `$r_2 := r_3$`。\n- 为了将 `$c_1$` 放入 `$r_3$`（`$c_4$` 必须在的位置），我们需要 `$r_3 := r_4$`。\n- 为了将 `$d_1$` 放入 `$r_4$`（`$d_4$` 必须在的位置），我们需要 `$r_4 := r_1$`。\n\n这些移动的依赖图包含边 `$r_2 \\to r_1$`、`$r_3 \\to r_2$`、`$r_4 \\to r_3$` 和 `$r_1 \\to r_4$`。它们形成了一个长度为 `$k=4$` 的环：`$r_1 \\to r_4 \\to r_3 \\to r_2 \\to r_1$`。使用一个临时寄存器 `$t$`，这个环可以通过 `$k+1 = 4+1 = 5$` 条移动指令来打破。例如：\n1. `mov t, r_1`\n2. `mov r_1, r_2`\n3. `mov r_2, r_3`\n4. `mov r_3, r_4`\n5. `mov r_4, t`\n`$B_1 \\to J$` 的移动指令数是 `$5$`。\n\n### 边 $B_2 \\to J$\n\n- 从 `$B_2$` 的 $\\phi$函数可知：`$a_4 \\leftarrow a_2, b_4 \\leftarrow b_2, c_4 \\leftarrow c_2, d_4 \\leftarrow d_2$`。\n- 在 `$B_2$` 的出口处：`$a_2$` 在 `$r_1$` 中，`$b_2$` 在 `$r_4$` 中，`$c_2$` 在 `$r_2$` 中，`$d_2$` 在 `$r_3$` 中。\n\n在边 `$B_2 \\to J$` 上所需的并行复制是：\n- `$r_1 := r_1$` (对于 `$a_4 \\leftarrow a_2$`)\n- `$r_2 := r_4$` (对于 `$b_4 \\leftarrow b_2$`)\n- `$r_3 := r_2$` (对于 `$c_4 \\leftarrow c_2$`)\n- `$r_4 := r_3$` (对于 `$d_4 \\leftarrow d_2$`)\n\n这些移动的依赖图有：\n- 一个自环 `$r_1 \\to r_1$`，这是一个恒等赋值，需要 `$0$` 条移动指令。\n- 一个长度为 `$k=3$` 的环：`$r_2 \\to r_3 \\to r_4 \\to r_2$`。这需要 `$k+1 = 3+1 = 4$` 条移动指令。\n`$B_2 \\to J$` 的总移动指令数是 `$0 + 4 = 4$`。\n\n### 边 $B_3 \\to J$\n\n- 从 `$B_3$` 的 $\\phi$函数可知：`$a_4 \\leftarrow a_3, b_4 \\leftarrow b_3, c_4 \\leftarrow c_3, d_4 \\leftarrow d_3$`。\n- 在 `$B_3$` 的出口处：`$a_3$` 在 `$r_3$` 中，`$b_3$` 在 `$r_2$` 中，`$c_3$` 在 `$r_1$` 中，`$d_3$` 在 `$r_4$` 中。\n\n在边 `$B_3 \\to J$` 上所需的并行复制是：\n- `$r_1 := r_3$` (对于 `$a_4 \\leftarrow a_3$`)\n- `$r_2 := r_2$` (对于 `$b_4 \\leftarrow b_3$`)\n- `$r_3 := r_1$` (对于 `$c_4 \\leftarrow c_3$`)\n- `$r_4 := r_4$` (对于 `$d_4 \\leftarrow d_3$`)\n\n这些移动的依赖图有：\n- 两个自环，`$r_2 \\to r_2$` 和 `$r_4 \\to r_4$`。每个需要 `$0$` 条移动指令。\n- 一个长度为 `$k=2$` 的环：`$r_1 \\to r_3 \\to r_1$`。这是一个交换操作，需要 `$k+1 = 2+1 = 3$` 条移动指令。\n`$B_3 \\to J$` 的总移动指令数是 `$0 + 0 + 3 = 3$`。\n\n### 移动指令总数\n\n最少移动指令总数是三条边各自所需移动指令数的总和。\n总移动数 = (`$B_1 \\to J$` 的移动数) + (`$B_2 \\to J$` 的移动数) + (`$B_3 \\to J$` 的移动数)\n总移动数 = `$5 + 4 + 3 = 12$`。", "answer": "$$\n\\boxed{12}\n$$", "id": "3670685"}, {"introduction": "经典的 SSA 构造算法虽然正确，但有时会插入“无用”的 $\\phi$函数，即其结果从未被使用。最后的这个练习将探讨剪枝 SSA（Pruned SSA），这是一种利用活性分析来消除此类不必要 $\\phi$函数的优化方法，从而产生更紧凑、更高效的中间表示。你将比较不同剪枝策略的结果，以理解它们之间的权衡。[@problem_id:3670701]", "problem": "考虑将一个程序转换为静态单赋值（SSA）形式的任务，其中每个变量只被赋值一次，并且$\\phi$函数在连接点处合并来自多个前驱的值。使用以下基本定义作为您推理的基础。\n\n- 控制流图（CFG）是一个有向图，其节点是基本块，其边代表块之间可能的控制流。如果从入口到节点$n$的每条路径都包含节点$d$，则称节点$d$支配节点$n$。节点$d$的支配边界（DF）是所有满足以下条件的节点$n$的集合：$d$支配$n$的一个前驱，但$d$并不严格支配$n$。\n- 在通过迭代支配边界的经典SSA构造方法中，对于变量$v$，$\\phi$函数被插入到包含对$v$赋值的块的DF中，并根据需要对新插入的$\\phi$定义进行迭代，直到达到不动点。\n- 剪枝SSA（Pruned SSA）会移除变量$v$在任何$v$在原始程序中不是活跃传入（live-in）的块中的$\\phi$函数。如果从某个点存在一条到变量$v$的某个使用的路径，并且在该路径上，$v$在该使用之前没有被重新定义，那么变量$v$在该点是活跃传入的。\n- 考虑一种保守的基于活跃度的剪枝变体，它通过将变量$v$在任何存在从该块到$v$的使用的路径的块中都视为活跃传入，从而过近似（over-approximates）$v$的活跃度，这种方法忽略了路径中间的重新定义。这种变体可能会保留剪枝SSA会移除的$\\phi$函数。\n\n给定以下CFG（条件$p$、$q$、$r$是任意布尔表达式；控制边由“goto”转换指定）：\n\n- 块 $B_0$：入口；跳转到 $B_1$。\n- 块 $B_1$：如果 $p$ 则跳转到 $B_2$ 否则跳转到 $B_3$。\n- 块 $B_2$：$x := 1$; $y := 1$; 跳转到 $B_4$。\n- 块 $B_3$：如果 $q$ 则跳转到 $B_5$ 否则跳转到 $B_6$。\n- 块 $B_5$：$x := 2$; 跳转到 $B_4$。\n- 块 $B_6$：$y := 3$; 跳转到 $B_4$。\n- 块 $B_4$：$B_2$、$B_5$、$B_6$的连接点；跳转到 $B_7$。\n- 块 $B_7$：$y := 4$; 如果 $r$ 则跳转到 $B_8$ 否则跳转到 $B_9$。\n- 块 $B_8$：$x := 5$; $t := x + 1$; 跳转到 $B_{10}$。\n- 块 $B_9$：$u := x$; 跳转到 $B_{10}$。\n- 块 $B_{10}$：$w := y + 1$; 退出。\n\n观察到：\n- $B_2$和$B_6$中对$y$的赋值，在任何使用之前，都被$B_7$中一个无条件的重定义$y := 4$所跟随，这使得早前的对$y$的赋值成为死代码（dead）。因此，$y$在$B_2$和$B_6$中有部分死赋值。\n- $B_2$和$B_5$中对$x$的赋值在路径$B_4 \\rightarrow B_7 \\rightarrow B_9$上被使用，但在路径$B_4 \\rightarrow B_7 \\rightarrow B_8$上，在$B_8$中被重新定义。因此，$x$有部分死赋值。\n\n仅使用上述定义并从第一性原理出发进行推理：\n- 推导由经典迭代支配边界方法为$x$和$y$生成的$\\phi$插入块集合。将这些集合表示为$S_x^{\\mathrm{DF}}$和$S_y^{\\mathrm{DF}}$。\n- 使用精确活跃度（即，考虑了重新定义的活跃度）为$x$和$y$推导剪枝SSA的$\\phi$插入块集合。将这些集合表示为$S_x^{\\mathrm{pruned}}$和$S_y^{\\mathrm{pruned}}$。\n- 为$x$和$y$推导基于保守活跃度的剪枝变体的$\\phi$插入块集合（即，使用当从使用点传播时忽略重新定义的过近似活跃度）。将这些集合表示为$S_x^{\\mathrm{live}}$和$S_y^{\\mathrm{live}}$。\n\n证明对于上述CFG，$S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$但$S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$。最后，计算标量\n$$E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right|.$$\n将$E$以单个整数形式给出。无需四舍五入。无需单位。", "solution": "我们将按照以下步骤进行解答：\n1.  分析CFG以确定支配关系和支配边界（DF）。\n2.  应用迭代DF算法找到初始的$\\phi$插入集合，$S_x^{\\mathrm{DF}}$和$S_y^{\\mathrm{DF}}$。\n3.  对$x$和$y$执行精确活跃度分析，以推导剪枝后的集合，$S_x^{\\mathrm{pruned}}$和$S_y^{\\mathrm{pruned}}$。\n4.  执行保守的活跃度分析，以推导集合$S_x^{\\mathrm{live}}$和$S_y^{\\mathrm{live}}$。\n5.  比较结果并计算$E$的值。\n\n**步骤1：支配和支配边界分析**\n\nCFG的结构是给定的。首先，我们确定每个基本块的支配节点。如果从入口块（$B_0$）到块$n$的每条路径都必须经过块$d$，则块$d$支配块$n$。根据CFG，直接支配节点（`idom`）如下：\n- $\\mathrm{idom}(B_1) = B_0$\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_3$\n- $\\mathrm{idom}(B_7) = B_4$\n- $\\mathrm{idom}(B_8) = B_7$\n- $\\mathrm{idom}(B_9) = B_7$\n- $\\mathrm{idom}(B_{10}) = B_7$\n\n节点$d$的支配边界$\\mathrm{DF}(d)$是所有满足以下条件的节点$n$的集合：$d$支配$n$的一个前驱，但$d$不严格支配$n$。我们需要包含对$x$或$y$原始赋值的块的DF。这些块是$B_2, B_5, B_6, B_7, B_8$。\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$：$B_2$支配其自身（$B_4$的一个前驱），但不严格支配$B_4$。\n- $\\mathrm{DF}(B_5) = \\{B_4\\}$：$B_5$支配其自身（$B_4$的一个前驱），但不严格支配$B_4$。\n- $\\mathrm{DF}(B_6) = \\{B_4\\}$：$B_6$支配其自身（$B_4$的一个前驱），但不严格支配$B_4$。\n- $\\mathrm{DF}(B_7) = \\{B_{10}\\}$：$B_7$支配其后继$B_8$和$B_9$（$B_{10}$的前驱），但$B_7$不严格支配$B_{10}$（它是直接支配节点）。连接点在$B_{10}$。\n- $\\mathrm{DF}(B_8) = \\{B_{10}\\}$：$B_8$支配其自身（$B_{10}$的一个前驱），但不严格支配$B_{10}$。\n- 对于迭代算法，我们还需要新$\\phi$函数所在块的DF：\n- $\\mathrm{DF}(B_4) = \\{B_7\\}$：此分析错误。$B_4$的唯一后继是$B_7$，且$B_4$严格支配$B_7$。因此，$\\mathrm{DF}(B_4) = \\emptyset$。\n- $\\mathrm{DF}(B_{10}) = \\emptyset$。\n\n**步骤2：经典迭代支配边界（$S_x^{\\mathrm{DF}}$, $S_y^{\\mathrm{DF}}$）**\n\n我们通过从包含对变量$v$赋值的节点集合开始，并将这些节点的支配边界迭代地添加到工作列表中，直到达到不动点，来计算$v$的$\\phi$函数插入节点集合。\n\n对于变量$x$：\n包含原始赋值的块集合是$A_x = \\{B_2, B_5, B_8\\}$。\n1.  我们计算DF的初始块集合是$A_x$。\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_5) \\cup \\mathrm{DF}(B_8) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$。令此为$P_1 = \\{B_4, B_{10}\\}$。\n3.  现在对$P_1$中的新定义进行迭代。$\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\emptyset \\cup \\emptyset = \\emptyset$。\n4.  这没有为我们的$\\phi$节点集合添加新块。该过程已达到不动点。\n插入块的集合是$S_x^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$。\n\n对于变量$y$：\n包含原始赋值的块集合是$A_y = \\{B_2, B_6, B_7\\}$。\n1.  初始块集合是$A_y$。\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_6) \\cup \\mathrm{DF}(B_7) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$。令此为$P_1 = \\{B_4, B_{10}\\}$。\n3.  对$P_1$进行迭代：$\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\emptyset \\cup \\emptyset = \\emptyset$。\n4.  没有添加新块。过程终止。\n插入块的集合是$S_y^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$。\n\n**步骤3：剪枝SSA（$S_x^{\\mathrm{pruned}}$, $S_y^{\\mathrm{pruned}}$）**\n\n如果变量在块$B$不是活跃传入的，剪枝SSA会从块$B$中移除该变量的$\\phi$函数。我们执行标准的后向活跃度分析。如果一个变量的值可能在其后继块或后续某条路径上被读取，则该变量在该块是活跃传入的。\n\n对于变量$x$：\n- $x$的向上暴露使用（Upward-exposed uses）：$B_9$中的$u := x$。$B_8$中的使用（$t := x + 1$）不是向上暴露的，因为它前面有同一块中的定义（$x := 5$）。所以，$\\mathrm{use}_x(B_9) = \\{x\\}$。\n- $x$的定义：$\\mathrm{def}_x(B_2) = \\{x\\}$, $\\mathrm{def}_x(B_5) = \\{x\\}$, $\\mathrm{def}_x(B_8) = \\{x\\}$。\n- 活跃度计算（从$B_9$向后流动）：\n  - $x$在$B_9$是活跃传入的。\n  - 这使得$x$在$B_7$是活跃传出的。由于$B_7$没有重新定义$x$，因此$x$在$B_7$是活跃传入的。\n  - 这使得$x$在$B_4$是活跃传出的。由于$B_4$没有重新定义$x$，因此$x$在$B_4$是活跃传入的。\n  - $x$的活跃度从$B_4$向后传播到其前驱$B_2, B_5, B_6$。\n  - 在$B_2$和$B_5$中，$x$被重新定义，所以活跃度被终止（killed）（$x$在$B_2$或$B_5$不是活跃传入的）。\n  - 在$B_6$中，$x$没有被重新定义，所以$x$是活跃传入的。\n  - 活跃度从$B_2, B_3, \\dots$向上层传播到入口。\n$x$是活跃传入的块的集合是$\\{B_0, B_1, B_3, B_4, B_6, B_7, B_9\\}$。\n- 对$S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$进行剪枝：\n  - $x$在$B_4$是活跃传入的吗？是。我们保留$\\phi$函数。\n  - $x$在$B_{10}$是活跃传入的吗？否。我们剪枝$\\phi$函数。\n- 因此，$S_x^{\\mathrm{pruned}} = \\{B_4\\}$。\n\n对于变量$y$：\n- $y$的向上暴露使用：$B_{10}$中的$w := y + 1$。所以，$\\mathrm{use}_y(B_{10}) = \\{y\\}$。\n- $y$的定义：$\\mathrm{def}_y(B_2) = \\{y\\}$, $\\mathrm{def}_y(B_6) = \\{y\\}$, $\\mathrm{def}_y(B_7) = \\{y\\}$。\n- 活跃度计算（从$B_{10}$向后流动）：\n  - $y$在$B_{10}$是活跃传入的。\n  - 这使得$y$在其前驱$B_8$和$B_9$是活跃传出的。因为两者都没有重新定义$y$，所以$y$在$B_8$和$B_9$都是活跃传入的。\n  - 这使得$y$在$B_7$是活跃传出的。然而，$B_7$包含一个定义$y := 4$，它终止了活跃度。因此，$y$在$B_7$不是活跃传入的。\n  - 因为活跃度在$B_7$被终止，所以它不会在CFG中向上传播得更远。$y$在$B_4$或其任何前驱中都不是活跃传入的。\n$y$是活跃传入的块的集合是$\\{B_8, B_9, B_{10}\\}$。\n- 对$S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$进行剪枝：\n  - $y$在$B_4$是活跃传入的吗？否。我们剪枝$\\phi$函数。\n  - $y$在$B_{10}$是活跃传入的吗？是。我们保留$\\phi$函数。\n- 因此，$S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$。\n\n**步骤4：基于保守活跃度的剪枝（$S_x^{\\mathrm{live}}$, $S_y^{\\mathrm{live}}$）**\n\n该变体认为，如果存在从块$B$到变量$v$的使用的任何路径，则$v$在块$B$是活跃传入的，并忽略路径上的重新定义。\n\n对于变量$x$：\n- $x$的使用在块$B_8$和$B_9$中。\n- 对$S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$进行剪枝：\n  - 在$B_4$处：存在从$B_4$到$x$的使用的一条路径（例如，$B_4 \\rightarrow B_7 \\rightarrow B_9$）。因此，$x$被认为是活跃传入的。我们保留$\\phi$函数。\n  - 在$B_{10}$处：没有从$B_{10}$到$x$的使用（$B_8$或$B_9$）的路径。因此，$x$不被认为是活跃传入的。我们剪枝$\\phi$函数。\n- 因此，$S_x^{\\mathrm{live}} = \\{B_4\\}$。\n\n对于变量$y$：\n- $y$的使用在块$B_{10}$中。\n- 对$S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$进行剪枝：\n  - 在$B_4$处：存在从$B_4$到$y$的使用的一条路径（例如，$B_4 \\rightarrow B_7 \\rightarrow B_8 \\rightarrow B_{10}$）。$B_7$中的重新定义被忽略。因此，$y$被认为是活跃传入的。我们保留$\\phi$函数。\n  - 在$B_{10}$处：这是包含使用的块，因此存在一条长度为0的平凡路径。$y$是活跃传入的。我们保留$\\phi$函数。\n- 因此，$S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$。\n\n**步骤5：比较与最终计算**\n\n我们现在总结结果并计算$E$。\n- 对于$x$：$S_x^{\\mathrm{pruned}} = \\{B_4\\}$ 且 $S_x^{\\mathrm{live}} = \\{B_4\\}$。因此，$S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$。\n- 对于$y$：$S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$ 且 $S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$。因此，$S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$。不等式成立，因为对$y$的保守活跃度分析忽略了$B_7$中的重定义$y := 4$，导致它错误地认为$y$在$B_4$是活跃传入的，从而未能剪掉那里的$\\phi$函数。\n\n最后，我们计算标量$E$：\n$$ E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| $$\n- $S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}} = \\{B_4\\} \\setminus \\{B_4\\} = \\emptyset$。所以 $\\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| = 0$。\n- $S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}} = \\{B_4, B_{10}\\} \\setminus \\{B_{10}\\} = \\{B_4\\}$。所以 $\\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| = 1$。\n\n$$ E = 0 + 1 = 1 $$", "answer": "$$\n\\boxed{1}\n$$", "id": "3670701"}]}