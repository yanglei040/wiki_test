{"hands_on_practices": [{"introduction": "此练习探讨了基于静态单赋值（SSA）的常量传播中最基础的应用场景。通过分析一个简单的条件分支，您将理解当所有控制流路径为一个变量赋上相同的常量值时，$\\phi$ 函数如何在汇合点将这些值统一起来。这个过程揭示了编译器如何通过消除冗余分支来简化代码，是理解 SSA 优化能力的第一步。[@problem_id:3671040]", "problem": "考虑从一个更大的程序中提取出的以下线性三地址代码及其控制流，其中 $cond$ 是一个未知的、动态确定的布尔值，所有算术运算都是在机器整数上进行的：\n\n入口块 $B_{0}$:\nif $cond$ then goto $B_{1}$ else goto $B_{2}$\n\n块 $B_{1}$:\n$x \\leftarrow 2$\ngoto $B_{3}$\n\n块 $B_{2}$:\n$x \\leftarrow 2$\ngoto $B_{3}$\n\n块 $B_{3}$:\n$y \\leftarrow x + 5$\nreturn $y$\n\n你需要从静态单赋值 (SSA) 形式和数据流常量传播的第一性原理出发进行推理。静态单赋值 (SSA) 形式要求每个变量仅被赋值一次，在控制流汇合点，值的选择通过 $\\phi$-函数建模，该函数从定义在输入控制流边上的值中进行选择。常量传播是一种前向数据流分析，它在一个值的抽象域上解释操作，以确定在每个程序点上，程序变量何时持有可证明的常量。\n\n仅使用这些基本定义和 $\\phi$-函数在汇合点选择与所选前驱对应的值这一标准属性，推导代码的 SSA 形式，定义通过赋值和 $\\phi$-函数传播常量所需的抽象解释，并推断该条件语句是否可以通过将程序重写为对 $x$ 的单个、与 $cond$ 无关的赋值来消除。\n\n在基于 SSA 的常量传播下，在汇合点 $B_{3}$ 可以将 $x$ 设置为哪个常量值，从而使得条件语句和两个分支可以被一个单一的赋值语句替换？请仅提供该常量作为你的最终答案。无需四舍五入。", "solution": "该问题要求使用静态单赋值 (SSA) 形式和常量传播的基本原理，分析一段给定的三地址代码，以确定一个条件分支是否可以被消除。\n\n### 求解过程\n\n求解过程分两个阶段进行：首先，将代码转换为 SSA 形式；其次，在 SSA 形式上执行常量传播。\n\n**1. 转换为静态单赋值 (SSA) 形式**\n\n原始代码中有两个对变量 $x$ 的赋值，一个在块 $B_{1}$ 中，一个在块 $B_{2}$ 中。SSA 规则要求每个变量只能被赋值一次。因此，我们必须重命名每个赋值的目标。\n\n- 块 $B_{1}$ 中的赋值 `$x \\leftarrow 2$` 被重命名为 `$x_{1} \\leftarrow 2$`。\n- 块 $B_{2}$ 中的赋值 `$x \\leftarrow 2$` 被重命名为 `$x_{2} \\leftarrow 2$`。\n\n块 $B_{3}$ 是一个汇合点，因为它有两个前驱：$B_{1}$ 和 $B_{2}$。变量 $x$ 在 $B_{3}$ 的语句 `$y \\leftarrow x + 5$` 中被使用。对 $x$ 的这次使用必须被一个新的变量（例如 $x_{3}$）替换，该变量的值来自放置在 $B_{3}$ 入口处的 $\\phi$-函数。$\\phi$-函数合并了到达 $B_{3}$ 的不同版本的 $x$。\n\n在 $B_{3}$ 开始处关于 $x$ 的 $\\phi$-函数是：\n$$x_{3} \\leftarrow \\phi(x_{1}, x_{2})$$\n这个函数意味着，如果控制流从 $B_{1}$ 流向 $B_{3}$，$x_{3}$ 就取 $x_{1}$ 的值。如果控制流从 $B_{2}$ 流向 $B_{3}$，$x_{3}$ 就取 $x_{2}$ 的值。\n\n最后，$B_{3}$ 中对 $x$ 的使用被 $x_{3}$ 替换，对 $y$ 的赋值也被赋予一个唯一的名称 $y_{1}$。代码的完整 SSA 形式是：\n\n入口块 $B_{0}$:\n`if $cond$ then goto $B_{1}$ else goto $B_{2}$`\n\n块 $B_{1}$:\n`$x_{1} \\leftarrow 2$`\n`goto $B_{3}$`\n\n块 $B_{2}$:\n`$x_{2} \\leftarrow 2$`\n`goto $B_{3}$`\n\n块 $B_{3}$:\n`$x_{3} \\leftarrow \\phi(x_{1}, x_{2})$`\n`$y_{1} \\leftarrow x_{3} + 5$`\n`return $y_{1}$`\n\n**2. 基于 SSA 的常量传播**\n\n常量传播是一种前向数据流分析，它在一个值的抽象域（格）上操作。对于这个问题，我们使用标准的常量传播格，它有三种类型的元素：\n-   $\\top$ (“顶”): 代表未定义或未初始化的值。\n-   $c$: 一个特定的常量值（例如 $2$, $5$ 等）。\n-   $\\bot$ (“底”): 代表已知不是常量的值（即，过度定义）。\n\n该分析确定每个程序点上每个变量的抽象值。分析的核心在于我们如何解释在这个抽象域上的操作。\n\n-   **对于赋值语句 `$v \\leftarrow c$`**，其中 $c$ 是一个常量，变量 $v$ 的抽象值变为 $c$。\n-   **对于 $\\phi$-函数 `$v \\leftarrow \\phi(v_1, v_2, ..., v_n)$`**，变量 $v$ 的抽象值是其参数 $v_{1}, v_{2}, \\dots, v_{n}$ 抽象值的相遇（meet, $\\sqcap$）运算结果。相遇运算定义如下：\n    -   对于任何 $a$，$a \\sqcap \\top = a$。\n    -   对于任何 $a$，$a \\sqcap \\bot = \\bot$。\n    -   $c \\sqcap c = c$ (两个相同常量的相遇运算结果是该常量)。\n    -   如果 $c_{1} \\neq c_{2}$，则 $c_{1} \\sqcap c_{2} = \\bot$ (两个不同常量的相遇运算结果不是一个常量)。\n\n我们现在将此分析应用于 SSA 代码：\n-   在块 $B_{1}$ 中，指令 `$x_{1} \\leftarrow 2$` 将 $x_{1}$ 的抽象值设置为常量 $2$。\n-   在块 $B_{2}$ 中，指令 `$x_{2} \\leftarrow 2$` 将 $x_{2}$ 的抽象值设置为常量 $2$。\n-   在块 $B_{3}$ 的入口处，我们计算 $\\phi$-函数 `$x_{3} \\leftarrow \\phi(x_{1}, x_{2})$`。$x_{3}$ 的抽象值是 $x_{1}$ 和 $x_{2}$ 抽象值的相遇运算结果。\n    $$ \\text{value}(x_{3}) = \\text{value}(x_{1}) \\sqcap \\text{value}(x_{2}) $$\n    代入已知的常量值：\n    $$ \\text{value}(x_{3}) = 2 \\sqcap 2 $$\n-   根据相遇运算符的定义 ($c \\sqcap c = c$)，结果是：\n    $$ \\text{value}(x_{3}) = 2 $$\n\n**结论**\n\n常量传播分析证明，在汇合点 $B_{3}$ 处的变量 $x_{3}$ 的值为常量 $2$。由于这个值与到达 $B_{3}$ 所经过的路径无关（即，与 $cond$ 的值无关），程序关于 $x$ 值的行为不是条件性的。\n\n这使得优化成为可能。两个分支和 $\\phi$-函数可以被一个单一的、无条件的赋值语句所取代。代码可以简化为：\n`$x \\leftarrow 2$`\n`$y \\leftarrow x + 5$`\n`return $y$`\n\n问题要求的是在汇合点可以将 $x$ 设置为的常量值。根据基于 SSA 的常量传播推导，这个值是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3671040"}, {"introduction": "本练习旨在展示常量传播强大的连锁效应。通过求解一个初看起来依赖于未知参数的复杂代码片段，您将体验到编译器如何通过代数化简发现初始常量，并利用这些常量剪除不可达的执行路径。这个练习凸显了常量传播不仅仅是替换变量，更是一种能够深刻改变程序控制流图、引发一系列连锁简化的强大分析技术。[@problem_id:3670976]", "problem": "考虑一个直线代码片段，该片段带有一个条件分支，其后跟一个下游条件分支，并在各自的汇合点处进行合并。假设该程序接受两个整数参数 $a$ 和 $b$，其初始值未知。用程序变量的数学表达式定义赋值和条件如下：\n1. 初始化 $x$ 为 $x := a - a + 4$，$y$ 为 $y := 4 \\cdot (b - b) + 4$。\n2. 关于 $x > y$ 的条件分支：\n   - Then 分支：赋值 $p := 2 \\cdot x$ 和 $q := y + 1$。\n   - Else 分支：赋值 $p := y - 2$ 和 $q := x + 3$。\n   在该条件的后支配节点处，令合并后的变量为 $p_{\\mathrm{merge}} := \\phi(p_{\\mathrm{then}}, p_{\\mathrm{else}})$ 和 $q_{\\mathrm{merge}} := \\phi(q_{\\mathrm{then}}, q_{\\mathrm{else}})$，然后计算 $m := p_{\\mathrm{merge}} + q_{\\mathrm{merge}}$。\n3. 关于 $(m - 9) = 0$ 的条件分支：\n   - Then 分支：赋值 $t := 3 \\cdot m$。\n   - Else 分支：赋值 $t := m - 4$。\n   在该条件的后支配节点处，令合并后的变量为 $t_{\\mathrm{merge}} := \\phi(t_{\\mathrm{then}}, t_{\\mathrm{else}})$，然后计算 $u := t_{\\mathrm{merge}} - m$。\n4. 函数返回 $u$。\n\n使用静态单赋值（SSA）形式（在汇合点处使用显式 $\\phi$ 函数）和标准的基于格的整数常量传播框架，其中每个 SSA 名称的取值范围为格 $\\mathcal{L} = \\{ \\bot \\} \\cup \\mathbb{Z} \\cup \\{ \\top \\}$，其排序方式为任何具体整数 $c \\in \\mathbb{Z}$ 都低于 $\\top$ 且高于 $\\bot$。从参数 $a$ 和 $b$ 未知（即初始值为 $\\top$）开始，执行基于 SSA 的常量传播。在你的推理中，如果前驱节点的守卫条件求值为已知的假常量，则将其视为不可行路径，并将此可行性应用于 $\\phi$ 函数的传入参数。在这些规则下，确定经过常量折叠和不可行路径消除后的最终返回值。将最终答案表示为一个精确的整数。无需四舍五入。明确说明由基于 SSA 的常量传播驱动的优化后，函数返回的单一实数值。", "solution": "### 求解推导\n我们将遵循指定的算法和规则，逐步执行基于 SSA 的常量传播。变量 $v$ 的格值将表示为 $\\mathrm{val}(v)$。\n\n1.  **初始状态**：参数 $a$ 和 $b$ 未知。在常量传播格中，这意味着它们的初始值为 $\\top$（未初始化）。\n    -   $\\mathrm{val}(a) = \\top$\n    -   $\\mathrm{val}(b) = \\top$\n\n2.  **初始赋值**：我们计算对 $x$ 和 $y$ 的初始赋值。常量折叠包括代数简化。\n    -   $x := a - a + 4$：表达式 $a - a$ 是一个代数恒等式，无论 $a$ 的值是多少，其结果始终为 $0$。这是常量折叠中的一个标准优化。因此，表达式简化为 $0 + 4$。\n        -   $\\mathrm{val}(x) = 4$。\n    -   $y := 4 \\cdot (b - b) + 4$：同样，表达式 $b - b$ 简化为 $0$。赋值变为 $y := 4 \\cdot 0 + 4$。\n        -   $\\mathrm{val}(y) = 4$。\n\n3.  **第一个条件分支**：条件是 $x > y$。我们代入已知的常量值。\n    -   条件变为 $4 > 4$。\n    -   该表达式求值为 `false`。\n    -   由于守卫条件是一个已知的常量 `false`，因此“then”分支被确定为不可行（死代码），而“else”分支是唯一的可行路径。\n\n4.  **路径特定赋值（第一个条件分支）**：\n    -   *Then 分支（不可行）*：尽管代码不可达，我们仍然可以计算表达式。$p_{\\mathrm{then}} := 2 \\cdot x = 2 \\cdot 4 = 8$。$q_{\\mathrm{then}} := y + 1 = 4 + 1 = 5$。\n    -   *Else 分支（可行）*：我们计算在此路径中赋值的变量的值。\n        -   $p_{\\mathrm{else}} := y - 2 = 4 - 2 = 2$。\n        -   $q_{\\mathrm{else}} := x + 3 = 4 + 3 = 7$。\n\n5.  **第一次合并**：我们使用 $\\phi$ 函数计算 $p_{\\mathrm{merge}}$ 和 $q_{\\mathrm{merge}}$ 的值。规则规定来自不可行路径的参数将被忽略。\n    -   $p_{\\mathrm{merge}} := \\phi(p_{\\mathrm{then}}, p_{\\mathrm{else}})$：由于“then”分支不可行，$\\phi$ 函数解析为唯一可行前驱（即“else”分支）的值。\n        -   $\\mathrm{val}(p_{\\mathrm{merge}}) = \\mathrm{val}(p_{\\mathrm{else}}) = 2$。\n    -   $q_{\\mathrm{merge}} := \\phi(q_{\\mathrm{then}}, q_{\\mathrm{else}})$：同样，此函数解析为“else”分支的值。\n        -   $\\mathrm{val}(q_{\\mathrm{merge}}) = \\mathrm{val}(q_{\\mathrm{else}}) = 7$。\n\n6.  **$m$ 的赋值**：我们使用 $p_{\\mathrm{merge}}$ 和 $q_{\\mathrm{merge}}$ 的常量值来计算 $m$ 的值。\n    -   $m := p_{\\mathrm{merge}} + q_{\\mathrm{merge}} = 2 + 7 = 9$。\n    -   $\\mathrm{val}(m) = 9$。\n\n7.  **第二个条件分支**：条件是 $(m - 9) = 0$。我们代入已知的 $m$ 的常量值。\n    -   条件变为 $(9 - 9) = 0$，简化为 $0 = 0$。\n    -   该表达式求值为 `true`。\n    -   由于守卫条件是一个已知的常量 `true`，因此“then”分支是唯一的可行路径，而“else”分支不可行。\n\n8.  **路径特定赋值（第二个条件分支）**：\n    -   *Then 分支（可行）*：我们计算在此路径中的赋值。\n        -   $t_{\\mathrm{then}} := 3 \\cdot m = 3 \\cdot 9 = 27$。\n    -   *Else 分支（不可行）*：$t_{\\mathrm{else}} := m - 4 = 9 - 4 = 5$。\n\n9.  **第二次合并**：我们使用 $\\phi$ 函数计算 $t_{\\mathrm{merge}}$ 的值。\n    -   $t_{\\mathrm{merge}} := \\phi(t_{\\mathrm{then}}, t_{\\mathrm{else}})$：由于“else”分支不可行，$\\phi$ 函数解析为“then”分支的值。\n        -   $\\mathrm{val}(t_{\\mathrm{merge}}) = \\mathrm{val}(t_{\\mathrm{then}}) = 27$。\n\n10. **$u$ 的最终赋值**：我们计算 $u$ 的值。\n    -   $u := t_{\\mathrm{merge}} - m = 27 - 9 = 18$。\n    -   $\\mathrm{val}(u) = 18$。\n\n11. **返回值**：函数返回 $u$ 的值。\n    -   最终返回值为常量整数 $18$。", "answer": "$$\n\\boxed{18}\n$$", "id": "3670976"}, {"introduction": "循环是程序优化的关键区域，而本练习将引导您分析一个包含循环的 SSA 形式代码。您将看到 $\\phi$ 函数如何简洁地表示循环变量的迭代更新，即合并来自循环入口前和循环体回边的值。通过应用常量传播，您会发现，仅凭循环的初始值便可判定循环条件是否恒为假，从而证明整个循环体都是不可达代码，并将其完全移除。[@problem_id:3671009]", "problem": "考虑一个静态单赋值 (SSA) 形式的循环，其中循环头使用 $\\phi$ 函数将变量 $i$ 定义为 $i = \\phi(0, i + 2)$，且循环控制条件为 $i > 0$。从 SSA 的基本定义和常量传播（作为抽象值格上的单调数据流分析）的语义出发，推导当应用常量传播和基于可达性的简化时，在控制流离开循环头的程序点处，为 $i$ 计算出的值是多少。你的推理应从以下基础开始：\n\n- 在 SSA 中，连接点的 $\\phi$ 函数会选择来自实际执行的控制流前驱的值。\n- 常量传播在抽象值格上操作，其中每个变量的值可以是特定的常量、未知的非常量值或初始化前的未定义值，并且它遵循控制流的可达性。\n\n在传播和简化稳定后，确定在循环头出口处 $i$ 的最终值。将你的答案表示为一个整数，无需进行四舍五入。", "solution": "此问题要求我们通过应用基于静态单赋值 (SSA) 的常量传播和可达性分析的原理，来确定循环变量 $i$ 在循环退出时的值。\n\n**求解过程**\n\n1.  **分析循环结构**\n    程序包含一个循环。在 SSA 形式中，循环头部的变量 $i$ 由一个 $\\phi$ 函数定义：$i = \\phi(0, i + 2)$。\n    这个 $\\phi$ 函数有两个输入：\n    -   第一个参数 `0`：这是循环变量的初始值，来自进入循环之前的路径（pre-header）。\n    -   第二个参数 `i + 2`：这是循环变量的更新值，来自循环体内部并返回到循环头的路径（back-edge）。\n\n2.  **执行常量传播**\n    常量传播算法以迭代方式进行，追踪变量的格值。\n    -   **首次访问循环头**：当控制流第一次到达循环头时，它来自循环的外部（pre-header）。因此，变量 $i$ 的值被设置为 $\\phi$ 函数的第一个参数，即常量 $0$。\n    -   **评估循环条件**：此时，$i$ 的值为 $0$。编译器接着评估循环的控制条件：$i > 0$。\n    -   代入 $i$ 的值，条件变为 $0 > 0$。\n    -   这个条件求值为 `false`。\n\n3.  **应用可达性分析和简化**\n    -   由于循环条件在第一次检查时就为 `false`，控制流将不会进入循环体。相反，它将直接沿着“假”路径（false path）离开循环，进入循环出口块。\n    -   因此，通往循环体的控制流路径被证明是**不可达的**。\n    -   既然循环体不可达，那么从循环体返回到循环头的回边（back-edge）也同样是不可达的。\n\n4.  **简化 $\\phi$ 函数**\n    -   现在，编译器重新审视循环头的 $\\phi$ 函数：$i = \\phi(0, i + 2)$。\n    -   根据 SSA 和 SCCP 的规则，$\\phi$ 函数只考虑来自**可达**前驱路径的参数。\n    -   由于来自回边的路径已被证明是不可达的，其对应的第二个参数 `i + 2` 被从 $\\phi$ 函数中移除。\n    -   $\\phi$ 函数因此被简化为只有一个参数：$i = \\phi(0)$。\n    -   只有一个参数的 $\\phi$ 函数是冗余的，它等价于一次简单的赋值。所以，定义变为 $i = 0$。\n\n5.  **得出结论**\n    分析至此达到稳定状态。通过结合常量传播和可达性分析，编译器证明了循环体是死代码，并确定了在循环出口处变量 $i$ 的值。当控制流离开循环头时（通过唯一的、可达的出口路径），变量 $i$ 的值是常量 $0$。整个循环结构可以在编译时被彻底消除。\n\n**最终值**\n\n因此，在循环头出口处 $i$ 的最终计算值为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3671009"}]}