{"hands_on_practices": [{"introduction": "静态单赋值（SSA）形式是现代编译器优化的基石，它通过确保每个变量只被赋值一次来简化和增强许多分析与变换。本练习 [@problem_id:3633415] 将带你实践将程序转换为 SSA 形式的核心算法。你将通过手动计算一个包含分支与循环的控制流图的支配边界（Dominance Frontiers），并应用迭代算法来确定放置 $\\phi$ 函数的最小集合，从而掌握编译器如何精确追踪变量值的来源。", "problem": "编译器必须通过在汇合点插入适当的 $\\phi$-函数，将一个带有分支和循环的直线式程序转换为静态单赋值 (SSA) 形式。使用以下伪代码定义一个控制流图 (CFG)，然后执行控制流分析，通过迭代支配边界过程来确定最小化的 $\\phi$-函数放置。\n\n带有标记基本块的程序：\n- $B_{0}$: 入口；$x := 0$；跳转至 $B_{1}$。\n- $B_{1}$: 如果 $c_{1}$ 则跳转至 $B_{2}$ 否则跳转至 $B_{3}$。\n- $B_{2}$: $x := 1$；$y := a$；跳转至 $B_{4}$。\n- $B_{3}$: $y := b$；跳转至 $B_{4}$。\n- $B_{4}$: 循环头；如果 $c_{2}$ 则跳转至 $B_{5}$ 否则跳转至 $B_{6}$。\n- $B_{5}$: $x := x + 1$；跳转至 $B_{7}$。\n- $B_{6}$: $y := y + 1$；跳转至 $B_{7}$。\n- $B_{7}$: 如果 $c_{3}$ 则跳转至 $B_{4}$ 否则跳转至 $B_{8}$。\n- $B_{8}$: $z := x + y$；跳转至 $B_{9}$。\n- $B_{9}$: 出口。\n\n控制流图 (CFG) 的边为：$B_{0} \\to B_{1}$；$B_{1} \\to B_{2}$；$B_{1} \\to B_{3}$；$B_{2} \\to B_{4}$；$B_{3} \\to B_{4}$；$B_{4} \\to B_{5}$；$B_{4} \\to B_{6}$；$B_{5} \\to B_{7}$；$B_{6} \\to B_{7}$；$B_{7} \\to B_{4}$；$B_{7} \\to B_{8}$；$B_{8} \\to B_{9}$。\n\n任务：\n1. 使用支配和支配边界的基本定义，计算 CFG 中每个基本块 $B_{i}$ 的支配边界 $\\mathrm{DF}(B_{i})$。\n2. 使用静态单赋值 (SSA) 的定义和迭代支配边界算法，仅确定变量 $x$ 和 $y$ 的最小化 $\\phi$-函数放置。在迭代时将 $\\phi$-函数视为定义。\n3. 提供为变量 $x$ 和 $y$ 在所有块中插入的 $\\phi$-函数的总数。\n\n答案格式要求：\n- 您的最终答案必须是一个整数，等于插入的 $\\phi$-函数的总数。", "solution": "用户希望找到将给定程序转换为变量 $x$ 和 $y$ 的静态单赋值 (SSA) 形式所需的最小 $\\phi$-函数数量。这涉及到执行控制流分析，特别是计算支配集和支配边界。\n\n### 步骤1：提取已知信息\n问题提供了以下信息：\n- **基本块**：一组10个基本块，标记为 $B_{0}$ 到 $B_{9}$。\n- **程序逻辑**：\n    - $B_{0}$: 入口；$x := 0$；跳转至 $B_{1}$。\n    - $B_{1}$: 如果 $c_{1}$ 则跳转至 $B_{2}$ 否则跳转至 $B_{3}$。\n    - $B_{2}$: $x := 1$；$y := a$；跳转至 $B_{4}$。\n    - $B_{3}$: $y := b$；跳转至 $B_{4}$。\n    - $B_{4}$: 循环头；如果 $c_{2}$ 则跳转至 $B_{5}$ 否则跳转至 $B_{6}$。\n    - $B_{5}$: $x := x + 1$；跳转至 $B_{7}$。\n    - $B_{6}$: $y := y + 1$；跳转至 $B_{7}$。\n    - $B_{7}$: 如果 $c_{3}$ 则跳转至 $B_{4}$ 否则跳转至 $B_{8}$。\n    - $B_{8}$: $z := x + y$；跳转至 $B_{9}$。\n    - $B_{9}$: 出口。\n- **控制流图 (CFG) 的边**：\n$B_{0} \\to B_{1}$、 $B_{1} \\to B_{2}$、 $B_{1} \\to B_{3}$、 $B_{2} \\to B_{4}$、 $B_{3} \\to B_{4}$、 $B_{4} \\to B_{5}$、 $B_{4} \\to B_{6}$、 $B_{5} \\to B_{7}$、 $B_{6} \\to B_{7}$、 $B_{7} \\to B_{4}$、 $B_{7} \\to B_{8}$、 $B_{8} \\to B_{9}$。\n- **任务**：\n    1. 计算每个基本块 $B_{i}$ 的支配边界 $\\mathrm{DF}(B_{i})$。\n    2. 为变量 $x$ 和 $y$ 确定最小化 $\\phi$-函数放置。\n    3. 提供为 $x$ 和 $y$ 插入的 $\\phi$-函数的总数。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学性**：该问题基于编译器理论中的标准概念，即控制流图、支配者、支配边界和静态单赋值 (SSA) 形式。这些是计算机科学中公认的基础性课题。\n- **适定性**：CFG 被明确定义，并且使用迭代支配边界计算最小 SSA 形式的算法是确定性的。这确保了存在唯一且有意义的解。\n- **客观性**：该问题使用编译器理论中的形式化语言陈述，不包含主观或模糊的语言。\n- **完整性和一致性**：所有必要的信息（基本块、CFG边、变量赋值）都已提供。块逻辑的描述与指定的CFG边一致。\n- **结论**：该问题是有效的。这是一个应用编译器优化算法的标准练习。\n\n### 步骤3：判断与行动\n该问题有效。我将继续提供完整解答。\n\n### 解答\n\n解答按要求分为三个主要部分：计算支配边界、确定 $\\phi$-函数放置以及计算 $\\phi$-函数的总数。\n\n#### 第1部分：支配和支配边界\n\n为了计算支配边界，我们必须首先计算 CFG 中每个基本块的支配集。如果从入口块 ($B_{0}$) 到块 $N$ 的每条路径都必须经过块 $D$，则称块 $D$ 支配块 $N$。支配关系可以使用标准迭代数据流分析算法计算。\n\n**支配集：**\n迭代算法收敛到以下支配集 $\\mathrm{DOM}(B_{i})$：\n- $\\mathrm{DOM}(B_{0}) = \\{B_{0}\\}$\n- $\\mathrm{DOM}(B_{1}) = \\{B_{0}, B_{1}\\}$\n- $\\mathrm{DOM}(B_{2}) = \\{B_{0}, B_{1}, B_{2}\\}$\n- $\\mathrm{DOM}(B_{3}) = \\{B_{0}, B_{1}, B_{3}\\}$\n- $\\mathrm{DOM}(B_{4}) = \\{B_{0}, B_{1}, B_{4}\\}$ (注意：$B_{4}$ 是一个循环头，其支配者是其前驱 $B_{2}$、$B_{3}$ 和 $B_{7}$ 的公共支配者)\n- $\\mathrm{DOM}(B_{5}) = \\{B_{0}, B_{1}, B_{4}, B_{5}\\}$\n- $\\mathrm{DOM}(B_{6}) = \\{B_{0}, B_{1}, B_{4}, B_{6}\\}$\n- $\\mathrm{DOM}(B_{7}) = \\{B_{0}, B_{1}, B_{4}, B_{7}\\}$\n- $\\mathrm{DOM}(B_{8}) = \\{B_{0}, B_{1}, B_{4}, B_{7}, B_{8}\\}$\n- $\\mathrm{DOM}(B_{9}) = \\{B_{0}, B_{1}, B_{4}, B_{7}, B_{8}, B_{9}\\}$\n\n**支配边界 ($\\mathrm{DF}$):**\n节点 $N$ 的支配边界，记为 $\\mathrm{DF}(N)$，是所有节点 $Y$ 的集合，其中 $N$ 支配 $Y$ 的一个直接前驱，但 $N$ 并不严格支配 $Y$。如果节点 $N$ 支配 $Y$ 且 $N \\neq Y$，则称 $N$ 严格支配 $Y$。我们用 $N \\text{ sdom } Y$ 表示严格支配。\n定义为：$\\mathrm{DF}(N) = \\{ Y \\mid \\exists P \\in \\mathrm{pred}(Y) \\text{ such that } N \\in \\mathrm{DOM}(P) \\text{ and } N \\notin \\mathrm{sdom}(Y) \\}$。\n\n将此定义应用于每个块 $B_{i}$：\n- $\\mathrm{DF}(B_{0}) = \\emptyset$：入口节点没有支配边界。\n- $\\mathrm{DF}(B_{1}) = \\emptyset$：虽然 $B_{1}$ 是一个分支点，但它所支配的任何节点（除了它自身），它都严格支配。对于汇合点 $B_{4}$，$B_{1}$ 严格支配它。\n- $\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$：$B_{2}$ 支配其自身前驱 $B_{2}$。对于边 $B_{2} \\to B_{4}$，$B_{2}$ 并不严格支配 $B_{4}$（因为 $B_{2} \\notin \\mathrm{sdom}(B_4) = \\{B_0, B_1\\}$）。因此，$B_{4} \\in \\mathrm{DF}(B_{2})$。\n- $\\mathrm{DF}(B_{3}) = \\{B_{4}\\}$：类似地，对于边 $B_{3} \\to B_{4}$，$B_{3}$ 支配 $B_{3}$ 但不严格支配 $B_{4}$。\n- $\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$：对于回边 $B_{7} \\to B_{4}$，$B_{4}$ 支配前驱 $B_{7}$。然而，$B_{4}$ 并不严格支配其自身。因此，$B_{4} \\in \\mathrm{DF}(B_{4})$。\n- $\\mathrm{DF}(B_{5}) = \\{B_{7}\\}$：对于边 $B_{5} \\to B_{7}$，$B_{5}$ 支配 $B_{5}$ 但不严格支配 $B_{7}$（因为 $B_{5} \\notin \\mathrm{sdom}(B_7) = \\{B_0, B_1, B_4\\}$）。\n- $\\mathrm{DF}(B_{6}) = \\{B_{7}\\}$：类似地，对于边 $B_{6} \\to B_{7}$，$B_{6}$ 支配 $B_{6}$ 但不严格支配 $B_{7}$。\n- $\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$：对于回边 $B_{7} \\to B_{4}$，$B_{7}$ 支配其自身前驱 $B_{7}$，但不严格支配 $B_{4}$。\n- $\\mathrm{DF}(B_{8}) = \\emptyset$：$B_{8}$ 严格支配其唯一的后继 $B_{9}$。\n- $\\mathrm{DF}(B_{9}) = \\emptyset$：出口节点没有后继。\n\n#### 第2部分：最小化 $\\phi$-函数放置\n\n我们使用迭代支配边界算法来找到为变量 $x$ 和 $y$ 需要 $\\phi$-函数的最小节点集。如果节点 $N$ 位于任何包含变量 $V$ 定义的块的支配边界中，则该节点需要为变量 $V$ 设置一个 $\\phi$-函数。这个过程是迭代的，因为 $\\phi$-函数本身就是一个定义。\n\n令 $A_{V}$ 为包含变量 $V$ 原始定义的块的集合。\n需要为 $V$ 设置 $\\phi$-函数的节点集 $\\Phi(V)$ 是以下序列的极限：\n$\\Phi_{0}(V) = \\emptyset$\n$\\Phi_{i+1}(V) = \\mathrm{DF}(A_{V} \\cup \\Phi_{i}(V))$\n\n**变量 $x$：**\n包含 $x$ 原始定义的块的集合是 $A_{x} = \\{B_{0}, B_{2}, B_{5}\\}$。\n我们初始化一个工作列表 $W = A_{x} = \\{B_{0}, B_{2}, B_{5}\\}$ 和一个包含 $\\phi$-函数的块的集合 $P_{x} = \\emptyset$。\n- **迭代 1**：\n    - 处理 $B_{0} \\in W$。$\\mathrm{DF}(B_{0}) = \\emptyset$。\n    - 处理 $B_{2} \\in W$。$\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。由于 $B_{4} \\notin P_{x}$，我们在 $B_{4}$ 处为 $x$ 添加一个 $\\phi$-函数。更新 $P_{x} = \\{B_{4}\\}$ 并将 $B_{4}$ 添加到工作列表 $W$ 中。\n    - 处理 $B_{5} \\in W$。$\\mathrm{DF}(B_{5}) = \\{B_{7}\\}$。由于 $B_{7} \\notin P_{x}$，我们在 $B_{7}$ 处为 $x$ 添加一个 $\\phi$-函数。更新 $P_{x} = \\{B_{4}, B_{7}\\}$ 并将 $B_{7}$ 添加到 $W$ 中。\n- **迭代 2**：工作列表现在包含 $\\{B_{4}, B_{7}\\}$。\n    - 处理 $B_{4} \\in W$。$\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$。$B_{4}$ 已经存在于 $P_{x}$ 中，所以没有变化。\n    - 处理 $B_{7} \\in W$。$\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$。$B_{4}$ 已经存在于 $P_{x}$ 中，所以没有变化。\n工作列表现在为空。算法终止。\n需要为 $x$ 设置 $\\phi$-函数的最小块集合是 $\\{B_{4}, B_{7}\\}$。\n\n**变量 $y$：**\n包含 $y$ 原始定义的块的集合是 $A_{y} = \\{B_{2}, B_{3}, B_{6}\\}$。\n初始化工作列表 $W = A_{y} = \\{B_{2}, B_{3}, B_{6}\\}$ 和 $P_{y} = \\emptyset$。\n- **迭代 1**：\n    - 处理 $B_{2} \\in W$。$\\mathrm{DF}(B_{2}) = \\{B_{4}\\}$。由于 $B_{4} \\notin P_{y}$，在 $B_{4}$ 处为 $y$ 添加一个 $\\phi$-函数。更新 $P_{y} = \\{B_{4}\\}$ 并将 $B_{4}$ 添加到 $W$ 中。\n    - 处理 $B_{3} \\in W$。$\\mathrm{DF}(B_{3}) = \\{B_{4}\\}$。$B_{4}$ 已经存在于 $P_{y}$ 中，所以没有变化。\n    - 处理 $B_{6} \\in W$。$\\mathrm{DF}(B_{6}) = \\{B_{7}\\}$。由于 $B_{7} \\notin P_{y}$，在 $B_{7}$ 处为 $y$ 添加一个 $\\phi$-函数。更新 $P_{y} = \\{B_{4}, B_{7}\\}$ 并将 $B_{7}$ 添加到 $W$ 中。\n- **迭代 2**：工作列表现在包含 $\\{B_{4}, B_{7}\\}$。\n    - 处理 $B_{4} \\in W$。$\\mathrm{DF}(B_{4}) = \\{B_{4}\\}$。$B_{4}$ 已经存在于 $P_{y}$ 中，所以没有变化。\n    - 处理 $B_{7} \\in W$。$\\mathrm{DF}(B_{7}) = \\{B_{4}\\}$。$B_{4}$ 已经存在于 $P_{y}$ 中，所以没有变化。\n工作列表现在为空。算法终止。\n需要为 $y$ 设置 $\\phi$-函数的最小块集合是 $\\{B_{4}, B_{7}\\}$。\n\n#### 第3部分：$\\phi$-函数总数\n\n根据第2部分的分析：\n- 变量 $x$ 的 $\\phi$-函数数量：$2$ 个（一个在 $B_{4}$ 中，一个在 $B_{7}$ 中）。\n- 变量 $y$ 的 $\\phi$-函数数量：$2$ 个（一个在 $B_{4}$ 中，一个在 $B_{7}$ 中）。\n\n为变量 $x$ 和 $y$ 插入的 $\\phi$-函数总数是这些计数的和。\n总数 = $2 + 2 = 4$。", "answer": "$$\\boxed{4}$$", "id": "3633415"}, {"introduction": "在上一个练习中，我们学习了在何处放置 $\\phi$ 函数。然而，如何正确实现这些 $\\phi$ 函数同样充满挑战，一个关键的障碍是“关键边”（critical edge）的存在。本练习 [@problem_id:3633367] 揭示了在存在关键边的CFG中，朴素的 $\\phi$ 函数实现为何会破坏程序语义，并介绍了通过边分裂（edge splitting）这一标准技术来解决该问题的原理，这对于编写正确且高效的后端代码至关重要。", "problem": "控制流图 (Control-Flow Graph, CFG) 是一个有向图 $G=(V,E)$，其顶点 $V$ 是基本块，边 $E$ 表示可能的控制转移；它有一个唯一的入口块 $b_{\\text{entry}} \\in V$。如果从 $b_{\\text{entry}}$ 到节点 $n \\in V$ 的每一条路径都包含节点 $d \\in V$，那么节点 $d$ 支配节点 $n$。如果节点 $u$ 有多于一个后继节点，并且节点 $v$ 有多于一个前驱节点，则边 $\\langle u,v \\rangle \\in E$ 被称为关键边。边分裂通过插入一个新块 $w$ 来替换边 $\\langle u,v \\rangle$，使得 $\\langle u,v \\rangle$ 被移除，并添加 $\\langle u,w \\rangle$ 和 $\\langle w,v \\rangle$。静态单赋值 (Static Single Assignment, SSA) 形式在合并点使用 $\\phi$ 函数 ($\\phi$)；在块 $h$ 处的 $\\phi$ 函数会根据控制流到达 $h$ 时所经过的前驱节点来选择其参数之一。\n\n考虑一个程序 $\\mathcal{P}$，它有基本块 $b_s, b_h, b_t, b_f, b_l, b_m, b_e$ 和以下边：\n- $b_s \\to b_h$\n- $b_h \\to b_t$ 和 $b_h \\to b_f$\n- $b_t \\to b_l$\n- $b_f \\to b_l$\n- $b_l \\to b_h$ 和 $b_l \\to b_m$\n- $b_m \\to b_e$\n\n假设块中有以下语句（采用三地址风格），其中 $p$ 和 $q$ 是布尔变量，$x$ 是一个整数：\n- 在 $b_s$ 中：$x := 0$\n- 在 $b_h$ 中：if $p$ then goto $b_t$ else goto $b_f$\n- 在 $b_t$ 中：$x := x + 1$; goto $b_l$\n- 在 $b_f$ 中：goto $b_l$\n- 在 $b_l$ 中：if $q$ then goto $b_h$ else goto $b_m$\n- 在 $b_m$ 中：use$(x)$; goto $b_e$\n\n当将程序 $\\mathcal{P}$ 转换为静态单赋值 (SSA) 形式时，一个 $\\phi$ 函数 $\\phi(x_{\\text{pre}}, x_{\\text{back}})$ 被放置在 $b_h$ 中，用于合并来自入边 $b_s \\to b_h$（“前置头”贡献 $x_{\\text{pre}}$）和 $b_l \\to b_h$（“回边”贡献 $x_{\\text{back}}$）的 $x$ 的值。一些 SSA 构建方法使用边局部的“参数移动”来实现 $\\phi$ 函数，即对于到 $\\phi$ 块 $h$ 的每个入边 $\\langle u,h \\rangle$，它们将输入值的副本插入到一个该边独有的临时变量中，这个插入操作必须且仅当控制流沿 $\\langle u,h \\rangle$ 流动时才执行。\n\n选择所有正确的选项：\n\nA. 边 $b_l \\to b_h$ 是关键边；通过插入一个新块 $b_{lh}$ 来分裂它，用 $b_l \\to b_{lh}$ 和 $b_{lh} \\to b_h$ 替换 $b_l \\to b_h$，会产生两条非关键边，并创建一个当且仅当控制流从 $b_l$ 流向 $b_h$ 时才执行的唯一程序点，同时保持原始节点间的支配关系不变。\n\nB. 对于在 $b_h$ 处的 $\\phi$ 放置，如果我们不分裂 $b_l \\to b_h$，将回边的参数移动操作放置在 $b_l$ 内部在语义上是安全的，因为 $b_l$ 中的条件语句确保了该移动操作仅在 $q$ 为真时执行。\n\nC. 如果我们不分裂 $b_l \\to b_h$ 并且将回边的参数移动操作放置在 $b_l$ 内部，那么存在一种 $p$ 为假且 $q$ 为假的执行情况，在该情况下，移动操作会沿着路径 $b_l \\to b_m$ 执行，并干扰在 $b_m$ 的 $use(x)$ 处所见的 $x$ 的版本，从而违反了 $\\phi$ 参数的路径敏感语义。这证明了一个反例：边局部的移动操作必须被放置在一条非关键边上，以确保它仅在相应的边被采用时执行。\n\nD. 分裂边 $b_t \\to b_l$ 和 $b_f \\to b_l$ 是消除程序 $\\mathcal{P}$ 中与在 $b_h$ 处放置 $\\phi$ 函数相关的所有关键边的充分必要条件。\n\n通过选择所有正确的选项来回答。从第一性原理出发证明你的选择：使用关键边、边分裂、支配的定义，以及依赖于控制流实际到达时所经过的前驱节点的 $\\phi$ 选择语义。", "solution": "问题陈述已经过验证，被认为是合理、适定且基于已确立的编译器理论原则的。我们可以开始进行分析。\n\n首先，我们分析所提供的控制流图 (CFG) 的结构。顶点集是 $V = \\{b_s, b_h, b_t, b_f, b_l, b_m, b_e\\}$。边集是 $E = \\{\\langle b_s, b_h \\rangle, \\langle b_h, b_t \\rangle, \\langle b_h, b_f \\rangle, \\langle b_t, b_l \\rangle, \\langle b_f, b_l \\rangle, \\langle b_l, b_h \\rangle, \\langle b_l, b_m \\rangle, \\langle b_m, b_e \\rangle\\}$。入口块是 $b_{\\text{entry}} = b_s$。\n\n为了识别关键边，我们必须确定每个块的后继节点和前驱节点的数量。\n设 $\\text{succ}(u)$ 为块 $u$ 的后继节点集合，$\\text{pred}(v)$ 为块 $v$ 的前驱节点集合。\n- $\\text{succ}(b_s) = \\{b_h\\}$，所以 $|\\text{succ}(b_s)| = 1$。\n- $\\text{succ}(b_h) = \\{b_t, b_f\\}$，所以 $|\\text{succ}(b_h)| = 2$。\n- $\\text{succ}(b_t) = \\{b_l\\}$，所以 $|\\text{succ}(b_t)| = 1$。\n- $\\text{succ}(b_f) = \\{b_l\\}$，所以 $|\\text{succ}(b_f)| = 1$。\n- $\\text{succ}(b_l) = \\{b_h, b_m\\}$，所以 $|\\text{succ}(b_l)| = 2$。\n- $\\text{succ}(b_m) = \\{b_e\\}$，所以 $|\\text{succ}(b_m)| = 1$。\n- $\\text{succ}(b_e) = \\emptyset$，所以 $|\\text{succ}(b_e)| = 0$。\n\n- $\\text{pred}(b_s) = \\emptyset$，所以 $|\\text{pred}(b_s)| = 0$。\n- $\\text{pred}(b_h) = \\{b_s, b_l\\}$，所以 $|\\text{pred}(b_h)| = 2$。\n- $\\text{pred}(b_t) = \\{b_h\\}$，所以 $|\\text{pred}(b_t)| = 1$。\n- $\\text{pred}(b_f) = \\{b_h\\}$，所以 $|\\text{pred}(b_f)| = 1$。\n- $\\text{pred}(b_l) = \\{b_t, b_f\\}$，所以 $|\\text{pred}(b_l)| = 2$。\n- $\\text{pred}(b_m) = \\{b_l\\}$，所以 $|\\text{pred}(b_m)| = 1$。\n- $\\text{pred}(b_e) = \\{b_m\\}$，所以 $|\\text{pred}(b_e)| = 1$。\n\n一条边 $\\langle u,v \\rangle$ 被定义为关键边，如果 $|\\text{succ}(u)|  1$ 且 $|\\text{pred}(v)|  1$。\n让我们检查从具有多于一个后继节点的块 ($b_h, b_l$) 发出的边：\n- $\\langle b_h, b_t \\rangle$: $|\\text{succ}(b_h)|=2$，但 $|\\text{pred}(b_t)|=1$。非关键边。\n- $\\langle b_h, b_f \\rangle$: $|\\text{succ}(b_h)|=2$，但 $|\\text{pred}(b_f)|=1$。非关键边。\n- $\\langle b_l, b_h \\rangle$: $|\\text{succ}(b_l)|=2$ 且 $|\\text{pred}(b_h)|=2$。这条边是**关键边**。\n- $\\langle b_l, b_m \\rangle$: $|\\text{succ}(b_l)|=2$，但 $|\\text{pred}(b_m)|=1$。非关键边。\n\n该 CFG 中唯一的关键边是 $\\langle b_l, b_h \\rangle$。\n\n将一个 $\\phi$ 函数的参数移动操作（比如 `t := x`）放置在边 $\\langle u,v \\rangle$ 上的问题在于，这个移动操作必须*仅*在控制流遍历该特定边时执行。\n- 如果放置在块 $u$ 的末尾，它将对所有离开 $u$ 的路径执行。如果 $|\\text{succ}(u)|1$，这对于不走向 $v$ 的路径是不正确的。这被称为“丢失副本”问题。\n- 如果放置在块 $v$ 的开头，它将对所有进入 $v$ 的路径执行。如果 $|\\text{pred}(v)|1$，这对于不来自 $u$ 的路径是不正确的。这被称为“错误副本”或“不安全副本”问题。\n一条关键边同时存在这两种情况，使得移动操作不可能被放置在 $u$ 或 $v$ 中。标准的解决方案是边分裂。\n\n现在我们评估每个选项。\n\n**A. 边 $b_l \\to b_h$ 是关键边；通过插入一个新块 $b_{lh}$ 来分裂它，用 $b_l \\to b_{lh}$ 和 $b_{lh} \\to b_h$ 替换 $b_l \\to b_h$，会产生两条非关键边，并创建一个当且仅当控制流从 $b_l$ 流向 $b_h$ 时才执行的唯一程序点，同时保持原始节点间的支配关系不变。**\n\n1.  **关键性**：如上所述，$|\\text{succ}(b_l)| = 2$ 且 $|\\text{pred}(b_h)| = 2$，所以边 $\\langle b_l, b_h \\rangle$ 确实是关键边。这部分是正确的。\n2.  **边分裂**：我们用一个新块 $b_{lh}$ 和两条新边 $\\langle b_l, b_{lh} \\rangle$ 和 $\\langle b_{lh}, b_h \\rangle$ 替换 $\\langle b_l, b_h \\rangle$。\n    - 对于新边 $\\langle b_l, b_{lh} \\rangle$：$|\\text{succ}(b_l)|$ 仍然是 $2$（现在指向 $b_{lh}$ 和 $b_m$）。然而，$b_{lh}$ 只有一个前驱节点 $b_l$，所以 $|\\text{pred}(b_{lh})| = 1$。这条边不是关键边。\n    - 对于新边 $\\langle b_{lh}, b_h \\rangle$：$b_{lh}$ 只有一个后继节点 $b_h$，所以 $|\\text{succ}(b_{lh})| = 1$。尽管 $|\\text{pred}(b_h)|$ 仍然是 $2$（现在来自 $b_s$ 和 $b_{lh}$），这条边也不是关键边。\n    - 这部分是正确的。\n3.  **唯一程序点**：新块 $b_{lh}$ 位于替换了边 $\\langle b_l, b_h \\rangle$ 的唯一路径段上。因此，它当且仅当控制流从 $b_l$ 流向 $b_h$ 时才执行。这是在 SSA 构建中进行边分裂的主要目的。这部分是正确的。\n4.  **支配关系**：支配是关于从入口块出发的所有路径的属性。在现有边 $\\langle b_l, b_h \\rangle$ 上插入一个块 $b_{lh}$ 不会创建任何连接原始节点的新路径，也不会从现有路径中移除任何原始节点。因此，如果一个节点 $d$ 在分裂前支配节点 $n$（即 $d$ 在从 $b_s$ 到 $n$ 的每一条路径上），那么在分裂后它仍然在每一条这样的路径上。原始集合 $V$ 中节点之间的支配关系得以保留。这部分是正确的。\n\n由于选项A中的所有论断都是正确的，所以该选项是正确的。\n对A的裁定：**正确**。\n\n**B. 对于在 $b_h$ 处的 $\\phi$ 放置，如果我们不分裂 $b_l \\to b_h$，将回边的参数移动操作放置在 $b_l$ 内部在语义上是安全的，因为 $b_l$ 中的条件语句确保了该移动操作仅在 $q$ 为真时执行。**\n\n一个基本块是一系列指令，具有单一入口点和单一出口点。块 $b_l$ 包含条件分支 `if q then goto b_h else goto b_m` 的逻辑。根据定义，任何放置在块 $b_l$ *内部*的指令都必须在此分支发生之前执行。如果我们将参数移动操作（例如 `t := x`）放置在 $b_l$ 内部，那么每次进入 $b_l$ 时它都会执行，无论 $q$ 是真还是假。然后控制流将继续到 $b_h$ 或 $b_m$。该移动操作仅对于到 $b_h$ 的路径是必需的。在到 $b_m$ 的路径上执行它是一个语义错误（如果临时变量被重用，会导致不正确的程序状态的“丢失副本”问题）。“条件语句确保该移动操作仅在 $q$ 为真时执行”这个前提是对基本块和CFG工作原理的误解。条件语句决定的是在块中指令执行*之后*走哪条路径。\n对B的裁定：**不正确**。\n\n**C. 如果我们不分裂 $b_l \\to b_h$ 并且将回边的参数移动操作放置在 $b_l$ 内部，那么存在一种 $p$ 为假且 $q$ 为假的执行情况，在该情况下，移动操作会沿着路径 $b_l \\to b_m$ 执行，并干扰在 $b_m$ 的 $use(x)$ 处所见的 $x$ 的版本，从而违反了 $\\phi$ 参数的路径敏感语义。这证明了一个反例：边局部的移动操作必须被放置在一条非关键边上，以确保它仅在相应的边被采用时执行。**\n\n这个选项直接驳斥了选项B。我们来分析这个论断。\n1.  **放置位置**：用于 $b_h$ 处 $\\phi$ 函数的回边参数移动被放置在 $b_l$ 内部。这个移动操作是特定于边 $\\langle b_l, b_h \\rangle$ 的。\n2.  **执行路径**：考虑 $p$ 为假且 $q$ 为假的执行情况。\n    - 执行从 $b_s$ 开始。我们来追踪 $x$ 的值。$b_s: x := 0$。\n    - 控制流 $b_s \\to b_h$。\n    - 在 $b_h$ 中，条件 $p$ 为假，所以控制流流向 $b_f$。$x$ 的值为 $0$。\n    - 控制流 $b_f \\to b_l$。\n    - 在 $b_l$ 中，错位的参数移动操作会执行。这个移动是为到 $b_h$ 的回边准备的，所以它会复制 $x$ 的当前值。\n    - 然后，对条件 $q$ 进行求值。由于 $q$ 为假，控制流流向 $b_m$。\n3.  **违规**：这个在语义上属于边 $\\langle b_l, b_h \\rangle$ 的参数移动操作，在一条通往 $b_m$ 的路径上被执行了。这直接违反了 $\\phi$ 函数参数的路径敏感语义，该语义要求对特定路径的准备工作只能在该路径上执行。虽然“干扰在 $use(x)$ 处所见的 $x$ 的版本”这一说法可能有不同的解释（例如，直接的值破坏 vs. 用一个活跃但不需要的临时变量污染状态），但该论点的核心是违反了路径敏感语义。这种违规是编译此阶段的一个根本性错误。\n4.  **结论**：最后的陈述，“边局部的移动操作必须被放置在一条非关键边上，以确保它仅在相应的边被采用时执行”，是从这个反例中得出的正确原则。边分裂是创建这样一条非关键边的机制。\n\n这个逻辑是合理的：一个特定于从具有多个出口的块中出来的一条路径的操作，不能被放置在该块内部。\n对C的裁定：**正确**。\n\n**D. 分裂边 $b_t \\to b_l$ 和 $b_f \\to b_l$ 是消除程序 $\\mathcal{P}$ 中与在 $b_h$ 处放置 $\\phi$ 函数相关的所有关键边的充分必要条件。**\n\n1.  **相关性**：所讨论的 $\\phi$ 函数位于块 $b_h$。此 $\\phi$ 函数的输入对应于 $b_h$ 的入边，即 $\\langle b_s, b_h \\rangle$ 和 $\\langle b_l, b_h \\rangle$。因此，唯一“相关的”关键边是这两条边中的一条。\n2.  **识别**：我们已经确定 $\\langle b_s, b_h \\rangle$ 不是关键边，而 $\\langle b_l, b_h \\rangle$ 是关键边。所以，唯一相关的关键边是 $\\langle b_l, b_h \\rangle$。\n3.  **提议的操作**：该选项提议分裂 $\\langle b_t, b_l \\rangle$ 和 $\\langle b_f, b_l \\rangle$。这些是进入 $b_l$ 的边。此操作可能与在 $b_l$ 处的 $\\phi$ 函数相关，但与在 $b_h$ 处的无关。\n4.  **充分性**：分裂 $\\langle b_t, b_l \\rangle$ 和 $\\langle b_f, b_l \\rangle$ 并不会改变 $b_l$ 的后继节点数 ($|\\text{succ}(b_l)| = 2$)，也不会改变 $b_h$ 的前驱节点数 ($|\\text{pred}(b_h)| = 2$)。因此，边 $\\langle b_l, b_h \\rangle$ 仍然是关键边。提议的操作不是充分的。\n5.  **必要性**：该操作不是必要的。为解决 $b_h$ 处 $\\phi$ 函数的问题，必要的操作是分裂关键边 $\\langle b_l, b_h \\rangle$。分裂进入 $b_l$ 的边是无关的。\n\n该选项在图的错误部分提议了一个操作，因此既不必要也不充分。\n对D的裁定：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3633367"}, {"introduction": "控制流分析的应用远不止于构建 SSA 形式，它同样是进行程序正确性验证的强大工具。本练习将介绍一个与支配性（dominance）对偶的重要概念——后置支配性（post-dominance）。通过分析一个包含嵌套循环和提前返回的复杂控制流图 [@problem_id:3633304]，你将学会如何运用后置支配性来回答关于程序正确性的关键问题，例如，在任何执行路径下，资源清理代码（cleanup code）是否都能得到保证执行。", "problem": "考虑一个函数，其控制流包含嵌套循环和提前返回，以及一个放置在循环之后的清理块。使用以下具有唯一出口的控制流图（CFG）来为该函数建模。节点标记如下：入口 $E$、初始化 $A$、外层循环头 $H_{o}$、内层循环头 $H_{i}$、内层循环体和提前返回测试 $B$、提前返回 $R$、内层循环增量 $I_{i}$、外层循环体和增量 $O$、清理 $C$ 以及出口 $X$。有向边为：\n$E \\rightarrow A$、$A \\rightarrow H_{o}$、$H_{o} \\rightarrow H_{i}$、$H_{o} \\rightarrow C$、$H_{i} \\rightarrow B$、$H_{i} \\rightarrow O$、$B \\rightarrow R$、$B \\rightarrow I_{i}$、$I_{i} \\rightarrow H_{i}$、$O \\rightarrow H_{o}$、$R \\rightarrow X$、$C \\rightarrow X$。\n\n假设节点 $R$ 处的提前返回会立即将控制权转移到唯一出口 $X$，绕过清理块 $C$。\n\n在一个具有唯一出口的图中，使用后支配的基本定义——当且仅当从节点 $n$ 到出口节点 $X$ 的每一条路径都包含节点 $p$ 时，节点 $p$ 后支配节点 $n$——执行以下操作：\n\n1. 计算每个节点 $n \\in V$ 的后支配节点集 $POD(n)$，其中 $V = \\{E, A, H_{o}, H_{i}, B, R, I_{i}, O, C, X\\}$。\n2. 令 $U = \\{\\, n \\in V \\mid C \\in POD(n) \\,\\}$。计算其基数 $|U|$。\n3. 令 $S = \\sum_{n \\in V} |POD(n)|$。将 $S$ 作为最终答案报告。\n\n然后，仅根据计算出的后支配节点集和后支配的定义，讨论当存在提前返回时，将清理块 $C$ 放置在循环之后是否能确保清理操作在所有可能的到达出口的路径上都会执行，并证明你的结论。\n\n将最终答案表示为精确整数 $S$。无需四舍五入。", "solution": "该问题要求使用后支配的概念来分析给定的控制流图（CFG）。当且仅当从节点 $n$ 到唯一出口节点 $X$ 的每一条路径都包含节点 $p$ 时，节点 $p$ 才后支配节点 $n$。节点 $n$ 的所有后支配节点的集合记为 $POD(n)$。根据定义，每个节点都后支配其自身，因此对于所有 $n \\in V$，都有 $n \\in POD(n)$。\n\n图中的节点集合为 $V = \\{E, A, H_{o}, H_{i}, B, R, I_{i}, O, C, X\\}$。边定义了控制流。我们将通过系统地分析从每个节点到出口节点 $X$ 的所有路径，来计算每个节点的后支配节点集。\n\n1.  **后支配节点集 $POD(n)$ 的计算**\n\n    *   **$POD(X)$**：从 $X$ 到 $X$ 的唯一路径是长度为0的平凡路径。此路径仅包含节点 $X$。因此，$POD(X) = \\{X\\}$。其基数为 $|POD(X)| = 1$。\n\n    *   **$POD(C)$**：$C$ 的唯一后继节点是 $X$。因此，从 $C$ 到 $X$ 的每条路径都以边 $C \\rightarrow X$ 开始，形式为 $(C, \\dots, X)$。该路径为 $(C, X)$。此路径上的节点为 $C$ 和 $X$。因此，$POD(C) = \\{C, X\\}$。其基数为 $|POD(C)| = 2$。\n\n    *   **$POD(R)$**：$R$ 的唯一后继节点是 $X$。从 $R$ 到 $X$ 的唯一路径是 $(R, X)$。此路径上的节点为 $R$ 和 $X$。因此，$POD(R) = \\{R, X\\}$。其基数为 $|POD(R)| = 2$。\n\n    *   **$POD(H_o)$**：节点 $H_o$ 有两个后继节点，$H_i$ 和 $C$。这产生了通往 $X$ 的两类路径：\n        1.  经由 $C$ 的路径：$H_o \\rightarrow C \\rightarrow X$。\n        2.  经由 $H_i$ 的路径：例如，$H_o \\rightarrow H_i \\rightarrow B \\rightarrow R \\rightarrow X$。\n        路径1不包含 $H_i$、$B$ 或 $R$。路径2不包含 $C$。从 $H_o$到 $X$ 的所有可能路径的公共节点只有 $H_o$ 本身和出口节点 $X$。因此，$POD(H_o) = \\{H_o, X\\}$。其基数为 $|POD(H_o)| = 2$。\n\n    *   **$POD(A)$**：$A$ 的唯一后继节点是 $H_o$。任何从 $A$ 到 $X$ 的路径都必须首先经过 $H_o$。因此，任何从 $A$ 到 $X$ 的路径都是边 $(A, H_o)$ 与一条从 $H_o$ 到 $X$ 的路径的拼接。所以，$A$ 的后支配节点集包括 $A$ 和 $H_o$ 的所有后支配节点。$POD(A) = \\{A\\} \\cup POD(H_o) = \\{A, H_o, X\\}$。其基数为 $|POD(A)| = 3$。\n\n    *   **$POD(E)$**：$E$ 的唯一后继节点是 $A$。与节点 $A$ 的逻辑相同，任何从入口 $E$ 到 $X$ 的路径都必须经过 $A$。因此，$POD(E) = \\{E\\} \\cup POD(A) = \\{E, A, H_o, X\\}$。其基数为 $|POD(E)| = 4$。\n\n    *   **$POD(H_i)$**：节点 $H_i$ 有两个后继节点，$B$ 和 $O$。这产生了通往 $X$ 的两类路径：\n        1.  经由 $B$ 的路径：例如，$H_i \\rightarrow B \\rightarrow R \\rightarrow X$。\n        2.  经由 $O$ 的路径：$H_i \\rightarrow O \\rightarrow H_o \\rightarrow C \\rightarrow X$。\n        第一条路径不包含 $O$、$H_o$ 或 $C$。第二条路径不包含 $B$ 或 $R$。从 $H_i$ 到 $X$ 的每条路径都包含的节点只有 $H_i$ 和 $X$。因此，$POD(H_i) = \\{H_i, X\\}$。其基数为 $|POD(H_i)| = 2$。\n\n    *   **$POD(I_i)$**：$I_i$ 的唯一后继节点是 $H_i$。从 $I_i$ 到 $X$ 的每条路径都必须经过 $H_i$。因此，$POD(I_i) = \\{I_i\\} \\cup POD(H_i) = \\{I_i, H_i, X\\}$。其基数为 $|POD(I_i)| = 3$。\n\n    *   **$POD(O)$**：$O$ 的唯一后继节点是 $H_o$。从 $O$ 到 $X$ 的每条路径都必须经过 $H_o$。因此，$POD(O) = \\{O\\} \\cup POD(H_o) = \\{O, H_o, X\\}$。其基数为 $|POD(O)| = 3$。\n\n    *   **$POD(B)$**：节点 $B$ 有两个后继节点，$R$ 和 $I_i$。这产生了通往 $X$ 的两类路径：\n        1.  经由 $R$ 的提前返回路径：$B \\rightarrow R \\rightarrow X$。\n        2.  经由 $I_i$ 继续循环的路径：例如，$B \\rightarrow I_i \\rightarrow H_i \\rightarrow O \\rightarrow H_o \\rightarrow C \\rightarrow X$。\n        第一条路径不包含 $I_i$、$H_i$、$O$、$H_o$ 或 $C$。第二条路径不包含 $R$。这两条路径的节点集的交集只包含 $B$ 和 $X$。所以，$POD(B) = \\{B, X\\}$。其基数为 $|POD(B)| = 2$。\n\n2.  **计算 $U = \\{\\, n \\in V \\mid C \\in POD(n) \\,\\}$ 的基数**\n\n我们检查上面计算出的后支配节点集，找出哪些集合包含节点 $C$。\n- $POD(E) = \\{E, A, H_o, X\\}$\n- $POD(A) = \\{A, H_o, X\\}$\n- $POD(H_o) = \\{H_o, X\\}$\n- $POD(H_i) = \\{H_i, X\\}$\n- $POD(B) = \\{B, X\\}$\n- $POD(R) = \\{R, X\\}$\n- $POD(I_i) = \\{I_i, H_i, X\\}$\n- $POD(O) = \\{O, H_o, X\\}$\n- $POD(C) = \\{C, X\\}$\n- $POD(X) = \\{X\\}$\n\n只有 $POD(C)$ 包含节点 $C$。因此，集合 $U$ 为 $U = \\{C\\}$。其基数为 $|U|=1$。\n\n3.  **计算 $S = \\sum_{n \\in V} |POD(n)|$**\n\n我们将十个计算出的后支配节点集的基数相加：\n$S = |POD(E)| + |POD(A)| + |POD(H_o)| + |POD(H_i)| + |POD(B)| + |POD(R)| + |POD(I_i)| + |POD(O)| + |POD(C)| + |POD(X)|$\n$S = 4 + 3 + 2 + 2 + 2 + 2 + 3 + 3 + 2 + 1$\n$S = 24$。\n\n**关于清理块执行的讨论**\n\n问题在于，将清理块 $C$ 放置在循环之后是否能确保它在所有可能的路径上都执行。\n从任何起点 $n$ 开始，块 $p$ 的执行得到保证，这在形式上等价于 $p$ 后支配 $n$ 的陈述，即 $p \\in POD(n)$。在此背景下，要保证清理块 $C$ 无论程序路径如何都能执行，它必须后支配入口节点 $E$。\n\n我们的计算表明 $POD(E) = \\{E, A, H_o, X\\}$。由于 $C \\notin POD(E)$，我们可以得出结论，至少存在一条从入口 $E$ 到出口 $X$ 的路径不经过 $C$。\n提前返回的存在提供了这样一条路径：$E \\rightarrow A \\rightarrow H_o \\rightarrow H_i \\rightarrow B \\rightarrow R \\rightarrow X$。这条路径完全绕过了清理节点 $C$。\n\n我们对集合 $U = \\{C\\}$ 的计算直接证明了这一点。集合 $U$ 包含了图中所有满足“从其出发到出口的每条路径都必须经过 $C$”的节点。由于 $U$ 只包含 $C$ 本身，因此图中没有其他节点（包括入口 $E$、循环头 $H_o$ 和 $H_i$ 以及循环体）能保证其清理操作的执行。因此，基于后支配分析，由于提前返回机制的存在，将清理块 $C$ 放在这个位置并**不能**确保它在所有可能的路径上都会执行。", "answer": "$$\\boxed{24}$$", "id": "3633304"}]}