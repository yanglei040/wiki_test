{"hands_on_practices": [{"introduction": "过程内联不仅仅是简单的代码替换，它还会将底层实现的细节暴露给优化器。本练习探讨了内联与C语言中“有符号整型溢出”这一未定义行为（Undefined Behavior, UB）之间的相互作用。通过分析优化器如何利用未定义行为来改变程序逻辑，您将更深刻地理解此项优化可能带来的微妙且出人意料的后果 [@problem_id:3664201]。", "problem": "考虑一个使用有符号整数的 C 语言程序。该程序定义了三个过程：一个计算和的辅助过程，一个试图通过将结果与一个操作数进行比较来防止溢出的过程，以及一个传递常量增量的客户端过程。具体来说，设 $\\text{add}$ 是一个定义为 $\\text{add}(\\text{a}, \\text{b})$ 的过程，返回有符号和 $\\text{a} + \\text{b}$。设 $\\text{safe\\_sum}(\\text{x}, \\text{y})$ 计算 $\\text{s} = \\text{add}(\\text{x}, \\text{y})$，如果 $\\text{s}  \\text{x}$，则返回 $\\text{x}$，否则返回 $\\text{s}$。设 $\\text{client}(\\text{n})$ 调用 $\\text{safe\\_sum}(\\text{n}, 1)$ 并返回结果。假设在没有链接时优化 (Link-Time Optimization, LTO) 的情况下进行分别编译，因此编译包含 $\\text{safe\\_sum}$ 的单元时，既不会内联 $\\text{add}$，也看不到来自 $\\text{client}$ 的实际参数 $\\text{y} = 1$；并将其与启用全程序内联的构建进行对比，后者允许编译器将 $\\text{add}$ 内联到 $\\text{safe\\_sum}$ 中，再将 $\\text{safe\\_sum}$ 内联到 $\\text{client}$ 中。\n\n使用的基本事实：\n- 在 C 语言中，有符号整数溢出是未定义行为：如果 $\\text{a} + \\text{b}$ 的数学结果不适合 $\\text{int}$ 类型的范围，则程序对该操作没有已定义的语义。\n- 过程内联是一种保持语义的转换，它用被调用者的主体替换调用，从而向优化器（如值域传播和代数简化）暴露更多代码。\n- 在二进制补码硬件上，对 $w$ 位字执行的机器加法计算结果模 $2^w$。然而，除非实现或标志另有规定，C 语言并未将有符号溢出定义为使用模 $2^w$；相反，它是未定义行为。\n- 对于数学整数，加上一个正常量是严格单调的：对于所有整数 $x$，$x + 1 > x$。\n\n假设客户端可能被以 $\\text{n} = \\text{INT\\_MAX}$ 调用，其中 $\\text{INT\\_MAX}$ 表示 $\\text{int}$ 类型的最大可表示值。回答以下关于过程内联如何暴露未定义行为从而改变优化结果，以及关于缓解措施（如编译器标志 `-fwrapv` 或通过像 Undefined Behavior Sanitizer (UBSan) 这样的清理器进行插桩）的多项选择题。\n\n以下哪些陈述是正确的？选择所有适用的选项。\n\nA. 将 $\\text{add}$ 的主体内联到 $\\text{safe\\_sum}$ 中，并进一步内联到 $\\text{client}$ 后，优化器可以利用对于有定义的有符号整数执行，加 $1$ 是严格单调的这一事实，来证明 $(\\text{n} + 1)  \\text{n}$ 为假并移除该条件，从而改变在像 $\\text{n} = \\text{INT\\_MAX}$ 这样的输入上的可观察结果，因为这些输入会触发未定义行为。\n\nB. 使用 `-fwrapv` 编译会强制有符号加法进行模 $2^w$ 回绕，因此优化器不能假设对于所有 $\\text{n}$ 都有 $(\\text{n} + 1) > \\text{n}$，所以不能消除该条件；无论过程是否内联，行为都保持一致。\n\nC. 启用 `-fsanitize=signed-integer-overflow` 会改变语言语义，将有符号溢出定义为模运算，从而保证无论是否内联，结果都相同。\n\nD. 如果程序被重写以对 $\\text{x}$、$\\text{y}$ 和 $\\text{s}$ 使用无符号整数，那么溢出被定义为模 $2^w$ 运算，而测试 $\\text{s}  \\text{x}$ 成为一种定义明确的、用于在加上一个正数 $\\text{y}$ 时检测进位的机制；编译器必须保留可观察的结果，而不管是否内联。\n\nE. 过程内联不能改变优化结果，因为它从不改变优化器可见的数据或控制依赖，因此与未定义行为没有相互作用。", "solution": "用户希望我验证问题陈述，如果有效，则提供详细的解决方案。\n\n### 步骤 1：提取已知信息\n- **语言**：C，使用有符号整数。\n- **过程 `add(a, b)`**：一个返回有符号和 `a + b` 的过程。\n- **过程 `safe_sum(x, y)`**：一个计算 `s = add(x, y)` 并在 `s  x` 时返回 `x`，否则返回 `s` 的过程。\n- **过程 `client(n)`**：一个调用 `safe_sum(n, 1)` 并返回其结果的过程。\n- **编译场景 1（无内联）**：分别编译，无链接时优化 (LTO)。`safe_sum` 的编译器不内联 `add`，`client` 的编译器不内联 `safe_sum`。在编译 `safe_sum` 时，常量参数 `y = 1` 是不可见的。\n- **编译场景 2（内联）**：启用全程序内联。编译器可以将 `add` 内联到 `safe_sum` 中，再将 `safe_sum` 内联到 `client` 中。\n- **基本事实 1**：C 语言中的有符号整数溢出是未定义行为 (UB)。\n- **基本事实 2**：过程内联是一种保持语义的转换。\n- **基本事实 3**：二进制补码硬件计算加法模 $2^w$。C 语言默认情况下不这样定义有符号溢出；它是 UB。\n- **基本事实 4**：对于数学整数，加上一个正常量是严格单调的，即对于所有整数 $x$，$x + 1 > x$。\n- **测试用例**：客户端可能被以 `n = INT_MAX` 调用。\n- **问题背景**：问题探究了过程内联、未定义行为、优化以及编译器标志/插桩之间的相互作用。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学上成立**：该问题基于 ISO C 标准定义的 C 编程语言的形式语义以及现代优化编译器（如 GCC 和 Clang）的实际行为。语言的抽象机（将有符号溢出定义为 UB）与目标硬件的行为（二进制补码回绕）之间的区别是系统编程和编译器设计中一个核心且公认的概念。所有概念——内联、LTO、未定义行为、`-fwrapv` 和清理器——都是标准的并且描述正确。\n2.  **适定性**：问题是适定的。它设置了两个清晰、可分析的场景（有内联和无内联），并询问其后果。关于优化器如何基于 C 标准的 UB 规则对代码进行推理的分析，可以得出一个关于程序行为潜在变化的明确结论。\n3.  **客观性**：问题以精确、客观的语言陈述。它引用了特定的编译器特性和 C 语言规则，没有歧义或主观性。\n\n问题陈述没有可辨别的缺陷。这是一个关于编译器优化和语言语义的有效且有见地的问题。\n\n### 步骤 3：结论与行动\n问题是有效的。我现在将推导解决方案并评估每个选项。\n\n### 基于原则的推导\n在 C 标准中，有符号整数溢出导致未定义行为。这为编译器提供了一个关键的许可：它可以假设任何*可能*溢出的操作在任何有效的程序执行中*实际上永远不会*溢出。如果一个操作会导致溢出，程序就已经进入了 UB 的领域，编译器没有义务产生任何特定的结果。\n\n**无内联分析（场景 1）**\n1.  `client` 函数被编译。它包含对外部函数 `safe_sum(n, 1)` 的调用。编译器看不到 `safe_sum` 的主体。\n2.  `safe_sum` 函数被单独编译。它包含对外部函数 `add(x, y)` 的调用。编译器知道 `y` 是一个参数，但不知道它将永远是 $1$。\n3.  当 `client(INT_MAX)` 执行时，它调用 `safe_sum(INT_MAX, 1)`。\n4.  `safe_sum` 接着调用 `add(INT_MAX, 1)`。加法 `INT_MAX + 1` 溢出。在机器层面，典型的二进制补码硬件上，这会回绕到 `INT_MIN`。我们假设这种行为。\n5.  `add` 返回 `INT_MIN`。这个值在 `safe_sum` 中赋给 `s`。\n6.  条件 `s  x` 被求值。这变成 `INT_MIN  INT_MAX`。这是真的。\n7.  `safe_sum` 返回 `x`，即 `INT_MAX`。\n8.  `client` 返回 `INT_MAX`。\n这个结果虽然常见，但它依赖于实现定义的行为（溢出的结果），并且由于函数调用边界的不透明性，该行为没有被激进地优化掉。这个“防护”似乎起作用了。\n\n**有内联分析（场景 2）**\n1.  启用全程序优化。编译器首先将 `add` 内联到 `safe_sum` 中。`safe_sum` 的主体实际上变成 `s = x + y; if (s  x) return x; else return s;`。\n2.  接着，编译器将这个版本的 `safe_sum` 内联到 `client` 中，用 `n` 替换 `x`，用常量 `1` 替换 `y`。`client` 的主体实际上变成 `s = n + 1; if (s  n) return n; else return s;`。\n3.  优化器现在分析这个统一的代码块：`if ((n + 1)  n)`。\n4.  C 标准允许优化器假设有符号溢出不会发生。基于这个假设和数学整数的规则（基本事实 4），`n + 1` 总是大于 `n`。\n5.  因此，对于任何不涉及 UB 的执行路径，条件 `(n + 1)  n` 可被证明为假。\n6.  优化器可以合法地消除该条件分支和 `if` 块，将函数简化为 `return n + 1;`。\n7.  当这个优化版本的 `client(INT_MAX)` 执行时，它直接计算 `INT_MAX + 1`。这会溢出，并在同样的二进制补码硬件上产生 `INT_MIN`。\n8.  优化后的 `client` 返回 `INT_MIN`。\n\n**结论**：内联同时向优化器暴露了操作和检查。优化器使用“无 UB”假设来证明检查是多余的并将其移除。这改变了程序对于导致溢出的输入 `n = INT_MAX` 的可观察行为，从 `INT_MAX` 变为 `INT_MIN`。\n\n### 逐项分析\n\n**A. 将 $\\text{add}$ 的主体内联到 $\\text{safe\\_sum}$ 中，并进一步内联到 $\\text{client}$ 后，优化器可以利用对于有定义的有符号整数执行，加 $1$ 是严格单调的这一事实，来证明 $(\\text{n} + 1)  \\text{n}$ 为假并移除该条件，从而改变在像 $\\text{n} = \\text{INT\\_MAX}$ 这样的输入上的可观察结果，因为这些输入会触发未定义行为。**\n此陈述准确地描述了上面推导的推理过程。优化器假设没有 UB，这意味着对于有符号整数，`n + 1 > n`。这使得检查 `(n + 1)  n` 看起来是不可能的，导致其被消除。当程序随后以 `n = INT_MAX` 运行时，底层的 `n + 1` 操作确实导致了 UB，但防护措施已经被移除，导致了与非内联情况（`INT_MAX`）不同的结果（`INT_MIN`）。\n**结论：正确**\n\n**B. 使用 `-fwrapv` 编译会强制有符号加法进行模 $2^w$ 回绕，因此优化器不能假设对于所有 $\\text{n}$ 都有 $(\\text{n} + 1) > \\text{n}$，所以不能消除该条件；无论过程是否内联，行为都保持一致。**\n编译器标志 `-fwrapv`（在 GCC/Clang 上）改变了有符号整数运算的语义。它使溢出被明确定义为模（二进制补码）回绕。因此，`n + 1 > n` 的假设不再有效，因为编译器现在必须考虑 `n = INT_MAX` 的情况，此时 `n + 1` 会回绕到 `INT_MIN`。由于在已定义的语义下，条件 `(n + 1)  n` 现在可能为真，优化器不能消除该条件分支。因为行为是明确定义的，内联（一种保持语义的转换）不会改变结果。在两种情况（内联或非内联）下，`client(INT_MAX)` 都会正确评估条件并返回 `INT_MAX`。\n**结论：正确**\n\n**C. 启用 `-fsanitize=signed-integer-overflow` 会改变语言语义，将有符号溢出定义为模运算，从而保证无论是否内联，结果都相同。**\n此陈述错误地描述了清理器的功能。`-fsanitize=signed-integer-overflow` (UBSan) 不会为优化器改变语言语义。它通过运行时检查来对代码进行插桩，以捕获未定义行为。在加法之前，它会插入代码来检查 `a + b` 是否会溢出。如果会，它会调用一个运行时处理程序，该程序通常会打印错误并中止程序。它*不*将结果定义为模运算；那是 `-fwrapv` 的作用。因此，其前提是错误的。\n**结论：错误**\n\n**D. 如果程序被重写以对 $\\text{x}$、$\\text{y}$ 和 $\\text{s}$ 使用无符号整数，那么溢出被定义为模 $2^w$ 运算，而测试 $\\text{s}  \\text{x}$ 成为一种定义明确的、用于在加上一个正数 $\\text{y}$ 时检测进位的机制；编译器必须保留可观察的结果，而不管是否内联。**\n这是正确的。根据 C 标准，无符号整数运算被明确定义为模运算。一个和 `s = x + y`（其中 `x, y` 为无符号正数）导致 `s  x` 是检测发生回绕（溢出）的标准、可移植的方法。由于所有操作都具有明确定义的语义，编译器不能自由地做出与这些语义相矛盾的简化假设（例如，它不能假设 `x + 1 > x`）。它必须保留检查的逻辑。内联是一种保持语义的转换，并且由于语义是完全定义的，无论是否内联，行为都将相同。\n**结论：正确**\n\n**E. 过程内联不能改变优化结果，因为它从不改变优化器可见的数据或控制依赖，因此与未定义行为没有相互作用。**\n此陈述根本上是错误的。内联的一个主要动机恰恰是*增加*在单个函数范围内对优化器可见的代码，从而揭示新的优化机会。正如主要分析所示，将 `add` 和 `safe_sum` 内联到 `client` 中，才向优化器暴露了 `(n + 1)  n` 的模式，使其能够利用关于 UB 的假设。内联绝对会改变优化的上下文。\n**结论：错误**", "answer": "$$\\boxed{ABD}$$", "id": "3664201"}, {"introduction": "编译器的优化旨在提升性能，但绝不能违背语言的核心语义规则。本练习研究了内联如何与精确的异常处理机制相互作用，这是一个关键的正确性约束。通过这个练习，您将了解为什么异常处理区域的边界会成为代码移动的重要屏障，从而确保优化不会无意中改变捕获异常的处理程序 [@problem_id:3664251]。", "problem": "一种具有精确异常语义的语言的编译器必须保留接收异常的动态封闭 catch-handler。设语义如下：在任何程序点 $p$，令 $H(p)$ 表示从内到外动态活动处理程序的有序集合。当在点 $p$ 的指令抛出类型为 $T$ 的异常时，控制权将转移到 $H(p)$ 中其过滤器与 $T$ 匹配的最近的处理程序，并根据需要进行栈回溯。过程内联用被调用者的主体替换调用，同时保留控制流和可观察行为。\n\n考虑以下抽象表示的源级情况。有一个异常类型 $E$。调用者按顺序执行：一个捕获 $E$ 的 try-catch 块，然后调用 $B$，接着调用 $C$，再调用 $F$，最后调用 $S$。在 try 内部，它调用 $A$。$E$ 的 catch 处理程序执行 $R$。所有调用 $A$、$B$、$C$、$D$、$R$ 和 $S$ 都可能有副作用，但它们中没有一个会抛出 $E$（它们可能抛出与此无关的其他类型）。谓词 $P$ 是纯的（没有副作用），唯一可能抛出 $E$ 的地方在 $F$ 内部：\n- 调用者: try { $A()$ } catch ($E$ $e$) { $R()$ } ; then $B()$ ; then $C()$ ; then $F()$ ; then $S()$.\n- 被调用者 $F$: if $P()$ then throw $E$ else $D()$.\n\n假设编译器在调用者中的调用点内联了 $F$。内联后，随后的局部代码移动或基本块合并过程将抛出 $E$ 的操作放置到一个文本上位于先前 try 区域内的基本块中（例如，通过合并直通块），从而有效地将可能抛出异常的指令跨越 try-catch 边界移动。这改变了在抛出点 $H(p)$ 中包含的处理程序。\n\n下列关于正确性和所需屏障的陈述中，哪些是正确的？选择所有适用的选项。\n\nA. 内联 $F$ 后，将抛出指令放置在任何基本块中都是保留语义的，只要异常的静态类型保持为 $E$ 即可，因为处理程序的选择仅取决于异常类型，而不取决于区域归属。\n\nB. 为保留精确异常，编译器必须将任何异常区域的入口和出口（例如，try 块的边界）视为任何可能抛出异常的指令的移动屏障；具体而言，仅当 $H(p) = H(q)$ 时，将可能抛出异常的指令从程序点 $p$ 移动到 $q$ 才是正确的。\n\nC. 如果 catch 处理程序立即重新抛出相同的异常且没有副作用，那么将抛出 $E$ 的操作从 try 外部移动到 try 区域内部是保留语义的，因为该异常最终会像以前一样传播。\n\nD. 在零成本异常实现中（例如，表驱动的回溯），只要相应地更新回溯表，内联就允许将抛出操作跨越 try-catch 边界移动，因为活动处理程序集是在链接时而不是在运行时重新计算的。\n\nE. 将一个不能抛出异常的纯指令跨越 try-catch 边界移动是安全的，但移动一个可能抛出异常的指令则不安全；因此，异常区域边界充当了一个条件性调度屏障，其取决于指令的“可能抛出”（may-throw）属性。", "solution": "问题陈述是有效的。它在编译器理论中提出了一个定义明确的场景，涉及代码优化（特别是过程内联和代码移动）与精确异常处理语义之间的相互作用。所使用的术语是该领域的标准术语，其设置在内部是一致的，并以计算机科学原理为科学基础。\n\n问题的核心在于保留“可观察行为”的要求。对于具有精确异常的语言，这包括确保在程序动态执行期间从给定点抛出的异常总是被同一个处理程序捕获。在程序点 $p$ 的动态活动处理程序集用 $H(p)$ 表示。所描述的转换是一个代码移动过程，它将一个可能抛出异常的指令从程序点 $p_{original}$ 移动到一个新点 $p_{new}$。仅当该指令抛出的异常在原始程序和转换后的程序中都被同一个处理程序捕获时，此转换在语义上才是有效的。这反过来要求相关处理程序集对于所讨论的指令保持不变。\n\n让我们分析转换前后的程序行为。\n\n**原始程序行为：**\n代码结构为：`try { A() } catch (E e) { R() } ; B() ; C() ; F() ; S()`.\n对 $F()$ 的调用发生在 `try-catch` 块完成*之后*。\n$F()$ 的主体是 `if P() then throw E else D()`。\n让我们考虑谓词 $P()$ 求值为真的执行路径。\n$1$. `try-catch` 块执行。调用 $A()$。该块完成。处理程序 `catch (E e)` 不再是动态活动的。\n$2$. 调用 $B()$ 执行。\n$3$. 调用 $C()$ 执行。\n$4$. 调用 $F()$。在 $F()$ 内部，`throw E` 被执行。\n$5$. 在此程序点 $p_{original}$，处理程序 `catch (E e)` 不在活动处理程序集 $H(p_{original})$ 中。异常 $E$ 沿调用栈向上传播，被在所示上下文之外的调用上下文中定义的处理程序捕获，或者如果没有这样的处理程序，则终止程序。处理程序主体 $R()$ 不被执行。由于异常引起的控制流转移，随后的 $S()$ 调用也不会被执行。\n产生副作用的调用序列是 $A()$，然后是 $B()$，然后是 $C()$。\n\n**转换后程序行为：**\n编译器首先内联 $F()$，得到：\n`try { A() } catch (E e) { R() } ; B() ; C() ; if P() then throw E else D() ; S()`\n然后，一个代码移动过程将 `throw E` 指令移动到一个新程序点 $p_{new}$，该点位于 `try` 块内部。概念上的结果是：\n`try { A(); if (P()) throw E; ... } catch (E e) { R() } ; B() ; C() ; ... D() ; S()`\n让我们分析 $P()$ 为真的执行路径。\n$1$. 进入 `try` 块。处理程序 `catch (E e)` 现在是动态活动的。\n$2$. 调用 $A()$。\n$3$. `if (P()) throw E` 语句被执行。由于 $P()$ 为真，`throw E` 在程序点 $p_{new}$ 发生。\n$4$. 此时，活动处理程序集 $H(p_{new})$ 将 `catch (E e)` 块作为类型 $E$ 的最内层处理程序。控制权转移到此处理程序。\n$5$. 处理程序主体 $R()$ 被执行。\n$6$. `catch` 块完成后，执行从 `try-catch` 结构之后的语句继续：$B()$，然后是 $C()$，然后很可能是 $D()$（如果它没有被移动或优化掉），最后是 $S()$。\n产生副作用的调用序列是 $A()$，然后是 $R()$，然后是 $B()$，然后是 $C()$，然后是 $D()$，最后是 $S()$。\n\n**分析结论：**\n该转换是不正确的。它改变了捕获异常的处理程序（从一个外部处理程序变为本地的 `catch(E e)`），并改变了已执行的带副作用函数的序列。这种无效性的根本原因是该指令在两个活动处理程序集不同的点之间移动，即 $p_{original}$ 和 $p_{new}$，其中 $H(p_{original}) \\neq H(p_{new})$。\n\n现在，我们评估每个选项。\n\n**A. 内联 $F$ 后，将抛出指令放置在任何基本块中都是保留语义的，只要异常的静态类型保持为 $E$ 即可，因为处理程序的选择仅取决于异常类型，而不取决于区域归属。**\n这个陈述是错误的。如分析所示，处理程序的选择严重依赖于动态上下文，而动态上下文由“区域归属”决定——即，抛出操作是否发生在 `try` 块的动态作用域内。将 `throw E` 指令跨越 `try` 块边界移动，直接改变了哪个 `catch` 处理程序被选中。因此，处理程序的选择同时取决于异常类型和抛出操作的程序点。\n\n**B. 为保留精确异常，编译器必须将任何异常区域的入口和出口（例如，try 块的边界）视为任何可能抛出异常的指令的移动屏障；具体而言，仅当 $H(p) = H(q)$ 时，将可能抛出异常的指令从程序点 $p$ 移动到 $q$ 才是正确的。**\n这个陈述是正确的。它为在代码移动期间保留异常语义提供了精确的形式化条件。如果活动异常处理程序集 $H(p)$ 与 $H(q)$ 不同，则可能抛出异常的指令不能从点 $p$ 移动到点 $q$。`try` 块的边界是代码中活动处理程序集发生变化的主要位置。因此，这些边界必须作为任何可能抛出异常的指令的移动屏障，除非编译器能够证明处理程序集是等价的（在跨越 `try` 边界时通常情况并非如此）。\n\n**C. 如果 catch 处理程序立即重新抛出相同的异常且没有副作用，那么将抛出 $E$ 的操作从 try 外部移动到 try 区域内部是保留语义的，因为该异常最终会像以前一样传播。**\n这个陈述是错误的。假设处理程序是 `catch(E e) { throw; }`。在转换后的程序中，如果 $P()$ 为真，执行序列将是：调用 $A()$，然后 `throw E` 发生。异常被本地处理程序捕获，该处理程序立即重新抛出它。这个重新抛出的异常确实会被与原始程序中相同的外部处理程序捕获。然而，对 $B()$ 和 $C()$ 的带副作用的调用现在被完全跳过，而在原始程序中它们是在异常抛出之前执行的。可观察行为（副作用的序列）已被改变。因此，该转换不是保留语义的。\n\n**D. 在零成本异常实现中（例如，表驱动的回溯），只要相应地更新回溯表，内联就允许将抛出操作跨越 try-catch 边界移动，因为活动处理程序集是在链接时而不是在运行时重新计算的。**\n这个陈述是错误的。它将实现机制与该实现必须遵守的语言语义混淆了。零成本异常实现使用静态表来将程序计数器范围映射到处理程序。虽然编译器*可以*更新这些表以反映任何代码转换，但它*必须*以保留原始程序语义的方式进行。如果转换在语义上是无效的（如此处所示），那么无论如何更新表都无法使其有效。必须配置表以确保 `throw` 调用*原始*处理程序，而不是使其对*新*处理程序的调用合法化。实现细节并不授予违反语义契约的许可。\n\n**E. 将一个不能抛出异常的纯指令跨越 try-catch 边界移动是安全的，但移动一个可能抛出异常的指令则不安全；因此，异常区域边界充当了一个条件性调度屏障，其取决于指令的“可能抛出”（may-throw）属性。**\n这个陈述是正确的。它准确地描述了对编译器指令调度器的实际影响。\n- 一个纯的（无副作用）且不能抛出异常的指令不与异常处理机制交互。在遵守数据依赖的前提下，将其跨越 `try-catch` 边界移动不会改变程序的可观察行为。\n- 正如在对B的分析中所确立的，如果改变了处理程序集，一个可能抛出异常的指令*不能*被移动过这个边界。\n- 因此，异常区域的边界充当一个“条件性”屏障：它阻止一类指令（可能抛出的指令）的移动，但允许另一类指令（纯且不能抛出的指令）的移动。这是对情况的精确和正确的描述。", "answer": "$$\\boxed{BE}$$", "id": "3664251"}, {"introduction": "编译器并不会内联所有可能的函数调用，而是在权衡利弊后做出战略决策。本问题将内联决策过程建模为一个经典的 0-1 背包问题，目标是在不超过代码体积预算的前提下，最大化性能收益。通过构建并解决这个优化问题，您将理解内联的启发式本质，以及编译器如何在速度提升和代码膨胀成本之间取得平衡 [@problem_id:3664279]。", "problem": "考虑一个编译器对一个程序执行过程内联，该程序由一个调用图表示，其节点为过程，有向边 $(i,j)$ 表示从过程 $i$ 到过程 $j$ 的一次调用。每个过程 $i$ 的代码大小为 $s_i$（以字节为单位），每个调用边 $(i,j)$ 以频率 $f_{ij}$（每次运行的调用次数）执行，内联调用 $(i,j)$ 会带来每次调用 $b_{ij}$（以周期为单位）的运行时减少量。内联将被调用者的主体复制到调用者中，并移除调用点的指令序列，导致边 $(i,j)$ 上的代码大小变化等于 $\\Delta s_{ij} = s_j - o_{ij}$，其中 $o_{ij}$（以字节为单位）是通过内联消除的调用序列和序言/尾声代码的大小。一个全局代码大小预算 $B$（以字节为单位）约束了所有选定内联操作带来的总代码大小增加量。\n\n从以下基本编译器原理出发：一组内联调用带来的预期总运行时减少量等于在所有调用点上，每次调用的节省量乘以其执行频率的总和；并且内联会因被调用者代码的复制而增加代码大小，减去移除的调用点开销。基于此，建立一个优化问题模型，该模型选择一个调用边的子集进行内联，以在代码大小预算约束下最大化预期总运行时减少量。然后，对下面的具体实例求解该优化问题，并计算确切的最大总运行时减少量，结果表示为整数个周期。\n\n过程及大小（字节）:\n- $F_1$: $s_1 = 120$，$F_2$: $s_2 = 80$，$F_3$: $s_3 = 200$，$F_4$: $s_4 = 50$，$F_5$: $s_5 = 160$。\n\n调用边，包括频率 $f_{ij}$（每次运行的调用次数）、每次调用的节省量 $b_{ij}$（周期）和可移除的开销大小 $o_{ij}$（字节）:\n- $(1,2)$: $f_{12} = 4000$, $b_{12} = 25$, $o_{12} = 6$。\n- $(1,3)$: $f_{13} = 500$, $b_{13} = 90$, $o_{13} = 10$。\n- $(4,2)$: $f_{42} = 6000$, $b_{42} = 10$, $o_{42} = 6$。\n- $(4,5)$: $f_{45} = 800$, $b_{45} = 120$, $o_{45} = 12$。\n- $(3,5)$: $f_{35} = 300$, $b_{35} = 200$, $o_{35} = 12$。\n\n预算:\n- $B = 300$ 字节。\n\n说明:\n- 如上所述，从第一性原理推导出目标和约束。\n- 计算要内联的调用边的最优选择以及由此产生的最大总运行时减少量（以周期为单位）。\n- 最终答案以整数个周期表示。无需四舍五入。", "solution": "编译器中过程内联的基本原理是：\n- 内联用过程 $j$ 的主体替换调用者 $i$ 中的调用 $(i,j)$，这可以通过移除调用开销和促成本地优化来减少运行时。如果 $(i,j)$ 的每次调用减少量为 $b_{ij}$ 个周期，且该边每次运行执行 $f_{ij}$ 次，则内联 $(i,j)$ 贡献的预期总运行时减少量为 $f_{ij} \\cdot b_{ij}$ 个周期。\n- 内联会因将被调用者的主体复制到调用者中而增加代码大小。在一个简单的加法模型下，边 $(i,j)$ 上的代码大小增加量为 $\\Delta s_{ij} = s_j - o_{ij}$，其中 $o_{ij}$ 计入了在调用点消除的调用序列和序言/尾声代码。\n\n为了选择一个调用边的子集进行内联，为每个调用边 $(i,j)$ 定义一个二元决策变量 $x_{ij} \\in \\{0,1\\}$，其中 $x_{ij} = 1$ 表示内联 $(i,j)$，$x_{ij} = 0$ 表示不内联。预期总运行时减少量为\n$$\n\\sum_{(i,j)} f_{ij} \\, b_{ij} \\, x_{ij},\n$$\n总代码大小增加量为\n$$\n\\sum_{(i,j)} \\Delta s_{ij} \\, x_{ij} = \\sum_{(i,j)} (s_j - o_{ij}) \\, x_{ij}.\n$$\n在代码大小预算 $B$ 的约束下，该优化问题是 0-1 背包问题：\n$$\n\\max_{x_{ij} \\in \\{0,1\\}} \\sum_{(i,j)} f_{ij} \\, b_{ij} \\, x_{ij}\n\\quad \\text{subject to} \\quad\n\\sum_{(i,j)} (s_j - o_{ij}) \\, x_{ij} \\le B.\n$$\n\n对于这个具体实例，首先计算权重 $\\Delta s_{ij}$ 和价值 $v_{ij} = f_{ij} \\cdot b_{ij}$：\n\n- $(1,2)$: $\\Delta s_{12} = s_2 - o_{12} = 80 - 6 = 74$ 字节, $v_{12} = f_{12} \\cdot b_{12} = 4000 \\cdot 25 = 100000$ 周期。\n- $(1,3)$: $\\Delta s_{13} = s_3 - o_{13} = 200 - 10 = 190$ 字节, $v_{13} = f_{13} \\cdot b_{13} = 500 \\cdot 90 = 45000$ 周期。\n- $(4,2)$: $\\Delta s_{42} = s_2 - o_{42} = 80 - 6 = 74$ 字节, $v_{42} = f_{42} \\cdot b_{42} = 6000 \\cdot 10 = 60000$ 周期。\n- $(4,5)$: $\\Delta s_{45} = s_5 - o_{45} = 160 - 12 = 148$ 字节, $v_{45} = f_{45} \\cdot b_{45} = 800 \\cdot 120 = 96000$ 周期。\n- $(3,5)$: $\\Delta s_{35} = s_5 - o_{35} = 160 - 12 = 148$ 字节, $v_{35} = f_{35} \\cdot b_{35} = 300 \\cdot 200 = 60000$ 周期。\n\n预算：$B = 300$ 字节。我们必须从这五个物品中选择一个子集，使其总权重最多为 $300$，且总价值最大。\n\n枚举可行组合：\n\n单边选择：\n- $(1,2)$: 权重 $74$，价值 $100000$。\n- $(1,3)$: 权重 $190$，价值 $45000$。\n- $(4,2)$: 权重 $74$，价值 $60000$。\n- $(4,5)$: 权重 $148$，价值 $96000$。\n- $(3,5)$: 权重 $148$，价值 $60000$。\n最佳单边价值是 $(1,2)$，为 $100000$ 周期。\n\n双边组合（权重和价值）：\n- $(1,2)+(1,3)$: $74 + 190 = 264$ 字节, $100000 + 45000 = 145000$ 周期。\n- $(1,2)+(4,2)$: $74 + 74 = 148$ 字节, $100000 + 60000 = 160000$ 周期。\n- $(1,2)+(4,5)$: $74 + 148 = 222$ 字节, $100000 + 96000 = 196000$ 周期。\n- $(1,2)+(3,5)$: $74 + 148 = 222$ 字节, $100000 + 60000 = 160000$ 周期。\n- $(1,3)+(4,2)$: $190 + 74 = 264$ 字节, $45000 + 60000 = 105000$ 周期。\n- $(1,3)+(4,5)$: $190 + 148 = 338$ 字节 (不可行)。\n- $(1,3)+(3,5)$: $190 + 148 = 338$ 字节 (不可行)。\n- $(4,2)+(4,5)$: $74 + 148 = 222$ 字节, $60000 + 96000 = 156000$ 周期。\n- $(4,2)+(3,5)$: $74 + 148 = 222$ 字节, $60000 + 60000 = 120000$ 周期。\n- $(4,5)+(3,5)$: $148 + 148 = 296$ 字节, $96000 + 60000 = 156000$ 周期。\n最佳双边价值是 $(1,2)+(4,5)$，为 $196000$ 周期。\n\n三边组合：\n- $(1,2)+(1,3)+(4,2)$: $74 + 190 + 74 = 338$ 字节 (不可行)。\n- $(1,2)+(1,3)+(4,5)$: $74 + 190 + 148 = 412$ 字节 (不可行)。\n- $(1,2)+(1,3)+(3,5)$: $74 + 190 + 148 = 412$ 字节 (不可行)。\n- $(1,2)+(4,2)+(4,5)$: $74 + 74 + 148 = 296$ 字节, $100000 + 60000 + 96000 = 256000$ 周期。\n- $(1,2)+(4,2)+(3,5)$: $74 + 74 + 148 = 296$ 字节, $100000 + 60000 + 60000 = 220000$ 周期。\n- $(1,2)+(4,5)+(3,5)$: $74 + 148 + 148 = 370$ 字节 (不可行)。\n- $(1,3)+(4,2)+(4,5)$: $190 + 74 + 148 = 412$ 字节 (不可行)。\n- $(1,3)+(4,2)+(3,5)$: $190 + 74 + 148 = 412$ 字节 (不可行)。\n- $(1,3)+(4,5)+(3,5)$: $190 + 148 + 148 = 486$ 字节 (不可行)。\n- $(4,2)+(4,5)+(3,5)$: $74 + 148 + 148 = 370$ 字节 (不可行)。\n在可行的三元组中，$(1,2)+(4,2)+(4,5)$ 产生 $256000$ 周期，是最佳的三元组。\n\n四边和五边组合会超出预算，因为任何包含 $(1,3)$ 的三元组已经超出预算，而增加更多的边只会增加权重。\n\n因此，最优子集是 $(1,2)$、$(4,2)$ 和 $(4,5)$，总权重为 $296 \\le 300$，总价值为 $256000$ 周期。因此，最大总运行时减少量是 $256000$ 周期。", "answer": "$$\\boxed{256000}$$", "id": "3664279"}]}