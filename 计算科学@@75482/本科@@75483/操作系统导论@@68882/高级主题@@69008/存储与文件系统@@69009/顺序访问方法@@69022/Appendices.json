{"hands_on_practices": [{"introduction": "这第一个练习是一项基础性的编程任务。你将扮演操作系统开发者的角色，在一个原始的块设备之上构建一个顺序访问方法（SAM）接口。通过实现将逻辑字节偏移量转换为物理块位置并管理一个简单缓存的逻辑，你将具体地理解高级文件API是如何在低级存储原语之上构建的。[@problem_id:3682261]", "problem": "在此教学操作系统场景中，您需要为一个抽象块设备实现一个顺序访问方法（SAM）接口。目标是规范化对物理存储在块设备上的字节可寻址区域的顺序访问，并将 open、next 和 rewind 操作映射为块读取和字节偏移量。该块设备提供连续的、固定大小的块，唯一允许的访问原语是块读取，它将整个块复制到 SAM 层可访问的缓存中。\n\n基本原理：\n- 块设备是一个由统一大小的块组成的数组。如果块大小为 $B$ 字节，并且有 $N$ 个块，则该设备存储了 $N \\cdot B$ 字节，索引范围从 $0$ 到 $N \\cdot B - 1$。\n- 顺序数据集是一个由起始块 $S$ 和长度 $L$（以字节为单位）定义的连续字节区间，因此其有效字节偏移量 $p$ 满足 $0 \\le p < L$（相对于数据集的起始位置）。\n- 顺序访问方法（SAM）支持：\n  - open：将顺序光标定位到数据集的开头，即将当前偏移量设为 $0$。\n  - next：返回下一个逻辑记录并前移光标。\n  - rewind：将光标重置到开头（$0$），并使任何依赖于当前位置的缓存失效。\n- 记录在数据集中被编码为可变长度记录，带有一个单字节的长度前缀：一个记录由 $1$ 字节的 $\\ell$（有效载荷长度）后跟 $\\ell$ 个有效载荷字节组成。有效的编码满足所有记录的 $(1 + \\ell)$ 之和等于 $L$。\n\n从字节偏移量到块设备的映射：\n- 给定一个相对于数据集的字节偏移量 $p$（$0 \\le p < L$），对应的设备块索引为\n$$\n\\text{block}(p) = S + \\left\\lfloor \\frac{p}{B} \\right\\rfloor,\n$$\n块内字节偏移量为\n$$\n\\text{off}(p) = p \\bmod B.\n$$\n- SAM 层持有一个单块缓存。要获取偏移量为 $p$ 的任何字节，需计算 $\\text{block}(p)$ 和 $\\text{off}(p)$。如果缓存当前未持有 $\\text{block}(p)$，则执行恰好一次块读取，将该块读入缓存，然后从缓存中返回位于 $\\text{off}(p)$ 的字节。如果缓存已持有 $\\text{block}(p)$，则直接返回缓存的字节，不发出新的块读取。\n- 每次块读取都会使一个块读取操作计数器递增。rewind 操作会使缓存失效，并为下一次遍历将块读取计数器重置为 $0$。\n\n程序要求：\n- 实现具有上述语义的 SAM。next 操作必须：\n  - 在当前相对于数据集的偏移量 $p$ 处，使用映射规则读取长度字节 $\\ell$，然后顺序读取 $\\ell$ 个有效载荷字节，并相应地前移偏移量。\n  - 如果能在超出 $L$ 之前获取一个完整的记录，则返回成功指示符；如果没有更多记录（即 $p \\ge L$），则返回失败指示符。\n- 为使结果纯数字且可复现，将记录的贡献定义为其有效载荷字节值的总和。在一次遍历中，计算总的有效载荷和以及记录总数。同时，计算该次遍历中发生了多少次块读取。\n- 唯一允许的设备原语是完整的块读取到缓存中。除了通过块读取后的缓存，不允许从设备内存直接进行按字节的读取。\n\n测试套件：\n通过将指定的记录写入一个零初始化的设备的数据集区域来构建以下四个测试用例。每个记录定义为 $[\\ell \\mid \\text{有效载荷字节}]$，表示一个单字节长度 $\\ell$ 后跟 $\\ell$ 个有效载荷字节。\n\n- 测试用例 $1$ (一个记录跨越块边界的正常路径)：\n  - 块大小 $B = 8$，块数量 $N = 4$，起始块 $S = 1$。\n  - 记录：$[3 \\mid 1,2,3]$，$[2 \\mid 4,5]$，$[4 \\mid 6,7,8,9]$。\n  - 数据集长度 $L = 12$ 字节。\n- 测试用例 $2$ (边界对齐：记录正好在块边界处结束)：\n  - 块大小 $B = 8$，块数量 $N = 3$，起始块 $S = 0$。\n  - 记录：$[7 \\mid 10,20,30,40,50,60,70]$，$[1 \\mid 255]$。\n  - 数据集长度 $L = 10$ 字节。\n- 测试用例 $3$ (空数据集)：\n  - 块大小 $B = 8$，块数量 $N = 2$，起始块 $S = 0$。\n  - 记录：无。\n  - 数据集长度 $L = 0$ 字节。\n- 测试用例 $4$ (跨越多个块的大记录)：\n  - 块大小 $B = 16$，块数量 $N = 4$，起始块 $S = 2$。\n  - 记录：$[30 \\mid 1,2,3,\\dots,30]$。\n  - 数据集长度 $L = 31$ 字节。\n\n对于每个测试用例，执行：\n- open，\n- 迭代执行 next 直到文件末尾，计算：\n  - 该次遍历的总有效载荷和，\n  - 记录数，\n  - 块读取次数，\n- rewind，\n- 再次迭代执行 next 以计算第二次遍历：\n  - 第二次遍历的总有效载荷和，\n  - 第二次遍历的块读取次数。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含每个测试用例的结果，聚合为一个列表的列表。对于每个测试用例，输出列表 $[\\text{sum\\_first}, \\text{count}, \\text{reads\\_first}, \\text{sum\\_second}, \\text{reads\\_second}]$。\n- 整体输出必须是单行中的一个类JSON格式的列表，格式完全如下：\n  - 示例形式：$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3],[a_4,b_4,c_4,d_4,e_4]]$，\n  - 其中所有的 $a_i$、$b_i$、$c_i$、$d_i$、$e_i$ 均为整数。", "solution": "该问题陈述已经过严格审查，并被确定为有效。它在科学上基于操作系统文件访问方法的原理，定义明确，具有一组完整且一致的定义和约束，并以客观、正式的语言表述。没有发现任何会妨碍推导出唯一的、有意义的解决方案的可识别缺陷。因此，我们可以继续进行求解。\n\n任务是在一个模拟的块设备上实现一个顺序访问方法（SAM）。这需要创建一个抽象层，该层在一个物理上组织为固定大小块的存储介质上提供字节流访问（`open`、`next`、`rewind`）。解决方案的核心在于将逻辑字节偏移量映射到物理块地址，并管理一个单块缓存以最小化块读取操作。\n\n### 数据结构\n\n为了对系统建模，我们定义以下结构：\n\n1.  **块设备（Block Device）**：物理存储介质由一个块数组表示。我们可以用一个结构来模拟它，该结构包含一个指向连续内存区域的指针、块大小 $B$ 以及总块数 $N$。\n    ```c\n    typedef struct {\n        unsigned char* memory;\n        int B; // Block size in bytes\n        int N; // Number of blocks\n    } BlockDevice;\n    ```\n\n2.  **SAM 数据集状态（SAM Dataset State）**：此结构封装了顺序数据集的状态，包括其属性和当前的访问状态。它包含：\n    *   一个对底层 `BlockDevice` 的引用。\n    *   数据集参数：起始块 $S$ 和总长度（以字节为单位）$L$。\n    *   当前逻辑位置或光标 `p`，它是一个相对于数据集起始位置的字节偏移量（$0 \\le p  L$）。\n    *   一个单块缓存及其状态：一个用于存放一块数据的缓冲区和一个用于跟踪当前缓存在缓存中块索引的整数。索引为 $-1$ 可以表示缓存无效或为空。\n    *   一个用于记录已执行的块读取操作次数的计数器。\n    ```c\n    typedef struct {\n        BlockDevice* device;\n        int S; // Start block\n        int L; // Length in bytes\n        int p; // Current dataset-relative byte offset (cursor)\n        unsigned char* cache;\n        int cached_block_index;\n        int block_reads;\n    } SAM_Dataset;\n    ```\n\n### 核心逻辑：映射与缓存\n\n基本操作是根据给定的相对于数据集的偏移量 $p$ 来检索单个字节。这由一个实现了指定映射和缓存逻辑的辅助函数来处理。\n\n**`read_byte(SAM_Dataset* ds, int p)`**：\n给定一个数据集 `ds` 和一个相对于数据集的偏移量 $p$，此函数返回该位置的字节值。\n\n1.  **地址转换**：首先，将逻辑偏移量 $p$ 转换为物理设备地址。根据问题描述，设备块索引和块内偏移量的计算方式如下：\n    $$\n    \\text{block\\_idx}(p) = S + \\left\\lfloor \\frac{p}{B} \\right\\rfloor\n    $$\n    $$\n    \\text{offset\\_in\\_block}(p) = p \\bmod B\n    $$\n    在 C 语言的整数算术中，对于非负的 $p$ 和 $B$，这分别对应于 `ds-S + p / ds-device-B` 和 `p % ds-device-B`。\n\n2.  **缓存管理**：然后，函数检查所需的块 `block_idx` 是否已在缓存中。\n    *   **缓存命中**：如果 `block_idx` 等于 `ds-cached_block_index`，说明该块已被加载。字节直接从缓存中的 `ds-cache[offset_in_block]` 返回。不发生块读取。\n    *   **缓存未命中**：如果 `block_idx` 不是当前缓存的块，则必须执行一次块读取。\n        a. `ds-block_reads` 计数器递增。\n        b. 位于 `block_idx` 的整个块从设备的内存复制到 `ds-cache` 缓冲区。设备上的源地址是 `ds-device-memory + block_idx * ds-device-B`。\n        c. `ds-cached_block_index` 更新为 `block_idx`。\n        d. 然后从现已更新的缓存中的 `ds-cache[offset_in_block]` 返回字节。\n\n### SAM 操作\n\nSAM 接口函数（`open`、`next`、`rewind`）是使用 `read_byte` 辅助函数实现的。\n\n1.  **`sam_open(SAM_Dataset* ds)`**：此操作为遍历数据集做准备。它仅将光标重置到开头。\n    *   设置 `ds-p = 0`。\n    *   初始化 `ds-block_reads = 0`。\n    *   通过设置 `ds-cached_block_index = -1` 使缓存失效。\n\n2.  **`sam_rewind(SAM_Dataset* ds)`**：此操作为后续的遍历重置状态，根据问题描述，这与 `sam_open` 相同。\n    *   设置 `ds-p = 0`。\n    *   重置 `ds-block_reads = 0`。\n    *   通过设置 `ds-cached_block_index = -1` 使缓存失效。\n\n3.  **`sam_next(SAM_Dataset* ds, int* payload_sum)`**：此函数读取下一个可变长度记录。\n    *   **文件结束检查**：首先检查光标 `ds-p` 是否位于或超出了数据集的末尾（`ds-p = ds-L`）。如果是，则表示失败（文件结束）并返回。\n    *   **读取长度前缀**：调用 `read_byte(ds, ds-p)` 获取记录的长度前缀 $\\ell$。然后光标 `ds-p` 递增。\n    *   **读取有效载荷**：进入一个循环，迭代 $\\ell$ 次。在每次迭代中，调用 `read_byte(ds, ds-p)` 获取下一个有效载荷字节，将其值加到当前记录的运行总和中，并递增 `ds-p`。\n    *   **返回值**：函数通过 `payload_sum` 指针参数更新此次遍历的总有效载荷和，并返回一个成功指示符。\n\n### 执行计划\n\n主程序将为四个指定的测试用例中的每一个执行逻辑。\n\n1.  **测试用例设置**：对于每个测试用例，我们为块设备和 SAM 缓存动态分配内存。设备内存被零初始化。\n2.  **数据填充**：将测试用例的记录数据写入模拟的设备内存中。数据从与数据集起始块相对应的设备字节偏移量（即 $S \\cdot B$）开始放置。\n3.  **第一次遍历**：\n    *   调用 `sam_open` 初始化状态。\n    *   循环调用 `sam_next` 直到它发出文件结束信号。\n    *   在循环内部，累加总有效载荷和并递增记录计数。\n    *   循环结束后，记录 `sum_first`、`count` 和 `reads_first` 的最终值。\n4.  **第二次遍历**：\n    *   调用 `sam_rewind` 重置状态。\n    *   重复 `sam_next` 循环以重新读取数据集。\n    *   累加第二次遍历的总有效载荷和。\n    *   循环结束后，记录 `sum_second` 和 `reads_second`。\n5.  **输出生成**：处理完所有测试用例后，将收集到的结果以指定的单行类JSON格式 `[[...],[...],...]` 打印到标准输出。\n6.  **清理**：为每个测试用例释放所有动态分配的内存（设备和缓存），以防止内存泄漏。", "answer": "[[45, 3, 2, 45, 2], [535, 2, 2, 535, 2], [0, 0, 0, 0, 0], [465, 1, 2, 465, 2]]", "id": "3682261"}, {"introduction": "理解了如何实现顺序访问之后，接下来的问题是如何使其高效运行。这个练习探讨了在系统调用的固定开销和数据传输效率之间的基本性能权衡。你将推导出一个最小的块大小，以确保系统调用开销不超过总时间的特定百分比，这是I/O性能调优中的一项核心技能。[@problem_id:3682197]", "problem": "一个程序使用顺序访问方法读取一个大文件，它通过重复调用操作系统的读系统调用（syscall）从存储设备中获取固定大小的数据块。在此模型中，每个大小为 $B$ 字节的数据块通过一次系统调用读取，该调用会产生 $\\alpha$ 纳秒的固定开销，并且数据传输以每秒 $R$ 字节的持续设备速率进行。假设此工作负载具有以下特性：没有缓存或预取效应，数据传输与系统调用开销没有重叠，以及以给定速率 $R$ 形成的稳定顺序流。\n\n设系统调用开销所占总时钟时间比例的目标上限为 $x$，表示为一个介于 $0$ 和 $1$ 之间的小数。仅使用第一性原理（即总时间是各组成部分时间之和，且顺序访问按顺序读取相邻数据塊，每个数据塊对应一次系统调用），确定最小数据块大小 $B^{\\star}$，以保证在整个读取过程中，系统调用开销的比例最多为 $x$。\n\n使用以下参数：$\\alpha = 3{,}500$ 纳秒，$R = 700$ mebibytes每秒 (MiB/s)，以及 $x = 0.03$。将 $1$ mebibyte (MiB) 视为 $1{,}048{,}576$ 字节，将 $1$ kibibyte (KiB) 视为 $1{,}024$ 字节。以KiB为单位表示你最终的数据块大小。将答案四舍五入到四位有效数字。", "solution": "问题要求计算最小数据块大小，记为 $B^{\\star}$，以确保系统调用（syscall）开销所占总时间的比例不超过指定值 $x$。分析从第一性原理开始，即考虑读取单个数据块所需的时间。\n\n根据问题描述，读取一个大小为 $B$ 字节的数据块所需的总时钟时间 $T_{\\text{total}}$ 是固定的系统调用开销时间 $T_{\\text{overhead}}$ 和可变的数据传输时间 $T_{\\text{transfer}}$ 之和。模型假设这两个阶段不重叠。\n$$T_{\\text{total}} = T_{\\text{overhead}} + T_{\\text{transfer}}$$\n系统调用开销是每次调用的固定时间，给定为 $\\alpha$。\n$$T_{\\text{overhead}} = \\alpha$$\n对于一个大小为 $B$ 字节的数据块，以每秒 $R$ 字节的持续速率进行传输所需的数据传输时间由大小与速率之比给出。\n$$T_{\\text{transfer}} = \\frac{B}{R}$$\n将这些代入总时间的方程，得到：\n$$T_{\\text{total}} = \\alpha + \\frac{B}{R}$$\n系统调用开销所占总时间的比例，我们可以称之为 $f_{\\text{overhead}}$，是开销时间与总时间之比。\n$$f_{\\text{overhead}} = \\frac{T_{\\text{overhead}}}{T_{\\text{total}}} = \\frac{\\alpha}{\\alpha + \\frac{B}{R}}$$\n问题指定了一个目标上限，要求这个比例最多为 $x$。\n$$f_{\\text{overhead}} \\le x$$\n代入 $f_{\\text{overhead}}$ 的表达式，得出以下不等式：\n$$\\frac{\\alpha}{\\alpha + \\frac{B}{R}} \\le x$$\n为了找到满足此条件的最小数据块大小 $B^{\\star}$，我们首先观察到 $f_{\\text{overhead}}$ 是 $B$ 的一个单调递减函数，因为增加 $B$ 会增大该分数的分母。因此，最小大小 $B^{\\star}$ 是使等式成立的大小。对于任何 $B > B^{\\star}$，该不等式将严格成立。我们通过将该比例设为等于 $x$ 来求解 $B^{\\star}$。\n$$\\frac{\\alpha}{\\alpha + \\frac{B^{\\star}}{R}} = x$$\n我们现在求解这个关于 $B^{\\star}$ 的方程。\n$$\\alpha = x \\left(\\alpha + \\frac{B^{\\star}}{R}\\right)$$\n$$\\alpha = x\\alpha + x\\frac{B^{\\star}}{R}$$\n$$\\alpha - x\\alpha = x\\frac{B^{\\star}}{R}$$\n$$\\alpha(1 - x) = x\\frac{B^{\\star}}{R}$$\n分离出 $B^{\\star}$ 得到解析解：\n$$B^{\\star} = \\frac{\\alpha R (1-x)}{x}$$\n现在，我们代入给定的参数值，确保所有单位一致。时间标准单位将是秒（s），大小标准单位将是字节。\n给定的参数为：\n$\\alpha = 3{,}500 \\text{ ns} = 3{,}500 \\times 10^{-9} \\text{ s}$\n$R = 700 \\text{ MiB/s} = 700 \\times 1{,}048{,}576 \\text{ bytes/s} = 733{,}993{,}200 \\text{ bytes/s}$\n$x = 0.03$\n此外，$1-x = 1 - 0.03 = 0.97$。\n\n将这些值代入 $B^{\\star}$ 的表达式中：\n$$B^{\\star} = \\frac{(3{,}500 \\times 10^{-9} \\text{ s}) \\times (733{,}993{,}200 \\text{ bytes/s}) \\times 0.97}{0.03}$$\n首先，我们计算分子：\n$$ \\text{Numerator} = (3{,}500 \\times 10^{-9}) \\times 733{,}993{,}200 \\times 0.97 \\text{ bytes}$$\n$$ \\text{Numerator} = 2.5689762 \\times 0.97 \\text{ bytes} \\approx 2.491906914 \\text{ bytes}$$\n现在，我们除以分母 $x = 0.03$：\n$$B^{\\star} = \\frac{2.491906914}{0.03} \\text{ bytes} \\approx 83{,}063.5638 \\text{ bytes}$$\n问题要求最终答案以kibibytes (KiB)为单位，并四舍五入到四位有效数字。我们使用转换因子 $1 \\text{ KiB} = 1{,}024 \\text{ bytes}$。\n$$B^{\\star} \\text{ [in KiB]} = \\frac{83{,}063.5638 \\text{ bytes}}{1{,}024 \\text{ bytes/KiB}} \\approx 81.1167615 \\text{ KiB}$$\n将此值四舍五入到四位有效数字，我们看第五位有效数字。这个数是 $81.116...$。第五位数字是 $6$，即大于或等于 $5$，所以我们对第四位有效数字进行向上舍入。\n$$B^{\\star} \\approx 81.12 \\text{ KiB}$$", "answer": "$$\\boxed{81.12}$$", "id": "3682197"}, {"introduction": "现代操作系统采用预读（readahead）等自动优化来加速顺序文件访问。然而，没有一种优化是万能的。这个练习将给出一个CPU密集型的应用场景，要求你分析预读机制的成本与收益，从而对这种延迟隐藏技术何时能提升吞吐量，以及何时其内存消耗可能成为负担进行批判性评估。[@problem_id:3682254]", "problem": "一个单线程应用程序通过读取一个大文件来进行顺序访问，它以固定大小的块读取文件，并在处理下一个块之前对每个块执行大量计算。操作系统（OS）通过实现预读来利用顺序性：当它观察到顺序访问时，它会异步地将接下来的块预取到页面缓存中。该机器有一个容量为 $M_{p}$ 的页面缓存，其他进程当前占用了其中的 $M_{o}$，剩余 $M_{f} = M_{p} - M_{o}$ 可用。该应用程序通过页面缓存使用缓冲输入/输出（I/O）。\n\n假设有以下参数：\n- 块大小 $b = 4\\,\\mathrm{MiB}$，预读窗口 $w = 64$ 个块，因此最大预取足迹为 $w \\cdot b$。\n- 持续存储带宽 $v = 200\\,\\mathrm{MiB/s}$，平均访问延迟 $t_{\\ell} = 5\\,\\mathrm{ms}$。\n- 中央处理器（CPU）上每块的计算时间 $t_{c} = 1.0\\,\\mathrm{s}$。\n- 页面缓存容量 $M_{p} = 4\\,\\mathrm{GiB}$，其他进程占用 $M_{o} = 3.75\\,\\mathrm{GiB}$，因此可用容量 $M_{f} = 0.25\\,\\mathrm{GiB}$。\n\n该应用程序读取一个远大于页面缓存容量的非常大的文件，并且除了指定的之外没有其他内存消耗者。基于顺序访问方法、页面缓存以及异步预取与计算交互的基本原理，哪个选项最能描述禁用预读对该工作负载的吞吐量和内存压力的影响？\n\nA. 禁用预读将通过回收大约 $w \\cdot b$ 的页面缓存来显著缓解内存压力，代价是每个处理的块增加大约一个块的读取时间 $t_{r}$（其中 $t_{r} = t_{\\ell} + \\frac{b}{v}$），在这种情况下，由于 $t_{c} \\gg t_{r}$，这是一个很小的分数惩罚。\n\nB. 禁用预读会增加内存压力，因为操作系统会在没有预取的情况下保留更多最近使用的页面，导致页面缓存足迹增长超过 $w \\cdot b$。\n\nC. 禁用预读不会改变吞吐量，因为 $t_{c} \\gg t_{r}$，并且它不会影响内存使用，因为预取的数据驻留在存储上而不是占用页面缓存。\n\nD. 保持预读启用是必要的，以避免大约 $100\\%$ 的吞吐量损失，并且其内存影响可以忽略不计，因为无论 $t_{c}$ 如何，每个预取的块都会被 CPU 立即消耗。", "solution": "在进行解答之前，首先验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n问题为执行顺序 I/O 的单线程应用程序提供了以下参数：\n- 块大小：$b = 4\\,\\mathrm{MiB}$\n- 预读窗口：$w = 64$ 个块\n- 最大预取足迹：$w \\cdot b$\n- 持续存储带宽：$v = 200\\,\\mathrm{MiB/s}$\n- 平均访问延迟：$t_{\\ell} = 5\\,\\mathrm{ms}$\n- 每块的计算时间：$t_{c} = 1.0\\,\\mathrm{s}$\n- 总页面缓存容量：$M_{p} = 4\\,\\mathrm{GiB}$\n- 其他进程使用的页面缓存：$M_{o} = 3.75\\,\\mathrm{GiB}$\n- 可用页面缓存容量：$M_{f} = M_{p} - M_{o} = 0.25\\,\\mathrm{GiB}$\n- 应用程序读取一个远大于页面缓存的文件。\n- I/O 通过页面缓存进行缓冲。\n- 操作系统实现异步预读。\n\n问题询问禁用预读对吞吐量和内存压力的影响。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于操作系统的原理，特别是文件系统缓存、I/O 调度和性能分析。术语是标准的，该场景是 CPU 密集型与 I/O 密集型工作负载的经典案例研究。\n\n我们来验证数值数据的一致性。\n- GiB 到 MiB 的转换使用二进制前缀标准（$1\\,\\mathrm{GiB} = 1024\\,\\mathrm{MiB}$）。\n- 总缓存容量：$M_{p} = 4\\,\\mathrm{GiB} = 4 \\times 1024\\,\\mathrm{MiB} = 4096\\,\\mathrm{MiB}$。\n- 已占用缓存容量：$M_{o} = 3.75\\,\\mathrm{GiB} = 3.75 \\times 1024\\,\\mathrm{MiB} = 3840\\,\\mathrm{MiB}$。\n- 可用缓存容量：$M_{f} = M_{p} - M_{o} = 4096\\,\\mathrm{MiB} - 3840\\,\\mathrm{MiB} = 256\\,\\mathrm{MiB}$。\n- 给定的可用内存值为 $M_{f} = 0.25\\,\\mathrm{GiB} = 0.25 \\times 1024\\,\\mathrm{MiB} = 256\\,\\mathrm{MiB}$。数值是一致的。\n\n现在让我们计算最大预取足迹：\n- $w \\cdot b = 64 \\,\\text{blocks} \\times 4\\,\\mathrm{MiB/block} = 256\\,\\mathrm{MiB}$。\n- 这表明预读窗口在满时将消耗全部可用的页面缓存：$w \\cdot b = M_{f}$。\n\n这些参数在物理上是现实的，问题是自包含的、良构的，并且没有矛盾或歧义。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。现在可以对两种情况（启用预读 vs. 禁用预读）进行定量分析。\n\n### 基于原理的推导\n我们从处理单个块所需的时间来分析两种情况下系统的性能。总时间将决定吞吐量，而页面缓存的使用情况将决定内存压力。\n\n首先，我们计算当块不在缓存中时从存储读取一个块所需的时间。这个时间 $t_{r}$ 是访问延迟和传输时间之和。\n$$t_{r} = t_{\\ell} + \\frac{b}{v}$$\n已知 $t_{\\ell} = 5\\,\\mathrm{ms} = 0.005\\,\\mathrm{s}$，$b = 4\\,\\mathrm{MiB}$，以及 $v = 200\\,\\mathrm{MiB/s}$：\n$$t_{r} = 0.005\\,\\mathrm{s} + \\frac{4\\,\\mathrm{MiB}}{200\\,\\mathrm{MiB/s}} = 0.005\\,\\mathrm{s} + 0.02\\,\\mathrm{s} = 0.025\\,\\mathrm{s}$$\n每块的计算时间给定为 $t_{c} = 1.0\\,\\mathrm{s}$。\n一个关键的观察是 $t_{c} \\gg t_{r}$ ($1.0\\,\\mathrm{s} \\gg 0.025\\,\\mathrm{s}$)。这表明该进程是严重受 CPU 限制的（CPU 密集型）。\n\n**情况 1：启用预读**\n在这种情况下，当 CPU 忙于计算当前块时，操作系统会异步预取后续的块。应用程序要处理块 $i$，必须首先获得该块的数据，然后对其进行计算。处理块 $i$ 的时间线（在启动阶段之后）如下：\n1. CPU 计算块 $i-1$（耗时 $t_c = 1.0\\,\\mathrm{s}$）。\n2. 在此期间，操作系统为块 $i$ 发出异步读取请求。由于读取时间为 $t_{r} = 0.025\\,\\mathrm{s}$，并且 $t_c > t_r$，对块 $i$ 的读取远在对块 $i-1$ 的计算完成之前就已结束。\n3. 当应用程序完成块 $i-1$ 并请求读取块 $i$ 时，该块已在页面缓存中。访问时间可忽略不计。\n4. 然后应用程序对块 $i$ 进行计算（耗时 $t_c = 1.0\\,\\mathrm{s}$）。\n每个块的处理被有效地流水线化。限速步骤是计算。每个块的总时间 $T_{on}$ 主要由计算时间决定。\n$$T_{on} \\approx t_{c} = 1.0\\,\\mathrm{s/block}$$\n吞吐量大约为 $b/T_{on} = 4\\,\\mathrm{MiB} / 1.0\\,\\mathrm{s} = 4\\,\\mathrm{MiB/s}$。\n\n在内存压力方面，预读机制试图填满其 $w=64$ 个块的窗口。这在页面缓存中创建了一个 $w \\cdot b = 256\\,\\mathrm{MiB}$ 的内存足迹。由于这等于总的可用空闲内存 $M_{f}$，预读机制对内存子系统施加了巨大压力，消耗了所有空闲的缓存页面。\n\n**情况 2：禁用预读**\n没有预读，从应用程序的角度来看，I/O 操作变成同步的。流水线被破坏了。\n1. 应用程序请求读取块 $i$。该块不在缓存中。\n2. 应用程序线程阻塞，等待 I/O 完成。这耗时 $t_{r} = 0.025\\,\\mathrm{s}$。\n3. 一旦数据可用，应用程序就对块 $i$ 进行计算。这耗时 $t_c = 1.0\\,\\mathrm{s}$。\n读取和计算操作是串行化的。每个块的总时间 $T_{off}$ 是读取时间和计算时间之和。\n$$T_{off} = t_r + t_c = 0.025\\,\\mathrm{s} + 1.0\\,\\mathrm{s} = 1.025\\,\\mathrm{s/block}$$\n吞吐量为 $b/T_{off} = 4\\,\\mathrm{MiB} / 1.025\\,\\mathrm{s} \\approx 3.90\\,\\mathrm{MiB/s}$。\n\n吞吐量损失率是 $\\frac{T_{on} - T_{off}}{T_{on}}$，或者处理时间的相对增加是 $\\frac{T_{off} - T_{on}}{T_{on}} = \\frac{t_r}{t_c} = \\frac{0.025}{1.0} = 2.5\\%$。这是一个很小的惩罚。\n\n在内存压力方面，只有当前正在读取或处理的块需要驻留在缓存中。应用程序在页面缓存中的足迹是最小的，大约为 $1$ 或 $2$ 个块（$4-8\\,\\mathrm{MiB}$）。与用于预取的 $256\\,\\mathrm{MiB}$ 相比，这是一个巨大的减少。因此，禁用预读显著缓解了内存压力。\n\n**禁用预读的影响总结：**\n- **吞吐量：** 减少少量（$2.5\\%$）。每个块的时间增加了 $t_r$。\n- **内存压力：** 显著降低，因为应用程序的页面缓存足迹从 $w \\cdot b = 256\\,\\mathrm{MiB}$ 下降到大约 $b = 4\\,\\mathrm{MiB}$。\n\n### 逐项分析选项\n\n**A. 禁用预读将通过回收大约 $w \\cdot b$ 的页面缓存来显著缓解内存压力，代价是每个处理的块增加大约一个块的读取时间 $t_{r}$（其中 $t_{r} = t_{\\ell} + \\frac{b}{v}$），在这种情况下，由于 $t_{c} \\gg t_{r}$，这是一个很小的分数惩罚。**\n- **内存压力：** 分析证实，禁用预读回收了 $w \\cdot b = 256\\,\\mathrm{MiB}$ 的预取窗口，这显著缓解了内存压力。此陈述正确。\n- **吞吐量成本：** 分析表明，每个块的时间从 $t_c$ 增加到 $t_c + t_r$，正好在串行执行路径上增加了一个块的读取时间 $t_r$。为 $t_r$ 提供的公式也是正确的。此陈述正确。\n- **惩罚幅度：** 每个块总时间的惩罚是 $t_r / t_c = 2.5\\%$。由于 $t_c \\gg t_r$，这被正确地描述为一个很小的分数惩罚。此陈述正确。\n- **总体结论：** **正确**。该选项准确描述了这种权衡。\n\n**B. 禁用预读会增加内存压力，因为操作系统会在没有预取的情况下保留更多最近使用的页面，导致页面缓存足迹增长超过 $w \\cdot b$。**\n- 这一说法是反直觉且不正确的。禁用预取意味着操作系统推测性地获取*更少*的块。对于大型顺序扫描，标准的页面替换算法（如 LRU）会迅速逐出旧块。内存足迹会缩小到几个块，而不是增长。足迹绝对不会增长超过 $w \\cdot b$。\n- **总体结论：** **错误**。\n\n**C. 禁用预读不会改变吞吐量，因为 $t_{c} \\gg t_{r}$，并且它不会影响内存使用，因为预取的数据驻留在存储上而不是占用页面缓存。**\n- **吞吐量：** 它声称吞吐量“不会改变”。虽然变化很小（$2.5\\%$），但它不是零。$t_c \\gg t_r$ 这个原因解释了为什么变化很小，而不是为什么不存在变化。这是一个不精确因此不正确的陈述。\n- **内存使用：** “预取的数据驻留在存储上而不是占用页面缓存”的说法是根本上错误的。预取的目的就是提前将数据从存储加载*到*页面缓存（RAM）中。\n- **总体结论：** **错误**。\n\n**D. 保持预读启用是必要的，以避免大约 $100\\%$ 的吞吐量损失，并且其内存影响可以忽略不计，因为每个预取的块都会被 CPU 立即消耗，无论 $t_{c}$ 如何。**\n- **吞吐量：** $100\\%$ 的吞吐量损失意味着吞吐量降至接近零，这是错误的。实际损失仅为 $2.5\\%$。只有在工作负载是 I/O 密集型（$t_r \\gg t_c$）时，才会出现大的吞吐量损失。\n- **内存影响：** 内存影响是 $w \\cdot b = 256\\,\\mathrm{MiB}$，这消耗了所有可用的空闲缓存，因此不能忽略。声称块被“立即消耗”是错误的；一个在 $0.025\\,\\mathrm{s}$ 内读完的块必须在缓存中等待，而 CPU 在前一个块上花费 $1.0\\,\\mathrm{s}$。\n- **总体结论：** **错误**。", "answer": "$$\\boxed{A}$$", "id": "3682254"}]}