{"hands_on_practices": [{"introduction": "我们从一个基础练习开始，旨在巩固对优先编码器核心功能的理解。在 [@problem_id:1954014] 中，您需要为一个给定的输入计算一个标准4-2优先编码器的输出。这个练习将帮助您掌握其关键原则：在多个同时有效的输入信号中，准确识别并编码优先级最高的信号。", "problem": "4-2优先编码器是一种组合逻辑电路，它接受四个输入并产生一个两位的二进制输出。该编码器旨在从其四个数据输入（记为 $I_3$、$I_2$、$I_1$ 和 $I_0$）中识别出最高优先级的有效输入。对于此特定设备，输入 $I_3$ 具有最高优先级，其次是 $I_2$，然后是 $I_1$，最后是优先级最低的 $I_0$。\n\n编码器有两个二进制输出 $Y_1$ 和 $Y_0$，它们代表最高优先级有效输入的二进制索引（其中“有效”表示输入为逻辑“1”）。例如，如果 $I_2$ 是最高优先级的有效输入，则输出 $Y_1Y_0$ 将是 2 的二进制表示，即“10”。除了编码输出外，还有一个“有效”位 $V$。如果一个或多个输入有效，$V$ 位置为“1”；仅当所有输入都无效（逻辑“0”）时，$V$ 位才为“0”。\n\n给定输入数据向量 $I_3I_2I_1I_0 = 1011$，确定输出 $V、Y_1$ 和 $Y_0$ 的结果状态。从以下选项中选择正确的选项。\n\nA. $V=1, Y_1=0, Y_0=1$\n\nB. $V=1, Y_1=1, Y_0=0$\n\nC. $V=1, Y_1=1, Y_0=1$\n\nD. $V=0, Y_1=1, Y_0=1$\n\nE. $V=1, Y_1=0, Y_0=0$", "solution": "4-2优先编码器选择优先级最高的置位输入，并在 $(Y_{1},Y_{0})$ 上以二进制形式输出其索引，$V$ 表示是否有任何输入被置位。使用标准布尔代数（其中 $+$ 为“或”运算，并置或 $\\cdot$ 为“与”运算，上划线为“非”运算），优先级为 $I_{3} \\succ I_{2} \\succ I_{1} \\succ I_{0}$ 的4-2优先编码器的规范表达式为：\n$$V = I_{3} + I_{2} + I_{1} + I_{0},$$\n$$Y_{1} = I_{3} + I_{2},$$\n$$Y_{0} = I_{3} + \\overline{I_{2}}\\,I_{1}.$$\n理由：\n- 如果任何输入有效，$V$ 即为 $1$，因此是所有输入的“或”运算。\n- 当且仅当选定的索引为 $2$ 或 $3$ 时，$Y_{1}$ 才为 $1$。这种情况在 $I_{3}=1$ 时发生，或者在（$I_{3}=0$ 且）$I_{2}=1$ 时发生，从而得出 $I_{3} + I_{2}$。\n- 当选定的索引为奇数（$1$ 或 $3$）时，$Y_{0}$ 为 $1$。索引 $3$ 在 $I_{3}=1$ 时发生，而索引 $1$ 仅在 $I_{3}=0$、$I_{2}=0$ 且 $I_{1}=1$ 时发生，从而得到 $I_{3} + \\overline{I_{2}}\\,I_{1}$。\n\n给定 $I_{3}I_{2}I_{1}I_{0} = 1011$，我们有 $I_{3}=1$, $I_{2}=0$, $I_{1}=1$, $I_{0}=1$。代入：\n$$V = 1 + 0 + 1 + 1 = 1,$$\n$$Y_{1} = 1 + 0 = 1,$$\n$$Y_{0} = 1 + \\overline{0}\\cdot 1 = 1 + 1\\cdot 1 = 1.$$\n因此输出为 $V=1$, $Y_{1}=1$, $Y_{0}=1$，这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1954014"}, {"introduction": "掌握了基础知识后，我们来挑战一个设计问题。练习 [@problem_id:1954013] 要求您利用8-3优先编码器的输出，来判断最高优先级输入的索引是奇数还是偶数。此题展示了编码器的输出不仅是一个标签，更是可以被二次处理以提取特定信息的结构化数据，这在复杂的系统中非常有用。", "problem": "一个8-3优先编码器具有八个高电平有效输入，表示为 $I_7, I_6, \\dots, I_0$，并产生一个3位二进制输出码，表示为 $Y_2Y_1Y_0$。该编码器的工作方式是，其输出代表当前有效的（处于逻辑“1”状态）输入中具有最高索引的输入的二进制索引。例如，如果输入 $I_5$、$I_2$ 和 $I_1$ 均有效，则编码器的输出将为 $Y_2Y_1Y_0 = 101$，因为在所有有效输入中，$I_5$ 的索引最高。本问题只考虑至少有一个输入有效的情况。\n\n来自优先编码器的这个3位输出被送入一个次级组合逻辑电路。这个次级电路被设计用来产生一个单比特输出 $F$。该电路的功能是，当且仅当优先编码器的最高索引有效输入是具有奇数索引的输入（即 $I_1, I_3, I_5,$ 或 $I_7$）时，将其输出 $F$ 置为 '1'。否则，输出 $F$ 为 '0'。\n\n确定输出 $F$ 作为编码器输出 $Y_2, Y_1,$ 和 $Y_0$ 的函数的最小化积之和（SOP）布尔表达式。", "solution": "8-3优先编码器输出最高索引有效输入的二进制索引 $k \\in \\{0,1,\\dots,7\\}$。次级电路必须在且仅在 $k$ 为奇数时输出 $F=1$，即 $k \\in \\{1,3,5,7\\}$。由于编码器的输出 $(Y_{2},Y_{1},Y_{0})$ 以标准二进制形式表示 $k$，所以当 $F=1$ 时的最小项恰好是 $(Y_{2},Y_{1},Y_{0})$ 等于 $001、011、101、111$ 的情况。\n\n根据这些最小项写出规范的积之和形式：\n$$\nF = \\overline{Y_{2}}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; \\overline{Y_{2}}\\,Y_{1}\\,Y_{0} \\;+\\; Y_{2}\\,\\overline{Y_{1}}\\,Y_{0} \\;+\\; Y_{2}\\,Y_{1}\\,Y_{0}.\n$$\n提出因子 $Y_{0}$：\n$$\nF = Y_{0}\\left(\\overline{Y_{2}}\\,\\overline{Y_{1}} \\;+\\; \\overline{Y_{2}}\\,Y_{1} \\;+\\; Y_{2}\\,\\overline{Y_{1}} \\;+\\; Y_{2}\\,Y_{1}\\right).\n$$\n使用 $\\overline{A}+A=1$ 和分配律进行分组和化简：\n$$\n\\overline{Y_{2}}\\,\\overline{Y_{1}} + \\overline{Y_{2}}\\,Y_{1} = \\overline{Y_{2}}(\\overline{Y_{1}}+Y_{1}) = \\overline{Y_{2}},\n$$\n$$\nY_{2}\\,\\overline{Y_{1}} + Y_{2}\\,Y_{1} = Y_{2}(\\overline{Y_{1}}+Y_{1}) = Y_{2},\n$$\n所以\n$$\nF = Y_{0}\\left(\\overline{Y_{2}} + Y_{2}\\right) = Y_{0}\\cdot 1 = Y_{0}.\n$$\n因此，最小化的SOP表达式就是编码器输出的最低有效位。", "answer": "$$\\boxed{Y_{0}}$$", "id": "1954013"}, {"introduction": "最后，我们将理论与现代数字设计的实践相结合。练习 [@problem_id:1943463] 引导您使用硬件描述语言 (HDL) Verilog 来实现一个4-2优先编码器。此任务旨在展示HDL中的条件结构如何自然地映射优先级逻辑，从而将抽象电路概念高效地转化为可综合的硬件代码。", "problem": "在数字逻辑设计中，优先编码器是一种组合电路，它将多个二进制输入转换为较少数量的输出。其输出表示处于有效状态的最高优先级输入的二进制编码索引。\n\n考虑一个要在硬件描述语言（HDL）如Verilog中实现的4-2优先编码器模块。该模块具有以下接口：\n- 一个4位输入向量 `d`，其中 `d[3]` 具有最高优先级，`d[0]` 具有最低优先级。\n- 一个2位输出向量 `y`，它应表示最高优先级置位（逻辑'1'）输入的二进制索引。\n- 一个1位输出 `v`（代表“有效”），如果 `d` 中有任何输入置位，则应为'1'，否则为'0'。\n\n如果没有输入置位（即 `d` 为 `4'b0000`），则 `v` 输出必须为'0'，并且 `y` 的输出值可以被视为“无关项”（通常设置为'0'）。\n\n您的任务是识别出使用嵌套条件（三元）运算符（`? :`）的单个连续赋值语句，该语句通过将适当的值赋给拼接向量 `{v, y}` 来正确实现此4-2优先编码器的逻辑。\n\n以下哪个Verilog语句正确地建模了指定的优先编码器？\n\nA. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\nB. `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`\n\nC. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`\n\nD. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`\n\nE. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`", "solution": "用户被要求使用单个带有嵌套条件运算符的 `assign` 语句，找出4-2优先编码器的正确Verilog实现。赋值的输出是3位拼接向量 `{v, y}`。\n\n首先，让我们根据问题描述建立优先编码器的真值表。输入是 `d[3:0]`，输出是 `v` 和 `y[1:0]`。优先级顺序为 `d[3] > d[2] > d[1] > d[0]`。我们还确定拼接向量 `{v, y}` 所需的3位值。真值表中的 'x' 代表“无关”条件。\n\n| `d[3]` | `d[2]` | `d[1]` | `d[0]` |  `v`  | `y[1:0]` | `{v, y}` (3位值) |\n|:------:|:------:|:------:|:------:|:-----:|:--------:|:----------------------:|\n|   1    |   x    |   x    |   x    |   1   |  `2'b11` |        `3'b111`        |\n|   0    |   1    |   x    |   x    |   1   |  `2'b10` |        `3'b110`        |\n|   0    |   0    |   1    |   x    |   1   |  `2'b01` |        `3'b101`        |\n|   0    |   0    |   0    |   1    |   1   |  `2'b00` |        `3'b100`        |\n|   0    |   0    |   0    |   0    |   0   |  `2'b00` |        `3'b000`        |\n*（注意：在没有输入置位的情况下，`y` 是一个无关项，通常设置为 `2'b00`）*\n\nVerilog中的嵌套条件（三元）运算符 `condition ? value_if_true : value_if_false` 创建了一个等效于 `if-else if-else` 链的优先级结构。该语句将按照它们出现的顺序检查条件。\n\n让我们根据真值表和优先级规则构建正确的语句：\n\n1.  **检查最高优先级的输入 `d[3]`：** 如果 `d[3]` 为'1'，输出 `{v, y}` 必须是 `3'b111`。\n    语句以以下形式开始：`d[3] ? 3'b111 : ...`\n\n2.  **检查次高优先级的输入 `d[2]`：** 如果 `d[3]` 为'0'，我们检查 `d[2]`。如果 `d[2]` 为'1'，输出 `{v, y}` 必须是 `3'b110`。\n    这就形成了第一个嵌套：`d[3] ? 3'b111 : (d[2] ? 3'b110 : ...)`\n\n3.  **检查 `d[1]`：** 如果 `d[3]` 和 `d[2]` 都为'0'，我们检查 `d[1]`。如果 `d[1]` 为'1'，输出 `{v, y}` 必须是 `3'b101`。\n    嵌套继续：`... : (d[2] ? 3'b110 : (d[1] ? 3'b101 : ...))`\n\n4.  **检查最低优先级的输入 `d[0]`：** 如果 `d[3]`、`d[2]` 和 `d[1]` 都为'0'，我们检查 `d[0]`。如果 `d[0]` 为'1'，输出 `{v, y}` 必须是 `3'b100`。\n    嵌套变为：`... : (d[1] ? 3'b101 : (d[0] ? 3'b100 : ...))`\n\n5.  **默认情况：** 如果所有输入都为'0'，则所有条件都不满足。这是最后的 `else` 情况。输出 `{v, y}` 必须是 `3'b000`。\n    完整的语句是：`assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\n现在，我们评估给定的选项：\n\n*   **A: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`**\n    该语句与我们推导出的逻辑完全匹配。它正确地实现了从 `d[3]` 到 `d[0]` 的优先级，并为每种情况（包括默认情况）生成了正确的 `{v, y}` 值。这是正确答案。\n\n*   **B: `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`**\n    该语句颠倒了优先级顺序，首先检查 `d[0]`。它实现了一个 `d[0]` 具有最高优先级的优先编码器，这与问题规范相矛盾。\n\n*   **C: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`**\n    该语句在 `d[1]` 的情况下输出有误。当 `d[1]` 置位（且 `d[3]`、`d[2]` 未置位）时，它输出 `3'b110`，这对应于 `{v=1, y=2'b10}`。正确的输出应为 `{v=1, y=2'b01}` 或 `3'b101`。\n\n*   **D: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`**\n    该语句在最后的 `else`（默认）情况下有误。如果没有输入置位（`d == 4'b0000`），它会将 `3'b100` 赋给 `{v, y}`。这意味着 `v` 变为'1'，这是不正确的，因为当没有输入有效时，有效位应为'0'。\n\n*   **E: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`**\n    该语句似乎是为赋值给 `{y, v}` 而不是 `{v, y}` 构建的。让我们分析 `d[2]` 的情况：`{v, y}` 的正确输出是 `3'b110`。该语句提供 `3'b101`，这意味着 `v=1, y=2'b01`。这对应于索引1，而不是2。然而，如果目标是 `{y, v}`，值将是 `{2'b10, 1'b1}`，即 `3'b101`。此选项表明对问题中指定的拼接顺序存在误解。\n\n因此，选项A是唯一正确建模指定4-2优先编码器逻辑的选项。", "answer": "$$\\boxed{A}$$", "id": "1943463"}]}