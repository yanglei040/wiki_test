{"hands_on_practices": [{"introduction": "有限状态机 (FSM) 是序贯电路设计的核心。本练习通过设计一个序列检测器，直接对比了两种经典的 FSM 实现——Mealy 机和 Moore 机，揭示了它们在输出产生方式和时序特性上的根本差异。通过这个实践，您将深刻理解 Mealy 机的输出如何依赖于当前状态和输入（从而能更快响应），而 Moore 机的输出仅依赖于当前状态（提供与时钟周期同步的、更稳定的输出）[@problem_id:3628036]。", "problem": "一个同步串行模式检测器处理一个单比特输入流，以检测二进制字 `1011`。该检测器以周期 $T$ 的时钟进行同步，并在上升沿采样输入。令 $k \\in \\mathbb{Z}$ 为上升沿的索引。将周期 $k$ 定义为上升沿 $k$ 和 $k+1$ 之间的开区间。假设输入是同步的：在周期 $k$ 期间施加的比特表示为 $x[k] \\in \\{0,1\\}$，并且在整个周期 $k$ 内保持稳定，直到下一个上升沿。\n\n考虑两种实现方式：\n\n- Mealy 型有限状态机 (FSM)：其在周期 $k$ 的输出 $z[k]$ 是当前状态 $S[k]$ 和当前输入 $x[k]$ 的函数。\n- Moore 型有限状态机 (FSM)：其在周期 $k$ 的输出 $y[k]$ 仅是当前状态 $S[k]$ 的函数。\n\n在两种设计中，下一状态由组合逻辑根据周期 $k$ 内的当前状态和当前输入计算得出，然后在上升沿 $k+1$ 被寄存：$S[k+1] = f(S[k], x[k])$。序列检测器允许重叠（例如，在 `10111` 中有两次检测）。考虑三种输出变体：\n- 未寄存的 Mealy 型输出 $z[k]$。\n- 一个寄存的 Mealy 型输出 $z_{r}[k]$。它通过一个 D 型触发器 (DFF) 在边沿 $k$ 捕获 $z[k-1]$ 的值，因此在周期 $k$ 内，$z_{r}[k]$ 的值等于 $z[k-1]$。\n- Moore 型输出 $y[k]$ (作为寄存状态的函数)。\n\n假设输入呈现子序列 $x[n-3]=1$, $x[n-2]=0$, $x[n-1]=1$, $x[n]=1$，且 $x[n-4]=0$，因此在周期 $n-3$ 到 $n$ 期间的四个比特恰好是目标字 `1011`，并且没有更早的匹配跨越这些周期。相对于 $T$ 忽略传播延迟，除非延迟决定了变化是在一个周期内发生还是在后续周期发生，并假设在此分析中所有逻辑都是无冒险的。\n\n关于检测器输出相对于最后一个比特 $x[n]=1$ 首次置位（转换为 $1$）的时间，以下哪个时序陈述是正确的？\n\nA. 未寄存的 Mealy 型输出 $z[k]$ 可以在周期 $n$ 期间首次置位，而 Moore 型输出 $y[k]$ 在周期 $n+1$ 首次置位。如果 $z[k]$ 被寄存以形成 $z_{r}[k]$，则 $z_{r}[k]$ 在周期 $n+1$ 首次置位。\n\nB. 一个在上升沿采样的同步下游寄存器可以在边沿 $n$ 就观察到未寄存的 Mealy 型输出已置位，而 Moore 型输出则需要等到边沿 $n+1$。\n\nC. 未寄存的 Mealy 型和 Moore 型输出都可以在周期 $n$ 期间首次置位，因为它们都依赖于周期 $n$ 开始时上升沿之后立即可用的信号。\n\nD. 寄存 Mealy 型输出总是相对于最后一个输入比特增加两个完整周期的延迟，因此 $z_{r}[k]$ 在周期 $n+2$ 首次置位。", "solution": "问题陈述是同步数字逻辑设计领域中一个定义明确的问题，具体涉及 Mealy 型和 Moore 型有限状态机 (FSM) 的时序特性。所提供的关于状态机、时钟、输入/输出行为的定义是标准的，并与已建立的理论一致。该问题具有科学依据，提法恰当且客观。它包含了推导出唯一且可验证解所需的所有信息。因此，该问题是有效的。\n\n我们将分析三种指定检测器实现的输出置位时序：未寄存的 Mealy FSM、Moore FSM 和寄存的 Mealy FSM。目标是检测序列 `1011`。此序列首次出现的最后一个比特是 $x[n]=1$，它出现在周期 $n$ 期间。\n\n首先，让我们确定状态转换行为。FSM 在周期 $k$ 开始时的状态表示为 $S[k]$。该状态是由周期 $k$ 开始时的上升沿触发的时钟寄存器的输出。状态转换函数为 $S[k+1] = f(S[k], x[k])$，其中 $x[k]$ 是周期 $k$ 期间的输入。\n\n**1. 未寄存的 Mealy FSM**\n\n在 Mealy 型状态机中，输出 $z[k]$ 是当前状态 $S[k]$ 和当前输入 $x[k]$ 的函数，即 $z[k] = g(S[k], x[k])$。由于该输出由组合逻辑生成，其值在周期 $k$ 内、在状态寄存器和输出逻辑本身的传播延迟之后变为可用。\n\n我们设计一个 FSM 来检测 `1011`。状态表示输入流中作为 `1011` 前缀的最长后缀。\n- $S_0$：空前缀（复位状态）。\n- $S_1$：匹配前缀 `1`。\n- $S_2$：匹配前缀 `10`。\n- $S_3$：匹配前缀 `101`。\n\n当状态机处于状态 $S_3$ 并接收到输入 $1$ 时，即检测到 `1011`。输出逻辑 $g(S,x)$ 仅在 $S=S_3$ 且 $x=1$ 时为 $1$。\n\n让我们跟踪给定输入序列的状态转换：$x[n-4]=0, x[n-3]=1, x[n-2]=0, x[n-1]=1, x[n]=1$。我们假设在此序列之前 FSM 处于状态 $S_0$，这由 $x[n-4]=0$ 保证。\n\n-   **周期 $n-3$**：在上升沿 $n-3$ 时，状态为 $S[n-3]=S_0$。输入为 $x[n-3]=1$。\n    在边沿 $n-2$ 锁存的下一状态为 $S[n-2]=f(S_0,1)=S_1$。\n    此周期内的 Mealy 输出为 $z[n-3]=g(S_0,1)=0$。\n\n-   **周期 $n-2$**：在上升沿 $n-2$ 时，状态为 $S[n-2]=S_1$。输入为 $x[n-2]=0$。\n    在边沿 $n-1$ 锁存的下一状态为 $S[n-1]=f(S_1,0)=S_2$。\n    Mealy 输出为 $z[n-2]=g(S_1,0)=0$。\n\n-   **周期 $n-1$**：在上升沿 $n-1$ 时，状态为 $S[n-1]=S_2$。输入为 $x[n-1]=1$。\n    在边沿 $n$ 锁存的下一状态为 $S[n]=f(S_2,1)=S_3$。\n    Mealy 输出为 $z[n-1]=g(S_2,1)=0$。\n\n-   **周期 $n$**：在上升沿 $n$ 时，状态为 $S[n]=S_3$。输入为 $x[n]=1$。序列 `1011` 现已完成。\n    此周期内的 Mealy 输出为 $z[n]=g(S_3,1)=1$。\n    此输出在周期 $n$ 内置位为 $1$，在状态 $S[n]$ 变为可用且组合逻辑 $g$ 计算出结果之后。\n\n因此，未寄存的 Mealy 输出 $z[k]$ 在周期 $n$ 期间首次置位。\n\n**2. Moore FSM**\n\n在 Moore 型状态机中，输出 $y[k]$ 仅是当前状态 $S[k]$ 的函数，即 $y[k]=h(S[k])$。该输出在整个周期内保持稳定。为了表示检测到一个序列，FSM 必须进入一个其关联输出为 $1$ 的特定状态。\n\n为了检测 `1011`，与 Mealy FSM 相比，我们需要一个额外的状态（我们称之为 $S_4$）来表示已接收到完整序列。\n- $S_0, S_1, S_2, S_3$：同上，对于 $i \\in \\{0, 1, 2, 3\\}$，输出 $h(S_i)=0$。\n- $S_4$：匹配序列 `1011`。输出 $h(S_4)=1$。\n\n让我们跟踪状态转换：\n- 到周期 $n$ 为止的状态演进与 Mealy 型状态机相同：$S[n-3]=S_0$, $S[n-2]=S_1$, $S[n-1]=S_2$, $S[n]=S_3$。\n- **周期 $n$**：在上升沿 $n$ 时，状态为 $S[n]=S_3$。输入为 $x[n]=1$。\n    此周期内的 Moore 输出为 $y[n]=h(S[n]) = h(S_3) = 0$。\n    由 $f(S[n],x[n]) = f(S_3,1)$ 决定的下一状态是检测状态 $S_4$。因此，$S[n+1]=S_4$。此状态在上升沿 $n+1$ 被锁存。\n\n- **周期 $n+1$**：在上升沿 $n+1$ 时，状态变为 $S[n+1]=S_4$。\n    此周期内的 Moore 输出为 $y[n+1]=h(S[n+1]) = h(S_4) = 1$。\n\n因此，Moore 输出 $y[k]$ 在周期 $n+1$ 的开始处首次置位。\n\n**3. 寄存的 Mealy 输出**\n\n寄存的 Mealy 输出 $z_r[k]$ 被定义为在上升沿 $k$ 由 D 型触发器捕获的 $z[k-1]$ 的值。这意味着在周期 $k$ 期间 $z_r$ 的值等于在周期 $k-1$ 期间 $z$ 的值。因此，$z_r[k] = z[k-1]$。\n\n- 我们发现未寄存的输出 $z[k]$ 对于所有 $k  n$ 均为 $0$，且 $z[n]=1$。\n- 为了找出 $z_r[k]$ 首次置位的时间，我们可以评估其在 $n$ 周围周期的值：\n    - 对于周期 $n$，$z_r[n] = z[n-1] = 0$。\n    - 对于周期 $n+1$，$z_r[n+1] = z[n] = 1$。\n\n因此，寄存的 Mealy 输出 $z_r[k]$ 在周期 $n+1$ 期间首次置位。\n\n**结果总结**\n- 未寄存的 Mealy 输出 $z[k]$ 在周期 $n$ 期间首次置位。\n- Moore 输出 $y[k]$ 在周期 $n+1$ 期间首次置位。\n- 寄存的 Mealy 输出 $z_r[k]$ 在周期 $n+1$ 期间首次置位。\n\n现在我们评估给出的选项。\n\n**A. 未寄存的 Mealy 输出 $z[k]$ 可以在周期 $n$ 期间首次置位，而 Moore 输出 $y[k]$ 在周期 $n+1$ 首次置位。如果 $z[k]$ 被寄存以形成 $z_{r}[k]$，则 $z_{r}[k]$ 在周期 $n+1$ 首次置位。**\n此陈述与我们为所有三种输出推导出的结果完全匹配。\n**结论：正确。**\n\n**B. 一个在上升沿采样的同步下游寄存器可以在边沿 $n$ 就观察到未寄存的 Mealy 型输出已置位，而 Moore 输出则需要等到边沿 $n+1$。**\n未寄存的 Mealy 输出 $z[n]$ 是由 $S[n]$ 和 $x[n]$ 生成的。状态 $S[n]$ 是在上升沿 $n$ 触发的触发器的输出。因此，$S[n]$ 仅在边沿 $n$ *之后* 才变为有效。因此，$z[n]$ 是在边沿 $n$ *之后*，即在周期 $n$ 期间生成的。对于一个同步寄存器要在边沿 $n$ 采样一个值，该值必须在边沿 $n$ *之前* 的建立时间内保持稳定。在那个时刻，Mealy 输出是 $z[n-1]=0$。不可能在边沿 $n$ 采样到 $z[n]$ 的置位值。下游寄存器可以在下一个上升沿，即边沿 $n+1$，采样到 $z[n]=1$。\n**结论：不正确。**\n\n**C. 未寄存的 Mealy 和 Moore 输出都可以在周期 $n$ 期间首次置位，因为它们都依赖于周期 $n$ 开始时上升沿之后立即可用的信号。**\n这个说法是错误的。如上所述，Moore 输出 $y[k]$ 在周期 $n+1$ 首次置位，而不是周期 $n$。Moore 型状态机的一个决定性特征是其输出仅依赖于寄存的状态，这意味着与 Mealy 型状态机相比，标志序列完成的输出变化会延迟一个时钟周期。\n**结论：不正确。**\n\n**D. 寄存 Mealy 输出总是相对于最后一个输入比特增加两个完整周期的延迟，因此 $z_{r}[k]$ 在周期 $n+2$ 首次置位。**\n最后一个输入比特 $x[n]$ 在周期 $n$ 到达。未寄存的 Mealy 输出 $z[n]$ 在同一周期内置位。如前所述，使用一个 D 型触发器寄存此输出，会增加恰好一个周期的延迟。如我们的分析所示，$z_r[k]$ 在周期 $n+1$ 置位，这是周期 $n$ 之后的一个周期。两个周期的延迟将意味着在周期 $n+2$ 置位，这是不正确的。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3628036"}, {"introduction": "在数字系统设计中，实现同一功能常有多种架构选择，每种选择都在不同性能维度上有所取舍。本练习探讨了使用两种截然不同的方法——一种是组合逻辑（查找表及线性插值），另一种是序贯逻辑（类 CORDIC 迭代）——来逼近数学函数 $f(x) = x^2$。这个实践将引导您量化分析数字设计中一个经典的核心权衡：面积与延迟的交换，即“空间换时间”或“时间换空间”[@problem_id:3628129]。", "problem": "一个定点数据通路必须使用两种备选架构来近似实值函数 $f(x) = x^{2}$，输入 $x \\in [0,1]$：一种是带分段线性插值的组合查找表 (LUT)，另一种是序贯迭代类 CORDIC 平方器。$x$ 的定点格式使用 $b = 16$ 个小数位。\n\n架构 C (组合逻辑)：近似域 $[0,1]$ 被划分为 $N$ 个宽度为 $h = 1/N$ 的均匀段。该设计将端点值 $y_{k} = (k/N)^{2}$ (其中 $k = 0,1,\\dots,N$) 存储在存储器中，并执行分段线性插值：对于 $x \\in [k/N,(k+1)/N]$，它计算 $y \\approx y_{k} + t \\cdot (y_{k+1} - y_{k})$，其中 $t \\in [0,1]$ 是段内的局部小数位置。该数据通路使用一个减法器来形成 $(y_{k+1} - y_{k})$，一个乘法器来计算 $t \\cdot (y_{k+1} - y_{k})$，以及一个加法器来形成 $y_{k} + (\\cdot)$。假设此组合路径的延迟为单周期。存储的 $y$ 值字宽为 $w_{y} = 16$ 位。使用面积成本模型\n- 存储器面积 $A_{\\text{mem}} = c_{\\text{mem}} \\times (N+1) \\times w_{y}$，\n- 加法器/减法器面积 $A_{\\text{add}} = c_{\\text{add}} \\times w_{y}$ 每个单元，\n- 乘法器面积 $A_{\\text{mul}} = c_{\\text{mul}} \\times w_{t} \\times w_{y}$，\n其中 $w_{t} = 16$ 位用于 $t$。常数为 $c_{\\text{mem}} = 1$，$c_{\\text{add}} = 2$，$c_{\\text{mul}} = 6$ (均采用相同的归一化等效门单位)。\n\n架构 S (序贯逻辑)：一个类 CORDIC 迭代平方器通过移位加法操作，每次迭代解析 $x$ 的一个小数位。经过 $k$ 次迭代后，内部表示等于将 $x$ 截断到 $m=k$ 个小数位的值 $\\hat{x}$，输出为 $\\hat{x}^{2}$。硬件由一个 $w_{y}$ 位加法器、两个 $w_{y}$ 位寄存器和固定面积为 $A_{\\text{ctrl}} = 64$ (单位相同) 的控制逻辑组成。使用面积成本模型\n- 加法器面积 $A_{\\text{add}} = c_{\\text{add}} \\times w_{y}$，\n- 寄存器面积 $A_{\\text{reg}} = c_{\\text{reg}} \\times w_{y}$ 每个寄存器，\n其中 $c_{\\text{add}} = 2$，$c_{\\text{reg}} = 0.5$。序贯延迟为 $k$ 个周期。\n\n从第一性原理出发：\n- 仅使用微积分和 $f(x) = x^{2}$ 的分段线性插值定义，推导架构 C 在 $[0,1]$ 上的最大绝对误差关于 $N$ 的最坏情况界限。\n- 仅使用截断到 $m$ 位的定义和平方的代数恒等式，推导架构 S 经过 $k$ 次迭代后的最大绝对误差的最坏情况界限。\n设 $k = 10$。选择最小的正整数 $N$，使得架构 C 在 $[0,1]$ 上的最坏情况最大绝对误差不超过架构 S 的。\n\n利用这个 $N$，使用给定的成本模型计算每个架构的面积，计算每个架构的面积延迟积，然后计算比率\n$$R \\;=\\; \\frac{\\text{(架构 C 的面积延迟积)}}{\\text{(架构 S 的面积延迟积)}}。$$\n将最终比率 $R$ 四舍五入到四位有效数字。最终答案以纯数字形式表示，不带单位。", "solution": "问题陈述已经过验证，被确定为数字架构设计与分析领域中一个定义良好、有科学依据的问题。该问题是自包含、客观的，其解决需要实质性的推理。我们开始进行解答。\n\n该问题要求对两种用于在区间 $x \\in [0,1]$ 上近似函数 $f(x) = x^2$ 的数字架构进行对比分析。我们将首先推导每种架构的最坏情况近似误差，然后使用这些误差界限来确定一个设计参数，最后计算面积延迟性能指标以进行比较。\n\n**第1部分：架构 C (组合逻辑 LUT) 的最坏情况误差**\n\n架构 C 使用分段线性插值来近似 $f(x) = x^2$。定义域 $[0,1]$ 被划分为 $N$ 个段，每段宽度为 $h = 1/N$。对于区间 $[x_k, x_{k+1}]$，其中 $x_k = k/N$，线性近似 $L(x)$ 由下式给出：\n$$L(x) = f(x_k) + \\frac{f(x_{k+1}) - f(x_k)}{x_{k+1} - x_k}(x - x_k)$$\n此近似的误差为 $E(x) = f(x) - L(x)$。根据线性插值的标准误差界，对于具有连续二阶导数的函数，误差由下式给出：\n$$E(x) = \\frac{f''(\\xi)}{2!}(x - x_k)(x - x_{k+1})$$\n对于某个 $\\xi \\in (x_k, x_{k+1})$。\n\n对于我们的函数 $f(x) = x^2$，其导数为 $f'(x) = 2x$ 和 $f''(x) = 2$。二阶导数是常数。因此，误差表达式变为：\n$$E(x) = \\frac{2}{2}(x - x_k)(x - x_{k+1}) = (x-x_k)(x-x_{k+1})$$\n为了找到区间 $[x_k, x_{k+1}]$ 内的最大绝对误差，我们必须找到二次函数 $g(x) = (x-x_k)(x-x_{k+1})$ 的最大幅值。这个二次函数在 $x_k$ 和 $x_{k+1}$ 处有根，其顶点位于区间的中点 $x = (x_k + x_{k+1})/2$。\n最大误差的位置是 $x_{mid} = x_k + h/2$。\n区间内的最大误差幅值为：\n$$|E(x_{mid})| = \\left|\\left(x_k + \\frac{h}{2} - x_k\\right)\\left(x_k + \\frac{h}{2} - x_{k+1}\\right)\\right| = \\left|\\left(\\frac{h}{2}\\right)\\left(x_k + \\frac{h}{2} - (x_k+h)\\right)\\right| = \\left|\\left(\\frac{h}{2}\\right)\\left(-\\frac{h}{2}\\right)\\right| = \\frac{h^2}{4}$$\n由于 $h=1/N$ 且该误差幅值与具体区间 $k$ 无关，因此这是在整个定义域 $[0,1]$ 上的最坏情况误差。\n架构 C 的最大绝对误差为：\n$$\\epsilon_C = \\frac{1}{4N^2}$$\n\n**第2部分：架构 S (序贯平方器) 的最坏情况误差**\n\n架构 S 计算 $\\hat{x}^2$，其中 $\\hat{x}$ 是将 $x$ 截断到 $m$ 个小数位后的值。输入 $x$ 定义为具有 $b=16$ 个小数位，但误差分析取决于截断到 $m$ 位。\n对于给定的 $x \\in [0,1]$，$\\hat{x}$ 是形式为 $\\sum_{i=1}^m d_i 2^{-i}$ (其中 $d_i \\in \\{0,1\\}$) 且满足 $\\hat{x} \\le x$ 的最大数。这意味着存在以下关系：\n$$\\hat{x} \\le x  \\hat{x} + 2^{-m}$$\n输出的误差是 $\\Delta = x^2 - \\hat{x}^2$。由于 $x \\ge \\hat{x}$，该误差始终为非负。我们希望找到它在所有 $x \\in [0,1]$ 上的最大值。\n$$\\Delta = x^2 - \\hat{x}^2  (\\hat{x} + 2^{-m})^2 - \\hat{x}^2 = \\hat{x}^2 + 2\\hat{x}2^{-m} + (2^{-m})^2 - \\hat{x}^2 = 2\\hat{x}2^{-m} + 2^{-2m}$$\n这个误差上界 $2\\hat{x}2^{-m} + 2^{-2m}$ 是 $\\hat{x}$ 的增函数。为了找到误差的上确界，我们必须考虑 $\\hat{x}$ 可能的最大值。\n当 $x$ 趋近于 $1$ 时，$\\hat{x}$ 趋近于其可能的最大值。对于任何 $x \\in [1-2^{-m}, 1)$，截断值为 $\\hat{x} = \\sum_{i=1}^m 1 \\cdot 2^{-i} = 1 - 2^{-m}$。\n对于固定的 $\\hat{x}$，误差 $x^2 - \\hat{x}^2$ 在 $x$ 接近其范围的上端时最大化，即当 $x \\to \\hat{x} + 2^{-m}$ 时。\n总体的最大误差发生在 $x \\to 1$ 时。在这种情况下，$\\hat{x}$ 趋近于 $1$。因此，最大误差可以从 $x \\to 1$ 时的误差界限中找到。\n更准确地说，误差 $\\Delta = x^2 - \\hat{x}^2$ 的最大值发生在 $x$ 的值恰好低于下一个截断点时。考虑区间 $[\\hat{x}, \\hat{x}+2^{-m})$。误差在此区间内是单调递增的。因此，最大误差在 $x \\to \\hat{x}+2^{-m}$ 时接近。该误差值趋近于 $(\\hat{x}+2^{-m})^2 - \\hat{x}^2 = 2\\hat{x}2^{-m} + 2^{-2m}$。这个值随着 $\\hat{x}$ 的增大而增大。最大的 $\\hat{x}$ 是当 $x \\to 1$ 时得到的，即 $\\hat{x} \\to 1-2^{-m}$。因此，最大误差的界限是 $x \\to 1$ 时的误差，即 $1^2 - (1-2^{-m})^2 = 1 - (1 - 2 \\cdot 2^{-m} + 2^{-2m}) = 2^{-m+1} - 2^{-2m}$。\n$$\\epsilon_S = 2^{-m+1} - 2^{-2m}$$\n\n**第3部分：确定段数 N**\n\n我们已知序贯架构使用 $k=10$ 次迭代，所以 $m=k=10$。架构 S 的误差是：\n$$\\epsilon_S = 2^{-10+1} - 2^{-2 \\cdot 10} = 2^{-9} - 2^{-20} = \\frac{1}{512} - \\frac{1}{1048576} = \\frac{2^{11}-1}{2^{20}} = \\frac{2047}{1048576}$$\n我们必须找到最小的正整数 $N$，使得架构 C 的误差不超过这个值：\n$$\\epsilon_C \\le \\epsilon_S \\implies \\frac{1}{4N^2} \\le 2^{-9} - 2^{-20}$$\n$$4N^2 \\ge \\frac{1}{2^{-9} - 2^{-20}} \\implies N^2 \\ge \\frac{1}{4(2^{-9} - 2^{-20})} = \\frac{1}{4} \\frac{2^{20}}{2^{11}-1} = \\frac{2^{18}}{2047}$$\n数值上，这是：\n$$N^2 \\ge \\frac{262144}{2047} \\approx 128.0625...$$\n取平方根：\n$$N \\ge \\sqrt{128.0625...} \\approx 11.316...$$\n由于 $N$ 必须是整数，所以 $N$ 的最小值为 $12$。\n\n**第4部分：计算架构面积和面积延迟积**\n\n当 $N=12$ 且 $k=10$ 时，我们现在可以使用提供的成本模型和参数来计算每个架构的面积：$w_y = 16$，$w_t=16$，$c_{\\text{mem}}=1$，$c_{\\text{add}}=2$，$c_{\\text{mul}}=6$，$c_{\\text{reg}}=0.5$，$A_{\\text{ctrl}}=64$。\n\n架构 C 的面积 ($A_C$)：\n组件包括一个 $(N+1) \\times w_y$ 的存储器、一个加法器、一个减法器和一个乘法器。\n$$A_C = A_{\\text{mem}} + A_{\\text{add}} + A_{\\text{sub}} + A_{\\text{mul}}$$\n$$A_{\\text{mem}} = c_{\\text{mem}} \\times (N+1) \\times w_y = 1 \\times (12+1) \\times 16 = 13 \\times 16 = 208$$\n$$A_{\\text{add}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{sub}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{mul}} = c_{\\text{mul}} \\times w_t \\times w_y = 6 \\times 16 \\times 16 = 1536$$\n$$A_C = 208 + 32 + 32 + 1536 = 1808$$\n延迟为 $L_C = 1$ 个周期。架构 C 的面积延迟积为：\n$$P_C = A_C \\times L_C = 1808 \\times 1 = 1808$$\n\n架构 S 的面积 ($A_S$)：\n组件包括一个加法器、两个寄存器和控制逻辑。\n$$A_S = A_{\\text{add}} + 2 \\times A_{\\text{reg}} + A_{\\text{ctrl}}$$\n$$A_{\\text{add}} = c_{\\text{add}} \\times w_y = 2 \\times 16 = 32$$\n$$A_{\\text{reg}} = c_{\\text{reg}} \\times w_y = 0.5 \\times 16 = 8$$\n$$A_S = 32 + 2 \\times 8 + 64 = 32 + 16 + 64 = 112$$\n延迟为 $L_S = k = 10$ 个周期。架构 S 的面积延迟积为：\n$$P_S = A_S \\times L_S = 112 \\times 10 = 1120$$\n\n**第5部分：计算比率 R**\n\n最后一步是计算面积延迟积的比率。\n$$R = \\frac{P_C}{P_S} = \\frac{1808}{1120}$$\n$$R = \\frac{180.8}{112} = \\frac{45.2}{28} = \\frac{11.3}{7} \\approx 1.6142857...$$\n四舍五入到四位有效数字，我们得到 $R = 1.614$。", "answer": "$$\\boxed{1.614}$$", "id": "3628129"}, {"introduction": "将抽象的逻辑设计思想转化为具体的硬件描述语言 (HDL) 代码是数字工程师的一项关键技能，但这个过程充满了潜在的陷阱。本练习聚焦于一个最常见且最微妙的错误：在意图设计纯组合逻辑时，由于编码不严谨而无意中生成了序贯存储元件（锁存器）。通过分析几种典型的 HDL 编码模式，您将学会识别并避免这些问题，确保您的代码能够准确地综合出预期的硬件行为[@problem_id:3628092]。", "problem": "一位工程师正在使用硬件描述语言（HDL）编写一个纯组合逻辑模块，该模块旨在用于寄存器传输级（RTL）的综合。其预期的行为是，在时间 $t$ 的每个输出都是当前输入向量 $\\mathbf{x}(t) \\in \\{0,1\\}^n$ 的确定性函数，即输出实现了一个函数 $f:\\{0,1\\}^n \\rightarrow \\{0,1\\}^m$，并且不依赖于过去的输入。根据定义，组合电路产生的输出仅依赖于当前输入，而时序电路包含存储元件，导致其输出依赖于过去的输入。锁存器是一种电平敏感的存储元件，当其输入没有被驱动以改变状态时，它会保持其先前的值。\n\n考虑工程师在HDL中描述意图为组合逻辑时，可能对信号 `a`、`b`、`y`、`sel`、`en` 和 `op` 使用以下一般模式：\n\n- 在关于 `sel` 或 `en` 的某个条件下对 `y` 进行条件赋值。\n- 对选择器 `op` 进行case分析，其中某些情况会对 `y` 进行赋值。\n- 一个在其右侧引用了 `y` 的赋值语句。\n\n以下哪些陈述正确地识别了在组合逻辑描述中会推断出意外锁存器的场景，并提出了避免此类推断的稳健编码指南？选择所有适用的选项。\n\nA. 如果在一个预期的组合逻辑描述中，通过一个关于 `sel` 或 `en` 的条件判断的某条路径没有对 `y` 进行赋值，那么对于那些输入条件，综合工具为了保持行为一致性，必须保留先前的值 $y(t-1)$，这会产生状态。因此，应确保在每条路径上都对 `y` 进行赋值，例如，在组合逻辑块的开头为 `y` 赋一个默认值，或者提供一个详尽的 else 分支。\n\nB. 在预期的组合逻辑描述中使用阻塞赋值来为 `y` 赋值会内在地强制推断出锁存器，因为阻塞赋值会立即更新 `y`。因此，为避免在组合逻辑中产生锁存器，应始终对 `y` 使用非阻塞赋值。\n\nC. 组合逻辑描述中不完整的敏感列表会导致综合工具为 `y` 推断出锁存器。因此，为避免锁存器，应用包含所有信号的隐式敏感列表替换显式敏感列表。\n\nD. 如果在对 `op` 进行 case 分析时，某些编码路径没有对 `y` 赋值，那么对于那些编码，`y` 必须保留其先前的值 $y(t-1)$，这意味着需要存储。因此，应包含一个为 `y` 赋值的 default 分支，以使所有可能的 `op` 编码都能产生一个被驱动的 `y`。\n\nE. 如果在组合逻辑描述中，`y` 的赋值表达式引用了 `y` 本身，例如 `$y \\leftarrow y \\wedge a$`，这会创建一个组合反馈路径，其解析需要状态来模拟先前的 $y(t-1)$，从而导致综合器推断出存储元件。因此，在组合逻辑描述中应避免对 `y` 进行自引用赋值，除非有意设计一个明确定义的时序元件。", "solution": "该问题要求评估关于在硬件描述语言（HDL）中描述组合逻辑以进行寄存器传输级（RTL）综合时，意外推断出锁存器的相关陈述。综合纯组合逻辑的核心原则是，对于每种可能的输入信号组合，每个输出信号的值都必须被明确指定。如果对于任何输入组合，某个输出的值没有被指定，HDL语义规定该信号必须保持其先前的值。为了在物理上实现这种“记忆”行为，综合工具必须推断出一个存储元件。在没有明确时钟的逻辑上下文中，这种存储元件通常是锁存器。\n\n让我们基于这一基本原则来分析每个选项。\n\n**A. 如果在一个预期的组合逻辑描述中，通过一个关于 `sel` 或 `en` 的条件判断的某条路径没有对 `y` 进行赋值，那么对于那些输入条件，综合工具为了保持行为一致性，必须保留先前的值 $y(t-1)$，这会产生状态。因此，应确保在每条路径上都对 `y` 进行赋值，例如，在组合逻辑块的开头为 `y` 赋一个默认值，或者提供一个详尽的 else 分支。**\n\n这个陈述描述了一个推断出锁存器的常见场景。考虑在像Verilog这样的HDL中描述的一个过程：\n```verilog\nalways @*\n  if (sel == 1'b1)\n    y = a;\n```\n在这个描述中，`y` 的值仅在 `sel` 为 `1'b1` 时被指定。当 `sel` 为 `0` 时，该描述没有指定 `y` 应该是什么。根据HDL的仿真语义，`y` 必须保持其上一次评估时的值。为了创建一个行为如此的硬件电路，需要一个存储元件来在 `sel` 为 `0` 时保持 `y` 的值。这导致了锁存器的推断。\n所提出的指南是防止这种情况的标准且正确的方法。通过提供一个 `else` 分支：\n```verilog\nalways @*\n  if (sel == 1'b1)\n    y = a;\n  else\n    y = b;\n```\n或者通过赋一个默认值：\n```verilog\nalways @*\nbegin\n  y = b; // Default assignment\n  if (sel == 1'b1)\n    y = a;\nend\n```\n输出 `y` 现在对所有可能的 `sel` 值都被指定了。最终的逻辑是纯组合的（在本例中是一个多路选择器）。该陈述准确地指出了锁存器推断的原因，并提供了一个稳健的解决方案。\n\n结论：**正确**。\n\n**B. 在预期的组合逻辑描述中使用阻塞赋值来为 `y` 赋值会内在地强制推断出锁存器，因为阻塞赋值会立即更新 `y`。因此，为避免在组合逻辑中产生锁存器，应始终对 `y` 使用非阻塞赋值。**\n\n这个陈述在事实上是错误的。在像Verilog这样的HDL中，过程块内主要有两种赋值类型：阻塞赋值（`=`）和非阻塞赋值（`=`）。它们之间的选择会影响仿真过程中的更新调度，并且是避免竞争条件的稳健编码风格的关键部分。标准的指南是为组合逻辑使用阻塞赋值，为时序逻辑使用非阻塞赋值。锁存器的推断取决于规范的完备性（即，是否在所有可能条件下都为输出赋值），而不是所使用的赋值操作符类型。例如，以下两个不完整的描述都将推断出锁存器，而不管赋值类型如何：\n`always @(sel, a) if (sel) y = a;` // 使用阻塞赋值推断出锁存器\n`always @(sel, a) if (sel) y = a;` // 使用非阻塞赋值推断出锁存器\n在这两种情况下，推断锁存器的原因都是缺少 `else` 子句。阻塞赋值导致锁存器的前提是错误的，而为组合逻辑始终使用非阻塞赋值的建议与既定的最佳实践相悖。\n\n结论：**不正确**。\n\n**C. 组合逻辑描述中不完整的敏感列表会导致综合工具为 `y` 推断出锁存器。因此，为避免锁存器，应用包含所有信号的隐式敏感列表替换显式敏感列表。**\n\n这个陈述描述了一个常见的HDL编码错误，但错误地归因了其主要后果。不完整的敏感列表会导致仿真-综合不匹配。例如：\n`always @(a) // Sensitivity list is missing 'b'`\n`  y = a | b;`\n在仿真中，这个块只会在 `a` 改变时重新评估。如果 `b` 改变，该块不会触发，`y` 会保持其旧值。这种仿真行为相对于 `b` 确实类似锁存器。然而，综合工具会分析块内的逻辑：`y = a | b;`。这明确无误地描述了一个组合逻辑的或门。工具将综合一个或门，并很可能会发出一个警告，指出敏感列表不完整。综合出的硬件不会包含锁存器。因此，不完整的敏感列表并不会导致*综合工具推断出锁存器*；它会导致综合前的仿真行为与综合后的硬件行为不同。尽管所提出的指南——使用隐式的、包含所有信号的敏感列表（例如，Verilog中的 `always @*` 或VHDL中的 `process(all)`）——是消除这种不匹配的关键最佳实践，但陈述中给出的理由——为了避免锁存器推断——是不正确的。\n\n结论：**不正确**。\n\n**D. 如果在对 `op` 进行 case 分析时，某些编码路径没有对 `y` 赋值，那么对于那些编码，`y` 必须保留其先前的值 $y(t-1)$，这意味着需要存储。因此，应包含一个为 `y` 赋值的 default 分支，以使所有可能的 `op` 编码都能产生一个被驱动的 `y`。**\n\n这个陈述与选项 A 类似，但应用于 `case` 语句。如果一个 `case` 语句（用于实现多路选择器或译码器）没有覆盖其选择器信号（`op`）所有可能的二进制编码，那么对于未覆盖的编码，在 `case` 语句内赋值的任何输出都没有被赋予新值。例如：\n```verilog\nalways @*\n  case (op) // op is a 2-bit signal\n    2'b00: y = a;\n    2'b01: y = b;\n    2'b10: y = a + b;\n    // case 2'b11 is missing\n  endcase\n```\n当 `op` 是 `2'b11` 时，`y` 没有被赋值。为了保持其值，必须推断出一个锁存器。所提出的解决方案，即添加一个 `default` 分支，确保了 `y` 对所有可能的 `op` 编码都被赋予一个值，从而确保逻辑保持为纯组合逻辑。\n```verilog\nalways @*\n  case (op)\n    ...\n    default: y = some_default_value;\n  endcase\n```\n该陈述正确地指出了原因，并提出了标准的、正确的解决方案。\n\n结论：**正确**。\n\n**E. 如果在组合逻辑描述中，`y` 的赋值表达式引用了 `y` 本身，例如 `$y \\leftarrow y \\wedge a$`，这会创建一个组合反馈路径，其解析需要状态来模拟先前的 $y(t-1)$，从而导致综合器推断出存储元件。因此，在组合逻辑描述中应避免对 `y` 进行自引用赋值，除非有意设计一个明确定义的时序元件。**\n\n这个陈述描述了组合逻辑反馈。一个带有反馈回路的纯组合电路，即 `$y(t) = f(y(t), \\text{inputs}(t))$`，可能不稳定（振荡），或者其稳态行为可能难以确定。当综合工具在旨在用于组合逻辑的过程块中遇到这样的结构时，它通常会将右侧的信号解释为“先前的”或存储的值。因此，描述 `$y \\leftarrow y \\wedge a$` 被解释为 `$y(t) \\leftarrow y(t-1) \\wedge a(t)$`。这是存储值 $y(t-1)$ 的时序电路元件的行为定义。综合器必须推断出一个存储元件（锁存器或触发器，取决于上下文）来实现这种行为。因此，创建这样的反馈回路是描述状态保持逻辑的直接方式，如果在意图为组合逻辑的块中使用，它将导致存储元件的推断。避免此类结构的建议是正确的，除非明确希望设计一个时序元件。\n\n结论：**正确**。\n\n总而言之，陈述 A、D 和 E 正确地指出了导致意外推断锁存器的场景，并提出了有效的编码指南来防止它们。", "answer": "$$\\boxed{ADE}$$", "id": "3628092"}]}