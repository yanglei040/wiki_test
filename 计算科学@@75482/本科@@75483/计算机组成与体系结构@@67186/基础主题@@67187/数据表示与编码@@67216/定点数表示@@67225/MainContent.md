## 引言
在数字计算的世界中，我们如何高效地表示和处理像音频信号或传感器读数这样的非整数值？虽然[浮点数](@entry_id:173316)提供了极高的精度和动态范围，但其复杂的硬件实现对于许多嵌入式系统、[数字信号处理](@entry_id:263660)器（DSP）和现代机器学习加速器而言，在成本、[功耗](@entry_id:264815)和性能上都构成了巨大挑战。定点数表示法作为一种巧妙的替代方案应运而生，它通过在硬件层面复用整数运算单元，为这些资源受限的应用提供了处理小数的关[键能](@entry_id:142761)力。

然而，这种效率的背后是一系列复杂的设计权衡。工程师必须在数值的精度、可表示的范围以及硬件成本之间做出精确的平衡。不当的格式选择或对运算副作用（如[溢出](@entry_id:172355)和量化误差）的忽视，可能导致从轻微的性能下降到灾难性的系统失效。本文旨在填补理论与实践之间的鸿沟，系统性地阐述定点数的设计、实现与应用。

读者将通过本文学习到：第一章“原理与机制”将深入剖析定点数的基础，包括[Q格式](@entry_id:753884)、算术规则、[溢出处理](@entry_id:144972)和[误差分析](@entry_id:142477)。第二章“应用与跨学科联系”将通过来自数字信号处理、控制系统和机器学习等领域的丰富案例，展示定点数在解决实际工程问题中的强大作用。最后，第三章“动手实践”将提供具体练习，以巩固所学知识。本文将从定点数表示法的基本原理和核心机制讲起，为后续的应用和实践打下坚实的基础。

## 原理与机制

在数字系统中，处理现实世界的信号——无论是音频、视频还是传感器读数——都要求我们能够表示和操作非整数值。虽然[浮点表示法](@entry_id:172570)提供了巨大的动态范围和精度，但在许多计算密集型且对成本、功耗和性能有严格要求的应用中（例如嵌入式系统和[数字信号处理器 (DSP)](@entry_id:748428)），其硬件复杂性可能过高。[定点表示法](@entry_id:174744)提供了一种高效的替代方案，它通过在二[进制](@entry_id:634389)数的固定位置假定一个小数点来表示小数。本章将深入探讨定点数表示的原理、算术运算机制及其在[系统设计](@entry_id:755777)中的权衡。

### [定点表示法](@entry_id:174744)基础

从根本上说，定点数是一种通过复用整数[算术逻辑单元 (ALU)](@entry_id:178252) 来处理小数的巧妙技巧。我们只需约定，在一个 $b$ 位的二进制数中，小数点位于某个固定的位置。这有效地将整数按 $2$ 的某个次幂进行缩放。

#### Q 格式表示法

为了[标准化](@entry_id:637219)这种约定，业界发展出了 **Q 格式**表示法。然而，Q 格式的定义存在多种变体，因此理解其上下文至关重要。一种常见的形式是 **Qm.n 格式**，特别适用于有符号整数。

- **Qm.n 格式**：一个二[进制](@entry_id:634389)数被解释为包含 1 个[符号位](@entry_id:176301)、 $m$ 个整数位和 $n$ 个小数位。总位数通常为 $b = 1 + m + n$。符号位位于最高有效位 (MSB)。整数部分由符号位和 $m$ 个整数位共同构成，而小数部分由 $n$ 个小数位构成。

一个以这种格式编码的数，其真实值 $v$ 由其底层的 $b$ 位整数表示 $X$ 通过除以 $2^n$ 得到：
$$v = X \cdot 2^{-n}$$

Qm.n 格式的两个关键属性是其**分辨率(Resolution)**和**范围(Range)**。

- **分辨率**：也称为精度，是可表示的最小正增量。这由最不重要的位 (LSB) 的权重决定。在 Qm.n 格式中，分辨率 $\delta$ 为：
  $$\delta = 2^{-n}$$
  增加小数部分的位数 $n$ 会提高分辨率，使得数值网格更密集，从而可以更精确地表示一个实数。

- **范围**：指该格式可以表示的最小值和最大值。这主要由整数部分的位数 $m$ 和所使用的[有符号数](@entry_id:165424)编码方案决定。

#### 常见的 Q 格式变体

在[数字信号处理 (DSP)](@entry_id:177080) 领域，尤其是在[音频处理](@entry_id:273289)中，信号通常被归一化到 $[-1.0, 1.0)$ 的范围内。这催生了一种更简洁的表示法，如 **Q15** 或 **Q31** [@problem_id:3641238]。

- **Qn 格式**：在这种约定下，数字 $n$ 直接表示小数位的数量。它通常隐含地表示这是一个[有符号数](@entry_id:165424)，且整数部分的位数为 0（即 $m=0$）。因此，一个 Qn 格式的数总位宽为 $b = n + 1$ （$n$ 个小数位加 1 个符号位），其范围近似为 $[-1, 1)$。例如，一个 Q15 数有 15 个小数位和 1 个符号位，总共 16 位。

### 有符号定点编码

与整数一样，定点数也需要一种编码方案来处理负值。最常见的三种方案是符号-数值 (Sign-Magnitude, SM)、[反码](@entry_id:172386) (One's Complement, OC) 和补码 (Two's Complement, TC)。它们的选择对硬件实现和[数值范围](@entry_id:752817)有着深远的影响 [@problem_id:3641235]。

- **符号-数值 (SM)**：最高位作为[符号位](@entry_id:176301) (0为正, 1为负)，其余位表示数值的绝对大小。这种表示法直观，但存在两个问题：它有两个零的表示（`+0` 和 `-0`），并且加法和减法逻辑复杂。硬件需要首先检查符号，然后根据符号是相同还是不同来决定是执行加法还是减法，可能还需要比较大小，这使得 ALU 设计效率低下。

- **[反码](@entry_id:172386) (OC)**：正数表示与无符号数相同。负数通过对相应的正数按位取反得到。它也存在两个零的表示（全0和全1）。其加法逻辑比 SM 简单，但需要一个称为**[循环进位](@entry_id:164748) (end-around carry)** 的额外步骤：如果最高位的加法产生了进位，这个进位必须被加到结果的最低位上。减法 $a - b$ 可以通过计算 $a$ 加上 $b$ 的[反码](@entry_id:172386)来实现，同样需要[循环进位](@entry_id:164748)。

- **补码 (TC)**：这是现代计算机系统中最主流的表示法。正数表示不变，负数通过对相应正数按位取反再加一得到。[补码](@entry_id:756269)只有一个唯一的零表示（全0），并且其加法和减法逻辑统一且简单。减法 $a - b$ 可以直接通过标准的加法硬件计算 $a + (\text{NOT}(b) + 1)$ 来实现，无需额外的修正步骤。

下表总结了在一个具有 $m$ 个整数位（不含[符号位](@entry_id:176301)）和 $n$ 个小数位的 $b=m+n+1$ 位系统中，不同编码的范围：

| 编码方案 | 最小值 | 最大值 | 零的表示 |
| :--- | :--- | :--- | :--- |
| 补码 (TC) | $-2^m$ | $2^m - 2^{-n}$ | 唯一 |
| [反码](@entry_id:172386) (OC) | $-(2^m - 2^{-n})$ | $2^m - 2^{-n}$ | 两个 |
| 符号-数值 (SM) | $-(2^m - 2^{-n})$ | $2^m - 2^{-n}$ | 两个 |

由于其唯一的零表示和简洁的算术逻辑，**[补码](@entry_id:756269)**几乎是所有现代处理器中[定点运算](@entry_id:170136)的默认选择。后续的讨论将主要基于补码系统。

### 实践中的格式选择

设计一个使用定点数的系统时，首要任务是为给定的应用选择合适的 $m$ 和 $n$ 值。这个决策是一个平衡过程，需要在满足系统对范围和分辨率的要求与最小化硬件成本（如存储和计算资源）之间进行权衡。

我们可以通过一个具体的例子来说明这个过程，比如为一个数字温度传感器设计接口 [@problem_id:3641312]。假设传感器测量的温度范围是 $[-40, 125]$ [摄氏度](@entry_id:141511)，并且要求系统的分辨率不低于 $0.1$ 摄氏度。我们的目标是找到满足这两个条件的最小的 $(m, n)$ 组合。

1.  **确定小数位数 $n$**：分辨率要求决定了 $n$ 的最小值。分辨率 $\delta$ 必须小于或等于 $0.1$。
    $$ 2^{-n} \le 0.1 $$
    $$ 10 \le 2^n $$
    通过计算可知，$2^3 = 8$ 而 $2^4 = 16$。因此，为满足此不等式， $n$ 必须至少为 $4$。所以，我们确定 $n_{min} = 4$。

2.  **确定整数位数 $m$**：[数值范围](@entry_id:752817)要求决定了 $m$ 的最小值。在[补码](@entry_id:756269) Qm.n 格式中，可表示的范围是 $[-2^m, 2^m - 2^{-n}]$。为了完整覆盖 $[-40, 125]$ 的区间，必须满足以下两个条件：
    $$ -2^m \le -40 \implies 2^m \ge 40 $$
    $$ 2^m - 2^{-n} \ge 125 \implies 2^m \ge 125 + 2^{-n} $$
    第二个条件 $2^m \ge 125 + 2^{-n}$ 比第一个条件 $2^m \ge 40$ 更为严格，因此我们只需关注第二个。由于我们已经知道 $n \ge 4$， $2^{-n}$ 是一个很小的正数。这意味着 $2^m$ 必须略大于 $125$。查看 2 的幂次：$2^6 = 64$，$2^7 = 128$。因此，$m$ 必须至少为 $7$ 才能使 $2^m$ 大于 $125$。我们确定 $m_{min} = 7$。

3.  **验证和结论**：我们找到了最小的组合 $(m, n) = (7, 4)$。让我们验证一下这个选择：
    -   **分辨率**：$2^{-4} = 0.0625$, 满足 $\le 0.1$ 的要求。
    -   **范围**：$[-2^7, 2^7 - 2^{-4}] = [-128, 127.9375]$。这个范围完全覆盖了 $[-40, 125]$。

因此，Qm.n 格式 $Q7.4$ 是满足该应用要求的最低配置。这种系统化的方法确保了既不浪费比特，又能保证数值的正确表示。

### [定点算术](@entry_id:170136)运算

定点数的算术运算是在其底层的整数表示上进行的，这正是其硬件效率的来源。然而，这也引入了一些需要仔细处理的细微之处，特别是关于溢出和位增长。

#### 加法与减法：溢出和饱和

当两个 [Qm.n格式](@entry_id:753884)的数相加或相减时，只要它们的二进制小数点对齐，就可以直接对它们的 $b$ 位整数表示执行加法或减法。结果的格式仍然是 Qm.n。

然而，一个严重的问题是**溢出 (Overflow)**。在[补码](@entry_id:756269)系统中，当两个正数相加得到一个负数结果，或者两个负数相加得到一个正数结果时，就会发生溢出。这在硬件上可以通过检测符号位所在位置的进位来进行判断：**当进入[符号位](@entry_id:176301)的进位 ($C_{in}$) 与离开[符号位](@entry_id:176301)的进位 ($C_{out}$) 不同时，表示发生[溢出](@entry_id:172355)** [@problem_id:3641308]。
$$ V = C_{in} \oplus C_{out} $$
其中 $V$ 是[溢出标志位](@entry_id:173845)。

处理溢出有两种常见方式：

1.  **回绕 (Wrap-around)**：这是整数 ALU 的默认行为。结果会 "回绕"到表示范围的另一端。例如，一个 8 位[有符号数](@entry_id:165424)的最大值 $127$ 加上 $1$ 会变成 $-128$。这种行为在大多数控制逻辑中是不可接受的，因为它会导致灾难性的错误。

2.  **饱和 (Saturation)**：这是一种在 DSP 应用中更受欢迎的策略。如果运算结果超出可表示范围，它会被“钳位”或“饱和”到最接近的可表示的端点值。例如，如果正向溢出，结果被设为最大可表示值 $X_{max}$；如果负向[溢出](@entry_id:172355)，结果被设为最小可表示值 $X_{min}$。这可以防止灾难性的回绕，并模拟了现实世界中[模拟电路](@entry_id:274672)的行为。

一个支持饱和算术的 ALU 数据通路需要包含[溢出检测](@entry_id:163270)逻辑，并使用多路选择器根据[溢出](@entry_id:172355)标志 $V$ 来选择是通过原始计算结果还是饱和值 [@problem_id:3641308]。现代 DSP 通常会提供专门的硬件指令来执行饱和算术。

#### 乘法：位增长

定点乘法比加法更复杂，因为它会导致位宽的增长。当你将一个 $N_1$ 位的整数与一个 $N_2$ 位的整数相乘时，完整的乘积最多需要 $N_1 + N_2$ 位来存储。

对于定点数，这个规则同样适用，并且我们可以分别考虑整数[部分和](@entry_id:162077)小数部分。如果我们将一个 $Q m_1.n_1$ 格式的数与一个 $Q m_2.n_2$ 格式的数相乘，其完整、精确的乘积将是 $Q (m_1+m_2).(n_1+n_2)$ 格式。

让我们考虑一个计算平方 $y = x^2$ 的例子，其中 $x$ 是一个 $Q m.n$ 格式的数 [@problem_id:3641281]。
- 输入 $x$ 的格式为 $Q m.n$，其底层整数表示 $X$ 是一个 $b = m+n+1$ 位的[补码](@entry_id:756269)整数。
- 乘积 $y = x^2 = (X \cdot 2^{-n})^2 = X^2 \cdot 2^{-2n}$。
- 为了无损地表示这个结果，新的小数位数 $n'$ 必须是 $2n$。
- 底层整数的乘积 $Y = X^2$。一个 $b$ 位整数的平方最多需要 $2b$ 位来存储。因此，结果寄存器需要有 $2b = 2(m+n+1)$ 位的宽度。
- 新格式 $Q m'.n'$ 的总位宽为 $b' = m'+n'+1$。为了避免[溢出](@entry_id:172355)，我们设置 $b' = 2b$。
- 我们可以求解 $m'$：
  $$ m' + n' + 1 = 2(m+n+1) $$
  $$ m' + 2n + 1 = 2m + 2n + 2 $$
  $$ m' = 2m + 1 $$
这意味着，为了确保平方运算在所有情况下都不会[溢出](@entry_id:172355)，结果的整数部分需要 $2m+1$ 位。这比简单地将位数加倍 ($2m$) 多出一位。这个额外的位被称为**保护位 (guard bit)**。为什么需要它？考虑最负的输入值 $x = -2^m$。它的平方是 $y = (-2^m)^2 = 2^{2m}$。这是一个正数。一个只有 $2m$ 个整数位的 Q 格式，其最大值是 $2^{2m} - 2^{-n'}$，它小于 $2^{2m}$。因此，若没有那个额外的保护位，对最负值的平方操作将会[溢出](@entry_id:172355)。

在实际系统中，我们通常没有无限的位宽。因此，在乘法之后，这个 $2b$ 位长的精确结果必须被**截断 (truncate)** 或**舍入 (round)** 回到目标格式（例如，原始的 $b$ 位格式），这个过程必然会引入**[量化误差](@entry_id:196306) (quantization error)**。

### [量化误差](@entry_id:196306)与舍入

只要我们将一个高精度的[数值表示](@entry_id:138287)为一个低精度的数值，[量化误差](@entry_id:196306)就不可避免。量化误差 $\epsilon$ 定义为量化后的值 $Q(X)$ 与原始值 $X$ 之差：$\epsilon = Q(X) - X$。误差的特性严重依赖于所使用的[舍入模式](@entry_id:168744)。

#### [舍入模式](@entry_id:168744)

有多种[舍入模式](@entry_id:168744)，每种模式都有其独特的统计特性，特别是**偏差 (bias)**，即误差的[期望值](@entry_id:153208) $\mathbb{E}[\epsilon]$ [@problem_id:3641323]。

- **向零舍入 (Round toward zero / Truncation)**：简单地丢弃多余的小数位。对于正数，这相当于向下取整（floor）；对于负数，这相当于向上取整（ceiling）。这种模式实现简单，但会引入与[信号相关](@entry_id:274796)的偏差。对于正数，[误差范围](@entry_id:169950)是 $(-\Delta, 0]$，期望为 $-\Delta/2$。对于负数，[误差范围](@entry_id:169950)是 $[0, \Delta)$，期望为 $+\Delta/2$。如果输入信号的[概率分布](@entry_id:146404)关于零对称，那么总体的平均偏差可能为零，但这种误差的信号依赖性在某些反馈系统中可能导致问题 [@problem_id:3641248]。

- **向负无穷舍入 (Round toward negative infinity / Floor)**：总是向下舍入到最接近的可表示值。这种模式会引入一个持续的负偏差。[误差范围](@entry_id:169950)是 $(-\Delta, 0]$，其期望为 $\mathbb{E}[\epsilon] = -\Delta/2$ [@problem_id:3641323]。

- **向最近邻舍入 (Round to nearest)**：舍入到最近的可表示值。当一个数恰好位于两个可表示值的中间时，需要一个决胜规则 (tie-breaking rule)。一个常见的规则是**[向偶数舍入](@entry_id:634629) (ties to even)**，这意味着如果出现平局，则舍入到那个 LSB 为 0 的值。这种模式在统计上是最优的，因为它能最小化[均方误差](@entry_id:175403)，并且对于大多数对称[分布](@entry_id:182848)的输入信号，其期望偏差为零 [@problem_id:3641323]。因此，它是高质量 DSP 系统中的首选舍入策略。

#### [量化误差](@entry_id:196306)的统计模型

在系统级分析中，逐个跟踪每个量化误差是不切实际的。取而代之，我们通常使用一个[统计模型](@entry_id:165873)来描述其行为。最著名的模型是将量化误差建模为**加性白[高斯噪声](@entry_id:260752) (Additive White Gaussian Noise, [AWGN](@entry_id:269320))** [@problem_id:3641248]。

该模型假设量化误差 $e[k]$ 是一个[随机过程](@entry_id:159502)，具有以下属性：
1.  **加性**：误差被视为直接加到原始信号上。
2.  **零均值**：$\mathbb{E}[e[k]] = 0$。这要求使用无偏的[舍入模式](@entry_id:168744)，如向最近邻舍入。
3.  **[白噪声](@entry_id:145248)**：误差序列在时间上是不相关的，其功率谱是平坦的。
4.  **与信号无关**：误差过程与原始信号过程是统计独立的。
5.  **高斯分布**：误差的[概率分布](@entry_id:146404)是高斯的。

这个模型的成立依赖于几个关键条件：
- **高分辨率**：量化步长 $\Delta$ 相对于信号的动态范围非常小 (即 $n$ 很大)。
- **“繁忙”的输入**：输入信号在每个量化间隔内变化足够，使得误差可以被近似为在 $[-\Delta/2, \Delta/2]$ 上[均匀分布](@entry_id:194597)。一个[均匀分布](@entry_id:194597)的[随机变量](@entry_id:195330)，其[方差](@entry_id:200758)（即噪声功率）为 $\sigma_e^2 = \Delta^2 / 12$。
- **线性处理**：当多个独立的、近似[均匀分布](@entry_id:194597)的[量化误差](@entry_id:196306)在[线性系统](@entry_id:147850)中累加时，根据**中心极限定理**，它们的总和将趋向于高斯分布。

然而，在某些情况下，[AWGN](@entry_id:269320) 模型会失效 [@problem_id:3641248]：
- **截断/向下取整**：如前所述，这些[舍入模式](@entry_id:168744)引入了与[信号相关](@entry_id:274796)的偏差，违反了零均值和信号独立性假设。
- **递归结构 (IIR 滤波器)**：在诸如 $y[k] = Q(y[k-1] + x[k])$ 的[累加器](@entry_id:175215)中，前一步的量化误差 $e[k-1]$ 会被反馈并影响下一步的输入，导致误差序列 $e[k]$ 在时间上相关（不再是白噪声）。
- **[溢出](@entry_id:172355)**：特别是回绕式[溢出](@entry_id:172355)，会引入巨大的、脉冲性的、且完全依赖于信号的误差，这与 [AWGN](@entry_id:269320) 模型的小而随机的假设完全相悖。

### 系统性能、成本与高级技术

选择定点格式不仅仅是关于[数值表示](@entry_id:138287)的正确性，它还深刻地影响着系统的**性能**、**[功耗](@entry_id:264815)**和**成本**。

#### 精度与成本的权衡

增加位数可以提高精度，但这是有代价的。让我们以一个[音频处理](@entry_id:273289)系统为例，比较 16 位定点 (Q15) 和 32 位定点 (Q31) [@problem_id:3641238]。

- **动态范围 (SQNR)**：信号与量化噪声比 (Signal-to-Quantization-Noise Ratio, SQNR) 是衡量精度的常用指标。对于一个满幅[正弦波](@entry_id:274998)输入，理论上的最大 SQNR (dB) 可以用一个著名的经验法则来近似：
  $$ \text{SQNR}_{\text{dB}} \approx 6.02 \cdot b + 1.76 $$
  其中 $b$ 是总位数。这意味着每增加一个比特，SQNR 大约提高 $6$ dB。
  - 对于 Q15 ($b=16$): $\text{SQNR} \approx 6.02 \times 16 + 1.76 \approx 98$ dB。
  - 对于 Q31 ($b=32$): $\text{SQNR} \approx 6.02 \times 32 + 1.76 \approx 194$ dB。
  显然，32 位提供了远超 16 位的保真度。

- **内存成本**：内存占用与位宽成正比。处理 Q31 [数据流](@entry_id:748201)需要的内存是 Q15 的两倍。

- **计算成本**：如果一个 DSP 的原生乘法器是 16x16 位，那么执行一次 16x16 位的乘法累加 (MAC) 只需要一个周期。但是，要模拟一次 32x32 位的乘法，需要使用四次 16x16 位的乘法以及多次加法和移位操作才能合成完整的结果。这会导致计算吞吐量显著下降（大约为原来的 1/4）。

- **[功耗](@entry_id:264815)**：在 [CMOS](@entry_id:178661) 电路中，动态功耗与[开关电容](@entry_id:197049)和时钟频率成正比。更宽的数据通路（更大的 $b$）意味着更复杂的电路、更大的电容和更高的开关能量。一个简化的模型表明，每次操作的能量消耗 $E$ 与位宽 $b$ 的某个次幂成正比，即 $E \propto b^{\alpha}$ (其中 $\alpha$ 通常在 1 到 2 之间) [@problem_id:3641337]。例如，如果 $\alpha=2$，将数据通路从 16 位减少到 12 位，可以带来的功耗节省为：
  $$ S = 1 - \left(\frac{b_{new}}{b_{old}}\right)^{\alpha} = 1 - \left(\frac{12}{16}\right)^{2} = 1 - \left(\frac{3}{4}\right)^{2} = 1 - \frac{9}{16} = 0.4375 $$
  这意味着高达 43.75% 的动态功耗节省，这在移动和电池供电的设备中至关重要。

#### 硬件加速技术

为了克服[定点算术](@entry_id:170136)的一些性能瓶颈，研究人员开发了专门的硬件架构。

- **流水线加法器与进位保存**：在标准的**[行波进位加法器](@entry_id:177994) (Ripple-Carry Adder, CPA)** 中，进位信号必须从最低位 "ripple" 到最高位。这导致加法器的延迟与位宽 $b$ 成[线性关系](@entry_id:267880)，即 $O(b)$。对于宽位数的累加操作（如 MAC），这将成为严重的性能瓶颈 [@problem_id:3641264]。**进位保存加法器 (Carry-Save Adder, CSA)** 通过将进位“保存”在一个单独的向量中而不是立即传播它，从而解决了这个问题。一个 CSA 接收三个输入数，并立即（在一个[全加器](@entry_id:178839)的延迟内，即 $O(1)$）产生两个输出数（一个和向量与一个进[位向量](@entry_id:746852)），它们的和等于三个输入数的和。在 MAC 累加循环中，每一轮都可以使用 CSA 来合并累加值和新的乘积，而无需等待长长的进位链。只有在所有累加完成后，才需要一次 CPA 来将最终的和向量与进[位向量](@entry_id:746852)相加。这使得 MAC 操作的周期时间与位宽无关。

#### 处理高动态范围：[块浮点](@entry_id:199195)

当一个信号块（例如一个音频帧或一个变换块）内部同时包含非常大和非常小的值时，它的**动态范围** $R = \frac{\max|x_i|}{\min|x_i|}$ 会非常高。使用单一尺度的纯定点格式会面临一个两难的困境 [@problem_id:3641210]：
- 如果为了精确表示小数值而选择小的缩放因子（即大的 $n$），那么大数值可能会[溢出](@entry_id:172355)。
- 如果为了防止大数值[溢出](@entry_id:172355)而选择大的缩放因子（即小的 $n$），那么小数值可能会因为量化不足而被舍入为零。

**[块浮点](@entry_id:199195) (Block Floating-Point, BFP)** 是一种优雅的折衷方案。它为一整个[数据块](@entry_id:748187)分配一个**共享的指数 (shared exponent)**，同时块内的每个数据点拥有自己的**[尾数](@entry_id:176652) (mantissa)**。其工作流程如下：
1. 扫描整个数据块，找到[绝对值](@entry_id:147688)最大的元素 $x_{max}$。
2. 选择一个公共的缩放指数 $e$，使得 $x_{max}$ 在缩放后能够被轻松地容纳在[尾数](@entry_id:176652)的表示范围内。
3. 使用这个公共指数 $e$ 来缩放块中的所有元素。
4. 存储经过缩放的[尾数](@entry_id:176652)数组以及那个单一的共享指数 $e$。

通过这种方式，BFP 保证了块内的最大值不会[溢出](@entry_id:172355)。它的代价是，块内较小的值的有效精度会降低，因为它们被迫与最大值使用相同的缩放因子。相对于每个样本都有自己指数的全[浮点](@entry_id:749453)表示，BFP 在动态范围和硬件/存储成本之间提供了一个高效的中间地带。它在[雷达信号](@entry_id:190382)处理和某些音频编解码器等领域有广泛应用。