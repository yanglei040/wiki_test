{"hands_on_practices": [{"introduction": "为了真正掌握浮点数，我们必须超越将其视为一个黑箱。本练习将引导你直接操作浮点数的原始比特模式，仅使用整数和位运算来提取其指数部分。通过这个过程，你将对 IEEE 754 标准的内部结构——符号、指数和尾数——建立一个具体而深刻的理解，这是底层编程和性能优化的基础。[@problem_id:3678233]", "problem": "给定电气和电子工程师协会 (IEEE) 的浮点数算术标准 (IEEE $754$) 格式的二进制布局，请你设计并实现一种位级方法，用于从浮点数的原始位模式中提取其无偏指数 $e$，过程中不使用任何浮点指令或运算。请纯粹以整数和位运算的方式完成。\n\n使用的基本依据：\n- IEEE $754$ 单精度 ($32$位) 格式使用 $1$ 个符号位、$8$ 个指数位和 $23$ 个小数位。设 $E$ 表示解释为无符号整数的编码指数场。指数偏移量为 $127$。对于规格化值（其中 $1 \\le E \\le 254$），无偏指数为 $e = E - 127$。对于 $E = 0$（非规格化数或零），在数值定义中使用的有效指数为 $e = 1 - 127 = -126$。对于 $E = 255$（全为1），该值是无穷大或非数值 (NaN)，其无偏指数不是有限的。\n- IEEE $754$ 双精度 ($64$位) 格式使用 $1$ 个符号位、$11$ 个指数位和 $52$ 个小数位。设 $E$ 表示解释为无符号整数的编码指数场。指数偏移量为 $1023$。对于规格化值（其中 $1 \\le E \\le 2046$），无偏指数为 $e = E - 1023$。对于 $E = 0$（非规格化数或零），在数值定义中使用的有效指数为 $e = 1 - 1023 = -1022$。对于 $E = 2047$（全为1），该值是无穷大或非数值 (NaN)，其无偏指数不是有限的。\n\n任务：\n- 设计纯整数的位技巧，从原始位模式中提取 $E$，并按照上述规定将其映射到 $e$，过程中不执行任何对 float 或 double 类型值的操作。你必须忽略符号场和小数场，除非是为了检测指数场是否全为零或全为一。对于指数场全为一的“非有限”情况，返回一个哨兵整数 $S = 2147483647$ 来表示未定义的无偏指数。对于 $E = 0$（包括非规格化数和零），返回如上定义的有效指数 $e = 1 - \\text{bias}$。\n\n约束：\n- 仅使用整数类型和位运算来分离和解释指数场。\n- 不要对浮点类型进行任何算术运算，也不要将整数强制转换为浮点类型。\n- 将所有输入视为编码了 IEEE $754$ 位模式的原始无符号整数。\n\n测试套件：\n将你提取方法应用于以下原始位模式，并严格按照给定顺序。对每一个模式，根据上述规则计算并返回整数 $e$。\n\n单精度 ($32$位) 输入，以十六进制常量形式给出：\n- $0x3F800000$  (表示 $+1.0$)\n- $0x3F400000$  (表示 $+0.75$)\n- $0x00000001$  (最小正非规格化数)\n- $0x00000000$  ($+0.0$)\n- $0x7F800000$  ($+∞$)\n- $0x7FC00001$  (一个静默 NaN)\n- $0x7F7FFFFF$  (最大有限正数)\n- $0x00800000$  (最小正规格化数)\n- $0xBF800000$  (表示 $-1.0$)\n\n双精度 ($64$位) 输入，以十六进制常量形式给出：\n- $0x3FF0000000000000$  (表示 $+1.0$)\n- $0xC000000000000000$  (表示 $-2.0$)\n- $0x0000000000000001$  (最小正非规格化数)\n- $0x8000000000000000$  ($-0.0$)\n- $0x7FF0000000000000$  ($+∞$)\n- $0x7FF8000000000001$  (一个静默 NaN)\n- $0x7FEFFFFFFFFFFFFF$  (最大有限正数)\n- $0x0010000000000000$  (最小正规格化数)\n\n要求的最终输出格式：\n- 你的程序必须生成单行输出，其中包含所有结果，形式为一个由逗号分隔的整数列表，并用方括号括起来，不含空格。结果必须按上述顺序列出：首先是所有 $9$ 个单精度结果（按给定顺序），然后是所有 $8$ 个双精度结果（按给定顺序）。例如，输出应类似于 $[r_1,r_2,\\dots,r_{17}]$，其中每个 $r_i$ 是一个整数。\n\n你的程序必须是一个完整、可运行的程序，仅使用整数和位运算来计算这些值，并以所描述的精确格式打印结果。不涉及用户输入。输出为纯整数；不适用任何物理单位、角度或百分比。", "solution": "仅使用整数和位运算从 IEEE $754$ 浮点数中提取无偏指数的问题，是理解底层数据表示的一个经典练习。解决方案依赖于该标准中指定的浮点数格式的固定位宽布局。\n\n基本原理是使用位运算来分离指数场，将其值解释为无符号整数，然后应用 IEEE $754$ 标准的规则将这个编码后的指数转换为真实的、无偏的指数值。\n\n设 $b$ 为浮点数的原始位模式，表示为一个无符号整数。设 $E$ 为指数场解释为无符号整数时的值，设 $e$ 为最终的无偏指数。\n\n**单精度 ($32$位) 格式的方法**\n\nIEEE $754$ 单精度格式按如下方式分配 $32$ 位：$1$ 个符号位、$8$ 个指数位和 $23$ 个小数位。指数偏移量为 $127$。\n\n1.  **分离编码后的指数 ($E$)**：这 $8$ 个指数位位于第 $23$ 位到第 $30$ 位。要从一个 $32$ 位无符号整数 $b$ 中提取这些位，我们执行两个操作：\n    *   首先，按位右移 $23$ 位 ($b \\gg 23$)。此操作将指数位移动到整数的最低有效 $8$ 位位置。\n    *   其次，与一个掩码进行按位与运算以分离这 $8$ 位。掩码是 $2^8 - 1 = 255$，其十六进制表示为 $0x\\text{FF}$。\n    完整的操作是：$E = (b \\gg 23) \\land 255$。\n\n2.  **计算无偏指数 ($e$)**：$E$ 的值决定了数的类别（规格化数、非规格化数、零、无穷大或 NaN）以及计算 $e$ 的规则。\n    *   **特殊情况 ($E = 255$)：** 如果指数场全为一，$E = 255$。这种模式表示无穷大或非数值 (NaN)。对于这些情况，问题指定返回一个哨兵整数值 $S = 2147483647$。\n    *   **特殊情况 ($E = 0$)：** 如果指数场全为零，$E = 0$。这种模式表示非规格化数或零。对于这些值，标准定义了一个用于计算的有效指数。这个有效指数是 $e = 1 - \\text{bias} = 1 - 127 = -126$。\n    *   **规格化情况 ($1 \\le E \\le 254$)：** 对于所有其他 $E$ 值，该数为规格化值。无偏指数通过从编码指数中减去偏移量来计算：$e = E - \\text{bias} = E - 127$。\n\n**双精度 ($64$位) 格式的方法**\n\nIEEE $754$ 双精度格式按如下方式分配 $64$ 位：$1$ 个符号位、$11$ 个指数位和 $52$ 个小数位。指数偏移量为 $1023$。\n\n1.  **分离编码后的指数 ($E$)**：这 $11$ 个指数位位于第 $52$ 位到第 $62$ 位。要从一个 $64$ 位无符号整数 $b$ 中提取这些位：\n    *   首先，按位右移 $52$ 位 ($b \\gg 52$)。\n    *   其次，与一个 $11$ 位的掩码进行按位与运算。掩码是 $2^{11} - 1 = 2047$，其十六进制表示为 $0x\\text{7FF}$。\n    完整的操作是：$E = (b \\gg 52) \\land 2047$。\n\n2.  **计算无偏指数 ($e$)**：规则与单精度情况类似，但参数不同。\n    *   **特殊情况 ($E = 2047$)：** 如果 $E = 2047$（所有 $11$ 位都为一），该值为无穷大或 NaN。返回哨兵值 $S = 2147483647$。\n    *   **特殊情况 ($E = 0$)：** 如果 $E = 0$（所有 $11$ 位都为零），该值为非规格化数或零。有效指数为 $e = 1 - \\text{bias} = 1 - 1023 = -1022$。\n    *   **规格化情况 ($1 \\le E \\le 2046$)：** 对于所有其他 $E$ 值，该数为规格化数。无偏指数为 $e = E - \\text{bias} = E - 1023$。\n\n这种纯位运算的方法能够严格遵守问题约束，在不使用任何浮点指令或数据类型的情况下，正确地提取和解释指数场。", "answer": "```c\n#include", "id": "3678233"}, {"introduction": "在掌握了浮点数的比特级结构之后，下一个挑战是理解它们是如何在实数线上排序的。本练习揭示了一个惊人的特性：对于正数，浮点数的数值顺序与其比特模式的整数顺序完全一致。通过实现一个计算相邻浮点数的函数，你将揭开标准库中 `nextafter` 这类函数的神秘面纱，并深化对浮点数离散性的认识。[@problem_id:3678203]", "problem": "考虑电气和电子工程师协会（IEEE）754 binary64（双精度）浮点格式。一个 binary64 数共有 $64$ 位，划分为：一个符号位 $s$、一个 $11$ 位的指数场 $E$（使用偏置值 $B = 1023$ 进行编码），以及一个 $52$ 位的分数（也称为有效数或尾数）场 $F$。其编码的实数值由以下经过充分检验的事实确定：\n- 对于 $0 < E < 2047$（规格化数），其值为\n$$\n(-1)^s \\cdot \\left(1 + \\frac{F}{2^{52}}\\right) \\cdot 2^{E - B}.\n$$\n- 对于 $E = 0$ 且 $F \\neq 0$（非规格化数），其值为\n$$\n(-1)^s \\cdot \\left(\\frac{F}{2^{52}}\\right) \\cdot 2^{1 - B}.\n$$\n- 对于 $E = 2047$ 且 $F = 0$，其值为 $\\pm \\infty$，具体取决于 $s$。\n- 对于 $E = 2047$ 且 $F \\neq 0$，其值为非数值（NaN），它与所有实数都是无序的。\n\n我们将一个可表示实数 $x$ 的直接后继 $\\operatorname{succ}(x)$ 定义为满足 $y > x$ 的最小可表示实数 $y$，将其直接前驱 $\\operatorname{pred}(x)$ 定义为满足 $y < x$ 的最大可表示实数 $y$。对于 NaN（无序）值，$\\operatorname{succ}$ 和 $\\operatorname{pred}$ 在实数顺序中均未定义；在这种情况下，将后继和前驱视为相同的 NaN 位模式（即，保持不变）。\n\n从上述 IEEE 754 编码的核心定义出发，推导在 $64$ 位位模式上计算 $\\operatorname{succ}(x)$ 和 $\\operatorname{pred}(x)$ 所需的最小整数操作，要求能正确处理所有输入，包括带符号的零和无穷大。您的推导必须明确地从实数排序和编码的符号-数值结构出发，论证整数步长的方向，不得使用任何未从给定定义中推导出的快捷公式。\n\n然后，实现一个程序，该程序：\n1. 将给定的双精度数 $x$ 重新解释为一个无符号 $64$ 位整数 $u$，该整数表示其原始位模式。\n2. 通过对 $u$ 在正确方向上进行单次整数自增或自减来计算 $\\operatorname{pred}(x)$ 和 $\\operatorname{succ}(x)$ 的原始位模式，并从第一性原理出发论证以下边界条件：\n   - 如果 $x$ 是 NaN，则两个输出都是保持不变的 NaN 位模式。\n   - 如果 $x = +\\infty$，则 $\\operatorname{succ}(x) = +\\infty$，$\\operatorname{pred}(x)$ 等于最大的有限正数。\n   - 如果 $x = -\\infty$，则 $\\operatorname{pred}(x) = -\\infty$，$\\operatorname{succ}(x)$ 等于最大的有限负数。\n   - 如果 $x = 0$（$+0$ 或 $-0$），则 $\\operatorname{succ}(x)$ 等于最小的正非规格化数，其原始位模式为 $\\mathtt{0x0000000000000001}$，$\\operatorname{pred}(x)$ 等于（绝对值）最小的负非规格化数，其原始位模式为 $\\mathtt{0x8000000000000001}$。\n3. 对于每个测试用例，输出由 $\\operatorname{pred}(x)$ 和 $\\operatorname{succ}(x)$ 的原始位模式组成的数对，表示为无符号整数。\n\n分析在 $E=0$ 的非规格化边界处的行为。特别地，解释在以下情况下的转换：\n- 最小的正非规格化值 $x = 2^{-1074}$。\n- 最大的正非规格化值 $x = 2^{-1022} - 2^{-1074}$。\n- 最小的正规格化值 $x = 2^{-1022}$。\n\n通过严格基于编码结构进行分析，确保科学真实性，展示为什么对正确定向的原始位模式进行单步整数操作会对应于实数排序中的直接前驱或后继。\n\n测试套件：\n请精确使用以下 $11$ 个测试用例，每个用例均通过其 $64$ 位十六进制字面量形式的原始位模式指定：\n1. $\\mathtt{0x0000000000000000}$ (正零 $+0$)。\n2. $\\mathtt{0x8000000000000000}$ (负零 $-0$)。\n3. $\\mathtt{0x0000000000000001}$ (最小的正非规格化数 $x = 2^{-1074}$)。\n4. $\\mathtt{0x000FFFFFFFFFFFFF}$ (最大的正非规格化数 $x = 2^{-1022} - 2^{-1074}$)。\n5. $\\mathtt{0x0010000000000000}$ (最小的正规格化数 $x = 2^{-1022}$)。\n6. $\\mathtt{0x3FF0000000000000}$ ($x = 1$)。\n7. $\\mathtt{0xBFF0000000000000}$ ($x = -1$)。\n8. $\\mathtt{0x7FEFFFFFFFFFFFFF}$ (最大的有限正数)。\n9. $\\mathtt{0xFFF0000000000000}$ (负无穷大)。\n10. $\\mathtt{0x7FF0000000000000}$ (正无穷大)。\n11. $\\mathtt{0x7FF8000000000000}$ (一个静默 NaN)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按照上述测试套件的顺序，为每个测试用例包含前驱的原始位模式和后继的原始位模式，两者均以无符号十进制整数形式打印。例如，输出格式为\n$$\n[\\text{前驱}_1,\\text{后继}_1,\\text{前驱}_2,\\text{后继}_2,\\dots,\\text{前驱}_{11},\\text{后继}_{11}]\n$$\n其中每个 $\\text{前驱}_i$ 和 $\\text{后继}_i$ 都是一个表示 $64$ 位位模式的无符号整数。", "solution": "该问题要求推导一种方法，通过对其 $64$ 位二进制表示执行整数操作，来找到双精度浮点数 $x$ 的直接后继 $\\operatorname{succ}(x)$ 和直接前驱 $\\operatorname{pred}(x)$。推导必须基于所提供的 IEEE 754 定义。\n\n一个 `binary64` 数由一个 $64$ 位模式表示，我们可以将其解释为一个 $64$ 位无符号整数 $u$。该整数由三个场组成：一个 $1$ 位的符号 $s$，一个 $11$ 位的偏置指数 $E$，以及一个 $52$ 位的分数 $F$。其整数表示为 $u = s \\cdot 2^{63} + E \\cdot 2^{52} + F$。\n\n推导的核心在于分析实数值 $x$ 的排序与其表示 $u$ 的整数排序之间的关系。\n\n**1. 正数（$s=0$）的分析**\n\n对于正数，符号位 $s$ 为 $0$。其整数表示为 $u = E \\cdot 2^{52} + F$。\n数值 $x$ 的值由 $E$ 和 $F$ 决定。\n- 如果 $x$ 是一个规格化数（$0 < E < 2047$），其值为 $x = (1 + F/2^{52}) \\cdot 2^{E - 1023}$。\n- 如果 $x$ 是一个非规格化数（$E = 0, F \\neq 0$），其值为 $x = (F/2^{52}) \\cdot 2^{1 - 1023}$。\n\n在这两种情况下，对于固定的指数 $E$，$x$ 的值是分数 $F$ 的单调递增函数。$F$ 增加 $1$ 会使 $x$ 增加一个很小的值（最后一位的单位，或 ULP）。类似地，随着指数 $E$ 的增加，$x$ 的值会显著增加。\n\n正数的整数表示 $u = E \\cdot 2^{52} + F$ 也是 $E$ 和 $F$ 的单调递增函数。$F$ 的增加直接导致 $u$ 的增加。$E$ 的增加导致 $u$ 的更大幅度增加。因此，对于任意两个可表示的正数 $x_1$ 和 $x_2$，其整数表示分别为 $u_1$ 和 $u_2$，排序得以保留：$x_1 > x_2 \\iff u_1 > u_2$。\n\n这种直接对应关系意味着，在实数域中寻找直接后继或前驱等同于在整数域中寻找直接后继或前驱。\n- 要找到 $\\operatorname{succ}(x)$，即大于 $x$ 的最小可表示数，我们必须找到大于 $u$ 的最小整数表示。这正是 $u+1$。\n- 要找到 $\\operatorname{pred}(x)$，即小于 $x$ 的最大可表示数，我们必须找到小于 $u$ 的最大整数表示。这正是 $u-1$。\n\n**2. 负数（$s=1$）的分析**\n\n对于负数，符号位 $s$ 为 $1$。$x$ 的值是其绝对值的负数，即 $x = -|x|$。让我们考虑两个负数 $x_1$ 和 $x_2$。实数排序为 $x_1 > x_2 \\iff -|x_1| > -|x_2| \\iff |x_1| < |x_2|$。负数的排序与其绝对值的排序相反。\n\n负数的整数表示 $u = 1 \\cdot 2^{63} + E \\cdot 2^{52} + F$ 是其绝对值分量 $E$ 和 $F$ 的增函数。一个更大的绝对值 $|x|$ 对应于一个更大的 $E$ 或 $F$ 值，这又对应于一个更大的整数表示 $u$。\n因此，对于任意两个可表示的负数 $x_1$ 和 $x_2$，其整数表示分别为 $u_1$ 和 $u_2$：\n$x_1 > x_2 \\iff |x_1| < |x_2| \\iff u_1 < u_2$。\n\n这种逆对应关系意味着，在实数域中寻找后继或前驱等同于在整数域中向相反方向移动。\n- 要找到 $\\operatorname{succ}(x)$，即一个更大（负得更少）的实数值，我们需要一个更小的绝对值，这对应于一个更小的整数表示。因此，我们计算 $u-1$。\n- 要找到 $\\operatorname{pred}(x)$，即一个更小（负得更多）的实数值，我们需要一个更大的绝对值，这对应于一个更大的整数表示。因此，我们计算 $u+1$。\n\n**3. 边界和特殊情况分析**\n\n上面推导的简单整数算术必须在数字系统的边界处进行检验。\n\n- **零（$+0$ 和 $-0$）**：\n  - 对于 $x = +0$，其表示为 $u = \\mathtt{0x0000000000000000}$。\n    - $\\operatorname{succ}(+0)$ 应该是最小的正数。我们对正数的规则给出 $u+1 = 1$，这是最小正非规格化数 $2^{-1074}$ 的正确表示。\n    - $\\operatorname{pred}(+0)$ 应该是恰好小于 $0$ 的数，也就是最大的负数（最接近零），即绝对值最小的负数。其表示为 $\\mathtt{0x8000000000000001}$。我们的规则 $u-1$ 会得到 $\\mathtt{0xFFFFFFFFFFFFFFFF}$（由于无符号回绕），这是一个 NaN。这是一个必须明确处理的特定边界情况。\n  - 对于 $x = -0$，其表示为 $u = \\mathtt{0x8000000000000000}$。\n    - $\\operatorname{pred}(-0)$ 应该是绝对值最小的负数。我们对负数的规则给出 $u+1 = \\mathtt{0x8000000000000001}$，这是正确的。\n    - $\\operatorname{succ}(-0)$ 应该是恰好大于 $0$ 的数，即最小的正数。其表示为 $1$。我们的规则 $u-1$ 会得到 $\\mathtt{0x7FFFFFFFFFFFFFFF}$，这是一个 NaN。这是零点处的另一个特定边界情况。\n  - 问题定义了跨越符号边界的 $\\operatorname{pred}(0)$ 和 $\\operatorname{succ}(0)$。因此，对于 $x=+0$ 和 $x=-0$，$\\operatorname{succ}(x)$ 都是最小的正非规格化数（$\\mathtt{0x...1}$），而 $\\operatorname{pred}(x)$ 都是绝对值最小的负非规格化数（$\\mathtt{0x8...1}$）。\n\n- **无穷大（$+\\infty$ 和 $-\\infty$）**：\n  - 对于 $x = +\\infty$，$u = \\mathtt{0x7FF0000000000000}$。它是最大的可表示实数值。\n    - $\\operatorname{succ}(+\\infty) = +\\infty$。其表示保持不变。我们的规则 $u+1$ 会产生一个 NaN，所以这必须作为特殊情况处理。\n    - $\\operatorname{pred}(+\\infty)$ 是最大的有限正数。其表示为 $\\mathtt{0x7FEFFFFFFFFFFFFF}$，这恰好是 $u-1$。对正数前驱的一般规则在这里适用。\n  - 对于 $x = -\\infty$，$u = \\mathtt{0xFFF0000000000000}$。它是最小的可表示实数值。\n    - $\\operatorname{pred}(-\\infty) = -\\infty$。其表示保持不变。我们的规则 $u+1$ 会产生一个 NaN，所以这是一个特殊情况。\n    - $\\operatorname{succ}(-\\infty)$ 是绝对值最大的有限负数。其表示为 $\\mathtt{0xFFEFFFFFFFFFFFFF}$，即 $u-1$。这与负数后继的一般规则（计算 $u-1$）相符。\n\n- **非数值（NaN）**：\n  - NaN 值具有 $E=2047$ 和 $F \\neq 0$ 的特性。它们是无序的。问题指出 $\\operatorname{succ}(\\text{NaN})$ 和 $\\operatorname{pred}(\\text{NaN})$ 应产生相同的 NaN 位模式。这需要进行显式检查。\n\n**4. 非规格化数与规格化数边界的分析**\n\n问题要求分析跨越非规格化范围的转换。\n- **最小的正非规格化数**：$x = 2^{-1074}$，其 $u = \\mathtt{0x0000000000000001}$。\n  - $\\operatorname{pred}(x)$ 对应于 $u-1=0$，即 $+0$。正确。\n  - $\\operatorname{succ}(x)$ 对应于 $u+1=2$，表示 $2 \\cdot 2^{-1074}$。正确。\n- **最大的正非规格化数**：$x = 2^{-1022} - 2^{-1074}$，其 $u = \\mathtt{0x000FFFFFFFFFFFFF}$。\n  - $\\operatorname{pred}(x)$ 对应于 $u-1 = \\mathtt{0x000FFFFFFFFFFFFE}$，即第二大的非规格化数。正确。\n  - $\\operatorname{succ}(x)$ 对应于 $u+1 = \\mathtt{0x0010000000000000}$。此表示具有 $E=1, F=0$，是最小的正规格化数 $2^{-1022}$。这展示了通过整数自增操作实现的无缝过渡。\n- **最小的正规格化数**：$x = 2^{-1022}$，其 $u = \\mathtt{0x0010000000000000}$。\n  - $\\operatorname{pred}(x)$ 对应于 $u-1 = \\mathtt{0x000FFFFFFFFFFFFF}$，即最大的非规格化数。正确。\n  - $\\operatorname{succ}(x)$ 对应于 $u+1 = \\mathtt{0x0010000000000001}$，即下一个规格化数。正确。\n\n此分析证实了简单的整数算术能正确处理非规格化数和规格化数之间的关键边界，这是 IEEE 754 标准的一个关键特性。\n\n**算法总结**\n\n基于此推导，以下算法可找到前驱和后继的表示。\n设 $u$ 为输入数 $x$ 的 $64$ 位无符号整数表示。\n1.  如果 $x$ 是 NaN（即 $(u \\gg 52 \\text{ & } \\mathtt{0x7FF}) == \\mathtt{0x7FF}$ 且 $(u \\text{ & } (\\mathtt{2^{52}-1})) \\neq 0$），则后继和前驱的表示均为 $u$。\n2.  如果 $u = \\mathtt{0x0000000000000000}$（对于 $+0$），则后继为 $1$，前驱为 $\\mathtt{0x8000000000000001}$。\n3.  如果 $u = \\mathtt{0x8000000000000000}$（对于 $-0$），则后继为 $1$，前驱为 $\\mathtt{0x8000000000000001}$。\n4.  如果 $u = \\mathtt{0x7FF0000000000000}$（对于 $+\\infty$），则后继为 $u$，前驱为 $u-1$。\n5.  如果 $u = \\mathtt{0xFFF0000000000000}$（对于 $-\\infty$），则后继为 $u-1$，前驱为 $u$。\n6.  对于任何其他正数（$u \\gg 63 == 0$），后继为 $u+1$，前驱为 $u-1$。\n7.  对于任何其他负数（$u \\gg 63 == 1$），后继为 $u-1$，前驱为 $u+1$。\n这种基于情况的逻辑正确地实现了推导出的原理。合并零的情况可以简化实现。", "answer": "```c\n#include", "id": "3678203"}, {"introduction": "理论知识的价值最终体现在解决实际问题上。这个最终练习将我们带入一个具体的应用场景：数据库连接操作。它清晰地展示了单精度和双精度之间看似微小的差异，是如何在实践中导致重大的逻辑错误的。通过分析这个问题，你将体会到在格式转换和数值比较中，谨慎处理精度为何至关重要。[@problem_id:3678173]", "problem": "考虑一个系统，该系统在两种不同的实现选择下对浮点键执行等值连接。这些键符合电气和电子工程师协会（IEEE）754二进制浮点标准，特别是binary32（单精度）和binary64（双精度）。该实现在格式之间转换时使用“舍入到最近，偶数优先”模式。\n\n定义了两个表如下。表 $\\mathcal{A}$ 以binary64格式存储其键；表 $\\mathcal{B}$ 以binary32格式存储其键。令\n$$\nS = 1 + 100 \\cdot 2^{-23}.\n$$\n表 $\\mathcal{A}$ 有三行，其键为\n$$\na_1 = S - 0.4 \\cdot 2^{-23}, \\quad a_2 = S + 0.4 \\cdot 2^{-23}, \\quad a_3 = 2.0,\n$$\n表 $\\mathcal{B}$ 有两行，其键为\n$$\nb_1 = S, \\quad b_2 = 2.0.\n$$\n\n该系统考虑两种等值连接策略：\n1. 策略D：将表 $\\mathcal{B}$ 的binary32键转换为binary64，并在binary64下进行相等性比较。\n2. 策略S：将表 $\\mathcal{A}$ 的binary64键转换为binary32，并在binary32下进行相等性比较。\n\n仅使用IEEE 754格式的基本定义和舍入行为，通过计算策略S产生而策略D未产生的等值连接对的数量，来确定策略S和策略D在正确性上的差异。将最终答案表示为一个等于此类不正确配对总数的实数。最终结果无需进行舍入。", "solution": "问题陈述经过严格评估并被认为是有效的。它在科学上基于IEEE 754浮点算术标准，提法恰当，提供了所有必要信息，并以客观、正式的语言表达。不存在矛盾、歧义或事实错误。\n\n任务是确定由策略S产生但不由策略D产生的等值连接对的数量。一个等值连接对的形式为 $(a_i, b_j)$，其中 $a_i$ 是来自表 $\\mathcal{A}$ 的一个键，$b_j$ 是来自表 $\\mathcal{B}$ 的一个键。\n\n首先，我们来分析指定的IEEE 754格式的属性。\n- **binary32（单精度）：** 此格式使用1个符号位，8个指数位，以及23位用于有效数的小数部分。这意味着总精度为24位（包括隐含的前导位）。对于范围在 $[1.0, 2.0)$ 内、指数为0的数字，尾数的最低有效位的值，即最后一位的单位（ULP），是 $2^{-23}$。\n- **binary64（双精度）：** 此格式使用1个符号位，11个指数位，以及52位用于有效数的小数部分，总精度为53位。\n\n舍入模式指定为“舍入到最近，偶数优先”。一个实数被舍入到最接近的可表示浮点值。如果它恰好在两个可表示值的正中间，它将被舍入到尾数最低有效位为0的那个值。\n\n给定的键如下：\n- 表 $\\mathcal{A}$ (binary64): $a_1 = S - 0.4 \\cdot 2^{-23}$, $a_2 = S + 0.4 \\cdot 2^{-23}$, $a_3 = 2.0$。\n- 表 $\\mathcal{B}$ (binary32): $b_1 = S$, $b_2 = 2.0$, 其中 $S = 1 + 100 \\cdot 2^{-23}$。\n\n我们来检查键 $b_1 = S$ 的表示。\n$S = 1 + 100 \\cdot 2^{-23}$。整数 $100$ 的二进制是 $64 + 32 + 4$，即 $2^6 + 2^5 + 2^2$。所以，$S = 1 + (2^6 + 2^5 + 2^2) \\cdot 2^{-23} = 1 + 2^{-17} + 2^{-18} + 2^{-21}$。由于 $S$ 的小数部分是2的负幂之和，其中最大的分母是 $2^{21}$，并且 $21 \\le 23$，因此值 $S$ 在binary32格式中是精确可表示的。键 $b_2 = 2.0$ 在binary32中也是精确可表示的。\n\n现在，我们来评估这两种连接策略。\n\n**策略D：将binary32转换为binary64，然后比较。**\n在此策略中，如果 $a_i = \\text{cast}_{\\text{binary64}}(b_j)$，则形成一个配对 $(a_i, b_j)$。从较低精度格式（binary32）转换到较高精度格式（binary64）始终是一个精确操作；没有信息丢失。因此，$\\text{cast}_{\\text{binary64}}(b_j)$ 就是 $b_j$ 的精确值。\n我们测试 $3 \\times 2 = 6$ 种可能的配对：\n1.  与 $b_1 = S$ 的比较：\n    - $a_1 = S - 0.4 \\cdot 2^{-23} \\neq S$。不形成配对 $(a_1, b_1)$。\n    - $a_2 = S + 0.4 \\cdot 2^{-23} \\neq S$。不形成配对 $(a_2, b_1)$。\n    - $a_3 = 2.0 \\neq S$。不形成配对 $(a_3, b_1)$。\n2.  与 $b_2 = 2.0$ 的比较：\n    - $a_1 = 1 + 99.6 \\cdot 2^{-23} \\neq 2.0$。不形成配对 $(a_1, b_2)$。\n    - $a_2 = 1 + 100.4 \\cdot 2^{-23} \\neq 2.0$。不形成配对 $(a_2, b_2)$。\n    - $a_3 = 2.0$。值相等。形成配对 $(a_3, b_2)$。\n\n策略D恰好产生一个配对：$(a_3, b_2)$。\n\n**策略S：将binary64转换为binary32，然后比较。**\n在此策略中，如果 $\\text{cast}_{\\text{binary32}}(a_i) = b_j$，则形成一个配对 $(a_i, b_j)$。从binary64转换为binary32涉及舍入，因为这是向较低精度格式的转换。对于一个值 $x$，$\\text{cast}_{\\text{binary32}}(x)$ 将是最接近的可表示binary32值。如果一个值 $v$ 与其相邻可表示值 $v_r$ 之间的距离 $|v-v_r|$ 小于ULP的一半，则 $v$ 会被舍入到 $v_r$。对于范围在 $[1.0, 2.0)$ 内的数，ULP为 $2^{-23}$。因此，舍入边界距离一个可表示数的距离为 $0.5 \\cdot 2^{-23}$。\n\n1.  与 $b_1 = S$ 的比较：\n    - 考虑 $a_1 = S - 0.4 \\cdot 2^{-23}$。值 $S$ 在binary32中是可表示的。$a_1$ 和 $S$ 之间的距离是 $|(S - 0.4 \\cdot 2^{-23}) - S| = 0.4 \\cdot 2^{-23}$。这个距离小于舍入阈值 $0.5 \\cdot 2^{-23}$。因此，$a_1$ 舍入为 $S$。$\\text{cast}_{\\text{binary32}}(a_1) = S = b_1$。形成配对 $(a_1, b_1)$。\n    - 考虑 $a_2 = S + 0.4 \\cdot 2^{-23}$。$a_2$ 和 $S$ 之间的距离是 $|(S + 0.4 \\cdot 2^{-23}) - S| = 0.4 \\cdot 2^{-23}$。这也小于 $0.5 \\cdot 2^{-23}$。因此，$a_2$ 也舍入为 $S$。$\\text{cast}_{\\text{binary32}}(a_2) = S = b_1$。形成配对 $(a_2, b_1)$。\n    - 考虑 $a_3 = 2.0$。值 $2.0$ 在binary32中是精确可表示的，所以 $\\text{cast}_{\\text{binary32}}(a_3) = 2.0$。由于 $2.0 \\neq S$，不形成配对 $(a_3, b_1)$。\n\n2.  与 $b_2 = 2.0$ 的比较：\n    - $\\text{cast}_{\\text{binary32}}(a_1)$ 舍入为 $S$，不等于 $2.0$。不形成配对 $(a_1, b_2)$。\n    - $\\text{cast}_{\\text{binary32}}(a_2)$ 舍入为 $S$，不等于 $2.0$。不形成配对 $(a_2, b_2)$。\n    - $\\text{cast}_{\\text{binary32}}(a_3) = \\text{cast}_{\\text{binary32}}(2.0) = 2.0$。这等于 $b_2$。形成配对 $(a_3, b_2)$。\n\n策略S产生三个配对：$(a_1, b_1)$，$(a_2, b_1)$ 和 $(a_3, b_2)$。\n\n**结论**\n设 $P_D$ 为策略D找到的配对集合，设 $P_S$ 为策略S找到的配对集合。\n$P_D = \\{ (a_3, b_2) \\}$\n$P_S = \\{ (a_1, b_1), (a_2, b_1), (a_3, b_2) \\}$\n\n问题要求的是策略S产生但策略D未产生的配对数量。这是集合差 $P_S \\setminus P_D$ 的基数。\n$P_S \\setminus P_D = \\{ (a_1, b_1), (a_2, b_1), (a_3, b_2) \\} \\setminus \\{ (a_3, b_2) \\} = \\{ (a_1, b_1), (a_2, b_1) \\}$。\n此类配对的数量是该集合的基数，即 $2$。这些配对，$(a_1, b_1)$ 和 $(a_2, b_1)$，是策略S因转换过程中的精度损失而找到的，而策略D则正确地识别出这些键并不相等。\n\n此类配对的总数为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3678173"}]}