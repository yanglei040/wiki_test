{"hands_on_practices": [{"introduction": "在计算机体系结构中，指令常常包含“立即数”（immediate values），这些数据直接编码在指令本身。当一个较小的立即数（例如12位）用于一个需要较大数据宽度（例如32位）的算术运算时，CPU必须将其扩展。此练习探讨了两种扩展方式——符号扩展与零扩展——之间的关键区别，通过一个假设的硬件故障场景，揭示了正确处理有符号数对于确保算术逻辑单元（ALU）计算准确性的重要性 [@problem_id:3647781]。", "problem": "一个 32 位精简指令集计算机 (RISC) 核心对有符号整数使用二进制补码表示法，并实现位宽为 $12$ 位的立即数操作数。在由算术逻辑单元 (ALU) 执行的一条加法指令中，$12$ 位的立即数字段为十六进制值 $0xF7F$，且目标寄存器初始包含十六进制值 $0x10001000$。该架构规范要求立即数在被 ALU 使用前必须符号扩展到 $32$ 位，但一个错误的实现却对立即数进行了零扩展。\n\n从位值记数系统和补码运算的基本原理出发，确定在比较正确的符号扩展行为和错误的零扩展行为时，计算出的寄存器值的差异的精确大小。具体来说，设 $I_{\\text{sext}}$ 是 $12$ 位立即数 $0xF7F$ 正确的 $32$ 位符号扩展值，设 $I_{\\text{zext}}$ 是同一立即数错误的 $32$ 位零扩展值。在正确行为下，ALU 计算 $R'_{\\text{sext}} = R + I_{\\text{sext}}$；在错误行为下，ALU 计算 $R'_{\\text{zext}} = R + I_{\\text{zext}}$，其中 $R = 0x10001000$。计算下式的精确值：\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|,$$\n并将您的最终答案表示为一个十进制整数。无需四舍五入，也不涉及物理单位。", "solution": "本题要求确定在使用正确符号扩展的立即数和错误零扩展的立即数进行加法运算时，其结果之间差异的绝对值 $D$。\n\n首先，我们对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- 架构：$32$ 位 RISC 核心。\n- 整数表示：有符号整数采用二进制补码。\n- 立即数操作数位宽：$12$ 位。\n- 立即数值（十六进制）：$0xF7F$。\n- 初始目标寄存器值（十六进制）：$R = 0x10001000$。\n- 正确行为：将 $12$ 位立即数符号扩展到 $32$ 位。设此值为 $I_{\\text{sext}}$。\n- 错误行为：将 $12$ 位立即数零扩展到 $32$ 位。设此值为 $I_{\\text{zext}}$。\n- 正确计算结果：$R'_{\\text{sext}} = R + I_{\\text{sext}}$。\n- 错误计算结果：$R'_{\\text{zext}} = R + I_{\\text{zext}}$。\n- 待计算量：差异 $D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|$。\n- 最终答案必须是十进制整数。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据**：本题基于计算机组成与体系结构的基本概念，包括位值记数系统（十六进制、二进制）、补码运算以及指令集架构特性，如立即数操作数、符号扩展和零扩展。这些概念都是成熟且科学上合理的。\n- **适定性**：本题是完全指定的。所有数值和行为都有定义，目标是一个明确陈述的数学计算。存在唯一解。\n- **客观性**：本题以精确、客观的语言陈述，没有歧义或主观论断。\n\n**结论与行动**\n本题有效。它有科学依据，适定且客观。没有矛盾、信息缺失或逻辑缺陷。我们继续进行求解。\n\n待计算的量是正确结果与错误结果之差的绝对值：\n$$D = \\left|R'_{\\text{sext}} - R'_{\\text{zext}}\\right|$$\n代入 $R'_{\\text{sext}}$ 和 $R'_{\\text{zext}}$ 的定义：\n$$D = \\left|(R + I_{\\text{sext}}) - (R + I_{\\text{zext}})\\right|$$\n化简表达式，寄存器的初始值 $R$ 被消掉：\n$$D = \\left|R + I_{\\text{sext}} - R - I_{\\text{zext}}\\right| = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right|$$\n因此，问题简化为求立即数的符号扩展值与零扩展值之差的绝对值。初始寄存器值 $R = 0x10001000$ 是无关信息。\n\n我们从基本原理来分析立即数值。该立即数是一个 $12$ 位的十六进制值 $0xF7F$。\n在一个基数为 $b$ 的位值记数系统中，由数字 $d_{n-1}d_{n-2}...d_0$ 表示的数的值为 $\\sum_{i=0}^{n-1} d_i b^i$。\n首先，我们将这个 $12$ 位的十六进制值转换为其二进制表示。每个十六进制数字对应 $4$ 个二进制数字（位）：\n- $F_{16} = 15_{10} = 1111_2$\n- $7_{16} = 7_{10} = 0111_2$\n- $F_{16} = 15_{10} = 1111_2$\n\n将它们组合起来，这个 $12$ 位立即数的二进制形式是 $111101111111_2$。我们记这个位模式为 $J$。\n\n在二进制补码表示法中，数的符号由其最高有效位 (MSB) 决定。对于一个 $12$ 位的数，MSB 是第 $11$ 位（从第 $0$ 位开始计数）。在模式 $111101111111_2$ 中，MSB 是 $1$。这表示该立即数代表一个负值。\n\n设 $j_{11}j_{10}...j_0$ 是 $12$ 位立即数 $J$ 的二进制表示。\n一个有符号的 $12$ 位补码整数的值由以下公式给出：\n$$V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n一个无符号的 $12$ 位整数的值为：\n$$V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i = j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\n零扩展到 $32$ 位涉及在前缀位置添加 $32 - 12 = 20$ 个零。得到的 $32$ 位数 $I_{\\text{zext}}$ 被系统解释为一个正数，其值就是原始 $12$ 位模式的无符号值。\n$$V(I_{\\text{zext}}) = V_U(J) = \\sum_{i=0}^{11} j_i \\cdot 2^i$$\n\n符号扩展到 $32$ 位涉及在前缀位置添加 $20$ 个原始 $12$ 位数的 MSB ($j_{11}$) 的副本。这个过程保留了原始数的有符号数值。\n$$V(I_{\\text{sext}}) = V(J) = -j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i$$\n\n现在我们计算它们值的差：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = \\left(-j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right) - \\left(j_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} j_i \\cdot 2^i\\right)$$\n求和项相互抵消：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -j_{11} \\cdot 2^{11} - j_{11} \\cdot 2^{11} = -2 \\cdot j_{11} \\cdot 2^{11} = -j_{11} \\cdot 2^{12}$$\n对于给定的立即数 $0xF7F$，其二进制表示为 $111101111111_2$，所以它的 MSB 是 $j_{11} = 1$。\n将 $j_{11} = 1$ 代入差值公式：\n$$V(I_{\\text{sext}}) - V(I_{\\text{zext}}) = -1 \\cdot 2^{12} = -2^{12}$$\n差异 $D$ 是这个差的绝对值：\n$$D = \\left|I_{\\text{sext}} - I_{\\text{zext}}\\right| = \\left|V(I_{\\text{sext}}) - V(I_{\\text{zext}})\\right| = \\left|-2^{12}\\right| = 2^{12}$$\n最后，我们计算其十进制值：\n$$2^{10} = 1024$$\n$$2^{11} = 2 \\times 1024 = 2048$$\n$$2^{12} = 2 \\times 2048 = 4096$$\n差异的绝对值为 $4096$。\n这个结果是通用的：对于一个 MSB 为 $1$ 的 $k$ 位立即数，错误的零扩展而不是符号扩展，将产生一个比正确值恰好大 $2^k$ 的值。如果 MSB 为 $0$，两种扩展将是相同的，差异将为 $0$。", "answer": "$$\\boxed{4096}$$", "id": "3647781"}, {"introduction": "超越了简单的数字表示，本练习将深入探讨计算机算术的核心——二进制补码加法及其固有的局限性。计算机使用固定位数的寄存器，这意味着计算结果可能会超出可表示的范围，从而导致“溢出”（overflow）。通过分析一个经典的边界情况，$0x7FFFFFFF + 0x00000001$，你将从第一性原理推导出检测溢出的通用规则，理解硬件是如何通过观察符号位和进位位的行为来识别这种关键的算术错误的 [@problem_id:3647851]。", "problem": "在一个使用 $n$ 位补码表示法表示有符号整数的计算机系统中，可表示范围为 $-2^{n-1}$ 到 $2^{n-1}-1$，最高有效位（MSB）编码符号，二进制加法以模 $2^{n}$ 的方式执行，并在各个位之间传播进位。有符号加法中的溢出发生在两个可表示操作数的真实数学和超出了可表示范围时，即使硬件返回了模 $2^{n}$ 的环绕结果。基于这一基本原理，推导补码加法的溢出条件（根据符号位行为和进位传播），然后用 $32$ 位的十六进制和 $0x7FFFFFFF + 0x00000001 \\rightarrow 0x80000000$ 来测试你的推导。选择所有正确描述溢出条件及其在给定测试中表现的陈述。\n\nA. 在 $n$ 位补码加法中，溢出发生当且仅当进入最高有效位的进位与来自最高有效位的进位不同；对于测试 $0x7FFFFFFF + 0x00000001$，此条件成立，因此发生溢出。\n\nB. 只要有来自最高有效位的进位，无论进入它的进位如何，都会发生溢出；对于测试 $0x7FFFFFFF + 0x00000001$，来自最高有效位的进位是 $1$，所以发生溢出。\n\nC. 溢出仅在相加异号操作数时发生；由于 $0x7FFFFFFF$ 和 $0x00000001$ 都是正数，所以在该测试中没有溢出。\n\nD. 在补码中，当两个正数相加时，如果结果的符号位为 $1$，则发生溢出，因为真实和超过了 $2^{n-1}-1$；在此示例中，两个操作数都是正数，且结果的符号位为 $1$，所以发生溢出。\n\nE. 十六进制结果 $0x80000000$ 在 $32$ 位补码中表示 $-2^{31}$；由于真实和 $2^{31}-1 + 1$ 等于 $2^{31}$，这超出了可表示的正数范围，硬件会以模 $2^{32}$ 环绕到 $-2^{31}$ 并置位溢出标志；等价地，当结果的符号与操作数共同的符号不同时，表示发生溢出。\n\nF. 没有发生溢出，因为 $0x80000000$ 是一个有效的 $32$ 位补码编码，并且溢出仅取决于返回的位模式是否可表示，而不取决于真实和。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n- 系统使用 $n$ 位补码表示法表示有符号整数。\n- 这些整数的可表示范围是从 $-2^{n-1}$ 到 $2^{n-1}-1$。\n- 最高有效位（MSB）编码符号。\n- 二进制加法以模 $2^{n}$ 的方式执行，并带有进位传播。\n- 溢出的定义是：两个可表示操作数的真实数学和超出了可表示范围。\n- 硬件返回模 $2^n$ 的环绕结果。\n- 任务是推导溢出条件，并用 $32$ 位的十六进制和 $0x7FFFFFFF + 0x00000001 \\rightarrow 0x80000000$ 来测试它。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于计算机体系结构中使用的补码运算的标准和基本原理。所提供的所有定义和公理都是正确且公认的。\n- **适定性**：问题陈述清晰，要求推导一个特定条件并将其应用于一个具体示例。其结构可确保有唯一且正确的解。\n- **客观性**：语言技术性强、精确，没有任何主观或模糊的术语。\n- **缺陷分析**：\n    1.  **科学/事实不准确**：无。前提事实正确。\n    2.  **不可形式化/不相关**：无。该问题是形式化的，并与计算机组成和体系结构直接相关。\n    3.  **不完整/矛盾的设置**：无。提供了所有必要信息。\n    4.  **不切实际/不可行**：无。这是数字逻辑中的标准操作。\n    5.  **不适定/结构不良**：无。问题导向一组明确的结论。\n    6.  **琐碎/同义反复**：无。推导需要严格应用第一原理。\n    7.  **不可验证**：无。结果在数学和逻辑上都是可验证的。\n\n**步骤 3：结论与行动**\n问题陈述是 **有效的**。解决方案将通过推导溢出条件和评估选项来继续进行。\n\n### 解题推导与选项分析\n\n问题要求推导 $n$ 位补码加法中的溢出条件。设两个 $n$ 位操作数为 $A$ 和 $B$，它们的符号位为 $a_{n-1}$ 和 $b_{n-1}$，其硬件和 $S'$ 的符号位为 $s'_{n-1}$。如果真实和 $A+B$ 超出范围 $[ -2^{n-1}, 2^{n-1}-1 ]$，则发生溢出。\n\n1.  **溢出条件的推导：**\n    设 $c_{in}$ 为进入最高有效位（MSB，第 $n-1$ 位）的进位，而 $c_{out}$ 为来自 MSB 的进位。\n\n    - **情况 1：异号操作数相加** ($a_{n-1} \\neq b_{n-1}$)。\n      设 $A \\geq 0$ 且 $B  0$。真实和 $S = A+B$ 的界限为 $B  S  A$。由于 $A$ 和 $B$ 都在可表示范围内，它们的和 $S$ 也必定在该范围内。例如，可能的最大和是 $(2^{n-1}-1) + (-1) = 2^{n-1}-2$，最小的和是 $0 + (-2^{n-1}) = -2^{n-1}$。两者都是可表示的。因此，当相加异号操作数时，溢出**不可能**发生。\n      在这种情况下，进入 MSB 的进位总是等于来自 MSB 的进位。让我们来证明这一点：$c_{out} = (a_{n-1} \\land b_{n-1}) \\lor (a_{n-1} \\land c_{in}) \\lor (b_{n-1} \\land c_{in})$。当 $a_{n-1} \\neq b_{n-1}$ 时，我们有 $a_{n-1} \\land b_{n-1} = 0$。所以，$c_{out} = (a_{n-1} \\lor b_{n-1}) \\land c_{in} = 1 \\land c_{in} = c_{in}$。因此，$c_{in} = c_{out}$。\n\n    - **情况 2：同号操作数相加** ($a_{n-1} = b_{n-1}$)。\n      - 如果两者都为正（$a_{n-1}=b_{n-1}=0$），它们的和为正。如果和过大，即 $A+B > 2^{n-1}-1$，则发生溢出。一个 $\\geq 2^{n-1}$ 的和需要在 MSB 处有进位（$c_{in}=1$）。结果的 MSB 是 $s'_{n-1} = a_{n-1} \\oplus b_{n-1} \\oplus c_{in} = 0 \\oplus 0 \\oplus 1 = 1$。结果错误地显示为负数。这里，$c_{in}=1$。进位输出是 $c_{out} = (0 \\land 0) \\lor (0 \\land 1) \\lor (0 \\land 1) = 0$。所以，$c_{in} \\neq c_{out}$。\n      - 如果两者都为负（$a_{n-1}=b_{n-1}=1$），它们的和为负。如果和过小，即 $A+B  -2^{n-1}$，则发生溢出。这种环绕导致一个正数，意味着结果的符号位是 $s'_{n-1}=0$。结果的 MSB 是 $s'_{n-1} = a_{n-1} \\oplus b_{n-1} \\oplus c_{in} = 1 \\oplus 1 \\oplus c_{in} = c_{in}$。为了使 $s'_{n-1}$ 为 $0$，我们必须有 $c_{in}=0$。进位输出是 $c_{out} = (1 \\land 1) \\lor (1 \\land 0) \\lor (1 \\land 0) = 1$。所以，$c_{in} \\neq c_{out}$。\n\n    **推导结论：** 溢出发生当且仅当操作数符号相同而结果符号相反。这在逻辑上等同于陈述：溢出发生当且仅当进入 MSB 的进位与来自 MSB 的进位不同（$c_{in} \\neq c_{out}$）。\n\n2.  **测试用例分析：$0x7FFFFFFF + 0x00000001$**\n    - 系统是 $n=32$ 位。\n    - 操作数 A: $0x7FFFFFFF = 2^{31}-1$。其二进制形式为 $0111...111$。它是一个正数。\n    - 操作数 B: $0x00000001 = 1$。其二进制形式为 $0000...001$。它是一个正数。\n    - 真实数学和：$(2^{31}-1) + 1 = 2^{31}$。\n    - 可表示范围：$[-2^{31}, 2^{31}-1]$。\n    - 由于真实和 $2^{31}$ 大于最大可表示正整数 $2^{31}-1$，因此必须发生 **溢出**。\n    - 硬件加法：\n      $$\n      \\begin{array}{rc}\n        0111\\;1111\\;...\\;1111 \\\\\n      +  0000\\;0000\\;...\\;0001 \\\\\n      \\hline\n      \\end{array}\n      $$\n      最低有效位的和是 $1+1=10_2$，所以结果位是 $0$ 并且有一个进位。这个进位会传播过所有 $31$ 位。进入 MSB（第 $31$ 位）的进位是 $c_{in, 31} = 1$。\n    - 在 MSB（第 $31$ 位）处：\n      - 操作数位：$a_{31}=0, b_{31}=0$。\n      - 结果位：$s'_{31} = a_{31} \\oplus b_{31} \\oplus c_{in, 31} = 0 \\oplus 0 \\oplus 1 = 1$。\n      - 进位输出：$c_{out, 31} = (a_{31} \\land b_{31}) \\lor (c_{in, 31} \\land (a_{31} \\oplus b_{31})) = (0\\land 0) \\lor (1 \\land (0\\oplus 0)) = 0$。\n    - 最终的二进制模式是 $1000...000$，即 $0x80000000$。这表示值 $-2^{31}$。\n    - 溢出检查：\n        - 符号检查：两个正数相加，结果为负。发生溢出。\n        - 进位检查：进入 MSB 的进位（$c_{in, 31}=1$）与来自 MSB 的进位（$c_{out, 31}=0$）不同。发生溢出。\n\n### 逐项分析\n\n**A. 在 $n$ 位补码加法中，溢出发生当且仅当进入最高有效位的进位与来自最高有效位的进位不同；对于测试 $0x7FFFFFFF + 0x00000001$，此条件成立，因此发生溢出。**\n该陈述提出了普适正确的基于进位的溢出条件（$c_{in} \\neq c_{out}$）。我们对测试用例的分析表明 $c_{in, 31}=1$ 且 $c_{out, 31}=0$，两者不同。因此，该条件成立，并且正确地识别了溢出。\n**结论：正确。**\n\n**B. 只要有来自最高有效位的进位，无论进入它的进位如何，都会发生溢出；对于测试 $0x7FFFFFFF + 0x00000001$，来自最高有效位的进位是 $1$，所以发生溢出。**\n“只要有来自最高有效位的进位就发生溢出”这一条件是 **无符号** 整数溢出的规则，而非有符号补码。对于有符号加法，将 $-1$ 与 $-1$ 相加（例如，在 $4$ 位中为 $1111+1111$）会产生 $1$ 的进位输出，但不会溢出。此外，对于给定的测试用例，我们的分析表明进位输出为 $c_{out, 31}=0$，而不是 $1$。该陈述的前提和应用都是不正确的。\n**结论：不正确。**\n\n**C. 溢出仅在相加异号操作数时发生；由于 $0x7FFFFFFF$ 和 $0x00000001$ 都是正数，所以在该测试中没有溢出。**\n这个陈述是根本错误的。根据推导，溢出 **只能** 在相加 **同号** 操作数时发生。相加异号操作数时不可能发生溢出。其结论也是错误的；测试中确实发生了溢出。\n**结论：不正确。**\n\n**D. 在补码中，当两个正数相加时，如果结果的符号位为 $1$，则发生溢出，因为真实和超过了 $2^{n-1}-1$；在此示例中，两个操作数都是正数，且结果的符号位为 $1$，所以发生溢出。**\n这提供了一个正确的、针对特定情况的溢出规则：两个正数相加得到一个负数结果。其推理是合理的。应用于该示例是完美的：$0x7FFFFFFF$ 和 $0x00000001$ 是正数，而结果 $0x80000000$ 的符号位是 $1$。发生溢出的结论是正确的。\n**结论：正确。**\n\n**E. 十六进制结果 $0x80000000$ 在 $32$ 位补码中表示 $-2^{31}$；由于真实和 $2^{31}-1 + 1$ 等于 $2^{31}$，这超出了可表示的正数范围，硬件会以模 $2^{32}$ 环绕到 $-2^{31}$ 并置位溢出标志；等价地，当结果的符号与操作数共同的符号不同时，表示发生溢出。**\n该陈述是对情况的全面而正确的描述。\n- $0x80000000$ 确实是 $-2^{31}$ 的表示。\n- 真实和被正确计算为 $2^{31}$。\n- $2^{31}$ 被正确地识别为在有效范围 $[-2^{31}, 2^{31}-1]$ 之外。\n- 环绕行为（模 $2^{32}$）正确地解释了为什么 $2^{31}$ 的位模式被解释为 $-2^{31}$。\n- 等价的基于符号的条件（正数 + 正数 $\\rightarrow$ 负数）被正确陈述。\n该陈述的每个部分都是准确的，并且与补码运算的原理一致。\n**结论：正确。**\n\n**F. 没有发生溢出，因为 $0x80000000$ 是一个有效的 $32$ 位补码编码，并且溢出仅取决于返回的位模式是否可表示，而不取决于真实和。**\n该陈述从根本上误解了溢出的概念。虽然 $0x80000000$ 是一个有效的编码，但溢出与结果位模式的有效性无关（所有 $n$ 位模式都是有效的编码）。根据定义，溢出是硬件的环绕结果与真实数学和不匹配的情况，因为真实和超出了可表示的范围。问题陈述本身就是根据真实和来定义溢出的。\n**结论：不正确。**", "answer": "$$\\boxed{ADE}$$", "id": "3647851"}, {"introduction": "在底层系统编程和硬件交互中，精确地修改一个数据字中的特定部分而不影响其余部分是一项基本技能。这个练习将指导你完成一个标准的“位域插入”（field insertion）操作，使用按位逻辑运算（AND, OR, NOT）和移位操作来实现。通过从头构建一个掩码并应用它，你将体会到十六进制表示法为何是描述和操作二进制位模式的强大且直观的工具，这在编写设备驱动或操作系统内核时至关重要 [@problem_id:3647874]。", "problem": "在中央处理器（CPU）的数据通路中，常规使用基于掩码的字段插入来设置一个字中的特定位域，同时保持所有其他位不变。考虑一个宽度为 $32$ 位的字长寄存器，其位位置从 $0$（最低有效位）到 $31$（最高有效位）编号。令 $x$ 表示寄存器的内容，初始值为 $x = 0x12345678$。目标是将 $x$ 的第 $8$ 位到第 $11$ 位置为十六进制半字节 $0xA$，并保持所有其他位不变。\n\n仅从按位与（``）、按位或（`|`）、按位非（`~`）和左移（``）这些按位运算的定义，以及十六进制数字相对于二进制的位置含义（每个十六进制数字等于四个连续位）出发，从基本原理推导出一个正确的掩码并插入过程，以完成所需的字段插入。然后将您推导出的过程应用于给定的 $x$ 以计算最终的寄存器值。\n\n将您的最终答案表示为带有前缀 `0x` 的单个十六进制整数。无需四舍五入。", "solution": "该问题是有效的，因为它在计算机体系结构方面有科学依据，定义明确，客观，并包含推导唯一解所需的所有必要信息。\n\n任务是修改一个 $32$ 位寄存器内的特定位域。令寄存器的初始内容用变量 $x$ 表示。目标是将第 $8$ 位到第 $11$ 位置为十六进制值 $0xA$，同时保持所有其他位的状态。这个操作通常被称为字段插入，并且可以从基本原理出发使用按位逻辑运算推导出来。\n\n该过程包括两个基本步骤：\n1.  **清除目标位域**：首先，我们必须将目标字段中的位（第 $8$ 位到第 $11$ 位）设置为 $0$。这确保了后续的插入步骤不会破坏最终值。这是通过与一个“清除掩码”进行按位与（``）运算来实现的。\n2.  **插入新值**：其次，我们必须将新值放入现已清除的目标字段中。这是通过与一个“插入值”进行按位或（`|`）运算来完成的。\n\n让我们从问题陈述中推导所需的掩码和值。寄存器宽度为 $32$ 位。目标字段从位 $i=8$ 跨越到位 $j=11$。该字段的宽度为 $w = j - i + 1 = 11 - 8 + 1 = 4$ 位。该字段的新值为 $v = 0xA$。\n\n**步骤1：推导清除掩码**\n\n为了清除 $x$ 中的目标字段，我们使用一个清除掩码，称之为 $M_{clear}$。这个掩码必须在位位置 $8$ 到 $11$ 处为 $0$，在所有其他 $28$ 个位置处为 $1$。执行 $x \\; \\ \\; M_{clear}$ 会将目标位设置为 $0$，同时保持 $x$ 的所有其他位不变（因为对于任何位 $b$，$b \\; \\ \\; 1 = b$ 且 $b \\; \\ \\; 0 = 0$）。\n\n我们可以通过先定义一个仅在目标位域中为 $1$ 的掩码，然后对其进行按位取反（`~`），来构造 $M_{clear}$。我们称这个中间掩码为 $M_{field}$。$M_{field}$ 从位位置 $8$ 开始有 $4$ 个连续的 $1$。一个由 $w$ 个 $1$ 组成的块由整数 $2^w - 1$ 表示。对于 $w=4$，这是 $2^4 - 1 = 15$，在十六进制中为 $0xF$。\n\n为了将这些 $1$ 定位到正确的位置，我们必须将此值按起始位位置 $i=8$进行左移（``）。\n$$M_{field} = (0xF) \\ll 8$$\n在一个 $32$ 位系统中，一个十六进制数是 $8$ 个半字节（4位组）的序列。左移 $8$ 位相当于移动两个十六进制位置。\n十六进制常数 $0xF$ 在 $32$ 位中表示为 $0x0000000F$。\n$$M_{field} = 0x0000000F \\ll 8 = 0x00000F00$$\n清除掩码 $M_{clear}$ 是 $M_{field}$ 的按位非：\n$$M_{clear} = \\sim M_{field} = \\sim (0x00000F00)$$\n对这个 $32$ 位值执行按位非运算得到：\n$$M_{clear} = 0xFFFFF0FF$$\n因此，清除 $x$ 中字段的操作是 $x \\; \\ \\; 0xFFFFF0FF$。\n\n**步骤2：推导插入值**\n\n要插入的新值是 $v = 0xA$。这个 $4$ 位的值必须在 $32$ 位字内正确定位，以便与目标字段（位 $8-11$）对齐。这也通过左移运算实现。令准备好的值为 $V_{insert}$。\n$$V_{insert} = v \\ll i = 0xA \\ll 8$$\n十六进制常数 $0xA$ 在 $32$ 位中表示为 $0x0000000A$。\n$$V_{insert} = 0x0000000A \\ll 8 = 0x00000A00$$\n这个值将通过按位或运算与 $x$ 的清除版本结合。由于清除后的 $x$ 中的目标字段全为零，或运算将插入 $V_{insert}$ 的位，而不会影响任何其他位（因为对于任何位 $b$，$b \\; | \\; 0 = b$）。\n\n**完整过程**\n\n结合这两个步骤，最终值 $x_{new}$ 计算如下：\n$$x_{new} = (x \\; \\ \\; M_{clear}) \\; | \\; V_{insert}$$\n代入推导出的表达式：\n$$x_{new} = (x \\; \\ \\; (\\sim(0xF \\ll 8))) \\; | \\; (0xA \\ll 8)$$\n\n**应用于给定数据**\n\n现在我们将此过程应用于给定的初始寄存器内容 $x = 0x12345678$。\n\n首先，我们清除目标字段：\n$$x_{cleared} = x \\; \\ \\; M_{clear} = 0x12345678 \\; \\ \\; 0xFFFFF0FF$$\n此操作保留了 $x$ 中掩码数字为 $F$ 的所有十六进制数字，并将掩码数字为 $0$ 的位置的数字清零。掩码在对应于位 $8-11$ 的位置上有一个 $0$，这与 $0x12345678$ 中的数字 '$6$' 对齐。\n$$x_{cleared} = 0x12345078$$\n\n接下来，我们插入新值：\n$$x_{new} = x_{cleared} \\; | \\; V_{insert} = 0x12345078 \\; | \\; 0x00000A00$$\n或运算将值 $A$ 放入从右边数的第三个半字节（位 $8-11$），该位置之前已被清除为 $0$。\n$$x_{new} = 0x12345A78$$\n\n最终的寄存器值为 $0x12345A78$。", "answer": "$$\\boxed{0x12345A78}$$", "id": "3647874"}]}