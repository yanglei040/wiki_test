{"hands_on_practices": [{"introduction": "每周期指令数（CPI）是衡量处理器性能的核心指标。然而，一个系统的整体CPI并非一个单一的固定值，而是由理想CPI和各种流水线冒险（如数据冒险、缓存未命中和分支预测错误）导致的停顿周期共同决定的。本练习 [@problem_id:3628693] 将指导你动手分解CPI的构成，通过量化计算每个冒险源对性能的具体影响，让你深入理解微体系结构层面的优化（例如提高分支预测准确率）是如何转化为可衡量的性能提升的。", "problem": "一个单发射、顺序执行的$5$级流水线正在执行一个包含稳定指令组合的大型程序，其中的冒险会导致流水线停顿。忽略所有冒险的基础每指令周期数 (CPI) 为 $1.0$。指令组合比例如下：加载指令占 $0.20$，存储指令占 $0.15$，算术和逻辑指令占 $0.45$，控制流指令（分支）占 $0.20$。对于此工作负载，观察到以下微体系结构行为：\n\n- 当一条紧跟在加载指令之后的指令使用了加载得到的值时，会发生加载-使用相关；每次加载发生这种情况的概率为 $0.30$，发生时会导致 $1$ 个周期的停顿。\n- 加载指令的数据缓存未命中率为 $0.02$，存储指令为 $0.01$。每次加载未命中导致流水线停顿 $12$ 个周期，每次存储未命中导致流水线停顿 $8$ 个周期。\n- 分支预测器是一个两级自适应预测器，其初始准确率为 $0.88$。每次分支预测错误都会导致流水线刷新，并产生 $4$ 个周期的惩罚。\n\n为进行分析，假设：指令间的冒险在统计上是独立的，不同事件引起的停顿周期不重叠，算术和逻辑指令在基础流水线时序之外不引起停顿，并且指令流足够长以使期望值具有代表性。一项体系结构改进将分支预测器的准确率提高到 $0.96$，所有其他特性保持不变。\n\n仅使用吞吐量和平均值的基本定义，计算在分支预测器准确率改进后，此工作负载的改进后总体每指令周期数 (CPI)。将您的答案四舍五入到四位有效数字。最终的CPI表示为一个没有单位的纯数字。", "solution": "题目要求计算在一项特定的体系结构改进后的总体每指令周期数 (CPI)。验证题目陈述是必需的第一步。\n\n### 步骤1：提取给定信息\n- 处理器流水线：单发射、顺序执行、$5$级\n- 基础CPI（无冒险）：$CPI_{base} = 1.0$\n- 指令组合比例：\n    - 加载指令 ($f_{load}$): $0.20$\n    - 存储指令 ($f_{store}$): $0.15$\n    - 算术/逻辑指令 ($f_{alu}$): $0.45$\n    - 控制流/分支指令 ($f_{branch}$): $0.20$\n- 加载-使用相关：\n    - 每次加载的发生概率 ($P_{dep}$): $0.30$\n    - 每次发生时的停顿周期 ($S_{dep}$): $1$\n- 数据缓存未命中：\n    - 加载未命中率 ($M_{load}$): $0.02$\n    - 存储未命中率 ($M_{store}$): $0.01$\n    - 每次加载未命中的停頓周期 ($S_{load\\_miss}$): $12$\n    - 每次存储未命中的停顿周期 ($S_{store\\_miss}$): $8$\n- 分支预测：\n    - 初始准确率 ($A_{init}$): $0.88$\n    - 改进后准确率 ($A_{imp}$): $0.96$\n    - 每次预测错误的停顿周期 ($S_{branch\\_miss}$): $4$\n- 假设：\n    - 冒险在统计上是独立的。\n    - 不同事件引起的停顿周期不重叠。\n    - 算术和逻辑指令不引起停顿。\n    - 指令流足够长，因此期望值具有代表性。\n\n### 步骤2：使用提取的信息进行验证\n根据验证标准对问题进行评估。\n- **科学性：** 该问题基于计算机组成和体系结构的基本概念，特别是流水线性能分析。CPI、指令组合、数据冒险（加载-使用）、缓存未命中和分支预测错误等概念都是该领域的标准和成熟概念。所提供的数值对于一个假设的处理器来说是合理的。\n- **良构性：** 该问题提供了计算最终CPI所需的所有数据（基础CPI、指令比例、冒险概率和停顿惩罚）。问题清晰明确。关于不同事件引起的停顿周期是可加的这一假设简化了计算，并确保了唯一解。\n- **客观性：** 问题陈述没有主观性语言、观点或偏见。它提出了一个纯粹用于定量分析的技术场景。\n\n该问题没有表现出验证标准中列出的任何缺陷。它在科学上是合理的、自洽的、一致的且是良构的。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供解答。\n\n流水线处理器的总体CPI可以表示为基础CPI与所有引起停顿的事件所贡献的CPI之和。理想流水线的基础CPI给定为 $1.0$。总CPI计算如下：\n$$CPI_{total} = CPI_{base} + \\sum_{i} CPI_{stall, i}$$\n其中，$CPI_{stall, i}$ 是第 $i$ 类冒险平均每条指令贡献的停顿周期数。每个停顿事件的贡献是其发生频率（每条指令）与每次发生的惩罚（以周期为单位）的乘积。\n\n问题描述了三种停顿来源：\n1. 加载-使用数据冒险。\n2. 数据缓存未命中（包括加载和存储）。\n3. 分支预测错误。\n\n问题要求计算改进后的总体CPI，这需要使用改进后的分支预测器准确率。我们将分别计算每个来源对CPI的贡献。\n\n**1. 加载-使用冒险对CPI的贡献 ($CPI_{dep}$)**\n当一条紧跟在加载指令之后的指令使用了加载的值时，就会发生加载-使用冒险停顿。此事件每条指令的发生频率是加载指令的比例乘以给定加载指令发生这种相关的概率。\n$$CPI_{dep} = f_{load} \\times P_{dep} \\times S_{dep}$$\n代入给定值：\n$$CPI_{dep} = 0.20 \\times 0.30 \\times 1 = 0.06$$\n\n**2. 数据缓存未命中对CPI的贡献 ($CPI_{dcache}$)**\n这个贡献有两个组成部分：加载未命中停顿和存储未命中停顿。根据不同事件引起的停顿周期不重叠的假设，我们可以将它们的单独贡献相加。\n\n-   **加载未命中停顿：** 加载未命中在每条指令中的发生频率是加载指令的比例乘以加载未命中率。\n    $$CPI_{load\\_miss} = f_{load} \\times M_{load} \\times S_{load\\_miss}$$\n    代入给定值：\n    $$CPI_{load\\_miss} = 0.20 \\times 0.02 \\times 12 = 0.048$$\n\n-   **存储未命中停顿：** 存储未命中在每条指令中的发生频率是存储指令的比例乘以存储未命中率。\n    $$CPI_{store\\_miss} = f_{store} \\times M_{store} \\times S_{store\\_miss}$$\n    代入给定值：\n    $$CPI_{store\\_miss} = 0.15 \\times 0.01 \\times 8 = 0.012$$\n\n数据缓存未命中的总贡献是这两个部分之和：\n$$CPI_{dcache} = CPI_{load\\_miss} + CPI_{store\\_miss} = 0.048 + 0.012 = 0.060$$\n\n**3. 分支预测错误对CPI的贡献 ($CPI_{branch}$)**\n问题要求使用改进后的分支预测器准确率 $A_{imp} = 0.96$。因此，分支预测错误率为 $1 - A_{imp}$。分支预测错误在每条指令中的发生频率是分支指令的比例乘以该预测错误率。\n$$CPI_{branch} = f_{branch} \\times (1 - A_{imp}) \\times S_{branch\\_miss}$$\n代入给定值：\n$$CPI_{branch} = 0.20 \\times (1 - 0.96) \\times 4 = 0.20 \\times 0.04 \\times 4 = 0.032$$\n\n**4. 计算改进后的总体CPI ($CPI_{improved}$)**\n改进后的总体CPI是基础CPI与所有停顿来源的CPI贡献之和。\n$$CPI_{improved} = CPI_{base} + CPI_{dep} + CPI_{dcache} + CPI_{branch}$$\n代入计算出的值：\n$$CPI_{improved} = 1.0 + 0.06 + 0.060 + 0.032$$\n$$CPI_{improved} = 1.0 + 0.120 + 0.032$$\n$$CPI_{improved} = 1.152$$\n题目要求将答案四舍五入到四位有效数字。计算出的值 $1.152$ 已经有四位有效数字。", "answer": "$$\\boxed{1.152}$$", "id": "3628693"}, {"introduction": "Amdahl定律为我们预测系统某一部分得到优化后所能带来的整体性能提升提供了一个经典的理论框架。然而，在实际工程决策中，我们不仅想知道“能快多少”，更想知道“优化哪里最有效”。本练习 [@problem_id:3628775] 超越了对Amdahl定律的简单应用，引入了“灵敏度”（或弹性）的概念。通过推导和计算，你将学会如何评估不同组件的优化对整体加速比的贡献大小，从而做出更具成本效益的设计决策。", "problem": "一个程序在中央处理器（CPU）上运行，该CPU具有经典的流水线结构。其动态执行时间可归因于与指令处理相关的四个不相交的活动类别：指令提取、指令解码、指令执行以及所有剩余活动（包括内存访问和寄存器写回）。对基准系统的仔细性能剖析显示，总执行时间的归一化比例如下：提取占 $f_{f} = 0.24$，解码占 $f_{d} = 0.19$，执行占 $f_{e} = 0.37$，未受影响的剩余部分占 $f_{o} = 0.20$，满足 $f_{f} + f_{d} + f_{e} + f_{o} = 1$。一次硬件重新设计对三个流水线阶段应用了独立的加速因子：指令提取的加速因子为 $s_{f}$，指令解码的加速因子为 $s_{d}$，指令执行的加速因子为 $s_{e}$。剩余部分 $f_{o}$ 保持不变。\n\n仅从第一性原理和核心定义出发，完成以下任务：\n- 根据基准时间比例 $f_{f}, f_{d}, f_{e}, f_{o}$ 和阶段加速因子 $s_{f}, s_{d}, s_{e}$，推导总体加速比 $S(s_{f}, s_{d}, s_{e})$ 的闭式表达式。\n- 使用具体设计点 $s_{f} = 1.5$，$s_{d} = 1.2$ 和 $s_{e} = 2.0$，计算总体加速比 $S$ 的数值。\n- 通过弹性 $E_{i} \\equiv \\left(\\frac{s_{i}}{S}\\right)\\frac{\\partial S}{\\partial s_{i}}$（其中 $i \\in \\{f,d,e\\}$）来定义总体加速比对每个阶段加速比的敏感度，并从第一性原理推导 $E_{i}$ 的闭式表达式。在给定的设计点上计算 $E_{f}$，$E_{d}$ 和 $E_{e}$ 的值。\n\n将您的最终结果以行向量 $\\big[S,\\;E_{f},\\;E_{d},\\;E_{e}\\big]$ 的形式报告。将所有数值四舍五入到4位有效数字。所有要求的量均为无量纲实数。", "solution": "首先验证问题。给定条件为：四个不相交活动的执行时间比例，$f_{f} = 0.24$，$f_{d} = 0.19$，$f_{e} = 0.37$ 和 $f_{o} = 0.20$。这些比例的总和为 $f_{f} + f_{d} + f_{e} + f_{o} = 0.24 + 0.19 + 0.37 + 0.20 = 1.00$，是一致的。硬件重新设计为前三个活动提供了加速因子 $s_{f}$、$s_{d}$ 和 $s_{e}$，而第四个活动不受影响（$s_{o} = 1$）。给定的具体设计点为：$s_{f} = 1.5$，$s_{d} = 1.2$ 和 $s_{e} = 2.0$。问题要求推导总体加速比 $S$ 及其数值，推导敏感度弹性 $E_{i}$ 及其在每个阶段的数值。该问题在科学上基于计算机性能分析的原理（阿姆达尔定律），信息完备、问题适定，并以客观、正式的语言表述。因此，它被认为是一个有效的问题。\n\n我们从第一性原理开始推导。\n\n总体加速比 $S$ 定义为增强前总执行时间（$T_{old}$）与增强后总执行时间（$T_{new}$）之比。\n$$S = \\frac{T_{old}}{T_{new}}$$\n设 $T_{old}$ 为基准执行时间。每个活动类别所花费的时间可以表示为该总时间的一部分：\n提取时间：$T_{f} = f_{f} \\cdot T_{old}$\n解码时间：$T_{d} = f_{d} \\cdot T_{old}$\n执行时间：$T_{e} = f_{e} \\cdot T_{old}$\n其他活动时间：$T_{o} = f_{o} \\cdot T_{old}$\n\n一个活动的加速因子 $s_{i}$ 会减少该活动所需的时间。活动 $i$ 的新时间（表示为 $T'_{i}$）与旧时间 $T_{i}$ 的关系为 $T'_{i} = T_{i} / s_{i}$。增强后各阶段的新执行时间为：\n新提取时间：$T'_{f} = \\frac{T_{f}}{s_{f}} = \\frac{f_{f} \\cdot T_{old}}{s_{f}}$\n新解码时间：$T'_{d} = \\frac{T_{d}}{s_{d}} = \\frac{f_{d} \\cdot T_{old}}{s_{d}}$\n新执行时间：$T'_{e} = \\frac{T_{e}}{s_{e}} = \\frac{f_{e} \\cdot T_{old}}{s_{e}}$\n\n对应于 $f_{o}$ 的任务部分不受影响，这意味着其加速因子为 $s_{o}=1$。\n新其他活动时间：$T'_{o} = \\frac{T_{o}}{s_{o}} = \\frac{f_{o} \\cdot T_{old}}{1} = f_{o} \\cdot T_{old}$\n\n新的总执行时间 $T_{new}$ 是每个活动的新时间之和，因为它们被说明为不相交的。\n$$T_{new} = T'_{f} + T'_{d} + T'_{e} + T'_{o} = \\frac{f_{f} T_{old}}{s_{f}} + \\frac{f_{d} T_{old}}{s_{d}} + \\frac{f_{e} T_{old}}{s_{e}} + f_{o} T_{old}$$\n提取公因子 $T_{old}$：\n$$T_{new} = T_{old} \\left( \\frac{f_{f}}{s_{f}} + \\frac{f_{d}}{s_{d}} + \\frac{f_{e}}{s_{e}} + f_{o} \\right)$$\n现在，我们可以写出总体加速比 $S$ 的表达式。\n$$S(s_{f}, s_{d}, s_{e}) = \\frac{T_{old}}{T_{new}} = \\frac{T_{old}}{T_{old} \\left( \\frac{f_{f}}{s_{f}} + \\frac{f_{d}}{s_{d}} + \\frac{f_{e}}{s_{e}} + f_{o} \\right)}$$\n这可以化简为总体加速比的闭式表达式，这是阿姆达尔定律的一种特定形式：\n$$S(s_{f}, s_{d}, s_{e}) = \\frac{1}{\\frac{f_{f}}{s_{f}} + \\frac{f_{d}}{s_{d}} + \\frac{f_{e}}{s_{e}} + f_{o}}$$\n\n接下来，我们计算在给定设计点下 $S$ 的数值：$f_{f} = 0.24$，$f_{d} = 0.19$，$f_{e} = 0.37$，$f_{o} = 0.20$，以及 $s_{f} = 1.5$，$s_{d} = 1.2$，$s_{e} = 2.0$。\n$$S = \\frac{1}{\\frac{0.24}{1.5} + \\frac{0.19}{1.2} + \\frac{0.37}{2.0} + 0.20}$$\n我们计算分母中的各项：\n$\\frac{0.24}{1.5} = 0.16$\n$\\frac{0.19}{1.2} = \\frac{19}{120} \\approx 0.15833...$\n$\\frac{0.37}{2.0} = 0.185$\n分母中的和为：\n$0.16 + \\frac{19}{120} + 0.185 + 0.20 = 0.545 + \\frac{19}{120} = \\frac{545}{1000} + \\frac{19}{120} = \\frac{109}{200} + \\frac{19}{120} = \\frac{327+95}{600} = \\frac{422}{600} = \\frac{211}{300}$。\n所以，总体加速比为：\n$$S = \\frac{1}{\\frac{211}{300}} = \\frac{300}{211} \\approx 1.4218009...$$\n四舍五入到4位有效数字，$S \\approx 1.422$。\n\n我们接着推导弹性 $E_{i}$，定义为 $E_{i} \\equiv \\left(\\frac{s_{i}}{S}\\right)\\frac{\\partial S}{\\partial s_{i}}$，其中 $i \\in \\{f,d,e\\}$。\n我们首先需要 $S$ 对于一个通用阶段加速比 $s_{i}$ 的偏导数。设 $S$ 的分母为 $D$，因此 $S = D^{-1}$，其中 $D = \\frac{f_{f}}{s_{f}} + \\frac{f_{d}}{s_{d}} + \\frac{f_{e}}{s_{e}} + f_{o}$。\n使用链式求导法则：\n$$\\frac{\\partial S}{\\partial s_{i}} = \\frac{d S}{d D} \\frac{\\partial D}{\\partial s_{i}}$$\n$S$ 对 $D$ 的导数为 $\\frac{dS}{dD} = -D^{-2} = -S^2$。\n$D$ 对 $s_{i}$ 的偏导数为：\n$$\\frac{\\partial D}{\\partial s_{i}} = \\frac{\\partial}{\\partial s_{i}} \\left( \\frac{f_{i}}{s_{i}} \\right) = f_{i} \\frac{\\partial}{\\partial s_{i}} (s_{i}^{-1}) = f_{i} (-1 \\cdot s_{i}^{-2}) = -\\frac{f_{i}}{s_{i}^2}$$\n综合这些结果：\n$$\\frac{\\partial S}{\\partial s_{i}} = (-S^2) \\left(-\\frac{f_{i}}{s_{i}^2}\\right) = \\frac{S^2 f_{i}}{s_{i}^2}$$\n现在，我们将此代入弹性的定义中：\n$$E_{i} = \\left(\\frac{s_{i}}{S}\\right) \\frac{\\partial S}{\\partial s_{i}} = \\left(\\frac{s_{i}}{S}\\right) \\left(\\frac{S^2 f_{i}}{s_{i}^2}\\right) = \\frac{S f_{i}}{s_{i}}$$\n这就是弹性的闭式表达式。该表达式代表了组件 $i$ 在新执行时间中所占的比例，直观地反映了其对整体性能的影响力。$E_i$ 的值越大，意味着总体加速比对 $s_i$ 的变化越敏感。\n\n最后，我们使用先前计算出的精确值 $S = \\frac{300}{211}$，在给定设计点上计算弹性 $E_{f}$，$E_{d}$ 和 $E_{e}$。\n\n对于指令提取（$i=f$）：\n$$E_{f} = S \\frac{f_{f}}{s_{f}} = \\left(\\frac{300}{211}\\right) \\frac{0.24}{1.5} = \\left(\\frac{300}{211}\\right) (0.16) = \\frac{300}{211} \\left(\\frac{16}{100}\\right) = \\frac{48}{211} \\approx 0.227488...$$\n四舍五入到4位有效数字，$E_{f} \\approx 0.2275$。\n\n对于指令解码（$i=d$）：\n$$E_{d} = S \\frac{f_{d}}{s_{d}} = \\left(\\frac{300}{211}\\right) \\frac{0.19}{1.2} = \\left(\\frac{300}{211}\\right) \\left(\\frac{19}{120}\\right) = \\frac{300 \\cdot 19}{211 \\cdot 120} = \\frac{5 \\cdot 19}{211 \\cdot 2} = \\frac{95}{422} \\approx 0.225118...$$\n四舍五入到4位有效数字，$E_{d} \\approx 0.2251$。\n\n对于指令执行（$i=e$）：\n$$E_{e} = S \\frac{f_{e}}{s_{e}} = \\left(\\frac{300}{211}\\right) \\frac{0.37}{2.0} = \\left(\\frac{300}{211}\\right) (0.185) = \\frac{300}{211} \\left(\\frac{185}{1000}\\right) = \\frac{3 \\cdot 185}{211 \\cdot 10} = \\frac{555}{2110} = \\frac{111}{422} \\approx 0.263033...$$\n四舍五入到4位有效数字，$E_{e} \\approx 0.2630$。\n\n将最终结果整理成所要求的行向量。\n$S \\approx 1.422$\n$E_{f} \\approx 0.2275$\n$E_{d} \\approx 0.2251$\n$E_{e} \\approx 0.2630$", "answer": "$$\\boxed{\\begin{pmatrix} 1.422 & 0.2275 & 0.2251 & 0.2630 \\end{pmatrix}}$$", "id": "3628775"}, {"introduction": "在现代计算中，尤其是在处理大数据和科学计算任务时，性能瓶颈常常不在于处理器的计算速度，而在于内存系统的访问带宽。Roofline模型是一个直观而强大的可视化工具，用于理解计算能力与内存带宽之间的平衡关系。本练习 [@problem_id:3628699] 将带你运用Roofline模型的核心思想，计算出处理器的“临界算术强度”。这个关键值标志着一个程序从“访存密集型”转变为“计算密集型”的转折点，是指导现代程序性能优化的重要依据。", "problem": "使用 roofline 性能模型对单插槽处理器进行评估。该处理器在流式访问下的峰值双精度吞吐量为 $3500$ GFLOPS（每秒十亿次浮点运算），持续内存带宽为 $560$ GB/s（每秒千兆字节）。考虑一个计算核心，其算术强度为 $I$ FLOP/byte（每次浮点运算/字节）。利用吞吐量、带宽和算术强度的第一性原理定义，以及 roofline 模型中可实现吞吐量受限于首先饱和的资源这一概念性陈述，推导临界算术强度 $I^{\\ast}$，在该强度下，核心从内存受限（memory-bound）过渡到计算受限（compute-bound）。然后，为给定的处理器计算 $I^{\\ast}$ 的数值。将最终结果四舍五入到四位有效数字。以 FLOP/byte 为单位表示最终答案。", "solution": "问题陈述已经过评估并被认为是有效的。它在科学上基于计算机体系结构的原理，特别是使用 roofline 模型的性能建模。所提供的数据是现实的，并且问题定义明确、客观、完整，可以推导出唯一且有意义的解。\n\n任务是为一个以峰值浮点吞吐量和持续内存带宽为特征的处理器推导临界算术强度 $I^{\\ast}$，然后计算其数值。Roofline 模型假设，可实现的性能 $\\pi$ 受两个主要因素制约：处理器的峰值计算速率和内存系统的带宽。\n\n我们用符号定义给定的量：\n- 处理器的峰值双精度吞吐量为 $\\pi_{\\text{peak}}$。\n- 持续内存带宽为 $\\beta$。\n- 计算核心的算术强度为 $I$。\n\n这些量的单位如下：\n- $\\pi_{\\text{peak}}$ 的单位是每秒浮点运算次数 (FLOP/s)。\n- $\\beta$ 的单位是每秒字节数 (B/s)。\n- $I$ 的单位是每次浮点运算/字节 (FLOP/byte)。\n\n根据 roofline 模型，算术强度为 $I$ 的核心可达到的性能 $\\pi(I)$ 是两个性能限制值中的较小者：计算受限性能和内存受限性能。\n\n$1$. **计算受限性能**：核心的性能永远不能超过处理器的峰值吞吐量。这代表了一个硬性限制，在 roofline 图中表现为一条“水平屋顶”。\n$$ \\pi_{\\text{compute}} = \\pi_{\\text{peak}} $$\n\n$2$. **内存受限性能**：核心的性能也可能受限于从内存中获取数据的速率。为了维持一定的吞吐量 $\\pi$，必须以相应的速率从内存向核心提供数据。对于一个算术强度为 $I$ 的核心，从内存传输的每个字节对应于 $I$ 次浮点运算。如果内存系统能以最大速率 $\\beta$ 字节/秒提供数据，那么内存系统能支持的最大性能就是算术强度与内存带宽的乘积。这在 roofline 图中表现为一条“倾斜屋顶”。\n$$ \\pi_{\\text{memory}}(I) = I \\times \\beta $$\n\n因此，总的可达到性能由组合模型给出：\n$$ \\pi(I) = \\min(\\pi_{\\text{peak}}, I \\times \\beta) $$\n\n如果一个核心的性能受限于内存带宽，即 $I \\times \\beta  \\pi_{\\text{peak}}$，则认为该核心是**内存受限**的。相反，如果核心的性能受限于处理器的峰值吞吐量，即 $I \\times \\beta \\geq \\pi_{\\text{peak}}$，则认为该核心是**计算受限**的。\n\n**临界算术强度**，记为 $I^{\\ast}$，是系统从内存受限过渡到计算受限时的特定 $I$ 值。这个过渡点，即 roofline 图的“拐点”，是两个性能限制相等的地方。\n$$ \\pi_{\\text{memory}}(I^{\\ast}) = \\pi_{\\text{compute}} $$\n代入两个限制的表达式：\n$$ I^{\\ast} \\times \\beta = \\pi_{\\text{peak}} $$\n求解 $I^{\\ast}$ 得到符号推导：\n$$ I^{\\ast} = \\frac{\\pi_{\\text{peak}}}{\\beta} $$\n\n现在，我们使用问题陈述中给出的数值来计算该表达式。\n给定的值为：\n- 峰值吞吐量：$\\pi_{\\text{peak}} = 3500 \\text{ GFLOPS} = 3500 \\times 10^{9} \\text{ FLOP/s}$\n- 内存带宽：$\\beta = 560 \\text{ GB/s} = 560 \\times 10^{9} \\text{ bytes/s}$\n\n将这些值代入推导出的 $I^{\\ast}$ 公式中：\n$$ I^{\\ast} = \\frac{3500 \\times 10^{9} \\text{ FLOP/s}}{560 \\times 10^{9} \\text{ bytes/s}} $$\n分子和分母中的因子 $10^{9}$ 相互抵消，将表达式简化为数值系数的比值。单位正确地组合为 FLOP/byte。\n$$ I^{\\ast} = \\frac{3500}{560} \\text{ FLOP/byte} $$\n执行除法运算：\n$$ I^{\\ast} = \\frac{350}{56} = \\frac{50}{8} = \\frac{25}{4} = 6.25 \\text{ FLOP/byte} $$\n问题要求将最终答案四舍五入到四位有效数字。计算出的值 $6.25$ 有三位有效数字。为了用四位有效数字表示，我们添加一个尾随零。\n$$ I^{\\ast} = 6.250 \\text{ FLOP/byte} $$\n这个值代表了机器的平衡点。算术强度小于 $6.250$ 的核心将受到内存带宽的瓶颈限制，而强度大于 $6.250$ 的核心将受到处理器计算能力的瓶颈限制。", "answer": "$$\\boxed{6.250}$$", "id": "3628699"}]}