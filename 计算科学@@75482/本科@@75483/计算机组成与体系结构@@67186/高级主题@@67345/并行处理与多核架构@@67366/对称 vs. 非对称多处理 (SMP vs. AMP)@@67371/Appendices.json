{"hands_on_practices": [{"introduction": "要理解对称多处理（SMP）和非对称多处理（AMP）设计之间的根本权衡，我们可以从一个高层次的性能模型入手。本练习使用基于阿姆达尔定律（Amdahl's Law）的简化模型，比较一个能加速特定类型工作的AMP系统与一个能并行化通用工作的SMP系统。通过推导它们的加速比之比 [@problem_id:3683281]，你将建立一种量化直觉，理解何时一种架构会因工作负载特性的不同而优于另一种。", "problem": "一个单程序工作负载将在相同的技术和功耗预算下，于两种可选的多核组织结构上运行。结构A是一个非对称多处理器（AMP），它包含一个“大”核，用于加速单指令多数据（SIMD）可向量化操作，其余核心是与基准单核参考相同的基准核心。结构B是一个对称多处理器（SMP），它包含 $p$ 个相同的基准核心，但没有SIMD加速功能。\n\n假设如下：\n- 程序的基准单核执行时间为 $T_{1}$。\n- 程序的指令混合中，有一部分比例 $f_{vec}$ 是可进行SIMD向量化的，并且仅在AMP的大核上获得理想的 $k_{v}$ 加速因子收益，而其余的 $1 - f_{vec}$ 部分则无法从SIMD加速中受益。\n- 在SMP上，程序中（可能不同的）一部分比例 $f_{par}$ 可以在 $p$ 个相同的基准核心上理想地并行化，而其余的 $1 - f_{par}$ 部分是固有的串行部分，在单个核心上运行。\n- 忽略所有由同步、通信、调度和内存系统效应引起的开销；假设并行部分的负载均衡是完美的，向量化部分的SIMD加速是理想的。所有基准核心以相同的频率运行，并具有与基准单核参考相同的每指令性能；大核的不同之处仅在于为可向量化部分提供了 $k_{v}$ 的SIMD加速因子。\n\n从执行时间是不相交代码部分的总和，以及加速比定义为基准时间除以优化后时间的定义出发，推导出一个封闭形式的表达式，并尽可能简化，用于表示比率\n$$R \\equiv \\frac{S_{AMP}}{S_{SMP}},$$\n其中 $S_{AMP}$ 是程序在大核上运行时AMP的加速比，$S_{SMP}$ 是程序在 $p$ 个核心上以理想并行化方式运行时SMP的加速比。请以一个关于 $f_{vec}$、$k_{v}$、$f_{par}$ 和 $p$ 的单一解析表达式的形式给出你的最终答案。", "solution": "在尝试任何解答之前，首先对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 基准单核执行时间：$T_{1}$\n- 系统A（AMP）：带有一个“大”核的非对称多处理器。\n- 系统B（SMP）：带有 $p$ 个相同基准核心的对称多处理器。\n- AMP程序特性：程序中比例为 $f_{vec}$ 的部分是可SIMD向量化的，并在大核上以因子 $k_{v}$ 加速。剩余比例 $1 - f_{vec}$ 不被加速。指定程序在大核上运行。\n- SMP程序特性：程序中比例为 $f_{par}$ 的部分可在 $p$ 个核心上理想地并行化。剩余比例 $1 - f_{par}$ 是固有的串行部分。\n- 假设：忽略所有开销；负载均衡和加速是理想的。\n- 定义：执行时间是不相交代码部分的总和。加速比 $S$ 定义为基准时间除以优化后时间，$S = T_{baseline} / T_{optimized}$。\n- 目标：推导比率 $R \\equiv \\frac{S_{AMP}}{S_{SMP}}$ 的封闭形式表达式，用 $f_{vec}$、$k_{v}$、$f_{par}$ 和 $p$ 表示。\n\n**第2步：使用提取的已知条件进行验证**\n该问题被评估为**有效**。它提出了一个基于阿姆达尔定律（Amdahl's Law）的、结构良好且有科学依据的场景，阿姆达尔定律是计算机体系结构中用于建模性能加速的基本原则。AMP和SMP这两种系统是常见的体系结构范式。使用代码比例（$f_{vec}$、$f_{par}$）和加速因子（$k_v$、$p$）是此类分析的标准方法。这些假设虽然是理想化的（例如，零开销），但被明确陈述以定义一个简化但连贯的理论模型，这在学术问题中是常见且有效的做法。该问题是自包含的、客观的、逻辑一致的，并且有一个清晰且唯一可确定的目标。\n\n**第3步：求解推导**\n推导过程首先计算每个系统的执行时间及相应的加速比，然后计算它们的比率。\n\n设 $T_{1}$ 为程序在单个基准核心上的执行时间。\n\n首先，我们分析非对称多处理器（AMP）的配置。问题陈述程序在大核上运行。程序包含可向量化的部分（比例为 $f_{vec}$）和不可向量化的部分（比例为 $1 - f_{vec}$）。不可向量化部分在大核上的执行时间与在基准核心上相同，为 $(1 - f_{vec}) T_{1}$。可向量化部分被因子 $k_{v}$ 加速，因此其在大核上的执行时间为 $\\frac{f_{vec} T_{1}}{k_{v}}$。在AMP上的总执行时间 $T_{AMP}$ 是这两个不相交部分的时间总和：\n$$T_{AMP} = (1 - f_{vec}) T_{1} + \\frac{f_{vec} T_{1}}{k_{v}}$$\n提取公因式 $T_{1}$，我们得到：\n$$T_{AMP} = T_{1} \\left( 1 - f_{vec} + \\frac{f_{vec}}{k_{v}} \\right)$$\nAMP的加速比 $S_{AMP}$ 是基准时间 $T_{1}$ 与优化后时间 $T_{AMP}$ 的比值：\n$$S_{AMP} = \\frac{T_{1}}{T_{AMP}} = \\frac{T_{1}}{T_{1} \\left( 1 - f_{vec} + \\frac{f_{vec}}{k_{v}} \\right)} = \\frac{1}{1 - f_{vec} + \\frac{f_{vec}}{k_{v}}}$$\n\n接下来，我们分析对称多处理器（SMP）的配置。程序有一个串行部分（比例为 $1 - f_{par}$）和一个可并行化部分（比例为 $f_{par}$）。串行部分在单个核心上运行，其执行时间为 $(1 - f_{par}) T_{1}$。可并行化部分理想地分布在 $p$ 个核心上，因此其执行时间为 $\\frac{f_{par} T_{1}}{p}$。在SMP上的总执行时间 $T_{SMP}$ 是串行和并行阶段的时间总和：\n$$T_{SMP} = (1 - f_{par}) T_{1} + \\frac{f_{par} T_{1}}{p}$$\n提取公因式 $T_{1}$：\n$$T_{SMP} = T_{1} \\left( 1 - f_{par} + \\frac{f_{par}}{p} \\right)$$\nSMP的加速比 $S_{SMP}$ 是基准时间 $T_{1}$ 与优化后时间 $T_{SMP}$ 的比值：\n$$S_{SMP} = \\frac{T_{1}}{T_{SMP}} = \\frac{T_{1}}{T_{1} \\left( 1 - f_{par} + \\frac{f_{par}}{p} \\right)} = \\frac{1}{1 - f_{par} + \\frac{f_{par}}{p}}$$\n\n最后，我们计算所需的比率，$R \\equiv \\frac{S_{AMP}}{S_{SMP}}$：\n$$R = \\frac{S_{AMP}}{S_{SMP}} = \\frac{\\frac{1}{1 - f_{vec} + \\frac{f_{vec}}{k_{v}}}}{\\frac{1}{1 - f_{par} + \\frac{f_{par}}{p}}}$$\n这可以简化为分母的倒数之比：\n$$R = \\frac{1 - f_{par} + \\frac{f_{par}}{p}}{1 - f_{vec} + \\frac{f_{vec}}{k_{v}}}$$\n为了进一步简化此表达式并消除复合分数，我们可以为主要分数中的分子和分母找到公分母。\n分子变为：\n$$1 - f_{par} + \\frac{f_{par}}{p} = \\frac{p(1 - f_{par}) + f_{par}}{p} = \\frac{p - p f_{par} + f_{par}}{p} = \\frac{p - f_{par}(p - 1)}{p}$$\n分母变为：\n$$1 - f_{vec} + \\frac{f_{vec}}{k_{v}} = \\frac{k_{v}(1 - f_{vec}) + f_{vec}}{k_{v}} = \\frac{k_{v} - k_{v} f_{vec} + f_{vec}}{k_{v}} = \\frac{k_{v} - f_{vec}(k_{v} - 1)}{k_{v}}$$\n将这些代回 $R$ 的表达式中：\n$$R = \\frac{\\frac{p - f_{par}(p - 1)}{p}}{\\frac{k_{v} - f_{vec}(k_{v} - 1)}{k_{v}}}$$\n这简化为最终的封闭形式表达式：\n$$R = \\frac{k_{v} [p - f_{par}(p - 1)]}{p[k_{v} - f_{vec}(k_{v} - 1)]}$$\n该表达式给出了在指定的理想化条件下，AMP系统相对于SMP系统的性能比率。", "answer": "$$\\boxed{\\frac{k_{v} [p - f_{par}(p - 1)]}{p [k_{v} - f_{vec}(k_{v} - 1)]}}$$", "id": "3683281"}, {"introduction": "在宏观的加速比模型之上，深入微架构层面进行分析同样重要。本练习将分析的粒度从抽象的加速因子推进到更具体的微架构参数，如基础CPI（每指令周期数）和内存延迟。通过计算混合工作负载在SMP和AMP系统上的加权平均CPI [@problem_id:3683318]，你将看到将工作负载特性（如内存访问密集度）与核心的专业化设计（如大核的低延迟缓存）相匹配，对于优化整体性能是何等关键。", "problem": "一个研究团队正在使用一个基于每指令周期数（CPI）和每千条指令未命中数（MPKI）定义的第一性原理分析模型，来比较对称多处理（SMP）与非对称多处理（AMP）。请使用以下定义作为推导的基础：CPI 定义为每条已退役指令的平均处理器周期数；MPKI 定义为每 $1000$ 条已退役指令的末级缓存未命中次数；每次末级缓存未命中会产生 $L$ 个周期的停顿，该停顿不与其它工作重叠。\n\n将执行两个工作负载 $W_{A}$ 和 $W_{B}$。工作负载参数如下：\n- $W_{A}$：MPKI $= 8$，指令数 $I_{A} = 2.0 \\times 10^{9}$。\n- $W_{B}$：MPKI $= 30$，指令数 $I_{B} = 1.0 \\times 10^{9}$。\n\n系统配置：\n- 对称多处理（SMP）：两个相同的核心，每个核心的基础CPI（即在完美缓存情况下的CPI）为 $CPI_{\\text{base,SMP}} = 0.7$，末级缓存未命中停顿延迟为 $L_{\\text{SMP}} = 120$ 个周期。\n- 非对称多处理（AMP）：一个大核和一个小核。大核的基础CPI为 $CPI_{\\text{base,big}} = 0.5$，未命中停顿延迟为 $L_{\\text{big}} = 80$ 个周期。小核的基础CPI为 $CPI_{\\text{base,small}} = 0.9$，未命中停顿延迟为 $L_{\\text{small}} = 140$ 个周期。\n\n执行策略：\n- 在SMP系统上，$W_{A}$ 和 $W_{B}$ 各自在一个相同的核心上运行，因此两个工作负载经历相同的 $CPI_{\\text{base,SMP}}$ 和 $L_{\\text{SMP}}$。\n- 在AMP系统上，$W_{B}$ 在大核上运行，$W_{A}$ 在小核上运行，直至其执行结束。\n\n假设：\n- 除了基础CPI外，唯一的停顿来源是末级缓存未命中。\n- 未命中停顿延迟 $L$ 是完全暴露的（无重叠），并且由未命中导致的每指令额外周期数直接遵循MPKI和 $L$ 的定义。\n- 忽略频率缩放，并假设所有CPI都在同一周期域中测量。\n\n任务：\n1. 仅从上述定义出发，推导在SMP系统和AMP系统下，每个工作负载的每核心CPI。\n2. 设一个配置的指令加权平均CPI定义为 $$\\overline{\\text{CPI}} \\equiv \\frac{CPI_{A}\\,I_{A} + CPI_{B}\\,I_{B}}{I_{A} + I_{B}},$$ 其中 $CPI_{A}$ 和 $CPI_{B}$ 是该配置下 $W_{A}$ 和 $W_{B}$ 的CPI。计算比率 $$R \\equiv \\frac{\\overline{\\text{CPI}}_{\\text{SMP}}}{\\overline{\\text{CPI}}_{\\text{AMP}}}.$$\n\n将 $R$ 的最终值以单个实数形式给出，四舍五入至四位有效数字。无需单位。", "solution": "该问题要求通过计算给定工作负载组合的指令加权平均每指令周期数（CPI），对对称多处理（SMP）和非对称多处理（AMP）系统进行比较分析。解法将从所提供的第一性原理推导得出。\n\n首先，我们必须建立一个核心总CPI的通用公式。问题陈述，总CPI是基础CPI $CPI_{\\text{base}}$ 和一个停顿分量 $CPI_{\\text{stall}}$ 的和，该停顿分量完全由末级缓存未命中引起。\n$$CPI = CPI_{\\text{base}} + CPI_{\\text{stall}}$$\n停顿分量 $CPI_{\\text{stall}}$ 代表每条指令的平均停顿周期数。这可以从提供的定义中推导出来：\n- MPKI（每千条指令未命中数）是每 $1000$ 条指令的未命中次数。\n- $L$ 是每次未命中的延迟周期数。\n\n因此，每条指令的未命中率是 $\\frac{\\text{MPKI}}{1000}$。由于每次未命中会产生 $L$ 个周期的惩罚，每条指令的平均停顿周期数就是未命中率与未命中延迟的乘积。\n$$CPI_{\\text{stall}} = \\left(\\frac{\\text{MPKI}}{1000}\\right) \\times L$$\n综合这些，总CPI的完整公式是：\n$$CPI = CPI_{\\text{base}} + \\frac{\\text{MPKI} \\times L}{1000}$$\n该公式将用于完成问题的第一个任务。\n\n**任务1：每核心CPI计算**\n\n现在我们将应用此公式计算每个工作负载（$W_{A}$, $W_{B}$）在每个系统配置（SMP, AMP）上的CPI。\n\n**对称多处理（SMP）系统：**\n对于SMP系统，两个核心是相同的，其基础CPI为 $CPI_{\\text{base,SMP}} = 0.7$，未命中延迟为 $L_{\\text{SMP}} = 120$ 个周期。工作负载的特征为 $MPKI_{A} = 8$ 和 $MPKI_{B} = 30$。\n\n工作负载 $W_{A}$ 在SMP系统上的CPI（$CPI_{A, \\text{SMP}}$）为：\n$$CPI_{A, \\text{SMP}} = CPI_{\\text{base,SMP}} + \\frac{MPKI_{A} \\times L_{\\text{SMP}}}{1000} = 0.7 + \\frac{8 \\times 120}{1000} = 0.7 + \\frac{960}{1000} = 0.7 + 0.96 = 1.66$$\n\n工作负载 $W_{B}$ 在SMP系统上的CPI（$CPI_{B, \\text{SMP}}$）为：\n$$CPI_{B, \\text{SMP}} = CPI_{\\text{base,SMP}} + \\frac{MPKI_{B} \\times L_{\\text{SMP}}}{1000} = 0.7 + \\frac{30 \\times 120}{1000} = 0.7 + \\frac{3600}{1000} = 0.7 + 3.6 = 4.3$$\n\n**非对称多处理（AMP）系统：**\n对于AMP系统，工作负载 $W_{A}$ 在小核上运行，而 $W_{B}$ 在大核上运行。核心参数是不同的。\n- 小核（用于 $W_{A}$）：基础CPI为 $CPI_{\\text{base,small}} = 0.9$，延迟为 $L_{\\text{small}} = 140$ 个周期。\n- 大核（用于 $W_{B}$）：基础CPI为 $CPI_{\\text{base,big}} = 0.5$，延迟为 $L_{\\text{big}} = 80$ 个周期。\n\n工作负载 $W_{A}$ 在AMP系统上的CPI（$CPI_{A, \\text{AMP}}$）为：\n$$CPI_{A, \\text{AMP}} = CPI_{\\text{base,small}} + \\frac{MPKI_{A} \\times L_{\\text{small}}}{1000} = 0.9 + \\frac{8 \\times 140}{1000} = 0.9 + \\frac{1120}{1000} = 0.9 + 1.12 = 2.02$$\n\n工作负载 $W_{B}$ 在AMP系统上的CPI（$CPI_{B, \\text{AMP}}$）为：\n$$CPI_{B, \\text{AMP}} = CPI_{\\text{base,big}} + \\frac{MPKI_{B} \\times L_{\\text{big}}}{1000} = 0.5 + \\frac{30 \\times 80}{1000} = 0.5 + \\frac{2400}{1000} = 0.5 + 2.4 = 2.9$$\n\n**任务2：计算比率 $R$**\n\n第二个任务是计算比率 $R \\equiv \\frac{\\overline{\\text{CPI}}_{\\text{SMP}}}{\\overline{\\text{CPI}}_{\\text{AMP}}}$。指令加权平均CPI $\\overline{\\text{CPI}}$ 由以下公式给出：\n$$\\overline{\\text{CPI}} = \\frac{CPI_{A}\\,I_{A} + CPI_{B}\\,I_{B}}{I_{A} + I_{B}}$$\n指令数分别为 $I_{A} = 2.0 \\times 10^{9}$ 和 $I_{B} = 1.0 \\times 10^{9}$。\n\n首先，我们使用为SMP系统推导出的CPI值计算 $\\overline{\\text{CPI}}_{\\text{SMP}}$：\n$$\\overline{\\text{CPI}}_{\\text{SMP}} = \\frac{CPI_{A, \\text{SMP}} \\times I_{A} + CPI_{B, \\text{SMP}} \\times I_{B}}{I_{A} + I_{B}}$$\n$$\\overline{\\text{CPI}}_{\\text{SMP}} = \\frac{(1.66) \\times (2.0 \\times 10^{9}) + (4.3) \\times (1.0 \\times 10^{9})}{2.0 \\times 10^{9} + 1.0 \\times 10^{9}}$$\n$$\\overline{\\text{CPI}}_{\\text{SMP}} = \\frac{(1.66 \\times 2.0 + 4.3 \\times 1.0) \\times 10^{9}}{3.0 \\times 10^{9}} = \\frac{3.32 + 4.3}{3.0} = \\frac{7.62}{3.0} = 2.54$$\n\n接下来，我们使用为AMP系统推导出的CPI值计算 $\\overline{\\text{CPI}}_{\\text{AMP}}$：\n$$\\overline{\\text{CPI}}_{\\text{AMP}} = \\frac{CPI_{A, \\text{AMP}} \\times I_{A} + CPI_{B, \\text{AMP}} \\times I_{B}}{I_{A} + I_{B}}$$\n$$\\overline{\\text{CPI}}_{\\text{AMP}} = \\frac{(2.02) \\times (2.0 \\times 10^{9}) + (2.9) \\times (1.0 \\times 10^{9})}{2.0 \\times 10^{9} + 1.0 \\times 10^{9}}$$\n$$\\overline{\\text{CPI}}_{\\text{AMP}} = \\frac{(2.02 \\times 2.0 + 2.9 \\times 1.0) \\times 10^{9}}{3.0 \\times 10^{9}} = \\frac{4.04 + 2.9}{3.0} = \\frac{6.94}{3.0}$$\n\n最后，我们计算比率 $R$：\n$$R = \\frac{\\overline{\\text{CPI}}_{\\text{SMP}}}{\\overline{\\text{CPI}}_{\\text{AMP}}} = \\frac{2.54}{\\frac{6.94}{3.0}} = \\frac{2.54 \\times 3.0}{6.94} = \\frac{7.62}{6.94}$$\n$$R \\approx 1.0979827089...$$\n根据要求，$R$ 的值必须四舍五入到四位有效数字。\n$$R \\approx 1.098$$", "answer": "$$\\boxed{1.098}$$", "id": "3683318"}, {"introduction": "非对称架构为软件，特别是操作系统调度器，带来了新的挑战和机遇。本练习模拟了一个根本性的调度决策：考虑到任务迁移带来的开销，何时将一个任务“卸载”到一个更快的“大核”上执行才是值得的？通过推导决定这一决策的临界内核大小 [@problem_id:3683271]，你将学习如何用数学方式形式化地表达这类权衡，这是为异构系统设计智能调度器的一项关键技能。", "problem": "考虑一个融合了对称多处理 (Symmetric Multiprocessing, SMP) 和非对称多处理 (Asymmetric Multiprocessing, AMP) 设计思想的多核系统。该系统有两个核心：一个“小”核和一个“大”核。从非对称多处理 (AMP) 的角度来看，只有“大”核实现了专门的指令集架构 (Instruction Set Architecture, ISA) 扩展，用以加速一个特定的内核。“小”核缺少这些 ISA 扩展，只能执行基线内核实现。\n\n假设以下基于第一性原理且有科学依据的性能模型：\n- 内核由 $n$ 个符合扩展条件的运算组成。\n- “小”核以 $\\mu$ 运算/秒的基线服务速率执行。\n- “大”核在运行经 ISA 加速的内核时，相对于“小”核获得一个为 $k$ 的乘法加速因子，因此其服务速率为 $k \\mu$，其中 $k > 1$。\n- 将内核卸载到“大”核需要一个一次性的固定复制和设置开销 $T_{\\text{copy}}$（以秒为单位），该开销涵盖了代码/数据移动和启动开销。此开销与 $n$ 无关。\n- 忽略排队、竞争和干扰；假设内核在任何一个运行它的核心上都是专用执行。\n\n仅使用“完成时间等于工作量除以服务速率再加上任何固定开销”这一基本关系，定义卸载“有益”的条件为：与在“小”核上本地执行相比，卸载到“大”核的总完成时间严格更小。推导出使得卸载有益的最小内核大小 $n^{\\*}$（以运算为单位）的精确闭式符号表达式。最终答案仅用 $k$、$\\mu$ 和 $T_{\\text{copy}}$ 表示。无需进行数值计算，也不允许四舍五入。报告 $n^{\\*}$ 的单位为运算（指令）。", "solution": "该问题对比了核心相同的对称多处理 (SMP) 和核心不同的非对称多处理 (AMP)。在此系统中，只有“大”核拥有专门的指令集架构 (ISA) 扩展，这使其在处理给定内核时具有非对称优势。我们使用“完成时间等于工作量除以服务速率再加上任何固定开销”这一定律来对执行进行建模。\n\n设内核包含 $n$ 个符合扩展条件的运算。“小”核以 $\\mu$ 运算/秒的速率执行，因此在“小”核上的本地执行时间为\n$$\nT_{\\text{local}} = \\frac{n}{\\mu}.\n$$\n如果内核被卸载到“大”核，会产生用于复制和设置代码/数据的固定开销 $T_{\\text{copy}}$。由于 ISA 扩展，“大”核以 $k \\mu$ 运算/秒的速率执行内核。因此，卸载后的总完成时间为\n$$\nT_{\\text{offload}} = T_{\\text{copy}} + \\frac{n}{k \\mu}.\n$$\n\n如果卸载后的总完成时间严格小于本地执行时间，则卸载“有益”：\n$$\nT_{\\text{offload}}  T_{\\text{local}}.\n$$\n代入表达式：\n$$\nT_{\\text{copy}} + \\frac{n}{k \\mu}  \\frac{n}{\\mu}.\n$$\n重新整理，将含 $n$ 的项分离到右侧：\n$$\nT_{\\text{copy}}  \\frac{n}{\\mu} - \\frac{n}{k \\mu} = \\frac{n}{\\mu}\\left(1 - \\frac{1}{k}\\right).\n$$\n解出 $n$：\n$$\nn > \\mu T_{\\text{copy}} \\cdot \\frac{1}{1 - \\frac{1}{k}}.\n$$\n注意到 $1 - \\frac{1}{k} = \\frac{k - 1}{k}$，因此\n$$\nn > \\mu T_{\\text{copy}} \\cdot \\frac{k}{k - 1}.\n$$\n卸载开始有益的最小内核大小 $n^{\\*}$（即当等式成立，两个完成时间相等时）为\n$$\nn^{\\*} = \\frac{k \\mu T_{\\text{copy}}}{k - 1}.\n$$\n\n此结果与直观的权衡相符：更大的 $k$（更大的加速比）或更大的 $\\mu$（更高的基线速率）会降低以时间单位计的阈值，但由于 $n^{\\*}$ 是以运算为单位的，它与 $\\mu T_{\\text{copy}}$ 成比例增长，并按 $\\frac{k}{k - 1}$ 的比例缩放，这反映了随着 $k$ 的增大，收益递减的规律。最终表达式以 $k$、$\\mu$ 和 $T_{\\text{copy}}$ 的形式给出了精确的符号阈值。", "answer": "$$\\boxed{\\frac{k \\mu T_{\\text{copy}}}{k - 1}}$$", "id": "3683271"}]}