{"hands_on_practices": [{"introduction": "本练习提供了一个关于非均匀内存访问 (NUMA) 性能影响的鲜明而直观的演示。通过分析链表遍历——一种对延迟极其敏感的操作——我们可以直接量化远程内存访问的成本，以及通过 NUMA 感知的内存布局所带来的显著加速。[@problem_id:3686974]", "problem": "一个双插槽非统一内存访问 (NUMA) 系统拥有插槽 $\\mathrm{S0}$ 和 $\\mathrm{S1}$，每个插槽都配有其自己的本地动态随机存取存储器 (DRAM)。一个单线程程序被绑定在 $\\mathrm{S0}$ 上运行。考虑遍历一个单链表，其节点大小为 $64$ 字节，并在 $64$ 字节的缓存行上对齐，因此，跟随每个节点的 $\\texttt{next}$ 指针会为下一个节点导致一次末级缓存未命中和一次 DRAM 访问。工作集远大于缓存，且硬件预取器无法预测指针追踪，因此内存级并行度实际上为 $1$（串行化的未命中）。\n\n在这台机器上，以下延迟已得到明确的表征：\n- 本地 DRAM 未命中延迟：当 $\\mathrm{S0}$ 上的线程访问分配在 $\\mathrm{S0}$ 上的内存时，$L_{\\mathrm{local}} = 90$ 纳秒。\n- 远程 DRAM 未命中延迟：当 $\\mathrm{S0}$ 上的线程通过插槽间互连访问分配在 $\\mathrm{S1}$ 上的内存时，$L_{\\mathrm{remote}} = 180$ 纳秒，该延迟包括一致性和目录开销。\n\n统一内存访问 (UMA) 指的是内存访问延迟与内存相对于处理器的位置无关的架构。相比之下，在 NUMA 架构中，访问延迟取决于内存是本地的还是远程的。\n\n构建以下病态糟糕的 NUMA 布局：对于 $i = 1, 2, \\dots, N$，如果 $i$ 是奇数，链表的节点 $i$ 分配在插槽 $\\mathrm{S0}$ 上；如果 $i$ 是偶数，则分配在插槽 $\\mathrm{S1}$ 上，其中头节点位于 $\\mathrm{S0}$。在这种布局下，平均而言，被遍历的节点中有一半是本地的，一半是远程的。\n\n从 UMA 和 NUMA 的核心定义以及“串行化指针追踪使得遍历时间等于各个访问延迟的总和”这一观察出发，推导在病态布局下每个节点的平均内存访问延迟 $L_{\\mathrm{avg,bad}}$ 的表达式。然后，提出一种重新设计方案，通过使用“首次接触”放置策略将所有链表节点分配在 $\\mathrm{S0}$ 上，以避免病态的交替分配，从而得到每个节点的平均延迟 $L_{\\mathrm{avg,good}}$。\n\n最后，计算重新设计的布局相对于病态布局的乘法加速比 $S$，其定义为\n$$\nS = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}.\n$$\n将 $S$ 以一个四位有效数字的实数形式给出。最终答案不需要单位；在你的推导中，所有中间延迟都应以纳秒为单位表示。假设 $N$ 足够大，以至于启动和收尾效应可以忽略不计，并且在遍历期间列表是只读的（没有写入操作），因此可以忽略由写入引起的一致性流量。将最终加速比表示为一个四位有效数字的无量纲数。", "solution": "用户要求我分析在非统一内存访问（NUMA）系统上，两种不同内存分配布局下链表遍历的性能，并计算优化布局相对于病态布局的加速比。\n\n首先，我将验证问题陈述。\n\n### 步骤 1：提取已知条件\n- 系统：双插槽 NUMA 系统，带插槽 $\\mathrm{S0}$ 和 $\\mathrm{S1}$。\n- 程序：单线程，绑定在 $\\mathrm{S0}$ 上运行。\n- 数据结构：单链表。\n- 节点大小：$64$ 字节，在 $64$ 字节缓存行上对齐。\n- 遍历特性：指针追踪导致每个节点一次末级缓存未命中和一次 DRAM 访问。工作集很大，硬件预取器无效。内存级并行度为 $1$。\n- 延迟：\n  - 本地 DRAM 未命中延迟: $L_{\\mathrm{local}} = 90$ 纳秒。\n  - 远程 DRAM 未命中延迟: $L_{\\mathrm{remote}} = 180$ 纳秒。\n- 病态布局：对于索引为 $i = 1, 2, \\dots, N$ 的 $N$ 个节点链表，如果 $i$ 为奇数，节点 $i$ 在插槽 $\\mathrm{S0}$ 上；如果 $i$ 为偶数，则在插槽 $\\mathrm{S1}$ 上。头节点（$i=1$）在 $\\mathrm{S0}$ 上。\n- 重新设计的布局：所有链表节点通过“首次接触”放置策略分配在 $\\mathrm{S0}$ 上。\n- 加速比定义: $S = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}$。\n- 假设：$N$ 足够大，可以忽略启动和收尾效应。遍历期间列表是只读的。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在科学上基于计算机体系结构的原理，特别是内存层次结构和多插槽处理器系统。NUMA、UMA、缓存未命中、指针追踪、内存级并行度以及像“首次接触”这样的内存放置策略都是标准且定义明确的概念。提供的延迟值（$L_{\\mathrm{local}} = 90 \\, \\text{ns}$，$L_{\\mathrm{remote}} = 180 \\, \\text{ns}$）对于现代服务器硬件是现实的，代表了 2 的 NUMA 因子。问题是适定的、客观的、自洽的，提供了推导唯一解所需的所有必要信息和假设。所描述的“病态”场景是用于说明 NUMA-非感知内存分配性能陷阱的经典例子。该问题不违反任何基本原则，没有歧义，并且可以使用提供的模型直接求解。\n\n### 步骤 3：结论与行动\n问题有效。我将继续进行推导和求解。\n\n问题的核心在于计算在两种不同场景下遍历单个节点的平均内存访问时间。问题指出，由于指针追踪，链表遍历是串行化的，这意味着对节点 $i+1$ 的访问必须在对节点 $i$ 的访问完成后才能开始。因此，$N$ 个节点的总遍历时间是每个节点各自内存访问延迟的总和。每个节点的平均延迟是这个总时间除以 $N$。\n\n首先，我们来分析病态的 NUMA 布局。线程在插槽 $\\mathrm{S0}$ 上执行。链表节点的内存分配在两个插槽之间交替进行：\n- 节点 $i=1$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=2$ 在 $\\mathrm{S1}$ 上（远程访问）。延迟为 $L_{\\mathrm{remote}}$。\n- 节点 $i=3$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=4$ 在 $\\mathrm{S1}$ 上（远程访问）。延迟为 $L_{\\mathrm{remote}}$。\n- ...以此类推。\n\n访问延迟的序列是 $L_{\\mathrm{local}}, L_{\\mathrm{remote}}, L_{\\mathrm{local}}, L_{\\mathrm{remote}}, \\dots$。\n由于节点数 $N$ 假定很大，我们可以忽略任何启动或收尾效应。在大量访问中，本地访问的次数将约等于远程访问的次数。具体来说，对于一个大的偶数 $N$，恰好有 $\\frac{N}{2}$ 次本地访问和 $\\frac{N}{2}$ 次远程访问。对于一个大的奇数 $N$，有 $\\frac{N+1}{2}$ 次本地访问和 $\\frac{N-1}{2}$ 次远程访问。在 $N \\to \\infty$ 的极限情况下，两种类型的访问各占总数的 $50\\%$。\n\n在病态布局下遍历 $N$ 个节点的总时间 $T_{\\mathrm{bad}}$ 为：\n$$T_{\\mathrm{bad}} \\approx \\frac{N}{2} \\cdot L_{\\mathrm{local}} + \\frac{N}{2} \\cdot L_{\\mathrm{remote}}$$\n每个节点的平均内存访问延迟 $L_{\\mathrm{avg,bad}}$ 是 $T_{\\mathrm{bad}}$ 除以 $N$：\n$$L_{\\mathrm{avg,bad}} = \\frac{T_{\\mathrm{bad}}}{N} = \\frac{\\frac{N}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})}{N} = \\frac{1}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})$$\n代入给定值 $L_{\\mathrm{local}} = 90 \\, \\text{ns}$ 和 $L_{\\mathrm{remote}} = 180 \\, \\text{ns}$：\n$$L_{\\mathrm{avg,bad}} = \\frac{1}{2} (90 \\, \\text{ns} + 180 \\, \\text{ns}) = \\frac{270}{2} \\, \\text{ns} = 135 \\, \\text{ns}$$\n\n接下来，我们分析重新设计的、NUMA 感知的布局。此布局使用“首次接触”放置策略。在这种策略中，操作系统在内存页首次被访问（写入或读取）的 NUMA 节点上分配该页。由于负责创建和遍历列表的单线程程序被绑定到插槽 $\\mathrm{S0}$，首次接触策略将确保链表节点的所有内存页都分配在 $\\mathrm{S0}$ 的本地内存上。\n\n因此，$\\mathrm{S0}$ 上的线程对链表节点的每次访问都将是本地内存访问。\n- 节点 $i=1$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- 节点 $i=2$ 在 $\\mathrm{S0}$ 上（本地访问）。延迟为 $L_{\\mathrm{local}}$。\n- ...对于所有 $N$ 个节点都是如此。\n\n在这种良好布局下遍历 $N$ 个节点的总时间 $T_{\\mathrm{good}}$ 为：\n$$T_{\\mathrm{good}} = N \\cdot L_{\\mathrm{local}}$$\n每个节点的平均内存访问延迟 $L_{\\mathrm{avg,good}}$ 是 $T_{\\mathrm{good}}$ 除以 $N$：\n$$L_{\\mathrm{avg,good}} = \\frac{T_{\\mathrm{good}}}{N} = \\frac{N \\cdot L_{\\mathrm{local}}}{N} = L_{\\mathrm{local}}$$\n代入给定值：\n$$L_{\\mathrm{avg,good}} = 90 \\, \\text{ns}$$\n\n最后，我们计算乘法加速比 $S$，即病态布局的平均延迟与重新设计布局的平均延迟之比。\n$$S = \\frac{L_{\\mathrm{avg,bad}}}{L_{\\mathrm{avg,good}}}$$\n代入推导出的表达式和值：\n$$S = \\frac{\\frac{1}{2} (L_{\\mathrm{local}} + L_{\\mathrm{remote}})}{L_{\\mathrm{local}}} = \\frac{L_{\\mathrm{local}} + L_{\\mathrm{remote}}}{2 \\cdot L_{\\mathrm{local}}}$$\n$$S = \\frac{135 \\, \\text{ns}}{90 \\, \\text{ns}} = \\frac{135}{90} = \\frac{3 \\times 45}{2 \\times 45} = \\frac{3}{2} = 1.5$$\n问题要求答案为一个四位有效数字的实数。\n$$S = 1.500$$\n1.500 的加速比表明，确保所有内存访问都是本地的 NUMA 感知布局，使得链表遍历比强制一半访问为远程的病态布局快了 $50\\%$。", "answer": "$$\\boxed{1.500}$$", "id": "3686974"}, {"introduction": "除了简单的访问延迟，NUMA 性能还与缓存一致性紧密相连。本练习通过比较结构体数组 (AoS) 和数组结构体 (SoA) 两种数据布局，探讨了“伪共享”这一微妙但严重的性能陷阱，揭示了数据组织方式如何能够显著减少昂贵的跨插槽通信。[@problem_id:3687062]", "problem": "考虑一个双插槽非统一内存访问 (NUMA) 系统。每个插槽都有私有缓存，系统采用一种基于目录的缓存一致性协议，该协议与“修改 (Modified)、独占 (Exclusive)、共享 (Shared)、无效 (Invalid)” (MESI) 状态一致。假设采用写-无效 (write-invalidate) 语义：当一个插槽上的核心对另一个插槽缓存中当前存在的缓存行执行存储操作时，对于每一次所有权转移，一致性协议会向另一个插槽精确地发出一次无效化指令。缓存行大小为 $L = 64$ 字节。所有数组的起始地址都是 $64$ 字节对齐的。\n\n一个程序在一个包含 $N = 2^{20}$ 个逻辑元素的数组上执行一个稳态迭代内核。考虑两种数据布局变体：\n\n1. 结构体数组 (AoS)：每个元素是一个大小为 $s = 32$ 字节的结构体，由两个独立的字段 $x$ 和 $y$ 组成，每个字段占用 $8$ 字节，外加填充以达到总共 $32$ 字节。包含 $N$ 个元素的数组 $A$ 在内存中是连续的。\n\n2. 数组结构体 (SoA)：两个独立的数组 $X$ 和 $Y$，每个数组长度为 $N$，元素大小为 $8$ 字节。数组 $X$ 的页面首次仅由运行在插槽 $0$ 上的线程访问，而数组 $Y$ 的页面首次仅由运行在插槽 $1$ 上的线程访问。\n\n每次迭代的工作分配如下。插槽 $0$ 上的线程更新所有偶数索引 $i \\in \\{0, 2, 4, \\dots\\}$ 的字段 $x$，为每个这样的 $i$ 对 $x$ 执行一次存储操作。插槽 $1$ 上的线程更新所有奇数索引 $i \\in \\{1, 3, 5, \\dots\\}$ 的字段 $y$，为每个这样的 $i$ 对 $y$ 执行一次存储操作。在迭代期间，没有线程读取或写入任何其他字段或索引。考虑稳态情况，即对于在 AoS 布局中被两个插槽都访问的缓存行，由于前一次迭代的访问，这些缓存在每次迭代开始时都驻留在两个插槽的缓存中。\n\n根据上述关于非统一内存访问 (NUMA)、缓存行和 MESI 写-无效语义的定义，推导在 AoS 布局和 SoA 布局下每次迭代产生的跨插槽（远程）无效化消息的确切数量。将您的最终答案表示为一个双分量行向量 $\\left(I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}}\\right)$，其中每个分量是每次迭代的远程无效化次数。不需要四舍五入。", "solution": "该问题要求在一个采用基于 MESI 的写-无效缓存一致性协议的双插槽 NUMA 系统上，推导两种数据布局——结构体数组 (AoS) 和数组结构体 (SoA)——每次迭代产生的跨插槽无效化消息的数量。\n\n首先，让我们明确题目提供的关键参数：\n- 缓存行大小：$L = 64$ 字节。\n- 逻辑元素数量：$N = 2^{20}$。\n- AoS 结构体大小：$s = 32$ 字节。\n- SoA 元素大小：$8$ 字节。\n\n对于存在于另一个插槽缓存中的缓存行的每一次所有权转移，一致性协议会精确地生成一条远程无效化消息。\n\n**结构体数组 (AoS) 布局分析**\n\n在 AoS 布局中，数据存储在单个由 $N$ 个结构体组成的连续数组 $A$ 中。每个结构体的大小为 $s = 32$ 字节。缓存行大小为 $L = 64$ 字节。因此，一个缓存行可以容纳的结构体数量为：\n$$ \\frac{L}{s} = \\frac{64 \\text{ 字节}}{32 \\text{ 字节}} = 2 $$\n由于数组是 $64$ 字节对齐的，数组的第 $k$ 个缓存行（其中 $k$ 是从零开始的索引）将包含结构体 $A[2k]$ 和 $A[2k+1]$。\n\n工作分配如下：\n- 插槽 $0$ 上的线程对所有偶数索引 $i$ 的 $A[i]$ 的字段 $x$ 执行存储操作。这对应于访问 $A[0], A[2], A[4], \\dots$。\n- 插槽 $1$ 上的线程对所有奇数索引 $i$ 的 $A[i]$ 的字段 $y$ 执行存储操作。这对应于访问 $A[1], A[3], A[5], \\dots$。\n\n让我们分析对包含 $A[2k]$ 和 $A[2k+1]$ 的第 $k$ 个缓存行的访问。\n- 插槽 $0$ 上的一个线程将写入 $A[2k]$ 内的一个字段。\n- 插槽 $1$ 上的一个线程将写入 $A[2k+1]$ 内的一个字段。\n由于两次写操作都针对同一个缓存行，这种情况被称为伪共享 (false sharing)。\n\n问题指出，在稳态下，这些有冲突的缓存行在每次迭代开始时都驻留在两个插槽的缓存中。在 MESI 协议中，这意味着该缓存在插槽 $0$ 和插槽 $1$ 的缓存中都处于**共享 (S)** 状态。\n\n我们现在追踪一个这样的缓存行在一次迭代中的无效化事件：\n1.  **第一次存储（例如，从插槽 0）：** 插槽 $0$ 上的一个线程对 $A[2k].x$ 执行存储操作。该缓存行处于 S 状态。要进行写操作，插槽 $0$ 的缓存必须获得独占所有权。它发送一个请求，将其状态升级为**修改 (M)**。此操作需要使所有其他共享副本无效。因此，一致性协议向插槽 $1$ 发送一条无效化消息。插槽 $1$ 的缓存行副本转换到**无效 (I)** 状态。此时，发生了一次远程无效化。该缓存行在插槽 $0$ 上处于 M 状态，在插槽 $1$ 上处于 I 状态。\n2.  **第二次存储（从插槽 1）：** 插槽 $1$ 上的一个线程对 $A[2k+1].y$ 执行存储操作。其本地副本处于 I 状态，因此这会导致写未命中 (write miss)。插槽 $1$ 的缓存发送一个请求，要求获得该缓存行的独占所有权。目录将此请求转发到当前持有该缓存行（处于 M 状态）的插槽 $0$。插槽 $0$ 必须放弃所有权。这构成一次所有权转移。由于该缓存行“当前存在于另一个插槽的缓存中”（即插槽 $0$ 的缓存），协议向插槽 $0$ 发出一次无效化指令。插槽 $0$ 的副本转换到 I 状态。此时，发生了第二次远程无效化。现在，该缓存行在插槽 $0$ 上处于 I 状态，在插槽 $1$ 上处于 M 状态。\n\n因此，对于每个包含被两个插槽都访问的数据的缓存行，每次迭代会精确地产生两次跨插槽无效化。\n\n现在，我们必须确定有多少缓存行表现出这种伪共享。数组 $A$ 由 $N = 2^{20}$ 个结构体组成，每个结构体大小为 $s = 32$ 字节。数组的总大小为 $N \\times s = 2^{20} \\times 32$ 字节。该数组跨越的缓存行数量为：\n$$ \\text{缓存行数量} = \\frac{N \\times s}{L} = \\frac{2^{20} \\times 32}{64} = \\frac{2^{20}}{2} = 2^{19} $$\n每个缓存行都包含一个偶数索引的结构体（由插槽 $0$ 写入）和一个奇数索引的结构体（由插槽 $1$ 写入），因此所有 $2^{19}$ 个缓存行都存在伪共享问题。\n\nAoS 布局的总无效化次数 $I_{\\mathrm{AoS}}$ 是冲突的缓存行数量乘以每个缓存行的无效化次数：\n$$ I_{\\mathrm{AoS}} = (\\text{缓存行数量}) \\times (\\text{每个缓存行的无效化次数}) = 2^{19} \\times 2 = 2^{20} $$\n\n**数组结构体 (SoA) 布局分析**\n\n在 SoA 布局中，数据被组织成两个独立的数组 $X$ 和 $Y$。数组 $X$ 包含所有的 $x$ 字段，数组 $Y$ 包含所有的 $y$ 字段。\n\n工作分配为：\n- 插槽 $0$ 上的线程写入偶数索引 $i$ 的 $X[i]$。\n- 插槽 $1$ 上的线程写入奇数索引 $i$ 的 $Y[i]$。\n\n关键在于，插槽 $0$ 上的线程只访问数组 $X$，而插槽 $1$ 上的线程只访问数组 $Y$。两个插槽访问的数组没有重叠。\n\n- **对数组 X 的访问：** 由于只有插槽 $0$ 的线程访问数组 $X$，属于 $X$ 的缓存行将只被加载到插槽 $0$ 的缓存中。它们永远不会出现在插槽 $1$ 的缓存中。因此，当插槽 $0$ 上的线程对来自 $X$ 的缓存行执行存储操作时，插槽 $1$ 上没有副本需要无效化。不会产生跨插槽的无效化消息。\n- **对数组 Y 的访问：** 同样，由于只有插槽 $1$ 的线程访问数组 $Y$，属于 $Y$ 的缓存行将只被加载到插槽 $1$ 的缓存中。它们永远不会出现在插槽 $0$ 的缓存中。当插槽 $1$ 上的线程执行存储操作时，插槽 $0$ 上没有副本需要无效化。同样，不会产生跨插槽的无效化消息。\n\n首次接触页面放置策略（将 $X$ 的页面分配给插槽 $0$ 的本地内存，将 $Y$ 的页面分配给插槽 $1$ 的本地内存）降低了内存访问延迟，但并未改变基本的缓存一致性行为。决定性因素是数据访问的严格分离，这在缓存行级别上完全消除了插槽之间的数据共享。\n\n因此，SoA 布局的跨插槽无效化总数为零。\n$$ I_{\\mathrm{SoA}} = 0 $$\n\n最终答案是双分量行向量 $(I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}})$。\n$$ (I_{\\mathrm{AoS}}, I_{\\mathrm{SoA}}) = (2^{20}, 0) $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{20}  0\n\\end{pmatrix}\n}\n$$", "id": "3687062"}, {"introduction": "在高性能计算中，优化像矩阵乘法这样的大规模计算至关重要。本练习要求你通过在 NUMA 节点间仔细划分数据和工作来设计一种最小化通信的算法，从而展示如何在宏观算法尺度上管理数据局部性以最大化性能。[@problem_id:3686977]", "problem": "在一个双插槽非均匀内存访问 (NUMA) 系统上执行密集矩阵乘法 $C = A \\times B$，并与概念上的均匀内存访问 (UMA) 系统进行对比。非均匀内存访问 (NUMA) 意味着每个插槽都拥有访问速度较快的本地内存和访问速度较慢的远程内存，而均匀内存访问 (UMA) 意味着无论哪个插槽发出访问请求，所有内存访问都具有统一的延迟和带宽。设 $A \\in \\mathbb{R}^{N \\times N}$ 和 $B \\in \\mathbb{R}^{N \\times N}$，其中 $N = 32768$，每个元素以 $8$ 字节存储。插槽 $0$ 拥有 $A$ 的前 $N/2$ 行和 $B$ 的前 $N/2$ 列，插槽 $1$ 拥有 $A$ 的后 $N/2$ 行和 $B$ 的后 $N/2$ 列。乘法计算的执行方式是，将 $C$ 的每个块行分配给拥有 $A$ 相应行的插槽，并按块列处理 $C$。你可以选择任何能放入缓存的方形块大小；假设只要 $B$ 的一个块列存在于某个插槽中，该插槽内就能实现理想的重用；并假设任何一个插槽所需的、但非其拥有的数据，都必须从另一个插槽传输一次，之后便可重用，无需进一步的远程传输。\n\n仅使用矩阵乘法的核心定义 $C_{ij} = \\sum_{\\ell=1}^{N} A_{i\\ell} B_{\\ell j}$，首先分析生成 $C$ 时是如何消耗 $A$ 的行和 $B$ 的列的，然后提出一种分块调度方案，以最小化此 NUMA 系统上 $B$ 的远程传输量，并明确说明为何该调度方案能最小化远程带宽使用。然后，在你的调度方案下，确定为完成整个乘法运算，两个插槽总共必须通过插槽间链路传输的最小总字节数。将最终答案以 gibibytes (GiB) 为单位表示，并四舍五入到四位有效数字。", "solution": "该问题要求为在双插槽 NUMA 系统上进行的密集矩阵乘法 $C = A \\times B$ 设计一个最优调度方案，并计算跨插槽间链路的最小数据传输量。\n\n首先，我们验证问题陈述的有效性。\n给定条件如下：\n- 运算：密集矩阵乘法 $C = A \\times B$，其中 $A, B, C \\in \\mathbb{R}^{N \\times N}$。\n- 矩阵维度：$N = 32768$。\n- 元素大小：$8$ 字节。\n- 系统：一个双插槽非均匀内存访问 (NUMA) 架构。\n- 数据分布：\n  - 插槽_0 拥有 $A$ 的第 $0$ 到 $N/2 - 1$ 行以及 $B$ 的第 $0$ 到 $N/2 - 1$ 列。\n  - 插槽_1 拥有 $A$ 的第 $N/2$ 到 $N - 1$ 行以及 $B$ 的第 $N/2$ 到 $N - 1$ 列。\n- 工作分布：\n  - 插槽_0 计算 $C$ 的第 $0$ 到 $N/2 - 1$ 行。\n  - 插槽_1 计算 $C$ 的第 $N/2$ 到 $N - 1$ 行。\n- 约束：$C$ 的计算按块列进行处理。\n- 假设：任何一个插槽需要但非其拥有的数据块仅需传输一次。\n- 目标：提出一个调度方案以最小化 $B$ 的远程传输，证明其最小性，计算总传输字节数，并以 GiB 为单位表示结果，四舍五入至四位有效数字。\n\n该问题具有科学依据，提法明确且客观。它描述了高性能计算中的一个标准场景。所有必要信息均已提供，且无矛盾之处。因此，该问题是有效的。\n\n我们将矩阵 $A$、$B$ 和 $C$ 划分为四个大小为 $(N/2) \\times (N/2)$ 的方形子块，以此来形式化问题：\n$$ A = \\begin{pmatrix} A_{00}  A_{01} \\\\ A_{10}  A_{11} \\end{pmatrix}, \\quad B = \\begin{pmatrix} B_{00}  B_{01} \\\\ B_{10}  B_{11} \\end{pmatrix}, \\quad C = \\begin{pmatrix} C_{00}  C_{01} \\\\ C_{10}  C_{11} \\end{pmatrix} $$\n矩阵乘法可以表示为这些子块的运算：\n$$ C_{00} = A_{00}B_{00} + A_{01}B_{10} $$\n$$ C_{01} = A_{00}B_{01} + A_{01}B_{11} $$\n$$ C_{10} = A_{10}B_{00} + A_{11}B_{10} $$\n$$ C_{11} = A_{10}B_{01} + A_{11}B_{11} $$\n\n根据问题陈述，我们可以定义每个子块的数据所有权：\n- 插槽 $0$ 拥有 $A$ 的前 $N/2$ 行，对应于子块 $A_{00}$ 和 $A_{01}$。它还拥有 $B$ 的前 $N/2$ 列，对应于子块 $B_{00}$ 和 $B_{10}$。\n- 插槽 $1$ 拥有 $A$ 的后 $N/2$ 行，对应于子块 $A_{10}$ 和 $A_{11}$。它还拥有 $B$ 的后 $N/2$ 列，对应于子块 $B_{01}$ 和 $B_{11}$。\n\n工作分布也已定义：\n- 插槽 $0$ 计算 $C$ 的前 $N/2$ 行，即子块 $C_{00}$ 和 $C_{01}$。\n- 插槽 $1$ 计算 $C$ 的后 $N/2$ 行，即子块 $C_{10}$ 和 $C_{11}$。\n\n为了证明传输量的最小性，我们首先确定通信的下界。\n为完成其分配的工作，插槽 $0$ 必须计算 $C_{00}$ 和 $C_{01}$。\n- 对于 $C_{00}$，插槽 $0$ 需要 $A_{00}$、$A_{01}$、$B_{00}$ 和 $B_{10}$。所有这些子块都归本地所有。\n- 对于 $C_{01}$，插槽 $0$ 需要 $A_{00}$、$A_{01}$、$B_{01}$ 和 $B_{11}$。子块 $A_{00}$ 和 $A_{01}$ 是本地的。然而，子块 $B_{01}$ 和 $B_{11}$ 归插槽 $1$ 所有。\n因此，为了完成其计算，插槽 $0$ 从根本上需要矩阵 $B$ 的全部后 $N/2$ 列。这些数据包含子块 $B_{01}$ 和 $B_{11}$，必须从插槽 $1$ 传输到插槽 $0$。该数据的大小为 $N \\times (N/2)$ 个元素。\n\n同样地，为完成其分配的工作，插槽 $1$ 必须计算 $C_{10}$ 和 $C_{11}$。\n- 对于 $C_{10}$，插槽 $1$ 需要 $A_{10}$、$A_{11}$、$B_{00}$ 和 $B_{10}$。子块 $A_{10}$ 和 $A_{11}$ 是本地的。然而，子块 $B_{00}$ 和 $B_{10}$ 归插槽 $0$ 所有。\n- 对于 $C_{11}$，插槽 $1$ 需要 $A_{10}$、$A_{11}$、$B_{01}$ 和 $B_{11}$。所有这些子块都归本地所有。\n因此，为了完成其计算，插槽 $1$ 从根本上需要矩阵 $B$ 的全部前 $N/2$ 列。这些数据包含子块 $B_{00}$ 和 $B_{10}$，必须从插槽 $0$ 传输到插槽 $1$。该数据的大小为 $N \\times (N/2)$ 个元素。\n\n这种将 $C$ 的行的计算分配给拥有 $A$ 相应行的插槽的工作分布方式，确保了矩阵 $A$ 的任何部分都不需要传输。通信成本完全源于矩阵 $B$ 的分布。最小总传输量是两个插槽所需远程数据的总和：\n$$ \\text{Volume}_\\text{min} = (\\text{Size of } B_{01} + B_{11}) + (\\text{Size of } B_{00} + B_{10}) $$\n每个子块的大小为 $(N/2) \\times (N/2)$，包含 $(N/2)^2 = N^2/4$ 个元素。\n$$ \\text{Volume}_\\text{min, elements} = (N^2/4 + N^2/4) + (N^2/4 + N^2/4) = N^2/2 + N^2/2 = N^2 $$\n必须通过插槽间链路传输的最小元素总数为 $N^2$。\n\n现在，我们根据问题中按块列处理 $C$ 的约束，提出一个能够达到此下界的调度方案。\n**调度方案建议：按 C 的块列进行计算**\n- **阶段 1：计算 $C$ 的第一个块列。**\n  - 插槽 $0$ 计算 $C_{00} = A_{00}B_{00} + A_{01}B_{10}$。所有需要的数据（$A_{00}, A_{01}, B_{00}, B_{10}$）都是本地的。无需向插槽 $0$ 传输数据。\n  - 插槽 $1$ 计算 $C_{10} = A_{10}B_{00} + A_{11}B_{10}$。它需要来自插槽 $0$ 的子块 $B_{00}$ 和 $B_{10}$。\n  - 阶段 1 的传输：插槽 $0$ 将 $B_{00}$ 和 $B_{10}$ 发送给插槽 $1$。传输量：$N^2/2$ 个元素。\n\n- **阶段 2：计算 $C$ 的第二个块列。**\n  - 插槽 $0$ 计算 $C_{01} = A_{00}B_{01} + A_{01}B_{11}$。它需要来自插槽 $1$ 的子块 $B_{01}$ 和 $B_{11}$。\n  - 插槽 $1$ 计算 $C_{11} = A_{10}B_{01} + A_{11}B_{11}$。所有需要的数据（$A_{10}, A_{11}, B_{01}, B_{11}$）都是本地的。无需向插槽 $1$ 传输数据。\n  - 阶段 2 的传输：插槽 $1$ 将 $B_{01}$ 和 $B_{11}$ 发送给插槽 $0$。传输量：$N^2/2$ 个元素。\n\n该调度方案的总传输量是两个阶段传输量的总和：$N^2/2 + N^2/2 = N^2$ 个元素。由于该传输量与推导出的下界相匹配，因此在最小化远程传输总量方面，此调度方案是最佳的。\n\n最后，我们计算总字节数。\n需要传输的元素数量为 $N^2$。\n给定 $N = 32768 = 2^{15}$。\n传输的总元素数 = $(2^{15})^2 = 2^{30}$。\n每个元素以 $8$ 字节存储。\n传输的总字节数 = $8 \\times 2^{30}$ 字节。\n\n为了将其表示为 gibibytes (GiB)，我们使用换算关系 $1 \\text{ GiB} = 2^{30}$ 字节。\n$$ \\text{Total GiB} = \\frac{8 \\times 2^{30} \\text{ bytes}}{2^{30} \\text{ bytes/GiB}} = 8 \\text{ GiB} $$\n问题要求将答案四舍五入到四位有效数字。\n$$ 8.000 \\text{ GiB} $$\n这就是必须通过插槽间链路传输的最小总字节数。", "answer": "$$\n\\boxed{8.000}\n$$", "id": "3686977"}]}