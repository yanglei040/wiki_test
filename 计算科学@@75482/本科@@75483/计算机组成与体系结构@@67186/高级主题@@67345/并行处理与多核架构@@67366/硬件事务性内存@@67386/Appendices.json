{"hands_on_practices": [{"introduction": "硬件事务内存（HTM）的性能在很大程度上取决于事务之间的冲突率。本练习旨在通过一个简化的微基准测试场景，帮助你运用基础概率论来量化冲突发生的可能性[@problem_id:3645919]。通过推导特定线程的事务因冲突而中止的精确概率，你将能更深刻地理解并发级别（线程数）和数据访问模式是如何直接影响HTM效率的。", "problem": "一个微基准测试旨在对硬件事务内存（HTM）中的冲突行为进行压力测试。共有 $N$ 个并发线程。每个线程执行一个事务，该事务原子地执行以下步骤：从一个数组中均匀随机地选择一个缓存行，并向其中写入一个机器字。该数组总大小为 $M$ 字节，按缓存行边界对齐，且缓存行大小为 $L$ 字节。假设 $M$ 是 $L$ 的整数倍，因此数组中恰好有 $M/L$ 个不同的缓存行。硬件以缓存行粒度检测写-写和写-读重叠冲突，如果任何其他并发事务访问（读取或写入）了某事务的写集合中的任何缓存行，则该事务将中止。在此基准测试中，所有事务都只进行写入操作而不进行读取，因此唯一可能的冲突是缓存行上的写-写重叠。所有 $N$ 个事务在时间上重叠，并尝试并发提交。每个线程对缓存行的选择是独立的，并且在 $M/L$ 个缓存行上是均匀分布的。\n\n仅使用HTM冲突检测的核心定义和基本概率法则，推导出一个特定线程的事务因冲突而中止的概率的精确闭式表达式，该表达式应为 $N$、$M$ 和 $L$ 的函数。请将最终答案表示为关于 $N$、$M$ 和 $L$ 的简化符号表达式。不要进行近似或四舍五入。", "solution": "设 $N$ 为并发线程数，$M$ 为数组的总大小（以字节为单位），$L$ 为缓存行的大小（以字节为单位）。根据题意，$M$ 是 $L$ 的整数倍。因此，不同缓存行的总数（我们记为 $C$）由下式给出：\n$$C = \\frac{M}{L}$$\n$N$ 个线程中的每一个都执行一个事务，该事务涉及向从 $C$ 个可用缓存行中独立、均匀随机选择的单个缓存行进行写入。\n\n我们被要求计算一个*特定*线程的事务中止的概率。让我们任意选择一个线程，比如线程1，并计算其事务中止的概率。如果发生冲突，事务就会中止。根据问题描述，对于线程1而言，如果任何其他并发事务访问了线程1为其写入操作所选择的同一个缓存行，就会发生冲突。由于总共有 $N$ 个线程，因此有 $N-1$ 个其他线程可能会与线程1发生冲突。\n\n如果其他 $N-1$ 个线程中至少有一个选择了与线程1相同的缓存行，那么线程1的事务将中止。在概率计算中，计算其互补事件通常更简单：即线程1的事务*成功*（即不中止）的概率。让我们将线程1的事务中止事件记为 $A$，成功事件记为 $A^c$。我们寻求的概率是 $P(A)$。我们将首先计算 $P(A^c)$，然后使用关系式 $P(A) = 1 - P(A^c)$。\n\n线程1的事务成功的充要条件是，其他*所有* $N-1$ 个线程都选择了与线程1所选*不同*的缓存行。\n\n设 $c_i$ 是线程 $i$（$i \\in \\{1, 2, \\dots, N\\}$）选择的缓存行。每个 $c_i$ 都是一个在 $C$ 个缓存行集合上均匀分布的独立随机变量。\n\n让我们考虑其他线程中的一个，比如线程 $j$，其中 $j \\in \\{2, 3, \\dots, N\\}$。线程1选择的缓存行 $c_1$ 可以是 $C$ 个缓存行中的任意一个。线程 $j$ 选择的缓存行 $c_j$ 也可以是 $C$ 个缓存行中的任意一个。由于选择是均匀的，线程 $j$ 选择与线程1完全相同的缓存行的概率是：\n$$P(c_j = c_1) = \\frac{1}{C}$$\n因此，线程 $j$ 选择与线程1*不同*的缓存行的概率是：\n$$P(c_j \\neq c_1) = 1 - P(c_j = c_1) = 1 - \\frac{1}{C} = \\frac{C-1}{C}$$\n事件 $A^c$（线程1成功）发生，当且仅当条件 $c_j \\neq c_1$ 对所有其他线程（即 $j = 2, 3, \\dots, N$）都成立。\n$$A^c \\equiv (c_2 \\neq c_1) \\land (c_3 \\neq c_1) \\land \\dots \\land (c_N \\neq c_1)$$\n问题陈述指出每个线程对缓存行的选择是独立的。因此，这个复合事件的概率是各个独立概率的乘积：\n$$P(A^c) = P(c_2 \\neq c_1) \\times P(c_3 \\neq c_1) \\times \\dots \\times P(c_N \\neq c_1)$$\n因为有 $N-1$ 个这样的线程，且每个线程的概率都相同，我们得到：\n$$P(A^c) = \\left( \\frac{C-1}{C} \\right)^{N-1}$$\n现在，我们可以求出中止的概率 $P(A)$，这正是问题所要求的：\n$$P(A) = 1 - P(A^c) = 1 - \\left( \\frac{C-1}{C} \\right)^{N-1}$$\n最后一步是将 $C$ 的表达式用给定的变量 $M$ 和 $L$ 代入。\n$$C = \\frac{M}{L}$$\n将此代入我们关于 $P(A)$ 的表达式中：\n$$P(A) = 1 - \\left( \\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} \\right)^{N-1}$$\n我们可以简化括号内的项：\n$$\\frac{\\frac{M}{L} - 1}{\\frac{M}{L}} = 1 - \\frac{1}{\\frac{M}{L}} = 1 - \\frac{L}{M}$$\n因此，一个特定线程的事务中止概率的精确闭式表达式为：\n$$P(A) = 1 - \\left( 1 - \\frac{L}{M} \\right)^{N-1}$$\n该表达式是 $N$、$M$ 和 $L$ 的函数，符合题目要求。", "answer": "$$ \\boxed{1 - \\left(1 - \\frac{L}{M}\\right)^{N-1}} $$", "id": "3645919"}, {"introduction": "并非所有事务冲突都源于对同一数据的逻辑争用。当多个线程访问位于同一缓存行（cache line）上的不同数据时，会发生一种称为“伪共享”（false sharing）的现象，导致不必要的事务中止。本练习将指导你分析如何通过优化数据结构布局——即添加填充（padding）——来有效减少伪共享，从而提高事务成功率[@problem_id:3645968]。掌握这种技术对于编写高性能的并发代码至关重要。", "problem": "一个多处理器实现了硬件事务内存（Hardware Transactional Memory, HTM），它以缓存行粒度检测冲突：如果两个并发事务访问位于同一缓存行上的不同对象，并且至少有一次访问是写操作，则它们发生冲突。考虑一个在内存中连续存储的相同结构体数组。每个结构体的数据负载大小为 $S$ 字节。您可以在每个结构体之后插入大小为 $P$ 字节的显式填充，使得每个对象的步长为 $B = S + P$ 字节。分配器将数组的起始地址与缓存行边界对齐，并且您必须遵守一个对齐约束，即 $B$ 必须是 $a$ 字节的倍数。假设 $B \\le L$，因此没有对象会跨越缓存行边界。在这些条件下，每个缓存行精确地包含 $k = \\left\\lfloor \\frac{L}{B} \\right\\rfloor$ 个对象。\n\n工作负载模型：在每个冲突检测窗口中，恰好有两个并发事务。它们从一个由 $W$ 个连续且被数组对象完全填充的缓存行组成的热工作集中，以均匀随机且不放回的方式选择两个不同的对象。每个事务对其选择的对象执行写操作。当且仅当所选的两个对象不同但映射到同一个缓存行时，发生伪冲突。\n\n仅使用上述核心定义（缓存行粒度的冲突检测和从 $W$ 行工作集中均匀不放回选择），确定最小的整数填充 $P$（以字节为单位），使得伪冲突的概率小于或等于给定的阈值 $\\theta$。\n\n使用以下参数：\n- 缓存行大小：$L = 64$ 字节。\n- 结构体数据负载大小：$S = 20$ 字节。\n- 要求的步长对齐：$a = 8$ 字节。\n- 工作集大小：$W = 32$ 缓存行。\n- 阈值：$\\theta = 0.02$。\n\n请将您的最终答案表述为最小填充 $P$ 的字节数。无需四舍五入。将最终答案表示为单个字节数。", "solution": "我们的目标是找到满足一系列约束条件的最小非负整数填充 $P$。让我们首先推导伪冲突概率 $P_f$ 的表达式。\n\n根据题意，工作集由 $W$ 个缓存行组成。每个缓存行包含 $k$ 个对象，其中 $k = \\lfloor \\frac{L}{B} \\rfloor$ 且步长 $B = S + P$。因此，工作集中的对象总数为 $N = W \\cdot k$。\n\n工作负载是从这 $N$ 个对象中以均匀随机且不放回的方式选择两个不同的对象。选择两个不同对象的总方式数由二项式系数 $\\binom{N}{2}$ 给出：\n$$ \\text{总对数} = \\binom{N}{2} = \\frac{N(N-1)}{2} $$\n当选择的两个不同对象位于同一个缓存行时，会发生伪冲突。为了计算此类对象对的数量，我们可以单独考虑每个缓存行。在一个缓存行内，有 $k$ 个对象。从这 $k$ 个对象中选择两个不同对象的方式数为 $\\binom{k}{2}$。\n$$ \\text{每行的冲突对数} = \\binom{k}{2} = \\frac{k(k-1)}{2} $$\n由于工作集中有 $W$ 个独立的缓存行，导致伪冲突的总对数是该值的 $W$ 倍：\n$$ \\text{总冲突对数} = W \\cdot \\binom{k}{2} = W \\frac{k(k-1)}{2} $$\n伪冲突的概率 $P_f$ 是冲突对数与总对数的比值：\n$$ P_f = \\frac{W \\frac{k(k-1)}{2}}{\\frac{N(N-1)}{2}} = \\frac{W k(k-1)}{N(N-1)} $$\n将 $N = Wk$ 代入上式：\n$$ P_f = \\frac{W k(k-1)}{Wk(Wk-1)} = \\frac{k-1}{Wk-1} $$\n这个表达式在 $k > 1$ 时有效。如果 $k=1$，每个缓存行只有一个对象，不可能从同一行中选择两个不同的对象，此时 $P_f = 0$。我们的公式在 $k=1$ 时正确地得出 $0$。\n\n现在，我们需要找到满足以下条件的最小整数 $P \\ge 0$：\n1. 步长 $B = S + P$ 必须是 $a$ 的倍数。\n2. 步长 $B$ 不能超过缓存行大小，$B \\le L$。\n3. 伪冲突的概率必须不大于阈值 $\\theta$，即 $P_f \\le \\theta$。\n\n代入给定参数：$S=20$, $L=64$, $a=8$, $W=32$, 和 $\\theta=0.02$。\n步长为 $B = 20 + P$。每个缓存行的对象数量为 $k = \\lfloor \\frac{64}{20+P} \\rfloor$。\n约束条件变为：\n1. $20+P$ 必须是 $8$ 的倍数。\n2. $20+P \\le 64$，这意味着 $P \\le 44$。\n3. $\\frac{k-1}{32k-1} \\le 0.02$。\n\n函数 $f(k) = \\frac{k-1}{Wk-1}$ 对于 $k \\ge 1$ 是单调递增的（因为 $W > 1$）。要满足 $P_f \\le \\theta$，我们需要减小 $k$ 的值。要使 $k = \\lfloor L/B \\rfloor$ 更小，我们必须使步长 $B = S+P$ 更大。因此，我们的策略是测试满足对齐约束的、从小到大的 $P$ 值，直到找到满足所有条件的第一个值。\n\n根据约束1，$20+P$ 必须是 $8$ 的倍数。由于 $20 \\equiv 4 \\pmod 8$，我们必须有 $(4+P) \\equiv 0 \\pmod 8$。这意味着 $P$ 的形式必须为 $8m - 4$，其中 $m$ 为正整数。$P$ 的最小非负整数值可以通过取 $m=1, 2, 3, \\dots$ 获得：\n- $m=1 \\implies P = 8(1)-4 = 4$\n- $m=2 \\implies P = 8(2)-4 = 12$\n- $m=3 \\implies P = 8(3)-4 = 20$\n- 依此类推。\n\n我们从最小的可能值开始测试，$P=4$。\n- **测试 $P=4$**：\n    - 步长：$B = S+P = 20+4 = 24$ 字节。\n    - 约束2检查：$B=24 \\le 64$，满足。\n    - 每个缓存行的对象数量：$k = \\lfloor \\frac{L}{B} \\rfloor = \\lfloor \\frac{64}{24} \\rfloor = \\lfloor 2.66\\dots \\rfloor = 2$。\n    - 伪冲突概率：\n      $$ P_f = \\frac{k-1}{Wk-1} = \\frac{2-1}{32(2)-1} = \\frac{1}{64-1} = \\frac{1}{63} $$\n    - 概率约束检查（约束3）：\n      $$ \\frac{1}{63} \\approx 0.01587 \\le 0.02 $$\n      此不等式成立。\n\n由于满足对齐约束的最小非负填充值 $P=4$ 同时满足了概率阈值，因此它就是我们寻找的最小填充值。\n\n最终答案是 $4$ 字节。", "answer": "$$\\boxed{4}$$", "id": "3645968"}, {"introduction": "即使经过精心设计，事务中止（abort）在某些高竞争场景下仍不可避免。因此，如何高效地从中止中恢复成为一个关键问题。本练习将带你分析和比较两种常见的软件恢复策略：有界重试（bounded retries）和指数退避（exponential backoff）[@problem_id:3645908]。通过建立性能模型并计算成功完成事务的期望时间，你将学会评估不同重试策略的优劣，并理解为何智能退避机制对于维持系统在高负载下的性能至关重要。", "problem": "一个处理器实现了硬件事务内存（HTM）。考虑一个单线程在具有许多对称竞争者的静态环境中使用 HTM。将来自其他线程的冲突临界区到达建模为速率为 $\\lambda$ 的泊松过程。一个事务的易受攻击执行窗口长度为 $t_s$，争用水平定义为 $c \\equiv \\lambda t_s$。根据泊松过程的性质，一次 HTM 尝试在其易受攻击窗口期间遇到零冲突到达的概率是 $\\exp(-\\lambda t_s)=\\exp(-c)$。每次成功的 HTM 尝试在时间 $t_s$ 内完成。每次中止的 HTM 尝试会产生该次尝试的开销外加中止惩罚 $h$，总成本为 $t_s+h$。在用尽重试预算后，线程将回退到固定时间为 $t_f$ 的非事务性慢速路径。\n\n考虑两种重试策略：\n- 有界重试无退避：连续进行最多 $r$ 次事务性尝试（无刻意等待），如果所有事务性尝试都中止，则调用慢速路径。在此策略下，假设每次尝试的成功概率是恒定的，等于 $\\exp(-c)$。\n- 指数退避：在第 $k$ 次事务性尝试之前，线程等待一个退避时长 $w_k=d_0 \\alpha^{k-1}$，其中固定值 $d_0>0$ 且 $\\alpha>1$。假设这种协调退避将第 $k$ 次尝试的有效冲突率降低到 $\\lambda/\\alpha^{k-1}$，因此第 $k$ 次尝试的成功概率为 $\\exp\\!\\big(-\\lambda t_s/\\alpha^{k-1}\\big)=\\exp\\!\\big(-c/\\alpha^{k-1}\\big)$。如果所有 $R_b$ 次受退避控制的尝试都中止，则采用慢速路径。\n\n仅从 $c$ 的定义、泊松“无到达”定律以及独立尝试的标准概率出发：\n1) 推导有界重试策略的预期成功时间 $E[T]$ 的解析表达式，该表达式是关于 $r$、$c$、$t_s$、$h$ 和 $t_f$ 的函数。\n2) 推导限制为 $R_b$ 次尝试的指数退避策略的预期成功时间 $E[T]$ 的解析表达式，该表达式是关于 $c$、$\\alpha$、$d_0$、$t_s$、$h$ 和 $t_f$ 的函数。\n3) 使用您在第(1)部分得到的表达式，为以下参数集确定使有界重试 $E[T]$ 最小化的最优整数重试限制 $r^{\\*}$：\n- $t_s = 20$ 微秒，\n- $h = 5$ 微秒，\n- $t_f = 120$ 微秒，\n- $c = 2$。\n然后，使用相同的参数和指数退避参数：\n- $d_0 = 10$ 微秒，\n- $\\alpha = 2$,\n- $R_b = 3$,\n数值计算在 $r^{\\*}$ 处有界重试的 $E[T]$ 和在 $R_b$ 次尝试处指数退避的 $E[T]$。\n\n将所有数值时间值四舍五入到 $4$ 位有效数字。时间以微秒表示。以行矩阵形式报告您的最终答案 $\\big(r^{\\*},\\,E[T]_{\\text{bounded at }r^{\\*}},\\,E[T]_{\\text{backoff at }R_b}\\big)$。", "solution": "预期成功时间 $E[T]$ 是每条可能执行路径所用时间乘以该路径概率的总和。\n\n**1) 有界重试策略**\n\n对于此策略，任何给定尝试的成功概率为 $P_s = \\exp(-c)$，失败（中止）概率为 $P_f = 1 - P_s = 1 - \\exp(-c)$。尝试是连续进行的，因此没有等待时间。\n\n一次执行可以通过以下两种方式之一终止：\n- **在第 $k$ 次尝试时成功（其中 $1 \\le k \\le r$）**：这需要 $k-1$ 次失败，然后一次成功。此路径的概率为 $P_f^{k-1} P_s$。所用时间是 $(k-1)$ 次失败尝试（每次成本为 $t_s+h$）加上一次成功尝试（成本为 $t_s$）。总时间：$(k-1)(t_s+h) + t_s$。\n- **$r$ 次失败后回退**：如果所有 $r$ 次尝试都失败，则会发生这种情况。概率为 $P_f^r$。所用时间是 $r$ 次失败尝试加上回退时间 $t_f$。总时间：$r(t_s+h) + t_f$。\n\n预期时间 $E[T]$ 是所有这些互斥路径的总和：\n$$E[T] = \\sum_{k=1}^{r} \\left[ ((k-1)(t_s+h) + t_s) P_f^{k-1} P_s \\right] + (r(t_s+h) + t_f) P_f^r$$\n使用递推关系可以得到一个更紧凑的形式。设 $C = t_s + hP_f$。递推式为 $E_i = C + P_f E_{i+1}$，从 $i=1$ 开始展开，并设 $E_{r+1}=t_f$，得到：\n$E[T] = C \\sum_{j=0}^{r-1} P_f^j + P_f^r E_{r+1} = C \\left(\\frac{1-P_f^r}{1-P_f}\\right) + t_f P_f^r$。\n代入 $C=t_s+hP_f$ 和 $1-P_f=P_s$：\n$$E[T] = (t_s + h(1-\\exp(-c))) \\frac{1 - (1-\\exp(-c))^r}{\\exp(-c)} + t_f (1-\\exp(-c))^r$$\n这就是所要求的解析表达式。\n\n**2) 指数退避策略**\n\n对于此策略，第 $k$ 次尝试（$1 \\le k \\le R_b$）的参数为：\n- 等待时间：$w_k = d_0 \\alpha^{k-1}$\n- 成功概率：$P_{s,k} = \\exp(-c/\\alpha^{k-1})$\n- 失败概率：$P_{f,k} = 1 - P_{s,k}$\n第 $k$ 次成功尝试的成本是 $w_k+t_s$。第 $k$ 次失败尝试的成本是 $w_k+t_s+h$。\n\n我们对所有可能的路径求和：\n- **在第 $k$ 次尝试时成功（$1 \\le k \\le R_b$）**：这要求第 $1, \\dots, k-1$ 次尝试失败。\n    - 概率：$P(\\text{在 k 次成功}) = \\left(\\prod_{j=1}^{k-1} P_{f,j}\\right) P_{s,k}$。\n    - 时间：总时间是 $k-1$ 次失败尝试和一次成功尝试的成本总和：$T_k = \\sum_{j=1}^{k-1} (w_j+t_s+h) + (w_k+t_s)$。\n- **$R_b$ 次失败后回退**：\n    - 概率：$P(\\text{回退}) = \\prod_{j=1}^{R_b} P_{f,j}$。\n    - 时间：总时间是 $R_b$ 次失败尝试的成本加上回退时间的总和：$T_{fall} = \\sum_{j=1}^{R_b} (w_j+t_s+h) + t_f$。\n\n预期时间 $E[T]$ 是在这些路径上（时间 $\\times$ 概率）的总和：\n$$E[T] = \\sum_{k=1}^{R_b} \\left[ \\left( \\sum_{j=1}^{k-1}(w_j+t_s+h) + w_k+t_s \\right) P_{s,k} \\prod_{j=1}^{k-1} P_{f,j} \\right] + \\left( \\left( \\sum_{j=1}^{R_b}(w_j+t_s+h) \\right) + t_f \\right) \\prod_{j=1}^{R_b}P_{f,j}$$\n其中空乘积为 $1$，空和为 $0$。这就是所要求的解析表达式。\n\n**3) 数值计算**\n\n给定参数：$t_s=20$, $h=5$, $t_f=120$, $c=2$, $d_0=10$, $\\alpha=2$, $R_b=3$。所有时间单位均为微秒。\n\n**有界重试最优重试限制 $r^*$**\n$E[T](r)$ 的表达式形式为 $A + B \\cdot p^r$，其中 $p=P_f=1-\\exp(-c)$。\n$$E[T](r) = \\frac{t_s+hP_f}{P_s} (1-P_f^r) + t_f P_f^r = \\frac{t_s+hP_f}{P_s} + \\left( t_f - \\frac{t_s+hP_f}{P_s} \\right) P_f^r$$\n我们来计算 $P_f^r$ 的系数：\n当 $c=2$ 时，$P_s = \\exp(-2)$ 且 $P_f = 1-\\exp(-2)$。\n$$ \\frac{t_s+hP_f}{P_s} = \\frac{20+5(1-\\exp(-2))}{\\exp(-2)} = \\frac{25-5\\exp(-2)}{\\exp(-2)} = 25\\exp(2)-5 $$\n$t_f - \\frac{t_s+hP_f}{P_s} = 120 - (25\\exp(2)-5) = 125 - 25\\exp(2)$。\n由于 $\\exp(2) \\approx 7.389$，我们有 $125 - 25(7.389) = 125 - 184.725 = -59.725  0$。\n所以，$E[T](r)$ 的形式为 $C_1 - C_2 \\cdot P_f^r$，其中 $C_1, C_2 > 0$ 且 $0  P_f  1$。\n随着 $r$ 的增加，$P_f^r$ 减小，所以 $-C_2 P_f^r$ 增加。因此，$E[T](r)$ 是一个关于 $r$ 的严格递增函数。对于整数 $r \\ge 1$，最小预期时间在 $r$ 的最小可能值处达到，即 $r^*=1$。\n\n**计算有界重试策略在 $r^*=1$ 时的 $E[T]$**\n使用 $r=1$ 时的 $E[T](r)$ 公式：\n$E[T](1) = t_s \\cdot P_s + (t_s+h+t_f) \\cdot P_f = 20\\exp(-2) + (20+5+120)(1-\\exp(-2))$\n$E[T](1) = 20\\exp(-2) + 145(1-\\exp(-2)) = 145 - 125\\exp(-2) \\approx 145 - 125(0.135335) \\approx 145 - 16.9169 = 128.0831 \\mu s$。\n四舍五入到4位有效数字，$E[T]_{\\text{bounded at }r^*=1} \\approx 128.1 \\mu s$。\n\n**计算指数退避策略在 $R_b=3$ 时的 $E[T]$**\n我们计算每次尝试（$k=1, 2, 3$）的参数：\n- 尝试 1: $w_1 = 10(2^0)=10$。 $P_{s,1}=\\exp(-2)$。 $P_{f,1}=1-\\exp(-2)$。\n- 尝试 2: $w_2 = 10(2^1)=20$。 $P_{s,2}=\\exp(-2/2)=\\exp(-1)$。 $P_{f,2}=1-\\exp(-1)$。\n- 尝试 3: $w_3 = 10(2^2)=40$。 $P_{s,3}=\\exp(-2/4)=\\exp(-0.5)$。 $P_{f,3}=1-\\exp(-0.5)$。\n\n现在我们对每条可能路径的（时间 $\\times$ 概率）求和：\n- 在 $k=1$ 时成功：\n    - 时间 $\\times$ 概率 = $(w_1+t_s) \\times P_{s,1} = 30\\exp(-2) \\approx 4.0601$\n- 在 $k=1$ 时失败，在 $k=2$ 时成功：\n    - 时间 $\\times$ 概率 = $((w_1+t_s+h) + (w_2+t_s)) \\times P_{f,1}P_{s,2} = (35+40) \\times (1-\\exp(-2))\\exp(-1) \\approx 75 \\times 0.864665 \\times 0.367879 \\approx 23.8341$\n- 在 $k=1,2$ 时失败，在 $k=3$ 时成功：\n    - 时间 $\\times$ 概率 = $((w_1+t_s+h) + (w_2+t_s+h) + (w_3+t_s)) \\times P_{f,1}P_{f,2}P_{s,3} = (35+45+60) \\times (1-\\exp(-2))(1-\\exp(-1))\\exp(-0.5) \\approx 140 \\times 0.864665 \\times 0.632121 \\times 0.606531 \\approx 46.4100$\n- 在 $k=1,2,3$ 时失败，回退：\n    - 时间 $\\times$ 概率 = $((w_1+t_s+h) + (w_2+t_s+h) + (w_3+t_s+h) + t_f) \\times P_{f,1}P_{f,2}P_{f,3} = (35+45+65+120) \\times (1-\\exp(-2))(1-\\exp(-1))(1-\\exp(-0.5)) \\approx 265 \\times 0.864665 \\times 0.632121 \\times 0.393469 \\approx 57.0015$\n\n$E[T]_{\\text{backoff}} \\approx 4.0601 + 23.8341 + 46.4100 + 57.0015 \\approx 131.3057 \\mu s$。\n四舍五入到4位有效数字，$E[T]_{\\text{backoff at }R_b=3} \\approx 131.3 \\mu s$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 1  128.1  131.3 \\end{pmatrix} } $$", "id": "3645908"}]}