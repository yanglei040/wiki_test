{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式就是动手实践。第一个练习旨在帮助你掌握跟踪缓存一致性协议状态变迁的基本功。通过在一个给定的读写序列中，手动模拟写失效（Write-Invalidate）和写更新（Write-Update）两种协议的行为，你将能直观地比较它们在总线事务、缓存状态转换和通信开销上的根本差异。这个练习是理解后续更复杂场景的基础。[@problem_id:3678515]", "problem": "考虑一个基于监听的多处理器，它有三个核心 $C_0$、$C_1$ 和 $C_2$，以及一个单一的缓存块 $X$。对于缓存块 $X$，所有缓存最初都处于无效状态 $I$。假设采用写回式缓存层次结构和单一共享总线。系统通过监听来维护缓存一致性，采用写-无效协议或写-更新协议。对于每种协议，请使用以下关于缓存一致性、总线事务和状态转换的基础行为定义和经过充分测试的规则：\n\n- 缓存状态含义（写-无效）：修改 ($M$)、独占 ($E$)、共享 ($S$)、无效 ($I$)，与修改-独占-共享-无效 (MESI) 协议中的定义相同。发生未命中的加载操作会发出 $\\mathrm{BusRd}$；需要独占权的存储操作会发出 $\\mathrm{BusRdX}$ 或 $\\mathrm{BusUpgr}$；在本地存储操作上从 $\\mathrm{E}$ 到 $\\mathrm{M}$ 的转换是静默的（无总线活动）。一个处于 $\\mathrm{E}$ 状态的持有者看到 $\\mathrm{BusRd}$ 会导致 $\\mathrm{E}\\to\\mathrm{S}$；一个处于 $\\mathrm{M}$ 状态的持有者看到 $\\mathrm{BusRd}$ 会导致数据供应并转换至 $\\mathrm{M}\\to\\mathrm{S}$。从 $\\mathrm{S}$ 状态写入会导致其他共享者无效化（它们的 $\\mathrm{S}\\to\\mathrm{I}$），并且写入者从 $\\mathrm{S}\\to\\mathrm{M}$ 转换。从 $\\mathrm{I}$ 状态写入会发出 $\\mathrm{BusRdX}$，获得 $\\mathrm{M}$ 状态，并使其他副本无效（如果有的话，$\\mathrm{S}\\to\\mathrm{I}$）。在写-无效协议中没有总线更新事件。\n\n- 缓存状态含义（写-更新）：使用类似Dragon协议的状态，即独占-干净 ($E$)、共享-干净 ($Sc$)、共享-修改 ($Sm$) 和修改 ($M$)。发生未命中的加载操作会发出 $\\mathrm{BusRd}$；如果没有其他缓存持有 $X$，请求者获得 $E$ 状态。如果另一个缓存以任何非无效状态持有 $X$，请求者获得 $Sc$ 状态，而先前的所有者根据以下规则转换：$E\\to Sc$，$M\\to Sm$，$Sm$ 保持 $Sm$。从 $E$ 状态写入会静默地从 $E\\to M$ 转换（无总线活动）；从 $Sc$ 状态写入会从 $Sc\\to Sm$ 转换，并向所有共享者广播一个总线更新 $\\mathrm{BusUpd}$；从 $Sm$ 状态写入会保持 $Sm$ 状态并广播 $\\mathrm{BusUpd}$。在广播 $\\mathrm{BusUpd}$ 的写入操作中，写入者成为 $Sm$ 状态的所有者，而任何先前处于 $Sm$ 状态的所有者会转换到 $Sc$ 状态。在写-更新协议中没有无效化操作。\n\n对于两种协议，为所有缓存中关于块 $X$ 的整个执行过程定义事件计数器如下：计算 $\\mathrm{S}\\to\\mathrm{I}$ 转换、$\\mathrm{I}\\to\\mathrm{S}$ 转换、$\\mathrm{S}\\to\\mathrm{M}$ 转换以及总线更新事件 $\\mathrm{BusUpd}$ 的总次数。仅当缓存中 $X$ 的状态确实发生上述方式的改变时才计数；不要计算 $E\\to M$、$M\\to S$、$E\\to S$ 或任何其他未列出的转换。每当写-更新协议因对共享块的存储操作而广播更新时，就计为一个总线更新事件 $\\mathrm{BusUpd}$。在写-无效协议下，$\\mathrm{BusUpd}$ 事件不会发生。\n\n执行以下关于块 $X$ 的内存操作合成轨迹：\n- 步骤 1：$C_0$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 2：$C_1$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 3：$C_0$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 4：$C_2$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 5：$C_1$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 6：$C_0$ 执行 $\\mathrm{Load}\\, X$。\n- 步骤 7：$C_2$ 执行 $\\mathrm{Store}\\, X$。\n- 步骤 8：$C_1$ 执行 $\\mathrm{Load}\\, X$。\n\n仅使用上述规则，计算在整个轨迹中，写-无效协议和写-更新协议的 $\\mathrm{S}\\to\\mathrm{I}$、$\\mathrm{I}\\to\\mathrm{S}$、$\\mathrm{S}\\to\\mathrm{M}$ 和 $\\mathrm{BusUpd}$ 事件的总数。将您的最终答案表示为单个行矩阵\n$$\\begin{pmatrix}\n\\text{WI } \\mathrm{S}\\to\\mathrm{I}  \\text{WI } \\mathrm{I}\\to\\mathrm{S}  \\text{WI } \\mathrm{S}\\to\\mathrm{M}  \\text{WI } \\mathrm{BusUpd}  \\text{WU } \\mathrm{S}\\to\\mathrm{I}  \\text{WU } \\mathrm{I}\\to\\mathrm{S}  \\text{WU } \\mathrm{S}\\to\\mathrm{M}  \\text{WU } \\mathrm{BusUpd}\n\\end{pmatrix}.$$\n无需四舍五入。", "solution": "该问题要求追踪一个给定的内存访问序列，并针对写无效（WI）和写更新（WU）两种协议，统计四种特定事件的发生次数。\n\n**第1部分：写无效 (WI) 协议分析**\n\n我们将追踪核心 $C_0, C_1, C_2$ 中缓存块 $X$ 的 MESI 状态，并更新计数器 $(\\mathrm{S}\\to\\mathrm{I}, \\mathrm{I}\\to\\mathrm{S}, \\mathrm{S}\\to\\mathrm{M}, \\mathrm{BusUpd})$。\n- **初始状态：** 状态: $(I, I, I)$。计数器: $(0, 0, 0, 0)$。\n- **步骤 1: $C_0$ Load X。** $C_0$ 读缺失，发出 $\\mathrm{BusRd}$，状态变为 $E$。状态: $(E, I, I)$。\n- **步骤 2: $C_1$ Load X。** $C_1$ 读缺失，发出 $\\mathrm{BusRd}$。$C_0$ 监听到，从 $E \\to S$。$C_1$ 获得数据，状态从 $I \\to S$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_1$)。状态: $(S, S, I)$。计数器: $(0, 1, 0, 0)$。\n- **步骤 3: $C_0$ Store X。** $C_0$ 对 $S$ 状态写入，发出 $\\mathrm{BusUpgr}$。$C_1$ 监听到，从 $S \\to I$。$C_0$ 从 $S \\to M$。\n  - **事件：** 1 次 $\\mathrm{S}\\to\\mathrm{I}$ ($C_1$)，1 次 $\\mathrm{S}\\to\\mathrm{M}$ ($C_0$)。状态: $(M, I, I)$。计数器: $(1, 1, 1, 0)$。\n- **步骤 4: $C_2$ Load X。** $C_2$ 读缺失，发出 $\\mathrm{BusRd}$。$C_0$ 监听到，提供数据，从 $M \\to S$。$C_2$ 获得数据，从 $I \\to S$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_2$)。状态: $(S, I, S)$。计数器: $(1, 2, 1, 0)$。\n- **步骤 5: $C_1$ Store X。** $C_1$ 写缺失，发出 $\\mathrm{BusRdX}$。$C_0$ 和 $C_2$ 监听到，从 $S \\to I$。$C_1$ 获得数据，状态变为 $M$。\n  - **事件：** 2 次 $\\mathrm{S}\\to\\mathrm{I}$ ($C_0, C_2$)。状态: $(I, M, I)$。计数器: $(3, 2, 1, 0)$。\n- **步骤 6: $C_0$ Load X。** $C_0$ 读缺失，发出 $\\mathrm{BusRd}$。$C_1$ 监听到，提供数据，从 $M \\to S$。$C_0$ 从 $I \\to S$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_0$)。状态: $(S, S, I)$。计数器: $(3, 3, 1, 0)$。\n- **步骤 7: $C_2$ Store X。** $C_2$ 写缺失，发出 $\\mathrm{BusRdX}$。$C_0$ 和 $C_1$ 监听到，从 $S \\to I$。$C_2$ 状态变为 $M$。\n  - **事件：** 2 次 $\\mathrm{S}\\to\\mathrm{I}$ ($C_0, C_1$)。状态: $(I, I, M)$。计数器: $(5, 3, 1, 0)$。\n- **步骤 8: $C_1$ Load X。** $C_1$ 读缺失，发出 $\\mathrm{BusRd}$。$C_2$ 监听到，提供数据，从 $M \\to S$。$C_1$ 从 $I \\to S$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_1$)。状态: $(I, S, S)$。计数器: $(5, 4, 1, 0)$。\n\n**写-无效 (WI) 最终计数：** $(\\mathrm{S}\\to\\mathrm{I}: 5, \\mathrm{I}\\to\\mathrm{S}: 4, \\mathrm{S}\\to\\mathrm{M}: 1, \\mathrm{BusUpd}: 0)$。\n\n**第2部分：写更新 (WU) 协议分析**\n\n我们追踪类Dragon协议的状态 ($E, Sc, Sm, M, I$)。根据规则，$\\mathrm{S}\\to\\mathrm{I}$ 和 $\\mathrm{S}\\to\\mathrm{M}$ 转换不会发生，所以它们的计数恒为 $0$。$I \\to Sc$ 被计为 $\\mathrm{I}\\to\\mathrm{S}$。\n- **初始状态：** 状态: $(I, I, I)$。计数器: $(0, 0, 0, 0)$。\n- **步骤 1: $C_0$ Load X。** $C_0$ 读缺失，发出 $\\mathrm{BusRd}$，状态变为 $E$。状态: $(E, I, I)$。\n- **步骤 2: $C_1$ Load X。** $C_1$ 读缺失，发出 $\\mathrm{BusRd}$。$C_0$ 监听到，从 $E \\to Sc$。$C_1$ 状态变为 $Sc$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_1$)。状态: $(Sc, Sc, I)$。计数器: $(0, 1, 0, 0)$。\n- **步骤 3: $C_0$ Store X。** $C_0$ 对 $Sc$ 状态写入，发出 $\\mathrm{BusUpd}$，从 $Sc \\to Sm$ 并成为所有者。$C_1$ 保持 $Sc$ 并更新数据。\n  - **事件：** 1 次 $\\mathrm{BusUpd}$。状态: $(Sm, Sc, I)$。计数器: $(0, 1, 0, 1)$。\n- **步骤 4: $C_2$ Load X。** $C_2$ 读缺失，发出 $\\mathrm{BusRd}$。$C_0$ ($Sm$, 所有者) 提供数据并保持 $Sm$。$C_2$ 状态变为 $Sc$。\n  - **事件：** 1 次 $\\mathrm{I}\\to\\mathrm{S}$ ($C_2$)。状态: $(Sm, Sc, Sc)$。计数器: $(0, 2, 0, 1)$。\n- **步骤 5: $C_1$ Store X。** $C_1$ 对 $Sc$ 状态写入，发出 $\\mathrm{BusUpd}$，从 $Sc \\to Sm$ 并成为新所有者。旧所有者 $C_0$ 从 $Sm \\to Sc$。$C_2$ 保持 $Sc$。\n  - **事件：** 1 次 $\\mathrm{BusUpd}$。状态: $(Sc, Sm, Sc)$。计数器: $(0, 2, 0, 2)$。\n- **步骤 6: $C_0$ Load X。** $C_0$ 读命中 $Sc$ 状态。无事件。状态: $(Sc, Sm, Sc)$。计数器: $(0, 2, 0, 2)$。\n- **步骤 7: $C_2$ Store X。** $C_2$ 对 $Sc$ 状态写入，发出 $\\mathrm{BusUpd}$，从 $Sc \\to Sm$ 并成为新所有者。旧所有者 $C_1$ 从 $Sm \\to Sc$。$C_0$ 保持 $Sc$。\n  - **事件：** 1 次 $\\mathrm{BusUpd}$。状态: $(Sc, Sc, Sm)$。计数器: $(0, 2, 0, 3)$。\n- **步骤 8: $C_1$ Load X。** $C_1$ 读命中 $Sc$ 状态。无事件。状态: $(Sc, Sc, Sm)$。计数器: $(0, 2, 0, 3)$。\n\n**写-更新 (WU) 最终计数：** $(\\mathrm{S}\\to\\mathrm{I}: 0, \\mathrm{I}\\to\\mathrm{S}: 2, \\mathrm{S}\\to\\mathrm{M}: 0, \\mathrm{BusUpd}: 3)$。\n\n**结果总结**\n将两种协议的结果合并到所需的矩阵格式中，得到最终答案。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5  4  1  0  0  2  0  3\n\\end{pmatrix}\n}\n$$", "id": "3678515"}, {"introduction": "在掌握了基本协议的运行机制后，我们来探讨一个更贴近实际的挑战：数据对齐问题。现实世界中的数据并非总能完美地放入单个缓存行，当一个变量跨越多个缓存行时，一致性维护就变得更加复杂。本练习将引导你分析这种情况下的一致性事件，从而让你深刻理解，一致性协议的操作粒度是缓存行（cache line），而非高级语言中的变量。[@problem_id:3678490]", "problem": "考虑一个共享内存多处理器，它有$3$个核心，分别表示为$C_0$、$C_1$和$C_2$。每个核心都有一个私有的写回缓存，该缓存通过单个共享总线参与一个窥探一致性协议。缓存行大小为$64$字节。一个大小为$24$字节的程序变量$v$未对齐，恰好跨越了两个相邻的缓存行$L_0$和$L_1$：$L_0$的最后$8$个字节存储了$v$的前$8$个字节，$L_1$的前$16$个字节存储了$v$剩余的$16$个字节。\n\n假设有以下初始条件和硬件行为：\n- 在时间$t=0$时，没有任何核心的缓存中持有$L_0$或$L_1$。\n- 当一个读请求所需的数据不在缓存行中时，会为所需的缓存行发出一个行填充请求。当一次读取填充了一个缓存行，且当前没有其他缓存持有该行时，该行被调入请求者的缓存。在写-无效协议下，该行进入独占（Exclusive）状态；在写-更新协议下，该行进入共享（Shared）状态。\n- 每个修改行内任意字节的存储操作在一致性上都以行粒度进行，这意味着一个同时触及$L_0$和$L_1$的存储操作被实现为两个独立的按行存储，一个针对$L_0$，一个针对$L_1$。\n- 在以下场景中没有缓存淘汰发生。\n\n定义待分析的两种一致性协议变体：\n- 写-无效协议，使用修改-独占-共享-无效 (MESI) 状态机。计算的一致性广播包括：每次$\\text{BusRd}$（读未命中行填充）计一次，每次$\\text{BusRdX}$（为写入不存在的行而获取所有权）计一次，以及每次$\\text{BusUpgr}$（为写入已存在的行而从共享状态升级到修改状态）计一次。不计算静默状态转换或对内存的写回；只计算促使其他缓存窥探其标签的窥探总线广播。\n- 写-更新协议，采用写分配和按行更新。计算的一致性广播包括：每次$\\text{BusRd}$（为获取共享副本而进行的读未命中行填充）计一次，以及每次$\\text{BusUpdate}$（写入时向其他共享副本广播新数据）计一次。不计算静默状态转换或对内存的写回。\n\n现在对变量$v$执行以下操作序列：\n1. 核心$C_0$执行一次对$v$的读取，该读取触及$L_0$和$L_1$。\n2. 核心$C_1$执行两次存储：首先，它写入$4$个完全位于$L_0$中$v$部分的连续字节；其次，它写入$8$个完全位于$L_1$中$v$部分的连续字节。\n3. 核心$C_2$执行一次存储，写入$8$个完全位于$L_1$中$v$部分的连续字节。\n4. 核心$C_0$再次执行一次对$v$的读取，触及$L_0$和$L_1$。\n5. 核心$C_1$执行一次存储，写入$4$个完全位于$L_0$中$v$部分的连续字节。\n6. 核心$C_2$执行一次存储，写入$4$个完全位于$L_1$中$v$部分的连续字节。\n\n在上述假设下，令$M_{\\text{inv}}$为写-无效协议下的窥探总线广播总数，令$M_{\\text{upd}}$为写-更新协议下的总数。计算单一量$M_{\\text{upd}} - M_{\\text{inv}}$。用一个没有单位的纯数字表示你的最终答案。如果需要任何数值近似，四舍五入到四位有效数字；否则给出精确的整数值。", "solution": "此问题要求我们追踪两个缓存行（$L_0$ 和 $L_1$）在三个核心（$C_0, C_1, C_2$）之间的一系列操作中的状态，并计算两种协议（写无效和写更新）下的总线广播次数，最后求出两者之差。\n\n**第1部分：写无效 (MESI) 协议分析 ($M_{\\text{inv}}$)**\n\n初始状态：所有核心中 $L_0, L_1$ 均为无效 (I)。$M_{\\text{inv}} = 0$。\n\n1.  **$C_0$ 读取 $v$ (触及 $L_0, L_1$)**:\n    -   $C_0$ 读 $L_0$：读未命中，发出 `BusRd`。获得 $L_0$ 为 **E** 状态。广播数 +1。\n    -   $C_0$ 读 $L_1$：读未命中，发出 `BusRd`。获得 $L_1$ 为 **E** 状态。广播数 +1。\n    -   状态: $C_0(E, E)$, 其他 $(I, I)$。$M_{\\text{inv}} = 2$。\n\n2.  **$C_1$ 写入 $L_0, L_1$**:\n    -   $C_1$ 写 $L_0$：写未命中，发出 `BusRdX`。$C_0$ 的 $L_0$ 副本失效 ($E \\to I$)。$C_1$ 获得 $L_0$ 为 **M** 状态。广播数 +1。\n    -   $C_1$ 写 $L_1$：写未命中，发出 `BusRdX`。$C_0$ 的 $L_1$ 副本失效 ($E \\to I$)。$C_1$ 获得 $L_1$ 为 **M** 状态。广播数 +1。\n    -   状态: $C_0(I, I), C_1(M, M), C_2(I, I)$。$M_{\\text{inv}} = 2 + 2 = 4$。\n\n3.  **$C_2$ 写入 $L_1$**:\n    -   写未命中，发出 `BusRdX`。$C_1$ 的 $L_1$ 副本失效 ($M \\to I$)。$C_2$ 获得 $L_1$ 为 **M** 状态。广播数 +1。\n    -   状态: $C_0(I, I), C_1(M, I), C_2(I, M)$。$M_{\\text{inv}} = 4 + 1 = 5$。\n\n4.  **$C_0$ 读取 $v$ (触及 $L_0, L_1$)**:\n    -   $C_0$ 读 $L_0$：读未命中，发出 `BusRd`。$C_1$ 提供数据并降级 ($M \\to S$)。$C_0$ 获得 $L_0$ 为 **S** 状态。广播数 +1。\n    -   $C_0$ 读 $L_1$：读未命中，发出 `BusRd`。$C_2$ 提供数据并降级 ($M \\to S$)。$C_0$ 获得 $L_1$ 为 **S** 状态。广播数 +1。\n    -   状态: $C_0(S, S), C_1(S, I), C_2(I, S)$。$M_{\\text{inv}} = 5 + 2 = 7$。\n\n5.  **$C_1$ 写入 $L_0$**:\n    -   写命中共享行，发出 `BusUpgr`。$C_0$ 的 $L_0$ 副本失效 ($S \\to I$)。$C_1$ 升级 ($S \\to M$)。广播数 +1。\n    -   状态: $C_0(I, S), C_1(M, I), C_2(I, S)$。$M_{\\text{inv}} = 7 + 1 = 8$。\n\n6.  **$C_2$ 写入 $L_1$**:\n    -   写命中共享行，发出 `BusUpgr`。$C_0$ 的 $L_1$ 副本失效 ($S \\to I$)。$C_2$ 升级 ($S \\to M$)。广播数 +1。\n    -   状态: $C_0(I, I), C_1(M, I), C_2(I, M)$。$M_{\\text{inv}} = 8 + 1 = 9$。\n\n**写-无效协议的总广播数 $M_{\\text{inv}} = 9$。**\n\n**第2部分：写更新协议分析 ($M_{\\text{upd}}$)**\n\n初始状态：所有核心中 $L_0, L_1$ 均为无效 (I)。$M_{\\text{upd}} = 0$。\n\n1.  **$C_0$ 读取 $v$ (触及 $L_0, L_1$)**:\n    -   $C_0$ 读 $L_0$：读未命中，发出 `BusRd`。获得 $L_0$ 为 **S** 状态。广播数 +1。\n    -   $C_0$ 读 $L_1$：读未命中，发出 `BusRd`。获得 $L_1$ 为 **S** 状态。广播数 +1。\n    -   状态: $C_0(S, S)$, 其他 $(I, I)$。$M_{\\text{upd}} = 2$。\n\n2.  **$C_1$ 写入 $L_0, L_1$**:\n    -   $C_1$ 写 $L_0$：写未命中 (写分配)。首先发出 `BusRd` 获取副本 (广播数 +1)，$C_1$ 获得 $L_0$ 为 **S**。然后对共享行写入，发出 `BusUpdate` (广播数 +1)。$C_0$ 更新其副本。\n    -   $C_1$ 写 $L_1$：同样，发出 `BusRd` (广播数 +1)，然后发出 `BusUpdate` (广播数 +1)。$C_0$ 更新其副本。\n    -   状态: $C_0(S, S), C_1(S, S), C_2(I, I)$。$M_{\\text{upd}} = 2 + 4 = 6$。\n\n3.  **$C_2$ 写入 $L_1$**:\n    -   写未命中。发出 `BusRd` (广播数 +1)，$C_2$ 获得 $L_1$ 为 **S**。然后发出 `BusUpdate` (广播数 +1)。$C_0, C_1$ 更新其副本。\n    -   状态: $C_0(S, S), C_1(S, S), C_2(I, S)$。$M_{\\text{upd}} = 6 + 2 = 8$。\n\n4.  **$C_0$ 读取 $v$ (触及 $L_0, L_1$)**:\n    -   $C_0$ 读 $L_0$：命中 S 状态。无广播。\n    -   $C_0$ 读 $L_1$：命中 S 状态。无广播。\n    -   状态不变。$M_{\\text{upd}} = 8$。\n\n5.  **$C_1$ 写入 $L_0$**:\n    -   写命中共享行。发出 `BusUpdate`。$C_0$ 更新副本。广播数 +1。\n    -   状态不变。$M_{\\text{upd}} = 8 + 1 = 9$。\n\n6.  **$C_2$ 写入 $L_1$**:\n    -   写命中共享行。发出 `BusUpdate`。$C_0, C_1$ 更新副本。广播数 +1。\n    -   状态不变。$M_{\\text{upd}} = 9 + 1 = 10$。\n\n**写-更新协议的总广播数 $M_{\\text{upd}} = 10$。**\n\n**第3部分：最终计算**\n\n我们计算差值 $M_{\\text{upd}} - M_{\\text{inv}}$。\n$M_{\\text{upd}} - M_{\\text{inv}} = 10 - 9 = 1$。\n最终答案为精确整数值 1。", "answer": "$$\\boxed{1}$$", "id": "3678490"}, {"introduction": "最后一个练习将带你从纸上推演迈向编程实现，完成一个从理论到实践的跨越。通过编写一个简单的缓存一致性协议模拟器，你不仅能将之前学到的规则形式化为代码，还能定量地分析不同策略的性能开销。更重要的是，这个练习引入了“自适应协议”的概念，让你探索如何动态地结合写失效和写更新策略的优点，这正是现代处理器设计中需要权衡的实际问题。[@problem_id:3678538]", "problem": "考虑一个基于总线的共享内存多处理器，该处理器采用监听缓存一致性协议和微处理器软件接口 (Microprocessor Software Interface, MSI) 状态：无效 (Invalid, I)、共享 (Shared, S) 和修改 (Modified, M)。系统有 $P$ 个核心和 $M$ 个缓存行。以下为基本定义：\n\n- 监听协议通过在共享总线上广播事务来保持缓存一致。每个缓存都监听总线并相应地更新其本地状态。\n- 在写-失效策略中，一个核心的写入操作会使其余缓存中的副本失效，从而授予写入者独占的写权限。\n- 在写-更新策略中，一个核心的写入操作会向其他持有共享副本的缓存广播新数据，使它们保持在数据最新的共享状态。\n- 缓存一致性不变量要求在任何时刻，最多只有一个缓存能以修改状态持有一行；同时，另一个核心对处于修改状态的行的读取操作，会将所有者降级到共享状态，并向请求者提供数据。\n\n假设总线事务的成本模型如下，以无单位整数“流量成本”单位衡量：\n\n- 一次广播一致性事务的成本为 $c_b$。\n- 向单个缓存传输数据（向请求者提供一行或发送更新负载）的成本为 $c_d$。\n- 核心的一次读未命中会产生 $c_b + c_d$ 的成本，并导致请求者进入共享状态。如果某个其他核心以修改状态持有该行，该所有者会作为提供数据的一部分降级到共享状态。\n- 从无效状态写入，需要先获取该行，产生 $c_b + c_d$ 的成本，然后应用该写入的一致性操作。\n- 在写-失效策略中，核心从共享状态写入时，会广播一条成本为 $c_b$ 的失效消息，使所有其他副本失效，并将写入者置于修改状态。如果写入者已处于修改状态，则该写入是本地命中，成本为 $0$。\n- 在写-更新策略中，核心从共享状态写入时，会广播一条成本为 $c_b + s \\cdot c_d$ 的更新消息，其中 $s$ 是该行当前处于共享状态的其他缓存的数量（不包括写入者）。更新后，所有持有该行的缓存都保持在数据最新的共享状态。如果写入者处于无效状态，它必须先获取该行（成本为 $c_b + c_d$），然后如上所述执行更新。\n\n我们探索一种启发式混合策略，该策略在每次对某一行进行写入时，根据当前估计的读取者数量来决定使用写-失效还是写-更新。对于每一行 $\\ell$，维护一个估计值 $\\hat{s}(\\ell)$，该值等于当前持有 $\\ell$ 且处于共享状态的缓存数量，不包括写入核心。混合决策规则如下：\n\n- 如果 $\\hat{s}(\\ell)  \\theta$，则对该次写入执行写-更新。\n- 否则，对该次写入执行写-失效。\n\n最初，所有缓存中的所有行都处于无效状态。读写操作以一个按时间排序的操作序列 $(\\ell, i, t)$ 的形式发生，其中行标识符 $\\ell \\in \\{0, 1, \\dots, M-1\\}$，核心标识符 $i \\in \\{0, 1, \\dots, P-1\\}$，操作类型 $t \\in \\{\\text{R}, \\text{W}\\}$。读取操作根据上述规则处理；写入操作遵循该测试所选的策略（总是写-失效、总是写-更新或启发式混合策略）。\n\n您的任务是实现一个模拟器，在给定固定成本参数和操作序列的情况下，计算以下三种策略的总线流量总成本：\n- 总是写-失效（表示为 $\\mathrm{WI}$），\n- 总是写-更新（表示为 $\\mathrm{WU}$），\n- 使用上述规则和阈值 $\\theta$ 的启发式混合策略（$\\mathrm{HYB}$）。\n\n使用固定成本 $c_b = 1$ 和 $c_d = 4$。模拟器必须跟踪每个核心中每行的MSI状态，并根据上述规则一致地应用状态转换。对于读取操作，已处于共享或修改状态的核心产生零成本，且状态不改变，除非另一个核心以修改状态持有该行且本次读取是未命中；处于无效状态的核心发生读未命中时，会产生 $c_b + c_d$ 的成本，如果某个其他核心以修改状态持有该行，该所有者会在读取过程中降级到共享状态。\n\n对于写-更新策略，写入后，写入者和所有其他持有该行的缓存将保持或进入数据最新的共享状态；对于写-失效策略，写入者最终处于修改状态，而所有其他曾持有该行的缓存将变为无效状态。\n\n请严格按照所述实现混合规则：在做出写入决策的时刻获取 $\\hat{s}(\\ell)$，计算 $\\hat{s}(\\ell)  \\theta$ 是否成立，并相应地选择更新或失效。如果写入者已处于修改状态且选择了失效分支，则该次写入不发出总线事务。\n\n测试套件：\n模拟以下四个测试用例，每个用例由 $(P, M, \\theta)$ 和一个操作序列定义。在所有序列中，数字和标识符都是从零开始的。\n\n- 测试用例 $1$ (混合工作负载，写入时有多个共享者):\n  - $P = 4$, $M = 2$, $\\theta = 1$，操作序列：\n    - 对行 $0$: $(0, 1, \\mathrm{R})$, $(0, 2, \\mathrm{R})$, $(0, 3, \\mathrm{R})$, $(0, 0, \\mathrm{W})$, $(0, 1, \\mathrm{R})$, $(0, 2, \\mathrm{R})$, $(0, 0, \\mathrm{W})$, $(0, 3, \\mathrm{R})$。\n    - 对行 $1$: $(1, 0, \\mathrm{R})$, $(1, 1, \\mathrm{R})$, $(1, 2, \\mathrm{W})$, $(1, 0, \\mathrm{R})$, $(1, 1, \\mathrm{R})$, $(1, 2, \\mathrm{W})$。\n- 测试用例 $2$ (边界情况：在阈值处持平):\n  - $P = 3$, $M = 1$, $\\theta = 2$，操作序列：\n    - 对行 $0$: $(0, 0, \\mathrm{R})$, $(0, 1, \\mathrm{R})$, $(0, 2, \\mathrm{R})$, $(0, 0, \\mathrm{W})$。\n- 测试用例 $3$ (边缘情况：单个写入者，无读取者):\n  - $P = 2$, $M = 1$, $\\theta = 0$，操作序列：\n    - 对行 $0$: $(0, 0, \\mathrm{W})$, $(0, 0, \\mathrm{W})$, $(0, 0, \\mathrm{W})$, $(0, 0, \\mathrm{W})$, $(0, 0, \\mathrm{W})$。\n- 测试用例 $4$ (边缘情况：两个核心之间的乒乓写操作):\n  - $P = 2$, $M = 1$, $\\theta = 1$，操作序列：\n    - 对行 $0$: $(0, 0, \\mathrm{W})$, $(0, 1, \\mathrm{W})$, $(0, 0, \\mathrm{W})$, $(0, 1, \\mathrm{W})$。\n\n您的程序必须为每个测试用例计算总流量成本的三元组 $(\\mathrm{WI}, \\mathrm{WU}, \\mathrm{HYB})$，结果为整数。您的程序应生成单行输出，其中包含用方括号括起来的每个测试用例的三元组列表，每个三元组本身也用方括号括起来。例如，输出格式为：\n$[[\\mathrm{WI}_1,\\mathrm{WU}_1,\\mathrm{HYB}_1],[\\mathrm{WI}_2,\\mathrm{WU}_2,\\dots]$。\n\n无需读取任何输入；所有参数和操作序列都必须按照上述规定进行硬编码。输出必须是单行，包含按所述确切格式聚合的整数三元组列表。此问题中没有物理单位。", "solution": "该问题要求通过模拟计算四种不同场景下，三种缓存一致性策略（写失效WI、写更新WU、混合HYB）的总线流量成本。成本参数为广播成本 $c_b=1$ 和数据传输成本 $c_d=4$。\n\n下面是每个测试用例的详细追踪和成本计算。\n\n**成本公式回顾:**\n- 读未命中：$c_b + c_d = 5$\n- WI 写（从S状态）：$c_b = 1$\n- WI 写（从I状态）：获取(5) + 失效(1) = 6\n- WU 写（从S状态）：$c_b + s \\cdot c_d = 1 + 4s$\n- WU 写（从I状态）：获取(5) + 更新($1 + 4s_{new}$)\n\n---\n\n**测试用例 1: $P=4, M=2, \\theta=1$**\n\n**行 0 追踪:**\n1.  `(0,1,R)`, `(0,2,R)`, `(0,3,R)`: 3次读未命中，每次成本5。 **成本: (15, 15, 15)**. 状态: 各策略下均为 (I, S, S, S)。\n2.  `(0,0,W)`: 写未命中。\n    - WI: 成本+6。状态(M,I,I,I)。**WI成本: 21**.\n    - WU: 获取(5)+更新(1+3*4=13) = 18。状态(S,S,S,S)。**WU成本: 33**.\n    - HYB: $s=3 > \\theta=1$, 使用WU。成本+18。状态(S,S,S,S)。**HYB成本: 33**.\n3.  `(0,1,R)`, `(0,2,R)`:\n    - WI: 2次读未命中，每次成本5。**WI成本: 31**. 状态: (S, S, S, I)。\n    - WU/HYB: 2次读命中。成本+0。\n4.  `(0,0,W)`:\n    - WI: 从S写，2个共享者。成本+1。**WI成本: 32**. 状态(M,I,I,I)。\n    - WU/HYB: 从S写，3个共享者。成本+(1+3*4=13)。**WU/HYB成本: 46**. 状态(S,S,S,S)。\n5.  `(0,3,R)`:\n    - WI: 读未命中。成本+5。**WI成本: 37**.\n    - WU/HYB: 读命中。成本+0。\n\n*行 0 最终成本: (37, 46, 46)*\n\n**行 1 追踪:**\n1.  `(1,0,R)`, `(1,1,R)`: 2次读未命中。**成本: (10, 10, 10)**。状态: (S,S,I,I)。\n2.  `(1,2,W)`: 写未命中。\n    - WI: 获取(5)+失效(1)=6。**WI成本: 16**. 状态(I,I,M,I)。\n    - WU: 获取(5)+更新(1+2*4=9)=14。**WU成本: 24**. 状态(S,S,S,I)。\n    - HYB: $s=2 > \\theta=1$, 使用WU。成本+14。**HYB成本: 24**. 状态(S,S,S,I)。\n3.  `(1,0,R)`, `(1,1,R)`:\n    - WI: 2次读未命中。成本+10。**WI成本: 26**. 状态(S,S,S,I)。\n    - WU/HYB: 2次读命中。成本+0。\n4.  `(1,2,W)`:\n    - WI: 从S写，2个共享者。成本+1。**WI成本: 27**.\n    - WU/HYB: 从S写，2个共享者。成本+(1+2*4=9)。**WU/HYB成本: 33**.\n\n*行 1 最终成本: (27, 33, 33)*\n\n**TC1 总成本: (37+27, 46+33, 46+33) = (64, 79, 79)**\n\n---\n\n**测试用例 2: $P=3, M=1, \\theta=2$**\n1.  `(0,0,R)`, `(0,1,R)`, `(0,2,R)`: 3次读未命中。**成本: (15, 15, 15)**. 状态: (S,S,S)。\n2.  `(0,0,W)`: 从S写，2个共享者 ($s=2$)。\n    - WI: 成本+1。**WI成本: 16**.\n    - WU: 成本+(1+2*4=9)。**WU成本: 24**.\n    - HYB: $s=2 > \\theta=2$ 为假。使用WI。成本+1。**HYB成本: 16**.\n\n**TC2 总成本: (16, 24, 16)**\n\n---\n\n**测试用例 3: $P=2, M=1, \\theta=0$**\n1.  `(0,0,W)` #1: 写未命中。\n    - WI: 成本+6。**WI成本: 6**. 状态(M,I)。\n    - WU: 获取(5)+更新(1+0*4=1)=6。**WU成本: 6**. 状态(S,I)。\n    - HYB: $s=0 > \\theta=0$ 为假。使用WI。成本+6。**HYB成本: 6**. 状态(M,I)。\n2.  `(0,0,W)` #2-5 (4次写入):\n    - WI/HYB: 在M状态下写，成本+0。**WI/HYB最终成本: 6**.\n    - WU: 在S状态下写，0个共享者。每次成本+1。4次写入成本+4。**WU最终成本: 10**.\n\n**TC3 总成本: (6, 10, 6)**\n\n---\n\n**测试用例 4: $P=2, M=1, \\theta=1$ (乒乓)**\n1.  `(0,0,W)`: 写未命中。\n    - WI: 成本+6。状态(M,I)。**WI成本: 6**.\n    - WU: 成本+6。状态(S,I)。**WU成本: 6**.\n    - HYB: $s=0 > \\theta=1$ 为假。使用WI。成本+6。状态(M,I)。**HYB成本: 6**.\n2.  `(0,1,W)`: 写未命中。\n    - WI/HYB: C0为M。获取(5)+失效(1)=6。**WI/HYB成本: 12**. 状态(I,M)。\n    - WU: C0为S。获取(5)+更新(1+1*4=5)=10。**WU成本: 16**. 状态(S,S)。\n3.  `(0,0,W)`: 写未命中。\n    - WI/HYB: C1为M。成本+6。**WI/HYB成本: 18**. 状态(M,I)。\n    - WU: 从S写，1个共享者。成本+(1+1*4=5)。**WU成本: 21**. 状态(S,S)。\n4.  `(0,1,W)`: 写未命中。\n    - WI/HYB: C0为M。成本+6。**WI/HYB成本: 24**.\n    - WU: 从S写，1个共享者。成本+5。**WU成本: 26**.\n\n**TC4 总成本: (24, 26, 24)**\n\n---\n\n**最终结果汇总:**\n- **TC1:** [64, 79, 79]\n- **TC2:** [16, 24, 16]\n- **TC3:** [6, 10, 6]\n- **TC4:** [24, 26, 24]", "answer": "$$\n\\boxed{[[64, 79, 79], [16, 24, 16], [6, 10, 6], [24, 26, 24]]}\n$$", "id": "3678538"}]}