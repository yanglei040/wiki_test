{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式就是亲自动手。这项练习提供了一个具体的指令序列和微架构，要求你进行逐周期的仿真。通过这个过程，你将能够精确地应用记分板的各项规则，区分并计算由写后写（$WAW$）和写后读（$WAR$）冒险所引起的具体停顿周期数，从而牢固掌握记分板的核心工作机制 [@problem_id:3638650]。", "problem": "考虑一个玩具指令集架构（ISA），其具有三地址整数指令和一个经典的基于记分板（scoreboard-based）的动态调度器。该机器支持乱序执行，但受记分板的冒险（hazards）和阶段规则的约束。ISA 和微体系结构规则如下。\n\n- 指令集架构（ISA）：指令格式为 $\\mathrm{OP}\\;R_{d}, R_{s1}, R_{s2}$，语义为 $R_{d} \\leftarrow R_{s1}\\;\\mathrm{OP}\\;R_{s2}$。支持的操作和延迟如下：\n  - $\\mathrm{ADD}$ 在一个整数算术逻辑单元（ALU）上执行：延迟 $L_{A} = 2$ 个周期。\n  - $\\mathrm{MUL}$ 在一个乘法器上执行：延迟 $L_{M} = 5$ 个周期。\n  - $\\mathrm{LD}$ 在一个加载单元上执行：格式为 $\\mathrm{LD}\\;R_{d}, [R_{s1}]$，延迟为 $L_{L} = 3$ 个周期。假设地址由 $R_{s1}$ 中的值形成；不存在内存体冲突。\n\n- 微体系结构和记分板：\n  - 功能单元（FU）：$2$ 个 ALU，$1$ 个乘法器，$1$ 个加载单元。每个 FU 一次最多只能容纳一条指令；FU 在发射（Issue）阶段被预留，并在写回结果（Write Result）阶段后释放。\n  - 每条指令的流水线阶段：发射（Issue） $\\rightarrow$ 读操作数（Read Operands） $\\rightarrow$ 执行（Execute） $\\rightarrow$ 写回结果（Write Result）。发射和读操作数各占 $1$ 个周期；执行占用 $L$ 个周期，具体取决于操作；写回结果占用 $1$ 个周期。\n  - 周期内的阶段顺序：首先执行所有符合条件的写回结果操作，然后执行所有符合条件的读操作数操作，最后执行最多一条指令的单次发射。读操作数所需的操作数就绪状态在周期开始时评估，早于该周期内的任何写操作；在周期 $t$ 写入的值最早在周期 $t+1$ 才能被读取。\n  - 由记分板强制执行的冒险：\n    - 写后写（WAW）：在发射阶段，如果任何活动指令（已发射但尚未完成）的目标寄存器与传入指令的目标寄存器相同，则暂停（stall）。\n    - 读后写（RAW）：在读操作数阶段，暂停直到每个源寄存器都就绪（即，其最后一个较早的写入者已完成写回结果）。\n    - 写后读（WAR）：在写回结果阶段，如果任何更早的活动指令尚未执行读操作数，并且将写入者的目标寄存器用作其源寄存器之一，则暂停。\n  - 结果总线：只有一个全局写端口；每个周期最多只能发生一次写回结果。如果多条指令在同一周期准备好写入，除一条外，其余所有指令都会因结构性原因暂停。对于下面的问题，这些在写端口上的结构性暂停不得计入 WAW 或 WAR 暂停。\n\n- 初始条件：在周期 $1$，所有体系结构寄存器 $R_{0}, R_{1}, \\dots$ 都具有有效的初始值（即，它们被视为就绪），除了那些将由程序本身定义的寄存器。除了 $L_{L}$ 之外，没有缓存未命中或额外的内存延迟，也没有分支指令。\n\n要执行的程序（按程序顺序，指令标识符为 $I_{1}$ 到 $I_{5}$）：\n1. $I_{1}: \\mathrm{LD}\\;R_{9}, [R_{10}]$\n2. $I_{2}: \\mathrm{ADD}\\;R_{7}, R_{5}, R_{9}$\n3. $I_{3}: \\mathrm{ADD}\\;R_{5}, R_{1}, R_{2}$\n4. $I_{4}: \\mathrm{MUL}\\;R_{5}, R_{3}, R_{4}$\n5. $I_{5}: \\mathrm{ADD}\\;R_{8}, R_{5}, R_{6}$\n\n注意：\n- 两条指令 $I_{3}$ 和 $I_{4}$ 都写入 $R_{5}$，产生了目标寄存器别名（destination aliasing）。\n- 指令 $I_{2}$ 读取 $R_{5}$，但必须等待来自 $I_{1}$ 的 $R_{9}$，当后续指令尝试写入 $R_{5}$ 时，这会与 WAR 约束产生交互。\n- 按照规则允许的尽可能积极地调度执行以最小化总时间：每个阶段都应在记分板约束和 FU 可用性允许的最早周期发生。\n\n任务：\n计算在上述模型下，完整执行 $I_{1}$ 到 $I_{5}$ 期间，完全由写后写（WAW）和写后读（WAR）冒险导致的暂停周期总数。不要计算由读后写（RAW）冒险或结构性约束（如单一写端口或 FU 可用性）引起的暂停周期。将最终答案表示为单个整数。无需四舍五入。", "solution": "用户希望我确定在一个基于记分板的处理器上，对于给定的代码序列，完全由写后写（WAW）和写后读（WAR）冒险导致的暂停周期总数。\n\n### 步骤 1：问题验证\n\n**1. 提取给定条件：**\n*   **指令集和延迟：**\n    *   $\\mathrm{OP}\\;R_{d}, R_{s1}, R_{s2}$，其语义为 $R_{d} \\leftarrow R_{s1}\\;\\mathrm{OP}\\;R_{s2}$。\n    *   $\\mathrm{ADD}$：延迟 $L_{A} = 2$ 个周期。\n    *   $\\mathrm{MUL}$：延迟 $L_{M} = 5$ 个周期。\n    *   $\\mathrm{LD}\\;R_{d}, [R_{s1}]$：延迟 $L_{L} = 3$ 个周期。\n*   **微体系结构：**\n    *   功能单元（FU）：$2$ 个 ALU，$1$ 个乘法器，$1$ 个加载单元。FU 从发射到写回结果期间都处于繁忙状态。\n    *   流水线阶段：发射（$1$ 个周期），读操作数（$1$ 个周期），执行（$L$ 个周期），写回结果（$1$ 个周期）。\n    *   周期内阶段顺序：1. 写回结果，2. 读操作数，3. 发射。\n    *   操作数转发：在周期 $t$ 写入的结果在周期 $t+1$ 可用于读操作数。\n    *   写端口：单个写端口，每个周期最多允许一次写回结果。\n*   **冒险规则：**\n    *   **WAW (写后写)：** 如果有活动指令具有相同的目标寄存器，则在发射阶段暂停。\n    *   **RAW (读后写)：** 在读操作数阶段暂停，直到源寄存器就绪。\n    *   **WAR (写后读)：** 如果有更早的活动指令尚未使用其操作数，并且该指令使用写入者的目标寄存器作为其源之一，则在写回结果阶段暂停。\n*   **初始条件：**\n    *   在周期 1，除程序定义的寄存器外，所有寄存器都已就绪。\n*   **程序序列：**\n    1.  $I_{1}: \\mathrm{LD}\\;R_{9}, [R_{10}]$\n    2.  $I_{2}: \\mathrm{ADD}\\;R_{7}, R_{5}, R_{9}$\n    3.  $I_{3}: \\mathrm{ADD}\\;R_{5}, R_{1}, R_{2}$\n    4.  $I_{4}: \\mathrm{MUL}\\;R_{5}, R_{3}, R_{4}$\n    5.  $I_{5}: \\mathrm{ADD}\\;R_{8}, R_{5}, R_{6}$\n\n**2. 使用提取的给定条件进行验证：**\n*   **科学依据：**该问题是计算机体系结构中的一个经典练习，基于记分板动态调度既定的原理。所有规则和概念在该领域都是标准的。\n*   **适定性：**该问题提供了一套完整且确定性的规则、延迟和程序序列。目标是计算一个具体、可验证的量。存在唯一解。\n*   **客观性：**该问题以精确、正式的语言陈述，没有任何主观或模棱两可的术语。\n*   **完整性和一致性：**所有必要的参数（延迟、FU 数量、冒险规则）都已指定。这些规则内部一致，并允许对处理器的执行进行逐步模拟。\n*   **其他缺陷：**该问题并非无关紧要、比喻性或超出科学分析范围。它直接涉及动态调度的主题。\n\n**3. 结论与行动：**\n该问题有效且适定。我将通过详细的逐周期模拟来解决它。\n\n### 步骤 2：逐周期执行分析\n\n为了确定暂停周期的数量，我们将构建一个流水线时序图。每条指令依次通过以下阶段：发射（I）、读操作数（RO）、执行（E）和写回结果（WR）。暂停用 '(S)' 表示。延迟为 $L$ 的指令的执行需要 $L$ 个周期，在第 $L$ 个周期结束时完成。请注意，问题要求只计算 WAW 和 WAR 暂停。\n\n**指令相关性：**\n*   $I_2$ 对 $I_1$ 在寄存器 $R_9$ 上有 RAW 相关。\n*   $I_3$ 对 $I_2$ 在寄存器 $R_5$ 上有 WAR 相关（$I_2$ 在 $I_3$ 写入 $R_5$ 之前读取它）。\n*   $I_4$ 对 $I_3$ 在寄存器 $R_5$ 上有 WAW 相关。\n*   $I_5$ 对 $I_4$ 在寄存器 $R_5$ 上有 RAW 相关。\n\n**时间线：**\n*   **周期 1：**$I_1$ 发射（加载 FU 被占用）。\n*   **周期 2：**$I_1$ 读操作数。$I_2$ 发射（ALU1 被占用）。\n*   **周期 3：**$I_1$ 开始执行（3个周期中的第1个）。$I_2$ 在 RO 阶段暂停（在 $R_9$ 上存在 RAW 冒险，$I_1$ 尚未写入）。$I_3$ 发射（ALU2 被占用）。\n*   **周期 4：**$I_1$ 执行（3个周期中的第2个）。$I_2$ 仍然暂停（在 $R_9$ 上存在 RAW 冒险）。$I_3$ 读操作数。$I_4$ 尝试发射。它被阻塞，因为一条活动指令（$I_3$）也正在写入 $R_5$。这是一个 **WAW 暂停**。（WAW 暂停周期 = $1$）。\n*   **周期 5：**$I_1$ 执行（3个周期中的第3个），在此周期末尾完成。$I_2$ 仍然暂停（在 $R_9$ 上存在 RAW 冒险）。$I_3$ 开始执行（2个周期中的第1个）。由于来自 $I_3$ 的 **WAW 冒险**，$I_4$ 在发射阶段仍然暂停。（WAW 暂停周期 = $2$）。\n*   **周期 6：**$I_1$ 执行写回结果。$R_9$ 将在周期 7 可用。$I_2$ 仍然暂停（在 $R_9$ 上存在 RAW 冒险）。$I_3$ 执行（2个周期中的第2个），在此周期末尾完成。由于来自 $I_3$ 的 **WAW 冒险**，$I_4$ 在发射阶段仍然暂停。（WAW 暂停周期 = $3$）。\n*   **周期 7：**\n    *   $I_3$ 准备好进行写回结果。然而，一条更早的指令 $I_2$ 尚未使用其操作数，并且使用 $R_5$（$I_3$ 的目标）作为其源。$I_3$ 必须暂停。这是一个 **WAR 暂停**。（WAR 暂停周期 = $1$）。\n    *   $I_2$ 现在读取其操作数，因为 $R_9$ 已可用。\n    *   由于来自 $I_3$ 的 **WAW 冒险**（它仍然是活动的，因为它还没有完成 WR），$I_4$ 在发射阶段仍然暂停。（WAW 暂停周期 = $4$）。\n*   **周期 8：**\n    *   $I_3$ 的 WAR 条件现已解除，因为 $I_2$ 在前一个周期读取了其操作数。$I_3$ 执行写回结果。$I_3$ 对 $R_5$ 的寄存器预留被释放。\n    *   $I_2$ 开始执行（2个周期中的第1个）。\n    *   在同一周期内，随着 $I_3$ 的 WR 完成，$I_4$ 的 WAW 冒险被清除。$I_4$ 发射（乘法器 FU 被占用）。\n*   **周期 9：**$I_2$ 执行（2个周期中的第2个），在此周期末尾完成。$I_4$ 读操作数。$I_5$ 发射（ALU2 被占用）。\n*   **周期 10：**$I_2$ 执行写回结果。$I_4$ 开始执行（5个周期中的第1个）。$I_5$ 在 RO 阶段暂停（在 $R_5$ 上存在 RAW 冒险，$R_5$ 正在由 $I_4$ 计算）。\n*   **周期 11-14：**$I_4$ 继续执行（第2、3、4、5个周期）。$I_5$ 仍然暂停（RAW）。在周期 14 末尾，$I_4$ 完成执行。\n*   **周期 15：**$I_4$ 执行写回结果。没有 WAR 暂停，因为读取 $R_5$ 的 $I_5$ 是一条后续指令，而不是更早的指令。$R_5$ 将在周期 16 可用。$I_5$ 读操作数。\n*   **周期 16-17：**$I_5$ 执行。\n*   **周期 18：**$I_5$ 执行写回结果。所有指令都已完成。\n\n### 步骤 3：统计暂停\n\n我们现在对被明确标识为由 WAW 或 WAR 冒险引起的暂停周期进行求和。\n\n*   **WAW 暂停：**\n    *   指令 $I_4$ 在周期 4 就准备好发射，但由于 $I_3$ 正在写入同一目标寄存器 $R_5$ 而被阻塞。\n    *   $I_4$ 在周期 $4、5、6$ 和 $7$ 暂停。\n    *   总 WAW 暂停周期 = $4$。\n\n*   **WAR 暂停：**\n    *   指令 $I_3$ 在周期 7 就准备好执行写回结果，但由于一条更早的指令 $I_2$ 尚未读取其源操作数 $R_5$ 而被阻塞。\n    *   $I_3$ 在周期 7 暂停。\n    *   总 WAR 暂停周期 = $1$。\n\n*   **总暂停周期 (WAW + WAR)：**\n    *   完全由 WAW 和 WAR 冒险导致的暂停周期总数是各个计数的总和。\n    *   总计 = (WAW 暂停) + (WAR 暂停) = $4 + 1 = 5$。\n\n根据问题的指示，$I_2$ 和 $I_5$ 经历的暂停周期是由 RAW 冒险引起的，不予计算。写端口上没有发生结构性暂停。", "answer": "$$\n\\boxed{5}\n$$", "id": "3638650"}, {"introduction": "掌握了记分板的基本操作后，我们来探讨其性能的边界。这个练习设计了一个看似简单但实际上紧密耦合的指令序列，即使有多余的功能单元，执行也无法并行化。通过分析这个特殊的依赖链，你将深刻理解为何真数据依赖（$RAW$）是决定处理器性能的根本瓶颈，这对于性能分析至关重要 [@problem_id:3638642]。", "problem": "考虑一个经典的、基于 CDC 6600 风格的记分板动态调度处理器。记分板为每条指令实现了以下四个生命周期阶段：发射 (Issue)、读操作数 (Read Operands)、执行 (Execute) 和写结果 (Write Result)。规则如下：\n\n- 发射 (Issue)：只有当有合适的功能单元空闲，并且其目标寄存器上没有写后写 (WAW) 冒险时，指令才能按程序顺序发射。\n- 读操作数 (Read Operands)：当指令的两个源寄存器都标记为就绪（没有等待中的生产者），并且所有 RAW 约束都满足时，指令可以读取其源寄存器。\n- 执行 (Execute)：指令会占用其功能单元，持续时间为该操作特定的固定延迟。\n- 写结果 (Write Result)：当与任何尚未读取其操作数的更早指令没有读后写 (WAR) 冒险时，该指令可以写入其目标寄存器。\n\n假设该机器有两个相同的整数加法器。每条加法指令使用一个加法器，执行延迟为 $3$ 个周期。每个发射阶段需要 $1$ 个周期，每个读操作数阶段需要 $1$ 个周期，每个写结果阶段需要 $1$ 个周期。每个周期只能发射一条指令。功能单元在发射阶段被分配，并一直被占用直到写结果阶段完成。在周期 $t$ 的写结果阶段结束时，该功能单元在周期 $t+1$ 变为可用于发射。所有初始寄存器值在周期 $0$ 时可用。\n\n考虑以下三条按程序顺序排列的整数加法指令，其数据流是明确的：\n\n- 指令 $\\mathrm{I1}$: $R1 \\leftarrow R2 + R3$,\n- 指令 $\\mathrm{I2}$: $R2 \\leftarrow R1 + R4$,\n- 指令 $\\mathrm{I3}$: $R3 \\leftarrow R2 + R5$,\n\n其中 $R2$、$R3$、$R4$ 和 $R5$ 在周期 $0$ 时已就绪，并具有有效的初始值。\n\n仅根据上述记分板规则以及写后读 (RAW)、读后写 (WAR) 和写后写 (WAW) 冒险的语义，推断该指令序列的执行阶段是否存在并行性，并确定在给定的延迟和资源约束下，所有三条指令的最小完成时间（即最后一条指令的写结果阶段完成的周期）。以周期数表示最终时间。无需四舍五入。", "solution": "问题陈述经核实具有科学依据、定义明确、客观且内部一致。它描述了计算机体系结构中的一个经典场景，可以使用所提供的规则进行形式化分析。其中没有歧义或矛盾。\n\n问题要求确定在一个基于记分板的处理器上，一个包含三条指令的序列的执行阶段是否可能存在并行性，并找出最小完成时间。该分析需要对处理器的状态进行逐步模拟，模拟过程受记分板规则的支配，并受到数据依赖和资源可用性的约束。\n\n首先，我们识别指令之间的数据依赖关系：\n- 指令 $I1: R1 \\leftarrow R2 + R3$\n- 指令 $I2: R2 \\leftarrow R1 + R4$\n- 指令 $I3: R3 \\leftarrow R2 + R5$\n\n1.  **写后读 (RAW) 或真数据依赖**：一条指令必须等待其源操作数由前一条指令产生。\n    - $I2$ 读取由 $I1$ 写入的 $R1$。这产生了一个 RAW 依赖，表示为 $I1 \\xrightarrow{\\text{RAW}} I2$。$I2$ 必须等到 $I1$ 完成其写结果阶段后才能读取其操作数。\n    - $I3$ 读取由 $I2$ 写入的 $R2$。这产生了一个 RAW 依赖，$I2 \\xrightarrow{\\text{RAW}} I3$。$I3$ 必须等到 $I2$ 完成其写结果阶段后才能读取其操作数。\n    这些依赖关系形成一个链条：$I1 \\rightarrow I2 \\rightarrow I3$。\n\n2.  **读后写 (WAR) 或反依赖**：一条指令不能在一条更早的指令从同一个寄存器读取之前，写入其目标寄存器。\n    - $I2$ 写入 $R2$，而 $I1$ 会读取 $R2$。这产生了一个 WAR 依赖，$I1 \\xrightarrow{\\text{WAR}} I2$。$I2$ 必须等到 $I1$ 读取其操作数后才能写入其结果。\n    - $I3$ 写入 $R3$，而 $I1$ 会读取 $R3$。这产生了一个 WAR 依赖，$I1 \\xrightarrow{\\text{WAR}} I3$。$I3$ 必须等到 $I1$ 读取其操作数后才能写入其结果。\n    记分板通过延迟写入指令 ($I2$、$I3$) 的写结果阶段，直到读取指令 ($I1$) 完成其读操作数阶段，来处理这些冒险。\n\n3.  **写后写 (WAW) 或输出依赖**：一条指令不能在一条更早的指令写入同一个目标寄存器之前，写入该寄存器。\n    - 指令 $I1$、$I2$ 和 $I3$ 分别写入不同的寄存器（$R1$、$R2$、$R3$）。因此，它们之间不存在 WAW 冒险。相对于此序列中的其他指令，发射阶段可以继续进行而不会因 WAW 而停顿。\n\n处理器有两个相同的整数加法器，我们称之为 $FU1$ 和 $FU2$。每个阶段（发射、读操作数、写结果）需要 $1$ 个周期。加法操作的执行阶段需要 $3$ 个周期。功能单元从其被发射的周期开始被占用，直到其写结果阶段完成的周期为止。\n\n我们可以构建一个时序图来跟踪每条指令通过四个流水线阶段的进度：发射 ($I$)、读操作数 ($RO$)、执行 ($EX$) 和写结果 ($WR$)。表中的数字代表每个阶段完成的周期数。$EX$ 阶段的持续时间由它所占用的周期范围表示。\n\n| 指令           | 阶段 $I$ | 阶段 $RO$ | 阶段 $EX$     | 阶段 $WR$ | FU    | 注释 |\n|----------------|-----------|------------|----------------|------------|-------|----------|\n| $I1: R1 \\leftarrow R2+R3$ | $1$         | $2$          | $3, 4, 5$      | $6$          | $FU1$ | 在周期 1 发射。$R2, R3$ 已就绪，因此 RO 在周期 2。 |\n| $I2: R2 \\leftarrow R1+R4$ | $2$         | $7$          | $8, 9, 10$     | $11$         | $FU2$ | 在周期 2 发射。因 $R1$ 上的 RAW 停顿。$I1$ 的 WR 在周期 6 完成，因此 $I2$ 的 RO 在周期 7 开始。 |\n| $I3: R3 \\leftarrow R2+R5$ | $7$         | $12$         | $13, 14, 15$   | $16$         | $FU1$ | 因 FU 停顿。$FU1$ 在周期 7 空闲。因 $R2$ 上的 RAW 停顿。$I2$ 的 WR 在周期 11 完成，因此 $I3$ 的 RO 在周期 12 开始。 |\n\n**逐周期分析：**\n\n- **周期 1**：$I1$ 发射，因为 $FU1$ 空闲且没有 WAW 冒险。$FU1$ 分配给 $I1$。\n- **周期 2**：$I1$ 进入读操作数 ($RO$) 阶段。其源寄存器 $R2$ 和 $R3$ 在周期 0 时已就绪。$I1$ 完成 $RO$。同时，$I2$ 发射，因为 $FU2$ 空闲。$FU2$ 分配给 $I2$。$I3$ 无法发射，因为每个周期只能发射一条指令。\n- **周期 3**：$I1$ 开始其为期 3 个周期的执行。它将占用 $FU1$ 三个周期（周期 3、4、5）。$I2$ 尝试进入其 $RO$ 阶段但停顿，因为其源寄存器 $R1$ 尚未就绪（它正由 $I1$ 产生）。$I3$ 无法发射，因为两个功能单元现在都已被分配。\n- **周期 4、5**：$I1$ 继续执行。$I2$ 继续在 $RO$ 阶段停顿。$I3$ 继续在发射阶段停顿。\n- **周期 6**：$I1$ 完成执行并进入写结果 ($WR$) 阶段。它写入 $R1$。WAR 冒险检查 ($I1 \\xrightarrow{\\text{WAR}} I2, I3$) 没有影响，因为 $I1$ 是第一条指令。$R1$ 在此周期结束时变得可用。$I2$ 仍在等待 $R1$。$I3$ 仍在等待空闲的 FU。\n- **周期 7**：$I1$ 完成。$FU1$ 对新指令变得可用（因为 $I1$ 的 $WR$ 在周期 $t=6$ 完成，FU 在 $t+1=7$ 空闲）。$I3$ 现在发射，占用 $FU1$。同时，$I2$ 检测到 $R1$ 已就绪，并进入其 $RO$ 阶段，该阶段在本周期完成。\n- **周期 8**：$I2$ 在 $FU2$ 中开始其为期 3 个周期的执行（周期 8、9、10）。$I3$ 尝试进入其 $RO$ 阶段但停顿，等待来自 $I2$ 的 $R2$。\n- **周期 9、10**：$I2$ 继续执行。$I3$ 继续在 $RO$ 阶段停顿。\n- **周期 11**：$I2$ 完成执行并进入 $WR$ 阶段。它写入 $R2$。WAR 冒险检查 ($I1 \\xrightarrow{\\text{WAR}} I2$) 通过，因为 $I1$ 在周期 2 已完成其 $RO$ 阶段。$R2$ 在此周期结束时变得可用。\n- **周期 12**：$I2$ 完成。$I3$ 检测到 $R2$ 已就绪，并进入其 $RO$ 阶段。\n- **周期 13、14、15**：$I3$ 处于 $EX$ 阶段，使用 $FU1$。\n- **周期 16**：$I3$ 完成执行并进入 $WR$ 阶段。WAR 冒险检查 ($I1 \\xrightarrow{\\text{WAR}} I3$) 通过，因为 $I1$ 在周期 2 已完成其 $RO$ 阶段。它写入 $R3$ 并完成。\n\n**关于并行性和完成时间的结论：**\n\n三条指令的执行阶段发生在以下周期区间：\n- $I1_{EX}$：周期 $3-5$\n- $I2_{EX}$：周期 $8-10$\n- $I3_{EX}$：周期 $13-15$\n\n这些区间是不相交的。因此，**在执行阶段没有实现任何并行性**。强大的 RAW 依赖链 ($I1 \\xrightarrow{\\text{RAW}} I2 \\xrightarrow{\\text{RAW}} I3$) 串行化了执行过程，尽管有两个功能单元可用，指令仍被迫一个接一个地进行。\n\n最后一条指令 $I3$ 在周期 16 结束时完成其写结果阶段。因此，所有三条指令的最小完成时间为 $16$ 个周期。", "answer": "$$ \\boxed{16} $$", "id": "3638642"}, {"introduction": "这项进阶练习将记分板与现代处理器设计的关键技术——寄存器重命名联系起来。它通过一个循环代码片段，揭示了“假依赖”（$WAR$ 和 $WAW$）是如何限制指令级并行性的。通过对比有无寄存器重命名的性能差异，你将能从根本上理解为何寄存器重命名是解锁处理器潜能、实现更高性能的基石 [@problem_id:3638623]。", "problem": "一个中央处理器（CPU）实现了一个经典的计分板（scoreboard），具有顺序发射、乱序读写以及以下特性。一条指令经历四个概念性阶段：发射（Issue）、读操作数（Read Operands）、执行（Execute）和写回结果（Write Result）。计分板按如下方式解决冒险：在发射阶段，通过禁止对同一架构寄存器有多个活跃的写入者来防止写后写（WAW）冒险；在读操作数阶段，通过延迟操作数读取，直到每个源寄存器最近的生产者已写回其结果，来防止写后读（RAW）冒险；在写回结果阶段，通过延迟写入，直到所有读取该寄存器的更早指令都已完成其读取操作，来防止读后写（WAR）冒险。功能单元的可用性会被跟踪；每条指令在发射阶段必须获取一个功能单元。假设功能单元是完全流水线化的，具有固定的执行延迟，并且除了计分板已建模的情况外，寄存器文件或写回端口上没有结构性冲突。\n\n考虑一个无限循环的微基准测试，其迭代体由三条指令组成：\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$ (使用加法器),\n- $I_2$: $R_2 \\leftarrow R_1 + R_4$ (使用加法器),\n- $I_3$: $R_3 \\leftarrow R_2 \\times R_5$ (使用乘法器),\n\n其中 $R_4$ 和 $R_5$ 是循环不变量。加法器的执行延迟为 $L_A$ 个周期，乘法器的执行延迟为 $L_M$ 个周期。一条指令的结果在其执行延迟完成后的下一个周期即可供相关的消费者指令使用。假设循环的调度方式是，在每次迭代中，三条指令按程序顺序 $I_1$, $I_2$, $I_3$ 出现，并且循环中没有其他指令。\n\n任务：\n- 从数据相关和冒险（RAW, WAR, WAW）的基本定义出发，构建单次迭代内的相关关系以及跨越连续迭代的循环携带相关。解释为什么在一个没有寄存器重命名（寄存器重命名 (RR) 是将架构寄存器动态映射到不同的物理寄存器以消除伪相关）的计分板下，这些关系会产生一个有向循环，即使功能单元是完全流水线化的，也迫使迭代必须串行启动。\n- 然后，假设理想的寄存器重命名消除了所有反相关（WAR）和输出相关（WAW），同时保留了真数据相关（RAW），请从第一性原理推导出该循环可以实现的最小稳态启动间隔（以每迭代周期数衡量），并将其表示为 $L_A$ 和 $L_M$ 的函数。\n- 最后，计算当 $L_A = 2$ 和 $L_M = 4$ 时你的表达式的值，并将稳态启动间隔报告为单个数字。将你的最终答案表示为每迭代的周期数（无单位）。无需四舍五入。", "solution": "用户提供的问题是计算机体系结构中的一个有效练习，具体涉及带有计分板的动态调度处理器的性能分析。所有提供的信息都是自包含、一致且科学地基于已确立的处理器设计原则。因此，我们可以进行完整的解答。\n\n分析按要求分为三个部分：首先， examining the loop execution without register renaming; second, the derivation of the minimum initiation interval with ideal register renaming; and third, a numerical evaluation of the result.\n\n### 第1部分：无寄存器重命名时的分析\n\n当两条指令访问相同的内存位置或寄存器，并且至少有一次访问是写入时，它们之间就存在数据相关。数据相关有三种类型：\n1.  写后读 (RAW)，或称真相关：一条指令在先前的指令写入某个位置后读取它。例如：$I_i: R_x \\leftarrow \\dots; \\dots; I_j: \\dots \\leftarrow R_x + \\dots$。\n2.  读后写 (WAR)，或称反相关：一条指令在先前的指令读取某个位置后写入它。例如：$I_i: \\dots \\leftarrow R_x + \\dots; \\dots; I_j: R_x \\leftarrow \\dots$。\n3.  写后写 (WAW)，或称输出相关：一条指令在先前的指令也写入某个位置后写入它。例如：$I_i: R_x \\leftarrow \\dots; \\dots; I_j: R_x \\leftarrow \\dots$。\n\nRAW 相关代表真实的数据流。WAR 和 WAW 相关是“伪”相关或“名称”相关，因为它们是由有限数量的架构寄存器名称的复用引起的，而不是因为数据需要在指令之间流动。\n\n令 $I_j^k$ 表示迭代 $k$ 中的指令 $I_j$。这些指令是：\n- $I_1^k: R_1 \\leftarrow R_2 + R_3$\n- $I_2^k: R_2 \\leftarrow R_1 + R_4$\n- $I_3^k: R_3 \\leftarrow R_2 \\times R_5$\n\n**单次迭代 ($k$) 内的相关：**\n-   $I_1^k \\xrightarrow{\\text{RAW}, R_1} I_2^k$: $I_2^k$ 在 $I_1^k$ 写入 $R_1$后读取它。\n-   $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_3^k$: $I_3^k$ 在 $I_2^k$ 写入 $R_2$后读取它。\n-   $I_1^k \\xrightarrow{\\text{WAR}, R_2} I_2^k$: $I_2^k$ 在 $I_1^k$ 读取 $R_2$后写入它。\n-   $I_1^k \\xrightarrow{\\text{WAR}, R_3} I_3^k$: $I_3^k$ 在 $I_1^k$ 读取 $R_3$后写入它。\n\n**循环携带相关（从迭代 $k$ 到 $k+1$）：**\n$I_1^{k+1}$ 读取的寄存器 $R_2$ 和 $R_3$ 的值是在迭代 $k$ 中产生的。\n-   $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_1^{k+1}$: $I_1^{k+1}$ 读取由 $I_2^k$ 产生的 $R_2$ 的值。\n-   $I_3^k \\xrightarrow{\\text{RAW}, R_3} I_1^{k+1}$: $I_1^{k+1}$ 读取由 $I_3^k$ 产生的 $R_3$ 的值。\n\n由于寄存器名称 $R_1, R_2, R_3$ 的复用，跨迭代也存在伪相关。\n-   $I_j^k \\xrightarrow{\\text{WAW}, R_j} I_j^{k+1}$ 对于 $j \\in \\{1, 2, 3\\}$。例如，$I_2^k$ 和 $I_2^{k+1}$ 都写入 $R_2$。\n-   $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_2} I_2^{k+1}$: $I_2^{k+1}$ 写入 $R_2$，而更早的指令 $I_1^{k+1}$ 读取了 $R_2$。\n-   $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_3} I_3^{k+1}$: $I_3^{k+1}$ 写入 $R_3$，而更早的指令 $I_1^{k+1}$ 读取了 $R_3$。\n\n由于这些相关的相互作用，经典的计分板会串行化迭代。让我们以寄存器 $R_2$ 为例。一个约束的有向循环形成了：\n1.  **RAW 冒险**: $I_2^k \\xrightarrow{\\text{RAW}, R_2} I_1^{k+1}$。计分板将暂停 $I_1^{k+1}$ 的读操作数阶段，直到 $I_2^k$ 完成其写回结果阶段。让我们将指令 $I$ 的阶段 `S` 表示为 $S(I)$。这意味着 $RO(I_1^{k+1})$ 必须在 $WB(I_2^k)$ 之后发生。\n2.  **WAR 冒险**: $I_1^{k+1} \\xrightarrow{\\text{WAR}, R_2} I_2^{k+1}$。计分板将延迟 $I_2^{k+1}$ 的写回结果阶段，直到更早的指令 $I_1^{k+1}$ 完成其读操作数阶段。这意味着 $WB(I_2^{k+1})$ 必须在 $RO(I_1^{k+1})$ 之后发生。\n3.  **WAW 冒险**: $I_2^k \\xrightarrow{\\text{WAW}, R_2} I_2^{k+1}$。计分板将暂停 $I_2^{k+1}$ 的发射阶段，直到 $I_2^k$ 不再是活跃的写入者，这意味着 $I_2^k$ 必須完成其写回结果阶段。这意味着 $Issue(I_2^{k+1})$ 必须在 $WB(I_2^k)$ 之后发生。\n\n结合这些约束，我们得到一个链条：$WB(I_2^k)$ 使得 $Issue(I_2^{k+1})$ 可以继续，同时也使得 $RO(I_1^{k+1})$ 可以进行。$RO(I_1^{k+1})$ 的完成反过来又使得 $WB(I_2^{k+1})$ 可以进行。因此，$I_2^{k+1}$ 的执行受到 $I_2^k$ 的完成和 $I_1^{k+1}$ 进度的严格约束。寄存器 $R_3$ 也存在类似的循环。这些迭代间的 RAW、WAR 和 WAW 冒险作用于相同寄存器名称的净效应是，迭代 $k+1$ 不能与迭代 $k$ 大幅重叠。迭代 $k+1$ 的开始依赖于迭代 $k$ 的完成，从而迫使迭代串行启动。\n\n### 第2部分：使用理想寄存器重命名时的分析\n\n理想的寄存器重命名通过将架构寄存器动态映射到一个大的物理寄存器池来消除所有的 WAR 和 WAW 冒险。这只留下了真数据 (RAW) 相关。最小稳态启动间隔 $II$ 是连续循环迭代开始之间的时间。它受到两个因素的制约：数据流图中的递归 ($II_{rec}$) 和硬件资源限制 ($II_{res}$)。可实现的 $II$ 是这两个下界的最大值：$II = \\max(II_{rec}, II_{res})$。\n\n**递归约束的最小启动间隔 ($II_{rec}$):**\n我们分析 RAW 相关来寻找跨越迭代边界的相关图中的循环。令 $S_j(k)$ 为迭代 $k$ 中指令 $I_j$ 的执行开始时间。指令的结果在其延迟之后才可用。相关指令的开始时间必须大于或等于所需结果可用的时间。\nRAW 相关给出以下不等式：\n1.  $S_2(k) \\ge S_1(k) + L_A$\n2.  $S_3(k) \\ge S_2(k) + L_A$\n3.  $S_1(k+1) \\ge S_2(k) + L_A$\n4.  $S_1(k+1) \\ge S_3(k) + L_M$\n\n为了找到最小的 $II$，我们寻找最紧的约束。我们可以结合这些不等式来找到形成递归的最长相关路径。\n根据 (4)，我们有迭代 $k+1$ 中 $I_1$ 的开始依赖于迭代 $k$ 中 $I_3$ 的完成。\n$$ S_1(k+1) \\ge S_3(k) + L_M $$\n将 (2) 代入此表达式：\n$$ S_1(k+1) \\ge (S_2(k) + L_A) + L_M $$\n将 (1) 代入此表达式：\n$$ S_1(k+1) \\ge ( (S_1(k) + L_A) + L_A ) + L_M $$\n$$ S_1(k+1) \\ge S_1(k) + 2L_A + L_M $$\n这个不等式追踪了关键的递归路径：$I_1^k \\xrightarrow{} I_2^k \\xrightarrow{} I_3^k \\xrightarrow{} I_1^{k+1}$。\n在稳態下，连续迭代中相同指令的开始时间之差就是启动间隔 $II$。因此，$S_1(k+1) = S_1(k) + II$。将此代入不等式得到：\n$$ S_1(k) + II \\ge S_1(k) + 2L_A + L_M $$\n$$ II \\ge 2L_A + L_M $$\n这确立了递归约束的下界：$II_{rec} = 2L_A + L_M$。\n\n**资源约束的最小启动间隔 ($II_{res}$):**\n此界限由对每种功能单元的需求决定。功能单元是完全流水线化的，意味着它们可以在每个时钟周期接受一个新操作。\n-   **加法器:** 由 $I_1$ 和 $I_2$ 使用。每次迭代使用2次。有1个加法器单元，服务这些请求所需的最小间隔是 $II_{res}(\\text{加法器}) = \\frac{2 \\text{ 次使用}}{1 \\text{ 个单元}} = 2$ 周期/迭代。\n-   **乘法器:** 由 $I_3$ 使用。每次迭代使用1次。有1个乘法器单元，最小间隔是 $II_{res}(\\text{乘法器}) = \\frac{1 \\text{ 次使用}}{1 \\text{ 个单元}} = 1$ 周期/迭代。\n\n总体资源约束的最小启动间隔 (MII) 是所有资源类型中的最大值：\n$$ II_{res} = \\max(2, 1) = 2 $$\n\n**最小启动间隔 ($II$):**\n可实现的启动间隔是递归约束和资源约束的最大值。\n$$ II = \\max(II_{rec}, II_{res}) = \\max(2L_A + L_M, 2) $$\n由于执行延迟 $L_A$ 和 $L_M$ 是正整数（至少为 $1$），项 $2L_A + L_M$ 将至少为 $2(1) + 1 = 3$。因此，递归总是限制因素。\n$$ II = 2L_A + L_M $$\n\n### 第3部分：数值计算\n\n给定延迟 $L_A = 2$ 个周期和 $L_M = 4$ 个周期。将这些值代入我们推导出的最小启动间隔表达式中：\n$$ II = 2(2) + 4 $$\n$$ II = 4 + 4 $$\n$$ II = 8 $$\n最小稳態启动间隔是 8 个周期/迭代。", "answer": "$$\\boxed{8}$$", "id": "3638623"}]}