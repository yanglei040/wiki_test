{"hands_on_practices": [{"introduction": "这个练习提供了一个具体的、动手实践的乱序执行核心模拟。通过首先仅基于数据依赖性计算理想的执行时间，然后模拟在现实约束（如有限的功能单元和发射宽度）下的执行过程，你将直接观察到资源争用如何引入延迟，并区分理论性能与实际性能。这项实践对于理解乱序执行中性能瓶颈的来源至关重要。[@problem_id:3662826]", "problem": "考虑一个指令级数据流图，该图为一个乱序（OOO）超标量核心中的线性程序片段建模。每个节点 $i$ 是一条延迟为 $L_i$（单位：周期）的指令，如果指令 $i$ 依赖于指令 $j$ 的结果，则存在一条有向边 $j \\rightarrow i$。假设不由任何节点产生的操作数（例如，常数）在周期 $0$ 时就绪。该图具有以下节点、边和延迟：\n- 节点和延迟：\n  - $I_1$: 加载， $L_1 = 3$\n  - $I_2$: 加载， $L_2 = 3$\n  - $I_3$: 乘法， $L_3 = 3$\n  - $I_4$: 整数加法， $L_4 = 1$\n  - $I_5$: 整数加法， $L_5 = 1$\n  - $I_6$: 乘法， $L_6 = 3$\n  - $I_7$: 整数加法， $L_7 = 1$\n  - $I_8$: 存储， $L_8 = 1$\n- 有向边（真相关）：\n  - $I_1 \\rightarrow I_3$, $I_2 \\rightarrow I_3$, $I_2 \\rightarrow I_5$, $I_3 \\rightarrow I_4$, $I_4 \\rightarrow I_6$, $I_5 \\rightarrow I_6$, $I_6 \\rightarrow I_7$, $I_7 \\rightarrow I_8$\n- $I_4$、$I_5$ 和 $I_7$ 的所有其他输入是在周期 $0$ 时就绪的独立常数。$I_1$、$I_2$ 和 $I_8$ 的地址在周期 $0$ 时就绪，且内存系统没有缓存未命中或冲突。\n\n架构模型（本问题中固定）：\n- 该核心执行乱序（OOO）执行，具有寄存器重命名、无限的保留站（RS）和无限的重排序缓冲（ROB）。\n- 发射宽度 $W = 2$：每个周期最多可以发射 $2$ 条指令。\n- 功能单元（全部为完全流水线化）：\n  - 一个加载单元（用于 $I_1$, $I_2$），每个周期最多可开始一次加载；加载延迟为 $3$。\n  - 两个相同的整数算术逻辑单元（ALU）用于加法（用于 $I_4$, $I_5$, $I_7$）；每个延迟为 $1$，每个周期可接受一个新的加法操作。\n  - 一个乘法单元（用于 $I_3$, $I_6$），延迟为 $3$；每个周期可接受一个新的乘法操作。\n  - 一个存储单元（用于 $I_8$），延迟为 $1$；每个周期可接受一个新的存储操作。\n- 时序语义：如果一条延迟为 $L$ 的指令在周期 $t$ 开始，其结果在周期 $t+L$ 的开始时可用。一条相关的指令可以在周期 $t+L$ 开始，前提是有一个匹配的功能单元可以接受它，并且在该周期内未超过发射宽度。\n- 确定性决胜规则：在任何周期中，在所有考虑到单元可用性可以发射的就绪指令中，调度器按指令索引递增的顺序选择，直到达到每周期的发射宽度。\n\n任务：\n1. 仅使用数据相关和延迟（即，假设功能单元和发射宽度无限），计算每个节点 $I_i$ 的最早开始时间 $\\operatorname{EST}(I_i)$。然后，在这些仅考虑相关的约束下，计算最终指令 $I_8$ 的关键路径完成时间 $T_{\\mathrm{CP}}$。\n2. 在给定的 OOO 核心约束下，通过模拟逐周期发射来计算 $I_8$ 的实际调度完成时间 $T_{\\mathrm{OOO}}$，模拟需遵循就绪性、功能单元可用性和发射宽度的限制。请严格按照指定的时序语义和决胜规则进行。\n3. 令 $\\Delta = T_{\\mathrm{OOO}} - T_{\\mathrm{CP}}$。$\\Delta$ 的值是多少？请以单个实数的形式表示您的答案（单位：周期）。最终的数值答案中不要包含任何单位标签。无需四舍五入。", "solution": "用户要求我解决一个涉及乱序执行的计算机体系结构问题。\n\n### 步骤 1：提取已知条件\n- **节点和延迟 ($L_i$)**：\n  - $I_1$: 加载, $L_1 = 3$ 周期\n  - $I_2$: 加载, $L_2 = 3$ 周期\n  - $I_3$: 乘法, $L_3 = 3$ 周期\n  - $I_4$: 整数加法, $L_4 = 1$ 周期\n  - $I_5$: 整数加法, $L_5 = 1$ 周期\n  - $I_6$: 乘法, $L_6 = 3$ 周期\n  - $I_7$: 整数加法, $L_7 = 1$ 周期\n  - $I_8$: 存储, $L_8 = 1$ 周期\n- **有向边（相关性）**：\n  - $I_1 \\rightarrow I_3$, $I_2 \\rightarrow I_3$, $I_2 \\rightarrow I_5$, $I_3 \\rightarrow I_4$, $I_4 \\rightarrow I_6$, $I_5 \\rightarrow I_6$, $I_6 \\rightarrow I_7$, $I_7 \\rightarrow I_8$\n- **初始条件**：\n  - 不由任何节点产生的操作数在周期 $0$ 时就绪。\n  - $I_1$、$I_2$ 和 $I_8$ 的地址在周期 $0$ 时就绪。\n- **架构模型**：\n  - 乱序（OOO）执行，无限的保留站（RS）和重排序缓冲（ROB）。\n  - 发射宽度 $W = 2$ 条指令/周期。\n  - 功能单元（全部为完全流水线化）：\n    - 1个加载单元（可启动1次加载/周期）。\n    - 2个整数ALU（每个可启动1次加法/周期，总共2次加法/周期）。\n    - 1个乘法单元（可启动1次乘法/周期）。\n    - 1个存储单元（可启动1次存储/周期）。\n- **时序语义**：\n  - 延迟为 $L$ 的指令在周期 $t$ 开始，其结果在周期 $t+L$ 的开始时可用。\n- **决胜规则**：\n  - 在就绪指令中，按指令索引递增的顺序发射。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是计算机体系结构中的一个标准练习，具体涉及乱序超标量处理器中的指令调度。\n- **科学依据**：该问题基于计算机组织与体系结构的既定原则，包括数据流图、关键路径分析以及带资源约束的OOO执行建模。所有概念都是标准且定义明确的。\n- **适定性**：问题陈述清晰，包含了所有必要的参数（延迟、相关性、机器模型）。确定性的决胜规则确保了调度模拟存在唯一解。\n- **客观性**：语言精确且技术性强，没有主观性或歧义。\n\n该问题是自包含且内部一致的。它不违反任何科学原则，不是不适定的，也不是微不足道的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n**第 1 部分：关键路径分析**\n首先，我们仅考虑数据相关性，计算每条指令的最早开始时间 $\\operatorname{EST}(I_i)$ 和最早完成时间 $\\operatorname{ECT}(I_i)$。我们假设资源无限。一条指令的 $\\operatorname{EST}$ 是它所依赖的所有指令的 $\\operatorname{ECT}$ 的最大值。没有相关性的指令可以在周期 $0$ 开始。完成时间为 $\\operatorname{ECT}(I_i) = \\operatorname{EST}(I_i) + L_i$。\n\n- $\\operatorname{EST}(I_1) = 0$。 $\\operatorname{ECT}(I_1) = 0 + L_1 = 0 + 3 = 3$。\n- $\\operatorname{EST}(I_2) = 0$。 $\\operatorname{ECT}(I_2) = 0 + L_2 = 0 + 3 = 3$。\n- $\\operatorname{EST}(I_3) = \\max(\\operatorname{ECT}(I_1), \\operatorname{ECT}(I_2)) = \\max(3, 3) = 3$。 $\\operatorname{ECT}(I_3) = 3 + L_3 = 3 + 3 = 6$。\n- $\\operatorname{EST}(I_5) = \\operatorname{ECT}(I_2) = 3$。 $\\operatorname{ECT}(I_5) = 3 + L_5 = 3 + 1 = 4$。\n- $\\operatorname{EST}(I_4) = \\operatorname{ECT}(I_3) = 6$。 $\\operatorname{ECT}(I_4) = 6 + L_4 = 6 + 1 = 7$。\n- $\\operatorname{EST}(I_6) = \\max(\\operatorname{ECT}(I_4), \\operatorname{ECT}(I_5)) = \\max(7, 4) = 7$。 $\\operatorname{ECT}(I_6) = 7 + L_6 = 7 + 3 = 10$。\n- $\\operatorname{EST}(I_7) = \\operatorname{ECT}(I_6) = 10$。 $\\operatorname{ECT}(I_7) = 10 + L_7 = 10 + 1 = 11$。\n- $\\operatorname{EST}(I_8) = \\operatorname{ECT}(I_7) = 11$。\n\n最终指令 $I_8$ 的关键路径完成时间为 $T_{\\mathrm{CP}} = \\operatorname{ECT}(I_8) = \\operatorname{EST}(I_8) + L_8 = 11 + 1 = 12$。\n\n**第 2 部分：OOO 执行模拟**\n接下来，我们模拟在指定的 OOO 核心上的执行过程，考虑发射宽度 $W=2$ 和功能单元约束。我们跟踪每条指令 $I_i$ 的开始时间 `S(i)` 和完成时间 `C(i)`。\n\n- **周期 0**：\n  - 所有操作数均已就绪的指令：$I_1, I_2$。\n  - 调度器先考虑 $I_1$，再考虑 $I_2$。\n  - $I_1$ 需要加载单元，该单元可用。发射 $I_1$。$S(I_1)=0$， $C(I_1)=0+3=3$。\n  - $I_2$ 需要加载单元。但是，单个加载单元每个周期只能开始一条指令。$I_2$ 无法发射。\n  - 已发射：{$I_1$}。\n\n- **周期 1**：\n  - 指令 $I_2$ 仍然就绪。\n  - 加载单元可用于开始一个新操作。发射 $I_2$。$S(I_2)=1$， $C(I_2)=1+3=4$。\n  - 已发射：{$I_2$}。\n\n- **周期 2-3**：\n  - 没有指令就绪。在周期 $3$ 的开始，$I_1$ 完成。\n\n- **周期 4**：\n  - 在这个周期的开始，$I_2$ 完成。来自 $I_1$（自周期 $3$ 起）和 $I_2$（现在）的结果均可用。\n  - $I_3$ 变为就绪：其来自 $I_1$ 和 $I_2$ 的输入可用。就绪时间为 $\\max(C(I_1), C(I_2)) = \\max(3, 4) = 4$。\n  - $I_5$ 变为就绪：其来自 $I_2$ 的输入可用。就绪时间为 $C(I_2) = 4$。\n  - 就绪队列：{$I_3, I_5$}。\n  - 调度器考虑 $I_3$（需要乘法单元，可用）和 $I_5$（需要ALU，可用）。由于 $W=2$，两者都可以发射。\n  - 发射 $I_3$：$S(I_3)=4$， $C(I_3)=4+3=7$。\n  - 发射 $I_5$：$S(I_5)=4$， $C(I_5)=4+1=5$。\n  - 已发射：{$I_3, I_5$}。\n\n- **周期 5-6**：\n  - 在周期 $5$ 的开始，$I_5$ 完成。没有新指令变为就绪（$I_6$ 在等待 $I_4$）。\n  - 没有指令被发射。\n\n- **周期 7**：\n  - 在这个周期的开始，$I_3$ 完成。\n  - $I_4$ 变为就绪：其来自 $I_3$ 的输入可用。就绪时间为 $C(I_3)=7$。\n  - 发射 $I_4$（需要ALU，可用）。$S(I_4)=7$， $C(I_4)=7+1=8$。\n  - 已发射：{$I_4$}。\n\n- **周期 8**：\n  - 在这个周期的开始，$I_4$ 完成。\n  - $I_6$ 变为就绪：其来自 $I_4$ 和 $I_5$ 的输入可用。就绪时间为 $\\max(C(I_4), C(I_5)) = \\max(8, 5) = 8$。\n  - 发射 $I_6$（需要乘法单元，可用）。$S(I_6)=8$， $C(I_6)=8+3=11$。\n  - 已发射：{$I_6$}。\n\n- **周期 9-10**：\n  - 没有指令被发射。\n\n- **周期 11**：\n  - 在这个周期的开始，$I_6$ 完成。\n  - $I_7$ 变为就绪：来自 $I_6$ 的输入可用。就绪时间为 $C(I_6)=11$。\n  - 发射 $I_7$（需要ALU，可用）。$S(I_7)=11$， $C(I_7)=11+1=12$。\n  - 已发射：{$I_7$}。\n\n- **周期 12**：\n  - 在这个周期的开始，$I_7$ 完成。\n  - $I_8$ 变为就绪：来自 $I_7$ 的输入可用。就绪时间为 $C(I_7)=12$。\n  - 发射 $I_8$（需要存储单元，可用）。$S(I_8)=12$， $C(I_8)=12+1=13$。\n  - 已发射：{$I_8$}。\n\n当 $I_8$ 完成时，模拟结束。实际调度完成时间为 $T_{\\mathrm{OOO}} = C(I_8) = 13$。\n\n**第 3 部分：$\\Delta$ 的计算**\n问题要求计算 $\\Delta = T_{\\mathrm{OOO}} - T_{\\mathrm{CP}}$ 的值。\n使用前面部分计算出的值：\n$T_{\\mathrm{CP}} = 12$\n$T_{\\mathrm{OOO}} = 13$\n$\\Delta = 13 - 12 = 1$。\n\n延迟是由周期 0 时的结构冒险引起的，此时 $I_1$ 和 $I_2$ 竞争唯一的加载单元。这迫使 $I_2$ 延迟了一个周期，而这个一周期延迟沿着关键路径传播到了最终指令。", "answer": "$$\n\\boxed{1}\n$$", "id": "3662826"}, {"introduction": "寄存器重命名是乱序执行的基石，但它需要一个比体系结构寄存器数量更多的物理寄存器池。这项练习要求你推导出维持特定性能水平所需的最小物理寄存器数量，将流水线深度和并行性与这一关键硬件资源联系起来。对于任何乱序处理器设计者来说，这都是一项基础性分析。[@problem_id:3662897]", "problem": "考虑一个单线程循环，运行在一个具有寄存器重命名、乱序执行、顺序提交和精确异常的核心上。该处理器实现了经典的寄存器重命名机制，带有一个重命名映射表和一个物理寄存器空闲列表。在重命名一个目标寄存器时，会立即分配一个新的物理寄存器，而先前映射到该架构寄存器名的物理寄存器只有在重新定义它的指令提交时才会被返回到空闲列表中。提交阶段按顺序更新架构映射表，并在重新定义指令提交时释放先前的物理映射，而不是更早。\n\n假设循环和机器具有以下稳态特性：\n- 循环体恰好有 $k$ 个不同的标量临时变量，每个都由一个唯一的架构寄存器表示，并且在每次迭代中被精确地重新定义一次。\n- 在稳态下，循环以每 $1$ 个周期 $1$ 次迭代的持续启动间隔运行（也就是说，每 $1$ 个周期就有一个新的迭代开始进行重命名）。\n- 对于每个临时变量，在给定的迭代中，从其重命名（分配新目标寄存器）到重新定义它的指令在该迭代中顺序提交的时间是一个恒定的 $D$ 个周期。你可以将 $D$ 视为一个整数，并且对于所有 $k$ 个临时变量都是相同的。\n- 除了这 $k$ 个临时变量外，没有其他架构寄存器被循环重新定义，并且你可以忽略所有其他形式的资源争用（例如，假设重排序缓冲区和调度器足够大，以至于只有物理寄存器空闲列表会导致重命名停顿）。\n\n仅使用上面提供的关于寄存器重命名、活跃性和顺序提交的定义，从第一性原理推导出保证循环在稳态下运行时重命名阶段永远不会因空闲列表为空而停顿所需的最小物理寄存器数量 $R_{phys}$。请用 $k$ 和 $D$ 的封闭形式表达式来表示你的答案。不要提供不等式。最终表达式不需要进行数值舍入，也不需要单位。", "solution": "该问题要求推导出保证处理器重命名阶段不会停顿所需的最小物理寄存器数量 $R_{phys}$。该系统的特点是一个循环在乱序执行核心上以稳态运行。\n\n解决此问题的基本原理是确定在此稳态期间同时处于使用状态（已分配但尚未释放）的物理寄存器总数。为防止停顿，物理寄存器堆必须足够大以容纳所有这些寄存器。这个数量可以通过计算一个物理寄存器的总生命周期并乘以寄存器的分配速率来求得。\n\n让我们首先确定分配速率。问题陈述如下：\n- 循环体有 $k$ 个不同的标量临时变量，每个都在每次迭代中被重新定义一次。\n- 循环以每 $1$ 个周期 $1$ 次迭代的持续启动间隔运行。\n这意味着每个周期都有一个新的迭代开始，重命名阶段必须为 $k$ 个被重新定义的架构寄存器中的每一个分配一个新的物理寄存器。\n因此，分配速率是每周期 $k$ 个物理寄存器。\n\n接下来，让我们确定一个物理寄存器的生命周期。生命周期从其在重命名阶段被分配开始，到其被释放（即返回到空闲列表）时结束。问题指明了释放规则：“先前映射到该架构寄存器名的物理寄存器只有在重新定义它的指令提交时才会被返回到空闲列表中。”\n\n考虑单个架构寄存器 $A$。让我们跟踪在连续迭代中映射到它的物理寄存器。\n- 在迭代 $i$ 中，假设重新定义 $A$ 的指令在周期 $t_i$ 被重命名。此时，一个新的物理寄存器（我们称之为 $P_i$）被分配给 $A$。\n- 在下一次迭代 $i+1$ 中，重新定义 $A$ 的指令被重命名。由于启动间隔为 $1$，这发生在周期 $t_{i+1} = t_i + 1$。一个新的物理寄存器 $P_{i+1}$被分配给 $A$。\n\n现在，我们来确定 $P_i$ 何时被释放。根据规则，$P_i$（“先前映射的物理寄存器”）在“重新定义指令”（来自迭代 $i+1$ 的那条）提交时被释放。\n问题陈述，从一条指令重命名到其提交的时间是一个恒定的 $D$ 个周期。来自迭代 $i+1$ 的指令在周期 $t_{i+1}$ 被重命名。因此，它在周期 $t_{commit} = t_{i+1} + D$ 提交。\n代入 $t_{i+1} = t_i + 1$：\n$$t_{commit} = (t_i + 1) + D = t_i + D + 1$$\n这就是物理寄存器 $P_i$ 被释放的周期。\n\n物理寄存器 $P_i$ 的生命周期是从它在周期 $t_i$ 被分配直到在周期 $t_i + D + 1$ 被释放的持续时间。它保持被占用的周期数为：\n$$\\text{Lifetime} = (t_i + D + 1) - t_i = D + 1 \\text{ cycles}$$\n\n我们现在已经确定了计算所需的两个必要组成部分：\n1. 从空闲列表中消耗物理寄存器的速率是每周期 $k$ 个寄存器。\n2. 每个物理寄存器保持被消耗状态的持续时间是 $D+1$ 个周期。\n\n在一个稳态系统中，被占用资源的总数是到达率和服务时间的乘积。这是Little's Law的一个应用。同时活跃的物理寄存器总数 $N_{live}$ 是：\n$$N_{live} = (\\text{registers allocated per cycle}) \\times (\\text{lifetime in cycles})$$\n$$N_{live} = k \\times (D+1)$$\n\n为了保证重命名阶段永远不会因为空闲列表为空而停顿，可用的物理寄存器总数 $R_{phys}$ 必须至少是这个数量。因此，所需的最小数量是：\n$$R_{phys} = k(D+1)$$\n\n另一种推导方法通过考虑机器状态的一个快照来证实这个结果。在任何时刻，物理寄存器堆必须保存最新提交的（架构）状态的值，加上所有在途的（推测性）状态的值。\n- 对于 $k$ 个循环临时变量，其提交状态需要 $k$ 个物理寄存器。\n- 一条指令从其重命名到提交期间都处于在途状态。从重命名到提交的时间是 $D$ 个周期。由于启动间隔为 $1$，总是有相当于 $D$ 个迭代的指令已经被重命名但尚未提交。例如，如果在周期 $t$ 重命名的指令在 $t+D$ 提交，那么在周期 $T$ 时，在周期 $T-1, T-2, \\ldots, T-D$ 重命名的所有指令都处于在途状态。\n- 这 $D$ 个在途的迭代每个都分配了 $k$ 个物理寄存器，总计为 $D \\times k$ 个推测性寄存器。\n被占用的寄存器总数是用于提交状态的寄存器和用于推测性状态的寄存器之和：\n$$R_{phys} = k_{\\text{committed}} + (D \\times k)_{\\text{speculative}} = k + kD = k(D+1)$$\n两种推导都得出结论，所需的最小物理寄存器数量是 $k(D+1)$。", "answer": "$$\\boxed{k(D+1)}$$", "id": "3662897"}, {"introduction": "激进的乱序处理器会推测性地在旧的存储指令之前执行加载指令，这带来了违反内存排序的风险。这个练习超越了确定性模拟，使用概率来为此类场景建模。通过分析“重放风暴”（replay storm）的风险，你将深入了解架构师如何量化推测执行的性能影响以及恢复机制的重要性。[@problem_id:3662876]", "problem": "一个超标量乱序核使用重排序缓冲（ROB）和加载-存储队列（LSQ）。该核采用内存依赖性预测器，允许较新的加载指令在所有较旧的存储指令解析其有效地址之前执行。考虑以下科学上真实的冒险场景。一个到地址 $A$ 的较旧存储指令由于地址生成延迟较长而导致其有效地址解析较晚。一个到相同地址 $A$ 的较新加载指令被推测性地发出，并从缓存中获取了一个值。当较旧的存储指令最终解析完成时，机器检测到内存顺序违规（加载指令在指向同一地址的较旧存储指令之前读取），撤销较新的加载指令及其所有相关指令，并将该加载指令标记为重放。由于预测器的行为，被重放的加载指令被允许在较旧存储指令的地址解析完成之前再次重新发出，这可能导致重复同样的违规。这可能导致一系列连锁的重执行，称为重放风暴。\n\n将此过程建模如下。在较旧存储指令的地址已知之前，每一次对较新加载指令的推测性执行尝试都是一次伯努利试验。在每次尝试中，有 $\\beta \\in (0,1)$ 的概率是违规的（因为它与一个尚未解析的较旧存储指令发生地址冲突，而该存储指令稍后被发现指向同一地址），有 $1-\\beta$ 的概率是非违规的（因为地址依赖不存在，或者因为较旧的存储指令已经解析完成，从而阻止了进一步的违规）。当一次尝试是违规的时，该加载指令被重放；尝试将持续进行，直到第一次非违规尝试发生。假设各次尝试之间相互独立。\n\n定义重放风暴风险 $\\mathcal{R}_{s}(\\beta)$ 为由该冒险事件引起的加载指令的额外执行次数的期望值，超出在完美排序情况下理想的单次执行（也就是说，只计算重放次数，不包括最终成功的执行）。从乱序推测、内存依赖冒险和伯努利试验的基本定义出发，推导 $\\mathcal{R}_{s}(\\beta)$ 作为 $\\beta$ 函数的闭式解析表达式。\n\n将您的最终答案表示为仅含 $\\beta$ 的简化闭式表达式。不需要单位。不需要数值舍入。", "solution": "问题陈述描述了一个超标量乱序处理器中内存顺序违规的场景，并将其建模为一个随机过程。验证证实了该问题在科学上基于计算机体系结构的原理，在数学上是适定的，并使用了客观、可形式化的语言。前提条件是一致且充分的，足以推导出唯一解。因此，我们可以进行推导。\n\n问题的核心在于对较新加载指令的重复执行尝试进行建模。每次尝试被描述为一次伯努利试验。我们来定义单次试验的结果：\n- “失败”对应于一次违规尝试，这会导致撤销和重放。此事件的概率为 $\\beta$。\n- “成功”对应于一次非违规尝试，这使得指令可以提交，过程终止。此事件的概率为 $1-\\beta$。\n\n这些尝试是独立的，并重复进行直到首次成功发生。这是一个遵循几何分布的过程的定义。设 $N$ 为实现首次成功所需的总尝试次数的随机变量。$N$ 的概率质量函数（PMF）由下式给出：\n$$\nP(N=n) = (\\beta)^{n-1}(1-\\beta), \\quad \\text{for } n = 1, 2, 3, \\dots\n$$\n其中 $n-1$ 是在第 $n$ 次试验时首次成功（非违规尝试）之前失败（违规尝试）的次数。该几何分布的参数是成功概率 $p = 1-\\beta$。\n\n成功概率为 $p$ 的几何分布随机变量 $N$ 的期望值是概率论中的一个标准结果：\n$$\nE[N] = \\frac{1}{p}\n$$\n在我们的情境中，当 $p = 1-\\beta$ 时，预期的总执行次数（包括违规和非违规的）是：\n$$\nE[N] = \\frac{1}{1-\\beta}\n$$\n\n问题要求的是重放风暴风险 $\\mathcal{R}_{s}(\\beta)$，它被定义为*额外*执行次数的期望值，即重放的次数。总执行次数 $N$ 由最终的成功执行和所有之前的失败执行（重放）组成。如果总执行次数为 $N$，那么重放次数为 $N-1$。\n\n因此，我们需要计算 $\\mathcal{R}_{s}(\\beta) = E[N-1]$。\n\n利用期望算子的线性性质，我们可以写出：\n$$\n\\mathcal{R}_{s}(\\beta) = E[N-1] = E[N] - E[1]\n$$\n常数的期望是其本身，所以 $E[1]=1$。代入 $E[N]$ 的表达式，我们得到：\n$$\n\\mathcal{R}_{s}(\\beta) = \\frac{1}{1-\\beta} - 1\n$$\n为了将其简化为单个闭式表达式，我们通分：\n$$\n\\mathcal{R}_{s}(\\beta) = \\frac{1}{1-\\beta} - \\frac{1-\\beta}{1-\\beta} = \\frac{1 - (1-\\beta)}{1-\\beta}\n$$\n简化分子可得：\n$$\n\\mathcal{R}_{s}(\\beta) = \\frac{1 - 1 + \\beta}{1-\\beta} = \\frac{\\beta}{1-\\beta}\n$$\n这就是作为违规概率 $\\beta$ 函数的重放次数期望值的闭式解析表达式。该推导從问题中指定的伯努利试验的基本定义开始，识别出由此产生的几何分布，并利用其性质来求得所需的期望值。", "answer": "$$\n\\boxed{\\frac{\\beta}{1 - \\beta}}\n$$", "id": "3662876"}]}