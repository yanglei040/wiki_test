{"hands_on_practices": [{"introduction": "本练习将有效地址计算的抽象概念置于一个实际的工程问题中。您将需要推导出访问一个特定内存地址所需的位移量，并由此计算出编码该位移量所需的最小位数。这个实践旨在揭示指令集的寻址范围与其指令编码大小之间的内在联系和设计权衡。", "problem": "在某个指令集架构（ISA）中，一条加载指令使用基址加变址带偏移量的寻址模式。根据定义，此模式产生的有效地址（EA）是两个通用寄存器的内容和一个符号扩展的立即数偏移量之整数和，即有效地址等于寄存器 $R1$ 中的值、寄存器 $R2$ 中的值以及一个立即数偏移量 $disp$ 的总和。该偏移量 $disp$ 以 $w$ 位的二进制补码形式编码，并在相加前符号扩展至机器字长。所有量都表示字节地址，并且仅在偏移量编码时被视为有符号整数。一个 $w$ 位有符号整数的二进制补码范围是 $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$。\n\n仅使用这些定义和事实，请依次解决以下问题：\n- 推导偏移量 $disp$ 必须满足的充分必要条件，以使该指令的有效地址等于给定的绝对目标地址 $C$。请完全用 $R1$、$R2$ 和 $C$ 来表示该条件，并且暂时不要假设任何特定的 $w$。\n- 将您的条件具体化，以符合 $w$ 位偏移量的二进制补码可表示性约束。\n- 现在用具体值 $R1 = 0x0000000010000100$、$R2 = 0x0000000000000200$ 和 $C = 0x0000000010008901$ 来实例化这些符号。确定最小的整数 $w$，使得该偏移量能够以二进制补码形式编码，并且该指令可以使用此寻址模式精确达到目标地址 $C$。\n\n您的最终答案必须是所需的最小整数位数 $w$。答案无需四舍五入，也无需单位。", "solution": "首先验证该问题，以确保其科学上成立、表述清晰且客观。\n\n### 步骤 1：提取已知条件\n- **寻址模式**：基址加变址带偏移量。\n- **有效地址（EA）公式**：有效地址 $EA$ 是寄存器 $R1$ 中的值、寄存器 $R2$ 中的值和一个符号扩展的立即数偏移量 $disp$ 的总和。$EA = R1 + R2 + disp$。\n- **偏移量编码**：$disp$ 被编码为一个 $w$ 位的二进制补码整数。在相加之前，它被符号扩展到机器字长。\n- **二进制补码范围**：一个 $w$ 位有符号整数的范围为 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$。\n- **目标地址**：一个给定的绝对目标地址 $C$。\n- **具体值**：\n  - $R1 = 0\\text{x}0000000010000100$\n  - $R2 = 0\\text{x}0000000000000200$\n  - $C = 0\\text{x}0000000010008901$\n- **目标**：求 $w$ 的最小整数值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题设定在计算机组成和体系结构的标准框架内。寻址模式、有效地址计算和二进制补码表示的定义都是标准的并且在事实上是正确的。该问题是自包含的，提供了得出唯一解所需的所有定义和数据。语言精确、客观。没有科学缺陷、歧义或矛盾。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n### 解答推导\n\n解答过程按照问题陈述中指定的三个任务顺序进行。\n\n**1. 推导偏移量 $disp$ 的充分必要条件。**\n\n有效地址（$EA$）定义为两个寄存器 $R1$ 和 $R2$ 的内容与一个立即数偏移量 $disp$ 的和。\n$$EA = R1 + R2 + disp$$\n问题要求有效地址等于一个特定的目标地址 $C$。\n$$EA = C$$\n将 $EA$ 的两个表达式相等，得到以下关系：\n$$C = R1 + R2 + disp$$\n为了找到关于 $disp$ 的充分必要条件，我们解此方程求 $disp$。这就得出了使指令能够达到目标地址 $C$ 所需的偏移量值。\n$$disp = C - (R1 + R2)$$\n这个方程就是完全用 $R1$、$R2$ 和 $C$ 表示的关于 $disp$ 的条件。\n\n**2. 将条件具体化为二进制补码的可表示性约束。**\n\n偏移量 $disp$ 必须能表示为一个 $w$ 位的二进制补码整数。问题给出了这样一个整数的有效范围为：\n$$-2^{w-1} \\le disp \\le 2^{w-1} - 1$$\n将第一部分得到的 $disp$ 的表达式代入，我们得到包含可表示性约束的具体条件：\n$$-2^{w-1} \\le C - (R1 + R2) \\le 2^{w-1} - 1$$\n要使偏移量能用 $w$ 位编码，就必须满足这个不等式。\n\n**3. 根据给定的具体值确定最小整数 $w$。**\n\n首先，我们使用提供的 $R1$、$R2$ 和 $C$ 的十六进制值计算偏移量 $disp$ 所需的数值。在算术运算中，地址被当作无符号整数处理。\n$$R1 = 0\\text{x}10000100$$\n$$R2 = 0\\text{x}00000200$$\n$$C = 0\\text{x}10008901$$\n我们首先计算寄存器内容的总和：\n$$R1 + R2 = 0\\text{x}10000100 + 0\\text{x}00000200 = 0\\text{x}10000300$$\n接下来，我们计算偏移量 $disp$：\n$$disp = C - (R1 + R2) = 0\\text{x}10008901 - 0\\text{x}10000300 = 0\\text{x}8601$$\n为了找到最小位数 $w$，我们将十六进制偏移量 $0\\text{x}8601$ 转换为其十进制等价值：\n$$disp = 8 \\times 16^3 + 6 \\times 16^2 + 0 \\times 16^1 + 1 \\times 16^0$$\n$$disp = 8 \\times 4096 + 6 \\times 256 + 0 + 1$$\n$$disp = 32768 + 1536 + 1 = 34305$$\n现在我们必须找到最小的整数 $w$，使得 $disp = 34305$ 满足二进制补码的范围条件：\n$$-2^{w-1} \\le 34305 \\le 2^{w-1} - 1$$\n由于 $disp$ 是一个正数，左侧不等式 $-2^{w-1} \\le 34305$ 对于任何 $w \\ge 2$ 都成立。决定性的约束是右侧的不等式：\n$$34305 \\le 2^{w-1} - 1$$\n整理不等式得到：\n$$34306 \\le 2^{w-1}$$\n为了找到满足此条件的最小整数 $w$，我们可以考察 $2$ 的幂：\n$$2^{14} = 16384$$\n$$2^{15} = 32768$$\n$$2^{16} = 65536$$\n我们需要 $2^{w-1}$ 大于或等于 $34306$。从上面的值可以看出，$2^{15}$ 太小，但 $2^{16}$ 足够。因此，指数 $w-1$ 的最小整数值必须是 $16$。\n$$w-1 \\ge 16$$\n这意味着 $w$ 的最小整数值为：\n$$w = 16 + 1 = 17$$\n为了验证，当 $w=17$ 时，范围是 $[-2^{16}, 2^{16}-1]$，即 $[-65536, 65535]$。值 $34305$ 在此范围内。当 $w=16$ 时，范围是 $[-2^{15}, 2^{15}-1]$，即 $[-32768, 32767]$。值 $34305$ 在此范围之外。因此，所需的最小整数位数为 $17$。", "answer": "$$\\boxed{17}$$", "id": "3618990"}, {"introduction": "寻址模式并非孤立的理论，而是底层算法高效实现的核心工具。本练习将引导您模拟使用自增寻址模式，分别通过字节和字访问来扫描一个字符串。通过追踪寄存器和内存地址的变化，您将深入理解该模式如何简化循环，以及不同的数据访问粒度如何从根本上影响程序的执行路径和效率。", "problem": "一个指令集架构 (ISA) 提供了一种自增寻址模式，表示为将基址寄存器放在括号内，后跟一个加号，以及一个指示操作数大小的尺寸后缀。有效地址 (EA) 定义为用于访问操作数内存的值；在自增模式下，访问位于 $EA$ 的内存操作数，然后基址寄存器按操作数大小（以字节为单位）递增。该机器是字节可寻址的，并使用一个 $4$ 字节的字。带尺寸后缀的操作应用于指定大小寄存器的低位部分。假设多字节加载使用小端表示法，以便在从地址 $A$ 加载一个字时，地址 $A$ 处的字节映射到目标寄存器的低位字节。\n\n考虑一个从地址 $B = 0x4000$ 开始的空字符终止的字符串。在地址 $B$ 及之后的内存内容如下：\n- 地址 $0x4000$：字节 $0x41$ (ASCII ‘A’)\n- 地址 $0x4001$：字节 $0x42$ (ASCII ‘B’)\n- 地址 $0x4002$：字节 $0x43$ (ASCII ‘C’)\n- 地址 $0x4003$：字节 $0x00$ (空终止符)\n- 地址 $0x4004$：字节 $0x5E$\n- 地址 $0x4005$：字节 $0x99$\n- 地址 $0x4006$：字节 $0x77$\n- 地址 $0x4007$：字节 $0x88$\n- 地址 $0x4008$：字节 $0x00$\n- 地址 $0x4009$：字节 $0x11$\n\n两个循环尝试扫描直到找到空终止符。基址寄存器 $R_0$ 初始化为 $B$。这两个循环是：\n\n- 字节循环 $S_b$：\n  - 循环体：LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #$0$; BNE back_to_loop\n  - 语义：LD.B 使用 $EA = R_0$，加载一个字节，然后更新 $R_0 \\leftarrow R_0 + 1$。\n\n- 字循环 $S_w$：\n  - 循环体：LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #$0$; BNE back_to_loop\n  - 语义：LD.W 使用 $EA = R_0$，将四个字节加载到 $R_2$ 中，其中 $EA$ 处的字节位于 $R_2$ 的低位字节，然后更新 $R_0 \\leftarrow R_0 + 4$。CMP.B 仅将 $R_2$ 的低位字节与 $0$ 进行比较。\n\n对于这些特定的内存内容和初始 $R_0 = 0x4000$ 的值，哪个选项正确描述了每个循环直到退出所使用的 $EA$ 值序列以及退出时 $R_0$ 的最终值？\n\nA. $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4004$。$S_w$：$EA$ 序列 $0x4000, 0x4004, 0x4008$；最终 $R_0 = 0x400C$。\n\nB. $S_b$：$EA$ 序列 $0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4003$。$S_w$：$EA$ 序列 $0x4004, 0x4008$；最终 $R_0 = 0x4008$。\n\nC. $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4004$。$S_w$：$EA$ 序列 $0x4000, 0x4002, 0x4004$；最终 $R_0 = 0x4006$。\n\nD. $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002$；最终 $R_0 = 0x4003$。$S_w$：$EA$ 序列 $0x4000$；最终 $R_0 = 0x4004$，因为字中任何零字节的存在都会导致立即退出。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于计算机组成和体系结构的原理，问题提出得很好，具有唯一且可确定的解，并以客观、明确的语言表达。所有必要的信息，包括初始内存状态、寄存器值和精确的指令语义，都已提供。该问题是在一个假设但现实的处理器架构上跟踪程序执行的标准练习。\n\n我们将通过模拟每个循环的执行来继续，在每一步跟踪相关的寄存器值和内存访问。\n\n### 字节循环 ($S_b$) 的分析\n\n字节循环的循环体是：`LD.B ($R_0$)+, $R_1$; CMP.B $R_1$, #0; BNE back_to_loop`。初始状态为 $R_0 = 0x4000$。\n\n- **第 1 次迭代：**\n  - `LD.B ($R_0$)+, $R_1$`：有效地址 ($EA$) 是 $R_0$ 的当前值，即 $0x4000$。从内存地址 $0x4000$ 加载一个字节。其值为 $0x41$ (ASCII 'A')。这个值被放置在 $R_1$ 的低位字节中。加载后，$R_0$ 按操作数大小（1 字节）递增。\n    - $EA_1 = 0x4000$\n    - $R_1 \\leftarrow 0x...0041$\n    - $R_0 \\leftarrow 0x4000 + 1 = 0x4001$\n  - `CMP.B $R_1$, #0`：$R_1$ 的低位字节 ($0x41$) 与 $0$ 比较。它们不相等。\n  - `BNE back_to_loop`：条件（不相等）为真，因此执行分支。\n\n- **第 2 次迭代：**\n  - `LD.B ($R_0$)+, $R_1$`：$EA$ 是 $R_0$ 的当前值 $0x4001$。地址 $0x4001$ 处的字节 $0x42$ 被加载到 $R_1$ 中。$R_0$ 递增。\n    - $EA_2 = 0x4001$\n    - $R_1 \\leftarrow 0x...0042$\n    - $R_0 \\leftarrow 0x4001 + 1 = 0x4002$\n  - `CMP.B $R_1$, #0`：将 $0x42$ 与 $0$ 比较。它们不相等。\n  - `BNE back_to_loop`：执行分支。\n\n- **第 3 次迭代：**\n  - `LD.B ($R_0$)+, $R_1$`：$EA$ 是 $0x4002$。地址 $0x4002$ 处的字节 $0x43$ 被加载到 $R_1$ 中。$R_0$ 递增。\n    - $EA_3 = 0x4002$\n    - $R_1 \\leftarrow 0x...0043$\n    - $R_0 \\leftarrow 0x4002 + 1 = 0x4003$\n  - `CMP.B $R_1$, #0`：将 $0x43$ 与 $0$ 比较。它们不相等。\n  - `BNE back_to_loop`：执行分支。\n\n- **第 4 次迭代：**\n  - `LD.B ($R_0$)+, $R_1$`：$EA$ 是 $0x4003$。地址 $0x4003$ 处的字节，即空终止符 $0x00$，被加载到 $R_1$ 中。$R_0$ 递增。\n    - $EA_4 = 0x4003$\n    - $R_1 \\leftarrow 0x...0000$\n    - $R_0 \\leftarrow 0x4003 + 1 = 0x4004$\n  - `CMP.B $R_1$, #0`：将 $0x00$ 与 $0$ 比较。它们相等。\n  - `BNE back_to_loop`：条件（不相等）为假，因此不执行分支。循环终止。\n\n**$S_b$ 的总结：**\n- 使用的有效地址序列是：$0x4000, 0x4001, 0x4002, 0x4003$。\n- 循环退出时 $R_0$ 的最终值是 $0x4004$。\n\n### 字循环 ($S_w$) 的分析\n\n字循环的循环体是：`LD.W ($R_0$)+, $R_2$; CMP.B $R_2$, #0; BNE back_to_loop`。字大小为 $4$ 字节。初始状态为 $R_0 = 0x4000$。\n\n- **第 1 次迭代：**\n  - `LD.W ($R_0$)+, $R_2$`：$EA$ 是 $0x4000$。从地址 $0x4000$ 开始从内存中加载一个 $4$ 字节的字。地址 $0x4000, 0x4001, 0x4002, 0x4003$ 处的字节分别是 $0x41, 0x42, 0x43, 0x00$。由于是小端表示法，最低地址 ($0x4000$) 处的字节映射到寄存器的低位字节。因此，加载到 $R_2$ 中的 $4$ 字节字是 $0x00434241$。加载后，$R_0$ 按字大小（4 字节）递增。\n    - $EA_1 = 0x4000$\n    - $R_2 \\leftarrow 0x00434241$\n    - $R_0 \\leftarrow 0x4000 + 4 = 0x4004$\n  - `CMP.B $R_2$, #0`：这仅将 $R_2$ 的低位字节与 $0$ 比较。$R_2$ 的低位字节是 $0x41$。这不等于 $0$。\n  - `BNE back_to_loop`：条件为真，因此执行分支。\n\n- **第 2 次迭代：**\n  - `LD.W ($R_0$)+, $R_2$`：$EA$ 是 $0x4004$。从地址 $0x4004$ 开始从内存中加载一个 $4$ 字节的字。地址 $0x4004, 0x4005, 0x4006, 0x4007$ 处的字节是 $0x5E, 0x99, 0x77, 0x88$。加载到 $R_2$ 中的 $4$ 字节字（小端）是 $0x8877995E$。$R_0$ 递增。\n    - $EA_2 = 0x4004$\n    - $R_2 \\leftarrow 0x8877995E$\n    - $R_0 \\leftarrow 0x4004 + 4 = 0x4008$\n  - `CMP.B $R_2$, #0`：$R_2$ 的低位字节 $0x5E$ 与 $0$ 比较。它们不相等。\n  - `BNE back_to_loop`：执行分支。\n\n- **第 3 次迭代：**\n  - `LD.W ($R_0$)+, $R_2$`：$EA$ 是 $0x4008$。从地址 $0x4008$ 开始从内存中加载一个 $4$ 字节的字。地址 $0x4008, 0x4009, ...$ 处的字节是 $0x00, 0x11, ...$。地址 $0x4008$ 处的字节是 $0x00$，成为 $R_2$ 的低位字节。完整的字是 $0x...1100$。$R_0$ 递增。\n    - $EA_3 = 0x4008$\n    - $R_2 \\leftarrow$ 一个低位字节为 $0x00$ 的值。\n    - $R_0 \\leftarrow 0x4008 + 4 = 0x400C$\n  - `CMP.B $R_2$, #0`：$R_2$ 的低位字节 $0x00$ 与 $0$ 比较。它们相等。\n  - `BNE back_to_loop`：条件为假，因此不执行分支。循环终止。\n\n**$S_w$ 的总结：**\n- 使用的有效地址序列是：$0x4000, 0x4004, 0x4008$。\n- 循环退出时 $R_0$ 的最终值是 $0x400C$。\n\n### 选项评估\n\n- **选项 A：** $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4004$。$S_w$：$EA$ 序列 $0x4000, 0x4004, 0x4008$；最终 $R_0 = 0x400C$。\n  - 此选项与我们为 $S_b$ 和 $S_w$ 推导出的结果相符。\n  - **结论：正确**\n\n- **选项 B：** $S_b$：$EA$ 序列 $0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4003$。$S_w$：$EA$ 序列 $0x4004, 0x4008$；最终 $R_0 = 0x4008$。\n  - 对于 $S_b$，$EA$ 序列不正确；它必须从 $R_0$ 的初始值 $0x4000$ 开始。最终的 $R_0$ 值不正确；它应该是 $0x4004$。\n  - 对于 $S_w$，$EA$ 序列同样不正确，缺少了在 $0x4000$ 的初始访问。最终的 $R_0$ 值不正确；它应该是 $0x400C$。\n  - **结论：不正确**\n\n- **选项 C：** $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002, 0x4003$；最终 $R_0 = 0x4004$。$S_w$：$EA$ 序列 $0x4000, 0x4002, 0x4004$；最终 $R_0 = 0x4006$。\n  - 对 $S_b$ 的描述是正确的。\n  - 对于 $S_w$，$EA$ 序列不正确。自增量是操作数大小（字，4 字节），所以地址应该按 $4$ 递增（$0x4000, 0x4004, ...$），而不是按 $2$。因此最终的 $R_0$ 值也不正确。\n  - **结论：不正确**\n\n- **选项 D：** $S_b$：$EA$ 序列 $0x4000, 0x4001, 0x4002$；最终 $R_0 = 0x4003$。$S_w$：$EA$ 序列 $0x4000$；最终 $R_0 = 0x4004$，因为字中任何零字节的存在都会导致立即退出。\n  - 对于 $S_b$，$EA$ 序列不完整；它未包含在 $0x4003$ 处找到空终止符的访问。最终的 $R_0$ 值不正确，因为没有计入最后的增量。\n  - 对于 $S_w$，其推理是有缺陷的。问题明确指出 `CMP.B` *仅*比较 $R_2$ 的低位字节。加载的第一个字 ($0x00434241$) 包含一个零字节，但其低位字节是 $0x41$。因此，循环在第一次迭代后不会退出。\n  - **结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3619064"}, {"introduction": "对计算机体系结构的深刻理解，往往源于对错误的分析。本题探讨一个常见但极其微妙的实现缺陷：将一个有符号位移错误地进行零扩展而非符号扩展。通过精确分析这种错误导致特定偏差的条件，您将巩固对二进制补码运算的理解，并体会到正确的数据表示在硬件设计中的关键作用。", "problem": "一个处理器对内存操作数使用基址加偏移量寻址模式。在此模式下，有效地址（EA）计算为 $EA = R5 + \\text{disp}$，其中 $R5$ 是一个通用基址寄存器，而 $\\text{disp}$ 是包含在指令编码中的一个立即数偏移字段。该体系结构规定，$\\text{disp}$ 是一个k位二进制补码值，在与 $R5$ 相加之前，必须将其符号扩展到机器字长。假设机器字长为32位，且内存为字节可寻址。一个有错误的实现错误地将 $\\text{disp}$ 零扩展到32位，而不是进行符号扩展。\n\n从基址加偏移量寻址和二进制补码符号扩展的核心定义出发，分析此错误的影响。特别地，确定在哪种情况下，不正确的零扩展会导致计算出的EA与正确的EA相差恰好 $2^k$ 字节。对于每个选项，将 $\\texttt{0x...}$ 视为k位偏移字段的字面位模式，并假设算术运算像往常一样对32位地址在模 $2^{32}$ 下进行。\n\n选择所有导致产生偏差为 $2^k$ 的错误的选项（即，不正确的EA等于正确的EA加上 $2^k$）。\n\nA. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x800}$\n\nB. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x7FF}$\n\nC. $k = 12$, $R5 = \\texttt{0x2000}$, $\\text{disp} = \\texttt{0xF20}$\n\nD. $k = 10$, $R5 = \\texttt{0xFF00}$, $\\text{disp} = \\texttt{0x120}$\n\nE. $k = 16$, $R5 = \\texttt{0x0000}$, $\\text{disp} = \\texttt{0x8000}$", "solution": "该问题陈述经证实具有科学依据、提法恰当且客观。它基于计算机体系结构的标准原理，包括寻址模式和二进制补码算术。其设定是自洽且无矛盾的，允许进行严格的形式化分析。\n\n问题的核心在于对一个k位二进制补码偏移量 $\\text{disp}$ 进行正确的符号扩展与不正确的零扩展之间的差异。我们需要找出在何种情况下，此错误会导致计算出的有效地址（EA）恰好偏离 $2^k$。\n\n令 $\\text{disp}_k$ 表示k位偏移字段。令其无符号整数值为 $D_k$。机器字长为32位。\n\n正确的有效地址 $EA_{\\text{correct}}$ 是通过将 $\\text{disp}_k$ 符号扩展到32位，然后将其加到基址寄存器 $R5$ 上计算得出的。\n$EA_{\\text{correct}} = R5 + \\text{sign_extend}(\\text{disp}_k)$\n\n有错误的有效地址 $EA_{\\text{buggy}}$ 是通过将 $\\text{disp}_k$ 零扩展到32位计算得出的。\n$EA_{\\text{buggy}} = R5 + \\text{zero_extend}(\\text{disp}_k)$\n\n让我们分析两种情况下扩展后偏移量的值。\n通过对 $\\text{disp}_k$ 进行零扩展得到的32位数字的值就是其无符号值 $D_k$。\n$\\text{zero_extend}(\\text{disp}_k)$ 的值 $= D_k$。\n\n通过对 $\\text{disp}_k$ 进行符号扩展得到的32位数字的值取决于其最高有效位（MSB），即第 $k-1$ 位。\n情况1：$\\text{disp}_k$ 的MSB为 $0$。这表示一个非负数。\n符号扩展用 $0$ 填充高位的 $32-k$ 位。这与零扩展相同。\n$\\text{sign_extend}(\\text{disp}_k)$ 的值 $= D_k$。\n\n情况2：$\\text{disp}_k$ 的MSB为 $1$。这在二进制补码表示法中表示一个负数。\n一个MSB被置为1的k位二进制补码数的值是 $D_k - 2^k$。符号扩展必须保持该值不变。\n为了进行符号扩展，高位的 $32-k$ 位被填充为 $1$。得到的32位模式的无符号值为 $D_k + \\sum_{i=k}^{31} 2^i = D_k + (2^{32}-2^k)$。\n作为一个32位二进制补码数，其值为 $(D_k + 2^{32}-2^k) - 2^{32} = D_k - 2^k$。\n所以，$\\text{sign_extend}(\\text{disp}_k)$ 的值 $= D_k - 2^k$。\n\n我们需要找出不正确的EA等于正确的EA加上 $2^k$ 的情况。\n$EA_{\\text{buggy}} = EA_{\\text{correct}} + 2^k$\n$(R5 + \\text{Value}(\\text{zero_extend}(\\text{disp}_k))) = (R5 + \\text{Value}(\\text{sign_extend}(\\text{disp}_k))) + 2^k$\n\n从两边减去 $R5$，条件简化为：\n$\\text{Value}(\\text{zero_extend}(\\text{disp}_k)) = \\text{Value}(\\text{sign_extend}(\\text{disp}_k)) + 2^k$\n\n让我们针对两种情况检查此条件：\n情况1（$\\text{disp}_k$的MSB为 $0$）：\n$D_k = D_k + 2^k$，简化为 $0 = 2^k$。对于任何 $k  0$ 这都是错误的。\n\n情况2（$\\text{disp}_k$的MSB为 $1$）：\n$D_k = (D_k - 2^k) + 2^k$，简化为 $D_k = D_k$。这永远成立。\n\n因此，当且仅当k位偏移字段 $\\text{disp}_k$ 的最高有效位为 $1$ 时，该错误才会导致一个 $2^k$ 的偏差。基址寄存器 $R5$ 的值与此条件无关。我们现在基于此原则分析每个选项。\n\n**A. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x800}$**\n位移是一个 $k=12$ 位的字段。值为 $\\text{disp} = \\texttt{0x800}$。\n在二进制中，$\\texttt{0x800}$ 是 $1000\\ 0000\\ 0000_2$。\n这是一个12位的模式。最高有效位（第11位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n验证如下：\n- 正确的值（符号扩展）：$\\text{disp}$ 在一个12位字段中表示值 $2^{11}$，这被解释为 $2^{11} - 2^{12} = 2048 - 4096 = -2048$。\n- 错误的值（零扩展）：$\\text{disp}$ 被解释为无符号值 $2048$。\n- 差值：$2048 - (-2048) = 4096$。\n- 这个差值等于 $2^k = 2^{12} = 4096$。\n结论：**正确**。\n\n**B. $k = 12$, $R5 = \\texttt{0x1000}$, $\\text{disp} = \\texttt{0x7FF}$**\n位移是一个 $k=12$ 位的字段。值为 $\\text{disp} = \\texttt{0x7FF}$。\n在二进制中，$\\texttt{0x7FF}$ 是 $0111\\ 1111\\ 1111_2$。\n这是一个12位的模式。最高有效位（第11位）是 $0$。\n根据我们的推导，该错误将导致差值为 $0$，而不是 $2^{12}$。符号扩展和零扩展产生相同的结果。\n结论：**不正确**。\n\n**C. $k = 12$, $R5 = \\texttt{0x2000}$, $\\text{disp} = \\texttt{0xF20}$**\n位移是一个 $k=12$ 位的字段。值为 $\\text{disp} = \\texttt{0xF20}$。\n在二进制中，$\\texttt{0xF20}$ 是 $1111\\ 0010\\ 0000_2$。\n这是一个12位的模式。最高有效位（第11位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n验证如下：\n- 无符号值 $D_{12} = \\texttt{0xF20} = 3872$。\n- 正确的值（符号扩展）：$3872 - 2^{12} = 3872 - 4096 = -224$。\n- 错误的值（零扩展）：$3872$。\n- 差值：$3872 - (-224) = 4096$。\n- 这个差值等于 $2^k = 2^{12} = 4096$。\n结论：**正确**。\n\n**D. $k = 10$, $R5 = \\texttt{0xFF00}$, $\\text{disp} = \\texttt{0x120}$**\n位移是一个 $k=10$ 位的字段。问题陈述要求将 $\\texttt{0x120}$ 视为“k位偏移字段的字面位模式”。\n十六进制字面量 $\\texttt{0x120}$ 对应于12位模式 $0001\\ 0010\\ 0000_2$。\n一个10位的字段无法容纳一个12位的字面模式。这个选项的前提是矛盾的，描述了一个不可能的场景。由于这种情况不可能存在，所以它不可能是该错误产生指定偏差的一个实例。\n结论：**不正确**。\n\n**E. $k = 16$, $R5 = \\texttt{0x0000}$, $\\text{disp} = \\texttt{0x8000}$**\n位移是一个 $k=16$ 位的字段。值为 $\\text{disp} = \\texttt{0x8000}$。\n在二进制中，$\\texttt{0x8000}$ 是 $1000\\ 0000\\ 0000\\ 0000_2$。\n这是一个16位的模式。最高有效位（第15位）是 $1$。\n根据我们的推导，这种情况将产生指定的错误。\n验证如下：\n- 无符号值 $D_{16} = \\texttt{0x8000} = 32768$。\n- 正确的值（符号扩展）：$32768 - 2^{16} = 32768 - 65536 = -32768$。\n- 错误的值（零扩展）：$32768$。\n- 差值：$32768 - (-32768) = 65536$。\n- 这个差值等于 $2^k = 2^{16} = 65536$。\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3618965"}]}