{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能巩固。本节练习将指导您完成一次精确的栈帧布局计算。理解编译器如何根据应用程序二进制接口（ABI）将高级语言中的函数转换为具体的内存布局，是进行底层调试、性能分析和安全漏洞利用与防范的关键。此练习将带您体验根据System V AMD64 ABI的规则，一丝不苟地计算每个字节的过程。[@problem_id:3680344]", "problem": "在用于 Advanced Micro Devices 64位架构 (AMD64) 的 System V 应用程序二进制接口 (SysV ABI) 中，一个函数通过寄存器接收其前六个整数参数，任何额外的整数参数则通过栈接收。栈向低地址方向增长。调用者执行一个 `call` 指令，该指令会推入返回地址；被调用者执行一个标准序言，该序言会推入基指针 ($\\mathrm{RBP}$)，将 $\\mathrm{RBP}$ 设置为栈指针 ($\\mathrm{RSP}$)，然后为局部存储减去一个连续的块。在此环境中，对齐不变量要求在任何 `call` 指令之前，$\\mathrm{RSP}$ 必须对齐到 $16$字节边界。这里描述的函数是非可变参数函数，使用帧指针，调用另一个函数（因此不能依赖红色区域），并且除了 $\\mathrm{RBP}$ 之外不推入任何被调用者保存的寄存器。\n\n给定该函数恰好有 $7$ 个整数参数和三个局部变量，其大小和对齐要求如下：\n- 局部变量 $L_{1}$ 大小为 $8$ 字节，要求 $8$字节对齐。\n- 局部变量 $L_{2}$ 大小为 $16$ 字节，要求 $16$字节对齐。\n- 局部变量 $L_{3}$ 大小为 $24$ 字节，要求 $8$字节对齐。\n\n假设局部变量按源顺序 $L_{1}$、然后 $L_{2}$、然后 $L_{3}$ 分配，从高地址到低地址连续布局，仅插入满足每个局部变量相对于 $\\mathrm{RBP}$ 的对齐要求所需的最小填充。将每个局部变量的“基地址”定义为其存储空间的最低地址字节，并定义所有字节偏移量都相对于 $\\mathrm{RBP}$。\n\n从上述基本事实（栈向下增长、`call` 指令推入返回地址、函数序言推入并设置 $\\mathrm{RBP}$、SysV ABI 寄存器/栈参数规则，以及在调用点 $\\mathrm{RSP}$ 的 $16$字节对齐要求）出发，通过以下步骤重建确切的栈帧布局：\n1. 确定 $L_{1}$、$L_{2}$ 和 $L_{3}$ 的基偏移量（相对于 $\\mathrm{RBP}$），满足它们的对齐要求且不重叠。\n2. 确定第七个整数参数的偏移量（相对于 $\\mathrm{RBP}$）。\n3. 确定必须添加到局部区域的额外填充字节的最小数量（除了局部变量本身所需的空间之外），以确保从此函数发出的任何调用之前，$\\mathrm{RSP}$ 都对齐到 $16$字节边界。\n\n将您的最终答案表示为一个行矩阵，顺序为 $\\left(L_{1}, L_{2}, L_{3}, \\text{arg}_{7}, \\text{padding}\\right)$，其中每个条目是所需的偏移量或填充量（以字节为单位）。无需四舍五入。", "solution": "用户希望确定在 System V AMD64 ABI 下编译的函数的栈帧布局。\n\n### 步骤 1：问题验证\n\n**1.1. 提取给定信息**\n- **架构/ABI：** 用于 AMD64 的 System V 应用程序二进制接口 (SysV ABI)。\n- **参数传递：** 前六个整数参数在寄存器中；额外的整数参数在栈上。\n- **栈增长：** 朝向更低的内存地址。\n- **`call` 指令：** 推入 8 字节的返回地址。\n- **函数序言：** 标准序言：`push RBP`, `mov RBP, RSP`, `sub RSP, N`。\n- **栈对齐：** 在任何 `call` 指令之前，`RSP` 必须对齐到 $16$字节边界。\n- **函数属性：** 非可变参数，使用帧指针 (`RBP`)，调用其他函数（非叶函数），不使用红色区域，除了 `RBP` 外不推入任何被调用者保存的寄存器。\n- **函数签名：** 恰好 $7$ 个整数参数。\n- **局部变量：**\n    - $L_{1}$：大小 $8$ 字节，对齐 $8$ 字节。\n    - $L_{2}$：大小 $16$ 字节，对齐 $16$ 字节。\n    - $L_{3}$：大小 $24$ 字节，对齐 $8$ 字节。\n- **局部变量布局：** 按源顺序（$L_{1}$、$L_{2}$、$L_{3}$）从高地址到低地址连续分配，使用最小填充以满足相对于 `RBP` 的对齐。\n- **定义：** “基地址”是局部变量存储的最低地址字节。偏移量相对于 `RBP`。\n\n**1.2. 使用提取的给定信息进行验证**\n根据验证标准评估问题陈述。\n- **科学依据：** 问题基于真实世界中明确定义的 System V AMD64 ABI。所有陈述的行为（栈增长、`call` 指令、函数序言、寄存器/栈参数传递、对齐规则）都是对该标准的事实正确描述。这是计算机组织和编译器设计中的一个典型问题。**（有效）**\n- **问题明确：** 问题提供了一套完整的约束条件（参数数量、局部变量属性、ABI 规则），并要求具体、可量化的结果（偏移量和填充）。这些约束足以确定唯一的解决方案。**（有效）**\n- **客观性：** 问题以精确、技术性的语言陈述，没有歧义、主观性或观点。**（有效）**\n- **完整性和一致性：** 给定信息自洽且足以求解。没有矛盾。**（有效）**\n- **现实性：** 该场景是理解编译器如何生成代码和管理栈的标准练习，这是计算机科学的一个基础课题。**（有效）**\n\n**1.3. 结论与行动**\n问题有效。将提供详细的解决方案。\n\n### 步骤 2：详细解决方案\n\n解决方案是通过根据 System V AMD64 ABI 的规则重建栈帧布局来得出的。所有偏移量都相对于函数序言执行后的基指针 `RBP`。\n\n**2.1. 确定 RBP 的对齐**\n首先，我们确定基指针 `RBP` 的对齐方式。\n1.  ABI 规定，在 `call` 指令之前，栈指针 `RSP` 必须对齐到 $16$字节边界。设调用者在调用我们函数之前的 `RSP` 为 $S_{caller}$，其中 $S_{caller} \\pmod{16} = 0$。\n2.  `call` 指令将 8 字节的返回地址推入栈中。因此，在进入我们的函数时，`RSP` 位于地址 $S_{caller} - 8$。入口处的 `RSP` 值为 $16k - 8$（对于某个整数 $k$），这意味着 $RSP \\pmod{16} = 8$。这与 ABI 的要求一致，即在函数入口处 `(RSP + 8)` 是 $16$ 的倍数。\n3.  被调用者序言的第一条指令是 `push RBP`。这将旧的 `RBP` 的 8 字节值推入栈，并使 `RSP` 减 8。现在 `RSP` 位于 $(S_{caller} - 8) - 8 = S_{caller} - 16$。该地址是 $16$ 的倍数。\n4.  下一条指令是 `mov RBP, RSP`。这将新帧的基指针 `RBP` 设置为 `RSP` 的当前值。\n因此，在我们函数的执行期间，`RBP` 的值是对齐到 $16$字节边界的。这是确定局部变量偏移量的关键事实。\n\n**2.2. 确定第七个参数 (`arg_7`) 的偏移量**\n参数位于相对于 `RBP` 的正偏移量处。\n-   `[RBP + 0]`：此位置存储来自调用者帧的已保存 `RBP`（由我们的序言推入）。\n-   `[RBP + 8]`：此位置存储返回地址（由 `call` 指令推入）。\n-   前六个整数参数通过寄存器传递。第七个参数 `arg_7` 是第一个通过栈传递的。调用者在 `call` 之前将其放置在栈上。它位于返回地址的正上方。\n-   因此，第七个参数位于 `[RBP + 16]`。\n`arg_7` 相对于 `RBP` 的偏移量是 $+16$ 字节。\n\n**2.3. 确定局部变量 ($L_1, L_2, L_3$) 的偏移量**\n局部变量存储在相对于 `RBP` 的负偏移量处。它们从高地址（更接近 `RBP`）向低地址布局。问题指定了满足对齐约束的最小填充。我们已经确定 `RBP` 是 $16$字节对齐的。位于 `RBP` 偏移量 `off` 处的对象地址为 `RBP + off`。要使此地址具有 `A` 的对齐方式，需要 `(RBP + off) \\pmod A = 0`。由于 `RBP` 是任何所需对齐（$8$ 或 $16$）的倍数，这简化为 `off \\pmod A = 0`。\n\n-   **$L_{1}$ 的布局（大小 $8$，对齐 $8$）：**\n    $L_1$ 是第一个局部变量，因此它被放置在最接近 `RBP` 的位置。我们需要为这个 8 字节对象找到一个基偏移量 $off_1  \\le -8$。为了尽可能靠近 `RBP`，我们将其基地址放在 `RBP-8`。偏移量为 $off_1 = -8$。这满足对齐要求，因为 $-8 \\pmod 8 = 0$。\n    -   $L_{1}$ 占据内存范围 `[RBP - 8, RBP - 1]`。\n    -   $L_1$ 的基偏移量是 $-8$。\n\n-   **$L_{2}$ 的布局（大小 $16$，对齐 $16$）：**\n    $L_2$ 必须紧接着 $L_1$ 下方连续放置。$L_1$ 使用的最高地址是 `RBP - 1`，因此下一个可用地址是 `RBP - 9`。$L_2$ 是一个 16 字节的对象，其内存块的最高地址是 `base + 15`。这个地址必须小于或等于 `RBP - 9`。\n    用偏移量来说，设基偏移量为 $off_2$。该块为 `[RBP + off_2, RBP + off_2 + 15]`。\n    我们必须有 $off_2 + 15 \\le -9$，这意味着 $off_2 \\le -24$。\n    此外，基偏移量必须是 $16$字节对齐的：$off_2 \\pmod{16} = 0$。\n    我们需要找到小于或等于 $-24$ 且是 $16$ 的倍数的最大整数偏移量（最接近 $0$）。这个值是 $-32$。\n    -   $L_{2}$ 占据内存范围 `[RBP - 32, RBP - 17]`。\n    -   $L_2$ 的基偏移量是 $-32$。\n    -   注意：这在 `RBP - 16` 和 `RBP - 9` 之间创建了一个 8 字节的填充区域。\n\n-   **$L_{3}$ 的布局（大小 $24$，对齐 $8$）：**\n    $L_3$ 放置在 $L_2$ 的下方。$L_2$ 占据的内存范围是 `[RBP - 32, RBP - 17]`。因此，下一个可用的地址（向低地址方向）是 `RBP - 33`。\n    设 $L_3$ 的基偏移量为 $off_3$。该 24 字节块的最高地址是 `RBP + off_3 + 23`。\n    我们必须有 $off_3 + 23 \\le -33$，这意味着 $off_3 \\le -56$。\n    基偏移量还必须是 $8$字节对齐的：$off_3 \\pmod 8 = 0$。\n    我们需要找到小于或等于 $-56$ 且是 $8$ 的倍数的最大整数偏移量（即最接近 0）。这个值是 $-56$。\n    -   $L_{3}$ 占据内存范围 `[RBP - 56, RBP - 33]`。\n    -   $L_3$ 的基偏移量是 $-56$。\n    -   在 $L_2$ 和 $L_3$ 之间没有填充。\n\n所有局部变量及其内部填充所需的总连续内存块从 `RBP - 1` 延伸到 `RBP - 56`，总大小为 $56$ 字节。\n\n**2.4. 确定用于调用对齐的额外填充**\n该函数调用另一个函数，因此是非叶函数。在它发出 `call` 指令之前，`RSP` 必须是 $16$字节对齐的。\n局部存储区域占据 $56$ 字节。函数序言必须通过 `sub RSP, N` 分配至少这么大的空间。\n设总分配大小为 $N$ 字节，其中 $N = 56 + P$，$P$ 是额外填充。序言之后，`RSP = RBP - N`。\n一个标准且稳健的编译策略是在序言之后立即对齐栈指针。这为函数体提供了一个正确对齐的栈来操作，简化了后续为调用所做的准备。为实现这一点，总的局部区域分配大小 `N` 必须是 $16$ 的倍数，因为 `RBP` 是 $16$字节对齐的。\n-   局部变量所需大小：$56$ 字节。\n-   我们需要找到 $16$ 的最小倍数，称之为 $N$，使得 $N \\ge 56$。\n-   $16$ 的倍数：$16, 32, 48, 64, ...$\n-   大于或等于 $56$ 的最小 $16$ 的倍数是 $64$。\n-   因此，总分配大小为 $N=64$ 字节。\n-   所需的额外填充是 $P = N - 56 = 64 - 56 = 8$ 字节。\n\n有了这个填充，序言指令将是 `sub RSP, 64`。然后 `RSP` 将是 `RBP - 64`，这是 $16$字节对齐的。当此函数随后调用另一个函数时，`RSP` 已经对齐（假设子调用不占用栈参数）。如果子调用需要栈参数，编译器会从这个对齐的基准开始进行进一步的栈调整来准备参数，同时保持对齐不变量。静态帧中的 8 字节填充是建立这个对齐基准所需的最小量。\n\n**结果总结：**\n-   $L_{1}$ 的偏移量：$-8$ 字节。\n-   $L_{2}$ 的偏移量：$-32$ 字节。\n-   $L_{3}$ 的偏移量：$-56$ 字节。\n-   `arg_7` 的偏移量：$+16$ 字节。\n-   额外填充：$8$ 字节。\n\n最终答案是按指定顺序排列的这些值的行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-8  -32  -56  16  8\n\\end{pmatrix}\n}\n$$", "id": "3680344"}, {"introduction": "当调用者和被调用者对函数签名的“契约”有不同理解时会发生什么？这个练习就像一个侦探故事，探讨了当一个函数指针指向一个类型不匹配的函数时所产生的后果。通过精确追踪ABI规则下发生的具体、机械的后果，这个练习揭示了“未定义行为”的神秘面纱，展示了数据是如何被错误解读的，这对于编写健壮和安全的系统软件至关重要。[@problem_id:3680339]", "problem": "考虑一个为 $\\text{x86\\_64}$ 架构上的 System V 应用程序二进制接口（ABI）编译的程序。以下事实（经过充分检验的 ABI 规则）成立：\n- 前六个整数或指针参数按顺序通过寄存器传递：$rdi$、$rsi$、$rdx$、$rcx$、$r8$、$r9$。\n- 前八个浮点参数通过 $xmm0$ 到 $xmm7$ 传递。\n- 整数或指针返回值在 $rax$ 中传递；浮点返回值在 $xmm0$ 中传递。\n- 在 `call` 指令执行时，栈指针 $rsp$ 必须是 $16$ 字节对齐的。\n- 被调用者保存的寄存器包括 $rbx$、$rbp$、$r12$、$r13$、$r14$ 和 $r15$；调用者保存的寄存器包括 $rax$、$rcx$、$rdx$、$rsi$、$rdi$、$r8$–$r11$ 和 $xmm0$–$xmm15$。\n\n一个调用者持有一个静态类型为 `long (*)(long, long, long)` 的函数指针 $p$，并以 $a=10, b=20, c=30$ 调用它，形式为 $p(a,b,c)$。实际的目标函数（被错误地赋给了 $p$）的原型是 `double h(double x, int y, long z)`，并返回 $x + (double)y + (double)z$。假设在没有清理程序（sanitizer）的情况下进行常规优化，没有可变参数，并且编译器遵守上述应用程序二进制接口（ABI）规则。同时假设调用者使用标准的序言（prologue）和调用序列，以确保 $rsp$ 的对齐规则得到满足。因此，由于原型不匹配，该程序表现出未定义行为。\n\n以下哪项描述正确地刻画了进入 `h` 时预期与实际的活动记录状态（寄存器和栈），以及由此对计算和调用者观察到的返回值产生的影响？\n\nA. 进入 `h` 时，$x$ 从 $xmm0$ 中读取（调用者未设置该寄存器，因此其包含一个不确定的值），$y$ 从 $edi$ 中读取（即持有 $a$ 的 $rdi$ 的低 $32$ 位），$z$ 从 $rsi$ 中读取（其持有 $b$）。调用者的第三个参数 $c$ 位于 $rdx$ 中，但被忽略，因为 `h` 不会使用第三个整数寄存器参数。被调用者使用一个不确定的 $x$ 计算出一个 $double$ 值，在 $xmm0$ 中返回该 $double$ 值，而调用者从 $rax$ 中读取一个 $long$ 结果，但 $rax$ 并不持有返回的 $double$ 值。因此，调用者观察到的 $long$ 值是未指定的。\n\nB. 过程调用标准规定，当发生原型不匹配时，调用者也必须通过将 $a$ 转换为 $(double)a$ 来将任何对应的浮点参数放入 $xmm0$，因此在入口处 $x$ 将等于 $(double)a$，计算将确定性地进行。\n\nC. 无论寄存器传递如何，内存中的活动记录在被调用者的栈帧中的固定偏移量处包含 $a$、$b$、$c$，被调用者从栈中读取它们。因此，$x$、$y$和$z$按顺序从栈中获取，计算是确定性的。\n\nD. 不匹配的原型迫使编译器生成一个可变参数风格的调用序列，将所有参数移动到栈上并清除 $xmm$ 寄存器。这消除了未定义行为，因为被调用者届时将根据需要从内存中加载所有三个参数。\n\nE. 即使原型不匹配，栈对齐和影子空间（shadow space）也保证了在函数返回时 $xmm0$ 的低 $64$ 位会镜像到 $rax$ 中，因此调用者会将返回的 $double$ 值的位表示读入 $r$。\n\nF. 在这种情况下，根据 ABI 的要求，栈指针 $rsp$ 在调用点保持 $16$ 字节对齐，因此对齐错误不是未定义行为的来源；未定义行为的产生是因为被调用者从 $xmm0$ 读取 $x$ 并在 $xmm0$ 中返回值，而调用者既没有为参数初始化 $xmm0$，也没有为返回值读取 $xmm0$。\n\n选择所有正确选项。", "solution": "### 问题验证\n\n根据所提供的规则对问题陈述进行评估。\n\n**步骤 1：提取已知信息**\n\n*   **平台**：$\\text{x86\\_64}$ 架构上的 System V 应用程序二进制接口（ABI）。\n*   **ABI 规则（整数/指针参数）**：前六个参数通过寄存器按顺序传递：$rdi, rsi, rdx, rcx, r8, r9$。\n*   **ABI 规则（浮点参数）**：前八个参数通过寄存器 $xmm0$ 到 $xmm7$ 传递。\n*   **ABI 规则（返回值）**：整数/指针值在 $rax$ 中返回。浮点值在 $xmm0$ 中返回。\n*   **ABI 规则（栈）**：在 `call` 指令执行时，栈指针 $rsp$ 必须是 $16$ 字节对齐的。\n*   **ABI 规则（寄存器保存约定）**：\n    *   被调用者保存：$rbx, rbp, r12, r13, r14, r15$。\n    *   调用者保存：$rax, rcx, rdx, rsi, rdi, r8-r11, xmm0-xmm15$。\n*   **调用者行为**：\n    *   持有一个静态类型为 `long (*)(long, long, long)` 的函数指针 $p$。\n    *   以 $a=10, b=20, c=30$ 执行调用 $p(a, b, c)$。\n    *   假定遵循 ABI 的对齐规则。\n*   **被调用者（实际函数）行为**：\n    *   函数是 `h`，其原型为 `double h(double x, int y, long z)`。\n    *   函数返回表达式 $x + (double)y + (double)z$ 的值。\n*   **假设**：常规优化，无清理程序，无可变参数，编译器遵守 ABI。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n*   **科学依据**：该问题基于真实世界且有详细文档记录的 System V AMD64 ABI。所有陈述的规则都是对该标准的正确表述。通过类型不匹配的指针进行函数调用的场景，是一个经典且现实的编程错误，会导致未定义行为。\n*   **定义明确**：问题定义清晰。调用者的行为由其静态类型信息决定，被调用者的行为由其实际原型决定。ABI 规则提供了一个确定性的框架来追踪这种不匹配所带来的机械后果。可以对状态转移进行唯一的分析。\n*   **客观性**：问题使用了来自计算机体系结构和系统编程的精确、标准术语（例如，“活动记录”、“寄存器”、“ABI”、“栈指针”）。它不含主观或模糊的语言。\n*   **完整性与一致性**：问题提供了足够的信息来分析该场景。没有内部矛盾。程序表现出“未定义行为”的说法在技术上是正确的，但问题要求基于 ABI 追踪具体的机械后果，这是一个标准的教学练习。\n\n**步骤 3：结论与操作**\n\n问题陈述是**有效的**。这是一个合理且定义明确的问题，旨在测试对标准调用约定的详细知识。\n\n### 解题推导\n\n分析过程是根据 ABI 分别考虑调用者和被调用者的行为，然后调和不匹配的状态。\n\n**1. 调用者的行为（调用 `p`）**\n\n调用者的编译器看到一个通过类型为 `long (*)(long, long, long)` 的指针进行的调用。根据 System V ABI，它将按如下方式准备参数：\n*   从调用者的角度来看，该函数不是浮点函数。\n*   第一个参数 `a = 10`（`long` 类型）被放入寄存器 $rdi$。\n*   第二个参数 `b = 20`（`long` 类型）被放入寄存器 $rsi$。\n*   第三个参数 `c = 30`（`long` 类型）被放入寄存器 $rdx$。\n*   调用者不使用任何 $xmm$ 寄存器来传递参数，因为它所知道的函数原型不包含浮点类型。寄存器 $xmm0$ 是调用者保存的，这意味着不保证其内容在函数调用后保持不变，并且调用者没有义务在调用前将其设置为任何特定值。因此，从被调用者的角度来看，它的值是不确定的。\n*   调用者执行一条 `call` 指令。根据问题陈述，此时栈指针 $rsp$ 是 $16$ 字节对齐的。\n*   函数返回后，调用者期望在 $rax$ 寄存器中得到 `long` 类型的返回值。\n\n**2. 被调用者的行为（进入 `h` 时）**\n\n实际执行的函数是 `h`，其原型为 `double h(double x, int y, long z)`。根据 ABI，它期望按如下方式接收其参数：\n*   第一个参数是 `x`（`double` 类型）。根据 ABI 的分类，这是一个浮点类型，所以它应在寄存器 $xmm0$ 中。\n*   第二个参数是 `y`（`int` 类型）。这是一个整数类型。下一个可用的整数类寄存器是 $rdi$。函数将读取 $rdi$ 的低 $32$ 位（即 $edi$ 寄存器）作为此值。\n*   第三个参数是 `z`（`long` 类型）。这是一个整数类型。下一个可用的整数类寄存器是 $rsi$。函数将读取完整的 $64$ 位 $rsi$ 寄存器作为此值。\n\n**3. 状态调和与计算**\n\n结合调用者的行为和被调用者的期望，我们确定 `h` 内部的实际初始状态：\n*   参数 $x$：`h` 从 $xmm0$ 读取。调用者没有在此处放置值。因此，$x$ 的值是不确定的（垃圾值）。\n*   参数 $y$：`h` 从 $edi$ 读取。调用者将 $a=10$ 放入了 $rdi$。所以，$y$ 接收到值 $10$。\n*   参数 $z$：`h` 从 $rsi$ 读取。调用者将 $b=20$ 放入了 $rsi$。所以，$z$ 接收到值 $20$。\n*   调用者的第三个参数 $c=30$ 在 $rdx$ 中，但 `h` 从未为它的参数读取该寄存器。\n\n函数 `h` 接着计算其返回值：$x + (double)y + (double)z$。\n这变成：$(\\text{不确定值}) + (double)10 + (double)20 = (\\text{不确定值}) + 30.0$。\n结果是一个不确定的 `double` 值。\n\n**4. 返回值处理**\n\n*   `h` 返回一个 `double` 值。根据 ABI，它将这个不确定的结果放入寄存器 $xmm0$。\n*   调用者期望一个 `long` 类型的返回值，因此从寄存器 $rax$ 读取。\n*   ABI 没有规定函数返回时 $xmm0$ 和 $rax$ 之间有任何联系。$rax$ 是一个调用者保存的寄存器，`h` 没有义务在其中放置任何特定值，特别是因为它返回的是一个 `double`。因此，返回到调用者时 $rax$ 中的值是未指定的。它可能是调用前的值，也可能在 `h` 执行期间被用于无关的临时计算而被覆盖。\n\n**结论**：调用者从 $rax$ 接收到一个未指定的 `long` 值，这个值与 `h` 计算并在 $xmm0$ 中返回的 `double` 值完全无关。\n\n### 逐项分析选项\n\n**A. 进入 `h` 时，$x$ 从 $xmm0$ 中读取（调用者未设置该寄存器，因此其包含一个不确定的值），$y$ 从 $edi$ 中读取（即持有 $a$ 的 $rdi$ 的低 $32$ 位），$z$ 从 $rsi$ 中读取（其持有 $b$）。调用者的第三个参数 $c$ 位于 $rdx$ 中，但被忽略，因为 `h` 不会使用第三个整数寄存器参数。被调用者使用一个不确定的 $x$ 计算出一个 $double$ 值，在 $xmm0$ 中返回该 $double$ 值，而调用者从 $rax$ 中读取一个 $long$ 结果，但 $rax$ 并不持有返回的 $double$ 值。因此，调用者观察到的 $long$ 值是未指定的。**\n\n此选项对事件进行了完整而准确的逐步描述。它正确地指出了调用者和被调用者为每个参数使用的寄存器、对计算的后果（使用了一个不确定值）、用于返回值的不同寄存器，以及调用者的最终结果。\n*结论：**正确***。\n\n**B. 过程调用标准规定，当发生原型不匹配时，调用者也必须通过将 $a$ 转换为 $(double)a$ 来将任何对应的浮点参数放入 $xmm0$，因此在入口处 $x$ 将等于 $(double)a$，计算将确定性地进行。**\n\n这是错误的。C 语言的编译模型基于静态类型。调用者的编译器根据它所知道的类型 `long (*)(long, long, long)` 生成代码，并且没有关于实际目标函数原型的信息。ABI 没有这种针对类型不匹配的“修复”机制；它们只会导致未定义行为。\n*结论：**错误***。\n\n**C. 无论寄存器传递如何，内存中的活动记录在被调用者的栈帧中的固定偏移量处包含 $a$、$b$、$c$，被调用者从栈中读取它们。因此，$x$、$y$和$z$按顺序从栈中获取，计算是确定性的。**\n\n这是错误的。System V x86_64 ABI 极力提倡在寄存器中传递参数以提高性能。只有在可用寄存器用尽时，参数才会在栈上传递。在这种情况下，调用者和被调用者都期望参数在寄存器中。\n*结论：**错误***。\n\n**D. 不匹配的原型迫使编译器生成一个可变参数风格的调用序列，将所有参数移动到栈上并清除 $xmm$ 寄存器。这消除了未定义行为，因为被调用者届时将根据需要从内存中加载所有三个参数。**\n\n这是错误的。函数指针的静态类型不包括省略号（`...`），因此编译器不会生成可变参数调用序列。这种不匹配在编译时不会被检测到。\n*结论：**错误***。\n\n**E. 即使原型不匹配，栈对齐和影子空间（shadow space）也保证了在函数返回时 $xmm0$ 的低 $64$ 位会镜像到 $rax$ 中，因此调用者会将返回的 $double$ 值的位表示读入 $r$。**\n\n这是错误的。System V ABI 中没有这样的规则。“影子空间”是 Windows x64 ABI 的一个特性，而不是 System V 的。更重要的是，浮点返回寄存器（$xmm0$）和整数返回寄存器（$rax$）之间没有自动镜像。它们是截然不同的，用于不同的返回类型。\n*结论：**错误***。\n\n**F. 在这种情况下，根据 ABI 的要求，栈指针 $rsp$ 在调用点保持 $16$ 字节对齐，因此对齐错误不是未定义行为的来源；未定义行为的产生是因为被调用者从 $xmm0$ 读取 $x$ 并在 $xmm0$ 中返回值，而调用者既没有为参数初始化 $xmm0$，也没有为返回值读取 $xmm0$。**\n\n这个陈述对问题给出了一个高层次且正确的诊断。它根据问题的前提正确地指出栈对齐不是问题所在。它正确地指出了两个根本性的失败点：（1）传递第一个参数时寄存器使用的不匹配（`调用者没有初始化 xmm0` 但 `被调用者从 xmm0 读取 x`），以及（2）返回值寄存器使用的不匹配（`被调用者在 xmm0 中返回` 但调用者从 $rax$ 读取）。这是对情况的有效且准确的描述。\n*结论：**正确***。", "answer": "$$\\boxed{AF}$$", "id": "3680339"}, {"introduction": "学习了构建栈帧的规则后，下一步自然是如何高效地构建它。这个练习将我们带入编译器优化的领域，提出了一个有趣的难题：如何最小化函数的栈帧大小？本练习将介绍一种关键的优化技术——基于变量生命周期的栈槽重用，并向您展示如何通过分析变量的存活区间来显著减少函数的内存占用。[@problem_id:3680337]", "problem": "一个函数 $g$ 在一台采用传统基于栈的调用约定的机器上运行。对 $g$ 的一次调用的激活记录（栈帧）必须包含以下固定字段：返回地址（一个机器字）、保存的帧指针（一个机器字），以及两个被调用者选择使用并因此必须保存的被调用者保存寄存器（两个机器字）。假设每个栈槽正好容纳一个机器字，栈的增长方向与机器的约定一致，并且除了这些字之外，不需要额外的填充或对齐约束。除了固定字段外，$g$ 还有几个驻留在栈上的对象（溢出的临时变量和局部变量），这些对象仅在其值是活跃的时候才需要存在于激活记录中。只要它们的活跃范围在时间上不重叠，单个栈槽就可以被多个这样的对象重用。\n\n考虑 $g$ 的一个直线代码区域，由程序点 $p \\in \\{0,1,\\ldots,16\\}$ 标记，驻栈对象的活跃范围以半开区间 $[l,r)$ 的形式给出，意味着对象在点 $l$ 之后立即变为活跃，并保持活跃直到但不包括点 $r$。这些对象及其活跃范围是：\n- $A: [2,7)$\n- $B: [1,4)$\n- $C: [5,10)$\n- $D: [3,5)$\n- $E: [8,12)$\n- $F: [11,15)$\n- $L: [6,11)$\n- $T: [9,13)$\n\n假设返回地址和保存的帧指针在对 $g$ 的整个调用过程中都存在，并且 $g$ 使用的两个被调用者保存寄存器在序言中保存，在尾声中恢复，因此它们在整个函数执行期间都占用其槽位。\n\n使用激活记录、活跃性和干涉（如果两个对象的活跃范围重叠，则它们相互干涉，因此不能同时占用同一个槽）的基本定义，从第一性原理出发，确定可重用溢出/局部变量槽的最小数量和最小总激活记录大小（以机器字为单位）。然后选择正确给出最小总大小并提供一个有效的对象到最小数量槽的重用映射以实现此大小的选项。\n\n选项：\nA. 总激活记录大小为 $8$ 个字。一个使用 $4$ 个溢出/局部变量槽的有效重用映射是：$s_1: B \\rightarrow C \\rightarrow F$，$s_2: A \\rightarrow E$，$s_3: D \\rightarrow L$，$s_4: T$。\nB. 总激活记录大小为 $9$ 个字，因为在 $[9,10)$ 区间，对象的峰值重叠数为 $5$。一种可能的映射是 $s_1: B$，$s_2: A$，$s_3: D \\rightarrow L$，$s_4: C$，$s_5: E \\rightarrow T \\rightarrow F$。\nC. 总激活记录大小为 $6$ 个字；映射 $s_1: B \\rightarrow C \\rightarrow F$，$s_2: A \\rightarrow E$，$s_3: D \\rightarrow L$，$s_4: T$ 足以满足溢出/局部变量部分的需求。\nD. 总激活记录大小为 $12$ 个字，因为存在调用时重用是不可能的；每个对象 $A,B,C,D,E,F,L,T$ 都必须有专用的槽，此外还有四个固定字。\nE. 总激活记录大小为 $8$ 个字；一个使用 $4$ 个溢出/局部变量槽的映射是 $s_1: A \\rightarrow C \\rightarrow E$，$s_2: B \\rightarrow F$，$s_3: D \\rightarrow L$，$s_4: T$。", "solution": "用户希望我通过首先验证问题陈述，然后在有效的情况下，推导解决方案并评估所提供的选项来解决问题。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n- 一个函数 $g$ 在一台采用传统基于栈的调用约定的机器上运行。\n- $g$ 的激活记录有固定字段：\n    - 返回地址：$1$ 个机器字。\n    - 保存的帧指针：$1$ 个机器字。\n    - 两个被调用者保存寄存器：$2$ 个机器字。\n- 每个栈槽容纳 $1$ 个机器字。\n- 不需要额外的填充或对齐约束。\n- 固定字段（返回地址、保存的帧指针、被调用者保存寄存器）在整个函数调用期间都存在。\n- 函数 $g$ 有几个驻栈对象，其存在仅在其值是活跃的时候才需要。\n- 如果多个对象的活跃范围不重叠，一个栈槽可以被它们重用。\n- 活跃范围是针对程序点 $p \\in \\{0, 1, \\ldots, 16\\}$ 给出的半开区间 $[l,r)$。\n- 驻栈对象的活跃范围是：\n    - $A: [2,7)$\n    - $B: [1,4)$\n    - $C: [5,10)$\n    - $D: [3,5)$\n    - $E: [8,12)$\n    - $F: [11,15)$\n    - $L: [6,11)$\n    - $T: [9,13)$\n\n**第 2 步：使用提取的已知条件进行验证**\n\n1.  **科学上合理：** 该问题基于编译器设计和计算机体系结构中的基本和标准概念，即栈帧组织、变量的活跃性分析和寄存器分配（特别是变量溢出到栈）。通过分析活跃范围干涉来确定所需槽的最小数量的方法是图论（特别是区间图的着色）的经典应用。该问题在科学上是合理的。\n2.  **定义明确：** 该问题提供了确定唯一解所需的所有信息。活跃范围被明确定义，栈帧固定部分的大小已指定，问题要求的是最小大小，这对应于同时活跃变量的最大数量（干涉图中的最大团的大小）。这是一个定义明确、有唯一答案的优化问题。\n3.  **客观：** 问题以精确、客观的语言陈述。数据是数字化的，概念（活跃范围、重叠）有正式的定义。没有歧义或主观内容。\n\n问题陈述是有效的。它是自包含、一致的，并基于既定的计算机科学原理。\n\n### 解决方案推导\n\n该问题要求函数 $g$ 的激活记录的最小总大小。这个大小是两个组成部分之和：固定字段的大小和用于驻栈局部对象和溢出变量区域的最小大小。\n\n**1. 固定字段的大小**\n\n问题陈述激活记录包含：\n- $1$ 个机器字用于返回地址。\n- $1$ 个机器字用于保存的帧指针。\n- $2$ 个机器字用于两个被调用者保存寄存器。\n\n这些字段在整个函数执行期间都存在。因此，激活记录的固定部分的大小是：\n$$ S_{fixed} = 1 + 1 + 2 = 4 \\text{ 个机器字} $$\n\n**2. 溢出/局部变量区域的最小大小**\n\n溢出/局部变量区域用于存放对象 $A, B, C, D, E, F, L, T$。如果不同对象的活跃范围不重叠，一个栈槽可以被它们重用。所需的最小槽数由任何时间点上同时活跃的对象最大数量决定。这等价于在给定的活跃范围中找到重叠区间的最大数量。\n\n活跃范围是：\n- $A: [2,7)$\n- $B: [1,4)$\n- $C: [5,10)$\n- $D: [3,5)$\n- $E: [8,12)$\n- $F: [11,15)$\n- $L: [6,11)$\n- $T: [9,13)$\n\n让我们确定在程序点定义的时间区间内活跃对象的数量，记为 $N$。活跃对象的数量仅在区间的起点或终点发生变化。\n\n- 区间 $[1,2)$: 活跃对象为 $\\{B\\}$。$N=1$。\n- 区间 $[2,3)$: 活跃对象为 $\\{B, A\\}$。$N=2$。\n- 区间 $[3,4)$: 活跃对象为 $\\{B, A, D\\}$。$N=3$。\n- 区间 $[4,5)$: 活跃对象为 $\\{A, D\\}$（B 在 4 处结束活跃）。$N=2$。\n- 区间 $[5,6)$: 活跃对象为 $\\{A, C\\}$（D 在 5 处结束活跃，C 在 5 处开始活跃）。$N=2$。\n- 区间 $[6,7)$: 活跃对象为 $\\{A, C, L\\}$。$N=3$。\n- 区间 $[7,8)$: 活跃对象为 $\\{C, L\\}$（A 在 7 处结束活跃）。$N=2$。\n- 区间 $[8,9)$: 活跃对象为 $\\{C, L, E\\}$。$N=3$。\n- 区间 $[9,10)$: 活跃对象为 $\\{C, L, E, T\\}$。$N=4$。\n- 区间 $[10,11)$: 活跃对象为 $\\{L, E, T\\}$（C 在 10 处结束活跃）。$N=3$。\n- 区间 $[11,12)$: 活跃对象为 $\\{E, T, F\\}$（L 在 11 处结束活跃，F 在 11 处开始活跃）。$N=3$。\n- 区间 $[12,13)$: 活跃对象为 $\\{T, F\\}$（E 在 12 处结束活跃）。$N=2$。\n- 区间 $[13,15)$: 活跃对象为 $\\{F\\}$（T 在 13 处结束活跃）。$N=1$。\n- 区间 $[15, \\ldots)$: 没有活跃对象。$N=0$。\n\n同时活跃对象的最大数量是 $4$，出现在程序点区间 $[9,10)$，此时活跃对象的集合是 $\\{C, L, E, T\\}$。这意味着溢出/局部对象至少需要 $4$ 个不同的栈槽。这个最小值是可以达到的，因为对于区间图，色数等于团数。\n\n因此，溢出/局部变量区域的最小大小是：\n$$ S_{local} = 4 \\text{ 个机器字} $$\n\n**3. 最小总激活记录大小**\n\n激活记录的最小总大小是固定部分和最小局部部分大小之和。\n$$ S_{total} = S_{fixed} + S_{local} = 4 + 4 = 8 \\text{ 个机器字} $$\n\n### 逐项分析选项\n\n现在，我们根据推导出的结果评估每个选项。\n\n**A. 总激活记录大小为 $8$ 个字。一个使用 $4$ 个溢出/局部变量槽的有效重用映射是：$s_1: B \\rightarrow C \\rightarrow F$，$s_2: A \\rightarrow E$，$s_3: D \\rightarrow L$，$s_4: T$。**\n\n- **总大小：** 所述大小为 $8$ 个字，与我们的计算相符。正确。\n- **溢出/局部变量槽：** 映射使用了 $4$ 个槽（$s_1, s_2, s_3, s_4$），与我们计算的最小值相符。正确。\n- **映射有效性：** 我们必须检查映射到同一个槽的对象其活跃范围是否重叠。两个区间 $[l_1, r_1)$ 和 $[l_2, r_2)$ 不重叠，当且仅当 $r_1 \\le l_2$ 或 $r_2 \\le l_1$。\n    - $s_1: B[1,4), C[5,10), F[11,15)$。\n        - $B$ 和 $C$：$4 \\le 5$。无重叠。\n        - $C$ 和 $F$：$10 \\le 11$。无重叠。\n        - 此映射有效。\n    - $s_2: A[2,7), E[8,12)$。\n        - $A$ 和 $E$：$7 \\le 8$。无重叠。\n        - 此映射有效。\n    - $s_3: D[3,5), L[6,11)$。\n        - $D$ 和 $L$：$5 \\le 6$。无重叠。\n        - 此映射有效。\n    - $s_4: T[9,13)$。\n        - 只有一个对象。此为有效。\n整个映射是有效的。该选项提供了正确的最小大小和有效的最小槽映射。\n- **结论：** 正确。\n\n**B. 总激活记录大小为 $9$ 个字，因为在 $[9,10)$ 区间，对象的峰值重叠数为 $5$。一种可能的映射是 $s_1: B$，$s_2: A$，$s_3: D \\rightarrow L$，$s_4: C$，$s_5: E \\rightarrow T \\rightarrow F$。**\n\n- **总大小和理由：** 所述大小为 $9$ 个字是错误的。其理由“峰值重叠数为 $5$”也是错误的；我们的分析表明峰值重叠数是 $4$。\n- **结论：** 错误。\n\n**C. 总激活记录大小为 $6$ 个字；映射 $s_1: B \\rightarrow C \\rightarrow F$，$s_2: A \\rightarrow E$，$s_3: D \\rightarrow L$，$s_4: T$ 足以满足溢出/局部变量部分的需求。**\n\n- **总大小：** 所述大小为 $6$ 个字是错误的。仅固定部分就有 $4$ 个字，溢出/局部变量部分还需要 $4$ 个字，总共为 $8$ 个字。\n- **映射：** 映射本身是有效的（如选项 A 的分析所示），但总大小是错误的。\n- **结论：** 错误。\n\n**D. 总激活记录大小为 $12$ 个字，因为存在调用时重用是不可能的；每个对象 $A,B,C,D,E,F,L,T$ 都必须有专用的槽，此外还有四个固定字。**\n\n- **总大小：** 大小为 $12$ 个字对应于 $4$ 个固定字加上为 $8$ 个对象准备的 $8$ 个专用槽。如果无法重用，则大小将是如此。\n- **理由：** “重用是不可能的”这一理由直接与问题的前提相矛盾，问题明确允许重用。问题描述了一个直线代码块，没有提到会使活跃性分析复杂化的函数调用。\n- **结论：** 错误。\n\n**E. 总激活记录大小为 $8$ 个字；一个使用 $4$ 个溢出/局部变量槽的映射是 $s_1: A \\rightarrow C \\rightarrow E$，$s_2: B \\rightarrow F$，$s_3: D \\rightarrow L$，$s_4: T$。**\n\n- **总大小：** 所述大小为 $8$ 个字是正确的。\n- **溢出/局部变量槽：** 映射正确地使用了 $4$ 个槽。\n- **映射有效性：** 我们检查分配。\n    - $s_1: A[2,7), C[5,10), E[8,12)$。\n        - $A$ 和 $C$：$A$ 的活跃范围是 $[2,7)$，$C$ 的活跃范围是 $[5,10)$。这些区间在 $[5,7)$ 范围内重叠。因此，对象 $A$ 和 $C$ 不能分配到同一个槽。\n    - 由于此分配无效，整个映射无效。\n- **结论：** 错误。\n\n根据分析，只有选项 A 是完全正确的。它陈述了正确的最小总大小，并提供了一个将对象分配到所需最小数量槽的有效映射。", "answer": "$$\\boxed{A}$$", "id": "3680337"}]}