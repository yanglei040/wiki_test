{"hands_on_practices": [{"introduction": "本练习将展示如何在一个字内操控完整的数据块。我们将学习如何使用掩码（masking）来分离特定的字节组，并利用移位（shifting）将它们移动到新的位置，这是实现字节序转换（endianness conversion）等任务的一项基本技能。这项实践 ([@problem_id:3623175]) 是理解数据在寄存器层面如何被重组和操纵的绝佳起点。", "problem": "设一个 $32$ 位无符号字 $x$ 被看作一个有序的四字节元组 $[b_3, b_2, b_1, b_0]$，其中 $b_0$ 是最低有效字节，$b_3$ 是最高有效字节。在与小端位编号一致的标准字节索引中，$b_0$ 占据位位置 $[0,7]$，$b_1$ 占据位位置 $[8,15]$，$b_2$ 占据位位置 $[16,23]$，而 $b_3$ 占据位位置 $[24,31]$。目标是仅使用可在典型通用处理器上实现的基本位级操作，将该字重构为字节顺序 $[b_1, b_0, b_3, b_2]$：按位与 (``)、按位或 (`|`)、左移 (``)、右移 (`>>`)，以及使用 $(2^{32}-1)$ 进行掩码操作。不得使用任何内置的“循环移位”指令或外部库例程。所有中间步骤必须通过使用 $(2^{32}-1)$ 进行掩码操作来处理模 $2^{32}$ 的值，以遵循 $32$ 位的字宽。\n\n您可以依赖的起点定义和事实：\n- “字节”为 $8$ 位。此处的“字”为 $32$ 位。\n- 按位与 (``)、按位或 (`|`)、左移 (``) 和右移 (`>>`) 作用于整数的二进制表示；当应用于无符号整数时，右移在逻辑上定义为零填充。\n- 使用 $(2^{32}-1)$ 进行掩码操作可将值限制为其最低有效的 $32$ 位。\n- 定宽字的循环移位会周期性地移动位，使得从一端移出的位从另一端重新进入；您可以使用此概念进行推理，但重构必须仅使用移位和掩码来实现。\n\n构建一个程序，对于一组给定的 $32$ 位无符号字，计算其字节排列为 $[b_1, b_0, b_3, b_2]$ 的重构字。程序必须完全使用所述的位移、掩码和组合来实现重构。程序不得读取任何输入；它必须为以下参数值的测试套件生成输出，每个值都按模 $2^{32}$ 解释：\n- $x = 0x\\text{AABBCCDD}$\n- $x = 0x\\text{12345678}$\n- $x = 0x\\text{00000000}$\n- $x = 0x\\text{FFFFFFFF}$\n- $x = 0x\\text{80000001}$\n- $x = 0x\\text{00FF00FF}$\n\n为覆盖性而设计：\n- 包含一个所有字节都不同的情况，以测试通用正确性。\n- 包含全零和全一的字，以测试边界条件。\n- 包含单个高位或低位影响跨字节移动的情况。\n- 包含具有对称半字的情况，以在适当时测试变换下的不变性。\n\n您的程序应生成单行输出，其中包含重构的 $32$ 位字，每个字表示为无符号十进制整数，聚合成一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_n]$）。不得打印任何额外的文本或格式。", "solution": "### 步骤 1：问题有效性评估\n首先评估问题陈述的有效性。\n- **科学基础**：该问题在根本上是合理的。它基于数字逻辑和计算机体系结构的原理，特别是整数的二进制表示及其使用标准位运算的操作。这些概念是计算机科学的基石。\n- **适定性**：该问题是适定的。它提供了一个清晰的初始状态 ($x$)、一个精确定义的最终状态（目标字节顺序）和一组明确允许的变换。这些约束足以构建一个唯一且确定性的解决方案。\n- **客观性**：该问题以精确、客观和形式化的语言陈述。所有术语，如“字节”、“字”、“位位置”以及位运算本身，在计算机科学的背景下都有标准、无歧义的定义。\n- **其他缺陷**：该问题没有表现出任何其他缺陷。它不是不完整、矛盾、不切实际、病态或微不足道的。该任务是低级数据操作的标准练习，通常与字节序转换等任务相关。\n\n结论：该问题是**有效的**。将构建一个解决方案。\n\n### 步骤 2：基于原理的解决方案\n目标是将一个具有字节结构 $[b_3, b_2, b_1, b_0]$ 的 $32$ 位无符号字 $x$ 转换为一个具有字节结构 $[b_1, b_0, b_3, b_2]$ 的新字 $y$。符号 $[b_3, b_2, b_1, b_0]$ 表示 $b_3$ 是最高有效字节，$b_0$ 是最低有效字节。\n\n该转换可以分解为四个步骤：\n1.  从原始字 $x$ 中分离出四个字节（$b_3, b_2, b_1, b_0$）。\n2.  将每个分离出的字节移到其在目标字 $y$ 中的新位置。\n3.  使用按位或操作组合四个移位后的结果。\n4.  确保所有操作都遵循 $32$ 位字长，符合模 $2^{32}$ 的算术规则。\n\n设原始字为 $x$。目标字 $y$ 的字节排列如下：\n- 原始字节 $b_1$ 移动到最高有效字节位置，即位 $[24,31]$。\n- 原始字节 $b_0$ 移动到第二高有效字节位置，即位 $[16,23]$。\n- 原始字节 $b_3$ 移动到第二低有效字节位置，即位 $[8,15]$。\n- 原始字节 $b_2$ 移动到最低有效字节位置，即位 $[0,7]$。\n\n此转换等同于交换 $32$ 位字的两个 $16$ 位半字。设 $x$ 的低半字为 $H_L = [b_1, b_0]$，高半字为 $H_U = [b_3, b_2]$。目标字 $y$ 将具有结构 $[H_L, H_U]$。\n\n我们可以通过首先分离这两个半字，然后重新定位它们来构建解决方案。\n\n1.  **隔离低 $16$ 位半字 ($H_L = [b_1, b_0]$)**：这个半字占据位 $[0,15]$。我们可以通过与一个在低 $16$ 位为1、其他位为0的掩码进行按位与操作来隔离它。这个掩码是 $0x0000\\text{FFFF}$。\n    `x_L = x  0x0000FFFF`\n    此操作得到一个高 $16$ 位为零，低 $16$ 位包含 $[b_1, b_0]$ 的字。\n\n2.  **将低半字移动到高位位置**：要将 $H_L$ 移动到目标字的高 $16$ 位（位 $[16,31]$），我们必须执行 $16$ 位的左移操作。\n    `y_upper = x_L  16 = (x  0x0000FFFF)  16`\n\n3.  **隔离高 $16$ 位半字 ($H_U = [b_3, b_2]$)**：这个半字占据位 $[16,31]$。有两种等效的方法可以将其值隔离到一个临时字的低 $16$ 位中。\n    a) 我们可以先用 $0x\\text{FFFF}0000$ 对其进行掩码操作，然后右移 $16$ 位。\n    b) 由于我们操作的是无符号整数，逻辑右移 $16$ 位会将位 $[16,31]$ 移动到位置 $[0,15]$，并自动用零填充新空出的高位。这种方法更直接。\n    `x_U = x >> 16`\n    此操作产生一个低 $16$ 位包含 $[b_3, b_2]$ 且高 $16$ 位为零的字。这是将高半字的值直接提取到低位位置。\n\n4.  **组合重新定位的半字**：最终结果 $y$ 是通过两个部分的按位或得到的。高位部分 `y_upper` 的低 $16$ 位已经为零，低位部分 `x_U` 的高 $16$ 位也为零。因此，它们的按位或将无干扰地组合它们。\n    `y = y_upper | x_U`\n    代入表达式：\n    `y = ((x  0x0000FFFF)  16) | (x >> 16)`\n这个表达式仅使用允许的操作，正确地将字重构为字节顺序 $[b_1, b_0, b_3, b_2]$。在C语言中，对 `unsigned int` 的操作（假设是标准 `int` 大小）会自动遵守 $32$ 位字边界，满足了模 $2^{32}$ 运算的要求。该算法有效地在 $32$ 位字上执行了 $16$ 位循环移位，而没有使用专用的循环移位指令，这与问题的概念框架是一致的。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```", "id": "3623175"}, {"introduction": "本练习将挑战你跳出简单数据移动的思维定式，转而利用位运算来实现无分支的条件逻辑。你将发现算术右移如何巧妙地创建一个依赖于符号的掩码，从而推导出一个优雅且高效的绝对值计算算法。这项实践 ([@problem_id:3623138]) 深刻揭示了二的补码表示法与位运算相结合所能产生的巨大威力。", "problem": "考虑一个在 $w$ 位上用二进制补码表示的有符号整数，其中 $w \\in \\mathbb{Z}$ 且 $w \\ge 2$。在二进制补码中，可表示的集合为 $\\{x \\in \\mathbb{Z} \\mid -2^{w-1} \\le x \\le 2^{w-1} - 1\\}$，最小值为 $-2^{w-1}$，最大值为 $2^{w-1} - 1$。算术右移会复制符号位，而按位异或 (XOR) 操作会翻转其掩码中为 $1$ 的那些位。\n\n从以下基本概念出发：\n- 关于 $w$ 位二进制补码编码的定义及其模 $2^w$ 的回绕特性。\n- 对一个有符号二进制补码值进行 $k$ 位算术右移 (ARS) 的语义：它等同于除以 $2^k$ 并向负无穷方向截断，同时复制符号位。\n- 位运算的语义：按位异或 (XOR)、按位非、减法和掩码操作。\n- 在固定宽度上，二进制补码取反与位运算之间的等价关系：对于一个 $w$ 位的值 $x$ 且 $x \\ne -2^{w-1}$，其取反操作满足 $-x \\equiv \\big(\\lnot x\\big) + 1 \\pmod{2^w}$；而对于 $x = -2^{w-1}$，则有 $\\big(\\lnot x\\big) + 1 \\equiv x \\pmod{2^w}$。\n\n任务：\n1. 设计一个无分支算法，在 $w$ 位二进制补码整数上，仅使用算术右移、异或、减法和掩码操作，在 $w$ 位语义下计算绝对值。你的设计在计算绝对值的地方不得使用条件分支。从上述定义出发，推导为何可以构建这样的算法，一个 $w-1$ 位的算术右移会产生什么样的掩码，以及为什么将该掩码与异或和减法结合可以得到期望的转换。\n2. 根据二进制补码和算术右移的语义，证明当 $x \\ge 0$ 时算法返回 $x$，当 $x > -2^{w-1}$ 时返回 $-x$，当 $x = -2^{w-1}$ 时返回 $-2^{w-1}$。你的证明必须通过分析位模式和模 $2^w$ 的回绕特性来显式处理 $x = -2^{w-1}$ 这个边界情况。\n3. 在一个完整的程序中实现所推导的算法，并在以下测试套件上验证其正确性。对于每个测试用例，将无分支算法的结果与数学上定义的 $w$ 位绝对值函数\n$$\n\\operatorname{abs}_w(x) =\n\\begin{cases}\nx,  x \\ge 0, \\\\\n-x,  x  -2^{w-1}, \\\\\n-2^{w-1},  x = -2^{w-1},\n\\end{cases}\n$$\n进行比较，并报告一个表示是否相等的布尔值，用整数 $1$ 表示真，用 $0$ 表示假。\n\n使用由 $(w, x)$ 对组成的测试套件：\n- $(8, 42)$,\n- $(8, -42)$,\n- $(8, 127)$,\n- $(8, -127)$,\n- $(8, 0)$,\n- $(8, -2^{7})$,\n- $(16, 12345)$,\n- $(16, -12345)$,\n- $(16, -2^{15})$,\n- $(16, 2^{15} - 1)$,\n- $(32, -2^{31})$,\n- $(32, -2^{31} + 1)$,\n- $(32, 2^{31} - 1)$,\n- $(32, 1)$,\n- $(32, -1)$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。如果无分支算法对于相应的测试用例等于 $\\operatorname{abs}_w(x)$，则列表中的元素为整数 $1$，否则为 $0$（例如，$[1,0,1]$）。不涉及单位或角度，所有值都必须表示为纯整数。", "solution": "不使用条件分支计算有符号整数的绝对值问题是“位操作技巧”领域中的一个经典练习。该解决方案利用了二进制补码算术的属性以及特定位运算和算术机器指令的行为。下面的分析将形式化地推导并证明这种算法的正确性。\n\n### 步骤 1：算法设计与推导\n\n任务是为 $w$ 位二进制补码整数 $x$ 计算 $\\operatorname{abs}_w(x)$。该函数定义为：\n$$\n\\operatorname{abs}_w(x) =\n\\begin{cases}\nx,  \\text{if } x \\ge 0 \\\\\n-x,  \\text{if } x  0 \\text{ and } x > -2^{w-1} \\\\\n-2^{w-1},  \\text{if } x = -2^{w-1}\n\\end{cases}\n$$\n核心挑战在于仅使用允许的操作——算术右移 (ARS)、异或、减法和掩码操作——来实现条件逻辑（$x \\ge 0$ vs. $x  0$）。\n\n让我们将期望的结果表示为单一表达式。我们寻求一个变换 $f(x)$，使得当 $x$ 为非负数时 $f(x) = x$，当 $x$ 为负数时 $f(x) = -x$（对最小值 $-2^{w-1}$ 进行特殊处理）。\n\n在二进制补码中，取反操作通过按位非再加 $1$ 来执行。即 $-x \\equiv (\\lnot x) + 1 \\pmod{2^w}$。\n因此，我们的目标是计算：\n$$\ny = \\begin{cases}\nx,  \\text{if } x \\ge 0 \\\\\n(\\lnot x) + 1,  \\text{if } x  0\n\\end{cases}\n$$\n我们可以构造一个依赖于 $x$ 符号的掩码。$w$ 位二进制补码整数的符号由其最高有效位 (MSB)，即第 $w-1$ 位决定。如果第 $w-1$ 位是 $0$，则该数为非负数 ($x \\ge 0$)。如果第 $w-1$ 位是 $1$，则该数为负数 ($x  0$)。\n\n算术右移 (ARS) 操作非常适合创建这样的掩码。将 $x$ 进行 $k$ 位的算术右移，记作 $\\text{ARS}(x, k)$，会将 $x$ 的位向右移动 $k$ 个位置，并用原始最高有效位（符号位）的副本填充新空出的高位。\n\n让我们通过将 $x$ 算术右移 $w-1$ 位来定义一个掩码 $m$：\n$$\nm = \\text{ARS}(x, w-1)\n$$\n\n- 如果 $x \\ge 0$，其符号位为 $0$。算术右移操作会将 $m$ 的所有 $w$ 位都填充为 $0$。因此，$m$ 变为一个全零的字，表示整数 $0$。\n- 如果 $x  0$，其符号位为 $1$。算术右移操作会将 $m$ 的所有 $w$ 位都填充为 $1$。因此，$m$ 变为一个全一的字，在二进制补码中表示整数 $-1$。\n\n所以，我们得到了一个掩码 $m$，当 $x \\ge 0$ 时为 $0$，当 $x  0$ 时为 $-1$。让我们来研究表达式 $(x \\oplus m) - m$，其中 $\\oplus$ 表示按位异或。\n\n- **当 $x \\ge 0$ 时**：此时 $m=0$。表达式变为 $(x \\oplus 0) - 0$。由于 $x \\oplus 0 = x$，结果为 $x$。这是正确的结果。\n- **当 $x  0$ 时**：此时 $m=-1$（位模式为全一）。表达式变为 $(x \\oplus -1) - (-1)$。操作 $x \\oplus -1$ 等价于按位非 $\\lnot x$。表达式简化为 $(\\lnot x) - (-1)$，即 $(\\lnot x) + 1$。这是二进制补码中取反（即 $-x$）的公式。\n\n这表明了以下无分支算法：\n1. 根据 $x$ 的符号生成掩码 $m$：$m = \\text{ARS}(x, w-1)$。\n2. 计算结果：$y = (x \\oplus m) - m$。\n\n该算法看起来可以正确计算绝对值。下一步是提供一个严格的证明，包括指定的边界情况。\n\n### 步骤 2：正确性证明\n\n设 $x$ 是一个 $w$ 位二进制补码整数。该算法计算 $y = (x \\oplus m) - m$，其中 $m = \\text{ARS}(x, w-1)$。我们将针对 $\\operatorname{abs}_w(x)$ 函数定义中指定的三种情况证明其正确性。\n\n**情况 1：$x \\ge 0$**\n如果 $x \\ge 0$，其二进制补码表示的最高有效位 (MSB)（位于第 $w-1$ 位）等于 $0$。操作 $m = \\text{ARS}(x, w-1)$ 将 $x$ 右移 $w-1$ 位，同时复制符号位。由于符号位为 $0$，得到的 $w$ 位整数 $m$ 由全零组成。因此 $m$ 的整数值为 $0$。\n算法计算：\n$$y = (x \\oplus 0) - 0$$\n与 $0$ 的按位异或操作是恒等变换，所以 $x \\oplus 0 = x$。\n表达式简化为：\n$$y = x - 0 = x$$\n这与 $x \\ge 0$ 时要求的输出 $\\operatorname{abs}_w(x) = x$ 相符。\n\n**情况 2：$x  0$ 且 $x > -2^{w-1}$**\n如果 $x  0$，其 MSB 为 $1$。操作 $m = \\text{ARS}(x, w-1)$ 会将此符号位复制到结果的所有 $w$ 个位上。因此 $m$ 的位模式是 $11...1_2$。在 $w$ 位二进制补码中，此模式表示整数 $-1$。\n算法计算：\n$$y = (x \\oplus (-1)) - (-1)$$\n与 $-1$（全一）进行按位异或等价于按位非操作 $\\lnot$。所以，$x \\oplus (-1) = \\lnot x$。\n表达式变为：\n$$y = (\\lnot x) - (-1) = (\\lnot x) + 1$$\n根据二进制补码算术的性质，对于除最小值（$-2^{w-1}$）之外的任何值 $x$，其相反数 $-x$ 计算为 $(\\lnot x) + 1$。由于本情况明确排除了 $x = -2^{w-1}$，结果为 $y = -x$。\n这与 $x > -2^{w-1}$ 时要求的输出 $\\operatorname{abs}_w(x) = -x$ 相符。\n\n**情况 3：$x = -2^{w-1}$**\n这是一个唯一的边界情况，标准的取反公式 $-x = (\\lnot x) + 1$ 无法产生一个在可表示范围内的值（因为 $-(-2^{w-1}) = 2^{w-1}$，超出了范围）。我们必须在 $w$ 位回绕语义下，在位级别上分析算法的行为。\n$x = -2^{w-1}$ 的二进制补码表示是位模式 $100...0_2$。\nMSB 是 $1$，因此和情况 2 一样，掩码 $m = \\text{ARS}(x, w-1) = -1$（全一，即 $11...1_2$）。\n算法计算 $y = (x \\oplus m) - m = (\\lnot x) + 1$。\n让我们将位运算应用于 $x = -2^{w-1}$ 的模式：\n- $x = 100...0_2$\n- $\\lnot x = \\lnot(100...0_2) = 011...1_2$。此位模式表示整数 $2^{w-1}-1$。\n- $(\\lnot x) + 1$：我们将 $1$ 加到位模式 $011...1_2$ 上。\n$$\n\\begin{array}{@{}c@{\\,}c@{}l}\n   011...11  \\\\\n+  000...01  \\\\\n\\hline\n   100...00 \n\\end{array}\n$$\n得到的位模式是 $100...0_2$。这与原始输入 $x = -2^{w-1}$ 的位模式完全相同。因此，计算的整数结果是 $y = -2^{w-1}$。\n这与 $x = -2^{w-1}$ 时要求的输出 $\\operatorname{abs}_w(x) = -2^{w-1}$ 相符。由于定宽整数算术的回绕特性，该算法正确地处理了这一边界情况。\n\n证明完毕。根据指定的 $\\operatorname{abs}_w(x)$ 函数，算法 $y = (x \\oplus \\text{ARS}(x, w-1)) - \\text{ARS}(x, w-1)$ 对于所有 $w$ 位二进制补码整数都是正确的。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```", "id": "3623138"}, {"introduction": "进入数据编码领域，本练习要求你从格雷码的定义出发，反向推导出其转换公式。你将需要设计并实现一个算法，将格雷码值转换回标准的二进制表示。这个过程 ([@problem_id:3623153]) 完美地展示了如何通过一系列的移位和异或（XOR）操作，解决一个看似复杂的逻辑难题。", "problem": "给定一个 $w$ 位寄存器，其中存储着一个二进制反射格雷码 (BRGC) 值 $g$。目标是推导、证明并实现一个算法，该算法仅使用无符号整数上的按位异或运算符 $\\oplus$ 和逻辑右移运算符 $\\gg$ 将 $g$ 转换为其对应的二进制值 $b$。推导过程必须从按位运算和 BRGC 编码的定义及基本性质出发，不得假设或陈述任何快捷转换公式。您还必须证明该算法对于任何有限的字长 $w$ 都会终止。\n\n使用的基本原理：\n- 按位异或：对于位向量 $x$ 和 $y$，$z = x \\oplus y$ 定义为对每个比特位 $i$ 都有 $z_i = x_i \\oplus y_i$，其中右侧的 $\\oplus$ 是单位比特上的异或。\n- 逻辑右移：对于一个无符号 $w$ 位值 $x$，$x \\gg k$ 将所有比特向右移动 $k$ 个位置，空出的高位用 $0$ 填充，即对于从最低有效位 $i = 0$ 到最高有效位 $i = w-1$ 索引的比特位，有 $(x \\gg k)_i = x_{i+k}$。当 $k \\geq w$ 时，有 $x \\gg k = 0$。\n- 二进制反射格雷码编码：对于一个 $w$ 位二进制数 $b$，其 BRGC 值 $g$ 定义为 $g = b \\oplus (b \\gg 1)$。\n\n任务：\n1. 从上述定义出发，推导一个仅使用无符号整数上的 $\\oplus$ 和 $\\gg$ 运算符从 $g$ 计算 $b$ 的算法。您的推导必须说明该算法是什么，为什么它是正确的，以及它如何从基本定义中得出。您必须正式论证该算法对于任何有限的 $w$ 位寄存器都会终止。\n2. 使用 C 语言标准 $C23$ 和无符号算术，将该算法实现为一个完整的、可运行的程序。实现必须通过与一个 $w$ 位全为 1 的掩码进行位掩蔽，将所有中间值和最终值限制在 $w$ 位内。\n3. 使用以下测试套件。每个测试用例是一个序对 $(w, g)$，其中 $w$ 是以比特为单位的字长，$g$ 是要解码的 $w$ 位 BRGC 值。该测试套件必须硬编码在程序中：\n   - $(w = 4, g = 0)$\n   - $(w = 4, g = 15)$\n   - $(w = 4, g = 12)$\n   - $(w = 8, g = 91)$\n   - $(w = 8, g = 128)$\n   - $(w = 1, g = 1)$\n   - $(w = 16, g = 0)$\n   - $(w = 32, g = 0x\\text{B1FB6198})$\n4. 对于每个测试用例，计算解码后的二进制值 $b$ 作为一个非负整数。不涉及物理单位。最终的程序输出必须是单一行，包含所有测试用例的解码结果，聚合为一个用方括号括起来的逗号分隔列表，其中每个 $b$ 均为十进制表示（例如 $[b_1,b_2,\\dots,b_n]$）。\n\n您的程序必须严格按照指定格式生成一行输出，不得有任何其他内容。", "solution": "本问题要求推导、证明并实现一个算法，用于将二进制反射格雷码 (BRGC) 值 $g$ 转换为其对应的标准二进制值 $b$。推导过程必须从第一性原理出发，并且仅使用按位异或 ($\\oplus$) 和逻辑右移 ($\\gg$) 运算符。\n\n**问题有效性评估**\n\n**步骤1：提取的已知条件**\n- **数据与变量**：一个 $w$ 位寄存器、一个 BRGC 值 $g$、一个二进制值 $b$。\n- **运算符**：按位异或 ($\\oplus$) 和逻辑右移 ($\\gg$)。\n- **定义**：\n    - $z = x \\oplus y$ 定义为对每个比特位 $i$ 都有 $z_i = x_i \\oplus y_i$。\n    - 对于从 LSB（$i=0$）到 MSB（$i=w-1$）索引的比特位，$(x \\gg k)_i = x_{i+k}$（$i=0, \\dots, w-1-k$），而其他比特位 $(x \\gg k)_i = 0$。\n    - BRGC 编码由关系式 $g = b \\oplus (b \\gg 1)$ 定义。\n- **约束条件**：\n    - 推导必须从所提供的定义开始。\n    - 算法必须只在无符号整数上使用 $\\oplus$ 和 $\\gg$ 运算符。\n    - 实现必须使用 C23 标准，采用硬编码的测试套件，并将值限制在 $w$ 位内。\n    - 输出格式必须为单一行：一个用方括号括起来的、以十进制表示的逗号分隔结果列表。\n\n**步骤2：使用提取的已知条件进行验证**\n根据指定标准对问题进行评估。\n- **科学依据**：该问题基于数字逻辑和计算机科学中的基本概念——二进制反射格雷码和按位运算的标准、公认定义。其前提在事实上是正确的。\n- **良态问题**：问题是良态的。编码函数 $f(b) = b \\oplus (b \\gg 1)$ 在 $w$ 位整数集合上是可逆的，因此对于任何给定的 $g$，都存在一个唯一的 $b$。问题要求在特定的运算约束下推导并实现其逆函数。\n- **客观性**：问题使用精确、形式化的数学语言陈述，没有歧义或主观性。\n\n该问题没有科学上不健全、信息缺失、矛盾或不可行等缺陷。它是计算机体系结构和离散数学领域内一个形式化的、可验证的问题。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 转换算法的推导\n\n设 $w$ 位值 $b$ 和 $g$ 的比特位从 $0$（最低有效位, LSB）索引到 $w-1$（最高有效位, MSB）。定义关系为 $g = b \\oplus (b \\gg 1)$。我们逐位分析这个关系。\n\n逻辑右移的定义意味着 $(b \\gg 1)$ 的第 $i$ 位，表示为 $(b \\gg 1)_i$，对于 $i  w-1$ 等于 $b_{i+1}$，而 $(b \\gg 1)_{w-1} = 0$。\n\n因此，编码的按位定义为：\n$$g_i = b_i \\oplus b_{i+1} \\quad \\text{for } 0 \\leq i  w-1$$\n$$g_{w-1} = b_{w-1} \\oplus (b \\gg 1)_{w-1} = b_{w-1} \\oplus 0 = b_{w-1}$$\n\n第二个方程直接给出了二进制值最高有效位的计算方法：\n$$b_{w-1} = g_{w-1}$$\n二进制数的最高有效位与其格雷码表示的最高有效位相同。\n\n现在，我们可以从最高有效位开始，向最低有效位迭代地确定 $b$ 的其他比特位。对于从 $w-2$ 到 $0$ 的任何比特位 $i$，我们可以通过应用性质 $x \\oplus x = 0$ 来重排关系 $g_i = b_i \\oplus b_{i+1}$：\n$$g_i \\oplus b_{i+1} = (b_i \\oplus b_{i+1}) \\oplus b_{i+1} = b_i \\oplus (b_{i+1} \\oplus b_{i+1}) = b_i \\oplus 0 = b_i$$\n这为我们提供了 $b$ 的比特位的递推关系：\n$$b_i = g_i \\oplus b_{i+1} \\quad \\text{for } i = w-2, w-3, \\dots, 0$$\n\n我们展开这个递推关系：\n- 对于 $i=w-2$：$b_{w-2} = g_{w-2} \\oplus b_{w-1}$。因为 $b_{w-1} = g_{w-1}$，所以 $b_{w-2} = g_{w-2} \\oplus g_{w-1}$。\n- 对于 $i=w-3$：$b_{w-3} = g_{w-3} \\oplus b_{w-2}$。代入 $b_{w-2}$ 的表达式，我们得到 $b_{w-3} = g_{w-3} \\oplus (g_{w-2} \\oplus g_{w-1})$。\n- 通过继续这种代换，我们可以建立一个通用公式，将 $b_i$ 表示为从位置 $i$ 到最高有效位的所有格雷码比特位的异或和：\n$$b_i = \\bigoplus_{j=i}^{w-1} g_j$$\n这个公式能从 $g$ 的各位比特正确计算出 $b$ 的每一位比特。然而，这并不是一个直接作用于整数寄存器上的算法。我们寻求一种能对整个 $w$ 位值 $g$ 进行操作的算法。\n\n让我们从整数关系 $g = b \\oplus (b \\gg 1)$ 出发，提出另一种推导方法。\n我们可以用 $g$ 和它自身的一个移位版本来表示 $b$：$b = g \\oplus (b \\gg 1)$。\n我们可以将这个 $b$ 的表达式代入右侧：\n$$b = g \\oplus \\big( (g \\oplus (b \\gg 1)) \\gg 1 \\big) = g \\oplus (g \\gg 1) \\oplus (b \\gg 2)$$\n对新的项 $b \\gg 2$ 重复此代换：\n$$b = g \\oplus (g \\gg 1) \\oplus \\big( (g \\oplus (b \\gg 1)) \\gg 2 \\big) = g \\oplus (g \\gg 1) \\oplus (g \\gg 2) \\oplus (b \\gg 3)$$\n通过反复代换，我们生成一个级数。经过 $k$ 次代换后，我们得到：\n$$b = \\left(\\bigoplus_{i=0}^{k} (g \\gg i)\\right) \\oplus (b \\gg (k+1))$$\n对于一个 $w$ 位字，任何大于等于 $w$ 的移位都会得到零，即当 $k \\geq w$ 时 $b \\gg k = 0$。如果我们将展开进行 $w-1$ 步，我们得到：\n$$b = \\left(\\bigoplus_{i=0}^{w-1} (g \\gg i)\\right) \\oplus (b \\gg w) = \\left(\\bigoplus_{i=0}^{w-1} (g \\gg i)\\right) \\oplus 0$$\n因此，二进制值 $b$ 可以表示为格雷码值 $g$ 的一系列移位版本的异或和：\n$$b = g \\oplus (g \\gg 1) \\oplus (g \\gg 2) \\oplus \\dots \\oplus (g \\gg (w-1))$$\n\n这个公式可以用一个简单的循环来实现。然而，可以推导出一个更高效、可并行的算法。考虑以下迭代过程：\n1. 初始化 $b \\leftarrow g$。\n2. 对于 $k = 1, 2, 4, 8, \\dots$，只要 $k  w$：\n   更新 $b \\leftarrow b \\oplus (b \\gg k)$。\n\n我们来追踪这个改进后的算法。设 $b^{(m)}$ 是第 $m$ 次迭代后 $b$ 的值，其中移位量为 $2^{m-1}$。\n- 初始化：$b^{(0)} = g$。\n- 迭代 1 ($k=1=2^0$)：\n  $b^{(1)} = b^{(0)} \\oplus (b^{(0)} \\gg 1) = g \\oplus (g \\gg 1)$。\n- 迭代 2 ($k=2=2^1$)：\n  $b^{(2)} = b^{(1)} \\oplus (b^{(1)} \\gg 2) = (g \\oplus (g \\gg 1)) \\oplus ((g \\oplus (g \\gg 1)) \\gg 2) = g \\oplus (g \\gg 1) \\oplus (g \\gg 2) \\oplus (g \\gg 3)$。\n- 迭代 3 ($k=4=2^2$)：\n  $b^{(3)} = b^{(2)} \\oplus (b^{(2)} \\gg 4) = (g \\oplus \\dots \\oplus (g \\gg 3)) \\oplus ((g \\oplus \\dots \\oplus (g \\gg 3)) \\gg 4) = g \\oplus \\dots \\oplus (g \\gg 7)$。\n\n经过 $m$ 次迭代（移位量为 $1, 2, \\dots, 2^{m-1}$），$b$ 的值为 $b^{(m)} = \\bigoplus_{i=0}^{2^m - 1} (g \\gg i)$。我们继续这个过程，直到下一个移位量 $k$ 大于或等于 $w$。此时，和 $b = \\bigoplus_{i=0}^{w-1} (g \\gg i)$ 中的所有必需项都已累加完毕，因为任何后续的移位 $(g \\gg i)$（对于 $i \\geq w$）均为零。这证实了该迭代算法的正确性。\n\n### 算法终止性论证\n所提出的算法如下：\n```\nb = g\nshift = 1\nwhile (shift  w) {\n    b = b ^ (b >> shift)\n    shift = shift * 2\n}\n```\n对于任何有限的字长 $w \\geq 1$：\n1. 循环控制变量 `shift` 初始化为 $1$。\n2. `shift` 的值序列为 $1, 2, 4, 8, \\dots, 2^k, \\dots$。这是一个严格递增的正整数序列。\n3. 当 `shift` 不再小于 $w$ 时，循环终止。由于 $w$ 是一个有限正数，而 `shift` 呈指数级增长，`shift` 保证最终会变得大于或等于 $w$。\n4. 迭代次数为 $\\lceil \\log_2 w \\rceil$（如果 $w=1$ 则为 $0$），对于任何有限的 $w$ 这都是一个有限的数。\n因此，可以保证该算法对于任何有限字长 $w$ 都会终止。\n\n### 最终算法\n对于一个 $w$ 位字，从 $g$ 计算 $b$ 的最终高效算法如下：\n1. 用 `g` 的值初始化一个无符号整数 `b`。\n2. 初始化一个整数 `shift` 为 $1$。\n3. 当 `shift  w` 时循环：\n   a. 将 `b` 更新为 `b` 与 `b` 右移 `shift` 位后的值进行异或运算的结果：$b \\leftarrow b \\oplus (b \\gg \\text{shift})$。\n   b. 将移位量加倍：$\\text{shift} \\leftarrow \\text{shift} \\times 2$。\n4. 循环终止后，如果 $w$ 小于所用无符号整数类型的原生字长，则对 `b` 应用一个掩码以清除任何多余的高位比特。该掩码由 $w$ 个 1 组成，可以计算为 $(1 \\ll w) - 1$（需注意 $w=$字长 的情况）。`b` 的最终值即为所需的二进制表示。", "answer": "```c\n#include\n```", "id": "3623153"}]}