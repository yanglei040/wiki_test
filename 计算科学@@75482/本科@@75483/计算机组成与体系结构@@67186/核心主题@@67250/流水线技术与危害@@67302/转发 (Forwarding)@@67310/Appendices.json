{"hands_on_practices": [{"introduction": "理解转发技术最直观的方法是亲眼见证其效果。本练习将引导你在两种不同的处理器（一种有转发，一种没有）上追踪同一段代码的执行过程。通过逐周期地调度指令，你将能够量化性能增益，并深入理解为何以及何时能够通过转发来消除停顿。[@problem_id:3643888]", "problem": "一个具有按序发射功能的五级流水线处理器按顺序执行 $\\mathrm{IF}$、$\\mathrm{ID}$、$\\mathrm{EX}$、$\\mathrm{MEM}$ 和 $\\mathrm{WB}$ 阶段，每个周期一个阶段。寄存器文件写入发生在 $\\mathrm{WB}$ 周期的前半部分，寄存器文件读取发生在 $\\mathrm{ID}$ 周期的后半部分。只有一个 $\\mathrm{EX}$ 单元，因此在任何给定周期内，最多只有一条指令可以占用 $\\mathrm{EX}$。考虑以下程序片段，其中 $\\mathrm{add}$ 和 $\\mathrm{sub}$ 是在 $\\mathrm{EX}$ 阶段产生结果的整数算术运算，$\\mathrm{lw}$ 是加载指令，它在 $\\mathrm{EX}$ 阶段计算有效地址，在 $\\mathrm{MEM}$ 阶段读取内存，并在 $\\mathrm{WB}$ 阶段写回加载的值：\n$I_1$: $\\mathrm{add}\\ r_1,\\ r_2,\\ r_3$ \n$I_2$: $\\mathrm{sub}\\ r_4,\\ r_1,\\ r_5$\n$I_3$: $\\mathrm{lw}\\ r_6,\\ 0(r_1)$\n$I_4$: $\\mathrm{add}\\ r_7,\\ r_6,\\ r_8$\n$I_5$: $\\mathrm{add}\\ r_1,\\ r_7,\\ r_9$\n$I_6$: $\\mathrm{add}\\ r_{10},\\ r_1,\\ r_{11}$\n$I_7$: $\\mathrm{lw}\\ r_{12},\\ 8(r_{10})$\n$I_8$: $\\mathrm{add}\\ r_{13},\\ r_{12},\\ r_{14}$\n假设有两种机器变体：\n- 变体 $\\mathcal{F}$ 具有完全转发（旁路）功能，从 $\\mathrm{EX}/\\mathrm{MEM}$ 和 $\\mathrm{MEM}/\\mathrm{WB}$ 流水线寄存器转发到 $\\mathrm{ID}/\\mathrm{EX}$ 阶段的输入端。\n- 变体 $\\mathcal{N}$ 没有转发功能；消费者指令只能通过读取寄存器文件来获取生成的值。\n\n将指令交互建模为一个有向无环图，其顶点是指令 $\\{I_1,\\dots,I_8\\}$，其边是真数据相关（$\\mathrm{RAW}$），并带有由阶段时序和是否可用转发决定的流水线距离约束。在此模型下，通过一个“尽快”拓扑调度来定义指令 $I_i$ 可以开始 $\\mathrm{EX}$ 的最早可能周期，记为 $E_i$。该调度强制执行以下约束：\n- 按程序顺序的按序发射（每条指令 $I_i$ 开始 $\\mathrm{EX}$ 的时间不得早于 $I_{i-1}$ 开始 $\\mathrm{EX}$ 之后的一个周期），\n- 基线流水线流程（在没有冒险的情况下，$I_i$ 将在周期 $i+2$ 开始 $\\mathrm{EX}$），\n- 流水线所隐含的数据相关边约束（根据给定的阶段语义推导这些约束；不要假设除阶段时序之外的任何公式）。\n\n分别计算变体 $\\mathcal{F}$ 和 $\\mathcal{N}$ 的序列 $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ 和 $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$，然后计算标量差 $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$。以单个实数的形式提供 $\\Delta$ 的值。无需四舍五入。", "solution": "该问题要求我们为给定的8条指令序列，在两种不同的流水线配置（有转发 $\\mathcal{F}$ 和无转发 $\\mathcal{N}$）下，计算每条指令 $I_i$ 开始执行（EX）阶段的最早周期 $E_i$。然后计算两种配置下最后一条指令的EX开始周期的差值 $\\Delta = E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$。\n\n我们遵循“尽快”（ASAP）调度原则，每条指令 $I_i$ 的EX开始周期 $E_i$ 由以下递推关系确定：\n$E_i = \\max(E_{i-1} + 1, \\text{数据相关约束})$\n其中 $E_0 = 2$。基线情况下（无冒险），$I_i$ 在周期 $i+2$ 开始EX。\n\n**数据相关性分析:**\n*   $I_2$ 依赖 $I_1$ ($r_1$)\n*   $I_3$ 依赖 $I_1$ ($r_1$)\n*   $I_4$ 依赖 $I_3$ ($r_6$, load-use)\n*   $I_5$ 依赖 $I_4$ ($r_7$)\n*   $I_6$ 依赖 $I_5$ ($r_1$)\n*   $I_7$ 依赖 $I_6$ ($r_{10}$)\n*   $I_8$ 依赖 $I_7$ ($r_{12}$, load-use)\n\n---\n\n**变体 $\\mathcal{N}$ (无转发)**\n\n在无转发的机器中，指令必须等待其依赖的数据被写入寄存器堆（WB阶段完成）后，才能在自己的ID阶段读取。\n- 算术指令 (add, sub) 在EX阶段产生结果，在WB阶段写入。如果EX在周期 $c$，WB在 $c+2$。\n- 加载指令 (lw) 在MEM阶段产生结果，在WB阶段写入。如果EX在周期 $c$，MEM在 $c+1$，WB在 $c+2$。\n消费者指令可以在生产者指令的WB周期读取寄存器堆。因此，如果生产者 $I_k$ 的WB在周期 $W_k$，消费者 $I_i$ 的ID最早可以在周期 $W_k$ 进行，其EX最早可以在 $W_k+1$ 开始。而 $W_k = E_k + 2$。所以 $E_i \\ge E_k + 3$。\n\n*   $E_1 = 1+2 = 3$\n*   $E_2$: 依赖 $I_1$。$E_2 \\ge E_1 + 3 = 6$。$E_2 = \\max(E_1+1, 6) = \\max(4, 6) = 6$。\n*   $E_3$: 依赖 $I_1$。$E_3 \\ge E_1 + 3 = 6$。$E_3 = \\max(E_2+1, 6) = \\max(7, 6) = 7$。\n*   $E_4$: 依赖 $I_3$ (lw)。$E_4 \\ge E_3 + 3 = 10$。$E_4 = \\max(E_3+1, 10) = \\max(8, 10) = 10$。\n*   $E_5$: 依赖 $I_4$。$E_5 \\ge E_4 + 3 = 13$。$E_5 = \\max(E_4+1, 13) = \\max(11, 13) = 13$。\n*   $E_6$: 依赖 $I_5$。$E_6 \\ge E_5 + 3 = 16$。$E_6 = \\max(E_5+1, 16) = \\max(14, 16) = 16$。\n*   $E_7$: 依赖 $I_6$。$E_7 \\ge E_6 + 3 = 19$。$E_7 = \\max(E_6+1, 19) = \\max(17, 19) = 19$。\n*   $E_8$: 依赖 $I_7$ (lw)。$E_8 \\ge E_7 + 3 = 22$。$E_8 = \\max(E_7+1, 22) = \\max(20, 22) = 22$。\n\n因此，$E_8^{\\mathcal{N}} = 22$。序列为 $\\{3, 6, 7, 10, 13, 16, 19, 22\\}$。\n\n---\n\n**变体 $\\mathcal{F}$ (有转发)**\n\n有转发时，结果可以从EX/MEM或MEM/WB寄存器直接送到EX阶段。\n- ALU -> ALU 依赖 (如 $I_2$ 依赖 $I_1$)：EX/MEM -> EX 转发，无停顿。$E_i \\ge E_k + 1$。\n- Load -> use 依赖 (如 $I_4$ 依赖 $I_3$)：结果在MEM阶段末尾可用。消费者需要停顿1个周期。可以从MEM/WB -> EX 转发。$E_i \\ge E_k + 2$。\n\n*   $E_1 = 3$\n*   $E_2$: 依赖 $I_1$ (ALU)。无停顿。$E_2 = \\max(E_1+1) = \\max(4) = 4$。\n*   $E_3$: 依赖 $I_1$ (ALU)。无停顿。$E_3 = \\max(E_2+1) = \\max(5) = 5$。\n*   $E_4$: 依赖 $I_3$ (load-use)。1周期停顿。$E_4 \\ge E_3 + 2 = 7$。$E_4 = \\max(E_3+1, 7) = \\max(6, 7) = 7$。\n*   $E_5$: 依赖 $I_4$ (ALU)。无停顿。$E_5 \\ge E_4 + 1 = 8$。$E_5 = \\max(E_4+1, 8) = \\max(8, 8) = 8$。\n*   $E_6$: 依赖 $I_5$ (ALU)。无停顿。$E_6 \\ge E_5 + 1 = 9$。$E_6 = \\max(E_5+1, 9) = \\max(9, 9) = 9$。\n*   $E_7$: 依赖 $I_6$ (ALU)。无停顿。$E_7 \\ge E_6 + 1 = 10$。$E_7 = \\max(E_6+1, 10) = \\max(10, 10) = 10$。\n*   $E_8$: 依赖 $I_7$ (load-use)。1周期停顿。$E_8 \\ge E_7 + 2 = 12$。$E_8 = \\max(E_7+1, 12) = \\max(11, 12) = 12$。\n\n因此，$E_8^{\\mathcal{F}} = 12$。序列为 $\\{3, 4, 5, 7, 8, 9, 10, 12\\}$。\n\n---\n\n**计算差值**\n\n$\\Delta = E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}} = 22 - 12 = 10$。", "answer": "$$\\boxed{10}$$", "id": "3643888"}, {"introduction": "虽然转发功能强大，但它并不能解决所有的读后写（RAW）数据冒险。一个经典的例外是“加载-使用”冒险，即一条指令需要的数据来自于一条仍在访存（MEM）阶段的加载（load）指令。本练习要求你设计出能检测此特定情况并插入停顿周期的硬件逻辑，从而保证流水线的正确性，并将流水线停顿的高级概念与具体的硬件实现联系起来。[@problem_id:3643923]", "problem": "一个标量、顺序执行的五级流水线实现以下阶段：指令提取（$\\mathrm{IF}$）、指令解码与寄存器读取（$\\mathrm{ID}$）、执行（$\\mathrm{EX}$）、访存（$\\mathrm{MEM}$）和写回（$\\mathrm{WB}$）。寄存器堆在 $\\mathrm{ID}$ 阶段读取，在 $\\mathrm{WB}$ 阶段写入。该机器将 $\\mathrm{EX}/\\mathrm{MEM}$ 和 $\\mathrm{MEM}/\\mathrm{WB}$ 边界处流水线寄存器中的结果转发到为 $\\mathrm{EX}$ 阶段提供输入的操作数多路选择器。$\\mathrm{MEM}$ 阶段的访存是单周期的理想缓存访问，因此加载指令在 $\\mathrm{MEM}$ 阶段结束时产生其数据。不存在结构冒险。指令集架构提供寄存器-寄存器算术指令、加载指令、存储指令和条件分支指令。分支在 $\\mathrm{EX}$ 阶段解析，并且是完美预测的，因此没有控制停顿。\n\n您将提出一个最小化的冒险检测器，该检测器仅在加载-使用冒险时产生停顿，论证为什么转发加上该检测器能确保此流水线中所有写后读数据冒险的正确性，然后在一个指定的合成工作负载上量化每指令周期数（CPI）。\n\n假设和术语：\n- 流水线寄存器表示为 $R_{\\mathrm{IF/ID}}$、$R_{\\mathrm{ID/EX}}$、$R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$。\n- 对于位于流水线寄存器 $R$ 中的任何指令 $I$，字段 $R.\\mathrm{rs}$ 和 $R.\\mathrm{rt}$ 表示在 $\\mathrm{ID}$ 阶段读取的第一个和第二个源寄存器的标识符（如果适用），$R.\\mathrm{dest}$ 表示在 $\\mathrm{WB}$ 阶段写入的目标寄存器（如果适用）。仅当 $I$ 是加载指令时，控制位 $R.\\mathrm{MemRead}$ 才被置位。\n- 索引为 $0$ 的寄存器硬连接为零，并且永远不会被写入；对寄存器 $0$ 的比较应在您的逻辑中处理，以避免伪相关导致停顿。\n- 当在周期 $t$ 请求停顿时，程序计数器和 $R_{\\mathrm{IF/ID}}$ 被保持，一个气泡（$\\mathrm{NOP}$）在周期 $t+1$ 被注入到 $R_{\\mathrm{ID/EX}}$ 中。\n\n任务：\n1) 根据前面的定义和五级流水线的语义，推导出一个作用于 $R_{\\mathrm{IF/ID}}$ 和 $R_{\\mathrm{ID/EX}}$ 字段的最小组合谓词 $H$。当且仅当必须插入一个单周期的停顿以避免在下一周期的 $\\mathrm{EX}$ 阶段发生写后读时序违规时，$H$ 为真。使用等式、逻辑合取、析取和否定对命名字段以符号形式表示 $H$。\n\n2) 仅使用上述流水线时序假设以及存在从 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$ 到 $\\mathrm{EX}$ 操作数输入的转发，论证以 $H$ 作为唯一的停顿来源，所有写后读数据冒险都得到了正确处理。您的论证应考虑生产者指令是算术指令（在 $\\mathrm{EX}$ 阶段结束时产生结果）和加载指令（在 $\\mathrm{MEM}$ 阶段结束时产生结果），并应解释为什么除了 $H$ 发出的信号之外，不需要其他停顿。\n\n3) 考虑一个长的合成指令流，其中静态指令混合为：算术指令比例 $f_{\\mathrm{A}} = 0.44$，加载指令比例 $f_{\\mathrm{L}} = 0.28$，存储指令比例 $f_{\\mathrm{S}} = 0.18$，分支指令比例 $f_{\\mathrm{B}} = 0.10$。假设以下数据相关性的独立性模型：在位置 $i$ 的指令是写入非零寄存器的加载指令的条件下，位置 $i+1$ 的指令以概率 $p = 0.35$ 将该目标寄存器作为其源寄存器之一进行读取，并且此事件与其他一切无关。如果发生这种情况，就构成了您在 $H$ 中定义的加载-使用情况；否则则不构成。没有其他停顿来源。\n\n基于第 1 部分和第 2 部分中的最小停顿策略，计算该流水线在此工作负载下的预期稳态 $\\mathrm{CPI}$。将您的答案四舍五入到四位有效数字。仅给出一个无单位的数值。", "solution": "该问题提出了一个经典的五级流水线处理器模型，并要求推导冒险检测逻辑、论证其正确性，并以每指令周期数（$\\mathrm{CPI}$）为单位进行性能计算。该问题定义明确、内部一致，并基于计算机体系结构的基本原理。将按要求分三部分进行解答。\n\n### 1. 冒险检测谓词 $H$ 的推导\n\n当后续指令需要某个指令的结果但该结果尚不可用，且转发硬件无法提供该数据时，就会发生需要停顿的数据冒险。我们必须识别出发生这种情况的特定时序情况。\n\n流水线具有从 $\\mathrm{EX}$ 和 $\\mathrm{MEM}$ 阶段的输出寄存器（即 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$）到 $\\mathrm{EX}$ 阶段输入的转发功能。\n- 算术指令在 $\\mathrm{EX}$ 阶段计算其结果。此结果在 $\\mathrm{EX}$ 阶段结束时在 $R_{\\mathrm{EX/MEM}}$ 中可用，可以及时转发给进入其 $\\mathrm{EX}$ 阶段的下一条指令。\n- 加载指令在 $\\mathrm{MEM}$ 阶段从内存中提取数据。此数据仅在 $\\mathrm{MEM}$ 阶段结束时在 $R_{\\mathrm{MEM/WB}}$ 中可用。\n\n让我们考虑一条加载指令 $I_1$，紧跟着一条使用所加载数据的指令 $I_2$。\n- 在周期 $t$，假设 $I_1$ 处于 $\\mathrm{EX}$ 阶段，$I_2$ 处于 $\\mathrm{ID}$ 阶段。$\\mathrm{ID}$ 阶段的硬件必须决定是停顿还是继续。\n- 如果流水线不停顿，那么在周期 $t+1$，$I_1$ 进入 $\\mathrm{MEM}$ 阶段，$I_2$ 进入 $\\mathrm{EX}$ 阶段。\n- $I_2$ 在其 $\\mathrm{EX}$ 阶段的开始（即周期 $t+1$ 的开始）需要其源操作数。\n- 然而，$I_1$ 要到其 $\\mathrm{MEM}$ 阶段的结束（即周期 $t+1$ 的结束）才能从内存中获得其数据。\n- 因此，数据在 $I_2$ 的 $\\mathrm{EX}$ 阶段开始时不可用。来自 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$ 的转发路径没有帮助，因为所需数据尚未锁存到这两个寄存器中的任何一个。这是一个加载-使用写后读（RAW）冒险。\n\n为了解决这个问题，必须进行一个周期的停顿。当在周期 $t$ 检测到冒险时，一个气泡被注入到周期 $t+1$ 的 $\\mathrm{EX}$ 阶段，而指令 $I_2$ 则被保持在 $\\mathrm{ID}$ 阶段。\n- 周期 $t$：$I_1$ 在 $\\mathrm{EX}$ 阶段，$I_2$ 在 $\\mathrm{ID}$ 阶段。检测到冒险。\n- 周期 $t+1$：$I_1$ 进入 $\\mathrm{MEM}$ 阶段。$I_2$ 保持在 $\\mathrm{ID}$ 阶段。一个 $\\mathrm{NOP}$（气泡）进入 $\\mathrm{EX}$ 阶段。\n- 周期 $t+2$：$I_1$ 进入 $\\mathrm{WB}$ 阶段。$I_2$ 进入 $\\mathrm{EX}$ 阶段。在这个周期开始时，加载的结果位于流水线寄存器 $R_{\\mathrm{MEM/WB}}$ 中。来自 $R_{\\mathrm{MEM/WB}}$ 的转发路径现在可以正确地为 $I_2$ 向 $\\mathrm{EX}$ 阶段提供操作数。\n\n冒险检测逻辑必须识别出这种精确的场景。该逻辑位于 $\\mathrm{ID}$ 阶段，并对代表 $\\mathrm{EX}$ 阶段指令（$R_{\\mathrm{ID/EX}}$）和 $\\mathrm{ID}$ 阶段指令（$R_{\\mathrm{IF/ID}}$）的流水线寄存器的内容进行操作。当且仅当满足以下所有条件时，用于停顿的谓词 $H$ 为真：\n1. $\\mathrm{EX}$ 阶段的指令是加载指令。如果其 `MemRead` 控制信号被置位，即 $R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}$，则为真。\n2. 加载指令的目标寄存器是 $\\mathrm{ID}$ 阶段指令的源寄存器之一。如果 $(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt})$，则为真。\n3. 相关性不是针对硬连接的零寄存器，该寄存器可以被读取但永远不会被写入。这意味着加载指令的目标寄存器不能是寄存器 $0$：$R_{\\mathrm{ID/EX}}.\\mathrm{dest} \\neq 0$，可以表示为 $\\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0)$。\n\n结合这些条件，最小组合谓词 $H$ 是：\n$$H = (R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}) \\land \\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0) \\land ((R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt}))$$\n\n### 2. 正确性论证\n\n我们必须证明，指定的转发路径和停顿逻辑 $H$ 的组合能正确解决所有可能的写后读（RAW）数据冒险。我们可以根据生产者指令的类型和到消费者指令的距离来对冒险进行分类。\n\n**情况 A：生产者是算术指令。**\n结果在 $\\mathrm{EX}$ 阶段结束时在 $R_{\\mathrm{EX/MEM}}$ 寄存器中可用。\n- **消费者是下一条指令（$i+1$）：** 当消费者指令处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{MEM}$ 阶段。生产者的结果位于 $R_{\\mathrm{EX/MEM}}$ 中，可以转发到消费者的 $\\mathrm{EX}$ 阶段输入。不需要停顿。\n- **消费者是指令 $i+2$：** 当消费者处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{WB}$ 阶段。生产者的结果位于 $R_{\\mathrm{MEM/WB}}$ 中，可以转发到消费者的 $\\mathrm{EX}$ 阶段输入。不需要停顿。\n- **消费者是指令 $i+3$ 或更后：** 生产者已过其 $\\mathrm{WB}$ 阶段。结果已写入寄存器堆。消费者在其 $\\mathrm{ID}$ 阶段从寄存器堆中读取正确的值（由于寄存器堆的先写后读语义，其中 $\\mathrm{WB}$ 的写半周期在 $\\mathrm{ID}$ 的读半周期之前）。不需要停顿。\n情况 A 的结论：所有来自算术指令的 RAW 冒险都由转发逻辑解决，无需停顿。\n\n**情况 B：生产者是加载指令。**\n结果在 $\\mathrm{MEM}$ 阶段结束时在 $R_{\\mathrm{MEM/WB}}$ 寄存器中可用。\n- **消费者是下一条指令（$i+1$）：** 这是第 1 部分中详述的加载-使用冒险。消费者在其 $\\mathrm{EX}$ 阶段开始时需要结果，但生产者仅在其 $\\mathrm{MEM}$ 阶段结束时才提供结果。转发无法及时进行。谓词 $H$ 专门设计用于检测这种情况（$\\mathrm{EX}$ 阶段的加载指令，$\\mathrm{ID}$ 阶段相关的消费者指令），并正确触发一个周期的停顿。停顿后，该相关性等同于“在 i+2 处的加载-使用”情况，该情况由转发处理。\n- **消费者是指令 $i+2$：** 当消费者处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{WB}$ 阶段。加载的数据位于 $R_{\\mathrm{MEM/WB}}$ 中，可以转发到消费者的 $\\mathrm{EX}$ 阶段输入。谓词 $H$ 不会触发，因为 $\\mathrm{EX}$ 阶段的指令（指令 $i+1$）不是生产者加载指令。没有停顿是正确的。\n- **消费者是指令 $i+3$ 或更后：** 结果已写入寄存器堆，并由消费者直接读取。不需要停顿。\n情况 B 的结论：唯一涉及加载指令且未通过转发解决的 RAW 冒险是紧随其后的加载-使用情况。这种情况由 $H$ 检测并通过一个周期的停顿解决。所有其他情况都由转发或正常的寄存器堆操作处理。\n\n由于所有可能源自算术指令和加载指令的 RAW 冒险都由转发硬件或最小停顿逻辑 $H$ 正确处理，因此该流水线的数据冒险处理是正确的。\n\n### 3. CPI 计算\n\n每指令周期数（$\\mathrm{CPI}$）是总时钟周期数除以总指令数。在没有冒险的理想流水线中，$\\mathrm{CPI}$ 为 $1$。停顿会增加 $\\mathrm{CPI}$。$\\mathrm{CPI}$ 的公式为：\n$$ \\mathrm{CPI} = \\mathrm{CPI}_{\\text{ideal}} + \\frac{\\text{总停顿周期数}}{\\text{总指令数}} $$\n给定 $\\mathrm{CPI}_{\\text{ideal}} = 1$，我们可以写成：\n$$ \\mathrm{CPI} = 1 + (\\text{停顿频率}) \\times (\\text{停顿惩罚}) $$\n根据以上分析，停顿仅在加载-使用冒险时发生。问题规定了一个周期的停顿，因此每次发生的停顿惩罚是 $1$ 个周期。\n\n我们需要计算停顿频率，即任何给定的指令序列触发停顿的概率。如果一条指令是加载指令，并且紧随其后的指令使用了其结果，则会触发停顿。\n- 作为加载指令的指令比例为 $f_{\\mathrm{L}} = 0.28$。\n- 紧随加载指令之后的指令对其有相关性的概率为 $p = 0.35$。这种相关性就是冒险检测逻辑 $H$ 所检测的。\n\n指令流中每条指令发生停顿事件的频率是指令为加载指令的概率与下一条指令引起加载-使用冒险的条件概率的乘积。\n$$ \\text{停顿频率} = f_{\\mathrm{L}} \\times p $$\n每条指令的停顿周期数是这个频率乘以 $1$ 个周期的惩罚。\n$$ \\frac{\\text{总停顿周期数}}{\\text{总指令数}} = f_{\\mathrm{L}} \\times p \\times 1 = f_{\\mathrm{L}} \\times p $$\n将此代入 $\\mathrm{CPI}$ 公式：\n$$ \\mathrm{CPI} = 1 + f_{\\mathrm{L}} \\times p $$\n使用给定的值 $f_{\\mathrm{L}} = 0.28$ 和 $p = 0.35$：\n$$ \\mathrm{CPI} = 1 + (0.28 \\times 0.35) $$\n$$ \\mathrm{CPI} = 1 + 0.098 $$\n$$ \\mathrm{CPI} = 1.098 $$\n问题要求将答案四舍五入到四位有效数字。值 $1.098$ 正好有四位有效数字。", "answer": "$$\n\\boxed{1.098}\n$$", "id": "3643923"}, {"introduction": "真实的程序充满了循环结构，其中既包含数据依赖，也包含控制流的改变（分支）。本练习将数据冒险的转发处理与控制冒险的处理结合起来。你将分析一个紧凑的循环，计算其综合的每指令周期数（CPI），从而学习如何在一个流水线处理器中为不同类型的冒险所带来的综合性能影响建模。[@problem_id:3643933]", "problem": "考虑一个经典的 $5$ 级整数流水线，其阶段包括：指令提取 (IF)、指令译码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该流水线是单发射的，拥有完美的指令和数据缓存（无缓存未命中），并实现了到执行阶段的完全数据前送（旁路）。前送将来自 EX/MEM 和 MEM/WB 流水线寄存器的结果提供给相关指令的 EX 阶段输入，以及用于分支的 EX 阶段比较器。加载指令在 MEM 阶段产生其结果；然而，下面的代码不包含加载指令。假设没有结构性冒险。\n\n条件分支在 EX 阶段被解析。当分支被采纳时，前端因控制冒险处理而损失 $\\beta$ 个气泡周期；当分支未被采纳时，不产生气泡周期。假设从长远来看，分支被采纳的迭代比例为 $p$，其中 $0 \\leq p \\leq 1$。\n\n分析以下紧凑循环，该循环更新寄存器 $R2$ 并在随后的指令中立即使用 $R2$：\n\nLOOP:\n    ADD R2, R2, R3\n    SUB R4, R2, R5\n    ADD R1, R1, R11\n    BNE R1, R12, LOOP\n\n假设末尾的分支会一直循环，直到满足一个依赖于 $R1$ 的终止条件，因此在动态执行中，该分支有 $p$ 的比例被采纳，否则不被采纳。\n\n从流水线阶段和冒险处理的基本定义出发，追踪在一个稳态循环迭代中数据相关性的前送决策，并确定是否需要任何停顿周期。然后，推导该循环的稳态每指令周期数 (CPI) 的封闭形式符号表达式，该表达式是分支采纳比例 $p$ 和分支采纳惩罚 $\\beta$ 的函数。将您的最终答案表示为单个解析表达式。CPI 是无量纲的，不需要单位。", "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n- 流水线：$5$ 级（指令提取 (IF)、指令译码 (ID)、执行 (EX)、内存访问 (MEM)、写回 (WB)）。\n- 微架构：单发射，从 EX/MEM 和 MEM/WB 寄存器到 EX 阶段输入和 EX 阶段比较器的完全数据前送。\n- 缓存：完美的指令和数据缓存（无缓存未命中）。\n- 冒险：无结构性冒险。代码中不存在加载指令。\n- 控制流：条件分支 (`BNE`) 在 EX 阶段被解析。\n- 分支惩罚：采纳的分支产生 $\\beta$ 个气泡周期的惩罚。未采纳的分支产生 $0$ 个气泡周期。\n- 分支行为：分支以 $p$ 的长期比例（概率）被采纳，其中 $0 \\leq p \\leq 1$。\n- 代码序列（循环）：\n  1. `ADD R2, R2, R3`\n  2. `SUB R4, R2, R5`\n  3. `ADD R1, R1, R11`\n  4. `BNE R1, R12, LOOP`\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，描述了一个在计算机体系结构教育和分析中常用的标准 RISC 流水线模型。数据前送、控制冒险和每指令周期数 (CPI) 的概念都定义明确。该问题是适定的，提供了所有必要的参数（$\\beta$、$p$）和一个清晰的代码段，以推导出 CPI 的唯一符号表达式。语言客观而精确。给定的条件内部一致，没有违反任何计算机组织的基本原则。指定的前送路径足以处理代码中存在的数据相关性，这将在解题过程中得到证明。该问题并非无足轻重，因为它需要仔细分析数据和控制冒险。\n\n### 步骤 3：结论与行动\n问题被判定为 **有效**。将推导完整解。\n\n### 解题推导\n目标是为所提供循环的稳态每指令周期数 (CPI) 推导一个封闭形式的符号表达式。这需要分析数据冒险和控制冒险。\n\n设循环中的四条指令表示如下：\n- $I_1$：`ADD R2, R2, R3`\n- $I_2$：`SUB R4, R2, R5`\n- $I_3$：`ADD R1, R1, R11`\n- $I_4$：`BNE R1, R12, LOOP`\n\n**1. 数据冒险分析**\n\n我们识别代码中的写后读 (RAW) 数据相关性：\n- **对 $R2$ 的相关性**：$I_1$ 写入寄存器 $R2$，而 $I_2$ 从 $R2$ 读取。\n- **对 $R1$ 的相关性**：$I_3$ 写入寄存器 $R1$，而 $I_4$ 从 $R1$ 读取以进行分支比较。\n\n让我们追踪流水线执行以确定这些相关性是否会导致停顿。如果生产者指令的结果在消费者指令需要它时还不可用，就需要停顿。\n\n*对 $I_1 \\rightarrow I_2$ 相关性的分析：*\n指令 $I_1$ (ADD) 在其 EX 阶段计算结果。这个结果在 $I_1$ 处于其 EX 阶段的时钟周期结束时可用于前送。指令 $I_2$ (SUB) 在其 EX 阶段开始时需要 $R2$ 的值作为 ALU 的输入。\n考虑没有任何停顿的单次迭代的流水线时序图：\n- 周期 $k$：$I_1$ 处于 EX 阶段。\n- 周期 $k+1$：$I_1$ 处于 MEM 阶段，$I_2$ 处于 EX 阶段。\n\n在周期 $k+1$， $I_1$ 的结果存在于 EX/MEM 流水线寄存器中。问题陈述指出，流水线具有“完全数据前送……从 EX/MEM……流水线寄存器到 EX 阶段输入”。因此，$I_1$ 的结果可以在周期 $k+1$ 直接前送到 $I_2$ 的 ALU 输入。解决这种相关性不需要停顿。\n\n*对 $I_3 \\rightarrow I_4$ 相关性的分析：*\n指令 $I_3$ (ADD) 在其 EX 阶段计算 $R1$ 的结果。指令 $I_4$ (BNE) 在其 EX 阶段需要这个 $R1$ 的值来执行比较。\n考虑这些指令的流水线时序：\n- 周期 $m$：$I_3$ 处于 EX 阶段。\n- 周期 $m+1$：$I_3$ 处于 MEM 阶段，$I_4$ 处于 EX 阶段。\n\n与第一种情况类似，在周期 $m+1$，$I_3$ 产生的 $R1$ 的新值在 EX/MEM 流水线寄存器中是可用的。问题指定了前送可用于“分支的 EX 阶段比较器”。因此，$R1$ 的新值可以前送到 $I_4$ 在 EX 阶段的比较器逻辑。这种相关性也不需要停顿。\n\n关于数据冒险的结论：由于指定了完全前送硬件，循环体内部的数据相关性不会导致停顿周期。\n\n**2. 控制冒险与 CPI 计算**\n\nCPI 定义为总周期数除以总指令数。对于稳态循环，我们可以将其计算为每次循环迭代的平均周期数除以每次迭代的指令数。\n\n每次迭代的指令数 $N_{instr}$ 为 $4$。\n\n在没有任何冒险的情况下，单发射流水线的理想 CPI 为 $1$。在这种情况下，一个循环迭代在稳态下需要 $4$ 个周期完成。然而，`BNE` 指令 ($I_4$) 引入了潜在的控制冒险。\n\n分支结果在 $I_4$ 的 EX 阶段确定。我们必须考虑两种情况：\n\n*情况 A：分支未被采纳*\n这种情况以 $(1-p)$ 的概率发生。流水线被假定预测分支不被采纳（一种常见的静态预测方案），因此它继续按顺序提取指令。当 $I_4$ 在其 EX 阶段被解析并发现未被采纳时，已经提取的指令是正确的。问题陈述指出，在这种情况下，会产生 $0$ 个气泡周期。\n这次迭代的周期数就是指令数：$C_{not\\_taken} = 4$。\n\n*情况 B：分支被采纳*\n这种情况以 $p$ 的概率发生。当 $I_4$ 处于其 EX 阶段时，流水线发现分支被采纳。此时，已经从错误的路径（顺序路径）提取了下一迭代的指令。这些指令必须从流水线中冲刷掉，并且必须在分支目标 (`LOOP`) 处重新开始提取。问题指定这会花费 $\\beta$ 个气泡周期。\n这次迭代的周期数是指令数加上惩罚：$C_{taken} = 4 + \\beta$。\n\n*每次迭代的平均周期数*\n每次循环迭代的平均周期数 $\\bar{C}_{iter}$ 是每种情况下周期的加权平均值：\n$$ \\bar{C}_{iter} = C_{not\\_taken} \\cdot (1-p) + C_{taken} \\cdot p $$\n$$ \\bar{C}_{iter} = 4 \\cdot (1-p) + (4 + \\beta) \\cdot p $$\n$$ \\bar{C}_{iter} = 4 - 4p + 4p + \\beta p $$\n$$ \\bar{C}_{iter} = 4 + \\beta p $$\n\n*最终 CPI 计算*\n稳态 CPI 是每次迭代的平均周期数除以每次迭代的指令数：\n$$ \\text{CPI} = \\frac{\\bar{C}_{iter}}{N_{instr}} $$\n$$ \\text{CPI} = \\frac{4 + \\beta p}{4} $$\n$$ \\text{CPI} = 1 + \\frac{\\beta p}{4} $$\n\n该表达式表示了稳态 CPI 作为分支采纳比例 $p$ 和分支采纳惩罚 $\\beta$ 的函数。基础 CPI 为 $1$，附加项 $\\frac{\\beta p}{4}$ 代表了因控制冒险而产生的性能损失，该损失是在循环中所有指令上平均计算的。", "answer": "$$\\boxed{1 + \\frac{\\beta p}{4}}$$", "id": "3643933"}]}