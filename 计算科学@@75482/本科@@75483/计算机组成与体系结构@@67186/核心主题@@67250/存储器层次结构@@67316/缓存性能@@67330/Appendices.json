{"hands_on_practices": [{"introduction": "要真正理解缓存性能，我们必须从命中和未命中的基本原理入手。第一个练习将引导你手动追踪一个精心构造的访问模式，该模式会在一个二路组相联缓存中导致“颠簸”（thrashing）现象 [@problem_id:3626035]。通过这个练习，你将从第一性原理出发，理解为何即使存在相联性，冲突未命中（conflict miss）仍可能主导性能。这次动手追踪将帮助你建立对“最近最少使用”（LRU）替换策略及其与内存访问序列相互作用的直观认识。", "problem": "一个处理器使用一级 (L1) 数据缓存，该缓存是一个总容量为 $C$ 字节、块大小为 $B$ 字节的 $2$ 路组相联缓存。替换策略为最近最少使用 (LRU)，且缓存初始为空。考虑地址为 $X$、$Y$ 和 $Z$ 的三个不同内存块，它们都映射到该缓存中的同一个组索引。每次访问都是读操作。处理器重复地对 $\\{X,Y,Z\\}$ 发出一个确定的无限访问序列，该序列在这三个块之间交替进行，以便在 LRU 策略下最大化冲突未命中。\n\n仅使用缓存命中、缓存未命中、命中率和平均内存访问时间 (AMAT) 的核心定义，完成以下任务：\n\n- 设计一个针对此 $2$ 路组相联 LRU 缓存的、在 $\\{X,Y,Z\\}$ 上交替进行并最大化冲突未命中的显式无限访问序列。\n- 从第一性原理出发，推导此访问序列的稳态命中率 $H$，其中 $H$ 是在任何瞬态预热效应之后，长期来看命中访问所占的比例。\n- 给定命中延迟为 $t_h = 3$ 个周期，未命中惩罚为 $t_m = 120$ 个周期，计算稳态平均内存访问时间 (AMAT)，以周期为单位。\n\n将 $H$ 表示为小数或分数，并将 AMAT 表示为周期数。无需四舍五入。最终答案必须是数对 $\\{H,\\text{AMAT}\\}$。", "solution": "该问题被评估为具有科学依据、提法明确且客观。所有确定访问序列、命中率和平均内存访问时间 (AMAT) 所需的信息均已提供。所用参数和概念均为计算机体系结构中的标准内容。该问题是有效的。\n\n解决方案按要求分三部分展开：设计访问序列、推导稳态命中率和计算 AMAT。\n\n**第 1 部分：无限访问序列的设计**\n\n该缓存是 $k=2$ 路组相联的，意味着每个组可以精确地容纳 $2$ 个不同的内存块。替换策略是最近最少使用 (LRU)，该策略规定，当一个新块必须被调入一个已满的组时，最长时间未被访问的块将被替换出去。\n\n我们已知有 $3$ 个不同的内存块，地址分别为 $X$、$Y$ 和 $Z$，它们都映射到同一个缓存组。任务是设计一个在 $\\{X, Y, Z\\}$ 上确定性的、交替的、无限的访问序列，以最大化冲突未命中。当一个块为了给映射到同一组的另一个块腾出空间而从组中被替换出去，并且这个被替换的块稍后又被再次访问时，就会发生冲突未命中。\n\n为了最大化未命中，我们应该以一种确保所请求的块永远不在缓存中的方式来访问这些块。这种现象被称为抖动。考虑循环访问序列：$S = (X, Y, Z, X, Y, Z, \\dots)$。让我们追踪这个唯一相关的缓存组的状态，它初始为空。元组将表示组中的块，其中最右边的元素是最近使用的 (MRU)，最左边的元素是最近最少使用的 (LRU)。\n\n1.  访问 $X$：**未命中** (强制性)。缓存为空。$X$ 被加载。\n    - 组状态：$\\{X\\}$\n    - LRU 状态：$X$ 是 MRU。\n\n2.  访问 $Y$：**未命中** (强制性)。组未满。$Y$ 被加载。\n    - 组状态：$\\{X, Y\\}$\n    - LRU 状态：$Y$ 是 MRU，$X$ 是 LRU。\n\n3.  访问 $Z$：**未命中** (冲突)。组已满，包含 $\\{X, Y\\}$。根据 LRU 策略，最近最少使用的块 $X$ 被替换。$Z$ 被加载。\n    - 组状态：$\\{Y, Z\\}$\n    - LRU 状态：$Z$ 是 MRU，$Y$ 是 LRU。\n\n4.  访问 $X$：**未命中** (冲突)。组已满，包含 $\\{Y, Z\\}$。LRU 块是 $Y$。$Y$ 被替换，$X$ 被加载。\n    - 组状态：$\\{Z, X\\}$\n    - LRU 状态：$X$ 是 MRU，$Z$ 是 LRU。\n\n5.  访问 $Y$：**未命中** (冲突)。组已满，包含 $\\{Z, X\\}$。LRU 块是 $Z$。$Z$ 被替换，$Y$ 被加载。\n    - 组状态：$\\{X, Y\\}$\n    - LRU 状态：$Y$ 是 MRU，$X$ 是 LRU。\n\n6.  访问 $Z$：**未命中** (冲突)。组已满，包含 $\\{X, Y\\}$。LRU 块是 $X$。$X$ 被替换，$Z$ 被加载。\n    - 组状态：$\\{Y, Z\\}$\n    - LRU 状态：$Z$ 是 MRU，$Y$ 是 LRU。\n\n缓存状态的模式 $\\{Y, Z\\} \\to \\{Z, X\\} \\to \\{X, Y\\}$ 会重复出现。在这个稳态循环中（从第 3 次访问开始），任何一次访问所请求的块，恰好是两步之前被替换出去的那个块。例如，在第 3 步，$Z$ 替换了 $X$，然后在第 4 步请求了 $X$。在第 4 步，$X$ 替换了 $Y$，然后在第 5 步请求了 $Y$。在第 5 步，$Y$ 替换了 $Z$，如果序列是 $X,Y,Z,X,Y,Z...$，那么在第 6 步就会请求 $Z$。所提供的追踪过程证实了这一点。\n\n该序列在稳态下导致每次访问都发生未命中。$0$ 的命中率是可能达到的最小值，这意味着未命中率被最大化了。因此，最大化冲突未命中的显式无限访问序列是重复序列 $(X, Y, Z)^\\infty$，即 $X, Y, Z, X, Y, Z, \\dots$。任何循环置换，例如 $(Y, Z, X)^\\infty$，也满足条件。\n\n**第 2 部分：稳态命中率 ($H$) 的推导**\n\n稳态命中率 $H$ 是指在任何初始瞬态效应（如强制性未命中）发生后，长期来看命中访问所占的比例。如上所述，对于序列 $S = (X, Y, Z, X, Y, Z, \\dots)$，从第三次访问开始，每次访问都是一次冲突未命中。\n\n命中率定义为：\n$$ H = \\lim_{N \\to \\infty} \\frac{\\text{Number of Hits in the first } N \\text{ accesses}}{\\text{Total number of accesses } (N)} $$\n在我们的序列中，对于任何 $N \\geq 1$，命中次数始终为 $0$。设 $N_h(N)$ 为前 $N$ 次访问中的命中次数。\n$$ N_h(N) = 0 \\quad \\forall N \\in \\mathbb{Z}^+ $$\n因此，命中率为：\n$$ H = \\lim_{N \\to \\infty} \\frac{0}{N} = 0 $$\n稳态命中率 $H$ 为 $0$。\n\n**第 3 部分：平均内存访问时间 (AMAT) 的计算**\n\n平均内存访问时间 (AMAT) 是命中时间和未命中时间的加权平均值。\n其核心定义是：\n$$ \\text{AMAT} = (\\text{Hit Rate} \\times \\text{Time per Hit}) + (\\text{Miss Rate} \\times \\text{Time per Miss}) $$\n设 $H$ 为命中率，$M$ 为未命中率。根据定义，$M = 1 - H$。\n设 $t_h$ 为命中延迟（每次命中的时间），$t_{miss}$ 为处理一次未命中所需的总时间。\n一次内存访问首先涉及检查缓存，这需要时间 $t_h$。如果命中，访问完成。如果未命中，则需要一个额外的时间，即未命中惩罚 ($t_m$)，用于从下一级内存中获取数据。\n因此：\n- 每次命中的时间 $= t_h$\n- 每次未命中的时间 $= t_{miss} = t_h + t_m$\n\n将这些代入 AMAT 公式：\n$$ \\text{AMAT} = H \\cdot t_h + (1 - H) \\cdot (t_h + t_m) $$\n这个表达式可以简化为：\n$$ \\text{AMAT} = H \\cdot t_h + t_h + t_m - H \\cdot t_h - H \\cdot t_m $$\n$$ \\text{AMAT} = t_h + (1 - H) \\cdot t_m $$\n这是 AMAT 的标准公式。\n\n我们已知以下值：\n- 命中延迟, $t_h = 3$ 个周期\n- 未命中惩罚, $t_m = 120$ 个周期\n\n从第 2 部分，我们推导出稳态命中率：\n- 命中率, $H = 0$\n\n现在，我们将这些值代入 AMAT 公式：\n$$ \\text{AMAT} = 3 \\text{ cycles} + (1 - 0) \\times 120 \\text{ cycles} $$\n$$ \\text{AMAT} = 3 + 1 \\times 120 $$\n$$ \\text{AMAT} = 3 + 120 $$\n$$ \\text{AMAT} = 123 \\text{ cycles} $$\n\n稳态命中率 $H$ 为 $0$，稳态平均内存访问时间为 $123$ 个周期。最终答案是数对 $\\{H, \\text{AMAT}\\}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0  123 \\end{pmatrix}}\n$$", "id": "3626035"}, {"introduction": "在我们对冲突未命中有了基本认识之后，这项练习将带你进入一个更真实的系统级问题，其中两个大型数据阵列会在一个直接映射缓存中引发病态的颠簸现象。你将首先通过计算平均内存访问时间（AMAT）来量化这种严重的性能下降 [@problem_id:3626006]。接着，你将评估一种改进后的架构方案——偏移相联缓存（skewed-associative cache），看看巧妙的设计如何能缓解这些冲突并显著提升系统速度。", "problem": "一个单处理器系统拥有一个一级（L1）数据缓存，该缓存为物理索引、物理标记，并且初始为直接映射。L1 缓存的总容量为 $C = 64\\,\\mathrm{KiB}$，块大小为 $B = 64\\,\\mathrm{B}$。因此，缓存行数量为 $C/B$，可索引的组数等于 $C/B$，因为初始关联度为1。考虑两个数组 $\\mathcal{A}$ 和 $\\mathcal{B}$，每个的大小恰好为 $C$，存储在连续的内存中，并按 $C$ 字节边界对齐。数组以等于缓存块大小的空间步幅进行访问，因此每次访问都会触及数组内的一个新块。具体来说，定义遍历数组的过程为以下按块交替序列的无限重复：\n- 对于 $i = 0, 1, 2, \\dots, (C/B) - 1$：访问 $\\mathcal{A}[i \\cdot B]$，然后访问 $\\mathcal{B}[i \\cdot B]$。\n$\\mathcal{A}$ 和 $\\mathcal{B}$ 的基虚拟地址被设置成：对于每个块索引 $i$，块 $\\mathcal{A}[i \\cdot B]$ 和 $\\mathcal{B}[i \\cdot B]$ 映射到相同的 L1 缓存索引，但具有不同的标记。例如，取 $\\mathrm{base}(\\mathcal{B}) = \\mathrm{base}(\\mathcal{A}) + C$。假设一个完美的翻译后备缓冲器（TLB）且没有虚拟别名效应。\n二级（L2）缓存足够大，可以在稳态下同时容纳两个数组，并且是高关联度的，块大小等于 $B$。经过初始预热后，每次 L1 未命中都会在 L2 缓存中命中。L1 命中时间为 $1.0\\,\\mathrm{ns}$，L2 命中时间（当处理一个在 L2 中命中的 L1 未命中时，超出 L1 命中时间的额外延迟）为 $8.0\\,\\mathrm{ns}$，并且在本实验的稳态下，主存永远不会被访问。\n任务：\n1) 仅使用缓存命中、未命中、未命中率的核心定义，以及将单次访问时间视为命中与未命中期望值的概念，论证上述访问模式为何能在直接映射的L1缓存中引发最坏情况的冲突行为，并说明在稳态下（忽略强制性初次访问），该模式的长期L1未命中率。\n2) 根据第 (1) 部分得出的未命中率结论和给定的时间参数，符号化地推导并计算初始直接映射 L1 设计在稳态下的长期平均每次内存访问时间。\n现在假设 L1 被重新设计为一个 2 路偏移关联（skewed-associative）缓存，具有相同的总容量 $C$ 和块大小 $B$，使用两个独立的索引函数（每路一个）将块均匀分布到各个组中。假设在这种重新设计和相同的访问模式下，稳态 L1 未命中率达到了由工作集与缓存大小之比所设定的理想下限，即在稳态下恰好有一半的访问在 L1 中未命中。由于增加了路和哈希逻辑，L1 命中时间精确增加了 $10\\%$，而所有其他时间参数保持不变。\n3) 使用与第 (2) 部分相同的第一性原理推理，推导并计算偏移关联 L1 在稳态下的平均内存访问时间。\n最后，报告你的单一数值结果——加速比 $S$，定义为初始平均访问时间与重新设计后的平均访问时间之比。将 $S$ 的最终答案四舍五入到四位有效数字。将 $S$ 表示为一个无单位的纯数。", "solution": "首先根据指定标准验证问题。\n\n**第1步：提取给定条件**\n- L1 缓存初始配置：物理索引、物理标记、直接映射（关联度 $k=1$）。\n- L1 缓存容量：$C = 64\\,\\mathrm{KiB}$。\n- L1 缓存块大小：$B = 64\\,\\mathrm{B}$。\n- L1 组数（直接映射）：$N = C/B$。\n- 数组：$\\mathcal{A}$ 和 $\\mathcal{B}$，每个的大小为 $C$。\n- 数组内存布局：连续，按 $C$ 字节边界对齐。\n- 访问模式：序列的无限重复：对于 $i = 0, 1, \\dots, (C/B) - 1$，访问 $\\mathcal{A}[i \\cdot B]$，然后访问 $\\mathcal{B}[i \\cdot B]$。\n- 映射约束：对于每个块索引 $i$，$\\mathcal{A}[i \\cdot B]$ 和 $\\mathcal{B}[i \\cdot B]$ 映射到相同的 L1 缓存索引但具有不同的标记。\n- 系统假设：完美的翻译后备缓冲器（TLB），无虚拟别名。\n- L2 缓存：足够大以容纳两个数组，高关联度，块大小为 $B$。\n- 稳态 L2 行为：每次 L1 未命中都是 L2 命中。不访问主存。\n- 初始设计的时间参数：\n  - L1 命中时间：$T_{H1} = 1.0\\,\\mathrm{ns}$。\n  - L2 命中时间（L1 未命中的额外延迟）：$T_{H2} = 8.0\\,\\mathrm{ns}$。\n- L1 缓存重新设计配置：2 路偏移关联，相同的 $C$ 和 $B$。\n- 偏移关联缓存属性：两个独立的、均匀的索引函数。\n-\n重新设计后缓存的稳态 L1 未命中率：$m_{1, \\text{skewed}} = 1/2$。\n- 重新设计的时间参数：\n  - 新的 L1 命中时间：$T'_{H1} = T_{H1} \\times (1 + 0.10) = 1.1 \\times T_{H1}$。\n  - 其他时间参数（$T_{H2}$）不变。\n- 最终要求结果：加速比 $S = \\frac{\\text{AMAT}_{\\text{initial}}}{\\text{AMAT}_{\\text{redesigned}}}$，四舍五入到四位有效数字。\n\n**第2步：使用提取的给定条件进行验证**\n- **科学基础**：该问题基于计算机体系结构的基本原理，特别是缓存存储器组织、性能指标（如未命中率和平均内存访问时间 AMAT）以及冲突未命中的概念。所描述的场景是一个标准的教科书示例，用于说明缓存冲突的病态情况。所有参数对于现代处理器都是物理上现实的。\n- **问题明确**：问题定义清晰，并提供了计算所需的所有数据。时间参数的定义，例如 L2 命中时间是“额外延迟”，是精确的，并直接对应于 AMAT 公式中的未命中惩罚项。\n- **客观性**：问题陈述没有主观性语言，并使用了精确的技术术语。\n- **一致性**：给定条件是自洽的。对于一个具有 $C/B$ 个组的直接映射缓存（其中 $C$ 是2的幂，这是标准情况），条件“$\\mathcal{A}[i \\cdot B]$ 和 $\\mathcal{B}[i \\cdot B]$ 映射到相同的 L1 索引”是指定内存布局（例如 $\\mathrm{base}(\\mathcal{B}) = \\mathrm{base}(\\mathcal{A}) + C$）的直接结果。\n\n**第3步：结论与行动**\n该问题是有效的，因为它科学合理、问题明确、客观且内部一致。可以从提供的信息中推导出完整的解决方案。\n\n**求解推导**\n\n该问题要求分析两种不同 L1 缓存设计下的缓存性能。我们将按顺序解决问题的每个部分。\n\n**第1部分：直接映射缓存的 L1 未命中率**\n\nL1 缓存是直接映射的，这意味着每个内存块只能映射到一个特定的缓存行（或组）。组的数量为 $N = C/B = (64 \\times 1024\\,\\mathrm{B}) / (64\\,\\mathrm{B}) = 1024$。访问模式是一个遍历数组 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的块的无限循环。对于每个块索引 $i$，先访问来自 $\\mathcal{A}$ 的块，然后访问来自 $\\mathcal{B}$ 的块。一个关键信息是，对于任何给定的 $i$，包含 $\\mathcal{A}[i \\cdot B]$ 的内存块和包含 $\\mathcal{B}[i \\cdot B]$ 的内存块映射到同一个 L1 缓存组。它们有不同的标记，证实它们是不同的内存块。\n\n让我们分析单个缓存组（比如说组 $j$，它对应于某个块索引 $i$）的事件序列。设来自 $\\mathcal{A}$ 的块表示为 $A_i$，来自 $\\mathcal{B}$ 的块表示为 $B_i$。\n与该组相关的访问序列是 $\\dots, A_i, B_i, A_i, B_i, \\dots$。我们关心的是稳态，因此忽略初始的冷未命中（cold misses）。\n\n1.  假设在稳态执行的某个时刻，我们访问块 $A_i$。在此访问之前，缓存组 $j$ 必定包含块 $B_i$，它是在上一次循环迭代中（当访问 $\\mathcal{B}[i \\cdot B]$ 时）加载的。由于组 $j$ 持有 $B_i$，对 $A_i$ 的访问导致**未命中**。因为缓存是直接映射的，块 $B_i$ 被驱逐，块 $A_i$ 被加载到组 $j$ 中。\n\n2.  紧接着对 $A_i$ 的访问，程序访问块 $B_i$。此时缓存组 $j$ 包含块 $A_i$。因此，对 $B_i$ 的访问也导致**未命中**。块 $A_i$ 被驱逐，块 $B_i$ 被加载到组 $j$ 中。\n\n这种相互驱逐的循环对每一对访问 $(\\mathcal{A}[i \\cdot B], \\mathcal{B}[i \\cdot B])$ 和每一个块索引 $i$ 都会重复。序列中的每一次内存访问都会导致冲突未命中。这种访问模式被完美地设计用来抖动（thrash）直接映射缓存，从而产生最坏情况。\n\n因此，稳态 L1 未命中率 $m_{1, \\text{direct}}$ 是未命中次数与总访问次数的比率。由于每次访问都是未命中，所以未命中率为 $1$。\n$$m_{1, \\text{direct}} = 1.0$$\n\n**第2部分：直接映射缓存的平均内存访问时间（AMAT）**\n\n平均内存访问时间（AMAT）是内存访问的期望时间。它使用 L1 命中时间（$T_{H1}$）、L1 未命中率（$m_1$）和 L1 未命中惩罚（$M_{P1}$）来计算。通用公式是：\n$$AMAT = T_{H1} + m_1 \\times M_{P1}$$\n问题指出，任何 L1 未命中都由 L2 缓存服务，而 L2 缓存在稳态下总是命中。此服务的额外延迟是 $T_{H2}$。这个额外延迟正是 L1 未命中惩罚，即 $M_{P1} = T_{H2}$。\n\n对于初始的直接映射设计，我们将 AMAT 表示为 $AMAT_{\\text{direct}}$。我们有：\n- L1 命中时间：$T_{H1} = 1.0\\,\\mathrm{ns}$\n- L1 未命中率：$m_{1, \\text{direct}} = 1.0$（来自第1部分）\n- L1 未命中惩罚：$M_{P1} = T_{H2} = 8.0\\,\\mathrm{ns}$\n\n将这些值代入 AMAT 公式：\n$$AMAT_{\\text{direct}} = T_{H1} + m_{1, \\text{direct}} \\times T_{H2}$$\n$$AMAT_{\\text{direct}} = 1.0\\,\\mathrm{ns} + (1.0) \\times (8.0\\,\\mathrm{ns}) = 1.0\\,\\mathrm{ns} + 8.0\\,\\mathrm{ns} = 9.0\\,\\mathrm{ns}$$\n\n**第3部分：偏移关联缓存的 AMAT**\n\nL1 缓存现在被重新设计为 2 路偏移关联，具有相同的容量 $C$ 和块大小 $B$。这次重新设计影响了 L1 命中时间和 L1 未命中率。\n\n新的参数是：\n- 新的 L1 命中时间：$T'_{H1} = T_{H1} \\times (1 + 0.10) = 1.0\\,\\mathrm{ns} \\times 1.1 = 1.1\\,\\mathrm{ns}$。\n- 新的 L1 未命中率：$m_{1, \\text{skewed}} = 1/2 = 0.5$，如问题陈述中所给。\n- L1 未命中惩罚不变，因为 L2 缓存系统未被修改：$M'_{P1} = T_{H2} = 8.0\\,\\mathrm{ns}$。\n\n我们可以使用相同的公式计算新的 AMAT，记为 $AMAT_{\\text{skewed}}$：\n$$AMAT_{\\text{skewed}} = T'_{H1} + m_{1, \\text{skewed}} \\times T_{H2}$$\n将新值代入：\n$$AMAT_{\\text{skewed}} = 1.1\\,\\mathrm{ns} + (0.5) \\times (8.0\\,\\mathrm{ns}) = 1.1\\,\\mathrm{ns} + 4.0\\,\\mathrm{ns} = 5.1\\,\\mathrm{ns}$$\n\n**最终计算：加速比 S**\n\n加速比 $S$ 定义为初始（较慢）平均访问时间与重新设计后（较快）平均访问时间之比。\n$$S = \\frac{AMAT_{\\text{direct}}}{AMAT_{\\text{skewed}}}$$\n使用计算出的值：\n$$S = \\frac{9.0\\,\\mathrm{ns}}{5.1\\,\\mathrm{ns}} = \\frac{9.0}{5.1} = \\frac{90}{51} = \\frac{30}{17}$$\n为了提供最终的数值答案，我们计算这个分数的值并将其四舍五入到四位有效数字。\n$$S = \\frac{30}{17} \\approx 1.76470588\\dots$$\n四舍五入到四位有效数字得到 $1.765$。", "answer": "$$\\boxed{1.765}$$", "id": "3626006"}, {"introduction": "尽管手动追踪富有启发性，但现实世界的分析需要自动化工具。这项综合性练习将挑战你编写一个程序来模拟一个组相联LRU缓存，这是每位计算机架构师都会使用的工具 [@problem_id:3625959]。通过实现这个模拟器，你不仅能巩固对缓存工作机制的理解，还能获得量化复杂动态行为（例如“冷启动”预热期以及向稳态性能的过渡）的能力。", "problem": "您必须编写一个完整、可运行的程序，模拟在重复的内存块引用阶段下的缓存预热，以量化冷启动效应。该程序必须计算作为离散时间函数的瞬态累积未命中率、达到稳态行为的时间、稳态未命中率，以及在一个阶段内的平均内存访问时间。此问题中的所有数学符号和数字均以 LaTeX 格式书写；您的程序必须为指定的测试套件生成具体的数值输出。\n\n假设一个物理索引、物理标记的缓存具有以下属性：\n- 组数为 $S$。\n- 相联度为 $A$（即每组 $A$ 路）。\n- 每组内采用最近最少使用（LRU）替换策略。\n- 块大小无关紧要，因为提供的地址已经是块地址。\n- 在 $t = 0$ 时缓存为空。\n\n地址以一个无限重复的有限块编号阶段模式给出。设该阶段模式为一个长度为 $L$ 的有序列表。总访问流通过永远重复此列表获得，因此时间 $t \\in \\{1,2,\\dots\\}$ 的访问是该阶段模式中位置为 $((t-1) \\bmod L) + 1$ 的元素。\n\n用作基本依据的定义：\n- 当请求的块当前驻留在由 $S$ 和 $A$ 隐含的映射关系所决定的适当组中时，发生缓存命中；否则发生缓存未命中。\n- 到时间 $t$ 为止的累积未命中率是 $MR(t) = \\dfrac{\\text{访问 } 1 \\text{ 到 } t \\text{ 的未命中次数}}{t}$。\n- 设每个阶段开始时的缓存状态是包括 LRU 顺序在内的每组内容的完整集合。在固定的、重复的阶段下，阶段开始状态的序列是确定性的。由于状态空间是有限的，因此存在索引 $i$ 和 $j$（$0 \\le i  j$），使得阶段开始状态 $S_i$ 等于 $S_j$。将稳态周期定义为从 $i$到 $j-1$ 的阶段序列，并将达到稳态的时间定义为 $t_{ss} = i \\cdot L$。\n- 稳态未命中率 $MR_{\\infty}$ 定义为一个完整稳态周期内发生的所有未命中总数除以该周期内的总访问次数，即周期中的阶段数乘以 $L$。\n- 设每次访问时间 $T$ 在命中时等于命中时间，在未命中时等于命中时间与未命中惩罚之和。使用全期望定律计算平均每次访问时间。\n\n您的程序必须：\n- 从空状态开始模拟缓存，按顺序应用访问，在每个组内使用 LRU 替换策略。\n- 通过比较阶段边界处的完整缓存状态，检测阶段开始状态序列中的最早周期。\n- 计算达到稳态的时间 $t_{ss}$，单位为访问次数，其值为 $i \\cdot L$，其中 $i$ 是周期开始的索引。\n- 计算 $MR_{\\infty}$，即一个完整稳态周期内总未命中数与总访问数的比率。\n- 设 $X$ 是一个指定的正整数。计算 $MR(X)$ 和前 $X$ 次访问的平均内存访问时间，方法是应用全期望定律并将结果表示为周期数。\n- 此外，计算进入稳态周期之前每个阶段边界结束时的累积未命中率列表，即 $\\left[MR(L), MR(2L), \\dots, MR(i \\cdot L)\\right]$。如果 $i = 0$，则此列表为空。\n\n所有未命中率必须以小数（而非百分比）表示。所有平均内存访问时间必须以周期数表示。对于数值输出，将所有浮点值四舍五入到小数点后恰好 $6$ 位。\n\n测试套件和参数：\n对于下面的每个测试用例，阶段模式以块编号列表的形式给出；到组的映射为 $set(b) = b \\bmod S$，标记为 $\\left\\lfloor \\dfrac{b}{S} \\right\\rfloor$。替换策略为 LRU。\n\n测试用例 A（带冲突的通用预热）：\n- $S = 2$, $A = 2$, $L = 12$\n- 阶段模式：$[0, 4, 1, 5, 2, 6, 0, 4, 3, 7, 1, 5]$\n- 命中时间 $H = 1.0$ 周期\n- 未命中惩罚 $M = 20.0$ 周期\n- $X = 24$\n\n测试用例 B（填充后可装入缓存）：\n- $S = 4$, $A = 2$, $L = 6$\n- 阶段模式：$[0, 8, 1, 9, 2, 10]$\n- 命中时间 $H = 2.0$ 周期\n- 未命中惩罚 $M = 50.0$ 周期\n- $X = 18$\n\n测试用例 C（直接映射抖动）：\n- $S = 2$, $A = 1$, $L = 4$\n- 阶段模式：$[0, 2, 4, 6]$\n- 命中时间 $H = 1.5$ 周期\n- 未命中惩罚 $M = 30.0$ 周期\n- $X = 8$\n\n每个测试用例所需的输出：\n- 稳态未命中率 $MR_{\\infty}$，以小数形式表示，四舍五入到小数点后 $6$ 位。\n- 达到稳态的时间 $t_{ss}$，以访问次数为单位的整数。\n- 一个完整稳态周期内的平均内存访问时间，以周期为单位，四舍五入到小数点后 $6$ 位。\n- 前 $X$ 次访问的平均内存访问时间，以周期为单位，四舍五入到小数点后 $6$ 位。\n- 累积未命中率 $MR(X)$，四舍五入到小数点后 $6$ 位。\n- 列表 $\\left[MR(L), MR(2L), \\dots, MR(i \\cdot L)\\right]$，其中每个元素都四舍五入到小数点后 $6$ 位。如果列表为空，则打印一个空列表。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按 A、B、C 顺序排列的三个测试用例的结果列表。每个测试用例的结果本身必须是以下形式的列表：\n$[MR_{\\infty}, t_{ss}, AMAT_{\\text{cycle}}, AMAT_{X}, MR(X), [MR(L), MR(2L), \\dots, MR(iL)]]$\n不含多余空格。整个输出为单行，格式如\n$[[\\dots],[\\dots],[\\dots]]$。", "solution": "该问题被评估为有效。这是一个在计算机体系结构领域中定义明确、有科学依据的问题，要求在重复的内存访问模式下，模拟采用 LRU 替换策略的组相联缓存。所有参数都已明确定义，且所需的度量指标——累积未命中率、稳态未命中率、达到稳态的时间以及平均内存访问时间——均基于标准的、形式化的定义。该问题可通过确定性模拟来解决。\n\n解决方案通过模拟缓存随时间变化的行为来进行。该方法的核心是在每次遍历重复的访问模式（称为一个阶段）结束时，跟踪缓存的完整状态。当一个阶段结束时的缓存状态与先前某个阶段结束时的状态相同时，就检测到了一个周期。\n\n**1. 数据结构**\n\n首先，我们定义缓存的结构。\n- **`CacheLine`**（缓存行）代表组内的单个块存储位置。它必须存储块的标记和一个有效位标志，以指示该行是否持有数据。对于块地址 $b$ 和 $S$ 个组，标记计算为 $tag = \\lfloor \\frac{b}{S} \\rfloor$。\n- **`CacheSet`**（缓存组）是 $A$ 个 `CacheLine` 的集合，其中 $A$ 是相联度。这些行按最近最少使用（LRU）顺序维护。一种简单有效的方法是使用一个数组，其中索引 $0$ 代表最近使用（MRU）的行，索引 $A-1$ 代表 LRU 行。\n- **`Cache`**（缓存）本身是一个包含 $S$ 个 `CacheSet` 的数组。\n\n为了检测稳态周期，我们必须记录每个阶段边界的缓存状态。**`CacheState`**（缓存状态）是在特定时间点，缓存中所有组的所有标记及其 LRU 顺序的快照。需要维护在时间 $t = 0, L, 2L, \\dots$ 采集的这些状态的历史记录。将新状态与所有先前记录的状态进行比较，以找到重复。\n\n**2. 模拟算法**\n\n模拟以离散时间步进，每一步对应一次内存访问。\n\n- **初始化**：在时间 $t=0$ 时，缓存为空（所有 `valid` 标志均为假）。总访问次数和总未命中次数初始化为 $0$。初始的空状态被记录为阶段 $0$ 开始时的状态，记作 $S_0$。\n\n- **主循环**：模拟按阶段迭代进行。在每个阶段 $p = 0, 1, 2, \\dots$ 中：\n    1. 对阶段模式中的 $L$ 个块地址中的每一个，模拟一次缓存访问。设当前时间为 $t$。块地址对应于模式中索引为 $((t-1) \\bmod L)$ 的元素。\n    2. 对于给定的块地址 $b$，目标组索引计算为 $set = b \\bmod S$，标记为 $tag = \\lfloor \\frac{b}{S} \\rfloor$。\n    3. 在相应的 `CacheSet` 中搜索具有匹配标记的有效行。\n        - **命中**：如果找到匹配项，则访问为命中。被访问的行移动到其组中的 MRU 位置（索引 $0$），所有先前比它更新近使用的行向 LRU 端移动一个位置。\n        - **未命中**：如果未找到匹配项，则访问为未命中。总未命中计数器递增。\n            - 如果组中有空闲（无效）的行，则将新块的标记放入第一个可用的无效行中，该行随后成为 MRU 行。\n            - 如果组已满，则替换 LRU 行（位于索引 $A-1$）。新块的标记被放置在 MRU 位置（索引 $0$），所有其他行向 LRU 端移动一个位置。\n    4. 在阶段 $p$ 结束时（经过 $L$ 次访问后），记录当前的缓存状态 $S_{p+1}$。将此状态与所有先前的阶段开始状态 $S_0, S_1, \\dots, S_p$ 的历史记录进行比较。\n    5. 如果找到匹配，例如对于某个 $k \\in \\{0, 1, \\dots, p\\}$ 有 $S_{p+1} = S_k$，则检测到了一个周期。模拟已达到重复模式。根据问题的定义，我们识别出最早的此类匹配，它给出了稳态周期的起始阶段 $i=k$ 和首次出现重复的阶段 $j=p+1$。\n    6. 模拟循环继续进行，直到找到一个周期并且模拟时间 $t$ 超过指定值 $X$。\n\n**3. 输出计算**\n\n一旦模拟终止，就使用记录的数据（每个阶段的未命中次数、周期索引 $i$ 和 $j$）来计算所需的度量指标。\n\n- **达到稳态的时间 ($t_{ss}$)**：瞬态或预热期由阶段 $0, 1, \\dots, i-1$ 组成。达到稳态的时间是此期间的总访问次数：$t_{ss} = i \\cdot L$。\n\n- **稳态未命中率 ($MR_{\\infty}$)**：稳态周期由阶段 $i, i+1, \\dots, j-1$ 组成。此周期内的未命中率是这些阶段中发生的总未命中次数除以总访问次数：\n$$MR_{\\infty} = \\frac{\\sum_{p=i}^{j-1} \\text{phase } p \\text{ 中的未命中数}}{(j-i) \\cdot L}$$\n\n- **稳态周期内的平均内存访问时间 ($AMAT_{\\text{cycle}}$)**：使用稳态未命中率以及给定的命中时间 $H$ 和未命中惩罚 $M$：\n$$AMAT_{\\text{cycle}} = H + (MR_{\\infty} \\cdot M)$$\n\n- **时间 $X$ 时的累积未命中率 ($MR(X)$)**：在模拟期间记录的直到访问 $X$ 为止的总未命中数除以 $X$：\n$$MR(X) = \\frac{\\text{访问 } 1 \\text{ 到 } X \\text{ 的总未命中数}}{X}$$\n\n- **前 $X$ 次访问的平均内存访问时间 ($AMAT_X$)**：\n$$AMAT_X = H + (MR(X) \\cdot M)$$\n\n- **瞬态累积未命中率列表**：这是列表 $[MR(L), MR(2L), \\dots, MR(iL)]$。对于每个 $k \\in \\{1, \\dots, i\\}$，累积未命中率计算如下：\n$$MR(kL) = \\frac{\\sum_{p=0}^{k-1} \\text{phase } p \\text{ 中的未命中数}}{k \\cdot L}$$\n如果 $i=0$，此列表为空。由于问题从空缓存开始，状态 $S_0$（空）永远不会重复，因此 $i \\ge 1$。", "answer": "[由于无法执行模拟，此处省略了测试用例的具体数值输出。]", "id": "3625959"}]}