{"hands_on_practices": [{"introduction": "The first step in leveraging a Program Dependence Graph is knowing how to construct one. This exercise provides hands-on practice in deriving control dependences from first principles. By applying the formal postdominator-based definition to a hypothetical code snippet with nested control structures, you will build the foundational skill needed to reason about program execution flow. [@problem_id:3664766]", "problem": "You are given the following structured snippet in imperative pseudocode with labeled lines. All assignments and conditions are written in mathematical notation, and each executable line is labeled $L_{k}$ for clarity. There is a single exit node $E$ placed immediately after the return.\n\n$L_{1}$: $s := 0$\n\n$L_{2}$: $i := 0$\n\n$L_{3}$: while $\\big(i  n\\big)$ do\n- $L_{4}$: if $\\big(p(i)\\big)$ then\n  - $L_{5}$: $s := s + a[i]$\n  - $L_{6}$: if $\\big(q(i)\\big)$ then\n    - $L_{7}$: $s := s + 1$\n    - else\n    - $L_{9}$: $s := s - 1$\n- else\n  - $L_{12}$: $j := 0$\n  - $L_{13}$: while $\\big(j  m\\big)$ do\n    - $L_{14}$: if $\\big(r(j)\\big)$ then\n      - $L_{15}$: $s := s + b[j]$\n    - end if\n    - $L_{17}$: $j := j + 1$\n  - end while\n- end if\n- $L_{20}$: $i := i + 1$\nend while\n\n$L_{22}$: return $s$\n\n$E$: exit\n\nConstruct the Control Flow Graph (CFG) for this snippet and then construct the Program Dependence Graph (PDG), restricting attention to control dependences only. Use the standard postdominator-based definition of control dependence on the CFG with a distinguished exit node. Specifically, a node $Y$ is control-dependent on a node $X$ if and only if there exists a successor $W$ of $X$ such that $Y$ postdominates $W$ and $Y$ does not postdominate $X$. A node $U$ postdominates a node $V$ if and only if every path from $V$ to $E$ passes through $U$.\n\nTreat each predicate line ($L_{3}$, $L_{4}$, $L_{6}$, $L_{13}$, $L_{14}$) and each executable statement line ($L_{1}$, $L_{2}$, $L_{5}$, $L_{7}$, $L_{9}$, $L_{12}$, $L_{15}$, $L_{17}$, $L_{20}$, $L_{22}$) as PDG nodes. Ignore any special entry node and do not add control dependence edges from an artificial start. Do not include the exit node $E$ as a PDG node.\n\nYour task: Based on the above definitions and this codeâ€™s CFG, identify all control dependence edges in the PDG and compute the total number of such edges. Provide the final answer as an exact integer (no rounding).", "solution": "The user wants to determine the total number of control dependence edges in the Program Dependence Graph (PDG) for a given code snippet. The analysis is to be based on the provided definition of control dependence using postdominators.\n\nThe solution process involves three sequential steps:\n1.  Construct the Control Flow Graph (CFG) for the given code.\n2.  Determine the postdominator set for each node in the CFG.\n3.  Apply the given definition of control dependence to identify all control dependence edges and count them.\n\n### Step 1: Construct the Control Flow Graph (CFG)\n\nThe nodes of the CFG correspond to the labeled lines of the pseudocode and a single exit node $E$. The edges represent the flow of control between these lines.\n\nThe CFG edges are as follows:\n- $L_{1} \\to L_{2}$\n- $L_{2} \\to L_{3}$\n- $L_{3} \\to L_{4}$ (true branch of `while`)\n- $L_{3} \\to L_{22}$ (false branch of `while`)\n- $L_{4} \\to L_{5}$ (true branch of `if p(i)`)\n- $L_{4} \\to L_{12}$ (false branch of `if p(i)`)\n- $L_{5} \\to L_{6}$\n- $L_{6} \\to L_{7}$ (true branch of `if q(i)`)\n- $L_{6} \\to L_{9}$ (false branch of `if q(i)`)\n- $L_{7} \\to L_{20}$ (end of `if q(i)` true branch)\n- $L_{9} \\to L_{20}$ (end of `if q(i)` false branch)\n- $L_{12} \\to L_{13}$\n- $L_{13} \\to L_{14}$ (true branch of `while`)\n- $L_{13} \\to L_{20}$ (false branch of `while`)\n- $L_{14} \\to L_{15}$ (true branch of `if r(j)`)\n- $L_{14} \\to L_{17}$ (false branch of `if r(j)`)\n- $L_{15} \\to L_{17}$ (end of `if r(j)` true branch)\n- $L_{17} \\to L_{13}$ (loop back)\n- $L_{20} \\to L_{3}$ (loop back)\n- $L_{22} \\to E$\n\n### Step 2: Determine Postdominators\n\nA node $U$ postdominates a node $V$ if every path from $V$ to the exit node $E$ contains $U$. We denote the set of postdominators of $V$ as $\\text{pdom}(V)$. We apply this definition to each node in the CFG.\n\n- $\\text{pdom}(E) = \\{E\\}$\n- From $L_{22}$, the only path to $E$ is $L_{22} \\to E$. Thus, $\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$.\n- From any node in the code, every path to $E$ must pass through $L_{22}$. So, $L_{22}$ postdominates all other nodes.\n- By systematically analyzing the CFG, we determine the postdominator set for each relevant node:\n  - $\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$\n  - $\\text{pdom}(L_{20}) = \\{L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{17}) = \\{L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{15}) = \\{L_{15}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{14})$: Paths from $L_{14}$ merge at $L_{17}$. So, $\\text{pdom}(L_{14}) = \\{L_{14}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$.\n  - $\\text{pdom}(L_{13})$: Paths from $L_{13}$ can loop, but must eventually exit to $L_{20}$. So, $\\text{pdom}(L_{13}) = \\{L_{13}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{13}, L_{20}, L_{3}, L_{22}, E\\}$.\n  - $\\text{pdom}(L_{12}) = \\{L_{12}\\} \\cup \\text{pdom}(L_{13}) = \\{L_{12}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{9}) = \\{L_{9}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{9}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{7}) = \\{L_{7}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{7}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{6})$: Paths from $L_6$ merge at $L_{20}$. So, $\\text{pdom}(L_{6}) = \\{L_{6}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{6}, L_{20}, L_{3}, L_{22}, E\\}$.\n  - $\\text{pdom}(L_{5}) = \\{L_{5}\\} \\cup \\text{pdom}(L_{6}) = \\{L_{5}, L_{6}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{4})$: Paths from $L_4$ merge at $L_{20}$. So, $\\text{pdom}(L_{4}) = \\{L_{4}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{4}, L_{20}, L_{3}, L_{22}, E\\}$.\n  - $\\text{pdom}(L_{3})$: Paths from $L_3$ can loop, but must eventually exit to $L_{22}$. So, $\\text{pdom}(L_{3}) = \\{L_{3}, L_{22}, E\\}$.\n\n### Step 3: Apply the Definition of Control Dependence\n\nThe problem states: \"a node $Y$ is control-dependent on a node $X$ if and only if there exists a successor $W$ of $X$ such that $Y$ postdominates $W$ and $Y$ does not postdominate $X$.\" Let's denote this by $X \\to_c Y$. We apply this definition to each predicate node $X$.\n\n**1. $X = L_3$ (predicate `while i  n`)**\n- Successors of $X$: $W_T = L_4$, $W_F = L_{22}$.\n- We need nodes $Y$ such that $Y \\in \\text{pdom}(W)$ and $Y \\notin \\text{pdom}(L_3)$.\n- For $W = L_4$: We need $Y \\in \\text{pdom}(L_4)$ and $Y \\notin \\text{pdom}(L_3)$.\n  - $\\text{pdom}(L_4) = \\{L_4, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_3) = \\{L_3, L_{22}, E\\}$\n  - The nodes in $\\text{pdom}(L_4)$ but not in $\\text{pdom}(L_3)$ are $\\{L_4, L_{20}\\}$.\n  - Edges: $(L_3, L_4), (L_3, L_{20})$. Total: 2.\n\n**2. $X = L_4$ (predicate `if p(i)`)**\n- Successors of $X$: $W_T = L_5$, $W_F = L_{12}$.\n- We need $Y$ such that $Y \\in \\text{pdom}(W)$ and $Y \\notin \\text{pdom}(L_4)$.\n  - $\\text{pdom}(L_4) = \\{L_4, L_{20}, L_3, L_{22}, E\\}$\n- For $W = L_5$: $\\text{pdom}(L_5) = \\{L_5, L_6, L_{20}, L_3, L_{22}, E\\}$. The nodes in this set but not in $\\text{pdom}(L_4)$ are $\\{L_5, L_6\\}$.\n- For $W = L_{12}$: $\\text{pdom}(L_{12}) = \\{L_{12}, L_{13}, L_{20}, L_3, L_{22}, E\\}$. The nodes in this set but not in $\\text{pdom}(L_4)$ are $\\{L_{12}, L_{13}\\}$.\n- Edges: $(L_4, L_5), (L_4, L_6), (L_4, L_{12}), (L_4, L_{13})$. Total: 4.\n\n**3. $X = L_6$ (predicate `if q(i)`)**\n- Successors of $X$: $W_T = L_7$, $W_F = L_9$.\n- We need $Y$ such that $Y \\in \\text{pdom}(W)$ and $Y \\notin \\text{pdom}(L_6)$.\n  - $\\text{pdom}(L_6) = \\{L_6, L_{20}, L_3, L_{22}, E\\}$\n- For $W = L_7$: $\\text{pdom}(L_7) = \\{L_7, L_{20}, L_3, L_{22}, E\\}$. The node in this set but not in $\\text{pdom}(L_6)$ is $\\{L_7\\}$.\n- For $W = L_9$: $\\text{pdom}(L_9) = \\{L_9, L_{20}, L_3, L_{22}, E\\}$. The node in this set but not in $\\text{pdom}(L_6)$ is $\\{L_9\\}$.\n- Edges: $(L_6, L_7), (L_6, L_9)$. Total: 2.\n\n**4. $X = L_{13}$ (predicate `while j  m`)**\n- Successors of $X$: $W_T = L_{14}$, $W_F = L_{20}$.\n- We need $Y$ such that $Y \\in \\text{pdom}(W)$ and $Y \\notin \\text{pdom}(L_{13})$.\n  - $\\text{pdom}(L_{13}) = \\{L_{13}, L_{20}, L_3, L_{22}, E\\}$\n- For $W = L_{14}$: $\\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$. The nodes in this set but not in $\\text{pdom}(L_{13})$ are $\\{L_{14}, L_{17}\\}$.\n- Edges: $(L_{13}, L_{14}), (L_{13}, L_{17})$. Total: 2.\n\n**5. $X = L_{14}$ (predicate `if r(j)`)**\n- Successors of $X$: $W_T = L_{15}$, $W_F = L_{17}$.\n- We need $Y$ such that $Y \\in \\text{pdom}(W)$ and $Y \\notin \\text{pdom}(L_{14})$.\n  - $\\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$\n- For $W = L_{15}$: $\\text{pdom}(L_{15}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$. The node in this set but not in $\\text{pdom}(L_{14})$ is $\\{L_{15}\\}$.\n- Edge: $(L_{14}, L_{15})$. Total: 1.\n\n### Final Count\nSumming the number of control dependence edges from each predicate node:\n- From $L_3$: $2$ edges\n- From $L_4$: $4$ edges\n- From $L_6$: $2$ edges\n- From $L_{13}$: $2$ edges\n- From $L_{14}$: $1$ edge\n\nTotal number of edges = $2 + 4 + 2 + 2 + 1 = 11$.", "answer": "$$\\boxed{11}$$", "id": "3664766"}, {"introduction": "Program Dependence Graphs are not just static representations; they evolve as compilers transform code. This practice explores if-conversion, an optimization that replaces conditional branches with predicated instructions. You will analyze how this transformation fundamentally alters the PDG, converting explicit control dependences into data dependences, which is a core concept in modern compiler design. [@problem_id:3664735]", "problem": "Consider the following structured fragment and its Control Flow Graph (CFG):\n\n- Code:\n  - if ($x  0$) then { $y := x + 1$ } else { $y := 0$ }\n  - $z := y * 2$\n\n- CFG nodes and edges:\n  - $B_0$ (entry) $\\to B_1$\n  - $B_1$: conditional on ($x  0$), true edge to $B_2$, false edge to $B_3$\n  - $B_2$: $y := x + 1$, then $\\to B_4$\n  - $B_3$: $y := 0$, then $\\to B_4$\n  - $B_4$: $z := y * 2$, then exit\n\nUse the standard definitions from compiler theory:\n\n- Control dependence in a Program Dependence Graph (PDG): A node $Y$ is control dependent on a node $X$ if and only if (i) there exists a path from $X$ to $Y$ on which $Y$ post-dominates every node except possibly $X$, and (ii) $Y$ does not post-dominate $X$.\n- Post-dominance in a Control Flow Graph (CFG): A node $A$ post-dominates a node $B$ if every path from $B$ to exit contains $A$.\n\nNow perform an if-conversion (predication) that removes the branch by introducing a predicate $p := (x  0)$ and a straight-line computation\n$y := select(p, x + 1, 0)$,\nfollowed by\n$z := y * 2$.\nAssume $select(p, t, e)$ denotes the value $t$ when $p$ is true and $e$ when $p$ is false.\n\nQuestion: Which statement correctly characterizes the control dependences in the $PDG$ before and after if-conversion, and specifies the correct $PDG$ update to reflect the removal of branch-based control dependences?\n\nChoose one:\n\nA. Before if-conversion: there are control dependence edges from the branch node $B_1$ to $y := x + 1$ (in $B_2$) and to $y := 0$ (in $B_3$), but not to $z := y * 2$ (in $B_4$). After if-conversion: the branch-based control dependences are removed; no control dependence emanates from $p$, and the $PDG$ gains a data dependence from the definition of $p$ to the $select$ that defines $y$.\n\nB. Before if-conversion: there are control dependence edges from $B_1$ to $y := x + 1$, to $y := 0$, and to $z := y * 2$. After if-conversion: control dependences remain because $z$ still semantically depends on the condition, so the $PDG$ retains a control dependence from $p$ to $z$.\n\nC. Before if-conversion: only $y := 0$ is control dependent on $B_1$ because it lies on the false edge; $y := x + 1$ is not control dependent. After if-conversion: both $y$ and $z$ are control dependent on $p$.\n\nD. Before if-conversion: there are no control dependences because both branches reconverge at $B_4$. After if-conversion: introduce a control dependence from $p$ to $z$ because $z$ follows the selection of $y$.", "solution": "This problem requires analyzing the control dependences in a Program Dependence Graph (PDG) before and after an if-conversion optimization.\n\n### Analysis Before If-Conversion\n\nFirst, we analyze the original code and its Control Flow Graph (CFG) to determine control dependences. The key is the concept of post-dominance. A node $A$ post-dominates a node $B$ if all paths from $B$ to the exit must pass through $A$.\n\n1.  **Post-dominance Analysis**:\n    *   The CFG shows a diamond structure. Paths from the conditional branch $B_1$ diverge to $B_2$ (true branch) and $B_3$ (false branch), and then reconverge at $B_4$.\n    *   Any path from $B_1$ to the exit (e.g., $B_1 \\to B_2 \\to B_4 \\to \\text{exit}$ or $B_1 \\to B_3 \\to B_4 \\to \\text{exit}$) must pass through $B_4$. Therefore, $B_4$ **post-dominates** $B_1$.\n    *   There is a path from $B_1$ to the exit that bypasses $B_2$ (the path through $B_3$). Therefore, $B_2$ **does not** post-dominate $B_1$.\n    *   Similarly, there is a path from $B_1$ to the exit that bypasses $B_3$ (the path through $B_2$). Therefore, $B_3$ **does not** post-dominate $B_1$.\n\n2.  **Control Dependence Analysis**: A node $Y$ is control dependent on $X$ if, among other things, $Y$ does not post-dominate $X$.\n    *   **Is $z := y * 2$ (in $B_4$) control dependent on $B_1$?** No. Since $B_4$ post-dominates $B_1$, the condition \"$Y$ does not post-dominate $X$\" is violated. The execution of $B_4$ is not conditional on the outcome of $B_1$; it always executes.\n    *   **Is $y := x + 1$ (in $B_2$) control dependent on $B_1$?** Yes. $B_2$ does not post-dominate $B_1$, and its execution is determined by the true outcome of the branch at $B_1$.\n    *   **Is $y := 0$ (in $B_3$) control dependent on $B_1$?** Yes. $B_3$ does not post-dominate $B_1$, and its execution is determined by the false outcome of the branch at $B_1$.\n\n    **Conclusion (Before)**: There are control dependence edges from $B_1$ to $B_2$ and from $B_1$ to $B_3$. There is no control dependence edge from $B_1$ to $B_4$.\n\n### Analysis After If-Conversion\n\nIf-conversion transforms the branching structure into a straight-line sequence of predicated instructions:\n1.  $p := (x > 0)$\n2.  $y := select(p, x + 1, 0)$\n3.  $z := y * 2$\n\n1.  **Control Flow**: The transformed code has no branches. It is a single basic block.\n2.  **Control Dependence**: Since there are no branches, there are no control dependences. All three statements execute unconditionally, one after the other.\n3.  **PDG Update**: The original control dependence from the branch is converted into a **data dependence**. The value of $y$ is now computed using a `$select` function that takes the predicate $p$ as an input. Thus, the PDG for the transformed code will show a true (flow) data dependence from the statement that defines $p$ to the statement that defines $y$ (because it uses $p$).\n\n### Evaluating the Options\n\n*   **A**: This option correctly states that before the transform, $B_2$ and $B_3$ are control dependent on $B_1$, but $B_4$ is not. It also correctly states that after the transform, the branch-based control dependences are gone and are replaced by a data dependence from the predicate `p` to the `select` instruction. This matches our analysis.\n*   **B**: Incorrect. It claims $z := y * 2$ is control dependent on $B_1$ before the transform, which is false. It also claims control dependence remains after the transform, which is false.\n*   **C**: Incorrect. It claims only one branch is control dependent, which is false. It also claims control dependences exist after the transform.\n*   **D**: Incorrect. It claims there are no control dependences before the transform, which is false. It also incorrectly introduces a control dependence after the transform instead of a data dependence.\n\nTherefore, option A is the only one that correctly describes the situation both before and after the if-conversion.", "answer": "$$\\boxed{A}$$", "id": "3664735"}, {"introduction": "A key motivation for constructing PDGs is to enable sophisticated optimizations like automatic parallelization. This exercise puts theory into practice by using data dependence analysis to determine if a loop can be safely parallelized. Identifying loop-carried dependences is crucial for this task, and this problem will guide you through the exact process using a hypothetical loop body. [@problem_id:3664740]", "problem": "Consider the following single loop over the integer induction variable $i$:\n- For $i$ ranging from $2$ to $N-1$ with $N \\geq 6$, execute the body consisting of three statements:\n  - $S_1$: $X[i+2] := Y[i] + Z[i-1]$,\n  - $S_2$: $Y[i+1] := X[i] + W[i]$,\n  - $S_3$: $Z[i-1] := Y[i-2] + 5$.\nAssume arrays $X$, $Y$, $Z$, and $W$ are sized and initialized so that all subscripts used are valid, and the semantics are the standard sequential semantics of a loop in a language with single-assignment per statement execution and strict evaluation order $S_1$ then $S_2$ then $S_3$ within each iteration.\n\nIn the Program Dependence Graph (PDG), nodes correspond to the statements $S_1$, $S_2$, and $S_3$, and edges capture control dependences and data dependences. A true data dependence (flow dependence) from a source statement to a sink statement exists when the source writes a memory location that the sink later reads, and a loop-carried true data dependence exists when the source and sink are in different iterations. Anti dependences and output dependences may be ignored for the purpose of determining parallelization legality because they can be eliminated by renaming.\n\nUsing only the foundational definitions of true data dependences, loop-carried dependences, and the fact that two array accesses refer to the same memory location if and only if their subscripts are equal, analyze the PDG induced by the loop body to:\n- Extract the set of loop-carried true data dependence distances based on the array subscripts in $S_1$, $S_2$, and $S_3$.\n- Let $\\mathcal{D}$ denote the set of all positive integer distances $d$ for loop-carried true dependences present in this loop. Define $d^{\\star}$ to be the minimum element of $\\mathcal{D}$, if $\\mathcal{D}$ is nonempty.\n- Define the legality indicator $L$ for parallelizing the loop across iterations under standard semantics as $L=1$ if the loop is legal to parallelize (that is, if there are no loop-carried true data dependences) and $L=0$ otherwise.\n\nProvide your final answer as a row matrix containing $d^{\\star}$ and $L$. No rounding is required, and no units are needed. If $\\mathcal{D}$ is empty, take $d^{\\star}$ to be $0$ by convention.", "solution": "To solve this problem, we must systematically search for all loop-carried true (flow) data dependences. A flow dependence occurs when a statement writes to a memory location that is later read by another statement. The dependence is loop-carried if the write and read occur in different iterations of the loop. Let $S_k(i)$ denote the execution of statement $S_k$ in iteration $i$. We are looking for dependences from $S_a(i)$ to $S_b(j)$ where $i  j$. The dependence distance is $d = j - i$.\n\nThe statements are:\n- $S_1: X[i+2] := Y[i] + Z[i-1]$ (Writes $X$, Reads $Y, Z$)\n- $S_2: Y[i+1] := X[i] + W[i]$ (Writes $Y$, Reads $X, W$)\n- $S_3: Z[i-1] := Y[i-2] + 5$ (Writes $Z$, Reads $Y$)\n\nWe check for dependences between pairs of statements on each array $X$, $Y$, and $Z$.\n\n**1. Dependences on Array X**\n- A statement must write to $X$ and another must read from $X$.\n- $S_1(i)$ writes to $X[i+2]$.\n- $S_2(j)$ reads from $X[j]$.\n- A dependence exists if the memory locations are identical: $i+2 = j$.\n- For this to be a loop-carried flow dependence, the write must be in an earlier iteration than the read: $i  j$.\n- Substituting $j=i+2$ into $i  j$ gives $i  i+2$, which is always true.\n- We have a loop-carried true dependence from $S_1$ to $S_2$ with distance $d = j - i = (i+2) - i = 2$.\n\n**2. Dependences on Array Y**\n- A statement must write to $Y$ and another must read from $Y$.\n- $S_2(i)$ writes to $Y[i+1]$.\n- $S_1(j)$ reads from $Y[j]$.\n- A dependence exists if $i+1 = j$.\n- Since $j=i+1$, the condition $i  j$ is met.\n- We have a loop-carried true dependence from $S_2$ to $S_1$ with distance $d = j - i = (i+1) - i = 1$.\n- $S_2(i)$ writes to $Y[i+1]$.\n- $S_3(j)$ reads from $Y[j-2]$.\n- A dependence exists if $i+1 = j-2$, which means $j = i+3$.\n- Since $j=i+3$, the condition $i  j$ is met.\n- We have a loop-carried true dependence from $S_2$ to $S_3$ with distance $d = j - i = (i+3) - i = 3$.\n\n**3. Dependences on Array Z**\n- A statement must write to $Z$ and another must read from $Z$.\n- $S_3(i)$ writes to $Z[i-1]$.\n- $S_1(j)$ reads from $Z[j-1]$.\n- A dependence exists if $i-1 = j-1$, which implies $i=j$.\n- This means the write and read would have to be in the same iteration. This is a loop-independent dependence, not a loop-carried one.\n- Furthermore, for a true (flow) dependence, the write must happen *before* the read. Within a single iteration $i$, the execution order is $S_1(i)$, $S_2(i)$, $S_3(i)$.\n- Here, the read is in $S_1(i)$ and the write is in $S_3(i)$. The read happens before the write. This is an anti-dependence, not a true dependence. The problem states to ignore anti-dependences. Thus, there is no loop-carried true dependence on array $Z$.\n\n**Summary and Final Calculation**\n- We have found the following loop-carried true dependence distances:\n  - From $S_1 \\to S_2$: distance $d=2$.\n  - From $S_2 \\to S_1$: distance $d=1$.\n  - From $S_2 \\to S_3$: distance $d=3$.\n- The set of all positive integer distances for loop-carried true dependences is $\\mathcal{D} = \\{1, 2, 3\\}$.\n- The minimum element of this set is $d^{\\star} = \\min(\\mathcal{D}) = 1$.\n- The legality indicator $L$ is $0$ because the loop is not legal to parallelize, as there are loop-carried true data dependences (i.e., $\\mathcal{D}$ is not empty).\n- The final answer is the row matrix containing $d^{\\star}$ and $L$.\n\nThe matrix is $\\begin{pmatrix}d^{\\star}  L\\end{pmatrix} = \\begin{pmatrix}1  0\\end{pmatrix}$.", "answer": "$$\\boxed{\\begin{pmatrix}1  0\\end{pmatrix}}$$", "id": "3664740"}]}