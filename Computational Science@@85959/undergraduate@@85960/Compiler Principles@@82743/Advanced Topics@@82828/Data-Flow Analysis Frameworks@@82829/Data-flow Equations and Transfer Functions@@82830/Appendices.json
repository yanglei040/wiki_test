{"hands_on_practices": [{"introduction": "Data-flow analysis begins with abstracting program properties into a mathematical structure called a lattice. This first practice challenges you to build such a structure from the ground up by combining simpler analyses—in this case, for a variable's sign and parity [@problem_id:3635977]. By deriving the transfer function for an arithmetic assignment, you will gain a concrete understanding of how abstract interpretation safely models program behavior.", "problem": "Consider a forward data-flow analysis that tracks, for each program point, the abstract sign and parity of each integer variable. The analysis uses a product lattice built from a sign lattice and a parity lattice, and uses a confluence operator at branch merges that is the greatest lower bound (meet) with respect to the chosen partial order. Your task is to derive this product lattice from first principles, craft the transfer function for the assignment $x := 2y + 1$, and reason about the information flow through a simple control-flow graph. Ultimately, you will compute the height of the product lattice. Report only this height as your final answer.\n\nStart from the following fundamentals:\n\n1. The analysis uses a finite lattice for sign information, denoted $\\mathcal{S}$, and a finite lattice for parity information, denoted $\\mathcal{P}$. Each lattice element abstracts a set of integers via a concretization function. The confluence operator at branch merges is the greatest lower bound (meet) in the lattice’s partial order.\n\n2. The sign lattice $\\mathcal{S}$ abstracts the following sets of integers: the set of all integers (denote the element by $\\mathsf{AnyS}$), negative integers (denote by $\\mathsf{Neg}$), zero (denote by $\\mathsf{Zero}$), positive integers (denote by $\\mathsf{Pos}$), and the empty set (denote by $\\mathsf{NoneS}$). The concretization function $\\gamma_{\\mathcal{S}}$ maps these elements to the corresponding sets of integers. The lattice order $\\preceq_{\\mathcal{S}}$ is defined by reverse set inclusion on concretizations: for $a, b \\in \\mathcal{S}$,\n$$\na \\preceq_{\\mathcal{S}} b \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n$$\nThus $\\mathsf{AnyS}$ is the least element and $\\mathsf{NoneS}$ is the greatest element of $\\mathcal{S}$; the elements $\\mathsf{Neg}$, $\\mathsf{Zero}$, and $\\mathsf{Pos}$ lie strictly between them and are pairwise incomparable. The meet operator $\\sqcap_{\\mathcal{S}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{S}}$.\n\n3. The parity lattice $\\mathcal{P}$ abstracts the following sets of integers: the set of all integers (denote the element by $\\mathsf{AnyP}$), the even integers (denote by $\\mathsf{Even}$), the odd integers (denote by $\\mathsf{Odd}$), and the empty set (denote by $\\mathsf{NoneP}$). The concretization function $\\gamma_{\\mathcal{P}}$ and the order $\\preceq_{\\mathcal{P}}$ are defined analogously by reverse set inclusion: for $p, q \\in \\mathcal{P}$,\n$$\np \\preceq_{\\mathcal{P}} q \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{P}}(p) \\supseteq \\gamma_{\\mathcal{P}}(q).\n$$\nThus $\\mathsf{AnyP}$ is the least element, $\\mathsf{NoneP}$ is the greatest element, and $\\mathsf{Even}$ and $\\mathsf{Odd}$ are incomparable atoms between them. The meet operator $\\sqcap_{\\mathcal{P}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{P}}$.\n\n4. The product lattice $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ is ordered componentwise: for $(s_{1}, p_{1}), (s_{2}, p_{2}) \\in \\mathcal{L}$,\n$$\n(s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\text{if and only if}\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\;\\text{and}\\;\\; p_{1} \\preceq_{\\mathcal{P}} p_{2}.\n$$\nThe meet is $\\sqcap_{\\mathcal{L}}$ given componentwise by\n$$\n(s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n$$\n\nYou are given the following straight-line control-flow graph with a single merge, using a nondeterministic conditional. Control Flow Graph (CFG) nodes are:\n- Entry node initializes the abstract state for both $x$ and $y$ to $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Then a branching node with two successors:\n  - Branch $B_{1}$ assigns $y := 0$.\n  - Branch $B_{2}$ assigns $y := -1$.\n- The two branches merge at node $M$, which assigns $x := 2y + 1$.\n- There are no further statements.\n\nTasks you must complete in your reasoning:\n- Use the fundamental definition of abstract interpretation for expressions to derive the transfer function $f_{n}$ at node $M$ for the assignment $x := 2y + 1$ on the product lattice $\\mathcal{L}$. Your derivation must explicitly argue from the arithmetic properties of doubling and adding one on abstract sign and parity.\n- Use the confluence operator at the merge to compute the abstract input for $M$ from the two predecessor facts, and then apply $f_{n}$ to obtain the abstract output for $x$ at $M$.\n- From the structural properties of product lattices and the definitions of $\\mathcal{S}$ and $\\mathcal{P}$ above, derive the height $h_{\\mathcal{L}}$ of the product lattice $\\mathcal{L}$, where the height is the number of elements in a longest strictly ascending chain under $\\preceq_{\\mathcal{L}}$.\n\nReport only the value of $h_{\\mathcal{L}}$ as your final answer. No rounding is required. No units are applicable.", "solution": "We begin by formalizing the abstract domains and the confluence operator precisely, then derive the transfer function for $x := 2y + 1$, compute the merge at $M$, and finally compute the height of the product lattice.\n\nFoundational setup of the base lattices:\n- The sign lattice $\\mathcal{S}$ consists of the elements $\\{\\mathsf{AnyS}, \\mathsf{Neg}, \\mathsf{Zero}, \\mathsf{Pos}, \\mathsf{NoneS}\\}$, with concretization $\\gamma_{\\mathcal{S}}$ given by:\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{AnyS}) = \\mathbb{Z}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Neg}) = \\{ n \\in \\mathbb{Z} \\mid n  0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Zero}) = \\{ 0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Pos}) = \\{ n \\in \\mathbb{Z} \\mid n  0 \\}$,\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{NoneS}) = \\varnothing$.\n  The partial order is defined by reverse set inclusion:\n  $$\n  a \\preceq_{\\mathcal{S}} b \\;\\;\\Leftrightarrow\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n  $$\n  Thus $\\mathsf{AnyS}$ is the least element, $\\mathsf{NoneS}$ is the greatest element, and the three atoms $\\mathsf{Neg}$, $\\mathsf{Zero}$, $\\mathsf{Pos}$ lie strictly between them and are pairwise incomparable. The meet $\\sqcap_{\\mathcal{S}}$ is the greatest lower bound with respect to $\\preceq_{\\mathcal{S}}$. Concretely, because $\\preceq_{\\mathcal{S}}$ is reverse-inclusion on concretizations, $\\sqcap_{\\mathcal{S}}$ corresponds to set union at the concrete level:\n  $$\n  \\gamma_{\\mathcal{S}}(a \\sqcap_{\\mathcal{S}} b) \\;=\\; \\gamma_{\\mathcal{S}}(a) \\cup \\gamma_{\\mathcal{S}}(b).\n  $$\n  Hence, for example, $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Pos} = \\mathsf{AnyS}$ and $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Zero} = \\mathsf{AnyS}$, while $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Neg} = \\mathsf{Neg}$.\n\n- The parity lattice $\\mathcal{P}$ consists of $\\{\\mathsf{AnyP}, \\mathsf{Even}, \\mathsf{Odd}, \\mathsf{NoneP}\\}$, with concretization $\\gamma_{\\mathcal{P}}$:\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{AnyP}) = \\mathbb{Z}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Even}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 0 \\pmod{2} \\}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Odd}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 1 \\pmod{2} \\}$,\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{NoneP}) = \\varnothing$.\n  The order is $\\preceq_{\\mathcal{P}}$ with the same reverse-inclusion definition, and the meet $\\sqcap_{\\mathcal{P}}$ satisfies\n  $$\n  \\gamma_{\\mathcal{P}}(p \\sqcap_{\\mathcal{P}} q) \\;=\\; \\gamma_{\\mathcal{P}}(p) \\cup \\gamma_{\\mathcal{P}}(q).\n  $$\n  Thus $\\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{AnyP}$ and $\\mathsf{Odd} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{Odd}$.\n\nProduct lattice and confluence:\n- The product lattice is $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ with componentwise order $\\preceq_{\\mathcal{L}}$ and meet $\\sqcap_{\\mathcal{L}}$:\n  $$\n  (s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\Leftrightarrow\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\wedge\\; p_{1} \\preceq_{\\mathcal{P}} p_{2},\n  $$\n  $$\n  (s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n  $$\n  At branch merges, we use $\\sqcap_{\\mathcal{L}}$ as the confluence operator.\n\nTransfer function for $x := 2y + 1$:\n- We derive the abstract effect on parity and sign separately and then combine them.\n\nParity component. For any integer $y$, $2y$ is even and $2y + 1$ is odd. Therefore, regardless of the incoming parity of $y$ (except the unreachable $\\mathsf{NoneP}$), the parity of $x := 2y+1$ is deterministically $\\mathsf{Odd}$. Formally, define $f^{\\mathcal{P}}_{n} : \\mathcal{P} \\to \\mathcal{P}$ by\n$$\nf^{\\mathcal{P}}_{n}(p) \\;=\\; \n\\begin{cases}\n\\mathsf{Odd},  \\text{if } p \\neq \\mathsf{NoneP}, \\\\[4pt]\n\\mathsf{NoneP},  \\text{if } p = \\mathsf{NoneP}.\n\\end{cases}\n$$\n\nSign component. For any integer $y$, $2y + 1 \\neq 0$ because $2y$ is even and adding $1$ yields an odd number. The sign of $2y + 1$ is positive if $y \\geq 0$ and negative if $y \\leq -1$. On abstract elements, the precise result depends on the input:\n- If $y$ is exactly $\\mathsf{Zero}$, then $x = 1$ so the sign is $\\mathsf{Pos}$.\n- If $y$ is exactly $\\mathsf{Pos}$, then $2y + 1 \\geq 3$, so the sign is $\\mathsf{Pos}$.\n- If $y$ is exactly $\\mathsf{Neg}$, then $2y + 1 \\leq -1$, so the sign is $\\mathsf{Neg}$.\n- If $y$ is $\\mathsf{AnyS}$, then the concrete set of possible signs is $\\{\\mathsf{Neg}, \\mathsf{Pos}\\}$; since our lattice does not have a dedicated $\\mathsf{NonZero}$ element, the most precise representable abstract sign is $\\mathsf{AnyS}$.\n- If $y$ is $\\mathsf{NoneS}$, then the output is $\\mathsf{NoneS}$.\n\nThus define $f^{\\mathcal{S}}_{n} : \\mathcal{S} \\to \\mathcal{S}$ by\n$$\nf^{\\mathcal{S}}_{n}(s) \\;=\\;\n\\begin{cases}\n\\mathsf{Pos},  \\text{if } s \\in \\{ \\mathsf{Zero}, \\mathsf{Pos} \\}, \\\\[4pt]\n\\mathsf{Neg},  \\text{if } s = \\mathsf{Neg}, \\\\[4pt]\n\\mathsf{AnyS},  \\text{if } s = \\mathsf{AnyS}, \\\\[4pt]\n\\mathsf{NoneS},  \\text{if } s = \\mathsf{NoneS}.\n\\end{cases}\n$$\n\nProduct transfer function. The node $M$ assigns $x := 2y+1$ and leaves $y$ unchanged. Therefore, the transfer function $f_{n} : \\mathcal{L}^{\\{x,y\\}} \\to \\mathcal{L}^{\\{x,y\\}}$ on environments for variables $\\{x,y\\}$ is\n$$\nf_{n}\\big((s_{x}, p_{x}), (s_{y}, p_{y})\\big) \\;=\\; \\Big( \\big(f^{\\mathcal{S}}_{n}(s_{y}),\\, f^{\\mathcal{P}}_{n}(p_{y})\\big),\\; (s_{y}, p_{y}) \\Big),\n$$\nwhere the first component is the new abstract value for $x$ and the second is the unchanged abstract value for $y$.\n\nFlow through the control-flow graph:\n- Entry initializes both $x$ and $y$ to $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Branch $B_{1}$ assigns $y := 0$, so the abstract fact at the end of $B_{1}$ for $y$ is $(\\mathsf{Zero}, \\mathsf{Even})$; $x$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n- Branch $B_{2}$ assigns $y := -1$, so the abstract fact at the end of $B_{2}$ for $y$ is $(\\mathsf{Neg}, \\mathsf{Odd})$; $x$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$.\n\nConfluence at $M$ uses the meet $\\sqcap_{\\mathcal{L}}$ componentwise (recall that under our reverse-inclusion order this operator corresponds to taking the union of concretizations). For $y$’s input to $M$ we have\n$$\n(\\mathsf{Zero}, \\mathsf{Even}) \\;\\sqcap_{\\mathcal{L}}\\; (\\mathsf{Neg}, \\mathsf{Odd}) \\;=\\; \\big(\\,\\mathsf{Zero} \\sqcap_{\\mathcal{S}} \\mathsf{Neg},\\; \\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd}\\,\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{AnyP}).\n$$\nApplying $f_{n}$ at $M$ then yields for $x$:\n$$\n\\big(f^{\\mathcal{S}}_{n}(\\mathsf{AnyS}),\\; f^{\\mathcal{P}}_{n}(\\mathsf{AnyP})\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{Odd}),\n$$\nand $y$ remains $(\\mathsf{AnyS}, \\mathsf{AnyP})$. This illustrates that the joint product abstraction captures the guaranteed odd parity of $2y+1$ while sign cannot be refined beyond $\\mathsf{AnyS}$ in this domain.\n\nHeight of the product lattice:\n- The height of a finite poset is the number of elements in a longest strictly ascending chain. For $\\mathcal{S}$, the longest chain under $\\preceq_{\\mathcal{S}}$ is\n$$\n\\mathsf{AnyS} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{Neg} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{NoneS},\n$$\nor similarly using $\\mathsf{Zero}$ or $\\mathsf{Pos}$ as the middle atom. Thus the height of $\\mathcal{S}$ is\n$$\nh_{\\mathcal{S}} \\;=\\; 3.\n$$\n- For $\\mathcal{P}$, the longest chain under $\\preceq_{\\mathcal{P}}$ is\n$$\n\\mathsf{AnyP} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{Even} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{NoneP},\n$$\nor with $\\mathsf{Odd}$ as the middle atom. Thus\n$$\nh_{\\mathcal{P}} \\;=\\; 3.\n$$\n- For the product lattice $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ with componentwise order, the height satisfies\n$$\nh_{\\mathcal{L}} \\;=\\; h_{\\mathcal{S}} \\;+\\; h_{\\mathcal{P}} \\;-\\; 1,\n$$\nbecause any strictly ascending chain in the product must increase in at least one component at each step, and we can interleave maximal chains from $\\mathcal{S}$ and $\\mathcal{P}$ while noting the shared starting element. Substituting the values gives\n$$\nh_{\\mathcal{L}} \\;=\\; 3 \\;+\\; 3 \\;-\\; 1 \\;=\\; 5.\n$$\n\nTherefore, the height of the product lattice is $5$.", "answer": "$$\\boxed{5}$$", "id": "3635977"}, {"introduction": "With an understanding of abstract domains, we can now apply them to a full control-flow graph. This exercise focuses on Reaching Definitions, a classic \"may\" analysis, and explores the practical implications of unreachable code [@problem_id:3635901]. You will see how a worklist algorithm, when correctly initialized, naturally discovers which parts of a program are executable and avoids propagating spurious information from those that are not.", "problem": "Consider a forward data-flow analysis on a Control Flow Graph (CFG), where Control Flow Graph (CFG) denotes a directed graph of basic blocks with edges corresponding to possible control transfers. You are given a program with four basic blocks: $B_{\\mathrm{entry}}$, $B_{1}$, $B_{2}$, and $B_{3}$. The blocks and edges are as follows.\n\n- Block $B_{\\mathrm{entry}}$: contains the single statement $y := 0$, then an unconditional jump to $B_{2}$.\n- Block $B_{1}$: contains a loop that never receives control from $B_{\\mathrm{entry}}$ (it is unreachable from $B_{\\mathrm{entry}}$). Its statements are $x := 7$ and then a conditional branch that either jumps back to $B_{1}$ or jumps to $B_{3}$. Thus, $B_{1}$ has a self-loop edge and an edge to $B_{3}$, but there is no incoming edge to $B_{1}$ from any block reachable from $B_{\\mathrm{entry}}$.\n- Block $B_{2}$: contains the single statement $x := 1$, then an unconditional jump to $B_{3}$.\n- Block $B_{3}$: contains the single statement $z := x$. There are two incoming edges to $B_{3}$: one from $B_{2}$ and one from $B_{1}$.\n\nFormally, the edge set is $\\{(B_{\\mathrm{entry}},B_{2}),(B_{1},B_{1}),(B_{1},B_{3}),(B_{2},B_{3})\\}$.\n\nLet the data-flow problem be Reaching Definitions for the single variable $x$ only. The domain consists of definition sites of $x$, which are:\n- $d_{u}$: the definition $x := 7$ in $B_{1}$,\n- $d_{r}$: the definition $x := 1$ in $B_{2}$.\n\nUse the monotone framework for forward, path-insensitive, may analyses over the finite powerset lattice, starting from core definitions only (lattice ordering and meet for “may,” block-local $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets, and the standard composition of transfer functions). Assume a standard worklist solver that:\n- initializes $\\mathrm{IN}[B_{\\mathrm{entry}}]$ to the least element $\\bot$ of the lattice,\n- initializes all other data-flow sets to $\\bot$,\n- seeds the worklist with only $B_{\\mathrm{entry}}$ and then propagates along CFG edges until a fixed point is reached.\n\nDerive the data-flow equations from these principles and solve them to the fixed point under the specified boundary condition. In particular, determine the number of distinct reaching definitions of $x$ at the entry of $B_{3}$ (that is, the cardinality of $\\mathrm{IN}[B_{3}]$ for $x$) produced by the solver under the given boundary condition. As part of your reasoning, justify why the unreachable loop in $B_{1}$ does not taint the solution at $B_{3}$ when $\\mathrm{IN}[B_{\\mathrm{entry}}]=\\bot$, and explain why this boundary condition matters in the presence of unreachable code.\n\nReport only the final number. No rounding is required.", "solution": "The problem is valid as it is self-contained, scientifically grounded in the principles of compiler theory, and objectively formulated. We shall proceed with a formal solution.\n\nThe problem asks for the number of reaching definitions for the variable $x$ at the entry of basic block $B_{3}$. This is a forward, \"may\" data-flow analysis problem.\n\n### 1. Formal Framework\n- **Direction**: Forward analysis.\n- **Set of Definitions for $x$**: $D = \\{d_{u}, d_{r}\\}$, where $d_{u}$ is $x := 7$ in $B_1$ and $d_{r}$ is $x := 1$ in $B_2$.\n- **Domain**: The lattice is the powerset of $D$, denoted $\\mathcal{P}(D)$. The elements are sets of reaching definitions.\n- **Lattice Properties**:\n    - The partial order is set inclusion, $\\subseteq$.\n    - The meet operator ($\\wedge$) for a \"may\" analysis is set union, $\\cup$. This is used at join points in the Control Flow Graph (CFG).\n    - The bottom element is $\\bot = \\emptyset$, representing no definitions reach.\n    - The top element is $T = D = \\{d_{u}, d_{r}\\}$, representing all definitions may reach.\n- **Data-flow Equations**: For a basic block $B$, the IN and OUT sets are related by:\n$$ \\mathrm{OUT}[B] = F_B(\\mathrm{IN}[B]) $$\n$$ \\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\nwhere $\\mathrm{pred}(B)$ is the set of predecessors of $B$. For the entry block, $\\mathrm{IN}[B_{\\mathrm{entry}}]$ is a boundary condition.\n\n### 2. GEN and KILL Sets\nThe transfer function $F_B$ for a block $B$ is defined using its local effects, captured by $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets. For a set of incoming definitions $S$, the outgoing definitions are $F_B(S) = (S \\setminus \\mathrm{KILL}_B) \\cup \\mathrm{GEN}_B$. We determine these sets for each block with respect to the variable $x$.\n\n- **Block $B_{\\mathrm{entry}}$**: Contains $y := 0$. This does not define or use $x$.\n    - $\\mathrm{GEN}[B_{\\mathrm{entry}}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{\\mathrm{entry}}] = \\emptyset$\n\n- **Block $B_{1}$**: Contains $x := 7$ (definition $d_{u}$). This definition kills all other definitions of $x$.\n    - $\\mathrm{GEN}[B_{1}] = \\{d_u\\}$\n    - $\\mathrm{KILL}[B_{1}] = D \\setminus \\{d_u\\} = \\{d_r\\}$\n\n- **Block $B_{2}$**: Contains $x := 1$ (definition $d_{r}$). This definition kills all other definitions of $x$.\n    - $\\mathrm{GEN}[B_{2}] = \\{d_r\\}$\n    - $\\mathrm{KILL}[B_{2}] = D \\setminus \\{d_r\\} = \\{d_u\\}$\n\n- **Block $B_{3}$**: Contains $z := x$. This does not define $x$.\n    - $\\mathrm{GEN}[B_{3}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{3}] = \\emptyset$\n\n### 3. Transfer Functions\nBased on the $\\mathrm{GEN}$ and $\\mathrm{KILL}$ sets, the transfer functions are:\n- $F_{B_{\\mathrm{entry}}}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n- $F_{B_1}(S) = (S \\setminus \\{d_r\\}) \\cup \\{d_u\\}$\n- $F_{B_2}(S) = (S \\setminus \\{d_u\\}) \\cup \\{d_r\\}$\n- $F_{B_3}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n\n### 4. Worklist Algorithm Simulation\nThe problem specifies a worklist solver with the following initialization:\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\bot = \\emptyset$.\n- For all other blocks $B \\neq B_{\\mathrm{entry}}$, all data-flow sets (IN and OUT) are initialized to $\\bot = \\emptyset$.\n- The worklist is seeded with only the entry block: $W = \\{B_{\\mathrm{entry}}\\}$.\n\nLet's trace the execution of the algorithm.\n\n**Initial State:**\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\emptyset$, $\\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$\n- $\\mathrm{IN}[B_{1}] = \\emptyset$, $\\mathrm{OUT}[B_{1}] = \\emptyset$\n- $\\mathrm{IN}[B_{2}] = \\emptyset$, $\\mathrm{OUT}[B_{2}] = \\emptyset$\n- $\\mathrm{IN}[B_{3}] = \\emptyset$, $\\mathrm{OUT}[B_{3}] = \\emptyset$\n- $W = \\{B_{\\mathrm{entry}}\\}$\n\n**Step 1:**\n- Pop $B_{\\mathrm{entry}}$ from $W$. ($W = \\emptyset$)\n- $\\mathrm{IN}[B_{\\mathrm{entry}}]$ is the boundary condition $\\emptyset$.\n- Compute new $\\mathrm{OUT}[B_{\\mathrm{entry}}]$: $F_{B_{\\mathrm{entry}}}(\\emptyset) = \\emptyset$.\n- The value of $\\mathrm{OUT}[B_{\\mathrm{entry}}]$ does not change from its initial value of $\\emptyset$.\n- The algorithm propagates to successors. The successor of $B_{\\mathrm{entry}}$ is $B_2$.\n- Add $B_2$ to $W$. ($W = \\{B_2\\}$)\n\n**Step 2:**\n- Pop $B_2$ from $W$. ($W = \\emptyset$)\n- Compute $\\mathrm{IN}[B_2]$: $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$.\n- Compute new $\\mathrm{OUT}[B_2]$: $new\\_OUT = F_{B_2}(\\mathrm{IN}[B_2]) = F_{B_2}(\\emptyset) = (\\emptyset \\setminus \\{d_u\\}) \\cup \\{d_r\\} = \\{d_r\\}$.\n- The current $\\mathrm{OUT}[B_2]$ is $\\emptyset$. Since $new\\_OUT \\neq \\mathrm{OUT}[B_2]$, we update: $\\mathrm{OUT}[B_2] := \\{d_r\\}$.\n- The successor of $B_2$ is $B_3$.\n- Add $B_3$ to $W$. ($W = \\{B_3\\}$)\n\n**Step 3:**\n- Pop $B_3$ from $W$. ($W = \\emptyset$)\n- Compute $\\mathrm{IN}[B_3]$. The predecessors of $B_3$ are $B_1$ and $B_2$.\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$.\n- From the initial state, $\\mathrm{OUT}[B_1]$ is still $\\emptyset$. From Step 2, $\\mathrm{OUT}[B_2]$ is $\\{d_r\\}$.\n- $\\mathrm{IN}[B_3] = \\emptyset \\cup \\{d_r\\} = \\{d_r\\}$.\n- Compute new $\\mathrm{OUT}[B_3]$: $new\\_OUT = F_{B_3}(\\mathrm{IN}[B_3]) = F_{B_3}(\\{d_r\\}) = \\{d_r\\}$.\n- The current $\\mathrm{OUT}[B_3]$ is $\\emptyset$. Since $new\\_OUT \\neq \\mathrm{OUT}[B_3]$, we update: $\\mathrm{OUT}[B_3] := \\{d_r\\}$.\n- Block $B_3$ has no successors, so no blocks are added to the worklist.\n\n**Termination:**\n- The worklist $W$ is now empty. The algorithm terminates.\n\n**Final Fixed-Point Solution:**\n- $\\mathrm{IN}[B_3] = \\{d_r\\}$\n- The cardinality of this set is $|\\mathrm{IN}[B_3]| = |\\{d_r\\}| = 1$.\n\n### 5. Justification Regarding Unreachable Code\nThe problem asks why the unreachable loop in $B_1$ does not \"taint\" the solution and why the boundary and initialization conditions are important.\n\nThe worklist algorithm specified begins with only the entry block $B_{\\mathrm{entry}}$ on the worklist. New blocks are added to the worklist only when they are successors of a block whose OUT set has changed. Since there is no path in the CFG from $B_{\\mathrm{entry}}$ to $B_1$, $B_1$ is never added to the worklist.\n\nConsequently, the data-flow sets for $B_1$, specifically $\\mathrm{OUT}[B_1]$, remain at their initial value of $\\bot = \\emptyset$ throughout the analysis. When computing the input for $B_3$, the join operation is $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$. With $\\mathrm{OUT}[B_1]=\\emptyset$, this becomes $\\mathrm{IN}[B_3] = \\emptyset \\cup \\mathrm{OUT}[B_2] = \\mathrm{OUT}[B_2]$. The value $\\emptyset$ is the identity element for the set union operator, so the contribution from the unreachable block $B_1$ has no effect on the result.\n\nThe initialization scheme is critical. If, for instance, a different algorithm were used, such as a naive iterative method that processes all blocks in each round regardless of reachability, the result would be less precise. Such an algorithm would compute $\\mathrm{OUT}[B_1]=\\{d_u\\}$ and propagate it to $B_3$, yielding $\\mathrm{IN}[B_3] = \\{d_u, d_r\\}$. The specified initialization ($\\mathrm{IN}[B] = \\bot$ for all $B \\neq B_{\\mathrm{entry}}$) and starting the worklist with only $B_{\\mathrm{entry}}$ ensures that the analysis is path-sensitive with respect to reachability from the program entry. This produces the most precise solution possible for a path-insensitive analysis, correctly reflecting that definitions from unreachable code cannot reach any point in the executable part of the program.\n\nThe final answer is the cardinality of the set of reaching definitions at the entry of $B_3$. As derived, $\\mathrm{IN}[B_3] = \\{d_r\\}$. The number of definitions is $1$.", "answer": "$$\\boxed{1}$$", "id": "3635901"}, {"introduction": "To complete our exploration, we now turn to the counterpart of \"may\" analysis: \"must\" analysis. This practice examines Available Expressions and highlights the crucial differences in the data-flow framework, particularly the meet operator and initialization strategy [@problem_id:3635923]. By analyzing a control-flow graph with an unreachable path, you will solidify your understanding of the duality between proving a property *may* be true versus proving it *must* be true.", "problem": "Consider a Control Flow Graph (CFG) for a program fragment with nodes $N_0$ (entry), $N_1$, $N_2$, and $N_3$ and directed edges $N_0 \\rightarrow N_1$, $N_1 \\rightarrow N_3$, and $N_2 \\rightarrow N_3$. Node $N_2$ has no incoming edges from the entry $N_0$ and is therefore unreachable. The statements in each basic block are:\n- $N_1$: $t_1 = a + b;$ then $t_2 = a * c;$ then $c = t_2;$ \n- $N_2$: no statements,\n- $N_3$: no statements,\n- $N_0$: no statements (entry).\n\nLet the data-flow problem be the forward must analysis of Available Expressions, defined over the powerset lattice of the set of all arithmetic expressions appearing syntactically in the program, with the universe $\\mathcal{E} = \\{a+b, a\\ast c\\}$. The partial order is set inclusion $\\subseteq$, the meet operator at control-flow joins is set intersection, the top element is $\\top = \\mathcal{E}$, and the bottom element is $\\bot = \\varnothing$. The boundary condition is $IN[N_0] = \\varnothing$, and for any node $n$ with no predecessors other than the entry (in particular, an unreachable node), $IN[n]$ is initialized to $\\top$.\n\nFor Available Expressions, the per-block transfer function is\n$$OUT[n] = GEN[n] \\cup \\bigl(IN[n] \\setminus KILL[n]\\bigr),$$\nwhere $GEN[n]$ contains expressions definitely evaluated in $n$ and not subsequently killed within $n$, and $KILL[n]$ contains all expressions in $\\mathcal{E}$ that mention any variable assigned in $n$. The confluence equation at a join is\n$$IN[n] = \\bigcap_{p \\in pred(n)} OUT[p].$$\n\nUsing these definitions, compute $IN[N_3]$ at the maximal fixed point and assess the effect of the unreachable predecessor $N_2$ supplying $\\top$ at the join into $N_3$.\n\nWhich option is correct?\n- A. $IN[N_3] = \\{a+b\\}$; the unreachable predecessor supplies $\\top$ and has no effect because $\\top$ is the identity for intersection.\n\n- B. $IN[N_3] = \\{a+b, a\\ast c\\}$; the unreachable predecessor forces $\\top$ at the join.\n\n- C. $IN[N_3] = \\varnothing$; the intersection collapses to $\\bot$ due to including an unreachable predecessor.\n\n- D. $IN[N_3] = \\{a\\ast c\\}$; the unreachable predecessor kills $a+b$ and only $a\\ast c$ remains available.", "solution": "### Step 1: Extract Givens\n\nThe problem statement provides the following information:\n1.  **Control Flow Graph (CFG)**:\n    -   Nodes: $N_0$ (entry), $N_1$, $N_2$, $N_3$.\n    -   Edges: $N_0 \\rightarrow N_1$, $N_1 \\rightarrow N_3$, $N_2 \\rightarrow N_3$.\n    -   Node $N_2$ is unreachable as it has no incoming edges originating from the entry block $N_0$. In fact, it has no incoming edges at all.\n    -   $pred(N_1) = \\{N_0\\}$\n    -   $pred(N_2) = \\varnothing$\n    -   $pred(N_3) = \\{N_1, N_2\\}$\n\n2.  **Basic Block Statements**:\n    -   $N_1$: $t_1 = a + b$; then $t_2 = a * c$; then $c = t_2$;\n    -   $N_2$: no statements.\n    -   $N_3$: no statements.\n    -   $N_0$: no statements (entry).\n\n3.  **Data-Flow Analysis Framework**:\n    -   Problem: Forward \"must\" analysis of Available Expressions.\n    -   Domain: The powerset of $\\mathcal{E} = \\{a+b, a\\ast c\\}$.\n    -   Lattice:\n        -   Partial Order: Set inclusion, $\\subseteq$.\n        -   Meet Operator: Set intersection, $\\cap$.\n        -   Top Element: $\\top = \\mathcal{E} = \\{a+b, a\\ast c\\}$.\n        -   Bottom Element: $\\bot = \\varnothing$.\n    -   Boundary Condition: $IN[N_0] = \\varnothing$.\n    -   Initialization for unreachable nodes: For a node $n$ with no predecessors (such as $N_2$), $IN[n]$ is initialized to $\\top$.\n    -   Transfer Function: $OUT[n] = GEN[n] \\cup \\bigl(IN[n] \\setminus KILL[n]\\bigr)$.\n    -   Confluence Equation: $IN[n] = \\bigcap_{p \\in pred(n)} OUT[p]$.\n\n4.  **$GEN$ and $KILL$ Sets**:\n    -   $GEN[n]$: Expressions evaluated in $n$ and not subsequently killed within $n$.\n    -   $KILL[n]$: All expressions in $\\mathcal{E}$ that mention any variable assigned in $n$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a standard data-flow analysis problem from compiler theory.\n-   **Scientifically Grounded**: The concepts of Control Flow Graphs, basic blocks, Available Expressions analysis, data-flow equations, lattices (powerset, $\\cap$, $\\subseteq$), and fixed-point iteration are all fundamental and well-established in the field of compiler design. The setup is scientifically and mathematically sound.\n-   **Well-Posed**: The problem is well-defined. It provides a specific CFG, a complete data-flow framework (lattice, transfer functions, boundary conditions), and asks for a specific value ($IN[N_3]$) at the fixed point. The standard iterative algorithm for data-flow analysis guarantees convergence to a unique maximal fixed point for this type of problem.\n-   **Objective**: The language is precise and technical. All terms like \"must analysis\", \"available expressions\", \"GEN/KILL sets\", and the data flow equations themselves have standard, unambiguous definitions in the context of compiler theory.\n-   **Completeness and Consistency**: The problem provides all necessary information. The handling of the unreachable node $N_2$ is explicitly defined, both by its lack of predecessors and by the rule for initializing its $IN$ set. This rule is consistent with the general theory of data-flow analysis, where the meet over an empty set of predecessors is the top element of the lattice.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-posed, internally consistent, and standard problem in compiler theory. I will proceed with the solution derivation.\n\n### Solution Derivation\n\nFirst, we must determine the $GEN$ and $KILL$ sets for each basic block based on the provided definitions. The universe of expressions is $\\mathcal{E} = \\{a+b, a\\ast c\\}$.\n\n-   **Block $N_0$**: No statements.\n    -   $GEN[N_0] = \\varnothing$\n    -   $KILL[N_0] = \\varnothing$\n\n-   **Block $N_1$**: Statements are $t_1 = a + b$; then $t_2 = a * c$; then $c = t_2$;.\n    -   The expression $a+b$ is evaluated. No subsequent assignment in $N_1$ modifies $a$ or $b$. Thus, $a+b$ is generated and not killed within the block.\n    -   The expression $a\\ast c$ is evaluated. However, there is a subsequent assignment to the variable $c$ within the same block ($c = t_2$). Therefore, the expression $a\\ast c$ is not available at the exit of the block. It is not in $GEN[N_1]$.\n    -   $GEN[N_1] = \\{a+b\\}$.\n    -   The variable $c$ is assigned a value in $N_1$. Any expression in $\\mathcal{E}$ containing $c$ is killed. The expression $a\\ast c$ contains $c$.\n    -   $KILL[N_1] = \\{a\\ast c\\}$.\n\n-   **Block $N_2$**: No statements.\n    -   $GEN[N_2] = \\varnothing$\n    -   $KILL[N_2] = \\varnothing$\n\n-   **Block $N_3$**: No statements.\n    -   $GEN[N_3] = \\varnothing$\n    -   $KILL[N_3] = \\varnothing$\n\nNow, we set up and solve the data-flow equations using a standard iterative worklist algorithm to find the maximal fixed point. We are solving for the $IN$ and $OUT$ sets for each node.\n\n**Initialization:**\n-   $IN[N_0] = \\varnothing$ (Boundary condition)\n-   For a forward analysis, we can initialize all other $IN$ sets to the top element $\\top$ to start the iteration towards the maximal fixed point. This is consistent with the specified rule for unreachable nodes.\n-   $IN[N_1] = \\top = \\{a+b, a\\ast c\\}$\n-   $IN[N_2] = \\top = \\{a+b, a\\ast c\\}$\n-   $IN[N_3] = \\top = \\{a+b, a\\ast c\\}$\n-   We compute the initial $OUT$ sets. Let's start with $OUT[n]=\\varnothing$ for all $n$ except for nodes whose $IN$ sets might change and iterate. A more formal approach is to initialize all OUT sets except for the entry node's to $\\top$ and iterate. Let's trace the values.\n\n**Iteration loop:**\nWe compute the sets until they stabilize.\n\n1.  **Entry Node $N_0$**:\n    -   $IN[N_0] = \\varnothing$ (fixed).\n    -   $OUT[N_0] = GEN[N_0] \\cup (IN[N_0] \\setminus KILL[N_0]) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$.\n\n2.  **Node $N_1$**:\n    -   $IN[N_1] = OUT[N_0] = \\varnothing$.\n    -   $OUT[N_1] = GEN[N_1] \\cup (IN[N_1] \\setminus KILL[N_1]) = \\{a+b\\} \\cup (\\varnothing \\setminus \\{a\\ast c\\}) = \\{a+b\\}$.\n\n3.  **Node $N_2$** (Unreachable):\n    -   Node $N_2$ has no predecessors, $pred(N_2) = \\varnothing$.\n    -   The confluence equation is $IN[N_2] = \\bigcap_{p \\in pred(N_2)} OUT[p] = \\bigcap_{p \\in \\varnothing} OUT[p]$.\n    -   The intersection (meet) over an empty set is defined as the top element of the lattice.\n    -   Therefore, $IN[N_2] = \\top = \\{a+b, a\\ast c\\}$. This value is fixed and will not change throughout the iteration.\n    -   $OUT[N_2] = GEN[N_2] \\cup (IN[N_2] \\setminus KILL[N_2]) = \\varnothing \\cup (\\top \\setminus \\varnothing) = \\top = \\{a+b, a\\ast c\\}$.\n\n4.  **Node $N_3$** (Join Point):\n    -   Node $N_3$ has predecessors $pred(N_3) = \\{N_1, N_2\\}$.\n    -   $IN[N_3] = OUT[N_1] \\cap OUT[N_2]$.\n    -   Substituting the stable values we found for $OUT[N_1]$ and $OUT[N_2]$:\n    -   $IN[N_3] = \\{a+b\\} \\cap \\{a+b, a\\ast c\\} = \\{a+b\\}$.\n\nThe iterative process has reached a fixed point as all IN/OUT sets are now stable. The final value for $IN[N_3]$ is $\\{a+b\\}$.\n\n**Analysis of the Unreachable Predecessor's Effect**:\nThe unreachable predecessor $N_2$ contributes its $OUT$ set, which is $OUT[N_2] = \\top$, to the confluence at node $N_3$. The confluence operation is intersection ($\\cap$). For any set $S$ in the lattice, the property $S \\cap \\top = S$ holds. In our case, $S = OUT[N_1]$. Therefore, $IN[N_3] = OUT[N_1] \\cap \\top = OUT[N_1]$. The contribution from the unreachable path does not alter the result, as $\\top$ is the identity element for the intersection operator. This is a general principle in \"must\" analyses: pessimistic assumptions (represented by $\\top$) from unvisited or unreachable paths do not incorrectly constrain the set of proven facts.\n\n### Option-by-Option Analysis\n\n-   **A. $IN[N_3] = \\{a+b\\}$; the unreachable predecessor supplies $\\top$ and has no effect because $\\top$ is the identity for intersection.**\n    -   Our derivation yielded $IN[N_3] = \\{a+b\\}$. This is correct.\n    -   Our analysis showed that the unreachable predecessor $N_2$ supplies $OUT[N_2] = \\top$. This is correct.\n    -   The reasoning that this has no effect because $\\top$ is the identity element for the meet operator (intersection) is also correct.\n    -   **Verdict: Correct.**\n\n-   **B. $IN[N_3] = \\{a+b, a\\ast c\\}$; the unreachable predecessor forces $\\top$ at the join.**\n    -   The result $IN[N_3] = \\{a+b, a\\ast c\\}$ is incorrect. This would be true if the meet operator were union ($\\cup$), but for a \"must\" analysis, it is intersection ($\\cap$).\n    -   **Verdict: Incorrect.**\n\n-   **C. $IN[N_3] = \\varnothing$; the intersection collapses to $\\bot$ due to including an unreachable predecessor.**\n    -   The result $IN[N_3] = \\varnothing$ is incorrect. This would happen if the unreachable predecessor supplied $\\bot=\\varnothing$. However, the opposite is true; it supplies $\\top$. $\\bot$ is the identity for union, not intersection. For intersection, $\\bot$ is the absorbing element ($S \\cap \\bot = \\bot$).\n    -   **Verdict: Incorrect.**\n\n-   **D. $IN[N_3] = \\{a\\ast c\\}$; the unreachable predecessor kills $a+b$ and only $a\\ast c$ remains available.**\n    -   The result $IN[N_3] = \\{a\\ast c\\}$ is incorrect.\n    -   The reasoning is also flawed. The block $N_2$ is empty and thus has an empty $KILL$ set ($KILL[N_2] = \\varnothing$). It does not kill any expressions. Its output is $\\top$ because its input is $\\top$.\n    -   **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3635923"}]}