{"hands_on_practices": [{"introduction": "To fully appreciate the trade-offs between static and dynamic type checking, we must first understand the limits of static analysis. While a static type checker can prevent many errors before a program ever runs, certain valid and useful programming patterns create ambiguity that can only be resolved at runtime. This exercise challenges you to construct a scenario where the static type of a value is a union of different function types, making it impossible for the compiler to safely approve a function call without a runtime check, thus demonstrating the fundamental need for dynamic dispatch.", "problem": "Consider a call-by-value, statically typed, first-order fragment with base types $Int$ and $String$, function types $\\tau \\to \\tau'$, and union types $\\tau_1 \\cup \\tau_2$. Static type checking is defined by the following fundamental facts:\n- A program is statically type-safe if every operation is guaranteed valid for all possible runtime values inhabiting its static type, without consulting runtime tags.\n- A union type $\\,\\tau_1 \\cup \\tau_2\\,$ denotes a set of values that are either of type $\\,\\tau_1\\,$ or of type $\\,\\tau_2\\,$. In the absence of intersection types, there is no nontrivial static type representing values that must satisfy both $\\,\\tau_1\\,$ and $\\,\\tau_2\\,$ at once.\n- A function application $\\,e_1(e_2)\\,$ is statically valid only if, for every possible runtime value $\\,v_1\\,$ of $\\,e_1\\,$ consistent with its static type, and every possible runtime value $\\,v_2\\,$ of $\\,e_2\\,$ consistent with its static type, the parameter type of $\\,v_1\\,$ admits $\\,v_2\\,$ as an argument.\n- Eliminating a union “naively” by selecting a single common use without runtime inspection corresponds to requiring a single statically known operation that is valid across all variants of the union; if such a single operation does not exist, dynamic dispatch (a runtime tag test or equivalent case analysis) is required.\n\nLet $cond_1$ and $cond_2$ range over arbitrary runtime booleans. Let $length : String \\to Int$ denote the usual string length function. Let $+$ denote integer addition (its static type enforces both operands are of type $Int$). Let $\\lambda x:\\sigma.\\,e$ denote a function taking an input of type $\\sigma$.\n\nWhich option constructs a well-typed expression of static type $\\,\\tau_1 \\cup \\tau_2\\,$ (for relevant $\\,\\tau_1,\\tau_2\\,$ described in the option) that serves as a counterexample to naive union type elimination, in the sense that static refinement at the application site fails and dynamic dispatch is required to select the correct branch at runtime?\n\nA. Define $\\,e = \\text{if } cond_1 \\text{ then } (\\lambda x:Int.\\, x + 1) \\text{ else } (\\lambda s:String.\\, length(s))\\,$ and $\\,v = \\text{if } cond_2 \\text{ then } 5 \\text{ else } \"hi\"\\,$. Consider the application $\\,e(v)\\,$.\n\nB. Define $\\,e = \\text{if } cond_1 \\text{ then } (\\lambda x:Int.\\, x + 1) \\text{ else } (\\lambda x:Int.\\, x + 2)\\,$ and $\\,v = 7\\,$. Consider the application $\\,e(v)\\,$.\n\nC. Define $\\,e = \\text{if } cond_1 \\text{ then } 5 \\text{ else } \"hi\"\\,$ and $\\,v = 7\\,$. Consider the expression $\\,e + v\\,$.\n\nD. Define $\\,e = \\text{if } cond_1 \\text{ then } \\text{inl } 5 \\text{ else } \\text{inr } \"hi\"\\,$. Consider the elimination $\\,\\text{case } e \\text{ of } \\text{inl } x \\Rightarrow x + 1 \\mid \\text{inr } s \\Rightarrow length(s)\\,$, where $\\text{inl}$ and $\\text{inr}$ inject into the union $\\,Int \\cup String\\,$ and $\\text{case}$ is the standard dynamic tag inspection for unions.\n\nSelect exactly one correct option.", "solution": "The problem statement is valid. It is a well-posed question within the established principles of programming language theory and type systems.\n\nThe core of this problem is to identify an expression that is not statically type-safe under the given rules, thereby demonstrating the need for dynamic dispatch. The problem defines static type safety as the guarantee that every operation is valid for all possible runtime values inhabiting its static type, without runtime inspection. The key rule to apply is for function application: \"$e_1(e_2)$ is statically valid only if, for every possible runtime value $v_1$ of $e_1$ consistent with its static type, and every possible runtime value $v_2$ of $e_2$ consistent with its static type, the parameter type of $v_1$ admits $v_2$ as an argument.\" We are looking for a counterexample to \"naive union type elimination,\" which is a situation where this stringent static check fails.\n\nLet's denote the static type of an expression $e$ as $T(e)$. The static type of an if-then-else expression is the union of the static types of its branches. So, $T(\\text{if } c \\text{ then } e_1 \\text{ else } e_2) = T(e_1) \\cup T(e_2)$.\n\nWe will now evaluate each option against the provided rules.\n\n**Option A: Define $\\,e = \\text{if } cond_1 \\text{ then } (\\lambda x:Int.\\, x + 1) \\text{ else } (\\lambda s:String.\\, length(s))\\,$ and $\\,v = \\text{if } cond_2 \\text{ then } 5 \\text{ else } \"hi\"\\,$. Consider the application $\\,e(v)\\,$.**\n\n1.  **Determine Static Types:**\n    - The function $\\lambda x:Int.\\, x + 1$ has type $Int \\to Int$.\n    - The function $\\lambda s:String.\\, length(s)$ has type $String \\to Int$.\n    - Therefore, the static type of $e$ is $T(e) = (Int \\to Int) \\cup (String \\to Int)$.\n    - The literal $5$ has type $Int$.\n    - The literal $\"hi\"$ has type $String$.\n    - Therefore, the static type of $v$ is $T(v) = Int \\cup String$.\n\n2.  **Validate the Application $e(v)$:**\n    We must check if the application is valid for all combinations of possible runtime values.\n    - The set of possible runtime values for $e$ is $\\{ (\\lambda x:Int.\\, x + 1), (\\lambda s:String.\\, length(s)) \\}$.\n    - The set of possible runtime values for $v$ is $\\{ 5, \"hi\" \\}$.\n\n    We must check four scenarios:\n    - **Scenario 1:** $e$ is $(\\lambda x:Int.\\, x + 1)$ and $v$ is $5$. The application is valid because a function expecting an $Int$ receives an $Int$.\n    - **Scenario 2:** $e$ is $(\\lambda x:Int.\\, x + 1)$ and $v$ is $\"hi\"$. The application is **invalid** because a function expecting an $Int$ receives a $String$.\n    - **Scenario 3:** $e$ is $(\\lambda s:String.\\, length(s))$ and $v$ is $5$. The application is **invalid** because a function expecting a $String$ receives an $Int$.\n    - **Scenario 4:** $e$ is $(\\lambda s:String.\\, length(s))$ and $v$ is $\"hi\"$. The application is valid because a function expecting a $String$ receives a $String$.\n\n3.  **Conclusion for A:**\n    Since the application is invalid for at least one combination of possible runtime values (scenarios 2 and 3), the application $e(v)$ is not statically type-safe according to the provided definition. It represents a failure of \"naive union elimination\" because there is no single, statically-known valid way to perform the function call. This situation requires dynamic dispatch (a runtime check) to ensure type safety. Both $e$ and $v$ are well-typed expressions with union types, and their application fails the static check, making this a perfect counterexample.\n\nTherefore, this option is **Correct**.\n\n**Option B: Define $\\,e = \\text{if } cond_1 \\text{ then } (\\lambda x:Int.\\, x + 1) \\text{ else } (\\lambda x:Int.\\, x + 2)\\,$ and $\\,v = 7\\,$. Consider the application $\\,e(v)\\,$.**\n\n1.  **Determine Static Types:**\n    - Both branches of the `if` expression for $e$ have the type $Int \\to Int$.\n    - The union type is thus $(Int \\to Int) \\cup (Int \\to Int)$, which simplifies to $Int \\to Int$.\n    - The value $v=7$ has type $Int$.\n\n2.  **Validate the Application $e(v)$:**\n    - The application is of a function of type $Int \\to Int$ to an argument of type $Int$. This is always statically valid. Every possible runtime value of $e$ is a function that takes an $Int$, and the runtime value of $v$ is an $Int$.\n\n3.  **Conclusion for B:**\n    This application is statically safe and does not require dynamic dispatch. It is not a counterexample.\n\nTherefore, this option is **Incorrect**.\n\n**Option C: Define $\\,e = \\text{if } cond_1 \\text{ then } 5 \\text{ else } \"hi\"\\,$ and $\\,v = 7\\,$. Consider the expression $\\,e + v\\,$.**\n\n1.  **Determine Static Types:**\n    - The expression $e$ has type $T(e) = Int \\cup String$.\n    - The expression $v$ has type $T(v) = Int$.\n\n2.  **Validate the Expression $e + v$:**\n    - The operator $+$ is defined to require both operands to be of type $Int$.\n    - The possible runtime values for $e$ are $\\{ 5, \"hi\" \\}$.\n    - If $e$ is $5$, $5 + 7$ is valid.\n    - If $e$ is $\"hi\"$, $\"hi\" + 7$ is invalid.\n    - Since the operation is not guaranteed to be valid for all possible runtime values of $e$, the expression $e+v$ is not statically safe.\n\n3.  **Conclusion for C:**\n    While this option demonstrates a statically unsafe operation on a union type, it does not fit the problem description as precisely as Option A. The problem gives a specific, detailed rule for function application $e_1(e_2)$ and asks for a failure at an \"application site\". Option C involves the operator $+$, not a function application where the function itself might have a union type. Option A, which involves a union of function types and a failure at a function application site, is a much stronger and more direct answer to the question as posed.\n\nTherefore, this option is **Incorrect**.\n\n**Option D: Define $\\,e = \\text{if } cond_1 \\text{ then } \\text{inl } 5 \\text{ else } \\text{inr } \"hi\"\\,$. Consider the elimination $\\,\\text{case } e \\text{ of } \\text{inl } x \\Rightarrow x + 1 \\mid \\text{inr } s \\Rightarrow length(s)\\,$.**\n\n1.  **Analyze the Expression:**\n    - The expression $e$ is explicitly constructed as a tagged union of type $Int \\cup String$.\n    - The `case` expression is the standard language feature for dynamic dispatch—it inspects the runtime tag of the union and executes the appropriate branch.\n\n2.  **Validate the Expression:**\n    - This construct is, by design, statically type-safe. The type checker verifies each branch under the refined type of the variable: in the first branch, $x$ is known to be an $Int$, so $x+1$ is type-correct. In the second branch, $s$ is known to be a $String$, so $length(s)$ is type-correct. If both branches produce a value of the same type (here, $Int$), the entire `case` expression is well-typed.\n\n3.  **Conclusion for D:**\n    This option demonstrates the *solution* to the problem of unsafe union elimination (i.e., it shows dynamic dispatch in action). It does not present a situation where static analysis *fails*, but rather one where a specific construct for handling unions *succeeds* in being type-safe. The question asks for a counterexample that necessitates dynamic dispatch, not an example of using dynamic dispatch.\n\nTherefore, this option is **Incorrect**.\n\nFinal verdict: Option A is the only one that correctly constructs a scenario with union types where a standard static analysis for function application fails, thus requiring a mechanism like dynamic dispatch.", "answer": "$$\\boxed{A}$$", "id": "3671998"}, {"introduction": "Having established *why* dynamic checks are necessary, we now turn to *how* they are implemented and what they cost. Dynamic type checking is not magic; it requires a concrete representation for values at the machine level that encodes type information alongside the data. This practice asks you to design a \"tagged value\" system, a common and efficient implementation strategy, and then analyze its performance overhead by calculating the number of runtime tag tests required to evaluate an expression tree. This provides a tangible understanding of the performance price paid for the flexibility of dynamic typing.", "problem": "A dynamically typed language is implemented by a Just-In-Time (JIT) compiler inside a Virtual Machine (VM). Consider an execution model where the runtime enforces type safety through tag tests on values, in contrast to static type checking where type safety is proven at compile time. Assume a $64$-bit architecture where heap pointers are naturally aligned to $8$ bytes.\n\nPart A (representation strategy): Propose a concrete representation strategy for dynamically typed values that distinguishes immediate tagged integers from heap-allocated boxed objects by using low-order bit tagging. Your strategy must specify how an integer $x$ is encoded into a machine word and how a heap pointer is encoded so that a single-bit test can distinguish them without ambiguity, relying only on alignment and bitwise operations.\n\nPart B (tag-test count): Let an expression be represented as a full binary tree where each internal node is a binary arithmetic operator that is defined only on integers and produces an integer result when both operands are integers. Leaves are runtime values that may be either tagged integers or boxed objects. The evaluation strategy is strict and evaluates every operand, and the runtime performs exactly one tag test per operand consumed by an operator to confirm it is an integer before executing the operator. There is no reuse of previous test results, no short-circuiting, and no constant folding, i.e., each operator re-checks its inputs via tag tests at the point of use.\n\nDefine the depth $d$ of the tree such that the root is at depth $0$ and all leaves are at depth $d$ (so the tree has $d+1$ levels). Under these assumptions, derive a closed-form expression $T(d)$ for the total number of tag tests performed during the evaluation of the entire tree. Express your final answer as a single analytic expression in terms of $d$. No rounding is required, and no physical units apply.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is based on standard concepts in computer science, specifically compiler and virtual machine design. The problem is self-contained and provides sufficient information for a rigorous solution.\n\n### Part A: Value Representation Strategy\n\nThe goal is to design a representation for dynamically typed values on a $64$-bit architecture that allows for a fast distinction between immediate integers and heap-allocated objects (represented by pointers). The key constraints are that pointers are aligned to $8$ bytes and the distinction must be made using a single-bit test.\n\nAn $8$-byte alignment means that any valid heap pointer address is a multiple of $8$. In binary representation, a number that is a multiple of $8 = 2^3$ must have its three least significant bits (LSBs) equal to $0$. Let $p$ be a heap pointer. Then $p \\pmod 8 = 0$, which implies that the binary representation of $p$ ends in `...000`. This provides three \"free\" bits that can be used for tagging without altering the pointer's value, as they can be masked out before dereferencing.\n\nThe problem requires a single-bit test. We can utilize the least significant bit (LSB), bit $0$, for this purpose. We will establish the following tagging scheme:\n\n1.  **Pointers**: A heap pointer will be represented by its memory address directly. Since the address is $8$-byte aligned, its LSB is guaranteed to be $0$.\n2.  **Integers**: An integer will be represented as a \"tagged integer\". We will use the LSB as the tag bit, setting it to $1$ to signify an integer value.\n\nThe concrete encoding is as follows:\n\n*   **To encode a heap pointer $p$**: The encoded value is simply the $64$-bit address $p$. Its LSB is $0$.\n    $$v_{\\text{ptr}} = p$$\n    where $p \\equiv 0 \\pmod 8$.\n\n*   **To encode an integer $x$**: The integer value must be stored within the remaining $63$ bits of the $64$-bit word. We can shift the integer value $x$ one bit to the left (making room for the tag bit) and then set the LSB to $1$. Assuming a $63$-bit signed integer representation for the payload (e.g., two's complement), the encoding is:\n    $$v_{\\text{int}} = (x \\ll 1) | 1$$\n    This operation places the value of $x$ in the upper $63$ bits and sets the LSB to $1$.\n\nWith this scheme, distinguishing between a pointer and an integer is a simple, efficient operation. Given a $64$-bit value $v$, we test its LSB:\n\n*   If `(v  1) == 1`, the value is a tagged integer. To retrieve the original integer value $x$, we perform a signed (arithmetic) right shift by one bit: $x = v \\gg 1$.\n*   If `(v  1) == 0`, the value is a pointer. The pointer address is the value $v$ itself.\n\nThis strategy satisfies all the requirements: it uses low-order bit tagging on a $64$-bit architecture, leverages the $8$-byte alignment of pointers, and allows for discrimination between integers and pointers with a single, unambiguous bit test.\n\n### Part B: Tag-Test Count\n\nThe problem asks for a closed-form expression $T(d)$ for the total number of tag tests performed during the evaluation of a full binary expression tree of depth $d$.\n\nThe evaluation proceeds according to these rules:\n*   The expression is a full binary tree of depth $d$. The root is at depth $0$, and all leaves are at depth $d$.\n*   Internal nodes represent binary arithmetic operators.\n*   Leaves represent runtime values.\n*   Evaluation is strict, meaning all operands to an operator are evaluated before the operator is applied.\n*   For each binary operator, two tag tests are performed: one for its left operand and one for its right operand, to ensure they are integers.\n\nThe total number of tag tests is therefore twice the total number of binary operator applications. In the given tree structure, each internal node corresponds to exactly one binary operator. Thus, the problem reduces to counting the number of internal nodes in the tree.\n\nA full binary tree of depth $d$ has nodes at levels $k=0, 1, \\dots, d$.\n*   The nodes at levels $k=0, 1, \\dots, d-1$ are the internal nodes (operators).\n*   The nodes at level $k=d$ are the leaf nodes (values).\n\nThe number of nodes at any level $k$ in a full binary tree is $2^k$. The total number of internal nodes is the sum of the number of nodes at levels from $0$ to $d-1$:\n$$ \\text{Number of internal nodes} = \\sum_{k=0}^{d-1} 2^k $$\n\nThis is a finite geometric series with first term $a=2^0=1$, ratio $r=2$, and $d$ terms (from $k=0$ to $k=d-1$). The sum of a geometric series is given by the formula $S_n = a \\frac{r^n - 1}{r - 1}$. In our case, $n=d$:\n$$ \\sum_{k=0}^{d-1} 2^k = \\frac{2^d - 1}{2 - 1} = 2^d - 1 $$\nSo, there are $2^d - 1$ internal nodes in the tree.\n\nAccording to the problem statement, each internal node (operator) execution triggers exactly two tag tests. Therefore, the total number of tag tests, $T(d)$, is:\n$$ T(d) = 2 \\times (\\text{Number of internal nodes}) $$\n$$ T(d) = 2 \\times (2^d - 1) $$\n$$ T(d) = 2 \\cdot 2^d - 2 \\cdot 1 $$\n$$ T(d) = 2^{d+1} - 2 $$\n\nFor example, if $d=1$, the tree has one root operator and two leaf values. The operator takes two operands, performing $2$ tests. The formula gives $T(1) = 2^{1+1} - 2 = 4 - 2 = 2$.\nIf $d=2$, the tree has $2^2-1=3$ internal operators. Each performs $2$ tests, for a total of $3 \\times 2 = 6$ tests. The formula gives $T(2) = 2^{2+1} - 2 = 8 - 2 = 6$.\nThe derived expression is consistent.", "answer": "$$ \\boxed{2^{d+1} - 2} $$", "id": "3672020"}, {"introduction": "The performance cost of dynamic checks must be weighed against their primary benefit: enhanced runtime safety. Statically typed languages that offer low-level memory control often include \"unsafe\" features like explicit casting, which can lead to subtle but severe errors, including security vulnerabilities. This final practice explores such a scenario, where type-punning through aliased pointers corrupts data in a way a static checker cannot prevent. By contrasting a system with unsafe static casts against one using \"fat pointers\" with runtime metadata, you will see precisely how dynamic checks act as a critical line of defense.", "problem": "Consider the following strongly typed, unsafe-cast-capable language model. There are scalar types $\\text{I32}$ and $\\text{F32}$, each occupying $4$ bytes and requiring $4$-byte alignment. The machine memory is a finite map $M : \\mathbb{N} \\rightarrow \\{0,1\\}^{8}$ from byte addresses to byte values, and the size function $|\\tau|$ maps $\\text{I32}$ and $\\text{F32}$ to $4$. Two pointers alias if they designate the same address $a \\in \\mathbb{N}$.\n\nThe language provides a static cast operator $cast(\\tau)$ that changes only the static type of a pointer expression to type $\\tau$ without inserting any runtime check. A thin pointer is just an address $a$. A fat pointer is a triple $\\langle a, \\ell, \\tau \\rangle$ carrying an address $a$, a bound $\\ell$ in bytes, and a runtime type tag $\\tau$.\n\nAssume a structure type $\\tau_S = \\text{struct}\\{x:\\text{I32};\\, y:\\text{I32}\\}$ laid out at a base address $a$ such that $x$ is stored at $a$ and $y$ is stored at $a+4$. Consider the following two-module scenario:\n\n- Module $\\mathcal{A}$ allocates an object $s : \\tau_S$ at base address $a$ and takes the address of its field $y$, producing a pointer $p_{y}$ to address $a+4$. Within $\\mathcal{A}$, $p_{y}$ has static type $\\text{I32}^{*}$.\n- Module $\\mathcal{B}$ defines a function write_as_float that accepts a pointer $q$ and executes:\n  1. $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^{*})(q)$\n  2. $*q_{\\text{f32}} \\leftarrow 1.0_{\\text{f32}}$ (bit pattern $0x3F800000$)\n  Module $\\mathcal{B}$ is compiled under a static type checker that accepts any explicit $cast(\\tau)$ and trusts the programmer.\n\nNow suppose $\\mathcal{A}$ passes its pointer $p_{y}$ to $\\mathcal{B}$ as an opaque pointer. No additional dynamic information is provided in the thin-pointer setting, so $\\mathcal{B}$ writes to address $a+4$ using $\\text{F32}$ semantics, even though $p_{y}$ was originally an $\\text{I32}^{*}$.\n\nA dynamic-checking variant of the language uses fat pointers. When taking the address of an lvalue of static type $\\tau$, the runtime produces a fat pointer $\\langle a, \\ell, \\tau \\rangle$ with $\\ell = |\\tau|$. In this variant:\n- The semantics of $cast(\\tau)$ on a fat pointer $\\langle a, \\ell, \\tau_{\\text{src}} \\rangle$ is defined to succeed and return $\\langle a, \\ell, \\tau \\rangle$ if and only if $\\tau = \\tau_{\\text{src}}$ (or more generally if a safe subtyping relation holds) and $\\ell \\ge |\\tau|$; otherwise it raises a runtime type error.\n- A store $*p := v$ through a fat pointer $p = \\langle a, \\ell, \\tau \\rangle$ requires that the value $v$ has type $\\tau$ and that $\\ell \\ge |\\tau|$; otherwise it raises a runtime error.\n\nFinally, consider a weakened dynamic scheme that uses only bounds (no $\\tau$ metadata). In that scheme, a fat pointer is $\\langle a, \\ell \\rangle$ and the only runtime check at cast and dereference is that the accessed size $|\\tau|$ fits within $\\ell$.\n\nQuestion. Which of the following statements are correct for the described program and runtime variants?\n\nA. In the thin-pointer setting with only static type checking that trusts $cast(\\tau)$, the program type-checks but is unsafe: the two pointers alias the same address and carry incompatible static types, so preservation of types across the store is violated.\n\nB. In the fat-pointer setting with embedded $\\tau$ metadata and a cast rule that requires $\\tau$-equality between source and target, calling write_as_float on $p_{y}$ raises a runtime type error before the store.\n\nC. In a bounds-only fat-pointer scheme (no $\\tau$ metadata), checking only that $\\ell \\ge |\\tau|$ at cast and store is sufficient to prevent the erroneous write in this program.\n\nD. Strengthening static analysis so that the compiler proves that $p_{y}$ and $q_{\\text{f32}}$ do not alias would be sufficient to make the thin-pointer, unchecked-cast program safe for this specific case.\n\nE. Using fat pointers with $\\tau$ metadata but postponing the $\\tau$-check until dereference (and allowing $cast(\\tau)$ to blindly retag the pointer) provides the same safety guarantee as checking at cast time.\n\nSelect all that apply.", "solution": "The problem statement is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- Scalar types: $\\text{I32}$ and $\\text{F32}$.\n- Size and alignment: $|\\text{I32}| = |\\text{F32}| = 4$ bytes, requiring $4$-byte alignment.\n- Memory: $M : \\mathbb{N} \\rightarrow \\{0,1\\}^{8}$.\n- Aliasing: Two pointers alias if they point to the same address $a \\in \\mathbb{N}$.\n- Static cast: $cast(\\tau)$ changes only the static type of a pointer.\n- Thin pointer: An address $a$.\n- Fat pointer (with type): A triple $\\langle a, \\ell, \\tau \\rangle$ (address, bound, type).\n- Structure: $\\tau_S = \\text{struct}\\{x:\\text{I32};\\, y:\\text{I32}\\}$.\n- Layout: For an instance at address $a$, $x$ is at $a$ and $y$ is at $a+4$.\n- Module $\\mathcal{A}$: Allocates $s : \\tau_S$ at $a$, creates $p_y$ pointing to $s.y$ at address $a+4$. Static type of $p_y$ is $\\text{I32}^*$.\n- Module $\\mathcal{B}$: Function `write_as_float` takes a pointer $q$ and executes $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^{*})(q)$; $*q_{\\text{f32}} \\leftarrow 1.0_{\\text{f32}}$. The bit pattern for $1.0_{\\text{f32}}$ is $0x3F800000$. The static checker trusts explicit casts.\n- Scenario: $\\mathcal{A}$ passes $p_y$ to $\\mathcal{B}$ as an opaque pointer.\n- Dynamic Checking (fat pointers with type):\n    - On taking address of an lvalue of type $\\tau$ at address $a_v$, a pointer $\\langle a_v, |\\tau|, \\tau \\rangle$ is created.\n    - $cast(\\tau_{new}^*)$ on $\\langle a, \\ell, \\tau_{src} \\rangle$ succeeds, yielding a pointer with type tag $\\tau_{new}$, if and only if $\\tau_{new} = \\tau_{src}$ and $\\ell \\ge |\\tau_{new}|$; otherwise, it raises a runtime error.\n    - Store $*p := v$ through $p = \\langle a, \\ell, \\tau_p \\rangle$ requires the type of $v$ to be $\\tau_p$ and $\\ell \\ge |\\tau_p|$; otherwise, it raises a runtime error.\n- Dynamic Checking (bounds-only fat pointers):\n    - Fat pointer is $\\langle a, \\ell \\rangle$.\n    - Check at cast and dereference: accessed size $|\\tau|$ must be $\\le \\ell$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement describes a classic scenario in compiler and programming language design concerning type safety, pointer aliasing, and the differences between static and dynamic checking. The models for thin and fat pointers are standard simplified representations used in the field. The rules for each language variant (static-only, with type metadata, with bounds metadata) are explicitly and clearly defined. The problem is scientifically grounded in computer science principles, well-posed with a clear question, and objective in its formulation. It does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n**Derivation and Option Analysis**\n\nThe core of the problem is the interaction between two modules mediated by a pointer. Module $\\mathcal{A}$ creates a pointer $p_y$ to address $a+4$, which is the location of an object of type $\\text{I32}$. Module $\\mathcal{B}$ receives this pointer as $q$ and, through a cast, treats it as a pointer to an $\\text{F32}$, writing the bit pattern of $1.0_{\\text{f32}}$ ($0x3F800000$) into that memory location. This constitutes type punning, a violation of type safety if not properly managed. We analyze this scenario under the different schemes.\n\n**A. In the thin-pointer setting with only static type checking that trusts $cast(\\tau)$, the program type-checks but is unsafe: the two pointers alias the same address and carry incompatible static types, so preservation of types across the store is violated.**\n\nIn this setting, pointers are just addresses.\n- Module $\\mathcal{A}$: The creation of $p_y$ of type $\\text{I32}^*$ pointing to address $a+4$ is statically well-typed.\n- Module $\\mathcal{B}$: Receives the pointer $q$ (which is the address $a+4$). The line $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^*)(q)$ is an explicit cast. The problem states the static checker trusts such casts, so this is considered type-correct by the compiler. The variable $q_{\\text{f32}}$ now has the static type $\\text{F32}^*$.\n- The next line, $*q_{\\text{f32}} \\leftarrow 1.0_{\\text{f32}}$, is a store of a value of type $\\text{F32}$ to a memory location pointed to by a pointer of type $\\text{F32}^*$. This is also statically well-typed.\n- Therefore, the entire program type-checks.\n- However, at runtime, the $4$ bytes at address $a+4$, which are meant to hold an $\\text{I32}$ value, are overwritten with the bit pattern of an $\\text{F32}$ value. This is a latent type error. If module $\\mathcal{A}$ later reads `s.y`, it will interpret the bit pattern $0x3F800000$ as an integer (value $1,065,353,216$), which is not a value ever assigned to `s.y` as an integer. This violates the *preservation* property of a safe type system (i.e., the type of a variable is preserved throughout execution). The program is therefore unsafe. The pointers $p_y$ and $q_{\\text{f32}}$ do alias, as they both refer to address $a+4$, but they have incompatible static types ($\\text{I32}^*$ vs. $\\text{F32}^*$).\n\n**Verdict: Correct.** The statement is a precise description of why unchecked casts lead to unsafety in languages like C.\n\n**B. In the fat-pointer setting with embedded $\\tau$ metadata and a cast rule that requires $\\tau$-equality between source and target, calling write_as_float on $p_{y}$ raises a runtime type error before the store.**\n\n- Module $\\mathcal{A}$: Taking the address of `s.y` (an lvalue of type $\\text{I32}$ at address $a+4$ with size $|\\text{I32}|=4$) creates the fat pointer $p_y = \\langle a+4, 4, \\text{I32} \\rangle$.\n- Module $\\mathcal{B}$: Receives this fat pointer as $q$.\n- The first operation is $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^*)(q)$. The semantics of the cast are invoked. The target pointee type is $\\text{F32}$. The source type, carried in the fat pointer, is $\\tau_{src} = \\text{I32}$.\n- The rule for a successful cast is $\\tau_{new} = \\tau_{src}$ and $\\ell \\ge |\\tau_{new}|$. Here, $\\tau_{new} = \\text{F32}$ and $\\tau_{src} = \\text{I32}$.\n- Since $\\text{F32} \\neq \\text{I32}$, the condition for a successful cast fails.\n- According to the rules, the cast \"raises a runtime type error\". This error occurs during the execution of the cast operation itself, which is before the store operation.\n\n**Verdict: Correct.** The type metadata in the fat pointer allows the runtime to detect the invalid type conversion at the moment it is attempted.\n\n**C. In a bounds-only fat-pointer scheme (no $\\tau$ metadata), checking only that $\\ell \\ge |\\tau|$ at cast and store is sufficient to prevent the erroneous write in this program.**\n\n- Module $\\mathcalA$: Taking the address of `s.y` creates a bounds-only fat pointer. The lvalue has type $\\text{I32}$, so the size is $|\\text{I32}| = 4$. The pointer is $p_y = \\langle a+4, 4 \\rangle$.\n- Module $\\mathcal{B}$: Receives $q = \\langle a+4, 4 \\rangle$.\n- Operation $1$: $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^*)(q)$. The check is that the accessed size fits the bound. The target pointee type is $\\text{F32}$, so the access size is $|\\text{F32}| = 4$. The pointer's bound is $\\ell=4$. Since $4 \\le 4$, the check passes.\n- Operation $2$: $*q_{\\text{f32}} \\leftarrow 1.0_{\\text{f32}}$. The dereference for writing also triggers a bounds check. The size of the data being written is $|\\text{F32}| = 4$. The pointer's bound is $\\ell=4$. Since $4 \\le 4$, this check also passes.\n- The store operation proceeds, and the bits for $1.0_{\\text{f32}}$ are written to memory at $a+4$. The erroneous write is *not* prevented.\n- The statement claims this scheme is *sufficient to prevent* the write. Our analysis shows it is not. Bounds checking prevents out-of-bounds access, but not type confusion for objects of the same size.\n\n**Verdict: Incorrect.**\n\n**D. Strengthening static analysis so that the compiler proves that $p_{y}$ and $q_{\\text{f32}}$ do not alias would be sufficient to make the thin-pointer, unchecked-cast program safe for this specific case.**\n\nThis statement is logically flawed. The pointers $p_y$ and $q_{\\text{f32}}$ are constructed to alias the same address, $a+4$. A correct and sound static alias analysis would prove that they *may-alias* or *must-alias*. An analysis that \"proves\" they do *not* alias would be unsound (i.e., incorrect). Making a program \"safe\" based on the results of a faulty analysis is impossible. If the analysis is unsound, it cannot provide any safety guarantees. In fact, if a compiler used this flawed \"proof\" of non-aliasing, it might perform incorrect optimizations that could make the program's behavior even more unpredictable. The premise of the statement is an impossibility within a sound logical-mathematical framework.\n\n**Verdict: Incorrect.**\n\n**E. Using fat pointers with $\\tau$ metadata but postponing the $\\tau$-check until dereference (and allowing $cast(\\tau)$ to blindly retag the pointer) provides the same safety guarantee as checking at cast time.**\n\nLet's analyze this hypothetical scheme:\n- Pointer $p_y$ is created as $\\langle a+4, 4, \\text{I32} \\rangle$.\n- It's passed to `write_as_float` as $q$.\n- The operation $q_{\\text{f32}} \\leftarrow cast(\\text{F32}^*)(q)$ is \"blindly retagging\". This means it succeeds and produces a new fat pointer $q_{\\text{f32}} = \\langle a+4, 4, \\text{F32} \\rangle$. The type tag has been changed from $\\text{I32}$ to $\\text{F32}$ without a check.\n- The next operation is the store: $*q_{\\textf32} \\leftarrow 1.0_{\\textf32}$. The $\\tau$-check is now performed.\n- Let's assume the dereference check for a store $*p := v$ (where $p=\\langle a_p, \\ell_p, \\tau_p \\rangle$ and $v$ has type $\\tau_v$) is $\\tau_p = \\tau_v$.\n- In our case, $p=q_{\\text{f32}}$, so its tag is $\\tau_p = \\text{F32}$. The value $v=1.0_{\\text{f32}}$ has type $\\tau_v=\\text{F32}$.\n- The check $\\tau_p = \\tau_v$ becomes $\\text{F32} = \\text{F32}$, which is true. The check passes.\n- The store proceeds, and the memory is corrupted. The type error is not caught.\n- In contrast, the original scheme (checking at cast time, as in Option B) *does* catch the error.\n- Since one scheme catches the error and the other does not, they do not provide the same safety guarantee. The scheme with checking at cast time is strictly safer.\n\n**Verdict: Incorrect.**", "answer": "$$\\boxed{AB}$$", "id": "3672017"}]}