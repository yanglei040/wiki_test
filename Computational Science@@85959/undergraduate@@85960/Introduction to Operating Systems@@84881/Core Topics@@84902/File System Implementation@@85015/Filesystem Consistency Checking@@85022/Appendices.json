{"hands_on_practices": [{"introduction": "At the heart of any filesystem is the management of its most fundamental resource: storage blocks. To perform this efficiently, many filesystems use redundant data structuresâ€”a detailed, authoritative bitmap to track the status of every single block, and faster summary counters for quickly finding free space. This practice [@problem_id:3643422] simulates a scenario where a system crash has left these two structures in disagreement. Your task is to implement a core `fsck` routine that trusts the detailed bitmap as the source of truth to verify and repair the summary counters, a fundamental step in restoring filesystem integrity.", "problem": "You are given a simplified model of a block-based filesystem divided into block groups. Each block group $g$ has a total number of blocks $B_g$, of which the first $R_g$ blocks are reserved for metadata and must never be counted as free. The filesystem maintains a free-space bitmap per group, where a bit value of $1$ denotes a free block and a bit value of $0$ denotes an allocated block. The bitmap covers all $B_g$ blocks in the group. The filesystem also stores a per-group summary counter $S_g$ that is supposed to equal the number of free data blocks in that group. The filesystem-wide summary is the sum of all per-group counters.\n\nThe fundamental invariants for filesystem consistency checking relevant here are:\n- The free-space bitmap is the authoritative per-block record of which blocks are currently free. By definition, the true free count for group $g$ equals the number of bits equal to $1$ among non-reserved positions, that is, among indices $i$ such that $R_g \\le i \\lt B_g$.\n- Reserved blocks are not usable for file data, so their bits must be treated as allocated regardless of their bitmap value. In a correct bitmap, reserved bits are $0$, but a robust reconciliation process must not count any reserved position as free.\n- The group summary $S_g$ is expected to equal the count of free data blocks derived from the bitmap. The filesystem-wide free-block summary is expected to be the sum $\\sum_{g=0}^{G-1} S_g$, where $G$ is the number of groups.\n\nDesign a reconciliation procedure analogous to a filesystem checker that:\n1. Recomputes, for each group $g$, the corrected free-block count $C_g$ by counting $1$ bits in the bitmap for indices $i$ with $R_g \\le i \\lt B_g$, ignoring the first $R_g$ bits as reserved.\n2. Compares $C_g$ to the stored $S_g$ and flags the group as inconsistent if $C_g \\ne S_g$.\n3. Computes the corrected filesystem-wide total free blocks $T = \\sum_{g=0}^{G-1} C_g$.\n4. Reports, for each test case, the list $\\left[C_0, C_1, \\dots, C_{G-1}, T, K\\right]$, where $K$ is the count of groups for which $C_g \\ne S_g$.\n\nImplement a complete, runnable program that hardcodes the following test suite and computes the reconciliation results:\n\nTest case $1$:\n- $G = 3$\n- Group $0$: $B_0 = 16$, $R_0 = 2$, bitmap string is the length-$16$ sequence \"0010110010011001\", stored summary $S_0 = 5$.\n- Group $1$: $B_1 = 8$, $R_1 = 1$, bitmap string is the length-$8$ sequence \"01001001\", stored summary $S_1 = 6$.\n- Group $2$: $B_2 = 10$, $R_2 = 0$, bitmap string is the length-$10$ sequence \"1100000000\", stored summary $S_2 = 4$.\n\nTest case $2$:\n- $G = 2$\n- Group $0$: $B_0 = 5$, $R_0 = 5$, bitmap string is the length-$5$ sequence \"00000\", stored summary $S_0 = 2$.\n- Group $1$: $B_1 = 5$, $R_1 = 0$, bitmap string is the length-$5$ sequence \"10101\", stored summary $S_1 = 3$.\n\nTest case $3$:\n- $G = 3$\n- Group $0$: $B_0 = 4$, $R_0 = 0$, bitmap string is the length-$4$ sequence \"1111\", stored summary $S_0 = 0$.\n- Group $1$: $B_1 = 4$, $R_1 = 2$, bitmap string is the length-$4$ sequence \"0001\", stored summary $S_1 = 2$.\n- Group $2$: $B_2 = 1$, $R_2 = 0$, bitmap string is the length-$1$ sequence \"0\", stored summary $S_2 = 0$.\n\nYour program must:\n- Use these hardcoded inputs exactly as specified.\n- Treat any reserved positions $i$ with $0 \\le i \\lt R_g$ as non-free regardless of the bitmap bit value.\n- For each test case, compute $C_g$ for each group, the total $T$, and the number $K$ of inconsistent groups.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of bracketed lists, one per test case, in the order given above. Specifically, the output must be of the form:\n  - $\\left[\\left[C_0^{(1)}, C_1^{(1)}, \\dots, C_{G^{(1)}-1}^{(1)}, T^{(1)}, K^{(1)}\\right], \\left[C_0^{(2)}, \\dots, T^{(2)}, K^{(2)}\\right], \\left[C_0^{(3)}, \\dots, T^{(3)}, K^{(3)}\\right]\\right]$\n  where the superscript $(j)$ denotes test case $j$.\n- The elements $C_g$, $T$, and $K$ are integers.\n- There must be no additional text or whitespace beyond the single bracketed line.", "solution": "The problem statement provides a simplified model of a block-based filesystem and requires the implementation of a reconciliation procedure, analogous to a filesystem checker, to validate and correct its free-block accounting. The problem is scientifically grounded in the principles of operating system and filesystem design, is well-posed with all necessary data and clear objectives, and is expressed in objective, formal language. It is therefore deemed a valid problem.\n\nThe core of the task is to re-calculate the number of free blocks in each group based on its bitmap, compare this corrected count to the stored summary, and aggregate the results. The procedure is specified by a set of precise rules. Let $G$ be the number of block groups in the filesystem. For each group $g$, where $g$ ranges from $0$ to $G-1$, we are given:\n- $B_g$: The total number of blocks in the group.\n- $R_g$: The number of initial blocks reserved for metadata.\n- A bitmap string of length $B_g$, where a '1' bit signifies a free block and a '0' bit signifies an allocated block.\n- $S_g$: A stored summary value purporting to be the number of free data blocks in the group.\n\nThe reconciliation procedure involves computing three quantities for each test case: a vector of corrected per-group free-block counts $[C_0, C_1, \\dots]$, a corrected filesystem-wide total free-block count $T$, and a count of inconsistent groups $K$.\n\nStep 1: Compute the Corrected Free-Block Count $C_g$\nThe fundamental invariant is that the bitmap is the definitive source of truth for block allocation status. However, a critical constraint is that reserved blocks must never be counted as free, regardless of their corresponding bit value in the bitmap. Reserved blocks occupy indices $i$ such that $0 \\le i < R_g$. Therefore, the pool of blocks available for data storage in group $g$ consists of blocks at indices $i$ where $R_g \\le i < B_g$.\n\nThe corrected free-block count for group $g$, denoted $C_g$, is determined by iterating through the non-reserved portion of the group's bitmap and summing the bits with a value of $1$. Formally, this is expressed as:\n$$ C_g = \\sum_{i=R_g}^{B_g - 1} \\mathbf{1}(\\text{bitmap}_g[i] = \\text{'1'}) $$\nwhere $\\mathbf{1}(\\cdot)$ is the indicator function, which evaluates to $1$ if its argument is true and $0$ otherwise. The loop for this calculation runs from the first non-reserved block index, $R_g$, up to, but not including, the total number of blocks, $B_g$.\n\nStep 2: Identify Inconsistent Groups and Compute $K$\nA group $g$ is flagged as inconsistent if its stored summary counter $S_g$ does not match the newly computed authoritative count $C_g$. The total number of inconsistent groups, $K$, is the count of all groups for which this condition holds.\n$$ K = \\sum_{g=0}^{G-1} \\mathbf{1}(C_g \\neq S_g) $$\nThis step is performed by comparing the calculated $C_g$ with the provided $S_g$ for each group and incrementing a counter for each detected discrepancy.\n\nStep 3: Compute the Corrected Filesystem-Wide Total $T$\nThe corrected filesystem-wide total number of free blocks, $T$, is simply the sum of the corrected free-block counts from all groups.\n$$ T = \\sum_{g=0}^{G-1} C_g $$\nThis value represents the true number of free data blocks across the entire filesystem after reconciliation.\n\nExample Calculation (Test Case 1, Group 0):\n- Given: $B_0 = 16$, $R_0 = 2$, bitmap = \"0010110010011001\", $S_0 = 5$.\n- We calculate $C_0$ by summing the '1's in the bitmap from index $i=2$ to $i=15$.\n- The substring to be examined is `10110010011001`.\n- Counting the '1's: at indices $2, 4, 5, 8, 11, 12, 15$. There are $7$ ones.\n- Thus, the corrected count is $C_0 = 7$.\n- We compare $C_0$ with $S_0$. Since $C_0 = 7$ and $S_0 = 5$, we have $C_0 \\neq S_0$. This group is inconsistent.\n\nThis procedure is systematically applied to all groups in all test cases to generate the required output vectors. The final report for each test case is an ordered list containing the per-group corrected counts, the total corrected count, and the number of inconsistent groups: $[C_0, C_1, \\dots, C_{G-1}, T, K]$.", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// A struct to hold the parameters for a single block group.\ntypedef struct {\n    int B;                  // Total blocks, B_g\n    int R;                  // Reserved blocks, R_g\n    const char* bitmap_str; // Bitmap as a string\n    int S;                  // Stored summary, S_g\n} BlockGroup;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int G;                      // Number of groups, G\n    const BlockGroup* groups;   // Pointer to an array of BlockGroup\n} TestCase;\n\nint main(void) {\n    // Define the data for all test cases.\n    // Test case 1 data\n    const BlockGroup tc1_groups[] = {\n        {16, 2, \"0010110010011001\", 5},\n        {8,  1, \"01001001\",         6},\n        {10, 0, \"1100000000\",       4}\n    };\n\n    // Test case 2 data\n    const BlockGroup tc2_groups[] = {\n        {5, 5, \"00000\", 2},\n        {5, 0, \"10101\", 3}\n    };\n\n    // Test case 3 data\n    const BlockGroup tc3_groups[] = {\n        {4, 0, \"1111\", 0},\n        {4, 2, \"0001\", 2},\n        {1, 0, \"0\",    0}\n    };\n\n    // Array of all test cases\n    const TestCase test_cases[] = {\n        {3, tc1_groups},\n        {2, tc2_groups},\n        {3, tc3_groups}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    // Begin printing the output with the opening bracket for the list of all results\n    printf(\"[\");\n\n    // Process each test case\n    for (int i = 0; i < num_cases; ++i) {\n        const TestCase* tc = &test_cases[i];\n        int C_values[tc->G]; // Array to store computed C_g for the current test case\n        int T = 0; // Total corrected free blocks\n        int K = 0; // Count of inconsistent groups\n\n        // Process each group within the test case\n        for (int g = 0; g < tc->G; ++g) {\n            const BlockGroup* group = &tc->groups[g];\n            int Cg = 0; // Corrected free-block count for the current group\n\n            // Calculate Cg by counting '1's in the non-reserved portion of the bitmap\n            for (int b = group->R; b < group->B; ++b) {\n                if (group->bitmap_str[b] == '1') {\n                    Cg++;\n                }\n            }\n            \n            C_values[g] = Cg;\n            T += Cg;\n\n            // Check if the group is inconsistent\n            if (Cg != group->S) {\n                K++;\n            }\n        }\n\n        // Print the result vector for the current test case: [C_0, C_1, ..., T, K]\n        printf(\"[\");\n        for (int g = 0; g < tc->G; ++g) {\n            printf(\"%d,\", C_values[g]);\n        }\n        printf(\"%d,%d]\", T, K);\n\n        // Add a comma between test case results, but not after the last one\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n\n    // End printing with the closing bracket\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643422"}, {"introduction": "Once we are confident in the filesystem's block allocation map, we can move up a level to inspect individual files. Each file's metadata contains at least two critical pieces of information: its logical size as known by applications, and an extent list that maps parts of the file to physical blocks on disk. This exercise [@problem_id:3643409] explores the consistency between these two views. You will develop a checker that identifies discrepancies, such as initialized data existing beyond the recorded end-of-file, and implements a conservative, data-preserving repair policy, reflecting how real-world tools prioritize avoiding data loss.", "problem": "You are given a simplified model of a filesystem that stores files as a set of logical extents. Each file has a recorded size and a sequence of extents, where each extent maps a contiguous range of logical blocks to either initialized (written) data or unwritten preallocation. Your task is to build a consistency checker that cross-validates the recorded file size against what is implied by the initialized extents, detects logical overlaps among extents, and proposes non-destructive repair actions that avoid truncating any initialized data.\n\nFundamental base and definitions:\n\n- A file is described by:\n  - A block size $B$ in bytes.\n  - A recorded size $S$ in bytes.\n  - A list of extents $\\{(l_i, n_i, w_i)\\}_{i=1}^N$ where:\n    - $l_i$ is the logical start block index (an integer satisfying $l_i \\ge 0$).\n    - $n_i$ is the number of blocks in the extent (an integer satisfying $n_i \\ge 0$).\n    - $w_i \\in \\{0,1\\}$ indicates whether the extent is initialized ($1$) or unwritten preallocation ($0$).\n\n- Each extent $i$ covers the logical block interval $I_i = [l_i, l_i + n_i)$ in block units. Two extents $i$ and $j$ overlap in logical space if $\\max(l_i, l_j) < \\min(l_i + n_i, l_j + n_j)$.\n\n- The maximum allocated logical byte end is\n  $$M_{\\text{alloc}} = \\max_{1 \\le i \\le N} (l_i + n_i) \\cdot B,$$\n  where the maximum of an empty set is defined as $0$.\n\n- The maximum initialized logical byte end is\n  $$M_{\\text{init}} = \\max_{1 \\le i \\le N, \\, w_i = 1} (l_i + n_i) \\cdot B,$$\n  where the maximum of an empty set is defined as $0$.\n\n- The ceiling number of blocks needed to represent the recorded size is\n  $$Q = \\left\\lceil \\frac{S}{B} \\right\\rceil.$$\n\nConsistency interpretation and non-destructive repair recommendations that avoid truncating initialized data:\n\n- If $S < M_{\\text{init}}$ then some initialized data lie beyond the recorded end-of-file. A non-destructive correction is to increase the recorded size to\n  $$S_{\\text{rec}} = M_{\\text{init}}.$$\n\n- Otherwise, keep the recorded size:\n  $$S_{\\text{rec}} = S.$$\n\n- Unwritten preallocation beyond end-of-file can be safely removed without risking data loss. Define the total number of unwritten blocks to drop beyond end-of-file as\n  $$C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right).$$\n  This counts only full blocks whose start index is at least $Q$; partially overlapping unwritten blocks with $l_i < Q$ are kept unchanged.\n\n- Count the number of overlapping extent pairs\n  $$O = \\#\\left\\{(i,j) \\mid 1 \\le i < j \\le N,\\; \\max(l_i, l_j) < \\min(l_i + n_i, l_j + n_j)\\right\\}.$$\n\n- Define a risk indicator\n  $$R = \\begin{cases}\n  1 & \\text{if there exists an overlapping pair with } w_i = 1 \\text{ and } w_j = 1,\\\\\n  0 & \\text{otherwise.}\n  \\end{cases}$$\n  This indicates overlaps between initialized extents that may require manual resolution due to potential conflicting data.\n\nProgram requirements:\n\n- For each test case, compute the tuple $\\left(O, S_{\\text{rec}}, C, R\\right)$ with all four values as integers.\n\n- Your program must process the following test suite of seven cases. For each case, the block size $B$, recorded size $S$, and list of extents are provided. Each extent is given as a triple $(l_i, n_i, w_i)$ in the order described above.\n\n  - Test case $1$:\n    - $B = 4096$, $S = 12288$.\n    - Extents: $(0, 3, 1)$.\n  - Test case $2$:\n    - $B = 4096$, $S = 20480$.\n    - Extents: $(0, 2, 1)$.\n  - Test case $3$:\n    - $B = 4096$, $S = 8192$.\n    - Extents: $(0, 3, 1)$.\n  - Test case $4$:\n    - $B = 4096$, $S = 4096$.\n    - Extents: $(0, 1, 1)$, $(1, 4, 0)$.\n  - Test case $5$:\n    - $B = 4096$, $S = 12288$.\n    - Extents: $(0, 3, 1)$, $(2, 2, 1)$.\n  - Test case $6$:\n    - $B = 4096$, $S = 0$.\n    - Extents: none (empty list).\n  - Test case $7$:\n    - $B = 4096$, $S = 4500$.\n    - Extents: $(0, 1, 1)$, $(1, 1, 0)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed list in the order $\\left[O,S_{\\text{rec}},C,R\\right]$. Use no spaces. For example, a two-case output might look like \"$[[1,100,0,0],[0,80,2,1]]$\". For the given seven test cases, output exactly one line aggregating all seven result lists in order.", "solution": "The problem provides a simplified model of a filesystem's file representation and asks for the implementation of a consistency checker that computes four metrics: the number of overlapping extents ($O$), a recommended non-destructive file size ($S_{\\text{rec}}$), the number of reclaimable unwritten blocks ($C$), and a risk indicator for overlapping initialized data ($R$). The problem is well-defined, scientifically grounded in the principles of operating systems, and all necessary formulas and data are provided. It is therefore deemed a valid problem.\n\nWe will proceed by applying the given definitions and formulas to each of the seven test cases provided.\n\nFor any given file, we have:\n- Block size $B$\n- Recorded size $S$\n- A list of $N$ extents $\\{(l_i, n_i, w_i)\\}_{i=1}^N$\n\nThe derived quantities are:\n- Ceiling number of blocks for the recorded size: $Q = \\left\\lceil \\frac{S}{B} \\right\\rceil$. For integer arithmetic with non-negative $S$ and positive $B$, this is computed as $(S + B - 1) / B$.\n- Maximum initialized logical byte end: $M_{\\text{init}} = \\max_{i: w_i = 1} (l_i + n_i) \\cdot B$.\n- Recommended size: $S_{\\text{rec}} = \\max(S, M_{\\text{init}})$.\n- Overlap count: $O = \\#\\left\\{(i,j) \\mid 1 \\le i < j \\le N,\\; \\max(l_i, l_j) < \\min(l_i + n_i, l_j + n_j)\\right\\}$.\n- Droppable unwritten blocks count: $C = \\sum_{i: w_i = 0} \\max\\left(0,\\,(l_i + n_i) - Q\\right)$.\n- Risk indicator: $R = 1$ if an overlapping pair $(i,j)$ exists where $w_i=1$ and $w_j=1$; $R=0$ otherwise.\n\nWe now analyze each case.\n\n**Test Case 1:**\n- Given: $B = 4096$, $S = 12288$, Extents: $\\{(0, 3, 1)\\}$.\n- $N=1$. The single extent is $l_1=0$, $n_1=3$, $w_1=1$.\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$.\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$.\n- $S = 12288$, $M_{\\text{init}} = 12288$. Since $S \\not< M_{\\text{init}}$, $S_{\\text{rec}} = S = 12288$.\n- $C$: There are no unwritten extents ($w_i=0$). The sum is over an empty set, so $C = 0$.\n- $O, R$: With only one extent, there are no pairs to check. $O=0, R=0$.\n- Result: $(0, 12288, 0, 0)$.\n\n**Test Case 2:**\n- Given: $B = 4096$, $S = 20480$, Extents: $\\{(0, 2, 1)\\}$.\n- $N=1$. The single extent is $l_1=0$, $n_1=2$, $w_1=1$.\n- $Q = \\lceil 20480 / 4096 \\rceil = \\lceil 5 \\rceil = 5$.\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 2) \\cdot 4096 = 8192$.\n- $S = 20480$, $M_{\\text{init}} = 8192$. Since $S \\ge M_{\\text{init}}$, $S_{\\text{rec}} = S = 20480$.\n- $C$: No unwritten extents. $C = 0$.\n- $O, R$: No pairs of extents. $O=0, R=0$.\n- Result: $(0, 20480, 0, 0)$.\n\n**Test Case 3:**\n- Given: $B = 4096$, $S = 8192$, Extents: $\\{(0, 3, 1)\\}$.\n- $N=1$. The single extent is $l_1=0$, $n_1=3$, $w_1=1$.\n- $Q = \\lceil 8192 / 4096 \\rceil = \\lceil 2 \\rceil = 2$.\n- $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 3) \\cdot 4096 = 12288$.\n- $S = 8192$, $M_{\\text{init}} = 12288$. Since $S < M_{\\text{init}}$, $S_{\\text{rec}} = M_{\\text{init}} = 12288$.\n- $C$: No unwritten extents. $C = 0$.\n- $O, R$: No pairs of extents. $O=0, R=0$.\n- Result: $(0, 12288, 0, 0)$.\n\n**Test Case 4:**\n- Given: $B = 4096$, $S = 4096$, Extents: $e_1=(0, 1, 1)$, $e_2=(1, 4, 0)$.\n- $N=2$. $l_1=0, n_1=1, w_1=1$; $l_2=1, n_2=4, w_2=0$.\n- $Q = \\lceil 4096 / 4096 \\rceil = \\lceil 1 \\rceil = 1$.\n- $M_{\\text{init}}$: Only $e_1$ is initialized. $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$.\n- $S = 4096$, $M_{\\text{init}} = 4096$. Since $S \\not< M_{\\text{init}}$, $S_{\\text{rec}} = S = 4096$.\n- $C$: Only $e_2$ is unwritten. $C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+4) - 1) = 4$.\n- $O, R$: Check pair $(e_1, e_2)$. The intervals are $I_1 = [0, 1)$ and $I_2 = [1, 5)$. Overlap requires $\\max(l_1, l_2) < \\min(l_1+n_1, l_2+n_2)$. Here, $\\max(0, 1) = 1$ and $\\min(1, 5) = 1$. The condition $1 < 1$ is false. No overlap. $O=0, R=0$.\n- Result: $(0, 4096, 4, 0)$.\n\n**Test Case 5:**\n- Given: $B = 4096$, $S = 12288$, Extents: $e_1=(0, 3, 1)$, $e_2=(2, 2, 1)$.\n- $N=2$. $l_1=0, n_1=3, w_1=1$; $l_2=2, n_2=2, w_2=1$.\n- $Q = \\lceil 12288 / 4096 \\rceil = \\lceil 3 \\rceil = 3$.\n- $M_{\\text{init}}$: Both extents are initialized. End bytes are $(0+3) \\cdot 4096 = 12288$ and $(2+2) \\cdot 4096 = 16384$. $M_{\\text{init}} = \\max(12288, 16384) = 16384$.\n- $S = 12288$, $M_{\\text{init}} = 16384$. Since $S < M_{\\text{init}}$, $S_{\\text{rec}} = M_{\\text{init}} = 16384$.\n- $C$: No unwritten extents. $C = 0$.\n- $O, R$: Check pair $(e_1, e_2)$. Intervals are $I_1 = [0, 3)$ and $I_2 = [2, 4)$. Overlap requires $\\max(l_1, l_2) < \\min(l_1+n_1, l_2+n_2)$. Here, $\\max(0, 2) = 2$ and $\\min(3, 4) = 3$. The condition $2 < 3$ is true. There is an overlap. $O=1$.\n- Since the overlapping pair has $w_1=1$ and $w_2=1$, the risk indicator $R=1$.\n- Result: $(1, 16384, 0, 1)$.\n\n**Test Case 6:**\n- Given: $B = 4096$, $S = 0$, Extents: none.\n- $N=0$.\n- $Q = \\lceil 0 / 4096 \\rceil = \\lceil 0 \\rceil = 0$.\n- $M_{\\text{init}}$: The set of initialized extents is empty. By definition, $M_{\\text{init}} = 0$.\n- $S=0$, $M_{\\text{init}}=0$. Since $S \\not< M_{\\text{init}}$, $S_{\\text{rec}} = S = 0$.\n- $C$: The set of unwritten extents is empty. $C=0$.\n- $O, R$: No extents, so no pairs. $O=0, R=0$.\n- Result: $(0, 0, 0, 0)$.\n\n**Test Case 7:**\n- Given: $B = 4096$, $S = 4500$, Extents: $e_1=(0, 1, 1)$, $e_2=(1, 1, 0)$.\n- $N=2$. $l_1=0, n_1=1, w_1=1$; $l_2=1, n_2=1, w_2=0$.\n- $Q = \\lceil 4500 / 4096 \\rceil = \\lceil 1.0986... \\rceil = 2$.\n- $M_{\\text{init}}$: Only $e_1$ is initialized. $M_{\\text{init}} = (l_1 + n_1) \\cdot B = (0 + 1) \\cdot 4096 = 4096$.\n- $S = 4500$, $M_{\\text{init}} = 4096$. Since $S \\ge M_{\\text{init}}$, $S_{\\text{rec}} = S = 4500$.\n- $C$: Only $e_2$ is unwritten. $C = \\max(0, (l_2+n_2) - Q) = \\max(0, (1+1) - 2) = 0$.\n- $O, R$: Check pair $(e_1, e_2)$. Intervals are $I_1=[0, 1)$ and $I_2=[1, 2)$. Overlap requires $\\max(l_1, l_2) < \\min(l_1+n_1, l_2+n_2)$. Here, $\\max(0, 1) = 1$ and $\\min(1, 2) = 1$. The condition $1 < 1$ is false. No overlap. $O=0, R=0$.\n- Result: $(0, 4500, 0, 0)$.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_EXTENTS 2\n\n// A struct to hold a single extent's information.\ntypedef struct {\n    long l; // logical start block\n    long n; // number of blocks\n    int w;  // written flag (1 for initialized, 0 for unwritten)\n} Extent;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long B; // block size\n    long S; // recorded size\n    int num_extents;\n    Extent extents[MAX_EXTENTS];\n} TestCase;\n\n// A struct to hold the computed results for a test case.\ntypedef struct {\n    long O;\n    long S_rec;\n    long C;\n    long R;\n} Result;\n\n// Helper function for max of two longs\nlong long_max(long a, long b) {\n    return a > b ? a : b;\n}\n\n// Helper function for min of two longs\nlong long_min(long a, long b) {\n    return a < b ? a : b;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {4096, 12288, 1, {{0, 3, 1}}},\n        {4096, 20480, 1, {{0, 2, 1}}},\n        {4096, 8192, 1, {{0, 3, 1}}},\n        {4096, 4096, 2, {{0, 1, 1}, {1, 4, 0}}},\n        {4096, 12288, 2, {{0, 3, 1}, {2, 2, 1}}},\n        {4096, 0, 0, {}},\n        {4096, 4500, 2, {{0, 1, 1}, {1, 1, 0}}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    Result results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase current_case = test_cases[i];\n        long B = current_case.B;\n        long S = current_case.S;\n        int N = current_case.num_extents;\n\n        // Calculate Q = ceil(S / B)\n        long Q = (S > 0) ? (S + B - 1) / B : 0;\n\n        // Calculate M_init\n        long max_init_block_end = 0;\n        for (int j = 0; j < N; ++j) {\n            if (current_case.extents[j].w == 1) {\n                long end_block = current_case.extents[j].l + current_case.extents[j].n;\n                if (end_block > max_init_block_end) {\n                    max_init_block_end = end_block;\n                }\n            }\n        }\n        long M_init = max_init_block_end * B;\n\n        // Calculate S_rec\n        results[i].S_rec = (S < M_init) ? M_init : S;\n\n        // Calculate C\n        results[i].C = 0;\n        for (int j = 0; j < N; ++j) {\n            if (current_case.extents[j].w == 0) {\n                long term = (current_case.extents[j].l + current_case.extents[j].n) - Q;\n                if (term > 0) {\n                    results[i].C += term;\n                }\n            }\n        }\n\n        // Calculate O and R\n        results[i].O = 0;\n        results[i].R = 0;\n        if (N > 1) {\n            for (int j = 0; j < N; ++j) {\n                for (int k = j + 1; k < N; ++k) {\n                    Extent e1 = current_case.extents[j];\n                    Extent e2 = current_case.extents[k];\n\n                    long overlap_start = long_max(e1.l, e2.l);\n                    long overlap_end = long_min(e1.l + e1.n, e2.l + e2.n);\n\n                    if (overlap_start < overlap_end) {\n                        results[i].O++;\n                        if (e1.w == 1 && e2.w == 1) {\n                            results[i].R = 1;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%ld,%ld,%ld,%ld]\", results[i].O, results[i].S_rec, results[i].C, results[i].R);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643409"}, {"introduction": "The highest level of filesystem consistency involves its overall directory structure, which organizes all files and directories into a coherent hierarchy. This structure is essentially a directed graph where inodes are nodes and directory entries are edges. This final practice [@problem_id:3643427] challenges you to perform a complete structural audit, assuming that even basic navigational aids like the `.` and `..` entries might be corrupt. By traversing the filesystem graph from scratch, you will reconstruct parent-child relationships, identify structural anomalies like orphan nodes or multiple parents, and validate metadata invariants like link counts, thereby ensuring the entire directory tree is logically sound.", "problem": "You are given an abstract model of a hierarchical filesystem intended to capture the essential constraints used by a File System Consistency Check (FSCK). Each entity is represented by a unique inode identifier. There are two types of inodes: directories and regular files. Directory contents are specified as name-to-inode mappings (directory entries). In this model, entries named \".\" and \"..\" may be corrupt, and therefore cannot be used to determine parent-child relations. The goal is to design and implement an algorithm that rebuilds parent-child links using only non-\".\" and non-\"..\" entries, unique inode identifiers, and link-count evidence.\n\nFundamental base definitions and facts:\n- An inode is identified by a unique integer identifier $i \\in \\mathbb{Z}$.\n- Each inode has a type in $\\{\\text{dir}, \\text{file}\\}$ and a metadata link count $lc(i) \\in \\mathbb{Z}_{\\ge 0}$.\n- For each directory inode $d$, its entry list is a finite sequence $E(d) = [(n_1, i_1), (n_2, i_2), \\dots, (n_k, i_k)]$, where each $n_j$ is a string name and $i_j$ is a target inode identifier.\n- Well-tested facts:\n  1. For a regular file inode $f$, the link count equals the number of directory entries referring to it: $lc(f) = \\left|\\{(n, f) \\mid (n, f) \\in \\bigcup_{d} E(d)\\}\\right|$.\n  2. For a directory inode $p$, the link count equals $2$ plus the number of subdirectories it directly contains: $lc(p) = 2 + \\left|\\{(n, c) \\mid (n, c) \\in E(p),\\ c\\ \\text{is a directory},\\ n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\right|$. The \"$2$\" accounts for the self-link \".\" and the back-link \"..\" contributed by each child directory; this is a well-established property of traditional Unix-like filesystems.\n\nTasks:\n- You must ignore directory entries with names \".\" and \"..\" when reconstructing parent-child relations and when counting references.\n- Reconstruct candidate parent-child relations by interpreting each non-\".\" and non-\"..\" directory entry $(n, i)$ found in a directory $d$ as an edge $d \\to i$. For a directory inode $c$, its candidate parents are the set $\\{d \\mid (n, c) \\in E(d),\\ n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}$.\n- Determine the root directory by selecting the unique directory inode with zero candidate parents. If multiple directories have zero candidate parents, select the root as the one with the smallest identifier and count each additional zero-parent directory as one inconsistency. If there is no zero-parent directory, count one inconsistency for \"no root found\".\n- For any directory with multiple candidate parents, select exactly one parent using the following tie-breaking rule derived from link-count evidence: for each candidate parent $p$ of a child $c$, compute $m(p) = \\left|lc(p) - \\left(2 + \\text{outdeg}_{\\text{dir}}(p)\\right)\\right|$, where $\\text{outdeg}_{\\text{dir}}(p)$ is the number of outgoing edges from $p$ to directory inodes using non-\".\" and non-\"..\" entries. Choose the parent $p^*$ that minimizes $m(p)$, breaking ties by the smallest inode identifier. Count each extra parent beyond $p^*$ as one inconsistency.\n- Validate link counts:\n  - For each file inode $f$, compute the number of incoming references from all directories ignoring \".\" and \"..\" entries, denoted $r(f)$, and count one inconsistency if $r(f) \\ne lc(f)$.\n  - For each directory inode $p$, compute $2 + \\text{outdeg}_{\\text{dir}}(p)$ and count one inconsistency if $2 + \\text{outdeg}_{\\text{dir}}(p) \\ne lc(p)$.\n\nYour program must compute, for each test case specified below, the total number of inconsistencies detected by the above rules, as a single non-negative integer. The final output must be a single line containing a comma-separated list of the results for all test cases enclosed in square brackets.\n\nTest Suite:\n- Test case $1$ (general, happy path):\n  - Inodes: directory $1$ with $lc(1) = 3$, directory $3$ with $lc(3) = 2$, file $2$ with $lc(2) = 2$.\n  - Directory entries:\n    - $E(1) = [(\\text{\".\"}, 1), (\\text{\"..\"}, 1), (\\text{\"etc\"}, 3), (\\text{\"readme\"}, 2)]$.\n    - $E(3) = [(\\text{\".\"}, 3), (\\text{\"..\"}, 1), (\\text{\"note\"}, 2)]$.\n- Test case $2$ (corrupted \".\" and \"..\" but structurally sound):\n  - Inodes: directory $10$ with $lc(10) = 3$, directory $11$ with $lc(11) = 2$.\n  - Directory entries:\n    - $E(10) = [(\\text{\".\"}, 999), (\\text{\"..\"}, 999), (\\text{\"child\"}, 11)]$.\n    - $E(11) = [(\\text{\".\"}, 111), (\\text{\"..\"}, 999)]$.\n- Test case $3$ (orphan directory, extra root):\n  - Inodes: directory $20$ with $lc(20) = 3$, directory $21$ with $lc(21) = 2$, directory $22$ with $lc(22) = 2$.\n  - Directory entries:\n    - $E(20) = [(\\text{\"child\"}, 22)]$.\n    - $E(21) = [\\ ]$.\n    - $E(22) = [\\ ]$.\n- Test case $4$ (directory referenced by multiple parents):\n  - Inodes: directory $30$ with $lc(30) = 3$, directory $31$ with $lc(31) = 3$, directory $32$ with $lc(32) = 2$.\n  - Directory entries:\n    - $E(30) = [(\\text{\"A\"}, 32)]$.\n    - $E(31) = [(\\text{\"B\"}, 32)]$.\n    - $E(32) = [\\ ]$.\n- Test case $5$ (file and directory link-count mismatches):\n  - Inodes: directory $40$ with $lc(40) = 4$, file $41$ with $lc(41) = 1$, directory $42$ with $lc(42) = 2$.\n  - Directory entries:\n    - $E(40) = [(\\text{\"file\"}, 41), (\\text{\"sub\"}, 42)]$.\n    - $E(42) = [(\\text{\"file\"}, 41)]$.\n- Test case $6$ (single empty root directory):\n  - Inodes: directory $50$ with $lc(50) = 2$.\n  - Directory entries:\n    - $E(50) = [\\ ]$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\dots]$. There must be no additional text or lines.", "solution": "The problem requires the design and implementation of an algorithm to validate the consistency of a simplified hierarchical filesystem model, analogous to a File System Consistency Check (FSCK) utility. The solution is architected as a systematic, multi-pass analysis of the filesystem's structure, which is treated as a directed graph. In this graph, inodes are vertices, and directory entries form the edges. The total inconsistency score for a given filesystem configuration is the sum of all violations of a specific set of rules.\n\nThe algorithm proceeds in three distinct phases for each test case:\n\n**Phase 1: Graph Reconstruction and Property Aggregation**\nThe initial phase is dedicated to building an in-memory representation of the filesystem's directed graph and calculating essential properties of its vertices (inodes). We iterate through every directory inode $d$ and its list of entries $E(d)$. As per the problem's constraints, entries with names `\".\"` and `\"..\"` are explicitly ignored because they do not define the primary parent-child hierarchy and may be unreliable.\n\nFor every valid entry $(n, i)$ where $n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}$, we interpret it as a directed edge from the directory inode $d$ to the target inode $i$. During this traversal, we compute and store three critical properties:\n\n1.  **Candidate Parents:** For each inode $j$, we compile a list of all directory inodes $d$ that contain an entry pointing to $j$. This set, $\\{d \\mid (n, j) \\in E(d), n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}$, represents the set of candidate parents for inode $j$.\n2.  **Reference Count, $r(i)$:** For each inode $i$, we tally the total number of incoming edges from valid directory entries. This computed value, $r(i) = |\\{(n, i) \\mid (n, i) \\in \\bigcup_{d} E(d), n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}|$, is the a posteriori reference count, which will be checked against the inode's stored metadata link count $lc(i)$.\n3.  **Directory Out-degree, $\\text{outdeg}_{\\text{dir}}(p)$:** For each directory inode $p$, we count the number of its outgoing edges that point specifically to other directory inodes. This value, $\\text{outdeg}_{\\text{dir}}(p) = |\\{(n, c) \\mid (n, c) \\in E(p), c \\text{ is a directory}, n \\notin \\{\\text{\".\"}, \\text{\"..\"}\\}\\}|$, is crucial for validating the directory link count rule.\n\n**Phase 2: Structural Validation**\nWith the graph structure established, the second phase validates its overall integrity against hierarchical expectations. This involves two primary checks:\n\n1.  **Root Directory Identification:** A well-formed filesystem should possess a single root, defined as a directory with an in-degree of $0$ (i.e., no candidate parents). We identify all such directories.\n    - If no directory has zero candidate parents (e.g., in the case of a directory cycle), one inconsistency is counted for \"no root found\".\n    - If exactly one directory has zero candidate parents, it is correctly identified as the root, and no inconsistency is recorded.\n    - If multiple directories, say $k > 1$, have zero candidate parents, this indicates fragmented or parallel hierarchies. The problem provides a tie-breaking rule: the directory with the smallest inode identifier is designated as the true root. The remaining $k-1$ directories are considered \"extra roots,\" and each contributes one inconsistency, for a total of $k-1$ inconsistencies.\n\n2.  **Multiple Parent Resolution:** A strict hierarchical structure dictates that every non-root directory must have precisely one parent. We examine each directory inode $c$ and the size of its candidate parent set. If a directory has $N_{p} > 1$ candidate parents, it violates this principle. The problem statement provides a deterministic rule to select a single canonical parent $p^*$, ensuring a choice can always be made. The remaining $N_{p}-1$ candidates are deemed \"extra parents,\" and each contributes one inconsistency. Thus, a directory with $N_{p}$ parents adds $N_{p}-1$ to the total inconsistency count.\n\n**Phase 3: Link Count Validation**\nThe final phase verifies the consistency between the filesystem's structure, as derived in Phase $1$, and the metadata link counts, $lc(i)$, stored with each inode.\n\n1.  **File Link Count:** For each file inode $f$, its metadata link count $lc(f)$ must equal the computed reference count $r(f)$. A discrepancy, $lc(f) \\neq r(f)$, indicates an inconsistency, and one is added to the total count.\n2.  **Directory Link Count:** For each directory inode $p$, its link count is governed by the formula $lc(p) = 2 + \\text{outdeg}_{\\text{dir}}(p)$. The term `2` accounts for the expected `.` (self) and `..` (parent) links within a consistent filesystem. We compare the inode's stored $lc(p)$ against the value computed from its structural property $\\text{outdeg}_{\\text{dir}}(p)$. A mismatch, $lc(p) \\neq 2 + \\text{outdeg}_{\\text{dir}}(p)$, signifies an inconsistency, and the count is incremented by one.\n\nThe sum of all inconsistencies detected across these three phases constitutes the final integer result for the given test case, providing a quantitative measure of the filesystem's deviation from a valid state.", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Enum for inode types\ntypedef enum {\n    INODE_FILE,\n    INODE_DIR\n} InodeType;\n\n// Struct for a directory entry (name -> inode_id mapping)\ntypedef struct {\n    const char* name;\n    int target_id;\n} DirEntry;\n\n// Struct for an inode\ntypedef struct Inode {\n    int id;\n    InodeType type;\n    int link_count; // Given metadata lc(i)\n\n    // For directories: list of entries\n    const DirEntry* entries;\n    int num_entries;\n\n    // Calculated properties for consistency checking\n    int* candidate_parents;\n    int num_candidate_parents;\n    int candidate_parent_capacity;\n    int outdeg_dir;\n    int ref_count; // Calculated reference count r(i)\n} Inode;\n\n// Struct for a file system instance\ntypedef struct {\n    Inode* inodes;\n    int num_inodes;\n} FileSystem;\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    FileSystem fs;\n} TestCase;\n\n// Helper to find an inode by its ID. Returns NULL if not found.\nInode* find_inode_by_id(FileSystem* fs, int id) {\n    for (int i = 0; i < fs->num_inodes; ++i) {\n        if (fs->inodes[i].id == id) {\n            return &fs->inodes[i];\n        }\n    }\n    return NULL;\n}\n\n// Helper to add a parent to an inode's candidate list\nvoid add_candidate_parent(Inode* inode, int parent_id) {\n    if (inode->num_candidate_parents >= inode->candidate_parent_capacity) {\n        inode->candidate_parent_capacity = (inode->candidate_parent_capacity == 0) ? 4 : inode->candidate_parent_capacity * 2;\n        inode->candidate_parents = (int*)realloc(inode->candidate_parents, inode->candidate_parent_capacity * sizeof(int));\n    }\n    inode->candidate_parents[inode->num_candidate_parents++] = parent_id;\n}\n\n// Comparison function for qsort to sort integers\nint compare_ints(const void* a, const void* b) {\n    int int_a = *((const int*)a);\n    int int_b = *((const int*)b);\n    if (int_a < int_b) return -1;\n    if (int_a > int_b) return 1;\n    return 0;\n}\n\nint main(void) {\n    // --- Test Case 1 Data ---\n    DirEntry entries1_1[] = {{\".\" , 1}, {\"..\", 1}, {\"etc\", 3}, {\"readme\", 2}};\n    DirEntry entries1_3[] = {{\".\" , 3}, {\"..\", 1}, {\"note\", 2}};\n    Inode inodes1[] = {\n        {1, INODE_DIR, 3, entries1_1, sizeof(entries1_1)/sizeof(entries1_1[0])},\n        {2, INODE_FILE, 2, NULL, 0},\n        {3, INODE_DIR, 2, entries1_3, sizeof(entries1_3)/sizeof(entries1_3[0])}\n    };\n\n    // --- Test Case 2 Data ---\n    DirEntry entries2_10[] = {{\".\" , 999}, {\"..\", 999}, {\"child\", 11}};\n    DirEntry entries2_11[] = {{\".\" , 111}, {\"..\", 999}};\n    Inode inodes2[] = {\n        {10, INODE_DIR, 3, entries2_10, sizeof(entries2_10)/sizeof(entries2_10[0])},\n        {11, INODE_DIR, 2, entries2_11, sizeof(entries2_11)/sizeof(entries2_11[0])}\n    };\n    \n    // --- Test Case 3 Data ---\n    DirEntry entries3_20[] = {{\"child\", 22}};\n    Inode inodes3[] = {\n        {20, INODE_DIR, 3, entries3_20, sizeof(entries3_20)/sizeof(entries3_20[0])},\n        {21, INODE_DIR, 2, NULL, 0},\n        {22, INODE_DIR, 2, NULL, 0}\n    };\n    \n    // --- Test Case 4 Data ---\n    DirEntry entries4_30[] = {{\"A\", 32}};\n    DirEntry entries4_31[] = {{\"B\", 32}};\n    Inode inodes4[] = {\n        {30, INODE_DIR, 3, entries4_30, sizeof(entries4_30)/sizeof(entries4_30[0])},\n        {31, INODE_DIR, 3, entries4_31, sizeof(entries4_31)/sizeof(entries4_31[0])},\n        {32, INODE_DIR, 2, NULL, 0}\n    };\n\n    // --- Test Case 5 Data ---\n    DirEntry entries5_40[] = {{\"file\", 41}, {\"sub\", 42}};\n    DirEntry entries5_42[] = {{\"file\", 41}};\n    Inode inodes5[] = {\n        {40, INODE_DIR, 4, entries5_40, sizeof(entries5_40)/sizeof(entries5_40[0])},\n        {41, INODE_FILE, 1, NULL, 0},\n        {42, INODE_DIR, 2, entries5_42, sizeof(entries5_42)/sizeof(entries5_42[0])}\n    };\n\n    // --- Test Case 6 Data ---\n    Inode inodes6[] = {\n        {50, INODE_DIR, 2, NULL, 0}\n    };\n\n    TestCase test_cases[] = {\n        {{inodes1, sizeof(inodes1)/sizeof(inodes1[0])}},\n        {{inodes2, sizeof(inodes2)/sizeof(inodes2[0])}},\n        {{inodes3, sizeof(inodes3)/sizeof(inodes3[0])}},\n        {{inodes4, sizeof(inodes4)/sizeof(inodes4[0])}},\n        {{inodes5, sizeof(inodes5)/sizeof(inodes5[0])}},\n        {{inodes6, sizeof(inodes6)/sizeof(inodes6[0])}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    for (int i = 0; i < num_cases; ++i) {\n        FileSystem* fs = &test_cases[i].fs;\n        int inconsistencies = 0;\n\n        // --- Initialization ---\n        for (int j = 0; j < fs->num_inodes; ++j) {\n            fs->inodes[j].candidate_parents = NULL;\n            fs->inodes[j].num_candidate_parents = 0;\n            fs->inodes[j].candidate_parent_capacity = 0;\n            fs->inodes[j].outdeg_dir = 0;\n            fs->inodes[j].ref_count = 0;\n        }\n\n        // --- Phase 1: Graph Reconstruction and Property Aggregation ---\n        for (int j = 0; j < fs->num_inodes; ++j) {\n            Inode* dir_inode = &fs->inodes[j];\n            if (dir_inode->type != INODE_DIR) {\n                continue;\n            }\n            for (int k = 0; k < dir_inode->num_entries; ++k) {\n                const DirEntry* entry = &dir_inode->entries[k];\n                if (strcmp(entry->name, \".\") == 0 || strcmp(entry->name, \"..\") == 0) {\n                    continue;\n                }\n                Inode* target_inode = find_inode_by_id(fs, entry->target_id);\n                if (target_inode) {\n                    target_inode->ref_count++;\n                    add_candidate_parent(target_inode, dir_inode->id);\n                    if (target_inode->type == INODE_DIR) {\n                        dir_inode->outdeg_dir++;\n                    }\n                }\n            }\n        }\n\n        // --- Phase 2: Structural Validation ---\n        int zero_parent_dirs[fs->num_inodes];\n        int num_zero_parent_dirs = 0;\n        for (int j = 0; j < fs->num_inodes; ++j) {\n            Inode* inode = &fs->inodes[j];\n            // Check for root candidates\n            if (inode->type == INODE_DIR && inode->num_candidate_parents == 0) {\n                zero_parent_dirs[num_zero_parent_dirs++] = inode->id;\n            }\n            // Check for multiple parents\n            if (inode->type == INODE_DIR && inode->num_candidate_parents > 1) {\n                inconsistencies += inode->num_candidate_parents - 1;\n            }\n        }\n\n        if (num_zero_parent_dirs == 0) {\n            inconsistencies++; // No root found\n        } else if (num_zero_parent_dirs > 1) {\n            inconsistencies += num_zero_parent_dirs - 1; // Extra roots\n            // qsort(zero_parent_dirs, num_zero_parent_dirs, sizeof(int), compare_ints); // Not needed for count\n        }\n\n        // --- Phase 3: Link Count Validation ---\n        for (int j = 0; j < fs->num_inodes; ++j) {\n            Inode* inode = &fs->inodes[j];\n            if (inode->type == INODE_FILE) {\n                if (inode->ref_count != inode->link_count) {\n                    inconsistencies++;\n                }\n            } else { // INODE_DIR\n                if ((2 + inode->outdeg_dir) != inode->link_count) {\n                    inconsistencies++;\n                }\n            }\n        }\n\n        results[i] = inconsistencies;\n\n        // Cleanup dynamically allocated memory\n        for (int j = 0; j < fs->num_inodes; ++j) {\n            free(fs->inodes[j].candidate_parents);\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3643427"}]}