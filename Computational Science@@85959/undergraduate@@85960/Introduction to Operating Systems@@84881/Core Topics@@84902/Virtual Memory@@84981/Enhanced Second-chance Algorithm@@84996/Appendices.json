{"hands_on_practices": [{"introduction": "The efficiency of any page replacement algorithm depends on balancing its decision-making accuracy with its computational overhead. The Enhanced Second-Chance algorithm involves scanning frames and clearing reference bits, both of which consume CPU cycles. This exercise [@problem_id:3639411] challenges you to mathematically model this trade-off by analyzing a batched approach to clearing reference bits, a common optimization technique. By deriving the optimal batch size, you will practice applying basic probability and cost modeling to tune system performance.", "problem": "An operating system uses the Enhanced Second-Chance (ESC) page replacement algorithm. Each page frame maintains a reference bit $R$ and a modified bit $M$. On a page fault, the algorithm scans frames sequentially with a circular hand. In this implementation, the system does not clear $R$ bits while scanning; instead, it performs a global batched clear of all $R$ bits after every $K$ page faults. Each global clear writes $R \\leftarrow 0$ for all frames. Assume the following cost model:\n- Each class check (reading $R$ and $M$ of one frame and comparing to the selection policy) costs $c_{\\mathrm{chk}}$ Central Processing Unit (CPU) cycles.\n- Clearing the $R$ bit of one frame during a batched clear costs $c_{\\mathrm{clr}}$ CPU cycles, so a batch that clears all frames costs $F \\, c_{\\mathrm{clr}}$ CPU cycles, where $F$ is the number of page frames.\n\nTo model the scan length, assume a stationary workload in which, at the time of a page fault, each encountered frame independently has $R = 0$ with probability $r \\in (0,1)$ and $R = 1$ with probability $1-r$. The ESC victim selection stops at the first frame with $R = 0$; preference between $M=0$ and $M=1$ is enforced at eviction time and does not change the number of frames scanned under this model. Let the target expected CPU overhead budget per page fault be $\\beta$ cycles, with $\\beta > \\frac{c_{\\mathrm{chk}}}{r}$ so that a feasible batch size exists.\n\nStarting only from the above assumptions and the definition of geometric waiting time for the first $R=0$ encounter, derive the minimal integer batch interval $K^{\\star}$ (measured in page faults between global clears) that guarantees the expected CPU overhead per page fault does not exceed $\\beta$. Express your final answer as a single closed-form analytic expression in terms of $F$, $c_{\\mathrm{chk}}$, $c_{\\mathrm{clr}}$, $r$, and $\\beta$.", "solution": "The problem is evaluated to be scientifically grounded, well-posed, objective, and internally consistent. It is a valid problem in the domain of operating systems algorithm analysis. We may proceed with the solution.\n\nThe objective is to find the minimal integer batch interval, denoted as $K^{\\star}$, such that the expected Central Processing Unit (CPU) overhead per page fault does not exceed a budget $\\beta$. The overhead arises from two distinct activities: the scanning of page frames to find a victim and the periodic batched clearing of reference bits.\n\nLet $C$ be the random variable representing the total CPU overhead per page fault. We are given the constraint that the expected value of this overhead, $E[C]$, must satisfy:\n$$\nE[C] \\le \\beta\n$$\n\nThe total expected overhead per page fault, $E[C]$, is the sum of the expected overhead from scanning and the amortized expected overhead from the batched clear operation. The batched clear occurs once every $K$ page faults.\n\nLet $C_{\\mathrm{scan}}$ be the cost of scanning frames during a single page fault.\nLet $C_{\\mathrm{clear}}$ be the cost of one global batched clear operation.\n\nThe total cost over a cycle of $K$ page faults is the sum of the costs of $K$ scans and one clear operation. The expected total cost for this cycle is $K \\cdot E[C_{\\mathrm{scan}}] + C_{\\mathrm{clear}}$, since the clear cost is deterministic. To find the average expected cost per page fault, we amortize this total cost over the $K$ faults:\n$$\nE[C] = E[C_{\\mathrm{scan}}] + \\frac{C_{\\mathrm{clear}}}{K}\n$$\n\nFirst, let's determine the expected scan cost, $E[C_{\\mathrm{scan}}]$. The problem states that the algorithm scans frames sequentially until it finds one with its reference bit $R=0$. Each frame check costs $c_{\\mathrm{chk}}$ CPU cycles. The state of each frame is modeled as an independent Bernoulli trial, where \"success\" is finding a frame with $R=0$. The probability of success for any given frame is given as $r$.\n\nLet $X$ be the random variable for the number of frames scanned until the first success. This follows a geometric distribution with success probability $r$. The probability mass function is $P(X=k) = (1-r)^{k-1}r$ for $k \\in \\{1, 2, 3, \\dots\\}$. The expected number of frames scanned is the expected value of this geometric distribution:\n$$\nE[X] = \\frac{1}{r}\n$$\n\nThe cost of scanning is the number of frames scanned multiplied by the cost per frame check, $c_{\\mathrm{chk}}$. Therefore, the expected scan cost per page fault is:\n$$\nE[C_{\\mathrm{scan}}] = E[X] \\cdot c_{\\mathrm{chk}} = \\frac{c_{\\mathrm{chk}}}{r}\n$$\n\nNext, we determine the cost of the global batched clear operation, $C_{\\mathrm{clear}}$. The system has $F$ page frames, and clearing the $R$ bit of one frame costs $c_{\\mathrm{clr}}$ cycles. Thus, the total cost for one batch clear is:\n$$\nC_{\\mathrm{clear}} = F \\cdot c_{\\mathrm{clr}}\n$$\n\nNow we can write the full expression for the expected CPU overhead per page fault as a function of the batch interval $K$:\n$$\nE[C](K) = \\frac{c_{\\mathrm{chk}}}{r} + \\frac{F c_{\\mathrm{clr}}}{K}\n$$\n\nThe problem requires that this a verage overhead not exceed the budget $\\beta$:\n$$\n\\frac{c_{\\mathrm{chk}}}{r} + \\frac{F c_{\\mathrm{clr}}}{K} \\le \\beta\n$$\n\nWe need to solve this inequality for $K$. The goal is to find the minimum integer $K$ that satisfies this condition.\n$$\n\\frac{F c_{\\mathrm{clr}}}{K} \\le \\beta - \\frac{c_{\\mathrm{chk}}}{r}\n$$\n\nThe problem provides the condition $\\beta > \\frac{c_{\\mathrm{chk}}}{r}$, which ensures that the right-hand side of the inequality is a positive value. This is a necessary condition for a feasible (positive) solution for $K$ to exist. Let's proceed with the algebraic manipulation. Since $K$ must be a positive integer (it's a count of page faults) and all costs are positive, we can safely multiply and divide.\n$$\nK \\ge \\frac{F c_{\\mathrm{clr}}}{\\beta - \\frac{c_{\\mathrm{chk}}}{r}}\n$$\n\nThis inequality specifies a lower bound for $K$. Since $K$ must be an integer, the minimal integer value $K^{\\star}$ that satisfies this condition is the smallest integer that is greater than or equal to the expression on the right-hand side. This corresponds to the ceiling function.\n$$\nK^{\\star} = \\left\\lceil \\frac{F c_{\\mathrm{clr}}}{\\beta - \\frac{c_{\\mathrm{chk}}}{r}} \\right\\rceil\n$$\n\nThis is the final closed-form expression for the minimal integer batch interval $K^{\\star}$ in terms of the given parameters $F$, $c_{\\mathrm{chk}}$, $c_{\\mathrm{clr}}$, $r$, and $\\beta$.", "answer": "$$\n\\boxed{\\left\\lceil \\frac{F c_{\\mathrm{clr}}}{\\beta - \\frac{c_{\\mathrm{chk}}}{r}} \\right\\rceil}\n$$", "id": "3639411"}, {"introduction": "A page replacement algorithm does not operate in a vacuum; it must coexist with other critical operating system components like the I/O subsystem. Pages involved in I/O operations are often \"pinned\" or locked in memory, creating a challenge for the eviction process. This practice problem [@problem_id:3639395] presents a concrete scenario to compare a naive implementation of ESC with a more robust, \"lock-aware\" design, forcing you to analyze the implications for performance and, most critically, the potential for system-wide deadlock.", "problem": "An operating system uses the Enhanced Second-Chance (ESC) page replacement algorithm. Each page frame is part of a circular list with a hand pointer. ESC uses the hardware-maintained reference bit $R$ and modified bit $M$ to assign four classes to frames, ordered by desirability for eviction: class $0$ is $(R=0,M=0)$, class $1$ is $(R=0,M=1)$, class $2$ is $(R=1,M=0)$, and class $3$ is $(R=1,M=1)$. On a scan, when a frame with $R=1$ is examined, its $R$ bit is cleared and the scan continues; the first frame found in the lowest nonempty class is selected for eviction. In addition, a frame can be locked by Input/Output (I/O) and marked with a lock bit $L=1$; such a frame is temporarily pinned for direct memory access and cannot be evicted until $L$ clears.\n\nConsider two policies:\n- Baseline ESC: ignores $L$ while scanning; if the selected victim happens to have $L=1$, the pager blocks until the lock clears, then evicts it.\n- Lock-Aware ESC (LA-ESC): never selects frames with $L=1$ as victims; when a locked frame is encountered, it is skipped without waiting. While scanning, LA-ESC clears $R$ only on unlocked frames and leaves all bits unchanged on locked frames.\n\nAssume the following snapshot of $N=8$ frames in circular order, indexed from $0$ to $7$, with the hand starting at index $0$. Each frame is labeled by a triple $(R,M,L)$:\n- Index $0$: $(0,0,1)$\n- Index $1$: $(1,1,0)$\n- Index $2$: $(0,1,0)$\n- Index $3$: $(1,0,0)$\n- Index $4$: $(0,0,0)$\n- Index $5$: $(1,1,1)$\n- Index $6$: $(0,1,0)$\n- Index $7$: $(1,0,0)$\n\nAssume the per-frame scan cost is $c_s=1$ time unit for examining a frame (including the chosen victim), and if the baseline ESC selects a locked victim it incurs an additional wait of $w=10$ time units for the lock to clear.\n\nUsing only the core definitions above (ESC classes and the four Coffman deadlock conditions: mutual exclusion, hold-and-wait, no preemption, and circular wait), reason about both policies on this snapshot. Which option below correctly identifies the LA-ESC victim index and correctly assesses, for this snapshot and under the given cost model, both the relative eviction latency of LA-ESC versus baseline ESC and whether LA-ESC prevents an eviction-stage deadlock due to waiting on I/O locks?\n\nA. LA-ESC evicts index $4$; by never waiting on $L=1$, it breaks hold-and-wait in the eviction path and prevents such deadlock; its eviction latency on this snapshot is $5$ time units, which is strictly less than the baseline ESC latency of $11$ time units.\n\nB. LA-ESC evicts index $2$; it does not change deadlock risk because it might still wait on locks later in the scan; its eviction latency equals that of baseline ESC.\n\nC. LA-ESC evicts index $4$; it cannot prevent deadlock because mutual exclusion still holds, and its eviction latency is higher than the baseline due to extra scanning.\n\nD. LA-ESC evicts index $0$ after waiting for $L$ to clear, preserving fairness; deadlock cannot occur in either policy because I/O always completes eventually, so their latencies are comparable.", "solution": "The problem asks for an analysis of two page replacement policies, Baseline Enhanced Second-Chance (ESC) and Lock-Aware ESC (LA-ESC), based on a given snapshot of page frames. The analysis should determine the victim page chosen by LA-ESC, compare the eviction latencies of the two policies, and assess their implications for deadlock.\n\n### Step 1: Validation of the Problem Statement\n\nThe problem statement provides a comprehensive definition of the Enhanced Second-Chance algorithm, including its use of reference ($R$) and modified ($M$) bits to define four page classes. It clearly delineates two distinct policies for handling I/O-locked pages (where the lock bit $L=1$). A specific initial state for $N=8$ pages is provided, along with the starting position of the scan hand. The cost model, with a scan cost $c_s=1$ and a wait cost $w=10$, is explicit. The question is specific, asking for the victim index under LA-ESC, a latency comparison, and a deadlock analysis based on the Coffman conditions.\n\nThe problem is scientifically grounded in established operating systems principles (page replacement, I/O handling, deadlock). It is well-posed, with all necessary data and rules provided for a deterministic simulation. The language is objective and precise. The setup is self-contained and free of contradictions. Therefore, the problem is valid.\n\n### Step 2: Derivation of the Solution\n\nLet's analyze the behavior and cost of each policy on the given snapshot. The page frame classes are defined as: Class $0$: $(R=0,M=0)$, Class $1$: $(R=0,M=1)$, Class $2$: $(R=1,M=0)$, and Class $3$: $(R=1,M=1)$. The search for a victim proceeds by looking for the first available page in the lowest-numbered class.\n\nThe initial state of the $N=8$ frames is:\n- Index $0$: $(0,0,1)$ - Class $0$, Locked\n- Index $1$: $(1,1,0)$ - Class $3$\n- Index $2$: $(0,1,0)$ - Class $1$\n- Index $3$: $(1,0,0)$ - Class $2$\n- Index $4$: $(0,0,0)$ - Class $0$\n- Index $5$: $(1,1,1)$ - Class $3$, Locked\n- Index $6$: $(0,1,0)$ - Class $1$\n- Index $7$: $(1,0,0)$ - Class $2$\n\nThe scan hand starts at index $0$.\n\n#### Analysis of Baseline ESC\n\nThe Baseline ESC policy ignores the lock bit $L$ during the scan for a victim. It only considers the lock bit after a victim is selected. The algorithm seeks the first frame in the lowest possible class.\n\n1.  The scan starts at index $0$.\n2.  The frame at index $0$ is $(R=0, M=0, L=1)$. This corresponds to Class $0$.\n3.  Since Class $0$ is the lowest (most desirable for eviction) class, the algorithm selects this frame as the victim immediately. The scan stops.\n4.  The number of frames examined is $1$. The scan cost is $1 \\times c_s = 1$ time unit.\n5.  After selection, the policy checks the lock bit. The victim frame at index $0$ has $L=1$. According to the Baseline ESC rule, the pager now blocks and waits for the lock to clear.\n6.  This wait incurs an additional cost of $w = 10$ time units.\n7.  The total eviction latency for Baseline ESC is the sum of the scan cost and the wait cost: $1 + 10 = 11$ time units.\n\n#### Analysis of Lock-Aware ESC (LA-ESC)\n\nThe LA-ESC policy never selects a locked frame ($L=1$) as a victim. It skips locked frames, leaving their bits unchanged. For unlocked frames with $R=1$, it clears the $R$ bit as it passes.\n\nThe search proceeds by looking for a victim in the lowest class, but restricted to unlocked frames. The algorithm makes passes, clearing $R$ bits as it goes.\n\n**Pass 1: Search for an unlocked Class $0$ victim $(R=0, M=0, L=0)$**\n\n1.  **Index $0$**: State is $(0,0,1)$. This is a Class $0$ frame, but it is locked ($L=1$). LA-ESC skips it. Per the rule for locked frames, its bits are not changed. The hand moves to index $1$. (Frames examined: $1$)\n2.  **Index $1$**: State is $(1,1,0)$. This is not a Class $0$ frame. It is unlocked and has $R=1$. LA-ESC clears the reference bit. The frame's state becomes $(0,1,0)$. The hand moves to index $2$. (Frames examined: $2$)\n3.  **Index $2$**: State is $(0,1,0)$. This is not a Class $0$ frame. The hand moves to index $3$. (Frames examined: $3$)\n4.  **Index $3$**: State is $(1,0,0)$. This is not a Class $0$ frame. It is unlocked and has $R=1$. LA-ESC clears the reference bit. The frame's state becomes $(0,0,0)$. The hand moves to index $4$. (Frames examined: $4$)\n5.  **Index $4$**: State is $(0,0,0)$. This is an unlocked Class $0$ frame. The algorithm has found a suitable victim. The scan stops. (Frames examined: $5$)\n\nThe victim selected by LA-ESC is the frame at **index $4$**.\n\nThe total eviction latency for LA-ESC is determined by the scan cost.\n-   Number of frames examined: $5$ (indices $0, 1, 2, 3, 4$).\n-   Scan cost is $5 \\times c_s = 5$ time units.\n-   The selected victim at index $4$ is unlocked ($L=0$), so there is no waiting cost.\n-   The total eviction latency for LA-ESC is $5$ time units.\n\n#### Comparison and Deadlock Analysis\n\n-   **Victim Identification**: LA-ESC evicts the frame at index $4$.\n-   **Latency Comparison**: LA-ESC latency is $5$ time units. Baseline ESC latency is $11$ time units. Thus, for this snapshot, LA-ESC has a strictly lower latency ($5 < 11$).\n-   **Deadlock Analysis**: Deadlock requires four necessary conditions (Coffman conditions): mutual exclusion, hold-and-wait, no preemption, and circular wait. The scenario of concern is a deadlock involving the pager and a process performing I/O.\n    -   **Mutual Exclusion**: A locked page frame is a mutually exclusive resource. This holds.\n    -   **No Preemption**: The pager cannot forcibly unlock a frame locked for I/O. This holds.\n    -   **Hold-and-Wait & Circular Wait**: Consider the Baseline ESC policy. The pager, needing to free a frame, can select a locked frame and enter a wait state. It is \"holding\" its current task (resolving a page fault) while \"waiting\" for the I/O lock to be released. If the process holding the I/O lock subsequently experiences a page fault, it will wait for the pager. A circular wait (Pager waits for Process, Process waits for Pager) now exists, causing a deadlock. The Baseline ESC policy creates a situation where the **hold-and-wait** condition is met by the pager, enabling this deadlock.\n    -   The LA-ESC policy, by contrast, is defined to *never* wait for a locked frame. When it encounters a locked frame, it simply skips it and continues its search for an unlocked victim. By refusing to wait for the locked resource, the LA-ESC policy explicitly breaks the **hold-and-wait** condition for the pager. Since one of the necessary conditions for deadlock is not met, this type of eviction-stage deadlock is prevented.\n\n### Step 3: Evaluation of Options\n\n-   **A. LA-ESC evicts index $4$; by never waiting on $L=1$, it breaks hold-and-wait in the eviction path and prevents such deadlock; its eviction latency on this snapshot is $5$ time units, which is strictly less than the baseline ESC latency of $11$ time units.**\n    -   LA-ESC evicts index $4$: Correct, as derived above.\n    -   It breaks hold-and-wait and prevents deadlock: Correct, as per the deadlock analysis.\n    -   Its eviction latency is $5$: Correct.\n    -   Its latency is strictly less than baseline's $11$: Correct ($5 < 11$).\n    -   **Verdict: Correct.**\n\n-   **B. LA-ESC evicts index $2$; it does not change deadlock risk because it might still wait on locks later in the scan; its eviction latency equals that of baseline ESC.**\n    -   LA-ESC evicts index $2$: Incorrect. It finds the Class $0$ frame at index $4$.\n    -   It does not change deadlock risk: Incorrect. The definition states it never waits, which is the mechanism that changes the deadlock risk.\n    -   Its eviction latency equals baseline's: Incorrect ($5 \\neq 11$).\n    -   **Verdict: Incorrect.**\n\n-   **C. LA-ESC evicts index $4$; it cannot prevent deadlock because mutual exclusion still holds, and its eviction latency is higher than the baseline due to extra scanning.**\n    -   LA-ESC evicts index $4$: Correct.\n    -   It cannot prevent deadlock because mutual exclusion still holds: Incorrect reasoning. Breaking any one of the four Coffman conditions is sufficient to prevent deadlock. LA-ESC breaks hold-and-wait.\n    -   Its eviction latency is higher: Incorrect. Its total latency is $5$, which is less than the baseline's $11$.\n    -   **Verdict: Incorrect.**\n\n-   **D. LA-ESC evicts index $0$ after waiting for $L$ to clear, preserving fairness; deadlock cannot occur in either policy because I/O always completes eventually, so their latencies are comparable.**\n    -   LA-ESC evicts index $0$ after waiting: Incorrect. This describes the Baseline ESC policy. LA-ESC is defined to skip locked frames.\n    -   Deadlock cannot occur in either policy because I/O always completes eventually: Incorrect. This confuses liveness with deadlock. Deadlock is a structural circular dependency that prevents progress, regardless of how quickly an individual operation might otherwise complete. Circular wait can and does lead to deadlock.\n    -   Latencies are comparable: Incorrect. A latency of $5$ is significantly different from $11$.\n    -   **Verdict: Incorrect.**\n\nBased on the detailed analysis, only option A is consistent with the rules and the initial state provided.", "answer": "$$\\boxed{A}$$", "id": "3639395"}, {"introduction": "An algorithm's true strength is tested not just in ideal conditions, but also in the face of failure. Evicting a dirty page requires successfully writing it back to storage, an operation that can fail. This thought experiment [@problem_id:3639440] asks you to step into the role of an OS designer and evaluate different policies for handling such write-back failures. By analyzing the impact of each policy on performance, data integrity, and the logical consistency of the ESC algorithm, you will develop a deeper understanding of fault-tolerant system design.", "problem": "An operating system implements the Enhanced Second-Chance (ESC) page-replacement algorithm, also called the enhanced clock, which uses the hardware reference bit ($R$) and modify or dirty bit ($M$) to prioritize eviction among the four classes in the order $ (R=0,M=0) \\prec (R=0,M=1) \\prec (R=1,M=0) \\prec (R=1,M=1) $. The algorithm is realized with a single clock hand that sweeps cyclically over frames, clearing $R$ on visited frames with $R=1$ and attempting to evict the lowest-priority available class, consistent with this ordering.\n\nConsider a storage subsystem where a write-back of a dirty page can fail transiently. When attempting to evict a page in class $ (R=0,M=1) $, the kernel initiates a write-back. Each write attempt succeeds independently with probability $1-p$ and fails with probability $p$, where $0<p<1$. On failure, the page remains dirty (i.e., $M=1$), and its data in memory remains authoritative. Assume that reference bits $R$ are only set by the hardware on access and cleared by the hand when visited, and that a page with $R=0$ is not subsequently accessed between consecutive visits of the hand unless implied by the policy.\n\nDefine “eviction order stability” to mean both of the following: \n- the class-preference ordering $ (R=0,M=0) \\prec (R=0,M=1) \\prec (R=1,M=0) \\prec (R=1,M=1) $ is never inverted by policy actions in response to write failures, and \n- the clock hand continues to make progress without indefinite blocking.\n\nWhich of the following retry policies and impact statements is correct under these assumptions?\n\nA. On a write failure of a page with $ (R=0,M=1) $, mark the frame as writeback-deferred without changing $R$ or $M$ (so it remains in class $ (R=0,M=1) $), do not retry immediately, and reattempt at most once per subsequent full hand pass when the frame is encountered again. This preserves eviction order stability and yields an expected number of additional full hand rotations per such page equal to $ \\dfrac{p}{1-p} $, while clean pages $ (R=0,M=0) $ continue to be evicted first.\n\nB. On a write failure of a page with $ (R=0,M=1) $, synchronously retry the write until it succeeds before advancing the hand. This preserves eviction order stability and yields zero additional hand rotations per such page in expectation, at the cost of possibly longer pauses.\n\nC. On a write failure of a page with $ (R=0,M=1) $, clear $M \\leftarrow 0$ to treat the page as clean and evict immediately to maintain progress. This preserves eviction order stability and eliminates additional hand rotations entirely, with the only cost being a higher risk of re-fetch I/O later.\n\nD. On a write failure of a page with $ (R=0,M=1) $, set $R \\leftarrow 1$ to reflect recent “activity,” moving the frame into a higher-priority class. This preserves eviction order stability and yields an expected additional number of full hand rotations per such page equal to $ \\dfrac{1}{p} - 1 $ because the page will be reconsidered less frequently.", "solution": "The problem requires an evaluation of four different policies for handling transient write-back failures within the context of the Enhanced Second-Chance (ESC) page-replacement algorithm. The evaluation criteria are \"eviction order stability\" and the correctness of the stated impacts, particularly the expected number of additional hand rotations.\n\nThe ESC algorithm prioritizes pages for eviction based on their ($R, M$) bits, with the preference order $ (R=0,M=0) \\prec (R=0,M=1) \\prec (R=1,M=0) \\prec (R=1,M=1) $, where $\\prec$ means \"is a better candidate for eviction than\". \"Eviction order stability\" is defined as preserving this preference order and ensuring the clock hand makes progress without indefinite blocking.\n\nThe scenario under consideration is a write-back attempt for a page in class $(R=0, M=1)$, which fails with probability $p$ and succeeds with probability $1-p$, for $0 < p < 1$.\n\nLet's analyze each option.\n\n**A. On a write failure of a page with $(R=0,M=1)$, mark the frame as writeback-deferred without changing $R$ or $M$ (so it remains in class $(R=0,M=1)$), do not retry immediately, and reattempt at most once per subsequent full hand pass when the frame is encountered again. This preserves eviction order stability and yields an expected number of additional full hand rotations per such page equal to $\\dfrac{p}{1-p}$, while clean pages $(R=0,M=0)$ continue to be evicted first.**\n\n*   **Eviction Order Stability Analysis**:\n    1.  **Order Preservation**: The policy keeps the page in class $(R=0, M=1)$. By not altering its class, the fundamental preference ordering of the ESC algorithm is respected. The clock hand, upon advancing, will still correctly evict any page of class $(R=0, M=0)$ it encounters before returning to this deferred page, upholding the $ (R=0,M=0) \\prec (R=0,M=1) $ rule. Thus, the preference order is not inverted.\n    2.  **Progress**: The policy explicitly states that the hand is not blocked and continues its scan. Therefore, the hand makes progress, and there is no indefinite blocking.\n    Both conditions for eviction order stability are met. The claim that it \"preserves eviction order stability\" is correct.\n\n*   **Impact Analysis**:\n    The claim that \"clean pages $(R=0,M=0)$ continue to be evicted first\" is a direct consequence of preserving the order and making progress.\n    The core of the impact analysis is the expected number of additional full hand rotations. Let $K$ be the random variable for the number of additional rotations. A write attempt is made. If it succeeds (probability $1-p$), no additional rotation is needed, so $K=0$. If it fails (probability $p$), the hand must complete one full rotation to return to the frame for another attempt. This sequence of independent trials (one per rotation) is a Bernoulli process. The number of failures $k$ before the first success follows a geometric distribution with success probability $1-p$.\n    The probability mass function for the number of failures $k$ is $P(K=k) = p^k (1-p)$ for $k = 0, 1, 2, \\dots$.\n    The expected value of $K$ is given by:\n    $$ E[K] = \\sum_{k=0}^{\\infty} k \\cdot P(K=k) = \\sum_{k=0}^{\\infty} k p^k (1-p) = (1-p) \\sum_{k=1}^{\\infty} k p^k $$\n    Using the known sum for the arithmetico-geometric series $\\sum_{k=1}^{\\infty} kx^k = \\frac{x}{(1-x)^2}$, with $x=p$:\n    $$ E[K] = (1-p) \\left( \\frac{p}{(1-p)^2} \\right) = \\frac{p}{1-p} $$\n    The calculated expected number of additional rotations matches the value given in the option.\n\n*   **Verdict**: **Correct**. The policy preserves stability, and the probabilistic analysis of its performance is accurate.\n\n**B. On a write failure of a page with $(R=0,M=1)$, synchronously retry the write until it succeeds before advancing the hand. This preserves eviction order stability and yields zero additional hand rotations per such page in expectation, at the cost of possibly longer pauses.**\n\n*   **Eviction Order Stability Analysis**:\n    1.  **Order Preservation**: By stalling on the current page, the algorithm doesn't select a page of a higher-priority class. In this sense, the ordering is not violated.\n    2.  **Progress**: The hand is blocked until the write succeeds. The number of retries is not bounded; with probability $p^N$, the process is still blocked after $N$ attempts. This constitutes \"indefinite blocking\" in the sense of an unbounded delay, which can halt the entire page replacement mechanism for an arbitrarily long time. This violates the second condition for eviction order stability.\n\n*   **Verdict**: **Incorrect**. The claim that this policy \"preserves eviction order stability\" is false because it fails the \"no indefinite blocking\" requirement.\n\n**C. On a write failure of a page with $(R=0,M=1)$, clear $M \\leftarrow 0$ to treat the page as clean and evict immediately to maintain progress. This preserves eviction order stability and eliminates additional hand rotations entirely, with the only cost being a higher risk of re-fetch I/O later.**\n\n*   **Scientific and Factual Soundness Analysis**:\n    The problem states that on write failure, \"data in memory remains authoritative.\" This policy proposes to clear the modify bit ($M \\leftarrow 0$) and evict the page frame. Evicting a frame whose dirty contents have not been successfully written to backing store results in the loss of those modifications. This constitutes data corruption. Such a policy violates the fundamental correctness principles of an operating system's memory manager. The description of the cost as merely a \"higher risk of re-fetch I/O\" is a severe mischaracterization; the cost is data loss. A policy that corrupts data cannot be considered a valid solution.\n\n*   **Verdict**: **Incorrect**. The policy is fundamentally unsound because it leads to data corruption, violating the implicit requirement of system correctness and the explicit statement that the in-memory data is authoritative after a failed write.\n\n**D. On a write failure of a page with $(R=0,M=1)$, set $R \\leftarrow 1$ to reflect recent “activity,” moving the frame into a higher-priority class. This preserves eviction order stability and yields an expected additional number of full hand rotations per such page equal to $\\dfrac{1}{p} - 1$ because the page will be reconsidered less frequently.**\n\n*   **Eviction Order Stability Analysis**:\n    1.  **Order Preservation**: This policy changes the page's class from $(R=0, M=1)$ to $(R=1, M=1)$. This moves the page from the second-best candidate for eviction to the worst candidate for eviction. This is a direct inversion of the eviction preference. A page selected for eviction is given a reprieve and promoted above pages that might have been recently referenced (e.g., class $(R=1, M=0)$). This action violates the first condition of eviction order stability.\n    2.  **Progress**: The hand would advance, so there is no blocking. However, the first condition is already violated.\n\n*   **Impact Analysis**:\n    The claim that this \"preserves eviction order stability\" is false. Let's also examine the expected value calculation. The formula for the expected number of *failures* before the first success in a Bernoulli process with success probability $s$ is $(1-s)/s$. Here, the success probability is $s = 1-p$, so the expected number of failures is $p/(1-p)$. The formula given is $\\frac{1}{p} - 1$. These are not generally equal. For instance, if $p=0.1$, $\\frac{1}{p}-1 = 9$, while $\\frac{p}{1-p} = \\frac{0.1}{0.9} \\approx 0.111$. The formula is incorrect; it appears to confuse the probability of failure with the probability of success.\n\n*   **Verdict**: **Incorrect**. The policy violates the order preservation requirement of stability. Furthermore, the mathematical formula for the expected number of rotations is incorrect.\n\nBased on the analysis, only option A describes a policy that is consistent with the stability requirements and provides a correct analysis of its performance impact.", "answer": "$$\\boxed{A}$$", "id": "3639440"}]}