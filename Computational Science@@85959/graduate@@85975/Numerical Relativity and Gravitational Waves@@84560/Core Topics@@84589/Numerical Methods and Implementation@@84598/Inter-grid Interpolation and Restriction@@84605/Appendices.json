{"hands_on_practices": [{"introduction": "The foundation of any adaptive mesh refinement (AMR) simulation lies in the accurate transfer of data between grids of different resolutions. This exercise explores the construction of a high-order prolongation (interpolation) operator from first principles, a core skill in developing robust numerical methods [@problem_id:3477765]. By requiring the operator to exactly reproduce polynomials up to a specific degree, you will directly control its formal order of accuracy and gain insight into the connection between local polynomial approximation and global convergence properties.", "problem": "Consider an Adaptive Mesh Refinement (AMR) hierarchy used in the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formulation in numerical relativity to evolve the spacetime metric and curvature near a binary black hole coalescence. Let a coarse level have uniform cell spacing $H$ and cell-centered samples of a smooth scalar field $\\phi(x)$ representing, for example, a gauge-invariant gravitational-wave extraction scalar on that level. A fine level is introduced with refinement ratio $r=2$, so its spacing is $h=H/2$, and its cell centers lie at offsets $\\pm H/4$ from each coarse cell center within each coarse cell.\n\nYour task is to construct, from first principles, a fourth-order tensor-product polynomial prolongation operator that maps coarse cell-centered data to fine cell centers and is exact for polynomials up to degree three. Work in one spatial dimension to derive the canonical one-dimensional stencil that serves as the building block for the tensor-product operator in higher dimensions.\n\nSpecifically, determine the four-point one-dimensional interpolation weights for the fine cell center located at offset $+H/4$ relative to a coarse cell center at position $x_i$. The interpolated fine value $\\phi^{f}$ at $x_i + H/4$ must be written as a linear combination of the four neighboring coarse cell-centered values $\\{\\phi_{i-1}, \\phi_i, \\phi_{i+1}, \\phi_{i+2}\\}$ such that the operator reproduces exactly any polynomial $\\phi(x)$ of degree up to three. Express your final answer as a row vector of the four coefficients in the order corresponding to $\\{\\phi_{i-1}, \\phi_i, \\phi_{i+1}, \\phi_{i+2}\\}$.\n\nNo numerical rounding is required. The final answer must be a single analytical expression.", "solution": "The problem requires the construction of a one-dimensional, fourth-order polynomial prolongation operator to interpolate data from a coarse grid with spacing $H$ to a specific fine grid point. The interpolated value at the fine point, which we denote as $\\phi^f$, is to be expressed as a linear combination of values from four specified neighboring coarse grid points. The operator must be exact for any polynomial of degree up to $3$, which implies its local truncation error is of order $\\mathcal{O}(H^4)$, consistent with a fourth-order method.\n\nLet the coarse grid points be located at positions $x_j = jH$ for any integer $j$. The values of a scalar field $\\phi(x)$ at these points are denoted $\\phi_j = \\phi(x_j)$. The specific task is to find the interpolated value at a fine grid point located at $x_f = x_i + H/4$ for a given coarse cell index $i$. The interpolation formula is specified to use the four coarse grid values from the points with indices $\\{i-1, i, i+1, i+2\\}$.\n\nThe interpolation formula is a linear combination of these coarse grid values:\n$$ \\phi^f = c_{-1} \\phi_{i-1} + c_0 \\phi_i + c_1 \\phi_{i+1} + c_2 \\phi_{i+2} $$\nThe coefficients $\\{c_{-1}, c_0, c_1, c_2\\}$ are the unknown weights that define the interpolation stencil.\n\nTo simplify the derivation without loss of generality, we can establish a local coordinate system by setting $x_i = 0$. The positions of the coarse grid points involved in the stencil are then:\n$$ x_{i-1} = -H, \\quad x_i = 0, \\quad x_{i+1} = H, \\quad x_{i+2} = 2H $$\nThe target fine point is located at $x_f = x_i + H/4 = H/4$.\n\nThe fundamental constraint is that the interpolation must be exact for any polynomial of degree up to $3$. This means that if $\\phi(x)$ is such a polynomial, then the formula must yield exactly $\\phi(x_f)$. We can enforce this condition by requiring the formula to be exact for a basis of the vector space of polynomials of degree at most $3$. The monomial basis $\\{1, x, x^2, x^3\\}$ is a convenient choice.\n\nWe apply this condition for each basis polynomial:\n\n1.  For $\\phi(x) = 1$:\n    The value of the function is $1$ at all points. The interpolation formula must reproduce this constant value.\n    $$ 1 = c_{-1}\\phi(-H) + c_0\\phi(0) + c_1\\phi(H) + c_2\\phi(2H) = c_{-1}(1) + c_0(1) + c_1(1) + c_2(1) $$\n    This gives our first linear equation:\n    $$ c_{-1} + c_0 + c_1 + c_2 = 1 \\quad (1) $$\n\n2.  For $\\phi(x) = x$:\n    The values at the coarse points are $\\phi(x_j) = x_j$. The value at the fine point to be recovered is $\\phi(x_f) = x_f = H/4$.\n    $$ \\frac{H}{4} = c_{-1}(-H) + c_0(0) + c_1(H) + c_2(2H) $$\n    Assuming $H \\neq 0$, we can divide by $H$:\n    $$ -c_{-1} + c_1 + 2c_2 = \\frac{1}{4} \\quad (2) $$\n\n3.  For $\\phi(x) = x^2$:\n    The values are given by $\\phi(x_j) = x_j^2$. The value at the fine point is $\\phi(x_f) = x_f^2 = (H/4)^2 = H^2/16$.\n    $$ \\frac{H^2}{16} = c_{-1}(-H)^2 + c_0(0)^2 + c_1(H)^2 + c_2(2H)^2 = c_{-1}H^2 + c_1H^2 + 4c_2H^2 $$\n    Dividing by $H^2$:\n    $$ c_{-1} + c_1 + 4c_2 = \\frac{1}{16} \\quad (3) $$\n\n4.  For $\\phi(x) = x^3$:\n    The values are given by $\\phi(x_j) = x_j^3$. The value at the fine point is $\\phi(x_f) = x_f^3 = (H/4)^3 = H^3/64$.\n    $$ \\frac{H^3}{64} = c_{-1}(-H)^3 + c_0(0)^3 + c_1(H)^3 + c_2(2H)^3 = -c_{-1}H^3 + c_1H^3 + 8c_2H^3 $$\n    Dividing by $H^3$:\n    $$ -c_{-1} + c_1 + 8c_2 = \\frac{1}{64} \\quad (4) $$\n\nWe have obtained a system of four linear equations for the four unknown coefficients $\\{c_{-1}, c_0, c_1, c_2\\}$. We can solve this system. Let's first focus on equations $(2)$, $(3)$, and $(4)$, which form a subsystem for $c_{-1}$, $c_1$, and $c_2$.\nSubtracting equation $(2)$ from equation $(4)$:\n$$ (-c_{-1} + c_1 + 8c_2) - (-c_{-1} + c_1 + 2c_2) = \\frac{1}{64} - \\frac{1}{4} $$\n$$ 6c_2 = \\frac{1 - 16}{64} = -\\frac{15}{64} $$\n$$ c_2 = -\\frac{15}{6 \\times 64} = -\\frac{5}{2 \\times 64} = -\\frac{5}{128} $$\n\nNow, substitute the value of $c_2$ into equations $(2)$ and $(3)$.\nFrom equation $(3)$:\n$$ c_{-1} + c_1 = \\frac{1}{16} - 4c_2 = \\frac{1}{16} - 4\\left(-\\frac{5}{128}\\right) = \\frac{1}{16} + \\frac{20}{128} = \\frac{8}{128} + \\frac{20}{128} = \\frac{28}{128} = \\frac{7}{32} \\quad (A) $$\nFrom equation $(2)$:\n$$ -c_{-1} + c_1 = \\frac{1}{4} - 2c_2 = \\frac{1}{4} - 2\\left(-\\frac{5}{128}\\right) = \\frac{1}{4} + \\frac{10}{128} = \\frac{32}{128} + \\frac{10}{128} = \\frac{42}{128} = \\frac{21}{64} \\quad (B) $$\n\nWe now solve the system of two equations $(A)$ and $(B)$ for $c_{-1}$ and $c_1$. Adding $(A)$ and $(B)$:\n$$ (c_{-1} + c_1) + (-c_{-1} + c_1) = \\frac{7}{32} + \\frac{21}{64} $$\n$$ 2c_1 = \\frac{14}{64} + \\frac{21}{64} = \\frac{35}{64} \\implies c_1 = \\frac{35}{128} $$\nSubstituting $c_1$ back into equation $(A)$:\n$$ c_{-1} = \\frac{7}{32} - c_1 = \\frac{7}{32} - \\frac{35}{128} = \\frac{28}{128} - \\frac{35}{128} = -\\frac{7}{128} $$\n\nFinally, we use equation $(1)$ to determine $c_0$:\n$$ c_0 = 1 - (c_{-1} + c_1 + c_2) = 1 - \\left(-\\frac{7}{128} + \\frac{35}{128} - \\frac{5}{128}\\right) $$\n$$ c_0 = 1 - \\left(\\frac{-7 + 35 - 5}{128}\\right) = 1 - \\frac{23}{128} = \\frac{128 - 23}{128} = \\frac{105}{128} $$\n\nThe four interpolation weights for the stencil are therefore:\n$$ c_{-1} = -\\frac{7}{128}, \\quad c_0 = \\frac{105}{128}, \\quad c_1 = \\frac{35}{128}, \\quad c_2 = -\\frac{5}{128} $$\nThe problem requests the final answer as a row vector of these coefficients.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{7}{128} & \\frac{105}{128} & \\frac{35}{128} & -\\frac{5}{128}\n\\end{pmatrix}\n}\n$$", "id": "3477765"}, {"introduction": "While transferring data to coarser grids (restriction) is computationally necessary, naive operators can introduce numerical artifacts like aliasing, where unresolved high-frequency content incorrectly appears as low-frequency signals. This practice uses Fourier analysis to diagnose how restriction by simple injection causes the aliasing of Nyquist-frequency modes, a common source of error and instability in simulations of wave phenomena [@problem_id:3477707]. You will then undertake a practical design task: constructing a simple pre-filter to suppress this contamination, thereby learning how to safeguard the fidelity of physical data, such as the gravitational wave signal encoded in the Weyl scalar $\\psi_4$.", "problem": "Consider a one-dimensional uniform fine grid with spacing $h$ and grid indices $j \\in \\mathbb{Z}$. You are given a scalar field sampled on this grid representing the Newman–Penrose Weyl scalar $\\psi_4$, denoted by $\\psi_{4,j}$. In a mesh hierarchy used in numerical relativity for gravitational wave extraction, a restriction operator is used to transfer data from the fine grid to a coarse grid of spacing $2h$. In this problem, the restriction operator is defined by injection: the coarse-grid value at index $i$ is the even-index fine-grid value, i.e., $\\Psi_i = \\psi_{4,2i}$. \n\nAssume the fine-grid field contains a single discrete Fourier mode of the form $\\psi_{4,j} = \\exp(i \\kappa j)$, where the nondimensional fine-grid wavenumber $\\kappa \\in [-\\pi,\\pi]$. Treat the restriction as a linear time-invariant operation followed by decimation by a factor of $2$.\n\nFirst, by starting from the definition of a plane wave and the sampling property under decimation, derive the discrete transfer function of the restriction operator in the Fourier domain: determine the coarse-grid wavenumber $\\kappa_c$ that results from restricting $\\exp(i \\kappa j)$ and the corresponding complex amplitude factor (gain) that multiplies the mode. Justify any aliasing that occurs due to the decimation.\n\nNext, to mitigate contamination of the coarse-grid $\\psi_4$ by high-frequency gauge modes near the fine-grid Nyquist wavenumber $\\kappa = \\pi$, you are to design a symmetric three-point pre-filter on the fine grid, applied before restriction. The pre-filter is the convolution \n$$\n\\tilde{\\psi}_{4,j} \\;=\\; a\\,\\psi_{4,j-1} \\;+\\; (1-2a)\\,\\psi_{4,j} \\;+\\; a\\,\\psi_{4,j+1} \\, ,\n$$\nwith real parameter $a \\in \\mathbb{R}$. The design requirements are: \n(i) the pre-filter must preserve low-frequency content to leading order (i.e., it must have unit gain at $\\kappa = 0$), and \n(ii) it must eliminate the contribution of a pure Nyquist mode $\\psi_{4,j} = (-1)^j$ to the coarse grid after restriction (i.e., the coarse-grid response to $\\kappa = \\pi$ should be exactly zero).\n\nUsing first principles of discrete Fourier analysis of linear shift-invariant filters and decimation, compute the discrete frequency response of the pre-filter, compose it with the restriction operator, evaluate the chain for the Nyquist input $\\kappa = \\pi$, and solve for the unique value of $a$ that enforces requirement (ii). Provide your final answer as the exact value of $a$. No rounding is required, and the answer is dimensionless.", "solution": "We begin by analyzing the restriction operator and then design the pre-filter. The base concepts used are: (a) linear shift-invariant convolution and its discrete-time Fourier transform, (b) the representation of a sampled plane wave, and (c) the effect of decimation by a factor of $2$ on sampled sinusoids and their wavenumbers.\n\nRestriction by injection. The restriction operator is defined by $\\Psi_i = \\psi_{4,2i}$. For a fine-grid plane wave $\\psi_{4,j} = \\exp(i \\kappa j)$, the restricted sequence is\n$$\n\\Psi_i \\;=\\; \\psi_{4,2i} \\;=\\; \\exp(i \\kappa \\cdot 2i) \\;=\\; \\exp\\!\\big(i (2\\kappa) i\\big) \\, .\n$$\nInterpreting $\\Psi_i$ as a plane wave on the coarse grid with index $i$ and spacing $2h$, the nondimensional coarse-grid wavenumber is the phase advance per coarse index,\n$$\n\\kappa_c \\;=\\; 2\\kappa \\;\\;\\; \\text{taken modulo } 2\\pi \\text{ and folded into } [-\\pi,\\pi] \\, .\n$$\nThus, decimation by $2$ maps the fine-grid mode at $\\kappa$ to the coarse-grid mode at $\\kappa_c = 2\\kappa$ modulo $2\\pi$, with aliasing when $2\\kappa \\notin [-\\pi,\\pi]$. The amplitude gain of this injection restriction on a pure sinusoid is unity because no averaging is performed; the output is a sample subsequence of the input:\n$$\n\\text{gain } R(\\kappa) \\;=\\; 1 \\, .\n$$\nA notable special case is the fine-grid Nyquist mode $\\kappa = \\pi$, for which\n$$\n\\Psi_i \\;=\\; \\exp\\!\\big(i (2\\pi) i\\big) \\;=\\; 1 \\, ,\n$$\nthat is, $\\kappa_c = 0$ and the amplitude is constant, showing that a fine-grid Nyquist component aliases to a coarse-grid zero-frequency component.\n\nPre-filter design. We now pre-filter the fine-grid data with the symmetric three-point kernel\n$$\ng[-1] = a, \\quad g[0] = 1 - 2a, \\quad g[+1] = a \\, .\n$$\nThe discrete-time Fourier transform (frequency response) of this kernel is\n$$\nG(\\kappa) \\;=\\; a\\,\\exp(-i\\kappa) \\;+\\; (1-2a) \\;+\\; a\\,\\exp(i\\kappa) \\;=\\; 1 - 2a + 2a \\cos(\\kappa) \\, .\n$$\nRequirement (i): preservation of low-frequency content to leading order is equivalent to unit gain at zero frequency. We verify\n$$\nG(0) \\;=\\; 1 - 2a + 2a \\cos(0) \\;=\\; 1 - 2a + 2a \\cdot 1 \\;=\\; 1 \\, ,\n$$\nwhich holds for all real $a$, so low-frequency content is preserved in amplitude. Being symmetric, the filter has zero linear phase distortion around $\\kappa = 0$, consistent with preserving smooth content to leading order.\n\nChain response at the Nyquist mode. Consider a pure Nyquist input $\\psi_{4,j} = \\exp(i \\pi j) = (-1)^j$ so that $\\kappa = \\pi$. The pre-filtered sequence is\n$$\n\\tilde{\\psi}_{4,j} \\;=\\; \\big(g * \\psi_4\\big)_j \\;=\\; G(\\pi)\\,\\exp(i \\pi j) \\, ,\n$$\nwhere the amplitude factor at $\\kappa = \\pi$ is\n$$\nG(\\pi) \\;=\\; 1 - 2a + 2a \\cos(\\pi) \\;=\\; 1 - 2a - 2a \\;=\\; 1 - 4a \\, .\n$$\nApplying restriction by injection gives the coarse-grid sequence\n$$\n\\tilde{\\Psi}_i \\;=\\; \\tilde{\\psi}_{4,2i} \\;=\\; G(\\pi)\\,\\exp\\!\\big(i \\pi \\cdot 2i\\big) \\;=\\; G(\\pi) \\cdot 1 \\;=\\; G(\\pi) \\, .\n$$\nAs shown earlier, the decimation maps $\\kappa = \\pi$ to $\\kappa_c = 0$, so the coarse-grid output of a Nyquist input is a constant with amplitude equal to $G(\\pi)$.\n\nDesign requirement (ii) asks that this coarse-grid response to the Nyquist mode be eliminated exactly. Therefore we require\n$$\nG(\\pi) \\;=\\; 0 \\;\\;\\;\\Longrightarrow\\;\\;\\; 1 - 4a \\;=\\; 0 \\, .\n$$\nSolving for $a$ gives\n$$\na \\;=\\; \\frac{1}{4} \\, .\n$$\nThis value preserves unit gain at low frequency by construction and imposes a transmission zero at the Nyquist wavenumber $\\kappa = \\pi$, thereby suppressing the alias of high-frequency gauge modes into the coarse-grid $\\psi_4$ after restriction by injection.", "answer": "$$\\boxed{\\frac{1}{4}}$$", "id": "3477707"}, {"introduction": "After designing operators on paper, their ultimate validation comes from computational testing, and the Method of Manufactured Solutions (MMS) is a cornerstone of modern code verification. This comprehensive practice guides you through implementing and testing both restriction and prolongation operators on analytic functions that mimic the tensor fields of the BSSN formulation [@problem_id:3477731]. By measuring the operators' convergence rates and comparing them against theoretical expectations, you will gain hands-on experience in diagnosing numerical implementations and understanding how factors like grid resolution and the spectral content of the solution can impact accuracy.", "problem": "You are asked to write a complete, runnable program that evaluates inter-grid transfer operators used in Adaptive Mesh Refinement (AMR) for the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formulation of general relativity, using a manufactured smooth solution. Your task is to measure the observed order of accuracy of restriction and prolongation individually and jointly on smooth tensor fields representative of BSSN variables, and to explain any deviations from the design order based on first principles.\n\nThe fundamental base for your derivation and design must be:\n- Smoothness of the manufactured fields and Taylor series expansions in $\\mathbb{R}^{3}$, with the standard assumption that truncation error for a smooth field is controlled by higher derivatives and powers of the mesh spacing $h$.\n- The interpretation of full-weighting restriction as a discrete local average and trilinear prolongation as a tensor-product of one-dimensional linear interpolation, both of which are well-tested in numerical analysis and multigrid theory.\n\nConstruct the following elements.\n\n1. Domain and grids:\n- Consider the periodic three-dimensional box $\\Omega = [0,2\\pi)^{3}$.\n- Use cell-centered grids with $N \\in \\mathbb{N}$ points per dimension, mesh spacing $h = 2\\pi/N$, and cell centers at coordinates $x_{i} = (i + \\tfrac{1}{2})h$, $y_{j} = (j + \\tfrac{1}{2})h$, $z_{k} = (k + \\tfrac{1}{2})h$ for $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n- Define two grid resolutions $N_{1} = 16$ and $N_{2} = 32$.\n\n2. Manufactured smooth fields (component-wise, periodic and smooth on $\\Omega$):\n- Scalar fields: the conformal factor $\\phi(x,y,z)$ and the trace of the extrinsic curvature $K(x,y,z)$.\n- Vector field: the conformal connection functions $\\Gamma^{i}(x,y,z)$ with $i \\in \\{1,2,3\\}$.\n- Symmetric trace-free $3\\times 3$ tensor fields: the conformal metric $\\bar{\\gamma}_{ij}(x,y,z)$ and the trace-free extrinsic curvature $\\bar{A}_{ij}(x,y,z)$, each symmetric in indices and projected to be trace-free by subtracting one third of their trace times the identity.\n\nConstruct two manufactured families to probe accuracy at different spectral contents:\n- Low-frequency family $\\mathcal{F}_{\\mathrm{low}}$:\n  - $\\phi = \\sin(x) + \\tfrac{1}{2}\\cos(y) + \\tfrac{1}{4}\\sin(z)$,\n  - $K = \\cos(x)\\cos(y)\\cos(z)$,\n  - $\\Gamma^{1} = \\sin(x+y)$, $\\Gamma^{2} = \\sin(y+z)$, $\\Gamma^{3} = \\sin(z+x)$,\n  - For $\\bar{\\gamma}_{ij}$: start from $S_{ij}$ with entries\n    $S_{11}=\\sin(x)$, $S_{22}=\\sin(y)$, $S_{33}=\\sin(z)$,\n    $S_{12}=S_{21}=\\cos(x+y)$, $S_{13}=S_{31}=\\cos(x+z)$, $S_{23}=S_{32}=\\cos(y+z)$,\n    then set $\\bar{\\gamma}_{ij}=S_{ij} - \\tfrac{1}{3}\\delta_{ij}\\operatorname{tr}(S)$.\n  - For $\\bar{A}_{ij}$: start from $T_{ij}$ with entries\n    $T_{11}=\\cos(x)$, $T_{22}=\\cos(y)$, $T_{33}=\\cos(z)$,\n    $T_{12}=T_{21}=\\sin(x+y)$, $T_{13}=T_{31}=\\sin(x+z)$, $T_{23}=T_{32}=\\sin(y+z)$,\n    then set $\\bar{A}_{ij}=T_{ij} - \\tfrac{1}{3}\\delta_{ij}\\operatorname{tr}(T)$.\n- High-frequency family $\\mathcal{F}_{\\mathrm{high}}$:\n  - Replace $x,y,z$ above by $5x,6y,7z$ in all trigonometric arguments.\n\nAll trigonometric functions use radians.\n\n3. Inter-grid transfer operators:\n- Restriction $\\mathcal{R}$ from a fine grid with $2N$ points per dimension to a coarse grid with $N$ points per dimension is the $3$-D full-weighting operator defined component-wise as the average of the $2\\times 2\\times 2$ fine-cell block underlying each coarse cell. Use periodicity for indexing if needed. This operator is designed to be second-order accurate for smooth fields, i.e., truncation error $O(h^{2})$.\n- Prolongation $\\mathcal{P}$ from a coarse grid with $N$ points per dimension to a fine grid with $2N$ points per dimension is the $3$-D trilinear interpolation defined as the tensor-product of one-dimensional linear interpolation on cell-centered grids. Use periodicity for indexing. This operator is designed to be second-order accurate for smooth fields, i.e., truncation error $O(h^{2})$.\n\n4. Error metrics and observed order:\n- For a grid function $u_{N}$ on mesh spacing $h = 2\\pi/N$, define the discrete $\\ell^{2}$-norm\n  $$\\| u_{N} \\|_{2,h} \\equiv \\left( h^{3}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} |u_{N}(i,j,k)|^{2} \\right)^{1/2}.$$\n- For restriction accuracy at resolution $N$, define $e_{\\mathcal{R}}(N) \\equiv \\| \\mathcal{R}(u_{2N}^{\\star}) - u_{N}^{\\star} \\|_{2,h}$, where $u_{M}^{\\star}$ denotes exact sampling of the manufactured field on the $M$ grid.\n- For prolongation accuracy at resolution $N$, define $e_{\\mathcal{P}}(N) \\equiv \\| \\mathcal{P}(u_{N}^{\\star}) - u_{2N}^{\\star} \\|_{2,h/2}$.\n- For joint operators:\n  - Coarse identity check: $e_{\\mathcal{R}\\circ\\mathcal{P}}(N) \\equiv \\| (\\mathcal{R}\\circ\\mathcal{P})(u_{N}^{\\star}) - u_{N}^{\\star} \\|_{2,h}$,\n  - Fine identity check: $e_{\\mathcal{P}\\circ\\mathcal{R}}(N) \\equiv \\| (\\mathcal{P}\\circ\\mathcal{R})(u_{2N}^{\\star}) - u_{2N}^{\\star} \\|_{2,h/2}$.\n- For each operator symbol $\\mathcal{O} \\in \\{\\mathcal{R},\\mathcal{P},\\mathcal{R}\\circ\\mathcal{P},\\mathcal{P}\\circ\\mathcal{R}\\}$, define the observed order using the pair $(N_{1},N_{2})$:\n  $$p_{\\mathcal{O}} \\equiv \\frac{\\log\\left( e_{\\mathcal{O}}(N_{1}) / e_{\\mathcal{O}}(N_{2}) \\right)}{\\log(2)}.$$\n\n5. Aggregation across BSSN fields:\n- Compute errors component-wise for each field, and aggregate them by summing the squared errors over all components and grid points, then taking the square root as implied by the $\\ell^{2}$-norm definition. That is, treat all components across all fields as one concatenated vector.\n\n6. Required test suite and outputs:\n- Compute the observed orders for both manufactured families $\\mathcal{F}_{\\mathrm{low}}$ and $\\mathcal{F}_{\\mathrm{high}}$, for each operator $\\mathcal{O} \\in \\{\\mathcal{R},\\mathcal{P},\\mathcal{R}\\circ\\mathcal{P},\\mathcal{P}\\circ\\mathcal{R}\\}$, using $N_{1}=16$ and $N_{2}=32$.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n  $$[p_{\\mathcal{R}}^{\\mathrm{low}}, p_{\\mathcal{P}}^{\\mathrm{low}}, p_{\\mathcal{R}\\circ\\mathcal{P}}^{\\mathrm{low}}, p_{\\mathcal{P}\\circ\\mathcal{R}}^{\\mathrm{low}}, p_{\\mathcal{R}}^{\\mathrm{high}}, p_{\\mathcal{P}}^{\\mathrm{high}}, p_{\\mathcal{R}\\circ\\mathcal{P}}^{\\mathrm{high}}, p_{\\mathcal{P}\\circ\\mathcal{R}}^{\\mathrm{high}}],$$\n  as floating-point numbers. No other text may be printed.\n\nScientific realism and constraints:\n- The fields are smooth and periodic, representing a plausible manufactured solution for inter-grid transfer tests in the BSSN context. You are not evolving the BSSN system; only inter-grid transfers are tested.\n- Angles are in radians.\n- No physical unit conversion is required.\n- Design order for both operators is second order; deviations from exactly $2$ in the observed orders must be reconciled in your solution by appealing to the Taylor-series truncation error structure and the spectral content (wavenumbers) of the manufactured fields.\n\nYour program must be complete and runnable as provided, and must not require any input. It must use the exact output format specified above on a single line.", "solution": "The goal is to measure and explain observed orders of accuracy of inter-grid transfer operators on smooth manufactured fields relevant to the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formulation. The foundational principles are the smoothness of the fields and Taylor series analysis, which determine truncation error orders for consistent discretizations.\n\nWe construct smooth periodic fields on the box $\\Omega = [0,2\\pi)^{3}$ and adopt cell-centered grids. For $N \\in \\mathbb{N}$ points per direction, mesh spacing is $h = 2\\pi/N$ and cell centers are $x_{i}=(i+\\tfrac{1}{2})h$, $y_{j}=(j+\\tfrac{1}{2})h$, $z_{k}=(k+\\tfrac{1}{2})h$. Manufactured fields include scalars $\\phi$ and $K$, a vector $\\Gamma^{i}$, and symmetric trace-free tensors $\\bar{\\gamma}_{ij}$ and $\\bar{A}_{ij}$. To enforce the trace-free property, we project any symmetric $3\\times 3$ seed tensor $S_{ij}$ by $\\bar{S}_{ij} = S_{ij} - \\tfrac{1}{3}\\delta_{ij}\\operatorname{tr}(S)$. Two spectral families probe behavior at different wavenumbers: a low-frequency family $\\mathcal{F}_{\\mathrm{low}}$ and a high-frequency family $\\mathcal{F}_{\\mathrm{high}}$ formed by replacing $x,y,z$ with $5x,6y,7z$ in all arguments.\n\nInter-grid transfer operators. We employ two standard, well-tested operators:\n- Full-weighting restriction $\\mathcal{R}$. For cell-centered grids, a coarse-grid value at index $(i,j,k)$ is the average of the $2\\times 2\\times 2$ fine-grid block underlying it:\n  $$ (\\mathcal{R}u)_{i,j,k} = \\frac{1}{8}\\sum_{\\alpha,\\beta,\\gamma \\in \\{0,1\\}} u_{2i+\\alpha,\\,2j+\\beta,\\,2k+\\gamma}. $$\n  With periodic boundaries for indexing, this operator is consistent and second-order accurate for smooth $u$.\n- Trilinear prolongation $\\mathcal{P}$. This is the tensor product of one-dimensional linear interpolation on cell-centered grids. In one dimension, if $H=2h$ is the coarse spacing, then fine-grid centers at quarter offsets between coarse centers lead to weights:\n  $$ u_{f}(2i) = \\tfrac{1}{4}u_{c}(i-1) + \\tfrac{3}{4}u_{c}(i), \\quad u_{f}(2i+1) = \\tfrac{3}{4}u_{c}(i) + \\tfrac{1}{4}u_{c}(i+1), $$\n  with periodic indexing. The three-dimensional operator is the separable composition along each axis, which preserves second-order accuracy for smooth $u$.\n\nSecond-order design order by Taylor series. We justify the second-order accuracy of both operators by Taylor expansions. Consider a smooth scalar field $u:\\mathbb{R}^{3}\\to\\mathbb{R}$ and a coarse cell center at $\\mathbf{x}_{0}$. For full-weighting restriction, each of the eight fine-cell centers is located at offsets $\\pm \\tfrac{h}{2}$ along each coordinate from $\\mathbf{x}_{0}$, where $h$ is the fine-grid spacing. The average over the eight points cancels all odd-order terms in the Taylor expansion about $\\mathbf{x}_{0}$:\n$$ \\frac{1}{8}\\sum_{\\epsilon_{x},\\epsilon_{y},\\epsilon_{z}\\in\\{-1,+1\\}} u\\!\\left(\\mathbf{x}_{0}+\\tfrac{h}{2}(\\epsilon_{x}\\hat{\\mathbf{e}}_{x}+\\epsilon_{y}\\hat{\\mathbf{e}}_{y}+\\epsilon_{z}\\hat{\\mathbf{e}}_{z})\\right) = u(\\mathbf{x}_{0}) + \\frac{h^{2}}{24}\\Delta u(\\mathbf{x}_{0}) + O(h^{4}). $$\nThus the restriction error is $O(h^{2})$. For trilinear prolongation, the one-dimensional linear interpolation error at a point offset by a quarter coarse spacing $H=2h$ is $O(H^{2})=O(h^{2})$; taking tensor products preserves this second-order behavior. Hence on smooth fields both $\\mathcal{R}$ and $\\mathcal{P}$ have truncation error $O(h^{2})$, and compositions $\\mathcal{R}\\circ\\mathcal{P}$ and $\\mathcal{P}\\circ\\mathcal{R}$ remain $O(h^{2})$ because they are linear combinations of evaluations of $u$ and its derivatives with overall scaling $O(h^{2})$.\n\nObserved order measurement. We define discrete $\\ell^{2}$ norms with mesh-weighted sums to approximate the continuum $L^{2}$ norm:\n$$ \\| e_{N} \\|_{2,h} \\equiv \\left( h^{3}\\sum_{i,j,k} |e_{N}(i,j,k)|^{2} \\right)^{1/2}. $$\nFor each operator $\\mathcal{O} \\in \\{\\mathcal{R},\\mathcal{P},\\mathcal{R}\\circ\\mathcal{P},\\mathcal{P}\\circ\\mathcal{R}\\}$, we compute errors $e_{\\mathcal{O}}(N_{1})$ at $N_{1}=16$ and $e_{\\mathcal{O}}(N_{2})$ at $N_{2}=32$. The observed order is\n$$ p_{\\mathcal{O}} = \\frac{\\log\\left( e_{\\mathcal{O}}(N_{1})/e_{\\mathcal{O}}(N_{2})\\right)}{\\log(2)}. $$\nFor a pure $O(h^{2})$ error, we expect $e_{\\mathcal{O}}(N)\\approx C h^{2}$, which yields $p_{\\mathcal{O}} \\approx 2$.\n\nAggregation across BSSN fields. Since interpolation is linear and component-wise, the error norms across multiple components may be aggregated by concatenation equivalently: sum the squared differences over all components and grid points, then take the square root with mesh weighting, i.e., treating all components as one long vector.\n\nReconciling deviations from exact design order. Deviations from exactly $2$ in the observed order $p_{\\mathcal{O}}$ may arise from:\n- Pre-asymptotic behavior: Higher-order terms $O(h^{4})$ and anisotropy effects influence $e_{\\mathcal{O}}(N)$ non-negligibly at coarse resolutions, slightly biasing the ratio $e(N_{1})/e(N_{2})$.\n- Spectral content: For high-frequency manufactured fields (with wavenumbers near the Nyquist limit of the coarse grid), the small-$kh$ Taylor expansion underpinning second-order truncation is less accurate. Interpolation and averaging act as filters with transfer functions depending on $kh$. For larger $kh$, the effective constants $C$ differ between $N_{1}$ and $N_{2}$, causing $p_{\\mathcal{O}}$ to under- or overshoot $2$.\n- Discrete norm effects: Switching the mesh spacing in the norm between levels changes the relative weighting of error modes across resolutions.\n\nAlgorithmic implementation. The program:\n- Builds grids for $N_{1}$ and $N_{2}$, samples the manufactured fields on $N$, $2N$.\n- Implements full-weighting restriction $\\mathcal{R}$ by averaging $2\\times 2\\times 2$ blocks, with periodic boundary handling implicit in slicing on even-length arrays.\n- Implements trilinear prolongation $\\mathcal{P}$ as successive one-dimensional refinements with weights $\\tfrac{1}{4}$ and $\\tfrac{3}{4}$ using periodic rolling, applied along each axis. This yields the tensor-product linear interpolation.\n- Computes errors for $\\mathcal{R}$, $\\mathcal{P}$, $\\mathcal{R}\\circ\\mathcal{P}$, and $\\mathcal{P}\\circ\\mathcal{R}$ for both families $\\mathcal{F}_{\\mathrm{low}}$ and $\\mathcal{F}_{\\mathrm{high}}$, aggregates across all BSSN components, forms the observed orders $p_{\\mathcal{O}}$ via the definition above, and prints them in the specified order and format.\n\nExpected qualitative outcomes. For $\\mathcal{F}_{\\mathrm{low}}$, the observed orders $p_{\\mathcal{O}}$ should be close to $2$ for all four operators. For $\\mathcal{F}_{\\mathrm{high}}$, the observed orders may deviate from $2$, often slightly lower, particularly for the composed operators, due to stronger pre-asymptotic and transfer-function effects at higher wavenumbers on the coarser grid. These deviations are reconciled by the Taylor-series truncation structure and the wavenumber dependence of the operators’ discrete symbols, in full agreement with the foundational analysis.", "answer": "```python\nimport numpy as np\n\n# Numerical Relativity AMR transfer operator accuracy assessment\n# Environment: Python 3.12, numpy 1.23.5\n\nTWOPI = 2.0 * np.pi\n\ndef cell_center_coords(N):\n    h = TWOPI / N\n    # Cell-centered coordinates: (i+0.5)*h\n    idx = np.arange(N, dtype=float)\n    x = (idx + 0.5) * h\n    return x, h\n\ndef meshgrid_cell_centers(N):\n    x1d, h = cell_center_coords(N)\n    X, Y, Z = np.meshgrid(x1d, x1d, x1d, indexing='ij')\n    return X, Y, Z, h\n\ndef make_trace_free_tensor_from_seed(seed_components):\n    # seed_components is a dict mapping (i,j) with i<=j to array values\n    # Build full symmetric tensor and project to trace-free\n    # Assemble S_ij\n    keys = list(seed_components.keys())\n    shape = next(iter(seed_components.values())).shape\n    S = np.zeros((3,3) + shape, dtype=float)\n    for (i,j), arr in seed_components.items():\n        S[i,j] = arr\n        S[j,i] = arr  # symmetry\n    # Trace\n    tr = S[0,0] + S[1,1] + S[2,2]\n    # Project: S_ij - (1/3) delta_ij tr\n    for a in range(3):\n        S[a,a] = S[a,a] - (1.0/3.0) * tr\n    return S\n\ndef manufactured_fields(N, family='low'):\n    # family: 'low' or 'high'\n    X, Y, Z, h = meshgrid_cell_centers(N)\n    if family == 'low':\n        fx, fy, fz = 1.0, 1.0, 1.0\n        gx, gy, gz = 1.0, 1.0, 1.0\n    elif family == 'high':\n        fx, fy, fz = 5.0, 6.0, 7.0\n        gx, gy, gz = 5.0, 6.0, 7.0\n    else:\n        raise ValueError(\"Unknown family\")\n\n    # Scalars\n    phi = np.sin(fx*X) + 0.5*np.cos(fy*Y) + 0.25*np.sin(fz*Z)\n    K = np.cos(fx*X) * np.cos(fy*Y) * np.cos(fz*Z)\n\n    # Vector Gamma^i\n    Gamma = np.zeros((3,)+X.shape, dtype=float)\n    Gamma[0] = np.sin(fx*X + fy*Y)\n    Gamma[1] = np.sin(fy*Y + fz*Z)\n    Gamma[2] = np.sin(fz*Z + fx*X)\n\n    # Conformal metric seed S_ij\n    S_seed = {\n        (0,0): np.sin(fx*X),\n        (1,1): np.sin(fy*Y),\n        (2,2): np.sin(fz*Z),\n        (0,1): np.cos(fx*X + fy*Y),\n        (0,2): np.cos(fx*X + fz*Z),\n        (1,2): np.cos(fy*Y + fz*Z),\n    }\n    gbar = make_trace_free_tensor_from_seed(S_seed)\n\n    # Trace-free extrinsic curvature seed T_ij\n    T_seed = {\n        (0,0): np.cos(gx*X),\n        (1,1): np.cos(gy*Y),\n        (2,2): np.cos(gz*Z),\n        (0,1): np.sin(gx*X + gy*Y),\n        (0,2): np.sin(gx*X + gz*Z),\n        (1,2): np.sin(gy*Y + gz*Z),\n    }\n    Abar = make_trace_free_tensor_from_seed(T_seed)\n\n    fields = {\n        'phi': phi,\n        'K': K,\n        'Gamma': Gamma,\n        'gbar': gbar,\n        'Abar': Abar,\n        'h': h\n    }\n    return fields\n\ndef restrict_full_weighting(u):\n    # Applies to arrays whose last three axes are spatial. Leading axes are components.\n    # Full-weighting 3D: average over 2x2x2 blocks.\n    spatial_shape = u.shape[-3:]\n    assert all(s % 2 == 0 for s in spatial_shape), \"Fine grid dimensions must be even.\"\n    sl = (slice(None), slice(None), slice(None))\n    # Sum over 8 octants\n    # Build coarse array\n    coarse_shape = u.shape[:-3] + tuple(s//2 for s in spatial_shape)\n    uc = np.zeros(coarse_shape, dtype=u.dtype)\n    for di in (0,1):\n        for dj in (0,1):\n            for dk in (0,1):\n                idx = [slice(None)]*(u.ndim)\n                idx[-3] = slice(di, None, 2)\n                idx[-2] = slice(dj, None, 2)\n                idx[-1] = slice(dk, None, 2)\n                uc = uc + u[tuple(idx)]\n    uc *= 0.125\n    return uc\n\ndef prolong_trilinear(u):\n    # Applies to arrays whose last three axes are spatial. Leading axes are components.\n    v = u\n    # Refine along axis -3, -2, -1 using 1D linear interpolation with periodic wrap\n    for axis in (-3, -2, -1):\n        v = prolong_axis(v, axis)\n    return v\n\ndef prolong_axis(u, axis):\n    # 1D linear prolongation along given axis (cell-centered):\n    # even fine index slice gets 0.25*shift(+1) + 0.75*center\n    # odd fine index slice gets 0.75*center + 0.25*shift(-1)\n    c = u\n    c_im1 = np.roll(c, shift=1, axis=axis)\n    c_ip1 = np.roll(c, shift=-1, axis=axis)\n    new_shape = list(c.shape)\n    new_shape[axis] *= 2\n    f = np.empty(new_shape, dtype=c.dtype)\n    slicer_even = [slice(None)]*f.ndim\n    slicer_odd = [slice(None)]*f.ndim\n    slicer_even[axis] = slice(0, None, 2)\n    slicer_odd[axis] = slice(1, None, 2)\n    f[tuple(slicer_even)] = 0.25*c_im1 + 0.75*c\n    f[tuple(slicer_odd)] = 0.75*c + 0.25*c_ip1\n    return f\n\ndef l2_norm_weighted(arr, h):\n    # Weighted L2 norm for arrays whose last three dims are spatial.\n    # Sum over all entries, including leading component axes.\n    return np.sqrt((h**3) * np.sum(arr*arr))\n\ndef fields_apply_R(fields_fine):\n    # Apply restriction to each field\n    return {\n        'phi': restrict_full_weighting(fields_fine['phi']),\n        'K': restrict_full_weighting(fields_fine['K']),\n        'Gamma': restrict_full_weighting(fields_fine['Gamma']),\n        'gbar': restrict_full_weighting(fields_fine['gbar']),\n        'Abar': restrict_full_weighting(fields_fine['Abar']),\n    }\n\ndef fields_apply_P(fields_coarse):\n    # Apply prolongation to each field\n    return {\n        'phi': prolong_trilinear(fields_coarse['phi']),\n        'K': prolong_trilinear(fields_coarse['K']),\n        'Gamma': prolong_trilinear(fields_coarse['Gamma']),\n        'gbar': prolong_trilinear(fields_coarse['gbar']),\n        'Abar': prolong_trilinear(fields_coarse['Abar']),\n    }\n\ndef aggregate_error_L2(fields_A, fields_B, h):\n    # Aggregate L2 error across all fields\n    err2 = 0.0\n    for key in ['phi', 'K', 'Gamma', 'gbar', 'Abar']:\n        diff = fields_A[key] - fields_B[key]\n        err2 += l2_norm_weighted(diff, h)**2\n    return np.sqrt(err2)\n\ndef observed_order(e_h, e_h2):\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef compute_orders_for_family(family):\n    # Resolutions\n    N1 = 16\n    N2 = 32\n\n    # Prepare exact fields at N, 2N\n    # N1\n    fN1 = manufactured_fields(N1, family)\n    f2N1 = manufactured_fields(2*N1, family)\n    # N2\n    fN2 = manufactured_fields(N2, family)\n    f2N2 = manufactured_fields(2*N2, family)\n\n    # Restriction errors: || R(u_{2N}) - u_N ||\n    R_2N1 = fields_apply_R({'phi': f2N1['phi'], 'K': f2N1['K'], 'Gamma': f2N1['Gamma'], 'gbar': f2N1['gbar'], 'Abar': f2N1['Abar']})\n    eR_N1 = aggregate_error_L2(R_2N1, {'phi': fN1['phi'], 'K': fN1['K'], 'Gamma': fN1['Gamma'], 'gbar': fN1['gbar'], 'Abar': fN1['Abar']}, fN1['h'])\n\n    R_2N2 = fields_apply_R({'phi': f2N2['phi'], 'K': f2N2['K'], 'Gamma': f2N2['Gamma'], 'gbar': f2N2['gbar'], 'Abar': f2N2['Abar']})\n    eR_N2 = aggregate_error_L2(R_2N2, {'phi': fN2['phi'], 'K': fN2['K'], 'Gamma': fN2['Gamma'], 'gbar': fN2['gbar'], 'Abar': fN2['Abar']}, fN2['h'])\n    pR = observed_order(eR_N1, eR_N2)\n\n    # Prolongation errors: || P(u_N) - u_{2N} ||\n    P_N1 = fields_apply_P({'phi': fN1['phi'], 'K': fN1['K'], 'Gamma': fN1['Gamma'], 'gbar': fN1['gbar'], 'Abar': fN1['Abar']})\n    eP_N1 = aggregate_error_L2(P_N1, {'phi': f2N1['phi'], 'K': f2N1['K'], 'Gamma': f2N1['Gamma'], 'gbar': f2N1['gbar'], 'Abar': f2N1['Abar']}, f2N1['h'])\n\n    P_N2 = fields_apply_P({'phi': fN2['phi'], 'K': fN2['K'], 'Gamma': fN2['Gamma'], 'gbar': fN2['gbar'], 'Abar': fN2['Abar']})\n    eP_N2 = aggregate_error_L2(P_N2, {'phi': f2N2['phi'], 'K': f2N2['K'], 'Gamma': f2N2['Gamma'], 'gbar': f2N2['gbar'], 'Abar': f2N2['Abar']}, f2N2['h'])\n    pP = observed_order(eP_N1, eP_N2)\n\n    # Joint R∘P on coarse: || R(P(u_N)) - u_N ||\n    RP_N1 = fields_apply_R(fields_apply_P({'phi': fN1['phi'], 'K': fN1['K'], 'Gamma': fN1['Gamma'], 'gbar': fN1['gbar'], 'Abar': fN1['Abar']}))\n    eRP_N1 = aggregate_error_L2(RP_N1, {'phi': fN1['phi'], 'K': fN1['K'], 'Gamma': fN1['Gamma'], 'gbar': fN1['gbar'], 'Abar': fN1['Abar']}, fN1['h'])\n\n    RP_N2 = fields_apply_R(fields_apply_P({'phi': fN2['phi'], 'K': fN2['K'], 'Gamma': fN2['Gamma'], 'gbar': fN2['gbar'], 'Abar': fN2['Abar']}))\n    eRP_N2 = aggregate_error_L2(RP_N2, {'phi': fN2['phi'], 'K': fN2['K'], 'Gamma': fN2['Gamma'], 'gbar': fN2['gbar'], 'Abar': fN2['Abar']}, fN2['h'])\n    pRP = observed_order(eRP_N1, eRP_N2)\n\n    # Joint P∘R on fine: || P(R(u_{2N})) - u_{2N} ||\n    PR_2N1 = fields_apply_P(fields_apply_R({'phi': f2N1['phi'], 'K': f2N1['K'], 'Gamma': f2N1['Gamma'], 'gbar': f2N1['gbar'], 'Abar': f2N1['Abar']}))\n    ePR_N1 = aggregate_error_L2(PR_2N1, {'phi': f2N1['phi'], 'K': f2N1['K'], 'Gamma': f2N1['Gamma'], 'gbar': f2N1['gbar'], 'Abar': f2N1['Abar']}, f2N1['h'])\n\n    PR_2N2 = fields_apply_P(fields_apply_R({'phi': f2N2['phi'], 'K': f2N2['K'], 'Gamma': f2N2['Gamma'], 'gbar': f2N2['gbar'], 'Abar': f2N2['Abar']}))\n    ePR_N2 = aggregate_error_L2(PR_2N2, {'phi': f2N2['phi'], 'K': f2N2['K'], 'Gamma': f2N2['Gamma'], 'gbar': f2N2['gbar'], 'Abar': f2N2['Abar']}, f2N2['h'])\n    pPR = observed_order(ePR_N1, ePR_N2)\n\n    return pR, pP, pRP, pPR\n\ndef main():\n    results = []\n    for family in ['low', 'high']:\n        pR, pP, pRP, pPR = compute_orders_for_family(family)\n        results.extend([pR, pP, pRP, pPR])\n    # Print in required single-line format\n    # Format floats with reasonable precision\n    formatted = \",\".join(f\"{v:.6f}\" for v in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3477731"}]}