{"hands_on_practices": [{"introduction": "A cornerstone of hyperelasticity is the direct relationship between a scalar strain-energy potential and the resulting stress tensors. This exercise provides fundamental practice in deriving these relationships and computationally verifying their equivalence. By working through the derivations for different work-conjugate pairs and implementing them in code, you will gain a concrete understanding of how energy principles are translated into the constitutive laws that form the bedrock of computational solid mechanics simulations [@problem_id:3561581].", "problem": "Consider a three-dimensional, homogeneous, isotropic, hyperelastic solid with strain-energy density per unit reference volume given by the compressible Neo-Hookean model\n$$\n\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(\\operatorname{tr}(\\mathbf{C}) - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2} (\\ln J)^2,\n$$\nwhere $\\mathbf{F}$ is the deformation gradient, $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ is the right Cauchy-Green deformation tensor, $J = \\det(\\mathbf{F}) > 0$ is the Jacobian determinant, and $\\mu > 0$ and $\\kappa > 0$ are material constants (shear modulus and bulk modulus, respectively). Let $U$ denote the total internal energy stored in a reference body $\\mathcal{B}_0$ of volume $V_0$, so that $U = \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0$.\n\nStarting only from the fundamental statements of energy principles for conservative systems and core definitions (hyperelasticity, work-conjugacy, frame-indifference, and change of variables between configurations), perform the following:\n\n1. Derive, from first principles, the expressions for the first Piola-Kirchhoff stress $\\mathbf{P}$, the second Piola-Kirchhoff stress $\\mathbf{S}$, and the Cauchy stress $\\boldsymbol{\\sigma}$ in terms of the prescribed strain-energy density $\\Psi(\\mathbf{F})$. Then, use these to prove the equivalence of the following energetic conjugate pairs for the first variation of internal energy $\\delta U$:\n   - The pair $(\\mathbf{F}, \\mathbf{P})$ satisfies\n     $$\n     \\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0,\n     $$\n     where $:$ is the double-dot product and $\\delta \\mathbf{F}$ is an admissible virtual variation of $\\mathbf{F}$.\n   - The pair $(\\mathbf{C}, \\mathbf{S})$ satisfies\n     $$\n     \\delta U = \\frac{1}{2} \\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0,\n     $$\n     with $\\delta \\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\delta \\mathbf{F} + \\delta \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$.\n   - Under the small-strain assumption (linearized kinematics), the pair $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ satisfies\n     $$\n     \\delta U \\approx \\int_{\\mathcal{B}} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}v,\n     $$\n     where $\\boldsymbol{\\varepsilon} \\approx \\frac{1}{2}\\left(\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\right) - \\mathbf{I}$ is the symmetric small-strain tensor, $\\delta \\boldsymbol{\\varepsilon} \\approx \\frac{1}{2}\\left(\\delta \\mathbf{F} + \\delta \\mathbf{F}^{\\mathsf{T}}\\right)$ is its virtual variation, and $\\mathrm{d}v$ is the current volume measure. Use the change of variables between configurations to state precisely when $\\mathrm{d}v \\approx \\mathrm{d}V_0$ is justified and interpret this approximation in the context of the equivalence of energetic conjugate pairs.\n\n2. Implement a program that, for specified material parameters and kinematic data $(\\mathbf{F}, \\delta \\mathbf{F})$, computes $\\delta U$ using all three conjugate pairs, under the same deformation and virtual variation, and reports the three values for each test case:\n   - Using $(\\mathbf{F}, \\mathbf{P})$: compute $\\delta U_{\\mathbf{P}} = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0$.\n   - Using $(\\mathbf{C}, \\mathbf{S})$: compute $\\delta U_{\\mathbf{S}} = \\frac{1}{2}\\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0$.\n   - Using $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ under small-strain linear elasticity: compute $\\delta U_{\\boldsymbol{\\sigma}} = \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}V_0$, where $\\boldsymbol{\\sigma}_{\\text{lin}} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$ and $\\lambda = \\kappa - \\tfrac{2}{3}\\mu$ is the Lamé parameter. For consistency with the small-strain assumption, take $\\mathrm{d}v \\approx \\mathrm{d}V_0$.\n\nUse the following test suite. In each case, interpret all matrix components as dimensionless, $\\mu$ and $\\kappa$ in Pascals, $V_0$ in $\\mathrm{m}^3$, and report $\\delta U$ in Joules. Angles must be in radians.\n\n- Test Case 1 (general small-strain, happy path):\n  - $V_0 = 1.0$,\n  - $\\mu = 8.0\\times 10^{4}$,\n  - $\\kappa = 1.6\\times 10^{5}$,\n  - $\\mathbf{F} = \\mathbf{I} + \\begin{bmatrix}\n  1.0\\times 10^{-3} & 2.0\\times 10^{-4} & 0 \\\\\n  0 & -5.0\\times 10^{-4} & 3.0\\times 10^{-4} \\\\\n  0 & 0 & 4.0\\times 10^{-4}\n  \\end{bmatrix}$,\n  - $\\delta \\mathbf{F} = \\begin{bmatrix}\n  1.0\\times 10^{-4} & 2.0\\times 10^{-5} & 0 \\\\\n  -2.0\\times 10^{-5} & -1.0\\times 10^{-5} & 1.0\\times 10^{-5} \\\\\n  0 & -1.0\\times 10^{-5} & 3.0\\times 10^{-5}\n  \\end{bmatrix}$.\n\n- Test Case 2 (pure rotation boundary; frame indifference):\n  - $V_0 = 0.8$,\n  - $\\mu = 1.2\\times 10^{5}$,\n  - $\\kappa = 2.4\\times 10^{5}$,\n  - Let $\\theta = 1.0\\times 10^{-3}$ be a rotation about the $z$-axis (radians). Define the rotation\n    $$\n    \\mathbf{R} = \\begin{bmatrix}\n    \\cos\\theta & -\\sin\\theta & 0 \\\\\n    \\sin\\theta & \\cos\\theta & 0 \\\\\n    0 & 0 & 1\n    \\end{bmatrix}, \\quad \\mathbf{F} = \\mathbf{R}.\n    $$\n    Let $\\delta \\theta = 5.0\\times 10^{-4}$ and define the skew-symmetric generator\n    $$\n    \\mathbf{W} = \\begin{bmatrix}\n    0 & -\\delta \\theta & 0 \\\\\n    \\delta \\theta & 0 & 0 \\\\\n    0 & 0 & 0\n    \\end{bmatrix}, \\quad \\delta \\mathbf{F} = \\mathbf{R}\\mathbf{W}.\n    $$\n\n- Test Case 3 (nearly incompressible edge case):\n  - $V_0 = 1.0$,\n  - $\\mu = 8.0\\times 10^{4}$,\n  - $\\kappa = 8.0\\times 10^{7}$,\n  - $\\mathbf{F} = \\operatorname{diag}(1.002, 1.002, 0.996)$,\n  - $\\delta \\mathbf{F} = 1.0\\times 10^{-4}\\,\\mathbf{I}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry should be a three-element list of floats corresponding to $[\\delta U_{\\mathbf{P}}, \\delta U_{\\mathbf{S}}, \\delta U_{\\boldsymbol{\\sigma}}]$ for the test cases in the order listed above. For example, the output must look like\n$$\n[[\\delta U_{\\mathbf{P}}^{(1)},\\delta U_{\\mathbf{S}}^{(1)},\\delta U_{\\boldsymbol{\\sigma}}^{(1)}],[\\delta U_{\\mathbf{P}}^{(2)},\\delta U_{\\mathbf{S}}^{(2)},\\delta U_{\\boldsymbol{\\sigma}}^{(2)}],[\\delta U_{\\mathbf{P}}^{(3)},\\delta U_{\\mathbf{S}}^{(3)},\\delta U_{\\boldsymbol{\\sigma}}^{(3)}]].\n$$\nAll numerical answers must be in Joules and printed as standard Python floats without units in the output line. No external input is permitted; the program must be self-contained and must run as-is.", "solution": "The problem is valid and will be solved by first deriving the required theoretical relations from first principles and then implementing them numerically for the given test cases. The analysis assumes a homogeneous deformation, allowing the integrals over the reference body $\\mathcal{B}_0$ to be replaced by a product of the integrand (evaluated at the constant deformation gradient $\\mathbf{F}$) and the reference volume $V_0$.\n\n### Part 1: Derivations and Theoretical Analysis\n\n#### Derivation of Stress Tensors\n\nThe foundation of hyperelasticity is that the state of stress can be derived from a scalar potential, the strain-energy density function $\\Psi$. For a conservative system, the first variation of the total internal energy, $\\delta U$, equals the virtual work performed by internal forces.\n\n**1. First Piola-Kirchhoff Stress ($\\mathbf{P}$)**\n\nThe first Piola-Kirchhoff stress tensor $\\mathbf{P}$ is defined as the stress measure energetically conjugate to the deformation gradient $\\mathbf{F}$. This is expressed through the virtual work principle in the reference configuration:\n$$\n\\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0\n$$\nwhere $\\delta\\mathbf{F}$ is a virtual variation of $\\mathbf{F}$. The total internal energy $U$ is the integral of the strain-energy density $\\Psi$ over the reference volume $V_0$:\n$$\nU = \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0\n$$\nThe variation $\\delta U$ is therefore:\n$$\n\\delta U = \\delta \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0 = \\int_{\\mathcal{B}_0} \\delta \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0 = \\int_{\\mathcal{B}_0} \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0\n$$\nComparing the two expressions for $\\delta U$, we identify the constitutive relation for $\\mathbf{P}$:\n$$\n\\mathbf{P} = \\frac{\\partial \\Psi}{\\partial \\mathbf{F}}\n$$\nTo compute this for the given compressible Neo-Hookean model, $\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}(\\operatorname{tr}(\\mathbf{C}) - 3) - \\mu \\ln J + \\frac{\\kappa}{2} (\\ln J)^2$, we need the following tensor derivatives:\n-   $\\frac{\\partial \\operatorname{tr}(\\mathbf{C})}{\\partial \\mathbf{F}} = \\frac{\\partial \\operatorname{tr}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})}{\\partial \\mathbf{F}} = 2\\mathbf{F}$\n-   $\\frac{\\partial J}{\\partial \\mathbf{F}} = J \\mathbf{F}^{-\\mathsf{T}}$ (Jacobi's formula), which implies $\\frac{\\partial (\\ln J)}{\\partial \\mathbf{F}} = \\frac{1}{J} \\frac{\\partial J}{\\partial \\mathbf{F}} = \\mathbf{F}^{-\\mathsf{T}}$\n-   $\\frac{\\partial (\\ln J)^2}{\\partial \\mathbf{F}} = 2(\\ln J) \\frac{\\partial (\\ln J)}{\\partial \\mathbf{F}} = 2(\\ln J) \\mathbf{F}^{-\\mathsf{T}}$\n\nSubstituting these into the derivative of $\\Psi$:\n$$\n\\mathbf{P} = \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} = \\frac{\\mu}{2}(2\\mathbf{F}) - \\mu(\\mathbf{F}^{-\\mathsf{T}}) + \\frac{\\kappa}{2}(2(\\ln J)\\mathbf{F}^{-\\mathsf{T}})\n$$\n$$\n\\mathbf{P} = \\mu \\mathbf{F} + (\\kappa \\ln J - \\mu) \\mathbf{F}^{-\\mathsf{T}}\n$$\n\n**2. Second Piola-Kirchhoff Stress ($\\mathbf{S}$)**\n\nThe second Piola-Kirchhoff stress tensor $\\mathbf{S}$ is energetically conjugate to the Green-Lagrange strain tensor $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$. Its virtual work contribution is expressed in terms of the variation of the right Cauchy-Green tensor $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$:\n$$\n\\delta U = \\frac{1}{2}\\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0\n$$\nWe can express $\\Psi$ as a function of $\\mathbf{C}$, noting that $J = \\det(\\mathbf{F}) = \\sqrt{\\det(\\mathbf{C})}$.\n$$\n\\hat{\\Psi}(\\mathbf{C}) = \\frac{\\mu}{2}(\\operatorname{tr}(\\mathbf{C}) - 3) - \\frac{\\mu}{2} \\ln(\\det\\mathbf{C}) + \\frac{\\kappa}{8} (\\ln(\\det\\mathbf{C}))^2\n$$\nThe variation is $\\delta \\Psi = \\frac{\\partial \\hat{\\Psi}}{\\partial \\mathbf{C}} : \\delta \\mathbf{C}$. Comparing this to the virtual work expression $\\delta\\Psi = \\frac{1}{2} \\mathbf{S} : \\delta\\mathbf{C}$, we obtain the constitutive relation:\n$$\n\\mathbf{S} = 2 \\frac{\\partial \\hat{\\Psi}}{\\partial \\mathbf{C}}\n$$\nWe compute the derivatives with respect to the symmetric tensor $\\mathbf{C}$:\n-   $\\frac{\\partial \\operatorname{tr}(\\mathbf{C})}{\\partial \\mathbf{C}} = \\mathbf{I}$\n-   $\\frac{\\partial \\ln(\\det\\mathbf{C})}{\\partial \\mathbf{C}} = \\mathbf{C}^{-1}$\n-   $\\frac{\\partial (\\ln(\\det\\mathbf{C}))^2}{\\partial \\mathbf{C}} = 2 \\ln(\\det\\mathbf{C}) \\mathbf{C}^{-1} = 4 \\ln J \\mathbf{C}^{-1}$\n\nSubstituting these results:\n$$\n\\mathbf{S} = 2 \\left( \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\mathbf{C}^{-1} + \\frac{\\kappa}{8}(4 \\ln J \\mathbf{C}^{-1}) \\right)\n$$\n$$\n\\mathbf{S} = \\mu \\mathbf{I} + (\\kappa \\ln J - \\mu) \\mathbf{C}^{-1}\n$$\n\n**3. Cauchy Stress ($\\boldsymbol{\\sigma}$)**\n\nThe Cauchy stress $\\boldsymbol{\\sigma}$, or true stress, acts on the deformed configuration. It is related to $\\mathbf{P}$ and $\\mathbf{S}$ through push-forward operations. Using the relation with $\\mathbf{S}$ ensures the symmetry of $\\boldsymbol{\\sigma}$:\n$$\n\\boldsymbol{\\sigma} = J^{-1} \\mathbf{F} \\mathbf{S} \\mathbf{F}^{\\mathsf{T}}\n$$\nSubstituting the expression for $\\mathbf{S}$:\n$$\n\\boldsymbol{\\sigma} = J^{-1} \\mathbf{F} (\\mu \\mathbf{I} + (\\kappa \\ln J - \\mu) \\mathbf{C}^{-1}) \\mathbf{F}^{\\mathsf{T}}\n$$\nUsing $\\mathbf{C}^{-1} = (\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})^{-1} = \\mathbf{F}^{-1}\\mathbf{F}^{-\\mathsf{T}}$ and defining the left Cauchy-Green tensor $\\mathbf{B} = \\mathbf{F}\\mathbf{F}^{\\mathsf{T}}$:\n$$\n\\boldsymbol{\\sigma} = J^{-1} (\\mu \\mathbf{F}\\mathbf{I}\\mathbf{F}^{\\mathsf{T}} + (\\kappa \\ln J - \\mu) \\mathbf{F}\\mathbf{C}^{-1}\\mathbf{F}^{\\mathsf{T}}) = J^{-1} (\\mu \\mathbf{B} + (\\kappa \\ln J - \\mu) \\mathbf{I})\n$$\n\n#### Equivalence of Energetic Conjugate Pairs\n\n**Equivalence of $(\\mathbf{F}, \\mathbf{P})$ and $(\\mathbf{C}, \\mathbf{S})$ pairs:**\n\nWe need to show that $\\mathbf{P} : \\delta \\mathbf{F} = \\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C}$. We start with the kinematic relationship between the variations $\\delta\\mathbf{F}$ and $\\delta\\mathbf{C}$:\n$$\n\\delta \\mathbf{C} = \\delta(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F}) = \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}\n$$\nNow consider the second expression for virtual work density:\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\frac{1}{2} \\mathbf{S} : (\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = \\frac{1}{2}(\\mathbf{S} : \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\nSince $\\mathbf{S}$ is symmetric ($\\mathbf{S} = \\mathbf{S}^{\\mathsf{T}}$), we use the identity $\\mathbf{A}:\\mathbf{B} = \\mathbf{A}^{\\mathsf{T}}:\\mathbf{B}^{\\mathsf{T}}$ on the first term:\n$$\n\\mathbf{S} : \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} = \\mathbf{S}^{\\mathsf{T}} : (\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})^{\\mathsf{T}} = \\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\nThus, the expression simplifies to:\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\frac{1}{2}(\\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F} + \\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = \\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\nUsing the tensor identity $(\\mathbf{AB}):\\mathbf{C} = \\mathbf{B}:(\\mathbf{A}^{\\mathsf{T}}\\mathbf{C})$, we can write:\n$$\n\\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = (\\mathbf{FS}) : \\delta\\mathbf{F}\n$$\nThe transformation law relating the two Piola-Kirchhoff stresses is $\\mathbf{P} = \\mathbf{FS}$. Substituting this, we arrive at:\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\mathbf{P} : \\delta \\mathbf{F}\n$$\nIntegrating both sides over the reference volume $V_0$ proves the equivalence of the two forms for $\\delta U$.\n\n**Equivalence for $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ under Small-Strain Assumption:**\n\nUnder the small-strain assumption, the displacement gradient $\\mathbf{H} = \\mathbf{F} - \\mathbf{I}$ has small components, $||\\mathbf{H}|| \\ll 1$. This leads to several approximations:\n$1$. The distinction between different stress measures vanishes, i.e., $\\mathbf{P} \\approx \\mathbf{S} \\approx \\boldsymbol{\\sigma}$.\n$2$. The virtual work density $\\mathbf{P}:\\delta\\mathbf{F}$ can be approximated. Since $\\delta\\mathbf{F} = \\delta\\mathbf{H}$ and $\\mathbf{P}\\approx\\boldsymbol{\\sigma}$ (which is symmetric), we have:\n$$\n\\mathbf{P}:\\delta\\mathbf{F} \\approx \\boldsymbol{\\sigma}:\\delta\\mathbf{H} = \\boldsymbol{\\sigma}:(\\text{sym}(\\delta\\mathbf{H}) + \\text{skew}(\\delta\\mathbf{H})) = \\boldsymbol{\\sigma}:\\text{sym}(\\delta\\mathbf{H})\n$$\nThe symmetric part of the virtual displacement gradient is precisely the virtual small-strain tensor given in the problem, $\\delta\\boldsymbol{\\varepsilon} = \\text{sym}(\\delta\\mathbf{F}) = \\frac{1}{2}(\\delta\\mathbf{F} + \\delta\\mathbf{F}^{\\mathsf{T}})$. Thus:\n$$\n\\mathbf{P}:\\delta\\mathbf{F} \\approx \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\n$$\n$3$. For small strains, the stress-strain relationship becomes linear. The problem provides the standard isotropic linear elastic relation $\\boldsymbol{\\sigma} \\approx \\boldsymbol{\\sigma}_{\\text{lin}} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon})\\mathbf{I} + 2\\mu\\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\varepsilon}$ is the small-strain tensor and $\\lambda$ is the first Lamé parameter.\n$4$. The volume change is given by $\\mathrm{d}v = J \\mathrm{d}V_0$. For small strains, $J = \\det(\\mathbf{I}+\\mathbf{H}) \\approx 1+\\operatorname{tr}(\\mathbf{H}) = 1+\\operatorname{tr}(\\boldsymbol{\\varepsilon})$. Since the strains are small, $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\ll 1$, which justifies the approximation $J \\approx 1$ and therefore $\\mathrm{d}v \\approx \\mathrm{d}V_0$. This approximation is accurate to first order in strain.\n\nCombining these points, we start with the exact expression and apply the approximations:\n$$\n\\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta\\mathbf{F}\\,\\mathrm{d}V_0 \\approx \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}V_0 \\approx \\int_{\\mathcal{B}} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}v\n$$\nThis establishes the approximate equivalence for the small-strain conjugate pair $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$. The provided problem formulation uses the consistent approximation $\\delta U_{\\boldsymbol{\\sigma}} = \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}V_0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (V0, mu, kappa, F, dF)\n    test_cases = [\n        # Test Case 1: General small-strain\n        (\n            1.0, 8.0e4, 1.6e5,\n            np.array([\n                [1.001, 2.0e-4, 0.0],\n                [0.0, 0.9995, 3.0e-4],\n                [0.0, 0.0, 1.0004]\n            ]),\n            np.array([\n                [1.0e-4, 2.0e-5, 0.0],\n                [-2.0e-5, -1.0e-5, 1.0e-5],\n                [0.0, -1.0e-5, 3.0e-5]\n            ])\n        ),\n        # Test Case 2: Pure rotation\n        (\n            0.8, 1.2e5, 2.4e5,\n            # For F and dF, we compute them from the given angles\n            (lambda theta: np.array([\n                [np.cos(theta), -np.sin(theta), 0],\n                [np.sin(theta), np.cos(theta),  0],\n                [0,             0,              1]\n            ]))(1.0e-3),\n            # dF = R @ W\n            (lambda R, dtheta: R @ np.array([\n                [0, -dtheta, 0],\n                [dtheta, 0, 0],\n                [0, 0, 0]\n            ]))((lambda theta: np.array([\n                [np.cos(theta), -np.sin(theta), 0],\n                [np.sin(theta), np.cos(theta),  0],\n                [0,             0,              1]\n            ]))(1.0e-3), 5.0e-4)\n        ),\n        # Test Case 3: Nearly incompressible\n        (\n            1.0, 8.0e4, 8.0e7,\n            np.diag([1.002, 1.002, 0.996]),\n            1.0e-4 * np.identity(3)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        V0, mu, kappa, F, dF = case\n        result_triplet = compute_energy_variations(V0, mu, kappa, F, dF)\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    # Use str(results).replace(\" \", \"\") to get the comma-separated list\n    # of lists without any whitespace.\n    print(str(results).replace(\" \", \"\"))\n\ndef compute_energy_variations(V0, mu, kappa, F, dF):\n    \"\"\"\n    Computes the first variation of internal energy dU using three\n    different work conjugate pairs for a homogeneous deformation.\n\n    Args:\n        V0 (float): Reference volume.\n        mu (float): Shear modulus.\n        kappa (float): Bulk modulus.\n        F (np.ndarray): Deformation gradient tensor (3x3).\n        dF (np.ndarray): Variation of the deformation gradient (3x3).\n\n    Returns:\n        list: A list of three floats [dU_P, dU_S, dU_sigma].\n    \"\"\"\n    I = np.identity(3)\n\n    # --- Calculation 1: Using (F, P) ---\n    J = np.linalg.det(F)\n    if J = 0:\n        # Physical deformation requires J > 0\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    \n    # P = mu*F + (kappa*ln(J) - mu) * (F^-T)\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F + (kappa * np.log(J) - mu) * F_inv_T\n    \n    # dU_P = V0 * (P : dF)\n    # The double-dot product A:B is sum(A_ij * B_ij)\n    dU_P = V0 * np.sum(P * dF)\n\n    # --- Calculation 2: Using (C, S) ---\n    # C = F^T * F\n    C = F.T @ F\n    # dC = dF^T*F + F^T*dF\n    dC = dF.T @ F + F.T @ dF\n    \n    C_inv = np.linalg.inv(C)\n    \n    # S = mu*I + (kappa*ln(J) - mu)*C^-1\n    S = mu * I + (kappa * np.log(J) - mu) * C_inv\n\n    # dU_S = V0 * 1/2 * (S : dC)\n    dU_S = V0 * 0.5 * np.sum(S * dC)\n\n    # --- Calculation 3: Using (epsilon, sigma) under small-strain ---\n    # Displacement gradient H = F - I\n    H = F - I\n    # Small-strain tensor epsilon = 1/2 * (H + H^T)\n    epsilon = 0.5 * (H + H.T)\n\n    # Variation of small-strain tensor d_epsilon\n    d_epsilon = 0.5 * (dF + dF.T)\n    \n    # Lamé's first parameter lambda\n    lame_lambda = kappa - (2.0/3.0) * mu\n\n    # Linearized Cauchy stress sigma_lin = lambda*tr(epsilon)*I + 2*mu*epsilon\n    sigma_lin = lame_lambda * np.trace(epsilon) * I + 2 * mu * epsilon\n    \n    # dU_sigma = V0 * (sigma_lin : d_epsilon)\n    dU_sigma = V0 * np.sum(sigma_lin * d_epsilon)\n\n    return [dU_P, dU_S, dU_sigma]\n\nsolve()\n```", "id": "3561581"}, {"introduction": "While energy principles are exact in continuum theory, their application in a discretized framework like the Finite Element Method (FEM) requires careful approximation, which can introduce numerical artifacts. This practice explores one of the most classic and important of these artifacts: spurious zero-energy or \"hourglass\" modes that arise from under-integrating an element's internal energy functional. By constructing a single element's stiffness matrix and analyzing its nullspace, you will see firsthand how non-physical deformations can produce zero strain energy, a crucial insight for developing robust and accurate finite element models [@problem_id:3561584].", "problem": "Consider a two-dimensional linearly elastic body discretized by a single isoparametric bilinear quadrilateral finite element with four nodes. The conservative internal energy functional of linear elasticity is given by\n$$\n\\Pi_{\\text{int}}[\\boldsymbol{u}] = \\int_{\\Omega} \\frac{1}{2} \\boldsymbol{\\varepsilon}(\\boldsymbol{u})^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\boldsymbol{u}$ is the displacement field, $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ is the small-strain tensor, and $\\mathbf{D}$ is the symmetric positive-definite constitutive matrix for linear elasticity under plane stress. The isoparametric bilinear quadrilateral element uses bilinear shape functions over the square reference domain $\\{(\\xi,\\eta)\\in[-1,1]\\times[-1,1]\\}$, and a smooth mapping to the physical element with nodal coordinates $\\{(x_i,y_i)\\}_{i=1}^4$, ordered counterclockwise.\n\nUnder reduced integration, the discrete internal energy is approximated by a single Gauss point at the element center $(\\xi,\\eta)=(0,0)$:\n$$\n\\Pi_{\\text{int}}^{\\text{red}}(\\mathbf{u}_e) = \\frac{1}{2} \\, w \\, J(0,0) \\, \\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e)^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e),\n$$\nwhere $\\mathbf{u}_e \\in \\mathbb{R}^{8}$ collects the nodal displacement degrees of freedom (two per node, $\\{u_{x,i},u_{y,i}\\}_{i=1}^4$), $w$ is the two-dimensional one-point Gauss weight over the reference square, $J(0,0)$ is the determinant of the Jacobian of the isoparametric mapping at the center, and $\\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e)$ is the small-strain vector evaluated at the center. The discrete functional defines a symmetric matrix $\\mathbf{K}_{\\text{red}}$ via\n$$\n\\Pi_{\\text{int}}^{\\text{red}}(\\mathbf{u}_e) = \\frac{1}{2} \\, \\mathbf{u}_e^{\\mathsf{T}} \\mathbf{K}_{\\text{red}} \\, \\mathbf{u}_e.\n$$\nA displacement mode is called a \"zero-energy mode\" of the discrete functional if it lies in the nullspace of $\\mathbf{K}_{\\text{red}}$. Rigid-body motions are displacement fields that produce zero strain everywhere; these are always zero-energy modes. An \"hourglass mode\" is a non-rigid-body zero-energy mode specific to the reduced-integration discretization.\n\nTask: Starting only from the fundamental definition of the internal energy functional, the small-strain kinematics, and the isoparametric mapping, derive a computational procedure that constructs $\\mathbf{K}_{\\text{red}}$ for a single bilinear quadrilateral element, and identify hourglass modes as zero-energy modes of the discrete functional that do not belong to the rigid-body motion subspace. Implement this procedure and, for each test case, return two integers:\n- the total number of zero-energy modes of $\\mathbf{K}_{\\text{red}}$ (the dimension of the nullspace), and\n- the number of hourglass modes (the dimension of the nullspace minus the dimension of the rigid-body motion subspace).\n\nAssume plane stress with Young's modulus $E$ (in Pascals) and Poisson's ratio $\\nu$ (dimensionless). Nodal coordinates are given in meters. For the one-point Gauss rule over the square reference domain, use the standard weight. In addition, implement a comparison case using full $2\\times 2$ Gauss integration to show the disappearance of hourglass modes. Use a numerically robust method (for example, a singular value decomposition) and a reasonable relative tolerance to determine the nullspace dimension.\n\nInput is hard-coded in your program via the following test suite of element geometries and material parameters:\n1. Square element, reduced integration: nodes $\\{(0,0),(1,0),(1,1),(0,1)\\}$, $E=210\\times 10^9$ Pa, $\\nu=0.30$.\n2. Skew parallelogram, reduced integration: nodes $\\{(0,0),(1.2,0.1),(1.0,1.1),(-0.2,1.0)\\}$, $E=70\\times 10^9$ Pa, $\\nu=0.25$.\n3. Distorted trapezoid, reduced integration: nodes $\\{(0,0),(1.3,0.0),(0.9,0.8),(0.1,0.6)\\}$, $E=100\\times 10^9$ Pa, $\\nu=0.30$.\n4. Slender rectangle, reduced integration: nodes $\\{(0,0),(2.0,0.0),(2.0,0.2),(0.0,0.2)\\}$, $E=50\\times 10^9$ Pa, $\\nu=0.30$.\n5. Square element, full integration ($2\\times 2$ Gauss): nodes $\\{(0,0),(1,0),(1,1),(0,1)\\}$, $E=210\\times 10^9$ Pa, $\\nu=0.30$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a two-integer list in the order described above. For example, the final output should look like\n$$\n[\\,[n_1,h_1],[n_2,h_2],[n_3,h_3],[n_4,h_4],[n_5,h_5]\\,],\n$$\nwith no spaces. All computations must be carried out in International System of Units (SI): lengths in meters and moduli in Pascals. Angles, if any, should be in radians, though no angles are required in this task.", "solution": "The present task requires the derivation and implementation of a computational procedure to determine the number of zero-energy modes and hourglass modes for a single bilinear quadrilateral finite element under different integration schemes. The analysis is founded on the principles of linear elasticity, isoparametric finite element formulation, and numerical quadrature.\n\n### 1. Theoretical Framework\n\nThe internal elastic energy functional $\\Pi_{\\text{int}}$ for a linearly elastic body undergoing small deformations is given by:\n$$\n\\Pi_{\\text{int}}[\\boldsymbol{u}] = \\int_{\\Omega} \\frac{1}{2} \\boldsymbol{\\varepsilon}(\\boldsymbol{u})^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, \\mathrm{d}\\Omega\n$$\nwhere $\\boldsymbol{u}$ is the displacement field, $\\boldsymbol{\\varepsilon}$ is the strain tensor in Voigt notation, $\\mathbf{D}$ is the material constitutive matrix, and $\\Omega$ is the domain of the body.\n\n#### 1.1. Isoparametric Finite Element Discretization\n\nFor a four-node bilinear quadrilateral element, the geometry and displacement field are interpolated from the nodal values using the same set of shape functions, $N_i(\\xi, \\eta)$, defined on a square reference master element $[-1,1] \\times [-1,1]$. The shape functions are:\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe physical coordinates $(x, y)$ are mapped from the reference coordinates $(\\xi, \\eta)$ using the nodal coordinates $\\mathbf{x}_e = [x_1, y_1, \\dots, x_4, y_4]^{\\mathsf{T}}$:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i\n$$\nSimilarly, the displacement field $\\boldsymbol{u} = [u_x, u_y]^{\\mathsf{T}}$ is interpolated from the nodal displacement vector $\\mathbf{u}_e = [u_{x,1}, u_{y,1}, \\dots, u_{x,4}, u_{y,4}]^{\\mathsf{T}} \\in \\mathbb{R}^8$:\n$$\n\\boldsymbol{u}(\\xi, \\eta) = \\mathbf{N}(\\xi, \\eta) \\mathbf{u}_e \\quad \\text{where} \\quad \\mathbf{N} = \\begin{bmatrix} N_1  0  N_2  0  N_3  0  N_4  0 \\\\ 0  N_1  0  N_2  0  N_3  0  N_4 \\end{bmatrix}\n$$\n\n#### 1.2. Strain-Displacement Relationship\n\nThe small-strain tensor, in Voigt vector form $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$, is derived from the displacement field by differentiation:\n$$\n\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\partial/\\partial x  0 \\\\ 0  \\partial/\\partial y \\\\ \\partial/\\partial y  \\partial/\\partial x \\end{bmatrix} \\boldsymbol{u}\n$$\nSubstituting the interpolated displacement field, we obtain the fundamental strain-displacement relationship $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$, where $\\mathbf{B}$ is the strain-displacement matrix. The matrix $\\mathbf{B}$ is composed of nodal blocks $\\mathbf{B}_i$:\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4] \\quad \\text{with} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\nThe derivatives of the shape functions with respect to physical coordinates $(x,y)$ are found using the chain rule and the Jacobian matrix $\\mathbf{J}$ of the isoparametric mapping:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}, \\quad \\text{where} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n\n#### 1.3. Element Stiffness Matrix\n\nSubstituting the discrete strain representation into the energy functional yields:\n$$\n\\Pi_{\\text{int}}(\\mathbf{u}_e) = \\frac{1}{2} \\mathbf{u}_e^{\\mathsf{T}} \\left( \\int_{\\Omega} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega \\right) \\mathbf{u}_e = \\frac{1}{2} \\mathbf{u}_e^{\\mathsf{T}} \\mathbf{K}_e \\mathbf{u}_e\n$$\nThe element stiffness matrix $\\mathbf{K}_e$ is thus defined by the integral. This integral is transformed to the reference domain and evaluated numerically using Gauss quadrature:\n$$\n\\mathbf{K}_e = \\int_{-1}^1 \\int_{-1}^1 \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx \\sum_{k=1}^{N_g} w_k \\, \\det(\\mathbf{J}_k) \\, \\mathbf{B}_k^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}_k\n$$\nwhere $N_g$ is the number of Gauss points, and $(\\xi_k, \\eta_k)$, $w_k$, $\\mathbf{J}_k$, and $\\mathbf{B}_k$ are the coordinates, weight, Jacobian, and strain-displacement matrix at the $k$-th Gauss point, respectively. For plane stress, the constitutive matrix is:\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{bmatrix}\n$$\n\n### 2. Analysis of Zero-Energy Modes\n\nA zero-energy mode is a non-zero nodal displacement vector $\\mathbf{v}$ that produces zero strain energy, i.e., $\\frac{1}{2}\\mathbf{v}^{\\mathsf{T}}\\mathbf{K}_e\\mathbf{v} = 0$. Since $\\mathbf{K}_e$ is symmetric positive semi-definite, this is equivalent to $\\mathbf{v}$ being in the nullspace of $\\mathbf{K}_e$, i.e., $\\mathbf{K}_e\\mathbf{v} = \\mathbf{0}$.\n\n#### 2.1. Rigid-Body Modes\nAny rigid-body motion produces zero strain throughout the element. For a 2D body, there are three such independent modes: two translations and one in-plane rotation. These three modes must always be in the nullspace of any correctly formulated stiffness matrix.\n\n#### 2.2. Hourglass Modes (Reduced Integration)\nReduced integration uses fewer Gauss points than required for exact integration of the stiffness matrix integrand. For the bilinear quadrilateral, one-point quadrature is a common reduced integration scheme. Here, $N_g=1$, the Gauss point is $(\\xi_1, \\eta_1) = (0,0)$, and the weight is $w_1 = 4$. The stiffness matrix is:\n$$\n\\mathbf{K}_{\\text{red}} = w_1 \\, \\det(\\mathbf{J}(0,0)) \\, \\mathbf{B}(0,0)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(0,0)\n$$\nA zero-energy mode $\\mathbf{v}$ for $\\mathbf{K}_{\\text{red}}$ is one for which the strain at the element center is zero: $\\boldsymbol{\\varepsilon}_c = \\mathbf{B}(0,0) \\mathbf{v} = \\mathbf{0}$. The bilinear shape function basis contains the term $\\xi\\eta$. A displacement field proportional to this term, such as $u_x(\\xi, \\eta) = c \\, \\xi\\eta$, has derivatives $\\partial u_x/\\partial\\xi = c\\eta$ and $\\partial u_x/\\partial\\eta = c\\xi$. Both derivatives are zero at $(\\xi, \\eta)=(0,0)$, meaning this field produces zero strain at the center. The nodal displacements corresponding to the field $\\xi\\eta$ are found by evaluating it at the four nodes: $(\\xi_i\\eta_i)_{i=1}^4 = (1, -1, 1, -1)$. This vector is the characteristic \"hourglass\" shape vector, $\\mathbf{h} = [1, -1, 1, -1]^{\\mathsf{T}}$.\n\nTwo independent displacement modes can be constructed from this shape:\n1.  An x-displacement mode: $\\mathbf{u}_{h1} = [1, 0, -1, 0, 1, 0, -1, 0]^{\\mathsf{T}}$\n2.  A y-displacement mode: $\\mathbf{u}_{h2} = [0, 1, 0, -1, 0, 1, 0, -1]^{\\mathsf{T}}$\n\nThese two modes are linearly independent of the three rigid-body modes. Therefore, the nullspace of $\\mathbf{B}(0,0)$ has a dimension of $5$. This implies that $\\mathbf{K}_{\\text{red}}$ will have a nullspace of dimension $5$. The number of zero-energy modes is $n=5$, and the number of hourglass modes is $h = n - 3 = 2$.\n\n#### 2.3. Full Integration\nFull integration for a bilinear quadrilateral uses a $2 \\times 2$ Gauss quadrature rule ($N_g=4$). The four Gauss points are $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$, each with weight $w_k = 1$. While the hourglass modes produce zero strain at the center $(\\xi, \\eta)=(0,0)$, they produce non-zero strains at the $2 \\times 2$ Gauss points. Consequently, they are no longer zero-energy modes, as their contribution to the total strain energy $\\sum_k w_k (\\dots)$ is positive. The only modes that remain in the nullspace are the three rigid-body modes, for which strain is zero everywhere. Thus, for full integration, the number of zero-energy modes is $n=3$, and the number of hourglass modes is $h = 3-3=0$.\n\n### 3. Computational Procedure\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case (element geometry, material properties, integration rule):\n    a. Construct the constitutive matrix $\\mathbf{D}$ for plane stress.\n    b. Initialize an $8 \\times 8$ element stiffness matrix $\\mathbf{K}_e$ to zeros.\n    c. Identify the set of Gauss points $(\\xi_k, \\eta_k)$ and weights $w_k$ for the specified integration rule.\n    d. For each Gauss point:\n        i.   Compute the derivatives of the shape functions, $\\partial N_i/\\partial \\xi$ and $\\partial N_i/\\partial \\eta$.\n        ii.  Compute the Jacobian matrix $\\mathbf{J}$ and its determinant $\\det(\\mathbf{J})$.\n        iii. Compute the strain-displacement matrix $\\mathbf{B}$ using $\\mathbf{J}^{-1}$ and the shape function derivatives.\n        iv.  Calculate the contribution to the stiffness matrix $\\Delta\\mathbf{K} = w_k \\det(\\mathbf{J}) \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}$ and add it to $\\mathbf{K}_e$.\n    e. Compute the Singular Value Decomposition (SVD) of the final matrix $\\mathbf{K}_e$.\n    f. Determine the dimension of the nullspace, $n$, by counting the number of singular values $\\sigma_i$ that are effectively zero relative to the largest singular value $\\sigma_{\\max}$. A singular value is considered zero if $\\sigma_i / \\sigma_{\\max}  \\epsilon$, where $\\epsilon$ is a small numerical tolerance (e.g., $10^{-12}$).\n    g. The number of hourglass modes is $h = n - 3$.\n2.  Collect the pair $[n, h]$ for each test case.\n3.  Format the final results as specified.\n\nThis procedure is implemented in the following Python program.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stiffness_matrix(nodes, E, nu, integration_rule):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node bilinear quadrilateral element.\n\n    Args:\n        nodes (np.ndarray): A 4x2 array of nodal coordinates, ordered counter-clockwise.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        integration_rule (str): Either 'reduced' (1-point) or 'full' (2x2).\n\n    Returns:\n        np.ndarray: The 8x8 element stiffness matrix.\n    \"\"\"\n    # Constitutive matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # Define Gauss quadrature points and weights\n    if integration_rule == 'reduced':\n        gauss_points = np.array([[0.0, 0.0]])\n        gauss_weights = np.array([4.0])\n    elif integration_rule == 'full':\n        a = 1.0 / np.sqrt(3.0)\n        gauss_points = np.array([\n            [-a, -a],\n            [ a, -a],\n            [ a,  a],\n            [-a,  a]\n        ])\n        gauss_weights = np.array([1.0, 1.0, 1.0, 1.0])\n    else:\n        raise ValueError(\"Invalid integration rule specified.\")\n\n    # Initialize stiffness matrix\n    K = np.zeros((8, 8))\n\n    # Loop over Gauss points for numerical integration\n    for i in range(len(gauss_weights)):\n        xi, eta = gauss_points[i]\n        weight = gauss_weights[i]\n\n        # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n        # N1 = 0.25*(1-xi)*(1-eta), N2 = 0.25*(1+xi)*(1-eta), etc.\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n\n        # Jacobian matrix J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        # J is computed as [dN/dxi, dN/deta]^T @ [x, y]\n        J_mat = np.array([\n            [np.dot(dN_dxi, nodes[:, 0]), np.dot(dN_dxi, nodes[:, 1])],\n            [np.dot(dN_deta, nodes[:, 0]), np.dot(dN_deta, nodes[:, 1])]\n        ])\n\n        detJ = np.linalg.det(J_mat)\n        if detJ = 0:\n            # Should not happen for valid element geometries ordered CCW\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        # Matrix of shape function derivatives w.r.t. physical coordinates (x, y)\n        # [dN/dx, dN/dy]^T = J_inv @ [dN/dxi, dN/deta]^T\n        # We need [dN/dx, dN/dy] = [dN/dxi, dN/deta] @ J_inv^T\n        dN_dxy = np.linalg.inv(J_mat).T @ np.vstack((dN_dxi, dN_deta))\n        dN_dx = dN_dxy[0, :]\n        dN_dy = dN_dxy[1, :]\n\n        # Strain-displacement matrix B\n        B = np.zeros((3, 8))\n        for j in range(4):\n            B[0, 2*j]     = dN_dx[j]\n            B[1, 2*j + 1] = dN_dy[j]\n            B[2, 2*j]     = dN_dy[j]\n            B[2, 2*j + 1] = dN_dx[j]\n\n        # Accumulate stiffness matrix\n        K += B.T @ D @ B * detJ * weight\n\n    return K\n\ndef get_nullspace_dims(K, tol=1e-12):\n    \"\"\"\n    Calculates the dimensions of the nullspace and hourglass mode space.\n    \"\"\"\n    # Use Singular Value Decomposition to find the rank\n    s = np.linalg.svd(K, compute_uv=False)\n    \n    # The number of zero-energy modes is the number of singular values\n    # that are numerically zero relative to the largest one.\n    s_max = s[0] if len(s) > 0 else 0\n    if s_max == 0: # This is a zero matrix\n        num_zero_modes = K.shape[0]\n    else:\n        num_zero_modes = np.sum(s  tol * s_max)\n\n    # Number of rigid body modes in 2D is 3\n    num_rigid_body_modes = 3\n    \n    # Hourglass modes are non-rigid-body zero-energy modes\n    num_hourglass_modes = num_zero_modes - num_rigid_body_modes\n    \n    return [num_zero_modes, num_hourglass_modes]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Square, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n         'E': 210e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 2: Skew parallelogram, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [-0.2, 1.0]]),\n         'E': 70e9, 'nu': 0.25, 'rule': 'reduced'},\n        # Case 3: Distorted trapezoid, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.3, 0.0], [0.9, 0.8], [0.1, 0.6]]),\n         'E': 100e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 4: Slender rectangle, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 0.2], [0.0, 0.2]]),\n         'E': 50e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 5: Square, full integration\n        {'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n         'E': 210e9, 'nu': 0.30, 'rule': 'full'},\n    ]\n\n    results = []\n    for case in test_cases:\n        K = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['rule'])\n        dims = get_nullspace_dims(K)\n        results.append(dims)\n\n    # Final print statement in the exact required format.\n    # e.g., [[5,2],[5,2],[5,2],[5,2],[3,0]]\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3561584"}, {"introduction": "Beyond defining constitutive laws, energy principles serve as a powerful tool for the verification of complex numerical simulations. For any conservative system, the total stored internal energy at the end of a quasi-static process must precisely equal the total work done by external forces. This hands-on practice guides you through the implementation of a numerical diagnostic that checks this global energy balance, a technique used to validate the correctness and consistency of nonlinear finite element codes and detect subtle bugs that might otherwise go unnoticed [@problem_id:3561571].", "problem": "You are asked to formalize, implement, and test a discrete energy diagnostic for a nonlinear hyperelastic Finite Element Method (FEM) system under conservative loading. The goal is to define a discrete total energy functional for a hyperelastic body and design a quantitative diagnostic that flags nonphysical energy gain, serving as a mesh-objective indicator of numerical issues. The problem is set in the context of a two-dimensional plane-strain body with a prescribed, load-parameterized kinematically admissible displacement field.\n\nStart from the following context-appropriate fundamental base:\n- Definition of a hyperelastic material: the First Piola–Kirchhoff stress $\\mathbf{P}$ is derived from a strain energy density function $W(\\mathbf{F})$, where $\\mathbf{F}$ is the deformation gradient. For a compressible Neo-Hookean material in $d$ dimensions, $W(\\mathbf{F})$ is a function of invariants of $\\mathbf{F}$ and the Jacobian determinant $J$.\n- The principle of conservation of energy for quasi-static, conservative systems: for a process parameterized by a load parameter $\\lambda$ from $\\lambda = 0$ to $\\lambda = \\lambda_n$, the increase in stored internal energy equals the external work input accumulated along the path, provided the loading is conservative and the solution satisfies equilibrium at each step. In discretization, this becomes an integral relation that must be respected by consistent numerical approximations.\n\nGeometry and kinematics:\n- Consider a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$ with $L_x$ and $L_y$ in meters and a thickness of $1$ meter (plane strain, unit thickness).\n- Define a smooth, inhomogeneous displacement field parameterized by $\\lambda$:\n$$\\mathbf{u}(\\mathbf{X};\\lambda) = \\lambda \\mathbf{u}_0(\\mathbf{X}), \\quad \\mathbf{X}=(X,Y),$$\nwith base field components\n$$u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}, \\quad u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}.$$\n- The deformation gradient in plane strain is\n$$\\mathbf{F}(\\lambda,\\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X}),$$\nwhere $\\mathbf{I}$ is the identity tensor and $\\nabla \\mathbf{u}_0$ is the gradient of the base displacement field.\n\nHyperelastic constitutive law:\n- For compressible Neo-Hookean material in $d=2$ dimensions, the strain energy density is\n$$W(\\mathbf{F}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{F}^\\top \\mathbf{F}) - d - 2\\ln J \\right) + \\frac{\\kappa}{2} (\\ln J)^2,$$\nwith $d=2$, $J = \\det(\\mathbf{F})$, shear modulus $\\mu$ in pascals, and bulk modulus $\\kappa$ in pascals.\n- The First Piola–Kirchhoff stress is\n$$\\mathbf{P}(\\mathbf{F}) = \\mu \\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\ln J \\, \\mathbf{F}^{-\\top}.$$\n\nConservative loading:\n- Enforce equilibrium for each $\\lambda$ by defining a conservative body force per unit reference volume\n$$\\mathbf{b}(\\lambda,\\mathbf{X}) = - \\nabla \\cdot \\mathbf{P}(\\mathbf{F}(\\lambda,\\mathbf{X})),$$\nwith $\\nabla \\cdot$ applied column-wise to $\\mathbf{P}$ in the reference configuration. This choice ensures the strong form of equilibrium $\\nabla \\cdot \\mathbf{P} + \\mathbf{b} = \\mathbf{0}$ holds for the prescribed $\\mathbf{u}(\\mathbf{X};\\lambda)$, making the loading conservative and path-consistent.\n- The external work rate for the quasi-static process is\n$$\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\frac{\\partial \\mathbf{u}}{\\partial \\lambda}(\\mathbf{X};\\lambda) \\, \\mathrm{d}V = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) \\, \\mathrm{d}V.$$\n\nDiscrete total energy and numerical diagnostic:\n- Discretize $\\Omega$ with a structured rectangular mesh of $N_x \\times N_y$ elements. On each element $e$ of area $A_e$, approximate the internal energy at $\\lambda_i$ by Gaussian quadrature:\n$$E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e} \\sum_{q=1}^{n_q} W\\!\\left(\\mathbf{F}(\\lambda_i,\\mathbf{X}_{e,q})\\right) \\, w_q \\, A_e,$$\nwhere $\\mathbf{X}_{e,q}$ are the quadrature points, $w_q$ are the quadrature weights, $n_q$ is the number of points per element, and $A_e$ is in $\\mathrm{m}^2$. Express the internal energy in joules.\n- Approximate the external work accumulated along the path $\\lambda_0, \\lambda_1, \\dots, \\lambda_n$ using the trapezoidal rule on the external work rate:\n$$W_{\\mathrm{ext}}(0 \\to \\lambda_n) \\approx \\sum_{i=1}^{n} \\frac{\\dot{W}_{\\mathrm{ext}}(\\lambda_{i-1}) + \\dot{W}_{\\mathrm{ext}}(\\lambda_i)}{2} \\, (\\lambda_i - \\lambda_{i-1}).$$\n- Define the energy residual\n$$r = E_{\\mathrm{int}}(\\lambda_n) - W_{\\mathrm{ext}}(0 \\to \\lambda_n).$$\n- Diagnostic rule: flag nonphysical energy gain if $r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\, E_{\\mathrm{int}}(\\lambda_n)$, with absolute tolerance $\\tau_{\\mathrm{abs}}$ in joules and relative tolerance $\\tau_{\\mathrm{rel}}$ dimensionless. This diagnostic is mesh-objective if it detects spurious energy creation regardless of mesh parameters when the discretization is inconsistent.\n\nNumerical implementation details:\n- Compute $\\mathbf{F}$ from the gradient $\\nabla \\mathbf{u}_0$ symbolically from the given $u_0$, and evaluate $W$ and $\\mathbf{P}$ at quadrature points.\n- Compute $\\nabla \\cdot \\mathbf{P}$ numerically by central finite differences applied to the columns of $\\mathbf{P}$ with a step size proportional to the local element size, ensuring scientific realism and numerical stability.\n- For comparative testing of mesh objectivity, optionally use an intentionally inconsistent external work evaluator by defining $\\mathbf{P}_{\\mathrm{lin}}$ from a linearized small-strain model:\n$$\\boldsymbol{\\varepsilon} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right), \\quad \\lambda_{\\mathrm{Lame}} = \\kappa - \\frac{2}{3}\\mu,$$\n$$\\mathbf{P}_{\\mathrm{lin}} \\approx \\lambda_{\\mathrm{Lame}} \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon},$$\nthen set $\\mathbf{b}_{\\mathrm{lin}}(\\lambda,\\mathbf{X}) = -\\nabla \\cdot \\mathbf{P}_{\\mathrm{lin}}(\\lambda,\\mathbf{X})$. This simulates a common numerical issue where internal and external energetics are inconsistently evaluated, leading to nonphysical energy creation detectable by the diagnostic.\n\nPhysical and numerical units:\n- Use meters ($\\mathrm{m}$) for lengths, pascals ($\\mathrm{Pa}$) for moduli $\\mu$ and $\\kappa$, and joules ($\\mathrm{J}$) for energy. Angles do not appear and are not required.\n\nTest suite and required output:\n- Use the following test cases to exercise the diagnostic:\n    1. Case A (happy path, consistent energetics, fine mesh): $L_x = 1.0 \\, \\mathrm{m}$, $L_y = 1.0 \\, \\mathrm{m}$, $N_x = 40$, $N_y = 40$, $\\mu = 1.0 \\times 10^{6} \\, \\mathrm{Pa}$, $\\kappa = 5.0 \\times 10^{6} \\, \\mathrm{Pa}$, $c_1 = 0.5$, $c_2 = 0.5$, $c_3 = 0.3$, load steps $\\lambda \\in \\{0.0, 0.7, 1.0\\}$, consistent Neo-Hookean internal and external models. Tolerances: $\\tau_{\\mathrm{abs}} = 1.0 \\times 10^{-1} \\, \\mathrm{J}$, $\\tau_{\\mathrm{rel}} = 1.0 \\times 10^{-6}$.\n    2. Case B (inconsistent energetics, coarse mesh): same $L_x$, $L_y$, $\\mu$, $\\kappa$, $c_1$, $c_2$, $c_3$ and load steps as Case A, but $N_x = 6$, $N_y = 6$, internal energy evaluated with Neo-Hookean, external work rate computed with the linearized small-strain $\\mathbf{P}_{\\mathrm{lin}}$ as above. Same tolerances. This case should flag nonphysical energy gain.\n    3. Case C (boundary case, zero path): same geometry and material, $N_x = 8$, $N_y = 8$, load steps $\\lambda \\in \\{0.0, 0.0\\}$, consistent Neo-Hookean internal and external models. Same tolerances. This case should not flag nonphysical energy gain.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3]$), where $result_i$ is a boolean for each case indicating whether nonphysical energy gain was flagged ($\\mathrm{True}$) or not ($\\mathrm{False}$).\n\nDesign for coverage:\n- Case A tests the general correct behavior under consistent discretization.\n- Case B tests the diagnostic’s ability to detect spurious energy creation when internal and external work are evaluated inconsistently, a realistic numerical issue.\n- Case C tests a boundary condition where no energy is exchanged along the path.\n\nAnswer format:\n- The final program must be fully self-contained, not require any input, and must print exactly one line in the format described above. Ensure the booleans are computed from the implemented diagnostic based on the numerical approximations and parameters given in the test suite.", "solution": "The user has provided a problem in computational solid mechanics concerning the development of an energy-based diagnostic for numerical simulations of hyperelastic materials. The problem is to be validated for self-consistency, scientific soundness, and well-posedness before a solution is attempted.\n\n### Step 1: Extract Givens\n\n- **Domain**: A rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$ with unit thickness ($1 \\, \\mathrm{m}$).\n- **Kinematics**:\n    - Prescribed displacement field: $\\mathbf{u}(\\mathbf{X};\\lambda) = \\lambda \\mathbf{u}_0(\\mathbf{X})$, where $\\mathbf{X}=(X,Y)$.\n    - Base displacement components: $u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}$ and $u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}$.\n    - Deformation gradient (plane strain): $\\mathbf{F}(\\lambda,\\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X})$.\n- **Constitutive Law (compressible Neo-Hookean, $d=2$)**:\n    - Strain energy density: $W(\\mathbf{F}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{F}^\\top \\mathbf{F}) - d - 2\\ln J \\right) + \\frac{\\kappa}{2} (\\ln J)^2$, with $d=2$, $J = \\det(\\mathbf{F})$.\n    - First Piola-Kirchhoff stress: $\\mathbf{P}(\\mathbf{F}) = \\mu \\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\ln J \\, \\mathbf{F}^{-\\top}$.\n- **Loading**:\n    - Conservative body force: $\\mathbf{b}(\\lambda,\\mathbf{X}) = - \\nabla \\cdot \\mathbf{P}(\\mathbf{F}(\\lambda,\\mathbf{X}))$.\n    - External work rate: $\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) \\, \\mathrm{d}V$.\n- **Inconsistent Model (for testing)**:\n    - Linearized strain: $\\boldsymbol{\\varepsilon} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right)$.\n    - Lamé parameter: $\\lambda_{\\mathrm{Lame}} = \\kappa - \\frac{2}{3}\\mu$.\n    - Linearized stress: $\\mathbf{P}_{\\mathrm{lin}} \\approx \\lambda_{\\mathrm{Lame}} \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$.\n    - Inconsistent body force: $\\mathbf{b}_{\\mathrm{lin}}(\\lambda,\\mathbf{X}) = -\\nabla \\cdot \\mathbf{P}_{\\mathrm{lin}}(\\lambda,\\mathbf{X})$.\n- **Discretization and Numerical Methods**:\n    - Mesh: Structured rectangular mesh of $N_x \\times N_y$ elements.\n    - Internal energy integration: Gaussian quadrature, $E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e} \\sum_{q=1}^{n_q} W(\\mathbf{F}(\\lambda_i,\\mathbf{X}_{e,q})) \\, w_q \\, A_e$.\n    - External work integration: Trapezoidal rule, $W_{\\mathrm{ext}}(0 \\to \\lambda_n) \\approx \\sum_{i=1}^{n} \\frac{\\dot{W}_{\\mathrm{ext}}(\\lambda_{i-1}) + \\dot{W}_{\\mathrm{ext}}(\\lambda_i)}{2} (\\lambda_i - \\lambda_{i-1})$.\n    - Body force computation: Central finite differences for $\\nabla \\cdot \\mathbf{P}$ with step size proportional to element size.\n- **Diagnostic**:\n    - Energy residual: $r = E_{\\mathrm{int}}(\\lambda_n) - W_{\\mathrm{ext}}(0 \\to \\lambda_n)$.\n    - Flagging condition: $r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\, E_{\\mathrm{int}}(\\lambda_n)$.\n- **Test Cases**:\n    - Case A: Consistent model, fine mesh ($N_x=40, N_y=40$), $\\lambda \\in \\{0.0, 0.7, 1.0\\}$, $\\tau_{\\mathrm{abs}}=0.1 \\, \\mathrm{J}$, $\\tau_{\\mathrm{rel}}=10^{-6}$.\n    - Case B: Inconsistent model, coarse mesh ($N_x=6, N_y=6$), same parameters otherwise.\n    - Case C: Consistent model, zero path ($\\lambda \\in \\{0.0, 0.0\\}$), $N_x=8, N_y=8$.\n    - Common parameters: $L_x=1.0 \\, \\mathrm{m}$, $L_y=1.0 \\, \\mathrm{m}$, $\\mu=10^6 \\, \\mathrm{Pa}$, $\\kappa=5 \\times 10^6 \\, \\mathrm{Pa}$, $c_1=0.5$, $c_2=0.5$, $c_3=0.3$.\n- **Output**: Single line, comma-separated list of booleans: `[result_A, result_B, result_C]`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to rigorous validation.\n1.  **Scientific or Factual Unsoundness**: The problem is grounded in the established principles of continuum mechanics, hyperelasticity, and the Finite Element Method (FEM). The use of a prescribed displacement field and a corresponding equilibrium body force is a standard technique for creating verification test cases (Method of Manufactured Solutions). The Neo-Hookean model is a classical hyperelastic law. All principles are sound.\n2.  **Non-Formalizable or Irrelevant**: The problem is highly formal and directly relevant to the specified topic of energy principles in computational solid mechanics. It requires the formalization and implementation of specific mathematical and numerical constructs.\n3.  **Incomplete or Contradictory Setup**: The problem statement is exceptionally detailed, providing all necessary kinematic definitions, constitutive laws, material parameters, discretization schemes, and test case specifications. There are no apparent contradictions. The provision of a specific, albeit physically inconsistent for $2\\text{D}$, formula for $\\lambda_{\\mathrm{Lame}}$ is part of the specification for an intentionally \"wrong\" model for testing purposes, not a flaw in the problem itself.\n4.  **Unrealistic or Infeasible**: The physical parameters are within a reasonable range for soft materials. The numerical tasks (quadrature, finite differences) are standard and computationally feasible.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. It defines a deterministic algorithm whose inputs are fully specified, leading to a unique, computable result for each test case. The diagnostic rule is unambiguous.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem requires a non-trivial implementation involving symbolic differentiation, numerical integration, and numerical differentiation, all integrated into a cohesive diagnostic tool. It is a substantive computational task.\n7.  **Outside Scientific Verifiability**: The results are computationally verifiable by implementing the described algorithm.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined, scientifically sound, and comprehensive problem in computational mechanics. I will proceed with generating a solution.\n\n### Solution Design\n\nThe solution will be implemented in Python using the `NumPy` library. The logic follows the steps laid out in the problem statement to construct and evaluate the energy diagnostic for each test case.\n\n**1. Analytical Preliminaries**\nThe base displacement field is given by $\\mathbf{u}_0(\\mathbf{X}) = (u_{0x}, u_{0y})^\\top$ with:\n$$u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}$$\n$$u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}$$\nThe gradient of this field, $\\nabla \\mathbf{u}_0$, is computed analytically. Its components are $(\\nabla \\mathbf{u}_0)_{ij} = \\partial u_{0i} / \\partial X_j$:\n$$\n\\nabla \\mathbf{u}_0(\\mathbf{X}) =\n\\begin{pmatrix}\n\\frac{\\partial u_{0x}}{\\partial X}  \\frac{\\partial u_{0x}}{\\partial Y} \\\\\n\\frac{\\partial u_{0y}}{\\partial X}  \\frac{\\partial u_{0y}}{\\partial Y}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2c_1 X / L_x^2  2c_2 Y / L_y^2 \\\\\nc_3 Y / (L_x L_y)  c_3 X / (L_x L_y)\n\\end{pmatrix}\n$$\nThe deformation gradient for a given load parameter $\\lambda$ and position $\\mathbf{X}$ is then $\\mathbf{F}(\\lambda, \\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X})$.\n\n**2. Numerical Integration Scheme**\nBoth internal energy $E_{\\mathrm{int}}$ and external work rate $\\dot{W}_{\\mathrm{ext}}$ are volume integrals over the domain $\\Omega$. We discretize $\\Omega$ into an $N_x \\times N_y$ grid of rectangular elements, each of area $A_e = (L_x/N_x) \\times (L_y/N_y)$. Within each element, the integrals are approximated using a standard $2 \\times 2$ Gaussian quadrature. This involves evaluating the integrand at $n_q=4$ specific points within each element and summing them up with appropriate weights. The integral of a function $f(\\mathbf{X})$ over an element $e$ is thus approximated as:\n$$ \\int_e f(\\mathbf{X}) \\mathrm{d}A \\approx \\sum_{q=1}^{4} f(\\mathbf{X}_{e,q}) \\frac{A_e}{4} $$\nThe total integral over $\\Omega$ is the sum of these contributions from all elements.\n\n**3. Internal Energy Calculation**\nThe internal energy at a given load level $\\lambda_i$ is $E_{\\mathrm{int}}(\\lambda_i) = \\int_{\\Omega} W(\\mathbf{F}(\\lambda_i, \\mathbf{X})) \\mathrm{d}V$. Using the numerical integration scheme:\n$$ E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e=1}^{N_x N_y} \\sum_{q=1}^{4} W(\\mathbf{F}(\\lambda_i, \\mathbf{X}_{e,q})) \\frac{A_e}{4} $$\nThe function $W(\\mathbf{F})$ is the specified compressible Neo-Hookean strain energy density.\n\n**4. External Work Calculation**\nThe external work rate is $\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda, \\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) \\mathrm{d}V$. This integral is also evaluated using the $2 \\times 2$ Gaussian quadrature. The body force $\\mathbf{b}$ is itself computed numerically at each quadrature point $\\mathbf{X}_{e,q}$ using central finite differences for the divergence of the stress tensor $\\mathbf{P}$:\n$$ (\\nabla \\cdot \\mathbf{P})_i = \\sum_j \\frac{\\partial P_{ij}}{\\partial X_j} \\approx \\sum_j \\frac{P_{ij}(\\mathbf{X} + \\frac{h_j}{2}\\mathbf{e}_j) - P_{ij}(\\mathbf{X} - \\frac{h_j}{2}\\mathbf{e}_j)}{h_j} $$\nwhere $h_1 = L_x/N_x$ and $h_2 = L_y/N_y$ are the element dimensions. For a given test case, the stress $\\mathbf{P}$ is computed either from the consistent Neo-Hookean law or the inconsistent linearized law. The total external work, $W_{\\mathrm{ext}}(0 \\to \\lambda_n)$, is then computed by integrating the work rate $\\dot{W}_{\\mathrm{ext}}(\\lambda)$ along the load path $\\{\\lambda_0, \\lambda_1, \\dots, \\lambda_n\\}$ using the trapezoidal rule.\n\n**5. Diagnostic Evaluation**\nFor each test case, the final internal energy $E_{\\mathrm{int}}(\\lambda_n)$ and total external work $W_{\\mathrm{ext}}(0 \\to \\lambda_n)$ are computed. The energy residual $r$ is calculated, and the diagnostic condition $r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} |E_{\\mathrm{int}}(\\lambda_n)|$ is checked. The absolute value of $E_{\\mathrm{int}}$ is used in the relative tolerance term for robustness, although for the given displacement field, the energy is non-negative.\n\n- **Case A** uses consistent energetics. The residual $r$ should be small, arising only from numerical discretization errors (quadrature for integrals, finite differences for divergence, trapezoidal rule for path integration). With a fine mesh, this error should fall below the specified tolerances. The expected result is `False`.\n- **Case B** uses an inconsistent formulation: $E_{\\mathrm{int}}$ is from the nonlinear Neo-Hookean model, while $W_{\\mathrm{ext}}$ is derived from a linearized stress model. This fundamental mismatch is expected to create a significant, non-physical energy residual that is independent of mesh refinement and should be flagged by the diagnostic. The expected result is `True`.\n- **Case C** involves a zero-length load path ($\\lambda_0=\\lambda_n=0$). At $\\lambda=0$, $\\mathbf{F}=\\mathbf{I}$, $J=1$, and the strain energy density $W$ is zero. Thus, $E_{\\mathrm{int}}(0)=0$. The path integral for $W_{\\mathrm{ext}}$ over a zero-length interval is also zero. The residual $r$ will be exactly $0$, which is less than the positive absolute tolerance $\\tau_{\\mathrm{abs}}$. The expected result is `False`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass EnergyDiagnosticSolver:\n    \"\"\"\n    A solver to formalize and test a discrete energy diagnostic for a\n    nonlinear hyperelastic system under conservative loading.\n    \"\"\"\n    def __init__(self, case_params):\n        \"\"\"Initializes the solver with parameters for a specific test case.\"\"\"\n        self.Lx = case_params[\"Lx\"]\n        self.Ly = case_params[\"Ly\"]\n        self.Nx = case_params[\"Nx\"]\n        self.Ny = case_params[\"Ny\"]\n        self.mu = case_params[\"mu\"]\n        self.kappa = case_params[\"kappa\"]\n        self.c1 = case_params[\"c1\"]\n        self.c2 = case_params[\"c2\"]\n        self.c3 = case_params[\"c3\"]\n        self.lambdas = case_params[\"lambdas\"]\n        self.model_type = case_params[\"model_type\"]\n        self.tau_abs = case_params[\"tau_abs\"]\n        self.tau_rel = case_params[\"tau_rel\"]\n        \n        self.dx = self.Lx / self.Nx\n        self.dy = self.Ly / self.Ny\n        self.Ae = self.dx * self.dy\n        \n        # Quadrature parameters for a 2x2 Gauss rule on a reference [-1,1]^2 element\n        self.quad_points_ref = np.array([\n            [-1/np.sqrt(3), -1/np.sqrt(3)], [ 1/np.sqrt(3), -1/np.sqrt(3)],\n            [-1/np.sqrt(3),  1/np.sqrt(3)], [ 1/np.sqrt(3),  1/np.sqrt(3)]\n        ])\n        self.quad_weights_ref = np.array([1.0, 1.0, 1.0, 1.0])\n        self.n_quad = len(self.quad_weights_ref)\n        \n        self.d = 2 # Problem is in 2D plane strain\n\n    def u0_fn(self, X, Y):\n        \"\"\"Computes the base displacement field u0 at (X, Y).\"\"\"\n        u0x = self.c1 * X**2 / self.Lx**2 + self.c2 * Y**2 / self.Ly**2\n        u0y = self.c3 * X * Y / (self.Lx * self.Ly)\n        return np.array([u0x, u0y])\n\n    def grad_u0_fn(self, X, Y):\n        \"\"\"Computes the gradient of the base displacement field at (X, Y).\"\"\"\n        du0x_dX = 2 * self.c1 * X / self.Lx**2\n        du0x_dY = 2 * self.c2 * Y / self.Ly**2\n        du0y_dX = self.c3 * Y / (self.Lx * self.Ly)\n        du0y_dY = self.c3 * X / (self.Lx * self.Ly)\n        return np.array([[du0x_dX, du0x_dY], [du0y_dX, du0y_dY]])\n\n    def F_fn(self, X, Y, lam):\n        \"\"\"Computes the deformation gradient F at (X, Y) for a given lambda.\"\"\"\n        return np.identity(self.d) + lam * self.grad_u0_fn(X, Y)\n\n    def W_neo_hookean_fn(self, F):\n        \"\"\"Computes the Neo-Hookean strain energy density.\"\"\"\n        J = np.linalg.det(F)\n        if J = 0: return np.inf\n        I1 = np.trace(F.T @ F)\n        W = self.mu / 2 * (I1 - self.d - 2 * np.log(J)) + self.kappa / 2 * (np.log(J))**2\n        return W\n\n    def P_neo_hookean_fn(self, F):\n        \"\"\"Computes the First Piola-Kirchhoff stress for the Neo-Hookean model.\"\"\"\n        J = np.linalg.det(F)\n        if J = 0: return np.full((self.d, self.d), np.nan)\n        F_inv_T = np.linalg.inv(F).T\n        P = self.mu * (F - F_inv_T) + self.kappa * np.log(J) * F_inv_T\n        return P\n\n    def P_linearized_fn(self, X, Y, lam):\n        \"\"\"Computes the inconsistent linearized First Piola-Kirchhoff stress.\"\"\"\n        grad_u = lam * self.grad_u0_fn(X, Y)\n        epsilon = 0.5 * (grad_u + grad_u.T)\n        lame_lambda = self.kappa - (2/3) * self.mu  # As specified in the problem\n        tr_epsilon = np.trace(epsilon)\n        P_lin = lame_lambda * tr_epsilon * np.identity(self.d) + 2 * self.mu * epsilon\n        return P_lin\n\n    def b_fn(self, X, Y, lam):\n        \"\"\"Computes body force b by numerical differentiation of the stress P.\"\"\"\n        hx, hy = self.dx, self.dy\n        \n        stress_fn = (self.P_neo_hookean_fn if self.model_type == 'consistent'\n                     else self.P_linearized_fn)\n\n        if self.model_type == 'consistent':\n            P_xp = stress_fn(self.F_fn(X + hx/2, Y, lam))\n            P_xm = stress_fn(self.F_fn(X - hx/2, Y, lam))\n            P_yp = stress_fn(self.F_fn(X, Y + hy/2, lam))\n            P_ym = stress_fn(self.F_fn(X, Y - hy/2, lam))\n        else:\n            P_xp = stress_fn(X + hx/2, Y, lam)\n            P_xm = stress_fn(X - hx/2, Y, lam)\n            P_yp = stress_fn(X, Y + hy/2, lam)\n            P_ym = stress_fn(X, Y - hy/2, lam)\n\n        if np.any(np.isnan(P_xp)) or np.any(np.isnan(P_xm)) or \\\n           np.any(np.isnan(P_yp)) or np.any(np.isnan(P_ym)):\n            return np.array([np.nan, np.nan])\n\n        dP_dX = (P_xp - P_xm) / hx\n        dP_dY = (P_yp - P_ym) / hy\n        \n        div_P = np.array([dP_dX[0, 0] + dP_dY[0, 1], dP_dX[1, 0] + dP_dY[1, 1]])\n        return -div_P\n\n    def _integrate_over_domain(self, integrand_fn):\n        \"\"\"Generic function to integrate a function over the domain using quadrature.\"\"\"\n        total_integral = 0.0\n        for i in range(self.Nx):\n            for j in range(self.Ny):\n                x_el_min, y_el_min = i * self.dx, j * self.dy\n                for k in range(self.n_quad):\n                    xi, eta = self.quad_points_ref[k]\n                    X_q = x_el_min + self.dx / 2 * (1 + xi)\n                    Y_q = y_el_min + self.dy / 2 * (1 + eta)\n                    \n                    value = integrand_fn(X_q, Y_q)\n                    if np.isnan(value): return np.nan\n                    \n                    # Quadrature weight in physical space is (weight_ref * Area_element / 4)\n                    w_q_phys = self.quad_weights_ref[k] * self.Ae / 4.0\n                    total_integral += value * w_q_phys\n        return total_integral\n\n    def compute_internal_energy(self, lam):\n        \"\"\"Computes the total internal energy E_int for a given lambda.\"\"\"\n        integrand = lambda X, Y: self.W_neo_hookean_fn(self.F_fn(X, Y, lam))\n        return self._integrate_over_domain(integrand)\n\n    def compute_external_work_rate(self, lam):\n        \"\"\"Computes the total external work rate dW_ext/dlambda for a given lambda.\"\"\"\n        integrand = lambda X, Y: np.dot(self.b_fn(X, Y, lam), self.u0_fn(X, Y))\n        return self._integrate_over_domain(integrand)\n\n    def run_diagnostic(self):\n        \"\"\"Executes the full energy diagnostic procedure for the case.\"\"\"\n        if len(self.lambdas)  2 or self.lambdas[0] == self.lambdas[-1]:\n            # For zero-length path, E_int and W_ext are 0. Residual is 0.\n            return 0.0 > self.tau_abs # False\n\n        lam_n = self.lambdas[-1]\n        E_int_final = self.compute_internal_energy(lam_n)\n\n        W_ext_total = 0.0\n        for i in range(1, len(self.lambdas)):\n            lam_i, lam_im1 = self.lambdas[i], self.lambdas[i-1]\n            delta_lam = lam_i - lam_im1\n\n            W_dot_i = self.compute_external_work_rate(lam_i)\n            W_dot_im1 = self.compute_external_work_rate(lam_im1)\n            \n            if np.isnan(W_dot_i) or np.isnan(W_dot_im1):\n                # An invalid work rate (e.g. from J=0) implies a failed path\n                return True\n\n            W_ext_total += (W_dot_i + W_dot_im1) / 2.0 * delta_lam\n        \n        residual = E_int_final - W_ext_total\n        threshold = self.tau_abs + self.tau_rel * abs(E_int_final)\n\n        return residual > threshold\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the energy diagnostic.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path, consistent, fine mesh. Expect False.\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 40, \"Ny\": 40, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.7, 1.0],\n            \"model_type\": 'consistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        },\n        # Case B: Inconsistent energetics, coarse mesh. Expect True.\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 6, \"Ny\": 6, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.7, 1.0],\n            \"model_type\": 'inconsistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        },\n        # Case C: Boundary case, zero path. Expect False.\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 8, \"Ny\": 8, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.0],\n            \"model_type\": 'consistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        solver = EnergyDiagnosticSolver(case_params)\n        flag = solver.run_diagnostic()\n        results.append(flag)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3561571"}]}