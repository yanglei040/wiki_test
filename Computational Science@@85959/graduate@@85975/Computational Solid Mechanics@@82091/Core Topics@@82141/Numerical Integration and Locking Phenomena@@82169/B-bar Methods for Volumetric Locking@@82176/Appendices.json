{"hands_on_practices": [{"introduction": "Before implementing a numerical method, it is crucial to understand its mathematical foundations. This exercise builds that core understanding by having you derive the key volumetric averaging operator from first principles [@problem_id:3545792]. By working through the analytics for a simple bilinear quadrilateral element, you will establish a concrete connection between the abstract concept of an \"element-averaged strain\" and the specific matrix operator that maps nodal displacements to this single value.", "problem": "Consider a single isoparametric bilinear quadrilateral ($Q_4$) finite element (FE) occupying the unit square domain $\\Omega = [0,1]\\times[0,1]$ in physical coordinates $(x,y)$. Let the nodal coordinates be ordered counterclockwise as node $1$ at $(0,0)$, node $2$ at $(1,0)$, node $3$ at $(1,1)$, and node $4$ at $(0,1)$. Let the displacement degrees of freedom (DOFs) be collected in the element vector\n$$\n\\mathbf{d}_e = \\begin{pmatrix} u_1 & v_1 & u_2 & v_2 & u_3 & v_3 & u_4 & v_4 \\end{pmatrix}^{\\mathsf{T}},\n$$\nwhere $u_i$ and $v_i$ are the displacement components at node $i$ along $x$ and $y$, respectively. Assume small-strain kinematics in plane strain so that the volumetric strain (dilatation) is defined by\n$$\n\\varepsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\nThe FE displacement field is approximated using the standard bilinear shape functions on the unit square,\n$$\nN_1(x,y) = (1-x)(1-y), \\quad N_2(x,y) = x(1-y), \\quad N_3(x,y) = xy, \\quad N_4(x,y) = (1-x)y,\n$$\nso that\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \\qquad v(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i.\n$$\nDefine the element-averaged volumetric strain\n$$\n\\bar{\\varepsilon}_v = \\frac{1}{A}\\int_{\\Omega} \\varepsilon_v(x,y)\\,\\mathrm{d}A,\n$$\nwith element area $A=1$. In the context of the $\\bar{B}$-method (B-bar method) for volumetric locking, the volumetric average operator $\\mathbf{P}_v$ is the unique $1\\times 8$ row matrix such that\n$$\n\\bar{\\varepsilon}_v = \\mathbf{P}_v\\,\\mathbf{d}_e.\n$$\nStarting only from the preceding definitions and the small-strain kinematics, derive $\\mathbf{P}_v$ explicitly by exact integration over $\\Omega$. Express your final operator as a $1\\times 8$ row matrix ordered as $\\left[u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4\\right]$. No numerical rounding is required, and the result must be given in exact rational form.", "solution": "We begin from the small-strain definition of volumetric strain (dilatation) in two dimensions:\n$$\n\\varepsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\nWith the finite element (FE) approximation\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \n\\qquad \nv(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i,\n$$\nwe obtain\n$$\n\\frac{\\partial u}{\\partial x} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i,\n\\qquad\n\\frac{\\partial v}{\\partial y} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i,\n$$\nso that\n$$\n\\varepsilon_v(x,y) = \\sum_{i=1}^{4} \\left(\\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i + \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i\\right).\n$$\nThe element-averaged volumetric strain over the unit square $\\Omega = [0,1]\\times[0,1]$ with area $A=1$ is\n$$\n\\bar{\\varepsilon}_v = \\int_{\\Omega} \\varepsilon_v(x,y)\\,\\mathrm{d}A \n= \\sum_{i=1}^{4} \\left( u_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A + v_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A \\right).\n$$\nHence, the volumetric average operator $\\mathbf{P}_v$ is assembled from the exact integrals\n$$\nI_{x,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A, \n\\qquad \nI_{y,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A,\n$$\nas\n$$\n\\bar{\\varepsilon}_v = \\begin{pmatrix} I_{x,1} & I_{y,1} & I_{x,2} & I_{y,2} & I_{x,3} & I_{y,3} & I_{x,4} & I_{y,4} \\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\\\ u_3 \\\\ v_3 \\\\ u_4 \\\\ v_4 \\end{pmatrix}.\n$$\nTherefore,\n$$\n\\mathbf{P}_v = \\begin{pmatrix} I_{x,1} & I_{y,1} & I_{x,2} & I_{y,2} & I_{x,3} & I_{y,3} & I_{x,4} & I_{y,4} \\end{pmatrix}.\n$$\n\nWe compute the required derivatives of the bilinear shape functions on the unit square:\n\n$$\n\\begin{aligned}\n&N_1(x,y) = (1-x)(1-y), && \\frac{\\partial N_1}{\\partial x} = -(1-y), && \\frac{\\partial N_1}{\\partial y} = -(1-x),\\\\\n&N_2(x,y) = x(1-y),      && \\frac{\\partial N_2}{\\partial x} = (1-y),  && \\frac{\\partial N_2}{\\partial y} = -x,\\\\\n&N_3(x,y) = xy,          && \\frac{\\partial N_3}{\\partial x} = y,       && \\frac{\\partial N_3}{\\partial y} = x,\\\\\n&N_4(x,y) = (1-x)y,      && \\frac{\\partial N_4}{\\partial x} = -y,      && \\frac{\\partial N_4}{\\partial y} = (1-x).\n\\end{aligned}\n$$\n\nWe perform exact integrations over $\\Omega = [0,1]\\times[0,1]$:\n\n$$\n\\begin{aligned}\nI_{x,1} &= \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-y) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\int_{0}^{1} \\mathrm{d}x \\right)\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\cdot 1 \\right)\\mathrm{d}y \n= -\\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= -\\left[ y - \\frac{y^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\[6pt]\nI_{x,2} &= \\int_{0}^{1}\\int_{0}^{1} (1-y)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\[6pt]\nI_{x,3} &= \\int_{0}^{1}\\int_{0}^{1} y\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} y \\left(\\int_{0}^{1} \\mathrm{d}x\\right)\\mathrm{d}y \n= \\int_{0}^{1} y\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\[6pt]\nI_{x,4} &= \\int_{0}^{1}\\int_{0}^{1} \\left( -y \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} y\\,\\mathrm{d}y \n= -\\frac{1}{2}.\n\\end{aligned}\n$$\n\nSimilarly for the $y$-derivatives:\n\n$$\n\\begin{aligned}\nI_{y,1} &= \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-x) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= -\\left[ x - \\frac{x^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\[6pt]\nI_{y,2} &= \\int_{0}^{1}\\int_{0}^{1} \\left( -x \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} x\\,\\mathrm{d}x \n= -\\frac{1}{2},\\\\[6pt]\nI_{y,3} &= \\int_{0}^{1}\\int_{0}^{1} x\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} x\\,\\mathrm{d}x \n= \\frac{1}{2},\\\\[6pt]\nI_{y,4} &= \\int_{0}^{1}\\int_{0}^{1} (1-x)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= \\frac{1}{2}.\n\\end{aligned}\n$$\n\nCollecting these into the operator and noting $A=1$, we obtain\n$$\n\\mathbf{P}_v = \\begin{pmatrix}\n-\\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2}\n\\end{pmatrix}.\n$$\nAs a consistency check, the sums of the coefficients associated with $u$-DOFs and $v$-DOFs separately vanish,\n$$\n\\left(-\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{2}\\right) = 0,\n\\qquad\n\\left(-\\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}\\right) = 0,\n$$\nwhich is consistent with the partition of unity and the fact that a constant displacement field has zero volumetric strain. This completes the derivation of the volumetric average operator for the $\\bar{B}$-method on the unit square $Q_4$ element.", "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & \\frac{1}{2}\\end{pmatrix}}$$", "id": "3545792"}, {"introduction": "With the foundational operator derived, the next step is to witness its effect in a controlled numerical experiment. This hands-on coding practice guides you through the implementation of a hydrostatic patch test, a fundamental benchmark that isolates an element's volumetric response under uniform pressure [@problem_id:3545830]. By directly comparing a standard locking-prone element with a $\\bar{B}$-modified element, you will quantitatively verify how the projection method corrects the pathological stiffness to recover the exact physical solution.", "problem": "Design a square-domain hydrostatic patch test in two-dimensional linear elasticity under plane strain to isolate constant pressure modes and to compare a standard bilinear quadrilateral element against a $\\bar B$-modified element. The goal is to verify that the $\\bar B$ element reproduces exact constant planar hydrostatic stress under uniform boundary pressure loading while the standard element exhibits volumetric locking as Poisson’s ratio approaches incompressibility.\n\nUse the following fundamental base and assumptions:\n- Small-deformation, quasi-static, linear momentum balance without body forces.\n- Linear isotropic elasticity in plane strain with Young’s modulus $E$ and Poisson’s ratio $\\nu$, with Lamé parameters $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. The constitutive matrix in the engineering-strain basis $\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$ is\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}.\n$$\n- The bilinear quadrilateral ($Q4$) element with full Gauss integration of order $2\\times 2$ for stiffness and order $2$ on each boundary edge for consistent traction loads.\n- The $\\bar B$ modification replaces the volumetric strain at each Gauss point by the element-wise average volumetric strain while preserving the deviatoric part exactly.\n\nGeometry, loading, and boundary conditions:\n- The computational domain is the unit square $[0,1]\\times[0,1]$ partitioned into a structured mesh of $n_x \\times n_y$ bilinear elements. Use $L=1$ for the side length.\n- Apply a uniform compressive pressure $p_0$ on all four boundary edges with traction $\\mathbf{t} = -p_0 \\,\\mathbf{n}$, where $\\mathbf{n}$ is the outward unit normal.\n- To remove rigid body modes without disturbing the uniform hydrostatic contraction mode, impose the following essential boundary conditions:\n  - At the corner $(x,y)=(0,0)$, enforce $u=0$ and $v=0$.\n  - At the corner $(x,y)=(1,0)$, enforce $v=0$.\n  - At the corner $(x,y)=(0,1)$, enforce $u=0$.\nThese are consistent with a uniform contraction field $u = e\\,x$, $v = e\\,y$.\n\nHydrostatic exact solution for verification:\n- Under exact plane hydrostatic stress with $\\sigma_{xx}=\\sigma_{yy}=-p_0$ constant and no shear, a compatible exact constant strain field is $\\varepsilon_{xx}=\\varepsilon_{yy}=e$ and $\\gamma_{xy}=0$, where\n$$\ne = -\\frac{p_0}{2\\lambda + 2\\mu}.\n$$\nTherefore, the exact displacement field is $u(x,y)=e\\,x$ and $v(x,y)=e\\,y$ over the domain. The exact planar hydrostatic pressure (negative of the planar mean stress) satisfies $p_{\\text{planar}} = -\\dfrac{\\sigma_{xx}+\\sigma_{yy}}{2} = p_0$.\n\nFinite element formulations to implement:\n- Standard $Q4$: At each Gauss point $g$, compute the strain $\\boldsymbol\\varepsilon_g = \\mathbf{B}_g \\,\\mathbf{u}_e$ and stiffness contribution $\\mathbf{K}_e^{\\text{std}} \\mathrel{+}= \\mathbf{B}_g^\\top \\mathbf{D}\\,\\mathbf{B}_g \\, w_g \\,\\det\\mathbf{J}_g$.\n- $\\bar B$-modified $Q4$: Let $\\mathbf{m}^\\top = [\\,1 \\;\\; 1 \\;\\; 0\\,]$ (extracting the planar dilatation) and $\\mathbf{q} = [\\,1 \\;\\; 1 \\;\\; 0\\,]^\\top$. For an element with Gauss points $g$, define the element area\n$$\nA_e = \\sum_g w_g \\,\\det\\mathbf{J}_g\n$$\nand the element-averaged volumetric strain row vector\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\,\\det\\mathbf{J}_g \\,\\mathbf{m}^\\top \\mathbf{B}_g,\n$$\nso that the averaged dilatation is $\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\,\\mathbf{u}_e$. The $\\bar B$ strain-displacement operator at Gauss point $g$ is\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta},\n$$\nwhich preserves the deviatoric strain exactly and replaces only the volumetric part by its element-wise average. The element stiffness is\n$$\n\\mathbf{K}_e^{\\bar B} \\mathrel{+}= \\bar{\\mathbf{B}}_g^\\top \\mathbf{D}\\,\\bar{\\mathbf{B}}_g \\, w_g \\,\\det\\mathbf{J}_g.\n$$\n\nVerification metrics:\n- Compute the relative root-mean-square (RMS) displacement error\n$$\n\\eta_u = \\sqrt{ \\frac{\\sum_i \\left\\|\\mathbf{u}_i - \\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2}{\\sum_i \\left\\|\\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2} },\n$$\nwhere the sum runs over all nodes $i$, and $\\mathbf{u}=(u,v)$.\n- Compute the planar pressure error using element Gauss point stresses. For each method, compute the average planar pressure\n$$\n\\bar p = -\\frac{1}{2 A}\\sum_{e}\\sum_{g} \\left(\\sigma_{xx}^g + \\sigma_{yy}^g\\right)\\, w_g \\,\\det\\mathbf{J}_g,\n$$\nwhere $A=1$ is the total area, and define the relative pressure error\n$$\n\\eta_p = \\frac{|\\bar p - p_0|}{p_0}.\n$$\n\nTest suite:\n- Use $E=1$ and $p_0=1$ for all cases, with $L=1$.\n- Case $1$: $(n_x,n_y,\\nu) = (2,2,0.3)$.\n- Case $2$: $(n_x,n_y,\\nu) = (2,2,0.4999)$.\n- Case $3$: $(n_x,n_y,\\nu) = (4,4,0.4999)$.\n\nProgram requirements:\n- Implement both the standard and the $\\bar B$ element formulations as above, assemble the global systems, apply the essential boundary conditions specified, and use consistent traction loads for the pressure on each boundary with $2$-point Gauss integration along each boundary edge.\n- For each test case, compute the pair $(\\eta_u^{\\text{std}}, \\eta_u^{\\bar B})$ and $(\\eta_p^{\\text{std}}, \\eta_p^{\\bar B})$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $12$ floating-point numbers in the following order:\n  - Case $1$: $\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - Case $2$: $\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - Case $3$: $\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$.\nAll outputs are dimensionless floats. No units are required for the final outputs because the reported quantities are relative errors. Angles are not used. Percentages must be expressed as decimals (not with a percent sign).", "solution": "The problem requires the design and implementation of a hydrostatic patch test for two-dimensional linear elastic elements. The purpose of this test is to demonstrate the phenomenon of volumetric locking in standard bilinear quadrilateral ($Q4$) elements under near-incompressible conditions and to verify the corrective efficacy of the $\\bar B$ method.\n\nWe will simulate the response of a unit square domain, discretized by a structured mesh of $Q4$ elements, subjected to a uniform external pressure $p_0$. The material is isotropic and linear elastic, operating in a state of plane strain. The analysis will be performed for two element formulations: the standard $Q4$ element and a $Q4$ element modified with the $\\bar B$ technique.\n\nThe foundation of the finite element method (FEM) lies in the principle of virtual work, which, for quasi-static linear elasticity without body forces, leads to the matrix system $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$. Here, $\\mathbf{K}$ is the global stiffness matrix, $\\mathbf{U}$ is the vector of nodal displacements, and $\\mathbf{F}$ is the global nodal force vector derived from applied tractions.\n\nThe element stiffness matrix $\\mathbf{K}_e$ for a single element is computed by integrating over the element's volume (or area $A_e$ in $2D$):\n$$\n\\mathbf{K}_e = \\int_{A_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\,dA\n$$\nwhere $\\mathbf{D}$ is the material constitutive matrix and $\\mathbf{B}$ is the strain-displacement matrix, which relates nodal displacements $\\mathbf{u}_e$ to the strain field $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{u}_e$. For a $Q4$ element, $\\mathbf{B}$ is derived from the derivatives of the bilinear shape functions. The integral is evaluated numerically using $2 \\times 2$ Gauss quadrature.\n\nThe force vector $\\mathbf{F}_e$ due to a traction $\\mathbf{t}$ on an element boundary $\\Gamma_e$ is given by:\n$$\n\\mathbf{F}_e = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\,d\\Gamma\n$$\nwhere $\\mathbf{N}$ is the matrix of shape functions. For the specified uniform pressure $p_0$, the traction is $\\mathbf{t}=-p_0\\mathbf{n}$, where $\\mathbf{n}$ is the outward normal. The integral is evaluated using $2$-point Gauss quadrature along each boundary edge.\n\n**Volumetric Locking and the $\\bar B$ Method**\n\nVolumetric locking is a numerical artifact that occurs in low-order finite elements, such as the standard $Q4$ element, when modeling near-incompressible materials (i.e., as Poisson's ratio $\\nu \\to 0.5$). For plane strain, the Lamé parameter $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ approaches infinity, over-stiffening the element's response to volumetric deformation. The element incorrectly predicts a near-zero volumetric strain, or \"locks\".\n\nThe $\\bar B$ method corrects this by uncoupling the deviatoric and volumetric parts of the strain field calculation. At each Gauss point, the deviatoric strain is computed locally as in the standard formulation. However, the volumetric strain (dilatation) is replaced by a single, element-averaged value, $\\theta_{\\text{bar}}$.\n\nThis modification is implemented by constructing a modified strain-displacement matrix, $\\bar{\\mathbf{B}}$. The strain at a Gauss point $g$ is computed as $\\boldsymbol{\\varepsilon}_g = \\bar{\\mathbf{B}}_g \\mathbf{u}_e$. The problem provides the direct construction of $\\bar{\\mathbf{B}}_g$:\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta}\n$$\nwhere $\\mathbf{m}^\\top=[1,1,0]$ extracts the planar dilatation $\\theta = \\varepsilon_{xx}+\\varepsilon_{yy}$, $\\mathbf{q}=\\mathbf{m}^\\top$, and $\\boldsymbol{\\Theta}$ is a row vector that computes the element-averaged dilatation $\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\mathbf{u}_e$ from the element nodal displacements. Specifically, $\\boldsymbol{\\Theta}$ is computed by averaging $\\mathbf{m}^\\top\\mathbf{B}_g$ over the element area:\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\det(\\mathbf{J}_g) (\\mathbf{m}^\\top \\mathbf{B}_g)\n$$\nThe term $(\\mathbf{I} - \\frac{1}{2}\\mathbf{q}\\mathbf{m}^\\top)$ is a projection operator that extracts the deviatoric part of the strain from the standard calculation $\\mathbf{B}_g\\mathbf{u}_e$. The term $\\frac{1}{2}\\mathbf{q}\\boldsymbol{\\Theta}$ then adds back the volumetric part using the single averaged value. The element stiffness for the $\\bar B$ element is then:\n$$\n\\mathbf{K}_e^{\\bar B} = \\int_{A_e} \\bar{\\mathbf{B}}^\\top \\mathbf{D} \\bar{\\mathbf{B}} \\,dA\n$$\n\n**Patch Test Verification**\n\nThe problem describes a hydrostatic patch test, where the exact solution corresponds to a state of uniform hydrostatic stress and strain. The analytical displacement field is $u(x,y)=e\\,x$, $v(x,y)=e\\,y$, where $e = -p_0/(2\\lambda + 2\\mu)$. A valid FEM formulation should reproduce this exact solution.\n\nWe apply essential boundary conditions at three corners to remove rigid-body motion without constraining the exact deformation mode. Nodal forces are applied consistently from the uniform boundary pressure. We then solve the global system $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ for both the standard and $\\bar B$ formulations.\n\nThe results are quantified by two error metrics:\n$1$. The relative root-mean-square displacement error, $\\eta_u$, which measures the deviation of the computed nodal displacements from the exact field.\n$2$. The relative pressure error, $\\eta_p$, which measures the deviation of the computed average planar pressure from the analytical value $p_0$.\n\nFor cases with $\\nu \\to 0.5$, we expect the standard $Q4$ element to yield large errors ($\\eta_u \\to 1$ and large $\\eta_p$), indicative of locking. In contrast, the $\\bar B$ element is designed to pass this patch test, so its errors should remain close to machine precision for all values of $\\nu$. The provided test cases with $\\nu=0.3$ and $\\nu=0.4999$ will highlight this difference. Mesh refinement (Case $3$) will not alleviate locking for the standard element in this test.", "answer": "```python\nimport numpy as np\n\ndef solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar):\n    \"\"\"\n    Solves a 2D linear elasticity problem on a square domain using Q4 elements.\n    \"\"\"\n    # 1. Material and Mesh Setup\n    if abs(1 - 2 * nu) < 1e-9: # Avoid singularity at nu=0.5\n        return np.nan, np.nan\n    lame_lambda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    lame_mu = E / (2 * (1 + nu))\n    D = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, lame_mu]\n    ])\n\n    num_nodes_x = nx + 1\n    num_nodes_y = ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(num_nodes_y):\n        for i in range(num_nodes_x):\n            node_idx = i + j * num_nodes_x\n            node_coords[node_idx, 0] = i * L / nx\n            node_coords[node_idx, 1] = j * L / ny\n\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n1 = i + j * num_nodes_x\n            n2 = (i + 1) + j * num_nodes_x\n            n3 = (i + 1) + (j + 1) * num_nodes_x\n            n4 = i + (j + 1) * num_nodes_x\n            elements.append(np.array([n1, n2, n3, n4]))\n\n    K = np.zeros((num_dofs, num_dofs))\n    \n    # 2. Element Assembly Loop\n    gauss_points = [-1 / np.sqrt(3), 1 / np.sqrt(3)]\n    gauss_weights = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta), (1 + xi) * (1 - eta),\n                               (1 + xi) * (1 + eta), (1 - xi) * (1 + eta)])\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        return N, dN_dxi, dN_deta\n\n    m_T = np.array([1.0, 1.0, 0.0])\n    q = m_T.reshape(3, 1)\n    P_dev = np.eye(3) - 0.5 * q @ q.T\n\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        Ke = np.zeros((8, 8))\n        \n        # B-bar: First pass to compute element-averaged strain vector Theta\n        if use_b_bar:\n            el_area = 0.0\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0, 2 * i] = dN_d_xy[0]\n                        B_gauss[1, 2 * i + 1] = dN_d_xy[1]\n                        B_gauss[2, 2 * i] = dN_d_xy[1]\n                        B_gauss[2, 2 * i + 1] = dN_d_xy[0]\n                    \n                    el_area += detJ  # All weights are 1.0\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n\n        # Second pass to compute stiffness matrix\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0, 2 * i] = dN_d_xy[0]\n                    B[1, 2 * i + 1] = dN_d_xy[1]\n                    B[2, 2 * i] = dN_d_xy[1]\n                    B[2, 2 * i + 1] = dN_d_xy[0]\n\n                if use_b_bar:\n                    B_bar = P_dev @ B + 0.5 * q @ Theta.reshape(1, 8)\n                    Ke += B_bar.T @ D @ B_bar * w * detJ\n                else:\n                    Ke += B.T @ D @ B * w * detJ\n\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        K[np.ix_(dof_indices, dof_indices)] += Ke\n\n    # 3. Apply Boundary Conditions and Loads\n    F = np.zeros(num_dofs)\n    hx, hy = L / nx, L / ny\n    for i in range(nx): # Bottom edge y=0, n=(0,-1), t=(0,p0)\n        n1, n2 = i, i+1; F[2*n1+1]+=p0*hx/2; F[2*n2+1]+=p0*hx/2\n    for i in range(nx): # Top edge y=L, n=(0,1), t=(0,-p0)\n        n1, n2 = i+ny*num_nodes_x, i+1+ny*num_nodes_x; F[2*n1+1]-=p0*hx/2; F[2*n2+1]-=p0*hx/2\n    for j in range(ny): # Left edge x=0, n=(-1,0), t=(p0,0)\n        n1, n2 = j*num_nodes_x, (j+1)*num_nodes_x; F[2*n1]+=p0*hy/2; F[2*n2]+=p0*hy/2\n    for j in range(ny): # Right edge x=L, n=(1,0), t=(-p0,0)\n        n1, n2 = nx+j*num_nodes_x, nx+(j+1)*num_nodes_x; F[2*n1]-=p0*hy/2; F[2*n2]-=p0*hy/2\n\n    bc_dofs = []\n    bc_dofs.extend([0, 1])  # (0,0): u=0, v=0\n    bc_dofs.append(2 * nx + 1)  # (L,0): v=0\n    bc_dofs.append(2 * (ny * num_nodes_x)) # (0,L): u=0\n    \n    free_dofs = np.setdiff1d(np.arange(num_dofs), bc_dofs)\n    \n    U = np.zeros(num_dofs)\n    U[free_dofs] = np.linalg.solve(K[np.ix_(free_dofs, free_dofs)], F[free_dofs])\n\n    # 4. Post-processing and Error Calculation\n    e = -p0 / (2 * lame_lambda + 2 * lame_mu)\n    U_exact = np.array([e * c[0] if i % 2 == 0 else e * c[1] for i, c in enumerate(np.repeat(node_coords, 2, axis=0))])\n    \n    sum_u_exact_sq = np.sum(U_exact**2)\n    sum_u_err_sq = np.sum((U - U_exact)**2)\n    eta_u = np.sqrt(sum_u_err_sq / sum_u_exact_sq) if sum_u_exact_sq > 0 else 0\n\n    pressure_integral = 0\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        u_e = U[dof_indices]\n\n        if use_b_bar: # Recompute Theta needed for stress calculation\n            el_area = (L/nx)*(L/ny)\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0,2*i]=dN_d_xy[0]; B_gauss[1,2*i+1]=dN_d_xy[1]; B_gauss[2,2*i]=dN_d_xy[1]; B_gauss[2,2*i+1]=dN_d_xy[0]\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n            theta_bar_val = Theta @ u_e\n\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0,2*i]=dN_d_xy[0]; B[1,2*i+1]=dN_d_xy[1]; B[2,2*i]=dN_d_xy[1]; B[2,2*i+1]=dN_d_xy[0]\n\n                if use_b_bar:\n                    strain = (P_dev @ B @ u_e) + (0.5 * q.flatten() * theta_bar_val)\n                else:\n                    strain = B @ u_e\n                \n                stress = D @ strain\n                pressure_integral += (stress[0] + stress[1]) * w * detJ\n                \n    avg_p = -0.5 * pressure_integral / (L*L)\n    eta_p = abs(avg_p - p0) / p0 if p0 != 0 else 0\n\n    return eta_u, eta_p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (2, 2, 0.3),\n        (2, 2, 0.4999),\n        (4, 4, 0.4999),\n    ]\n    E = 1.0\n    p0 = 1.0\n    L = 1.0\n    results = []\n\n    for nx, ny, nu in test_cases:\n        # Standard Q4 element\n        eta_u_std, eta_p_std = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=False)\n        # B-bar modified Q4 element\n        eta_u_bbar, eta_p_bbar = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=True)\n        \n        results.extend([eta_u_std, eta_u_bbar, eta_p_std, eta_p_bbar])\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3545830"}, {"introduction": "Moving beyond simple verification, this practice addresses a more challenging and realistic benchmark: the bending of a cantilever beam. This scenario induces complex, spatially varying strain fields, providing a stringent test for element performance in the nearly incompressible regime [@problem_id:3545765]. This implementation will not only solidify your understanding of the $\\bar{B}$ method but also introduce the related $J$-bar (selective reduced integration) technique and, most importantly, equip you with a suite of quantitative metrics used in practice to diagnose locking and assess the performance of different remedies.", "problem": "Consider the quasi-static, small-strain bending of a two-dimensional cantilever beam under plane strain kinematics in the context of isotropic linear elasticity. Let the beam occupy the rectangle $\\Omega = [0,L] \\times [0,H]$ with thickness equal to $1$. The left edge at $x=0$ is fully clamped, satisfying $u_x = 0$ and $u_y = 0$, and a uniform vertical traction $t_y = -q$ (downward) is applied on the right edge at $x=L$. Neglect body forces. Use a four-node bilinear quadrilateral element (denoted $\\mathrm{Q4}$) with a standard isoparametric mapping.\n\nThe fundamental base consists of:\n- Linear momentum balance in the absence of inertia and body forces: $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$.\n- Small-strain kinematics: $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^\\top)$, with $\\boldsymbol{u} = (u_x,u_y)$.\n- Isotropic linear elasticity in terms of the Lamé parameters $\\lambda$ and $\\mu$, with plane strain constitutive law: $\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$, where $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. The bulk modulus is $\\kappa = \\lambda + \\dfrac{2}{3}\\mu$.\n- The standard $\\mathrm{Q4}$ finite element method with bilinear shape functions, and $2\\times 2$ Gauss integration for element matrices under full integration.\n\nVolumetric locking may occur when the material is nearly incompressible, i.e., when the Poisson ratio $\\nu$ approaches $0.5$, making $\\kappa \\gg \\mu$. This problem focuses on remedies using $B$-bar and $J$-bar methods and how to assess locking through quantifiable metrics.\n\nYou must implement two remedies:\n1. $B$-bar method: Replace the volumetric strain $\\varepsilon_{\\mathrm{vol}} = \\mathrm{tr}(\\boldsymbol{\\varepsilon})$ at Gauss points by its element-wise mean $\\overline{\\varepsilon}_{\\mathrm{vol}}$, leading to a modified volumetric stiffness per element of the form\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}},\n$$\nwhere $\\Omega_e$ is the element area and $\\mathbf{B}_{\\mathrm{vol,mean}}$ maps nodal displacements to the element-mean volumetric strain, defined by\n$$\n\\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega,\n\\quad\n\\mathbf{B}_{\\mathrm{vol}} \\boldsymbol{u}_e = \\varepsilon_{\\mathrm{vol}}.\n$$\n\n2. $J$-bar method (small-strain analogue): Compute the volumetric stiffness using one-point integration at the element center while retaining full integration for deviatoric terms, i.e.,\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, w_c \\, J_c \\, \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}},\n$$\nwhere $\\mathbf{B}_{\\mathrm{vol,c}}$ is the volumetric strain-displacement row at the element center, $J_c$ is the Jacobian determinant at the center, and $w_c=4$ is the $1\\times 1$ Gauss weight for the biunit square mapping.\n\nDecompose the constitutive stiffness into deviatoric and volumetric parts to isolate the volumetric locking mechanism. In Voigt notation with $\\boldsymbol{\\varepsilon}_v=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\top$ under plane strain, use the deviatoric matrix\n$$\n\\mathbf{C}_{\\mathrm{dev}} =\n\\begin{bmatrix}\n\\dfrac{4\\mu}{3} & -\\dfrac{2\\mu}{3} & 0 \\\\\n-\\dfrac{2\\mu}{3} & \\dfrac{4\\mu}{3} & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix},\n$$\nand the volumetric energy density $\\kappa \\, \\varepsilon_{\\mathrm{vol}}^2$ with $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$. Assemble the global stiffness as\n$$\n\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}},\n\\quad\n\\mathbf{K}_{\\mathrm{dev}} = \\int_{\\Omega} \\mathbf{B}^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B} \\,\\mathrm{d}\\Omega,\n$$\nwith $2\\times 2$ Gauss integration for $\\mathbf{K}_{\\mathrm{dev}}$, and $\\mathbf{K}_{\\mathrm{vol}}$ according to the chosen method ($B$-bar or $J$-bar).\n\nUse the following explicit locking assessment metrics:\n- Metric M1 (edge deflection): The average vertical displacement at the loaded edge $x=L$, defined by\n$$\n\\overline{v}_{\\mathrm{edge}} = \\frac{1}{N_R}\\sum_{i\\in \\Gamma_R} v_i,\n$$\nwhere $\\Gamma_R$ is the set of nodes with $x=L$, $N_R$ its cardinality, and $v_i$ is the nodal $u_y$ at node $i$. Report this in meters, rounded to six decimal places.\n\n- Metric M2 (volumetric energy fraction): The ratio of volumetric strain energy to total strain energy,\n$$\n\\eta_{\\mathrm{vol}} = \\frac{U_{\\mathrm{vol}}}{U_{\\mathrm{tot}}},\n\\quad\nU_{\\mathrm{tot}} = \\tfrac{1}{2} \\boldsymbol{u}^\\top \\mathbf{K} \\boldsymbol{u},\n$$\nand $U_{\\mathrm{vol}}$ assembled consistently with the chosen method, i.e., per element\n$$\nU_{\\mathrm{vol}}^{(e)} =\n\\begin{cases}\n\\tfrac{1}{2}\\kappa \\,\\Omega_e \\left(\\mathbf{B}_{\\mathrm{vol,mean}}\\boldsymbol{u}_e\\right)^2, & \\text{$B$-bar},\\\\[6pt]\n\\tfrac{1}{2}\\kappa \\, w_c J_c \\left(\\mathbf{B}_{\\mathrm{vol,c}}\\boldsymbol{u}_e\\right)^2, & \\text{$J$-bar}.\n\\end{cases}\n$$\nReport $\\eta_{\\mathrm{vol}}$ as a unitless decimal rounded to six decimal places.\n\n- Metric M3 (volumetric strain oscillation): The root-mean-square of the deviation of the volumetric strain from the element mean,\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g J_g \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}},\n\\quad\n\\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)} = \\frac{1}{\\Omega_e}\\sum_{g} w_g J_g \\varepsilon_{\\mathrm{vol},g}^{(e)},\n$$\nwhere $g$ indexes the $2 \\times 2$ Gauss points in element $e$. Report $r_{\\mathrm{vol}}$ as a unitless decimal rounded to six decimal places.\n\nImplement the finite element assembly, boundary conditions, and the two remedies, then compute the three metrics for both $B$-bar and $J$-bar methods.\n\nTest Suite:\nUse the following parameter sets to exercise the solver, covering a typical case, a severe locking case, and a baseline compressible case. All quantities are in SI units.\n\n- Case 1 (typical nearly incompressible bending): $L=4\\,\\mathrm{m}$, $H=1\\,\\mathrm{m}$, $E=1.0\\times 10^{6}\\,\\mathrm{Pa}$, $\\nu=0.499$, $q=1.0\\times 10^{3}\\,\\mathrm{N/m}$, mesh $n_x=8$, $n_y=4$.\n\n- Case 2 (severe locking tendency, coarse mesh): $L=4\\,\\mathrm{m}$, $H=1\\,\\mathrm{m}$, $E=1.0\\times 10^{6}\\,\\mathrm{Pa}$, $\\nu=0.4999$, $q=1.0\\times 10^{3}\\,\\mathrm{N/m}$, mesh $n_x=2$, $n_y=1$.\n\n- Case 3 (baseline moderately compressible): $L=4\\,\\mathrm{m}$, $H=1\\,\\mathrm{m}$, $E=1.0\\times 10^{6}\\,\\mathrm{Pa}$, $\\nu=0.3$, $q=1.0\\times 10^{3}\\,\\mathrm{N/m}$, mesh $n_x=2$, $n_y=1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a six-item list in the following order:\n$[\\overline{v}_{\\mathrm{edge},B\\text{-}\\mathrm{bar}},\\overline{v}_{\\mathrm{edge},J\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},J\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},J\\text{-}\\mathrm{bar}}]$.\nAll six values must be floats rounded to six decimal places. Aggregate the three test case lists into one list with no spaces, e.g., \"[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]\".", "solution": "The problem is valid as it presents a well-posed, scientifically-grounded task in computational solid mechanics. It is self-contained, with all necessary data, equations, and definitions for implementing a finite element solution to a plane strain cantilever beam problem. The core of the problem—assessing volumetric locking and its remedies ($B$-bar and $J$-bar methods)—is a standard and important topic in the field. The provided equations, boundary conditions, and assessment metrics are consistent and allow for a unique, verifiable solution.\n\nHerein, a detailed methodology for the finite element implementation is presented.\n\n### 1. Finite Element Discretization\nThe problem domain $\\Omega = [0,L] \\times [0,H]$ is discretized into a structured mesh of $n_x \\times n_y$ four-node bilinear quadrilateral ($\\mathrm{Q4}$) elements. The displacement field $\\boldsymbol{u}(x,y)$ within each element $\\Omega_e$ is approximated using isoparametric shape functions $N_i(\\xi, \\eta)$:\n$$\n\\boldsymbol{u}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{u}_i, \\quad \\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\nwhere $\\boldsymbol{u}_i$ and $\\boldsymbol{x}_i$ are the nodal displacements and coordinates, respectively, and $(\\xi, \\eta)$ are the parent coordinates in the bi-unit square $[-1,1]^2$. The shape functions are given by $N_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta)$, and $N_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta)$.\n\nThe small-strain tensor $\\boldsymbol{\\varepsilon}$ is related to the nodal displacements $\\boldsymbol{d}_e$ via the strain-displacement matrix $\\mathbf{B}$:\n$$\n\\boldsymbol{\\varepsilon}_v = \\mathbf{B} \\boldsymbol{d}_e, \\quad \\text{where} \\quad \\boldsymbol{\\varepsilon}_v = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top\n$$\nThe matrix $\\mathbf{B}$ is derived from the spatial derivatives of the shape functions. The derivative of a shape function with respect to physical coordinates $(x,y)$ is obtained using the chain rule and the inverse of the Jacobian matrix $\\mathbf{J}$:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}, \\quad \\mathbf{J} = \\begin{bmatrix} \\partial x / \\partial \\xi & \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta & \\partial y / \\partial \\eta \\end{bmatrix}\n$$\nThe $3 \\times 8$ matrix $\\mathbf{B}$ for a $\\mathrm{Q4}$ element is thus constructed as:\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}, \\quad \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\n$$\n\n### 2. Stiffness Matrix Decomposition and Assembly\nThe principle of virtual work leads to the system of linear equations $\\mathbf{K}\\boldsymbol{u}=\\mathbf{F}$, where $\\mathbf{K}$ is the global stiffness matrix, $\\boldsymbol{u}$ is the vector of global nodal displacements, and $\\mathbf{F}$ is the global force vector. The stiffness matrix is additively decomposed into deviatoric and volumetric parts: $\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}}$.\n\nThe element stiffness matrix for a unit thickness is $\\mathbf{K}^{(e)} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega$, where $\\mathbf{C}$ is the constitutive matrix for plane strain. The decomposition of $\\mathbf{C}$ into $\\mathbf{C}_{\\mathrm{dev}}$ and $\\mathbf{C}_{\\mathrm{vol}}$ allows for the separate assembly of the stiffness parts. Integration is performed numerically using Gauss quadrature over the parent element:\n$$\n\\mathbf{K}^{(e)} = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx \\sum_{g} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_g \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\nwhere $g$ indexes the Gauss points, and $w_g$ are the quadrature weights.\n\n#### Deviatoric Stiffness $\\mathbf{K}_{\\mathrm{dev}}$\nThe deviatoric stiffness is computed using full $2 \\times 2$ Gauss quadrature as specified:\n$$\n\\mathbf{K}_{\\mathrm{dev}}^{(e)} = \\sum_{g=1}^{4} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\nwith the provided deviatoric constitutive matrix $\\mathbf{C}_{\\mathrm{dev}}$.\n\n#### Volumetric Stiffness $\\mathbf{K}_{\\mathrm{vol}}$\nTwo methods are implemented to compute the volumetric stiffness, both designed to alleviate locking. The volumetric part of the constitutive response is associated with the energy density $\\tfrac{1}{2}\\kappa \\varepsilon_{\\mathrm{vol}}^2$, where $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$. The strain $\\varepsilon_{\\mathrm{vol}}$ is related to the nodal displacements via the row vector $\\mathbf{B}_{\\mathrm{vol}} = [1, 1, 0]\\mathbf{B}$.\n\n1.  **$J$-bar Method (Selective Reduced Integration):** The volumetric stiffness is integrated using a single Gauss point at the element center $(\\xi, \\eta)=(0,0)$. The corresponding weight for the bi-unit square is $w_c=4$.\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, J}^{(e)} = \\kappa \\left( \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}} \\right) w_c \\det(\\mathbf{J}_c)\n    $$\n    where the subscript $c$ indicates evaluation at the element center.\n\n2.  **$B$-bar Method:** This method replaces the local volumetric strain-displacement operator $\\mathbf{B}_{\\mathrm{vol}}$ with its element-average, $\\mathbf{B}_{\\mathrm{vol,mean}}$.\n    $$\n    \\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega = \\frac{\\sum_{g=1}^{4} w_g \\mathbf{B}_{\\mathrm{vol},g} \\det(\\mathbf{J}_g)}{\\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)}\n    $$\n    The element volumetric stiffness is then constructed as:\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, B}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}}\n    $$\n    where $\\Omega_e = \\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)$ is the element area computed with full integration.\n\n### 3. Force Vector and Boundary Conditions\nA uniform traction $t_y = -q$ is applied on the right edge ($x=L$). The consistent nodal force vector $\\mathbf{F}$ is assembled by integrating the traction against the shape functions along each element edge on this boundary. For a vertical edge of length $h_e$ on a rectangular element, the total vertical force $-q h_e$ is distributed equally to the two nodes on that edge, contributing $-q h_e / 2$ to each.\n\nThe clamped boundary condition at $x=0$ ($u_x = 0, u_y = 0$) is enforced by applying the penalty method. A large number is added to the diagonal entries of the global stiffness matrix corresponding to the constrained degrees of freedom.\n\n### 4. Locking Assessment Metrics\nAfter solving the systems $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},B})\\boldsymbol{u}_B = \\mathbf{F}$ and $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},J})\\boldsymbol{u}_J = \\mathbf{F}$ for the displacement vectors $\\boldsymbol{u}_B$ and $\\boldsymbol{u}_J$, the following metrics are computed for each solution:\n\n-   **M1 (Edge Deflection):** The average vertical displacement $\\overline{v}_{\\mathrm{edge}}$ of the nodes on the loaded edge at $x=L$. This metric directly shows the artificial stiffening effect of locking; a locked element structure will deflect less.\n\n-   **M2 (Volumetric Energy Fraction):** The ratio $\\eta_{\\mathrm{vol}} = U_{\\mathrm{vol}}/U_{\\mathrm{tot}}$. The total strain energy is $U_{\\mathrm{tot}} = \\tfrac{1}{2}\\boldsymbol{u}^\\top\\mathbf{F}$. The volumetric strain energy $U_{\\mathrm{vol}}$ is summed over all elements, using the formulation consistent with the method used (B-bar or J-bar). In locking-prone situations, this ratio becomes spuriously high as the element resists volume changes excessively.\n\n-   **M3 (Volumetric Strain Oscillation):** The metric $r_{\\mathrm{vol}}$ quantifies the non-physical, element-level oscillations in the volumetric strain field, a classic symptom of locking. It is the root-mean-square of the deviation of the point-wise volumetric strain (at $2 \\times 2$ Gauss points) from the element's mean volumetric strain. A high value indicates significant, unphysical strain variations within elements.\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g \\det(\\mathbf{J}_g) \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}}\n$$\nwhere $\\varepsilon_{\\mathrm{vol},g}^{(e)}$ is computed from the solved displacement field $\\boldsymbol{u}$ using the standard $\\mathbf{B}_{\\mathrm{vol}, g}$ at each Gauss point $g$.\n\nThese three metrics provide a comprehensive, quantitative assessment of volumetric locking and the effectiveness of the implemented remedies.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (typical nearly incompressible bending)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.499, 'q': 1.0e3, 'nx': 8, 'ny': 4},\n        # Case 2 (severe locking tendency, coarse mesh)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.4999, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n        # Case 3 (baseline moderately compressible)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.3, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(**case)\n        results.append(case_results)\n\n    # Format output string to match requirements\n    # '[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]'\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\ndef solve_case(L, H, E, nu, q, nx, ny):\n    \"\"\"\n    Solves the FEM problem for a single set of parameters.\n    \"\"\"\n    # 1. Material properties and mesh generation\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    kappa = lmbda + 2/3 * mu\n    \n    C_dev = np.array([\n        [4/3 * mu, -2/3 * mu, 0],\n        [-2/3 * mu, 4/3 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    num_nodes = (nx + 1) * (ny + 1)\n    num_elems = nx * ny\n    \n    node_coords = np.zeros((num_nodes, 2))\n    dx, dy = L / nx, H / ny\n    for j in range(ny + 1):\n        for i in range(nx + 1):\n            node_idx = j * (nx + 1) + i\n            node_coords[node_idx] = [i * dx, j * dy]\n\n    elem_conn = np.zeros((num_elems, 4), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            elem_idx = j * nx + i\n            n1 = j * (nx + 1) + i\n            n2 = n1 + 1\n            n3 = n2 + nx + 1\n            n4 = n1 + nx + 1\n            elem_conn[elem_idx] = [n1, n2, n3, n4]\n            \n    # 2. FEM Preliminaries\n    # Gauss points and weights for 2x2 quadrature\n    gp = 1 / np.sqrt(3)\n    gauss_points_2x2 = np.array([[-gp, -gp], [gp, -gp], [gp, gp], [-gp, gp]])\n    gauss_weights_2x2 = np.array([1, 1, 1, 1])\n\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        return N\n\n    def shape_derivatives(xi, eta):\n        dNd_xi = 0.25 * np.array([\n            -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n        ])\n        dNd_eta = 0.25 * np.array([\n            -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n        ])\n        return dNd_xi, dNd_eta\n\n    # 3. Assembly\n    num_dofs = 2 * num_nodes\n    K_dev = np.zeros((num_dofs, num_dofs))\n    K_vol_B = np.zeros((num_dofs, num_dofs))\n    K_vol_J = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n    \n    dofs_map = np.zeros((4, 2), dtype=int)\n\n    m_vec = np.array([1, 1, 0])\n\n    for el in range(num_elems):\n        node_indices = elem_conn[el]\n        el_coords = node_coords[node_indices]\n        \n        dofs_map[:, 0] = 2 * node_indices\n        dofs_map[:, 1] = 2 * node_indices + 1\n        dofs = dofs_map.flatten()\n\n        # Deviatoric stiffness (full 2x2 integration)\n        Ke_dev = np.zeros((8, 8))\n        \n        # For B-bar method\n        B_vol_int = np.zeros(8)\n        Omega_e = 0.0\n\n        for i in range(len(gauss_points_2x2)):\n            xi, eta = gauss_points_2x2[i]\n            w = gauss_weights_2x2[i]\n            \n            dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n            \n            J_mat = np.zeros((2, 2))\n            J_mat[0, :] = dNd_xi @ el_coords\n            J_mat[1, :] = dNd_eta @ el_coords\n            detJ = np.linalg.det(J_mat)\n            invJ = np.linalg.inv(J_mat)\n            \n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                B[0, 2*k] = dNd_xy[0]\n                B[1, 2*k+1] = dNd_xy[1]\n                B[2, 2*k] = dNd_xy[1]\n                B[2, 2*k+1] = dNd_xy[0]\n\n            Ke_dev += B.T @ C_dev @ B * detJ * w\n            \n            # Accumulate for B-bar\n            B_vol = m_vec @ B\n            B_vol_int += B_vol * detJ * w\n            Omega_e += detJ * w\n\n        K_dev[np.ix_(dofs, dofs)] += Ke_dev\n\n        # B-bar volumetric stiffness\n        B_vol_mean = B_vol_int / Omega_e\n        Ke_vol_B = kappa * Omega_e * np.outer(B_vol_mean, B_vol_mean)\n        K_vol_B[np.ix_(dofs, dofs)] += Ke_vol_B\n\n        # J-bar volumetric stiffness (1-point integration)\n        xi_c, eta_c = 0.0, 0.0\n        dNd_xi_c, dNd_eta_c = shape_derivatives(xi_c, eta_c)\n        J_mat_c = np.zeros((2, 2))\n        J_mat_c[0, :] = dNd_xi_c @ el_coords\n        J_mat_c[1, :] = dNd_eta_c @ el_coords\n        detJ_c = np.linalg.det(J_mat_c)\n        invJ_c = np.linalg.inv(J_mat_c)\n        \n        B_c = np.zeros((3, 8))\n        for k in range(4):\n            dNd_xy_c = invJ_c @ np.array([dNd_xi_c[k], dNd_eta_c[k]])\n            B_c[0, 2 * k] = dNd_xy_c[0]\n            B_c[1, 2 * k + 1] = dNd_xy_c[1]\n            B_c[2, 2 * k] = dNd_xy_c[1]\n            B_c[2, 2 * k + 1] = dNd_xy_c[0]\n        \n        B_vol_c = m_vec @ B_c\n        w_c = 4.0 # For bi-unit square\n        Ke_vol_J = kappa * w_c * detJ_c * np.outer(B_vol_c, B_vol_c)\n        K_vol_J[np.ix_(dofs, dofs)] += Ke_vol_J\n    \n    # Force vector\n    for j in range(ny):\n        elem_idx = (j + 1) * nx - 1\n        nodes = elem_conn[elem_idx]\n        dof_y1 = 2 * nodes[1] + 1\n        dof_y2 = 2 * nodes[2] + 1\n        force_per_node = -q * dy / 2.0\n        F[dof_y1] += force_per_node\n        F[dof_y2] += force_per_node\n\n    # 4. Boundary Conditions\n    K_B = K_dev + K_vol_B\n    K_J = K_dev + K_vol_J\n    \n    penalty = 1e10 * np.max(np.abs(K_B.diagonal())) \n    clamped_nodes = np.where(node_coords[:, 0] == 0)[0]\n    for node_idx in clamped_nodes:\n        dof1 = 2 * node_idx\n        dof2 = 2 * node_idx + 1\n        K_B[dof1, dof1] += penalty\n        K_B[dof2, dof2] += penalty\n        K_J[dof1, dof1] += penalty\n        K_J[dof2, dof2] += penalty\n\n    # 5. Solve\n    u_B = np.linalg.solve(K_B, F)\n    u_J = np.linalg.solve(K_J, F)\n\n    # 6. Post-processing - Metrics\n    def calculate_metrics(u_sol, K_vol_method):\n        # M1: Edge deflection\n        right_edge_nodes = np.where(node_coords[:, 0] == L)[0]\n        right_edge_dofs_y = 2 * right_edge_nodes + 1\n        v_edge = np.mean(u_sol[right_edge_dofs_y])\n        \n        # M2: Volumetric energy fraction\n        U_tot = 0.5 * u_sol @ F\n        U_vol = 0.5 * u_sol @ (K_vol_method @ u_sol)\n        eta_vol = U_vol / U_tot if U_tot != 0 else 0\n\n        # M3: Volumetric strain oscillation\n        total_volume = 0\n        osc_numerator = 0\n        for el in range(num_elems):\n            node_indices = elem_conn[el]\n            el_coords = node_coords[node_indices]\n            dofs_map[:, 0] = 2 * node_indices\n            dofs_map[:, 1] = 2 * node_indices + 1\n            dofs = dofs_map.flatten()\n            u_e = u_sol[dofs]\n\n            # Calculate mean vol strain with 2x2 Gauss\n            vol_strain_sum = 0\n            Omega_e = 0\n            strains_at_gp = []\n            \n            for i in range(len(gauss_points_2x2)):\n                xi, eta = gauss_points_2x2[i]\n                w = gauss_weights_2x2[i]\n                \n                dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n                J_mat = np.zeros((2, 2))\n                J_mat[0, :] = dNd_xi @ el_coords\n                J_mat[1, :] = dNd_eta @ el_coords\n                detJ = np.linalg.det(J_mat)\n                invJ = np.linalg.inv(J_mat)\n                \n                B = np.zeros((3, 8))\n                for k in range(4):\n                    dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                    B[0, 2*k] = dNd_xy[0]\n                    B[1, 2*k+1] = dNd_xy[1]\n                    B[2, 2*k] = dNd_xy[1]\n                    B[2, 2*k+1] = dNd_xy[0]\n\n                eps_vol_g = (m_vec @ B) @ u_e\n                strains_at_gp.append((eps_vol_g, w, detJ))\n                vol_strain_sum += eps_vol_g * detJ * w\n                Omega_e += detJ * w\n            \n            eps_vol_mean = vol_strain_sum / Omega_e if Omega_e != 0 else 0\n            total_volume += Omega_e\n            \n            # Sum for numerator\n            for eps_vol_g, w, detJ in strains_at_gp:\n                osc_numerator += w * detJ * (eps_vol_g - eps_vol_mean)**2\n        \n        r_vol = np.sqrt(osc_numerator / total_volume) if total_volume != 0 else 0\n        \n        return round(v_edge, 6), round(eta_vol, 6), round(r_vol, 6)\n\n    v_B, eta_B, r_B = calculate_metrics(u_B, K_vol_B)\n    v_J, eta_J, r_J = calculate_metrics(u_J, K_vol_J)\n    \n    return [v_B, v_J, eta_B, eta_J, r_B, r_J]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3545765"}]}