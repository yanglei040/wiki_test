{"hands_on_practices": [{"introduction": "A cornerstone of reliable scientific computing is verification. For simple plasticity models, it is possible to derive an exact, closed-form solution for the plastic multiplier increment, $\\Delta\\lambda$. This analytical solution serves as an invaluable benchmark to confirm that a numerical implementation of the return mapping algorithm is free of bugs. This foundational exercise [@problem_id:3550975] guides you through the derivation and implementation for a simple uniaxial model with linear isotropic hardening, allowing you to validate your numerical solver and build confidence before tackling more complex models.", "problem": "Design and implement a uniaxial small-strain elastoplastic return-mapping verification using an isotropic linear hardening model. Work from fundamental definitions and laws to derive a closed-form update of the plastic multiplier increment and use it to verify a numerical implementation driven by the consistency condition. Your implementation must be a complete program that computes, for several prescribed load steps, both the analytically derived plastic multiplier increment and a numerically obtained value from an implicit return-mapping with the consistency condition, and compares them.\n\nModel assumptions and definitions:\n\n- Kinematics and elasticity: In one-dimensional small strain, the total strain increment is denoted by $\\Delta \\varepsilon$, the plastic strain by $\\varepsilon^{p}$, and the Cauchy stress by $\\sigma$. Linear elasticity gives $\\sigma = E \\left( \\varepsilon - \\varepsilon^{p} \\right)$, where $E$ is the Young's modulus (in $\\mathrm{Pa}$). The trial stress is $\\sigma^{\\mathrm{tr}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right)$, where subscript $n$ denotes the previous step.\n- Yield function with linear isotropic hardening: $f(\\sigma,\\alpha) = \\lvert \\sigma \\rvert - \\left( \\sigma_{y0} + H \\alpha \\right)$, where $\\sigma_{y0}$ is the initial yield stress (in $\\mathrm{Pa}$), $H$ is the hardening modulus (in $\\mathrm{Pa}$), and $\\alpha$ is the accumulated plastic strain (dimensionless), defined by $\\dot{\\alpha} = \\lvert \\dot{\\varepsilon}^{p} \\rvert$.\n- Associated flow and Karush-Kuhn-Tucker (KKT) conditions: The plastic flow is associative, $\\dot{\\varepsilon}^{p} = \\dot{\\lambda} \\, \\mathrm{sign}(\\sigma)$, with plastic multiplier rate $\\dot{\\lambda} \\ge 0$. The KKT conditions are $\\dot{\\lambda} \\ge 0$, $f \\le 0$, and $\\dot{\\lambda} f = 0$. The consistency condition for plastic loading enforces $f(\\sigma_{n+1},\\alpha_{n+1}) = 0$.\n- Time discretization: Use an implicit (backward-Euler) update over a single step of size $\\Delta t$ (you may set $\\Delta t = 1$ without loss of generality for this uniaxial, rate-independent step). Over the step, the plastic strain increment is $\\Delta \\varepsilon^{p} = \\Delta \\lambda \\, \\mathrm{sign}(\\sigma_{n+1})$ with $\\Delta \\lambda \\ge 0$, and the hardening variable increment is $\\Delta \\alpha = \\Delta \\lambda$.\n\nTasks:\n\n- Starting only from the definitions above, derive a closed-form expression for the plastic multiplier increment $\\Delta \\lambda$ in a single uniaxial step in terms of $E$, $H$, $\\sigma_{y0}$, $\\alpha_{n}$, and $\\sigma^{\\mathrm{tr}}$. Do not assume any result beyond these definitions and the KKT/consistency framework.\n- Derive the corresponding updated stress $\\sigma_{n+1}$, plastic strain $\\varepsilon^{p}_{n+1}$, and hardening variable $\\alpha_{n+1}$ for both elastic and plastic cases, and characterize the elastic/plastic switch condition in terms of the trial state.\n- Implement two routes to compute $\\Delta \\lambda$:\n  - A closed-form route based on your derivation.\n  - A numerical route that enforces the discrete consistency condition $f(\\sigma_{n+1},\\alpha_{n+1}) = 0$ via a scalar Newton iteration on $\\Delta \\lambda$.\n- Use the numerical route to compute the end-of-step yield function value $f_{n+1} = f(\\sigma_{n+1},\\alpha_{n+1})$ and verify the consistency condition.\n\nPhysical units and output quantities:\n\n- Use the International System of Units (SI). Stresses $E$, $\\sigma$, $\\sigma_{y0}$, and $H$ are in $\\mathrm{Pa}$ (Pascals). Strains $\\varepsilon$, $\\varepsilon^{p}$, $\\alpha$, and $\\Delta \\lambda$ are dimensionless.\n- Your program must compute, for each test case:\n  - The closed-form plastic multiplier increment $\\Delta \\lambda_{\\mathrm{cf}}$ (dimensionless).\n  - The numerically obtained plastic multiplier increment $\\Delta \\lambda_{\\mathrm{num}}$ (dimensionless).\n  - The absolute difference $\\lvert \\Delta \\lambda_{\\mathrm{cf}} - \\Delta \\lambda_{\\mathrm{num}} \\rvert$ (dimensionless).\n  - The end-of-step yield function value $f_{n+1}$ in $\\mathrm{Pa}$.\n\nTest suite:\n\nProvide results for the following five cases, designed to cover elastic, boundary, plastic, hardening history, and compressive cases. In all cases, take the previous total strain to be $\\varepsilon_{n} = 0$.\n\n- Case A (strictly elastic): $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$, $H = 0\\ \\mathrm{Pa}$, $\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$, $\\varepsilon^{p}_{n} = 0$, $\\alpha_{n} = 0$, $\\Delta \\varepsilon = 1.0 \\times 10^{-4}$.\n- Case B (exactly at yield): $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$, $H = 0\\ \\mathrm{Pa}$, $\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$, $\\varepsilon^{p}_{n} = 0$, $\\alpha_{n} = 0$, $\\Delta \\varepsilon = 1.1904761904761905 \\times 10^{-3}$.\n- Case C (perfect plasticity beyond yield): $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$, $H = 0\\ \\mathrm{Pa}$, $\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$, $\\varepsilon^{p}_{n} = 0$, $\\alpha_{n} = 0$, $\\Delta \\varepsilon = 3.0 \\times 10^{-3}$.\n- Case D (isotropic hardening with prior history): $E = 2.00 \\times 10^{11}\\ \\mathrm{Pa}$, $H = 1.00 \\times 10^{9}\\ \\mathrm{Pa}$, $\\sigma_{y0} = 3.00 \\times 10^{8}\\ \\mathrm{Pa}$, $\\varepsilon^{p}_{n} = 4.0 \\times 10^{-4}$, $\\alpha_{n} = 6.0 \\times 10^{-4}$, $\\Delta \\varepsilon = 2.0 \\times 10^{-3}$.\n- Case E (compressive plasticity with hardening): $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$, $H = 2.00 \\times 10^{9}\\ \\mathrm{Pa}$, $\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$, $\\varepsilon^{p}_{n} = -2.0 \\times 10^{-4}$, $\\alpha_{n} = 2.0 \\times 10^{-4}$, $\\Delta \\varepsilon = -2.0 \\times 10^{-3}$.\n\nNumerical implementation requirements:\n\n- Use a scalar Newton method for the numerical route with a maximum of, for example, $k_{\\max} = 5$ iterations and a tolerance $\\tau = 10^{-12}$ on the residual of the consistency function. Initialize the Newton iteration with $\\Delta \\lambda^{(0)} = 0$.\n- For the elastic case you should detect that no plastic correction is needed and set $\\Delta \\lambda_{\\mathrm{cf}} = \\Delta \\lambda_{\\mathrm{num}} = 0$.\n- In all cases, ensure that the end-of-step yield function $f_{n+1}$ is computed with the updated stress and hardening variable, and report its value in $\\mathrm{Pa}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets. Each element should be a list with four entries in the order $[\\Delta \\lambda_{\\mathrm{cf}}, \\Delta \\lambda_{\\mathrm{num}}, \\lvert \\Delta \\lambda_{\\mathrm{cf}} - \\Delta \\lambda_{\\mathrm{num}} \\rvert, f_{n+1}]$. For example, a syntactically correct output looks like $[[a,b,c,d],[e,f,g,h],\\ldots]$ where each symbol is replaced by a floating-point number.", "solution": "The problem asks for the derivation and implementation of a return-mapping algorithm for a uniaxial small-strain elastoplastic model with linear isotropic hardening. This involves deriving a closed-form expression for the plastic multiplier increment, $\\Delta\\lambda$, and verifying it against a numerical solution that enforces the consistency condition via a Newton-Raphson scheme.\n\nFirst, we establish the governing equations in a time-discretized form suitable for a single load step from time $n$ to $n+1$. The model is rate-independent, so the step size is irrelevant. We use an implicit backward-Euler integration scheme.\n\nThe state at step $n$ is known: total strain $\\varepsilon_n$, plastic strain $\\varepsilon^p_n$, and accumulated plastic strain $\\alpha_n$. A total strain increment $\\Delta\\varepsilon$ is applied. The goal is to find the state at $n+1$: $\\sigma_{n+1}$, $\\varepsilon^p_{n+1}$, and $\\alpha_{n+1}$.\n\nThe discrete governing equations are:\n1.  Total strain at step $n+1$: $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon$.\n2.  Elastic constitutive law: $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1})$, where $E$ is the Young's modulus.\n3.  Plastic strain update (flow rule): $\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\varepsilon^p = \\varepsilon^p_n + \\Delta\\lambda \\, \\mathrm{sign}(\\sigma_{n+1})$. Here, $\\Delta\\lambda \\ge 0$ is the plastic multiplier increment.\n4.  Hardening variable update: $\\alpha_{n+1} = \\alpha_n + \\Delta\\alpha$. From $\\dot{\\alpha} = |\\dot{\\varepsilon}^p|$ and $\\dot{\\varepsilon}^p = \\dot{\\lambda} \\, \\mathrm{sign}(\\sigma)$, we have $\\dot{\\alpha} = \\dot{\\lambda} |\\mathrm{sign}(\\sigma)| = \\dot{\\lambda}$ (for $\\sigma \\ne 0$). The discrete update is $\\Delta\\alpha = \\Delta\\lambda$. Thus, $\\alpha_{n+1} = \\alpha_n + \\Delta\\lambda$.\n5.  Yield condition: The state must satisfy $f(\\sigma_{n+1}, \\alpha_{n+1}) \\le 0$, where the yield function is $f(\\sigma, \\alpha) = |\\sigma| - \\sigma_y(\\alpha)$ and the yield stress is $\\sigma_y(\\alpha) = \\sigma_{y0} + H\\alpha$. $H$ is the hardening modulus and $\\sigma_{y0}$ is the initial yield stress.\n6.  Karush-Kuhn-Tucker (KKT) conditions in discrete form: $\\Delta\\lambda \\ge 0$, $f_{n+1} \\le 0$, and the complementarity condition $\\Delta\\lambda f_{n+1} = 0$. This implies that if plastic flow occurs ($\\Delta\\lambda  0$), the final state must lie on the yield surface, i.e., $f_{n+1}=0$. This is the consistency condition.\n\nThe standard procedure for solving this system is the elastic-predictor, plastic-corrector algorithm.\n\n**1. Elastic Predictor**\n\nFirst, we assume the step is purely elastic, meaning $\\Delta\\lambda = 0$. This leads to a \"trial\" state.\n-   Plastic strain remains unchanged: $\\varepsilon^{p, \\mathrm{tr}} = \\varepsilon^p_n$.\n-   Hardening variable remains unchanged: $\\alpha^{\\mathrm{tr}} = \\alpha_n$.\n-   The trial stress is computed from the elastic law:\n    $$ \\sigma^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{p, \\mathrm{tr}}) = E(\\varepsilon_n + \\Delta\\varepsilon - \\varepsilon^p_n) $$\n-   We then check if this trial state is admissible by evaluating the yield function:\n    $$ f^{\\mathrm{tr}} = f(\\sigma^{\\mathrm{tr}}, \\alpha_n) = |\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n) $$\n\n**2. Elastic/Plastic Loading Condition**\n\nThe value of $f^{\\mathrm{tr}}$ determines the nature of the step:\n-   If $f^{\\mathrm{tr}} \\le 0$, the trial state is valid and lies within or on the elastic domain. The assumption of elastic behavior was correct. The step is elastic (or neutral loading if $f^{\\mathrm{tr}}=0$). The final state is the trial state:\n    $$ \\Delta\\lambda = 0 $$\n    $$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} $$\n    $$ \\varepsilon^p_{n+1} = \\varepsilon^p_n $$\n    $$ \\alpha_{n+1} = \\alpha_n $$\n-   If $f^{\\mathrm{tr}}  0$, the trial state is outside the elastic domain, which is physically inadmissible. The assumption of elastic behavior was incorrect, and plastic deformation must occur. We proceed to the plastic corrector step to enforce the consistency condition.\n\n**3. Plastic Corrector (Return Mapping)**\n\nFor a plastic step ($f^{\\mathrm{tr}}  0$), we must find a $\\Delta\\lambda  0$ such that the final state $(\\sigma_{n+1}, \\alpha_{n+1})$ satisfies the consistency condition $f_{n+1}=0$.\n\nThe updated stress $\\sigma_{n+1}$ can be related to the trial stress $\\sigma^{\\mathrm{tr}}$:\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^p_n + \\Delta\\varepsilon^p)) = E(\\varepsilon_{n+1} - \\varepsilon^p_n) - E\\Delta\\varepsilon^p $$\nRecognizing the first term as the trial stress, we have:\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\varepsilon^p $$\nSubstituting the flow rule $\\Delta\\varepsilon^p = \\Delta\\lambda\\,\\mathrm{sign}(\\sigma_{n+1})$:\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma_{n+1}) $$\nFor this uniaxial return mapping, the stress correction occurs along the direction opposite to the final stress, which lies on the same side of the origin as the trial stress. Thus, we can assert that $\\mathrm{sign}(\\sigma_{n+1}) = \\mathrm{sign}(\\sigma^{\\mathrm{tr}})$. This simplifies the stress update to:\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\nThe updated hardening variable is:\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\lambda $$\nNow, we impose the consistency condition $f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$:\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\nSubstitute the expressions for $\\sigma_{n+1}$ and $\\alpha_{n+1}$:\n$$ |\\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}})| - (\\sigma_{y0} + H(\\alpha_n + \\Delta\\lambda)) = 0 $$\nSince the return path reduces the magnitude of the stress from $|\\sigma^{\\mathrm{tr}}|$ to $|\\sigma_{n+1}|$, the term inside the absolute value has the same sign as $\\sigma^{\\mathrm{tr}}$. Thus, $|\\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}})| = |\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda$. The equation becomes:\n$$ (|\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda) - (\\sigma_{y0} + H\\alpha_n + H\\Delta\\lambda) = 0 $$\nWe can group terms to solve for $\\Delta\\lambda$:\n$$ (|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)) - (E + H)\\Delta\\lambda = 0 $$\nThe first parenthetical term is exactly the trial yield function, $f^{\\mathrm{tr}}$.\n$$ f^{\\mathrm{tr}} - (E + H)\\Delta\\lambda = 0 $$\nThis gives the closed-form expression for the plastic multiplier increment:\n$$ \\Delta\\lambda_{\\mathrm{cf}} = \\frac{f^{\\mathrm{tr}}}{E + H} $$\nSince $f^{\\mathrm{tr}}  0$, $E  0$, and $H \\ge 0$, it follows that $\\Delta\\lambda  0$, consistent with plastic loading.\n\nThe final updated state variables for a plastic step are:\n$$ \\Delta\\lambda = \\frac{|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)}{E+H} $$\n$$ \\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\lambda $$\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\n\n**4. Numerical Solution via Newton's Method**\n\nTo verify this result, we solve for $\\Delta\\lambda$ numerically by finding the root of the consistency equation. We define a residual function $R(\\Delta\\lambda)$ which represents the value of the yield function for a given $\\Delta\\lambda$:\n$$ R(\\Delta\\lambda) = |\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda - (\\sigma_{y0} + H\\alpha_n + H\\Delta\\lambda) $$\nSimplifying:\n$$ R(\\Delta\\lambda) = (|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)) - (E + H)\\Delta\\lambda = f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda $$\nThe Newton-Raphson iteration for finding the root of $R(\\Delta\\lambda)=0$ is:\n$$ \\Delta\\lambda^{(k+1)} = \\Delta\\lambda^{(k)} - \\frac{R(\\Delta\\lambda^{(k)})}{R'(\\Delta\\lambda^{(k)})} $$\nwhere $R'(\\Delta\\lambda)$ is the derivative of the residual with respect to $\\Delta\\lambda$:\n$$ R'(\\Delta\\lambda) = \\frac{d}{d(\\Delta\\lambda)} \\left[ f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda \\right] = -(E+H) $$\nThe derivative is constant. The update rule becomes:\n$$ \\Delta\\lambda^{(k+1)} = \\Delta\\lambda^{(k)} - \\frac{f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda^{(k)}}{-(E+H)} = \\Delta\\lambda^{(k)} + \\frac{f^{\\mathrm{tr}}}{E+H} - \\Delta\\lambda^{(k)} = \\frac{f^{\\mathrm{tr}}}{E+H} $$\nThis shows that for a linear hardening model, the Newton-Raphson method converges to the exact analytical solution in a single iteration, regardless of the initial guess. Our numerical implementation, starting with $\\Delta\\lambda^{(0)}=0$ and iterating as per the problem description, should yield a result identical to the closed-form solution, up to machine precision.\n\n**5. Verification and Final State Calculation**\n\nFor both elastic and plastic cases, after determining $\\Delta\\lambda$, we compute the final state $(\\sigma_{n+1}, \\alpha_{n+1})$ and evaluate the final yield function value $f_{n+1} = |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1})$. For an elastic step, $f_{n+1}$ will be less than or equal to $0$. For a plastic step, $f_{n+1}$ should be numerically zero, thus verifying that consistency is achieved. The program will compare the closed-form $\\Delta\\lambda_{\\mathrm{cf}}$ with the numerically computed $\\Delta\\lambda_{\\mathrm{num}}$ and report their absolute difference.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite for the uniaxial elastoplastic model.\n    \"\"\"\n\n    def compute_update(E, H, sig_y0, eps_p_n, alpha_n, delta_eps):\n        \"\"\"\n        Computes the state update for a single load step using both closed-form and numerical methods.\n\n        Args:\n            E (float): Young's modulus (Pa)\n            H (float): Hardening modulus (Pa)\n            sig_y0 (float): Initial yield stress (Pa)\n            eps_p_n (float): Plastic strain at step n\n            alpha_n (float): Hardening variable at step n\n            delta_eps (float): Total strain increment\n\n        Returns:\n            tuple: A tuple containing (delta_lambda_cf, delta_lambda_num, diff, f_n1)\n                   - delta_lambda_cf (float): Closed-form plastic multiplier increment.\n                   - delta_lambda_num (float): Numerical plastic multiplier increment.\n                   - diff (float): Absolute difference between cf and num values.\n                   - f_n1 (float): Yield function value at the end of the step (Pa).\n        \"\"\"\n        # Problem states all cases have eps_n = 0\n        eps_n = 0.0\n\n        # Step 1: Elastic Predictor\n        # Trial stress\n        sigma_tr = E * (eps_n + delta_eps - eps_p_n)\n        \n        # Current yield stress\n        sigma_y_n = sig_y0 + H * alpha_n\n        \n        # Trial yield function\n        f_tr = np.abs(sigma_tr) - sigma_y_n\n        \n        # Step 2: Elastic/Plastic Check\n        if f_tr = 0:\n            # Elastic step\n            delta_lambda_cf = 0.0\n            delta_lambda_num = 0.0\n            sigma_n1 = sigma_tr\n            alpha_n1 = alpha_n\n        else:\n            # Plastic step\n\n            # --- Closed-form route ---\n            delta_lambda_cf = f_tr / (E + H)\n\n            # --- Numerical route (Newton's method) ---\n            k_max = 5\n            tolerance = 1e-12\n            delta_lambda_k = 0.0  # Initial guess as per problem statement\n\n            for _ in range(k_max):\n                # Calculate residual R(delta_lambda)\n                residual = f_tr - (E + H) * delta_lambda_k\n                \n                if np.abs(residual)  tolerance:\n                    break\n                \n                # Calculate Jacobian (derivative of R)\n                jacobian = -(E + H)\n                \n                # Newton update\n                delta_lambda_k -= residual / jacobian\n            \n            delta_lambda_num = delta_lambda_k\n            \n            # --- Calculate final state using the numerical result for verification ---\n            sign_sigma_tr = np.sign(sigma_tr)\n            sigma_n1 = sigma_tr - E * delta_lambda_num * sign_sigma_tr\n            alpha_n1 = alpha_n + delta_lambda_num\n\n        # Step 5: Verification\n        # Calculate final yield function value\n        f_n1 = np.abs(sigma_n1) - (sig_y0 + H * alpha_n1)\n\n        # Calculate absolute difference between analytical and numerical solutions\n        diff = np.abs(delta_lambda_cf - delta_lambda_num)\n        \n        return delta_lambda_cf, delta_lambda_num, diff, f_n1\n\n\n    test_cases = [\n        # Case A: strictly elastic\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 1.0e-4},\n        # Case B: exactly at yield\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 1.1904761904761905e-3},\n        # Case C: perfect plasticity beyond yield\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 3.0e-3},\n        # Case D: isotropic hardening with prior history\n        {'E': 2.00e11, 'H': 1.00e9, 'sig_y0': 3.00e8, 'eps_p_n': 4.0e-4, 'alpha_n': 6.0e-4, 'delta_eps': 2.0e-3},\n        # Case E: compressive plasticity with hardening\n        {'E': 2.10e11, 'H': 2.00e9, 'sig_y0': 2.50e8, 'eps_p_n': -2.0e-4, 'alpha_n': 2.0e-4, 'delta_eps': -2.0e-3}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_update(**case)\n        # Format numbers to be easily representable\n        formatted_result = [f\"{x:.8e}\" for x in result]\n        results.append(str(formatted_result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3550975"}, {"introduction": "Moving beyond simple models, most realistic material laws, such as $J_2$ plasticity with nonlinear hardening, do not permit a closed-form solution for the plastic multiplier. In these cases, a robust numerical solver is essential. This practice [@problem_id:3550995] focuses on developing a Newton-Raphson iterative scheme to solve the scalar nonlinear consistency equation that arises from a combined Voce-plus-linear hardening law. You will derive the necessary residual function and its derivative (the algorithmic tangent) and implement a robust iterative procedure, a core skill for any developer of computational plasticity software.", "problem": "Consider small-strain, isotropic, associative plasticity governed by the second invariant of the deviatoric stress (J2) plasticity with linear elasticity. Let $G$ denote the shear modulus, let $\\boldsymbol{s}$ denote the deviatoric stress, and let the von Mises equivalent stress be defined by $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}} \\, \\| \\boldsymbol{s} \\|$. The elastic predictor returns the trial deviatoric stress $\\boldsymbol{s}^{\\mathrm{tr}}$ and the corresponding trial equivalent stress $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$. For an associative flow rule, the plastic strain increment is $ \\Delta \\varepsilon^{p} = \\Delta \\lambda \\, \\frac{\\partial \\Phi}{\\partial \\sigma}$ with the yield function $\\Phi(\\sigma, \\kappa) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(\\kappa)$, where $\\kappa$ is the accumulated (equivalent) plastic strain and $\\sigma_{y}$ is the current yield stress.\n\nUnder the standard radial return mapping assumption for J2 plasticity, the plastic correction preserves the direction of the deviatoric stress and the magnitude update reads\n$$\n\\sigma_{\\mathrm{eq}}^{n+1} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda,\n$$\nand the internal variable update is\n$$\n\\kappa_{n+1} = \\kappa_{n} + \\Delta \\lambda.\n$$\nAssume combined isotropic hardening of Voce plus linear type,\n$$\n\\sigma_{y}(\\kappa) = \\sigma_{y0} + H \\, \\kappa + Q \\left( 1 - e^{-b \\kappa} \\right),\n$$\nwhere $\\sigma_{y0}$ is the initial yield stress, $H$ is the linear hardening modulus, $Q$ and $b$ are Voce parameters, and $\\kappa$ is the accumulated plastic strain.\n\nThe consistency condition enforces $\\Phi(\\sigma_{n+1}, \\kappa_{n+1}) = 0$ whenever plastic loading occurs, which leads to a scalar nonlinear equation for the plastic multiplier increment $\\Delta \\lambda$:\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}\\left( \\kappa_{n} + \\Delta \\lambda \\right) = 0,\n$$\nsubject to the loading/unloading condition: if $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y}(\\kappa_{n}) \\le 0$, then $\\Delta \\lambda = 0$ (elastic step). Otherwise, $\\Delta \\lambda  0$ solves the above equation.\n\nTask: Derive from first principles the Newton-Raphson (NR) iteration scheme for solving the scalar equation $r(\\Delta \\lambda) = 0$ for $\\Delta \\lambda$, including an explicit expression for the derivative $\\frac{dr}{d(\\Delta \\lambda)}$ in terms of the material parameters and state variables, and implement a robust algorithm that\n- detects elastic steps ($\\Delta \\lambda = 0$ if $r(0) \\le 0$),\n- otherwise solves the nonlinear equation with a safeguarded Newton-Raphson method confined to a physically justified bracket,\n- returns the converged $\\Delta \\lambda$ for each test case.\n\nAll stresses must be treated in Pascals ($\\mathrm{Pa}$). The strain-like quantities $\\Delta \\lambda$ and $\\kappa$ are dimensionless. Angles do not appear in this problem. Your final program must compute and output $\\Delta \\lambda$ for the following test suite, each test case provided as $(G, \\sigma_{y0}, H, Q, b, \\kappa_{n}, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}})$:\n\n- Test $1$ (general nonlinear hardening, \"happy path\"): $(80 \\times 10^{9}, 250 \\times 10^{6}, 1.0 \\times 10^{9}, 450 \\times 10^{6}, 20, 0.02, 800 \\times 10^{6})$.\n- Test $2$ (elastic step boundary): $(80 \\times 10^{9}, 250 \\times 10^{6}, 1.0 \\times 10^{9}, 450 \\times 10^{6}, 20, 0.05, 500 \\times 10^{6})$.\n- Test $3$ (pure linear hardening): $(80 \\times 10^{9}, 250 \\times 10^{6}, 1.5 \\times 10^{9}, 0, 10, 0.0, 600 \\times 10^{6})$.\n- Test $4$ (strong initial nonlinearity due to large $b$): $(80 \\times 10^{9}, 200 \\times 10^{6}, 0.5 \\times 10^{9}, 300 \\times 10^{6}, 200, 0.005, 700 \\times 10^{6})$.\n- Test $5$ (lower shear modulus): $(30 \\times 10^{9}, 150 \\times 10^{6}, 0, 350 \\times 10^{6}, 5, 0.0, 400 \\times 10^{6})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\Delta\\lambda_{1},\\Delta\\lambda_{2},\\Delta\\lambda_{3},\\Delta\\lambda_{4},\\Delta\\lambda_{5}]$). Each entry must be a decimal (floating-point) number representing the computed $\\Delta \\lambda$ for the corresponding test case, in dimensionless units.", "solution": "The problem is valid as it is scientifically grounded in the principles of computational plasticity, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe core of the problem is to solve the scalar nonlinear consistency equation for the plastic multiplier increment, $\\Delta \\lambda$, which arises in the return mapping algorithm for J2 plasticity with combined isotropic hardening. The equation to be solved is $r(\\Delta \\lambda) = 0$, where the residual function $r(\\Delta \\lambda)$ is given by:\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}\\left( \\kappa_{n} + \\Delta \\lambda \\right)\n$$\nThis equation must be solved subject to the Karush-Kuhn-Tucker (KKT) conditions: $\\Delta \\lambda \\ge 0$, $r(\\Delta \\lambda) \\le 0$ for $\\Delta\\lambda=0$, and $r(\\Delta \\lambda) \\Delta\\lambda = 0$ is not a formulation used here but the a simpler one, which is $\\Phi \\le 0$, $\\Delta\\lambda \\ge 0$ and $\\Phi \\Delta\\lambda = 0$. The given loading/unloading condition is a practical implementation of this: if $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\kappa_n) \\le 0$, the state is elastic or neutral loading, so $\\Delta \\lambda = 0$. Otherwise, plastic loading occurs, $\\Delta \\lambda  0$, and the consistency condition $r(\\Delta \\lambda) = 0$ must be enforced.\n\nThe hardening law is specified as a combined Voce plus linear model:\n$$\n\\sigma_{y}(\\kappa) = \\sigma_{y0} + H \\, \\kappa + Q \\left( 1 - e^{-b \\kappa} \\right)\n$$\nwhere $\\kappa_n$ is the accumulated plastic strain from the previous converged time step. The updated accumulated plastic strain is $\\kappa_{n+1} = \\kappa_{n} + \\Delta \\lambda$. Substituting this into the residual function yields the explicit form:\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\left[ \\sigma_{y0} + H(\\kappa_{n} + \\Delta \\lambda) + Q \\left( 1 - e^{-b(\\kappa_{n} + \\Delta \\lambda)} \\right) \\right]\n$$\n\nTo solve $r(\\Delta \\lambda) = 0$ for $\\Delta \\lambda  0$, we employ the Newton-Raphson (NR) method. The iterative update scheme is:\n$$\n\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - \\frac{r(\\Delta \\lambda_k)}{r'(\\Delta \\lambda_k)}\n$$\nwhere $\\Delta \\lambda_k$ is the estimate at iteration $k$, and $r'(\\Delta \\lambda_k) = \\frac{dr}{d(\\Delta \\lambda)}\\big|_{\\Delta \\lambda = \\Delta \\lambda_k}$.\n\nWe must first compute the derivative of the residual function with respect to $\\Delta \\lambda$. Differentiating $r(\\Delta \\lambda)$ term by term:\n$$\n\\frac{dr}{d(\\Delta \\lambda)} = \\frac{d}{d(\\Delta \\lambda)} \\left( \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} \\right) - \\frac{d}{d(\\Delta \\lambda)} \\left( 3 G \\, \\Delta \\lambda \\right) - \\frac{d}{d(\\Delta \\lambda)} \\left( \\sigma_{y}(\\kappa_n + \\Delta \\lambda) \\right)\n$$\nThe first term is a constant and its derivative is $0$. The second term's derivative is $-3G$. For the third term, we use the chain rule:\n$$\n\\frac{d}{d(\\Delta \\lambda)} \\sigma_{y}(\\kappa_n + \\Delta \\lambda) = \\frac{d\\sigma_y}{d\\kappa}\\bigg|_{\\kappa = \\kappa_n + \\Delta \\lambda} \\cdot \\frac{d(\\kappa_n + \\Delta \\lambda)}{d(\\Delta \\lambda)} = \\frac{d\\sigma_y}{d\\kappa}\\bigg|_{\\kappa = \\kappa_n + \\Delta \\lambda} \\cdot 1\n$$\nThe derivative of the yield stress function $\\sigma_y(\\kappa)$ is the tangent hardening modulus, $H_{\\mathrm{tan}}(\\kappa)$:\n$$\nH_{\\mathrm{tan}}(\\kappa) = \\frac{d\\sigma_y}{d\\kappa} = \\frac{d}{d\\kappa} \\left( \\sigma_{y0} + H \\kappa + Q (1 - e^{-b \\kappa}) \\right) = H + Q(-e^{-b\\kappa})(-b) = H + Q b e^{-b\\kappa}\n$$\nThus, the derivative of the residual is:\n$$\nr'(\\Delta \\lambda) = -3G - \\left( H + Q b \\, e^{-b(\\kappa_n + \\Delta \\lambda)} \\right) = -\\left( 3G + H_{\\mathrm{tan}}(\\kappa_n + \\Delta \\lambda) \\right)\n$$\nFor physically realistic materials, $G  0$, $H \\ge 0$, $Q \\ge 0$, and $b  0$, which ensures that $r'(\\Delta \\lambda)$ is always negative. This means $r(\\Delta \\lambda)$ is a monotonically decreasing function, guaranteeing a unique root for $\\Delta \\lambda  0$ when $r(0)  0$.\n\nThe full Newton-Raphson update for $\\Delta \\lambda$ is:\n$$\n\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\frac{ \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\Delta \\lambda_k - \\sigma_{y}(\\kappa_n + \\Delta \\lambda_k) }{ 3G + H + Q b \\, e^{-b(\\kappa_n + \\Delta \\lambda_k)} }\n$$\n\nA robust algorithm is implemented as follows:\n1.  **Elastic-Plastic Check**: First, evaluate the initial residual $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\kappa_n)$. If $r(0) \\le 0$, the step is elastic, and the solution is $\\Delta \\lambda = 0$.\n2.  **Bracketing**: If $r(0)  0$ (plastic step), a root must be found. Since $r(\\Delta \\lambda)$ is monotonic, we can robustly bracket the root. The lower bound is $\\lambda_a = 0$, where $r(\\lambda_a)  0$. An upper bound $\\lambda_b$ can be established by considering the case of perfect plasticity starting from the trial stress, which gives $3G\\Delta\\lambda \\approx \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$. A safe upper bound that guarantees $r(\\lambda_b)  0$ is $\\lambda_b = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}{3G}$, because at this point $r(\\lambda_b) = -\\sigma_y(\\kappa_n+\\lambda_b)$, which is always negative for positive yield stress. The solution is thus bracketed in $[0, \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}{3G}]$.\n3.  **Safeguarded Iteration**: The NR iteration begins with an initial guess, e.g., $\\Delta \\lambda_0 = 0$.\n    - At each iteration $k$, a new estimate $\\Delta \\lambda_{k+1}$ is computed using the NR formula.\n    - To ensure robustness, a safeguard is employed. If the NR update $\\Delta \\lambda_{k+1}$ falls outside the current bracket $[\\lambda_a, \\lambda_b]$, the update is rejected, and a more conservative bisection step, $\\Delta \\lambda_{k+1} = (\\lambda_a + \\lambda_b)/2$, is taken instead.\n    - After each step, the bracket is updated based on the sign of $r(\\Delta \\lambda_{k+1})$. If $r(\\Delta \\lambda_{k+1})  0$, the lower bound is updated: $\\lambda_a = \\Delta \\lambda_{k+1}$. Otherwise, the upper bound is updated: $\\lambda_b = \\Delta \\lambda_{k+1}$.\n4.  **Convergence**: The iteration continues until the magnitude of the residual, $|r(\\Delta \\lambda_k)|$, falls below a prescribed tolerance (e.g., $1.0 \\, \\mathrm{Pa}$), or a maximum number of iterations is reached.\nThis combination of a fast-converging local method (NR) with a globally convergent but slower method (bisection) provides a robust and efficient algorithm for solving the consistency condition.", "answer": "```python\nimport numpy as np\n\ndef compute_delta_lambda(G, sigma_y0, H, Q, b, kappa_n, sigma_eq_tr):\n    \"\"\"\n    Computes the plastic multiplier increment Delta_lambda for J2 plasticity\n    with combined isotropic hardening using a safeguarded Newton-Raphson method.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        sigma_y0 (float): Initial yield stress (Pa).\n        H (float): Linear hardening modulus (Pa).\n        Q (float): Voce hardening saturation stress (Pa).\n        b (float): Voce hardening exponent (dimensionless).\n        kappa_n (float): Accumulated plastic strain at step n (dimensionless).\n        sigma_eq_tr (float): Trial equivalent stress (Pa).\n\n    Returns:\n        float: The converged plastic multiplier increment Delta_lambda.\n    \"\"\"\n\n    # For better numerical stability with small arguments, use expm1.\n    # sigma_y = sigma_y0 + H*k + Q*(1 - exp(-b*k)) = sigma_y0 + H*k - Q*(exp(-b*k) - 1)\n    # The term is -Q*expm1(-b*k).\n    def get_sigma_y(kappa):\n        if b * kappa  0:\n            return sigma_y0 + H * kappa - Q * np.expm1(-b * kappa)\n        else: # Handles b=0 or kappa=0 case without precision loss\n            return sigma_y0 + H * kappa\n\n    def get_residual(delta_lambda):\n        if delta_lambda  0:\n            # Physically, delta_lambda must be non-negative\n            return np.inf\n        kappa_np1 = kappa_n + delta_lambda\n        sigma_y_np1 = get_sigma_y(kappa_np1)\n        return sigma_eq_tr - 3.0 * G * delta_lambda - sigma_y_np1\n\n    def get_residual_derivative(delta_lambda):\n        kappa_np1 = kappa_n + delta_lambda\n        # Tangent hardening modulus d(sigma_y)/d(kappa)\n        d_sigma_y_d_kappa = H + Q * b * np.exp(-b * kappa_np1)\n        return -3.0 * G - d_sigma_y_d_kappa\n\n    # Step 1: Elastic-Plastic Check\n    residual_at_zero = get_residual(0.0)\n\n    if residual_at_zero = 1e-9: # Add small tolerance for floating point comparisons\n        return 0.0\n\n    # Step 2: Setup for Newton-Raphson (Plastic Step)\n    delta_lambda = 0.0  # Initial guess\n\n    # Define a robust bracket for the safeguarded method\n    lambda_min = 0.0\n    lambda_max = sigma_eq_tr / (3.0 * G)\n\n    TOL = 1.0  # Absolute tolerance on the residual in Pascals\n    MAX_ITER = 50\n\n    for _ in range(MAX_ITER):\n        res = get_residual(delta_lambda)\n\n        if abs(res)  TOL:\n            break\n\n        deriv = get_residual_derivative(delta_lambda)\n        if deriv == 0:\n            # Algorithm should not get here with physical parameters\n            # Fallback to bisection\n            delta_lambda = (lambda_min + lambda_max) / 2.0\n            continue\n        \n        # Step 3: Compute Newton-Raphson update\n        update = -res / deriv\n        delta_lambda_next = delta_lambda + update\n\n        # Step 4: Safeguard - fall back to bisection if NR step is out of bounds\n        if not (lambda_min = delta_lambda_next = lambda_max):\n            delta_lambda_next = (lambda_min + lambda_max) / 2.0\n            \n        delta_lambda = delta_lambda_next\n\n        # Step 5: Update the bracket for the next iteration\n        if get_residual(delta_lambda)  0:\n            lambda_min = delta_lambda\n        else:\n            lambda_max = delta_lambda\n            \n    return delta_lambda\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (G, sigma_y0, H, Q, b, kappa_n, sigma_eq_tr)\n    test_cases = [\n        (80e9, 250e6, 1.0e9, 450e6, 20, 0.02, 800e6), # General nonlinear hardening\n        (80e9, 250e6, 1.0e9, 450e6, 20, 0.05, 500e6), # Elastic step boundary\n        (80e9, 250e6, 1.5e9, 0, 10, 0.0, 600e6),      # Pure linear hardening\n        (80e9, 200e6, 0.5e9, 300e6, 200, 0.005, 700e6),# Strong initial nonlinearity\n        (30e9, 150e6, 0, 350e6, 5, 0.0, 400e6),      # Lower shear modulus\n    ]\n\n    results = []\n    for params in test_cases:\n        delta_lambda_result = compute_delta_lambda(*params)\n        results.append(str(delta_lambda_result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3550995"}, {"introduction": "The standard Newton-Raphson method, while powerful, can fail to converge when the underlying mathematical problem is not well-behaved. Such challenges frequently arise in models that include material softening, where the tangent modulus $H$ becomes negative, leading to a non-convex optimization landscape. This advanced practice [@problem_id:3550930] explores this critical failure mode and introduces a powerful globalization strategy—the line-search method—to ensure the solver finds a valid solution. By comparing a pure Newton method with a line-search-augmented version, you will gain practical insight into developing robust constitutive drivers capable of handling complex material behaviors.", "problem": "Consider a small-strain, isotropic, rate-independent von Mises plasticity model with isotropic hardening/softening. The yield function is defined as $f(\\boldsymbol{\\sigma},p) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(p)$, where $\\sigma_{\\mathrm{eq}}$ is the von Mises equivalent stress and $\\sigma_{y}(p)$ is the current yield stress as a function of the accumulated equivalent plastic strain $p$. Over a single load increment, the standard elastic predictor–plastic corrector (return mapping) procedure introduces a plastic multiplier increment $\\Delta \\lambda \\ge 0$ and enforces the consistency condition $f=0$ at the end of the step. Under the radial return assumption for von Mises plasticity, the consistency condition reduces to a scalar nonlinear equation in the unknown $\\Delta \\lambda$:\n$$\nr(\\Delta \\lambda) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}(p_n + \\Delta \\lambda) = 0,\n$$\nwhere $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$ is the elastic trial equivalent stress computed from the total strain increment, $G$ is the shear modulus, and $p_n$ is the accumulated equivalent plastic strain at the beginning of the step. Treat all quantities as nondimensional.\n\nIn this problem, the isotropic hardening/softening law is chosen to be non-convex, of the form\n$$\n\\sigma_{y}(p) = \\sigma_{y0} + A \\, p - C \\, p^3,\n$$\nwith parameters $A  0$ and $C  0$, so that the instantaneous hardening modulus is\n$$\nH(p) := \\frac{d \\sigma_{y}}{d p} = A - 3 C p^2,\n$$\nwhich can be negative for sufficiently large $p$ (softening regime with $H(p)  0$). This choice produces a non-convex stored energy landscape and can challenge standard iterative solvers.\n\nYour tasks are:\n1) Starting from the consistency condition $r(\\Delta \\lambda)=0$ above and the given $\\sigma_{y}(p)$, derive expressions for the residual $r(\\Delta \\lambda)$ and its derivative $r'(\\Delta \\lambda)$ with respect to $\\Delta \\lambda$.\n2) Propose a merit function $\\phi(\\Delta \\lambda)$ based on the residual norm and derive the Armijo backtracking line-search sufficient decrease condition specialized to this one-dimensional problem.\n3) Implement and compare two solvers for $\\Delta \\lambda$:\n   - A pure Newton method that updates $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$, with the constraint $\\Delta \\lambda \\ge 0$ enforced by clamping to $0$ if an update attempts to violate non-negativity.\n   - A line-search augmented Newton method that uses the same Newton direction $s_k = - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$ but chooses a step length $\\alpha_k \\in (0,1]$ via backtracking to satisfy the Armijo condition with the proposed merit function. Enforce the constraint $\\Delta \\lambda \\ge 0$ by limiting the step length if necessary so that $\\Delta \\lambda_{k} + \\alpha_k s_k \\ge 0$.\nBoth methods should start from the initial guess $\\Delta \\lambda_0 = 0$ and iterate until either $\\lvert r(\\Delta \\lambda_k) \\rvert \\le \\text{tol}$ or a maximum number of iterations is reached. Use $\\text{tol} = 10^{-10}$ and $\\text{max\\_iters} = 50$. For the line search, use an Armijo parameter $c = 10^{-4}$ and a backtracking factor $\\beta = 1/2$.\n\nDerivations must begin from the consistency condition and the definition of the hardening law. Do not assume any specialized shortcut formulas beyond these definitions. Clearly justify how the line search condition is specialized in one dimension.\n\nImplement your solution as a program that computes, for each test case, the final values produced by both solvers together with convergence flags. If a method fails to converge within the iteration limit, return the last iterate for $\\Delta \\lambda$ and a boolean flag indicating lack of convergence. Treat all quantities as nondimensional; no physical units are required.\n\nTest suite:\nProvide results for the following four parameter sets $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C)$:\n- Case $1$ (happy path with mild softening): $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (1000.0, \\, 350.0, \\, 250.0, \\, 0.0, \\, 150.0, \\, 500.0)$.\n- Case $2$ (strong softening, possible non-monotonic residual): $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (200.0, \\, 310.0, \\, 300.0, \\, 0.2, \\, 50.0, \\, 1200.0)$.\n- Case $3$ (near-yield boundary, very small overstress): $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (1000.0, \\, 250.0001, \\, 250.0, \\, 0.0, \\, 100.0, \\, 800.0)$.\n- Case $4$ (extreme softening and multiple extrema of the residual): $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (150.0, \\, 280.0, \\, 260.0, \\, 0.05, \\, 20.0, \\, 5000.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing a list of entries, one per test case, where each entry is the list $[\\Delta \\lambda_{\\mathrm{Newton}}, \\, \\Delta \\lambda_{\\mathrm{LS}}, \\, \\text{conv}_{\\mathrm{Newton}}, \\, \\text{conv}_{\\mathrm{LS}}]$. Here $\\Delta \\lambda_{\\mathrm{Newton}}$ is the final value from the pure Newton solver, $\\Delta \\lambda_{\\mathrm{LS}}$ is the final value from the line-search Newton solver, and the convergence flags are boolean values. The output must be printed as a single bracketed list with comma-separated entries and no spaces, for example: $[[x_1,y_1,\\mathrm{True},\\mathrm{False}],[x_2,y_2,\\mathrm{True},\\mathrm{True}],\\dots]$. Ensure that the printed numbers are standard decimal representations.", "solution": "The problem poses a well-defined task in computational solid mechanics, requiring the numerical solution of a scalar nonlinear equation that arises from the consistency condition in rate-independent plasticity. The material model features a non-convex hardening/softening law, which introduces numerical challenges that the problem is designed to investigate by comparing a standard Newton-Raphson solver with a more robust line-search-augmented version. The problem is scientifically grounded, self-contained, and all parameters are clearly specified. It is therefore deemed valid.\n\nThe solution is presented in three parts, as requested: derivation of the residual and its derivative, formulation of the merit function and line search condition, and a description of the implemented algorithms.\n\n### 1. Derivation of the Residual and its Derivative\n\nThe core of the problem is to solve the scalar consistency condition for the plastic multiplier increment $\\Delta \\lambda$:\n$$\nr(\\Delta \\lambda) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}(p_n + \\Delta \\lambda) = 0\n$$\nwhere $\\Delta \\lambda \\ge 0$. A plastic step is considered only if the elastic trial state violates the yield condition, i.e., $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}  \\sigma_{y}(p_n)$. If this condition is not met, the step is elastic, and the solution is trivially $\\Delta \\lambda = 0$. For all test cases provided, $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}  \\sigma_{y}(p_n)$, so a non-zero $\\Delta \\lambda$ is expected.\n\nThe accumulated equivalent plastic strain at the end of the step is $p = p_{n+1} = p_n + \\Delta p$. For rate-independent plasticity, the increment of accumulated plastic strain is identical to the plastic multiplier increment, $\\Delta p = \\Delta \\lambda$. Thus, $p = p_n + \\Delta \\lambda$.\n\nThe specified isotropic hardening/softening law is:\n$$\n\\sigma_{y}(p) = \\sigma_{y0} + A \\, p - C \\, p^3\n$$\nSubstituting $p = p_n + \\Delta \\lambda$ into this law and then into the consistency condition gives the full expression for the residual function $r(\\Delta \\lambda)$:\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\left( \\sigma_{y0} + A (p_n + \\Delta \\lambda) - C (p_n + \\Delta \\lambda)^3 \\right)\n$$\nThis is the function for which we need to find the root $\\Delta \\lambda \\ge 0$.\n\nFor Newton's method, we require the derivative of the residual function, $r'(\\Delta \\lambda) = \\frac{d r}{d (\\Delta \\lambda)}$. We differentiate the expression for $r(\\Delta \\lambda)$ with respect to $\\Delta \\lambda$, treating $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$, $G$, $\\sigma_{y0}$, $A$, $C$, and $p_n$ as constants for the current increment.\n$$\nr'(\\Delta \\lambda) = \\frac{d}{d (\\Delta \\lambda)} \\left( \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} \\right) - \\frac{d}{d (\\Delta \\lambda)} \\left( 3 G \\, \\Delta \\lambda \\right) - \\frac{d}{d (\\Delta \\lambda)} \\left( \\sigma_{y}(p_n + \\Delta \\lambda) \\right)\n$$\n$$\nr'(\\Delta \\lambda) = 0 - 3 G - \\frac{d \\sigma_y}{d p} \\bigg|_{p=p_n+\\Delta \\lambda} \\cdot \\frac{d (p_n + \\Delta \\lambda)}{d (\\Delta \\lambda)}\n$$\nThe derivative of the yield stress with respect to the accumulated plastic strain is the instantaneous hardening modulus, $H(p) = \\frac{d \\sigma_y}{d p}$. From the given law:\n$$\nH(p) = \\frac{d}{d p} (\\sigma_{y0} + A \\, p - C \\, p^3) = A - 3 C p^2\n$$\nEvaluating this at $p = p_n + \\Delta \\lambda$ yields $H(p_n + \\Delta \\lambda) = A - 3 C (p_n + \\Delta \\lambda)^2$.\nSubstituting this back into the expression for $r'(\\Delta \\lambda)$:\n$$\nr'(\\Delta \\lambda) = -3G - H(p_n + \\Delta \\lambda) = -3G - \\left( A - 3 C (p_n + \\Delta \\lambda)^2 \\right)\n$$\n$$\nr'(\\Delta \\lambda) = -3G - A + 3 C (p_n + \\Delta \\lambda)^2\n$$\nThis final expression is the algorithmic consistent tangent, which is crucial for the quadratic convergence of Newton's method. Note that for large $p$, $H(p)$ can become negative (softening), which can lead to $r'(\\Delta \\lambda)$ changing sign or approaching zero, a source of potential failure for the pure Newton method.\n\n### 2. Merit Function and Armijo Line Search Condition\n\nTo improve the robustness of Newton's method, particularly for non-convex problems, a line search is employed to ensure that each iteration makes sufficient progress towards the solution. This is achieved by minimizing a merit function. A standard choice for a root-finding problem $r(x)=0$ is the squared norm of the residual, which in this one-dimensional case is:\n$$\n\\phi(\\Delta \\lambda) = \\frac{1}{2} r(\\Delta \\lambda)^2\n$$\nThe Newton update at iteration $k$ is $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\alpha_k s_k$, where $s_k = -r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$ is the search direction and $\\alpha_k \\in (0,1]$ is the step length determined by the line search.\n\nThe Armijo sufficient decrease condition requires that the reduction in the merit function is at least a fraction of the reduction predicted by a first-order Taylor expansion. The general form is $\\phi(\\mathbf{x}_k + \\alpha_k \\mathbf{s}_k) \\le \\phi(\\mathbf{x}_k) + c \\, \\alpha_k \\, \\nabla \\phi(\\mathbf{x}_k)^T \\mathbf{s}_k$.\n\nFor our 1D problem, the gradient $\\nabla \\phi$ is the derivative $\\phi'(\\Delta \\lambda)$:\n$$\n\\phi'(\\Delta \\lambda) = \\frac{d}{d(\\Delta \\lambda)} \\left( \\frac{1}{2} r(\\Delta \\lambda)^2 \\right) = r(\\Delta \\lambda) r'(\\Delta \\lambda)\n$$\nThe directional derivative at $\\Delta \\lambda_k$ along $s_k$ is:\n$$\n\\phi'(\\Delta \\lambda_k) s_k = \\left( r(\\Delta \\lambda_k) r'(\\Delta \\lambda_k) \\right) \\left( -\\frac{r(\\Delta \\lambda_k)}{r'(\\Delta \\lambda_k)} \\right) = -r(\\Delta \\lambda_k)^2\n$$\nThis demonstrates that the Newton direction $s_k$ is always a descent direction for the chosen merit function $\\phi$, as long as $r(\\Delta \\lambda_k) \\neq 0$.\n\nThe Armijo condition at iteration $k$ thus becomes:\n$$\n\\phi(\\Delta \\lambda_k + \\alpha_k s_k) \\le \\phi(\\Delta \\lambda_k) + c \\, \\alpha_k \\left( -r(\\Delta \\lambda_k)^2 \\right)\n$$\nSubstituting the definition of $\\phi$:\n$$\n\\frac{1}{2} r(\\Delta \\lambda_k + \\alpha_k s_k)^2 \\le \\frac{1}{2} r(\\Delta \\lambda_k)^2 - c \\, \\alpha_k \\, r(\\Delta \\lambda_k)^2\n$$\nwhere $c=10^{-4}$ is the specified Armijo parameter.\n\nThe backtracking algorithm to find a suitable $\\alpha_k$ is:\n1. Initialize $\\alpha_k = 1$.\n2. In a loop, check if the trial step is valid:\n   a. Check physical constraint: $\\Delta\\lambda_{\\text{trial}} = \\Delta \\lambda_k + \\alpha_k s_k \\ge 0$.\n   b. Check Armijo condition: $\\frac{1}{2} r(\\Delta\\lambda_{\\text{trial}})^2 \\le (\\frac{1}{2} - c \\, \\alpha_k) r(\\Delta \\lambda_k)^2$.\n3. If either check fails, reduce the step length, $\\alpha_k \\leftarrow \\beta \\alpha_k$ (with $\\beta=1/2$), and repeat.\n4. Once a valid $\\alpha_k$ is found, accept the update.\n\n### 3. Solver Implementation\n\nTwo solvers are implemented as per the problem description. Both start with $\\Delta \\lambda_0 = 0$ and iterate until $|r(\\Delta \\lambda_k)| \\le 10^{-10}$ or a maximum of $50$ iterations is reached.\n\n**Pure Newton Solver:**\nAt each iteration $k$, the update is computed as $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$. The non-negativity constraint $\\Delta \\lambda \\ge 0$ is enforced by \"clamping\": $\\Delta \\lambda_{k+1} = \\max(0, \\Delta \\lambda_{k+1})$. This ad-hoc approach can be fast but may lead to oscillations or failure to converge, especially if the algorithm overshoots into a region where $r'(\\Delta \\lambda)$ is ill-behaved.\n\n**Line-Search Augmented Newton Solver:**\nThis solver uses the same Newton direction $s_k = -r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$ but employs the backtracking algorithm described above to find a step length $\\alpha_k$ that satisfies both the Armijo condition and the physical constraint $\\Delta \\lambda \\ge 0$. The update is $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\alpha_k s_k$. This globalization strategy makes the method more robust and likely to converge even when starting far from the solution or when the residual function $r(\\Delta \\lambda)$ is not monotonic.\n\nFor both solvers, an initial check is performed: if $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(p_n) \\le 0$, the step is elastic, so we immediately return $\\Delta \\lambda = 0$ with a convergence status of true.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the solvers on all test cases and print results.\n    \"\"\"\n    \n    # Solver parameters\n    tol = 1e-10\n    max_iters = 50\n    # Line search parameters\n    c_armijo = 1e-4\n    beta_bt = 0.5\n    \n    test_cases = [\n        # (G, sig_eq_tr, sig_y0, p_n, A, C)\n        (1000.0, 350.0, 250.0, 0.0, 150.0, 500.0),    # Case 1\n        (200.0, 310.0, 300.0, 0.2, 50.0, 1200.0),     # Case 2\n        (1000.0, 250.0001, 250.0, 0.0, 100.0, 800.0), # Case 3\n        (150.0, 280.0, 260.0, 0.05, 20.0, 5000.0),    # Case 4\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        dl_newton, conv_newton = solve_newton(params, tol, max_iters)\n        dl_ls, conv_ls = solve_linesearch_newton(params, tol, max_iters, c_armijo, beta_bt)\n        \n        all_results.append([dl_newton, dl_ls, conv_newton, conv_ls])\n\n    # Format the output string as per requirements (no spaces)\n    formatted_results = []\n    for res_list in all_results:\n        # Correctly format booleans as 'True' or 'False'\n        f_res = f\"[{res_list[0]},{res_list[1]},{str(res_list[2])},{str(res_list[3])}]\"\n        formatted_results.append(f_res)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output.replace(\" \", \"\"))\n\n\ndef _get_residual_and_derivative(dl, G, sig_eq_tr, sig_y0, p_n, A, C):\n    \"\"\"\n    Computes the residual r(dl) and its derivative r'(dl).\n    \"\"\"\n    p = p_n + dl\n    \n    # Yield stress and its derivative (hardening modulus)\n    sig_y = sig_y0 + A * p - C * p**3\n    H = A - 3 * C * p**2\n    \n    # Residual and its derivative\n    r_val = sig_eq_tr - 3 * G * dl - sig_y\n    r_prime_val = -3 * G - H\n    \n    return r_val, r_prime_val\n\ndef solve_newton(params, tol, max_iters):\n    \"\"\"\n    Solves for dl using the pure Newton method with clamping.\n    \"\"\"\n    G, sig_eq_tr, sig_y0, p_n, A, C = params\n    \n    # Check for elastic step\n    r0, _ = _get_residual_and_derivative(0.0, *params)\n    if r0 = 0:\n        return 0.0, True\n        \n    dl = 0.0\n    converged = False\n    \n    for _ in range(max_iters):\n        r_val, r_prime_val = _get_residual_and_derivative(dl, *params)\n        \n        if np.abs(r_val) = tol:\n            converged = True\n            break\n            \n        if np.abs(r_prime_val)  1e-12: # Avoid division by zero\n            break\n\n        # Newton update\n        update = -r_val / r_prime_val\n        dl = dl + update\n        \n        # Enforce non-negativity by clamping\n        dl = max(0.0, dl)\n        \n    # Final check\n    if not converged:\n        r_final, _ = _get_residual_and_derivative(dl, *params)\n        if np.abs(r_final) = tol:\n            converged = True\n\n    return dl, converged\n\ndef solve_linesearch_newton(params, tol, max_iters, c, beta):\n    \"\"\"\n    Solves for dl using Newton's method with an Armijo backtracking line search.\n    \"\"\"\n    G, sig_eq_tr, sig_y0, p_n, A, C = params\n    \n    # Check for elastic step\n    r0, _ = _get_residual_and_derivative(0.0, *params)\n    if r0 = 0:\n        return 0.0, True\n\n    dl = 0.0\n    converged = False\n    \n    for _ in range(max_iters):\n        r_val, r_prime_val = _get_residual_and_derivative(dl, *params)\n        \n        if np.abs(r_val) = tol:\n            converged = True\n            break\n            \n        if np.abs(r_prime_val)  1e-12:\n            break\n\n        # Newton direction\n        s = -r_val / r_prime_val\n        \n        # Backtracking line search\n        alpha = 1.0\n        phi = 0.5 * r_val**2\n        \n        while True:\n            dl_trial = dl + alpha * s\n            \n            if dl_trial  0:\n                alpha *= beta\n                if alpha  1e-8: # Line search failed\n                    break\n                continue\n\n            r_trial, _ = _get_residual_and_derivative(dl_trial, *params)\n            phi_trial = 0.5 * r_trial**2\n            \n            # Armijo condition\n            armijo_check = phi + c * alpha * (-r_val**2) # Directional derivative is -r^2\n            \n            if phi_trial = armijo_check:\n                dl = dl_trial\n                break\n            \n            alpha *= beta\n            if alpha  1e-8: # Line search failed\n                dl = dl_trial # Take the last valid (but not sufficient) step\n                break\n        \n        if alpha  1e-8: # Propagate line search failure\n             break\n\n    if not converged:\n        r_final, _ = _get_residual_and_derivative(dl, *params)\n        if np.abs(r_final) = tol:\n            converged = True\n\n    return dl, converged\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3550930"}]}