{"hands_on_practices": [{"introduction": "Before we can implement a numerical algorithm, we must have a firm grasp of the underlying theory. This first practice takes us back to the foundational principles of $J_2$ plasticity. By deriving the von Mises equivalent stress, $\\sigma_{\\mathrm{eq}}$, directly from its definition in terms of stress invariants and principal stresses, we solidify our understanding of the scalar quantity that governs the onset of plastic deformation. This exercise also provides a direct proof of a cornerstone property of the model: its insensitivity to hydrostatic pressure, which is critical for understanding why plastic flow is treated as an incompressible, or isochoric, process [@problem_id:3592674].", "problem": "A stress tensor $\\boldsymbol{\\sigma}$ in a homogeneous, isotropic, small-strain solid has principal values $(\\sigma_{1},\\sigma_{2},\\sigma_{3})$ obtained by spectral decomposition. In classical $\\mathrm{J}_{2}$ plasticity, the flow rule and the radial return mapping algorithm are driven by the von Mises equivalent stress, which is defined in terms of the deviatoric stress tensor $\\boldsymbol{s}$ and the second invariant of $\\boldsymbol{s}$. Starting from the following foundational definitions:\n\n(i) The deviatoric stress is $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\,\\mathrm{tr}(\\boldsymbol{\\sigma})\\,\\boldsymbol{I}$, where $\\mathrm{tr}(\\cdot)$ denotes the trace and $\\boldsymbol{I}$ is the identity tensor.\n\n(ii) The second invariant of the deviatoric stress is $J_{2} = \\frac{1}{2}\\,\\boldsymbol{s}:\\boldsymbol{s}$, where $:$ denotes the double contraction $\\boldsymbol{A}:\\boldsymbol{B} = \\mathrm{tr}(\\boldsymbol{A}^{\\top}\\boldsymbol{B})$.\n\n(iii) The von Mises equivalent stress is $\\sigma_{\\mathrm{eq}} = \\sqrt{3\\,J_{2}}$.\n\nDerive a closed-form expression for $\\sigma_{\\mathrm{eq}}$ purely in terms of the principal stresses $(\\sigma_{1},\\sigma_{2},\\sigma_{3})$ and, using that expression together with the definitions above, verify that adding a hydrostatic shift $p$ so that the transformed stress tensor is $\\tilde{\\boldsymbol{\\sigma}} = \\boldsymbol{\\sigma} + p\\,\\boldsymbol{I}$ leaves $\\sigma_{\\mathrm{eq}}$ invariant. Provide only the single algebraic expression for $\\sigma_{\\mathrm{eq}}$ in terms of $(\\sigma_{1},\\sigma_{2},\\sigma_{3})$ as your final answer. No numerical evaluation is required, and no rounding is needed. Do not include physical units in the final expression.", "solution": "The problem is valid. It is scientifically grounded in the principles of continuum mechanics, well-posed, and objectively stated. All necessary definitions are provided for a complete derivation.\n\nThe task is to derive an expression for the von Mises equivalent stress, $\\sigma_{\\mathrm{eq}}$, in terms of the principal stresses $(\\sigma_{1}, \\sigma_{2}, \\sigma_{3})$ and to verify its invariance under a hydrostatic stress shift.\n\nLet the stress tensor be $\\boldsymbol{\\sigma}$. In the principal stress coordinate system, $\\boldsymbol{\\sigma}$ is represented by a diagonal matrix with the principal stresses on the diagonal:\n$$\n\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{1} & 0 & 0 \\\\ 0 & \\sigma_{2} & 0 \\\\ 0 & 0 & \\sigma_{3} \\end{pmatrix}\n$$\nThe identity tensor $\\boldsymbol{I}$ in this basis is:\n$$\n\\boldsymbol{I} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nFirst, we calculate the trace of the stress tensor, $\\mathrm{tr}(\\boldsymbol{\\sigma})$:\n$$\n\\mathrm{tr}(\\boldsymbol{\\sigma}) = \\sigma_{1} + \\sigma_{2} + \\sigma_{3}\n$$\nThe trace is related to the mean or hydrostatic stress, $\\sigma_{m}$, by $\\sigma_{m} = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})$.\n\nNext, we find the deviatoric stress tensor, $\\boldsymbol{s}$, using the given definition: $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\boldsymbol{I}$.\n$$\n\\boldsymbol{s} = \\begin{pmatrix} \\sigma_{1} & 0 & 0 \\\\ 0 & \\sigma_{2} & 0 \\\\ 0 & 0 & \\sigma_{3} \\end{pmatrix} - \\frac{1}{3}(\\sigma_{1} + \\sigma_{2} + \\sigma_{3}) \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nThis results in a diagonal tensor whose components are the principal deviatoric stresses $(s_{1}, s_{2}, s_{3})$:\n$$\ns_{1} = \\sigma_{1} - \\frac{1}{3}(\\sigma_{1} + \\sigma_{2} + \\sigma_{3}) = \\frac{2\\sigma_{1} - \\sigma_{2} - \\sigma_{3}}{3}\n$$\n$$\ns_{2} = \\sigma_{2} - \\frac{1}{3}(\\sigma_{1} + \\sigma_{2} + \\sigma_{3}) = \\frac{2\\sigma_{2} - \\sigma_{1} - \\sigma_{3}}{3}\n$$\n$$\ns_{3} = \\sigma_{3} - \\frac{1}{3}(\\sigma_{1} + \\sigma_{2} + \\sigma_{3}) = \\frac{2\\sigma_{3} - \\sigma_{1} - \\sigma_{2}}{3}\n$$\nNote that the trace of the deviatoric stress tensor is zero: $\\mathrm{tr}(\\boldsymbol{s}) = s_{1} + s_{2} + s_{3} = 0$.\n\nNow, we compute the second invariant of the deviatoric stress, $J_{2} = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$. The double contraction $\\boldsymbol{s}:\\boldsymbol{s}$ is the sum of the squares of the tensor components. Since $\\boldsymbol{s}$ is diagonal in this basis, this simplifies to the sum of the squares of the principal deviatoric stresses:\n$$\n\\boldsymbol{s}:\\boldsymbol{s} = s_{1}^{2} + s_{2}^{2} + s_{3}^{2}\n$$\nSo, $J_{2}$ is given by:\n$$\nJ_{2} = \\frac{1}{2}(s_{1}^{2} + s_{2}^{2} + s_{3}^{2})\n$$\nWe substitute the expressions for $s_{1}, s_{2}, s_{3}$:\n$$\nJ_{2} = \\frac{1}{2} \\left[ \\left(\\frac{2\\sigma_{1} - \\sigma_{2} - \\sigma_{3}}{3}\\right)^{2} + \\left(\\frac{2\\sigma_{2} - \\sigma_{1} - \\sigma_{3}}{3}\\right)^{2} + \\left(\\frac{2\\sigma_{3} - \\sigma_{1} - \\sigma_{2}}{3}\\right)^{2} \\right]\n$$\n$$\nJ_{2} = \\frac{1}{18} \\left[ (2\\sigma_{1} - \\sigma_{2} - \\sigma_{3})^{2} + (2\\sigma_{2} - \\sigma_{1} - \\sigma_{3})^{2} + (2\\sigma_{3} - \\sigma_{1} - \\sigma_{2})^{2} \\right]\n$$\nExpanding the terms in the bracket:\n$$\n(2\\sigma_{1} - \\sigma_{2} - \\sigma_{3})^{2} = 4\\sigma_{1}^{2} + \\sigma_{2}^{2} + \\sigma_{3}^{2} - 4\\sigma_{1}\\sigma_{2} + 2\\sigma_{2}\\sigma_{3} - 4\\sigma_{3}\\sigma_{1}\n$$\n$$\n(2\\sigma_{2} - \\sigma_{1} - \\sigma_{3})^{2} = 4\\sigma_{2}^{2} + \\sigma_{1}^{2} + \\sigma_{3}^{2} - 4\\sigma_{1}\\sigma_{2} - 4\\sigma_{2}\\sigma_{3} + 2\\sigma_{3}\\sigma_{1}\n$$\n$$\n(2\\sigma_{3} - \\sigma_{1} - \\sigma_{2})^{2} = 4\\sigma_{3}^{2} + \\sigma_{1}^{2} + \\sigma_{2}^{2} + 2\\sigma_{1}\\sigma_{2} - 4\\sigma_{2}\\sigma_{3} - 4\\sigma_{3}\\sigma_{1}\n$$\nSumming these three expressions yields:\n$$\n6\\sigma_{1}^{2} + 6\\sigma_{2}^{2} + 6\\sigma_{3}^{2} - 6\\sigma_{1}\\sigma_{2} - 6\\sigma_{2}\\sigma_{3} - 6\\sigma_{3}\\sigma_{1} = 6(\\sigma_{1}^{2} + \\sigma_{2}^{2} + \\sigma_{3}^{2} - \\sigma_{1}\\sigma_{2} - \\sigma_{2}\\sigma_{3} - \\sigma_{3}\\sigma_{1})\n$$\nSubstituting this sum back into the expression for $J_{2}$:\n$$\nJ_{2} = \\frac{1}{18} \\cdot 6(\\sigma_{1}^{2} + \\sigma_{2}^{2} + \\sigma_{3}^{2} - \\sigma_{1}\\sigma_{2} - \\sigma_{2}\\sigma_{3} - \\sigma_{3}\\sigma_{1}) = \\frac{1}{3}(\\sigma_{1}^{2} + \\sigma_{2}^{2} + \\sigma_{3}^{2} - \\sigma_{1}\\sigma_{2} - \\sigma_{2}\\sigma_{3} - \\sigma_{3}\\sigma_{1})\n$$\nThis expression can be rewritten in a more compact and common form using the identity $2(a^{2}+b^{2}+c^{2}-ab-bc-ca) = (a-b)^{2}+(b-c)^{2}+(c-a)^{2}$.\n$$\nJ_{2} = \\frac{1}{6} [(\\sigma_{1}-\\sigma_{2})^{2} + (\\sigma_{2}-\\sigma_{3})^{2} + (\\sigma_{3}-\\sigma_{1})^{2}]\n$$\nFinally, we find the von Mises equivalent stress, $\\sigma_{\\mathrm{eq}} = \\sqrt{3J_{2}}$:\n$$\n\\sigma_{\\mathrm{eq}} = \\sqrt{3 \\cdot \\frac{1}{6} [(\\sigma_{1}-\\sigma_{2})^{2} + (\\sigma_{2}-\\sigma_{3})^{2} + (\\sigma_{3}-\\sigma_{1})^{2}]}\n$$\n$$\n\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{1}{2} [(\\sigma_{1}-\\sigma_{2})^{2} + (\\sigma_{2}-\\sigma_{3})^{2} + (\\sigma_{3}-\\sigma_{1})^{2}]}\n$$\nThis is the desired closed-form expression for $\\sigma_{\\mathrm{eq}}$ in terms of the principal stresses.\n\nNow, we must verify that $\\sigma_{\\mathrm{eq}}$ is invariant under a hydrostatic shift $p$, which transforms the stress tensor to $\\tilde{\\boldsymbol{\\sigma}} = \\boldsymbol{\\sigma} + p\\boldsymbol{I}$.\nLet the new principal stresses be $\\tilde{\\sigma}_{1}, \\tilde{\\sigma}_{2}, \\tilde{\\sigma}_{3}$. The principal directions do not change, so the new principal stresses are simply:\n$$\n\\tilde{\\sigma}_{1} = \\sigma_{1} + p, \\quad \\tilde{\\sigma}_{2} = \\sigma_{2} + p, \\quad \\tilde{\\sigma}_{3} = \\sigma_{3} + p\n$$\nWe can verify the invariance in two ways.\n\nMethod 1: Using the derived expression for $\\sigma_{\\mathrm{eq}}$.\nLet's calculate the equivalent stress for the shifted state, $\\tilde{\\sigma}_{\\mathrm{eq}}$, by substituting the new principal stresses into the formula:\n$$\n\\tilde{\\sigma}_{\\mathrm{eq}} = \\sqrt{\\frac{1}{2} [(\\tilde{\\sigma}_{1}-\\tilde{\\sigma}_{2})^{2} + (\\tilde{\\sigma}_{2}-\\tilde{\\sigma}_{3})^{2} + (\\tilde{\\sigma}_{3}-\\tilde{\\sigma}_{1})^{2}]}\n$$\nThe differences in principal stresses are:\n$$\n\\tilde{\\sigma}_{1} - \\tilde{\\sigma}_{2} = (\\sigma_{1} + p) - (\\sigma_{2} + p) = \\sigma_{1} - \\sigma_{2}\n$$\n$$\n\\tilde{\\sigma}_{2} - \\tilde{\\sigma}_{3} = (\\sigma_{2} + p) - (\\sigma_{3} + p) = \\sigma_{2} - \\sigma_{3}\n$$\n$$\n\\tilde{\\sigma}_{3} - \\tilde{\\sigma}_{1} = (\\sigma_{3} + p) - (\\sigma_{1} + p) = \\sigma_{3} - \\sigma_{1}\n$$\nThe differences are unaffected by the hydrostatic shift. Substituting these back:\n$$\n\\tilde{\\sigma}_{\\mathrm{eq}} = \\sqrt{\\frac{1}{2} [(\\sigma_{1}-\\sigma_{2})^{2} + (\\sigma_{2}-\\sigma_{3})^{2} + (\\sigma_{3}-\\sigma_{1})^{2}]} = \\sigma_{\\mathrm{eq}}\n$$\nThis confirms that $\\sigma_{\\mathrm{eq}}$ is invariant.\n\nMethod 2: Using the fundamental definitions.\nLet's find the deviatoric part of the new stress tensor $\\tilde{\\boldsymbol{\\sigma}}$.\nFirst, the trace of $\\tilde{\\boldsymbol{\\sigma}}$ is:\n$$\n\\mathrm{tr}(\\tilde{\\boldsymbol{\\sigma}}) = \\mathrm{tr}(\\boldsymbol{\\sigma} + p\\boldsymbol{I}) = \\mathrm{tr}(\\boldsymbol{\\sigma}) + \\mathrm{tr}(p\\boldsymbol{I}) = \\mathrm{tr}(\\boldsymbol{\\sigma}) + p\\,\\mathrm{tr}(\\boldsymbol{I}) = \\mathrm{tr}(\\boldsymbol{\\sigma}) + 3p\n$$\nThe new deviatoric stress tensor, $\\tilde{\\boldsymbol{s}}$, is:\n$$\n\\tilde{\\boldsymbol{s}} = \\tilde{\\boldsymbol{\\sigma}} - \\frac{1}{3}\\mathrm{tr}(\\tilde{\\boldsymbol{\\sigma}})\\boldsymbol{I} = (\\boldsymbol{\\sigma} + p\\boldsymbol{I}) - \\frac{1}{3}(\\mathrm{tr}(\\boldsymbol{\\sigma}) + 3p)\\boldsymbol{I}\n$$\n$$\n\\tilde{\\boldsymbol{s}} = \\boldsymbol{\\sigma} + p\\boldsymbol{I} - \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\boldsymbol{I} - \\frac{1}{3}(3p)\\boldsymbol{I} = \\boldsymbol{\\sigma} + p\\boldsymbol{I} - \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\boldsymbol{I} - p\\boldsymbol{I}\n$$\n$$\n\\tilde{\\boldsymbol{s}} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\boldsymbol{I} = \\boldsymbol{s}\n$$\nThe deviatoric part of the stress tensor is itself invariant under a hydrostatic shift. Since $J_{2}$ and $\\sigma_{\\mathrm{eq}}$ are defined solely based on the deviatoric stress, they must also be invariant. Specifically, $\\tilde{J}_{2} = \\frac{1}{2}\\tilde{\\boldsymbol{s}}:\\tilde{\\boldsymbol{s}} = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s} = J_{2}$, and consequently $\\tilde{\\sigma}_{\\mathrm{eq}} = \\sqrt{3\\tilde{J}_{2}} = \\sqrt{3J_{2}} = \\sigma_{\\mathrm{eq}}$. This completes the verification.\nThe final answer is the derived algebraic expression for $\\sigma_{\\mathrm{eq}}$.", "answer": "$$\n\\boxed{\\sqrt{\\frac{1}{2} \\left[ (\\sigma_{1} - \\sigma_{2})^{2} + (\\sigma_{2} - \\sigma_{3})^{2} + (\\sigma_{3} - \\sigma_{1})^{2} \\right]}}\n$$", "id": "3592674"}, {"introduction": "Moving from pure theory to robust implementation requires confronting the realities of finite-precision arithmetic. The radial return algorithm geometrically projects an elastic trial stress back onto the yield surface, and the direction of this projection, $\\mathbf{n}$, is defined by the trial deviatoric stress itself. This practice addresses a crucial numerical challenge: what happens when the trial stress is nearly zero? This exercise guides you through the development of a numerically safe algorithm that avoids division-by-zero errors and spurious plasticity by using properly scaled tolerances, a technique essential for professional-grade simulation software [@problem_id:3592677].", "problem": "Consider the standard associative von Mises (second invariant of the deviatoric stress tensor, commonly denoted as $J_{2}$) plasticity model with linear isotropic hardening. Let the trial deviatoric Cauchy stress be $\\mathbf{s}_\\text{trial}\\in\\mathbb{R}^{3\\times 3}$, the shear modulus be $G>0$, the initial yield stress be $\\sigma_{y0}>0$, the isotropic hardening modulus be $H\\ge 0$, and the current equivalent plastic strain (hardening variable) be $\\alpha_{n}\\ge 0$. The yield function is defined as\n$$\nf(\\mathbf{s},\\alpha)=\\sqrt{\\frac{3}{2}}\\,\\|\\mathbf{s}\\|-\\big(\\sigma_{y0}+H\\,\\alpha\\big),\n$$\nwhere $\\|\\mathbf{s}\\|=\\sqrt{\\mathbf{s}:\\mathbf{s}}$ is the Frobenius norm. The associative flow direction for radial return mapping is $\\mathbf{n}=\\mathbf{s}_\\text{trial}/\\|\\mathbf{s}_\\text{trial}\\|$.\n\nYour task is to derive from first principles and implement a numerically safe algorithm that:\n- Evaluates the trial state and decides elastic versus plastic response using the yield function $f$ and the consistency conditions.\n- Computes the plastic correction via radial return mapping when plasticity is active, ensuring the updated deviatoric stress remains on the yield surface.\n- Computes the flow direction $\\mathbf{n}$ robustly when $\\|\\mathbf{s}_\\text{trial}\\|\\ll 1$ by introducing a scaled tolerance to avoid division by a very small $\\|\\mathbf{s}_\\text{trial}\\|$. Specifically, define a relative tolerance $\\mathrm{rtol}=\\sqrt{\\varepsilon_{\\text{mach}}}$, where $\\varepsilon_{\\text{mach}}$ is the machine precision for double-precision floating point arithmetic, and use the stress scale\n$$\ns_\\text{scale}=\\max\\Big(\\sigma_{y0}+H\\,\\alpha_{n},\\,\\|\\mathbf{s}_\\text{trial}\\|\\Big).\n$$\nConstruct two decision tolerances\n$$\n\\tau_{n}=\\mathrm{rtol}\\,s_\\text{scale,\\quad}\\tau_{f}=\\mathrm{rtol}\\,\\max\\Big(\\sigma_{y0}+H\\,\\alpha_{n},\\,\\sqrt{\\frac{3}{2}}\\,\\|\\mathbf{s}_\\text{trial}\\|\\Big).\n$$\nIf $\\|\\mathbf{s}_\\text{trial}\\|\\le \\tau_{n}$, you must not compute $\\mathbf{n}$ by direct normalization; instead, you must fall back to the elastic predictor and set a flag indicating the fallback. If $f(\\mathbf{s}_\\text{trial},\\alpha_{n})\\le \\tau_{f}$, treat the step as elastic. Otherwise, perform the plastic correction by radial return mapping with an associated flow rule and linear isotropic hardening, enforcing the yield surface consistency at the updated state.\n\nScientific and numerical requirements:\n- Begin from the fundamental small-strain linear elasticity with deviatoric response, the von Mises yield function $f$, the associative flow, and the Karush–Kuhn–Tucker conditions. Do not use any shortcut update formulas in the problem statement. Your implementation must be derived in your solution from these bases.\n- The plastic multiplier increment $\\Delta\\gamma$ is nonnegative and must be computed consistently with the return-to-surface condition for the chosen $f$ and hardening. The hardening variable updates from $\\alpha_{n}$ to $\\alpha_{n+1}$ following linear isotropic hardening with an associated flow.\n- The final reported quantities are:\n    1. The updated deviatoric stress norm $\\|\\mathbf{s}_{n+1}\\|$ in Pascals (Pa).\n    2. The plastic multiplier increment $\\Delta\\gamma$ as a dimensionless quantity.\n    3. An integer fallback flag that is $1$ if the elastic-predictor fallback due to small $\\|\\mathbf{s}_\\text{trial}\\|$ was used, and $0$ otherwise.\n    4. An integer plasticity flag that is $1$ if plastic correction was applied, and $0$ otherwise.\n- All stresses must be expressed in Pascals (Pa). Angles do not appear. There are no percentages.\n\nTest suite:\nYou must run your algorithm on the following four test cases. In each case, construct $\\mathbf{s}_\\text{trial}$, specify material parameters, and use the given $\\alpha_{n}$.\n\n- Test case $1$ (general plastic case, diagonal deviatoric):\n    - $G=80\\times 10^{9}\\ \\text{Pa}$, $\\sigma_{y0}=400\\times 10^{6}\\ \\text{Pa}$, $H=1\\times 10^{9}\\ \\text{Pa}$, and $\\alpha_{n}=0$.\n    - Choose a target trial deviatoric norm $S_\\text{target}=\\|\\mathbf{s}_\\text{trial}\\|=\\dfrac{\\sigma_{y0}+100\\times 10^{6}}{\\sqrt{3/2}}$.\n    - Let $\\mathbf{s}_\\text{trial}$ be diagonal with zero trace: $\\mathbf{s}_\\text{trial}=\\kappa\\,\\mathrm{diag}(2,-1,-1)$ where $\\kappa=S_\\text{target}/\\sqrt{6}$.\n\n- Test case $2$ (near-zero norm, triggers fallback):\n    - $G=80\\times 10^{9}\\ \\text{Pa}$, $\\sigma_{y0}=400\\times 10^{6}\\ \\text{Pa}$, $H=1\\times 10^{9}\\ \\text{Pa}$, and $\\alpha_{n}=0$.\n    - Set $\\|\\mathbf{s}_\\text{trial}\\|=1\\times 10^{-12}\\ \\text{Pa}$ via the same diagonal deviatoric form: $\\mathbf{s}_\\text{trial}=\\kappa\\,\\mathrm{diag}(2,-1,-1)$ with $\\kappa=(1\\times 10^{-12})/\\sqrt{6}$.\n\n- Test case $3$ (borderline plastic case, $f$ slightly positive):\n    - $G=80\\times 10^{9}\\ \\text{Pa}$, $\\sigma_{y0}=400\\times 10^{6}\\ \\text{Pa}$, $H=1\\times 10^{9}\\ \\text{Pa}$, and $\\alpha_{n}=0$.\n    - Set $\\|\\mathbf{s}_\\text{trial}\\|=\\dfrac{\\sigma_{y0}+10}{\\sqrt{3/2}}$ and build $\\mathbf{s}_\\text{trial}$ as in Test case $1$.\n\n- Test case $4$ (off-diagonal shear, plastic case):\n    - $G=80\\times 10^{9}\\ \\text{Pa}$, $\\sigma_{y0}=400\\times 10^{6}\\ \\text{Pa}$, $H=1\\times 10^{9}\\ \\text{Pa}$, and $\\alpha_{n}=0$.\n    - Let the only nonzero components be $\\mathbf{s}_\\text{trial,12}=\\mathbf{s}_\\text{trial,21}=300\\times 10^{6}\\ \\text{Pa}$ and all others zero. This yields $\\|\\mathbf{s}_\\text{trial}\\|=\\sqrt{2}\\,(300\\times 10^{6})\\ \\text{Pa}$.\n\nProgram output specification:\n- For each test case, compute and collect the list $[\\|\\mathbf{s}_{n+1}\\|,\\Delta\\gamma,\\text{fallback\\_flag},\\text{plastic\\_flag}]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s result enclosed in its own square brackets and in the order of the test suite above (for example, $\"[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],...]\"$).", "solution": "The problem requires the derivation and implementation of a radial return mapping algorithm for a standard von Mises ($J_2$) plasticity model with linear isotropic hardening. The derivation must originate from first principles of continuum plasticity, specifically the elastic-plastic decomposition, the yield condition, the flow rule, and the hardening law.\n\nThe state of the material at the beginning of a time step, denoted by subscript $n$, is characterized by the deviatoric stress $\\mathbf{s}_n$ and the equivalent plastic strain $\\alpha_n$. A strain increment occurs, leading to a trial deviatoric stress $\\mathbf{s}_\\text{trial}$. The objective is to find the updated state $(\\mathbf{s}_{n+1}, \\alpha_{n+1})$ at the end of the step. The framework is based on an operator split, where a trial elastic state is computed first, followed by a plastic correctional phase if necessary.\n\nThe core principles are:\n$1$. The elastic-plastic decomposition of the strain rate.\n$2$. The elastic stress-strain relationship for the elastic part.\n$3$. A yield function, $f$, which defines the boundary of the elastic region.\n$4$. A flow rule, which specifies the direction of plastic straining.\n$5$. A hardening law, which describes the evolution of the yield surface.\n$6$. The Karush–Kuhn–Tucker (KKT) loading/unloading conditions.\n\nLet us begin the derivation.\n\nThe model is defined by the following givens: shear modulus $G > 0$, initial yield stress $\\sigma_{y0} > 0$, isotropic hardening modulus $H \\ge 0$, and the state variables at the start of the increment: the deviatoric stress $\\mathbf{s}_n$ and equivalent plastic strain $\\alpha_n$. The problem provides the trial deviatoric stress $\\mathbf{s}_\\text{trial}$, which represents the purely elastic response to the total strain increment:\n$$\n\\mathbf{s}_\\text{trial} = \\mathbf{s}_n + 2G\\,\\Delta\\mathbf{e}\n$$\nwhere $\\Delta\\mathbf{e}$ is the increment of the deviatoric part of the total strain tensor.\n\nThe yield condition is given by the von Mises yield function:\n$$\nf(\\mathbf{s}, \\alpha) = \\sqrt{\\frac{3}{2}}\\,\\|\\mathbf{s}\\| - \\sigma_y(\\alpha) \\le 0\n$$\nwhere $\\|\\mathbf{s}\\| = \\sqrt{\\mathbf{s}:\\mathbf{s}}$ is the Frobenius norm of the deviatoric stress tensor and $\\sigma_y(\\alpha)$ is the current yield stress. For linear isotropic hardening, the yield stress evolves as:\n$$\n\\sigma_y(\\alpha) = \\sigma_{y0} + H\\alpha\n$$\n\nThe first step is to evaluate the yield function at the trial state, $f_\\text{trial} = f(\\mathbf{s}_\\text{trial}, \\alpha_n)$. Based on the KKT conditions ($\\Delta\\gamma \\ge 0$, $f_{n+1} \\le 0$, $\\Delta\\gamma f_{n+1} = 0$), we determine if the step is elastic or plastic.\n\nThe problem introduces numerical tolerances for this decision. Let $\\varepsilon_{\\text{mach}}$ be the machine precision. The relative tolerance is $\\mathrm{rtol} = \\sqrt{\\varepsilon_{\\text{mach}}}$.\nThe yield tolerance is $\\tau_{f} = \\mathrm{rtol}\\,\\max(\\sigma_y(\\alpha_n), \\sqrt{3/2}\\|\\mathbf{s}_\\text{trial}\\|)$.\n\nIf $f(\\mathbf{s}_\\text{trial}, \\alpha_n) \\le \\tau_f$, the step is considered elastic. The plastic multiplier increment $\\Delta\\gamma$ is zero. The final state is the trial state:\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}_\\text{trial}\n$$\n$$\n\\alpha_{n+1} = \\alpha_n\n$$\nIn this case, the `plastic_flag` is $0$.\n\nIf $f(\\mathbf{s}_\\text{trial}, \\alpha_n) > \\tau_f$, the trial state lies outside the yield surface, and a plastic correction is required. This is a plastic step, where $\\Delta\\gamma > 0$ and the final state must satisfy the consistency condition $f(\\mathbf{s}_{n+1}, \\alpha_{n+1}) = 0$.\n\nThe plastic correction is governed by the associative flow rule, where the plastic strain increment is normal to the yield surface:\n$$\n\\Delta\\mathbf{e}^p = \\Delta\\gamma \\frac{\\partial f}{\\partial \\mathbf{s}}\n$$\nThe gradient of the yield function with respect to the deviatoric stress $\\mathbf{s}$ is:\n$$\n\\frac{\\partial f}{\\partial \\mathbf{s}} = \\frac{\\partial}{\\partial \\mathbf{s}} \\left( \\sqrt{\\frac{3}{2}} (\\mathbf{s}:\\mathbf{s})^{1/2} \\right) = \\sqrt{\\frac{3}{2}} \\frac{\\mathbf{s}}{\\|\\mathbf{s}\\|}\n$$\nThe updated stress $\\mathbf{s}_{n+1}$ is obtained by subtracting the elastic stress change due to plastic straining from the trial stress:\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}_\\text{trial} - 2G\\,\\Delta\\mathbf{e}^p\n$$\nFor an implicit integration scheme, the gradient is evaluated at the final state $\\mathbf{s}_{n+1}$.\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}_\\text{trial} - 2G \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{\\mathbf{s}_{n+1}}{\\|\\mathbf{s}_{n+1}\\|}\n$$\nThis equation reveals that $\\mathbf{s}_{n+1}$ must be collinear with $\\mathbf{s}_\\text{trial}$. This is the defining characteristic of radial return mapping for $J_2$ plasticity. Let $\\mathbf{n} = \\mathbf{s}_\\text{trial} / \\|\\mathbf{s}_\\text{trial}\\|$. Then we also have $\\mathbf{n} = \\mathbf{s}_{n+1} / \\|\\mathbf{s}_{n+1}\\|$. The stress update becomes:\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}_\\text{trial} - 2G \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\mathbf{n}\n$$\nTaking the Frobenius norm of both sides and noting that $\\mathbf{s}_\\text{trial}$ and $\\mathbf{n}$ are collinear:\n$$\n\\|\\mathbf{s}_{n+1}\\| = \\|\\mathbf{s}_\\text{trial}\\| - 2G \\Delta\\gamma \\sqrt{\\frac{3}{2}}\n$$\nThe hardening variable $\\alpha$ evolves with plastic work. For $J_2$ plasticity, this is typically defined such that $\\Delta\\alpha = \\Delta\\gamma$. Thus, the updated hardening variable is:\n$$\n\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma\n$$\nNow, we enforce the consistency condition, $f(\\mathbf{s}_{n+1}, \\alpha_{n+1}) = 0$:\n$$\n\\sqrt{\\frac{3}{2}} \\|\\mathbf{s}_{n+1}\\| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0\n$$\nSubstitute the expressions for $\\|\\mathbf{s}_{n+1}\\|$ and $\\alpha_{n+1}$:\n$$\n\\sqrt{\\frac{3}{2}} \\left( \\|\\mathbf{s}_\\text{trial}\\| - 2G \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\right) - \\left( \\sigma_{y0} + H(\\alpha_n + \\Delta\\gamma) \\right) = 0\n$$\nExpanding and rearranging terms to solve for $\\Delta\\gamma$:\n$$\n\\sqrt{\\frac{3}{2}} \\|\\mathbf{s}_\\text{trial}\\| - 3G \\Delta\\gamma - (\\sigma_{y0} + H\\alpha_n) - H\\Delta\\gamma = 0\n$$\nRecognizing that the first and third terms constitute the trial yield function value, $f(\\mathbf{s}_\\text{trial}, \\alpha_n)$:\n$$\nf(\\mathbf{s}_\\text{trial}, \\alpha_n) - (3G+H)\\Delta\\gamma = 0\n$$\nThis yields the closed-form solution for the plastic multiplier increment:\n$$\n\\Delta\\gamma = \\frac{f(\\mathbf{s}_\\text{trial}, \\alpha_n)}{3G + H}\n$$\nSince the step is plastic, $f(\\mathbf{s}_\\text{trial}, \\alpha_n) > 0$. With $G > 0$ and $H \\ge 0$, it is guaranteed that $\\Delta\\gamma > 0$.\n\nOnce $\\Delta\\gamma$ is computed, all other final quantities can be determined. The `plastic_flag` is set to $1$. The norm of the updated deviatoric stress, $\\|\\mathbf{s}_{n+1}\\|$, is most robustly calculated from the consistency condition:\n$$\n\\|\\mathbf{s}_{n+1}\\| = \\sqrt{\\frac{2}{3}} (\\sigma_{y0} + H\\alpha_{n+1}) = \\sqrt{\\frac{2}{3}} (\\sigma_{y0} + H[\\alpha_n + \\Delta\\gamma])\n$$\nA special case for numerical robustness is required when $\\|\\mathbf{s}_\\text{trial}\\|$ is very small. A near-zero trial stress could lead to floating-point errors when computing the flow direction $\\mathbf{n} = \\mathbf{s}_\\text{trial}/\\|\\mathbf{s}_\\text{trial}\\|$. The problem defines a tolerance $\\tau_n$ for this purpose:\n$$\ns_\\text{scale} = \\max(\\sigma_y(\\alpha_n), \\|\\mathbf{s}_\\text{trial}\\|)\n$$\n$$\n\\tau_n = \\mathrm{rtol} \\cdot s_\\text{scale}\n$$\nIf $\\|\\mathbf{s}_\\text{trial}\\| \\le \\tau_n$, the trial state is considered to be at the origin of the deviatoric stress space. This is an unambiguously elastic state. To avoid numerical issues, we set a `fallback_flag` to $1$ and treat the step as elastic, regardless of the value of $f$. Thus, $\\mathbf{s}_{n+1} = \\mathbf{s}_\\text{trial}$, $\\Delta\\gamma=0$, and `plastic_flag=0`. If this check does not trigger, `fallback_flag` is $0$.\n\nThe final algorithm is as follows:\n$1$. Given inputs $\\mathbf{s}_\\text{trial}, \\alpha_n, G, \\sigma_{y0}, H$. Initialize `fallback_flag` to $0$ and `plastic_flag` to $0$.\n$2$. Compute $\\|\\mathbf{s}_\\text{trial}\\|$.\n$3$. Compute tolerances $\\tau_n$ and $\\tau_f$ as specified.\n$4$. Check for fallback: If $\\|\\mathbf{s}_\\text{trial}\\| \\le \\tau_n$, set `fallback_flag=1`, $\\Delta\\gamma=0$, $\\|\\mathbf{s}_{n+1}\\| = \\|\\mathbf{s}_\\text{trial}\\|$, and return the results.\n$5$. Compute trial yield function value $f_\\text{trial} = \\sqrt{3/2}\\|\\mathbf{s}_\\text{trial}\\| - (\\sigma_{y0} + H\\alpha_n)$.\n$6$. Check for plastic loading: If $f_\\text{trial} > \\tau_f$:\n    a. Set `plastic_flag=1$.\n    b. Compute $\\Delta\\gamma = f_\\text{trial} / (3G+H)$.\n    c. Compute $\\|\\mathbf{s}_{n+1}\\| = \\sqrt{2/3}(\\sigma_{y0} + H(\\alpha_n + \\Delta\\gamma))$.\n$7$. Else (elastic step):\n    a. Set $\\Delta\\gamma=0$.\n    b. Set $\\|\\mathbf{s}_{n+1}\\| = \\|\\mathbf{s}_\\text{trial}\\|$.\n$8$. Return the computed values: $\\|\\mathbf{s}_{n+1}\\|$, $\\Delta\\gamma$, `fallback_flag`, and `plastic_flag`.\nThis completes the derivation and algorithmic specification.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# Per the problem description, scipy is listed as a library but is not needed\n# for the analytical solution of this specific plasticity model.\n# from scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the radial return mapping algorithm.\n    \"\"\"\n\n    def radial_return_J2(s_trial, alpha_n, G, sigma_y0, H):\n        \"\"\"\n        Implements the radial return mapping for J2 plasticity with linear isotropic hardening.\n\n        Args:\n            s_trial (np.ndarray): The 3x3 trial deviatoric stress tensor.\n            alpha_n (float): The equivalent plastic strain at the start of the increment.\n            G (float): Shear modulus.\n            sigma_y0 (float): Initial yield stress.\n            H (float): Isotropic hardening modulus.\n\n        Returns:\n            tuple: A tuple containing:\n                - norm_s_n1 (float): The norm of the updated deviatoric stress.\n                - delta_gamma (float): The plastic multiplier increment.\n                - fallback_flag (int): 1 if near-zero norm fallback was used, 0 otherwise.\n                - plastic_flag (int): 1 if a plastic correction was applied, 0 otherwise.\n        \"\"\"\n        fallback_flag = 0\n        plastic_flag = 0\n        \n        # Machine epsilon for double precision\n        eps_mach = np.finfo(float).eps\n        rtol = math.sqrt(eps_mach)\n\n        # Calculate Frobenius norm of the trial deviatoric stress\n        norm_s_trial = np.linalg.norm(s_trial)\n\n        # Current yield stress\n        sigma_y_n = sigma_y0 + H * alpha_n\n        \n        # --- Fallback Check for near-zero trial stress norm ---\n        s_scale = max(sigma_y_n, norm_s_trial)\n        tau_n = rtol * s_scale\n\n        if norm_s_trial = tau_n:\n            fallback_flag = 1\n            # Elastic fallback: the final state is the trial state\n            norm_s_n1 = norm_s_trial\n            delta_gamma = 0.0\n            plastic_flag = 0\n            return [norm_s_n1, delta_gamma, fallback_flag, plastic_flag]\n\n        # --- Yield Check ---\n        # von Mises equivalent stress for the trial state\n        sigma_vm_trial = math.sqrt(3.0 / 2.0) * norm_s_trial\n        \n        # Trial yield function value\n        f_trial = sigma_vm_trial - sigma_y_n\n        \n        # Tolerance for the yield function check\n        tau_f = rtol * max(sigma_y_n, sigma_vm_trial)\n\n        if f_trial = tau_f:\n            # Elastic step\n            plastic_flag = 0\n            delta_gamma = 0.0\n            norm_s_n1 = norm_s_trial\n        else:\n            # Plastic step (radial return)\n            plastic_flag = 1\n            \n            # Compute plastic multiplier\n            delta_gamma = f_trial / (3.0 * G + H)\n            \n            # Update hardening variable\n            alpha_n1 = alpha_n + delta_gamma\n            \n            # Updated yield stress\n            sigma_y_n1 = sigma_y0 + H * alpha_n1\n            \n            # Compute the norm of the updated deviatoric stress from the consistency condition\n            norm_s_n1 = math.sqrt(2.0 / 3.0) * sigma_y_n1\n\n        return [norm_s_n1, delta_gamma, fallback_flag, plastic_flag]\n\n    # Material parameters from the problem statement\n    G_val = 80.0e9  # Pa\n    sigma_y0_val = 400.0e6  # Pa\n    H_val = 1.0e9  # Pa\n    alpha_n_val = 0.0\n\n    # Define test cases\n    test_cases_params = [\n        {'type': 'diag', 'norm_val': (sigma_y0_val + 100.0e6) / math.sqrt(1.5)},\n        {'type': 'diag', 'norm_val': 1.0e-12},\n        {'type': 'diag', 'norm_val': (sigma_y0_val + 10.0) / math.sqrt(1.5)},\n        {'type': 'off_diag', 'shear_val': 300.0e6},\n    ]\n\n    results = []\n    \n    for params in test_cases_params:\n        s_trial = np.zeros((3, 3))\n        if params['type'] == 'diag':\n            S_target = params['norm_val']\n            kappa = S_target / math.sqrt(6.0)\n            s_trial[0, 0] = 2.0 * kappa\n            s_trial[1, 1] = -1.0 * kappa\n            s_trial[2, 2] = -1.0 * kappa\n        elif params['type'] == 'off_diag':\n            s_trial[0, 1] = params['shear_val']\n            s_trial[1, 0] = params['shear_val']\n\n        result_case = radial_return_J2(s_trial, alpha_n_val, G_val, sigma_y0_val, H_val)\n        results.append(result_case)\n\n    # Format the output as per the specification\n    # [[r1_1,...,r1_4], [r2_1,...,r2_4], ...]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3592677"}, {"introduction": "The ultimate purpose of a local stress update algorithm is to serve as a constitutive driver within a global nonlinear finite element analysis. This final, comprehensive practice connects the local radial return map to the global convergence behavior of a Newton-Raphson solver. You will not only implement the stress update but also derive the exact algorithmic tangent modulus, $\\mathbb{C}_{\\text{alg}}$, which is the consistent linearization of the update procedure. By comparing the quadratic convergence achieved with the consistent tangent against the linear convergence of an elastic tangent, you will gain a profound appreciation for why this complex derivation is indispensable for building efficient and reliable nonlinear structural analysis codes [@problem_id:3592675].", "problem": "Consider small-strain, rate-independent, isotropically hardening von Mises (also called $J_2$) plasticity under isothermal conditions. Assume an initially stress-free, homogeneous, isotropic, linear-elastic solid with Young’s modulus $E$ and Poisson’s ratio $v$, augmented by linear isotropic hardening of modulus $H \\ge 0$. The Lamé parameters are defined by $\\lambda = \\dfrac{Ev}{(1+v)(1-2v)}$ and $\\mu = \\dfrac{E}{2(1+v)}$, and the bulk modulus is $K = \\lambda + \\dfrac{2}{3}\\mu = \\dfrac{E}{3(1-2v)}$. Let the Cauchy stress be $\\boldsymbol{\\sigma}$, the infinitesimal strain be $\\boldsymbol{\\varepsilon}$, with deviatoric parts $\\mathbf{s} = \\text{dev}\\,\\boldsymbol{\\sigma}$ and $\\boldsymbol{\\varepsilon}^{\\text{dev}} = \\text{dev}\\,\\boldsymbol{\\varepsilon}$, and let the equivalent plastic strain be $\\varepsilon^{\\text{eq}}_p$. The von Mises equivalent stress is $q = \\sqrt{\\dfrac{3}{2}}\\,\\|\\mathbf{s}\\|_2$. The yield condition is $f(\\boldsymbol{\\sigma},\\varepsilon^{\\text{eq}}_p) = q - \\sigma_y(\\varepsilon^{\\text{eq}}_p) \\le 0$, with $\\sigma_y(\\varepsilon^{\\text{eq}}_p) = \\sigma_{y0} + H \\varepsilon^{\\text{eq}}_p$ and initial yield stress $\\sigma_{y0}  0$. The associative flow rule is used. Consider the standard elastic predictor–plastic corrector algorithm (radial return mapping) for the local stress update at a material point from step $n$ to $n+1$ for a given total strain increment.\n\nYour tasks:\n\n1) From the above fundamental definitions, derive the closed-form radial return mapping in the small-strain setting for $J_2$ plasticity with linear isotropic hardening. Base your derivation on the elastic predictor, the yield function, and the consistency condition, without invoking any pre-derived plasticity update formulas. Conclude with an explicit expression for the updated Cauchy stress $\\boldsymbol{\\sigma}_{n+1}$ and the updated equivalent plastic strain $\\varepsilon^{\\text{eq}}_{p,n+1}$ in terms of the known total strain $\\boldsymbol{\\varepsilon}_{n+1}$ and the previous step’s internal variables.\n\n2) Linearize the return-mapped stress update to derive the exact algorithmic consistent tangent modulus $\\mathbb{C}_{\\text{alg}} = \\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\boldsymbol{\\varepsilon}_{n+1}}$ as a fourth-order tensor. Your derivation must start from the definitions above, apply the consistency condition, and retain the deviatoric flow direction $\\mathbf{n} = \\mathbf{s}/\\|\\mathbf{s}\\|_2$ where appropriate. Provide the final expression of $\\mathbb{C}_{\\text{alg}}$ in a form that clearly separates volumetric and deviatoric contributions.\n\n3) Assess robustness as $v \\to 0.5$ by designing a stress update experiment under uniaxial strain loading $\\boldsymbol{\\varepsilon} = \\text{diag}(\\varepsilon,0,0)$ on a one-dimensional bar of length $L$ and cross-sectional area $A$, with no body force and with a prescribed end load $F$. The global residual is $R(u) = A\\,\\sigma_{11}(\\varepsilon(u)) - F$, where the axial strain is $\\varepsilon(u) = u/L$. Implement two global Newton methods to solve $R(u)=0$:\n- Method (i): using the exact algorithmic consistent tangent, i.e., the global tangent $dR/du$ formed from $\\mathbb{C}_{\\text{alg}}$ projected onto the uniaxial strain path.\n- Method (ii): using the purely elastic tangent, i.e., the global tangent $dR/du$ formed from the linear-elastic modulus only.\n\nUse the same local stress update (radial return) in both methods; only the global Newton tangent differs. Start Newton’s method from the linear-elastic uniaxial-strain solution $u_0 = F L / (A M)$, where $M = \\lambda + 2\\mu$ is the uniaxial-strain modulus. Terminate when $|R(u_k)| \\le \\tau \\max(1,|F|)$ with tolerance $\\tau = 10^{-10}$, or when a maximum of $50$ iterations is reached. Count iterations as the number of Newton updates performed; if the initial guess already satisfies the tolerance, report $0$.\n\n4) Use International System of Units (SI). All stresses and moduli must be in Pascals, lengths in meters, forces in Newtons, and strains are dimensionless. Use angles in radians if any appear.\n\n5) Implement the above in a complete, runnable program that carries out the following test suite. For each case, run both Newton methods and report the pair of iteration counts in the order [consistent,elastic]. The material point history at the start of each case is zero plastic strain and zero stress.\n\nTest suite (each case uses $A = 1\\,\\text{m}^2$ and $L = 1\\,\\text{m}$):\n- Case 1 (elastic, moderate compressibility):\n  - $E = 210\\times 10^9\\,\\text{Pa}$, $v = 0.3$, $\\sigma_{y0} = 250\\times 10^6\\,\\text{Pa}$, $H = 1\\times 10^9\\,\\text{Pa}$, $F = 349600000\\,\\text{N}$.\n- Case 2 (perfect plasticity, moderate compressibility):\n  - $E = 210\\times 10^9\\,\\text{Pa}$, $v = 0.3$, $\\sigma_{y0} = 250\\times 10^6\\,\\text{Pa}$, $H = 0\\,\\text{Pa}$, $F = 524400000\\,\\text{N}$.\n- Case 3 (plastic, nearly incompressible):\n  - $E = 210\\times 10^9\\,\\text{Pa}$, $v = 0.4999$, $\\sigma_{y0} = 250\\times 10^6\\,\\text{Pa}$, $H = 1\\times 10^9\\,\\text{Pa}$, $F = 750000000000\\,\\text{N}$.\n- Case 4 (perfect plasticity, nearly incompressible):\n  - $E = 210\\times 10^9\\,\\text{Pa}$, $v = 0.4999$, $\\sigma_{y0} = 250\\times 10^6\\,\\text{Pa}$, $H = 0\\,\\text{Pa}$, $F = 750000000000\\,\\text{N}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of four two-element lists, each inner list being the pair of iteration counts [consistent,elastic] for Cases 1–4 in order, e.g., \"[[c1,e1],[c2,e2],[c3,e3],[c4,e4]]\".", "solution": "This problem requires the derivation and implementation of the radial return mapping algorithm for $J_2$ plasticity with linear isotropic hardening, its consistent tangent modulus, and an assessment of its numerical performance in a global Newton-Raphson scheme. The solution is presented in three parts as requested: derivation of the stress update, derivation of the consistent tangent, and a description of the numerical implementation.\n\n### 1. Derivation of the Radial Return Mapping\n\nThe objective is to find the stress state $\\boldsymbol{\\sigma}_{n+1}$ and the equivalent plastic strain $\\varepsilon^{\\text{eq}}_{p,n+1}$ at time step $n+1$, given the total strain $\\boldsymbol{\\varepsilon}_{n+1}$ and the state variables ($\\boldsymbol{\\varepsilon}^p_n$, $\\varepsilon^{\\text{eq}}_{p,n}$) from the previous step $n$. The model is based on an additive decomposition of the total strain into elastic and plastic parts, $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^e + \\boldsymbol{\\varepsilon}^p$.\n\n**Elastic Predictor**\nFirst, we assume the entire strain increment is elastic. The trial stress state is computed using linear elasticity. Let $\\Delta\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}_n$. The trial stress $\\boldsymbol{\\sigma}^{\\text{tr}}$ is given by:\n$$\n\\boldsymbol{\\sigma}^{\\text{tr}} = \\mathbb{C}^e : (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^p_n)\n$$\nwhere $\\mathbb{C}^e$ is the fourth-order isotropic elastic stiffness tensor, $\\mathbb{C}^e_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu (\\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk})$.\nThis can be decomposed into volumetric and deviatoric parts. The trial hydrostatic stress is $p^{\\text{tr}} = K \\text{tr}(\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^p_n) = K \\text{tr}(\\boldsymbol{\\varepsilon}_{n+1})$ as plastic strain is incompressible ($\\text{tr}(\\boldsymbol{\\varepsilon}^p_n)=0$). The trial deviatoric stress is:\n$$\n\\mathbf{s}^{\\text{tr}} = 2\\mu (\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{\\text{dev},p}_n)\n$$\nwhere $\\boldsymbol{\\varepsilon}^{\\text{dev},p}_n = \\boldsymbol{\\varepsilon}^p_n$.\n\n**Yield Condition Check**\nThe trial state is checked against the yield condition $f(\\boldsymbol{\\sigma}, \\varepsilon^{\\text{eq}}_p) = q - \\sigma_y(\\varepsilon^{\\text{eq}}_p) \\le 0$. The trial equivalent stress is $q^{\\text{tr}} = \\sqrt{\\frac{3}{2}} \\|\\mathbf{s}^{\\text{tr}}\\|_2$. The yield stress at the beginning of the step is $\\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})$. The trial yield function value is:\n$$\nf^{\\text{tr}} = q^{\\text{tr}} - \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})\n$$\nIf $f^{\\text{tr}} \\le 0$, the step is elastic. The final state is the trial state: $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\text{tr}}$, $\\boldsymbol{\\varepsilon}^p_{n+1} = \\boldsymbol{\\varepsilon}^p_n$, and $\\varepsilon^{\\text{eq}}_{p,n+1} = \\varepsilon^{\\text{eq}}_{p,n}$.\n\n**Plastic Corrector**\nIf $f^{\\text{tr}}  0$, plastic flow occurs. The state must be returned to the yield surface. The stress-strain relationship is $\\boldsymbol{\\sigma}_{n+1} = \\mathbb{C}^e : (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^p_{n+1})$. Defining the plastic strain increment $\\Delta\\boldsymbol{\\varepsilon}^p = \\boldsymbol{\\varepsilon}^p_{n+1} - \\boldsymbol{\\varepsilon}^p_n$, we have:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\text{tr}} - \\mathbb{C}^e : \\Delta\\boldsymbol{\\varepsilon}^p\n$$\nThe associative flow rule states that the plastic strain increment is normal to the yield surface:\n$$\n\\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}_{n+1}} = \\Delta\\gamma \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}_{n+1}} = \\Delta\\gamma \\frac{3}{2q_{n+1}} \\mathbf{s}_{n+1}\n$$\nwhere $\\Delta\\gamma \\ge 0$ is the consistency parameter or plastic multiplier. Since $\\Delta\\boldsymbol{\\varepsilon}^p$ is purely deviatoric, the stress update simplifies to:\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}^{\\text{tr}} - 2\\mu \\Delta\\boldsymbol{\\varepsilon}^p \\quad \\text{and} \\quad \\frac{1}{3}\\text{tr}(\\boldsymbol{\\sigma}_{n+1}) = \\frac{1}{3}\\text{tr}(\\boldsymbol{\\sigma}^{\\text{tr}})\n$$\nSubstituting the flow rule into the deviatoric stress update implies that $\\mathbf{s}_{n+1}$ and $\\mathbf{s}^{\\text{tr}}$ are coaxial. Thus, the direction of flow is fixed by the trial state: $\\mathbf{n}_{n+1} = \\frac{\\mathbf{s}_{n+1}}{\\|\\mathbf{s}_{n+1}\\|_2} = \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_2} = \\mathbf{n}^{\\text{tr}}$. The flow rule can then be written as $\\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\sqrt{\\frac{3}{2}}\\mathbf{n}^{\\text{tr}}$.\nThe increment in equivalent plastic strain is $\\Delta\\varepsilon^{\\text{eq}}_p = \\sqrt{\\frac{2}{3}} \\|\\Delta\\boldsymbol{\\varepsilon}^p\\|_2 = \\Delta\\gamma$.\nProjecting the deviatoric stress update onto the direction $\\mathbf{n}^{\\text{tr}}$ yields:\n$$\n\\|\\mathbf{s}_{n+1}\\|_2 = \\|\\mathbf{s}^{\\text{tr}}\\|_2 - 2\\mu \\|\\Delta\\boldsymbol{\\varepsilon}^p\\|_2 \\implies q_{n+1} = q^{\\text{tr}} - 3\\mu \\Delta\\gamma\n$$\nThis is the radial return equation, showing the magnitude of the trial deviatoric stress is reduced. The state at step $n+1$ must satisfy the consistency condition, $f_{n+1}=0$:\n$$\nq_{n+1} = \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n+1}) = \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n} + \\Delta\\varepsilon^{\\text{eq}}_p) = \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n}) + H\\Delta\\gamma\n$$\nWe now have a system of two equations for the unknowns $\\Delta\\gamma$ and $q_{n+1}$. Solving for $\\Delta\\gamma$:\n$$\nq^{\\text{tr}} - 3\\mu \\Delta\\gamma = \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n}) + H\\Delta\\gamma \\implies \\Delta\\gamma = \\frac{q^{\\text{tr}} - \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{3\\mu + H} = \\frac{f^{\\text{tr}}}{3\\mu + H}\n$$\nWith $\\Delta\\gamma$ known, the internal variables and stress are updated.\n\n**Final Update Formulas**\n- If $f^{\\text{tr}} \\le 0$ (elastic):\n  $$ \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\text{tr}}, \\quad \\varepsilon^{\\text{eq}}_{p,n+1} = \\varepsilon^{\\text{eq}}_{p,n} $$\n- If $f^{\\text{tr}}  0$ (plastic):\n  - Plastic multiplier: $\\Delta\\gamma = \\dfrac{q^{\\text{tr}} - \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{3\\mu + H}$\n  - Equivalent plastic strain: $\\varepsilon^{\\text{eq}}_{p,n+1} = \\varepsilon^{\\text{eq}}_{p,n} + \\Delta\\gamma$\n  - Stress tensor:\n    $$ \\boldsymbol{\\sigma}_{n+1} = \\frac{1}{3}\\text{tr}(\\boldsymbol{\\sigma}^{\\text{tr}})\\mathbf{I} + \\left(1 - \\frac{3\\mu\\Delta\\gamma}{q^{\\text{tr}}}\\right)\\mathbf{s}^{\\text{tr}} $$\n    The term $1 - \\frac{3\\mu\\Delta\\gamma}{q^{\\text{tr}}}$ is the scaling factor that returns the stress to the updated yield surface, equal to $\\frac{q_{n+1}}{q^{\\text{tr}}}$.\n\n### 2. Derivation of the Algorithmic Consistent Tangent Modulus\n\nThe algorithmic tangent modulus $\\mathbb{C}_{\\text{alg}}$ is the exact linearization of the stress update algorithm, $\\mathbb{C}_{\\text{alg}} = \\frac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\boldsymbol{\\varepsilon}_{n+1}}$. For an elastic step, $\\mathbb{C}_{\\text{alg}} = \\mathbb{C}^e$. For a plastic step, we differentiate the update expressions.\n$$\n\\boldsymbol{\\sigma}_{n+1} = K\\,\\text{tr}(\\boldsymbol{\\varepsilon}_{n+1})\\mathbf{I} + \\beta \\mathbf{s}^{\\text{tr}}, \\quad \\text{where} \\quad \\beta = \\frac{q_{n+1}}{q^{\\text{tr}}} = 1 - \\frac{3\\mu\\Delta\\gamma}{q^{\\text{tr}}}\n$$\nThe differential is $d\\boldsymbol{\\sigma}_{n+1} = K\\,\\text{tr}(d\\boldsymbol{\\varepsilon}_{n+1})\\mathbf{I} + d(\\beta \\mathbf{s}^{\\text{tr}})$. Using the product rule:\n$$\nd\\boldsymbol{\\sigma}_{n+1} = K\\,\\mathbf{I}\\otimes\\mathbf{I}:d\\boldsymbol{\\varepsilon}_{n+1} + \\mathbf{s}^{\\text{tr}} \\otimes d\\beta + \\beta d\\mathbf{s}^{\\text{tr}}\n$$\nWe need expressions for $d\\mathbf{s}^{\\text{tr}}$ and $d\\beta$.\n$d\\mathbf{s}^{\\text{tr}} = 2\\mu\\,d\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} = 2\\mu \\mathbb{P}_{\\text{dev}} : d\\boldsymbol{\\varepsilon}_{n+1}$, where $\\mathbb{P}_{\\text{dev}}$ is the fourth-order deviatoric projection tensor.\nTo find $d\\beta$, we write $\\beta$ as a function of $q^{\\text{tr}}$:\n$$\n\\beta = \\frac{q_{n+1}}{q^{\\text{tr}}} = \\frac{1}{q^{\\text{tr}}} \\left( \\sigma_y(\\varepsilon^{\\text{eq}}_{p,n}) + H\\Delta\\gamma \\right) = \\frac{\\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{q^{\\text{tr}}} + \\frac{H}{q^{\\text{tr}}} \\frac{q^{\\text{tr}}-\\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{3\\mu+H} = \\frac{3\\mu \\frac{\\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{q^{\\text{tr}}} + H}{3\\mu+H}\n$$\nDifferentiating $\\beta$ with respect to $\\boldsymbol{\\varepsilon}_{n+1}$ is equivalent to differentiating with respect to $q^{\\text{tr}}$, and using the chain rule. $\\frac{\\partial \\beta}{\\partial \\boldsymbol{\\varepsilon}_{n+1}} = \\frac{d\\beta}{dq^{\\text{tr}}} \\frac{\\partial q^{\\text{tr}}}{\\partial \\boldsymbol{\\varepsilon}_{n+1}}$.\n$$\n\\frac{d\\beta}{dq^{\\text{tr}}} = \\frac{d}{dq^{\\text{tr}}}\\left(\\frac{q_{n+1}}{q^{\\text{tr}}}\\right) = \\frac{1}{(q^{\\text{tr}})^2} \\left( \\frac{dq_{n+1}}{dq^{\\text{tr}}}q^{\\text{tr}} - q_{n+1} \\right)\n$$\nFrom $q_{n+1} = \\frac{H q^{\\text{tr}} + 3\\mu\\sigma_y(\\varepsilon^{\\text{eq}}_{p,n})}{3\\mu+H}$, we get $\\frac{dq_{n+1}}{dq^{\\text{tr}}} = \\frac{H}{3\\mu+H}$.\n$$\n\\frac{d\\beta}{dq^{\\text{tr}}} = \\frac{1}{q^{\\text{tr}}} \\left(\\frac{H}{3\\mu+H} - \\frac{q_{n+1}}{q^{\\text{tr}}}\\right) = \\frac{1}{q^{\\text{tr}}}\\left(\\frac{H}{3\\mu+H} - \\beta\\right)\n$$\nThe derivative of the trial equivalent stress is $\\frac{\\partial q^{\\text{tr}}}{\\partial \\boldsymbol{\\varepsilon}_{n+1}} = \\sqrt{6}\\mu \\mathbf{n}^{\\text{tr}}$.\nCombining these, $d\\beta = \\frac{1}{q^{\\text{tr}}}\\left(\\frac{H}{3\\mu+H} - \\beta\\right) (\\sqrt{6}\\mu \\mathbf{n}^{\\text{tr}}:d\\boldsymbol{\\varepsilon}_{n+1})$.\nThe term $\\mathbf{s}^{\\text{tr}} \\otimes d\\beta$ becomes:\n$$\n\\mathbf{s}^{\\text{tr}} \\otimes \\frac{\\partial \\beta}{\\partial \\boldsymbol{\\varepsilon}_{n+1}} = (\\sqrt{2/3}q^{\\text{tr}}\\mathbf{n}^{\\text{tr}}) \\otimes \\left( \\frac{1}{q^{\\text{tr}}}\\left(\\frac{H}{3\\mu+H} - \\beta\\right) \\sqrt{6}\\mu \\mathbf{n}^{\\text{tr}} \\right) = 2\\mu\\left(\\frac{H}{3\\mu+H} - \\beta\\right) \\mathbf{n}^{\\text{tr}}\\otimes\\mathbf{n}^{\\text{tr}}\n$$\nSubstituting all parts into the expression for $d\\boldsymbol{\\sigma}_{n+1}$:\n$$\nd\\boldsymbol{\\sigma}_{n+1} = \\left[ K\\mathbf{I}\\otimes\\mathbf{I} + 2\\mu\\beta\\mathbb{P}_{\\text{dev}} + 2\\mu\\left(\\frac{H}{3\\mu+H} - \\beta\\right)\\mathbf{n}^{\\text{tr}}\\otimes\\mathbf{n}^{\\text{tr}} \\right] : d\\boldsymbol{\\varepsilon}_{n+1}\n$$\nThe term in brackets is the algorithmic tangent modulus $\\mathbb{C}_{\\text{alg}}$. It clearly separates into a volumetric part ($K\\mathbf{I}\\otimes\\mathbf{I}$) and a deviatoric part.\n- Volumetric part: $\\mathbb{C}_{\\text{vol}} = K\\,\\mathbf{I}\\otimes\\mathbf{I}$\n- Deviatoric part: $\\mathbb{C}_{\\text{dev}} = 2\\mu\\beta\\mathbb{P}_{\\text{dev}} + 2\\mu\\left(\\frac{H}{3\\mu+H} - \\beta\\right)\\mathbf{n}^{\\text{tr}}\\otimes\\mathbf{n}^{\\text{tr}}$\nwhere $\\beta = q_{n+1}/q^{\\text{tr}}$.\n\n### 3. Numerical Experiment Implementation\n\nThe experiment involves solving the nonlinear scalar equation $R(u) = A\\,\\sigma_{11}(\\varepsilon(u)) - F = 0$ for the displacement $u$, where $\\varepsilon(u) = u/L$. Since $A=1\\,\\text{m}^2$ and $L=1\\,\\text{m}$, this simplifies to $R(u) = \\sigma_{11}(u) - F = 0$. The Newton-Raphson update is $u_{k+1} = u_k - R(u_k)/K_T$, where $K_T = dR/du = d\\sigma_{11}/d\\varepsilon$.\n\nThe uniaxial strain state is $\\boldsymbol{\\varepsilon} = \\text{diag}(\\varepsilon, 0, 0)$. For this path, the required tangent component $d\\sigma_{11}/d\\varepsilon$ is the $(1,1,1,1)$ component of $\\mathbb{C}_{\\text{alg}}$.\n- If the step is elastic, $d\\sigma_{11}/d\\varepsilon = \\mathbb{C}^e_{1111} = \\lambda + 2\\mu = M$, the uniaxial strain modulus.\n- If the step is plastic, we evaluate $\\mathbb{C}_{\\text{alg},1111}$. The required tensor components are:\n  - $(\\mathbf{I}\\otimes\\mathbf{I})_{1111} = 1$\n  - $\\mathbb{P}_{\\text{dev},1111} = 2/3$\n  - For uniaxial strain $\\varepsilon$, $\\mathbf{n}^{\\text{tr}} = \\frac{\\text{sgn}(\\varepsilon)}{\\sqrt{6}}\\text{diag}(2,-1,-1)$, so $(\\mathbf{n}^{\\text{tr}}\\otimes\\mathbf{n}^{\\text{tr}})_{1111} = n^{\\text{tr}}_{11}n^{\\text{tr}}_{11} = (2/\\sqrt{6})^2 = 2/3$.\nSubstituting these into the expression for $\\mathbb{C}_{\\text{alg}}$:\n$$\n\\frac{d\\sigma_{11}}{d\\varepsilon} = K\\cdot 1 + 2\\mu\\beta(\\frac{2}{3}) + 2\\mu\\left(\\frac{H}{3\\mu+H} - \\beta\\right)(\\frac{2}{3}) = K + \\frac{4}{3}\\mu\\beta + \\frac{4}{3}\\mu\\frac{H}{3\\mu+H} - \\frac{4}{3}\\mu\\beta = K + \\frac{4\\mu H}{3(3\\mu+H)}\n$$\nThis is the plastic tangent modulus for uniaxial strain, $M_p$.\n\nTwo Newton methods are implemented:\n1.  **Consistent Tangent Method**: Uses $K_T = M$ for elastic steps and $K_T = M_p$ for plastic steps. This provides quadratic convergence.\n2.  **Elastic Tangent Method**: Always uses $K_T = M$. This method is expected to have slower, linear convergence in the plastic regime.\n\nThe implementation consists of a main loop that iterates through the test cases. For each case, two Newton solver loops are executed, one for each tangent type. The stress update logic, including the radial return and the calculation of $\\sigma_{11}$ and the appropriate tangent $d\\sigma_{11}/d\\varepsilon$, is encapsulated in a helper function. The number of iterations for each method is recorded and formatted into the required output.", "answer": "```python\nimport numpy as np\n\ndef stress_update(eps, E, v, sigy0, H):\n    \"\"\"\n    Performs a radial return stress update for J2 plasticity under uniaxial strain.\n\n    Args:\n        eps (float): Axial strain component (epsilon_11).\n        E (float): Young's modulus.\n        v (float): Poisson's ratio.\n        sigy0 (float): Initial yield stress.\n        H (float): Linear hardening modulus.\n\n    Returns:\n        tuple: A tuple containing:\n            - sig11 (float): Updated axial stress component (sigma_11).\n            - tangent (float): Algorithmic consistent tangent d(sigma_11)/d(epsilon).\n    \"\"\"\n    # Material properties\n    # Use float conversions to avoid potential integer division issues.\n    E, v, sigy0, H = float(E), float(v), float(sigy0), float(H)\n    \n    # Check for valid Poisson's ratio to prevent division by zero\n    if abs(1.0 - 2.0 * v)  1e-12 or abs(1.0 + v)  1e-12:\n        # For perfectly incompressible case, use large K but avoid inf\n        K = E / (3.0 * (1.0 - 2.0 * 0.49999999))\n    else:\n        K = E / (3.0 * (1.0 - 2.0 * v))\n    \n    mu = E / (2.0 * (1.0 + v))\n    M = K + 4.0 / 3.0 * mu  # Uniaxial elastic modulus\n\n    # Elastic predictor step for uniaxial strain\n    # Strain tensor is diag(eps, 0, 0)\n    # Trial deviatoric stress s_tr = 2*mu*eps_dev\n    # eps_dev = diag(2/3*eps, -1/3*eps, -1/3*eps)\n    # q_tr = sqrt(3/2 * s_tr:s_tr) = 2*mu*|eps|\n    q_tr = 2.0 * mu * np.abs(eps)\n\n    # Yield criterion check (using state at step n, which is zero)\n    f_tr = q_tr - sigy0\n\n    if f_tr = 0:\n        # Elastic response\n        sig11 = M * eps\n        tangent = M\n    else:\n        # Plastic response\n        # Consistency parameter (plastic multiplier increment)\n        delta_gamma = f_tr / (3.0 * mu + H)\n\n        # Updated stress sigma_11\n        # s_11 = s_tr_11 * (q_n+1 / q_tr)\n        # q_n+1 = sigy0 + H * delta_gamma\n        # s_tr_11 = 2*mu*(2/3*eps) = 4/3*mu*eps\n        # sigma_11 = K * tr(eps) + s_11 = K*eps + s_11\n        # s_11 = (4/3*mu*eps) * ((sigy0 + H*delta_gamma) / (2*mu*|eps|))\n        # s_11 = sign(eps) * 2/3 * (sigy0 + H*delta_gamma)\n        sig11 = K * eps + np.sign(eps) * (2.0 / 3.0) * (sigy0 + H * delta_gamma)\n\n        # Algorithmic consistent tangent for uniaxial strain\n        # C_1111 = K + (4*mu*H) / (3*(3*mu+H))\n        tangent = K + (4.0 * mu * H) / (3.0 * (3.0 * mu + H))\n        \n    return sig11, tangent\n\ndef run_newton_solver(F, E, v, sigy0, H, use_consistent_tangent):\n    \"\"\"\n    Solves the 1D global problem R(u)=0 using Newton's method.\n\n    Args:\n        F (float): Applied force.\n        E, v, sigy0, H (float): Material parameters.\n        use_consistent_tangent (bool): Flag to choose tangent stiffness.\n\n    Returns:\n        int: Number of iterations required for convergence.\n    \"\"\"\n    A = 1.0  # Area\n    L = 1.0  # Length\n    tol = 1.0e-10\n    max_iter = 50\n\n    # Material properties and elastic moduli\n    E, v, F = float(E), float(v), float(F)\n    if abs(1.0 - 2.0 * v)  1e-12 or abs(1.0 + v)  1e-12:\n        K = E / (3.0 * (1.0 - 2.0 * 0.49999999))\n    else:\n        K = E / (3.0 * (1.0 - 2.0 * v))\n        \n    mu = E / (2.0 * (1.0 + v))\n    M = K + 4.0 / 3.0 * mu\n\n    # Initial guess from linear elastic solution\n    u = (F * L) / (A * M)\n    \n    iterations = 0\n    \n    for i in range(max_iter + 1):\n        eps = u / L\n        sig11, consistent_tangent = stress_update(eps, E, v, sigy0, H)\n        \n        # Global residual\n        R = A * sig11 - F\n        \n        # Convergence check\n        if np.abs(R) = tol * max(1.0, np.abs(F)):\n            return iterations\n        \n        if i == max_iter:\n            break\n            \n        # Global tangent stiffness\n        if use_consistent_tangent:\n            KT = A * consistent_tangent / L\n        else: # Use elastic tangent\n            KT = A * M / L\n        \n        # Newton update\n        u = u - R / KT\n        iterations += 1\n\n    return iterations # Should be max_iter if loop finished without convergence\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (elastic, moderate compressibility)\n        {'E': 210e9, 'v': 0.3, 'sigy0': 250e6, 'H': 1e9, 'F': 349600000},\n        # Case 2 (perfect plasticity, moderate compressibility)\n        {'E': 210e9, 'v': 0.3, 'sigy0': 250e6, 'H': 0.0, 'F': 524400000},\n        # Case 3 (plastic, nearly incompressible)\n        {'E': 210e9, 'v': 0.4999, 'sigy0': 250e6, 'H': 1e9, 'F': 750000000000},\n        # Case 4 (perfect plasticity, nearly incompressible)\n        {'E': 210e9, 'v': 0.4999, 'sigy0': 250e6, 'H': 0.0, 'F': 750000000000},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        # Run with consistent tangent\n        iters_consistent = run_newton_solver(**params, use_consistent_tangent=True)\n        # Run with elastic tangent\n        iters_elastic = run_newton_solver(**params, use_consistent_tangent=False)\n        all_results.append([iters_consistent, iters_elastic])\n\n    print(f\"{all_results}\")\n\nsolve()\n```", "id": "3592675"}]}