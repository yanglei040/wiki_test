{"hands_on_practices": [{"introduction": "Before implementing a source in a simulation, it is crucial to understand its fundamental mathematical properties. This exercise involves an analytical derivation of the crest factor for a Gabor pulse, a key metric linking the peak amplitude of a signal to its effective energy. By completing this analysis, you will gain insight into how a source's waveform impacts the dynamic range requirements for achieving stable and accurate results in time-domain solvers [@problem_id:3310757].", "problem": "A Gaussian-modulated sinusoidal source (Gabor pulse) used as a broadband excitation in computational electromagnetics is defined by the real-valued waveform\n$$\ns(t) = \\exp\\!\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\!\\left(2\\pi f_{0} t\\right),\n$$\nwhere $f_{0}$ is the carrier frequency and $\\sigma$ is the temporal standard deviation of the Gaussian envelope. Consider the crest factor (peak-to-root-mean-square ratio) defined as the ratio of the peak amplitude to a root-mean-square value computed via a Gaussian-windowed time average appropriate for finite-energy pulses:\n$$\nC = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}, \\quad s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}.\n$$\nStarting only from the given definitions and standard integral identities for Gaussian functions, derive an exact closed-form expression for the crest factor $C$ as a function of the dimensionless parameter $f_{0}\\sigma$. Your derivation must be self-contained and must not assume any unproven intermediate formulas. Then, using your result, explain how the dependence of $C$ on $f_{0}\\sigma$ impacts the required dynamic range when exciting and recording fields in time-domain solvers such as Finite-Difference Time-Domain (FDTD), including any implications for numerical precision and stability.\n\nExpress your final answer as a single analytic expression in terms of $f_{0}\\sigma$ only. Do not include units in your final answer. No numerical approximation is required.", "solution": "The problem is valid as it is scientifically grounded in the principles of signal processing and computational electromagnetics, is well-posed with all necessary definitions provided, and is stated in objective, formal language. We may proceed with the solution.\n\nThe problem requires the derivation of the crest factor $C$ for a Gabor pulse and a discussion of its implications. The Gabor pulse is given by\n$$s(t) = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right)$$\nand the crest factor is defined as\n$$C = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}$$\nwhere the root-mean-square value $s_{\\mathrm{rms}}$ is defined by a Gaussian-windowed average:\n$$s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}$$\nOur derivation will proceed in two main steps: calculating the peak amplitude $\\max|s(t)|$ and calculating the RMS value $s_{\\mathrm{rms}}$.\n\n**Step 1: Calculation of the Peak Amplitude**\n\nThe peak amplitude is the maximum value of $|s(t)|$ over all $t \\in \\mathbb{R}$.\n$$|s(t)| = \\left| \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right| = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right) \\left|\\cos\\left(2\\pi f_{0} t\\right)\\right|$$\nThe term $\\exp(-t^{2}/(2\\sigma^{2}))$ is a Gaussian function, which has its unique maximum value of $1$ at $t=0$. For any $t \\neq 0$, its value is strictly less than $1$. The term $|\\cos(2\\pi f_{0} t)|$ is a periodic function with a maximum value of $1$. One of these maxima occurs at $t=0$.\nSince both terms achieve their maximum value of $1$ at the same point $t=0$, their product also achieves its global maximum at this point.\nTherefore, the peak amplitude is:\n$$\\max_{t\\in\\mathbb{R}} |s(t)| = |s(0)| = \\exp(0) \\cdot |\\cos(0)| = 1 \\cdot 1 = 1$$\n\n**Step 2: Calculation of the RMS Value**\n\nThe calculation of $s_{\\mathrm{rms}}$ requires the evaluation of two integrals. Let's denote the integral in the numerator as $I_{N}$ and the integral in the denominator as $I_{D}$.\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{I_{N}}{I_{D}}}$$\n\nFirst, we evaluate the denominator integral, $I_{D}$:\n$$I_{D} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t$$\nThis is a standard Gaussian integral of the form $\\int_{-\\infty}^{\\infty} \\exp(-at^{2}) \\mathrm{d}t = \\sqrt{\\pi/a}$. Here, $a=1/\\sigma^2$.\n$$I_{D} = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} = \\sqrt{\\pi\\sigma^{2}} = \\sigma\\sqrt{\\pi}$$\n\nNext, we evaluate the numerator integral, $I_{N}$:\n$$I_{N} = \\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t = \\int_{-\\infty}^{\\infty} \\left[ \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right]^{2} \\mathrm{d}t$$\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos^{2}\\left(2\\pi f_{0} t\\right)\\mathrm{d}t$$\nWe use the trigonometric identity $\\cos^{2}(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$. Let $\\theta = 2\\pi f_{0} t$.\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right) \\frac{1}{2}\\left[1 + \\cos\\left(4\\pi f_{0} t\\right)\\right]\\mathrm{d}t$$\nWe can split this into two integrals:\n$$I_{N} = \\frac{1}{2} \\left[ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t + \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t \\right]$$\nThe first integral is simply $I_{D} = \\sigma\\sqrt{\\pi}$. The second integral is a Fourier cosine transform of a Gaussian. We use the standard identity $\\int_{-\\infty}^{\\infty} \\exp(-at^{2})\\cos(bt)\\mathrm{d}t = \\sqrt{\\pi/a} \\exp(-b^{2}/(4a))$.\nFor this integral, we have $a=1/\\sigma^2$ and $b=4\\pi f_{0}$.\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\fract^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} \\exp\\left(-\\frac{(4\\pi f_{0})^{2}}{4(1/\\sigma^{2})}\\right) = \\sigma\\sqrt{\\pi} \\exp\\left(-\\frac{16\\pi^{2}f_{0}^{2}\\sigma^{2}}{4}\\right)$$\n$$= \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right)$$\nSubstituting this back into the expression for $I_{N}$:\n$$I_{N} = \\frac{1}{2} \\left[ \\sigma\\sqrt{\\pi} + \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right) \\right] = \\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n\nNow we can compute $s_{\\mathrm{rms}}^{2}$:\n$$s_{\\mathrm{rms}}^{2} = \\frac{I_{N}}{I_{D}} = \\frac{\\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]}{\\sigma\\sqrt{\\pi}} = \\frac{1}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\nTaking the square root gives $s_{\\mathrm{rms}}$:\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}$$\n\n**Step 3: Derivation of the Crest Factor C**\n\nFinally, we find the crest factor $C$ by substituting the peak amplitude and the RMS value into its definition:\n$$C = \\frac{\\max|s(t)|}{s_{\\mathrm{rms}}} = \\frac{1}{\\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}} = \\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}$$\nThis is the required closed-form expression for the crest factor $C$ as a function of the dimensionless parameter $f_{0}\\sigma$.\n\n**Discussion of Implications for Time-Domain Solvers (e.g., FDTD)**\n\nThe derived expression for the crest factor, $C(f_{0}\\sigma)$, reveals how the waveform's shape influences its numerical properties as a source in computational solvers. Let's analyze the behavior of $C$ in two limiting cases of the parameter $f_{0}\\sigma$, which represents the number of carrier cycles within the effective duration of the Gaussian envelope.\n\n1.  **Low-frequency or impulsive limit ($f_{0}\\sigma \\to 0$):**\n    As $f_{0}\\sigma \\to 0$, the exponential term $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to \\exp(0) = 1$.\n    $$C \\to \\sqrt{\\frac{2}{1+1}} = \\sqrt{1} = 1$$\n    This corresponds to a baseband Gaussian pulse (where $f_{0}=0$). A crest factor of $1$ implies the peak value is equal to the RMS value, which is characteristic of a constant (DC) signal. For the given pulse definition, $f_0=0$ yields $s(t) = \\exp(-t^2/(2\\sigma^2))$ and $s_{\\mathrm{rms}}=1$, leading to $C=1$.\n\n2.  **High-frequency or narrowband limit ($f_{0}\\sigma \\gg 1$):**\n    As $f_{0}\\sigma \\to \\infty$, the exponential term $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to 0$.\n    $$C \\to \\sqrt{\\frac{2}{1+0}} = \\sqrt{2}$$\n    This corresponds to a sinusoidal carrier modulated by a slowly varying Gaussian envelope, containing many cycles. The crest factor approaches $\\sqrt{2}$, which is precisely the crest factor of an ideal, un-windowed sinusoidal waveform ($\\cos(\\omega t)$).\n\nThe key insight is that the crest factor of a Gabor pulse is bounded: $1 \\le C \\le \\sqrt{2}$. This has important consequences for numerical methods like FDTD.\n\nIn a numerical simulation, the **dynamic range** refers to the ratio between the largest representable (non-overflow) value and the smallest discernible value above the numerical noise floor (due to round-off errors). The source waveform must be chosen to fit within this range.\n- The **peak amplitude** ($\\max|s(t)|$) determines the maximum field values generated in the simulation. This peak must be low enough to prevent floating-point overflow, which would cause catastrophic instability.\n- The **RMS value** ($s_{\\mathrm{rms}}$) is a measure of the effective amplitude and is related to the total energy of the pulse. This value must be large enough relative to the machine precision to ensure a good signal-to-noise ratio (SNR) in the recorded field data, which are later used for post-processing (e.g., Fourier transforms to find S-parameters).\n\nThe fact that $C \\le \\sqrt{2}$ is highly desirable. It means the peak amplitude is never more than about $1.414$ times the effective RMS amplitude. This is in contrast to other possible signals with very high crest factors (e.g., a train of sharp impulses), which would have very large peaks compared to their total energy content.\n\nFor a Gabor pulse, one can set the peak amplitude to a safe, high value (e.g., normalized to $1$) to maximize the injected energy. The resulting RMS value will be at worst $1/\\sqrt{2} \\approx 0.707$, which is still a substantial fraction of the peak value. This simultaneously ensures a high SNR and a low risk of overflow. The benign and bounded nature of its crest factor makes the Gabor pulse a numerically robust and \"friendly\" source for broadband excitation in FDTD and other time-domain methods, contributing to both the accuracy and stability of the simulation.", "answer": "$$\n\\boxed{\\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}}\n$$", "id": "3310757"}, {"introduction": "Translating a continuous mathematical function into a discrete sequence for a computer simulation involves practical trade-offs. This practice explores the fidelity of two common source generation methods: direct analytical evaluation at each time step versus the use of a computationally efficient lookup table. You will use the Hilbert transform to quantify the resulting amplitude and phase errors, revealing the practical challenges of signal generation near the Nyquist limit [@problem_id:3310788].", "problem": "You are to implement and compare two numerical representations of a Gaussian-envelope modulated sinusoidal source used for injecting a time-domain excitation in computational electromagnetics. One representation evaluates the source analytically at discrete time steps; the other uses a discrete-time lookup table of the sine function with quantized phase increments. Your task is to quantify phase error accumulation and amplitude fidelity for cases where the carrier angular frequency times the time step, $\\omega_c \\Delta t$, approaches the Nyquist limit.\n\nStart from the following base definitions and laws:\n- The Nyquist-Shannon sampling theorem guarantees that a band-limited continuous-time signal can be reconstructed from uniform samples when its highest frequency is less than half the sampling rate. In discrete time with sampling interval $\\Delta t$, the Nyquist angular frequency is $\\omega_N = \\pi / \\Delta t$.\n- A Gaussian envelope is defined as $A(t) = \\exp\\!\\left(-\\dfrac{(t - t_0)^2}{2\\sigma^2}\\right)$, with $t_0$ the center time and $\\sigma$ the standard deviation (width).\n- A modulated sinusoidal source is $s(t) = A(t)\\sin(\\omega_c t + \\phi_0)$, where $\\omega_c$ is the carrier angular frequency and $\\phi_0$ is the initial phase.\n- In discrete time, $t_n = n \\Delta t$ for integer $n$, and the analytic representation evaluates $s_n^{(a)} = A(t_n)\\sin(\\omega_c t_n + \\phi_0)$ exactly at the grid times.\n- A discrete-time lookup table representation uses $M$ uniformly spaced samples of the sine function over one period to approximate $\\sin(\\theta)$ by table lookup. Let the table be $\\mathrm{LUT}[k] = \\sin\\!\\left(\\dfrac{2\\pi k}{M}\\right)$ for $k = 0,1,\\dots,M-1$. The discrete phase increment per time step for the lookup is quantized by $K = \\mathrm{round}\\!\\left(\\dfrac{M\\,\\omega_c \\Delta t}{2\\pi}\\right)$, yielding a quantized increment $\\delta_{\\mathrm{hat}} = \\dfrac{2\\pi K}{M}$. The initial phase is quantized to $i_0 = \\mathrm{round}\\!\\left(\\dfrac{M\\,\\phi_0}{2\\pi}\\right)$. The lookup-driven signal is $s_n^{(\\ell)} = A(t_n)\\,\\mathrm{LUT}[(i_0 + nK)\\bmod M]$.\n\nTo assess fidelity, you must extract an instantaneous amplitude and phase from each discrete-time signal using the Hilbert transform. Define the analytic signal $z[n]$ of a real sequence $x[n]$ as the discrete-time complex signal obtained by applying the discrete Hilbert transform. The instantaneous amplitude is $|z[n]|$, and the instantaneous phase is the unwrapped argument $\\arg(z[n])$. For phase error computation, use the target phase $\\varphi_{\\mathrm{target}}[n] = \\omega_c t_n + \\phi_0$ and wrap the phase difference to the interval $(-\\pi, \\pi]$ prior to root-mean-square (RMS) computation to avoid spurious $2\\pi$ jumps. To focus on the region where modulation assumptions hold, restrict all error computations to samples where the envelope is not negligible. Specifically, define a mask selecting indices where $A(t_n) \\geq \\alpha\\,\\max_n A(t_n)$, with $\\alpha = 0.05$.\n\nCompute and report the following metrics for each signal:\n1. Amplitude fidelity as the relative RMS error between the Hilbert magnitude and the envelope,\n   $$E_{\\mathrm{amp}} = \\dfrac{\\sqrt{\\dfrac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}\\left(|z[n]| - A(t_n)\\right)^2}}{\\sqrt{\\dfrac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}A(t_n)^2}},$$\n   where $\\mathcal{I}$ indexes the masked samples and $N_{\\mathrm{mask}}$ is their count.\n2. Phase error accumulation as the RMS of the wrapped phase difference between the instantaneous phase and the target,\n   $$E_{\\mathrm{phase}} = \\sqrt{\\dfrac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}\\left(\\mathrm{wrap}\\!\\left(\\arg(z[n]) - \\varphi_{\\mathrm{target}}[n]\\right)\\right)^2},$$\n   where $\\mathrm{wrap}(\\theta)$ maps any real $\\theta$ to $(-\\pi, \\pi]$ by adding or subtracting integer multiples of $2\\pi$ as needed.\n\nUse the following fixed simulation parameters common to all test cases:\n- Time step $\\Delta t = 1.0\\times 10^{-10}$ seconds (expressed in seconds).\n- Number of samples $N = 8192$ (so total duration $T = N\\Delta t$).\n- Gaussian envelope center $t_0 = T/2$ and width $\\sigma = T/12$ (expressed in seconds).\n- Initial phase $\\phi_0 = 0.3$ radians (expressed in radians).\n- Envelope mask threshold fraction $\\alpha = 0.05$.\n\nDefine the carrier angular frequency by prescribing the dimensionless product $\\delta = \\omega_c \\Delta t$ for each case; then set $\\omega_c = \\delta / \\Delta t$.\n\nTest suite:\n- Case 1 (general case): $\\delta = 0.6\\pi$, $M = 1024$.\n- Case 2 (near Nyquist, coarse lookup): $\\delta = 0.99\\pi$, $M = 256$.\n- Case 3 (lower carrier, very coarse lookup): $\\delta = 0.2\\pi$, $M = 64$.\n- Case 4 (near Nyquist, fine lookup): $\\delta = 0.95\\pi$, $M = 8192$.\n\nFor each case, compute and return four floats:\n- $E_{\\mathrm{amp}}^{(a)}$ for the analytic drive $s_n^{(a)}$,\n- $E_{\\mathrm{amp}}^{(\\ell)}$ for the lookup drive $s_n^{(\\ell)}$,\n- $E_{\\mathrm{phase}}^{(a)}$ for the analytic drive $s_n^{(a)}$,\n- $E_{\\mathrm{phase}}^{(\\ell)}$ for the lookup drive $s_n^{(\\ell)}$.\n\nAngles must be handled in radians. Amplitude is dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the four floats in the order specified above. For example, the format should be\n$[\\,[e_{1,a},e_{1,\\ell},p_{1,a},p_{1,\\ell}],\\,[e_{2,a},e_{2,\\ell},p_{2,a},p_{2,\\ell}],\\,\\dots\\,]$,\nwith each $e$ and $p$ rendered as a standard floating-point representation.", "solution": "The problem requires a comparative analysis of two methods for generating a discrete-time Gaussian-modulated sinusoidal source signal, a common task in computational electromagnetics simulations (e.g., Finite-Difference Time-Domain, FDTD). The first method is the direct analytical evaluation of the source function at discrete time steps. The second method employs a pre-computed lookup table (LUT) for the sine function, which can offer computational performance gains at the cost of introducing quantization errors. We are tasked with quantifying the fidelity of each method in terms of amplitude and phase, particularly as the carrier frequency approaches the Nyquist limit.\n\nThe solution proceeds systematically by first defining the simulation parameters and time grid. Then, for each test case, we generate the two discrete-time signals. Subsequently, we apply the discrete Hilbert transform to each signal to extract its instantaneous amplitude and phase. Finally, we compute the specified error metrics against the ideal theoretical envelope and phase evolution.\n\n**1. Signal Generation**\n\nFirst, we establish the common simulation parameters. The time step is $\\Delta t = 1.0 \\times 10^{-10} \\, \\text{s}$ and the number of samples is $N = 8192$. This defines a time vector $t_n = n \\Delta t$ for $n = 0, 1, \\dots, N-1$, with a total duration of $T = N \\Delta t = 8.192 \\times 10^{-7} \\, \\text{s}$. The Gaussian envelope is centered at $t_0 = T/2$ with a width of $\\sigma = T/12$. The envelope function is thus:\n$$\nA(t_n) = \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2\\sigma^2}\\right)\n$$\nThe carrier angular frequency $\\omega_c$ is determined for each test case from the dimensionless product $\\delta = \\omega_c \\Delta t$, so $\\omega_c = \\delta / \\Delta t$. The initial phase is fixed at $\\phi_0 = 0.3$ radians.\n\n**a. Analytic Signal, $s_n^{(a)}$**\n\nThe first signal, referred to as the analytic drive, is generated by directly evaluating the continuous-time source function at each discrete time point $t_n$:\n$$\ns_n^{(a)} = A(t_n) \\sin(\\omega_c t_n + \\phi_0)\n$$\nThis representation serves as a high-precision baseline, though it is not entirely error-free in a discrete-time context due to spectral effects inherent to sampling, which become pronounced near the Nyquist limit.\n\n**b. Lookup Table Signal, $s_n^{(\\ell)}$**\n\nThe second signal is generated using a lookup table for the sine function. This approach introduces two primary sources of quantization error: phase increment quantization and phase-to-index quantization.\n\nFirst, a sine lookup table of size $M$ is created:\n$$\n\\mathrm{LUT}[k] = \\sin\\left(\\frac{2\\pi k}{M}\\right), \\quad k = 0, 1, \\dots, M-1\n$$\nThe phase of the carrier evolves by $\\omega_c \\Delta t$ at each time step. To use the LUT, this continuous increment must be mapped to a discrete number of table indices. This is done by calculating the integer index increment $K$:\n$$\nK = \\mathrm{round}\\left(\\frac{M \\omega_c \\Delta t}{2\\pi}\\right) = \\mathrm{round}\\left(\\frac{M \\delta}{2\\pi}\\right)\n$$\nSimilarly, the initial phase $\\phi_0$ is quantized to an initial table index $i_0$:\n$$\ni_0 = \\mathrm{round}\\left(\\frac{M \\phi_0}{2\\pi}\\right)\n$$\nThe phase at time step $n$ is then approximated by the table index $(i_0 + nK) \\bmod M$. The LUT-driven signal is then constructed as:\n$$\ns_n^{(\\ell)} = A(t_n) \\cdot \\mathrm{LUT}[(i_0 + nK) \\bmod M]\n$$\nThe accumulated phase error in this method arises from the difference between the true phase increment $\\omega_c \\Delta t$ and the quantized one, $\\delta_{\\mathrm{hat}} = 2\\pi K / M$.\n\n**2. Fidelity Analysis**\n\nTo quantify the fidelity, we must extract the instantaneous amplitude and phase from the generated discrete-time signals $s_n^{(a)}$ and $s_n^{(\\ell)}$. This is achieved using the analytic signal representation, which is computed via the discrete Hilbert transform. For a real signal $x[n]$, its analytic signal is $z[n] = x[n] + j\\mathcal{H}\\{x[n]\\}$, where $\\mathcal{H}$ is the discrete Hilbert transform operator.\n\nThe instantaneous amplitude is the magnitude of the analytic signal, $|z[n]|$, and the instantaneous phase is its unwrapped angle, $\\arg(z[n])$.\n\nAll error computations are restricted to the significant portion of the pulse, defined by a mask $\\mathcal{I}$ corresponding to time steps where the envelope $A(t_n)$ is at least $5\\%$ of its maximum value ($\\alpha = 0.05$). Since the Gaussian is centered, its maximum is $A(t_0) = 1$, so the condition is $A(t_n) \\geq 0.05$.\n\n**a. Amplitude Fidelity, $E_{\\mathrm{amp}}$**\n\nThe amplitude fidelity is measured by the relative root-mean-square (RMS) error between the extracted instantaneous amplitude $|z[n]|$ and the ideal Gaussian envelope $A(t_n)$ over the masked region.\n$$\nE_{\\mathrm{amp}} = \\frac{\\sqrt{\\frac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}\\left(|z[n]| - A(t_n)\\right)^2}}{\\sqrt{\\frac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}A(t_n)^2}}\n$$\nwhere $N_{\\mathrm{mask}}$ is the number of samples in the masked set $\\mathcal{I}$. This metric quantifies how well the signal's envelope is preserved.\n\n**b. Phase Error, $E_{\\mathrm{phase}}$**\n\nThe phase error measures the deviation of the extracted instantaneous phase from the ideal linear phase progression $\\varphi_{\\mathrm{target}}[n] = \\omega_c t_n + \\phi_0$. To handle the periodic nature of phase, the difference is wrapped to the interval $(-\\pi, \\pi]$ before calculating the RMS error.\n$$\n\\Delta\\varphi_n = \\mathrm{wrap}(\\arg(z[n]) - \\varphi_{\\mathrm{target}}[n])\n$$\nThe wrapping function $\\mathrm{wrap}(\\theta)$ is implemented as $(\\theta + \\pi) \\pmod{2\\pi} - \\pi$. The phase error metric is then:\n$$\nE_{\\mathrm{phase}} = \\sqrt{\\frac{1}{N_{\\mathrm{mask}}}\\sum_{n\\in\\mathcal{I}}(\\Delta\\varphi_n)^2}\n$$\nThis metric is sensitive to both the systematic drift from phase increment quantization (in the LUT case) and the noise-like errors arising from spectral distortion and aliasing.\n\nThe implementation will loop through the four specified test cases, performing these calculations for both $s_n^{(a)}$ and $s_n^{(\\ell)}$ in each case to generate the required eight error metrics per case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing analytic and LUT-based signal generation\n    by calculating amplitude and phase fidelity metrics for several test cases.\n    \"\"\"\n\n    # --- Fixed Simulation Parameters ---\n    DT = 1.0e-10  # Time step in seconds\n    N = 8192      # Number of samples\n    PHI0 = 0.3    # Initial phase in radians\n    ALPHA = 0.05  # Envelope mask threshold fraction\n\n    # --- Derived Parameters ---\n    T_total = N * DT\n    t0 = T_total / 2\n    sigma = T_total / 12\n    t = np.arange(N) * DT\n\n    # --- Gaussian Envelope ---\n    A = np.exp(-((t - t0)**2) / (2 * sigma**2))\n\n    # --- Analysis Mask ---\n    # The maximum of the envelope is 1.0 at t=t0.\n    mask = A = ALPHA\n\n    def calculate_metrics(signal, envelope, wc, t_vec, phi0, mask_vec):\n        \"\"\"\n        Calculates amplitude and phase error metrics for a given signal.\n        \"\"\"\n        # 1. Compute analytic signal via Hilbert transform\n        z = hilbert(signal)\n        \n        # 2. Extract instantaneous amplitude and phase\n        inst_amp = np.abs(z)\n        inst_phase = np.unwrap(np.angle(z))\n\n        # 3. Apply mask\n        inst_amp_masked = inst_amp[mask_vec]\n        envelope_masked = envelope[mask_vec]\n        \n        # 4. Calculate Amplitude Fidelity (E_amp)\n        # This is the relative RMS error.\n        rms_amp_error = np.sqrt(np.mean((inst_amp_masked - envelope_masked)**2))\n        rms_envelope = np.sqrt(np.mean(envelope_masked**2))\n        E_amp = rms_amp_error / rms_envelope if rms_envelope  0 else 0.0\n        \n        # 5. Calculate Phase Error (E_phase)\n        # Target phase evolution\n        target_phase = wc * t_vec + phi0\n        \n        # Phase difference, wrapped to (-pi, pi]\n        phase_diff = inst_phase - target_phase\n        wrapped_phase_diff = (phase_diff + np.pi) % (2 * np.pi) - np.pi\n        \n        # Apply mask and compute RMS error\n        wrapped_phase_diff_masked = wrapped_phase_diff[mask_vec]\n        E_phase = np.sqrt(np.mean(wrapped_phase_diff_masked**2))\n\n        return E_amp, E_phase\n\n    # --- Test Suite ---\n    test_cases = [\n        # (delta, M)\n        (0.6 * np.pi, 1024),   # Case 1\n        (0.99 * np.pi, 256),   # Case 2\n        (0.2 * np.pi, 64),     # Case 3\n        (0.95 * np.pi, 8192),  # Case 4\n    ]\n\n    all_results = []\n    for delta, M in test_cases:\n        # --- Case-Specific Parameter ---\n        wc = delta / DT\n\n        # --- Signal Generation ---\n        \n        # 1. Analytic Signal (s_a)\n        s_a = A * np.sin(wc * t + PHI0)\n\n        # 2. Lookup Table Signal (s_l)\n        # Create LUT\n        lut_indices = np.arange(M)\n        sine_lut = np.sin(2 * np.pi * lut_indices / M)\n        \n        # Quantize phase increment and initial phase\n        K = int(np.round(M * delta / (2 * np.pi)))\n        i0 = int(np.round(M * PHI0 / (2 * np.pi)))\n        \n        # Generate signal using LUT\n        n_indices = np.arange(N)\n        s_l_indices = (i0 + n_indices * K) % M\n        s_l = A * sine_lut[s_l_indices]\n\n        # --- Calculate Metrics for Both Signals ---\n        E_amp_a, E_phase_a = calculate_metrics(s_a, A, wc, t, PHI0, mask)\n        E_amp_l, E_phase_l = calculate_metrics(s_l, A, wc, t, PHI0, mask)\n        \n        case_results = [E_amp_a, E_amp_l, E_phase_a, E_phase_l]\n        all_results.append(case_results)\n\n    # --- Final Output Formatting ---\n    # The explicit string conversion ensures the required format '[...], [...]'\n    result_str = ','.join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```", "id": "3310788"}, {"introduction": "The characteristics of a source signal, especially its bandwidth, have profound consequences for the total computational cost of a simulation. This practice guides you through building an operation-count model to analyze how the workload of two powerful algorithms, Pseudo-Spectral Time-Domain (PSTD) and Finite-Difference Time-Domain (FDTD), scales with the source's maximum frequency. This type of analysis is essential for making informed decisions about which numerical method is best suited for a given problem and for predicting performance on large-scale computations [@problem_id:3310734].", "problem": "A one-dimensional time-domain electromagnetic simulation of a Gaussian-modulated sinusoidal source must be designed to generate broadband excitations and to benchmark algorithmic workloads for two classes of solvers: Pseudo-Spectral Time-Domain (PSTD) using the Fast Fourier Transform (FFT) and Finite-Difference Time-Domain (FDTD) with an Auxiliary Differential Equation (ADE) for a single-pole Debye dispersion. The goal is to quantify how the total computational workload scales with the source bandwidth when the discretization is chosen to resolve the highest significant frequency content of the pulse. The problem must be solved from first principles of wave propagation and sampling constraints, and the algorithmic workload must be defined in terms of elementary operation counts without relying on empirical timings.\n\nAssume a one-dimensional vacuum domain of length $L$ with speed of light $c$, and a time-domain source of the form $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$ for center frequency $f_{0}$ and temporal standard deviation $\\sigma_{t}$. From Fourier analysis, the positive-frequency spectrum of the Gaussian-modulated sinusoid is Gaussian with standard deviation $\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}$ centered at $f_{0}$. To ensure negligible spectral truncation, define the maximum design frequency as $f_{\\max} = f_{0} + m\\,\\sigma_{f}$ for a fixed $m$. The discretization must satisfy two constraints that are standard in time-domain electromagnetics: a minimum number of spatial points per minimum wavelength and a Courant stability bound on the time step. Specifically, let the minimum resolvable wavelength be $\\lambda_{\\min} = \\frac{c}{f_{\\max}}$, enforce $p$ points per $\\lambda_{\\min}$ so that $\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}$, and choose a time step $\\Delta t = S \\frac{\\Delta x}{c}$ with Courant number $S \\in (0,1)$. Consider a total simulated time window $T_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}$, where $q$ is a fixed multiple of the temporal standard deviation chosen to capture essentially all pulse energy and the traversal time across the domain. Let the number of spatial samples be $N = \\lceil \\frac{L}{\\Delta x} \\rceil$, the number of time steps be $N_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil$, and the FFT grid size be $N_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}$ (the smallest power of two not less than $N$) to stress FFT workloads.\n\nDefine an operation-count model in which one operation unit is one floating-point addition or multiplication. For the PSTD solver, model each time step as completing a fixed number of complex FFTs of length $N_{\\text{fft}}$; assume there are $n_{\\text{fft}}$ such transforms per time step, and that one length-$N_{\\text{fft}}$ complex FFT costs $k_{\\text{fft}}\\,N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$ operation units. Thus, the total PSTD workload is the product of the per-step FFT cost and the number of steps. For the ADE-FDTD solver with a single-pole Debye polarization, model the per-cell, per-time-step workload as a constant $k_{\\text{cell}}$ operation units accounting for one magnetic field update, one polarization update, and one electric field update. Thus, the total ADE-FDTD workload is the per-cell cost times $N$ times $N_{t}$.\n\nAll physical constants and modeling parameters are to be treated as given constants:\n- Speed of light: $c = 299792458$ in $\\text{m/s}$.\n- Domain length: $L = 1.0$ in $\\text{m}$.\n- Points per minimum wavelength: $p = 12$.\n- Spectral truncation multiple: $m = 4$.\n- Courant number: $S = 0.99$.\n- Time-window multiple: $q = 6$.\n- FFT cost coefficient: $k_{\\text{fft}} = 5$.\n- Number of complex FFTs per time step in PSTD: $n_{\\text{fft}} = 4$.\n- ADE-FDTD per-cell cost: $k_{\\text{cell}} = 12$.\n\nUsing these constants and the definitions above, compute the following for each test case in the test suite:\n- The total PSTD workload $W_{\\text{PSTD}}$ in operation units.\n- The total ADE-FDTD workload $W_{\\text{ADE}}$ in operation units.\n\nAdditionally, across the entire test suite, compute two scaling exponents by least-squares fit on a log-log scale:\n- The slope $s_{\\text{PSTD}}$ of $\\log W_{\\text{PSTD}}$ versus $\\log f_{\\max}$.\n- The slope $s_{\\text{ADE}}$ of $\\log W_{\\text{ADE}}$ versus $\\log f_{\\max}$.\n\nThe test suite consists of four cases, all with the units specified explicitly:\n1. Case A (moderately broadband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.0000000005$ in $\\text{s}$.\n2. Case B (strongly broadband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.00000000005$ in $\\text{s}$.\n3. Case C (ultra-broadband, baseband Gaussian): $f_{0} = 0$ in $\\text{Hz}$, $\\sigma_{t} = 0.00000000002$ in $\\text{s}$.\n4. Case D (narrowband, modulated): $f_{0} = 3000000000$ in $\\text{Hz}$, $\\sigma_{t} = 0.000000005$ in $\\text{s}$.\n\nYour program must compute, for each case in the order A, B, C, D, the pair of workloads $\\left(W_{\\text{PSTD}}, W_{\\text{ADE}}\\right)$ using the definitions and constants above. Then compute the two slopes $s_{\\text{PSTD}}$ and $s_{\\text{ADE}}$ using all four cases. Report the workloads as integers (operation units) and the slopes as decimal numbers rounded to three decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$\\left[W_{\\text{PSTD}}^{(A)}, W_{\\text{ADE}}^{(A)}, W_{\\text{PSTD}}^{(B)}, W_{\\text{ADE}}^{(B)}, W_{\\text{PSTD}}^{(C)}, W_{\\text{ADE}}^{(C)}, W_{\\text{PSTD}}^{(D)}, W_{\\text{ADE}}^{(D)}, s_{\\text{PSTD}}, s_{\\text{ADE}}\\right]$.\nAll workloads are unitless operation counts; no physical unit is required on the output, and angles do not appear. The slopes must be expressed as decimals (not percentages).", "solution": "The problem requires the calculation of computational workloads for two numerical methods in electromagnetics, Pseudo-Spectral Time-Domain (PSTD) and Finite-Difference Time-Domain with an Auxiliary Differential Equation (ADE-FDTD), under various source conditions. Furthermore, it requires an analysis of how these workloads scale with the maximum frequency content of the source. The solution is derived from first principles of wave theory, numerical discretization, and algorithmic complexity analysis as specified.\n\nThe process begins by calculating the necessary simulation parameters from the given physical source parameters for each test case.\nThe source is a Gaussian-modulated sinusoid, $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2pi f_{0} t)$, with a center frequency $f_{0}$ and temporal standard deviation $\\sigma_{t}$. Its spectral properties determine the simulation requirements. The standard deviation of the pulse's spectrum in the frequency domain, $\\sigma_{f}$, is inversely related to its temporal standard deviation:\n$$\n\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}\n$$\nTo accurately capture the pulse's energy, the simulation must resolve frequencies up to a maximum design frequency, $f_{\\max}$. This is defined by extending from the center frequency by a multiple $m$ of the spectral standard deviation:\n$$\nf_{\\max} = f_{0} + m\\,\\sigma_{f}\n$$\nWith $f_{\\max}$ established, we can determine the required spatial and temporal discretization. For a numerical method to be stable and accurate, its grid must resolve the smallest wavelength present, $\\lambda_{\\min} = c/f_{\\max}$. The spatial step size, $\\Delta x$, is set to be a fraction of this minimum wavelength, controlled by the parameter $p$ (points per wavelength):\n$$\n\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}\n$$\nThe total number of spatial grid points, $N$, is then found by dividing the domain length $L$ by $\\Delta x$ and taking the ceiling to ensure the entire domain is covered:\n$$\nN = \\left\\lceil \\frac{L}{\\Delta x} \\right\\rceil = \\left\\lceil \\frac{L\\,p\\,f_{\\max}}{c} \\right\\rceil\n$$\nThe time step, $\\Delta t$, is constrained by the Courant-Friedrichs-Lewy (CFL) stability condition. It is related to $\\Delta x$ via the Courant number $S$:\n$$\n\\Delta t = S \\frac{\\Delta x}{c} = S \\frac{1}{p\\,f_{\\max}}\n$$\nThe total simulation duration, $T_{\\text{tot}}$, must be long enough for the wave to propagate across the domain (time $L/c$) and for the significant portion of the pulse's temporal envelope to pass, which is estimated as a multiple $q$ of $\\sigma_{t}$:\n$$\nT_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}\n$$\nThe total number of time steps, $N_{t}$, is then the total duration divided by the time step size, again taking the ceiling:\n$$\nN_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil = \\left\\lceil \\left(\\frac{L}{c} + q\\,\\sigma_{t}\\right) \\frac{p\\,f_{\\max}}{S} \\right\\rceil\n$$\nFor the PSTD method, which relies on the Fast Fourier Transform (FFT), performance is optimal when the grid size is a power of two. Therefore, the computational grid size for the FFT, $N_{\\text{fft}}$, is defined as the smallest power of two that is not less than $N$:\n$$\nN_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}\n$$\nWith these numerical parameters ($N, N_{t}, N_{\\text{fft}}$) derived, we can apply the given operation-count models to find the workloads.\nThe PSTD workload, $W_{\\text{PSTD}}$, is modeled as the total number of time steps, $N_t$, multiplied by the cost per time step. The cost per step is determined by the number of FFTs, $n_{\\text{fft}}$, the cost coefficient, $k_{\\text{fft}}$, and the complexity of a single FFT of size $N_{\\text{fft}}$, which is $N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$:\n$$\nW_{\\text{PSTD}} = N_{t} \\cdot n_{\\text{fft}} \\cdot k_{\\text{fft}} \\cdot N_{\\text{fft}} \\log_{2} N_{\\text{fft}}\n$$\nThe ADE-FDTD workload, $W_{\\text{ADE}}$, is a simpler volume-of-computation model. It is the product of the per-cell update cost, $k_{\\text{cell}}$, the number of spatial cells, $N$, and the number of time steps, $N_t$:\n$$\nW_{\\text{ADE}} = k_{\\text{cell}} \\cdot N \\cdot N_{t}\n$$\nFinally, to analyze the scaling of these workloads with respect to the maximum frequency, we assume a power-law relationship $W \\propto (f_{\\max})^s$. Taking the logarithm of both sides yields $\\log W = s \\log f_{\\max} + \\log(\\text{constant})$, which is a linear equation. The scaling exponent, $s$, is the slope of the best-fit line to the data points $(\\log f_{\\max}^{(i)}, \\log W^{(i)})$ for each test case $i$. This slope is calculated using a standard linear least-squares regression. The formula for the slope $s$ given a set of points $(x_i, y_i)$ is:\n$$\ns = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum (x_i - \\bar{x})^2}\n$$\nwhere $x_i = \\log f_{\\max}^{(i)}$ and $y_i = \\log W^{(i)}$. This procedure is applied separately to the datasets for $W_{\\text{PSTD}}$ and $W_{\\text{ADE}}$ to find the exponents $s_{\\text{PSTD}}$ and $s_{\\text{ADE}}$.\n\nThe provided constants are: $c = 299792458$, $L=1.0$, $p=12$, $m=4$, $S=0.99$, $q=6$, $k_{\\text{fft}}=5$, $n_{\\text{fft}}=4$, and $k_{\\text{cell}}=12$. These values, along with the parameters for each test case, are substituted into the above formulas to compute the final results. All workload results are converted to integers, and the slopes are rounded to three decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics workload problem.\n\n    This function calculates the computational workloads for PSTD and ADE-FDTD methods\n    for a set of test cases involving Gaussian-modulated sinusoidal sources. It then\n    computes the scaling exponents of these workloads with respect to the maximum\n    simulation frequency using a log-log linear least-squares fit.\n    \"\"\"\n\n    # Define physical constants and modeling parameters.\n    c = 299792458       # Speed of light in m/s\n    L = 1.0             # Domain length in m\n    p = 12              # Points per minimum wavelength\n    m = 4               # Spectral truncation multiple\n    S = 0.99            # Courant number\n    q = 6               # Time-window multiple\n    k_fft = 5           # FFT cost coefficient\n    n_fft = 4           # Number of complex FFTs per time step in PSTD\n    k_cell = 12         # ADE-FDTD per-cell cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f0 in Hz, sigma_t in s)\n        (3.0e9, 5.0e-10),  # Case A\n        (3.0e9, 5.0e-11),  # Case B\n        (0.0,   2.0e-11),  # Case C\n        (3.0e9, 5.0e-9),   # Case D\n    ]\n\n    results = []\n    log_fmax_list = []\n    log_w_pstd_list = []\n    log_w_ade_list = []\n\n    for f0, sigma_t in test_cases:\n        # Step 1: Calculate maximum frequency\n        sigma_f = 1 / (2 * np.pi * sigma_t)\n        f_max = f0 + m * sigma_f\n\n        # Step 2: Calculate discretization parameters\n        delta_x = c / (p * f_max)\n        # This is equivalent to S * delta_x / c\n        delta_t = S / (p * f_max)\n\n        # Step 3: Calculate grid and time dimensions\n        N = int(np.ceil(L / delta_x))\n        T_tot = L / c + q * sigma_t\n        N_t = int(np.ceil(T_tot / delta_t))\n\n        # Step 4: Calculate FFT grid size\n        if N = 1:\n            log2_N_ceil = 0 if N == 0 else 1\n        else:\n            log2_N_ceil = int(np.ceil(np.log2(N)))\n        N_fft = 1  log2_N_ceil # Efficient way to compute 2^log2_N_ceil\n\n        # Step 5: Calculate workloads\n        W_pstd = N_t * n_fft * k_fft * N_fft * log2_N_ceil\n        W_ade = k_cell * N * N_t\n        \n        results.extend([int(W_pstd), int(W_ade)])\n\n        # Step 6: Store log values for regression\n        log_fmax_list.append(np.log(f_max))\n        # Add a small epsilon to workloads that could be zero to avoid log(0)\n        # In this problem, workloads are guaranteed to be positive.\n        log_w_pstd_list.append(np.log(W_pstd))\n        log_w_ade_list.append(np.log(W_ade))\n\n    # Step 7: Compute scaling exponents using least-squares fit on log-log data\n    # np.polyfit(x, y, 1) returns [slope, intercept] for the best-fit line.\n    slope_pstd, _ = np.polyfit(log_fmax_list, log_w_pstd_list, 1)\n    slope_ade, _ = np.polyfit(log_fmax_list, log_w_ade_list, 1)\n\n    results.extend([round(slope_pstd, 3), round(slope_ade, 3)])\n    \n    # Final print statement in the exact required format.\n    # Convert all numbers to string before joining\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310734"}]}