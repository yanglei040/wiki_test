{"hands_on_practices": [{"introduction": "The foundation of the Finite Element Method (FEM) for electromagnetics lies in the choice of basis functions used to approximate the fields. This exercise provides a foundational workout, guiding you through the construction of first-kind Nédélec \"edge\" elements, the vector basis functions that are fundamental to $H(\\mathrm{curl})$-conforming discretizations. By deriving these functions from first principles on a reference tetrahedron and using them for interpolation, you will gain a deep, practical understanding of how vector fields are represented locally and why these specific functions are crucial for correctly modeling electromagnetic phenomena [@problem_id:3329964].", "problem": "Consider a single tetrahedral element used in the Finite Element Method (FEM) for Computational Electromagnetics (CEM). Let the reference tetrahedron have vertices at $v_{1} = (0,0,0)$, $v_{2} = (1,0,0)$, $v_{3} = (0,1,0)$, and $v_{4} = (0,0,1)$, with the six oriented edges taken as $(1,2)$, $(1,3)$, $(1,4)$, $(2,3)$, $(2,4)$, and $(3,4)$, each oriented from the lower-index vertex to the higher-index vertex. Let the barycentric coordinates be $\\lambda_{1} = 1 - x - y - z$, $\\lambda_{2} = x$, $\\lambda_{3} = y$, and $\\lambda_{4} = z$, with corresponding constant gradients $\\nabla \\lambda_{1}$, $\\nabla \\lambda_{2}$, $\\nabla \\lambda_{3}$, and $\\nabla \\lambda_{4}$.\n\nThe first-kind Nédélec edge-based $H(\\mathrm{curl})$-conforming basis of order $1$ on a tetrahedron is characterized by vector shape functions associated to edges, each possessing a unit tangential line integral along its associated oriented edge and vanishing tangential line integrals on all other edges. Using only these defining properties and the structure provided by barycentric coordinates, perform the following:\n\n1. Construct the explicit local edge-based vector shape functions for the six oriented edges of the reference tetrahedron. Your construction must be derived from first principles based on barycentric coordinates and their gradients, and must satisfy the defining tangential integral properties of first-kind Nédélec functions.\n\n2. For each constructed shape function, compute its tangential trace on every oriented edge and show that the line integrals of the tangential component produce the Kronecker delta property across all six edges.\n\n3. Let the linear vector field be\n$$\n\\boldsymbol{E}(x,y,z) = \\begin{pmatrix}\nx + 2y + 3z + 1 \\\\\n2x + 3y + z + 2 \\\\\n3x + y + 2z + 3\n\\end{pmatrix}.\n$$\nCompute its first-kind Nédélec interpolation on the reference tetrahedron by evaluating the six edge degrees of freedom (DoF), namely the oriented tangential line integrals $\\int_{e_{ij}} \\boldsymbol{E} \\cdot \\hat{\\boldsymbol{t}}_{ij} \\, \\mathrm{d}s$ for the edges $(i,j) \\in \\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\\}$, where $\\hat{\\boldsymbol{t}}_{ij}$ denotes the unit tangent vector along the edge from $v_{i}$ to $v_{j}$. Then express the interpolant as a linear combination of your six edge shape functions with these coefficients.\n\nReport as your final answer the ordered row matrix of the six interpolation coefficients $(c_{12}, c_{13}, c_{14}, c_{23}, c_{24}, c_{34})$, with exact values and no rounding. There are no physical units in this problem.", "solution": "The user has provided a valid, well-posed problem from the field of computational electromagnetics. The problem requires the construction and verification of first-kind Nédélec basis functions on a reference tetrahedron and the subsequent interpolation of a given vector field. The solution will proceed in three parts as requested.\n\nThe reference tetrahedron has vertices $v_{1} = (0,0,0)$, $v_{2} = (1,0,0)$, $v_{3} = (0,1,0)$, and $v_{4} = (0,0,1)$. The barycentric coordinates are given as $\\lambda_{1} = 1 - x - y - z$, $\\lambda_{2} = x$, $\\lambda_{3} = y$, and $\\lambda_{4} = z$. A position vector in the tetrahedron is $\\boldsymbol{r} = (x,y,z)$.\n\n### Part 1: Construction of Edge-Based Vector Shape Functions\n\nThe first-kind Nédélec vector basis functions of order $1$ for an edge $e_{ij}$ connecting vertices $v_i$ and $v_j$ are constructed using the barycentric coordinates $\\lambda_i, \\lambda_j$ and their gradients. The general form is:\n$$\n\\boldsymbol{N}_{ij}(\\boldsymbol{r}) = \\lambda_i(\\boldsymbol{r}) \\nabla \\lambda_j(\\boldsymbol{r}) - \\lambda_j(\\boldsymbol{r}) \\nabla \\lambda_i(\\boldsymbol{r})\n$$\nThis form ensures that the tangential component of $\\boldsymbol{N}_{ij}$ is continuous across element faces and that $\\mathrm{curl}(\\boldsymbol{N}_{ij})$ is a constant vector, which are key properties for $H(\\mathrm{curl})$-conforming elements.\n\nFirst, we compute the gradients of the barycentric coordinates:\n$$\n\\nabla\\lambda_{1} = \\nabla(1 - x - y - z) = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix}\n$$\n$$\n\\nabla\\lambda_{2} = \\nabla(x) = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\nabla\\lambda_{3} = \\nabla(y) = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n$$\n\\nabla\\lambda_{4} = \\nabla(z) = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\nNow, we construct the $6$ basis functions for the oriented edges $(i,j)$ with $i<j$:\n\n1.  **Edge $e_{12}$:** From $v_1$ to $v_2$.\n    $$\n    \\boldsymbol{N}_{12} = \\lambda_1 \\nabla \\lambda_2 - \\lambda_2 \\nabla \\lambda_1 = (1-x-y-z)\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - x\\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1-y-z \\\\ x \\\\ x \\end{pmatrix}\n    $$\n2.  **Edge $e_{13}$:** From $v_1$ to $v_3$.\n    $$\n    \\boldsymbol{N}_{13} = \\lambda_1 \\nabla \\lambda_3 - \\lambda_3 \\nabla \\lambda_1 = (1-x-y-z)\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} - y\\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} y \\\\ 1-x-z \\\\ y \\end{pmatrix}\n    $$\n3.  **Edge $e_{14}$:** From $v_1$ to $v_4$.\n    $$\n    \\boldsymbol{N}_{14} = \\lambda_1 \\nabla \\lambda_4 - \\lambda_4 \\nabla \\lambda_1 = (1-x-y-z)\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - z\\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} z \\\\ z \\\\ 1-x-y \\end{pmatrix}\n    $$\n4.  **Edge $e_{23}$:** From $v_2$ to $v_3$.\n    $$\n    \\boldsymbol{N}_{23} = \\lambda_2 \\nabla \\lambda_3 - \\lambda_3 \\nabla \\lambda_2 = x\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} - y\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -y \\\\ x \\\\ 0 \\end{pmatrix}\n    $$\n5.  **Edge $e_{24}$:** From $v_2$ to $v_4$.\n    $$\n    \\boldsymbol{N}_{24} = \\lambda_2 \\nabla \\lambda_4 - \\lambda_4 \\nabla \\lambda_2 = x\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - z\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -z \\\\ 0 \\\\ x \\end{pmatrix}\n    $$\n6.  **Edge $e_{34}$:** From $v_3$ to $v_4$.\n    $$\n    \\boldsymbol{N}_{34} = \\lambda_3 \\nabla \\lambda_4 - \\lambda_4 \\nabla \\lambda_3 = y\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - z\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ -z \\\\ y \\end{pmatrix}\n    $$\n\n### Part 2: Verification of the Kronecker Delta Property\n\nThe defining property of these basis functions is that the line integral of the tangential component of $\\boldsymbol{N}_{ij}$ along any edge $e_{kl}$ is equal to the Kronecker delta $\\delta_{ij,kl}$:\n$$\n\\int_{e_{kl}} \\boldsymbol{N}_{ij} \\cdot \\hat{\\boldsymbol{t}}_{kl} \\, \\mathrm{d}s = 1 \\text{ if } e_{kl} = e_{ij}, \\text{ and } 0 \\text{ otherwise.}\n$$\nLet $\\boldsymbol{e}_{kl} = v_l - v_k$ be the vector for edge $e_{kl}$. Since barycentric coordinates are linear functions of position, the directional derivative of $\\lambda_m$ along $\\boldsymbol{e}_{kl}$ is constant and given by $\\nabla\\lambda_m \\cdot \\boldsymbol{e}_{kl}$. This value is also equal to $\\lambda_m(v_l) - \\lambda_m(v_k)$, which by definition is $\\delta_{ml} - \\delta_{mk}$.\n\nThe tangential component of $\\boldsymbol{N}_{ij}$ along the direction of $\\boldsymbol{e}_{kl}$ is:\n$$\n\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{kl} = (\\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i) \\cdot \\boldsymbol{e}_{kl} = \\lambda_i (\\nabla \\lambda_j \\cdot \\boldsymbol{e}_{kl}) - \\lambda_j (\\nabla \\lambda_i \\cdot \\boldsymbol{e}_{kl})\n$$\n$$\n\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{kl} = \\lambda_i (\\delta_{jl} - \\delta_{jk}) - \\lambda_j (\\delta_{il} - \\delta_{ik})\n$$\nWe analyze this expression on the edge $e_{kl}$. On this edge, only $\\lambda_k$ and $\\lambda_l$ are non-zero, and they satisfy $\\lambda_k + \\lambda_l = 1$. All other barycentric coordinates $\\lambda_m$ (for $m \\neq k,l$) are zero.\n\nCase 1: The edges are disjoint, i.e., $\\{i,j\\} \\cap \\{k,l\\} = \\emptyset$.\nOn edge $e_{kl}$, both $\\lambda_i$ and $\\lambda_j$ are zero. Thus, $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{kl} = 0$, and the integral is $0$.\n\nCase 2: The edges share one vertex. Let $k=i$, so the edge is $e_{il}$ with $j \\neq l$.\nOn edge $e_{il}$, $\\lambda_j=0$. The expression becomes $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{il} = \\lambda_i (\\delta_{jl} - \\delta_{ji})$. Since $j \\neq l$ and $j \\neq i$, both Kronecker deltas are zero. So $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{il} = 0$, and the integral is $0$.\n\nCase 3: The edges are the same, i.e., $k=i$ and $l=j$.\nWe evaluate $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{ij}$:\n$$\n\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{ij} = \\lambda_i (\\delta_{jj} - \\delta_{ji}) - \\lambda_j (\\delta_{ij} - \\delta_{ii}) = \\lambda_i(1 - 0) - \\lambda_j(0 - 1) = \\lambda_i + \\lambda_j\n$$\nOn edge $e_{ij}$, we have $\\lambda_i + \\lambda_j = 1$. Therefore, $\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{ij} = 1$. The line integral is:\n$$\n\\int_{e_{ij}} \\boldsymbol{N}_{ij} \\cdot \\hat{\\boldsymbol{t}}_{ij} \\, \\mathrm{d}s = \\int_{e_{ij}} \\frac{\\boldsymbol{N}_{ij} \\cdot \\boldsymbol{e}_{ij}}{|\\boldsymbol{e}_{ij}|} \\, \\mathrm{d}s = \\int_{e_{ij}} \\frac{1}{|\\boldsymbol{e}_{ij}|} \\, \\mathrm{d}s = \\frac{1}{|\\boldsymbol{e}_{ij}|} \\int_0^{|\\boldsymbol{e}_{ij}|} \\, \\mathrm{d}s = 1\n$$\nThis demonstrates that $\\int_{e_{kl}} \\boldsymbol{N}_{ij} \\cdot d\\boldsymbol{l} = \\delta_{ij,kl}$, satisfying the Kronecker delta property.\n\n### Part 3: Interpolation of the Vector Field\n\nGiven the linear vector field:\n$$\n\\boldsymbol{E}(x,y,z) = \\begin{pmatrix}\nx + 2y + 3z + 1 \\\\\n2x + 3y + z + 2 \\\\\n3x + y + 2z + 3\n\\end{pmatrix}\n$$\nThe first-kind Nédélec interpolant $\\boldsymbol{E}_h$ is given by:\n$$\n\\boldsymbol{E}_h = \\sum_{(i,j)} c_{ij} \\boldsymbol{N}_{ij}\n$$\nwhere the coefficients (degrees of freedom) $c_{ij}$ are the line integrals of $\\boldsymbol{E}$ along the corresponding edges:\n$$\nc_{ij} = \\int_{e_{ij}} \\boldsymbol{E} \\cdot d\\boldsymbol{l} = \\int_{e_{ij}} \\boldsymbol{E} \\cdot \\hat{\\boldsymbol{t}}_{ij} \\, \\mathrm{d}s\n$$\nWe compute these $6$ coefficients:\n\n1.  **$c_{12}$ on $e_{12}$:** $\\boldsymbol{r}(t) = (t,0,0)$, $d\\boldsymbol{l}=(1,0,0)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(t,0,0) = (t+1, 2t+2, 3t+3)^T$.\n    $c_{12} = \\int_0^1 (t+1) dt = \\left[\\frac{1}{2}t^2+t\\right]_0^1 = \\frac{1}{2}+1 = \\frac{3}{2}$.\n\n2.  **$c_{13}$ on $e_{13}$:** $\\boldsymbol{r}(t) = (0,t,0)$, $d\\boldsymbol{l}=(0,1,0)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(0,t,0) = (2t+1, 3t+2, t+3)^T$.\n    $c_{13} = \\int_0^1 (3t+2) dt = \\left[\\frac{3}{2}t^2+2t\\right]_0^1 = \\frac{3}{2}+2 = \\frac{7}{2}$.\n\n3.  **$c_{14}$ on $e_{14}$:** $\\boldsymbol{r}(t) = (0,0,t)$, $d\\boldsymbol{l}=(0,0,1)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(0,0,t) = (3t+1, t+2, 2t+3)^T$.\n    $c_{14} = \\int_0^1 (2t+3) dt = \\left[t^2+3t\\right]_0^1 = 1+3 = 4$.\n\n4.  **$c_{23}$ on $e_{23}$:** $\\boldsymbol{r}(t) = v_2 + t(v_3-v_2) = (1-t, t, 0)$, $d\\boldsymbol{l}=(-1,1,0)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(\\boldsymbol{r}(t)) = ((1-t)+2t+1, 2(1-t)+3t+2, 3(1-t)+t+3)^T = (t+2, t+4, 6-2t)^T$.\n    $c_{23} = \\int_0^1 \\begin{pmatrix} t+2 \\\\ t+4 \\\\ 6-2t \\end{pmatrix} \\cdot \\begin{pmatrix} -1 \\\\ 1 \\\\ 0 \\end{pmatrix} dt = \\int_0^1 (-(t+2) + (t+4)) dt = \\int_0^1 2 \\, dt = 2$.\n\n5.  **$c_{24}$ on $e_{24}$:** $\\boldsymbol{r}(t) = v_2 + t(v_4-v_2) = (1-t, 0, t)$, $d\\boldsymbol{l}=(-1,0,1)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(\\boldsymbol{r}(t)) = ((1-t)+3t+1, 2(1-t)+t+2, 3(1-t)+2t+3)^T = (2t+2, 4-t, 6-t)^T$.\n    $c_{24} = \\int_0^1 \\begin{pmatrix} 2t+2 \\\\ 4-t \\\\ 6-t \\end{pmatrix} \\cdot \\begin{pmatrix} -1 \\\\ 0 \\\\ 1 \\end{pmatrix} dt = \\int_0^1 (-(2t+2) + (6-t)) dt = \\int_0^1 (-3t+4) dt = \\left[-\\frac{3}{2}t^2+4t\\right]_0^1 = -\\frac{3}{2}+4 = \\frac{5}{2}$.\n\n6.  **$c_{34}$ on $e_{34}$:** $\\boldsymbol{r}(t) = v_3 + t(v_4-v_3) = (0, 1-t, t)$, $d\\boldsymbol{l}=(0,-1,1)dt$, $t \\in [0,1]$.\n    $\\boldsymbol{E}(\\boldsymbol{r}(t)) = (2(1-t)+3t+1, 3(1-t)+t+2, (1-t)+2t+3)^T = (t+3, 5-2t, t+4)^T$.\n    $c_{34} = \\int_0^1 \\begin{pmatrix} t+3 \\\\ 5-2t \\\\ t+4 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ -1 \\\\ 1 \\end{pmatrix} dt = \\int_0^1 (-(5-2t) + (t+4)) dt = \\int_0^1 (3t-1) dt = \\left[\\frac{3}{2}t^2-t\\right]_0^1 = \\frac{3}{2}-1 = \\frac{1}{2}$.\n\nThe six interpolation coefficients are $(c_{12}, c_{13}, c_{14}, c_{23}, c_{24}, c_{34}) = (\\frac{3}{2}, \\frac{7}{2}, 4, 2, \\frac{5}{2}, \\frac{1}{2})$.\nThe Nédélec interpolant of $\\boldsymbol{E}$ is:\n$$\n\\boldsymbol{E}_h(\\boldsymbol{r}) = \\frac{3}{2}\\boldsymbol{N}_{12}(\\boldsymbol{r}) + \\frac{7}{2}\\boldsymbol{N}_{13}(\\boldsymbol{r}) + 4\\boldsymbol{N}_{14}(\\boldsymbol{r}) + 2\\boldsymbol{N}_{23}(\\boldsymbol{r}) + \\frac{5}{2}\\boldsymbol{N}_{24}(\\boldsymbol{r}) + \\frac{1}{2}\\boldsymbol{N}_{34}(\\boldsymbol{r})\n$$\nThe problem requests the ordered row matrix of these six coefficients as the final answer.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{3}{2} & \\frac{7}{2} & 4 & 2 & \\frac{5}{2} & \\frac{1}{2}\n\\end{pmatrix}\n}\n$$", "id": "3329964"}, {"introduction": "Moving from a single element to a complex simulation requires assembling a mesh, which may consist of different element types to efficiently discretize a geometric domain. This hands-on coding practice tackles the critical challenge of ensuring tangential field continuity across interfaces in a hybrid mesh composed of tetrahedral and prismatic elements [@problem_id:3329977]. Implementing a robust mapping between local and global Degrees of Freedom (DOFs) is essential for any functional FEM solver, and this exercise will solidify your understanding of the data structures and logical checks required to maintain consistency and physical correctness in your model.", "problem": "You are given a mixed-element mesh in three-dimensional space comprising tetrahedral and triangular-prism elements. The unknown field is the electric field in the curl-conforming subspace (commonly implemented via edge-based Nédélec elements in the Finite Element Method (FEM)). The Degrees of Freedom (DOF) associated with each element are the line integrals of the electric field along oriented edges. The global assembly requires a consistent global numbering and orientation of edges such that the tangential continuity condition across interfaces is respected in the sense of boundary conditions derived from Maxwell's equations. Specifically, the tangential component of the electric field is continuous across material interfaces when there are no surface currents, which is enforced by sharing a common global DOF for each geometric edge across adjacent elements with a consistent orientation convention.\n\nStart from the following principles:\n- Let the electric field be denoted by $\\boldsymbol{E}(\\boldsymbol{x})$. For a curl-conforming first-order Nédélec element, DOFs are edge-integrals of $\\boldsymbol{E}$: for an oriented edge with endpoints $\\boldsymbol{a}$ and $\\boldsymbol{b}$ and tangent $\\boldsymbol{t} = \\boldsymbol{b} - \\boldsymbol{a}$, the DOF is $\\int_{0}^{1} \\boldsymbol{E}(\\boldsymbol{a} + s(\\boldsymbol{b} - \\boldsymbol{a})) \\cdot (\\boldsymbol{b} - \\boldsymbol{a}) \\,\\mathrm{d}s$. If $\\boldsymbol{E}$ is constant $\\boldsymbol{E} = \\boldsymbol{E}_0$, this reduces to $\\boldsymbol{E}_0 \\cdot (\\boldsymbol{b} - \\boldsymbol{a})$.\n- A global edge orientation convention assigns to each geometric edge a unique direction, and each element’s local edge orientation contributes a sign $\\sigma \\in \\{+1,-1\\}$ to map the local DOF to the global DOF, depending on whether the local orientation agrees with the global orientation.\n\nYour task is to devise and verify a DOF mapping that preserves tangential field continuity and ensures consistency of edge orientation and global numbering across an interface between a tetrahedral element and a triangular-prism element. Use an algorithmic approach grounded in the above principles that:\n- Builds a global edge numbering by assigning a unique identifier to each geometric edge, using a canonical orientation defined by increasing node index $(\\min(i,j) \\rightarrow \\max(i,j))$.\n- For each element, maps each local edge DOF to its global edge identifier with an associated sign $\\sigma$ that is $+1$ if the local orientation matches the global orientation, and $-1$ otherwise.\n- Verifies tangential continuity across the interface by checking that for every shared geometric edge between the two elements, the oriented edge-integral of a test field $\\boldsymbol{E}$ is consistent after applying the local sign and mapping to the global DOF. Concretely, for each shared edge with local integrals $I_{\\mathrm{tet}}$ and $I_{\\mathrm{prism}}$ and signs $\\sigma_{\\mathrm{tet}}$ and $\\sigma_{\\mathrm{prism}}$, verify that $\\sigma_{\\mathrm{tet}} I_{\\mathrm{tet}}$ equals $\\sigma_{\\mathrm{prism}} I_{\\mathrm{prism}}$ within a tolerance $\\epsilon$.\n- Verifies consistency of edge orientation and numbering across the interface by checking that each shared geometric edge is assigned the same global edge identifier by both elements.\n\nUse the constant test field $\\boldsymbol{E} = [1,2,3]^\\top$. For the triangular-prism element, use the local vertex ordering $(v_0,v_1,v_2,v_3,v_4,v_5)$ where $(v_0,v_1,v_2)$ are the bottom triangular face vertices and $(v_3,v_4,v_5)$ are the corresponding top face vertices. Its local edges are: bottom face edges $(v_0,v_1)$, $(v_1,v_2)$, $(v_2,v_0)$; top face edges $(v_3,v_4)$, $(v_4,v_5)$, $(v_5,v_3)$; and vertical edges $(v_0,v_3)$, $(v_1,v_4)$, $(v_2,v_5)$. For the tetrahedral element with local vertex ordering $(w_0,w_1,w_2,w_3)$, the local edges are $(w_0,w_1)$, $(w_1,w_2)$, $(w_2,w_0)$, $(w_0,w_3)$, $(w_1,w_3)$, $(w_2,w_3)$.\n\nImplement a program that constructs the global edge numbering and local-to-global DOF mapping, computes oriented edge-integrals for the constant field $\\boldsymbol{E}$, and checks the two consistency conditions described above on a fixed test suite. The program must output, for each test case, a boolean that is `true` if and only if:\n- All shared geometric edges between the tetrahedral and prism elements are mapped to the same global edge identifier by both elements, and\n- For each shared geometric edge, the equality $\\sigma_{\\mathrm{tet}} I_{\\mathrm{tet}} = \\sigma_{\\mathrm{prism}} I_{\\mathrm{prism}}$ holds within tolerance $\\epsilon = 10^{-12}$.\n\nUse the following node coordinates (in abstract units, no physical unit required) as a base set for all test cases, with the top face height parameter $h$ specified per case:\n- Node $0$: $(0,0,0)$\n- Node $1$: $(1,0,0)$\n- Node $2$: $(0,1,0)$\n- Node $3$: $(0,0,h)$\n- Node $4$: $(1,0,h)$\n- Node $5$: $(0,1,h)$\n- Node $6$: $(0,0,-1)$\n- Node $7$: $(0.5,0.5,-1)$\n\nTest Suite:\n- Case $1$ (happy path): Prism local order $[0,1,2,3,4,5]$, Tetra local order $[0,1,2,6]$, $h=1$, no bugs.\n- Case $2$ (reversed bottom face orientation in prism): Prism local order $[0,2,1,3,5,4]$, Tetra local order $[0,1,2,6]$, $h=1$, no bugs.\n- Case $3$ (edge-numbering bug on prism using directed edge keys): Prism local order $[0,2,1,3,5,4]$, Tetra local order $[0,1,2,6]$, $h=1$, but the prism’s global edge numbering is incorrectly constructed using directed edge pairs $(i,j)$ rather than the canonical $(\\min(i,j),\\max(i,j))$; this should fail the consistency check.\n- Case $4$ (interface reduces to a single shared edge): Prism local order $[0,1,2,3,4,5]$, Tetra local order $[0,1,6,7]$, $h=1$, no bugs.\n- Case $5$ (thin prism in height direction): Prism local order $[0,1,2,3,4,5]$, Tetra local order $[0,1,2,6]$, $h=10^{-9}$, no bugs.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, [`true_1`, `true_2`, `true_3`, `true_4`, `true_5`], where each entry is a boolean in the programming language’s native boolean literal form.", "solution": "The problem requires the design and verification of a local-to-global degree of freedom (DOF) mapping for a mixed mesh of tetrahedral and triangular-prism elements, as used in curl-conforming finite element methods (FEM) for electromagnetics. The core task is to ensure that the tangential component of the electric field, represented by edge-based DOFs, is continuous across the interface between a tetrahedron and a prism. This is achieved by verifying two conditions for a given test field $\\mathbf{E}$: first, that shared geometric edges are assigned a consistent global DOF identifier, and second, that the oriented edge integrals (the DOFs) are equal after being mapped to the global orientation.\n\nThe algorithmic approach is grounded in the principles of Nédélec edge element formulations. We will construct a global edge numbering system and then, for each element, create a map from its local edges to the global system. This process provides both a global identifier and an orientation sign for each local DOF. Finally, we will verify the consistency at the interface between the two elements.\n\n**1. Algorithmic Framework**\n\nThe procedure to validate the DOF mapping for an interface between two elements is as follows:\n1.  Define the geometry, comprising the global node coordinates for all vertices in the test setup.\n2.  For each test case, instantiate a global edge registry, which will map each unique geometric edge to a global integer identifier.\n3.  Process the first element (e.g., the prism). For each of its local edges, calculate its corresponding DOF, determine its global identifier and orientation sign by consulting the global edge registry, and store this local-to-global mapping.\n4.  Process the second element (the tetrahedron) in the same manner, using and updating the same global edge registry.\n5.  Identify the set of geometric edges shared by both elements.\n6.  For each shared edge, perform two checks:\n    a.  **Numbering Consistency**: The global identifier assigned to the edge must be identical for both elements.\n    b.  **Field Continuity**: The globally oriented DOF values calculated from each element's local DOF must be equal within a specified tolerance $\\epsilon$.\n7.  The test case is considered valid if and only if all checks pass for all shared edges.\n\n**2. Global Edge Representation and Numbering**\n\nA geometric edge in the mesh is uniquely defined by its two endpoint nodes, irrespective of direction. To create a unique key for each edge, we adopt a canonical representation. For an edge connecting global nodes with indices $i$ and $j$, the canonical key is the sorted tuple $(\\min(i, j), \\max(i, j))$. This convention assigns a global orientation to each edge, from the lower-indexed node to the higher-indexed one.\n\nA global edge registry, implemented as a dictionary or hash map, is used to assign a unique integer identifier to each canonical edge key. As elements are processed, we query this registry. If an edge is encountered for the first time, it is added to the registry with a new, sequential identifier.\n\n**3. Element Processing and DOF Mapping**\n\nFor a given element, defined by its type (tetrahedron or prism) and its list of global node indices (connectivity), we generate a local-to-global DOF map. The procedure for each local edge of the element is as follows:\n\nLet a local edge be defined by the pair of local vertex indices $(v_a, v_b)$. Using the element's connectivity list, these are mapped to global node indices $(n_a, n_b)$.\n- **DOF Calculation**: The problem statement specifies a constant test field $\\boldsymbol{E} = \\boldsymbol{E}_0$. The DOF, which is the line integral of $\\boldsymbol{E}$ along the local edge, simplifies to $I = \\boldsymbol{E}_0 \\cdot (\\boldsymbol{p}_b - \\boldsymbol{p}_a)$, where $\\boldsymbol{p}_a$ and $\\boldsymbol{p}_b$ are the coordinate vectors of nodes $n_a$ and $n_b$.\n- **Global Identifier**: The canonical key for this edge is $k = (\\min(n_a, n_b), \\max(n_a, n_b))$. This key is used to look up or assign a `global_id` in the global edge registry.\n- **Orientation Sign**: The sign $\\sigma$ aligns the local edge orientation $(n_a \\rightarrow n_b)$ with the global canonical orientation $(\\min(n_a, n_b) \\rightarrow \\max(n_a, n_b))$. The sign is $\\sigma = +1$ if $n_a < n_b$ (orientations agree) and $\\sigma = -1$ if $n_a > n_b$ (orientations are opposed).\n- **Mapping**: For the element, we store a mapping from the canonical key $k$ to a tuple containing the `global_id`, the sign $\\sigma$, and the calculated integral $I$.\n\n**4. Interface Consistency Verification**\n\nAfter processing both the tetrahedron and the prism, we have two separate local-to-global DOF maps. The interface consistency is verified as follows:\n- **Identify Shared Edges**: The set of shared geometric edges is found by taking the intersection of the sets of canonical edge keys from the two elements' DOF maps. If this set is empty, continuity is vacuously satisfied.\n- **Perform Checks**: For each shared canonical edge $k$:\n    1.  Retrieve the mapped data for the tetrahedron, $(g_{\\mathrm{tet}}, \\sigma_{\\mathrm{tet}}, I_{\\mathrm{tet}})$, and the prism, $(g_{\\mathrm{prism}}, \\sigma_{\\mathrm{prism}}, I_{\\mathrm{prism}})$.\n    2.  **Numbering Consistency Check**: Verify that $g_{\\mathrm{tet}} = g_{\\mathrm{prism}}$. A mismatch indicates a flaw in the global numbering logic, where the same geometric entity is erroneously assigned two different DOF indices.\n    3.  **Field Continuity Check**: The value of a local DOF, when mapped to the global system, is given by $\\sigma I$. To ensure tangential continuity, the globally oriented DOFs from both elements must be equal: $\\sigma_{\\mathrm{tet}} I_{\\mathrm{tet}} = \\sigma_{\\mathrm{prism}} I_{\\mathrm{prism}}$. We check if $|\\sigma_{\\mathrm{tet}} I_{\\mathrm{tet}} - \\sigma_{\\mathrm{prism}} I_{\\mathrm{prism}}| \\le \\epsilon$, where $\\epsilon = 10^{-12}$. A failure implies that the tangential component of the field is discontinuous across that edge in the discretized model.\n\n**5. Simulation of the Numbering Bug**\n\nTest case 3 introduces a specific implementation bug. For the prism element, the key used to access the global edge registry is the directed pair of global node indices $(n_a, n_b)$ instead of the canonical, sorted pair $(\\min(n_a, n_b), \\max(n_a, n_b))$. This faulty logic will create a new entry in the global registry for an edge $(n_a, n_b)$ where $n_a > n_b$, even if the canonical edge $(\\min(n_a, n_b), \\max(n_a, n_b))$ already exists. Consequently, when comparing with the correctly processed tetrahedron, the `global_id`s for such an edge will not match, causing the numbering consistency check to fail, as intended by the test case design.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DOF mapping consistency problem for a tet-prism interface.\n    \"\"\"\n    \n    # Base node coordinates (abstract units) before applying height parameter h\n    BASE_NODES = np.array([\n        [0.0, 0.0, 0.0],   # Node 0\n        [1.0, 0.0, 0.0],   # Node 1\n        [0.0, 1.0, 0.0],   # Node 2\n        [0.0, 0.0, 'h'], # Node 3 - y-coord is placeholder for h\n        [1.0, 0.0, 'h'], # Node 4\n        [0.0, 1.0, 'h'], # Node 5\n        [0.0, 0.0, -1.0],  # Node 6\n        [0.5, 0.5, -1.0],  # Node 7\n    ])\n\n    # Constant test electric field\n    E_FIELD = np.array([1.0, 2.0, 3.0])\n    \n    # Tolerance for floating-point comparisons\n    TOLERANCE = 1e-12\n\n    # Local edge definitions by local vertex indices\n    PRISM_LOCAL_EDGES = [\n        (0, 1), (1, 2), (2, 0),  # Bottom face\n        (3, 4), (4, 5), (5, 3),  # Top face\n        (0, 3), (1, 4), (2, 5)   # Vertical edges\n    ]\n    TET_LOCAL_EDGES = [\n        (0, 1), (1, 2), (2, 0),  # Base face\n        (0, 3), (1, 3), (2, 3)   # Edges to apex\n    ]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: Happy path\n        {'prism_conn': [0, 1, 2, 3, 4, 5], 'tet_conn': [0, 1, 2, 6], 'h': 1.0, 'buggy_prism_numbering': False},\n        # Case 2: Reversed bottom face orientation in prism\n        {'prism_conn': [0, 2, 1, 3, 5, 4], 'tet_conn': [0, 1, 2, 6], 'h': 1.0, 'buggy_prism_numbering': False},\n        # Case 3: Edge-numbering bug on prism\n        {'prism_conn': [0, 2, 1, 3, 5, 4], 'tet_conn': [0, 1, 2, 6], 'h': 1.0, 'buggy_prism_numbering': True},\n        # Case 4: Interface reduces to a single shared edge\n        {'prism_conn': [0, 1, 2, 3, 4, 5], 'tet_conn': [0, 1, 6, 7], 'h': 1.0, 'buggy_prism_numbering': False},\n        # Case 5: Thin prism\n        {'prism_conn': [0, 1, 2, 3, 4, 5], 'tet_conn': [0, 1, 2, 6], 'h': 1e-9, 'buggy_prism_numbering': False},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Setup for the current test case ---\n        h = case['h']\n        nodes = np.copy(BASE_NODES)\n        # Substitute the 'h' placeholder with the actual value\n        nodes[3:6, 2] = h\n        nodes = nodes.astype(float) # Ensure float type after substitution\n\n        global_edge_map = {}\n        next_global_id = 0\n        \n        # --- Process Prism Element ---\n        prism_conn = case['prism_conn']\n        prism_dof_map = {}\n        for v_start, v_end in PRISM_LOCAL_EDGES:\n            n_start, n_end = prism_conn[v_start], prism_conn[v_end]\n            \n            p_start, p_end = nodes[n_start], nodes[n_end]\n            integral = np.dot(E_FIELD, p_end - p_start)\n            \n            canonical_edge = tuple(sorted((n_start, n_end)))\n            \n            if case['buggy_prism_numbering']:\n                key = (n_start, n_end)\n            else:\n                key = canonical_edge\n            \n            if key not in global_edge_map:\n                global_edge_map[key] = next_global_id\n                next_global_id += 1\n            \n            global_id = global_edge_map[key]\n            sign = 1 if n_start < n_end else -1\n            \n            prism_dof_map[canonical_edge] = (global_id, sign, integral)\n\n        # --- Process Tetrahedral Element ---\n        tet_conn = case['tet_conn']\n        tet_dof_map = {}\n        for v_start, v_end in TET_LOCAL_EDGES:\n            n_start, n_end = tet_conn[v_start], tet_conn[v_end]\n            \n            p_start, p_end = nodes[n_start], nodes[n_end]\n            integral = np.dot(E_FIELD, p_end - p_start)\n            \n            canonical_edge = tuple(sorted((n_start, n_end)))\n            key = canonical_edge # Tet is never buggy\n\n            if key not in global_edge_map:\n                global_edge_map[key] = next_global_id\n                next_global_id += 1\n            \n            global_id = global_edge_map[key]\n            sign = 1 if n_start < n_end else -1\n            \n            tet_dof_map[canonical_edge] = (global_id, sign, integral)\n\n        # --- Verification ---\n        is_consistent = True\n        \n        # Find shared edges by intersecting the keys of the DOF maps\n        shared_edges = set(prism_dof_map.keys()).intersection(set(tet_dof_map.keys()))\n\n        if not shared_edges:\n            # If no shared edges, consistency is vacuously true\n            pass\n        else:\n            for edge in shared_edges:\n                prism_gid, prism_sign, prism_integral = prism_dof_map[edge]\n                tet_gid, tet_sign, tet_integral = tet_dof_map[edge]\n                \n                # 1. Check for consistent global numbering\n                if prism_gid != tet_gid:\n                    is_consistent = False\n                    break\n                \n                # 2. Check for field continuity\n                prism_global_dof = prism_sign * prism_integral\n                tet_global_dof = tet_sign * tet_integral\n                if abs(prism_global_dof - tet_global_dof) > TOLERANCE:\n                    is_consistent = False\n                    break\n        \n        results.append(str(is_consistent).lower())\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3329977"}, {"introduction": "Meshing for high-frequency problems, where the electromagnetic wavelength is small compared to the geometric features, presents unique challenges that demand more than a simple uniform discretization. This practice explores the interplay between geometric accuracy, mesh resolution, and the physics of wave scattering by examining a canonical high-frequency scattering problem [@problem_id:3330003]. By implementing and comparing the performance of linear versus higher-order elements and uniform versus curvature-adaptive meshing, you will develop an intuition for how to create efficient and accurate meshes that are tailored to the specific demands of the underlying wave physics.", "problem": "A two-dimensional scattering problem in computational electromagnetics is considered for a Perfect Electric Conductor (PEC) cylinder of radius $a$ centered at the origin and invariant along the $z$-axis. Under a Transverse Magnetic to $z$ (TM$_z$) plane-wave incidence, the fields reduce to a scalar Helmholtz equation for the $z$-component of the electric field. In the high-frequency regime where $ka \\gg 1$ (with $k$ the wavenumber), a Huygens-type boundary integral for a far-field quantity can be modeled as a highly oscillatory integral over the smooth boundary. To isolate the impact of geometric discretization order on far-field error, consider the canonical oscillatory boundary integral\n$$\nI(\\theta; k, a, \\alpha) = \\int_{0}^{2\\pi} \\exp\\left\\{ i k \\left(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta) \\right) \\cdot \\boldsymbol{x}(\\psi) \\right\\} \\, \\mathrm{d}s(\\psi),\n$$\nwhere $\\boldsymbol{e}_i = [\\cos\\alpha, \\sin\\alpha]^\\top$ is the incident direction, $\\boldsymbol{d}(\\theta) = [\\cos\\theta, \\sin\\theta]^\\top$ is the observation direction, $\\boldsymbol{x}(\\psi) = a[\\cos\\psi, \\sin\\psi]^\\top$ parametrizes the exact boundary by polar angle $\\psi$, and $\\mathrm{d}s(\\psi)$ is the differential arc length along the boundary. The illuminated-region restriction is not imposed to keep the analysis purely geometric.\n\nMesh generation for the boundary integral is performed elementwise over $\\psi \\in [0, 2\\pi)$ using an isoparametric mapping of polynomial order $p$. On each element, local coordinates $\\xi \\in [-1,1]$ are used, and the boundary is represented as\n$$\n\\boldsymbol{x}_h(\\xi) = \\sum_{j=0}^{p} N_j(\\xi) \\, \\boldsymbol{x}(\\psi_j),\n$$\nwhere $N_j(\\xi)$ are the Lagrange shape functions associated with nodes $\\xi_j \\in [-1,1]$ mapped to $\\psi_j \\in [\\psi_0, \\psi_1]$ via uniform spacing, and $\\boldsymbol{x}(\\psi_j)$ are the exact boundary points used as geometry nodes. The differential arc length in the numerical integral is given by\n$$\n\\mathrm{d}s_h(\\xi) = \\left\\| \\frac{\\mathrm{d}\\boldsymbol{x}_h}{\\mathrm{d}\\xi}(\\xi) \\right\\| \\mathrm{d}\\xi.\n$$\n\nCurvature-adaptive meshing is employed to resolve caustic-like concentrations of oscillatory phase. Let the phase function be\n$$\n\\Phi(\\psi; \\theta, \\alpha) = \\left(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)\\right) \\cdot \\boldsymbol{x}(\\psi),\n$$\nand note that the local phase curvature is $ \\Phi''(\\psi; \\theta, \\alpha) = \\left(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)\\right) \\cdot \\boldsymbol{x}''(\\psi) $. For the exact circle, $\\boldsymbol{x}''(\\psi) = -\\boldsymbol{x}(\\psi)$, so\n$$\n\\Phi''(\\psi; \\theta, \\alpha) = -a \\left[ \\cos(\\psi - \\alpha) - \\cos(\\psi - \\theta) \\right].\n$$\nTo control phase variation within each element, we enforce the heuristic bound\n$$\n\\Delta \\phi \\approx \\frac{1}{2} k \\left|\\Phi''(\\psi_c; \\theta, \\alpha)\\right| \\Delta\\psi^2 \\le \\tau,\n$$\nwhere $\\psi_c$ is the element center, $\\Delta\\psi$ is the element angular size, and $\\tau$ is a fixed tolerance. This yields a curvature-adaptive local element size\n$$\n\\Delta\\psi(\\psi_c) = \\sqrt{\\frac{2\\tau}{k \\left|\\Phi''(\\psi_c; \\theta, \\alpha)\\right| + \\varepsilon}},\n$$\nwith $\\varepsilon > 0$ a small regularization to avoid division by zero. The element size is clamped to $[\\Delta\\psi_{\\min}, \\Delta\\psi_{\\max}]$ for robustness.\n\nThe reference far-field integral $I_{\\text{ref}}(\\theta)$ is computed using the exact geometry with a very fine uniform partition of $\\psi$ and high-order Gaussian quadrature, while the approximated far-field $I_p(\\theta)$ is computed using the isoparametric geometry of order $p$ on either a uniform mesh or the curvature-adaptive mesh described above. The far-field error metric for a set of observation angles $\\Theta$ is defined as\n$$\nE = \\max_{\\theta \\in \\Theta} \\frac{\\left| I_p(\\theta) - I_{\\text{ref}}(\\theta) \\right|}{\\left| I_{\\text{ref}}(\\theta) \\right|}.\n$$\n\nStarting from the scalar Helmholtz equation and Huygens’ principle for smooth boundaries, justify the use of the above oscillatory integral as a canonical proxy for far-field synthesis. Derive how geometric representation order $p$ and curvature-adaptive meshing influence the numerical approximation of $I(\\theta)$ via control of phase error and Jacobian accuracy. Implement a program that:\n- Constructs the reference integral $I_{\\text{ref}}(\\theta)$ using the exact circle geometry with a fine uniform mesh.\n- Constructs $I_p(\\theta)$ using isoparametric geometry of order $p$ on either a uniform mesh or a curvature-adaptive mesh with the element size rule given above.\n- Computes the error metric $E$ for specified test cases.\n\nUse $a = 1\\,\\text{m}$, angles in radians, and let the incident angle be $\\alpha = 0$. The wavenumber $k$ is chosen to achieve specified values of $ka$. The final output must be dimensionless floats.\n\nTest suite:\n1. $ka = 30$, $p = 1$ (straight-edged), uniform mesh (no adaptation), $\\Theta = \\{0, \\pi/36, \\pi/12, \\pi/6\\}$.\n2. $ka = 100$, $p = 1$ (straight-edged), curvature-adaptive mesh (adaptation enabled), $\\Theta = \\{0, \\pi/72, \\pi/36, \\pi/9\\}$.\n3. $ka = 100$, $p = 3$ (curvilinear), uniform mesh (no adaptation), $\\Theta = \\{0, \\pi/72, \\pi/36, \\pi/9\\}$.\n4. $ka = 300$, $p = 2$ (curvilinear), curvature-adaptive mesh (adaptation enabled), $\\Theta = \\{0, \\pi/180, \\pi/60, \\pi/18\\}$.\n\nNumerical and algorithmic parameters:\n- Use Gaussian quadrature with at least $8$ points per element for all integrals.\n- For the reference integral, use a uniform partition with at least $2048$ elements over $\\psi \\in [0,2\\pi)$.\n- For uniform meshes in approximate integrals, use $64$ elements over $\\psi \\in [0,2\\pi)$.\n- For curvature-adaptive meshes, use $\\tau = \\pi/2$, $\\Delta\\psi_{\\min} = 2\\pi/1024$, $\\Delta\\psi_{\\max} = 2\\pi/32$, and $\\varepsilon = 10^{-12}$.\n\nYour program should produce a single line of output containing the four error metrics $E$ for the four test cases as a comma-separated list enclosed in square brackets (e.g., [`e1`, `e2`, `e3`, `e4`]).", "solution": "The problem statement has been validated and is determined to be scientifically sound, well-posed, and objective. It presents a canonical and well-defined problem in computational electromagnetics, providing all necessary parameters and definitions for a unique numerical solution.\n\n### Justification of the Canonical Integral\n\nThe problem originates from the two-dimensional scalar Helmholtz equation, $(\\nabla^2 + k^2)E_z = 0$, which governs the $z$-component of the electric field for Transverse Magnetic to $z$ (TM$_z$) scattering. According to Huygens' principle, or more formally the Kirchhoff-Helmholtz integral theorem, the scattered field $E_z^s$ at an observation point $\\boldsymbol{r}$ can be represented by an integral over the boundary $\\partial\\Omega$ of the scatterer:\n$$\nE_z^s(\\boldsymbol{r}) = \\int_{\\partial\\Omega} \\left( E_z(\\boldsymbol{r}') \\frac{\\partial G(\\boldsymbol{r}, \\boldsymbol{r}')}{\\partial n'} - G(\\boldsymbol{r}, \\boldsymbol{r}') \\frac{\\partial E_z(\\boldsymbol{r}')}{\\partial n'} \\right) \\, \\mathrm{d}s(\\boldsymbol{r}'),\n$$\nwhere $G$ is the $2$D free-space Green's function, $H_0^{(1)}(k|\\boldsymbol{r}-\\boldsymbol{r}'|)$, and $\\partial/\\partial n'$ is the normal derivative. For a Perfect Electric Conductor (PEC), the total tangential electric field vanishes, so $E_z(\\boldsymbol{r}') = 0$ on $\\partial\\Omega$. The surface current density is related to the normal derivative of the field, $J_z \\propto \\partial E_z / \\partial n'$. The integral simplifies to a radiation integral involving the surface current multiplied by the Green's function.\n\nIn the far-field, where $|\\boldsymbol{r}| \\to \\infty$, the Hankel function (Green's function) has the asymptotic form $G(\\boldsymbol{r}, \\boldsymbol{r}') \\propto \\frac{e^{ik|\\boldsymbol{r}|}}{\\sqrt{k|\\boldsymbol{r}|}} e^{-ik \\boldsymbol{d}(\\theta) \\cdot \\boldsymbol{r}'}$, where $\\boldsymbol{d}(\\theta) = \\boldsymbol{r}/|\\boldsymbol{r}|$ is the observation direction. The far-field pattern is thus proportional to an integral of the form $\\int_{\\partial\\Omega} J_z(\\boldsymbol{r}') e^{-ik \\boldsymbol{d}(\\theta) \\cdot \\boldsymbol{r}'} \\, \\mathrm{d}s(\\boldsymbol{r}')$.\n\nIn the high-frequency regime ($ka \\gg 1$), the Physical Optics (PO) approximation is often used for the surface current $J_z$. It approximates the current on the illuminated portion of the scatterer by twice the incident tangential magnetic field and assumes zero current in the shadow region. For a plane wave incidence with direction $\\boldsymbol{e}_i$, the incident field at a point $\\boldsymbol{x}(\\psi)$ on the boundary has a phase dependence of $e^{ik \\boldsymbol{e}_i \\cdot \\boldsymbol{x}(\\psi)}$. The induced PO current therefore carries this phase factor.\n\nCombining these elements, the far-field integral involves an integrand of the form $e^{ik \\boldsymbol{e}_i \\cdot \\boldsymbol{x}(\\psi)} e^{-ik \\boldsymbol{d}(\\theta) \\cdot \\boldsymbol{x}(\\psi)} = e^{ik(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)) \\cdot \\boldsymbol{x}(\\psi)}$. The problem provides the canonical integral:\n$$\nI(\\theta; k, a, \\alpha) = \\int_{0}^{2\\pi} \\exp\\left\\{ i k \\left(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta) \\right) \\cdot \\boldsymbol{x}(\\psi) \\right\\} \\, \\mathrm{d}s(\\psi),\n$$\nThis integral serves as an excellent proxy for the far-field synthesis problem because it isolates the core numerical challenge: the accurate evaluation of a highly oscillatory integral over a curved boundary. By omitting the amplitude factors and the illuminated/shadow boundary logic of the PO approximation, it allows for a focused analysis of the errors arising purely from the discretization of the geometry $\\boldsymbol{x}(\\psi)$ and the phase function $\\Phi(\\psi) = (\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)) \\cdot \\boldsymbol{x}(\\psi)$.\n\n### Influence of Geometric Order and Adaptive Meshing\n\nThe numerical approximation of $I(\\theta)$ replaces the exact integral with a sum of integrals over discrete elements, each evaluated using numerical quadrature. The error arises from two primary sources related to the geometry representation: phase error and Jacobian error.\n\n**1. Geometric Representation Order ($p$):**\n\n- **Phase Error:** The accuracy of the integral is critically dependent on how well the numerical phase function $\\Phi_h(\\xi) = (\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)) \\cdot \\boldsymbol{x}_h(\\xi)$ approximates the exact phase $\\Phi(\\psi)$. The geometric error, $\\|\\boldsymbol{x}(\\psi) - \\boldsymbol{x}_h(\\xi(\\psi))\\|$, directly translates into a phase error, $k |(\\boldsymbol{e}_i - \\boldsymbol{d}(\\theta)) \\cdot (\\boldsymbol{x}(\\psi) - \\boldsymbol{x}_h(\\xi(\\psi)))|$.\n    - For $p=1$ (linear elements), the circular boundary is approximated by an inscribed polygon. This results in a systematic underestimation of the radial position, leading to a significant geometric and phase error, particularly for coarse meshes.\n    - For higher orders ($p > 1$), the isoparametric elements can curve, providing a much better fit to the circular boundary. For instance, a quadratic element ($p=2$) can match the position and tangent at its ends and midpoint, leading to a much smaller geometric error. The representation error for a smooth curve using a polynomial of order $p$ is proportional to $h^{p+1}$, where $h$ is the element size. This higher-order accuracy in geometry translates to higher-order accuracy in the phase, drastically reducing the numerical error for a given number of elements.\n\n- **Jacobian Accuracy:** The differential arc length on the exact circle is $\\mathrm{d}s = a \\, \\mathrm{d}\\psi$. The numerical counterpart is $\\mathrm{d}s_h = \\|\\frac{\\mathrm{d}\\boldsymbol{x}_h}{\\mathrm{d}\\xi}\\| \\mathrm{d}\\xi$. The accuracy of the Jacobian, $\\|\\frac{\\mathrm{d}\\boldsymbol{x}_h}{\\mathrm{d}\\xi}\\|$, which represents the local stretching of the mapping from the reference element to the physical element, is also dependent on $p$. For $p=1$, the arc length of the polygonal segment is always less than the arc length of the circular arc it subtends. Higher-order elements provide a more accurate approximation of the arc length, reducing this source of error.\n\n**2. Curvature-Adaptive Meshing:**\n\nThe integrand is highly oscillatory, with the local frequency of oscillation determined by the derivative of the phase, $\\Phi'(\\psi)$. The stationary phase principle indicates that the main contributions to the integral come from neighborhoods of stationary points, where $\\Phi'(\\psi)=0$, and from boundary endpoints. The rate of phase variation away from these points is governed by the phase curvature, $\\Phi''(\\psi)$.\n\n- **Efficiency:** A uniform mesh is inefficient. It uses the same element size in regions of slow phase variation (where a large element would suffice) and rapid phase variation (where a small element is required).\n- **Targeted Refinement:** The curvature-adaptive meshing strategy is designed to overcome this. The rule $\\Delta\\psi \\propto 1/\\sqrt{k|\\Phi''|}$ places smaller elements where the phase curvature is large and larger elements where it is small. This ensures that the total phase change within any given element, $\\Delta\\phi \\approx \\frac{1}{2} k \\left|\\Phi''(\\psi_c)\\right| \\Delta\\psi^2$, is kept below a fixed tolerance $\\tau$. By concentrating computational effort in regions where the integrand is most challenging to resolve, this approach achieves a desired accuracy with significantly fewer elements than a uniform mesh, especially in the high-frequency ($k \\gg 1$) regime. This makes the numerical integration both more accurate and more efficient. The stationary points have $\\Phi'(\\psi)=0$, but the curvature $\\Phi''$ can still be large nearby, necessitating refinement. The points where $\\Phi''=0$ are inflection points of the phase function, and the rule correctly allows for larger elements there.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Problem-defined constants and parameters\nA_RADIUS = 1.0\nALPHA_INCIDENCE = 0.0\n\n# Numerical parameters\nGQ_POINTS = 8\nN_REF_ELEMENTS = 2048\nN_UNIF_ELEMENTS = 64\nTAU_ADAPT = np.pi / 2\nD_PSI_MIN = 2 * np.pi / 1024\nD_PSI_MAX = 2 * np.pi / 32\nEPSILON_ADAPT = 1e-12\nEPSILON_ERROR_DENOM = 1e-15\n\ndef lagrange_poly_and_deriv(p, xis):\n    \"\"\"\n    Computes Lagrange polynomial basis functions and their derivatives.\n    Nodes are uniformly spaced in [-1, 1].\n    \n    Args:\n        p (int): Polynomial order.\n        xis (np.ndarray): Points in [-1, 1] to evaluate the functions at.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: (N, N_prime) matrices of shape (len(xis), p + 1).\n    \"\"\"\n    nodes = np.linspace(-1, 1, p + 1)\n    num_pts = len(xis)\n    N = np.ones((num_pts, p + 1))\n    N_prime = np.zeros((num_pts, p + 1))\n    \n    for j in range(p + 1):\n        # Denominator for N_j and N_j'\n        denom = np.prod(nodes[j] - nodes[np.arange(p + 1) != j])\n        \n        # Calculate N_j(xi)\n        for k in range(p + 1):\n            if j == k: continue\n            N[:, j] *= (xis - nodes[k])\n        N[:, j] /= denom\n        \n        # Calculate N_j'(xi)\n        for m in range(p + 1):\n            if m == j: continue\n            term = np.ones(num_pts)\n            for k in range(p + 1):\n                if k == j or k == m: continue\n                term *= (xis - nodes[k])\n            N_prime[:, j] += term\n        N_prime[:, j] /= denom\n            \n    return N, N_prime\n\ndef create_uniform_mesh(num_elements):\n    \"\"\"Creates a uniform mesh over [0, 2*pi].\"\"\"\n    psi_vals = np.linspace(0, 2 * np.pi, num_elements + 1)\n    return list(zip(psi_vals[:-1], psi_vals[1:]))\n\ndef create_adaptive_mesh(k, theta):\n    \"\"\"Creates a curvature-adaptive mesh over [0, 2*pi].\"\"\"\n    mesh = []\n    psi_current = 0.0\n    \n    while psi_current < 2 * np.pi:\n        psi_c_est = psi_current + 1e-6 # Estimate at start of element\n        phi_double_prime = -A_RADIUS * (np.cos(psi_c_est - ALPHA_INCIDENCE) - np.cos(psi_c_est - theta))\n        \n        delta_psi = np.sqrt(2 * TAU_ADAPT / (k * abs(phi_double_prime) + EPSILON_ADAPT))\n        delta_psi = np.clip(delta_psi, D_PSI_MIN, D_PSI_MAX)\n        \n        psi_next = psi_current + delta_psi\n        if psi_next > 2 * np.pi:\n            psi_next = 2 * np.pi\n            \n        mesh.append((psi_current, psi_next))\n        psi_current = psi_next\n        \n    return mesh\n\ndef calculate_integral(k, theta, p, mesh, use_exact_geom):\n    \"\"\"\n    Calculates the boundary integral for a given mesh and geometry representation.\n    \"\"\"\n    total_integral = 0.0j\n    gq_nodes, gq_weights = roots_legendre(GQ_POINTS)\n    \n    e_i = np.array([np.cos(ALPHA_INCIDENCE), np.sin(ALPHA_INCIDENCE)])\n    d_theta = np.array([np.cos(theta), np.sin(theta)])\n    k_vec = k * (e_i - d_theta)\n\n    if not use_exact_geom:\n        N, N_prime = lagrange_poly_and_deriv(p, gq_nodes)\n\n    for psi0, psi1 in mesh:\n        delta_psi = psi1 - psi0\n        psi_c = (psi0 + psi1) / 2.0\n\n        if use_exact_geom:\n            psi_gq = psi_c + (delta_psi / 2.0) * gq_nodes\n            \n            x_gq = A_RADIUS * np.array([np.cos(psi_gq), np.sin(psi_gq)]).T\n            phase = x_gq @ k_vec\n            integrand = np.exp(1j * phase)\n            \n            ds_dpsi = A_RADIUS\n            jac_psi_to_xi = delta_psi / 2.0\n            \n            elem_integral = np.sum(gq_weights * integrand * ds_dpsi * jac_psi_to_xi)\n        else:\n            psi_nodes_geom = np.linspace(psi0, psi1, p + 1)\n            x_nodes = A_RADIUS * np.array([np.cos(psi_nodes_geom), np.sin(psi_nodes_geom)]).T\n            \n            # Interpolated positions and derivatives at GQ points\n            x_h_gq = N @ x_nodes\n            dxh_dxi_gq = N_prime @ x_nodes\n            \n            jacobian_ds_dxi = np.linalg.norm(dxh_dxi_gq, axis=1)\n            \n            phase = x_h_gq @ k_vec\n            integrand = np.exp(1j * phase)\n            \n            elem_integral = np.sum(gq_weights * integrand * jacobian_ds_dxi)\n            \n        total_integral += elem_integral\n        \n    return total_integral\n\ndef solve():\n    test_cases = [\n        {'ka': 30, 'p': 1, 'mesh_type': 'uniform', 'Theta': [0, np.pi/36, np.pi/12, np.pi/6]},\n        {'ka': 100, 'p': 1, 'mesh_type': 'adaptive', 'Theta': [0, np.pi/72, np.pi/36, np.pi/9]},\n        {'ka': 100, 'p': 3, 'mesh_type': 'uniform', 'Theta': [0, np.pi/72, np.pi/36, np.pi/9]},\n        {'ka': 300, 'p': 2, 'mesh_type': 'adaptive', 'Theta': [0, np.pi/180, np.pi/60, np.pi/18]},\n    ]\n    \n    results = []\n    \n    mesh_ref = create_uniform_mesh(N_REF_ELEMENTS)\n    \n    for case in test_cases:\n        ka = case['ka']\n        p = case['p']\n        mesh_type = case['mesh_type']\n        Theta = case['Theta']\n        \n        k = ka / A_RADIUS\n        max_error = 0.0\n        \n        for theta in Theta:\n            # Compute reference integral\n            i_ref = calculate_integral(k, theta, p, mesh_ref, use_exact_geom=True)\n            \n            # Create mesh for approximation\n            if mesh_type == 'uniform':\n                mesh_approx = create_uniform_mesh(N_UNIF_ELEMENTS)\n            else: # adaptive\n                mesh_approx = create_adaptive_mesh(k, theta)\n            \n            # Compute approximate integral\n            i_p = calculate_integral(k, theta, p, mesh_approx, use_exact_geom=False)\n            \n            # Compute relative error\n            error = np.abs(i_p - i_ref) / (np.abs(i_ref) + EPSILON_ERROR_DENOM)\n            if error > max_error:\n                max_error = error\n                \n        results.append(max_error)\n        \n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3330003"}]}