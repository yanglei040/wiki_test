{"hands_on_practices": [{"introduction": "The simplest description of collective rotation in deformed nuclei is the rigid rotor model, which treats the nucleus as a solid object with a fixed shape. This foundational exercise bridges classical mechanics and nuclear physics by asking you to first derive the general expression for rotational kinetic energy [@problem_id:3606569]. By then applying this formula to a hypothetical deformed nucleus, you will gain hands-on experience in quantifying rotational energy and appreciate the physical reasoning behind the model's applicability, based on the separation of energy scales in nuclear dynamics.", "problem": "A rigid body consists of $N$ point masses $m_{k}$ at fixed positions $\\mathbf{r}_{k}$ relative to a body-fixed frame whose axes are defined by the principal directions of the mass distribution. The body undergoes a pure rotation with angular velocity vector $\\boldsymbol{\\omega}$, expressed in radians per second. Starting from Newton’s laws and the definition of kinetic energy for a system of point masses, derive the general tensorial expression for the rotational kinetic energy of the rigid body in terms of $\\boldsymbol{\\omega}$ and the inertia tensor constructed from $\\{m_{k}, \\mathbf{r}_{k}\\}$.\n\nThen, consider an even-even nucleus with a stable quadrupole deformation that can be approximated as a rigid rotor with principal moments of inertia about its body-fixed axes given by $I_{1} = 3.6 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$, $I_{2} = 4.0 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$, and $I_{3} = 4.4 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$. Suppose the nucleus rotates with angular velocity components $\\omega_{1} = 0.70 \\times 10^{20} \\text{ rad/s}$, $\\omega_{2} = 0.50 \\times 10^{20} \\text{ rad/s}$, and $\\omega_{3} = 0.60 \\times 10^{20} \\text{ rad/s}$ along the principal axes. Compute the rotational kinetic energy and express the final energy in megaelectronvolts (MeV). Use the conversion $1 \\text{ MeV} = 1.602176634 \\times 10^{-13} \\text{ J}$. Round your answer to four significant figures.\n\nFinally, justify why the rigid rotor approximation is applicable to nuclei with stable quadrupole deformations by appealing to first-principles considerations such as constraints implied by rigidity, separation of timescales, and collective motion in many-body systems. Your justification should be based on physical reasoning without invoking model-specific formulas.", "solution": "The problem consists of three parts: a derivation, a calculation, and a conceptual justification. Each part will be addressed in sequence.\n\n**Part 1: Derivation of the Tensorial Expression for Rotational Kinetic Energy**\n\nWe begin with the definition of the total kinetic energy, $T$, for a system of $N$ point masses $m_k$ with velocities $\\mathbf{v}_k$.\n$$T = \\sum_{k=1}^{N} \\frac{1}{2} m_k \\mathbf{v}_k^2 = \\sum_{k=1}^{N} \\frac{1}{2} m_k (\\mathbf{v}_k \\cdot \\mathbf{v}_k)$$\nFor a rigid body undergoing pure rotation with angular velocity $\\boldsymbol{\\omega}$ about a fixed point (which we take as the origin of the body-fixed frame), the velocity $\\mathbf{v}_k$ of the $k$-th mass at position $\\mathbf{r}_k$ is given by the cross product:\n$$\\mathbf{v}_k = \\boldsymbol{\\omega} \\times \\mathbf{r}_k$$\nSubstituting this into the expression for kinetic energy yields:\n$$T = \\sum_{k=1}^{N} \\frac{1}{2} m_k (\\boldsymbol{\\omega} \\times \\mathbf{r}_k) \\cdot (\\boldsymbol{\\omega} \\times \\mathbf{r}_k)$$\nWe use the vector identity for the scalar triple product, also known as Lagrange's identity: $(\\mathbf{A} \\times \\mathbf{B}) \\cdot (\\mathbf{C} \\times \\mathbf{D}) = (\\mathbf{A} \\cdot \\mathbf{C})(\\mathbf{B} \\cdot \\mathbf{D}) - (\\mathbf{A} \\cdot \\mathbf{D})(\\mathbf{B} \\cdot \\mathbf{C})$. For our case, $\\mathbf{A} = \\mathbf{C} = \\boldsymbol{\\omega}$ and $\\mathbf{B} = \\mathbf{D} = \\mathbf{r}_k$.\n$$(\\boldsymbol{\\omega} \\times \\mathbf{r}_k) \\cdot (\\boldsymbol{\\omega} \\times \\mathbf{r}_k) = (\\boldsymbol{\\omega} \\cdot \\boldsymbol{\\omega})(\\mathbf{r}_k \\cdot \\mathbf{r}_k) - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)(\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k) = \\omega^2 r_k^2 - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)^2$$\nHere, $\\omega = |\\boldsymbol{\\omega}|$ and $r_k = |\\mathbf{r}_k|$. The kinetic energy becomes:\n$$T = \\frac{1}{2} \\sum_{k=1}^{N} m_k \\left[ \\omega^2 r_k^2 - (\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k)^2 \\right]$$\nTo obtain the tensorial form, we express this in terms of Cartesian components. Let $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3)$ and $\\mathbf{r}_k = (x_{k,1}, x_{k,2}, x_{k,3})$.\nThen $\\omega^2 = \\sum_{i=1}^{3} \\omega_i^2$, $r_k^2 = \\sum_{j=1}^{3} x_{k,j}^2$, and $\\boldsymbol{\\omega} \\cdot \\mathbf{r}_k = \\sum_{j=1}^{3} \\omega_j x_{k,j}$.\nThe expression inside the summation is:\n$$m_k \\left[ \\left(\\sum_{i=1}^{3} \\omega_i^2 \\right) \\left(\\sum_{j=1}^{3} x_{k,j}^2 \\right) - \\left(\\sum_{i=1}^{3} \\omega_i x_{k,i} \\right) \\left(\\sum_{j=1}^{3} \\omega_j x_{k,j} \\right) \\right]$$\nUsing the Kronecker delta, $\\delta_{ij}$, we can write $\\sum_{i} \\omega_i^2 = \\sum_{i,j} \\omega_i \\omega_j \\delta_{ij}$.\n$$T = \\frac{1}{2} \\sum_{k=1}^{N} m_k \\left[ \\left(\\sum_{i,j} \\omega_i \\omega_j \\delta_{ij} \\right) \\left(\\sum_{l} x_{k,l}^2 \\right) - \\sum_{i,j} \\omega_i \\omega_j x_{k,i} x_{k,j} \\right]$$\nWe can interchange the order of summation:\n$$T = \\frac{1}{2} \\sum_{i,j} \\left[ \\sum_{k=1}^{N} m_k \\left( \\delta_{ij} \\sum_{l=1}^{3} x_{k,l}^2 - x_{k,i} x_{k,j} \\right) \\right] \\omega_i \\omega_j$$\nThe term in the square brackets is the $(i,j)$-th component of the inertia tensor $\\mathbf{I}$:\n$$I_{ij} = \\sum_{k=1}^{N} m_k (r_k^2 \\delta_{ij} - x_{k,i} x_{k,j})$$\nwhere $r_k^2 = x_{k,1}^2 + x_{k,2}^2 + x_{k,3}^2$.\nTherefore, the general tensorial expression for the rotational kinetic energy is:\n$$T = \\frac{1}{2} \\sum_{i,j=1}^{3} I_{ij} \\omega_i \\omega_j$$\nIn matrix notation, this is written as $T = \\frac{1}{2} \\boldsymbol{\\omega}^T \\mathbf{I} \\boldsymbol{\\omega}$, where $\\boldsymbol{\\omega}$ is the column vector of angular velocity components and $\\mathbf{I}$ is the $3 \\times 3$ inertia tensor matrix.\n\n**Part 2: Calculation of Kinetic Energy for the Nucleus**\n\nThe problem specifies that the body-fixed axes are the principal axes of the mass distribution. In the principal axis system, the inertia tensor $\\mathbf{I}$ is diagonal. Its components are $I_{ij} = I_i \\delta_{ij}$, where $I_1$, $I_2$, and $I_3$ are the principal moments of inertia. The general expression for kinetic energy simplifies to:\n$$T = \\frac{1}{2} \\sum_{i,j=1}^{3} (I_i \\delta_{ij}) \\omega_i \\omega_j = \\frac{1}{2} \\sum_{i=1}^{3} I_i \\omega_i^2$$\n$$T = \\frac{1}{2} (I_1 \\omega_1^2 + I_2 \\omega_2^2 + I_3 \\omega_3^2)$$\nWe are given the following values:\n$I_{1} = 3.6 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$I_{2} = 4.0 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$I_{3} = 4.4 \\times 10^{-54} \\text{ kg}\\cdot\\text{m}^{2}$\n$\\omega_{1} = 0.70 \\times 10^{20} \\text{ rad/s}$\n$\\omega_{2} = 0.50 \\times 10^{20} \\text{ rad/s}$\n$\\omega_{3} = 0.60 \\times 10^{20} \\text{ rad/s}$\n\nWe calculate each term in SI units (Joules):\n$I_1 \\omega_1^2 = (3.6 \\times 10^{-54}) (0.70 \\times 10^{20})^2 = (3.6 \\times 10^{-54}) (0.49 \\times 10^{40}) = 1.764 \\times 10^{-14} \\text{ J}$\n$I_2 \\omega_2^2 = (4.0 \\times 10^{-54}) (0.50 \\times 10^{20})^2 = (4.0 \\times 10^{-54}) (0.25 \\times 10^{40}) = 1.000 \\times 10^{-14} \\text{ J}$\n$I_3 \\omega_3^2 = (4.4 \\times 10^{-54}) (0.60 \\times 10^{20})^2 = (4.4 \\times 10^{-54}) (0.36 \\times 10^{40}) = 1.584 \\times 10^{-14} \\text{ J}$\n\nThe sum is:\n$\\sum_{i=1}^{3} I_i \\omega_i^2 = (1.764 + 1.000 + 1.584) \\times 10^{-14} = 4.348 \\times 10^{-14} \\text{ J}$\n\nThe kinetic energy is:\n$T = \\frac{1}{2} (4.348 \\times 10^{-14} \\text{ J}) = 2.174 \\times 10^{-14} \\text{ J}$\n\nFinally, we convert the energy to megaelectronvolts (MeV) using the given conversion factor $1 \\text{ MeV} = 1.602176634 \\times 10^{-13} \\text{ J}$.\n$$T_{\\text{MeV}} = \\frac{2.174 \\times 10^{-14} \\text{ J}}{1.602176634 \\times 10^{-13} \\text{ J/MeV}} \\approx 0.1356900 \\text{ MeV}$$\nRounding to four significant figures as requested, we get:\n$T_{\\text{MeV}} = 0.1357 \\text{ MeV}$\n\n**Part 3: Justification of the Rigid Rotor Approximation**\n\nThe applicability of the rigid rotor model to a quantum many-body system like a nucleus, particularly one with a stable quadrupole deformation, rests on several key physical principles rooted in first-principles considerations.\n\nFirst, the concept of **collective motion** is central. In atomic nuclei, not all excitations involve promoting a single nucleon to a higher energy state (single-particle excitations). Certain low-energy states arise from the coherent, in-phase motion of many nucleons. For nuclei that are not spherically symmetric, such as those with a stable prolate or oblate quadrupole deformation, the entire nucleus can rotate as a whole. This collective rotation of the deformed shape gives rise to a band of excited states, which is the phenomenon the rigid rotor model aims to describe.\n\nSecond, the notion of **rigidity** emerges from the strong correlations among the nucleons. A classical rigid body has fixed distances between its constituents. A nucleus is not strictly rigid; its constituent nucleons are in constant motion within the mean field potential. However, for a nucleus with a stable deformation, the strong nuclear force creates a self-bound system with a well-defined average shape. The energy required to alter this shape (vibrational excitations) or to break the pairing correlations between nucleons is significantly higher than the energy associated with the slow rotation of the shape itself. This \"stiffness\" against deformation and internal rearrangement during rotation allows the nucleus to be approximated as a rigid body.\n\nThird, the validity of the model depends critically on the **separation of timescales and energy scales**. There is a distinct hierarchy of characteristic times for different types of nuclear motion.\n1.  **Single-particle motion:** Nucleons move rapidly within the nucleus. The timescale $\\tau_{sp}$ is on the order of the time it takes for a nucleon to traverse the nucleus. This corresponds to the highest energy scale, $E_{sp}$.\n2.  **Vibrational motion:** Oscillations of the nuclear surface about its equilibrium shape occur on a slower timescale, $\\tau_{vib}$, corresponding to a lower energy scale, $E_{vib}$.\n3.  **Rotational motion:** The collective rotation of the deformed nucleus as a whole is the slowest motion, occurring on a timescale $\\tau_{rot}$, and corresponds to the lowest energy scale, $E_{rot}$.\n\nThis hierarchy, $E_{rot} \\ll E_{vib} < E_{sp}$ and thus $\\tau_{rot} \\gg \\tau_{vib} > \\tau_{sp}$, is crucial. Because the rotation is much slower than the internal motions, the nucleus can undergo many internal rearrangements and shape vibrations during a single rotation. From the perspective of the slow rotational motion, the fast internal dynamics average out, presenting an effectively stable, deformed object with a well-defined moment of inertia. This adiabatic separation allows one to decouple the rotational degrees of freedom from the intrinsic and vibrational degrees of freedom, justifying the treatment of the nucleus as a simple rigid rotor for the lowest-lying collective states.", "answer": "$$\\boxed{0.1357}$$", "id": "3606569"}, {"introduction": "While the rigid rotor provides a good baseline, real nuclei exhibit more complex behavior, especially at high rotational frequencies. This practice delves into the fascinating phenomenon of backbending, where the alignment of a pair of nucleons dramatically alters the moment of inertia, using a simplified two-band mixing model within the cranking formalism [@problem_id:3550162]. By numerically implementing this model, you will compute the kinematic and dynamic moments of inertia and directly observe how a band crossing manifests, providing crucial insight into the interplay between collective and single-particle motion.", "problem": "Consider a simplified, two-band blocked cranked Hartree–Fock–Bogoliubov (HFB) model for collective rotational motion in a deformed nucleus. The purpose is to simulate the alignment of a specific Nilsson orbital under rotation and to compute the changes in the kinematic moment of inertia and the dynamic moment of inertia across the band crossing.\n\nYou will implement a minimal, self-consistent model in the rotating frame based on the cranking approach and a two-level mixing Hamiltonian. The model is defined by the following elements:\n\n1. The cranking method introduces the rotating-frame Hamiltonian $H' = H - \\omega \\hat{J}$, where $\\omega$ is the rotational frequency expressed in $\\mathrm{MeV}/\\hbar$, $H$ is the laboratory-frame Hamiltonian, and $\\hat{J}$ is the angular momentum operator.\n\n2. The core rotational energy is modeled as a classical rigid rotor with energy $E_{\\text{core}}(\\omega) = \\tfrac{1}{2} \\mathcal{J}\\,\\omega^2$, where $\\mathcal{J}$ is the core moment of inertia in $\\hbar^2/\\mathrm{MeV}$. In the rotating frame, the corresponding Routhian contribution is $E_{\\text{core}}'(\\omega) = E_{\\text{core}}(\\omega) - \\omega J_{\\text{core}}(\\omega)$. Using $J_{\\text{core}}(\\omega) = \\mathcal{J}\\,\\omega$ for a rigid rotor, this yields $E_{\\text{core}}'(\\omega) = -\\tfrac{1}{2}\\,\\mathcal{J}\\,\\omega^2$.\n\n3. The alignment of a specific Nilsson orbital with aligned angular momentum $i_a$ (in units of $\\hbar$) is modeled as an additional contribution to the Routhian $E_{\\text{align}}'(\\omega) = E_{\\text{align}} - \\omega\\,i_a$, where $E_{\\text{align}}$ (in $\\mathrm{MeV}$) is the intrinsic energy cost associated with creating the aligned quasiparticle configuration.\n\n4. Blocking in Hartree–Fock–Bogoliubov (HFB) means that one quasiparticle is occupied, which reduces pairing correlations and increases the effective moment of inertia. We parameterize this effect by a fractional increase $\\alpha \\ge 0$ in the core moment of inertia for the aligned band. Thus, the unaligned (A) band has core moment $\\mathcal{J}_A = \\mathcal{J}_0$, while the aligned (B) band has $\\mathcal{J}_B = \\mathcal{J}_0\\,(1+\\alpha)$, with $\\mathcal{J}_0$ in $\\hbar^2/\\mathrm{MeV}$.\n\n5. The two-band rotating-frame Routhians are\n$$\nE_A'(\\omega) = -\\tfrac{1}{2}\\,\\mathcal{J}_0\\,\\omega^2,\n\\qquad\nE_B'(\\omega) = E_{\\text{align}} - \\omega\\,i_a - \\tfrac{1}{2}\\,\\mathcal{J}_0(1+\\alpha)\\,\\omega^2.\n$$\n\n6. The interaction between the two configurations is modeled by a constant mixing matrix element $V$ (in $\\mathrm{MeV}$). The resulting $2\\times 2$ rotating-frame Hamiltonian is\n$$\nH'(\\omega) =\n\\begin{pmatrix}\nE_A'(\\omega) & V \\\\\nV & E_B'(\\omega)\n\\end{pmatrix}.\n$$\nThe ground-state Routhian $E'_-(\\omega)$ is the lower eigenvalue of $H'(\\omega)$ obtained by diagonalization.\n\n7. The total angular momentum expectation value as a function of rotational frequency follows from the cranking definition:\n$$\nI(\\omega) = -\\frac{dE'_-(\\omega)}{d\\omega}.\n$$\n\n8. The kinematic moment of inertia and dynamic moment of inertia are defined by\n$$\n\\mathcal{J}^{(1)}(\\omega) = \\frac{I(\\omega)}{\\omega},\n\\qquad\n\\mathcal{J}^{(2)}(\\omega) = \\frac{dI(\\omega)}{d\\omega}.\n$$\nBoth $\\mathcal{J}^{(1)}$ and $\\mathcal{J}^{(2)}$ are in units of $\\hbar^2/\\mathrm{MeV}$.\n\n9. The diabatic crossing frequency (the frequency at which the two un-mixed bands would cross) is defined by solving $E_A'(\\omega) = E_B'(\\omega)$ for $\\omega$. This yields the quadratic equation\n$$\n\\frac{1}{2}\\,\\mathcal{J}_0\\,\\alpha\\,\\omega^2 + i_a\\,\\omega - E_{\\text{align}} = 0,\n$$\nwhose physically relevant solution for $\\alpha > 0$ is\n$$\n\\omega_c = \\frac{-i_a + \\sqrt{i_a^2 + 2\\,\\mathcal{J}_0\\,\\alpha\\,E_{\\text{align}}}}{\\mathcal{J}_0\\,\\alpha}.\n$$\nFor $\\alpha = 0$, use $\\omega_c = E_{\\text{align}}/i_a$.\n\n10. The change across the crossing for a given quantity $Q(\\omega)$ (either $\\mathcal{J}^{(1)}$ or $\\mathcal{J}^{(2)}$) is defined as\n$$\n\\Delta Q = \\langle Q(\\omega)\\rangle_{\\text{post}} - \\langle Q(\\omega)\\rangle_{\\text{pre}},\n$$\nwhere $\\langle\\cdot\\rangle_{\\text{pre}}$ is the average over a frequency window just below the crossing, and $\\langle\\cdot\\rangle_{\\text{post}}$ is the average over a window just above the crossing. Use symmetric windows of half-width $w$ and exclude a small neighborhood of size $\\varepsilon$ around $\\omega_c$ to avoid the immediate mixing region:\n$$\n\\text{pre-window}:\\ \\omega \\in [\\omega_c - w,\\ \\omega_c - \\varepsilon],\\quad\n\\text{post-window}:\\ \\omega \\in [\\omega_c + \\varepsilon,\\ \\omega_c + w].\n$$\n\nYour program must:\n\n- Construct $H'(\\omega)$ over a uniform frequency grid using the model above.\n- Diagonalize $H'(\\omega)$ at each grid point to obtain $E'_-(\\omega)$.\n- Compute $I(\\omega)$ by numerical differentiation of $E'_-(\\omega)$ with respect to $\\omega$ using finite differences.\n- Compute $\\mathcal{J}^{(1)}(\\omega)$ and $\\mathcal{J}^{(2)}(\\omega)$ using the definitions above.\n- Compute the changes $\\Delta \\mathcal{J}^{(1)}$ and $\\Delta \\mathcal{J}^{(2)}$ across the crossing using the specified windows.\n\nUnits and conventions:\n\n- Express $\\omega$ in $\\mathrm{MeV}/\\hbar$, energies in $\\mathrm{MeV}$, angular momenta in $\\hbar$, and $\\mathcal{J}^{(1)}$, $\\mathcalJ}^{(2)}$ in $\\hbar^2/\\mathrm{MeV}$.\n- Use radians implicitly when differentiating with respect to $\\omega$; no angle unit needs to be specified.\n\nFrequency grid and windows:\n\n- Use a frequency grid $\\omega \\in [\\omega_{\\min}, \\omega_{\\max}]$ with step $\\Delta\\omega$, where $\\omega_{\\min} > 0$ to avoid division by zero in $\\mathcal{J}^{(1)}(\\omega)$.\n- Use the symmetric windows defined above with parameters $w$ and $\\varepsilon$.\n\nTest suite:\n\nImplement the program to evaluate the following parameter sets, each given as a tuple $(\\mathcal{J}_0, \\alpha, i_a, E_{\\text{align}}, V, \\omega_{\\min}, \\omega_{\\max}, \\Delta\\omega, w, \\varepsilon)$:\n\n- Case 1 (general mixing, moderate blocking, typical alignment):\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.05,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$.\n- Case 2 (no mixing, sharp crossing limit):\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.00,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$.\n- Case 3 (strong mixing, avoided crossing more pronounced):\n  $(30.0,\\ 0.12,\\ 6.0,\\ 1.20,\\ 0.20,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$.\n- Case 4 (larger alignment, weaker blocking):\n  $(28.0,\\ 0.05,\\ 10.0,\\ 1.50,\\ 0.08,\\ 0.02,\\ 0.80,\\ 0.002,\\ 0.06,\\ 0.01)$.\n\nOutput specification:\n\n- For each test case, your program must output a list containing two floating-point numbers: $[\\Delta \\mathcal{J}^{(1)},\\ \\Delta \\mathcal{J}^{(2)}]$, in units of $\\hbar^2/\\mathrm{MeV}$.\n- Aggregate the results of all test cases into a single list in the order given above, and print exactly one line containing this aggregate list formatted as a comma-separated list enclosed in square brackets. For example: `[[dJ1_case1,dJ2_case1],[dJ1_case2,dJ2_case2],[dJ1_case3,dJ2_case3],[dJ1_case4,dJ2_case4]]`.", "solution": "The problem statement has been critically examined and is found to be valid. It is scientifically grounded in the principles of nuclear structure physics, specifically the cranked Hartree-Fock-Bogoliubov (HFB) formalism for describing rotational bands in deformed nuclei. The problem is well-posed, with all necessary parameters and a clear computational objective. The language is objective and the parameters provided are physically realistic. Therefore, a solution is warranted.\n\nThe core of this problem is to model a two-band mixing scenario in a rotating nucleus and to quantify the changes in the kinematic and dynamic moments of inertia across the band crossing region. The solution proceeds by implementing the specified model step-by-step.\n\nFirst, we define the rotating frame (or Routhian) for a two-level system. The unperturbed, or diabatic, configurations are the ground-state band (band A) and an aligned two-quasiparticle band (band B). Their Routhians, $E_A'(\\omega)$ and $E_B'(\\omega)$, are functions of the rotational frequency $\\omega$. As specified, they are:\n$$\nE_A'(\\omega) = -\\frac{1}{2}\\,\\mathcal{J}_0\\,\\omega^2\n$$\n$$\nE_B'(\\omega) = E_{\\text{align}} - \\omega\\,i_a - \\frac{1}{2}\\,\\mathcal{J}_0(1+\\alpha)\\,\\omega^2\n$$\nHere, $\\mathcal{J}_0$ is the moment of inertia of the core, $E_{\\text{align}}$ is the energy cost of creating the aligned configuration at rest, $i_a$ is the angular momentum aligned by the two quasiparticles along the rotation axis, and $\\alpha$ is a parameter accounting for the reduction in pairing correlations (blocking effect), which increases the moment of inertia of the aligned band.\n\nThese two diabatic bands interact with a strength $V$. The full Routhian operator in the basis of these two states is a $2 \\times 2$ matrix:\n$$\nH'(\\omega) =\n\\begin{pmatrix}\nE_A'(\\omega) & V \\\\\nV & E_B'(\\omega)\n\\end{pmatrix}\n$$\nThe observable states, known as the yrast and yrare bands, are the eigenstates of this matrix. We are interested in the yrast band, which corresponds to the lower eigenvalue of $H'(\\omega)$ at each frequency $\\omega$. The eigenvalues $\\lambda$ of a general $2\\times 2$ matrix $\\begin{pmatrix} a & c \\\\ c & b \\end{pmatrix}$ are given by $\\lambda = \\frac{a+b \\pm \\sqrt{(a-b)^2 + 4c^2}}{2}$. The lower eigenvalue, which we denote as the yrast Routhian $E'_-(\\omega)$, is therefore:\n$$\nE'_-(\\omega) = \\frac{1}{2} \\left[ (E_A'(\\omega) + E_B'(\\omega)) - \\sqrt{(E_A'(\\omega) - E_B'(\\omega))^2 + 4V^2} \\right]\n$$\nThis expression is computed over a discrete grid of rotational frequencies $\\omega_k$ spanning the range $[\\omega_{\\min}, \\omega_{\\max}]$ with a step size of $\\Delta\\omega$.\n\nFrom the yrast Routhian $E'_-(\\omega)$, we derive the total aligned angular momentum $I(\\omega)$. Within the cranking model, this is given by the thermodynamic-like relation:\n$$\nI(\\omega) = -\\frac{dE'_-(\\omega)}{d\\omega}\n$$\nSince $E'_-(\\omega)$ is known only on a discrete grid, this derivative is computed numerically using a central finite-difference scheme.\n\nWith the angular momentum $I(\\omega)$ determined, we can calculate the kinematic and dynamic moments of inertia, $\\mathcal{J}^{(1)}(\\omega)$ and $\\mathcal{J}^{(2)}(\\omega)$, respectively. Their definitions are:\n$$\n\\mathcal{J}^{(1)}(\\omega) = \\frac{I(\\omega)}{\\omega}\n$$\n$$\n\\mathcal{J}^{(2)}(\\omega) = \\frac{dI(\\omega)}{d\\omega}\n$$\nThe kinematic moment of inertia $\\mathcal{J}^{(1)}$ is a measure of how much angular momentum is generated for a given rotational frequency. The dynamic moment of inertia $\\mathcal{J}^{(2)}$ measures the rate of change of angular momentum with frequency and is particularly sensitive to structural changes, such as band crossings. The derivative for $\\mathcal{J}^{(2)}$ is also computed using a central finite-difference method.\n\nThe final step is to analyze the behavior of $\\mathcal{J}^{(1)}$ and $\\mathcal{J}^{(2)}$ across the band crossing. The crossing point is characterized by the diabatic crossing frequency $\\omega_c$, where the unperturbed Routhians are equal, $E_A'(\\omega_c) = E_B'(\\omega_c)$. This leads to the quadratic equation for $\\omega_c$:\n$$\n\\frac{1}{2}\\,\\mathcal{J}_0\\,\\alpha\\,\\omega_c^2 + i_a\\,\\omega_c - E_{\\text{align}} = 0\n$$\nThe physically relevant (positive) solution is given in the problem statement. A special case for $\\alpha=0$ yields $\\omega_c = E_{\\text{align}}/i_a$.\n\nTo quantify the change across the crossing, we average $\\mathcal{J}^{(1)}$ and $\\mathcal{J}^{(2)}$ over two frequency windows: a pre-crossing window $[\\omega_c - w, \\omega_c - \\varepsilon]$ and a post-crossing window $[\\omega_c + \\varepsilon, \\omega_c + w]$. The parameters $w$ and $\\varepsilon$ define the width of the windows and an excluded region around $\\omega_c$ where the mixing interaction is strongest. The change in a quantity $Q(\\omega)$ is then calculated as the difference between the averages:\n$$\n\\Delta Q = \\langle Q(\\omega)\\rangle_{\\text{post}} - \\langle Q(\\omega)\\rangle_{\\text{pre}}\n$$\nThe algorithm proceeds as follows: for each parameter set, a uniform frequency grid is established. Then, the arrays for $E_A'(\\omega)$ and $E_B'(\\omega)$ are computed, followed by $E'_-(\\omega)$. Numerical differentiation via `numpy.gradient` is applied twice to obtain $I(\\omega)$ and then $\\mathcal{J}^{(2)}(\\omega)$. $\\mathcal{J}^{(1)}(\\omega)$ is found through division. The crossing frequency $\\omega_c$ is calculated, and boolean mask arrays are used to identify grid points within the pre- and post-crossing windows. Finally, `numpy.mean` is used to compute the averages over these windows, and their difference gives the final result. This entire process is repeated for each of the provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (J0, alpha, i_a, E_align, V, w_min, w_max, dw, w, eps)\n        (30.0, 0.12, 6.0, 1.20, 0.05, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 1\n        (30.0, 0.12, 6.0, 1.20, 0.00, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 2\n        (30.0, 0.12, 6.0, 1.20, 0.20, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 3\n        (28.0, 0.05, 10.0, 1.50, 0.08, 0.02, 0.80, 0.002, 0.06, 0.01), # Case 4\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_crossing_changes(params)\n        results.append(result)\n\n    # Format the output string to be exactly [[dJ1_1,dJ2_1],[dJ1_2,dJ2_2],...]\n    # without any extra spaces, as per the example format.\n    inner_parts = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef calculate_crossing_changes(params):\n    \"\"\"\n    Calculates the change in kinematic and dynamic moments of inertia\n    across a band crossing for a single set of parameters.\n    \n    Args:\n        params (tuple): A tuple containing all model and grid parameters.\n\n    Returns:\n        list: A list containing [delta_J1, delta_J2].\n    \"\"\"\n    J0, alpha, i_a, E_align, V, w_min, w_max, dw, w, eps = params\n\n    # 1. Construct the frequency grid.\n    omega = np.arange(w_min, w_max + dw, dw)\n\n    # 2. Calculate the diabatic Routhians for the two bands.\n    E_A_prime = -0.5 * J0 * omega**2\n    E_B_prime = E_align - omega * i_a - 0.5 * J0 * (1.0 + alpha) * omega**2\n\n    # 3. Calculate the yrast Routhian (lower eigenvalue of the 2x2 H' matrix).\n    sum_E = E_A_prime + E_B_prime\n    diff_E = E_A_prime - E_B_prime\n    E_minus_prime = 0.5 * (sum_E - np.sqrt(diff_E**2 + 4.0 * V**2))\n\n    # 4. Calculate the total aligned angular momentum I(omega) = -dE'/d(omega).\n    I = -np.gradient(E_minus_prime, dw)\n\n    # 5. Calculate the kinematic and dynamic moments of inertia.\n    # omega_min > 0 ensures no division by zero for J1.\n    J1 = I / omega      # Kinematic moment of inertia, J^(1)\n    J2 = np.gradient(I, dw)  # Dynamic moment of inertia, J^(2)\n\n    # 6. Calculate the diabatic crossing frequency omega_c.\n    if alpha == 0.0:\n        # If alpha is 0, the equation for omega_c is linear.\n        if i_a > 0.0:\n            omega_c = E_align / i_a\n        else:\n            # Physically, i_a must be positive for this simple model to make sense.\n            # Avoid division by zero, though test cases do not trigger this.\n            omega_c = np.nan\n    else:\n        # For alpha > 0, solve the quadratic equation for omega_c:\n        # 0.5*J0*alpha*w^2 + i_a*w - E_align = 0\n        a = 0.5 * J0 * alpha\n        b = i_a\n        c = -E_align\n        discriminant = b**2 - 4.0 * a * c\n        # The physically relevant solution corresponds to a positive frequency.\n        omega_c = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n    # 7. Define the pre- and post-crossing analysis windows.\n    pre_window_mask = (omega >= omega_c - w) & (omega <= omega_c - eps)\n    post_window_mask = (omega >= omega_c + eps) & (omega <= omega_c + w)\n    \n    # 8. Calculate the average values in the windows.\n    # Use np.mean, which correctly handles cases where a window might be empty\n    # (by returning NaN), although this is not expected with the given parameters.\n    avg_J1_pre = np.mean(J1[pre_window_mask])\n    avg_J1_post = np.mean(J1[post_window_mask])\n    \n    avg_J2_pre = np.mean(J2[pre_window_mask])\n    avg_J2_post = np.mean(J2[post_window_mask])\n\n    # 9. Compute the changes Delta J^(1) and Delta J^(2).\n    delta_J1 = avg_J1_post - avg_J1_pre\n    delta_J2 = avg_J2_post - avg_J2_pre\n\n    return [delta_J1, delta_J2]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3550162"}, {"introduction": "An alternative and more fundamental approach to generating rotational states, compared to the cranking model, is angular momentum projection. This method constructs states of good angular momentum directly from an intrinsic, deformed state that has broken rotational symmetry. This computational exercise focuses on the core numerical task of projection: evaluating integrals of the overlap kernel over the rotation group [@problem_id:3550190]. You will implement and compare the efficiency of different numerical quadrature schemes, gaining practical skills in a vital technique used in many modern nuclear structure theories.", "problem": "Consider an intrinsic deformed nuclear state represented by a normalized vector $\\lvert \\Phi \\rangle$ in Hilbert space, and the rotation operator $\\hat{R}(\\Omega)$ parameterized by Euler angles $\\Omega = (\\alpha,\\beta,\\gamma)$ with $\\alpha \\in [0,2\\pi)$, $\\beta \\in [0,\\pi]$, and $\\gamma \\in [0,2\\pi)$. The Haar measure on the rotation group is $d\\Omega = d\\alpha \\, d\\beta \\, d\\gamma \\, \\sin\\beta$. In collective rotational motion and angular momentum projection, a central quantity is the norm kernel overlap $\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle$, and the angular momentum projected norm for total angular momentum $J$ and axial symmetry ($K=0$) is obtained by integrating this overlap against the Wigner matrix element $D^J_{00}(\\Omega)$ over the rotation group.\n\nFor an axially symmetric intrinsic state, assume the overlap kernel depends only on the polar angle $\\beta$ and takes the form\n$$\n\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp\\!\\big(\\kappa \\cos\\beta\\big),\n$$\nwhere $\\kappa \\ge 0$ is a dimensionless deformation strength parameter, and the angle $\\beta$ is in radians. The angular momentum projected norm for $J$ is then\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, D^J_{00}(\\Omega) \\, \\exp\\!\\big(\\kappa \\cos\\beta\\big).\n$$\nAll angles are to be treated in radians.\n\nYour task is to implement two numerical quadrature schemes to evaluate $N_J$ for this kernel:\n\n1. A mixed quadrature using Gauss–Legendre quadrature for the $\\beta$ integral (after the change of variable $x=\\cos\\beta$ on the interval $x \\in [-1,1]$) and trapezoidal (periodic) quadrature for the $\\alpha$ and $\\gamma$ integrals on $[0,2\\pi)$.\n\n2. A fully trapezoidal quadrature using trapezoidal (periodic) quadrature for $\\alpha$ and $\\gamma$ on $[0,2\\pi)$ and trapezoidal quadrature for $\\beta$ on $[0,\\pi]$ with the correct $\\sin\\beta$ measure factor explicitly included.\n\nUse the foundational facts that $D^J_{00}(\\Omega) = d^J_{00}(\\beta)$ and $d^J_{00}(\\beta) = P_J(\\cos\\beta)$, where $P_J$ is the Legendre polynomial of degree $J$. No other shortcut formulas should be assumed in the problem statement.\n\nDesign your program to compute $N_J$ for all integer $J$ satisfying $0 \\le J \\le 20$, for the parameter sets in the test suite below. For each parameter set, the program must verify whether both quadrature schemes achieve a target relative error less than $10^{-6}$ for all $J$ in the specified range, compared to an analytically derived reference value obtained from first principles. If the exact reference value for a given $J$ is zero, compare the absolute error to a threshold of $10^{-12}$ instead of relative error. Angles must be treated in radians. All computed values are dimensionless.\n\nTest suite (each tuple defines one test case as $(\\kappa, J_{\\text{max}}, N_{\\beta}^{\\text{GL}}, N_{\\beta}^{\\text{Trap}}, N_{\\alpha}, N_{\\gamma})$):\n- $(0.0, 20, 64, 512, 16, 16)$\n- $(1.0, 20, 80, 4096, 32, 32)$\n- $(5.0, 20, 120, 8192, 64, 64)$\n- $(20.0, 20, 240, 16384, 128, 128)$\n\nYour program must:\n- Implement both quadrature schemes described above.\n- Derive and use an exact analytical reference for $N_J$ as warranted by the above definitions and the kernel choice, without relying on any unspecified shortcuts in the problem statement.\n- For each test case, return two boolean results: the first for the mixed Gauss–Legendre plus trapezoidal scheme, and the second for the fully trapezoidal scheme. Each boolean is true if and only if the prescribed error criterion is satisfied simultaneously for all $J$ in $\\{0,1,2,\\dots,J_{\\text{max}}\\}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered in the same sequence as the test suite and, for each test case, listing first the result for the mixed Gauss–Legendre plus trapezoidal scheme and then for the fully trapezoidal scheme. For example, the output should have the form\n$$\n[\\text{case1\\_GL},\\text{case1\\_Trap},\\text{case2\\_GL},\\text{case2\\_Trap},\\text{case3\\_GL},\\text{case3\\_Trap},\\text{case4\\_GL},\\text{case4\\_Trap}],\n$$\nwhere each entry is a boolean literal.", "solution": "The problem requires the numerical evaluation of the angular momentum projected norm, $N_J$, for an axially symmetric deformed nuclear state. The evaluation must be performed using two distinct quadrature schemes, and their accuracy is to be validated against an analytically derived reference value.\n\nThe angular momentum projected norm is given by:\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, D^J_{00}(\\Omega) \\, \\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle\n$$\nThe problem specifies the overlap kernel $\\langle \\Phi \\lvert \\hat{R}(\\Omega) \\rvert \\Phi \\rangle = \\exp(\\kappa \\cos\\beta)$ and the identity for the Wigner D-matrix element $D^J_{00}(\\Omega) = P_J(\\cos\\beta)$, where $P_J$ is the Legendre polynomial of degree $J$.\n\nFirst, we derive the analytical reference value for $N_J$. Substituting the given expressions into the formula for $N_J$:\n$$\nN_J = \\frac{2J+1}{8\\pi^2} \\int_0^{2\\pi} d\\alpha \\int_0^\\pi d\\beta \\, \\sin\\beta \\int_0^{2\\pi} d\\gamma \\, P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta)\n$$\nThe integrand is independent of the Euler angles $\\alpha$ and $\\gamma$. The integration over these variables is therefore trivial:\n$$\n\\int_0^{2\\pi} d\\alpha = 2\\pi \\quad \\text{and} \\quad \\int_0^{2\\pi} d\\gamma = 2\\pi\n$$\nThis simplifies the expression for $N_J$ to:\n$$\nN_J = \\frac{2J+1}{8\\pi^2} (2\\pi)(2\\pi) \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\n$$\nN_J = \\frac{2J+1}{2} \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\nTo evaluate the remaining integral over $\\beta$, we perform a change of variables to $x = \\cos\\beta$. This implies $dx = -\\sin\\beta \\, d\\beta$. The integration limits change from $\\beta \\in [0, \\pi]$ to $x \\in [1, -1]$.\n$$\nN_J = \\frac{2J+1}{2} \\int_1^{-1} P_J(x) \\, e^{\\kappa x} \\, (-dx) = \\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, e^{\\kappa x} \\, dx\n$$\nThe integral on the right-hand side has a standard representation in terms of the modified spherical Bessel function of the first kind, $i_J(z)$, which is defined by:\n$$\ni_J(z) = \\frac{1}{2} \\int_{-1}^{1} e^{zx} P_J(x) \\, dx\n$$\nBy comparing this definition with our expression, we can identify $z = \\kappa$ and thus:\n$$\n\\int_{-1}^{1} P_J(x) \\, e^{\\kappa x} \\, dx = 2 i_J(\\kappa)\n$$\nSubstituting this back into the formula for $N_J$ yields the exact analytical result:\n$$\nN_J^{\\text{ref}} = \\frac{2J+1}{2} \\left[ 2 i_J(\\kappa) \\right] = (2J+1) i_J(\\kappa)\n$$\nThis analytical formula will serve as the reference for validating the numerical schemes. The values of $i_J(\\kappa)$ can be computed using standard scientific libraries.\n\nNext, we specify the implementation of the two numerical quadrature schemes. As established, the integrals over $\\alpha$ and $\\gamma$ contribute a multiplicative factor of $(2\\pi)^2$, which cancels with the denominator. This holds true for the periodic trapezoidal rule as well, since for any number of points $N > 0$, the rule exactly integrates a constant function over a periodic domain. Thus, both numerical schemes reduce to evaluating the integral over $\\beta$:\n$$\nI_\\beta = \\int_0^\\pi P_J(\\cos\\beta) \\, \\exp(\\kappa \\cos\\beta) \\, \\sin\\beta \\, d\\beta\n$$\nsuch that $N_J \\approx \\frac{2J+1}{2} I_\\beta^{\\text{num}}$.\n\n1.  **Mixed Gauss–Legendre plus Trapezoidal Scheme:**\n    This scheme employs Gauss-Legendre quadrature for the $\\beta$-integration. We use the change of variables $x=\\cos\\beta$ to transform the integral to the standard interval $[-1, 1]$:\n    $$\n    I_\\beta = \\int_{-1}^{1} P_J(x) e^{\\kappa x} dx\n    $$\n    Using an $N_{\\beta}^{\\text{GL}}$-point Gauss-Legendre quadrature with nodes $x_i$ and weights $w_i$, the integral is approximated as:\n    $$\n    I_\\beta^{\\text{GL}} \\approx \\sum_{i=1}^{N_{\\beta}^{\\text{GL}}} w_i P_J(x_i) e^{\\kappa x_i}\n    $$\n    The corresponding norm is $N_J^{\\text{GL}} = \\frac{2J+1}{2} I_\\beta^{\\text{GL}}$. This method is expected to be highly efficient, as Gauss-Legendre quadrature converges exponentially for analytic integrands.\n\n2.  **Fully Trapezoidal Scheme:**\n    This scheme uses the trapezoidal rule directly on the $\\beta$ integral over $[0, \\pi]$. The interval is discretized into $N_{\\beta}^{\\text{Trap}}$ subintervals of width $h_\\beta = \\pi / N_{\\beta}^{\\text{Trap}}$, with points $\\beta_j = j \\cdot h_\\beta$ for $j=0, 1, \\dots, N_{\\beta}^{\\text{Trap}}$. The integrand is $f(\\beta) = P_J(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta$. The trapezoidal rule gives:\n    $$\n    I_\\beta^{\\text{Trap}} \\approx h_\\beta \\left[ \\frac{f(\\beta_0) + f(\\beta_{N_{\\beta}^{\\text{Trap}}})}{2} + \\sum_{j=1}^{N_{\\beta}^{\\text{Trap}}-1} f(\\beta_j) \\right]\n    $$\n    Since $f(0) = f(\\pi) = 0$ due to the $\\sin\\beta$ factor, the endpoint contributions vanish. The approximation simplifies to:\n    $$\n    I_\\beta^{\\text{Trap}} \\approx \\sum_{j=1}^{N_{\\beta}^{\\text{Trap}}-1} \\frac{\\pi}{N_{\\beta}^{\\text{Trap}}} P_J(\\cos\\beta_j) \\exp(\\kappa \\cos\\beta_j) \\sin\\beta_j\n    $$\n    The corresponding norm is $N_J^{\\text{Trap}} = \\frac{2J+1}{2} I_\\beta^{\\text{Trap}}$. Since the integrand's derivatives are not all zero at the endpoints, this method is expected to exhibit standard algebraic convergence ($O(h^2)$), requiring a significantly larger number of points than the Gauss-Legendre scheme for equivalent accuracy, especially for large $\\kappa$ where the integrand becomes sharply peaked.\n\nFor each test case and each scheme, the numerically computed values $N_J^{\\text{num}}$ for $J \\in \\{0, 1, \\dots, J_{\\text{max}}\\}$ are compared to the analytical reference $N_J^{\\text{ref}}$. The scheme is deemed successful if for all $J$, the relative error $\\left| (N_J^{\\text{num}} - N_J^{\\text{ref}}) / N_J^{\\text{ref}} \\right|$ is less than $10^{-6}$. If $|N_J^{\\text{ref}}|$ is close to zero (less than $10^{-12}$), an absolute error check $|N_J^{\\text{num}} - N_J^{\\text{ref}}| < 10^{-12}$ is used instead.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_in, eval_legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the nuclear physics problem of calculating and validating angular momentum projected norms.\n    \"\"\"\n\n    def calculate_analytical_nj(j_max, kappa):\n        \"\"\"\n        Calculates the analytical reference value N_J = (2J+1) * i_J(kappa).\n        \"\"\"\n        j_values = np.arange(j_max + 1)\n        # scipy.special.spherical_in(n, z) computes the modified spherical Bessel function i_n(z).\n        # It can take an array for the order n.\n        i_j_values = spherical_in(j_values, kappa)\n        return (2 * j_values + 1) * i_j_values\n\n    def calculate_nj_mixed_scheme(j_max, kappa, n_beta_gl):\n        \"\"\"\n        Calculates N_J using a mixed scheme: Gauss-Legendre for beta-integration.\n        \"\"\"\n        # Get Gauss-Legendre nodes (x) and weights (w) on the interval [-1, 1].\n        x_nodes, w_weights = leggauss(n_beta_gl)\n        \n        results = np.zeros(j_max + 1)\n        exp_values = np.exp(kappa * x_nodes)\n        \n        for j in range(j_max + 1):\n            # Integrand is P_J(x) * exp(kappa*x).\n            p_j_values = eval_legendre(j, x_nodes)\n            integrand_values = p_j_values * exp_values\n            \n            # Perform the quadrature sum: sum(w_i * f(x_i)).\n            integral_val = np.sum(w_weights * integrand_values)\n            \n            # The full expression for N_J from the simplified integral.\n            n_j = (2 * j + 1) / 2.0 * integral_val\n            results[j] = n_j\n            \n        return results\n\n    def calculate_nj_trapz_scheme(j_max, kappa, n_beta_trap):\n        \"\"\"\n        Calculates N_J using a fully trapezoidal scheme.\n        \"\"\"\n        # Grid for beta from 0 to pi with n_beta_trap intervals (n_beta_trap + 1 points).\n        beta_grid = np.linspace(0, np.pi, n_beta_trap + 1)\n        cos_beta = np.cos(beta_grid)\n        sin_beta = np.sin(beta_grid)\n        \n        results = np.zeros(j_max + 1)\n        exp_values = np.exp(kappa * cos_beta)\n        \n        for j in range(j_max + 1):\n            # Integrand is P_J(cos(beta)) * exp(kappa*cos(beta)) * sin(beta).\n            p_j_values = eval_legendre(j, cos_beta)\n            integrand_values = p_j_values * exp_values * sin_beta\n            \n            # Use numpy.trapz for numerical integration.\n            integral_val = np.trapz(integrand_values, x=beta_grid)\n            \n            # The full expression for N_J.\n            n_j = (2 * j + 1) / 2.0 * integral_val\n            results[j] = n_j\n            \n        return results\n\n    def verify_scheme(numerical_results, analytical_results, j_max):\n        \"\"\"\n        Verifies if a scheme meets the specified error criteria for all J.\n        \"\"\"\n        abs_tol = 1.0e-12\n        rel_tol = 1.0e-6\n        \n        is_valid = True\n        for j in range(j_max + 1):\n            num_val = numerical_results[j]\n            ana_val = analytical_results[j]\n            \n            if np.abs(ana_val) < abs_tol:\n                # Use absolute error for values close to zero.\n                if not (np.abs(num_val - ana_val) < abs_tol):\n                    is_valid = False\n                    break\n            else:\n                # Use relative error otherwise.\n                rel_error = np.abs((num_val - ana_val) / ana_val)\n                if not (rel_error < rel_tol):\n                    is_valid = False\n                    break\n        return is_valid\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # (kappa, J_max, N_beta_GL, N_beta_Trap, N_alpha, N_gamma)\n        (0.0, 20, 64, 512, 16, 16),\n        (1.0, 20, 80, 4096, 32, 32),\n        (5.0, 20, 120, 8192, 64, 64),\n        (20.0, 20, 240, 16384, 128, 128)\n    ]\n\n    final_results = []\n    for case in test_cases:\n        kappa, j_max, n_beta_gl, n_beta_trap, n_alpha, n_gamma = case\n        \n        # Calculate reference values once per test case.\n        analytical_njs = calculate_analytical_nj(j_max, kappa)\n        \n        # Evaluate and verify Scheme 1: Mixed Gauss-Legendre.\n        gl_njs = calculate_nj_mixed_scheme(j_max, kappa, n_beta_gl)\n        gl_valid = verify_scheme(gl_njs, analytical_njs, j_max)\n        final_results.append(gl_valid)\n        \n        # Evaluate and verify Scheme 2: Full Trapezoidal.\n        trapz_njs = calculate_nj_trapz_scheme(j_max, kappa, n_beta_trap)\n        trapz_valid = verify_scheme(trapz_njs, analytical_njs, j_max)\n        final_results.append(trapz_valid)\n        \n    # Print the final results in the specified format.\n    # Convert boolean to lowercase string as per example format in problem description.\n    print(f\"[{','.join(str(b).lower() for b in final_results)}]\")\n\nsolve()\n```", "id": "3550190"}]}