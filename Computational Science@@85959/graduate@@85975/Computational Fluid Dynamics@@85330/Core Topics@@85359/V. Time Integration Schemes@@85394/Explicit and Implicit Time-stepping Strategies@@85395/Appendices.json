{"hands_on_practices": [{"introduction": "In computational fluid dynamics, the choice of an implicit time-stepping scheme often involves a trade-off between numerical stability and physical fidelity. While schemes like Crank-Nicolson are celebrated for their second-order accuracy and energy-preserving properties on linear problems, others like backward Euler introduce numerical dissipation. This exercise delves into this crucial distinction by analyzing the amplitude and phase errors of these two methods, providing quantitative insight into how they can alter the propagation of waves and impact the simulation of phenomena like under-resolved turbulence [@problem_id:3316984].", "problem": "Consider the linear wave equation on a periodic domain, $u_{t} + c\\,u_{x} = 0$, with constant wave speed $c > 0$. Let the spatial derivative be semi-discretized by a skew-symmetric linear operator that is consistent with $\\partial_{x}$, so that for a single Fourier mode with wavenumber $k$, the semi-discrete evolution of its complex amplitude $\\hat{u}(t)$ is governed by the ordinary differential equation\n$$\n\\frac{d\\hat{u}}{dt} = i\\,\\omega\\,\\hat{u},\\quad \\omega = c\\,\\tilde{k},\\quad \\omega > 0,\n$$\nwhere $\\tilde{k}$ is the discrete wavenumber associated with the chosen spatial discretization. Denote the uniform time step by $\\Delta t$ and the dimensionless parameter $z = \\omega\\,\\Delta t$.\n\nApply the backward Euler method and the Crank–Nicolson method to the semi-discrete ordinary differential equation and define, for each method, the one-step amplification factor $g$ by $\\hat{u}^{n+1} = g\\,\\hat{u}^{n}$. For each method:\n- Derive $g$ in closed form as a function of $z$.\n- Define the one-step amplitude error as $|g| - 1$ (relative to the exact solution’s amplitude, which is constant in time for purely imaginary $\\omega$).\n- Define the one-step phase error (in radians) as $\\arg(g) - \\omega\\,\\Delta t$, where $\\arg(g)$ is the principal argument of the complex number $g$.\n- Obtain the leading-order small-$z$ asymptotic expansion of the amplitude error up to and including terms of order $z^{2}$, and the phase error up to and including terms of order $z^{3}$.\n\nThen, using these expansions, compute the ratio of the magnitudes of the leading-order phase error coefficients of backward Euler to Crank–Nicolson (that is, the ratio of the absolute values of the coefficients multiplying $z^{3}$ in the leading-order phase error expansions). Report this ratio as a single real number. Use radians for all phase quantities. No rounding is required.\n\nFinally, explain, based on your derivations, the implications of the amplitude and phase behaviors of these time-stepping strategies for under-resolved turbulence in computational fluid dynamics, explicitly addressing the roles of numerical dissipation and dispersion introduced by time integration in the presence of skew-symmetric spatial operators.", "solution": "The linear wave equation $u_{t} + c\\,u_{x} = 0$ on a periodic domain can be expressed in Fourier space. For a single Fourier mode with wavenumber $k$, $u(x,t) = \\hat{u}(t)\\,\\exp(i k x)$, and a skew-symmetric semi-discrete spatial operator (for example, a spectral derivative or centered difference on a periodic grid) maps this mode to a purely imaginary eigenvalue. Therefore the semi-discrete evolution equation for the mode amplitude is\n$$\n\\frac{d\\hat{u}}{dt} = i\\,\\omega\\,\\hat{u},\\quad \\omega = c\\,\\tilde{k},\\quad \\omega > 0.\n$$\nThe exact solution over one time step $\\Delta t$ is $\\hat{u}(t+\\Delta t) = \\exp(i \\omega \\Delta t)\\,\\hat{u}(t)$, which has unit modulus and accumulates phase $\\omega \\Delta t$.\n\nWe analyze backward Euler and Crank–Nicolson applied to $\\frac{d\\hat{u}}{dt} = i\\,\\omega\\,\\hat{u}$.\n\nBackward Euler is defined by\n$$\n\\hat{u}^{n+1} = \\hat{u}^{n} + \\Delta t\\, i\\,\\omega\\,\\hat{u}^{n+1}.\n$$\nSolving for the amplification factor $g_{\\mathrm{BE}}$ gives\n$$\n\\hat{u}^{n+1}\\left(1 - i\\,\\omega\\,\\Delta t\\right) = \\hat{u}^{n}\\quad\\Rightarrow\\quad g_{\\mathrm{BE}} = \\frac{\\hat{u}^{n+1}}{\\hat{u}^{n}} = \\frac{1}{1 - i z},\\quad z = \\omega\\,\\Delta t.\n$$\nIts modulus and argument are\n$$\n|g_{\\mathrm{BE}}| = \\frac{1}{\\sqrt{1 + z^{2}}},\\qquad \\arg(g_{\\mathrm{BE}}) = \\arctan(z).\n$$\nThe one-step amplitude error is\n$$\n|g_{\\mathrm{BE}}| - 1 = \\frac{1}{\\sqrt{1 + z^{2}}} - 1.\n$$\nFor small $z$, using $(1 + z^{2})^{-1/2} = 1 - \\frac{1}{2} z^{2} + \\frac{3}{8} z^{4} + \\mathcal{O}(z^{6})$, we obtain\n$$\n|g_{\\mathrm{BE}}| - 1 = -\\frac{1}{2} z^{2} + \\frac{3}{8} z^{4} + \\mathcal{O}(z^{6}).\n$$\nThe one-step phase error in radians is\n$$\n\\text{Phase error}_{\\mathrm{BE}} = \\arg(g_{\\mathrm{BE}}) - \\omega\\,\\Delta t = \\arctan(z) - z.\n$$\nUsing $\\arctan(z) = z - \\frac{1}{3} z^{3} + \\frac{1}{5} z^{5} + \\mathcal{O}(z^{7})$, the leading-order phase error is\n$$\n\\text{Phase error}_{\\mathrm{BE}} = -\\frac{1}{3} z^{3} + \\frac{1}{5} z^{5} + \\mathcal{O}(z^{7}).\n$$\n\nCrank–Nicolson is defined by\n$$\n\\hat{u}^{n+1} = \\hat{u}^{n} + \\Delta t\\, i\\,\\omega\\,\\frac{\\hat{u}^{n+1} + \\hat{u}^{n}}{2}.\n$$\nSolving for $g_{\\mathrm{CN}}$ gives\n$$\n\\hat{u}^{n+1}\\left(1 - i\\,\\frac{z}{2}\\right) = \\hat{u}^{n}\\left(1 + i\\,\\frac{z}{2}\\right)\\quad\\Rightarrow\\quad g_{\\mathrm{CN}} = \\frac{1 + i\\,\\frac{z}{2}}{1 - i\\,\\frac{z}{2}}.\n$$\nIts modulus is\n$$\n|g_{\\mathrm{CN}}| = \\frac{\\sqrt{1 + \\left(\\frac{z}{2}\\right)^{2}}}{\\sqrt{1 + \\left(\\frac{z}{2}\\right)^{2}}} = 1,\n$$\nso the one-step amplitude error is identically zero:\n$$\n|g_{\\mathrm{CN}}| - 1 = 0.\n$$\nThe argument of $g_{\\mathrm{CN}}$ is the difference of the arguments of numerator and denominator:\n$$\n\\arg\\!\\left(1 + i\\,\\frac{z}{2}\\right) = \\arctan\\!\\left(\\frac{z}{2}\\right),\\qquad \\arg\\!\\left(1 - i\\,\\frac{z}{2}\\right) = -\\arctan\\!\\left(\\frac{z}{2}\\right),\n$$\nhence\n$$\n\\arg(g_{\\mathrm{CN}}) = 2\\,\\arctan\\!\\left(\\frac{z}{2}\\right).\n$$\nThe one-step phase error in radians is\n$$\n\\text{Phase error}_{\\mathrm{CN}} = 2\\,\\arctan\\!\\left(\\frac{z}{2}\\right) - z.\n$$\nUsing the series $\\arctan(\\xi) = \\xi - \\frac{1}{3}\\xi^{3} + \\frac{1}{5}\\xi^{5} + \\mathcal{O}(\\xi^{7})$ with $\\xi = z/2$, we obtain\n$$\n2\\,\\arctan\\!\\left(\\frac{z}{2}\\right) = 2\\left(\\frac{z}{2} - \\frac{1}{3}\\left(\\frac{z}{2}\\right)^{3} + \\frac{1}{5}\\left(\\frac{z}{2}\\right)^{5} + \\mathcal{O}(z^{7})\\right) = z - \\frac{1}{12} z^{3} + \\frac{1}{80} z^{5} + \\mathcal{O}(z^{7}),\n$$\nso\n$$\n\\text{Phase error}_{\\mathrm{CN}} = -\\frac{1}{12} z^{3} + \\frac{1}{80} z^{5} + \\mathcal{O}(z^{7}).\n$$\n\nWe now compute the ratio of the magnitudes of the leading-order phase error coefficients (the coefficients multiplying $z^{3}$):\n- For backward Euler, the magnitude is $\\left|\\,-\\frac{1}{3}\\,\\right| = \\frac{1}{3}$.\n- For Crank–Nicolson, the magnitude is $\\left|\\,-\\frac{1}{12}\\,\\right| = \\frac{1}{12}$.\nTherefore the requested ratio is\n$$\n\\frac{\\frac{1}{3}}{\\frac{1}{12}} = 4.\n$$\n\nImplications for under-resolved turbulence in computational fluid dynamics follow from these amplitude and phase behaviors. The semi-discrete linearized dynamics of advective terms are skew-symmetric, corresponding to purely imaginary eigenvalues. In this setting, Crank–Nicolson introduces no amplitude damping ($|g_{\\mathrm{CN}}| = 1$), preserving the norm of such linear modes while exhibiting a comparatively small dispersive phase error of order $z^{3}$ with coefficient $-\\frac{1}{12}$. Backward Euler introduces unconditional amplitude damping ($|g_{\\mathrm{BE}}|  1$) with leading-order deficit $-\\frac{1}{2} z^{2}$ and a larger dispersive phase error with coefficient $-\\frac{1}{3}$. For under-resolved turbulence, where small scales cannot be accurately represented by the grid, time-integration-induced dissipation can act as an implicit subgrid regularization. Backward Euler’s time-step-dependent damping preferentially attenuates high-frequency content, analogous to Implicit Large Eddy Simulation (ILES), but at the cost of increased dispersion error and potential overdamping of dynamically relevant near-grid scales. Crank–Nicolson, being non-dissipative for skew-symmetric linear dynamics, preserves energy of these components and has smaller phase error, which is beneficial for accurately propagating waves and vortical structures; however, in the presence of nonlinear interactions, aliasing, and non-normal effects, the absence of time-stepping dissipation can permit energy accumulation at unresolved scales unless complemented by spatial filtering, dealiasing, or explicit subgrid modeling. Consequently, the choice between these strategies involves a trade-off: backward Euler provides robustness via dissipation but distorts both amplitude and phase more strongly; Crank–Nicolson maintains amplitude fidelity and lower dispersion for linear waves, but relies on other mechanisms to control under-resolved dynamics.", "answer": "$$\\boxed{4}$$", "id": "3316984"}, {"introduction": "A key advantage of implicit methods is their potential for unconditional stability, which allows for time steps far exceeding the explicit Courant–Friedrichs–Lewy (CFL) limit. However, this powerful property relies on the assumption that the implicit algebraic system is solved exactly at each time step, a condition rarely met in practice where iterative solvers are used. This practice provides a crucial lesson in numerical robustness by demonstrating how a finite solver tolerance can undermine the theoretical stability of a method, leading to divergence even for an $A$-stable scheme [@problem_id:3316997].", "problem": "Consider the initial value problem for a scalar ordinary differential equation in computational fluid dynamics: $y'(t) = f(y(t))$ with $y(0) = y_0$, where $f$ is globally Lipschitz continuous with Lipschitz constant $L > 0$, meaning $|f(y) - f(z)| \\le L |y - z|$ for all $y$ and $z$. A widely used A-stable one-step implicit method is the backward (implicit) Euler scheme, defined for a time step size $\\Delta t > 0$ by the nonlinear equation\n$$\ny_{n+1} = y_n + \\Delta t\\, f(y_{n+1}),\n$$\nwhich must be solved for $y_{n+1}$ at each step $n$. In practice, the implicit equation is often solved using an iterative linear or nonlinear solver that terminates when a prescribed residual tolerance is met. Let the computed iterate $y_{n+1}^{\\text{(approx)}}$ satisfy a residual condition\n$$\nr_n := y_{n+1}^{\\text{(approx)}} - y_n - \\Delta t\\, f\\!\\left(y_{n+1}^{\\text{(approx)}}\\right),\n$$\nwith a relative tolerance $|r_n| \\le \\zeta\\, |y_n|$ for some $\\zeta \\ge 0$ (dimensionless). Assume the worst-case alignment of the residual with $y_n$ that maximizes growth in the computed solution.\n\nThe task is to formally derive, from first principles, a counterexample that demonstrates loss of unconditional stability in an A-stable implicit method due to an inexact linear/nonlinear solve, and to quantify the tolerance threshold in terms of $\\Delta t$ and $L$. Use the linear test equation $f(y) = -L y$, with $L > 0$, so that the exact implicit Euler update solves\n$$\n(1 + \\Delta t\\, L)\\, y_{n+1} = y_n.\n$$\nWith an inexact solve obeying $|r_n| \\le \\zeta\\, |y_n|$, where $r_n$ is chosen to be aligned with $y_n$ to maximize growth, show that the effective amplification factor is modified and derive the threshold on $\\zeta$ such that the computed iterates $y_n$ diverge. Conclude the precise inequality relating $\\zeta$, $\\Delta t$, and $L$ that separates contraction, neutral behavior, and divergence.\n\nThen implement a program that, for a specified test suite, computes for each case:\n- the threshold $\\zeta_{\\text{th}} = \\Delta t\\, L$,\n- the effective amplification factor $g_{\\text{eff}}$, and\n- whether the numerical sequence diverges under the worst-case residual alignment.\n\nUse the following test suite, which is designed to cover a stable case, a neutral boundary case, divergent cases, and sensitivity at small step sizes. All quantities are unitless. For each case, the program should evolve $N$ steps starting from $y_0$ using the worst-case inexact implicit Euler recurrence derived in the solution section and report the resulting $y_N$:\n1. $(L, \\Delta t, \\zeta, N, y_0) = (10.0, 0.01, 0.05, 50, 1.0)$,\n2. $(L, \\Delta t, \\zeta, N, y_0) = (10.0, 0.01, 0.10, 50, 1.0)$,\n3. $(L, \\Delta t, \\zeta, N, y_0) = (10.0, 0.01, 0.20, 50, 1.0)$,\n4. $(L, \\Delta t, \\zeta, N, y_0) = (1.0, 1.0, 1.01, 50, 1.0)$,\n5. $(L, \\Delta t, \\zeta, N, y_0) = (100.0, 10^{-4}, 0.011, 50, 1.0)$.\n\nFor each test case, the output must be a list of the form $[\\zeta_{\\text{th}}, g_{\\text{eff}}, d, y_N]$ where $d$ is an integer indicator ($1$ if the sequence diverges under worst-case residual alignment, $0$ otherwise). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s list in the same order as above and floats rounded to six decimal places, for example, $[[\\cdots],[\\cdots],\\ldots]$.", "solution": "The problem requires an analysis of the stability of the backward (implicit) Euler method when the resulting nonlinear algebraic equation is solved inexactly at each time step. We are tasked with deriving a condition that demonstrates a loss of unconditional stability for an A-stable method due to this inexactness and quantifying the threshold for the solution tolerance.\n\nLet's begin by formalizing the problem setup. We are given a scalar ordinary differential equation (ODE) $y'(t) = f(y(t))$ with an initial condition $y(0) = y_0$. The function $f$ is Lipschitz continuous with constant $L > 0$. The backward Euler method discretizes this ODE as:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = f(y_{n+1})\n$$\nwhere $y_n$ is the numerical approximation to $y(n\\Delta t)$ and $\\Delta t$ is the time step size. This can be rewritten as the equation to be solved for $y_{n+1}$:\n$$\ny_{n+1} - y_n - \\Delta t f(y_{n+1}) = 0\n$$\nThe problem states that this equation is solved inexactly. Let the computed solution be denoted $y_{n+1}^{\\text{(approx)}}$. For simplicity, as is common in such analyses, we will drop the superscript and let $y_{n+1}$ represent this computed, inexact value. The inexactness is characterized by a non-zero residual, $r_n$:\n$$\nr_n := y_{n+1} - y_n - \\Delta t f(y_{n+1})\n$$\nThis residual is bounded by a relative tolerance condition:\n$$\n|r_n| \\le \\zeta |y_n|\n$$\nwhere $\\zeta \\ge 0$ is a dimensionless tolerance parameter.\n\nTo analyze stability, we use the standard linear test equation $f(y) = \\lambda y$. For the problem at hand, we are given $f(y) = -L y$, where $L > 0$ is the Lipschitz constant. This corresponds to $\\lambda = -L$, a real and negative value, for which the backward Euler method is known to be A-stable (and L-stable), meaning the exact numerical solution should decay for any choice of $\\Delta t > 0$.\n\nSubstituting $f(y_{n+1}) = -L y_{n+1}$ into the residual definition gives:\n$$\nr_n = y_{n+1} - y_n - \\Delta t (-L y_{n+1})\n$$\n$$\nr_n = y_{n+1} (1 + \\Delta t L) - y_n\n$$\nWe can rearrange this equation to express the next iterate, $y_{n+1}$, in terms of the current iterate, $y_n$, and the residual, $r_n$:\n$$\ny_{n+1} (1 + \\Delta t L) = y_n + r_n\n$$\n$$\ny_{n+1} = \\frac{y_n + r_n}{1 + \\Delta t L}\n$$\nThis equation shows how the solution evolves from one step to the next under the influence of the numerical scheme and the inexact solve residual.\n\nThe problem asks us to consider the \"worst-case alignment\" of the residual that maximizes the growth of the computed solution. The magnitude of the next iterate is $|y_{n+1}| = \\frac{|y_n + r_n|}{|1 + \\Delta t L|}$. Since $L > 0$ and $\\Delta t > 0$, the denominator $1 + \\Delta t L$ is always positive. To maximize $|y_{n+1}|$, we must maximize the numerator $|y_n + r_n|$. The residual $r_n$ is constrained by $|r_n| \\le \\zeta |y_n|$. The value of $|y_n + r_n|$ is maximized when $r_n$ is real and has the same sign as $y_n$. Therefore, the worst-case choice for the residual is $r_n = \\zeta y_n$ (if $y_n > 0$, $r_n = \\zeta y_n$; if $y_n  0$, $r_n = \\zeta y_n = -\\zeta|y_n|$). This choice saturates the tolerance bound and aligns the residual to cause maximum amplification.\n\nSubstituting this worst-case residual $r_n = \\zeta y_n$ into the recurrence relation for $y_{n+1}$:\n$$\ny_{n+1} = \\frac{y_n + \\zeta y_n}{1 + \\Delta t L} = \\frac{(1 + \\zeta) y_n}{1 + \\Delta t L}\n$$\nThis gives us a linear recurrence relation of the form $y_{n+1} = g_{\\text{eff}} y_n$, where $g_{\\text{eff}}$ is the effective amplification factor:\n$$\ng_{\\text{eff}} = \\frac{1 + \\zeta}{1 + \\Delta t L}\n$$\nThe numerical solution sequence $y_n$ is stable (contracts) if $|g_{\\text{eff}}|  1$, is neutral if $|g_{\\text{eff}}| = 1$, and is unstable (diverges) if $|g_{\\text{eff}}| > 1$.\n\nSince $\\zeta \\ge 0$, $L > 0$, and $\\Delta t > 0$, the numerator $1 + \\zeta$ and the denominator $1 + \\Delta t L$ are both greater than or equal to $1$. Thus, $g_{\\text{eff}}$ is always positive, and we can drop the absolute value sign in the stability analysis.\n\nThe condition for divergence is $g_{\\text{eff}} > 1$:\n$$\n\\frac{1 + \\zeta}{1 + \\Delta t L} > 1\n$$\nMultiplying by the positive denominator $1 + \\Delta t L$:\n$$\n1 + \\zeta > 1 + \\Delta t L\n$$\n$$\n\\zeta > \\Delta t L\n$$\nThis inequality provides a counterexample to the unconditional stability of the backward Euler method. Even though the method is A-stable when solved exactly, an inexact solve can induce instability if the relative residual tolerance $\\zeta$ is larger than the product of the time step size $\\Delta t$ and the system's characteristic frequency (represented by $L$).\n\nThe threshold tolerance, $\\zeta_{\\text{th}}$, that separates contraction from divergence is the point where the amplification factor is exactly $1$:\n$$\n\\zeta_{\\text{th}} = \\Delta t L\n$$\nWe can summarize the behavior based on the relationship between $\\zeta$ and this threshold:\n- If $\\zeta  \\Delta t L$, then $g_{\\text{eff}}  1$ and the solution contracts (stable).\n- If $\\zeta = \\Delta t L$, then $g_{\\text{eff}} = 1$ and the solution is neutral (constant magnitude).\n- If $\\zeta > \\Delta t L$, then $g_{\\text{eff}} > 1$ and the solution diverges (unstable).\n\nThe program will implement these findings. For each test case $(L, \\Delta t, \\zeta, N, y_0)$, we calculate:\n1. The threshold tolerance: $\\zeta_{\\text{th}} = \\Delta t L$.\n2. The effective amplification factor: $g_{\\text{eff}} = (1 + \\zeta) / (1 + \\Delta t L)$.\n3. The divergence indicator $d$: $d=1$ if $\\zeta > \\zeta_{\\text{th}}$, and $d=0$ otherwise.\n4. The final value after $N$ steps: $y_N = y_0 \\cdot (g_{\\text{eff}})^N$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the stability properties and final solution value for an inexact\n    implicit Euler method applied to the linear test equation y' = -Ly.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, Delta_t, zeta, N, y0)\n        (10.0, 0.01, 0.05, 50, 1.0),\n        (10.0, 0.01, 0.10, 50, 1.0),\n        (10.0, 0.01, 0.20, 50, 1.0),\n        (1.0, 1.0, 1.01, 50, 1.0),\n        (100.0, 1e-4, 0.011, 50, 1.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L, delta_t, zeta, N, y0 = case\n\n        # 1. Calculate the stability threshold zeta_th\n        zeta_th = delta_t * L\n\n        # 2. Calculate the effective amplification factor g_eff\n        g_eff = (1.0 + zeta) / (1.0 + delta_t * L)\n\n        # 3. Determine the divergence indicator d\n        # Divergence occurs for zeta  delta_t * L, which is equivalent to g_eff  1.\n        # The problem defines divergence for a strict inequality.\n        d = 1 if zeta > zeta_th else 0\n\n        # 4. Calculate y_N using the derived recurrence y_{n+1} = g_eff * y_n\n        # This is a geometric progression: y_N = y0 * (g_eff)^N\n        y_N = y0 * (g_eff ** N)\n        \n        # Store results for this case\n        case_results = [zeta_th, g_eff, d, y_N]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # Each float must be rounded to six decimal places.\n    formatted_results = []\n    for res in all_results:\n        zeta_th_str = f\"{res[0]:.6f}\"\n        g_eff_str = f\"{res[1]:.6f}\"\n        d_str = str(res[2])\n        y_N_str = f\"{res[3]:.6f}\"\n        formatted_results.append(f\"[{zeta_th_str},{g_eff_str},{d_str},{y_N_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3316997"}, {"introduction": "Real-world fluid dynamics problems often involve multiple physical processes with disparate time scales, such as fast advection and slow diffusion, making purely explicit or purely implicit methods inefficient. This exercise guides you through the construction of a modern, hybrid Implicit-Explicit (IMEX) Additive Runge-Kutta (ARK) scheme, a powerful strategy for such multiscale problems. You will implement an adaptive time-step controller based on an embedded error estimate, while also enforcing an explicit CFL constraint, synthesizing key concepts to build a robust and efficient solver [@problem_id:3316899].", "problem": "Consider a one-dimensional variable-density advection-diffusion model posed on a periodic domain, where a scalar velocity-like field $u(x,t)$ is transported by a spatially varying advective velocity and is smoothed by diffusion. Let the spatial domain be $x \\in [0,L]$ with periodic boundary conditions, and let time be $t \\in [0,T]$ with units of seconds.\n\nThe governing equation is\n$$\n\\frac{\\partial u}{\\partial t} + v(x)\\,\\frac{\\partial u}{\\partial x} = \\nu\\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\nwhere $\\nu$ is the kinematic viscosity in $\\mathrm{m}^2/\\mathrm{s}$, and the advective velocity $v(x)$ arises from a constant mass flux assumption $J = \\rho(x)\\,v(x) = U_0$, with $U_0$ a constant mass flux in $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$ and $\\rho(x)$ a prescribed spatial density field in $\\mathrm{kg}/\\mathrm{m}^3$. We define\n$$\n\\rho(x) = \\rho_0\\,\\big(1 + \\alpha \\sin\\left(\\frac{2\\pi x}{L}\\right)\\big),\\quad v(x) = \\frac{U_0}{\\rho(x)}.\n$$\nThe initial condition is\n$$\nu(x,0) = \\sin\\left(\\frac{2\\pi x}{L}\\right).\n$$\n\nDiscretize space with $N$ uniformly spaced points, spacing $\\Delta x = L/N$, and periodic boundary conditions. For the explicit convective term, use a first-order upwind discrete derivative at grid point $x_i$:\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_i \\approx\n\\begin{cases}\n\\frac{u_i - u_{i-1}}{\\Delta x},  v_i \\ge 0, \\\\\n\\frac{u_{i+1} - u_i}{\\Delta x},  v_i  0,\n\\end{cases}\n$$\nwhere $v_i = v(x_i)$, and indices are periodic. For the diffusive operator, use the second-order centered finite difference Laplacian:\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_i \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\nwith periodic indices.\n\nSplit the right-hand side into a nonstiff explicit part $F(u) = - v(x)\\,u_x$ and a stiff linear implicit part $G(u) = \\nu\\,u_{xx}$. Advance in time with an Additive Runge-Kutta (ARK) scheme, also known as an Implicit-Explicit (IMEX) Runge-Kutta method, using the standard Ascher–Ruuth–Spiteri two-stage, second-order scheme (ARS(2,2,2)), which is defined by the following Butcher coefficients. Let $\\gamma = 1 - 1/\\sqrt{2}$. The explicit tableau is\n$$\n\\mathbf{A}^{\\mathrm{E}} = \\begin{bmatrix}\n0  0 \\\\\n\\gamma  0\n\\end{bmatrix},\\quad\n\\mathbf{b}^{\\mathrm{E}} = \\begin{bmatrix}\n1-\\gamma \\\\ \\gamma\n\\end{bmatrix},\\quad\n\\mathbf{c}^{\\mathrm{E}} = \\begin{bmatrix}\n0 \\\\ \\gamma\n\\end{bmatrix},\n$$\nand the diagonally implicit tableau is\n$$\n\\mathbf{A}^{\\mathrm{I}} = \\begin{bmatrix}\n\\gamma  0 \\\\\n1 - 2\\gamma  \\gamma\n\\end{bmatrix},\\quad\n\\mathbf{b}^{\\mathrm{I}} = \\begin{bmatrix}\n1-\\gamma \\\\ \\gamma\n\\end{bmatrix},\\quad\n\\mathbf{c}^{\\mathrm{I}} = \\begin{bmatrix}\n\\gamma \\\\ 1\n\\end{bmatrix}.\n$$\nUse the embedded lower-order pair for error estimation with weights\n$$\n\\tilde{\\mathbf{b}}^{\\mathrm{E}} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix},\\quad\n\\tilde{\\mathbf{b}}^{\\mathrm{I}} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix},\n$$\nso that the embedded solution is first order in time.\n\nAt each time step, compute the two stage solutions $\\{y_1,y_2\\}$ by\n$$\n\\left(\\mathbf{I} - \\Delta t\\,a^{\\mathrm{I}}_{11}\\,\\mathbf{L}\\right)\\,y_1 = u^n + \\Delta t \\left(\\sum_{j1} a^{\\mathrm{E}}_{1j}\\,F(y_j) + \\sum_{j1} a^{\\mathrm{I}}_{1j}\\,\\mathbf{L} y_j\\right),\n$$\n$$\n\\left(\\mathbf{I} - \\Delta t\\,a^{\\mathrm{I}}_{22}\\,\\mathbf{L}\\right)\\,y_2 = u^n + \\Delta t \\left(\\sum_{j2} a^{\\mathrm{E}}_{2j}\\,F(y_j) + \\sum_{j2} a^{\\mathrm{I}}_{2j}\\,\\mathbf{L} y_j\\right),\n$$\nwhere $\\mathbf{L}$ is the discrete Laplacian scaled by $\\nu$. Then form the high-order update\n$$\nu^{n+1} = u^n + \\Delta t \\left(\\sum_{i=1}^2 b^{\\mathrm{E}}_i\\,F(y_i) + \\sum_{i=1}^2 b^{\\mathrm{I}}_i\\,\\mathbf{L}y_i\\right),\n$$\nand the embedded low-order update\n$$\n\\tilde{u}^{n+1} = u^n + \\Delta t \\left(\\sum_{i=1}^2 \\tilde{b}^{\\mathrm{E}}_i\\,F(y_i) + \\sum_{i=1}^2 \\tilde{b}^{\\mathrm{I}}_i\\,\\mathbf{L}y_i\\right).\n$$\n\nDesign an adaptive time-step controller that uses the embedded pair to estimate the local error and adjust $\\Delta t$ to meet a user-specified tolerance. Let the local error estimate be\n$$\ne_n = \\left(\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(u^{n+1}_i - \\tilde{u}^{n+1}_i\\right)^2\\right)^{1/2}.\n$$\nGiven a tolerance $\\mathrm{tol}$, accept the step if $e_n \\le \\mathrm{tol}$; otherwise, reject it and reduce $\\Delta t$. Update the accepted step size by\n$$\n\\Delta t_{\\mathrm{new}} = \\Delta t \\cdot s \\cdot \\left(\\frac{\\mathrm{tol}}{e_n}\\right)^{1/p},\n$$\nwhere $p=2$ is the order of accuracy of the high-order ARK solution and $s$ is a safety factor in $(0,1)$ chosen by you to achieve robust behavior; limit $\\Delta t_{\\mathrm{new}}$ by reasonable minimum and maximum growth factors to prevent excessively large changes between steps.\n\nTo prevent divergence of explicit stages, impose a Courant–Friedrichs–Lewy (CFL) constraint based on the largest local wave speed. Define\n$$\ns_{\\max} = \\max_i \\left|v_i\\right|,\n$$\nand enforce at every step\n$$\n\\Delta t \\le C_{\\mathrm{CFL}}\\,\\frac{\\Delta x}{s_{\\max}},\n$$\nwith a user-specified constant $C_{\\mathrm{CFL}}$ in $\\mathbb{R}^+$. Always clip any proposed $\\Delta t$ to this upper bound before evaluating stages. Initialize $\\Delta t$ using this bound and ensure the last step respects both the tolerance and the CFL constraint.\n\nImplement the above with the following test suite of parameters. For each case, compute the total number of accepted steps taken to reach $T$ (an integer) and output that count. The spatial length is $L$ in $\\mathrm{m}$, the final time is $T$ in $\\mathrm{s}$, the base density is $\\rho_0$ in $\\mathrm{kg}/\\mathrm{m}^3$, the density variation amplitude is $\\alpha$ (dimensionless and satisfying $|\\alpha|  1$), the constant mass flux is $U_0$ in $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$, the viscosity is $\\nu$ in $\\mathrm{m}^2/\\mathrm{s}$, and the tolerance is a dimensionless number for the root-mean-square local error measure.\n\nTest suite:\n- Case $1$: $L=1$, $N=64$, $T=0.2$, $\\rho_0=1$, $\\alpha=0.5$, $U_0=1$, $\\nu=0.01$, $\\mathrm{tol}=10^{-3}$, $C_{\\mathrm{CFL}}=0.5$.\n- Case $2$: $L=1$, $N=64$, $T=0.2$, $\\rho_0=1$, $\\alpha=0.5$, $U_0=1$, $\\nu=0.01$, $\\mathrm{tol}=10^{-5}$, $C_{\\mathrm{CFL}}=0.5$.\n- Case $3$: $L=1$, $N=64$, $T=0.2$, $\\rho_0=1$, $\\alpha=0.2$, $U_0=1$, $\\nu=0.01$, $\\mathrm{tol}=10^{-3}$, $C_{\\mathrm{CFL}}=2$.\n- Case $4$: $L=1$, $N=64$, $T=0.2$, $\\rho_0=1$, $\\alpha=0.9$, $U_0=5$, $\\nu=0.01$, $\\mathrm{tol}=10^{-3}$, $C_{\\mathrm{CFL}}=0.3$.\n\nYour program should produce a single line of output containing the four integers (numbers of accepted steps for the four cases) as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3,n_4]$. No other output should be produced. Angles are not part of this problem. All physical quantities appearing in any intermediate computations should be handled consistently with the stated units, but the final outputs are unitless integers.", "solution": "The solution proceeds as follows:\n1.  **Problem Decomposition**: The governing partial differential equation (PDE) is a one-dimensional, variable-coefficient advection-diffusion equation. The solution strategy involves discretizing this PDE in space and time.\n    -   **Spatial Discretization**: A uniform grid with $N$ points and spacing $\\Delta x = L/N$ is used.\n        -   The advection term, $v(x) \\frac{\\partial u}{\\partial x}$, is discretized using a first-order upwind finite difference scheme. This choice is crucial for the stability of the explicit part of the time integrator, as it introduces numerical diffusion that dampens oscillations. The direction of the difference (forward or backward) at each grid point $x_i$ depends on the sign of the local advective velocity $v_i = v(x_i)$.\n        -   The diffusion term, $\\nu \\frac{\\partial^2 u}{\\partial x^2}$, is discretized using a standard second-order centered finite difference scheme. This results in a linear operator that is stiff, especially for small $\\Delta x$, motivating its implicit treatment.\n    -   **Temporal Discretization (IMEX ARK)**: The spatially discretized system of ordinary differential equations (ODEs), $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u}) + \\mathbf{G}(\\mathbf{u})$, is integrated in time using an Implicit-Explicit (IMEX) Additive Runge-Kutta (ARK) method.\n        -   The non-stiff advection term is designated as the explicit part, $\\mathbf{F}(\\mathbf{u})$.\n        -   The stiff linear diffusion term is designated as the implicit part, $\\mathbf{G}(\\mathbf{u}) = \\mathbf{L}\\mathbf{u}$, where $\\mathbf{L}$ is the discrete scaled Laplacian matrix.\n        -   The specific scheme is the Ascher–Ruuth–Spiteri ARS(2,2,2), a two-stage, second-order accurate Diagonally Implicit Runge-Kutta (DIRK) scheme. Its structure is defined by the provided Butcher tableaux.\n\n2.  **Implementation of the IMEX ARK Scheme**:\n    -   **Stages**: The scheme involves computing two intermediate stages, $y_1$ and $y_2$. Each stage requires solving a linear system of the form $(\\mathbf{I} - c \\mathbf{L}) \\mathbf{y} = \\mathbf{z}$, where $\\mathbf{I}$ is the identity matrix and $c$ is a constant derived from the time step $\\Delta t$ and the implicit Butcher coefficients.\n    -   **Linear System Solver**: The matrix $\\mathbf{L}$ is a circulant matrix due to the periodic boundary conditions and uniform grid. Such matrices are efficiently diagonalized by the Fast Fourier Transform (FFT). The linear system is transformed into Fourier space, where it becomes a simple element-wise division, and the solution is then transformed back to physical space using an inverse FFT. The eigenvalues $\\hat{L}_k$ of the discrete Laplacian are pre-computed:\n        $$\n        \\hat{L}_k = \\frac{2\\nu}{\\Delta x^2} \\left( \\cos\\left(\\frac{2\\pi k}{N}\\right) - 1 \\right), \\quad k = 0, 1, \\dots, N-1.\n        $$\n        The solution to $(\\mathbf{I} - c \\mathbf{L}) \\mathbf{y} = \\mathbf{z}$ is thus found by $\\mathbf{y} = \\mathcal{F}^{-1}\\left( \\frac{\\mathcal{F}(\\mathbf{z})}{1 - c \\hat{\\mathbf{L}}} \\right)$, where $\\mathcal{F}$ is the FFT operator and arithmetic on the transformed vectors is element-wise.\n    -   **Re-using Implicit Terms**: A key optimization involves recognizing that the implicit term $\\mathbf{L} y_i$ can be computed algebraically from the stage equation itself, e.g., $\\mathbf{L}y_1 = (y_1 - u^n) / (\\Delta t a^\\mathrm{I}_{11})$, avoiding a direct (and potentially less accurate) application of the discrete Laplacian operator. This is used for all implicit term evaluations.\n\n3.  **Adaptive Time-Stepping**:\n    -   **Error Estimation**: The ARS(2,2,2) scheme is supplied with an embedded first-order method. The difference between the second-order solution $u^{n+1}$ and the first-order embedded solution $\\tilde{u}^{n+1}$ provides an estimate of the local truncation error, $e_n$. The root-mean-square norm of this error vector is used.\n    -   **Step Size Controller**: A standard Proportional-Integral (PI) like controller is implemented to adjust the time step $\\Delta t$.\n        -   If the error $e_n$ is less than or equal to the tolerance $\\mathrm{tol}$, the step is accepted. A new, potentially larger, step size for the next iteration is proposed using the formula $\\Delta t_{\\text{new}} = \\Delta t \\cdot s \\cdot (\\mathrm{tol}/e_n)^{1/p}$, where $s=0.9$ is a safety factor and $p=2$ is the order of the method.\n        -   If $e_n > \\mathrm{tol}$, the step is rejected, and the same formula is used to compute a smaller $\\Delta t$ for a retry of the current step.\n        -   To ensure robustness, the change in step size is limited by a minimum reduction factor (e.g., $0.2$) and a maximum growth factor (e.g., $1.5$).\n    -   **CFL Constraint**: At every step, the proposed $\\Delta t$ is strictly capped by the advective Courant–Friedrichs–Lewy (CFL) limit, $\\Delta t \\le C_{\\mathrm{CFL}} \\Delta x / \\max_i|v_i|$, to maintain the stability of the explicit advection part. The initial time step is also set to this value.\n\n4.  **Execution and Output**: The implementation is encapsulated in a Python function. This function is called for each parameter set provided in the test suite. The total number of accepted steps required to reach the final time $T$ is recorded for each case. The final output is a comma-separated list of these integer counts, enclosed in square brackets. The logic is numerically robust, handling potential floating-point issues such as division by zero in the error controller.", "answer": "```python\nimport numpy as np\nimport sys\n\ndef run_simulation(L, N, T, rho0, alpha, U0, nu, tol, C_CFL):\n    \"\"\"\n    Solves the 1D advection-diffusion equation using an adaptive IMEX-ARK scheme.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of spatial points.\n        T (float): Final time.\n        rho0 (float): Base density.\n        alpha (float): Density variation amplitude.\n        U0 (float): Constant mass flux.\n        nu (float): Kinematic viscosity.\n        tol (float): Local error tolerance.\n        C_CFL (float): CFL number.\n\n    Returns:\n        int: The total number of accepted time steps.\n    \"\"\"\n    # 1. Setup grid and parameters\n    DX = L / N\n    X = np.linspace(0, L, N, endpoint=False)\n\n    # Adaptive controller parameters\n    SAFETY_FACTOR = 0.9\n    MIN_FACTOR = 0.2\n    MAX_FACTOR = 1.5\n    P_ORDER = 2.0  # Order of the higher-order method\n\n    # 2. Physics setup\n    rho = rho0 * (1.0 + alpha * np.sin(2.0 * np.pi * X / L))\n    if np.any(rho = 0):\n        # This should not happen with |alpha|  1 as given.\n        raise ValueError(\"Density must be positive.\")\n    v = U0 / rho\n    s_max = np.max(np.abs(v))\n    DT_CFL = C_CFL * DX / s_max if s_max > 0 else sys.float_info.max\n\n    # 3. ARK scheme constants\n    GAMMA = 1.0 - 1.0 / np.sqrt(2.0)\n\n    # 4. Operator definitions\n    \n    # Implicit operator L (Laplacian) in Fourier space\n    j = np.arange(N)\n    L_hat = nu * (2.0 / DX**2) * (np.cos(2.0 * np.pi * j / N) - 1.0)\n    \n    # Explicit operator F(u) = -v * du/dx (upwind)\n    def F_op(u_vec, v_vec, dx):\n        dudx = np.zeros_like(u_vec)\n        u_p1 = np.roll(u_vec, -1)\n        u_m1 = np.roll(u_vec, 1)\n        \n        mask_pos = v_vec >= 0\n        dudx[mask_pos] = (u_vec[mask_pos] - u_m1[mask_pos]) / dx\n        \n        mask_neg = v_vec  0\n        dudx[mask_neg] = (u_p1[mask_neg] - u_vec[mask_neg]) / dx\n        \n        return -v_vec * dudx\n\n    # 5. ARK step function\n    def perform_ark_step(u_n, dt):\n        \"\"\"Performs one step of the ARS(2,2,2) scheme.\"\"\"\n        D_inv = 1.0 - dt * GAMMA * L_hat\n        D_inv[D_inv == 0] = 1e-16 # Avoid division by zero\n        \n        # Stage 1\n        R1 = u_n\n        y1 = np.fft.ifft(np.fft.fft(R1) / D_inv).real\n        \n        F1 = F_op(y1, v, DX)\n        G1 = (y1 - u_n) / (dt * GAMMA)\n        \n        # Stage 2\n        R2 = u_n + dt * (GAMMA * F1 + (1.0 - 2.0 * GAMMA) * G1)\n        y2 = np.fft.ifft(np.fft.fft(R2) / D_inv).real\n        \n        F2 = F_op(y2, v, DX)\n        G2 = (y2 - R2) / (dt * GAMMA)\n        \n        # Final updates\n        u_next = u_n + dt * ((1.0-GAMMA)*F1 + GAMMA*F2 + (1.0-GAMMA)*G1 + GAMMA*G2)\n        u_tilde_next = u_n + dt * (F1 + G1)\n        \n        return u_next, u_tilde_next\n\n    # 6. Main time-stepping loop\n    t = 0.0\n    u = np.sin(2.0 * np.pi * X / L) # Initial condition\n    dt_proposal = DT_CFL\n    accepted_steps = 0\n    \n    while t  T:\n        dt_current = min(dt_proposal, T - t)\n        dt_current = min(dt_current, DT_CFL)\n\n        # Retry loop for adaptive stepping\n        while True:\n            if dt_current  1e-14:\n                raise RuntimeError(\"Time step became excessively small.\")\n\n            u_next, u_tilde_next = perform_ark_step(u, dt_current)\n\n            # Error estimation (RMS norm)\n            error_sq = np.mean((u_next - u_tilde_next)**2)\n            error = np.sqrt(error_sq) if error_sq > 0 else 1e-16\n\n            if error = tol:\n                t += dt_current\n                u = u_next\n                accepted_steps += 1\n\n                if error  1e-12:\n                    ratio = MAX_FACTOR\n                else: \n                    ratio = SAFETY_FACTOR * (tol / error)**(1.0 / P_ORDER)\n                \n                dt_proposal = dt_current * min(MAX_FACTOR, ratio)\n                break\n            else:\n                ratio = SAFETY_FACTOR * (tol / error)**(1.0 / P_ORDER)\n                dt_current = dt_current * max(MIN_FACTOR, ratio)\n\n    return accepted_steps\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'L': 1.0, 'N': 64, 'T': 0.2, 'rho0': 1.0, 'alpha': 0.5, 'U0': 1.0, 'nu': 0.01, 'tol': 1e-3, 'C_CFL': 0.5},\n        {'L': 1.0, 'N': 64, 'T': 0.2, 'rho0': 1.0, 'alpha': 0.5, 'U0': 1.0, 'nu': 0.01, 'tol': 1e-5, 'C_CFL': 0.5},\n        {'L': 1.0, 'N': 64, 'T': 0.2, 'rho0': 1.0, 'alpha': 0.2, 'U0': 1.0, 'nu': 0.01, 'tol': 1e-3, 'C_CFL': 2.0},\n        {'L': 1.0, 'N': 64, 'T': 0.2, 'rho0': 1.0, 'alpha': 0.9, 'U0': 5.0, 'nu': 0.01, 'tol': 1e-3, 'C_CFL': 0.3},\n    ]\n\n    results = []\n    for case in test_cases:\n        num_steps = run_simulation(**case)\n        results.append(num_steps)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3316899"}]}