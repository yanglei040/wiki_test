{"hands_on_practices": [{"introduction": "A critical step in developing any numerical solver is verification: ensuring the code behaves as expected and converges to the correct solution as the grid resolution increases. For solutions with shocks and contact discontinuities, standard error norms like the $L_1$ norm of the pointwise error are misleading. This practice guides you through the fundamental process of a grid refinement study, focusing on error metrics specifically designed for discontinuous features [@problem_id:3521202]. By implementing simple first-order solvers for both a shock and a contact, you will learn to measure convergence by tracking shock position error and contact smearing, foundational skills for validating any shock-capturing code.", "problem": "You are to implement and analyze one-dimensional conservation-law models that contain a propagating shock and a propagating contact discontinuity. The goal is to define interface-aware error norms that are appropriate for discontinuities and to design a grid refinement study that measures convergence of the shock position and the contact width against exact solutions. All mathematical entities must be written in LaTeX, and all physical outputs must be expressed in meters where applicable.\n\nThe fundamental base is the theory of hyperbolic conservation laws, Rankine–Hugoniot jump conditions, and the Courant–Friedrichs–Lewy (CFL) stability condition. Use the following two models:\n\n1. Shock model: the inviscid Burgers conservation law,\n$$\nu_t + \\left(\\frac{1}{2} u^2\\right)_x = 0,\n$$\nwith Riemann initial data at position $x_0$,\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x  x_0,\n\\end{cases}\n$$\nand $u_L  u_R$. The exact shock speed from Rankine–Hugoniot jump conditions is\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}, \\quad \\text{with} \\quad f(u) = \\frac{1}{2}u^2,\n$$\nwhich simplifies to\n$$\ns = \\frac{u_L + u_R}{2}.\n$$\nThe exact shock position is then\n$$\nx_s(t) = x_0 + s t.\n$$\n\n2. Contact discontinuity model: linear advection of a passive scalar density,\n$$\n\\rho_t + a \\,\\rho_x = 0,\n$$\nwith Riemann initial data at position $x_0$,\n$$\n\\rho(x,0) = \\begin{cases}\n\\rho_L,  x  x_0,\\\\\n\\rho_R,  x  x_0,\n\\end{cases}\n$$\nwhere $a$ is a constant advection speed. The exact contact propagates without diffusion at speed $a$ and the exact contact width remains zero for all times. The exact contact position is\n$$\nx_c(t) = x_0 + a t \\quad \\text{modulo the domain length for periodic boundaries}.\n$$\n\nDefine error norms appropriate for discontinuities. For a discontinuity represented by an interface (shock or contact), we define indicator functions, thresholds, and geometric error metrics as follows:\n\n- Shock indicator function: let $H(x; x_*)$ be the Heaviside function centered at $x_*$,\n$$\nH(x; x_*) = \\begin{cases}\n1,  x  x_*,\\\\\n0,  x  x_*.\n\\end{cases}\n$$\nFor the Burgers shock with $u_L  u_R$, the exact indicator is $\\chi_{\\mathrm{exact}}(x,t) = H(x; x_s(t))$, while the numerical indicator is $\\chi_{\\mathrm{num}}(x,t) = \\mathbf{1}_{\\{u(x,t)  u_m\\}}$ where the mid-value threshold is $u_m = \\frac{u_L + u_R}{2}$. The indicator-function error field is $e_\\chi(x,t) = \\chi_{\\mathrm{num}}(x,t) - \\chi_{\\mathrm{exact}}(x,t)$. The $L_1$, $L_2$, and $L_\\infty$ norms of $e_\\chi$ over the spatial domain $[0,L]$ are\n$$\n\\|e_\\chi\\|_{1} = \\int_0^L |e_\\chi(x,t)| \\, dx, \\quad\n\\|e_\\chi\\|_{2} = \\left(\\int_0^L |e_\\chi(x,t)|^2 \\, dx\\right)^{1/2}, \\quad\n\\|e_\\chi\\|_{\\infty} = \\sup_{x \\in [0,L]} |e_\\chi(x,t)|.\n$$\nFor perfectly sharp steps, $\\|e_\\chi\\|_{1}$ equals the shock misalignment $|x_s^{\\mathrm{num}}(t) - x_s(t)|$ and $\\|e_\\chi\\|_{2} = \\sqrt{|x_s^{\\mathrm{num}}(t) - x_s(t)|}$, while $\\|e_\\chi\\|_{\\infty}$ is either $0$ or $1$. In practice, with numerical smearing, $\\|e_\\chi\\|_{1}$ includes both misalignment and smear contributions. To isolate the geometric shock position error, define the scalar position error\n$$\ne_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t),\n$$\nand use its scalar norms,\n$$\n\\|e_s\\|_{1} = |e_s|, \\quad \\|e_s\\|_{2} = \\sqrt{e_s^2}, \\quad \\|e_s\\|_{\\infty} = |e_s|.\n$$\n\n- Contact width indicator: normalize the density by the jump magnitude,\n$$\n\\eta(x,t) = \\frac{\\rho(x,t) - \\rho_R}{\\rho_L - \\rho_R}.\n$$\nDefine threshold crossings at levels $\\eta_{10} = 0.1$ and $\\eta_{90} = 0.9$. Let $x_{10}(t)$ and $x_{90}(t)$ be the positions at time $t$ where $\\eta$ crosses $0.1$ and $0.9$ respectively, using linear interpolation between grid points. The numerical contact width is\n$$\n\\hat{w}(t) = x_{90}(t) - x_{10}(t).\n$$\nThe exact width is $w(t) = 0$, so the scalar width error is\n$$\ne_w(t) = \\hat{w}(t) - w(t) = \\hat{w}(t).\n$$\nDefine scalar norms for $e_w$ as\n$$\n\\|e_w\\|_{1} = \\hat{w}, \\quad \\|e_w\\|_{2} = \\sqrt{\\hat{w}^2}, \\quad \\|e_w\\|_{\\infty} = \\hat{w}.\n$$\n\nNumerical schemes to be used:\n\n- For the Burgers shock, use a first-order conservative finite-volume method with the Lax–Friedrichs numerical flux, implemented on a uniform grid. The Lax–Friedrichs flux at an interface $i+\\frac{1}{2}$ is\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),\n$$\nwith $f(u) = \\frac{1}{2}u^2$ and $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|,|u_{i+1}|\\}$. Update\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\nand enforce outflow (transmissive) boundary conditions via constant extrapolation to ghost cells. Choose the time step by the Courant–Friedrichs–Lewy (CFL) condition,\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},\n$$\nwith $\\mathrm{CFL} = 0.45$.\n\n- For the contact, use a first-order upwind finite-difference scheme appropriate to the sign of $a$ on a uniform periodic grid. If $a \\ge 0$,\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\nwith periodic wrap for $i-1$. If $a  0$,\n$$\n\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_{i+1}^n - \\rho_i^n\\right), \\quad \\nu = \\frac{a \\Delta t}{\\Delta x},\n$$\nwith periodic wrap for $i+1$. Choose $\\Delta t$ by the Courant–Friedrichs–Lewy (CFL) condition\n$$\n\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|},\n$$\nwith $\\mathrm{CFL} = 0.9$.\n\nGeometric detection procedures:\n\n- Shock position detection: at final time $t$, define the mid-state $u_m = \\frac{u_L + u_R}{2}$ and locate the unique crossing in $u(x,t)$ of the level $u_m$ by linear interpolation between the two adjacent grid points that straddle $u_m$. If no crossing is found due to numerical anomalies, fall back to locating the interface as the midpoint of the cell face with maximal gradient magnitude $|u_{i+1} - u_i|$.\n\n- Contact width detection: at final time $t$, compute the normalized field $\\eta$. Locate the positions $x_{10}$ and $x_{90}$ at which $\\eta$ crosses the levels $0.1$ and $0.9$ by linear interpolation. Use the pair of crossings closest (in index space) to the maximum gradient location to avoid spurious crossings due to periodicity. The width is then $\\hat{w} = x_{90} - x_{10}$.\n\nGrid refinement study and required outputs:\n\n- Domain length is $L = 1$ meter. Initial discontinuity positions are $x_0 = 0.5$ meters for the shock and $x_0 = 0.25$ meters for the contact. Final times and parameters are:\n\n  - Shock case: $u_L = 2$ meters per second, $u_R = 0$ meters per second, final time $t_{\\mathrm{shock}} = 0.2$ seconds.\n  - Contact case: $\\rho_L = 1$ kilograms per cubic meter, $\\rho_R = 0.1$ kilograms per cubic meter, advection speed $a = 0.5$ meters per second, final time $t_{\\mathrm{contact}} = 0.4$ seconds.\n\n- Use the uniform grids with numbers of cells $N \\in \\{100, 200, 400, 800\\}$. For each $N$, compute the $L_1$ norm of the shock position error $\\|e_s\\|_1$ in meters and the $L_1$ norm of the contact width error $\\|e_w\\|_1$ in meters. Then compute empirical convergence rates for each quantity by pairwise ratios across successive refinements,\n$$\nR = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log\\left(\\Delta x_{N_j} / \\Delta x_{N_{j+1}}\\right)} = \\frac{1}{M}\\sum_{j=1}^{M} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},\n$$\nwhere $E_{N}$ is the error at resolution $N$, $\\Delta x_N = L/N$, and $M = 3$ for the sequence $\\{100,200,400,800\\}$.\n\n- Physical units: all positions and widths must be expressed in meters. Report all errors and rates as unitless floats except that all error values represent lengths in meters.\n\n- Test suite: use the two scenarios above and the grid sizes $N \\in \\{100, 200, 400, 800\\}$ for both scenarios.\n\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with the exact order\n$$\n[\\|e_s\\|_1(N{=}100), \\|e_s\\|_1(N{=}200), \\|e_s\\|_1(N{=}400), \\|e_s\\|_1(N{=}800), R_{\\mathrm{shock}}, \\|e_w\\|_1(N{=}100), \\|e_w\\|_1(N{=}200), \\|e_w\\|_1(N{=}400), \\|e_w\\|_1(N{=}800), R_{\\mathrm{contact}}],\n$$\nwhere each $\\|e_s\\|_1$ and $\\|e_w\\|_1$ is in meters and each rate $R$ is unitless. The list must be printed exactly as specified, with no additional text.", "solution": "This solution details the implementation and analysis of numerical solutions for two fundamental one-dimensional hyperbolic conservation laws: the inviscid Burgers' equation, which models shock formation, and the linear advection equation, which models the propagation of a contact discontinuity. The analysis involves a grid refinement study to measure the convergence of specific error metrics appropriate for discontinuous solutions.\n\nThe solution is structured as follows: First, we develop the numerical solver for the Burgers' equation using a first-order finite-volume method with the Lax-Friedrichs flux. Second, we develop a solver for the linear advection equation using a first-order upwind scheme. For both cases, we implement the specified procedures for detecting the feature (shock position or contact width) and calculating the error against the exact solution. Finally, we perform a grid refinement study for both models, calculate the errors for grid sizes $N \\in \\{100, 200, 400, 800\\}$, and compute the empirical convergence rates.\n\n### 1. Shock Model: Inviscid Burgers' Equation\n\n**Governing Equation and Exact Solution**\nThe inviscid Burgers' equation is given by\n$$u_t + \\left(\\frac{1}{2} u^2\\right)_x = 0.$$\nFor Riemann initial data with $u(x,0) = u_L$ for $x  x_0$ and $u(x,0) = u_R$ for $x  x_0$, where $u_L  u_R$, a shock wave forms and propagates with a constant speed $s$ determined by the Rankine-Hugoniot condition:\n$$s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}.$$\nThe exact shock position at time $t$ is $x_s(t) = x_0 + st$.\n\n**Numerical Implementation**\nWe implement a conservative finite-volume scheme on a uniform grid with cell size $\\Delta x = L/N$. The state variable $u_i^n$ represents the cell-average of the solution in cell $i$ at time $t^n$. The update formula is\n$$u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),$$\nwhere $F_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. We use the Lax-Friedrichs flux:\n$$F_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right) - \\frac{1}{2}\\alpha_{i+\\frac{1}{2}}(u_{i+1} - u_i),$$\nwith the flux function $f(u) = \\frac{1}{2}u^2$ and local dissipative coefficient $\\alpha_{i+\\frac{1}{2}} = \\max\\{|u_i|, |u_{i+1}|\\}$. This scheme is first-order accurate. The time step $\\Delta t$ is controlled by the CFL condition with a constant $\\mathrm{CFL}=0.45$:\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i^n|}.$$\nOutflow boundary conditions are handled by setting the values in the single ghost cells at each end of the domain to be equal to their adjacent interior cell-centered values (zero-gradient extrapolation).\n\n**Error Analysis: Shock Position**\nThe primary error metric is the shock position error, $e_s(t) = x_s^{\\mathrm{num}}(t) - x_s(t)$. To find the numerical shock position $x_s^{\\mathrm{num}}(t)$, we locate where the numerical solution $u(x,t)$ crosses the mid-state value $u_m = (u_L+u_R)/2$. This is achieved by finding the two adjacent grid cells $(i, i+1)$ that straddle $u_m$ and using linear interpolation to find the sub-grid crossing point. A fallback procedure, based on locating the cell interface with the maximum gradient, is implemented for robustness, though it's not expected to be triggered by the monotone Lax-Friedrichs scheme. The $L_1$ norm of this scalar error is simply its absolute value, $\\|e_s\\|_1 = |e_s(t)|$.\n\n### 2. Contact Discontinuity Model: Linear Advection\n\n**Governing Equation and Exact Solution**\nThe linear advection of a passive scalar density $\\rho$ is governed by\n$$\\rho_t + a \\,\\rho_x = 0,$$\nwhere $a$ is a constant velocity. For Riemann initial data, the discontinuity simply translates at speed $a$ without changing its shape. The exact width of the contact remains zero. The position is $x_c(t) = (x_0 + at) \\pmod{L}$ for a periodic domain of length $L$.\n\n**Numerical Implementation**\nA first-order upwind finite-difference scheme is used on a uniform, periodic grid. For the given parameter $a=0.5 \\text{ m/s}  0$, the update is\n$$\\rho_i^{n+1} = \\rho_i^n - \\nu\\left(\\rho_i^n - \\rho_{i-1}^n\\right),$$\nwhere $\\nu = a\\Delta t / \\Delta x$ is the Courant number. Periodicity is enforced by using a circular shift for the $\\rho_{i-1}$ term. The time step is determined by the CFL condition with $\\mathrm{CFL}=0.9$:\n$$\\Delta t = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{|a|}.$$\n\n**Error Analysis: Contact Width**\nFirst-order schemes introduce numerical diffusion, which artificially broadens the contact discontinuity. This broadening is the primary error to be measured. The numerical contact width, $\\hat{w}(t)$, is calculated from the profile of the normalized density, $\\eta(x,t) = (\\rho(x,t) - \\rho_R)/(\\rho_L - \\rho_R)$. We identify the positions $x_{10}(t)$ and $x_{90}(t)$ where $\\eta$ crosses the thresholds $0.1$ and $0.9$, respectively. These positions are found using linear interpolation, with the search localized around the point of maximum gradient in $\\eta$ to ensure the correct transition is identified. The numerical width is then computed as $\\hat{w}(t) = |x_{10}(t) - x_{90}(t)|$. Since the exact width $w(t)$ is zero, the width error is $e_w(t) = \\hat{w}(t)$, and its $L_1$ norm is $\\|e_w\\|_1 = \\hat{w}(t)$.\n\n### 3. Grid Refinement Study and Convergence Rate\n\nA convergence study is performed for both models using a sequence of four grid resolutions, $N = 100, 200, 400, 800$. For each resolution, the corresponding error, $\\|e_s\\|_1$ for the shock or $\\|e_w\\|_1$ for the contact, is recorded. The empirical convergence rate $R$ is then calculated as the average of the pairwise rates determined from successive refinements:\n$$R = \\frac{1}{3} \\sum_{j=1}^{3} \\frac{\\log\\left(E_{N_j} / E_{N_{j+1}}\\right)}{\\log(2)},$$\nwhere $E_{N_j}$ is the error for resolution $N_j$ from the sequence $\\{100, 200, 400, 800\\}$. For first-order schemes, the shock position error is expected to converge with $R \\approx 1$, while the contact width, dominated by numerical diffusion proportional to $\\Delta x$, is also expected to converge with $R \\approx 1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_shock_sim(N):\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation for a shock tube problem\n    using a first-order Lax-Friedrichs finite-volume scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.5  # meters\n    u_L = 2.0  # m/s\n    u_R = 0.0  # m/s\n    t_final = 0.2  # seconds\n    CFL_val = 0.45\n\n    # Grid setup\n    dx = L / N\n    # Array with one ghost cell on each side\n    u = np.zeros(N + 2)\n    # Cell centers for the physical domain\n    domain_x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n\n    # Initial condition\n    u[1:-1] = np.where(domain_x  x0, u_L, u_R)\n    \n    t = 0.0\n    while t  t_final:\n        # Boundary conditions: outflow (zero-gradient)\n        u[0] = u[1]\n        u[-1] = u[-2]\n\n        # Time step from CFL condition\n        max_speed = np.max(np.abs(u))\n        if max_speed  1e-9: # Avoid division by zero\n            dt = t_final - t\n        else:\n            dt = CFL_val * dx / max_speed\n        \n        dt = min(dt, t_final - t)\n\n        # Lax-Friedrichs flux calculation\n        f_u = 0.5 * u**2\n        u_left = u[:-1]\n        u_right = u[1:]\n        \n        alpha = np.maximum(np.abs(u_left), np.abs(u_right))\n        flux = 0.5 * (f_u[:-1] + f_u[1:]) - 0.5 * alpha * (u_right - u_left)\n        \n        # Update solution in the physical domain\n        u[1:-1] -= (dt / dx) * (flux[1:] - flux[:-1])\n        \n        t += dt\n\n    # Post-processing to find error\n    s = (u_L + u_R) / 2.0\n    x_s_exact = x0 + s * t_final\n    \n    u_m = (u_L + u_R) / 2.0\n    u_domain = u[1:-1]\n    \n    x_s_num = None\n    # Find shock position via linear interpolation\n    for i in range(N - 1):\n        if u_domain[i]  u_m and u_domain[i+1] = u_m:\n            y1, y2 = u_domain[i], u_domain[i+1]\n            x1 = domain_x[i]\n            # (x2-x1) is dx\n            x_s_num = x1 + dx * (u_m - y1) / (y2 - y1)\n            break\n            \n    # Fallback if no crossing is found\n    if x_s_num is None:\n        grad_u = np.abs(u_domain[1:] - u_domain[:-1])\n        max_grad_idx = np.argmax(grad_u)\n        # Midpoint of the cell face with maximal gradient\n        x_s_num = domain_x[max_grad_idx] + 0.5 * dx\n\n    return np.abs(x_s_num - x_s_exact)\n\n\ndef run_contact_sim(N):\n    \"\"\"\n    Solves the 1D linear advection equation for a contact discontinuity\n    using a first-order upwind finite-difference scheme.\n    \"\"\"\n    # Parameters from problem statement\n    L = 1.0  # meters\n    x0 = 0.25  # meters\n    rho_L = 1.0  # kg/m^3\n    rho_R = 0.1  # kg/m^3\n    a = 0.5  # m/s\n    t_final = 0.4  # seconds\n    CFL_val = 0.9\n\n    # Grid setup\n    dx = L / N\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n    rho = np.where(x  x0, rho_L, rho_R)\n    \n    t = 0.0\n    # Fixed timestep and Courant number for linear advection\n    dt_cfl = CFL_val * dx / np.abs(a)\n    nu_cfl = a * dt_cfl / dx\n\n    while t  t_final:\n        dt = min(dt_cfl, t_final - t)\n        nu = a * dt / dx\n        \n        # Update with first-order upwind scheme (a  0)\n        # Periodic BCs handled by np.roll\n        rho_prev = np.roll(rho, 1)\n        rho = rho - nu * (rho - rho_prev)\n        \n        t += dt\n\n    # Post-processing to find contact width\n    eta = (rho - rho_R) / (rho_L - rho_R)\n    \n    def find_crossing_pos(vals, x_coords, threshold):\n        for i in range(N):\n            i_p1 = (i + 1) % N\n            y1, y2 = vals[i], vals[i_p1]\n            if (y1 - threshold) * (y2 - threshold)  0 and y1  y2:\n                x1 = x_coords[i]\n                return x1 + dx * (threshold - y1) / (y2 - y1)\n        return None\n\n    x_90 = find_crossing_pos(eta, x, 0.9)\n    x_10 = find_crossing_pos(eta, x, 0.1)\n\n    if x_90 is None or x_10 is None:\n        return np.nan # Should not happen in this problem\n\n    # Since profile is decreasing, x_90  x_10. Width is positive.\n    width = x_10 - x_90\n    if width  0: # Handle periodic wrap-around case\n        width += L\n    \n    return width\n\n\ndef calculate_rate(errors):\n    \"\"\"Calculates the average convergence rate.\"\"\"\n    rates = []\n    for i in range(len(errors) - 1):\n        # Avoid log(0) or division by zero\n        if errors[i] = 0 or errors[i+1] = 0:\n            continue\n        ratio_err = errors[i] / errors[i+1]\n        rate = np.log2(ratio_err) # Equivalent to log(ratio)/log(2)\n        rates.append(rate)\n    return np.mean(rates) if rates else np.nan\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run simulations, calculate errors and rates,\n    and print the final result in the specified format.\n    \"\"\"\n    N_vals = [100, 200, 400, 800]\n    \n    shock_errors = [run_shock_sim(N) for N in N_vals]\n    R_shock = calculate_rate(shock_errors)\n\n    contact_errors = [run_contact_sim(N) for N in N_vals]\n    R_contact = calculate_rate(contact_errors)\n    \n    results = shock_errors + [R_shock] + contact_errors + [R_contact]\n    \n    # Format and print the final output line\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n\n```", "id": "3521202"}, {"introduction": "While first-order schemes are robust, their high numerical diffusion excessively smears sharp features. To achieve higher fidelity, we turn to second-order methods like the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL). This approach, however, can introduce non-physical oscillations near discontinuities, which must be controlled using slope limiters. This hands-on coding exercise challenges you to implement a MUSCL-based finite volume scheme and explore the role of various classic slope limiters in capturing a contact discontinuity [@problem_id:3521267]. You will gain practical insight into the trade-off between maintaining sharpness and preventing spurious oscillations, a central theme in modern computational fluid dynamics.", "problem": "Consider the one-dimensional scalar conservation law $\\partial_t q + \\partial_x f(q) = 0$ over a periodic domain of length $L$ with a piecewise constant initial condition that contains a single contact discontinuity. In a contact discontinuity of a compressible flow, a passively advected scalar such as density or a mass fraction is transported without change in shape by the underlying velocity field. Model this transport using the linear advection flux $f(q) = a q$ with constant advection speed $a$, so that the conservation law becomes $\\partial_t q + a \\partial_x q = 0$. Use a finite volume method with uniform cells where $q_i^n$ denotes the cell average in cell index $i$ at time level $n$, uniform grid spacing $\\Delta x = L/N$, and time step $\\Delta t$ set by a specified Courant number $C$ through $\\Delta t = C \\Delta x / |a|$. The update for a single time step is $q_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$, where $F_{i+1/2}^n$ is the numerical flux at the interface between cells $i$ and $i+1$ and periodic boundary conditions are imposed.\n\nConstruct second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) interface states $q_{i+1/2}^{L}$ and $q_{i+1/2}^{R}$ by piecewise linear reconstruction from $q_i^n$ with a slope limiter chosen from the following set: minmod, monotonized central (MC), van Leer, or superbee. The slope limiter must enforce monotonicity consistent with the Total Variation Diminishing (TVD) requirement, reducing to first-order upwind in the presence of local extrema and sharpening contacts where possible without creating spurious oscillations. Use the upwind Godunov flux for linear advection: for $a \\ge 0$, choose $F_{i+1/2}^n = a \\, q_{i+1/2}^{L}$; for $a  0$, choose $F_{i+1/2}^n = a \\, q_{i+1/2}^{R}$.\n\nAfter advancing the solution by one time step from the initial data using the above scheme, assess oscillation control and contact sharpness using the following metrics:\n- Maximum overshoot magnitude with respect to the initial global bounds: let $q_{\\min}^0 = \\min_i q_i^0$ and $q_{\\max}^0 = \\max_i q_i^0$, and define $\\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)$ expressed as a float.\n- Total variation increase: let $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$ with periodic indexing, and define $\\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})$ expressed as a float.\n- Contact transition width: given known plateau values $q_L$ (left state) and $q_R$ (right state), define $\\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R)  q_i^{1}  \\max(q_L,q_R)\\}$ expressed as an integer count of cells whose values lie strictly between the two plateaus after the update.\n\nYour program must implement the reconstruction and update for a single time step and compute these metrics for each test case below. Use a periodic domain. All mathematical operations must be consistent and scientifically sound. No external input is permitted.\n\nTest suite:\n- Case $1$: $N = 100$, $L = 1$, $a = 1$, $C = 0.8$, limiter = minmod, contact location at fraction $x_c = 0.4$ of the domain, plateau values $q_L = 1.0$, $q_R = 0.1$, additive localized noise amplitude $\\epsilon = 0$.\n- Case $2$: $N = 100$, $L = 1$, $a = 1$, $C = 0.95$, limiter = MC, contact location at fraction $x_c = 0.4$, plateau values $q_L = 1.0$, $q_R = 0.1$, additive localized noise amplitude $\\epsilon = 0.01$ applied to exactly the $5$ cells centered at the contact via $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ for those cells.\n- Case $3$: $N = 20$, $L = 1$, $a = 1$, $C = 0.5$, limiter = vanleer, contact location at fraction $x_c = 0.5$, plateau values $q_L = 2.0$, $q_R = 1.5$, $\\epsilon = 0$.\n- Case $4$: $N = 80$, $L = 1$, $a = -1$, $C = 0.9$, limiter = superbee, contact location at fraction $x_c = 0.5$, plateau values $q_L = 1.0$, $q_R = 0.0$, additive localized noise amplitude $\\epsilon = 0.005$ applied to exactly the $3$ cells centered at the contact via $q_i \\mapsto q_i + \\epsilon \\sin\\left(2\\pi i / N\\right)$ for those cells.\n- Case $5$ (boundary condition and degeneracy check): $N = 50$, $L = 1$, $a = 1$, $C = 0.7$, limiter = MC, contact location at fraction $x_c = 0.3$, plateau values $q_L = 0.5$, $q_R = 0.5$, $\\epsilon = 0$.\n\nInitialization: For each case, initialize $q_i^0$ on a uniform grid points $x_i = (i+1/2)\\Delta x$ by setting $q_i^0 = q_L$ for $x_i  x_c L$ and $q_i^0 = q_R$ for $x_i \\ge x_c L$, then add the specified localized noise at the designated number of cells centered on the contact index $i_c = \\lfloor x_c N \\rfloor$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three values $[\\mathrm{overshoot\\_max}, \\mathrm{width}, \\Delta \\mathrm{TV}]$. Round the floating-point values $\\mathrm{overshoot\\_max}$ and $\\Delta \\mathrm{TV}$ to $6$ decimal places, and output $\\mathrm{width}$ as an integer. For example, an output with two cases would look like $[[0.000123,4,0.001234],[0.0,0,-0.000456]]$.", "solution": "A second-order Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) finite volume method is implemented to solve the one-dimensional linear advection equation,\n$$\n\\partial_t q + a \\partial_x q = 0\n$$\non a periodic domain of length $L$. Here, $q(x,t)$ is a scalar quantity and $a$ is a constant advection speed. This equation is a specific case of a conservation law $\\partial_t q + \\partial_x f(q) = 0$ with a linear flux function $f(q) = aq$.\n\nThe numerical solution is computed on a uniform grid of $N$ cells, where cell $i$ spans the interval $[x_{i-1/2}, x_{i+1/2}]$. The cell centers are at $x_i = (i+1/2)\\Delta x$ for $i=0, 1, \\dots, N-1$, with grid spacing $\\Delta x = L/N$. The cell-averaged value of $q$ in cell $i$ at time level $n$ is denoted by $q_i^n$.\n\nThe finite volume method updates the cell averages from one time level $n$ to the next $n+1$ via the conservative formula:\n$$\nq_i^{n+1} = q_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)\n$$\nwhere $\\Delta t$ is the time step, and $F_{i+1/2}^n$ is the numerical flux at the interface between cells $i$ and $i+1$. The time step is determined by the Courant-Friedrichs-Lewy (CFL) condition, $\\Delta t = C \\Delta x / |a|$, where $C$ is the specified Courant number, which must be less than or equal to $1$ for stability. Periodic boundary conditions are applied, meaning that indices are treated modulo $N$.\n\nThe core of the MUSCL scheme is the second-order accurate spatial reconstruction of the states at the cell interfaces. Within each cell $i$, the data is represented by a piecewise linear function. This leads to two distinct values at each interface: $q_{i+1/2}^L$, the state reconstructed from the left (cell $i$), and $q_{i+1/2}^R$, the state reconstructed from the right (cell $i+1$). These are given by:\n$$\nq_{i+1/2}^L = q_i^n + \\frac{1}{2} \\sigma_i\n$$\n$$\nq_{i+1/2}^R = q_{i+1}^n - \\frac{1}{2} \\sigma_{i+1}\n$$\nHere, $\\sigma_i$ is a slope-limited representation of the change in $q$ across cell $i$. To prevent spurious oscillations and ensure the scheme is Total Variation Diminishing (TVD), the slope $\\sigma_i$ is computed by applying a slope limiter function to the backward and forward differences relative to cell $i$: $\\Delta q_{i-1/2} = q_i^n - q_{i-1}^n$ and $\\Delta q_{i+1/2} = q_{i+1}^n - q_i^n$.\n$$\n\\sigma_i = \\text{limiter}(\\Delta q_{i-1/2}, \\Delta q_{i+1/2})\n$$\nThe limiter functions are defined as follows, for two arguments $u$ and $v$:\n1.  **minmod**:\n    $$\n    \\text{minmod}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min(|u|, |v|)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n2.  **Monotonized Central (MC)**:\n    $$\n    \\text{MC}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\min\\left(2|u|, 2|v|, \\frac{|u+v|}{2}\\right)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n3.  **van Leer**:\n    $$\n    \\text{vanLeer}(u, v) =\n    \\begin{cases}\n    \\frac{2uv}{u+v}  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n4.  **superbee**:\n    $$\n    \\text{superbee}(u, v) =\n    \\begin{cases}\n    \\text{sgn}(u) \\max\\left(\\min(2|u|,|v|), \\min(|u|,2|v|)\\right)  \\text{if } uv  0 \\\\\n    0  \\text{if } uv \\le 0\n    \\end{cases}\n    $$\n\nThe numerical flux $F_{i+1/2}^n$ is an upwind Godunov flux, which selects the interface state based on the direction of information flow, determined by the sign of the advection speed $a$:\n$$\nF_{i+1/2}^n =\n\\begin{cases}\na \\, q_{i+1/2}^{L}  \\text{if } a \\ge 0 \\\\\na \\, q_{i+1/2}^{R}  \\text{if } a  0\n\\end{cases}\n$$\n\nAfter computing the updated state $q_i^1$ for all cells $i$, the following metrics are evaluated to assess the scheme's performance:\n-   **Maximum overshoot magnitude**: This measures the largest violation of the initial data's global minimum and maximum values. Let $q_{\\min}^0 = \\min_j q_j^0$ and $q_{\\max}^0 = \\max_j q_j^0$. The overshoot is:\n    $$\n    \\mathrm{overshoot\\_max} = \\max_i \\max\\left(0, q_i^{1} - q_{\\max}^0, q_{\\min}^0 - q_i^{1}\\right)\n    $$\n    A value of $0$ indicates a non-oscillatory result that respects the initial bounds.\n-   **Total variation increase**: The total variation $\\mathrm{TV}(q) = \\sum_i \\left|q_{i+1} - q_i\\right|$ (with periodic indexing) is a measure of the total oscillation in the data. For a TVD scheme, the total variation should not increase over time. The metric is the change in total variation after one step:\n    $$\n    \\Delta \\mathrm{TV} = \\mathrm{TV}(q^{1}) - \\mathrm{TV}(q^{0})\n    $$\n-   **Contact transition width**: This measures the numerical diffusion of the contact discontinuity. It is defined as the number of cells whose values lie strictly between the initial left and right plateau values, $q_L$ and $q_R$:\n    $$\n    \\mathrm{width} = \\#\\{i \\, | \\, \\min(q_L,q_R)  q_i^{1}  \\max(q_L,q_R)\\}\n    $$\n    A smaller width indicates a sharper captured discontinuity.\n\nThe algorithm proceeds by initializing the cell averages $q_i^0$ based on the given piecewise-constant profile and any specified noise, computing the slopes and interface states, calculating the upwind fluxes, advancing the solution by one time step, and finally computing the required metrics. For the case of constant initial data ($q_L = q_R$), the scheme is expected to preserve this state exactly, resulting in zero for all metrics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a MUSCL finite volume scheme for the 1D linear advection equation\n    and computes performance metrics for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.8, 'limiter': 'minmod', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 100, 'L': 1.0, 'a': 1.0, 'C': 0.95, 'limiter': 'mc', 'xc': 0.4, 'qL': 1.0, 'qR': 0.1, 'epsilon': 0.01, 'noise_cells': 5},\n        {'N': 20, 'L': 1.0, 'a': 1.0, 'C': 0.5, 'limiter': 'vanleer', 'xc': 0.5, 'qL': 2.0, 'qR': 1.5, 'epsilon': 0.0, 'noise_cells': 0},\n        {'N': 80, 'L': 1.0, 'a': -1.0, 'C': 0.9, 'limiter': 'superbee', 'xc': 0.5, 'qL': 1.0, 'qR': 0.0, 'epsilon': 0.005, 'noise_cells': 3},\n        {'N': 50, 'L': 1.0, 'a': 1.0, 'C': 0.7, 'limiter': 'mc', 'xc': 0.3, 'qL': 0.5, 'qR': 0.5, 'epsilon': 0.0, 'noise_cells': 0},\n    ]\n\n    # --- Slope Limiter Functions ---\n    def minmod(a, b):\n        return np.where(a * b  0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def mc(a, b):\n        s = (a + b) / 2.0\n        # Use np.sign(s) instead of np.sign(a) to handle s=0 case if a,b are opposite signs\n        return np.where(a * b  0, np.sign(s) * np.minimum(np.abs(s), np.minimum(2 * np.abs(a), 2 * np.abs(b))), 0)\n\n    def vanleer(a, b):\n        # Handle division by zero when a+b is close to zero\n        # This happens if a = -b or a=b=0. If a*b  0, then a+b=0 only if a=b=0.\n        denom = a + b\n        # Epsilon can be larger since we're dealing with differences, not just machine precision\n        return np.where( (a * b  0)  (np.abs(denom)  1e-12), 2 * a * b / denom, 0)\n        \n    def superbee(a, b):\n        t1 = np.minimum(2 * np.abs(a), np.abs(b))\n        t2 = np.minimum(np.abs(a), 2 * np.abs(b))\n        return np.where(a * b  0, np.sign(a) * np.maximum(t1, t2), 0)\n\n    limiters = {\n        'minmod': minmod,\n        'mc': mc,\n        'vanleer': vanleer,\n        'superbee': superbee\n    }\n\n    def total_variation(q):\n        \"\"\"Computes the total variation of a periodic array.\"\"\"\n        return np.sum(np.abs(np.roll(q, -1) - q))\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        a = case['a']\n        C = case['C']\n        qL = case['qL']\n        qR = case['qR']\n        xc = case['xc']\n        epsilon = case['epsilon']\n        noise_cells = case['noise_cells']\n        limiter_func = limiters[case['limiter']]\n\n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        dt = C * dx / abs(a)\n        \n        # --- Initialization ---\n        i = np.arange(N)\n        x = (i + 0.5) * dx\n        q0 = np.where(x  xc * L, qL, qR)\n\n        if epsilon  0 and noise_cells  0:\n            ic = int(np.floor(xc * N))\n            m = noise_cells // 2\n            noise_indices = np.arange(ic - m, ic + m + 1)\n            noise_indices = noise_indices % N  # Handle periodic wrap-around\n            q0[noise_indices] += epsilon * np.sin(2 * np.pi * noise_indices / N)\n\n        # --- Initial Metrics ---\n        q0_min = np.min(q0)\n        q0_max = np.max(q0)\n        tv0 = total_variation(q0)\n        \n        # --- MUSCL Finite Volume Step ---\n        # Get neighboring cell values with periodic boundaries\n        q_im1 = np.roll(q0, 1)\n        q_ip1 = np.roll(q0, -1)\n\n        # Compute differences for slope calculation\n        delta_fwd = q_ip1 - q0  # Corresponds to q_{i+1} - q_i\n        delta_bwd = q0 - q_im1  # Corresponds to q_i - q_{i-1}\n\n        # Compute limited slopes for each cell\n        # The limiter function arguments are (q_i - q_{i-1}, q_{i+1} - q_i)\n        sigma = limiter_func(delta_bwd, delta_fwd)\n\n        # Reconstruct interface states\n        q_L = q0 + 0.5 * sigma\n        q_R = q_ip1 - 0.5 * np.roll(sigma, -1)\n\n        # Compute upwind Godunov flux at interfaces i+1/2\n        if a = 0:\n            F = a * q_L\n        else:\n            F = a * q_R\n        \n        # Get fluxes at interfaces i-1/2 by rolling\n        F_im1_2 = np.roll(F, 1)\n\n        # Update solution by one time step\n        q1 = q0 - (dt / dx) * (F - F_im1_2)\n\n        # --- Final Metrics Calculation ---\n        # 1. Maximum overshoot\n        overshoot = np.maximum(0, q1 - q0_max)\n        undershoot = np.maximum(0, q0_min - q1)\n        overshoot_max = np.max(np.maximum(overshoot, undershoot))\n\n        # 2. Total variation increase\n        tv1 = total_variation(q1)\n        delta_tv = tv1 - tv0\n\n        # 3. Contact transition width\n        plateau_min = min(qL, qR)\n        plateau_max = max(qL, qR)\n        \n        # Prevent counting plateaus if min == max\n        if plateau_min == plateau_max:\n             width = 0\n        else:\n             width = np.sum((q1  plateau_min)  (q1  plateau_max))\n\n        results.append([round(overshoot_max, 6), int(width), round(delta_tv, 6)])\n\n    # --- Format final output correctly ---\n    formatted_results = []\n    for r in results:\n        # Use standard float formatting; round() handles cases like 0.0 correctly\n        # f-strings with precision (e.g. .6f) would write 0.0 as 0.000000\n        formatted_results.append(f\"[{r[0]},{r[1]},{r[2]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3521267"}, {"introduction": "To capture shocks without catastrophic failure, numerical schemes must dissipate kinetic energy into heat, a process often modeled with an \"artificial viscosity\" term. However, this necessary dissipation has an unintended side effect: it also smears contact discontinuities, which are physically non-dissipative. This exercise uses a powerful analytical approach to explore this fundamental compromise, comparing how it manifests in both grid-based finite-volume methods and particle-based Smoothed Particle Hydrodynamics (SPH) schemes [@problem_id:3521219]. By calculating shock widths and contact smearing using simplified models, you will develop a quantitative understanding of how numerical choices impact the simulation of different physical phenomena.", "problem": "Consider one-dimensional compressible flow governed by the Euler equations for an ideal gas with ratio of specific heats $\\gamma$, augmented by an artificial viscosity of the linear form $q = C_{\\rm av}\\, \\rho\\, c_s\\, |\\nabla \\cdot u|$, where $\\rho$ is the mass density, $u$ is the velocity, $c_s$ is the local sound speed, and $C_{\\rm av}$ is a dimensionless coefficient. In grid-based finite-volume schemes, it is common to treat $q$ as an effective bulk viscosity acting over a characteristic resolution scale $\\Delta x$. In Smoothed Particle Hydrodynamics (SPH), the analogous dissipation is often parameterized over the smoothing length $h$. For a normal shock, assume the dissipation acts as a kinematic viscosity $\\nu_{\\rm eff}$ localized over the resolution scale $\\ell$, with $\\nu_{\\rm eff} = C_{\\rm av}\\, c_s\\, \\ell$.\n\nYour task is to compute, for a set of test cases, the following four quantities:\n- The shock width (measured in units of $\\Delta x$) in a grid scheme, using a steady-shock analog derived from the viscous Burgers equation.\n- The shock width (measured in units of $\\Delta x$) in a Smoothed Particle Hydrodynamics (SPH) scheme when adjusted to match the grid dissipation at the resolution scale.\n- The SPH coefficient $C_{\\rm av}^{\\rm sph}$ required to match the grid dissipation at the resolution scale.\n- The contact discontinuity smearing width (measured in units of $\\Delta x$) for the grid scheme after a finite time $t$, modeled as diffusion of a passive scalar with diffusivity equal to the effective viscosity, and the corresponding SPH contact width assuming no explicit conductivity (thus negligible diffusion of density).\n\nFundamental base and modeling assumptions to be used:\n- Use the normal shock relations for an ideal gas to determine the downstream-to-upstream density compression ratio $r$ as a function of the upstream Mach number $M_1$ and $\\gamma$, treating the upstream state as $(\\rho_1, p_1, u_1)$ with $\\rho_1 = 1$, $p_1 = 1$, and $u_1 = M_1\\, c_{s1}$, where $c_{s1} = \\sqrt{\\gamma p_1 / \\rho_1} = \\sqrt{\\gamma}$.\n- For a one-dimensional steady shock in the presence of an effective viscosity $\\nu_{\\rm eff}$, approximate the shock internal structure by the steady solution of the viscous Burgers equation, and define the shock width $\\delta$ via the inverse of the maximum gradient (slope-based thickness). This yields $\\delta = 4 \\nu_{\\rm eff}/\\Delta u$, where $\\Delta u = u_1 - u_2$ is the velocity jump, with $u_2 = u_1/r$ obtained from mass conservation.\n- For the grid scheme, take $\\nu_{\\rm eff}^{\\rm grid} = C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, \\Delta x$ and compute the shock width in grid-cell units as $w_{\\rm shock}^{\\rm grid} = \\delta/\\Delta x$.\n- For the SPH scheme, take $\\nu_{\\rm eff}^{\\rm sph} = C_{\\rm av}^{\\rm sph}\\, c_{s1}\\, h$. Impose matching dissipation at the resolution scale by equating the physical shock width $\\delta$ between the schemes, which defines $C_{\\rm av}^{\\rm sph}$ as a function of $C_{\\rm av}^{\\rm grid}$ and the ratio $s = h/\\Delta x$. Report the SPH shock width in units of $\\Delta x$ using this matched $C_{\\rm av}^{\\rm sph}$.\n- For contact smearing in the grid scheme, model the evolution of an initial sharp contact discontinuity of a passive scalar under advection-diffusion with diffusivity $D = \\nu_{\\rm eff}^{\\rm grid}$ for time $t$. Measure the contact width as the full-width at half-maximum (FWHM) of the gradient, which yields $w_{\\rm contact}^{\\rm grid} = 4 \\sqrt{(\\ln 2)\\, D\\, t}/\\Delta x$. For the SPH scheme with no explicit conductivity, assume negligible diffusion of density and take $w_{\\rm contact}^{\\rm sph} \\approx 0$ in units of $\\Delta x$.\n\nAll computations are nondimensional with $\\rho_1 = 1$, $p_1 = 1$, length measured in the same units as $\\Delta x$, time in the same units such that velocities have units of length per unit time, and widths must be reported in units of $\\Delta x$ as dimensionless floats.\n\nDefinitions to use:\n- Upstream sound speed: $c_{s1} = \\sqrt{\\gamma}$.\n- Compression ratio: $r = \\dfrac{(\\gamma + 1)\\, M_1^2}{(\\gamma - 1)\\, M_1^2 + 2}$.\n- Velocity jump: $\\Delta u = u_1\\left(1 - \\dfrac{1}{r}\\right)$ with $u_1 = M_1\\, c_{s1}$.\n- Effective viscosities: $\\nu_{\\rm eff}^{\\rm grid} = C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, \\Delta x$, $\\nu_{\\rm eff}^{\\rm sph} = C_{\\rm av}^{\\rm sph}\\, c_{s1}\\, h$.\n- Shock width (slope-based): $\\delta = \\dfrac{4 \\nu_{\\rm eff}}{\\Delta u}$.\n- Grid shock width in cells: $w_{\\rm shock}^{\\rm grid} = \\dfrac{\\delta}{\\Delta x} = \\dfrac{4\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}}{\\Delta u}$.\n- SPH grid-matched coefficient: $C_{\\rm av}^{\\rm sph} = C_{\\rm av}^{\\rm grid}\\, \\dfrac{\\Delta x}{h} = \\dfrac{C_{\\rm av}^{\\rm grid}}{s}$.\n- SPH shock width reported in grid cells: $w_{\\rm shock}^{\\rm sph} = \\left(\\dfrac{\\delta}{h}\\right)\\, s = \\dfrac{4\\, C_{\\rm av}^{\\rm sph}\\, c_{s1}}{\\Delta u}\\, s$.\n- Grid contact FWHM in cells after time $t$: $w_{\\rm contact}^{\\rm grid} = \\dfrac{4 \\sqrt{(\\ln 2)\\, \\nu_{\\rm eff}^{\\rm grid}\\, t}}{\\Delta x} = 4 \\sqrt{(\\ln 2)\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, t/\\Delta x}$.\n- SPH contact width in cells: $w_{\\rm contact}^{\\rm sph} \\approx 0$.\n\nTest suite:\nProvide the following parameter sets $(\\gamma, M_1, C_{\\rm av}^{\\rm grid}, \\Delta x, s, t)$:\n- Case A (moderate shock, typical smoothing): $(\\gamma = 1.4, M_1 = 2.0, C_{\\rm av}^{\\rm grid} = 1.0, \\Delta x = 1/400, s = 1.2, t = 0.1)$.\n- Case B (near-sonic edge case, typical smoothing): $(\\gamma = 1.4, M_1 = 1.05, C_{\\rm av}^{\\rm grid} = 1.0, \\Delta x = 1/400, s = 1.2, t = 0.1)$.\n- Case C (strong shock, alternate $\\gamma$ and finer grid): $(\\gamma = 1.667, M_1 = 10.0, C_{\\rm av}^{\\rm grid} = 0.5, \\Delta x = 1/1000, s = 1.0, t = 0.05)$.\n\nRequired outputs:\nFor each case, compute and output a list with five floats in the following order:\n$[w_{\\rm shock}^{\\rm grid}, w_{\\rm shock}^{\\rm sph}, C_{\\rm av}^{\\rm sph}, w_{\\rm contact}^{\\rm grid}, w_{\\rm contact}^{\\rm sph}]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all three cases as a single comma-separated list enclosed in square brackets. Concatenate the five-element results for Case A, Case B, and Case C in order into one flat list, e.g., $[{\\rm A}_1,{\\rm A}_2,{\\rm A}_3,{\\rm A}_4,{\\rm A}_5,{\\rm B}_1,\\dots,{\\rm C}_5]$. All widths must be reported in units of $\\Delta x$ as dimensionless floats, and times are in the same nondimensional units specified above.", "solution": "We begin from the one-dimensional Euler equations for an ideal gas with ratio of specific heats $\\gamma$ in conservation form. To model shocks numerically, many schemes augment the equations with an artificial viscosity term that acts like an effective bulk viscosity under compression. In linear artificial viscosity, one adds $q = C_{\\rm av}\\, \\rho\\, c_s\\, |\\nabla \\cdot u|$ to the pressure in the momentum and energy equations, with $C_{\\rm av}$ dimensionless, $\\rho$ the density, $u$ the velocity, and $c_s$ the sound speed. When coarse-grained over a resolution scale $\\ell$, this has the effect of a kinematic viscosity $\\nu_{\\rm eff}$ proportional to $c_s$ and $\\ell$:\n$$\n\\nu_{\\rm eff} = \\frac{q}{\\rho\\, |\\nabla \\cdot u|} \\approx C_{\\rm av}\\, c_s\\, \\ell.\n$$\nThis approximation captures the dominant role of resolution-scale dissipation and is robust for designing parameter studies.\n\nFor a normal shock, the inviscid jump conditions (Rankine–Hugoniot relations) give the compression ratio as a function of the upstream Mach number $M_1$ and $\\gamma$:\n$$\nr \\equiv \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma + 1) M_1^2}{(\\gamma - 1) M_1^2 + 2}.\n$$\nAssuming upstream nondimensional state $\\rho_1 = 1$, $p_1 = 1$, the upstream sound speed is $c_{s1} = \\sqrt{\\gamma p_1/\\rho_1} = \\sqrt{\\gamma}$ and the upstream velocity is $u_1 = M_1\\, c_{s1}$. From mass conservation across the shock, $\\rho_1 u_1 = \\rho_2 u_2$, therefore $u_2 = u_1/r$. The velocity jump is then\n$$\n\\Delta u = u_1 - u_2 = u_1 \\left(1 - \\frac{1}{r}\\right).\n$$\n\nTo connect the effective viscosity to an internal shock thickness, we adopt the well-tested viscous Burgers equation as a local model for shock steepening and balancing by viscosity:\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu_{\\rm eff} \\frac{\\partial^2 u}{\\partial x^2}.\n$$\nIn steady state ($\\partial u/\\partial t = 0$), the exact shock solution joining two constant states of velocity with jump $\\Delta u$ is\n$$\nu(x) = u_2 + \\frac{\\Delta u}{2} \\left[1 - \\tanh\\left(\\frac{\\Delta u}{2 \\nu_{\\rm eff}} (x - x_0)\\right)\\right].\n$$\nThe maximum slope occurs at the inflection point $x_0$ and is\n$$\n\\left|\\frac{du}{dx}\\right|_{\\max} = \\frac{(\\Delta u)^2}{4 \\nu_{\\rm eff}}.\n$$\nA slope-based definition of the shock thickness $\\delta$ sets $\\delta$ equal to the ratio of the amplitude to the maximum slope:\n$$\n\\delta \\equiv \\frac{\\Delta u}{\\left|\\dfrac{du}{dx}\\right|_{\\max}} = \\frac{4 \\nu_{\\rm eff}}{\\Delta u}.\n$$\nThis measure is widely used because it relates directly to the steepest gradient attained and is robust to monotonic re-parameterizations of the profile.\n\nIn a grid scheme with cell size $\\Delta x$, setting $\\nu_{\\rm eff}^{\\rm grid} = C_{\\rm av}^{\\rm grid} c_{s1} \\Delta x$ gives a grid shock width in cell units\n$$\nw_{\\rm shock}^{\\rm grid} \\equiv \\frac{\\delta}{\\Delta x} = \\frac{4 \\nu_{\\rm eff}^{\\rm grid}}{\\Delta u\\, \\Delta x} = \\frac{4\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}}{\\Delta u}.\n$$\nIn Smoothed Particle Hydrodynamics (SPH), with smoothing length $h$, the analogous effective viscosity is $\\nu_{\\rm eff}^{\\rm sph} = C_{\\rm av}^{\\rm sph} c_{s1} h$ (Smoothed Particle Hydrodynamics (SPH) replaces grid resolution $\\Delta x$ with $h$). To match dissipation at the resolution scale (i.e., to produce the same physical shock thickness $\\delta$), equate $\\delta$ between the two schemes:\n$$\n\\frac{4\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, \\Delta x}{\\Delta u} = \\frac{4\\, C_{\\rm av}^{\\rm sph}\\, c_{s1}\\, h}{\\Delta u}\n\\quad \\Rightarrow \\quad\nC_{\\rm av}^{\\rm sph} = C_{\\rm av}^{\\rm grid} \\frac{\\Delta x}{h}.\n$$\nDefining $s \\equiv h/\\Delta x$, this gives $C_{\\rm av}^{\\rm sph} = C_{\\rm av}^{\\rm grid}/s$. The SPH shock width reported in grid-cell units is then\n$$\nw_{\\rm shock}^{\\rm sph} \\equiv \\left(\\frac{\\delta}{h}\\right) s = \\left(\\frac{4\\, C_{\\rm av}^{\\rm sph}\\, c_{s1}}{\\Delta u}\\right) s = \\frac{4\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}}{\\Delta u} = w_{\\rm shock}^{\\rm grid}.\n$$\nThus, when dissipation is matched at the resolution scale, both schemes yield the same shock width when measured in units of $\\Delta x$.\n\nTo quantify contact discontinuity smearing, consider a passive scalar (e.g., density contrast) advected with a constant mean velocity and diffused with diffusivity $D$. Starting from a sharp step, the profile evolves into an error function with gradient equal to a Gaussian with variance $\\sigma^2 = 2 D t$. A physically meaningful and measurable width is the full-width at half-maximum (FWHM) of the gradient, which is\n$$\n{\\rm FWHM} = 2 \\sqrt{2 \\ln 2}\\, \\sigma = 2 \\sqrt{2 \\ln 2}\\, \\sqrt{2 D t} = 4 \\sqrt{(\\ln 2)\\, D\\, t}.\n$$\nFor the grid scheme, we set $D = \\nu_{\\rm eff}^{\\rm grid} = C_{\\rm av}^{\\rm grid} c_{s1} \\Delta x$, so the contact width in cell units after time $t$ is\n$$\nw_{\\rm contact}^{\\rm grid} = \\frac{{\\rm FWHM}}{\\Delta x} = \\frac{4 \\sqrt{(\\ln 2)\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, \\Delta x\\, t}}{\\Delta x} = 4 \\sqrt{(\\ln 2)\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, t / \\Delta x}.\n$$\nIn SPH without explicit artificial conductivity, density is advected exactly by particles and is not diffused by the velocity divergence viscosity; hence, in the continuum limit the contact remains sharp, giving\n$$\nw_{\\rm contact}^{\\rm sph} \\approx 0.\n$$\n\nAlgorithmic procedure for each test case $(\\gamma, M_1, C_{\\rm av}^{\\rm grid}, \\Delta x, s, t)$:\n1. Compute $c_{s1} = \\sqrt{\\gamma}$, $u_1 = M_1 c_{s1}$.\n2. Compute $r = \\dfrac{(\\gamma + 1) M_1^2}{(\\gamma - 1) M_1^2 + 2}$ and $\\Delta u = u_1\\left(1 - \\dfrac{1}{r}\\right)$.\n3. Compute $w_{\\rm shock}^{\\rm grid} = \\dfrac{4 C_{\\rm av}^{\\rm grid} c_{s1}}{\\Delta u}$.\n4. Compute $C_{\\rm av}^{\\rm sph} = \\dfrac{C_{\\rm av}^{\\rm grid}}{s}$.\n5. Compute $w_{\\rm shock}^{\\rm sph} = \\left(\\dfrac{4 C_{\\rm av}^{\\rm sph} c_{s1}}{\\Delta u}\\right) s$; by construction, this equals $w_{\\rm shock}^{\\rm grid}$.\n6. Compute $w_{\\rm contact}^{\\rm grid} = 4 \\sqrt{(\\ln 2)\\, C_{\\rm av}^{\\rm grid}\\, c_{s1}\\, t / \\Delta x}$.\n7. Set $w_{\\rm contact}^{\\rm sph} = 0$.\n\nEdge cases and consistency:\n- For $M_1 \\to 1^+$, the compression ratio $r \\to 1$, so $\\Delta u \\to 0^+$ and $w_{\\rm shock}^{\\rm grid} \\to \\infty$, reflecting the physical spread of a weak shock. This is a sensitive test of the formula.\n- For large $M_1$, $r \\to (\\gamma + 1)/(\\gamma - 1)$ and $\\Delta u \\sim u_1 (1 - 1/r)$ grows linearly with $M_1$; thus $w_{\\rm shock}^{\\rm grid} \\propto 1/M_1$, a strong-shock limit check.\n- The contact width $w_{\\rm contact}^{\\rm grid}$ scales as $\\sqrt{t/\\Delta x}$ at fixed $C_{\\rm av}^{\\rm grid}$ and $c_{s1}$, consistent with diffusion on the grid where $\\nu_{\\rm eff} \\propto \\Delta x$.\n\nApplying this to the specified test suite, the program will compute and return, for each case, the five requested floats $[w_{\\rm shock}^{\\rm grid}, w_{\\rm shock}^{\\rm sph}, C_{\\rm av}^{\\rm sph}, w_{\\rm contact}^{\\rm grid}, w_{\\rm contact}^{\\rm sph}]$, concatenated into a single flat list, all widths in units of $\\Delta x$ and time in the specified nondimensional units.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef shock_compression_ratio(gamma, M1):\n    # r = ((gamma + 1) M^2) / ((gamma - 1) M^2 + 2)\n    return ((gamma + 1.0) * M1**2) / (((gamma - 1.0) * M1**2) + 2.0)\n\ndef upstream_sound_speed(gamma):\n    # c_s1 = sqrt(gamma * p1 / rho1) with p1 = rho1 = 1\n    return np.sqrt(gamma)\n\ndef delta_u(gamma, M1):\n    c1 = upstream_sound_speed(gamma)\n    u1 = M1 * c1\n    r = shock_compression_ratio(gamma, M1)\n    return u1 * (1.0 - 1.0 / r)\n\ndef w_shock_grid(gamma, M1, C_av_grid):\n    # w_shock_grid = 4 * C_av_grid * c_s1 / Δu\n    c1 = upstream_sound_speed(gamma)\n    du = delta_u(gamma, M1)\n    return 4.0 * C_av_grid * c1 / du\n\ndef cav_sph_match(C_av_grid, s):\n    # C_av_sph = C_av_grid / s\n    return C_av_grid / s\n\ndef w_shock_sph_matched(gamma, M1, C_av_grid, s):\n    # w_shock_sph in grid-cell units = (4 * C_av_sph * c1 / Δu) * s\n    c1 = upstream_sound_speed(gamma)\n    du = delta_u(gamma, M1)\n    cav_sph = cav_sph_match(C_av_grid, s)\n    return (4.0 * cav_sph * c1 / du) * s\n\ndef w_contact_grid(gamma, C_av_grid, dx, t):\n    # w_contact_grid = 4 * sqrt( ln(2) * C_av_grid * c_s1 * t / dx )\n    c1 = upstream_sound_speed(gamma)\n    return 4.0 * np.sqrt(np.log(2.0) * C_av_grid * c1 * t / dx)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (gamma, M1, C_av_grid, dx, s, t)\n    test_cases = [\n        (1.4,   2.0, 1.0, 1.0/400.0, 1.2, 0.1),    # Case A\n        (1.4,   1.05, 1.0, 1.0/400.0, 1.2, 0.1),   # Case B (near-sonic)\n        (1.667, 10.0, 0.5, 1.0/1000.0, 1.0, 0.05), # Case C (strong shock)\n    ]\n\n    results = []\n    for gamma, M1, C_av_grid, dx, s, t in test_cases:\n        w_grid = w_shock_grid(gamma, M1, C_av_grid)\n        w_sph = w_shock_sph_matched(gamma, M1, C_av_grid, s)\n        cav_sph = cav_sph_match(C_av_grid, s)\n        wc_grid = w_contact_grid(gamma, C_av_grid, dx, t)\n        wc_sph = 0.0  # negligible without explicit conductivity\n        results.extend([\n            w_grid, w_sph, cav_sph, wc_grid, wc_sph\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3521219"}]}