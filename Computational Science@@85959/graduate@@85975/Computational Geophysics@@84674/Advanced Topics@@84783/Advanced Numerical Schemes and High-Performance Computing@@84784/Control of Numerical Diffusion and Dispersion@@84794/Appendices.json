{"hands_on_practices": [{"introduction": "The foundation of controlling numerical errors is the ability to precisely quantify them. This first practice [@problem_id:3581900] guides you through a Fourier analysis of the linear advection equation, a cornerstone model for wave propagation. By comparing a classical high-order stencil against one optimized for low dispersion, you will develop the essential skill of using modified wavenumber analysis to evaluate how different numerical schemes handle waves of various lengths, revealing the critical trade-off between formal accuracy and practical performance.", "problem": "Consider the one-dimensional linear advection equation $u_t + c u_x = 0$ with constant speed $c  0$ on a uniform grid with spacing $\\Delta x$ and periodic boundary conditions. Let the Courant number be defined as $\\nu = c \\Delta t/\\Delta x$. You will compare two spatial discretizations for the first derivative $u_x$ coupled to the same explicit time integrator, and quantify their numerical dispersion (phase error) and numerical dissipation (amplitude error) across the non-dimensional wavenumber band $k\\Delta x \\in [0,\\pi]$. All angles must be expressed in radians.\n\nBase the analysis on the following principles and well-tested formulas:\n\n- Fourier mode analysis: for a Fourier mode $u_j^n \\propto \\exp(i j \\xi)$ with $\\xi = k\\Delta x \\in [0,\\pi]$, any linear time-stepping scheme applied to the discretized spatial operator yields a per-step complex amplification factor $G(\\xi)$ such that $u^{n+1} = G(\\xi) u^n$.\n- For the exact partial differential equation, the per-step exact amplification factor is $\\exp(-i \\nu \\xi)$.\n- For a semi-discrete method-of-lines with a finite-difference approximation of $u_x$ on a symmetric stencil, the discrete spatial Fourier symbol is $i \\kappa(\\xi)/\\Delta x$, where $\\kappa(\\xi)$ is the modified wavenumber of the stencil. For an antisymmetric, $(2M+1)$-point central stencil with weights $\\{b_m\\}_{m=1}^M$ defined by\n$$\n(D u)_j \\approx \\frac{1}{\\Delta x}\\sum_{m=1}^M b_m\\left(u_{j+m} - u_{j-m}\\right),\n$$\nthe modified wavenumber is\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi).\n$$\n- For explicit classical fourth-order Runge–Kutta (RK4), whose stability function is\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24},\n$$\nthe numerical amplification factor of the fully discrete scheme is $G(\\xi) = R(-i \\nu \\kappa(\\xi))$.\n\nYou will study two seven-point stencils ($M=3$), both coupled to the same RK4 time integrator at $\\nu = 0.5$:\n\n- Classical sixth-order central difference (on a $7$-point symmetric stencil):\n$$\nb_1 = \\frac{45}{60} = 0.75,\\quad b_2 = -\\frac{9}{60} = -0.15,\\quad b_3 = \\frac{1}{60}.\n$$\n- An optimized low-dispersion, non-compact, explicit $7$-point stencil with coefficients designed to reduce dispersion error over a wide band (a well-known choice in the literature of Dispersion-Relation-Preserving schemes):\n$$\nb_1 = 0.770882380518225,\\quad b_2 = -0.166705904414580,\\quad b_3 = 0.020843142770311.\n$$\n\nFor each stencil, define the per-step phase error and amplitude error as functions of $\\xi$ by\n$$\ne_{\\mathrm{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\,\\xi\\right),\n\\qquad\ne_{\\mathrm{amp}}(\\xi) = \\left| |G(\\xi)| - 1 \\right|,\n$$\nwhere $\\arg(\\cdot)$ is the principal argument and $\\operatorname{wrap}_{(-\\pi,\\pi]}(\\theta)$ wraps any real angle $\\theta$ into $(-\\pi,\\pi]$ by adding or subtracting integer multiples of $2\\pi$.\n\nDefine a combined per-step error magnitude\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}.\n$$\n\nYour program must, for $\\nu = 0.5$ and a uniform grid of $N = 10001$ points in $\\xi \\in [0,\\pi]$ inclusive, compute the following quantities:\n\n- Test case 1 (float): the smallest $\\xi^\\star \\in (0,\\pi]$ at which the optimized stencil achieves strictly smaller combined error than the classical stencil, i.e., the smallest sampled $\\xi$ such that $E_{\\mathrm{opt}}(\\xi)  E_{\\mathrm{classical}}(\\xi)$. If no such $\\xi$ exists on the grid, return $\\mathrm{NaN}$.\n- Test case 2 (boolean): at $\\xi = \\pi/2$, does the optimized stencil have strictly smaller absolute phase error than the classical stencil? Return $True$ if $\\left|e_{\\mathrm{phase,opt}}(\\pi/2)\\right|  \\left|e_{\\mathrm{phase,classic}}(\\pi/2)\\right|$, otherwise $False$.\n- Test case 3 (boolean): at $\\xi = 0$, do both stencils have amplitude error below a tolerance of $10^{-12}$? Return $True$ if $\\left|e_{\\mathrm{amp,opt}}(0)\\right| \\le 10^{-12}$ and $\\left|e_{\\mathrm{amp,classic}}(0)\\right| \\le 10^{-12}$, otherwise $False$.\n- Test case 4 (float): the maximum absolute amplitude error of the classical stencil over $\\xi \\in [0,\\pi]$, i.e., $\\max_{\\xi} \\left|e_{\\mathrm{amp,classic}}(\\xi)\\right|$.\n- Test case 5 (float): the maximum absolute amplitude error of the optimized stencil over $\\xi \\in [0,\\pi]$, i.e., $\\max_{\\xi} \\left|e_{\\mathrm{amp,opt}}(\\xi)\\right|$.\n\nAngle quantities must be in radians. All floating-point outputs must be rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order specified above, for the five test cases:\n$[\\xi^\\star, \\text{bool\\_at\\_}\\pi/2, \\text{bool\\_at\\_}0, \\max e_{\\mathrm{amp,classic}}, \\max e_{\\mathrm{amp,opt}}]$.", "solution": "The problem requires a comparative analysis of two numerical schemes for the one-dimensional linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the transported quantity and $c > 0$ is the constant wave speed. The analysis is performed in the Fourier domain for a uniform spatial grid with spacing $\\Delta x$ and a constant time step $\\Delta t$. The key parameter is the Courant number, defined as $\\nu = c\\Delta t / \\Delta x$.\n\nWe analyze the behavior of the schemes on a single Fourier mode, $u_j^n = \\hat{u}^n(k) e^{i(k x_j)} = \\hat{u}^n(\\xi) e^{ij\\xi}$, where $x_j = j\\Delta x$ and $\\xi = k\\Delta x$ is the non-dimensional wavenumber. The exact solution evolves this mode over one time step $\\Delta t$ as:\n$$\nu(x, t+\\Delta t) = u(x-c\\Delta t, t) \\implies \\hat{u}^{n+1} = \\hat{u}^n e^{-ikc\\Delta t} = \\hat{u}^n e^{-i\\nu\\xi}\n$$\nThe term $G_{\\text{exact}}(\\xi) = e^{-i\\nu\\xi}$ is the exact amplification factor. It has a magnitude of $|G_{\\text{exact}}(\\xi)| = 1$, indicating no amplitude change, and a phase of $\\phi_{\\text{exact}}(\\xi) = -\\nu\\xi$.\n\nA numerical scheme approximates this evolution by $u_j^{n+1} = \\mathcal{L}(u^n)_j$, which in the Fourier domain becomes $\\hat{u}^{n+1} = G(\\xi) \\hat{u}^n$. The complex quantity $G(\\xi)$ is the numerical amplification factor of the fully discrete scheme.\n\nThe method of lines first discretizes the spatial derivative $\\frac{\\partial u}{\\partial x}$, yielding a system of ordinary differential equations (ODEs). For a general $(2M+1)$-point antisymmetric central difference scheme, this is:\n$$\n\\frac{du_j}{dt} = -c (D u)_j = -\\frac{c}{\\Delta x} \\sum_{m=1}^M b_m(u_{j+m} - u_{j-m})\n$$\nApplying this operator to the Fourier mode $e^{ij\\xi}$ gives:\n$$\nD e^{ij\\xi} = \\frac{1}{\\Delta x} \\sum_{m=1}^M b_m(e^{i(j+m)\\xi} - e^{i(j-m)\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\sum_{m=1}^M b_m(e^{im\\xi} - e^{-im\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\left( 2i \\sum_{m=1}^M b_m \\sin(m\\xi) \\right)\n$$\nThis defines the Fourier symbol of the spatial operator as $i\\kappa(\\xi)/\\Delta x$, where $\\kappa(\\xi)$ is the modified wavenumber:\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi)\n$$\nThe semi-discrete system of ODEs in Fourier space is therefore $\\frac{d\\hat{u}}{dt} = -c \\frac{i\\kappa(\\xi)}{\\Delta x} \\hat{u}$.\n\nFor the two seven-point stencils ($M=3$) under consideration:\n- **Classical Sixth-Order:** With coefficients $b_1 = 45/60$, $b_2 = -9/60$, $b_3 = 1/60$, the modified wavenumber is:\n$$\n\\kappa_{\\text{classic}}(\\xi) = 2\\left(\\frac{45}{60}\\sin(\\xi) - \\frac{9}{60}\\sin(2\\xi) + \\frac{1}{60}\\sin(3\\xi)\\right)\n$$\n- **Optimized Low-Dispersion:** With coefficients $b_1 = 0.770882380518225$, $b_2 = -0.166705904414580$, $b_3 = 0.020843142770311$, the modified wavenumber is:\n$$\n\\kappa_{\\text{opt}}(\\xi) = 2(b_1\\sin(\\xi) + b_2\\sin(2\\xi) + b_3\\sin(3\\xi))\n$$\n\nThe semi-discrete ODE system $\\frac{d\\hat{u}}{dt} = \\lambda \\hat{u}$, where $\\lambda = -ic\\kappa(\\xi)/\\Delta x$, is integrated forward in time using the explicit fourth-order Runge-Kutta (RK4) method. The amplification factor for a single RK4 step on $y'=\\lambda y$ is given by its stability function, $R(z)$, where $z = \\lambda \\Delta t$.\n$$\nz = \\left(-i\\frac{c\\kappa(\\xi)}{\\Delta x}\\right) \\Delta t = -i \\left(\\frac{c\\Delta t}{\\Delta x}\\right) \\kappa(\\xi) = -i\\nu\\kappa(\\xi)\n$$\nThe numerical amplification factor for the fully discrete scheme is thus $G(\\xi) = R(-i\\nu\\kappa(\\xi))$, where $R(z)$ is the RK4 polynomial:\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\n$$\n\nNumerical errors are quantified by comparing the numerical amplification factor $G(\\xi)$ to the exact one $G_{\\text{exact}}(\\xi)$.\n- The **phase error** measures the difference in phase speeds. The numerical phase is $\\phi_{\\text{num}}(\\xi) = \\arg(G(\\xi))$. The per-step phase error is the difference between the numerical and exact phases, wrapped to the interval $(-\\pi, \\pi]$:\n$$\ne_{\\text{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\phi_{\\text{num}}(\\xi) - \\phi_{\\text{exact}}(\\xi)\\right) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\xi\\right)\n$$\nA non-zero phase error causes numerical dispersion, where waves of different wavenumbers travel at incorrect speeds relative to each other.\n- The **amplitude error** measures the change in a mode's amplitude per step. The numerical amplitude is $|G(\\xi)|$. The per-step amplitude error is:\n$$\ne_{\\text{amp}}(\\xi) = \\left| |G(\\xi)| - 1 \\right|\n$$\nA non-zero amplitude error corresponds to numerical dissipation (if $|G(\\xi)|  1$) or instability (if $|G(\\xi)|  1$). For a stable scheme, this error represents undesired damping.\n- The **combined error** provides a single metric for the overall error magnitude:\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}\n$$\n\nThe solution is obtained by executing the following steps for the given Courant number $\\nu=0.5$:\n1.  Define a discrete grid of $N=10001$ wavenumbers $\\xi_j$ uniformly spaced in $[0, \\pi]$.\n2.  For each stencil (classical and optimized), perform the following:\n    a.  Compute the modified wavenumber vector $\\kappa(\\xi_j)$ using its respective coefficients.\n    b.  Compute the complex vector $z(\\xi_j) = -i\\nu\\kappa(\\xi_j)$.\n    c.  Evaluate the RK4 stability polynomial $G(\\xi_j) = R(z(\\xi_j))$.\n    d.  Calculate the phase error vector $e_{\\text{phase}}(\\xi_j)$, ensuring angles are correctly wrapped into $(-\\pi, \\pi]$.\n    e.  Calculate the amplitude error vector $e_{\\text{amp}}(\\xi_j)$.\n    f.  Calculate the combined error vector $E(\\xi_j)$.\n3.  Using the computed error vectors for both stencils, answer the five test questions:\n    - **Test 1**: Find the first index $j  0$ where $E_{\\text{opt}}(\\xi_j)  E_{\\text{classic}}(\\xi_j)$ and report the corresponding $\\xi_j$.\n    - **Test 2**: At the grid point closest to $\\xi=\\pi/2$, compare the absolute values of the phase errors.\n    - **Test 3**: At $\\xi_0=0$, check if the amplitude errors for both stencils are below the tolerance $10^{-12}$. This is expected from theory, as $\\kappa(0) = 0 \\implies G(0) = 1 \\implies e_{\\text{amp}}(0) = 0$.\n    - **Test 4  5**: Find the maximum value of the amplitude error vectors over the entire domain $[0, \\pi]$ for each stencil.\n4.  Format the final results as a comma-separated list according to the specified format rules.\n\nThis procedure provides a rigorous, quantitative comparison of the dispersion and dissipation properties of the two spatial discretization schemes when coupled with an RK4 time integrator.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and compares two finite-difference schemes for the 1D linear\n    advection equation by computing their numerical dispersion and dissipation\n    errors.\n    \"\"\"\n    # Define problem parameters and test cases from the problem statement.\n    nu = 0.5\n    N = 10001\n    b_classic = [45.0 / 60.0, -9.0 / 60.0, 1.0 / 60.0]\n    b_opt = [0.770882380518225, -0.166705904414580, 0.020843142770311]\n    \n    # Create the non-dimensional wavenumber grid\n    xi = np.linspace(0, np.pi, N, endpoint=True)\n\n    def get_errors(b_coeffs, nu_val, xi_grid):\n        \"\"\"\n        Calculates error metrics for a given stencil and Courant number.\n        \"\"\"\n        # Calculate the modified wavenumber kappa(xi)\n        # kappa(xi) = 2 * sum_{m=1}^{3} b_m * sin(m*xi)\n        kappa = (2 * b_coeffs[0] * np.sin(1 * xi_grid) +\n                 2 * b_coeffs[1] * np.sin(2 * xi_grid) +\n                 2 * b_coeffs[2] * np.sin(3 * xi_grid))\n        \n        # Argument for the RK4 stability function\n        z = -1j * nu_val * kappa\n        \n        # Numerical amplification factor G(xi) from RK4 stability function R(z)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        G = 1 + z + z**2 / 2.0 + z**3 / 6.0 + z**4 / 24.0\n\n        # Calculate phase error, e_phase = wrap(arg(G) + nu*xi)\n        e_phase_raw = np.angle(G) + nu_val * xi_grid\n        \n        # Wrap the phase error to the interval (-pi, pi]\n        # The formula is theta - 2*pi*floor((theta+pi)/(2*pi))\n        e_phase = e_phase_raw - 2 * np.pi * np.floor((e_phase_raw + np.pi) / (2 * np.pi))\n\n        # Calculate amplitude error, e_amp = ||G| - 1|\n        e_amp = np.abs(np.abs(G) - 1.0)\n        \n        # Calculate combined error magnitude E\n        E = np.sqrt(e_phase**2 + e_amp**2)\n\n        return e_phase, e_amp, E\n\n    # Calculate errors for both stencils\n    e_phase_c, e_amp_c, E_c = get_errors(b_classic, nu, xi)\n    e_phase_o, e_amp_o, E_o = get_errors(b_opt, nu, xi)\n\n    # --- Test Cases ---\n\n    # Test case 1: Smallest xi_star in (0, pi] where E_opt  E_classic\n    # We search in the slice [1:] to exclude xi=0\n    indices = np.where(E_o[1:]  E_c[1:])[0]\n    if len(indices)  0:\n        # Add 1 to the index to map it back to the original `xi` array\n        first_index = indices[0] + 1\n        xi_star = xi[first_index]\n    else:\n        xi_star = np.nan\n\n    # Test case 2: At xi = pi/2, is |e_phase_opt|  |e_phase_classic|?\n    idx_pi_2 = np.argmin(np.abs(xi - np.pi / 2.0))\n    is_opt_better_phase = np.abs(e_phase_o[idx_pi_2])  np.abs(e_phase_c[idx_pi_2])\n\n    # Test case 3: At xi = 0, do both stencils have amplitude error = 1e-12?\n    # At xi=0, kappa=0, z=0, G=1, so e_amp should be 0. We check for numerical precision.\n    is_amp_zero_at_origin = (e_amp_c[0] = 1e-12) and (e_amp_o[0] = 1e-12)\n\n    # Test case 4: Maximum absolute amplitude error of the classical stencil\n    max_amp_c = np.max(e_amp_c)\n\n    # Test case 5: Maximum absolute amplitude error of the optimized stencil\n    max_amp_o = np.max(e_amp_o)\n\n    # --- Final Output Formatting ---\n    results = [\n        xi_star,\n        is_opt_better_phase,\n        is_amp_zero_at_origin,\n        max_amp_c,\n        max_amp_o\n    ]\n\n    def format_item(item):\n        \"\"\"Formats a result item according to the problem specification.\"\"\"\n        if isinstance(item, (bool, np.bool_)):\n            return str(item)\n        if isinstance(item, (float, np.floating)):\n            if np.isnan(item):\n                return 'NaN'\n            return f\"{item:.6f}\"\n        return str(item)\n\n    formatted_results = [format_item(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3581900"}, {"introduction": "Building on the analysis of the simple advection equation, we now turn to systems that are inherently dispersive, such as the flexural waves modeled by the Euler-Bernoulli beam equation. This exercise [@problem_id:3581957] provides a powerful and clean framework for quantifying numerical dispersion by directly comparing the discrete eigenspectrum of the numerical operator against the exact analytical solution. You will also explore a practical technique for controlling spurious high-frequency oscillations by implementing a scale-selective filter, a common strategy in large-scale geophysical simulations.", "problem": "You are to construct a computational benchmark for dispersive normal modes using a one-dimensional Euler–Bernoulli flexural wave model, which is a standard proxy in computational geophysics for lithospheric flexure and other thin-plate phenomena. The goal is to quantify and control numerical dispersion and diffusion by comparing discrete-mode eigenfrequencies against exact analytical values for a thin elastic beam.\n\nConsider the initial-boundary-value problem governed by the linear Euler–Bernoulli beam equation\n$$u_{tt}(x,t) + c_b^2 u_{xxxx}(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,$$\nwith simply supported boundary conditions\n$$u(0,t) = 0,\\quad u(L,t) = 0,\\quad u_{xx}(0,t) = 0, \\quad u_{xx}(L,t) = 0.$$\nHere, $u(x,t)$ is the transverse displacement, $L$ is the beam length, and $c_b$ is the flexural wave speed parameter with units of $\\mathrm{m}^2/\\mathrm{s}$ so that angular frequency has units of $\\mathrm{rad/s}$. The normal-mode solution ansatz $u(x,t) = \\phi_n(x)\\cos(\\omega_n t)$ yields the eigenvalue problem\n$$\\phi_n^{(4)}(x) = \\kappa_n^4 \\phi_n(x),\\quad \\phi_n(0) = 0,\\ \\phi_n(L)=0,\\ \\phi_n''(0)=0,\\ \\phi_n''(L)=0,$$\nwhose exact eigenfunctions are $\\phi_n(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)$ with exact wavenumbers $k_n = \\frac{n\\pi}{L}$ for integer modes $n\\ge 1$. The exact angular eigenfrequencies are\n$$\\omega_n^{\\mathrm{exact}} = c_b k_n^2 = c_b \\left(\\frac{n\\pi}{L}\\right)^2.$$\n\nDiscretize the spatial domain with $N$ interior points and uniform spacing $h = \\frac{L}{N+1}$, enforcing the Dirichlet boundary values $u(0,t)=u(L,t)=0$ at the endpoints. Consider two finite-difference discretizations for the second derivative operator $u_{xx}$ on the interior grid, both represented as symmetric Toeplitz matrices acting on the vector of interior values and implicitly using boundary values $u=0$ outside the interior stencil:\n\n- Second-order accurate three-point stencil with coefficients $\\frac{1}{h^2}\\{1,-2,1\\}$ at offsets $\\{-1,0,1\\}$.\n- Fourth-order accurate five-point stencil with coefficients $\\frac{1}{h^2}\\left\\{-\\frac{1}{12},\\frac{4}{3},-\\frac{5}{2},\\frac{4}{3},-\\frac{1}{12}\\right\\}$ at offsets $\\{-2,-1,0,1,2\\}$.\n\nLet $\\theta_n = \\frac{n\\pi}{N+1}$. For the discrete sine eigenvector $v^{(n)}_j = \\sin(j\\theta_n)$, $j=1,\\dots,N$, the corresponding discrete second-derivative eigenvalues for these Toeplitz stencils are\n$$\n\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2} = -\\frac{4\\sin^2(\\theta/2)}{h^2},\n$$\nand\n$$\n\\lambda^{(4)}(\\theta) = \\frac{-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)}{h^2}.\n$$\nThe discrete fourth-derivative eigenvalues are modeled by $\\mu(\\theta) = (\\lambda(\\theta))^2$, and the corresponding semi-discrete angular frequencies satisfy\n$$\n\\omega_n^{\\mathrm{num}} = c_b\\,\\left|\\lambda(\\theta_n)\\right|.\n$$\n\nTo explore control of numerical dispersion and diffusion, augment the spatial operator with a scale-selective smoothing (filter) that reduces high-wavenumber content, represented in modal form by a multiplicative attenuation\n$$\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma \\varphi(\\theta)\\right)\\lambda(\\theta), \\quad \\varphi(\\theta) = \\sin^6\\left(\\frac{\\theta}{2}\\right),$$\nwith filter strength $\\sigma\\in[0,1]$. This mimics spectral vanishing viscosity, primarily acting near the grid Nyquist wavenumber. The filtered discrete frequency is modeled as\n$$\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b \\left|\\lambda_{\\sigma}(\\theta_n)\\right|.$$\n\nFor each test configuration and mode index set $\\mathcal{M}$, define the relative error for mode $n\\in \\mathcal{M}$ as\n$$\\varepsilon_n = \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}},$$\nand declare the configuration a pass if $\\max_{n\\in\\mathcal{M}} \\varepsilon_n \\le \\mathrm{tol}$.\n\nYour task is to write a complete program that:\n- Implements the second-order and fourth-order discrete second-derivative eigenvalues $\\lambda^{(2)}(\\theta)$ and $\\lambda^{(4)}(\\theta)$.\n- Computes the exact and numerical angular eigenfrequencies for specified modes $n$ using the formulas above, with optional filter strength $\\sigma$.\n- Evaluates pass/fail booleans for a given tolerance by comparing relative errors for all modes in a test set.\n\nPhysical units requirement: interpret $L$ in $\\mathrm{m}$, $c_b$ in $\\mathrm{m^2/s}$, and angular frequencies in $\\mathrm{rad/s}$. However, the program’s final outputs are booleans, which are dimensionless.\n\nTest Suite:\nProvide results for the following parameter sets, covering accuracy order effects, grid resolution impacts, and filter influences. For each case, the mode set is given by a list of positive integers; the maximum relative error over the list is compared to the tolerance.\n\n- Case $1$: $L=1.0$, $c_b=1.0$, $N=63$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=2\\times 10^{-3}$.\n- Case $2$: $L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=1\\times 10^{-2}$.\n- Case $3$: $L=1.0$, $c_b=1.0$, $N=47$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=3\\times 10^{-3}$.\n- Case $4$: $L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.2$, modes $\\mathcal{M}=[10,12,14]$, tolerance $\\mathrm{tol}=7\\times 10^{-2}$.\n- Case $5$: $L=1.0$, $c_b=1.0$, $N=127$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3]$, tolerance $\\mathrm{tol}=1\\times 10^{-3}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as above, for example $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$, where each $\\mathrm{result}_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$. The program must not read any input and must compute these results internally.", "solution": "The problem statement has been meticulously validated and is determined to be sound. It is scientifically grounded in the principles of solid mechanics and numerical analysis, specifically using the Euler–Bernoulli beam equation as a model for flexural waves and analyzing the properties of finite difference schemes. The problem is well-posed, providing all necessary equations, parameters, and a clear objective for each test case. The language is precise and unambiguous. Therefore, a complete solution is provided below.\n\nThe core of this problem lies in comparing the analytical dispersion relation of a continuous physical system with the numerical dispersion relation of its discrete approximation.\n\nThe physical system is a one-dimensional elastic beam whose transverse displacement $u(x,t)$ is governed by the Euler–Bernoulli equation:\n$$\n\\frac{\\partial^2 u}{\\partial t^2} + c_b^2 \\frac{\\partial^4 u}{\\partial x^4} = 0\n$$\nHere, $c_b$ is the flexural wave speed parameter. For simply supported boundary conditions on a domain $x \\in [0, L]$, the solution can be expressed as a superposition of normal modes. The ansatz $u(x,t) = \\phi_n(x) \\cos(\\omega_n t)$ separates the problem into a spatial eigenvalue problem for the mode shapes $\\phi_n(x)$ and their corresponding angular eigenfrequencies $\\omega_n$. The exact mode shapes are given as $\\phi_n(x) = \\sin(k_n x)$ with wavenumbers $k_n = n\\pi/L$ for integer modes $n \\ge 1$. Substituting this into the governing equation yields the exact dispersion relation:\n$$\n\\omega_n^{\\mathrm{exact}} = c_b k_n^2 = c_b \\left(\\frac{n\\pi}{L}\\right)^2\n$$\nThis relation is dispersive, meaning the phase velocity $v_p = \\omega_n/k_n = c_b k_n$ depends on the wavenumber, so waves of different lengths travel at different speeds.\n\nWhen the spatial domain is discretized with $N$ interior points and spacing $h = L/(N+1)$, the continuous derivatives are replaced by finite difference operators. For the simply supported boundary conditions specified, the eigenvectors of the resulting discrete operators are discrete sine functions, $v_j^{(n)} = \\sin(j \\theta_n)$, where $j=1,\\dots,N$ is the grid point index and $\\theta_n = n\\pi/(N+1) = k_n h$ is the dimensionless wavenumber.\n\nThe key step in this analysis is that applying a finite difference operator to a discrete sine eigenvector is equivalent to multiplying the eigenvector by a scalar eigenvalue. This scalar, denoted $\\lambda(\\theta_n)$ for the second-derivative operator, is a function of the dimensionless wavenumber $\\theta_n$. The continuous second derivative operator $\\frac{\\partial^2}{\\partial x^2}$ has eigenvalues $-k_n^2$. The accuracy of a finite difference scheme is determined by how well its eigenvalue $\\lambda(\\theta_n)$ approximates $-k_n^2 = -(\\theta_n/h)^2$.\n\nThe problem specifies two schemes for the second derivative:\n1.  A second-order accurate scheme with eigenvalue $\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2}$.\n2.  A fourth-order accurate scheme with eigenvalue $\\lambda^{(4)}(\\theta) = \\frac{1}{h^2}\\left(-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)\\right)$.\n\nThe problem models the fourth-derivative operator as the square of the second-derivative operator. Consequently, the semi-discrete governing equation leads to a numerical dispersion relation by replacing the analytical $k_n^2$ with its numerical counterpart, which is effectively $-\\lambda(\\theta_n)$. Thus, the numerical frequency is computed as:\n$$\n\\omega_n^{\\mathrm{num}} = c_b \\left|-\\lambda(\\theta_n)\\right| = c_b \\left|\\lambda(\\theta_n)\\right|\n$$\nThe absolute value is used because the provided eigenvalues $\\lambda(\\theta_n)$ are non-positive. The deviation of $\\omega_n^{\\mathrm{num}}$ from $\\omega_n^{\\mathrm{exact}}$ is known as numerical dispersion.\n\nTo control high-frequency numerical artifacts, a spectral filter is introduced. This filter modifies the operator's eigenvalue via multiplication:\n$$\n\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma\\,\\varphi(\\theta)\\right)\\lambda(\\theta)\n$$\nwhere $\\sigma$ is the filter strength and $\\varphi(\\theta) = \\sin^6(\\theta/2)$ is a function that selectively targets high wavenumbers (i.e., $\\theta$ approaching $\\pi$). This added term introduces numerical diffusion, which damps high-frequency components. The filtered numerical frequency is then:\n$$\n\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b \\left|\\lambda_{\\sigma}(\\theta_n)\\right|\n$$\nThe procedure is to evaluate, for each test configuration, the maximum relative error over a specified set of modes $\\mathcal{M}$:\n$$\n\\varepsilon_{\\mathrm{max}} = \\max_{n\\in\\mathcal{M}} \\left( \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}} \\right)\n$$\nThe configuration is declared a \"pass\" ($\\mathrm{True}$) if this maximum error does not exceed a given tolerance $\\mathrm{tol}$, and a \"fail\" ($\\mathrm{False}$) otherwise. The implementation will systematically apply these formulas to each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational benchmark problem for dispersive normal modes.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 63, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 2e-3, \"case_id\": 1\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 1e-2, \"case_id\": 2\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 47, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 3e-3, \"case_id\": 3\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.2,\n            \"modes\": [10, 12, 14], \"tol\": 7e-2, \"case_id\": 4\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 127, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3], \"tol\": 1e-3, \"case_id\": 5\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        cb = case[\"cb\"]\n        N = case[\"N\"]\n        scheme = case[\"scheme\"]\n        sigma = case[\"sigma\"]\n        modes = case[\"modes\"]\n        tol = case[\"tol\"]\n\n        h = L / (N + 1)\n        \n        max_relative_error = 0.0\n\n        for n in modes:\n            # Calculate the exact angular eigenfrequency\n            kn = n * np.pi / L\n            omega_exact = cb * kn**2\n\n            # Calculate the dimensionless wavenumber\n            theta_n = n * np.pi / (N + 1)\n\n            # Calculate the unfiltered discrete second-derivative eigenvalue\n            if scheme == \"second-order\":\n                lambda_theta = (-2.0 + 2.0 * np.cos(theta_n)) / h**2\n            elif scheme == \"fourth-order\":\n                lambda_theta = (\n                    -2.5 + (8.0/3.0) * np.cos(theta_n) - (1.0/6.0) * np.cos(2.0 * theta_n)\n                ) / h**2\n            else:\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n\n            # Apply the filter if sigma is non-zero\n            if sigma > 0:\n                phi_theta = np.sin(theta_n / 2.0)**6\n                lambda_sigma_theta = (1.0 - sigma * phi_theta) * lambda_theta\n            else:\n                lambda_sigma_theta = lambda_theta\n            \n            # Calculate the numerical angular eigenfrequency\n            omega_num = cb * np.abs(lambda_sigma_theta)\n\n            # Calculate the relative error for the current mode\n            relative_error = np.abs(omega_num - omega_exact) / omega_exact\n            \n            if relative_error > max_relative_error:\n                max_relative_error = relative_error\n\n        # Check if the configuration passes the tolerance test\n        pass_fail = max_relative_error = tol\n        results.append(pass_fail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3581957"}, {"introduction": "After learning to analyze and filter numerical errors, the next step is to design schemes that actively cancel them. This practice [@problem_id:3581918] introduces the method of modified equations, a powerful theoretical tool that reveals the partial differential equation a numerical scheme truly solves, including its inherent error terms. By deriving this modified equation, you will determine the precise amount of artificial viscosity needed to counteract the leading-order dispersive error, demonstrating that numerical diffusion can be a constructive tool for enhancing accuracy.", "problem": "Consider the one-dimensional linear constant-coefficient advection-diffusion model with artificial viscosity,\n$$u_{t} + a u_{x} = \\nu \\partial_{x}^{2p} u,$$\non a uniform spatial grid with spacing $\\Delta x$. You will construct a fully discrete scheme using forward Euler time stepping and second-order central differences in space. In order to directly target the leading-order dispersive error that arises from the central difference approximation of the advective derivative, restrict attention to the case $p=1$ so that the artificial viscosity operator is the standard Laplacian. The discrete update is\n$$\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} + a \\frac{u_{j+1}^{n} - u_{j-1}^{n}}{2 \\Delta x} = \\nu \\frac{u_{j+1}^{n} - 2 u_{j}^{n} + u_{j-1}^{n}}{\\Delta x^{2}}.$$\nUsing the method of modified equations, derive the leading-order odd-derivative term that appears in the truncation error of this scheme and determine the value of the artificial viscosity coefficient $\\nu$, as a function of $\\Delta x$ and $a$, that cancels that leading odd-derivative term in the modified equation. Assume a constant Courant number based on the magnitude of the advective speed, $C \\equiv |a|\\Delta t/\\Delta x = 1$, so that $\\Delta t = \\Delta x/|a|$. State any smoothness assumptions you need for Taylor expansions. Express your final result for $\\nu$ in International System of Units (SI) as $\\text{m}^2/\\text{s}$. No numerical rounding is required; provide a closed-form analytic expression.", "solution": "The problem requires us to analyze a fully discrete scheme for the one-dimensional advection-diffusion equation using the method of modified equations. The objective is to determine the value of the artificial viscosity coefficient, $\\nu$, that cancels the leading-order dispersive error. We assume the solution $u(x,t)$ is sufficiently smooth, meaning it possesses continuous partial derivatives up to the orders required for the Taylor series expansions used in this analysis.\n\nThe given fully discrete scheme is:\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} + a \\frac{u_{j+1}^{n} - u_{j-1}^{n}}{2 \\Delta x} = \\nu \\frac{u_{j+1}^{n} - 2 u_{j}^{n} + u_{j-1}^{n}}{(\\Delta x)^{2}}\n$$\nTo derive the modified equation, we perform Taylor series expansions of each term around the point $(x_j, t_n)$, where $u(x_j, t_n)$ is denoted as $u$ and its partial derivatives are denoted with subscripts (e.g., $u_t = \\partial u / \\partial t$, $u_x = \\partial u / \\partial x$).\n\nThe forward Euler time-stepping term is expanded as:\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = \\frac{1}{\\Delta t} \\left( u + \\Delta t u_t + \\frac{(\\Delta t)^2}{2} u_{tt} + \\frac{(\\Delta t)^3}{6} u_{ttt} + \\dots - u \\right) = u_t + \\frac{\\Delta t}{2} u_{tt} + \\frac{(\\Delta t)^2}{6} u_{ttt} + O((\\Delta t)^3)\n$$\nThe second-order central difference for the advection term is expanded as:\n\\begin{align*}\nu_{j+1}^{n} = u + \\Delta x u_x + \\frac{(\\Delta x)^2}{2} u_{xx} + \\frac{(\\Delta x)^3}{6} u_{xxx} + \\frac{(\\Delta x)^4}{24} u_{xxxx} + \\dots \\\\\nu_{j-1}^{n} = u - \\Delta x u_x + \\frac{(\\Delta x)^2}{2} u_{xx} - \\frac{(\\Delta x)^3}{6} u_{xxx} + \\frac{(\\Delta x)^4}{24} u_{xxxx} - \\dots\n\\end{align*}\nSubtracting these gives:\n$$\n\\frac{u_{j+1}^{n} - u_{j-1}^{n}}{2 \\Delta x} = \\frac{1}{2 \\Delta x} \\left( 2\\Delta x u_x + \\frac{2(\\Delta x)^3}{6} u_{xxx} + O((\\Delta x)^5) \\right) = u_x + \\frac{(\\Delta x)^2}{6} u_{xxx} + O((\\Delta x)^4)\n$$\nThe second-order central difference for the diffusion term is expanded as:\n$$\n\\frac{u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}}{(\\Delta x)^2} = \\frac{1}{(\\Delta x)^2} \\left( (\\Delta x)^2 u_{xx} + \\frac{2(\\Delta x)^4}{24} u_{xxxx} + O((\\Delta x)^6) \\right) = u_{xx} + \\frac{(\\Delta x)^2}{12} u_{xxxx} + O((\\Delta x)^4)\n$$\nThe problem specifies \"artificial viscosity\", which implies the scheme approximates the pure advection equation $u_t + a u_x = 0$. The truncation error, $\\tau$, is the residual when the exact solution to the target PDE is substituted into the finite difference equation.\n$$\n\\tau = \\left(u_t + \\frac{\\Delta t}{2}u_{tt} + \\dots\\right) + a\\left(u_x + \\frac{(\\Delta x)^2}{6}u_{xxx} + \\dots\\right) - \\nu\\left(u_{xx} + \\frac{(\\Delta x)^2}{12}u_{xxxx} + \\dots\\right) - (u_t + a u_x)\n$$\n$$\n\\tau = \\frac{\\Delta t}{2}u_{tt} - \\nu u_{xx} + a \\frac{(\\Delta x)^2}{6} u_{xxx} + \\text{higher-order terms}\n$$\nThe leading-order odd-derivative term that appears in the truncation error is therefore $a \\frac{(\\Delta x)^2}{6} u_{xxx}$. This term is responsible for numerical dispersion.\n\nThe modified equation is the partial differential equation that the numerical scheme effectively solves. We obtain it by setting the discrete equation (and thus the expansions) to zero:\n$$\n\\left( u_t + \\frac{\\Delta t}{2} u_{tt} + \\dots \\right) + a \\left( u_x + \\frac{(\\Delta x)^2}{6} u_{xxx} + \\dots \\right) - \\nu \\left( u_{xx} + \\frac{(\\Delta x)^2}{12} u_{xxxx} + \\dots \\right) = 0\n$$\nRearranging this gives:\n$$\nu_t + a u_x = \\nu u_{xx} - \\frac{\\Delta t}{2} u_{tt} - a \\frac{(\\Delta x)^2}{6} u_{xxx} + \\text{higher-order terms}\n$$\nTo proceed, we express time derivatives in terms of spatial derivatives using the modified equation itself. To leading order, $u_t \\approx -a u_x + \\nu u_{xx}$. Differentiating with respect to time gives:\n$$\nu_{tt} = \\frac{\\partial}{\\partial t} u_t \\approx \\frac{\\partial}{\\partial t} (-a u_x + \\nu u_{xx}) = -a u_{xt} + \\nu u_{xxt}\n$$\nNow we find the mixed derivatives:\n$$\nu_{xt} = \\frac{\\partial}{\\partial x} u_t \\approx \\frac{\\partial}{\\partial x} (-a u_x + \\nu u_{xx}) = -a u_{xx} + \\nu u_{xxx}\n$$\nTherefore:\n$$\nu_{tt} \\approx -a (-a u_{xx} + \\nu u_{xxx}) + \\nu \\frac{\\partial}{\\partial x}(-a u_{xx} + \\nu u_{xxx}) = a^2 u_{xx} - 2a\\nu u_{xxx} + O((\\Delta x)^2)\n$$\nSubstituting this expression for $u_{tt}$ back into the modified equation:\n$$\nu_t + a u_x = \\nu u_{xx} - \\frac{\\Delta t}{2} \\left( a^2 u_{xx} - 2a\\nu u_{xxx} + \\dots \\right) - a \\frac{(\\Delta x)^2}{6} u_{xxx} + \\dots\n$$\nWe collect terms based on the order of the spatial derivative:\n$$\nu_t + a u_x = \\left(\\nu - \\frac{a^2 \\Delta t}{2}\\right) u_{xx} + \\left(a\\nu \\Delta t - a \\frac{(\\Delta x)^2}{6}\\right) u_{xxx} + \\dots\n$$\nThe leading odd-derivative term in the modified equation is $\\left(a\\nu \\Delta t - a \\frac{(\\Delta x)^2}{6}\\right) u_{xxx}$. To cancel this dispersive term, we must set its coefficient to zero:\n$$\na\\nu \\Delta t - a \\frac{(\\Delta x)^2}{6} = 0\n$$\nAssuming $a \\neq 0$, we can divide by $a$:\n$$\n\\nu \\Delta t = \\frac{(\\Delta x)^2}{6} \\implies \\nu = \\frac{(\\Delta x)^2}{6 \\Delta t}\n$$\nThe problem specifies a constant Courant number $C = |a|\\frac{\\Delta t}{\\Delta x} = 1$. From this, we find an expression for $\\Delta t$:\n$$\n\\Delta t = \\frac{\\Delta x}{|a|}\n$$\nSubstituting this into our equation for $\\nu$:\n$$\n\\nu = \\frac{(\\Delta x)^2}{6 \\left( \\frac{\\Delta x}{|a|} \\right)} = \\frac{|a| (\\Delta x)^2}{6 \\Delta x} = \\frac{|a| \\Delta x}{6}\n$$\nThe units of $a$ are $\\text{m/s}$ and the units of $\\Delta x$ are $\\text{m}$, so the units of $\\nu$ are $(\\text{m/s})\\cdot\\text{m} = \\text{m}^2/\\text{s}$, which is consistent with a diffusion coefficient.\nThis value of $\\nu$ represents the amount of artificial viscosity required to cancel the leading-order numerical dispersion from the central-differenced advection term when using a forward Euler time step with $C=1$.", "answer": "$$\\boxed{\\frac{|a|\\Delta x}{6}}$$", "id": "3581918"}]}