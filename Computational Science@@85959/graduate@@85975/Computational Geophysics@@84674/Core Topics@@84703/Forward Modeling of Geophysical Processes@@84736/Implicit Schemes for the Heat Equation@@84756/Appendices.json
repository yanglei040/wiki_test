{"hands_on_practices": [{"introduction": "Before using a numerical model for scientific discovery, we must first build confidence that it is correctly implemented. This practice introduces the Method of Manufactured Solutions (MMS), a powerful and rigorous technique for code verification. By postulating an analytical solution to the heat equation, you will derive a corresponding source term and use this setup to empirically measure the convergence rates of your code, confirming that your Backward Euler and Crank-Nicolson implementations achieve their theoretical orders of accuracy [@problem_id:3604151]. This process is a cornerstone of responsible computational science.", "problem": "Consider the one-dimensional heat conduction equation in a homogeneous medium with thermal diffusivity $\\kappa$ on a spatial domain $x \\in [0,1]$ and time interval $t \\in [0,T]$,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t),\n$$\nsubject to Dirichlet boundary conditions and an initial condition chosen by the method of manufactured solutions. Define the manufactured solution\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\nand derive the forcing term $f(x,t)$ so that $u_{\\mathrm{exact}}(x,t)$ satisfies the heat equation exactly for a given $\\kappa$. Impose Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$ for all $t$, and initial condition $u(x,0) = u_{\\mathrm{exact}}(x,0)$.\n\nYour task is to implement two implicit time-stepping schemes for the spatially discretized problem using second-order centered finite differences in space:\n- Backward Euler (first-order accurate in time).\n- Crank–Nicolson (second-order accurate in time).\n\nUse a uniform grid with $N$ interior points, grid spacing $h = \\frac{1}{N+1}$, and times $t_n = n \\Delta t$, $n=0,1,\\dots,\\lfloor T/\\Delta t \\rfloor$. Assemble the standard second-derivative matrix consistent with the centered finite difference approximation of $\\frac{\\partial^2 u}{\\partial x^2}$ under homogeneous Dirichlet boundary conditions. At each time step, enforce the forcing term and boundary conditions consistently with the manufactured solution.\n\nDefine the discrete $\\ell^2$-norm error at final time $T$ by\n$$\nE(h,\\Delta t;\\kappa,\\text{scheme}) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right)^2 \\right)^{1/2},\n$$\nwhere $x_i = i h$ and $u_i^{\\text{num}}(T)$ is the numerical approximation at $x_i$ and time $T$.\n\nEmpirical convergence rates are defined by\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)},\\quad\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)},\n$$\nfor fixed $h$ when refining $\\Delta t$, and fixed $\\Delta t$ when refining $h$, respectively.\n\nImplement the schemes and compute empirical convergence rates for the following test suite. All quantities are dimensionless; report all numerical results as dimensionless floats.\n\nTest suite:\n1. Backward Euler time refinement (“happy path”): $\\kappa = 0.35$, $T = 0.2$, $N = 1000$ (so $h = \\frac{1}{1001}$ fixed), $\\Delta t_1 = 0.1$, $\\Delta t_2 = 0.05$. Compute $p_{\\Delta t}$ for Backward Euler.\n2. Backward Euler space refinement (“happy path”): $\\kappa = 0.35$, $T = 0.2$, $\\Delta t = 5\\times 10^{-5}$ fixed, $N_1 = 50$, $N_2 = 100$ (so $h_1 = \\frac{1}{51}$, $h_2 = \\frac{1}{101}$). Compute $p_{h}$ for Backward Euler.\n3. Crank–Nicolson time refinement (“happy path”): $\\kappa = 0.35$, $T = 0.2$, $N = 1000$ fixed, $\\Delta t_1 = 0.1$, $\\Delta t_2 = 0.05$. Compute $p_{\\Delta t}$ for Crank–Nicolson.\n4. Backward Euler space refinement under contaminated regime (“edge case”): $\\kappa = 0.35$, $T = 0.2$, $\\Delta t = 0.05$ fixed (time error not negligible), $N_1 = 20$, $N_2 = 40$. Compute $p_{h}$ for Backward Euler and observe deviation from the expected spatial order.\n5. Backward Euler time refinement under strong diffusion (“edge case”): $\\kappa = 5.0$, $T = 0.2$, $N = 1000$ fixed, $\\Delta t_1 = 0.1$, $\\Delta t_2 = 0.05$. Compute $p_{\\Delta t}$ for Backward Euler to assess robustness of the time order under increased stiffness.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the five test cases described above. For example: “[result1,result2,result3,result4,result5]”.", "solution": "The problem requires the implementation and verification of implicit finite difference schemes for the one-dimensional heat equation using the method of manufactured solutions.\n\n**1. Problem Formulation and Forcing Term Derivation**\n\nThe governing partial differential equation (PDE) is the heat equation with a source term $f(x,t)$:\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t)\n$$\non the spatial domain $x \\in [0,1]$ and time interval $t \\in [0,T]$. The thermal diffusivity is denoted by $\\kappa$.\n\nTo verify the numerical schemes, we use the method of manufactured solutions. We postulate an exact solution and substitute it into the PDE to derive the corresponding forcing term $f(x,t)$. The chosen manufactured solution is:\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\nWe compute the partial derivatives of $u_{\\mathrm{exact}}(x,t)$:\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} = -e^{-t}\\sin(\\pi x)\n$$\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} = \\pi e^{-t}\\cos(\\pi x) \\implies \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -\\pi^2 e^{-t}\\sin(\\pi x)\n$$\nSubstituting these into the heat equation, we solve for $f(x,t)$:\n$$\nf(x,t) = \\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} - \\kappa \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -e^{-t}\\sin(\\pi x) - \\kappa(-\\pi^2 e^{-t}\\sin(\\pi x))\n$$\n$$\nf(x,t) = (\\kappa \\pi^2 - 1)e^{-t}\\sin(\\pi x)\n$$\nThe boundary and initial conditions are derived from $u_{\\mathrm{exact}}(x,t)$:\n-   Initial Condition ($t=0$): $u(x,0) = u_{\\mathrm{exact}}(x,0) = e^{-0}\\sin(\\pi x) = \\sin(\\pi x)$.\n-   Boundary Conditions ($x=0, x=1$):\n    -   $u(0,t) = u_{\\mathrm{exact}}(0,t) = e^{-t}\\sin(0) = 0$.\n    -   $u(1,t) = u_{\\mathrm{exact}}(1,t) = e^{-t}\\sin(\\pi) = 0$.\nThese are homogeneous Dirichlet boundary conditions, as specified.\n\n**2. Numerical Discretization**\n\nWe discretize the problem on a uniform grid. The spatial domain $[0,1]$ is divided into $N+1$ subintervals of width $h = \\frac{1}{N+1}$, yielding $N$ interior grid points $x_i = i h$ for $i=1, 2, \\dots, N$. The time domain is discretized into steps of size $\\Delta t$, with $t_n = n \\Delta t$.\n\n**2.1. Spatial Discretization**\n\nThe second spatial derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated at each interior grid point $x_i$ using a second-order accurate centered finite difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\nLet $\\mathbf{u}(t)$ be the vector of approximate solutions at the interior grid points, $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$, where $u_i(t) \\approx u(x_i, t)$. Applying the discretization to the PDE results in a system of $N$ coupled ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{h^2} A \\mathbf{u}(t) + \\mathbf{f}(t)\n$$\nHere, $\\mathbf{f}(t) = [f(x_1,t), f(x_2,t), \\dots, f(x_N,t)]^T$ is the vector of the forcing term evaluated at the grid points. The matrix $A$ is the $N \\times N$ tridiagonal matrix representing the discrete Laplacian with homogeneous Dirichlet boundary conditions:\n$$\nA = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1 \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n\n**2.2. Temporal Discretization**\n\nLet $\\mathbf{u}^n$ be the numerical solution vector at time $t_n$.\n\n**Backward Euler (BE):** This is a first-order accurate implicit scheme. The time derivative is approximated by a backward difference, and the right-hand side is evaluated at the future time step $t_{n+1}$:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\n$$\nRearranging to solve for the unknown vector $\\mathbf{u}^{n+1}$, we obtain a linear system:\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{h^2} A\\right) \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{f}^{n+1}\n$$\nwhere $I$ is the $N \\times N$ identity matrix. The matrix on the left-hand side is tridiagonal, symmetric, and positive definite, allowing for efficient solution using a banded linear solver.\n\n**Crank–Nicolson (CN):** This is a second-order accurate implicit scheme that averages the right-hand side evaluation at times $t_n$ and $t_{n+1}$:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\\right) + \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n} + \\mathbf{f}^{n}\\right)\n$$\nGrouping terms with $\\mathbf{u}^{n+1}$ on the left and known terms on the right yields the linear system:\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n} + \\frac{\\Delta t}{2}(\\mathbf{f}^{n+1} + \\mathbf{f}^n)\n$$\nSimilar to the BE scheme, the matrix on the left-hand side is tridiagonal, and the system can be solved efficiently at each time step.\n\n**3. Error Analysis and Algorithmic Procedure**\n\nThe total discretization error for BE is expected to be $O(\\Delta t, h^2)$ and for CN is $O(\\Delta t^2, h^2)$. We quantify the error using the discrete $\\ell^2$-norm at the final simulation time $T^* = \\lfloor T/\\Delta t \\rfloor \\Delta t$:\n$$\nE(h,\\Delta t) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T^*) - u_{\\mathrm{exact}}(x_i,T^*) \\right)^2 \\right)^{1/2}\n$$\nThe empirical convergence rates are computed to verify the theoretical orders of accuracy. For time refinement with fixed $h$ and two time steps $\\Delta t_1, \\Delta t_2$:\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)}\n$$\nFor space refinement with fixed $\\Delta t$ and two grid spacings $h_1, h_2$:\n$$\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)}\n$$\nThe algorithm proceeds as follows:\n1.  Initialize parameters: $\\kappa$, $T$, $N$, $\\Delta t$.\n2.  Set up the spatial grid ($h, x_i$) and the initial solution $\\mathbf{u}^0 = \\sin(\\pi \\mathbf{x})$.\n3.  Construct the system matrix for the chosen scheme (BE or CN). Since this matrix is constant for all time steps, it is assembled only once.\n4.  Iterate from $n=0$ to $N_t-1$, where $N_t = \\lfloor T/\\Delta t \\rfloor$:\n    a. Assemble the right-hand side vector, which depends on the solution at the previous time step, $\\mathbf{u}^n$, and the forcing term $\\mathbf{f}$.\n    b. Solve the resulting tridiagonal linear system for $\\mathbf{u}^{n+1}$.\n5.  After the loop, compute the final error $E$ by comparing the numerical solution $\\mathbf{u}^{N_t}$ with the exact solution $u_{\\mathrm{exact}}(x_i, T^*)$.\n6.  Use the computed errors from different runs to calculate the empirical convergence rates $p_{\\Delta t}$ or $p_h$ for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def exact_solution(x, t):\n        \"\"\"Computes the exact manufactured solution.\"\"\"\n        return np.exp(-t) * np.sin(np.pi * x)\n\n    def forcing_term(x, t, kappa):\n        \"\"\"Computes the forcing term for the manufactured solution.\"\"\"\n        return (kappa * np.pi**2 - 1.0) * np.exp(-t) * np.sin(np.pi * x)\n\n    def run_simulation(scheme, kappa, T, N, dt):\n        \"\"\"\n        Runs a single simulation of the 1D heat equation.\n\n        Args:\n            scheme (str): 'BE' for Backward Euler or 'CN' for Crank-Nicolson.\n            kappa (float): Thermal diffusivity.\n            T (float): Final time.\n            N (int): Number of interior spatial grid points.\n            dt (float): Time step size.\n\n        Returns:\n            float: The discrete l2-norm of the error at the final time.\n        \"\"\"\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N, dtype=np.float64)\n        \n        num_steps = int(np.floor(T / dt))\n        if num_steps == 0:\n            # If dt is larger than T, no steps are taken. The error is then computed\n            # at t=0, which is zero. This case may arise with large dt values.\n            return 0.0\n            \n        final_time = num_steps * dt\n\n        # Initial condition\n        u = exact_solution(x, 0.0)\n\n        if scheme == 'BE':\n            # System: (I - alpha * A) u_n+1 = u_n + dt * f_n+1\n            alpha = dt * kappa / h**2\n            # LHS matrix for solve_banded, shape (3, N) for (l=1, u=1)\n            M_diags = np.zeros((3, N), dtype=np.float64)\n            M_diags[0, 1:] = -alpha      # Super-diagonal\n            M_diags[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n            M_diags[2, :-1] = -alpha     # Sub-diagonal\n            \n            for n in range(num_steps):\n                t_next = (n + 1) * dt\n                f_next = forcing_term(x, t_next, kappa)\n                rhs = u + dt * f_next\n                # solve_banded solves A*x=b, where A is given by 'M_diags'\n                u = solve_banded((1, 1), M_diags, rhs)\n                \n        elif scheme == 'CN':\n            # System: (I - alpha * A) u_n+1 = (I + alpha * A) u_n + dt/2 * (f_n+1 + f_n)\n            # where alpha = dt * kappa / (2 * h^2)\n            alpha = dt * kappa / (2.0 * h**2)\n            \n            # LHS matrix M_CN\n            M_CN_diags = np.zeros((3, N), dtype=np.float64)\n            M_CN_diags[0, 1:] = -alpha\n            M_CN_diags[1, :] = 1.0 + 2.0 * alpha\n            M_CN_diags[2, :-1] = -alpha\n            \n            # Function to apply the RHS matrix N_CN = (I + alpha * A)\n            def apply_N_CN(vec):\n                res = (1.0 - 2.0 * alpha) * vec\n                res[1:] += alpha * vec[:-1]\n                res[:-1] += alpha * vec[1:]\n                return res\n\n            for n in range(num_steps):\n                t_curr = n * dt\n                t_next = (n + 1) * dt\n                \n                f_curr = forcing_term(x, t_curr, kappa)\n                f_next = forcing_term(x, t_next, kappa)\n                \n                rhs_u_part = apply_N_CN(u)\n                rhs_f_part = dt / 2.0 * (f_curr + f_next)\n                \n                rhs = rhs_u_part + rhs_f_part\n                u = solve_banded((1, 1), M_CN_diags, rhs)\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n        u_exact_final = exact_solution(x, final_time)\n        \n        # Calculate discrete l2-norm of the error\n        error = np.sqrt(h * np.sum((u - u_exact_final)**2))\n        \n        return error\n\n    def compute_p_dt(err1, err2, dt1, dt2):\n        \"\"\"Computes temporal convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(dt1 / dt2)\n\n    def compute_p_h(err1, err2, h1, h2):\n        \"\"\"Computes spatial convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    test_cases = [\n        # 1. BE time refinement\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 2. BE space refinement\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 5e-5, 'N1': 50, 'N2': 100},\n        # 3. CN time refinement\n        {'type': 'p_dt', 'scheme': 'CN', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 4. BE space refinement (contaminated)\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 0.05, 'N1': 20, 'N2': 40},\n        # 5. BE time refinement (stiff)\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 5.0, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'p_dt':\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt1'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt2'])\n            rate = compute_p_dt(err1, err2, case['dt1'], case['dt2'])\n            results.append(rate)\n        elif case['type'] == 'p_h':\n            h1 = 1.0 / (case['N1'] + 1)\n            h2 = 1.0 / (case['N2'] + 1)\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N1'], case['dt'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N2'], case['dt'])\n            rate = compute_p_h(err1, err2, h1, h2)\n            results.append(rate)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3604151"}, {"introduction": "Different numerical schemes can have profoundly different effects on the solutions they produce, particularly in how they handle various frequency components. This exercise shifts our focus from code verification to scheme analysis, concentrating on the property of numerical dissipation. You will implement and compare the Backward Euler and Crank-Nicolson schemes to quantify, both theoretically and empirically, how they damp solution modes [@problem_id:3604206]. Understanding this behavior is critical for selecting a scheme that either preserves or selectively removes high-frequency content, a common requirement in long-term geophysical simulations.", "problem": "Consider the one-dimensional heat conduction Partial Differential Equation (PDE) with constant thermal diffusivity $\\kappa$ on a finite domain with homogeneous Dirichlet boundary conditions. The governing law is $u_t=\\kappa u_{xx}$ on $x\\in[0,L]$, with boundary conditions $u(0,t)=0$ and $u(L,t)=0$, and an initial condition $u(x,0)$ that is a single sine mode. Using a uniform spatial mesh and the Finite Difference Method (FDM) for the second derivative, construct the discrete Laplacian with homogeneous Dirichlet boundary conditions. Implement one implicit time step using both Crank–Nicolson (CN) and Backward Euler (BE), where Crank–Nicolson (CN) and Backward Euler (BE) are standard implicit time-integration schemes for parabolic PDEs.\n\nStarting from the fundamental PDE and boundary conditions, and employing the discrete Laplacian derived from second-order centered differences, quantify the numerical dissipation of each scheme for a single time step by using the discrete sine mode that is an eigenvector of the discrete Laplacian. The numerical dissipation for a single step is defined here as the ratio of the discrete $\\ell^2$ norm after the step to the discrete $\\ell^2$ norm before the step, that is, $\\|u^{n+1}\\|_2 / \\|u^n\\|_2$, which is dimensionless. For the discrete eigenmode of index $m$, $\\|u^n\\|_2$ denotes the Euclidean norm of the vector of interior-node values at time level $n$. Because the initial condition is chosen as a discrete Laplacian eigenvector (a sine mode compatible with homogeneous Dirichlet boundaries), the shape of the solution remains proportional to that mode under linear implicit stepping, and this norm ratio equals the magnitude of the per-step amplification factor.\n\nYour program must:\n- Build the one-dimensional discrete Laplacian matrix corresponding to second-order centered differences on $N$ interior points with homogeneous Dirichlet boundary conditions, spacing $\\Delta x = L/(N+1)$.\n- Initialize the interior values to the discrete sine mode $u_j^0=\\sin\\!\\left(\\frac{m\\pi j}{N+1}\\right)$ for $j=1,2,\\dots,N$, which corresponds to a sine mode on $[0,L]$ with wave number $\\frac{m\\pi}{L}$.\n- Perform one BE step and one CN step with time step $\\Delta t$ and compute the empirical dissipation factors as $g_{\\mathrm{BE,emp}}=\\|u^{1}_{\\mathrm{BE}}\\|_2/\\|u^{0}\\|_2$ and $g_{\\mathrm{CN,emp}}=\\|u^{1}_{\\mathrm{CN}}\\|_2/\\|u^{0}\\|_2$.\n- Compute the theoretical dissipation factors for the discrete mode by eigenvalue analysis of the discrete Laplacian, obtaining $g_{\\mathrm{BE,th}}$ and $g_{\\mathrm{CN,th}}$ in terms of the discrete eigenvalue for mode $m$ and the parameters $\\kappa$, $\\Delta t$, and $L$. Do not use any shortcut formulas given in the problem statement; derive the expressions from first principles of the method and the eigenstructure of the discrete Laplacian.\n\nReport, for each test case, the list of four floats $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$.\n\nUse the following scientifically consistent test suite to ensure coverage of different regimes:\n1. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=1$.\n2. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=63$.\n3. $L=1$, $N=63$, $\\kappa=0.5$, $\\Delta t=10^{-6}$, $m=32$.\n4. $L=1$, $N=3$, $\\kappa=1$, $\\Delta t=0.1$, $m=1$.\n5. $L=2$, $N=63$, $\\kappa=2$, $\\Delta t=0.5$, $m=22$.\n\nAll quantities are dimensionless, so no physical unit conversions are required. Angles appearing inside trigonometric functions are to be interpreted in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list in the order $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$, for example, $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$ with $a_i$, $b_i$, $c_i$, $d_i$ being floats for the $i$-th test case.", "solution": "The user wants me to solve a problem related to numerical methods for the heat equation.\n\nHere's my plan:\n1.  **Validate the problem statement.**\n    *   Extract all given information verbatim.\n    *   Check for scientific soundness, well-posedness, objectivity, completeness, and other validity criteria. The problem seems to be a standard numerical analysis task, so it's likely valid. It deals with the one-dimensional heat equation, FDMs, Crank-Nicolson, Backward Euler, and eigenvalue analysis of the discrete operator. These are all well-established concepts in computational science and engineering.\n    *   The parameters and test cases look reasonable.\n    *   I need to derive the theoretical amplification factors from first principles, which is a key part of the task.\n\n2.  **If the problem is valid, proceed with the solution.**\n    *   **Derivation of Theoretical Dissipation Factors:**\n        *   Start with the continuous PDE: $u_t = \\kappa u_{xx}$.\n        *   Discretize in space. The domain is $x \\in [0, L]$. Let there be $N$ interior points $x_j = j \\Delta x$ for $j=1, \\dots, N$, where $\\Delta x = L/(N+1)$. The boundary points are $x_0 = 0$ and $x_{N+1} = L$.\n        *   The second-order centered difference approximation for the second spatial derivative at an interior point $x_j$ is:\n            $$ u_{xx}(x_j, t) \\approx \\frac{u(x_{j-1}, t) - 2u(x_j, t) + u(x_{j+1}, t)}{(\\Delta x)^2} $$\n        *   Let $u_j(t) \\approx u(x_j, t)$. The semi-discretized system of ODEs for the vector $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$ is:\n            $$ \\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{(\\Delta x)^2} A \\mathbf{u} $$\n            where $A$ is the $N \\times N$ discrete Laplacian matrix. For homogeneous Dirichlet boundary conditions ($u_0=0, u_{N+1}=0$), the matrix $A$ is a tridiagonal matrix:\n            $$ A = \\begin{pmatrix}\n            -2  1  0  \\dots  0 \\\\\n            1  -2  1  \\dots  0 \\\\\n            0  1  -2  \\dots  0 \\\\\n            \\vdots  \\vdots  \\ddots  \\ddots  \\vdots \\\\\n            0  0  \\dots  1  -2\n            \\end{pmatrix} $$\n        *   The problem statement specifies that the initial condition is a discrete sine mode, which is an eigenvector of the discrete Laplacian. Let's verify this. The eigenvectors $\\mathbf{v}^{(m)}$ and eigenvalues $\\lambda_m$ of matrix $A$ are well-known:\n            *   The $j$-th component of the $m$-th eigenvector is $v_j^{(m)} = \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$ for $j=1, \\dots, N$ and $m=1, \\dots, N$.\n            *   The corresponding eigenvalue is $\\lambda_m = -4 \\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$.\n            *   Let's double-check the eigenvalue.\n                *   $(A \\mathbf{v}^{(m)})_j = v_{j-1}^{(m)} - 2v_j^{(m)} + v_{j+1}^{(m)}$\n                *   $= \\sin\\left(\\frac{m \\pi (j-1)}{N+1}\\right) - 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right) + \\sin\\left(\\frac{m \\pi (j+1)}{N+1}\\right)$\n                *   Using the identity $\\sin(a-b) + \\sin(a+b) = 2\\sin(a)\\cos(b)$, where $a = \\frac{m \\pi j}{N+1}$ and $b = \\frac{m \\pi}{N+1}$:\n                *   $= 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right)\\cos\\left(\\frac{m \\pi}{N+1}\\right) - 2\\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= \\left(2\\cos\\left(\\frac{m \\pi}{N+1}\\right) - 2\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   Using the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n                *   $= -2 \\left(1 - \\cos\\left(\\frac{m \\pi}{N+1}\\right)\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= -2 \\left(2\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)\\right) \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$\n                *   $= -4\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right) v_j^{(m)}$\n            *   So, $\\lambda_m = -4\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$. This is correct.\n\n        *   Now, let's look at the time integration schemes. The semi-discrete system is $\\frac{d\\mathbf{u}}{dt} = M \\mathbf{u}$, where $M = \\frac{\\kappa}{(\\Delta x)^2} A$.\n        *   The eigenvalues of $M$ are $\\mu_m = \\frac{\\kappa}{(\\Delta x)^2} \\lambda_m = -\\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$.\n\n        *   **Backward Euler (BE):**\n            *   The scheme is $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = M \\mathbf{u}^{n+1}$.\n            *   Rearranging: $(I - \\Delta t M) \\mathbf{u}^{n+1} = \\mathbf{u}^n$.\n            *   So, $\\mathbf{u}^{n+1} = (I - \\Delta t M)^{-1} \\mathbf{u}^n$.\n            *   The \"amplification matrix\" is $G_{BE} = (I - \\Delta t M)^{-1}$.\n            *   If the initial condition $\\mathbf{u}^0$ is an eigenvector $\\mathbf{v}^{(m)}$ of $M$ with eigenvalue $\\mu_m$, then $\\mathbf{u}^1 = g_{BE}(\\mu_m) \\mathbf{u}^0$.\n            *   The amplification factor for this mode is the corresponding eigenvalue of $G_{BE}$.\n            *   The eigenvalues of $G_{BE}$ are $(1 - \\Delta t \\mu_m)^{-1}$.\n            *   So, the theoretical dissipation factor $g_{\\mathrm{BE,th}}$ is the magnitude of this eigenvalue:\n                $$ g_{\\mathrm{BE,th}} = |(1 - \\Delta t \\mu_m)^{-1}| = \\left| \\frac{1}{1 - \\Delta t \\mu_m} \\right| $$\n            *   Since $\\mu_m$ is real and negative, the denominator is $1 - \\Delta t \\mu_m  1$.\n                $$ g_{\\mathrm{BE,th}} = \\frac{1}{1 - \\Delta t \\mu_m} = \\frac{1}{1 + \\Delta t \\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)} $$\n\n        *   **Crank-Nicolson (CN):**\n            *   The scheme is $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} M (\\mathbf{u}^{n+1} + \\mathbf{u}^n)$.\n            *   Rearranging: $(I - \\frac{\\Delta t}{2} M) \\mathbf{u}^{n+1} = (I + \\frac{\\Delta t}{2} M) \\mathbf{u}^n$.\n            *   So, $\\mathbf{u}^{n+1} = (I - \\frac{\\Delta t}{2} M)^{-1} (I + \\frac{\\Delta t}{2} M) \\mathbf{u}^n$.\n            *   The amplification matrix is $G_{CN} = (I - \\frac{\\Delta t}{2} M)^{-1} (I + \\frac{\\Delta t}{2} M)$.\n            *   The eigenvalues of $G_{CN}$ are $\\frac{1 + \\frac{\\Delta t}{2} \\mu_m}{1 - \\frac{\\Delta t}{2} \\mu_m}$.\n            *   The theoretical dissipation factor $g_{\\mathrm{CN,th}}$ is the magnitude of this eigenvalue:\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 + \\frac{\\Delta t}{2} \\mu_m}{1 - \\frac{\\Delta t}{2} \\mu_m} \\right| $$\n            *   Since $\\mu_m$ is real and negative, the numerator is $1 + \\frac{\\Delta t}{2} \\mu_m$ and the denominator is $1 - \\frac{\\Delta t}{2} \\mu_m$.\n            *   The value is real. The dissipation factor is the magnitude of this amplification factor.\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 - \\frac{\\Delta t}{2} |\\mu_m|}{1 + \\frac{\\Delta t}{2} |\\mu_m|} \\right| = \\left| \\frac{1 - \\frac{2\\kappa \\Delta t}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)}{1 + \\frac{2\\kappa \\Delta t}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)} \\right| $$\n            \n        *   The problem defines numerical dissipation as the ratio of discrete $\\ell^2$ norms, $\\|u^{n+1}\\|_2 / \\|u^n\\|_2$. Since the initial condition $\\mathbf{u}^n$ is an eigenvector, the subsequent solution $\\mathbf{u}^{n+1}$ is simply a scalar multiple of it, i.e., $\\mathbf{u}^{n+1} = g \\mathbf{u}^n$, where $g$ is the scalar amplification factor.\n        *   Thus, $\\|\\mathbf{u}^{n+1}\\|_2 = \\|g \\mathbf{u}^n\\|_2 = |g| \\|\\mathbf{u}^n\\|_2$.\n        *   The norm ratio is $\\|\\mathbf{u}^{n+1}\\|_2 / \\|\\mathbf{u}^n\\|_2 = |g|$. This validates that the theoretical dissipation factors are indeed the magnitudes of the amplification factors derived above.\n\n3.  **Implementation Details:**\n    *   For each test case with parameters $(L, N, \\kappa, \\Delta t, m)$:\n        *   Calculate $\\Delta x = L/(N+1)$.\n        *   **Theoretical Calculation:**\n            *   Calculate the eigenvalue of the scaled discrete Laplacian operator $M$:\n                $$ \\mu_m = -\\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right) $$\n            *   Calculate $g_{\\mathrm{BE,th}}$:\n                $$ g_{\\mathrm{BE,th}} = \\frac{1}{1 - \\Delta t \\mu_m} $$\n            *   Calculate $g_{\\mathrm{CN,th}}$:\n                $$ g_{\\mathrm{CN,th}} = \\left| \\frac{1 + \\Delta t \\mu_m / 2}{1 - \\Delta t \\mu_m / 2} \\right| $$\n        *   **Empirical Calculation:**\n            *   Create the initial condition vector $\\mathbf{u}^0$:\n                $$ u_j^0 = \\sin\\left(\\frac{m \\pi j}{N+1}\\right) \\quad \\text{for } j=1, \\dots, N $$\n            *   Calculate the initial norm $\\|\\mathbf{u}^0\\|_2$.\n            *   **Backward Euler Step:**\n                *   Set up and solve the linear system $(I - \\frac{\\kappa \\Delta t}{(\\Delta x)^2} A) \\mathbf{u}^1_{BE} = \\mathbf{u}^0$ for $\\mathbf{u}^1_{BE}$.\n            *   Calculate $\\|\\mathbf{u}^1_{BE}\\|_2$.\n            *   Compute $g_{\\mathrm{BE,emp}} = \\|\\mathbf{u}^1_{BE}\\|_2 / \\|\\mathbf{u}^0\\|_2$.\n            *   **Crank-Nicolson Step:**\n                *   First, calculate the right-hand side vector $\\mathbf{rhs} = (I + \\frac{\\kappa \\Delta t}{2(\\Delta x)^2} A) \\mathbf{u}^0$.\n                *   Then, solve the linear system $(I - \\frac{\\kappa \\Delta t}{2(\\Delta x)^2} A) \\mathbf{u}^1_{CN} = \\mathbf{rhs}$ for $\\mathbf{u}^1_{CN}$.\n            *   Calculate $\\|\\mathbf{u}^1_{CN}\\|_2$.\n            *   Compute $g_{\\mathrm{CN,emp}} = \\|\\mathbf{u}^1_{CN}\\|_2 / \\|\\mathbf{u}^0\\|_2$.\n\nThis procedure provides the four required quantities for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes theoretical and empirical numerical dissipation factors for Backward Euler\n    and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, kappa, dt, m)\n        (1.0, 63, 1.0, 0.01, 1),\n        (1.0, 63, 1.0, 0.01, 63),\n        (1.0, 63, 0.5, 1e-6, 32),\n        (1.0, 3, 1.0, 0.1, 1),\n        (2.0, 63, 2.0, 0.5, 22),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, kappa, dt, m = case\n\n        # Physical and discretization parameters\n        dx = L / (N + 1)\n        j_indices = np.arange(1, N + 1)\n\n        # --- Theoretical Dissipation Factor Calculation ---\n        \n        # Eigenvalue of the scaled discrete Laplacian M = (kappa/dx^2) * A for mode m\n        # lambda_m = -4 * sin^2(m*pi/(2*(N+1))) is the eigenvalue of A.\n        sin_term_sq = np.sin(m * np.pi / (2 * (N + 1)))**2\n        mu_m = -4 * kappa / (dx**2) * sin_term_sq\n\n        # Theoretical amplification factor for Backward Euler\n        # g_be = 1 / (1 - dt * mu_m)\n        g_be_th = 1.0 / (1.0 - dt * mu_m)\n\n        # Theoretical amplification factor for Crank-Nicolson\n        # g_cn = (1 + dt * mu_m / 2) / (1 - dt * mu_m / 2)\n        # The dissipation factor is the magnitude.\n        g_cn_th = np.abs((1.0 + dt * mu_m / 2.0) / (1.0 - dt * mu_m / 2.0))\n\n        # --- Empirical Dissipation Factor Calculation ---\n        \n        # Initial condition: discrete sine mode (eigenvector of the discrete Laplacian)\n        u0 = np.sin(m * np.pi * j_indices / (N + 1))\n        norm_u0 = np.linalg.norm(u0)\n\n        # Build the discrete Laplacian matrix A for N interior points\n        # A is an N x N tridiagonal matrix with (-2, 1, 1) entries\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        I = np.identity(N)\n\n        # 1. Backward Euler (BE)\n        # (I - dt * kappa / dx^2 * A) u_1 = u_0\n        c_be = kappa * dt / (dx**2)\n        M_be = I - c_be * A\n        u1_be = np.linalg.solve(M_be, u0)\n        norm_u1_be = np.linalg.norm(u1_be)\n        g_be_emp = norm_u1_be / norm_u0\n\n        # 2. Crank-Nicolson (CN)\n        # (I - dt/2 * kappa / dx^2 * A) u_1 = (I + dt/2 * kappa / dx^2 * A) u_0\n        c_cn = kappa * dt / (2 * dx**2)\n        LHS_cn = I - c_cn * A\n        RHS_cn_matrix = I + c_cn * A\n        rhs_cn_vector = RHS_cn_matrix @ u0\n        u1_cn = np.linalg.solve(LHS_cn, rhs_cn_vector)\n        norm_u1_cn = np.linalg.norm(u1_cn)\n        g_cn_emp = norm_u1_cn / norm_u0\n        \n        # Store results in the specified order\n        results.append([g_cn_emp, g_be_emp, g_cn_th, g_be_th])\n\n    # Final print statement in the exact required format.\n    # The format string ensures that nested lists are printed correctly.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3604206"}, {"introduction": "The selection of a time-stepping algorithm is a crucial design decision involving complex trade-offs between accuracy, stability, and the preservation of physical principles. This practice explores these trade-offs within the unified framework of the $\\theta$-scheme, which generalizes many common methods. You will analyze properties such as L-stability for handling stiff systems, high-frequency damping, and the preservation of the discrete maximum principle—all of which are vital for robust and physically meaningful geophysical modeling [@problem_id:3604158]. This comparative analysis will equip you to make informed decisions when choosing an implicit scheme for a specific scientific application.", "problem": "Consider the one-dimensional heat equation arising in conductive cooling of an oceanic lithosphere plate, written in nondimensional form as $$\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2},$$ with constant thermal diffusivity parameterized as a positive constant $\\kappa  0$. For this problem, focus on the case $\\kappa = 1$ to isolate diffusion-induced stability and monotonicity properties. On the interval $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$, adopt a uniform grid with $N$ interior points, grid spacing $\\Delta x = 1/(N+1)$, and the standard second-order centered difference for the Laplacian operator. Use the $\\theta$-scheme in time for the semi-discrete system, with a fixed time-step $\\Delta t  0$. The family of $\\theta$-schemes is generated by time-stepping $$\\frac{u^{n+1} - u^n}{\\Delta t} = \\theta \\left(\\kappa \\frac{\\partial^2 u^{n+1}}{\\partial x^2}\\right) + (1-\\theta) \\left(\\kappa \\frac{\\partial^2 u^n}{\\partial x^2}\\right),$$ where $\\theta \\in [0,1]$; here, focus on $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$. In this formulation, the matrix form for interior nodes is $$\\left(I - \\theta \\Delta t \\, \\kappa L\\right) u^{n+1} = \\left(I + (1-\\theta) \\Delta t \\, \\kappa L\\right) u^n,$$ where $L$ is the discrete Laplacian with homogeneous Dirichlet boundary conditions.\n\nYour goal is to design and compare these $\\theta$-schemes on three aspects directly connected to stiff diffusion dynamics in computational geophysics:\n\n1. Stiff decay (L-stability): For the linear test equation $$v'(t) = \\lambda v(t), \\quad \\lambda \\in \\mathbb{C} \\text{ with } \\operatorname{Re}(\\lambda) \\le 0,$$ the $\\theta$-scheme yields the scalar amplification factor $$G_\\theta(z) = \\frac{1 + (1-\\theta) z}{1 - \\theta z}, \\quad z = \\Delta t \\, \\lambda.$$ A method is L-stable if it is A-stable and additionally satisfies $$\\lim_{z \\to -\\infty} |G_\\theta(z)| = 0$$ along the negative real axis. Design a quantitative check of L-stability by evaluating the magnitude of $G_\\theta(z)$ at a very stiff point $z = -10^6$ and declaring the scheme L-stable if and only if $$\\left|G_\\theta(-10^6)\\right|  10^{-3}.$$ Report the result as a boolean for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$.\n\n2. Damping of the highest-frequency Fourier mode: For the one-dimensional discrete Laplacian with $N$ interior nodes and homogeneous Dirichlet boundary conditions, the eigenpairs are $$\\phi_j(i) = \\sin\\left(\\frac{j \\pi i}{N+1}\\right), \\quad \\lambda_j^{(L)} = -\\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{j \\pi}{2(N+1)}\\right), \\quad j=1,\\dots,N.$$ The highest-frequency mode corresponds to $j = N$. For a fixed choice $N=100$, $\\kappa=1$, and a time-step defined by a nondimensional ratio $$r = \\frac{\\kappa \\Delta t}{\\Delta x^2} = 0.8,$$ compute the one-step magnitude attenuation factor $$\\rho_\\theta = \\left|G_\\theta\\left(z_N\\right)\\right| \\quad \\text{with} \\quad z_N = \\Delta t \\, \\kappa \\, \\lambda_N^{(L)} = r \\, \\left(\\Delta x^2 \\lambda_N^{(L)}\\right),$$ for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$. Report the three attenuation factors as floats.\n\n3. Discrete maximum principle (DMP) preservation: For the diffusion-only problem with homogeneous Dirichlet boundary conditions, a sufficient condition for the one-step update to preserve the discrete maximum principle is that the coefficients on the explicit part are nonnegative. For the one-dimensional three-point stencil, this yields the constraint $$r \\le \\frac{1}{2(1-\\theta)} \\quad \\text{for} \\quad \\theta  1,$$ and unconditional preservation for $\\theta = 1$. Using this sufficient condition, evaluate DMP preservation for two step sizes: a \"safe\" step $r = 0.8$ and a \"stress\" step $r = 1.3$. Report booleans indicating whether the sufficient condition holds for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$ under each chosen $r$.\n\nYou must proceed from first principles consistent with energy conservation and the method-of-lines discretization, avoiding any specialized shortcut formulas. Base your derivations on:\n\n- Conservation of energy leading to the heat equation,\n- Standard second-order finite differences for the one-dimensional Laplacian with homogeneous Dirichlet boundary conditions,\n- The definition of the $\\theta$-family of one-step methods,\n- The scalar amplification factor induced by the $\\theta$-scheme for a linear test equation.\n\nTest Suite and Output Specification:\n\n- Adopt the following test suite:\n  - L-stability check at $z = -10^6$ for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$, with the threshold $\\left|G_\\theta(-10^6)\\right|  10^{-3}$.\n  - High-frequency damping with $N=100$, $\\kappa=1$, and $r=0.8$ for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$.\n  - DMP preservation booleans for $r=0.8$ and $r=1.3$ for each $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$ using the sufficient condition above.\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  - Three booleans for L-stability for $\\theta = 1$, $\\theta = \\frac{1}{2}$, $\\theta = \\frac{2}{3}$,\n  - Three floats for single-step high-frequency attenuation $\\rho_\\theta$ for $\\theta = 1$, $\\theta = \\frac{1}{2}$, $\\theta = \\frac{2}{3}$ (use any reasonable floating-point representation),\n  - Three booleans for DMP preservation at $r=0.8$ for $\\theta = 1$, $\\theta = \\frac{1}{2}$, $\\theta = \\frac{2}{3}$,\n  - Three booleans for DMP preservation at $r=1.3$ for $\\theta = 1$, $\\theta = \\frac{1}{2}$, $\\theta = \\frac{2}{3}$.\n\nFor example, the output format must be exactly a single line like \"[result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11,result12]\". No other text should be printed. Since all quantities here are nondimensional, no physical units are required in the output.", "solution": "The problem requires an analysis and comparison of three instances of the $\\theta$-scheme for the one-dimensional heat equation, specifically for $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$. The analysis focuses on three key properties relevant to computational geophysics where stiff diffusion problems are common: L-stability, damping of high-frequency numerical modes, and preservation of the discrete maximum principle.\n\nThe starting point is the one-dimensional heat equation, a model for conductive heat transfer which arises from the principle of conservation of energy:\n$$ u_t = \\nabla \\cdot (\\kappa \\nabla u) + q $$\nFor this problem, we consider the simplified case on the spatial domain $x \\in (0,1)$ with constant thermal diffusivity $\\kappa=1$ and no heat source $q=0$. The equation becomes:\n$$ u_t = u_{xx} $$\nThe boundary conditions are homogeneous Dirichlet, $u(0,t) = u(1,t) = 0$.\n\nWe employ the method of lines, first discretizing in space. Using a uniform grid with $N$ interior points $x_i = i \\Delta x$ for $i=1, \\dots, N$, where the grid spacing is $\\Delta x = 1/(N+1)$, we approximate the spatial derivative using a second-order central difference formula:\n$$ u_{xx}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{\\Delta x^2} $$\nLetting $u_i(t)$ be the approximation of $u(x_i, t)$, the partial differential equation is converted into a system of coupled ordinary differential equations (ODEs):\n$$ \\frac{du_i}{dt} = \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{\\Delta x^2} \\quad \\text{for } i=1, \\dots, N $$\nwith $u_0(t)=0$ and $u_{N+1}(t)=0$ from the boundary conditions. This system can be written in matrix form as:\n$$ \\frac{d\\mathbf{u}}{dt} = L \\mathbf{u} $$\nwhere $\\mathbf{u}(t) = [u_1(t), \\dots, u_N(t)]^T$ is the vector of temperature values at the interior nodes, and $L$ is the $N \\times N$ discrete Laplacian matrix, which for a $1$D problem with homogeneous Dirichlet boundary conditions is a symmetric tridiagonal matrix with $-2/\\Delta x^2$ on the main diagonal and $1/\\Delta x^2$ on the sub- and super-diagonals.\n\nNext, we discretize in time using the $\\theta$-scheme. Let $u^n$ be the approximation of $\\mathbf{u}$ at time $t_n = n \\Delta t$. The time derivative is approximated as $(u^{n+1}-u^n)/\\Delta t$, and the spatial term is evaluated as a weighted average at times $t_n$ and $t_{n+1}$:\n$$ \\frac{u^{n+1} - u^n}{\\Delta t} = \\theta (L u^{n+1}) + (1-\\theta) (L u^n) $$\nRearranging the terms to solve for the unknown state $u^{n+1}$ yields the matrix form of the time-stepping scheme, consistent with the problem statement (for $\\kappa=1$ and $q=0$):\n$$ (I - \\theta \\Delta t L) u^{n+1} = (I + (1-\\theta) \\Delta t L) u^n $$\nwhere $I$ is the identity matrix.\n\nTo analyze the stability properties of this scheme, we apply it to the scalar linear test equation $v'(t) = \\lambda v(t)$, where $\\lambda \\in \\mathbb{C}$ represents an eigenvalue of the operator. The scheme becomes:\n$$ \\frac{v^{n+1} - v^n}{\\Delta t} = \\theta \\lambda v^{n+1} + (1-\\theta) \\lambda v^n $$\nSolving for the ratio $G = v^{n+1}/v^n$, which is the scalar amplification factor, we get:\n$$ v^{n+1}(1 - \\theta \\Delta t \\lambda) = v^n(1 + (1-\\theta) \\Delta t \\lambda) $$\n$$ G_\\theta(z) = \\frac{v^{n+1}}{v^n} = \\frac{1 + (1-\\theta) z}{1 - \\theta z}, \\quad \\text{where } z = \\Delta t \\lambda $$\nThis amplification factor governs the growth or decay of numerical solutions and is central to the analysis.\n\n**1. Stiff decay (L-stability)**\nA numerical method is L-stable if it is A-stable (i.e., $|G(z)| \\le 1$ for all $z$ with $\\text{Re}(z) \\le 0$) and additionally satisfies $\\lim_{\\text{Re}(z) \\to -\\infty} |G(z)| = 0$. This property is crucial for stiff problems, ensuring that highly stiff (rapidly decaying) components are strongly damped by the numerical scheme. For the $\\theta$-scheme on the real axis, the limit is:\n$$ \\lim_{z \\to -\\infty} G_\\theta(z) = \\lim_{z \\to -\\infty} \\frac{1/z + (1-\\theta)}{1/z - \\theta} = \\frac{1-\\theta}{-\\theta} = \\frac{\\theta-1}{\\theta} $$\nThis limit is zero only if the numerator is zero, which requires $\\theta=1$. Thus, among the general family of $\\theta$-methods, only Backward Euler ($\\theta=1$) is L-stable.\n\nWe perform the quantitative check specified, evaluating $|G_\\theta(z)|$ at $z = -10^6$ with a tolerance of $10^{-3}$.\n- For $\\theta = 1$: $G_1(-10^6) = \\frac{1}{1 - (-10^6)} = \\frac{1}{1000001} \\approx 9.99 \\times 10^{-7}$. Since $|G_1(-10^6)|  10^{-3}$, the scheme is L-stable.\n- For $\\theta = \\frac{1}{2}$: $G_{1/2}(-10^6) = \\frac{1 + (1/2)(-10^6)}{1 - (1/2)(-10^6)} = \\frac{1 - 500000}{1 + 500000} = \\frac{-499999}{500001} \\approx -1$. Since $|G_{1/2}(-10^6)| \\approx 1 \\not 10^{-3}$, the scheme is not L-stable.\n- For $\\theta = \\frac{2}{3}$: $G_{2/3}(-10^6) = \\frac{1 + (1/3)(-10^6)}{1 - (2/3)(-10^6)} = \\frac{1 - 10^6/3}{1 + 2 \\cdot 10^6/3} \\approx \\frac{-1/3}{-(-2/3)} = -1/2$. Since $|G_{2/3}(-10^6)| \\approx 0.5 \\not 10^{-3}$, the scheme is not L-stable.\nThe results are: {True, False, False}.\n\n**2. Damping of the highest-frequency Fourier mode**\nThe stability analysis for the PDE system relies on the eigenvalues of the discrete Laplacian matrix $L$. The eigenpairs are given as $(\\lambda_j^{(L)}, \\phi_j)$. The amplification factor for the $j$-th mode is $G_\\theta(z_j)$ with $z_j = \\Delta t \\kappa \\lambda_j^{(L)}$. The highest-frequency (most oscillatory) mode corresponds to $j=N$. The problem provides the relevant eigenvalue $\\lambda_N^{(L)} = -\\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{N \\pi}{2(N+1)}\\right)$.\nWe are asked to compute the attenuation factor $\\rho_\\theta = |G_\\theta(z_N)|$ for $N=100$, $\\kappa=1$, and the nondimensional ratio $r = \\frac{\\kappa \\Delta t}{\\Delta x^2} = 0.8$.\nThe argument $z_N$ is calculated as:\n$$ z_N = \\Delta t \\kappa \\lambda_N^{(L)} = \\left(\\frac{r \\Delta x^2}{\\kappa}\\right) \\kappa \\lambda_N^{(L)} = r (\\Delta x^2 \\lambda_N^{(L)}) = r \\left(-4 \\sin^2\\left(\\frac{N \\pi}{2(N+1)}\\right)\\right) $$\nFor $N=100$ and $r=0.8$:\n$$ z_N = -0.8 \\times 4 \\sin^2\\left(\\frac{100 \\pi}{2(101)}\\right) = -3.2 \\sin^2\\left(\\frac{50\\pi}{101}\\right) \\approx -3.1992257 $$\nWe now compute $\\rho_\\theta = |G_\\theta(z_N)|$ for each $\\theta$:\n- For $\\theta = 1$: $\\rho_1 = \\left| \\frac{1}{1 - z_N} \\right| \\approx \\left| \\frac{1}{1 - (-3.1992)} \\right| \\approx 0.238138$\n- For $\\theta = \\frac{1}{2}$: $\\rho_{1/2} = \\left| \\frac{1 + 0.5 z_N}{1 - 0.5 z_N} \\right| \\approx \\left| \\frac{1 + 0.5(-3.1992)}{1 - 0.5(-3.1992)} \\right| \\approx 0.230796$\n- For $\\theta = \\frac{2}{3}$: $\\rho_{2/3} = \\left| \\frac{1 + (1/3) z_N}{1 - (2/3) z_N} \\right| \\approx \\left| \\frac{1 + (1/3)(-3.1992)}{1 - (2/3)(-3.1992)} \\right| \\approx 0.021271$\nThe attenuation factors are: {$0.238138$, $0.230796$, $0.021271$}.\n\n**3. Discrete maximum principle (DMP) preservation**\nThe DMP for the heat equation implies that, in the absence of sources, the maximum temperature value does not increase and the minimum does not decrease over time. A numerical scheme preserving this property is desirable as it prevents the creation of non-physical oscillations. For the $\\theta$-scheme applied to $u_t=u_{xx}$, the update rule for a single node $u_i$ is obtained by expanding the matrix form. The right-hand side, representing the explicit part of the update, acts on $u^n$. The value $u_i^{n+1}$ depends on a linear combination of $u_{j}^n$ for $j=i-1, i, i+1$. A sufficient condition for DMP preservation is that all coefficients in this linear combination are non-negative.\nThe update involves solving $(I - \\theta r L_{\\Delta x^2}) u^{n+1} = (I + (1-\\theta) r L_{\\Delta x^2}) u^n$, where $L_{\\Delta x^2} = \\Delta x^2 L$ is the Laplacian stencil matrix with entries $(-2, 1, 1)$. The coefficients acting on $u^n$ are from the matrix $(I + (1-\\theta) r L_{\\Delta x^2})$. This gives rise to the stencil $[(1-\\theta)r, \\quad 1-2(1-\\theta)r, \\quad (1-\\theta)r]$ acting on $[u_{i-1}^n, u_i^n, u_{i+1}^n]$.\nFor non-negativity, we require $(1-\\theta)r \\ge 0$ and $1-2(1-\\theta)r \\ge 0$. As $r0$, the first condition implies $\\theta \\le 1$. The second condition gives the constraint $r \\le \\frac{1}{2(1-\\theta)}$. This constraint is undefined for $\\theta=1$. For $\\theta=1$, the RHS matrix is simply $I$, and the coefficients are $[0, 1, 0]$, which are all non-negative. Thus, the DMP is unconditionally preserved for $\\theta=1$.\n\nWe check this condition for $\\theta \\in \\{1, \\frac{1}{2}, \\frac{2}{3}\\}$ with $r \\in \\{0.8, 1.3\\}$.\nFor $r=0.8$:\n- $\\theta = 1$: Unconditional. Holds.\n- $\\theta = \\frac{1}{2}$: Condition is $r \\le \\frac{1}{2(1-1/2)} = 1$. $0.8 \\le 1$ holds.\n- $\\theta = \\frac{2}{3}$: Condition is $r \\le \\frac{1}{2(1-2/3)} = 1.5$. $0.8 \\le 1.5$ holds.\nResults for $r=0.8$: {True, True, True}.\n\nFor $r=1.3$:\n- $\\theta = 1$: Unconditional. Holds.\n- $\\theta = \\frac{1}{2}$: Condition is $r \\le 1$. $1.3 \\le 1$ fails.\n- $\\theta = \\frac{2}{3}$: Condition is $r \\le 1.5$. $1.3 \\le 1.5$ holds.\nResults for $r=1.3$: {True, False, True}.\n\nCombining all results in the specified order gives the final list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs the analysis of the theta-scheme for the 1D heat equation\n    as specified in the problem statement.\n    \"\"\"\n    thetas = [1.0, 0.5, 2.0/3.0]\n    all_results = []\n\n    # 1. L-stability check\n    z_stiff = -1e6\n    l_stability_threshold = 1e-3\n\n    def G_theta(theta, z):\n        \"\"\"Amplification factor for the theta-scheme.\"\"\"\n        # Handle the case theta*z = 1 to avoid division by zero, though not expected here.\n        if np.isclose(1.0 - theta * z, 0.0):\n            return np.inf\n        return (1.0 + (1.0 - theta) * z) / (1.0 - theta * z)\n\n    l_stability_results = []\n    for theta in thetas:\n        mag_G = np.abs(G_theta(theta, z_stiff))\n        l_stability_results.append(mag_G  l_stability_threshold)\n    all_results.extend(l_stability_results)\n\n    # 2. Damping of the highest-frequency Fourier mode\n    N = 100\n    r = 0.8  # kappa * dt / dx^2\n\n    # Argument z_N for the amplification factor, corresponding to the highest frequency mode\n    # z_N = r * (dx^2 * lambda_N), where lambda_N is the largest-magnitude eigenvalue\n    # dx^2 * lambda_N = -4 * sin^2(N*pi / (2*(N+1)))\n    z_N = r * (-4.0 * np.sin(N * np.pi / (2.0 * (N + 1.0)))**2)\n\n    damping_results = []\n    for theta in thetas:\n        rho_theta = np.abs(G_theta(theta, z_N))\n        damping_results.append(rho_theta)\n    all_results.extend(damping_results)\n\n    # 3. Discrete maximum principle (DMP) preservation\n    r_values = [0.8, 1.3]\n    for r_val in r_values:\n        dmp_results = []\n        for theta in thetas:\n            if np.isclose(theta, 1.0):\n                # Unconditionally preserves DMP for theta=1\n                dmp_results.append(True)\n            else:\n                # Sufficient condition: r = 1 / (2*(1-theta))\n                dmp_limit = 1.0 / (2.0 * (1.0 - theta))\n                dmp_results.append(r_val = dmp_limit)\n        all_results.extend(dmp_results)\n\n    # Format the final output string\n    # Convert booleans to lowercase 'true'/'false' as per Python's str()\n    # and format floats to a reasonable precision.\n    formatted_results = []\n    for res in all_results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            # Standard float representation is sufficient\n            formatted_results.append(str(res))\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3604158"}]}