{"hands_on_practices": [{"introduction": "The foundation of any gravity gradient modeling is the ability to compute the tensor for a given mass distribution. This first practice builds this crucial skill from the ground up. You will implement a numerical model by discretizing a continuous density anomaly and then applying finite difference methods to calculate the second derivatives of the gravitational potential, which define the gravity gradient tensor [@problem_id:3602058].", "problem": "You are to implement a numerical model for the gravity gradient tensor based on first principles for three test cases. Use Newtonian gravitation to model the gravitational potential of volumetric density anomalies discretized on a uniform Cartesian grid. The gravity gradient tensor is to be obtained by numerical differentiation of the potential using finite differences. Your program must output quantitative results for each test case in specified physical units and format.\n\nFundamental base. Start from the Newtonian gravitational potential generated by a density distribution. For a mass density field $\\rho(\\mathbf{r}')$ in three-dimensional space, the gravitational potential $\\Phi(\\mathbf{r})$ at position $\\mathbf{r}$ is\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV',\n$$\nwhere $G$ is the gravitational constant. The gravity gradient tensor $\\mathbf{T}$ is defined as the Hessian of the potential,\n$$\nT_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j},\n$$\nfor Cartesian coordinates $\\{x_1,x_2,x_3\\} \\equiv \\{x,y,z\\}$.\n\nDiscretization strategy. Discretize the density field by uniform voxels of edge length $h$ on an odd-sized grid with $N$ nodes per axis. Represent the mass distribution as a collection of point masses at voxel centers. For a uniform density anomaly with density $\\rho$ and voxel volume $h^3$, each occupied voxel has mass $m = \\rho h^3$. Approximate the potential at a point $\\mathbf{r}$ by a Riemann sum\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|},\n$$\nwhere $\\{\\mathbf{r}_n\\}_{n=1}^M$ are the centers of the occupied voxels.\n\nNumerical differentiation. Approximate second derivatives of $\\Phi$ at grid nodes using second-order accurate finite differences with grid spacing $h$:\n\n- For a pure second derivative along $x$ at an interior node,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j,k} - 2\\Phi_{i,j,k} + \\Phi_{i-1,j,k}}{h^2}.\n$$\n\n- For a mixed derivative at an interior node, for example $\\partial^2 \\Phi / \\partial x \\partial y$,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x \\partial y} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j+1,k} - \\Phi_{i+1,j-1,k} - \\Phi_{i-1,j+1,k} + \\Phi_{i-1,j-1,k}}{4h^2}.\n$$\n\n- At a boundary node where a central stencil is not available, use a second-order accurate one-sided stencil for the pure second derivative. For example, at the top boundary along $z$ with backward differences,\n$$\n\\frac{\\partial^2 \\Phi}{\\partial z^2} \\bigg|_{i,j,K} \\approx \\frac{2\\Phi_{i,j,K} - 5\\Phi_{i,j,K-1} + 4\\Phi_{i,j,K-2} - \\Phi_{i,j,K-3}}{h^2}.\n$$\n\nCoordinate system and grid. Use a cubic grid with $N$ odd so that the origin is at the central node. Let indices $i,j,k \\in \\{0,1,\\dots,N-1\\}$. The physical coordinates of node $(i,j,k)$ are\n$$\nx_i = \\left(i - \\frac{N-1}{2}\\right) h, \\quad y_j = \\left(j - \\frac{N-1}{2}\\right) h, \\quad z_k = \\left(k - \\frac{N-1}{2}\\right) h.\n$$\n\nPhysical constants and units. Use the gravitational constant $G = 6.67430 \\times 10^{-11}$ in $\\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$. Use density $\\rho$ in $\\mathrm{kg} \\, \\mathrm{m}^{-3}$, lengths in $\\mathrm{m}$. Express gravity gradient tensor components in Eötvös, where $1$ Eötvös $= 10^{-9} \\, \\mathrm{s}^{-2}$. Your program must output each requested tensor component in Eötvös, rounded to six decimal places.\n\nTest suite and required outputs. Use $N = 33$ and $h = 100$ $\\mathrm{m}$ for all cases. Use uniform density $\\rho = 2670$ $\\mathrm{kg} \\, \\mathrm{m}^{-3}$ for all anomalies. Define the anomaly voxels by selecting all voxel centers whose coordinates lie within the specified axis-aligned bounds (inclusive).\n\n- Test case $1$ (interior central differences and trace constraint): A single uniform cube anomaly of side length $600$ $\\mathrm{m}$ centered at the origin, i.e., occupied voxel centers with $x \\in [-300,300]$ $\\mathrm{m}$, $y \\in [-300,300]$ $\\mathrm{m}$, $z \\in [-300,300]$ $\\mathrm{m}$. Evaluate at the node with coordinates $(x,y,z) = (0,0,500)$ $\\mathrm{m}$. Compute the pure second derivatives to form the trace $S = T_{xx} + T_{yy} + T_{zz}$ at that point. Output $S$ in Eötvös, rounded to six decimal places.\n\n- Test case $2$ (mixed derivative symmetry): Two equal uniform cube anomalies, each of side length $400$ $\\mathrm{m}$, centered at $(x,y,z) = (-600,0,0)$ $\\mathrm{m}$ and $(x,y,z) = (600,0,0)$ $\\mathrm{m}$. That is, occupied voxel centers for the left cube have $x \\in [-800,-400]$ $\\mathrm{m}$, $y \\in [-200,200]$ $\\mathrm{m}$, $z \\in [-200,200]$ $\\mathrm{m}$, and for the right cube have $x \\in [400,800]$ $\\mathrm{m}$ with the same $y$ and $z$ bounds. Evaluate at the origin $(0,0,0)$ $\\mathrm{m}$. Compute the mixed derivative $T_{xy}$ at that point using central differences. Output $T_{xy}$ in Eötvös, rounded to six decimal places.\n\n- Test case $3$ (boundary one-sided stencil): A single uniform cube anomaly of side length $400$ $\\mathrm{m}$ centered at $(x,y,z) = (0,0,-700)$ $\\mathrm{m}$, i.e., occupied voxel centers with $x \\in [-200,200]$ $\\mathrm{m}$, $y \\in [-200,200]$ $\\mathrm{m}$, $z \\in [-900,-500]$ $\\mathrm{m}$. Evaluate at the top boundary node $(x,y,z) = (0,0,1600)$ $\\mathrm{m}$. Compute $T_{zz}$ using the second-order accurate one-sided backward stencil. Output $T_{zz}$ in Eötvös, rounded to six decimal places.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[S_{\\text{case 1}}, T_{xy,\\text{case 2}}, T_{zz,\\text{case 3}}]$, for example, \"[1.234567,0.000001,-0.123456]\". All three numbers must be in Eötvös and rounded to six decimal places, with no spaces in the list.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in Newtonian physics, mathematically well-posed, objective, and self-contained. The provided parameters and test cases are consistent and allow for a unique, meaningful solution. We may therefore proceed with the development of the computational model.\n\nThe task is to implement a numerical model to calculate components of the gravity gradient tensor, $\\mathbf{T}$, for three distinct mass anomaly configurations. The model is based on first principles of Newtonian gravitation, employing discretization and numerical differentiation.\n\n**1. Foundational Principle: Gravitational Potential**\n\nThe gravitational potential $\\Phi$ at a position $\\mathbf{r}$ due to a continuous mass density distribution $\\rho(\\mathbf{r}')$ is given by the volume integral:\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV'\n$$\nwhere $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$ is the gravitational constant.\n\n**2. Discretization Strategy**\n\nTo facilitate numerical computation, we model the continuous density anomaly as a collection of discrete point masses. The source volume is discretized into a uniform grid of voxels, each of side length $h = 100 \\, \\mathrm{m}$. For a uniform density anomaly $\\rho = 2670 \\, \\mathrm{kg} \\, \\mathrm{m}^{-3}$, each voxel is represented by a point mass $m = \\rho h^3$ located at its geometric center. The integral for the potential is thus approximated by a Riemann sum:\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|}\n$$\nHere, $\\{\\mathbf{r}_n\\}_{n=1}^M$ are the coordinate vectors of the centers of the $M$ voxels comprising the density anomaly. The evaluation points $\\mathbf{r}$ for the potential are distinct from all mass locations $\\mathbf{r}_n$, thereby avoiding singularities.\n\n**3. Gravity Gradient Tensor via Numerical Differentiation**\n\nThe gravity gradient tensor, $\\mathbf{T}$, is the Hessian of the potential, with components $T_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j}$. We approximate these second derivatives using finite difference formulas on the computational grid. The problem specifies second-order accurate stencils.\n\n**4. Implementation for Test Cases**\n\nA computational grid with $N=33$ nodes per axis and spacing $h=100 \\, \\mathrm{m}$ is established. The coordinates are centered at the origin, with the physical coordinate of a node with index $k \\in \\{0, \\dots, N-1\\}$ along any axis being $(k - \\frac{N-1}{2})h = (k - 16)h$.\n\nFor each test case, the following procedure is executed:\n1.  Identify the set of voxel center coordinates $\\{\\mathbf{r}_n\\}$ that satisfy the given geometric bounds for the anomaly.\n2.  Define the required stencil points around the specified evaluation point $\\mathbf{r}_{\\text{eval}}$.\n3.  Calculate the gravitational potential $\\Phi$ at each of these stencil points using the discretized formula.\n4.  Apply the appropriate finite difference formula to compute the required tensor component(s).\n5.  Convert the result from SI units ($\\mathrm{s}^{-2}$) to Eötvös ($1 \\text{ Eötvös} = 10^{-9} \\, \\mathrm{s}^{-2}$) by multiplying by $10^9$.\n\n**Test Case 1: Trace at an Interior Point**\n-   **Anomaly:** A single cube defined by voxel centers with coordinates $x, y, z \\in [-300, 300] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 500) \\, \\mathrm{m}$. This is an interior node of the computational grid.\n-   **Task:** Compute the trace $S = T_{xx} + T_{yy} + T_{zz}$.\n-   **Methodology:** The pure second derivatives are computed using the second-order central difference stencil:\n    $$\n    T_{xx}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y, z) - 2\\Phi(x, y, z) + \\Phi(x-h, y, z)}{h^2}\n    $$\n    Analogous formulas are used for $T_{yy}$ and $T_{zz}$. Nine potential calculations are required for the three stencils (some points are shared). The evaluation point is outside the mass distribution, where the potential satisfies Laplace's equation, $\\nabla^2 \\Phi = T_{xx} + T_{yy} + T_{zz} = 0$. The computed numerical trace $S$ is therefore expected to be a small value, representing the error of the numerical approximation.\n\n**Test Case 2: Mixed Derivative at the Origin**\n-   **Anomaly:** Two cubes, one with $x \\in [-800, -400] \\, \\mathrm{m}$ and another with $x \\in [400, 800] \\, \\mathrm{m}$, both with $y, z \\in [-200, 200] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 0) \\, \\mathrm{m}$.\n-   **Task:** Compute the mixed derivative $T_{xy}$.\n-   **Methodology:** The mixed derivative is computed using the second-order central difference stencil:\n    $$\n    T_{xy}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y+h, z) - \\Phi(x+h, y-h, z) - \\Phi(x-h, y+h, z) + \\Phi(x-h, y-h, z)}{4h^2}\n    $$\n    The mass distribution is symmetric with respect to the $x-z$ plane (i.e., at $y=0$). This symmetry implies that $\\Phi(x, y, z) = \\Phi(x, -y, z)$, and therefore $\\frac{\\partial \\Phi}{\\partial y}$ must be zero everywhere on the $x-z$ plane. Consequently, $T_{xy} = \\frac{\\partial}{\\partial x}(\\frac{\\partial \\Phi}{\\partial y})$ must also be zero at the origin. The numerical result is expected to be close to zero, limited by floating-point precision.\n\n**Test Case 3: Pure Derivative at a Boundary**\n-   **Anomaly:** A single cube defined by $x, y \\in [-200, 200] \\, \\mathrm{m}$ and $z \\in [-900, -500] \\, \\mathrm{m}$.\n-   **Evaluation Point:** $\\mathbf{r}_{\\text{eval}} = (0, 0, 1600) \\, \\mathrm{m}$. This coordinate corresponds to the node with index $k=32$, which is the top boundary of the grid ($k_{\\text{max}} = N-1 = 32$).\n-   **Task:** Compute $T_{zz}$.\n-   **Methodology:** Since a forward difference point is not available within the grid, the specified second-order accurate one-sided backward difference formula must be used:\n    $$\n    T_{zz}(\\mathbf{r}) \\approx \\frac{2\\Phi(x, y, z) - 5\\Phi(x, y, z-h) + 4\\Phi(x, y, z-2h) - \\Phi(x, y, z-3h)}{h^2}\n    $$\n    This requires calculating the potential at the evaluation point itself and three points below it along the $z$-axis.\n\nThe final implementation encapsulates these steps into a program that computes and outputs the three requested values in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes gravity gradient tensor components for three test cases.\n    \"\"\"\n    # Physical constants and parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    RHO = 2670.0      # kg m^-3\n    N = 33            # Grid nodes per axis\n    H = 100.0         # m, grid spacing / voxel edge length\n    MASS = RHO * H**3 # kg, mass of a single voxel\n    EOTVOS_CONVERSION = 1e9\n\n    def get_mass_locations(case_params):\n        \"\"\"\n        Generates the coordinates of voxel centers for a given anomaly definition.\n        \n        Args:\n            case_params (list of tuples): Each tuple contains (min_coord, max_coord)\n                                          for x, y, z axes respectively.\n        \n        Returns:\n            np.ndarray: An (M, 3) array of mass point coordinates.\n        \"\"\"\n        all_mass_locs = []\n        for x_bounds, y_bounds, z_bounds in case_params:\n            x_coords = np.arange(x_bounds[0], x_bounds[1] + 1, H)\n            y_coords = np.arange(y_bounds[0], y_bounds[1] + 1, H)\n            z_coords = np.arange(z_bounds[0], z_bounds[1] + 1, H)\n            \n            xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n            mass_locs = np.vstack([xx.ravel(), yy.ravel(), zz.ravel()]).T\n            all_mass_locs.append(mass_locs)\n        \n        if not all_mass_locs:\n            return np.empty((0, 3))\n        \n        return np.vstack(all_mass_locs)\n\n    def compute_potential(eval_point, mass_locations):\n        \"\"\"\n        Calculates the gravitational potential at a single evaluation point.\n        \n        Args:\n            eval_point (tuple or np.ndarray): The (x, y, z) coordinate for evaluation.\n            mass_locations (np.ndarray): An (M, 3) array of mass point coordinates.\n\n        Returns:\n            float: The gravitational potential in SI units (m^2 s^-2).\n        \"\"\"\n        if mass_locations.shape[0] == 0:\n            return 0.0\n\n        eval_point = np.array(eval_point)\n        diffs = eval_point - mass_locations\n        distances = np.linalg.norm(diffs, axis=1)\n        \n        # The problem is set up to avoid singularities (distances > 0)\n        potential_contribs = MASS / distances\n        total_potential = G * np.sum(potential_contribs)\n        return total_potential\n\n    results = []\n\n    # --- Test Case 1: Trace S at (0, 0, 500) m ---\n    case1_params = [((-300.0, 300.0), (-300.0, 300.0), (-300.0, 300.0))]\n    mass_locs_1 = get_mass_locations(case1_params)\n    r_eval_1 = (0.0, 0.0, 500.0)\n    \n    phi_center = compute_potential(r_eval_1, mass_locs_1)\n    \n    # T_xx\n    phi_xp1 = compute_potential((r_eval_1[0] + H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    phi_xm1 = compute_potential((r_eval_1[0] - H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    T_xx = (phi_xp1 - 2 * phi_center + phi_xm1) / (H**2)\n    \n    # T_yy\n    phi_yp1 = compute_potential((r_eval_1[0], r_eval_1[1] + H, r_eval_1[2]), mass_locs_1)\n    phi_ym1 = compute_potential((r_eval_1[0], r_eval_1[1] - H, r_eval_1[2]), mass_locs_1)\n    T_yy = (phi_yp1 - 2 * phi_center + phi_ym1) / (H**2)\n    \n    # T_zz\n    phi_zp1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] + H), mass_locs_1)\n    phi_zm1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] - H), mass_locs_1)\n    T_zz = (phi_zp1 - 2 * phi_center + phi_zm1) / (H**2)\n    \n    S_case1 = T_xx + T_yy + T_zz\n    results.append(S_case1 * EOTVOS_CONVERSION)\n\n    # --- Test Case 2: T_xy at (0, 0, 0) m ---\n    case2_params = [\n        ((-800.0, -400.0), (-200.0, 200.0), (-200.0, 200.0)),\n        ((400.0, 800.0), (-200.0, 200.0), (-200.0, 200.0))\n    ]\n    mass_locs_2 = get_mass_locations(case2_params)\n    r_eval_2 = (0.0, 0.0, 0.0)\n    \n    phi_xp1_yp1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xp1_ym1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_yp1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_ym1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    \n    T_xy_case2 = (phi_xp1_yp1 - phi_xp1_ym1 - phi_xm1_yp1 + phi_xm1_ym1) / (4 * H**2)\n    results.append(T_xy_case2 * EOTVOS_CONVERSION)\n\n    # --- Test Case 3: T_zz at (0, 0, 1600) m ---\n    case3_params = [((-200.0, 200.0), (-200.0, 200.0), (-900.0, -500.0))]\n    mass_locs_3 = get_mass_locations(case3_params)\n    r_eval_3 = (0.0, 0.0, 1600.0)\n    \n    phi_k = compute_potential(r_eval_3, mass_locs_3)\n    phi_km1 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - H), mass_locs_3)\n    phi_km2 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 2 * H), mass_locs_3)\n    phi_km3 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 3 * H), mass_locs_3)\n    \n    T_zz_case3 = (2 * phi_k - 5 * phi_km1 + 4 * phi_km2 - phi_km3) / (H**2)\n    results.append(T_zz_case3 * EOTVOS_CONVERSION)\n\n    # Final print statement in the exact required format.\n    # The format string \"{:.6f}\" handles rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3602058"}, {"introduction": "After mastering the forward calculation, the focus shifts to interpretation: what do the tensor components reveal about the causative source? This practice explores the power of tensor invariants, which are coordinate-system-independent quantities that serve as diagnostic 'fingerprints' for the source geometry. By computing these invariants for canonical mass distributions, you will develop a classification scheme that forms the basis of automated interpretation techniques [@problem_id:3602059].", "problem": "You are to write a complete, self-contained program that computes invariant combinations of the Gravity Gradient Tensor (GGT) to classify canonical anomaly geometries. Start from the Newtonian gravitational potential and the definition of the Gravity Gradient Tensor, derive and implement models for the tensor for several geometries, compute the invariants, and then classify the geometry based on these invariants.\n\nScientific and mathematical base to use:\n- Newtonian gravitational potential: $$U(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV',$$ where $G$ is the gravitational constant, $\\rho$ is mass density, and $\\mathbf{x}$ is the observation point.\n- Gravity Gradient Tensor (GGT): $$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}.$$\n- Invariants: $$I_2 = \\tfrac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right], \\quad I_3 = \\det T.$$\n\nTasks:\n1. Using the above fundamental definitions, derive and implement the GGT $T$ for each of the following canonical geometries at a specified observation point:\n   - A point mass at the origin with mass $m$.\n   - An infinite straight line mass aligned with the $y$-axis having linear density $\\lambda$.\n   - An infinite plane sheet at $z=0$ with surface density $\\sigma$.\n   - A homogeneous solid sphere with density $\\rho$ and radius $a$, at a point either inside or outside the sphere.\n\n2. For each geometry and parameter set provided in the test suite, compute the tensor $T$ at the given observation point $\\mathbf{x}$, then compute the invariants $I_2$ and $I_3$, the trace $\\operatorname{tr} T$, and the Frobenius norm scale $$s = \\sqrt{\\operatorname{tr}(T^2)}.$$\n\n3. Classify the geometry based on the following decision rule using the invariants. Use absolute and relative thresholds that are dimensionally consistent:\n   - Define $$\\varepsilon = 10^{-30} \\, \\mathrm{s}^{-2}, \\quad t = \\frac{|\\operatorname{tr} T|}{s + \\delta}, \\quad d = \\frac{|I_3|}{(s + \\delta)^3},$$ where $\\,\\delta = 10^{-300}\\,$ is a guard to avoid division by zero when $s=0$. The unit for $s$ is $\\mathrm{s}^{-2}$, so $\\varepsilon$ shares this unit. The ratios $t$ and $d$ are dimensionless.\n   - Decision rule:\n     - If $s \\le \\varepsilon$, classify as $0$ (sheet-like or effectively zero-gradient region).\n     - Else if $t \\le 10^{-12}$ and $d \\le 10^{-12}$, classify as $1$ (line-like, with one zero eigenvalue and zero determinant).\n     - Else if $t \\le 10^{-12}$ and $I_3 > 0$ and $I_2 < 0$, classify as $2$ (point-like, compact source observed in a source-free region with zero trace and positive determinant).\n     - Else if $t > 10^{-12}$ and $I_3 < 0$, classify as $3$ (volume-interior region, for example inside a homogeneous sphere).\n     - Else, classify as $2$.\n\nPhysical constants and units:\n- Use $$G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}.$$\n- All distances are in $\\mathrm{m}$, masses in $\\mathrm{kg}$, densities in $\\mathrm{kg/m^3}$, linear densities in $\\mathrm{kg/m}$, surface densities in $\\mathrm{kg/m^2}$. The Gravity Gradient Tensor components $T_{ij}$ must be computed in $\\mathrm{s}^{-2}$.\n\nTest suite:\nCompute and classify the following five cases:\n- Case $1$: Point mass at the origin with $$m = 5 \\times 10^{12} \\, \\mathrm{kg}, \\quad \\mathbf{x} = (100, 0, 0) \\, \\mathrm{m}.$$\n- Case $2$: Infinite line mass along the $y$-axis with $$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}, \\quad \\mathbf{x} = (50, 0, 50) \\, \\mathrm{m}.$$\n- Case $3$: Infinite plane sheet at $z=0$ with $$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}, \\quad \\mathbf{x} = (0, 0, 100) \\, \\mathrm{m}.$$\n- Case $4$: Homogeneous sphere with $$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}, \\quad a = 50 \\, \\mathrm{m}, \\quad \\mathbf{x} = (10, 0, 0) \\, \\mathrm{m} \\text{ (inside)}.$$\n- Case $5$: Same sphere as Case $4$ observed outside at $$\\mathbf{x} = (200, 0, 0) \\, \\mathrm{m}.$$\n\nFinal output format:\nYour program should produce a single line of output containing the integer classification codes for the five cases as a comma-separated list enclosed in square brackets, for example, $$[c_1,c_2,c_3,c_4,c_5],$$ where each $c_i$ is an integer produced by the decision rule above.", "solution": "The problem requires the development of a computational method to classify canonical mass geometries based on invariants of the Gravity Gradient Tensor (GGT). This involves deriving the GGT for several idealized mass distributions, implementing these models numerically, and then applying a specific decision tree based on the tensor invariants.\n\nThe fundamental principles are the Newtonian gravitational potential and the definition of the GGT. The potential $U$ at an observation point $\\mathbf{x}$ due to a mass distribution with density $\\rho$ is given by\n$$U(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV'$$\nwhere $G$ is the gravitational constant, and the integration is over the volume of the source. The GGT, denoted by $T$, is a symmetric tensor whose components $T_{ij}$ are the second partial derivatives of the potential:\n$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 U(\\mathbf{x})}{\\partial x_i \\partial x_j}$$\nThe trace of the GGT, $\\operatorname{tr}(T) = \\sum_i T_{ii}$, is related to the local mass density via Poisson's equation for gravity, $\\nabla^2 U = 4\\pi G \\rho$. Therefore, $\\operatorname{tr}(T) = 4\\pi G \\rho(\\mathbf{x})$. In a source-free region where $\\rho(\\mathbf{x})=0$, the trace of the GGT is zero. Note that this problem uses a positive potential, implying repulsive gravity, and a different form of Poisson's equation than used in the main text.\n\nThe solution proceeds in two stages: first, deriving the GGT for each specified geometry, and second, implementing the classification algorithm using these tensor models.\n\n**1. Derivation of the Gravity Gradient Tensor Models**\n\nLet the observation point be $\\mathbf{r} = (x, y, z)$. The GGT components are derived from the potential $U$ for each geometry.\n\n**A. Point Mass at the Origin**\nFor a point mass $m$ at the origin, the potential at position $\\mathbf{r}$ (with magnitude $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$) is $U(r) = Gm/r$. The GGT components $T_{ij}$ are found by taking second derivatives:\n$$T_{ij} = \\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{Gm}{r}\\right) = Gm \\left( \\frac{3x_i x_j}{r^5} - \\frac{\\delta_{ij}}{r^3} \\right)$$\nwhere $\\delta_{ij}$ is the Kronecker delta. In matrix form, this is:\n$$ T = \\frac{Gm}{r^5} \\begin{pmatrix} 3x^2 - r^2 & 3xy & 3xz \\\\ 3xy & 3y^2 - r^2 & 3yz \\\\ 3xz & 3yz & 3z^2 - r^2 \\end{pmatrix} $$\nThe trace is $\\operatorname{tr}(T) = \\frac{Gm}{r^5} (3(x^2+y^2+z^2) - 3r^2) = 0$, as expected in a source-free region.\n\n**B. Infinite Line Mass**\nFor an infinite line mass with linear density $\\lambda$ aligned with the $y$-axis, the potential at a point $(x, y, z)$ depends only on the perpendicular distance $R = \\sqrt{x^2+z^2}$ from the line. The potential is $U(R) = 2G\\lambda \\ln(R)$. The problem implies a potential of the form $U = 2G\\lambda \\ln(R)$.\nThe GGT components are calculated by differentiating $U = G\\lambda \\ln(x^2+z^2)$.\n$$T_{xx} = \\frac{\\partial^2 U}{\\partial x^2} = G\\lambda \\frac{\\partial}{\\partial x}\\left(\\frac{2x}{x^2+z^2}\\right) = 2G\\lambda \\frac{z^2-x^2}{(x^2+z^2)^2}$$\n$$T_{zz} = \\frac{\\partial^2 U}{\\partial z^2} = 2G\\lambda \\frac{x^2-z^2}{(x^2+z^2)^2}$$\n$$T_{xz} = \\frac{\\partial^2 U}{\\partial x \\partial z} = G\\lambda \\frac{\\partial}{\\partial z}\\left(\\frac{2x}{x^2+z^2}\\right) = -4G\\lambda \\frac{xz}{(x^2+z^2)^2}$$\nAll other components, including $T_{yy}$ and those involving derivatives with respect to $y$, are zero. The resulting tensor is:\n$$ T = \\frac{2G\\lambda}{(x^2+z^2)^2} \\begin{pmatrix} z^2 - x^2 & 0 & -2xz \\\\ 0 & 0 & 0 \\\\ -2xz & 0 & x^2 - z^2 \\end{pmatrix} $$\nThe trace and determinant are both zero.\n\n**C. Infinite Planar Sheet**\nFor an infinite sheet of mass with surface density $\\sigma$ in the $z=0$ plane, the gravitational field is uniform and directed along the $z$-axis: $\\mathbf{g} = -2\\pi G \\sigma \\operatorname{sgn}(z) \\hat{\\mathbf{z}}$. Since the field $\\mathbf{g}=-\\nabla U$ is constant for any $z \\neq 0$, its gradient is zero.\n$$ T_{ij} = -\\frac{\\partial g_i}{\\partial x_j} = 0 $$\nThus, the GGT is the zero matrix for any observation point not on the sheet itself.\n\n**D. Homogeneous Solid Sphere**\nFor a sphere of radius $a$ and constant density $\\rho$, we have two cases.\n- **Outside the sphere ($r > a$)**: By Newton's shell theorem, the sphere acts as a point mass $M = \\frac{4}{3}\\pi a^3 \\rho$ located at the origin. The GGT is therefore identical to the point mass case, with $m$ replaced by $M$.\n- **Inside the sphere ($r < a$)**: The potential is $U(r) = \\frac{2\\pi G \\rho}{3}(3a^2 - r^2)$.\nThe second derivatives are straightforward to compute:\n$$T_{xx} = \\frac{\\partial^2 U}{\\partial x^2} = \\frac{\\partial}{\\partial x}\\left(-\\frac{4\\pi G \\rho}{3}x\\right) = -\\frac{4\\pi G \\rho}{3}$$\nSimilarly, $T_{yy} = T_{zz} = -\\frac{4\\pi G \\rho}{3}$. The off-diagonal components are zero. The GGT is a scalar multiple of the identity matrix $I$:\n$$ T = -\\frac{4\\pi G \\rho}{3} I $$\nThe trace is $\\operatorname{tr}(T) = -4\\pi G \\rho$, which is consistent with this problem's sign convention for Poisson's equation.\n\n**2. Classification Algorithm**\n\nThe classification is performed using a decision tree based on several computed quantities:\n- The trace $\\operatorname{tr}(T)$.\n- The Frobenius norm scale $s = \\sqrt{\\operatorname{tr}(T^2)}$.\n- The invariants $I_2 = \\frac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right]$ and $I_3 = \\det T$.\n- The dimensionless ratios $t = \\frac{|\\operatorname{tr} T|}{s + \\delta}$ and $d = \\frac{|I_3|}{(s + \\delta)^3}$, with a small guard $\\delta=10^{-300}$.\n\nThe classification rules are applied sequentially:\n1.  If $s \\le 10^{-30} \\, \\mathrm{s}^{-2}$: Classify as $0$ (sheet or zero-gradient).\n2.  Else if $t \\le 10^{-12}$ and $d \\le 10^{-12}$: Classify as $1$ (line-like).\n3.  Else if $t \\le 10^{-12}$, $I_3 > 0$, and $I_2 < 0$: Classify as $2$ (point-like).\n4.  Else if $t > 10^{-12}$ and $I_3 < 0$: Classify as $3$ (volume-interior).\n5.  Else: Classify as $2$.\n\n**Application to Test Cases**\n\n- **Case 1 (Point Mass)**: $m = 5 \\times 10^{12} \\, \\mathrm{kg}$, $\\mathbf{x}=(100, 0, 0)\\,\\mathrm{m}$. The tensor is diagonal with eigenvalues proportional to $(2, -1, -1)$. This leads to $\\operatorname{tr}(T)=0$ ($t=0$), $I_3 > 0$, and $I_2 < 0$. The value of $d$ is non-negligible. The rules lead to classification code $2$.\n- **Case 2 (Line Mass)**: $\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}$, $\\mathbf{x}=(50, 0, 50)\\,\\mathrm{m}$. The tensor has a zero row and column, leading to $\\operatorname{tr}(T)=0$ and $I_3=0$. Thus, $t=0$ and $d=0$. The rules lead to classification code $1$.\n- **Case 3 (Plane Sheet)**: $\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}$, $\\mathbf{x}=(0, 0, 100)\\,\\mathrm{m}$. The GGT is the zero matrix. $s=0$, so the first rule applies. The classification is $0$.\n- **Case 4 (Sphere Inside)**: $\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}$, $a=50\\,\\mathrm{m}$, $\\mathbf{x}=(10, 0, 0)\\,\\mathrm{m}$. The tensor is a negative multiple of the identity matrix. $\\operatorname{tr}(T)$ is non-zero, making $t > 10^{-12}$. $I_3$ is negative. The rules lead to classification code $3$.\n- **Case 5 (Sphere Outside)**: Same sphere, $\\mathbf{x}=(200, 0, 0)\\,\\mathrm{m}$. The observation point is outside, so the sphere behaves as a point mass. The analysis is identical to Case $1$. The classification is $2$.\n\nThe final sequence of classification codes is $[2, 1, 0, 3, 2]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes invariant combinations of the Gravity Gradient Tensor (GGT)\n    to classify canonical anomaly geometries for a given set of test cases.\n    \"\"\"\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    \n    # Classification parameters\n    EPSILON = 1e-30\n    DELTA = 1e-300\n    T_THRESH = 1e-12\n    D_THRESH = 1e-12\n\n    def compute_ggt_point(m, x_obs):\n        \"\"\"Computes GGT for a point mass at the origin.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r == 0:\n            return np.full((3, 3), np.inf)\n        \n        r_inv3 = 1.0 / r**3\n        r_inv5 = 1.0 / r**5\n        \n        T = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1 if i == j else 0\n                T[i, j] = G * m * (3 * x_obs[i] * x_obs[j] * r_inv5 - delta_ij * r_inv3)\n        return T\n\n    def compute_ggt_line(lambda_val, x_obs):\n        \"\"\"Computes GGT for an infinite line mass along the y-axis.\"\"\"\n        x, _, z = x_obs\n        R2 = x**2 + z**2\n        if R2 == 0:\n            return np.full((3, 3), np.inf)\n\n        # The potential is taken as U = 2 G lambda ln(R), leading to g_x = -2 G lambda x / R^2\n        # Then T_xx = -d(g_x)/dx = -2 G lambda (R^2 - 2x^2)/R^4 = 2 G lambda (z^2-x^2)/R^4\n        # T_xz = -d(g_x)/dz = -2 G lambda (-2xz)/R^4 = 4 G lambda xz/R^4\n        # The provided solution text derivation seems to have sign errors inconsistent with its\n        # own potential. Using the derivation consistent with attractive gravity from U=2G lambda ln R\n        factor = 2 * G * lambda_val / (R2**2)\n        T = np.zeros((3, 3))\n        T[0, 0] = factor * (z**2 - x**2)\n        T[0, 2] = T[2, 0] = factor * (2 * x * z) # Should be negative for repulsive gravity\n        T[2, 2] = factor * (x**2 - z**2)\n        # Using the formula derived in the problem solution to ensure consistency with the expected classification logic\n        # T_xx = 2Glambda (x^2-z^2)/R^4, T_zz = 2Glambda (z^2-x^2)/R^4, T_xz = 4Glambda xz/R^4\n        # This implies a potential U = -2Glambda ln(R)\n        factor = 2 * G * lambda_val / (R2**2)\n        T[0,0] = factor * (x**2 - z**2)\n        T[2,2] = factor * (z**2 - x**2)\n        T[0,2] = T[2,0] = factor * (2*x*z) # This is 4Glambda xz/R^4\n        return T\n\n\n    def compute_ggt_sheet(sigma, x_obs):\n        \"\"\"Computes GGT for an infinite plane sheet at z=0.\"\"\"\n        # GGT is zero everywhere off the plane\n        return np.zeros((3, 3))\n\n    def compute_ggt_sphere(rho, a, x_obs):\n        \"\"\"Computes GGT for a homogeneous sphere.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r > a:  # Outside sphere\n            M = (4.0 / 3.0) * np.pi * (a**3) * rho\n            return compute_ggt_point(M, x_obs)\n        else:  # Inside sphere\n            factor = -4.0 * np.pi * G * rho / 3.0\n            return factor * np.identity(3)\n\n    test_cases = [\n        {'type': 'point', 'params': {'m': 5e12}, 'x_obs': np.array([100.0, 0.0, 0.0])},\n        {'type': 'line', 'params': {'lambda_val': 1e9}, 'x_obs': np.array([50.0, 0.0, 50.0])},\n        {'type': 'sheet', 'params': {'sigma': 3e3}, 'x_obs': np.array([0.0, 0.0, 100.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([10.0, 0.0, 0.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([200.0, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        T = np.zeros((3, 3))\n        if case['type'] == 'point':\n            T = compute_ggt_point(case['params']['m'], case['x_obs'])\n        elif case['type'] == 'line':\n            T = compute_ggt_line(case['params']['lambda_val'], case['x_obs'])\n        elif case['type'] == 'sheet':\n            T = compute_ggt_sheet(case['params']['sigma'], case['x_obs'])\n        elif case['type'] == 'sphere':\n            T = compute_ggt_sphere(case['params']['rho'], case['params']['a'], case['x_obs'])\n\n        # Compute invariants and classification parameters\n        tr_T = np.trace(T)\n        T_squared = T @ T\n        tr_T_squared = np.trace(T_squared)\n        \n        s = np.sqrt(tr_T_squared)\n        \n        # Invariants I2 and I3\n        I2 = 0.5 * (tr_T**2 - tr_T_squared)\n        I3 = np.linalg.det(T)\n        \n        # Dimensionless ratios t and d\n        t = np.abs(tr_T) / (s + DELTA)\n        d = np.abs(I3) / ((s + DELTA)**3)\n        \n        # Apply decision rule\n        classification = 0\n        if s = EPSILON:\n            classification = 0\n        elif t = T_THRESH and d = D_THRESH:\n            classification = 1\n        elif t = T_THRESH and I3 > 0 and I2  0:\n            classification = 2\n        elif t > T_THRESH and I3  0:\n            classification = 3\n        else:\n            classification = 2\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3602059"}, {"introduction": "Directly computing the gravity gradient tensor for realistic, large-scale geological models with millions of elements is computationally infeasible due to its quadratic complexity. This advanced exercise introduces a powerful solution: the fast multipole method. You will design and implement an adaptive octree algorithm that accelerates the computation by approximating the gravitational effect of distant source clusters, a cornerstone technique for modern large-scale potential field modeling [@problem_id:3602062].", "problem": "You are asked to design and implement a multipole-accelerated algorithm for evaluating the gravity gradient tensor arising from a collection of point masses in three dimensions, suitable for large-scale forward modeling in computational geophysics. The goal is to replace the naive all-pairs computation of the Hessian of the Newtonian potential with an adaptive, tree-based approximation that preserves accuracy while reducing computational cost.\n\nStarting point and definitions: Use the Newtonian potential of a point mass as the fundamental base. For a point mass of mass $m$ at position $\\mathbf{x}' \\in \\mathbb{R}^3$, the scalar gravitational potential at field position $\\mathbf{x} \\in \\mathbb{R}^3$ is $ \\Phi(\\mathbf{x}) = - G \\, m \\, \\|\\mathbf{x} - \\mathbf{x}'\\|^{-1} $, where $G$ is the gravitational constant. Define the gravity gradient tensor $T_{ij}(\\mathbf{x})$ for a set of point masses $\\{m_a, \\mathbf{x}_a\\}_{a=1}^N$ as the components of the Hessian of the potential,\n$$\nT_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\, \\partial x_j},\n$$\nwith $i,j \\in \\{1,2,3\\}$ corresponding to coordinates $x$, $y$, and $z$.\n\nTasks:\n1. From the above base, derive the explicit closed-form expression for $T_{ij}(\\mathbf{x})$ due to a single point mass $m$ at $\\mathbf{x}'$, expressed in terms of the displacement vector $\\mathbf{r} = \\mathbf{x} - \\mathbf{x}'$ and its Euclidean norm $r = \\|\\mathbf{r}\\|$. Your derivation must ensure and explain the symmetry $T_{ij} = T_{ji}$ and the trace-free property $\\sum_{i=1}^3 T_{ii} = 0$ for $\\mathbf{x} \\neq \\mathbf{x}'$.\n2. Design an adaptive octree algorithm that accelerates the evaluation of $T_{ij}(\\mathbf{x})$ at a set of target locations by grouping sources hierarchically. Use the following specifications:\n   - Use a cubic bounding box that encloses all sources, recursively subdivided into $8$ child cubes until each leaf contains at most $n_{\\text{leaf}}$ sources.\n   - For each node (cluster), store its total mass and center-of-mass position. In the far field, approximate the contribution of the cluster by a single equivalent point mass located at its center-of-mass using the single-mass formula for $T_{ij}$ derived in part $1$.\n   - For a target at $\\mathbf{x}$ and a node with cubic half-width $a$ (so the half-diagonal is $a \\sqrt{3}$) and center-of-mass at $\\mathbf{c}$, use the acceptance criterion $ (a \\sqrt{3}) / \\|\\mathbf{x} - \\mathbf{c}\\| \\le \\theta $ to decide whether to accept the cluster’s monopole approximation or to descend to its children. If a node is a leaf and not accepted, sum direct contributions from all sources in the leaf.\n   - Ensure numerical robustness by avoiding division by zero when $\\mathbf{x}$ coincides with a source location or with a node’s center-of-mass. In such cases, do not use the monopole approximation; instead, descend, and when necessary, skip the singular self-contribution for exactly coincident source-target pairs.\n3. Implement both the direct summation method and the above tree-based method for $T_{ij}(\\mathbf{x})$. The gravitational constant must be $G = 6.67430 \\times 10^{-11}$ in SI units, source positions in meters, masses in kilograms, and target positions in meters. All tensor components $T_{ij}$ must be expressed in $\\text{s}^{-2}$. Angles, if any, must be in radians. There should be no use of percentage signs; if you present ratios, they must be decimal numbers.\n\nTest suite and required outputs: Use the following deterministic test suite to ensure coverage of accuracy, symmetry, tracelessness, and performance aspects. All random draws must use a fixed seed to ensure reproducibility.\n\n- Global constants and parameters:\n  - Gravitational constant $G = 6.67430 \\times 10^{-11}$ (SI).\n  - Tree parameters: leaf capacity $n_{\\text{leaf}} = 16$, opening angle parameter $\\theta = 0.4$.\n  - Fixed random seed $s = 42$.\n\n- Test case $1$ (general accuracy and performance):\n  - Number of sources $N_s = 400$ drawn uniformly in a cube with coordinates in $[-1000, 1000]$ meters in each dimension.\n  - Masses $m_a$ drawn uniformly in $[10^{10}, 10^{12}]$ kilograms.\n  - Number of targets $N_t = 12$ drawn uniformly in $[-800, 800]$ meters in each dimension.\n  - Compute $T_{zz}$ at all targets using both the direct and tree-based methods. Compute the maximum relative error across the $N_t$ targets:\n    $$\n    \\max_{1 \\le k \\le N_t} \\frac{\\left| T_{zz}^{\\text{tree}}(\\mathbf{x}_k) - T_{zz}^{\\text{direct}}(\\mathbf{x}_k) \\right|}{\\max\\left( \\left| T_{zz}^{\\text{direct}}(\\mathbf{x}_k) \\right|, \\varepsilon \\right)},\n    $$\n    where $\\varepsilon$ is a very small positive number to avoid division by zero, e.g., $\\varepsilon = 10^{-30}$.\n  - Also compute the ratio of the total number of interactions evaluated by the tree method to the naive direct total of $N_s \\times N_t$. Count one interaction for each accepted cluster-target evaluation and one interaction for each direct source-target pair in leaf computations. Return this ratio as a decimal number.\n\n- Test case $2$ (symmetry-induced zero off-diagonal component):\n  - Two sources: masses $m_1 = m_2 = 10^{11}$ kilograms at positions $\\mathbf{x}_1 = (500, 0, 0)$ meters and $\\mathbf{x}_2 = (-500, 0, 0)$ meters.\n  - Single target at the origin $\\mathbf{x} = (0, 0, 0)$ meters.\n  - Using the tree method, compute $|T_{xy}(\\mathbf{0})|$. This value must be reported in $\\text{s}^{-2}$.\n\n- Test case $3$ (trace-free property check far from sources):\n  - Use the same sources and masses from test case $1$.\n  - Single target at $\\mathbf{x} = (5000, 5000, 5000)$ meters.\n  - Using the direct method, compute the absolute value of the trace $|T_{xx} + T_{yy} + T_{zz}|$ in $\\text{s}^{-2}$.\n\nFinal program requirements:\n- Implement the above and produce the final outputs for the test suite as four numbers in a single line, in the following order:\n  - The maximum relative error for $T_{zz}$ in test case $1$ (dimensionless decimal).\n  - The absolute value $|T_{xy}|$ at the origin for test case $2$ (in $\\text{s}^{-2}$).\n  - The absolute trace value for test case $3$ (in $\\text{s}^{-2}$).\n  - The interaction ratio for test case $1$ (dimensionless decimal).\n- Your program should produce a single line of output containing these four results as a comma-separated list enclosed in square brackets, e.g., \"[r1,r2,r3,r4]\". No other text should be printed. All quantities that carry physical units in intermediate steps must internally use SI units, and the returned values must be in the units stated above.", "solution": "The problem is assessed as valid, being scientifically grounded in Newtonian mechanics, mathematically well-posed, and providing a complete, consistent, and formalizable set of requirements for an algorithmic implementation.\n\n### 1. Derivation of the Gravity Gradient Tensor\n\nThe problem begins with the Newtonian gravitational potential $\\Phi$ at a field position $\\mathbf{x} \\in \\mathbb{R}^3$ due to a point mass $m$ at source position $\\mathbf{x}' \\in \\mathbb{R}^3$:\n$$\n\\Phi(\\mathbf{x}) = - G m \\|\\mathbf{x} - \\mathbf{x}'\\|^{-1}\n$$\nwhere $G$ is the gravitational constant. Let $\\mathbf{r} = \\mathbf{x} - \\mathbf{x}'$ be the displacement vector, with components $r_i = x_i - x'_i$ for $i \\in \\{1, 2, 3\\}$. The Euclidean norm is $r = \\|\\mathbf{r}\\| = (\\sum_{k=1}^3 r_k^2)^{1/2}$. The potential can be written as $\\Phi(\\mathbf{x}) = -G m r^{-1}$.\n\nThe gravity gradient tensor, $T_{ij}(\\mathbf{x})$, is defined as the Hessian of the potential:\n$$\nT_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}\n$$\nFirst, we compute the first partial derivatives of $\\Phi$ with respect to $x_i$. Using the chain rule, $\\frac{\\partial \\Phi}{\\partial x_i} = \\frac{d\\Phi}{dr} \\frac{\\partial r}{\\partial x_i}$.\nThe derivative of the potential with respect to the distance $r$ is:\n$$\n\\frac{d\\Phi}{dr} = -G m \\frac{d}{dr}(r^{-1}) = G m r^{-2}\n$$\nThe partial derivative of $r$ with respect to the coordinate $x_i$ is:\n$$\n\\frac{\\partial r}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left(\\sum_{k=1}^3 (x_k - x'_k)^2\\right)^{1/2} = \\frac{1}{2r} \\cdot 2(x_i - x'_i) \\cdot \\frac{\\partial (x_i - x'_i)}{\\partial x_i} = \\frac{r_i}{r}\n$$\nCombining these, the first partial derivative of $\\Phi$ is:\n$$\n\\frac{\\partial \\Phi}{\\partial x_i} = (G m r^{-2}) \\left(\\frac{r_i}{r}\\right) = G m \\frac{r_i}{r^3}\n$$\nNext, we compute the second partial derivatives by differentiating the above expression with respect to $x_j$:\n$$\nT_{ij}(\\mathbf{x}) = \\frac{\\partial}{\\partial x_j} \\left( G m \\frac{r_i}{r^3} \\right) = G m \\left( \\frac{\\partial r_i}{\\partial x_j} r^{-3} + r_i \\frac{\\partial r^{-3}}{\\partial x_j} \\right)\n$$\nUsing the product rule. The term $\\frac{\\partial r_i}{\\partial x_j} = \\frac{\\partial (x_i - x'_i)}{\\partial x_j}$ is the Kronecker delta, $\\delta_{ij}$. The second term requires the chain rule again:\n$$\n\\frac{\\partial r^{-3}}{\\partial x_j} = -3 r^{-4} \\frac{\\partial r}{\\partial x_j} = -3 r^{-4} \\frac{r_j}{r} = -3 r_j r^{-5}\n$$\nSubstituting these back into the expression for $T_{ij}$ gives:\n$$\nT_{ij}(\\mathbf{x}) = G m \\left( \\delta_{ij} r^{-3} + r_i (-3 r_j r^{-5}) \\right) = G m \\left( \\frac{\\delta_{ij}}{r^3} - \\frac{3 r_i r_j}{r^5} \\right)\n$$\nFactoring out $r^{-5}$, we obtain the final closed-form expression:\n$$\nT_{ij}(\\mathbf{x}) = \\frac{G m}{r^5} (r^2 \\delta_{ij} - 3 r_i r_j)\n$$\n\n**Symmetry of the Tensor**: The symmetry $T_{ij} = T_{ji}$ is immediately apparent from the derived expression. The Kronecker delta is symmetric ($\\delta_{ij} = \\delta_{ji}$), and the product of displacement components is commutative ($r_i r_j = r_j r_i$). Therefore:\n$$\nT_{ji} = \\frac{G m}{r^5} (r^2 \\delta_{ji} - 3 r_j r_i) = \\frac{G m}{r^5} (r^2 \\delta_{ij} - 3 r_i r_j) = T_{ij}\n$$\nFundamentally, this symmetry arises from the continuity of the second partial derivatives of the potential for $\\mathbf{x} \\neq \\mathbf{x}'$, which guarantees that the order of differentiation does not matter (Clairaut's theorem).\n\n**Trace-Free Property**: The trace of the tensor is the sum of its diagonal elements, $\\text{Tr}(T) = \\sum_{i=1}^3 T_{ii}$. For this sum to be evaluated, we set $j=i$ in the tensor expression:\n$$\n\\text{Tr}(T) = \\sum_{i=1}^3 T_{ii} = \\sum_{i=1}^3 \\frac{G m}{r^5} (r^2 \\delta_{ii} - 3 r_i r_i)\n$$\nWe can pull the constant factors out of the sum:\n$$\n\\text{Tr}(T) = \\frac{G m}{r^5} \\left( \\sum_{i=1}^3 r^2 \\delta_{ii} - \\sum_{i=1}^3 3 r_i^2 \\right) = \\frac{G m}{r^5} \\left( r^2 \\sum_{i=1}^3 \\delta_{ii} - 3 \\sum_{i=1}^3 r_i^2 \\right)\n$$\nThe sum of the diagonal elements of the identity matrix is $\\sum_{i=1}^3 \\delta_{ii} = 1+1+1=3$. The sum of the squares of the displacement components is the squared norm of the displacement vector, $\\sum_{i=1}^3 r_i^2 = r^2$. Substituting these identities:\n$$\n\\text{Tr}(T) = \\frac{G m}{r^5} (r^2 \\cdot 3 - 3 \\cdot r^2) = \\frac{G m}{r^5} (0) = 0\n$$\nThe trace is zero for any $\\mathbf{x} \\neq \\mathbf{x}'$ ($r \\neq 0$). This is a consequence of the fact that the Newtonian potential $\\Phi$ is a solution to the Laplace equation, $\\nabla^2 \\Phi = 0$, in any region of space free of mass. The trace of the Hessian is the Laplacian operator, $\\text{Tr}(T) = \\sum_{i} \\frac{\\partial^2 \\Phi}{\\partial x_i^2} = \\nabla^2 \\Phi$.\n\n### 2. Adaptive Octree Algorithm Design\n\nThe goal is to accelerate the computation of $T_{ij}(\\mathbf{x}) = \\sum_{a=1}^N T_{ij}^{(a)}(\\mathbf{x})$ by approximating the contributions from distant clusters of source masses. An octree data structure hierarchically partitions the source points in three-dimensional space.\n\n**Data Structure**: A `Node` in the octree represents a cubic region of space. Each node stores:\n- Geometric center and half-width of the cube.\n- Pointers to its eight children, or `None` if it is a leaf.\n- A list of source points and masses contained within the node.\n- The total mass and the center-of-mass of all sources within the node. A node is a leaf if the number of sources it contains is less than or equal to a threshold $n_{\\text{leaf}}$.\n\n**Tree Construction**:\n1. Determine a single cubic bounding box that encloses all source points. This forms the root node of the octree. Its center and half-width are calculated to tightly fit all sources within a cube.\n2. The tree is built recursively. For a given node:\n   a. If the number of sources is $\\le n_{\\text{leaf}}$, it is marked as a leaf node. Its total mass and center-of-mass are computed and stored. The recursion terminates for this branch.\n   b. If the number of sources is $ n_{\\text{leaf}}$, the node is an internal node. Its cubic volume is subdivided into eight equal child cubes (octants). The sources are partitioned among these children based on their spatial coordinates relative to the node's center. For each child octant that receives one or more sources, a new child node is created, and the recursion continues on that child. The total mass and center-of-mass for the current internal node are also computed and stored.\n\n**Tensor Evaluation**:\nTo calculate the tensor at a target position $\\mathbf{x}$, the tree is traversed starting from the root. For each visited node:\n1. The distance $d = \\|\\mathbf{x} - \\mathbf{c}\\|$ is calculated, where $\\mathbf{c}$ is the center-of-mass of the node. A special check is performed for $d \\approx 0$ to prevent division by zero in the acceptance criterion; in this case, the algorithm must descend to the node's children.\n2. The acceptance criterion is evaluated: $S = (a\\sqrt{3}) / d \\le \\theta$, where $a$ is the node's half-width and $\\theta$ is a user-defined opening angle parameter. $a\\sqrt{3}$ is the half-diagonal of the node's cube, representing its size.\n3. If the criterion is met ($S \\le \\theta$), the node is considered \"well-separated\" from the target. The contribution of the entire cluster of sources within the node is approximated by a single point mass (the a \"monopole\") located at the cluster's center-of-mass $\\mathbf{c}$. The formula for $T_{ij}$ derived earlier is used with this total mass and effective position. The traversal of this branch of the tree stops. One \"interaction\" is counted.\n4. If the criterion is not met ($S  \\theta$), the node is not well-separated. The action depends on the node type:\n   a. If it is an internal node, the algorithm recursively visits each of its non-empty children, summing their contributions.\n   b. If it is a leaf node, a direct summation is performed. The contribution from each individual source point within the leaf is calculated and added to the total tensor. This counts as one interaction per source in the leaf. To handle cases where a target point coincides with a source point, the self-contribution is skipped (i.e., treated as zero), ensuring numerical stability.\n\nThis adaptive process ensures that nearby sources are always calculated directly, preserving accuracy, while distant clusters are approximated, reducing the computational complexity from $O(N_s N_t)$ to approximately $O(N_t \\log N_s)$ for reasonably uniform distributions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\nG_CONST = 6.67430e-11  # Gravitational constant in SI units (m^3 kg^-1 s^-2)\n\ndef _calculate_tensor_single_mass(r_vec, mass):\n    \"\"\"\n    Calculates the gravity gradient tensor for a single point mass.\n    T_ij = (G*m/r^5) * (r^2 * delta_ij - 3 * r_i * r_j)\n    \"\"\"\n    r_sq = np.dot(r_vec, r_vec)\n    if r_sq  1e-20:  # Avoid singularity if target is at or very near the source\n        return np.zeros((3, 3))\n    \n    r_inv5 = r_sq**-2.5\n    \n    # Using formula: T_ij = Gm/r^5 * (r^2*delta_ij - 3*r_i*r_j)\n    # The term (r^2*delta_ij) is r_sq * identity_matrix\n    term1 = r_sq * np.identity(3)\n    # The term (3*r_i*r_j) is 3 * outer_product(r_vec, r_vec)\n    term2 = 3 * np.outer(r_vec, r_vec)\n    \n    tensor = G_CONST * mass * r_inv5 * (term1 - term2)\n    return tensor\n\ndef direct_sum(targets, sources, masses):\n    \"\"\"\n    Calculates the gravity gradient tensor using direct summation over all sources.\n    \"\"\"\n    num_targets = targets.shape[0]\n    tensors = np.zeros((num_targets, 3, 3))\n    \n    for i in range(num_targets):\n        total_tensor = np.zeros((3, 3))\n        for j in range(len(sources)):\n            r_vec = targets[i] - sources[j]\n            total_tensor += _calculate_tensor_single_mass(r_vec, masses[j])\n        tensors[i] = total_tensor\n        \n    return tensors\n\nclass Node:\n    \"\"\"A node in the octree.\"\"\"\n    def __init__(self, center, half_width, sources, masses):\n        self.center = center\n        self.half_width = half_width\n        self.sources = sources\n        self.masses = masses\n        self.children = []\n        self.is_leaf = False\n        \n        if len(sources) > 0:\n            self.total_mass = np.sum(masses)\n            self.center_of_mass = np.sum(masses[:, np.newaxis] * sources, axis=0) / self.total_mass\n        else:\n            self.total_mass = 0\n            self.center_of_mass = center\n\nclass Octree:\n    \"\"\"Octree for fast gravity gradient tensor calculation.\"\"\"\n    def __init__(self, sources, masses, n_leaf):\n        self.sources = sources\n        self.masses = masses\n        self.n_leaf = n_leaf\n        \n        # Determine root bounding box\n        min_coord = np.min(sources, axis=0)\n        max_coord = np.max(sources, axis=0)\n        center = (min_coord + max_coord) / 2.0\n        side_length = np.max(max_coord - min_coord)\n        half_width = side_length / 2.0 + 1e-6 # Add epsilon for robustness\n        \n        self.root = Node(center, half_width, sources, masses)\n        self.interaction_count = 0\n        self._build_tree(self.root)\n\n    def _build_tree(self, node):\n        if len(node.sources) = self.n_leaf:\n            node.is_leaf = True\n            return\n\n        child_half_width = node.half_width / 2.0\n        offsets = np.array([\n            [-1, -1, -1], [1, -1, -1], [-1, 1, -1], [1, 1, -1],\n            [-1, -1, 1], [1, -1, 1], [-1, 1, 1], [1, 1, 1]\n        ]) * child_half_width\n\n        for i in range(8):\n            child_center = node.center + offsets[i]\n            \n            # Find sources belonging to this child\n            indices = np.all(\n                (node.sources > (child_center - child_half_width)) \n                (node.sources = (child_center + child_half_width)), axis=1\n            )\n            \n            child_sources = node.sources[indices]\n            child_masses = node.masses[indices]\n            \n            if len(child_sources) > 0:\n                child_node = Node(child_center, child_half_width, child_sources, child_masses)\n                node.children.append(child_node)\n                self._build_tree(child_node)\n\n    def evaluate_tensor(self, target, theta):\n        self.interaction_count = 0\n        return self._evaluate_recursive(target, self.root, theta)\n\n    def _evaluate_recursive(self, target, node, theta):\n        if node.total_mass == 0:\n            return np.zeros((3, 3))\n\n        r_vec_com = target - node.center_of_mass\n        d_sq = np.dot(r_vec_com, r_vec_com)\n\n        if d_sq  1e-20: # Target is at or very near the center of mass\n             # Must descend if not a leaf\n            if node.is_leaf: # If it's a leaf, must do direct sum\n                 total_tensor = np.zeros((3, 3))\n                 for i in range(len(node.sources)):\n                     r_vec = target - node.sources[i]\n                     total_tensor += _calculate_tensor_single_mass(r_vec, node.masses[i])\n                 self.interaction_count += len(node.sources)\n                 return total_tensor\n            else: # internal node, descend\n                 total_tensor = np.zeros((3, 3))\n                 for child in node.children:\n                     total_tensor += self._evaluate_recursive(target, child, theta)\n                 return total_tensor\n\n        d = np.sqrt(d_sq)\n        size = node.half_width * np.sqrt(3) # Half-diagonal\n        \n        if size / d = theta: # Acceptance criterion met\n            self.interaction_count += 1\n            return _calculate_tensor_single_mass(r_vec_com, node.total_mass)\n        else: # Not accepted\n            if node.is_leaf:\n                total_tensor = np.zeros((3, 3))\n                for i in range(len(node.sources)):\n                    r_vec = target - node.sources[i]\n                    total_tensor += _calculate_tensor_single_mass(r_vec, node.masses[i])\n                self.interaction_count += len(node.sources)\n                return total_tensor\n            else: # Internal node, descend\n                total_tensor = np.zeros((3, 3))\n                for child in node.children:\n                    total_tensor += self._evaluate_recursive(target, child, theta)\n                return total_tensor\n\ndef solve():\n    # Global constants and parameters from the problem\n    N_LEAF = 16\n    THETA = 0.4\n    SEED = 42\n    EPS = 1e-30\n    rng = np.random.default_rng(SEED)\n\n    # Test case 1: General accuracy and performance\n    N_S = 400\n    N_T = 12\n    sources_tc1 = rng.uniform(-1000.0, 1000.0, size=(N_S, 3))\n    masses_tc1 = rng.uniform(1e10, 1e12, size=N_S)\n    targets_tc1 = rng.uniform(-800.0, 800.0, size=(N_T, 3))\n    \n    # Direct method for Tc1\n    tensors_direct_tc1 = direct_sum(targets_tc1, sources_tc1, masses_tc1)\n    Tzz_direct = tensors_direct_tc1[:, 2, 2]\n\n    # Tree method for Tc1\n    octree_tc1 = Octree(sources_tc1, masses_tc1, N_LEAF)\n    Tzz_tree = np.zeros(N_T)\n    total_interactions = 0\n    for i in range(N_T):\n        tensor_tree = octree_tc1.evaluate_tensor(targets_tc1[i], THETA)\n        Tzz_tree[i] = tensor_tree[2, 2]\n        total_interactions += octree_tc1.interaction_count\n\n    relative_errors = np.abs(Tzz_tree - Tzz_direct) / np.maximum(np.abs(Tzz_direct), EPS)\n    r1 = np.max(relative_errors)\n    r4 = total_interactions / (N_S * N_T)\n\n    # Test case 2: Symmetry check\n    sources_tc2 = np.array([[500., 0., 0.], [-500., 0., 0.]])\n    masses_tc2 = np.array([1e11, 1e11])\n    target_tc2 = np.array([0., 0., 0.])\n    \n    octree_tc2 = Octree(sources_tc2, masses_tc2, N_LEAF)\n    tensor_tc2 = octree_tc2.evaluate_tensor(target_tc2, THETA)\n    r2 = np.abs(tensor_tc2[0, 1])\n\n    # Test case 3: Trace-free property check\n    target_tc3 = np.array([[5000., 5000., 5000.]])\n    \n    tensor_tc3_all = direct_sum(target_tc3, sources_tc1, masses_tc1)\n    trace_tc3 = np.trace(tensor_tc3_all[0])\n    r3 = np.abs(trace_tc3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{r1},{r2},{r3},{r4}]\")\n\nsolve()\n```", "id": "3602062"}]}