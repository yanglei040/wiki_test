{"hands_on_practices": [{"introduction": "The foundation of magnetohydrodynamic (MHD) equilibrium is the precise balance between the pressure gradient force, $\\nabla p$, and the Lorentz force, $\\mathbf{j} \\times \\mathbf{B}$. This practice provides a direct computational method to assess how well a given magnetic field and pressure configuration satisfies this condition. By numerically calculating the residual force, you will develop a fundamental diagnostic tool used to validate both simulation results and experimental reconstructions of plasma equilibria [@problem_id:3721270].", "problem": "Consider a magnetohydrodynamic equilibrium in a toroidally axisymmetric tokamak cross-section, described in cylindrical coordinates $(R,\\phi,Z)$, where the magnetic field $\\mathbf{B}(R,Z)$ and pressure $p(R,Z)$ are axisymmetric (no $\\phi$ dependence). The fundamental base for this problem consists of the following laws and definitions, all in the International System of Units (SI): (i) Maxwell–Ampère law in magnetostatics $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j}$, with vacuum permeability $\\mu_0$, (ii) the force balance condition for static equilibrium $\\mathbf{j} \\times \\mathbf{B} = \\nabla p$, and (iii) the definition of the area-normalized $\\mathrm{L}^2$ norm over a rectangular domain in the $(R,Z)$-plane. From these bases, derive the expressions needed to compute the residual vector field $\\mathbf{r}(R,Z) = \\mathbf{j}(R,Z) \\times \\mathbf{B}(R,Z) - \\nabla p(R,Z)$ and then evaluate the area-normalized $\\mathrm{L}^2$ norm\n$$\n\\|\\mathbf{r}\\|_{A} = \\sqrt{\\frac{1}{A}\\int_{R_{\\min}}^{R_{\\max}}\\int_{Z_{\\min}}^{Z_{\\max}} \\left( r_R^2 + r_\\phi^2 + r_Z^2 \\right)\\, \\mathrm{d}Z\\,\\mathrm{d}R},\n$$\nwhere $A = (R_{\\max}-R_{\\min})(Z_{\\max}-Z_{\\min})$ is the cross-sectional area, and $r_R$, $r_\\phi$, $r_Z$ are the components of $\\mathbf{r}$ along the orthonormal basis $(\\hat{\\mathbf{e}}_R,\\hat{\\mathbf{e}}_\\phi,\\hat{\\mathbf{e}}_Z)$. The final numerical result must be expressed in $\\mathrm{N/m^3}$.\n\nYour program must implement the following procedure for each test case:\n- Discretize the rectangular domain $D = [R_{\\min},R_{\\max}] \\times [Z_{\\min},Z_{\\max}]$ uniformly with $N_R$ points in the $R$-direction and $N_Z$ points in the $Z$-direction. Use uniform spacings $\\Delta R$ and $\\Delta Z$ with $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ and $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$. All numerical derivatives must be approximated on this grid using finite differences that are consistent and self-contained on the domain (for example, central differences in the interior and one-sided differences at the boundaries).\n- Compute the current density $\\mathbf{j}(R,Z)$ from $\\mathbf{B}(R,Z)$ via the curl relation and the axisymmetry assumption.\n- Compute $\\nabla p(R,Z)$ from $p(R,Z)$ via spatial derivatives in $R$ and $Z$.\n- Form the residual field $\\mathbf{r}(R,Z)$ and evaluate $\\|\\mathbf{r}\\|_{A}$ using the area-normalized $\\mathrm{L}^2$ norm integral approximated by a Riemann sum on the grid.\n\nAll physical quantities must be handled in SI units: $R$ and $Z$ in $\\mathrm{m}$, $p$ in $\\mathrm{Pa}$, $\\mathbf{B}$ in $\\mathrm{T}$, $\\mu_0$ in $\\mathrm{N/A^2}$, $\\mathbf{j}$ in $\\mathrm{A/m^2}$, and the residual norm $\\|\\mathbf{r}\\|_{A}$ in $\\mathrm{N/m^3}$. Angles are not used directly in the computation; however, the coordinate $\\phi$ is implicit through axisymmetry.\n\nUse the following test suite, which specifies the domain, grid resolution, and prescribed analytic fields for $\\mathbf{B}(R,Z)$ and $p(R,Z)$. The toroidal field uses a standard vacuum scaling $B_\\phi(R) = B_0 R_0 / R$. Constants are: $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{N/A^2}$, $B_0 = 5\\,\\mathrm{T}$, $R_0 = 2\\,\\mathrm{m}$, $p_0 = 1\\times 10^{5}\\,\\mathrm{Pa}$, $a = 0.5\\,\\mathrm{T/m}$, $b = 0.8\\,\\mathrm{T/m}$. The rectangular domain is $R \\in [1.5, 2.5]\\,\\mathrm{m}$ and $Z \\in [-0.5, 0.5]\\,\\mathrm{m}$ for all cases.\n\nTest case $1$ (happy path, exact vacuum toroidal field with constant pressure):\n- $N_R = 81$, $N_Z = 81$.\n- $B_R(R,Z) = 0$, $B_\\phi(R,Z) = B_0 R_0 / R$, $B_Z(R,Z) = 0$.\n- $p(R,Z) = p_0$.\n\nTest case $2$ (equilibrium with poloidal field and matching pressure gradient):\n- $N_R = 101$, $N_Z = 101$.\n- $B_R(R,Z) = 0$, $B_\\phi(R,Z) = B_0 R_0 / R$, $B_Z(R,Z) = a R$.\n- $p(R,Z) = -\\dfrac{a^2}{2\\mu_0} R^2 + p_0$.\n\nTest case $3$ (non-equilibrium: same magnetic field as test case $2$ but constant pressure):\n- $N_R = 101$, $N_Z = 101$.\n- $B_R(R,Z) = 0$, $B_\\phi(R,Z) = B_0 R_0 / R$, $B_Z(R,Z) = a R$.\n- $p(R,Z) = p_0$.\n\nTest case $4$ (edge case with coarse grid and $Z$-dependent radial field, matching pressure gradient):\n- $N_R = 5$, $N_Z = 5$.\n- $B_R(R,Z) = b Z$, $B_\\phi(R,Z) = B_0 R_0 / R$, $B_Z(R,Z) = 0$.\n- $p(R,Z) = -\\dfrac{b^2}{2\\mu_0} Z^2 + p_0$.\n\nYour program should produce a single line of output containing the residual norms for the four test cases, in $\\mathrm{N/m^3}$, as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$). No other text should be printed. All computations must be self-contained and use the specified domain and fields directly; no external input is allowed.", "solution": "We start from the fundamental magnetohydrodynamic (MHD) equilibrium principle $\\mathbf{j} \\times \\mathbf{B} = \\nabla p$ and Maxwell–Ampère law $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j}$ in magnetostatics, where $\\mu_0$ is the vacuum permeability. The goal is to assess equilibrium consistency by computing the residual vector field $\\mathbf{r}(R,Z) = \\mathbf{j} \\times \\mathbf{B} - \\nabla p$ and its area-normalized $\\mathrm{L}^2$ norm over the $(R,Z)$ cross-section.\n\nCoordinate framework and axisymmetry: We work in cylindrical coordinates $(R,\\phi,Z)$ with orthonormal basis $(\\hat{\\mathbf{e}}_R,\\hat{\\mathbf{e}}_\\phi,\\hat{\\mathbf{e}}_Z)$ and assume axisymmetry, i.e., $\\partial/\\partial \\phi = 0$. Under this assumption, the magnetic field has components $\\mathbf{B}(R,Z) = B_R(R,Z)\\,\\hat{\\mathbf{e}}_R + B_\\phi(R,Z)\\,\\hat{\\mathbf{e}}_\\phi + B_Z(R,Z)\\,\\hat{\\mathbf{e}}_Z$ and the pressure depends only on $(R,Z)$, so $\\nabla p = \\dfrac{\\partial p}{\\partial R}\\,\\hat{\\mathbf{e}}_R + \\dfrac{\\partial p}{\\partial Z}\\,\\hat{\\mathbf{e}}_Z$.\n\nCurrent density from the curl in cylindrical coordinates with axisymmetry: Using the general curl operator in cylindrical coordinates specialized to $\\partial/\\partial \\phi = 0$, the components of $\\nabla \\times \\mathbf{B}$ are\n$$\n(\\nabla \\times \\mathbf{B})_R = -\\frac{\\partial B_\\phi}{\\partial Z}, \\quad\n(\\nabla \\times \\mathbf{B})_\\phi = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R}, \\quad\n(\\nabla \\times \\mathbf{B})_Z = \\frac{1}{R}\\frac{\\partial (R B_\\phi)}{\\partial R}.\n$$\nBy Maxwell–Ampère, $\\mathbf{j} = \\dfrac{1}{\\mu_0}\\nabla \\times \\mathbf{B}$, hence\n$$\nj_R = -\\frac{1}{\\mu_0}\\frac{\\partial B_\\phi}{\\partial Z}, \\quad\nj_\\phi = \\frac{1}{\\mu_0}\\left(\\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R}\\right), \\quad\nj_Z = \\frac{1}{\\mu_0}\\frac{1}{R}\\frac{\\partial (R B_\\phi)}{\\partial R}.\n$$\n\nResidual vector field: With $\\mathbf{f} = \\mathbf{j} \\times \\mathbf{B}$, the components in the orthonormal basis are given by the standard determinant (cross product) relations:\n$$\nf_R = j_\\phi B_Z - j_Z B_\\phi, \\quad\nf_\\phi = j_Z B_R - j_R B_Z, \\quad\nf_Z = j_R B_\\phi - j_\\phi B_R.\n$$\nThe pressure gradient is $\\nabla p = \\left(\\dfrac{\\partial p}{\\partial R}\\right)\\hat{\\mathbf{e}}_R + \\left(\\dfrac{\\partial p}{\\partial Z}\\right)\\hat{\\mathbf{e}}_Z$, so the residual components are\n$$\nr_R = f_R - \\frac{\\partial p}{\\partial R}, \\quad\nr_\\phi = f_\\phi, \\quad\nr_Z = f_Z - \\frac{\\partial p}{\\partial Z}.\n$$\n\nNorm definition and discretization: The area-normalized $\\mathrm{L}^2$ norm is\n$$\n\\|\\mathbf{r}\\|_{A} = \\sqrt{\\frac{1}{A}\\int_{D} \\left( r_R^2 + r_\\phi^2 + r_Z^2 \\right)\\, \\mathrm{d}R\\,\\mathrm{d}Z},\n$$\nwith $D = [R_{\\min},R_{\\max}] \\times [Z_{\\min},Z_{\\max}]$ and $A = (R_{\\max}-R_{\\min})(Z_{\\max}-Z_{\\min})$. On a uniform grid with spacings $\\Delta R$ and $\\Delta Z$, we approximate the integral by a Riemann sum:\n$$\n\\int_{D} g(R,Z)\\,\\mathrm{d}R\\,\\mathrm{d}Z \\approx \\sum_{i=1}^{N_R}\\sum_{k=1}^{N_Z} g(R_i,Z_k)\\, \\Delta R\\,\\Delta Z,\n$$\nwhere $g(R,Z) = r_R^2 + r_\\phi^2 + r_Z^2$. Thus,\n$$\n\\|\\mathbf{r}\\|_{A} \\approx \\sqrt{\\frac{\\Delta R\\,\\Delta Z}{A} \\sum_{i,k} \\left( r_R(R_i,Z_k)^2 + r_\\phi(R_i,Z_k)^2 + r_Z(R_i,Z_k)^2 \\right)}.\n$$\nNumerical derivatives $\\dfrac{\\partial}{\\partial R}$ and $\\dfrac{\\partial}{\\partial Z}$ are computed using finite differences on the uniform grid; central differences in the interior and one-sided differences at the boundaries ensure a consistent, self-contained approximation.\n\nTest case analysis:\n- Test case $1$: $B_R = 0$, $B_\\phi = B_0 R_0/R$, $B_Z = 0$, $p = p_0$. Here $R B_\\phi = B_0 R_0$ is constant, and there is no $Z$-dependence. Therefore $j_R = 0$, $j_Z = 0$, $j_\\phi = 0$. Hence $\\mathbf{j} \\times \\mathbf{B} = \\mathbf{0}$ and $\\nabla p = \\mathbf{0}$, so $\\mathbf{r} = \\mathbf{0}$ and $\\|\\mathbf{r}\\|_{A}$ should be numerically near zero, limited only by floating-point and finite-difference round-off.\n- Test case $2$: $B_R = 0$, $B_\\phi = B_0 R_0/R$, $B_Z = a R$, $p(R,Z) = -\\dfrac{a^2}{2\\mu_0}R^2 + p_0$. We have $j_R = 0$, $j_Z = 0$, $j_\\phi = -\\dfrac{a}{\\mu_0}$. Then $\\mathbf{j} \\times \\mathbf{B}$ has only a radial component $f_R = j_\\phi B_Z = -\\dfrac{a}{\\mu_0}\\cdot a R = -\\dfrac{a^2}{\\mu_0} R$. The pressure gradient $\\dfrac{\\partial p}{\\partial R} = -\\dfrac{a^2}{\\mu_0} R$ and $\\dfrac{\\partial p}{\\partial Z} = 0$, so $\\mathbf{r} = \\mathbf{0}$ exactly; numerically, $\\|\\mathbf{r}\\|_{A}$ should be near zero.\n- Test case $3$: Same $\\mathbf{B}$ as test case $2$ but $p = p_0$. Then $\\nabla p = \\mathbf{0}$ while $\\mathbf{f}$ as above has $f_R = -\\dfrac{a^2}{\\mu_0} R$. Therefore $r_R = -\\dfrac{a^2}{\\mu_0} R$, $r_\\phi = 0$, $r_Z = 0$. The norm is\n$$\n\\|\\mathbf{r}\\|_{A} = \\frac{a^2}{\\mu_0}\\sqrt{\\frac{1}{A}\\int_{Z_{\\min}}^{Z_{\\max}}\\int_{R_{\\min}}^{R_{\\max}} R^2\\, \\mathrm{d}R\\,\\mathrm{d}Z}\n= \\frac{a^2}{\\mu_0}\\sqrt{\\frac{Z_{\\max}-Z_{\\min}}{A}\\cdot \\frac{R_{\\max}^3 - R_{\\min}^3}{3}},\n$$\nwhich serves as a consistency check for the numerical implementation.\n- Test case $4$: $B_R = b Z$, $B_\\phi = B_0 R_0/R$, $B_Z = 0$, $p(R,Z) = -\\dfrac{b^2}{2\\mu_0}Z^2 + p_0$. Axisymmetry and $B_\\phi$ independent of $Z$ imply $j_R = 0$, $j_Z = 0$, and $j_\\phi = \\dfrac{b}{\\mu_0}$. Then $f_Z = -j_\\phi B_R = -\\dfrac{b}{\\mu_0}\\cdot b Z = -\\dfrac{b^2}{\\mu_0} Z$. The pressure gradient $\\dfrac{\\partial p}{\\partial Z} = -\\dfrac{b^2}{\\mu_0} Z$, so $\\mathbf{r} = \\mathbf{0}$ and $\\|\\mathbf{r}\\|_{A}$ should be near zero. The coarse grid primarily tests boundary derivative handling.\n\nAlgorithmic design:\n- Construct uniform grids in $R$ and $Z$ using the prescribed $R$ and $Z$ ranges and $(N_R,N_Z)$.\n- Evaluate $B_R$, $B_\\phi$, $B_Z$, and $p$ on the grid.\n- Use finite differences to approximate $\\dfrac{\\partial B_\\phi}{\\partial Z}$, $\\dfrac{\\partial (R B_\\phi)}{\\partial R}$, $\\dfrac{\\partial B_R}{\\partial Z}$, $\\dfrac{\\partial B_Z}{\\partial R}$, $\\dfrac{\\partial p}{\\partial R}$, and $\\dfrac{\\partial p}{\\partial Z}$ consistently.\n- Compute $\\mathbf{j}$ via the axisymmetric curl relations and then $\\mathbf{f} = \\mathbf{j} \\times \\mathbf{B}$.\n- Form $\\mathbf{r}$, accumulate $\\sum (r_R^2 + r_\\phi^2 + r_Z^2)$, multiply by $\\Delta R\\,\\Delta Z$, divide by $A$, and take the square root to produce $\\|\\mathbf{r}\\|_{A}$ in $\\mathrm{N/m^3}$.\n- Repeat for all test cases and report the norms in the prescribed single-line format.\n\nThis approach adheres strictly to the fundamental laws, uses unit-consistent computations, and provides a robust numerical assessment of equilibrium consistency across diverse scenarios.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constant: vacuum permeability (SI units)\nMU0 = 4.0 * np.pi * 1e-7  # N/A^2\n\n# Domain bounds (meters)\nR_MIN = 1.5\nR_MAX = 2.5\nZ_MIN = -0.5\nZ_MAX = 0.5\n\n# Parameters (SI units)\nB0 = 5.0      # Tesla\nR0 = 2.0      # meters\np0 = 1.0e5    # Pascals\na = 0.5       # Tesla/meter\nb = 0.8       # Tesla/meter\n\ndef compute_residual_norm(NR, NZ, B_funcs, p_func):\n    \"\"\"\n    Compute the area-normalized L2 norm of the residual r = j x B - grad p\n    over the rectangular domain [R_MIN,R_MAX] x [Z_MIN,Z_MAX] using a uniform grid.\n\n    Parameters:\n    - NR, NZ: number of grid points in R and Z directions (integers >= 3 recommended)\n    - B_funcs: function (R_grid, Z_grid) -> (B_R, B_phi, B_Z) arrays of shape (NR, NZ)\n    - p_func: function (R_grid, Z_grid) -> p array of shape (NR, NZ)\n\n    Returns:\n    - residual norm (float) in N/m^3\n    \"\"\"\n    # Create uniform grid\n    R = np.linspace(R_MIN, R_MAX, NR)\n    Z = np.linspace(Z_MIN, Z_MAX, NZ)\n    dR = (R_MAX - R_MIN) / (NR - 1)\n    dZ = (Z_MAX - Z_MIN) / (NZ - 1)\n    RR, ZZ = np.meshgrid(R, Z, indexing='ij')  # arrays of shape (NR, NZ)\n\n    # Evaluate fields\n    B_R, B_phi, B_Z = B_funcs(RR, ZZ)\n    p = p_func(RR, ZZ)\n\n    # Compute derivatives using finite differences via np.gradient\n    # np.gradient returns derivatives along each axis with provided spacing.\n    # Axis 0 corresponds to R, axis 1 corresponds to Z.\n\n    # dB_phi/dZ\n    dBphi_dZ = np.gradient(B_phi, dR, dZ, axis=(0, 1))[1]\n    # d(R B_phi)/dR\n    RBphi = RR * B_phi\n    dRBphi_dR = np.gradient(RBphi, dR, dZ, axis=(0, 1))[0]\n    # dB_R/dZ and dB_Z/dR\n    dBR_dZ = np.gradient(B_R, dR, dZ, axis=(0, 1))[1]\n    dBZ_dR = np.gradient(B_Z, dR, dZ, axis=(0, 1))[0]\n    # dp/dR and dp/dZ\n    dp_dR = np.gradient(p, dR, dZ, axis=(0, 1))[0]\n    dp_dZ = np.gradient(p, dR, dZ, axis=(0, 1))[1]\n\n    # Current density components from axisymmetric curl relations\n    j_R = -(1.0 / MU0) * dBphi_dZ\n    j_phi = (1.0 / MU0) * (dBR_dZ - dBZ_dR)\n    # Avoid division by zero for j_Z by ensuring RR > 0 (domain ensures RR >= 1.5)\n    j_Z = (1.0 / MU0) * (1.0 / RR) * dRBphi_dR\n\n    # Cross product f = j x B components\n    f_R = j_phi * B_Z - j_Z * B_phi\n    f_phi = j_Z * B_R - j_R * B_Z\n    f_Z = j_R * B_phi - j_phi * B_R\n\n    # Residual components r = f - grad p\n    r_R = f_R - dp_dR\n    r_phi = f_phi  # grad p has no phi component\n    r_Z = f_Z - dp_dZ\n\n    # Area-normalized L2 norm\n    A = (R_MAX - R_MIN) * (Z_MAX - Z_MIN)\n    integrand = r_R**2 + r_phi**2 + r_Z**2\n    integral_approx = np.sum(integrand) * dR * dZ\n    norm = np.sqrt(integral_approx / A)\n\n    return float(norm)\n\ndef case1_B(RR, ZZ):\n    # B_R = 0, B_phi = B0*R0/R, B_Z = 0\n    B_R = np.zeros_like(RR)\n    B_phi = B0 * R0 / RR\n    B_Z = np.zeros_like(RR)\n    return B_R, B_phi, B_Z\n\ndef case1_p(RR, ZZ):\n    # p = p0\n    return p0 * np.ones_like(RR)\n\ndef case2_B(RR, ZZ):\n    # B_R = 0, B_phi = B0*R0/R, B_Z = a*R\n    B_R = np.zeros_like(RR)\n    B_phi = B0 * R0 / RR\n    B_Z = a * RR\n    return B_R, B_phi, B_Z\n\ndef case2_p(RR, ZZ):\n    # p = -(a^2/(2*MU0)) * R^2 + p0\n    return (-(a**2) / (2.0 * MU0) * (RR**2)) + p0\n\ndef case3_B(RR, ZZ):\n    # Same as case2_B\n    return case2_B(RR, ZZ)\n\ndef case3_p(RR, ZZ):\n    # p = p0\n    return p0 * np.ones_like(RR)\n\ndef case4_B(RR, ZZ):\n    # B_R = b*Z, B_phi = B0*R0/R, B_Z = 0\n    B_R = b * ZZ\n    B_phi = B0 * R0 / RR\n    B_Z = np.zeros_like(RR)\n    return B_R, B_phi, B_Z\n\ndef case4_p(RR, ZZ):\n    # p = -(b^2/(2*MU0)) * Z^2 + p0\n    return (-(b**2) / (2.0 * MU0) * (ZZ**2)) + p0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (NR, NZ, B_funcs, p_func)\n        (81, 81, case1_B, case1_p),\n        (101, 101, case2_B, case2_p),\n        (101, 101, case3_B, case3_p),\n        (5, 5, case4_B, case4_p),\n    ]\n\n    results = []\n    for NR, NZ, Bf, pf in test_cases:\n        result = compute_residual_norm(NR, NZ, Bf, pf)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3721270"}, {"introduction": "While verifying an equilibrium is a crucial diagnostic step, finding an equilibrium requires solving the governing Grad-Shafranov equation. This exercise guides you through the process of discretizing this key partial differential equation using the Finite Element Method (FEM), a powerful technique widely used in computational physics. By translating the equation into its 'weak form' and constructing the associated matrices, you will gain hands-on experience in building the core of a numerical equilibrium solver [@problem_id:3721297].", "problem": "You are to derive and implement a finite element discretization for the axisymmetric magnetohydrodynamic equilibrium known as the Grad-Shafranov equation in cylindrical coordinates with radial coordinate $R$ and vertical coordinate $Z$, starting from first principles appropriate to nuclear fusion plasmas. Use the physical starting point of static Magnetohydrodynamics (MHD) equilibrium, where the force balance law is $ \\nabla p = \\mathbf{j} \\times \\mathbf{B} $, together with Ampère's law $ \\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j} $ and axisymmetry (no dependence on the toroidal angle). From these, derive the governing Partial Differential Equation (PDE) for the poloidal flux function $ \\psi(R,Z) $ that represents the Grad-Shafranov equilibrium. Then obtain a weak form by multiplying the PDE by an admissible test function $ v(R,Z) $ and integrating over the poloidal cross-section domain, applying integration by parts carefully to isolate stiffness-type terms (containing spatial derivatives of $ \\psi $ and $ v $) and source-type terms (containing prescribed functions and data). Clearly state the resulting weak integrals in terms of $ (R,Z) $ for:\n- the stiffness terms that involve $ \\partial_R \\psi $ and $ \\partial_Z \\psi $ paired against derivatives of $ v $ in $ (R,Z) $, and\n- the source terms driven by radial weighting and profiles of pressure and toroidal field.\n\nDiscretize the weak form using the Finite Element Method (FEM) with first-order (linear) triangular elements over a rectangular domain $ \\Omega = \\{ (R,Z) : R \\in [1,2], Z \\in [0,1] \\} $. Use a mesh of four nodes located at $ (R,Z) = (1,0), (2,0), (1,1), (2,1) $ and two triangles: element $ e_0 $ with nodes $ (1,0),(2,0),(1,1) $ and element $ e_1 $ with nodes $ (2,0),(2,1),(1,1) $. Let the shape functions on each element be $ N_i(R,Z) $ for local node indices $ i \\in \\{1,2,3\\} $, with $ \\psi(R,Z) \\approx \\sum_i \\psi_i N_i(R,Z) $ and $ v(R,Z) = N_j(R,Z) $ serving as test functions. Express the stiffness integrals for the symmetric gradient part $ \\int_{\\Omega} \\left( \\partial_R \\psi \\, \\partial_R v + \\partial_Z \\psi \\, \\partial_Z v \\right) \\, \\mathrm{d}\\Omega $, the non-symmetric first-order term $ \\int_{\\Omega} \\frac{1}{R} \\partial_R \\psi \\, v \\, \\mathrm{d}\\Omega $, and the profile-driven source integrals $ \\int_{\\Omega} s(R,\\psi) \\, v \\, \\mathrm{d}\\Omega $ in terms of $ N_i $, $ \\partial_R N_i $, $ \\partial_Z N_i $. Here let the pressure and toroidal field be parameterized by $ p'(\\psi) = \\alpha $ (constant) and $ F(\\psi) = \\beta \\psi $, so that $ F(\\psi) F'(\\psi) = \\beta^2 \\psi $. With these parameterizations, split the weak form into:\n- a gradient stiffness matrix with entries $ K_{ij} $,\n- a non-symmetric convection-like matrix with entries $ C_{ij} $ arising from the $ (1/R) $ weight times $ \\partial_R \\psi $,\n- a reaction (mass-like) matrix with entries $ M_{ij} $ proportional to $ \\beta^2 $ and the product $ N_i N_j $,\n- and a source vector with entries $ f_j $ containing the term $ \\mu_0 \\alpha R^2 N_j $.\n\nYour program must assemble the global matrices $ K $, $ C $, $ M $ and the global source vector $ f $ for the described mesh using the following element-level formulations:\n- $ K_{ij}^{(e)} = \\int_{e} \\left( \\partial_R N_i \\, \\partial_R N_j + \\partial_Z N_i \\, \\partial_Z N_j \\right) \\, \\mathrm{d}e $,\n- $ C_{ij}^{(e)} = \\int_{e} \\frac{1}{R} \\, \\partial_R N_i \\, N_j \\, \\mathrm{d}e $,\n- $ M_{ij}^{(e)} = \\int_{e} \\frac{1}{2} \\beta^2 \\, N_i \\, N_j \\, \\mathrm{d}e $,\n- $ f_{j}^{(e)} = \\int_{e} \\mu_0 \\alpha R^2 \\, N_j \\, \\mathrm{d}e $.\n\nFor first-order triangles, use the known constant gradients $ \\partial_R N_i = b_i $ and $ \\partial_Z N_i = c_i $ obtained from the coordinates of the triangle, and compute $ K_{ij}^{(e)} = (b_i b_j + c_i c_j) A_e $ exactly, where $ A_e $ is the element area. For $ C_{ij}^{(e)} $ and $ f_j^{(e)} $, evaluate the integrals numerically with a symmetric three-point barycentric quadrature that is exact for quadratic polynomials, using barycentric points $ (1/6, 1/6, 2/3) $, $ (1/6, 2/3, 1/6) $, $ (2/3, 1/6, 1/6) $ with equal weights $ 1/3 $; map those barycentric coordinates to $ (R,Z) $ within each triangle via $ (R,Z) = \\sum_k \\lambda_k (R_k, Z_k) $. For $ M_{ij}^{(e)} $, you may use the exact formula for linear elements $ \\int_{e} N_i N_j \\, \\mathrm{d}e = A_e/6 $ if $ i=j $ and $ A_e/12 $ if $ i \\neq j $.\n\nUse the International System of Units (SI) for all quantities. Take the magnetic permeability $ \\mu_0 = 4 \\pi \\times 10^{-7} $ in SI units. Treat $ \\alpha $ and $ \\beta $ as SI-consistent constants. Your program should assemble the global $ 4 \\times 4 $ matrices $ K $, $ C $, $ M $ and the global $ 4 $-vector $ f $ for the mesh and then output, for each specified test case, the sums of all entries of $ K $, $ C $, $ M $, and the sum of entries of $ f $ as four floating-point numbers. Express the final outputs in SI units as pure decimal numbers (no unit symbols in the output string).\n\nTest Suite:\n- Case $1$: $ \\alpha = 2.0 \\times 10^{4} $, $ \\beta = 0.0 $.\n- Case $2$: $ \\alpha = 0.0 $, $ \\beta = 1.0 $.\n- Case $3$: $ \\alpha = 5.0 \\times 10^{4} $, $ \\beta = 0.5 $.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of three lists, one per test case. Each inner list must be $ [S_K, S_C, S_M, S_f] $, where $ S_K $ is the sum of all entries of $ K $, $ S_C $ is the sum of all entries of $ C $, $ S_M $ is the sum of all entries of $ M $, and $ S_f $ is the sum of all entries of $ f $. For example, the output should look like $ [[x_1,x_2,x_3,x_4],[y_1,y_2,y_3,y_4],[z_1,z_2,z_3,z_4]] $ where each $ x_i, y_i, z_i $ are decimal numbers.", "solution": "We begin from the static Magnetohydrodynamics (MHD) equilibrium condition $ \\nabla p = \\mathbf{j} \\times \\mathbf{B} $ and Ampère's law $ \\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j} $ with axisymmetry (no toroidal angle dependence). Introduce cylindrical coordinates $ (R,\\phi,Z) $ and the poloidal flux function $ \\psi(R,Z) $ such that the magnetic field decomposes as $ \\mathbf{B} = \\mathbf{B}_{\\text{pol}} + \\mathbf{B}_{\\phi} $, where $ \\mathbf{B}_{\\text{pol}} = \\frac{1}{R} \\nabla \\psi \\times \\hat{\\boldsymbol{\\phi}} $ and $ \\mathbf{B}_{\\phi} = \\frac{F(\\psi)}{R} \\hat{\\boldsymbol{\\phi}} $. The quantities $ p(\\psi) $ and $ F(\\psi) $ are flux functions by axisymmetry. Combining $ \\nabla p = \\mathbf{j} \\times \\mathbf{B} $ and $ \\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{j} $ with the above representation yields the Grad-Shafranov equation,\n$$\n\\Delta^* \\psi = - \\mu_0 R^2 \\frac{\\mathrm{d} p}{\\mathrm{d}\\psi} - \\frac{1}{2} \\frac{\\mathrm{d} (F^2)}{\\mathrm{d}\\psi},\n$$\nwhere $ \\Delta^* \\psi = R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right ) + \\frac{\\partial^2 \\psi}{\\partial Z^2} = \\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2} $. This governing equation follows directly from the divergence form $ \\Delta^* \\psi = R \\nabla \\cdot \\left( \\frac{1}{R} \\nabla \\psi \\right ) $ and the axisymmetric force balance with flux functions $ p(\\psi) $ and $ F(\\psi) $.\n\nTo construct the weak form, multiply the PDE by a test function $ v(R,Z) $ and integrate over the poloidal cross-section $ \\Omega $:\n$$\n\\int_{\\Omega} \\left( \\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2} \\right) v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\left( - \\mu_0 R^2 \\frac{\\mathrm{d} p}{\\mathrm{d}\\psi} - \\frac{1}{2} F(\\psi) \\frac{\\mathrm{d} F}{\\mathrm{d}\\psi} \\right) v \\, \\mathrm{d}\\Omega.\n$$\nIntegrating by parts the second derivatives, and assuming Dirichlet-type boundary conditions that eliminate boundary terms, one obtains\n$$\n- \\int_{\\Omega} \\frac{\\partial \\psi}{\\partial R} \\frac{\\partial v}{\\partial R} \\, \\mathrm{d}\\Omega - \\int_{\\Omega} \\frac{\\partial \\psi}{\\partial Z} \\frac{\\partial v}{\\partial Z} \\, \\mathrm{d}\\Omega - \\int_{\\Omega} \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\left( - \\mu_0 R^2 \\frac{\\mathrm{d} p}{\\mathrm{d}\\psi} - \\frac{1}{2} F(\\psi) \\frac{\\mathrm{d} F}{\\mathrm{d}\\psi} \\right) v \\, \\mathrm{d}\\Omega.\n$$\nMultiplying both sides by $ -1 $ and recognizing the decomposition into stiffness and source parts yields\n$$\n\\int_{\\Omega} \\left( \\frac{\\partial \\psi}{\\partial R} \\frac{\\partial v}{\\partial R} + \\frac{\\partial \\psi}{\\partial Z} \\frac{\\partial v}{\\partial Z} \\right) \\, \\mathrm{d}\\Omega + \\int_{\\Omega} \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\left( \\mu_0 R^2 \\frac{\\mathrm{d} p}{\\mathrm{d}\\psi} + \\frac{1}{2} F(\\psi) \\frac{\\mathrm{d} F}{\\mathrm{d}\\psi} \\right) v \\, \\mathrm{d}\\Omega.\n$$\nIn this form, the left-hand side contains a symmetric gradient stiffness term and a non-symmetric first-order term, while the right-hand side is a source term that may include a reaction contribution if $ F(\\psi) \\frac{\\mathrm{d}F}{\\mathrm{d}\\psi} $ depends on $ \\psi $.\n\nWe parameterize $ \\frac{\\mathrm{d} p}{\\mathrm{d}\\psi} = \\alpha $ (constant) and $ F(\\psi) = \\beta \\psi $, so $ F(\\psi) \\frac{\\mathrm{d}F}{\\mathrm{d}\\psi} = \\beta^2 \\psi $. Substituting this into the weak form yields\n$$\n\\int_{\\Omega} \\left( \\frac{\\partial \\psi}{\\partial R} \\frac{\\partial v}{\\partial R} + \\frac{\\partial \\psi}{\\partial Z} \\frac{\\partial v}{\\partial Z} \\right) \\, \\mathrm{d}\\Omega + \\int_{\\Omega} \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mu_0 \\alpha R^2 v \\, \\mathrm{d}\\Omega + \\int_{\\Omega} \\frac{1}{2} \\beta^2 \\psi v \\, \\mathrm{d}\\Omega.\n$$\nDiscretize $ \\psi $ with linear triangular shape functions on each element $ e $ using $ \\psi \\approx \\sum_i \\psi_i N_i $ and test function $ v = N_j $ for a given node $ j $. The element matrices and vector are then:\n- Gradient stiffness (symmetric) term:\n$$\nK_{ij}^{(e)} = \\int_e \\left( \\partial_R N_i \\, \\partial_R N_j + \\partial_Z N_i \\, \\partial_Z N_j \\right) \\, \\mathrm{d}e.\n$$\nFor linear triangles, the gradients are constants $ \\partial_R N_i = b_i $ and $ \\partial_Z N_i = c_i $, so\n$$\nK_{ij}^{(e)} = (b_i b_j + c_i c_j) A_e,\n$$\nwhere $ A_e $ is the area of element $ e $.\n- First-order non-symmetric term:\n$$\nC_{ij}^{(e)} = \\int_e \\frac{1}{R} \\, \\partial_R N_i \\, N_j \\, \\mathrm{d}e = \\int_e \\frac{1}{R} \\, b_i \\, N_j \\, \\mathrm{d}e.\n$$\nSince $ R $ varies over the element, evaluate with a three-point barycentric quadrature exact to second order. Let barycentric points $ (\\lambda_1,\\lambda_2,\\lambda_3) $ be $ (1/6,1/6,2/3) $, $ (1/6,2/3,1/6) $, $ (2/3,1/6,1/6) $ with weights $ w_q = 1/3 $. The physical coordinates are $ (R_q,Z_q) = \\sum_k \\lambda_k (R_k,Z_k) $. Then\n$$\nC_{ij}^{(e)} \\approx A_e \\sum_{q=1}^3 w_q \\, \\frac{1}{R_q} \\, b_i \\, N_j(\\lambda^{(q)}),\n$$\nwith $ N_j(\\lambda) = \\lambda_j $ for linear barycentric shape functions.\n- Reaction (mass-like) term from $ \\frac{1}{2} \\beta^2 \\psi v $:\n$$\nM_{ij}^{(e)} = \\int_e \\frac{1}{2} \\beta^2 N_i N_j \\, \\mathrm{d}e.\n$$\nFor linear triangles, the exact integrals are well known:\n$$\n\\int_e N_i N_j \\, \\mathrm{d}e = \\begin{cases}\nA_e/6 & \\text{if } i=j,\\\\\nA_e/12 & \\text{if } i \\neq j,\n\\end{cases}\n$$\nhence\n$$\nM_{ij}^{(e)} = \\frac{1}{2} \\beta^2 \\times \\begin{cases}\nA_e/6 & i=j,\\\\\nA_e/12 & i \\neq j.\n\\end{cases}\n$$\n- Source vector from $ \\mu_0 \\alpha R^2 v $:\n$$\nf_{j}^{(e)} = \\int_e \\mu_0 \\alpha R^2 N_j \\, \\mathrm{d}e \\approx A_e \\sum_{q=1}^3 w_q \\, \\mu_0 \\alpha R_q^2 \\, N_j(\\lambda^{(q)}).\n$$\n\nThe global assembly places each element contribution $ K^{(e)}, C^{(e)}, M^{(e)} $ and $ f^{(e)} $ into their corresponding global matrices and vector using the mapping from local node indices $ i,j \\in \\{1,2,3\\} $ to global node indices in $ \\{0,1,2,3\\} $ associated with the mesh nodes $ (R,Z) = (1,0), (2,0), (1,1), (2,1) $. The triangle $ e_0 $ uses the global nodes $ [0,1,2] $, and triangle $ e_1 $ uses $ [1,3,2] $. The element areas are obtained from the determinant formula\n$$\nA_e = \\frac{1}{2} \\left| (R_2-R_1)(Z_3-Z_1) - (R_3-R_1)(Z_2-Z_1) \\right|.\n$$\nThe constant gradients $ b_i, c_i $ for each triangle are found from\n$$\nb_1 = \\frac{Z_2 - Z_3}{2 A_e}, \\quad c_1 = \\frac{R_3 - R_2}{2 A_e}, \\quad\nb_2 = \\frac{Z_3 - Z_1}{2 A_e}, \\quad c_2 = \\frac{R_1 - R_3}{2 A_e}, \\quad\nb_3 = \\frac{Z_1 - Z_2}{2 A_e}, \\quad c_3 = \\frac{R_2 - R_1}{2 A_e}.\n$$\nThe three-point barycentric quadrature of a function $ g $ over triangle $ e $ is\n$$\n\\int_e g(R,Z) \\, \\mathrm{d}e \\approx A_e \\sum_{q=1}^3 w_q \\, g(R_q,Z_q),\n$$\nwith $ w_q = 1/3 $ and $ (R_q,Z_q) $ obtained from the barycentric coordinates $ \\lambda^{(q)} $ and the triangle's node coordinates.\n\nUsing these formulas, the program assembles the global $ 4 \\times 4 $ matrices $ K $, $ C $, $ M $ and the global $ 4 $-vector $ f $ in the International System of Units (SI), with $ \\mu_0 = 4 \\pi \\times 10^{-7} $. For each test case $ (\\alpha,\\beta) $, it computes:\n- $ S_K = \\sum_{i,j} K_{ij} $,\n- $ S_C = \\sum_{i,j} C_{ij} $,\n- $ S_M = \\sum_{i,j} M_{ij} $,\n- $ S_f = \\sum_{j} f_j $.\nThese are reported as pure decimal numbers corresponding to SI units. The three test cases exercise complementary aspects of the formulation: Case $1$ ($ \\beta = 0 $) highlights the source-only loading from the pressure gradient, Case $2$ ($ \\alpha = 0 $) isolates the reaction (mass-like) contribution due to the toroidal field function, and Case $3$ combines both effects.\n\nAlgorithmic outline implemented in the program:\n- Define nodes and elements for the mesh of $ \\Omega $.\n- For each element, compute $ A_e $ and the constants $ b_i, c_i $.\n- Assemble $ K $ using the exact constant-gradient formula.\n- Assemble $ C $ and $ f $ using three-point barycentric quadrature; evaluate $ R $ and $ N_j $ at quadrature points.\n- Assemble $ M $ using the exact linear-element formula for $ \\int N_i N_j $ scaled by $ \\frac{1}{2} \\beta^2 $.\n- For each test case, form the global matrices and vector, compute the sums $ S_K, S_C, S_M, S_f $, and output them in the required single-line list format.\n\nThis design transparently links the physical principles of MHD equilibrium to the discrete operator structure produced by a finite element method on a simple mesh, preserving the $ (R,Z) $ dependence, and demonstrating how axisymmetric weights such as $ 1/R $ and $ R^2 $ enter the stiffness and source terms within the weak form.", "answer": "```python\n# Python 3.12 program to assemble FE weak-form matrices for the Grad-Shafranov equation\n# using a simple 2-triangle mesh over a rectangular domain in (R,Z),\n# and output the sums of K, C, M, and f for specified (alpha, beta) test cases.\nimport numpy as np\n\ndef triangle_area(coords):\n    # coords: array shape (3,2) with rows [R_i, Z_i]\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    return 0.5 * abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))\n\ndef triangle_gradients(coords):\n    # Returns arrays b (dN/dR) and c (dN/dZ) for linear shape functions N1,N2,N3\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    A = triangle_area(coords)\n    # Using standard formulas for linear triangle gradients\n    b1 = (y2 - y3) / (2.0 * A)\n    c1 = (x3 - x2) / (2.0 * A)\n    b2 = (y3 - y1) / (2.0 * A)\n    c2 = (x1 - x3) / (2.0 * A)\n    b3 = (y1 - y2) / (2.0 * A)\n    c3 = (x2 - x1) / (2.0 * A)\n    b = np.array([b1, b2, b3], dtype=float)\n    c = np.array([c1, c2, c3], dtype=float)\n    return b, c, A\n\ndef barycentric_quadrature_points():\n    # Three-point symmetric quadrature, exact for quadratics\n    # Returns list of (lambda1, lambda2, lambda3, weight)\n    w = 1.0 / 3.0\n    return [\n        (1.0/6.0, 1.0/6.0, 2.0/3.0, w),\n        (1.0/6.0, 2.0/3.0, 1.0/6.0, w),\n        (2.0/3.0, 1.0/6.0, 1.0/6.0, w),\n    ]\n\ndef assemble_matrices(alpha, beta, mu0):\n    # Define mesh nodes (R,Z)\n    nodes = np.array([\n        [1.0, 0.0],  # node 0\n        [2.0, 0.0],  # node 1\n        [1.0, 1.0],  # node 2\n        [2.0, 1.0],  # node 3\n    ], dtype=float)\n\n    # Define elements by global node indices\n    elements = [\n        [0, 1, 2],  # e0\n        [1, 3, 2],  # e1\n    ]\n\n    n_nodes = nodes.shape[0]\n    K = np.zeros((n_nodes, n_nodes), dtype=float)\n    C = np.zeros((n_nodes, n_nodes), dtype=float)\n    M = np.zeros((n_nodes, n_nodes), dtype=float)\n    f = np.zeros(n_nodes, dtype=float)\n\n    quad = barycentric_quadrature_points()\n\n    # Loop over elements\n    for elem in elements:\n        # Element coordinates in (R,Z)\n        coords = nodes[np.array(elem)]\n        # Gradients and area\n        b, c, A = triangle_gradients(coords)\n\n        # Local stiffness K_e (symmetric gradient part)\n        Ke = np.zeros((3, 3), dtype=float)\n        for i in range(3):\n            for j in range(3):\n                Ke[i, j] = (b[i] * b[j] + c[i] * c[j]) * A\n\n        # Local convection-like C_e = \\int (1/R) * dN_i/dR * N_j dΩ\n        Ce = np.zeros((3, 3), dtype=float)\n        # Local source f_e = \\int mu0*alpha*R^2*N_j dΩ\n        fe = np.zeros(3, dtype=float)\n        # Quadrature over triangle\n        R_coords = coords[:, 0]\n        Z_coords = coords[:, 1]\n        for (l1, l2, l3, w) in quad:\n            # Physical coordinates at quadrature point\n            Rq = l1 * R_coords[0] + l2 * R_coords[1] + l3 * R_coords[2]\n            Zq = l1 * Z_coords[0] + l2 * Z_coords[1] + l3 * Z_coords[2]\n            # Shape function values at barycentric coordinates\n            Nvals = np.array([l1, l2, l3], dtype=float)\n            # Convection-like term integrand\n            for i in range(3):\n                for j in range(3):\n                    Ce[i, j] += A * w * (1.0 / Rq) * b[i] * Nvals[j]\n            # Source vector integrand\n            for j in range(3):\n                fe[j] += A * w * mu0 * alpha * (Rq ** 2) * Nvals[j]\n\n        # Local mass/reaction matrix M_e = \\int (1/2)*beta^2*N_i*N_j dΩ\n        Me = np.zeros((3, 3), dtype=float)\n        for i in range(3):\n            for j in range(3):\n                if i == j:\n                    Me[i, j] = 0.5 * (beta ** 2) * (A / 6.0)\n                else:\n                    Me[i, j] = 0.5 * (beta ** 2) * (A / 12.0)\n\n        # Assemble into global matrices\n        for a_local, a_global in enumerate(elem):\n            for b_local, b_global in enumerate(elem):\n                K[a_global, b_global] += Ke[a_local, b_local]\n                C[a_global, b_global] += Ce[a_local, b_local]\n                M[a_global, b_global] += Me[a_local, b_local]\n            f[a_global] += fe[a_local]\n\n    # Compute sums of entries\n    S_K = float(np.sum(K))\n    S_C = float(np.sum(C))\n    S_M = float(np.sum(M))\n    S_f = float(np.sum(f))\n\n    return S_K, S_C, S_M, S_f\n\ndef solve():\n    # SI constant\n    mu0 = 4.0 * np.pi * 1e-7\n\n    # Define the test cases (alpha, beta)\n    test_cases = [\n        (2.0e4, 0.0),  # Case 1\n        (0.0, 1.0),    # Case 2\n        (5.0e4, 0.5),  # Case 3\n    ]\n\n    results = []\n    for alpha, beta in test_cases:\n        S_K, S_C, S_M, S_f = assemble_matrices(alpha, beta, mu0)\n        results.append([S_K, S_C, S_M, S_f])\n\n    # Final print statement in the exact required format.\n    # Produce a single line: [[case1_results],[case2_results],[case3_results]]\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```", "id": "3721297"}, {"introduction": "The solutions to the Grad-Shafranov equation in modern tokamaks often exhibit complex features like magnetic separatrices and X-points, which are critical for plasma performance and stability. This advanced practice explores the profound impact of this magnetic topology on the safety factor, $q$. You will derive the integral definition of $q$ and use it to analyze why $q$ diverges near an X-point, a signature feature that has deep implications for transport and stability at the plasma edge [@problem_id:3721299].", "problem": "Consider an axisymmetric magnetohydrodynamic equilibrium in a toroidal geometry, governed by the static ideal Magnetohydrodynamics (MHD) force balance $ \\nabla p = \\mathbf{J} \\times \\mathbf{B} $ and Ampère’s law $ \\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J} $. In cylindrical coordinates with toroidal angle $ \\phi $, axisymmetry implies that the poloidal flux function $ \\psi(r,z) $ and the toroidal field function $ F(\\psi) $ organize the magnetic field into nested flux surfaces. Let $ \\mathbf{B} $ be decomposed as $ \\mathbf{B} = \\mathbf{B}_p + \\mathbf{B}_\\phi $ where $ \\mathbf{B}_p $ is the poloidal component and $ \\mathbf{B}_\\phi $ is the toroidal component. The Grad-Shafranov equation provides the equilibrium condition for $ \\psi(r,z) $ and $ F(\\psi) $, but its explicit form should not be used directly as a shortcut in this task. An X-point is defined here as a saddle point of $ \\psi(r,z) $ on the separatrix where $ \\nabla \\psi = \\mathbf{0} $ and the Hessian of $ \\psi $ has one positive and one negative eigenvalue.\n\nThe safety factor $ q(\\psi) $ is defined as the number of toroidal turns per poloidal circuit for a magnetic field line on the flux surface $ \\psi = \\text{constant} $. Your tasks are:\n\n1. Starting only from the above fundamental laws and the axisymmetric decomposition, derive a mathematically explicit expression for $ q(\\psi) $ as a contour integral around the closed curve $ C_\\psi $ defined by $ \\psi(r,z) = \\text{constant} $. The derivation must be consistent with first principles and express $ q(\\psi) $ using the magnetic field representation, making clear how $ \\mathbf{B}_p $, $ \\mathbf{B}_\\phi $, $ \\psi $, and $ F(\\psi) $ enter the result. Do not assume or state the final formula from memory; derive it.\n\n2. Near an X-point on the separatrix at $ \\psi = \\psi_{\\text{sep}} $, assume a local quadratic expansion of the poloidal flux in orthonormal Cartesian coordinates $ (x,y) $ aligned with the principal axes of the Hessian,\n$$\n\\psi(x,y) \\approx \\psi_{\\text{sep}} + \\frac{1}{2}\\left(\\alpha x^2 - \\beta y^2\\right),\n$$\nwith $ \\alpha > 0 $ and $ \\beta > 0 $. Show how the contour integral obtained in part 1 behaves as $ \\psi \\to \\psi_{\\text{sep}}^- $ (approaching from inside the last closed flux surface) and analytically determine the leading-order divergence of $ q(\\psi) $ in terms of $ \\alpha $, $ \\beta $, and the toroidal magnetic field $ B_\\phi $ evaluated at the X-point. Your analysis must be asymptotic, explicitly demonstrating the mechanism by which the divergence arises from the local geometry of $ \\psi $ near the X-point.\n\n3. Construct a computational algorithm that evaluates $ q(\\psi) $ approaching the separatrix in two distinct configurations:\n   - With X-point: Evaluate the dominant near-X-point contribution to $ q(\\psi) $ by numerically integrating the appropriate contour integral using the local quadratic model above. Parameterize the hyperbolic branches of the contour $ \\psi(x,y) = \\psi_0 $ with $ \\psi_0 = \\psi_{\\text{sep}} - \\delta $ for $ \\delta > 0 $ small, and integrate from a lower cutoff $ x_{\\min} $ determined by $ \\delta $ up to a finite matching scale $ L_x $ that represents the end of validity of the local quadratic model. Include both symmetric branches to obtain the total near-X contribution. Assume $ B_\\phi $ is approximately constant and equal to its value at the X-point in this local region. The algorithm should return the value of $ q(\\psi_0) $ computed from this near-X contribution.\n   - Without X-point: Consider a local model of a smooth boundary with negative-definite Hessian,\n     $$\n     \\psi(x,y) \\approx \\psi_{\\text{sep}} - \\frac{1}{2}\\left(\\alpha x^2 + \\beta y^2\\right),\n     $$\n     with $ \\alpha > 0 $ and $ \\beta > 0 $. For the contour $ \\psi(x,y) = \\psi_0 = \\psi_{\\text{sep}} - \\delta $, parameterize the ellipse and numerically evaluate the full contour integral for $ q(\\psi_0) $. Demonstrate that the integral is finite and independent of $ \\delta $ in the limit $ \\delta \\to 0^+ $.\n\nUse the following modeling assumptions for the computations: in the near-X region, take the toroidal magnetic field to be $ B_\\phi = \\text{constant} $, equal to its value at the X-point; elsewhere in the local boundary model for the no-X case, also take $ B_\\phi = \\text{constant} $ on the contour. You may assume $ F(\\psi) = R B_\\phi $ with $ R $ slowly varying and replace it by its local value when justified, but you must make this justification clear in your derivation.\n\nYou must implement a complete, runnable program that:\n- Computes $ q(\\psi_0) $ for each test case listed below.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $ [q_1,q_2,\\dots] $.\n- Each $ q(\\psi_0) $ must be reported as a floating-point number rounded to six decimal places.\n- Since $ q $ is dimensionless, no physical unit should be included in the output.\n\nTest Suite (all constants are scientifically plausible and self-consistent):\n- With X-point (saddle):\n  - Case 1: $ \\alpha = 3.0 $, $ \\beta = 2.0 $, $ B_\\phi = 2.5 \\, \\text{Tesla} $, $ \\delta = 10^{-3} $, $ L_x = 0.3 \\, \\text{meter} $.\n  - Case 2: $ \\alpha = 3.0 $, $ \\beta = 2.0 $, $ B_\\phi = 2.5 \\, \\text{Tesla} $, $ \\delta = 10^{-5} $, $ L_x = 0.3 \\, \\text{meter} $.\n  - Case 3: $ \\alpha = 3.0 $, $ \\beta = 2.0 $, $ B_\\phi = 2.5 \\, \\text{Tesla} $, $ \\delta = 10^{-7} $, $ L_x = 0.3 \\, \\text{meter} $.\n- Without X-point (elliptic):\n  - Case 4: $ \\alpha = 3.0 $, $ \\beta = 2.0 $, $ B_\\phi = 2.5 \\, \\text{Tesla} $, $ \\delta = 10^{-3} $.\n  - Case 5: $ \\alpha = 0.8 $, $ \\beta = 5.0 $, $ B_\\phi = 2.5 \\, \\text{Tesla} $, $ \\delta = 10^{-3} $.\n\nAlgorithmic Requirements:\n- For the X-point cases, parameterize the hyperbolic branches of the level set $ \\beta y^2 - \\alpha x^2 = 2\\delta $ and integrate the near-X contribution\n  along $ x \\in [x_{\\min}, L_x] $ on both branches, where $ x_{\\min} = \\sqrt{2\\delta/\\alpha} $,\n  using the local expressions for $ y(x) $, $ \\mathrm{d}l $, and $ |\\nabla \\psi| $ implied by the quadratic model.\n- For the elliptic cases, parameterize the ellipse $ \\alpha x^2 + \\beta y^2 = 2\\delta $ using $ x(t) = a\\cos t $, $ y(t) = b\\sin t $, $ t \\in [0,2\\pi] $, where $ a = \\sqrt{2\\delta/\\alpha} $ and $ b = \\sqrt{2\\delta/\\beta} $, and evaluate the full contour integral.\n- Angles, if any appear in your parameterization, must be in radians.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $ [q_1,q_2,q_3,q_4,q_5] $ corresponding to Cases 1 through 5.\n\nYour derivation and algorithm must be presented first, followed by the program. The final program must be fully self-contained and runnable without user interaction, using only the Python standard library and the specified scientific libraries.", "solution": "### Part 1: Derivation of the Safety Factor $q(\\psi)$\n\nThe safety factor $q$ is defined as the number of toroidal turns a magnetic field line completes for every single poloidal circuit. A magnetic field line is a curve $\\mathbf{l}$ in space that is everywhere tangent to the magnetic field vector $\\mathbf{B}$. In cylindrical coordinates $(r, \\phi, z)$, the path element is $d\\mathbf{l} = dr\\,\\hat{r} + r\\,d\\phi\\,\\hat{\\phi} + dz\\,\\hat{z}$. The tangency condition implies that the components of $d\\mathbf{l}$ are proportional to the components of $\\mathbf{B} = B_r\\,\\hat{r} + B_\\phi\\,\\hat{\\phi} + B_z\\,\\hat{z}$:\n$$\n\\frac{dr}{B_r} = \\frac{dz}{B_z} = \\frac{r\\,d\\phi}{B_\\phi}\n$$\nFrom this, we can express the differential change in toroidal angle $d\\phi$ in terms of the differential arc length in the poloidal plane, $dl_p = \\sqrt{dr^2 + dz^2}$, and the magnitude of the poloidal magnetic field, $B_p = \\sqrt{B_r^2 + B_z^2}$:\n$$\nd\\phi = \\frac{B_\\phi}{r} \\frac{dl_p}{B_p}\n$$\nIntegrating $d\\phi$ over one full poloidal circuit of a field line gives the total toroidal angle traversed, $\\Delta\\phi$. The safety factor $q$ is this total angle normalized by $2\\pi$:\n$$\nq = \\frac{\\Delta\\phi}{2\\pi} = \\frac{1}{2\\pi} \\oint_{C_p} d\\phi = \\frac{1}{2\\pi} \\oint_{C_p} \\frac{B_\\phi}{r B_p} dl_p\n$$\nIn an axisymmetric equilibrium, magnetic field lines lie on nested flux surfaces, which are surfaces of constant poloidal flux function $\\psi(r,z)$. The integration path $C_p$ is thus a contour of constant $\\psi$ in the poloidal plane, which we denote $C_\\psi$.\n\nThe magnetic field components can be expressed in terms of $\\psi$ and a second flux function $F(\\psi)$.\nFrom the solenoidal condition $\\nabla \\cdot \\mathbf{B} = 0$, for an axisymmetric field, the poloidal field $\\mathbf{B}_p$ can be written as the curl of a vector potential with only a toroidal component, $\\mathbf{A} = A_\\phi(r,z)\\hat{\\phi}$. It is standard to define the poloidal flux function $\\psi$ as $\\psi = r A_\\phi$. Then, the poloidal field is given by:\n$$\n\\mathbf{B}_p = \\nabla \\times (A_\\phi \\hat{\\phi}) = \\nabla \\times \\left(\\frac{\\psi}{r}\\hat{\\phi}\\right) = \\frac{1}{r} \\nabla\\psi \\times \\hat{\\phi}\n$$\nThe magnitude of the poloidal field is therefore:\n$$\nB_p = |\\mathbf{B}_p| = \\left| \\frac{1}{r} \\nabla\\psi \\times \\hat{\\phi} \\right| = \\frac{1}{r} |\\nabla\\psi|\n$$\nThe ideal MHD force balance equation $\\nabla p = \\mathbf{J} \\times \\mathbf{B}$ implies that $\\mathbf{B} \\cdot \\nabla p = 0$. Since $\\mathbf{B}_p \\cdot \\nabla \\psi = 0$ by construction, it follows that $p$ must be a function of $\\psi$ alone, $p=p(\\psi)$. A further consequence of the force balance and Ampère's law is that $\\mathbf{B} \\cdot \\nabla(rB_\\phi) = 0$, which implies that the quantity $rB_\\phi$ is also a flux function. We define this function as $F(\\psi) = r B_\\phi$. Therefore, the toroidal field is $B_\\phi = F(\\psi)/r$. Note that the problem statement uses the symbol $R$ to denote the major radius coordinate, which is identical to $r$ in our cylindrical system.\n\nSubstituting the expressions for $B_p$ and $B_\\phi$ into the integral for $q(\\psi)$:\n$$\nq(\\psi) = \\frac{1}{2\\pi} \\oint_{C_\\psi} \\frac{F(\\psi)/r}{r (|\\nabla\\psi|/r)} dl_p = \\frac{F(\\psi)}{2\\pi} \\oint_{C_\\psi} \\frac{1}{r |\\nabla\\psi|} dl_p\n$$\nThis is the desired expression for the safety factor, derived from first principles. It shows that $q$ depends on the flux functions $F(\\psi)$ and $\\psi$, and the geometry of the flux surface through the integral of $1/(r|\\nabla\\psi|)$ along the poloidal contour.\n\n### Part 2: Asymptotic Behavior of $q(\\psi)$ Near an X-point\n\nNear an X-point, where $\\nabla\\psi = \\mathbf{0}$, the denominator in the integrand approaches zero, leading to a potential divergence. We analyze the behavior of the integral using the local quadratic model for $\\psi(x,y)$ near the X-point located at $(x,y)=(0,0)$:\n$$\n\\psi(x,y) \\approx \\psi_{\\text{sep}} + \\frac{1}{2}\\left(\\alpha x^2 - \\beta y^2\\right)\n$$\nWe consider a flux surface just inside the separatrix, $\\psi_0 = \\psi_{\\text{sep}} - \\delta$, where $\\delta > 0$ is small. This gives the contour equation:\n$$\n\\frac{1}{2}(\\alpha x^2 - \\beta y^2) = -\\delta \\quad \\implies \\quad \\beta y^2 - \\alpha x^2 = 2\\delta\n$$\nThis equation describes a hyperbola opening along the $y$-axis. The local contribution to $q(\\psi)$ is dominated by the parts of the contour passing close to the X-point. In this local Cartesian frame, we assume $r \\approx R_X$ (the major radius at the X-point) and $B_\\phi \\approx B_{\\phi,X}$ are constant. The function $F(\\psi) = rB_\\phi$ is also approximately constant, $F_0 = R_X B_{\\phi,X}$. The local contribution to $q$ becomes:\n$$\n\\Delta q_X \\approx \\frac{F_0}{2\\pi} \\oint_{C_{\\text{local}}} \\frac{dl}{R_X |\\nabla\\psi|} = \\frac{B_{\\phi,X}}{2\\pi} \\oint_{C_{\\text{local}}} \\frac{dl}{|\\nabla\\psi|}\n$$\nThe gradient of $\\psi$ in these coordinates is $\\nabla\\psi = (\\alpha x, -\\beta y)$, so its magnitude is $|\\nabla\\psi| = \\sqrt{\\alpha^2 x^2 + \\beta^2 y^2}$. Using the contour equation to express $y^2$:\n$$\n|\\nabla\\psi| = \\sqrt{\\alpha^2 x^2 + \\beta^2 \\frac{\\alpha x^2 + 2\\delta}{\\beta}} = \\sqrt{(\\alpha^2 + \\alpha\\beta)x^2 + 2\\beta\\delta}\n$$\nThe poloidal arc length element is $dl = \\sqrt{1+(dy/dx)^2}dx$. Differentiating $y = \\sqrt{(\\alpha x^2 + 2\\delta)/\\beta}$ gives $dy/dx = \\alpha x / \\sqrt{\\beta(\\alpha x^2 + 2\\delta)}$.\n$$\ndl = \\sqrt{1 + \\frac{\\alpha^2 x^2}{\\beta(\\alpha x^2 + 2\\delta)}} dx = \\sqrt{\\frac{\\beta(\\alpha x^2+2\\delta)+\\alpha^2 x^2}{\\beta(\\alpha x^2+2\\delta)}} dx = \\frac{\\sqrt{(\\alpha^2+\\alpha\\beta)x^2+2\\beta\\delta}}{\\sqrt{\\beta(\\alpha x^2+2\\delta)}} dx\n$$\nThe integrand $\\frac{dl}{|\\nabla\\psi|}$ simplifies remarkably:\n$$\n\\frac{dl}{|\\nabla\\psi|} = \\frac{1}{\\sqrt{\\beta(\\alpha x^2 + 2\\delta)}} dx\n$$\nThe integral is taken over the parts of the contour within the local model's validity, from some cutoff $-L_x$ to $L_x$. The total contribution from the two symmetric branches is:\n$$\n\\oint_{C_{\\text{local}}} \\frac{dl}{|\\nabla\\psi|} = 2 \\int_0^{L_x} \\frac{dx}{\\sqrt{\\beta(\\alpha x^2 + 2\\delta)}} = \\frac{2}{\\sqrt{\\alpha\\beta}} \\int_0^{L_x} \\frac{dx}{\\sqrt{x^2 + 2\\delta/\\alpha}}\n$$\nEvaluating the integral gives:\n$$\n\\frac{2}{\\sqrt{\\alpha\\beta}} \\left[ \\ln\\left(x + \\sqrt{x^2 + \\frac{2\\delta}{\\alpha}}\\right) \\right]_0^{L_x} = \\frac{2}{\\sqrt{\\alpha\\beta}} \\left( \\ln\\left(L_x + \\sqrt{L_x^2+\\frac{2\\delta}{\\alpha}}\\right) - \\ln\\sqrt{\\frac{2\\delta}{\\alpha}} \\right)\n$$\nAs $\\delta \\to 0$, the expression is dominated by the logarithmic term:\n$$\n\\oint \\approx \\frac{2}{\\sqrt{\\alpha\\beta}} \\left( \\ln(2L_x) - \\frac{1}{2}\\ln\\left(\\frac{2\\delta}{\\alpha}\\right) \\right) = \\frac{2}{\\sqrt{\\alpha\\beta}} \\left( \\text{const} - \\frac{1}{2}\\ln\\delta \\right)\n$$\nThus, the safety factor has a leading-order logarithmic divergence as the separatrix is approached:\n$$\n\\Delta q_X \\approx \\frac{B_{\\phi,X}}{2\\pi} \\left( \\frac{-\\ln\\delta}{\\sqrt{\\alpha\\beta}} + \\text{const} \\right) \\propto -\\ln\\delta\n$$\n\n### Part 3: Computational Algorithm\n\n#### With X-point (Saddle)\nThe algorithm follows the explicit instructions. The contribution to $q(\\psi_0)$ for $\\psi_0 = \\psi_{\\text{sep}} - \\delta$ is computed by integrating along the hyperbolic contour $\\beta y^2 - \\alpha x^2 = 2\\delta$. The problem specifies integrating from a lower cutoff $x_{\\min} = \\sqrt{2\\delta/\\alpha}$ to a matching scale $L_x$ on both symmetric branches. The total integral is twice the integral over the positive branch.\n$$\nq(\\psi_0, \\delta) = \\frac{B_\\phi}{2\\pi} \\times \\left(2 \\int_{x_{\\min}}^{L_x} \\frac{dl}{|\\nabla\\psi|}\\right) = \\frac{B_\\phi}{\\pi} \\int_{\\sqrt{2\\delta/\\alpha}}^{L_x} \\frac{dx}{\\sqrt{\\beta(\\alpha x^2 + 2\\delta)}}\n$$\nThis definite integral can be evaluated numerically using standard quadrature methods, such as `scipy.integrate.quad`.\n\n#### Without X-point (Elliptic)\nFor the case without an X-point, the local model is $\\psi(x,y) \\approx \\psi_{\\text{sep}} - \\frac{1}{2}(\\alpha x^2 + \\beta y^2)$. The contour $\\psi_0 = \\psi_{\\text{sep}} - \\delta$ is therefore the ellipse $\\alpha x^2 + \\beta y^2 = 2\\delta$. We parameterize it as $x(t) = a\\cos t$, $y(t) = b\\sin t$ for $t \\in [0, 2\\pi]$, with semi-axes $a=\\sqrt{2\\delta/\\alpha}$ and $b=\\sqrt{2\\delta/\\beta}$.\n\nAs before, we compute $q(\\psi_0)$ using the local formula $q \\approx \\frac{B_\\phi}{2\\pi} \\oint \\frac{dl}{|\\nabla\\psi|}$.\nThe gradient for the corrected model is $\\nabla\\psi = (-\\alpha x, -\\beta y)$.\n$|\\nabla\\psi| = \\sqrt{\\alpha^2 x^2 + \\beta^2 y^2} = \\sqrt{\\alpha^2 a^2 \\cos^2 t + \\beta^2 b^2 \\sin^2 t} = \\sqrt{2\\delta(\\alpha\\cos^2 t + \\beta\\sin^2 t)}$.\nThe arc length element is $dl = \\sqrt{(x')^2 + (y')^2}dt = \\sqrt{a^2\\sin^2 t + b^2\\cos^2 t}dt = \\sqrt{\\frac{2\\delta}{\\alpha}\\sin^2 t + \\frac{2\\delta}{\\beta}\\cos^2 t}dt$.\nThe integrand becomes:\n$$\n\\frac{dl}{|\\nabla\\psi|} = \\frac{\\sqrt{\\frac{2\\delta}{\\alpha}\\sin^2 t + \\frac{2\\delta}{\\beta}\\cos^2 t}}{\\sqrt{2\\delta(\\alpha\\cos^2 t + \\beta\\sin^2 t)}} dt = \\frac{\\sqrt{2\\delta}\\sqrt{\\frac{\\beta\\sin^2 t + \\alpha\\cos^2 t}{\\alpha\\beta}}}{\\sqrt{2\\delta}\\sqrt{\\alpha\\cos^2 t + \\beta\\sin^2 t}} dt = \\frac{1}{\\sqrt{\\alpha\\beta}} dt\n$$\nThe integrand is constant and independent of both $t$ and $\\delta$. The integral is trivial:\n$$\n\\oint_{C_\\psi} \\frac{dl}{|\\nabla\\psi|} = \\int_0^{2\\pi} \\frac{1}{\\sqrt{\\alpha\\beta}} dt = \\frac{2\\pi}{\\sqrt{\\alpha\\beta}}\n$$\nSubstituting this back into the formula for $q$:\n$$\nq(\\psi_0) = \\frac{B_\\phi}{2\\pi} \\left( \\frac{2\\pi}{\\sqrt{\\alpha\\beta}} \\right) = \\frac{B_\\phi}{\\sqrt{\\alpha\\beta}}\n$$\nThis demonstrates that for an elliptic boundary, $q(\\psi_0)$ is finite and, in this local model, independent of $\\delta$. The computation for these cases is therefore a direct analytical evaluation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the safety factor q for several test cases, modeling its behavior\n    near an X-point (saddle) and a regular boundary (elliptic).\n    \"\"\"\n\n    # Test suite format: (case_type, alpha, beta, B_phi, delta, L_x)\n    # For elliptic cases, L_x is not used and can be None.\n    test_cases = [\n        # With X-point (saddle)\n        # Case 1\n        ('x-point', 3.0, 2.0, 2.5, 1e-3, 0.3),\n        # Case 2\n        ('x-point', 3.0, 2.0, 2.5, 1e-5, 0.3),\n        # Case 3\n        ('x-point', 3.0, 2.0, 2.5, 1e-7, 0.3),\n        # Without X-point (elliptic)\n        # Case 4\n        ('elliptic', 3.0, 2.0, 2.5, 1e-3, None),\n        # Case 5\n        ('elliptic', 0.8, 5.0, 2.5, 1e-3, None),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        case_type, alpha, beta, B_phi, delta, L_x = case\n        \n        if case_type == 'x-point':\n            # This case corresponds to a saddle point (X-point).\n            # The contour is a hyperbola: beta*y^2 - alpha*x^2 = 2*delta\n            # The formula for the near-X-point contribution to q is derived in the solution:\n            # q = (B_phi / pi) * integral from x_min to L_x of the integrand.\n            # This accounts for the two symmetric branches of the contour.\n            \n            # The integrand is dl/|nabla_psi| = 1 / sqrt(beta * (alpha*x^2 + 2*delta))\n            integrand = lambda x: 1.0 / np.sqrt(beta * (alpha * x**2 + 2 * delta))\n            \n            # Lower integration limit as specified in the problem\n            x_min = np.sqrt(2 * delta / alpha)\n            \n            # Upper integration limit\n            x_max = L_x\n            \n            # Perform numerical integration using SciPy quad\n            integral_val, _ = integrate.quad(integrand, x_min, x_max)\n\n            # Calculate q\n            q_val = (B_phi / np.pi) * integral_val\n            \n            results.append(f\"{q_val:.6f}\")\n\n        elif case_type == 'elliptic':\n            # This case corresponds to a smooth, elliptic boundary.\n            # As derived in the solution, the integral for q simplifies to an\n            # analytical expression independent of delta.\n            # q = B_phi / sqrt(alpha * beta)\n            \n            q_val = B_phi / np.sqrt(alpha * beta)\n            \n            results.append(f\"{q_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3721299"}]}