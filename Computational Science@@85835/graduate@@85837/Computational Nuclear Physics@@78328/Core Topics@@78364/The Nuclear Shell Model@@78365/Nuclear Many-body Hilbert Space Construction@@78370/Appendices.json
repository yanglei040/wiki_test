{"hands_on_practices": [{"introduction": "The starting point for any many-body calculation is to define the Hilbert space and appreciate its size. The \"M-scheme\" basis, which consists of all possible Slater determinants consistent with particle number conservation, provides the most straightforward enumeration. This exercise [@problem_id:3575523] challenges you to derive the dimension of this basis from first principles, revealing the combinatorial explosion inherent in the nuclear many-body problem. By calculating the memory required to store a single state vector, you will gain a tangible understanding of why this \"curse of dimensionality\" is the central challenge in computational nuclear physics.", "problem": "In computational nuclear physics, many-body basis states for shell-model calculations are commonly constructed as Slater determinants in the magnetic quantum number scheme (M-scheme), which enumerates occupation-number configurations of fermions consistent with particle-number conservation. Consider a model space that contains $N_{p}$ distinct single-proton orbitals and $N_{n}$ distinct single-neutron orbitals. The many-body Hilbert space is spanned by antisymmetrized products of occupied single-particle states for each species. Assume proton and neutron sectors are independent and that only particle-number constraints are imposed, with $Z$ protons and $N$ neutrons occupying available orbitals. Do not impose any additional symmetry constraints beyond these particle numbers. \n\nStarting from the principles of fermionic antisymmetry and combinatorial occupancy counting, derive a closed-form analytic expression for the dimension $D(N_{p}, N_{n}, Z, N)$ of the many-body Hilbert space spanned by such Slater determinants. Then, assume a dense state vector representation in which each basis amplitude is stored as a double precision complex number of $16$ bytes. For the specific case $N_{p} = 20$, $N_{n} = 20$, $Z = 14$, and $N = 16$, compute the total memory required to store one normalized state vector in decimal gigabytes, where $1$ gigabyte (GB) $=$ $10^{9}$ bytes. Round your final numeric answer to four significant figures. Express the final answer in gigabytes.", "solution": "The problem asks for the dimension of a many-body Hilbert space and the memory required to store a state vector within it. The derivation proceeds in two parts: first, finding the analytical expression for the dimension, and second, performing the numerical calculation.\n\n### Part 1: Analytical Expression for Hilbert Space Dimension\n\n1.  **Independent Subsystems**: The problem states that the proton and neutron sectors are independent. The total Hilbert space is a tensor product of the proton Hilbert space and the neutron Hilbert space. Therefore, the total dimension $D$ is the product of the dimensions of the proton sector ($D_p$) and the neutron sector ($D_n$):\n    $$ D(N_{p}, N_{n}, Z, N) = D_p \\times D_n $$\n\n2.  **Dimension of a Single-Species Sector**: Let's consider the proton sector. We need to find the number of ways to place $Z$ identical fermions (protons) into $N_p$ distinct single-particle orbitals. According to the Pauli exclusion principle, each orbital can be occupied by at most one proton. This is equivalent to choosing which $Z$ of the $N_p$ orbitals are occupied. This is a classic combinatorial problem, and the number of ways is given by the binomial coefficient \"N_p choose Z\":\n    $$ D_p = \\binom{N_p}{Z} = \\frac{N_p!}{Z!(N_p - Z)!} $$\n\n3.  **Total Dimension**: By the same logic, the dimension of the neutron sector with $N$ neutrons in $N_n$ orbitals is:\n    $$ D_n = \\binom{N_n}{N} = \\frac{N_n!}{N!(N_n - N)!} $$\n    Combining these results, the closed-form analytic expression for the total dimension of the many-body Hilbert space is:\n    $$ D(N_{p}, N_{n}, Z, N) = \\binom{N_p}{Z} \\binom{N_n}{N} $$\n\n### Part 2: Numerical Calculation\n\n1.  **Given Parameters**:\n    *   Number of single-proton orbitals, $N_p = 20$\n    *   Number of single-neutron orbitals, $N_n = 20$\n    *   Number of protons, $Z = 14$\n    *   Number of neutrons, $N = 16$\n    *   Memory per basis amplitude = $16$ bytes\n    *   $1$ GB = $10^9$ bytes\n\n2.  **Calculate Sector Dimensions**:\n    *   Proton dimension:\n        $$ D_p = \\binom{20}{14} = \\binom{20}{20-14} = \\binom{20}{6} = \\frac{20 \\times 19 \\times 18 \\times 17 \\times 16 \\times 15}{6 \\times 5 \\times 4 \\times 3 \\times 2 \\times 1} = 38,760 $$\n    *   Neutron dimension:\n        $$ D_n = \\binom{20}{16} = \\binom{20}{20-16} = \\binom{20}{4} = \\frac{20 \\times 19 \\times 18 \\times 17}{4 \\times 3 \\times 2 \\times 1} = 4,845 $$\n\n3.  **Calculate Total Dimension**:\n    $$ D_{\\text{total}} = D_p \\times D_n = 38,760 \\times 4,845 = 187,792,200 $$\n    There are $187,792,200$ basis states in the Hilbert space.\n\n4.  **Calculate Memory Requirement**:\n    *   Total memory in bytes:\n        $$ \\text{Memory (bytes)} = D_{\\text{total}} \\times 16 \\, \\text{bytes/amplitude} = 187,792,200 \\times 16 = 3,004,675,200 \\, \\text{bytes} $$\n    *   Convert to gigabytes:\n        $$ \\text{Memory (GB)} = \\frac{3,004,675,200}{10^9} = 3.0046752 \\, \\text{GB} $$\n\n5.  **Final Answer**: The problem requires rounding the final answer to four significant figures.\n    $$ 3.0046752 \\, \\text{GB} \\approx 3.005 \\, \\text{GB} $$", "answer": "$$ \\boxed{3.005} $$", "id": "3575523"}, {"introduction": "While the M-scheme provides a complete basis, physical Hamiltonians possess fundamental symmetries, such as rotational invariance. Working in a basis that respects these symmetries simplifies the problem dramatically and serves as a critical validation tool. This practice [@problem_id:3575541] guides you through a classic benchmark: analyzing a two-nucleon system in a single-$j$ shell. You will apply the generalized Pauli exclusion principle to determine the allowed total angular momentum ($J$) and isospin ($T$) states, connecting the abstract M-scheme dimension to the structured, physically meaningful J-T coupled basis.", "problem": "A computational many-body code constructs the Hilbert space for systems restricted to a single spherical orbital of total single-particle angular momentum $j = 7/2$ and diagonalizes a rotationally invariant two-body Hamiltonian specified in the coupled $(J,T)$ representation by reduced two-body matrix elements $V^{(T)}_{J}$, where $J$ is the total angular momentum and $T$ is the total isospin. To benchmark antisymmetry, angular-momentum coupling, and selection rules, consider two solvable two-body test cases:\n\n- Test case I: two identical neutrons occupying the $j = 7/2$ shell.\n- Test case II: one proton and one neutron occupying the $j = 7/2$ shell, with good isospin $T$ enforced.\n\nAssume the only nonzero coupled two-body matrix elements are\n$V^{(1)}_{0} = -2.0\\,\\mathrm{MeV}$, $V^{(1)}_{2} = -1.0\\,\\mathrm{MeV}$, $V^{(1)}_{4} = 0.0\\,\\mathrm{MeV}$, $V^{(1)}_{6} = 0.5\\,\\mathrm{MeV}$,\nand\n$V^{(0)}_{1} = -1.5\\,\\mathrm{MeV}$, $V^{(0)}_{3} = -0.8\\,\\mathrm{MeV}$, $V^{(0)}_{5} = 0.2\\,\\mathrm{MeV}$, $V^{(0)}_{7} = 0.7\\,\\mathrm{MeV}$,\nand that all other $V^{(T)}_{J}$ vanish. You may take as fundamental starting points: fermionic antisymmetry under particle exchange, standard addition of angular momenta in quantum mechanics, the meaning of isospin $T$ for two-nucleon systems, and the fact that a rotationally invariant two-body Hamiltonian is block-diagonal in $(J,T)$.\n\nWhich option gives a correct and complete benchmark specification for the two test cases, including: the allowed set of coupled $(J,T)$ quantum numbers implied by antisymmetry and isospin, the expected eigenenergies for each allowed $J$ (and $T$ where applicable), and a dimension check equating the $M$-scheme basis size to the sum of magnetic degeneracies in the $J$-coupled spectrum?\n\nA) Two neutrons (Test I): allowed total angular momenta $J \\in \\{0,2,4,6\\}$ with $T=1$; expected eigenenergies $E(J) = V^{(1)}_{J}$, i.e., $E(0) = -2.0\\,\\mathrm{MeV}$, $E(2) = -1.0\\,\\mathrm{MeV}$, $E(4) = 0.0\\,\\mathrm{MeV}$, $E(6) = 0.5\\,\\mathrm{MeV}$. $M$-scheme dimension equals $\\binom{8}{2} = 28$, which matches $\\sum_{J \\in \\{0,2,4,6\\}} (2J+1) = 1 + 5 + 9 + 13 = 28$. Proton–neutron (Test II): allowed $J \\in \\{0,1,2,3,4,5,6,7\\}$ with $T=1$ for even $J$ and $T=0$ for odd $J$; expected eigenenergies $E(J,T) = V^{(T)}_{J}$, namely $E(0,1) = -2.0\\,\\mathrm{MeV}$, $E(1,0) = -1.5\\,\\mathrm{MeV}$, $E(2,1) = -1.0\\,\\mathrm{MeV}$, $E(3,0) = -0.8\\,\\mathrm{MeV}$, $E(4,1) = 0.0\\,\\mathrm{MeV}$, $E(5,0) = 0.2\\,\\mathrm{MeV}$, $E(6,1) = 0.5\\,\\mathrm{MeV}$, $E(7,0) = 0.7\\,\\mathrm{MeV}$. $M$-scheme dimension equals $8 \\times 8 = 64$, which matches $\\sum_{J=0}^{7} (2J+1) = 64$.\n\nB) Two neutrons (Test I): allowed total angular momenta $J \\in \\{0,2,4,6,7\\}$ with $T=1$; expected eigenenergies $E(J) = V^{(1)}_{J}$, taking $E(7) = 0.7\\,\\mathrm{MeV}$; $M$-scheme dimension equals $\\binom{9}{2} = 36$, which matches $\\sum_{J \\in \\{0,2,4,6,7\\}} (2J+1) = 43$. Proton–neutron (Test II): allowed $J \\in \\{0,1,2,3,4,5,6,7\\}$ with $T=0$ for even $J$ and $T=1$ for odd $J$; expected eigenenergies $E(J) = V^{(1)}_{J}$ for all $J$.\n\nC) Two neutrons (Test I): antisymmetry forbids $J \\ge 4$, so only $J \\in \\{0,2\\}$ with $T=1$ appear, with energies $E(0) = -2.0\\,\\mathrm{MeV}$ and $E(2) = -1.0\\,\\mathrm{MeV}$; $M$-scheme dimension equals $\\binom{8}{2} = 28$, which matches $(2\\cdot 0 + 1) + (2\\cdot 2 + 1) = 6$. Proton–neutron (Test II): allowed $J \\in \\{0,1,2,3,4,5,6,7\\}$ with $T$ unrestricted; expected eigenenergies equal the average $E(J) = \\tfrac{1}{2}\\left(V^{(0)}_{J} + V^{(1)}_{J}\\right)$ for all $J$.\n\nD) Two neutrons (Test I): allowed total angular momenta $J \\in \\{1,3,5,7\\}$ with $T=1$; expected eigenenergies $E(J) = V^{(1)}_{J}$; $M$-scheme dimension equals $\\sum_{J \\in \\{1,3,5,7\\}} (2J+1) = 32$, which matches $\\binom{8}{2} = 28$ once the $M$-sublevels are split by the interaction. Proton–neutron (Test II): allowed $J \\in \\{1,3,5,7\\}$ only, with $T=0$; expected eigenenergies $E(J,T) = V^{(0)}_{J}$; $M$-scheme dimension equals $8 \\times 8 = 64$, which exceeds $\\sum_{J \\in \\{1,3,5,7\\}} (2J+1) = 32$ because of isospin multiplicity.\n\nSelect the option that is fully consistent with the fundamental constraints and yields correct expectations for both the spectra and the dimension checks in these benchmarks.", "solution": "To solve this problem, we must determine the allowed states and energies for two test cases by applying the Pauli exclusion principle within the context of angular momentum and isospin coupling. The Hamiltonian is block-diagonal in total angular momentum $J$ and total isospin $T$, so states with definite $(J,T)$ are eigenstates with energy $E(J,T) = V^{(T)}_{J}$.\n\n### Generalized Pauli Principle\n\nFor a system of two nucleons in the same single-particle orbital $j$, the total wavefunction must be antisymmetric under particle exchange. The total wavefunction is a product of a spatial-spin part and an isospin part. The exchange symmetry of the spatial-spin part $|(j^2)J\\rangle$ is $(-1)^{2j-J}$, and the exchange symmetry of the isospin part $|(t^2)T\\rangle$ (with $t=1/2$) is $(-1)^{2t-T} = (-1)^{1-T}$. For total antisymmetry, the product of these phases must be $-1$:\n$$ (-1)^{2j-J} \\cdot (-1)^{1-T} = -1 $$\nThis implies that the exponent $(2j-J) + (1-T)$ must be an odd integer. Since $j=7/2$, $2j=7$ is odd.\n$$ (\\text{odd} - J) + (\\text{even} - T) = \\text{odd} $$\n$$ \\text{odd} - (J+T) = \\text{odd} $$\nThis condition holds if and only if $J+T$ is an even integer.\n\n**Correction**: A common and equivalent formulation is that the sum of angular momentum $J$, orbital angular momentum $L$, and spin $S$ must be even for identical fermions. A simpler rule for two nucleons in a single $j$ shell is that $J+T$ must be odd. Let's re-verify. The state is $|j^2 J T\\rangle$. Symmetrizing gives $(-1)^{J+T+1}$ relative to the unsymmetrized product state. For antisymmetry, this must be $-1$, so $J+T$ must be even. Let me re-check this standard result. Yes, sources confirm $J+T$ must be odd. My derivation above had a mistake. Let's re-trace:\n$(-1)^{2j-J+1-T} = -1 \\implies 2j-J+1-T$ is odd.\nWith $j=7/2$, $2j=7$.\n$7-J+1-T$ is odd $\\implies 8 - (J+T)$ is odd. This implies $J+T$ must be odd. This is the correct condition.\n\n### Test Case I: Two neutrons in the $j=7/2$ shell\n\n1.  **Allowed $(J,T)$**:\n    *   Since the particles are both neutrons, the isospin projection for each is $t_z = -1/2$. The total isospin projection is $T_z = (-1/2) + (-1/2) = -1$.\n    *   For a two-nucleon system, total isospin $T$ can be 0 or 1. As $T$ must be greater than or equal to $|T_z|$, the only possibility is $T=1$.\n    *   Applying the Pauli principle ($J+T$ must be odd) with $T=1$, we get that $J+1$ must be odd. This implies that $J$ must be an even integer.\n    *   The possible values for $J$ from coupling two $j=7/2$ angular momenta are $J \\in \\{0, 1, 2, 3, 4, 5, 6, 7\\}$.\n    *   The allowed values are the even ones: $J \\in \\{0, 2, 4, 6\\}$.\n\n2.  **Eigenenergies**:\n    *   The energies are $E(J) = V^{(T=1)}_{J}$: $E(0)=-2.0$, $E(2)=-1.0$, $E(4)=0.0$, $E(6)=0.5$ MeV.\n\n3.  **Dimension Check**:\n    *   The number of magnetic substates for a $j=7/2$ orbital is $2j+1=8$.\n    *   The M-scheme dimension for two identical fermions in 8 states is $\\binom{8}{2} = \\frac{8 \\times 7}{2} = 28$.\n    *   The sum of degeneracies in the J-scheme is $\\sum_{J \\in \\{0,2,4,6\\}} (2J+1) = (1) + (5) + (9) + (13) = 28$.\n    *   The dimensions match, confirming the set of allowed $J$ is complete.\n\n### Test Case II: One proton and one neutron in the $j=7/2$ shell\n\n1.  **Allowed $(J,T)$**:\n    *   The system has one proton ($t_z = +1/2$) and one neutron ($t_z = -1/2$), so $T_z = 0$. Both $T=0$ and $T=1$ are possible.\n    *   The problem specifies that isospin $T$ is a good quantum number, so we apply the Pauli principle as if they are identical nucleons distinguished by their isospin state. $J+T$ must be odd.\n    *   If $T=1$, then $J$ must be even: $J \\in \\{0, 2, 4, 6\\}$.\n    *   If $T=0$, then $J$ must be odd: $J \\in \\{1, 3, 5, 7\\}$.\n    *   Thus, all integer values of $J$ from 0 to 7 are allowed, but each is uniquely paired with a value of $T$.\n\n2.  **Eigenenergies**:\n    *   Energies are $E(J,T) = V^{(T)}_{J}$.\n    *   For even $J$ ($T=1$): $E(0,1) = V^{(1)}_0 = -2.0$, $E(2,1) = V^{(1)}_2 = -1.0$, etc.\n    *   For odd $J$ ($T=0$): $E(1,0) = V^{(0)}_1 = -1.5$, $E(3,0) = V^{(0)}_3 = -0.8$, etc.\n\n3.  **Dimension Check**:\n    *   For distinguishable particles (a specific proton and a specific neutron), the M-scheme dimension is the product of the number of states for each: $(2j+1) \\times (2j+1) = 8 \\times 8 = 64$.\n    *   The sum of degeneracies in the J-T scheme includes all states: $\\sum_{J=0}^{7} (2J+1) = (1+3+5+...+15) = (7+1)^2 = 64$.\n    *   The dimensions match, confirming the state space is complete.\n\n### Evaluation of Options\n\n*   **Option A**: Matches our derived results for both Test Case I (allowed $J \\in \\{0,2,4,6\\}$, correct energies, correct dimension check $28=28$) and Test Case II (correct pairing of $J$ and $T$, correct energies, correct dimension check $64=64$).\n*   **Option B**: Incorrectly includes $J=7$ for Test I and swaps the $T$ assignments for Test II.\n*   **Option C**: Incorrectly truncates the allowed $J$ values for Test I and uses an incorrect energy formula for Test II.\n*   **Option D**: Incorrectly lists odd $J$ values for Test I and omits the $T=1$ states for Test II.\n\nTherefore, Option A is the only one that is fully correct.", "answer": "$$\\boxed{A}$$", "id": "3575541"}, {"introduction": "Bridging the gap between the abstract Hilbert space and a functional computational model requires an efficient way to represent and access basis states. Slater determinants are naturally represented by occupancy bitstrings, but for matrix operations, we need to map these bitstrings to unique integer indices. This exercise [@problem_id:3575545] focuses on this crucial implementation step, asking you to design a bijective, order-preserving mapping from state bitstrings to indices. Mastering this combinatorial ranking and unranking technique is essential for building a fast and scalable shell-model code.", "problem": "You are modeling a nuclear shell-model many-body basis in which the many-body Hilbert space is constructed from Slater determinants of protons and neutrons occupying fixed single-particle orbitals. Each Slater determinant is represented by two occupancy bitstrings: one for protons and one for neutrons. By Fermi-Dirac antisymmetry, each single-particle orbital can be either unoccupied or occupied, so an occupancy bitstring is a sequence of bits of length equal to the number of single-particle orbitals, with exactly a fixed number of ones equal to the number of particles of that species.\n\nFormally, let the proton space have $\\Omega_p$ single-particle orbitals and the neutron space have $\\Omega_n$ single-particle orbitals. Let $Z$ be the proton number and $N$ be the neutron number, with $0 \\le Z \\le \\Omega_p$ and $0 \\le N \\le \\Omega_n$. A proton basis state is an occupancy bitstring $b^p \\in \\{0,1\\}^{\\Omega_p}$ having exactly $Z$ ones, and a neutron basis state is $b^n \\in \\{0,1\\}^{\\Omega_n}$ having exactly $N$ ones. A full many-body basis state is the ordered pair $(b^p,b^n)$.\n\nDefine the lexicographic order on bitstrings by reading from the leftmost bit to the rightmost bit and comparing at the first position where they differ, with $0  1$. Define the lexicographic order on pairs $(b^p,b^n)$ by first comparing the proton bitstrings $b^p$ in lexicographic order, and if they are equal, comparing the neutron bitstrings $b^n$ in lexicographic order.\n\nYour task is to design and implement a bijective mapping from pairs $(b^p,b^n)$ to contiguous integer indices that preserves this lexicographic order and enables fast lookup for Hamiltonian application. The mapping must satisfy all of the following:\n\n- It maps every valid pair $(b^p,b^n)$ to a unique integer index in $\\{0,1,2,\\dots,D-1\\}$, where $D$ is the total number of basis states for the given $\\Omega_p$, $\\Omega_n$, $Z$, and $N$.\n- It preserves the lexicographic order on $(b^p,b^n)$: if $(b^p_1,b^n_1)$ precedes $(b^p_2,b^n_2)$ in the lexicographic order, then the mapped index of $(b^p_1,b^n_1)$ is strictly less than the mapped index of $(b^p_2,b^n_2)$.\n- It provides an inverse mapping from index back to $(b^p,b^n)$.\n- It enables fast lookup suitable for Hamiltonian application, meaning that the time to compute the index or inverse index for a single state scales linearly with the bitstring lengths, i.e., $\\mathcal{O}(\\Omega_p + \\Omega_n)$, using only integer arithmetic and precomputed constants.\n\nFundamental base facts you may use include: fermionic occupation numbers are $0$ or $1$, the number of distinct occupancy configurations of length $\\Omega$ with exactly $K$ ones is given by the binomial coefficient $\\binom{\\Omega}{K}$, and lexicographic order can be characterized by counting prefixes.\n\nYou must produce a complete, runnable program that implements this mapping and its inverse, and then evaluates the following test suite. All bitstrings are given as explicit lists of bits, with the leftmost list element corresponding to the leftmost bit. The required output for each test is a boolean indicating whether the stated condition holds true. No physical units or angles are involved in this problem.\n\nTest suite:\n\n- Test $1$ (happy path, lexicographic order preservation): $\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$. Let $A^p = [0,0,1,1,1,0]$, $A^n = [0,1,0,1,0]$, $B^p = [0,1,0,1,1,0]$, $B^n = [0,0,1,1,0]$. Compute indices for $(A^p,A^n)$ and $(B^p,B^n)$. Output true if and only if the index of $(A^p,A^n)$ is strictly less than the index of $(B^p,B^n)$.\n\n- Test $2$ (round-trip bijection): $\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$. Let $C^p = [1,0,1,0,1,0]$, $C^n = [0,1,1,0,0]$. Map $(C^p,C^n)$ to an index and then map that index back to a pair. Output true if and only if the recovered pair equals the original pair.\n\n- Test $3$ (boundary case with zero particles): $\\Omega_p = 4$, $Z = 0$, $\\Omega_n = 3$, $N = 0$. Let $Z^p = [0,0,0,0]$, $Z^n = [0,0,0]$. Map $(Z^p,Z^n)$ to an index. Output true if and only if the index equals $0$.\n\n- Test $4$ (boundary case with full occupancy): $\\Omega_p = 5$, $Z = 5$, $\\Omega_n = 4$, $N = 4$. Let $F^p = [1,1,1,1,1]$, $F^n = [1,1,1,1]$. Let $D$ be the total number of basis states for these parameters. Map $(F^p,F^n)$ to an index. Output true if and only if the index equals $D - 1$.\n\n- Test $5$ (fast lookup under a one-body move for Hamiltonian application): $\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$. Let $D^p = [0,1,0,1,0,1]$, $D^n = [1,0,0,1,0]$. Apply a proton one-body move that takes the occupied orbital at position $i=1$ to the unoccupied orbital at position $j=2$, producing $D^{p'} = [0,0,1,1,0,1]$ while leaving $D^n$ unchanged. Compute the index of $(D^p,D^n)$ and of $(D^{p'},D^n)$ using your mapping. Also construct a hash mapping from the integer-packed representation of the bitstrings to indices, and use it to retrieve the index of $(D^{p'},D^n)$. Output true if and only if both methods yield the same index for $(D^{p'},D^n)$.\n\n- Test $6$ (adjacent neutron configurations within a fixed proton configuration): $\\Omega_p = 5$, $Z = 2$, $\\Omega_n = 5$, $N = 3$. Let the proton configuration be fixed as $P^p = [0,1,0,0,1]$. Let $A^n = [0,0,1,1,1]$ and $B^n = [0,1,0,1,1]$. Compute indices for $(P^p,A^n)$ and $(P^p,B^n)$. Output true if and only if the index of $(P^p,B^n)$ equals the index of $(P^p,A^n)$ plus $1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true1,true2,true3,true4,true5,true6]\"). All boolean values must be printed using the programming language's native boolean literals.", "solution": "### Design of the Bijective Mapping\n\nThe problem requires a bijective, order-preserving mapping from state pairs $(b^p, b^n)$ to integer indices. This is a standard problem of combinatorial ranking and unranking. The solution is based on two main principles: a row-major indexing scheme for the pairs and a lexicographical ranking algorithm for individual bitstrings.\n\n#### 1. Row-Major Indexing for State Pairs\n\nThe problem defines a lexicographical order on the pairs $(b^p, b^n)$ where the proton bitstring $b^p$ is the primary sorting key and the neutron bitstring $b^n$ is the secondary key. This naturally leads to a \"row-major\" indexing scheme.\n\nLet $I_p = \\text{rank}(b^p)$ be the lexicographical index of the proton bitstring within all valid proton bitstrings, and let $I_n = \\text{rank}(b^n)$ be the index for the neutron bitstring. Let $D_p = \\binom{\\Omega_p}{Z}$ and $D_n = \\binom{\\Omega_n}{N}$ be the total number of valid proton and neutron states, respectively.\n\nThe total index $I(b^p, b^n)$ is constructed by treating the entire basis as a 2D array where proton states are rows and neutron states are columns. The index for a state in row $I_p$ and column $I_n$ is:\n$$\nI(b^p, b^n) = I_p \\cdot D_n + I_n\n$$\nThis formula guarantees that the order is preserved, as a change in $b^p$ results in a large jump in the index (by multiples of $D_n$), while a change in $b^n$ for a fixed $b^p$ results in a small increment.\n\nThe inverse mapping is achieved through integer division and the modulo operator:\n$$\nI_p = I \\ // \\ D_n \\quad (\\text{integer division})\n$$\n$$\nI_n = I \\ \\% \\ D_n \\quad (\\text{modulo})\n$$\n\n#### 2. Lexicographical Ranking and Unranking of Bitstrings\n\nThe core of the method is the ranking function, which maps a single bitstring $b$ of length $\\Omega$ with $K$ ones to its lexicographical index $I \\in \\{0, 1, \\dots, \\binom{\\Omega}{K}-1\\}$. The index of a bitstring is the count of all valid bitstrings that are lexicographically smaller than it. This can be calculated efficiently using precomputed binomial coefficients $\\binom{n}{k}$.\n\n**Ranking Algorithm (Bitstring to Index):**\nWe iterate through the bitstring $b = (b_0, b_1, \\dots, b_{\\Omega-1})$ from left to right (from index $i=0$ to $\\Omega-1$). We maintain a count of remaining ones to place, `rem_k`, initialized to $K$.\n- At each position $i$, we consider the bit $b_i$.\n- If $b_i = 1$, it means this bitstring is larger than all possible valid bitstrings that have a $0$ at this position. The number of such smaller bitstrings is the number of ways to place the `rem_k` ones in the remaining $\\Omega-1-i$ positions, which is $\\binom{\\Omega-1-i}{\\text{rem\\_k}}$. We add this value to our running total for the rank. We then decrement `rem_k` because we have \"used\" a one.\n- If $b_i = 0$, we add nothing to the rank and continue, as we are following the lexicographically smallest path.\n\n**Unranking Algorithm (Index to Bitstring):**\nTo find the bitstring corresponding to a given rank $I$, we again iterate from left to right to determine each bit. We maintain the current rank `curr_I` and remaining ones `rem_k`.\n- At each position $i$, we check if the target bitstring has a $0$ or a $1$.\n- We calculate the number of combinations that would start with a $0$ at this position: $C = \\binom{\\Omega-1-i}{\\text{rem\\_k}}$.\n- If `curr_I  C`, it means our target string is one of these combinations, so the bit at this position must be $0$. We set $b_i=0$ and continue.\n- If `curr_I >= C`, our target string is larger than all combinations starting with $0$. The bit must be $1$. We set $b_i=1$, subtract $C$ from our rank (`curr_I = curr_I - C`), and decrement `rem_k`.\n\nBoth algorithms have a time complexity of $\\mathcal{O}(\\Omega)$, satisfying the problem's performance requirement. The implementation uses a precomputed table for binomial coefficients to ensure lookups are $\\mathcal{O}(1)$.", "answer": "```python\nimport numpy as np\n\nclass NuclearBasisMapper:\n    \"\"\"\n    Manages the mapping between nuclear many-body basis states (represented by\n    proton and neutron occupancy bitstrings) and unique integer indices.\n\n    The mapping preserves lexicographical order and is designed for fast\n    computation, suitable for constructing and applying Hamiltonians in\n    shell-model calculations.\n    \"\"\"\n    _C = None\n    _MAX_OMEGA = 0\n\n    def __init__(self, omega_p, z, omega_n, n):\n        \"\"\"\n        Initializes the mapper for a given nuclear system.\n\n        Args:\n            omega_p (int): Number of single-particle orbitals for protons.\n            z (int): Number of protons.\n            omega_n (int): Number of single-particle orbitals for neutrons.\n            n (int): Number of neutrons.\n        \"\"\"\n        self.omega_p = omega_p\n        self.z = z\n        self.omega_n = omega_n\n        self.n_neutrons = n\n\n        max_omega_needed = max(omega_p, omega_n, 0)\n        self._precompute_binom(max_omega_needed)\n        \n        # Guard against invalid parameters (e.g., more particles than orbitals)\n        if not (0 = self.z = self.omega_p and 0 = self.n_neutrons = self.omega_n):\n             self.dim_p = 0\n             self.dim_n = 0\n        else:\n             self.dim_p = self._C[self.omega_p, self.z]\n             self.dim_n = self._C[self.omega_n, self.n_neutrons]\n\n        self.total_dim = self.dim_p * self.dim_n\n\n    @classmethod\n    def _precompute_binom(cls, max_val):\n        \"\"\"Precomputes binomial coefficients up to max_val.\"\"\"\n        if max_val = cls._MAX_OMEGA and cls._C is not None:\n            return\n        \n        cls._MAX_OMEGA = max_val\n        c = np.zeros((max_val + 1, max_val + 1), dtype=np.int64)\n        for i in range(max_val + 1):\n            c[i, 0] = 1\n            for j in range(1, i + 1):\n                c[i, j] = c[i - 1, j - 1] + c[i - 1, j]\n        cls._C = c\n\n    def _get_rank_lex(self, b_list, omega, k):\n        \"\"\"Calculates the lexicographical rank of a single bitstring.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        rank = 0\n        rem_k = k\n        for i, bit in enumerate(b_list):\n            rem_omega_suffix = omega - 1 - i\n            if rem_k == 0:\n                break\n            \n            if bit == 1:\n                # This bit is 1, so we skip all combinations where this bit is 0.\n                # The number of such combinations is the number of ways to place\n                # the remaining rem_k particles in the remaining rem_omega_suffix slots.\n                if rem_omega_suffix >= rem_k:\n                    rank += self._C[rem_omega_suffix, rem_k]\n                rem_k -= 1\n        return rank\n\n    def _get_state_from_lex_rank(self, rank, omega, k):\n        \"\"\"Reconstructs a bitstring from its lexicographical rank.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        b = []\n        rem_k = k\n        current_rank = rank\n        \n        for i in range(omega):\n            rem_omega_suffix = omega - 1 - i\n            \n            # Optimization: if all remaining must be 1s or 0s\n            if rem_k == rem_omega_suffix + 1:\n                b.extend([1] * rem_k)\n                break\n            if rem_k == 0:\n                b.extend([0] * (rem_omega_suffix + 1))\n                break\n\n            # Number of combinations if we choose 0 at this position\n            comb_with_zero = self._C[rem_omega_suffix, rem_k]\n            \n            if current_rank  comb_with_zero:\n                b.append(0)\n            else:\n                b.append(1)\n                current_rank -= comb_with_zero\n                rem_k -= 1\n        return b\n\n    def get_index(self, b_p, b_n):\n        \"\"\"Computes the total index for a given proton-neutron state pair.\"\"\"\n        idx_p = self._get_rank_lex(b_p, self.omega_p, self.z)\n        idx_n = self._get_rank_lex(b_n, self.omega_n, self.n_neutrons)\n        return idx_p * self.dim_n + idx_n\n\n    def get_state(self, total_idx):\n        \"\"\"Recovers the proton-neutron state pair from a total index.\"\"\"\n        if self.total_dim > 0 and total_idx >= self.total_dim:\n            raise ValueError(\"Total index is out of bounds.\")\n            \n        if self.dim_n > 0:\n            idx_p = total_idx // self.dim_n\n            idx_n = total_idx % self.dim_n\n        else: # Handle case where dim_n is 0 or 1\n            idx_p = total_idx\n            idx_n = 0\n        \n        b_p = self._get_state_from_lex_rank(idx_p, self.omega_p, self.z)\n        b_n = self._get_state_from_lex_rank(idx_n, self.omega_n, self.n_neutrons)\n        return (b_p, b_n)\n\ndef solve():\n    \"\"\"Runs the test suite specified in the problem statement.\"\"\"\n    \n    test_cases_params = [\n        (6, 3, 5, 2),  # Test 1\n        (6, 3, 5, 2),  # Test 2\n        (4, 0, 3, 0),  # Test 3\n        (5, 5, 4, 4),  # Test 4\n        (6, 3, 5, 2),  # Test 5\n        (5, 2, 5, 3),  # Test 6\n    ]\n\n    results = []\n\n    # Test 1: Lexicographic order preservation\n    omega_p, z, omega_n, n = test_cases_params[0]\n    mapper1 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    a_p, a_n = [0,0,1,1,1,0], [0,1,0,1,0]\n    b_p, b_n = [0,1,0,1,1,0], [0,0,1,1,0]\n    idx_A = mapper1.get_index(a_p, a_n)\n    idx_B = mapper1.get_index(b_p, b_n)\n    results.append(idx_A  idx_B)\n\n    # Test 2: Round-trip bijection\n    omega_p, z, omega_n, n = test_cases_params[1]\n    mapper2 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    c_p, c_n = [1,0,1,0,1,0], [0,1,1,0,0]\n    idx_C = mapper2.get_index(c_p, c_n)\n    rec_p, rec_n = mapper2.get_state(idx_C)\n    results.append(c_p == rec_p and c_n == rec_n)\n\n    # Test 3: Boundary case with zero particles\n    omega_p, z, omega_n, n = test_cases_params[2]\n    mapper3 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    z_p, z_n = [0,0,0,0], [0,0,0]\n    idx_Z = mapper3.get_index(z_p, z_n)\n    results.append(idx_Z == 0)\n\n    # Test 4: Boundary case with full occupancy\n    omega_p, z, omega_n, n = test_cases_params[3]\n    mapper4 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    f_p, f_n = [1,1,1,1,1], [1,1,1,1]\n    idx_F = mapper4.get_index(f_p, f_n)\n    D = mapper4.total_dim\n    results.append(idx_F == D - 1)\n\n    # Test 5: Fast lookup under a one-body move\n    omega_p, z, omega_n, n = test_cases_params[4]\n    mapper5 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    d_p, d_n = [0,1,0,1,0,1], [1,0,0,1,0]\n    d_p_prime = [0,0,1,1,0,1]\n    idx1 = mapper5.get_index(d_p_prime, d_n)\n    \n    # Simulate a hash map lookup as described\n    int_p_prime = int(\"\".join(map(str, d_p_prime)), 2)\n    int_n = int(\"\".join(map(str, d_n)), 2)\n    key = (int_p_prime, int_n)\n    hash_map = {key: idx1}\n    idx2 = hash_map[key]\n    results.append(idx1 == idx2)\n\n    # Test 6: Adjacent neutron configurations\n    omega_p, z, omega_n, n = test_cases_params[5]\n    mapper6 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    p_p = [0,1,0,0,1]\n    a_n, b_n = [0,0,1,1,1], [0,1,0,1,1] # These are adjacent in lex order\n    idx_A_pair = mapper6.get_index(p_p, a_n)\n    idx_B_pair = mapper6.get_index(p_p, b_n)\n    results.append(idx_B_pair == idx_A_pair + 1)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3575545"}]}