{"hands_on_practices": [{"introduction": "The foundation of the finite element method lies in constructing the element stiffness matrix, $\\mathbf{K}_e$, which mathematically links an element's nodal displacements to its nodal forces. This first exercise guides you through the derivation of the stiffness matrix for a Constant Strain Triangle (CST) from the principle of virtual work, providing a hands-on experience with the core mechanics of the formulation [@problem_id:3607848]. By explicitly calculating $\\mathbf{K}_e$ and verifying its fundamental properties, you will build a crucial intuition for how element geometry and material laws translate into a computable structural response.", "problem": "Consider a two-dimensional linear elastic body under plane stress with constitutive matrix $\\mathbf{D}=\\dfrac{E}{1-\\nu^{2}}\\begin{bmatrix}1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$, where $E$ is Young’s modulus and $\\nu$ is Poisson’s ratio. Using the Constant Strain Triangle (CST) formulation, derive from first principles based on the principle of virtual work the element stiffness matrix $\\mathbf{K}_{e}$ for the triangular finite element with nodal coordinates $((x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{3}))=((0,0),(2,0),(0,1))$ and uniform thickness $t$. Explicitly compute $\\mathbf{K}_{e}$ in terms of $E$, $\\nu$, and $t$, and verify the symmetry and positive semidefiniteness of $\\mathbf{K}_{e}$ using the energy argument. Finally, provide the exact value of the determinant $\\det(\\mathbf{K}_{e})$ as a dimensionless scalar. No rounding is required. Define both the Constant Strain Triangle (CST) and the Linear Strain Triangle (LST) acronyms on first use.", "solution": "A Constant Strain Triangle (CST) is a 3-node triangular finite element characterized by a linear displacement field. This formulation results in strains (and stresses) that are constant throughout the element. In contrast, a Linear Strain Triangle (LST) is a 6-node triangular element (with midside nodes) characterized by a quadratic displacement field, which results in strains (and stresses) that vary linearly over the element.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is derived from the principle of virtual work. For a single element, the internal virtual work $\\delta W_{int}$ is given by:\n$$ \\delta W_{int} = \\int_{V_e} \\delta \\boldsymbol{\\epsilon}^T \\boldsymbol{\\sigma} \\, dV $$\nwhere $\\boldsymbol{\\sigma}$ is the stress vector, $\\delta \\boldsymbol{\\epsilon}$ is the virtual strain vector, and the integration is over the element volume $V_e$.\n\nThe kinematic relationship for a CST element links the displacement field $\\mathbf{u}(x,y)$ to the nodal displacements $\\mathbf{d}_e$ via linear shape functions $N_i(x,y)$.\n$$ \\mathbf{u}(x,y) = \\begin{Bmatrix} u(x,y) \\\\ v(x,y) \\end{Bmatrix} = \\mathbf{N}(x,y) \\mathbf{d}_e $$\nwhere $\\mathbf{d}_e = \\{u_1, v_1, u_2, v_2, u_3, v_3\\}^T$ is the vector of nodal displacements, and the shape function matrix is:\n$$ \\mathbf{N}(x,y) = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} $$\nThe shape functions are $N_i(x,y) = \\frac{1}{2A}(a_i + b_i x + c_i y)$, where $A$ is the element area and the coefficients are $a_i = x_j y_k - x_k y_j$, $b_i = y_j - y_k$, and $c_i = x_k - x_j$ for cyclic indices $(i,j,k)$.\n\nThe strain vector $\\boldsymbol{\\epsilon} = \\{\\epsilon_x, \\epsilon_y, \\gamma_{xy}\\}^T$ is related to the displacement field by $\\boldsymbol{\\epsilon} = \\mathbf{L}\\mathbf{u}$, where $\\mathbf{L}$ is the differential operator. Substituting the interpolated displacement, we get:\n$$ \\boldsymbol{\\epsilon} = \\mathbf{B} \\mathbf{d}_e $$\nwhere $\\mathbf{B} = \\mathbf{L}\\mathbf{N}$ is the strain-displacement matrix. For a CST, $\\mathbf{B}$ is constant:\n$$ \\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix} b_1 & 0 & b_2 & 0 & b_3 & 0 \\\\ 0 & c_1 & 0 & c_2 & 0 & c_3 \\\\ c_1 & b_1 & c_2 & b_2 & c_3 & b_3 \\end{bmatrix} $$\n\nThe constitutive law relates stress and strain: $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\epsilon} = \\mathbf{D} \\mathbf{B} \\mathbf{d}_e$. Substituting these into the virtual work expression:\n$$ \\delta W_{int} = \\int_{V_e} (\\delta(\\mathbf{B} \\mathbf{d}_e))^T (\\mathbf{D} \\mathbf{B} \\mathbf{d}_e) \\, dV = \\delta \\mathbf{d}_e^T \\left( \\int_{V_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV \\right) \\mathbf{d}_e $$\nFrom the definition $\\delta W_{int} = \\delta \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$, the element stiffness matrix is:\n$$ \\mathbf{K}_e = \\int_{V_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV $$\nFor a CST with uniform thickness $t$, $\\mathbf{B}$ and $\\mathbf{D}$ are constant, so the integral simplifies to:\n$$ \\mathbf{K}_e = (\\mathbf{B}^T \\mathbf{D} \\mathbf{B}) \\cdot (A \\cdot t) $$\n\nNow, we compute $\\mathbf{K}_e$ for the given element with nodes $(0,0)$, $(2,0)$, and $(0,1)$.\nThe area of the triangle is $A = \\frac{1}{2} |\\det \\begin{bmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 & 1 \\end{bmatrix}| = \\frac{1}{2} |\\det \\begin{bmatrix} 0 & 0 & 1 \\\\ 2 & 0 & 1 \\\\ 0 & 1 & 1 \\end{bmatrix}| = \\frac{1}{2} |1(2 \\cdot 1 - 0 \\cdot 0)| = 1$.\nThe coefficients $b_i$ and $c_i$ are:\n$b_1 = y_2 - y_3 = 0 - 1 = -1$\n$b_2 = y_3 - y_1 = 1 - 0 = 1$\n$b_3 = y_1 - y_2 = 0 - 0 = 0$\n$c_1 = x_3 - x_2 = 0 - 2 = -2$\n$c_2 = x_1 - x_3 = 0 - 0 = 0$\n$c_3 = x_2 - x_1 = 2 - 0 = 2$\n\nWith $2A = 2$, the $\\mathbf{B}$ matrix is:\n$$ \\mathbf{B} = \\frac{1}{2} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} $$\nThe constitutive matrix is $\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix}$.\n\nWe now compute $\\mathbf{K}_e = t A \\mathbf{B}^T \\mathbf{D} \\mathbf{B} = t \\mathbf{B}^T \\mathbf{D} \\mathbf{B}$.\n$$ \\mathbf{K}_e = t \\left( \\frac{1}{2} \\begin{bmatrix} -1 & 0 & -2 \\\\ 0 & -2 & -1 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 2 \\\\ 0 & 2 & 0 \\end{bmatrix} \\right) \\left( \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} \\right) \\left( \\frac{1}{2} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} \\right) $$\n$$ \\mathbf{K}_e = \\frac{Et}{4(1-\\nu^2)} \\begin{bmatrix} -1 & 0 & -2 \\\\ 0 & -2 & -1 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 2 \\\\ 0 & 2 & 0 \\end{bmatrix} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} $$\nPerforming the matrix multiplications yields:\n$$ \\mathbf{K}_e = \\frac{Et}{4(1-\\nu^2)} \\begin{bmatrix} 3-2\\nu & 1+\\nu & -1 & \\nu-1 & 2\\nu-2 & -2\\nu \\\\ 1+\\nu & \\frac{9-\\nu}{2} & -2\\nu & -\\frac{1-\\nu}{2} & \\nu-1 & -4 \\\\ -1 & -2\\nu & 1 & 0 & 0 & 2\\nu \\\\ \\nu-1 & -\\frac{1-\\nu}{2} & 0 & \\frac{1-\\nu}{2} & 1-\\nu & 0 \\\\ 2\\nu-2 & \\nu-1 & 0 & 1-\\nu & 2(1-\\nu) & 0 \\\\ -2\\nu & -4 & 2\\nu & 0 & 0 & 4 \\end{bmatrix} $$\n\n**Verification of Symmetry and Positive Semidefiniteness:**\n1.  **Symmetry:** The stiffness matrix is given by $\\mathbf{K}_e = tA\\mathbf{B}^T\\mathbf{D}\\mathbf{B}$. Its transpose is $\\mathbf{K}_e^T = tA(\\mathbf{B}^T\\mathbf{D}\\mathbf{B})^T = tA\\mathbf{B}^T\\mathbf{D}^T(\\mathbf{B}^T)^T = tA\\mathbf{B}^T\\mathbf{D}\\mathbf{B} = \\mathbf{K}_e$, because the constitutive matrix $\\mathbf{D}$ for a linear elastic material is symmetric ($\\mathbf{D}^T = \\mathbf{D}$). The explicitly computed matrix can also be seen to be symmetric by inspection.\n2.  **Positive Semidefiniteness:** The strain energy stored in the element is $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$. Since strain energy must be non-negative for any physically admissible displacement $\\mathbf{d}_e$, the quadratic form $\\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$ must be greater than or equal to zero. This is the definition of a positive semidefinite matrix. The energy is zero only if the strains are zero, i.e., $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}_e = 0$. This occurs for rigid body motions (translation and rotation), for which the element does not deform. An unconstrained element stiffness matrix must admit these zero-energy modes, which correspond to a non-trivial null space. Therefore, $\\mathbf{K}_e$ must be singular and positive semidefinite, not positive definite.\n\n**Determinant of $\\mathbf{K}_e$:**\nA singular matrix has a determinant of zero. We can verify that $\\mathbf{K}_e$ is singular by identifying its null space vectors, which correspond to rigid body motions.\nFor a rigid body translation in the $x$-direction, $\\mathbf{d}_e = \\{1, 0, 1, 0, 1, 0\\}^T$. The product $\\mathbf{K}_e \\mathbf{d}_e$ is the sum of the 1st, 3rd, and 5th columns of $\\mathbf{K}_e$. Summing the elements of the first row gives:\n$\\frac{Et}{4(1-\\nu^2)}[(3-2\\nu) + (-1) + (2\\nu-2)] = \\frac{Et}{4(1-\\nu^2)}[0] = 0$.\nThis holds for all rows. Thus, $\\mathbf{K}_e \\mathbf{d}_e = \\mathbf{0}$ for this $\\mathbf{d}_e$, confirming a non-trivial null space.\nSimilarly, for a rigid translation in the $y$-direction, $\\mathbf{d}_e = \\{0, 1, 0, 1, 0, 1\\}^T$, the sum of the 2nd, 4th, and 6th columns is the zero vector.\nSince $\\mathbf{K}_e$ has a non-trivial null space, it is singular. The determinant of any singular matrix is zero.\n$$ \\det(\\mathbf{K}_e) = 0 $$\nThe value $0$ is a dimensionless scalar, satisfying the problem's requirement.", "answer": "$$\n\\boxed{0}\n$$", "id": "3607848"}, {"introduction": "After deriving the theoretical formulation, the next critical step is to verify its implementation. The \"patch test\" is a fundamental benchmark that any valid finite element formulation must pass to guarantee convergence, ensuring that an assembly of elements can exactly represent a constant strain state [@problem_id:3607774]. This practice involves writing code to numerically confirm that a patch of CST elements correctly reproduces a linear displacement field and that the internal forces are perfectly balanced by consistent boundary tractions.", "problem": "Consider small-strain, linear-elastic, plane stress in two spatial dimensions with zero body forces. Let the displacement field be $\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix}$, with infinitesimal strain tensor $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix}$. For an isotropic material under plane stress, let $\\mathbf{D}$ be the elastic constitutive matrix such that $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\sigma} = \\begin{bmatrix} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\sigma_{xy} \\end{bmatrix}$ is the Cauchy stress vector. For Young’s modulus $E$ and Poisson’s ratio $\\nu$, the plane stress matrix is $\\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$.\n\nIn a Constant Strain Triangle (CST) finite element, the displacement is interpolated with linear shape functions over each triangle. Denote the element thickness by $t$ (out-of-plane, constant and positive). The virtual work statement with zero body forces and consistent boundary tractions $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ on the boundary $\\Gamma$ leads to the assembled equilibrium (residual) vector $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$, where $\\mathbf{f}_{\\mathrm{int}}$ is the assembled internal nodal force vector with components $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega$ per element and $\\mathbf{f}_{\\mathrm{trac}}$ is the assembled consistent nodal traction vector with components $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$ per boundary edge, and $\\mathbf{B}$ is the standard CST strain-displacement matrix constructed from derivatives of linear shape functions, and $\\mathbf{N}$ is the matrix collecting the shape functions for the two displacement components.\n\nYour task is to design and analyze three triangle patches made of CST elements and to verify, numerically and algorithmically, the following two properties derived from first principles:\n- If the exact displacement is a linear function of $x$ and $y$, then the CST interpolation reproduces it pointwise over each element when nodal values are taken from the same linear field.\n- Under zero body forces and with boundary tractions set to the exact $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ corresponding to the same linear field, the assembled residual $\\mathbf{r}$ vanishes, i.e., the global internal forces are exactly balanced by the boundary tractions, so the residual norm is zero.\n\nImplement a complete program that, for each of the specified patches and linear displacement fields, computes:\n- The maximum absolute displacement reproduction error over a set of sample points inside each triangle, measured as $\\max\\limits_{\\text{samples},\\ \\alpha \\in \\{u,v\\}} \\left| \\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}} \\right|$, expressed in meters (SI unit).\n- The Euclidean norm of the assembled residual vector $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$, expressed in Newtons (SI unit), when consistent boundary tractions $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ are applied on the boundary edges in counterclockwise order.\n\nUse the following three test cases (all coordinates in meters, moduli in Pascals, thickness in meters). For each case, the linear displacement field is given in the form $u(x,y) = a_0 + a_1 x + a_2 y$ and $v(x,y) = b_0 + b_1 x + b_2 y$. All angles, if any appear, must be in radians.\n\nTest case $\\mathbf{1}$ (baseline patch of two triangles forming a square):\n- Nodes $\\mathbf{x}_i$: $\\left[(0,0),(1,0),(1,1),(0,1)\\right]$.\n- Elements (triples of node indices, zero-based): $\\left[(0,1,2),(0,2,3)\\right]$.\n- Boundary edges (ordered counterclockwise as pairs of node indices): $\\left[(0,1),(1,2),(2,3),(3,0)\\right]$.\n- Material: $E = 210\\times 10^9$, $\\nu = 0.3$, $t = 0.01$.\n- Linear field coefficients: $a_0 = 1$, $a_1 = 2$, $a_2 = -3$, $b_0 = -0.5$, $b_1 = 4$, $b_2 = 1$.\n\nTest case $\\mathbf{2}$ (patch with an interior node: four triangles meeting at center):\n- Nodes $\\mathbf{x}_i$: $\\left[(0,0),(2,0),(2,1),(0,1),(1,0.5)\\right]$.\n- Elements: $\\left[(0,1,4),(1,2,4),(2,3,4),(3,0,4)\\right]$.\n- Boundary edges (counterclockwise): $\\left[(0,1),(1,2),(2,3),(3,0)\\right]$.\n- Material: $E = 70\\times 10^9$, $\\nu = 0.25$, $t = 0.02$.\n- Linear field coefficients: $a_0 = -0.1$, $a_1 = 0.3$, $a_2 = 0.2$, $b_0 = 0.7$, $b_1 = -0.6$, $b_2 = 0.4$.\n\nTest case $\\mathbf{3}$ (edge case: a single, skinny triangle):\n- Nodes $\\mathbf{x}_i$: $\\left[(0,0),(0.001,0),(1,0.1)\\right]$.\n- Elements: $\\left[(0,1,2)\\right]$.\n- Boundary edges (counterclockwise): $\\left[(0,1),(1,2),(2,0)\\right]$.\n- Material: $E = 110\\times 10^9$, $\\nu = 0.29$, $t = 0.005$.\n- Linear field coefficients (rigid body motion: zero strain): $a_0 = 0.02$, $a_1 = 0$, $a_2 = 0.001$, $b_0 = -0.03$, $b_1 = -0.001$, $b_2 = 0$.\n\nAlgorithmic requirements:\n- Use the standard CST construction. For each triangle with nodes $(x_i,y_i)$, define linear shape functions $N_i(x,y)$, $i\\in\\{1,2,3\\}$, and their constant derivatives over the element. Construct the element $\\mathbf{B}$ matrix accordingly.\n- Compute the exact constant strain for the given linear field as $\\varepsilon_{xx} = a_1$, $\\varepsilon_{yy} = b_2$, and $\\gamma_{xy} = a_2 + b_1$, and then compute $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$.\n- Assemble the internal force vector as the sum over elements of $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega = \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\,A_e\\,t$ with $A_e$ the element area.\n- Assemble the consistent boundary traction vector by summing over boundary edges $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$, where $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ with the outward unit normal $\\mathbf{n}$ obtained from the counterclockwise edge ordering. Since $\\mathbf{t}$ is constant along a straight edge for a linear displacement field, distribute it to the two edge nodes as $\\dfrac{L_e\\,t}{2}\\mathbf{t}$ at each of the two nodes of that edge, where $L_e$ is the edge length.\n- For the reproduction error, set the nodal displacements equal to the exact linear field evaluated at the nodes, then evaluate the finite element displacement using the CST shape functions at sample points consisting of the centroid and the midpoints of each edge of each triangle, and compute the maximum absolute difference from the exact field over all samples and both displacement components.\n\nFinal output format:\n- Your program should produce a single line of output containing a Python-style list of $6$ floats in the following order: $\\left[\\text{err}_1,\\ \\|\\mathbf{r}_1\\|_2,\\ \\text{err}_2,\\ \\|\\mathbf{r}_2\\|_2,\\ \\text{err}_3,\\ \\|\\mathbf{r}_3\\|_2\\right]$, where $\\text{err}_k$ is the maximum absolute displacement reproduction error in meters for test case $k$, and $\\|\\mathbf{r}_k\\|_2$ is the Euclidean norm of the assembled residual vector in Newtons for test case $k$. Do not print units; ensure the values correspond to SI units as specified.", "solution": "The problem requires the numerical verification of two fundamental properties of the Constant Strain Triangle (CST) finite element under plane stress conditions. These properties are its ability to exactly reproduce a linear displacement field and to pass the patch test, which, for zero body forces, manifests as a zero residual force vector when consistent boundary tractions corresponding to a constant strain state are applied. We will analyze three distinct test cases, each with specified geometry, material properties, and a linear displacement field.\n\nThe analysis is based on the principles of linear elasticity and the finite element method. The displacement field $\\mathbf{u}(x,y)$ is given by $\\mathbf{u} = [u(x,y), v(x,y)]^\\top$. The strain-displacement relationship for infinitesimal strains is given in vector form as $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$, where\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix} $$\nFor a linear, isotropic, and homogeneous material under plane stress, the stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^\\top$ is related to the strain vector by the constitutive matrix $\\mathbf{D}$:\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} \\quad \\text{where} \\quad \\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix} $$\nHere, $E$ represents Young's modulus and $\\nu$ is Poisson's ratio.\n\nA CST element approximates the displacement field within a triangular domain $\\Omega_e$ using linear shape functions $N_i(x,y)$, where $i \\in \\{1,2,3\\}$ corresponds to the three nodes of the element. The interpolated displacement field $(u^h, v^h)$ is:\n$$ u^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i \\quad \\text{and} \\quad v^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i $$\nwhere $(u_i, v_i)$ are the displacements at node $i$. The shape function $N_i$ is a linear function of $x$ and $y$ with the property $N_i(x_j, y_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\nThe derivatives of these linear shape functions are constant over the element. This leads to a constant strain field within the element, which is why it is named the Constant Strain Triangle. The strain is related to the vector of nodal displacements $\\mathbf{d}_e = [u_1, v_1, u_2, v_2, u_3, v_3]^\\top$ via the strain-displacement matrix $\\mathbf{B}$:\n$$ \\boldsymbol{\\varepsilon}_e = \\mathbf{B} \\mathbf{d}_e $$\nFor an element with nodes $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ ordered counter-clockwise, the $\\mathbf{B}$ matrix is given by:\n$$ \\mathbf{B} = \\frac{1}{2A_e} \\begin{bmatrix}\ny_2-y_3 & 0 & y_3-y_1 & 0 & y_1-y_2 & 0 \\\\\n0 & x_3-x_2 & 0 & x_1-x_3 & 0 & x_2-x_1 \\\\\nx_3-x_2 & y_2-y_3 & x_1-x_3 & y_3-y_1 & x_2-x_1 & y_1-y_2\n\\end{bmatrix} $$\nwhere $A_e$ is the area of the element, calculated as $A_e = \\frac{1}{2} \\det \\begin{bmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{bmatrix}$.\n\n**Verification of Displacement Reproduction**\n\nThe first property to verify is that the CST element can exactly reproduce a linear displacement field. The given exact field is:\n$$ u(x,y) = a_0 + a_1 x + a_2 y \\quad \\text{and} \\quad v(x,y) = b_0 + b_1 x + b_2 y $$\nSince the CST shape functions $N_i(x,y)$ are themselves linear, and they form a basis for linear polynomials over the triangle (since $\\sum N_i = 1$), any linear combination of nodal values taken from a linear field must reproduce that same linear field. That is, if we set the nodal displacements $u_i = u(x_i, y_i)$ and $v_i = v(x_i, y_i)$, then the interpolated displacement $u^h(x,y) = \\sum N_i(x,y) u(x_i,y_i)$ must be identical to $u(x,y)$ for all $(x,y)$ in the element. A linear function is uniquely determined by its values at three non-collinear points (the vertices). Since both $u(x,y)$ and $u^h(x,y)$ are linear and agree at the vertices, they must be identical everywhere.\n\nTo verify this numerically, we compute the finite element approximation $u^h, v^h$ at a set of sample points within each element (the centroid and edge midpoints) and compare it to the exact values $u, v$. The maximum absolute difference, $\\max |\\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}}|$ for $\\alpha \\in \\{u,v\\}$, is expected to be zero, within the limits of floating-point precision.\n\n**Verification of the Patch Test (Zero Residual)**\n\nThe second property is the satisfaction of the patch test. For a patch of elements under a constant strain state, with no body forces, the nodal equilibrium equations must be satisfied. This means the assembled internal nodal forces $\\mathbf{f}_{\\mathrm{int}}$ must be exactly balanced by the assembled external nodal forces from boundary tractions, $\\mathbf{f}_{\\mathrm{trac}}$. The residual vector, $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$, must be a zero vector.\n\nThe linear displacement field provided induces a constant strain state over the entire domain:\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} a_1 \\\\ b_2 \\\\ a_2 + b_1 \\end{bmatrix} $$\nThis results in a constant stress field $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$.\n\nThe internal force vector for an element is computed by integrating the virtual work of internal stresses:\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega $$\nSince $\\mathbf{B}$ and $\\boldsymbol{\\sigma}$ are constant within a CST element, this simplifies to:\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\mathbf{B}^\\top \\boldsymbol{\\sigma} A_e t $$\nwhere $t$ is the constant element thickness. These elemental vectors are assembled into a global internal force vector $\\mathbf{f}_{\\mathrm{int}}$.\n\nThe consistent nodal forces due to boundary tractions are computed for each edge on the patch's exterior boundary. For an edge $\\Gamma_e$ with a traction vector $\\mathbf{t}$, the force vector is:\n$$ \\mathbf{f}_{e, \\mathrm{trac}} = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\, \\mathrm{d}\\Gamma $$\nThe traction $\\mathbf{t}$ on an edge with outward unit normal $\\mathbf{n}$ is given by $\\mathbf{t} = \\hat{\\boldsymbol{\\sigma}}\\mathbf{n}$, where $\\hat{\\boldsymbol{\\sigma}}$ is the Cauchy stress tensor. For our constant stress field, $\\mathbf{t}$ is constant along each straight boundary edge. For a linear edge element with nodes $i$ and $j$, this integral distributes the total edge force $L_e t \\mathbf{t}$ equally to the two nodes:\n$$ \\mathbf{f}_{i, \\mathrm{trac}} = \\mathbf{f}_{j, \\mathrm{trac}} = \\frac{L_e t}{2} \\mathbf{t} $$\nwhere $L_e$ is the edge length. These nodal forces are assembled into the global traction force vector $\\mathbf{f}_{\\mathrm{trac}}$.\n\nThe norm of the resulting residual vector, $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$, is then calculated. Theory predicts this norm will be zero (within floating-point tolerance), confirming that the CST formulation passes the patch test.\n\nThe computational procedure for each test case is as follows:\n1.  Parse the case data: node coordinates, element connectivity, boundary edges, material properties, and linear field coefficients.\n2.  **Reproduction Error**:\n    a. For each element, establish sample points (centroid, edge midpoints).\n    b. Calculate exact nodal displacements by evaluating the given linear field at the element's nodes.\n    c. At each sample point, compute the interpolated FE displacement using the nodal values and shape functions.\n    d. Compute the exact displacement at the sample point.\n    e. Calculate the absolute error between the FE and exact displacements for both $u$ and $v$ components.\n    f. The maximum of these errors across all elements and sample points is the result for the test case.\n3.  **Residual Norm**:\n    a. Initialize global force vectors $\\mathbf{f}_{\\mathrm{int}}$ and $\\mathbf{f}_{\\mathrm{trac}}$ to zero.\n    b. Calculate the constant strain vector $\\boldsymbol{\\varepsilon}$ and stress vector $\\boldsymbol{\\sigma}$ from the linear field coefficients and material properties.\n    c. Loop over all elements: calculate the element internal force vector $\\mathbf{f}_{e, \\mathrm{int}}$ and assemble it into $\\mathbf{f}_{\\mathrm{int}}$.\n    d. Loop over all boundary edges: calculate the traction vector $\\mathbf{t}$, the nodal forces, and assemble them into $\\mathbf{f}_{\\mathrm{trac}}$.\n    e. Compute the residual $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$ and its Euclidean norm.\n\nThis procedure, when implemented, will numerically demonstrate the correctness of the CST formulation for constant strain states, a cornerstone of finite element theory.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification tests for CST elements.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": np.array([[0, 0], [1, 0], [1, 1], [0, 1]]),\n            \"elements\": np.array([[0, 1, 2], [0, 2, 3]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 210e9, \"nu\": 0.3, \"t\": 0.01},\n            \"field\": {\"a\": [1, 2, -3], \"b\": [-0.5, 4, 1]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [2, 0], [2, 1], [0, 1], [1, 0.5]]),\n            \"elements\": np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 70e9, \"nu\": 0.25, \"t\": 0.02},\n            \"field\": {\"a\": [-0.1, 0.3, 0.2], \"b\": [0.7, -0.6, 0.4]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [0.001, 0], [1, 0.1]]),\n            \"elements\": np.array([[0, 1, 2]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 0]]),\n            \"material\": {\"E\": 110e9, \"nu\": 0.29, \"t\": 0.005},\n            \"field\": {\"a\": [0.02, 0, 0.001], \"b\": [-0.03, -0.001, 0]},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        err = calculate_reproduction_error(case)\n        residual_norm = calculate_residual_norm(case)\n        results.extend([err, residual_norm])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_cst_b_matrix_and_area(node_coords):\n    \"\"\"\n    Computes the B-matrix and area for a CST element.\n    node_coords is a 3x2 numpy array of [[x1, y1], [x2, y2], [x3, y3]].\n    \"\"\"\n    mat = np.hstack([np.ones((3, 1)), node_coords])\n    area = 0.5 * np.linalg.det(mat)\n    \n    # Ensure area is positive (assumes CCW ordering)\n    if area < 0:\n        # This case is not expected with problem data but good practice\n        node_coords = node_coords[[0, 2, 1], :]\n        area = -area\n\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    \n    b_mat = (1 / (2 * area)) * np.array([\n        [y2 - y3, 0, y3 - y1, 0, y1 - y2, 0],\n        [0, x3 - x2, 0, x1 - x3, 0, x2 - x1],\n        [x3 - x2, y2 - y3, x1 - x3, y3 - y1, x2 - x1, y1 - y2]\n    ])\n    \n    return b_mat, area\n\ndef calculate_reproduction_error(case):\n    \"\"\"\n    Calculates the maximum absolute displacement reproduction error.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    max_error = 0.0\n\n    # Define exact displacement field functions\n    def u_exact(x, y):\n        return a_coeffs[0] + a_coeffs[1] * x + a_coeffs[2] * y\n\n    def v_exact(x, y):\n        return b_coeffs[0] + b_coeffs[1] * x + b_coeffs[2] * y\n\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        \n        # Get exact nodal displacements\n        nodal_u = u_exact(node_coords[:, 0], node_coords[:, 1])\n        nodal_v = v_exact(node_coords[:, 0], node_coords[:, 1])\n\n        # Define sample points: centroid and edge midpoints\n        p1, p2, p3 = node_coords[0], node_coords[1], node_coords[2]\n        sample_points = [\n            (p1 + p2 + p3) / 3.0,  # Centroid\n            (p1 + p2) / 2.0,       # Midpoint of edge 1-2\n            (p2 + p3) / 2.0,       # Midpoint of edge 2-3\n            (p3 + p1) / 2.0,       # Midpoint of edge 3-1\n        ]\n        \n        for sp in sample_points:\n            x_sp, y_sp = sp\n\n            # Calculate shape function values (using area coordinates)\n            mat = np.hstack([np.ones((3, 1)), node_coords])\n            total_area = 0.5 * np.linalg.det(mat)\n            \n            # Area coordinates L1, L2, L3 are the shape function values N1, N2, N3\n            N = np.zeros(3)\n            # N1 = Area(P, P2, P3) / TotalArea\n            N[0] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p2[0], p2[1]], [1, p3[0], p3[1]]])) / total_area\n            # N2 = Area(P, P3, P1) / TotalArea\n            N[1] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p3[0], p3[1]], [1, p1[0], p1[1]]])) / total_area\n            # N3 = 1 - N1 - N2\n            N[2] = 1.0 - N[0] - N[1]\n\n            # FE interpolated displacement\n            u_fe = np.dot(N, nodal_u)\n            v_fe = np.dot(N, nodal_v)\n\n            # Exact displacement\n            u_ex = u_exact(x_sp, y_sp)\n            v_ex = v_exact(x_sp, y_sp)\n\n            # Update max error\n            max_error = max(max_error, abs(u_fe - u_ex), abs(v_fe - v_ex))\n            \n    return max_error\n\ndef calculate_residual_norm(case):\n    \"\"\"\n    Calculates the Euclidean norm of the assembled residual vector.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    boundary_edges = case[\"boundary_edges\"]\n    E, nu, t = case[\"material\"][\"E\"], case[\"material\"][\"nu\"], case[\"material\"][\"t\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    num_nodes = len(nodes)\n    f_int = np.zeros(2 * num_nodes)\n    f_trac = np.zeros(2 * num_nodes)\n\n    # 1. Calculate constant strain and stress from the linear field\n    strain = np.array([\n        a_coeffs[1],                # eps_xx = a1\n        b_coeffs[2],                # eps_yy = b2\n        a_coeffs[2] + b_coeffs[1]   # gamma_xy = a2 + b1\n    ])\n    \n    # Plane stress constitutive matrix D\n    D_mat = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n    \n    stress = D_mat @ strain\n\n    # 2. Assemble internal force vector f_int\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        b_mat, area = get_cst_b_matrix_and_area(node_coords)\n        \n        f_e_int = b_mat.T @ stress * area * t\n        \n        # Assembly map\n        dof_indices = np.array([2*i for i in el_nodes_idx] + [2*i+1 for i in el_nodes_idx]).reshape(2,3).T.flatten()\n        f_int[dof_indices] += f_e_int\n\n    # 3. Assemble traction force vector f_trac\n    # Stress tensor in 2x2 matrix form for traction calculation\n    stress_tensor = np.array([\n        [stress[0], stress[2]],  # [sigma_xx, sigma_xy]\n        [stress[2], stress[1]]   # [sigma_xy, sigma_yy]\n    ])\n    \n    for edge_nodes_idx in boundary_edges:\n        n1_idx, n2_idx = edge_nodes_idx\n        p1, p2 = nodes[n1_idx], nodes[n2_idx]\n        \n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        length = np.sqrt(dx**2 + dy**2)\n        \n        # Outward normal vector (assuming CCW boundary edge ordering)\n        normal = np.array([dy, -dx]) / length\n        \n        # Traction vector t = sigma * n\n        traction_vec = stress_tensor @ normal\n        \n        # Distribute force to nodes\n        node_force = (length * t / 2) * traction_vec\n        \n        # Assembly\n        f_trac[2*n1_idx: 2*n1_idx+2] += node_force\n        f_trac[2*n2_idx: 2*n2_idx+2] += node_force\n\n    # 4. Calculate residual and its norm\n    residual = f_int - f_trac\n    return np.linalg.norm(residual)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3607774"}, {"introduction": "While the CST element is foundational, its inherent simplicity imposes significant limitations. This practice provides a direct, computational comparison between the Constant Strain Triangle (CST) and the higher-order Linear Strain Triangle (LST) to explore the concept of element completeness [@problem_id:3607784]. By attempting to model a quadratic displacement field, you will quantify the strain error produced by the CST and verify the exactness of the LST, gaining critical insight into why higher-order elements are essential for accurately capturing problems with strain gradients.", "problem": "A two-dimensional small-strain continuum is discretized with triangular finite elements. Consider both the Constant Strain Triangle (CST) and the Linear Strain Triangle (LST). The CST employs linear shape functions over a three-node triangle, yielding a constant strain field inside the element. The LST employs quadratic shape functions over a six-node triangle (three vertices and three mid-side nodes), which can exactly interpolate any quadratic displacement field in the element.\n\nStarting from the definition of infinitesimal strain in two dimensions, let the displacement field be quadratic in position:\n$$\nu(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f,\\qquad\nv(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w,\n$$\nwhere $u$ and $v$ are the components of displacement and $a,b,c,d,e,f,p,q,r,s,t,w$ are real coefficients. The small-strain tensor components are defined by\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y},\\quad\n\\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right).\n$$\nFor a given triangle with vertices at $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, denote the barycentric (area) coordinates by $(L_1,L_2,L_3)$, with $L_1+L_2+L_3=1$ and $L_i\\ge 0$. The CST uses the linear shape functions $N_1=L_1$, $N_2=L_2$, $N_3=L_3$. The LST uses the quadratic shape functions $N_1=L_1(2L_1-1)$, $N_2=L_2(2L_2-1)$, $N_3=L_3(2L_3-1)$, $N_4=4L_1L_2$, $N_5=4L_2L_3$, $N_6=4L_3L_1$. The barycentric coordinates are linear functions of $(x,y)$ over the element, and their gradients are constant.\n\nYour task is to implement a program that:\n- Constructs the exact quadratic displacement field with specified coefficients.\n- Computes nodal displacements at the vertices for CST and at the $6$ nodes (vertices and mid-side nodes) for LST, by evaluating the exact displacement field at those nodes.\n- Forms the element displacement approximation for CST and LST and computes the corresponding strain components using the small-strain definition.\n- Evaluates the exact strain components from the quadratic field.\n- Quantifies the residual strain error inside the element by the root-mean-square (RMS) norm over a set of interior sampling points specified via barycentric coordinates.\n\nUse the following test suite of three cases, each defined by triangle vertex coordinates and displacement coefficients:\n- Case $1$ (general scalene triangle with mixed quadratic and linear terms):\n  - Triangle vertices: $(0,0)$, $(2,0)$, $(0.5,1.5)$.\n  - Coefficients for $u$: $a=0.3$, $b=-0.2$, $c=0.4$, $d=1.0$, $e=-0.5$, $f=0.0$.\n  - Coefficients for $v$: $p=-0.1$, $q=0.25$, $r=0.2$, $s=-0.7$, $t=0.3$, $w=0.2$.\n- Case $2$ (equilateral triangle with purely quadratic fields):\n  - Triangle vertices: $(0,0)$, $(1,0)$, $\\left(0.5,\\frac{\\sqrt{3}}{2}\\right)$.\n  - Coefficients for $u$: $a=0.5$, $b=0.1$, $c=0.3$, $d=0.0$, $e=0.0$, $f=0.0$.\n  - Coefficients for $v$: $p=-0.4$, $q=0.2$, $r=0.1$, $s=0.0$, $t=0.0$, $w=0.0$.\n- Case $3$ (skinny triangle to probe geometric conditioning):\n  - Triangle vertices: $(0,0)$, $(10^{-3},0)$, $(0,1.0)$.\n  - Coefficients for $u$: $a=0.8$, $b=-0.6$, $c=0.5$, $d=0.0$, $e=1.0$, $f=-0.3$.\n  - Coefficients for $v$: $p=0.2$, $q=0.3$, $r=-0.4$, $s=0.0$, $t=-0.2$, $w=0.5$.\n\nUse the following $7$ sampling points defined by barycentric coordinates to evaluate the RMS error:\n$$\n(1/3,1/3,1/3),\\ (0.6,0.2,0.2),\\ (0.2,0.6,0.2),\\ (0.2,0.2,0.6),\\ (0.05,0.05,0.90),\\ (0.05,0.90,0.05),\\ (0.90,0.05,0.05).\n$$\nAt each sampling point, compute the approximate strain from CST and LST and the exact strain from the quadratic field, obtain the error vector $(\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\varepsilon_{xy}^{h}-\\varepsilon_{xy}^{\\text{exact}})$ for each method, accumulate the sum of squared error norms, divide by the number of sampling points, and take the square root to obtain the RMS error. Strain is dimensionless; report the RMS residuals as dimensionless floats.\n\nYour program should produce a single line of output containing the $6$ results as a comma-separated list enclosed in square brackets, ordered as $[\\text{Case }1\\ \\text{CST RMS},\\ \\text{Case }1\\ \\text{LST RMS},\\ \\text{Case }2\\ \\text{CST RMS},\\ \\text{Case }2\\ \\text{LST RMS},\\ \\text{Case }3\\ \\text{CST RMS},\\ \\text{Case }3\\ \\text{LST RMS}]$. For example, output in the format $[r_1^{\\text{CST}},r_1^{\\text{LST}},r_2^{\\text{CST}},r_2^{\\text{LST}},r_3^{\\text{CST}},r_3^{\\text{LST}}]$.", "solution": "The solution proceeds by implementing a computational analysis to quantify the strain approximation error for both Constant Strain Triangle (CST) and Linear Strain Triangle (LST) elements when subjected to an exact quadratic displacement field. The error is measured by the Root-Mean-Square (RMS) norm of the strain tensor components, evaluated over a prescribed set of sampling points within the element.\n\nFirst, we define the exact displacement and strain fields. The problem provides a general quadratic displacement field in two dimensions $(x, y)$:\n$$u(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f$$\n$$v(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w$$\nwhere $u$ and $v$ are the displacement components along the $x$ and $y$ axes, respectively. The coefficients $a,b,c,d,e,f,p,q,r,s,t,w$ are given for each test case.\n\nThe exact infinitesimal strain tensor components, $(\\varepsilon_{xx}^{\\text{exact}}, \\varepsilon_{yy}^{\\text{exact}}, \\varepsilon_{xy}^{\\text{exact}})$, are derived by differentiating the displacement field according to the small-strain definitions:\n$$\\varepsilon_{xx}^{\\text{exact}} = \\frac{\\partial u}{\\partial x} = 2ax + by + d$$\n$$\\varepsilon_{yy}^{\\text{exact}} = \\frac{\\partial v}{\\partial y} = qx + 2ry + t$$\n$$\\varepsilon_{xy}^{\\text{exact}} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right) = \\frac{1}{2}\\left( (bx + 2cy + e) + (2px + qy + s) \\right) = \\left(\\frac{b}{2} + p\\right)x + \\left(c + \\frac{q}{2}\\right)y + \\frac{e+s}{2}$$\nNote that for a quadratic displacement field, the resulting strain field is linear in position $(x, y)$.\n\nNext, we formulate the finite element approximations. A key component of this formulation is the use of barycentric coordinates $(L_1, L_2, L_3)$ for a triangle with vertices at $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$. Any point $(x,y)$ inside the triangle can be expressed as a convex combination of the vertices: $x = L_1x_1 + L_2x_2 + L_3x_3$ and $y = L_1y_1 + L_2y_2 + L_3y_3$, where $L_1+L_2+L_3=1$. The approximated displacement field, $u^h(x,y)$, is constructed by interpolating the nodal displacements $u_i$ using shape functions $N_i$: $u^h = \\sum_i N_i u_i$. To compute strains, we require the spatial gradients of the shape functions. Since the shape functions are defined in terms of barycentric coordinates, we use the chain rule: $\\frac{\\partial N_i}{\\partial x} = \\sum_{j=1}^3 \\frac{\\partial N_i}{\\partial L_j} \\frac{\\partial L_j}{\\partial x}$. The gradients of the barycentric coordinates are constant throughout the element and are given by:\n$$ \\frac{\\partial L_1}{\\partial x} = \\frac{y_2 - y_3}{2A}, \\quad \\frac{\\partial L_1}{\\partial y} = \\frac{x_3 - x_2}{2A} $$\n$$ \\frac{\\partial L_2}{\\partial x} = \\frac{y_3 - y_1}{2A}, \\quad \\frac{\\partial L_2}{\\partial y} = \\frac{x_1 - x_3}{2A} $$\n$$ \\frac{\\partial L_3}{\\partial x} = \\frac{y_1 - y_2}{2A}, \\quad \\frac{\\partial L_3}{\\partial y} = \\frac{x_2 - x_1}{2A} $$\nwhere $A$ is the area of the triangle, calculated as $2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)$.\n\nFor the Constant Strain Triangle (CST), we have $3$ nodes at the vertices. The shape functions are linear: $N_1=L_1, N_2=L_2, N_3=L_3$. Consequently, the displacement approximation $u^h$ is linear, and its derivatives, the strains $\\varepsilon^h$, are constant. The nodal displacements $(u_i,v_i)$ for $i=1,2,3$ are obtained by evaluating the exact quadratic displacement field at the vertex coordinates. The constant approximate strain components are then:\n$$ \\varepsilon_{xx}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} u_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial x} u_i $$\n$$ \\varepsilon_{yy}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} v_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial y} v_i $$\n$$ \\varepsilon_{xy}^h = \\frac{1}{2} \\left( \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} u_i + \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} v_i \\right) $$\nSince the exact strain field is linear and the CST approximation is constant, an error is expected.\n\nFor the Linear Strain Triangle (LST), we have $6$ nodes: $3$ at the vertices and $3$ at the midpoints of the sides. The shape functions $N_i$ are quadratic polynomials of the barycentric coordinates. The crucial insight for the LST element is its ability to exactly represent any quadratic polynomial. The space of quadratic polynomials in two variables, $P_2(x,y)$, has $6$ degrees of freedom (corresponding to coefficients of $1, x, y, x^2, xy, y^2$). An LST element has $6$ nodes. A quadratic polynomial is uniquely determined by its values at $6$ non-degenerate points. Since the exact displacement field $(u, v)$ is quadratic, and the LST nodal displacements $(u_i, v_i)$ are evaluated from this exact field, the LST interpolation $u^h = \\sum_{i=1}^6 N_i u_i$ will be identical to the exact field $u(x,y)$ everywhere within the element. This is a fundamental property of finite element completeness. Consequently, the strains derived from the LST approximation, $\\varepsilon^h$, will be identical to the exact strains, $\\varepsilon^{\\text{exact}}$. Therefore, the strain error for the LST element is identically zero, and the resulting RMS error is $0.0$.\n\nThe residual error is quantified by the RMS norm. For each of the $N_{sp}=7$ sampling points, we compute the strain error vector $\\mathbf{e} = (\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\varepsilon_{xy}^{h}-\\varepsilon_{xy}^{\\text{exact}})$. The RMS error is then:\n$$ \\text{RMS error} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\|\\mathbf{e}_k\\|^2_2} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\left( (\\varepsilon_{xx,k}^{h}-\\varepsilon_{xx,k}^{\\text{exact}})^2 + (\\varepsilon_{yy,k}^{h}-\\varepsilon_{yy,k}^{\\text{exact}})^2 + (\\varepsilon_{xy,k}^{h}-\\varepsilon_{xy,k}^{\\text{exact}})^2 \\right)} $$\nFor the CST element, this value is computed numerically. For the LST element, this value is theoretically and numerically $0.0$.\n\nThe algorithm implemented performs the following steps for each test case:\n1.  Define the exact displacement and strain functions from the given coefficients.\n2.  Calculate the element's geometric properties (area and barycentric coordinate gradients).\n3.  For the CST analysis:\n    a. Evaluate the exact displacement at the $3$ vertex nodes.\n    b. Compute the constant strain components for the CST element.\n    c. Initialize a sum of squared errors to $0$.\n    d. For each of the $7$ sampling points (given in barycentric coordinates):\n        i. Convert barycentric coordinates to Cartesian coordinates $(x_{sp}, y_{sp})$.\n        ii. Evaluate the exact strain at $(x_{sp}, y_{sp})$.\n        iii. Calculate the squared norm of the error vector between the constant CST strain and the exact strain at that point.\n        iv. Add this value to the sum of squared errors.\n    e. Compute the final RMS error for CST by taking the square root of the mean of the squared errors.\n4.  For the LST analysis, the RMS error is set to $0.0$ based on the theoretical argument above.\n5.  The results for all cases are collected and presented in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite element analysis problem for CST and LST elements.\n    \"\"\"\n\n    def calculate_rms_errors(vertices, u_coeffs, v_coeffs):\n        \"\"\"\n        Calculates RMS strain errors for CST and LST for a single test case.\n\n        Args:\n            vertices (tuple): A tuple of 3 vertex coordinates ((x1, y1), ...).\n            u_coeffs (tuple): Coefficients a, b, c, d, e, f for the u-displacement.\n            v_coeffs (tuple): Coefficients p, q, r, s, t, w for the v-displacement.\n\n        Returns:\n            tuple: A tuple containing (rms_err_cst, rms_err_lst).\n        \"\"\"\n        # Unpack vertices\n        (x1, y1), (x2, y2), (x3, y3) = vertices\n        \n        # Unpack coefficients\n        a, b, c, d, e, f = u_coeffs\n        p, q, r, s, t, w = v_coeffs\n\n        # --- Exact field and strain definitions ---\n        def u_exact(x, y):\n            return a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n\n        def v_exact(x, y):\n            return p*x**2 + q*x*y + r*y**2 + s*x + t*y + w\n\n        def eps_xx_exact(x, y):\n            return 2*a*x + b*y + d\n\n        def eps_yy_exact(x, y):\n            return q*x + 2*r*y + t\n\n        def eps_xy_exact(x, y):\n            # 0.5 * ( (b*x + 2*c*y + e) + (2*p*x + q*y + s) )\n            return (0.5*b + p)*x + (c + 0.5*q)*y + 0.5*(e + s)\n\n        # --- CST (Constant Strain Triangle) Calculation ---\n        \n        # Triangle Area and Barycentric coordinate gradients\n        two_A = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n        if abs(two_A) < 1e-20:  # Avoid division by zero for collinear points\n            return np.nan, np.nan\n\n        L1x = (y2 - y3) / two_A\n        L1y = (x3 - x2) / two_A\n        L2x = (y3 - y1) / two_A\n        L2y = (x1 - x3) / two_A\n        L3x = (y1 - y2) / two_A\n        L3y = (x2 - x1) / two_A\n\n        # Nodal displacements for CST (3 vertices)\n        u1, v1 = u_exact(x1, y1), v_exact(x1, y1)\n        u2, v2 = u_exact(x2, y2), v_exact(x2, y2)\n        u3, v3 = u_exact(x3, y3), v_exact(x3, y3)\n        \n        # Constant strain components for CST\n        eps_xx_cst = L1x*u1 + L2x*u2 + L3x*u3\n        eps_yy_cst = L1y*v1 + L2y*v2 + L3y*v3\n        eps_xy_cst = 0.5 * ((L1y*u1 + L2y*u2 + L3y*u3) + (L1x*v1 + L2x*v2 + L3x*v3))\n\n        # --- Error calculation over specified sampling points ---\n        sampling_points_bary = [\n            (1/3, 1/3, 1/3),\n            (0.6, 0.2, 0.2), (0.2, 0.6, 0.2), (0.2, 0.2, 0.6),\n            (0.05, 0.05, 0.90), (0.05, 0.90, 0.05), (0.90, 0.05, 0.05),\n        ]\n        \n        sum_sq_err_cst = 0.0\n        for L1s, L2s, L3s in sampling_points_bary:\n            # Cartesian coordinates of the sampling point\n            xs = L1s*x1 + L2s*x2 + L3s*x3\n            ys = L1s*y1 + L2s*y2 + L3s*y3\n\n            # Exact strain at the sampling point\n            exx_e = eps_xx_exact(xs, ys)\n            eyy_e = eps_yy_exact(xs, ys)\n            exy_e = eps_xy_exact(xs, ys)\n\n            # Error for CST\n            err_xx = eps_xx_cst - exx_e\n            err_yy = eps_yy_cst - eyy_e\n            err_xy = eps_xy_cst - exy_e\n            sum_sq_err_cst += err_xx**2 + err_yy**2 + err_xy**2\n\n        num_sampling_points = len(sampling_points_bary)\n        rms_err_cst = np.sqrt(sum_sq_err_cst / num_sampling_points)\n\n        # --- LST (Linear Strain Triangle) Calculation ---\n        # The LST element with quadratic shape functions can exactly represent the\n        # quadratic displacement field. Therefore, the approximated strains are\n        # identical to the exact strains, and the error is zero.\n        rms_err_lst = 0.0\n\n        return rms_err_cst, rms_err_lst\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"vertices\": ((0.0, 0.0), (2.0, 0.0), (0.5, 1.5)),\n            \"u_coeffs\": (0.3, -0.2, 0.4, 1.0, -0.5, 0.0),\n            \"v_coeffs\": (-0.1, 0.25, 0.2, -0.7, 0.3, 0.2),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1.0, 0.0), (0.5, np.sqrt(3)/2)),\n            \"u_coeffs\": (0.5, 0.1, 0.3, 0.0, 0.0, 0.0),\n            \"v_coeffs\": (-0.4, 0.2, 0.1, 0.0, 0.0, 0.0),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1e-3, 0.0), (0.0, 1.0)),\n            \"u_coeffs\": (0.8, -0.6, 0.5, 0.0, 1.0, -0.3),\n            \"v_coeffs\": (0.2, 0.3, -0.4, 0.0, -0.2, 0.5),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_cst, rms_lst = calculate_rms_errors(\n            case[\"vertices\"], \n            case[\"u_coeffs\"], \n            case[\"v_coeffs\"]\n        )\n        results.append(rms_cst)\n        results.append(rms_lst)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3607784"}]}