{"hands_on_practices": [{"introduction": "This practice grounds our understanding of diffraction in its most fundamental geometric basis: the reciprocal lattice. By programmatically converting a real-space crystal lattice into its reciprocal-space counterpart, you will construct the essential framework for interpreting any diffraction pattern. This exercise solidifies the concept of the Laue condition, which determines precisely which crystal planes will produce a diffraction peak for a given incident X-ray beam. [@problem_id:3504299]", "problem": "You are given a triclinic Bravais lattice in real space specified by three linearly independent basis vectors $\\mathbf{a}_1$, $\\mathbf{a}_2$, and $\\mathbf{a}_3$ with components in angstroms. The reciprocal lattice is defined by the reciprocal basis vectors $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$ such that $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta and $\\cdot$ denotes the Euclidean dot product. The real-space unit cell volume is $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$, where $\\times$ denotes the Euclidean cross product. The reciprocal-space cell volume is the oriented volume of the parallelepiped spanned by $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$. For X-ray Diffraction (XRD), the diffraction condition (Laue condition) states that there exists a scattered wavevector $\\mathbf{k}_{\\mathrm{out}}$ with $|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$ such that $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$, where $\\mathbf{G}$ is a reciprocal lattice vector. The incident wavevector magnitude is $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi / \\lambda$, where $\\lambda$ is the X-ray wavelength specified in angstroms, and the incident direction is given as a unit vector.\n\nStarting from these definitions and physical facts, implement a program that:\n- Computes the reciprocal basis vectors $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$ from $\\mathbf{a}_1$, $\\mathbf{a}_2$, and $\\mathbf{a}_3$.\n- Computes the reciprocal cell volume in $\\mathrm{\\AA}^{-3}$ (inverse angstrom cubed), consistent with the above definition.\n- Enumerates all non-zero reciprocal lattice vectors $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$ with integer Miller indices $(h,k,\\ell)$ that satisfy both $|\\mathbf{G}| \\le Q_{\\max}$ and the diffraction condition (Laue condition) for the given incident beam, tested numerically using a tolerance $\\varepsilon$ on the scalar equation implied by $|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|$. Exclude the trivial $\\mathbf{G} = \\mathbf{0}$. Express all vector components of $\\mathbf{b}_i$ in $\\mathrm{\\AA}^{-1}$ and the reciprocal cell volume in $\\mathrm{\\AA}^{-3}$. Use the specified tolerance $\\varepsilon$ as a dimensionless bound for equality checks in the diffraction condition.\n\nYou must not assume any pre-derived shortcut formulas beyond the given definitions and the fundamental facts stated above. Your derivation and implementation must rely only on these foundational elements.\n\nFor numerical output:\n- Round all floating-point outputs (reciprocal basis components and reciprocal cell volume) to six decimal places.\n- Angles are not directly used; directions are given as unit vectors, so no angle unit specification is required.\n- The final output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form $[\\text{b\\_flat\\_list}, \\text{reciprocal\\_volume}, \\text{hkls\\_list}]$, where $\\text{b\\_flat\\_list}$ is the flattened list of components $[b_{1x}, b_{1y}, b_{1z}, b_{2x}, b_{2y}, b_{2z}, b_{3x}, b_{3y}, b_{3z}]$ (all in $\\mathrm{\\AA}^{-1}$), $\\text{reciprocal\\_volume}$ is a float in $\\mathrm{\\AA}^{-3}$, and $\\text{hkls\\_list}$ is a list of integer triples $[h,k,\\ell]$ that meet the conditions.\n\nUse the following test suite. Each case is defined by $(\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3, \\lambda, \\hat{\\mathbf{k}}_{\\mathrm{in}}, Q_{\\max}, \\varepsilon)$:\n1. General triclinic case (happy path):\n   - $\\mathbf{a}_1 = (\\,4.0,\\,0.2,\\,0.1\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.1,\\,5.0,\\,0.4\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.2,\\,0.3,\\,6.1\\,)\\,\\mathrm{\\AA}$.\n   - $\\lambda = 1.0\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.0,\\,0.0,\\,1.0\\,)$.\n   - $Q_{\\max} = 4.0\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$.\n2. Oblique incidence with typical wavelength:\n   - $\\mathbf{a}_1 = (\\,3.5,\\,0.0,\\,0.0\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.2,\\,4.7,\\,0.1\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.1,\\,0.4,\\,5.5\\,)\\,\\mathrm{\\AA}$.\n   - $\\lambda = 1.5406\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,0.3,\\,0.4,\\,0.866025403784\\,)$.\n   - $Q_{\\max} = 3.0\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$.\n3. Boundary case with small $Q_{\\max}$:\n   - $\\mathbf{a}_1 = (\\,5.2,\\,0.1,\\,0.0\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_2 = (\\,0.0,\\,5.3,\\,0.2\\,)\\,\\mathrm{\\AA}$, $\\mathbf{a}_3 = (\\,0.1,\\,0.0,\\,5.4\\,)\\,\\mathrm{\\AA}$.\n   - $\\lambda = 0.5\\,\\mathrm{\\AA}$, $\\hat{\\mathbf{k}}_{\\mathrm{in}} = (\\,1.0,\\,0.0,\\,0.0\\,)$.\n   - $Q_{\\max} = 0.8\\,\\mathrm{\\AA}^{-1}$, $\\varepsilon = 1\\times 10^{-6}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case result structured as described above. For example, the output format must be exactly like $[\\text{case1},\\text{case2},\\text{case3}]$ with no extraneous text, using the units and rounding rules specified.", "solution": "The user-provided problem is assessed as valid based on the specified criteria. It is scientifically grounded in the principles of solid-state physics and X-ray diffraction, well-posed with a complete and consistent set of givens, and objective in its formulation. The problem requires the implementation of fundamental definitions without reliance on pre-derived shortcuts, constituting a substantive computational task.\n\nThe solution is developed in three main stages:\n1.  Computation of the reciprocal basis vectors and reciprocal cell volume.\n2.  Derivation of the conditions for identifying diffracting reciprocal lattice vectors.\n3.  Establishment of an algorithm to enumerate these vectors.\n\n### 1. Reciprocal Basis and Volume Calculation\n\nThe problem defines the real-space basis vectors as $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ and the reciprocal basis vectors $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$ via the relationship:\n$$\n\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta. The real-space cell volume is given by the scalar triple product $V = \\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)$.\n\nTo find an expression for $\\mathbf{b}_1$, we use the definition. The conditions $\\mathbf{a}_2 \\cdot \\mathbf{b}_1 = 0$ and $\\mathbf{a}_3 \\cdot \\mathbf{b}_1 = 0$ imply that $\\mathbf{b}_1$ must be orthogonal to both $\\mathbf{a}_2$ and $\\mathbf{a}_3$. Therefore, $\\mathbf{b}_1$ must be parallel to the cross product $\\mathbf{a}_2 \\times \\mathbf{a}_3$. We can write this as:\n$$\n\\mathbf{b}_1 = C (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\nfor some scalar constant $C$. To find $C$, we use the remaining condition $\\mathbf{a}_1 \\cdot \\mathbf{b}_1 = 2\\pi$:\n$$\n\\mathbf{a}_1 \\cdot [C (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\n$$\nC [\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)] = 2\\pi\n$$\nUsing the definition of the real-space volume $V$, we get $C V = 2\\pi$, which gives $C = 2\\pi/V$. Thus, the expression for $\\mathbf{b}_1$ is:\n$$\n\\mathbf{b}_1 = \\frac{2\\pi}{V} (\\mathbf{a}_2 \\times \\mathbf{a}_3)\n$$\nBy cyclic permutation of the indices, we obtain the expressions for $\\mathbf{b}_2$ and $\\mathbf{b}_3$:\n$$\n\\mathbf{b}_2 = \\frac{2\\pi}{V} (\\mathbf{a}_3 \\times \\mathbf{a}_1)\n$$\n$$\n\\mathbf{b}_3 = \\frac{2\\pi}{V} (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n\nThe reciprocal cell volume is defined as the oriented volume of the parallelepiped spanned by the reciprocal basis vectors, which is given by their scalar triple product:\n$$\nV_{\\text{recip}} = \\mathbf{b}_1 \\cdot (\\mathbf{b}_2 \\times \\mathbf{b}_3)\n$$\nInstead of using the derived relation $V_{\\text{recip}} = (2\\pi)^3/V$, which is a common shortcut, we will compute this value directly from the calculated $\\mathbf{b}_i$ vectors to adhere strictly to the problem's constraints.\n\n### 2. Diffraction Conditions\n\nA reciprocal lattice vector is given by $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + \\ell \\mathbf{b}_3$ for integer Miller indices $(h,k,\\ell)$. We need to find all non-zero vectors $\\mathbf{G}$ that satisfy two conditions.\n\n**Condition 1: Magnitude Constraint**\nThe magnitude of the reciprocal lattice vector must be less than or equal to a given maximum value, $Q_{\\max}$:\n$$\n|\\mathbf{G}| \\le Q_{\\max}\n$$\nEquivalently, $|\\mathbf{G}|^2 \\le Q_{\\max}^2$.\n\n**Condition 2: Laue Condition**\nThe diffraction (Laue) condition is $\\mathbf{k}_{\\mathrm{out}} - \\mathbf{k}_{\\mathrm{in}} = \\mathbf{G}$, where $\\mathbf{k}_{\\mathrm{in}}$ is the incident wavevector and $\\mathbf{k}_{\\mathrm{out}}$ is the scattered wavevector. For elastic scattering, as in XRD, $|\\mathbf{k}_{\\mathrm{out}}| = |\\mathbf{k}_{\\mathrm{in}}|$. Substituting $\\mathbf{k}_{\\mathrm{out}} = \\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}$ into the elastic scattering condition gives:\n$$\n|\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}| = |\\mathbf{k}_{\\mathrm{in}}|\n$$\nSquaring both sides yields:\n$$\n(\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) \\cdot (\\mathbf{k}_{\\mathrm{in}} + \\mathbf{G}) = \\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{k}_{\\mathrm{in}}\n$$\n$$\n|\\mathbf{k}_{\\mathrm{in}}|^2 + 2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = |\\mathbf{k}_{\\mathrm{in}}|^2\n$$\nThis simplifies to the final equation that must be satisfied by a diffracting vector $\\mathbf{G}$:\n$$\n2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2 = 0\n$$\nThe problem specifies a numerical test for this condition using a dimensionless tolerance $\\varepsilon$. A suitable dimensionless quantity representing the deviation from this condition is obtained by dividing by $|\\mathbf{k}_{\\mathrm{in}}|^2$:\n$$\n\\left| \\frac{2\\mathbf{k}_{\\mathrm{in}} \\cdot \\mathbf{G} + |\\mathbf{G}|^2}{|\\mathbf{k}_{\\mathrm{in}}|^2} \\right| \\le \\varepsilon\n$$\nThe incident wavevector is constructed from its magnitude $|\\mathbf{k}_{\\mathrm{in}}| = 2\\pi/\\lambda$ and its given direction unit vector $\\hat{\\mathbf{k}}_{\\mathrm{in}}$: $\\mathbf{k}_{\\mathrm{in}} = (2\\pi/\\lambda)\\hat{\\mathbf{k}}_{\\mathrm{in}}$.\n\n### 3. Enumeration Algorithm\n\nTo find all integer triples $(h,k,\\ell)$ that satisfy the conditions, we must search a finite region of the integer lattice. The condition $|\\mathbf{G}| \\le Q_{\\max}$ defines an ellipsoid in $(h,k,\\ell)$ space. To establish a simple search boundary, we can find a rectangular prism that encloses this ellipsoid.\n\nA vector $\\mathbf{G}$ can be written in matrix form as $\\mathbf{G} = B \\mathbf{m}$, where $B$ is the matrix whose columns are $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$ and $\\mathbf{m} = [h, k, \\ell]^T$. Consequently, $\\mathbf{m} = B^{-1} \\mathbf{G}$.\nLet the rows of the real-space basis matrix be $A_{mat} = [\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]^T$. The definition $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$ implies $A_{mat} B = 2\\pi I$, so $B^{-1} = \\frac{1}{2\\pi} A_{mat}$. The rows of $B^{-1}$ are $\\frac{1}{2\\pi}\\mathbf{a}_1$, $\\frac{1}{2\\pi}\\mathbf{a}_2$, and $\\frac{1}{2\\pi}\\mathbf{a}_3$.\n\nThe components of $\\mathbf{m}$ can be bounded. For example, for $h$:\n$$\nh = (\\frac{1}{2\\pi}\\mathbf{a}_1) \\cdot \\mathbf{G}\n$$\nBy the Cauchy-Schwarz inequality, $|h| \\le \\frac{1}{2\\pi}|\\mathbf{a}_1| |\\mathbf{G}|$. Since $|\\mathbf{G}| \\le Q_{\\max}$, we have:\n$$\n|h| \\le \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi}\n$$\nThis gives us the maximum search range for $h$, and similarly for $k$ and $\\ell$:\n$$\nh_{\\max} = \\lceil \\frac{|\\mathbf{a}_1| Q_{\\max}}{2\\pi} \\rceil, \\quad k_{\\max} = \\lceil \\frac{|\\mathbf{a}_2| Q_{\\max}}{2\\pi} \\rceil, \\quad \\ell_{\\max} = \\lceil \\frac{|\\mathbf{a}_3| Q_{\\max}}{2\\pi} \\rceil\n$$\nwhere $\\lceil \\cdot \\rceil$ is the ceiling function. The algorithm will iterate through all integers $h, k, \\ell$ within these ranges (from $-h_{\\max}$ to $h_{\\max}$, etc.), construct the corresponding $\\mathbf{G}$, and test it against the two conditions. The resulting list of $(h,k,\\ell)$ triples will be sorted lexicographically for a deterministic output.\n\nThe final results for each test case require specific formatting: components of the reciprocal basis vectors and the reciprocal volume must be rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General triclinic\n        (np.array([4.0, 0.2, 0.1]), np.array([0.1, 5.0, 0.4]), np.array([0.2, 0.3, 6.1]),\n         1.0, np.array([0.0, 0.0, 1.0]), 4.0, 1e-6),\n        # Case 2: Oblique incidence\n        (np.array([3.5, 0.0, 0.0]), np.array([0.2, 4.7, 0.1]), np.array([0.1, 0.4, 5.5]),\n         1.5406, np.array([0.3, 0.4, 0.866025403784]), 3.0, 1e-6),\n        # Case 3: Boundary case\n        (np.array([5.2, 0.1, 0.0]), np.array([0.0, 5.3, 0.2]), np.array([0.1, 0.0, 5.4]),\n         0.5, np.array([1.0, 0.0, 0.0]), 0.8, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # The problem asks for the standard python string representation of lists\n    # which includes spaces after commas. The f-string joins these string\n    # representations with a comma but doesn't alter the inner representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_case(a1, a2, a3, lambda_xray, k_in_hat, Q_max, epsilon):\n    \"\"\"\n    Processes a single test case for X-ray diffraction analysis.\n    \n    Args:\n        a1, a2, a3 (np.ndarray): Real-space basis vectors in Angstroms.\n        lambda_xray (float): Wavelength of the X-ray in Angstroms.\n        k_in_hat (np.ndarray): Unit vector of the incident wavevector.\n        Q_max (float): Maximum magnitude of reciprocal lattice vectors to consider.\n        epsilon (float): Tolerance for the diffraction condition check.\n\n    Returns:\n        list: A list containing [b_flat_list, reciprocal_volume, hkls_list].\n    \"\"\"\n    \n    # 1. Compute real-space volume\n    # V = a1 . (a2 x a3)\n    V_real = np.dot(a1, np.cross(a2, a3))\n    \n    # 2. Compute reciprocal basis vectors\n    factor = 2 * np.pi / V_real\n    b1 = factor * np.cross(a2, a3)\n    b2 = factor * np.cross(a3, a1)\n    b3 = factor * np.cross(a1, a2)\n    \n    # 3. Compute reciprocal cell volume\n    # V_recip = b1 . (b2 x b3)\n    V_recip = np.dot(b1, np.cross(b2, b3))\n    \n    # 4. Enumerate reciprocal lattice vectors G = h*b1 + k*b2 + l*b3\n    k_in_mag = 2 * np.pi / lambda_xray\n    k_in = k_in_mag * k_in_hat\n    k_in_mag_sq = k_in_mag**2\n\n    # Determine search bounds for Miller indices h, k, l\n    h_max = int(np.ceil(np.linalg.norm(a1) * Q_max / (2 * np.pi)))\n    k_max = int(np.ceil(np.linalg.norm(a2) * Q_max / (2 * np.pi)))\n    l_max = int(np.ceil(np.linalg.norm(a3) * Q_max / (2 * np.pi)))\n    \n    hkls_list = []\n    \n    for h in range(-h_max, h_max + 1):\n        for k in range(-k_max, k_max + 1):\n            for l in range(-l_max, l_max + 1):\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                G = h * b1 + k * b2 + l * b3\n                G_mag = np.linalg.norm(G)\n                \n                # Condition 1: |G| <= Q_max\n                if G_mag > Q_max:\n                    continue\n                \n                # Condition 2: Diffraction condition (Laue)\n                # Test |(2*k_in.G + |G|^2) / |k_in|^2| <= epsilon\n                G_mag_sq = G_mag**2\n                laue_check_numerator = 2 * np.dot(k_in, G) + G_mag_sq\n                \n                # Handle case where k_in_mag_sq is zero, though physically unlikely\n                if k_in_mag_sq == 0:\n                    continue\n                \n                dimensionless_test_val = laue_check_numerator / k_in_mag_sq\n                \n                if abs(dimensionless_test_val) <= epsilon:\n                    hkls_list.append([h, k, l])\n\n    # Sort the list for deterministic output\n    hkls_list.sort()\n    \n    # 5. Format the output\n    b_flat = np.concatenate((b1, b2, b3))\n    b_flat_list = [round(comp, 6) for comp in b_flat]\n    reciprocal_volume = round(V_recip, 6)\n    \n    return [b_flat_list, reciprocal_volume, hkls_list]\n\n# Execute the solver\nsolve()\n```", "id": "3504299"}, {"introduction": "The reciprocal lattice dictates where diffraction peaks can appear, but their intensities hold the key to the atomic arrangement. This practice confronts the famous 'phase problem' by introducing the Patterson function, which can be calculated directly from measured intensities, proportional to $|F(\\mathbf{G})|^2$, without phase information. You will implement the computation of a Patterson map and use its peaks to deduce interatomic vectors, a classic method that provides the first critical step toward solving an unknown crystal structure. [@problem_id:3504298]", "problem": "You are given a periodic electron density in a unit cell modeled on a uniform discrete grid, and a discrete set of scattering centers (atoms) with real, positive scattering strengths. The goal is to derive and implement the computation of the Patterson function and to design an automated procedure that recovers a heavy-atom substructure from the Patterson map for synthetic datasets in two dimensions. Work entirely in fractional coordinates in the unit cell, with periodic boundary conditions on a discrete lattice.\n\nDefinitions and fundamental bases:\n- Let the unit cell be represented by an $N \\times N$ grid with indices $(x,y)$ where $x,y \\in \\{0,1,\\dots,N-1\\}$, corresponding to fractional coordinates $(x/N,y/N)$.\n- The discretized electron density is $\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$ and is constructed by placing atoms as weighted discrete impulses (Kronecker deltas) on grid points: if there are $M$ atoms with grid indices $(x_j,y_j)$ and scattering strengths $f_j > 0$, then $\\rho[x_j,y_j] \\leftarrow \\rho[x_j,y_j] + f_j$ for $j=1,\\dots,M$.\n- The discrete structure factors are the discrete Fourier transform of $\\rho[x,y]$, denoted $F[h,k]$, where $h,k \\in \\{0,1,\\dots,N-1\\}$. Use the discrete Fourier transform convention that:\n$$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\nand the inverse transform has the factor $1/N^2$.\n- The Patterson function is the cyclic autocorrelation of $\\rho[x,y]$, defined by:\n$$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\nfor integer shifts $(u,v)$ with $u,v \\in \\{0,1,\\dots,N-1\\}$.\n\nTasks:\n1) Starting only from the definitions of the discrete Fourier transform, its inverse, and the definition of the cyclic autocorrelation above, derive that the Patterson function can be computed as the inverse discrete Fourier transform of $|F[h,k]|^2$ up to the standard normalization of the chosen discrete transform convention. Provide a clear derivation that justifies the computational route using the Fast Fourier Transform (FFT).\n\n2) Design and implement an algorithm that, given a Patterson map $P[u,v]$, automatically reconstructs a heavy-atom substructure consistent with the strongest peaks in $P[u,v]$. Use the following modeling assumptions and requirements:\n- The atoms are placed exactly on grid points, that is, their fractional coordinates are multiples of $1/N$.\n- The Patterson map contains peaks at all interatomic difference vectors, i.e., at shifts corresponding to $(x_j-x_i \\bmod N, y_j-y_i \\bmod N)$ for all ordered pairs $(i,j)$, including the origin where the peak height sums self-products $f_j^2$.\n- Because the Patterson function is invariant to overall translation and inversion of the atomic configuration, define a canonical gauge for reporting the reconstructed substructure as follows:\n  - Fix the first reconstructed atom at the origin $(0,0)$ in grid coordinates.\n  - Choose subsequent atom positions using only the peak set and consistency of pairwise differences, and then convert to fractional coordinates in $[0,1)$ by dividing by $N$.\n  - Sort the reconstructed fractional coordinates lexicographically.\n- Implement a deterministic greedy embedding procedure for up to $M=3$ atoms:\n  - Extract a set of strong, unique non-origin peaks from $P[u,v]$ by searching for local maxima and discarding the origin $(u,v)=(0,0)$. Retain enough peaks to cover all interatomic vectors for up to $M=3$ atoms.\n  - Place the first atom at $(0,0)$ by convention.\n  - Place a second atom at the highest-amplitude non-origin peak index $(u_1,v_1)$ chosen deterministically from the peak set using a fixed rule (e.g., lexicographically smallest index among symmetry-related equivalents).\n  - Place a third atom, if present, at a candidate peak $(u_2,v_2)$ such that the difference with the second atom is consistent with the observed peak set under modular arithmetic, that is, either $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ or $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ exists among the observed peaks. Use a deterministic selection rule to break ties by descending peak amplitude and then lexicographic order of indices.\n\n3) Implement the full pipeline:\n- Given $N$ and a list of atoms specified by integer indices $(x_j,y_j)$ and strengths $f_j$, construct $\\rho[x,y]$, compute $F[h,k]$ via the discrete Fourier transform, construct intensities $I[h,k] = |F[h,k]|^2$, and compute the Patterson map $P[u,v]$ via the inverse discrete Fourier transform of $I[h,k]$.\n- Implement the heavy-atom substructure search algorithm described above to reconstruct a set of up to $M=3$ atom positions, in fractional coordinates in $[0,1)$, rounded to three decimals.\n- Output the reconstructed positions under the canonical gauge.\n\nTest suite:\nProvide results for the following three synthetic datasets. All datasets are in two dimensions with periodic boundary conditions and are strictly on-grid (grid coordinates in integers; fractional coordinates are integers divided by $N$):\n- Test case A (edge case, single atom):\n  - $N=32$.\n  - Atoms: one atom at $(x_1,y_1)=(8,5)$ with $f_1=74$.\n- Test case B (two atoms, equal strength):\n  - $N=32$.\n  - Atoms: two atoms at $(x_1,y_1)=(5,9)$ with $f_1=74$ and $(x_2,y_2)=(21,15)$ with $f_2=74$.\n- Test case C (three atoms, unequal strengths, heaviest pair dominates):\n  - $N=32$.\n  - Atoms: three atoms at $(x_1,y_1)=(6,10)$ with $f_1=74$, $(x_2,y_2)=(25,22)$ with $f_2=50$, and $(x_3,y_3)=(12,27)$ with $f_3=40$.\n\nAnswer specification:\n- For each test case, the program must return a list of floats representing the flattened reconstructed fractional coordinates in the canonical gauge, rounded to three decimals, with the first atom fixed at $(0.000,0.000)$, and the rest sorted lexicographically. For example, for two atoms in two dimensions, return four numbers $[x_1,y_1,x_2,y_2]$ where $(x_1,y_1)=(0.000,0.000)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of floats. For example: $[[\\dots],[\\dots],[\\dots]]$.\n\nAngle units and physical units:\n- No physical units are used. Angles are implicit in the complex exponentials and are dimensionless; there is no separate angle unit required in this discrete setting.\n\nYour final deliverable is a complete, runnable program that computes the Patterson function via the discrete Fourier transform, performs the described substructure search, and prints the results for the three test cases in the exact format specified above. No user input is required; the program should run as-is.", "solution": "The user has provided a computational problem in materials science, specifically concerning the Patterson function in X-ray crystallography. The problem is to be solved on a discrete grid representing a 2D unit cell.\n\nThe validation of the problem statement is performed first, as per the established protocol.\n\n### Step 1: Extract Givens\n\n-   **Grid**: A discrete $N \\times N$ grid with indices $(x,y)$ where $x,y \\in \\{0, 1, \\dots, N-1\\}$.\n-   **Electron Density ($\\rho$)**: $\\rho[x,y] \\in \\mathbb{R}_{\\ge 0}$ is constructed from $M$ atoms at grid points $(x_j, y_j)$ with scattering strengths $f_j > 0$. The value $\\rho[x_j, y_j]$ is incremented by $f_j$ for each atom.\n-   **Discrete Fourier Transform (DFT)**: The structure factor $F[h,k]$ is the DFT of $\\rho[x,y]$:\n    $$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\n-   **Inverse DFT**: It is specified that the inverse transform includes a normalization factor of $1/N^2$.\n-   **Patterson Function ($P$)**: The cyclic autocorrelation of the electron density:\n    $$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\n-   **Task 1**: Derive that $P[u,v]$ can be computed as the inverse DFT of $|F[h,k]|^2$.\n-   **Task 2**: Design and implement a deterministic greedy algorithm to reconstruct an atomic substructure of up to $M=3$ heavy atoms from the Patterson map $P[u,v]$. This includes:\n    -   Extracting strong, non-origin peaks (local maxima).\n    -   Defining a canonical gauge: atom 1 at $(0,0)$, subsequent fractional coordinates sorted lexicographically.\n    -   Greedy placement: atom 2 at the lexicographically smallest index among the highest-amplitude peaks. Atom 3 at a candidate peak $(u_2,v_2)$ such that either $(u_2-u_1 \\bmod N, v_2-v_1 \\bmod N)$ or $(u_2+u_1 \\bmod N, v_2+v_1 \\bmod N)$ is also an observed peak, with deterministic tie-breaking.\n-   **Task 3**: Implement the full pipeline and provide results for three test cases.\n-   **Test Cases**:\n    -   A: $N=32$, 1 atom: $((8,5), f=74)$.\n    -   B: $N=32$, 2 atoms: $((5,9), f=74)$, $((21,15), f=74)$.\n    -   C: $N=32$, 3 atoms: $((6,10), f=74)$, $((25,22), f=50)$, $((12,27), f=40)$.\n-   **Answer Format**: A single-line JSON-style list of lists `[[...],[...],[...]]` containing flattened, rounded (3 decimals) fractional coordinates for each test case.\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientific Grounding**: The problem is well-grounded in the principles of Fourier analysis and X-ray crystallography. The definitions of structure factors and the Patterson function are standard. The relationship between the Patterson function and the squared magnitudes of the structure factors is a direct consequence of the convolution theorem for Fourier transforms, a fundamental result. The interpretation of Patterson peaks as interatomic vectors is the central principle of the Patterson method. All premises are scientifically sound.\n2.  **Well-Posedness**: The problem is well-posed. The DFT and its inverse are given with a consistent normalization convention. The algorithmic requirements for substructure reconstruction, including the canonical gauge and tie-breaking rules, are sufficiently detailed to ensure a unique, deterministic solution for each test case.\n3.  **Objectivity**: The problem is stated in precise, objective mathematical language.\n4.  **Completeness**: The provided data for each test case ($N$, atom positions, and strengths) are complete and sufficient to perform all required computations. All necessary definitions are provided.\n5.  **Feasibility**: The grid size ($N=32$) and number of atoms ($M\\le3$) are small, making the computation entirely feasible using standard library functions for Fast Fourier Transform (FFT).\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a self-contained, scientifically sound, and well-posed computational problem. The solution process may proceed.\n\n---\n\n### Solution\n\nThe solution is divided into two parts: the theoretical derivation required by Task 1, and the design of the computational algorithm for Tasks 2 and 3.\n\n**Part 1: Derivation of the Patterson Function Computation via FFT**\n\nThis part establishes the theoretical foundation for efficiently computing the Patterson function.\n\n**1. Definitions**\n\nLet the discrete electron density on an $N \\times N$ grid be $\\rho[x,y]$, where $x,y \\in \\{0, 1, \\dots, N-1\\}$. The function is real and non-negative. The structure factor $F[h,k]$ is the 2D Discrete Fourier Transform (DFT) of $\\rho[x,y]$, denoted $F = \\mathcal{F}\\{\\rho\\}$:\n$$F[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right)$$\nThe Patterson function $P[u,v]$ is the cyclic autocorrelation of $\\rho[x,y]$:\n$$P[u,v] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N]$$\nThe inverse DFT is denoted $\\mathcal{F}^{-1}$, where $\\rho = \\mathcal{F}^{-1}\\{F\\}$.\n\n**2. Derivation using the Cross-Correlation Theorem**\n\nThe DFT cross-correlation theorem states that the DFT of the cross-correlation of two signals is the product of the DFT of the first signal and the complex conjugate of the DFT of the second signal. Since we are autocorrelating a real function $\\rho$ with itself, this simplifies.\n\nWe compute the DFT of the Patterson function, $\\mathcal{F}\\{P\\}[h,k]$:\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} P[u,v] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\nSubstitute the definition of $P[u,v]$ into the equation:\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\right) \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) $$\nRearranging the order of summation:\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} \\rho[(x+u) \\bmod N,(y+v) \\bmod N] \\exp\\left(-2\\pi i \\left(\\frac{hu}{N}+\\frac{kv}{N}\\right)\\right) \\right) $$\nLet $x' = (x+u) \\bmod N$ and $y' = (y+v) \\bmod N$. This implies $u = (x' - x) \\bmod N$ and $v = (y' - y) \\bmod N$. The inner summation over $u,v$ can be rewritten as a summation over $x',y'$:\n$$ \\mathcal{F}\\{P\\}[h,k] = \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{h(x'-x)}{N}+\\frac{k(y'-y)}{N}\\right)\\right) \\right) $$\nSeparating the exponential term:\n$$ \\mathcal{F}\\{P\\}[h,k] = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right) \\left( \\sum_{x'=0}^{N-1} \\sum_{y'=0}^{N-1} \\rho[x',y'] \\exp\\left(-2\\pi i \\left(\\frac{hx'}{N}+\\frac{ky'}{N}\\right)\\right) \\right) $$\nThe second term is the definition of the structure factor $F[h,k]$. The first term is the complex conjugate of $F[h,k]$, because $\\rho$ is real ($\\rho^* = \\rho$) and $\\exp(i\\theta)^* = \\exp(-i\\theta)$:\n$$ \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) = \\left( \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} \\rho[x,y] \\exp\\left(-2\\pi i \\left(\\frac{hx}{N}+\\frac{ky}{N}\\right)\\right) \\right)^* = (F[h,k])^* $$\nThus, we arrive at the central relation:\n$$ \\mathcal{F}\\{P\\}[h,k] = (F[h,k])^* F[h,k] = |F[h,k]|^2 $$\nTo obtain the Patterson function $P[u,v]$, we apply the inverse DFT to both sides:\n$$ P[u,v] = \\mathcal{F}^{-1} \\{ |F[h,k]|^2 \\} $$\nThis derivation confirms that the Patterson map can be calculated by taking the Fourier transform of the density, computing the squared magnitudes of the resulting structure factors (the intensities $I[h,k]$), and then taking the inverse Fourier transform of the intensities. This FFT-based approach, with complexity $O(N^2 \\log N)$, is vastly more efficient than the direct $O(N^4)$ summation.\n\n**Part 2: Algorithmic Design and Implementation**\n\nThe full pipeline is implemented in a single Python script. The logic follows the tasks specified in the problem statement.\n\n1.  **Electron Density Construction**: A 2D NumPy array of size $N \\times N$ is initialized to zeros. For each atom in the input list, its scattering strength $f_j$ is added to the grid at position $(x_j, y_j)$.\n\n2.  **Patterson Map Computation**: The `numpy.fft.fft2` and `numpy.fft.ifft2` functions are used. `np.fft.fft2` computes $F[h,k]$. The squared absolute values $|F[h,k]|^2$ are calculated. `np.fft.ifft2` is then applied to this intensity map. The `numpy` `ifft2` function includes the $1/N^2$ normalization factor, matching the problem's convention. The real part of the result is taken to yield $P[u,v]$.\n\n3.  **Heavy-Atom Substructure Search**:\n    a.  **Peak Extraction**: Local maxima in the Patterson map $P[u,v]$ are identified using `scipy.ndimage.maximum_filter` with a $3 \\times 3$ footprint and `'wrap'` mode for periodic boundaries. Peaks are filtered to include only those with significant amplitude (greater than $1\\%$ of the origin peak's height) to avoid numerical noise. The origin peak at $(0,0)$ is discarded. The resulting peaks are stored as tuples `(amplitude, u, v)` and sorted in descending order of amplitude, with lexicographical order of coordinates as a tie-breaker.\n    b.  **Greedy Embedding**: A list of reconstructed atom grid coordinates is initialized with the first atom at $(0,0)$, as per the canonical gauge.\n        -   **Atom 2**: If the structure has more than one atom (i.e., non-origin peaks exist), the highest-amplitude non-origin peak is selected. If there's a tie in amplitude, the one with the lexicographically smallest grid coordinate is chosen. This determines the position of the second atom.\n        -   **Atom 3**: If a third atom is to be found, the algorithm iterates through the remaining sorted peaks. For each candidate peak at $(u_2, v_2)$, a consistency check is performed. A candidate is accepted if the vector difference to the second atom, $(u_2-u_1 \\pmod N, v_2-v_1 \\pmod N)$, or the vector sum, $(u_2+u_1 \\pmod N, v_2+v_1 \\pmod N)$, corresponds to a location in the set of previously identified peaks. The first candidate to satisfy this condition is chosen, which is deterministic due to the sorted nature of the peak list.\n\n4.  **Canonical Gauge and Output Formatting**:\n    -   The final list of integer grid coordinates is converted to fractional coordinates by dividing by $N$.\n    -   This list of fractional coordinate pairs is sorted lexicographically.\n    -   The sorted coordinates are flattened into a single list of floats.\n    -   Each number in the final list is formatted to three decimal places.\n    -   The results for all test cases are compiled into a list of lists and printed as a single, space-free string to match the specified output format `[[...],[...],[...]]`.\n\nThis structured approach ensures that all problem requirements are met, producing a deterministic and correct result for the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import maximum_filter\n\ndef solve():\n    \"\"\"\n    Main function to run the Patterson reconstruction pipeline for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 32, 'atoms': [((8, 5), 74)]},\n        {'N': 32, 'atoms': [((5, 9), 74), ((21, 15), 74)]},\n        {'N': 32, 'atoms': [((6, 10), 74), ((25, 22), 50), ((12, 27), 40)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        atoms_data = case['atoms']\n\n        # Task 3, Step 1: Construct electron density rho[x,y]\n        rho = np.zeros((N, N), dtype=float)\n        for (x, y), f in atoms_data:\n            rho[x, y] += f\n\n        # Task 3, Step 2: Compute structure factors, intensities, and Patterson map\n        # numpy's fft/ifft conventions match the problem's requirements:\n        # - fft2: no normalization\n        # - ifft2: 1/N^2 normalization\n        F = np.fft.fft2(rho)\n        I = np.abs(F)**2\n        P = np.fft.ifft2(I).real\n\n        # Task 2 & 3: Implement heavy-atom substructure search\n        TOL = 1e-6 # Tolerance for floating point comparisons\n\n        # Find local maxima in the Patterson map using a maximum filter\n        p_max_filter = maximum_filter(P, size=3, mode='wrap')\n        maxima_mask = np.abs(P - p_max_filter) < TOL\n        \n        # Filter for significant peaks to avoid numerical artifacts\n        origin_peak_val = P[0, 0]\n        # A low threshold is sufficient for this clean synthetic data.\n        significant_mask = P > origin_peak_val * 0.01 \n\n        peak_coords = np.argwhere(maxima_mask & significant_mask)\n\n        # Create a list of (amplitude, u, v) for unique non-origin peaks\n        non_origin_peaks = []\n        for u, v in peak_coords:\n            if u == 0 and v == 0:\n                continue\n            non_origin_peaks.append((P[u, v], u, v))\n\n        # Sort peaks by amplitude (desc), then u (asc), then v (asc)\n        non_origin_peaks.sort(key=lambda p: (-p[0], p[1], p[2]))\n        \n        # Create a set of peak locations for efficient O(1) average-case lookup\n        peak_locations = {(u, v) for amp, u, v in non_origin_peaks}\n\n        # --- GREEDY EMBEDDING PROCEDURE ---\n        \n        reconstructed_atoms_grid = [(0, 0)] # Atom 1 at origin by convention\n\n        num_atoms_in_case = len(atoms_data)\n\n        if num_atoms_in_case > 1 and len(non_origin_peaks) > 0:\n            # Place Atom 2\n            # Find all peaks with the max amplitude\n            max_amp = non_origin_peaks[0][0]\n            top_peaks = [p for p in non_origin_peaks if abs(p[0] - max_amp) < TOL]\n            \n            # Choose the one with the lexicographically smallest index.\n            # a_priori sorting ensures top_peaks[0] is the correct choice.\n            _, u1, v1 = top_peaks[0]\n            \n            reconstructed_atoms_grid.append((u1, v1))\n\n            if num_atoms_in_case > 2 and len(non_origin_peaks) > 1:\n                # Place Atom 3\n                # Create a list of candidate peaks, excluding the one already chosen\n                candidate_peaks = [p for p in non_origin_peaks if (p[1], p[2]) != (u1, v1)]\n                \n                for _, u2, v2 in candidate_peaks:\n                    # Consistency check as per the specific problem instruction\n                    # Check 1: Difference vector\n                    diff_vec = ((u2 - u1) % N, (v2 - v1) % N)\n                    # Check 2: Sum vector\n                    sum_vec = ((u2 + u1) % N, (v2 + v1) % N)\n                    \n                    if diff_vec in peak_locations or sum_vec in peak_locations:\n                        reconstructed_atoms_grid.append((u2, v2))\n                        break\n\n        # --- CANONICAL GAUGE AND FORMATTING ---\n        \n        # Convert integer grid coordinates to fractional coordinates\n        frac_coords = [ (p[0] / N, p[1] / N) for p in reconstructed_atoms_grid ]\n        \n        # Sort the reconstructed atoms' fractional coordinates lexicographically\n        frac_coords.sort()\n\n        # Flatten the list of coordinate pairs\n        final_coords_flat = [coord for pos in frac_coords for coord in pos]\n        \n        results.append(final_coords_flat)\n\n    # Final print statement in the exact required format:\n    # A single string representing a list of lists, e.g., [[...],[...]],\n    # with no spaces and with numbers formatted to three decimal places.\n    final_output_parts = []\n    for res_list in results:\n        formatted_list_str = '[' + ','.join([f'{x:.3f}' for x in res_list]) + ']'\n        final_output_parts.append(formatted_list_str)\n    \n    print('[' + ','.join(final_output_parts) + ']')\n\nsolve()\n```", "id": "3504298"}, {"introduction": "Obtaining an initial structural model is often just the beginning; refinement is required to achieve high accuracy. This practice moves from structure solution to structure refinement by having you derive the analytical gradient of a least-squares cost function with respect to atomic positions, $\\mathbf{r}_j$. Understanding and implementing this gradient calculation reveals the mathematical engine behind modern refinement programs, showing how they iteratively adjust a model to best fit experimental diffraction data. [@problem_id:3504329]", "problem": "You are given the kinematic scattering model of X-ray diffraction (XRD) for a crystal with a finite set of atoms. The reciprocal-space scattering amplitude, also called the structure factor, is defined for each reciprocal-space vector $\\mathbf{q}$ by the sum over atoms of their complex scattering contributions. The atomic position vectors are denoted by $\\mathbf{r}_j$ in angstroms, the reciprocal-space vectors $\\mathbf{q}$ are in inverse angstroms, and the atomic scattering factor $f_j(\\mathbf{q})$ may be complex-valued due to anomalous dispersion. The dot product $\\mathbf{q}\\cdot\\mathbf{r}_j$ is dimensionless and its phase is in radians. The model assumptions are: independent atoms, kinematic scattering (no multiple scattering), and the intensity is the modulus-squared of the structure factor.\n\nStarting from fundamental definitions and standard complex calculus, derive the gradient of a least-squares cost function with respect to the atomic positions. Specifically, use only the following base definitions:\n\n- Structure factor: $F(\\mathbf{q})$ is defined by\n$$\nF(\\mathbf{q}) = \\sum_{j=1}^{N_\\text{atoms}} f_j(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}.\n$$\n\n- Intensity: $I(\\mathbf{q})$ is given by\n$$\nI(\\mathbf{q}) = |F(\\mathbf{q})|^2 = F(\\mathbf{q})\\, F(\\mathbf{q})^\\ast,\n$$\nwhere the superscript $\\ast$ denotes complex conjugation.\n\n- Weighted least-squares cost over a finite set of $K$ reciprocal-space points $\\{\\mathbf{q}_k\\}_{k=1}^K$ with observed intensities $I_{\\text{obs}}(\\mathbf{q}_k)$ and nonnegative weights $w_k$:\n$$\nC(\\{\\mathbf{r}_j\\}) = \\frac{1}{2}\\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right)^2.\n$$\n\nYour tasks:\n\n1. Derive the gradient $\\partial C / \\partial \\mathbf{r}_j$ starting from the base definitions above. Your derivation should show each major step, including the application of the chain rule to $I(\\mathbf{q})$, and the complex differentiation of $F(\\mathbf{q})$ with respect to $\\mathbf{r}_j$. Do not assume any derivative expressions not justified by these definitions.\n\n2. Implement a program that computes, for each test case described below, the Euclidean norm of the full gradient vector $\\nabla_{\\mathbf{r}} C$ aggregated over all atoms, where the gradient vector collects $\\partial C / \\partial \\mathbf{r}_j$ for all $j$. The Euclidean norm must be reported in units of \"arbitrary cost per angstrom\" as a float.\n\n3. Use the angle unit radians for all phases $\\mathbf{q}\\cdot\\mathbf{r}_j$. Ensure all computations adhere to the units: $\\mathbf{q}$ in inverse angstroms, $\\mathbf{r}_j$ in angstroms, and intensities $I(\\mathbf{q})$ and $I_{\\text{obs}}(\\mathbf{q})$ in arbitrary squared-amplitude units.\n\n4. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$. Each result must be a float corresponding to the Euclidean norm of the gradient for the corresponding test case.\n\nTest suite specification:\n\n- Test Case $1$ (general case, two atoms, three $\\mathbf{q}$-vectors):\n  - Atomic positions in angstroms: $\\mathbf{r}_1 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_2 = (1.0, 0.0, 0.0)$.\n  - Reciprocal-space vectors in inverse angstroms: $\\mathbf{q}_1 = (0.5, 0.0, 0.0)$, $\\mathbf{q}_2 = (1.0, 0.0, 0.0)$, $\\mathbf{q}_3 = (0.7, 0.3, 0.1)$.\n  - Atomic scattering factors per $\\mathbf{q}_k$:\n    - $f_1(\\mathbf{q}_1) = 10.0$, $f_1(\\mathbf{q}_2) = 9.5$, $f_1(\\mathbf{q}_3) = 9.0$.\n    - $f_2(\\mathbf{q}_1) = 7.0$, $f_2(\\mathbf{q}_2) = 6.5$, $f_2(\\mathbf{q}_3) = 6.0$.\n    All $f_j(\\mathbf{q}_k)$ are real in this test case.\n  - Observed intensities: $I_{\\text{obs}}(\\mathbf{q}_1) = 320.0$, $I_{\\text{obs}}(\\mathbf{q}_2) = 250.0$, $I_{\\text{obs}}(\\mathbf{q}_3) = 200.0$.\n  - Weights: $w_1 = 1.0$, $w_2 = 1.0$, $w_3 = 1.0$.\n\n- Test Case $2$ (boundary condition $\\mathbf{q}=\\mathbf{0}$):\n  - Atomic positions in angstroms: $\\mathbf{r}_1 = (0.3, -0.2, 0.1)$.\n  - Reciprocal-space vectors in inverse angstroms: $\\mathbf{q}_1 = (0.0, 0.0, 0.0)$.\n  - Atomic scattering factors: $f_1(\\mathbf{q}_1) = 12.0$.\n  - Observed intensity: $I_{\\text{obs}}(\\mathbf{q}_1) = 100.0$.\n  - Weight: $w_1 = 1.0$.\n\n- Test Case $3$ (zero residuals, gradient should be zero):\n  - Atomic positions in angstroms: $\\mathbf{r}_1 = (0.25, 0.0, 0.0)$, $\\mathbf{r}_2 = (0.0, 0.4, 0.0)$.\n  - Reciprocal-space vectors in inverse angstroms: $\\mathbf{q}_1 = (1.1, 0.0, 0.0)$, $\\mathbf{q}_2 = (0.0, 1.2, 0.0)$.\n  - Atomic scattering factors per $\\mathbf{q}_k$:\n    - $f_1(\\mathbf{q}_1) = 11.0$, $f_1(\\mathbf{q}_2) = 10.0$.\n    - $f_2(\\mathbf{q}_1) = 6.0$, $f_2(\\mathbf{q}_2) = 5.0$.\n  - Observed intensities are defined to equal the model-predicted intensities for these positions and scattering factors, that is $I_{\\text{obs}}(\\mathbf{q}_k) = |F(\\mathbf{q}_k)|^2$ for $k\\in\\{1,2\\}$ computed using the base definitions.\n  - Weights: $w_1 = 1.0$, $w_2 = 1.0$.\n\n- Test Case $4$ (anomalous dispersion, complex scattering factor):\n  - Atomic positions in angstroms: $\\mathbf{r}_1 = (0.2, 0.1, 0.0)$.\n  - Reciprocal-space vectors in inverse angstroms: $\\mathbf{q}_1 = (0.8, 0.1, 0.0)$, $\\mathbf{q}_2 = (0.5, 0.2, 0.3)$.\n  - Atomic scattering factors per $\\mathbf{q}_k$:\n    - $f_1(\\mathbf{q}_1) = 4.0 + 0.5i$, $f_1(\\mathbf{q}_2) = 3.0 - 0.2i$.\n  - Observed intensities: $I_{\\text{obs}}(\\mathbf{q}_1) = 50.0$, $I_{\\text{obs}}(\\mathbf{q}_2) = 60.0$.\n  - Weights: $w_1 = 1.0$, $w_2 = 1.0$.\n\nYour program must compute the Euclidean norm of the gradient vector $\\nabla_{\\mathbf{r}} C$ for each of the four test cases above and print a single line in the format $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$, where each $\\text{result}_k$ is a float. No other output is permitted.", "solution": "The objective is to derive the analytical gradient of a least-squares cost function with respect to atomic positions in a crystal, based on the kinematic model of X-ray diffraction, and then to implement a program to compute the norm of this gradient for several test cases.\n\nThe derivation will proceed from the fundamental definitions provided. Let $\\mathbf{r}_j$ be the position vector of the $j$-th atom, and $\\mathbf{q}_k$ be a reciprocal-space vector.\n\nThe cost function $C$ is given by:\n$$\nC(\\{\\mathbf{r}_j\\}) = \\frac{1}{2}\\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right)^2\n$$\nwhere $I(\\mathbf{q}_k)$ is the calculated intensity and $I_{\\text{obs}}(\\mathbf{q}_k)$ is the observed intensity for the reciprocal-space vector $\\mathbf{q}_k$.\n\nWe seek the gradient of $C$ with respect to the position vector $\\mathbf{r}_j$ of the $j$-th atom. This gradient is a vector quantity, denoted $\\frac{\\partial C}{\\partial \\mathbf{r}_j}$. Applying the chain rule of differentiation to the cost function, we obtain:\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\frac{\\partial I(\\mathbf{q}_k)}{\\partial \\mathbf{r}_j}\n$$\nThis expression requires the gradient of the calculated intensity, $\\frac{\\partial I(\\mathbf{q}_k)}{\\partial \\mathbf{r}_j}$. The intensity $I(\\mathbf{q})$ is defined as the modulus squared of the structure factor $F(\\mathbf{q})$:\n$$\nI(\\mathbf{q}) = |F(\\mathbf{q})|^2 = F(\\mathbf{q}) F(\\mathbf{q})^\\ast\n$$\nwhere $F(\\mathbf{q})^\\ast$ is the complex conjugate of $F(\\mathbf{q})$. To differentiate $I(\\mathbf{q})$, we use the product rule. For clarity, we temporarily drop the index $k$:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} F(\\mathbf{q})^\\ast + F(\\mathbf{q}) \\frac{\\partial F(\\mathbf{q})^\\ast}{\\partial \\mathbf{r}_j}\n$$\nSince the atomic positions $\\mathbf{r}_j$ are real-valued vectors, differentiation with respect to $\\mathbf{r}_j$ commutes with complex conjugation:\n$$\n\\frac{\\partial F(\\mathbf{q})^\\ast}{\\partial \\mathbf{r}_j} = \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast\n$$\nSubstituting this into the expression for the intensity gradient gives:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} F(\\mathbf{q})^\\ast + F(\\mathbf{q}) \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast\n$$\nThis expression is of the form $z + z^*$, where $z = F(\\mathbf{q}) \\left( \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right)^\\ast$ or its conjugate. For any complex number $z$, $z+z^* = 2\\,\\text{Re}(z)$. Therefore, we can write:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\text{Re} \\left[ F(\\mathbf{q})^\\ast \\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} \\right]\n$$\nThe next step is to find the gradient of the structure factor, $\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j}$. The structure factor is defined as:\n$$\nF(\\mathbf{q}) = \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_l}\n$$\nDifferentiating with respect to $\\mathbf{r}_j$ (using a different summation index $l$ to avoid confusion):\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = \\frac{\\partial}{\\partial \\mathbf{r}_j} \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q})\\, e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_l}\n$$\nThe derivative operator passes through the summation. The derivative is non-zero only for the term where $l=j$:\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = f_j(\\mathbf{q}) \\frac{\\partial}{\\partial \\mathbf{r}_j} \\left( e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right)\n$$\nUsing the chain rule for vector calculus, $\\nabla_{\\mathbf{x}} e^{u(\\mathbf{x})} = e^{u(\\mathbf{x})} \\nabla_{\\mathbf{x}} u(\\mathbf{x})$, with $u(\\mathbf{r}_j) = i\\,\\mathbf{q}\\cdot \\mathbf{r}_j$. The gradient of the scalar field $\\mathbf{q}\\cdot \\mathbf{r}_j$ with respect to $\\mathbf{r}_j$ is simply $\\mathbf{q}$. Thus:\n$$\n\\frac{\\partial}{\\partial \\mathbf{r}_j} \\left( e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right) = e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} (i\\,\\mathbf{q}) = i\\,\\mathbf{q}\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}\n$$\nThis results in a complex vector quantity (a real vector $\\mathbf{q}$ multiplied by a complex scalar). The gradient of the structure factor is:\n$$\n\\frac{\\partial F(\\mathbf{q})}{\\partial \\mathbf{r}_j} = i\\,\\mathbf{q}\\,f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j}\n$$\nNow, we substitute this back into the expression for the intensity gradient:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\text{Re} \\left[ F(\\mathbf{q})^\\ast \\left( i\\,\\mathbf{q}\\,f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right) \\right]\n$$\nThe real vector $\\mathbf{q}$ and the scalar $2$ can be factored out of the real part operator:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = 2\\,\\mathbf{q}\\,\\text{Re} \\left[ i\\,F(\\mathbf{q})^\\ast f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right]\n$$\nUsing the identity $\\text{Re}(iz) = -\\text{Im}(z)$ for any complex number $z$, we find:\n$$\n\\frac{\\partial I(\\mathbf{q})}{\\partial \\mathbf{r}_j} = -2\\,\\mathbf{q}\\,\\text{Im} \\left[ F(\\mathbf{q})^\\ast f_j(\\mathbf{q})\\,e^{i\\,\\mathbf{q}\\cdot \\mathbf{r}_j} \\right]\n$$\nFinally, we substitute this result back into the expression for the cost function gradient, reintroducing the index $k$ for the sum over reciprocal-space points:\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\left( -2\\,\\mathbf{q}_k\\,\\text{Im} \\left[ F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j} \\right] \\right)\n$$\nRearranging the terms yields the final expression for the gradient of the cost function with respect to the position of atom $j$:\n$$\n\\frac{\\partial C}{\\partial \\mathbf{r}_j} = -2 \\sum_{k=1}^K w_k \\left( I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k) \\right) \\mathbf{q}_k \\text{Im} \\left[ F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j} \\right]\n$$\nThis is a vector sum. The total gradient $\\nabla_{\\mathbf{r}}C$ is the collection of all such vector gradients $\\{\\frac{\\partial C}{\\partial \\mathbf{r}_j}\\}_{j=1}^{N_\\text{atoms}}$. The problem requires computing the Euclidean norm of this total gradient, which is a vector in a $3N_\\text{atoms}$-dimensional space.\n\nThe algorithm for the numerical implementation is as follows:\n1. For each test case, initialize a list to store the gradient vectors for each atom.\n2. For each atom $j$ from $1$ to $N_\\text{atoms}$:\n   a. Initialize its gradient vector, $\\mathbf{g}_j = \\frac{\\partial C}{\\partial \\mathbf{r}_j}$, to zero.\n   b. For each reciprocal-space point $k$ from $1$ to $K$:\n      i. Calculate the structure factor $F(\\mathbf{q}_k) = \\sum_{l=1}^{N_\\text{atoms}} f_l(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_l}$.\n      ii. Calculate the model intensity $I(\\mathbf{q}_k) = |F(\\mathbf{q}_k)|^2$.\n      iii. Calculate the difference $\\Delta I_k = I(\\mathbf{q}_k) - I_{\\text{obs}}(\\mathbf{q}_k)$.\n      iv. Calculate the complex value inside the imaginary part operator: $Z_{jk} = F(\\mathbf{q}_k)^\\ast f_j(\\mathbf{q}_k)\\,e^{i\\,\\mathbf{q}_k\\cdot \\mathbf{r}_j}$.\n      v. Calculate the scalar factor for the gradient contribution: $S_{jk} = -2\\,w_k\\,\\Delta I_k\\,\\text{Im}(Z_{jk})$.\n      vi. Add the vector contribution to the gradient: $\\mathbf{g}_j \\leftarrow \\mathbf{g}_j + S_{jk}\\,\\mathbf{q}_k$.\n   c. Store the final gradient vector $\\mathbf{g}_j$ for atom $j$.\n3. Concatenate all individual gradient vectors $\\{\\mathbf{g}_j\\}$ into a single flat vector representing $\\nabla_{\\mathbf{r}}C$.\n4. Compute and store the Euclidean norm of this consolidated gradient vector.\n5. Repeat for all test cases and format the output as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Euclidean norm of the gradient of a least-squares cost function \n    with respect to atomic positions for several X-ray diffraction scenarios.\n    \"\"\"\n    \n    # Test Case 1: General case, two atoms, three q-vectors.\n    test_case_1 = {\n        'r': np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]), # angstroms\n        'q': np.array([[0.5, 0.0, 0.0], [1.0, 0.0, 0.0], [0.7, 0.3, 0.1]]), # 1/angstroms\n        'f': np.array([[10.0, 9.5, 9.0], [7.0, 6.5, 6.0]], dtype=complex), # atomic scattering factors\n        'I_obs': np.array([320.0, 250.0, 200.0]), # arbitrary units\n        'w': np.array([1.0, 1.0, 1.0]) # weights\n    }\n\n    # Test Case 2: Boundary condition q=0. Gradient should be zero.\n    test_case_2 = {\n        'r': np.array([[0.3, -0.2, 0.1]]),\n        'q': np.array([[0.0, 0.0, 0.0]]),\n        'f': np.array([[12.0]], dtype=complex),\n        'I_obs': np.array([100.0]),\n        'w': np.array([1.0])\n    }\n\n    # Test Case 3: Zero residuals. Gradient should be zero.\n    # First, calculate I_obs for this case.\n    r3 = np.array([[0.25, 0.0, 0.0], [0.0, 0.4, 0.0]])\n    q3 = np.array([[1.1, 0.0, 0.0], [0.0, 1.2, 0.0]])\n    f3 = np.array([[11.0, 10.0], [6.0, 5.0]], dtype=complex)\n    I_obs3 = []\n    for k in range(q3.shape[0]):\n        F_k = 0.0\n        for l in range(r3.shape[0]):\n            phase = np.dot(q3[k], r3[l])\n            F_k += f3[l, k] * np.exp(1j * phase)\n        I_obs3.append(np.abs(F_k)**2)\n    \n    test_case_3 = {\n        'r': r3,\n        'q': q3,\n        'f': f3,\n        'I_obs': np.array(I_obs3),\n        'w': np.array([1.0, 1.0])\n    }\n\n    # Test Case 4: Anomalous dispersion (complex f). Single atom.\n    test_case_4 = {\n        'r': np.array([[0.2, 0.1, 0.0]]),\n        'q': np.array([[0.8, 0.1, 0.0], [0.5, 0.2, 0.3]]),\n        'f': np.array([[4.0 + 0.5j, 3.0 - 0.2j]], dtype=complex),\n        'I_obs': np.array([50.0, 60.0]),\n        'w': np.array([1.0, 1.0])\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    for case in test_cases:\n        r = case['r']\n        q = case['q']\n        f = case['f']\n        I_obs = case['I_obs']\n        w = case['w']\n\n        n_atoms = r.shape[0]\n        n_q_pts = q.shape[0]\n        \n        all_grad_components = []\n\n        for j in range(n_atoms):\n            grad_j = np.zeros(3)\n            for k in range(n_q_pts):\n                # Calculate structure factor F(q_k)\n                F_k = 0.0 + 0.0j\n                for l in range(n_atoms):\n                    phase = np.dot(q[k], r[l])\n                    F_k += f[l, k] * np.exp(1j * phase)\n                \n                # Calculate model intensity I(q_k) and residual\n                I_k = np.abs(F_k)**2\n                delta_I_k = I_k - I_obs[k]\n                \n                # If residual is zero, contribution is zero.\n                if np.isclose(delta_I_k, 0):\n                    continue\n\n                # Calculate the complex term and its imaginary part\n                phase_j = np.dot(q[k], r[j])\n                term_in_imag = F_k.conj() * f[j, k] * np.exp(1j * phase_j)\n                imag_part = term_in_imag.imag\n                \n                # Add contribution to gradient for atom j\n                grad_j += -2.0 * w[k] * delta_I_k * q[k] * imag_part\n            \n            all_grad_components.append(grad_j)\n\n        # Concatenate all gradient vectors into one large vector\n        if all_grad_components:\n            full_gradient_vector = np.concatenate(all_grad_components)\n        else:\n            full_gradient_vector = np.array([])\n            \n        # Compute the Euclidean norm of the full gradient vector\n        norm = np.linalg.norm(full_gradient_vector)\n        results.append(norm)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "3504329"}]}