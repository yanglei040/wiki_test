{"hands_on_practices": [{"introduction": "Before we can calculate decay rates, we must first understand the allowed kinematic configurations for a decay process. This practice [@problem_id:3532984] guides you through implementing the fundamental checks that define the physical boundaries of three-body phase space, a region often visualized in a Dalitz plot. By applying conditions derived from four-momentum conservation and the geometry of momentum vectors, you will build a crucial tool for any simulation or analysis involving multi-particle final states.", "problem": "Implement a program that, for a given three-body decay in the parent rest frame, determines whether specified pairwise invariant masses correspond to a physically allowed kinematic configuration by enforcing kinematic constraints derived from first principles. You must check three independent necessary and sufficient conditions for physicality: triangle inequalities for pairwise invariant masses, positivity of individual energies, and non-negative three-momentum Gram determinant. All input quantities are to be interpreted in the parent rest frame.\n\nYou are given a parent particle with mass $M$ decaying into three daughters with masses $m_1$, $m_2$, and $m_3$. Define the pairwise invariant masses squared as $s_{ij} \\equiv m_{ij}^2 = (p_i + p_j)^2$, where $p_i$ are the daughter four-momenta satisfying the on-shell conditions $p_i^2 = m_i^2$, and total four-momentum $P = p_1 + p_2 + p_3$ with $P^2 = M^2$. In the parent rest frame, $P = (M,\\mathbf{0})$. For any two chosen invariants $s_{12}$ and $s_{23}$, the third invariant $s_{13}$ is fixed by conservation laws:\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}.\n$$\nA point $(s_{12}, s_{23})$ is physically allowed if and only if all of the following hold:\n- Triangle inequalities for each pair: for each pair $(i,j)$, \n$$\ns_{ij} \\ge (m_i + m_j)^2.\n$$\n- Positivity of energies and real three-momenta for each daughter $i$ in the parent rest frame, where\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2 M}, \\quad \\text{with } \\{i,j,k\\} = \\{1,2,3\\},\n$$\nmust satisfy $E_i \\ge m_i$, implying $E_i \\ge 0$ and $E_i^2 - m_i^2 \\ge 0$.\n- Non-negative three-momentum Gram determinant $G \\ge 0$, where $G$ is the determinant of the $3 \\times 3$ Euclidean Gram matrix $\\mathcal{G}$ of daughter three-momenta in the Center-of-Mass (COM) frame of the parent. Let $\\mathbf{p}_i$ be the three-momentum of particle $i$ with magnitude $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$. The off-diagonal entries of $\\mathcal{G}$ are determined purely from invariants and energies, without needing explicit angles, via\n$$\n\\mathcal{G}_{ii} = |\\mathbf{p}_i|^2, \\quad \\mathcal{G}_{ij} = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2} \\quad \\text{for } i \\ne j,\n$$\nso that $G = \\det \\mathcal{G} \\ge 0$ ensures that three real vectors with those mutual scalar products and magnitudes exist in three-dimensional space. Numerical checks must be tolerant to floating-point roundoff; treat values within a small tolerance $\\varepsilon$ of a bound as satisfying the bound.\n\nYour task is to write a complete program that applies these checks to a fixed test suite. All masses must be specified in gigaelectronvolts ($\\mathrm{GeV}$). All invariant masses squared must be specified in $\\mathrm{GeV}^2$. The output for each test case is a boolean indicating whether the input corresponds to a physical kinematic configuration under these criteria.\n\nTest suite (each case is $(M, [m_1,m_2,m_3], s_{12}, s_{23})$):\n- Case 1 (happy path, interior point): $(3.0, [0.5, 0.4, 0.3], 1.01, 4.0)$.\n- Case 2 (boundary with a daughter at rest; Gram determinant zero): $(3.0, [0.5, 0.4, 0.3], 7.29, 1.05)$, noting $7.29 = (3.0 - 0.3)^2$ and this choice implies $s_{13} = 1.16$ by conservation.\n- Case 3 (violates triangle inequality): $(3.0, [0.5, 0.4, 0.3], 0.80, 4.0)$.\n- Case 4 (violates energy positivity for particle $1$): $(3.0, [0.5, 0.4, 0.3], 1.01, 6.3)$.\n- Case 5 (violates Gram determinant while triangle bounds hold): $(3.0, [0.5, 0.4, 0.3], 1.01, 6.0)$.\n- Case 6 (massless daughters, boundary point): $(1.0, [0.0, 0.0, 0.0], 0.2, 0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). For the given test suite, the output should be a list of six booleans in the same order as the cases above. Angles are not required and must not be used; all computations must be in terms of the invariants, masses, and the parent mass, using the COM frame definitions given. Use a numerical tolerance $\\varepsilon = 10^{-10}$ when comparing to bounds to account for floating-point error. All values must be treated as having the units specified above, and no other units should be used. The output booleans must be the native boolean values produced by the programming language, not strings.", "solution": "The problem of determining the physical region for a three-body decay is a classic exercise in relativistic kinematics. The solution hinges on the principles of four-momentum conservation and the geometric properties of vectors in three-dimensional Euclidean space. We are given a parent particle of mass $M$ decaying into three daughters of masses $m_1, m_2, m_3$. The entire analysis is conducted in the rest frame of the parent particle, where its four-momentum is $P = (M, \\mathbf{0})$. The daughters' four-momenta are denoted by $p_i = (E_i, \\mathbf{p}_i)$, where $E_i$ and $\\mathbf{p}_i$ are their respective energies and three-momenta.\n\nFour-momentum conservation dictates that $P = p_1 + p_2 + p_3$. A crucial consequence of this is that the kinematic configuration of the decay is not arbitrary. The phase space of possible outcomes is constrained. For a three-body decay, this phase space can be described by two independent variables. A convenient choice is two of the three possible pairwise invariant mass squares, denoted as $s_{ij} = (p_i + p_j)^2$. The problem specifies $s_{12}$ and $s_{23}$ as the independent variables.\n\nThe third invariant mass square, $s_{13}$, is then fixed by the conservation law. This can be derived by summing all three pairwise invariants:\n$$\ns_{12} + s_{13} + s_{23} = (p_1+p_2)^2 + (p_1+p_3)^2 + (p_2+p_3)^2\n$$\nExpanding the squares and using the on-shell condition $p_i^2=m_i^2$, we get:\n$$\ns_{12} + s_{13} + s_{23} = 2(m_1^2+m_2^2+m_3^2) + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\nFrom total momentum conservation, $P^2 = (p_1+p_2+p_3)^2$, we have:\n$$\nM^2 = m_1^2+m_2^2+m_3^2 + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\nCombining these two results yields the relation $s_{12} + s_{13} + s_{23} = M^2 + m_1^2 + m_2^2 + m_3^2$. Solving for $s_{13}$ gives the formula provided in the problem statement:\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}\n$$\nA given point $(s_{12}, s_{23})$ is physically allowed if and only if it satisfies three independent sets of necessary and sufficient conditions. Our algorithm will check each of these conditions in sequence.\n\nFirst, we check the **triangle inequalities**. The quantity $\\sqrt{s_{ij}}$ represents the total energy of the daughter pair $(i, j)$ in their combined center-of-mass frame. For the particles to be produced, this energy must be at least the sum of their rest masses. Therefore, for each pair $(i,j)$, we must have $\\sqrt{s_{ij}} \\ge m_i + m_j$. Squaring both sides gives the condition stated:\n$$\ns_{ij} \\ge (m_i + m_j)^2\n$$\nWe must verify this for all three pairs: $(1,2)$, $(2,3)$, and $(1,3)$.\n\nSecond, we check the **positivity of energies**. The energy $E_i$ of each daughter particle in the parent's rest frame must be at least its rest mass $m_i$, i.e., $E_i \\ge m_i$. This ensures that its kinetic energy is non-negative and its three-momentum magnitude $|\\mathbf{p}_i| = \\sqrt{E_i^2 - m_i^2}$ is a real number. The formula for $E_i$ is derived from the definition of $s_{jk}$:\n$$\ns_{jk} = (p_j+p_k)^2 = (P-p_i)^2 = P^2 - 2P \\cdot p_i + p_i^2\n$$\nIn the parent rest frame, $P=(M, \\mathbf{0})$ and $p_i=(E_i, \\mathbf{p}_i)$, so $P \\cdot p_i = M E_i$. Substituting this and the on-shell conditions $P^2=M^2$ and $p_i^2 = m_i^2$ gives $s_{jk} = M^2 - 2ME_i + m_i^2$. Solving for $E_i$ yields the provided formula, which must be checked for each daughter $i=1,2,3$:\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2M} \\ge m_i\n$$\n\nThird, we check the **non-negativity of the three-momentum Gram determinant**. In the parent rest frame, the three daughter momenta must sum to zero: $\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3 = \\mathbf{0}$. This means the three vectors are linearly dependent and must therefore be coplanar. A fundamental result from linear algebra states that a set of vectors can be embedded in $n$-dimensional Euclidean space if and only if their Gram determinant is non-negative. For our three vectors $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ in 3D space, the Gram matrix $\\mathcal{G}$ has elements $\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j$. Its determinant $G = \\det(\\mathcal{G})$ must be greater than or equal to zero. As the three vectors are coplanar, the determinant must be exactly zero for any physical configuration. A negative determinant implies that no set of real vectors $\\mathbf{p}_i$ in 3D space can satisfy the specified magnitudes and mutual dot products, making the configuration unphysical. The elements of $\\mathcal{G}$ are computed from the invariants and energies, as specified. The diagonal elements are the squared magnitudes $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$. The off-diagonal elements are derived from the four-vector dot product $p_i \\cdot p_j = E_i E_j - \\mathbf{p}_i \\cdot \\mathbf{p}_j$ and the invariant mass definition $s_{ij} = m_i^2 + m_j^2 + 2p_i \\cdot p_j$:\n$$\n\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2}\n$$\nWe construct the $3 \\times 3$ matrix $\\mathcal{G}$ and compute its determinant $G$. The configuration is physical only if $G \\ge 0$. Due to floating-point arithmetic, we check if $G \\ge -\\varepsilon$, where $\\varepsilon$ is a small tolerance.\n\nThe overall algorithm is to take the inputs $(M, [m_1,m_2,m_3], s_{12}, s_{23})$, compute $s_{13}$, and then sequentially apply the three sets of checks. If any check fails, the kinematic point is unphysical and we conclude immediately. If all checks pass, the point is physical.\nA numerical tolerance $\\varepsilon = 10^{-10}$ is used for all inequality comparisons to robustly handle floating-point inaccuracies, especially at the boundaries of the physical region.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_physical(M, masses, s12, s23, tol=1e-10):\n    \"\"\"\n    Checks if a given kinematic configuration for a three-body decay is physical.\n\n    Args:\n        M (float): Mass of the parent particle.\n        masses (list[float]): List of the three daughter masses [m1, m2, m3].\n        s12 (float): Invariant mass squared of the pair (1, 2).\n        s23 (float): Invariant mass squared of the pair (2, 3).\n        tol (float): Numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the configuration is physical, False otherwise.\n    \"\"\"\n    m1, m2, m3 = masses\n    m1_sq, m2_sq, m3_sq = m1**2, m2**2, m3**2\n    M_sq = M**2\n\n    # Step 1: Calculate the dependent invariant mass squared, s13, from conservation.\n    s13 = M_sq + m1_sq + m2_sq + m3_sq - s12 - s23\n\n    # Step 2: Check the triangle inequalities for all three pairs.\n    # The condition is s_ij >= (m_i + m_j)^2.\n    if s12 < (m1 + m2)**2 - tol:\n        return False\n    if s23 < (m2 + m3)**2 - tol:\n        return False\n    if s13 < (m1 + m3)**2 - tol:\n        return False\n\n    # Step 3: Calculate daughter energies and check the energy positivity condition.\n    # The condition is E_i >= m_i, which ensures a real-valued three-momentum.\n    # This also implicitly enforces the upper bounds on s_ij, e.g., s23 <= (M-m1)^2.\n    \n    # Division by zero check for M\n    if M <= 0:\n        return False\n        \n    E1 = (M_sq + m1_sq - s23) / (2 * M)\n    if E1 < m1 - tol:\n        return False\n\n    E2 = (M_sq + m2_sq - s13) / (2 * M)\n    if E2 < m2 - tol:\n        return False\n\n    E3 = (M_sq + m3_sq - s12) / (2 * M)\n    if E3 < m3 - tol:\n        return False\n\n    # Step 4: Check if the three-momentum Gram determinant is non-negative.\n    # Calculate diagonal elements of the Gram matrix: G_ii = |p_i|^2 = E_i^2 - m_i^2\n    # The energy checks above ensure these are non-negative.\n    p1_sq = E1**2 - m1_sq\n    p2_sq = E2**2 - m2_sq\n    p3_sq = E3**2 - m3_sq\n\n    # Calculate off-diagonal elements: G_ij = p_i . p_j\n    p1_dot_p2 = E1 * E2 - (s12 - m1_sq - m2_sq) / 2\n    p1_dot_p3 = E1 * E3 - (s13 - m1_sq - m3_sq) / 2\n    p2_dot_p3 = E2 * E3 - (s23 - m2_sq - m3_sq) / 2\n\n    # Construct the Gram matrix and calculate its determinant.\n    gram_matrix = np.array([\n        [p1_sq,     p1_dot_p2, p1_dot_p3],\n        [p1_dot_p2, p2_sq,     p2_dot_p3],\n        [p1_dot_p3, p2_dot_p3, p3_sq]\n    ])\n    \n    det_G = np.linalg.det(gram_matrix)\n\n    # A negative determinant is unphysical.\n    if det_G < -tol:\n        return False\n\n    # If all checks pass, the configuration is physical.\n    return True\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (M, [m1, m2, m3], s12, s23)\n    test_cases = [\n        (3.0, [0.5, 0.4, 0.3], 1.01, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 7.29, 1.05),\n        (3.0, [0.5, 0.4, 0.3], 0.80, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.3),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.0),\n        (1.0, [0.0, 0.0, 0.0], 0.2, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, masses, s12, s23 = case\n        result = is_physical(M, masses, s12, s23)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to \"True\"/\"False\" string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3532984"}, {"introduction": "With the phase space boundaries established, the next step is to integrate over this space to compute physical rates. This exercise [@problem_id:3532974] focuses on a cornerstone of relativistic kinematics: transforming the Lorentz-invariant phase space measure $d^3p/E$ into coordinates like rapidity $y$ and transverse momentum $p_T$, which are directly relevant to experiments. You will then apply this powerful result to a practical scenario, calculating a detector's acceptance for particles produced from a hypothetical thermal source.", "problem": "You are tasked with deriving and computationally validating a transformation of the Lorentz-invariant phase-space measure and using it to compute acceptance fractions for a realistic detector with kinematic cuts. The context is a thermal source in High-Energy Physics (HEP), modeled in the source rest frame.\n\nStart from the following foundational basis:\n- The on-shell relation for a particle of mass $m$: $E = \\sqrt{m^2 + \\mathbf{p}^2}$, where $\\mathbf{p} = (p_x,p_y,p_z)$ is the three-momentum.\n- The Lorentz-invariant phase-space measure: $d^3p/E$.\n- The definition of rapidity $y$: $y = \\frac{1}{2}\\ln\\left(\\frac{E + p_z}{E - p_z}\\right)$.\n- Cylindrical coordinates for the transverse plane: $p_T = \\sqrt{p_x^2 + p_y^2}$ and azimuthal angle $\\phi$.\n\nYour tasks are:\n1. Derive the Jacobian for the change of variables $(p_x,p_y,p_z) \\mapsto (p_T,\\phi,y)$, and show that the Lorentz-invariant measure expressed in these variables takes the form $d^3p/E$ equal to a simple product of differentials. Do not skip intermediate steps; justify each change of variable explicitly and ensure that the derivation uses only the fundamental laws and core definitions above.\n2. Consider a thermal source in its rest frame with an invariant momentum spectrum $E\\, d^3N/d^3p \\propto \\exp(-E/T)$, where $T$ is the temperature. Using the result from part $1$:\n   - Write the accepted rate $N_{\\text{acc}}$ under realistic detector acceptance cuts $|y| < y_{\\max}$ and $p_T > p_{T,\\min}$ as an integral over $p_T$, $y$, and $\\phi$.\n   - Define the total rate $N_{\\text{tot}}$ as the integral over the full phase space $(p_T \\in [0,\\infty),\\, y \\in (-\\infty,\\infty),\\, \\phi \\in [0,2\\pi))$.\n   - Define the acceptance fraction $F$ as $F = N_{\\text{acc}}/N_{\\text{tot}}$. Use purely mathematical manipulations based on the provided foundations to simplify the integrals as far as possible, making use of symmetry where applicable. Angles must be in radians. All physical quantities $m$, $T$, and $p_T$ must be expressed in gigaelectronvolts (GeV). The acceptance fraction $F$ is dimensionless; provide it as a decimal.\n3. Implement a complete, runnable program that numerically evaluates $F$ for a set of test cases using robust numerical integration. Your implementation must:\n   - Use the result of part $1$ to set up the integrals.\n   - Treat the azimuthal angle $\\phi$ integration analytically if possible. For the rapidity integration, exploit evenness in $y$ to reduce computational cost.\n   - Perform the remaining integrals with sufficient numerical accuracy and stability.\n   - Express all inputs in GeV, and angles in radians.\n   - Produce as final output a single line containing the acceptance fractions for all test cases as a comma-separated list enclosed in square brackets.\n\nTest Suite:\nEvaluate $F$ for the following parameter sets $(m, T, y_{\\max}, p_{T,\\min})$, with $m$ in $\\text{GeV}$, $T$ in $\\text{GeV}$, $y_{\\max}$ dimensionless, $p_{T,\\min}$ in $\\text{GeV}$:\n- Case $1$: $(0.139, 0.170, 1.0, 0.30)$\n- Case $2$: $(0.939, 0.170, 2.0, 0.00)$\n- Case $3$: $(0.000, 0.170, 0.0, 0.00)$\n- Case $4$: $(0.500, 0.200, 10.0, 5.00)$\n- Case $5$: $(3.000, 0.250, 1.0, 0.00)$\n\nDesign for coverage:\n- The set spans a light hadron with moderate cuts, a nucleon-like mass with broad rapidity acceptance and no $p_T$ threshold, a massless limit with zero rapidity window, a stringent high-$p_T$ cut with broad rapidity, and a heavy-mass scenario.\n- The expected outputs are decimal floats representing acceptance fractions.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.12345678,0.23456789,0.34567890,0.45678901,0.56789012]$). No other text should be printed.", "solution": "The problem requires the derivation and application of a transformed Lorentz-invariant phase-space measure to calculate detector acceptance fractions for a thermal source. The validation of the problem statement confirms that it is scientifically grounded, well-posed, and objective. The provided definitions and physical model are standard in high-energy physics. We proceed with a step-by-step solution.\n\n### Part 1: Transformation of the Phase-Space Measure\n\nThe objective is to transform the Lorentz-invariant phase-space measure, $\\frac{d^3p}{E}$, from Cartesian momentum coordinates $(p_x, p_y, p_z)$ to a new set of variables: transverse momentum $p_T$, azimuthal angle $\\phi$, and rapidity $y$.\n\nThe phase-space volume element in Cartesian coordinates is $d^3p = dp_x dp_y dp_z$.\n\n**Step 1: Transformation to Cylindrical Coordinates**\nFirst, we change from Cartesian coordinates $(p_x, p_y, p_z)$ to cylindrical coordinates $(p_T, \\phi, p_z)$. The relations are:\n$$ p_x = p_T \\cos\\phi $$\n$$ p_y = p_T \\sin\\phi $$\n$$ p_z = p_z $$\nwhere $p_T = \\sqrt{p_x^2 + p_y^2}$ is the transverse momentum and $\\phi$ is the azimuthal angle. The Jacobian of this transformation, $J_1$, is:\n$$ J_1 = \\left| \\det \\begin{pmatrix} \\frac{\\partial p_x}{\\partial p_T} & \\frac{\\partial p_x}{\\partial \\phi} & \\frac{\\partial p_x}{\\partial p_z} \\\\ \\frac{\\partial p_y}{\\partial p_T} & \\frac{\\partial p_y}{\\partial \\phi} & \\frac{\\partial p_y}{\\partial p_z} \\\\ \\frac{\\partial p_z}{\\partial p_T} & \\frac{\\partial p_z}{\\partial \\phi} & \\frac{\\partial p_z}{\\partial p_z} \\end{pmatrix} \\right| = \\left| \\det \\begin{pmatrix} \\cos\\phi & -p_T \\sin\\phi & 0 \\\\ \\sin\\phi & p_T \\cos\\phi & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right| $$\n$$ J_1 = | p_T \\cos^2\\phi - (-p_T \\sin^2\\phi) | = | p_T(\\cos^2\\phi + \\sin^2\\phi) | = p_T $$\nSince $p_T \\ge 0$, the absolute value is redundant. The volume element becomes $d^3p = p_T dp_T d\\phi dp_z$. The phase-space measure is now:\n$$ \\frac{d^3p}{E} = \\frac{p_T dp_T d\\phi dp_z}{E} $$\n\n**Step 2: Transformation from Longitudinal Momentum to Rapidity**\nNext, we perform the change of variable from longitudinal momentum $p_z$ to rapidity $y$. The definition of rapidity is:\n$$ y = \\frac{1}{2}\\ln\\left(\\frac{E + p_z}{E - p_z}\\right) $$\nTo find the differential relation between $dp_z$ and $dy$, we first express $p_z$ and $E$ in terms of $y$ and the transverse mass, $m_T = \\sqrt{m^2 + p_T^2}$.\nFrom the definition of $y$:\n$$ e^{2y} = \\frac{E+p_z}{E-p_z} \\implies e^{2y}(E-p_z) = E+p_z \\implies p_z = E \\frac{e^{2y}-1}{e^{2y}+1} = E \\tanh(y) $$\nThe on-shell energy-momentum relation is $E^2 = m^2 + \\mathbf{p}^2 = m^2 + p_T^2 + p_z^2 = m_T^2 + p_z^2$. Substituting $p_z = E \\tanh(y)$:\n$$ E^2 = m_T^2 + E^2 \\tanh^2(y) \\implies E^2(1-\\tanh^2(y)) = m_T^2 $$\nUsing the identity $1-\\tanh^2(y) = \\text{sech}^2(y) = 1/\\cosh^2(y)$, we get:\n$$ \\frac{E^2}{\\cosh^2(y)} = m_T^2 \\implies E = m_T \\cosh(y) $$\nWe take the positive root since energy $E$ is positive. Now substitute this back into the expression for $p_z$:\n$$ p_z = (m_T \\cosh(y)) \\tanh(y) = m_T \\sinh(y) $$\nTo find $dp_z$, we differentiate $p_z$ with respect to $y$ while holding $p_T$ (and thus $m_T$) constant:\n$$ \\frac{\\partial p_z}{\\partial y} = \\frac{\\partial}{\\partial y}(m_T \\sinh y) = m_T \\cosh y $$\nSince we found $E = m_T \\cosh y$, we have the remarkably simple relation:\n$$ dp_z = E \\, dy $$\n\n**Step 3: Final Form of the Measure**\nSubstituting $dp_z = E \\, dy$ into our intermediate expression for the measure:\n$$ \\frac{d^3p}{E} = \\frac{p_T dp_T d\\phi (E \\, dy)}{E} $$\nThe energy $E$ cancels, yielding the final transformed measure:\n$$ \\frac{d^3p}{E} = p_T dp_T d\\phi dy $$\nThis shows that the Lorentz-invariant phase-space measure is a simple product of differentials in the $(p_T, \\phi, y)$ coordinate system.\n\n### Part 2: Formulation of the Acceptance Fraction\n\nThe invariant momentum spectrum is given as $E \\, d^3N/d^3p \\propto \\exp(-E/T)$. This means the number of particles $dN$ in a phase space element $d^3p$ is $dN \\propto \\exp(-E/T) \\frac{d^3p}{E}$. Letting $C$ be the proportionality constant:\n$$ dN = C \\exp(-E/T) \\frac{d^3p}{E} = C \\exp\\left(-\\frac{m_T \\cosh y}{T}\\right) p_T dp_T d\\phi dy $$\nwhere $E = m_T \\cosh y = \\sqrt{m^2 + p_T^2} \\cosh y$.\n\nThe total particle rate, $N_{\\text{tot}}$, is the integral over all phase space: $p_T \\in [0, \\infty)$, $\\phi \\in [0, 2\\pi)$, $y \\in (-\\infty, \\infty)$.\nThe accepted particle rate, $N_{\\text{acc}}$, is the integral over the detector acceptance: $p_T > p_{T,\\min}$, $|y|  y_{\\max}$.\n\nThe acceptance fraction is $F = N_{\\text{acc}} / N_{\\text{tot}}$. The constant $C$ and the integral over $\\phi$ (which gives a factor of $2\\pi$ in both numerator and denominator as the integrand is $\\phi$-independent) cancel out.\n$$ F = \\frac{\\int_{-y_{\\max}}^{y_{\\max}} dy \\int_{p_{T,\\min}}^{\\infty} dp_T \\, p_T \\exp\\left(-\\frac{\\sqrt{m^2+p_T^2}\\cosh y}{T}\\right)}{\\int_{-\\infty}^{\\infty} dy \\int_0^{\\infty} dp_T \\, p_T \\exp\\left(-\\frac{\\sqrt{m^2+p_T^2}\\cosh y}{T}\\right)} $$\nThe integrand is an even function of $y$ because $\\cosh(-y) = \\cosh(y)$. We can simplify the integration limits for $y$:\n$$ F = \\frac{\\int_0^{y_{\\max}} dy \\int_{p_{T,\\min}}^{\\infty} dp_T \\, p_T \\exp\\left(-\\frac{\\sqrt{m^2+p_T^2}\\cosh y}{T}\\right)}{\\int_0^{\\infty} dy \\int_0^{\\infty} dp_T \\, p_T \\exp\\left(-\\frac{\\sqrt{m^2+p_T^2}\\cosh y}{T}\\right)} $$\nLet's evaluate the inner integral over $p_T$. We use the substitution $u = \\sqrt{m^2+p_T^2}$, which implies $u^2 = m^2+p_T^2$ and $u\\,du = p_T\\,dp_T$. The integration $\\int_{p_{T, \\text{start}}}^\\infty$ becomes $\\int_{u_{\\text{start}}}^\\infty$ where $u_{\\text{start}} = \\sqrt{m^2 + p_{T, \\text{start}}^2}$.\nThe inner integral is of the form $\\int_{u_{\\text{start}}}^\\infty u \\exp(-au) du$, with $a = (\\cosh y)/T$. Using integration by parts, this evaluates to:\n$$ \\left[ -e^{-au}\\left(\\frac{u}{a} + \\frac{1}{a^2}\\right) \\right]_{u_{\\text{start}}}^{\\infty} = e^{-au_{\\text{start}}}\\left(\\frac{u_{\\text{start}}}{a} + \\frac{1}{a^2}\\right) = e^{-\\frac{u_{\\text{start}}\\cosh y}{T}}\\left(\\frac{u_{\\text{start}} T}{\\cosh y} + \\frac{T^2}{\\cosh^2 y}\\right) $$\nThe numerator integral, $I_{\\text{num}}$, becomes a single integral over $y$ which requires numerical evaluation:\n$$ I_{\\text{num}} = \\int_0^{y_{\\max}} e^{-\\frac{u_{\\min}\\cosh y}{T}}\\left(\\frac{u_{\\min} T}{\\cosh y} + \\frac{T^2}{\\cosh^2 y}\\right) dy \\quad \\text{with } u_{\\min} = \\sqrt{m^2 + p_{T,\\min}^2} $$\nThe denominator integral, $I_{\\text{den}}$, has $p_{T,\\min}=0$, so $u_{\\text{start}} = \\sqrt{m^2+0^2} = m$. Its integral over $y$ extends to infinity. This integral has a known analytical solution. First, swap the order of integration in the double integral for $I_{\\text{den}}$:\n$$ I_{\\text{den}} = \\int_0^\\infty dp_T \\, p_T \\int_0^\\infty dy \\, \\exp\\left(-\\frac{\\sqrt{m^2+p_T^2}\\cosh y}{T}\\right) $$\nThe inner integral is $\\int_0^\\infty e^{-z \\cosh y} dy = K_0(z)$, where $K_0$ is the modified Bessel function of the second kind of order $0$, and $z = \\sqrt{m^2+p_T^2}/T$.\n$$ I_{\\text{den}} = \\int_0^\\infty p_T K_0\\left(\\frac{\\sqrt{m^2+p_T^2}}{T}\\right) dp_T $$\nWith the substitution $x = \\sqrt{m^2+p_T^2}/T$, so $x^2 T^2 = m^2+p_T^2$ and $2xT^2 dx = 2p_T dp_T$:\n$$ I_{\\text{den}} = \\int_{m/T}^\\infty (xT^2) K_0(x) dx = T^2 \\int_{m/T}^\\infty x K_0(x) dx $$\nUsing the identity $\\frac{d}{dx}(x K_1(x)) = -x K_0(x)$, we have $\\int x K_0(x) dx = -x K_1(x)$.\n$$ I_{\\text{den}} = T^2 [-x K_1(x)]_{m/T}^\\infty = T^2 \\left(0 - \\left(-\\frac{m}{T} K_1\\left(\\frac{m}{T}\\right)\\right)\\right) = m T K_1\\left(\\frac{m}{T}\\right) $$\nFor the special case $m=0$, the denominator can be calculated directly: $I_{\\text{den}} = \\int_0^\\infty dy \\int_0^\\infty dp_T p_T e^{-p_T \\cosh y / T}$. The inner integral is $T^2/\\cosh^2 y$, and $\\int_0^\\infty (T^2/\\cosh^2 y) dy = T^2[\\tanh y]_0^\\infty = T^2$. This is consistent with the limit $m \\to 0$ of the Bessel function expression, as $zK_1(z) \\to 1$ as $z \\to 0$.\n\n### Part 3: Numerical Implementation Strategy\n\nThe acceptance fraction $F = I_{\\text{num}}/I_{\\text{den}}$ is computed as follows:\n1.  The denominator $I_{\\text{den}}$ is calculated analytically:\n    - If $m > 0$, $I_{\\text{den}} = m T K_1(m/T)$. We use `scipy.special.k1`.\n    - If $m = 0$, $I_{\\text{den}} = T^2$.\n2.  The numerator $I_{\\text{num}}$ is calculated by numerically integrating the single-variable function derived above from $y=0$ to $y=y_{\\max}$. This is done using `scipy.integrate.quad`. The integrand is:\n    $$ f(y) = e^{-\\frac{u_{\\min}\\cosh y}{T}}\\left(\\frac{u_{\\min} T}{\\cosh y} + \\frac{T^2}{\\cosh^2 y}\\right), \\quad \\text{where } u_{\\min} = \\sqrt{m^2 + p_{T,\\min}^2} $$\n3.  Edge cases are handled: if $y_{\\max}=0$, the integral $I_{\\text{num}}$ is $0$, so $F=0$.\nThe computation is performed for each test case, and the results are formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import k1\n\ndef solve():\n    \"\"\"\n    Computes the acceptance fraction F for a set of physical parameters.\n\n    The acceptance fraction F is the ratio of the accepted particle rate to the\n    total particle rate from a thermal source, under specified kinematic cuts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, T, y_max, pT_min)\n    # m: mass (GeV), T: temperature (GeV), y_max: max rapidity (dimensionless),\n    # pT_min: min transverse momentum (GeV)\n    test_cases = [\n        (0.139, 0.170, 1.0, 0.30),\n        (0.939, 0.170, 2.0, 0.00),\n        (0.000, 0.170, 0.0, 0.00),\n        (0.500, 0.200, 10.0, 5.00),\n        (3.000, 0.250, 1.0, 0.00)\n    ]\n\n    results = []\n    for m, T, y_max, pT_min in test_cases:\n        # Handle the trivial case where the rapidity acceptance window is zero.\n        if y_max == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate the denominator (total rate integral I_den).\n        # This has an analytical solution.\n        if m == 0.0:\n            # For a massless particle, the integral evaluates to T^2.\n            I_den = T**2\n        else:\n            # For a massive particle, the integral is expressed using the\n            # modified Bessel function of the second kind, K_1.\n            # I_den = m * T * K1(m/T)\n            # scipy.special.k1 computes K_1.\n            I_den = m * T * k1(m / T)\n        \n        # Guard against a non-physical case of zero denominator, though\n        # with T  0, this will not happen.\n        if I_den == 0:\n            # This case shouldn't be reached with valid physical inputs.\n            results.append(float('nan'))\n            continue\n\n        # Define the integrand for the numerator (accepted rate integral I_num).\n        # The integral is over rapidity y from 0 to y_max.\n        u_min = np.sqrt(m**2 + pT_min**2)\n        \n        def numerator_integrand(y):\n            \"\"\"\n            The integrand for the numerator integral I_num, as a function of y.\n            This function resulted from analytically integrating over pT first.\n            \"\"\"\n            cosh_y = np.cosh(y)\n            \n            # The exponential term dominates and ensures rapid convergence.\n            exp_term = np.exp(-(u_min * cosh_y) / T)\n            \n            # The term in parentheses.\n            bracket_term = (u_min * T) / cosh_y + T**2 / cosh_y**2\n            \n            return exp_term * bracket_term\n\n        # Numerically calculate the numerator integral I_num using quad.\n        # quad returns the integral result and an error estimate.\n        I_num, _ = quad(numerator_integrand, 0, y_max, epsabs=1e-12, epsrel=1e-12)\n        \n        # The acceptance fraction F is the ratio of the two integrals.\n        F = I_num / I_den\n        results.append(F)\n\n    # Final print statement in the exact required format.\n    # Results are formatted to 8 decimal places as floats.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3532974"}, {"introduction": "Integrating over phase space often involves functions with sharp peaks, such as those from resonant particles described by a Breit-Wigner propagator, which makes standard Monte Carlo methods inefficient. This hands-on problem [@problem_id:3532946] introduces importance sampling, a powerful variance-reduction technique that is essential for modern computational physics. You will derive and implement a sampler for a resonant distribution from first principles, a skill directly applicable to building efficient event generators.", "problem": "You are to design and implement an importance sampling scheme for the intermediate invariant mass-squared variable $x \\equiv m_{12}^2$ whose distribution is shaped by a resonant propagator. The goal is to integrate functions of the form\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2},\n$$\nwhere $x \\equiv m_{12}^2$, $M$ is a resonance mass parameter, $\\Gamma$ is a width parameter, and $R(x)$ is a bounded, nonnegative function that may vary across $[s_{\\min}, s_{\\max}]$. All quantities are to be treated as dimensionless.\n\nBase your derivation and algorithm on the following foundational principles only:\n- Monte Carlo integration and importance sampling: for a target integral $I = \\int \\mathrm{d}x \\, H(x)$ and a normalized proposal density $g(x)$ with support covering the domain of integration, the unbiased estimator is $\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{H(x_i)}{g(x_i)}$ with $x_i \\sim g$ independently and identically distributed.\n- The Cauchy distribution: a standard Cauchy probability density function with location $a$ and scale $b$ has density $f(x; a, b) = \\frac{1}{\\pi}\\frac{b}{(x-a)^2 + b^2}$ and cumulative distribution function $F(x; a, b) = \\frac{1}{\\pi}\\arctan\\!\\left(\\frac{x-a}{b}\\right) + \\frac{1}{2}$.\n\nTasks you must complete:\n1. Construct a normalized proposal density $g(x)$ proportional to a Cauchy (Breit-Wigner) function on the finite interval $[s_{\\min}, s_{\\max}]$, with location $a = M^2$ and scale $b = M\\Gamma$. The construction must use truncation of the Cauchy distribution to $[s_{\\min}, s_{\\max}]$. Your implementation must use an inverse-transform sampling scheme to generate samples $x$ from this truncated proposal.\n2. Derive, from first principles, the corresponding event weight $w(x)$ such that the Monte Carlo estimator for $I$ remains unbiased under sampling from $g(x)$. Your derivation must start from the base principles stated above and not from any specialized shortcut formula.\n3. Implement a program that:\n   - Generates $N$ independent samples from the proposal $g(x)$ for each test case using inverse-transform sampling.\n   - Computes the Monte Carlo estimate of $I$ for each test case using the derived event weights.\n   - Computes a high-accuracy reference value of $I$ using numerical quadrature over $[s_{\\min}, s_{\\max}]$.\n   - Uses a fixed random seed so the results are deterministic and repeatable.\n\nAngle unit convention: if any inverse trigonometric function appears in your derivation or implementation, it must be interpreted in radians.\n\nTest suite:\n- Case $1$ (happy path, moderate width, centered in range):\n  - $M = 1.0$, $\\Gamma = 0.05$ so $a = M^2 = 1.0$, $b = M\\Gamma = 0.05$.\n  - $s_{\\min} = 0.5$, $s_{\\max} = 1.5$.\n  - $R(x) = 1$.\n  - $N = 200000$ samples.\n- Case $2$ (varying numerator):\n  - $M = \\sqrt{2.0}$, $\\Gamma = 0.1414213562373095$ so $a = M^2 = 2.0$, $b = M\\Gamma = 0.2$.\n  - $s_{\\min} = 1.0$, $s_{\\max} = 3.0$.\n  - $R(x) = x$.\n  - $N = 200000$ samples.\n- Case $3$ (resonance center outside the integration range):\n  - $M = \\sqrt{1.5}$, $\\Gamma = 0.08164965809277261$ so $a = M^2 = 1.5$, $b = M\\Gamma = 0.1224744871391589$; for this test use $b = 0.1$ exactly.\n  - $s_{\\min} = 1.7$, $s_{\\max} = 2.0$.\n  - $R(x) = 1 + x^2$.\n  - $N = 200000$ samples.\n- Case $4$ (narrow width edge case on a wide interval):\n  - $M = 3.0$, $\\Gamma = 0.005$ so $a = M^2 = 9.0$, $b = M\\Gamma = 0.015$.\n  - $s_{\\min} = 0.0$, $s_{\\max} = 20.0$.\n  - $R(x) = \\exp(-0.1 x)$.\n  - $N = 200000$ samples.\n\nImplementation details:\n- Use a single fixed random seed of $12345$ for all pseudorandom number generation.\n- For the inverse-transform sampler for the truncated Cauchy on $[s_{\\min}, s_{\\max}]$, use the standard Cauchy cumulative distribution function $F(x; a, b)$ and its inverse. Ensure numerical robustness by avoiding the exact endpoints where the tangent diverges.\n- The high-accuracy reference integral must be computed numerically over $[s_{\\min}, s_{\\max}]$.\n\nRequired outputs:\n- For each test case, compute two floats:\n  - The Monte Carlo estimate of $I$ using your importance sampling weights.\n  - The absolute error between the Monte Carlo estimate and the high-accuracy numerical quadrature reference.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The order must be\n  $[\\hat{I}_1, \\Delta_1, \\hat{I}_2, \\Delta_2, \\hat{I}_3, \\Delta_3, \\hat{I}_4, \\Delta_4]$,\n  where $\\hat{I}_k$ is the Monte Carlo estimate for case $k$ and $\\Delta_k$ is the absolute error for case $k$.\n- All outputs are dimensionless real numbers. No units should be included. Angles, where applicable internally, are in radians.", "solution": "The problem requires the design and implementation of an importance sampling scheme to compute integrals of the form\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2}\n$$\nwhere the integrand is dominated by a resonant (Breit-Wigner) propagator. Let the location parameter be $a = M^2$ and the scale parameter be $b = M\\Gamma$. The integral can be written as $I = \\int_{s_{\\min}}^{s_{\\max}} H(x) \\, \\mathrm{d}x$, with the integrand $H(x) = \\frac{R(x)}{(x-a)^2 + b^2}$.\n\nThe core principle of importance sampling is to draw samples $x_i$ from a proposal probability density function (PDF) $g(x)$ that is similar in shape to the integrand $H(x)$, and then compute the integral estimate as the average of weighted samples:\n$$\n\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} w(x_i) \\quad \\text{where} \\quad w(x_i) = \\frac{H(x_i)}{g(x_i)}\n$$\n\n**1. Derivation of the Proposal Density $g(x)$**\n\nA suitable proposal density $g(x)$ should be proportional to the part of the integrand $H(x)$ that causes large variations, which is the Breit-Wigner term. We define an un-normalized proposal function $p(x)$ for $x \\in [s_{\\min}, s_{\\max}]$:\n$$\np(x) = \\frac{1}{(x-a)^2 + b^2}\n$$\nTo obtain a normalized PDF $g(x)$, we must divide $p(x)$ by its integral over the domain $[s_{\\min}, s_{\\max}]$. Let this normalization constant be $\\mathcal{N}_p$.\n$$\n\\mathcal{N}_p = \\int_{s_{\\min}}^{s_{\\max}} p(x) \\, \\mathrm{d}x = \\int_{s_{\\min}}^{s_{\\max}} \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x\n$$\nThe integral is a standard form:\n$$\n\\int \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x = \\frac{1}{b} \\arctan\\left(\\frac{x-a}{b}\\right) + C\n$$\nEvaluating this at the limits of integration gives the normalization constant:\n$$\n\\mathcal{N}_p = \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\nThe normalized proposal PDF $g(x)$ is therefore defined as:\n$$\ng(x) = \\frac{p(x)}{\\mathcal{N}_p} = \\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2} \\quad \\text{for } x \\in [s_{\\min}, s_{\\max}]\n$$\nand $g(x)=0$ otherwise.\n\n**2. Derivation of the Inverse Transform Sampler**\n\nTo generate random variates from $g(x)$, we use the inverse transform sampling method. This requires finding the inverse of the cumulative distribution function (CDF) of $g(x)$, which we denote as $G(x)$. For $x \\in [s_{\\min}, s_{\\max}]$, the CDF is:\n$$\nG(x) = \\int_{s_{\\min}}^x g(t) \\, \\mathrm{d}t = \\frac{1}{\\mathcal{N}_p} \\int_{s_{\\min}}^x \\frac{1}{(t-a)^2 + b^2} \\, \\mathrm{d}t\n$$\nUsing the antiderivative from the previous step:\n$$\nG(x) = \\frac{1}{\\mathcal{N}_p b} \\left[ \\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\nSubstituting the expression for $\\mathcal{N}_p$:\n$$\nG(x) = \\frac{\\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}{\\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}\n$$\nTo find the inverse function $x=G^{-1}(u)$, we set $G(x) = u$, where $u$ is a random variable sampled from a uniform distribution $\\mathcal{U}(0, 1)$. We then solve for $x$. Let $\\theta_y = \\arctan\\left(\\frac{y-a}{b}\\right)$. The equation becomes:\n$$\nu = \\frac{\\theta_x - \\theta_{s_{\\min}}}{\\theta_{s_{\\max}} - \\theta_{s_{\\min}}}\n$$\nSolving for $\\theta_x$:\n$$\n\\theta_x = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\nSubstituting back $\\theta_x = \\arctan\\left(\\frac{x-a}{b}\\right)$:\n$$\n\\arctan\\left(\\frac{x-a}{b}\\right) = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\nFinally, solving for $x$ yields the sampling formula:\n$$\nx(u) = a + b \\tan\\left( \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}}) \\right)\n$$\nThis formula allows us to generate a sample $x$ distributed according to $g(x)$ from a uniform random number $u$.\n\n**3. Derivation of the Event Weight $w(x)$**\n\nThe event weight $w(x)$ is defined as the ratio of the original integrand $H(x)$ to the proposal PDF $g(x)$.\n$$\nw(x) = \\frac{H(x)}{g(x)} = \\frac{\\frac{R(x)}{(x-a)^2 + b^2}}{\\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2}}\n$$\nThe denominator term $(x-a)^2 + b^2$ cancels, which is the primary benefit of this choice of importance sampling. This cancellation removes the dominant source of variance, leaving a much smoother function to integrate. The weight simplifies to:\n$$\nw(x) = R(x) \\cdot \\mathcal{N}_p\n$$\nSubstituting the expression for $\\mathcal{N}_p$:\n$$\nw(x) = R(x) \\cdot \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\fracs_{\\min}-a}{b}\\right) \\right]\n$$\nThe Monte Carlo estimator for the integral $I$ is the average of these weights over $N$ samples:\n$$\n\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N w(x_i)\n$$\nSince the part of the weight involving the arctan functions and $b$ is a constant, let's call it $W_{const} = \\mathcal{N}_p$, the estimator can be written efficiently as:\n$$\n\\hat{I}_N = W_{const} \\cdot \\left( \\frac{1}{N} \\sum_{i=1}^N R(x_i) \\right) = W_{const} \\cdot \\langle R(x) \\rangle\n$$\nThis expression is implemented to find the Monte Carlo estimate. The reference value for the integral is computed using high-precision numerical quadrature, and the absolute error is the absolute difference between the Monte Carlo estimate and the reference value.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the importance sampling problem for the given test cases.\n    \"\"\"\n\n    # Fixed random seed for reproducibility\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test cases defined in the problem statement.\n    # Structure: (M, Gamma, s_min, s_max, R_func, N, (optional_a, optional_b))\n    test_cases = [\n        (1.0, 0.05, 0.5, 1.5, lambda x: np.ones_like(x), 200000, None),\n        (np.sqrt(2.0), 0.1414213562373095, 1.0, 3.0, lambda x: x, 200000, None),\n        # For Case 3, a and b are specified explicitly in the problem.\n        # M and Gamma are for context. a=M^2=1.5, b=0.1\n        (np.sqrt(1.5), 0.08164965809277261, 1.7, 2.0, lambda x: 1 + x**2, 200000, (1.5, 0.1)),\n        (3.0, 0.005, 0.0, 20.0, lambda x: np.exp(-0.1 * x), 200000, None),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        M, Gamma, s_min, s_max, R_func, N, overrides = case\n\n        # Set resonance parameters a and b\n        if overrides:\n            a, b = overrides\n        else:\n            a = M**2\n            b = M * Gamma\n\n        # --- Importance Sampling ---\n\n        # 1. Calculate constants for sampling and weighting\n        theta_min = np.arctan((s_min - a) / b)\n        theta_max = np.arctan((s_max - a) / b)\n        \n        # 2. Generate N samples using inverse transform sampling\n        u = rng.uniform(size=N)\n        theta_samples = theta_min + u * (theta_max - theta_min)\n        x_samples = a + b * np.tan(theta_samples)\n        \n        # 3. Calculate constant part of the weight (the normalization constant N_p)\n        W_const = (theta_max - theta_min) / b\n\n        # 4. Compute the Monte Carlo estimate\n        R_values = R_func(x_samples)\n        I_hat = W_const * np.mean(R_values)\n        \n        # --- High-Accuracy Reference Calculation ---\n        \n        # Define the full integrand for numerical quadrature\n        integrand = lambda x: R_func(x) / ((x - a)**2 + b**2)\n        \n        # 5. Compute the reference integral using scipy.integrate.quad\n        I_ref, _ = integrate.quad(integrand, s_min, s_max, epsabs=1e-12, limit=200)\n\n        # 6. Calculate the absolute error\n        delta = abs(I_hat - I_ref)\n        \n        results.extend([I_hat, delta])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3532946"}]}