{"hands_on_practices": [{"introduction": "The most direct way to appreciate the power of spectral differentiation is to build it yourself. This first exercise guides you through implementing the fundamental algorithm for periodic functions using the Fast Fourier Transform (FFT). By translating the core principle—that differentiation in physical space becomes simple multiplication in Fourier space—into code, you will gain a practical understanding of constructing wavenumber arrays, handling the special case of the Nyquist frequency, and observing the method's high accuracy for smooth functions. [@problem_id:3417201]", "problem": "You are asked to design and implement a program that computes the first derivative of a periodic function using spectral differentiation in transform space with a Fast Fourier Transform (FFT). The underlying principle is that differentiation in the physical domain corresponds to multiplication by the imaginary unit times the angular wavenumber in the Fourier domain. All angles must be in radians.\n\nThe fundamental base to use is as follows. Consider a periodic function sampled on a uniform grid over a periodic interval of length $L$. Let the grid be $x_j = j\\Delta x$ for $j = 0, 1, \\dots, N-1$, where $\\Delta x = L/N$. The Discrete Fourier Transform (DFT) and its inverse are defined (up to normalization constants chosen by library conventions) by\n$$\nU_k = \\sum_{j=0}^{N-1} u_j \\, e^{-\\mathrm{i} \\kappa_k x_j}, \\quad\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k \\, e^{\\mathrm{i} \\kappa_k x_j},\n$$\nwhere $u_j = u(x_j)$ and $\\kappa_k$ are the angular wavenumbers corresponding to the integer Fourier modes indexed by $k$. For a periodic domain of length $L$, the continuous Fourier modes are $e^{\\mathrm{i} m (2\\pi/L) x}$ with integer $m$, hence the angular wavenumbers are $\\kappa = (2\\pi/L) m$.\n\nThe key well-tested fact to use is that for each Fourier mode $e^{\\mathrm{i} \\kappa x}$, the derivative satisfies\n$$\n\\frac{d}{dx} \\left( e^{\\mathrm{i} \\kappa x} \\right) = \\mathrm{i} \\kappa \\, e^{\\mathrm{i} \\kappa x}.\n$$\nTherefore, differentiation in the Fourier domain corresponds to multiplication by $\\mathrm{i} \\kappa$.\n\nConstruct the angular wavenumber array by mapping the DFT indices to integers consistent with the periodic grid. For even $N$, the ordering of integer wavenumbers is $0, 1, \\dots, N/2, -(N/2-1), \\dots, -1$. The corresponding angular wavenumbers are $\\kappa_k = (2\\pi/L) \\, m_k$, where $m_k$ follows the specified ordering. The Nyquist mode at $m = N/2$ occurs only when $N$ is even; the conventional choice in spectral differentiation is to set the derivative multiplier of the Nyquist coefficient to zero to maintain real-valuedness of the physical derivative for real input data.\n\nYour implementation must proceed in the following logical steps, strictly adhering to the principles above without using any unmotivated shortcut formulas:\n1. Sample the function $u(x)$ on an equispaced grid $x_j$ over $[0, L)$ with $N$ points.\n2. Compute the DFT coefficients $U_k$ using a Fast Fourier Transform (FFT).\n3. Construct the angular wavenumber array $\\kappa_k$ from the DFT frequency bins for the given $L$ and $N$, ensuring correct ordering for negative frequencies. For even $N$, set the derivative multiplier at the Nyquist index to zero.\n4. Form the differentiated spectrum $\\widehat{u'}_k = \\mathrm{i} \\, \\kappa_k \\, U_k$.\n5. Compute the inverse DFT of $\\widehat{u'}_k$ to obtain the differentiated values $u'_j$ in the physical domain. Use the convention of your FFT library consistently.\n6. Extract the real part of $u'_j$ and report errors or diagnostic values as required.\n\nTest suite. Your program must compute and aggregate the following test cases, each producing a single real number. Use $N = 16$ unless otherwise stated, and angles in radians.\n\n- Case A (happy path, exact resolvability): Let $L = 2\\pi$. Define $u(x) = \\sin(3x) + 0.5 \\cos(5x)$. Compute the spectral derivative and the analytic derivative $u'(x) = 3 \\cos(3x) - 2.5 \\sin(5x)$. Report the maximum absolute error $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$ as a float.\n\n- Case B (Nyquist mode handling): Let $L = 2\\pi$. Define $u(x) = \\cos\\!\\big((N/2) x\\big) = \\cos(8x)$. Compute the spectral derivative, which should be identically zero on the sample grid due to the derivative being proportional to $\\sin\\!\\big((N/2) x\\big)$ evaluated at $x_j = 2\\pi j/N$, where it vanishes. Report $\\max_j |u'_j|$ as a float.\n\n- Case C (aliasing beyond Nyquist): Let $L = 2\\pi$. Define $u(x) = \\sin(9x)$. On the discrete grid with $N = 16$, this aliases to $-\\sin(7x)$. The spectral method will return the derivative consistent with the aliased representation, i.e., approximately $-7 \\cos(7x)$ on the grid. Report the maximum absolute error between the spectral derivative and the aliased derivative,\n$$\n\\max_j \\left| u'_j - \\left( -7 \\cos(7 x_j) \\right) \\right|,\n$$\nas a float.\n\n- Case D (non-unit domain length scaling): Let $L = 4\\pi$. Define\n$$\nu(x) = \\sin\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) + 0.5 \\cos\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\nThe analytic derivative is\n$$\nu'(x) = \\left(3 \\cdot \\frac{2\\pi}{L}\\right) \\cos\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) - 0.5 \\left(5 \\cdot \\frac{2\\pi}{L}\\right) \\sin\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\nReport the maximum absolute error $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$ as a float.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order [Case A, Case B, Case C, Case D]. For example, a line of the form \"[resultA,resultB,resultC,resultD]\".", "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded, well-posed, objective, and provides a complete and consistent set of requirements for implementing a spectral differentiation algorithm. The problem is a standard exercise in numerical spectral methods and is directly relevant to the specified topic. We may therefore proceed with a formal solution.\n\nThe core principle of spectral differentiation for a periodic function $u(x)$ on a domain of length $L$ is based on its Fourier series representation. Any sufficiently smooth periodic function can be expressed as a sum of complex exponentials:\n$$\nu(x) = \\sum_{m=-\\infty}^{\\infty} \\hat{u}_m e^{\\mathrm{i} \\kappa_m x}\n$$\nwhere $\\hat{u}_m$ are the Fourier coefficients and $\\kappa_m = m \\frac{2\\pi}{L}$ are the angular wavenumbers for integer modes $m$. The key property of the Fourier basis is that differentiation is diagonal in this basis. Differentiating the series term-by-term yields:\n$$\n\\frac{d u(x)}{dx} = \\sum_{m=-\\infty}^{\\infty} (\\mathrm{i} \\kappa_m) \\hat{u}_m e^{\\mathrm{i} \\kappa_m x}\n$$\nThis demonstrates that in the Fourier domain, differentiation of the function $u(x)$ corresponds to the multiplication of its Fourier coefficients $\\hat{u}_m$ by the factor $\\mathrm{i}\\kappa_m$.\n\nFor a computational implementation, we work with a discretized version of the function. The function $u(x)$ is sampled on a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. The discrete function values are $u_j = u(x_j)$. The continuous Fourier series is replaced by the Discrete Fourier Transform (DFT), which relates the physical space values $u_j$ to a set of $N$ discrete Fourier coefficients $U_k$. The forward and inverse DFT pair, as implemented in standard numerical libraries like `numpy`, are defined as:\n$$\nU_k = \\sum_{j=0}^{N-1} u_j e^{-\\mathrm{i} 2\\pi j k / N} \\quad (\\text{FFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k e^{\\mathrm{i} 2\\pi j k / N} \\quad (\\text{iFFT})\n$$\nHere, the index $k$ ranges from $0$ to $N-1$ and represents the discrete frequency bins. To apply the differentiation principle, we must map these indices to the correct physical angular wavenumbers $\\kappa_k$. The set of integer wavenumbers $m$ that can be uniquely represented on a grid of $N$ points spans from negative to positive values. For an even number of points $N$, the standard convention arranges the corresponding integer modes $m_k$ for DFT indices $k=0, 1, \\dots, N-1$ as $m_k \\in \\{0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1\\}$. The physical angular wavenumber associated with each DFT index $k$ is then given by:\n$$\n\\kappa_k = m_k \\frac{2\\pi}{L}\n$$\nThis array of wavenumbers can be algorithmically generated. A critical aspect of spectral differentiation is the handling of the Nyquist frequency, which corresponds to the integer mode $|m| = N/2$ for even $N$. As stipulated, the derivative multiplier for the Nyquist mode coefficient is set to zero. This practice ensures that the computed derivative of a real-valued function remains real-valued and helps to stabilize the numerical scheme. While the problem statement describes an integer wavenumber set containing $+N/2$, standard FFT libraries associate the Nyquist index with $-N/2$. This distinction is immaterial because the instruction to set the corresponding derivative multiplier $\\mathrm{i}\\kappa_{N/2}$ to $0$ makes the sign irrelevant.\n\nThe complete algorithm for spectral differentiation is as follows:\n1.  **Discretize**: Given a function $u(x)$, a domain length $L$, and the number of points $N$, generate the grid values $u_j = u(x_j)$ for $x_j = j L/N$, where $j=0, \\dots, N-1$.\n2.  **Forward Transform**: Compute the DFT coefficients $U_k$ of the discrete signal $u_j$ using a Fast Fourier Transform (FFT) algorithm: $U_k = \\text{FFT}(u_j)$.\n3.  **Construct Wavenumbers**: Construct the array of angular wavenumbers $\\kappa_k$ corresponding to the FFT frequency bins. For each index $k \\in \\{0, \\dots, N-1\\}$, calculate $\\kappa_k$. If $N$ is even, enforce the condition $\\kappa_{N/2} = 0$.\n4.  **Differentiate in Fourier Space**: Multiply the Fourier coefficients $U_k$ by $\\mathrm{i}\\kappa_k$ to obtain the coefficients of the derivative, $\\widehat{u'}_k = \\mathrm{i} \\kappa_k U_k$.\n5.  **Inverse Transform**: Compute the inverse FFT of the differentiated coefficients $\\widehat{u'}_k$ to transform back to physical space, yielding the discrete values of the derivative: $u'_j = \\text{iFFT}(\\widehat{u'}_k)$.\n6.  **Final Result**: For a real-valued input function $u(x)$, the computed derivative $u'_j$ should be real. Due to finite precision arithmetic, a negligible imaginary component may arise, which is discarded by taking the real part of the result.\n\nThis procedure is applied to each test case.\n-   **Case A** and **Case D** test the accuracy of the method for well-resolved functions (those containing frequencies well below the Nyquist limit), with Case D specifically testing the implementation's handling of non-standard domain length $L$. For such functions, the spectral derivative is expected to be accurate to machine precision.\n-   **Case B** tests the specified handling of the Nyquist frequency. The function $u(x) = \\cos(8x)$ on a grid with $N=16$ and $L=2\\pi$ corresponds exactly to the Nyquist frequency. The algorithm must produce a zero derivative, as its analytical derivative, $-8\\sin(8x)$, is zero at all grid points $x_j=j\\pi/8$.\n-   **Case C** tests the phenomenon of aliasing. The function $u(x) = \\sin(9x)$ has a frequency higher than the Nyquist limit for $N=16$. On the discrete grid, it is indistinguishable from (i.e., aliases to) the lower-frequency function $-\\sin(7x)$. The spectral method, operating on the grid data, correctly computes the derivative of this aliased representation, which is $-7\\cos(7x)$.", "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(u: np.ndarray, L: float) -> np.ndarray:\n    \"\"\"\n    Computes the first derivative of a periodic function u on a domain of length L\n    using the Fourier spectral method.\n\n    Args:\n        u: A numpy array of function values sampled on a uniform grid.\n        L: The length of the periodic domain.\n\n    Returns:\n        A numpy array containing the values of the spectral derivative on the grid.\n    \"\"\"\n    N = len(u)\n    \n    # 1. Construct the angular wavenumber array.\n    # The sample spacing is d = L/N. np.fft.fftfreq returns frequencies in\n    # cycles per unit of d. Here, this is cycles/distance.\n    # The angular wavenumber is kappa = 2*pi*frequency.\n    # The fftfreq function correctly orders positive and negative frequencies\n    # for the DFT output.\n    freq = np.fft.fftfreq(N, d=L/N)\n    kappa = 2 * np.pi * freq\n\n    # 2. Handle the Nyquist frequency for even N.\n    # As per the problem specification, the derivative multiplier for the Nyquist\n    # coefficient must be zeroed out. This corresponds to the FFT index N//2.\n    if N % 2 == 0:\n        kappa[N//2] = 0.0\n\n    # 3. Compute the FFT of the function.\n    U = np.fft.fft(u)\n\n    # 4. Multiply by i*kappa in Fourier space to perform differentiation.\n    U_prime = 1j * kappa * U\n\n    # 5. Compute the Inverse FFT to return to physical space.\n    u_prime = np.fft.ifft(U_prime)\n\n    # 6. For a real input, the derivative is real. Return the real part\n    # to discard any imaginary noise from floating-point inaccuracies.\n    return u_prime.real\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the spectral differentiation algorithm and\n    prints the results in the specified format.\n    \"\"\"\n    # Globally specified parameter for test cases\n    N_global = 16\n\n    results = []\n\n    # Case A: Happy path, exact resolvability\n    L_A = 2.0 * np.pi\n    x_A = np.arange(N_global) * L_A / N_global\n    u_A = np.sin(3.0 * x_A) + 0.5 * np.cos(5.0 * x_A)\n    u_prime_analytic_A = 3.0 * np.cos(3.0 * x_A) - 2.5 * np.sin(5.0 * x_A)\n    u_prime_spectral_A = spectral_derivative(u_A, L_A)\n    error_A = np.max(np.abs(u_prime_spectral_A - u_prime_analytic_A))\n    results.append(error_A)\n\n    # Case B: Nyquist mode handling\n    L_B = 2.0 * np.pi\n    x_B = np.arange(N_global) * L_B / N_global\n    u_B = np.cos((N_global / 2.0) * x_B)\n    u_prime_spectral_B = spectral_derivative(u_B, L_B)\n    # The spectral derivative should be identically zero due to Nyquist handling.\n    # We report the maximum absolute value of the computed derivative.\n    error_B = np.max(np.abs(u_prime_spectral_B))\n    results.append(error_B)\n\n    # Case C: Aliasing beyond Nyquist\n    L_C = 2.0 * np.pi\n    x_C = np.arange(N_global) * L_C / N_global\n    u_C = np.sin(9.0 * x_C)\n    # On the grid, sin(9x) aliases to -sin(7x). The spectral method\n    # differentiates this aliased representation, yielding -7*cos(7x).\n    u_aliased_deriv_C = -7.0 * np.cos(7.0 * x_C)\n    u_prime_spectral_C = spectral_derivative(u_C, L_C)\n    error_C = np.max(np.abs(u_prime_spectral_C - u_aliased_deriv_C))\n    results.append(error_C)\n\n    # Case D: Non-unit domain length scaling\n    L_D = 4.0 * np.pi\n    x_D = np.arange(N_global) * L_D / N_global\n    # Fundamental wavenumber for this domain\n    k0_D = 2.0 * np.pi / L_D\n    u_D = np.sin(3.0 * k0_D * x_D) + 0.5 * np.cos(5.0 * k0_D * x_D)\n    u_prime_analytic_D = \\\n        (3.0 * k0_D) * np.cos(3.0 * k0_D * x_D) - \\\n        0.5 * (5.0 * k0_D) * np.sin(5.0 * k0_D * x_D)\n    u_prime_spectral_D = spectral_derivative(u_D, L_D)\n    error_D = np.max(np.abs(u_prime_spectral_D - u_prime_analytic_D))\n    results.append(error_D)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3417201"}, {"introduction": "While the FFT provides a computationally efficient algorithm, it's important to understand the underlying mathematical operator it represents. This practice bridges the gap between the abstract concept of a differentiation matrix and the fast transform-based implementation. You will construct the explicit dense differentiation matrix and verify that it produces numerically identical results to the FFT-based approach, confirming that they are two sides of the same coin: one conceptual, the other practical and fast. [@problem_id:3417286]", "problem": "Consider a periodic domain $[0,2\\pi)$ and an equispaced grid of $N$ nodes $x_j = \\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$. The fundamental base for this task is the trigonometric Fourier series representation and the well-tested differentiation rule in modal space: for any Fourier mode $e^{\\mathrm{i} m x}$, $\\frac{\\mathrm{d}}{\\mathrm{d}x} e^{\\mathrm{i} m x} = \\mathrm{i} m\\, e^{\\mathrm{i} m x}$. The discrete Fourier transform and its inverse are used to map between grid values (physical space) and modal coefficients (transform space). You will implement two distinct numerical realizations of spectral differentiation on this grid:\n\n- A pseudospectral differentiation operator assembled via explicit dense transform matrices: form a forward transform matrix that maps grid values to modal coefficients, apply the modal differentiation rule by multiplying by $\\mathrm{i} m$, and then map back with the inverse transform matrix to obtain the grid derivative.\n- A fast Fourier transform (FFT) based modal differentiation: compute the discrete Fourier transform of the sampled function values, multiply the modal coefficients by $\\mathrm{i} m$, and invert using the inverse FFT to obtain the grid derivative.\n\nBoth approaches are mathematically equivalent for trigonometric polynomials resolvable on the chosen grid, and should match to machine precision when implemented correctly.\n\nAngles must be in radians. There are no physical units involved.\n\nYour program must implement both approaches and, for each test case, compute the maximum absolute difference between the two resulting grid derivatives. Report whether this maximum difference is less than $10^{-14}$.\n\nUse the following test suite, which covers a general case, a constant function, the Nyquist boundary, and mixed-mode cases. In each case, $N=32$ and $x_j = \\frac{2\\pi j}{N}$:\n\n1. $u(x) = \\cos(7x)$.\n2. $u(x) = 1$.\n3. $u(x) = \\cos(16x)$ (the Nyquist mode for $N=32$).\n4. $u(x) = \\cos(7x) + \\tfrac{1}{2}\\sin(3x)$.\n5. $u(x) = \\sin(15x)$.\n\nFor each test case, compute a boolean result indicating whether the maximum absolute difference between the pseudospectral derivative and the FFT-based modal derivative is strictly less than $10^{-14}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each \"result\" is a boolean (\"True\" or \"False\") corresponding to each test case in the order listed above.", "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in the field of numerical analysis, specifically concerning spectral methods for differentiation. All necessary data and definitions are provided, and the task is objective and verifiable.\n\nThe core of this problem lies in the principle of spectral differentiation, which leverages the properties of Fourier transforms. For a function $u(x)$ defined on a periodic domain, its derivative $u'(x)$ can be computed by first transforming the function into its Fourier series representation (modal space), performing differentiation in this space, and then transforming the result back to the original physical space. The Fourier basis functions are typically complex exponentials of the form $e^{\\mathrm{i} m x}$, where $m$ is an integer wavenumber. The differentiation rule in this basis is exceptionally simple:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x} e^{\\mathrm{i} m x} = \\mathrm{i} m\\, e^{\\mathrm{i} m x}\n$$\nThus, differentiation in physical space corresponds to multiplication by $\\mathrm{i} m$ in the modal space.\n\nFor a numerical implementation, we consider a function $u(x)$ sampled on an equispaced grid of $N$ points, $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$. The vector of sampled values is $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_{N-1})]^T$. The mapping between the physical space (grid values $\\mathbf{u}$) and the modal space (Fourier coefficients $\\hat{\\mathbf{u}}$) is achieved through the Discrete Fourier Transform (DFT) and its inverse (IDFT).\n\nThe DFT of $\\mathbf{u}$ is defined as:\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j e^{-\\mathrm{i} k x_j} = \\sum_{j=0}^{N-1} u_j e^{-\\mathrm{i} 2\\pi jk/N}, \\quad k = 0, 1, \\dots, N-1\n$$\nThe IDFT is given by:\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k e^{\\mathrm{i} k x_j} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k e^{\\mathrm{i} 2\\pi jk/N}\n$$\n\nThe discrete wavenumbers $m$ corresponding to the DFT indices $k=0, 1, \\dots, N-1$ are, for an even number of points $N$, given by the sequence $\\mathbf{m} = [0, 1, \\dots, \\frac{N}{2}-1, -\\frac{N}{2}, \\dots, -1]$. However, for the differentiation of real-valued functions, a modification is necessary at the Nyquist frequency (index $k=N/2$). The derivative of the corresponding cosine mode, $\\cos(\\frac{N}{2}x)$, is $-\\sin(\\frac{N}{2}x)$, which is identically zero on the grid $x_j$. To reflect this and avoid ambiguity, the effective wavenumber for the Nyquist mode is conventionally set to zero. The modified wavenumber vector $\\mathbf{m}'$ is therefore:\n$$\n\\mathbf{m}' = [0, 1, \\dots, \\frac{N}{2}-1, 0, -\\frac{N}{2}+1, \\dots, -1]\n$$\n\nWe implement two methods to compute the derivative $\\mathbf{u}'$ from $\\mathbf{u}$.\n\n**Method 1: Pseudospectral Differentiation via Explicit Dense Transform Matrices**\n\nThis approach involves constructing the matrices that represent the DFT, IDFT, and modal differentiation operations explicitly.\n1.  The forward DFT matrix, $\\mathbf{F}$, has entries $F_{kj} = e^{-\\mathrm{i} 2\\pi jk/N}$. The transform is $\\hat{\\mathbf{u}} = \\mathbf{F}\\mathbf{u}$.\n2.  The inverse DFT matrix, $\\mathbf{F}^{-1}$, has entries $(F^{-1})_{jk} = \\frac{1}{N} e^{\\mathrm{i} 2\\pi jk/N}$.\n3.  The modal differentiation operator, $\\mathbf{D}_{\\text{modal}}$, is a diagonal matrix with the values $\\mathrm{i}\\mathbf{m}'$ on its diagonal, i.e., $(\\mathbf{D}_{\\text{modal}})_{kk} = \\mathrm{i} m'_k$.\nThe complete differentiation operator in physical space is assembled as a single dense matrix $\\mathbf{D} = \\mathbf{F}^{-1}\\mathbf{D}_{\\text{modal}}\\mathbf{F}$. The grid derivative vector is then computed by a matrix-vector product: $\\mathbf{u}' = \\mathbf{D}\\mathbf{u}$.\n\n**Method 2: FFT-based Modal Differentiation**\n\nThis method follows the same conceptual steps but uses the highly efficient Fast Fourier Transform (FFT) algorithm, avoiding the memory and computational costs of forming and multiplying by dense matrices. This approach scales as $O(N \\log N)$ instead of $O(N^2)$.\n1.  Compute the Fourier coefficients using FFT: $\\hat{\\mathbf{u}} = \\text{FFT}(\\mathbf{u})$.\n2.  Multiply by $\\mathrm{i}\\mathbf{m}'$ in modal space: $\\hat{\\mathbf{u}}' = \\mathrm{i}\\mathbf{m}' \\odot \\hat{\\mathbf{u}}$ (element-wise product).\n3.  Transform back to physical space using the inverse FFT: $\\mathbf{u}' = \\text{IFFT}(\\hat{\\mathbf{u}}')$.\n\nFor each test case, we compute the derivative vector using both methods. Since the input functions are real, the exact derivative is also real. The numerical methods, though using complex arithmetic, should yield a result that is real up to floating-point precision. We therefore take the real part of both resulting vectors and compute the maximum absolute difference between them. This difference is compared against the tolerance of $10^{-14}$ to verify that the two methods produce numerically identical results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares two methods of spectral differentiation:\n    1. Using explicit dense Fourier transform matrices.\n    2. Using the Fast Fourier Transform (FFT).\n    The comparison is done on a suite of test functions, checking if the\n    maximum absolute difference between the results is less than 1e-14.\n    \"\"\"\n    N = 32\n    # Define the grid in the periodic domain [0, 2*pi)\n    x = 2 * np.pi * np.arange(N) / N\n\n    # Define the wavenumbers for differentiation.\n    # The numpy.fft.fftfreq function provides the scaled frequencies k/N.\n    # Multiplying by N gives the integer wavenumbers.\n    m = np.fft.fftfreq(N) * N\n\n    # For differentiation of real-valued data, the contribution from the\n    # Nyquist frequency is conventionally set to zero to avoid ambiguity.\n    # The Nyquist frequency corresponds to index N/2.\n    if N % 2 == 0:\n        m[N // 2] = 0.0\n\n    # --- Method 1: Pseudospectral differentiation via explicit matrices ---\n\n    # Construct the forward DFT matrix F\n    j = np.arange(N)\n    k = np.arange(N)\n    F = np.exp(-1j * 2 * np.pi * k[:, np.newaxis] * j[np.newaxis, :] / N)\n    \n    # Construct the inverse DFT matrix F_inv\n    F_inv = np.exp(1j * 2 * np.pi * j[:, np.newaxis] * k[np.newaxis, :] / N) / N\n    \n    # Construct the diagonal differentiation matrix in modal space\n    D_modal = np.diag(1j * m)\n    \n    # Assemble the full differentiation operator D in physical space\n    # D = F_inv @ D_modal @ F\n    # The @ operator denotes matrix multiplication.\n    # To be precise on the order of operations as in the description:\n    # u' = F_inv * (D_modal * (F * u))\n    # which is equivalent to (F_inv * D_modal * F) * u\n    D_matrix = F_inv @ D_modal @ F\n\n    # --- Define Test Cases ---\n    test_functions = [\n        lambda x: np.cos(7 * x),                     # Case 1: General case\n        lambda x: np.ones_like(x),                   # Case 2: Constant function (m=0)\n        lambda x: np.cos(16 * x),                    # Case 3: Nyquist mode for N=32\n        lambda x: np.cos(7 * x) + 0.5 * np.sin(3 * x), # Case 4: Mixed-mode case\n        lambda x: np.sin(15 * x)                     # Case 5: Another well-resolved mode\n    ]\n\n    results = []\n    TOLERANCE = 1e-14\n\n    for u_func in test_functions:\n        # Evaluate the function on the grid\n        u_vec = u_func(x)\n\n        # --- Compute derivative using Method 1 (Matrices) ---\n        du_dx_method1 = D_matrix @ u_vec\n\n        # --- Compute derivative using Method 2 (FFT) ---\n        u_hat = np.fft.fft(u_vec)\n        du_hat_dx = 1j * m * u_hat\n        du_dx_method2 = np.fft.ifft(du_hat_dx)\n\n        # The derivative of a real function is real. The numerical methods\n        # should produce results with imaginary parts close to zero. We\n        # compare the real parts of the results.\n        max_abs_diff = np.max(np.abs(np.real(du_dx_method1) - np.real(du_dx_method2)))\n        \n        # Check if the difference is within the machine precision tolerance\n        is_close = max_abs_diff < TOLERANCE\n        results.append(is_close)\n\n    # Format the final output as a comma-separated list of booleans\n    # The str() conversion handles Python's 'True'/'False' capitalization.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3417286"}, {"introduction": "A key challenge in applying spectral methods to nonlinear problems, such as in fluid dynamics, is managing aliasing errors that arise from products of functions. This exercise tackles this issue head-on by asking you to compute the derivative of a product, a process that can generate frequencies beyond what the grid can represent. You will implement and contrast a naive approach with the standard de-aliasing technique known as the two-thirds rule, providing a crucial skill for achieving stability and accuracy in complex simulations. [@problem_id:3417276]", "problem": "Consider the $2\\pi$-periodic functions $u(x)=\\sin(ax)$ and $v(x)=\\cos(bx)$ sampled on a uniform periodic grid with $N$ points on the interval $[0,2\\pi)$, where $x_j=\\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$ and angles are measured in radians. The goal is to compute the spatial derivative $\\partial_x(uv)$ by a spectral method in transform space using the Fast Fourier Transform (FFT), both without de-aliasing and with the two-thirds-rule de-aliasing implemented via $3/2$ zero-padding, and then to quantify the aliasing error by comparison to the exact analytical derivative obtained from first principles.\n\nStart from the following fundamental bases:\n- The Fourier series representation of a $2\\pi$-periodic function $f(x)$ and the Discrete Fourier Transform (DFT) computed via the Fast Fourier Transform (FFT).\n- The identity for derivatives in transform space: for each Fourier mode $e^{\\mathrm{i}kx}$ it holds that $\\partial_x e^{\\mathrm{i}kx}=\\mathrm{i}k e^{\\mathrm{i}kx}$.\n- The product rule $\\partial_x(uv)=u_x v + u v_x$.\n\nDesign a program that, for each test case described below, performs the following tasks:\n1. Compute $w(x)=u(x)v(x)$ at the $N$ grid points and then compute $\\partial_x w$ at those points by transforming $w$ into Fourier space, multiplying by $\\mathrm{i}k$, and transforming back. Use the angular wavenumbers $k$ consistent with the $[0,2\\pi)$ domain. This is the computation without de-aliasing.\n2. Compute $\\partial_x w$ with de-aliasing using the two-thirds rule implemented via $3/2$ zero-padding: zero-pad the discrete Fourier transforms of $u$ and $v$ from length $N$ to length $M=\\frac{3N}{2}$ (ensure correct coefficient scaling so that inverse transforms evaluate the same continuous Fourier content on the finer grid), inverse transform to the $M$-point grid, form the product $w$ pointwise on the $M$-point grid, transform $w$ back to Fourier space, multiply by $\\mathrm{i}k$ at resolution $M$, truncate the resulting spectrum back to length $N$ (with the inverse scaling to preserve low-frequency content), and inverse transform to the original $N$-point grid.\n3. Compute the exact analytical derivative $\\partial_x(uv)$ using the product rule and the definitions of $u$ and $v$, evaluated at the $N$ grid points.\n4. Quantify the aliasing error for both the non-de-aliased and de-aliased computations as the relative discrete $\\ell^2$ error with respect to the exact analytical derivative, defined as\n$$\nE_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm over the $N$ sampled grid points.\n\nYour program must implement the FFT-based spectral differentiation with appropriate angular wavenumbers $k$ constructed from the DFT frequency array for a sampling spacing $\\Delta x = \\frac{2\\pi}{N}$ so that the angular wavenumbers are integers. It must also implement the $3/2$ zero-padding procedure with consistent scaling when padding and truncating spectra to preserve the amplitudes of low-frequency Fourier modes.\n\nTest Suite:\nUse the following five test cases to exercise different aliasing regimes. Each test case is a tuple $(N,a,b)$ with angles in radians:\n- Case 1 (no aliasing, low wavenumbers): $(16,3,4)$.\n- Case 2 (strong aliasing, high-but-resolvable inputs whose product excites modes above Nyquist): $(16,7,7)$.\n- Case 3 (no aliasing at higher resolution): $(32,12,13)$.\n- Case 4 (aliasing near the resolution limit): $(32,15,17)$.\n- Case 5 (aliasing at moderate resolution): $(24,8,10)$.\n\nAnswer Specification:\nFor each test case, compute the pair of relative $\\ell^2$ errors $[E_{\\ell^2}^{\\text{no-dealias}}, E_{\\ell^2}^{\\text{dealias}}]$. Aggregate the results for all five cases into a single line of output containing a list of five such pairs. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, where each pair is itself a comma-separated list enclosed in square brackets. For example: \"[[e11,e12],[e21,e22],[e31,e32],[e41,e42],[e51,e52]]\". All angles must be treated in radians. No physical units other than radians are involved, and no conversions are necessary.", "solution": "The user wants me to solve a problem that involves computing the derivative of a product of two trigonometric functions using spectral methods and quantifying the aliasing error.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Functions**: $u(x) = \\sin(ax)$ and $v(x) = \\cos(bx)$ are $2\\pi$-periodic.\n- **Domain**: Uniform grid on $[0, 2\\pi)$ with $N$ points, $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$.\n- **Task**: Compute the spatial derivative $\\partial_x(uv)$.\n- **Method 1 (No De-aliasing)**: Compute the product $w=uv$ in physical space, transform to Fourier space using FFT, multiply each mode $\\hat{w}(k)$ by $\\mathrm{i}k$, and transform back using IFFT.\n- **Method 2 (De-aliasing via Two-Thirds Rule)**: \n    1. Pad the Fourier transforms of $u$ and $v$ from length $N$ to $M = \\frac{3N}{2}$.\n    2. Apply scaling to the padded spectra.\n    3. Inverse transform to the $M$-point grid.\n    4. Compute the product $w=uv$ on the $M$-point grid.\n    5. Transform $w$ to the $M$-dimensional Fourier space.\n    6. Multiply each mode $\\hat{w}(k)$ by $\\mathrm{i}k$ (using wavenumbers for the $M$-point grid).\n    7. Truncate the resulting spectrum back to length $N$.\n    8. Apply inverse scaling.\n    9. Inverse transform to the original $N$-point grid.\n- **Method 3 (Exact Analytical Derivative)**: Compute $\\partial_x(uv)$ using the product rule: $\\partial_x(uv) = (\\partial_x u)v + u(\\partial_x v)$.\n- **Error Metric**: The relative discrete $\\ell^2$ error, $E_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2}$, where $\\|\\cdot\\|_2$ is the Euclidean norm over the $N$ grid points.\n- **Wavenumbers**: The angular wavenumbers $k$ must be integers consistent with the domain.\n- **Test Suite**:\n    - Case 1: $(N, a, b) = (16, 3, 4)$\n    - Case 2: $(N, a, b) = (16, 7, 7)$\n    - Case 3: $(N, a, b) = (32, 12, 13)$\n    - Case 4: $(N, a, b) = (32, 15, 17)$\n    - Case 5: $(N, a, b) = (24, 8, 10)$\n- **Output Format**: A single-line string representation of a list of five pairs: `[[e1_no_dealias,e1_dealias], [e2_no_dealias,e2_dealias], ...]`.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is a standard exercise in numerical analysis, specifically within the field of spectral methods. It correctly utilizes Fourier transforms for differentiation and addresses the well-known phenomenon of aliasing. The proposed de-aliasing method (the two-thirds rule implemented via zero-padding) is a canonical technique. All principles are sound.\n- **Well-Posed**: The problem is clearly defined with specific, unambiguous algorithmic steps. All required parameters are provided in the test suite. The error metric is a standard mathematical definition. All test cases use an even integer $N$, for which $M=3N/2$ is an integer, ensuring the padding procedure is well-defined. A unique, deterministic numerical result exists for each test case.\n- **Objective**: The problem is stated using precise mathematical and algorithmic language, free of any subjectivity or ambiguity.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, well-posed, objective, complete, and poses a non-trivial challenge relevant to the specified topic.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be provided.\n\n### **Solution Development**\n\nThe core of this problem lies in understanding how differentiation and multiplication are handled in Fourier space and how the finite resolution of a discrete grid leads to aliasing errors.\n\n**1. Spectral Differentiation**\n\nA $2\\pi$-periodic function $f(x)$ can be expressed as a Fourier series:\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{\\mathrm{i}kx}\n$$\nwhere $k$ are integer angular wavenumbers and $c_k$ are the complex Fourier coefficients. Differentiating term-by-term yields:\n$$\n\\partial_x f(x) = \\sum_{k=-\\infty}^{\\infty} (\\mathrm{i}k) c_k e^{\\mathrm{i}kx}\n$$\nThis demonstrates that differentiation in physical space corresponds to multiplication by $\\mathrm{i}k$ in Fourier space.\n\nOn a discrete grid of $N$ points $x_j = 2\\pi j/N$, we use the Discrete Fourier Transform (DFT), computed efficiently by the Fast Fourier Transform (FFT). The procedure is:\n1. Compute the DFT of the sampled function $f(x_j)$ to obtain its discrete spectrum, $\\hat{f}_k$.\n2. Determine the integer wavenumber $k$ corresponding to each element of the DFT array. For a domain of length $2\\pi$, the wavenumbers are $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$.\n3. Multiply each $\\hat{f}_k$ by $\\mathrm{i}k$.\n4. Compute the Inverse DFT (IDFT) of the resulting spectrum to obtain the derivative samples $\\partial_x f(x_j)$.\n\n**2. Aliasing in Products**\n\nThe product of two functions, $w(x) = u(x)v(x)$, corresponds to the convolution of their spectra in Fourier space. If the highest wavenumber in $u(x)$ is $k_u$ and in $v(x)$ is $k_v$, the product $w(x)$ will contain wavenumbers up to $k_u + k_v$.\n\nOn a grid of size $N$, the highest representable wavenumber without ambiguity is the Nyquist wavenumber, $k_{Nyquist} = N/2$. If $k_u + k_v > k_{Nyquist}$, the high-frequency content of the product \"aliases,\" meaning it is misrepresented as a lower-frequency mode on the grid. For a mode with wavenumber $k > k_{Nyquist}$, its alias on the grid will be $k' = k - mN$ for some integer $m$ that brings $k'$ into the resolvable range $[ -N/2, N/2-1 ]$. This corrupts the numerical result.\n\n**3. De-aliasing with the Two-Thirds Rule**\n\nTo compute the product $uv$ without aliasing, we must perform the multiplication on a grid fine enough to represent all resulting wavenumbers. If the original functions are resolved on an $N$-point grid (meaning their modes satisfy $|k| < N/2$), their product's highest mode is less than $N$. The two-thirds rule states that if we restrict the initial spectra to wavenumbers $|k| < N/3$, the product's highest mode is less than $2N/3$. This can be resolved on a padded grid of size $M$ if its Nyquist limit satisfies $M/2 > 2N/3$, which holds for the common choice $M = 3N/2$.\n\nThe problem specifies an algorithm that implements this idea:\n- Transform $u$ and $v$ to Fourier space.\n- Pad their spectra to a larger size $M=3N/2$. This is equivalent to interpolating the functions onto a finer grid.\n- A crucial step is scaling the spectra. To preserve the function's values when moving from an $N$-point IFFT to an $M$-point IFFT, the Fourier coefficients must be scaled by a factor of $M/N$.\n- On the fine grid, multiply the function values pointwise: $w_{padded} = u_{padded} v_{padded}$. This product is free from aliasing if the original wavenumbers were sufficiently low.\n- Transform $w_{padded}$ to the $M$-dimensional Fourier space, perform the differentiation by multiplying by $\\mathrm{i}k$ (using the wavenumbers for the $M$-grid), and then truncate the resulting spectrum back down to size $N$.\n- This truncation requires an inverse scaling factor of $N/M$ to correctly represent the continuous Fourier amplitudes in the $N$-point DFT convention.\n- The final IFFT yields the de-aliased derivative on the original grid.\n\n**4. Analytical Derivative**\n\nThe exact derivative provides the ground truth for error analysis. Using the product rule:\n$$\nw(x) = \\sin(ax)\\cos(bx)\n$$\n$$\n\\partial_x w(x) = \\frac{d}{dx}(\\sin(ax))\\cos(bx) + \\sin(ax)\\frac{d}{dx}(\\cos(bx))\n$$\n$$\n\\partial_x w(x) = a\\cos(ax)\\cos(bx) - b\\sin(ax)\\sin(bx)\n$$\nThis expression is evaluated at the grid points $x_j$ to obtain the exact reference solution.\n\n**5. Implementation Steps**\n\nThe program will loop through each test case $(N, a, b)$ and perform the following calculations:\n1. **Grid and Functions**: Define the $N$-point grid `x` and the sample arrays `u` and `v`.\n2. **Non-De-aliased Derivative**: Compute `w = u * v`, FFT to get `w_hat`, multiply by `1j * k`, and IFFT to get `dw_dx_no_dealias`. The real part of this result is used.\n3. **De-aliased Derivative**:\n    - FFT `u` and `v` to get `u_hat` and `v_hat`.\n    - Create zero arrays `u_hat_padded` and `v_hat_padded` of size $M=3N/2$.\n    - Copy the frequency components from the original spectra to the padded spectra, preserving their wavenumber positions.\n    - Scale the padded spectra by $M/N$.\n    - IFFT to get `u_padded` and `v_padded` on the fine grid.\n    - Compute the product `w_padded = u_padded * v_padded`.\n    - FFT to get `w_padded_hat`.\n    - Differentiate by multiplying by `1j * k_padded`.\n    - Truncate the resulting spectrum back to size $N$.\n    - Scale the truncated spectrum by $N/M$.\n    - IFFT to get `dw_dx_dealias`. The real part of this result is used.\n4. **Exact Derivative**: Evaluate the analytical formula for $\\partial_x w(x)$ on the grid `x`.\n5. **Error Calculation**: For both numerical methods, compute the relative $\\ell^2$ norm of the difference between the numerical and exact derivatives. The results are stored as a pair `[error_no_dealias, error_dealias]`.\nFinally, all pairs are collected and printed in the specified string format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for a suite of test cases.\n    \"\"\"\n\n    def compute_errors(N, a, b):\n        \"\"\"\n        Computes the derivative of u(x)v(x) and its error for a given (N, a, b).\n\n        Args:\n            N (int): Number of grid points.\n            a (int): Wavenumber for sin(ax).\n            b (int): Wavenumber for cos(bx).\n\n        Returns:\n            list: A pair of floats [error_no_dealias, error_dealias].\n        \"\"\"\n        # 1. Grid, functions, and analytical derivative\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(a * x)\n        v = np.cos(b * x)\n        \n        # Exact analytical derivative evaluated on the grid\n        dw_dx_exact = a * np.cos(a * x) * np.cos(b * x) - b * np.sin(a * x) * np.sin(b * x)\n        norm_exact = np.linalg.norm(dw_dx_exact)\n\n        # Handle case where the exact derivative is zero to avoid division by zero.\n        if norm_exact < 1e-15:\n            # If the exact derivative is zero, the absolute error is the norm of the computed one.\n            # Relative error is not well-defined, but we can check if the computed is also zero.\n            # For this problem's test cases, norm_exact is never zero.\n            pass\n\n        # 2. Method 1: No De-aliasing\n        w = u * v\n        k_N = np.fft.fftfreq(N) * N\n        dw_dx_hat_no_dealias = 1j * k_N * np.fft.fft(w)\n        dw_dx_no_dealias = np.fft.ifft(dw_dx_hat_no_dealias)\n\n        error_no_dealias = np.linalg.norm(dw_dx_no_dealias.real - dw_dx_exact) / norm_exact\n\n        # 3. Method 2: De-aliasing with 3/2 zero-padding\n        M = 3 * N // 2\n        \n        u_hat = np.fft.fft(u)\n        v_hat = np.fft.fft(v)\n        \n        # Padded spectra\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        v_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        # Slicing indices for even N\n        # Positive frequencies (and zero) go at the beginning.\n        # Negative frequencies (including Nyquist) go at the end.\n        n_pos_freqs = N // 2\n        \n        # Copy positive frequencies\n        u_hat_padded[:n_pos_freqs] = u_hat[:n_pos_freqs]\n        v_hat_padded[:n_pos_freqs] = v_hat[:n_pos_freqs]\n\n        # Copy negative frequencies\n        u_hat_padded[M - (N - n_pos_freqs):] = u_hat[n_pos_freqs:]\n        v_hat_padded[M - (N - n_pos_freqs):] = v_hat[n_pos_freqs:]\n        \n        # Scale for IFFT to finer grid\n        u_hat_padded *= M / N\n        v_hat_padded *= M / N\n        \n        # Transform to fine grid, multiply, and transform back\n        u_padded = np.fft.ifft(u_hat_padded)\n        v_padded = np.fft.ifft(v_hat_padded)\n        w_padded = u_padded * v_padded\n        w_padded_hat = np.fft.fft(w_padded)\n        \n        # Differentiate in padded Fourier space\n        k_M = np.fft.fftfreq(M) * M\n        dw_dx_padded_hat = 1j * k_M * w_padded_hat\n        \n        # Truncate spectrum back to size N\n        dw_dx_hat_dealias = np.zeros(N, dtype=np.complex128)\n        dw_dx_hat_dealias[:n_pos_freqs] = dw_dx_padded_hat[:n_pos_freqs]\n        dw_dx_hat_dealias[n_pos_freqs:] = dw_dx_padded_hat[M - (N - n_pos_freqs):]\n\n        # Scale for IFFT to original grid\n        dw_dx_hat_dealias *= N / M\n        \n        dw_dx_dealias = np.fft.ifft(dw_dx_hat_dealias)\n        \n        error_dealias = np.linalg.norm(dw_dx_dealias.real - dw_dx_exact) / norm_exact\n        \n        return [error_no_dealias, error_dealias]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 3, 4),   # Case 1\n        (16, 7, 7),   # Case 2\n        (32, 12, 13), # Case 3\n        (32, 15, 17), # Case 4\n        (24, 8, 10),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b = case\n        errors = compute_errors(N, a, b)\n        results.append(errors)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is very close.\n    # We just need to remove spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3417276"}]}