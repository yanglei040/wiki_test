{"hands_on_practices": [{"introduction": "To bridge the gap between the abstract weak formulation of a partial differential equation and a concrete numerical system, we must first learn how to construct the fundamental matrices. This exercise provides a direct, hands-on opportunity to compute the entries of a local stiffness matrix for a low-degree polynomial basis. By working through the integration of the basis function derivatives, you will gain a concrete understanding of how the operator's structure materializes from its definition, providing a solid foundation for more complex scenarios [@problem_id:3398573].", "problem": "Consider the one-dimensional Poisson operator with unit diffusion coefficient on the reference element $[-1,1]$. In a spectral/discontinuous Galerkin formulation, the local stiffness matrix $\\mathbf{K}$ associated with a polynomial basis $\\{\\phi_{i}(x)\\}_{i=0}^{p}$ is defined from the bilinear form of the weak statement as $K_{ij} = \\int_{-1}^{1} \\frac{d \\phi_{i}}{d x}(x) \\frac{d \\phi_{j}}{d x}(x) \\, dx$. Let $\\{\\phi_{0}, \\phi_{1}, \\phi_{2}\\}$ be the degree-$p$ Legendre basis on $[-1,1]$ with $p=2$, where $\\phi_{n}(x) = P_{n}(x)$ and $P_{n}(x)$ denotes the standard Legendre polynomial of degree $n$ on $[-1,1]$ satisfying the orthogonality relation $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$. Using exact quadrature (i.e., exact evaluation of the defining integrals), compute the local stiffness matrix $\\mathbf{K}$ and list its entries in the order $\\{P_{0}, P_{1}, P_{2}\\}$. Your final answer must be the full $3 \\times 3$ matrix as a single closed-form analytic expression. No rounding is required.", "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in the field of numerical methods for partial differential equations. We proceed with the solution.\n\nThe task is to compute the local stiffness matrix $\\mathbf{K}$ for the one-dimensional Poisson operator on the reference element $[-1, 1]$. The entries of the stiffness matrix are defined by the integral:\n$$\nK_{ij} = \\int_{-1}^{1} \\frac{d \\phi_{i}}{d x}(x) \\frac{d \\phi_{j}}{d x}(x) \\, dx\n$$\nThe basis functions $\\{\\phi_{i}\\}_{i=0}^{2}$ are chosen to be the standard Legendre polynomials $\\{P_{i}\\}_{i=0}^{2}$ on the interval $[-1, 1]$. We are considering the basis set for $p=2$, which consists of $\\{P_{0}(x), P_{1}(x), P_{2}(x)\\}$.\n\nFirst, we list the required Legendre polynomials and their derivatives. The first three standard Legendre polynomials are:\n$$\n\\phi_{0}(x) = P_{0}(x) = 1\n$$\n$$\n\\phi_{1}(x) = P_{1}(x) = x\n$$\n$$\n\\phi_{2}(x) = P_{2}(x) = \\frac{1}{2}(3x^2 - 1)\n$$\nNext, we compute the derivatives of these basis functions with respect to $x$:\n$$\n\\frac{d \\phi_{0}}{d x} = \\frac{d P_{0}}{d x} = 0\n$$\n$$\n\\frac{d \\phi_{1}}{d x} = \\frac{d P_{1}}{d x} = 1\n$$\n$$\n\\frac{d \\phi_{2}}{d x} = \\frac{d P_{2}}{d x} = \\frac{d}{dx} \\left( \\frac{1}{2}(3x^2 - 1) \\right) = \\frac{1}{2}(6x) = 3x\n$$\n\nNow, we can compute the $3 \\times 3$ entries of the stiffness matrix $\\mathbf{K}$ using the integral definition. The matrix is symmetric, i.e., $K_{ij} = K_{ji}$, so we only need to compute the upper triangular entries.\n\nFor $i=0$:\nSince $\\frac{d \\phi_{0}}{dx} = 0$, all entries in the first row and first column of the matrix will be zero.\n$$\nK_{00} = \\int_{-1}^{1} (0)(0) \\, dx = 0\n$$\n$$\nK_{01} = \\int_{-1}^{1} (0)(1) \\, dx = 0\n$$\n$$\nK_{02} = \\int_{-1}^{1} (0)(3x) \\, dx = 0\n$$\nBy symmetry, $K_{10} = K_{01} = 0$ and $K_{20} = K_{02} = 0$.\n\nFor $i=1$:\n$$\nK_{11} = \\int_{-1}^{1} \\left( \\frac{d \\phi_{1}}{d x} \\right)^2 \\, dx = \\int_{-1}^{1} (1)^2 \\, dx = \\int_{-1}^{1} 1 \\, dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\n$$\nK_{12} = \\int_{-1}^{1} \\frac{d \\phi_{1}}{d x} \\frac{d \\phi_{2}}{d x} \\, dx = \\int_{-1}^{1} (1)(3x) \\, dx = 3 \\int_{-1}^{1} x \\, dx = 3 \\left[ \\frac{x^2}{2} \\right]_{-1}^{1} = 3 \\left( \\frac{1^2}{2} - \\frac{(-1)^2}{2} \\right) = 0\n$$\nBy symmetry, $K_{21} = K_{12} = 0$.\n\nFor $i=2$:\n$$\nK_{22} = \\int_{-1}^{1} \\left( \\frac{d \\phi_{2}}{d x} \\right)^2 \\, dx = \\int_{-1}^{1} (3x)^2 \\, dx = 9 \\int_{-1}^{1} x^2 \\, dx = 9 \\left[ \\frac{x^3}{3} \\right]_{-1}^{1} = 9 \\left( \\frac{1^3}{3} - \\frac{(-1)^3}{3} \\right) = 9 \\left( \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) \\right) = 9 \\left( \\frac{2}{3} \\right) = 6\n$$\nAlternatively, for $K_{22}$, we can use the orthogonality property of Legendre polynomials. Note that $\\frac{d \\phi_{2}}{dx} = 3x = 3P_{1}(x)$.\n$$\nK_{22} = \\int_{-1}^{1} (3 P_{1}(x))(3 P_{1}(x)) \\, dx = 9 \\int_{-1}^{1} P_{1}(x) P_{1}(x) \\, dx\n$$\nUsing the given orthogonality relation $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$, with $m=n=1$:\n$$\n\\int_{-1}^{1} P_{1}(x) P_{1}(x) \\, dx = \\frac{2}{2(1)+1} = \\frac{2}{3}\n$$\nTherefore, $K_{22} = 9 \\times \\frac{2}{3} = 6$, which confirms our direct integration result.\n\nAssembling the matrix $\\mathbf{K}$ with the computed entries:\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\nK_{00} & K_{01} & K_{02} \\\\\nK_{10} & K_{11} & K_{12} \\\\\nK_{20} & K_{21} & K_{22}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 6\n\\end{pmatrix}\n$$\nThis is the local stiffness matrix for the basis $\\{P_0, P_1, P_2\\}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 6\n\\end{pmatrix}\n}\n$$", "id": "3398573"}, {"introduction": "In numerical analysis, theoretical properties such as energy conservation do not always transfer perfectly to the discrete setting. This computational practice explores a critical phenomenon known as quadrature aliasing, where using an inexact integration rule to assemble the convection matrix breaks the underlying skew-symmetry property of the continuous operator. By observing the resulting spurious energy growth, you will develop a deeper appreciation for how the choice of quadrature directly impacts the stability and physical fidelity of a simulation [@problem_id:3398522].", "problem": "Consider the one-dimensional linear advection equation on the interval $[-1,1]$ with periodic boundary conditions,\n$$\n\\partial_t u(x,t) + \\partial_x u(x,t) = 0,\n$$\nand its spectral Galerkin semi-discretization in a modal Legendre basis $\\{\\phi_i(x)\\}_{i=0}^p$, where $\\phi_i(x)$ is the $i$-th Legendre polynomial on $[-1,1]$. Let $u_h(x,t) = \\sum_{j=0}^p \\hat{u}_j(t)\\,\\phi_j(x)$ denote the spectral approximation with coefficients $\\hat{u}_j(t)$.\n\nDefine the mass matrix $M \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ and the convection (stiffness) matrix $K\\in \\mathbb{R}^{(p+1)\\times(p+1)}$ by the Galerkin weak form\n$$\nM_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\phi_j(x)\\,dx,\\qquad\nK_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x \\phi_j(x)\\,dx,\n$$\nand set the semi-discrete operator $C = M^{-1}K$. The semi-discrete system reads\n$$\n\\frac{d\\hat{\\mathbf{u}}}{dt} + C\\,\\hat{\\mathbf{u}} = 0,\\quad \\hat{\\mathbf{u}}(0) = \\hat{\\mathbf{u}}_0.\n$$\n\nIn exact arithmetic with exact integration of $M$ and $K$, periodic boundary conditions imply the $M$-skew property\n$$\nM C + C^\\top M = \\mathbf{0},\n$$\nand hence the discrete $L^2$ energy $E(t) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(t)^\\top M\\,\\hat{\\mathbf{u}}(t)$ is conserved, i.e., $\\frac{dE}{dt} = 0$. However, if $K$ is assembled using an inexact quadrature rule, the $M$-skew property generally fails, which can lead to spurious growth or decay of the discrete energy.\n\nYour task is to demonstrate quadrature aliasing in the spectral Galerkin method by assembling $M$ with an exact quadrature rule of order $Q_M = p+1$ (Gauss–Legendre) and assembling $K$ with a possibly inexact quadrature rule of order $Q_K \\in \\mathbb{N}$. Use the following steps:\n\n- Use Gauss–Legendre quadrature of order $Q$ to approximate any integral $\\int_{-1}^1 f(x)\\,dx$ by $\\sum_{q=1}^{Q} w_q\\,f(x_q)$, where $\\{x_q,w_q\\}_{q=1}^Q$ are the Gauss–Legendre nodes and weights.\n- Assemble $M$ using $Q_M = p+1$ to ensure exactness for the polynomial mass integrals.\n- Assemble $K$ using a variable rule $Q_K$ (which may be less than $p+1$), to purposefully introduce inexactness and hence aliasing in the convection operator.\n- Define $C = M^{-1}K$.\n- Choose the initial condition $u(x,0) = \\sin(\\pi x)$ and compute its $L^2$ projection coefficients $\\hat{\\mathbf{u}}_0$ by solving $M\\,\\hat{\\mathbf{u}}_0 = \\mathbf{b}$ with $b_i = \\int_{-1}^1 \\phi_i(x)\\,u(x,0)\\,dx$. Use a sufficiently high quadrature order $Q_{\\text{proj}} = 2p+5$ to approximate these projection integrals.\n- Evolve the ordinary differential equation system in time with the explicit fourth-order Runge–Kutta (Runge–Kutta (RK) of order $4$) method up to final time $T$. Choose a time step $\\Delta t$ based on the spectral radius $\\rho(C)$ such that $\\Delta t = \\text{CFL}/\\max(\\rho(C),\\varepsilon)$ with $\\text{CFL} = 0.1$ and $\\varepsilon = 10^{-14}$; use a fixed number of steps $N = \\lceil T/\\Delta t \\rceil$ and adjust $\\Delta t$ to exactly reach $T$.\n- Measure the relative energy error at time $T$ using a high-order energy evaluation mass matrix $M_{\\text{en}}$ assembled with $Q_{\\text{en}}=2p+5$ and the formula\n$$\n\\mathcal{E}_{\\text{rel}} = \\frac{\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(T)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(T) - \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(0)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(0)}{\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(0)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(0)}.\n$$\n\nImplement a program that, for each test case $(p,Q_K,T)$ below, constructs $M$ with $Q_M=p+1$, constructs $K$ with the specified $Q_K$, forms $C=M^{-1}K$, projects the initial data, advances the system with the fourth-order Runge–Kutta method to time $T$, and returns $\\mathcal{E}_{\\text{rel}}$ as a floating-point number.\n\nUse the following test suite:\n- Test $1$: $(p,Q_K,T) = (0,1,0.1)$.\n- Test $2$: $(p,Q_K,T) = (3,2,0.2)$.\n- Test $3$: $(p,Q_K,T) = (7,5,0.2)$.\n- Test $4$: $(p,Q_K,T) = (7,8,0.2)$.\n- Test $5$: $(p,Q_K,T) = (9,6,0.15)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\dots]$, where each entry is the value of $\\mathcal{E}_{\\text{rel}}$ for the corresponding test case listed in order. No additional text should be printed.", "solution": "We begin from the Galerkin weak form for the one-dimensional advection equation $\\partial_t u + \\partial_x u = 0$ on the interval $[-1,1]$ with periodic boundary conditions. Using a modal Legendre basis $\\{\\phi_i\\}_{i=0}^p$, the semi-discrete approximation $u_h(x,t) = \\sum_{j=0}^p \\hat{u}_j(t)\\,\\phi_j(x)$ enforces\n$$\n\\int_{-1}^{1} \\phi_i(x)\\,\\partial_t u_h(x,t)\\,dx + \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x u_h(x,t)\\,dx = 0,\\quad \\forall i\\in\\{0,\\dots,p\\}.\n$$\nUsing linearity and defining the mass and convection matrices,\n$$\nM_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\phi_j(x)\\,dx,\\qquad\nK_{ij} = \\int_{-1}^{1} \\phi_i(x)\\,\\partial_x \\phi_j(x)\\,dx,\n$$\nwe find the ordinary differential equation for the coefficient vector $\\hat{\\mathbf{u}}(t)$:\n$$\nM\\,\\frac{d\\hat{\\mathbf{u}}}{dt} + K\\,\\hat{\\mathbf{u}} = 0\\quad\\Longleftrightarrow\\quad \\frac{d\\hat{\\mathbf{u}}}{dt} + C\\,\\hat{\\mathbf{u}} = 0,\\quad C = M^{-1}K.\n$$\nWhen $M$ and $K$ are computed with exact integration and periodic boundary conditions, integration by parts yields $K = -S$ with $S_{ij}=\\int_{-1}^1 \\partial_x \\phi_i(x)\\,\\phi_j(x)\\,dx$, hence\n$$\n(M C + C^\\top M) = (K + K^\\top) = \\left(\\int \\phi_i\\,\\partial_x\\phi_j + \\int \\phi_j\\,\\partial_x\\phi_i\\right)_{ij} = \\left(\\int \\partial_x(\\phi_i\\,\\phi_j)\\right)_{ij} = \\mathbf{0},\n$$\nwhich implies $M$-skew-adjointness of $C$ and discrete energy conservation in the $M$-inner product. The discrete energy $E(t) = \\tfrac{1}{2}\\hat{\\mathbf{u}}^\\top M \\hat{\\mathbf{u}}$ then satisfies\n$$\n\\frac{dE}{dt} = \\hat{\\mathbf{u}}^\\top M \\frac{d\\hat{\\mathbf{u}}}{dt} = -\\hat{\\mathbf{u}}^\\top M C \\hat{\\mathbf{u}} = -\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}^\\top (M C + C^\\top M)\\,\\hat{\\mathbf{u}} = 0.\n$$\nHowever, if $K$ is assembled with an inexact quadrature, $K$ is perturbed to $\\tilde{K}$ and $C$ to $\\tilde{C} = M^{-1}\\tilde{K}$; the exact $M$-skew property is generally lost:\n$$\nM \\tilde{C} + \\tilde{C}^\\top M = \\tilde{K} + \\tilde{K}^\\top \\neq \\mathbf{0},\n$$\nso that\n$$\n\\frac{dE}{dt} = -\\tfrac{1}{2}\\,\\hat{\\mathbf{u}}^\\top \\left(M \\tilde{C} + \\tilde{C}^\\top M\\right)\\,\\hat{\\mathbf{u}} \\neq 0,\n$$\nwhich yields spurious growth or decay of energy. This is the essence of quadrature aliasing: nonlinear or mixed products evaluated with insufficient quadrature inject components outside the finite-dimensional polynomial space, which re-enter the discrete space incorrectly upon projection, breaking invariants tied to exact adjointness or symmetry.\n\nAlgorithmic construction:\n\n- Basis and quadrature. We choose the Legendre basis $\\phi_i = P_i$, where $P_i$ is the $i$-th Legendre polynomial on $[-1,1]$. For any quadrature order $Q$, the Gauss–Legendre nodes and weights $\\{x_q,w_q\\}_{q=1}^Q$ integrate polynomials of degree up to $2Q-1$ exactly.\n\n- Mass matrix. To ensure an invertible and accurate mass matrix, we assemble $M$ with $Q_M = p+1$, so that any product $\\phi_i\\,\\phi_j$ (degree at most $2p$) is integrated exactly. Numerically,\n$$\nM_{ij} \\approx \\sum_{q=1}^{Q_M} w_q\\,\\phi_i(x_q)\\,\\phi_j(x_q).\n$$\n\n- Convection matrix. We introduce inexactness by assembling $K$ with a potentially lower quadrature order $Q_K$:\n$$\nK_{ij} \\approx \\sum_{q=1}^{Q_K} w_q\\,\\phi_i(x_q)\\,\\partial_x \\phi_j(x_q).\n$$\nIf $Q_K < p+1$, then the degree-$2p-1$ integrands in $K$ are not integrated exactly, and aliasing errors arise.\n\n- Semi-discrete operator. We form $C = M^{-1}K$ by solving $M C = K$ for $C$.\n\n- Initial condition and projection. We set $u(x,0)=\\sin(\\pi x)$ and compute its $L^2$ projection onto the span of $\\{\\phi_i\\}_{i=0}^p$:\n$$\nb_i = \\int_{-1}^1 \\phi_i(x)\\,u(x,0)\\,dx\\approx \\sum_{q=1}^{Q_{\\text{proj}}} w_q\\,\\phi_i(x_q)\\,u(x_q,0),\n$$\nwith $Q_{\\text{proj}}=2p+5$, and then solve $M\\,\\hat{\\mathbf{u}}_0 = \\mathbf{b}$.\n\n- Time stepping. We solve $\\frac{d\\hat{\\mathbf{u}}}{dt} = -C\\,\\hat{\\mathbf{u}}$ using the fourth-order explicit Runge–Kutta method. To mitigate time discretization error and avoid instability, we select a step size based on the spectral radius $\\rho(C)$:\n$$\n\\Delta t = \\frac{\\text{CFL}}{\\max(\\rho(C),\\varepsilon)},\\quad \\text{CFL} = 0.1,\\ \\varepsilon=10^{-14},\n$$\ntake $N=\\lceil T/\\Delta t\\rceil$ steps, and adjust $\\Delta t=T/N$ to reach the final time exactly.\n\n- Energy measurement. To quantify energy drift robustly, we evaluate the energy with a high-order mass matrix $M_{\\text{en}}$ assembled using $Q_{\\text{en}}=2p+5$:\n$$\nE(0) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}_0^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}_0,\\quad E(T) = \\tfrac{1}{2}\\,\\hat{\\mathbf{u}}(T)^\\top M_{\\text{en}}\\,\\hat{\\mathbf{u}}(T),\n$$\nand report the relative error $\\mathcal{E}_{\\text{rel}} = \\frac{E(T)-E(0)}{E(0)}$.\n\nTest design and coverage:\n\n- Test $1$: $(p,Q_K,T)=(0,1,0.1)$. Here $\\phi_0$ is constant, $\\partial_x \\phi_0=0$, thus $K=\\mathbf{0}$ regardless of $Q_K$ and $\\mathcal{E}_{\\text{rel}}=0$ up to round-off, serving as a boundary case.\n\n- Test $2$: $(p,Q_K,T)=(3,2,0.2)$. The mass is exact, while $K$ is under-integrated ($Q_K<p+1$), yielding non-$M$-skew operator and visible energy drift.\n\n- Test $3$: $(p,Q_K,T)=(7,5,0.2)$. Higher degree with stronger aliasing effects; expect noticeable energy growth or decay.\n\n- Test $4$: $(p,Q_K,T)=(7,8,0.2)$. Exactness restored ($Q_K=p+1$) so that $M C + C^\\top M \\approx \\mathbf{0}$; expect $\\mathcal{E}_{\\text{rel}}$ near machine and time-stepping error levels.\n\n- Test $5$: $(p,Q_K,T)=(9,6,0.15)$. High degree with substantial under-integration, demonstrating increased sensitivity to quadrature aliasing.\n\nThe program constructs all matrices, performs the projection and time stepping, and prints a single line containing $[\\mathcal{E}_{\\text{rel}}^{(1)},\\dots,\\mathcal{E}_{\\text{rel}}^{(5)}]$ in that order, thereby measuring energy error versus quadrature order and demonstrating that inexact quadrature for the convection matrix destroys the $M$-skew property and induces spurious energy drift.", "answer": "```python\nimport numpy as np\n\ndef gauss_legendre(n):\n    # Gauss-Legendre nodes and weights on [-1,1]\n    x, w = np.polynomial.legendre.leggauss(n)\n    return x, w\n\ndef legendre_and_derivative_values(p, x):\n    # Evaluate Legendre polynomials P_0..P_p and their derivatives at points x\n    # Returns arrays of shape (p+1, len(x))\n    x = np.asarray(x)\n    vals = np.zeros((p + 1, x.size))\n    ders = np.zeros((p + 1, x.size))\n    for i in range(p + 1):\n        P = np.polynomial.legendre.Legendre.basis(i)\n        dP = P.deriv()\n        vals[i, :] = P(x)\n        ders[i, :] = dP(x)\n    return vals, ders\n\ndef assemble_mass(p, Q):\n    # Assemble mass matrix M using Gauss-Legendre quadrature of order Q\n    xq, wq = gauss_legendre(Q)\n    V, _ = legendre_and_derivative_values(p, xq)\n    # M = V W V^T\n    M = V @ (wq[:, None] * V.T)\n    return M\n\ndef assemble_stiffness_K(p, QK):\n    # Assemble convection (stiffness) matrix K_ij = ∫ phi_i * d(phi_j)/dx dx\n    xq, wq = gauss_legendre(QK)\n    V, dV = legendre_and_derivative_values(p, xq)\n    K = V @ (wq[:, None] * dV.T)\n    return K\n\ndef project_initial_condition(p, Qproj, u_func):\n    # Compute L2 projection coefficients of u_func onto span{phi_0..phi_p}\n    xq, wq = gauss_legendre(Qproj)\n    V, _ = legendre_and_derivative_values(p, xq)\n    uvals = u_func(xq)\n    # b_i = ∫ phi_i * u dx ≈ sum wq * phi_i(xq) * u(xq)\n    b = V @ (wq * uvals)\n    # Mass matrix for projection (exact for polynomials if Qproj large)\n    Mproj = V @ (wq[:, None] * V.T)\n    coeffs = np.linalg.solve(Mproj, b)\n    return coeffs\n\ndef rk4_linear(C, u0, dt, nsteps):\n    u = u0.copy()\n    for _ in range(nsteps):\n        k1 = -C @ u\n        k2 = -C @ (u + 0.5 * dt * k1)\n        k3 = -C @ (u + 0.5 * dt * k2)\n        k4 = -C @ (u + dt * k3)\n        u = u + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return u\n\ndef energy(u, M):\n    return 0.5 * float(u.T @ (M @ u))\n\ndef solve_case(p, QK, T):\n    # Assemble mass with exact quadrature QM = p+1\n    QM = p + 1\n    M = assemble_mass(p, QM)\n    # Assemble stiffness with possibly inexact quadrature QK\n    K = assemble_stiffness_K(p, QK)\n    # Operator C = M^{-1} K\n    C = np.linalg.solve(M, K)\n    # Initial condition u(x,0) = sin(pi x)\n    u_func = lambda x: np.sin(np.pi * x)\n    Qproj = max(2 * p + 5, 10)\n    u0 = project_initial_condition(p, Qproj, u_func)\n    # Energy evaluation mass matrix with high-order quadrature\n    Men = assemble_mass(p, Qproj)\n    E0 = energy(u0, Men)\n    # Time step based on spectral radius\n    if p == 0:\n        rho = 0.0\n    else:\n        eigvals = np.linalg.eigvals(C)\n        rho = float(np.max(np.abs(eigvals))) if eigvals.size > 0 else 0.0\n    CFL = 0.1\n    eps = 1e-14\n    dt = CFL / max(rho, eps)\n    nsteps = max(1, int(np.ceil(T / dt)))\n    dt = T / nsteps\n    # Time integration\n    uT = rk4_linear(C, u0, dt, nsteps)\n    ET = energy(uT, Men)\n    rel_err = (ET - E0) / E0 if E0 != 0.0 else 0.0\n    return rel_err\n\ndef solve():\n    # Define the test cases (p, QK, T)\n    test_cases = [\n        (0, 1, 0.1),\n        (3, 2, 0.2),\n        (7, 5, 0.2),\n        (7, 8, 0.2),\n        (9, 6, 0.15),\n    ]\n    results = []\n    for p, QK, T in test_cases:\n        rel_err = solve_case(p, QK, T)\n        results.append(rel_err)\n    # Print in exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3398522"}, {"introduction": "The practical viability of high-order spectral methods hinges on their computational efficiency, which is not immediately obvious when considering a naive matrix-vector multiplication. This analytical exercise guides you through a complexity analysis that reveals the power of the sum-factorization technique. By exploiting the tensor-product structure of the basis functions, we can avoid assembling large, dense matrices, drastically reducing the computational cost of applying operators like the stiffness matrix. This practice quantifies the profound performance advantage of such \"matrix-free\" implementations, a cornerstone of modern high-performance spectral element codes [@problem_id:3398537].", "problem": "Consider the application of the stiffness operator $K$ arising from the weak form of the Laplace operator on a single reference hexahedral element $\\hat{\\Omega}=[-1,1]^{3}$ in a Spectral Element Method (SEM) and Discontinuous Galerkin (DG) discretization. Let the scalar trial and test spaces be spanned by tensor-product Lagrange basis functions built on $p+1$ Gauss–Lobatto–Legendre (GLL) nodes in each of the three coordinate directions, so the number of degrees of freedom per element is $N=(p+1)^{3}$. Assume a collocation formulation in which the mass matrix is diagonal under GLL quadrature and the geometry is an affine map with identity Jacobian and constant coefficients, so metric terms are trivial and the stiffness operator at the element level reduces to a sum of three separable one-dimensional contributions.\n\nDefine the one-dimensional differentiation matrix $D\\in\\mathbb{R}^{n\\times n}$, with $n=p+1$, whose entries are $D_{ij}=l_{j}'(\\xi_{i})$, where $l_{j}$ are the Lagrange basis polynomials at the GLL nodes $\\{\\xi_{i}\\}_{i=1}^{n}$. Let $\\{w_{i}\\}_{i=1}^{n}$ be the one-dimensional GLL quadrature weights, and let the three-dimensional quadrature weight at a tensor-product node $(i,j,k)$ be $w_{i}w_{j}w_{k}$. With these definitions, the element stiffness operator can be written in tensor-product form as a sum over coordinate directions of one-dimensional derivative-transpose, diagonal weighting, and one-dimensional derivative applications.\n\nTwo application strategies are considered:\n- A matrix-free sum-factorized application that exploits tensor-product separability and performs sequences of one-dimensional matrix-vector products along lines in each coordinate direction, together with diagonal scalings and accumulations.\n- A naive dense matrix-vector product with the fully assembled $N\\times N$ stiffness matrix.\n\nAssume the following floating-point operation (flop) model: a scalar multiplication or a scalar addition each counts as one flop; a dense $n\\times n$ matrix-vector multiply costs $2n^{2}$ flops (one multiplication and one addition per entry of the output vector); a diagonal scaling of a length-$n$ vector costs $n$ flops; summing three elementwise contributions costs $2$ additions per degree of freedom. Ignore flux, penalty, and boundary terms and any geometric factor contractions beyond the diagonal quadrature weights stated above.\n\nStarting from the separable weak form and these operational assumptions, derive:\n1. The total flop count per element for the sum-factorized application of $K$ as a function of $p$.\n2. The total flop count per element for the naive dense matrix-vector application as a function of $p$.\n3. The ratio of the naive dense flop count to the sum-factorized flop count as a closed-form analytic expression in $p$.\n\nExpress your final answer as the single ratio in terms of $p$. No rounding is required, and no physical units apply. Define and use any acronyms on first use, including Discontinuous Galerkin (DG) and Spectral Element Method (SEM).", "solution": "The problem asks for the derivation of floating-point operation (flop) counts for two methods of applying a spectral element stiffness operator on a reference hexahedron, and for the ratio of these counts.\n\nFirst, we establish the mathematical context and notation. The discretization uses a basis of tensor-product Lagrange polynomials of degree $p$ built on $n=p+1$ Gauss-Lobatto-Legendre (GLL) nodes in each of the three spatial directions $\\xi$, $\\eta$, and $\\zeta$. The total number of degrees of freedom (DoF) per element is $N = n^3 = (p+1)^3$. The solution vector on the element, $u$, can be represented as a 3D array of size $n \\times n \\times n$.\n\nThe stiffness operator $K$ arises from the weak form of the negative Laplacian, $-\\nabla^2$, which, for a test function $v$ and trial function $u$ on the reference element $\\hat{\\Omega}=[-1,1]^3$, is given by the integral $\\int_{\\hat{\\Omega}} \\nabla v \\cdot \\nabla u \\, d\\hat{\\Omega}$. With the assumption of an identity Jacobian, this separates into three terms:\n$$ \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\xi}\\frac{\\partial u}{\\partial \\xi} \\, d\\hat{\\Omega} + \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\eta}\\frac{\\partial u}{\\partial \\eta} \\, d\\hat{\\Omega} + \\int_{\\hat{\\Omega}} \\frac{\\partial v}{\\partial \\zeta}\\frac{\\partial u}{\\partial \\zeta} \\, d\\hat{\\Omega} $$\nWhen discretized using GLL basis functions and collocation at the GLL nodes (which makes the mass matrix diagonal), the operator action $Ku$ can be written as a sum of three components, $Ku = K_\\xi u + K_\\eta u + K_\\zeta u$. Each component corresponds to one spatial direction.\n\nThe operator for the $\\xi$-direction can be expressed in tensor-product form as $K_\\xi = (D_\\xi)^T M D_\\xi$, where $D_\\xi = D \\otimes I_n \\otimes I_n$ is the discrete derivative operator, $D \\in \\mathbb{R}^{n \\times n}$ is the 1D differentiation matrix, $I_n$ is the $n \\times n$ identity matrix, and $M$ is the $N \\times N$ diagonal mass matrix. The diagonal entries of $M$ corresponding to the node $(\\xi_i, \\eta_j, \\zeta_k)$ are the 3D quadrature weights $w_i w_j w_k$. The operators for the $\\eta$ and $\\zeta$ directions are analogous: $K_\\eta = (D_\\eta)^T M D_\\eta$ and $K_\\zeta = (D_\\zeta)^T M D_\\zeta$, with $D_\\eta = I_n \\otimes D \\otimes I_n$ and $D_\\zeta = I_n \\otimes I_n \\otimes D$.\n\n1.  **Flop Count for Sum-Factorized Application ($C_{SF}$)**\nThe sum-factorized method computes the action $Ku$ without assembling the full matrix $K$. It computes the contribution from each direction separately and sums the results: $v = (K_\\xi u) + (K_\\eta u) + (K_\\zeta u)$. Let's analyze the flop count for one term, $v_\\xi = (D_\\xi)^T M (D_\\xi u)$.\n\n-   **Step 1: Apply $D_\\xi$.** The operation $u' = D_\\xi u$ corresponds to applying the 1D differentiation matrix $D$ to the data along the $\\xi$-fibers. There are $n^2$ such fibers (one for each pair of $(\\eta_j, \\zeta_k)$ indices), and each is of length $n$. The cost for one dense $n \\times n$ matrix-vector product is given as $2n^2$ flops.\n    -   Cost of $D_\\xi u$: $n^2 \\times (2n^2) = 2n^4$ flops.\n\n-   **Step 2: Apply $M$.** The operation $u'' = M u'$ is a scaling by the diagonal mass matrix $M$. This corresponds to an element-wise multiplication of the vector $u'$ of length $N=n^3$ by the diagonal entries of $M$.\n    -   Cost of $M u'$: $N = n^3$ flops.\n\n-   **Step 3: Apply $(D_\\xi)^T$.** The operation $v_\\xi = (D_\\xi)^T u''$ is analogous to Step 1, applying the transposed derivative matrix $D^T$ along the $\\xi$-fibers.\n    -   Cost of $(D_\\xi)^T u''$: $n^2 \\times (2n^2) = 2n^4$ flops.\n\nThe total cost to compute the contribution from one direction ($v_\\xi$) is the sum of the costs of these three steps: $2n^4 + n^3 + 2n^4 = 4n^4 + n^3$ flops.\nBy symmetry, the costs for computing $v_\\eta$ and $v_\\zeta$ are identical. The total cost to compute all three contributions is $3 \\times (4n^4 + n^3) = 12n^4 + 3n^3$ flops.\n\n-   **Step 4: Accumulate results.** The final result is $v = v_\\xi + v_\\eta + v_\\zeta$. This involves summing three vectors of length $N=n^3$. This requires two vector additions. The problem specifies this costs $2$ additions per degree of freedom.\n    -   Cost of accumulation: $2N = 2n^3$ flops.\n\nThe total flop count for the sum-factorized application is the sum of all steps:\n$$C_{SF} = (12n^4 + 3n^3) + 2n^3 = 12n^4 + 5n^3$$\nSubstituting $n=p+1$, we get $C_{SF} = 12(p+1)^4 + 5(p+1)^3$.\n\n2.  **Flop Count for Naive Dense Application ($C_{Naive}$)**\nThe naive method involves forming the full $N \\times N$ stiffness matrix $K$ and performing a standard matrix-vector product $Ku$.\n-   The size of the matrix is $N \\times N$, where $N=n^3 = (p+1)^3$.\n-   The problem states that a dense $M \\times M$ matrix-vector multiply costs $2M^2$ flops. In our case, the size is $N$.\n-   The cost is therefore $2N^2$.\n$$C_{Naive} = 2N^2 = 2(n^3)^2 = 2n^6$$\nSubstituting $n=p+1$, we get $C_{Naive} = 2(p+1)^6$.\n\n3.  **Ratio of Flop Counts**\nThe ratio of the naive dense flop count to the sum-factorized flop count is:\n$$ \\text{Ratio} = \\frac{C_{Naive}}{C_{SF}} = \\frac{2n^6}{12n^4 + 5n^3} $$\nFor any valid discretization, $p \\ge 1$ and thus $n \\ge 2$, so we can simplify the expression by dividing the numerator and denominator by $n^3$:\n$$ \\text{Ratio} = \\frac{2n^3}{12n + 5} $$\nFinally, we express the ratio in terms of the polynomial degree $p$ by substituting $n=p+1$:\n$$ \\text{Ratio} = \\frac{2(p+1)^3}{12(p+1) + 5} = \\frac{2(p+1)^3}{12p + 12 + 5} = \\frac{2(p+1)^3}{12p + 17} $$\nThis expression quantifies the significant computational advantage of the sum-factorization technique over the naive dense matrix approach, an advantage that grows rapidly with the polynomial degree $p$.", "answer": "$$ \\boxed{\\frac{2(p+1)^3}{12p+17}} $$", "id": "3398537"}]}