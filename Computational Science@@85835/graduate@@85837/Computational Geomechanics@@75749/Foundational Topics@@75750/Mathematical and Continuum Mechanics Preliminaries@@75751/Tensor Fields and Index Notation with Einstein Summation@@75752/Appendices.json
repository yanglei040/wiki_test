{"hands_on_practices": [{"introduction": "Translating the elegance of Einstein summation into robust code is a foundational skill in computational mechanics. This first practice focuses on a critical, yet often overlooked, implementation detail: the 'index collision' bug. By contrasting the correct tensor contraction $s_i = \\sigma_{ij} n_j$ with a common flawed implementation, you will develop a diagnostic test to detect and understand this subtle but significant error [@problem_id:3566792].", "problem": "Consider a Cauchy stress tensor field in three dimensions where the traction vector on a plane with unit normal satisfies $s_i = \\sigma_{ij} n_j$ under Einstein summation. Let the plane normal be generated by rigid-body rotation of a reference normal $n^{(0)}_k$ via a proper orthogonal rotation tensor $Q_{jk}$ so that $n_j = Q_{jk} n^{(0)}_k$. All quantities are to be treated as dimensionless (unitless). Angles must be specified and used in radians.\n\nYour task is to implement the contraction $s_i = \\sigma_{ij} n_j$ in code and design a diagnostic that reveals index-collision bugs in the rotation step. A common index-collision mistake is to write $n_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j$ (repeating the same index on $Q_{jj}$ and using it again on $n^{(0)}_j$), which suppresses the necessary summation over the rotation index and incorrectly scales each component instead of mixing components.\n\nImplement the following for each test case:\n1. Construct a diagonal stress tensor $\\sigma_{ij} = \\mathrm{diag}(\\sigma_{11}, \\sigma_{22}, \\sigma_{33})$ from given diagonal entries.\n2. Construct the proper orthogonal rotation tensor $Q_{jk}$ for rotation about a specified coordinate axis by a specified angle in radians.\n3. Compute the rotated normal $n_j = Q_{jk} n^{(0)}_k$ and the traction $s_i = \\sigma_{ij} n_j$.\n4. Compute the buggy rotated normal $n_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j$ (no summation on $j$), and the corresponding traction $s_i^{\\mathrm{bug}} = \\sigma_{ij} n_j^{\\mathrm{bug}}$.\n5. Compute the diagnostic residual $r = \\| s - s^{\\mathrm{bug}} \\|_2$, the Euclidean norm of the difference between correct and buggy tractions.\n\nUse the following test suite, which explores typical, boundary, and edge cases:\n- Case $1$ (happy path): $\\sigma_{11} = 10$, $\\sigma_{22} = 20$, $\\sigma_{33} = 30$, rotation about the $z$-axis by angle $\\theta = \\pi/4$, and $n^{(0)} = [1, 0, 0]$.\n- Case $2$ (identity rotation boundary): $\\sigma_{11} = 15$, $\\sigma_{22} = 25$, $\\sigma_{33} = 35$, rotation about the $z$-axis by angle $\\theta = 0$, and $n^{(0)} = [0, 1, 0]$.\n- Case $3$ (zero normal boundary): $\\sigma_{11} = 12$, $\\sigma_{22} = 7$, $\\sigma_{33} = 5$, rotation about the $y$-axis by angle $\\theta = 0.5$, and $n^{(0)} = [0, 0, 0]$.\n- Case $4$ (anisotropy highlight): $\\sigma_{11} = 1000$, $\\sigma_{22} = 1$, $\\sigma_{33} = 1$, rotation about the $z$-axis by angle $\\theta = \\pi/2$, and $n^{(0)} = [1, 0, 0]$.\n- Case $5$ (in-plane isotropy with rotation): $\\sigma_{11} = 5$, $\\sigma_{22} = 5$, $\\sigma_{33} = 0$, rotation about the $z$-axis by angle $\\theta = 0.1$, and $n^{(0)} = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$.\n\nYour program must produce a single line of output containing the residuals for the five cases, as a comma-separated list enclosed in square brackets, with each residual rounded to six decimal places, for example, $[r_1,r_2,r_3,r_4,r_5]$. The output values must be floats.\n\nYour implementation must be entirely deterministic and self-contained. The rotation tensors $Q_{jk}$ must be constructed as proper orthogonal matrices for rotations about the coordinate axes. The contraction must be implemented in a manner that respects Einstein summation without index collisions. Treat all quantities as dimensionless numbers (unitless).", "solution": "The problem is valid as it is scientifically grounded in continuum mechanics and linear algebra, well-posed with a unique and deterministically computable solution for each case, and objective in its formulation. It presents a clear, formalizable task relevant to computational sciences and serves as a meaningful exercise in identifying common implementation errors in tensor algebra.\n\nThe core of this problem lies in the correct application of tensor contractions, particularly matrix-vector products, as governed by Einstein summation notation. We are tasked with computing a traction vector $s_i$ acting on a plane, which is related to the Cauchy stress tensor $\\sigma_{ij}$ and the plane's unit normal vector $n_j$ through Cauchy's first law of motion:\n$$\ns_i = \\sigma_{ij} n_j\n$$\nIn this equation, the repeated index $j$ implies summation over the three spatial dimensions (from $1$ to $3$), representing a matrix-vector multiplication.\n\nThe normal vector $n_j$ is not given directly but is obtained by rotating a reference normal vector $n^{(0)}_k$ using a proper orthogonal rotation tensor $Q_{jk}$. The transformation is given by:\n$$\nn_j = Q_{jk} n^{(0)}_k\n$$\nHere again, the repeated index $k$ implies summation, corresponding to the multiplication of the matrix $Q$ with the vector $n^{(0)}$.\n\nThe problem requires constructing the rotation tensor $Q_{jk}$ for rotations about the standard Cartesian axes. For a rotation by an angle $\\theta$ about the $x$, $y$, and $z$-axes, the respective rotation tensors are:\nRotation about the $x$-axis:\n$$\nQ_x(\\theta) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\nRotation about the $y$-axis:\n$$\nQ_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n$$\nRotation about the $z$-axis:\n$$\nQ_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nThe stress tensor $\\sigma_{ij}$ is given as a diagonal matrix constructed from three specified principal stress values, $\\sigma_{11}$, $\\sigma_{22}$, and $\\sigma_{33}$:\n$$\n\\sigma_{ij} = \\begin{pmatrix} \\sigma_{11} & 0 & 0 \\\\ 0 & \\sigma_{22} & 0 \\\\ 0 & 0 & \\sigma_{33} \\end{pmatrix}\n$$\n\nA critical part of the task is to diagnose a common coding error involving index collision. The buggy implementation of the normal vector rotation is defined as:\n$$\nn_j^{\\mathrm{bug}} = Q_{jj} n^{(0)}_j \\quad (\\text{no summation over } j)\n$$\nThis operation is not a tensor contraction. It represents an element-wise product between the diagonal elements of the rotation tensor $Q$ and the components of the reference normal vector $n^{(0)}$. For $j=1, 2, 3$, this corresponds to:\n$$\nn_1^{\\mathrm{bug}} = Q_{11} n^{(0)}_1 \\\\\nn_2^{\\mathrm{bug}} = Q_{22} n^{(0)}_2 \\\\\nn_3^{\\mathrm{bug}} = Q_{33} n^{(0)}_3\n$$\nThis flawed normal vector is then used to compute a \"buggy\" traction vector $s_i^{\\mathrm{bug}}$:\n$$\ns_i^{\\mathrm{bug}} = \\sigma_{ij} n_j^{\\mathrm{bug}}\n$$\nThis step, a matrix-vector product, is itself a correct tensor contraction, but it operates on incorrect input data $n_j^{\\mathrm{bug}}$.\n\nThe diagnostic to quantify the error is the Euclidean norm ($L_2$-norm) of the difference between the correct traction vector $s_i$ and the buggy one $s_i^{\\mathrm{bug}}$. This residual, $r$, is calculated as:\n$$\nr = \\| s - s^{\\mathrm{bug}} \\|_2 = \\sqrt{\\sum_{i=1}^{3} (s_i - s_i^{\\mathrm{bug}})^2}\n$$\n\nThe solution algorithm for each test case proceeds as follows:\n$1$. Construct the $3 \\times 3$ diagonal stress tensor $\\sigma$ from the given principal stresses $\\sigma_{11}, \\sigma_{22}, \\sigma_{33}$.\n$2$. Construct the $3 \\times 3$ proper orthogonal rotation tensor $Q$ corresponding to the specified rotation axis and angle $\\theta$.\n$3$. Convert the reference normal $n^{(0)}$ into a $3$-dimensional vector.\n$4$. Compute the correctly rotated normal vector $n$ via the matrix-vector product $n = Q n^{(0)}$.\n$5$. Compute the correct traction vector $s$ via the matrix-vector product $s = \\sigma n$.\n$6$. Isolate the diagonal of the rotation tensor $Q$.\n$7$. Compute the buggy normal vector $n^{\\mathrm{bug}}$ by performing an element-wise product of the diagonal of $Q$ and the reference normal $n^{(0)}$.\n$8$. Compute the buggy traction vector $s^{\\mathrm{bug}}$ via the matrix-vector product $s^{\\mathrm{bug}} = \\sigma n^{\\mathrm{bug}}$.\n$9$. Calculate the vector difference $s - s^{\\mathrm{bug}}$.\n$10$. Compute the Euclidean norm of the difference vector to find the residual $r$.\n$11$. Store the result rounded to six decimal places.\n\nThis procedure is applied to each of the five test cases provided, and the resulting residuals are compiled into a final list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the diagnostic residual for five test cases.\n    \"\"\"\n\n    def compute_residual(sigma_diag, rot_axis, theta, n0_tuple):\n        \"\"\"\n        Computes the residual for a single test case.\n\n        Args:\n            sigma_diag (tuple): Diagonal elements (s11, s22, s33) of the stress tensor.\n            rot_axis (str): The axis of rotation ('x', 'y', or 'z').\n            theta (float): The angle of rotation in radians.\n            n0_tuple (tuple): The components of the reference normal vector n_0.\n\n        Returns:\n            float: The computed residual r, rounded to six decimal places.\n        \"\"\"\n        # 1. Construct the diagonal stress tensor sigma\n        sigma = np.diag(sigma_diag)\n        \n        # Convert reference normal to a numpy array\n        n0 = np.array(n0_tuple, dtype=float)\n\n        # 2. Construct the proper orthogonal rotation tensor Q\n        c, s = np.cos(theta), np.sin(theta)\n        if rot_axis == 'x':\n            Q = np.array([\n                [1, 0, 0],\n                [0, c, -s],\n                [0, s, c]\n            ])\n        elif rot_axis == 'y':\n            Q = np.array([\n                [c, 0, s],\n                [0, 1, 0],\n                [-s, 0, c]\n            ])\n        elif rot_axis == 'z':\n            Q = np.array([\n                [c, -s, 0],\n                [s, c, 0],\n                [0, 0, 1]\n            ])\n        else:\n            raise ValueError(\"Invalid rotation axis specified.\")\n\n        # 3. Compute the correctly rotated normal and the correct traction\n        n = Q @ n0\n        s = sigma @ n\n\n        # 4. Compute the buggy rotated normal and the corresponding traction\n        # n_j^bug = Q_jj * n0_j (no summation) is an element-wise product\n        # of the diagonal of Q with the vector n0.\n        n_bug = np.diag(Q) * n0\n        s_bug = sigma @ n_bug\n\n        # 5. Compute the diagnostic residual r\n        residual = np.linalg.norm(s - s_bug)\n        \n        return residual\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'sigma_diag': (10, 20, 30), 'rot_axis': 'z', 'theta': np.pi/4, 'n0_tuple': (1, 0, 0)},\n        {'sigma_diag': (15, 25, 35), 'rot_axis': 'z', 'theta': 0, 'n0_tuple': (0, 1, 0)},\n        {'sigma_diag': (12, 7, 5), 'rot_axis': 'y', 'theta': 0.5, 'n0_tuple': (0, 0, 0)},\n        {'sigma_diag': (1000, 1, 1), 'rot_axis': 'z', 'theta': np.pi/2, 'n0_tuple': (1, 0, 0)},\n        {'sigma_diag': (5, 5, 0), 'rot_axis': 'z', 'theta': 0.1, 'n0_tuple': (1/np.sqrt(2), 1/np.sqrt(2), 0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_residual(**case)\n        results.append(result)\n\n    # Format the results to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3566792"}, {"introduction": "Beyond correct syntax, the power of index notation lies in its ability to express profound physical principles concisely. This exercise moves to fourth-order elasticity tensors to explore how different contraction patterns on the same tensor, such as $C_{iikk}$ versus $C_{ijij}$, yield entirely different physical quantities. You will derive the bulk modulus of an anisotropic material and discover how a seemingly minor change in index summation can lead to physically incorrect results [@problem_id:3566793].", "problem": "Design and implement a self-contained program that, for a class of three-dimensional linear elastic materials used in computational geomechanics, computes the correct bulk modulus and an intentionally miscomputed bulk modulus to expose the distinction between free versus dummy indices in Einstein summation. The program must adhere to the following mathematical and physical specifications.\n\nStart from the fundamental constitutive relation of linear elasticity under small strains,\n$$\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl},$$\nwhere $\\sigma_{ij}$ is the Cauchy stress tensor, $C_{ijkl}$ is the fourth-order elasticity (stiffness) tensor, and $\\varepsilon_{kl}$ is the small-strain tensor. The mean stress $p$ is defined by\n$$p = \\frac{1}{3}\\,\\sigma_{ii},$$\nand the volumetric strain is\n$$\\varepsilon_v = \\varepsilon_{kk}.$$\nUnder hydrostatic loading, the strain is purely spherical:\n$$\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl},$$\nwhere $\\delta_{kl}$ is the Kronecker delta. The bulk modulus $K$ is defined by\n$$K = \\frac{p}{\\varepsilon_v}.$$\n\nYour implementation must:\n- Construct $C_{ijkl}$ for a family of materials composed of an isotropic baseline and a deviatoric anisotropic perturbation:\n  $$C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl},$$\n  where $\\lambda$ is the first Lamé parameter, $\\mu$ is the shear modulus, $\\gamma$ is a nonnegative scalar amplitude, and $S_{ij}$ is a symmetric deviatoric second-order tensor with $S_{ii}=0$. The perturbation preserves minor and major symmetries and represents a physically plausible deviatoric stiffening that does not contribute to purely spherical strain when contracted correctly.\n- Compute the correct bulk modulus $K$ using the definitions above (apply hydrostatic strain and perform the correct tensor contractions).\n- Compute an intentionally misused bulk modulus $K_{\\text{wrong}}$ by swapping the positions of dummy indices during contraction, collapsing the tensor on $(i,j)$ instead of $(k,l)$ when coupling with the Kronecker delta. This incorrect procedure produces a quantity proportional to $C_{ijij}$, which is not the appropriate contraction for spherical strain.\n- Quantify the effect of the misuse by computing the relative error as a decimal (not a percentage),\n  $$e = \\frac{K_{\\text{wrong}} - K}{K},$$\nfor each test case.\n\nUnits and numerical specifications:\n- Report only the relative errors $e$ as dimensionless decimals. Do not include a percentage sign.\n- Internally, use elastic moduli in gigapascals (GPa) and a volumetric strain magnitude $\\varepsilon_v$ of $10^{-3}$ (dimensionless). Although $K$ and $K_{\\text{wrong}}$ have units of gigapascals, the final reported $e$ is unitless.\n- Angles are not involved in this problem.\n\nTest suite:\nProvide results for the following parameter sets, each defined by $(\\lambda,\\mu,\\gamma,S)$, where $\\lambda$, $\\mu$, and $\\gamma$ are in $\\mathrm{GPa}$ and $S$ is a $3\\times 3$ symmetric deviatoric tensor:\n1. Happy path isotropic material: $\\lambda = 30$, $\\mu = 20$, $\\gamma = 0$, $S = \\mathbf{0}$.\n2. Near-incompressible isotropic baseline: $\\lambda = 1000$, $\\mu = 30$, $\\gamma = 0$, $S = \\mathbf{0}$.\n3. Isotropic baseline plus deviatoric anisotropy:\n   - $\\lambda = 30$, $\\mu = 20$, $\\gamma = 50$.\n   - $S = \\begin{bmatrix} 2 & 0.5 & -0.5 \\\\ 0.5 & -1 & 0 \\\\ -0.5 & 0 & -1 \\end{bmatrix}$, which is symmetric and deviatoric since $S_{11}+S_{22}+S_{33} = 2 + (-1) + (-1) = 0$.\n4. Purely deviatoric isotropic baseline: $\\lambda = 0$, $\\mu = 30$, $\\gamma = 0$, $S = \\mathbf{0}$.\n5. Purely volumetric isotropic baseline: $\\lambda = 50$, $\\mu = 0$, $\\gamma = 0$, $S = \\mathbf{0}$.\n\nFinal output format:\nYour program should produce a single line of output containing the relative errors for the five cases as a comma-separated list enclosed in square brackets, for example,\n$$[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4,\\text{e}_5].$$\nNo other text should be printed.", "solution": "The problem requires the design of a program to compute the relative error between a correctly calculated bulk modulus, $K$, and an incorrectly calculated one, $K_{\\text{wrong}}$, for a specific class of anisotropic linear elastic materials. This exercise is designed to highlight the critical importance of correct index placement and summation conventions in tensor algebra, specifically the Einstein summation notation prevalent in continuum mechanics.\n\n### Step 1: Validation of the Problem Statement\n\nThe problem statement is subjected to rigorous validation.\n\n**1.1. Extracted Givens:**\n- Constitutive relation: $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$\n- Mean stress definition: $p = \\frac{1}{3}\\,\\sigma_{ii}$\n- Volumetric strain definition: $\\varepsilon_v = \\varepsilon_{kk}$\n- Hydrostatic strain condition: $\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl}$\n- Bulk modulus definition: $K = \\frac{p}{\\varepsilon_v}$\n- Stiffness tensor form: $C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl}$\n  - where $\\lambda$, $\\mu$, $\\gamma$ are scalar parameters.\n  - $S_{ij}$ is a symmetric, deviatoric ($S_{ii}=0$) second-order tensor.\n- Incorrect bulk modulus $K_{\\text{wrong}}$ is proportional to the contraction $C_{ijij}$.\n- Relative error definition: $e = \\frac{K_{\\text{wrong}} - K}{K}$\n- Numerical value for strain for context: $\\varepsilon_v = 10^{-3}$\n- Test cases: Five sets of parameters $(\\lambda, \\mu, \\gamma, S)$ are provided.\n\n**1.2. Validation against Criteria:**\n- **Scientifically Grounded:** The problem is firmly rooted in the theory of linear elasticity, a cornerstone of solid mechanics and geomechanics. The constitutive law, definitions of stress and strain invariants, and the form of the anisotropic stiffness tensor are standard and physically plausible.\n- **Well-Posed:** The problem is well-defined. All necessary equations and parameters are provided for each case, leading to a unique, stable, and meaningful solution (the relative error $e$).\n- **Objective:** The language is formal, mathematical, and free of subjectivity.\n- **Completeness and Consistency:** The problem is self-contained. The description of the incorrect calculation, while illustrating a conceptual error, is specified sufficiently (\"proportional to $C_{ijij}$\") to permit a unique formalization. No contradictions are present.\n\n**1.3. Verdict:**\nThe problem is deemed **valid**. It is scientifically sound, well-posed, and all information required for a unique solution is provided.\n\n### Step 2: Mathematical Derivation and Solution Design\n\nThe core of the task is to derive analytical expressions for $K$ and $K_{\\text{wrong}}$ from the provided definitions.\n\n**2.1. Derivation of the Correct Bulk Modulus ($K$)**\n\nThe bulk modulus $K$ relates the mean stress $p$ to the volumetric strain $\\varepsilon_v$ under hydrostatic loading conditions.\n\n$1$. Substitute the hydrostatic strain, $\\varepsilon_{kl} = \\frac{\\varepsilon_v}{3}\\,\\delta_{kl}$, into the constitutive equation $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$:\n$$ \\sigma_{ij} = C_{ijkl} \\left( \\frac{\\varepsilon_v}{3}\\,\\delta_{kl} \\right) = \\frac{\\varepsilon_v}{3} C_{ijkl}\\,\\delta_{kl} $$\nThe Einstein summation over the repeated index $l$ contracts the tensor $C_{ijkl}$ with $\\delta_{kl}$, which effectively replaces the index $l$ with $k$.\n$$ \\sigma_{ij} = \\frac{\\varepsilon_v}{3} C_{ijkk} $$\n\n$2$. Calculate the mean stress $p$ by taking the trace of the stress tensor, $\\sigma_{ii}$, and dividing by $3$:\n$$ p = \\frac{1}{3}\\sigma_{ii} = \\frac{1}{3} \\left( \\frac{\\varepsilon_v}{3} C_{iikk} \\right) = \\frac{\\varepsilon_v}{9} C_{iikk} $$\nHere, a second contraction occurs over the repeated index $i$. The term $C_{iikk}$ is a scalar resulting from the double contraction of the fourth-order tensor $C_{ijkl}$.\n\n$3$. Determine the expression for the scalar $C_{iikk}$ by contracting the given stiffness tensor $C_{ijkl} = \\lambda\\,\\delta_{ij}\\delta_{kl} + \\mu\\,(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\gamma\\,S_{ij}S_{kl}$. We apply summation over both $i$ and $k$. Note that in $n=3$ dimensions, $\\delta_{aa} = 3$.\n- First term: $\\lambda\\,\\delta_{ii}\\delta_{kk} = \\lambda(3)(3) = 9\\lambda$.\n- Second term: $\\mu\\,(\\delta_{ik}\\delta_{ik} + \\delta_{ik}\\delta_{ki}) = \\mu\\,(\\delta_{kk} + \\delta_{ii}) = \\mu\\,(3+3) = 6\\mu$.\n- Third term: $\\gamma\\,S_{ii}S_{kk}$. Since $S$ is deviatoric, its trace $S_{ii} = S_{11}+S_{22}+S_{33} = 0$. Thus, $\\gamma\\,S_{ii}S_{kk} = \\gamma \\cdot 0 \\cdot 0 = 0$.\n\nCombining the terms, we find:\n$$ C_{iikk} = 9\\lambda + 6\\mu $$\n\n$4$. Substitute this back into the expression for $p$ and solve for $K$:\n$$ p = \\frac{\\varepsilon_v}{9} (9\\lambda + 6\\mu) = \\varepsilon_v (\\lambda + \\frac{2}{3}\\mu) $$\n$$ K = \\frac{p}{\\varepsilon_v} = \\lambda + \\frac{2}{3}\\mu $$\nThis is the well-known relationship for the bulk modulus of an isotropic material. The anisotropic term $\\gamma\\,S_{ij}S_{kl}$ correctly makes no contribution to the bulk modulus, as it represents a purely deviatoric stiffening.\n\n**2.2. Derivation of the Misused Bulk Modulus ($K_{\\text{wrong}}$)**\n\nThe problem states that $K_{\\text{wrong}}$ is derived from a misuse of indices, producing a quantity proportional to $C_{ijij}$. We define $K_{\\text{wrong}}$ using the same proportionality constant, $1/9$, as found in the derivation of $K$ to ensure the quantities are comparable.\n$$ K_{\\text{wrong}} = \\frac{1}{9}C_{ijij} $$\nWe now compute the scalar $C_{ijij}$ by contracting $C_{ijkl}$ over its first and third indices ($k=i$) and its second and fourth indices ($l=j$), with summation implied over $i$ and $j$.\n- First term: $\\lambda\\,\\delta_{ij}\\delta_{ij} = \\lambda\\,\\delta_{ii} = 3\\lambda$.\n- Second term: $\\mu\\,(\\delta_{ii}\\delta_{jj} + \\delta_{ij}\\delta_{ji}) = \\mu\\,(3 \\cdot 3 + \\delta_{ii}) = \\mu\\,(9+3) = 12\\mu$.\n- Third term: $\\gamma\\,S_{ij}S_{ij} = \\gamma \\sum_{i,j=1}^3 (S_{ij})^2 = \\gamma \\|S\\|_F^2$, where $\\|S\\|_F^2$ is the squared Frobenius norm of the matrix representation of $S$.\n\nCombining these terms gives:\n$$ C_{ijij} = 3\\lambda + 12\\mu + \\gamma \\|S\\|_F^2 $$\nTherefore, the expression for the misused bulk modulus is:\n$$ K_{\\text{wrong}} = \\frac{1}{9} (3\\lambda + 12\\mu + \\gamma \\|S\\|_F^2) = \\frac{1}{3}\\lambda + \\frac{4}{3}\\mu + \\frac{\\gamma}{9}\\|S\\|_F^2 $$\n\n**2.3. Final Computation**\n\nThe program will implement the following derived formulas for each test case:\n1.  Compute the correct bulk modulus: $K = \\lambda + \\frac{2}{3}\\mu$.\n2.  Compute the squared Frobenius norm of $S$: $\\|S\\|_F^2 = \\sum_{i,j} S_{ij}^2$.\n3.  Compute the incorrect bulk modulus: $K_{\\text{wrong}} = \\frac{1}{3}\\lambda + \\frac{4}{3}\\mu + \\frac{\\gamma}{9}\\|S\\|_F^2$.\n4.  Compute the relative error: $e = \\frac{K_{\\text{wrong}} - K}{K}$.\n\nFor the test cases, the denominator $K$ is never zero, so the division is always well-defined. The numerical value of $\\varepsilon_v$ is extraneous to the calculation of the relative error $e$, as it cancels out.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the correct and miscomputed bulk modulus to find the relative error\n    for a series of test cases in computational geomechanics.\n    \"\"\"\n\n    # Test suite with parameters (lambda, mu, gamma, S).\n    # lambda, mu, gamma are in GPa. S is a 3x3 symmetric deviatoric tensor.\n    test_cases = [\n        {\n            # Case 1: Happy path isotropic material\n            \"lambda\": 30.0, \"mu\": 20.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 2: Near-incompressible isotropic baseline\n            \"lambda\": 1000.0, \"mu\": 30.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 3: Isotropic baseline plus deviatoric anisotropy\n            \"lambda\": 30.0, \"mu\": 20.0, \"gamma\": 50.0,\n            \"S\": np.array([[2.0, 0.5, -0.5], \n                           [0.5, -1.0, 0.0], \n                           [-0.5, 0.0, -1.0]])\n        },\n        {\n            # Case 4: Purely deviatoric isotropic baseline\n            \"lambda\": 0.0, \"mu\": 30.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        },\n        {\n            # Case 5: Purely volumetric isotropic baseline\n            \"lambda\": 50.0, \"mu\": 0.0, \"gamma\": 0.0, \n            \"S\": np.zeros((3, 3))\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lam = case[\"lambda\"]\n        mu = case[\"mu\"]\n        gamma = case[\"gamma\"]\n        S_tensor = case[\"S\"]\n\n        # Calculate the correct bulk modulus, K.\n        # K = lambda + (2/3)*mu\n        k_correct = lam + (2.0 / 3.0) * mu\n\n        # Calculate the squared Frobenius norm of the tensor S.\n        # ||S||_F^2 = sum(S_ij^2)\n        s_norm_sq = np.sum(S_tensor**2)\n\n        # Calculate the intentionally misused bulk modulus, K_wrong.\n        # K_wrong = (1/9) * (3*lambda + 12*mu + gamma * ||S||_F^2)\n        k_wrong = (1.0 / 9.0) * (3.0 * lam + 12.0 * mu + gamma * s_norm_sq)\n\n        # Calculate the relative error e = (K_wrong - K) / K.\n        # The denominator K is non-zero for all given test cases.\n        if np.isclose(k_correct, 0):\n            # This case does not occur in the test suite but is a good practice.\n            # If K is 0, relative error is infinity if K_wrong is non-zero,\n            # or undefined/0 if K_wrong is also 0.\n            # We assume K > 0 for geomechanical materials.\n            # For the purpose of this problem, we let the standard division handle it.\n            # In a real scenario, this would require specific handling.\n            pass\n        \n        relative_error = (k_wrong - k_correct) / k_correct\n        results.append(str(relative_error))\n\n    # Print the final output in the specified format: [e_1,e_2,e_3,e_4,e_5]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3566793"}, {"introduction": "This final practice synthesizes your skills in tensor manipulation and calculus to perform a vital task in computational science: code verification using the Method of Manufactured Solutions (MMS). Starting with a chosen analytical displacement field $u_i(x_j)$, you will apply the entire chain of elastostatic equations, including differentiation ($u_{i,j}$) and contraction ($\\sigma_{ij} = C_{ijkl} \\varepsilon_{kl}$), to derive the exact body force $b_i$ needed for equilibrium. This process provides an invaluable benchmark for testing the accuracy of complex numerical simulators [@problem_id:3566830].", "problem": "Construct a self-contained program that implements the Method of Manufactured Solutions (MMS) in small-strain linear elasticity for computational geomechanics using tensor index notation with Einstein summation. The goal is to start from core definitions and derive an algorithm that, given a polynomial displacement field $u_i(x_j)$ and a constant fourth-order stiffness tensor $C_{ijkl}$, computes the stress field $\\sigma_{ij}$ and its divergence to generate the body force $b_i$. All quantities are nondimensional. The program must apply the following foundational definitions and laws.\n\nFundamental base:\n1. The small-strain tensor is defined by $ \\varepsilon_{ij} = \\dfrac{1}{2} \\left( u_{i,j} + u_{j,i} \\right) $, where $u_{i,j} = \\dfrac{\\partial u_i}{\\partial x_j}$ and Einstein summation convention applies.\n2. The linear elastic constitutive relation (Hooke’s law) for a general anisotropic material is given by $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $, where $C_{ijkl}$ is a constant fourth-order stiffness tensor obeying minor symmetries $C_{ijkl} = C_{jikl} = C_{ijlk}$ and major symmetry $C_{ijkl} = C_{klij}$.\n3. The divergence of the stress gives the body force required to sustain the manufactured displacement field in static equilibrium: $ b_i = \\sigma_{ij,j} = \\dfrac{\\partial \\sigma_{ij}}{\\partial x_j} $.\n\nYour program must:\n- Represent $u_i(x_j)$ as a finite sum of multivariate monomials. Each monomial has the form $x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$ with a coefficient vector $c_i$ for the displacement components, i.e., $u_i(x_j) = \\sum_{(\\alpha,\\beta,\\gamma)} c_i^{(\\alpha,\\beta,\\gamma)} x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$. All exponents and coefficients are specified as rational or integer values.\n- Compute first derivatives $u_{i,j}$ and second derivatives $u_{i,jk} = \\dfrac{\\partial^2 u_i}{\\partial x_j \\partial x_k}$ analytically for these polynomials.\n- Use Einstein summation to assemble $ \\varepsilon_{ij} = \\dfrac{1}{2}(u_{i,j} + u_{j,i}) $, then $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $, and finally $ b_i = \\sigma_{ij,j} $.\n- Support two constructions of $C_{ijkl}$:\n  1. Isotropic stiffness using Lamé parameters $ \\lambda $ and $ \\mu $ via $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $, where $ \\delta_{ij} $ is the Kronecker delta.\n  2. A general symmetric positive-definite stiffness provided in Voigt form as a $6 \\times 6$ matrix $C^{(6)}$, interpreted in tensorial strain mapping (not engineering strain), with index pairing $ (11) \\rightarrow 0 $, $ (22) \\rightarrow 1 $, $ (33) \\rightarrow 2 $, $ (23) \\rightarrow 3 $, $ (13) \\rightarrow 4 $, $ (12) \\rightarrow 5 $, such that $ C_{ijkl} = C^{(6)}_{I J} $ with $I$ and $J$ the mapped pair indices for $(i,j)$ and $(k,l)$ using symmetric pairs.\n\nTest suite:\nProvide and evaluate the following four test cases. For each case, compute the body force $b_i$ at a specified point $x_j$ and return the numeric vector $[b_1,b_2,b_3]$.\n\n- Case A (general polynomial, isotropic): Use Lamé parameters $ \\lambda = 2 $, $ \\mu = 3 $. Let\n  $ u_1 = 2 x_1^2 - x_1 x_2 + 3 x_3 $,\n  $ u_2 = - x_1 x_3 + x_2^2 + 2 x_2 $,\n  $ u_3 = x_2 x_3 + x_3^2 - x_1 $.\n  Evaluate at $ x = (1,-1,2) $.\n\n- Case B (rigid rotation, isotropic): Use Lamé parameters $ \\lambda = 2 $, $ \\mu = 3 $. Let rigid rotation $ u_i = \\varepsilon_{ijk} \\Omega_j x_k $ with angular velocity $ \\boldsymbol{\\Omega} = (0.1,-0.2,0.3) $ and $ \\varepsilon_{ijk} $ the Levi-Civita symbol. Explicitly,\n  $ u_1 = \\Omega_2 x_3 - \\Omega_3 x_2 $,\n  $ u_2 = \\Omega_3 x_1 - \\Omega_1 x_3 $,\n  $ u_3 = \\Omega_1 x_2 - \\Omega_2 x_1 $.\n  Evaluate at $ x = (2,-3,1) $.\n\n- Case C (uniform strain, isotropic): Use Lamé parameters $ \\lambda = 2 $, $ \\mu = 3 $. Let $ u_i = A_{ij} x_j $ with constant coefficients\n  $ A = \\begin{bmatrix} 0.05 & 0.02 & 0 \\\\ 0.02 & -0.01 & 0.01 \\\\ 0 & 0.01 & 0.03 \\end{bmatrix} $.\n  Evaluate at $ x = (3,-1,4) $.\n\n- Case D (cubic polynomials, anisotropic SPD stiffness): Construct $ C^{(6)} = M^\\top M + 0.5 I $ where\n  $ M = \\begin{bmatrix}\n  2 & -1 & 0 & 0 & 1 & 2\\\\\n  0 & 3 & -1 & 1 & 0 & -2\\\\\n  1 & 0 & 2 & -2 & 1 & 0\\\\\n  -1 & 2 & 0 & 1 & -1 & 1\\\\\n  0 & 0 & 1 & 0 & 2 & -1\\\\\n  2 & -1 & 0 & 1 & 0 & 3\n  \\end{bmatrix} $, and $ I $ is the $6 \\times 6$ identity. Map $ C^{(6)} $ to $ C_{ijkl} $ using the tensorial strain Voigt pairing described above. Let\n  $ u_1 = x_1^3 + 0.5 x_1 x_2 x_3 $,\n  $ u_2 = x_2^3 - x_1^2 x_2 $,\n  $ u_3 = x_3^3 + x_2 x_3^2 $.\n  Evaluate at $ x = (0.5,-0.7,0.9) $.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three floats $[b_1,b_2,b_3]$ for a test case. For example, use the format $ [ [b_1^{(A)},b_2^{(A)},b_3^{(A)}], [b_1^{(B)},b_2^{(B)},b_3^{(B)}], [b_1^{(C)},b_2^{(C)},b_3^{(C)}], [b_1^{(D)},b_2^{(D)},b_3^{(D)}] ] $. No units are required because all quantities are nondimensional, and angles are implied in radians through the Levi-Civita-based rotation definition without requiring an explicit angle unit. Each result must be a list of floats.\n\nThe program must be self-contained and must not require any user input. It must implement the above derivations from first principles and produce the specified output format exactly.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Strain-Displacement Relation:** The small-strain tensor is $ \\varepsilon_{ij} = \\dfrac{1}{2} \\left( u_{i,j} + u_{j,i} \\right) $, with $u_{i,j} = \\dfrac{\\partial u_i}{\\partial x_j}$ and Einstein summation.\n- **Constitutive Law:** Hooke's law is $ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $. $C_{ijkl}$ is a constant fourth-order stiffness tensor.\n- **Stiffness Tensor Symmetries:** $C_{ijkl}$ obeys minor symmetries ($C_{ijkl} = C_{jikl} = C_{ijlk}$) and major symmetry ($C_{ijkl} = C_{klij}$).\n- **Equilibrium Condition:** The body force for static equilibrium is $ b_i = \\sigma_{ij,j} = \\dfrac{\\partial \\sigma_{ij}}{\\partial x_j} $.\n- **Displacement Field Form:** $u_i(x_j) = \\sum_{(\\alpha,\\beta,\\gamma)} c_i^{(\\alpha,\\beta,\\gamma)} x_1^{\\alpha} x_2^{\\beta} x_3^{\\gamma}$.\n- **Isotropic Stiffness:** $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $.\n- **Anisotropic Stiffness:** $C_{ijkl}$ is derived from a $6 \\times 6$ Voigt matrix $C^{(6)}$ using the index mapping $ (11) \\rightarrow 0 $, $ (22) \\rightarrow 1 $, $ (33) \\rightarrow 2 $, $ (23) \\rightarrow 3 $, $ (13) \\rightarrow 4 $, $ (12) \\rightarrow 5 $ for symmetric pairs.\n- **Test Case A:** Isotropic with $ \\lambda = 2, \\mu = 3 $. $ u_1 = 2 x_1^2 - x_1 x_2 + 3 x_3 $, $ u_2 = - x_1 x_3 + x_2^2 + 2 x_2 $, $ u_3 = x_2 x_3 + x_3^2 - x_1 $. Evaluate at $ x = (1,-1,2) $.\n- **Test Case B:** Isotropic with $ \\lambda = 2, \\mu = 3 $. Rigid rotation $ u_i = \\varepsilon_{ijk} \\Omega_j x_k $ with $ \\boldsymbol{\\Omega} = (0.1,-0.2,0.3) $. Evaluate at $ x = (2,-3,1) $.\n- **Test Case C:** Isotropic with $ \\lambda = 2, \\mu = 3 $. Uniform strain from $ u_i = A_{ij} x_j $ with $ A = \\begin{bmatrix} 0.05 & 0.02 & 0 \\\\ 0.02 & -0.01 & 0.01 \\\\ 0 & 0.01 & 0.03 \\end{bmatrix} $. Evaluate at $ x = (3,-1,4) $.\n- **Test Case D:** Anisotropic with $ C^{(6)} = M^\\top M + 0.5 I $, where $M$ is a given $6 \\times 6$ matrix. Displacement field is $ u_1 = x_1^3 + 0.5 x_1 x_2 x_3 $, $ u_2 = x_2^3 - x_1^2 x_2 $, $ u_3 = x_3^3 + x_2 x_3^2 $. Evaluate at $ x = (0.5,-0.7,0.9) $.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded:** The problem is based on the standard theory of linear elasticity, a cornerstone of continuum mechanics and geomechanics. All equations and concepts are fundamental and well-established. The Method of Manufactured Solutions (MMS) is a standard verification technique in computational science. The problem is scientifically sound.\n- **Well-Posed:** All inputs ($u_i$, $C_{ijkl}$, evaluation point $x$) are specified, and the desired output ($b_i$) is derived through a deterministic sequence of mathematical operations. A unique solution exists for each case. The problem is well-posed.\n- **Objective:** The problem is stated using precise, unambiguous mathematical notation and terminology. It is free of subjective claims.\n- **Completeness and Consistency:** The problem provides all necessary data and definitions for each test case. The construction of the anisotropic stiffness tensor $ C^{(6)} = M^\\top M + 0.5 I $ ensures it is symmetric and positive-definite, which is physically required. The problem is complete and internally consistent.\n- **Other Flaws:** The problem does not exhibit any other flaws such as being unrealistic, non-formalizable, or trivial. In fact, cases B and C provide non-trivial physical checks (rigid motion and uniform strain should result in zero body force), demonstrating a well-conceived problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n### Derivation and Algorithmic Design\n\nThe objective is to compute the body force vector $b_i$ required to maintain a manufactured displacement field $u_i(x_j)$ in static equilibrium. The governing equation for $b_i$ is derived from first principles.\n\nStarting from the definition of the body force as the divergence of the stress tensor:\n$$ b_i = \\sigma_{ij,j} = \\frac{\\partial \\sigma_{ij}}{\\partial x_j} $$\nSubstitute Hooke's Law, $\\sigma_{ij} = C_{ijkl} \\varepsilon_{kl}$:\n$$ b_i = \\frac{\\partial}{\\partial x_j} (C_{ijkl} \\varepsilon_{kl}) $$\nSince the stiffness tensor $C_{ijkl}$ is given as constant, it can be moved outside the derivative:\n$$ b_i = C_{ijkl} \\frac{\\partial \\varepsilon_{kl}}{\\partial x_j} = C_{ijkl} \\varepsilon_{kl,j} $$\nNext, substitute the small-strain definition, $\\varepsilon_{kl} = \\frac{1}{2}(u_{k,l} + u_{l,k})$:\n$$ b_i = C_{ijkl} \\frac{\\partial}{\\partial x_j} \\left[ \\frac{1}{2}(u_{k,l} + u_{l,k}) \\right] = \\frac{1}{2} C_{ijkl} (u_{k,lj} + u_{l,kj}) $$\nThis expression involves the second partial derivatives of the displacement field, $u_{k,lj} = \\frac{\\partial^2 u_k}{\\partial x_l \\partial x_j}$. We can simplify this expression using the minor symmetries of the stiffness tensor, specifically $C_{ijkl} = C_{ijlk}$. Consider the second term in the parenthesis:\n$$ C_{ijkl} u_{l,kj} $$\nBy renaming the dummy summation indices ($k \\leftrightarrow l$), this term becomes:\n$$ C_{ijlk} u_{k,lj} $$\nUsing the minor symmetry $C_{ijlk} = C_{ijkl}$, this is equivalent to the first term:\n$$ C_{ijlk} u_{k,lj} = C_{ijkl} u_{k,lj} $$\nTherefore, the two terms in the expression for $b_i$ are identical. The equation simplifies to:\n$$ b_i = \\frac{1}{2} C_{ijkl} (u_{k,lj} + u_{k,lj}) = C_{ijkl} u_{k,lj} $$\nThis final, compact equation, $b_i = C_{ijkl} u_{k,lj}$, forms the basis of our algorithm. It elegantly connects the body force to the second derivatives of the displacement field via the stiffness tensor. The Einstein summation convention implies summing over indices $j, k, l$ from $1$ to $3$.\n\nThe algorithm is as follows:\n1.  **Represent Polynomials:** The displacement field components $u_i$, which are multivariate polynomials, are represented as a collection of terms, with each term comprising a coefficient and a tuple of exponents for $(x_1, x_2, x_3)$.\n2.  **Analytical Differentiation:** A routine is implemented to analytically compute the first and second partial derivatives of these polynomials. Since the displacement fields are polynomials, their second partial derivatives are continuous, so the order of differentiation is immaterial ($u_{k,lj} = u_{k,jl}$).\n3.  **Stiffness Tensor Construction:**\n    *   For isotropic materials, the tensor $C_{ijkl}$ is constructed from Lamé parameters $\\lambda$ and $\\mu$ and the Kronecker delta $\\delta_{ij}$ using the formula $ C_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu \\left( \\delta_{ik} \\delta_{jl} + \\delta_{il} \\delta_{jk} \\right) $.\n    *   For the anisotropic material, the $6 \\times 6$ Voigt matrix $C^{(6)}$ is first computed. Then, the full $3 \\times 3 \\times 3 \\times 3$ tensor $C_{ijkl}$ is assembled using the specified tensorial-strain Voigt index mapping. For 0-based indices, this map is: $(0,0) \\to 0, (1,1) \\to 1, (2,2) \\to 2$, and $(1,2), (2,1) \\to 3$, $(0,2), (2,0) \\to 4$, $(0,1), (1,0) \\to 5$.\n4.  **Computation of Body Force:**\n    *   For each test case, the tensor of second derivatives, $U_{klj} \\equiv u_{k,lj}(x_p)$, is computed by evaluating the symbolic second derivatives at the specified point $x_p$.\n    *   The body force vector $b_i$ is computed by contracting the stiffness tensor with the second derivative tensor: $b_i = C_{ijkl} U_{klj}$. This tensor contraction is efficiently performed using `numpy.einsum`.\n\n**Verification with Canonical Cases:**\n- **Case B (Rigid Rotation):** The displacement field $u_i = \\varepsilon_{ijk} \\Omega_j x_k$ is linear in position $x_k$. Consequently, all second derivatives $u_{i,jk}$ are identically zero. The formula $b_i = C_{ijkl} u_{k,lj}$ immediately yields $b_i = 0$. This is physically correct, as a rigid rotation induces no strain, hence no stress, and requires no body force to maintain.\n- **Case C (Uniform Strain):** The displacement field $u_i = A_{ij} x_j$ with constant $A_{ij}$ is also linear in $x_j$. As with rigid rotation, all second derivatives $u_{i,jk}$ are zero, leading to $b_i=0$. This is also physically correct: a homogeneous strain field results in a constant stress field, whose divergence is zero.\n\nThese analytical checks confirm the validity of the derived formula and provide confidence in the subsequent numerical implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Method of Manufactured Solutions for small-strain linear elasticity.\n    \"\"\"\n\n    class Polynomial:\n        \"\"\"\n        Represents a multivariate polynomial as a sum of terms.\n        Each term is a tuple (coefficient, (exp_x1, exp_x2, exp_x3)).\n        \"\"\"\n        def __init__(self, terms_list):\n            # terms_list: e.g., [(2.0, (2,0,0)), (-1.0, (1,1,0))] for 2*x1^2 - x1*x2\n            self.terms = [term for term in terms_list if term[0] != 0]\n\n        def differentiate(self, var_index):\n            \"\"\"\n            Differentiates the polynomial with respect to a variable xi.\n            var_index: 0 for x1, 1 for x2, 2 for x3.\n            \"\"\"\n            new_terms = []\n            for coeff, exponents in self.terms:\n                exp = exponents[var_index]\n                if exp > 0:\n                    new_coeff = coeff * exp\n                    new_exponents = list(exponents)\n                    new_exponents[var_index] -= 1\n                    new_terms.append((new_coeff, tuple(new_exponents)))\n            if not new_terms:\n                return Polynomial([(0.0, (0, 0, 0))])\n            return Polynomial(new_terms)\n\n        def evaluate(self, x):\n            \"\"\"Evaluates the polynomial at a point x = (x1, x2, x3).\"\"\"\n            total = 0.0\n            for coeff, exponents in self.terms:\n                term_val = coeff\n                for i in range(3):\n                    if exponents[i] > 0:\n                        term_val *= x[i] ** exponents[i]\n                    elif exponents[i] < 0: # Should not happen for polynomials\n                        if x[i] == 0: return np.nan\n                        term_val *= x[i] ** exponents[i]\n\n                total += term_val\n            return total\n\n    def get_isotropic_C(lam, mu):\n        \"\"\"Constructs the isotropic stiffness tensor C_ijkl.\"\"\"\n        delta = np.eye(3)\n        # C_ijkl = lam * delta_ij * delta_kl + mu * (delta_ik * delta_jl + delta_il * delta_jk)\n        C = (lam * np.einsum('ij,kl->ijkl', delta, delta) +\n             mu * (np.einsum('ik,jl->ijkl', delta, delta) +\n                   np.einsum('il,jk->ijkl', delta, delta)))\n        return C\n\n    def get_anisotropic_C(C6):\n        \"\"\"Constructs the anisotropic stiffness tensor C_ijkl from a 6x6 Voigt matrix.\"\"\"\n        voigt_map = {(0, 0): 0, (1, 1): 1, (2, 2): 2,\n                     (1, 2): 3, (2, 1): 3,\n                     (0, 2): 4, (2, 0): 4,\n                     (0, 1): 5, (1, 0): 5}\n        C = np.zeros((3, 3, 3, 3))\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    for l in range(3):\n                        I = voigt_map[(i, j)]\n                        J = voigt_map[(k, l)]\n                        C[i, j, k, l] = C6[I, J]\n        return C\n\n    def compute_body_force(u_polys, C, point):\n        \"\"\"Computes the body force b_i = C_ijkl * u_k,lj at a given point.\"\"\"\n        u_deriv2 = np.zeros((3, 3, 3))\n        for k in range(3):\n            for l in range(3):\n                for j in range(3):\n                    # u_k,lj = d/dxj (d/dxl (u_k))\n                    deriv2_poly = u_polys[k].differentiate(l).differentiate(j)\n                    u_deriv2[k, l, j] = deriv2_poly.evaluate(point)\n        \n        # b_i = C_ijkl * u_k,lj\n        b = np.einsum('ijkl,klj->i', C, u_deriv2, optimize=True)\n        return b.tolist()\n\n    # --- Test Cases Setup ---\n    \n    # Case A: General polynomial, isotropic\n    u_A = [\n        Polynomial([(2.0, (2, 0, 0)), (-1.0, (1, 1, 0)), (3.0, (0, 0, 1))]),\n        Polynomial([(-1.0, (1, 0, 1)), (1.0, (0, 2, 0)), (2.0, (0, 1, 0))]),\n        Polynomial([(1.0, (0, 1, 1)), (1.0, (0, 0, 2)), (-1.0, (1, 0, 0))])\n    ]\n    C_A = get_isotropic_C(lam=2.0, mu=3.0)\n    point_A = (1, -1, 2)\n\n    # Case B: Rigid rotation, isotropic\n    Omega = np.array([0.1, -0.2, 0.3])\n    # u1 = O2*x3 - O3*x2 = -0.2*x3 - 0.3*x2\n    # u2 = O3*x1 - O1*x3 = 0.3*x1 - 0.1*x3\n    # u3 = O1*x2 - O2*x1 = 0.1*x2 + 0.2*x1\n    u_B = [\n        Polynomial([(Omega[1], (0, 0, 1)), (-Omega[2], (0, 1, 0))]),\n        Polynomial([(Omega[2], (1, 0, 0)), (-Omega[0], (0, 0, 1))]),\n        Polynomial([(Omega[0], (0, 1, 0)), (-Omega[1], (1, 0, 0))])\n    ]\n    C_B = get_isotropic_C(lam=2.0, mu=3.0)\n    point_B = (2, -3, 1)\n\n    # Case C: Uniform strain, isotropic\n    A = np.array([[0.05, 0.02, 0.0],\n                  [0.02, -0.01, 0.01],\n                  [0.0, 0.01, 0.03]])\n    u_C = [\n        Polynomial([(A[0, 0], (1, 0, 0)), (A[0, 1], (0, 1, 0)), (A[0, 2], (0, 0, 1))]),\n        Polynomial([(A[1, 0], (1, 0, 0)), (A[1, 1], (0, 1, 0)), (A[1, 2], (0, 0, 1))]),\n        Polynomial([(A[2, 0], (1, 0, 0)), (A[2, 1], (0, 1, 0)), (A[2, 2], (0, 0, 1))])\n    ]\n    C_C = get_isotropic_C(lam=2.0, mu=3.0)\n    point_C = (3, -1, 4)\n\n    # Case D: Cubic polynomials, anisotropic\n    M = np.array([\n        [2, -1, 0, 0, 1, 2],\n        [0, 3, -1, 1, 0, -2],\n        [1, 0, 2, -2, 1, 0],\n        [-1, 2, 0, 1, -1, 1],\n        [0, 0, 1, 0, 2, -1],\n        [2, -1, 0, 1, 0, 3]\n    ])\n    C6_D = M.T @ M + 0.5 * np.eye(6)\n    C_D = get_anisotropic_C(C6_D)\n    u_D = [\n        Polynomial([(1.0, (3, 0, 0)), (0.5, (1, 1, 1))]),\n        Polynomial([(1.0, (0, 3, 0)), (-1.0, (2, 1, 0))]),\n        Polynomial([(1.0, (0, 0, 3)), (1.0, (0, 1, 2))])\n    ]\n    point_D = (0.5, -0.7, 0.9)\n\n    test_cases = [\n        (u_A, C_A, point_A),\n        (u_B, C_B, point_B),\n        (u_C, C_C, point_C),\n        (u_D, C_D, point_D),\n    ]\n\n    results = []\n    for u_polys, C, point in test_cases:\n        b = compute_body_force(u_polys, C, point)\n        results.append(b)\n    \n    # Format the final output string exactly as requested\n    result_strings = [f\"[{','.join(f'{x:.10f}' for x in res)}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\n\nsolve()\n```", "id": "3566830"}]}