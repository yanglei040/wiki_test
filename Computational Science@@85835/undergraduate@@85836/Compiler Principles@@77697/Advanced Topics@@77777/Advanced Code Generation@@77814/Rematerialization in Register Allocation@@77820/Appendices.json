{"hands_on_practices": [{"introduction": "At its heart, the decision to rematerialize is a cost-benefit analysis. A compiler must weigh the cost of re-executing instructions against the cost of storing a value in memory and reloading it later. This first exercise guides you through the fundamental mathematics of this trade-off, allowing you to derive a precise threshold to make an optimal, data-driven decision [@problem_id:3668340].", "problem": "A compiler performing Register Allocation (RA) must decide, for a value whose live range cannot be entirely assigned to a register, whether to spill the value to memory and reload it at each use, or to rematerialize the value at each use by recomputing it from its operands. Consider a cost model in which all dynamic costs add linearly across independent events and are measured in machine cycles per execution. Let $C_{\\text{spill}}$ denote the total dynamic cost accrued over the entire live range if the value is spilled, including any one-time store and all reloads. Let $C_{\\text{rm}}$ denote the per-use dynamic cost of rematerializing the value (for example, the cost of regenerating an immediate and applying a simple arithmetic operation). Let $U$ denote the dynamic use count of the value across the program’s execution profile, defined as the sum of execution counts of all static use sites.\n\nStarting only from these definitions and the assumption of linear additivity of independent costs, derive a threshold expression $C_{\\text{rm}}^{*}$ in terms of $C_{\\text{spill}}$ and $U$ such that choosing rematerialization minimizes the total dynamic cost precisely when $C_{\\text{rm}}$ is below this threshold. State the decision criterion in terms of $C_{\\text{rm}}$ and $C_{\\text{rm}}^{*}$.\n\nThen validate the expression with the following worked example. A value $v$ has three static uses: one in basic block $B_{1}$ executed $10$ times, one in $B_{2}$ executed $2$ times, and one in $B_{3}$ executed $2$ times, so that the dynamic use count is the sum across these sites. If spilled, $v$ incurs a one-time store cost of $c_{s} = 12$ cycles and a reload cost of $c_{\\ell} = 6$ cycles per dynamic use, so the total spill cost is the one-time store plus the sum of reloads across all dynamic uses. If rematerialized, $v$ can be recomputed at each use by loading an immediate and performing a single arithmetic operation with costs $c_{\\text{imm}} = 2$ cycles and $c_{\\text{op}} = 1$ cycle respectively, so the per-use rematerialization cost is the sum of these operation costs.\n\nCompute:\n1. The threshold $C_{\\text{rm}}^{*}$.\n2. The decision indicator $D$, where $D = 1$ if rematerialization is selected and $D = 0$ otherwise.\n\nExpress the numerical threshold in machine cycles per use and the decision indicator as a dimensionless value. Report your final answer as a row matrix $\\begin{pmatrix} C_{\\text{rm}}^{*}  D \\end{pmatrix}$.", "solution": "The problem requires the derivation of a decision criterion for choosing between two compiler optimization strategies for a value that cannot be held in a register for its entire live range: spilling to memory or rematerialization. The decision is to be based on minimizing the total dynamic cost, measured in machine cycles.\n\nFirst, we establish the total dynamic cost for each strategy based on the provided definitions. Let $C_{\\text{total, spill}}$ be the total cost of the spilling strategy and $C_{\\text{total, rm}}$ be the total cost of the rematerialization strategy.\n\nThe problem defines $C_{\\text{spill}}$ as the total dynamic cost for the spilling strategy, which includes a one-time store and all subsequent reloads. Thus, we have:\n$$C_{\\text{total, spill}} = C_{\\text{spill}}$$\n\nThe problem defines $C_{\\text{rm}}$ as the per-use dynamic cost of rematerializing the value. The total number of dynamic uses of the value is given by $U$. The problem states that costs add linearly across independent events. Since rematerialization is performed at each of the $U$ dynamic uses, the total cost for this strategy is the per-use cost multiplied by the number of uses:\n$$C_{\\text{total, rm}} = C_{\\text{rm}} \\times U$$\n\nTo minimize the total dynamic cost, the compiler should choose rematerialization if and only if its total cost is strictly less than the total cost of spilling. This gives us the following inequality:\n$$C_{\\text{total, rm}}  C_{\\text{total, spill}}$$\nSubstituting the expressions for the total costs, we get:\n$$C_{\\text{rm}} \\times U  C_{\\text{spill}}$$\n\nThe problem asks for a threshold, $C_{\\text{rm}}^{*}$, such that rematerialization is the optimal choice precisely when $C_{\\text{rm}}  C_{\\text{rm}}^{*}$. To derive this threshold, we isolate $C_{\\text{rm}}$ in the inequality. Assuming the value is used at least once, the dynamic use count $U$ is a positive integer ($U \\ge 1$). Therefore, we can divide both sides of the inequality by $U$ without altering its direction:\n$$C_{\\text{rm}}  \\frac{C_{\\text{spill}}}{U}$$\nBy comparing this inequality to the required form $C_{\\text{rm}}  C_{\\text{rm}}^{*}$, we can directly identify the threshold $C_{\\text{rm}}^{*}$:\n$$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U}$$\nThe decision criterion is: select rematerialization if $C_{\\text{rm}}  C_{\\text{rm}}^{*}$; otherwise, select spilling.\n\nNext, we apply this formal derivation to the worked example to compute the numerical values for $C_{\\text{rm}}^{*}$ and the decision indicator $D$.\n\n1.  **Compute the dynamic use count, $U$**.\n    $U$ is the sum of the execution counts of all static use sites.\n    $$U = 10 + 2 + 2 = 14$$\n\n2.  **Compute the total spill cost, $C_{\\text{spill}}$**.\n    This cost consists of a one-time store cost, $c_{s} = 12$ cycles, and a reload cost, $c_{\\ell} = 6$ cycles, incurred for each of the $U$ dynamic uses.\n    $$C_{\\text{spill}} = c_{s} + (c_{\\ell} \\times U) = 12 + (6 \\times 14) = 12 + 84 = 96$$\n    The total spill cost is $96$ cycles.\n\n3.  **Compute the per-use rematerialization cost, $C_{\\text{rm}}$**.\n    This cost is the sum of the cost to load an immediate, $c_{\\text{imm}} = 2$ cycles, and the cost of a single arithmetic operation, $c_{\\text{op}} = 1$ cycle.\n    $$C_{\\text{rm}} = c_{\\text{imm}} + c_{\\text{op}} = 2 + 1 = 3$$\n    The per-use rematerialization cost is $3$ cycles per use.\n\n4.  **Compute the threshold, $C_{\\text{rm}}^{*}$**.\n    Using the derived formula and the computed values for $C_{\\text{spill}}$ and $U$:\n    $$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U} = \\frac{96}{14} = \\frac{48}{7}$$\n    The threshold is $\\frac{48}{7}$ machine cycles per use.\n\n5.  **Determine the decision indicator, $D$**.\n    We apply the decision criterion by comparing the actual per-use cost $C_{\\text{rm}}$ with the threshold $C_{\\text{rm}}^{*}$:\n    $$C_{\\text{rm}} = 3$$\n    $$C_{\\text{rm}}^{*} = \\frac{48}{7} \\approx 6.857$$\n    The inequality to check is $C_{\\text{rm}}  C_{\\text{rm}}^{*}$, which is $3  \\frac{48}{7}$. Multiplying both sides by $7$ gives $21  48$, which is true.\n    Since the condition is met, rematerialization is the cost-minimizing strategy. The problem defines the decision indicator $D$ to be $1$ if rematerialization is selected. Therefore:\n    $$D = 1$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{48}{7}  1 \\end{pmatrix}}$$", "id": "3668340"}, {"introduction": "Beyond the direct cost of instructions, the primary goal of rematerialization is to reduce 'register pressure'—the competition for the limited number of available registers. This is achieved by shortening the live ranges of variables, which means they occupy a register for less time. This conceptual exercise explores how rematerialization accomplishes this, impacting the underlying interference graph that the register allocator must solve [@problem_id:3668375].", "problem": "Consider a loop with induction variable $i$ and an address expression $a = \\text{base} + i \\cdot \\text{stride}$ used inside the loop and also used once immediately after the loop. Assume the following canonical control flow: a preheader initializes $i$, a single-entry single-exit loop updates $i$ by a fixed increment $\\text{stride}$ each iteration and terminates when $i$ reaches a bound $N$, and there is an exit block that uses $a$ exactly once. The target architecture supports a single-instruction computation of $a$ from $\\text{base}$, $i$, and $\\text{stride}$.\n\nThe register allocator currently keeps a virtual register $v_a$ holding the running value of $a$ across the loop and into the exit block (for example, by computing $a$ once and then updating it by adding $\\text{stride}$ each iteration). Consider instead a rematerialization transformation that does not carry $v_a$ across the loop and instead recomputes $a$ at the exit from $\\text{base}$, $i$, and $\\text{stride}$ in a fresh virtual register $v_a^{\\text{exit}}$.\n\nUse the following foundational definitions from compiler theory:\n- A variable is live at a program point if its current value may be read along some path starting at that point before being overwritten. The live range of a virtual register is the set of program points where it is live. A reduction in live range length means strictly fewer program points where it is live.\n- The interference graph has one node per virtual register, with an edge between two nodes if their live ranges overlap at any program point. The interference degree $\\Delta$ of a node is the number of its neighbors.\n\nAssume that $\\text{base}$, $i$, and $\\text{stride}$ are either already available at the exit or are themselves cheap to rematerialize so that recomputing $a$ in the exit block is legal and has negligible cost relative to a spill.\n\nWhich statement best characterizes the effect of rematerializing $a$ at the loop exit on the live range length and the interference degree $\\Delta$ of the original $v_a$?\n\nA. If $a$ is rematerialized at the exit, the live range of $v_a$ no longer spans the loop to the exit; it strictly shortens to end after the last in-loop use. Consequently, $v_a$ loses all interferences due to overlap with values outside the loop and cannot gain new ones in the exit, so its interference degree $\\Delta$ weakly decreases and never increases.\n\nB. Rematerializing $a$ at the exit does not affect the live range of $v_a$ because $a$ depends on $i$ updated in the loop; $v_a$ must remain live across the loop to maintain correctness, so $\\Delta$ is unchanged.\n\nC. Rematerializing $a$ at the exit lengthens the live range of $v_a$ because $i$ must be kept live to the exit, increasing the number of simultaneous live values and therefore increasing $\\Delta$ of $v_a$.\n\nD. The benefit depends on $\\text{stride}$: only when $\\text{stride} = 0$ or $\\text{stride} = 1$ can rematerialization shorten the live range; otherwise, the multiplication in $a = \\text{base} + i \\cdot \\text{stride}$ prevents any reduction in $\\Delta$ for $v_a$.", "solution": "The problem asks to characterize how rematerializing a variable `$a$` at a loop exit affects the live range and interference degree of the original virtual register `$v_a$`.\n\n1.  **Analyze the \"Before\" Scenario:** Originally, the virtual register `$v_a$` holds the value of `$a$`. This value is used both inside the loop and once in the exit block. By the definition of liveness, a variable is live if its value might be used in the future. Therefore, to satisfy the use in the exit block, `$v_a$` must remain live from its last update inside the loop, through the loop's termination, and up to the point of use in the exit block. This creates a long live range that spans the entire loop and extends beyond it.\n\n2.  **Analyze the \"After\" Scenario (Rematerialization):** The transformation rematerializes `$a$` in the exit block using a new register `$v_a^{\\text{exit}}$`. This means the original register `$v_a$` is no longer needed after its last use *inside* the loop. Its value is not required in the exit block anymore. Consequently, the live range of `$v_a$` now ends after its final use within the loop body. The portion of the live range that previously extended into the exit block is eliminated. Therefore, the live range of `$v_a$` is strictly shortened.\n\n3.  **Analyze the Impact on the Interference Graph:** The interference degree, `$\\Delta(v_a)$`, is the number of other virtual registers whose live ranges overlap with that of `$v_a$`.\n    *   Since the new live range of `$v_a$` is a strict subset of the old one, it cannot overlap with any new registers it didn't overlap with before. Thus, no new interference edges can be created for `$v_a$`.\n    *   However, existing interference edges can be removed. If another register `$v_x$` was live only in the exit block (and not inside the loop), its live range might have overlapped with the old live range of `$v_a$` but will not overlap with the new, shorter live range. In such a case, the interference between `$v_a$` and `$v_x$` is eliminated, and `$\\Delta(v_a)$` decreases.\n    *   If all registers that interfered with `$v_a$` did so within the loop body, then `$\\Delta(v_a)$` remains unchanged.\n    *   Combining these possibilities, the interference degree of `$v_a$` either decreases or stays the same. It can never increase. This is known as a weak decrease.\n\n4.  **Evaluate the Options:**\n    *   **A:** This option correctly states that the live range of `$v_a$` is shortened, ending after the last in-loop use. It also correctly concludes that this leads to a weak decrease in the interference degree. This aligns perfectly with our analysis.\n    *   **B:** This is incorrect. The purpose of rematerialization is precisely to break the need for `$v_a$` to remain live. Correctness is maintained by recomputing the value.\n    *   **C:** This is incorrect. The live range of `$v_a$` is shortened, not lengthened. While the live range of the input `$i$` might be affected, this doesn't lengthen the live range of `$v_a$`.\n    *   **D:** This is incorrect. The specific arithmetic operation (e.g., multiplication) or the value of `$\\text{stride}$` is irrelevant to the dataflow concept of liveness. The transformation's validity depends on control flow and data dependencies, not the operator itself.\n\nTherefore, statement A provides the best characterization of the effects.", "answer": "$$\\boxed{A}$$", "id": "3668375"}, {"introduction": "The feasibility and cost of rematerialization are not abstract; they are dictated by the capabilities of the target hardware. An instruction that is cheap on one processor might be expensive or even impossible on another. This final problem demonstrates how a specific detail of an Instruction Set Architecture (ISA)—the bit-width of immediate operands—directly influences the rematerialization cost and the ultimate decision made by the compiler [@problem_id:3668304].", "problem": "A compiler for a given Instruction Set Architecture (ISA) must decide whether to rematerialize the value $y = x + 4096$ at each of its use sites instead of spilling and reloading. The ISA provides an add-immediate instruction that accepts a signed immediate of width $w$ bits. If the constant $4096$ does not fit in the $w$-bit signed immediate field, the compiler uses a canonical two-instruction sequence to rematerialize $y$ at a use site. Assume the following cost model: each dynamic instruction contributes an execution cost of $c_{\\text{exec}}$ cycles, and each static instruction contributes a code-size penalty weighted by $k$ cycles per byte, with each instruction having a size of $b$ bytes. If there are $U$ dynamic uses of $y$, define the total rematerialization cost as\n$$\nC_{\\text{rm}}(w) = U \\cdot n(w) \\cdot \\big(c_{\\text{exec}} + k \\cdot b\\big),\n$$\nwhere $n(w)$ is the number of instructions required to rematerialize at a use site under immediate width $w$.\n\nStarting from core definitions, derive the condition on $w$ under which the single add-immediate instruction suffices to encode $x + 4096$, and the complementary condition under which a two-instruction sequence is required. Then, for the specific parameter values $U = 750$, $c_{\\text{exec}} = 1$, $k = 0.01$, and $b = 4$, compute the incremental penalty\n$$\n\\Delta C = C_{\\text{rm}}(13) - C_{\\text{rm}}(14),\n$$\nexpressed in cycles. Provide your final numerical answer. No rounding is required.", "solution": "The problem is first validated to ensure it is self-contained, scientifically grounded, and well-posed. The problem statement provides all necessary definitions, constants, and a clear objective. It is based on standard principles of computer architecture and compiler design, specifically concerning instruction encoding, immediate operands, and performance cost modeling. No scientific or logical flaws are present. Thus, we proceed with the solution.\n\nThe core of the problem lies in determining the number of instructions, $n(w)$, required to materialize the constant $4096$ for a given signed immediate field width of $w$ bits. An add-immediate instruction, `add immediate, Rd, Rs, Imm`, can be used in a single instruction if the constant can be represented by the $w$-bit signed immediate field.\n\nA $w$-bit signed integer, typically represented in two's complement format, can encode values in the range $[ -2^{w-1}, 2^{w-1} - 1 ]$.\nThe value to be materialized is $y = x + 4096$. This requires encoding the constant $4096$ as the immediate operand.\n\nA single instruction is sufficient if and only if the constant $4096$ lies within the representable range of a $w$-bit signed immediate. Since $4096$ is a positive value, this condition simplifies to:\n$$\n4096 \\le 2^{w-1} - 1\n$$\nIf this inequality holds, $n(w) = 1$. If it does not hold, the constant is too large, and the problem states a canonical two-instruction sequence is used, so $n(w) = 2$.\n\nTherefore, we can define $n(w)$ as a piecewise function:\n$$\nn(w) =\n\\begin{cases}\n1  \\text{if } 4096 \\le 2^{w-1} - 1 \\\\\n2  \\text{if } 4096  2^{w-1} - 1\n\\end{cases}\n$$\n\nWe must now evaluate $n(w)$ for the specific cases $w=13$ and $w=14$.\n\nFor $w=13$:\nThe maximum representable signed value is $2^{13-1} - 1 = 2^{12} - 1 = 4096 - 1 = 4095$.\nWe test the condition: $4096 \\le 4095$. This is false.\nThus, for an immediate width of $w=13$ bits, two instructions are required.\n$$\nn(13) = 2\n$$\n\nFor $w=14$:\nThe maximum representable signed value is $2^{14-1} - 1 = 2^{13} - 1 = 8192 - 1 = 8191$.\nWe test the condition: $4096 \\le 8191$. This is true.\nThus, for an immediate width of $w=14$ bits, a single instruction suffices.\n$$\nn(14) = 1\n$$\n\nThe problem asks for the incremental penalty $\\Delta C = C_{\\text{rm}}(13) - C_{\\text{rm}}(14)$. The total rematerialization cost is given by the formula:\n$$\nC_{\\text{rm}}(w) = U \\cdot n(w) \\cdot (c_{\\text{exec}} + k \\cdot b)\n$$\nThe parameter values are given as $U = 750$, $c_{\\text{exec}} = 1$, $k = 0.01$, and $b = 4$.\n\nFirst, let's compute the cost factor per instruction, which is common to both calculations:\n$$\nc_{\\text{exec}} + k \\cdot b = 1 + (0.01) \\cdot 4 = 1 + 0.04 = 1.04\n$$\nThis factor represents the combined execution and code-size cost for a single instruction, measured in cycles.\n\nNow we can compute the costs for $w=13$ and $w=14$.\n$$\nC_{\\text{rm}}(13) = U \\cdot n(13) \\cdot (c_{\\text{exec}} + k \\cdot b) = 750 \\cdot 2 \\cdot (1.04)\n$$\n$$\nC_{\\text{rm}}(14) = U \\cdot n(14) \\cdot (c_{\\text{exec}} + k \\cdot b) = 750 \\cdot 1 \\cdot (1.04)\n$$\n\nFinally, we compute the incremental penalty $\\Delta C$:\n$$\n\\Delta C = C_{\\text{rm}}(13) - C_{\\text{rm}}(14)\n$$\n$$\n\\Delta C = (750 \\cdot 2 \\cdot 1.04) - (750 \\cdot 1 \\cdot 1.04)\n$$\nWe can factor out the common terms:\n$$\n\\Delta C = 750 \\cdot 1.04 \\cdot (2 - 1)\n$$\n$$\n\\Delta C = 750 \\cdot 1.04 \\cdot 1\n$$\n$$\n\\Delta C = 750 \\cdot (1 + 0.04) = 750 \\cdot 1 + 750 \\cdot 0.04\n$$\n$$\n\\Delta C = 750 + 30\n$$\n$$\n\\Delta C = 780\n$$\nThe incremental penalty, in cycles, is $780$. This value represents the total cost savings (in cycles) of having a $14$-bit-wide immediate field compared to a $13$-bit-wide one for this specific rematerialization scenario.", "answer": "$$\\boxed{780}$$", "id": "3668304"}]}