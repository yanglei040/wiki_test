{"hands_on_practices": [{"introduction": "Before building complex digital systems, it's essential to master the fundamentals. This first exercise takes you back to first principles, challenging you to derive the Boolean logic for an unsigned magnitude comparator from scratch. By proving that its outputs ($L$ for less-than, $E$ for equal, and $G$ for greater-than) are one-hot and designing an encoder for an Arithmetic Logic Unit (ALU), you will solidify your understanding of how basic comparison operations form the bedrock of processor datapaths.", "problem": "Consider unsigned integers $A$ and $B$ of equal width $n \\geq 1$, represented in binary as $A = \\sum_{i=0}^{n-1} a_{i} 2^{i}$ and $B = \\sum_{i=0}^{n-1} b_{i} 2^{i}$, where $a_{i}, b_{i} \\in \\{0,1\\}$ denote the bits at position $i$, and bit position $i = n-1$ is the most significant bit. A magnitude comparator produces three one-hot outputs $L$, $E$, and $G$ satisfying $L = 1$ if and only if $A  B$, $E = 1$ if and only if $A = B$, and $G = 1$ if and only if $A  B$, with the requirement that exactly one of $L$, $E$, $G$ equals $1$ for any inputs $A$ and $B$.\n\nStarting only from the definition of unsigned comparison on binary numerals and the positional weight expansion of $A$ and $B$, derive Boolean expressions for $L$, $E$, and $G$ in terms of the input bits $\\{a_{i}\\}$ and $\\{b_{i}\\}$ and prefix-equality conditions, and use these to rigorously establish that the triple $(L,E,G)$ is one-hot for all inputs. Then, design a combinational encoder that maps the one-hot comparator outputs to a signed two’s-complement integer $Z$ of width $m \\geq 2$ such that $Z = -1$ when $L = 1$, $Z = 0$ when $E = 1$, and $Z = +1$ when $G = 1$. This encoder is intended to feed an Arithmetic Logic Unit (ALU) control in an arithmetic datapath where $Z$ serves as the sign of the comparison $A - B$.\n\nProvide your final encoded result for $Z$ as a single closed-form analytic expression in terms of the one-hot signals $L$ and $G$. No numerical rounding is required for this problem.", "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n- Unsigned integers: $A = \\sum_{i=0}^{n-1} a_{i} 2^{i}$ and $B = \\sum_{i=0}^{n-1} b_{i} 2^{i}$.\n- Integer width: $n \\geq 1$.\n- Bits: $a_{i}, b_{i} \\in \\{0,1\\}$.\n- Most Significant Bit (MSB): position $i = n-1$.\n- Comparator outputs: $L$, $E$, $G$.\n- Output definitions: $L = 1 \\iff A  B$, $E = 1 \\iff A = B$, $G = 1 \\iff A  B$.\n- One-hot constraint: Exactly one of $L$, $E$, $G$ equals $1$ for any inputs.\n- Task 1: Derive Boolean expressions for $L$, $E$, and $G$ in terms of $\\{a_i\\}$, $\\{b_i\\}$, and prefix-equality conditions.\n- Task 2: Rigorously establish that the triple $(L,E,G)$ is one-hot.\n- Task 3: Design a combinational encoder mapping $(L,E,G)$ to a signed two’s-complement integer $Z$.\n- Output integer width: $m \\geq 2$.\n- Encoder mapping: $L=1 \\implies Z=-1$; $E=1 \\implies Z=0$; $G=1 \\implies Z=+1$.\n- Final answer format: A single closed-form analytic expression for $Z$ in terms of $L$ and $G$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a standard exercise in digital logic design and computer architecture. It deals with fundamental concepts such as binary number representation, magnitude comparison, one-hot encoding, and two's complement arithmetic. The problem statement is well-posed, objective, and self-contained, providing all necessary definitions and constraints. It asks for a derivation and proof based on first principles, which is a valid and meaningful task. The constraints $n \\ge 1$ and $m \\ge 2$ are appropriate and do not introduce any contradictions or infeasibilities. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe solution is developed in three parts as requested: derivation of the comparator logic, proof of the one-hot property, and design of the output encoder.\n\n#### Part 1: Derivation of Comparator Outputs $L$, $E$, and $G$\n\nThe comparison of two unsigned integers $A$ and $B$ proceeds by comparing their bits from the most significant bit (MSB) at position $n-1$ down to the least significant bit (LSB) at position $0$.\n\nFirst, we define bit-level comparison signals for each position $i \\in \\{0, 1, \\dots, n-1\\}$:\n- Bit equality: $e_i = 1$ if $a_i = b_i$. The Boolean expression is $e_i = \\overline{a_i \\oplus b_i}$.\n- Bit greater-than: $g_i = 1$ if $a_i  b_i$. This occurs only if $a_i=1$ and $b_i=0$, so $g_i = a_i \\land \\overline{b_i}$.\n- Bit less-than: $l_i = 1$ if $a_i  b_i$. This occurs only if $a_i=0$ and $b_i=1$, so $l_i = \\overline{a_i} \\land b_i$.\nNote that for any given $i$, exactly one of $e_i$, $g_i$, or $l_i$ can be $1$.\n\nThe condition for overall equality, $A=B$, is that all corresponding bits are equal. This gives the expression for $E$:\n$$E = \\bigwedge_{i=0}^{n-1} e_i = e_{n-1} \\land e_{n-2} \\land \\dots \\land e_0$$\n\nThe condition for $AB$ is that there exists a bit position $k$ where $a_k  b_k$, and for all more significant bits $j  k$, the bits are equal ($a_j = b_j$). This can be formulated by summing contributions from each bit position. A bit position $i$ determines the outcome $AB$ if $a_ib_i$ and all higher bits are equal. We define the prefix-equality condition $P_i$ as the logical AND of bit equalities for all positions more significant than $i$:\n$$P_i = \\bigwedge_{j=i+1}^{n-1} e_j$$\nFor the MSB at $i=n-1$, the set of indices $j  n-1$ is empty, so $P_{n-1}$ is an empty product, which evaluates to logical true ($1$).\n\nUsing this, the expression for $G$ (for $AB$) is the disjunction of conditions where each bit position $i$ is the most significant one establishing the inequality:\n$$G = \\bigvee_{i=0}^{n-1} (P_i \\land g_i)$$\nLet's write it out:\n$$G = g_{n-1} \\lor (e_{n-1} \\land g_{n-2}) \\lor (e_{n-1} \\land e_{n-2} \\land g_{n-3}) \\lor \\dots \\lor \\left(\\left(\\bigwedge_{j=1}^{n-1}e_j\\right) \\land g_0\\right)$$\nSimilarly, the expression for $L$ (for $AB$) is:\n$$L = \\bigvee_{i=0}^{n-1} (P_i \\land l_i) = l_{n-1} \\lor (e_{n-1} \\land l_{n-2}) \\lor \\dots \\lor \\left(\\left(\\bigwedge_{j=1}^{n-1}e_j\\right) \\land l_0\\right)$$\n\n#### Part 2: Proof of the One-Hot Property\nWe must show that for any given inputs $A$ and $B$, exactly one of $L$, $E$, $G$ is $1$. This involves two sub-proofs: mutual exclusion (at most one is $1$) and exhaustion (at least one is $1$).\n\n**Mutual Exclusion:**\n- $E \\land G$: If $E=1$, then $e_i = 1$ for all $i$. This implies $g_i = a_i \\land \\overline{b_i} = 0$ for all $i$ (since $e_i=1 \\implies a_i=b_i$). The expression for $G$ is a disjunction of terms, all of which contain a $g_i$ factor. Thus, if all $g_i=0$, then $G=0$. So, $E \\land G = 0$.\n- $E \\land L$: By a symmetric argument, if $E=1$, all $l_i=0$, which implies $L=0$. So, $E \\land L = 0$.\n- $L \\land G$: Assume $G=1$. This means there exists some bit position $k$ which is the most significant position where the bits differ, and at this position, $a_kb_k$. Formally, there exists a $k \\in \\{0, \\dots, n-1\\}$ such that $g_k=1$ and $e_j=1$ for all $jk$. The condition $g_k=1$ implies $e_k=0$ and $l_k=0$.\n  - For any term in the expression for $L$ at an index $ik$, the term $P_i \\land l_i$ is $0$ because $l_i=0$ (since $e_i=1$ for $ik$).\n  - The term in the expression for $L$ at index $i=k$ is $P_k \\land l_k$. Since $l_k=0$, this term is $0$.\n  - For any term in the expression for $L$ at an index $ik$, the prefix equality $P_i = \\bigwedge_{j=i+1}^{n-1} e_j$ contains the factor $e_k$. Since $e_k=0$, $P_i=0$. Thus, these terms are all $0$.\n  - Since all terms in the disjunction for $L$ are $0$, $L=0$. Therefore, if $G=1$, then $L=0$. This proves $L \\land G = 0$.\n\n**Exhaustion ($L \\lor E \\lor G = 1$):**\nWe analyze all possible relationships between the bit strings for $A$ and $B$.\n- Case 1: All bits are identical. $a_i = b_i$ for all $i \\in \\{0, \\dots, n-1\\}$. In this case, $e_i=1$ for all $i$, so $E = \\bigwedge e_i = 1$. Since $a_i=b_i$, both $g_i=0$ and $l_i=0$ for all $i$. This makes $G=0$ and $L=0$. The result is $(L,E,G) = (0,1,0)$, and $L \\lor E \\lor G = 1$.\n- Case 2: The bits are not all identical. Let $k$ be the index of the most significant bit where $a_k \\neq b_k$. By definition of $k$, for all $jk$, $a_j=b_j$, which means $e_j=1$. This implies the prefix equality $P_k = \\bigwedge_{j=k+1}^{n-1} e_j = 1$.\n  - Subcase 2a: $a_k  b_k$. This means $a_k=1, b_k=0$, so $g_k=1$ and $l_k=0$. The $k$-th term in the expression for $G$ is $P_k \\land g_k = 1 \\land 1 = 1$. Thus, $G=1$. Since $k$ is the most significant differing bit, $L$ must be $0$ (by the mutual exclusion argument for $L \\land G$). Since $a_k \\neq b_k$, $e_k=0$, which makes $E = \\bigwedge e_i = 0$. The result is $(L,E,G)=(0,0,1)$, and $L \\lor E \\lor G = 1$.\n  - Subcase 2b: $a_k  b_k$. This means $a_k=0, b_k=1$, so $g_k=0$ and $l_k=1$. The $k$-th term in the expression for $L$ is $P_k \\land l_k = 1 \\land 1 = 1$. Thus, $L=1$. By symmetry, $G=0$ and $E=0$. The result is $(L,E,G)=(1,0,0)$, and $L \\lor E \\lor G = 1$.\n\nSince these cases cover all possibilities, we have rigorously established that for any inputs $A$ and $B$, exactly one of $L,E,G$ is equal to $1$.\n\n#### Part 3: Encoder Design\nThe task is to design a combinational circuit that maps the one-hot signals $(L,E,G)$ to a signed two's-complement integer $Z$ of width $m \\ge 2$, according to the rules:\n- if $(L,E,G)=(1,0,0)$, then $Z=-1$.\n- if $(L,E,G)=(0,1,0)$, then $Z=0$.\n- if $(L,E,G)=(0,0,1)$, then $Z=+1$.\n\nLet $Z$ be represented by the $m$-bit vector $(z_{m-1}, z_{m-2}, \\dots, z_0)$, where $z_{m-1}$ is the sign bit. The two's complement values are:\n- $Z=+1$: $(0,0,\\dots,0,1)_2$.\n- $Z=0$: $(0,0,\\dots,0,0)_2$.\n- $Z=-1$: $(1,1,\\dots,1,1)_2$.\n\nFrom this mapping, we can derive the logic for each bit $z_i$ in terms of $L, E, G$. Since the inputs are one-hot, we can simplify the expressions.\n- For the LSB, $z_0$: $z_0=1$ if $AB$ (for $Z=-1$) or if $AB$ (for $Z=+1$). So, $z_0 = L \\lor G$.\n- For any other bit, $z_i$ where $i \\in \\{1, 2, \\dots, m-1\\}$: $z_i=1$ only if $AB$ (for $Z=-1$). So, $z_i = L$ for $1 \\le i \\le m-1$.\n\nThe value of an $m$-bit two's-complement number is given by the formula:\n$$Z = -z_{m-1} 2^{m-1} + \\sum_{i=0}^{m-2} z_i 2^{i}$$\nSubstituting our expressions for the bits $z_i$:\n$z_{m-1}=L$\n$\\sum_{i=0}^{m-2} z_i 2^{i} = z_0 2^0 + \\sum_{i=1}^{m-2} z_i 2^i = (L \\lor G) + \\sum_{i=1}^{m-2} L \\cdot 2^i$\n\nSince $L$ and $G$ are mutually exclusive ($L \\land G = 0$), their logical OR, $L \\lor G$, is equivalent to arithmetic addition, $L+G$, when $L,G$ are treated as integers $\\{0,1\\}$.\nThe sum is a geometric series: $\\sum_{i=1}^{m-2} 2^i = (2^{m-1}-2)/(2-1) = 2^{m-1}-2$ for $m \\ge 3$. If $m=2$, the sum is empty and equals $0$. Let's analyze both cases.\nCase $m \\ge 3$:\n$\\sum_{i=0}^{m-2} z_i 2^{i} = (L+G) + L(2^{m-1}-2) = L+G+L \\cdot 2^{m-1}-2L = G-L+L \\cdot 2^{m-1}$\n$Z = -z_{m-1} 2^{m-1} + \\sum_{i=0}^{m-2} z_i 2^{i} = -L \\cdot 2^{m-1} + (G-L+L \\cdot 2^{m-1}) = G-L$.\nCase $m=2$:\n$z_1=L$, $z_0=L+G$.\n$Z = -z_1 \\cdot 2^1 + z_0 \\cdot 2^0 = -L \\cdot 2 + (L+G) = -2L+L+G = G-L$.\n\nThe resulting analytic expression is independent of the width $m$ (for $m \\ge 2$) and is remarkably simple. We can verify it:\n- If $(L,G)=(1,0)$: $Z = 0 - 1 = -1$. Correct.\n- If $(L,G)=(0,0)$ (which implies $E=1$): $Z = 0-0=0$. Correct.\n- If $(L,G)=(0,1)$: $Z = 1-0 = 1$. Correct.\n\nThe desired closed-form expression for $Z$ is therefore $G-L$.", "answer": "$$\n\\boxed{G - L}\n$$", "id": "3655742"}, {"introduction": "The theoretical elegance of a number system has direct consequences on the complexity of the hardware required to implement it. This practice problem moves beyond simple unsigned integers to explore the nuances of sign-magnitude representation. Your task is to design an equality comparator that correctly handles the unique challenge of this format: the existence of two distinct bit patterns for zero ($+0$ and $-0$), a complication not found in the more common two's complement system.", "problem": "Consider fixed-width integer encodings used in computer organization and architecture, and the problem of deciding equality with a magnitude comparator. In sign-magnitude representation, an $n$-bit word encodes a signed integer using a single sign bit and a $(n-1)$-bit magnitude. Let $A$ and $B$ be two $n$-bit words in sign-magnitude representation, with $A$ having sign bit $s_{A} \\in \\{0,1\\}$ and magnitude bits $\\{a_{i}\\}_{i=0}^{n-2}$, and $B$ having sign bit $s_{B} \\in \\{0,1\\}$ and magnitude bits $\\{b_{i}\\}_{i=0}^{n-2}$. Let $n \\geq 2$. The encoded mathematical value of $A$ is given by the mapping $v(A) = (-1)^{s_{A}} \\cdot \\sum_{i=0}^{n-2} a_{i} 2^{i}$, and $v(B) = (-1)^{s_{B}} \\cdot \\sum_{i=0}^{n-2} b_{i} 2^{i}$. In two’s complement representation, equality is decided by exact bitwise equality, and there is only one encoding for zero. In sign-magnitude, there are two encodings for zero, $+0$ and $-0$, which correspond to $s=0$ and $s=1$ with all magnitude bits zero. By the semantics of integers, these two encodings are equal in value even though their bit patterns differ.\n\nStarting from the definitions above and first principles, derive a Boolean output expression for the equality decision $E_{\\mathrm{sm}}(A,B)$ that is true if and only if $v(A)=v(B)$ under sign-magnitude semantics, with the explicit requirement that $+0$ and $-0$ be treated as equal. Your expression must be written using only the logical connectives $\\land$, $\\lor$, $\\neg$, and $\\oplus$ (exclusive-or), applied to the bit variables $s_{A}$, $s_{B}$, $\\{a_{i}\\}$, and $\\{b_{i}\\}$. Use standard finite conjunction and disjunction notation, such as $\\bigwedge_{i=0}^{n-2}(\\cdot)$ and $\\bigvee_{i=0}^{n-2}(\\cdot)$, where appropriate. \n\nIn your derivation, explicitly enumerate and justify the differences between equality in sign-magnitude and two’s complement representations that affect the comparator logic, focusing on the multiplicity of zero encodings and the conditions under which sign bits and magnitude bits must be compared.\n\nProvide your final equality expression in closed form. No numerical evaluation or rounding is required. The final answer must be a single analytic expression.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computer arithmetic, well-posed with clear definitions and a specific goal, and expressed in objective language. It is self-contained and free of contradictions. I will now proceed with a full derivation.\n\nThe problem requires the derivation of a Boolean expression, $E_{\\mathrm{sm}}(A,B)$, that evaluates to true if and only if two $n$-bit numbers, $A$ and $B$, in sign-magnitude representation have the same mathematical value. The value of an $n$-bit word $X$ with sign bit $s_X$ and magnitude bits $\\{x_i\\}_{i=0}^{n-2}$ is given by $v(X) = (-1)^{s_X} \\cdot M(X)$, where the magnitude $M(X)$ is the unsigned integer $M(X) = \\sum_{i=0}^{n-2} x_i 2^i$.\n\nThe condition for equality is $v(A) = v(B)$. Substituting the definitions, we have:\n$$\n(-1)^{s_A} \\cdot M(A) = (-1)^{s_B} \\cdot M(B)\n$$\nSince magnitudes $M(A)$ and $M(B)$ are, by definition, non-negative, a necessary (but not sufficient) condition for the equality to hold is that the absolute values must be equal. The absolute value of $v(X)$ is simply $M(X)$. Thus, we must have $M(A) = M(B)$.\nThe magnitude of an integer in sign-magnitude representation is given by an unsigned binary number. For two unsigned binary numbers to be equal, they must be bitwise identical. This gives us our first logical condition: the magnitude bits of $A$ and $B$ must be identical.\n$$\na_i = b_i \\quad \\forall i \\in \\{0, 1, \\dots, n-2\\}\n$$\nIn Boolean logic, the equality of two bits $p$ and $q$ can be expressed as $\\neg(p \\oplus q)$. Therefore, the condition for equal magnitudes, let us call it $E_{\\mathrm{mag}}$, is the conjunction of the equality of all corresponding magnitude bits:\n$$\nE_{\\mathrm{mag}} = \\bigwedge_{i=0}^{n-2} \\neg(a_i \\oplus b_i)\n$$\nIf this condition $E_{\\mathrm{mag}}$ is false, then $M(A) \\neq M(B)$, and the numbers cannot be equal (unless both are zero, but different magnitude bit patterns for non-zero values mean $M(A) \\ne M(B)$). The case of one being zero and the other non-zero is also captured: if $M(A)=0$ and $M(B) \\ne 0$, then $E_{\\mathrm{mag}}$ is false. Therefore, $E_{\\mathrm{mag}}$ is a necessary condition for equality.\n\nNow, assuming $E_{\\mathrm{mag}}$ is true (i.e., $M(A) = M(B)$), our original equation simplifies to:\n$$\n(-1)^{s_A} \\cdot M(A) = (-1)^{s_B} \\cdot M(A)\n$$\nWe analyze this equation based on the value of $M(A)$:\nCase 1: The magnitude is zero, $M(A)=0$.\nThis occurs if and only if all magnitude bits are zero: $a_i = 0$ for all $i \\in \\{0, 1, \\dots, n-2\\}$. In this case, the equation becomes $0=0$, which is always true, regardless of the sign bits $s_A$ and $s_B$. This is the formal basis for the rule that $+0$ and $-0$ are equal. The Boolean condition for $A$ to be zero, let's call it $Z_A$, is:\n$$\nZ_A = \\bigwedge_{i=0}^{n-2} \\neg a_i\n$$\n\nCase 2: The magnitude is non-zero, $M(A)  0$.\nIn this case, we can divide both sides of the equation by $M(A)$, which yields:\n$$\n(-1)^{s_A} = (-1)^{s_B}\n$$\nThis implies that the sign bits must be identical, $s_A = s_B$. The Boolean expression for the equality of sign bits, let us call it $E_{\\mathrm{sign}}$, is:\n$$\nE_{\\mathrm{sign}} = \\neg(s_A \\oplus s_B)\n$$\n\nCombining these points, for two numbers $A$ and $B$ to be equal, their magnitudes must first be equal ($E_{\\mathrm{mag}}$ must be true). If their magnitudes are equal, then we must further satisfy the condition derived from the signs. This condition is: either the signs are equal ($E_{\\mathrm{sign}}$ is true), OR the magnitude is zero ($Z_A$ is true). Note that since we are in the context where $M(A)=M(B)$, the condition $Z_A$ is equivalent to the condition that $M(B)=0$.\n\nThus, the complete logical expression for equality $E_{\\mathrm{sm}}(A,B)$ is that the magnitudes must be equal, AND (the signs are equal OR the magnitude is zero).\n$$\nE_{\\mathrm{sm}}(A,B) = E_{\\mathrm{mag}} \\land (E_{\\mathrm{sign}} \\lor Z_A)\n$$\nSubstituting the Boolean expressions for each part gives the final closed-form expression:\n$$\nE_{\\mathrm{sm}}(A,B) = \\left( \\bigwedge_{i=0}^{n-2} \\neg(a_i \\oplus b_i) \\right) \\land \\left( \\neg(s_A \\oplus s_B) \\lor \\left( \\bigwedge_{j=0}^{n-2} \\neg a_j \\right) \\right)\n$$\nNote the use of index $j$ in the second inner conjunction is for clarity; it iterates over the same set $\\{0, 1, \\dots, n-2\\}$.\n\nAs required, we juxtapose this with equality in two's complement representation. The fundamental difference lies in the encoding of zero.\n1.  **Uniqueness of Zero**: Two's complement has a single, unique representation for the integer zero (all bits are $0$). Sign-magnitude has two representations for zero: $+0$ (sign bit $0$, all magnitude bits $0$) and $-0$ (sign bit $1$, all magnitude bits $0$).\n2.  **Comparator Logic**: Due to the unique encoding for every value in a two's complement system, checking for value equality $v(A) = v(B)$ is equivalent to checking for bitwise identity of the entire $n$-bit words. The comparator logic is a simple bitwise XNOR across all $n$ bits. In Boolean form, $E_{\\mathrm{2C}}(A,B) = \\bigwedge_{k=0}^{n-1} \\neg(A_k \\oplus B_k)$. This simplicity and efficiency is a significant advantage of two's complement.\n3.  **Complexity**: The non-unique representation of zero in sign-magnitude forces the comparator logic to be more complex. It cannot rely on simple bitwise identity. It must incorporate a special case, as derived above: either the bit patterns are identical, or both numbers represent zero. This leads to the more complex logical expression for $E_{\\mathrm{sm}}(A,B)$, which requires more hardware (gates) to implement than a two's complement comparator. This demonstrates how a choice of number representation directly impacts the complexity of the arithmetic logic unit (ALU) in a processor.\n\nThe derived expression correctly and completely formalizes the equality condition under sign-magnitude semantics.", "answer": "$$\n\\boxed{\n\\left( \\bigwedge_{i=0}^{n-2} \\neg(a_i \\oplus b_i) \\right) \\land \\left( \\neg(s_A \\oplus s_B) \\lor \\left( \\bigwedge_{j=0}^{n-2} \\neg a_j \\right) \\right)\n}\n$$", "id": "3655770"}, {"introduction": "In modern high-performance processors, speed is everything, and naive designs do not scale. This advanced problem tackles the critical challenge of building a large, 64-bit comparator without suffering a crippling propagation delay. You will analyze a hierarchical design that uses borrow-lookahead logic and a prefix network, learning how architects create fast arithmetic units by calculating results in parallel rather than in a slow serial chain.", "problem": "An unsigned magnitude comparator for $64$-bit operands $A$ and $B$ is built hierarchically from identical $4$-bit modules that implement borrow-lookahead comparison. At the bit level, for each position $i$, define the bitwise borrow-generate and borrow-propagate signals by $g_i = \\overline{a_i} \\land b_i$ and $p_i = \\overline{a_i} \\lor b_i$, and define the borrow recurrence $b_{i+1} = g_i \\lor (p_i \\land b_i)$ with initial borrow $b_0 = 0$. Each $4$-bit module $j \\in \\{0,1,\\dots,15\\}$ consumes the slice $a_{4j+3:4j}$ and $b_{4j+3:4j}$ and outputs a group-borrow-generate $G_j$ and group-borrow-propagate $P_j$ such that the block-level borrow across the module obeys $b_{j+1} = G_j \\lor (P_j \\land b_j)$. The $16$ modules are combined at the top level by a balanced binary prefix network over the associative pairwise-combine operator $\\circ$ defined for pairs by $(G,P)\\circ(G',P') = \\big(G' \\lor (P' \\land G),\\, P' \\land P\\big)$. The final decision bit $L$ that indicates $AB$ equals the most significant borrow-out and is obtained as the $G$ component of the prefix reduction over all $16$ modules, followed by a final output mapping stage.\n\nAssume the following timing model.\n- Every $4$-bit module produces its group-borrow-generate $G_j$ after a time $t_G$ and its group-borrow-propagate $P_j$ after a time $t_P$, both measured from the stabilization of its $4$-bit inputs. \n- Each prefix-combine node that computes $(G,P)\\circ(G',P')$ from its two input pairs incurs a delay $t_{\\circ}$ to produce both outputs, measured from the arrival of the later of its two inputs. \n- The final mapping from the top-level prefix $G$ to the decision bit $L$ incurs an additional delay $t_o$.\n- All primary inputs of $A$ and $B$ arrive simultaneously at time $0$, wire delays are negligible, and there is no retiming between stages.\n\nFor the specific input class in which $A$ and $B$ differ only in the least significant bit (that is, $a_i = b_i$ for all $i \\ge 1$ and $a_0 \\ne b_0$), express the critical-path delay $T_{cp}$ from the primary inputs to the decision output $L$ as a closed-form analytic function of $t_G$, $t_P$, $t_{\\circ}$, and $t_o$. The answer must be a single analytic expression. No rounding is required and no units are necessary.", "solution": "The unsigned magnitude comparison $AB$ can be determined by the most significant borrow-out when subtracting $B$ from $A$ with zero initial borrow. At the bit level, the standard and widely used borrow-lookahead identities are\n$$\ng_i = \\overline{a_i}\\land b_i,\\quad p_i = \\overline{a_i}\\lor b_i,\\quad b_{i+1} = g_i \\lor (p_i \\land b_i),\\quad b_0=0.\n$$\nThese follow from the truth table of a full subtractor: a borrow is generated at position $i$ exactly when $a_i=0$ and $b_i=1$, and a borrow is propagated when either $a_i=0$ or $b_i=1$. From these bit-level identities, a $4$-bit group spanning bits $4j$ through $4j+3$ admits group-borrow-generate $G_j$ and group-borrow-propagate $P_j$ such that\n$$\nb_{j+1} = G_j \\lor (P_j \\land b_j),\n$$\nwith $P_j$ true if and only if every bit in the group would propagate an incoming borrow, and $G_j$ true if and only if some bit in the group generates a borrow not masked by more significant propagations. The pairwise-combine operator for adjacent groups is associative:\n$$\n(G,P)\\circ(G',P') = \\big(G' \\lor (P' \\land G),\\, P' \\land P\\big),\n$$\nbecause if $b_{\\mathrm{mid}} = G \\lor (P \\land b_{\\mathrm{in}})$ and $b_{\\mathrm{out}} = G' \\lor (P' \\land b_{\\mathrm{mid}})$, then substitution yields\n$$\nb_{\\mathrm{out}} = \\big(G' \\lor (P' \\land G)\\big) \\lor \\big(P'\\land P \\land b_{\\mathrm{in}}\\big),\n$$\nwhich has the same form with combined pair $\\big(G' \\lor (P' \\land G),\\, P'\\land P\\big)$. Therefore, a prefix reduction over $16$ groups using $\\circ$ computes the overall $G$ that equals the most significant borrow-out. The final decision $L$ is then the overall $G$ after a final output mapping.\n\nGiven the timing model:\n- Each module $j$ presents $G_j$ at time $t_G$ and $P_j$ at time $t_P$.\n- Each prefix-combine node adds $t_{\\circ}$ from the latest arriving of its two input pairs.\n- The final mapping adds $t_o$.\n\nWe now analyze the stated input class: $A$ and $B$ differ only at the least significant bit, so $a_i=b_i$ for all $i\\ge 1$. At any bit position $i\\ge 1$, equality implies either $(a_i,b_i)=(0,0)$ or $(1,1)$, and in either case $g_i=\\overline{a_i}\\land b_i = 0$ and $p_i=\\overline{a_i}\\lor b_i = 1$. Consequently, for every module $j\\ge 1$, the group-borrow-generate and group-borrow-propagate evaluate to\n$$\nG_j = 0,\\quad P_j = 1.\n$$\nFor module $j=0$, which contains the least significant bit, the group-borrow-generate $G_0$ equals the contribution of the least significant bit guarded by propagations from the three more significant bits of that module. Under the given input class, those three more significant bits in module $0$ are equal across $A$ and $B$, so they contribute propagate-only behavior. Therefore, the only nontrivial generate in the system is $G_0$, while all higher modules satisfy $G_j=0$ and $P_j=1$.\n\nThe top-level balanced prefix network over $16$ modules has $\\lceil \\log_2(16)\\rceil = 4$ levels. Along the sensitized data path for this input class, $G_0$ must be successively gated through the chain of higher-level propagations. At the first prefix level, the combine node that merges module $0$ with module $1$ must wait for both $G_0$ and $P_1$ to be valid, because its $G$ output takes the form $G_1^{\\mathrm{prefix}} = G_1 \\lor (P_1 \\land G_0)$ and, under the input class, $G_1=0$ while $P_1=1$. Thus, the earliest time the first-level $G$ can be produced is\n$$\n\\max\\{t_G,\\, t_P\\} + t_{\\circ}.\n$$\nSubsequent prefix levels each add one more $t_{\\circ}$, because each combine node at those levels uses one input pair whose $G$ component originated at the previous level and another input pair whose $P$ component is a constant $1$ from a higher module; however, regardless of the constant logic value, the node output cannot be valid until both inputs have arrived, and by assumption both inputs arrive no earlier than time $t_P$ from their respective modules for the $P$ side and no earlier than the previous combine completion time for the $G$ side. Since the $G$ side strictly dominates beyond the first level, each of the remaining $3$ levels adds exactly $t_{\\circ}$ to the arrival time.\n\nFinally, the decision bit $L$ is produced by the output mapping in an additional $t_o$ after the topmost prefix $G$ has stabilized. Summing these contributions yields the critical-path delay\n$$\nT_{cp} = \\max\\{t_G,\\, t_P\\} + 4\\,t_{\\circ} + t_o.\n$$\nThis expression captures the need to wait for the slower of the initial generate and propagate signals before the first prefix-combine, the four balanced prefix levels across the $16$ modules, and the final output mapping.", "answer": "$$\\boxed{\\max\\{t_G,\\, t_P\\} + 4\\,t_{\\circ} + t_o}$$", "id": "3655806"}]}