{"hands_on_practices": [{"introduction": "One of the most fundamental applications of shift registers is to perform fast and efficient multiplication and division by powers of two, operations that are at the heart of any processor's arithmetic logic unit. However, the correctness of these operations for signed numbers depends critically on the type of shift performed. This practice challenges you to explore the crucial difference between a logical shift and an arithmetic shift, especially within the context of two's complement representation, and to quantify the precise error that results from using the wrong one [@problem_id:3675923]. Mastering this distinction is essential for understanding and designing correct computer arithmetic circuits.", "problem": "An $n$-bit right shift register is built from $n$ edge-triggered $D$ flip-flops with a single global clock, and each stage has a $2$-to-$1$ multiplexer to select its input. The register supports two modes: logical right shift and arithmetic right shift. In logical right shift mode, vacated high-order bit positions are filled with $0$. In arithmetic right shift mode, vacated high-order bit positions are filled with the sign bit so that two’s complement signed numbers keep their sign after shifting. The Most Significant Bit (MSB) is defined as the highest-order bit, and two’s complement signed integers use the MSB as the sign bit.\n\nUsing only the core facts that (i) a two’s complement $n$-bit negative integer $x$ has an unsigned encoding equal to $2^{n} + x$, (ii) a right shift by $k$ bits on an unsigned quantity implements division by $2^{k}$ with truncation toward zero (equivalently, the floor for nonnegative values), and (iii) replicating the MSB during arithmetic right shift implements division by $2^{k}$ on signed two’s complement integers with truncation toward negative infinity, answer the following:\n\n1. Briefly justify how an arithmetic right shift register can be realized with the described hardware so that each clock-cycle right shift preserves the MSB in all newly vacated positions, while a logical right shift fills those positions with $0$, without altering the basic flip-flop and multiplexer structure.\n\n2. Consider performing signed division by $2^{k}$ by applying $k$ successive arithmetic right shifts to an $n$-bit two’s complement input $x$, where $1 \\leq k \\leq n-1$. Suppose a design bug causes the register to use logical right shift for these $k$ cycles, and the resulting bit pattern is then interpreted as a signed two’s complement integer. Over all possible negative inputs $x$ in the $n$-bit two’s complement range, determine the worst-case absolute error (the maximum possible absolute difference) between the correct arithmetic right-shift result and the incorrect logical right-shift result, as a closed-form expression in $n$ and $k$.\n\nProvide your final answer as a single analytic expression. No numerical rounding is required.", "solution": "The problem consists of two parts. The first part requires a justification for the hardware implementation of a shift register capable of both logical and arithmetic right shifts. The second part requires the calculation of the worst-case absolute error when a logical right shift is performed instead of an arithmetic right shift on a negative number.\n\n**Part 1: Hardware Realization**\nAn $n$-bit right shift register is composed of $n$ series-connected flip-flops, which we can label $FF_{n-1}, FF_{n-2}, \\dots, FF_{0}$, where $FF_{n-1}$ stores the Most Significant Bit (MSB) and $FF_{0}$ stores the Least Significant Bit (LSB). For a right shift operation, the data input to each flip-flop $FF_{i}$ (for $i < n-1$) is connected to the output of the adjacent higher-order flip-flop, $FF_{i+1}$.\n\nThe distinction between a logical right shift and an arithmetic right shift is determined by the value shifted into the MSB position, which is the input to the first flip-flop, $FF_{n-1}$.\n- In a logical right shift, the vacated MSB position is filled with a $0$.\n- In an arithmetic right shift, the vacated MSB position is filled with the value of the current sign bit, which is the current MSB itself. This preserves the sign of the number.\n\nThe problem states that each stage has a $2$-to-$1$ multiplexer. This hardware element is key to selecting the input for the MSB flip-flop, $FF_{n-1}$, based on the desired mode of operation. Let the two data inputs to the multiplexer at the MSB stage be $I_0$ and $I_1$, and let its control input be $S$.\n1. To implement a logical right shift, we need to feed a $0$ into $FF_{n-1}$. We can achieve this by connecting one of the multiplexer's inputs to a constant logic $0$. Let's set $I_0 = 0$.\n2. To implement an arithmetic right shift, we need to feed the current sign bit back into $FF_{n-1}$. The current sign bit is stored in and available at the output of $FF_{n-1}$, let's call it $Q_{n-1}$. Thus, we connect the other multiplexer input to this output: $I_1 = Q_{n-1}$.\n\nThe control signal $S$ acts as a mode selector.\n- If $S=0$ is asserted (e.g., for logical shift mode), the multiplexer selects input $I_0$, so the input to $FF_{n-1}$ is $0$.\n- If $S=1$ is asserted (e.g., for arithmetic shift mode), the multiplexer selects input $I_1$, so the input to $FF_{n-1}$ is its own previous output, $Q_{n-1}$.\n\nIn this configuration, the single control line $S$ globally determines the type of shift performed by the register on each clock cycle, using the described flip-flop and multiplexer structure without alteration. For all other stages $i \\in \\{0, 1, \\dots, n-2\\}$, the input to $FF_i$ is simply the output of $FF_{i+1}$, which is a common connection for both shift types.\n\n**Part 2: Worst-Case Error Calculation**\nWe are asked to find the worst-case absolute error between the result of a correct arithmetic right shift and an incorrect logical right shift by $k$ bits on an $n$-bit negative two's complement integer $x$. The shift amount $k$ is constrained by $1 \\le k \\le n-1$.\n\nLet $x$ be an $n$-bit negative two's complement integer. Its value lies in the range $[-2^{n-1}, -1]$. Because $x$ is negative, its MSB is $1$.\n\nLet $R_{ARS}$ be the correct result from performing a $k$-bit arithmetic right shift on $x$.\nAccording to fact (iii) provided in the problem statement, an arithmetic right shift by $k$ on a signed integer $x$ implements division by $2^k$ with truncation toward negative infinity (the floor function).\n$$R_{ARS} = \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor$$\n\nLet $R_{LRS}$ be the incorrect result obtained by performing a $k$-bit logical right shift and then interpreting the resulting bit pattern as a signed two's complement integer.\nThe process begins with the bit pattern of $x$. Let $U(x)$ be the unsigned integer value of this bit pattern. According to fact (i), for a negative integer $x$, this unsigned encoding is given by:\n$$U(x) = 2^n + x$$\nA logical right shift by $k$ bits is performed on this bit pattern. Let the resulting bit pattern have an unsigned value of $U_{new}$. According to fact (ii), this operation is equivalent to an unsigned integer division by $2^k$ with truncation (floor).\n$$U_{new} = \\left\\lfloor \\frac{U(x)}{2^k} \\right\\rfloor$$\nSubstituting the expression for $U(x)$:\n$$U_{new} = \\left\\lfloor \\frac{2^n + x}{2^k} \\right\\rfloor = \\left\\lfloor 2^{n-k} + \\frac{x}{2^k} \\right\\rfloor$$\nSince the problem specifies $1 \\le k \\le n-1$, the term $n-k$ is an integer greater than or equal to $1$. Therefore, $2^{n-k}$ is an integer. We can pull this integer term out of the floor function:\n$$U_{new} = 2^{n-k} + \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor$$\nThe problem states that this resulting bit pattern is then interpreted as a signed two's complement integer. A logical right shift fills the $k$ most significant vacated bit positions with $0$. Since $k \\ge 1$, the new MSB of the resulting bit pattern is guaranteed to be $0$. For an $n$-bit two's complement representation, if the MSB is $0$, the number is non-negative, and its signed value is identical to its unsigned value.\nTherefore, the value of the incorrect result, $R_{LRS}$, is equal to $U_{new}$:\n$$R_{LRS} = 2^{n-k} + \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor$$\nThe error, which is the difference between the incorrect result and the correct result, is:\n$$Error = R_{LRS} - R_{ARS} = \\left(2^{n-k} + \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor\\right) - \\left\\lfloor \\frac{x}{2^k} \\right\\rfloor = 2^{n-k}$$\nThe absolute error is the absolute value of this difference:\n$$|Error| = |2^{n-k}| = 2^{n-k}$$\nThis result for the absolute error, $2^{n-k}$, depends only on $n$ and $k$, and is constant for all negative input values of $x$. The problem asks for the worst-case (maximum) absolute error over all possible negative inputs $x$. Since the error is constant for all such $x$, the maximum absolute error is simply this constant value.\n\nThus, the worst-case absolute error is $2^{n-k}$.", "answer": "$$\\boxed{2^{n-k}}$$", "id": "3675923"}, {"introduction": "Moving beyond pure arithmetic, shift registers are versatile components for sequencing and control in larger digital systems. A classic example is the ring counter, a circular shift register, which can be used to select one of many channels in a repeating cycle. This hands-on problem places you in the role of a system designer tasked with creating an LED-based music sequencer [@problem_id:3675857]. Your goal is to determine the minimum clock frequency for the display controller by synthesizing constraints from two very different domains: the human visual system's threshold for flicker and the timing requirements of a musical tempo.", "problem": "A circular array of $16$ light-emitting diodes (LEDs) is driven by a $16$-stage ring counter that acts as a $1$-of-$16$ selector for time-multiplexed display. A $16$-bit pattern register stores a binary word $P = p_{15} p_{14} \\dots p_{1} p_{0}$, with $p_{i} \\in \\{0,1\\}$. The ring counter advances by one state on each pulse of a scan clock of frequency $f_{\\mathrm{scan}}$, and at ring state $i$ the selector enables LED $i$; the LED current driver is gated by $p_{i}$, so LED $i$ is driven only if $p_{i} = 1$. The pattern register is rotated by one position at a slower update clock of frequency $f_{\\mathrm{step}}$ to realize a musical step sequencer. The musical tempo is $120$ beats per minute (BPM), and the sequencer uses $4$ steps per beat. For the purposes of avoiding visible flicker, assume that each LED that is logically on must be refreshed at least $95$ times per second. To prevent partial frames, the design requires that pattern updates occur only at whole-frame boundaries, where a frame is defined as one complete cycle of the ring counter through its $16$ states.\n\nStarting only from fundamental definitions and well-tested facts (for example, a ring counter with $N$ stages visits $N$ distinct states, one per clock pulse; $B$ beats per minute equals $B/60$ beats per second; and the refresh rate per LED in a time-multiplexed $1$-of-$N$ scheme equals the number of full selector cycles per second), and explicitly using the mapping from ring counter states to pattern bits described above, determine the minimum scan clock frequency $f_{\\mathrm{scan}}$ that simultaneously satisfies:\n- the per-LED refresh rate is at least $95$ Hz, and\n- the frame rate is an integer multiple of the step update frequency so that pattern rotation occurs exactly at frame boundaries.\n\nExpress your final $f_{\\mathrm{scan}}$ in $\\mathrm{kHz}$ and round your answer to four significant figures. Provide only the numerical value without units in your final answer box.", "solution": "The problem requires determining the minimum scan clock frequency, $f_{\\mathrm{scan}}$, for a digital system that satisfies two primary constraints: a minimum LED refresh rate and a specific timing synchronization between the display scan and pattern updates.\n\nFirst, we establish the parameters given in the problem. The system has a circular array of $N=16$ LEDs driven by a $16$-stage ring counter. The musical tempo is specified as $120$ beats per minute (BPM), with $4$ steps per beat. Let us denote this tempo as $T_m = 120$ BPM. The number of steps per beat is $S_b = 4$.\n\nThe frequency of the musical step updates, $f_{\\mathrm{step}}$, is the number of steps per second. We convert the tempo from beats per minute to beats per second (Hz).\n$$\n\\text{Tempo in Hz} = \\frac{T_m}{60 \\, \\mathrm{s/min}} = \\frac{120}{60} \\, \\mathrm{Hz} = 2 \\, \\mathrm{Hz}\n$$\nThe step update frequency is then the tempo in Hz multiplied by the number of steps per beat:\n$$\nf_{\\mathrm{step}} = (\\text{Tempo in Hz}) \\times S_b = (2 \\, \\mathrm{s}^{-1}) \\times 4 = 8 \\, \\mathrm{Hz}\n$$\n\nNext, we analyze the display scanning mechanism. A frame is defined as one complete cycle of the $16$-stage ring counter. The frequency of these frames is the frame rate, $f_{\\mathrm{frame}}$. The problem states that for a $1$-of-$N$ time-multiplexed display, the refresh rate of an individual LED, let's call it $R_{\\mathrm{LED}}$, is equal to the number of full selector cycles per second. Since a full selector cycle is a frame, the LED refresh rate is equal to the frame rate:\n$$\nR_{\\mathrm{LED}} = f_{\\mathrm{frame}}\n$$\nThe first constraint is that each LED must be refreshed at least $R_{\\mathrm{min}} = 95$ times per second to avoid visible flicker. This imposes a lower bound on the frame rate:\n$$\nf_{\\mathrm{frame}} \\ge R_{\\mathrm{min}} = 95 \\, \\mathrm{Hz}\n$$\n\nThe second constraint concerns the synchronization of pattern updates. The problem states that pattern updates, which occur at the frequency $f_{\\mathrm{step}}$, must happen only at whole-frame boundaries. This implies that the time interval between consecutive step updates, $T_{\\mathrm{step}} = 1/f_{\\mathrm{step}}$, must be an integer multiple of the frame period, $T_{\\mathrm{frame}} = 1/f_{\\mathrm{frame}}$. Let this integer be $k$, where $k \\ge 1$.\n$$\nT_{\\mathrm{step}} = k \\cdot T_{\\mathrm{frame}}, \\quad k \\in \\{1, 2, 3, \\dots\\}\n$$\nRewriting this relationship in terms of frequencies:\n$$\n\\frac{1}{f_{\\mathrm{step}}} = k \\cdot \\frac{1}{f_{\\mathrm{frame}}} \\implies f_{\\mathrm{frame}} = k \\cdot f_{\\mathrm{step}}\n$$\nThis means the frame rate must be an integer multiple of the step update frequency.\n\nWe must find the minimum $f_{\\mathrm{scan}}$, which corresponds to the minimum valid $f_{\\mathrm{frame}}$. The minimum $f_{\\mathrm{frame}}$ must satisfy both constraints simultaneously:\n1. $f_{\\mathrm{frame}} \\ge 95 \\, \\mathrm{Hz}$\n2. $f_{\\mathrm{frame}} = k \\cdot f_{\\mathrm{step}} = k \\cdot (8 \\, \\mathrm{Hz})$ for some integer $k \\ge 1$.\n\nCombining these, we get:\n$$\nk \\cdot (8 \\, \\mathrm{Hz}) \\ge 95 \\, \\mathrm{Hz}\n$$\nSolving for the integer $k$:\n$$\nk \\ge \\frac{95}{8} = 11.875\n$$\nSince $k$ must be an integer, the smallest value of $k$ that satisfies this condition is $k_{\\mathrm{min}} = \\lceil 11.875 \\rceil = 12$.\n\nNow, we can calculate the minimum valid frame rate, $f_{\\mathrm{frame,min}}$, using $k_{\\mathrm{min}}$:\n$$\nf_{\\mathrm{frame,min}} = k_{\\mathrm{min}} \\cdot f_{\\mathrm{step}} = 12 \\cdot (8 \\, \\mathrm{Hz}) = 96 \\, \\mathrm{Hz}\n$$\nThis frame rate satisfies both conditions: $96 \\, \\mathrm{Hz} \\ge 95 \\, \\mathrm{Hz}$ and it is an integer multiple ($12$) of $8 \\, \\mathrm{Hz}$.\n\nFinally, we determine the scan clock frequency, $f_{\\mathrm{scan}}$. The ring counter has $N=16$ stages, and it advances by one state for each pulse of the scan clock. A full frame requires the counter to cycle through all $N=16$ states. Therefore, $N$ clock pulses are needed for each frame. The relationship between the scan clock frequency and the frame rate is:\n$$\nf_{\\mathrm{scan}} = N \\cdot f_{\\mathrm{frame}}\n$$\nTo find the minimum required scan clock frequency, we use the minimum valid frame rate:\n$$\nf_{\\mathrm{scan,min}} = N \\cdot f_{\\mathrm{frame,min}} = 16 \\cdot (96 \\, \\mathrm{Hz})\n$$\nCalculating the product:\n$$\nf_{\\mathrm{scan,min}} = 1536 \\, \\mathrm{Hz}\n$$\nThe problem asks for the answer to be expressed in kilohertz (kHz) and rounded to four significant figures.\n$$\nf_{\\mathrm{scan,min}} = \\frac{1536}{1000} \\, \\mathrm{kHz} = 1.536 \\, \\mathrm{kHz}\n$$\nThe value $1.536$ has exactly four significant figures, so no further rounding is necessary.", "answer": "$$\\boxed{1.536}$$", "id": "3675857"}, {"introduction": "Shift registers are indispensable in modern data communications and storage systems for ensuring data integrity. A special configuration, the Linear Feedback Shift Register (LFSR), provides a hardware-efficient way to implement powerful error-detection schemes like the Cyclic Redundancy Check (CRC). This exercise delves into the elegant connection between the physical operation of an LFSR and its abstract mathematical model: polynomial division over a Galois Field, $GF(2)$. By working through this problem, you will learn to derive an incremental update formula for a sliding-window CRC, a vital optimization technique used in high-speed network protocols and file systems [@problem_id:3675958].", "problem": "Consider a byte-oriented sliding computation of a Cyclic Redundancy Check (CRC) implemented by a Linear Feedback Shift Register (LFSR) over the Galois field (GF(2)). Let the generator polynomial be $G(x) = x^{8} + x^{2} + x + 1$ (degree $8$), and let the window length be $W = 2$ bytes. A window of $W$ bytes is represented as a polynomial\n$$M(x) = \\sum_{j=0}^{W-1} Y_{j}(x) x^{8 j},$$\nwhere $Y_{j}(x)$ is the degree-at-most-$7$ polynomial encoding the $j$-th byte, with $Y_{0}(x)$ the newest byte and $Y_{W-1}(x)$ the oldest byte. The CRC remainder of the window is defined as the polynomial remainder $r = M(x) \\bmod G(x)$, with no initial nonzero value and no augmentation by $x^{n}$.\n\nYou receive a stream of bytes using the above conventions. The current window (oldest first) is the pair of bytes $(213, 46)$, where each byte value is interpreted as a polynomial in the natural way (most significant bit as the coefficient of $x^{7}$). A new byte with value $167$ arrives; the oldest byte $213$ exits the window, and the window slides to contain $(46, 167)$.\n\nStarting from the core definitions of polynomial arithmetic over GF(2), linearity of remainders modulo $G(x)$, and the LFSR interpretation of multiplication by $x$, derive an incremental update expression that reuses the previous remainder when one byte exits and another enters:\n- Express the updated remainder $r'$ of the new window $(46, 167)$ in terms of the previous remainder $r$ of $(213, 46)$, the generator $G(x)$, and precomputable constants that depend only on $G(x)$ and $W$.\n- Then, compute the numerical value of $r'$ for the given data. Express your final answer as a single integer in the range $0$ to $255$. No rounding is required, and no units should be included.", "solution": "We work over the Galois field (GF(2)), where addition and subtraction are both bitwise exclusive-or. A byte value $b \\in \\{0,\\dots,255\\}$ is mapped to the polynomial $B(x) = \\sum_{i=0}^{7} b_{i} x^{i}$, where $b_{i}$ is the $i$-th bit of $b$ and the most significant bit corresponds to $x^{7}$. For a window of $W$ bytes, the message polynomial is\n$$M(x) = \\sum_{j=0}^{W-1} Y_{j}(x) x^{8 j},$$\nwith $Y_{0}(x)$ the newest byte and $Y_{W-1}(x)$ the oldest. The CRC remainder is $r = M(x) \\bmod G(x)$.\n\nWhen the window slides by one byte, the oldest byte $Y_{W-1}(x)$ exits, the remaining $W-1$ bytes are shifted by one byte position (multiplication by $x^{8}$), and a new byte $Z(x)$ enters at position $j=0$. Therefore, the new window polynomial is\n$$M'(x) = x^{8}\\big(M(x) - Y_{W-1}(x) x^{8(W-1)}\\big) + Z(x).$$\nIn GF(2), subtraction equals addition, so this is\n$$M'(x) = x^{8} M(x) + Y_{W-1}(x) x^{8W} + Z(x).$$\nTaking remainders modulo $G(x)$ and using linearity and the compatibility of multiplication with modular reduction, we obtain\n$$r' \\equiv \\big(x^{8} \\bmod G(x)\\big)\\cdot \\big(M(x) \\bmod G(x)\\big) \\;+\\; \\big(x^{8W} \\bmod G(x)\\big)\\cdot Y_{W-1}(x) \\;+\\; Z(x) \\pmod{G(x)}.$$\nLet $A(x) \\equiv x^{8} \\bmod G(x)$ and $B(x) \\equiv x^{8W} \\bmod G(x)$. Then the incremental update formula that reuses the previous remainder $r$ is\n$$r' \\equiv A(x)\\, r \\;+\\; B(x)\\, Y_{W-1}(x) \\;+\\; Z(x) \\pmod{G(x)}.$$\n\nWe now compute $A(x)$ and $B(x)$ for $G(x) = x^{8} + x^{2} + x + 1$ and $W = 2$.\n\n1. Compute $A(x) = x^{8} \\bmod G(x)$. Since $x^{8} \\equiv x^{2} + x + 1 \\pmod{G(x)}$, we have $A(x) = x^{2} + x + 1$.\n\n2. Compute $B(x) = x^{16} \\bmod G(x)$. Using $x^{16} = \\big(x^{8}\\big)^{2}$ and squaring in GF(2),\n$$B(x) \\equiv \\big(x^{2} + x + 1\\big)^{2} = x^{4} + x^{2} + 1.$$\n\nNext, we compute the previous remainder $r$ for the current window $(213, 46)$ from first principles. With $W = 2$, the window polynomial is $M(x) = Y_{1}(x) x^{8} + Y_{0}(x)$. Equivalently, processing sequentially with the one-byte step effect $A(x)$,\n$$r = \\big(A(x)\\, Y_{1}(x) + Y_{0}(x)\\big) \\bmod G(x).$$\nWe represent the bytes as polynomials:\n- $213$ in binary is $11010101$, so $Y_{1}(x) = x^{7} + x^{6} + x^{4} + x^{2} + 1$.\n- $46$ in binary is $00101110$, so $Y_{0}(x) = x^{5} + x^{3} + x^{2} + x$.\n\nCompute $A(x) Y_{1}(x) = (x^{2} + x + 1)(x^{7} + x^{6} + x^{4} + x^{2} + 1)$:\n- $x^{2}$ times $Y_{1}(x)$ gives $x^{9} + x^{8} + x^{6} + x^{4} + x^{2}$.\n- $x$ times $Y_{1}(x)$ gives $x^{8} + x^{7} + x^{5} + x^{3} + x$.\n- $1$ times $Y_{1}(x)$ gives $x^{7} + x^{6} + x^{4} + x^{2} + 1$.\nSumming in GF(2) yields $x^{9} + x^{5} + x^{3} + x + 1$. Reduce $x^{9}$ using $x^{8} \\equiv x^{2} + x + 1$:\n$$x^{9} = x \\cdot x^{8} \\equiv x(x^{2} + x + 1) = x^{3} + x^{2} + x.$$\nTherefore $A(x) Y_{1}(x) \\equiv (x^{3} + x^{2} + x) + x^{5} + x^{3} + x + 1 = x^{5} + x^{2} + 1.$\n\nNow add $Y_{0}(x)$:\n$$r \\equiv \\big(x^{5} + x^{2} + 1\\big) + \\big(x^{5} + x^{3} + x^{2} + x\\big) = x^{3} + x + 1.$$\nThus $r$ corresponds to the byte value $11$.\n\nWe now perform the incremental update using the derived formula with the outgoing oldest byte $Y_{W-1}(x) = Y_{1}(x)$ and the incoming byte $Z(x)$ for the value $167$. The binary of $167$ is $10100111$, so $Z(x) = x^{7} + x^{5} + x^{2} + x + 1$.\n\nFirst, compute $A(x)\\, r$:\n$$A(x)\\, r = (x^{2} + x + 1)(x^{3} + x + 1).$$\nMultiply:\n- $x^{2}$ times gives $x^{5} + x^{3} + x^{2}$,\n- $x$ times gives $x^{4} + x^{2} + x$,\n- $1$ times gives $x^{3} + x + 1$.\nSumming yields $x^{5} + x^{4} + 1$.\n\nSecond, compute $B(x)\\, Y_{1}(x)$:\n$$B(x)\\, Y_{1}(x) = (x^{4} + x^{2} + 1)(x^{7} + x^{6} + x^{4} + x^{2} + 1).$$\nMultiply and sum:\n- $x^{4}$ times gives $x^{11} + x^{10} + x^{8} + x^{6} + x^{4}$,\n- $x^{2}$ times gives $x^{9} + x^{8} + x^{6} + x^{4} + x^{2}$,\n- $1$ times gives $x^{7} + x^{6} + x^{4} + x^{2} + 1$.\nThe sum is $x^{11} + x^{10} + x^{9} + x^{7} + x^{6} + x^{4} + 1$. Reduce degrees $\\ge 8$ using $x^{8} \\equiv x^{2} + x + 1$:\n- $x^{11} = x^{3} x^{8} \\equiv x^{5} + x^{4} + x^{3}$,\n- $x^{10} = x^{2} x^{8} \\equiv x^{4} + x^{3} + x^{2}$,\n- $x^{9} = x x^{8} \\equiv x^{3} + x^{2} + x$.\nSumming these with the remaining terms yields $x^{7} + x^{6} + x^{5} + x^{4} + x^{3} + x + 1$.\n\nFinally, apply the update:\n$$r' \\equiv \\big(x^{5} + x^{4} + 1\\big) + \\big(x^{7} + x^{6} + x^{5} + x^{4} + x^{3} + x + 1\\big) + \\big(x^{7} + x^{5} + x^{2} + x + 1\\big).$$\nSum the three polynomials term-by-term in GF(2). Combine the first two:\n$$(x^{5} + x^{4} + 1) + (x^{7} + x^{6} + x^{5} + x^{4} + x^{3} + x + 1) = x^{7} + x^{6} + x^{3} + x.$$\nNow add $Z(x)$:\n$$(x^{7} + x^{6} + x^{3} + x) + (x^{7} + x^{5} + x^{2} + x + 1) = x^{6} + x^{5} + x^{3} + x^{2} + 1.$$\nThus the updated remainder polynomial is $x^{6} + x^{5} + x^{3} + x^{2} + 1$, which corresponds to the byte value\n$$64 + 32 + 8 + 4 + 1 = 109.$$\n\nTherefore, the new window $(46, 167)$ has CRC remainder $109$ under the stated conventions.", "answer": "$$\\boxed{109}$$", "id": "3675958"}]}