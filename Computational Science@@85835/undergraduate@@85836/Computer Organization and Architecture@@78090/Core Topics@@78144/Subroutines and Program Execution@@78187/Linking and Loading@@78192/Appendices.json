{"hands_on_practices": [{"introduction": "Before a program can run, the linker must resolve all symbolic references, translating abstract names into concrete memory addresses. This exercise places you in the role of the linker, challenging you to implement the core arithmetic of address calculation and relocation for both absolute and program-counter-relative references. By simulating this process, you will gain a foundational understanding of how separate pieces of code are stitched together into a single, cohesive executable [@problem_id:3654640].", "problem": "You must write a complete, runnable program that simulates address assignment and relocation value computation as performed by a linker following a custom linker script. The program will operate purely on integer address arithmetic according to the accepted meanings of sections, symbols, and relocations used in the Executable and Linkable Format (ELF). The script fixes the base addresses of the code section ($\\text{TEXT}$) and the data section ($\\text{DATA}$), and the task is to compute absolute symbol addresses and relocation patch values. You must also verify whether certain relocation values fit in the intended machine word and validate alignment constraints.\n\nThe computational foundation must follow the core definitions used in system linkers:\n- Sections have base addresses prescribed by the linker script.\n- Symbols carry section-relative offsets.\n- Relocations describe how to compute a patch value to be written at a specific reference location. For absolute relocations, the target symbol’s absolute address is combined with an addend. For program-counter-relative relocations, the target symbol’s absolute address is compared to a reference address, and an addend and a bias (architecture-dependent) are accounted for to produce a signed value intended to fit a specified word width.\n\nUse the following parameters.\n\nSection bases and alignment:\n- $B_{\\text{text}} = 0x400000$.\n- $B_{\\text{data}} = 0x600000$.\n- Alignment requirement for both sections: $A_{\\text{align}} = 0x1000$.\n\nSymbols (each given by a section and a section-relative offset):\n- $s_{\\text{foo}}$: in $\\text{TEXT}$, offset $0x120$.\n- $s_{\\text{bar}}$: in $\\text{TEXT}$, offset $0x1FFE$.\n- $s_{\\text{baz}}$: in $\\text{DATA}$, offset $0x30$.\n- $s_{\\text{qux}}$: in $\\text{DATA}$, offset $0x10010$.\n\nRelocations (each specifies a type, a target symbol, the reference location section and offset, a bias $b$, and an addend $a$):\n- $R_1$: type $REL32$ (signed $32$-bit relative), target $s_{\\text{foo}}$, reference in $\\text{TEXT}$ at offset $0x200$, bias $b=4$, addend $a=0$.\n- $R_2$: type $REL32$, target $s_{\\text{bar}}$, reference in $\\text{TEXT}$ at offset $0x1FF0$, bias $b=4$, addend $a$ chosen so the final computed relocation value equals $2^{31}-1$.\n- $R_3$: type $ABS64$ (absolute $64$-bit), target $s_{\\text{baz}}$, reference in $\\text{DATA}$ at offset $0x8$ (reference location does not affect the absolute computation), addend $a=0x10$.\n- $R_4$: type $REL32$, target $s_{\\text{baz}}$, reference in $\\text{TEXT}$ at offset $0x300$, bias $b=4$, addend $a=0$.\n- $R_5$: type $REL32$, target $s_{\\text{qux}}$, reference in $\\text{TEXT}$ at offset $0x10$, bias $b=4$, addend $a$ chosen so the final computed relocation value equals $2^{31}$.\n- $R_6$: type $REL32$, target $s_{\\text{foo}}$, reference in $\\text{TEXT}$ at offset $0x11C$, bias $b=4$, addend $a=0$.\n\nComputation objectives:\n1. Compute the absolute addresses of the symbols $s_{\\text{foo}}, s_{\\text{bar}}, s_{\\text{baz}}, s_{\\text{qux}}$.\n2. For each relocation $R_i$, compute its patch value and verify whether the value fits its intended width.\n   - For $REL32$, the value must fit in a signed $32$-bit range, i.e., it must satisfy $-2^{31} \\le V \\le 2^{31}-1$.\n   - For $ABS64$, treat the computation as an unsigned $64$-bit absolute address plus addend; for this test suite, consider the fit check to be true if the computed value is representable in $64$-bit arithmetic.\n\n3. Validate section alignment: report whether $B_{\\text{text}}$ and $B_{\\text{data}}$ are multiples of $A_{\\text{align}}$.\n\nTest suite coverage requirements:\n- General case: $R_1$ and $R_4$ cover typical relative relocations across and within sections.\n- Boundary condition: $R_2$ must produce exactly $2^{31}-1$.\n- Edge case overflow: $R_5$ must produce exactly $2^{31}$, which does not fit a signed $32$-bit word, and must be flagged as not fitting.\n- Zero case: $R_6$ must produce exactly $0$.\n- Absolute relocation: $R_3$ covers $ABS64$ with a nonzero addend.\n- Alignment checks ensure that base addresses respect $A_{\\text{align}}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, in the exact order:\n$[A_{\\text{foo}},A_{\\text{bar}},A_{\\text{baz}},A_{\\text{qux}},V_1,F_1,V_2,F_2,V_3,F_3,V_4,F_4,V_5,F_5,V_6,F_6,Align_{\\text{text}},Align_{\\text{data}}]$\nwhere each $A_{\\cdot}$ is the absolute address of the symbol as an integer, each $V_i$ is the computed relocation value as an integer, each $F_i$ is a boolean fit indicator for the relocation ($1$ for true, $0$ for false), and $Align_{\\text{text}}$, $Align_{\\text{data}}$ are booleans indicating whether $B_{\\text{text}}$ and $B_{\\text{data}}$ are multiples of $A_{\\text{align}}$.\n\nNo user input is permitted; the program must embed the above parameters and produce the single required output line.", "solution": "The problem requires the computation of symbol addresses and relocation patch values, as would be performed by a linker, based on a given set of section bases, symbol offsets, and relocation entries. The validity of section alignment and the fit of relocation values within specified integer widths must also be checked. The problem is well-posed and grounded in the standard principles of computer architecture and systems programming.\n\nThe fundamental formulas governing the calculations are as follows:\n\n1.  **Absolute Symbol Address**: The absolute address of a symbol, denoted $A_{\\text{symbol}}$, is calculated by adding its section-relative offset, $O_{\\text{symbol}}$, to the base address of its section, $B_{\\text{section}}$.\n    $$A_{\\text{symbol}} = B_{\\text{section}} + O_{\\text{symbol}}$$\n\n2.  **Absolute Relocation Value ($ABS$ type)**: The patch value, $V$, for an absolute relocation is the absolute address of the target symbol, $A_{\\text{target}}$, plus a constant addend, $a$.\n    $$V = A_{\\text{target}} + a$$\n\n3.  **Relative Relocation Value ($REL$ type)**: The patch value, $V$, for a program-counter (PC) relative relocation is the difference between the target symbol's absolute address, $A_{\\text{target}}$, and the absolute address of the reference location, $P_{\\text{ref}}$, adjusted by an addend, $a$, and an architectural bias, $b$. The reference address $P_{\\text{ref}}$ is the sum of the reference section's base address, $B_{\\text{ref\\_section}}$, and the reference offset, $O_{\\text{ref}}$.\n    $$P_{\\text{ref}} = B_{\\text{ref\\_section}} + O_{\\text{ref}}$$\n    $$V = A_{\\text{target}} - P_{\\text{ref}} + a - b$$\n\nThe parameters provided in the problem statement are:\n\n**Section Parameters:**\n-   Base address of TEXT section: $B_{\\text{text}} = 0x400000$\n-   Base address of DATA section: $B_{\\text{data}} = 0x600000$\n-   Alignment requirement: $A_{\\text{align}} = 0x1000$\n\n**Symbol Definitions (Symbol: Section, Offset):**\n-   $s_{\\text{foo}}$: TEXT, $O_{\\text{foo}} = 0x120$\n-   $s_{\\text{bar}}$: TEXT, $O_{\\text{bar}} = 0x1FFE$\n-   $s_{\\text{baz}}$: DATA, $O_{\\text{baz}} = 0x30$\n-   $s_{\\text{qux}}$: DATA, $O_{\\text{qux}} = 0x10010$\n\n**Relocation Definitions:** The fit for a $REL32$ relocation requires the value $V$ to be in the range $[-2^{31}, 2^{31}-1]$.\n\n---\n\n**Step 1: Compute Absolute Symbol Addresses**\n\nUsing the formula $A = B + O$:\n-   $A_{\\text{foo}} = B_{\\text{text}} + O_{\\text{foo}} = 0x400000 + 0x120 = 0x400120 = 4,194,592$\n-   $A_{\\text{bar}} = B_{\\text{text}} + O_{\\text{bar}} = 0x400000 + 0x1FFE = 0x401FFE = 4,202,494$\n-   $A_{\\text{baz}} = B_{\\text{data}} + O_{\\text{baz}} = 0x600000 + 0x30 = 0x600030 = 6,291,504$\n-   $A_{\\text{qux}} = B_{\\text{data}} + O_{\\text{qux}} = 0x600000 + 0x10010 = 0x610010 = 6,357,008$\n\n---\n\n**Step 2: Compute Relocation Values and Check Fits**\n\n-   **Relocation $R_1$ ($REL32$):**\n    -   Target: $s_{\\text{foo}}$, so $A_{\\text{target}} = A_{\\text{foo}} = 0x400120$.\n    -   Reference: TEXT section, offset $0x200$, so $P_{\\text{ref}} = B_{\\text{text}} + 0x200 = 0x400200$.\n    -   Parameters: $a_1=0$, $b_1=4$.\n    -   Value: $V_1 = A_{\\text{foo}} - P_{\\text{ref}} + a_1 - b_1 = 0x400120 - 0x400200 - 4 = -0xE0 - 4 = -224 - 4 = -228$.\n    -   Fit ($F_1$): $-2^{31} \\le -228 \\le 2^{31}-1$. This is true. $F_1 = 1$.\n\n-   **Relocation $R_2$ ($REL32$):**\n    -   The problem states the addend is chosen such that the final value $V_2$ is $2^{31} - 1$.\n    -   Value: $V_2 = 2^{31} - 1 = 2,147,483,647$.\n    -   Fit ($F_2$): $-2^{31} \\le 2^{31}-1 \\le 2^{31}-1$. This is true. $F_2 = 1$.\n\n-   **Relocation $R_3$ ($ABS64$):**\n    -   Target: $s_{\\text{baz}}$, so $A_{\\text{target}} = A_{\\text{baz}} = 0x600030$.\n    -   Parameters: $a_3=0x10$.\n    -   Value: $V_3 = A_{\\text{baz}} + a_3 = 0x600030 + 0x10 = 0x600040 = 6,291,520$.\n    -   Fit ($F_3$): The value is representable as an unsigned $64$-bit integer. This is true. $F_3 = 1$.\n\n-   **Relocation $R_4$ ($REL32$):**\n    -   Target: $s_{\\text{baz}}$, so $A_{\\text{target}} = A_{\\text{baz}} = 0x600030$.\n    -   Reference: TEXT section, offset $0x300$, so $P_{\\text{ref}} = B_{\\text{text}} + 0x300 = 0x400300$.\n    -   Parameters: $a_4=0$, $b_4=4$.\n    -   Value: $V_4 = A_{\\text{baz}} - P_{\\text{ref}} + a_4 - b_4 = 0x600030 - 0x400300 - 4 = 0x1FFD30 - 4 = 2,096,432 - 4 = 2,096,428$.\n    -   Fit ($F_4$): $-2^{31} \\le 2,096,428 \\le 2^{31}-1$. This is true. $F_4 = 1$.\n\n-   **Relocation $R_5$ ($REL32$):**\n    -   The problem states the addend is chosen such that the final value $V_5$ is $2^{31}$.\n    -   Value: $V_5 = 2^{31} = 2,147,483,648$.\n    -   Fit ($F_5$): The condition is $-2^{31} \\le 2^{31} \\le 2^{31}-1$. This is false because $2^{31} > 2^{31}-1$. $F_5 = 0$.\n\n-   **Relocation $R_6$ ($REL32$):**\n    -   Target: $s_{\\text{foo}}$, so $A_{\\text{target}} = A_{\\text{foo}} = 0x400120$.\n    -   Reference: TEXT section, offset $0x11C$, so $P_{\\text{ref}} = B_{\\text{text}} + 0x11C = 0x40011C$.\n    -   Parameters: $a_6=0$, $b_6=4$.\n    -   Value: $V_6 = A_{\\text{foo}} - P_{\\text{ref}} + a_6 - b_6 = 0x400120 - 0x40011C - 4 = 0x4 - 4 = 0$.\n    -   Fit ($F_6$): $-2^{31} \\le 0 \\le 2^{31}-1$. This is true. $F_6 = 1$.\n\n---\n\n**Step 3: Validate Section Alignment**\n\nThe alignment requirement is that each section's base address must be a multiple of $A_{\\text{align}} = 0x1000$.\n\n-   **TEXT Section Alignment ($Align_{\\text{text}}$):**\n    -   Check if $B_{\\text{text}}$ is a multiple of $A_{\\text{align}}$.\n    -   $0x400000 \\pmod{0x1000} = 0$. The condition is met. $Align_{\\text{text}} = 1$.\n\n-   **DATA Section Alignment ($Align_{\\text{data}}$):**\n    -   Check if $B_{\\text{data}}$ is a multiple of $A_{\\text{align}}$.\n    -   $0x600000 \\pmod{0x1000} = 0$. The condition is met. $Align_{\\text{data}} = 1$.\n\n---\n\n**Consolidated Results**\n\nThe computed values are:\n-   $A_{\\text{foo}} = 4,194,592$\n-   $A_{\\text{bar}} = 4,202,494$\n-   $A_{\\text{baz}} = 6,291,504$\n-   $A_{\\text{qux}} = 6,357,008$\n-   $V_1 = -228$, $F_1 = 1$\n-   $V_2 = 2,147,483,647$, $F_2 = 1$\n-   $V_3 = 6,291,520$, $F_3 = 1$\n-   $V_4 = 2,096,428$, $F_4 = 1$\n-   $V_5 = 2,147,483,648$, $F_5 = 0$\n-   $V_6 = 0$, $F_6 = 1$\n-   $Align_{\\text{text}} = 1$\n-   $Align_{\\text{data}} = 1$", "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nint main(void) {\n    //\n    // Problem Parameters\n    //\n\n    // Section bases and alignment\n    const long long B_text = 0x400000;\n    const long long B_data = 0x600000;\n    const long long A_align = 0x1000;\n\n    // Symbol offsets\n    const long long O_foo = 0x120;\n    const long long O_bar = 0x1FFE;\n    const long long O_baz = 0x30;\n    const long long O_qux = 0x10010;\n\n    //\n    // Computation Step 1: Absolute Symbol Addresses\n    //\n    const long long A_foo = B_text + O_foo;\n    const long long A_bar = B_text + O_bar;\n    const long long A_baz = B_data + O_baz;\n    const long long A_qux = B_data + O_qux;\n\n    //\n    // Computation Step 2: Relocation Values and Fit Checks\n    //\n\n    // Define signed 32-bit integer limits, as <stdint.h> is not permitted.\n    // S32_MAX = 2^31 - 1\n    // S32_MIN = -2^31\n    const long long S32_MAX = 2147483647LL;\n    const long long S32_MIN = -2147483648LL;\n    \n    // R1: type REL32, target s_foo, ref in TEXT at 0x200, bias=4, addend=0\n    long long V1;\n    int F1;\n    {\n        const long long A_target = A_foo;\n        const long long P_ref = B_text + 0x200;\n        const long long addend = 0;\n        const int bias = 4;\n        V1 = A_target - P_ref + addend - bias;\n        F1 = (V1 >= S32_MIN && V1 <= S32_MAX);\n    }\n\n    // R2: type REL32, target s_bar, value is 2^31 - 1\n    const long long V2 = S32_MAX;\n    const int F2 = 1; // By definition, it's the max value, so it fits.\n\n    // R3: type ABS64, target s_baz, addend=0x10\n    long long V3;\n    int F3;\n    {\n        const long long A_target = A_baz;\n        const long long addend = 0x10;\n        V3 = A_target + addend;\n        F3 = 1; // As per problem, ABS64 fit is considered true.\n    }\n    \n    // R4: type REL32, target s_baz, ref in TEXT at 0x300, bias=4, addend=0\n    long long V4;\n    int F4;\n    {\n        const long long A_target = A_baz;\n        const long long P_ref = B_text + 0x300;\n        const long long addend = 0;\n        const int bias = 4;\n        V4 = A_target - P_ref + addend - bias;\n        F4 = (V4 >= S32_MIN && V4 <= S32_MAX);\n    }\n\n    // R5: type REL32, target s_qux, value is 2^31\n    const long long V5 = S32_MAX + 1;\n    const int F5 = 0; // By definition, 2^31 is one greater than the max signed 32-bit value.\n\n    // R6: type REL32, target s_foo, ref in TEXT at 0x11C, bias=4, addend=0\n    long long V6;\n    int F6;\n    {\n        const long long A_target = A_foo;\n        const long long P_ref = B_text + 0x11C;\n        const long long addend = 0;\n        const int bias = 4;\n        V6 = A_target - P_ref + addend - bias;\n        F6 = (V6 >= S32_MIN && V6 <= S32_MAX);\n    }\n    \n    //\n    // Computation Step 3: Alignment Validation\n    //\n    const int Align_text = (B_text % A_align == 0);\n    const int Align_data = (B_data % A_align == 0);\n\n    //\n    // Final Output Generation\n    //\n    printf(\"[%lld,%lld,%lld,%lld,%lld,%d,%lld,%d,%lld,%d,%lld,%d,%lld,%d,%lld,%d,%d,%d]\",\n        A_foo, A_bar, A_baz, A_qux,\n        V1, F1,\n        V2, F2,\n        V3, F3,\n        V4, F4,\n        V5, F5,\n        V6, F6,\n        Align_text, Align_data);\n\n    return EXIT_SUCCESS;\n}\n```", "id": "3654640"}, {"introduction": "Beyond resolving symbols, a static linker is also a master organizer, responsible for arranging code and data sections in memory efficiently. This practice explores the crucial concept of memory alignment, a hardware requirement that can force the linker to insert empty padding bytes between sections. Your task is to solve the puzzle of finding an optimal ordering for a set of sections that minimizes this wasted space, revealing a key optimization that impacts final program size [@problem_id:3654643].", "problem": "A static linker receives several input sections that must be packed contiguously into a single loadable segment in memory. For each section, the linker must honor the section’s alignment constraint: the section’s start address in memory must be congruent to zero modulo the section’s alignment. The segment’s base load address is chosen by the Operating System (OS) loader to be a page boundary. In this scenario, assume the Executable and Linkable Format (ELF) segment base address $A_{0}$ is $0$ and $A_{0}$ is aligned to $2^{12}$ bytes (that is, $4096$ bytes). The linker may reorder the sections arbitrarily.\n\nFundamental definitions and facts for this context:\n- A section with alignment $a$ must begin at an address $x$ satisfying $x \\equiv 0 \\pmod{a}$.\n- If the current end-of-segment offset is $o$ and the next section has alignment $a$, the linker may insert padding of $p \\ge 0$ bytes so that $o + p \\equiv 0 \\pmod{a}$; then the section is placed starting at $o + p$, and the new end-of-segment offset becomes $o + p + s$, where $s$ is the section’s size.\n- All alignments in this problem are powers of two and each divides $4096$, so $A_{0} \\equiv 0 \\pmod{a}$ for all given alignments.\n\nYou are given the six sections below; each section $i$ has size $s_{i}$ and an alignment requirement $a_{i}$, both in bytes:\n- Section $\\mathsf{X}$: $a_{\\mathsf{X}} = 1024$, $s_{\\mathsf{X}} = 1500$.\n- Section $\\mathsf{Y}$: $a_{\\mathsf{Y}} = 512$, $s_{\\mathsf{Y}} = 2048$.\n- Section $\\mathsf{Z}$: $a_{\\mathsf{Z}} = 256$, $s_{\\mathsf{Z}} = 700$.\n- Section $\\mathsf{U}$: $a_{\\mathsf{U}} = 128$, $s_{\\mathsf{U}} = 512$.\n- Section $\\mathsf{V}$: $a_{\\mathsf{V}} = 64$, $s_{\\mathsf{V}} = 1300$.\n- Section $\\mathsf{W}$: $a_{\\mathsf{W}} = 32$, $s_{\\mathsf{W}} = 1100$.\n\nStarting from $A_{0} = 0$, compute a final segment layout that minimizes the total padding inserted, subject to the alignment constraints. You must determine an ordering of sections and the offsets and paddings implied by that ordering. Then compute the minimal possible total padding (the sum of all pad bytes inserted between sections). Express the final answer in bytes. No rounding is required. The final answer must be a single number.", "solution": "The problem is to determine an ordering for a set of memory sections to minimize the total amount of padding required to satisfy alignment constraints. The goal is to find the minimum possible total padding.\n\nLet there be $n$ sections. For each section $i \\in \\{1, 2, \\dots, n\\}$, we are given a size $s_i$ and an alignment $a_i$. A section $i$ must be placed at a memory address $addr_i$ such that $addr_i \\equiv 0 \\pmod{a_i}$. The initial base address for the segment is $A_0 = 0$.\n\nWhen laying out the sections in a sequence, let the current offset (the address of the end of the previously placed section) be $o_{k-1}$. To place the next section, section $k$, we must find the smallest start address $addr_k$ such that $addr_k \\ge o_{k-1}$ and $addr_k \\equiv 0 \\pmod{a_k}$. The padding $p_k$ required is $p_k = addr_k - o_{k-1}$. The new offset becomes $o_k = addr_k + s_k = o_{k-1} + p_k + s_k$. The padding can be calculated using modular arithmetic:\n$$p_k = (a_k - (o_{k-1} \\pmod{a_k})) \\pmod{a_k}$$\nThe total padding for a given ordering of $n$ sections is $P_{\\text{total}} = \\sum_{k=1}^{n} p_k$.\n\nThe problem asks for an ordering that minimizes $P_{\\text{total}}$. Since all alignments $a_i$ are powers of two, a greedy algorithm is known to be optimal. This algorithm sorts the sections in descending order of their alignment values. The intuition is that sections with stricter alignment requirements (larger $a_i$) are placed first. This is advantageous because the initial offset is $0$, which satisfies any alignment constraint, and subsequent offsets are more likely to be \"naturally\" aligned to smaller alignment values, thus minimizing padding. An address aligned to $2^N$ is inherently aligned to $2^M$ for any $M < N$.\n\nThe given sections are:\n- Section $\\mathsf{X}$: $a_{\\mathsf{X}} = 1024$, $s_{\\mathsf{X}} = 1500$.\n- Section $\\mathsf{Y}$: $a_{\\mathsf{Y}} = 512$, $s_{\\mathsf{Y}} = 2048$.\n- Section $\\mathsf{Z}$: $a_{\\mathsf{Z}} = 256$, $s_{\\mathsf{Z}} = 700$.\n- Section $\\mathsf{U}$: $a_{\\mathsf{U}} = 128$, $s_{\\mathsf{U}} = 512$.\n- Section $\\mathsf{V}$: $a_{\\mathsf{V}} = 64$, $s_{\\mathsf{V}} = 1300$.\n- Section $\\mathsf{W}$: $a_{\\mathsf{W}} = 32$, $s_{\\mathsf{W}} = 1100$.\n\nSorting these sections by alignment in descending order yields the sequence: $\\mathsf{X}$, $\\mathsf{Y}$, $\\mathsf{Z}$, $\\mathsf{U}$, $\\mathsf{V}$, $\\mathsf{W}$. We will now calculate the total padding for this optimal ordering. The initial offset is $o_0 = A_0 = 0$. The total padding is initialized to $P = 0$.\n\n1.  **Place Section $\\mathsf{X}$**:\n    -   Current offset $o_{\\text{prev}} = 0$.\n    -   Alignment $a_{\\mathsf{X}} = 1024$. Size $s_{\\mathsf{X}} = 1500$.\n    -   Padding $p_{\\mathsf{X}} = (1024 - (0 \\pmod{1024})) \\pmod{1024} = 0$.\n    -   Start address of $\\mathsf{X}$ is $0 + 0 = 0$.\n    -   New offset $o_1 = 0 + 0 + 1500 = 1500$.\n    -   Total padding $P = 0 + 0 = 0$.\n\n2.  **Place Section $\\mathsf{Y}$**:\n    -   Current offset $o_{\\text{prev}} = o_1 = 1500$.\n    -   Alignment $a_{\\mathsf{Y}} = 512$. Size $s_{\\mathsf{Y}} = 2048$.\n    -   $1500 \\pmod{512} = 476$.\n    -   Padding $p_{\\mathsf{Y}} = (512 - 476) \\pmod{512} = 36$.\n    -   Start address of $\\mathsf{Y}$ is $1500 + 36 = 1536$. ($1536 = 3 \\times 512$).\n    -   New offset $o_2 = 1536 + 2048 = 3584$.\n    -   Total padding $P = 0 + 36 = 36$.\n\n3.  **Place Section $\\mathsf{Z}$**:\n    -   Current offset $o_{\\text{prev}} = o_2 = 3584$.\n    -   Alignment $a_{\\mathsf{Z}} = 256$. Size $s_{\\mathsf{Z}} = 700$.\n    -   $3584 \\pmod{256} = 0$ since $3584 = 14 \\times 256$.\n    -   Padding $p_{\\mathsf{Z}} = (256 - 0) \\pmod{256} = 0$.\n    -   Start address of $\\mathsf{Z}$ is $3584 + 0 = 3584$.\n    -   New offset $o_3 = 3584 + 700 = 4284$.\n    -   Total padding $P = 36 + 0 = 36$.\n\n4.  **Place Section $\\mathsf{U}$**:\n    -   Current offset $o_{\\text{prev}} = o_3 = 4284$.\n    -   Alignment $a_{\\mathsf{U}} = 128$. Size $s_{\\mathsf{U}} = 512$.\n    -   $4284 \\pmod{128} = 60$ since $4284 = 33 \\times 128 + 60$.\n    -   Padding $p_{\\mathsf{U}} = (128 - 60) \\pmod{128} = 68$.\n    -   Start address of $\\mathsf{U}$ is $4284 + 68 = 4352$. ($4352 = 34 \\times 128$).\n    -   New offset $o_4 = 4352 + 512 = 4864$.\n    -   Total padding $P = 36 + 68 = 104$.\n\n5.  **Place Section $\\mathsf{V}$**:\n    -   Current offset $o_{\\text{prev}} = o_4 = 4864$.\n    -   Alignment $a_{\\mathsf{V}} = 64$. Size $s_{\\mathsf{V}} = 1300$.\n    -   $4864 \\pmod{64} = 0$ since $4864 = 76 \\times 64$.\n    -   Padding $p_{\\mathsf{V}} = (64 - 0) \\pmod{64} = 0$.\n    -   Start address of $\\mathsf{V}$ is $4864 + 0 = 4864$.\n    -   New offset $o_5 = 4864 + 1300 = 6164$.\n    -   Total padding $P = 104 + 0 = 104$.\n\n6.  **Place Section $\\mathsf{W}$**:\n    -   Current offset $o_{\\text{prev}} = o_5 = 6164$.\n    -   Alignment $a_{\\mathsf{W}} = 32$. Size $s_{\\mathsf{W}} = 1100$.\n    -   $6164 \\pmod{32} = 20$ since $6164 = 192 \\times 32 + 20$.\n    -   Padding $p_{\\mathsf{W}} = (32 - 20) \\pmod{32} = 12$.\n    -   Start address of $\\mathsf{W}$ is $6164 + 12 = 6176$. ($6176 = 193 \\times 32$).\n    -   New offset $o_6 = 6176 + 1100 = 7276$.\n    -   Total padding $P = 104 + 12 = 116$.\n\nThe final layout results in a total size of $7276$ bytes. The sum of the section sizes is $1500+2048+700+512+1300+1100 = 7160$ bytes. The total padding is $7276 - 7160 = 116$ bytes, which matches the sum of the individually calculated padding values: $0 + 36 + 0 + 68 + 0 + 12 = 116$.\n\nThe minimal possible total padding is $116$ bytes.", "answer": "$$\\boxed{116}$$", "id": "3654643"}, {"introduction": "Modern applications are rarely monolithic; they are typically assembled at runtime from an executable and numerous shared libraries. This modularity, however, introduces new challenges, as dependencies must be correctly resolved when the program loads. This exercise presents a classic runtime failure—an \"undefined symbol\" error—and asks you to diagnose the issue within the dependency graph of shared objects, teaching you to reason like a dynamic linker and apply the principle of \"link against what you use\" [@problem_id:3654570].", "problem": "An application is built for the Executable and Linkable Format (ELF), and the runtime dynamic linker is used to resolve external symbols at load time. Let $G(V,E)$ be the directed dependency graph of the loadable objects, where $V$ is the set of vertices and $E$ is the set of directed edges. Each vertex denotes a loadable object: the main executable $X$ and shared libraries $L_A$, $L_B$, $L_C$. An edge $(u,v) \\in E$ indicates that object $u$ contains a Dynamic Table (DT) entry `DT_NEEDED` naming $v$. The current graph is\n$$\nV = \\{X, L_A, L_B, L_C\\}, \\quad E = \\{(X, L_A), (X, L_B)\\}.\n$$\nLibrary $L_A$ contains an undefined relocation for a symbol $s$, and $s$ is defined only in $L_C$. At runtime, the dynamic loader constructs the link map by loading $X$ and recursively loading all objects named by `DT_NEEDED`. The loader then resolves undefined symbols by searching the global scope of the loaded objects; it does not open additional libraries solely to satisfy a reference, except through entries already present in `DT_NEEDED` or via mechanisms such as the environment variable $LD_PRELOAD$.\n\nThe system fails at load time with the error “undefined symbol: $s$” attributed to $L_A$. Assume the directories containing $L_A$, $L_B$, and $L_C$ are accessible (for instance via a suitable environment variable $LD_LIBRARY_PATH$), and there are no symbol version mismatches; the problem stems from the dependency structure.\n\nWhich change most directly repairs the dependency so that the dynamic loader deterministically resolves $s$ in compliance with the rule “link against what you use,” and without relying on non-deterministic environment overrides? Choose the best option.\n\n- A. Add the missing edge $(L_A, L_C)$ by relinking $L_A$ to include `DT_NEEDED` for $L_C$ (for example, passing $-lC$ when producing $L_A$), so that $L_C$ is loaded whenever $L_A$ is loaded.\n\n- B. Add a runtime library search path (RPATH) entry to $L_A$ pointing to the directory of $L_C$, without modifying `DT_NEEDED` for any object.\n\n- C. Add the edge $(L_B, L_C)$ by relinking $L_B$ to include `DT_NEEDED` for $L_C$, relying on $L_B$ to cause $L_C$ to be loaded transitively.\n\n- D. Reorder the `DT_NEEDED` entries of $X$ so that $L_B$ precedes $L_A$, expecting $s$ to be found through search-order effects among already loaded libraries.", "solution": "The problem statement describes a common runtime linking failure in systems using the Executable and Linkable Format (ELF). Before providing a solution, the validity of the problem statement must be established.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The system involves an executable $X$ and three shared libraries, $L_A$, $L_B$, and $L_C$. These form the set of vertices $V = \\{X, L_A, L_B, L_C\\}$ in a dependency graph $G(V,E)$.\n- A directed edge $(u,v) \\in E$ signifies that object $u$ has a `DT_NEEDED` entry for object $v$.\n- The initial dependency graph has edges $E = \\{(X, L_A), (X, L_B)\\}$. This means $X$ depends on $L_A$ and $L_B$. There are no other specified `DT_NEEDED` dependencies.\n- Library $L_A$ requires a symbol $s$ (it contains an undefined relocation for $s$).\n- Symbol $s$ is defined exclusively in library $L_C$.\n- The dynamic loader begins with the executable $X$ and recursively loads all libraries specified in `DT_NEEDED` entries to form a link map. It resolves undefined symbols by searching the global scope of all objects within this link map.\n- The system fails at load time with the error \"undefined symbol: $s$\".\n- It is assumed that the filesystem locations of all libraries are known to the loader (e.g., via `LD_LIBRARY_PATH`).\n- The question asks for the change that most directly repairs the dependency, adheres to the rule \"link against what you use,\" and is deterministic.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding:** The problem is firmly grounded in the established principles of dynamic linking and loading on modern Unix-like operating systems. The concepts of ELF, `DT_NEEDED` tables, dependency graphs, symbol resolution, and runtime errors are standard and factually correct components of computer organization and operating systems theory and practice.\n- **Well-Posed:** The problem is well-posed. The initial state, the process (dynamic loading), and the outcome (failure) are clearly described and are consistent with one another. The goal is to find a modification that resolves the failure while satisfying a specific, objective software engineering principle (\"link against what you use\").\n- **Objectivity:** The problem is stated in precise, objective technical terms. There is no subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It presents a realistic, technically sound, and well-defined scenario in software engineering and systems programming. I will proceed with a full solution.\n\n### Principle-Based Derivation and Solution\n\nThe core of the problem lies in the process of dynamic symbol resolution by the ELF loader (e.g., `ld.so` on Linux systems).\n\n1.  **Loading Phase:** The loader starts with the main executable, $X$. It parses the `DT_NEEDED` entries in $X$'s Dynamic Table. Based on the given edges $E = \\{(X, L_A), (X, L_B)\\}$, the loader identifies direct dependencies on $L_A$ and $L_B$. It proceeds to load these two libraries into memory. The loader would then recursively examine the `DT_NEEDED` entries of $L_A$ and $L_B$. Since no such outgoing edges from $L_A$ or $L_B$ are specified, the loading process terminates. The final set of loaded objects, known as the link map, is $\\{X, L_A, L_B\\}$. Crucially, library $L_C$ is not loaded because there is no dependency path from $X$ to $L_C$.\n\n2.  **Relocation Phase:** After all necessary objects are loaded, the loader resolves symbolic references. Library $L_A$ contains an unresolved reference to symbol $s$. The loader attempts to find a definition for $s$ by searching the symbol tables of all objects in the link map that have been loaded into the global scope. This search scope consists of $X$, $L_A$, and $L_B$.\n\n3.  **Failure Analysis:** The problem states that $s$ is defined only in $L_C$. As $L_C$ is not part of the link map, the loader's search for $s$ fails. This correctly explains the observed runtime error: \"undefined symbol: $s$\".\n\nTo fix this, the dependency structure must be altered to ensure $L_C$ is loaded into the process's link map. The solution must also satisfy the principle of \"link against what you use,\" which mandates that an object should explicitly declare its dependencies. Since $L_A$ uses symbol $s$ from $L_C$, $L_A$ should declare a dependency on $L_C$.\n\n### Option-by-Option Analysis\n\n**A. Add the missing edge $(L_A, L_C)$ by relinking $L_A$ to include `DT_NEEDED` for $L_C$ (for example, passing $-lC$ when producing $L_A$), so that $L_C$ is loaded whenever $L_A$ is loaded.**\nThis action modifies the dependency graph by adding the edge $(L_A, L_C)$.\n- **Loading Effect:** When the loader processes $X$, it loads $L_A$. It then recursively inspects $L_A$'s dependencies and finds the new `DT_NEEDED` entry for $L_C$. Consequently, the loader loads $L_C$. The final link map becomes $\\{X, L_A, L_B, L_C\\}$.\n- **Resolution Effect:** When resolving the reference to $s$ from $L_A$, the loader will search the link map and find the definition of $s$ in $L_C$. The resolution succeeds.\n- **Principle Compliance:** The object that uses the symbol ($L_A$) is modified to declare the dependency on the object that provides it ($L_C$). This is the textbook application of the \"link against what you use\" principle. This creates a robust and self-documenting dependency structure.\n**Verdict:** **Correct**. This is the most direct, correct, and robust solution that aligns with best practices.\n\n**B. Add a runtime library search path (RPATH) entry to $L_A$ pointing to the directory of $L_C$, without modifying `DT_NEEDED` for any object.**\nThis action modifies the metadata of $L_A$ that influences *where* the loader searches for libraries, but not *which* libraries it searches for.\n- **Loading Effect:** The `RPATH` (or `RUNPATH`) of an object is used to find the files corresponding to its `DT_NEEDED` entries. It does not introduce new dependencies. The dependency graph remains $E = \\{(X, L_A), (X, L_B)\\}$. Since there is no `DT_NEEDED` entry for $L_C$ in the dependency chain starting from $X$, $L_C$ will not be loaded.\n- **Resolution Effect:** The link map remains $\\{X, L_A, L_B\\}$. The symbol $s$ is still undefined. The error persists.\n**Verdict:** **Incorrect**. This option fundamentally misunderstands the purpose of `RPATH` versus `DT_NEEDED`.\n\n**C. Add the edge $(L_B, L_C)$ by relinking $L_B$ to include `DT_NEEDED` for $L_C$, relying on $L_B$ to cause $L_C$ to be loaded transitively.**\nThis action modifies the dependency graph by adding the edge $(L_B, L_C)$.\n- **Loading Effect:** The loader loads $X$, then its dependencies $L_A$ and $L_B$. When processing $L_B$, it finds the `DT_NEEDED` entry for $L_C$ and loads it. The final link map is $\\{X, L_A, L_B, L_C\\}$.\n- **Resolution Effect:** The symbol $s$ is now available from $L_C$, so the reference from $L_A$ will be resolved successfully. The program will run.\n- **Principle Compliance:** This solution violates the \"link against what you use\" principle. The dependency on $L_C$ is required by $L_A$, but it is declared by an unrelated object, $L_B$. This creates a fragile, indirect dependency. If a future version of the executable $X$ no longer needs $L_B$, the application would break again because the transitive dependency that brought in $L_C$ would disappear, even though $L_A$'s need for $L_C$ has not changed.\n**Verdict:** **Incorrect**. While it technically resolves the crash, it does so by violating the specified design principle, leading to a brittle and difficult-to-maintain system.\n\n**D. Reorder the `DT_NEEDED` entries of $X$ so that $L_B$ precedes $L_A$, expecting $s$ to be found through search-order effects among already loaded libraries.**\nThis action changes the order in which the loader might process the direct dependencies of $X$.\n- **Loading Effect:** The set of loaded libraries remains the same: $\\{X, L_A, L_B\\}$. The order in which they are added to the link map might change, which can affect the symbol search order. However, the fundamental problem is that $L_C$ is not loaded at all.\n- **Resolution Effect:** Regardless of the search order among $X$, $L_A$, and $L_B$, the definition for symbol $s$ is not present in any of them. The loader will still fail to find $s$.\n**Verdict:** **Incorrect**. This solution is irrelevant to the root cause of the problem, which is a missing library in the link map, not the search order within it.", "answer": "$$\\boxed{A}$$", "id": "3654570"}]}