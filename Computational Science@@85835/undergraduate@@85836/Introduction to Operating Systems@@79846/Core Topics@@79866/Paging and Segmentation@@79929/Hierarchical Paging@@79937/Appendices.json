{"hands_on_practices": [{"introduction": "To begin, let's explore the fundamental task of mapping a contiguous block of virtual memory. This exercise focuses on how a simple two-level page table hierarchy partitions the address space and how many top-level entries are required to cover a memory region of a given size. Mastering this basic calculation [@problem_id:3647771] is the first step toward understanding the resource costs associated with virtual memory management.", "problem": "Consider a two-level hierarchical paging scheme used by a virtual memory subsystem. The top-level structure is a Page Directory (PD), and the second-level structure is a Page Table (PT). The Page Directory (PD) has entries, each of which references exactly one Page Table (PT). Each Page Table (PT) contains $E_{2}$ entries. Each Page Table entry maps one page of size $P$ bytes. By construction, a single Page Directory entry thus governs a contiguous span of virtual addresses of size $A$, where $A = E_{2} \\times P$. The spans governed by Page Directory entries are non-overlapping and partition the virtual address space at boundaries that are integer multiples of $A$.\n\nSuppose a process needs to map a contiguous virtual memory region of size $R$ bytes. The regionâ€™s start address is aligned to $A$, meaning the start address is an integer multiple of $A$. Any Page Directory entry that covers at least one byte of the region must exist (it may reference a partially filled Page Table), and Page Directory entries are counted toward the total even if their corresponding Page Tables are only partially used. Assume $R > 0$ and $A > 0$.\n\nUsing only the definitions of hierarchical paging given above and the fact that alignment to $A$ places the start of the region on a Page Directory boundary, derive a closed-form analytic expression for the minimal number of top-level entries, denoted $n_{\\text{top}}$, required to cover the entire region. Express your final answer solely in terms of $R$ and $A$. No numerical rounding is required.", "solution": "The user has requested a solution to a problem concerning hierarchical paging in a virtual memory system. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n- The system uses a two-level hierarchical paging scheme.\n- The top-level structure is a Page Directory (PD).\n- The second-level structure is a Page Table (PT).\n- Each PD entry references one PT.\n- Each PT contains $E_{2}$ entries.\n- Each PT entry maps one page of size $P$ bytes.\n- A single PD entry governs a contiguous span of virtual addresses of size $A$, where $A = E_{2} \\times P$.\n- PD entry spans are non-overlapping and partition the virtual address space at boundaries that are integer multiples of $A$.\n- A process needs to map a contiguous virtual memory region of size $R$ bytes.\n- The region's start address is aligned to $A$ (i.e., it is an integer multiple of $A$).\n- Any PD entry that covers at least one byte of the region must exist.\n- $R > 0$ and $A > 0$.\n- The goal is to find a closed-form expression for the minimal number of top-level entries, $n_{\\text{top}}$, required to cover the region, in terms of $R$ and $A$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n\n- **Scientifically Grounded**: The problem describes a simplified but standard model of hierarchical paging, a fundamental concept in operating systems. The relationship between page directories, page tables, page sizes, and address space partitioning is consistent with established computer architecture and OS principles. The problem is scientifically sound.\n- **Well-Posed**: The problem asks for the minimal number of entries required under a clear set of constraints (contiguous region, specific size $R$, and start address alignment to $A$). The parameters $R$ and $A$ are given, and the objective is to find $n_{\\text{top}}$. The alignment constraint simplifies the scenario, ensuring that a unique, minimal solution exists.\n- **Objective**: The problem is stated using precise, technical language (e.g., \"contiguous virtual memory region,\" \"aligned to $A$,\" \"non-overlapping\"). There are no subjective or ambiguous terms.\n- **Incomplete or Contradictory Setup**: The problem provides all necessary information to determine the number of top-level entries. The size of the region to be mapped ($R$) and the size of the address space spanned by a single top-level entry ($A$) are the only variables needed for the calculation, and both are provided symbolically. The alignment of the start address is a critical, non-contradictory constraint.\n- **Unrealistic or Infeasible**: The model is an abstraction, but it is not physically impossible or scientifically implausible. It represents a valid, albeit idealized, memory management scenario.\n- **Other Flaws**: The problem is not metaphorical, trivial, tautological, or outside the realm of scientific verifiability. It is a formal problem that requires logical deduction based on the provided model.\n\n### Step 3: Verdict and Action\nThe problem is valid. A rigorous derivation of the solution can proceed.\n\n### Solution Derivation\n\nThe objective is to find the minimum number of top-level page directory entries, $n_{\\text{top}}$, required to map a contiguous memory region of size $R$ bytes.\n\nLet the virtual address space be represented by a number line starting at address $0$. The top-level page directory entries partition this space into contiguous, non-overlapping blocks. Each block, or span, is of size $A$. The boundaries of these spans occur at addresses $0, A, 2A, 3A, \\dots, kA, \\dots$, for non-negative integers $k$. The $k$-th such span (for $k \\ge 0$) covers the virtual address range $[kA, (k+1)A)$.\n\nThe problem states that the memory region to be mapped is of size $R$ and its start address is aligned to $A$. Let the start address of the region be $S$. The alignment constraint implies that $S$ is an integer multiple of $A$. Therefore, we can write $S = m \\cdot A$ for some non-negative integer $m$.\n\nThe contiguous region of size $R$ starting at address $S$ occupies the half-open interval of virtual addresses $[S, S+R)$. Substituting $S = m \\cdot A$, the region is $[m \\cdot A, m \\cdot A + R)$.\n\nWe need to find the minimum number of top-level entries, $n_{\\text{top}}$, required to cover this entire region. Since the region starts exactly at the boundary of a span governed by a page directory entry, the first entry required is the one that covers the span beginning at $S = m \\cdot A$.\n\nLet $n_{\\text{top}}$ be the number of consecutive top-level entries used. These entries will start with the one for the span $[m \\cdot A, (m+1)A)$ and proceed for a total of $n_{\\text{top}}$ entries. The total virtual address range covered by these $n_{\\text{top}}$ consecutive entries will be from the start address $S$ to $S + n_{\\text{top}} \\cdot A$. That is, they cover the address interval $[S, S + n_{\\text{top}} \\cdot A)$.\n\nFor the entire region of size $R$ to be mapped, the address range it occupies, $[S, S+R)$, must be a subset of the address range covered by the allocated page directory entries, $[S, S + n_{\\text{top}} \\cdot A)$.\n$$[S, S+R) \\subseteq [S, S + n_{\\text{top}} \\cdot A)$$\nThis subset condition is satisfied if and only if the end of the region's interval is less than or equal to the end of the covered interval.\n$$S + R \\le S + n_{\\text{top}} \\cdot A$$\nSubtracting $S$ from both sides of the inequality yields:\n$$R \\le n_{\\text{top}} \\cdot A$$\nSince the problem specifies $A > 0$, we can divide by $A$ without changing the direction of the inequality:\n$$n_{\\text{top}} \\ge \\frac{R}{A}$$\nThe variable $n_{\\text{top}}$ represents a count of page directory entries, so it must be an integer. We are looking for the *minimal* number of entries, which means we must find the smallest integer $n_{\\text{top}}$ that satisfies the condition $n_{\\text{top}} \\ge \\frac{R}{A}$.\n\nBy definition, the smallest integer greater than or equal to a real number $x$ is the ceiling of $x$, denoted $\\lceil x \\rceil$.\nTherefore, the minimal number of top-level entries required is:\n$$n_{\\text{top}} = \\left\\lceil \\frac{R}{A} \\right\\rceil$$\nThis expression is a closed-form analytical expression solely in terms of $R$ and $A$, as required.", "answer": "$$\n\\boxed{\\left\\lceil \\frac{R}{A} \\right\\rceil}\n$$", "id": "3647771"}, {"introduction": "Building on the basics, this next practice delves into the memory overhead of a realistic, four-level page table structure. We will investigate how the operating system dynamically allocates page tables as new memory mappings are created, a concept best understood by tracing the paths through the page table tree. By calculating the cost of adding several 'alias' mappings [@problem_id:3647750], you will see firsthand how shared parent tables reduce memory consumption and why creating new address space branches can be costly.", "problem": "A process runs on a system that uses hierarchical paging with the following properties: a virtual address has $48$ bits; the page size is $4\\,\\mathrm{KiB}$; there are $4$ page-table levels; each page table occupies exactly one page of size $4\\,\\mathrm{KiB}$; and each page table entry (PTE) is $8$ bytes. The four level indices extracted from a virtual address are $i_4, i_3, i_2, i_1$, each $9$ bits wide, followed by a $12$-bit page offset.\n\nAssume the Level-$4$ root page table page for the process already exists independent of any mappings discussed here, and its existence must not be counted in any memory totals. A single baseline mapping has been established to a physical page $P$ at the virtual address with indices $(i_4,i_3,i_2,i_1)=(100,200,300,400)$. This baseline mapping has already allocated any missing page-table pages along that path. No other page-table structures are present in the process.\n\nYou now introduce additional alias mappings of the same physical page $P$ at the following virtual addresses, listed by their $(i_4,i_3,i_2,i_1)$ index tuples:\n- Group $\\mathrm{A}$: $(100,200,300,401)$, $(100,200,300,402)$, $(100,200,300,403)$.\n- Group $\\mathrm{B}$: $(100,200,301,10)$, $(100,200,302,11)$.\n- Group $\\mathrm{C}$: $(100,201,0,1)$, $(100,202,2,3)$.\n- Group $\\mathrm{D}$: $(101,0,0,0)$, $(102,7,8,9)$.\n\nUse the following foundational facts about hierarchical paging:\n- A mapping of one virtual page requires a valid chain of page tables down to the leaf PTE at Level $1$ along its $(i_4,i_3,i_2,i_1)$ path.\n- If a required page table at some level does not yet exist, the operating system allocates a new page of size $4\\,\\mathrm{KiB}$ for that page table and installs a pointer to it in the parent level.\n- Occupying a PTE slot itself does not allocate additional memory beyond the page table page that contains it.\n\nCompute the total additional page-table memory, in bytes, allocated by introducing all of the alias mappings in Groups $\\mathrm{A}$ through $\\mathrm{D}$, relative to the baseline single mapping. Do not count the Level-$4$ root page table page, since it exists regardless of these mappings. Express your final answer in bytes as an exact integer. No rounding is required.", "solution": "The problem requires the calculation of the total additional memory allocated for page tables when introducing a set of new virtual-to-physical address mappings. The system employs a $4$-level hierarchical paging scheme. We must first establish the initial state of the page-table structure and then analyze the memory cost of adding each new mapping.\n\nThe system parameters are as follows:\n- Virtual address size: $48$ bits.\n- Page size: $4\\,\\mathrm{KiB}$, which is equal to $4 \\times 1024 = 4096$ bytes.\n- Page table levels: $4$.\n- Page table size: One page, i.e., $4096$ bytes.\n- Page Table Entry (PTE) size: $8$ bytes.\n- Virtual address structure: A $48$-bit address is divided into four $9$-bit indices $(i_4, i_3, i_2, i_1)$ and a $12$-bit offset. The index fields correctly sum to $4 \\times 9 = 36$ bits, and adding the $12$-bit offset gives $36+12=48$ bits. Each $9$-bit index can address $2^9 = 512$ entries. The number of PTEs that can fit in a single page table is $\\frac{4096 \\text{ bytes/table}}{8 \\text{ bytes/PTE}} = 512$ entries/table. The parameters are consistent.\n\nThe core principle of hierarchical paging is that a virtual address is translated by traversing a tree of page tables. To map a virtual page defined by the indices $(i_4, i_3, i_2, i_1)$, a valid path must exist. This requires:\n1.  A Level-4 (L4) page table (the root, which is given to exist).\n2.  A PTE at index $i_4$ in the L4 table pointing to an existing Level-3 (L3) page table.\n3.  A PTE at index $i_3$ in that L3 table pointing to an existing Level-2 (L2) page table.\n4.  A PTE at index $i_2$ in that L2 table pointing to an existing Level-1 (L1) page table.\n5.  A PTE at index $i_1$ in that L1 table pointing to the final physical page frame.\n\nIf at any step the required page table does not exist, a new page of $4096$ bytes must be allocated for it. We are asked to find the *additional* memory allocated, relative to a baseline mapping.\n\n**Baseline State**\nA single mapping exists for the virtual address with indices $(i_4, i_3, i_2, i_1) = (100, 200, 300, 400)$. This implies the existence of the following page tables, which were allocated to establish this path. The L4 root table is excluded from memory cost calculations per the problem statement.\n- The PTE at index $i_4=100$ in the L4 root table points to an L3 page table. Let's call this $PT_3(100)$. This required one page allocation.\n- The PTE at index $i_3=200$ in $PT_3(100)$ points to an L2 page table, $PT_2(100, 200)$. This required a second page allocation.\n- The PTE at index $i_2=300$ in $PT_2(100, 200)$ points to an L1 page table, $PT_1(100, 200, 300)$. This required a third page allocation.\nThe baseline configuration has thus already allocated $3 \\times 4096$ bytes of memory. We calculate the new allocations relative to this state.\n\n**Analysis of Additional Mappings**\n\nWe will analyze each group of new mappings to determine the number of new page tables that must be allocated.\n\n**Group $\\mathrm{A}$: Mappings $(100, 200, 300, 401)$, $(100, 200, 300, 402)$, and $(100, 200, 300, 403)$**\nAll three mappings share the same indices $i_4=100$, $i_3=200$, and $i_2=300$ as the baseline mapping. This means they traverse the same path through the L4, L3, and L2 tables, arriving at the same L1 page table, $PT_1(100, 200, 300)$, which already exists. The new mappings only require populating PTEs at indices $401$, $402$, and $403$ within this existing L1 table. Since occupying a PTE slot does not allocate a new page, no additional page-table memory is required for this group.\n*Number of new page tables for Group $\\mathrm{A}$: $0$.*\n\n**Group $\\mathrm{B}$: Mappings $(100, 200, 301, 10)$ and $(100, 200, 302, 11)$**\n- For the mapping $(100, 200, 301, 10)$: The path prefix $(i_4, i_3) = (100, 200)$ is shared with the baseline. Thus, the L2 page table $PT_2(100, 200)$ is reused. However, the index $i_2=301$ is new at this level (the baseline used $i_2=300$). Therefore, a new L1 page table, $PT_1(100, 200, 301)$, must be allocated. This is $1$ new page table.\n- For the mapping $(100, 200, 302, 11)$: Similarly, the L2 table $PT_2(100, 200)$ is reused. The index $i_2=302$ is also new. This necessitates the allocation of another new L1 page table, $PT_1(100, 200, 302)$. This is a second new page table.\n*Number of new page tables for Group $\\mathrm{B}$: $2$.*\n\n**Group $\\mathrm{C}$: Mappings $(100, 201, 0, 1)$ and $(100, 202, 2, 3)$**\n- For the mapping $(100, 201, 0, 1)$: The path prefix $i_4=100$ is shared, so the L3 table $PT_3(100)$ is reused. The index $i_3=201$ is new. This requires the allocation of a new L2 page table, $PT_2(100, 201)$. Following this new path, the index $i_2=0$ is also necessarily new for this branch, so a new L1 page table, $PT_1(100, 201, 0)$, must also be allocated. This mapping requires $2$ new page tables (one L2, one L1).\n- For the mapping $(100, 202, 2, 3)$: The path again reuses $PT_3(100)$. The index $i_3=202$ is new and different from both $200$ and $201$. This requires allocating a new L2 page table, $PT_2(100, 202)$. Subsequently, a new L1 page table, $PT_1(100, 202, 2)$, must be allocated. This mapping also requires $2$ new page tables.\n*Number of new page tables for Group $\\mathrm{C}$: $2 + 2 = 4$.*\n\n**Group $\\mathrm{D}$: Mappings $(101, 0, 0, 0)$ and $(102, 7, 8, 9)$**\n- For the mapping $(101, 0, 0, 0)$: The index $i_4=101$ is new at the L4 level. This requires creating an entirely new branch of the page table hierarchy.\n    1. A new L3 page table, $PT_3(101)$, must be allocated.\n    2. A new L2 page table, $PT_2(101, 0)$, must be allocated.\n    3. A new L1 page table, $PT_1(101, 0, 0)$, must be allocated.\n    This mapping requires $3$ new page tables.\n- For the mapping $(102, 7, 8, 9)$: The index $i_4=102$ is also new, and distinct from $100$ and $101$. This requires another completely separate branch.\n    1. A new L3 page table, $PT_3(102)$, must be allocated.\n    2. A new L2 page table, $PT_2(102, 7)$, must be allocated.\n    3. A new L1 page table, $PT_1(102, 7, 8)$, must be allocated.\n    This mapping also requires $3$ new page tables.\n*Number of new page tables for Group $\\mathrm{D}$: $3 + 3 = 6$.*\n\n**Total Additional Memory Calculation**\nThe total number of newly allocated page tables is the sum of the counts from each group:\nTotal new tables = $0 (\\text{Group A}) + 2 (\\text{Group B}) + 4 (\\text{Group C}) + 6 (\\text{Group D}) = 12$.\n\nEach new page table consumes one page of memory, which is $4096$ bytes.\nTotal additional memory = (Total new tables) $\\times$ (size of one page)\nTotal additional memory = $12 \\times 4096$ bytes\nTotal additional memory = $49152$ bytes.\n\nThis is the total additional memory allocated for page tables to accommodate all the new alias mappings.", "answer": "$$\n\\boxed{49152}\n$$", "id": "3647750"}, {"introduction": "Our final practice moves from understanding the mechanics of hierarchical paging to optimizing its performance using a key feature of modern CPUs: mixed page sizes. Using larger pages, or 'huge pages,' can significantly reduce the number of page table entries and improve translation speed, but they come with strict alignment and contiguity requirements. This exercise [@problem_id:3647756] challenges you to devise an optimal mapping strategy for a large, partially-filled memory region, balancing the use of different page sizes to minimize page table overhead.", "problem": "An operating system (OS) uses four-level hierarchical paging on a $64$-bit architecture and supports mixed page sizes from the set $S=\\{4 \\text{ KiB}, 2 \\text{ MiB}, 1 \\text{ GiB}\\}$. A page of size $p \\in S$ may be used as a leaf mapping only if its virtual base address is aligned to $p$ bytes and the entire $p$-byte region is mapped contiguously without holes. Consider mapping a contiguous virtual region of size $R$ bytes, where a fraction $f$ (expressed as a decimal in $[0,1)$) of the region is intentionally left unmapped as holes at the base-page granularity of $4 \\text{ KiB}$. Assume the following:\n\n- $R$ is a positive integer multiple of $4 \\text{ KiB}$, that is, $R = n \\cdot 4 \\text{ KiB}$ for some integer $n \\geq 1$.\n- The number of unmapped base pages is exactly $f n$, so $(1-f)R$ is also a multiple of $4 \\text{ KiB}$.\n- The OS may choose the placement of the holes within the region and the base virtual address of the region. In particular, it may align the region base on a $1 \\text{ GiB}$ boundary to minimize the number of leaf entries.\n- A Page Table Entry (PTE) is defined here as a single leaf mapping at its respective level: a $4 \\text{ KiB}$ PTE at level $1$, a $2 \\text{ MiB}$ PTE at level $2$, or a $1 \\text{ GiB}$ PTE at level $3$. Do not count non-leaf entries.\n\nUsing only fundamental properties of hierarchical paging (alignment and contiguity constraints) and the sizes $4 \\text{ KiB}=2^{12}$ bytes, $2 \\text{ MiB}=2^{21}$ bytes, and $1 \\text{ GiB}=2^{30}$ bytes, derive a closed-form expression, in terms of $R$ and $f$, for the minimal possible number of leaf PTEs required to map the region subject to the constraints above. You may use the floor function $\\lfloor \\cdot \\rfloor$, the ceiling function $\\lceil \\cdot \\rceil$, and the modulo operation $\\bmod$. Your final answer must be a single analytic expression. No rounding is required, and no units should be included in the final expression.", "solution": "The problem is valid as it is scientifically grounded in the principles of operating system memory management, specifically hierarchical paging and the use of large pages (huge pages). It is well-posed, objective, and contains sufficient information to derive a unique, minimal solution.\n\nThe objective is to find the minimum number of leaf page table entries (PTEs) required to map a virtual memory region of size $R$. The region contains unmapped holes, and the total size of the mapped portion is $(1-f)R$. The OS has the freedom to choose the base virtual address of the region and the location of the holes. To minimize the number of PTEs, one must maximize the use of the largest available page sizes.\n\nThe available page sizes are $P_3 = 1\\,\\text{GiB} = 2^{30}$ bytes, $P_2 = 2\\,\\text{MiB} = 2^{21}$ bytes, and $P_1 = 4\\,\\text{KiB} = 2^{12}$ bytes. A page of size $p$ can only be used if the virtual address block of size $p$ is aligned on a $p$-byte boundary and is fully mapped (contiguous, with no holes).\n\nTo satisfy these constraints while minimizing the PTE count, the optimal strategy for the OS is as follows:\n1.  **Align the Region**: The OS should align the base of the entire virtual region of size $R$ on a $1\\,\\text{GiB}$ boundary. This ensures that the start of the region is optimally aligned for the largest page size, $P_3$. Let us assume the region starts at virtual address $0$ for simplicity, without loss of generality.\n2.  **Consolidate Holes**: To maximize the size of contiguous mapped memory, the OS should place all the unmapped $4\\,\\text{KiB}$ pages (the holes) together. The best placement is at the end of the region. This creates a single, contiguous block of mapped memory at the beginning of the region. Any other arrangement of holes would fragment the mapped region, breaking potential large page mappings and thus increasing the total number of PTEs.\n\nWith this strategy, we have a single contiguous mapped block of size $M = (1-f)R$. This block starts at virtual address $0$ (which is $1\\,\\text{GiB}$-aligned) and extends to address $M-1$. The remainder of the region, from address $M$ to $R-1$, is unmapped.\n\nNow, we can tile this mapped block of size $M$ greedily, using the largest pages first.\n\n**Step 1: Mapping with $1\\,\\text{GiB}$ pages ($P_3$)**\nThe mapped region is $[0, M-1]$. Since this region starts at a $1\\,\\text{GiB}$-aligned address, we can use as many full $1\\,\\text{GiB}$ pages as possible. The number of such pages, $N_3$, is the number of times $P_3$ fits entirely into $M$.\n$$N_3 = \\left\\lfloor \\frac{M}{P_3} \\right\\rfloor = \\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor$$\nThese pages cover the memory range from address $0$ to $N_3 \\cdot P_3 - 1$.\n\n**Step 2: Mapping with $2\\,\\text{MiB}$ pages ($P_2$)**\nAfter mapping with $1\\,\\text{GiB}$ pages, the remaining memory to be mapped has a size of $M_{\\text{rem},2} = M - N_3 \\cdot P_3 = M \\bmod P_3$. This remaining block starts at address $N_3 \\cdot P_3$, which is aligned to $P_3 = 2^9 \\cdot P_2$, and thus is also aligned to $P_2$. We can greedily tile this remaining block with $2\\,\\text{MiB}$ pages. The number of $2\\,\\text{MiB}$ pages, $N_2$, is:\n$$N_2 = \\left\\lfloor \\frac{M_{\\text{rem},2}}{P_2} \\right\\rfloor = \\left\\lfloor \\frac{M \\bmod P_3}{P_2} \\right\\rfloor = \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor$$\nThese pages cover the memory range from address $N_3 \\cdot P_3$ to $N_3 \\cdot P_3 + N_2 \\cdot P_2 - 1$.\n\n**Step 3: Mapping with $4\\,\\text{KiB}$ pages ($P_1$)**\nAfter using $2\\,\\text{MiB}$ pages, the final remaining portion of memory to be mapped has a size of $M_{\\text{rem},1} = M_{\\text{rem},2} - N_2 \\cdot P_2 = M_{\\text{rem},2} \\bmod P_2$. Since $P_3$ is an integer multiple of $P_2$, it follows that $(M \\bmod P_3) \\bmod P_2 = M \\bmod P_2$. So, $M_{\\text{rem},1} = M \\bmod P_2$. This remaining block starts at an address $N_3 \\cdot P_3 + N_2 \\cdot P_2$, which is aligned to $P_2=2^9 \\cdot P_1$, and is thus also aligned to $P_1$. The problem statement guarantees that the total mapped memory, $M=(1-f)R$, is an integer multiple of the base page size $P_1 = 4\\,\\text{KiB}$. Since the portions covered by $P_3$ and $P_2$ pages are also multiples of $P_1$, the remaining size $M_{\\text{rem},1}$ must also be a multiple of $P_1$. Therefore, this final remainder can be perfectly tiled with $4\\,\\text{KiB}$ pages. The number of such pages, $N_1$, is:\n$$N_1 = \\frac{M_{\\text{rem},1}}{P_1} = \\frac{M \\bmod P_2}{P_1} = \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}$$\n\n**Total Number of Leaf PTEs**\nThe minimal total number of leaf PTEs, $N_{PTE}$, is the sum of the PTEs from each level:\n$$N_{PTE} = N_3 + N_2 + N_1$$\nSubstituting the expressions derived above, we obtain the final closed-form expression in terms of $R$ and $f$:\n$$N_{PTE}(R, f) = \\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor + \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor + \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}$$\nThis expression represents the result of the optimal greedy tiling strategy, which is enabled by the OS's ability to align the memory region and consolidate the unmapped holes.", "answer": "$$\\boxed{\\left\\lfloor \\frac{(1-f)R}{2^{30}} \\right\\rfloor + \\left\\lfloor \\frac{((1-f)R) \\bmod 2^{30}}{2^{21}} \\right\\rfloor + \\frac{((1-f)R) \\bmod 2^{21}}{2^{12}}}$$", "id": "3647756"}]}